"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-node_modules_esri_calcite-components_dist_esm_calcite-color-picker_3_entry_js"],{

/***/ "./node_modules/@esri/calcite-components/dist/esm/calcite-color-picker_3.entry.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/esm/calcite-color-picker_3.entry.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calcite_color_picker: () => (/* binding */ ColorPicker),
/* harmony export */   calcite_color_picker_hex_input: () => (/* binding */ ColorPickerHexInput),
/* harmony export */   calcite_color_picker_swatch: () => (/* binding */ ColorPickerSwatch)
/* harmony export */ });
/* harmony import */ var _index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-86faef9c.js */ "./node_modules/@esri/calcite-components/dist/esm/index-86faef9c.js");
/* harmony import */ var _dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-ed00a585.js */ "./node_modules/@esri/calcite-components/dist/esm/dom-ed00a585.js");
/* harmony import */ var _utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils-a44d0b30.js */ "./node_modules/@esri/calcite-components/dist/esm/utils-a44d0b30.js");
/* harmony import */ var _interactive_cbd8a6dc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interactive-cbd8a6dc.js */ "./node_modules/@esri/calcite-components/dist/esm/interactive-cbd8a6dc.js");
/* harmony import */ var _key_61f82ddb_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./key-61f82ddb.js */ "./node_modules/@esri/calcite-components/dist/esm/key-61f82ddb.js");
/* harmony import */ var _loadable_b17396e0_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loadable-b17396e0.js */ "./node_modules/@esri/calcite-components/dist/esm/loadable-b17396e0.js");
/* harmony import */ var _locale_6e783cf0_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./locale-6e783cf0.js */ "./node_modules/@esri/calcite-components/dist/esm/locale-6e783cf0.js");
/* harmony import */ var _math_922e37ec_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./math-922e37ec.js */ "./node_modules/@esri/calcite-components/dist/esm/math-922e37ec.js");
/* harmony import */ var _t9n_0bcdca54_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./t9n-0bcdca54.js */ "./node_modules/@esri/calcite-components/dist/esm/t9n-0bcdca54.js");
/* harmony import */ var _throttle_f4d8c9e4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./throttle-f4d8c9e4.js */ "./node_modules/@esri/calcite-components/dist/esm/throttle-f4d8c9e4.js");
/* harmony import */ var _guid_21fecfa4_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./guid-21fecfa4.js */ "./node_modules/@esri/calcite-components/dist/esm/guid-21fecfa4.js");
/* harmony import */ var _resources_cf82388c_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./resources-cf82388c.js */ "./node_modules/@esri/calcite-components/dist/esm/resources-cf82388c.js");
/* harmony import */ var _browser_ece29da7_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./browser-ece29da7.js */ "./node_modules/@esri/calcite-components/dist/esm/browser-ece29da7.js");
/* harmony import */ var _observers_71d332db_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./observers-71d332db.js */ "./node_modules/@esri/calcite-components/dist/esm/observers-71d332db.js");
/* harmony import */ var _debounce_85958bb1_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./debounce-85958bb1.js */ "./node_modules/@esri/calcite-components/dist/esm/debounce-85958bb1.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.0.0
 */
















function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire();
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var colorName$1 = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var isArrayish = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var simpleSwizzle = createCommonjsModule(function (module) {



var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};
});

var colorString = createCommonjsModule(function (module) {
/* MIT license */


var hasOwnProperty = Object.hasOwnProperty;

var reverseNames = Object.create(null);

// create a list of reverse color names
for (var name in colorName$1) {
	if (hasOwnProperty.call(colorName$1, name)) {
		reverseNames[colorName$1[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var keyword = /^(\w+)$/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		if (!hasOwnProperty.call(colorName$1, match[1])) {
			return null;
		}

		rgb = colorName$1[match[1]];
		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = simpleSwizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = simpleSwizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = simpleSwizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = simpleSwizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = simpleSwizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = Math.round(num).toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}
});

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

/* MIT license */
/* eslint-disable no-mixed-operators */


// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(colorName)) {
	reverseKeywords[colorName[key]] = key;
}

const convert$1 = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

var conversions = convert$1;

// Hide .channels and .labels properties
for (const model of Object.keys(convert$1)) {
	if (!('channels' in convert$1[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert$1[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert$1[model].labels.length !== convert$1[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert$1[model];
	delete convert$1[model].channels;
	delete convert$1[model].labels;
	Object.defineProperty(convert$1[model], 'channels', {value: channels});
	Object.defineProperty(convert$1[model], 'labels', {value: labels});
}

convert$1.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert$1.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert$1.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert$1.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert$1.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert$1.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(colorName)) {
		const value = colorName[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert$1.keyword.rgb = function (keyword) {
	return colorName[keyword];
};

convert$1.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert$1.rgb.lab = function (rgb) {
	const xyz = convert$1.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$1.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert$1.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert$1.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert$1.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert$1.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert$1.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert$1.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert$1.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$1.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert$1.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert$1.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert$1.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert$1.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
};

convert$1.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert$1.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert$1.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert$1.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$1.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert$1.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert$1.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert$1.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert$1.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert$1.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert$1.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert$1.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert$1.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert$1.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert$1.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert$1.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert$1.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert$1.gray.hsv = convert$1.gray.hsl;

convert$1.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert$1.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert$1.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert$1.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$1.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var colorConvert = convert;

const skippedModels = [
	// To be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// Gray conflicts with some method names, and has its own method defined.
	'gray',

	// Shouldn't really be in color-convert either...
	'hex',
];

const hashedModelKeys = {};
for (const model of Object.keys(colorConvert)) {
	hashedModelKeys[[...colorConvert[model].labels].sort().join('')] = model;
}

const limiters = {};

function Color(object, model) {
	if (!(this instanceof Color)) {
		return new Color(object, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in colorConvert)) {
		throw new Error('Unknown model: ' + model);
	}

	let i;
	let channels;

	if (object == null) { // eslint-disable-line no-eq-null,eqeqeq
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (object instanceof Color) {
		this.model = object.model;
		this.color = [...object.color];
		this.valpha = object.valpha;
	} else if (typeof object === 'string') {
		const result = colorString.get(object);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + object);
		}

		this.model = result.model;
		channels = colorConvert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (object.length > 0) {
		this.model = model || 'rgb';
		channels = colorConvert[this.model].channels;
		const newArray = Array.prototype.slice.call(object, 0, channels);
		this.color = zeroArray(newArray, channels);
		this.valpha = typeof object[channels] === 'number' ? object[channels] : 1;
	} else if (typeof object === 'number') {
		// This is always RGB - can be converted later on.
		this.model = 'rgb';
		this.color = [
			(object >> 16) & 0xFF,
			(object >> 8) & 0xFF,
			object & 0xFF,
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		const keys = Object.keys(object);
		if ('alpha' in object) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof object.alpha === 'number' ? object.alpha : 0;
		}

		const hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(object));
		}

		this.model = hashedModelKeys[hashedKeys];

		const {labels} = colorConvert[this.model];
		const color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(object[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// Perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = colorConvert[this.model].channels;
		for (i = 0; i < channels; i++) {
			const limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString() {
		return this.string();
	},

	toJSON() {
		return this[this.model]();
	},

	string(places) {
		let self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
		return colorString.to[self.model](args);
	},

	percentString(places) {
		const self = this.rgb().round(typeof places === 'number' ? places : 1);
		const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
		return colorString.to.rgb.percent(args);
	},

	array() {
		return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
	},

	object() {
		const result = {};
		const {channels} = colorConvert[this.model];
		const {labels} = colorConvert[this.model];

		for (let i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray() {
		const rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject() {
		const rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round(places) {
		places = Math.max(places || 0, 0);
		return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
	},

	alpha(value) {
		if (value !== undefined) {
			return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
		}

		return this.valpha;
	},

	// Rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => ((value % 360) + 360) % 360),

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(95.047)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(108.833)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		return colorConvert[this.model].keyword(this.color);
	},

	hex(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	hexa(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		const rgbArray = this.rgb().round().color;

		let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
		if (alphaHex.length === 1) {
			alphaHex = '0' + alphaHex;
		}

		return colorString.to.hex(rgbArray) + alphaHex;
	},

	rgbNumber() {
		const rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity() {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		const rgb = this.rgb().color;

		const lum = [];
		for (const [i, element] of rgb.entries()) {
			const chan = element / 255;
			lum[i] = (chan <= 0.04045) ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast(color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		const lum1 = this.luminosity();
		const lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level(color2) {
		// https://www.w3.org/TR/WCAG/#contrast-enhanced
		const contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark() {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		const rgb = this.rgb().color;
		const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;
		return yiq < 128;
	},

	isLight() {
		return !this.isDark();
	},

	negate() {
		const rgb = this.rgb();
		for (let i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}

		return rgb;
	},

	lighten(ratio) {
		const hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken(ratio) {
		const hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate(ratio) {
		const hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate(ratio) {
		const hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten(ratio) {
		const hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken(ratio) {
		const hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale() {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		const rgb = this.rgb().color;
		const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(value, value, value);
	},

	fade(ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer(ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate(degrees) {
		const hsl = this.hsl();
		let hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix(mixinColor, weight) {
		// Ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		if (!mixinColor || !mixinColor.rgb) {
			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
		}

		const color1 = mixinColor.rgb();
		const color2 = this.rgb();
		const p = weight === undefined ? 0.5 : weight;

		const w = 2 * p - 1;
		const a = color1.alpha() - color2.alpha();

		const w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2;
		const w2 = 1 - w1;

		return Color.rgb(
			w1 * color1.red() + w2 * color2.red(),
			w1 * color1.green() + w2 * color2.green(),
			w1 * color1.blue() + w2 * color2.blue(),
			color1.alpha() * p + color2.alpha() * (1 - p));
	},
};

// Model conversion methods and static constructors
for (const model of Object.keys(colorConvert)) {
	if (skippedModels.includes(model)) {
		continue;
	}

	const {channels} = colorConvert[model];

	// Conversion methods
	Color.prototype[model] = function (...args) {
		if (this.model === model) {
			return new Color(this);
		}

		if (args.length > 0) {
			return new Color(args, model);
		}

		return new Color([...assertArray(colorConvert[this.model][model].raw(this.color)), this.valpha], model);
	};

	// 'static' construction methods
	Color[model] = function (...args) {
		let color = args[0];
		if (typeof color === 'number') {
			color = zeroArray(args, channels);
		}

		return new Color(color, model);
	};
}

function roundTo(number, places) {
	return Number(number.toFixed(places));
}

function roundToPlace(places) {
	return function (number) {
		return roundTo(number, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	for (const m of model) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	}

	model = model[0];

	return function (value) {
		let result;

		if (value !== undefined) {
			if (modifier) {
				value = modifier(value);
			}

			result = this[model]();
			result.color[channel] = value;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(value) {
	return Array.isArray(value) ? value : [value];
}

function zeroArray(array, length) {
	for (let i = 0; i < length; i++) {
		if (typeof array[i] !== 'number') {
			array[i] = 0;
		}
	}

	return array;
}

var color = Color;

const CSS$2 = {
  channel: "channel",
  channels: "channels",
  colorField: "color-field",
  colorFieldScope: "scope--color-field",
  colorMode: "color-mode",
  colorModeContainer: "color-mode-container",
  container: "container",
  control: "control",
  controlAndScope: "control-and-scope",
  controlSection: "control-section",
  deleteColor: "delete-color",
  header: "header",
  hexAndChannelsGroup: "hex-and-channels-group",
  hexOptions: "color-hex-options",
  hueScope: "scope--hue",
  hueSlider: "hue-slider",
  opacityScope: "scope--opacity",
  opacitySlider: "opacity-slider",
  preview: "preview",
  previewAndSliders: "preview-and-sliders",
  saveColor: "save-color",
  savedColor: "saved-color",
  savedColors: "saved-colors",
  savedColorsButtons: "saved-colors-buttons",
  savedColorsSection: "saved-colors-section",
  scope: "scope",
  section: "section",
  slider: "slider",
  sliders: "sliders",
  splitSection: "section--split",
};
const DEFAULT_COLOR$1 = color("#007AC2");
const DEFAULT_STORAGE_KEY_PREFIX = "calcite-color-";
const RGB_LIMITS = {
  r: 255,
  g: 255,
  b: 255,
};
const HSV_LIMITS = {
  h: 360,
  s: 100,
  v: 100,
};
// 0 and 360 represent the same value, so we limit the hue to 359
const HUE_LIMIT_CONSTRAINED = HSV_LIMITS.h - 1;
const OPACITY_LIMITS = {
  min: 0,
  max: 100,
};
const DIMENSIONS = {
  s: {
    slider: {
      height: 12,
      width: 104,
    },
    colorField: {
      height: 80,
      width: 160,
    },
    thumb: {
      radius: 10,
    },
  },
  m: {
    slider: {
      height: 12,
      width: 204,
    },
    colorField: {
      height: 150,
      width: 272,
    },
    thumb: {
      radius: 10,
    },
  },
  l: {
    slider: {
      height: 12,
      width: 384,
    },
    colorField: {
      height: 200,
      width: 464,
    },
    thumb: {
      radius: 10,
    },
  },
};
const SCOPE_SIZE = 1;

const colorPickerCss = ":host([disabled]){cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}:host([disabled]) *,:host([disabled]) ::slotted(*){pointer-events:none}:host{display:inline-block;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-normal)}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}:host([scale=s]){--calcite-color-picker-spacing:8px}:host([scale=s]) .container{inline-size:160px}:host([scale=s]) .saved-colors{gap:0.25rem;grid-template-columns:repeat(auto-fill, 20px)}:host([scale=m]){--calcite-color-picker-spacing:12px}:host([scale=m]) .container{inline-size:272px}:host([scale=l]){--calcite-color-picker-spacing:16px;font-size:var(--calcite-font-size--1);line-height:1rem}:host([scale=l]) .container{inline-size:464px}:host([scale=l]) .section:first-of-type{padding-block-start:var(--calcite-color-picker-spacing)}:host([scale=l]) .saved-colors{grid-template-columns:repeat(auto-fill, 32px)}:host([scale=l]) .control-section{flex-wrap:nowrap;align-items:baseline;flex-wrap:wrap}:host([scale=l]) .color-hex-options{display:flex;flex-shrink:1;flex-direction:column;justify-content:space-around}:host([scale=l]) .color-mode-container{flex-shrink:3}.container{background-color:var(--calcite-color-foreground-1);display:inline-block;border:1px solid var(--calcite-color-border-1)}.control-and-scope{position:relative;display:flex;cursor:pointer;touch-action:none}.scope{pointer-events:none;position:absolute;z-index:var(--calcite-z-index);block-size:1px;inline-size:1px;border-radius:9999px;background-color:transparent;font-size:var(--calcite-font-size--1);outline-color:transparent}.scope:focus{outline:2px solid var(--calcite-color-brand);outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          );outline-offset:11px}.hex-and-channels-group{inline-size:100%}.hex-and-channels-group,.control-section{display:flex;flex-direction:row;flex-wrap:wrap}.section{padding-block:0 var(--calcite-color-picker-spacing);padding-inline:var(--calcite-color-picker-spacing)}.section:first-of-type{padding-block-start:var(--calcite-color-picker-spacing)}.sliders{display:flex;flex-direction:column;justify-content:space-between;margin-inline-start:var(--calcite-color-picker-spacing)}.preview-and-sliders{display:flex;align-items:center;padding:var(--calcite-color-picker-spacing)}.color-hex-options,.section--split{flex-grow:1}.header{display:flex;align-items:center;justify-content:space-between;color:var(--calcite-color-text-1)}.color-mode-container{padding-block-start:var(--calcite-color-picker-spacing)}.channels{display:flex;row-gap:0.125rem}.channel[data-channel-index=\"3\"]{inline-size:159px}:host([scale=s]) .channels{flex-wrap:wrap}:host([scale=s]) .channel{flex-basis:30%;flex-grow:1}:host([scale=s]) .channel[data-channel-index=\"3\"]{inline-size:unset;margin-inline-start:unset}:host([scale=l]) .channel[data-channel-index=\"3\"]{inline-size:131px}.saved-colors{display:grid;gap:0.5rem;padding-block-start:var(--calcite-color-picker-spacing);grid-template-columns:repeat(auto-fill, 24px)}.saved-colors-buttons{display:flex}.saved-color{outline-offset:0;outline-color:transparent;cursor:pointer}.saved-color:focus{outline:2px solid var(--calcite-color-brand);outline-offset:2px}.saved-color:hover{transition:outline-color var(--calcite-internal-animation-timing-fast) ease-in-out;outline:2px solid var(--calcite-color-border-2);outline-offset:2px}:host([hidden]){display:none}[hidden]{display:none}";

const throttleFor60FpsInMs = 16;
const ColorPicker = class {
  constructor(hostRef) {
    (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.calciteColorPickerChange = (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "calciteColorPickerChange", 6);
    this.calciteColorPickerInput = (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "calciteColorPickerInput", 6);
    this.internalColorUpdateContext = null;
    this.mode = _utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.C.HEX;
    this.shiftKeyChannelAdjustment = 0;
    this.handleTabActivate = (event) => {
      this.channelMode = event.currentTarget.getAttribute("data-color-mode");
      this.updateChannelsFromColor(this.color);
    };
    this.handleColorFieldScopeKeyDown = (event) => {
      const { key } = event;
      const arrowKeyToXYOffset = {
        ArrowUp: { x: 0, y: -10 },
        ArrowRight: { x: 10, y: 0 },
        ArrowDown: { x: 0, y: 10 },
        ArrowLeft: { x: -10, y: 0 },
      };
      if (arrowKeyToXYOffset[key]) {
        event.preventDefault();
        this.scopeOrientation = key === "ArrowDown" || key === "ArrowUp" ? "vertical" : "horizontal";
        this.captureColorFieldColor(this.colorFieldScopeLeft + arrowKeyToXYOffset[key].x || 0, this.colorFieldScopeTop + arrowKeyToXYOffset[key].y || 0, false);
      }
    };
    this.handleHueScopeKeyDown = (event) => {
      const modifier = event.shiftKey ? 10 : 1;
      const { key } = event;
      const arrowKeyToXOffset = {
        ArrowUp: 1,
        ArrowRight: 1,
        ArrowDown: -1,
        ArrowLeft: -1,
      };
      if (arrowKeyToXOffset[key]) {
        event.preventDefault();
        const delta = arrowKeyToXOffset[key] * modifier;
        const hue = this.baseColorFieldColor.hue();
        const color = this.baseColorFieldColor.hue(hue + delta);
        this.internalColorSet(color, false);
      }
    };
    this.handleHexInputChange = (event) => {
      event.stopPropagation();
      const { allowEmpty, color: color$1 } = this;
      const input = event.target;
      const hex = input.value;
      if (allowEmpty && !hex) {
        this.internalColorSet(null);
        return;
      }
      const normalizedHex = color$1 && (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.n)((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(color$1, (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.c)(this.mode)));
      if (hex !== normalizedHex) {
        this.internalColorSet(color(hex));
      }
    };
    this.handleSavedColorSelect = (event) => {
      const swatch = event.currentTarget;
      this.internalColorSet(color(swatch.color));
    };
    this.handleChannelInput = (event) => {
      const input = event.currentTarget;
      const channelIndex = Number(input.getAttribute("data-channel-index"));
      const isAlphaChannel = channelIndex === 3;
      const limit = isAlphaChannel
        ? OPACITY_LIMITS.max
        : this.channelMode === "rgb"
          ? RGB_LIMITS[Object.keys(RGB_LIMITS)[channelIndex]]
          : HSV_LIMITS[Object.keys(HSV_LIMITS)[channelIndex]];
      let inputValue;
      if (this.allowEmpty && !input.value) {
        inputValue = "";
      }
      else {
        const value = Number(input.value);
        const adjustedValue = value + this.shiftKeyChannelAdjustment;
        const clamped = (0,_math_922e37ec_js__WEBPACK_IMPORTED_MODULE_7__.c)(adjustedValue, 0, limit);
        inputValue = clamped.toString();
      }
      input.value = inputValue;
    };
    this.handleChannelChange = (event) => {
      const input = event.currentTarget;
      const channelIndex = Number(input.getAttribute("data-channel-index"));
      const channels = [...this.channels];
      const shouldClearChannels = this.allowEmpty && !input.value;
      if (shouldClearChannels) {
        this.channels = [null, null, null, null];
        this.internalColorSet(null);
        return;
      }
      const isAlphaChannel = channelIndex === 3;
      const value = Number(input.value);
      channels[channelIndex] = isAlphaChannel ? (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.o)(value) : value;
      this.updateColorFromChannels(channels);
    };
    this.handleSavedColorKeyDown = (event) => {
      if ((0,_key_61f82ddb_js__WEBPACK_IMPORTED_MODULE_4__.i)(event.key)) {
        event.preventDefault();
        this.handleSavedColorSelect(event);
      }
    };
    this.handleColorFieldPointerDown = (event) => {
      if (!(0,_dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_1__.i)(event)) {
        return;
      }
      const { offsetX, offsetY } = event;
      window.addEventListener("pointermove", this.globalPointerMoveHandler);
      window.addEventListener("pointerup", this.globalPointerUpHandler, { once: true });
      this.activeCanvasInfo = {
        context: this.colorFieldRenderingContext,
        bounds: this.colorFieldRenderingContext.canvas.getBoundingClientRect(),
      };
      this.captureColorFieldColor(offsetX, offsetY);
      this.colorFieldScopeNode.focus();
    };
    this.handleHueSliderPointerDown = (event) => {
      if (!(0,_dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_1__.i)(event)) {
        return;
      }
      const { offsetX } = event;
      window.addEventListener("pointermove", this.globalPointerMoveHandler);
      window.addEventListener("pointerup", this.globalPointerUpHandler, { once: true });
      this.activeCanvasInfo = {
        context: this.hueSliderRenderingContext,
        bounds: this.hueSliderRenderingContext.canvas.getBoundingClientRect(),
      };
      this.captureHueSliderColor(offsetX);
      this.hueScopeNode.focus();
    };
    this.handleOpacitySliderPointerDown = (event) => {
      if (!(0,_dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_1__.i)(event)) {
        return;
      }
      const { offsetX } = event;
      window.addEventListener("pointermove", this.globalPointerMoveHandler);
      window.addEventListener("pointerup", this.globalPointerUpHandler, { once: true });
      this.activeCanvasInfo = {
        context: this.opacitySliderRenderingContext,
        bounds: this.opacitySliderRenderingContext.canvas.getBoundingClientRect(),
      };
      this.captureOpacitySliderValue(offsetX);
      this.opacityScopeNode.focus();
    };
    this.globalPointerUpHandler = (event) => {
      if (!(0,_dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_1__.i)(event)) {
        return;
      }
      const previouslyDragging = this.activeCanvasInfo;
      this.activeCanvasInfo = null;
      this.drawColorControls();
      if (previouslyDragging) {
        this.calciteColorPickerChange.emit();
      }
    };
    this.globalPointerMoveHandler = (event) => {
      const { activeCanvasInfo, el } = this;
      if (!el.isConnected || !activeCanvasInfo) {
        return;
      }
      const { context, bounds } = activeCanvasInfo;
      let samplingX;
      let samplingY;
      const { clientX, clientY } = event;
      if (context.canvas.matches(":hover")) {
        samplingX = clientX - bounds.x;
        samplingY = clientY - bounds.y;
      }
      else {
        // snap x and y to the closest edge
        if (clientX < bounds.x + bounds.width && clientX > bounds.x) {
          samplingX = clientX - bounds.x;
        }
        else if (clientX < bounds.x) {
          samplingX = 0;
        }
        else {
          samplingX = bounds.width;
        }
        if (clientY < bounds.y + bounds.height && clientY > bounds.y) {
          samplingY = clientY - bounds.y;
        }
        else if (clientY < bounds.y) {
          samplingY = 0;
        }
        else {
          samplingY = bounds.height;
        }
      }
      if (context === this.colorFieldRenderingContext) {
        this.captureColorFieldColor(samplingX, samplingY, false);
      }
      else if (context === this.hueSliderRenderingContext) {
        this.captureHueSliderColor(samplingX);
      }
      else if (context === this.opacitySliderRenderingContext) {
        this.captureOpacitySliderValue(samplingX);
      }
    };
    this.storeColorFieldScope = (node) => {
      this.colorFieldScopeNode = node;
    };
    this.storeHueScope = (node) => {
      this.hueScopeNode = node;
    };
    this.renderChannelsTabTitle = (channelMode) => {
      const { channelMode: activeChannelMode, messages } = this;
      const selected = channelMode === activeChannelMode;
      const label = channelMode === "rgb" ? messages.rgb : messages.hsv;
      return ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tab-title", { class: CSS$2.colorMode, "data-color-mode": channelMode, key: channelMode, onCalciteTabsActivate: this.handleTabActivate, selected: selected }, label));
    };
    this.renderChannelsTab = (channelMode) => {
      const { allowEmpty, channelMode: activeChannelMode, channels, messages, alphaChannel } = this;
      const selected = channelMode === activeChannelMode;
      const isRgb = channelMode === "rgb";
      const channelAriaLabels = isRgb
        ? [messages.red, messages.green, messages.blue]
        : [messages.hue, messages.saturation, messages.value];
      const direction = (0,_dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.el);
      const channelsToRender = alphaChannel ? channels : channels.slice(0, 3);
      return ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tab", { class: CSS$2.control, key: channelMode, selected: selected }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.channels, dir: "ltr" }, channelsToRender.map((channelValue, index) => {
        const isAlphaChannel = index === 3;
        if (isAlphaChannel) {
          channelValue =
            allowEmpty && !channelValue ? channelValue : (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.b)(channelValue);
        }
        /* the channel container is ltr, so we apply the host's direction */
        return this.renderChannel(channelValue, index, channelAriaLabels[index], direction, isAlphaChannel ? "%" : "");
      }))));
    };
    this.renderChannel = (value, index, ariaLabel, direction, suffix) => {
      return ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-number", { class: CSS$2.channel, "data-channel-index": index, dir: direction, key: index, label: ariaLabel, lang: this.effectiveLocale, numberButtonType: "none", numberingSystem: this.numberingSystem, onCalciteInputNumberChange: this.handleChannelChange, onCalciteInputNumberInput: this.handleChannelInput, onKeyDown: this.handleKeyDown, scale: this.scale === "l" ? "m" : "s",
        // workaround to ensure input borders overlap as desired
        // this is because the build transforms margin-left to its
        // logical-prop, which is undesired as channels are always ltr
        style: {
          marginLeft: index > 0 && !(this.scale === "s" && this.alphaChannel && index === 3) ? "-1px" : "",
        }, suffixText: suffix, value: value?.toString() }));
    };
    this.deleteColor = () => {
      const colorToDelete = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(this.color, this.alphaChannel);
      const inStorage = this.savedColors.indexOf(colorToDelete) > -1;
      if (!inStorage) {
        return;
      }
      const savedColors = this.savedColors.filter((color) => color !== colorToDelete);
      this.savedColors = savedColors;
      const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
      if (this.storageId) {
        localStorage.setItem(storageKey, JSON.stringify(savedColors));
      }
    };
    this.saveColor = () => {
      const colorToSave = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(this.color, this.alphaChannel);
      const alreadySaved = this.savedColors.indexOf(colorToSave) > -1;
      if (alreadySaved) {
        return;
      }
      const savedColors = [...this.savedColors, colorToSave];
      this.savedColors = savedColors;
      const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
      if (this.storageId) {
        localStorage.setItem(storageKey, JSON.stringify(savedColors));
      }
    };
    this.drawColorControls = (0,_throttle_f4d8c9e4_js__WEBPACK_IMPORTED_MODULE_9__.t)((type = "all") => {
      if ((type === "all" || type === "color-field") && this.colorFieldRenderingContext) {
        this.drawColorField();
      }
      if ((type === "all" || type === "hue-slider") && this.hueSliderRenderingContext) {
        this.drawHueSlider();
      }
      if (this.alphaChannel &&
        (type === "all" || type === "opacity-slider") &&
        this.opacitySliderRenderingContext) {
        this.drawOpacitySlider();
      }
    }, throttleFor60FpsInMs);
    this.captureColorFieldColor = (x, y, skipEqual = true) => {
      const { dimensions: { colorField: { height, width }, }, } = this;
      const saturation = Math.round((HSV_LIMITS.s / width) * x);
      const value = Math.round((HSV_LIMITS.v / height) * (height - y));
      this.internalColorSet(this.baseColorFieldColor.hsv().saturationv(saturation).value(value), skipEqual);
    };
    this.initColorField = (canvas) => {
      this.colorFieldRenderingContext = canvas.getContext("2d");
      this.updateCanvasSize("color-field");
      this.drawColorControls();
    };
    this.initHueSlider = (canvas) => {
      this.hueSliderRenderingContext = canvas.getContext("2d");
      this.updateCanvasSize("hue-slider");
      this.drawHueSlider();
    };
    this.initOpacitySlider = (canvas) => {
      if (!canvas) {
        return;
      }
      this.opacitySliderRenderingContext = canvas.getContext("2d");
      this.updateCanvasSize("opacity-slider");
      this.drawOpacitySlider();
    };
    this.storeOpacityScope = (node) => {
      this.opacityScopeNode = node;
    };
    this.handleOpacityScopeKeyDown = (event) => {
      const modifier = event.shiftKey ? 10 : 1;
      const { key } = event;
      const arrowKeyToXOffset = {
        ArrowUp: 0.01,
        ArrowRight: 0.01,
        ArrowDown: -0.01,
        ArrowLeft: -0.01,
      };
      if (arrowKeyToXOffset[key]) {
        event.preventDefault();
        const delta = arrowKeyToXOffset[key] * modifier;
        const alpha = this.baseColorFieldColor.alpha();
        const color = this.baseColorFieldColor.alpha(alpha + delta);
        this.internalColorSet(color, false);
      }
    };
    this.allowEmpty = false;
    this.alphaChannel = false;
    this.channelsDisabled = false;
    this.color = DEFAULT_COLOR$1;
    this.disabled = false;
    this.format = "auto";
    this.hideChannels = false;
    this.hexDisabled = false;
    this.hideHex = false;
    this.hideSaved = false;
    this.savedDisabled = false;
    this.scale = "m";
    this.storageId = undefined;
    this.messageOverrides = undefined;
    this.numberingSystem = undefined;
    this.value = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.n)((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(DEFAULT_COLOR$1, this.alphaChannel));
    this.defaultMessages = undefined;
    this.channelMode = "rgb";
    this.channels = this.toChannels(DEFAULT_COLOR$1);
    this.dimensions = DIMENSIONS.m;
    this.effectiveLocale = "";
    this.messages = undefined;
    this.savedColors = [];
    this.colorFieldScopeTop = undefined;
    this.colorFieldScopeLeft = undefined;
    this.hueScopeLeft = undefined;
    this.opacityScopeLeft = undefined;
    this.scopeOrientation = undefined;
  }
  handleAlphaChannelChange(alphaChannel) {
    const { format } = this;
    if (alphaChannel && format !== "auto" && !(0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.c)(format)) {
      console.warn(`ignoring alphaChannel as the current format (${format}) does not support alpha`);
      this.alphaChannel = false;
    }
  }
  handleColorChange(color, oldColor) {
    this.drawColorControls();
    this.updateChannelsFromColor(color);
    this.previousColor = oldColor;
  }
  handleFormatOrAlphaChannelChange() {
    this.setMode(this.format);
    this.internalColorSet(this.color, false, "internal");
  }
  handleScaleChange(scale = "m") {
    this.updateDimensions(scale);
    this.updateCanvasSize("all");
    this.drawColorControls();
  }
  onMessagesChange() {
    /* wired up by t9n util */
  }
  handleValueChange(value, oldValue) {
    const { allowEmpty, format } = this;
    const checkMode = !allowEmpty || value;
    let modeChanged = false;
    if (checkMode) {
      const nextMode = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.p)(value);
      if (!nextMode || (format !== "auto" && nextMode !== format)) {
        this.showIncompatibleColorWarning(value, format);
        this.value = oldValue;
        return;
      }
      modeChanged = this.mode !== nextMode;
      this.setMode(nextMode, this.internalColorUpdateContext === null);
    }
    const dragging = this.activeCanvasInfo;
    if (this.internalColorUpdateContext === "initial") {
      return;
    }
    if (this.internalColorUpdateContext === "user-interaction") {
      this.calciteColorPickerInput.emit();
      if (!dragging) {
        this.calciteColorPickerChange.emit();
      }
      return;
    }
    const color$1 = allowEmpty && !value
      ? null
      : color(value != null && typeof value === "object" && (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.c)(this.mode)
        ? (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.g)(value)
        : value);
    const colorChanged = !(0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.d)(color$1, this.color);
    if (modeChanged || colorChanged) {
      this.internalColorSet(color$1, this.alphaChannel && !(this.mode.endsWith("a") || this.mode.endsWith("a-css")), "internal");
    }
  }
  get baseColorFieldColor() {
    return this.color || this.previousColor || DEFAULT_COLOR$1;
  }
  effectiveLocaleChange() {
    (0,_t9n_0bcdca54_js__WEBPACK_IMPORTED_MODULE_8__.u)(this, this.effectiveLocale);
  }
  // using @Listen as a workaround for VDOM listener not firing
  handleChannelKeyUpOrDown(event) {
    this.shiftKeyChannelAdjustment = 0;
    const { key } = event;
    if ((key !== "ArrowUp" && key !== "ArrowDown") ||
      !event.composedPath().some((node) => node.classList?.contains(CSS$2.channel))) {
      return;
    }
    const { shiftKey } = event;
    event.preventDefault();
    if (!this.color) {
      this.internalColorSet(this.previousColor);
      event.stopPropagation();
      return;
    }
    // this gets applied to the input's up/down arrow increment/decrement
    const complementaryBump = 9;
    this.shiftKeyChannelAdjustment =
      key === "ArrowUp" && shiftKey
        ? complementaryBump
        : key === "ArrowDown" && shiftKey
          ? -complementaryBump
          : 0;
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /** Sets focus on the component's first focusable element. */
  async setFocus() {
    await (0,_loadable_b17396e0_js__WEBPACK_IMPORTED_MODULE_5__.c)(this);
    this.el.focus();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    (0,_loadable_b17396e0_js__WEBPACK_IMPORTED_MODULE_5__.s)(this);
    const { allowEmpty, color: color$1, format, value } = this;
    const willSetNoColor = allowEmpty && !value;
    const parsedMode = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.p)(value);
    const valueIsCompatible = willSetNoColor || (format === "auto" && parsedMode) || format === parsedMode;
    const initialColor = willSetNoColor ? null : valueIsCompatible ? color(value) : color$1;
    if (!valueIsCompatible) {
      this.showIncompatibleColorWarning(value, format);
    }
    this.setMode(format, false);
    this.internalColorSet(initialColor, false, "initial");
    this.updateDimensions(this.scale);
    const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
    if (this.storageId && localStorage.getItem(storageKey)) {
      this.savedColors = JSON.parse(localStorage.getItem(storageKey));
    }
    await (0,_t9n_0bcdca54_js__WEBPACK_IMPORTED_MODULE_8__.s)(this);
  }
  connectedCallback() {
    (0,_interactive_cbd8a6dc_js__WEBPACK_IMPORTED_MODULE_3__.c)(this);
    (0,_locale_6e783cf0_js__WEBPACK_IMPORTED_MODULE_6__.c)(this);
    (0,_t9n_0bcdca54_js__WEBPACK_IMPORTED_MODULE_8__.c)(this);
  }
  componentDidLoad() {
    (0,_loadable_b17396e0_js__WEBPACK_IMPORTED_MODULE_5__.a)(this);
  }
  disconnectedCallback() {
    window.removeEventListener("pointermove", this.globalPointerMoveHandler);
    window.removeEventListener("pointerup", this.globalPointerUpHandler);
    (0,_interactive_cbd8a6dc_js__WEBPACK_IMPORTED_MODULE_3__.d)(this);
    (0,_locale_6e783cf0_js__WEBPACK_IMPORTED_MODULE_6__.d)(this);
    (0,_t9n_0bcdca54_js__WEBPACK_IMPORTED_MODULE_8__.d)(this);
  }
  componentDidRender() {
    (0,_interactive_cbd8a6dc_js__WEBPACK_IMPORTED_MODULE_3__.u)(this);
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { allowEmpty, channelsDisabled, color, colorFieldScopeLeft, colorFieldScopeTop, dimensions: { slider: { width: sliderWidth }, thumb: { radius: thumbRadius }, }, hexDisabled, hideChannels, hideHex, hideSaved, hueScopeLeft, messages, alphaChannel, opacityScopeLeft, savedColors, savedDisabled, scale, scopeOrientation, } = this;
    const selectedColorInHex = color ? (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(color, alphaChannel) : null;
    const hueTop = thumbRadius;
    const hueLeft = hueScopeLeft ?? (sliderWidth * DEFAULT_COLOR$1.hue()) / HSV_LIMITS.h;
    const opacityTop = thumbRadius;
    const opacityLeft = opacityScopeLeft ??
      (sliderWidth * (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.b)(DEFAULT_COLOR$1.alpha())) / OPACITY_LIMITS.max;
    const noColor = color === null;
    const vertical = scopeOrientation === "vertical";
    const noHex = hexDisabled || hideHex;
    const noChannels = channelsDisabled || hideChannels;
    const noSaved = savedDisabled || hideSaved;
    const [adjustedColorFieldScopeLeft, adjustedColorFieldScopeTop] = this.getAdjustedScopePosition(colorFieldScopeLeft, colorFieldScopeTop);
    const [adjustedHueScopeLeft, adjustedHueScopeTop] = this.getAdjustedScopePosition(hueLeft, hueTop);
    const [adjustedOpacityScopeLeft, adjustedOpacityScopeTop] = this.getAdjustedScopePosition(opacityLeft, opacityTop);
    return ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.container }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.controlAndScope }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("canvas", { class: CSS$2.colorField, onPointerDown: this.handleColorFieldPointerDown,
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: this.initColorField }), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { "aria-label": vertical ? messages.value : messages.saturation, "aria-valuemax": vertical ? HSV_LIMITS.v : HSV_LIMITS.s, "aria-valuemin": "0", "aria-valuenow": (vertical ? color?.saturationv() : color?.value()) || "0", class: { [CSS$2.scope]: true, [CSS$2.colorFieldScope]: true }, onKeyDown: this.handleColorFieldScopeKeyDown, role: "slider", style: {
        top: `${adjustedColorFieldScopeTop || 0}px`,
        left: `${adjustedColorFieldScopeLeft || 0}px`,
      }, tabindex: "0",
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: this.storeColorFieldScope })), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.previewAndSliders }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-color-picker-swatch", { class: CSS$2.preview, color: selectedColorInHex, scale: "l" }), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.sliders }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.controlAndScope }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("canvas", { class: { [CSS$2.slider]: true, [CSS$2.hueSlider]: true }, onPointerDown: this.handleHueSliderPointerDown,
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: this.initHueSlider }), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { "aria-label": messages.hue, "aria-valuemax": HSV_LIMITS.h, "aria-valuemin": "0", "aria-valuenow": color?.round().hue() || DEFAULT_COLOR$1.round().hue(), class: { [CSS$2.scope]: true, [CSS$2.hueScope]: true }, onKeyDown: this.handleHueScopeKeyDown, role: "slider", style: {
        top: `${adjustedHueScopeTop}px`,
        left: `${adjustedHueScopeLeft}px`,
      }, tabindex: "0",
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: this.storeHueScope })), alphaChannel ? ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.controlAndScope }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("canvas", { class: { [CSS$2.slider]: true, [CSS$2.opacitySlider]: true }, onPointerDown: this.handleOpacitySliderPointerDown,
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: this.initOpacitySlider }), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { "aria-label": messages.opacity, "aria-valuemax": OPACITY_LIMITS.max, "aria-valuemin": OPACITY_LIMITS.min, "aria-valuenow": (color || DEFAULT_COLOR$1).round().alpha(), class: { [CSS$2.scope]: true, [CSS$2.opacityScope]: true }, onKeyDown: this.handleOpacityScopeKeyDown, role: "slider", style: {
        top: `${adjustedOpacityScopeTop}px`,
        left: `${adjustedOpacityScopeLeft}px`,
      }, tabindex: "0",
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: this.storeOpacityScope }))) : null)), noHex && noChannels ? null : ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: {
        [CSS$2.controlSection]: true,
        [CSS$2.section]: true,
      } }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.hexAndChannelsGroup }, noHex ? null : ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.hexOptions }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-color-picker-hex-input", { allowEmpty: allowEmpty, alphaChannel: alphaChannel, class: CSS$2.control, messages: messages, numberingSystem: this.numberingSystem, onCalciteColorPickerHexInputChange: this.handleHexInputChange, scale: scale, value: selectedColorInHex }))), noChannels ? null : ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tabs", { class: {
        [CSS$2.colorModeContainer]: true,
        [CSS$2.splitSection]: true,
      }, scale: scale === "l" ? "m" : "s" }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tab-nav", { slot: "title-group" }, this.renderChannelsTabTitle("rgb"), this.renderChannelsTabTitle("hsv")), this.renderChannelsTab("rgb"), this.renderChannelsTab("hsv")))))), noSaved ? null : ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: { [CSS$2.savedColorsSection]: true, [CSS$2.section]: true } }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.header }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("label", null, messages.saved), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.savedColorsButtons }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", class: CSS$2.deleteColor, disabled: noColor, iconStart: "minus", kind: "neutral", label: messages.deleteColor, onClick: this.deleteColor, scale: scale, type: "button" }), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", class: CSS$2.saveColor, disabled: noColor, iconStart: "plus", kind: "neutral", label: messages.saveColor, onClick: this.saveColor, scale: scale, type: "button" }))), savedColors.length > 0 ? ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.savedColors }, [
      ...savedColors.map((color) => ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-color-picker-swatch", { class: CSS$2.savedColor, color: color, key: color, onClick: this.handleSavedColorSelect, onKeyDown: this.handleSavedColorKeyDown, scale: scale, tabIndex: 0 }))),
    ])) : null))));
  }
  // --------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  handleKeyDown(event) {
    if (event.key === "Enter") {
      event.preventDefault();
    }
  }
  showIncompatibleColorWarning(value, format) {
    console.warn(`ignoring color value (${value}) as it is not compatible with the current format (${format})`);
  }
  setMode(format, warn = true) {
    const mode = format === "auto" ? this.mode : format;
    this.mode = this.ensureCompatibleMode(mode, warn);
  }
  ensureCompatibleMode(mode, warn) {
    const { alphaChannel } = this;
    const isAlphaCompatible = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.c)(mode);
    if (alphaChannel && !isAlphaCompatible) {
      const alphaMode = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.f)(mode);
      if (warn) {
        console.warn(`setting format to (${alphaMode}) as the provided one (${mode}) does not support alpha`);
      }
      return alphaMode;
    }
    if (!alphaChannel && isAlphaCompatible) {
      const nonAlphaMode = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.t)(mode);
      if (warn) {
        console.warn(`setting format to (${nonAlphaMode}) as the provided one (${mode}) does not support alpha`);
      }
      return nonAlphaMode;
    }
    return mode;
  }
  captureHueSliderColor(x) {
    const { dimensions: { slider: { width }, }, } = this;
    const hue = (HUE_LIMIT_CONSTRAINED / width) * x;
    this.internalColorSet(this.baseColorFieldColor.hue(hue), false);
  }
  captureOpacitySliderValue(x) {
    const { dimensions: { slider: { width }, }, } = this;
    const alpha = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.o)((OPACITY_LIMITS.max / width) * x);
    this.internalColorSet(this.baseColorFieldColor.alpha(alpha), false);
  }
  internalColorSet(color, skipEqual = true, context = "user-interaction") {
    if (skipEqual && (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.d)(color, this.color)) {
      return;
    }
    this.internalColorUpdateContext = context;
    this.color = color;
    this.value = this.toValue(color);
    this.internalColorUpdateContext = null;
  }
  toValue(color, format = this.mode) {
    if (!color) {
      return null;
    }
    const hexMode = "hex";
    if (format.includes(hexMode)) {
      const hasAlpha = format === _utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.C.HEXA;
      return (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.n)((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(color.round(), hasAlpha), hasAlpha);
    }
    if (format.includes("-css")) {
      const value = color[format.replace("-css", "").replace("a", "")]().round().string();
      // Color omits alpha values when alpha is 1
      const needToInjectAlpha = (format.endsWith("a") || format.endsWith("a-css")) && color.alpha() === 1;
      if (needToInjectAlpha) {
        const model = value.slice(0, 3);
        const values = value.slice(4, -1);
        return `${model}a(${values}, ${color.alpha()})`;
      }
      return value;
    }
    const colorObject = 
    /* Color() does not support hsva, hsla nor rgba, so we use the non-alpha mode */
    color[(0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.t)(format)]().round().object();
    if (format.endsWith("a")) {
      return (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.e)(colorObject);
    }
    return colorObject;
  }
  getSliderCapSpacing() {
    const { dimensions: { slider: { height }, thumb: { radius }, }, } = this;
    return radius * 2 - height;
  }
  updateDimensions(scale = "m") {
    this.dimensions = DIMENSIONS[scale];
  }
  drawColorField() {
    const context = this.colorFieldRenderingContext;
    const { dimensions: { colorField: { height, width }, }, } = this;
    context.fillStyle = this.baseColorFieldColor
      .hsv()
      .saturationv(100)
      .value(100)
      .alpha(1)
      .string();
    context.fillRect(0, 0, width, height);
    const whiteGradient = context.createLinearGradient(0, 0, width, 0);
    whiteGradient.addColorStop(0, "rgba(255,255,255,1)");
    whiteGradient.addColorStop(1, "rgba(255,255,255,0)");
    context.fillStyle = whiteGradient;
    context.fillRect(0, 0, width, height);
    const blackGradient = context.createLinearGradient(0, 0, 0, height);
    blackGradient.addColorStop(0, "rgba(0,0,0,0)");
    blackGradient.addColorStop(1, "rgba(0,0,0,1)");
    context.fillStyle = blackGradient;
    context.fillRect(0, 0, width, height);
    this.drawActiveColorFieldColor();
  }
  setCanvasContextSize(canvas, { height, width }) {
    if (!canvas) {
      return;
    }
    const devicePixelRatio = window.devicePixelRatio || 1;
    canvas.width = width * devicePixelRatio;
    canvas.height = height * devicePixelRatio;
    canvas.style.height = `${height}px`;
    canvas.style.width = `${width}px`;
    const context = canvas.getContext("2d");
    context.scale(devicePixelRatio, devicePixelRatio);
  }
  updateCanvasSize(context = "all") {
    const { dimensions } = this;
    if (context === "all" || context === "color-field") {
      this.setCanvasContextSize(this.colorFieldRenderingContext?.canvas, dimensions.colorField);
    }
    const adjustedSliderDimensions = {
      width: dimensions.slider.width,
      height: dimensions.slider.height + (dimensions.thumb.radius - dimensions.slider.height / 2) * 2,
    };
    if (context === "all" || context === "hue-slider") {
      this.setCanvasContextSize(this.hueSliderRenderingContext?.canvas, adjustedSliderDimensions);
    }
    if (context === "all" || context === "opacity-slider") {
      this.setCanvasContextSize(this.opacitySliderRenderingContext?.canvas, adjustedSliderDimensions);
    }
  }
  drawActiveColorFieldColor() {
    const { color } = this;
    if (!color) {
      return;
    }
    const hsvColor = color.hsv();
    const { dimensions: { colorField: { height, width }, thumb: { radius }, }, } = this;
    const x = hsvColor.saturationv() / (HSV_LIMITS.s / width);
    const y = height - hsvColor.value() / (HSV_LIMITS.v / height);
    requestAnimationFrame(() => {
      this.colorFieldScopeLeft = x;
      this.colorFieldScopeTop = y;
    });
    this.drawThumb(this.colorFieldRenderingContext, radius, x, y, hsvColor);
  }
  drawThumb(context, radius, x, y, color) {
    const startAngle = 0;
    const endAngle = 2 * Math.PI;
    const outlineWidth = 1;
    context.beginPath();
    context.arc(x, y, radius, startAngle, endAngle);
    context.fillStyle = "#fff";
    context.fill();
    context.strokeStyle = "rgba(0,0,0,0.3)";
    context.lineWidth = outlineWidth;
    context.stroke();
    context.beginPath();
    context.arc(x, y, radius - 3, startAngle, endAngle);
    context.fillStyle = color.rgb().alpha(1).string();
    context.fill();
  }
  drawActiveHueSliderColor() {
    const { color } = this;
    if (!color) {
      return;
    }
    const hsvColor = color.hsv().saturationv(100).value(100);
    const { dimensions: { slider: { width }, thumb: { radius }, }, } = this;
    const x = hsvColor.hue() / (HUE_LIMIT_CONSTRAINED / width);
    const y = radius;
    const sliderBoundX = this.getSliderBoundX(x, width, radius);
    requestAnimationFrame(() => {
      this.hueScopeLeft = sliderBoundX;
    });
    this.drawThumb(this.hueSliderRenderingContext, radius, sliderBoundX, y, hsvColor);
  }
  drawHueSlider() {
    const context = this.hueSliderRenderingContext;
    const { dimensions: { slider: { height, width }, thumb: { radius: thumbRadius }, }, } = this;
    const x = 0;
    const y = thumbRadius - height / 2;
    const gradient = context.createLinearGradient(0, 0, width, 0);
    const hueSliderColorStopKeywords = [
      "red",
      "yellow",
      "lime",
      "cyan",
      "blue",
      "magenta",
      "#ff0004" /* 1 unit less than #ff0 to avoid duplicate values within range */,
    ];
    const offset = 1 / (hueSliderColorStopKeywords.length - 1);
    let currentOffset = 0;
    hueSliderColorStopKeywords.forEach((keyword) => {
      gradient.addColorStop(currentOffset, color(keyword).string());
      currentOffset += offset;
    });
    context.clearRect(0, 0, width, height + this.getSliderCapSpacing() * 2);
    this.drawSliderPath(context, height, width, x, y);
    context.fillStyle = gradient;
    context.fill();
    context.strokeStyle = "rgba(0,0,0,0.3)";
    context.lineWidth = 1;
    context.stroke();
    this.drawActiveHueSliderColor();
  }
  drawOpacitySlider() {
    const context = this.opacitySliderRenderingContext;
    const { baseColorFieldColor: previousColor, dimensions: { slider: { height, width }, thumb: { radius: thumbRadius }, }, } = this;
    const x = 0;
    const y = thumbRadius - height / 2;
    context.clearRect(0, 0, width, height + this.getSliderCapSpacing() * 2);
    const gradient = context.createLinearGradient(0, y, width, 0);
    const startColor = previousColor.rgb().alpha(0);
    const midColor = previousColor.rgb().alpha(0.5);
    const endColor = previousColor.rgb().alpha(1);
    gradient.addColorStop(0, startColor.string());
    gradient.addColorStop(0.5, midColor.string());
    gradient.addColorStop(1, endColor.string());
    this.drawSliderPath(context, height, width, x, y);
    const pattern = context.createPattern(this.getCheckeredBackgroundPattern(), "repeat");
    context.fillStyle = pattern;
    context.fill();
    context.fillStyle = gradient;
    context.fill();
    context.strokeStyle = "rgba(0,0,0,0.3)";
    context.lineWidth = 1;
    context.stroke();
    this.drawActiveOpacitySliderColor();
  }
  drawSliderPath(context, height, width, x, y) {
    const radius = height / 2 + 1;
    context.beginPath();
    context.moveTo(x + radius, y);
    context.lineTo(x + width - radius, y);
    context.quadraticCurveTo(x + width, y, x + width, y + radius);
    context.lineTo(x + width, y + height - radius);
    context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    context.lineTo(x + radius, y + height);
    context.quadraticCurveTo(x, y + height, x, y + height - radius);
    context.lineTo(x, y + radius);
    context.quadraticCurveTo(x, y, x + radius, y);
    context.closePath();
  }
  getCheckeredBackgroundPattern() {
    if (this.checkerPattern) {
      return this.checkerPattern;
    }
    const pattern = document.createElement("canvas");
    pattern.width = 10;
    pattern.height = 10;
    const patternContext = pattern.getContext("2d");
    patternContext.fillStyle = "#ccc";
    patternContext.fillRect(0, 0, 10, 10);
    patternContext.fillStyle = "#fff";
    patternContext.fillRect(0, 0, 5, 5);
    patternContext.fillRect(5, 5, 5, 5);
    this.checkerPattern = pattern;
    return pattern;
  }
  drawActiveOpacitySliderColor() {
    const { color } = this;
    if (!color) {
      return;
    }
    const hsvColor = color;
    const { dimensions: { slider: { width }, thumb: { radius }, }, } = this;
    const x = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.b)(hsvColor.alpha()) / (OPACITY_LIMITS.max / width);
    const y = radius;
    const sliderBoundX = this.getSliderBoundX(x, width, radius);
    requestAnimationFrame(() => {
      this.opacityScopeLeft = sliderBoundX;
    });
    this.drawThumb(this.opacitySliderRenderingContext, radius, sliderBoundX, y, hsvColor);
  }
  getSliderBoundX(x, width, radius) {
    const closeToEdge = (0,_math_922e37ec_js__WEBPACK_IMPORTED_MODULE_7__.a)(x, width, radius);
    return closeToEdge === 0
      ? x
      : closeToEdge === -1
        ? (0,_math_922e37ec_js__WEBPACK_IMPORTED_MODULE_7__.r)(x, 0, width, radius, radius * 2)
        : (0,_math_922e37ec_js__WEBPACK_IMPORTED_MODULE_7__.r)(x, 0, width, width - radius * 2, width - radius);
  }
  updateColorFromChannels(channels) {
    this.internalColorSet(color(channels, this.channelMode));
  }
  updateChannelsFromColor(color) {
    this.channels = color ? this.toChannels(color) : [null, null, null, null];
  }
  toChannels(color) {
    const { channelMode } = this;
    const channels = color[channelMode]()
      .array()
      .map((value, index) => {
      const isAlpha = index === 3;
      return isAlpha ? value : Math.floor(value);
    });
    if (channels.length === 3) {
      channels.push(1); // Color omits alpha when 1
    }
    return channels;
  }
  getAdjustedScopePosition(left, top) {
    return [left - SCOPE_SIZE / 2, top - SCOPE_SIZE / 2];
  }
  static get delegatesFocus() { return true; }
  static get assetsDirs() { return ["assets"]; }
  get el() { return (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
  static get watchers() { return {
    "alphaChannel": ["handleAlphaChannelChange", "handleFormatOrAlphaChannelChange"],
    "color": ["handleColorChange"],
    "format": ["handleFormatOrAlphaChannelChange"],
    "scale": ["handleScaleChange"],
    "messageOverrides": ["onMessagesChange"],
    "value": ["handleValueChange"],
    "effectiveLocale": ["effectiveLocaleChange"]
  }; }
};
ColorPicker.style = colorPickerCss;

const CSS$1 = {
  container: "container",
  hexInput: "hex-input",
  opacityInput: "opacity-input",
};

const colorPickerHexInputCss = ":host{display:block}.container{display:flex;inline-size:100%;flex-wrap:nowrap;align-items:center}.hex-input{flex-grow:1;text-transform:uppercase}.opacity-input{inline-size:68px;margin-inline-start:-1px}:host([scale=s]) .container{flex-wrap:wrap;row-gap:0.125rem}:host([scale=s]) .opacity-input{inline-size:unset;margin-inline-start:unset}:host([scale=l]) .opacity-input{inline-size:88px}:host([hidden]){display:none}[hidden]{display:none}";

const DEFAULT_COLOR = color();
const ColorPickerHexInput = class {
  constructor(hostRef) {
    (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.calciteColorPickerHexInputChange = (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "calciteColorPickerHexInputChange", 6);
    this.onHexInputBlur = () => {
      const node = this.hexInputNode;
      const inputValue = node.value;
      const hex = `#${inputValue}`;
      const { allowEmpty, internalColor } = this;
      const willClearValue = allowEmpty && !inputValue;
      const isLonghand = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.j)(hex);
      // ensure modified pasted hex values are committed since we prevent default to remove the # char.
      this.onHexInputChange();
      if (willClearValue || ((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.i)(hex) && isLonghand)) {
        return;
      }
      // manipulating DOM directly since rerender doesn't update input value
      node.value =
        allowEmpty && !internalColor
          ? ""
          : this.formatHexForInternalInput((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.r)(
          // always display hex input in RRGGBB format
          internalColor.object()));
    };
    this.onOpacityInputBlur = () => {
      const node = this.opacityInputNode;
      const inputValue = node.value;
      const { allowEmpty, internalColor } = this;
      const willClearValue = allowEmpty && !inputValue;
      if (willClearValue) {
        return;
      }
      // manipulating DOM directly since rerender doesn't update input value
      node.value =
        allowEmpty && !internalColor ? "" : this.formatOpacityForInternalInput(internalColor);
    };
    this.onHexInputChange = () => {
      const nodeValue = this.hexInputNode.value;
      let value = nodeValue;
      if (value) {
        const normalized = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.n)(value, false);
        const preserveExistingAlpha = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.i)(normalized) && this.alphaChannel;
        if (preserveExistingAlpha && this.internalColor) {
          const alphaHex = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.n)(this.internalColor.hexa(), true).slice(-2);
          value = `${normalized + alphaHex}`;
        }
      }
      this.internalSetValue(value, this.value);
    };
    this.onOpacityInputChange = () => {
      const node = this.opacityInputNode;
      let value;
      if (!node.value) {
        value = node.value;
      }
      else {
        const alpha = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.o)(Number(node.value));
        value = this.internalColor?.alpha(alpha).hexa();
      }
      this.internalSetValue(value, this.value);
    };
    this.onInputKeyDown = (event) => {
      const { altKey, ctrlKey, metaKey, shiftKey } = event;
      const { alphaChannel, hexInputNode, internalColor, value } = this;
      const { key } = event;
      const composedPath = event.composedPath();
      if (key === "Tab" || key === "Enter") {
        if (composedPath.includes(hexInputNode)) {
          this.onHexInputChange();
        }
        else {
          this.onOpacityInputChange();
        }
        if (key === "Enter") {
          event.preventDefault();
        }
        return;
      }
      const isNudgeKey = key === "ArrowDown" || key === "ArrowUp";
      const oldValue = this.value;
      if (isNudgeKey) {
        if (!value) {
          this.internalSetValue(this.previousNonNullValue, oldValue);
          event.preventDefault();
          return;
        }
        const direction = key === "ArrowUp" ? 1 : -1;
        const bump = shiftKey ? 10 : 1;
        this.internalSetValue((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(this.nudgeRGBChannels(internalColor, bump * direction, composedPath.includes(hexInputNode) ? "rgb" : "a"), alphaChannel), oldValue);
        event.preventDefault();
        return;
      }
      const withModifiers = altKey || ctrlKey || metaKey;
      const singleChar = key.length === 1;
      const validHexChar = _utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.k.test(key);
      if (singleChar && !withModifiers && !validHexChar) {
        event.preventDefault();
      }
    };
    this.onHexInputPaste = (event) => {
      const hex = event.clipboardData.getData("text");
      if ((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.i)(hex)) {
        event.preventDefault();
        this.hexInputNode.value = hex.slice(1);
      }
    };
    this.previousNonNullValue = this.value;
    this.storeHexInputRef = (node) => {
      this.hexInputNode = node;
    };
    this.storeOpacityInputRef = (node) => {
      this.opacityInputNode = node;
    };
    this.allowEmpty = false;
    this.alphaChannel = false;
    this.hexLabel = "Hex";
    this.messages = undefined;
    this.numberingSystem = undefined;
    this.scale = "m";
    this.value = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.n)((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(DEFAULT_COLOR, this.alphaChannel), this.alphaChannel, true);
    this.internalColor = DEFAULT_COLOR;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    const { allowEmpty, alphaChannel, value } = this;
    if (value) {
      const normalized = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.n)(value, alphaChannel);
      if ((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.i)(normalized, alphaChannel)) {
        this.internalSetValue(normalized, normalized, false);
      }
      return;
    }
    if (allowEmpty) {
      this.internalSetValue(null, null, false);
    }
  }
  componentWillLoad() {
    (0,_loadable_b17396e0_js__WEBPACK_IMPORTED_MODULE_5__.s)(this);
  }
  componentDidLoad() {
    (0,_loadable_b17396e0_js__WEBPACK_IMPORTED_MODULE_5__.a)(this);
  }
  handleValueChange(value, oldValue) {
    this.internalSetValue(value, oldValue, false);
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  render() {
    const { alphaChannel, hexLabel, internalColor, messages, scale, value } = this;
    const hexInputValue = this.formatHexForInternalInput(value);
    const opacityInputValue = this.formatOpacityForInternalInput(internalColor);
    const inputScale = scale === "l" ? "m" : "s";
    return ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.container }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-text", { class: CSS$1.hexInput, label: messages?.hex || hexLabel, maxLength: 6, onCalciteInputTextChange: this.onHexInputChange, onCalciteInternalInputTextBlur: this.onHexInputBlur, onKeyDown: this.onInputKeyDown, onPaste: this.onHexInputPaste, prefixText: "#", scale: inputScale, value: hexInputValue,
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: this.storeHexInputRef }), alphaChannel ? ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-number", { class: CSS$1.opacityInput, key: "opacity-input", label: messages?.opacity, max: OPACITY_LIMITS.max, maxLength: 3, min: OPACITY_LIMITS.min, numberButtonType: "none", numberingSystem: this.numberingSystem, onCalciteInputNumberChange: this.onOpacityInputChange, onCalciteInternalInputNumberBlur: this.onOpacityInputBlur, onKeyDown: this.onInputKeyDown, scale: inputScale, suffixText: "%", value: opacityInputValue,
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: this.storeOpacityInputRef })) : null));
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /** Sets focus on the component. */
  async setFocus() {
    await (0,_loadable_b17396e0_js__WEBPACK_IMPORTED_MODULE_5__.c)(this);
    return (0,_dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_1__.d)(this.hexInputNode);
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  internalSetValue(value, oldValue, emit = true) {
    if (value) {
      const { alphaChannel } = this;
      const normalized = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.n)(value, alphaChannel, alphaChannel);
      if ((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.i)(normalized, alphaChannel)) {
        const { internalColor: currentColor } = this;
        const nextColor = color(normalized);
        const normalizedLonghand = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.n)((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(nextColor, alphaChannel), alphaChannel);
        const changed = !currentColor ||
          normalizedLonghand !== (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.n)((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(currentColor, alphaChannel), alphaChannel);
        this.internalColor = nextColor;
        this.previousNonNullValue = normalizedLonghand;
        this.value = normalizedLonghand;
        if (changed && emit) {
          this.calciteColorPickerHexInputChange.emit();
        }
        return;
      }
    }
    else if (this.allowEmpty) {
      this.internalColor = null;
      this.value = null;
      if (emit) {
        this.calciteColorPickerHexInputChange.emit();
      }
      return;
    }
    this.value = oldValue;
  }
  formatHexForInternalInput(hex) {
    return hex ? hex.replace("#", "").slice(0, 6) : "";
  }
  formatOpacityForInternalInput(color) {
    return color ? `${(0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.b)(color.alpha())}` : "";
  }
  nudgeRGBChannels(color$1, amount, context) {
    let nudgedChannels;
    const channels = color$1.array();
    const rgbChannels = channels.slice(0, 3);
    if (context === "rgb") {
      const nudgedRGBChannels = rgbChannels.map((channel) => channel + amount);
      nudgedChannels = [
        ...nudgedRGBChannels,
        this.alphaChannel ? channels[3] : undefined,
      ];
    }
    else {
      const nudgedAlpha = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.o)((0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.b)(color$1.alpha()) + amount);
      nudgedChannels = [...rgbChannels, nudgedAlpha];
    }
    return color(nudgedChannels);
  }
  get el() { return (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
  static get watchers() { return {
    "value": ["handleValueChange"]
  }; }
};
ColorPickerHexInput.style = colorPickerHexInputCss;

const CSS = {
  swatch: "swatch",
  noColorSwatch: "swatch--no-color",
  checker: "checker",
};
const COLORS = {
  borderLight: "rgba(0, 0, 0, 0.3)",
  borderDark: "rgba(255, 255, 255, 0.15)",
};
const checkerSquareSize = 4;
const CHECKER_DIMENSIONS = {
  squareSize: checkerSquareSize,
  size: checkerSquareSize * 2,
};

const colorPickerSwatchCss = ":host{position:relative;display:inline-flex}:host([scale=s]){block-size:1.25rem;inline-size:1.25rem}:host([scale=m]){block-size:1.5rem;inline-size:1.5rem}:host([scale=l]){block-size:2rem;inline-size:2rem}.swatch{overflow:hidden;block-size:inherit;inline-size:inherit}.swatch rect{transition-property:all;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}.swatch--no-color rect{fill:var(--calcite-color-foreground-1)}.swatch--no-color line{stroke:var(--calcite-color-status-danger)}.checker{fill:#cacaca}:host([hidden]){display:none}[hidden]{display:none}";

const ColorPickerSwatch = class {
  constructor(hostRef) {
    (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.active = false;
    this.color = undefined;
    this.scale = "m";
  }
  handleColorChange(color$1) {
    this.internalColor = color$1 ? color(color$1) : null;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  componentWillLoad() {
    this.handleColorChange(this.color);
  }
  render() {
    const isEmpty = !this.internalColor;
    const classes = {
      [CSS.swatch]: true,
      [CSS.noColorSwatch]: isEmpty,
    };
    return ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { class: classes, xmlns: "http://www.w3.org/2000/svg" }, this.renderSwatch()));
  }
  renderSwatch() {
    const { active, el, internalColor } = this;
    const borderRadius = active ? "100%" : "0";
    const theme = (0,_dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_1__.j)(el);
    const borderColor = theme === "light" ? COLORS.borderLight : COLORS.borderDark;
    const commonSwatchProps = {
      height: "100%",
      rx: borderRadius,
      stroke: borderColor,
      // stroke-width and clip-path are needed to hide overflowing portion of stroke
      // see https://stackoverflow.com/a/7273346/194216
      // using attribute to work around Stencil using the prop name vs the attribute when rendering
      ["stroke-width"]: "2",
      width: "100%",
    };
    const isEmpty = !internalColor;
    if (isEmpty) {
      return ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("clipPath", { id: "shape" }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("rect", { height: "100%", rx: borderRadius, width: "100%" })), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("rect", { "clip-path": `inset(0 round ${borderRadius})`, rx: borderRadius, ...commonSwatchProps }), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("line", { "clip-path": "url(#shape)", "stroke-width": "3", x1: "100%", x2: "0", y1: "0", y2: "100%" })));
    }
    const alpha = internalColor.alpha();
    const hex = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(internalColor);
    const hexa = (0,_utils_a44d0b30_js__WEBPACK_IMPORTED_MODULE_2__.a)(internalColor, alpha < 1);
    return ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("title", null, hexa), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("defs", null, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("pattern", { height: CHECKER_DIMENSIONS.size, id: "checker", patternUnits: "userSpaceOnUse", width: CHECKER_DIMENSIONS.size, x: "0", y: "0" }, (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("rect", { class: CSS.checker, height: CHECKER_DIMENSIONS.squareSize, width: CHECKER_DIMENSIONS.squareSize, x: "0", y: "0" }), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("rect", { class: CSS.checker, height: CHECKER_DIMENSIONS.squareSize, width: CHECKER_DIMENSIONS.squareSize, x: CHECKER_DIMENSIONS.squareSize, y: CHECKER_DIMENSIONS.squareSize }))), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("rect", { fill: "url(#checker)", height: "100%", rx: borderRadius, width: "100%" }), (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("rect", { fill: hex, style: {
        "clip-path": alpha < 1 ? "polygon(100% 0, 0 0, 0 100%)" : `inset(0 round ${borderRadius})`,
      }, ...commonSwatchProps }), alpha < 1 ? ((0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.h)("rect", { fill: hexa, key: "opacity-fill", style: { "clip-path": "polygon(100% 0, 100% 100%, 0 100%)" }, ...commonSwatchProps })) : null));
  }
  get el() { return (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
  static get watchers() { return {
    "color": ["handleColorChange"]
  }; }
};
ColorPickerSwatch.style = colorPickerSwatchCss;



//# sourceMappingURL=calcite-color-picker_3.entry.js.map

/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/esm/loadable-b17396e0.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/esm/loadable-b17396e0.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ setComponentLoaded),
/* harmony export */   b: () => (/* binding */ componentLoaded),
/* harmony export */   c: () => (/* binding */ componentFocusable),
/* harmony export */   s: () => (/* binding */ setUpLoadableComponent)
/* harmony export */ });
/* harmony import */ var _index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-86faef9c.js */ "./node_modules/@esri/calcite-components/dist/esm/index-86faef9c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.0.0
 */


const resolveMap = new WeakMap();
const promiseMap = new WeakMap();
/**
 * This helper util sets up the component for the ability to know when the component has been loaded.
 *
 * This should be used in the `componentWillLoad` lifecycle hook.
 *
 * ```
 * componentWillLoad(): void {
 *   setUpLoadableComponent(this);
 * }
 * ```
 *
 * @param component
 */
function setUpLoadableComponent(component) {
  promiseMap.set(component, new Promise((resolve) => resolveMap.set(component, resolve)));
}
/**
 * This helper util lets the loadable component know that it is now loaded.
 *
 * This should be used in the `componentDidLoad` lifecycle hook.
 *
 * ```
 * componentDidLoad(): void {
 *   setComponentLoaded(this);
 * }
 * ```
 *
 * @param component
 */
function setComponentLoaded(component) {
  resolveMap.get(component)();
}
/**
 * This helper util can be used to ensure a component has been loaded (The "componentDidLoad" Stencil lifecycle method has been called).
 *
 * Requires requires `LoadableComponent` to be implemented.
 *
 * A component developer can await this method before proceeding with any logic that requires a component to be loaded first.
 *
 * ```
 * async myMethod(): Promise<void> {
 *   await componentLoaded(this);
 * }
 * ```
 *
 * @param component
 * @returns Promise<void>
 */
function componentLoaded(component) {
  return promiseMap.get(component);
}
/**
 * This helper util can be used to ensuring the component is loaded and rendered by the browser (The "componentDidLoad" Stencil lifecycle method has been called and any internal elements are focusable).
 *
 * Requires requires `LoadableComponent` to be implemented.
 *
 * A component developer can await this method before proceeding with any logic that requires a component to be loaded first and then an internal element be focused.
 *
 * ```
 * async setFocus(): Promise<void> {
 *   await componentFocusable(this);
 *   this.internalElement?.focus();
 * }
 * ```
 *
 * @param component
 * @returns Promise<void>
 */
async function componentFocusable(component) {
  await componentLoaded(component);
  (0,_index_86faef9c_js__WEBPACK_IMPORTED_MODULE_0__.f)(component);
  return new Promise((resolve) => requestAnimationFrame(() => resolve()));
}



//# sourceMappingURL=loadable-b17396e0.js.map

/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/esm/math-922e37ec.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/esm/math-922e37ec.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ closeToRangeEdge),
/* harmony export */   c: () => (/* binding */ clamp),
/* harmony export */   d: () => (/* binding */ decimalPlaces),
/* harmony export */   g: () => (/* binding */ getDecimals),
/* harmony export */   r: () => (/* binding */ remap)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.0.0
 */
const clamp = (value, min, max) => Math.max(min, Math.min(value, max));
const decimalNumberRegex = new RegExp(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
/**
 * Returns the quantity of real decimal places for a number, which excludes trailing zeros.
 *
 * Adapted from {@link https://stackoverflow.com/questions/10454518/javascript-how-to-retrieve-the-number-of-decimals-of-a-string-number}.
 *
 * @param decimal - decimal value
 * @param value
 * @returns {number} the amount of decimal places in a number
 */
const decimalPlaces = (value) => {
  const match = ("" + value).match(decimalNumberRegex);
  if (!match || parseInt(match[1]) === 0) {
    return 0;
  }
  return Math.max(0, 
  // Number of digits right of decimal point.
  (match[1] ? match[1].length : 0) -
    // Adjust for scientific notation.
    (match[2] ? +match[2] : 0));
};
function getDecimals(value) {
  if (decimalPlaces(value) > 0 && value > 0) {
    return parseFloat(`0.${value.toString().split(".")[1]}`);
  }
  return value;
}
function remap(value, fromMin, fromMax, toMin, toMax) {
  return ((value - fromMin) * (toMax - toMin)) / (fromMax - fromMin) + toMin;
}
/**
 * Helper to determine if a value is close to the edge of a range within a threshold.
 *
 * @param value
 * @param range
 * @param threshold
 * @returns -1 if close to lower edge, 1 if close to upper edge, 0 otherwise.
 */
function closeToRangeEdge(value, range, threshold) {
  return value < threshold ? -1 : value > range - threshold ? 1 : 0;
}



//# sourceMappingURL=math-922e37ec.js.map

/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/esm/utils-a44d0b30.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/esm/utils-a44d0b30.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSSColorMode),
/* harmony export */   a: () => (/* binding */ hexify),
/* harmony export */   b: () => (/* binding */ alphaToOpacity),
/* harmony export */   c: () => (/* binding */ alphaCompatible),
/* harmony export */   d: () => (/* binding */ colorEqual),
/* harmony export */   e: () => (/* binding */ normalizeAlpha),
/* harmony export */   f: () => (/* binding */ toAlphaMode),
/* harmony export */   g: () => (/* binding */ normalizeColor),
/* harmony export */   h: () => (/* binding */ hexToRGB),
/* harmony export */   i: () => (/* binding */ isValidHex),
/* harmony export */   j: () => (/* binding */ isLonghandHex),
/* harmony export */   k: () => (/* binding */ hexChar),
/* harmony export */   n: () => (/* binding */ normalizeHex),
/* harmony export */   o: () => (/* binding */ opacityToAlpha),
/* harmony export */   p: () => (/* binding */ parseMode),
/* harmony export */   r: () => (/* binding */ rgbToHex),
/* harmony export */   t: () => (/* binding */ toNonAlphaMode)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.0.0
 */
const hexChar = /^[0-9A-F]$/i;
const shorthandHex = /^#[0-9A-F]{3}$/i;
const longhandHex = /^#[0-9A-F]{6}$/i;
const shorthandHexWithAlpha = /^#[0-9A-F]{4}$/i;
const longhandHexWithAlpha = /^#[0-9A-F]{8}$/i;
const alphaToOpacity = (alpha) => Number((alpha * 100).toFixed());
const opacityToAlpha = (opacity) => Number((opacity / 100).toFixed(2));
function isValidHex(hex, hasAlpha = false) {
  return isShorthandHex(hex, hasAlpha) || isLonghandHex(hex, hasAlpha);
}
function evaluateHex(hex, length, pattern) {
  if (!hex) {
    return false;
  }
  return hex.length === length && pattern.test(hex);
}
function isShorthandHex(hex, hasAlpha = false) {
  const hexLength = hasAlpha ? 5 : 4;
  const hexPattern = hasAlpha ? shorthandHexWithAlpha : shorthandHex;
  return evaluateHex(hex, hexLength, hexPattern);
}
function isLonghandHex(hex, hasAlpha = false) {
  const hexLength = hasAlpha ? 9 : 7;
  const hexPattern = hasAlpha ? longhandHexWithAlpha : longhandHex;
  return evaluateHex(hex, hexLength, hexPattern);
}
function normalizeHex(hex, hasAlpha = false, convertFromHexToHexa = false) {
  hex = hex.toLowerCase();
  if (!hex.startsWith("#")) {
    hex = `#${hex}`;
  }
  if (isShorthandHex(hex, hasAlpha)) {
    return rgbToHex(hexToRGB(hex, hasAlpha));
  }
  if (hasAlpha && convertFromHexToHexa && isValidHex(hex, false /* we only care about RGB hex for conversion */)) {
    const isShorthand = isShorthandHex(hex, false);
    return rgbToHex(hexToRGB(`${hex}${isShorthand ? "f" : "ff"}`, true));
  }
  return hex;
}
function hexify(color, hasAlpha = false) {
  return hasAlpha ? color.hexa() : color.hex();
}
function rgbToHex(color) {
  const { r, g, b } = color;
  const rChars = numToHex(r);
  const gChars = numToHex(g);
  const bChars = numToHex(b);
  const alphaChars = "a" in color ? numToHex(color.a * 255) : "";
  return `#${rChars}${gChars}${bChars}${alphaChars}`.toLowerCase();
}
function numToHex(num) {
  return num.toString(16).padStart(2, "0");
}
function normalizeAlpha(colorObject) {
  const normalized = { ...colorObject, a: colorObject.alpha ?? 1 /* Color() will omit alpha if 1 */ };
  delete normalized.alpha;
  return normalized;
}
function normalizeColor(alphaColorObject) {
  const normalized = { ...alphaColorObject, alpha: alphaColorObject.a ?? 1 };
  delete normalized.a;
  return normalized;
}
function hexToRGB(hex, hasAlpha = false) {
  if (!isValidHex(hex, hasAlpha)) {
    return null;
  }
  hex = hex.replace("#", "");
  let r;
  let g;
  let b;
  let a;
  const isShorthand = hex.length === 3 || hex.length === 4;
  if (isShorthand) {
    const [first, second, third, fourth] = hex.split("");
    r = parseInt(`${first}${first}`, 16);
    g = parseInt(`${second}${second}`, 16);
    b = parseInt(`${third}${third}`, 16);
    a = parseInt(`${fourth}${fourth}`, 16) / 255;
  }
  else {
    r = parseInt(hex.slice(0, 2), 16);
    g = parseInt(hex.slice(2, 4), 16);
    b = parseInt(hex.slice(4, 6), 16);
    a = parseInt(hex.slice(6, 8), 16) / 255;
  }
  return isNaN(a) ? { r, g, b } : { r, g, b, a };
}
// these utils allow users to pass enum values as strings without having to access the enum
// based on the approach suggested by https://github.com/microsoft/TypeScript/issues/17690#issuecomment-321365759,
const enumify = (x) => x;
const CSSColorMode = enumify({
  HEX: "hex",
  HEXA: "hexa",
  RGB_CSS: "rgb-css",
  RGBA_CSS: "rgba-css",
  HSL_CSS: "hsl-css",
  HSLA_CSS: "hsla-css",
});
const ObjectColorMode = enumify({
  RGB: "rgb",
  RGBA: "rgba",
  HSL: "hsl",
  HSLA: "hsla",
  HSV: "hsv",
  HSVA: "hsva",
});
function parseMode(colorValue) {
  if (typeof colorValue === "string") {
    if (colorValue.startsWith("#")) {
      const { length } = colorValue;
      if (length === 4 || length === 7) {
        return CSSColorMode.HEX;
      }
      if (length === 5 || length === 9) {
        return CSSColorMode.HEXA;
      }
    }
    if (colorValue.startsWith("rgba(")) {
      return CSSColorMode.RGBA_CSS;
    }
    if (colorValue.startsWith("rgb(")) {
      return CSSColorMode.RGB_CSS;
    }
    if (colorValue.startsWith("hsl(")) {
      return CSSColorMode.HSL_CSS;
    }
    if (colorValue.startsWith("hsla(")) {
      return CSSColorMode.HSLA_CSS;
    }
  }
  if (typeof colorValue === "object") {
    if (hasChannels(colorValue, "r", "g", "b")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.RGBA : ObjectColorMode.RGB;
    }
    if (hasChannels(colorValue, "h", "s", "l")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.HSLA : ObjectColorMode.HSL;
    }
    if (hasChannels(colorValue, "h", "s", "v")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.HSVA : ObjectColorMode.HSV;
    }
  }
  return null;
}
function hasChannels(colorObject, ...channels) {
  return channels.every((channel) => channel && colorObject && `${channel}` in colorObject);
}
function colorEqual(value1, value2) {
  return value1?.rgb().array().toString() === value2?.rgb().array().toString();
}
function alphaCompatible(mode) {
  return (mode === CSSColorMode.HEXA ||
    mode === CSSColorMode.RGBA_CSS ||
    mode === CSSColorMode.HSLA_CSS ||
    mode === ObjectColorMode.RGBA ||
    mode === ObjectColorMode.HSLA ||
    mode === ObjectColorMode.HSVA);
}
function toAlphaMode(mode) {
  const alphaMode = mode === CSSColorMode.HEX
    ? CSSColorMode.HEXA
    : mode === CSSColorMode.RGB_CSS
      ? CSSColorMode.RGBA_CSS
      : mode === CSSColorMode.HSL_CSS
        ? CSSColorMode.HSLA_CSS
        : mode === ObjectColorMode.RGB
          ? ObjectColorMode.RGBA
          : mode === ObjectColorMode.HSL
            ? ObjectColorMode.HSLA
            : mode === ObjectColorMode.HSV
              ? ObjectColorMode.HSVA
              : mode;
  return alphaMode;
}
function toNonAlphaMode(mode) {
  const nonAlphaMode = mode === CSSColorMode.HEXA
    ? CSSColorMode.HEX
    : mode === CSSColorMode.RGBA_CSS
      ? CSSColorMode.RGB_CSS
      : mode === CSSColorMode.HSLA_CSS
        ? CSSColorMode.HSL_CSS
        : mode === ObjectColorMode.RGBA
          ? ObjectColorMode.RGB
          : mode === ObjectColorMode.HSLA
            ? ObjectColorMode.HSL
            : mode === ObjectColorMode.HSVA
              ? ObjectColorMode.HSV
              : mode;
  return nonAlphaMode;
}



//# sourceMappingURL=utils-a44d0b30.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsY2l0ZS1jb21wb25lbnRzL2NodW5rcy92ZW5kb3JzLW5vZGVfbW9kdWxlc19lc3JpX2NhbGNpdGUtY29tcG9uZW50c19kaXN0X2VzbV9jYWxjaXRlLWNvbG9yLXBpY2tlcl8zX2VudHJ5X2pzLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lIO0FBQ1E7QUFDbU47QUFDaE47QUFDbkU7QUFDOEQ7QUFDaEM7QUFDSjtBQUN3QztBQUNwRTtBQUMzQjtBQUNLO0FBQ0Y7QUFDRTtBQUNEOztBQUVoQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DLFNBQVM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixJQUFJO0FBQzdCLHdCQUF3QixFQUFFLFdBQVcsRUFBRTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsSUFBSTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixJQUFJO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTywyQkFBMkI7QUFDbEMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTywyQkFBMkI7QUFDbEMsUUFBUSw0QkFBNEI7QUFDcEMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTyw2QkFBNkI7QUFDcEMsV0FBVyxpQ0FBaUM7QUFDNUMsVUFBVSxnQ0FBZ0M7QUFDMUMsV0FBVyxpQ0FBaUM7QUFDNUMsT0FBTyxxQ0FBcUM7QUFDNUMsU0FBUywyQ0FBMkM7QUFDcEQsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0Esc0RBQXNELGdCQUFnQjtBQUN0RSxvREFBb0QsY0FBYztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxRQUFRO0FBQ2xDLGtCQUFrQixRQUFRLFFBQVE7QUFDbEMsa0JBQWtCLFFBQVEsT0FBTztBQUNqQyxrQkFBa0IsUUFBUSxPQUFPO0FBQ2pDLGtCQUFrQixRQUFRLE9BQU87QUFDakMsa0JBQWtCLFFBQVEsT0FBTztBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RUFBNEU7O0FBRTVFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsRUFBRSxVQUFVLEVBQUU7QUFDL0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsYUFBYTtBQUMxQztBQUNBLGdCQUFnQixhQUFhLGFBQWE7QUFDMUM7QUFDQSxnQkFBZ0IsYUFBYSxhQUFhO0FBQzFDO0FBQ0EsZ0JBQWdCLGFBQWEsYUFBYTtBQUMxQztBQUNBLGdCQUFnQixhQUFhLGFBQWE7QUFDMUM7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3REFBd0QsdUNBQXVDO0FBQy9GLHNEQUFzRCxxQ0FBcUM7O0FBRTNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTLFFBQVE7QUFDakI7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CLFNBQVMsUUFBUTs7QUFFakIsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFVBQVU7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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dUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU0sRUFBRSxNQUFNO0FBQ2xDLG9CQUFvQixPQUFPLEVBQUUsT0FBTztBQUNwQyxvQkFBb0IsTUFBTSxFQUFFLE1BQU07QUFDbEMsb0JBQW9CLE9BQU8sRUFBRSxPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxRQUFRO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdVOztBQUVoVSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvZXNtL2NhbGNpdGUtY29sb3ItcGlja2VyXzMuZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9lc20vbG9hZGFibGUtYjE3Mzk2ZTAuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9lc20vbWF0aC05MjJlMzdlYy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2VzbS91dGlscy1hNDRkMGIzMC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvbWFpbi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjIuMC4wXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgZyBhcyBnZXRFbGVtZW50LCBGIGFzIEZyYWdtZW50IH0gZnJvbSAnLi9pbmRleC04NmZhZWY5Yy5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzUHJpbWFyeVBvaW50ZXJCdXR0b24sIGcgYXMgZ2V0RWxlbWVudERpciwgZCBhcyBmb2N1c0VsZW1lbnQsIGogYXMgZ2V0TW9kZU5hbWUgfSBmcm9tICcuL2RvbS1lZDAwYTU4NS5qcyc7XG5pbXBvcnQgeyBDIGFzIENTU0NvbG9yTW9kZSwgbiBhcyBub3JtYWxpemVIZXgsIGEgYXMgaGV4aWZ5LCBvIGFzIG9wYWNpdHlUb0FscGhhLCBiIGFzIGFscGhhVG9PcGFjaXR5LCBjIGFzIGFscGhhQ29tcGF0aWJsZSwgcCBhcyBwYXJzZU1vZGUsIGQgYXMgY29sb3JFcXVhbCwgdCBhcyB0b05vbkFscGhhTW9kZSwgZSBhcyBub3JtYWxpemVBbHBoYSwgZiBhcyB0b0FscGhhTW9kZSwgZyBhcyBub3JtYWxpemVDb2xvciwgaiBhcyBpc0xvbmdoYW5kSGV4LCBpIGFzIGlzVmFsaWRIZXgsIHIgYXMgcmdiVG9IZXgsIGsgYXMgaGV4Q2hhciB9IGZyb20gJy4vdXRpbHMtYTQ0ZDBiMzAuanMnO1xuaW1wb3J0IHsgYyBhcyBjb25uZWN0SW50ZXJhY3RpdmUsIGQgYXMgZGlzY29ubmVjdEludGVyYWN0aXZlLCB1IGFzIHVwZGF0ZUhvc3RJbnRlcmFjdGlvbiB9IGZyb20gJy4vaW50ZXJhY3RpdmUtY2JkOGE2ZGMuanMnO1xuaW1wb3J0IHsgaSBhcyBpc0FjdGl2YXRpb25LZXkgfSBmcm9tICcuL2tleS02MWY4MmRkYi5qcyc7XG5pbXBvcnQgeyBjIGFzIGNvbXBvbmVudEZvY3VzYWJsZSwgcyBhcyBzZXRVcExvYWRhYmxlQ29tcG9uZW50LCBhIGFzIHNldENvbXBvbmVudExvYWRlZCB9IGZyb20gJy4vbG9hZGFibGUtYjE3Mzk2ZTAuanMnO1xuaW1wb3J0IHsgYyBhcyBjb25uZWN0TG9jYWxpemVkLCBkIGFzIGRpc2Nvbm5lY3RMb2NhbGl6ZWQgfSBmcm9tICcuL2xvY2FsZS02ZTc4M2NmMC5qcyc7XG5pbXBvcnQgeyByIGFzIHJlbWFwLCBjIGFzIGNsYW1wLCBhIGFzIGNsb3NlVG9SYW5nZUVkZ2UgfSBmcm9tICcuL21hdGgtOTIyZTM3ZWMuanMnO1xuaW1wb3J0IHsgdSBhcyB1cGRhdGVNZXNzYWdlcywgcyBhcyBzZXRVcE1lc3NhZ2VzLCBjIGFzIGNvbm5lY3RNZXNzYWdlcywgZCBhcyBkaXNjb25uZWN0TWVzc2FnZXMgfSBmcm9tICcuL3Q5bi0wYmNkY2E1NC5qcyc7XG5pbXBvcnQgeyB0IGFzIHRocm90dGxlIH0gZnJvbSAnLi90aHJvdHRsZS1mNGQ4YzllNC5qcyc7XG5pbXBvcnQgJy4vZ3VpZC0yMWZlY2ZhNC5qcyc7XG5pbXBvcnQgJy4vcmVzb3VyY2VzLWNmODIzODhjLmpzJztcbmltcG9ydCAnLi9icm93c2VyLWVjZTI5ZGE3LmpzJztcbmltcG9ydCAnLi9vYnNlcnZlcnMtNzFkMzMyZGIuanMnO1xuaW1wb3J0ICcuL2RlYm91bmNlLTg1OTU4YmIxLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIGJhc2VkaXIsIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0ge1xuXHRcdHBhdGg6IGJhc2VkaXIsXG5cdFx0ZXhwb3J0czoge30sXG5cdFx0cmVxdWlyZTogZnVuY3Rpb24gKHBhdGgsIGJhc2UpIHtcblx0XHRcdHJldHVybiBjb21tb25qc1JlcXVpcmUoKTtcblx0XHR9XG5cdH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlICgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBAcm9sbHVwL3BsdWdpbi1jb21tb25qcycpO1xufVxuXG52YXIgY29sb3JOYW1lJDEgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xuXG52YXIgaXNBcnJheWlzaCA9IGZ1bmN0aW9uIGlzQXJyYXlpc2gob2JqKSB7XG5cdGlmICghb2JqIHx8IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5IHx8IEFycmF5LmlzQXJyYXkob2JqKSB8fFxuXHRcdChvYmoubGVuZ3RoID49IDAgJiYgKG9iai5zcGxpY2UgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuXHRcdFx0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCAob2JqLmxlbmd0aCAtIDEpKSAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPT0gJ1N0cmluZycpKSk7XG59O1xuXG52YXIgc2ltcGxlU3dpenpsZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuXG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG52YXIgc3dpenpsZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3dpenpsZShhcmdzKSB7XG5cdHZhciByZXN1bHRzID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHR2YXIgYXJnID0gYXJnc1tpXTtcblxuXHRcdGlmIChpc0FycmF5aXNoKGFyZykpIHtcblx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tL2phdmFzY3JpcHQtYXJyYXktY29uY2F0LXZzLXB1c2gvOThcblx0XHRcdHJlc3VsdHMgPSBjb25jYXQuY2FsbChyZXN1bHRzLCBzbGljZS5jYWxsKGFyZykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHRzLnB1c2goYXJnKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbnN3aXp6bGUud3JhcCA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBmbihzd2l6emxlKGFyZ3VtZW50cykpO1xuXHR9O1xufTtcbn0pO1xuXG52YXIgY29sb3JTdHJpbmcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4vKiBNSVQgbGljZW5zZSAqL1xuXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHJldmVyc2VOYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8vIGNyZWF0ZSBhIGxpc3Qgb2YgcmV2ZXJzZSBjb2xvciBuYW1lc1xuZm9yICh2YXIgbmFtZSBpbiBjb2xvck5hbWUkMSkge1xuXHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb2xvck5hbWUkMSwgbmFtZSkpIHtcblx0XHRyZXZlcnNlTmFtZXNbY29sb3JOYW1lJDFbbmFtZV1dID0gbmFtZTtcblx0fVxufVxuXG52YXIgY3MgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0dG86IHt9LFxuXHRnZXQ6IHt9XG59O1xuXG5jcy5nZXQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdHZhciBwcmVmaXggPSBzdHJpbmcuc3Vic3RyaW5nKDAsIDMpLnRvTG93ZXJDYXNlKCk7XG5cdHZhciB2YWw7XG5cdHZhciBtb2RlbDtcblx0c3dpdGNoIChwcmVmaXgpIHtcblx0XHRjYXNlICdoc2wnOlxuXHRcdFx0dmFsID0gY3MuZ2V0LmhzbChzdHJpbmcpO1xuXHRcdFx0bW9kZWwgPSAnaHNsJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2h3Yic6XG5cdFx0XHR2YWwgPSBjcy5nZXQuaHdiKHN0cmluZyk7XG5cdFx0XHRtb2RlbCA9ICdod2InO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHZhbCA9IGNzLmdldC5yZ2Ioc3RyaW5nKTtcblx0XHRcdG1vZGVsID0gJ3JnYic7XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdGlmICghdmFsKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4ge21vZGVsOiBtb2RlbCwgdmFsdWU6IHZhbH07XG59O1xuXG5jcy5nZXQucmdiID0gZnVuY3Rpb24gKHN0cmluZykge1xuXHRpZiAoIXN0cmluZykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGFiYnIgPSAvXiMoW2EtZjAtOV17Myw0fSkkL2k7XG5cdHZhciBoZXggPSAvXiMoW2EtZjAtOV17Nn0pKFthLWYwLTldezJ9KT8kL2k7XG5cdHZhciByZ2JhID0gL15yZ2JhP1xcKFxccyooWystXT9cXGQrKSg/PVtcXHMsXSlcXHMqKD86LFxccyopPyhbKy1dP1xcZCspKD89W1xccyxdKVxccyooPzosXFxzKik/KFsrLV0/XFxkKylcXHMqKD86Wyx8XFwvXVxccyooWystXT9bXFxkXFwuXSspKCU/KVxccyopP1xcKSQvO1xuXHR2YXIgcGVyID0gL15yZ2JhP1xcKFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKiw/XFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLD9cXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyooPzpbLHxcXC9dXFxzKihbKy1dP1tcXGRcXC5dKykoJT8pXFxzKik/XFwpJC87XG5cdHZhciBrZXl3b3JkID0gL14oXFx3KykkLztcblxuXHR2YXIgcmdiID0gWzAsIDAsIDAsIDFdO1xuXHR2YXIgbWF0Y2g7XG5cdHZhciBpO1xuXHR2YXIgaGV4QWxwaGE7XG5cblx0aWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGhleCkpIHtcblx0XHRoZXhBbHBoYSA9IG1hdGNoWzJdO1xuXHRcdG1hdGNoID0gbWF0Y2hbMV07XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHQvLyBodHRwczovL2pzcGVyZi5jb20vc2xpY2UtdnMtc3Vic3RyLXZzLXN1YnN0cmluZy1tZXRob2RzLWxvbmctc3RyaW5nLzE5XG5cdFx0XHR2YXIgaTIgPSBpICogMjtcblx0XHRcdHJnYltpXSA9IHBhcnNlSW50KG1hdGNoLnNsaWNlKGkyLCBpMiArIDIpLCAxNik7XG5cdFx0fVxuXG5cdFx0aWYgKGhleEFscGhhKSB7XG5cdFx0XHRyZ2JbM10gPSBwYXJzZUludChoZXhBbHBoYSwgMTYpIC8gMjU1O1xuXHRcdH1cblx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChhYmJyKSkge1xuXHRcdG1hdGNoID0gbWF0Y2hbMV07XG5cdFx0aGV4QWxwaGEgPSBtYXRjaFszXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2ldICsgbWF0Y2hbaV0sIDE2KTtcblx0XHR9XG5cblx0XHRpZiAoaGV4QWxwaGEpIHtcblx0XHRcdHJnYlszXSA9IHBhcnNlSW50KGhleEFscGhhICsgaGV4QWxwaGEsIDE2KSAvIDI1NTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0sIDApO1xuXHRcdH1cblxuXHRcdGlmIChtYXRjaFs0XSkge1xuXHRcdFx0aWYgKG1hdGNoWzVdKSB7XG5cdFx0XHRcdHJnYlszXSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pICogMC4wMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJnYlszXSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChwZXIpKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0cmdiW2ldID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KG1hdGNoW2kgKyAxXSkgKiAyLjU1KTtcblx0XHR9XG5cblx0XHRpZiAobWF0Y2hbNF0pIHtcblx0XHRcdGlmIChtYXRjaFs1XSkge1xuXHRcdFx0XHRyZ2JbM10gPSBwYXJzZUZsb2F0KG1hdGNoWzRdKSAqIDAuMDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZ2JbM10gPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goa2V5d29yZCkpIHtcblx0XHRpZiAobWF0Y2hbMV0gPT09ICd0cmFuc3BhcmVudCcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgMCwgMF07XG5cdFx0fVxuXG5cdFx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbG9yTmFtZSQxLCBtYXRjaFsxXSkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJnYiA9IGNvbG9yTmFtZSQxW21hdGNoWzFdXTtcblx0XHRyZ2JbM10gPSAxO1xuXG5cdFx0cmV0dXJuIHJnYjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRyZ2JbaV0gPSBjbGFtcChyZ2JbaV0sIDAsIDI1NSk7XG5cdH1cblx0cmdiWzNdID0gY2xhbXAocmdiWzNdLCAwLCAxKTtcblxuXHRyZXR1cm4gcmdiO1xufTtcblxuY3MuZ2V0LmhzbCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0aWYgKCFzdHJpbmcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBoc2wgPSAvXmhzbGE/XFwoXFxzKihbKy1dPyg/OlxcZHswLDN9XFwuKT9cXGQrKSg/OmRlZyk/XFxzKiw/XFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKiw/XFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OlssfFxcL11cXHMqKFsrLV0/KD89XFwuXFxkfFxcZCkoPzowfFsxLTldXFxkKik/KD86XFwuXFxkKik/KD86W2VFXVsrLV0/XFxkKyk/KVxccyopP1xcKSQvO1xuXHR2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHNsKTtcblxuXHRpZiAobWF0Y2gpIHtcblx0XHR2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcblx0XHR2YXIgaCA9ICgocGFyc2VGbG9hdChtYXRjaFsxXSkgJSAzNjApICsgMzYwKSAlIDM2MDtcblx0XHR2YXIgcyA9IGNsYW1wKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApO1xuXHRcdHZhciBsID0gY2xhbXAocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCk7XG5cdFx0dmFyIGEgPSBjbGFtcChpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuXG5cdFx0cmV0dXJuIFtoLCBzLCBsLCBhXTtcblx0fVxuXG5cdHJldHVybiBudWxsO1xufTtcblxuY3MuZ2V0Lmh3YiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0aWYgKCFzdHJpbmcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBod2IgPSAvXmh3YlxcKFxccyooWystXT9cXGR7MCwzfSg/OlxcLlxcZCspPykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT8oPz1cXC5cXGR8XFxkKSg/OjB8WzEtOV1cXGQqKT8oPzpcXC5cXGQqKT8oPzpbZUVdWystXT9cXGQrKT8pXFxzKik/XFwpJC87XG5cdHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xuXG5cdGlmIChtYXRjaCkge1xuXHRcdHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuXHRcdHZhciBoID0gKChwYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCkgKyAzNjApICUgMzYwO1xuXHRcdHZhciB3ID0gY2xhbXAocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCk7XG5cdFx0dmFyIGIgPSBjbGFtcChwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKTtcblx0XHR2YXIgYSA9IGNsYW1wKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG5cdFx0cmV0dXJuIFtoLCB3LCBiLCBhXTtcblx0fVxuXG5cdHJldHVybiBudWxsO1xufTtcblxuY3MudG8uaGV4ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmdiYSA9IHNpbXBsZVN3aXp6bGUoYXJndW1lbnRzKTtcblxuXHRyZXR1cm4gKFxuXHRcdCcjJyArXG5cdFx0aGV4RG91YmxlKHJnYmFbMF0pICtcblx0XHRoZXhEb3VibGUocmdiYVsxXSkgK1xuXHRcdGhleERvdWJsZShyZ2JhWzJdKSArXG5cdFx0KHJnYmFbM10gPCAxXG5cdFx0XHQ/IChoZXhEb3VibGUoTWF0aC5yb3VuZChyZ2JhWzNdICogMjU1KSkpXG5cdFx0XHQ6ICcnKVxuXHQpO1xufTtcblxuY3MudG8ucmdiID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmdiYSA9IHNpbXBsZVN3aXp6bGUoYXJndW1lbnRzKTtcblxuXHRyZXR1cm4gcmdiYS5sZW5ndGggPCA0IHx8IHJnYmFbM10gPT09IDFcblx0XHQ/ICdyZ2IoJyArIE1hdGgucm91bmQocmdiYVswXSkgKyAnLCAnICsgTWF0aC5yb3VuZChyZ2JhWzFdKSArICcsICcgKyBNYXRoLnJvdW5kKHJnYmFbMl0pICsgJyknXG5cdFx0OiAncmdiYSgnICsgTWF0aC5yb3VuZChyZ2JhWzBdKSArICcsICcgKyBNYXRoLnJvdW5kKHJnYmFbMV0pICsgJywgJyArIE1hdGgucm91bmQocmdiYVsyXSkgKyAnLCAnICsgcmdiYVszXSArICcpJztcbn07XG5cbmNzLnRvLnJnYi5wZXJjZW50ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmdiYSA9IHNpbXBsZVN3aXp6bGUoYXJndW1lbnRzKTtcblxuXHR2YXIgciA9IE1hdGgucm91bmQocmdiYVswXSAvIDI1NSAqIDEwMCk7XG5cdHZhciBnID0gTWF0aC5yb3VuZChyZ2JhWzFdIC8gMjU1ICogMTAwKTtcblx0dmFyIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0gLyAyNTUgKiAxMDApO1xuXG5cdHJldHVybiByZ2JhLmxlbmd0aCA8IDQgfHwgcmdiYVszXSA9PT0gMVxuXHRcdD8gJ3JnYignICsgciArICclLCAnICsgZyArICclLCAnICsgYiArICclKSdcblx0XHQ6ICdyZ2JhKCcgKyByICsgJyUsICcgKyBnICsgJyUsICcgKyBiICsgJyUsICcgKyByZ2JhWzNdICsgJyknO1xufTtcblxuY3MudG8uaHNsID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaHNsYSA9IHNpbXBsZVN3aXp6bGUoYXJndW1lbnRzKTtcblx0cmV0dXJuIGhzbGEubGVuZ3RoIDwgNCB8fCBoc2xhWzNdID09PSAxXG5cdFx0PyAnaHNsKCcgKyBoc2xhWzBdICsgJywgJyArIGhzbGFbMV0gKyAnJSwgJyArIGhzbGFbMl0gKyAnJSknXG5cdFx0OiAnaHNsYSgnICsgaHNsYVswXSArICcsICcgKyBoc2xhWzFdICsgJyUsICcgKyBoc2xhWzJdICsgJyUsICcgKyBoc2xhWzNdICsgJyknO1xufTtcblxuLy8gaHdiIGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHJnYihhKSAmIGhzbChhKSBzaW5jZSB0aGVyZSBpcyBubyBhbHBoYSBzcGVjaWZpYyBzeW50YXhcbi8vIChod2IgaGF2ZSBhbHBoYSBvcHRpb25hbCAmIDEgaXMgZGVmYXVsdCB2YWx1ZSlcbmNzLnRvLmh3YiA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGh3YmEgPSBzaW1wbGVTd2l6emxlKGFyZ3VtZW50cyk7XG5cblx0dmFyIGEgPSAnJztcblx0aWYgKGh3YmEubGVuZ3RoID49IDQgJiYgaHdiYVszXSAhPT0gMSkge1xuXHRcdGEgPSAnLCAnICsgaHdiYVszXTtcblx0fVxuXG5cdHJldHVybiAnaHdiKCcgKyBod2JhWzBdICsgJywgJyArIGh3YmFbMV0gKyAnJSwgJyArIGh3YmFbMl0gKyAnJScgKyBhICsgJyknO1xufTtcblxuY3MudG8ua2V5d29yZCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0cmV0dXJuIHJldmVyc2VOYW1lc1tyZ2Iuc2xpY2UoMCwgMyldO1xufTtcblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuXHRyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBudW0pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBoZXhEb3VibGUobnVtKSB7XG5cdHZhciBzdHIgPSBNYXRoLnJvdW5kKG51bSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAoc3RyLmxlbmd0aCA8IDIpID8gJzAnICsgc3RyIDogc3RyO1xufVxufSk7XG5cbnZhciBjb2xvck5hbWUgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xuXG4vKiBNSVQgbGljZW5zZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tbWl4ZWQtb3BlcmF0b3JzICovXG5cblxuLy8gTk9URTogY29udmVyc2lvbnMgc2hvdWxkIG9ubHkgcmV0dXJuIHByaW1pdGl2ZSB2YWx1ZXMgKGkuZS4gYXJyYXlzLCBvclxuLy8gICAgICAgdmFsdWVzIHRoYXQgZ2l2ZSBjb3JyZWN0IGB0eXBlb2ZgIHJlc3VsdHMpLlxuLy8gICAgICAgZG8gbm90IHVzZSBib3ggdmFsdWVzIHR5cGVzIChpLmUuIE51bWJlcigpLCBTdHJpbmcoKSwgZXRjLilcblxuY29uc3QgcmV2ZXJzZUtleXdvcmRzID0ge307XG5mb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb2xvck5hbWUpKSB7XG5cdHJldmVyc2VLZXl3b3Jkc1tjb2xvck5hbWVba2V5XV0gPSBrZXk7XG59XG5cbmNvbnN0IGNvbnZlcnQkMSA9IHtcblx0cmdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3JnYid9LFxuXHRoc2w6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHNsJ30sXG5cdGhzdjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdoc3YnfSxcblx0aHdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2h3Yid9LFxuXHRjbXlrOiB7Y2hhbm5lbHM6IDQsIGxhYmVsczogJ2NteWsnfSxcblx0eHl6OiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3h5eid9LFxuXHRsYWI6IHtjaGFubmVsczogMywgbGFiZWxzOiAnbGFiJ30sXG5cdGxjaDoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdsY2gnfSxcblx0aGV4OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydoZXgnXX0sXG5cdGtleXdvcmQ6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2tleXdvcmQnXX0sXG5cdGFuc2kxNjoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnYW5zaTE2J119LFxuXHRhbnNpMjU2OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydhbnNpMjU2J119LFxuXHRoY2c6IHtjaGFubmVsczogMywgbGFiZWxzOiBbJ2gnLCAnYycsICdnJ119LFxuXHRhcHBsZToge2NoYW5uZWxzOiAzLCBsYWJlbHM6IFsncjE2JywgJ2cxNicsICdiMTYnXX0sXG5cdGdyYXk6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2dyYXknXX1cbn07XG5cbnZhciBjb252ZXJzaW9ucyA9IGNvbnZlcnQkMTtcblxuLy8gSGlkZSAuY2hhbm5lbHMgYW5kIC5sYWJlbHMgcHJvcGVydGllc1xuZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3Qua2V5cyhjb252ZXJ0JDEpKSB7XG5cdGlmICghKCdjaGFubmVscycgaW4gY29udmVydCQxW21vZGVsXSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG5cdH1cblxuXHRpZiAoISgnbGFiZWxzJyBpbiBjb252ZXJ0JDFbbW9kZWxdKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVsIGxhYmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0fVxuXG5cdGlmIChjb252ZXJ0JDFbbW9kZWxdLmxhYmVscy5sZW5ndGggIT09IGNvbnZlcnQkMVttb2RlbF0uY2hhbm5lbHMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NoYW5uZWwgYW5kIGxhYmVsIGNvdW50cyBtaXNtYXRjaDogJyArIG1vZGVsKTtcblx0fVxuXG5cdGNvbnN0IHtjaGFubmVscywgbGFiZWxzfSA9IGNvbnZlcnQkMVttb2RlbF07XG5cdGRlbGV0ZSBjb252ZXJ0JDFbbW9kZWxdLmNoYW5uZWxzO1xuXHRkZWxldGUgY29udmVydCQxW21vZGVsXS5sYWJlbHM7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0JDFbbW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNoYW5uZWxzfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0JDFbbW9kZWxdLCAnbGFiZWxzJywge3ZhbHVlOiBsYWJlbHN9KTtcbn1cblxuY29udmVydCQxLnJnYi5oc2wgPSBmdW5jdGlvbiAocmdiKSB7XG5cdGNvbnN0IHIgPSByZ2JbMF0gLyAyNTU7XG5cdGNvbnN0IGcgPSByZ2JbMV0gLyAyNTU7XG5cdGNvbnN0IGIgPSByZ2JbMl0gLyAyNTU7XG5cdGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0Y29uc3QgZGVsdGEgPSBtYXggLSBtaW47XG5cdGxldCBoO1xuXHRsZXQgcztcblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRoID0gMDtcblx0fSBlbHNlIGlmIChyID09PSBtYXgpIHtcblx0XHRoID0gKGcgLSBiKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuXHRcdGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuXHRcdGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXHR9XG5cblx0aCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdGNvbnN0IGwgPSAobWluICsgbWF4KSAvIDI7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0cyA9IDA7XG5cdH0gZWxzZSBpZiAobCA8PSAwLjUpIHtcblx0XHRzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcblx0fSBlbHNlIHtcblx0XHRzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdH1cblxuXHRyZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydCQxLnJnYi5oc3YgPSBmdW5jdGlvbiAocmdiKSB7XG5cdGxldCByZGlmO1xuXHRsZXQgZ2RpZjtcblx0bGV0IGJkaWY7XG5cdGxldCBoO1xuXHRsZXQgcztcblxuXHRjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuXHRjb25zdCBnID0gcmdiWzFdIC8gMjU1O1xuXHRjb25zdCBiID0gcmdiWzJdIC8gMjU1O1xuXHRjb25zdCB2ID0gTWF0aC5tYXgociwgZywgYik7XG5cdGNvbnN0IGRpZmYgPSB2IC0gTWF0aC5taW4ociwgZywgYik7XG5cdGNvbnN0IGRpZmZjID0gZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gKHYgLSBjKSAvIDYgLyBkaWZmICsgMSAvIDI7XG5cdH07XG5cblx0aWYgKGRpZmYgPT09IDApIHtcblx0XHRoID0gMDtcblx0XHRzID0gMDtcblx0fSBlbHNlIHtcblx0XHRzID0gZGlmZiAvIHY7XG5cdFx0cmRpZiA9IGRpZmZjKHIpO1xuXHRcdGdkaWYgPSBkaWZmYyhnKTtcblx0XHRiZGlmID0gZGlmZmMoYik7XG5cblx0XHRpZiAociA9PT0gdikge1xuXHRcdFx0aCA9IGJkaWYgLSBnZGlmO1xuXHRcdH0gZWxzZSBpZiAoZyA9PT0gdikge1xuXHRcdFx0aCA9ICgxIC8gMykgKyByZGlmIC0gYmRpZjtcblx0XHR9IGVsc2UgaWYgKGIgPT09IHYpIHtcblx0XHRcdGggPSAoMiAvIDMpICsgZ2RpZiAtIHJkaWY7XG5cdFx0fVxuXG5cdFx0aWYgKGggPCAwKSB7XG5cdFx0XHRoICs9IDE7XG5cdFx0fSBlbHNlIGlmIChoID4gMSkge1xuXHRcdFx0aCAtPSAxO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbXG5cdFx0aCAqIDM2MCxcblx0XHRzICogMTAwLFxuXHRcdHYgKiAxMDBcblx0XTtcbn07XG5cbmNvbnZlcnQkMS5yZ2IuaHdiID0gZnVuY3Rpb24gKHJnYikge1xuXHRjb25zdCByID0gcmdiWzBdO1xuXHRjb25zdCBnID0gcmdiWzFdO1xuXHRsZXQgYiA9IHJnYlsyXTtcblx0Y29uc3QgaCA9IGNvbnZlcnQkMS5yZ2IuaHNsKHJnYilbMF07XG5cdGNvbnN0IHcgPSAxIC8gMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpO1xuXG5cdGIgPSAxIC0gMSAvIDI1NSAqIE1hdGgubWF4KHIsIE1hdGgubWF4KGcsIGIpKTtcblxuXHRyZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xufTtcblxuY29udmVydCQxLnJnYi5jbXlrID0gZnVuY3Rpb24gKHJnYikge1xuXHRjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuXHRjb25zdCBnID0gcmdiWzFdIC8gMjU1O1xuXHRjb25zdCBiID0gcmdiWzJdIC8gMjU1O1xuXG5cdGNvbnN0IGsgPSBNYXRoLm1pbigxIC0gciwgMSAtIGcsIDEgLSBiKTtcblx0Y29uc3QgYyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXHRjb25zdCBtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cdGNvbnN0IHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gaykgfHwgMDtcblxuXHRyZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xufTtcblxuZnVuY3Rpb24gY29tcGFyYXRpdmVEaXN0YW5jZSh4LCB5KSB7XG5cdC8qXG5cdFx0U2VlIGh0dHBzOi8vZW4ubS53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2Rpc3RhbmNlI1NxdWFyZWRfRXVjbGlkZWFuX2Rpc3RhbmNlXG5cdCovXG5cdHJldHVybiAoXG5cdFx0KCh4WzBdIC0geVswXSkgKiogMikgK1xuXHRcdCgoeFsxXSAtIHlbMV0pICoqIDIpICtcblx0XHQoKHhbMl0gLSB5WzJdKSAqKiAyKVxuXHQpO1xufVxuXG5jb252ZXJ0JDEucmdiLmtleXdvcmQgPSBmdW5jdGlvbiAocmdiKSB7XG5cdGNvbnN0IHJldmVyc2VkID0gcmV2ZXJzZUtleXdvcmRzW3JnYl07XG5cdGlmIChyZXZlcnNlZCkge1xuXHRcdHJldHVybiByZXZlcnNlZDtcblx0fVxuXG5cdGxldCBjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG5cdGxldCBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG5cblx0Zm9yIChjb25zdCBrZXl3b3JkIG9mIE9iamVjdC5rZXlzKGNvbG9yTmFtZSkpIHtcblx0XHRjb25zdCB2YWx1ZSA9IGNvbG9yTmFtZVtrZXl3b3JkXTtcblxuXHRcdC8vIENvbXB1dGUgY29tcGFyYXRpdmUgZGlzdGFuY2Vcblx0XHRjb25zdCBkaXN0YW5jZSA9IGNvbXBhcmF0aXZlRGlzdGFuY2UocmdiLCB2YWx1ZSk7XG5cblx0XHQvLyBDaGVjayBpZiBpdHMgbGVzcywgaWYgc28gc2V0IGFzIGNsb3Nlc3Rcblx0XHRpZiAoZGlzdGFuY2UgPCBjdXJyZW50Q2xvc2VzdERpc3RhbmNlKSB7XG5cdFx0XHRjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0XHRjdXJyZW50Q2xvc2VzdEtleXdvcmQgPSBrZXl3b3JkO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG59O1xuXG5jb252ZXJ0JDEua2V5d29yZC5yZ2IgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xuXHRyZXR1cm4gY29sb3JOYW1lW2tleXdvcmRdO1xufTtcblxuY29udmVydCQxLnJnYi54eXogPSBmdW5jdGlvbiAocmdiKSB7XG5cdGxldCByID0gcmdiWzBdIC8gMjU1O1xuXHRsZXQgZyA9IHJnYlsxXSAvIDI1NTtcblx0bGV0IGIgPSByZ2JbMl0gLyAyNTU7XG5cblx0Ly8gQXNzdW1lIHNSR0Jcblx0ciA9IHIgPiAwLjA0MDQ1ID8gKCgociArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQpIDogKHIgLyAxMi45Mik7XG5cdGcgPSBnID4gMC4wNDA0NSA/ICgoKGcgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40KSA6IChnIC8gMTIuOTIpO1xuXHRiID0gYiA+IDAuMDQwNDUgPyAoKChiICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCkgOiAoYiAvIDEyLjkyKTtcblxuXHRjb25zdCB4ID0gKHIgKiAwLjQxMjQpICsgKGcgKiAwLjM1NzYpICsgKGIgKiAwLjE4MDUpO1xuXHRjb25zdCB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuXHRjb25zdCB6ID0gKHIgKiAwLjAxOTMpICsgKGcgKiAwLjExOTIpICsgKGIgKiAwLjk1MDUpO1xuXG5cdHJldHVybiBbeCAqIDEwMCwgeSAqIDEwMCwgeiAqIDEwMF07XG59O1xuXG5jb252ZXJ0JDEucmdiLmxhYiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0Y29uc3QgeHl6ID0gY29udmVydCQxLnJnYi54eXoocmdiKTtcblx0bGV0IHggPSB4eXpbMF07XG5cdGxldCB5ID0geHl6WzFdO1xuXHRsZXQgeiA9IHh5elsyXTtcblxuXHR4IC89IDk1LjA0Nztcblx0eSAvPSAxMDA7XG5cdHogLz0gMTA4Ljg4MztcblxuXHR4ID0geCA+IDAuMDA4ODU2ID8gKHggKiogKDEgLyAzKSkgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG5cdHkgPSB5ID4gMC4wMDg4NTYgPyAoeSAqKiAoMSAvIDMpKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcblx0eiA9IHogPiAwLjAwODg1NiA/ICh6ICoqICgxIC8gMykpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG5cdGNvbnN0IGwgPSAoMTE2ICogeSkgLSAxNjtcblx0Y29uc3QgYSA9IDUwMCAqICh4IC0geSk7XG5cdGNvbnN0IGIgPSAyMDAgKiAoeSAtIHopO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0JDEuaHNsLnJnYiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0Y29uc3QgaCA9IGhzbFswXSAvIDM2MDtcblx0Y29uc3QgcyA9IGhzbFsxXSAvIDEwMDtcblx0Y29uc3QgbCA9IGhzbFsyXSAvIDEwMDtcblx0bGV0IHQyO1xuXHRsZXQgdDM7XG5cdGxldCB2YWw7XG5cblx0aWYgKHMgPT09IDApIHtcblx0XHR2YWwgPSBsICogMjU1O1xuXHRcdHJldHVybiBbdmFsLCB2YWwsIHZhbF07XG5cdH1cblxuXHRpZiAobCA8IDAuNSkge1xuXHRcdHQyID0gbCAqICgxICsgcyk7XG5cdH0gZWxzZSB7XG5cdFx0dDIgPSBsICsgcyAtIGwgKiBzO1xuXHR9XG5cblx0Y29uc3QgdDEgPSAyICogbCAtIHQyO1xuXG5cdGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHR0MyA9IGggKyAxIC8gMyAqIC0oaSAtIDEpO1xuXHRcdGlmICh0MyA8IDApIHtcblx0XHRcdHQzKys7XG5cdFx0fVxuXG5cdFx0aWYgKHQzID4gMSkge1xuXHRcdFx0dDMtLTtcblx0XHR9XG5cblx0XHRpZiAoNiAqIHQzIDwgMSkge1xuXHRcdFx0dmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG5cdFx0fSBlbHNlIGlmICgyICogdDMgPCAxKSB7XG5cdFx0XHR2YWwgPSB0Mjtcblx0XHR9IGVsc2UgaWYgKDMgKiB0MyA8IDIpIHtcblx0XHRcdHZhbCA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsID0gdDE7XG5cdFx0fVxuXG5cdFx0cmdiW2ldID0gdmFsICogMjU1O1xuXHR9XG5cblx0cmV0dXJuIHJnYjtcbn07XG5cbmNvbnZlcnQkMS5oc2wuaHN2ID0gZnVuY3Rpb24gKGhzbCkge1xuXHRjb25zdCBoID0gaHNsWzBdO1xuXHRsZXQgcyA9IGhzbFsxXSAvIDEwMDtcblx0bGV0IGwgPSBoc2xbMl0gLyAxMDA7XG5cdGxldCBzbWluID0gcztcblx0Y29uc3QgbG1pbiA9IE1hdGgubWF4KGwsIDAuMDEpO1xuXG5cdGwgKj0gMjtcblx0cyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcblx0c21pbiAqPSBsbWluIDw9IDEgPyBsbWluIDogMiAtIGxtaW47XG5cdGNvbnN0IHYgPSAobCArIHMpIC8gMjtcblx0Y29uc3Qgc3YgPSBsID09PSAwID8gKDIgKiBzbWluKSAvIChsbWluICsgc21pbikgOiAoMiAqIHMpIC8gKGwgKyBzKTtcblxuXHRyZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn07XG5cbmNvbnZlcnQkMS5oc3YucmdiID0gZnVuY3Rpb24gKGhzdikge1xuXHRjb25zdCBoID0gaHN2WzBdIC8gNjA7XG5cdGNvbnN0IHMgPSBoc3ZbMV0gLyAxMDA7XG5cdGxldCB2ID0gaHN2WzJdIC8gMTAwO1xuXHRjb25zdCBoaSA9IE1hdGguZmxvb3IoaCkgJSA2O1xuXG5cdGNvbnN0IGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcblx0Y29uc3QgcCA9IDI1NSAqIHYgKiAoMSAtIHMpO1xuXHRjb25zdCBxID0gMjU1ICogdiAqICgxIC0gKHMgKiBmKSk7XG5cdGNvbnN0IHQgPSAyNTUgKiB2ICogKDEgLSAocyAqICgxIC0gZikpKTtcblx0diAqPSAyNTU7XG5cblx0c3dpdGNoIChoaSkge1xuXHRcdGNhc2UgMDpcblx0XHRcdHJldHVybiBbdiwgdCwgcF07XG5cdFx0Y2FzZSAxOlxuXHRcdFx0cmV0dXJuIFtxLCB2LCBwXTtcblx0XHRjYXNlIDI6XG5cdFx0XHRyZXR1cm4gW3AsIHYsIHRdO1xuXHRcdGNhc2UgMzpcblx0XHRcdHJldHVybiBbcCwgcSwgdl07XG5cdFx0Y2FzZSA0OlxuXHRcdFx0cmV0dXJuIFt0LCBwLCB2XTtcblx0XHRjYXNlIDU6XG5cdFx0XHRyZXR1cm4gW3YsIHAsIHFdO1xuXHR9XG59O1xuXG5jb252ZXJ0JDEuaHN2LmhzbCA9IGZ1bmN0aW9uIChoc3YpIHtcblx0Y29uc3QgaCA9IGhzdlswXTtcblx0Y29uc3QgcyA9IGhzdlsxXSAvIDEwMDtcblx0Y29uc3QgdiA9IGhzdlsyXSAvIDEwMDtcblx0Y29uc3Qgdm1pbiA9IE1hdGgubWF4KHYsIDAuMDEpO1xuXHRsZXQgc2w7XG5cdGxldCBsO1xuXG5cdGwgPSAoMiAtIHMpICogdjtcblx0Y29uc3QgbG1pbiA9ICgyIC0gcykgKiB2bWluO1xuXHRzbCA9IHMgKiB2bWluO1xuXHRzbCAvPSAobG1pbiA8PSAxKSA/IGxtaW4gOiAyIC0gbG1pbjtcblx0c2wgPSBzbCB8fCAwO1xuXHRsIC89IDI7XG5cblx0cmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG4vLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtY29sb3IvI2h3Yi10by1yZ2JcbmNvbnZlcnQkMS5od2IucmdiID0gZnVuY3Rpb24gKGh3Yikge1xuXHRjb25zdCBoID0gaHdiWzBdIC8gMzYwO1xuXHRsZXQgd2ggPSBod2JbMV0gLyAxMDA7XG5cdGxldCBibCA9IGh3YlsyXSAvIDEwMDtcblx0Y29uc3QgcmF0aW8gPSB3aCArIGJsO1xuXHRsZXQgZjtcblxuXHQvLyBXaCArIGJsIGNhbnQgYmUgPiAxXG5cdGlmIChyYXRpbyA+IDEpIHtcblx0XHR3aCAvPSByYXRpbztcblx0XHRibCAvPSByYXRpbztcblx0fVxuXG5cdGNvbnN0IGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcblx0Y29uc3QgdiA9IDEgLSBibDtcblx0ZiA9IDYgKiBoIC0gaTtcblxuXHRpZiAoKGkgJiAweDAxKSAhPT0gMCkge1xuXHRcdGYgPSAxIC0gZjtcblx0fVxuXG5cdGNvbnN0IG4gPSB3aCArIGYgKiAodiAtIHdoKTsgLy8gTGluZWFyIGludGVycG9sYXRpb25cblxuXHRsZXQgcjtcblx0bGV0IGc7XG5cdGxldCBiO1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cy1wZXItbGluZSxuby1tdWx0aS1zcGFjZXMgKi9cblx0c3dpdGNoIChpKSB7XG5cdFx0ZGVmYXVsdDpcblx0XHRjYXNlIDY6XG5cdFx0Y2FzZSAwOiByID0gdjsgIGcgPSBuOyAgYiA9IHdoOyBicmVhaztcblx0XHRjYXNlIDE6IHIgPSBuOyAgZyA9IHY7ICBiID0gd2g7IGJyZWFrO1xuXHRcdGNhc2UgMjogciA9IHdoOyBnID0gdjsgIGIgPSBuOyBicmVhaztcblx0XHRjYXNlIDM6IHIgPSB3aDsgZyA9IG47ICBiID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSA0OiByID0gbjsgIGcgPSB3aDsgYiA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgNTogciA9IHY7ICBnID0gd2g7IGIgPSBuOyBicmVhaztcblx0fVxuXHQvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzLXBlci1saW5lLG5vLW11bHRpLXNwYWNlcyAqL1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0JDEuY215ay5yZ2IgPSBmdW5jdGlvbiAoY215aykge1xuXHRjb25zdCBjID0gY215a1swXSAvIDEwMDtcblx0Y29uc3QgbSA9IGNteWtbMV0gLyAxMDA7XG5cdGNvbnN0IHkgPSBjbXlrWzJdIC8gMTAwO1xuXHRjb25zdCBrID0gY215a1szXSAvIDEwMDtcblxuXHRjb25zdCByID0gMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgayk7XG5cdGNvbnN0IGcgPSAxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKTtcblx0Y29uc3QgYiA9IDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0JDEueHl6LnJnYiA9IGZ1bmN0aW9uICh4eXopIHtcblx0Y29uc3QgeCA9IHh5elswXSAvIDEwMDtcblx0Y29uc3QgeSA9IHh5elsxXSAvIDEwMDtcblx0Y29uc3QgeiA9IHh5elsyXSAvIDEwMDtcblx0bGV0IHI7XG5cdGxldCBnO1xuXHRsZXQgYjtcblxuXHRyID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG5cdGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuXHRiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuXHQvLyBBc3N1bWUgc1JHQlxuXHRyID0gciA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIChyICoqICgxLjAgLyAyLjQpKSkgLSAwLjA1NSlcblx0XHQ6IHIgKiAxMi45MjtcblxuXHRnID0gZyA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIChnICoqICgxLjAgLyAyLjQpKSkgLSAwLjA1NSlcblx0XHQ6IGcgKiAxMi45MjtcblxuXHRiID0gYiA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIChiICoqICgxLjAgLyAyLjQpKSkgLSAwLjA1NSlcblx0XHQ6IGIgKiAxMi45MjtcblxuXHRyID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuXHRnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuXHRiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0JDEueHl6LmxhYiA9IGZ1bmN0aW9uICh4eXopIHtcblx0bGV0IHggPSB4eXpbMF07XG5cdGxldCB5ID0geHl6WzFdO1xuXHRsZXQgeiA9IHh5elsyXTtcblxuXHR4IC89IDk1LjA0Nztcblx0eSAvPSAxMDA7XG5cdHogLz0gMTA4Ljg4MztcblxuXHR4ID0geCA+IDAuMDA4ODU2ID8gKHggKiogKDEgLyAzKSkgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG5cdHkgPSB5ID4gMC4wMDg4NTYgPyAoeSAqKiAoMSAvIDMpKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcblx0eiA9IHogPiAwLjAwODg1NiA/ICh6ICoqICgxIC8gMykpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG5cdGNvbnN0IGwgPSAoMTE2ICogeSkgLSAxNjtcblx0Y29uc3QgYSA9IDUwMCAqICh4IC0geSk7XG5cdGNvbnN0IGIgPSAyMDAgKiAoeSAtIHopO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0JDEubGFiLnh5eiA9IGZ1bmN0aW9uIChsYWIpIHtcblx0Y29uc3QgbCA9IGxhYlswXTtcblx0Y29uc3QgYSA9IGxhYlsxXTtcblx0Y29uc3QgYiA9IGxhYlsyXTtcblx0bGV0IHg7XG5cdGxldCB5O1xuXHRsZXQgejtcblxuXHR5ID0gKGwgKyAxNikgLyAxMTY7XG5cdHggPSBhIC8gNTAwICsgeTtcblx0eiA9IHkgLSBiIC8gMjAwO1xuXG5cdGNvbnN0IHkyID0geSAqKiAzO1xuXHRjb25zdCB4MiA9IHggKiogMztcblx0Y29uc3QgejIgPSB6ICoqIDM7XG5cdHkgPSB5MiA+IDAuMDA4ODU2ID8geTIgOiAoeSAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXHR4ID0geDIgPiAwLjAwODg1NiA/IHgyIDogKHggLSAxNiAvIDExNikgLyA3Ljc4Nztcblx0eiA9IHoyID4gMC4wMDg4NTYgPyB6MiA6ICh6IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cblx0eCAqPSA5NS4wNDc7XG5cdHkgKj0gMTAwO1xuXHR6ICo9IDEwOC44ODM7XG5cblx0cmV0dXJuIFt4LCB5LCB6XTtcbn07XG5cbmNvbnZlcnQkMS5sYWIubGNoID0gZnVuY3Rpb24gKGxhYikge1xuXHRjb25zdCBsID0gbGFiWzBdO1xuXHRjb25zdCBhID0gbGFiWzFdO1xuXHRjb25zdCBiID0gbGFiWzJdO1xuXHRsZXQgaDtcblxuXHRjb25zdCBociA9IE1hdGguYXRhbjIoYiwgYSk7XG5cdGggPSBociAqIDM2MCAvIDIgLyBNYXRoLlBJO1xuXG5cdGlmIChoIDwgMCkge1xuXHRcdGggKz0gMzYwO1xuXHR9XG5cblx0Y29uc3QgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblxuXHRyZXR1cm4gW2wsIGMsIGhdO1xufTtcblxuY29udmVydCQxLmxjaC5sYWIgPSBmdW5jdGlvbiAobGNoKSB7XG5cdGNvbnN0IGwgPSBsY2hbMF07XG5cdGNvbnN0IGMgPSBsY2hbMV07XG5cdGNvbnN0IGggPSBsY2hbMl07XG5cblx0Y29uc3QgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG5cdGNvbnN0IGEgPSBjICogTWF0aC5jb3MoaHIpO1xuXHRjb25zdCBiID0gYyAqIE1hdGguc2luKGhyKTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydCQxLnJnYi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncywgc2F0dXJhdGlvbiA9IG51bGwpIHtcblx0Y29uc3QgW3IsIGcsIGJdID0gYXJncztcblx0bGV0IHZhbHVlID0gc2F0dXJhdGlvbiA9PT0gbnVsbCA/IGNvbnZlcnQkMS5yZ2IuaHN2KGFyZ3MpWzJdIDogc2F0dXJhdGlvbjsgLy8gSHN2IC0+IGFuc2kxNiBvcHRpbWl6YXRpb25cblxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyA1MCk7XG5cblx0aWYgKHZhbHVlID09PSAwKSB7XG5cdFx0cmV0dXJuIDMwO1xuXHR9XG5cblx0bGV0IGFuc2kgPSAzMFxuXHRcdCsgKChNYXRoLnJvdW5kKGIgLyAyNTUpIDw8IDIpXG5cdFx0fCAoTWF0aC5yb3VuZChnIC8gMjU1KSA8PCAxKVxuXHRcdHwgTWF0aC5yb3VuZChyIC8gMjU1KSk7XG5cblx0aWYgKHZhbHVlID09PSAyKSB7XG5cdFx0YW5zaSArPSA2MDtcblx0fVxuXG5cdHJldHVybiBhbnNpO1xufTtcblxuY29udmVydCQxLmhzdi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHQvLyBPcHRpbWl6YXRpb24gaGVyZTsgd2UgYWxyZWFkeSBrbm93IHRoZSB2YWx1ZSBhbmQgZG9uJ3QgbmVlZCB0byBnZXRcblx0Ly8gaXQgY29udmVydGVkIGZvciB1cy5cblx0cmV0dXJuIGNvbnZlcnQkMS5yZ2IuYW5zaTE2KGNvbnZlcnQkMS5oc3YucmdiKGFyZ3MpLCBhcmdzWzJdKTtcbn07XG5cbmNvbnZlcnQkMS5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdGNvbnN0IHIgPSBhcmdzWzBdO1xuXHRjb25zdCBnID0gYXJnc1sxXTtcblx0Y29uc3QgYiA9IGFyZ3NbMl07XG5cblx0Ly8gV2UgdXNlIHRoZSBleHRlbmRlZCBncmV5c2NhbGUgcGFsZXR0ZSBoZXJlLCB3aXRoIHRoZSBleGNlcHRpb24gb2Zcblx0Ly8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuXG5cdGlmIChyID09PSBnICYmIGcgPT09IGIpIHtcblx0XHRpZiAociA8IDgpIHtcblx0XHRcdHJldHVybiAxNjtcblx0XHR9XG5cblx0XHRpZiAociA+IDI0OCkge1xuXHRcdFx0cmV0dXJuIDIzMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5yb3VuZCgoKHIgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7XG5cdH1cblxuXHRjb25zdCBhbnNpID0gMTZcblx0XHQrICgzNiAqIE1hdGgucm91bmQociAvIDI1NSAqIDUpKVxuXHRcdCsgKDYgKiBNYXRoLnJvdW5kKGcgLyAyNTUgKiA1KSlcblx0XHQrIE1hdGgucm91bmQoYiAvIDI1NSAqIDUpO1xuXG5cdHJldHVybiBhbnNpO1xufTtcblxuY29udmVydCQxLmFuc2kxNi5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHRsZXQgY29sb3IgPSBhcmdzICUgMTA7XG5cblx0Ly8gSGFuZGxlIGdyZXlzY2FsZVxuXHRpZiAoY29sb3IgPT09IDAgfHwgY29sb3IgPT09IDcpIHtcblx0XHRpZiAoYXJncyA+IDUwKSB7XG5cdFx0XHRjb2xvciArPSAzLjU7XG5cdFx0fVxuXG5cdFx0Y29sb3IgPSBjb2xvciAvIDEwLjUgKiAyNTU7XG5cblx0XHRyZXR1cm4gW2NvbG9yLCBjb2xvciwgY29sb3JdO1xuXHR9XG5cblx0Y29uc3QgbXVsdCA9ICh+fihhcmdzID4gNTApICsgMSkgKiAwLjU7XG5cdGNvbnN0IHIgPSAoKGNvbG9yICYgMSkgKiBtdWx0KSAqIDI1NTtcblx0Y29uc3QgZyA9ICgoKGNvbG9yID4+IDEpICYgMSkgKiBtdWx0KSAqIDI1NTtcblx0Y29uc3QgYiA9ICgoKGNvbG9yID4+IDIpICYgMSkgKiBtdWx0KSAqIDI1NTtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydCQxLmFuc2kyNTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Ly8gSGFuZGxlIGdyZXlzY2FsZVxuXHRpZiAoYXJncyA+PSAyMzIpIHtcblx0XHRjb25zdCBjID0gKGFyZ3MgLSAyMzIpICogMTAgKyA4O1xuXHRcdHJldHVybiBbYywgYywgY107XG5cdH1cblxuXHRhcmdzIC09IDE2O1xuXG5cdGxldCByZW07XG5cdGNvbnN0IHIgPSBNYXRoLmZsb29yKGFyZ3MgLyAzNikgLyA1ICogMjU1O1xuXHRjb25zdCBnID0gTWF0aC5mbG9vcigocmVtID0gYXJncyAlIDM2KSAvIDYpIC8gNSAqIDI1NTtcblx0Y29uc3QgYiA9IChyZW0gJSA2KSAvIDUgKiAyNTU7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQkMS5yZ2IuaGV4ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Y29uc3QgaW50ZWdlciA9ICgoTWF0aC5yb3VuZChhcmdzWzBdKSAmIDB4RkYpIDw8IDE2KVxuXHRcdCsgKChNYXRoLnJvdW5kKGFyZ3NbMV0pICYgMHhGRikgPDwgOClcblx0XHQrIChNYXRoLnJvdW5kKGFyZ3NbMl0pICYgMHhGRik7XG5cblx0Y29uc3Qgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0cmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn07XG5cbmNvbnZlcnQkMS5oZXgucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Y29uc3QgbWF0Y2ggPSBhcmdzLnRvU3RyaW5nKDE2KS5tYXRjaCgvW2EtZjAtOV17Nn18W2EtZjAtOV17M30vaSk7XG5cdGlmICghbWF0Y2gpIHtcblx0XHRyZXR1cm4gWzAsIDAsIDBdO1xuXHR9XG5cblx0bGV0IGNvbG9yU3RyaW5nID0gbWF0Y2hbMF07XG5cblx0aWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMykge1xuXHRcdGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoJycpLm1hcChjaGFyID0+IHtcblx0XHRcdHJldHVybiBjaGFyICsgY2hhcjtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdGNvbnN0IGludGVnZXIgPSBwYXJzZUludChjb2xvclN0cmluZywgMTYpO1xuXHRjb25zdCByID0gKGludGVnZXIgPj4gMTYpICYgMHhGRjtcblx0Y29uc3QgZyA9IChpbnRlZ2VyID4+IDgpICYgMHhGRjtcblx0Y29uc3QgYiA9IGludGVnZXIgJiAweEZGO1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0JDEucmdiLmhjZyA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0Y29uc3QgciA9IHJnYlswXSAvIDI1NTtcblx0Y29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcblx0Y29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcblx0Y29uc3QgbWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgociwgZyksIGIpO1xuXHRjb25zdCBtaW4gPSBNYXRoLm1pbihNYXRoLm1pbihyLCBnKSwgYik7XG5cdGNvbnN0IGNocm9tYSA9IChtYXggLSBtaW4pO1xuXHRsZXQgZ3JheXNjYWxlO1xuXHRsZXQgaHVlO1xuXG5cdGlmIChjaHJvbWEgPCAxKSB7XG5cdFx0Z3JheXNjYWxlID0gbWluIC8gKDEgLSBjaHJvbWEpO1xuXHR9IGVsc2Uge1xuXHRcdGdyYXlzY2FsZSA9IDA7XG5cdH1cblxuXHRpZiAoY2hyb21hIDw9IDApIHtcblx0XHRodWUgPSAwO1xuXHR9IGVsc2Vcblx0aWYgKG1heCA9PT0gcikge1xuXHRcdGh1ZSA9ICgoZyAtIGIpIC8gY2hyb21hKSAlIDY7XG5cdH0gZWxzZVxuXHRpZiAobWF4ID09PSBnKSB7XG5cdFx0aHVlID0gMiArIChiIC0gcikgLyBjaHJvbWE7XG5cdH0gZWxzZSB7XG5cdFx0aHVlID0gNCArIChyIC0gZykgLyBjaHJvbWE7XG5cdH1cblxuXHRodWUgLz0gNjtcblx0aHVlICU9IDE7XG5cblx0cmV0dXJuIFtodWUgKiAzNjAsIGNocm9tYSAqIDEwMCwgZ3JheXNjYWxlICogMTAwXTtcbn07XG5cbmNvbnZlcnQkMS5oc2wuaGNnID0gZnVuY3Rpb24gKGhzbCkge1xuXHRjb25zdCBzID0gaHNsWzFdIC8gMTAwO1xuXHRjb25zdCBsID0gaHNsWzJdIC8gMTAwO1xuXG5cdGNvbnN0IGMgPSBsIDwgMC41ID8gKDIuMCAqIHMgKiBsKSA6ICgyLjAgKiBzICogKDEuMCAtIGwpKTtcblxuXHRsZXQgZiA9IDA7XG5cdGlmIChjIDwgMS4wKSB7XG5cdFx0ZiA9IChsIC0gMC41ICogYykgLyAoMS4wIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2hzbFswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG59O1xuXG5jb252ZXJ0JDEuaHN2LmhjZyA9IGZ1bmN0aW9uIChoc3YpIHtcblx0Y29uc3QgcyA9IGhzdlsxXSAvIDEwMDtcblx0Y29uc3QgdiA9IGhzdlsyXSAvIDEwMDtcblxuXHRjb25zdCBjID0gcyAqIHY7XG5cdGxldCBmID0gMDtcblxuXHRpZiAoYyA8IDEuMCkge1xuXHRcdGYgPSAodiAtIGMpIC8gKDEgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHN2WzBdLCBjICogMTAwLCBmICogMTAwXTtcbn07XG5cbmNvbnZlcnQkMS5oY2cucmdiID0gZnVuY3Rpb24gKGhjZykge1xuXHRjb25zdCBoID0gaGNnWzBdIC8gMzYwO1xuXHRjb25zdCBjID0gaGNnWzFdIC8gMTAwO1xuXHRjb25zdCBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdGlmIChjID09PSAwLjApIHtcblx0XHRyZXR1cm4gW2cgKiAyNTUsIGcgKiAyNTUsIGcgKiAyNTVdO1xuXHR9XG5cblx0Y29uc3QgcHVyZSA9IFswLCAwLCAwXTtcblx0Y29uc3QgaGkgPSAoaCAlIDEpICogNjtcblx0Y29uc3QgdiA9IGhpICUgMTtcblx0Y29uc3QgdyA9IDEgLSB2O1xuXHRsZXQgbWcgPSAwO1xuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLXBlci1saW5lICovXG5cdHN3aXRjaCAoTWF0aC5mbG9vcihoaSkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRwdXJlWzBdID0gMTsgcHVyZVsxXSA9IHY7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDE6XG5cdFx0XHRwdXJlWzBdID0gdzsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSB2OyBicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IHc7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRjYXNlIDQ6XG5cdFx0XHRwdXJlWzBdID0gdjsgcHVyZVsxXSA9IDA7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cHVyZVswXSA9IDE7IHB1cmVbMV0gPSAwOyBwdXJlWzJdID0gdztcblx0fVxuXHQvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzLXBlci1saW5lICovXG5cblx0bWcgPSAoMS4wIC0gYykgKiBnO1xuXG5cdHJldHVybiBbXG5cdFx0KGMgKiBwdXJlWzBdICsgbWcpICogMjU1LFxuXHRcdChjICogcHVyZVsxXSArIG1nKSAqIDI1NSxcblx0XHQoYyAqIHB1cmVbMl0gKyBtZykgKiAyNTVcblx0XTtcbn07XG5cbmNvbnZlcnQkMS5oY2cuaHN2ID0gZnVuY3Rpb24gKGhjZykge1xuXHRjb25zdCBjID0gaGNnWzFdIC8gMTAwO1xuXHRjb25zdCBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdGNvbnN0IHYgPSBjICsgZyAqICgxLjAgLSBjKTtcblx0bGV0IGYgPSAwO1xuXG5cdGlmICh2ID4gMC4wKSB7XG5cdFx0ZiA9IGMgLyB2O1xuXHR9XG5cblx0cmV0dXJuIFtoY2dbMF0sIGYgKiAxMDAsIHYgKiAxMDBdO1xufTtcblxuY29udmVydCQxLmhjZy5oc2wgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG5cdGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0Y29uc3QgbCA9IGcgKiAoMS4wIC0gYykgKyAwLjUgKiBjO1xuXHRsZXQgcyA9IDA7XG5cblx0aWYgKGwgPiAwLjAgJiYgbCA8IDAuNSkge1xuXHRcdHMgPSBjIC8gKDIgKiBsKTtcblx0fSBlbHNlXG5cdGlmIChsID49IDAuNSAmJiBsIDwgMS4wKSB7XG5cdFx0cyA9IGMgLyAoMiAqICgxIC0gbCkpO1xuXHR9XG5cblx0cmV0dXJuIFtoY2dbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydCQxLmhjZy5od2IgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG5cdGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG5cdGNvbnN0IHYgPSBjICsgZyAqICgxLjAgLSBjKTtcblx0cmV0dXJuIFtoY2dbMF0sICh2IC0gYykgKiAxMDAsICgxIC0gdikgKiAxMDBdO1xufTtcblxuY29udmVydCQxLmh3Yi5oY2cgPSBmdW5jdGlvbiAoaHdiKSB7XG5cdGNvbnN0IHcgPSBod2JbMV0gLyAxMDA7XG5cdGNvbnN0IGIgPSBod2JbMl0gLyAxMDA7XG5cdGNvbnN0IHYgPSAxIC0gYjtcblx0Y29uc3QgYyA9IHYgLSB3O1xuXHRsZXQgZyA9IDA7XG5cblx0aWYgKGMgPCAxKSB7XG5cdFx0ZyA9ICh2IC0gYykgLyAoMSAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtod2JbMF0sIGMgKiAxMDAsIGcgKiAxMDBdO1xufTtcblxuY29udmVydCQxLmFwcGxlLnJnYiA9IGZ1bmN0aW9uIChhcHBsZSkge1xuXHRyZXR1cm4gWyhhcHBsZVswXSAvIDY1NTM1KSAqIDI1NSwgKGFwcGxlWzFdIC8gNjU1MzUpICogMjU1LCAoYXBwbGVbMl0gLyA2NTUzNSkgKiAyNTVdO1xufTtcblxuY29udmVydCQxLnJnYi5hcHBsZSA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0cmV0dXJuIFsocmdiWzBdIC8gMjU1KSAqIDY1NTM1LCAocmdiWzFdIC8gMjU1KSAqIDY1NTM1LCAocmdiWzJdIC8gMjU1KSAqIDY1NTM1XTtcbn07XG5cbmNvbnZlcnQkMS5ncmF5LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHJldHVybiBbYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NV07XG59O1xuXG5jb252ZXJ0JDEuZ3JheS5oc2wgPSBmdW5jdGlvbiAoYXJncykge1xuXHRyZXR1cm4gWzAsIDAsIGFyZ3NbMF1dO1xufTtcblxuY29udmVydCQxLmdyYXkuaHN2ID0gY29udmVydCQxLmdyYXkuaHNsO1xuXG5jb252ZXJ0JDEuZ3JheS5od2IgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gWzAsIDEwMCwgZ3JheVswXV07XG59O1xuXG5jb252ZXJ0JDEuZ3JheS5jbXlrID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFswLCAwLCAwLCBncmF5WzBdXTtcbn07XG5cbmNvbnZlcnQkMS5ncmF5LmxhYiA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbZ3JheVswXSwgMCwgMF07XG59O1xuXG5jb252ZXJ0JDEuZ3JheS5oZXggPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRjb25zdCB2YWwgPSBNYXRoLnJvdW5kKGdyYXlbMF0gLyAxMDAgKiAyNTUpICYgMHhGRjtcblx0Y29uc3QgaW50ZWdlciA9ICh2YWwgPDwgMTYpICsgKHZhbCA8PCA4KSArIHZhbDtcblxuXHRjb25zdCBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcblxuY29udmVydCQxLnJnYi5ncmF5ID0gZnVuY3Rpb24gKHJnYikge1xuXHRjb25zdCB2YWwgPSAocmdiWzBdICsgcmdiWzFdICsgcmdiWzJdKSAvIDM7XG5cdHJldHVybiBbdmFsIC8gMjU1ICogMTAwXTtcbn07XG5cbi8qXG5cdFRoaXMgZnVuY3Rpb24gcm91dGVzIGEgbW9kZWwgdG8gYWxsIG90aGVyIG1vZGVscy5cblxuXHRhbGwgZnVuY3Rpb25zIHRoYXQgYXJlIHJvdXRlZCBoYXZlIGEgcHJvcGVydHkgYC5jb252ZXJzaW9uYCBhdHRhY2hlZFxuXHR0byB0aGUgcmV0dXJuZWQgc3ludGhldGljIGZ1bmN0aW9uLiBUaGlzIHByb3BlcnR5IGlzIGFuIGFycmF5XG5cdG9mIHN0cmluZ3MsIGVhY2ggd2l0aCB0aGUgc3RlcHMgaW4gYmV0d2VlbiB0aGUgJ2Zyb20nIGFuZCAndG8nXG5cdGNvbG9yIG1vZGVscyAoaW5jbHVzaXZlKS5cblxuXHRjb252ZXJzaW9ucyB0aGF0IGFyZSBub3QgcG9zc2libGUgc2ltcGx5IGFyZSBub3QgaW5jbHVkZWQuXG4qL1xuXG5mdW5jdGlvbiBidWlsZEdyYXBoKCkge1xuXHRjb25zdCBncmFwaCA9IHt9O1xuXHQvLyBodHRwczovL2pzcGVyZi5jb20vb2JqZWN0LWtleXMtdnMtZm9yLWluLXdpdGgtY2xvc3VyZS8zXG5cdGNvbnN0IG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuXHRmb3IgKGxldCBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0Z3JhcGhbbW9kZWxzW2ldXSA9IHtcblx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tLzEtdnMtaW5maW5pdHlcblx0XHRcdC8vIG1pY3JvLW9wdCwgYnV0IHRoaXMgaXMgc2ltcGxlLlxuXHRcdFx0ZGlzdGFuY2U6IC0xLFxuXHRcdFx0cGFyZW50OiBudWxsXG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBncmFwaDtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlYWR0aC1maXJzdF9zZWFyY2hcbmZ1bmN0aW9uIGRlcml2ZUJGUyhmcm9tTW9kZWwpIHtcblx0Y29uc3QgZ3JhcGggPSBidWlsZEdyYXBoKCk7XG5cdGNvbnN0IHF1ZXVlID0gW2Zyb21Nb2RlbF07IC8vIFVuc2hpZnQgLT4gcXVldWUgLT4gcG9wXG5cblx0Z3JhcGhbZnJvbU1vZGVsXS5kaXN0YW5jZSA9IDA7XG5cblx0d2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdGNvbnN0IGN1cnJlbnQgPSBxdWV1ZS5wb3AoKTtcblx0XHRjb25zdCBhZGphY2VudHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9uc1tjdXJyZW50XSk7XG5cblx0XHRmb3IgKGxldCBsZW4gPSBhZGphY2VudHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjb25zdCBhZGphY2VudCA9IGFkamFjZW50c1tpXTtcblx0XHRcdGNvbnN0IG5vZGUgPSBncmFwaFthZGphY2VudF07XG5cblx0XHRcdGlmIChub2RlLmRpc3RhbmNlID09PSAtMSkge1xuXHRcdFx0XHRub2RlLmRpc3RhbmNlID0gZ3JhcGhbY3VycmVudF0uZGlzdGFuY2UgKyAxO1xuXHRcdFx0XHRub2RlLnBhcmVudCA9IGN1cnJlbnQ7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoYWRqYWNlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBncmFwaDtcbn1cblxuZnVuY3Rpb24gbGluayhmcm9tLCB0bykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRyZXR1cm4gdG8oZnJvbShhcmdzKSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKSB7XG5cdGNvbnN0IHBhdGggPSBbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50LCB0b01vZGVsXTtcblx0bGV0IGZuID0gY29udmVyc2lvbnNbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcblxuXHRsZXQgY3VyID0gZ3JhcGhbdG9Nb2RlbF0ucGFyZW50O1xuXHR3aGlsZSAoZ3JhcGhbY3VyXS5wYXJlbnQpIHtcblx0XHRwYXRoLnVuc2hpZnQoZ3JhcGhbY3VyXS5wYXJlbnQpO1xuXHRcdGZuID0gbGluayhjb252ZXJzaW9uc1tncmFwaFtjdXJdLnBhcmVudF1bY3VyXSwgZm4pO1xuXHRcdGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuXHR9XG5cblx0Zm4uY29udmVyc2lvbiA9IHBhdGg7XG5cdHJldHVybiBmbjtcbn1cblxudmFyIHJvdXRlID0gZnVuY3Rpb24gKGZyb21Nb2RlbCkge1xuXHRjb25zdCBncmFwaCA9IGRlcml2ZUJGUyhmcm9tTW9kZWwpO1xuXHRjb25zdCBjb252ZXJzaW9uID0ge307XG5cblx0Y29uc3QgbW9kZWxzID0gT2JqZWN0LmtleXMoZ3JhcGgpO1xuXHRmb3IgKGxldCBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0Y29uc3QgdG9Nb2RlbCA9IG1vZGVsc1tpXTtcblx0XHRjb25zdCBub2RlID0gZ3JhcGhbdG9Nb2RlbF07XG5cblx0XHRpZiAobm9kZS5wYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdC8vIE5vIHBvc3NpYmxlIGNvbnZlcnNpb24sIG9yIHRoaXMgbm9kZSBpcyB0aGUgc291cmNlIG1vZGVsLlxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udmVyc2lvblt0b01vZGVsXSA9IHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKTtcblx0fVxuXG5cdHJldHVybiBjb252ZXJzaW9uO1xufTtcblxuY29uc3QgY29udmVydCA9IHt9O1xuXG5jb25zdCBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cbmZ1bmN0aW9uIHdyYXBSYXcoZm4pIHtcblx0Y29uc3Qgd3JhcHBlZEZuID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRjb25zdCBhcmcwID0gYXJnc1swXTtcblx0XHRpZiAoYXJnMCA9PT0gdW5kZWZpbmVkIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmcwO1xuXHRcdH1cblxuXHRcdGlmIChhcmcwLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBhcmcwO1xuXHRcdH1cblxuXHRcdHJldHVybiBmbihhcmdzKTtcblx0fTtcblxuXHQvLyBQcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbmZ1bmN0aW9uIHdyYXBSb3VuZGVkKGZuKSB7XG5cdGNvbnN0IHdyYXBwZWRGbiA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0Y29uc3QgYXJnMCA9IGFyZ3NbMF07XG5cblx0XHRpZiAoYXJnMCA9PT0gdW5kZWZpbmVkIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmcwO1xuXHRcdH1cblxuXHRcdGlmIChhcmcwLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBhcmcwO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJlc3VsdCA9IGZuKGFyZ3MpO1xuXG5cdFx0Ly8gV2UncmUgYXNzdW1pbmcgdGhlIHJlc3VsdCBpcyBhbiBhcnJheSBoZXJlLlxuXHRcdC8vIHNlZSBub3RpY2UgaW4gY29udmVyc2lvbnMuanM7IGRvbid0IHVzZSBib3ggdHlwZXNcblx0XHQvLyBpbiBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cblx0XHRpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAobGV0IGxlbiA9IHJlc3VsdC5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gUHJlc2VydmUgLmNvbnZlcnNpb24gcHJvcGVydHkgaWYgdGhlcmUgaXMgb25lXG5cdGlmICgnY29udmVyc2lvbicgaW4gZm4pIHtcblx0XHR3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG5cdH1cblxuXHRyZXR1cm4gd3JhcHBlZEZuO1xufVxuXG5tb2RlbHMuZm9yRWFjaChmcm9tTW9kZWwgPT4ge1xuXHRjb252ZXJ0W2Zyb21Nb2RlbF0gPSB7fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0uY2hhbm5lbHN9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2xhYmVscycsIHt2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5sYWJlbHN9KTtcblxuXHRjb25zdCByb3V0ZXMgPSByb3V0ZShmcm9tTW9kZWwpO1xuXHRjb25zdCByb3V0ZU1vZGVscyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG5cblx0cm91dGVNb2RlbHMuZm9yRWFjaCh0b01vZGVsID0+IHtcblx0XHRjb25zdCBmbiA9IHJvdXRlc1t0b01vZGVsXTtcblxuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXSA9IHdyYXBSb3VuZGVkKGZuKTtcblx0XHRjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0ucmF3ID0gd3JhcFJhdyhmbik7XG5cdH0pO1xufSk7XG5cbnZhciBjb2xvckNvbnZlcnQgPSBjb252ZXJ0O1xuXG5jb25zdCBza2lwcGVkTW9kZWxzID0gW1xuXHQvLyBUbyBiZSBob25lc3QsIEkgZG9uJ3QgcmVhbGx5IGZlZWwgbGlrZSBrZXl3b3JkIGJlbG9uZ3MgaW4gY29sb3IgY29udmVydCwgYnV0IGVoLlxuXHQna2V5d29yZCcsXG5cblx0Ly8gR3JheSBjb25mbGljdHMgd2l0aCBzb21lIG1ldGhvZCBuYW1lcywgYW5kIGhhcyBpdHMgb3duIG1ldGhvZCBkZWZpbmVkLlxuXHQnZ3JheScsXG5cblx0Ly8gU2hvdWxkbid0IHJlYWxseSBiZSBpbiBjb2xvci1jb252ZXJ0IGVpdGhlci4uLlxuXHQnaGV4Jyxcbl07XG5cbmNvbnN0IGhhc2hlZE1vZGVsS2V5cyA9IHt9O1xuZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3Qua2V5cyhjb2xvckNvbnZlcnQpKSB7XG5cdGhhc2hlZE1vZGVsS2V5c1tbLi4uY29sb3JDb252ZXJ0W21vZGVsXS5sYWJlbHNdLnNvcnQoKS5qb2luKCcnKV0gPSBtb2RlbDtcbn1cblxuY29uc3QgbGltaXRlcnMgPSB7fTtcblxuZnVuY3Rpb24gQ29sb3Iob2JqZWN0LCBtb2RlbCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihvYmplY3QsIG1vZGVsKTtcblx0fVxuXG5cdGlmIChtb2RlbCAmJiBtb2RlbCBpbiBza2lwcGVkTW9kZWxzKSB7XG5cdFx0bW9kZWwgPSBudWxsO1xuXHR9XG5cblx0aWYgKG1vZGVsICYmICEobW9kZWwgaW4gY29sb3JDb252ZXJ0KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlbDogJyArIG1vZGVsKTtcblx0fVxuXG5cdGxldCBpO1xuXHRsZXQgY2hhbm5lbHM7XG5cblx0aWYgKG9iamVjdCA9PSBudWxsKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcblx0XHR0aGlzLm1vZGVsID0gJ3JnYic7XG5cdFx0dGhpcy5jb2xvciA9IFswLCAwLCAwXTtcblx0XHR0aGlzLnZhbHBoYSA9IDE7XG5cdH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgQ29sb3IpIHtcblx0XHR0aGlzLm1vZGVsID0gb2JqZWN0Lm1vZGVsO1xuXHRcdHRoaXMuY29sb3IgPSBbLi4ub2JqZWN0LmNvbG9yXTtcblx0XHR0aGlzLnZhbHBoYSA9IG9iamVjdC52YWxwaGE7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcblx0XHRjb25zdCByZXN1bHQgPSBjb2xvclN0cmluZy5nZXQob2JqZWN0KTtcblx0XHRpZiAocmVzdWx0ID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBjb2xvciBmcm9tIHN0cmluZzogJyArIG9iamVjdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb2RlbCA9IHJlc3VsdC5tb2RlbDtcblx0XHRjaGFubmVscyA9IGNvbG9yQ29udmVydFt0aGlzLm1vZGVsXS5jaGFubmVscztcblx0XHR0aGlzLmNvbG9yID0gcmVzdWx0LnZhbHVlLnNsaWNlKDAsIGNoYW5uZWxzKTtcblx0XHR0aGlzLnZhbHBoYSA9IHR5cGVvZiByZXN1bHQudmFsdWVbY2hhbm5lbHNdID09PSAnbnVtYmVyJyA/IHJlc3VsdC52YWx1ZVtjaGFubmVsc10gOiAxO1xuXHR9IGVsc2UgaWYgKG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0dGhpcy5tb2RlbCA9IG1vZGVsIHx8ICdyZ2InO1xuXHRcdGNoYW5uZWxzID0gY29sb3JDb252ZXJ0W3RoaXMubW9kZWxdLmNoYW5uZWxzO1xuXHRcdGNvbnN0IG5ld0FycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqZWN0LCAwLCBjaGFubmVscyk7XG5cdFx0dGhpcy5jb2xvciA9IHplcm9BcnJheShuZXdBcnJheSwgY2hhbm5lbHMpO1xuXHRcdHRoaXMudmFscGhhID0gdHlwZW9mIG9iamVjdFtjaGFubmVsc10gPT09ICdudW1iZXInID8gb2JqZWN0W2NoYW5uZWxzXSA6IDE7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ251bWJlcicpIHtcblx0XHQvLyBUaGlzIGlzIGFsd2F5cyBSR0IgLSBjYW4gYmUgY29udmVydGVkIGxhdGVyIG9uLlxuXHRcdHRoaXMubW9kZWwgPSAncmdiJztcblx0XHR0aGlzLmNvbG9yID0gW1xuXHRcdFx0KG9iamVjdCA+PiAxNikgJiAweEZGLFxuXHRcdFx0KG9iamVjdCA+PiA4KSAmIDB4RkYsXG5cdFx0XHRvYmplY3QgJiAweEZGLFxuXHRcdF07XG5cdFx0dGhpcy52YWxwaGEgPSAxO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMudmFscGhhID0gMTtcblxuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXHRcdGlmICgnYWxwaGEnIGluIG9iamVjdCkge1xuXHRcdFx0a2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKCdhbHBoYScpLCAxKTtcblx0XHRcdHRoaXMudmFscGhhID0gdHlwZW9mIG9iamVjdC5hbHBoYSA9PT0gJ251bWJlcicgPyBvYmplY3QuYWxwaGEgOiAwO1xuXHRcdH1cblxuXHRcdGNvbnN0IGhhc2hlZEtleXMgPSBrZXlzLnNvcnQoKS5qb2luKCcnKTtcblx0XHRpZiAoIShoYXNoZWRLZXlzIGluIGhhc2hlZE1vZGVsS2V5cykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIGNvbG9yIGZyb20gb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkob2JqZWN0KSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb2RlbCA9IGhhc2hlZE1vZGVsS2V5c1toYXNoZWRLZXlzXTtcblxuXHRcdGNvbnN0IHtsYWJlbHN9ID0gY29sb3JDb252ZXJ0W3RoaXMubW9kZWxdO1xuXHRcdGNvbnN0IGNvbG9yID0gW107XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29sb3IucHVzaChvYmplY3RbbGFiZWxzW2ldXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb2xvciA9IHplcm9BcnJheShjb2xvcik7XG5cdH1cblxuXHQvLyBQZXJmb3JtIGxpbWl0YXRpb25zIChjbGFtcGluZywgZXRjLilcblx0aWYgKGxpbWl0ZXJzW3RoaXMubW9kZWxdKSB7XG5cdFx0Y2hhbm5lbHMgPSBjb2xvckNvbnZlcnRbdGhpcy5tb2RlbF0uY2hhbm5lbHM7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGNoYW5uZWxzOyBpKyspIHtcblx0XHRcdGNvbnN0IGxpbWl0ID0gbGltaXRlcnNbdGhpcy5tb2RlbF1baV07XG5cdFx0XHRpZiAobGltaXQpIHtcblx0XHRcdFx0dGhpcy5jb2xvcltpXSA9IGxpbWl0KHRoaXMuY29sb3JbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRoaXMudmFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy52YWxwaGEpKTtcblxuXHRpZiAoT2JqZWN0LmZyZWV6ZSkge1xuXHRcdE9iamVjdC5mcmVlemUodGhpcyk7XG5cdH1cbn1cblxuQ29sb3IucHJvdG90eXBlID0ge1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5zdHJpbmcoKTtcblx0fSxcblxuXHR0b0pTT04oKSB7XG5cdFx0cmV0dXJuIHRoaXNbdGhpcy5tb2RlbF0oKTtcblx0fSxcblxuXHRzdHJpbmcocGxhY2VzKSB7XG5cdFx0bGV0IHNlbGYgPSB0aGlzLm1vZGVsIGluIGNvbG9yU3RyaW5nLnRvID8gdGhpcyA6IHRoaXMucmdiKCk7XG5cdFx0c2VsZiA9IHNlbGYucm91bmQodHlwZW9mIHBsYWNlcyA9PT0gJ251bWJlcicgPyBwbGFjZXMgOiAxKTtcblx0XHRjb25zdCBhcmdzID0gc2VsZi52YWxwaGEgPT09IDEgPyBzZWxmLmNvbG9yIDogWy4uLnNlbGYuY29sb3IsIHRoaXMudmFscGhhXTtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcudG9bc2VsZi5tb2RlbF0oYXJncyk7XG5cdH0sXG5cblx0cGVyY2VudFN0cmluZyhwbGFjZXMpIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcy5yZ2IoKS5yb3VuZCh0eXBlb2YgcGxhY2VzID09PSAnbnVtYmVyJyA/IHBsYWNlcyA6IDEpO1xuXHRcdGNvbnN0IGFyZ3MgPSBzZWxmLnZhbHBoYSA9PT0gMSA/IHNlbGYuY29sb3IgOiBbLi4uc2VsZi5jb2xvciwgdGhpcy52YWxwaGFdO1xuXHRcdHJldHVybiBjb2xvclN0cmluZy50by5yZ2IucGVyY2VudChhcmdzKTtcblx0fSxcblxuXHRhcnJheSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWxwaGEgPT09IDEgPyBbLi4udGhpcy5jb2xvcl0gOiBbLi4udGhpcy5jb2xvciwgdGhpcy52YWxwaGFdO1xuXHR9LFxuXG5cdG9iamVjdCgpIHtcblx0XHRjb25zdCByZXN1bHQgPSB7fTtcblx0XHRjb25zdCB7Y2hhbm5lbHN9ID0gY29sb3JDb252ZXJ0W3RoaXMubW9kZWxdO1xuXHRcdGNvbnN0IHtsYWJlbHN9ID0gY29sb3JDb252ZXJ0W3RoaXMubW9kZWxdO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGFubmVsczsgaSsrKSB7XG5cdFx0XHRyZXN1bHRbbGFiZWxzW2ldXSA9IHRoaXMuY29sb3JbaV07XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMudmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZXN1bHQuYWxwaGEgPSB0aGlzLnZhbHBoYTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdHVuaXRBcnJheSgpIHtcblx0XHRjb25zdCByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHJnYlswXSAvPSAyNTU7XG5cdFx0cmdiWzFdIC89IDI1NTtcblx0XHRyZ2JbMl0gLz0gMjU1O1xuXG5cdFx0aWYgKHRoaXMudmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZ2IucHVzaCh0aGlzLnZhbHBoYSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJnYjtcblx0fSxcblxuXHR1bml0T2JqZWN0KCkge1xuXHRcdGNvbnN0IHJnYiA9IHRoaXMucmdiKCkub2JqZWN0KCk7XG5cdFx0cmdiLnIgLz0gMjU1O1xuXHRcdHJnYi5nIC89IDI1NTtcblx0XHRyZ2IuYiAvPSAyNTU7XG5cblx0XHRpZiAodGhpcy52YWxwaGEgIT09IDEpIHtcblx0XHRcdHJnYi5hbHBoYSA9IHRoaXMudmFscGhhO1xuXHRcdH1cblxuXHRcdHJldHVybiByZ2I7XG5cdH0sXG5cblx0cm91bmQocGxhY2VzKSB7XG5cdFx0cGxhY2VzID0gTWF0aC5tYXgocGxhY2VzIHx8IDAsIDApO1xuXHRcdHJldHVybiBuZXcgQ29sb3IoWy4uLnRoaXMuY29sb3IubWFwKHJvdW5kVG9QbGFjZShwbGFjZXMpKSwgdGhpcy52YWxwaGFdLCB0aGlzLm1vZGVsKTtcblx0fSxcblxuXHRhbHBoYSh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKFsuLi50aGlzLmNvbG9yLCBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSkpXSwgdGhpcy5tb2RlbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMudmFscGhhO1xuXHR9LFxuXG5cdC8vIFJnYlxuXHRyZWQ6IGdldHNldCgncmdiJywgMCwgbWF4Zm4oMjU1KSksXG5cdGdyZWVuOiBnZXRzZXQoJ3JnYicsIDEsIG1heGZuKDI1NSkpLFxuXHRibHVlOiBnZXRzZXQoJ3JnYicsIDIsIG1heGZuKDI1NSkpLFxuXG5cdGh1ZTogZ2V0c2V0KFsnaHNsJywgJ2hzdicsICdoc2wnLCAnaHdiJywgJ2hjZyddLCAwLCB2YWx1ZSA9PiAoKHZhbHVlICUgMzYwKSArIDM2MCkgJSAzNjApLFxuXG5cdHNhdHVyYXRpb25sOiBnZXRzZXQoJ2hzbCcsIDEsIG1heGZuKDEwMCkpLFxuXHRsaWdodG5lc3M6IGdldHNldCgnaHNsJywgMiwgbWF4Zm4oMTAwKSksXG5cblx0c2F0dXJhdGlvbnY6IGdldHNldCgnaHN2JywgMSwgbWF4Zm4oMTAwKSksXG5cdHZhbHVlOiBnZXRzZXQoJ2hzdicsIDIsIG1heGZuKDEwMCkpLFxuXG5cdGNocm9tYTogZ2V0c2V0KCdoY2cnLCAxLCBtYXhmbigxMDApKSxcblx0Z3JheTogZ2V0c2V0KCdoY2cnLCAyLCBtYXhmbigxMDApKSxcblxuXHR3aGl0ZTogZ2V0c2V0KCdod2InLCAxLCBtYXhmbigxMDApKSxcblx0d2JsYWNrOiBnZXRzZXQoJ2h3YicsIDIsIG1heGZuKDEwMCkpLFxuXG5cdGN5YW46IGdldHNldCgnY215aycsIDAsIG1heGZuKDEwMCkpLFxuXHRtYWdlbnRhOiBnZXRzZXQoJ2NteWsnLCAxLCBtYXhmbigxMDApKSxcblx0eWVsbG93OiBnZXRzZXQoJ2NteWsnLCAyLCBtYXhmbigxMDApKSxcblx0YmxhY2s6IGdldHNldCgnY215aycsIDMsIG1heGZuKDEwMCkpLFxuXG5cdHg6IGdldHNldCgneHl6JywgMCwgbWF4Zm4oOTUuMDQ3KSksXG5cdHk6IGdldHNldCgneHl6JywgMSwgbWF4Zm4oMTAwKSksXG5cdHo6IGdldHNldCgneHl6JywgMiwgbWF4Zm4oMTA4LjgzMykpLFxuXG5cdGw6IGdldHNldCgnbGFiJywgMCwgbWF4Zm4oMTAwKSksXG5cdGE6IGdldHNldCgnbGFiJywgMSksXG5cdGI6IGdldHNldCgnbGFiJywgMiksXG5cblx0a2V5d29yZCh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sb3JDb252ZXJ0W3RoaXMubW9kZWxdLmtleXdvcmQodGhpcy5jb2xvcik7XG5cdH0sXG5cblx0aGV4KHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodmFsdWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb2xvclN0cmluZy50by5oZXgodGhpcy5yZ2IoKS5yb3VuZCgpLmNvbG9yKTtcblx0fSxcblxuXHRoZXhhKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodmFsdWUpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJnYkFycmF5ID0gdGhpcy5yZ2IoKS5yb3VuZCgpLmNvbG9yO1xuXG5cdFx0bGV0IGFscGhhSGV4ID0gTWF0aC5yb3VuZCh0aGlzLnZhbHBoYSAqIDI1NSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdFx0aWYgKGFscGhhSGV4Lmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0YWxwaGFIZXggPSAnMCcgKyBhbHBoYUhleDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sb3JTdHJpbmcudG8uaGV4KHJnYkFycmF5KSArIGFscGhhSGV4O1xuXHR9LFxuXG5cdHJnYk51bWJlcigpIHtcblx0XHRjb25zdCByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHJldHVybiAoKHJnYlswXSAmIDB4RkYpIDw8IDE2KSB8ICgocmdiWzFdICYgMHhGRikgPDwgOCkgfCAocmdiWzJdICYgMHhGRik7XG5cdH0sXG5cblx0bHVtaW5vc2l0eSgpIHtcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG5cdFx0Y29uc3QgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcblxuXHRcdGNvbnN0IGx1bSA9IFtdO1xuXHRcdGZvciAoY29uc3QgW2ksIGVsZW1lbnRdIG9mIHJnYi5lbnRyaWVzKCkpIHtcblx0XHRcdGNvbnN0IGNoYW4gPSBlbGVtZW50IC8gMjU1O1xuXHRcdFx0bHVtW2ldID0gKGNoYW4gPD0gMC4wNDA0NSkgPyBjaGFuIC8gMTIuOTIgOiAoKGNoYW4gKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xuXHRcdH1cblxuXHRcdHJldHVybiAwLjIxMjYgKiBsdW1bMF0gKyAwLjcxNTIgKiBsdW1bMV0gKyAwLjA3MjIgKiBsdW1bMl07XG5cdH0sXG5cblx0Y29udHJhc3QoY29sb3IyKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxuXHRcdGNvbnN0IGx1bTEgPSB0aGlzLmx1bWlub3NpdHkoKTtcblx0XHRjb25zdCBsdW0yID0gY29sb3IyLmx1bWlub3NpdHkoKTtcblxuXHRcdGlmIChsdW0xID4gbHVtMikge1xuXHRcdFx0cmV0dXJuIChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpO1xuXHRcdH1cblxuXHRcdHJldHVybiAobHVtMiArIDAuMDUpIC8gKGx1bTEgKyAwLjA1KTtcblx0fSxcblxuXHRsZXZlbChjb2xvcjIpIHtcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvV0NBRy8jY29udHJhc3QtZW5oYW5jZWRcblx0XHRjb25zdCBjb250cmFzdFJhdGlvID0gdGhpcy5jb250cmFzdChjb2xvcjIpO1xuXHRcdGlmIChjb250cmFzdFJhdGlvID49IDcpIHtcblx0XHRcdHJldHVybiAnQUFBJztcblx0XHR9XG5cblx0XHRyZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNC41KSA/ICdBQScgOiAnJztcblx0fSxcblxuXHRpc0RhcmsoKSB7XG5cdFx0Ly8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXHRcdGNvbnN0IHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cdFx0Y29uc3QgeWlxID0gKHJnYlswXSAqIDIxMjYgKyByZ2JbMV0gKiA3MTUyICsgcmdiWzJdICogNzIyKSAvIDEwMDAwO1xuXHRcdHJldHVybiB5aXEgPCAxMjg7XG5cdH0sXG5cblx0aXNMaWdodCgpIHtcblx0XHRyZXR1cm4gIXRoaXMuaXNEYXJrKCk7XG5cdH0sXG5cblx0bmVnYXRlKCkge1xuXHRcdGNvbnN0IHJnYiA9IHRoaXMucmdiKCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYi5jb2xvcltpXSA9IDI1NSAtIHJnYi5jb2xvcltpXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmdiO1xuXHR9LFxuXG5cdGxpZ2h0ZW4ocmF0aW8pIHtcblx0XHRjb25zdCBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdGhzbC5jb2xvclsyXSArPSBoc2wuY29sb3JbMl0gKiByYXRpbztcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdGRhcmtlbihyYXRpbykge1xuXHRcdGNvbnN0IGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0aHNsLmNvbG9yWzJdIC09IGhzbC5jb2xvclsyXSAqIHJhdGlvO1xuXHRcdHJldHVybiBoc2w7XG5cdH0sXG5cblx0c2F0dXJhdGUocmF0aW8pIHtcblx0XHRjb25zdCBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdGhzbC5jb2xvclsxXSArPSBoc2wuY29sb3JbMV0gKiByYXRpbztcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdGRlc2F0dXJhdGUocmF0aW8pIHtcblx0XHRjb25zdCBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdGhzbC5jb2xvclsxXSAtPSBoc2wuY29sb3JbMV0gKiByYXRpbztcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdHdoaXRlbihyYXRpbykge1xuXHRcdGNvbnN0IGh3YiA9IHRoaXMuaHdiKCk7XG5cdFx0aHdiLmNvbG9yWzFdICs9IGh3Yi5jb2xvclsxXSAqIHJhdGlvO1xuXHRcdHJldHVybiBod2I7XG5cdH0sXG5cblx0YmxhY2tlbihyYXRpbykge1xuXHRcdGNvbnN0IGh3YiA9IHRoaXMuaHdiKCk7XG5cdFx0aHdiLmNvbG9yWzJdICs9IGh3Yi5jb2xvclsyXSAqIHJhdGlvO1xuXHRcdHJldHVybiBod2I7XG5cdH0sXG5cblx0Z3JheXNjYWxlKCkge1xuXHRcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JheXNjYWxlI0NvbnZlcnRpbmdfY29sb3JfdG9fZ3JheXNjYWxlXG5cdFx0Y29uc3QgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcblx0XHRjb25zdCB2YWx1ZSA9IHJnYlswXSAqIDAuMyArIHJnYlsxXSAqIDAuNTkgKyByZ2JbMl0gKiAwLjExO1xuXHRcdHJldHVybiBDb2xvci5yZ2IodmFsdWUsIHZhbHVlLCB2YWx1ZSk7XG5cdH0sXG5cblx0ZmFkZShyYXRpbykge1xuXHRcdHJldHVybiB0aGlzLmFscGhhKHRoaXMudmFscGhhIC0gKHRoaXMudmFscGhhICogcmF0aW8pKTtcblx0fSxcblxuXHRvcGFxdWVyKHJhdGlvKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWxwaGEodGhpcy52YWxwaGEgKyAodGhpcy52YWxwaGEgKiByYXRpbykpO1xuXHR9LFxuXG5cdHJvdGF0ZShkZWdyZWVzKSB7XG5cdFx0Y29uc3QgaHNsID0gdGhpcy5oc2woKTtcblx0XHRsZXQgaHVlID0gaHNsLmNvbG9yWzBdO1xuXHRcdGh1ZSA9IChodWUgKyBkZWdyZWVzKSAlIDM2MDtcblx0XHRodWUgPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuXHRcdGhzbC5jb2xvclswXSA9IGh1ZTtcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdG1peChtaXhpbkNvbG9yLCB3ZWlnaHQpIHtcblx0XHQvLyBQb3J0ZWQgZnJvbSBzYXNzIGltcGxlbWVudGF0aW9uIGluIENcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2Fzcy9saWJzYXNzL2Jsb2IvMGU2YjRhMjg1MDA5MjM1NmFhM2VjZTA3YzZiMjQ5ZjAyMjFjYWNlZC9mdW5jdGlvbnMuY3BwI0wyMDlcblx0XHRpZiAoIW1peGluQ29sb3IgfHwgIW1peGluQ29sb3IucmdiKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IHRvIFwibWl4XCIgd2FzIG5vdCBhIENvbG9yIGluc3RhbmNlLCBidXQgcmF0aGVyIGFuIGluc3RhbmNlIG9mICcgKyB0eXBlb2YgbWl4aW5Db2xvcik7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29sb3IxID0gbWl4aW5Db2xvci5yZ2IoKTtcblx0XHRjb25zdCBjb2xvcjIgPSB0aGlzLnJnYigpO1xuXHRcdGNvbnN0IHAgPSB3ZWlnaHQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHdlaWdodDtcblxuXHRcdGNvbnN0IHcgPSAyICogcCAtIDE7XG5cdFx0Y29uc3QgYSA9IGNvbG9yMS5hbHBoYSgpIC0gY29sb3IyLmFscGhhKCk7XG5cblx0XHRjb25zdCB3MSA9ICgoKHcgKiBhID09PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMjtcblx0XHRjb25zdCB3MiA9IDEgLSB3MTtcblxuXHRcdHJldHVybiBDb2xvci5yZ2IoXG5cdFx0XHR3MSAqIGNvbG9yMS5yZWQoKSArIHcyICogY29sb3IyLnJlZCgpLFxuXHRcdFx0dzEgKiBjb2xvcjEuZ3JlZW4oKSArIHcyICogY29sb3IyLmdyZWVuKCksXG5cdFx0XHR3MSAqIGNvbG9yMS5ibHVlKCkgKyB3MiAqIGNvbG9yMi5ibHVlKCksXG5cdFx0XHRjb2xvcjEuYWxwaGEoKSAqIHAgKyBjb2xvcjIuYWxwaGEoKSAqICgxIC0gcCkpO1xuXHR9LFxufTtcblxuLy8gTW9kZWwgY29udmVyc2lvbiBtZXRob2RzIGFuZCBzdGF0aWMgY29uc3RydWN0b3JzXG5mb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC5rZXlzKGNvbG9yQ29udmVydCkpIHtcblx0aWYgKHNraXBwZWRNb2RlbHMuaW5jbHVkZXMobW9kZWwpKSB7XG5cdFx0Y29udGludWU7XG5cdH1cblxuXHRjb25zdCB7Y2hhbm5lbHN9ID0gY29sb3JDb252ZXJ0W21vZGVsXTtcblxuXHQvLyBDb252ZXJzaW9uIG1ldGhvZHNcblx0Q29sb3IucHJvdG90eXBlW21vZGVsXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0aWYgKHRoaXMubW9kZWwgPT09IG1vZGVsKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChhcmdzLmxlbmd0aCA+IDApIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IoYXJncywgbW9kZWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgQ29sb3IoWy4uLmFzc2VydEFycmF5KGNvbG9yQ29udmVydFt0aGlzLm1vZGVsXVttb2RlbF0ucmF3KHRoaXMuY29sb3IpKSwgdGhpcy52YWxwaGFdLCBtb2RlbCk7XG5cdH07XG5cblx0Ly8gJ3N0YXRpYycgY29uc3RydWN0aW9uIG1ldGhvZHNcblx0Q29sb3JbbW9kZWxdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRsZXQgY29sb3IgPSBhcmdzWzBdO1xuXHRcdGlmICh0eXBlb2YgY29sb3IgPT09ICdudW1iZXInKSB7XG5cdFx0XHRjb2xvciA9IHplcm9BcnJheShhcmdzLCBjaGFubmVscyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb2xvcihjb2xvciwgbW9kZWwpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiByb3VuZFRvKG51bWJlciwgcGxhY2VzKSB7XG5cdHJldHVybiBOdW1iZXIobnVtYmVyLnRvRml4ZWQocGxhY2VzKSk7XG59XG5cbmZ1bmN0aW9uIHJvdW5kVG9QbGFjZShwbGFjZXMpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChudW1iZXIpIHtcblx0XHRyZXR1cm4gcm91bmRUbyhudW1iZXIsIHBsYWNlcyk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGdldHNldChtb2RlbCwgY2hhbm5lbCwgbW9kaWZpZXIpIHtcblx0bW9kZWwgPSBBcnJheS5pc0FycmF5KG1vZGVsKSA/IG1vZGVsIDogW21vZGVsXTtcblxuXHRmb3IgKGNvbnN0IG0gb2YgbW9kZWwpIHtcblx0XHQobGltaXRlcnNbbV0gfHwgKGxpbWl0ZXJzW21dID0gW10pKVtjaGFubmVsXSA9IG1vZGlmaWVyO1xuXHR9XG5cblx0bW9kZWwgPSBtb2RlbFswXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0bGV0IHJlc3VsdDtcblxuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAobW9kaWZpZXIpIHtcblx0XHRcdFx0dmFsdWUgPSBtb2RpZmllcih2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdCA9IHRoaXNbbW9kZWxdKCk7XG5cdFx0XHRyZXN1bHQuY29sb3JbY2hhbm5lbF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0cmVzdWx0ID0gdGhpc1ttb2RlbF0oKS5jb2xvcltjaGFubmVsXTtcblx0XHRpZiAobW9kaWZpZXIpIHtcblx0XHRcdHJlc3VsdCA9IG1vZGlmaWVyKHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcbn1cblxuZnVuY3Rpb24gbWF4Zm4obWF4KSB7XG5cdHJldHVybiBmdW5jdGlvbiAodikge1xuXHRcdHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHYpKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXJyYXkodmFsdWUpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG5mdW5jdGlvbiB6ZXJvQXJyYXkoYXJyYXksIGxlbmd0aCkge1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBhcnJheVtpXSAhPT0gJ251bWJlcicpIHtcblx0XHRcdGFycmF5W2ldID0gMDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYXJyYXk7XG59XG5cbnZhciBjb2xvciA9IENvbG9yO1xuXG5jb25zdCBDU1MkMiA9IHtcbiAgY2hhbm5lbDogXCJjaGFubmVsXCIsXG4gIGNoYW5uZWxzOiBcImNoYW5uZWxzXCIsXG4gIGNvbG9yRmllbGQ6IFwiY29sb3ItZmllbGRcIixcbiAgY29sb3JGaWVsZFNjb3BlOiBcInNjb3BlLS1jb2xvci1maWVsZFwiLFxuICBjb2xvck1vZGU6IFwiY29sb3ItbW9kZVwiLFxuICBjb2xvck1vZGVDb250YWluZXI6IFwiY29sb3ItbW9kZS1jb250YWluZXJcIixcbiAgY29udGFpbmVyOiBcImNvbnRhaW5lclwiLFxuICBjb250cm9sOiBcImNvbnRyb2xcIixcbiAgY29udHJvbEFuZFNjb3BlOiBcImNvbnRyb2wtYW5kLXNjb3BlXCIsXG4gIGNvbnRyb2xTZWN0aW9uOiBcImNvbnRyb2wtc2VjdGlvblwiLFxuICBkZWxldGVDb2xvcjogXCJkZWxldGUtY29sb3JcIixcbiAgaGVhZGVyOiBcImhlYWRlclwiLFxuICBoZXhBbmRDaGFubmVsc0dyb3VwOiBcImhleC1hbmQtY2hhbm5lbHMtZ3JvdXBcIixcbiAgaGV4T3B0aW9uczogXCJjb2xvci1oZXgtb3B0aW9uc1wiLFxuICBodWVTY29wZTogXCJzY29wZS0taHVlXCIsXG4gIGh1ZVNsaWRlcjogXCJodWUtc2xpZGVyXCIsXG4gIG9wYWNpdHlTY29wZTogXCJzY29wZS0tb3BhY2l0eVwiLFxuICBvcGFjaXR5U2xpZGVyOiBcIm9wYWNpdHktc2xpZGVyXCIsXG4gIHByZXZpZXc6IFwicHJldmlld1wiLFxuICBwcmV2aWV3QW5kU2xpZGVyczogXCJwcmV2aWV3LWFuZC1zbGlkZXJzXCIsXG4gIHNhdmVDb2xvcjogXCJzYXZlLWNvbG9yXCIsXG4gIHNhdmVkQ29sb3I6IFwic2F2ZWQtY29sb3JcIixcbiAgc2F2ZWRDb2xvcnM6IFwic2F2ZWQtY29sb3JzXCIsXG4gIHNhdmVkQ29sb3JzQnV0dG9uczogXCJzYXZlZC1jb2xvcnMtYnV0dG9uc1wiLFxuICBzYXZlZENvbG9yc1NlY3Rpb246IFwic2F2ZWQtY29sb3JzLXNlY3Rpb25cIixcbiAgc2NvcGU6IFwic2NvcGVcIixcbiAgc2VjdGlvbjogXCJzZWN0aW9uXCIsXG4gIHNsaWRlcjogXCJzbGlkZXJcIixcbiAgc2xpZGVyczogXCJzbGlkZXJzXCIsXG4gIHNwbGl0U2VjdGlvbjogXCJzZWN0aW9uLS1zcGxpdFwiLFxufTtcbmNvbnN0IERFRkFVTFRfQ09MT1IkMSA9IGNvbG9yKFwiIzAwN0FDMlwiKTtcbmNvbnN0IERFRkFVTFRfU1RPUkFHRV9LRVlfUFJFRklYID0gXCJjYWxjaXRlLWNvbG9yLVwiO1xuY29uc3QgUkdCX0xJTUlUUyA9IHtcbiAgcjogMjU1LFxuICBnOiAyNTUsXG4gIGI6IDI1NSxcbn07XG5jb25zdCBIU1ZfTElNSVRTID0ge1xuICBoOiAzNjAsXG4gIHM6IDEwMCxcbiAgdjogMTAwLFxufTtcbi8vIDAgYW5kIDM2MCByZXByZXNlbnQgdGhlIHNhbWUgdmFsdWUsIHNvIHdlIGxpbWl0IHRoZSBodWUgdG8gMzU5XG5jb25zdCBIVUVfTElNSVRfQ09OU1RSQUlORUQgPSBIU1ZfTElNSVRTLmggLSAxO1xuY29uc3QgT1BBQ0lUWV9MSU1JVFMgPSB7XG4gIG1pbjogMCxcbiAgbWF4OiAxMDAsXG59O1xuY29uc3QgRElNRU5TSU9OUyA9IHtcbiAgczoge1xuICAgIHNsaWRlcjoge1xuICAgICAgaGVpZ2h0OiAxMixcbiAgICAgIHdpZHRoOiAxMDQsXG4gICAgfSxcbiAgICBjb2xvckZpZWxkOiB7XG4gICAgICBoZWlnaHQ6IDgwLFxuICAgICAgd2lkdGg6IDE2MCxcbiAgICB9LFxuICAgIHRodW1iOiB7XG4gICAgICByYWRpdXM6IDEwLFxuICAgIH0sXG4gIH0sXG4gIG06IHtcbiAgICBzbGlkZXI6IHtcbiAgICAgIGhlaWdodDogMTIsXG4gICAgICB3aWR0aDogMjA0LFxuICAgIH0sXG4gICAgY29sb3JGaWVsZDoge1xuICAgICAgaGVpZ2h0OiAxNTAsXG4gICAgICB3aWR0aDogMjcyLFxuICAgIH0sXG4gICAgdGh1bWI6IHtcbiAgICAgIHJhZGl1czogMTAsXG4gICAgfSxcbiAgfSxcbiAgbDoge1xuICAgIHNsaWRlcjoge1xuICAgICAgaGVpZ2h0OiAxMixcbiAgICAgIHdpZHRoOiAzODQsXG4gICAgfSxcbiAgICBjb2xvckZpZWxkOiB7XG4gICAgICBoZWlnaHQ6IDIwMCxcbiAgICAgIHdpZHRoOiA0NjQsXG4gICAgfSxcbiAgICB0aHVtYjoge1xuICAgICAgcmFkaXVzOiAxMCxcbiAgICB9LFxuICB9LFxufTtcbmNvbnN0IFNDT1BFX1NJWkUgPSAxO1xuXG5jb25zdCBjb2xvclBpY2tlckNzcyA9IFwiOmhvc3QoW2Rpc2FibGVkXSl7Y3Vyc29yOmRlZmF1bHQ7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7b3BhY2l0eTp2YXIoLS1jYWxjaXRlLW9wYWNpdHktZGlzYWJsZWQpfTpob3N0KFtkaXNhYmxlZF0pICosOmhvc3QoW2Rpc2FibGVkXSkgOjpzbG90dGVkKCope3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3R7ZGlzcGxheTppbmxpbmUtYmxvY2s7Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0yKTtsaW5lLWhlaWdodDoxcmVtO2ZvbnQtd2VpZ2h0OnZhcigtLWNhbGNpdGUtZm9udC13ZWlnaHQtbm9ybWFsKX06aG9zdChbZGlzYWJsZWRdKSA6OnNsb3R0ZWQoW2NhbGNpdGUtaHlkcmF0ZWRdW2Rpc2FibGVkXSksOmhvc3QoW2Rpc2FibGVkXSkgW2NhbGNpdGUtaHlkcmF0ZWRdW2Rpc2FibGVkXXtvcGFjaXR5OjF9Omhvc3QoW3NjYWxlPXNdKXstLWNhbGNpdGUtY29sb3ItcGlja2VyLXNwYWNpbmc6OHB4fTpob3N0KFtzY2FsZT1zXSkgLmNvbnRhaW5lcntpbmxpbmUtc2l6ZToxNjBweH06aG9zdChbc2NhbGU9c10pIC5zYXZlZC1jb2xvcnN7Z2FwOjAuMjVyZW07Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOnJlcGVhdChhdXRvLWZpbGwsIDIwcHgpfTpob3N0KFtzY2FsZT1tXSl7LS1jYWxjaXRlLWNvbG9yLXBpY2tlci1zcGFjaW5nOjEycHh9Omhvc3QoW3NjYWxlPW1dKSAuY29udGFpbmVye2lubGluZS1zaXplOjI3MnB4fTpob3N0KFtzY2FsZT1sXSl7LS1jYWxjaXRlLWNvbG9yLXBpY2tlci1zcGFjaW5nOjE2cHg7Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0xKTtsaW5lLWhlaWdodDoxcmVtfTpob3N0KFtzY2FsZT1sXSkgLmNvbnRhaW5lcntpbmxpbmUtc2l6ZTo0NjRweH06aG9zdChbc2NhbGU9bF0pIC5zZWN0aW9uOmZpcnN0LW9mLXR5cGV7cGFkZGluZy1ibG9jay1zdGFydDp2YXIoLS1jYWxjaXRlLWNvbG9yLXBpY2tlci1zcGFjaW5nKX06aG9zdChbc2NhbGU9bF0pIC5zYXZlZC1jb2xvcnN7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOnJlcGVhdChhdXRvLWZpbGwsIDMycHgpfTpob3N0KFtzY2FsZT1sXSkgLmNvbnRyb2wtc2VjdGlvbntmbGV4LXdyYXA6bm93cmFwO2FsaWduLWl0ZW1zOmJhc2VsaW5lO2ZsZXgtd3JhcDp3cmFwfTpob3N0KFtzY2FsZT1sXSkgLmNvbG9yLWhleC1vcHRpb25ze2Rpc3BsYXk6ZmxleDtmbGV4LXNocmluazoxO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYXJvdW5kfTpob3N0KFtzY2FsZT1sXSkgLmNvbG9yLW1vZGUtY29udGFpbmVye2ZsZXgtc2hyaW5rOjN9LmNvbnRhaW5lcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItZm9yZWdyb3VuZC0xKTtkaXNwbGF5OmlubGluZS1ibG9jaztib3JkZXI6MXB4IHNvbGlkIHZhcigtLWNhbGNpdGUtY29sb3ItYm9yZGVyLTEpfS5jb250cm9sLWFuZC1zY29wZXtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmZsZXg7Y3Vyc29yOnBvaW50ZXI7dG91Y2gtYWN0aW9uOm5vbmV9LnNjb3Ble3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDp2YXIoLS1jYWxjaXRlLXotaW5kZXgpO2Jsb2NrLXNpemU6MXB4O2lubGluZS1zaXplOjFweDtib3JkZXItcmFkaXVzOjk5OTlweDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMSk7b3V0bGluZS1jb2xvcjp0cmFuc3BhcmVudH0uc2NvcGU6Zm9jdXN7b3V0bGluZToycHggc29saWQgdmFyKC0tY2FsY2l0ZS1jb2xvci1icmFuZCk7b3V0bGluZS1vZmZzZXQ6Y2FsYyhcXG4gICAgICAgICAgICAycHggKlxcbiAgICAgICAgICAgIGNhbGMoXFxuICAgICAgICAgICAgICAxIC1cXG4gICAgICAgICAgICAgIDIgKiBjbGFtcChcXG4gICAgICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAgICAgdmFyKC0tY2FsY2l0ZS1vZmZzZXQtaW52ZXJ0LWZvY3VzKSxcXG4gICAgICAgICAgICAgICAgMVxcbiAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIClcXG4gICAgICAgICAgKTtvdXRsaW5lLW9mZnNldDoxMXB4fS5oZXgtYW5kLWNoYW5uZWxzLWdyb3Vwe2lubGluZS1zaXplOjEwMCV9LmhleC1hbmQtY2hhbm5lbHMtZ3JvdXAsLmNvbnRyb2wtc2VjdGlvbntkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtd3JhcDp3cmFwfS5zZWN0aW9ue3BhZGRpbmctYmxvY2s6MCB2YXIoLS1jYWxjaXRlLWNvbG9yLXBpY2tlci1zcGFjaW5nKTtwYWRkaW5nLWlubGluZTp2YXIoLS1jYWxjaXRlLWNvbG9yLXBpY2tlci1zcGFjaW5nKX0uc2VjdGlvbjpmaXJzdC1vZi10eXBle3BhZGRpbmctYmxvY2stc3RhcnQ6dmFyKC0tY2FsY2l0ZS1jb2xvci1waWNrZXItc3BhY2luZyl9LnNsaWRlcnN7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjttYXJnaW4taW5saW5lLXN0YXJ0OnZhcigtLWNhbGNpdGUtY29sb3ItcGlja2VyLXNwYWNpbmcpfS5wcmV2aWV3LWFuZC1zbGlkZXJze2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7cGFkZGluZzp2YXIoLS1jYWxjaXRlLWNvbG9yLXBpY2tlci1zcGFjaW5nKX0uY29sb3ItaGV4LW9wdGlvbnMsLnNlY3Rpb24tLXNwbGl0e2ZsZXgtZ3JvdzoxfS5oZWFkZXJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbjtjb2xvcjp2YXIoLS1jYWxjaXRlLWNvbG9yLXRleHQtMSl9LmNvbG9yLW1vZGUtY29udGFpbmVye3BhZGRpbmctYmxvY2stc3RhcnQ6dmFyKC0tY2FsY2l0ZS1jb2xvci1waWNrZXItc3BhY2luZyl9LmNoYW5uZWxze2Rpc3BsYXk6ZmxleDtyb3ctZ2FwOjAuMTI1cmVtfS5jaGFubmVsW2RhdGEtY2hhbm5lbC1pbmRleD1cXFwiM1xcXCJde2lubGluZS1zaXplOjE1OXB4fTpob3N0KFtzY2FsZT1zXSkgLmNoYW5uZWxze2ZsZXgtd3JhcDp3cmFwfTpob3N0KFtzY2FsZT1zXSkgLmNoYW5uZWx7ZmxleC1iYXNpczozMCU7ZmxleC1ncm93OjF9Omhvc3QoW3NjYWxlPXNdKSAuY2hhbm5lbFtkYXRhLWNoYW5uZWwtaW5kZXg9XFxcIjNcXFwiXXtpbmxpbmUtc2l6ZTp1bnNldDttYXJnaW4taW5saW5lLXN0YXJ0OnVuc2V0fTpob3N0KFtzY2FsZT1sXSkgLmNoYW5uZWxbZGF0YS1jaGFubmVsLWluZGV4PVxcXCIzXFxcIl17aW5saW5lLXNpemU6MTMxcHh9LnNhdmVkLWNvbG9yc3tkaXNwbGF5OmdyaWQ7Z2FwOjAuNXJlbTtwYWRkaW5nLWJsb2NrLXN0YXJ0OnZhcigtLWNhbGNpdGUtY29sb3ItcGlja2VyLXNwYWNpbmcpO2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoYXV0by1maWxsLCAyNHB4KX0uc2F2ZWQtY29sb3JzLWJ1dHRvbnN7ZGlzcGxheTpmbGV4fS5zYXZlZC1jb2xvcntvdXRsaW5lLW9mZnNldDowO291dGxpbmUtY29sb3I6dHJhbnNwYXJlbnQ7Y3Vyc29yOnBvaW50ZXJ9LnNhdmVkLWNvbG9yOmZvY3Vze291dGxpbmU6MnB4IHNvbGlkIHZhcigtLWNhbGNpdGUtY29sb3ItYnJhbmQpO291dGxpbmUtb2Zmc2V0OjJweH0uc2F2ZWQtY29sb3I6aG92ZXJ7dHJhbnNpdGlvbjpvdXRsaW5lLWNvbG9yIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1mYXN0KSBlYXNlLWluLW91dDtvdXRsaW5lOjJweCBzb2xpZCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJvcmRlci0yKTtvdXRsaW5lLW9mZnNldDoycHh9Omhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX1baGlkZGVuXXtkaXNwbGF5Om5vbmV9XCI7XG5cbmNvbnN0IHRocm90dGxlRm9yNjBGcHNJbk1zID0gMTY7XG5jb25zdCBDb2xvclBpY2tlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5jYWxjaXRlQ29sb3JQaWNrZXJDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVDb2xvclBpY2tlckNoYW5nZVwiLCA2KTtcbiAgICB0aGlzLmNhbGNpdGVDb2xvclBpY2tlcklucHV0ID0gY3JlYXRlRXZlbnQodGhpcywgXCJjYWxjaXRlQ29sb3JQaWNrZXJJbnB1dFwiLCA2KTtcbiAgICB0aGlzLmludGVybmFsQ29sb3JVcGRhdGVDb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLm1vZGUgPSBDU1NDb2xvck1vZGUuSEVYO1xuICAgIHRoaXMuc2hpZnRLZXlDaGFubmVsQWRqdXN0bWVudCA9IDA7XG4gICAgdGhpcy5oYW5kbGVUYWJBY3RpdmF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5jaGFubmVsTW9kZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvci1tb2RlXCIpO1xuICAgICAgdGhpcy51cGRhdGVDaGFubmVsc0Zyb21Db2xvcih0aGlzLmNvbG9yKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ29sb3JGaWVsZFNjb3BlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBrZXkgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgYXJyb3dLZXlUb1hZT2Zmc2V0ID0ge1xuICAgICAgICBBcnJvd1VwOiB7IHg6IDAsIHk6IC0xMCB9LFxuICAgICAgICBBcnJvd1JpZ2h0OiB7IHg6IDEwLCB5OiAwIH0sXG4gICAgICAgIEFycm93RG93bjogeyB4OiAwLCB5OiAxMCB9LFxuICAgICAgICBBcnJvd0xlZnQ6IHsgeDogLTEwLCB5OiAwIH0sXG4gICAgICB9O1xuICAgICAgaWYgKGFycm93S2V5VG9YWU9mZnNldFtrZXldKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc2NvcGVPcmllbnRhdGlvbiA9IGtleSA9PT0gXCJBcnJvd0Rvd25cIiB8fCBrZXkgPT09IFwiQXJyb3dVcFwiID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCI7XG4gICAgICAgIHRoaXMuY2FwdHVyZUNvbG9yRmllbGRDb2xvcih0aGlzLmNvbG9yRmllbGRTY29wZUxlZnQgKyBhcnJvd0tleVRvWFlPZmZzZXRba2V5XS54IHx8IDAsIHRoaXMuY29sb3JGaWVsZFNjb3BlVG9wICsgYXJyb3dLZXlUb1hZT2Zmc2V0W2tleV0ueSB8fCAwLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUh1ZVNjb3BlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgbW9kaWZpZXIgPSBldmVudC5zaGlmdEtleSA/IDEwIDogMTtcbiAgICAgIGNvbnN0IHsga2V5IH0gPSBldmVudDtcbiAgICAgIGNvbnN0IGFycm93S2V5VG9YT2Zmc2V0ID0ge1xuICAgICAgICBBcnJvd1VwOiAxLFxuICAgICAgICBBcnJvd1JpZ2h0OiAxLFxuICAgICAgICBBcnJvd0Rvd246IC0xLFxuICAgICAgICBBcnJvd0xlZnQ6IC0xLFxuICAgICAgfTtcbiAgICAgIGlmIChhcnJvd0tleVRvWE9mZnNldFtrZXldKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gYXJyb3dLZXlUb1hPZmZzZXRba2V5XSAqIG1vZGlmaWVyO1xuICAgICAgICBjb25zdCBodWUgPSB0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuaHVlKCk7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5iYXNlQ29sb3JGaWVsZENvbG9yLmh1ZShodWUgKyBkZWx0YSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChjb2xvciwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVIZXhJbnB1dENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBjb25zdCB7IGFsbG93RW1wdHksIGNvbG9yOiBjb2xvciQxIH0gPSB0aGlzO1xuICAgICAgY29uc3QgaW5wdXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBjb25zdCBoZXggPSBpbnB1dC52YWx1ZTtcbiAgICAgIGlmIChhbGxvd0VtcHR5ICYmICFoZXgpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkSGV4ID0gY29sb3IkMSAmJiBub3JtYWxpemVIZXgoaGV4aWZ5KGNvbG9yJDEsIGFscGhhQ29tcGF0aWJsZSh0aGlzLm1vZGUpKSk7XG4gICAgICBpZiAoaGV4ICE9PSBub3JtYWxpemVkSGV4KSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChjb2xvcihoZXgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU2F2ZWRDb2xvclNlbGVjdCA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgc3dhdGNoID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChjb2xvcihzd2F0Y2guY29sb3IpKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ2hhbm5lbElucHV0ID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBpbnB1dCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBjaGFubmVsSW5kZXggPSBOdW1iZXIoaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jaGFubmVsLWluZGV4XCIpKTtcbiAgICAgIGNvbnN0IGlzQWxwaGFDaGFubmVsID0gY2hhbm5lbEluZGV4ID09PSAzO1xuICAgICAgY29uc3QgbGltaXQgPSBpc0FscGhhQ2hhbm5lbFxuICAgICAgICA/IE9QQUNJVFlfTElNSVRTLm1heFxuICAgICAgICA6IHRoaXMuY2hhbm5lbE1vZGUgPT09IFwicmdiXCJcbiAgICAgICAgICA/IFJHQl9MSU1JVFNbT2JqZWN0LmtleXMoUkdCX0xJTUlUUylbY2hhbm5lbEluZGV4XV1cbiAgICAgICAgICA6IEhTVl9MSU1JVFNbT2JqZWN0LmtleXMoSFNWX0xJTUlUUylbY2hhbm5lbEluZGV4XV07XG4gICAgICBsZXQgaW5wdXRWYWx1ZTtcbiAgICAgIGlmICh0aGlzLmFsbG93RW1wdHkgJiYgIWlucHV0LnZhbHVlKSB7XG4gICAgICAgIGlucHV0VmFsdWUgPSBcIlwiO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyKGlucHV0LnZhbHVlKTtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRWYWx1ZSA9IHZhbHVlICsgdGhpcy5zaGlmdEtleUNoYW5uZWxBZGp1c3RtZW50O1xuICAgICAgICBjb25zdCBjbGFtcGVkID0gY2xhbXAoYWRqdXN0ZWRWYWx1ZSwgMCwgbGltaXQpO1xuICAgICAgICBpbnB1dFZhbHVlID0gY2xhbXBlZC50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaW5wdXQudmFsdWUgPSBpbnB1dFZhbHVlO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDaGFubmVsQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBpbnB1dCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBjaGFubmVsSW5kZXggPSBOdW1iZXIoaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jaGFubmVsLWluZGV4XCIpKTtcbiAgICAgIGNvbnN0IGNoYW5uZWxzID0gWy4uLnRoaXMuY2hhbm5lbHNdO1xuICAgICAgY29uc3Qgc2hvdWxkQ2xlYXJDaGFubmVscyA9IHRoaXMuYWxsb3dFbXB0eSAmJiAhaW5wdXQudmFsdWU7XG4gICAgICBpZiAoc2hvdWxkQ2xlYXJDaGFubmVscykge1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW251bGwsIG51bGwsIG51bGwsIG51bGxdO1xuICAgICAgICB0aGlzLmludGVybmFsQ29sb3JTZXQobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQWxwaGFDaGFubmVsID0gY2hhbm5lbEluZGV4ID09PSAzO1xuICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIoaW5wdXQudmFsdWUpO1xuICAgICAgY2hhbm5lbHNbY2hhbm5lbEluZGV4XSA9IGlzQWxwaGFDaGFubmVsID8gb3BhY2l0eVRvQWxwaGEodmFsdWUpIDogdmFsdWU7XG4gICAgICB0aGlzLnVwZGF0ZUNvbG9yRnJvbUNoYW5uZWxzKGNoYW5uZWxzKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU2F2ZWRDb2xvcktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChpc0FjdGl2YXRpb25LZXkoZXZlbnQua2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmhhbmRsZVNhdmVkQ29sb3JTZWxlY3QoZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDb2xvckZpZWxkUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghaXNQcmltYXJ5UG9pbnRlckJ1dHRvbihldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5nbG9iYWxQb2ludGVyTW92ZUhhbmRsZXIpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5nbG9iYWxQb2ludGVyVXBIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICB0aGlzLmFjdGl2ZUNhbnZhc0luZm8gPSB7XG4gICAgICAgIGNvbnRleHQ6IHRoaXMuY29sb3JGaWVsZFJlbmRlcmluZ0NvbnRleHQsXG4gICAgICAgIGJvdW5kczogdGhpcy5jb2xvckZpZWxkUmVuZGVyaW5nQ29udGV4dC5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB9O1xuICAgICAgdGhpcy5jYXB0dXJlQ29sb3JGaWVsZENvbG9yKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgdGhpcy5jb2xvckZpZWxkU2NvcGVOb2RlLmZvY3VzKCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUh1ZVNsaWRlclBvaW50ZXJEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWlzUHJpbWFyeVBvaW50ZXJCdXR0b24oZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgb2Zmc2V0WCB9ID0gZXZlbnQ7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuZ2xvYmFsUG9pbnRlck1vdmVIYW5kbGVyKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuZ2xvYmFsUG9pbnRlclVwSGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgdGhpcy5hY3RpdmVDYW52YXNJbmZvID0ge1xuICAgICAgICBjb250ZXh0OiB0aGlzLmh1ZVNsaWRlclJlbmRlcmluZ0NvbnRleHQsXG4gICAgICAgIGJvdW5kczogdGhpcy5odWVTbGlkZXJSZW5kZXJpbmdDb250ZXh0LmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIH07XG4gICAgICB0aGlzLmNhcHR1cmVIdWVTbGlkZXJDb2xvcihvZmZzZXRYKTtcbiAgICAgIHRoaXMuaHVlU2NvcGVOb2RlLmZvY3VzKCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZU9wYWNpdHlTbGlkZXJQb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKCFpc1ByaW1hcnlQb2ludGVyQnV0dG9uKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IG9mZnNldFggfSA9IGV2ZW50O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLmdsb2JhbFBvaW50ZXJNb3ZlSGFuZGxlcik7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLmdsb2JhbFBvaW50ZXJVcEhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHRoaXMuYWN0aXZlQ2FudmFzSW5mbyA9IHtcbiAgICAgICAgY29udGV4dDogdGhpcy5vcGFjaXR5U2xpZGVyUmVuZGVyaW5nQ29udGV4dCxcbiAgICAgICAgYm91bmRzOiB0aGlzLm9wYWNpdHlTbGlkZXJSZW5kZXJpbmdDb250ZXh0LmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIH07XG4gICAgICB0aGlzLmNhcHR1cmVPcGFjaXR5U2xpZGVyVmFsdWUob2Zmc2V0WCk7XG4gICAgICB0aGlzLm9wYWNpdHlTY29wZU5vZGUuZm9jdXMoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2xvYmFsUG9pbnRlclVwSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKCFpc1ByaW1hcnlQb2ludGVyQnV0dG9uKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c2x5RHJhZ2dpbmcgPSB0aGlzLmFjdGl2ZUNhbnZhc0luZm87XG4gICAgICB0aGlzLmFjdGl2ZUNhbnZhc0luZm8gPSBudWxsO1xuICAgICAgdGhpcy5kcmF3Q29sb3JDb250cm9scygpO1xuICAgICAgaWYgKHByZXZpb3VzbHlEcmFnZ2luZykge1xuICAgICAgICB0aGlzLmNhbGNpdGVDb2xvclBpY2tlckNoYW5nZS5lbWl0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdsb2JhbFBvaW50ZXJNb3ZlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBhY3RpdmVDYW52YXNJbmZvLCBlbCB9ID0gdGhpcztcbiAgICAgIGlmICghZWwuaXNDb25uZWN0ZWQgfHwgIWFjdGl2ZUNhbnZhc0luZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjb250ZXh0LCBib3VuZHMgfSA9IGFjdGl2ZUNhbnZhc0luZm87XG4gICAgICBsZXQgc2FtcGxpbmdYO1xuICAgICAgbGV0IHNhbXBsaW5nWTtcbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZXZlbnQ7XG4gICAgICBpZiAoY29udGV4dC5jYW52YXMubWF0Y2hlcyhcIjpob3ZlclwiKSkge1xuICAgICAgICBzYW1wbGluZ1ggPSBjbGllbnRYIC0gYm91bmRzLng7XG4gICAgICAgIHNhbXBsaW5nWSA9IGNsaWVudFkgLSBib3VuZHMueTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBzbmFwIHggYW5kIHkgdG8gdGhlIGNsb3Nlc3QgZWRnZVxuICAgICAgICBpZiAoY2xpZW50WCA8IGJvdW5kcy54ICsgYm91bmRzLndpZHRoICYmIGNsaWVudFggPiBib3VuZHMueCkge1xuICAgICAgICAgIHNhbXBsaW5nWCA9IGNsaWVudFggLSBib3VuZHMueDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGllbnRYIDwgYm91bmRzLngpIHtcbiAgICAgICAgICBzYW1wbGluZ1ggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNhbXBsaW5nWCA9IGJvdW5kcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpZW50WSA8IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCAmJiBjbGllbnRZID4gYm91bmRzLnkpIHtcbiAgICAgICAgICBzYW1wbGluZ1kgPSBjbGllbnRZIC0gYm91bmRzLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpZW50WSA8IGJvdW5kcy55KSB7XG4gICAgICAgICAgc2FtcGxpbmdZID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzYW1wbGluZ1kgPSBib3VuZHMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dCA9PT0gdGhpcy5jb2xvckZpZWxkUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICB0aGlzLmNhcHR1cmVDb2xvckZpZWxkQ29sb3Ioc2FtcGxpbmdYLCBzYW1wbGluZ1ksIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvbnRleHQgPT09IHRoaXMuaHVlU2xpZGVyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICB0aGlzLmNhcHR1cmVIdWVTbGlkZXJDb2xvcihzYW1wbGluZ1gpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29udGV4dCA9PT0gdGhpcy5vcGFjaXR5U2xpZGVyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICB0aGlzLmNhcHR1cmVPcGFjaXR5U2xpZGVyVmFsdWUoc2FtcGxpbmdYKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc3RvcmVDb2xvckZpZWxkU2NvcGUgPSAobm9kZSkgPT4ge1xuICAgICAgdGhpcy5jb2xvckZpZWxkU2NvcGVOb2RlID0gbm9kZTtcbiAgICB9O1xuICAgIHRoaXMuc3RvcmVIdWVTY29wZSA9IChub2RlKSA9PiB7XG4gICAgICB0aGlzLmh1ZVNjb3BlTm9kZSA9IG5vZGU7XG4gICAgfTtcbiAgICB0aGlzLnJlbmRlckNoYW5uZWxzVGFiVGl0bGUgPSAoY2hhbm5lbE1vZGUpID0+IHtcbiAgICAgIGNvbnN0IHsgY2hhbm5lbE1vZGU6IGFjdGl2ZUNoYW5uZWxNb2RlLCBtZXNzYWdlcyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0gY2hhbm5lbE1vZGUgPT09IGFjdGl2ZUNoYW5uZWxNb2RlO1xuICAgICAgY29uc3QgbGFiZWwgPSBjaGFubmVsTW9kZSA9PT0gXCJyZ2JcIiA/IG1lc3NhZ2VzLnJnYiA6IG1lc3NhZ2VzLmhzdjtcbiAgICAgIHJldHVybiAoaChcImNhbGNpdGUtdGFiLXRpdGxlXCIsIHsgY2xhc3M6IENTUyQyLmNvbG9yTW9kZSwgXCJkYXRhLWNvbG9yLW1vZGVcIjogY2hhbm5lbE1vZGUsIGtleTogY2hhbm5lbE1vZGUsIG9uQ2FsY2l0ZVRhYnNBY3RpdmF0ZTogdGhpcy5oYW5kbGVUYWJBY3RpdmF0ZSwgc2VsZWN0ZWQ6IHNlbGVjdGVkIH0sIGxhYmVsKSk7XG4gICAgfTtcbiAgICB0aGlzLnJlbmRlckNoYW5uZWxzVGFiID0gKGNoYW5uZWxNb2RlKSA9PiB7XG4gICAgICBjb25zdCB7IGFsbG93RW1wdHksIGNoYW5uZWxNb2RlOiBhY3RpdmVDaGFubmVsTW9kZSwgY2hhbm5lbHMsIG1lc3NhZ2VzLCBhbHBoYUNoYW5uZWwgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IGNoYW5uZWxNb2RlID09PSBhY3RpdmVDaGFubmVsTW9kZTtcbiAgICAgIGNvbnN0IGlzUmdiID0gY2hhbm5lbE1vZGUgPT09IFwicmdiXCI7XG4gICAgICBjb25zdCBjaGFubmVsQXJpYUxhYmVscyA9IGlzUmdiXG4gICAgICAgID8gW21lc3NhZ2VzLnJlZCwgbWVzc2FnZXMuZ3JlZW4sIG1lc3NhZ2VzLmJsdWVdXG4gICAgICAgIDogW21lc3NhZ2VzLmh1ZSwgbWVzc2FnZXMuc2F0dXJhdGlvbiwgbWVzc2FnZXMudmFsdWVdO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZ2V0RWxlbWVudERpcih0aGlzLmVsKTtcbiAgICAgIGNvbnN0IGNoYW5uZWxzVG9SZW5kZXIgPSBhbHBoYUNoYW5uZWwgPyBjaGFubmVscyA6IGNoYW5uZWxzLnNsaWNlKDAsIDMpO1xuICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS10YWJcIiwgeyBjbGFzczogQ1NTJDIuY29udHJvbCwga2V5OiBjaGFubmVsTW9kZSwgc2VsZWN0ZWQ6IHNlbGVjdGVkIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDIuY2hhbm5lbHMsIGRpcjogXCJsdHJcIiB9LCBjaGFubmVsc1RvUmVuZGVyLm1hcCgoY2hhbm5lbFZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBpc0FscGhhQ2hhbm5lbCA9IGluZGV4ID09PSAzO1xuICAgICAgICBpZiAoaXNBbHBoYUNoYW5uZWwpIHtcbiAgICAgICAgICBjaGFubmVsVmFsdWUgPVxuICAgICAgICAgICAgYWxsb3dFbXB0eSAmJiAhY2hhbm5lbFZhbHVlID8gY2hhbm5lbFZhbHVlIDogYWxwaGFUb09wYWNpdHkoY2hhbm5lbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiB0aGUgY2hhbm5lbCBjb250YWluZXIgaXMgbHRyLCBzbyB3ZSBhcHBseSB0aGUgaG9zdCdzIGRpcmVjdGlvbiAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDaGFubmVsKGNoYW5uZWxWYWx1ZSwgaW5kZXgsIGNoYW5uZWxBcmlhTGFiZWxzW2luZGV4XSwgZGlyZWN0aW9uLCBpc0FscGhhQ2hhbm5lbCA/IFwiJVwiIDogXCJcIik7XG4gICAgICB9KSkpKTtcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyQ2hhbm5lbCA9ICh2YWx1ZSwgaW5kZXgsIGFyaWFMYWJlbCwgZGlyZWN0aW9uLCBzdWZmaXgpID0+IHtcbiAgICAgIHJldHVybiAoaChcImNhbGNpdGUtaW5wdXQtbnVtYmVyXCIsIHsgY2xhc3M6IENTUyQyLmNoYW5uZWwsIFwiZGF0YS1jaGFubmVsLWluZGV4XCI6IGluZGV4LCBkaXI6IGRpcmVjdGlvbiwga2V5OiBpbmRleCwgbGFiZWw6IGFyaWFMYWJlbCwgbGFuZzogdGhpcy5lZmZlY3RpdmVMb2NhbGUsIG51bWJlckJ1dHRvblR5cGU6IFwibm9uZVwiLCBudW1iZXJpbmdTeXN0ZW06IHRoaXMubnVtYmVyaW5nU3lzdGVtLCBvbkNhbGNpdGVJbnB1dE51bWJlckNoYW5nZTogdGhpcy5oYW5kbGVDaGFubmVsQ2hhbmdlLCBvbkNhbGNpdGVJbnB1dE51bWJlcklucHV0OiB0aGlzLmhhbmRsZUNoYW5uZWxJbnB1dCwgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleURvd24sIHNjYWxlOiB0aGlzLnNjYWxlID09PSBcImxcIiA/IFwibVwiIDogXCJzXCIsXG4gICAgICAgIC8vIHdvcmthcm91bmQgdG8gZW5zdXJlIGlucHV0IGJvcmRlcnMgb3ZlcmxhcCBhcyBkZXNpcmVkXG4gICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSB0aGUgYnVpbGQgdHJhbnNmb3JtcyBtYXJnaW4tbGVmdCB0byBpdHNcbiAgICAgICAgLy8gbG9naWNhbC1wcm9wLCB3aGljaCBpcyB1bmRlc2lyZWQgYXMgY2hhbm5lbHMgYXJlIGFsd2F5cyBsdHJcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBtYXJnaW5MZWZ0OiBpbmRleCA+IDAgJiYgISh0aGlzLnNjYWxlID09PSBcInNcIiAmJiB0aGlzLmFscGhhQ2hhbm5lbCAmJiBpbmRleCA9PT0gMykgPyBcIi0xcHhcIiA6IFwiXCIsXG4gICAgICAgIH0sIHN1ZmZpeFRleHQ6IHN1ZmZpeCwgdmFsdWU6IHZhbHVlPy50b1N0cmluZygpIH0pKTtcbiAgICB9O1xuICAgIHRoaXMuZGVsZXRlQ29sb3IgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjb2xvclRvRGVsZXRlID0gaGV4aWZ5KHRoaXMuY29sb3IsIHRoaXMuYWxwaGFDaGFubmVsKTtcbiAgICAgIGNvbnN0IGluU3RvcmFnZSA9IHRoaXMuc2F2ZWRDb2xvcnMuaW5kZXhPZihjb2xvclRvRGVsZXRlKSA+IC0xO1xuICAgICAgaWYgKCFpblN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2F2ZWRDb2xvcnMgPSB0aGlzLnNhdmVkQ29sb3JzLmZpbHRlcigoY29sb3IpID0+IGNvbG9yICE9PSBjb2xvclRvRGVsZXRlKTtcbiAgICAgIHRoaXMuc2F2ZWRDb2xvcnMgPSBzYXZlZENvbG9ycztcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBgJHtERUZBVUxUX1NUT1JBR0VfS0VZX1BSRUZJWH0ke3RoaXMuc3RvcmFnZUlkfWA7XG4gICAgICBpZiAodGhpcy5zdG9yYWdlSWQpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSwgSlNPTi5zdHJpbmdpZnkoc2F2ZWRDb2xvcnMpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2F2ZUNvbG9yID0gKCkgPT4ge1xuICAgICAgY29uc3QgY29sb3JUb1NhdmUgPSBoZXhpZnkodGhpcy5jb2xvciwgdGhpcy5hbHBoYUNoYW5uZWwpO1xuICAgICAgY29uc3QgYWxyZWFkeVNhdmVkID0gdGhpcy5zYXZlZENvbG9ycy5pbmRleE9mKGNvbG9yVG9TYXZlKSA+IC0xO1xuICAgICAgaWYgKGFscmVhZHlTYXZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzYXZlZENvbG9ycyA9IFsuLi50aGlzLnNhdmVkQ29sb3JzLCBjb2xvclRvU2F2ZV07XG4gICAgICB0aGlzLnNhdmVkQ29sb3JzID0gc2F2ZWRDb2xvcnM7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gYCR7REVGQVVMVF9TVE9SQUdFX0tFWV9QUkVGSVh9JHt0aGlzLnN0b3JhZ2VJZH1gO1xuICAgICAgaWYgKHRoaXMuc3RvcmFnZUlkKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KHNhdmVkQ29sb3JzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRyYXdDb2xvckNvbnRyb2xzID0gdGhyb3R0bGUoKHR5cGUgPSBcImFsbFwiKSA9PiB7XG4gICAgICBpZiAoKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJjb2xvci1maWVsZFwiKSAmJiB0aGlzLmNvbG9yRmllbGRSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZHJhd0NvbG9yRmllbGQoKTtcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImh1ZS1zbGlkZXJcIikgJiYgdGhpcy5odWVTbGlkZXJSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZHJhd0h1ZVNsaWRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYWxwaGFDaGFubmVsICYmXG4gICAgICAgICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwib3BhY2l0eS1zbGlkZXJcIikgJiZcbiAgICAgICAgdGhpcy5vcGFjaXR5U2xpZGVyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICB0aGlzLmRyYXdPcGFjaXR5U2xpZGVyKCk7XG4gICAgICB9XG4gICAgfSwgdGhyb3R0bGVGb3I2MEZwc0luTXMpO1xuICAgIHRoaXMuY2FwdHVyZUNvbG9yRmllbGRDb2xvciA9ICh4LCB5LCBza2lwRXF1YWwgPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCB7IGRpbWVuc2lvbnM6IHsgY29sb3JGaWVsZDogeyBoZWlnaHQsIHdpZHRoIH0sIH0sIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2F0dXJhdGlvbiA9IE1hdGgucm91bmQoKEhTVl9MSU1JVFMucyAvIHdpZHRoKSAqIHgpO1xuICAgICAgY29uc3QgdmFsdWUgPSBNYXRoLnJvdW5kKChIU1ZfTElNSVRTLnYgLyBoZWlnaHQpICogKGhlaWdodCAtIHkpKTtcbiAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldCh0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuaHN2KCkuc2F0dXJhdGlvbnYoc2F0dXJhdGlvbikudmFsdWUodmFsdWUpLCBza2lwRXF1YWwpO1xuICAgIH07XG4gICAgdGhpcy5pbml0Q29sb3JGaWVsZCA9IChjYW52YXMpID0+IHtcbiAgICAgIHRoaXMuY29sb3JGaWVsZFJlbmRlcmluZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgdGhpcy51cGRhdGVDYW52YXNTaXplKFwiY29sb3ItZmllbGRcIik7XG4gICAgICB0aGlzLmRyYXdDb2xvckNvbnRyb2xzKCk7XG4gICAgfTtcbiAgICB0aGlzLmluaXRIdWVTbGlkZXIgPSAoY2FudmFzKSA9PiB7XG4gICAgICB0aGlzLmh1ZVNsaWRlclJlbmRlcmluZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgdGhpcy51cGRhdGVDYW52YXNTaXplKFwiaHVlLXNsaWRlclwiKTtcbiAgICAgIHRoaXMuZHJhd0h1ZVNsaWRlcigpO1xuICAgIH07XG4gICAgdGhpcy5pbml0T3BhY2l0eVNsaWRlciA9IChjYW52YXMpID0+IHtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub3BhY2l0eVNsaWRlclJlbmRlcmluZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgdGhpcy51cGRhdGVDYW52YXNTaXplKFwib3BhY2l0eS1zbGlkZXJcIik7XG4gICAgICB0aGlzLmRyYXdPcGFjaXR5U2xpZGVyKCk7XG4gICAgfTtcbiAgICB0aGlzLnN0b3JlT3BhY2l0eVNjb3BlID0gKG5vZGUpID0+IHtcbiAgICAgIHRoaXMub3BhY2l0eVNjb3BlTm9kZSA9IG5vZGU7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZU9wYWNpdHlTY29wZUtleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IG1vZGlmaWVyID0gZXZlbnQuc2hpZnRLZXkgPyAxMCA6IDE7XG4gICAgICBjb25zdCB7IGtleSB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBhcnJvd0tleVRvWE9mZnNldCA9IHtcbiAgICAgICAgQXJyb3dVcDogMC4wMSxcbiAgICAgICAgQXJyb3dSaWdodDogMC4wMSxcbiAgICAgICAgQXJyb3dEb3duOiAtMC4wMSxcbiAgICAgICAgQXJyb3dMZWZ0OiAtMC4wMSxcbiAgICAgIH07XG4gICAgICBpZiAoYXJyb3dLZXlUb1hPZmZzZXRba2V5XSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGFycm93S2V5VG9YT2Zmc2V0W2tleV0gKiBtb2RpZmllcjtcbiAgICAgICAgY29uc3QgYWxwaGEgPSB0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuYWxwaGEoKTtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuYWxwaGEoYWxwaGEgKyBkZWx0YSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChjb2xvciwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hbGxvd0VtcHR5ID0gZmFsc2U7XG4gICAgdGhpcy5hbHBoYUNoYW5uZWwgPSBmYWxzZTtcbiAgICB0aGlzLmNoYW5uZWxzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbG9yID0gREVGQVVMVF9DT0xPUiQxO1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZvcm1hdCA9IFwiYXV0b1wiO1xuICAgIHRoaXMuaGlkZUNoYW5uZWxzID0gZmFsc2U7XG4gICAgdGhpcy5oZXhEaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuaGlkZUhleCA9IGZhbHNlO1xuICAgIHRoaXMuaGlkZVNhdmVkID0gZmFsc2U7XG4gICAgdGhpcy5zYXZlZERpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5zY2FsZSA9IFwibVwiO1xuICAgIHRoaXMuc3RvcmFnZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWVzc2FnZU92ZXJyaWRlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbHVlID0gbm9ybWFsaXplSGV4KGhleGlmeShERUZBVUxUX0NPTE9SJDEsIHRoaXMuYWxwaGFDaGFubmVsKSk7XG4gICAgdGhpcy5kZWZhdWx0TWVzc2FnZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFubmVsTW9kZSA9IFwicmdiXCI7XG4gICAgdGhpcy5jaGFubmVscyA9IHRoaXMudG9DaGFubmVscyhERUZBVUxUX0NPTE9SJDEpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IERJTUVOU0lPTlMubTtcbiAgICB0aGlzLmVmZmVjdGl2ZUxvY2FsZSA9IFwiXCI7XG4gICAgdGhpcy5tZXNzYWdlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNhdmVkQ29sb3JzID0gW107XG4gICAgdGhpcy5jb2xvckZpZWxkU2NvcGVUb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2xvckZpZWxkU2NvcGVMZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaHVlU2NvcGVMZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3BhY2l0eVNjb3BlTGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjb3BlT3JpZW50YXRpb24gPSB1bmRlZmluZWQ7XG4gIH1cbiAgaGFuZGxlQWxwaGFDaGFubmVsQ2hhbmdlKGFscGhhQ2hhbm5lbCkge1xuICAgIGNvbnN0IHsgZm9ybWF0IH0gPSB0aGlzO1xuICAgIGlmIChhbHBoYUNoYW5uZWwgJiYgZm9ybWF0ICE9PSBcImF1dG9cIiAmJiAhYWxwaGFDb21wYXRpYmxlKGZvcm1hdCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgaWdub3JpbmcgYWxwaGFDaGFubmVsIGFzIHRoZSBjdXJyZW50IGZvcm1hdCAoJHtmb3JtYXR9KSBkb2VzIG5vdCBzdXBwb3J0IGFscGhhYCk7XG4gICAgICB0aGlzLmFscGhhQ2hhbm5lbCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBoYW5kbGVDb2xvckNoYW5nZShjb2xvciwgb2xkQ29sb3IpIHtcbiAgICB0aGlzLmRyYXdDb2xvckNvbnRyb2xzKCk7XG4gICAgdGhpcy51cGRhdGVDaGFubmVsc0Zyb21Db2xvcihjb2xvcik7XG4gICAgdGhpcy5wcmV2aW91c0NvbG9yID0gb2xkQ29sb3I7XG4gIH1cbiAgaGFuZGxlRm9ybWF0T3JBbHBoYUNoYW5uZWxDaGFuZ2UoKSB7XG4gICAgdGhpcy5zZXRNb2RlKHRoaXMuZm9ybWF0KTtcbiAgICB0aGlzLmludGVybmFsQ29sb3JTZXQodGhpcy5jb2xvciwgZmFsc2UsIFwiaW50ZXJuYWxcIik7XG4gIH1cbiAgaGFuZGxlU2NhbGVDaGFuZ2Uoc2NhbGUgPSBcIm1cIikge1xuICAgIHRoaXMudXBkYXRlRGltZW5zaW9ucyhzY2FsZSk7XG4gICAgdGhpcy51cGRhdGVDYW52YXNTaXplKFwiYWxsXCIpO1xuICAgIHRoaXMuZHJhd0NvbG9yQ29udHJvbHMoKTtcbiAgfVxuICBvbk1lc3NhZ2VzQ2hhbmdlKCkge1xuICAgIC8qIHdpcmVkIHVwIGJ5IHQ5biB1dGlsICovXG4gIH1cbiAgaGFuZGxlVmFsdWVDaGFuZ2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgY29uc3QgeyBhbGxvd0VtcHR5LCBmb3JtYXQgfSA9IHRoaXM7XG4gICAgY29uc3QgY2hlY2tNb2RlID0gIWFsbG93RW1wdHkgfHwgdmFsdWU7XG4gICAgbGV0IG1vZGVDaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKGNoZWNrTW9kZSkge1xuICAgICAgY29uc3QgbmV4dE1vZGUgPSBwYXJzZU1vZGUodmFsdWUpO1xuICAgICAgaWYgKCFuZXh0TW9kZSB8fCAoZm9ybWF0ICE9PSBcImF1dG9cIiAmJiBuZXh0TW9kZSAhPT0gZm9ybWF0KSkge1xuICAgICAgICB0aGlzLnNob3dJbmNvbXBhdGlibGVDb2xvcldhcm5pbmcodmFsdWUsIGZvcm1hdCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBvbGRWYWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbW9kZUNoYW5nZWQgPSB0aGlzLm1vZGUgIT09IG5leHRNb2RlO1xuICAgICAgdGhpcy5zZXRNb2RlKG5leHRNb2RlLCB0aGlzLmludGVybmFsQ29sb3JVcGRhdGVDb250ZXh0ID09PSBudWxsKTtcbiAgICB9XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB0aGlzLmFjdGl2ZUNhbnZhc0luZm87XG4gICAgaWYgKHRoaXMuaW50ZXJuYWxDb2xvclVwZGF0ZUNvbnRleHQgPT09IFwiaW5pdGlhbFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmludGVybmFsQ29sb3JVcGRhdGVDb250ZXh0ID09PSBcInVzZXItaW50ZXJhY3Rpb25cIikge1xuICAgICAgdGhpcy5jYWxjaXRlQ29sb3JQaWNrZXJJbnB1dC5lbWl0KCk7XG4gICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgIHRoaXMuY2FsY2l0ZUNvbG9yUGlja2VyQ2hhbmdlLmVtaXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29sb3IkMSA9IGFsbG93RW1wdHkgJiYgIXZhbHVlXG4gICAgICA/IG51bGxcbiAgICAgIDogY29sb3IodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgYWxwaGFDb21wYXRpYmxlKHRoaXMubW9kZSlcbiAgICAgICAgPyBub3JtYWxpemVDb2xvcih2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZSk7XG4gICAgY29uc3QgY29sb3JDaGFuZ2VkID0gIWNvbG9yRXF1YWwoY29sb3IkMSwgdGhpcy5jb2xvcik7XG4gICAgaWYgKG1vZGVDaGFuZ2VkIHx8IGNvbG9yQ2hhbmdlZCkge1xuICAgICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KGNvbG9yJDEsIHRoaXMuYWxwaGFDaGFubmVsICYmICEodGhpcy5tb2RlLmVuZHNXaXRoKFwiYVwiKSB8fCB0aGlzLm1vZGUuZW5kc1dpdGgoXCJhLWNzc1wiKSksIFwiaW50ZXJuYWxcIik7XG4gICAgfVxuICB9XG4gIGdldCBiYXNlQ29sb3JGaWVsZENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yIHx8IHRoaXMucHJldmlvdXNDb2xvciB8fCBERUZBVUxUX0NPTE9SJDE7XG4gIH1cbiAgZWZmZWN0aXZlTG9jYWxlQ2hhbmdlKCkge1xuICAgIHVwZGF0ZU1lc3NhZ2VzKHRoaXMsIHRoaXMuZWZmZWN0aXZlTG9jYWxlKTtcbiAgfVxuICAvLyB1c2luZyBATGlzdGVuIGFzIGEgd29ya2Fyb3VuZCBmb3IgVkRPTSBsaXN0ZW5lciBub3QgZmlyaW5nXG4gIGhhbmRsZUNoYW5uZWxLZXlVcE9yRG93bihldmVudCkge1xuICAgIHRoaXMuc2hpZnRLZXlDaGFubmVsQWRqdXN0bWVudCA9IDA7XG4gICAgY29uc3QgeyBrZXkgfSA9IGV2ZW50O1xuICAgIGlmICgoa2V5ICE9PSBcIkFycm93VXBcIiAmJiBrZXkgIT09IFwiQXJyb3dEb3duXCIpIHx8XG4gICAgICAhZXZlbnQuY29tcG9zZWRQYXRoKCkuc29tZSgobm9kZSkgPT4gbm9kZS5jbGFzc0xpc3Q/LmNvbnRhaW5zKENTUyQyLmNoYW5uZWwpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHNoaWZ0S2V5IH0gPSBldmVudDtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghdGhpcy5jb2xvcikge1xuICAgICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KHRoaXMucHJldmlvdXNDb2xvcik7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdGhpcyBnZXRzIGFwcGxpZWQgdG8gdGhlIGlucHV0J3MgdXAvZG93biBhcnJvdyBpbmNyZW1lbnQvZGVjcmVtZW50XG4gICAgY29uc3QgY29tcGxlbWVudGFyeUJ1bXAgPSA5O1xuICAgIHRoaXMuc2hpZnRLZXlDaGFubmVsQWRqdXN0bWVudCA9XG4gICAgICBrZXkgPT09IFwiQXJyb3dVcFwiICYmIHNoaWZ0S2V5XG4gICAgICAgID8gY29tcGxlbWVudGFyeUJ1bXBcbiAgICAgICAgOiBrZXkgPT09IFwiQXJyb3dEb3duXCIgJiYgc2hpZnRLZXlcbiAgICAgICAgICA/IC1jb21wbGVtZW50YXJ5QnVtcFxuICAgICAgICAgIDogMDtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBQdWJsaWMgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKiBTZXRzIGZvY3VzIG9uIHRoZSBjb21wb25lbnQncyBmaXJzdCBmb2N1c2FibGUgZWxlbWVudC4gKi9cbiAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgYXdhaXQgY29tcG9uZW50Rm9jdXNhYmxlKHRoaXMpO1xuICAgIHRoaXMuZWwuZm9jdXMoKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBMaWZlY3ljbGVcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBzZXRVcExvYWRhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIGNvbnN0IHsgYWxsb3dFbXB0eSwgY29sb3I6IGNvbG9yJDEsIGZvcm1hdCwgdmFsdWUgfSA9IHRoaXM7XG4gICAgY29uc3Qgd2lsbFNldE5vQ29sb3IgPSBhbGxvd0VtcHR5ICYmICF2YWx1ZTtcbiAgICBjb25zdCBwYXJzZWRNb2RlID0gcGFyc2VNb2RlKHZhbHVlKTtcbiAgICBjb25zdCB2YWx1ZUlzQ29tcGF0aWJsZSA9IHdpbGxTZXROb0NvbG9yIHx8IChmb3JtYXQgPT09IFwiYXV0b1wiICYmIHBhcnNlZE1vZGUpIHx8IGZvcm1hdCA9PT0gcGFyc2VkTW9kZTtcbiAgICBjb25zdCBpbml0aWFsQ29sb3IgPSB3aWxsU2V0Tm9Db2xvciA/IG51bGwgOiB2YWx1ZUlzQ29tcGF0aWJsZSA/IGNvbG9yKHZhbHVlKSA6IGNvbG9yJDE7XG4gICAgaWYgKCF2YWx1ZUlzQ29tcGF0aWJsZSkge1xuICAgICAgdGhpcy5zaG93SW5jb21wYXRpYmxlQ29sb3JXYXJuaW5nKHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbiAgICB0aGlzLnNldE1vZGUoZm9ybWF0LCBmYWxzZSk7XG4gICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KGluaXRpYWxDb2xvciwgZmFsc2UsIFwiaW5pdGlhbFwiKTtcbiAgICB0aGlzLnVwZGF0ZURpbWVuc2lvbnModGhpcy5zY2FsZSk7XG4gICAgY29uc3Qgc3RvcmFnZUtleSA9IGAke0RFRkFVTFRfU1RPUkFHRV9LRVlfUFJFRklYfSR7dGhpcy5zdG9yYWdlSWR9YDtcbiAgICBpZiAodGhpcy5zdG9yYWdlSWQgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSkpIHtcbiAgICAgIHRoaXMuc2F2ZWRDb2xvcnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpKTtcbiAgICB9XG4gICAgYXdhaXQgc2V0VXBNZXNzYWdlcyh0aGlzKTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb25uZWN0SW50ZXJhY3RpdmUodGhpcyk7XG4gICAgY29ubmVjdExvY2FsaXplZCh0aGlzKTtcbiAgICBjb25uZWN0TWVzc2FnZXModGhpcyk7XG4gIH1cbiAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICBzZXRDb21wb25lbnRMb2FkZWQodGhpcyk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLmdsb2JhbFBvaW50ZXJNb3ZlSGFuZGxlcik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5nbG9iYWxQb2ludGVyVXBIYW5kbGVyKTtcbiAgICBkaXNjb25uZWN0SW50ZXJhY3RpdmUodGhpcyk7XG4gICAgZGlzY29ubmVjdExvY2FsaXplZCh0aGlzKTtcbiAgICBkaXNjb25uZWN0TWVzc2FnZXModGhpcyk7XG4gIH1cbiAgY29tcG9uZW50RGlkUmVuZGVyKCkge1xuICAgIHVwZGF0ZUhvc3RJbnRlcmFjdGlvbih0aGlzKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBSZW5kZXIgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGFsbG93RW1wdHksIGNoYW5uZWxzRGlzYWJsZWQsIGNvbG9yLCBjb2xvckZpZWxkU2NvcGVMZWZ0LCBjb2xvckZpZWxkU2NvcGVUb3AsIGRpbWVuc2lvbnM6IHsgc2xpZGVyOiB7IHdpZHRoOiBzbGlkZXJXaWR0aCB9LCB0aHVtYjogeyByYWRpdXM6IHRodW1iUmFkaXVzIH0sIH0sIGhleERpc2FibGVkLCBoaWRlQ2hhbm5lbHMsIGhpZGVIZXgsIGhpZGVTYXZlZCwgaHVlU2NvcGVMZWZ0LCBtZXNzYWdlcywgYWxwaGFDaGFubmVsLCBvcGFjaXR5U2NvcGVMZWZ0LCBzYXZlZENvbG9ycywgc2F2ZWREaXNhYmxlZCwgc2NhbGUsIHNjb3BlT3JpZW50YXRpb24sIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlbGVjdGVkQ29sb3JJbkhleCA9IGNvbG9yID8gaGV4aWZ5KGNvbG9yLCBhbHBoYUNoYW5uZWwpIDogbnVsbDtcbiAgICBjb25zdCBodWVUb3AgPSB0aHVtYlJhZGl1cztcbiAgICBjb25zdCBodWVMZWZ0ID0gaHVlU2NvcGVMZWZ0ID8/IChzbGlkZXJXaWR0aCAqIERFRkFVTFRfQ09MT1IkMS5odWUoKSkgLyBIU1ZfTElNSVRTLmg7XG4gICAgY29uc3Qgb3BhY2l0eVRvcCA9IHRodW1iUmFkaXVzO1xuICAgIGNvbnN0IG9wYWNpdHlMZWZ0ID0gb3BhY2l0eVNjb3BlTGVmdCA/P1xuICAgICAgKHNsaWRlcldpZHRoICogYWxwaGFUb09wYWNpdHkoREVGQVVMVF9DT0xPUiQxLmFscGhhKCkpKSAvIE9QQUNJVFlfTElNSVRTLm1heDtcbiAgICBjb25zdCBub0NvbG9yID0gY29sb3IgPT09IG51bGw7XG4gICAgY29uc3QgdmVydGljYWwgPSBzY29wZU9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCI7XG4gICAgY29uc3Qgbm9IZXggPSBoZXhEaXNhYmxlZCB8fCBoaWRlSGV4O1xuICAgIGNvbnN0IG5vQ2hhbm5lbHMgPSBjaGFubmVsc0Rpc2FibGVkIHx8IGhpZGVDaGFubmVscztcbiAgICBjb25zdCBub1NhdmVkID0gc2F2ZWREaXNhYmxlZCB8fCBoaWRlU2F2ZWQ7XG4gICAgY29uc3QgW2FkanVzdGVkQ29sb3JGaWVsZFNjb3BlTGVmdCwgYWRqdXN0ZWRDb2xvckZpZWxkU2NvcGVUb3BdID0gdGhpcy5nZXRBZGp1c3RlZFNjb3BlUG9zaXRpb24oY29sb3JGaWVsZFNjb3BlTGVmdCwgY29sb3JGaWVsZFNjb3BlVG9wKTtcbiAgICBjb25zdCBbYWRqdXN0ZWRIdWVTY29wZUxlZnQsIGFkanVzdGVkSHVlU2NvcGVUb3BdID0gdGhpcy5nZXRBZGp1c3RlZFNjb3BlUG9zaXRpb24oaHVlTGVmdCwgaHVlVG9wKTtcbiAgICBjb25zdCBbYWRqdXN0ZWRPcGFjaXR5U2NvcGVMZWZ0LCBhZGp1c3RlZE9wYWNpdHlTY29wZVRvcF0gPSB0aGlzLmdldEFkanVzdGVkU2NvcGVQb3NpdGlvbihvcGFjaXR5TGVmdCwgb3BhY2l0eVRvcCk7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQyLmNvbnRhaW5lciB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQyLmNvbnRyb2xBbmRTY29wZSB9LCBoKFwiY2FudmFzXCIsIHsgY2xhc3M6IENTUyQyLmNvbG9yRmllbGQsIG9uUG9pbnRlckRvd246IHRoaXMuaGFuZGxlQ29sb3JGaWVsZFBvaW50ZXJEb3duLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1zb3J0LXByb3BzIC0tIHJlZiBzaG91bGQgYmUgbGFzdCBzbyBub2RlIGF0dHJzL3Byb3BzIGFyZSBpbiBzeW5jIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL3B1bGwvNjUzMClcbiAgICAgIHJlZjogdGhpcy5pbml0Q29sb3JGaWVsZCB9KSwgaChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbFwiOiB2ZXJ0aWNhbCA/IG1lc3NhZ2VzLnZhbHVlIDogbWVzc2FnZXMuc2F0dXJhdGlvbiwgXCJhcmlhLXZhbHVlbWF4XCI6IHZlcnRpY2FsID8gSFNWX0xJTUlUUy52IDogSFNWX0xJTUlUUy5zLCBcImFyaWEtdmFsdWVtaW5cIjogXCIwXCIsIFwiYXJpYS12YWx1ZW5vd1wiOiAodmVydGljYWwgPyBjb2xvcj8uc2F0dXJhdGlvbnYoKSA6IGNvbG9yPy52YWx1ZSgpKSB8fCBcIjBcIiwgY2xhc3M6IHsgW0NTUyQyLnNjb3BlXTogdHJ1ZSwgW0NTUyQyLmNvbG9yRmllbGRTY29wZV06IHRydWUgfSwgb25LZXlEb3duOiB0aGlzLmhhbmRsZUNvbG9yRmllbGRTY29wZUtleURvd24sIHJvbGU6IFwic2xpZGVyXCIsIHN0eWxlOiB7XG4gICAgICAgIHRvcDogYCR7YWRqdXN0ZWRDb2xvckZpZWxkU2NvcGVUb3AgfHwgMH1weGAsXG4gICAgICAgIGxlZnQ6IGAke2FkanVzdGVkQ29sb3JGaWVsZFNjb3BlTGVmdCB8fCAwfXB4YCxcbiAgICAgIH0sIHRhYmluZGV4OiBcIjBcIixcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtc29ydC1wcm9wcyAtLSByZWYgc2hvdWxkIGJlIGxhc3Qgc28gbm9kZSBhdHRycy9wcm9wcyBhcmUgaW4gc3luYyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9wdWxsLzY1MzApXG4gICAgICByZWY6IHRoaXMuc3RvcmVDb2xvckZpZWxkU2NvcGUgfSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQyLnByZXZpZXdBbmRTbGlkZXJzIH0sIGgoXCJjYWxjaXRlLWNvbG9yLXBpY2tlci1zd2F0Y2hcIiwgeyBjbGFzczogQ1NTJDIucHJldmlldywgY29sb3I6IHNlbGVjdGVkQ29sb3JJbkhleCwgc2NhbGU6IFwibFwiIH0pLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQyLnNsaWRlcnMgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMi5jb250cm9sQW5kU2NvcGUgfSwgaChcImNhbnZhc1wiLCB7IGNsYXNzOiB7IFtDU1MkMi5zbGlkZXJdOiB0cnVlLCBbQ1NTJDIuaHVlU2xpZGVyXTogdHJ1ZSB9LCBvblBvaW50ZXJEb3duOiB0aGlzLmhhbmRsZUh1ZVNsaWRlclBvaW50ZXJEb3duLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1zb3J0LXByb3BzIC0tIHJlZiBzaG91bGQgYmUgbGFzdCBzbyBub2RlIGF0dHJzL3Byb3BzIGFyZSBpbiBzeW5jIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL3B1bGwvNjUzMClcbiAgICAgIHJlZjogdGhpcy5pbml0SHVlU2xpZGVyIH0pLCBoKFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsXCI6IG1lc3NhZ2VzLmh1ZSwgXCJhcmlhLXZhbHVlbWF4XCI6IEhTVl9MSU1JVFMuaCwgXCJhcmlhLXZhbHVlbWluXCI6IFwiMFwiLCBcImFyaWEtdmFsdWVub3dcIjogY29sb3I/LnJvdW5kKCkuaHVlKCkgfHwgREVGQVVMVF9DT0xPUiQxLnJvdW5kKCkuaHVlKCksIGNsYXNzOiB7IFtDU1MkMi5zY29wZV06IHRydWUsIFtDU1MkMi5odWVTY29wZV06IHRydWUgfSwgb25LZXlEb3duOiB0aGlzLmhhbmRsZUh1ZVNjb3BlS2V5RG93biwgcm9sZTogXCJzbGlkZXJcIiwgc3R5bGU6IHtcbiAgICAgICAgdG9wOiBgJHthZGp1c3RlZEh1ZVNjb3BlVG9wfXB4YCxcbiAgICAgICAgbGVmdDogYCR7YWRqdXN0ZWRIdWVTY29wZUxlZnR9cHhgLFxuICAgICAgfSwgdGFiaW5kZXg6IFwiMFwiLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1zb3J0LXByb3BzIC0tIHJlZiBzaG91bGQgYmUgbGFzdCBzbyBub2RlIGF0dHJzL3Byb3BzIGFyZSBpbiBzeW5jIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL3B1bGwvNjUzMClcbiAgICAgIHJlZjogdGhpcy5zdG9yZUh1ZVNjb3BlIH0pKSwgYWxwaGFDaGFubmVsID8gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDIuY29udHJvbEFuZFNjb3BlIH0sIGgoXCJjYW52YXNcIiwgeyBjbGFzczogeyBbQ1NTJDIuc2xpZGVyXTogdHJ1ZSwgW0NTUyQyLm9wYWNpdHlTbGlkZXJdOiB0cnVlIH0sIG9uUG9pbnRlckRvd246IHRoaXMuaGFuZGxlT3BhY2l0eVNsaWRlclBvaW50ZXJEb3duLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1zb3J0LXByb3BzIC0tIHJlZiBzaG91bGQgYmUgbGFzdCBzbyBub2RlIGF0dHJzL3Byb3BzIGFyZSBpbiBzeW5jIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL3B1bGwvNjUzMClcbiAgICAgIHJlZjogdGhpcy5pbml0T3BhY2l0eVNsaWRlciB9KSwgaChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbFwiOiBtZXNzYWdlcy5vcGFjaXR5LCBcImFyaWEtdmFsdWVtYXhcIjogT1BBQ0lUWV9MSU1JVFMubWF4LCBcImFyaWEtdmFsdWVtaW5cIjogT1BBQ0lUWV9MSU1JVFMubWluLCBcImFyaWEtdmFsdWVub3dcIjogKGNvbG9yIHx8IERFRkFVTFRfQ09MT1IkMSkucm91bmQoKS5hbHBoYSgpLCBjbGFzczogeyBbQ1NTJDIuc2NvcGVdOiB0cnVlLCBbQ1NTJDIub3BhY2l0eVNjb3BlXTogdHJ1ZSB9LCBvbktleURvd246IHRoaXMuaGFuZGxlT3BhY2l0eVNjb3BlS2V5RG93biwgcm9sZTogXCJzbGlkZXJcIiwgc3R5bGU6IHtcbiAgICAgICAgdG9wOiBgJHthZGp1c3RlZE9wYWNpdHlTY29wZVRvcH1weGAsXG4gICAgICAgIGxlZnQ6IGAke2FkanVzdGVkT3BhY2l0eVNjb3BlTGVmdH1weGAsXG4gICAgICB9LCB0YWJpbmRleDogXCIwXCIsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LXNvcnQtcHJvcHMgLS0gcmVmIHNob3VsZCBiZSBsYXN0IHNvIG5vZGUgYXR0cnMvcHJvcHMgYXJlIGluIHN5bmMgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vcHVsbC82NTMwKVxuICAgICAgcmVmOiB0aGlzLnN0b3JlT3BhY2l0eVNjb3BlIH0pKSkgOiBudWxsKSksIG5vSGV4ICYmIG5vQ2hhbm5lbHMgPyBudWxsIDogKGgoXCJkaXZcIiwgeyBjbGFzczoge1xuICAgICAgICBbQ1NTJDIuY29udHJvbFNlY3Rpb25dOiB0cnVlLFxuICAgICAgICBbQ1NTJDIuc2VjdGlvbl06IHRydWUsXG4gICAgICB9IH0sIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDIuaGV4QW5kQ2hhbm5lbHNHcm91cCB9LCBub0hleCA/IG51bGwgOiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMi5oZXhPcHRpb25zIH0sIGgoXCJjYWxjaXRlLWNvbG9yLXBpY2tlci1oZXgtaW5wdXRcIiwgeyBhbGxvd0VtcHR5OiBhbGxvd0VtcHR5LCBhbHBoYUNoYW5uZWw6IGFscGhhQ2hhbm5lbCwgY2xhc3M6IENTUyQyLmNvbnRyb2wsIG1lc3NhZ2VzOiBtZXNzYWdlcywgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLm51bWJlcmluZ1N5c3RlbSwgb25DYWxjaXRlQ29sb3JQaWNrZXJIZXhJbnB1dENoYW5nZTogdGhpcy5oYW5kbGVIZXhJbnB1dENoYW5nZSwgc2NhbGU6IHNjYWxlLCB2YWx1ZTogc2VsZWN0ZWRDb2xvckluSGV4IH0pKSksIG5vQ2hhbm5lbHMgPyBudWxsIDogKGgoXCJjYWxjaXRlLXRhYnNcIiwgeyBjbGFzczoge1xuICAgICAgICBbQ1NTJDIuY29sb3JNb2RlQ29udGFpbmVyXTogdHJ1ZSxcbiAgICAgICAgW0NTUyQyLnNwbGl0U2VjdGlvbl06IHRydWUsXG4gICAgICB9LCBzY2FsZTogc2NhbGUgPT09IFwibFwiID8gXCJtXCIgOiBcInNcIiB9LCBoKFwiY2FsY2l0ZS10YWItbmF2XCIsIHsgc2xvdDogXCJ0aXRsZS1ncm91cFwiIH0sIHRoaXMucmVuZGVyQ2hhbm5lbHNUYWJUaXRsZShcInJnYlwiKSwgdGhpcy5yZW5kZXJDaGFubmVsc1RhYlRpdGxlKFwiaHN2XCIpKSwgdGhpcy5yZW5kZXJDaGFubmVsc1RhYihcInJnYlwiKSwgdGhpcy5yZW5kZXJDaGFubmVsc1RhYihcImhzdlwiKSkpKSkpLCBub1NhdmVkID8gbnVsbCA6IChoKFwiZGl2XCIsIHsgY2xhc3M6IHsgW0NTUyQyLnNhdmVkQ29sb3JzU2VjdGlvbl06IHRydWUsIFtDU1MkMi5zZWN0aW9uXTogdHJ1ZSB9IH0sIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDIuaGVhZGVyIH0sIGgoXCJsYWJlbFwiLCBudWxsLCBtZXNzYWdlcy5zYXZlZCksIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDIuc2F2ZWRDb2xvcnNCdXR0b25zIH0sIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgY2xhc3M6IENTUyQyLmRlbGV0ZUNvbG9yLCBkaXNhYmxlZDogbm9Db2xvciwgaWNvblN0YXJ0OiBcIm1pbnVzXCIsIGtpbmQ6IFwibmV1dHJhbFwiLCBsYWJlbDogbWVzc2FnZXMuZGVsZXRlQ29sb3IsIG9uQ2xpY2s6IHRoaXMuZGVsZXRlQ29sb3IsIHNjYWxlOiBzY2FsZSwgdHlwZTogXCJidXR0b25cIiB9KSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCBjbGFzczogQ1NTJDIuc2F2ZUNvbG9yLCBkaXNhYmxlZDogbm9Db2xvciwgaWNvblN0YXJ0OiBcInBsdXNcIiwga2luZDogXCJuZXV0cmFsXCIsIGxhYmVsOiBtZXNzYWdlcy5zYXZlQ29sb3IsIG9uQ2xpY2s6IHRoaXMuc2F2ZUNvbG9yLCBzY2FsZTogc2NhbGUsIHR5cGU6IFwiYnV0dG9uXCIgfSkpKSwgc2F2ZWRDb2xvcnMubGVuZ3RoID4gMCA/IChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQyLnNhdmVkQ29sb3JzIH0sIFtcbiAgICAgIC4uLnNhdmVkQ29sb3JzLm1hcCgoY29sb3IpID0+IChoKFwiY2FsY2l0ZS1jb2xvci1waWNrZXItc3dhdGNoXCIsIHsgY2xhc3M6IENTUyQyLnNhdmVkQ29sb3IsIGNvbG9yOiBjb2xvciwga2V5OiBjb2xvciwgb25DbGljazogdGhpcy5oYW5kbGVTYXZlZENvbG9yU2VsZWN0LCBvbktleURvd246IHRoaXMuaGFuZGxlU2F2ZWRDb2xvcktleURvd24sIHNjYWxlOiBzY2FsZSwgdGFiSW5kZXg6IDAgfSkpKSxcbiAgICBdKSkgOiBudWxsKSkpKTtcbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHJpdmF0ZSBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgc2hvd0luY29tcGF0aWJsZUNvbG9yV2FybmluZyh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgY29uc29sZS53YXJuKGBpZ25vcmluZyBjb2xvciB2YWx1ZSAoJHt2YWx1ZX0pIGFzIGl0IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgZm9ybWF0ICgke2Zvcm1hdH0pYCk7XG4gIH1cbiAgc2V0TW9kZShmb3JtYXQsIHdhcm4gPSB0cnVlKSB7XG4gICAgY29uc3QgbW9kZSA9IGZvcm1hdCA9PT0gXCJhdXRvXCIgPyB0aGlzLm1vZGUgOiBmb3JtYXQ7XG4gICAgdGhpcy5tb2RlID0gdGhpcy5lbnN1cmVDb21wYXRpYmxlTW9kZShtb2RlLCB3YXJuKTtcbiAgfVxuICBlbnN1cmVDb21wYXRpYmxlTW9kZShtb2RlLCB3YXJuKSB7XG4gICAgY29uc3QgeyBhbHBoYUNoYW5uZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgaXNBbHBoYUNvbXBhdGlibGUgPSBhbHBoYUNvbXBhdGlibGUobW9kZSk7XG4gICAgaWYgKGFscGhhQ2hhbm5lbCAmJiAhaXNBbHBoYUNvbXBhdGlibGUpIHtcbiAgICAgIGNvbnN0IGFscGhhTW9kZSA9IHRvQWxwaGFNb2RlKG1vZGUpO1xuICAgICAgaWYgKHdhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBzZXR0aW5nIGZvcm1hdCB0byAoJHthbHBoYU1vZGV9KSBhcyB0aGUgcHJvdmlkZWQgb25lICgke21vZGV9KSBkb2VzIG5vdCBzdXBwb3J0IGFscGhhYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxwaGFNb2RlO1xuICAgIH1cbiAgICBpZiAoIWFscGhhQ2hhbm5lbCAmJiBpc0FscGhhQ29tcGF0aWJsZSkge1xuICAgICAgY29uc3Qgbm9uQWxwaGFNb2RlID0gdG9Ob25BbHBoYU1vZGUobW9kZSk7XG4gICAgICBpZiAod2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oYHNldHRpbmcgZm9ybWF0IHRvICgke25vbkFscGhhTW9kZX0pIGFzIHRoZSBwcm92aWRlZCBvbmUgKCR7bW9kZX0pIGRvZXMgbm90IHN1cHBvcnQgYWxwaGFgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub25BbHBoYU1vZGU7XG4gICAgfVxuICAgIHJldHVybiBtb2RlO1xuICB9XG4gIGNhcHR1cmVIdWVTbGlkZXJDb2xvcih4KSB7XG4gICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IHNsaWRlcjogeyB3aWR0aCB9LCB9LCB9ID0gdGhpcztcbiAgICBjb25zdCBodWUgPSAoSFVFX0xJTUlUX0NPTlNUUkFJTkVEIC8gd2lkdGgpICogeDtcbiAgICB0aGlzLmludGVybmFsQ29sb3JTZXQodGhpcy5iYXNlQ29sb3JGaWVsZENvbG9yLmh1ZShodWUpLCBmYWxzZSk7XG4gIH1cbiAgY2FwdHVyZU9wYWNpdHlTbGlkZXJWYWx1ZSh4KSB7XG4gICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IHNsaWRlcjogeyB3aWR0aCB9LCB9LCB9ID0gdGhpcztcbiAgICBjb25zdCBhbHBoYSA9IG9wYWNpdHlUb0FscGhhKChPUEFDSVRZX0xJTUlUUy5tYXggLyB3aWR0aCkgKiB4KTtcbiAgICB0aGlzLmludGVybmFsQ29sb3JTZXQodGhpcy5iYXNlQ29sb3JGaWVsZENvbG9yLmFscGhhKGFscGhhKSwgZmFsc2UpO1xuICB9XG4gIGludGVybmFsQ29sb3JTZXQoY29sb3IsIHNraXBFcXVhbCA9IHRydWUsIGNvbnRleHQgPSBcInVzZXItaW50ZXJhY3Rpb25cIikge1xuICAgIGlmIChza2lwRXF1YWwgJiYgY29sb3JFcXVhbChjb2xvciwgdGhpcy5jb2xvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnRlcm5hbENvbG9yVXBkYXRlQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLnRvVmFsdWUoY29sb3IpO1xuICAgIHRoaXMuaW50ZXJuYWxDb2xvclVwZGF0ZUNvbnRleHQgPSBudWxsO1xuICB9XG4gIHRvVmFsdWUoY29sb3IsIGZvcm1hdCA9IHRoaXMubW9kZSkge1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBoZXhNb2RlID0gXCJoZXhcIjtcbiAgICBpZiAoZm9ybWF0LmluY2x1ZGVzKGhleE1vZGUpKSB7XG4gICAgICBjb25zdCBoYXNBbHBoYSA9IGZvcm1hdCA9PT0gQ1NTQ29sb3JNb2RlLkhFWEE7XG4gICAgICByZXR1cm4gbm9ybWFsaXplSGV4KGhleGlmeShjb2xvci5yb3VuZCgpLCBoYXNBbHBoYSksIGhhc0FscGhhKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdC5pbmNsdWRlcyhcIi1jc3NcIikpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY29sb3JbZm9ybWF0LnJlcGxhY2UoXCItY3NzXCIsIFwiXCIpLnJlcGxhY2UoXCJhXCIsIFwiXCIpXSgpLnJvdW5kKCkuc3RyaW5nKCk7XG4gICAgICAvLyBDb2xvciBvbWl0cyBhbHBoYSB2YWx1ZXMgd2hlbiBhbHBoYSBpcyAxXG4gICAgICBjb25zdCBuZWVkVG9JbmplY3RBbHBoYSA9IChmb3JtYXQuZW5kc1dpdGgoXCJhXCIpIHx8IGZvcm1hdC5lbmRzV2l0aChcImEtY3NzXCIpKSAmJiBjb2xvci5hbHBoYSgpID09PSAxO1xuICAgICAgaWYgKG5lZWRUb0luamVjdEFscGhhKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdmFsdWUuc2xpY2UoMCwgMyk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHZhbHVlLnNsaWNlKDQsIC0xKTtcbiAgICAgICAgcmV0dXJuIGAke21vZGVsfWEoJHt2YWx1ZXN9LCAke2NvbG9yLmFscGhhKCl9KWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yT2JqZWN0ID0gXG4gICAgLyogQ29sb3IoKSBkb2VzIG5vdCBzdXBwb3J0IGhzdmEsIGhzbGEgbm9yIHJnYmEsIHNvIHdlIHVzZSB0aGUgbm9uLWFscGhhIG1vZGUgKi9cbiAgICBjb2xvclt0b05vbkFscGhhTW9kZShmb3JtYXQpXSgpLnJvdW5kKCkub2JqZWN0KCk7XG4gICAgaWYgKGZvcm1hdC5lbmRzV2l0aChcImFcIikpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVBbHBoYShjb2xvck9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBjb2xvck9iamVjdDtcbiAgfVxuICBnZXRTbGlkZXJDYXBTcGFjaW5nKCkge1xuICAgIGNvbnN0IHsgZGltZW5zaW9uczogeyBzbGlkZXI6IHsgaGVpZ2h0IH0sIHRodW1iOiB7IHJhZGl1cyB9LCB9LCB9ID0gdGhpcztcbiAgICByZXR1cm4gcmFkaXVzICogMiAtIGhlaWdodDtcbiAgfVxuICB1cGRhdGVEaW1lbnNpb25zKHNjYWxlID0gXCJtXCIpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBESU1FTlNJT05TW3NjYWxlXTtcbiAgfVxuICBkcmF3Q29sb3JGaWVsZCgpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb2xvckZpZWxkUmVuZGVyaW5nQ29udGV4dDtcbiAgICBjb25zdCB7IGRpbWVuc2lvbnM6IHsgY29sb3JGaWVsZDogeyBoZWlnaHQsIHdpZHRoIH0sIH0sIH0gPSB0aGlzO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5iYXNlQ29sb3JGaWVsZENvbG9yXG4gICAgICAuaHN2KClcbiAgICAgIC5zYXR1cmF0aW9udigxMDApXG4gICAgICAudmFsdWUoMTAwKVxuICAgICAgLmFscGhhKDEpXG4gICAgICAuc3RyaW5nKCk7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB3aGl0ZUdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgd2hpdGVHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCJyZ2JhKDI1NSwyNTUsMjU1LDEpXCIpO1xuICAgIHdoaXRlR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFwicmdiYSgyNTUsMjU1LDI1NSwwKVwiKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHdoaXRlR3JhZGllbnQ7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBibGFja0dyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBoZWlnaHQpO1xuICAgIGJsYWNrR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgICBibGFja0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBcInJnYmEoMCwwLDAsMSlcIik7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBibGFja0dyYWRpZW50O1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kcmF3QWN0aXZlQ29sb3JGaWVsZENvbG9yKCk7XG4gIH1cbiAgc2V0Q2FudmFzQ29udGV4dFNpemUoY2FudmFzLCB7IGhlaWdodCwgd2lkdGggfSkge1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZGV2aWNlUGl4ZWxSYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpbztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY29udGV4dC5zY2FsZShkZXZpY2VQaXhlbFJhdGlvLCBkZXZpY2VQaXhlbFJhdGlvKTtcbiAgfVxuICB1cGRhdGVDYW52YXNTaXplKGNvbnRleHQgPSBcImFsbFwiKSB7XG4gICAgY29uc3QgeyBkaW1lbnNpb25zIH0gPSB0aGlzO1xuICAgIGlmIChjb250ZXh0ID09PSBcImFsbFwiIHx8IGNvbnRleHQgPT09IFwiY29sb3ItZmllbGRcIikge1xuICAgICAgdGhpcy5zZXRDYW52YXNDb250ZXh0U2l6ZSh0aGlzLmNvbG9yRmllbGRSZW5kZXJpbmdDb250ZXh0Py5jYW52YXMsIGRpbWVuc2lvbnMuY29sb3JGaWVsZCk7XG4gICAgfVxuICAgIGNvbnN0IGFkanVzdGVkU2xpZGVyRGltZW5zaW9ucyA9IHtcbiAgICAgIHdpZHRoOiBkaW1lbnNpb25zLnNsaWRlci53aWR0aCxcbiAgICAgIGhlaWdodDogZGltZW5zaW9ucy5zbGlkZXIuaGVpZ2h0ICsgKGRpbWVuc2lvbnMudGh1bWIucmFkaXVzIC0gZGltZW5zaW9ucy5zbGlkZXIuaGVpZ2h0IC8gMikgKiAyLFxuICAgIH07XG4gICAgaWYgKGNvbnRleHQgPT09IFwiYWxsXCIgfHwgY29udGV4dCA9PT0gXCJodWUtc2xpZGVyXCIpIHtcbiAgICAgIHRoaXMuc2V0Q2FudmFzQ29udGV4dFNpemUodGhpcy5odWVTbGlkZXJSZW5kZXJpbmdDb250ZXh0Py5jYW52YXMsIGFkanVzdGVkU2xpZGVyRGltZW5zaW9ucyk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09PSBcImFsbFwiIHx8IGNvbnRleHQgPT09IFwib3BhY2l0eS1zbGlkZXJcIikge1xuICAgICAgdGhpcy5zZXRDYW52YXNDb250ZXh0U2l6ZSh0aGlzLm9wYWNpdHlTbGlkZXJSZW5kZXJpbmdDb250ZXh0Py5jYW52YXMsIGFkanVzdGVkU2xpZGVyRGltZW5zaW9ucyk7XG4gICAgfVxuICB9XG4gIGRyYXdBY3RpdmVDb2xvckZpZWxkQ29sb3IoKSB7XG4gICAgY29uc3QgeyBjb2xvciB9ID0gdGhpcztcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhzdkNvbG9yID0gY29sb3IuaHN2KCk7XG4gICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IGNvbG9yRmllbGQ6IHsgaGVpZ2h0LCB3aWR0aCB9LCB0aHVtYjogeyByYWRpdXMgfSwgfSwgfSA9IHRoaXM7XG4gICAgY29uc3QgeCA9IGhzdkNvbG9yLnNhdHVyYXRpb252KCkgLyAoSFNWX0xJTUlUUy5zIC8gd2lkdGgpO1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgLSBoc3ZDb2xvci52YWx1ZSgpIC8gKEhTVl9MSU1JVFMudiAvIGhlaWdodCk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuY29sb3JGaWVsZFNjb3BlTGVmdCA9IHg7XG4gICAgICB0aGlzLmNvbG9yRmllbGRTY29wZVRvcCA9IHk7XG4gICAgfSk7XG4gICAgdGhpcy5kcmF3VGh1bWIodGhpcy5jb2xvckZpZWxkUmVuZGVyaW5nQ29udGV4dCwgcmFkaXVzLCB4LCB5LCBoc3ZDb2xvcik7XG4gIH1cbiAgZHJhd1RodW1iKGNvbnRleHQsIHJhZGl1cywgeCwgeSwgY29sb3IpIHtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gMDtcbiAgICBjb25zdCBlbmRBbmdsZSA9IDIgKiBNYXRoLlBJO1xuICAgIGNvbnN0IG91dGxpbmVXaWR0aCA9IDE7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI2ZmZlwiO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsMC4zKVwiO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gb3V0bGluZVdpZHRoO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMgLSAzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvci5yZ2IoKS5hbHBoYSgxKS5zdHJpbmcoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuICBkcmF3QWN0aXZlSHVlU2xpZGVyQ29sb3IoKSB7XG4gICAgY29uc3QgeyBjb2xvciB9ID0gdGhpcztcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhzdkNvbG9yID0gY29sb3IuaHN2KCkuc2F0dXJhdGlvbnYoMTAwKS52YWx1ZSgxMDApO1xuICAgIGNvbnN0IHsgZGltZW5zaW9uczogeyBzbGlkZXI6IHsgd2lkdGggfSwgdGh1bWI6IHsgcmFkaXVzIH0sIH0sIH0gPSB0aGlzO1xuICAgIGNvbnN0IHggPSBoc3ZDb2xvci5odWUoKSAvIChIVUVfTElNSVRfQ09OU1RSQUlORUQgLyB3aWR0aCk7XG4gICAgY29uc3QgeSA9IHJhZGl1cztcbiAgICBjb25zdCBzbGlkZXJCb3VuZFggPSB0aGlzLmdldFNsaWRlckJvdW5kWCh4LCB3aWR0aCwgcmFkaXVzKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5odWVTY29wZUxlZnQgPSBzbGlkZXJCb3VuZFg7XG4gICAgfSk7XG4gICAgdGhpcy5kcmF3VGh1bWIodGhpcy5odWVTbGlkZXJSZW5kZXJpbmdDb250ZXh0LCByYWRpdXMsIHNsaWRlckJvdW5kWCwgeSwgaHN2Q29sb3IpO1xuICB9XG4gIGRyYXdIdWVTbGlkZXIoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuaHVlU2xpZGVyUmVuZGVyaW5nQ29udGV4dDtcbiAgICBjb25zdCB7IGRpbWVuc2lvbnM6IHsgc2xpZGVyOiB7IGhlaWdodCwgd2lkdGggfSwgdGh1bWI6IHsgcmFkaXVzOiB0aHVtYlJhZGl1cyB9LCB9LCB9ID0gdGhpcztcbiAgICBjb25zdCB4ID0gMDtcbiAgICBjb25zdCB5ID0gdGh1bWJSYWRpdXMgLSBoZWlnaHQgLyAyO1xuICAgIGNvbnN0IGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgY29uc3QgaHVlU2xpZGVyQ29sb3JTdG9wS2V5d29yZHMgPSBbXG4gICAgICBcInJlZFwiLFxuICAgICAgXCJ5ZWxsb3dcIixcbiAgICAgIFwibGltZVwiLFxuICAgICAgXCJjeWFuXCIsXG4gICAgICBcImJsdWVcIixcbiAgICAgIFwibWFnZW50YVwiLFxuICAgICAgXCIjZmYwMDA0XCIgLyogMSB1bml0IGxlc3MgdGhhbiAjZmYwIHRvIGF2b2lkIGR1cGxpY2F0ZSB2YWx1ZXMgd2l0aGluIHJhbmdlICovLFxuICAgIF07XG4gICAgY29uc3Qgb2Zmc2V0ID0gMSAvIChodWVTbGlkZXJDb2xvclN0b3BLZXl3b3Jkcy5sZW5ndGggLSAxKTtcbiAgICBsZXQgY3VycmVudE9mZnNldCA9IDA7XG4gICAgaHVlU2xpZGVyQ29sb3JTdG9wS2V5d29yZHMuZm9yRWFjaCgoa2V5d29yZCkgPT4ge1xuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGN1cnJlbnRPZmZzZXQsIGNvbG9yKGtleXdvcmQpLnN0cmluZygpKTtcbiAgICAgIGN1cnJlbnRPZmZzZXQgKz0gb2Zmc2V0O1xuICAgIH0pO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQgKyB0aGlzLmdldFNsaWRlckNhcFNwYWNpbmcoKSAqIDIpO1xuICAgIHRoaXMuZHJhd1NsaWRlclBhdGgoY29udGV4dCwgaGVpZ2h0LCB3aWR0aCwgeCwgeSk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDAuMylcIjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB0aGlzLmRyYXdBY3RpdmVIdWVTbGlkZXJDb2xvcigpO1xuICB9XG4gIGRyYXdPcGFjaXR5U2xpZGVyKCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLm9wYWNpdHlTbGlkZXJSZW5kZXJpbmdDb250ZXh0O1xuICAgIGNvbnN0IHsgYmFzZUNvbG9yRmllbGRDb2xvcjogcHJldmlvdXNDb2xvciwgZGltZW5zaW9uczogeyBzbGlkZXI6IHsgaGVpZ2h0LCB3aWR0aCB9LCB0aHVtYjogeyByYWRpdXM6IHRodW1iUmFkaXVzIH0sIH0sIH0gPSB0aGlzO1xuICAgIGNvbnN0IHggPSAwO1xuICAgIGNvbnN0IHkgPSB0aHVtYlJhZGl1cyAtIGhlaWdodCAvIDI7XG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCArIHRoaXMuZ2V0U2xpZGVyQ2FwU3BhY2luZygpICogMik7XG4gICAgY29uc3QgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIHksIHdpZHRoLCAwKTtcbiAgICBjb25zdCBzdGFydENvbG9yID0gcHJldmlvdXNDb2xvci5yZ2IoKS5hbHBoYSgwKTtcbiAgICBjb25zdCBtaWRDb2xvciA9IHByZXZpb3VzQ29sb3IucmdiKCkuYWxwaGEoMC41KTtcbiAgICBjb25zdCBlbmRDb2xvciA9IHByZXZpb3VzQ29sb3IucmdiKCkuYWxwaGEoMSk7XG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIHN0YXJ0Q29sb3Iuc3RyaW5nKCkpO1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjUsIG1pZENvbG9yLnN0cmluZygpKTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgZW5kQ29sb3Iuc3RyaW5nKCkpO1xuICAgIHRoaXMuZHJhd1NsaWRlclBhdGgoY29udGV4dCwgaGVpZ2h0LCB3aWR0aCwgeCwgeSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybih0aGlzLmdldENoZWNrZXJlZEJhY2tncm91bmRQYXR0ZXJuKCksIFwicmVwZWF0XCIpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsMC4zKVwiO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIHRoaXMuZHJhd0FjdGl2ZU9wYWNpdHlTbGlkZXJDb2xvcigpO1xuICB9XG4gIGRyYXdTbGlkZXJQYXRoKGNvbnRleHQsIGhlaWdodCwgd2lkdGgsIHgsIHkpIHtcbiAgICBjb25zdCByYWRpdXMgPSBoZWlnaHQgLyAyICsgMTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgIGNvbnRleHQubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgY29udGV4dC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG4gIGdldENoZWNrZXJlZEJhY2tncm91bmRQYXR0ZXJuKCkge1xuICAgIGlmICh0aGlzLmNoZWNrZXJQYXR0ZXJuKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGVja2VyUGF0dGVybjtcbiAgICB9XG4gICAgY29uc3QgcGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgcGF0dGVybi53aWR0aCA9IDEwO1xuICAgIHBhdHRlcm4uaGVpZ2h0ID0gMTA7XG4gICAgY29uc3QgcGF0dGVybkNvbnRleHQgPSBwYXR0ZXJuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBwYXR0ZXJuQ29udGV4dC5maWxsU3R5bGUgPSBcIiNjY2NcIjtcbiAgICBwYXR0ZXJuQ29udGV4dC5maWxsUmVjdCgwLCAwLCAxMCwgMTApO1xuICAgIHBhdHRlcm5Db250ZXh0LmZpbGxTdHlsZSA9IFwiI2ZmZlwiO1xuICAgIHBhdHRlcm5Db250ZXh0LmZpbGxSZWN0KDAsIDAsIDUsIDUpO1xuICAgIHBhdHRlcm5Db250ZXh0LmZpbGxSZWN0KDUsIDUsIDUsIDUpO1xuICAgIHRoaXMuY2hlY2tlclBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIGRyYXdBY3RpdmVPcGFjaXR5U2xpZGVyQ29sb3IoKSB7XG4gICAgY29uc3QgeyBjb2xvciB9ID0gdGhpcztcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhzdkNvbG9yID0gY29sb3I7XG4gICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IHNsaWRlcjogeyB3aWR0aCB9LCB0aHVtYjogeyByYWRpdXMgfSwgfSwgfSA9IHRoaXM7XG4gICAgY29uc3QgeCA9IGFscGhhVG9PcGFjaXR5KGhzdkNvbG9yLmFscGhhKCkpIC8gKE9QQUNJVFlfTElNSVRTLm1heCAvIHdpZHRoKTtcbiAgICBjb25zdCB5ID0gcmFkaXVzO1xuICAgIGNvbnN0IHNsaWRlckJvdW5kWCA9IHRoaXMuZ2V0U2xpZGVyQm91bmRYKHgsIHdpZHRoLCByYWRpdXMpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLm9wYWNpdHlTY29wZUxlZnQgPSBzbGlkZXJCb3VuZFg7XG4gICAgfSk7XG4gICAgdGhpcy5kcmF3VGh1bWIodGhpcy5vcGFjaXR5U2xpZGVyUmVuZGVyaW5nQ29udGV4dCwgcmFkaXVzLCBzbGlkZXJCb3VuZFgsIHksIGhzdkNvbG9yKTtcbiAgfVxuICBnZXRTbGlkZXJCb3VuZFgoeCwgd2lkdGgsIHJhZGl1cykge1xuICAgIGNvbnN0IGNsb3NlVG9FZGdlID0gY2xvc2VUb1JhbmdlRWRnZSh4LCB3aWR0aCwgcmFkaXVzKTtcbiAgICByZXR1cm4gY2xvc2VUb0VkZ2UgPT09IDBcbiAgICAgID8geFxuICAgICAgOiBjbG9zZVRvRWRnZSA9PT0gLTFcbiAgICAgICAgPyByZW1hcCh4LCAwLCB3aWR0aCwgcmFkaXVzLCByYWRpdXMgKiAyKVxuICAgICAgICA6IHJlbWFwKHgsIDAsIHdpZHRoLCB3aWR0aCAtIHJhZGl1cyAqIDIsIHdpZHRoIC0gcmFkaXVzKTtcbiAgfVxuICB1cGRhdGVDb2xvckZyb21DaGFubmVscyhjaGFubmVscykge1xuICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChjb2xvcihjaGFubmVscywgdGhpcy5jaGFubmVsTW9kZSkpO1xuICB9XG4gIHVwZGF0ZUNoYW5uZWxzRnJvbUNvbG9yKGNvbG9yKSB7XG4gICAgdGhpcy5jaGFubmVscyA9IGNvbG9yID8gdGhpcy50b0NoYW5uZWxzKGNvbG9yKSA6IFtudWxsLCBudWxsLCBudWxsLCBudWxsXTtcbiAgfVxuICB0b0NoYW5uZWxzKGNvbG9yKSB7XG4gICAgY29uc3QgeyBjaGFubmVsTW9kZSB9ID0gdGhpcztcbiAgICBjb25zdCBjaGFubmVscyA9IGNvbG9yW2NoYW5uZWxNb2RlXSgpXG4gICAgICAuYXJyYXkoKVxuICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBpc0FscGhhID0gaW5kZXggPT09IDM7XG4gICAgICByZXR1cm4gaXNBbHBoYSA/IHZhbHVlIDogTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgfSk7XG4gICAgaWYgKGNoYW5uZWxzLmxlbmd0aCA9PT0gMykge1xuICAgICAgY2hhbm5lbHMucHVzaCgxKTsgLy8gQ29sb3Igb21pdHMgYWxwaGEgd2hlbiAxXG4gICAgfVxuICAgIHJldHVybiBjaGFubmVscztcbiAgfVxuICBnZXRBZGp1c3RlZFNjb3BlUG9zaXRpb24obGVmdCwgdG9wKSB7XG4gICAgcmV0dXJuIFtsZWZ0IC0gU0NPUEVfU0laRSAvIDIsIHRvcCAtIFNDT1BFX1NJWkUgLyAyXTtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlbGVnYXRlc0ZvY3VzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICBzdGF0aWMgZ2V0IGFzc2V0c0RpcnMoKSB7IHJldHVybiBbXCJhc3NldHNcIl07IH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwiYWxwaGFDaGFubmVsXCI6IFtcImhhbmRsZUFscGhhQ2hhbm5lbENoYW5nZVwiLCBcImhhbmRsZUZvcm1hdE9yQWxwaGFDaGFubmVsQ2hhbmdlXCJdLFxuICAgIFwiY29sb3JcIjogW1wiaGFuZGxlQ29sb3JDaGFuZ2VcIl0sXG4gICAgXCJmb3JtYXRcIjogW1wiaGFuZGxlRm9ybWF0T3JBbHBoYUNoYW5uZWxDaGFuZ2VcIl0sXG4gICAgXCJzY2FsZVwiOiBbXCJoYW5kbGVTY2FsZUNoYW5nZVwiXSxcbiAgICBcIm1lc3NhZ2VPdmVycmlkZXNcIjogW1wib25NZXNzYWdlc0NoYW5nZVwiXSxcbiAgICBcInZhbHVlXCI6IFtcImhhbmRsZVZhbHVlQ2hhbmdlXCJdLFxuICAgIFwiZWZmZWN0aXZlTG9jYWxlXCI6IFtcImVmZmVjdGl2ZUxvY2FsZUNoYW5nZVwiXVxuICB9OyB9XG59O1xuQ29sb3JQaWNrZXIuc3R5bGUgPSBjb2xvclBpY2tlckNzcztcblxuY29uc3QgQ1NTJDEgPSB7XG4gIGNvbnRhaW5lcjogXCJjb250YWluZXJcIixcbiAgaGV4SW5wdXQ6IFwiaGV4LWlucHV0XCIsXG4gIG9wYWNpdHlJbnB1dDogXCJvcGFjaXR5LWlucHV0XCIsXG59O1xuXG5jb25zdCBjb2xvclBpY2tlckhleElucHV0Q3NzID0gXCI6aG9zdHtkaXNwbGF5OmJsb2NrfS5jb250YWluZXJ7ZGlzcGxheTpmbGV4O2lubGluZS1zaXplOjEwMCU7ZmxleC13cmFwOm5vd3JhcDthbGlnbi1pdGVtczpjZW50ZXJ9LmhleC1pbnB1dHtmbGV4LWdyb3c6MTt0ZXh0LXRyYW5zZm9ybTp1cHBlcmNhc2V9Lm9wYWNpdHktaW5wdXR7aW5saW5lLXNpemU6NjhweDttYXJnaW4taW5saW5lLXN0YXJ0Oi0xcHh9Omhvc3QoW3NjYWxlPXNdKSAuY29udGFpbmVye2ZsZXgtd3JhcDp3cmFwO3Jvdy1nYXA6MC4xMjVyZW19Omhvc3QoW3NjYWxlPXNdKSAub3BhY2l0eS1pbnB1dHtpbmxpbmUtc2l6ZTp1bnNldDttYXJnaW4taW5saW5lLXN0YXJ0OnVuc2V0fTpob3N0KFtzY2FsZT1sXSkgLm9wYWNpdHktaW5wdXR7aW5saW5lLXNpemU6ODhweH06aG9zdChbaGlkZGVuXSl7ZGlzcGxheTpub25lfVtoaWRkZW5de2Rpc3BsYXk6bm9uZX1cIjtcblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IGNvbG9yKCk7XG5jb25zdCBDb2xvclBpY2tlckhleElucHV0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmNhbGNpdGVDb2xvclBpY2tlckhleElucHV0Q2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJjYWxjaXRlQ29sb3JQaWNrZXJIZXhJbnB1dENoYW5nZVwiLCA2KTtcbiAgICB0aGlzLm9uSGV4SW5wdXRCbHVyID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuaGV4SW5wdXROb2RlO1xuICAgICAgY29uc3QgaW5wdXRWYWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICBjb25zdCBoZXggPSBgIyR7aW5wdXRWYWx1ZX1gO1xuICAgICAgY29uc3QgeyBhbGxvd0VtcHR5LCBpbnRlcm5hbENvbG9yIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgd2lsbENsZWFyVmFsdWUgPSBhbGxvd0VtcHR5ICYmICFpbnB1dFZhbHVlO1xuICAgICAgY29uc3QgaXNMb25naGFuZCA9IGlzTG9uZ2hhbmRIZXgoaGV4KTtcbiAgICAgIC8vIGVuc3VyZSBtb2RpZmllZCBwYXN0ZWQgaGV4IHZhbHVlcyBhcmUgY29tbWl0dGVkIHNpbmNlIHdlIHByZXZlbnQgZGVmYXVsdCB0byByZW1vdmUgdGhlICMgY2hhci5cbiAgICAgIHRoaXMub25IZXhJbnB1dENoYW5nZSgpO1xuICAgICAgaWYgKHdpbGxDbGVhclZhbHVlIHx8IChpc1ZhbGlkSGV4KGhleCkgJiYgaXNMb25naGFuZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gbWFuaXB1bGF0aW5nIERPTSBkaXJlY3RseSBzaW5jZSByZXJlbmRlciBkb2Vzbid0IHVwZGF0ZSBpbnB1dCB2YWx1ZVxuICAgICAgbm9kZS52YWx1ZSA9XG4gICAgICAgIGFsbG93RW1wdHkgJiYgIWludGVybmFsQ29sb3JcbiAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICA6IHRoaXMuZm9ybWF0SGV4Rm9ySW50ZXJuYWxJbnB1dChyZ2JUb0hleChcbiAgICAgICAgICAvLyBhbHdheXMgZGlzcGxheSBoZXggaW5wdXQgaW4gUlJHR0JCIGZvcm1hdFxuICAgICAgICAgIGludGVybmFsQ29sb3Iub2JqZWN0KCkpKTtcbiAgICB9O1xuICAgIHRoaXMub25PcGFjaXR5SW5wdXRCbHVyID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMub3BhY2l0eUlucHV0Tm9kZTtcbiAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgY29uc3QgeyBhbGxvd0VtcHR5LCBpbnRlcm5hbENvbG9yIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgd2lsbENsZWFyVmFsdWUgPSBhbGxvd0VtcHR5ICYmICFpbnB1dFZhbHVlO1xuICAgICAgaWYgKHdpbGxDbGVhclZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIG1hbmlwdWxhdGluZyBET00gZGlyZWN0bHkgc2luY2UgcmVyZW5kZXIgZG9lc24ndCB1cGRhdGUgaW5wdXQgdmFsdWVcbiAgICAgIG5vZGUudmFsdWUgPVxuICAgICAgICBhbGxvd0VtcHR5ICYmICFpbnRlcm5hbENvbG9yID8gXCJcIiA6IHRoaXMuZm9ybWF0T3BhY2l0eUZvckludGVybmFsSW5wdXQoaW50ZXJuYWxDb2xvcik7XG4gICAgfTtcbiAgICB0aGlzLm9uSGV4SW5wdXRDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub2RlVmFsdWUgPSB0aGlzLmhleElucHV0Tm9kZS52YWx1ZTtcbiAgICAgIGxldCB2YWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplSGV4KHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHByZXNlcnZlRXhpc3RpbmdBbHBoYSA9IGlzVmFsaWRIZXgobm9ybWFsaXplZCkgJiYgdGhpcy5hbHBoYUNoYW5uZWw7XG4gICAgICAgIGlmIChwcmVzZXJ2ZUV4aXN0aW5nQWxwaGEgJiYgdGhpcy5pbnRlcm5hbENvbG9yKSB7XG4gICAgICAgICAgY29uc3QgYWxwaGFIZXggPSBub3JtYWxpemVIZXgodGhpcy5pbnRlcm5hbENvbG9yLmhleGEoKSwgdHJ1ZSkuc2xpY2UoLTIpO1xuICAgICAgICAgIHZhbHVlID0gYCR7bm9ybWFsaXplZCArIGFscGhhSGV4fWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaW50ZXJuYWxTZXRWYWx1ZSh2YWx1ZSwgdGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uT3BhY2l0eUlucHV0Q2hhbmdlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMub3BhY2l0eUlucHV0Tm9kZTtcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIGlmICghbm9kZS52YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBvcGFjaXR5VG9BbHBoYShOdW1iZXIobm9kZS52YWx1ZSkpO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuaW50ZXJuYWxDb2xvcj8uYWxwaGEoYWxwaGEpLmhleGEoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW50ZXJuYWxTZXRWYWx1ZSh2YWx1ZSwgdGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uSW5wdXRLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB7IGFsdEtleSwgY3RybEtleSwgbWV0YUtleSwgc2hpZnRLZXkgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgeyBhbHBoYUNoYW5uZWwsIGhleElucHV0Tm9kZSwgaW50ZXJuYWxDb2xvciwgdmFsdWUgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IGtleSB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgIGlmIChrZXkgPT09IFwiVGFiXCIgfHwga2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgaWYgKGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhoZXhJbnB1dE5vZGUpKSB7XG4gICAgICAgICAgdGhpcy5vbkhleElucHV0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbk9wYWNpdHlJbnB1dENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNOdWRnZUtleSA9IGtleSA9PT0gXCJBcnJvd0Rvd25cIiB8fCBrZXkgPT09IFwiQXJyb3dVcFwiO1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgaWYgKGlzTnVkZ2VLZXkpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuaW50ZXJuYWxTZXRWYWx1ZSh0aGlzLnByZXZpb3VzTm9uTnVsbFZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0ga2V5ID09PSBcIkFycm93VXBcIiA/IDEgOiAtMTtcbiAgICAgICAgY29uc3QgYnVtcCA9IHNoaWZ0S2V5ID8gMTAgOiAxO1xuICAgICAgICB0aGlzLmludGVybmFsU2V0VmFsdWUoaGV4aWZ5KHRoaXMubnVkZ2VSR0JDaGFubmVscyhpbnRlcm5hbENvbG9yLCBidW1wICogZGlyZWN0aW9uLCBjb21wb3NlZFBhdGguaW5jbHVkZXMoaGV4SW5wdXROb2RlKSA/IFwicmdiXCIgOiBcImFcIiksIGFscGhhQ2hhbm5lbCksIG9sZFZhbHVlKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2l0aE1vZGlmaWVycyA9IGFsdEtleSB8fCBjdHJsS2V5IHx8IG1ldGFLZXk7XG4gICAgICBjb25zdCBzaW5nbGVDaGFyID0ga2V5Lmxlbmd0aCA9PT0gMTtcbiAgICAgIGNvbnN0IHZhbGlkSGV4Q2hhciA9IGhleENoYXIudGVzdChrZXkpO1xuICAgICAgaWYgKHNpbmdsZUNoYXIgJiYgIXdpdGhNb2RpZmllcnMgJiYgIXZhbGlkSGV4Q2hhcikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbkhleElucHV0UGFzdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGhleCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHRcIik7XG4gICAgICBpZiAoaXNWYWxpZEhleChoZXgpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuaGV4SW5wdXROb2RlLnZhbHVlID0gaGV4LnNsaWNlKDEpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wcmV2aW91c05vbk51bGxWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgdGhpcy5zdG9yZUhleElucHV0UmVmID0gKG5vZGUpID0+IHtcbiAgICAgIHRoaXMuaGV4SW5wdXROb2RlID0gbm9kZTtcbiAgICB9O1xuICAgIHRoaXMuc3RvcmVPcGFjaXR5SW5wdXRSZWYgPSAobm9kZSkgPT4ge1xuICAgICAgdGhpcy5vcGFjaXR5SW5wdXROb2RlID0gbm9kZTtcbiAgICB9O1xuICAgIHRoaXMuYWxsb3dFbXB0eSA9IGZhbHNlO1xuICAgIHRoaXMuYWxwaGFDaGFubmVsID0gZmFsc2U7XG4gICAgdGhpcy5oZXhMYWJlbCA9IFwiSGV4XCI7XG4gICAgdGhpcy5tZXNzYWdlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlID0gXCJtXCI7XG4gICAgdGhpcy52YWx1ZSA9IG5vcm1hbGl6ZUhleChoZXhpZnkoREVGQVVMVF9DT0xPUiwgdGhpcy5hbHBoYUNoYW5uZWwpLCB0aGlzLmFscGhhQ2hhbm5lbCwgdHJ1ZSk7XG4gICAgdGhpcy5pbnRlcm5hbENvbG9yID0gREVGQVVMVF9DT0xPUjtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBMaWZlY3ljbGVcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb25zdCB7IGFsbG93RW1wdHksIGFscGhhQ2hhbm5lbCwgdmFsdWUgfSA9IHRoaXM7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplSGV4KHZhbHVlLCBhbHBoYUNoYW5uZWwpO1xuICAgICAgaWYgKGlzVmFsaWRIZXgobm9ybWFsaXplZCwgYWxwaGFDaGFubmVsKSkge1xuICAgICAgICB0aGlzLmludGVybmFsU2V0VmFsdWUobm9ybWFsaXplZCwgbm9ybWFsaXplZCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWxsb3dFbXB0eSkge1xuICAgICAgdGhpcy5pbnRlcm5hbFNldFZhbHVlKG51bGwsIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgc2V0VXBMb2FkYWJsZUNvbXBvbmVudCh0aGlzKTtcbiAgfVxuICBjb21wb25lbnREaWRMb2FkKCkge1xuICAgIHNldENvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAgfVxuICBoYW5kbGVWYWx1ZUNoYW5nZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICB0aGlzLmludGVybmFsU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCBmYWxzZSk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYWxwaGFDaGFubmVsLCBoZXhMYWJlbCwgaW50ZXJuYWxDb2xvciwgbWVzc2FnZXMsIHNjYWxlLCB2YWx1ZSB9ID0gdGhpcztcbiAgICBjb25zdCBoZXhJbnB1dFZhbHVlID0gdGhpcy5mb3JtYXRIZXhGb3JJbnRlcm5hbElucHV0KHZhbHVlKTtcbiAgICBjb25zdCBvcGFjaXR5SW5wdXRWYWx1ZSA9IHRoaXMuZm9ybWF0T3BhY2l0eUZvckludGVybmFsSW5wdXQoaW50ZXJuYWxDb2xvcik7XG4gICAgY29uc3QgaW5wdXRTY2FsZSA9IHNjYWxlID09PSBcImxcIiA/IFwibVwiIDogXCJzXCI7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQxLmNvbnRhaW5lciB9LCBoKFwiY2FsY2l0ZS1pbnB1dC10ZXh0XCIsIHsgY2xhc3M6IENTUyQxLmhleElucHV0LCBsYWJlbDogbWVzc2FnZXM/LmhleCB8fCBoZXhMYWJlbCwgbWF4TGVuZ3RoOiA2LCBvbkNhbGNpdGVJbnB1dFRleHRDaGFuZ2U6IHRoaXMub25IZXhJbnB1dENoYW5nZSwgb25DYWxjaXRlSW50ZXJuYWxJbnB1dFRleHRCbHVyOiB0aGlzLm9uSGV4SW5wdXRCbHVyLCBvbktleURvd246IHRoaXMub25JbnB1dEtleURvd24sIG9uUGFzdGU6IHRoaXMub25IZXhJbnB1dFBhc3RlLCBwcmVmaXhUZXh0OiBcIiNcIiwgc2NhbGU6IGlucHV0U2NhbGUsIHZhbHVlOiBoZXhJbnB1dFZhbHVlLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1zb3J0LXByb3BzIC0tIHJlZiBzaG91bGQgYmUgbGFzdCBzbyBub2RlIGF0dHJzL3Byb3BzIGFyZSBpbiBzeW5jIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL3B1bGwvNjUzMClcbiAgICAgIHJlZjogdGhpcy5zdG9yZUhleElucHV0UmVmIH0pLCBhbHBoYUNoYW5uZWwgPyAoaChcImNhbGNpdGUtaW5wdXQtbnVtYmVyXCIsIHsgY2xhc3M6IENTUyQxLm9wYWNpdHlJbnB1dCwga2V5OiBcIm9wYWNpdHktaW5wdXRcIiwgbGFiZWw6IG1lc3NhZ2VzPy5vcGFjaXR5LCBtYXg6IE9QQUNJVFlfTElNSVRTLm1heCwgbWF4TGVuZ3RoOiAzLCBtaW46IE9QQUNJVFlfTElNSVRTLm1pbiwgbnVtYmVyQnV0dG9uVHlwZTogXCJub25lXCIsIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW0sIG9uQ2FsY2l0ZUlucHV0TnVtYmVyQ2hhbmdlOiB0aGlzLm9uT3BhY2l0eUlucHV0Q2hhbmdlLCBvbkNhbGNpdGVJbnRlcm5hbElucHV0TnVtYmVyQmx1cjogdGhpcy5vbk9wYWNpdHlJbnB1dEJsdXIsIG9uS2V5RG93bjogdGhpcy5vbklucHV0S2V5RG93biwgc2NhbGU6IGlucHV0U2NhbGUsIHN1ZmZpeFRleHQ6IFwiJVwiLCB2YWx1ZTogb3BhY2l0eUlucHV0VmFsdWUsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LXNvcnQtcHJvcHMgLS0gcmVmIHNob3VsZCBiZSBsYXN0IHNvIG5vZGUgYXR0cnMvcHJvcHMgYXJlIGluIHN5bmMgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vcHVsbC82NTMwKVxuICAgICAgcmVmOiB0aGlzLnN0b3JlT3BhY2l0eUlucHV0UmVmIH0pKSA6IG51bGwpKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBQdWJsaWMgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKiBTZXRzIGZvY3VzIG9uIHRoZSBjb21wb25lbnQuICovXG4gIGFzeW5jIHNldEZvY3VzKCkge1xuICAgIGF3YWl0IGNvbXBvbmVudEZvY3VzYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gZm9jdXNFbGVtZW50KHRoaXMuaGV4SW5wdXROb2RlKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBQcml2YXRlIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpbnRlcm5hbFNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgZW1pdCA9IHRydWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNvbnN0IHsgYWxwaGFDaGFubmVsIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUhleCh2YWx1ZSwgYWxwaGFDaGFubmVsLCBhbHBoYUNoYW5uZWwpO1xuICAgICAgaWYgKGlzVmFsaWRIZXgobm9ybWFsaXplZCwgYWxwaGFDaGFubmVsKSkge1xuICAgICAgICBjb25zdCB7IGludGVybmFsQ29sb3I6IGN1cnJlbnRDb2xvciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbmV4dENvbG9yID0gY29sb3Iobm9ybWFsaXplZCk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRMb25naGFuZCA9IG5vcm1hbGl6ZUhleChoZXhpZnkobmV4dENvbG9yLCBhbHBoYUNoYW5uZWwpLCBhbHBoYUNoYW5uZWwpO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gIWN1cnJlbnRDb2xvciB8fFxuICAgICAgICAgIG5vcm1hbGl6ZWRMb25naGFuZCAhPT0gbm9ybWFsaXplSGV4KGhleGlmeShjdXJyZW50Q29sb3IsIGFscGhhQ2hhbm5lbCksIGFscGhhQ2hhbm5lbCk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxDb2xvciA9IG5leHRDb2xvcjtcbiAgICAgICAgdGhpcy5wcmV2aW91c05vbk51bGxWYWx1ZSA9IG5vcm1hbGl6ZWRMb25naGFuZDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5vcm1hbGl6ZWRMb25naGFuZDtcbiAgICAgICAgaWYgKGNoYW5nZWQgJiYgZW1pdCkge1xuICAgICAgICAgIHRoaXMuY2FsY2l0ZUNvbG9yUGlja2VySGV4SW5wdXRDaGFuZ2UuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5hbGxvd0VtcHR5KSB7XG4gICAgICB0aGlzLmludGVybmFsQ29sb3IgPSBudWxsO1xuICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICBpZiAoZW1pdCkge1xuICAgICAgICB0aGlzLmNhbGNpdGVDb2xvclBpY2tlckhleElucHV0Q2hhbmdlLmVtaXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IG9sZFZhbHVlO1xuICB9XG4gIGZvcm1hdEhleEZvckludGVybmFsSW5wdXQoaGV4KSB7XG4gICAgcmV0dXJuIGhleCA/IGhleC5yZXBsYWNlKFwiI1wiLCBcIlwiKS5zbGljZSgwLCA2KSA6IFwiXCI7XG4gIH1cbiAgZm9ybWF0T3BhY2l0eUZvckludGVybmFsSW5wdXQoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IgPyBgJHthbHBoYVRvT3BhY2l0eShjb2xvci5hbHBoYSgpKX1gIDogXCJcIjtcbiAgfVxuICBudWRnZVJHQkNoYW5uZWxzKGNvbG9yJDEsIGFtb3VudCwgY29udGV4dCkge1xuICAgIGxldCBudWRnZWRDaGFubmVscztcbiAgICBjb25zdCBjaGFubmVscyA9IGNvbG9yJDEuYXJyYXkoKTtcbiAgICBjb25zdCByZ2JDaGFubmVscyA9IGNoYW5uZWxzLnNsaWNlKDAsIDMpO1xuICAgIGlmIChjb250ZXh0ID09PSBcInJnYlwiKSB7XG4gICAgICBjb25zdCBudWRnZWRSR0JDaGFubmVscyA9IHJnYkNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4gY2hhbm5lbCArIGFtb3VudCk7XG4gICAgICBudWRnZWRDaGFubmVscyA9IFtcbiAgICAgICAgLi4ubnVkZ2VkUkdCQ2hhbm5lbHMsXG4gICAgICAgIHRoaXMuYWxwaGFDaGFubmVsID8gY2hhbm5lbHNbM10gOiB1bmRlZmluZWQsXG4gICAgICBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG51ZGdlZEFscGhhID0gb3BhY2l0eVRvQWxwaGEoYWxwaGFUb09wYWNpdHkoY29sb3IkMS5hbHBoYSgpKSArIGFtb3VudCk7XG4gICAgICBudWRnZWRDaGFubmVscyA9IFsuLi5yZ2JDaGFubmVscywgbnVkZ2VkQWxwaGFdO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3IobnVkZ2VkQ2hhbm5lbHMpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcInZhbHVlXCI6IFtcImhhbmRsZVZhbHVlQ2hhbmdlXCJdXG4gIH07IH1cbn07XG5Db2xvclBpY2tlckhleElucHV0LnN0eWxlID0gY29sb3JQaWNrZXJIZXhJbnB1dENzcztcblxuY29uc3QgQ1NTID0ge1xuICBzd2F0Y2g6IFwic3dhdGNoXCIsXG4gIG5vQ29sb3JTd2F0Y2g6IFwic3dhdGNoLS1uby1jb2xvclwiLFxuICBjaGVja2VyOiBcImNoZWNrZXJcIixcbn07XG5jb25zdCBDT0xPUlMgPSB7XG4gIGJvcmRlckxpZ2h0OiBcInJnYmEoMCwgMCwgMCwgMC4zKVwiLFxuICBib3JkZXJEYXJrOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNSlcIixcbn07XG5jb25zdCBjaGVja2VyU3F1YXJlU2l6ZSA9IDQ7XG5jb25zdCBDSEVDS0VSX0RJTUVOU0lPTlMgPSB7XG4gIHNxdWFyZVNpemU6IGNoZWNrZXJTcXVhcmVTaXplLFxuICBzaXplOiBjaGVja2VyU3F1YXJlU2l6ZSAqIDIsXG59O1xuXG5jb25zdCBjb2xvclBpY2tlclN3YXRjaENzcyA9IFwiOmhvc3R7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtZmxleH06aG9zdChbc2NhbGU9c10pe2Jsb2NrLXNpemU6MS4yNXJlbTtpbmxpbmUtc2l6ZToxLjI1cmVtfTpob3N0KFtzY2FsZT1tXSl7YmxvY2stc2l6ZToxLjVyZW07aW5saW5lLXNpemU6MS41cmVtfTpob3N0KFtzY2FsZT1sXSl7YmxvY2stc2l6ZToycmVtO2lubGluZS1zaXplOjJyZW19LnN3YXRjaHtvdmVyZmxvdzpoaWRkZW47YmxvY2stc2l6ZTppbmhlcml0O2lubGluZS1zaXplOmluaGVyaXR9LnN3YXRjaCByZWN0e3RyYW5zaXRpb24tcHJvcGVydHk6YWxsO3RyYW5zaXRpb24tZHVyYXRpb246MTUwbXM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKX0uc3dhdGNoLS1uby1jb2xvciByZWN0e2ZpbGw6dmFyKC0tY2FsY2l0ZS1jb2xvci1mb3JlZ3JvdW5kLTEpfS5zd2F0Y2gtLW5vLWNvbG9yIGxpbmV7c3Ryb2tlOnZhcigtLWNhbGNpdGUtY29sb3Itc3RhdHVzLWRhbmdlcil9LmNoZWNrZXJ7ZmlsbDojY2FjYWNhfTpob3N0KFtoaWRkZW5dKXtkaXNwbGF5Om5vbmV9W2hpZGRlbl17ZGlzcGxheTpub25lfVwiO1xuXG5jb25zdCBDb2xvclBpY2tlclN3YXRjaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2NhbGUgPSBcIm1cIjtcbiAgfVxuICBoYW5kbGVDb2xvckNoYW5nZShjb2xvciQxKSB7XG4gICAgdGhpcy5pbnRlcm5hbENvbG9yID0gY29sb3IkMSA/IGNvbG9yKGNvbG9yJDEpIDogbnVsbDtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBMaWZlY3ljbGVcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICB0aGlzLmhhbmRsZUNvbG9yQ2hhbmdlKHRoaXMuY29sb3IpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBpc0VtcHR5ID0gIXRoaXMuaW50ZXJuYWxDb2xvcjtcbiAgICBjb25zdCBjbGFzc2VzID0ge1xuICAgICAgW0NTUy5zd2F0Y2hdOiB0cnVlLFxuICAgICAgW0NTUy5ub0NvbG9yU3dhdGNoXTogaXNFbXB0eSxcbiAgICB9O1xuICAgIHJldHVybiAoaChcInN2Z1wiLCB7IGNsYXNzOiBjbGFzc2VzLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sIHRoaXMucmVuZGVyU3dhdGNoKCkpKTtcbiAgfVxuICByZW5kZXJTd2F0Y2goKSB7XG4gICAgY29uc3QgeyBhY3RpdmUsIGVsLCBpbnRlcm5hbENvbG9yIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IGFjdGl2ZSA/IFwiMTAwJVwiIDogXCIwXCI7XG4gICAgY29uc3QgdGhlbWUgPSBnZXRNb2RlTmFtZShlbCk7XG4gICAgY29uc3QgYm9yZGVyQ29sb3IgPSB0aGVtZSA9PT0gXCJsaWdodFwiID8gQ09MT1JTLmJvcmRlckxpZ2h0IDogQ09MT1JTLmJvcmRlckRhcms7XG4gICAgY29uc3QgY29tbW9uU3dhdGNoUHJvcHMgPSB7XG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgcng6IGJvcmRlclJhZGl1cyxcbiAgICAgIHN0cm9rZTogYm9yZGVyQ29sb3IsXG4gICAgICAvLyBzdHJva2Utd2lkdGggYW5kIGNsaXAtcGF0aCBhcmUgbmVlZGVkIHRvIGhpZGUgb3ZlcmZsb3dpbmcgcG9ydGlvbiBvZiBzdHJva2VcbiAgICAgIC8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzI3MzM0Ni8xOTQyMTZcbiAgICAgIC8vIHVzaW5nIGF0dHJpYnV0ZSB0byB3b3JrIGFyb3VuZCBTdGVuY2lsIHVzaW5nIHRoZSBwcm9wIG5hbWUgdnMgdGhlIGF0dHJpYnV0ZSB3aGVuIHJlbmRlcmluZ1xuICAgICAgW1wic3Ryb2tlLXdpZHRoXCJdOiBcIjJcIixcbiAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHkgPSAhaW50ZXJuYWxDb2xvcjtcbiAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgcmV0dXJuIChoKEZyYWdtZW50LCBudWxsLCBoKFwiY2xpcFBhdGhcIiwgeyBpZDogXCJzaGFwZVwiIH0sIGgoXCJyZWN0XCIsIHsgaGVpZ2h0OiBcIjEwMCVcIiwgcng6IGJvcmRlclJhZGl1cywgd2lkdGg6IFwiMTAwJVwiIH0pKSwgaChcInJlY3RcIiwgeyBcImNsaXAtcGF0aFwiOiBgaW5zZXQoMCByb3VuZCAke2JvcmRlclJhZGl1c30pYCwgcng6IGJvcmRlclJhZGl1cywgLi4uY29tbW9uU3dhdGNoUHJvcHMgfSksIGgoXCJsaW5lXCIsIHsgXCJjbGlwLXBhdGhcIjogXCJ1cmwoI3NoYXBlKVwiLCBcInN0cm9rZS13aWR0aFwiOiBcIjNcIiwgeDE6IFwiMTAwJVwiLCB4MjogXCIwXCIsIHkxOiBcIjBcIiwgeTI6IFwiMTAwJVwiIH0pKSk7XG4gICAgfVxuICAgIGNvbnN0IGFscGhhID0gaW50ZXJuYWxDb2xvci5hbHBoYSgpO1xuICAgIGNvbnN0IGhleCA9IGhleGlmeShpbnRlcm5hbENvbG9yKTtcbiAgICBjb25zdCBoZXhhID0gaGV4aWZ5KGludGVybmFsQ29sb3IsIGFscGhhIDwgMSk7XG4gICAgcmV0dXJuIChoKEZyYWdtZW50LCBudWxsLCBoKFwidGl0bGVcIiwgbnVsbCwgaGV4YSksIGgoXCJkZWZzXCIsIG51bGwsIGgoXCJwYXR0ZXJuXCIsIHsgaGVpZ2h0OiBDSEVDS0VSX0RJTUVOU0lPTlMuc2l6ZSwgaWQ6IFwiY2hlY2tlclwiLCBwYXR0ZXJuVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIiwgd2lkdGg6IENIRUNLRVJfRElNRU5TSU9OUy5zaXplLCB4OiBcIjBcIiwgeTogXCIwXCIgfSwgaChcInJlY3RcIiwgeyBjbGFzczogQ1NTLmNoZWNrZXIsIGhlaWdodDogQ0hFQ0tFUl9ESU1FTlNJT05TLnNxdWFyZVNpemUsIHdpZHRoOiBDSEVDS0VSX0RJTUVOU0lPTlMuc3F1YXJlU2l6ZSwgeDogXCIwXCIsIHk6IFwiMFwiIH0pLCBoKFwicmVjdFwiLCB7IGNsYXNzOiBDU1MuY2hlY2tlciwgaGVpZ2h0OiBDSEVDS0VSX0RJTUVOU0lPTlMuc3F1YXJlU2l6ZSwgd2lkdGg6IENIRUNLRVJfRElNRU5TSU9OUy5zcXVhcmVTaXplLCB4OiBDSEVDS0VSX0RJTUVOU0lPTlMuc3F1YXJlU2l6ZSwgeTogQ0hFQ0tFUl9ESU1FTlNJT05TLnNxdWFyZVNpemUgfSkpKSwgaChcInJlY3RcIiwgeyBmaWxsOiBcInVybCgjY2hlY2tlcilcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgcng6IGJvcmRlclJhZGl1cywgd2lkdGg6IFwiMTAwJVwiIH0pLCBoKFwicmVjdFwiLCB7IGZpbGw6IGhleCwgc3R5bGU6IHtcbiAgICAgICAgXCJjbGlwLXBhdGhcIjogYWxwaGEgPCAxID8gXCJwb2x5Z29uKDEwMCUgMCwgMCAwLCAwIDEwMCUpXCIgOiBgaW5zZXQoMCByb3VuZCAke2JvcmRlclJhZGl1c30pYCxcbiAgICAgIH0sIC4uLmNvbW1vblN3YXRjaFByb3BzIH0pLCBhbHBoYSA8IDEgPyAoaChcInJlY3RcIiwgeyBmaWxsOiBoZXhhLCBrZXk6IFwib3BhY2l0eS1maWxsXCIsIHN0eWxlOiB7IFwiY2xpcC1wYXRoXCI6IFwicG9seWdvbigxMDAlIDAsIDEwMCUgMTAwJSwgMCAxMDAlKVwiIH0sIC4uLmNvbW1vblN3YXRjaFByb3BzIH0pKSA6IG51bGwpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJjb2xvclwiOiBbXCJoYW5kbGVDb2xvckNoYW5nZVwiXVxuICB9OyB9XG59O1xuQ29sb3JQaWNrZXJTd2F0Y2guc3R5bGUgPSBjb2xvclBpY2tlclN3YXRjaENzcztcblxuZXhwb3J0IHsgQ29sb3JQaWNrZXIgYXMgY2FsY2l0ZV9jb2xvcl9waWNrZXIsIENvbG9yUGlja2VySGV4SW5wdXQgYXMgY2FsY2l0ZV9jb2xvcl9waWNrZXJfaGV4X2lucHV0LCBDb2xvclBpY2tlclN3YXRjaCBhcyBjYWxjaXRlX2NvbG9yX3BpY2tlcl9zd2F0Y2ggfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsY2l0ZS1jb2xvci1waWNrZXJfMy5lbnRyeS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvbWFpbi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjIuMC4wXG4gKi9cbmltcG9ydCB7IGYgYXMgZm9yY2VVcGRhdGUgfSBmcm9tICcuL2luZGV4LTg2ZmFlZjljLmpzJztcblxuY29uc3QgcmVzb2x2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwcm9taXNlTWFwID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogVGhpcyBoZWxwZXIgdXRpbCBzZXRzIHVwIHRoZSBjb21wb25lbnQgZm9yIHRoZSBhYmlsaXR5IHRvIGtub3cgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGxvYWRlZC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIHRoZSBgY29tcG9uZW50V2lsbExvYWRgIGxpZmVjeWNsZSBob29rLlxuICpcbiAqIGBgYFxuICogY29tcG9uZW50V2lsbExvYWQoKTogdm9pZCB7XG4gKiAgIHNldFVwTG9hZGFibGVDb21wb25lbnQodGhpcyk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIHNldFVwTG9hZGFibGVDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHByb21pc2VNYXAuc2V0KGNvbXBvbmVudCwgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmVNYXAuc2V0KGNvbXBvbmVudCwgcmVzb2x2ZSkpKTtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgdXRpbCBsZXRzIHRoZSBsb2FkYWJsZSBjb21wb25lbnQga25vdyB0aGF0IGl0IGlzIG5vdyBsb2FkZWQuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgdXNlZCBpbiB0aGUgYGNvbXBvbmVudERpZExvYWRgIGxpZmVjeWNsZSBob29rLlxuICpcbiAqIGBgYFxuICogY29tcG9uZW50RGlkTG9hZCgpOiB2b2lkIHtcbiAqICAgc2V0Q29tcG9uZW50TG9hZGVkKHRoaXMpO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBzZXRDb21wb25lbnRMb2FkZWQoY29tcG9uZW50KSB7XG4gIHJlc29sdmVNYXAuZ2V0KGNvbXBvbmVudCkoKTtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgdXRpbCBjYW4gYmUgdXNlZCB0byBlbnN1cmUgYSBjb21wb25lbnQgaGFzIGJlZW4gbG9hZGVkIChUaGUgXCJjb21wb25lbnREaWRMb2FkXCIgU3RlbmNpbCBsaWZlY3ljbGUgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZCkuXG4gKlxuICogUmVxdWlyZXMgcmVxdWlyZXMgYExvYWRhYmxlQ29tcG9uZW50YCB0byBiZSBpbXBsZW1lbnRlZC5cbiAqXG4gKiBBIGNvbXBvbmVudCBkZXZlbG9wZXIgY2FuIGF3YWl0IHRoaXMgbWV0aG9kIGJlZm9yZSBwcm9jZWVkaW5nIHdpdGggYW55IGxvZ2ljIHRoYXQgcmVxdWlyZXMgYSBjb21wb25lbnQgdG8gYmUgbG9hZGVkIGZpcnN0LlxuICpcbiAqIGBgYFxuICogYXN5bmMgbXlNZXRob2QoKTogUHJvbWlzZTx2b2lkPiB7XG4gKiAgIGF3YWl0IGNvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqIEByZXR1cm5zIFByb21pc2U8dm9pZD5cbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50TG9hZGVkKGNvbXBvbmVudCkge1xuICByZXR1cm4gcHJvbWlzZU1hcC5nZXQoY29tcG9uZW50KTtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgdXRpbCBjYW4gYmUgdXNlZCB0byBlbnN1cmluZyB0aGUgY29tcG9uZW50IGlzIGxvYWRlZCBhbmQgcmVuZGVyZWQgYnkgdGhlIGJyb3dzZXIgKFRoZSBcImNvbXBvbmVudERpZExvYWRcIiBTdGVuY2lsIGxpZmVjeWNsZSBtZXRob2QgaGFzIGJlZW4gY2FsbGVkIGFuZCBhbnkgaW50ZXJuYWwgZWxlbWVudHMgYXJlIGZvY3VzYWJsZSkuXG4gKlxuICogUmVxdWlyZXMgcmVxdWlyZXMgYExvYWRhYmxlQ29tcG9uZW50YCB0byBiZSBpbXBsZW1lbnRlZC5cbiAqXG4gKiBBIGNvbXBvbmVudCBkZXZlbG9wZXIgY2FuIGF3YWl0IHRoaXMgbWV0aG9kIGJlZm9yZSBwcm9jZWVkaW5nIHdpdGggYW55IGxvZ2ljIHRoYXQgcmVxdWlyZXMgYSBjb21wb25lbnQgdG8gYmUgbG9hZGVkIGZpcnN0IGFuZCB0aGVuIGFuIGludGVybmFsIGVsZW1lbnQgYmUgZm9jdXNlZC5cbiAqXG4gKiBgYGBcbiAqIGFzeW5jIHNldEZvY3VzKCk6IFByb21pc2U8dm9pZD4ge1xuICogICBhd2FpdCBjb21wb25lbnRGb2N1c2FibGUodGhpcyk7XG4gKiAgIHRoaXMuaW50ZXJuYWxFbGVtZW50Py5mb2N1cygpO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxuICovXG5hc3luYyBmdW5jdGlvbiBjb21wb25lbnRGb2N1c2FibGUoY29tcG9uZW50KSB7XG4gIGF3YWl0IGNvbXBvbmVudExvYWRlZChjb21wb25lbnQpO1xuICBmb3JjZVVwZGF0ZShjb21wb25lbnQpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiByZXNvbHZlKCkpKTtcbn1cblxuZXhwb3J0IHsgc2V0Q29tcG9uZW50TG9hZGVkIGFzIGEsIGNvbXBvbmVudExvYWRlZCBhcyBiLCBjb21wb25lbnRGb2N1c2FibGUgYXMgYywgc2V0VXBMb2FkYWJsZUNvbXBvbmVudCBhcyBzIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRhYmxlLWIxNzM5NmUwLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9tYWluL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2Mi4wLjBcbiAqL1xuY29uc3QgY2xhbXAgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbmNvbnN0IGRlY2ltYWxOdW1iZXJSZWdleCA9IG5ldyBSZWdFeHAoLyg/OlxcLihcXGQrKSk/KD86W2VFXShbKy1dP1xcZCspKT8kLyk7XG4vKipcbiAqIFJldHVybnMgdGhlIHF1YW50aXR5IG9mIHJlYWwgZGVjaW1hbCBwbGFjZXMgZm9yIGEgbnVtYmVyLCB3aGljaCBleGNsdWRlcyB0cmFpbGluZyB6ZXJvcy5cbiAqXG4gKiBBZGFwdGVkIGZyb20ge0BsaW5rIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNDU0NTE4L2phdmFzY3JpcHQtaG93LXRvLXJldHJpZXZlLXRoZS1udW1iZXItb2YtZGVjaW1hbHMtb2YtYS1zdHJpbmctbnVtYmVyfS5cbiAqXG4gKiBAcGFyYW0gZGVjaW1hbCAtIGRlY2ltYWwgdmFsdWVcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gdGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBpbiBhIG51bWJlclxuICovXG5jb25zdCBkZWNpbWFsUGxhY2VzID0gKHZhbHVlKSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gKFwiXCIgKyB2YWx1ZSkubWF0Y2goZGVjaW1hbE51bWJlclJlZ2V4KTtcbiAgaWYgKCFtYXRjaCB8fCBwYXJzZUludChtYXRjaFsxXSkgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoMCwgXG4gIC8vIE51bWJlciBvZiBkaWdpdHMgcmlnaHQgb2YgZGVjaW1hbCBwb2ludC5cbiAgKG1hdGNoWzFdID8gbWF0Y2hbMV0ubGVuZ3RoIDogMCkgLVxuICAgIC8vIEFkanVzdCBmb3Igc2NpZW50aWZpYyBub3RhdGlvbi5cbiAgICAobWF0Y2hbMl0gPyArbWF0Y2hbMl0gOiAwKSk7XG59O1xuZnVuY3Rpb24gZ2V0RGVjaW1hbHModmFsdWUpIHtcbiAgaWYgKGRlY2ltYWxQbGFjZXModmFsdWUpID4gMCAmJiB2YWx1ZSA+IDApIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChgMC4ke3ZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdfWApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHJlbWFwKHZhbHVlLCBmcm9tTWluLCBmcm9tTWF4LCB0b01pbiwgdG9NYXgpIHtcbiAgcmV0dXJuICgodmFsdWUgLSBmcm9tTWluKSAqICh0b01heCAtIHRvTWluKSkgLyAoZnJvbU1heCAtIGZyb21NaW4pICsgdG9NaW47XG59XG4vKipcbiAqIEhlbHBlciB0byBkZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBjbG9zZSB0byB0aGUgZWRnZSBvZiBhIHJhbmdlIHdpdGhpbiBhIHRocmVzaG9sZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSByYW5nZVxuICogQHBhcmFtIHRocmVzaG9sZFxuICogQHJldHVybnMgLTEgaWYgY2xvc2UgdG8gbG93ZXIgZWRnZSwgMSBpZiBjbG9zZSB0byB1cHBlciBlZGdlLCAwIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gY2xvc2VUb1JhbmdlRWRnZSh2YWx1ZSwgcmFuZ2UsIHRocmVzaG9sZCkge1xuICByZXR1cm4gdmFsdWUgPCB0aHJlc2hvbGQgPyAtMSA6IHZhbHVlID4gcmFuZ2UgLSB0aHJlc2hvbGQgPyAxIDogMDtcbn1cblxuZXhwb3J0IHsgY2xvc2VUb1JhbmdlRWRnZSBhcyBhLCBjbGFtcCBhcyBjLCBkZWNpbWFsUGxhY2VzIGFzIGQsIGdldERlY2ltYWxzIGFzIGcsIHJlbWFwIGFzIHIgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC05MjJlMzdlYy5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvbWFpbi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjIuMC4wXG4gKi9cbmNvbnN0IGhleENoYXIgPSAvXlswLTlBLUZdJC9pO1xuY29uc3Qgc2hvcnRoYW5kSGV4ID0gL14jWzAtOUEtRl17M30kL2k7XG5jb25zdCBsb25naGFuZEhleCA9IC9eI1swLTlBLUZdezZ9JC9pO1xuY29uc3Qgc2hvcnRoYW5kSGV4V2l0aEFscGhhID0gL14jWzAtOUEtRl17NH0kL2k7XG5jb25zdCBsb25naGFuZEhleFdpdGhBbHBoYSA9IC9eI1swLTlBLUZdezh9JC9pO1xuY29uc3QgYWxwaGFUb09wYWNpdHkgPSAoYWxwaGEpID0+IE51bWJlcigoYWxwaGEgKiAxMDApLnRvRml4ZWQoKSk7XG5jb25zdCBvcGFjaXR5VG9BbHBoYSA9IChvcGFjaXR5KSA9PiBOdW1iZXIoKG9wYWNpdHkgLyAxMDApLnRvRml4ZWQoMikpO1xuZnVuY3Rpb24gaXNWYWxpZEhleChoZXgsIGhhc0FscGhhID0gZmFsc2UpIHtcbiAgcmV0dXJuIGlzU2hvcnRoYW5kSGV4KGhleCwgaGFzQWxwaGEpIHx8IGlzTG9uZ2hhbmRIZXgoaGV4LCBoYXNBbHBoYSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZUhleChoZXgsIGxlbmd0aCwgcGF0dGVybikge1xuICBpZiAoIWhleCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gbGVuZ3RoICYmIHBhdHRlcm4udGVzdChoZXgpO1xufVxuZnVuY3Rpb24gaXNTaG9ydGhhbmRIZXgoaGV4LCBoYXNBbHBoYSA9IGZhbHNlKSB7XG4gIGNvbnN0IGhleExlbmd0aCA9IGhhc0FscGhhID8gNSA6IDQ7XG4gIGNvbnN0IGhleFBhdHRlcm4gPSBoYXNBbHBoYSA/IHNob3J0aGFuZEhleFdpdGhBbHBoYSA6IHNob3J0aGFuZEhleDtcbiAgcmV0dXJuIGV2YWx1YXRlSGV4KGhleCwgaGV4TGVuZ3RoLCBoZXhQYXR0ZXJuKTtcbn1cbmZ1bmN0aW9uIGlzTG9uZ2hhbmRIZXgoaGV4LCBoYXNBbHBoYSA9IGZhbHNlKSB7XG4gIGNvbnN0IGhleExlbmd0aCA9IGhhc0FscGhhID8gOSA6IDc7XG4gIGNvbnN0IGhleFBhdHRlcm4gPSBoYXNBbHBoYSA/IGxvbmdoYW5kSGV4V2l0aEFscGhhIDogbG9uZ2hhbmRIZXg7XG4gIHJldHVybiBldmFsdWF0ZUhleChoZXgsIGhleExlbmd0aCwgaGV4UGF0dGVybik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVIZXgoaGV4LCBoYXNBbHBoYSA9IGZhbHNlLCBjb252ZXJ0RnJvbUhleFRvSGV4YSA9IGZhbHNlKSB7XG4gIGhleCA9IGhleC50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIWhleC5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgIGhleCA9IGAjJHtoZXh9YDtcbiAgfVxuICBpZiAoaXNTaG9ydGhhbmRIZXgoaGV4LCBoYXNBbHBoYSkpIHtcbiAgICByZXR1cm4gcmdiVG9IZXgoaGV4VG9SR0IoaGV4LCBoYXNBbHBoYSkpO1xuICB9XG4gIGlmIChoYXNBbHBoYSAmJiBjb252ZXJ0RnJvbUhleFRvSGV4YSAmJiBpc1ZhbGlkSGV4KGhleCwgZmFsc2UgLyogd2Ugb25seSBjYXJlIGFib3V0IFJHQiBoZXggZm9yIGNvbnZlcnNpb24gKi8pKSB7XG4gICAgY29uc3QgaXNTaG9ydGhhbmQgPSBpc1Nob3J0aGFuZEhleChoZXgsIGZhbHNlKTtcbiAgICByZXR1cm4gcmdiVG9IZXgoaGV4VG9SR0IoYCR7aGV4fSR7aXNTaG9ydGhhbmQgPyBcImZcIiA6IFwiZmZcIn1gLCB0cnVlKSk7XG4gIH1cbiAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIGhleGlmeShjb2xvciwgaGFzQWxwaGEgPSBmYWxzZSkge1xuICByZXR1cm4gaGFzQWxwaGEgPyBjb2xvci5oZXhhKCkgOiBjb2xvci5oZXgoKTtcbn1cbmZ1bmN0aW9uIHJnYlRvSGV4KGNvbG9yKSB7XG4gIGNvbnN0IHsgciwgZywgYiB9ID0gY29sb3I7XG4gIGNvbnN0IHJDaGFycyA9IG51bVRvSGV4KHIpO1xuICBjb25zdCBnQ2hhcnMgPSBudW1Ub0hleChnKTtcbiAgY29uc3QgYkNoYXJzID0gbnVtVG9IZXgoYik7XG4gIGNvbnN0IGFscGhhQ2hhcnMgPSBcImFcIiBpbiBjb2xvciA/IG51bVRvSGV4KGNvbG9yLmEgKiAyNTUpIDogXCJcIjtcbiAgcmV0dXJuIGAjJHtyQ2hhcnN9JHtnQ2hhcnN9JHtiQ2hhcnN9JHthbHBoYUNoYXJzfWAudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG51bVRvSGV4KG51bSkge1xuICByZXR1cm4gbnVtLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBbHBoYShjb2xvck9iamVjdCkge1xuICBjb25zdCBub3JtYWxpemVkID0geyAuLi5jb2xvck9iamVjdCwgYTogY29sb3JPYmplY3QuYWxwaGEgPz8gMSAvKiBDb2xvcigpIHdpbGwgb21pdCBhbHBoYSBpZiAxICovIH07XG4gIGRlbGV0ZSBub3JtYWxpemVkLmFscGhhO1xuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGFscGhhQ29sb3JPYmplY3QpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHsgLi4uYWxwaGFDb2xvck9iamVjdCwgYWxwaGE6IGFscGhhQ29sb3JPYmplY3QuYSA/PyAxIH07XG4gIGRlbGV0ZSBub3JtYWxpemVkLmE7XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuZnVuY3Rpb24gaGV4VG9SR0IoaGV4LCBoYXNBbHBoYSA9IGZhbHNlKSB7XG4gIGlmICghaXNWYWxpZEhleChoZXgsIGhhc0FscGhhKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhleCA9IGhleC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcbiAgbGV0IHI7XG4gIGxldCBnO1xuICBsZXQgYjtcbiAgbGV0IGE7XG4gIGNvbnN0IGlzU2hvcnRoYW5kID0gaGV4Lmxlbmd0aCA9PT0gMyB8fCBoZXgubGVuZ3RoID09PSA0O1xuICBpZiAoaXNTaG9ydGhhbmQpIHtcbiAgICBjb25zdCBbZmlyc3QsIHNlY29uZCwgdGhpcmQsIGZvdXJ0aF0gPSBoZXguc3BsaXQoXCJcIik7XG4gICAgciA9IHBhcnNlSW50KGAke2ZpcnN0fSR7Zmlyc3R9YCwgMTYpO1xuICAgIGcgPSBwYXJzZUludChgJHtzZWNvbmR9JHtzZWNvbmR9YCwgMTYpO1xuICAgIGIgPSBwYXJzZUludChgJHt0aGlyZH0ke3RoaXJkfWAsIDE2KTtcbiAgICBhID0gcGFyc2VJbnQoYCR7Zm91cnRofSR7Zm91cnRofWAsIDE2KSAvIDI1NTtcbiAgfVxuICBlbHNlIHtcbiAgICByID0gcGFyc2VJbnQoaGV4LnNsaWNlKDAsIDIpLCAxNik7XG4gICAgZyA9IHBhcnNlSW50KGhleC5zbGljZSgyLCA0KSwgMTYpO1xuICAgIGIgPSBwYXJzZUludChoZXguc2xpY2UoNCwgNiksIDE2KTtcbiAgICBhID0gcGFyc2VJbnQoaGV4LnNsaWNlKDYsIDgpLCAxNikgLyAyNTU7XG4gIH1cbiAgcmV0dXJuIGlzTmFOKGEpID8geyByLCBnLCBiIH0gOiB7IHIsIGcsIGIsIGEgfTtcbn1cbi8vIHRoZXNlIHV0aWxzIGFsbG93IHVzZXJzIHRvIHBhc3MgZW51bSB2YWx1ZXMgYXMgc3RyaW5ncyB3aXRob3V0IGhhdmluZyB0byBhY2Nlc3MgdGhlIGVudW1cbi8vIGJhc2VkIG9uIHRoZSBhcHByb2FjaCBzdWdnZXN0ZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzY5MCNpc3N1ZWNvbW1lbnQtMzIxMzY1NzU5LFxuY29uc3QgZW51bWlmeSA9ICh4KSA9PiB4O1xuY29uc3QgQ1NTQ29sb3JNb2RlID0gZW51bWlmeSh7XG4gIEhFWDogXCJoZXhcIixcbiAgSEVYQTogXCJoZXhhXCIsXG4gIFJHQl9DU1M6IFwicmdiLWNzc1wiLFxuICBSR0JBX0NTUzogXCJyZ2JhLWNzc1wiLFxuICBIU0xfQ1NTOiBcImhzbC1jc3NcIixcbiAgSFNMQV9DU1M6IFwiaHNsYS1jc3NcIixcbn0pO1xuY29uc3QgT2JqZWN0Q29sb3JNb2RlID0gZW51bWlmeSh7XG4gIFJHQjogXCJyZ2JcIixcbiAgUkdCQTogXCJyZ2JhXCIsXG4gIEhTTDogXCJoc2xcIixcbiAgSFNMQTogXCJoc2xhXCIsXG4gIEhTVjogXCJoc3ZcIixcbiAgSFNWQTogXCJoc3ZhXCIsXG59KTtcbmZ1bmN0aW9uIHBhcnNlTW9kZShjb2xvclZhbHVlKSB7XG4gIGlmICh0eXBlb2YgY29sb3JWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChjb2xvclZhbHVlLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gY29sb3JWYWx1ZTtcbiAgICAgIGlmIChsZW5ndGggPT09IDQgfHwgbGVuZ3RoID09PSA3KSB7XG4gICAgICAgIHJldHVybiBDU1NDb2xvck1vZGUuSEVYO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA9PT0gNSB8fCBsZW5ndGggPT09IDkpIHtcbiAgICAgICAgcmV0dXJuIENTU0NvbG9yTW9kZS5IRVhBO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sb3JWYWx1ZS5zdGFydHNXaXRoKFwicmdiYShcIikpIHtcbiAgICAgIHJldHVybiBDU1NDb2xvck1vZGUuUkdCQV9DU1M7XG4gICAgfVxuICAgIGlmIChjb2xvclZhbHVlLnN0YXJ0c1dpdGgoXCJyZ2IoXCIpKSB7XG4gICAgICByZXR1cm4gQ1NTQ29sb3JNb2RlLlJHQl9DU1M7XG4gICAgfVxuICAgIGlmIChjb2xvclZhbHVlLnN0YXJ0c1dpdGgoXCJoc2woXCIpKSB7XG4gICAgICByZXR1cm4gQ1NTQ29sb3JNb2RlLkhTTF9DU1M7XG4gICAgfVxuICAgIGlmIChjb2xvclZhbHVlLnN0YXJ0c1dpdGgoXCJoc2xhKFwiKSkge1xuICAgICAgcmV0dXJuIENTU0NvbG9yTW9kZS5IU0xBX0NTUztcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBjb2xvclZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKGhhc0NoYW5uZWxzKGNvbG9yVmFsdWUsIFwiclwiLCBcImdcIiwgXCJiXCIpKSB7XG4gICAgICByZXR1cm4gaGFzQ2hhbm5lbHMoY29sb3JWYWx1ZSwgXCJhXCIpID8gT2JqZWN0Q29sb3JNb2RlLlJHQkEgOiBPYmplY3RDb2xvck1vZGUuUkdCO1xuICAgIH1cbiAgICBpZiAoaGFzQ2hhbm5lbHMoY29sb3JWYWx1ZSwgXCJoXCIsIFwic1wiLCBcImxcIikpIHtcbiAgICAgIHJldHVybiBoYXNDaGFubmVscyhjb2xvclZhbHVlLCBcImFcIikgPyBPYmplY3RDb2xvck1vZGUuSFNMQSA6IE9iamVjdENvbG9yTW9kZS5IU0w7XG4gICAgfVxuICAgIGlmIChoYXNDaGFubmVscyhjb2xvclZhbHVlLCBcImhcIiwgXCJzXCIsIFwidlwiKSkge1xuICAgICAgcmV0dXJuIGhhc0NoYW5uZWxzKGNvbG9yVmFsdWUsIFwiYVwiKSA/IE9iamVjdENvbG9yTW9kZS5IU1ZBIDogT2JqZWN0Q29sb3JNb2RlLkhTVjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBoYXNDaGFubmVscyhjb2xvck9iamVjdCwgLi4uY2hhbm5lbHMpIHtcbiAgcmV0dXJuIGNoYW5uZWxzLmV2ZXJ5KChjaGFubmVsKSA9PiBjaGFubmVsICYmIGNvbG9yT2JqZWN0ICYmIGAke2NoYW5uZWx9YCBpbiBjb2xvck9iamVjdCk7XG59XG5mdW5jdGlvbiBjb2xvckVxdWFsKHZhbHVlMSwgdmFsdWUyKSB7XG4gIHJldHVybiB2YWx1ZTE/LnJnYigpLmFycmF5KCkudG9TdHJpbmcoKSA9PT0gdmFsdWUyPy5yZ2IoKS5hcnJheSgpLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBhbHBoYUNvbXBhdGlibGUobW9kZSkge1xuICByZXR1cm4gKG1vZGUgPT09IENTU0NvbG9yTW9kZS5IRVhBIHx8XG4gICAgbW9kZSA9PT0gQ1NTQ29sb3JNb2RlLlJHQkFfQ1NTIHx8XG4gICAgbW9kZSA9PT0gQ1NTQ29sb3JNb2RlLkhTTEFfQ1NTIHx8XG4gICAgbW9kZSA9PT0gT2JqZWN0Q29sb3JNb2RlLlJHQkEgfHxcbiAgICBtb2RlID09PSBPYmplY3RDb2xvck1vZGUuSFNMQSB8fFxuICAgIG1vZGUgPT09IE9iamVjdENvbG9yTW9kZS5IU1ZBKTtcbn1cbmZ1bmN0aW9uIHRvQWxwaGFNb2RlKG1vZGUpIHtcbiAgY29uc3QgYWxwaGFNb2RlID0gbW9kZSA9PT0gQ1NTQ29sb3JNb2RlLkhFWFxuICAgID8gQ1NTQ29sb3JNb2RlLkhFWEFcbiAgICA6IG1vZGUgPT09IENTU0NvbG9yTW9kZS5SR0JfQ1NTXG4gICAgICA/IENTU0NvbG9yTW9kZS5SR0JBX0NTU1xuICAgICAgOiBtb2RlID09PSBDU1NDb2xvck1vZGUuSFNMX0NTU1xuICAgICAgICA/IENTU0NvbG9yTW9kZS5IU0xBX0NTU1xuICAgICAgICA6IG1vZGUgPT09IE9iamVjdENvbG9yTW9kZS5SR0JcbiAgICAgICAgICA/IE9iamVjdENvbG9yTW9kZS5SR0JBXG4gICAgICAgICAgOiBtb2RlID09PSBPYmplY3RDb2xvck1vZGUuSFNMXG4gICAgICAgICAgICA/IE9iamVjdENvbG9yTW9kZS5IU0xBXG4gICAgICAgICAgICA6IG1vZGUgPT09IE9iamVjdENvbG9yTW9kZS5IU1ZcbiAgICAgICAgICAgICAgPyBPYmplY3RDb2xvck1vZGUuSFNWQVxuICAgICAgICAgICAgICA6IG1vZGU7XG4gIHJldHVybiBhbHBoYU1vZGU7XG59XG5mdW5jdGlvbiB0b05vbkFscGhhTW9kZShtb2RlKSB7XG4gIGNvbnN0IG5vbkFscGhhTW9kZSA9IG1vZGUgPT09IENTU0NvbG9yTW9kZS5IRVhBXG4gICAgPyBDU1NDb2xvck1vZGUuSEVYXG4gICAgOiBtb2RlID09PSBDU1NDb2xvck1vZGUuUkdCQV9DU1NcbiAgICAgID8gQ1NTQ29sb3JNb2RlLlJHQl9DU1NcbiAgICAgIDogbW9kZSA9PT0gQ1NTQ29sb3JNb2RlLkhTTEFfQ1NTXG4gICAgICAgID8gQ1NTQ29sb3JNb2RlLkhTTF9DU1NcbiAgICAgICAgOiBtb2RlID09PSBPYmplY3RDb2xvck1vZGUuUkdCQVxuICAgICAgICAgID8gT2JqZWN0Q29sb3JNb2RlLlJHQlxuICAgICAgICAgIDogbW9kZSA9PT0gT2JqZWN0Q29sb3JNb2RlLkhTTEFcbiAgICAgICAgICAgID8gT2JqZWN0Q29sb3JNb2RlLkhTTFxuICAgICAgICAgICAgOiBtb2RlID09PSBPYmplY3RDb2xvck1vZGUuSFNWQVxuICAgICAgICAgICAgICA/IE9iamVjdENvbG9yTW9kZS5IU1ZcbiAgICAgICAgICAgICAgOiBtb2RlO1xuICByZXR1cm4gbm9uQWxwaGFNb2RlO1xufVxuXG5leHBvcnQgeyBDU1NDb2xvck1vZGUgYXMgQywgaGV4aWZ5IGFzIGEsIGFscGhhVG9PcGFjaXR5IGFzIGIsIGFscGhhQ29tcGF0aWJsZSBhcyBjLCBjb2xvckVxdWFsIGFzIGQsIG5vcm1hbGl6ZUFscGhhIGFzIGUsIHRvQWxwaGFNb2RlIGFzIGYsIG5vcm1hbGl6ZUNvbG9yIGFzIGcsIGhleFRvUkdCIGFzIGgsIGlzVmFsaWRIZXggYXMgaSwgaXNMb25naGFuZEhleCBhcyBqLCBoZXhDaGFyIGFzIGssIG5vcm1hbGl6ZUhleCBhcyBuLCBvcGFjaXR5VG9BbHBoYSBhcyBvLCBwYXJzZU1vZGUgYXMgcCwgcmdiVG9IZXggYXMgciwgdG9Ob25BbHBoYU1vZGUgYXMgdCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy1hNDRkMGIzMC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=