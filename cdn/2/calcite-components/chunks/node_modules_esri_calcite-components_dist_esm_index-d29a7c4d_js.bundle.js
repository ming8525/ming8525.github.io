"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["node_modules_esri_calcite-components_dist_esm_index-d29a7c4d_js"],{

/***/ "./node_modules/@esri/calcite-components/dist/esm/index-d29a7c4d.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/esm/index-d29a7c4d.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DateEngine: () => (/* binding */ NativeDateEngine)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.0.0
 */
class NativeDateEngine {
    constructor() {
        this._formatterCache = new Map();
        this._commonDateTimeFormatterOptions = {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            timeZoneName: 'shortOffset',
        };
    }
    get name() {
        return 'native';
    }
    create(date) {
        return new Date(date);
    }
    increase(date) {
        const oneDayInMs = 86400000;
        return new Date(date.getTime() + oneDayInMs);
    }
    formatToIsoDateString(date) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        return `${year}-${month.toString().padStart(2, '0')}-${day
            .toString()
            .padStart(2, '0')}`;
    }
    isoToTimeZone(isoDate, tz) {
        const date = this._toDate(isoDate);
        const formatter = this._getFormatter(tz);
        const parts = formatter.formatToParts(date);
        const [offset] = parts
            .filter(({ type }) => type === 'timeZoneName')
            .map(({ value }) => value);
        const tzOffset = this._getTimeZoneOffsetInMins(offset);
        const tzOffsetMinutes = date.getMinutes() - (date.getTimezoneOffset() - tzOffset);
        date.setMinutes(tzOffsetMinutes);
        return date;
    }
    same(date1, date2) {
        return date1.getTime() === date2.getTime();
    }
    _toDate(isoDate) {
        return new Date(isoDate);
    }
    _getFormatter(tz) {
        let formatter = this._formatterCache.get(tz);
        if (!formatter) {
            formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: tz,
                ...this._commonDateTimeFormatterOptions,
            });
            this._formatterCache.set(tz, formatter);
        }
        return formatter;
    }
    _getTimeZoneOffsetInMins(gmtTimeZone) {
        const [sign, ...hoursMinutes] = gmtTimeZone.slice(3);
        const [hours, minutes] = hoursMinutes.join('').split(':');
        const signMultiplier = sign === '+' ? 1 : -1;
        return signMultiplier * (Number(hours) * 60 + Number(minutes || 0));
    }
}



//# sourceMappingURL=index-d29a7c4d.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsY2l0ZS1jb21wb25lbnRzL2NodW5rcy9ub2RlX21vZHVsZXNfZXNyaV9jYWxjaXRlLWNvbXBvbmVudHNfZGlzdF9lc21faW5kZXgtZDI5YTdjNGRfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssR0FBRyxrQ0FBa0MsR0FBRztBQUMvRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBDOztBQUUxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvZXNtL2luZGV4LWQyOWE3YzRkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9tYWluL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2Mi4wLjBcbiAqL1xuY2xhc3MgTmF0aXZlRGF0ZUVuZ2luZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb21tb25EYXRlVGltZUZvcm1hdHRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBtb250aDogJzItZGlnaXQnLFxuICAgICAgICAgICAgZGF5OiAnMi1kaWdpdCcsXG4gICAgICAgICAgICB0aW1lWm9uZU5hbWU6ICdzaG9ydE9mZnNldCcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ25hdGl2ZSc7XG4gICAgfVxuICAgIGNyZWF0ZShkYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgICB9XG4gICAgaW5jcmVhc2UoZGF0ZSkge1xuICAgICAgICBjb25zdCBvbmVEYXlJbk1zID0gODY0MDAwMDA7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIG9uZURheUluTXMpO1xuICAgIH1cbiAgICBmb3JtYXRUb0lzb0RhdGVTdHJpbmcoZGF0ZSkge1xuICAgICAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICBjb25zdCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICByZXR1cm4gYCR7eWVhcn0tJHttb250aC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9LSR7ZGF5XG4gICAgICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAgICAgLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgICB9XG4gICAgaXNvVG9UaW1lWm9uZShpc29EYXRlLCB0eikge1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5fdG9EYXRlKGlzb0RhdGUpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSB0aGlzLl9nZXRGb3JtYXR0ZXIodHopO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKGRhdGUpO1xuICAgICAgICBjb25zdCBbb2Zmc2V0XSA9IHBhcnRzXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gJ3RpbWVab25lTmFtZScpXG4gICAgICAgICAgICAubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKTtcbiAgICAgICAgY29uc3QgdHpPZmZzZXQgPSB0aGlzLl9nZXRUaW1lWm9uZU9mZnNldEluTWlucyhvZmZzZXQpO1xuICAgICAgICBjb25zdCB0ek9mZnNldE1pbnV0ZXMgPSBkYXRlLmdldE1pbnV0ZXMoKSAtIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLSB0ek9mZnNldCk7XG4gICAgICAgIGRhdGUuc2V0TWludXRlcyh0ek9mZnNldE1pbnV0ZXMpO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgc2FtZShkYXRlMSwgZGF0ZTIpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUxLmdldFRpbWUoKSA9PT0gZGF0ZTIuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBfdG9EYXRlKGlzb0RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGlzb0RhdGUpO1xuICAgIH1cbiAgICBfZ2V0Rm9ybWF0dGVyKHR6KSB7XG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXR0ZXJDYWNoZS5nZXQodHopO1xuICAgICAgICBpZiAoIWZvcm1hdHRlcikge1xuICAgICAgICAgICAgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2VuLVVTJywge1xuICAgICAgICAgICAgICAgIHRpbWVab25lOiB0eixcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9jb21tb25EYXRlVGltZUZvcm1hdHRlck9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlckNhY2hlLnNldCh0eiwgZm9ybWF0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyO1xuICAgIH1cbiAgICBfZ2V0VGltZVpvbmVPZmZzZXRJbk1pbnMoZ210VGltZVpvbmUpIHtcbiAgICAgICAgY29uc3QgW3NpZ24sIC4uLmhvdXJzTWludXRlc10gPSBnbXRUaW1lWm9uZS5zbGljZSgzKTtcbiAgICAgICAgY29uc3QgW2hvdXJzLCBtaW51dGVzXSA9IGhvdXJzTWludXRlcy5qb2luKCcnKS5zcGxpdCgnOicpO1xuICAgICAgICBjb25zdCBzaWduTXVsdGlwbGllciA9IHNpZ24gPT09ICcrJyA/IDEgOiAtMTtcbiAgICAgICAgcmV0dXJuIHNpZ25NdWx0aXBsaWVyICogKE51bWJlcihob3VycykgKiA2MCArIE51bWJlcihtaW51dGVzIHx8IDApKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IE5hdGl2ZURhdGVFbmdpbmUgYXMgRGF0ZUVuZ2luZSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC1kMjlhN2M0ZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=