"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-33a6ef"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/help-texts.fr-7671a600.js":
/*!**********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/help-texts.fr-7671a600.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rfxArgsHelpTexts: () => (/* binding */ rfxArgsHelpTexts)
/* harmony export */ });
const rfxArgsHelpTexts = {
	"@@Abs_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Abs_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Abs_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Abs_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Abs_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Abs_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Abs_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Abs_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Abs_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Abs_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Abs_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Abs_Raster_tag0@@": "Raster en entrée dont vous calculez les valeurs absolues.",
	"@@ACos_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@ACos_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@ACos_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@ACos_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@ACos_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@ACos_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@ACos_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@ACos_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ACos_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@ACos_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ACos_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@ACos_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de cosinus inverse.",
	"@@ACosH_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@ACosH_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@ACosH_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@ACosH_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@ACosH_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@ACosH_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@ACosH_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@ACosH_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ACosH_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@ACosH_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ACosH_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@ACosH_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de cosinus hyperbolique inverse.",
	"@@Apparent-Reflectance_Albedo_tag0@@": "Les résultats de la fonction de réflectance apparente peuvent également être exprimés en albédo, pourcentage de l'énergie disponible réfléchie par la surface planétaire. Les données albédo sont utilisées par des scientifiques dans le cadre d'applications techniques de télédétection et de modélisation complexes.",
	"@@Apparent-Reflectance_Albedo_tag1@@": "Non coché : la fonction renvoie les valeurs de réflectance apparente. Il s’agit de l’option par défaut.",
	"@@Apparent-Reflectance_Albedo_tag2@@": "Coché : la fonction renvoie des valeurs à virgule flottante 32 bits, généralement comprises entre 0.0 et 1.0. Aucun découpage de donnée n'est effectué si cette option est sélectionnée.",
	"@@Apparent-Reflectance_Albedo_tag3@@": "Le type de données en sortie pour l’albédo étant le nombre à virgule flottante, vous devez définir explicitement le <strong>Type de pixel en sortie</strong> qui convient le mieux (nombre à virgule flottante 32 bits ou double 64 bits). Le paramètre <strong>Type de pixel en sortie</strong> figure sur l’onglet <strong>Général</strong> de la fonction raster <strong>Réflectance apparente</strong>. Si le <strong>Type de pixel en sortie</strong> n’est pas correctement défini pour l’option <strong>Albédo</strong>, les valeurs résultantes ne seront pas valides et seront définies sur 0.",
	"@@Apparent-Reflectance_Offset_tag0@@": "Votre valeur albédo mise à l'échelle peut comporter une valeur de décalage :",
	"@@Apparent-Reflectance_Offset_tag1@@": "Pour les types de données 16 bits non signées, le décalage d'échelle par défaut est 5 000.",
	"@@Apparent-Reflectance_Offset_tag2@@": "Pour les types de données 8 bits non signées, le décalage d'échelle par défaut est 0.",
	"@@Apparent-Reflectance_Offset_tag3@@": "Aucune mise à l'échelle n'est appliquée lorsque la sortie est une valeur albédo.",
	"@@Apparent-Reflectance_Radiance-Gains-and-Bias-Values-per-Band_tag0@@": "Vous pouvez définir ou modifier manuellement cette valeur pour chaque canal. Les informations appropriées peuvent être lues à partir des métadonnées du produit raster en entrée.",
	"@@Apparent-Reflectance_Raster_tag0@@": "Le produit raster sur lequel appliquer la réflectance apparente.",
	"@@Apparent-Reflectance_Scale-Factor_tag0@@": "La valeur en sortie de votre réflectance apparente peut s'exprimer sous la forme d'un entier. Le facteur d'échelle est multiplié par la valeur albédo pour convertir toutes les valeurs à virgule flottante en valeurs entières.",
	"@@Apparent-Reflectance_Scale-Factor_tag1@@": "Si le facteur d’échelle est ${0} ou n’est pas spécifié, la mise à l’échelle par défaut est appliquée selon le type de pixel des données en entrée :",
	"@@Apparent-Reflectance_Scale-Factor_tag2@@": "Pour les types de données 16 bits non signées, le facteur d'échelle par défaut est 50 000.",
	"@@Apparent-Reflectance_Scale-Factor_tag3@@": "Pour les types de données 8 bits non signées, le facteur d'échelle par défaut est 225.",
	"@@Apparent-Reflectance_Scale-Factor_tag4@@": "Le facteur d'échelle est toujours appliqué lorsque la sortie est une réflectance apparente. Aucune mise à l'échelle n'est appliquée lorsque la sortie est une valeur albédo.",
	"@@Apparent-Reflectance_Sun-Elevation_tag0@@": "Il s'agit de la valeur d'altitude du soleil, exprimée en degrés. Elle est renseignée par le système si les informations appropriées sont lisibles à partir des métadonnées. Vous pouvez définir ou modifier manuellement cette valeur.",
	"@@ArgStatistics_Max_tag0@@": "La valeur maximale que vous définissez est la valeur la plus haute inférieure ou égale à la fin de la durée.",
	"@@ArgStatistics_Max_tag1@@": "Cette entrée s’applique uniquement dans le cas de la méthode Duration.",
	"@@ArgStatistics_Method_tag0@@": "Sélectionnez la méthode de statistiques à calculer :",
	"@@ArgStatistics_Method_tag1@@": "Arg Max : argument du maximum, qui renvoie le ${Band index} pour lequel le pixel donné atteint sa valeur minimale de tous les canaux. Tous les canaux de raster provenant de chaque raster en entrée se voient attribuer un index de canal incrémentiel de base 0, qui est classé d’abord selon l’index de raster en entrée, puis selon l’ordre relatif des canaux dans chaque raster en entrée.",
	"@@ArgStatistics_Method_tag2@@": "Arg Median : argument de la médiane, qui retourne le ${Band index} pour lequel le pixel donné atteint la valeur médiane des valeurs de tous les canaux.",
	"@@ArgStatistics_Method_tag3@@": "Arg Min : argument du minimum, qui retourne le ${Band index} pour lequel le pixel donné atteint sa valeur minimale de tous les canaux.",
	"@@ArgStatistics_Method_tag4@@": "Durée : la méthode Durée trouve les éléments consécutifs les plus longs de la matrice, où chaque élément possède une valeur supérieure ou égale à <strong>Min</strong> et inférieure ou égale à <strong>Max</strong>, puis renvoie la longueur de chacun.",
	"@@ArgStatistics_Min_tag0@@": "La valeur minimale que vous définissez est la valeur la plus basse supérieure ou égale au début de la durée.",
	"@@ArgStatistics_Min_tag1@@": "Cette entrée s’applique uniquement dans le cas de la méthode Duration.",
	"@@ArgStatistics_Rasters_tag0@@": "Raster en entrée sur lequel vous allez exécuter les différents méthodes statistiques.",
	"@@ArgStatistics_Undefined-Class_tag0@@": "Constante en entrée qui sera retournée si aucun maximum, minimum ou médiane ne peut être atteint. Le scénario le plus courant se produit lorsque la valeur maximale ou minimale survient plusieurs fois parmi les valeurs de tous les canaux. La valeur par défaut du champ de la constante non définie est 100.",
	"@@ArgStatistics_Undefined-Class_tag1@@": "La classe non définie concerne uniquement les cas dans lesquels la méthode est <strong>ArgMax</strong>, <strong>ArgMin</strong> ou <strong>ArgMedian</strong>.",
	"@@ArgStatistics_ignorenodata_tag0@@": "Indique si les valeurs NoData sont ignorées dans le calcul des statistiques.",
	"@@ArgStatistics_ignorenodata_tag1@@": "Activé : l’analyse inclut tous les pixels valides dans les rasters en entrée et ignore les pixels NoData.",
	"@@ArgStatistics_ignorenodata_tag2@@": "Désactivé : l’analyse renvoie des valeurs NoData si les pixels dans les rasters en entrée présentent des valeurs NoData. Il s’agit de l’option par défaut.",
	"@@Arithmetic_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Arithmetic_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Arithmetic_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Arithmetic_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Arithmetic_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Arithmetic_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Arithmetic_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Arithmetic_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Arithmetic_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Arithmetic_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Arithmetic_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Arithmetic_Operation_tag0@@": "Opérateur arithmétique à effectuer entre les deux rasters en entrée.",
	"@@Arithmetic_Operation_tag1@@": "Les options sont les suivantes :",
	"@@Arithmetic_Operation_tag2@@": "<strong>Division</strong> : génère le quotient entre les valeurs de pixels correspondantes pour chaque raster.",
	"@@Arithmetic_Operation_tag4@@": "<strong>Soustraction</strong> : génère la différence entre les valeurs de pixels correspondantes pour chaque raster. Cela permet de calculer la détection des changements.",
	"@@Arithmetic_Operation_tag6@@": "<strong>Mode</strong> : génère la valeur de pixel la plus fréquente pour tous les pixels superposés. Si, par exemple, le raster compte six bandes, il y aura six pixels superposés. Pour les valeurs 4, 5, 6, 4, 7, 9, la valeur de mode est 4.",
	"@@Arithmetic_Operation_tag8@@": "<strong>Multiplication</strong> : génère le produit des valeurs de pixels correspondantes pour chaque raster. Cette option permet d’exécuter des fonctions de coût.",
	"@@Arithmetic_Operation_tag10@@": "<strong>Addition</strong> : génère la somme de toutes les valeurs de pixels correspondantes pour chaque raster.",
	"@@Arithmetic_Operation_tag12@@": "<strong>Puissance</strong> : génère le produit des valeurs de pixels correspondantes, élevé à la puissance du raster ou scalaire en entrée.",
	"@@Arithmetic_Raster_tag0@@": "Le premier jeu de données raster en entrée.",
	"@@Arithmetic_Raster2_tag0@@": "Deuxième jeu de données raster en entrée.",
	"@@ASin_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@ASin_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@ASin_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@ASin_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@ASin_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@ASin_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@ASin_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@ASin_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ASin_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@ASin_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ASin_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@ASin_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de sinus inverse.",
	"@@ASinH_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@ASinH_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@ASinH_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@ASinH_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@ASinH_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@ASinH_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@ASinH_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@ASinH_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ASinH_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@ASinH_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ASinH_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@ASinH_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de sinus hyperbolique inverse.",
	"@@Aspect_Raster_tag0@@": "Le MNA utilisé pour dériver le jeu de données d’exposition.",
	"@@Aspect-Slope_Raster_tag0@@": "DEM en entrée.",
	"@@Aspect-Slope_Z-Factor_tag0@@": "Un facteur d’échelle utilisé pour convertir les valeurs d’altitude dans les deux buts suivants :",
	"@@Aspect-Slope_Z-Factor_tag1@@": "Convertit les unités d'altitude (telles que les mètres ou les pieds) en unités de coordonnées horizontales du jeu de données, qui peuvent être des pieds, des mètres ou des degrés,",
	"@@Aspect-Slope_Z-Factor_tag2@@": "Ajoute une exagération verticale comme effet visuel.",
	"@@ATan_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@ATan_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@ATan_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@ATan_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@ATan_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@ATan_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@ATan_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@ATan_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ATan_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@ATan_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ATan_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@ATan_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de tangente inverse.",
	"@@ATan2_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@ATan2_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@ATan2_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@ATan2_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@ATan2_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@ATan2_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@ATan2_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@ATan2_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ATan2_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@ATan2_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ATan2_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@ATan2_Raster_tag0@@": "Entrée spécifiant le numérateur, ou la valeur y, à utiliser lors du calcul de la tangente inverse.",
	"@@ATan2_Raster2_tag0@@": "Entrée spécifiant le dénominateur, ou la valeur x, à utiliser lors du calcul de la tangente inverse.",
	"@@ATanH_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@ATanH_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@ATanH_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@ATanH_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@ATanH_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@ATanH_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@ATanH_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@ATanH_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ATanH_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@ATanH_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@ATanH_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@ATanH_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de tangente hyperbolique inverse.",
	"@@Attribute-Table_Raster_tag0@@": "Raster en entrée.",
	"@@Attribute-Table_Table-Type_tag0@@": "La table attributaire en entrée peut être renseignée à l’aide du type <strong>Manuel</strong> où vous attribuez un nom de classe et une couleur à chaque valeur, ou vous pouvez faire référence à une table existante qui provient d’un fichier ${.dbf}.",
	"@@Band-Arithmetic_Band-Indexes_tag0@@": "Définissez votre formule arithmétique de bande si vous avez choisi <strong>Défini par l’utilisateur</strong> pour <strong>Méthode</strong>.",
	"@@Band-Arithmetic_Band-Indexes_tag5@@": "Si vous avez choisi un indice prédéfini pour <strong>Méthode</strong>, définissez les bandes appropriées de votre jeu de données raster en entrée correspondant à l’indice.",
	"@@Band-Arithmetic_Method_tag0@@": "Type d’algorithme arithmétique de canal que vous souhaitez déployer. Vous pouvez définir votre algorithme personnalisé ou choisir un indice prédéfini.",
	"@@Band-Arithmetic_Method_tag1@@": "<strong>BAI</strong> : indice de zones brûlées",
	"@@Band-Arithmetic_Method_tag2@@": "<strong>CIg</strong> : indice chlorophyllien - Vert",
	"@@Band-Arithmetic_Method_tag3@@": "<strong>CIre</strong> : indice chlorophyllien - Proche infrarouge",
	"@@Band-Arithmetic_Method_tag4@@": "<strong>Minéraux argileux</strong> : rapport de minéraux argileux",
	"@@Band-Arithmetic_Method_tag5@@": "<strong>EVI</strong> : indice de végétation amélioré",
	"@@Band-Arithmetic_Method_tag6@@": "<strong>Minéraux ferreux</strong> : rapport de minéraux ferreux",
	"@@Band-Arithmetic_Method_tag7@@": "<strong>GEMI</strong> : indice de surveillance environnementale globale",
	"@@Band-Arithmetic_Method_tag8@@": "<strong>GNDVI</strong> : indice de végétation par différence normalisée - Vert",
	"@@Band-Arithmetic_Method_tag9@@": "<strong>GVI (Landsat TM)</strong> : indice de végétation - Landsat TM",
	"@@Band-Arithmetic_Method_tag10@@": "<strong>Oxyde de fer</strong> : rapport d’oxyde de fer",
	"@@Band-Arithmetic_Method_tag11@@": "<strong>MNDWI</strong> : indice de teneur en eau modifié par différence normalisée",
	"@@Band-Arithmetic_Method_tag12@@": "<strong>MTVI2</strong> : indice de végétation triangulé modifié (deuxième itération)",
	"@@Band-Arithmetic_Method_tag13@@": "<strong>SAVI modifié</strong> : indice de végétation ajusté en fonction du sol et modifié",
	"@@Band-Arithmetic_Method_tag14@@": "<strong>NBR</strong> : indice du ratio de brûlure normalisé",
	"@@Band-Arithmetic_Method_tag15@@": "<strong>NDBI</strong> : indice d’urbanisation par différence normalisée",
	"@@Band-Arithmetic_Method_tag16@@": "<strong>NDMI</strong> : indice d'humidité par différence normalisée",
	"@@Band-Arithmetic_Method_tag17@@": "<strong>NDSI</strong> : indice d’enneigement par différence normalisée",
	"@@Band-Arithmetic_Method_tag18@@": "<strong>NDVI</strong> : indice de végétation par différence normalisée",
	"@@Band-Arithmetic_Method_tag19@@": "<strong>NDVIre</strong> : indice de végétation par différence normalisée - Proche infrarouge",
	"@@Band-Arithmetic_Method_tag20@@": "<strong>NDWI</strong> : indice de teneur en eau par différence normalisée",
	"@@Band-Arithmetic_Method_tag21@@": "<strong>PVI</strong> : indice de végétation perpendiculaire",
	"@@Band-Arithmetic_Method_tag22@@": "<strong>RTVICore</strong> : indice de végétation triangulé - Proche infrarouge",
	"@@Band-Arithmetic_Method_tag23@@": "<strong>SAVI</strong> : indice de végétation ajusté en fonction du sol",
	"@@Band-Arithmetic_Method_tag24@@": "<strong>SR</strong> : ratio simple",
	"@@Band-Arithmetic_Method_tag25@@": "<strong>SRre</strong> : ratio simple - Proche infrarouge",
	"@@Band-Arithmetic_Method_tag26@@": "<strong>Formule de Sultan</strong> : formule de Sultan",
	"@@Band-Arithmetic_Method_tag27@@": "<strong>SAVI transformé</strong> : indice de végétation ajusté en fonction du sol et transformé",
	"@@Band-Arithmetic_Method_tag28@@": "<strong>Défini par l’utilisateur</strong> : permet de définir votre expression arithmétique de canal personnalisé.",
	"@@Band-Arithmetic_Method_tag29@@": "<strong>VARI</strong> : indice visible de réduction des effets atmosphériques",
	"@@Band-Arithmetic_Method_tag30@@": "<strong>WNDWI</strong> : indice de végétation par différence normalisée pondéré",
	"@@Band-Arithmetic_Raster_tag0@@": "Raster en entrée.",
	"@@Binary-Thresholding_Raster_tag0@@": "Raster en entrée.",
	"@@Bitwise-And_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Bitwise-And_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Bitwise-And_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Bitwise-And_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Bitwise-And_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Bitwise-And_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Bitwise-And_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Bitwise-And_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-And_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Bitwise-And_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-And_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Bitwise-And_Raster_tag0@@": "Première entrée à utiliser dans cette opération bit à bit.",
	"@@Bitwise-And_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Bitwise-And_Raster2_tag0@@": "Deuxième entrée à utiliser dans cette opération bit à bit.",
	"@@Bitwise-And_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Bitwise-Left-Shift_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Bitwise-Left-Shift_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-Left-Shift_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Bitwise-Left-Shift_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-Left-Shift_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Bitwise-Left-Shift_Raster_tag0@@": "Entrée sur laquelle exécuter le décalage.",
	"@@Bitwise-Left-Shift_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Bitwise-Left-Shift_Raster2_tag0@@": "Entrée définissant le nombre de positions duquel déplacer les bits.",
	"@@Bitwise-Left-Shift_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Bitwise-Not_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Bitwise-Not_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Bitwise-Not_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Bitwise-Not_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Bitwise-Not_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Bitwise-Not_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Bitwise-Not_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Bitwise-Not_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-Not_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Bitwise-Not_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-Not_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Bitwise-Not_Raster_tag0@@": "Raster en entrée sur lequel exécuter une opération de complément Non bit à bit.",
	"@@Bitwise-Or_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Bitwise-Or_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Bitwise-Or_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Bitwise-Or_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Bitwise-Or_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Bitwise-Or_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Bitwise-Or_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Bitwise-Or_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-Or_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Bitwise-Or_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-Or_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Bitwise-Or_Raster_tag0@@": "Première entrée à utiliser dans cette opération bit à bit.",
	"@@Bitwise-Or_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Bitwise-Or_Raster2_tag0@@": "Deuxième entrée à utiliser dans cette opération bit à bit.",
	"@@Bitwise-Or_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Bitwise-Right-Shift_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Bitwise-Right-Shift_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-Right-Shift_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Bitwise-Right-Shift_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-Right-Shift_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Bitwise-Right-Shift_Raster_tag0@@": "Entrée sur laquelle exécuter le décalage.",
	"@@Bitwise-Right-Shift_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Bitwise-Right-Shift_Raster2_tag0@@": "Entrée définissant le nombre de positions duquel déplacer les bits.",
	"@@Bitwise-Right-Shift_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Bitwise-Xor_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Bitwise-Xor_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Bitwise-Xor_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Bitwise-Xor_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Bitwise-Xor_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Bitwise-Xor_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Bitwise-Xor_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Bitwise-Xor_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-Xor_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Bitwise-Xor_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Bitwise-Xor_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Bitwise-Xor_Raster_tag0@@": "Première entrée à utiliser dans cette opération bit à bit.",
	"@@Bitwise-Xor_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Bitwise-Xor_Raster2_tag0@@": "Deuxième entrée à utiliser dans cette opération bit à bit.",
	"@@Bitwise-Xor_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Boolean-and_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Boolean-and_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Boolean-and_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Boolean-and_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Boolean-and_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Boolean-and_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Boolean-and_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Boolean-and_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Boolean-and_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Boolean-and_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Boolean-and_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Boolean-and_Raster_tag0@@": "Première entrée à utiliser dans cette opération booléenne.",
	"@@Boolean-and_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Boolean-and_Raster2_tag0@@": "Deuxième entrée à utiliser dans cette opération booléenne.",
	"@@Boolean-and_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Boolean-Not_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Boolean-Not_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Boolean-Not_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Boolean-Not_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Boolean-Not_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Boolean-Not_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Boolean-Not_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Boolean-Not_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Boolean-Not_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Boolean-Not_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Boolean-Not_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Boolean-Not_Raster_tag0@@": "Première entrée à utiliser dans cette opération booléenne.",
	"@@Boolean-Or_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Boolean-Or_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Boolean-Or_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Boolean-Or_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Boolean-Or_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Boolean-Or_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Boolean-Or_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Boolean-Or_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Boolean-Or_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Boolean-Or_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Boolean-Or_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Boolean-Or_Raster_tag0@@": "Première entrée à utiliser dans cette opération booléenne.",
	"@@Boolean-Or_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Boolean-Or_Raster2_tag0@@": "Deuxième entrée à utiliser dans cette opération booléenne.",
	"@@Boolean-Or_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Boolean-Xor_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Boolean-Xor_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Boolean-Xor_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Boolean-Xor_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Boolean-Xor_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Boolean-Xor_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Boolean-Xor_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Boolean-Xor_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Boolean-Xor_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Boolean-Xor_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Boolean-Xor_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Boolean-Xor_Raster_tag0@@": "Première entrée à utiliser dans cette opération booléenne.",
	"@@Boolean-Xor_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Boolean-Xor_Raster2_tag0@@": "Deuxième entrée à utiliser dans cette opération booléenne.",
	"@@Boolean-Xor_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Buffered_Raster_tag0@@": "Le raster en entrée à stocker en mémoire.",
	"@@Calculator_Cellsize-Type_tag0@@": "La taille de cellule utilisée pour créer le raster en sortie.",
	"@@Calculator_Cellsize-Type_tag1@@": "Vous pouvez choisir la taille de cellule en sortie à l’aide des options suivantes de la liste déroulante :",
	"@@Calculator_Cellsize-Type_tag2@@": "<strong>Premier de</strong> : taille de cellule de la première variable raster.",
	"@@Calculator_Cellsize-Type_tag4@@": "<strong>Min de</strong> : taille de cellule minimale des rasters en entrée.",
	"@@Calculator_Cellsize-Type_tag6@@": "<strong>Max de</strong> : taille de cellule maximale des rasters en entrée.",
	"@@Calculator_Cellsize-Type_tag8@@": "<strong>Moyenne de</strong> : taille de cellule moyenne des rasters en entrée.",
	"@@Calculator_Cellsize-Type_tag10@@": "<strong>Dernier de</strong> : taille de cellule de la dernière variable raster.",
	"@@Calculator_Cellsize-Type_tag12@@": "La sélection par défaut est <strong>Max de</strong>.",
	"@@Calculator_Expression_tag0@@": "Construire une expression algébrique pour effectuer l’analyse spatiale sur le raster en entrée.",
	"@@Calculator_Expression_tag1@@": "Toutes les fonctions mathématiques existantes peuvent être appelées pour construire l’expression. Les opérateurs disponibles sont répertoriés ci-dessous.",
	"@@Calculator_Expression_tag2@@": "Opérations arithmétiques",
	"@@Calculator_Expression_tag3@@": "Addition : +",
	"@@Calculator_Expression_tag4@@": "Division : /",
	"@@Calculator_Expression_tag5@@": "Modulo : %",
	"@@Calculator_Expression_tag6@@": "Multiplication : *",
	"@@Calculator_Expression_tag7@@": "Puissance : **",
	"@@Calculator_Expression_tag8@@": "Soustraction : -",
	"@@Calculator_Expression_tag9@@": "Opérations booléennes",
	"@@Calculator_Expression_tag10@@": "Et booléen : &&",
	"@@Calculator_Expression_tag11@@": "Ou booléen : ||",
	"@@Calculator_Expression_tag12@@": "Opérations relationnelles",
	"@@Calculator_Expression_tag13@@": "Égal à :==",
	"@@Calculator_Expression_tag14@@": "Supérieur à : >",
	"@@Calculator_Expression_tag15@@": "Supérieur ou égal à : >=",
	"@@Calculator_Expression_tag16@@": "Inférieur à : <",
	"@@Calculator_Expression_tag17@@": "Inférieur ou égal à : <=",
	"@@Calculator_Expression_tag18@@": "N’est pas égal à : !=",
	"@@Calculator_Expression_tag19@@": "Opérations supplémentaires",
	"@@Calculator_Expression_tag20@@": "Minimum de deux rasters, pixel par pixel : min(a,b)",
	"@@Calculator_Expression_tag21@@": "Maximum de deux rasters, pixel par pixel : max(a,b)",
	"@@Calculator_Expression_tag22@@": "Voici quelques exemples d’expressions.",
	"@@Calculator_Expression_tag23@@": "Instruction conditionnelle simple : dans un raster (indiqué par la lettre T) recherchez les valeurs d’altitude supérieures à 4 000 pieds et attribuez à ces zones la valeur 1 et la valeur 0 à toutes les autres zones.",
	"@@Calculator_Expression_tag24@@": "Con(T > 4000, 1, 0)",
	"@@Calculator_Expression_tag25@@": "Instruction conditionnelle imbriquée : recherchez les zones où la pente (indiquée par b1)) est inférieure à 10 degrés et l’indice NDVI (indiqué par b2) est supérieur à 0,5, et attribuez à ces zones la valeur 1. Pour toutes les autres zones, attribuez la valeur 2 si la pente est supérieure à 10 degrés et l’altitude (indiquée par b3) est supérieure à 2 500 pieds. La valeur 3 est attribuée à toutes les autres zones.",
	"@@Calculator_Expression_tag26@@": "Con((b1 < 10 && b2 > .5, 1, Con(b1 > 10 && b3 > 2500, 2, 3)))",
	"@@Calculator_extenttype_tag0@@": "<p>Sélectionnez l’étendue à utiliser dans le raster en sortie :</p><ul><li><p>Premier de : utiliser l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.</p></li><li>Intersection de : utiliser l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.</li><li>Union de : utiliser l’étendue de tous les rasters pour déterminer l’étendue de traitement.</li><li>Dernier de : utiliser l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.</li></ul>",
	"@@Calculator_Raster-Variables_tag0@@": "Le nom de la variable définie par l’utilisateur et le raster en entrée.",
	"@@Classify_Input-Definition-File_tag0@@": "Fichier de définition de classificateur Esri en entrée (${.ecd}) qui contient les statistiques et d’autres informations de classification pour le jeu de données, le classificateur et les attributs choisis.",
	"@@Classify_Raster_tag0@@": "Jeu de données raster à classer.",
	"@@Classify_Raster2_tag0@@": "Jeu de données raster auxiliaire facultatif à incorporer au classificateur, tel qu’une image segmentée, une image multispectrale ou des données d’altitude, utilisé pour générer une définition de classification plus robuste pour votre ensemble de données. Le jeu de données raster pour ce paramètre doit correspondre à celui qui a été utilisé pour créer le fichier de définition de classificateur Esri en entrée.",
	"@@Clip_Clipping-Geometry-or-Raster_tag0@@": "Les éléments suivants peuvent être utilisés pou spécifier l’étendue de découpage :",
	"@@Clip_Clipping-Geometry-or-Raster_tag1@@": "<strong>Découpage du raster</strong> : étendue de découpage du raster.",
	"@@Clip_Clipping-Geometry-or-Raster_tag3@@": "<strong>Étendue personnalisée</strong> : coordonnées X et Y minimales et maximales",
	"@@Clip_Clipping-Geometry-or-Raster_tag5@@": "<strong>Étendue actuelle de la carte</strong> : étendue de l’affichage cartographique actuel",
	"@@Clip_Clipping-Raster_tag0@@": "La couche raster utilisée pour le découpage.",
	"@@Clip_Clipping-Type_tag0@@": "Indiquez si vous voulez que la zone figure à l’intérieur ou à l’extérieur de la géométrie de découpage.",
	"@@Clip_Clipping-Type_tag1@@": "<strong>Découpage intérieur</strong> : l’imagerie qui se trouve dans l’étendue de découpage sera supprimée.",
	"@@Clip_Clipping-Type_tag3@@": "<strong>Découpage extérieur</strong> : l’imagerie qui se trouve hors de l’étendue de découpage sera supprimée.",
	"@@Clip_Custom-Extent_tag0@@": "Spécifier les quatre coordonnées qui définissent l’étendue de l’emprise utilisée pour découper le raster.",
	"@@Clip_Output-Extent_tag0@@": "Les coordonnées x et y de l’étendue de découpage actuelle.",
	"@@Clip_Output-Extent_tag1@@": "Le bouton <strong>Capturer l’étendue actuelle de la carte</strong> utilise l’étendue d’affichage de la carte active.",
	"@@Clip_Raster_tag0@@": "Couche raster en entrée.",
	"@@Clip_Use-Input-Features-for-Clipping-Geometry_tag0@@": "Une fois sélectionnées, les données sont découpées selon la géométrie de la classe d’entités spécifiée",
	"@@Clip_Use-Input-Features-for-Clipping-Geometry_tag1@@": "Désactivé : la fonction utilise la géométrie de découpage spécifiée par l’option <strong>Rectangle</strong>. Il s’agit de l’option par défaut.",
	"@@Clip_Use-Input-Features-for-Clipping-Geometry_tag4@@": "Coché : la fonction utilise la géométrie de découpage définie par une classe d’entités.",
	"@@Color-Model-Conversion_Conversion-Type_tag0@@": "Le type de conversion de couleur à effectuer :",
	"@@Color-Model-Conversion_Conversion-Type_tag1@@": "TSL vers RVB",
	"@@Color-Model-Conversion_Conversion-Type_tag2@@": "RVB vers TSL",
	"@@Color-Model-Conversion_Raster_tag0@@": "Raster en entrée.",
	"@@Colormap_Color-Ramp_tag0@@": "Choisissez un dégradé de couleurs existant.",
	"@@Colormap_Color-Scheme-Type_tag0@@": "Choisissez le type de combinaison de couleurs à utiliser pour afficher votre raster en entrée",
	"@@Colormap_Color-Scheme-Type_tag1@@": "Dégradé de couleurs : utilisez un dégradé de couleurs.",
	"@@Colormap_Color-Scheme-Type_tag2@@": "Palette de couleurs : utilisez une palette de couleurs existante.",
	"@@Colormap_Colormap_tag0@@": "Les palettes de couleurs par défaut suivantes sont disponibles dans la liste déroulante :",
	"@@Colormap_Colormap_tag1@@": "Altitude : palette de couleurs qui passe progressivement du cyan au mauve, puis au noir.",
	"@@Colormap_Colormap_tag2@@": "Gris : palette de couleurs qui passe progressivement du noir au blanc.",
	"@@Colormap_Colormap_tag7@@": "Ombrage : palette de couleurs en échelle de gris servant à visualiser une représentation 3D de la surface du terrain, avec prise en compte de la position relative du soleil pour l’ombrage de l’image.",
	"@@Colormap_Colormap_tag3@@": "NDVI : palette de couleurs permettant de visualiser la végétation. Les valeurs proches de zéro correspondent au bleu. Les valeurs faibles correspondent au marron. Ensuite, les couleurs passent progressivement du rouge au orange, puis au jaune, au vert et enfin au noir, car l’index de végétation va des valeurs faibles aux plus élevées.",
	"@@Colormap_Colormap_tag4@@": "NDVI2 : palette de couleurs permettant de visualiser la végétation. La plage des valeurs faibles va du blanc au vert. Ensuite, les couleurs vont du gris au mauve, au violet, puis au bleu foncé et enfin au noir, à mesure que l’index de végétation passe de faible à élevé.",
	"@@Colormap_Colormap_tag5@@": "NDVI3 : palette de couleurs permettant de visualiser la végétation. Les valeurs proches de zéro correspondent au bleu. Ensuite, les couleurs passent progressivement du rouge au orange, puis au vert, car l’index de végétation va des valeurs faibles aux plus élevées.",
	"@@Colormap_Colormap_tag6@@": "Aléatoire : palette de couleurs aléatoires.",
	"@@Colormap_Raster_tag0@@": "Raster en entrée.",
	"@@Colormap-To-RGB_Raster_tag0@@": "Raster de la palette de couleurs en entrée.",
	"@@Complex_Raster_tag0@@": "Raster en entrée.",
	"@@Composite-Bands_Rasters_tag0@@": "Utilisez la liste déroulante ou le bouton <strong>Parcourir</strong> pour choisir les entrées raster.",
	"@@Composite-Bands_cellsizetype_tag0@@": "<p>Choisir la taille de cellule à utiliser dans le raster en sortie. Si toutes les tailles de cellule en entrée sont identiques, toutes les options donnent les mêmes résultats.</p><ul><li>Premier de : utiliser la première taille de cellule des rasters en entrée.</li><li>Min de : utiliser la plus petite taille de cellule de tous les rasters en entrée.</li><li>Max de : utiliser la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.</li><li>Moyenne de : utiliser la taille de cellule moyenne de tous les rasters en entrée.</li><li>Dernier de : utiliser la dernière taille de cellule des rasters en entrée.</li></ul>",
	"@@Con-function_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Con-function_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Con-function_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Con-function_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Con-function_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Con-function_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Con_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Con_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Con_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Con_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Con_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Con_False-Raster_tag0@@": "Entrée dont les valeurs seront utilisées en tant que valeurs de pixel en sortie si la condition est fausse. Il peut s’agir d’un raster de type entier, à virgule flottante ou d’une valeur constante.",
	"@@Con_Raster_tag0@@": "Le raster en entrée qui représente le résultat booléen d’une fonction raster mathématique logique. Les valeurs sont égales à 1 (pour Vrai) ou à 0 (pour Faux). Il peut s'agir d'un entier ou d'un raster en virgule flottante.",
	"@@Con_True-Raster_tag0@@": "Entrée dont les valeurs seront utilisées en tant que valeurs de pixel en sortie si la condition est vraie. Il peut s’agir d’un raster de type entier, à virgule flottante ou d’une valeur constante.",
	"@@Constant_Constant_tag0@@": "La valeur de la constante à ajouter au raster virtuel.",
	"@@Constant_Raster-Info_tag0@@": "Utilisez le bouton <strong>Charger le raster modèle</strong> pour charger un modèle à partir d’un répertoire ou d’un portail.",
	"@@Contour_Adaptive-Smoothing_tag0@@": "Quantité de lissage à appliquer à l'isoligne. La valeur par défaut est 2.5.",
	"@@Contour_Adaptive-Smoothing_tag1@@": "Une valeur inférieure produit une isoligne avec plus de granularité et moins de lissage, tandis qu'une valeur supérieure génère une isoligne avec plus de lissage qui semble moins irrégulière.",
	"@@Contour_Contour-Interval_tag0@@": "Différence en altitude entre les isolignes.",
	"@@Contour_Contour-Interval_tag1@@": "Un petit intervalle d’isolignes est utilisé dans les zones relativement planes, tandis qu’un intervalle plus élevé est utilisé pour les terrains variables ou montagneux.",
	"@@Contour_Contour-Type_tag0@@": "Type d'isoligne à créer :",
	"@@Contour_Contour-Type_tag1@@": "<strong>Remplissage d’isolignes</strong> : remplit la zone située entre chaque isoligne avec la valeur d’élévation quantifiée.",
	"@@Contour_Contour-Type_tag3@@": "<strong>Isolignes</strong> : joint les points d’élévation égale pour créer une ligne représentant une élévation constante.",
	"@@Contour_Contour-Type_tag5@@": "<strong>Surface lisse uniquement</strong> : lisse la couche d’élévation en entrée, mais ne génère pas d’isolignes.",
	"@@Contour_Nth-Contour-Line-In-Bold_tag0@@": "Isoligne d'index, qui est représentée sous forme de ligne en gras.",
	"@@Contour_Nth-Contour-Line-In-Bold_tag1@@": "La valeur par défaut est 5, c’est-à-dire qu’une isoligne sur 5 est en gras.",
	"@@Contour_Number-Of-Contours_tag0@@": "Nombre d’isolignes à générer sur l’affichage. Ajuste dynamiquement l'intervalle des isolignes pour les adapter au MNT sur l'affichage tout en conservant les intervalles standardisés, tels que 1, 5, 10, etc.",
	"@@Contour_Raster_tag0@@": "Jeu de données d'altitude raster monocanal.",
	"@@Contour_Z-Base_tag0@@": "Valeur de l'isoligne de base. Les isolignes sont générées au-dessus et en dessous de cette valeur de façon à couvrir la plage de valeurs complète du raster en entrée. La valeur par défaut est 0.",
	"@@Contour_Z-Base_tag1@@": "La valeur 0 représente souvent le niveau moyen de la mer, selon le jeu de données d'altitude source.",
	"@@Contour_Z-Factor_tag0@@": "Facteur de conversion d'unités utilisé lors de la génération des isolignes. La valeur par défaut est 1.",
	"@@Contour_Z-Factor_tag1@@": "Les isolignes sont générées en fonction des valeurs z dans le raster en entrée, qui sont souvent mesurées en mètres ou en pieds. Avec la valeur par défaut 1, les isolignes sont dans les mêmes unités que les valeurs z du raster en entrée. Pour créer des isolignes dans une autre unité que celle des valeurs z, définissez une valeur appropriée pour le facteur z. Notez qu'il n'est pas nécessaire que les unités x,y au sol et les unités z de surface soient homogènes pour cet outil.",
	"@@Contour_Z-Factor_tag2@@": "Par exemple, si les valeurs d’altitude de votre raster en entrée sont en pieds, mais que vous voulez que les isolignes soient générées en mètres, définissez le facteur z sur 0,3048 (car 1 pied = 0,3048 mètres).",
	"@@Contrast-and-Brightness_Brightness-Offset_tag0@@": "Réglez la luminosité de la couche raster.",
	"@@Contrast-and-Brightness_Brightness-Offset_tag1@@": "Vous pouvez utiliser le curseur pour modifier la luminosité, ou saisir une valeur.",
	"@@Contrast-and-Brightness_Contrast-Offset_tag0@@": "Réglez le contraste de la couche raster.",
	"@@Contrast-and-Brightness_Contrast-Offset_tag1@@": "Vous pouvez utiliser le curseur pour modifier le contraste, ou saisir une valeur.",
	"@@Contrast-and-Brightness_Raster_tag0@@": "Raster en entrée sur lequel modifier la luminosité et le contraste.",
	"@@Convolution_kernel_tag0@@": "<p>Cette table illustre la manière dont chaque pixel sera pondéré au cours du filtrage. Cette table peut être mise à jour si vous paramétrez le <strong>Type</strong> sur <strong>Défini par l’utilisateur</strong>.</p>",
	"@@Convolution_Raster_tag0@@": "Jeu de données raster en entrée.",
	"@@Convolution_Type_tag0@@": "Sélectionnez le type de filtrage à effectuer : Des options permettent d’affiner, de brouiller une image ou détecter des tronçons, mais vous pouvez également définir votre propre filtre de type noyau",
	"@@Corridor_Distance-Raster-1_tag0@@": "Premier raster de distance en entrée. Il doit s’agir d’une sortie d’outil de distance de coût cumulé provenant de Distance de coût ou Distance de chemin.",
	"@@Corridor_Distance-Raster-2_tag0@@": "Deuxième raster de distance en entrée. Il doit s’agir d’une sortie d’outil de distance de coût cumulé provenant de Distance de coût ou Distance de chemin.",
	"@@Cos_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Cos_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Cos_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Cos_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Cos_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Cos_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Cos_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Cos_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Cos_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Cos_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Cos_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Cos_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de cosinus.",
	"@@CosH_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@CosH_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@CosH_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@CosH_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@CosH_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@CosH_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@CosH_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@CosH_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@CosH_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@CosH_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@CosH_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@CosH_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de cosinus hyperbolique.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag0@@": "Ce paramètre simule l’augmentation de l’effort pour surmonter les coûts au fur et à mesure que le coût cumulé augmente. Il permet de modéliser la fatigue du voyageur. Le coût cumulé croissant pour atteindre une cellule est multiplié par le taux de résistance et ajouté au coût engendré par le déplacement vers la cellule suivante.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag1@@": "Il s’agit d’une version modifiée d’une formule de taux d’intérêt composé qui permet de calculer le coût apparent du déplacement à travers une cellule. Avec l'augmentation du taux de résistance, le coût des cellules qui sont visitées ultérieurement s'accroît également. Plus le taux de résistance est important, plus le coût de déplacement vers la cellule suivante augmente, lequel est ajouté pour chaque mouvement suivant. Puisque le taux de résistance est similaire à un taux composé et qu’habituellement les valeurs de coût cumulé sont très importantes, nous suggérons l’utilisation de taux de résistance faibles, tels que 0,005 ou encore inférieurs, selon les valeurs de coût cumulé.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag2@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag3@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Cost-Allocation_Capacity_tag0@@": "Définit la capacité de coût pour le voyageur pour une source. Les calculs de coût continuent pour chaque source jusqu’à ce que la capacité spécifiée soit atteinte.",
	"@@Cost-Allocation_Capacity_tag1@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Cost-Allocation_Capacity_tag2@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Cost-Allocation_Cost-Raster_tag0@@": "Raster en entrée requis définissant le coût ou l’impédance de déplacement planimétrique à travers chaque cellule. La valeur à chaque emplacement de cellule représente le coût par unité de distance pour le déplacement à travers chaque cellule. Chaque valeur d’emplacement de cellule est multipliée par la résolution de cellule et compense également le mouvement diagonal afin d’obtenir le coût total du passage à travers la cellule.",
	"@@Cost-Allocation_Cost-Raster_tag1@@": "Les valeurs du <strong>Raster de coût</strong> peuvent être des entiers ou des nombres à virgule flottante, mais elles ne peuvent pas être négatives ni nulles.",
	"@@Cost-Allocation_Maximum-Distance_tag0@@": "Le seuil que les valeurs de coût cumulé ne peuvent pas dépasser. Si une distance de coût cumulé dépasse cette valeur, la valeur en sortie de l’emplacement de cellule est ${NoData}. La distance maximale définit l’étendue pour laquelle les distances de coût cumulé sont calculées. La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag0@@": "Multiplicateur à appliquer aux valeurs de coût.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag1@@": "Ce paramètre permet de contrôler le mode de déplacement ou la magnitude à une source. Plus le multiplicateur est élevé, plus le coût de déplacement d’une cellule à une autre est important.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag2@@": "Les valeurs doivent être supérieures à zéro. La valeur par défaut est 1.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag3@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Cost-Allocation_Source-Field_tag0@@": "Champ permettant d’attribuer des valeurs aux emplacements sources. Il doit être de type entier. Si le <strong>Raster de valeur</strong> a été défini, les valeurs dans cette entrée sont prioritaires sur tout paramètre du <strong>Champ source</strong>.",
	"@@Cost-Allocation_Source-Raster_tag0@@": "Le raster en entrée requis des emplacements source.",
	"@@Cost-Allocation_Source-Raster_tag1@@": "Raster qui identifie les cellules ou les emplacements à partir desquels la distance de moindre coût cumulé est calculée pour chaque emplacement de cellule en sortie.",
	"@@Cost-Allocation_Source-Raster_tag2@@": "Si le <strong>Raster source</strong> en entrée est à virgule flottante, le <strong>Raster de valeur</strong> doit être défini et il doit être de type entier. Le <strong>Raster de valeur</strong> est prioritaire sur tout paramètre du <strong>Champ source</strong>.",
	"@@Cost-Allocation_Start-Cost_tag0@@": "Coût de départ du calcul des coûts. Ce paramètre permet de spécifier le coût fixe associé à une source. Plutôt que de commencer avec un coût égal à 0, l’algorithme de coût commence avec la valeur définie.",
	"@@Cost-Allocation_Start-Cost_tag1@@": "La valeur doit être égale ou supérieure à zéro. La valeur par défaut est 0.",
	"@@Cost-Allocation_Travel-Direction_tag0@@": "Définit le sens du voyageur en cas d’application du taux de résistance source et du coût de départ source.",
	"@@Cost-Allocation_Travel-Direction_tag1@@": "<strong>À partir de la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de la source en entrée et en se déplaçant vers les cellules non sources. Il s’agit de l’option par défaut.",
	"@@Cost-Allocation_Travel-Direction_tag3@@": "<strong>Vers la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de chaque cellule non source et en revenant vers la source en entrée.",
	"@@Cost-Allocation_Travel-Direction_tag5@@": "Spécifiez le mot-clé <strong>À partir de la source</strong> ou <strong>Vers la source</strong>, qui est appliqué à toutes les sources, ou spécifiez un champ dans le <strong>Raster source</strong> qui contient les mots-clés permettant d’identifier le sens de déplacement pour chaque source. Ce champ doit contenir la chaîne ${FROM_SOURCE} ou ${TO_SOURCE}.",
	"@@Cost-Allocation_Value-Raster_tag0@@": "Raster d’entiers en entrée qui identifie les valeurs de zone à utiliser pour chaque emplacement source en entrée. Pour chaque cellule d’emplacement source, la valeur définie par le <strong>Raster de valeur</strong> est attribuée à toutes les cellules allouées à l’emplacement source pour le calcul. Le <strong>Raster de valeur</strong> est prioritaire sur tout paramètre du <strong>Champ source</strong>.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag0@@": "Ce paramètre simule l’augmentation de l’effort pour surmonter les coûts au fur et à mesure que le coût cumulé augmente. Il permet de modéliser la fatigue du voyageur. Le coût cumulé croissant pour atteindre une cellule est multiplié par le taux de résistance et ajouté au coût engendré par le déplacement vers la cellule suivante.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag1@@": "Il s’agit d’une version modifiée d’une formule de taux d’intérêt composé qui permet de calculer le coût apparent du déplacement à travers une cellule. Avec l'augmentation du taux de résistance, le coût des cellules qui sont visitées ultérieurement s'accroît également. Plus le taux de résistance est important, plus le coût de déplacement vers la cellule suivante augmente, lequel est ajouté pour chaque mouvement suivant. Puisque le taux de résistance est similaire à un taux composé et qu’habituellement les valeurs de coût cumulé sont très importantes, nous suggérons l’utilisation de taux de résistance faibles, tels que 0,005 ou encore inférieurs, selon les valeurs de coût cumulé.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag2@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag3@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Cost-Back-Link_Capacity_tag0@@": "Définit la capacité de coût pour le voyageur pour une source. Les calculs de coût continuent pour chaque source jusqu’à ce que la capacité spécifiée soit atteinte.",
	"@@Cost-Back-Link_Capacity_tag1@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Cost-Back-Link_Capacity_tag2@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Cost-Back-Link_Cost-Raster_tag0@@": "Raster en entrée requis définissant le coût ou l’impédance de déplacement planimétrique à travers chaque cellule. La valeur à chaque emplacement de cellule représente le coût par unité de distance pour le déplacement à travers chaque cellule. Chaque valeur d’emplacement de cellule est multipliée par la résolution de cellule et compense également le mouvement diagonal afin d’obtenir le coût total du passage à travers la cellule.",
	"@@Cost-Back-Link_Cost-Raster_tag1@@": "Les valeurs du <strong>Raster de coût</strong> peuvent être des entiers ou des nombres à virgule flottante, mais elles ne peuvent pas être négatives ni nulles.",
	"@@Cost-Back-Link_Maximum-Distance_tag0@@": "Le seuil que les valeurs de coût cumulé ne peuvent pas dépasser. Si une distance de coût cumulé dépasse cette valeur, la valeur en sortie de l’emplacement de cellule est NoData. La distance maximale définit l’étendue pour laquelle les distances de coût cumulé sont calculées. La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag0@@": "Multiplicateur à appliquer aux valeurs de coût.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag1@@": "Ce paramètre permet de contrôler le mode de déplacement ou la magnitude à une source. Plus le multiplicateur est élevé, plus le coût de déplacement d’une cellule à une autre est important.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag2@@": "Les valeurs doivent être supérieures à zéro. La valeur par défaut est 1.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag3@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Cost-Back-Link_Source-Raster_tag0@@": "Le raster en entrée requis des emplacements source.",
	"@@Cost-Back-Link_Source-Raster_tag1@@": "Raster qui identifie les cellules ou les emplacements à partir desquels la distance de moindre coût cumulé est calculée pour chaque emplacement de cellule en sortie.",
	"@@Cost-Back-Link_Start-Cost_tag0@@": "Coût de départ du calcul des coûts. Ce paramètre permet de spécifier le coût fixe associé à une source. Plutôt que de commencer avec un coût égal à 0, l’algorithme de coût commence avec la valeur définie.",
	"@@Cost-Back-Link_Start-Cost_tag1@@": "La valeur doit être égale ou supérieure à zéro. La valeur par défaut est 0.",
	"@@Cost-Back-Link_Travel-Direction_tag0@@": "Définit le sens du voyageur en cas d’application du taux de résistance source et du coût de départ source.",
	"@@Cost-Back-Link_Travel-Direction_tag1@@": "<strong>À partir de la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de la source en entrée et en se déplaçant vers les cellules non sources. Il s’agit de l’option par défaut.",
	"@@Cost-Back-Link_Travel-Direction_tag3@@": "<strong>Vers la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de chaque cellule non source et en revenant vers la source en entrée.",
	"@@Cost-Back-Link_Travel-Direction_tag5@@": "Spécifiez le mot-clé <strong>À partir de la source</strong> ou <strong>Vers la source</strong>, qui est appliqué à toutes les sources, ou spécifiez un champ dans le <strong>Raster source</strong> qui contient les mots-clés permettant d’identifier le sens de déplacement pour chaque source. Ce champ doit contenir la chaîne ${FROM_SOURCE} ou ${TO_SOURCE}.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag0@@": "Ce paramètre simule l’augmentation de l’effort pour surmonter les coûts au fur et à mesure que le coût cumulé augmente. Il permet de modéliser la fatigue du voyageur. Le coût cumulé croissant pour atteindre une cellule est multiplié par le taux de résistance et ajouté au coût engendré par le déplacement vers la cellule suivante.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag1@@": "Il s’agit d’une version modifiée d’une formule de taux d’intérêt composé qui permet de calculer le coût apparent du déplacement à travers une cellule. Avec l'augmentation du taux de résistance, le coût des cellules qui sont visitées ultérieurement s'accroît également. Plus le taux de résistance est important, plus le coût de déplacement vers la cellule suivante augmente, lequel est ajouté pour chaque mouvement suivant. Puisque le taux de résistance est similaire à un taux composé et qu’habituellement les valeurs de coût cumulé sont très importantes, nous suggérons l’utilisation de taux de résistance faibles, tels que 0,005 ou encore inférieurs, selon les valeurs de coût cumulé.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag2@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag3@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Cost-Distance_Capacity_tag0@@": "Définit la capacité de coût pour le voyageur pour une source. Les calculs de coût continuent pour chaque source jusqu’à ce que la capacité spécifiée soit atteinte.",
	"@@Cost-Distance_Capacity_tag1@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Cost-Distance_Capacity_tag2@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Cost-Distance_Cost-Raster_tag0@@": "Raster en entrée requis définissant le coût ou l’impédance de déplacement planimétrique à travers chaque cellule. La valeur à chaque emplacement de cellule représente le coût par unité de distance pour le déplacement à travers chaque cellule. Chaque valeur d’emplacement de cellule est multipliée par la résolution de cellule et compense également le mouvement diagonal afin d’obtenir le coût total du passage à travers la cellule.",
	"@@Cost-Distance_Cost-Raster_tag1@@": "Les valeurs du <strong>Raster de coût</strong> peuvent être des entiers ou des nombres à virgule flottante, mais elles ne peuvent pas être négatives ni nulles.",
	"@@Cost-Distance_Maximum-Distance_tag0@@": "Le seuil que les valeurs de coût cumulé ne peuvent pas dépasser. Si une distance de coût cumulé dépasse cette valeur, la valeur en sortie de l’emplacement de cellule est NoData. La distance maximale définit l’étendue pour laquelle les distances de coût cumulé sont calculées. La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag0@@": "Multiplicateur à appliquer aux valeurs de coût.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag1@@": "Ce paramètre permet de contrôler le mode de déplacement ou la magnitude à une source. Plus le multiplicateur est élevé, plus le coût de déplacement d’une cellule à une autre est important.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag2@@": "Les valeurs doivent être supérieures à zéro. La valeur par défaut est 1.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag3@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Cost-Distance_Source-Raster_tag0@@": "Le raster en entrée requis des emplacements source.",
	"@@Cost-Distance_Source-Raster_tag1@@": "Raster qui identifie les cellules ou les emplacements à partir desquels la distance de moindre coût cumulé est calculée pour chaque emplacement de cellule en sortie.",
	"@@Cost-Distance_Start-Cost_tag0@@": "Coût de départ du calcul des coûts. Ce paramètre permet de spécifier le coût fixe associé à une source. Plutôt que de commencer avec un coût égal à 0, l’algorithme de coût commence avec la valeur définie.",
	"@@Cost-Distance_Start-Cost_tag1@@": "La valeur doit être égale ou supérieure à zéro. La valeur par défaut est 0.",
	"@@Cost-Distance_Travel-Direction_tag0@@": "Définit le sens du voyageur en cas d’application du taux de résistance source et du coût de départ source.",
	"@@Cost-Distance_Travel-Direction_tag1@@": "<strong>À partir de la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de la source en entrée et en se déplaçant vers les cellules non sources. Il s’agit de l’option par défaut.",
	"@@Cost-Distance_Travel-Direction_tag3@@": "<strong>Vers la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de chaque cellule non source et en revenant vers la source en entrée.",
	"@@Cost-Distance_Travel-Direction_tag5@@": "Spécifiez le mot-clé <strong>À partir de la source</strong> ou <strong>Vers la source</strong>, qui est appliqué à toutes les sources, ou spécifiez un champ dans le <strong>Raster source</strong> qui contient les mots-clés permettant d’identifier le sens de déplacement pour chaque source. Ce champ doit contenir la chaîne ${FROM_SOURCE} ou ${TO_SOURCE}.",
	"@@Curvature_Curvature-Type_tag0@@": "Le type de courbure accentue différentes expositions de la pente. Il existe trois options de courbure :",
	"@@Curvature_Curvature-Type_tag1@@": "Planiforme : est perpendiculaire à la direction de la pente maximale. Elle affecte la convergence et la divergence de flux sur la surface.",
	"@@Curvature_Curvature-Type_tag2@@": "Longitudinale : est parallèle à la pente et indique la direction de la pente maximale. Elle affecte l'accélération et la décélération de flux sur la surface.",
	"@@Curvature_Curvature-Type_tag3@@": "Standard : associe les courbures de type <strong>Profil</strong> et <strong>Planiforme</strong>.",
	"@@Curvature_DEM_tag0@@": "Raster de modèle numérique de terrain (MNT).",
	"@@Curvature_Z-Factor_tag0@@": "Le facteur z ajuste les unités de mesure des unités z lorsqu'elles sont différentes des unités x,y de la surface en entrée. Si les unités x,y et les unités z utilisent les mêmes unités de mesure, le facteur z doit être égal à 1. Les valeurs z de la surface en entrée sont multipliées par le facteur z lors du calcul de la surface finale en sortie. Par exemple, si l'unité z est exprimée en pieds et que les unités x,y sont exprimées en mètres, vous devez utiliser un facteur z égal à 0,3048 pour effectuer la conversion pieds/mètres (1 pied = 0,3048 mètre).",
	"@@Divide_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Divide_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Divide_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Divide_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Divide_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Divide_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Divide_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Divide_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Divide_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Divide_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Divide_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Divide_Raster_tag0@@": "Entrée dont la valeur est divisée par la deuxième entrée.",
	"@@Divide_Raster_tag1@@": "Un nombre peut être utilisé en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour ${Raster2}.",
	"@@Divide_Raster2_tag0@@": "Entrée par laquelle est divisée la valeur de la première entrée.",
	"@@Divide_Raster2_tag1@@": "Un nombre peut être utilisé en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour ${Raster}.",
	"@@Elevation-Void-Fill_DEM_tag0@@": "DEM en entrée.",
	"@@Elevation-Void-Fill_Max-Void-Width_tag0@@": "La valeur de largeur de vide maximale est utilisée pour préciser la taille de vide la plus importante que vous souhaitez remplir. Si la largeur ou la hauteur de l'emprise autour du vide est plus grande que la valeur de largeur de vide maximale, le vide n'est pas rempli. Les unités de ce paramètre sont identiques à celles utilisées dans le système de référence spatiale de vos données.",
	"@@Elevation-Void-Fill_Max-Void-Width_tag1@@": "Si ce paramètre n’est pas renseigné ou a la valeur ${0}, aucune largeur maximale n’est utilisée et tous les vides sont remplis. La valeur ${-1} signifie qu’aucun remplissage des vides n’a lieu.",
	"@@Elevation-Void-Fill_Short-Range-IDW-Radius_tag0@@": "Le rayon de recherche maximum qui sera utilisé pour le remplissage des vides. Un vide plus éloigné, par rapport à n’importe quel pixel valide, que cette valeur seuil restera vide. Les unités de ce paramètre sont identiques à celles utilisées dans le système de référence spatiale de vos données.",
	"@@Elevation-Void-Fill_Short-Range-IDW-Radius_tag1@@": "Si la valeur de ce paramètre est non renseignée, ${0}, ou ${-1} ce paramètre n’est pas utilisé.",
	"@@Equal-to_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Equal-to_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Equal-to_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Equal-to_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Equal-to_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Equal-to_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Equal-to_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Equal-to_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Equal-to_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Equal-to_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Equal-to_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Equal-to_Raster_tag0@@": "Entrée à comparer à la seconde entrée pour vérifier l'égalité des deux entrées.",
	"@@Equal-to_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Equal-to_Raster2_tag0@@": "Entrée à comparer à la première entrée pour vérifier l'égalité des deux entrées.",
	"@@Equal-to_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Euclidean-Allocation_Cellsize_tag0@@": "Taille des cellules qui sera utilisée pour la création du raster en sortie.",
	"@@Euclidean-Allocation_Cellsize_tag1@@": "Si la taille de cellule a été explicitement définie dans <strong>Environnements d’analyse</strong>, il s’agit de la taille de cellule par défaut. Si elle n’a pas été définie, la taille de cellule en sortie est identique à celle du <strong>Raster source</strong>.",
	"@@Euclidean-Allocation_Distance-Method_tag0@@": "Détermine si la distance doit être calculée avec une méthode plane (Terre plate) ou géodésique (ellipsoïde).",
	"@@Euclidean-Allocation_Distance-Method_tag1@@": "Géodésique : ligne la plus courte entre deux points d’un sphéroïde (ellipsoïde) sur la surface de la Terre. Les résultats ne changent donc pas quelle que soit la projection en entrée ou en sortie. Vous pouvez utiliser une ligne géodésique si vous souhaitez déterminer la distance la plus courte entre deux villes pour la trajectoire de vol d’un avion. On parle également de « ligne de grand cercle » si elle repose sur une sphère plutôt qu'une ellipsoïde.",
	"@@Euclidean-Allocation_Distance-Method_tag2@@": "Plane : la mesure plane utilise des mathématiques cartésiennes en 2D pour calculer la longueur et la surface. Cette option est uniquement disponible lorsque les mesures sont effectuées dans un système de coordonnées projetées. Le plan 2D de ce système de coordonnées est alors utilisé comme base des mesures.",
	"@@Euclidean-Allocation_Maximum-Distance_tag0@@": "Définit la distance de seuil prise en compte pour estimer la source la plus proche. Si la distance par rapport à la source la plus proche dépasse ce seuil, la sortie de cette cellule prend la valeur ${NoData}.",
	"@@Euclidean-Allocation_Maximum-Distance_tag1@@": "La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Euclidean-Allocation_Raster-Barriers_tag0@@": "Raster qui définit les interruptions.",
	"@@Euclidean-Allocation_Raster-Barriers_tag1@@": "Le jeu de données doit contenir une valeur ${NoData} lorsqu’il n’y a pas d’interruption. Les interruptions sont représentées par des valeurs valides, y compris zéro.",
	"@@Euclidean-Allocation_Raster-Barriers_tag2@@": "Les interruptions peuvent être définies par un entier ou un raster à virgule flottante.",
	"@@Euclidean-Allocation_Source-Field_tag0@@": "Champ permettant d’attribuer des valeurs aux emplacements sources. Il doit être de type entier. Si le <strong>Raster de valeur</strong> a été défini, les valeurs dans cette entrée sont prioritaires sur tout paramètre du <strong>Champ source</strong>.",
	"@@Euclidean-Allocation_Source-Raster_tag0@@": "Raster en entrée requis identifiant les emplacements source. Détermine, pour chaque cellule de la sortie, la source la plus proche en fonction de la distance euclidienne.",
	"@@Euclidean-Allocation_Source-Raster_tag1@@": "Le type en entrée peut être un entier ou un nombre à virgule flottante.",
	"@@Euclidean-Allocation_Value-Raster_tag0@@": "Raster d’entiers en entrée qui identifie les valeurs de zone à utiliser pour chaque emplacement source en entrée. Pour chaque cellule d’emplacement source, la valeur définie par le <strong>Raster de valeur</strong> est attribuée à toutes les cellules allouées à l’emplacement source pour le calcul. Le <strong>Raster de valeur</strong> est prioritaire sur tout paramètre du <strong>Champ source</strong>.",
	"@@Euclidean-Direction_Cellsize_tag0@@": "Taille des cellules qui sera utilisée pour la création du raster en sortie.",
	"@@Euclidean-Direction_Cellsize_tag1@@": "Si la taille de cellule a été explicitement définie dans <strong>Environnements d’analyse</strong>, il s’agit de la taille de cellule par défaut. Si elle n’a pas été définie, la taille de cellule en sortie est identique à celle du <strong>Raster source</strong>.",
	"@@Euclidean-Direction_Distance-Method_tag0@@": "Détermine si la distance doit être calculée avec une méthode plane (Terre plate) ou géodésique (ellipsoïde).",
	"@@Euclidean-Direction_Distance-Method_tag1@@": "Géodésique : ligne la plus courte entre deux points d’un sphéroïde (ellipsoïde) sur la surface de la Terre. Les résultats ne changent donc pas quelle que soit la projection en entrée ou en sortie. Vous pouvez utiliser une ligne géodésique si vous souhaitez déterminer la distance la plus courte entre deux villes pour la trajectoire de vol d’un avion. On parle également de « ligne de grand cercle » si elle repose sur une sphère plutôt qu'une ellipsoïde.",
	"@@Euclidean-Direction_Distance-Method_tag2@@": "Plane : la mesure plane utilise des mathématiques cartésiennes en 2D pour calculer la longueur et la surface. Cette option est uniquement disponible lorsque les mesures sont effectuées dans un système de coordonnées projetées. Le plan 2D de ce système de coordonnées est alors utilisé comme base des mesures.",
	"@@Euclidean-Direction_Maximum-Distance_tag0@@": "Définit la distance de seuil prise en compte pour estimer la direction par rapport à la source la plus proche. Si la distance par rapport à la source la plus proche dépasse ce seuil, la sortie de cette cellule prend la valeur ${NoData}.",
	"@@Euclidean-Direction_Maximum-Distance_tag1@@": "La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Euclidean-Direction_Raster-Barriers_tag0@@": "Raster qui définit les interruptions.",
	"@@Euclidean-Direction_Raster-Barriers_tag1@@": "Le jeu de données doit contenir une valeur NoData lorsqu’il n’y a pas d’interruption. Les interruptions sont représentées par des valeurs valides, y compris zéro.",
	"@@Euclidean-Direction_Raster-Barriers_tag2@@": "Les interruptions peuvent être définies par un entier ou un raster à virgule flottante.",
	"@@Euclidean-Direction_Source-Raster_tag0@@": "Raster en entrée requis qui identifie les cellules ou les emplacements par rapport auxquels la direction euclidienne est calculée pour chaque emplacement de cellule en sortie.",
	"@@Euclidean-Direction_Source-Raster_tag1@@": "Le type en entrée peut être un entier ou un nombre à virgule flottante.",
	"@@Euclidean-Distance_Cellsize_tag0@@": "Taille des cellules qui sera utilisée pour la création du raster en sortie.",
	"@@Euclidean-Distance_Cellsize_tag1@@": "Si la taille de cellule a été explicitement définie dans <strong>Environnements d’analyse</strong>, il s’agit de la taille de cellule par défaut. Si elle n’a pas été définie, la taille de cellule en sortie est identique à celle du <strong>Raster source</strong>.",
	"@@Euclidean-Distance_Distance-Method_tag0@@": "Détermine si la distance doit être calculée avec une méthode plane (Terre plate) ou géodésique (ellipsoïde).",
	"@@Euclidean-Distance_Distance-Method_tag1@@": "Géodésique : ligne la plus courte entre deux points d’un sphéroïde (ellipsoïde) sur la surface de la Terre. Les résultats ne changent donc pas quelle que soit la projection en entrée ou en sortie. Vous pouvez utiliser une ligne géodésique si vous souhaitez déterminer la distance la plus courte entre deux villes pour la trajectoire de vol d’un avion. On parle également de « ligne de grand cercle » si elle repose sur une sphère plutôt qu'une ellipsoïde.",
	"@@Euclidean-Distance_Distance-Method_tag2@@": "Plane : la mesure plane utilise des mathématiques cartésiennes en 2D pour calculer la longueur et la surface. Cette option est uniquement disponible lorsque les mesures sont effectuées dans un système de coordonnées projetées. Le plan 2D de ce système de coordonnées est alors utilisé comme base des mesures.",
	"@@Euclidean-Distance_Maximum-Distance_tag0@@": "Seuil que les valeurs de distance cumulée ne peuvent pas dépasser. Si une distance euclidienne cumulée dépasse cette valeur, la valeur en sortie de l’emplacement de cellule est NoData.",
	"@@Euclidean-Distance_Maximum-Distance_tag1@@": "La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Euclidean-Distance_Raster-Barriers_tag0@@": "Raster qui définit les interruptions.",
	"@@Euclidean-Distance_Raster-Barriers_tag1@@": "Le jeu de données doit contenir une valeur ${NoData} lorsqu’il n’y a pas d’interruption. Les interruptions sont représentées par des valeurs valides, y compris zéro.",
	"@@Euclidean-Distance_Raster-Barriers_tag2@@": "Les interruptions peuvent être définies par un entier ou un raster à virgule flottante.",
	"@@Euclidean-Distance_Source-Raster_tag0@@": "Le raster en entrée requis qui identifie les cellules ou les emplacements par rapport auxquels la distance euclidienne est calculée pour chaque emplacement de cellule en sortie.",
	"@@Euclidean-Distance_Source-Raster_tag1@@": "Le type en entrée peut être un entier ou un nombre à virgule flottante.",
	"@@Exp_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Exp_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Exp_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Exp_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Exp_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Exp_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Exp_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Exp_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Exp_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Exp_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Exp_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Exp_Raster_tag0@@": "Valeurs en entrée pour lesquelles on calcule la base e exponentielle.",
	"@@Exp10_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Exp10_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Exp10_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Exp10_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Exp10_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Exp10_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Exp10_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Exp10_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Exp10_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Exp10_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Exp10_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Exp10_Raster_tag0@@": "Valeurs en entrée pour lesquelles on calcule la base 10 exponentielle.",
	"@@Exp2_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Exp2_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Exp2_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Exp2_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Exp2_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Exp2_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Exp2_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Exp2_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Exp2_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Exp2_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Exp2_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Exp2_Raster_tag0@@": "Valeurs en entrée pour lesquelles on calcule la base 2 exponentielle.",
	"@@Extract-Bands_Band_tag0@@": "Sélectionnez les bandes à extraire dans une liste basée sur l’option utilisée pour le paramètre <strong>Méthode</strong>.",
	"@@Extract-Bands_Combination_tag0@@": "Combinaison de bandes ou ordre des bandes. La liste de sélection dépend de l’option <strong>Méthode</strong> spécifiée. Par exemple, si la <strong>Méthode</strong> choisie est <strong>Noms des bandes</strong>, vous pouvez sélectionner une combinaison Bleu, Vert et Rouge pour extraire une image aux couleurs naturelles.",
	"@@Extract-Bands_Method_tag0@@": "Sélectionnez l’une des méthodes suivantes pour extraire les canaux :",
	"@@Extract-Bands_Method_tag1@@": "<strong>Identifiants des bandes</strong> : désignation ou numéro de bande qui est unique pour chaque capteur. Ils peuvent être identiques aux valeurs de l’option <strong>Noms des bandes</strong>.",
	"@@Extract-Bands_Method_tag4@@": "<strong>Noms des bandes</strong> : utilise le nom de la bande représentant l’intervalle de longueur d’onde sur le spectre électromagnétique (Rouge, Proche infrarouge, Infrarouge thermique, par exemple). Le nom de la bande est également désigné comme l’identifiant de numéro de bande.",
	"@@Extract-Bands_Method_tag6@@": "<strong>Longueurs d’ondes des bandes</strong> : longueur d’onde sur le spectre électromagnétique.",
	"@@Extract-Bands_Missing-Band-Action_tag0@@": "Indiquez l’action qui va se produire lorsqu’un canal au sein de la liste des canaux à extraire n’est pas disponible.",
	"@@Extract-Bands_Missing-Band-Action_tag1@@": "<strong>Meilleur résultat</strong> : Recherche la meilleure bande disponible à utiliser à la place de la bande manquante en fonction de la longueur d’onde, pour que la fonction n’échoue pas",
	"@@Extract-Bands_Missing-Band-Action_tag3@@": "<strong>Échec</strong> : si, dans le jeu de données en entrée, l’une des bandes spécifiées est absente dans le paramètre </strong>Bande<strong>, la fonction échoue.",
	"@@Extract-Bands_Raster_tag0@@": "Le produit raster duquel le ou les canaux seront extraits.",
	"@@Fill_Raster_tag0@@": "Raster d’altitude monocanal.",
	"@@Fill_Z-Limit_tag0@@": "La différence d’altitude maximale entre une cuvette et le point d’écoulement à remplir.",
	"@@Fill_Z-Limit_tag1@@": "Si aucune valeur n'est indiquée pour ce paramètre, toutes les cuvettes seront remplies, quelle que soit la profondeur.",
	"@@Fill_Z-Limit_tag2@@": "La valeur de <strong>Limite Z</strong> doit être supérieure à zéro.",
	"@@Float_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Float_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Float_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Float_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Float_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Float_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Float_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Float_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Float_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Float_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Float_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Float_Raster_tag0@@": "Raster en entrée à convertir en virgule flottante.",
	"@@Flow-Accumulation_Flow-Direction-Raster_tag0@@": "Raster en entrée qui montre la direction du flux sortant de chaque cellule.",
	"@@Flow-Accumulation_Flow-Direction-Raster_tag1@@": "Le raster de direction de flux peut être créé en exécutant la fonction <strong>Direction de flux</strong>.",
	"@@Flow-Accumulation_Flow-Direction-Type_tag0@@": "Définit le type de raster de direction de flux en entrée.",
	"@@Flow-Accumulation_Flow-Direction-Type_tag1@@": "<strong>D8</strong> : le raster de direction de flux en entrée est de type D8. Il s’agit de l’option par défaut.",
	"@@Flow-Accumulation_Flow-Direction-Type_tag3@@": "<strong>DINF</strong> : le raster de direction de flux en entrée est de type D-Infinity (DINF).",
	"@@Flow-Accumulation_Flow-Direction-Type_tag5@@": "<strong>MFD</strong> : le raster de direction de flux en entrée est de type Multi Flow Direction (MFD).",
	"@@Flow-Accumulation_Output-Data-Type_tag0@@": "Le raster d'accumulation en sortie peut être un entier ou à virgule flottante.",
	"@@Flow-Accumulation_Output-Data-Type_tag1@@": "<strong>Flottant</strong> : le raster en sortie sera de type à virgule flottante. Il s’agit de l’option par défaut.",
	"@@Flow-Accumulation_Output-Data-Type_tag3@@": "<strong>Entier</strong> : le raster en sortie sera de type entier.",
	"@@Flow-Accumulation_Weight-Raster_tag0@@": "Raster en entrée facultatif pour appliquer une pondération à chaque pixel.",
	"@@Flow-Accumulation_Weight-Raster_tag1@@": "Si aucun raster de pondération n’est spécifié, une pondération par défaut de 1 est appliquée à chaque pixel.",
	"@@Flow-Direction_Flow-Direction-Type_tag0@@": "Définit le type de raster de direction de flux en entrée.",
	"@@Flow-Direction_Flow-Direction-Type_tag1@@": "<strong>D8</strong> : le raster de direction de flux en entrée est de type D8. Il s’agit de l’option par défaut.",
	"@@Flow-Direction_Flow-Direction-Type_tag3@@": "<strong>DINF</strong> : le raster de direction de flux en entrée est de type D-Infinity (DINF).",
	"@@Flow-Direction_Flow-Direction-Type_tag5@@": "<strong>MFD</strong> : le raster de direction de flux en entrée est de type Multi Flow Direction (MFD).",
	"@@Flow-Direction_Force-all-edge-cells-to-flow-outward_tag0@@": "Indique si les pixels de tronçon s’écoulent toujours vers l’extérieur ou suivent les règles de flux normales.",
	"@@Flow-Direction_Force-all-edge-cells-to-flow-outward_tag1@@": "<strong>Non</strong> : si la pente maximale d’un pixel de segment est supérieure à zéro, la direction de flux est déterminée de la manière habituelle. Dans le cas contraire, elle sera orientée vers le segment. Les pixels qui devraient s’écouler du segment de la surface raster vers l’intérieur s’écouleront ainsi. Il s’agit de l’option par défaut.",
	"@@Flow-Direction_Force-all-edge-cells-to-flow-outward_tag3@@": "<strong>Oui</strong> : tous les pixels sur le segment du raster de surface s’écouleront vers l’extérieur à partir du raster de surface.",
	"@@Flow-Direction_Raster_tag0@@": "Raster en entrée qui représente une surface d’altitude continue.",
	"@@Flow-Distance_Distance-Type_tag0@@": "Détermine si le composant vertical ou horizontal de la distance d'écoulement est calculé.",
	"@@Flow-Distance_Distance-Type_tag1@@": "<strong>Horizontale</strong> : les calculs de distance d’écoulement représentent le composant horizontal de la distance d’écoulement à partir de chaque pixel dans le domaine vers les pixels de l’écoulement dans lequel ils transitent.",
	"@@Flow-Distance_Distance-Type_tag3@@": "<strong>Verticale</strong> : les calculs de distance d’écoulement représentent le composant vertical de la distance d’écoulement à partir de chaque pixel dans le domaine vers les pixels de l’écoulement dans lequel ils transitent. Il s’agit de l’option par défaut.",
	"@@Flow-Distance_Flow-Direction-Raster_tag0@@": "Raster en entrée qui montre la direction du flux sortant de chaque pixel.",
	"@@Flow-Distance_Flow-Direction-Raster_tag1@@": "Lorsqu’un raster de direction de flux est fourni, les directions de pente descendante seront limitées à celles définies par les directions de flux en entrée.",
	"@@Flow-Distance_Flow-Direction-Raster_tag2@@": "Le raster de direction de flux peut être créé à l’aide de la fonction Flow Direction (Direction de flux).",
	"@@Flow-Distance_Flow-Direction-Type_tag0@@": "Définit le type de raster de direction de flux en entrée.",
	"@@Flow-Distance_Flow-Direction-Type_tag1@@": "<strong>D8</strong> : le raster de direction de flux en entrée est de type D8. Il s’agit de l’option par défaut.",
	"@@Flow-Distance_Flow-Direction-Type_tag3@@": "<strong>DINF</strong> : le raster de direction de flux en entrée est de type D-Infinity (DINF).",
	"@@Flow-Distance_Flow-Direction-Type_tag5@@": "<strong>MFD</strong> : le raster de direction de flux en entrée est de type Multi Flow Direction (MFD).",
	"@@Flow-Distance_Statistics-Type_tag0@@": "Détermine le type de statistique utilisé pour calculer la distance d’écoulement sur plusieurs chemins de flux. Lorsqu’il n’existe qu’un seul chemin de flux depuis chaque cellule vers une cellule du flux, tous les types de statistiques produisent le même résultat.",
	"@@Flow-Distance_Statistics-Type_tag1@@": "<strong>Minimum</strong> : s’il existe plusieurs chemins de flux, la distance d’écoulement minimale est calculée. Il s’agit de l’option par défaut.",
	"@@Flow-Distance_Statistics-Type_tag3@@": "<strong>Moyenne pondérée</strong> : s’il existe plusieurs chemins de flux, une moyenne pondérée de la distance d’écoulement est calculée. La proportion de flux à partir d’une cellule vers ses cellules voisines en aval est utilisée comme pondération pour calculer la moyenne pondérée.",
	"@@Flow-Distance_Statistics-Type_tag5@@": "<strong>Maximum</strong> : s’il existe plusieurs chemins de flux, la distance d’écoulement maximale est calculée.",
	"@@Flow-Distance_Stream-Raster_tag0@@": "Raster d’écoulement en entrée représentant un réseau d’écoulement linéaire.",
	"@@Flow-Distance_Surface-Raster_tag0@@": "Raster en entrée qui représente une surface d’altitude continue.",
	"@@Flow-Length_Direction-of-Measurement_tag0@@": "Direction mesurée le long du chemin de flux.",
	"@@Flow-Length_Direction-of-Measurement_tag1@@": "<strong>En aval</strong> : calcule la distance de pente le long du chemin de flux depuis chaque cellule jusqu’à une cuvette ou un orifice sur le segment du raster.",
	"@@Flow-Length_Direction-of-Measurement_tag3@@": "<strong>En amont</strong> : calcule la distance de montée la plus grande le long du chemin de flux, depuis chaque cellule jusqu’au sommet de la ligne de partage des eaux.",
	"@@Flow-Length_Flow-Direction-Raster_tag0@@": "Raster en entrée qui montre la direction du flux sortant de chaque cellule.",
	"@@Flow-Length_Flow-Direction-Raster_tag1@@": "Le raster de direction de flux peut être créé en exécutant la fonction <strong>Direction de flux</strong>.",
	"@@Flow-Length_Weight-Raster_tag0@@": "Raster en entrée facultatif pour appliquer une pondération à chaque cellule.",
	"@@Flow-Length_Weight-Raster_tag1@@": "Si aucun raster de pondération n'est spécifié, une pondération par défaut de 1 est appliquée à chaque cellule.",
	"@@Focal-Statistics_Ignore-NoData-in-calculations_tag0@@": "Indique si les valeurs ${NoData} sont ignorées par le calcul de statistiques.",
	"@@Focal-Statistics_Ignore-NoData-in-calculations_tag1@@": "<strong>Activé</strong> : précise que si une valeur ${NoData} existe dans un voisinage, elle est ignorée. Seules les cellules du voisinage dotées de valeurs de données sont utilisées dans la détermination de la valeur en sortie. Il s’agit de l’option par défaut.",
	"@@Focal-Statistics_Ignore-NoData-in-calculations_tag3@@": "<strong>Désactivé</strong> : précise que si une cellule d’un voisinage a une valeur ${NoData}, la sortie de la cellule de traitement est ${NoData}.",
	"@@Focal-Statistics_Neighborhood_tag0@@": "La forme de la zone autour de chaque cellule utilisée pour le calcul des statistiques.",
	"@@Focal-Statistics_Neighborhood_tag1@@": "Chaque voisinage possède des paramètres supplémentaires avec lesquels définir la forme.",
	"@@Focal-Statistics_Neighborhood_tag2@@": "Anneau, Rayon intérieur, Rayon extérieur",
	"@@Focal-Statistics_Neighborhood_tag3@@": "Cercle, Rayon",
	"@@Focal-Statistics_Neighborhood_tag4@@": "Irrégulier, Largeur, Hauteur, Valeurs voisines",
	"@@Focal-Statistics_Neighborhood_tag5@@": "Rectangle, Largeur, Hauteur",
	"@@Focal-Statistics_Neighborhood_tag6@@": "Secteur, Rayon, Angle de début, Angle de fin",
	"@@Focal-Statistics_Neighborhood_tag7@@": "Pondération, Largeur, Hauteur, Valeurs voisines",
	"@@Focal-Statistics_Neighborhood_tag8@@": "Le voisinage irrégulier permet de spécifier un voisinage de forme irrégulière autour de la cellule de traitement. Utilisez la table des valeurs voisines pour définir la forme du noyau de voisinage. Une valeur nulle pour une position de cellule indique que la cellule ne fait pas partie du voisinage et ne sera pas prise en compte dans le traitement. La valeur 1 indique que la cellule correspondante est un membre du voisinage (de même que sa valeur).",
	"@@Focal-Statistics_Neighborhood_tag9@@": "Le voisinage de pondération est similaire au type de voisinage irrégulier, dans le sens où il vous permet de définir un voisinage irrégulier autour de la cellule de traitement, mais également d’appliquer des pondérations aux valeurs en entrée. Les valeurs du noyau de pondération spécifie les positions de cellule qui doivent être comprises dans le voisinage et les pondérations par lesquelles elles seront multipliées. Utilisez la valeur 0 pour exclure une cellule du traitement. Les valeurs positives, négatives et décimales peuvent être utilisées en tant que valeurs de pondération. Pour le type de voisinage de pondération, seules les statistiques Moyenne, Écart type ou Somme sont prises en charge.",
	"@@Focal-Statistics_Percentile-Value_tag0@@": "Indique le centile à calculer lorsque le type de statistique <strong>Centile</strong> est sélectionné. La valeur par défaut est de 90, soit le 90e centile.",
	"@@Focal-Statistics_Percentile-Value_tag3@@": "Les valeurs peuvent varier entre 0 et 100. Le pourcentage nul est généralement équivalent à la statistique Minimum et le pourcentage 100 est équivalent à la statistique Maximum, à l’exception près que le résultat est de type virgule flottante. Une valeur de 50 donne généralement le même résultat que la statistique Median (Médiane).",
	"@@Focal-Statistics_Raster_tag0@@": "Le raster en entrée requis.",
	"@@Focal-Statistics_Statistics-Type_tag0@@": "Type de statistique à calculer.",
	"@@Focal-Statistics_Statistics-Type_tag1@@": "<strong>Majorité</strong> : calcule la majorité (valeur la plus fréquente) des cellules du voisinage.",
	"@@Focal-Statistics_Statistics-Type_tag3@@": "<strong>Maximum</strong> : calcule le maximum (valeur la plus élevée) des cellules du voisinage.",
	"@@Focal-Statistics_Statistics-Type_tag5@@": "<strong>Moyenne</strong> : calcule la moyenne des cellules du voisinage.",
	"@@Focal-Statistics_Statistics-Type_tag7@@": "<strong>Médiane</strong> : calcule la médiane des cellules du voisinage.",
	"@@Focal-Statistics_Statistics-Type_tag9@@": "<strong>Minimum</strong> : calcule le minimum (valeur la plus faible) des cellules du voisinage.",
	"@@Focal-Statistics_Statistics-Type_tag11@@": "<strong>Minorité</strong> : calcule la minorité (valeur la moins fréquente) des cellules du voisinage.",
	"@@Focal-Statistics_Statistics-Type_tag13@@": "<strong>Centile</strong> : calcule un centile des cellules du voisinage. Vous pouvez déterminer le centile à calculer à l’aide du paramètre <strong>Valeur de centile</strong>.",
	"@@Focal-Statistics_Statistics-Type_tag17@@": "<strong>Plage</strong> : calcule la plage (différence entre la valeur la plus élevée et la valeur la plus faible) des cellules du voisinage.",
	"@@Focal-Statistics_Statistics-Type_tag19@@": "<strong>Écart type</strong> : calcule l’écart type des cellules du voisinage.",
	"@@Focal-Statistics_Statistics-Type_tag21@@": "<strong>Somme</strong> : calcule la somme (total de toutes les valeurs) des cellules du voisinage.",
	"@@Focal-Statistics_Statistics-Type_tag23@@": "<strong>Variété</strong> : calcule la variété (le nombre de valeurs uniques) des cellules du voisinage.",
	"@@Focal-Statistics_Statistics-Type_tag25@@": "Si le raster en entrée est de type virgule flottante, seuls les types de statistiques Mean (Moyenne), Maximum, Median (Médiane), Minimum, Percentile (Pourcentage), Range (Plage), Standard deviation (Écart type) et Sum (Somme) sont disponibles.",
	"@@Focal-Statistics_Statistics-Type_tag26@@": "Pour Mean (Moyenne), Median (Médiane), Percentile (Pourcentage) et Standard Deviation (Écart type), la sortie est toujours de type virgule flottante.",
	"@@Focal-Statistics_Statistics-Type_tag27@@": "Le type de statistiques par défaut est Moyenne.",
	"@@Geometric_Constant-Z_tag0@@": "Spécifiez une altitude constante à utiliser pour la fonction Géométrique.",
	"@@Geometric_DEM_tag0@@": "Spécifiez un MNT à utiliser pour la fonction Géométrique. Vous pouvez utiliser un MNE contenu dans le jeu de données mosaïque sous forme de jeu de données raster ou de jeu de données mosaïque dont la sortie est un MNE.",
	"@@Geometric_Geoid_tag0@@": "La plupart des jeux de données d’élévation, comme USGS NED ou ArcGIS Online World Elevation, sont des hauteurs orthométriques. Par conséquent, il convient de sélectionner la correction Géoïde pour assurer la compatibilité avec les coefficients polynomiaux rationnels (RPC) des satellites, qui nécessitent des hauteurs ellipsoïdales. Cochez la case <strong>Géoïde</strong> pour appliquer la correction géoïde (EGM96) aux valeurs z, sauf si votre MNE est déjà référencé par rapport à des hauteurs ellipsoïdales.",
	"@@Geometric_Method_tag0@@": "Choisissez la méthode d'altitude pour la fonction géométrique :",
	"@@Geometric_Method_tag1@@": "Utiliser la constante Z : spécifier une altitude constante pour exécuter la fonction géométrique.",
	"@@Geometric_Method_tag2@@": "Utiliser MNE : spécifier un MNE pour exécuter la fonction géométrique.",
	"@@Geometric_Raster_tag0@@": "Raster en entrée.",
	"@@Geometric_Z-Factor_tag0@@": "Les coefficients polynomiaux rationnels (RPC) de satellite sont mis à l’échelle pour les jeux de données d’élévation avec des unités verticales en mètres. Si votre élévation utilise d’autres unités verticales, saisissez un <strong>Facteur Z</strong> pour redimensionner en mètres. Par exemple, si les unités d’élévation sont en pieds, vous devez utiliser une valeur de 0,3048 pour convertir les unités d’élévation de pieds en mètres.",
	"@@Geometric_Z-Offset_tag0@@": "Valeur de base à ajouter à la valeur d'altitude dans le modèle numérique de terrain. Cela permet de compenser des valeurs d'altitude qui ne démarrent pas au niveau de la mer.",
	"@@Geometric_Tolerance_tag0@@": "Indiquez l’erreur tolérable maximale dans la fonction géométrique, en nombre de pixels. La valeur par défaut pour le raster de type NITF (NCDRD) est deux.",
	"@@Grayscale_Raster_tag0@@": "Raster en entrée.",
	"@@Grayscale_Conversion-Parameters_tag0@@": "Pondérations de chaque canal comprenant le raster en entrée.",
	"@@Greater-Than_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Greater-Than_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Greater-Than_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Greater-Than_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Greater-Than_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Greater-Than_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Greater-Than_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Greater-Than_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Greater-Than_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Greater-Than_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Greater-Than_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Greater-Than_Raster_tag0@@": "Entrée testée pour déterminer si elle est supérieure à la seconde entrée.",
	"@@Greater-Than_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Greater-Than_Raster2_tag0@@": "Entrée par rapport à laquelle la première entrée est testée pour déterminer si elle est supérieure.",
	"@@Greater-Than_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Greater-Than-Equal_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Greater-Than-Equal_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Greater-Than-Equal_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Greater-Than-Equal_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Greater-Than-Equal_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Greater-Than-Equal_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Greater-Than-Equal_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Greater-Than-Equal_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Greater-Than-Equal_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Greater-Than-Equal_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Greater-Than-Equal_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Greater-Than-Equal_Raster_tag0@@": "Entrée testée pour déterminer si elle est supérieure ou égale à la seconde entrée.",
	"@@Greater-Than-Equal_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Greater-Than-Equal_Raster2_tag0@@": "Entrée par rapport à laquelle la première entrée est testée pour déterminer si elle est supérieure ou égale.",
	"@@Greater-Than-Equal_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Heat-Index_Heat-Index-Units_tag0@@": "Unité de mesure associée au raster en sortie. Les unités disponibles en sortie sont Celsius, Fahrenheit et Kelvin.",
	"@@Heat-Index_Relative-Humidity-Raster_tag0@@": "Raster monocanal où les valeurs de pixel représentent l’humidité relative sous forme de valeur de pourcentage comprise entre 0 et 100.",
	"@@Heat-Index_Temperature-Raster_tag0@@": "Raster monocanal où les valeurs de pixel représentent la température de l’air ambiant.",
	"@@Heat-Index_Temperature-Units_tag0@@": "Unité de mesure associée au raster de température en entrée. Les unités disponibles en entrée sont Celsius, Fahrenheit et Kelvin.",
	"@@Hillshade_Altitude_tag0@@": "L'altitude représente l'angle solaire de l'altitude au-dessus de la ligne d'horizon et s'étend de 0 à 90 degrés. Une valeur de 0 degrés indique que le soleil est sur l'horizon, c'est-à-dire sur le même plan horizontal que le cadre de référence. Une valeur de 90 degrés indique que le soleil est directement au-dessus.",
	"@@Hillshade_Altitude_tag1@@": "Ce paramètre est valide uniquement si le <strong>Type d’ombrage</strong> est <strong>Traditionnel</strong>. La valeur par défaut est de 45 degrés au-dessus de l’horizon.",
	"@@Hillshade_Azimuth_tag0@@": "La propriété Azimut définit la position relative du soleil par rapport à l'horizon (en degrés). Cette position est indiquée par l'angle du soleil mesuré dans le sens horaire à partir du nord. Un azimut de 0 degré indique le Nord, l'Est est à 90 degrés, le Sud à 180 degrés et l'Ouest à 270 degrés.",
	"@@Hillshade_Azimuth_tag1@@": "Ce paramètre est valide uniquement si le <strong>Type d’ombrage</strong> est <strong>Traditionnel</strong>. La valeur par défaut est de 315 degrés, à partir du nord-ouest.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag0@@": "Cette option évite les artefacts de rééchantillonnage qui peuvent se produire le long des tronçons d'un raster. Les pixels en sortie le long du tronçon d'un raster ou à côté de pixels NoData sont renseignés avec NoData. Il est par conséquent recommandé d'utiliser ce paramètre uniquement avec des mosaïques d'altitude qui présentent une superposition. Lorsque des pixels superposés sont disponibles, les surfaces de NoData affichent les valeurs des pixels superposés au lieu de pixels vides.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag1@@": "Non coché : le rééchantillonnage bilinéaire est appliqué uniformément pour rééchantillonner votre ombrage. Utilisez cette option lorsque la mosaïque contenant vos données raster d'altitude a connu un assemblage côte à côte. Il s’agit de l’option par défaut.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag2@@": "Coché : le rééchantillonnage bilinéaire est utilisé au sein de l’ombrage, sauf le long des tronçons des rasters ou à côté des pixels de valeur NoData. Ces pixels sont renseignés avec NoData et affichent les valeurs de pixels superposés, ce qui réduit les effets de tronçons abrupts pouvant se produire. Utilisez cette option lorsque la mosaïque contenant vos données raster d'altitude se compose de tuiles ou d'éléments superposés.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag3@@": "Les résultats de la fonction peuvent dépendre des données. Si vous observez des artéfacts de limites de tuiles dans votre sortie, sélectionnez l'autre condition de la case à cocher.",
	"@@Hillshade_Hillshade-Type_tag0@@": "Contrôle la source d'éclairage de l'ombrage :",
	"@@Hillshade_Hillshade-Type_tag1@@": "Traditionnel : calcule l’ombrage à partir d’une seule direction d’éclairage. Il s’agit de l’option par défaut. Vous pouvez définir les options <strong>Azimut</strong> et <strong>Altitude</strong> pour contrôler l’emplacement de la source d’éclairage.",
	"@@Hillshade_Hillshade-Type_tag6@@": "Multidirectionnel : associe la lumière de plusieurs sources pour représenter une visualisation optimisée du terrain.",
	"@@Hillshade_Pixel-Size-Factor_tag0@@": "L’option Facteur de taille de pixel tient compte des changements d’échelle à mesure que l’utilisateur applique un zoom avant ou arrière sur l’affichage cartographique. Elle contrôle la vitesse à laquelle le <strong>Facteur Z</strong> change.",
	"@@Hillshade_Pixel-Size-Factor_tag3@@": "Ce paramètre est valide uniquement si le type de <strong>Mise à l’échelle</strong> est <strong>Ajusté</strong>. La valeur par défaut est 0,024.",
	"@@Hillshade_Pixel-Size-Power_tag0@@": "L’option Puissance de taille de pixel tient compte de l’évolution de l’altitude (ou de l’échelle) à mesure que la visionneuse applique un zoom avant ou arrière sur l’affichage cartographique. Il s’agit de l’exposant appliqué au terme de taille de pixel dans l’équation qui contrôle la fréquence à laquelle le <strong>Facteur Z</strong> change pour éviter les pertes de relief significatives.",
	"@@Hillshade_Pixel-Size-Power_tag3@@": "Ce paramètre est valide uniquement si le type de <strong>Mise à l’échelle</strong> est <strong>Ajusté</strong>. La valeur par défaut est 0,664.",
	"@@Hillshade_Raster_tag0@@": "Le jeu de données d'altitude en entrée.",
	"@@Hillshade_Scaling_tag0@@": "Le résultat ombré est mis à l'échelle dynamiquement en ajustant le facteur z grâce à l'une de deux options :",
	"@@Hillshade_Scaling_tag1@@": "Ajusté : applique un ajustement non linéaire en utilisant les valeurs de <strong>Puissance de taille de pixel</strong> et de <strong>Facteur de taille de pixel</strong> par défaut, qui tiennent compte des changements d’altitude (échelle) lors d’un zoom avant ou arrière. L’utilisation du paramètre <strong>Ajusté</strong> est recommandée en cas d’utilisation d’un jeu de données mondial.",
	"@@Hillshade_Scaling_tag8@@": "Aucun : aucune mise à l’échelle n’est appliquée. Cela est idéal pour un jeu de données raster unique qui couvre une zone locale. Cette option n'est pas recommandée pour les jeux de données mondiaux dont l'altitude varie beaucoup ou les cartes à plusieurs échelles, car elle génère un relief du MNT avec des variations restreintes à de petites échelles.",
	"@@Hillshade_Z-Factor_tag0@@": "Le facteur Z est un facteur d'échelle utilisé pour convertir les valeurs d'altitude dans deux buts :",
	"@@Hillshade_Z-Factor_tag1@@": "Convertit les unités d'altitude (telles que les mètres ou les pieds) en unités de coordonnées horizontales du jeu de données, qui peuvent être des pieds, des mètres ou des degrés,",
	"@@Hillshade_Z-Factor_tag2@@": "Ajoute une exagération verticale comme effet visuel.",
	"@@Int_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Int_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Int_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Int_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Int_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Int_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Int_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Int_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Int_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Int_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Int_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Int_Raster_tag0@@": "Raster en entrée à convertir en entier.",
	"@@Interpolate-Irregular-Data_Cellsize_tag0@@": "La taille de cellule du raster en sortie est automatiquement détectée, mais vous pouvez modifier ce comportement. La taille de cellule peut être modifiée, mais l’étendue du jeu de données raster reste identique.",
	"@@Interpolate-Irregular-Data_Input-Samples_tag0@@": "Les données ponctuelles en entrée.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag0@@": "Quatre méthodes de rééchantillonnage sont disponibles pour cette fonction :",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag1@@": "<strong>Pondération par l’inverse de la distance</strong> : détermine les valeurs des cellules via la combinaison pondérée de manière linéaire d’un ensemble de points d’échantillonnage ou de cellules. La pondération est une fonction de l’inverse de la distance à partir des cellules ou des points connus.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag3@@": "<strong>TIN linéaire</strong> : utilise un réseau triangulé irrégulier (TIN) à partir des points centraux de chaque cellule du raster irrégulier pour interpoler une surface qui sera ensuite convertie en raster régulier.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag5@@": "<strong>Voisin naturel</strong> : recherche le sous-ensemble d’échantillons en entrée le plus proche d’un point de requête et lui applique une pondération sur la base de surfaces proportionnelles afin d’interpoler une valeur.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag7@@": "<strong>Voisin le plus proche</strong> : calcule la valeur du pixel grâce au pixel le plus proche. Si aucun pixel source n’existe, aucun nouveau pixel ne peut être créé dans la sortie. Il s’agit de l’option par défaut.",
	"@@Interpolate-Irregular-Data_Search-Radius_tag0@@": "Identifie le nombre de pixels à inclure pour la méthode de rééchantillonnage sélectionnée. La valeur par défaut est ${3} pixels.",
	"@@Interpolate-Irregular-Data_Value-Field_tag0@@": "Si vous sélectionnez une classe d’entités ponctuelles en entrée, vous devrez identifier le champ dans la table attributaire avec la valeur des points.",
	"@@Is-Null_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Is-Null_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Is-Null_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Is-Null_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Is-Null_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Is-Null_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Is-Null_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Is-Null_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Is-Null_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Is-Null_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Is-Null_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Is-Null_Raster_tag0@@": "Raster en entrée testé pour identifier les cellules qui ont une valeur ${NoData} (nulle).",
	"@@Is-Null_Raster_tag1@@": "L'entrée peut être une valeur entière ou à virgule flottante.",
	"@@Key-Metadata_Band-Names_tag0@@": "Permet de remplacer les noms de canaux d'un raster. Il s'agit d'une chaîne séparée par une virgule représentant les noms de canaux mis à jour.",
	"@@Key-Metadata_Band-Names_tag1@@": "Ce paramètre est facultatif.",
	"@@Key-Metadata_Metadata-JSON_tag0@@": "Les métadonnées clés à injecter dans le raster sortant décrit comme une chaîne JSON représentant une collection de paires clé-valeur. Voici un exemple de chaîne JSON pouvant servir d'entrée à cette fonction. Toutes les entrées de ce paramètre doivent suivre le même format.",
	"@@Key-Metadata_Metadata-JSON_tag1@@": "Chaîne JSON représentant les métadonnées clés.",
	"@@Key-Metadata_Metadata-JSON_tag2@@": "{ \"CloudCover\": 4, \"BandProperties\":[ { \"BandName\": \"Blue\", \"WavelengthMin\": 445, \"WavelengthMax\": 516 }, { \"BandName\": \"Green\", \"WavelengthMin\": 506, \"WavelengthMax\": 595 }, ]}",
	"@@Key-Metadata_Property-Name_tag0@@": "Le nom de la propriété clé au niveau du jeu de données que vous souhaitez remplacer.",
	"@@Key-Metadata_Raster_tag0@@": "Le jeu de données raster ou la mosaïque contenant les métadonnées clés que vous souhaitez insérer ou remplacer.",
	"@@Key-Metadata_Value_tag0@@": "La valeur de remplacement de la propriété clé au niveau du jeu de données que vous souhaitez définir.",
	"@@Least-Cost-Path_Accumulative-Cost-Resistance-Rate_tag0@@": "Ce paramètre simule l’augmentation de l’effort pour surmonter les coûts au fur et à mesure que le coût cumulé augmente. Il permet de modéliser la fatigue du voyageur. Le coût cumulé croissant pour atteindre une cellule est multiplié par le taux de résistance et ajouté au coût engendré par le déplacement vers la cellule suivante.",
	"@@Least-Cost-Path_Accumulative-Cost-Resistance-Rate_tag1@@": "Il s’agit d’une version modifiée d’une formule de taux d’intérêt composé qui permet de calculer le coût apparent du déplacement à travers une cellule. Avec l'augmentation du taux de résistance, le coût des cellules qui sont visitées ultérieurement s'accroît également. Plus le taux de résistance est important, plus le coût de déplacement vers la cellule suivante augmente, lequel est ajouté pour chaque mouvement suivant. Puisque le taux de résistance est similaire à un taux composé et qu’habituellement les valeurs de coût cumulé sont très importantes, nous suggérons l’utilisation de taux de résistance faibles, tels que 0,005 ou encore inférieurs, selon les valeurs de coût cumulé.",
	"@@Least-Cost-Path_Accumulative-Cost-Resistance-Rate_tag2@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Least-Cost-Path_Capacity_tag0@@": "Définit la capacité de coût pour le voyageur pour une source. Les calculs de coût continuent pour chaque source jusqu’à ce que la capacité spécifiée soit atteinte.",
	"@@Least-Cost-Path_Capacity_tag1@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Least-Cost-Path_Cost-Raster_tag0@@": "Raster en entrée requis définissant le coût ou l’impédance de déplacement planimétrique à travers chaque cellule. La valeur à chaque emplacement de cellule représente le coût par unité de distance pour le déplacement à travers chaque cellule. Chaque valeur d’emplacement de cellule est multipliée par la résolution de cellule et compense également le mouvement diagonal afin d’obtenir le coût total du passage à travers la cellule.",
	"@@Least-Cost-Path_Cost-Raster_tag1@@": "Les valeurs du <strong>Raster de coût</strong> peuvent être des entiers ou des nombres à virgule flottante, mais elles ne peuvent pas être négatives ni nulles.",
	"@@Least-Cost-Path_Destination-Field_tag0@@": "Champ permettant d'obtenir des valeurs relatives aux emplacements de destination.",
	"@@Least-Cost-Path_Destination-Raster_tag0@@": "Raster en entrée requis identifiant les pixels à partir desquels le chemin de moindre coût est déterminé vers la source de moindre coût. Cette entrée est composée de pixels ayant des valeurs valides et les pixels restants doivent avoir la valeur ${NoData}. Les valeurs égales à 0 sont valides.",
	"@@Least-Cost-Path_Maximum-Distance_tag0@@": "Le seuil que les valeurs de coût cumulé ne peuvent pas dépasser. Si une distance de coût cumulé dépasse cette valeur, la valeur en sortie de l’emplacement de cellule est ${NoData}. La distance maximale définit l’étendue pour laquelle les distances de coût cumulé sont calculées. La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Least-Cost-Path_Multiplier-to-Apply-to-Costs_tag0@@": "Ce paramètre permet de contrôler le mode de déplacement ou la magnitude à une source. Plus le multiplicateur est élevé, plus le coût de déplacement d’une cellule à une autre est important.",
	"@@Least-Cost-Path_Multiplier-to-Apply-to-Costs_tag1@@": "Les valeurs doivent être supérieures à zéro. La valeur par défaut est 1.",
	"@@Least-Cost-Path_Path-Type_tag0@@": "Mot-clé définissant la façon dont les valeurs et les zones de l'entrée de destination sont interprétées dans les calculs du chemin de coût :",
	"@@Least-Cost-Path_Path-Type_tag1@@": "<strong>Le moins coûteux</strong> : pour tous les pixels des données de destination en entrée, le chemin du moindre coût est dérivé du pixel contenant le minimum de chemins de moindre coût vers les cellules sources.",
	"@@Least-Cost-Path_Path-Type_tag3@@": "<strong>Chaque cellule</strong> : un chemin de moindre coût est déterminé pour chaque pixel avec des valeurs valides dans les données de destination en entrée, puis enregistré dans le raster en sortie. Chaque cellule des données de destination en entrée est traitée séparément et un chemin de moindre coût est déterminé pour chaque cellule de départ.",
	"@@Least-Cost-Path_Path-Type_tag5@@": "<strong>Chaque zone</strong> : un chemin de moindre coût est déterminé pour chaque zone des données de destination en entrée, puis enregistré dans le raster en sortie. Le chemin de moindre coût commence au pixel avec la pondération de distance de plus faible coût dans la zone.",
	"@@Least-Cost-Path_Source-Raster_tag0@@": "Raster en entrée requis qui identifie les cellules ou les emplacements à partir desquels la distance de moindre coût cumulé est calculée pour chaque emplacement de cellule en sortie.",
	"@@Least-Cost-Path_Start-Cost_tag0@@": "Coût de départ du calcul des coûts. Ce paramètre permet de spécifier le coût fixe associé à une source. Plutôt que de commencer avec un coût égal à 0, l’algorithme de coût commence avec la valeur définie.",
	"@@Least-Cost-Path_Start-Cost_tag1@@": "La valeur doit être égale ou supérieure à zéro. La valeur par défaut est 0.",
	"@@Least-Cost-Path_Travel-Direction_tag0@@": "Définit le sens du voyageur en cas d’application du taux de résistance source et du coût de départ source.",
	"@@Least-Cost-Path_Travel-Direction_tag1@@": "<strong>À partir de la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de la source en entrée et en se déplaçant vers les cellules non sources. Il s’agit de l’option par défaut.",
	"@@Least-Cost-Path_Travel-Direction_tag3@@": "<strong>Vers la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de chaque cellule non source et en revenant vers la source en entrée.",
	"@@Least-Cost-Path_Travel-Direction_tag5@@": "Spécifiez le mot-clé <strong>À partir de la source</strong> ou <strong>Vers la source</strong>, qui est appliqué à toutes les sources, ou spécifiez un champ dans le <strong>Raster source</strong> qui contient les mots-clés permettant d’identifier le sens de déplacement pour chaque source. Ce champ doit contenir la chaîne ${FROM_SOURCE} ou ${TO_SOURCE}.",
	"@@Less-Than_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Less-Than_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Less-Than_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Less-Than_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Less-Than_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Less-Than_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Less-Than_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Less-Than_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Less-Than_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Less-Than_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Less-Than_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Less-Than_Raster_tag0@@": "Entrée testée pour déterminer si elle est inférieure à la seconde entrée.",
	"@@Less-Than_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Less-Than_Raster2_tag0@@": "Entrée par rapport à laquelle la première entrée est testée pour déterminer si elle est inférieure.",
	"@@Less-Than_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Less-Than-Equal_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Less-Than-Equal_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Less-Than-Equal_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Less-Than-Equal_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Less-Than-Equal_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Less-Than-Equal_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Less-Than-Equal_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Less-Than-Equal_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Less-Than-Equal_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Less-Than-Equal_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Less-Than-Equal_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Less-Than-Equal_Raster_tag0@@": "Entrée testée pour déterminer si elle est inférieure ou égale à la seconde entrée.",
	"@@Less-Than-Equal_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Less-Than-Equal_Raster2_tag0@@": "Entrée par rapport à laquelle la première entrée est testée pour déterminer si elle est inférieure ou égale.",
	"@@Less-Than-Equal_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Ln_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Ln_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Ln_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Ln_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Ln_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Ln_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Ln_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Ln_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Ln_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Ln_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Ln_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Ln_Raster_tag0@@": "Valeurs en entrée pour lesquelles calculer le logarithme naturel (Ln).",
	"@@Log10_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Log10_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Log10_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Log10_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Log10_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Log10_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Log10_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Log10_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Log10_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Log10_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Log10_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Log10_Raster_tag0@@": "Valeurs en entrée pour lesquelles on calcule le logarithme de base 10.",
	"@@Log2_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Log2_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Log2_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Log2_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Log2_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Log2_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Log2_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Log2_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Log2_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Log2_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Log2_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Log2_Raster_tag0@@": "Valeurs en entrée pour lesquelles on calcule le logarithme de base 2.",
	"@@Lookup_Field_tag0@@": "Champ contenant les valeurs souhaitées du nouveau raster.",
	"@@Lookup_Field_tag1@@": "Il doit s’agir d’un type numérique.",
	"@@Lookup_Raster_tag0@@": "Le raster en entrée contenant un champ à partir duquel vous voulez créer un raster.",
	"@@Lookup_Raster_tag1@@": "Il peut être de type entier ou à virgule flottante.",
	"@@Mask_Included-Ranges_tag0@@": "Les plages incluses peuvent être spécifiées pour chaque canal en définissant une valeur minimum et une valeur maximum ; toute valeur en dehors de cette plage renverra la valeur ${NoData}. Un pixel n’est inclus que si sa valeur est comprise dans l’une des plages spécifiées. Par conséquent, si le canal 1 a une plage de 5-10 et le canal 2 une plage de 15-20, et que la valeur de pixel pour le canal 1 est 8, ce pixel ne sera pas masqué.",
	"@@Mask_NoData-Interpretation_tag0@@": "Cela fait référence à la façon dont les <strong>Valeurs ${NoData}</strong> impactent l’image en sortie.",
	"@@Mask_NoData-Interpretation_tag3@@": "Vous pouvez choisir parmi les deux options suivantes :",
	"@@Mask_NoData-Interpretation_tag4@@": "<strong>Tous les critères</strong> : les valeurs ${NoData} que vous spécifiez pour chaque bande doivent se produire dans le même pixel pour que l’image en sortie contienne le pixel ${NoData}.",
	"@@Mask_NoData-Interpretation_tag6@@": "<strong>Certains critères</strong> : si la valeur ${NoData} que vous spécifiez se produit pour un pixel dans une bande spécifiée, ce pixel dans l’image en sortie prendra la valeur ${NoData}. Il s’agit de l’option par défaut.",
	"@@Mask_NoData-Values_tag0@@": "Les valeurs NoData peuvent être spécifiées pour chaque canal. Vous pouvez spécifier plusieurs valeurs en saisissant une liste de valeurs séparées par un espace.",
	"@@Mask_Raster_tag0@@": "Raster en entrée.",
	"@@Minus_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Minus_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Minus_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Minus_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Minus_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Minus_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Minus_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Minus_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Minus_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Minus_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Minus_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Minus_Raster_tag0@@": "Entrée de laquelle soustraire les valeurs de la deuxième entrée.",
	"@@Minus_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Minus_Raster2_tag0@@": "Valeurs en entrée à soustraire des valeurs de la première entrée.",
	"@@Minus_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@ML-Classify_Raster_tag0@@": "Raster en entrée à classer à l’aide de l’algorithme de classification de vraisemblance maximale.",
	"@@ML-Classify_Signature-File-or-URL_tag0@@": "Fichier de signatures ${.gsg}.",
	"@@Mod_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Mod_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Mod_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Mod_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Mod_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Mod_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Mod_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Mod_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Mod_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Mod_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Mod_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Mod_Raster_tag0@@": "Entrée du numérateur.",
	"@@Mod_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Mod_Raster2_tag0@@": "Entrée du dénominateur.",
	"@@Mod_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Mosaic-Rasters_Operation_tag0@@": "Résout les conflits lorsque des parties de deux images ou plus se superposent. Voici quelques-unes des options disponibles :",
	"@@Mosaic-Rasters_Operation_tag1@@": "<strong>Fusionner</strong> : calculer et afficher une moyenne des pixels superposés en attribuant une pondération plus élevée aux pixels les plus proches des images voisines afin de générer une image plus lisse. Il s’agit de l’option par défaut.",
	"@@Mosaic-Rasters_Operation_tag3@@": "<strong>Premier</strong> : afficher les pixels de la première image dans la liste des images qui se superposent à une zone donnée.",
	"@@Mosaic-Rasters_Operation_tag5@@": "<strong>Dernier</strong> : afficher les pixels de la dernière image dans la liste des images qui se superposent à une zone donnée.",
	"@@Mosaic-Rasters_Operation_tag7@@": "<strong>Max</strong> : afficher la valeur de pixel la plus élevée de toutes les couches superposées. Avec cette option, rien ne garantit que vous affichiez les pixels d’une seule image dans la zone de superposition. Il s’agit plutôt d’une combinaison des couches potentielles.",
	"@@Mosaic-Rasters_Operation_tag9@@": "<strong>Moyenne</strong> : calculer et afficher une moyenne des pixels superposés.",
	"@@Mosaic-Rasters_Operation_tag11@@": "<strong>Min</strong> : afficher la valeur de pixel la plus faible de toutes les couches superposées. Avec cette option, rien ne garantit que vous affichiez les pixels d’une seule image dans la zone de superposition. Il s’agit plutôt d’une combinaison des couches potentielles.",
	"@@Mosaic-Rasters_Rasters_tag0@@": "Sélectionner les raster que vous souhaitez mosaïquer ensemble pour former une image.",
	"@@NDVI_Infrared-Band-ID_tag0@@": "Spécifie l’ID de canal qui représente la partie infrarouge proche du spectre électromagnétique.",
	"@@NDVI_Raster_tag0@@": "Raster multispectral en entrée.",
	"@@NDVI_Scientific-Output_tag0@@": "Les valeurs en sortie vont de -1.0 à 1.0, ce qui est utilisé dans de nombreuses applications scientifiques.",
	"@@NDVI_Visible-Band-ID_tag0@@": "Spécifie l’ID de canal qui représente la partie rouge du spectre électromagnétique.",
	"@@NDVI-Colorized_Color-Ramp_tag0@@": "Choisissez un dégradé de couleurs prédéfini dans la liste déroulante.",
	"@@NDVI-Colorized_Color-Scheme-Type_tag0@@": "Sélectionnez le type de combinaison de couleurs avec lequel la sortie NDVI sera colorisée :",
	"@@NDVI-Colorized_Color-Scheme-Type_tag1@@": "Palette de couleurs : choisissez une palette de couleurs prédéfinie dans la liste déroulante. Vous avez également la possibilité d’accéder à un fichier de palette de couleurs existant.",
	"@@NDVI-Colorized_Color-Scheme-Type_tag2@@": "Dégradé de couleurs : choisissez une combinaison de couleurs prédéfinie dans la liste déroulante.",
	"@@NDVI-Colorized_Colormap_tag0@@": "Choisissez une palette de couleurs prédéfinie dans la liste déroulante. Vous pouvez aussi accéder à un fichier de palette de couleurs existant.",
	"@@NDVI-Colorized_Infrared-Band-ID_tag0@@": "Spécifie l’ID de canal qui représente la partie infrarouge proche du spectre électromagnétique.",
	"@@NDVI-Colorized_Raster_tag0@@": "Raster multispectral en entrée.",
	"@@NDVI-Colorized_Scientific-Output_tag0@@": "Les valeurs en sortie vont de -1.0 à 1.0, ce qui est utilisé dans de nombreuses applications scientifiques.",
	"@@NDVI-Colorized_Visible-Band-ID_tag0@@": "Spécifie l’ID de canal qui représente la partie rouge du spectre électromagnétique.",
	"@@Negate_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Negate_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Negate_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Negate_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Negate_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Negate_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Negate_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Negate_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Negate_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Negate_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Negate_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Negate_Raster_tag0@@": "Raster en entrée dont l'opposé est calculé (multiplication par -1).",
	"@@Nibble_Mask-Raster_tag0@@": "Raster en entrée requis utilisé comme masque.",
	"@@Nibble_Mask-Raster_tag1@@": "Les cellules avec la valeur NoData sont grignotées dans le <strong>Raster</strong> en entrée.",
	"@@Nibble_Mask-Raster_tag4@@": "Le raster de masque peut être de type entier ou à virgule flottante.",
	"@@Nibble_Nibble-NoData-cells_tag0@@": "Définit si les cellules NoData dans le raster en entrée conserveront une valeur NoData dans le raster en sortie.",
	"@@Nibble_Nibble-NoData-cells_tag1@@": "<strong>Non</strong> : spécifie que les cellules NoData du raster en entrée resteront de type NoData dans le raster en sortie. Il s’agit de l’option par défaut.",
	"@@Nibble_Nibble-NoData-cells_tag3@@": "<strong>Oui</strong> : spécifie que les cellules NoData du raster en entrée et dans le masque peuvent être grignotées en valeurs de cellules en sortie valides.",
	"@@Nibble_Raster_tag0@@": "Raster en entrée requis qui sera grignoté.",
	"@@Nibble_Raster_tag1@@": "Le raster en entrée peut être une valeur entière ou à virgule flottante.",
	"@@Nibble_Use-NoData-values-if-they-are-the-nearest-neighbor_tag0@@": "Définit si les valeurs ${NoData} du raster en entrée peuvent grignoter la zone définie par le raster de masque.",
	"@@Nibble_Use-NoData-values-if-they-are-the-nearest-neighbor_tag1@@": "<strong>Oui</strong> : spécifie que la valeur du voisin le plus proche sera utilisée, que cette valeur soit ${NoData} ou une autre valeur de données dans le raster en entrée. Les valeurs ${NoData} dans le raster en entrée peuvent grignoter les zones définies dans le masque si elles constituent le voisin le plus proche. Il s’agit de l’option par défaut.",
	"@@Nibble_Use-NoData-values-if-they-are-the-nearest-neighbor_tag3@@": "<strong>Non</strong> : spécifie que seules les valeurs de données peuvent grignoter les zones définies dans le raster de masque. Les valeurs ${NoData} dans le raster en entrée ne sont pas autorisées à grignoter les zones définies dans le raster de masque, même si elles constituent le voisin le plus proche.",
	"@@Nibble_Zone-Raster_tag0@@": "Raster de zones en entrée.",
	"@@Nibble_Zone-Raster_tag1@@": "Une zone contient toutes les cellules d’un raster possédant la même valeur, qu’elles soient contiguës ou non. La couche de zone en entrée régit la forme, les valeurs et les emplacements des zones. Le raster de zones peut être de type entier ou à virgule flottante.",
	"@@Not-Equal_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Not-Equal_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Not-Equal_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Not-Equal_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Not-Equal_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Not-Equal_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Not-Equal_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Not-Equal_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Not-Equal_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Not-Equal_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Not-Equal_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Not-Equal_Raster_tag0@@": "Entrée qui sera comparée pour déterminer l'inégalité avec la deuxième entrée.",
	"@@Not-Equal_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Not-Equal_Raster2_tag0@@": "Entrée qui sera comparée à la première entrée pour déterminer l'inégalité.",
	"@@Not-Equal_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Pansharpening_Multispectral_tag0@@": "Le raster multispectral que vous voulez affiner à l’aide du canal panchromatique.",
	"@@Pansharpening_Panchromatic_tag0@@": "Le raster monocanal haute résolution utilisé pour affiner le raster multispectral de plus faible résolution.",
	"@@Pansharpening_Pansharpening-Type_tag0@@": "Sélectionnez l’algorithme d’affinage panchromatique à utiliser.",
	"@@Pansharpening_Pansharpening-Type_tag1@@": "Brovey : utilise l’algorithme Brovey basé sur la modélisation spectrale pour la fusion des données.",
	"@@Pansharpening_Pansharpening-Type_tag2@@": "ESRI : utilise l’algorithme ESRI basé sur la modélisation spectrale pour la fusion des données.",
	"@@Pansharpening_Pansharpening-Type_tag3@@": "Gram-Schmidt : l’algorithme d’affinage spectral Gram-Schmidt permet d’affiner les données multispectrales.",
	"@@Pansharpening_Pansharpening-Type_tag4@@": "IHS : utilise l’espace de couleur Intensité, Teinte et Saturation pour la fusion des données.",
	"@@Pansharpening_Pansharpening-Type_tag5@@": "Moyenne : utilise la valeur moyenne entre les valeurs rouge, vert et bleu et la valeur du pixel panchromatique.",
	"@@Pansharpening_Weights_tag0@@": "Spécifiez les pondérations des canaux rouge, vert, bleu et infrarouge. Toutes les valeurs doivent être comprises entre 0 et 1.",
	"@@Path-Distance_Accumulative-Cost-Resistance-Rate_tag0@@": "Ce paramètre simule l’augmentation de l’effort pour surmonter les coûts au fur et à mesure que le coût cumulé augmente. Il permet de modéliser la fatigue du voyageur. Le coût cumulé croissant pour atteindre une cellule est multiplié par le taux de résistance et ajouté au coût engendré par le déplacement vers la cellule suivante.",
	"@@Path-Distance_Accumulative-Cost-Resistance-Rate_tag1@@": "Il s’agit d’une version modifiée d’une formule de taux d’intérêt composé qui permet de calculer le coût apparent du déplacement à travers une cellule. Avec l'augmentation du taux de résistance, le coût des cellules qui sont visitées ultérieurement s'accroît également. Plus le taux de résistance est important, plus le coût de déplacement vers la cellule suivante augmente, lequel est ajouté pour chaque mouvement suivant. Puisque le taux de résistance est similaire à un taux composé et qu’habituellement les valeurs de coût cumulé sont très importantes, nous suggérons l’utilisation de taux de résistance faibles, tels que 0,005 ou encore inférieurs, selon les valeurs de coût cumulé.",
	"@@Path-Distance_Accumulative-Cost-Resistance-Rate_tag2@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Path-Distance_Capacity_tag0@@": "Définit la capacité de coût pour le voyageur pour une source. Les calculs de coût continuent pour chaque source jusqu’à ce que la capacité spécifiée soit atteinte.",
	"@@Path-Distance_Capacity_tag1@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Path-Distance_Cost-Raster_tag0@@": "Raster en entrée requis définissant le coût ou l’impédance de déplacement planimétrique à travers chaque cellule. La valeur à chaque emplacement de cellule représente le coût par unité de distance pour le déplacement à travers chaque cellule. Chaque valeur d’emplacement de cellule est multipliée par la résolution de cellule et compense également le mouvement diagonal afin d’obtenir le coût total du passage à travers la cellule.",
	"@@Path-Distance_Cost-Raster_tag1@@": "Les valeurs du <strong>Raster de coût</strong> peuvent être des entiers ou des nombres à virgule flottante, mais elles ne peuvent pas être négatives ni nulles.",
	"@@Path-Distance_horizontalfactor_tag0@@": "<p>Définit la relation entre le facteur de coût horizontal et l’angle de déplacement relatif horizontal (HRMA).</p><p>Plusieurs facteurs, avec modificateurs, identifient un diagramme de facteurs verticaux défini. En outre, vous pouvez utiliser une table pour créer un diagramme personnalisé. Les diagrammes permettent d’identifier le facteur vertical utilisé pour le calcul du coût total d’un déplacement vers une cellule voisine.</p><p>Dans les explications ci-dessous, deux acronymes sont utilisés : HF et HRMA. Le facteur HF correspond au facteur horizontal qui représente la difficulté horizontale rencontrée lors d’un déplacement d’une cellule vers la suivante. L’angle HRMA correspond à l’angle de déplacement relatif horizontal, lequel représente l’angle entre la direction horizontale d’une cellule et la direction du déplacement.</p><p>Les types de <strong>Facteur horizontal</strong> sont les suivants :</p><ul><li><strong>Binaire</strong> : indique que si l’angle HRMA est inférieur à l’angle d’inflexion, le facteur HF a la valeur associée au facteur zéro. Dans le cas contraire, le facteur horizontal a une valeur infinie.</li><li><strong>Avant</strong> : précise que seul un mouvement vers l’avant est autorisé. L’angle HRMA doit être supérieur ou égal à 0 et inférieur à 90 degrés (0 &lt;= HRMA &lt; 90). Si l’angle HRMA est compris entre 0 et 45 degrés, le facteur HF de la cellule a la valeur associée au facteur zéro. Si l’angle HRMA est supérieur ou égal à 45 degrés, la valeur du modificateur de la valeur de bord est utilisée. Le facteur HF pour un angle HRMA égal ou supérieur à 90 degrés a une valeur infinie.</li><li><strong>Linéaire</strong> : spécifie que le facteur HF est une fonction linéaire de l’angle HRMA.</li><li><strong>Linéaire inverse</strong> : spécifie que le facteur HF est une fonction linéaire inverse de l’angle HRMA.</li><li><strong>Table</strong> : indique qu’un fichier de table sera utilisé pour définir le diagramme des facteurs horizontaux permettant de déterminer les facteurs HF.</li></ul><p>Les modificateurs des facteurs horizontaux sont les suivants :</p><ul><li><strong>Facteur zéro</strong> : définit le facteur horizontal à utiliser lorsque l’angle HRMA est nul. Ce facteur positionne l’intersection avec l’axe des y de toutes les fonctions de facteur horizontal.</li><li><strong>Angle d’inflexion</strong> : définit l’angle HRMA au-delà duquel le facteur HF a une valeur infinie.</li><li><strong>Pente</strong> : définit la pente de la ligne droite utilisée avec les mots-clés de facteur horizontal <strong>Linéaire</strong> et <strong>Linéaire inverse</strong>. La pente est spécifiée sous forme d’un rapport de la hauteur sur la distance parcourue (par exemple, une pente de 45 pour cent correspond à 1/45, la valeur introduite étant 0,02222).</li><li><strong>Valeur de bord</strong> : définit le facteur HF lorsque l’angle HRMA est supérieur ou égal à 45 degrés et inférieur à 90 degrés lorsque le mot-clé de facteur horizontal <strong>Avant</strong> est spécifié.</li><li><strong>Nom de la table</strong> : correspond au nom de la table définissant le facteur HF.</li></ul>",
	"@@Path-Distance_Horizontal-Raster_tag0@@": "Un raster définissant la direction horizontale pour chaque cellule.",
	"@@Path-Distance_Horizontal-Raster_tag1@@": "Les valeurs du raster doivent être des entiers compris entre 0 et 360, 0 degré correspondant au nord (vers le haut de l’écran). Elles augmentent dans le sens horaire. La valeur -1 doit être attribuée aux surfaces planes. Les valeurs à chaque emplacement seront utilisées conjointement au <strong>Facteur horizontal</strong> afin de déterminer le coût horizontal encouru lors d’un déplacement à partir d’une cellule vers les cellules voisines.",
	"@@Path-Distance_Maximum-Distance_tag0@@": "Le seuil que les valeurs de coût cumulé ne peuvent pas dépasser. Si une distance de coût cumulé dépasse cette valeur, la valeur en sortie de l’emplacement de cellule est NoData. La distance maximale définit l’étendue pour laquelle les distances de coût cumulé sont calculées. La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag0@@": "Multiplicateur à appliquer aux valeurs de coût.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag1@@": "Ce paramètre permet de contrôler le mode de déplacement ou la magnitude à une source. Plus le multiplicateur est élevé, plus le coût de déplacement d’une cellule à une autre est important.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag2@@": "Les valeurs doivent être supérieures à zéro. La valeur par défaut est 1.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag3@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Path-Distance_Source-Raster_tag0@@": "Le raster en entrée requis des emplacements source.",
	"@@Path-Distance_Source-Raster_tag1@@": "Raster qui identifie les cellules ou les emplacements à partir desquels la distance de moindre coût cumulé est calculée pour chaque emplacement de cellule en sortie.",
	"@@Path-Distance_Source-Raster_tag2@@": "Il peut s’agir d’un entier ou d’un nombre à virgule flottante.",
	"@@Path-Distance_Start-Cost_tag0@@": "Coût de départ du calcul des coûts. Ce paramètre permet de spécifier le coût fixe associé à une source. Plutôt que de commencer avec un coût égal à 0, l’algorithme de coût commence avec la valeur définie.",
	"@@Path-Distance_Start-Cost_tag1@@": "La valeur doit être égale ou supérieure à zéro. La valeur par défaut est 0.",
	"@@Path-Distance_Surface-Raster_tag0@@": "Un raster définissant les valeurs d'altitudes à chaque emplacement de cellule.",
	"@@Path-Distance_Surface-Raster_tag1@@": "Ces valeurs permettent de calculer la distance à la surface réelle qui est couverte lors du passage d'une cellule à une autre.",
	"@@Path-Distance_Travel-Direction_tag0@@": "Définit le sens du voyageur en cas d’application du taux de résistance source et du coût de départ source.",
	"@@Path-Distance_Travel-Direction_tag1@@": "<strong>À partir de la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de la source en entrée et en se déplaçant vers les cellules non sources. Il s’agit de l’option par défaut.",
	"@@Path-Distance_Travel-Direction_tag3@@": "<strong>Vers la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de chaque cellule non source et en revenant vers la source en entrée.",
	"@@Path-Distance_Travel-Direction_tag5@@": "Spécifiez le mot-clé <strong>À partir de la source</strong> ou <strong>Vers la source</strong>, qui est appliqué à toutes les sources, ou spécifiez un champ dans le <strong>Raster source</strong> qui contient les mots-clés permettant d’identifier le sens de déplacement pour chaque source. Ce champ doit contenir la chaîne ${FROM_SOURCE} ou ${TO_SOURCE}.",
	"@@Path-Distance_verticalfactor_tag0@@": "<p>Définit la relation entre le facteur de coût vertical et l’angle de déplacement relatif vertical (VRMA).</p><p>Plusieurs facteurs, avec modificateurs, identifient un diagramme de facteurs verticaux défini. En outre, vous pouvez utiliser une table pour créer un diagramme personnalisé. Les diagrammes permettent d’identifier le facteur vertical utilisé pour le calcul du coût total d’un déplacement vers une cellule voisine.</p><p>Dans les explications ci-dessous, deux acronymes sont utilisés : VF et VRMA. Le facteur VF correspond au facteur vertical, lequel représente la difficulté verticale rencontrée lors d’un déplacement d’une cellule vers la suivante. L’angle VRMA correspond à l’angle de déplacement relatif vertical, lequel représente l’angle de la pente entre la cellule FROM (Origine), ou de traitement, et la cellule TO (Destination).</p><p>Les types de <strong>Facteur vertical</strong> sont les suivants :</p><ul><li><strong>Binaire</strong> : spécifie que si l’angle VRMA est supérieur à l’angle d’inflexion inférieur et inférieur à l’angle d’inflexion supérieur, le facteur VF doit correspondre à la valeur associée au facteur zéro. Dans le cas contraire, le facteur vertical a une valeur infinie.</li><li><strong>Linéaire</strong> : indique que le facteur VF est une fonction linéaire de l’angle VRMA.</li><li><strong>Linéaire symétrique</strong> : spécifie que le facteur VF est une fonction linéaire de l’angle VRMA, du côté négatif ou du côté positif de l’angle VRMA, respectivement, et que les deux fonctions linéaires sont symétriques par rapport à l’axe (y) du facteur VF.</li><li><strong>Linéaire inverse</strong> : indique que le facteur VF est une fonction linéaire inverse de l’angle VRMA.</li><li><strong>Linéaire inverse symétrique</strong> : spécifie que le facteur VF est une fonction linéaire inverse de l’angle VRMA, du côté négatif ou du côté positif de l’angle VRMA, respectivement, et que les deux fonctions linéaires sont symétriques par rapport à l’axe (y) du facteur VF.</li><li><strong>Cos</strong> : identifie le facteur VF comme une fonction cosinusoïdale de l’angle VRMA.</li><li><strong>Sec</strong> : identifie le facteur VF comme une fonction sécante de l’angle VRMA.</li><li><strong>Cos-Sec</strong> : spécifie que le facteur VF est une fonction cosinusoïdale de l’angle VRMA lorsque ce dernier est négatif et qu’il est une fonction sécante de l’angle VRMA lorsque ce dernier n’est pas négatif.</li><li><strong>Sec-Cos</strong> : spécifie que le facteur VF est une fonction sécante de l’angle VRMA lorsque ce dernier est négatif et qu’il est une fonction cosinusoïdale de l’angle VRMA lorsque ce dernier n’est pas négatif.</li><li><strong>Table</strong> : indique qu’un fichier de table sera utilisé pour définir le diagramme des facteurs verticaux permettant de déterminer les facteurs VF.</li></ul><p>Les modificateurs des mots-clés de facteur vertical sont les suivants :</p><ul><li><strong>Facteur zéro</strong> : définit le facteur vertical utilisé lorsque l’angle VRMA est nul. Ce facteur positionne l’intersection avec l’axe des y de la fonction spécifiée. Par définition, le facteur zéro ne s’applique à aucune fonction verticale trigonométrique (COS, SEC, COS-SEC ou SEC-COS). Ces fonctions définissent l’interception de l’axe des y.</li><li><strong>Angle d’inflexion inférieur</strong> : définit l’angle VRMA en dessous duquel le facteur VF a une valeur infinie.</li><li><strong>Angle d’inflexion supérieur</strong> : définit l’angle VRMA au-dessus duquel le facteur VF a une valeur infinie.</li><li><strong>Pente</strong> : définit la pente de la ligne droite utilisée avec les mots-clés de facteur vertical <strong>Linéaire</strong> et <strong>Linéaire inverse</strong>. La pente est spécifiée sous forme d’un rapport de la hauteur sur la distance parcourue (par exemple, une pente de 45 pour cent correspond à 1/45, la valeur introduite étant 0,02222).</li><li><strong>Nom de la table</strong> : correspond au nom de la table définissant le facteur VF.</li></ul>",
	"@@Path-Distance_Vertical-Raster_tag0@@": "Définit la relation entre le facteur de coût vertical et l'angle de déplacement relatif vertical (VRMA, vertical relative moving angle).",
	"@@Path-Distance_Vertical-Raster_tag1@@": "Ces valeurs permettent de calculer la pente utilisée pour identifier le facteur vertical relatif au déplacement d'une cellule à une autre.",
	"@@Path-Distance-Allocation_Accumulative-Cost-Resistance-Rate_tag0@@": "Ce paramètre simule l’augmentation de l’effort pour surmonter les coûts au fur et à mesure que le coût cumulé augmente. Il permet de modéliser la fatigue du voyageur. Le coût cumulé croissant pour atteindre une cellule est multiplié par le taux de résistance et ajouté au coût engendré par le déplacement vers la cellule suivante.",
	"@@Path-Distance-Allocation_Accumulative-Cost-Resistance-Rate_tag1@@": "Il s’agit d’une version modifiée d’une formule de taux d’intérêt composé qui permet de calculer le coût apparent du déplacement à travers une cellule. Avec l'augmentation du taux de résistance, le coût des cellules qui sont visitées ultérieurement s'accroît également. Plus le taux de résistance est important, plus le coût de déplacement vers la cellule suivante augmente, lequel est ajouté pour chaque mouvement suivant. Puisque le taux de résistance est similaire à un taux composé et qu’habituellement les valeurs de coût cumulé sont très importantes, nous suggérons l’utilisation de taux de résistance faibles, tels que 0,005 ou encore inférieurs, selon les valeurs de coût cumulé.",
	"@@Path-Distance-Allocation_Accumulative-Cost-Resistance-Rate_tag2@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Path-Distance-Allocation_Capacity_tag0@@": "Définit la capacité de coût pour le voyageur pour une source. Les calculs de coût continuent pour chaque source jusqu’à ce que la capacité spécifiée soit atteinte.",
	"@@Path-Distance-Allocation_Capacity_tag1@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Path-Distance-Allocation_Cost-Raster_tag0@@": "Raster en entrée requis définissant le coût ou l’impédance de déplacement planimétrique à travers chaque cellule. La valeur à chaque emplacement de cellule représente le coût par unité de distance pour le déplacement à travers chaque cellule. Chaque valeur d’emplacement de cellule est multipliée par la résolution de cellule et compense également le mouvement diagonal afin d’obtenir le coût total du passage à travers la cellule.",
	"@@Path-Distance-Allocation_Cost-Raster_tag1@@": "Les valeurs du <strong>Raster de coût</strong> peuvent être des entiers ou des nombres à virgule flottante, mais elles ne peuvent pas être négatives ni nulles.",
	"@@Path-Distance-Allocation_horizontalfactor_tag0@@": "<p>Définit la relation entre le facteur de coût horizontal et l’angle de déplacement relatif horizontal (HRMA).</p><p>Plusieurs facteurs, avec modificateurs, identifient un diagramme de facteurs verticaux défini. En outre, vous pouvez utiliser une table pour créer un diagramme personnalisé. Les diagrammes permettent d’identifier le facteur vertical utilisé pour le calcul du coût total d’un déplacement vers une cellule voisine.</p><p>Dans les explications ci-dessous, deux acronymes sont utilisés : HF et HRMA. Le facteur HF correspond au facteur horizontal qui représente la difficulté horizontale rencontrée lors d’un déplacement d’une cellule vers la suivante. L’angle HRMA correspond à l’angle de déplacement relatif horizontal, lequel représente l’angle entre la direction horizontale d’une cellule et la direction du déplacement.</p><p>Les types de <strong>Facteur horizontal</strong> sont les suivants :</p><ul><li><strong>Binaire</strong> : indique que si l’angle HRMA est inférieur à l’angle d’inflexion, le facteur HF a la valeur associée au facteur zéro. Dans le cas contraire, le facteur horizontal a une valeur infinie.</li><li><strong>Avant</strong> : précise que seul un mouvement vers l’avant est autorisé. L’angle HRMA doit être supérieur ou égal à 0 et inférieur à 90 degrés (0 &lt;= HRMA &lt; 90). Si l’angle HRMA est compris entre 0 et 45 degrés, le facteur HF de la cellule a la valeur associée au facteur zéro. Si l’angle HRMA est supérieur ou égal à 45 degrés, la valeur du modificateur de la valeur de bord est utilisée. Le facteur HF pour un angle HRMA égal ou supérieur à 90 degrés a une valeur infinie.</li><li><strong>Linéaire</strong> : spécifie que le facteur HF est une fonction linéaire de l’angle HRMA.</li><li><strong>Linéaire inverse</strong> : spécifie que le facteur HF est une fonction linéaire inverse de l’angle HRMA.</li><li><strong>Table</strong> : indique qu’un fichier de table sera utilisé pour définir le diagramme des facteurs horizontaux permettant de déterminer les facteurs HF.</li></ul><p>Les modificateurs des facteurs horizontaux sont les suivants :</p><ul><li><strong>Facteur zéro</strong> : définit le facteur horizontal à utiliser lorsque l’angle HRMA est nul. Ce facteur positionne l’intersection avec l’axe des y de toutes les fonctions de facteur horizontal.</li><li><strong>Angle d’inflexion</strong> : définit l’angle HRMA au-delà duquel le facteur HF a une valeur infinie.</li><li><strong>Pente</strong> : définit la pente de la ligne droite utilisée avec les mots-clés de facteur horizontal <strong>Linéaire</strong> et <strong>Linéaire inverse</strong>. La pente est spécifiée sous forme d’un rapport de la hauteur sur la distance parcourue (par exemple, une pente de 45 pour cent correspond à 1/45, la valeur introduite étant 0,02222).</li><li><strong>Valeur de bord</strong> : définit le facteur HF lorsque l’angle HRMA est supérieur ou égal à 45 degrés et inférieur à 90 degrés lorsque le mot-clé de facteur horizontal <strong>Avant</strong> est spécifié.</li><li><strong>Nom de la table</strong> : correspond au nom de la table définissant le facteur HF.</li></ul>",
	"@@Path-Distance-Allocation_Horizontal-Raster_tag0@@": "Un raster définissant la direction horizontale pour chaque cellule.",
	"@@Path-Distance-Allocation_Horizontal-Raster_tag1@@": "Les valeurs du raster doivent être des entiers compris entre 0 et 360, 0 degré correspondant au nord (vers le haut de l’écran). Elles augmentent dans le sens horaire. La valeur -1 doit être attribuée aux surfaces planes. Les valeurs à chaque emplacement seront utilisées conjointement au <strong>Facteur horizontal</strong> afin de déterminer le coût horizontal encouru lors d’un déplacement à partir d’une cellule vers les cellules voisines.",
	"@@Path-Distance-Allocation_Maximum-Distance_tag0@@": "Le seuil que les valeurs de coût cumulé ne peuvent pas dépasser. Si une distance de coût cumulé dépasse cette valeur, la valeur en sortie de l’emplacement de cellule est NoData. La distance maximale définit l’étendue pour laquelle les distances de coût cumulé sont calculées. La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag0@@": "Multiplicateur à appliquer aux valeurs de coût.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag1@@": "Ce paramètre permet de contrôler le mode de déplacement ou la magnitude à une source. Plus le multiplicateur est élevé, plus le coût de déplacement d’une cellule à une autre est important.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag2@@": "Les valeurs doivent être supérieures à zéro. La valeur par défaut est 1.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag3@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Path-Distance-Allocation_Source-Field_tag0@@": "Champ permettant d’attribuer des valeurs aux emplacements sources. Il doit être de type entier. Si le <strong>Raster de valeur</strong> a été défini, les valeurs dans cette entrée sont prioritaires sur tout paramètre du <strong>Champ source</strong>.",
	"@@Path-Distance-Allocation_Source-Raster_tag0@@": "Le raster en entrée requis des emplacements source.",
	"@@Path-Distance-Allocation_Source-Raster_tag1@@": "Raster qui identifie les cellules ou les emplacements à partir desquels la distance de moindre coût cumulé est calculée pour chaque emplacement de cellule en sortie.",
	"@@Path-Distance-Allocation_Source-Raster_tag2@@": "Il peut s’agir d’un entier ou d’un nombre à virgule flottante.",
	"@@Path-Distance-Allocation_Start-Cost_tag0@@": "Coût de départ du calcul des coûts. Ce paramètre permet de spécifier le coût fixe associé à une source. Plutôt que de commencer avec un coût égal à 0, l’algorithme de coût commence avec la valeur définie.",
	"@@Path-Distance-Allocation_Start-Cost_tag1@@": "La valeur doit être égale ou supérieure à zéro. La valeur par défaut est 0.",
	"@@Path-Distance-Allocation_Surface-Raster_tag0@@": "Un raster définissant les valeurs d'altitudes à chaque emplacement de cellule.",
	"@@Path-Distance-Allocation_Surface-Raster_tag1@@": "Ces valeurs permettent de calculer la distance à la surface réelle qui est couverte lors du passage d'une cellule à une autre.",
	"@@Path-Distance-Allocation_Travel-Direction_tag0@@": "Définit le sens du voyageur en cas d’application du taux de résistance source et du coût de départ source.",
	"@@Path-Distance-Allocation_Travel-Direction_tag1@@": "<strong>À partir de la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de la source en entrée et en se déplaçant vers les cellules non sources. Il s’agit de l’option par défaut.",
	"@@Path-Distance-Allocation_Travel-Direction_tag3@@": "<strong>Vers la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de chaque cellule non source et en revenant vers la source en entrée.",
	"@@Path-Distance-Allocation_Travel-Direction_tag5@@": "Spécifiez le mot-clé <strong>À partir de la source</strong> ou <strong>Vers la source</strong>, qui est appliqué à toutes les sources, ou spécifiez un champ dans le <strong>Raster source</strong> qui contient les mots-clés permettant d’identifier le sens de déplacement pour chaque source. Ce champ doit contenir la chaîne ${FROM_SOURCE} ou ${TO_SOURCE}.",
	"@@Path-Distance-Allocation_Value-Raster_tag0@@": "Raster d’entiers en entrée qui identifie les valeurs de zone à utiliser pour chaque emplacement source en entrée. Pour chaque cellule d’emplacement source, la valeur définie par le <strong>Raster de valeur</strong> est attribuée à toutes les cellules allouées à l’emplacement source pour le calcul. Le <strong>Raster de valeur</strong> est prioritaire sur tout paramètre du <strong>Champ source</strong>.",
	"@@Path-Distance-Allocation_verticalfactor_tag0@@": "<p>Définit la relation entre le facteur de coût vertical et l’angle de déplacement relatif vertical (VRMA).</p><p>Plusieurs facteurs, avec modificateurs, identifient un diagramme de facteurs verticaux défini. En outre, vous pouvez utiliser une table pour créer un diagramme personnalisé. Les diagrammes permettent d’identifier le facteur vertical utilisé pour le calcul du coût total d’un déplacement vers une cellule voisine.</p><p>Dans les explications ci-dessous, deux acronymes sont utilisés : VF et VRMA. Le facteur VF correspond au facteur vertical, lequel représente la difficulté verticale rencontrée lors d’un déplacement d’une cellule vers la suivante. L’angle VRMA correspond à l’angle de déplacement relatif vertical, lequel représente l’angle de la pente entre la cellule FROM (Origine), ou de traitement, et la cellule TO (Destination).</p><p>Les types de <strong>Facteur vertical</strong> sont les suivants :</p><ul><li><strong>Binaire</strong> : spécifie que si l’angle VRMA est supérieur à l’angle d’inflexion inférieur et inférieur à l’angle d’inflexion supérieur, le facteur VF doit correspondre à la valeur associée au facteur zéro. Dans le cas contraire, le facteur vertical a une valeur infinie.</li><li><strong>Linéaire</strong> : indique que le facteur VF est une fonction linéaire de l’angle VRMA.</li><li><strong>Linéaire symétrique</strong> : spécifie que le facteur VF est une fonction linéaire de l’angle VRMA, du côté négatif ou du côté positif de l’angle VRMA, respectivement, et que les deux fonctions linéaires sont symétriques par rapport à l’axe (y) du facteur VF.</li><li><strong>Linéaire inverse</strong> : indique que le facteur VF est une fonction linéaire inverse de l’angle VRMA.</li><li><strong>Linéaire inverse symétrique</strong> : spécifie que le facteur VF est une fonction linéaire inverse de l’angle VRMA, du côté négatif ou du côté positif de l’angle VRMA, respectivement, et que les deux fonctions linéaires sont symétriques par rapport à l’axe (y) du facteur VF.</li><li><strong>Cos</strong> : identifie le facteur VF comme une fonction cosinusoïdale de l’angle VRMA.</li><li><strong>Sec</strong> : identifie le facteur VF comme une fonction sécante de l’angle VRMA.</li><li><strong>Cos-Sec</strong> : spécifie que le facteur VF est une fonction cosinusoïdale de l’angle VRMA lorsque ce dernier est négatif et qu’il est une fonction sécante de l’angle VRMA lorsque ce dernier n’est pas négatif.</li><li><strong>Sec-Cos</strong> : spécifie que le facteur VF est une fonction sécante de l’angle VRMA lorsque ce dernier est négatif et qu’il est une fonction cosinusoïdale de l’angle VRMA lorsque ce dernier n’est pas négatif.</li><li><strong>Table</strong> : indique qu’un fichier de table sera utilisé pour définir le diagramme des facteurs verticaux permettant de déterminer les facteurs VF.</li></ul><p>Les modificateurs des mots-clés de facteur vertical sont les suivants :</p><ul><li><strong>Facteur zéro</strong> : définit le facteur vertical utilisé lorsque l’angle VRMA est nul. Ce facteur positionne l’intersection avec l’axe des y de la fonction spécifiée. Par définition, le facteur zéro ne s’applique à aucune fonction verticale trigonométrique (COS, SEC, COS-SEC ou SEC-COS). Ces fonctions définissent l’interception de l’axe des y.</li><li><strong>Angle d’inflexion inférieur</strong> : définit l’angle VRMA en dessous duquel le facteur VF a une valeur infinie.</li><li><strong>Angle d’inflexion supérieur</strong> : définit l’angle VRMA au-dessus duquel le facteur VF a une valeur infinie.</li><li><strong>Pente</strong> : définit la pente de la ligne droite utilisée avec les mots-clés de facteur vertical <strong>Linéaire</strong> et <strong>Linéaire inverse</strong>. La pente est spécifiée sous forme d’un rapport de la hauteur sur la distance parcourue (par exemple, une pente de 45 pour cent correspond à 1/45, la valeur introduite étant 0,02222).</li><li><strong>Nom de la table</strong> : correspond au nom de la table définissant le facteur VF.</li></ul>",
	"@@Path-Distance-Allocation_Vertical-Raster_tag0@@": "Définit la relation entre le facteur de coût vertical et l'angle de déplacement relatif vertical (VRMA, vertical relative moving angle).",
	"@@Path-Distance-Allocation_Vertical-Raster_tag1@@": "Ces valeurs permettent de calculer la pente utilisée pour identifier le facteur vertical relatif au déplacement d'une cellule à une autre.",
	"@@Path-Distance-Back-Link_Accumulative-Cost-Resistance-Rate_tag0@@": "Ce paramètre simule l’augmentation de l’effort pour surmonter les coûts au fur et à mesure que le coût cumulé augmente. Il permet de modéliser la fatigue du voyageur. Le coût cumulé croissant pour atteindre une cellule est multiplié par le taux de résistance et ajouté au coût engendré par le déplacement vers la cellule suivante.",
	"@@Path-Distance-Back-Link_Accumulative-Cost-Resistance-Rate_tag1@@": "Il s’agit d’une version modifiée d’une formule de taux d’intérêt composé qui permet de calculer le coût apparent du déplacement à travers une cellule. Avec l'augmentation du taux de résistance, le coût des cellules qui sont visitées ultérieurement s'accroît également. Plus le taux de résistance est important, plus le coût de déplacement vers la cellule suivante augmente, lequel est ajouté pour chaque mouvement suivant. Puisque le taux de résistance est similaire à un taux composé et qu’habituellement les valeurs de coût cumulé sont très importantes, nous suggérons l’utilisation de taux de résistance faibles, tels que 0,005 ou encore inférieurs, selon les valeurs de coût cumulé.",
	"@@Path-Distance-Back-Link_Accumulative-Cost-Resistance-Rate_tag2@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Path-Distance-Back-Link_Capacity_tag0@@": "Définit la capacité de coût pour le voyageur pour une source. Les calculs de coût continuent pour chaque source jusqu’à ce que la capacité spécifiée soit atteinte.",
	"@@Path-Distance-Back-Link_Capacity_tag1@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le tronçon du raster en sortie.",
	"@@Path-Distance-Back-Link_Cost-Raster_tag0@@": "Raster en entrée requis définissant le coût ou l’impédance de déplacement planimétrique à travers chaque cellule. La valeur à chaque emplacement de cellule représente le coût par unité de distance pour le déplacement à travers chaque cellule. Chaque valeur d’emplacement de cellule est multipliée par la résolution de cellule et compense également le mouvement diagonal afin d’obtenir le coût total du passage à travers la cellule.",
	"@@Path-Distance-Back-Link_Cost-Raster_tag1@@": "Les valeurs du <strong>Raster de coût</strong> peuvent être des entiers ou des nombres à virgule flottante, mais elles ne peuvent pas être négatives ni nulles.",
	"@@Path-Distance-Back-Link_horizontalfactor_tag0@@": "<p>Définit la relation entre le facteur de coût horizontal et l’angle de déplacement relatif horizontal (HRMA).</p><p>Plusieurs facteurs, avec modificateurs, identifient un diagramme de facteurs verticaux défini. En outre, vous pouvez utiliser une table pour créer un diagramme personnalisé. Les diagrammes permettent d’identifier le facteur vertical utilisé pour le calcul du coût total d’un déplacement vers une cellule voisine.</p><p>Dans les explications ci-dessous, deux acronymes sont utilisés : HF et HRMA. Le facteur HF correspond au facteur horizontal qui représente la difficulté horizontale rencontrée lors d’un déplacement d’une cellule vers la suivante. L’angle HRMA correspond à l’angle de déplacement relatif horizontal, lequel représente l’angle entre la direction horizontale d’une cellule et la direction du déplacement.</p><p>Les types de <strong>Facteur horizontal</strong> sont les suivants :</p><ul><li><strong>Binaire</strong> : indique que si l’angle HRMA est inférieur à l’angle d’inflexion, le facteur HF a la valeur associée au facteur zéro. Dans le cas contraire, le facteur horizontal a une valeur infinie.</li><li><strong>Avant</strong> : précise que seul un mouvement vers l’avant est autorisé. L’angle HRMA doit être supérieur ou égal à 0 et inférieur à 90 degrés (0 &lt;= HRMA &lt; 90). Si l’angle HRMA est compris entre 0 et 45 degrés, le facteur HF de la cellule a la valeur associée au facteur zéro. Si l’angle HRMA est supérieur ou égal à 45 degrés, la valeur du modificateur de la valeur de bord est utilisée. Le facteur HF pour un angle HRMA égal ou supérieur à 90 degrés a une valeur infinie.</li><li><strong>Linéaire</strong> : spécifie que le facteur HF est une fonction linéaire de l’angle HRMA.</li><li><strong>Linéaire inverse</strong> : spécifie que le facteur HF est une fonction linéaire inverse de l’angle HRMA.</li><li><strong>Table</strong> : indique qu’un fichier de table sera utilisé pour définir le diagramme des facteurs horizontaux permettant de déterminer les facteurs HF.</li></ul><p>Les modificateurs des facteurs horizontaux sont les suivants :</p><ul><li><strong>Facteur zéro</strong> : définit le facteur horizontal à utiliser lorsque l’angle HRMA est nul. Ce facteur positionne l’intersection avec l’axe des y de toutes les fonctions de facteur horizontal.</li><li><strong>Angle d’inflexion</strong> : définit l’angle HRMA au-delà duquel le facteur HF a une valeur infinie.</li><li><strong>Pente</strong> : définit la pente de la ligne droite utilisée avec les mots-clés de facteur horizontal <strong>Linéaire</strong> et <strong>Linéaire inverse</strong>. La pente est spécifiée sous forme d’un rapport de la hauteur sur la distance parcourue (par exemple, une pente de 45 pour cent correspond à 1/45, la valeur introduite étant 0,02222).</li><li><strong>Valeur de bord</strong> : définit le facteur HF lorsque l’angle HRMA est supérieur ou égal à 45 degrés et inférieur à 90 degrés lorsque le mot-clé de facteur horizontal <strong>Avant</strong> est spécifié.</li><li><strong>Nom de la table</strong> : correspond au nom de la table définissant le facteur HF.</li></ul>",
	"@@Path-Distance-Back-Link_Horizontal-Raster_tag0@@": "Un raster définissant la direction horizontale pour chaque cellule.",
	"@@Path-Distance-Back-Link_Horizontal-Raster_tag1@@": "Les valeurs du raster doivent être des entiers compris entre 0 et 360, 0 degré correspondant au nord (vers le haut de l’écran). Elles augmentent dans le sens horaire. La valeur -1 doit être attribuée aux surfaces planes. Les valeurs à chaque emplacement seront utilisées conjointement au <strong>Facteur horizontal</strong> afin de déterminer le coût horizontal encouru lors d’un déplacement à partir d’une cellule vers les cellules voisines.",
	"@@Path-Distance-Back-Link_Maximum-Distance_tag0@@": "Le seuil que les valeurs de coût cumulé ne peuvent pas dépasser. Si une distance de coût cumulé dépasse cette valeur, la valeur en sortie de l’emplacement de cellule est NoData. La distance maximale définit l’étendue pour laquelle les distances de coût cumulé sont calculées. La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag0@@": "Multiplicateur à appliquer aux valeurs de coût.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag1@@": "Ce paramètre permet de contrôler le mode de déplacement ou la magnitude à une source. Plus le multiplicateur est élevé, plus le coût de déplacement d’une cellule à une autre est important.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag2@@": "Les valeurs doivent être supérieures à zéro. La valeur par défaut est 1.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag3@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Path-Distance-Back-Link_Source-Raster_tag0@@": "Le raster en entrée requis des emplacements source.",
	"@@Path-Distance-Back-Link_Source-Raster_tag1@@": "Raster qui identifie les cellules ou les emplacements à partir desquels la distance de moindre coût cumulé est calculée pour chaque emplacement de cellule en sortie.",
	"@@Path-Distance-Back-Link_Source-Raster_tag2@@": "Il peut s’agir d’un entier ou d’un nombre à virgule flottante.",
	"@@Path-Distance-Back-Link_Start-Cost_tag0@@": "Coût de départ du calcul des coûts. Ce paramètre permet de spécifier le coût fixe associé à une source. Plutôt que de commencer avec un coût égal à 0, l’algorithme de coût commence avec la valeur définie.",
	"@@Path-Distance-Back-Link_Start-Cost_tag1@@": "La valeur doit être égale ou supérieure à zéro. La valeur par défaut est 0.",
	"@@Path-Distance-Back-Link_Surface-Raster_tag0@@": "Un raster définissant les valeurs d'altitudes à chaque emplacement de cellule.",
	"@@Path-Distance-Back-Link_Surface-Raster_tag1@@": "Ces valeurs permettent de calculer la distance à la surface réelle qui est couverte lors du passage d'une cellule à une autre.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag0@@": "Définit le sens du voyageur en cas d’application du taux de résistance source et du coût de départ source.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag1@@": "<strong>À partir de la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de la source en entrée et en se déplaçant vers les cellules non sources. Il s’agit de l’option par défaut.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag3@@": "<strong>Vers la source</strong> : le taux de résistance source et le coût de départ source sont appliqués à partir de chaque cellule non source et en revenant vers la source en entrée.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag5@@": "Spécifiez le mot-clé <strong>À partir de la source</strong> ou <strong>Vers la source</strong>, qui est appliqué à toutes les sources, ou spécifiez un champ dans le <strong>Raster source</strong> qui contient les mots-clés permettant d’identifier le sens de déplacement pour chaque source. Ce champ doit contenir la chaîne ${FROM_SOURCE} ou ${TO_SOURCE}.",
	"@@Path-Distance-Back-Link_verticalfactor_tag0@@": "<p>Définit la relation entre le facteur de coût vertical et l’angle de déplacement relatif vertical (VRMA).</p><p>Plusieurs facteurs, avec modificateurs, identifient un diagramme de facteurs verticaux défini. En outre, vous pouvez utiliser une table pour créer un diagramme personnalisé. Les diagrammes permettent d’identifier le facteur vertical utilisé pour le calcul du coût total d’un déplacement vers une cellule voisine.</p><p>Dans les explications ci-dessous, deux acronymes sont utilisés : VF et VRMA. Le facteur VF correspond au facteur vertical, lequel représente la difficulté verticale rencontrée lors d’un déplacement d’une cellule vers la suivante. L’angle VRMA correspond à l’angle de déplacement relatif vertical, lequel représente l’angle de la pente entre la cellule FROM (Origine), ou de traitement, et la cellule TO (Destination).</p><p>Les types de <strong>Facteur vertical</strong> sont les suivants :</p><ul><li><strong>Binaire</strong> : spécifie que si l’angle VRMA est supérieur à l’angle d’inflexion inférieur et inférieur à l’angle d’inflexion supérieur, le facteur VF doit correspondre à la valeur associée au facteur zéro. Dans le cas contraire, le facteur vertical a une valeur infinie.</li><li><strong>Linéaire</strong> : indique que le facteur VF est une fonction linéaire de l’angle VRMA.</li><li><strong>Linéaire symétrique</strong> : spécifie que le facteur VF est une fonction linéaire de l’angle VRMA, du côté négatif ou du côté positif de l’angle VRMA, respectivement, et que les deux fonctions linéaires sont symétriques par rapport à l’axe (y) du facteur VF.</li><li><strong>Linéaire inverse</strong> : indique que le facteur VF est une fonction linéaire inverse de l’angle VRMA.</li><li><strong>Linéaire inverse symétrique</strong> : spécifie que le facteur VF est une fonction linéaire inverse de l’angle VRMA, du côté négatif ou du côté positif de l’angle VRMA, respectivement, et que les deux fonctions linéaires sont symétriques par rapport à l’axe (y) du facteur VF.</li><li><strong>Cos</strong> : identifie le facteur VF comme une fonction cosinusoïdale de l’angle VRMA.</li><li><strong>Sec</strong> : identifie le facteur VF comme une fonction sécante de l’angle VRMA.</li><li><strong>Cos-Sec</strong> : spécifie que le facteur VF est une fonction cosinusoïdale de l’angle VRMA lorsque ce dernier est négatif et qu’il est une fonction sécante de l’angle VRMA lorsque ce dernier n’est pas négatif.</li><li><strong>Sec-Cos</strong> : spécifie que le facteur VF est une fonction sécante de l’angle VRMA lorsque ce dernier est négatif et qu’il est une fonction cosinusoïdale de l’angle VRMA lorsque ce dernier n’est pas négatif.</li><li><strong>Table</strong> : indique qu’un fichier de table sera utilisé pour définir le diagramme des facteurs verticaux permettant de déterminer les facteurs VF.</li></ul><p>Les modificateurs des mots-clés de facteur vertical sont les suivants :</p><ul><li><strong>Facteur zéro</strong> : définit le facteur vertical utilisé lorsque l’angle VRMA est nul. Ce facteur positionne l’intersection avec l’axe des y de la fonction spécifiée. Par définition, le facteur zéro ne s’applique à aucune fonction verticale trigonométrique (COS, SEC, COS-SEC ou SEC-COS). Ces fonctions définissent l’interception de l’axe des y.</li><li><strong>Angle d’inflexion inférieur</strong> : définit l’angle VRMA en dessous duquel le facteur VF a une valeur infinie.</li><li><strong>Angle d’inflexion supérieur</strong> : définit l’angle VRMA au-dessus duquel le facteur VF a une valeur infinie.</li><li><strong>Pente</strong> : définit la pente de la ligne droite utilisée avec les mots-clés de facteur vertical <strong>Linéaire</strong> et <strong>Linéaire inverse</strong>. La pente est spécifiée sous forme d’un rapport de la hauteur sur la distance parcourue (par exemple, une pente de 45 pour cent correspond à 1/45, la valeur introduite étant 0,02222).</li><li><strong>Nom de la table</strong> : correspond au nom de la table définissant le facteur VF.</li></ul>",
	"@@Path-Distance-Back-Link_Vertical-Raster_tag0@@": "Définit la relation entre le facteur de coût vertical et l'angle de déplacement relatif vertical (VRMA, vertical relative moving angle).",
	"@@Path-Distance-Back-Link_Vertical-Raster_tag1@@": "Ces valeurs permettent de calculer la pente utilisée pour identifier le facteur vertical relatif au déplacement d'une cellule à une autre.",
	"@@Plus_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Plus_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Plus_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Plus_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Plus_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Plus_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Plus_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Plus_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Plus_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Plus_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Plus_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Plus_Raster_tag0@@": "Entrée dont les valeurs sont ajoutées.",
	"@@Plus_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Plus_Raster2_tag0@@": "Entrée dont les valeurs sont ajoutées à la première entrée.",
	"@@Plus_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Local_Cellsize-Type_tag0@@": "Sélectionnez la taille de cellule à utiliser dans le raster en sortie. Si toutes les tailles de cellule en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Local_Cellsize-Type_tag1@@": "Premier de : utiliser la première taille de cellule des rasters en entrée.",
	"@@Local_Cellsize-Type_tag2@@": "Dernier de : utiliser la dernière taille de cellule des rasters en entrée.",
	"@@Local_Cellsize-Type_tag3@@": "Max de : utiliser la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Local_Cellsize-Type_tag4@@": "Moyenne de : utiliser la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Local_Cellsize-Type_tag5@@": "Min de : utiliser la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Local_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie :",
	"@@Local_Extent-Type_tag1@@": "Premier de : utiliser l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Local_Extent-Type_tag2@@": "Intersection de : utiliser l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Local_Extent-Type_tag3@@": "Dernier de : utiliser l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Local_Extent-Type_tag4@@": "Union de : utiliser l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Local_Raster_tag0@@": "Entrée dont les valeurs subissent l’ajout.",
	"@@Local_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Local_Raster2_tag0@@": "Entrée dont les valeurs sont ajoutées à la première entrée.",
	"@@Local_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Local_False-Raster_tag0@@": "Entrée dont les valeurs sont utilisées en tant que valeurs de pixel en sortie si la condition est fausse. Il peut s’agir d’un raster de type entier ou à virgule flottante, ou d’une valeur constante.",
	"@@Local_True-Raster_tag0@@": "Entrée dont les valeurs sont utilisées en tant que valeurs de pixel en sortie si la condition est vraie. Il peut s’agir d’un raster de type entier ou à virgule flottante, ou d’une valeur constante.",
	"@@Power_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Power_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Power_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Power_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Power_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Power_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Power_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Power_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Power_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Power_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Power_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Power_Raster_tag0@@": "Valeurs en entrée à élever à la puissance définie par <strong>Raster2</strong>.",
	"@@Power_Raster_tag3@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Power_Raster2_tag0@@": "Entrée qui détermine la puissance à laquelle les valeurs <strong>Raster</strong> seront élevées.",
	"@@Power_Raster2_tag3@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Radar-Calibration_Calibration-Type_tag0@@": "Type de calibrage à réaliser.",
	"@@Radar-Calibration_Calibration-Type_tag1@@": "Beta-nought (Bêta zéro) : la fonction renvoie la réflectivité du radar par unité de surface en distance oblique. Il s’agit du type de calibrage par défaut.",
	"@@Radar-Calibration_Calibration-Type_tag2@@": "Sigma-nought (Sigma zéro) : la fonction renvoie la réflectivité du radar par unité de surface en portée au sol. Les résultats sont des valeurs à virgule flottante 32 bits généralement comprises entre 0,0 et 1,0. Aucun découpage de donnée n'est effectué si cette option est sélectionnée.",
	"@@Radar-Calibration_Calibration-Type_tag3@@": "Gamma : la fonction renvoie la réflectivité du radar par unité de surface dans le plan perpendiculaire à la direction de la mesure.",
	"@@Radar-Calibration_Calibration-Type_tag4@@": "Aucun",
	"@@Radar-Calibration_Raster_tag0@@": "Raster en entrée.",
	"@@RasterInfo_Raster-Info_tag0@@": "Sélectionnez un jeu de données raster à utiliser comme modèle.",
	"@@RasterInfo_Raster_tag0@@": "Raster en entrée.",
	"@@Rasterize-Attributes_Attribute-Field-Names_tag0@@": "Liste des champs de la <strong>Table des attributs zonaux</strong>, où chaque champ est séparé par une virgule. Les valeurs dans chaque champ seront représentées par une bande dans le raster en sortie.",
	"@@Rasterize-Attributes_Background-Value_tag0@@": "La valeur de pixel initiale des canaux en sortie dans un raster, avant leur classement.",
	"@@Rasterize-Attributes_Background-Value_tag1@@": "Si un pixel ne se trouve pas au sein d’une zone, il demeure en tant que valeur d’arrière-plan.",
	"@@Rasterize-Attributes_Value-Raster_tag0@@": "Le raster en entrée requis.",
	"@@Rasterize-Attributes_Value-Raster_tag1@@": "L'entrée doit être un raster monocanal. Si un raster multicanal est utilisé, seul le premier canal est employé.",
	"@@Rasterize-Attributes_Where-Clause_tag0@@": "Requête supplémentaire facultative appliquée à la <strong>Table des attributs zonaux</strong>.",
	"@@Rasterize-Attributes_Where-Clause_tag3@@": "Si vous utilisiez la table ci-dessus comme exemple, la requête serait ${Variable1 = 'bare earth'}.",
	"@@Rasterize-Attributes_Zonal-Attributes-Table_tag0@@": "Les attributs zonaux spécifiés en tant que chemin d'accès à une classe d'entités locale, chemin d'accès à une table, URL d'une couche de service d'entités ou chaîne JSON.",
	"@@Rasterize-Attributes_Zonal-Attributes-Table_tag1@@": "Dans JSON, ceci est décrit en tant que collection cartographique allant des ID de zone à une matrice d’entiers. ${{ zoneId:[f1,f2,...,fn], ... } }",
	"@@Rasterize-Attributes_Zone-Field_tag0@@": "Le nom de champ contenant les valeurs d'ID de zone.",
	"@@Rasterize-Attributes_Zone-Raster_tag0@@": "Raster monocanal facultatif où chaque pixel contient l'ID de zone associé à l'emplacement. L'ID de zone permet de rechercher des lignes dans la table des attributs zonaux afin de recevoir des zones spécifiques.",
	"@@Rasterize-Attributes_Zone-Raster_tag1@@": "Ne spécifiez pas ce paramètre si vous souhaitez uniquement importer l'attribut.",
	"@@Rasterize-Features_Field_tag0@@": "Sélectionnez le champ à utiliser pour identifier chaque entité.",
	"@@Rasterize-Features_Input-Features_tag0@@": "Sélectionnez la classe d'entités à convertir en format raster.",
	"@@Rasterize-Features_Raster_tag0@@": "Sélectionnez un raster pour définir la taille de cellule et l’étendue pour la conversion des entités.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag0@@": "Indiquez comment gérer les entités superposées :",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag1@@": "<strong>Premier</strong> : une valeur issue du premier jeu de données répertorié est attribuée aux zones superposées.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag3@@": "<strong>Dernier</strong> : une valeur issue du dernier jeu de données répertorié est attribuée aux zones superposées.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag5@@": "<strong>Le plus petit</strong> : une valeur issue des plus petites entités est attribuée aux zones superposées.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag7@@": "<strong>Le plus grand</strong> : une valeur issue des plus grandes entités est attribuée aux zones superposées.",
	"@@Recast_Overrides_tag0@@": "Une table des noms de variables et des valeurs définies par l’utilisateur utilisée pour modifier un jeu de données mosaïque.",
	"@@Recast_Raster_tag0@@": "Produit raster sur lequel auquel la fonction Rédéfinir est appliqué.",
	"@@Region-Group_Add-Link_tag0@@": "Spécifie si un champ LINK est ajouté à la table du résultat en sortie.",
	"@@Region-Group_Add-Link_tag1@@": "<strong>Ajouter un lien</strong> : un élément ${LINK} sera ajouté à la table du raster en sortie.",
	"@@Region-Group_Add-Link_tag3@@": "<strong>Aucun lien</strong> : la table attributaire du raster en sortie contiendra uniquement les éléments ${Value} et ${Count}.",
	"@@Region-Group_Excluded-Value_tag0@@": "Identifie une valeur telle que si un emplacement de cellule contient cette valeur, aucune connectivité spatiale ne pourra être évaluée, quel que soit le nombre de voisin spécifié (FOUR ou EIGHT).",
	"@@Region-Group_Excluded-Value_tag1@@": "Les cellules dotées de la valeur exclue sont traitées en NoData et sont éliminées de tout calcul. Dans le raster en sortie, la valeur zéro est attribuée aux emplacements de cellule qui contiennent la valeur exclue.",
	"@@Region-Group_Excluded-Value_tag2@@": "La valeur exclue repose sur le même concept qu’une valeur d’arrière-plan ou que l’application d’un masque. Une valeur doit être spécifiée pour ce paramètre si le paramètre <strong>${CROSS}</strong> est spécifié.",
	"@@Region-Group_Number-of-Neighbor-Cells_tag0@@": "Nombre de cellules voisines à utiliser afin d'évaluer la connectivité entre les cellules.",
	"@@Region-Group_Number-of-Neighbor-Cells_tag1@@": "<strong>QUATRE</strong> : définit la connectivité entre des cellules d’une même valeur uniquement si elles se trouvent directement à gauche, à droite, au-dessus ou en dessous des quatre voisins les plus proches. Il s’agit de l’option par défaut.",
	"@@Region-Group_Number-of-Neighbor-Cells_tag3@@": "<strong>HUIT</strong> : définit la connectivité entre des cellules de même valeur si elles se trouvent dans le voisinage immédiat de huit cellules. Elles peuvent se situer à droite, à gauche, au-dessus ou en diagonale.",
	"@@Region-Group_Zone-Connectivity_tag0@@": "Définit les valeurs de cellules qui doivent être prises en compte dans le cadre des tests de connectivité.",
	"@@Region-Group_Zone-Connectivity_tag1@@": "<strong>DANS</strong> : teste la connectivité entre des valeurs identiques en entrée au sein de la même zone. Il s’agit de l’option par défaut.",
	"@@Region-Group_Zone-Connectivity_tag3@@": "Les seules cellules qui peuvent être regroupées sont des cellules de la même zone (valeur) et qui répondent aux exigences spatiales de connectivité spécifiées par le paramètre <strong>Nombre de voisins</strong> (quatre ou huit voisins).",
	"@@Region-Group_Zone-Connectivity_tag6@@": "<strong>CROISER</strong> : teste la connectivité sur la base des exigences spatiales spécifiées par le nombre de voisins entre les cellules dotées de valeurs quelconques, à l’exception de la valeur identifiée à exclure via le paramètre de valeur exclue.",
	"@@Region-Group_Zone-Connectivity_tag8@@": "Lorsque cette option est utilisée, une valeur doit être spécifiée pour le paramètre <strong>Valeur exclue</strong>.",
	"@@Region-Group_Zone-Raster_tag0@@": "Raster en entrée requis dont les uniques régions connectées seront identifiées.",
	"@@Region-Group_Zone-Raster_tag1@@": "Il doit être de type entier.",
	"@@Region-Grow_Fill-Value-Field_tag0@@": "Champ de la table attributaire qui définit la valeur de remplissage attribuée au groupe de pixels. Dans une image multicanal, cette valeur est attribuée à tous les canaux.",
	"@@Region-Grow_Max-Growth-Radius-Field_tag0@@": "Champ de la table attributaire qui définit le rayon d'évolution maximale, dans les unités de la référence spatiale de l'image.",
	"@@Region-Grow_Raster_tag0@@": "Le raster sur lequel vous souhaitez appliquer cette fonction.",
	"@@Region-Grow_Seed-Points_tag0@@": "Classe d'entités points qui sert de valeurs initiales à l'algorithme. Chaque point d’origine correspond à une entrée de la table attributaire, qui comporte des informations sur le rayon d’évolution maximale, le seuil de similarité et la valeur de remplissage.",
	"@@Region-Grow_Similarity-Threshold-Field_tag0@@": "Champ de la table attributaire qui définit le seuil de similarité, en tant que distance euclidienne de l'espace spectral.",
	"@@Remap_Allow-Unmatched-Pixel-Values_tag0@@": "Les valeurs manquantes dans la table de reclassement peuvent conserver leur valeur ou être classifiées sur NoData.",
	"@@Remap_Allow-Unmatched-Pixel-Values_tag1@@": "Désactivé : tout pixel du raster en entrée qui n’est pas reclassé dans une table de classification conservera sa valeur et sera enregistré pour son emplacement dans le raster en sortie. Il s’agit de l’option par défaut.",
	"@@Remap_Allow-Unmatched-Pixel-Values_tag2@@": "Activé : tout pixel du raster en entrée qui n’est pas reclassé dans une table de classification prendra la valeur NoData pour son emplacement dans le raster en sortie.",
	"@@Remap_Input-Field_tag0@@": "Choisissez le champ qui indique la valeur de pixel à classifier.",
	"@@Remap_Input-Field_tag1@@": "Si votre table comporte une plage de valeurs, il s’agit du champ de la valeur minimale, et le paramètre <strong>Champ max en entrée</strong> doit également être spécifié.",
	"@@Remap_Input-Max-Field_tag0@@": "Choisissez le champ de la valeur maximale si votre table indique une plage de valeurs.",
	"@@Remap_List_tag0@@": "Indiquez les valeurs à apparier, ainsi que la plage des valeurs minimale et maximale et les nouvelles valeurs de classification. La plage des valeurs peut en outre être définie sur pixels NoData.",
	"@@Remap_Output-Field_tag0@@": "Choisissez le champ qui sera utilisé comme valeur classifiée en sortie.",
	"@@Remap_Raster_tag0@@": "Raster en entrée.",
	"@@Remap_Remap-Definition-Type_tag0@@": "Choisissez l’option que vous souhaitez utiliser pour définir les valeurs de classification :",
	"@@Remap_Remap-Definition-Type_tag1@@": "Liste : spécifier une plage de valeurs de pixel à apparier à une valeur de pixel en sortie",
	"@@Remap_Remap-Table-Type_tag0@@": "Choisissez le type de table que vous utiliserez pour classifier votre raster en entrée :",
	"@@Remap_Remap-Table-Type_tag1@@": "Simple : utilise la <strong>Table de classification</strong> en entrée pour apparier les valeurs de pixels du <strong>Champ en entrée</strong> avec la valeur correspondante dans le paramètre <strong>Champ en sortie</strong>. Cette méthode met en cache la table de classification afin d’accroître la rapidité d’exécution.",
	"@@Remap_Remap-Table-Type_tag8@@": "Dynamique : cette méthode ne met pas en cache la table de classification et effectue une requête chaque fois que l’utilisateur effectue un déplacement, zoom ou actualise la carte. Si la table est modifiée, la demande suivante peut classifier dynamiquement les valeurs en conséquence.",
	"@@Remap_Remap-Table-Type_tag9@@": "Réaffectation : une table spécifique est utilisée pour le processus de reclassification, dans lequel chaque ligne de la table n’est reclassée qu’en fonction de chaque limite d’entité.",
	"@@Remap_Remap-Table_tag0@@": "Accédez à la table qui définit vos valeurs de classification.",
	"@@Reproject_Raster_tag0@@": "Le jeu de données raster à reprojeter ou ré-échantilloner.",
	"@@Reproject_Spatial-Reference_tag0@@": "Système de coordonnées utilisé pour reprojeter les données.",
	"@@Reproject_X-Cellsize_tag0@@": "Dimension x dans laquelle les données doivent être rééchantillonnées. Ce paramètre est facultatif. Si la valeur est inférieure ou égale à 0, l’enveloppe en sortie (étendue et tailles de cellule) est calculée à partir du raster en entrée.",
	"@@Reproject_X-Registration-Point_tag0@@": "Coordonnée x utilisée pour définir l’angle supérieur gauche du jeu de données. Cette coordonnée doit être définie dans les unités de la nouvelle référence spatiale. Si les paramètres <strong>Taille de cellule X</strong> et <strong>Taille de cellule Y</strong> sont tous deux supérieurs à 0, ils sont utilisés avec les paramètres <strong>Point de calage X</strong> et <strong>Point de calage Y</strong> pour définir l’enveloppe en sortie.",
	"@@Reproject_Y-Cellsize_tag0@@": "Dimension y dans laquelle les données doivent être rééchantillonnées. Ce paramètre est facultatif. Si la valeur est inférieure ou égale à 0, l’enveloppe en sortie (étendue et tailles de cellule) est calculée à partir du raster en entrée.",
	"@@Reproject_Y-Registration-Point_tag0@@": "Coordonnée y utilisée pour définir l’angle supérieur gauche du jeu de données. Cette coordonnée doit être définie dans les unités de la nouvelle référence spatiale. Si les paramètres <strong>Taille de cellule X</strong> et <strong>Taille de cellule Y</strong> sont tous deux supérieurs à 0, ils sont utilisés avec les paramètres <strong>Point de calage X</strong> et <strong>Point de calage Y</strong> pour définir l’enveloppe en sortie.",
	"@@Resample_Input-Cellsize_tag0@@": "Taille de cellule (pixel) du raster en entrée.",
	"@@Resample_Output-Cellsize_tag0@@": "La taille de la cellule (pixel) du raster en sortie. La taille de cellule peut être modifiée, mais l’étendue du jeu de données raster reste identique. Le ré-échantillonnage à partir d'une taille de cellule définie par l'utilisateur peut s'avérer beaucoup plus lent que la valeur par défaut du système, car le ré-échantillonnage par défaut du système traite la quantité minimale de données à partir de la résolution la plus proche possible.",
	"@@Resample_Raster_tag0@@": "Le raster en entrée à ré-échantilloner.",
	"@@Resample_Resampling-Type_tag0@@": "<strong>Voisin le plus proche</strong> : calcule la valeur du pixel en sortie grâce au pixel en entrée le plus proche. Les pixels NoData ne sont pas modifiés dans le jeu de données raster en sortie. Il s’agit de l’option par défaut.",
	"@@Resample_Resampling-Type_tag2@@": "<strong>Interpolation bilinéaire</strong> : calcule la valeur du pixel en utilisant la valeur de distance pondérée des quatre pixels les plus proches. L’exécution de cette méthode est efficace au point de vue du calcul.",
	"@@Resample_Resampling-Type_tag4@@": "<strong>Convolution cubique</strong> : détermine la nouvelle valeur d’un pixel en faisant passer une courbe lissée par les centres des 16 pixels en entrée les plus proches.",
	"@@Resample_Resampling-Type_tag6@@": "<strong>Majorité</strong> : calcule la valeur du pixel en utilisant la valeur de pixel majoritaire des 16 pixels les plus proches. Les pixels NoData ne sont pas modifiés dans le jeu de données raster en sortie.",
	"@@Resample_Resampling-Type_tag8@@": "<strong>Interpolation bilinéaire Plus</strong> : utilise l’<strong>Interpolation bilinéaire</strong>, mais les pixels le long des segments sont définis sur la valeur NoData et ne sont ni répliqués ni pris en compte dans le calcul. Utilisez l’<strong>Interpolation bilinéaire Plus</strong> pour les données tuilées car les segments seront mieux ajustés.",
	"@@Resample_Resampling-Type_tag14@@": "<strong>Flou gaussien</strong> : applique une convolution gaussienne au raster source et calcule la valeur du pixel en utilisant la valeur de distance pondérée des quatre pixels les plus proches du raster flou. Cette méthode est appropriée pour supprimer le bruit dans les données rééchantillonnées et pour sous-échantillonner afin d’obtenir une taille de pixel plus grande.",
	"@@Resample_Resampling-Type_tag16@@": "<strong>Flou gaussien Plus</strong> : applique la méthode de <strong>Flou gaussien</strong>, mais les pixels le long des segments sont définis sur la valeur NoData et ne sont ni répliqués ni pris en compte dans le calcul. Utilisez le <strong>Flou gaussien Plus</strong> pour les données tuilées car les segments seront mieux ajustés.",
	"@@Resample_Resampling-Type_tag22@@": "<strong>Moyenne</strong> : calcule les valeurs des pixels en utilisant la valeur moyenne de tous les pixels superposés, pour chaque pixel cible.",
	"@@Resample_Resampling-Type_tag24@@": "<strong>Minimum</strong> : calcule la valeur du pixel en utilisant la valeur minimale de tous les pixels superposés. Les pixels NoData ne sont pas modifiés dans le jeu de données raster en sortie.",
	"@@Resample_Resampling-Type_tag26@@": "<strong>Maximum</strong> : adaptée aux données continues, cette méthode produit une image en sortie plus lisse que la méthode de rééchantillonnage par le voisin le plus proche.",
	"@@Resample_Resampling-Type_tag28@@": "<strong>Moyenne vectorielle</strong> : calcule la moyenne vectorielle de magnitude-direction en utilisant tous les pixels impliqués. Cette méthode s’applique uniquement à deux rasters bandes représentant la magnitude et la direction. Elle convertit d’abord la magnitude-direction en U-V, puis prend la moyenne arithmétique de tous les pixels impliqués pour obtenir l’U-V du pixel cible et le reconvertir en magnitude-direction.",
	"@@Round-Down_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Round-Down_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Round-Down_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Round-Down_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Round-Down_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Round-Down_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Round-Down_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Round-Down_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Round-Down_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Round-Down_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Round-Down_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Round-Down_Raster_tag0@@": "Valeurs en entrée à arrondir au nombre inférieur.",
	"@@Round-Up_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Round-Up_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Round-Up_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Round-Up_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Round-Up_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Round-Up_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Round-Up_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Round-Up_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Round-Up_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Round-Up_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Round-Up_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Round-Up_Raster_tag0@@": "Valeurs en entrée à arrondir au nombre supérieur.",
	"@@Segment-Mean-Shift_Minimum-Segment-Size-in-Pixels_tag0@@": "Taille minimale du segment exprimée en pixels. Cette valeur est associée à votre unité de mappage minimale et permet de filtrer les blocs de pixels plus petits. Tous les segments dont la taille est inférieure à la valeur précisée fusionnent les plus petits segments avec leur segment voisin le mieux adapté.",
	"@@Segment-Mean-Shift_Raster_tag0@@": "Raster en entrée à segmenter.",
	"@@Segment-Mean-Shift_Segment-boundaries-only_tag0@@": "Les limites du segment dessinent une isoligne autour de chaque segment. Cela permet de distinguer des segments adjacents de couleurs similaires.",
	"@@Segment-Mean-Shift_Segment-boundaries-only_tag1@@": "Non sélectionné : les limites des segments ne s’affichent pas. Il s’agit de l’option par défaut.",
	"@@Segment-Mean-Shift_Segment-boundaries-only_tag2@@": "Sélectionné : les limites des segments s’affichent avec des isolignes noires autour de chaque segment.",
	"@@Segment-Mean-Shift_Spatial-Detail_tag0@@": "Importance relative de la séparation des objets en fonction de caractéristiques spatiales.",
	"@@Segment-Mean-Shift_Spatial-Detail_tag1@@": "Les valeurs entières correctes sont comprises entre 1 et 20. Plus les valeurs sont faibles, plus les classes sont grandes et le lissage important. Une valeur élevée convient pour distinguer des entités petites et agrégées. Par exemple, dans une scène urbaine, vous pouvez classer une surface imperméable générale à l’aide d’une valeur de détail spatial plus petite ou classer des bâtiments et des routes en tant que classes séparées à l’aide d’une valeur de détail spatial supérieure.",
	"@@Segment-Mean-Shift_Spectral-Detail_tag0@@": "Importance relative de la séparation des objets en fonction de caractéristiques de couleur.",
	"@@Segment-Mean-Shift_Spectral-Detail_tag1@@": "Les valeurs à virgule flottante valides sont comprises entre 1,0 et 20,0. Plus les valeurs sont faibles, plus les classes sont grandes et le lissage important. Il convient d’attribuer une valeur élevée lorsque vous souhaitez distinguer les entités dont les caractéristiques spectrales sont relativement similaires. Par exemple, l’utilisation d’une valeur de détail spectral élevée dans une scène en zone forestière vous permet de mieux distinguer les espèces d’arbres.",
	"@@Segment-Mean-Shift_maximumsegmentsizeinpixels_tag0@@": "<p>Taille maximale d’un segment. Les segments de taille supérieure à celle spécifiée seront divisés. Utilisez ce paramètre pour éviter les artefacts dans la couche en sortie qui résultent de segments volumineux. La valeur par défaut est -1.</p>",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag0@@": "Sélectionnez l’un des quatre types de calibrage :",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag1@@": "<strong>Beta nought</strong> : produit une sortie contenant le coefficient de luminosité du radar.",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag3@@": "<strong>Sigma nought</strong> : rétrodiffusion renvoyée à l’antenne à partir de la surface d’une unité au sol, liée à la distance au sol.",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag5@@": "<strong>Gamma</strong> : mesure de l’énergie émise et renvoyée utile pour déterminer les modèles d’antenne.",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag7@@": "<strong>Aucun</strong> : aucune correction n’est appliquée. Il s’agit de l’option par défaut.",
	"@@Sentinel-1-Radiometric-Calibration_Raster_tag0@@": "Le raster en entrée GRD ou SLC Sentinel-1 de niveau 1 que vous souhaitez traiter.",
	"@@Sentinel-1-Radiometric-Calibration_Raster_tag1@@": "La fonction utilisera le fichier LUT pour appliquer la correction thermique ou pour supprimer la correction, selon le contenu du fichier LUT.",
	"@@Sentinel-1-Thermal-Noise-Removal_Raster_tag0@@": "Le raster en entrée Sentinel-1 que vous souhaitez traiter.",
	"@@Sentinel-1-Thermal-Noise-Removal_Raster_tag1@@": "La fonction utilisera le fichier LUT pour appliquer la correction thermique ou pour supprimer la correction, selon le contenu du fichier LUT.",
	"@@Set-Null_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Set-Null_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Set-Null_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Set-Null_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Set-Null_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Set-Null_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Set-Null_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Set-Null_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Set-Null_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Set-Null_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Set-Null_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Set-Null_False-Raster_tag0@@": "Entrée dont les valeurs seront utilisées en tant que valeurs de pixel en sortie si la condition est fausse. Il peut s’agir d’un raster de type entier, à virgule flottante ou d’une valeur constante.",
	"@@Set-Null_Raster_tag0@@": "Le raster en entrée qui représente le résultat booléen d’une fonction raster mathématique logique. Les valeurs sont égales à 1 (pour Vrai) ou à 0 (pour Faux). Il peut s'agir d'un entier ou d'un raster en virgule flottante.",
	"@@Shaded-Relief_Altitude_tag0@@": "L'altitude représente l'angle solaire de l'altitude au-dessus de la ligne d'horizon et s'étend de 0 à 90 degrés. Une valeur de 0 degrés indique que le soleil est sur l'horizon, c'est-à-dire sur le même plan horizontal que le cadre de référence. Une valeur de 90 degrés indique que le soleil est directement au-dessus. La valeur par défaut est de 45 degrés, au-dessus de l'horizon.",
	"@@Shaded-Relief_Azimuth_tag0@@": "La propriété Azimut définit la position relative du soleil par rapport à l'horizon (en degrés). Cette position est indiquée par l'angle du soleil mesuré dans le sens horaire à partir du nord. Un azimut de 0 degré indique le Nord, l'Est est à 90 degrés, le Sud à 180 degrés et l'Ouest à 270 degrés.",
	"@@Shaded-Relief_Color-Scheme-Type_tag0@@": "Spécifiez si un dégradé de couleurs ou une palette de couleurs sera utilisé pour représenter le relief ombré.",
	"@@Shaded-Relief_Color-Scheme-Type_tag1@@": "<strong>Dégradé de couleurs</strong> : lorsque vous choisissez <strong>Dégradé de couleurs</strong>, vous êtes invité à sélectionner le dégradé de couleurs approprié.",
	"@@Shaded-Relief_Color-Scheme-Type_tag5@@": "<strong>Palette de couleurs</strong> : lorsque vous choisissez <strong>Palette de couleurs</strong>, vous êtes invité à spécifier le fichier de palette de couleurs à utiliser.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag0@@": "Spécifiez si l’interpolation des pixels de tronçon par défaut est désactivée.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag1@@": "Non coché : le rééchantillonnage bilinéaire est appliqué uniformément pour rééchantillonner le relief ombré. Il s’agit de l’option par défaut.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag2@@": "Coché : le rééchantillonnage bilinéaire est utilisé au sein du relief ombré, sauf le long des tronçons des rasters ou à côté des pixels de valeur NoData. Ces pixels sont renseignés avec NoData, car ils réduisent les effets de tronçons abrupts pouvant se produire.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag3@@": "Cette option évite les artefacts de rééchantillonnage qui peuvent se produire le long des tronçons d'un raster. Les pixels en sortie le long du tronçon d'un raster ou à côté de pixels sans valeur sont renseignés avec NoData. Il est par conséquent recommandé d'utiliser cette option uniquement lorsque d'autres rasters avec des pixels superposés sont disponibles. Lorsque des pixels superposés sont disponibles, ces surfaces de NoData affichent les pixels superposés au lieu d'être vides.",
	"@@Shaded-Relief_Raster_tag0@@": "Le raster d’altitude en entrée.",
	"@@Shaded-Relief_Scaling_tag0@@": "Le résultat ombré est mis à l'échelle dynamiquement en ajustant le facteur z grâce à l'une de deux options :",
	"@@Shaded-Relief_Scaling_tag1@@": "<strong>Aucune</strong> : aucune mise à l’échelle n’est appliquée. Cette option est idéale pour un jeu de données raster unique qui couvre une zone locale. Cette option n’est pas recommandée pour les jeux de données mondiaux dont l’élévation varie beaucoup ou pour les cartes à plusieurs échelles, car elle génère un relief de terrain avec des variations restreintes à de petites échelles.",
	"@@Shaded-Relief_Scaling_tag3@@": "<strong>Ajusté</strong> : applique un ajustement non linéaire en utilisant les valeurs de <strong>Puissance de taille de pixel</strong> et de <strong>Facteur de taille de pixel</strong> par défaut, qui tiennent compte des changements d’altitude (échelle) lors d’un zoom avant ou arrière. L’option <strong>Ajusté</strong> est recommandée en cas d’utilisation d’un jeu de données mondial.",
	"@@Shaded-Relief_Z-Factor_tag0@@": "Le facteur Z est un facteur d'échelle utilisé pour convertir les valeurs d'altitude dans deux buts :",
	"@@Shaded-Relief_Z-Factor_tag1@@": "pour convertir les unités altimétriques (telles que les mètres ou les pieds) en unités de coordonnées horizontales du jeu de données, qui peuvent être des pieds, des mètres ou des degrés ;",
	"@@Shaded-Relief_Z-Factor_tag2@@": "pour ajouter une exagération verticale comme effet visuel.",
	"@@Shaded-Relief_Z-Factor_tag3@@": "Le résultat ombré est mis à l'échelle dynamiquement en ajustant le facteur z grâce à l'une de deux options :",
	"@@Shaded-Relief_Z-Factor_tag4@@": "<strong>Aucune</strong> : aucune mise à l’échelle n’est appliquée. Cette option est idéale pour un jeu de données raster unique qui couvre une zone locale. Cette option n’est pas recommandée pour les jeux de données mondiaux dont l’élévation varie beaucoup ou pour les cartes à plusieurs échelles, car elle génère un relief de terrain avec des variations restreintes à de petites échelles.",
	"@@Shaded-Relief_Z-Factor_tag6@@": "<strong>Ajusté</strong> : applique un ajustement non linéaire en utilisant les valeurs de <strong>Puissance de taille de pixel</strong> et de <strong>Facteur de taille de pixel</strong> par défaut, qui tiennent compte des changements d’altitude (échelle) lors d’un zoom avant ou arrière. L’option <strong>Ajusté</strong> est recommandée en cas d’utilisation d’un jeu de données mondial.",
	"@@Shaded-Relief_hillshadetype_tag0@@": "Contrôle la source d’éclairage de l’ombrage.",
	"@@Shaded-Relief_hillshadetype_tag1@@": "<strong>Traditionnel</strong> : calcule l’ombrage à partir d’une seule direction d’éclairage. Vous pouvez définir les options <strong>Azimut</strong> et <strong>Altitude</strong> pour contrôler l’emplacement de la source d’éclairage. Il s’agit de l’option par défaut.",
	"@@Shaded-Relief_hillshadetype_tag2@@": "<strong>Multidirectionnel</strong> : associe la lumière de plusieurs sources pour représenter une visualisation optimisée du terrain.",
	"@@Shaded-Relief_PSPower_tag0@@": "L’option <strong>Puissance de taille de pixel</strong> tient compte des changements d’altitude (ou d’échelle) à mesure que des zooms avant ou arrière sont appliqués sur l’affichage cartographique. Il s’agit de l’exposant appliqué au terme de taille de pixel dans l’équation qui contrôle la fréquence à laquelle le <strong>Facteur Z</strong> change pour éviter les pertes de relief significatives.",
	"@@Shaded-Relief_PSPower_tag1@@": "Ce paramètre est valide uniquement si le type <strong>Mise à l’échelle</strong> est défini sur <strong>Ajusté</strong>. La valeur par défaut est 0,664.",
	"@@Shaded-Relief_PSZFactor_tag0@@": "L’option <strong>Facteur de taille de pixel</strong> tient compte des changements d’échelle à mesure que des zooms avant ou arrière sont appliqués sur l’affichage cartographique. Elle contrôle la fréquence à laquelle le <strong>Facteur Z</strong> change.",
	"@@Shaded-Relief_PSZFactor_tag1@@": "Ce paramètre est valide uniquement si le type <strong>Mise à l’échelle</strong> est défini sur <strong>Ajusté</strong>. La valeur par défaut est 0,024.",
	"@@Sin_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Sin_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Sin_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Sin_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Sin_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Sin_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Sin_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Sin_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Sin_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Sin_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Sin_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Sin_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de sinus.",
	"@@SinH_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@SinH_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@SinH_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@SinH_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@SinH_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@SinH_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@SinH_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@SinH_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@SinH_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@SinH_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@SinH_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@SinH_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de sinus hyperbolique.",
	"@@Sink_Flow-Direction-Raster_tag0@@": "Raster en entrée qui montre la direction du flux sortant de chaque cellule.",
	"@@Sink_Flow-Direction-Raster_tag1@@": "Le raster de direction de flux peut être créé en exécutant la fonction <strong>Direction de flux</strong>.",
	"@@Slope_DEM_tag0@@": "Le raster d’altitude en entrée.",
	"@@Slope_Disable-default-edge-pixel-interpolation_tag0@@": "Cette option évite les artefacts de rééchantillonnage qui peuvent se produire le long des tronçons d'un raster. Les pixels en sortie le long du tronçon d'un raster ou à côté de pixels sans valeur sont renseignés avec NoData. Il est par conséquent recommandé d'utiliser cette option uniquement lorsque d'autres rasters avec des pixels superposés sont disponibles. Lorsque des pixels superposés sont disponibles, ces surfaces de NoData affichent les pixels superposés au lieu d'être vides.",
	"@@Slope_Disable-default-edge-pixel-interpolation_tag1@@": "Non sélectionnée : le ré-échantillonnage bilinéaire sera appliqué uniformément pour ré-échantillonner la pente. Il s’agit de l’option par défaut.",
	"@@Slope_Disable-default-edge-pixel-interpolation_tag2@@": "Sélectionnée : le ré-échantillonnage bilinéaire sera utilisé dans la pente, sauf le long des limites des rasters ou en dehors des pixels de valeur NoData. Ces pixels sont renseignés avec NoData, car ils réduisent les effets de tronçons abrupts pouvant se produire.",
	"@@Slope_Scaling_tag0@@": "L’inclinaison de la pente peut être générée sous la forme d’une valeur exprimée en degrés ou en pourcentage d’élévation. Il existe trois options pour la <strong>Mise à l’échelle</strong> :",
	"@@Slope_Scaling_tag3@@": "<strong>Degré</strong> : l’inclinaison de la pente est calculée en degrés. Les valeurs sont comprises entre 0 et 90.",
	"@@Slope_Scaling_tag5@@": "<strong>Pourcentage d’élévation</strong> : l’inclinaison de la pente est calculée en valeurs de pourcentage. Les valeurs sont comprises entre 0 et l’infini. Une surface plane correspond à un pourcentage d’élévation de 0 pour cent et une surface à 45 degrés à un pourcentage d’élévation de 100 pour cent. Au fur et à mesure que la surface devient de plus en plus verticale, le pourcentage d’élévation augmente.",
	"@@Slope_Scaling_tag7@@": "<strong>Mise à l’échelle</strong> : l’inclinaison de la pente est calculée de la même manière qu’avec DEGRÉ, mais le facteur z est ajusté pour l’échelle. Cette option utilise les valeurs de <strong>Puissance de taille de pixel</strong> et de <strong>Facteur de taille de pixel</strong>, qui tiennent compte des changements de résolution (échelle) lors d’un zoom avant ou arrière. Elle est recommandée lors de l’utilisation de jeux de données au niveau mondial, plus particulièrement si vous utilisez une pente comme surface de visualisation.",
	"@@Slope_Scaling_tag13@@": "Le facteur z est ajusté à l'aide de l'équation suivante :",
	"@@Slope_Scaling_tag14@@": "Facteur Z ajusté = (facteur Z) + (taille de pixel)",
	"@@Slope_Scaling_tag15@@": "x (Facteur de taille de pixel)",
	"@@Slope_Scaling_tag16@@": "Puissance de la taille de pixel",
	"@@Slope_Z-Factor_tag0@@": "Le <strong>Facteur Z</strong> est un facteur d’échelle utilisé pour convertir les valeurs d’élévation dans deux buts :",
	"@@Slope_Z-Factor_tag3@@": "pour convertir les unités altimétriques (telles que les mètres ou les pieds) en unités de coordonnées horizontales du jeu de données, qui peuvent être des pieds, des mètres ou des degrés ;",
	"@@Slope_Z-Factor_tag4@@": "pour ajouter une exagération verticale comme effet visuel.",
	"@@Slope_PSPower_tag0@@": "L’option <strong>Puissance de taille de pixel</strong> tient compte des changements d’altitude (ou d’échelle) à mesure que des zooms avant ou arrière sont appliqués sur l’affichage cartographique. Il s’agit de l’exposant appliqué au terme de taille de pixel dans l’équation qui contrôle la fréquence à laquelle le <strong>Facteur Z</strong> change pour éviter les pertes de relief significatives.",
	"@@Slope_PSPower_tag1@@": "Ce paramètre est valide uniquement si le type <strong>Mise à l’échelle</strong> est défini sur <strong>Avec mise à l’échelle</strong>. La valeur par défaut est 0,664.",
	"@@Slope_PSZFactor_tag0@@": "L’option <strong>Facteur de taille de pixel</strong> tient compte des changements d’échelle à mesure que des zooms avant ou arrière sont appliqués sur l’affichage cartographique. Elle contrôle la fréquence à laquelle le <strong>Facteur Z</strong> change.",
	"@@Slope_PSZFactor_tag1@@": "Ce paramètre est valide uniquement si le type <strong>Mise à l’échelle</strong> est défini sur <strong>Avec mise à l’échelle</strong>. La valeur par défaut est 0,024.",
	"@@Snap-Pour-Point_Flow-Accumulation-Raster_tag0@@": "Couche raster d’accumulation de flux en entrée.",
	"@@Snap-Pour-Point_Flow-Accumulation-Raster_tag1@@": "Celui-ci peut être créé avec la fonction <strong>Accumulation de flux</strong>.",
	"@@Snap-Pour-Point_Pour-Point-Field_tag0@@": "Champ utilisé pour attribuer des valeurs aux emplacements de points d'écoulement.",
	"@@Snap-Pour-Point_Pour-Point-Raster_tag0@@": "Emplacements de point d'écoulement en entrée qui seront capturés.",
	"@@Snap-Pour-Point_Pour-Point-Raster_tag1@@": "Pour une couche raster en entrée, toutes les cellules dont la valeur n’est pas NoData (qui ont une valeur) sont considérées comme des points d’écoulement et sont capturées.",
	"@@Snap-Pour-Point_Snap-Distance_tag0@@": "Distance maximale (en unités de carte) de recherche d’une cellule d’accumulation de flux plus élevée.",
	"@@Speckle_Additive-Noise-Mean_tag0@@": "Spécifie la valeur moyenne du bruit additif. Une valeur de moyenne de bruit plus élevée produit un lissage moindre, tandis qu’une valeur plus petite génère un lissage plus important.",
	"@@Speckle_Additive-Noise-Mean_tag1@@": "Ce paramètre est valide uniquement si l’option <strong>Type de filtre</strong> est définie sur <strong>Filtre Lee</strong> et que le <strong>Modèle de bruit</strong> est défini sur <strong>Bruit additif</strong> ou sur <strong>Bruit additif et multiplicatif</strong>. La valeur par défaut est 0.",
	"@@Speckle_Damping-Factor_tag0@@": "Spécifie l’étendue de l’effet d’humidité exponentielle sur le filtrage. Une valeur d’humidité plus élevée préserve mieux les tronçons mais génère un lissage moindre, tandis qu’une valeur moins élevée produit un plus grand lissage. La valeur 0 produit le même résultat qu'un filtre passe-bas.",
	"@@Speckle_Damping-Factor_tag1@@": "Ce paramètre est valide uniquement si l’option <strong>Type de filtre</strong> est définie sur <strong>Filtre Lee amélioré</strong> ou sur <strong>Filtre Frost</strong>. La valeur par défaut est 1.",
	"@@Speckle_Filter-Size_tag0@@": "Spécifie la taille de la fenêtre de pixel utilisée pour filtrer le bruit :",
	"@@Speckle_Filter-Size_tag1@@": "3x3",
	"@@Speckle_Filter-Size_tag2@@": "5x5",
	"@@Speckle_Filter-Size_tag3@@": "7x7",
	"@@Speckle_Filter-Size_tag4@@": "9x9",
	"@@Speckle_Filter-Size_tag5@@": "11x11",
	"@@Speckle_Filter-Type_tag0@@": "Spécifie le type de filtre à utiliser dans l’algorithme de lissage en vue de supprimer la granularité :",
	"@@Speckle_Filter-Type_tag1@@": "<strong>Filtre Lee</strong> : réduit la granularité en appliquant un filtre spatial à chaque pixel d’une image, ce qui filtre les données en fonction des statistiques locales calculées dans une fenêtre carrée. Ce filtre est utile pour lisser les données granuleuses qui comportent un composant additif et/ou multiplicatif. Il s’agit de l’option par défaut.",
	"@@Speckle_Filter-Type_tag3@@": "<strong>Filtre Lee amélioré</strong> : version adaptée du filtre Lee qui inclut les paramètres <strong>Facteur d’atténuation</strong> et <strong>Nombre de vues</strong>. Ce filtre est utile pour réduire la granularité tout en préservant les informations de texture.",
	"@@Speckle_Filter-Type_tag9@@": "<strong>Filtre Frost</strong> : réduit la granularité à l’aide d’un filtre symétrique circulaire d’atténuation exponentielle qui utilise des statistiques locales dans les fenêtres de chaque filtre. Ce filtre est utile pour réduire la granularité tout en préservant les segments dans les images radar.",
	"@@Speckle_Filter-Type_tag11@@": "<strong>Filtre Kuan</strong> : similaire au filtre Lee, ce filtre applique un filtre spatial à chaque pixel d’une image et filtre les données en fonction des statistiques locales calculées dans une fenêtre carrée. Ce filtre est utile pour réduire la granularité tout en préservant les segments dans les images radar.",
	"@@Speckle_Multiplicative-Noise-Mean_tag0@@": "Spécifie la valeur moyenne du bruit multiplicatif. Une valeur de moyenne de bruit plus élevée produit un lissage moindre, tandis qu’une valeur plus petite génère un lissage plus important.",
	"@@Speckle_Multiplicative-Noise-Mean_tag1@@": "Ce paramètre est valide uniquement si l’option <strong>Type de filtre</strong> est définie sur <strong>Filtre Lee</strong> et que le <strong>Modèle de bruit</strong> est défini sur <strong>Bruit additif</strong> ou sur <strong>Bruit additif et multiplicatif</strong>. La valeur par défaut est 1.",
	"@@Speckle_Noise-Model_tag0@@": "Spécifie le type de bruit qui réduit la qualité de l’image radar :",
	"@@Speckle_Noise-Model_tag1@@": "<strong>Bruit multiplicatif</strong> : bruit de signal aléatoire qui est multiplié dans le signal pertinent au cours de la capture ou de la transmission.",
	"@@Speckle_Noise-Model_tag3@@": "<strong>Bruit additif</strong> : bruit de signal aléatoire qui est ajouté au signal pertinent au cours de la capture ou de la transmission.",
	"@@Speckle_Noise-Model_tag5@@": "<strong>Bruit additif et multiplicatif</strong> : les deux modèles de bruit.",
	"@@Speckle_Noise-Variance_tag0@@": "Spécifie la variance de bruit de l’image radar.",
	"@@Speckle_Noise-Variance_tag1@@": "Ce paramètre est valide uniquement si l’option <strong>Type de filtre</strong> est définie sur <strong>Filtre Lee</strong> et que le <strong>Modèle de bruit</strong> est défini sur <strong>Bruit additif</strong> ou sur <strong>Bruit additif et multiplicatif</strong>. La valeur par défaut est 0,25.",
	"@@Speckle_Number-of-Looks_tag0@@": "Spécifie le nombre de vues de l’image, ce qui contrôle le lissage des images et estime la variance de bruit. Une valeur plus petite produit un plus grand lissage, tandis qu’une valeur plus élevée conserve davantage d’entités d’images.",
	"@@Speckle_Number-of-Looks_tag1@@": "Ce paramètre est valide uniquement si l’option <strong>Type de filtre</strong> est définie sur <strong>Filtre Lee</strong> et que le <strong>Modèle de bruit</strong> est défini sur <strong>Bruit multiplicatif</strong>, ou si l’option <strong>Type de filtre</strong> est définie sur <strong>Filtre Kuan</strong>. La valeur par défaut est 1.",
	"@@Speckle_Raster_tag0@@": "Raster en entrée.",
	"@@Spectral-Conversion_Conversion-Matrix_tag0@@": "Matrice utilisée pour convertir le raster en entrée.",
	"@@Spectral-Conversion_Conversion-Matrix_tag1@@": "L'équation utilisée pour effectuer cette conversion est la suivante :",
	"@@Spectral-Conversion_Conversion-Matrix_tag2@@": "Canal en sortie Band_R = Weight_P * Band_C",
	"@@Spectral-Conversion_Conversion-Matrix_tag3@@": "où :",
	"@@Spectral-Conversion_Conversion-Matrix_tag4@@": "Band_R est un canal en sortie, où R est un nombre compris entre 1 et le nombre de canaux en sortie.",
	"@@Spectral-Conversion_Conversion-Matrix_tag5@@": "Weight_P est une liste de pondérations délimitée par des virgules, 1 pour chaque canal en entrée. La somme des pondérations de chaque canal doit égaler la valeur 1.",
	"@@Spectral-Conversion_Conversion-Matrix_tag6@@": "Band_C est l'image en entrée, où C est un nombre compris entre 1 et le nombre de canaux de l'image en entrée.",
	"@@Spectral-Conversion_Raster_tag0@@": "Raster en entrée.",
	"@@Spectral-Conversion_Raster_tag1@@": "Il peut s’agir d’un jeu de données raster, d’une mosaïque ou d’un service d’imagerie.",
	"@@Spectral-Conversion_Size_tag0@@": "Nombre de lignes et de colonnes de la <strong>Matrice de conversion</strong>.",
	"@@Square_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Square_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Square_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Square_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Square_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Square_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Square_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Square_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Square_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Square_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Square_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Square_Raster_tag0@@": "Valeurs en entrée à mettre au carré.",
	"@@Square-Root_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Square-Root_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Square-Root_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Square-Root_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Square-Root_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Square-Root_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Square-Root_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Square-Root_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Square-Root_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Square-Root_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Square-Root_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Square-Root_Raster_tag0@@": "Valeurs en entrée utilisées pour calculer la racine carrée.",
	"@@Statistics-and-Histogram_Define-Statistics-and-Histogram_tag0@@": "Définissez les valeurs de statistiques de chaque canal.",
	"@@Statistics-and-Histogram_Define-Statistics-and-Histogram_tag1@@": "La colonne ${Histogram} est un champ en lecture seule qui peut être renseigné grâce au paramètre <strong>Importer</strong>. Si vous importez un fichier d’histogramme, la colonne ${Histogram} est marquée comme <strong>Définie</strong>.",
	"@@Statistics-and-Histogram_Import_tag0@@": "Importe les informations liées aux statistiques et à l'histogramme d'un raster ou d'un fichier XML existant.",
	"@@Statistics-and-Histogram_Raster_tag0@@": "Le raster en entrée pour lequel les statistiques et l’histogramme doivent être définis.",
	"@@Statistics-and-Histogram_Statistics_tag0@@": "Définissez les valeurs de statistiques de chaque canal.",
	"@@Stream-Link_Flow-Direction-Raster_tag0@@": "Raster en entrée qui montre la direction du flux sortant de chaque cellule.",
	"@@Stream-Link_Flow-Direction-Raster_tag1@@": "Le raster de direction de flux peut être créé en exécutant la fonction <strong>Direction de flux</strong>.",
	"@@Stream-Link_Stream-Raster_tag0@@": "Raster en entrée représentant un réseau d’écoulement linéaire.",
	"@@Stream-Order_Flow-Direction-Raster_tag0@@": "Raster en entrée qui montre la direction du flux sortant de chaque cellule.",
	"@@Stream-Order_Flow-Direction-Raster_tag1@@": "Le raster de direction de flux peut être créé en exécutant la fonction <strong>Direction de flux</strong>.",
	"@@Stream-Order_Order-Method_tag0@@": "Méthode utilisée pour attribuer l'ordre d'écoulement.",
	"@@Stream-Order_Order-Method_tag1@@": "<strong>STRAHLER</strong> : méthode de hiérarchisation d’écoulement proposée par Strahler en 1952. L’ordre d’écoulement augmente uniquement lorsque des cours d’eau du même ordre se croisent. L’intersection d’une liaison de premier ordre et d’une liaison de deuxième ordre reste une liaison de deuxième ordre plutôt que de créer une liaison de troisième ordre. Il s’agit de l’option par défaut.",
	"@@Stream-Order_Order-Method_tag3@@": "<strong>SHREVE</strong> : méthode de hiérarchisation d’écoulement par magnitude, proposée par Shreve en 1967. Tous les liens sans affluent ont une magnitude (ordre) de un. Les magnitudes sont des pentes descendantes additives. Lorsque deux liaisons se croisent, leurs magnitudes sont additionnées et le résultat est attribué au lien de pente descendante.",
	"@@Stream-Order_Stream-Raster_tag0@@": "Raster d’écoulement en entrée représentant un réseau d’écoulement linéaire.",
	"@@Stretch_Auto-Gamma_tag0@@": "Utilisez la <strong>Valeur Gamma automatique</strong> pour calculer la valeur Gamma à partir des statistiques et de l’histogramme du jeu de données. Les statistiques peuvent être estimées par la fonction même ou par le logiciel si vous avez choisi une couche.",
	"@@Stretch_Dynamic-Range-Adjustment_tag0@@": "Cochez la case <strong>Ajustement dynamique de la plage</strong> pour calculer les statistiques uniquement à partir des pixels affichés à l’écran. Cette option est appliquée en général lorsque l’image est destinée à être publiée et utilisée dans une application Web qui ne peut pas effectuer ce type d’étirement.",
	"@@Stretch_Estimate-Statistics_tag0@@": "Cochez la case <strong>Estimer les statistiques</strong> pour estimer vos statistiques. Les statistiques estimées sont calculées à partir d’un échantillon de 1 000 sur 1 000 depuis le centre du raster et utilisées par l’étirement.",
	"@@Stretch_Estimate-Statistics_tag3@@": "Si cette option est sélectionnée et que le raster comporte des statistiques, ou si vous avez saisi des valeurs dans la table <strong>Statistiques</strong>, elles sont utilisées au lieu d’effectuer une estimation, sauf si l’étirement nécessite un histogramme. Si l’étirement nécessite un histogramme qui n’existe pas, il est estimé.",
	"@@Stretch_Gamma_tag0@@": "Utilisez la barre du curseur pour définir manuellement la valeur <strong>Gamma</strong>.",
	"@@Stretch_Number-Of-Standard-Deviations_tag0@@": "Spécifiez la valeur n pour le nombre d'écart types à utiliser. Cette méthode permet d'accentuer dans quelle mesure les valeurs d'entités varient par rapport à la valeur moyenne. Elle est plus utile lorsqu'elle est utilisée sur des données réparties normalement.",
	"@@Stretch_Output-Maximum_tag0@@": "Définissez la valeur de pixel la plus élevée pour l'histogramme.",
	"@@Stretch_Output-Maximum_tag1@@": "Les valeurs de <strong>Sortie minimale</strong> et de <strong>Sortie maximale</strong> définissent la plage des valeurs qui présenteront ensuite un étirement de contraste linéaire.",
	"@@Stretch_Output-Minimum_tag0@@": "Définissez la valeur de pixel la plus faible pour l'histogramme.",
	"@@Stretch_Output-Minimum_tag1@@": "Les valeurs de <strong>Sortie minimale</strong> et de <strong>Sortie maximale</strong> définissent la plage des valeurs qui présenteront ensuite un étirement de contraste linéaire.",
	"@@Stretch_Percent-Clip-Maximum_tag0@@": "Spécifiez le pourcentage des valeurs élevées à exclure de l'étirement.",
	"@@Stretch_Percent-Clip-Maximum_tag1@@": "Les valeurs correctes sont comprises entre 0 et 99.",
	"@@Stretch_Percent-Clip-Minimum_tag0@@": "Spécifiez le pourcentage des valeurs faibles à exclure de l'étirement.",
	"@@Stretch_Percent-Clip-Minimum_tag1@@": "Les valeurs correctes sont comprises entre 0 et 99.",
	"@@Stretch_Raster_tag0@@": "Le raster en entrée pour l'étirement de contraste.",
	"@@Stretch_Sigmoid-Strength-Level_tag0@@": "Le <strong>Niveau de force</strong> détermine quelle partie de la fonction sigmoïdale sera utilisée dans l’étirement. Une valeur faible (par exemple, 1) utilise uniquement la partie centrale de la courbe, ce qui tend à générer des couleurs ternes et floues. Une valeur élevée (par exemple, 6) utilise l’intégralité de la courbe, ce qui tend à générer des couleurs vives et nettes.",
	"@@Stretch_Statistics_tag0@@": "Vous pouvez saisir vos propres statistiques dans la boîte de dialogue. Par défaut, les statistiques sont extraites des données. Toutefois, si vous entrez des valeurs dans ce paramètre, elles seront utilisées à la place.",
	"@@Stretch_Type_tag0@@": "Choisissez la méthode du type d'étirement:",
	"@@Stretch_Type_tag1@@": "Aucun : aucun étirement de contraste",
	"@@Stretch_Type_tag2@@": "Écart type : étirement Écart type",
	"@@Stretch_Type_tag3@@": "MinMax : étirement Minimum-Maximum",
	"@@Stretch_Type_tag4@@": "PourcentageMinMax : étirement Pourcentage de découpe",
	"@@Stretch_Type_tag5@@": "Sigmoïde : étirement Sigmoïde",
	"@@Stretch_Use-Gamma_tag0@@": "Cochez la case <strong>Utiliser la valeur Gamma</strong> pour appliquer un étirement gamma.",
	"@@Swath_Cellsize_tag0@@": "La taille de cellule du raster en sortie est automatiquement détectée, mais ceci peut être modifié si vous le souhaitez. La taille de cellule peut être modifiée, mais l'étendue du jeu de données raster reste identique.",
	"@@Swath_Interpolation-Method_tag0@@": "Quatre méthodes de rééchantillonnage sont disponibles pour cette fonction :",
	"@@Swath_Interpolation-Method_tag1@@": "<strong>Voisin le plus proche</strong> : calcule la valeur du pixel grâce au pixel le plus proche. Si aucun pixel source n’existe, aucun nouveau pixel ne peut être créé dans la sortie.",
	"@@Swath_Interpolation-Method_tag3@@": "<strong>Bilinéaire</strong> : calcule la valeur du pixel en utilisant la valeur de distance pondérée des quatre pixels les plus proches.",
	"@@Swath_Interpolation-Method_tag5@@": "<strong>TIN linéaire</strong> : utilise un réseau triangulé irrégulier (TIN) à partir des points centraux de chaque cellule du raster irrégulier pour interpoler une surface qui sera ensuite convertie en raster régulier.",
	"@@Swath_Interpolation-Method_tag7@@": "<strong>Voisin naturel</strong> : effectue une affectation du voisin le plus proche. Il s’agit de la plus rapide des méthodes d’interpolation. Elle est essentiellement utilisée pour les données discrètes, telles qu’une classification de l’utilisation du sol, car elle ne modifie pas les valeurs des cellules. L’erreur spatiale maximale sera de la moitié d’une taille de cellule.",
	"@@Swath_Raster_tag0@@": "Raster de points quadrillés de façon irrégulière à rééchantillonner.",
	"@@Tan_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Tan_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Tan_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Tan_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Tan_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Tan_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Tan_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Tan_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Tan_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Tan_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Tan_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Tan_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de tangente.",
	"@@TanH_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@TanH_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@TanH_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@TanH_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@TanH_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@TanH_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@TanH_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@TanH_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@TanH_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@TanH_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@TanH_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@TanH_Raster_tag0@@": "Entrée pour laquelle calculer les valeurs de tangente hyperbolique.",
	"@@Tasseled-Cap_Raster_tag0@@": "Raster en entrée sur lequel exécuter la transformation.",
	"@@Times_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Times_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Times_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Times_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Times_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Times_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Times_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Times_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Times_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Times_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Times_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Times_Raster_tag0@@": "Entrée qui contient les valeurs à multiplier.",
	"@@Times_Raster_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Times_Raster2_tag0@@": "Entrée qui contient les valeurs par lesquelles la première entrée est multipliée.",
	"@@Times_Raster2_tag1@@": "Une valeur constante peut être utilisée en entrée pour ce paramètre, à condition qu’un raster soit spécifié pour l’autre paramètre.",
	"@@Transpose-Bits_Bit-Pattern_tag0@@": "Choisissez le type de transposition à effectuer ou spécifiez un type personnalisé.",
	"@@Transpose-Bits_Bit-Pattern_tag1@@": "Landsat 8 Cirrus",
	"@@Transpose-Bits_Bit-Pattern_tag2@@": "Landsat 8 Nuage",
	"@@Transpose-Bits_Bit-Pattern_tag3@@": "Landsat 8 Ombre nuage",
	"@@Transpose-Bits_Bit-Pattern_tag4@@": "Landsat 8 Remplissage désigné",
	"@@Transpose-Bits_Bit-Pattern_tag5@@": "Landsat 8 Image déplacée",
	"@@Transpose-Bits_Bit-Pattern_tag6@@": "Landsat 8 Neige/glace",
	"@@Transpose-Bits_Bit-Pattern_tag7@@": "Landsat 8 Occlusion de terrain",
	"@@Transpose-Bits_Bit-Pattern_tag8@@": "Landsat 8 Végétation",
	"@@Transpose-Bits_Bit-Pattern_tag9@@": "Landsat 8 Eau",
	"@@Transpose-Bits_Bit-Pattern_tag10@@": "Défini par l’utilisateur",
	"@@Transpose-Bits_Constant-Value_tag0@@": "Valeur facultative qui permet de renseigner tous les bits non impliqués dans la transposition. Ce paramètre est visible si le paramètre <strong>Générer un raster de remplissage à partir d’une constante</strong> est défini sur <strong>Oui</strong>.",
	"@@Transpose-Bits_Fill-Raster_tag0@@": "Spécifiez un jeu de données raster permettant de renseigner tous les bits non impliqués dans la transposition. Ce paramètre est visible si le paramètre <strong>Générer un raster de remplissage à partir d’une constante</strong> est défini sur <strong>Non</strong>.",
	"@@Transpose-Bits_Generate-Fill-Raster-from-Constant_tag0@@": "Générer un raster de remplissage à l’aide d’une valeur constante.",
	"@@Transpose-Bits_Generate-Fill-Raster-from-Constant_tag1@@": "<strong>Oui</strong> : un raster sera généré à l’aide d’une valeur constante pour renseigner tous les bits non impliqués dans la transposition. Il s’agit de l’option par défaut.",
	"@@Transpose-Bits_Generate-Fill-Raster-from-Constant_tag3@@": "<strong>Non</strong> : un raster sera généré à l’aide de valeurs de pixels provenant d’un jeu de données raster existant pour renseigner tous les bits non impliqués dans la transposition.",
	"@@Transpose-Bits_Output-Bit-and-Input-Bit_tag0@@": "Une table en lecture seule présentant les bits en sortie et les entrées qui seront à leur place.",
	"@@Transpose-Bits_Raster_tag0@@": "Le raster en entrée à décompresser et apparier à nouveau.",
	"@@Unit-Conversion_From-Unit_tag0@@": "Type d’unité d’origine des pixels.",
	"@@Unit-Conversion_Raster_tag0@@": "Raster en entrée qui contient les unités converties.",
	"@@Unit-Conversion_To-Unit_tag0@@": "Type d’unité convertie des pixels.",
	"@@Vector-Field_Angle-Reference-System_tag0@@": "Spécifie la façon dont le composant de direction a été mesuré.",
	"@@Vector-Field_Angle-Reference-System_tag1@@": "Géographique : 0° pointe vers le nord et 90° pointe vers l’est",
	"@@Vector-Field_Angle-Reference-System_tag2@@": "Arithmétique : 0° pointe vers l’est et 90° pointe vers le nord",
	"@@Vector-Field_Input-Data-Type_tag0@@": "Type de champ vectoriel représenté par vos entrées.",
	"@@Vector-Field_Input-Data-Type_tag1@@": "Unknown (Inconnu) : vous ne savez pas si les entrées représentent des valeurs U-V ou des valeurs Magnitude-Direction.",
	"@@Vector-Field_Input-Data-Type_tag2@@": "U-V : les données en entrée représentent les composants U et V.",
	"@@Vector-Field_Input-Data-Type_tag3@@": "Magnitude-Direction : les données en entrée représentent la magnitude et la direction.",
	"@@Vector-Field_Output-Data-Type_tag0@@": "Indique le type de champ vectoriel représenté par votre sortie.",
	"@@Vector-Field_Output-Data-Type_tag1@@": "Magnitude-Direction : les données en sortie représentent la magnitude et la direction.",
	"@@Vector-Field_Output-Data-Type_tag2@@": "U-V : les données en sortie représentent les composants U et V.",
	"@@Vector-Field_Raster1_tag0@@": "Premier raster en entrée.",
	"@@Vector-Field_Raster1_tag1@@": "Il s’agit de la valeur U ou de la magnitude.",
	"@@Vector-Field_Raster2_tag0@@": "Second raster en entrée.",
	"@@Vector-Field_Raster2_tag1@@": "Il s’agit de la valeur V ou de la direction.",
	"@@Viewshed_Analysis-Method_tag0@@": "Choisissez la méthode qui permettra de calculer la visibilité. Cette option vous permet d'adapter la précision afin d'optimiser les performances.",
	"@@Viewshed_Analysis-Method_tag1@@": "Toutes les lignes de visée : une ligne de visée est effectuée sur chaque pixel du raster afin d’établir des zones visibles. Il s'agit de la méthode par défaut.",
	"@@Viewshed_Analysis-Method_tag2@@": "Lignes de visée du périmètre : des lignes de visée sont uniquement effectuées sur les pixels situés dans le périmètre des zones visibles afin d’établir des zones de visibilité. Les performances de cette méthode sont meilleures que celles de la méthode <strong>Toutes les lignes de visée</strong>, car un moins grand nombre de lignes de visée sont présentes dans le calcul.",
	"@@Viewshed_Analysis-Type_tag0@@": "Choisissez le type d'analyse de visibilité que vous souhaitez effectuer, soit en déterminant le degré de visibilité de chaque cellule par rapport aux points d'observation, soit en identifiant pour chaque emplacement de la surface quels points d'observation sont visibles.",
	"@@Viewshed_Analysis-Type_tag1@@": "Fréquence : le nombre de fois où chaque emplacement de pixel dans le raster de surface en entrée est visible depuis les emplacements des points d’observation en entrée (en tant que points ou en tant que sommets pour les entités polylignes d’observation). Il s’agit de l’option par défaut.",
	"@@Viewshed_Analysis-Type_tag2@@": "Points d’observation : la sortie identifie avec précision les points d’observation visibles depuis chaque emplacement de la surface raster. Le nombre maximal autorisé de points d'observation en entrée est 32 avec ce type d'analyse.",
	"@@Viewshed_Horizontal-End-Angle_tag0@@": "Cette valeur définit l'angle de fin de la plage d'analyse horizontale. La valeur doit être exprimée en degrés de 0 à 360.0, 0 étant orienté vers le nord. La valeur par défaut est 360.0.",
	"@@Viewshed_Horizontal-End-Angle_tag1@@": "Il peut s’agir d’un champ du jeu de données <strong>Entités points d’observation</strong> en entrée ou d’une valeur numérique. Si une valeur est attribuée à ce paramètre, elle est appliquée à tous les points d’observation. Pour spécifier des valeurs différentes pour chaque point d’observation, définissez ce paramètre sur un champ du jeu de données <strong>Entités points d’observation</strong>.",
	"@@Viewshed_Horizontal-Start-Angle_tag0@@": "Cette valeur définit l'angle de départ de la plage d'analyse horizontale. La valeur doit être exprimée en degrés de 0 à 360.0, 0 étant orienté vers le nord. La valeur par défaut est 0.",
	"@@Viewshed_Horizontal-Start-Angle_tag1@@": "Il peut s’agir d’un champ du jeu de données <strong>Entités points d’observation</strong> en entrée ou d’une valeur numérique. Si une valeur est attribuée à ce paramètre, elle est appliquée à tous les points d’observation. Pour spécifier des valeurs différentes pour chaque point d’observation, définissez ce paramètre sur un champ du jeu de données <strong>Entités points d’observation</strong>.",
	"@@Viewshed_Inner-Radius-is-3D-Distance_tag0@@": "Type de distance pour le paramètre de rayon intérieur.",
	"@@Viewshed_Inner-Radius-is-3D-Distance_tag1@@": "Désactivé : le <strong>Rayon intérieur</strong> doit être interprété comme une distance 2D. Il s’agit de l’option par défaut.",
	"@@Viewshed_Inner-Radius-is-3D-Distance_tag4@@": "Activé : le <strong>Rayon intérieur</strong> doit être interprété comme une distance 3D.",
	"@@Viewshed_Inner-Radius_tag0@@": "Cette valeur définit la distance de départ (minimum) à partir de laquelle la visibilité est déterminée. Les pixels plus proches que cette distance sont considérés comme non visibles dans la sortie, mais peuvent toujours empêcher la visibilité des pixels situés entre le <strong>Rayon intérieur</strong> et le <strong>Rayon extérieur</strong>. La valeur par défaut est 0.",
	"@@Viewshed_Inner-Radius_tag5@@": "Il peut s’agir d’un champ du jeu de données <strong>Entités points d’observation</strong> en entrée ou d’une valeur numérique. Si une valeur est attribuée à ce paramètre, elle est appliquée à tous les points d’observation. Pour spécifier des valeurs différentes pour chaque point d’observation, définissez ce paramètre sur un champ du jeu de données <strong>Entités points d’observation</strong>.",
	"@@Viewshed_Observer-Elevation_tag0@@": "Cette valeur permet de définir les altitudes des surfaces des points d'observation ou des sommets.",
	"@@Viewshed_Observer-Elevation_tag1@@": "Il peut s’agir d’un champ du jeu de données <strong>Entités points d’observation</strong> en entrée ou d’une valeur numérique. Si ce paramètre n’est pas spécifié, l’élévation du point d’observation s’obtient à partir du raster de surface à l’aide de l’interpolation bilinéaire. Si une valeur est attribuée à ce paramètre, elle est appliquée à tous les points d’observation. Pour spécifier des valeurs différentes pour chaque point d’observation, définissez ce paramètre sur un champ du jeu de données <strong>Entités points d’observation</strong>.",
	"@@Viewshed_Observer-Features_tag0@@": "La classe d’entités requise en entrée qui identifie les emplacements des points d’observation. Il peut s'agir d'entités ponctuelles, multi-points ou polylinéaires.",
	"@@Viewshed_Observer-Features_tag1@@": "La classe d'entités en entrée est transformée en système de coordonnées 3D géocentriques au cours du calcul de la visibilité. Les points d'observation en dehors de l'étendue du raster de surface, ou se trouvant sur les cellules NoData, ne sont pas pris en compte dans le calcul.",
	"@@Viewshed_Observer-Offset_tag0@@": "Cette valeur indique la distance verticale (en unités de surface) à ajouter à l'altitude du point d'observation. La valeur doit être un entier positif ou un nombre à virgule flottante.",
	"@@Viewshed_Observer-Offset_tag1@@": "Il peut s’agir d’un champ du jeu de données <strong>Entités points d’observation</strong> en entrée ou d’une valeur numérique. Si une valeur est attribuée à ce paramètre, elle est appliquée à tous les points d’observation. Pour spécifier des valeurs différentes pour chaque point d’observation, définissez ce paramètre sur un champ du jeu de données <strong>Entités points d’observation</strong>.",
	"@@Viewshed_Outer-Radius-is-3D-Distance_tag0@@": "Type de distance pour le paramètre de rayon extérieur.",
	"@@Viewshed_Outer-Radius-is-3D-Distance_tag1@@": "Désactivé : le <strong>Rayon extérieur</strong> doit être interprété comme une distance 2D. Il s’agit de l’option par défaut.",
	"@@Viewshed_Outer-Radius-is-3D-Distance_tag4@@": "Activé : le <strong>Rayon extérieur</strong> doit être interprété comme une distance 3D.",
	"@@Viewshed_Outer-Radius_tag0@@": "Cette valeur définit la distance maximale à partir de laquelle la visibilité est déterminée. Les pixels situés au-delà de cette distance sont exclus de l'analyse.",
	"@@Viewshed_Outer-Radius_tag1@@": "Il peut s’agir d’un champ du jeu de données <strong>Entités points d’observation</strong> en entrée ou d’une valeur numérique. Si une valeur est attribuée à ce paramètre, elle est appliquée à tous les points d’observation. Pour spécifier des valeurs différentes pour chaque point d’observation, définissez ce paramètre sur un champ du jeu de données <strong>Entités points d’observation</strong>.",
	"@@Viewshed_Raster_tag0@@": "Le raster de surface en entrée requis. Il peut s'agir d'un entier ou d'un raster en virgule flottante.",
	"@@Viewshed_Raster_tag1@@": "L'entrée est transformée en système de coordonnées 3D géocentriques au cours du calcul de la visibilité. Les cellules NoData du raster en entrée n'empêchent pas de déterminer la visibilité.",
	"@@Viewshed_Refractive-Coefficient_tag0@@": "Coefficient de réfraction de la lumière visible dans l'air.",
	"@@Viewshed_Refractive-Coefficient_tag1@@": "La valeur par défaut est 0,13.",
	"@@Viewshed_Surface-Offset_tag0@@": "Cette valeur indique la distance verticale (en unités de surface) à ajouter à la valeur z de chaque pixel cible, telle qu'elle est prise en compte pour la visibilité. La valeur doit être un entier positif ou un nombre à virgule flottante.",
	"@@Viewshed_Surface-Offset_tag1@@": "Il peut s’agir d’un champ du jeu de données <strong>Entités points d’observation</strong> en entrée ou d’une valeur numérique. Si une valeur est attribuée à ce paramètre, elle est appliquée à tous les points d’observation. Pour spécifier des valeurs différentes pour chaque point d’observation, définissez ce paramètre sur un champ du jeu de données <strong>Entités points d’observation</strong>.",
	"@@Viewshed_Vertical-Error_tag0@@": "Niveau d'incertitude, mesuré en tant qu'erreur quadratique moyenne (EQM) des valeurs d'altitude de surface. Il s'agit de la valeur à virgule flottante représentant l'erreur attendue des valeurs d'altitude en entrée. Lorsque ce paramètre se voit attribuer une valeur supérieure à 0, le raster de visibilité en sortie sera à virgule flottante. Dans ce cas, chaque valeur de pixel du raster de visibilité en sortie représente la somme des probabilités que la cellule puisse être vue d'un quelconque point d'observation.",
	"@@Viewshed_Vertical-Error_tag1@@": "Lorsque le <strong>Type d’analyse</strong> est <strong>Points d’observation</strong> ou que la <strong>Méthode d’analyse</strong> est <strong>Lignes de visée du périmètre</strong>, ce paramètre est désactivé.",
	"@@Viewshed_Vertical-Lower-Angle_tag0@@": "Cette valeur définit la limite de l'angle vertical inférieur de l'analyse au-dessous du plan horizontal. La valeur doit être exprimée en degrés de -90.0 à 0 et peut être un entier ou une valeur à virgule flottante. La valeur par défaut est -90.0.",
	"@@Viewshed_Vertical-Lower-Angle_tag1@@": "Il peut s’agir d’un champ du jeu de données <strong>Entités points d’observation</strong> en entrée ou d’une valeur numérique. Si une valeur est attribuée à ce paramètre, elle est appliquée à tous les points d’observation. Pour spécifier des valeurs différentes pour chaque point d’observation, définissez ce paramètre sur un champ du jeu de données <strong>Entités points d’observation</strong>.",
	"@@Viewshed_Vertical-Upper-Angle_tag0@@": "Cette valeur définit la limite de l'angle vertical supérieur de l'analyse au-dessus du plan horizontal. La valeur doit être exprimée en degrés de 0 à 90.0 et peut être un entier ou une valeur à virgule flottante. La valeur par défaut est 90.0.",
	"@@Viewshed_Vertical-Upper-Angle_tag1@@": "Il peut s’agir d’un champ du jeu de données <strong>Entités points d’observation</strong> en entrée ou d’une valeur numérique. Si une valeur est attribuée à ce paramètre, elle est appliquée à tous les points d’observation. Pour spécifier des valeurs différentes pour chaque point d’observation, définissez ce paramètre sur un champ du jeu de données <strong>Entités points d’observation</strong>.",
	"@@Watershed_Flow-Direction-Raster_tag0@@": "Raster en entrée qui montre la direction du flux sortant de chaque cellule.",
	"@@Watershed_Flow-Direction-Raster_tag1@@": "Le raster de direction de flux peut être créé en exécutant la fonction <strong>Direction de flux</strong>.",
	"@@Watershed_Pour-Point(s)-Raster_tag0@@": "Emplacements des points d'écoulement en entrée.",
	"@@Watershed_Pour-Point(s)-Raster_tag1@@": "Ce raster représente les cellules au-dessus desquelles la surface de captation est déterminée. Toutes les cellules n'ayant pas la valeur NoData sont utilisées en tant que cellules sources.",
	"@@Watershed_Pour-Point-Field_tag0@@": "Champ utilisé pour attribuer des valeurs aux emplacements de points d'écoulement.",
	"@@Watershed_Pour-Point-Field_tag1@@": "Dans le cas d’un jeu de données raster de points d’écoulement, l’option ${Value} est utilisée par défaut.",
	"@@Weighted-Overlay_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Weighted-Overlay_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Weighted-Overlay_Cellsize-Type_tag2@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Weighted-Overlay_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Weighted-Overlay_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Weighted-Overlay_Cellsize-Type_tag5@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Weighted-Overlay_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Weighted-Overlay_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Weighted-Overlay_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Weighted-Overlay_Extent-Type_tag3@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Weighted-Overlay_Extent-Type_tag4@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Weighted-Overlay_Scales_tag0@@": "Plage des nouvelles valeurs permettant de classifier les anciennes valeurs.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag0@@": "La table de superposition pondérée se compose de quatre parties :",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag1@@": "Couche : tous les rasters en entrée doivent être des entiers.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag2@@": "Influence : chaque raster en entrée est pondéré selon son importance, ou son influence, en pourcentage relatif. La somme des pondérations des pourcentages d’influence doit être égale à 100 et chaque pondération doit être spécifiée à l’aide de valeurs entières.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag3@@": "Champ : un champ de type entier ou chaîne dans le raster en entrée à utiliser pour la pondération.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag4@@": "Table de classification : une nouvelle valeur d’échelle basée sur la table de classification est affectée à chaque valeur dans un raster en entrée. La valeur d’échelle peut être une valeur valide ou une valeur NoData.",
	"@@Weighted-Sum_Cellsize-Type_tag0@@": "Choisissez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Weighted-Sum_Cellsize-Type_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Weighted-Sum_Cellsize-Type_tag2@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Weighted-Sum_Cellsize-Type_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Weighted-Sum_Cellsize-Type_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Weighted-Sum_Cellsize-Type_tag5@@": "Mini de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Weighted-Sum_Extent-Type_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Weighted-Sum_Extent-Type_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Weighted-Sum_Extent-Type_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Weighted-Sum_Extent-Type_tag3@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Weighted-Sum_Extent-Type_tag4@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Weighted-Sum_Weighted-Sum-Table_tag0@@": "La table de somme pondérée est définie par trois propriétés :",
	"@@Weighted-Sum_Weighted-Sum-Table_tag1@@": "Couche : le raster qui est pondéré.",
	"@@Weighted-Sum_Weighted-Sum-Table_tag2@@": "Champ : le champ du raster à utiliser pour la pondération.",
	"@@Weighted-Sum_Weighted-Sum-Table_tag3@@": "Pondération : la valeur de pondération par laquelle multiplier le raster. Il peut s'agir de toute valeur décimale positive ou négative.",
	"@@Wind-Chill_Temperature-Raster_tag0@@": "Raster monocanal où les valeurs de pixel représentent la température de l’air ambiant.",
	"@@Wind-Chill_Temperature-Units_tag0@@": "Unité de mesure associée au raster de température en entrée. Les unités disponibles en entrée sont Celsius, Fahrenheit et Kelvin.",
	"@@Wind-Chill_Wind-Chill-Units_tag0@@": "Unité de mesure associée au raster en sortie. Les unités disponibles en sortie sont Celsius, Fahrenheit et Kelvin.",
	"@@Wind-Chill_Wind-Speed-Raster_tag0@@": "Raster monocanal où les valeurs de pixel représentent la vitesse du vent.",
	"@@Wind-Chill_Wind-Speed-Units_tag0@@": "Définit l’unité de mesure du raster de vitesse du vent.",
	"@@Wind-Chill_Wind-Speed-Units_tag1@@": "Miles par heure (mph)",
	"@@Wind-Chill_Wind-Speed-Units_tag2@@": "Kilomètres par heure (km/h)",
	"@@Wind-Chill_Wind-Speed-Units_tag3@@": "Mètres par seconde (m/s)",
	"@@Wind-Chill_Wind-Speed-Units_tag4@@": "Pieds par seconde (pd/s)",
	"@@Wind-Chill_Wind-Speed-Units_tag5@@": "Nœuds (nd)",
	"@@Zonal-Remap_Background-Value_tag0@@": "La valeur de pixel initiale du raster en sortie, avant le classement des pixels en entrée.",
	"@@Zonal-Remap_Default-Output-Value_tag0@@": "Valeur qui sera attribuée à un pixel qui ne répond à aucune des conditions définies dans la <strong>Table des attributs zonaux</strong>.",
	"@@Zonal-Remap_Default-Output-Value_tag3@@": "Il s’agit également de la valeur du pixel en sortie si le paramètre <strong>Nom du champ de la valeur en sortie</strong> n’est pas spécifié ou si la valeur en sortie du seuil zonal correspondant n’est pas spécifiée dans la <strong>Table des attributs zonaux</strong>.",
	"@@Zonal-Remap_Maximum-Value-Field-Name_tag0@@": "Nom du champ contenant la valeur maximale ci-dessous, dans laquelle un pixel en entrée est classé.",
	"@@Zonal-Remap_Maximum-Value-Field-Name_tag1@@": "Si aucune valeur n'est spécifiée ou si la valeur de champ est Null, les valeurs de pixel maximum ne sont pas testées.",
	"@@Zonal-Remap_Minimum-Value-Field-Name_tag0@@": "Nom du champ contenant la valeur minimale ci-dessus, dans laquelle un pixel en entrée est classé.",
	"@@Zonal-Remap_Minimum-Value-Field-Name_tag1@@": "Si aucune valeur n'est spécifiée ou si la valeur de champ est Null, les valeurs de pixel minimum ne sont pas testées.",
	"@@Zonal-Remap_Output-Value-Field-Name_tag0@@": "Nom du champ contenant la valeur cible dans laquelle un pixel en entrée est classé.",
	"@@Zonal-Remap_Output-Value-Field-Name_tag1@@": "Si aucune valeur n’est spécifiée ou si la valeur de champ est Null, les valeurs de pixels reclassées sont définies sur <strong>Valeur en sortie par défaut</strong>.",
	"@@Zonal-Remap_Value-Raster_tag0@@": "Entrée de raster monocanal requise contenant des valeurs de pixels à classer.",
	"@@Zonal-Remap_Where-Clause_tag0@@": "Requête facultative appliquée à la <strong>Table des attributs zonaux</strong>.",
	"@@Zonal-Remap_Where-Clause_tag3@@": "Si vous utilisiez la table ci-dessus comme exemple, la requête serait ${Variable1 = 'bare earth' AND Variable2 = 'California'}.",
	"@@Zonal-Remap_Zonal-Attributes-Table_tag0@@": "Une table en entrée requise contenant au moins trois champs. Elle doit comporter une valeur de seuil minimale, une valeur de seuil maximale et une valeur cible. La valeur cible est le champ qui contiendra la valeur classée.",
	"@@Zonal-Remap_Zonal-Attributes-Table_tag1@@": "Le format du fichier peut être une classe d’entités, un service d’entités ou n’importe quel type de table pris en charge par ArcGIS.",
	"@@Zonal-Remap_Zone-Field_tag0@@": "Nom du champ dans la <strong>Table des attributs zonaux</strong> qui contient les valeurs d’ID de zone.",
	"@@Zonal-Remap_Zone-Field_tag3@@": "Les valeurs d'ID de zone sont directement liées aux ID de zone dans votre raster zonal. Le classement bénéficie ainsi d’un niveau de filtrage supplémentaire. Si aucun ID de zone n'est associé à un enregistrement en particulier dans la table, il ne fera pas partie du classement.",
	"@@Zonal-Remap_Zone-Raster_tag0@@": "Un raster monocanal où chaque pixel définit les zones associées à un emplacement en particulier. Une zone est définie comme l'ensemble des surfaces en entrée ayant la même valeur. Les surfaces ne sont pas nécessairement contiguës.",
	"@@Predict-Using-Trend_dimensiondefinition_tag0@@": "Spécifie la méthode utilisée pour fournir les valeurs de dimension de prévision.",
	"@@Predict-Using-Trend_dimensiondefinition_tag1@@": "<strong>Par valeur</strong> : la prévision est calculée pour une seule valeur de dimension. Par exemple, vous souhaitez prévoir les précipitations annuelles pour les années 2050, 2100 et 2150. Il s’agit de l’option par défaut.",
	"@@Predict-Using-Trend_dimensiondefinition_tag2@@": "<strong>Par intervalle</strong> : la prévision est calculée pour un intervalle de la dimension défini par une valeur de début et une valeur de fin. Par exemple, vous souhaitez prévoir les précipitations annuelles pour les années comprises entre 2050 et 2150.",
	"@@Predict-Using-Trend_end_tag0@@": "Date de fin, hauteur ou profondeur de l’intervalle de dimension à utiliser dans la prévision.",
	"@@Predict-Using-Trend_end_tag1@@": "Ce paramètre est obligatoire si le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par intervalle</strong>.",
	"@@Predict-Using-Trend_raster_tag0@@": "Raster de tendance multimensionnel en entrée de la fonction <strong>Générer un raster de tendance</strong>.",
	"@@Predict-Using-Trend_start_tag0@@": "Date de début, hauteur ou profondeur de l’intervalle de dimension à utiliser dans la prévision.",
	"@@Predict-Using-Trend_start_tag1@@": "Ce paramètre est obligatoire si le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par intervalle</strong>.",
	"@@Predict-Using-Trend_unit_tag0@@": "Unité utilisée pour l’intervalle de valeurs. Ce paramètre s’applique uniquement si la dimension de l’analyse est une dimension temporelle.",
	"@@Predict-Using-Trend_unit_tag1@@": "<strong>Heures</strong> : la prévision est calculée pour chaque heure de la plage temporelle définie par les paramètres <strong>Début</strong>, <strong>Fin</strong> et <strong>Intervalle de valeur</strong>.",
	"@@Predict-Using-Trend_unit_tag2@@": "<strong>Jours</strong> : la prévision est calculée pour chaque jour de la plage temporelle définie par les paramètres <strong>Début</strong>, <strong>Fin</strong> et <strong>Intervalle de valeur</strong>.",
	"@@Predict-Using-Trend_unit_tag3@@": "<strong>Semaines</strong> : la prévision est calculée pour chaque semaine de la plage temporelle définie par les paramètres <strong>Début</strong>, <strong>Fin</strong> et <strong>Intervalle de valeur</strong>.",
	"@@Predict-Using-Trend_unit_tag4@@": "<strong>Mois</strong> : la prévision est calculée pour chaque mois de la plage temporelle définie par les paramètres <strong>Début</strong>, <strong>Fin</strong> et <strong>Intervalle de valeur</strong>.",
	"@@Predict-Using-Trend_unit_tag5@@": "<strong>Années</strong> : la prévision est calculée pour chaque année de la plage temporelle définie par les paramètres <strong>Début</strong>, <strong>Fin</strong> et <strong>Intervalle de valeur</strong>.",
	"@@Predict-Using-Trend_valueinterval_tag0@@": "Nombre d’étapes entre deux valeurs de dimension à inclure dans la prévision. La valeur par défaut est 1.",
	"@@Predict-Using-Trend_valueinterval_tag1@@": "Ce paramètre est obligatoire si le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par intervalle</strong>.",
	"@@Predict-Using-Trend_values_tag0@@": "Valeur(s) de dimension à utiliser dans la prévision.",
	"@@Predict-Using-Trend_values_tag1@@": "Le format des valeurs temporelles, de profondeur et de hauteur doit correspondre au format des valeurs de dimension utilisées pour générer le raster de tendance. Si le raster de tendance a été généré pour la dimension StdTime, le format doit être AAAA-MM-JJTHH:MM:SS (par exemple, 2050-01-01T00:00:00). Les valeurs multiples sont séparées par des points-virgules.",
	"@@Process-Raster-Collection_aggregationfunction_tag0@@": "Spécifiez le modèle de fonction raster utilisé pour agréger plusieurs tranches en un nombre de tranches inférieur ou en une seule tranche.",
	"@@Process-Raster-Collection_dimension_tag0@@": "Dimension de l’agrégation. Il s’agit de la dimension le long de laquelle les variables sont agrégées.",
	"@@Process-Raster-Collection_itemfunction_tag0@@": "Spécifiez le modèle de fonction raster utilisé pour traiter chaque tranche ou élément de l’ensemble de rasters en entrée.",
	"@@Process-Raster-Collection_keywordinterval_tag0@@": "Spécifie le mot-clé de l’intervalle à utiliser lors de l’agrégation le long de la dimension. Ce paramètre est obligatoire si le <strong>Type</strong> est défini sur <strong>Mot-clé de l’intervalle</strong>. Dans ce cas, l’agrégation doit se faire dans le temps.",
	"@@Process-Raster-Collection_keywordinterval_tag1@@": "<strong>Par heure</strong> : les valeurs des données sont agrégées selon des intervalles horaires et le résultat comprend chaque heure de la série chronologique.",
	"@@Process-Raster-Collection_keywordinterval_tag2@@": "<strong>Par jour</strong> : les valeurs des données sont agrégées selon des intervalles quotidiens et le résultat comprend chaque jour de la série chronologique.",
	"@@Process-Raster-Collection_keywordinterval_tag3@@": "<strong>Par semaine</strong> : les valeurs des données sont agrégées selon des intervalles hebdomadaires et le résultat comprend chaque semaine de la série chronologique.",
	"@@Process-Raster-Collection_keywordinterval_tag4@@": "<strong>Par dix jours</strong> : les valeurs des données sont agrégées en 3 périodes de 10 jours chacune. La dernière période peut contenir plus ou moins de 10 jours. La sortie comprend 3 tranches pour chaque mois.",
	"@@Process-Raster-Collection_keywordinterval_tag5@@": "<strong>Par cinq jours</strong> : les valeurs des données sont agrégées en 6 périodes de 5 jours chacune. La dernière période peut contenir plus ou moins de 5 jours. La sortie comprend 6 tranches pour chaque mois.",
	"@@Process-Raster-Collection_keywordinterval_tag6@@": "<strong>Par mois</strong> : les valeurs des données sont agrégées selon des intervalles mensuels et le résultat comprend chaque mois de la série chronologique.",
	"@@Process-Raster-Collection_keywordinterval_tag7@@": "<strong>Par trimestre</strong> : les valeurs des données sont agrégées selon des intervalles trimestriels et le résultat comprend chaque trimestre de la série chronologique.",
	"@@Process-Raster-Collection_keywordinterval_tag8@@": "<strong>Par an</strong> : les valeurs des données sont agrégées selon des intervalles annuels et le résultat comprend chaque année de la série chronologique.",
	"@@Process-Raster-Collection_keywordinterval_tag9@@": "<strong>Récurrence quotidienne</strong> : les valeurs des données sont agrégées selon des intervalles quotidiens et le résultat inclut une valeur agrégée par jour du calendrier julien. Le résultat comprend 366 tranches de temps quotidiennes au maximum.",
	"@@Process-Raster-Collection_keywordinterval_tag10@@": "<strong>Récurrence hebdomadaire</strong> : les valeurs des données sont agrégées selon des intervalles hebdomadaires et le résultat inclut une valeur agrégée par semaine. Le résultat comprend 53 tranches de temps hebdomadaires au maximum.",
	"@@Process-Raster-Collection_keywordinterval_tag11@@": "<strong>Récurrence mensuelle</strong> : les valeurs des données sont agrégées selon des intervalles mensuels et le résultat inclut une valeur agrégée par mois. Le résultat comprend 12 tranches de temps mensuelles au maximum.",
	"@@Process-Raster-Collection_keywordinterval_tag12@@": "<strong>Récurrence trimestrielle</strong> : les valeurs des données sont agrégées selon des intervalles trimestriels et le résultat inclut une valeur agrégée par trimestre. Le résultat comprend 4 tranches de temps trimestrielles au maximum.",
	"@@Process-Raster-Collection_maximumvalue_tag0@@": "Valeur maximum d’une plage.",
	"@@Process-Raster-Collection_maximumvalue_tag1@@": "Ce paramètre est obligatoire si le paramètre <strong>Type</strong> est défini sur <strong>Plages d’intervalle</strong>.",
	"@@Process-Raster-Collection_minimumvalue_tag0@@": "Valeur minimum d’une plage.",
	"@@Process-Raster-Collection_minimumvalue_tag1@@": "Ce paramètre est obligatoire si le paramètre <strong>Type</strong> est défini sur <strong>Plages d’intervalle</strong>.",
	"@@Process-Raster-Collection_processingfunction_tag0@@": "Spécifiez le modèle de fonction raster utilisé pour afficher la couche raster traitée.",
	"@@Process-Raster-Collection_rastercollection_tag0@@": "Raster multidimensionnel, couche mosaïque ou jeu de données mosaïque en entrée.",
	"@@Process-Raster-Collection_type_tag0@@": "Spécifie l’intervalle dimensionnel selon lequel les données sont agrégées.",
	"@@Process-Raster-Collection_type_tag1@@": "<strong>Tout</strong> : les valeurs des données sont agrégées sur toutes les tranches. Il s’agit de l’option par défaut.",
	"@@Process-Raster-Collection_type_tag2@@": "<strong>Mot-clé de l’intervalle</strong> : les données des variables sont agrégées à l’aide d’un intervalle courant connu.",
	"@@Process-Raster-Collection_type_tag3@@": "<strong>Plages d’intervalle</strong> : les données des variables sont agrégées entre les paires de valeurs ou de dates spécifiées.",
	"@@Process-Raster-Collection_type_tag4@@": "<strong>Valeurs d’intervalle</strong> : les données des variables sont agrégées à l’aide d’un intervalle et d’une unité définis par l’utilisateur.",
	"@@Process-Raster-Collection_unit_tag0@@": "Unité utilisée pour la valeur de l’intervalle. Ce paramètre est obligatoire si la <strong>Dimension</strong> est un champ temporel et que le paramètre <strong>Type</strong> est défini sur <strong>Valeur de l’intervalle</strong>.",
	"@@Process-Raster-Collection_unit_tag1@@": "Si vous procédez à une agrégation sur une dimension autre que temporelle, cette option n’est pas disponible et l’unité de la valeur de l’intervalle correspond à l’unité de variable des données raster multidimensionnelles en entrée.",
	"@@Process-Raster-Collection_unit_tag2@@": "<strong>Heures</strong> : les valeurs des données sont agrégées par tranches horaires suivant l’intervalle fourni.",
	"@@Process-Raster-Collection_unit_tag3@@": "<strong>Jours</strong> : les valeurs des données sont agrégées par tranches quotidiennes suivant l’intervalle fourni.",
	"@@Process-Raster-Collection_unit_tag4@@": "<strong>Semaines</strong> : les valeurs des données sont agrégées par tranches hebdomadaires suivant l’intervalle fourni.",
	"@@Process-Raster-Collection_unit_tag5@@": "<strong>Mois</strong> : les valeurs des données sont agrégées par tranches mensuelles suivant l’intervalle fourni.",
	"@@Process-Raster-Collection_unit_tag6@@": "<strong>Années</strong> : les valeurs des données sont agrégées par tranches annuelles suivant l’intervalle fourni.",
	"@@Process-Raster-Collection_valueinterval_tag0@@": "Taille de l’intervalle à appliquer à l’agrégation. Ce paramètre est obligatoire si le paramètre <strong>Type</strong> est défini sur <strong>Valeur de l’intervalle</strong>.",
	"@@Process-Raster-Collection_valueinterval_tag1@@": "Par exemple, pour agréger 30 années de données de température mensuelles par incréments de 5 ans, saisissez 5 comme <strong>Valeur de l’intervalle</strong> et définissez <strong>Unité</strong> sur <strong>Années</strong>.",
	"@@Linear-Spectral-Unmixing_non-negative_tag0@@": "Spécifie les options permettant de définir les valeurs de pixels en sortie.",
	"@@Linear-Spectral-Unmixing_non-negative_tag1@@": "Activé : il n’y aura pas de valeurs négatives en sortie.",
	"@@Linear-Spectral-Unmixing_non-negative_tag2@@": "Désactivé : les fractions d’occupation du sol peuvent comporter des valeurs négatives.",
	"@@Linear-Spectral-Unmixing_raster_tag0@@": "Raster en entrée.",
	"@@Linear-Spectral-Unmixing_spectralprofile_tag0@@": "Fichier de profil spectral en entrée.",
	"@@Linear-Spectral-Unmixing_spectralprofiletype_tag0@@": "Informations spectrales pour les différentes classes d’occupation du sol.",
	"@@Linear-Spectral-Unmixing_spectralprofiletype_tag1@@": "<strong>Profil spectral</strong> : un fichier de définition de classificateur (${.ecd}), généré via l’outil <strong><strong>Préparer le classificateur de vraisemblance maximale</strong></strong>, ou un fichier JavaScript Object Notation (${.json}) qui contient les profils spectraux de classe.",
	"@@Linear-Spectral-Unmixing_spectralprofiletype_tag2@@": "<strong>Entités d’entraînement</strong> : des entités surfaciques ou une classe d’entités d’échantillons d’entraînement, générées à partir du <strong>Gestionnaire d’échantillons d’entraînement</strong>.",
	"@@Linear-Spectral-Unmixing_sumtoone_tag0@@": "Spécifie les options permettant de définir les valeurs de pixels en sortie.",
	"@@Linear-Spectral-Unmixing_sumtoone_tag1@@": "Activé : les valeurs de classe pour chaque pixel sont fournies au format décimal, la somme de toutes les classes étant égale à 1. Exemple : Classe1 = 0,16 ; Classe2 = 0,24 ; Classe3 = 0,60.",
	"@@Linear-Spectral-Unmixing_sumtoone_tag2@@": "Désactivé : la somme de toutes les classes d’un pixel peut être supérieure à 1.",
	"@@Linear-Spectral-Unmixing_trainingfeature_tag0@@": "Fichier d’entités d’entraînement en entrée.",
	"@@Aggregate_aggregationtechnique_tag0@@": "Méthode employée pour l’agrégation. Les valeurs des cellules en entrée incluses dans les cellules en sortie les plus grossières sont agrégées selon l’une des statistiques suivantes :",
	"@@Aggregate_aggregationtechnique_tag1@@": "<strong>Somme</strong> : total des cellules en entrée. Il s’agit de l’option par défaut.",
	"@@Aggregate_aggregationtechnique_tag2@@": "<strong>Maximum</strong> : valeur la plus élevée des cellules en entrée.",
	"@@Aggregate_aggregationtechnique_tag3@@": "<strong>Moyenne</strong> : valeur moyenne des cellules en entrée.",
	"@@Aggregate_aggregationtechnique_tag4@@": "<strong>Médiane</strong> : valeur médiane des cellules en entrée.",
	"@@Aggregate_aggregationtechnique_tag5@@": "<strong>Minimum</strong> : valeur la plus faible des cellules en entrée.",
	"@@Aggregate_cellfactor_tag0@@": "Facteur de multiplication de la taille de cellule du raster en entrée.",
	"@@Aggregate_cellfactor_tag1@@": "Par exemple, une valeur de facteur de cellule de trois entraîne une taille de cellule en sortie trois fois supérieure à celle du raster en entrée.",
	"@@Aggregate_expandextentifneeded_tag0@@": "Définit la gestion des limites du raster en entrée si ses lignes ou ses colonnes ne sont pas des multiples du facteur de cellule.",
	"@@Aggregate_expandextentifneeded_tag1@@": "Activé : étend les limites en haut ou à droite du raster en entrée afin que le nombre total de cellules d’une ligne ou d’une colonne soit un multiple du facteur de cellule. Cette option permet au raster en sortie de couvrir une étendue spatiale plus importante que celle du raster en entrée. Il s’agit de l’option par défaut.",
	"@@Aggregate_expandextentifneeded_tag2@@": "Désactivé : réduit le nombre de lignes ou de colonnes dans le raster en sortie. Cette option tronque les cellules restantes sur les limites en haut ou à droite du raster en entrée, ce qui fait du nombre de lignes ou de colonnes du raster en entrée un multiple du facteur de cellule. Cette option permet au raster en sortie de couvrir une étendue spatiale plus réduite que celle du raster en entrée.",
	"@@Aggregate_ignorenodataincalculations_tag0@@": "Indique si les valeurs ${NoData} sont exclues du calcul d’agrégation.",
	"@@Aggregate_ignorenodataincalculations_tag1@@": "Activé : précise que si des valeurs ${NoData} existent pour des cellules incluses dans l’étendue spatiale d’une plus grande cellule dans le raster en sortie, les valeurs ${NoData} sont ignorées lors de la détermination de la valeur des emplacements des cellules en sortie. Seules les cellules en entrée se trouvant dans l’étendue d’une cellule en sortie contenant des valeurs de données sont utilisées pour déterminer la valeur de la cellule en sortie. Il s’agit de l’option par défaut.",
	"@@Aggregate_ignorenodataincalculations_tag2@@": "Désactivé : précise que si une cellule incluse dans l’étendue spatiale d’une cellule plus grande dans le raster en sortie a une valeur ${NoData}, la valeur de l’emplacement de cette cellule en sortie est également ${NoData}. L’utilisation de cette option implique que, lorsque les cellules d’une agrégation contiennent la valeur ${NoData}, il manque des informations pour effectuer les calculs spécifiés nécessaires à la détermination d’une valeur en sortie.",
	"@@Aggregate_raster_tag0@@": "Raster en entrée à agréger.",
	"@@Expand_numberofcells_tag0@@": "Nombre de cellules à utiliser pour développer les zones.",
	"@@Expand_numberofcells_tag1@@": "La valeur doit être un entier et peut être égale ou supérieure à 1.",
	"@@Expand_raster_tag0@@": "Raster en entrée pour lequel les zones identifiées seront développées.",
	"@@Expand_raster_tag1@@": "Il doit être de type entier.",
	"@@Expand_zonevalues_tag0@@": "Liste des zones à développer.",
	"@@Expand_zonevalues_tag1@@": "Les valeurs de zone doivent être des entiers et peuvent être dans n’importe quel ordre.",
	"@@Expand_zonevalues_tag2@@": "Pour préciser plusieurs zones, utilisez un espace pour séparer les valeurs de zone.",
	"@@Multidimensional-Filter_dimension_tag0@@": "Dimension de laquelle les variables doivent être extraites.",
	"@@Multidimensional-Filter_dimensiondefinition_tag0@@": "Précise la méthode utilisée pour découper la dimension en tranches.",
	"@@Multidimensional-Filter_dimensiondefinition_tag1@@": "<strong>Tout</strong> : la plage complète de chaque dimension est utilisée. Il s’agit de l’option par défaut.",
	"@@Multidimensional-Filter_dimensiondefinition_tag2@@": "<strong>Par valeurs</strong> : la dimension est découpée en tranches selon une valeur de dimension ou une liste de valeurs.",
	"@@Multidimensional-Filter_dimensiondefinition_tag3@@": "<strong>Par plages</strong> : la dimension est découpée en tranches selon une plage ou une liste de plages.",
	"@@Multidimensional-Filter_dimensiondefinition_tag4@@": "<strong>Par itération</strong> : la dimension est découpée en tranches selon une taille d’intervalle précisée.",
	"@@Multidimensional-Filter_endoffirstiteration_tag0@@": "Fin du premier intervalle. Cet intervalle est employé pour l’itération au sein du jeu de données. Ce paramètre est obligatoire si le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par itération</strong>.",
	"@@Multidimensional-Filter_maximumvalue_tag0@@": "Valeur maximale de la plage. Ce paramètre est obligatoire si le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par plages</strong>.",
	"@@Multidimensional-Filter_minimumvalue_tag0@@": "Valeur minimale de la plage. Ce paramètre est obligatoire si le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par plages</strong>.",
	"@@Multidimensional-Filter_raster_tag0@@": "Raster multidimensionnel en entrée.",
	"@@Multidimensional-Filter_ranges_tag0@@": "<p>Plages d’intervalle spécifiées dans une table, utilisées pour agréger des groupes de valeurs. Les valeurs minimales et maximales déterminent la plage à inclure.</p><p>Ce paramètre est requis lorsque le paramètre <strong>Type</strong> est défini sur <strong>Plages d’intervalle</strong>.</p>",
	"@@Multidimensional-Filter_startoffirstiteration_tag0@@": "Début du premier intervalle. Cet intervalle est employé pour l’itération au sein du jeu de données. Ce paramètre est obligatoire si le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par itération</strong>.",
	"@@Multidimensional-Filter_step_tag0@@": "Fréquence à laquelle les données sont découpées en tranches. Ce paramètre est obligatoire si le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par itération</strong>. La valeur par défaut est 3.",
	"@@Multidimensional-Filter_unit_tag0@@": "Spécifie l’unité de l’itération. Ce paramètre est obligatoire si le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par itération</strong> et que le paramètre <strong>Dimension</strong> est défini sur <strong>StdTime</strong>.",
	"@@Multidimensional-Filter_value_tag0@@": "Valeur de la dimension spécifiée. Ce paramètre est obligatoire si le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par valeurs</strong>.",
	"@@Multidimensional-Filter_variables_tag0@@": "Variables incluses dans la couche raster multidimensionnelle en sortie. Si aucune variable n’est spécifiée, la première variable est utilisée.",
	"@@Multidimensional-Filter_dimensionless_tag0@@": "Spécifie si la couche possède des valeurs de dimension. Cette option est disponible seulement si une seule tranche est sélectionnée pour la création d’une couche.",
	"@@Multidimensional-Filter_dimensionless_tag1@@": "Activé : la couche ne contient pas de valeurs de dimension.",
	"@@Multidimensional-Filter_dimensionless_tag2@@": "Désactivé : la couche contient des valeurs de dimension. Il s’agit de l’option par défaut.",
	"@@Multidimensional-Raster_interpolationcellsize_tag0@@": "Taille de cellule du raster interpolé. La valeur par défaut est ${1}.",
	"@@Multidimensional-Raster_interpolationmethod_tag0@@": "Méthode de rééchantillonnage utilisée pour interpoler les données irrégulières.",
	"@@Multidimensional-Raster_interpolationmethod_tag1@@": "<strong>Voisin le plus proche</strong> : calcule la valeur du pixel en sortie grâce au pixel en entrée le plus proche. Si aucun pixel source n’existe, aucun nouveau pixel ne peut être créé dans la sortie. Il s’agit de l’option par défaut.",
	"@@Multidimensional-Raster_interpolationmethod_tag2@@": "<strong>TIN linéaire</strong> : utilise un réseau triangulé irrégulier (TIN) à partir du point central de chaque pixel du raster irrégulier pour interpoler une surface qui sera ensuite convertie en raster régulier.",
	"@@Multidimensional-Raster_interpolationmethod_tag3@@": "<strong>Voisin naturel</strong> : recherche le sous-ensemble d’échantillons en entrée le plus proche d’un point de requête et lui applique une pondération sur la base de surfaces proportionnelles afin d’interpoler une valeur.",
	"@@Multidimensional-Raster_interpolationmethod_tag4@@": "<strong>Pondération par l’inverse de la distance</strong> : détermine les valeurs des pixels via la combinaison pondérée de manière linéaire d’un ensemble de points d’échantillonnage ou de pixels. La pondération est une fonction de l’inverse de la distance à partir des pixels ou des points connus.",
	"@@Multidimensional-Raster_raster_tag0@@": "Raster multidimensionnel en entrée.",
	"@@Multidimensional-Raster_variables_tag0@@": "Variable(s) à inclure dans la couche raster multidimensionnelle.",
	"@@Random_distribution_tag0@@": "Indiquez la méthode de distribution de valeurs aléatoires à utiliser.",
	"@@Random_distribution_tag1@@": "<strong>Uniforme</strong> (Minimum, Maximum) : distribution uniforme avec une plage définie. Les valeurs par défaut sont 0 pour Minimum et 1 pour Maximum. Il s’agit de l’option par défaut.",
	"@@Random_distribution_tag2@@": "<strong>Entiers</strong> (Minimum, Maximum) : distribution d’entiers avec une plage définie. Les valeurs par défaut sont 1 pour Minimum et 10 pour Maximum.",
	"@@Random_distribution_tag3@@": "<strong>Normale</strong> (Moyenne, Écart type) : distribution normale avec définition des valeurs Moyenne et Écart type. Les valeurs par défaut sont 0 pour Moyenne et 1 pour Écart type.",
	"@@Random_distribution_tag4@@": "<strong>Exponentielle</strong> (Moyenne) : distribution exponentielle avec définition de la valeur Moyenne. La valeur par défaut est 1.",
	"@@Random_distribution_tag5@@": "<strong>Poisson</strong> (Moyenne) : distribution Poisson avec définition de la valeur Moyenne. La valeur par défaut est 1.",
	"@@Random_distribution_tag6@@": "<strong>Gamma</strong> (Alpha, Bêta) : distribution gamma avec définition des valeurs Alpha et Bêta. Les valeurs par défaut sont 1 pour Alpha et 1 pour Bêta.",
	"@@Random_distribution_tag7@@": "<strong>Binomiale</strong> (N, Probabilité) : distribution binomiale avec définition des valeurs N et Probabilité. Les valeurs par défaut sont 10 pour N et 0,5 pour Probabilité.",
	"@@Random_distribution_tag8@@": "<strong>Géométrique</strong> (Probabilité) : distribution géométrique avec définition de la valeur Probabilité. La valeur par défaut est 0,5.",
	"@@Random_distribution_tag9@@": "<strong>Binomiale négative</strong> (r, Probabilité) : distribution Pascal avec définition des valeurs r et Probabilité. Les valeurs par défaut sont 10,0 pour r et 0,5 pour Probabilité.",
	"@@Random_randomnumbergenerator_tag0@@": "Spécifiez l’algorithme du générateur de nombres aléatoires qui utilise la valeur initiale et la distribution pour générer une séquence de nombres aléatoires. Les options disponibles sont les suivantes :",
	"@@Random_randomnumbergenerator_tag1@@": "Standard C Rand",
	"@@Random_randomnumbergenerator_tag2@@": "Algorithme de collecte ACM 599",
	"@@Random_randomnumbergenerator_tag3@@": "Mersenne Twister",
	"@@Random_randomnumbergenerator_tag4@@": "La valeur par défaut est Mersenne Twister.",
	"@@Random_rasterinfo_tag0@@": "Utilisez le bouton <strong>Charger le raster modèle</strong> pour charger un modèle à partir d’un répertoire ou d’un portail.",
	"@@Random_seed_tag0@@": "La valeur initiale est une valeur entière utilisée pour initialiser le générateur de nombres aléatoires. La valeur par défaut est 1.",
	"@@Shrink_numberofcells_tag0@@": "Nombre de cellules à utiliser pour réduire chaque zone spécifiée.",
	"@@Shrink_numberofcells_tag1@@": "La valeur doit être un entier et peut être égale ou supérieure à 1.",
	"@@Shrink_raster_tag0@@": "Raster en entrée pour lequel les zones identifiées seront réduites.",
	"@@Shrink_raster_tag1@@": "Il doit être de type entier.",
	"@@Shrink_zonevalues_tag0@@": "Liste des zones à réduire.",
	"@@Shrink_zonevalues_tag1@@": "Les valeurs de zone doivent être des entiers et peuvent être dans n’importe quel ordre.",
	"@@Shrink_zonevalues_tag2@@": "Pour préciser plusieurs zones, utilisez un espace pour séparer les valeurs de zone.",
	"@@Distance-Accumulation_costraster_tag0@@": "Raster définissant le coût ou l’impédance de déplacement planimétrique à travers chaque cellule. La valeur à chaque emplacement de cellule représente le coût par unité de distance pour le déplacement à travers la cellule. Chaque valeur d’emplacement de cellule est multipliée par la résolution de cellule et compense également le déplacement diagonal afin d’obtenir le coût total du passage à travers la cellule.",
	"@@Distance-Accumulation_costraster_tag1@@": "Les valeurs du <strong>Raster de coût</strong> peuvent être des entiers ou des nombres à virgule flottante, mais elles ne peuvent pas être négatives ni nulles.",
	"@@Distance-Accumulation_distancemethod_tag0@@": "Détermine si la distance doit être calculée avec une méthode plane (Terre plate) ou géodésique (ellipsoïde).",
	"@@Distance-Accumulation_distancemethod_tag1@@": "Plane : les mesures planes utilisent des mathématiques cartésiennes en 2D pour calculer la longueur et la surface. Cette option est uniquement disponible lorsque les mesures sont effectuées dans un système de coordonnées projetées. Le plan 2D de ce système de coordonnées est alors utilisé comme base des mesures.",
	"@@Distance-Accumulation_distancemethod_tag2@@": "Géodésique : ligne la plus courte entre deux points de la surface de la Terre sur un sphéroïde (ellipsoïde). Les résultats ne changent donc pas quelle que soit la projection en entrée ou en sortie.",
	"@@Distance-Accumulation_distancemethod_tag3@@": "<strong>Remarque :</strong> vous pouvez utiliser une ligne géodésique si vous souhaitez déterminer la distance la plus courte entre deux villes pour la trajectoire de vol d’un avion. On parle également de « ligne orthodromique » si elle repose sur une sphère plutôt que sur un ellipsoïde.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag0@@": "Détermine si seul le raster d’accumulation de distance est créé ou si un raster multibande constitué à la fois du raster d’accumulation de distance et du raster de direction arrière est créé.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag1@@": "Désactivé : le résultat est le raster d’accumulation de distance. Il s’agit d’un résultat à une seule bande. Il s’agit de l’option par défaut.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag2@@": "Activé : un résultat multibande est créé. La première bande correspond au raster d’accumulation de distance et la deuxième, au raster de direction arrière.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag3@@": "Le raster de direction arrière calcule pour chaque cellule la direction, en degrés, vers la cellule voisine sur le chemin le plus court en revenant vers la cellule source la plus proche, en évitant toute interruption.",
	"@@Distance-Accumulation_horizontalfactor_tag0@@": "<p>Définit la relation entre le facteur de coût horizontal et l’angle de déplacement relatif horizontal (HRMA).</p><p>Plusieurs facteurs, avec modificateurs, identifient un diagramme de facteurs verticaux défini. En outre, vous pouvez utiliser une table pour créer un diagramme personnalisé. Les diagrammes permettent d’identifier le facteur vertical utilisé pour le calcul du coût total d’un déplacement vers une cellule voisine.</p><p>Dans les explications ci-dessous, deux acronymes sont utilisés : HF et HRMA. Le facteur HF correspond au facteur horizontal qui représente la difficulté horizontale rencontrée lors d’un déplacement d’une cellule vers la suivante. L’angle HRMA correspond à l’angle de déplacement relatif horizontal, lequel représente l’angle entre la direction horizontale d’une cellule et la direction du déplacement.</p><p>Les types de <strong>Facteur horizontal</strong> sont les suivants :</p><ul><li><strong>Binaire</strong> : indique que si l’angle HRMA est inférieur à l’angle d’inflexion, le facteur HF a la valeur associée au facteur zéro. Dans le cas contraire, le facteur horizontal a une valeur infinie.</li><li><strong>Avant</strong> : précise que seul un mouvement vers l’avant est autorisé. L’angle HRMA doit être supérieur ou égal à 0 et inférieur à 90 degrés (0 &lt;= HRMA &lt; 90). Si l’angle HRMA est compris entre 0 et 45 degrés, le facteur HF de la cellule a la valeur associée au facteur zéro. Si l’angle HRMA est supérieur ou égal à 45 degrés, la valeur du modificateur de la valeur de bord est utilisée. Le facteur HF pour un angle HRMA égal ou supérieur à 90 degrés a une valeur infinie.</li><li><strong>Linéaire</strong> : spécifie que le facteur HF est une fonction linéaire de l’angle HRMA.</li><li><strong>Linéaire inverse</strong> : spécifie que le facteur HF est une fonction linéaire inverse de l’angle HRMA.</li><li><strong>Table</strong> : indique qu’un fichier de table sera utilisé pour définir le diagramme des facteurs horizontaux permettant de déterminer les facteurs HF.</li></ul><p>Les modificateurs des facteurs horizontaux sont les suivants :</p><ul><li><strong>Facteur zéro</strong> : définit le facteur horizontal à utiliser lorsque l’angle HRMA est nul. Ce facteur positionne l’intersection avec l’axe des y de toutes les fonctions de facteur horizontal.</li><li><strong>Angle d’inflexion</strong> : définit l’angle HRMA au-delà duquel le facteur HF a une valeur infinie.</li><li><strong>Pente</strong> : définit la pente de la ligne droite utilisée avec les mots-clés de facteur horizontal <strong>Linéaire</strong> et <strong>Linéaire inverse</strong>. La pente est spécifiée sous forme d’un rapport de la hauteur sur la distance parcourue (par exemple, une pente de 45 pour cent correspond à 1/45, la valeur introduite étant 0,02222).</li><li><strong>Valeur de bord</strong> : définit le facteur HF lorsque l’angle HRMA est supérieur ou égal à 45 degrés et inférieur à 90 degrés lorsque le mot-clé de facteur horizontal <strong>Avant</strong> est spécifié.</li><li><strong>Nom de la table</strong> : correspond au nom de la table définissant le facteur HF.</li></ul>",
	"@@Distance-Accumulation_horizontalraster_tag0@@": "Raster définissant la direction horizontale pour chaque cellule.",
	"@@Distance-Accumulation_horizontalraster_tag1@@": "Les valeurs du raster doivent être des entiers compris entre 0 et 360, 0 degré correspondant au nord (vers le haut de l’écran). Elles augmentent dans le sens horaire. La valeur -1 doit être attribuée aux surfaces planes. Les valeurs à chaque emplacement seront utilisées conjointement au <strong>Facteur horizontal</strong> afin de déterminer le coût horizontal encouru lors d’un déplacement à partir d’une cellule vers les cellules voisines.",
	"@@Distance-Accumulation_initialaccumulation_tag0@@": "Coût cumulé initial pour commencer le calcul de coût. Ce paramètre permet de spécifier le coût fixe associé à une source. Plutôt que de commencer avec un coût égal à 0, l’algorithme de coût commence avec la valeur définie.",
	"@@Distance-Accumulation_initialaccumulation_tag1@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Distance-Accumulation_initialaccumulation_tag2@@": "La valeur doit être égale ou supérieure à zéro. La valeur par défaut est 0.",
	"@@Distance-Accumulation_maximumaccumulation_tag0@@": "Définit le coût cumulé maximal pour le voyageur pour une source. Les calculs de coût continuent pour chaque source jusqu’à ce que la capacité spécifiée soit atteinte.",
	"@@Distance-Accumulation_maximumaccumulation_tag1@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Distance-Accumulation_maximumaccumulation_tag2@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le segment du raster en sortie.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag0@@": "Multiplicateur à appliquer aux valeurs de coût.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag1@@": "Ce paramètre permet de contrôler le mode de déplacement ou la magnitude à une source. Plus le multiplicateur est élevé, plus le coût de déplacement d’une cellule à une autre est important.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag2@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag3@@": "Les valeurs doivent être supérieures à zéro. La valeur par défaut est 1.",
	"@@Distance-Accumulation_rasterbarriers_tag0@@": "Raster qui définit les interruptions.",
	"@@Distance-Accumulation_rasterbarriers_tag1@@": "Le jeu de données doit contenir une valeur NoData lorsqu’il n’y a pas d’interruption. Les interruptions sont représentées par des valeurs valides, y compris zéro.",
	"@@Distance-Accumulation_rasterbarriers_tag2@@": "Les interruptions peuvent être définies par un raster de type entier ou à virgule flottante.",
	"@@Distance-Accumulation_sourceraster_tag0@@": "Emplacement des sources en entrée.",
	"@@Distance-Accumulation_sourceraster_tag1@@": "Jeu de données raster qui identifie les cellules ou les emplacements depuis ou vers lesquels la distance de moindre coût cumulé est calculée pour chaque emplacement de cellule en sortie.",
	"@@Distance-Accumulation_sourceraster_tag2@@": "Il peut s’agir d’un raster de type entier ou à virgule flottante.",
	"@@Distance-Accumulation_surfaceraster_tag0@@": "Raster définissant les valeurs d’élévation à chaque emplacement de cellule.",
	"@@Distance-Accumulation_surfaceraster_tag1@@": "Ces valeurs permettent de calculer la distance de surface réelle qui est couverte lors du passage d’une cellule à une autre.",
	"@@Distance-Accumulation_traveldirection_tag0@@": "Définit le sens du voyageur en cas d’application du facteur vertical, du facteur horizontal et du taux de résistance source.",
	"@@Distance-Accumulation_traveldirection_tag1@@": "<strong>À partir de la source</strong> : le facteur vertical, le facteur horizontal et le taux de résistance source sont appliqués à partir de la source en entrée et en se déplaçant vers les cellules non sources. Il s’agit de l’option par défaut.",
	"@@Distance-Accumulation_traveldirection_tag2@@": "<strong>Vers la source</strong> : le facteur vertical, le facteur horizontal et le taux de résistance source sont appliqués à partir de chaque cellule non source et lors du retour à la source en entrée.",
	"@@Distance-Accumulation_traveldirection_tag3@@": "Spécifiez le mot-clé <strong>À partir de la source</strong> ou <strong>Vers la source</strong>, qui est appliqué à toutes les sources, ou spécifiez un champ dans le <strong>Raster source</strong> qui contient les mots-clés permettant d’identifier le sens de déplacement pour chaque source. Ce champ doit contenir la chaîne ${FROM_SOURCE} ou ${TO_SOURCE}.",
	"@@Distance-Accumulation_verticalfactor_tag0@@": "<p>Définit la relation entre le facteur de coût vertical et l’angle de déplacement relatif vertical (VRMA).</p><p>Plusieurs facteurs, avec modificateurs, identifient un diagramme de facteurs verticaux défini. En outre, vous pouvez utiliser une table pour créer un diagramme personnalisé. Les diagrammes permettent d’identifier le facteur vertical utilisé pour le calcul du coût total d’un déplacement vers une cellule voisine.</p><p>Dans les explications ci-dessous, deux acronymes sont utilisés : VF et VRMA. Le facteur VF correspond au facteur vertical, lequel représente la difficulté verticale rencontrée lors d’un déplacement d’une cellule vers la suivante. L’angle VRMA correspond à l’angle de déplacement relatif vertical, lequel représente l’angle de la pente entre la cellule FROM (Origine), ou de traitement, et la cellule TO (Destination).</p><p>Les types de <strong>Facteur vertical</strong> sont les suivants :</p><ul><li><strong>Binaire</strong> : spécifie que si l’angle VRMA est supérieur à l’angle d’inflexion inférieur et inférieur à l’angle d’inflexion supérieur, le facteur VF doit correspondre à la valeur associée au facteur zéro. Dans le cas contraire, le facteur vertical a une valeur infinie.</li><li><strong>Linéaire</strong> : indique que le facteur VF est une fonction linéaire de l’angle VRMA.</li><li><strong>Linéaire symétrique</strong> : spécifie que le facteur VF est une fonction linéaire de l’angle VRMA, du côté négatif ou du côté positif de l’angle VRMA, respectivement, et que les deux fonctions linéaires sont symétriques par rapport à l’axe (y) du facteur VF.</li><li><strong>Linéaire inverse</strong> : indique que le facteur VF est une fonction linéaire inverse de l’angle VRMA.</li><li><strong>Linéaire inverse symétrique</strong> : spécifie que le facteur VF est une fonction linéaire inverse de l’angle VRMA, du côté négatif ou du côté positif de l’angle VRMA, respectivement, et que les deux fonctions linéaires sont symétriques par rapport à l’axe (y) du facteur VF.</li><li><strong>Cos</strong> : identifie le facteur VF comme une fonction cosinusoïdale de l’angle VRMA.</li><li><strong>Sec</strong> : identifie le facteur VF comme une fonction sécante de l’angle VRMA.</li><li><strong>Cos-Sec</strong> : spécifie que le facteur VF est une fonction cosinusoïdale de l’angle VRMA lorsque ce dernier est négatif et qu’il est une fonction sécante de l’angle VRMA lorsque ce dernier n’est pas négatif.</li><li><strong>Sec-Cos</strong> : spécifie que le facteur VF est une fonction sécante de l’angle VRMA lorsque ce dernier est négatif et qu’il est une fonction cosinusoïdale de l’angle VRMA lorsque ce dernier n’est pas négatif.</li><li><strong>Table</strong> : indique qu’un fichier de table sera utilisé pour définir le diagramme des facteurs verticaux permettant de déterminer les facteurs VF.</li></ul><p>Les modificateurs des mots-clés de facteur vertical sont les suivants :</p><ul><li><strong>Facteur zéro</strong> : définit le facteur vertical utilisé lorsque l’angle VRMA est nul. Ce facteur positionne l’intersection avec l’axe des y de la fonction spécifiée. Par définition, le facteur zéro ne s’applique à aucune fonction verticale trigonométrique (COS, SEC, COS-SEC ou SEC-COS). Ces fonctions définissent l’interception de l’axe des y.</li><li><strong>Angle d’inflexion inférieur</strong> : définit l’angle VRMA en dessous duquel le facteur VF a une valeur infinie.</li><li><strong>Angle d’inflexion supérieur</strong> : définit l’angle VRMA au-dessus duquel le facteur VF a une valeur infinie.</li><li><strong>Pente</strong> : définit la pente de la ligne droite utilisée avec les mots-clés de facteur vertical <strong>Linéaire</strong> et <strong>Linéaire inverse</strong>. La pente est spécifiée sous forme d’un rapport de la hauteur sur la distance parcourue (par exemple, une pente de 45 pour cent correspond à 1/45, la valeur introduite étant 0,02222).</li><li><strong>Nom de la table</strong> : correspond au nom de la table définissant le facteur VF.</li></ul>",
	"@@Distance-Accumulation_verticalraster_tag0@@": "Définit la relation entre le facteur de coût vertical et l’angle de déplacement relatif vertical (VRMA).",
	"@@Distance-Accumulation_verticalraster_tag1@@": "Ces valeurs permettent de calculer la pente utilisée pour identifier le facteur vertical associé au déplacement d’une cellule à une autre.",
	"@@Distance-Allocation_costraster_tag0@@": "Raster définissant le coût ou l’impédance de déplacement planimétrique à travers chaque cellule. La valeur à chaque emplacement de cellule représente le coût par unité de distance pour le déplacement à travers la cellule. Chaque valeur d’emplacement de cellule est multipliée par la résolution de cellule et compense également le déplacement diagonal afin d’obtenir le coût total du passage à travers la cellule.",
	"@@Distance-Allocation_costraster_tag1@@": "Les valeurs du <strong>Raster de coût</strong> peuvent être des entiers ou des nombres à virgule flottante, mais elles ne peuvent pas être négatives ni nulles.",
	"@@Distance-Allocation_distancemethod_tag0@@": "Détermine si la distance doit être calculée avec une méthode plane (Terre plate) ou géodésique (ellipsoïde).",
	"@@Distance-Allocation_distancemethod_tag1@@": "Plane : les mesures planes utilisent des mathématiques cartésiennes en 2D pour calculer la longueur et la surface. Cette option est uniquement disponible lorsque les mesures sont effectuées dans un système de coordonnées projetées. Le plan 2D de ce système de coordonnées est alors utilisé comme base des mesures.",
	"@@Distance-Allocation_distancemethod_tag2@@": "Géodésique : ligne la plus courte entre deux points de la surface de la Terre sur un sphéroïde (ellipsoïde). Les résultats ne changent donc pas quelle que soit la projection en entrée ou en sortie.",
	"@@Distance-Allocation_distancemethod_tag3@@": "<strong>Remarque :</strong> vous pouvez utiliser une ligne géodésique si vous souhaitez déterminer la distance la plus courte entre deux villes pour la trajectoire de vol d’un avion. On parle également de « ligne orthodromique » si elle repose sur une sphère plutôt que sur un ellipsoïde.",
	"@@Distance-Allocation_horizontalfactor_tag0@@": "<p>Définit la relation entre le facteur de coût horizontal et l’angle de déplacement relatif horizontal (HRMA).</p><p>Plusieurs facteurs, avec modificateurs, identifient un diagramme de facteurs verticaux défini. En outre, vous pouvez utiliser une table pour créer un diagramme personnalisé. Les diagrammes permettent d’identifier le facteur vertical utilisé pour le calcul du coût total d’un déplacement vers une cellule voisine.</p><p>Dans les explications ci-dessous, deux acronymes sont utilisés : HF et HRMA. Le facteur HF correspond au facteur horizontal qui représente la difficulté horizontale rencontrée lors d’un déplacement d’une cellule vers la suivante. L’angle HRMA correspond à l’angle de déplacement relatif horizontal, lequel représente l’angle entre la direction horizontale d’une cellule et la direction du déplacement.</p><p>Les types de <strong>Facteur horizontal</strong> sont les suivants :</p><ul><li><strong>Binaire</strong> : indique que si l’angle HRMA est inférieur à l’angle d’inflexion, le facteur HF a la valeur associée au facteur zéro. Dans le cas contraire, le facteur horizontal a une valeur infinie.</li><li><strong>Avant</strong> : précise que seul un mouvement vers l’avant est autorisé. L’angle HRMA doit être supérieur ou égal à 0 et inférieur à 90 degrés (0 &lt;= HRMA &lt; 90). Si l’angle HRMA est compris entre 0 et 45 degrés, le facteur HF de la cellule a la valeur associée au facteur zéro. Si l’angle HRMA est supérieur ou égal à 45 degrés, la valeur du modificateur de la valeur de bord est utilisée. Le facteur HF pour un angle HRMA égal ou supérieur à 90 degrés a une valeur infinie.</li><li><strong>Linéaire</strong> : spécifie que le facteur HF est une fonction linéaire de l’angle HRMA.</li><li><strong>Linéaire inverse</strong> : spécifie que le facteur HF est une fonction linéaire inverse de l’angle HRMA.</li><li><strong>Table</strong> : indique qu’un fichier de table sera utilisé pour définir le diagramme des facteurs horizontaux permettant de déterminer les facteurs HF.</li></ul><p>Les modificateurs des facteurs horizontaux sont les suivants :</p><ul><li><strong>Facteur zéro</strong> : définit le facteur horizontal à utiliser lorsque l’angle HRMA est nul. Ce facteur positionne l’intersection avec l’axe des y de toutes les fonctions de facteur horizontal.</li><li><strong>Angle d’inflexion</strong> : définit l’angle HRMA au-delà duquel le facteur HF a une valeur infinie.</li><li><strong>Pente</strong> : définit la pente de la ligne droite utilisée avec les mots-clés de facteur horizontal <strong>Linéaire</strong> et <strong>Linéaire inverse</strong>. La pente est spécifiée sous forme d’un rapport de la hauteur sur la distance parcourue (par exemple, une pente de 45 pour cent correspond à 1/45, la valeur introduite étant 0,02222).</li><li><strong>Valeur de bord</strong> : définit le facteur HF lorsque l’angle HRMA est supérieur ou égal à 45 degrés et inférieur à 90 degrés lorsque le mot-clé de facteur horizontal <strong>Avant</strong> est spécifié.</li><li><strong>Nom de la table</strong> : correspond au nom de la table définissant le facteur HF.</li></ul>",
	"@@Distance-Allocation_horizontalraster_tag0@@": "Raster définissant la direction horizontale pour chaque cellule.",
	"@@Distance-Allocation_horizontalraster_tag1@@": "Les valeurs du raster doivent être des entiers compris entre 0 et 360, 0 degré correspondant au nord (vers le haut de l’écran). Elles augmentent dans le sens horaire. La valeur -1 doit être attribuée aux surfaces planes. Les valeurs à chaque emplacement seront utilisées conjointement au <strong>Facteur horizontal</strong> afin de déterminer le coût horizontal encouru lors d’un déplacement à partir d’une cellule vers les cellules voisines.",
	"@@Distance-Allocation_initialaccumulation_tag0@@": "Coût cumulé initial pour commencer le calcul de coût. Ce paramètre permet de spécifier le coût fixe associé à une source. Plutôt que de commencer avec un coût égal à 0, l’algorithme de coût commence avec la valeur définie.",
	"@@Distance-Allocation_initialaccumulation_tag1@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Distance-Allocation_initialaccumulation_tag2@@": "La valeur doit être égale ou supérieure à zéro. La valeur par défaut est 0.",
	"@@Distance-Allocation_maximumaccumulation_tag0@@": "Définit le coût cumulé maximal pour le voyageur pour une source. Les calculs de coût continuent pour chaque source jusqu’à ce que la capacité spécifiée soit atteinte.",
	"@@Distance-Allocation_maximumaccumulation_tag1@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Distance-Allocation_maximumaccumulation_tag2@@": "La valeur doit être supérieure à zéro. La capacité par défaut est limitée par le segment du raster en sortie.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag0@@": "Multiplicateur à appliquer aux valeurs de coût.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag1@@": "Ce paramètre permet de contrôler le mode de déplacement ou la magnitude à une source. Plus le multiplicateur est élevé, plus le coût de déplacement d’une cellule à une autre est important.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag2@@": "Les valeurs doivent être supérieures à zéro. La valeur par défaut est 1.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag3@@": "Vous pouvez utiliser pour ce paramètre une valeur numérique (double) ou un champ du <strong>Raster source</strong>.",
	"@@Distance-Allocation_rasterbarriers_tag0@@": "Raster qui définit les interruptions.",
	"@@Distance-Allocation_rasterbarriers_tag1@@": "Le jeu de données doit contenir une valeur NoData lorsqu’il n’y a pas d’interruption. Les interruptions sont représentées par des valeurs valides, y compris zéro.",
	"@@Distance-Allocation_rasterbarriers_tag2@@": "Les interruptions peuvent être définies par un raster de type entier ou à virgule flottante.",
	"@@Distance-Allocation_sourcefield_tag0@@": "Champ permettant d’attribuer des valeurs aux emplacements sources. Il doit être de type entier.",
	"@@Distance-Allocation_sourceraster_tag0@@": "Emplacement des sources en entrée.",
	"@@Distance-Allocation_sourceraster_tag1@@": "Jeu de données raster qui identifie les cellules ou les emplacements depuis ou vers lesquels la distance de moindre coût cumulé est calculée pour chaque emplacement de cellule en sortie.",
	"@@Distance-Allocation_sourcerowandcolumnbands_tag0@@": "Détermine si seul le raster d’allocation est créé ou si un raster multibande est également créé.",
	"@@Distance-Allocation_sourcerowandcolumnbands_tag1@@": "Désactivé : le résultat est le raster d’allocation de distance. Il s’agit d’un résultat à une seule bande. Il s’agit de l’option par défaut.",
	"@@Distance-Allocation_sourcerowandcolumnbands_tag2@@": "Activé : un raster multibande est créé. La première bande est le raster d’allocation de distance, la seconde contient un index de lignes, et la troisième bande contient un index de colonnes. Ces index identifient l’emplacement de la cellule source qui se trouve à la distance de plus faible coût cumulé.",
	"@@Distance-Allocation_surfaceraster_tag0@@": "Raster définissant les valeurs d’élévation à chaque emplacement de cellule.",
	"@@Distance-Allocation_surfaceraster_tag1@@": "Ces valeurs permettent de calculer la distance de surface réelle qui est couverte lors du passage d’une cellule à une autre.",
	"@@Distance-Allocation_traveldirection_tag0@@": "Définit le sens du voyageur en cas d’application du facteur vertical, du facteur horizontal et du taux de résistance source.",
	"@@Distance-Allocation_traveldirection_tag1@@": "<strong>À partir de la source</strong> : le facteur vertical, le facteur horizontal et le taux de résistance source sont appliqués à partir de la source en entrée et en se déplaçant vers les cellules non sources. Il s’agit de l’option par défaut.",
	"@@Distance-Allocation_traveldirection_tag2@@": "<strong>Vers la source</strong> : le facteur vertical, le facteur horizontal et le taux de résistance source sont appliqués à partir de chaque cellule non source et lors du retour à la source en entrée.",
	"@@Distance-Allocation_traveldirection_tag3@@": "Spécifiez le mot-clé <strong>À partir de la source</strong> ou <strong>Vers la source</strong>, qui est appliqué à toutes les sources, ou spécifiez un champ dans le <strong>Raster source</strong> qui contient les mots-clés permettant d’identifier le sens de déplacement pour chaque source. Ce champ doit contenir la chaîne ${FROM_SOURCE} ou ${TO_SOURCE}.",
	"@@Distance-Allocation_verticalfactor_tag0@@": "<p>Définit la relation entre le facteur de coût vertical et l’angle de déplacement relatif vertical (VRMA).</p><p>Plusieurs facteurs, avec modificateurs, identifient un diagramme de facteurs verticaux défini. En outre, vous pouvez utiliser une table pour créer un diagramme personnalisé. Les diagrammes permettent d’identifier le facteur vertical utilisé pour le calcul du coût total d’un déplacement vers une cellule voisine.</p><p>Dans les explications ci-dessous, deux acronymes sont utilisés : VF et VRMA. Le facteur VF correspond au facteur vertical, lequel représente la difficulté verticale rencontrée lors d’un déplacement d’une cellule vers la suivante. L’angle VRMA correspond à l’angle de déplacement relatif vertical, lequel représente l’angle de la pente entre la cellule FROM (Origine), ou de traitement, et la cellule TO (Destination).</p><p>Les types de <strong>Facteur vertical</strong> sont les suivants :</p><ul><li><strong>Binaire</strong> : spécifie que si l’angle VRMA est supérieur à l’angle d’inflexion inférieur et inférieur à l’angle d’inflexion supérieur, le facteur VF doit correspondre à la valeur associée au facteur zéro. Dans le cas contraire, le facteur vertical a une valeur infinie.</li><li><strong>Linéaire</strong> : indique que le facteur VF est une fonction linéaire de l’angle VRMA.</li><li><strong>Linéaire symétrique</strong> : spécifie que le facteur VF est une fonction linéaire de l’angle VRMA, du côté négatif ou du côté positif de l’angle VRMA, respectivement, et que les deux fonctions linéaires sont symétriques par rapport à l’axe (y) du facteur VF.</li><li><strong>Linéaire inverse</strong> : indique que le facteur VF est une fonction linéaire inverse de l’angle VRMA.</li><li><strong>Linéaire inverse symétrique</strong> : spécifie que le facteur VF est une fonction linéaire inverse de l’angle VRMA, du côté négatif ou du côté positif de l’angle VRMA, respectivement, et que les deux fonctions linéaires sont symétriques par rapport à l’axe (y) du facteur VF.</li><li><strong>Cos</strong> : identifie le facteur VF comme une fonction cosinusoïdale de l’angle VRMA.</li><li><strong>Sec</strong> : identifie le facteur VF comme une fonction sécante de l’angle VRMA.</li><li><strong>Cos-Sec</strong> : spécifie que le facteur VF est une fonction cosinusoïdale de l’angle VRMA lorsque ce dernier est négatif et qu’il est une fonction sécante de l’angle VRMA lorsque ce dernier n’est pas négatif.</li><li><strong>Sec-Cos</strong> : spécifie que le facteur VF est une fonction sécante de l’angle VRMA lorsque ce dernier est négatif et qu’il est une fonction cosinusoïdale de l’angle VRMA lorsque ce dernier n’est pas négatif.</li><li><strong>Table</strong> : indique qu’un fichier de table sera utilisé pour définir le diagramme des facteurs verticaux permettant de déterminer les facteurs VF.</li></ul><p>Les modificateurs des mots-clés de facteur vertical sont les suivants :</p><ul><li><strong>Facteur zéro</strong> : définit le facteur vertical utilisé lorsque l’angle VRMA est nul. Ce facteur positionne l’intersection avec l’axe des y de la fonction spécifiée. Par définition, le facteur zéro ne s’applique à aucune fonction verticale trigonométrique (COS, SEC, COS-SEC ou SEC-COS). Ces fonctions définissent l’interception de l’axe des y.</li><li><strong>Angle d’inflexion inférieur</strong> : définit l’angle VRMA en dessous duquel le facteur VF a une valeur infinie.</li><li><strong>Angle d’inflexion supérieur</strong> : définit l’angle VRMA au-dessus duquel le facteur VF a une valeur infinie.</li><li><strong>Pente</strong> : définit la pente de la ligne droite utilisée avec les mots-clés de facteur vertical <strong>Linéaire</strong> et <strong>Linéaire inverse</strong>. La pente est spécifiée sous forme d’un rapport de la hauteur sur la distance parcourue (par exemple, une pente de 45 pour cent correspond à 1/45, la valeur introduite étant 0,02222).</li><li><strong>Nom de la table</strong> : correspond au nom de la table définissant le facteur VF.</li></ul>",
	"@@Distance-Allocation_verticalraster_tag0@@": "Définit la relation entre le facteur de coût vertical et l’angle de déplacement relatif vertical (VRMA).",
	"@@Distance-Allocation_verticalraster_tag1@@": "Ces valeurs permettent de calculer la pente utilisée pour identifier le facteur vertical associé au déplacement d’une cellule à une autre.",
	"@@Euclidean-Back-Direction_cellsize_tag0@@": "Taille de cellule qui sera utilisée pour la création du raster en sortie.",
	"@@Euclidean-Back-Direction_cellsize_tag1@@": "Si la taille de cellule a été explicitement définie dans <strong>Environnements</strong>, il s’agit de la taille de cellule par défaut. Si elle n’a pas été définie, la taille de cellule en sortie est identique à celle du <strong>Raster source</strong>.",
	"@@Euclidean-Back-Direction_distancemethod_tag0@@": "Détermine si la distance doit être calculée avec une méthode plane (Terre plate) ou géodésique (ellipsoïde).",
	"@@Euclidean-Back-Direction_distancemethod_tag1@@": "Plane : les mesures planes utilisent des mathématiques cartésiennes en 2D pour calculer la longueur et la surface. Cette option est uniquement disponible lorsque les mesures sont effectuées dans un système de coordonnées projetées. Le plan 2D de ce système de coordonnées est alors utilisé comme base des mesures.",
	"@@Euclidean-Back-Direction_distancemethod_tag2@@": "Géodésique : ligne la plus courte entre deux points de la surface de la Terre sur un sphéroïde (ellipsoïde). Les résultats ne changent donc pas quelle que soit la projection en entrée ou en sortie.",
	"@@Euclidean-Back-Direction_distancemethod_tag3@@": "<strong>Remarque :</strong> vous pouvez utiliser une ligne géodésique si vous souhaitez déterminer la distance la plus courte entre deux villes pour la trajectoire de vol d’un avion. On parle également de « ligne orthodromique » si elle repose sur une sphère plutôt que sur un ellipsoïde.",
	"@@Euclidean-Back-Direction_maximumdistance_tag0@@": "Définit la distance de seuil prise en compte pour calculer la direction par rapport à la source la plus proche. Si la distance par rapport à la source la plus proche dépasse ce seuil, la sortie de cette cellule prend la valeur NoData.",
	"@@Euclidean-Back-Direction_maximumdistance_tag1@@": "La distance par défaut va jusqu’à l’étendue du raster en sortie.",
	"@@Euclidean-Back-Direction_rasterbarriers_tag0@@": "Raster qui définit les interruptions.",
	"@@Euclidean-Back-Direction_rasterbarriers_tag1@@": "Le jeu de données doit contenir une valeur NoData lorsqu’il n’y a pas d’interruption. Les interruptions sont représentées par des valeurs valides, y compris zéro.",
	"@@Euclidean-Back-Direction_rasterbarriers_tag2@@": "Les interruptions peuvent être définies par un raster de type entier ou à virgule flottante.",
	"@@Euclidean-Back-Direction_sourceraster_tag0@@": "Jeu de données raster qui identifie les cellules ou les emplacements par rapport auxquels la direction euclidienne pour chaque emplacement de cellule en sortie est calculée.",
	"@@Euclidean-Back-Direction_sourceraster_tag1@@": "Le raster en entrée peut être de type entier ou à virgule flottante.",
	"@@Cost-Path_costbacklinkraster_tag0@@": "Nom de la couche raster d’antécédence de coût utilisée pour déterminer le chemin permettant de revenir vers une source via le chemin de moindre coût.",
	"@@Cost-Path_costbacklinkraster_tag1@@": "Pour chaque cellule dans le raster d’antécédence, une valeur identifie le voisin, à savoir la cellule suivante sur le chemin de moindre coût cumulé à partir de la cellule vers une seule cellule source ou un jeu de cellules sources.",
	"@@Cost-Path_costdistanceraster_tag0@@": "Nom du raster de distance de coût à utiliser pour déterminer le chemin de moindre coût à partir des emplacements cibles vers une source.",
	"@@Cost-Path_costdistanceraster_tag1@@": "En général, vous pouvez créer un raster de distance de coût grâce aux fonctions Distance de coût, Allocation de coût ou Antécédence de coût. La couche raster de distance de coût stocke, pour chaque cellule, la distance de coût cumulé minimale sur une surface de coût à partir de chaque cellule vers un ensemble de cellules sources.",
	"@@Cost-Path_destinationfield_tag0@@": "Champ permettant d’obtenir des valeurs pour les emplacements de destination. Les données d’entités en entrée doivent contenir au moins un champ autorisé.",
	"@@Cost-Path_destinationraster_tag0@@": "Couche de jeu de données raster identifiant les cellules à partir desquelles le chemin de moindre coût est déterminé par rapport à la source de moindre coût.",
	"@@Cost-Path_destinationraster_tag1@@": "La couche raster en entrée comporte des cellules qui ont des valeurs valides (zéro est une valeur valide) et les cellules restantes doivent avoir la valeur NoData.",
	"@@Cost-Path_forceflowdirectionconventionforbacklinkraster_tag0@@": "Oblige la fonction à traiter le raster d’antécédence en entrée comme un raster de sens de circulation. Les valeurs des rasters de sens de circulation peuvent être des entiers compris entre 0 et 255.",
	"@@Cost-Path_forceflowdirectionconventionforbacklinkraster_tag1@@": "Désactivé : si les valeurs du raster d’antécédence spécifié sont des entiers compris entre 0 et 8, le jeu de données est traité comme un raster d’antécédence de coût. Si les valeurs sont comprises entre 0 et 255, l’entrée est traitée comme un raster de sens de circulation. Si les valeurs sont comprises entre 0 et 360 avec une virgule flottante, l’entrée est traitée comme un raster de direction arrière.",
	"@@Cost-Path_forceflowdirectionconventionforbacklinkraster_tag2@@": "Activé : le raster fourni pour le raster d’antécédence est traité comme un raster de sens de circulation. Utilisez cette option si le raster de sens de circulation possède une valeur maximale inférieure ou égale à 8.",
	"@@Cost-Path_pathtype_tag0@@": "Mot-clé définissant la façon dont les valeurs et les zones des données de destination en entrée sont interprétées dans les calculs du chemin de coût. Les options sont les suivantes :",
	"@@Cost-Path_pathtype_tag1@@": "<strong>Chaque cellule</strong> : pour chaque cellule contenant des valeurs valides de données de destination en entrée, un chemin de moindre coût est déterminé et enregistré dans le raster en sortie. Avec cette option, chaque cellule des données de destination en entrée est traitée séparément et un chemin de moindre coût est déterminé pour chaque cellule.",
	"@@Cost-Path_pathtype_tag2@@": "<strong>Chaque zone</strong> : pour chaque zone des données de destination en entrée, un chemin de moindre coût est déterminé et enregistré dans le raster en sortie. Avec cette option, pour chaque zone, le chemin de moindre coût commence à la cellule avec la pondération de distance de plus faible coût dans la zone.",
	"@@Cost-Path_pathtype_tag3@@": "<strong>Le moins coûteux</strong> : pour toutes les cellules des données de destination en entrée, le chemin du moindre coût est dérivé de la cellule contenant le minimum de chemins de moindre coût vers les cellules sources.",
	"@@Cell-Statistics_cellsizetype_tag0@@": "Sélectionnez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.",
	"@@Cell-Statistics_cellsizetype_tag1@@": "Premier de : utilise la première taille de cellule des rasters en entrée.",
	"@@Cell-Statistics_cellsizetype_tag2@@": "Min de : utilise la plus petite taille de cellule de tous les rasters en entrée.",
	"@@Cell-Statistics_cellsizetype_tag3@@": "Max de : utilise la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.",
	"@@Cell-Statistics_cellsizetype_tag4@@": "Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.",
	"@@Cell-Statistics_cellsizetype_tag5@@": "Dernier de : utilise la dernière taille de cellule des rasters en entrée.",
	"@@Cell-Statistics_extenttype_tag0@@": "Sélectionnez l’étendue à utiliser dans le raster en sortie.",
	"@@Cell-Statistics_extenttype_tag1@@": "Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Cell-Statistics_extenttype_tag2@@": "Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.",
	"@@Cell-Statistics_extenttype_tag3@@": "Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.",
	"@@Cell-Statistics_extenttype_tag4@@": "Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.",
	"@@Cell-Statistics_processasmultiband_tag0@@": "Détermine le mode de traitement des bandes raster en entrée.",
	"@@Cell-Statistics_processasmultiband_tag1@@": "Désactivé : toutes les entrées multibandes sont traitées comme des bandes individuelles. Il s’agit de l’option par défaut.",
	"@@Cell-Statistics_processasmultiband_tag2@@": "Activé : toutes les entrées multibandes sont traitées comme des bandes multiples.",
	"@@Cell-Statistics_rasters_tag0@@": "Liste des rasters à partir desquels calculer les statistiques, pixel par pixel.",
	"@@Cell-Statistics_percentileinterpolationtype_tag0@@": "<p>Définit la méthode d’interpolation à utiliser lorsque la valeur de centile spécifiée se situe entre deux valeurs de cellule en entrée.</p><ul><li><strong>Détection automatique</strong> : si le type de pixel des rasters en entrée est entier, la méthode <strong>Le plus proche</strong> est utilisée. Si le raster en entrée est de type de pixel à virgule flottante, la méthode <strong>Linéaire</strong> est utilisée. Il s’agit de l’option par défaut.</li><li><strong>Le plus proche</strong> : la valeur disponible la plus proche du centile souhaité est utilisée. Dans ce cas, le type de pixel en sortie est identique à celui du raster de valeurs en entrée.</li><li><strong>Linéaire</strong> : la moyenne pondérée des deux valeurs environnantes du centile souhaité est utilisée. Dans ce cas, le type de pixel en sortie est à virgule flottante.</li></ul><p>Cette option est disponible uniquement si le paramètre <strong>Opération</strong> est défini sur <strong>Médiane</strong> ou <strong>Centile</strong>.</p>",
	"@@Cell-Statistics_percentilevalue_tag0@@": "<p>Centile à calculer. La valeur par défaut est de 90, soit le 90e centile.</p><p>Les valeurs peuvent aller de 0 à 100. Le centile 0 est équivalent à la statistique minimale, tandis que le 100e centile équivaut au maximum. Une valeur de 50 donne le même résultat que la statistique Médiane.</p><p>Cette option est disponible uniquement si le paramètre <strong>Opération</strong> est défini sur <strong>Centile</strong>.</p>",
	"@@Optimal-Path-As-Raster_backdirectionrasterorflowdirectionraster_tag0@@": "Le raster de direction arrière contient des directions calculées en degrés. La direction identifie la cellule suivante sur le chemin optimal de retour vers la source de plus faible coût cumulé, en évitant les interruptions.",
	"@@Optimal-Path-As-Raster_backdirectionrasterorflowdirectionraster_tag1@@": "La plage de valeurs s’étend de 0 à 360 degrés, 0 étant réservé aux cellules source. La direction plein Est (droite) est de 90 et les valeurs augmentent dans le sens horaire (180, Sud ; 270, Ouest et 360, Nord).",
	"@@Optimal-Path-As-Raster_destinationfield_tag0@@": "Champ permettant d’obtenir des valeurs relatives aux emplacements de destination.",
	"@@Optimal-Path-As-Raster_destinationraster_tag0@@": "La couche de jeu de données raster qui identifie les cellules à partir desquelles le chemin optimal est déterminé par rapport à la source de moindre coût. Cette entrée est obligatoire.",
	"@@Optimal-Path-As-Raster_destinationraster_tag1@@": "La couche raster en entrée comporte des cellules qui ont des valeurs valides (zéro est une valeur valide) et les cellules restantes doivent avoir la valeur NoData.",
	"@@Optimal-Path-As-Raster_distanceaccumulationraster_tag0@@": "Le raster d’accumulation de distance permet de déterminer le chemin optimal entre les destinations et les sources. Le raster d’accumulation de distance est généralement créé à l’aide de la fonction <strong>Accumulation de distance</strong>. Chaque cellule du raster d’accumulation de distance représente la distance de coût cumulée minimum sur une surface allant de chaque cellule à un ensemble de cellules source.",
	"@@Optimal-Path-As-Raster_pathtype_tag0@@": "Spécifie un mot-clé définissant la façon dont les valeurs et les zones de l’entrée de destination sont interprétées dans les calculs du chemin de coût.",
	"@@Optimal-Path-As-Raster_pathtype_tag1@@": "<strong>Chaque zone</strong> : pour chaque zone des données de destination en entrée, un chemin de moindre coût est déterminé et enregistré dans le raster en sortie. Avec cette option, pour chaque zone, le chemin optimal commence à la cellule avec la pondération de distance de plus faible coût dans la zone.",
	"@@Optimal-Path-As-Raster_pathtype_tag2@@": "<strong>Le moins coûteux</strong> : pour toutes les cellules des données de destination en entrée, le chemin optimal est dérivé de la cellule contenant le minimum de chemins de moindre coût vers les cellules sources.",
	"@@Optimal-Path-As-Raster_pathtype_tag3@@": "<strong>Chaque cellule</strong> : pour chaque cellule contenant des valeurs valides de données de destination en entrée, un chemin optimal est déterminé. Avec cette option, chaque cellule des données de destination en entrée est traitée séparément et un chemin optimal est déterminé pour chaque cellule.",
	"@@CCDC-Analysis_bandsfordetectingchange_tag0@@": "Identifiants des canaux à utiliser pour la détection de changements. Si aucun identifiant des canaux n’est fourni, tous les canaux du jeu de données raster en entrée seront utilisés.",
	"@@CCDC-Analysis_bandsfordetectingchange_tag1@@": "Les valeurs d’identifiant doivent être des entiers séparés par un espace.",
	"@@CCDC-Analysis_bandsfortemporalmasking_tag0@@": "Les identifiants des canaux vert et SWIR, à utiliser pour masquer les nuages, l’ombre des nuages et la neige. En l’absence d’identifiants des canaux, aucun masquage ne se produit.",
	"@@CCDC-Analysis_bandsfortemporalmasking_tag1@@": "Les valeurs d’identifiant doivent être des entiers séparés par un espace.",
	"@@CCDC-Analysis_bandsfortemporalmasking_tag2@@": "Ce paramètre spécifie les canaux à utiliser pour le masquage des nuages, de l’ombre des nuages et de la neige. L’ombre des nuages et la neige apparaissant très sombres dans le canal à onde courte infrarouge (SWIR) et les nuages et la neige étant très lumineux dans le canal vert, il est recommandé de masquer les index des canaux SWIR et vert.",
	"@@CCDC-Analysis_chi-squaredthresholdfordetectchange_tag0@@": "Seuil du khi deux de probabilité des changements. Si une observation a une probabilité de changement calculée supérieure à ce seuil, elle est signalée comme une anomalie, ce qui correspond à un événement de changement potentiel. La valeur par défaut est 0,99.",
	"@@CCDC-Analysis_minimumconsecutiveanomalyobservations_tag0@@": "Nombre minimum d’observations d’anomalies consécutives devant se produire pour qu’un événement soit considéré comme un changement. Un pixel doit être signalé comme une anomalie pour le nombre spécifié de tranches temporelles consécutives pour qu’il soit considéré comme un changement véritable. La valeur par défaut est 6.",
	"@@CCDC-Analysis_raster_tag0@@": "Couche raster multidimensionnelle en entrée.",
	"@@CCDC-Analysis_updatingfittingfrequency(inyears)_tag0@@": "Fréquence à laquelle le modèle de série chronologique est mis à jour avec les nouvelles observations. Par défaut, le modèle est mis à jour chaque année.",
	"@@CCDC-Analysis_updatingfittingfrequency(inyears)_tag1@@": "Ce paramètre définit la fréquence à laquelle le modèle de série chronologique est mis à jour avec les nouvelles observations. La mise à jour fréquente d’un modèle peut occasionner un grand nombre de calculs pour un avantage minimal. Si, par exemple, le raster multidimensionnel contient 365 tranches ou observations claires par an et que la fréquence de mise à jour concerne chacune de ces observations, le traitement demandera 365 fois plus de calculs qu’une mise à jour annuelle, sans pour autant que la précision ne soit supérieure.",
	"@@Trend-To-RGB_modeltype_tag0@@": "Type des informations du modèle à convertir en RGB.",
	"@@Trend-To-RGB_modeltype_tag1@@": "Linéaire : les informations sur la tendance linéaire seront converties en RVB. Il s’agit de l’option par défaut.",
	"@@Trend-To-RGB_modeltype_tag2@@": "Harmonique : les informations sur la tendance harmonique seront converties en RVB.",
	"@@Trend-To-RGB_raster_tag0@@": "Raster de tendance en entrée.",
	"@@LandTrendr-Analysis_bestmodelproportion_tag0@@": "<p>Meilleure valeur de proportion de modèle. Pendant le processus de sélection du modèle, l’outil calcule la valeur p pour chaque modèle et sélectionne le modèle qui a le plus de sommets tout en conservant la valeur p la plus petite (la plus significative) en fonction de cette valeur de proportion. La valeur 1 signifie que le modèle a la valeur p la plus basse mais n’a peut-être pas un grand nombre de sommets. La valeur par défaut est 1,25.</p>",
	"@@LandTrendr-Analysis_maximumnumberofsegments_tag0@@": "<p>Nombre maximal de segments à associer à la série chronologique de chaque pixel. La valeur par défaut est 5.</p>",
	"@@LandTrendr-Analysis_minimumnumberofobservations_tag0@@": "<p>Nombre minimum d’observations valides nécessaire pour effectuer l’ajustement. Le nombre d’années dans le jeu de données multidimensionnelles en entrée doit être supérieur ou égal à cette valeur. La valeur par défaut est 6.</p>",
	"@@LandTrendr-Analysis_outputotherbands_tag0@@": "<p>Indique si les autres canaux sont inclus dans les résultats.</p><ul><li>Activé : les autres canaux sont inclus dans les résultats. Les informations sur la segmentation et les sommets issues du canal de segmentation initial spécifié dans le paramètre <strong>Canal de traitement</strong> sont également ajustées aux autres canaux des images multicanal. Les résultats du modèle incluent d’abord le canal de segmentation, puis les autres canaux.</li><li>Désactivé : les autres canaux ne sont pas inclus. Il s’agit de l’option par défaut.</li></ul>",
	"@@LandTrendr-Analysis_preventoneyearrecovery_tag0@@": "<p>Indique si les segments qui présentent une récupération sur un an doivent être exclus.</p><ul><li>Activé : les segments qui présentent une récupération sur un an doivent être exclus. Il s’agit de l’option par défaut.</li><li>Désactivé : les segments qui présentent une récupération sur un an ne doivent pas être exclus.</li></ul>",
	"@@LandTrendr-Analysis_processingband_tag0@@": "<p>Canal utilisé pour découper les trajectoires de valeur de pixel au fil du temps en segments. Sélectionnez le canal qui capture le mieux les changements sur l’entité à observer.</p>",
	"@@LandTrendr-Analysis_p-valuethreshold_tag0@@": "<p>Seuil de la valeur p pour la sélection d’un modèle. Une fois les sommets détectés à l’étape initiale d’ajustement du modèle, l’outil ajuste chaque segment et calcule la valeur p pour déterminer le niveau d’importance du modèle. À l’itération suivante, le modèle diminue le nombre de segments d’un et recalcule la valeur p. Le processus continue ainsi et, si la valeur p devient inférieure à la valeur spécifiée dans ce paramètre, le modèle est sélectionné et l’outil arrête de rechercher un meilleur modèle. Si aucun modèle n’est sélectionné, l’outil sélectionne un modèle avec une valeur p inférieure à la <strong>valeur p la plus petite x la meilleure valeur de proportion de modèle</strong>. La valeur par défaut est 0,01.</p>",
	"@@LandTrendr-Analysis_raster_tag0@@": "<p>Couche raster multidimensionnelle Landsat en entrée.</p>",
	"@@LandTrendr-Analysis_recoveryhasincreasetrend_tag0@@": "<p>Indique si la récupération présente une tendance à la hausse (positive).</p><ul><li>Activé : la récupération présente une tendance à la hausse. Il s’agit de l’option par défaut.</li><li>Désactivé : la récupération présente une tendance à la baisse.</li></ul>",
	"@@LandTrendr-Analysis_recoverythreshold_tag0@@": "<p>Valeur du seuil de récupération, en années. Si le taux de récupération d’un segment est plus rapide que la valeur <strong>1/seuil de récupération</strong>, ce segment est ignoré et n’est pas inclus dans le modèle de série chronologique. La valeur doit être comprise entre 0 et 1. La valeur par défaut est 0,25.</p>",
	"@@LandTrendr-Analysis_snappingdate_tag0@@": "<p>Date utilisée pour sélectionner une tranche pour chaque année dans le jeu de données multidimensionnelles en entrée. La tranche dont la date est la plus proche de la date de capture est sélectionnée. Ce paramètre est requis si le jeu de données en entrée contient des données pour des périodes inférieures aux années.</p>",
	"@@LandTrendr-Analysis_spikethreshold_tag0@@": "<p>Seuil à utiliser pour amortir les pics ou les anomalies dans la trajectoire de valeur de pixel. Cette valeur doit être comprise entre 0 et 1, où 1 signifie qu’il n’y a pas d’amortissement. La valeur par défaut est 0,9.</p>",
	"@@LandTrendr-Analysis_vertexcountovershoot_tag0@@": "<p>Nombre de sommets supplémentaires au-delà de <strong>nombre_max_segments + 1</strong> qui peut être utilisé pour ajuster le modèle pendant la phase initiale d’identification des sommets. Plus tard dans le processus de modélisation, le nombre de sommets supplémentaires est réduit à <strong>nombre_max_segments + 1</strong>. La valeur par défaut est 2.</p>",
	"@@Merge-Rasters_rasters_tag0@@": "<p>Jeux de données raster ou jeux de données raster multidimensionnelles en entrée à fusionner.</p>",
	"@@Merge-Rasters_resolveoverlapmethod_tag0@@": "<p>Indique la méthode à utiliser pour résoudre les pixels superposés dans les jeux de données combinés.</p><ul><li><strong>Premier</strong> : la valeur de pixel des zones superposées est celle issue du premier raster de la liste des rasters en entrée. Il s’agit de l’option par défaut.</li><li><strong>Dernier</strong> : la valeur de pixel des zones superposées est celle issue du dernier raster de la liste des rasters en entrée.</li><li><strong>Min</strong> : la valeur de pixel des zones superposées est la valeur minimale des pixels superposés.</li><li><strong>Max</strong> : la valeur de pixel des zones superposées est la valeur maximale des pixels superposés.</li><li><strong>Moyenne</strong> : la valeur de pixel des zones superposées est la valeur moyenne des pixels superposés.</li><li><strong>Somme</strong> : la valeur de pixel des zones superposées est la somme des pixels superposés.</li></ul>",
	"@@Generate-Trend_cycleunit_tag0@@": "<p>Spécifie l’unité de temps à utiliser pour la durée d’un cycle harmonique.</p><ul><li><strong>Jours</strong> : L’unité de durée du cycle harmonique se définit en jours.</li><li><strong>Années</strong> : L’unité de durée du cycle harmonique se définit en années. Il s’agit de l’option par défaut.</li></ul>",
	"@@Generate-Trend_dimensionname_tag0@@": "<p>Dimension le long de laquelle une tendance sera extraite pour la ou les variables sélectionnées dans l’analyse.</p>",
	"@@Generate-Trend_harmonicfrequency_tag0@@": "<p>Numéro de fréquence à utiliser dans l’ajustement de tendance. Ce paramètre spécifie la fréquence des cycles au cours d’une année. La valeur par défaut est 1, soit un cycle harmonique par an.</p><p>Ce paramètre n’est inclus dans l’analyse de tendance que pour une régression harmonique.</p>",
	"@@Generate-Trend_ignorenodata_tag0@@": "<p>Indique si les valeurs NoData sont ignorées lors de l’analyse.</p><ul><li>Activé : l’analyse inclut tous les pixels valides le long d’une dimension donnée et ignore les pixels NoData. Il s’agit de l’option par défaut.</li><li>Désactivé : le résultat de l’analyse est NoData s’il existe des valeurs NoData pour les pixels le long de la dimension donnée.</li></ul>",
	"@@Generate-Trend_lengthofcycle_tag0@@": "<p>Durée de la variation périodique à modéliser. L’unité est le jour, quelle que soit l’unité temporelle des données en entrée. Par exemple, la couleur verte des feuilles possède généralement un cycle de variation important au cours d’une année ; la durée du cycle est égale à 365,25, même si les données en entrée font référence à une couleur verte mensuelle. Les données de température horaires ont un cycle de variation important sur la journée, la durée du cycle est égale à 1.</p><p>La durée par défaut est de 365,25 jours pour les données variant sur un cycle annuel.</p>",
	"@@Generate-Trend_p-valueofslopecoefficient_tag0@@": "<p>Indique s’il convient de calculer la statistique de valeur p du coefficient de pente de la ligne de tendance.</p><ul><li>Activé : la valeur p est calculée et affichée dans les détails à la fin du calcul de la fonction.</li><li>Désactivé : la valeur p n’est pas calculée. Il s’agit de l’option par défaut.</li></ul>",
	"@@Generate-Trend_polynomialorder_tag0@@": "<p>Numéro d’ordre polynomial à utiliser dans l’ajustement de tendance. Ce paramètre spécifie l’ordre polynomial. La valeur par défaut est 2 ou un polynôme de deuxième degré.</p><p>Ce paramètre n’est inclus dans l’analyse de tendance que pour une régression polynomiale.</p>",
	"@@Generate-Trend_r-squared_tag0@@": "<p>Indique s’il convient de calculer la statistique de la qualité de l’ajustement R-carré pour la ligne d’ajustement de la tendance.</p><ul><li>Activé : la valeur R-carré est calculée et affichée dans les détails à la fin du calcul de la fonction.</li><li>Désactivé : la valeur R-carré n’est pas calculée. Il s’agit de l’option par défaut.</li></ul>",
	"@@Generate-Trend_raster_tag0@@": "<p>Raster multidimensionnel en entrée.</p>",
	"@@Generate-Trend_rmse_tag0@@": "<p>Indique s’il convient de générer la racine carrée de l’erreur quadratique moyenne (EQM) de la ligne d’ajustement de la tendance.</p><ul><li>Activé : la valeur EQM est calculée et affichée dans les détails à la fin du calcul de la fonction. Il s’agit de l’option par défaut.</li><li>Désactivé : la valeur EQM n’est pas calculée.</li></ul>",
	"@@Generate-Trend_seasonalperiod_tag0@@": "<p>Spécifie l’unité de temps à utiliser pour mesurer la longueur de la période saisonnière lors du test de Kendall saisonnier</p><ul><li>Jours : l’unité de durée de la période saisonnière se définit en jours. Il s’agit de l’option par défaut.</li><li>Mois : l’unité de durée de la période saisonnière se définit en mois.</li></ul>",
	"@@Generate-Trend_trendtype_tag0@@": "<p>Spécifie le type de ligne à utiliser pour ajuster les valeurs de pixel le long d’une dimension.</p><ul><li><strong>Linéaire</strong> : ajuste les valeurs de pixel d’une variable le long d’une ligne de tendance linéaire. Il s’agit de l’option par défaut.</li><li><strong>Harmonique</strong> : ajuste les valeurs de pixel d’une variable le long d’une ligne de tendance harmonique.</li><li><strong>Polynomiale</strong> : ajuste les valeurs de pixel d’une variable le long d’une ligne de tendance polynomiale de deuxième degré.</li><li><strong>Mann-Kendall</strong> : les valeurs de pixel variables sont évaluées à l’aide du test de tendance de Mann-Kendall.</li><li><strong>Kendall saisonnier</strong> : les valeurs de pixel variables sont évaluées à l’aide du test de tendance de Kendall saisonnier.</li></ul>",
	"@@Compute-Change_cellsizetype_tag0@@": "<p>Sélectionnez la taille de cellule à utiliser dans le raster en sortie. Si les tailles des cellules en entrée sont identiques, toutes les options donnent les mêmes résultats.</p><ul><li>Premier de : utilise la première taille de cellule des rasters en entrée.</li><li>Min de : utilise la taille de cellule la plus petite de tous les rasters en entrée.</li><li>Max de : utilise la taille de cellule la plus grande de tous les rasters en entrée. Il s’agit de l’option par défaut.</li><li>Moyenne de : utilise la taille de cellule moyenne de tous les rasters en entrée.</li><li>Dernier de : utilise la dernière taille de cellule des rasters en entrée.</li></ul>",
	"@@Compute-Change_computechangemethod_tag0@@": "<p>Méthode employée pour le calcul.</p><ul><li><strong>Différence</strong> : calcule la différence mathématique, ou soustraction, entre les valeurs de pixel dans les rasters en entrée. Il s’agit de l’option par défaut.</li><li><strong>Différence relative</strong> - Calcule la différence en valeurs de pixel, en tenant compte des magnitudes des valeurs comparées.</li><li><strong>Différence catégorielle</strong> - Calcule la différence entre deux rasters catégoriels ou thématiques. La sortie contient les transitions de classe ayant eu lieu entre les deux rasters.</li><li><strong>Distance euclidienne spectrale</strong> - Calcule la distance euclidienne entre les valeurs de pixel de deux rasters multibandes.</li><li><strong>Écart de l’angle spectral</strong> - Calcule l’angle spectral entre les valeurs de pixel de deux rasters multibandes. La sortie est exprimée en radians.</li><li><strong>Bande avec le plus de changements</strong> - Calcule la bande comportant le plus grand nombre de changements pour chaque pixel entre deux rasters multibandes.</li></ul><p>Si l’option <strong>Mode de calcul des changements</strong> est définie sur <strong>Différence catégorielle</strong>, et que l’une des entrées n’est pas catégorique, une différence simple est calculée.</p>",
	"@@Compute-Change_definetransitioncolors_tag0@@": "<p>Spécifier la méthode à utiliser pour symboliser les pixels ayant changé de classe.</p><ul><li><strong>Utiliser la moyenne des couleurs d’origine et de destination</strong> : la couleur du pixel correspond à la moyenne de la couleur de sa classe d’origine et de la couleur de sa classe de destination.</li><li><strong>Utiliser les couleurs d’origine</strong> : le pixel prend la couleur de sa classe d’origine.</li><li><strong>Utiliser les couleurs de destination</strong> : le pixel prendra la couleur de sa classe de destination.</li></ul>",
	"@@Compute-Change_extenttype_tag0@@": "<p>Sélectionnez l’étendue à utiliser dans le raster en sortie :</p><ul><li>Premier de : utilise l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.</li><li>Intersection de : utilise l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.</li><li>Union de : utilise l’étendue de tous les rasters pour déterminer l’étendue de traitement.</li><li>Dernier de : utilise l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.</li></ul>",
	"@@Compute-Change_filtermethod_tag0@@": "<p>Choisissez la méthode de filtrage à utiliser pour le calcul des changements catégoriels.</p><ul><li><strong>Tout conserver</strong> : toutes les classes sont incluses dans la sortie, et il n’y a pas de filtrage. Sélectionnez cette option pour observer les changements et les persistances dans un seul jeu de données.</li><li><strong>Conserver uniquement les pixels modifiés</strong> : seules les classes qui ont changé de type de classe sont incluses dans la sortie. Sélectionnez cette option si seuls les changements vous intéressent.</li><li><strong>Conserver uniquement les pixels non modifiés</strong> : seules les classes qui restent inchangées sont incluses dans la sortie. Sélectionnez cette option si seules les persistances vous intéressent.</li></ul>",
	"@@Compute-Change_fromclassvalues_tag0@@": "<p>Valeurs de la classe provenant de <strong>Raster d’origine</strong> à inclure dans le calcul, lorsqu’on compare deux rasters catégoriels. Il s’agit d’une liste de valeurs entières délimitées par des espaces correspondant au champ <strong>ClassValue</strong> dans votre jeu de données raster en entrée.</p>",
	"@@Compute-Change_fromraster_tag0@@": "<p>Premier raster utilisé dans le calcul. Pour évaluer le changement de l’intervalle 1 (précédemment) à l’intervalle 2 (ultérieurement), saisissez le raster de l’intervalle 1 ici.</p>",
	"@@Compute-Change_toclassvalues_tag0@@": "<p>Valeurs de la classe provenant de <strong>Raster de destination</strong> à inclure dans le calcul, lorsqu’on compare deux rasters catégoriels. Il s’agit d’une liste de valeurs entières délimitées par des espaces correspondant au champ <strong>ClassValue</strong> dans votre jeu de données raster en entrée.</p>",
	"@@Compute-Change_toraster_tag0@@": "<p>Second raster utilisé dans le calcul. Pour évaluer le changement de l’intervalle 1 (précédemment) à l’intervalle 2 (ultérieurement), saisissez le raster de l’intervalle 2.</p>",
	"@@Compute-Change_usecolormethod_tag0@@": "<p>Spécifier la méthode à utiliser pour symboliser les pixels ayant changé de classe.</p><ul><li><strong>Utiliser la moyenne des couleurs d’origine et de destination</strong> : la couleur du pixel correspond à la moyenne de la couleur de sa classe d’origine et de la couleur de sa classe de destination.</li><li><strong>Utiliser les couleurs d’origine</strong> : le pixel prend la couleur de sa classe d’origine.</li><li><strong>Utiliser les couleurs de destination</strong> : le pixel prendra la couleur de sa classe de destination.</li></ul>",
	"@@Compute-Change_fieldnameforclassnamesinfromraster_tag0@@": "<p>Champ stockant les noms de classe dans l’entrée <strong>Raster d’origine</strong>. L’outil recherche automatiquement le champ <strong>ClassName</strong> ou <strong>Class_Name</strong> à utiliser.</p><p>Utilisez cette option si l’entrée ne contient pas ces noms de champ standards.</p>",
	"@@Compute-Change_fieldnameforclassnamesintoraster_tag0@@": "<p>Champ stockant les noms de classe dans l’entrée <strong>Raster de destination</strong>. L’outil recherche automatiquement le champ <strong>ClassName</strong> ou <strong>Class_Name</strong> à utiliser.</p><p>Utilisez cette option si l’entrée ne contient pas ces noms de champ standards.</p>",
	"@@Statistics_numberofcolumns_tag0@@": "<p>Nombre de colonnes de pixels à utiliser dans une dimension de voisinage focale.</p>",
	"@@Statistics_numberofrows_tag0@@": "<p>Nombre de lignes de pixels que vous utilisez dans une dimension de voisinage focale.</p>",
	"@@Statistics_onlyfillnodatapixels_tag0@@": "<p>Comble les intervalles NoData dans la sortie. Cette fonction est utile lorsqu’il se peut que votre imagerie ait supprimé des lignes.</p>",
	"@@Statistics_raster_tag0@@": "<p>Raster en entrée sur lequel réaliser les statistiques focales.</p>",
	"@@Statistics_statisticstype_tag0@@": "<p>Les sept types de fonctions statistiques focales sont les suivants :</p><ul><li>Minimum : calcule la valeur minimale des pixels dans le voisinage.</li><li>Maximum : calcule la valeur maximale des pixels dans le voisinage.</li><li>Moyenne : calcule la valeur moyenne des pixels dans le voisinage. Il s’agit de l’option par défaut.</li><li>Écart type : calcule la valeur d’écart type des pixels dans le voisinage.</li><li>Médiane : calcule la valeur médiane des pixels dans le voisinage.</li><li>Majorité : calcule la majorité ou la valeur la plus fréquente des pixels dans le voisinage.</li><li>Minorité : calcule la minorité ou la valeur la moins fréquente des pixels dans le voisinage.</li></ul>",
	"@@Detect-Change-Using-Change-Analysis_changedirection_tag0@@": "<p>Indique la direction du changement à inclure dans l’analyse.</p><p>Ce paramètre est disponible uniquement si le raster d’analyse des changements en entrée est la sortie des outils LandTrendr.</p><ul><li><strong>Toutes les directions</strong> : toutes les directions de changement sont incluses dans la sortie. Il s’agit de l’option par défaut.</li><li><strong>Croissant</strong> : seuls les changements dont la direction est positive ou croissante sont inclus dans la sortie.</li><li><strong>Décroissant</strong> : seuls les changements dont la direction est négative ou décroissante sont inclus dans la sortie.</li></ul>",
	"@@Detect-Change-Using-Change-Analysis_changetype_tag0@@": "<p>Indique les informations de changement à calculer.</p><ul><li><strong>Heure du changement le plus récent</strong> : chaque pixel comprend la date de son changement le plus récent dans la série chronologique. Il s’agit de l’option par défaut.</li><li><strong>Heure du premier changement</strong> : chaque pixel comprend la date de son premier changement dans la série chronologique.</li><li><strong>Heure du plus grand changement</strong> : chaque pixel comprend la date de son changement le plus important dans la série chronologique.</li><li><strong>Nombre de changements</strong> : chaque pixel comprend le nombre total de fois où il a été changé dans la série chronologique.</li><li><strong>Date/heure du plus long changement</strong> : chaque pixel comprend la date de changement à la fin du plus long segment de transition de la série chronologique.</li><li><strong>Date/heure du plus court changement</strong> : chaque pixel comprend la date de changement à la fin du plus court segment de transition de la série chronologique.</li><li><strong>Date/heure du changement le plus rapide</strong> : chaque pixel comprend la date de changement à la fin de la transition qui est survenue le plus rapidement.</li><li><strong>Date/heure du changement le plus lent</strong> : chaque pixel comprend la date de changement à la fin de la transition qui est survenue le plus lentement.</li></ul>",
	"@@Detect-Change-Using-Change-Analysis_filterbyduration_tag0@@": "<p>Indique si le filtrage s’effectue sur la durée des changements.</p><p></p><ul><li>Activé : les résultats sont filtrés par durée, de façon à ce que seuls les changements ayant une durée donnée soient inclus dans la sortie.</li><li>Désactivé : les résultats ne sont pas filtrés par durée. Il s’agit de l’option par défaut.</li></ul><p>Ce paramètre est disponible uniquement si le raster d’analyse des changements en entrée est la sortie des outils LandTrendr.</p><p>Si ce paramètre est activé, vous devez définir les paramètres <strong>Durée minimale</strong> et <strong>Durée maximale</strong> pour le filtrage.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbymagnitude_tag0@@": "<p>Indique si le filtrage s’effectue sur la magnitude des changements. </p><ul><li>Activé : les résultats sont filtrés par magnitude, de façon à ce que seuls les changements ayant une magnitude donnée soient inclus dans la sortie.</li><li>Désactivé : les résultats ne sont pas filtrés par magnitude. Il s’agit de l’option par défaut.</li></ul><p>Ce paramètre est disponible uniquement si le raster d’analyse des changements en entrée est la sortie des outils LandTrendr.</p><p>Si ce paramètre est activé, vous devez définir les paramètres <strong>Magnitude minimale</strong> et <strong>Magnitude maximale</strong> pour le filtrage.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbyyear_tag0@@": "<p>Indique si la sortie doit être limitée à un nombre d’années. </p><ul><li>Activé : les résultats sont filtrés de façon à ce que seuls les changements survenus dans un nombre d’années spécifique soient inclus dans la sortie.</li><li>Désactivé : les résultats ne sont pas filtrés par année. Il s’agit de l’option par défaut.</li></ul><p>Si ce paramètre est activé, vous devez définir les paramètres <strong>Valeur minimale</strong> et <strong>Valeur maximale</strong> pour le filtrage.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbystartvalue_tag0@@": "<p>Filtrez les résultats par valeur de départ de façon à ce que seuls les changements d’une valeur de départ donnée soient inclus dans la sortie.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbyendvalue_tag0@@": "<p>Filtrez les résultats par valeur de fin de façon à ce que seuls les changements d’une valeur de fin donnée soient inclus dans la sortie.</p>",
	"@@Detect-Change-Using-Change-Analysis_maximumnumberofchanges_tag0@@": "<p>Nombre maximal de changements par pixel à calculer. Le nombre saisi correspond au nombre de canaux dans le raster en sortie. Par défaut, la valeur est 1. Autrement dit, une seule date de changement est calculée, et le raster en sortie ne comprend qu’une seule bande.</p><p>Ce paramètre n’est pas disponible si le paramètre <strong>Type de changement</strong> est défini sur <strong>Nombre de changements</strong>.</p>",
	"@@Detect-Change-Using-Change-Analysis_raster_tag0@@": "<p>Raster d’analyse des changements en entrée.</p>",
	"@@Detect-Change-Using-Change-Analysis_segmentdate_tag0@@": "<p>Indique s’il faut extraire la date au début ou à la fin d’un segment de changement.</p><p>Ce paramètre est disponible uniquement si le raster d’analyse des changements en entrée est la sortie des outils LandTrendr.</p><ul><li><strong>Début du segment</strong> : la date est extraite au début d’un segment de changement. Il s’agit de l’option par défaut.</li><li><strong>Fin du segment</strong> : la date est extraite à la fin d’un segment de changement.</li></ul>",
	"@@Kernel-Density_areaunits_tag0@@": "<p>Unités de surface des valeurs de densité en sortie.</p><ul><li>Unité de carte au carré : pour le carré des unités linéaires de la référence spatiale en sortie.</li><li>Miles carrés : pour les miles (U.S.).</li><li>Kilomètres carrés : pour les kilomètres.</li><li>Acres : pour les acres (U.S.).</li><li>Hectares : pour les hectares.</li><li>Mètres carrés : pour les mètres.</li><li>Yards carrés : pour les yards (U.S.).</li><li>Pieds carrés : pour les pieds (U.S.).</li><li>Pouces carrés : pour les pouces (U.S.).</li><li>Centimètres carrés : pour les centimètres.</li><li>Millimètres carrés : pour les millimètres.</li></ul>",
	"@@Kernel-Density_cellsize_tag0@@": "<p>Taille de pixel du jeu de données raster en sortie. Si la valeur du paramètre <strong>Taille de cellule</strong> a été configurée dans les environnements de géotraitement, il s’agit de la valeur par défaut.</p>",
	"@@Kernel-Density_inputbarriers_tag0@@": "<p>Jeu de données qui définit les interruptions.</p><p>Les interruptions peuvent être une couche d’entités polylignes ou surfaciques.</p>",
	"@@Kernel-Density_inputfeatures_tag0@@": "<p>Entités ponctuelles ou linéaires en entrée pour lesquelles calculer la densité.</p>",
	"@@Kernel-Density_method_tag0@@": "<p>Détermine s’il convient d’utiliser un plus court chemin sur une sphéroïde (géodésique) ou une terre plate (plane).</p><ul><li><strong>Planaire</strong> : utilise des distances planes entre les entités. Il s’agit de l’option par défaut.</li><li><strong>Géodésique</strong> : utilise des distances géodésiques entre les entités. Cette méthode tient compte de la courbure du sphéroïde et gère correctement les données situées près des pôles et la ligne internationale de changement de jour.</li></ul><p>Il est conseillé d’utiliser la méthode <strong>Géodésique</strong> avec des données stockées dans un système de coordonnées non approprié pour les mesures de distance et toute analyse couvrant une zone géographique importante. Par exemple, Web Mercator ou tout système de coordonnées géographiques doit utiliser la méthode <strong>Géodésique</strong>.</p>",
	"@@Kernel-Density_outputcellvalues_tag0@@": "<p>Détermine ce que les valeurs du raster en sortie représentent.</p><ul><li><strong>Densités</strong> : les valeurs en sortie représentent la valeur de densité prévue. Il s’agit de l’option par défaut.</li><li><strong>Volumes attendus</strong> : les valeurs en sortie représentent l’intensité prévue du phénomène dans chaque pixel. Puisque la valeur de pixel est liée à la valeur du paramètre <strong>Taille de cellule</strong> spécifiée, il est impossible de ré-échantillonner le raster résultant sur une autre taille de pixel, car il représente l’intensité du phénomène.</li></ul>",
	"@@Kernel-Density_populationfield_tag0@@": "<p>Champ indiquant les valeurs de population pour chaque entité. La valeur du paramètre <strong>Champ de population</strong> représente le total ou la quantité à répartir sur tout le paysage pour créer une surface continue. Le paramètre <strong>Champ de population</strong> peut contenir des valeurs entières ou à virgule flottante.</p><p>Les options et les comportements par défaut pour le champ sont répertoriés ci-dessous par ordre de priorité.</p><ul><li>Utilisez <strong>Aucun</strong> si aucun élément ou valeur spéciale n’est utilisé et que chaque entité est comptée une seule fois.</li><li>Utilisez <strong>Shape</strong> si les entités en entrée contiennent des valeurs z.</li><li>Sinon, le champ par défaut est <strong>POPULATION</strong>, ou toute dérivée acceptable de la population :<ul><li><strong>POPULATIONxxxx</strong> où <strong>xxxx</strong> représente n’importe quel caractère valide, tel que <strong>POPULATION6</strong>, <strong>POPULATION1974</strong>, ou <strong>POPULATIONROADTYPE</strong>.</li><li><strong>POP</strong>.</li><li><strong>POPxxxx</strong>.</li><li>Si aucune des conditions ci-dessus ne s’applique, la valeur par défaut est <strong>Aucun</strong>.</li></ul></li></ul>",
	"@@Kernel-Density_searchradius_tag0@@": "<p>Rayon de recherche dans lequel le calcul de la densité est effectué. Les unités sont basées sur l’unité linéaire de la projection.</p><p>Par exemple, si les unités sont exprimées en mètres pour inclure toutes les entités dans un voisinage d’un mile, définissez le rayon de recherche sur 1 609,344 (car 1 mile = 1 609,344 mètres).</p>",
	"@@Zonal-Statistics_ignorenodataincalculations_tag0@@": "<p>Indique si les valeurs <strong>NoData</strong> dans <strong>Raster de valeurs</strong> influencent les résultats de la zone dans laquelle elles se trouvent.</p><ul><li><strong>Oui</strong> : dans une zone particulière, seuls les pixels qui ont une valeur dans le <strong>raster de valeurs</strong> sont utilisés pour déterminer la valeur en sortie de cette zone. Les pixels <strong>NoData</strong> dans le <strong>Raster de valeurs</strong> sont ignorées dans le calcul statistique. Il s’agit de l’option par défaut.</li><li><strong>Non</strong> : dans une zone particulière, s’il existe des pixels <strong>NoData</strong> dans le <strong>Raster de valeurs</strong>, on considère que les informations sont insuffisantes pour exécuter des calculs statistiques pour l’ensemble des pixels de cette zone. Par conséquent, la zone entière reçoit la valeur <strong>NoData</strong> sur le raster en sortie.</li></ul>",
	"@@Zonal-Statistics_percentileinterpolationtype_tag0@@": "<p>Détermine la méthode d’interpolation en centile à utiliser lorsque le nombre de valeurs du raster en entrée à calculer est pair.</p><ul><li><strong>Détection automatique</strong> : si le type de pixel du raster de valeurs en entrée est de type entier, la méthode <strong>Le plus proche</strong> est utilisée. Si le type de pixel du raster de valeurs en entrée est de type virgule flottante, la méthode <strong>Linéaire</strong> est utilisée. Il s’agit de l’option par défaut.</li><li><strong>La plus proche</strong> : la valeur disponible la plus proche du centile souhaité est utilisée. Dans ce cas, le type de pixel en sortie est identique à celui du raster de valeurs en entrée.</li><li><strong>Linéaire</strong> : la moyenne pondérée des deux valeurs environnantes du centile souhaité est utilisée. Dans ce cas, le type de pixel en sortie est à virgule flottante.</li></ul>",
	"@@Zonal-Statistics_percentilevalue_tag0@@": "<p>Percentile à calculer. La valeur par défaut est de 90, soit le 90ème centile.</p><p>Les valeurs peuvent s’échelonner de 0 à 100. Le centile n° 0 est équivalent à la statistique Minimum tandis que le 100è centile équivaut au Maximum. </p>Une valeur de 50 donne le même résultat que la statistique Médiane.",
	"@@Zonal-Statistics_processasmultidimensional_tag0@@": "<p>Détermine le mode de traitement du raster de valeurs multidimensionnelles en entrée.</p><ul><li><strong>Tranche actuelle</strong> : les statistiques sont calculées à partir de la tranche actuelle d’un jeu de données multidimensionnelles. Il s’agit de l’option par défaut.</li><li><strong>Toutes les tranches</strong> : les statistiques sont calculées pour toutes les dimensions (par exemple, temps ou profondeur) d’un jeu de données multidimensionnelles.</li></ul>",
	"@@Zonal-Statistics_statisticstype_tag0@@": "<p>Type de statistique à calculer.</p><ul><li><strong>Moyenne </strong> : calcule la moyenne de tous les pixels dans le <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie.</li><li><strong>Majorité</strong> :détermine la valeur qui se produit le plus souvent parmi tous les pixels du <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie.</li><li><strong>Maximum</strong> : détermine la plus grande valeur parmi tous les pixels du <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie.</li><li><strong>Médiane</strong> : détermine la valeur médiane parmi tous les pixels du <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie.</li><li><strong>Minimum</strong> : détermine la plus petite valeur parmi tous les pixels du <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie.</li><li><strong>Minorité</strong> : détermine la valeur qui se produit le moins souvent parmi tous les pixels du <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie.</li><li><strong>Percentile</strong> : calcule un pourcentage de tous les pixels dans le <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie. Le 90è centile est calculé par défaut. Vous pouvez déterminer le pourcentage à calculer à l’aide du paramètre <strong>Valeur de centile</strong>.</li><li><strong>Plage</strong> : calcule l’écart entre la plus petite valeur et la plus grande valeur parmi tous les pixels du <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie.</li><li><strong>Écart type</strong> : calcule l’écart type de tous les pixels dans le <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie.</li><li><strong>Somme</strong> : calcule la valeur totale de tous les pixels dans le <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie.</li><li><strong>Variété</strong> : calcule le nombre de valeurs uniques pour tous les pixels du <strong>Raster de valeurs</strong> qui appartiennent à la même zone que le pixel en sortie.</li></ul>",
	"@@Zonal-Statistics_valueraster_tag0@@": "<p>Raster contenant les valeurs sur lesquelles vous voulez calculer une statistique.</p>",
	"@@Zonal-Statistics_zonefield_tag0@@": "<p>Champ contenant les valeurs qui définissent chaque zone. Il peut s’agir d’un champ de type entier ou chaîne du raster de zones.</p>",
	"@@Zonal-Statistics_zoneraster_tag0@@": "<p>Jeu de données définissant les zones. Les zones peuvent être définies par un raster de type entier.</p>",
	"@@Zonal-Statistics_calculatecircularstatistics_tag0@@": "<p>Détermine le mode de calcul du type de statistique.</p><ul><li><strong>Arithmétique</strong> : calcule des statistiques arithmétiques. Il s’agit de l’option par défaut.</li><li><strong>Circulaire</strong> : calcule les statistiques circulaires appropriées aux quantités cycliques, telles que la direction de la boussole en degrés, les journées ou la partie décimale des nombres réels.</li></ul>",
	"@@Zonal-Statistics_circularwrapvalue_tag0@@": "<p>Valeur possible la plus élevée (limite supérieure) dans les données cycliques. Il s’agit d’un nombre positif dont la valeur par défaut est 360. Cette valeur représente également la même quantité que la valeur possible la plus faible (limite inférieure).</p><p>Ce paramètre n’est applicable que lorsque des statistiques circulaires sont calculées.</p>",
	"@@Boundary-Clean-function_inputraster_tag0@@": "<p>Raster en entrée dont la limite entre les zones doit être lissée.</p><p>Il doit être de type entier.</p>",
	"@@Boundary-Clean-function_runexpansionandshrinkingtwice_tag0@@": "<p>Indique le nombre d’exécutions du lissage : une ou deux fois. </p><ul><li><p><strong>Activé</strong> : l’opération d’expansion et de contraction est effectuée deux fois. La première fois, l’opération est effectuée selon le type de tri spécifié. Ensuite, une opération d’expansion et de contraction supplémentaire est effectuée avec la priorité inverse. Il s’agit de l’option par défaut.</p></li><li><p><strong>Désactivé</strong> : l’opération d’expansion et de contraction est effectuée une seule fois en fonction du type de tri. </p></li></ul>",
	"@@Boundary-Clean-function_sorttype_tag0@@": "<p>Indique le type de tri à utiliser dans le processus de lissage. Celui-ci définit la priorité des cellules à étendre dans leur voisinage.</p><p>Le tri peut être basé sur la valeur de la zone ou sur la surface de la zone.</p><ul><li><p><strong>Ne pas trier</strong> : les zones ne sont pas triées par taille. Les zones dotées de valeurs plus importantes sont prioritaires pour s’étendre dans des zones à valeurs moindres dans la sortie lissée. Il s’agit de l’option par défaut.</p></li><li><p><strong>Décroissant</strong> : trie les zones par ordre de taille décroissant. Les zones dotées de surfaces totales plus importantes sont prioritaires pour s'étendre dans des zones à surfaces totales moindres. Cette option tend à éliminer ou à réduire la prévalence des cellules des zones plus petites dans la sortie lissée.</p></li><li><p><strong>Croissant</strong> : trie les zones par ordre de taille croissant. Les zones dotées de surfaces totales plus réduites sont prioritaires pour s'étendre dans des zones à surfaces totales plus importantes. Cette option tend à conserver ou à augmenter la prévalence des cellules des zones plus petites dans la sortie lissée.</p></li></ul>",
	"@@Aggregate-Multidimensional_dimension_tag0@@": "<p>Dimension de l’agrégation. Il s’agit de la dimension sur laquelle les variables sont agrégées.</p>",
	"@@Aggregate-Multidimensional_dimensiondefinition_tag0@@": "<p>Indique la méthode à utiliser pour filtrer les données multidimensionnelles en entrée avant d’effectuer l’agrégation.</p><ul><li><strong>Tout</strong> : la plage complète de chaque dimension est utilisée. Il s’agit de l’option par défaut.</li><li><strong>Par valeurs</strong> : la dimension est découpée en tranches selon une valeur de la dimension ou une liste de valeurs.</li><li><strong>Par plages</strong> : la dimension est découpée en tranches selon une plage ou une liste de plages.</li><li><strong>Par itération</strong> : la dimension est découpée en tranches selon une taille d’intervalle précisée.</li></ul>",
	"@@Aggregate-Multidimensional_iterationdefinitionparameters_tag0@@": "<p>Les paramètres de définition de l’itération permettent de définir les valeurs de la dimension à utiliser pour filtrer les données multidimensionnelles en entrée aux fins d’analyse lorsque le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par itération</strong>.</p><ul><li><strong>Dimension</strong> : la dimension à utiliser pour le filtrage.</li><li><strong>Début de la première itération</strong> : début du premier intervalle. Cet intervalle est employé pour l’itération au sein du jeu de données.</li><li><strong>Fin de la première itération</strong> : fin du premier intervalle. Cet intervalle est employé pour l’itération au sein du jeu de données.</li><li><strong>Étape</strong> : fréquence à laquelle les données sont découpées en tranches.</li><li><strong>Unité</strong> : unité de l’itération.</li></ul>",
	"@@Aggregate-Multidimensional_keywordinterval_tag0@@": "<p>Spécifie le mot-clé de l’intervalle à utiliser lors de l’agrégation sur la dimension.</p><p>Ce paramètre est requis lorsque le paramètre <strong>Type</strong> est défini sur <strong>Mot-clé de l’intervalle</strong>.</p><ul><li><strong>Par heure</strong> : les valeurs des données sont agrégées selon des intervalles horaires et le résultat comprend chaque heure de la série chronologique. Il s’agit de l’option par défaut.</li><li><strong>Par jour</strong> : les valeurs des données sont agrégées selon des intervalles quotidiens et le résultat comprend chaque jour de la série chronologique.</li><li><strong>Par semaine</strong> : les valeurs des données sont agrégées selon des intervalles hebdomadaires et le résultat comprend chaque semaine de la série chronologique.</li><li><strong>Par dix jours</strong> : les valeurs des données sont agrégées en 3 périodes de 10 jours chacune. La dernière période peut contenir plus ou moins de 10 jours. La sortie comprend 3 tranches pour chaque mois.</li><li><strong>Par cinq jours</strong> : les valeurs des données sont agrégées en 6 périodes de 5 jours chacune. La dernière période peut contenir plus ou moins de 5 jours. La sortie comprend 6 tranches pour chaque mois.</li><li><strong>Par mois</strong> : les valeurs des données sont agrégées selon des intervalles mensuels et le résultat comprend chaque mois de la série chronologique.</li><li><strong>Par trimestre</strong> : les valeurs des données sont agrégées selon des intervalles trimestriels et le résultat comprend chaque trimestre de la série chronologique.</li><li><strong>Par an</strong> : les valeurs des données sont agrégées selon des intervalles annuels et le résultat comprend chaque année de la série chronologique.</li><li><strong>Récurrence quotidienne</strong> : les valeurs des données sont agrégées selon des intervalles quotidiens et le résultat comprend une valeur agrégée par jour du calendrier julien. La sortie comprend au maximum 366 tranches temporelles quotidiennes.</li><li><strong>Récurrence hebdomadaire</strong> : les valeurs des données sont agrégées selon des intervalles hebdomadaires et le résultat comprend une valeur agrégée par semaine. La sortie comprend au maximum 53 tranches temporelles hebdomadaires.</li><li><strong>Récurrence mensuelle</strong> : les valeurs des données sont agrégées selon des intervalles mensuels et le résultat comprend une valeur agrégée par mois. La sortie comprend au maximum 12 tranches temporelles mensuelles.</li><li><strong>Récurrence trimestrielle</strong> : les valeurs des données sont agrégées selon des intervalles trimestriels et le résultat comprend une valeur agrégée par trimestre. La sortie comprend au maximum 4 tranches temporelles trimestrielles.</li></ul>",
	"@@Aggregate-Multidimensional_operation_tag0@@": "<p>Indique la méthode mathématique utilisée pour combiner les tranches agrégées dans un intervalle.</p><ul><li><strong>Majorité</strong> : valeur de pixel la plus fréquente, calculée sur toutes les tranches comprises dans l’intervalle.</li><li><strong>Maximum</strong> : valeur maximale d’un pixel, calculée sur toutes les tranches comprises dans l’intervalle.</li><li><strong>Moyenne</strong> : moyenne des valeurs d’un pixel, calculée sur toutes les tranches comprises dans l’intervalle. Il s’agit de l’option par défaut.</li><li><strong>Médiane</strong> : valeur médiane d’un pixel, calculée sur toutes les tranches comprises dans l’intervalle.</li><li><strong>Minimum</strong> : valeur minimale d’un pixel, calculée sur toutes les tranches comprises dans l’intervalle.</li><li><strong>Minorité</strong> : valeur de pixel la moins fréquente, calculée sur toutes les tranches comprises dans l’intervalle.</li><li><strong>Plage</strong> : plage des valeurs d’un pixel, calculée sur toutes les tranches comprises dans l’intervalle.</li><li><strong>Écart type</strong> : écart type des valeurs d’un pixel, calculé sur toutes les tranches comprises dans l’intervalle.</li><li><strong>Somme</strong> : somme des valeurs d’un pixel, calculée sur toutes les tranches comprises dans l’intervalle.</li><li><strong>Variété</strong> : nombre de valeurs de pixel uniques, calculé sur toutes les tranches comprises dans l’intervalle.</li></ul><p>Chacune de ces options a également une option Ignorer NoData équivalente. Elle permet d’effectuer l’opération mathématique sur tous les pixels valides de la dimension et d’ignorer les pixels NoData.</p>",
	"@@Aggregate-Multidimensional_ranges_tag0@@": "<p>Plages d’intervalle spécifiées dans une table, utilisées pour agréger des groupes de valeurs. Les valeurs minimales et maximales déterminent la plage à inclure.</p><p>Ce paramètre est requis lorsque le paramètre <strong>Type</strong> est défini sur <strong>Plages d’intervalle</strong>.</p>",
	"@@Aggregate-Multidimensional_raster_tag0@@": "<p>Raster multidimensionnel en entrée.</p>",
	"@@Aggregate-Multidimensional_type_tag0@@": "<p>Spécifie l’intervalle dimensionnel pour lequel les données sont agrégées.</p><ul><li><strong>Tout</strong> : les données des variables sont agrégées sur toutes les tranches. Il s’agit de l’option par défaut.</li><li><strong>Mot-clé de l’intervalle</strong> : les données des variables sont agrégées à l’aide d’un intervalle courant connu.</li><li><strong>Valeur d’intervalle</strong> : les données des variables sont agrégées à l’aide d’un intervalle et d’une unité définis par l’utilisateur.</li><li><strong>Plages d’intervalle</strong> : les données des variables sont agrégées entre les paires de valeurs ou de dates spécifiées.</li></ul>",
	"@@Aggregate-Multidimensional_valueinterval_tag0@@": "<p>Taille de l’intervalle à utiliser pour l’agrégation.</p><p>Ce paramètre est requis lorsque le paramètre<strong>Type</strong>est défini sur<strong>Valeur d’intervalle</strong>.</p>",
	"@@Aggregate-Multidimensional_values_tag0@@": "<p>Les valeurs de la dimension à utiliser pour filtrer les données multidimensionnelles en entrée aux fins d’analyse. Ce paramètre est requis lorsque le paramètre <strong>Définition de la dimension</strong> est défini sur <strong>Par valeurs</strong>.</p>",
	"@@Aggregate-Multidimensional_variables_tag0@@": "<p>La ou les variables qui sont agrégées sur la dimension donnée.</p>",
	"@@Predict-Using-Regression_inputdefinitionfile_tag0@@": "<p>Fichier de définition de régression Esri (<strong>.ecd</strong>) en entrée qui contient les statistiques et les informations pour le jeu de données spécifique, le modèle de régression et les attributs choisis.</p>",
	"@@Predict-Using-Regression_rasters_tag0@@": "<p>Jeu ou jeux de données raster représentant les variables de prévision. Il peut s’agir d’un raster à une seule bande ou à plusieurs bandes, d’un raster multidimensionnel, d’un jeu de données mosaïque ou d’un ensemble de rasters.</p>",
	"@@Cell-Statistics_operation_tag0@@": "<p>Type de calcul statistique que vous souhaitez effectuer.</p><p>Les statistiques disponibles sont les suivantes :<strong>Majorité</strong>,<strong>Maximum</strong>,<strong>Moyenne</strong>,<strong>Médiane</strong>,<strong>Minimum</strong>,<strong>Minorité</strong>,<strong>Centile</strong>,<strong>Plage</strong>,<strong>Écart type</strong>,<strong>Somme</strong> et<strong>Variété</strong>.</p><p>La valeur par défaut est<strong>Moyenne</strong>.</p>",
	"@@Colormap-To-RGB_randomlyassigncolortounmappedpixels_tag0@@": "<p>Les couleurs sont attribuées de manière aléatoire aux pixels non inclus dans la palette de couleurs.</p><ul><li>Désactivé : aucune couleur n’est attribuée aux pixels non appariés. Il s’agit de l’option par défaut.</li><li>Activé : une couleur est attribuée aux pixels non appariés.</li></ul>",
	"@@Pansharpen_sensor_tag0@@": "<p>Lorsque l’algorithme Gram-Schmidt est choisi, vous pouvez également spécifier le capteur du raster multicanal en entrée. Le choix du type de capteur définit les pondérations de canal appropriées.</p>",
	"@@Dimensional-Moving-Statistics_backwardwindow_tag0@@": "<p>Valeur du nombre de coupes avant ou au-dessus à inclure dans la fenêtre définie. La valeur doit être un entier positif compris entre 1 et 100. La valeur par défaut est 1.</p><p>L’unité de ce paramètre est la coupe.</p>",
	"@@Dimensional-Moving-Statistics_circularwrapvalue_tag0@@": "<p>Valeur allant être utilisée pour arrondir une valeur linéaire à la plage d’une moyenne circulaire donnée.</p><p>Sa valeur doit être positive. La valeur par défaut est 360 degrés</p>.",
	"@@Dimensional-Moving-Statistics_dimension_tag0@@": "<p>Nom de la dimension le long de laquelle la fenêtre se déplace.</p><p>La valeur par défaut est la première dimension autre que x,y trouvée dans le raster multidimensionnel en entrée.</p>",
	"@@Dimensional-Moving-Statistics_forwardwindow_tag0@@": "<p>Valeur du nombre de coupes après ou au-dessous à inclure dans la fenêtre définie. La valeur doit être un entier positif compris entre 1 et 100. La valeur par défaut est 1.</p><p>L’unité de ce paramètre est la coupe.</p>",
	"@@Dimensional-Moving-Statistics_inputraster_tag0@@": "<p>Le raster en entrée ne peut être qu’un raster multidimensionnel au format Cloud Raster Format (fichier<strong>.crf</strong>).</p>",
	"@@Dimensional-Moving-Statistics_nodatahandling_tag0@@": "<p>Indique comment les valeurs NoData sont traitées par le calcul de statistiques.</p><ul><li><strong>Données</strong> : les valeurs NoData de la valeur en entrée sont ignorées dans les résultats de la fenêtre définie dans laquelle elles se trouvent. Il s’agit de l’option par défaut.</li><li><strong>NoData</strong> : les valeurs en sortie sont NoData s’il existe des valeurs NoData dans l’entrée dans la fenêtre définie.</li><li><strong>Remplir les valeurs NoData</strong> : les valeurs de cellule NoData sont remplacées à l’aide de la statistique sélectionnée dans la fenêtre définie.</li></ul>",
	"@@Dimensional-Moving-Statistics_percentileinterpolationtype_tag0@@": "<p>Définit la méthode d’interpolation à utiliser lorsque la valeur de centile se situe entre deux valeurs de cellule.</p><ul><li><strong>Détection automatique</strong> : si le raster en entrée est de type entier, la méthode<strong>Le plus proche</strong> est utilisée. Si le raster en entrée est de type pixel flottant, la méthode<strong>Linéaire</strong>est utilisée. Il s’agit de l’option par défaut.</li><li><strong>Le plus proche</strong> : la valeur disponible la plus proche du centile souhaité est utilisée. Dans ce cas, le type de pixel en sortie est identique à celui du raster de valeurs en entrée.</li><li><strong>Linéaire</strong> : la moyenne pondérée des deux valeurs environnantes du centile souhaité est utilisée. Dans ce cas, le type de pixel en sortie est à virgule flottante.</li></ul>",
	"@@Dimensional-Moving-Statistics_percentilevalue_tag0@@": "<p>Centile calculé lorsque le type de statistique<strong>Centile</strong>est sélectionné. La valeur par défaut est de 90, soit le 90e centile.</p><p>Les valeurs peuvent aller de 0 à 100. Le centile n° 0 équivaut essentiellement à la statistique minimale tandis que le 100e centile équivaut à la statistique maximale, à ceci près que le résultat est une virgule flottante. Une valeur de 50 génère le même résultat que la statistique Médiane.</p>",
	"@@Dimensional-Moving-Statistics_statisticstype_tag0@@": "<p>Spécifie le type de statistique à calculer.</p><p></p><ul><li><strong>Moyenne</strong> : la moyenne (valeur moyenne) des cellules dans la fenêtre définie est calculée. Il s’agit de l’option par défaut.</li><li><strong>Moyenne circulaire</strong> : la moyenne circulaire des cellules dans la fenêtre définie est calculée. Lorsque ce type de statistique est sélectionné, le paramètre<strong>Valeur de repli circulaire</strong>devient disponible.</li><li><strong>Majorité</strong> : la majorité (valeur la plus fréquente) des cellules dans la fenêtre définie est identifiée.</li><li><strong>Maximum</strong> : le maximum (valeur la plus élevée) des cellules dans la fenêtre définie est identifié.</li><li><strong>Médiane</strong> : la médiane des cellules du voisinage est identifiée.</li><li><strong>Minimum</strong> : le minimum (valeur la plus faible) des cellules du voisinage est identifié.</li><li><strong>Centile</strong> : un centile des cellules du voisinage est calculé. Lorsque ce type de statistique est sélectionné, les paramètres<strong>Valeur de centile</strong>et<strong>Type d’interpolation en centile</strong>deviennent disponibles. Utilisez ces nouveaux paramètres afin de désigner le centile à calculer et de choisir le type d’interpolation à utiliser, respectivement.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_dimension_tag0@@": "<p>Dimension à utiliser pour l’interpolation.</p><p>Ce paramètre est requis si le paramètre<strong>Définition de la dimension</strong>est défini sur<strong>Par intervalle</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_dimensiondefinition_tag0@@": "<p>Spécifie la méthode utilisée pour filtrer les données multidimensionnelles en entrée avant d’effectuer l’interpolation.</p><ul><li><strong>Par valeurs</strong> : la dimension est découpée en tranches à l’aide d’une valeur de dimension ou d’une liste de valeurs.</li><li><strong>Par intervalle</strong> : la dimension est découpée en tranches selon une plage ou une liste de plages.</li><li><strong>Par raster cible</strong> : la dimension est découpée à l’aide d’un raster multidimensionnel cible spécifique.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_endofinterval_tag0@@": "<p>Fin de l’intervalle, utilisée pour les itérations dans le jeu de données.</p><p>Ce paramètre est requis si le paramètre<strong>Définition de la dimension</strong>est défini sur<strong>Par intervalle</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_ignorenodata_tag0@@": "<p>Spécifie si les valeurs NoData sont ignorées lors de l’analyse.</p><ul><li>Désactivé : l’analyse renvoie une valeur NoData si les tranches adjacentes comportent des valeurs NoData. Il s’agit de l’option par défaut.</li><li>Activé : l’analyse n’utilise que les tranches comportant des pixels valides et ignore les tranches NoData.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_interpolationmethod_tag0@@": "<p>Spécifie la méthode à utiliser pour interpoler le raster.</p><ul><li><strong>Linéaire</strong> : la sortie est interpolée de façon linéaire à l’aide des tranches adjacentes. Il s’agit de l’option par défaut.</li><li><strong>Voisin par défaut</strong> : la sortie utilise la tranche adjacente la plus proche.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_raster_tag0@@": "<p>Raster multidimensionnel en entrée.</p>",
	"@@Interpolate-Raster-By-Dimension_startofinterval_tag0@@": "<p>Début de l’intervalle, utilisé pour les itérations dans le jeu de données.</p><p>Ce paramètre est requis si le paramètre<strong>Définition de la dimension</strong>est défini sur<strong>Par intervalle</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_step_tag0@@": "<p>Fréquence à laquelle les données sont interpolées.</p><p>Ce paramètre est requis si le paramètre<strong>Définition de la dimension</strong>est défini sur<strong>Par intervalle</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_targetraster_tag0@@": "<p>Raster cible spécifié par la définition de la dimension.</p><p>Ce paramètre est requis si le paramètre<strong>Définition de la dimension</strong>est défini sur<strong>Par raster cible</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_unit_tag0@@": "<p>Unité d’intervalle.</p><p>Ce paramètre est requis si le paramètre<strong>Définition de la dimension</strong>est défini sur<strong>Par intervalle</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_values_tag0@@": "<p>Valeurs de dimension à utiliser afin de filtrer les données multidimensionnelles en entrée pour l’analyse.</p><p>Ce paramètre est requis si le paramètre<strong>Définition de la dimension</strong>est défini sur<strong>Par valeurs</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_variables_tag0@@": "<p>La ou les variables interpolées par la définition de la dimension.</p>",
	"@@Terrain-Flatten_calibrationtype_tag0@@": "<p>Indique si le terrain de la sortie est aplani à l’aide de <strong>Sigma zéro</strong> ou <strong>Gamma zéro</strong>.</p><ul><li><strong>Gamma zéro</strong> - La rétrodiffusion bêta zéro est normalisée à l’aide de la surface d’unité d’un plan localement tangent au MNE, couramment appelé angle d’incidence local. Il s’agit de l’option par défaut.</li><li><strong>Sigma zéro</strong> - La rétrodiffusion bêta zéro est normalisée à l’aide d’un MNE pour calculer la surface.</li></ul>",
	"@@Terrain-Flatten_dem_tag0@@": "<p>MNE en entrée.</p><p>Le MNE permet d’estimer la zone locale éclairée.</p>",
	"@@Terrain-Flatten_geoid_tag0@@": "<p>Indique si le système de référence verticale du MNE en entrée est transformé en hauteur ellipsoïdale. La plupart des jeux de données d’élévation étant référencés par rapport à la hauteur orthométrique du niveau de la mer, une correction est donc nécessaire pour effectuer la conversion en hauteur ellipsoïdale.</p><ul><li>Activé - Une correction géodésique est effectuée pour convertir la hauteur orthométrique en hauteur ellipsoïdale (en fonction du géoïde EGM96). Il s’agit de l’option par défaut.</li><li>Désactivé - Aucune correction géodésique n’est effectuée. Utilisez cette option uniquement si le MNE est exprimé en hauteur ellipsoïdale.</li></ul>",
	"@@Terrain-Flatten_raster_tag0@@": "<p>Données radar en entrée.</p><p>Ce raster doit être préalablement calibré par radiométrie sur bêta zéro.</p>",
	"@@Create-Color-Composite_blueexpression_tag0@@": "<p>Calcul affecté à la troisième bande.</p><p>Nom de bande, identifiant de bande ou expression algébrique utilisant les bandes.</p><p>Les opérateurs pris en charge sont unaires : addition (+), soustraction (-), multiplication (*) et division (/).</p>",
	"@@Create-Color-Composite_greenexpression_tag0@@": "<p>Calcul affecté à la deuxième bande.</p><p>Nom de bande, identifiant de bande ou expression algébrique utilisant les bandes.</p><p>Les opérateurs pris en charge sont unaires : addition (+), soustraction (-), multiplication (*) et division (/).</p>",
	"@@Create-Color-Composite_inputraster_tag0@@": "<p>Données raster multibande en entrée.</p>",
	"@@Create-Color-Composite_method_tag0@@": "<p>Indique la méthode à utiliser pour extraire les bandes.</p><ul><li>Noms des bandes - Utilise le nom de la bande représentant l’intervalle de longueur d’onde sur le spectre électromagnétique (rouge, proche infrarouge ou infrarouge thermique, par exemple) ou la polarisation (VH, VV, HH ou HV). Il s’agit de l’option par défaut.</li><li>ID des bandes - Utilise le numéro de la bande (B1, B2, B3, etc.).</li></ul>",
	"@@Create-Color-Composite_redexpression_tag0@@": "<p>Calcul affecté à la première bande.</p><p>Nom de bande, identifiant de bande ou expression algébrique utilisant les bandes.</p><p>Les opérateurs pris en charge sont unaires : addition (+), soustraction (-), multiplication (*) et division (/).</p>",
	"@@Surface-Parameters_localsurfacetype_tag0@@": "<p>Choisir le type de fonction de surface qui est appliqué autour de la cellule cible.</p><ul><li>Quadratique : une fonction de surface quadratique est appliquée aux cellules du voisinage. Il s’agit du type par défaut.</li><li>Biquadratique : une fonction de surface biquadratique est appliquée aux cellules de voisinage.</li></ul>",
	"@@Surface-Parameters_neighborhooddistance_tag0@@": "<p>La sortie est calculée sur cette distance à partir du centre de la cellule cible. Elle détermine la taille du voisinage. La valeur par défaut est la taille de cellule du raster en entrée, soit un voisinage de 3 par 3.</p>",
	"@@Surface-Parameters_outputslopemeasurement_tag0@@": "<p>Unités de mesure (degrés ou pourcentages) utilisées pour le raster de pente en sortie. Ce paramètre est actif uniquement si <strong>Type de paramètre</strong> est défini sur <strong>Pente</strong>.</p><ul><li>Degré : l’inclinaison de la pente est calculée en degrés. Il s’agit de l’option par défaut.</li><li>Pourcentage d’élévation : l’inclinaison de la pente est calculée en pourcentage d’élévation, également désigné sous le nom de pourcentage de pente.</li></ul>",
	"@@Surface-Parameters_parametertype_tag0@@": "<p>Spécifie le type de paramètre de surface en sortie à calculer.</p><ul><li>Pente : le taux de variation de l’élévation est calculé. Il s’agit de l’option par défaut.</li><li>Exposition : la direction de la pente descendante du taux de variation maximal pour chaque cellule est calculée.</li><li>Courbure moyenne : la courbure globale de la surface est mesurée. Elle est calculée comme étant la moyenne des courbures maximale et minimale. Cette courbure décrit la convexité ou la concavité intrinsèque de la surface, indépendamment de la direction ou de l’influence de la gravité.</li><li>Courbure tangentielle (isoligne normale) : la courbure normale géométrique perpendiculaire à la ligne de pente, tangente à l’isoligne, est mesurée. Cette courbure est généralement appliquée pour caractériser la convergence ou la divergence du flux sur la surface.</li><li>Courbure longitudinale (ligne de pente normale) : la courbure normale géométrique le long de la ligne de pente est mesurée. Cette courbure est généralement appliquée pour caractériser l’accélération et la décélération du flux sur la surface.</li><li>Courbure transversale (isoligne projetée) : la courbure le long des isolignes est mesurée.</li><li>Torsion géodésique des isolignes : le taux de variation de l’angle de pente le long des isolignes est mesuré.</li><li>Courbure gaussienne : la courbure globale de la surface est mesurée. Elle est calculée comme le produit des courbures maximale et minimale.</li><li>Courbure Casorati : la courbure générale de la surface est mesurée. Elle peut être égale à zéro ou à tout autre nombre positif.</li></ul>",
	"@@Surface-Parameters_projectgeodesicazimuths_tag0@@": "<p>Spécifie si les azimuts géodésiques sont projetés afin de corriger la distorsion de l’angle provoquée par la référence spatiale en sortie. Ce paramètre est actif uniquement si <strong>Type de paramètre</strong> est défini sur <strong>Exposition</strong>.</p><ul><li>Désactivé : les azimuts géodésiques ne sont pas projetés. Il s’agit de l’option par défaut.</li><li>Activé : les azimuts géodésiques sont projetés.</li></ul>",
	"@@Surface-Parameters_raster_tag0@@": "<p>Raster de surface en entrée. Il peut s’agir d’un raster de type entier ou à virgule flottante.</p>",
	"@@Surface-Parameters_useadaptiveneighborhood_tag0@@": "<p>Spécifie si la distance de voisinage varie selon les changements du paysage (distance adaptative). La distance maximale est déterminée par la distance de voisinage. La distance minimale correspond à la taille de cellule du raster en entrée.</p><ul><li>Désactivé : une distance de voisinage unique (fixe) est utilisée à toutes les localisations. Il s’agit de l’option par défaut.</li><li>Activé : une distance de voisinage adaptative est utilisée à toutes les localisations.</li></ul>",
	"@@Surface-Parameters_useequatorialaspect_tag0@@": "<p>Spécifie si l’exposition est mesurée à partir d’un point sur l’équateur ou à partir du pôle Nord. Ce paramètre est actif uniquement si <strong>Type de paramètre</strong> est défini sur <strong>Exposition</strong>.</p><ul><li>Désactivé : l’exposition est mesurée à partir du pôle Nord. Il s’agit de l’option par défaut.</li><li>Activé : l’exposition est mesurée à partir d’un point sur l’équateur.</li></ul>",
	"@@Surface-Parameters_zunit_tag0@@": "<p>Unité linéaire des valeurs z verticales.</p><p>Elle est définie par un système de coordonnées verticales, s’il en existe un. En l’absence d’un système de coordonnées verticales, l’unité z doit être définie à partir de la liste des unités pour garantir un calcul géodésique correct.</p><ul><li>Pouce : l’unité linéaire est le pouce.</li><li>Pied : l’unité linéaire est le pied.</li><li>Yard : l’unité linéaire est le yard.</li><li>Mile (États-Unis) : l’unité linéaire est le mile.</li><li>Mille nautique : l’unité linéaire est le mille nautique.</li><li>Millimètre : l’unité linéaire est le millimètre.</li><li>Centimètre : l’unité linéaire est le centimètre.</li><li>Mètre : l’unité linéaire est le mètre. Il s’agit de l’option par défaut.</li><li>Kilomètre : l’unité linéaire est le kilomètre.</li><li>Décimètre : l’unité linéaire est le décimètre.</li></ul>",
	"@@Surface-Parameters_analysismask_tag0@@": "<p>Raster indiquant les localisations où l’analyse est effectuée.</p><p>Le raster peut être de type entier ou à virgule flottante.</p><p>Toutes les cellules ayant une valeur valide, zéro y compris, composent le masque. Les cellules NoData dans le masque de saisie auront une valeur NoData dans la sortie.</p>",
	"@@Geometric-Median_cellsizetype_tag0@@": "<p>Sélectionnez la taille de cellule à utiliser dans le raster en sortie. Si toutes les tailles de cellule en entrée sont identiques, toutes les options donnent les mêmes résultats.</p><ul><li>Premier de : utiliser la première taille de cellule des rasters en entrée.</li><li>Min de : utiliser la plus petite taille de cellule de tous les rasters en entrée.</li><li>Max de : utiliser la plus grande taille de cellule de tous les rasters en entrée. Il s’agit de l’option par défaut.</li><li>Moyenne de : utiliser la taille de cellule moyenne de tous les rasters en entrée.</li><li>Dernier de : utiliser la dernière taille de cellule des rasters en entrée.</li></ul>",
	"@@Geometric-Median_epsilon_tag0@@": "<p>Spécifie la valeur de convergence entre deux itérations consécutives. Si epsilon est inférieur ou égal à la valeur spécifiée, l’itération s’arrête et le résultat de la dernière itération est utilisé.</p>",
	"@@Geometric-Median_extenttype_tag0@@": "<p>Sélectionnez l’étendue à utiliser dans le raster en sortie :</p><ul><li><p>Premier de : utiliser l’étendue du premier raster en entrée pour déterminer l’étendue de traitement.</p></li><li>Intersection de : utiliser l’étendue des pixels superposés pour déterminer l’étendue de traitement. Il s’agit de l’option par défaut.</li><li>Union de : utiliser l’étendue de tous les rasters pour déterminer l’étendue de traitement.</li><li>Dernier de : utiliser l’étendue du dernier raster en entrée pour déterminer l’étendue de traitement.</li></ul>",
	"@@Geometric-Median_maximumnumberofiterations_tag0@@": "<p>Spécifie le nombre maximal d’itérations à effectuer. Le calcul prend fin lorsque cette valeur est atteinte, quelle que soit la valeur du paramètre <strong>Epsilon</strong>.</p>",
	"@@Geometric-Median_rasters_tag0@@": "<p>Rasters multibandes en entrée.</p>",
	"@@Least-Cost-Corridor_inputaccumulativecostdistanceraster1_tag0@@": "<p>Raster en entrée représentant la distance de coût cumulé pour la première source.</p><p>Il doit s’agir d’une distance de coût cumulé générée en sortie de la fonction <strong>Accumulation de distance</strong> ou <strong>Allocation de distance</strong>.</p>",
	"@@Least-Cost-Corridor_inputaccumulativecostdistanceraster2_tag0@@": "<p>Raster en entrée représentant la distance de coût cumulé pour la deuxième source.</p><p>Il doit s’agir d’une distance de coût cumulé générée en sortie de la fonction <strong>Accumulation de distance</strong> ou <strong>Allocation de distance</strong>.</p>",
	"@@Least-Cost-Corridor_inputbackdirectionraster1_tag0@@": "<p>Raster de direction arrière en entrée pour la première source.</p><p>Il s’agit d’un jeu de données raster indiquant la direction de la cellule suivante sur le chemin de moindre coût en revenant vers la première source. Il doit s’agir de la sortie générée par la fonction <strong>Accumulation de distance</strong> ou <strong>Allocation de distance</strong>.</p>",
	"@@Least-Cost-Corridor_inputbackdirectionraster2_tag0@@": "<p>Raster de direction arrière en entrée pour la seconde source.</p><p>Il s’agit d’un jeu de données raster indiquant la direction de la cellule suivante sur le chemin de moindre coût en revenant vers la première source. Il doit s’agir de la sortie générée par la fonction <strong>Accumulation de distance</strong> ou <strong>Allocation de distance</strong>.</p>",
	"@@Least-Cost-Corridor_threshold_tag0@@": "<p>Pourcentage ou seuil de coût cumulé qui détermine si une cellule donnée est ou non incluse dans le raster de couloir en sortie.</p><p>Lorsque le paramètre <strong>Méthode de seuil</strong> est défini sur <strong>Pourcentage de moindre coût</strong>, la valeur spécifiée indique le pourcentage de hausse à appliquer à partir de la valeur minimale des rasters de distance de coût cumulé additionnés. Lorsque le paramètre <strong>Méthode de seuil</strong> est défini sur <strong>Coût cumulé</strong>, la valeur indique les cellules dont la somme du coût cumulé est inférieure ou égale à la valeur à inclure dans le couloir.</p><p>Ce paramètre est actif uniquement si le paramètre <strong>Méthode de seuil</strong> est défini sur <strong>Pourcentage de moindre coût</strong> ou <strong>Coût cumulé</strong>.</p>",
	"@@Least-Cost-Corridor_thresholdmethod_tag0@@": "<p>Indique le mode de définition du seuil.</p><p></p><ul><li><strong>Aucun seuil</strong> : aucun seuil n’est appliqué et le couloir généré couvre l’étendue entière des rasters en entrée. Il s’agit de l’option par défaut.</li><li><strong>Pourcentage de moindre coût</strong> : le seuil est exprimé en un pourcentage de la valeur minimale des rasters de distance de coût cumulé additionnés.</li><li><strong>Coût cumulé</strong> : le seuil est exprimé en unités de distance de coût cumulé.</li></ul>"
};
const helpTexts_fr = {
	rfxArgsHelpTexts: rfxArgsHelpTexts
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (helpTexts_fr);


//# sourceMappingURL=help-texts.fr-7671a600.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTMzYTZlZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxHQUFHO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFlBQVk7QUFDL0YsMEZBQTBGLFlBQVk7QUFDdEcsb0ZBQW9GLFlBQVk7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyUkFBMlIsS0FBSztBQUNoUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxLQUFLO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJOQUEyTixPQUFPO0FBQ2xPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb1hBQW9YLGFBQWEsS0FBSyxVQUFVO0FBQ2haO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbVhBQW1YLGFBQWEsS0FBSyxVQUFVO0FBQy9ZO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtYQUFrWCxhQUFhLEtBQUssVUFBVTtBQUM5WTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUksUUFBUTtBQUMzSTtBQUNBLG9JQUFvSSxPQUFPO0FBQzNJO0FBQ0E7QUFDQSxzR0FBc0csRUFBRSxxRkFBcUYsSUFBSTtBQUNqTTtBQUNBLDRHQUE0RyxFQUFFLE9BQU8sSUFBSTtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNlBBQTZQLE9BQU87QUFDcFE7QUFDQTtBQUNBLGdHQUFnRyxRQUFRO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdVJBQXVSLE9BQU87QUFDOVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixRQUFRO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsUUFBUTtBQUM5RixtSEFBbUgsUUFBUTtBQUMzSCxtSkFBbUosT0FBTyw4Q0FBOEMsT0FBTztBQUMvTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZLQUE2SyxHQUFHO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxRQUFRO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMENBQTBDLHdFQUF3RSxJQUFJLHlFQUF5RSxJQUFJO0FBQzlPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5U0FBeVMsT0FBTztBQUNoVCwyTkFBMk4sT0FBTztBQUNsTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvWEFBb1gsYUFBYSxLQUFLLFVBQVU7QUFDaFo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySkFBMkosMkRBQTJELE9BQU87QUFDN04sbUdBQW1HLE9BQU87QUFDMUc7QUFDQSw0RkFBNEYsUUFBUSw0SEFBNEgsT0FBTztBQUN2Tyw2RkFBNkYsUUFBUSwwSEFBMEgsT0FBTztBQUN0TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLFFBQVE7QUFDekcsc0xBQXNMLFFBQVEsdUVBQXVFLFFBQVE7QUFDN1EsdU5BQXVOLFFBQVE7QUFDL047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbzBDQUFvMEMsWUFBWTtBQUNoMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtYQUFrWCxhQUFhLEtBQUssVUFBVTtBQUM5WTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCswQ0FBKzBDLFlBQVk7QUFDMzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZYQUE2WCxhQUFhLEtBQUssVUFBVTtBQUN6WjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsODBDQUE4MEMsWUFBWTtBQUMxMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRYQUE0WCxhQUFhLEtBQUssVUFBVTtBQUN4WjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCx5QkFBeUI7QUFDako7QUFDQSw4S0FBOEssOEJBQThCO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsTUFBTTtBQUMxRixpSkFBaUosT0FBTyxLQUFLLE1BQU07QUFDbks7QUFDQTtBQUNBLGdPQUFnTyxNQUFNO0FBQ3RPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaU9BQWlPO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5TkFBeU47QUFDek47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLFdBQVcsNEpBQTRKLFdBQVc7QUFDdFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1IQUFtSCxPQUFPO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0csc0RBQXNEO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEksS0FBSywwSkFBMEosTUFBTTtBQUNqVDtBQUNBO0FBQ0EsNk1BQTZNLGlCQUFpQjtBQUM5TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxRQUFRO0FBQ3BGLHlGQUF5RixRQUFRLDhIQUE4SCxRQUFRO0FBQ3ZPLDRMQUE0TCxPQUFPLHdFQUF3RSxPQUFPLDRHQUE0RyxPQUFPO0FBQ3JZO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCxFQUFFO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0MENBQTQwQyxZQUFZO0FBQ3gxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseVhBQXlYLGFBQWEsS0FBSyxVQUFVO0FBQ3JaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDAwQ0FBMDBDLFlBQVk7QUFDdDFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1WEFBdVgsYUFBYSxLQUFLLFVBQVU7QUFDblo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdVFBQXVRO0FBQ3ZRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrU0FBa1M7QUFDbFM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFlBQVksRUFBQztBQUNBOztBQUU1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL2hlbHAtdGV4dHMuZnItNzY3MWE2MDAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmZ4QXJnc0hlbHBUZXh0cyA9IHtcblx0XCJAQEFic19DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEFic19DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQWJzX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBYnNfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEFic19DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQWJzX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQWJzX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEFic19FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQWJzX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEFic19FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQWJzX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQWJzX1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSBkb250IHZvdXMgY2FsY3VsZXogbGVzIHZhbGV1cnMgYWJzb2x1ZXMuXCIsXG5cdFwiQEBBQ29zX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAQUNvc19DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQUNvc19DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQUNvc19DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQUNvc19DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQUNvc19DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFDb3NfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAQUNvc19FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQUNvc19FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBBQ29zX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBBQ29zX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQUNvc19SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSBwb3VyIGxhcXVlbGxlIGNhbGN1bGVyIGxlcyB2YWxldXJzIGRlIGNvc2ludXMgaW52ZXJzZS5cIixcblx0XCJAQEFDb3NIX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAQUNvc0hfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFDb3NIX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQUNvc0hfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFDb3NIX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQUNvc0hfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAQUNvc0hfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEFDb3NIX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEFDb3NIX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBBQ29zSF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEFDb3NIX1Jhc3Rlcl90YWcwQEBcIjogXCJFbnRyw6llIHBvdXIgbGFxdWVsbGUgY2FsY3VsZXIgbGVzIHZhbGV1cnMgZGUgY29zaW51cyBoeXBlcmJvbGlxdWUgaW52ZXJzZS5cIixcblx0XCJAQEFwcGFyZW50LVJlZmxlY3RhbmNlX0FsYmVkb190YWcwQEBcIjogXCJMZXMgcsOpc3VsdGF0cyBkZSBsYSBmb25jdGlvbiBkZSByw6lmbGVjdGFuY2UgYXBwYXJlbnRlIHBldXZlbnQgw6lnYWxlbWVudCDDqnRyZSBleHByaW3DqXMgZW4gYWxiw6lkbywgcG91cmNlbnRhZ2UgZGUgbCfDqW5lcmdpZSBkaXNwb25pYmxlIHLDqWZsw6ljaGllIHBhciBsYSBzdXJmYWNlIHBsYW7DqXRhaXJlLiBMZXMgZG9ubsOpZXMgYWxiw6lkbyBzb250IHV0aWxpc8OpZXMgcGFyIGRlcyBzY2llbnRpZmlxdWVzIGRhbnMgbGUgY2FkcmUgZCdhcHBsaWNhdGlvbnMgdGVjaG5pcXVlcyBkZSB0w6lsw6lkw6l0ZWN0aW9uIGV0IGRlIG1vZMOpbGlzYXRpb24gY29tcGxleGVzLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfQWxiZWRvX3RhZzFAQFwiOiBcIk5vbiBjb2Now6kgOiBsYSBmb25jdGlvbiByZW52b2llIGxlcyB2YWxldXJzIGRlIHLDqWZsZWN0YW5jZSBhcHBhcmVudGUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9BbGJlZG9fdGFnMkBAXCI6IFwiQ29jaMOpIDogbGEgZm9uY3Rpb24gcmVudm9pZSBkZXMgdmFsZXVycyDDoCB2aXJndWxlIGZsb3R0YW50ZSAzMiBiaXRzLCBnw6luw6lyYWxlbWVudCBjb21wcmlzZXMgZW50cmUgMC4wIGV0IDEuMC4gQXVjdW4gZMOpY291cGFnZSBkZSBkb25uw6llIG4nZXN0IGVmZmVjdHXDqSBzaSBjZXR0ZSBvcHRpb24gZXN0IHPDqWxlY3Rpb25uw6llLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfQWxiZWRvX3RhZzNAQFwiOiBcIkxlIHR5cGUgZGUgZG9ubsOpZXMgZW4gc29ydGllIHBvdXIgbOKAmWFsYsOpZG8gw6l0YW50IGxlIG5vbWJyZSDDoCB2aXJndWxlIGZsb3R0YW50ZSwgdm91cyBkZXZleiBkw6lmaW5pciBleHBsaWNpdGVtZW50IGxlIDxzdHJvbmc+VHlwZSBkZSBwaXhlbCBlbiBzb3J0aWU8L3N0cm9uZz4gcXVpIGNvbnZpZW50IGxlIG1pZXV4IChub21icmUgw6AgdmlyZ3VsZSBmbG90dGFudGUgMzIgYml0cyBvdSBkb3VibGUgNjQgYml0cykuIExlIHBhcmFtw6h0cmUgPHN0cm9uZz5UeXBlIGRlIHBpeGVsIGVuIHNvcnRpZTwvc3Ryb25nPiBmaWd1cmUgc3VyIGzigJlvbmdsZXQgPHN0cm9uZz5Hw6luw6lyYWw8L3N0cm9uZz4gZGUgbGEgZm9uY3Rpb24gcmFzdGVyIDxzdHJvbmc+UsOpZmxlY3RhbmNlIGFwcGFyZW50ZTwvc3Ryb25nPi4gU2kgbGUgPHN0cm9uZz5UeXBlIGRlIHBpeGVsIGVuIHNvcnRpZTwvc3Ryb25nPiBu4oCZZXN0IHBhcyBjb3JyZWN0ZW1lbnQgZMOpZmluaSBwb3VyIGzigJlvcHRpb24gPHN0cm9uZz5BbGLDqWRvPC9zdHJvbmc+LCBsZXMgdmFsZXVycyByw6lzdWx0YW50ZXMgbmUgc2Vyb250IHBhcyB2YWxpZGVzIGV0IHNlcm9udCBkw6lmaW5pZXMgc3VyIDAuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9PZmZzZXRfdGFnMEBAXCI6IFwiVm90cmUgdmFsZXVyIGFsYsOpZG8gbWlzZSDDoCBsJ8OpY2hlbGxlIHBldXQgY29tcG9ydGVyIHVuZSB2YWxldXIgZGUgZMOpY2FsYWdlIDpcIixcblx0XCJAQEFwcGFyZW50LVJlZmxlY3RhbmNlX09mZnNldF90YWcxQEBcIjogXCJQb3VyIGxlcyB0eXBlcyBkZSBkb25uw6llcyAxNiBiaXRzIG5vbiBzaWduw6llcywgbGUgZMOpY2FsYWdlIGQnw6ljaGVsbGUgcGFyIGTDqWZhdXQgZXN0IDUgMDAwLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfT2Zmc2V0X3RhZzJAQFwiOiBcIlBvdXIgbGVzIHR5cGVzIGRlIGRvbm7DqWVzIDggYml0cyBub24gc2lnbsOpZXMsIGxlIGTDqWNhbGFnZSBkJ8OpY2hlbGxlIHBhciBkw6lmYXV0IGVzdCAwLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfT2Zmc2V0X3RhZzNAQFwiOiBcIkF1Y3VuZSBtaXNlIMOgIGwnw6ljaGVsbGUgbidlc3QgYXBwbGlxdcOpZSBsb3JzcXVlIGxhIHNvcnRpZSBlc3QgdW5lIHZhbGV1ciBhbGLDqWRvLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfUmFkaWFuY2UtR2FpbnMtYW5kLUJpYXMtVmFsdWVzLXBlci1CYW5kX3RhZzBAQFwiOiBcIlZvdXMgcG91dmV6IGTDqWZpbmlyIG91IG1vZGlmaWVyIG1hbnVlbGxlbWVudCBjZXR0ZSB2YWxldXIgcG91ciBjaGFxdWUgY2FuYWwuIExlcyBpbmZvcm1hdGlvbnMgYXBwcm9wcmnDqWVzIHBldXZlbnQgw6p0cmUgbHVlcyDDoCBwYXJ0aXIgZGVzIG3DqXRhZG9ubsOpZXMgZHUgcHJvZHVpdCByYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQEFwcGFyZW50LVJlZmxlY3RhbmNlX1Jhc3Rlcl90YWcwQEBcIjogXCJMZSBwcm9kdWl0IHJhc3RlciBzdXIgbGVxdWVsIGFwcGxpcXVlciBsYSByw6lmbGVjdGFuY2UgYXBwYXJlbnRlLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfU2NhbGUtRmFjdG9yX3RhZzBAQFwiOiBcIkxhIHZhbGV1ciBlbiBzb3J0aWUgZGUgdm90cmUgcsOpZmxlY3RhbmNlIGFwcGFyZW50ZSBwZXV0IHMnZXhwcmltZXIgc291cyBsYSBmb3JtZSBkJ3VuIGVudGllci4gTGUgZmFjdGV1ciBkJ8OpY2hlbGxlIGVzdCBtdWx0aXBsacOpIHBhciBsYSB2YWxldXIgYWxiw6lkbyBwb3VyIGNvbnZlcnRpciB0b3V0ZXMgbGVzIHZhbGV1cnMgw6AgdmlyZ3VsZSBmbG90dGFudGUgZW4gdmFsZXVycyBlbnRpw6hyZXMuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9TY2FsZS1GYWN0b3JfdGFnMUBAXCI6IFwiU2kgbGUgZmFjdGV1ciBk4oCZw6ljaGVsbGUgZXN0ICR7MH0gb3UgbuKAmWVzdCBwYXMgc3DDqWNpZmnDqSwgbGEgbWlzZSDDoCBs4oCZw6ljaGVsbGUgcGFyIGTDqWZhdXQgZXN0IGFwcGxpcXXDqWUgc2Vsb24gbGUgdHlwZSBkZSBwaXhlbCBkZXMgZG9ubsOpZXMgZW4gZW50csOpZSA6XCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9TY2FsZS1GYWN0b3JfdGFnMkBAXCI6IFwiUG91ciBsZXMgdHlwZXMgZGUgZG9ubsOpZXMgMTYgYml0cyBub24gc2lnbsOpZXMsIGxlIGZhY3RldXIgZCfDqWNoZWxsZSBwYXIgZMOpZmF1dCBlc3QgNTAgMDAwLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfU2NhbGUtRmFjdG9yX3RhZzNAQFwiOiBcIlBvdXIgbGVzIHR5cGVzIGRlIGRvbm7DqWVzIDggYml0cyBub24gc2lnbsOpZXMsIGxlIGZhY3RldXIgZCfDqWNoZWxsZSBwYXIgZMOpZmF1dCBlc3QgMjI1LlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfU2NhbGUtRmFjdG9yX3RhZzRAQFwiOiBcIkxlIGZhY3RldXIgZCfDqWNoZWxsZSBlc3QgdG91am91cnMgYXBwbGlxdcOpIGxvcnNxdWUgbGEgc29ydGllIGVzdCB1bmUgcsOpZmxlY3RhbmNlIGFwcGFyZW50ZS4gQXVjdW5lIG1pc2Ugw6AgbCfDqWNoZWxsZSBuJ2VzdCBhcHBsaXF1w6llIGxvcnNxdWUgbGEgc29ydGllIGVzdCB1bmUgdmFsZXVyIGFsYsOpZG8uXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9TdW4tRWxldmF0aW9uX3RhZzBAQFwiOiBcIklsIHMnYWdpdCBkZSBsYSB2YWxldXIgZCdhbHRpdHVkZSBkdSBzb2xlaWwsIGV4cHJpbcOpZSBlbiBkZWdyw6lzLiBFbGxlIGVzdCByZW5zZWlnbsOpZSBwYXIgbGUgc3lzdMOobWUgc2kgbGVzIGluZm9ybWF0aW9ucyBhcHByb3ByacOpZXMgc29udCBsaXNpYmxlcyDDoCBwYXJ0aXIgZGVzIG3DqXRhZG9ubsOpZXMuIFZvdXMgcG91dmV6IGTDqWZpbmlyIG91IG1vZGlmaWVyIG1hbnVlbGxlbWVudCBjZXR0ZSB2YWxldXIuXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX01heF90YWcwQEBcIjogXCJMYSB2YWxldXIgbWF4aW1hbGUgcXVlIHZvdXMgZMOpZmluaXNzZXogZXN0IGxhIHZhbGV1ciBsYSBwbHVzIGhhdXRlIGluZsOpcmlldXJlIG91IMOpZ2FsZSDDoCBsYSBmaW4gZGUgbGEgZHVyw6llLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19NYXhfdGFnMUBAXCI6IFwiQ2V0dGUgZW50csOpZSBz4oCZYXBwbGlxdWUgdW5pcXVlbWVudCBkYW5zIGxlIGNhcyBkZSBsYSBtw6l0aG9kZSBEdXJhdGlvbi5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfTWV0aG9kX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbGEgbcOpdGhvZGUgZGUgc3RhdGlzdGlxdWVzIMOgIGNhbGN1bGVyIDpcIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfTWV0aG9kX3RhZzFAQFwiOiBcIkFyZyBNYXggOiBhcmd1bWVudCBkdSBtYXhpbXVtLCBxdWkgcmVudm9pZSBsZSAke0JhbmQgaW5kZXh9IHBvdXIgbGVxdWVsIGxlIHBpeGVsIGRvbm7DqSBhdHRlaW50IHNhIHZhbGV1ciBtaW5pbWFsZSBkZSB0b3VzIGxlcyBjYW5hdXguIFRvdXMgbGVzIGNhbmF1eCBkZSByYXN0ZXIgcHJvdmVuYW50IGRlIGNoYXF1ZSByYXN0ZXIgZW4gZW50csOpZSBzZSB2b2llbnQgYXR0cmlidWVyIHVuIGluZGV4IGRlIGNhbmFsIGluY3LDqW1lbnRpZWwgZGUgYmFzZSAwLCBxdWkgZXN0IGNsYXNzw6kgZOKAmWFib3JkIHNlbG9uIGzigJlpbmRleCBkZSByYXN0ZXIgZW4gZW50csOpZSwgcHVpcyBzZWxvbiBs4oCZb3JkcmUgcmVsYXRpZiBkZXMgY2FuYXV4IGRhbnMgY2hhcXVlIHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19NZXRob2RfdGFnMkBAXCI6IFwiQXJnIE1lZGlhbiA6IGFyZ3VtZW50IGRlIGxhIG3DqWRpYW5lLCBxdWkgcmV0b3VybmUgbGUgJHtCYW5kIGluZGV4fSBwb3VyIGxlcXVlbCBsZSBwaXhlbCBkb25uw6kgYXR0ZWludCBsYSB2YWxldXIgbcOpZGlhbmUgZGVzIHZhbGV1cnMgZGUgdG91cyBsZXMgY2FuYXV4LlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19NZXRob2RfdGFnM0BAXCI6IFwiQXJnIE1pbiA6IGFyZ3VtZW50IGR1IG1pbmltdW0sIHF1aSByZXRvdXJuZSBsZSAke0JhbmQgaW5kZXh9IHBvdXIgbGVxdWVsIGxlIHBpeGVsIGRvbm7DqSBhdHRlaW50IHNhIHZhbGV1ciBtaW5pbWFsZSBkZSB0b3VzIGxlcyBjYW5hdXguXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX01ldGhvZF90YWc0QEBcIjogXCJEdXLDqWUgOiBsYSBtw6l0aG9kZSBEdXLDqWUgdHJvdXZlIGxlcyDDqWzDqW1lbnRzIGNvbnPDqWN1dGlmcyBsZXMgcGx1cyBsb25ncyBkZSBsYSBtYXRyaWNlLCBvw7kgY2hhcXVlIMOpbMOpbWVudCBwb3Nzw6hkZSB1bmUgdmFsZXVyIHN1cMOpcmlldXJlIG91IMOpZ2FsZSDDoCA8c3Ryb25nPk1pbjwvc3Ryb25nPiBldCBpbmbDqXJpZXVyZSBvdSDDqWdhbGUgw6AgPHN0cm9uZz5NYXg8L3N0cm9uZz4sIHB1aXMgcmVudm9pZSBsYSBsb25ndWV1ciBkZSBjaGFjdW4uXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX01pbl90YWcwQEBcIjogXCJMYSB2YWxldXIgbWluaW1hbGUgcXVlIHZvdXMgZMOpZmluaXNzZXogZXN0IGxhIHZhbGV1ciBsYSBwbHVzIGJhc3NlIHN1cMOpcmlldXJlIG91IMOpZ2FsZSBhdSBkw6lidXQgZGUgbGEgZHVyw6llLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19NaW5fdGFnMUBAXCI6IFwiQ2V0dGUgZW50csOpZSBz4oCZYXBwbGlxdWUgdW5pcXVlbWVudCBkYW5zIGxlIGNhcyBkZSBsYSBtw6l0aG9kZSBEdXJhdGlvbi5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfUmFzdGVyc190YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSBzdXIgbGVxdWVsIHZvdXMgYWxsZXogZXjDqWN1dGVyIGxlcyBkaWZmw6lyZW50cyBtw6l0aG9kZXMgc3RhdGlzdGlxdWVzLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19VbmRlZmluZWQtQ2xhc3NfdGFnMEBAXCI6IFwiQ29uc3RhbnRlIGVuIGVudHLDqWUgcXVpIHNlcmEgcmV0b3VybsOpZSBzaSBhdWN1biBtYXhpbXVtLCBtaW5pbXVtIG91IG3DqWRpYW5lIG5lIHBldXQgw6p0cmUgYXR0ZWludC4gTGUgc2PDqW5hcmlvIGxlIHBsdXMgY291cmFudCBzZSBwcm9kdWl0IGxvcnNxdWUgbGEgdmFsZXVyIG1heGltYWxlIG91IG1pbmltYWxlIHN1cnZpZW50IHBsdXNpZXVycyBmb2lzIHBhcm1pIGxlcyB2YWxldXJzIGRlIHRvdXMgbGVzIGNhbmF1eC4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGR1IGNoYW1wIGRlIGxhIGNvbnN0YW50ZSBub24gZMOpZmluaWUgZXN0IDEwMC5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfVW5kZWZpbmVkLUNsYXNzX3RhZzFAQFwiOiBcIkxhIGNsYXNzZSBub24gZMOpZmluaWUgY29uY2VybmUgdW5pcXVlbWVudCBsZXMgY2FzIGRhbnMgbGVzcXVlbHMgbGEgbcOpdGhvZGUgZXN0IDxzdHJvbmc+QXJnTWF4PC9zdHJvbmc+LCA8c3Ryb25nPkFyZ01pbjwvc3Ryb25nPiBvdSA8c3Ryb25nPkFyZ01lZGlhbjwvc3Ryb25nPi5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfaWdub3Jlbm9kYXRhX3RhZzBAQFwiOiBcIkluZGlxdWUgc2kgbGVzIHZhbGV1cnPCoE5vRGF0YSBzb250IGlnbm9yw6llcyBkYW5zIGxlIGNhbGN1bCBkZXMgc3RhdGlzdGlxdWVzLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19pZ25vcmVub2RhdGFfdGFnMUBAXCI6IFwiQWN0aXbDqcKgOiBs4oCZYW5hbHlzZSBpbmNsdXQgdG91cyBsZXMgcGl4ZWxzIHZhbGlkZXMgZGFucyBsZXMgcmFzdGVycyBlbiBlbnRyw6llIGV0IGlnbm9yZSBsZXMgcGl4ZWxzwqBOb0RhdGEuXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX2lnbm9yZW5vZGF0YV90YWcyQEBcIjogXCJEw6lzYWN0aXbDqcKgOiBs4oCZYW5hbHlzZSByZW52b2llIGRlcyB2YWxldXJzwqBOb0RhdGEgc2kgbGVzIHBpeGVscyBkYW5zIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUgcHLDqXNlbnRlbnQgZGVzIHZhbGV1cnPCoE5vRGF0YS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEFyaXRobWV0aWNfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBBcml0aG1ldGljX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBcml0aG1ldGljX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBcml0aG1ldGljX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBBcml0aG1ldGljX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBcml0aG1ldGljX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQXJpdGhtZXRpY19FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBBcml0aG1ldGljX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBBcml0aG1ldGljX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEFyaXRobWV0aWNfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEFyaXRobWV0aWNfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWcwQEBcIjogXCJPcMOpcmF0ZXVyIGFyaXRobcOpdGlxdWUgw6AgZWZmZWN0dWVyIGVudHJlIGxlcyBkZXV4IHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFyaXRobWV0aWNfT3BlcmF0aW9uX3RhZzFAQFwiOiBcIkxlcyBvcHRpb25zIHNvbnQgbGVzIHN1aXZhbnRlcyA6XCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWcyQEBcIjogXCI8c3Ryb25nPkRpdmlzaW9uPC9zdHJvbmc+IDogZ8OpbsOocmUgbGUgcXVvdGllbnQgZW50cmUgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIGNvcnJlc3BvbmRhbnRlcyBwb3VyIGNoYXF1ZSByYXN0ZXIuXCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWc0QEBcIjogXCI8c3Ryb25nPlNvdXN0cmFjdGlvbjwvc3Ryb25nPiA6IGfDqW7DqHJlIGxhIGRpZmbDqXJlbmNlIGVudHJlIGxlcyB2YWxldXJzIGRlIHBpeGVscyBjb3JyZXNwb25kYW50ZXMgcG91ciBjaGFxdWUgcmFzdGVyLiBDZWxhIHBlcm1ldCBkZSBjYWxjdWxlciBsYSBkw6l0ZWN0aW9uIGRlcyBjaGFuZ2VtZW50cy5cIixcblx0XCJAQEFyaXRobWV0aWNfT3BlcmF0aW9uX3RhZzZAQFwiOiBcIjxzdHJvbmc+TW9kZTwvc3Ryb25nPiA6IGfDqW7DqHJlIGxhIHZhbGV1ciBkZSBwaXhlbCBsYSBwbHVzIGZyw6lxdWVudGUgcG91ciB0b3VzIGxlcyBwaXhlbHMgc3VwZXJwb3PDqXMuIFNpLCBwYXIgZXhlbXBsZSwgbGUgcmFzdGVyIGNvbXB0ZSBzaXggYmFuZGVzLCBpbCB5IGF1cmEgc2l4IHBpeGVscyBzdXBlcnBvc8Opcy4gUG91ciBsZXMgdmFsZXVycyA0LCA1LCA2LCA0LCA3LCA5LCBsYSB2YWxldXIgZGUgbW9kZSBlc3QgNC5cIixcblx0XCJAQEFyaXRobWV0aWNfT3BlcmF0aW9uX3RhZzhAQFwiOiBcIjxzdHJvbmc+TXVsdGlwbGljYXRpb248L3N0cm9uZz4gOiBnw6luw6hyZSBsZSBwcm9kdWl0IGRlcyB2YWxldXJzIGRlIHBpeGVscyBjb3JyZXNwb25kYW50ZXMgcG91ciBjaGFxdWUgcmFzdGVyLiBDZXR0ZSBvcHRpb24gcGVybWV0IGTigJlleMOpY3V0ZXIgZGVzIGZvbmN0aW9ucyBkZSBjb8O7dC5cIixcblx0XCJAQEFyaXRobWV0aWNfT3BlcmF0aW9uX3RhZzEwQEBcIjogXCI8c3Ryb25nPkFkZGl0aW9uPC9zdHJvbmc+IDogZ8OpbsOocmUgbGEgc29tbWUgZGUgdG91dGVzIGxlcyB2YWxldXJzIGRlIHBpeGVscyBjb3JyZXNwb25kYW50ZXMgcG91ciBjaGFxdWUgcmFzdGVyLlwiLFxuXHRcIkBAQXJpdGhtZXRpY19PcGVyYXRpb25fdGFnMTJAQFwiOiBcIjxzdHJvbmc+UHVpc3NhbmNlPC9zdHJvbmc+IDogZ8OpbsOocmUgbGUgcHJvZHVpdCBkZXMgdmFsZXVycyBkZSBwaXhlbHMgY29ycmVzcG9uZGFudGVzLCDDqWxldsOpIMOgIGxhIHB1aXNzYW5jZSBkdSByYXN0ZXIgb3Ugc2NhbGFpcmUgZW4gZW50csOpZS5cIixcblx0XCJAQEFyaXRobWV0aWNfUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHByZW1pZXIgamV1IGRlIGRvbm7DqWVzIHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQXJpdGhtZXRpY19SYXN0ZXIyX3RhZzBAQFwiOiBcIkRldXhpw6htZSBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBU2luX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFTaW5fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAQVNpbl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQVNpbl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBBU2luX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBBU2luX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQVNpbl9SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSBwb3VyIGxhcXVlbGxlIGNhbGN1bGVyIGxlcyB2YWxldXJzIGRlIHNpbnVzIGludmVyc2UuXCIsXG5cdFwiQEBBU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEFTaW5IX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQVNpbkhfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEFTaW5IX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFTaW5IX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEFTaW5IX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBBU2luSF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBBU2luSF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQVNpbkhfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBBU2luSF9SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSBwb3VyIGxhcXVlbGxlIGNhbGN1bGVyIGxlcyB2YWxldXJzIGRlIHNpbnVzIGh5cGVyYm9saXF1ZSBpbnZlcnNlLlwiLFxuXHRcIkBAQXNwZWN0X1Jhc3Rlcl90YWcwQEBcIjogXCJMZSBNTkEgdXRpbGlzw6kgcG91ciBkw6lyaXZlciBsZSBqZXUgZGUgZG9ubsOpZXMgZOKAmWV4cG9zaXRpb24uXCIsXG5cdFwiQEBBc3BlY3QtU2xvcGVfUmFzdGVyX3RhZzBAQFwiOiBcIkRFTSBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQXNwZWN0LVNsb3BlX1otRmFjdG9yX3RhZzBAQFwiOiBcIlVuIGZhY3RldXIgZOKAmcOpY2hlbGxlIHV0aWxpc8OpIHBvdXIgY29udmVydGlyIGxlcyB2YWxldXJzIGTigJlhbHRpdHVkZSBkYW5zIGxlcyBkZXV4IGJ1dHMgc3VpdmFudHMgOlwiLFxuXHRcIkBAQXNwZWN0LVNsb3BlX1otRmFjdG9yX3RhZzFAQFwiOiBcIkNvbnZlcnRpdCBsZXMgdW5pdMOpcyBkJ2FsdGl0dWRlICh0ZWxsZXMgcXVlIGxlcyBtw6h0cmVzIG91IGxlcyBwaWVkcykgZW4gdW5pdMOpcyBkZSBjb29yZG9ubsOpZXMgaG9yaXpvbnRhbGVzIGR1IGpldSBkZSBkb25uw6llcywgcXVpIHBldXZlbnQgw6p0cmUgZGVzIHBpZWRzLCBkZXMgbcOodHJlcyBvdSBkZXMgZGVncsOpcyxcIixcblx0XCJAQEFzcGVjdC1TbG9wZV9aLUZhY3Rvcl90YWcyQEBcIjogXCJBam91dGUgdW5lIGV4YWfDqXJhdGlvbiB2ZXJ0aWNhbGUgY29tbWUgZWZmZXQgdmlzdWVsLlwiLFxuXHRcIkBAQVRhbl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEFUYW5fQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFUYW5fQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFUYW5fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEFUYW5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFUYW5fQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBVGFuX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEFUYW5fRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEFUYW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQVRhbl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQVRhbl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEFUYW5fUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgcG91ciBsYXF1ZWxsZSBjYWxjdWxlciBsZXMgdmFsZXVycyBkZSB0YW5nZW50ZSBpbnZlcnNlLlwiLFxuXHRcIkBAQVRhbjJfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBBVGFuMl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQVRhbjJfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFUYW4yX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBBVGFuMl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQVRhbjJfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBVGFuMl9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBBVGFuMl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQVRhbjJfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQVRhbjJfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEFUYW4yX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQVRhbjJfUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgc3DDqWNpZmlhbnQgbGUgbnVtw6lyYXRldXIsIG91IGxhIHZhbGV1ciB5LCDDoCB1dGlsaXNlciBsb3JzIGR1IGNhbGN1bCBkZSBsYSB0YW5nZW50ZSBpbnZlcnNlLlwiLFxuXHRcIkBAQVRhbjJfUmFzdGVyMl90YWcwQEBcIjogXCJFbnRyw6llIHNww6ljaWZpYW50IGxlIGTDqW5vbWluYXRldXIsIG91IGxhIHZhbGV1ciB4LCDDoCB1dGlsaXNlciBsb3JzIGR1IGNhbGN1bCBkZSBsYSB0YW5nZW50ZSBpbnZlcnNlLlwiLFxuXHRcIkBAQVRhbkhfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBBVGFuSF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQVRhbkhfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEFUYW5IX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBBVGFuSF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQVRhbkhfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBVGFuSF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBBVGFuSF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQVRhbkhfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQVRhbkhfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEFUYW5IX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQVRhbkhfUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgcG91ciBsYXF1ZWxsZSBjYWxjdWxlciBsZXMgdmFsZXVycyBkZSB0YW5nZW50ZSBoeXBlcmJvbGlxdWUgaW52ZXJzZS5cIixcblx0XCJAQEF0dHJpYnV0ZS1UYWJsZV9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBdHRyaWJ1dGUtVGFibGVfVGFibGUtVHlwZV90YWcwQEBcIjogXCJMYSB0YWJsZSBhdHRyaWJ1dGFpcmUgZW4gZW50csOpZSBwZXV0IMOqdHJlIHJlbnNlaWduw6llIMOgIGzigJlhaWRlIGR1IHR5cGUgPHN0cm9uZz5NYW51ZWw8L3N0cm9uZz4gb8O5IHZvdXMgYXR0cmlidWV6IHVuIG5vbSBkZSBjbGFzc2UgZXQgdW5lIGNvdWxldXIgw6AgY2hhcXVlIHZhbGV1ciwgb3Ugdm91cyBwb3V2ZXogZmFpcmUgcsOpZsOpcmVuY2Ugw6AgdW5lIHRhYmxlIGV4aXN0YW50ZSBxdWkgcHJvdmllbnQgZOKAmXVuIGZpY2hpZXIgJHsuZGJmfS5cIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19CYW5kLUluZGV4ZXNfdGFnMEBAXCI6IFwiRMOpZmluaXNzZXogdm90cmUgZm9ybXVsZSBhcml0aG3DqXRpcXVlIGRlIGJhbmRlIHNpIHZvdXMgYXZleiBjaG9pc2kgPHN0cm9uZz5Ew6lmaW5pIHBhciBs4oCZdXRpbGlzYXRldXI8L3N0cm9uZz4gcG91ciA8c3Ryb25nPk3DqXRob2RlPC9zdHJvbmc+LlwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX0JhbmQtSW5kZXhlc190YWc1QEBcIjogXCJTaSB2b3VzIGF2ZXogY2hvaXNpIHVuIGluZGljZSBwcsOpZMOpZmluaSBwb3VyIDxzdHJvbmc+TcOpdGhvZGU8L3N0cm9uZz4sIGTDqWZpbmlzc2V6IGxlcyBiYW5kZXMgYXBwcm9wcmnDqWVzIGRlIHZvdHJlIGpldSBkZSBkb25uw6llcyByYXN0ZXIgZW4gZW50csOpZSBjb3JyZXNwb25kYW50IMOgIGzigJlpbmRpY2UuXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzBAQFwiOiBcIlR5cGUgZOKAmWFsZ29yaXRobWUgYXJpdGhtw6l0aXF1ZSBkZSBjYW5hbCBxdWUgdm91cyBzb3VoYWl0ZXogZMOpcGxveWVyLiBWb3VzIHBvdXZleiBkw6lmaW5pciB2b3RyZSBhbGdvcml0aG1lIHBlcnNvbm5hbGlzw6kgb3UgY2hvaXNpciB1biBpbmRpY2UgcHLDqWTDqWZpbmkuXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzFAQFwiOiBcIjxzdHJvbmc+QkFJPC9zdHJvbmc+wqA6IGluZGljZSBkZSB6b25lcyBicsO7bMOpZXNcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMkBAXCI6IFwiPHN0cm9uZz5DSWc8L3N0cm9uZz7CoDogaW5kaWNlIGNobG9yb3BoeWxsaWVuIC0gVmVydFwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPkNJcmU8L3N0cm9uZz7CoDogaW5kaWNlIGNobG9yb3BoeWxsaWVuIC0gUHJvY2hlIGluZnJhcm91Z2VcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnNEBAXCI6IFwiPHN0cm9uZz5NaW7DqXJhdXggYXJnaWxldXg8L3N0cm9uZz7CoDogcmFwcG9ydCBkZSBtaW7DqXJhdXggYXJnaWxldXhcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnNUBAXCI6IFwiPHN0cm9uZz5FVkk8L3N0cm9uZz7CoDogaW5kaWNlIGRlIHbDqWfDqXRhdGlvbiBhbcOpbGlvcsOpXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzZAQFwiOiBcIjxzdHJvbmc+TWluw6lyYXV4IGZlcnJldXg8L3N0cm9uZz7CoDogcmFwcG9ydCBkZSBtaW7DqXJhdXggZmVycmV1eFwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWc3QEBcIjogXCI8c3Ryb25nPkdFTUk8L3N0cm9uZz7CoDogaW5kaWNlIGRlIHN1cnZlaWxsYW5jZSBlbnZpcm9ubmVtZW50YWxlIGdsb2JhbGVcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnOEBAXCI6IFwiPHN0cm9uZz5HTkRWSTwvc3Ryb25nPsKgOiBpbmRpY2UgZGUgdsOpZ8OpdGF0aW9uIHBhciBkaWZmw6lyZW5jZSBub3JtYWxpc8OpZSAtIFZlcnRcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnOUBAXCI6IFwiPHN0cm9uZz5HVkkgKExhbmRzYXQgVE0pPC9zdHJvbmc+wqA6IGluZGljZSBkZSB2w6lnw6l0YXRpb24gLSBMYW5kc2F0IFRNXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzEwQEBcIjogXCI8c3Ryb25nPk94eWRlIGRlIGZlcjwvc3Ryb25nPsKgOiByYXBwb3J0IGTigJlveHlkZSBkZSBmZXJcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMTFAQFwiOiBcIjxzdHJvbmc+TU5EV0k8L3N0cm9uZz7CoDogaW5kaWNlIGRlIHRlbmV1ciBlbiBlYXUgbW9kaWZpw6kgcGFyIGRpZmbDqXJlbmNlIG5vcm1hbGlzw6llXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzEyQEBcIjogXCI8c3Ryb25nPk1UVkkyPC9zdHJvbmc+wqA6IGluZGljZSBkZSB2w6lnw6l0YXRpb24gdHJpYW5ndWzDqSBtb2RpZmnDqSAoZGV1eGnDqG1lIGl0w6lyYXRpb24pXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzEzQEBcIjogXCI8c3Ryb25nPlNBVkkgbW9kaWZpw6k8L3N0cm9uZz7CoDogaW5kaWNlIGRlIHbDqWfDqXRhdGlvbiBhanVzdMOpIGVuIGZvbmN0aW9uIGR1IHNvbCBldCBtb2RpZmnDqVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcxNEBAXCI6IFwiPHN0cm9uZz5OQlI8L3N0cm9uZz7CoDogaW5kaWNlIGR1IHJhdGlvIGRlIGJyw7tsdXJlIG5vcm1hbGlzw6lcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMTVAQFwiOiBcIjxzdHJvbmc+TkRCSTwvc3Ryb25nPsKgOiBpbmRpY2UgZOKAmXVyYmFuaXNhdGlvbiBwYXIgZGlmZsOpcmVuY2Ugbm9ybWFsaXPDqWVcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMTZAQFwiOiBcIjxzdHJvbmc+TkRNSTwvc3Ryb25nPsKgOiBpbmRpY2UgZCdodW1pZGl0w6kgcGFyIGRpZmbDqXJlbmNlIG5vcm1hbGlzw6llXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzE3QEBcIjogXCI8c3Ryb25nPk5EU0k8L3N0cm9uZz7CoDogaW5kaWNlIGTigJllbm5laWdlbWVudCBwYXIgZGlmZsOpcmVuY2Ugbm9ybWFsaXPDqWVcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMThAQFwiOiBcIjxzdHJvbmc+TkRWSTwvc3Ryb25nPsKgOiBpbmRpY2UgZGUgdsOpZ8OpdGF0aW9uIHBhciBkaWZmw6lyZW5jZSBub3JtYWxpc8OpZVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcxOUBAXCI6IFwiPHN0cm9uZz5ORFZJcmU8L3N0cm9uZz7CoDogaW5kaWNlIGRlIHbDqWfDqXRhdGlvbiBwYXIgZGlmZsOpcmVuY2Ugbm9ybWFsaXPDqWUgLSBQcm9jaGUgaW5mcmFyb3VnZVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyMEBAXCI6IFwiPHN0cm9uZz5ORFdJPC9zdHJvbmc+wqA6IGluZGljZSBkZSB0ZW5ldXIgZW4gZWF1IHBhciBkaWZmw6lyZW5jZSBub3JtYWxpc8OpZVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyMUBAXCI6IFwiPHN0cm9uZz5QVkk8L3N0cm9uZz7CoDogaW5kaWNlIGRlIHbDqWfDqXRhdGlvbiBwZXJwZW5kaWN1bGFpcmVcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjJAQFwiOiBcIjxzdHJvbmc+UlRWSUNvcmU8L3N0cm9uZz7CoDogaW5kaWNlIGRlIHbDqWfDqXRhdGlvbiB0cmlhbmd1bMOpIC0gUHJvY2hlIGluZnJhcm91Z2VcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjNAQFwiOiBcIjxzdHJvbmc+U0FWSTwvc3Ryb25nPsKgOiBpbmRpY2UgZGUgdsOpZ8OpdGF0aW9uIGFqdXN0w6kgZW4gZm9uY3Rpb24gZHUgc29sXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzI0QEBcIjogXCI8c3Ryb25nPlNSPC9zdHJvbmc+wqA6IHJhdGlvIHNpbXBsZVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyNUBAXCI6IFwiPHN0cm9uZz5TUnJlPC9zdHJvbmc+wqA6IHJhdGlvIHNpbXBsZSAtIFByb2NoZSBpbmZyYXJvdWdlXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzI2QEBcIjogXCI8c3Ryb25nPkZvcm11bGUgZGUgU3VsdGFuPC9zdHJvbmc+wqA6IGZvcm11bGUgZGUgU3VsdGFuXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzI3QEBcIjogXCI8c3Ryb25nPlNBVkkgdHJhbnNmb3Jtw6k8L3N0cm9uZz7CoDogaW5kaWNlIGRlIHbDqWfDqXRhdGlvbiBhanVzdMOpIGVuIGZvbmN0aW9uIGR1IHNvbCBldCB0cmFuc2Zvcm3DqVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyOEBAXCI6IFwiPHN0cm9uZz5Ew6lmaW5pIHBhciBs4oCZdXRpbGlzYXRldXI8L3N0cm9uZz7CoDogcGVybWV0IGRlIGTDqWZpbmlyIHZvdHJlIGV4cHJlc3Npb24gYXJpdGhtw6l0aXF1ZSBkZSBjYW5hbCBwZXJzb25uYWxpc8OpLlwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyOUBAXCI6IFwiPHN0cm9uZz5WQVJJPC9zdHJvbmc+wqA6IGluZGljZSB2aXNpYmxlIGRlIHLDqWR1Y3Rpb24gZGVzIGVmZmV0cyBhdG1vc3Bow6lyaXF1ZXNcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMzBAQFwiOiBcIjxzdHJvbmc+V05EV0k8L3N0cm9uZz7CoDogaW5kaWNlIGRlIHbDqWfDqXRhdGlvbiBwYXIgZGlmZsOpcmVuY2Ugbm9ybWFsaXPDqWUgcG9uZMOpcsOpXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQmluYXJ5LVRocmVzaG9sZGluZ19SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQml0d2lzZS1BbmRfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQml0d2lzZS1BbmRfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9SYXN0ZXJfdGFnMEBAXCI6IFwiUHJlbWnDqHJlIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJpdCDDoCBiaXQuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9SYXN0ZXJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQEJpdHdpc2UtQW5kX1Jhc3RlcjJfdGFnMEBAXCI6IFwiRGV1eGnDqG1lIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJpdCDDoCBiaXQuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9SYXN0ZXIyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBCaXR3aXNlLUxlZnQtU2hpZnRfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBCaXR3aXNlLUxlZnQtU2hpZnRfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQml0d2lzZS1MZWZ0LVNoaWZ0X0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCaXR3aXNlLUxlZnQtU2hpZnRfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBCaXR3aXNlLUxlZnQtU2hpZnRfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCaXR3aXNlLUxlZnQtU2hpZnRfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSBzdXIgbGFxdWVsbGUgZXjDqWN1dGVyIGxlIGTDqWNhbGFnZS5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9SYXN0ZXJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9SYXN0ZXIyX3RhZzBAQFwiOiBcIkVudHLDqWUgZMOpZmluaXNzYW50IGxlIG5vbWJyZSBkZSBwb3NpdGlvbnMgZHVxdWVsIGTDqXBsYWNlciBsZXMgYml0cy5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9SYXN0ZXIyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEJpdHdpc2UtTm90X0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQml0d2lzZS1Ob3RfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEJpdHdpc2UtTm90X0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJpdHdpc2UtTm90X0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEJpdHdpc2UtTm90X0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQml0d2lzZS1Ob3RfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgc3VyIGxlcXVlbCBleMOpY3V0ZXIgdW5lIG9ww6lyYXRpb24gZGUgY29tcGzDqW1lbnQgTm9uIGJpdCDDoCBiaXQuXCIsXG5cdFwiQEBCaXR3aXNlLU9yX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJpdHdpc2UtT3JfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCaXR3aXNlLU9yX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCaXR3aXNlLU9yX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9SYXN0ZXJfdGFnMEBAXCI6IFwiUHJlbWnDqHJlIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJpdCDDoCBiaXQuXCIsXG5cdFwiQEBCaXR3aXNlLU9yX1Jhc3Rlcl90YWcxQEBcIjogXCJVbmUgdmFsZXVyIGNvbnN0YW50ZSBwZXV0IMOqdHJlIHV0aWxpc8OpZSBlbiBlbnRyw6llIHBvdXIgY2UgcGFyYW3DqHRyZSwgw6AgY29uZGl0aW9uIHF14oCZdW4gcmFzdGVyIHNvaXQgc3DDqWNpZmnDqSBwb3VyIGzigJlhdXRyZSBwYXJhbcOodHJlLlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9SYXN0ZXIyX3RhZzBAQFwiOiBcIkRldXhpw6htZSBlbnRyw6llIMOgIHV0aWxpc2VyIGRhbnMgY2V0dGUgb3DDqXJhdGlvbiBiaXQgw6AgYml0LlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9SYXN0ZXIyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSBzdXIgbGFxdWVsbGUgZXjDqWN1dGVyIGxlIGTDqWNhbGFnZS5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfUmFzdGVyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X1Jhc3RlcjJfdGFnMEBAXCI6IFwiRW50csOpZSBkw6lmaW5pc3NhbnQgbGUgbm9tYnJlIGRlIHBvc2l0aW9ucyBkdXF1ZWwgZMOpcGxhY2VyIGxlcyBiaXRzLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9SYXN0ZXIyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQml0d2lzZS1Yb3JfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQml0d2lzZS1Yb3JfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9SYXN0ZXJfdGFnMEBAXCI6IFwiUHJlbWnDqHJlIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJpdCDDoCBiaXQuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9SYXN0ZXJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQEJpdHdpc2UtWG9yX1Jhc3RlcjJfdGFnMEBAXCI6IFwiRGV1eGnDqG1lIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJpdCDDoCBiaXQuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9SYXN0ZXIyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9SYXN0ZXJfdGFnMEBAXCI6IFwiUHJlbWnDqHJlIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJvb2zDqWVubmUuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9SYXN0ZXJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQEJvb2xlYW4tYW5kX1Jhc3RlcjJfdGFnMEBAXCI6IFwiRGV1eGnDqG1lIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJvb2zDqWVubmUuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9SYXN0ZXIyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBCb29sZWFuLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEJvb2xlYW4tTm90X0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCb29sZWFuLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEJvb2xlYW4tTm90X0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCb29sZWFuLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJvb2xlYW4tTm90X0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEJvb2xlYW4tTm90X0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCb29sZWFuLU5vdF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCb29sZWFuLU5vdF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCb29sZWFuLU5vdF9SYXN0ZXJfdGFnMEBAXCI6IFwiUHJlbWnDqHJlIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJvb2zDqWVubmUuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJvb2xlYW4tT3JfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9SYXN0ZXJfdGFnMEBAXCI6IFwiUHJlbWnDqHJlIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJvb2zDqWVubmUuXCIsXG5cdFwiQEBCb29sZWFuLU9yX1Jhc3Rlcl90YWcxQEBcIjogXCJVbmUgdmFsZXVyIGNvbnN0YW50ZSBwZXV0IMOqdHJlIHV0aWxpc8OpZSBlbiBlbnRyw6llIHBvdXIgY2UgcGFyYW3DqHRyZSwgw6AgY29uZGl0aW9uIHF14oCZdW4gcmFzdGVyIHNvaXQgc3DDqWNpZmnDqSBwb3VyIGzigJlhdXRyZSBwYXJhbcOodHJlLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9SYXN0ZXIyX3RhZzBAQFwiOiBcIkRldXhpw6htZSBlbnRyw6llIMOgIHV0aWxpc2VyIGRhbnMgY2V0dGUgb3DDqXJhdGlvbiBib29sw6llbm5lLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9SYXN0ZXIyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQm9vbGVhbi1Yb3JfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQm9vbGVhbi1Yb3JfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9SYXN0ZXJfdGFnMEBAXCI6IFwiUHJlbWnDqHJlIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJvb2zDqWVubmUuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9SYXN0ZXJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQEJvb2xlYW4tWG9yX1Jhc3RlcjJfdGFnMEBAXCI6IFwiRGV1eGnDqG1lIGVudHLDqWUgw6AgdXRpbGlzZXIgZGFucyBjZXR0ZSBvcMOpcmF0aW9uIGJvb2zDqWVubmUuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9SYXN0ZXIyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBCdWZmZXJlZF9SYXN0ZXJfdGFnMEBAXCI6IFwiTGUgcmFzdGVyIGVuIGVudHLDqWUgw6Agc3RvY2tlciBlbiBtw6ltb2lyZS5cIixcblx0XCJAQENhbGN1bGF0b3JfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJMYSB0YWlsbGUgZGUgY2VsbHVsZSB1dGlsaXPDqWUgcG91ciBjcsOpZXIgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQENhbGN1bGF0b3JfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJWb3VzIHBvdXZleiBjaG9pc2lyIGxhIHRhaWxsZSBkZSBjZWxsdWxlIGVuIHNvcnRpZSDDoCBs4oCZYWlkZSBkZXMgb3B0aW9ucyBzdWl2YW50ZXMgZGUgbGEgbGlzdGUgZMOpcm91bGFudGUgOlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIjxzdHJvbmc+UHJlbWllciBkZTwvc3Ryb25nPiA6IHRhaWxsZSBkZSBjZWxsdWxlIGRlIGxhIHByZW1pw6hyZSB2YXJpYWJsZSByYXN0ZXIuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiPHN0cm9uZz5NaW4gZGU8L3N0cm9uZz4gOiB0YWlsbGUgZGUgY2VsbHVsZSBtaW5pbWFsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9DZWxsc2l6ZS1UeXBlX3RhZzZAQFwiOiBcIjxzdHJvbmc+TWF4IGRlPC9zdHJvbmc+IDogdGFpbGxlIGRlIGNlbGx1bGUgbWF4aW1hbGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQENhbGN1bGF0b3JfQ2VsbHNpemUtVHlwZV90YWc4QEBcIjogXCI8c3Ryb25nPk1veWVubmUgZGU8L3N0cm9uZz4gOiB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0NlbGxzaXplLVR5cGVfdGFnMTBAQFwiOiBcIjxzdHJvbmc+RGVybmllciBkZTwvc3Ryb25nPiA6IHRhaWxsZSBkZSBjZWxsdWxlIGRlIGxhIGRlcm5pw6hyZSB2YXJpYWJsZSByYXN0ZXIuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0NlbGxzaXplLVR5cGVfdGFnMTJAQFwiOiBcIkxhIHPDqWxlY3Rpb24gcGFyIGTDqWZhdXQgZXN0IDxzdHJvbmc+TWF4IGRlPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzBAQFwiOiBcIkNvbnN0cnVpcmUgdW5lIGV4cHJlc3Npb24gYWxnw6licmlxdWUgcG91ciBlZmZlY3R1ZXIgbOKAmWFuYWx5c2Ugc3BhdGlhbGUgc3VyIGxlIHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzFAQFwiOiBcIlRvdXRlcyBsZXMgZm9uY3Rpb25zIG1hdGjDqW1hdGlxdWVzIGV4aXN0YW50ZXMgcGV1dmVudCDDqnRyZSBhcHBlbMOpZXMgcG91ciBjb25zdHJ1aXJlIGzigJlleHByZXNzaW9uLiBMZXMgb3DDqXJhdGV1cnMgZGlzcG9uaWJsZXMgc29udCByw6lwZXJ0b3Jpw6lzIGNpLWRlc3NvdXMuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMkBAXCI6IFwiT3DDqXJhdGlvbnMgYXJpdGhtw6l0aXF1ZXNcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWczQEBcIjogXCJBZGRpdGlvbiA6ICtcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWc0QEBcIjogXCJEaXZpc2lvbiA6IC9cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWc1QEBcIjogXCJNb2R1bG8gOiAlXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnNkBAXCI6IFwiTXVsdGlwbGljYXRpb24gOiAqXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnN0BAXCI6IFwiUHVpc3NhbmNlIDogKipcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWc4QEBcIjogXCJTb3VzdHJhY3Rpb24gOiAtXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnOUBAXCI6IFwiT3DDqXJhdGlvbnMgYm9vbMOpZW5uZXNcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxMEBAXCI6IFwiRXQgYm9vbMOpZW4gOiAmJlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzExQEBcIjogXCJPdSBib29sw6llbiA6IHx8XCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMTJAQFwiOiBcIk9ww6lyYXRpb25zIHJlbGF0aW9ubmVsbGVzXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMTNAQFwiOiBcIsOJZ2FsIMOgIDo9PVwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzE0QEBcIjogXCJTdXDDqXJpZXVyIMOgIDogPlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzE1QEBcIjogXCJTdXDDqXJpZXVyIG91IMOpZ2FsIMOgIDogPj1cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxNkBAXCI6IFwiSW5mw6lyaWV1ciDDoCA6IDxcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxN0BAXCI6IFwiSW5mw6lyaWV1ciBvdSDDqWdhbCDDoCA6IDw9XCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMThAQFwiOiBcIk7igJllc3QgcGFzIMOpZ2FsIMOgIDogIT1cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxOUBAXCI6IFwiT3DDqXJhdGlvbnMgc3VwcGzDqW1lbnRhaXJlc1wiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzIwQEBcIjogXCJNaW5pbXVtIGRlIGRldXggcmFzdGVycywgcGl4ZWwgcGFyIHBpeGVsIDogbWluKGEsYilcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcyMUBAXCI6IFwiTWF4aW11bSBkZSBkZXV4IHJhc3RlcnMsIHBpeGVsIHBhciBwaXhlbCA6IG1heChhLGIpXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMjJAQFwiOiBcIlZvaWNpIHF1ZWxxdWVzIGV4ZW1wbGVzIGTigJlleHByZXNzaW9ucy5cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcyM0BAXCI6IFwiSW5zdHJ1Y3Rpb24gY29uZGl0aW9ubmVsbGUgc2ltcGxlIDogZGFucyB1biByYXN0ZXIgKGluZGlxdcOpIHBhciBsYSBsZXR0cmUgVCkgcmVjaGVyY2hleiBsZXMgdmFsZXVycyBk4oCZYWx0aXR1ZGUgc3Vww6lyaWV1cmVzIMOgIDQgMDAwIHBpZWRzIGV0IGF0dHJpYnVleiDDoCBjZXMgem9uZXMgbGEgdmFsZXVyIDEgZXQgbGEgdmFsZXVyIDAgw6AgdG91dGVzIGxlcyBhdXRyZXMgem9uZXMuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMjRAQFwiOiBcIkNvbihUID4gNDAwMCwgMSwgMClcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcyNUBAXCI6IFwiSW5zdHJ1Y3Rpb24gY29uZGl0aW9ubmVsbGUgaW1icmlxdcOpZSA6IHJlY2hlcmNoZXogbGVzIHpvbmVzIG/DuSBsYSBwZW50ZSAoaW5kaXF1w6llIHBhciBiMSkpIGVzdCBpbmbDqXJpZXVyZSDDoCAxMCBkZWdyw6lzIGV0IGzigJlpbmRpY2UgTkRWSSAoaW5kaXF1w6kgcGFyIGIyKSBlc3Qgc3Vww6lyaWV1ciDDoCAwLDUsIGV0IGF0dHJpYnVleiDDoCBjZXMgem9uZXMgbGEgdmFsZXVyIDEuIFBvdXIgdG91dGVzIGxlcyBhdXRyZXMgem9uZXMsIGF0dHJpYnVleiBsYSB2YWxldXIgMiBzaSBsYSBwZW50ZSBlc3Qgc3Vww6lyaWV1cmUgw6AgMTAgZGVncsOpcyBldCBs4oCZYWx0aXR1ZGUgKGluZGlxdcOpZSBwYXIgYjMpIGVzdCBzdXDDqXJpZXVyZSDDoCAyIDUwMCBwaWVkcy4gTGEgdmFsZXVyIDMgZXN0IGF0dHJpYnXDqWUgw6AgdG91dGVzIGxlcyBhdXRyZXMgem9uZXMuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMjZAQFwiOiBcIkNvbigoYjEgPCAxMCAmJiBiMiA+IC41LCAxLCBDb24oYjEgPiAxMCAmJiBiMyA+IDI1MDAsIDIsIDMpKSlcIixcblx0XCJAQENhbGN1bGF0b3JfZXh0ZW50dHlwZV90YWcwQEBcIjogXCI8cD5Tw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWXCoDo8L3A+PHVsPjxsaT48cD5QcmVtaWVyIGRlwqA6IHV0aWxpc2VyIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuPC9wPjwvbGk+PGxpPkludGVyc2VjdGlvbiBkZcKgOiB1dGlsaXNlciBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPlVuaW9uIGRlwqA6IHV0aWxpc2VyIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuPC9saT48bGk+RGVybmllciBkZcKgOiB1dGlsaXNlciBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LjwvbGk+PC91bD5cIixcblx0XCJAQENhbGN1bGF0b3JfUmFzdGVyLVZhcmlhYmxlc190YWcwQEBcIjogXCJMZSBub20gZGUgbGEgdmFyaWFibGUgZMOpZmluaWUgcGFyIGzigJl1dGlsaXNhdGV1ciBldCBsZSByYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQENsYXNzaWZ5X0lucHV0LURlZmluaXRpb24tRmlsZV90YWcwQEBcIjogXCJGaWNoaWVyIGRlIGTDqWZpbml0aW9uIGRlIGNsYXNzaWZpY2F0ZXVyIEVzcmkgZW4gZW50csOpZSAoJHsuZWNkfSkgcXVpIGNvbnRpZW50IGxlcyBzdGF0aXN0aXF1ZXMgZXQgZOKAmWF1dHJlcyBpbmZvcm1hdGlvbnMgZGUgY2xhc3NpZmljYXRpb24gcG91ciBsZSBqZXUgZGUgZG9ubsOpZXMsIGxlIGNsYXNzaWZpY2F0ZXVyIGV0IGxlcyBhdHRyaWJ1dHMgY2hvaXNpcy5cIixcblx0XCJAQENsYXNzaWZ5X1Jhc3Rlcl90YWcwQEBcIjogXCJKZXUgZGUgZG9ubsOpZXMgcmFzdGVyIMOgIGNsYXNzZXIuXCIsXG5cdFwiQEBDbGFzc2lmeV9SYXN0ZXIyX3RhZzBAQFwiOiBcIkpldSBkZSBkb25uw6llcyByYXN0ZXIgYXV4aWxpYWlyZSBmYWN1bHRhdGlmIMOgIGluY29ycG9yZXIgYXUgY2xhc3NpZmljYXRldXIsIHRlbCBxdeKAmXVuZSBpbWFnZSBzZWdtZW50w6llLCB1bmUgaW1hZ2UgbXVsdGlzcGVjdHJhbGUgb3UgZGVzIGRvbm7DqWVzIGTigJlhbHRpdHVkZSwgdXRpbGlzw6kgcG91ciBnw6luw6lyZXIgdW5lIGTDqWZpbml0aW9uIGRlIGNsYXNzaWZpY2F0aW9uIHBsdXMgcm9idXN0ZSBwb3VyIHZvdHJlIGVuc2VtYmxlIGRlIGRvbm7DqWVzLiBMZSBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIHBvdXIgY2UgcGFyYW3DqHRyZSBkb2l0IGNvcnJlc3BvbmRyZSDDoCBjZWx1aSBxdWkgYSDDqXTDqSB1dGlsaXPDqSBwb3VyIGNyw6llciBsZSBmaWNoaWVyIGRlIGTDqWZpbml0aW9uIGRlIGNsYXNzaWZpY2F0ZXVyIEVzcmkgZW4gZW50csOpZS5cIixcblx0XCJAQENsaXBfQ2xpcHBpbmctR2VvbWV0cnktb3ItUmFzdGVyX3RhZzBAQFwiOiBcIkxlcyDDqWzDqW1lbnRzIHN1aXZhbnRzIHBldXZlbnQgw6p0cmUgdXRpbGlzw6lzIHBvdSBzcMOpY2lmaWVyIGzigJnDqXRlbmR1ZSBkZSBkw6ljb3VwYWdlIDpcIixcblx0XCJAQENsaXBfQ2xpcHBpbmctR2VvbWV0cnktb3ItUmFzdGVyX3RhZzFAQFwiOiBcIjxzdHJvbmc+RMOpY291cGFnZSBkdSByYXN0ZXI8L3N0cm9uZz4gOiDDqXRlbmR1ZSBkZSBkw6ljb3VwYWdlIGR1IHJhc3Rlci5cIixcblx0XCJAQENsaXBfQ2xpcHBpbmctR2VvbWV0cnktb3ItUmFzdGVyX3RhZzNAQFwiOiBcIjxzdHJvbmc+w4l0ZW5kdWUgcGVyc29ubmFsaXPDqWU8L3N0cm9uZz4gOiBjb29yZG9ubsOpZXMgWCBldCBZIG1pbmltYWxlcyBldCBtYXhpbWFsZXNcIixcblx0XCJAQENsaXBfQ2xpcHBpbmctR2VvbWV0cnktb3ItUmFzdGVyX3RhZzVAQFwiOiBcIjxzdHJvbmc+w4l0ZW5kdWUgYWN0dWVsbGUgZGUgbGEgY2FydGU8L3N0cm9uZz4gOiDDqXRlbmR1ZSBkZSBs4oCZYWZmaWNoYWdlIGNhcnRvZ3JhcGhpcXVlIGFjdHVlbFwiLFxuXHRcIkBAQ2xpcF9DbGlwcGluZy1SYXN0ZXJfdGFnMEBAXCI6IFwiTGEgY291Y2hlIHJhc3RlciB1dGlsaXPDqWUgcG91ciBsZSBkw6ljb3VwYWdlLlwiLFxuXHRcIkBAQ2xpcF9DbGlwcGluZy1UeXBlX3RhZzBAQFwiOiBcIkluZGlxdWV6IHNpIHZvdXMgdm91bGV6IHF1ZSBsYSB6b25lIGZpZ3VyZSDDoCBs4oCZaW50w6lyaWV1ciBvdSDDoCBs4oCZZXh0w6lyaWV1ciBkZSBsYSBnw6lvbcOpdHJpZSBkZSBkw6ljb3VwYWdlLlwiLFxuXHRcIkBAQ2xpcF9DbGlwcGluZy1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+RMOpY291cGFnZSBpbnTDqXJpZXVyPC9zdHJvbmc+IDogbOKAmWltYWdlcmllIHF1aSBzZSB0cm91dmUgZGFucyBs4oCZw6l0ZW5kdWUgZGUgZMOpY291cGFnZSBzZXJhIHN1cHByaW3DqWUuXCIsXG5cdFwiQEBDbGlwX0NsaXBwaW5nLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5Ew6ljb3VwYWdlIGV4dMOpcmlldXI8L3N0cm9uZz4gOiBs4oCZaW1hZ2VyaWUgcXVpIHNlIHRyb3V2ZSBob3JzIGRlIGzigJnDqXRlbmR1ZSBkZSBkw6ljb3VwYWdlIHNlcmEgc3VwcHJpbcOpZS5cIixcblx0XCJAQENsaXBfQ3VzdG9tLUV4dGVudF90YWcwQEBcIjogXCJTcMOpY2lmaWVyIGxlcyBxdWF0cmUgY29vcmRvbm7DqWVzIHF1aSBkw6lmaW5pc3NlbnQgbOKAmcOpdGVuZHVlIGRlIGzigJllbXByaXNlIHV0aWxpc8OpZSBwb3VyIGTDqWNvdXBlciBsZSByYXN0ZXIuXCIsXG5cdFwiQEBDbGlwX091dHB1dC1FeHRlbnRfdGFnMEBAXCI6IFwiTGVzIGNvb3Jkb25uw6llcyB4IGV0IHkgZGUgbOKAmcOpdGVuZHVlIGRlIGTDqWNvdXBhZ2UgYWN0dWVsbGUuXCIsXG5cdFwiQEBDbGlwX091dHB1dC1FeHRlbnRfdGFnMUBAXCI6IFwiTGUgYm91dG9uIDxzdHJvbmc+Q2FwdHVyZXIgbOKAmcOpdGVuZHVlIGFjdHVlbGxlIGRlIGxhIGNhcnRlPC9zdHJvbmc+IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGTigJlhZmZpY2hhZ2UgZGUgbGEgY2FydGUgYWN0aXZlLlwiLFxuXHRcIkBAQ2xpcF9SYXN0ZXJfdGFnMEBAXCI6IFwiQ291Y2hlIHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQ2xpcF9Vc2UtSW5wdXQtRmVhdHVyZXMtZm9yLUNsaXBwaW5nLUdlb21ldHJ5X3RhZzBAQFwiOiBcIlVuZSBmb2lzIHPDqWxlY3Rpb25uw6llcywgbGVzIGRvbm7DqWVzIHNvbnQgZMOpY291cMOpZXMgc2Vsb24gbGEgZ8Opb23DqXRyaWUgZGUgbGEgY2xhc3NlIGTigJllbnRpdMOpcyBzcMOpY2lmacOpZVwiLFxuXHRcIkBAQ2xpcF9Vc2UtSW5wdXQtRmVhdHVyZXMtZm9yLUNsaXBwaW5nLUdlb21ldHJ5X3RhZzFAQFwiOiBcIkTDqXNhY3RpdsOpIDogbGEgZm9uY3Rpb24gdXRpbGlzZSBsYSBnw6lvbcOpdHJpZSBkZSBkw6ljb3VwYWdlIHNww6ljaWZpw6llIHBhciBs4oCZb3B0aW9uIDxzdHJvbmc+UmVjdGFuZ2xlPC9zdHJvbmc+LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQ2xpcF9Vc2UtSW5wdXQtRmVhdHVyZXMtZm9yLUNsaXBwaW5nLUdlb21ldHJ5X3RhZzRAQFwiOiBcIkNvY2jDqSA6IGxhIGZvbmN0aW9uIHV0aWxpc2UgbGEgZ8Opb23DqXRyaWUgZGUgZMOpY291cGFnZSBkw6lmaW5pZSBwYXIgdW5lIGNsYXNzZSBk4oCZZW50aXTDqXMuXCIsXG5cdFwiQEBDb2xvci1Nb2RlbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tVHlwZV90YWcwQEBcIjogXCJMZSB0eXBlIGRlIGNvbnZlcnNpb24gZGUgY291bGV1ciDDoCBlZmZlY3R1ZXIgOlwiLFxuXHRcIkBAQ29sb3ItTW9kZWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLVR5cGVfdGFnMUBAXCI6IFwiVFNMIHZlcnMgUlZCXCIsXG5cdFwiQEBDb2xvci1Nb2RlbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tVHlwZV90YWcyQEBcIjogXCJSVkIgdmVycyBUU0xcIixcblx0XCJAQENvbG9yLU1vZGVsLUNvbnZlcnNpb25fUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3ItUmFtcF90YWcwQEBcIjogXCJDaG9pc2lzc2V6IHVuIGTDqWdyYWTDqSBkZSBjb3VsZXVycyBleGlzdGFudC5cIixcblx0XCJAQENvbG9ybWFwX0NvbG9yLVNjaGVtZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGUgdHlwZSBkZSBjb21iaW5haXNvbiBkZSBjb3VsZXVycyDDoCB1dGlsaXNlciBwb3VyIGFmZmljaGVyIHZvdHJlIHJhc3RlciBlbiBlbnRyw6llXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvci1TY2hlbWUtVHlwZV90YWcxQEBcIjogXCJEw6lncmFkw6kgZGUgY291bGV1cnMgOiB1dGlsaXNleiB1biBkw6lncmFkw6kgZGUgY291bGV1cnMuXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvci1TY2hlbWUtVHlwZV90YWcyQEBcIjogXCJQYWxldHRlIGRlIGNvdWxldXJzIDogdXRpbGlzZXogdW5lIHBhbGV0dGUgZGUgY291bGV1cnMgZXhpc3RhbnRlLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnMEBAXCI6IFwiTGVzIHBhbGV0dGVzIGRlIGNvdWxldXJzIHBhciBkw6lmYXV0IHN1aXZhbnRlcyBzb250IGRpc3BvbmlibGVzIGRhbnMgbGEgbGlzdGUgZMOpcm91bGFudGUgOlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnMUBAXCI6IFwiQWx0aXR1ZGUgOiBwYWxldHRlIGRlIGNvdWxldXJzIHF1aSBwYXNzZSBwcm9ncmVzc2l2ZW1lbnQgZHUgY3lhbiBhdSBtYXV2ZSwgcHVpcyBhdSBub2lyLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnMkBAXCI6IFwiR3JpcyA6IHBhbGV0dGUgZGUgY291bGV1cnMgcXVpIHBhc3NlIHByb2dyZXNzaXZlbWVudCBkdSBub2lyIGF1IGJsYW5jLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnN0BAXCI6IFwiT21icmFnZcKgOiBwYWxldHRlIGRlIGNvdWxldXJzIGVuIMOpY2hlbGxlIGRlIGdyaXMgc2VydmFudCDDoCB2aXN1YWxpc2VyIHVuZSByZXByw6lzZW50YXRpb27CoDNEIGRlIGxhIHN1cmZhY2UgZHUgdGVycmFpbiwgYXZlYyBwcmlzZSBlbiBjb21wdGUgZGUgbGEgcG9zaXRpb24gcmVsYXRpdmUgZHUgc29sZWlsIHBvdXIgbOKAmW9tYnJhZ2UgZGUgbOKAmWltYWdlLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnM0BAXCI6IFwiTkRWSSA6IHBhbGV0dGUgZGUgY291bGV1cnMgcGVybWV0dGFudCBkZSB2aXN1YWxpc2VyIGxhIHbDqWfDqXRhdGlvbi4gTGVzIHZhbGV1cnMgcHJvY2hlcyBkZSB6w6lybyBjb3JyZXNwb25kZW50IGF1IGJsZXUuIExlcyB2YWxldXJzIGZhaWJsZXMgY29ycmVzcG9uZGVudCBhdSBtYXJyb24uIEVuc3VpdGUsIGxlcyBjb3VsZXVycyBwYXNzZW50IHByb2dyZXNzaXZlbWVudCBkdSByb3VnZSBhdSBvcmFuZ2UsIHB1aXMgYXUgamF1bmUsIGF1IHZlcnQgZXQgZW5maW4gYXUgbm9pciwgY2FyIGzigJlpbmRleCBkZSB2w6lnw6l0YXRpb24gdmEgZGVzIHZhbGV1cnMgZmFpYmxlcyBhdXggcGx1cyDDqWxldsOpZXMuXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvcm1hcF90YWc0QEBcIjogXCJORFZJMiA6IHBhbGV0dGUgZGUgY291bGV1cnMgcGVybWV0dGFudCBkZSB2aXN1YWxpc2VyIGxhIHbDqWfDqXRhdGlvbi4gTGEgcGxhZ2UgZGVzIHZhbGV1cnMgZmFpYmxlcyB2YSBkdSBibGFuYyBhdSB2ZXJ0LiBFbnN1aXRlLCBsZXMgY291bGV1cnMgdm9udCBkdSBncmlzIGF1IG1hdXZlLCBhdSB2aW9sZXQsIHB1aXMgYXUgYmxldSBmb25jw6kgZXQgZW5maW4gYXUgbm9pciwgw6AgbWVzdXJlIHF1ZSBs4oCZaW5kZXggZGUgdsOpZ8OpdGF0aW9uIHBhc3NlIGRlIGZhaWJsZSDDoCDDqWxldsOpLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnNUBAXCI6IFwiTkRWSTMgOiBwYWxldHRlIGRlIGNvdWxldXJzIHBlcm1ldHRhbnQgZGUgdmlzdWFsaXNlciBsYSB2w6lnw6l0YXRpb24uIExlcyB2YWxldXJzIHByb2NoZXMgZGUgesOpcm8gY29ycmVzcG9uZGVudCBhdSBibGV1LiBFbnN1aXRlLCBsZXMgY291bGV1cnMgcGFzc2VudCBwcm9ncmVzc2l2ZW1lbnQgZHUgcm91Z2UgYXUgb3JhbmdlLCBwdWlzIGF1IHZlcnQsIGNhciBs4oCZaW5kZXggZGUgdsOpZ8OpdGF0aW9uIHZhIGRlcyB2YWxldXJzIGZhaWJsZXMgYXV4IHBsdXMgw6lsZXbDqWVzLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnNkBAXCI6IFwiQWzDqWF0b2lyZSA6IHBhbGV0dGUgZGUgY291bGV1cnMgYWzDqWF0b2lyZXMuXCIsXG5cdFwiQEBDb2xvcm1hcF9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDb2xvcm1hcC1Uby1SR0JfUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBkZSBsYSBwYWxldHRlIGRlIGNvdWxldXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDb21wbGV4X1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQENvbXBvc2l0ZS1CYW5kc19SYXN0ZXJzX3RhZzBAQFwiOiBcIlV0aWxpc2V6IGxhIGxpc3RlIGTDqXJvdWxhbnRlIG91IGxlIGJvdXRvbiA8c3Ryb25nPlBhcmNvdXJpcjwvc3Ryb25nPiBwb3VyIGNob2lzaXIgbGVzIGVudHLDqWVzIHJhc3Rlci5cIixcblx0XCJAQENvbXBvc2l0ZS1CYW5kc19jZWxsc2l6ZXR5cGVfdGFnMEBAXCI6IFwiPHA+Q2hvaXNpciBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIHRvdXRlcyBsZXMgdGFpbGxlcyBkZSBjZWxsdWxlIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuPC9wPjx1bD48bGk+UHJlbWllciBkZcKgOiB1dGlsaXNlciBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS48L2xpPjxsaT5NaW4gZGXCoDogdXRpbGlzZXIgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLjwvbGk+PGxpPk1heCBkZcKgOiB1dGlsaXNlciBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+TW95ZW5uZSBkZcKgOiB1dGlsaXNlciBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS48L2xpPjxsaT5EZXJuaWVyIGRlwqA6IHV0aWxpc2VyIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLjwvbGk+PC91bD5cIixcblx0XCJAQENvbi1mdW5jdGlvbl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQENvbi1mdW5jdGlvbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQ29uLWZ1bmN0aW9uX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDb24tZnVuY3Rpb25fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQENvbi1mdW5jdGlvbl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQ29uLWZ1bmN0aW9uX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQ29uX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQENvbl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQ29uX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQENvbl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQ29uX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQ29uX0ZhbHNlLVJhc3Rlcl90YWcwQEBcIjogXCJFbnRyw6llIGRvbnQgbGVzIHZhbGV1cnMgc2Vyb250IHV0aWxpc8OpZXMgZW4gdGFudCBxdWUgdmFsZXVycyBkZSBwaXhlbCBlbiBzb3J0aWUgc2kgbGEgY29uZGl0aW9uIGVzdCBmYXVzc2UuIElsIHBldXQgc+KAmWFnaXIgZOKAmXVuIHJhc3RlciBkZSB0eXBlIGVudGllciwgw6AgdmlyZ3VsZSBmbG90dGFudGUgb3UgZOKAmXVuZSB2YWxldXIgY29uc3RhbnRlLlwiLFxuXHRcIkBAQ29uX1Jhc3Rlcl90YWcwQEBcIjogXCJMZSByYXN0ZXIgZW4gZW50csOpZSBxdWkgcmVwcsOpc2VudGUgbGUgcsOpc3VsdGF0IGJvb2zDqWVuIGTigJl1bmUgZm9uY3Rpb24gcmFzdGVyIG1hdGjDqW1hdGlxdWUgbG9naXF1ZS4gTGVzIHZhbGV1cnMgc29udCDDqWdhbGVzIMOgIDEgKHBvdXIgVnJhaSkgb3Ugw6AgMCAocG91ciBGYXV4KS4gSWwgcGV1dCBzJ2FnaXIgZCd1biBlbnRpZXIgb3UgZCd1biByYXN0ZXIgZW4gdmlyZ3VsZSBmbG90dGFudGUuXCIsXG5cdFwiQEBDb25fVHJ1ZS1SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSBkb250IGxlcyB2YWxldXJzIHNlcm9udCB1dGlsaXPDqWVzIGVuIHRhbnQgcXVlIHZhbGV1cnMgZGUgcGl4ZWwgZW4gc29ydGllIHNpIGxhIGNvbmRpdGlvbiBlc3QgdnJhaWUuIElsIHBldXQgc+KAmWFnaXIgZOKAmXVuIHJhc3RlciBkZSB0eXBlIGVudGllciwgw6AgdmlyZ3VsZSBmbG90dGFudGUgb3UgZOKAmXVuZSB2YWxldXIgY29uc3RhbnRlLlwiLFxuXHRcIkBAQ29uc3RhbnRfQ29uc3RhbnRfdGFnMEBAXCI6IFwiTGEgdmFsZXVyIGRlIGxhIGNvbnN0YW50ZSDDoCBham91dGVyIGF1IHJhc3RlciB2aXJ0dWVsLlwiLFxuXHRcIkBAQ29uc3RhbnRfUmFzdGVyLUluZm9fdGFnMEBAXCI6IFwiVXRpbGlzZXogbGUgYm91dG9uIDxzdHJvbmc+Q2hhcmdlciBsZSByYXN0ZXIgbW9kw6hsZTwvc3Ryb25nPiBwb3VyIGNoYXJnZXIgdW4gbW9kw6hsZSDDoCBwYXJ0aXIgZOKAmXVuIHLDqXBlcnRvaXJlIG91IGTigJl1biBwb3J0YWlsLlwiLFxuXHRcIkBAQ29udG91cl9BZGFwdGl2ZS1TbW9vdGhpbmdfdGFnMEBAXCI6IFwiUXVhbnRpdMOpIGRlIGxpc3NhZ2Ugw6AgYXBwbGlxdWVyIMOgIGwnaXNvbGlnbmUuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMi41LlwiLFxuXHRcIkBAQ29udG91cl9BZGFwdGl2ZS1TbW9vdGhpbmdfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBpbmbDqXJpZXVyZSBwcm9kdWl0IHVuZSBpc29saWduZSBhdmVjIHBsdXMgZGUgZ3JhbnVsYXJpdMOpIGV0IG1vaW5zIGRlIGxpc3NhZ2UsIHRhbmRpcyBxdSd1bmUgdmFsZXVyIHN1cMOpcmlldXJlIGfDqW7DqHJlIHVuZSBpc29saWduZSBhdmVjIHBsdXMgZGUgbGlzc2FnZSBxdWkgc2VtYmxlIG1vaW5zIGlycsOpZ3VsacOocmUuXCIsXG5cdFwiQEBDb250b3VyX0NvbnRvdXItSW50ZXJ2YWxfdGFnMEBAXCI6IFwiRGlmZsOpcmVuY2UgZW4gYWx0aXR1ZGUgZW50cmUgbGVzIGlzb2xpZ25lcy5cIixcblx0XCJAQENvbnRvdXJfQ29udG91ci1JbnRlcnZhbF90YWcxQEBcIjogXCJVbiBwZXRpdCBpbnRlcnZhbGxlIGTigJlpc29saWduZXMgZXN0IHV0aWxpc8OpIGRhbnMgbGVzIHpvbmVzIHJlbGF0aXZlbWVudCBwbGFuZXMsIHRhbmRpcyBxdeKAmXVuIGludGVydmFsbGUgcGx1cyDDqWxldsOpIGVzdCB1dGlsaXPDqSBwb3VyIGxlcyB0ZXJyYWlucyB2YXJpYWJsZXMgb3UgbW9udGFnbmV1eC5cIixcblx0XCJAQENvbnRvdXJfQ29udG91ci1UeXBlX3RhZzBAQFwiOiBcIlR5cGUgZCdpc29saWduZSDDoCBjcsOpZXIgOlwiLFxuXHRcIkBAQ29udG91cl9Db250b3VyLVR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5SZW1wbGlzc2FnZSBk4oCZaXNvbGlnbmVzPC9zdHJvbmc+IDogcmVtcGxpdCBsYSB6b25lIHNpdHXDqWUgZW50cmUgY2hhcXVlIGlzb2xpZ25lIGF2ZWMgbGEgdmFsZXVyIGTigJnDqWzDqXZhdGlvbiBxdWFudGlmacOpZS5cIixcblx0XCJAQENvbnRvdXJfQ29udG91ci1UeXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+SXNvbGlnbmVzPC9zdHJvbmc+IDogam9pbnQgbGVzIHBvaW50cyBk4oCZw6lsw6l2YXRpb24gw6lnYWxlIHBvdXIgY3LDqWVyIHVuZSBsaWduZSByZXByw6lzZW50YW50IHVuZSDDqWzDqXZhdGlvbiBjb25zdGFudGUuXCIsXG5cdFwiQEBDb250b3VyX0NvbnRvdXItVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPlN1cmZhY2UgbGlzc2UgdW5pcXVlbWVudDwvc3Ryb25nPiA6IGxpc3NlIGxhIGNvdWNoZSBk4oCZw6lsw6l2YXRpb24gZW4gZW50csOpZSwgbWFpcyBuZSBnw6luw6hyZSBwYXMgZOKAmWlzb2xpZ25lcy5cIixcblx0XCJAQENvbnRvdXJfTnRoLUNvbnRvdXItTGluZS1Jbi1Cb2xkX3RhZzBAQFwiOiBcIklzb2xpZ25lIGQnaW5kZXgsIHF1aSBlc3QgcmVwcsOpc2VudMOpZSBzb3VzIGZvcm1lIGRlIGxpZ25lIGVuIGdyYXMuXCIsXG5cdFwiQEBDb250b3VyX050aC1Db250b3VyLUxpbmUtSW4tQm9sZF90YWcxQEBcIjogXCJMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDUsIGPigJllc3Qtw6AtZGlyZSBxdeKAmXVuZSBpc29saWduZSBzdXIgNSBlc3QgZW4gZ3Jhcy5cIixcblx0XCJAQENvbnRvdXJfTnVtYmVyLU9mLUNvbnRvdXJzX3RhZzBAQFwiOiBcIk5vbWJyZSBk4oCZaXNvbGlnbmVzIMOgIGfDqW7DqXJlciBzdXIgbOKAmWFmZmljaGFnZS4gQWp1c3RlIGR5bmFtaXF1ZW1lbnQgbCdpbnRlcnZhbGxlIGRlcyBpc29saWduZXMgcG91ciBsZXMgYWRhcHRlciBhdSBNTlQgc3VyIGwnYWZmaWNoYWdlIHRvdXQgZW4gY29uc2VydmFudCBsZXMgaW50ZXJ2YWxsZXMgc3RhbmRhcmRpc8OpcywgdGVscyBxdWUgMSwgNSwgMTAsIGV0Yy5cIixcblx0XCJAQENvbnRvdXJfUmFzdGVyX3RhZzBAQFwiOiBcIkpldSBkZSBkb25uw6llcyBkJ2FsdGl0dWRlIHJhc3RlciBtb25vY2FuYWwuXCIsXG5cdFwiQEBDb250b3VyX1otQmFzZV90YWcwQEBcIjogXCJWYWxldXIgZGUgbCdpc29saWduZSBkZSBiYXNlLiBMZXMgaXNvbGlnbmVzIHNvbnQgZ8OpbsOpcsOpZXMgYXUtZGVzc3VzIGV0IGVuIGRlc3NvdXMgZGUgY2V0dGUgdmFsZXVyIGRlIGZhw6dvbiDDoCBjb3V2cmlyIGxhIHBsYWdlIGRlIHZhbGV1cnMgY29tcGzDqHRlIGR1IHJhc3RlciBlbiBlbnRyw6llLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDAuXCIsXG5cdFwiQEBDb250b3VyX1otQmFzZV90YWcxQEBcIjogXCJMYSB2YWxldXIgMCByZXByw6lzZW50ZSBzb3V2ZW50IGxlIG5pdmVhdSBtb3llbiBkZSBsYSBtZXIsIHNlbG9uIGxlIGpldSBkZSBkb25uw6llcyBkJ2FsdGl0dWRlIHNvdXJjZS5cIixcblx0XCJAQENvbnRvdXJfWi1GYWN0b3JfdGFnMEBAXCI6IFwiRmFjdGV1ciBkZSBjb252ZXJzaW9uIGQndW5pdMOpcyB1dGlsaXPDqSBsb3JzIGRlIGxhIGfDqW7DqXJhdGlvbiBkZXMgaXNvbGlnbmVzLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDEuXCIsXG5cdFwiQEBDb250b3VyX1otRmFjdG9yX3RhZzFAQFwiOiBcIkxlcyBpc29saWduZXMgc29udCBnw6luw6lyw6llcyBlbiBmb25jdGlvbiBkZXMgdmFsZXVycyB6IGRhbnMgbGUgcmFzdGVyIGVuIGVudHLDqWUsIHF1aSBzb250IHNvdXZlbnQgbWVzdXLDqWVzIGVuIG3DqHRyZXMgb3UgZW4gcGllZHMuIEF2ZWMgbGEgdmFsZXVyIHBhciBkw6lmYXV0IDEsIGxlcyBpc29saWduZXMgc29udCBkYW5zIGxlcyBtw6ptZXMgdW5pdMOpcyBxdWUgbGVzIHZhbGV1cnMgeiBkdSByYXN0ZXIgZW4gZW50csOpZS4gUG91ciBjcsOpZXIgZGVzIGlzb2xpZ25lcyBkYW5zIHVuZSBhdXRyZSB1bml0w6kgcXVlIGNlbGxlIGRlcyB2YWxldXJzIHosIGTDqWZpbmlzc2V6IHVuZSB2YWxldXIgYXBwcm9wcmnDqWUgcG91ciBsZSBmYWN0ZXVyIHouIE5vdGV6IHF1J2lsIG4nZXN0IHBhcyBuw6ljZXNzYWlyZSBxdWUgbGVzIHVuaXTDqXMgeCx5IGF1IHNvbCBldCBsZXMgdW5pdMOpcyB6IGRlIHN1cmZhY2Ugc29pZW50IGhvbW9nw6huZXMgcG91ciBjZXQgb3V0aWwuXCIsXG5cdFwiQEBDb250b3VyX1otRmFjdG9yX3RhZzJAQFwiOiBcIlBhciBleGVtcGxlLCBzaSBsZXMgdmFsZXVycyBk4oCZYWx0aXR1ZGUgZGUgdm90cmUgcmFzdGVyIGVuIGVudHLDqWUgc29udCBlbiBwaWVkcywgbWFpcyBxdWUgdm91cyB2b3VsZXogcXVlIGxlcyBpc29saWduZXMgc29pZW50IGfDqW7DqXLDqWVzIGVuIG3DqHRyZXMsIGTDqWZpbmlzc2V6IGxlIGZhY3RldXIgeiBzdXIgMCwzMDQ4IChjYXIgMSBwaWVkID0gMCwzMDQ4IG3DqHRyZXMpLlwiLFxuXHRcIkBAQ29udHJhc3QtYW5kLUJyaWdodG5lc3NfQnJpZ2h0bmVzcy1PZmZzZXRfdGFnMEBAXCI6IFwiUsOpZ2xleiBsYSBsdW1pbm9zaXTDqSBkZSBsYSBjb3VjaGUgcmFzdGVyLlwiLFxuXHRcIkBAQ29udHJhc3QtYW5kLUJyaWdodG5lc3NfQnJpZ2h0bmVzcy1PZmZzZXRfdGFnMUBAXCI6IFwiVm91cyBwb3V2ZXogdXRpbGlzZXIgbGUgY3Vyc2V1ciBwb3VyIG1vZGlmaWVyIGxhIGx1bWlub3NpdMOpLCBvdSBzYWlzaXIgdW5lIHZhbGV1ci5cIixcblx0XCJAQENvbnRyYXN0LWFuZC1CcmlnaHRuZXNzX0NvbnRyYXN0LU9mZnNldF90YWcwQEBcIjogXCJSw6lnbGV6IGxlIGNvbnRyYXN0ZSBkZSBsYSBjb3VjaGUgcmFzdGVyLlwiLFxuXHRcIkBAQ29udHJhc3QtYW5kLUJyaWdodG5lc3NfQ29udHJhc3QtT2Zmc2V0X3RhZzFAQFwiOiBcIlZvdXMgcG91dmV6IHV0aWxpc2VyIGxlIGN1cnNldXIgcG91ciBtb2RpZmllciBsZSBjb250cmFzdGUsIG91IHNhaXNpciB1bmUgdmFsZXVyLlwiLFxuXHRcIkBAQ29udHJhc3QtYW5kLUJyaWdodG5lc3NfUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIHN1ciBsZXF1ZWwgbW9kaWZpZXIgbGEgbHVtaW5vc2l0w6kgZXQgbGUgY29udHJhc3RlLlwiLFxuXHRcIkBAQ29udm9sdXRpb25fa2VybmVsX3RhZzBAQFwiOiBcIjxwPkNldHRlIHRhYmxlIGlsbHVzdHJlIGxhIG1hbmnDqHJlIGRvbnQgY2hhcXVlIHBpeGVsIHNlcmEgcG9uZMOpcsOpIGF1IGNvdXJzIGR1IGZpbHRyYWdlLiBDZXR0ZSB0YWJsZSBwZXV0IMOqdHJlIG1pc2Ugw6Agam91ciBzaSB2b3VzIHBhcmFtw6l0cmV6IGxlIDxzdHJvbmc+VHlwZTwvc3Ryb25nPiBzdXIgPHN0cm9uZz5Ew6lmaW5pIHBhciBs4oCZdXRpbGlzYXRldXI8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBAQ29udm9sdXRpb25fUmFzdGVyX3RhZzBAQFwiOiBcIkpldSBkZSBkb25uw6llcyByYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQENvbnZvbHV0aW9uX1R5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBsZSB0eXBlIGRlIGZpbHRyYWdlIMOgIGVmZmVjdHVlciA6IERlcyBvcHRpb25zIHBlcm1ldHRlbnQgZOKAmWFmZmluZXIsIGRlIGJyb3VpbGxlciB1bmUgaW1hZ2Ugb3UgZMOpdGVjdGVyIGRlcyB0cm9uw6dvbnMsIG1haXMgdm91cyBwb3V2ZXogw6lnYWxlbWVudCBkw6lmaW5pciB2b3RyZSBwcm9wcmUgZmlsdHJlIGRlIHR5cGUgbm95YXVcIixcblx0XCJAQENvcnJpZG9yX0Rpc3RhbmNlLVJhc3Rlci0xX3RhZzBAQFwiOiBcIlByZW1pZXIgcmFzdGVyIGRlIGRpc3RhbmNlIGVuIGVudHLDqWUuIElsIGRvaXQgc+KAmWFnaXIgZOKAmXVuZSBzb3J0aWUgZOKAmW91dGlsIGRlIGRpc3RhbmNlIGRlIGNvw7t0IGN1bXVsw6kgcHJvdmVuYW50IGRlIERpc3RhbmNlIGRlIGNvw7t0IG91IERpc3RhbmNlIGRlIGNoZW1pbi5cIixcblx0XCJAQENvcnJpZG9yX0Rpc3RhbmNlLVJhc3Rlci0yX3RhZzBAQFwiOiBcIkRldXhpw6htZSByYXN0ZXIgZGUgZGlzdGFuY2UgZW4gZW50csOpZS4gSWwgZG9pdCBz4oCZYWdpciBk4oCZdW5lIHNvcnRpZSBk4oCZb3V0aWwgZGUgZGlzdGFuY2UgZGUgY2/Du3QgY3VtdWzDqSBwcm92ZW5hbnQgZGUgRGlzdGFuY2UgZGUgY2/Du3Qgb3UgRGlzdGFuY2UgZGUgY2hlbWluLlwiLFxuXHRcIkBAQ29zX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAQ29zX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDb3NfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQENvc19DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQ29zX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDb3NfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDb3NfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAQ29zX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBDb3NfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQ29zX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBDb3NfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBDb3NfUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgcG91ciBsYXF1ZWxsZSBjYWxjdWxlciBsZXMgdmFsZXVycyBkZSBjb3NpbnVzLlwiLFxuXHRcIkBAQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQENvc0hfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQENvc0hfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQENvc0hfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQENvc0hfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQENvc0hfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDb3NIX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQENvc0hfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQENvc0hfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQ29zSF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQ29zSF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQENvc0hfUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgcG91ciBsYXF1ZWxsZSBjYWxjdWxlciBsZXMgdmFsZXVycyBkZSBjb3NpbnVzIGh5cGVyYm9saXF1ZS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMEBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBzaW11bGUgbOKAmWF1Z21lbnRhdGlvbiBkZSBs4oCZZWZmb3J0IHBvdXIgc3VybW9udGVyIGxlcyBjb8O7dHMgYXUgZnVyIGV0IMOgIG1lc3VyZSBxdWUgbGUgY2/Du3QgY3VtdWzDqSBhdWdtZW50ZS4gSWwgcGVybWV0IGRlIG1vZMOpbGlzZXIgbGEgZmF0aWd1ZSBkdSB2b3lhZ2V1ci4gTGUgY2/Du3QgY3VtdWzDqSBjcm9pc3NhbnQgcG91ciBhdHRlaW5kcmUgdW5lIGNlbGx1bGUgZXN0IG11bHRpcGxpw6kgcGFyIGxlIHRhdXggZGUgcsOpc2lzdGFuY2UgZXQgYWpvdXTDqSBhdSBjb8O7dCBlbmdlbmRyw6kgcGFyIGxlIGTDqXBsYWNlbWVudCB2ZXJzIGxhIGNlbGx1bGUgc3VpdmFudGUuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzFAQFwiOiBcIklsIHPigJlhZ2l0IGTigJl1bmUgdmVyc2lvbiBtb2RpZmnDqWUgZOKAmXVuZSBmb3JtdWxlIGRlIHRhdXggZOKAmWludMOpcsOqdCBjb21wb3PDqSBxdWkgcGVybWV0IGRlIGNhbGN1bGVyIGxlIGNvw7t0IGFwcGFyZW50IGR1IGTDqXBsYWNlbWVudCDDoCB0cmF2ZXJzIHVuZSBjZWxsdWxlLiBBdmVjIGwnYXVnbWVudGF0aW9uIGR1IHRhdXggZGUgcsOpc2lzdGFuY2UsIGxlIGNvw7t0IGRlcyBjZWxsdWxlcyBxdWkgc29udCB2aXNpdMOpZXMgdWx0w6lyaWV1cmVtZW50IHMnYWNjcm/DrnQgw6lnYWxlbWVudC4gUGx1cyBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIGVzdCBpbXBvcnRhbnQsIHBsdXMgbGUgY2/Du3QgZGUgZMOpcGxhY2VtZW50IHZlcnMgbGEgY2VsbHVsZSBzdWl2YW50ZSBhdWdtZW50ZSwgbGVxdWVsIGVzdCBham91dMOpIHBvdXIgY2hhcXVlIG1vdXZlbWVudCBzdWl2YW50LiBQdWlzcXVlIGxlIHRhdXggZGUgcsOpc2lzdGFuY2UgZXN0IHNpbWlsYWlyZSDDoCB1biB0YXV4IGNvbXBvc8OpIGV0IHF14oCZaGFiaXR1ZWxsZW1lbnQgbGVzIHZhbGV1cnMgZGUgY2/Du3QgY3VtdWzDqSBzb250IHRyw6hzIGltcG9ydGFudGVzLCBub3VzIHN1Z2fDqXJvbnMgbOKAmXV0aWxpc2F0aW9uIGRlIHRhdXggZGUgcsOpc2lzdGFuY2UgZmFpYmxlcywgdGVscyBxdWUgMCwwMDUgb3UgZW5jb3JlIGluZsOpcmlldXJzLCBzZWxvbiBsZXMgdmFsZXVycyBkZSBjb8O7dCBjdW11bMOpLlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcyQEBcIjogXCJMYSB2YWxldXIgZG9pdCDDqnRyZSBzdXDDqXJpZXVyZSDDoCB6w6lyby4gTGEgY2FwYWNpdMOpIHBhciBkw6lmYXV0IGVzdCBsaW1pdMOpZSBwYXIgbGUgdHJvbsOnb24gZHUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnM0BAXCI6IFwiVm91cyBwb3V2ZXogdXRpbGlzZXIgcG91ciBjZSBwYXJhbcOodHJlIHVuZSB2YWxldXIgbnVtw6lyaXF1ZSAoZG91YmxlKSBvdSB1biBjaGFtcCBkdSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4uXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fQ2FwYWNpdHlfdGFnMEBAXCI6IFwiRMOpZmluaXQgbGEgY2FwYWNpdMOpIGRlIGNvw7t0IHBvdXIgbGUgdm95YWdldXIgcG91ciB1bmUgc291cmNlLiBMZXMgY2FsY3VscyBkZSBjb8O7dCBjb250aW51ZW50IHBvdXIgY2hhcXVlIHNvdXJjZSBqdXNxdeKAmcOgIGNlIHF1ZSBsYSBjYXBhY2l0w6kgc3DDqWNpZmnDqWUgc29pdCBhdHRlaW50ZS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9DYXBhY2l0eV90YWcxQEBcIjogXCJMYSB2YWxldXIgZG9pdCDDqnRyZSBzdXDDqXJpZXVyZSDDoCB6w6lyby4gTGEgY2FwYWNpdMOpIHBhciBkw6lmYXV0IGVzdCBsaW1pdMOpZSBwYXIgbGUgdHJvbsOnb24gZHUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9DYXBhY2l0eV90YWcyQEBcIjogXCJWb3VzIHBvdXZleiB1dGlsaXNlciBwb3VyIGNlIHBhcmFtw6h0cmUgdW5lIHZhbGV1ciBudW3DqXJpcXVlIChkb3VibGUpIG91IHVuIGNoYW1wIGR1IDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPi5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Db3N0LVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSByZXF1aXMgZMOpZmluaXNzYW50IGxlIGNvw7t0IG91IGzigJlpbXDDqWRhbmNlIGRlIGTDqXBsYWNlbWVudCBwbGFuaW3DqXRyaXF1ZSDDoCB0cmF2ZXJzIGNoYXF1ZSBjZWxsdWxlLiBMYSB2YWxldXIgw6AgY2hhcXVlIGVtcGxhY2VtZW50IGRlIGNlbGx1bGUgcmVwcsOpc2VudGUgbGUgY2/Du3QgcGFyIHVuaXTDqSBkZSBkaXN0YW5jZSBwb3VyIGxlIGTDqXBsYWNlbWVudCDDoCB0cmF2ZXJzIGNoYXF1ZSBjZWxsdWxlLiBDaGFxdWUgdmFsZXVyIGTigJllbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVzdCBtdWx0aXBsacOpZSBwYXIgbGEgcsOpc29sdXRpb24gZGUgY2VsbHVsZSBldCBjb21wZW5zZSDDqWdhbGVtZW50IGxlIG1vdXZlbWVudCBkaWFnb25hbCBhZmluIGTigJlvYnRlbmlyIGxlIGNvw7t0IHRvdGFsIGR1IHBhc3NhZ2Ugw6AgdHJhdmVycyBsYSBjZWxsdWxlLlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX0Nvc3QtUmFzdGVyX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGR1IDxzdHJvbmc+UmFzdGVyIGRlIGNvw7t0PC9zdHJvbmc+IHBldXZlbnQgw6p0cmUgZGVzIGVudGllcnMgb3UgZGVzIG5vbWJyZXMgw6AgdmlyZ3VsZSBmbG90dGFudGUsIG1haXMgZWxsZXMgbmUgcGV1dmVudCBwYXMgw6p0cmUgbsOpZ2F0aXZlcyBuaSBudWxsZXMuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fTWF4aW11bS1EaXN0YW5jZV90YWcwQEBcIjogXCJMZSBzZXVpbCBxdWUgbGVzIHZhbGV1cnMgZGUgY2/Du3QgY3VtdWzDqSBuZSBwZXV2ZW50IHBhcyBkw6lwYXNzZXIuIFNpIHVuZSBkaXN0YW5jZSBkZSBjb8O7dCBjdW11bMOpIGTDqXBhc3NlIGNldHRlIHZhbGV1ciwgbGEgdmFsZXVyIGVuIHNvcnRpZSBkZSBs4oCZZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlc3QgJHtOb0RhdGF9LiBMYSBkaXN0YW5jZSBtYXhpbWFsZSBkw6lmaW5pdCBs4oCZw6l0ZW5kdWUgcG91ciBsYXF1ZWxsZSBsZXMgZGlzdGFuY2VzIGRlIGNvw7t0IGN1bXVsw6kgc29udCBjYWxjdWzDqWVzLiBMYSBkaXN0YW5jZSBwYXIgZMOpZmF1dCB2YSBqdXNxdeKAmcOgIGzigJnDqXRlbmR1ZSBkdSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiTXVsdGlwbGljYXRldXIgw6AgYXBwbGlxdWVyIGF1eCB2YWxldXJzIGRlIGNvw7t0LlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMUBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgY29udHLDtGxlciBsZSBtb2RlIGRlIGTDqXBsYWNlbWVudCBvdSBsYSBtYWduaXR1ZGUgw6AgdW5lIHNvdXJjZS4gUGx1cyBsZSBtdWx0aXBsaWNhdGV1ciBlc3Qgw6lsZXbDqSwgcGx1cyBsZSBjb8O7dCBkZSBkw6lwbGFjZW1lbnQgZOKAmXVuZSBjZWxsdWxlIMOgIHVuZSBhdXRyZSBlc3QgaW1wb3J0YW50LlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMkBAXCI6IFwiTGVzIHZhbGV1cnMgZG9pdmVudCDDqnRyZSBzdXDDqXJpZXVyZXMgw6AgesOpcm8uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzNAQFwiOiBcIlZvdXMgcG91dmV6IHV0aWxpc2VyIHBvdXIgY2UgcGFyYW3DqHRyZSB1bmUgdmFsZXVyIG51bcOpcmlxdWUgKGRvdWJsZSkgb3UgdW4gY2hhbXAgZHUgPHN0cm9uZz5SYXN0ZXIgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX1NvdXJjZS1GaWVsZF90YWcwQEBcIjogXCJDaGFtcCBwZXJtZXR0YW50IGTigJlhdHRyaWJ1ZXIgZGVzIHZhbGV1cnMgYXV4IGVtcGxhY2VtZW50cyBzb3VyY2VzLiBJbCBkb2l0IMOqdHJlIGRlIHR5cGUgZW50aWVyLiBTaSBsZSA8c3Ryb25nPlJhc3RlciBkZSB2YWxldXI8L3N0cm9uZz4gYSDDqXTDqSBkw6lmaW5pLCBsZXMgdmFsZXVycyBkYW5zIGNldHRlIGVudHLDqWUgc29udCBwcmlvcml0YWlyZXMgc3VyIHRvdXQgcGFyYW3DqHRyZSBkdSA8c3Ryb25nPkNoYW1wIHNvdXJjZTwvc3Ryb25nPi5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBlbiBlbnRyw6llIHJlcXVpcyBkZXMgZW1wbGFjZW1lbnRzIHNvdXJjZS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzFAQFwiOiBcIlJhc3RlciBxdWkgaWRlbnRpZmllIGxlcyBjZWxsdWxlcyBvdSBsZXMgZW1wbGFjZW1lbnRzIMOgIHBhcnRpciBkZXNxdWVscyBsYSBkaXN0YW5jZSBkZSBtb2luZHJlIGNvw7t0IGN1bXVsw6kgZXN0IGNhbGN1bMOpZSBwb3VyIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVuIHNvcnRpZS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzJAQFwiOiBcIlNpIGxlIDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPiBlbiBlbnRyw6llIGVzdCDDoCB2aXJndWxlIGZsb3R0YW50ZSwgbGUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyPC9zdHJvbmc+IGRvaXQgw6p0cmUgZMOpZmluaSBldCBpbCBkb2l0IMOqdHJlIGRlIHR5cGUgZW50aWVyLiBMZSA8c3Ryb25nPlJhc3RlciBkZSB2YWxldXI8L3N0cm9uZz4gZXN0IHByaW9yaXRhaXJlIHN1ciB0b3V0IHBhcmFtw6h0cmUgZHUgPHN0cm9uZz5DaGFtcCBzb3VyY2U8L3N0cm9uZz4uXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fU3RhcnQtQ29zdF90YWcwQEBcIjogXCJDb8O7dCBkZSBkw6lwYXJ0IGR1IGNhbGN1bCBkZXMgY2/Du3RzLiBDZSBwYXJhbcOodHJlIHBlcm1ldCBkZSBzcMOpY2lmaWVyIGxlIGNvw7t0IGZpeGUgYXNzb2Npw6kgw6AgdW5lIHNvdXJjZS4gUGx1dMO0dCBxdWUgZGUgY29tbWVuY2VyIGF2ZWMgdW4gY2/Du3Qgw6lnYWwgw6AgMCwgbOKAmWFsZ29yaXRobWUgZGUgY2/Du3QgY29tbWVuY2UgYXZlYyBsYSB2YWxldXIgZMOpZmluaWUuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fU3RhcnQtQ29zdF90YWcxQEBcIjogXCJMYSB2YWxldXIgZG9pdCDDqnRyZSDDqWdhbGUgb3Ugc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMC5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxlIHNlbnMgZHUgdm95YWdldXIgZW4gY2FzIGTigJlhcHBsaWNhdGlvbiBkdSB0YXV4IGRlIHLDqXNpc3RhbmNlIHNvdXJjZSBldCBkdSBjb8O7dCBkZSBkw6lwYXJ0IHNvdXJjZS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+w4AgcGFydGlyIGRlIGxhIHNvdXJjZTwvc3Ryb25nPiA6IGxlIHRhdXggZGUgcsOpc2lzdGFuY2Ugc291cmNlIGV0IGxlIGNvw7t0IGRlIGTDqXBhcnQgc291cmNlIHNvbnQgYXBwbGlxdcOpcyDDoCBwYXJ0aXIgZGUgbGEgc291cmNlIGVuIGVudHLDqWUgZXQgZW4gc2UgZMOpcGxhw6dhbnQgdmVycyBsZXMgY2VsbHVsZXMgbm9uIHNvdXJjZXMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlZlcnMgbGEgc291cmNlPC9zdHJvbmc+IDogbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBzb3VyY2UgZXQgbGUgY2/Du3QgZGUgZMOpcGFydCBzb3VyY2Ugc29udCBhcHBsaXF1w6lzIMOgIHBhcnRpciBkZSBjaGFxdWUgY2VsbHVsZSBub24gc291cmNlIGV0IGVuIHJldmVuYW50IHZlcnMgbGEgc291cmNlIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fVHJhdmVsLURpcmVjdGlvbl90YWc1QEBcIjogXCJTcMOpY2lmaWV6IGxlIG1vdC1jbMOpIDxzdHJvbmc+w4AgcGFydGlyIGRlIGxhIHNvdXJjZTwvc3Ryb25nPiBvdSA8c3Ryb25nPlZlcnMgbGEgc291cmNlPC9zdHJvbmc+LCBxdWkgZXN0IGFwcGxpcXXDqSDDoCB0b3V0ZXMgbGVzIHNvdXJjZXMsIG91IHNww6ljaWZpZXogdW4gY2hhbXAgZGFucyBsZSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4gcXVpIGNvbnRpZW50IGxlcyBtb3RzLWNsw6lzIHBlcm1ldHRhbnQgZOKAmWlkZW50aWZpZXIgbGUgc2VucyBkZSBkw6lwbGFjZW1lbnQgcG91ciBjaGFxdWUgc291cmNlLiBDZSBjaGFtcCBkb2l0IGNvbnRlbmlyIGxhIGNoYcOubmUgJHtGUk9NX1NPVVJDRX0gb3UgJHtUT19TT1VSQ0V9LlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX1ZhbHVlLVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZOKAmWVudGllcnMgZW4gZW50csOpZSBxdWkgaWRlbnRpZmllIGxlcyB2YWxldXJzIGRlIHpvbmUgw6AgdXRpbGlzZXIgcG91ciBjaGFxdWUgZW1wbGFjZW1lbnQgc291cmNlIGVuIGVudHLDqWUuIFBvdXIgY2hhcXVlIGNlbGx1bGUgZOKAmWVtcGxhY2VtZW50IHNvdXJjZSwgbGEgdmFsZXVyIGTDqWZpbmllIHBhciBsZSA8c3Ryb25nPlJhc3RlciBkZSB2YWxldXI8L3N0cm9uZz4gZXN0IGF0dHJpYnXDqWUgw6AgdG91dGVzIGxlcyBjZWxsdWxlcyBhbGxvdcOpZXMgw6AgbOKAmWVtcGxhY2VtZW50IHNvdXJjZSBwb3VyIGxlIGNhbGN1bC4gTGUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyPC9zdHJvbmc+IGVzdCBwcmlvcml0YWlyZSBzdXIgdG91dCBwYXJhbcOodHJlIGR1IDxzdHJvbmc+Q2hhbXAgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzBAQFwiOiBcIkNlIHBhcmFtw6h0cmUgc2ltdWxlIGzigJlhdWdtZW50YXRpb24gZGUgbOKAmWVmZm9ydCBwb3VyIHN1cm1vbnRlciBsZXMgY2/Du3RzIGF1IGZ1ciBldCDDoCBtZXN1cmUgcXVlIGxlIGNvw7t0IGN1bXVsw6kgYXVnbWVudGUuIElsIHBlcm1ldCBkZSBtb2TDqWxpc2VyIGxhIGZhdGlndWUgZHUgdm95YWdldXIuIExlIGNvw7t0IGN1bXVsw6kgY3JvaXNzYW50IHBvdXIgYXR0ZWluZHJlIHVuZSBjZWxsdWxlIGVzdCBtdWx0aXBsacOpIHBhciBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIGV0IGFqb3V0w6kgYXUgY2/Du3QgZW5nZW5kcsOpIHBhciBsZSBkw6lwbGFjZW1lbnQgdmVycyBsYSBjZWxsdWxlIHN1aXZhbnRlLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzFAQFwiOiBcIklsIHPigJlhZ2l0IGTigJl1bmUgdmVyc2lvbiBtb2RpZmnDqWUgZOKAmXVuZSBmb3JtdWxlIGRlIHRhdXggZOKAmWludMOpcsOqdCBjb21wb3PDqSBxdWkgcGVybWV0IGRlIGNhbGN1bGVyIGxlIGNvw7t0IGFwcGFyZW50IGR1IGTDqXBsYWNlbWVudCDDoCB0cmF2ZXJzIHVuZSBjZWxsdWxlLiBBdmVjIGwnYXVnbWVudGF0aW9uIGR1IHRhdXggZGUgcsOpc2lzdGFuY2UsIGxlIGNvw7t0IGRlcyBjZWxsdWxlcyBxdWkgc29udCB2aXNpdMOpZXMgdWx0w6lyaWV1cmVtZW50IHMnYWNjcm/DrnQgw6lnYWxlbWVudC4gUGx1cyBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIGVzdCBpbXBvcnRhbnQsIHBsdXMgbGUgY2/Du3QgZGUgZMOpcGxhY2VtZW50IHZlcnMgbGEgY2VsbHVsZSBzdWl2YW50ZSBhdWdtZW50ZSwgbGVxdWVsIGVzdCBham91dMOpIHBvdXIgY2hhcXVlIG1vdXZlbWVudCBzdWl2YW50LiBQdWlzcXVlIGxlIHRhdXggZGUgcsOpc2lzdGFuY2UgZXN0IHNpbWlsYWlyZSDDoCB1biB0YXV4IGNvbXBvc8OpIGV0IHF14oCZaGFiaXR1ZWxsZW1lbnQgbGVzIHZhbGV1cnMgZGUgY2/Du3QgY3VtdWzDqSBzb250IHRyw6hzIGltcG9ydGFudGVzLCBub3VzIHN1Z2fDqXJvbnMgbOKAmXV0aWxpc2F0aW9uIGRlIHRhdXggZGUgcsOpc2lzdGFuY2UgZmFpYmxlcywgdGVscyBxdWUgMCwwMDUgb3UgZW5jb3JlIGluZsOpcmlldXJzLCBzZWxvbiBsZXMgdmFsZXVycyBkZSBjb8O7dCBjdW11bMOpLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIkxhIHZhbGV1ciBkb2l0IMOqdHJlIHN1cMOpcmlldXJlIMOgIHrDqXJvLiBMYSBjYXBhY2l0w6kgcGFyIGTDqWZhdXQgZXN0IGxpbWl0w6llIHBhciBsZSB0cm9uw6dvbiBkdSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzNAQFwiOiBcIlZvdXMgcG91dmV6IHV0aWxpc2VyIHBvdXIgY2UgcGFyYW3DqHRyZSB1bmUgdmFsZXVyIG51bcOpcmlxdWUgKGRvdWJsZSkgb3UgdW4gY2hhbXAgZHUgPHN0cm9uZz5SYXN0ZXIgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQ2FwYWNpdHlfdGFnMEBAXCI6IFwiRMOpZmluaXQgbGEgY2FwYWNpdMOpIGRlIGNvw7t0IHBvdXIgbGUgdm95YWdldXIgcG91ciB1bmUgc291cmNlLiBMZXMgY2FsY3VscyBkZSBjb8O7dCBjb250aW51ZW50IHBvdXIgY2hhcXVlIHNvdXJjZSBqdXNxdeKAmcOgIGNlIHF1ZSBsYSBjYXBhY2l0w6kgc3DDqWNpZmnDqWUgc29pdCBhdHRlaW50ZS5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX0NhcGFjaXR5X3RhZzFAQFwiOiBcIkxhIHZhbGV1ciBkb2l0IMOqdHJlIHN1cMOpcmlldXJlIMOgIHrDqXJvLiBMYSBjYXBhY2l0w6kgcGFyIGTDqWZhdXQgZXN0IGxpbWl0w6llIHBhciBsZSB0cm9uw6dvbiBkdSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQ2FwYWNpdHlfdGFnMkBAXCI6IFwiVm91cyBwb3V2ZXogdXRpbGlzZXIgcG91ciBjZSBwYXJhbcOodHJlIHVuZSB2YWxldXIgbnVtw6lyaXF1ZSAoZG91YmxlKSBvdSB1biBjaGFtcCBkdSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4uXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19Db3N0LVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSByZXF1aXMgZMOpZmluaXNzYW50IGxlIGNvw7t0IG91IGzigJlpbXDDqWRhbmNlIGRlIGTDqXBsYWNlbWVudCBwbGFuaW3DqXRyaXF1ZSDDoCB0cmF2ZXJzIGNoYXF1ZSBjZWxsdWxlLiBMYSB2YWxldXIgw6AgY2hhcXVlIGVtcGxhY2VtZW50IGRlIGNlbGx1bGUgcmVwcsOpc2VudGUgbGUgY2/Du3QgcGFyIHVuaXTDqSBkZSBkaXN0YW5jZSBwb3VyIGxlIGTDqXBsYWNlbWVudCDDoCB0cmF2ZXJzIGNoYXF1ZSBjZWxsdWxlLiBDaGFxdWUgdmFsZXVyIGTigJllbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVzdCBtdWx0aXBsacOpZSBwYXIgbGEgcsOpc29sdXRpb24gZGUgY2VsbHVsZSBldCBjb21wZW5zZSDDqWdhbGVtZW50IGxlIG1vdXZlbWVudCBkaWFnb25hbCBhZmluIGTigJlvYnRlbmlyIGxlIGNvw7t0IHRvdGFsIGR1IHBhc3NhZ2Ugw6AgdHJhdmVycyBsYSBjZWxsdWxlLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQ29zdC1SYXN0ZXJfdGFnMUBAXCI6IFwiTGVzIHZhbGV1cnMgZHUgPHN0cm9uZz5SYXN0ZXIgZGUgY2/Du3Q8L3N0cm9uZz4gcGV1dmVudCDDqnRyZSBkZXMgZW50aWVycyBvdSBkZXMgbm9tYnJlcyDDoCB2aXJndWxlIGZsb3R0YW50ZSwgbWFpcyBlbGxlcyBuZSBwZXV2ZW50IHBhcyDDqnRyZSBuw6lnYXRpdmVzIG5pIG51bGxlcy5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiTGUgc2V1aWwgcXVlIGxlcyB2YWxldXJzIGRlIGNvw7t0IGN1bXVsw6kgbmUgcGV1dmVudCBwYXMgZMOpcGFzc2VyLiBTaSB1bmUgZGlzdGFuY2UgZGUgY2/Du3QgY3VtdWzDqSBkw6lwYXNzZSBjZXR0ZSB2YWxldXIsIGxhIHZhbGV1ciBlbiBzb3J0aWUgZGUgbOKAmWVtcGxhY2VtZW50IGRlIGNlbGx1bGUgZXN0IE5vRGF0YS4gTGEgZGlzdGFuY2UgbWF4aW1hbGUgZMOpZmluaXQgbOKAmcOpdGVuZHVlIHBvdXIgbGFxdWVsbGUgbGVzIGRpc3RhbmNlcyBkZSBjb8O7dCBjdW11bMOpIHNvbnQgY2FsY3Vsw6llcy4gTGEgZGlzdGFuY2UgcGFyIGTDqWZhdXQgdmEganVzcXXigJnDoCBs4oCZw6l0ZW5kdWUgZHUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiTXVsdGlwbGljYXRldXIgw6AgYXBwbGlxdWVyIGF1eCB2YWxldXJzIGRlIGNvw7t0LlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcxQEBcIjogXCJDZSBwYXJhbcOodHJlIHBlcm1ldCBkZSBjb250csO0bGVyIGxlIG1vZGUgZGUgZMOpcGxhY2VtZW50IG91IGxhIG1hZ25pdHVkZSDDoCB1bmUgc291cmNlLiBQbHVzIGxlIG11bHRpcGxpY2F0ZXVyIGVzdCDDqWxldsOpLCBwbHVzIGxlIGNvw7t0IGRlIGTDqXBsYWNlbWVudCBk4oCZdW5lIGNlbGx1bGUgw6AgdW5lIGF1dHJlIGVzdCBpbXBvcnRhbnQuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzJAQFwiOiBcIkxlcyB2YWxldXJzIGRvaXZlbnQgw6p0cmUgc3Vww6lyaWV1cmVzIMOgIHrDqXJvLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDEuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzNAQFwiOiBcIlZvdXMgcG91dmV6IHV0aWxpc2VyIHBvdXIgY2UgcGFyYW3DqHRyZSB1bmUgdmFsZXVyIG51bcOpcmlxdWUgKGRvdWJsZSkgb3UgdW4gY2hhbXAgZHUgPHN0cm9uZz5SYXN0ZXIgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfU291cmNlLVJhc3Rlcl90YWcwQEBcIjogXCJMZSByYXN0ZXIgZW4gZW50csOpZSByZXF1aXMgZGVzIGVtcGxhY2VtZW50cyBzb3VyY2UuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19Tb3VyY2UtUmFzdGVyX3RhZzFAQFwiOiBcIlJhc3RlciBxdWkgaWRlbnRpZmllIGxlcyBjZWxsdWxlcyBvdSBsZXMgZW1wbGFjZW1lbnRzIMOgIHBhcnRpciBkZXNxdWVscyBsYSBkaXN0YW5jZSBkZSBtb2luZHJlIGNvw7t0IGN1bXVsw6kgZXN0IGNhbGN1bMOpZSBwb3VyIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVuIHNvcnRpZS5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiQ2/Du3QgZGUgZMOpcGFydCBkdSBjYWxjdWwgZGVzIGNvw7t0cy4gQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgc3DDqWNpZmllciBsZSBjb8O7dCBmaXhlIGFzc29jacOpIMOgIHVuZSBzb3VyY2UuIFBsdXTDtHQgcXVlIGRlIGNvbW1lbmNlciBhdmVjIHVuIGNvw7t0IMOpZ2FsIMOgIDAsIGzigJlhbGdvcml0aG1lIGRlIGNvw7t0IGNvbW1lbmNlIGF2ZWMgbGEgdmFsZXVyIGTDqWZpbmllLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfU3RhcnQtQ29zdF90YWcxQEBcIjogXCJMYSB2YWxldXIgZG9pdCDDqnRyZSDDqWdhbGUgb3Ugc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMC5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX1RyYXZlbC1EaXJlY3Rpb25fdGFnMEBAXCI6IFwiRMOpZmluaXQgbGUgc2VucyBkdSB2b3lhZ2V1ciBlbiBjYXMgZOKAmWFwcGxpY2F0aW9uIGR1IHRhdXggZGUgcsOpc2lzdGFuY2Ugc291cmNlIGV0IGR1IGNvw7t0IGRlIGTDqXBhcnQgc291cmNlLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfVHJhdmVsLURpcmVjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPsOAIHBhcnRpciBkZSBsYSBzb3VyY2U8L3N0cm9uZz4gOiBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIHNvdXJjZSBldCBsZSBjb8O7dCBkZSBkw6lwYXJ0IHNvdXJjZSBzb250IGFwcGxpcXXDqXMgw6AgcGFydGlyIGRlIGxhIHNvdXJjZSBlbiBlbnRyw6llIGV0IGVuIHNlIGTDqXBsYcOnYW50IHZlcnMgbGVzIGNlbGx1bGVzIG5vbiBzb3VyY2VzLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlZlcnMgbGEgc291cmNlPC9zdHJvbmc+IDogbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBzb3VyY2UgZXQgbGUgY2/Du3QgZGUgZMOpcGFydCBzb3VyY2Ugc29udCBhcHBsaXF1w6lzIMOgIHBhcnRpciBkZSBjaGFxdWUgY2VsbHVsZSBub24gc291cmNlIGV0IGVuIHJldmVuYW50IHZlcnMgbGEgc291cmNlIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19UcmF2ZWwtRGlyZWN0aW9uX3RhZzVAQFwiOiBcIlNww6ljaWZpZXogbGUgbW90LWNsw6kgPHN0cm9uZz7DgCBwYXJ0aXIgZGUgbGEgc291cmNlPC9zdHJvbmc+IG91IDxzdHJvbmc+VmVycyBsYSBzb3VyY2U8L3N0cm9uZz4sIHF1aSBlc3QgYXBwbGlxdcOpIMOgIHRvdXRlcyBsZXMgc291cmNlcywgb3Ugc3DDqWNpZmlleiB1biBjaGFtcCBkYW5zIGxlIDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPiBxdWkgY29udGllbnQgbGVzIG1vdHMtY2zDqXMgcGVybWV0dGFudCBk4oCZaWRlbnRpZmllciBsZSBzZW5zIGRlIGTDqXBsYWNlbWVudCBwb3VyIGNoYXF1ZSBzb3VyY2UuIENlIGNoYW1wIGRvaXQgY29udGVuaXIgbGEgY2hhw65uZSAke0ZST01fU09VUkNFfSBvdSAke1RPX1NPVVJDRX0uXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcwQEBcIjogXCJDZSBwYXJhbcOodHJlIHNpbXVsZSBs4oCZYXVnbWVudGF0aW9uIGRlIGzigJllZmZvcnQgcG91ciBzdXJtb250ZXIgbGVzIGNvw7t0cyBhdSBmdXIgZXQgw6AgbWVzdXJlIHF1ZSBsZSBjb8O7dCBjdW11bMOpIGF1Z21lbnRlLiBJbCBwZXJtZXQgZGUgbW9kw6lsaXNlciBsYSBmYXRpZ3VlIGR1IHZveWFnZXVyLiBMZSBjb8O7dCBjdW11bMOpIGNyb2lzc2FudCBwb3VyIGF0dGVpbmRyZSB1bmUgY2VsbHVsZSBlc3QgbXVsdGlwbGnDqSBwYXIgbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBldCBham91dMOpIGF1IGNvw7t0IGVuZ2VuZHLDqSBwYXIgbGUgZMOpcGxhY2VtZW50IHZlcnMgbGEgY2VsbHVsZSBzdWl2YW50ZS5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzFAQFwiOiBcIklsIHPigJlhZ2l0IGTigJl1bmUgdmVyc2lvbiBtb2RpZmnDqWUgZOKAmXVuZSBmb3JtdWxlIGRlIHRhdXggZOKAmWludMOpcsOqdCBjb21wb3PDqSBxdWkgcGVybWV0IGRlIGNhbGN1bGVyIGxlIGNvw7t0IGFwcGFyZW50IGR1IGTDqXBsYWNlbWVudCDDoCB0cmF2ZXJzIHVuZSBjZWxsdWxlLiBBdmVjIGwnYXVnbWVudGF0aW9uIGR1IHRhdXggZGUgcsOpc2lzdGFuY2UsIGxlIGNvw7t0IGRlcyBjZWxsdWxlcyBxdWkgc29udCB2aXNpdMOpZXMgdWx0w6lyaWV1cmVtZW50IHMnYWNjcm/DrnQgw6lnYWxlbWVudC4gUGx1cyBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIGVzdCBpbXBvcnRhbnQsIHBsdXMgbGUgY2/Du3QgZGUgZMOpcGxhY2VtZW50IHZlcnMgbGEgY2VsbHVsZSBzdWl2YW50ZSBhdWdtZW50ZSwgbGVxdWVsIGVzdCBham91dMOpIHBvdXIgY2hhcXVlIG1vdXZlbWVudCBzdWl2YW50LiBQdWlzcXVlIGxlIHRhdXggZGUgcsOpc2lzdGFuY2UgZXN0IHNpbWlsYWlyZSDDoCB1biB0YXV4IGNvbXBvc8OpIGV0IHF14oCZaGFiaXR1ZWxsZW1lbnQgbGVzIHZhbGV1cnMgZGUgY2/Du3QgY3VtdWzDqSBzb250IHRyw6hzIGltcG9ydGFudGVzLCBub3VzIHN1Z2fDqXJvbnMgbOKAmXV0aWxpc2F0aW9uIGRlIHRhdXggZGUgcsOpc2lzdGFuY2UgZmFpYmxlcywgdGVscyBxdWUgMCwwMDUgb3UgZW5jb3JlIGluZsOpcmlldXJzLCBzZWxvbiBsZXMgdmFsZXVycyBkZSBjb8O7dCBjdW11bMOpLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMkBAXCI6IFwiTGEgdmFsZXVyIGRvaXQgw6p0cmUgc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIGNhcGFjaXTDqSBwYXIgZMOpZmF1dCBlc3QgbGltaXTDqWUgcGFyIGxlIHRyb27Dp29uIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWczQEBcIjogXCJWb3VzIHBvdXZleiB1dGlsaXNlciBwb3VyIGNlIHBhcmFtw6h0cmUgdW5lIHZhbGV1ciBudW3DqXJpcXVlIChkb3VibGUpIG91IHVuIGNoYW1wIGR1IDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPi5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfQ2FwYWNpdHlfdGFnMEBAXCI6IFwiRMOpZmluaXQgbGEgY2FwYWNpdMOpIGRlIGNvw7t0IHBvdXIgbGUgdm95YWdldXIgcG91ciB1bmUgc291cmNlLiBMZXMgY2FsY3VscyBkZSBjb8O7dCBjb250aW51ZW50IHBvdXIgY2hhcXVlIHNvdXJjZSBqdXNxdeKAmcOgIGNlIHF1ZSBsYSBjYXBhY2l0w6kgc3DDqWNpZmnDqWUgc29pdCBhdHRlaW50ZS5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfQ2FwYWNpdHlfdGFnMUBAXCI6IFwiTGEgdmFsZXVyIGRvaXQgw6p0cmUgc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIGNhcGFjaXTDqSBwYXIgZMOpZmF1dCBlc3QgbGltaXTDqWUgcGFyIGxlIHRyb27Dp29uIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX0NhcGFjaXR5X3RhZzJAQFwiOiBcIlZvdXMgcG91dmV6IHV0aWxpc2VyIHBvdXIgY2UgcGFyYW3DqHRyZSB1bmUgdmFsZXVyIG51bcOpcmlxdWUgKGRvdWJsZSkgb3UgdW4gY2hhbXAgZHUgPHN0cm9uZz5SYXN0ZXIgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9Db3N0LVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSByZXF1aXMgZMOpZmluaXNzYW50IGxlIGNvw7t0IG91IGzigJlpbXDDqWRhbmNlIGRlIGTDqXBsYWNlbWVudCBwbGFuaW3DqXRyaXF1ZSDDoCB0cmF2ZXJzIGNoYXF1ZSBjZWxsdWxlLiBMYSB2YWxldXIgw6AgY2hhcXVlIGVtcGxhY2VtZW50IGRlIGNlbGx1bGUgcmVwcsOpc2VudGUgbGUgY2/Du3QgcGFyIHVuaXTDqSBkZSBkaXN0YW5jZSBwb3VyIGxlIGTDqXBsYWNlbWVudCDDoCB0cmF2ZXJzIGNoYXF1ZSBjZWxsdWxlLiBDaGFxdWUgdmFsZXVyIGTigJllbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVzdCBtdWx0aXBsacOpZSBwYXIgbGEgcsOpc29sdXRpb24gZGUgY2VsbHVsZSBldCBjb21wZW5zZSDDqWdhbGVtZW50IGxlIG1vdXZlbWVudCBkaWFnb25hbCBhZmluIGTigJlvYnRlbmlyIGxlIGNvw7t0IHRvdGFsIGR1IHBhc3NhZ2Ugw6AgdHJhdmVycyBsYSBjZWxsdWxlLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9Db3N0LVJhc3Rlcl90YWcxQEBcIjogXCJMZXMgdmFsZXVycyBkdSA8c3Ryb25nPlJhc3RlciBkZSBjb8O7dDwvc3Ryb25nPiBwZXV2ZW50IMOqdHJlIGRlcyBlbnRpZXJzIG91IGRlcyBub21icmVzIMOgIHZpcmd1bGUgZmxvdHRhbnRlLCBtYWlzIGVsbGVzIG5lIHBldXZlbnQgcGFzIMOqdHJlIG7DqWdhdGl2ZXMgbmkgbnVsbGVzLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9NYXhpbXVtLURpc3RhbmNlX3RhZzBAQFwiOiBcIkxlIHNldWlsIHF1ZSBsZXMgdmFsZXVycyBkZSBjb8O7dCBjdW11bMOpIG5lIHBldXZlbnQgcGFzIGTDqXBhc3Nlci4gU2kgdW5lIGRpc3RhbmNlIGRlIGNvw7t0IGN1bXVsw6kgZMOpcGFzc2UgY2V0dGUgdmFsZXVyLCBsYSB2YWxldXIgZW4gc29ydGllIGRlIGzigJllbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVzdCBOb0RhdGEuIExhIGRpc3RhbmNlIG1heGltYWxlIGTDqWZpbml0IGzigJnDqXRlbmR1ZSBwb3VyIGxhcXVlbGxlIGxlcyBkaXN0YW5jZXMgZGUgY2/Du3QgY3VtdWzDqSBzb250IGNhbGN1bMOpZXMuIExhIGRpc3RhbmNlIHBhciBkw6lmYXV0IHZhIGp1c3F14oCZw6AgbOKAmcOpdGVuZHVlIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiTXVsdGlwbGljYXRldXIgw6AgYXBwbGlxdWVyIGF1eCB2YWxldXJzIGRlIGNvw7t0LlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzFAQFwiOiBcIkNlIHBhcmFtw6h0cmUgcGVybWV0IGRlIGNvbnRyw7RsZXIgbGUgbW9kZSBkZSBkw6lwbGFjZW1lbnQgb3UgbGEgbWFnbml0dWRlIMOgIHVuZSBzb3VyY2UuIFBsdXMgbGUgbXVsdGlwbGljYXRldXIgZXN0IMOpbGV2w6ksIHBsdXMgbGUgY2/Du3QgZGUgZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSDDoCB1bmUgYXV0cmUgZXN0IGltcG9ydGFudC5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcyQEBcIjogXCJMZXMgdmFsZXVycyBkb2l2ZW50IMOqdHJlIHN1cMOpcmlldXJlcyDDoCB6w6lyby4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAxLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzNAQFwiOiBcIlZvdXMgcG91dmV6IHV0aWxpc2VyIHBvdXIgY2UgcGFyYW3DqHRyZSB1bmUgdmFsZXVyIG51bcOpcmlxdWUgKGRvdWJsZSkgb3UgdW4gY2hhbXAgZHUgPHN0cm9uZz5SYXN0ZXIgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBlbiBlbnRyw6llIHJlcXVpcyBkZXMgZW1wbGFjZW1lbnRzIHNvdXJjZS5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfU291cmNlLVJhc3Rlcl90YWcxQEBcIjogXCJSYXN0ZXIgcXVpIGlkZW50aWZpZSBsZXMgY2VsbHVsZXMgb3UgbGVzIGVtcGxhY2VtZW50cyDDoCBwYXJ0aXIgZGVzcXVlbHMgbGEgZGlzdGFuY2UgZGUgbW9pbmRyZSBjb8O7dCBjdW11bMOpIGVzdCBjYWxjdWzDqWUgcG91ciBjaGFxdWUgZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlbiBzb3J0aWUuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiQ2/Du3QgZGUgZMOpcGFydCBkdSBjYWxjdWwgZGVzIGNvw7t0cy4gQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgc3DDqWNpZmllciBsZSBjb8O7dCBmaXhlIGFzc29jacOpIMOgIHVuZSBzb3VyY2UuIFBsdXTDtHQgcXVlIGRlIGNvbW1lbmNlciBhdmVjIHVuIGNvw7t0IMOpZ2FsIMOgIDAsIGzigJlhbGdvcml0aG1lIGRlIGNvw7t0IGNvbW1lbmNlIGF2ZWMgbGEgdmFsZXVyIGTDqWZpbmllLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9TdGFydC1Db3N0X3RhZzFAQFwiOiBcIkxhIHZhbGV1ciBkb2l0IMOqdHJlIMOpZ2FsZSBvdSBzdXDDqXJpZXVyZSDDoCB6w6lyby4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAwLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9UcmF2ZWwtRGlyZWN0aW9uX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxlIHNlbnMgZHUgdm95YWdldXIgZW4gY2FzIGTigJlhcHBsaWNhdGlvbiBkdSB0YXV4IGRlIHLDqXNpc3RhbmNlIHNvdXJjZSBldCBkdSBjb8O7dCBkZSBkw6lwYXJ0IHNvdXJjZS5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfVHJhdmVsLURpcmVjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPsOAIHBhcnRpciBkZSBsYSBzb3VyY2U8L3N0cm9uZz4gOiBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIHNvdXJjZSBldCBsZSBjb8O7dCBkZSBkw6lwYXJ0IHNvdXJjZSBzb250IGFwcGxpcXXDqXMgw6AgcGFydGlyIGRlIGxhIHNvdXJjZSBlbiBlbnRyw6llIGV0IGVuIHNlIGTDqXBsYcOnYW50IHZlcnMgbGVzIGNlbGx1bGVzIG5vbiBzb3VyY2VzLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9UcmF2ZWwtRGlyZWN0aW9uX3RhZzNAQFwiOiBcIjxzdHJvbmc+VmVycyBsYSBzb3VyY2U8L3N0cm9uZz4gOiBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIHNvdXJjZSBldCBsZSBjb8O7dCBkZSBkw6lwYXJ0IHNvdXJjZSBzb250IGFwcGxpcXXDqXMgw6AgcGFydGlyIGRlIGNoYXF1ZSBjZWxsdWxlIG5vbiBzb3VyY2UgZXQgZW4gcmV2ZW5hbnQgdmVycyBsYSBzb3VyY2UgZW4gZW50csOpZS5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfVHJhdmVsLURpcmVjdGlvbl90YWc1QEBcIjogXCJTcMOpY2lmaWV6IGxlIG1vdC1jbMOpIDxzdHJvbmc+w4AgcGFydGlyIGRlIGxhIHNvdXJjZTwvc3Ryb25nPiBvdSA8c3Ryb25nPlZlcnMgbGEgc291cmNlPC9zdHJvbmc+LCBxdWkgZXN0IGFwcGxpcXXDqSDDoCB0b3V0ZXMgbGVzIHNvdXJjZXMsIG91IHNww6ljaWZpZXogdW4gY2hhbXAgZGFucyBsZSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4gcXVpIGNvbnRpZW50IGxlcyBtb3RzLWNsw6lzIHBlcm1ldHRhbnQgZOKAmWlkZW50aWZpZXIgbGUgc2VucyBkZSBkw6lwbGFjZW1lbnQgcG91ciBjaGFxdWUgc291cmNlLiBDZSBjaGFtcCBkb2l0IGNvbnRlbmlyIGxhIGNoYcOubmUgJHtGUk9NX1NPVVJDRX0gb3UgJHtUT19TT1VSQ0V9LlwiLFxuXHRcIkBAQ3VydmF0dXJlX0N1cnZhdHVyZS1UeXBlX3RhZzBAQFwiOiBcIkxlIHR5cGUgZGUgY291cmJ1cmUgYWNjZW50dWUgZGlmZsOpcmVudGVzIGV4cG9zaXRpb25zIGRlIGxhIHBlbnRlLiBJbCBleGlzdGUgdHJvaXMgb3B0aW9ucyBkZSBjb3VyYnVyZSA6XCIsXG5cdFwiQEBDdXJ2YXR1cmVfQ3VydmF0dXJlLVR5cGVfdGFnMUBAXCI6IFwiUGxhbmlmb3JtZSA6IGVzdCBwZXJwZW5kaWN1bGFpcmUgw6AgbGEgZGlyZWN0aW9uIGRlIGxhIHBlbnRlIG1heGltYWxlLiBFbGxlIGFmZmVjdGUgbGEgY29udmVyZ2VuY2UgZXQgbGEgZGl2ZXJnZW5jZSBkZSBmbHV4IHN1ciBsYSBzdXJmYWNlLlwiLFxuXHRcIkBAQ3VydmF0dXJlX0N1cnZhdHVyZS1UeXBlX3RhZzJAQFwiOiBcIkxvbmdpdHVkaW5hbGUgOiBlc3QgcGFyYWxsw6hsZSDDoCBsYSBwZW50ZSBldCBpbmRpcXVlIGxhIGRpcmVjdGlvbiBkZSBsYSBwZW50ZSBtYXhpbWFsZS4gRWxsZSBhZmZlY3RlIGwnYWNjw6lsw6lyYXRpb24gZXQgbGEgZMOpY8OpbMOpcmF0aW9uIGRlIGZsdXggc3VyIGxhIHN1cmZhY2UuXCIsXG5cdFwiQEBDdXJ2YXR1cmVfQ3VydmF0dXJlLVR5cGVfdGFnM0BAXCI6IFwiU3RhbmRhcmQgOiBhc3NvY2llIGxlcyBjb3VyYnVyZXMgZGUgdHlwZSA8c3Ryb25nPlByb2ZpbDwvc3Ryb25nPiBldCA8c3Ryb25nPlBsYW5pZm9ybWU8L3N0cm9uZz4uXCIsXG5cdFwiQEBDdXJ2YXR1cmVfREVNX3RhZzBAQFwiOiBcIlJhc3RlciBkZSBtb2TDqGxlIG51bcOpcmlxdWUgZGUgdGVycmFpbiAoTU5UKS5cIixcblx0XCJAQEN1cnZhdHVyZV9aLUZhY3Rvcl90YWcwQEBcIjogXCJMZSBmYWN0ZXVyIHogYWp1c3RlIGxlcyB1bml0w6lzIGRlIG1lc3VyZSBkZXMgdW5pdMOpcyB6IGxvcnNxdSdlbGxlcyBzb250IGRpZmbDqXJlbnRlcyBkZXMgdW5pdMOpcyB4LHkgZGUgbGEgc3VyZmFjZSBlbiBlbnRyw6llLiBTaSBsZXMgdW5pdMOpcyB4LHkgZXQgbGVzIHVuaXTDqXMgeiB1dGlsaXNlbnQgbGVzIG3Dqm1lcyB1bml0w6lzIGRlIG1lc3VyZSwgbGUgZmFjdGV1ciB6IGRvaXQgw6p0cmUgw6lnYWwgw6AgMS4gTGVzIHZhbGV1cnMgeiBkZSBsYSBzdXJmYWNlIGVuIGVudHLDqWUgc29udCBtdWx0aXBsacOpZXMgcGFyIGxlIGZhY3RldXIgeiBsb3JzIGR1IGNhbGN1bCBkZSBsYSBzdXJmYWNlIGZpbmFsZSBlbiBzb3J0aWUuIFBhciBleGVtcGxlLCBzaSBsJ3VuaXTDqSB6IGVzdCBleHByaW3DqWUgZW4gcGllZHMgZXQgcXVlIGxlcyB1bml0w6lzIHgseSBzb250IGV4cHJpbcOpZXMgZW4gbcOodHJlcywgdm91cyBkZXZleiB1dGlsaXNlciB1biBmYWN0ZXVyIHogw6lnYWwgw6AgMCwzMDQ4IHBvdXIgZWZmZWN0dWVyIGxhIGNvbnZlcnNpb24gcGllZHMvbcOodHJlcyAoMSBwaWVkID0gMCwzMDQ4IG3DqHRyZSkuXCIsXG5cdFwiQEBEaXZpZGVfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBEaXZpZGVfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQERpdmlkZV9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBARGl2aWRlX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBEaXZpZGVfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQERpdmlkZV9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQERpdmlkZV9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBEaXZpZGVfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQERpdmlkZV9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBEaXZpZGVfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQERpdmlkZV9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQERpdmlkZV9SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSBkb250IGxhIHZhbGV1ciBlc3QgZGl2aXPDqWUgcGFyIGxhIGRldXhpw6htZSBlbnRyw6llLlwiLFxuXHRcIkBARGl2aWRlX1Jhc3Rlcl90YWcxQEBcIjogXCJVbiBub21icmUgcGV1dCDDqnRyZSB1dGlsaXPDqSBlbiBlbnRyw6llIHBvdXIgY2UgcGFyYW3DqHRyZSwgw6AgY29uZGl0aW9uIHF14oCZdW4gcmFzdGVyIHNvaXQgc3DDqWNpZmnDqSBwb3VyICR7UmFzdGVyMn0uXCIsXG5cdFwiQEBEaXZpZGVfUmFzdGVyMl90YWcwQEBcIjogXCJFbnRyw6llIHBhciBsYXF1ZWxsZSBlc3QgZGl2aXPDqWUgbGEgdmFsZXVyIGRlIGxhIHByZW1pw6hyZSBlbnRyw6llLlwiLFxuXHRcIkBARGl2aWRlX1Jhc3RlcjJfdGFnMUBAXCI6IFwiVW4gbm9tYnJlIHBldXQgw6p0cmUgdXRpbGlzw6kgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciAke1Jhc3Rlcn0uXCIsXG5cdFwiQEBFbGV2YXRpb24tVm9pZC1GaWxsX0RFTV90YWcwQEBcIjogXCJERU0gZW4gZW50csOpZS5cIixcblx0XCJAQEVsZXZhdGlvbi1Wb2lkLUZpbGxfTWF4LVZvaWQtV2lkdGhfdGFnMEBAXCI6IFwiTGEgdmFsZXVyIGRlIGxhcmdldXIgZGUgdmlkZSBtYXhpbWFsZSBlc3QgdXRpbGlzw6llIHBvdXIgcHLDqWNpc2VyIGxhIHRhaWxsZSBkZSB2aWRlIGxhIHBsdXMgaW1wb3J0YW50ZSBxdWUgdm91cyBzb3VoYWl0ZXogcmVtcGxpci4gU2kgbGEgbGFyZ2V1ciBvdSBsYSBoYXV0ZXVyIGRlIGwnZW1wcmlzZSBhdXRvdXIgZHUgdmlkZSBlc3QgcGx1cyBncmFuZGUgcXVlIGxhIHZhbGV1ciBkZSBsYXJnZXVyIGRlIHZpZGUgbWF4aW1hbGUsIGxlIHZpZGUgbidlc3QgcGFzIHJlbXBsaS4gTGVzIHVuaXTDqXMgZGUgY2UgcGFyYW3DqHRyZSBzb250IGlkZW50aXF1ZXMgw6AgY2VsbGVzIHV0aWxpc8OpZXMgZGFucyBsZSBzeXN0w6htZSBkZSByw6lmw6lyZW5jZSBzcGF0aWFsZSBkZSB2b3MgZG9ubsOpZXMuXCIsXG5cdFwiQEBFbGV2YXRpb24tVm9pZC1GaWxsX01heC1Wb2lkLVdpZHRoX3RhZzFAQFwiOiBcIlNpIGNlIHBhcmFtw6h0cmUgbuKAmWVzdCBwYXMgcmVuc2VpZ27DqSBvdSBhIGxhIHZhbGV1ciAkezB9LCBhdWN1bmUgbGFyZ2V1ciBtYXhpbWFsZSBu4oCZZXN0IHV0aWxpc8OpZSBldCB0b3VzIGxlcyB2aWRlcyBzb250IHJlbXBsaXMuIExhIHZhbGV1ciAkey0xfSBzaWduaWZpZSBxdeKAmWF1Y3VuIHJlbXBsaXNzYWdlIGRlcyB2aWRlcyBu4oCZYSBsaWV1LlwiLFxuXHRcIkBARWxldmF0aW9uLVZvaWQtRmlsbF9TaG9ydC1SYW5nZS1JRFctUmFkaXVzX3RhZzBAQFwiOiBcIkxlIHJheW9uIGRlIHJlY2hlcmNoZSBtYXhpbXVtIHF1aSBzZXJhIHV0aWxpc8OpIHBvdXIgbGUgcmVtcGxpc3NhZ2UgZGVzIHZpZGVzLiBVbiB2aWRlIHBsdXMgw6lsb2lnbsOpLCBwYXIgcmFwcG9ydCDDoCBu4oCZaW1wb3J0ZSBxdWVsIHBpeGVsIHZhbGlkZSwgcXVlIGNldHRlIHZhbGV1ciBzZXVpbCByZXN0ZXJhIHZpZGUuIExlcyB1bml0w6lzIGRlIGNlIHBhcmFtw6h0cmUgc29udCBpZGVudGlxdWVzIMOgIGNlbGxlcyB1dGlsaXPDqWVzIGRhbnMgbGUgc3lzdMOobWUgZGUgcsOpZsOpcmVuY2Ugc3BhdGlhbGUgZGUgdm9zIGRvbm7DqWVzLlwiLFxuXHRcIkBARWxldmF0aW9uLVZvaWQtRmlsbF9TaG9ydC1SYW5nZS1JRFctUmFkaXVzX3RhZzFAQFwiOiBcIlNpIGxhIHZhbGV1ciBkZSBjZSBwYXJhbcOodHJlIGVzdCBub24gcmVuc2VpZ27DqWUsICR7MH0sIG91ICR7LTF9IGNlIHBhcmFtw6h0cmUgbuKAmWVzdCBwYXMgdXRpbGlzw6kuXCIsXG5cdFwiQEBFcXVhbC10b19DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEVxdWFsLXRvX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBFcXVhbC10b19DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBARXF1YWwtdG9fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEVxdWFsLXRvX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBFcXVhbC10b19DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEVxdWFsLXRvX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEVxdWFsLXRvX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBFcXVhbC10b19FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBFcXVhbC10b19FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBARXF1YWwtdG9fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBFcXVhbC10b19SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSDDoCBjb21wYXJlciDDoCBsYSBzZWNvbmRlIGVudHLDqWUgcG91ciB2w6lyaWZpZXIgbCfDqWdhbGl0w6kgZGVzIGRldXggZW50csOpZXMuXCIsXG5cdFwiQEBFcXVhbC10b19SYXN0ZXJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQEVxdWFsLXRvX1Jhc3RlcjJfdGFnMEBAXCI6IFwiRW50csOpZSDDoCBjb21wYXJlciDDoCBsYSBwcmVtacOocmUgZW50csOpZSBwb3VyIHbDqXJpZmllciBsJ8OpZ2FsaXTDqSBkZXMgZGV1eCBlbnRyw6llcy5cIixcblx0XCJAQEVxdWFsLXRvX1Jhc3RlcjJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX0NlbGxzaXplX3RhZzBAQFwiOiBcIlRhaWxsZSBkZXMgY2VsbHVsZXMgcXVpIHNlcmEgdXRpbGlzw6llIHBvdXIgbGEgY3LDqWF0aW9uIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9DZWxsc2l6ZV90YWcxQEBcIjogXCJTaSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBhIMOpdMOpIGV4cGxpY2l0ZW1lbnQgZMOpZmluaWUgZGFucyA8c3Ryb25nPkVudmlyb25uZW1lbnRzIGTigJlhbmFseXNlPC9zdHJvbmc+LCBpbCBz4oCZYWdpdCBkZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBwYXIgZMOpZmF1dC4gU2kgZWxsZSBu4oCZYSBwYXMgw6l0w6kgZMOpZmluaWUsIGxhIHRhaWxsZSBkZSBjZWxsdWxlIGVuIHNvcnRpZSBlc3QgaWRlbnRpcXVlIMOgIGNlbGxlIGR1IDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPi5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX0Rpc3RhbmNlLU1ldGhvZF90YWcwQEBcIjogXCJEw6l0ZXJtaW5lIHNpIGxhIGRpc3RhbmNlIGRvaXQgw6p0cmUgY2FsY3Vsw6llIGF2ZWMgdW5lIG3DqXRob2RlIHBsYW5lIChUZXJyZSBwbGF0ZSkgb3UgZ8Opb2TDqXNpcXVlIChlbGxpcHNvw69kZSkuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9EaXN0YW5jZS1NZXRob2RfdGFnMUBAXCI6IFwiR8Opb2TDqXNpcXVlIDogbGlnbmUgbGEgcGx1cyBjb3VydGUgZW50cmUgZGV1eCBwb2ludHMgZOKAmXVuIHNwaMOpcm/Dr2RlIChlbGxpcHNvw69kZSkgc3VyIGxhIHN1cmZhY2UgZGUgbGEgVGVycmUuIExlcyByw6lzdWx0YXRzIG5lIGNoYW5nZW50IGRvbmMgcGFzIHF1ZWxsZSBxdWUgc29pdCBsYSBwcm9qZWN0aW9uIGVuIGVudHLDqWUgb3UgZW4gc29ydGllLiBWb3VzIHBvdXZleiB1dGlsaXNlciB1bmUgbGlnbmUgZ8Opb2TDqXNpcXVlIHNpIHZvdXMgc291aGFpdGV6IGTDqXRlcm1pbmVyIGxhIGRpc3RhbmNlIGxhIHBsdXMgY291cnRlIGVudHJlIGRldXggdmlsbGVzIHBvdXIgbGEgdHJhamVjdG9pcmUgZGUgdm9sIGTigJl1biBhdmlvbi4gT24gcGFybGUgw6lnYWxlbWVudCBkZSDCqyBsaWduZSBkZSBncmFuZCBjZXJjbGUgwrsgc2kgZWxsZSByZXBvc2Ugc3VyIHVuZSBzcGjDqHJlIHBsdXTDtHQgcXUndW5lIGVsbGlwc2/Dr2RlLlwiLFxuXHRcIkBARXVjbGlkZWFuLUFsbG9jYXRpb25fRGlzdGFuY2UtTWV0aG9kX3RhZzJAQFwiOiBcIlBsYW5lIDogbGEgbWVzdXJlIHBsYW5lIHV0aWxpc2UgZGVzIG1hdGjDqW1hdGlxdWVzIGNhcnTDqXNpZW5uZXMgZW4gMkQgcG91ciBjYWxjdWxlciBsYSBsb25ndWV1ciBldCBsYSBzdXJmYWNlLiBDZXR0ZSBvcHRpb24gZXN0IHVuaXF1ZW1lbnQgZGlzcG9uaWJsZSBsb3JzcXVlIGxlcyBtZXN1cmVzIHNvbnQgZWZmZWN0dcOpZXMgZGFucyB1biBzeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgcHJvamV0w6llcy4gTGUgcGxhbiAyRCBkZSBjZSBzeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgZXN0IGFsb3JzIHV0aWxpc8OpIGNvbW1lIGJhc2UgZGVzIG1lc3VyZXMuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9NYXhpbXVtLURpc3RhbmNlX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxhIGRpc3RhbmNlIGRlIHNldWlsIHByaXNlIGVuIGNvbXB0ZSBwb3VyIGVzdGltZXIgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlLiBTaSBsYSBkaXN0YW5jZSBwYXIgcmFwcG9ydCDDoCBsYSBzb3VyY2UgbGEgcGx1cyBwcm9jaGUgZMOpcGFzc2UgY2Ugc2V1aWwsIGxhIHNvcnRpZSBkZSBjZXR0ZSBjZWxsdWxlIHByZW5kIGxhIHZhbGV1ciAke05vRGF0YX0uXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9NYXhpbXVtLURpc3RhbmNlX3RhZzFAQFwiOiBcIkxhIGRpc3RhbmNlIHBhciBkw6lmYXV0IHZhIGp1c3F14oCZw6AgbOKAmcOpdGVuZHVlIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9SYXN0ZXItQmFycmllcnNfdGFnMEBAXCI6IFwiUmFzdGVyIHF1aSBkw6lmaW5pdCBsZXMgaW50ZXJydXB0aW9ucy5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX1Jhc3Rlci1CYXJyaWVyc190YWcxQEBcIjogXCJMZSBqZXUgZGUgZG9ubsOpZXMgZG9pdCBjb250ZW5pciB1bmUgdmFsZXVyICR7Tm9EYXRhfSBsb3JzcXXigJlpbCBu4oCZeSBhIHBhcyBk4oCZaW50ZXJydXB0aW9uLiBMZXMgaW50ZXJydXB0aW9ucyBzb250IHJlcHLDqXNlbnTDqWVzIHBhciBkZXMgdmFsZXVycyB2YWxpZGVzLCB5IGNvbXByaXMgesOpcm8uXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9SYXN0ZXItQmFycmllcnNfdGFnMkBAXCI6IFwiTGVzIGludGVycnVwdGlvbnMgcGV1dmVudCDDqnRyZSBkw6lmaW5pZXMgcGFyIHVuIGVudGllciBvdSB1biByYXN0ZXIgw6AgdmlyZ3VsZSBmbG90dGFudGUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9Tb3VyY2UtRmllbGRfdGFnMEBAXCI6IFwiQ2hhbXAgcGVybWV0dGFudCBk4oCZYXR0cmlidWVyIGRlcyB2YWxldXJzIGF1eCBlbXBsYWNlbWVudHMgc291cmNlcy4gSWwgZG9pdCDDqnRyZSBkZSB0eXBlIGVudGllci4gU2kgbGUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyPC9zdHJvbmc+IGEgw6l0w6kgZMOpZmluaSwgbGVzIHZhbGV1cnMgZGFucyBjZXR0ZSBlbnRyw6llIHNvbnQgcHJpb3JpdGFpcmVzIHN1ciB0b3V0IHBhcmFtw6h0cmUgZHUgPHN0cm9uZz5DaGFtcCBzb3VyY2U8L3N0cm9uZz4uXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIHJlcXVpcyBpZGVudGlmaWFudCBsZXMgZW1wbGFjZW1lbnRzIHNvdXJjZS4gRMOpdGVybWluZSwgcG91ciBjaGFxdWUgY2VsbHVsZSBkZSBsYSBzb3J0aWUsIGxhIHNvdXJjZSBsYSBwbHVzIHByb2NoZSBlbiBmb25jdGlvbiBkZSBsYSBkaXN0YW5jZSBldWNsaWRpZW5uZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX1NvdXJjZS1SYXN0ZXJfdGFnMUBAXCI6IFwiTGUgdHlwZSBlbiBlbnRyw6llIHBldXQgw6p0cmUgdW4gZW50aWVyIG91IHVuIG5vbWJyZSDDoCB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX1ZhbHVlLVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZOKAmWVudGllcnMgZW4gZW50csOpZSBxdWkgaWRlbnRpZmllIGxlcyB2YWxldXJzIGRlIHpvbmUgw6AgdXRpbGlzZXIgcG91ciBjaGFxdWUgZW1wbGFjZW1lbnQgc291cmNlIGVuIGVudHLDqWUuIFBvdXIgY2hhcXVlIGNlbGx1bGUgZOKAmWVtcGxhY2VtZW50IHNvdXJjZSwgbGEgdmFsZXVyIGTDqWZpbmllIHBhciBsZSA8c3Ryb25nPlJhc3RlciBkZSB2YWxldXI8L3N0cm9uZz4gZXN0IGF0dHJpYnXDqWUgw6AgdG91dGVzIGxlcyBjZWxsdWxlcyBhbGxvdcOpZXMgw6AgbOKAmWVtcGxhY2VtZW50IHNvdXJjZSBwb3VyIGxlIGNhbGN1bC4gTGUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyPC9zdHJvbmc+IGVzdCBwcmlvcml0YWlyZSBzdXIgdG91dCBwYXJhbcOodHJlIGR1IDxzdHJvbmc+Q2hhbXAgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9DZWxsc2l6ZV90YWcwQEBcIjogXCJUYWlsbGUgZGVzIGNlbGx1bGVzIHF1aSBzZXJhIHV0aWxpc8OpZSBwb3VyIGxhIGNyw6lhdGlvbiBkdSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9DZWxsc2l6ZV90YWcxQEBcIjogXCJTaSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBhIMOpdMOpIGV4cGxpY2l0ZW1lbnQgZMOpZmluaWUgZGFucyA8c3Ryb25nPkVudmlyb25uZW1lbnRzIGTigJlhbmFseXNlPC9zdHJvbmc+LCBpbCBz4oCZYWdpdCBkZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBwYXIgZMOpZmF1dC4gU2kgZWxsZSBu4oCZYSBwYXMgw6l0w6kgZMOpZmluaWUsIGxhIHRhaWxsZSBkZSBjZWxsdWxlIGVuIHNvcnRpZSBlc3QgaWRlbnRpcXVlIMOgIGNlbGxlIGR1IDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPi5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fRGlzdGFuY2UtTWV0aG9kX3RhZzBAQFwiOiBcIkTDqXRlcm1pbmUgc2kgbGEgZGlzdGFuY2UgZG9pdCDDqnRyZSBjYWxjdWzDqWUgYXZlYyB1bmUgbcOpdGhvZGUgcGxhbmUgKFRlcnJlIHBsYXRlKSBvdSBnw6lvZMOpc2lxdWUgKGVsbGlwc2/Dr2RlKS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fRGlzdGFuY2UtTWV0aG9kX3RhZzFAQFwiOiBcIkfDqW9kw6lzaXF1ZSA6IGxpZ25lIGxhIHBsdXMgY291cnRlIGVudHJlIGRldXggcG9pbnRzIGTigJl1biBzcGjDqXJvw69kZSAoZWxsaXBzb8OvZGUpIHN1ciBsYSBzdXJmYWNlIGRlIGxhIFRlcnJlLiBMZXMgcsOpc3VsdGF0cyBuZSBjaGFuZ2VudCBkb25jIHBhcyBxdWVsbGUgcXVlIHNvaXQgbGEgcHJvamVjdGlvbiBlbiBlbnRyw6llIG91IGVuIHNvcnRpZS4gVm91cyBwb3V2ZXogdXRpbGlzZXIgdW5lIGxpZ25lIGfDqW9kw6lzaXF1ZSBzaSB2b3VzIHNvdWhhaXRleiBkw6l0ZXJtaW5lciBsYSBkaXN0YW5jZSBsYSBwbHVzIGNvdXJ0ZSBlbnRyZSBkZXV4IHZpbGxlcyBwb3VyIGxhIHRyYWplY3RvaXJlIGRlIHZvbCBk4oCZdW4gYXZpb24uIE9uIHBhcmxlIMOpZ2FsZW1lbnQgZGUgwqsgbGlnbmUgZGUgZ3JhbmQgY2VyY2xlIMK7IHNpIGVsbGUgcmVwb3NlIHN1ciB1bmUgc3Bow6hyZSBwbHV0w7R0IHF1J3VuZSBlbGxpcHNvw69kZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fRGlzdGFuY2UtTWV0aG9kX3RhZzJAQFwiOiBcIlBsYW5lIDogbGEgbWVzdXJlIHBsYW5lIHV0aWxpc2UgZGVzIG1hdGjDqW1hdGlxdWVzIGNhcnTDqXNpZW5uZXMgZW4gMkQgcG91ciBjYWxjdWxlciBsYSBsb25ndWV1ciBldCBsYSBzdXJmYWNlLiBDZXR0ZSBvcHRpb24gZXN0IHVuaXF1ZW1lbnQgZGlzcG9uaWJsZSBsb3JzcXVlIGxlcyBtZXN1cmVzIHNvbnQgZWZmZWN0dcOpZXMgZGFucyB1biBzeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgcHJvamV0w6llcy4gTGUgcGxhbiAyRCBkZSBjZSBzeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgZXN0IGFsb3JzIHV0aWxpc8OpIGNvbW1lIGJhc2UgZGVzIG1lc3VyZXMuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlyZWN0aW9uX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiRMOpZmluaXQgbGEgZGlzdGFuY2UgZGUgc2V1aWwgcHJpc2UgZW4gY29tcHRlIHBvdXIgZXN0aW1lciBsYSBkaXJlY3Rpb24gcGFyIHJhcHBvcnQgw6AgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlLiBTaSBsYSBkaXN0YW5jZSBwYXIgcmFwcG9ydCDDoCBsYSBzb3VyY2UgbGEgcGx1cyBwcm9jaGUgZMOpcGFzc2UgY2Ugc2V1aWwsIGxhIHNvcnRpZSBkZSBjZXR0ZSBjZWxsdWxlIHByZW5kIGxhIHZhbGV1ciAke05vRGF0YX0uXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlyZWN0aW9uX01heGltdW0tRGlzdGFuY2VfdGFnMUBAXCI6IFwiTGEgZGlzdGFuY2UgcGFyIGTDqWZhdXQgdmEganVzcXXigJnDoCBs4oCZw6l0ZW5kdWUgZHUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fUmFzdGVyLUJhcnJpZXJzX3RhZzBAQFwiOiBcIlJhc3RlciBxdWkgZMOpZmluaXQgbGVzIGludGVycnVwdGlvbnMuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlyZWN0aW9uX1Jhc3Rlci1CYXJyaWVyc190YWcxQEBcIjogXCJMZSBqZXUgZGUgZG9ubsOpZXMgZG9pdCBjb250ZW5pciB1bmUgdmFsZXVyIE5vRGF0YSBsb3JzcXXigJlpbCBu4oCZeSBhIHBhcyBk4oCZaW50ZXJydXB0aW9uLiBMZXMgaW50ZXJydXB0aW9ucyBzb250IHJlcHLDqXNlbnTDqWVzIHBhciBkZXMgdmFsZXVycyB2YWxpZGVzLCB5IGNvbXByaXMgesOpcm8uXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlyZWN0aW9uX1Jhc3Rlci1CYXJyaWVyc190YWcyQEBcIjogXCJMZXMgaW50ZXJydXB0aW9ucyBwZXV2ZW50IMOqdHJlIGTDqWZpbmllcyBwYXIgdW4gZW50aWVyIG91IHVuIHJhc3RlciDDoCB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fU291cmNlLVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSByZXF1aXMgcXVpIGlkZW50aWZpZSBsZXMgY2VsbHVsZXMgb3UgbGVzIGVtcGxhY2VtZW50cyBwYXIgcmFwcG9ydCBhdXhxdWVscyBsYSBkaXJlY3Rpb24gZXVjbGlkaWVubmUgZXN0IGNhbGN1bMOpZSBwb3VyIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVuIHNvcnRpZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fU291cmNlLVJhc3Rlcl90YWcxQEBcIjogXCJMZSB0eXBlIGVuIGVudHLDqWUgcGV1dCDDqnRyZSB1biBlbnRpZXIgb3UgdW4gbm9tYnJlIMOgIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX0NlbGxzaXplX3RhZzBAQFwiOiBcIlRhaWxsZSBkZXMgY2VsbHVsZXMgcXVpIHNlcmEgdXRpbGlzw6llIHBvdXIgbGEgY3LDqWF0aW9uIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfQ2VsbHNpemVfdGFnMUBAXCI6IFwiU2kgbGEgdGFpbGxlIGRlIGNlbGx1bGUgYSDDqXTDqSBleHBsaWNpdGVtZW50IGTDqWZpbmllIGRhbnMgPHN0cm9uZz5FbnZpcm9ubmVtZW50cyBk4oCZYW5hbHlzZTwvc3Ryb25nPiwgaWwgc+KAmWFnaXQgZGUgbGEgdGFpbGxlIGRlIGNlbGx1bGUgcGFyIGTDqWZhdXQuIFNpIGVsbGUgbuKAmWEgcGFzIMOpdMOpIGTDqWZpbmllLCBsYSB0YWlsbGUgZGUgY2VsbHVsZSBlbiBzb3J0aWUgZXN0IGlkZW50aXF1ZSDDoCBjZWxsZSBkdSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4uXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfRGlzdGFuY2UtTWV0aG9kX3RhZzBAQFwiOiBcIkTDqXRlcm1pbmUgc2kgbGEgZGlzdGFuY2UgZG9pdCDDqnRyZSBjYWxjdWzDqWUgYXZlYyB1bmUgbcOpdGhvZGUgcGxhbmUgKFRlcnJlIHBsYXRlKSBvdSBnw6lvZMOpc2lxdWUgKGVsbGlwc2/Dr2RlKS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXN0YW5jZV9EaXN0YW5jZS1NZXRob2RfdGFnMUBAXCI6IFwiR8Opb2TDqXNpcXVlIDogbGlnbmUgbGEgcGx1cyBjb3VydGUgZW50cmUgZGV1eCBwb2ludHMgZOKAmXVuIHNwaMOpcm/Dr2RlIChlbGxpcHNvw69kZSkgc3VyIGxhIHN1cmZhY2UgZGUgbGEgVGVycmUuIExlcyByw6lzdWx0YXRzIG5lIGNoYW5nZW50IGRvbmMgcGFzIHF1ZWxsZSBxdWUgc29pdCBsYSBwcm9qZWN0aW9uIGVuIGVudHLDqWUgb3UgZW4gc29ydGllLiBWb3VzIHBvdXZleiB1dGlsaXNlciB1bmUgbGlnbmUgZ8Opb2TDqXNpcXVlIHNpIHZvdXMgc291aGFpdGV6IGTDqXRlcm1pbmVyIGxhIGRpc3RhbmNlIGxhIHBsdXMgY291cnRlIGVudHJlIGRldXggdmlsbGVzIHBvdXIgbGEgdHJhamVjdG9pcmUgZGUgdm9sIGTigJl1biBhdmlvbi4gT24gcGFybGUgw6lnYWxlbWVudCBkZSDCqyBsaWduZSBkZSBncmFuZCBjZXJjbGUgwrsgc2kgZWxsZSByZXBvc2Ugc3VyIHVuZSBzcGjDqHJlIHBsdXTDtHQgcXUndW5lIGVsbGlwc2/Dr2RlLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX0Rpc3RhbmNlLU1ldGhvZF90YWcyQEBcIjogXCJQbGFuZSA6IGxhIG1lc3VyZSBwbGFuZSB1dGlsaXNlIGRlcyBtYXRow6ltYXRpcXVlcyBjYXJ0w6lzaWVubmVzIGVuIDJEIHBvdXIgY2FsY3VsZXIgbGEgbG9uZ3VldXIgZXQgbGEgc3VyZmFjZS4gQ2V0dGUgb3B0aW9uIGVzdCB1bmlxdWVtZW50IGRpc3BvbmlibGUgbG9yc3F1ZSBsZXMgbWVzdXJlcyBzb250IGVmZmVjdHXDqWVzIGRhbnMgdW4gc3lzdMOobWUgZGUgY29vcmRvbm7DqWVzIHByb2pldMOpZXMuIExlIHBsYW4gMkQgZGUgY2Ugc3lzdMOobWUgZGUgY29vcmRvbm7DqWVzIGVzdCBhbG9ycyB1dGlsaXPDqSBjb21tZSBiYXNlIGRlcyBtZXN1cmVzLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiU2V1aWwgcXVlIGxlcyB2YWxldXJzIGRlIGRpc3RhbmNlIGN1bXVsw6llIG5lIHBldXZlbnQgcGFzIGTDqXBhc3Nlci4gU2kgdW5lIGRpc3RhbmNlIGV1Y2xpZGllbm5lIGN1bXVsw6llIGTDqXBhc3NlIGNldHRlIHZhbGV1ciwgbGEgdmFsZXVyIGVuIHNvcnRpZSBkZSBs4oCZZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlc3QgTm9EYXRhLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX01heGltdW0tRGlzdGFuY2VfdGFnMUBAXCI6IFwiTGEgZGlzdGFuY2UgcGFyIGTDqWZhdXQgdmEganVzcXXigJnDoCBs4oCZw6l0ZW5kdWUgZHUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXN0YW5jZV9SYXN0ZXItQmFycmllcnNfdGFnMEBAXCI6IFwiUmFzdGVyIHF1aSBkw6lmaW5pdCBsZXMgaW50ZXJydXB0aW9ucy5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXN0YW5jZV9SYXN0ZXItQmFycmllcnNfdGFnMUBAXCI6IFwiTGUgamV1IGRlIGRvbm7DqWVzIGRvaXQgY29udGVuaXIgdW5lIHZhbGV1ciAke05vRGF0YX0gbG9yc3F14oCZaWwgbuKAmXkgYSBwYXMgZOKAmWludGVycnVwdGlvbi4gTGVzIGludGVycnVwdGlvbnMgc29udCByZXByw6lzZW50w6llcyBwYXIgZGVzIHZhbGV1cnMgdmFsaWRlcywgeSBjb21wcmlzIHrDqXJvLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX1Jhc3Rlci1CYXJyaWVyc190YWcyQEBcIjogXCJMZXMgaW50ZXJydXB0aW9ucyBwZXV2ZW50IMOqdHJlIGTDqWZpbmllcyBwYXIgdW4gZW50aWVyIG91IHVuIHJhc3RlciDDoCB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXN0YW5jZV9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBlbiBlbnRyw6llIHJlcXVpcyBxdWkgaWRlbnRpZmllIGxlcyBjZWxsdWxlcyBvdSBsZXMgZW1wbGFjZW1lbnRzIHBhciByYXBwb3J0IGF1eHF1ZWxzIGxhIGRpc3RhbmNlIGV1Y2xpZGllbm5lIGVzdCBjYWxjdWzDqWUgcG91ciBjaGFxdWUgZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlbiBzb3J0aWUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfU291cmNlLVJhc3Rlcl90YWcxQEBcIjogXCJMZSB0eXBlIGVuIGVudHLDqWUgcGV1dCDDqnRyZSB1biBlbnRpZXIgb3UgdW4gbm9tYnJlIMOgIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcIkBARXhwX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBARXhwX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBFeHBfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEV4cF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBARXhwX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBFeHBfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBFeHBfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBARXhwX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBFeHBfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBARXhwX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBFeHBfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBFeHBfUmFzdGVyX3RhZzBAQFwiOiBcIlZhbGV1cnMgZW4gZW50csOpZSBwb3VyIGxlc3F1ZWxsZXMgb24gY2FsY3VsZSBsYSBiYXNlIGUgZXhwb25lbnRpZWxsZS5cIixcblx0XCJAQEV4cDEwX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBARXhwMTBfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEV4cDEwX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBFeHAxMF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBARXhwMTBfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEV4cDEwX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBARXhwMTBfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBARXhwMTBfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEV4cDEwX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEV4cDEwX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBFeHAxMF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEV4cDEwX1Jhc3Rlcl90YWcwQEBcIjogXCJWYWxldXJzIGVuIGVudHLDqWUgcG91ciBsZXNxdWVsbGVzIG9uIGNhbGN1bGUgbGEgYmFzZSAxMCBleHBvbmVudGllbGxlLlwiLFxuXHRcIkBARXhwMl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQEV4cDJfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEV4cDJfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEV4cDJfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEV4cDJfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEV4cDJfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBFeHAyX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEV4cDJfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEV4cDJfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBARXhwMl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBARXhwMl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEV4cDJfUmFzdGVyX3RhZzBAQFwiOiBcIlZhbGV1cnMgZW4gZW50csOpZSBwb3VyIGxlc3F1ZWxsZXMgb24gY2FsY3VsZSBsYSBiYXNlIDIgZXhwb25lbnRpZWxsZS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfQmFuZF90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGxlcyBiYW5kZXMgw6AgZXh0cmFpcmUgZGFucyB1bmUgbGlzdGUgYmFzw6llIHN1ciBs4oCZb3B0aW9uIHV0aWxpc8OpZSBwb3VyIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Nw6l0aG9kZTwvc3Ryb25nPi5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfQ29tYmluYXRpb25fdGFnMEBAXCI6IFwiQ29tYmluYWlzb24gZGUgYmFuZGVzIG91IG9yZHJlIGRlcyBiYW5kZXMuIExhIGxpc3RlIGRlIHPDqWxlY3Rpb24gZMOpcGVuZCBkZSBs4oCZb3B0aW9uIDxzdHJvbmc+TcOpdGhvZGU8L3N0cm9uZz4gc3DDqWNpZmnDqWUuIFBhciBleGVtcGxlLCBzaSBsYSA8c3Ryb25nPk3DqXRob2RlPC9zdHJvbmc+IGNob2lzaWUgZXN0IDxzdHJvbmc+Tm9tcyBkZXMgYmFuZGVzPC9zdHJvbmc+LCB2b3VzIHBvdXZleiBzw6lsZWN0aW9ubmVyIHVuZSBjb21iaW5haXNvbiBCbGV1LCBWZXJ0IGV0IFJvdWdlIHBvdXIgZXh0cmFpcmUgdW5lIGltYWdlIGF1eCBjb3VsZXVycyBuYXR1cmVsbGVzLlwiLFxuXHRcIkBARXh0cmFjdC1CYW5kc19NZXRob2RfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZdW5lIGRlcyBtw6l0aG9kZXMgc3VpdmFudGVzIHBvdXIgZXh0cmFpcmUgbGVzIGNhbmF1eCA6XCIsXG5cdFwiQEBFeHRyYWN0LUJhbmRzX01ldGhvZF90YWcxQEBcIjogXCI8c3Ryb25nPklkZW50aWZpYW50cyBkZXMgYmFuZGVzPC9zdHJvbmc+IDogZMOpc2lnbmF0aW9uIG91IG51bcOpcm8gZGUgYmFuZGUgcXVpIGVzdCB1bmlxdWUgcG91ciBjaGFxdWUgY2FwdGV1ci4gSWxzIHBldXZlbnQgw6p0cmUgaWRlbnRpcXVlcyBhdXggdmFsZXVycyBkZSBs4oCZb3B0aW9uIDxzdHJvbmc+Tm9tcyBkZXMgYmFuZGVzPC9zdHJvbmc+LlwiLFxuXHRcIkBARXh0cmFjdC1CYW5kc19NZXRob2RfdGFnNEBAXCI6IFwiPHN0cm9uZz5Ob21zIGRlcyBiYW5kZXM8L3N0cm9uZz4gOiB1dGlsaXNlIGxlIG5vbSBkZSBsYSBiYW5kZSByZXByw6lzZW50YW50IGzigJlpbnRlcnZhbGxlIGRlIGxvbmd1ZXVyIGTigJlvbmRlIHN1ciBsZSBzcGVjdHJlIMOpbGVjdHJvbWFnbsOpdGlxdWUgKFJvdWdlLCBQcm9jaGUgaW5mcmFyb3VnZSwgSW5mcmFyb3VnZSB0aGVybWlxdWUsIHBhciBleGVtcGxlKS4gTGUgbm9tIGRlIGxhIGJhbmRlIGVzdCDDqWdhbGVtZW50IGTDqXNpZ27DqSBjb21tZSBs4oCZaWRlbnRpZmlhbnQgZGUgbnVtw6lybyBkZSBiYW5kZS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWV0aG9kX3RhZzZAQFwiOiBcIjxzdHJvbmc+TG9uZ3VldXJzIGTigJlvbmRlcyBkZXMgYmFuZGVzPC9zdHJvbmc+IDogbG9uZ3VldXIgZOKAmW9uZGUgc3VyIGxlIHNwZWN0cmUgw6lsZWN0cm9tYWduw6l0aXF1ZS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWlzc2luZy1CYW5kLUFjdGlvbl90YWcwQEBcIjogXCJJbmRpcXVleiBs4oCZYWN0aW9uIHF1aSB2YSBzZSBwcm9kdWlyZSBsb3JzcXXigJl1biBjYW5hbCBhdSBzZWluIGRlIGxhIGxpc3RlIGRlcyBjYW5hdXggw6AgZXh0cmFpcmUgbuKAmWVzdCBwYXMgZGlzcG9uaWJsZS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWlzc2luZy1CYW5kLUFjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPk1laWxsZXVyIHLDqXN1bHRhdDwvc3Ryb25nPiA6IFJlY2hlcmNoZSBsYSBtZWlsbGV1cmUgYmFuZGUgZGlzcG9uaWJsZSDDoCB1dGlsaXNlciDDoCBsYSBwbGFjZSBkZSBsYSBiYW5kZSBtYW5xdWFudGUgZW4gZm9uY3Rpb24gZGUgbGEgbG9uZ3VldXIgZOKAmW9uZGUsIHBvdXIgcXVlIGxhIGZvbmN0aW9uIG7igJnDqWNob3VlIHBhc1wiLFxuXHRcIkBARXh0cmFjdC1CYW5kc19NaXNzaW5nLUJhbmQtQWN0aW9uX3RhZzNAQFwiOiBcIjxzdHJvbmc+w4ljaGVjPC9zdHJvbmc+IDogc2ksIGRhbnMgbGUgamV1IGRlIGRvbm7DqWVzIGVuIGVudHLDqWUsIGzigJl1bmUgZGVzIGJhbmRlcyBzcMOpY2lmacOpZXMgZXN0IGFic2VudGUgZGFucyBsZSBwYXJhbcOodHJlIDwvc3Ryb25nPkJhbmRlPHN0cm9uZz4sIGxhIGZvbmN0aW9uIMOpY2hvdWUuXCIsXG5cdFwiQEBFeHRyYWN0LUJhbmRzX1Jhc3Rlcl90YWcwQEBcIjogXCJMZSBwcm9kdWl0IHJhc3RlciBkdXF1ZWwgbGUgb3UgbGVzIGNhbmF1eCBzZXJvbnQgZXh0cmFpdHMuXCIsXG5cdFwiQEBGaWxsX1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZOKAmWFsdGl0dWRlIG1vbm9jYW5hbC5cIixcblx0XCJAQEZpbGxfWi1MaW1pdF90YWcwQEBcIjogXCJMYSBkaWZmw6lyZW5jZSBk4oCZYWx0aXR1ZGUgbWF4aW1hbGUgZW50cmUgdW5lIGN1dmV0dGUgZXQgbGUgcG9pbnQgZOKAmcOpY291bGVtZW50IMOgIHJlbXBsaXIuXCIsXG5cdFwiQEBGaWxsX1otTGltaXRfdGFnMUBAXCI6IFwiU2kgYXVjdW5lIHZhbGV1ciBuJ2VzdCBpbmRpcXXDqWUgcG91ciBjZSBwYXJhbcOodHJlLCB0b3V0ZXMgbGVzIGN1dmV0dGVzIHNlcm9udCByZW1wbGllcywgcXVlbGxlIHF1ZSBzb2l0IGxhIHByb2ZvbmRldXIuXCIsXG5cdFwiQEBGaWxsX1otTGltaXRfdGFnMkBAXCI6IFwiTGEgdmFsZXVyIGRlIDxzdHJvbmc+TGltaXRlIFo8L3N0cm9uZz4gZG9pdCDDqnRyZSBzdXDDqXJpZXVyZSDDoCB6w6lyby5cIixcblx0XCJAQEZsb2F0X0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBARmxvYXRfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEZsb2F0X0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBGbG9hdF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBARmxvYXRfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEZsb2F0X0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBARmxvYXRfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBARmxvYXRfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEZsb2F0X0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEZsb2F0X0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBGbG9hdF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEZsb2F0X1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSDDoCBjb252ZXJ0aXIgZW4gdmlyZ3VsZSBmbG90dGFudGUuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgcXVpIG1vbnRyZSBsYSBkaXJlY3Rpb24gZHUgZmx1eCBzb3J0YW50IGRlIGNoYXF1ZSBjZWxsdWxlLlwiLFxuXHRcIkBARmxvdy1BY2N1bXVsYXRpb25fRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzFAQFwiOiBcIkxlIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCBwZXV0IMOqdHJlIGNyw6nDqSBlbiBleMOpY3V0YW50IGxhIGZvbmN0aW9uIDxzdHJvbmc+RGlyZWN0aW9uIGRlIGZsdXg8L3N0cm9uZz4uXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxlIHR5cGUgZGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBkZSBmbHV4IGVuIGVudHLDqWUuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+RDg8L3N0cm9uZz4gOiBsZSByYXN0ZXIgZGUgZGlyZWN0aW9uIGRlIGZsdXggZW4gZW50csOpZSBlc3QgZGUgdHlwZSBEOC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5ESU5GPC9zdHJvbmc+IDogbGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBkZSBmbHV4IGVuIGVudHLDqWUgZXN0IGRlIHR5cGUgRC1JbmZpbml0eSAoRElORikuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzVAQFwiOiBcIjxzdHJvbmc+TUZEPC9zdHJvbmc+IDogbGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBkZSBmbHV4IGVuIGVudHLDqWUgZXN0IGRlIHR5cGUgTXVsdGkgRmxvdyBEaXJlY3Rpb24gKE1GRCkuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9PdXRwdXQtRGF0YS1UeXBlX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBkJ2FjY3VtdWxhdGlvbiBlbiBzb3J0aWUgcGV1dCDDqnRyZSB1biBlbnRpZXIgb3Ugw6AgdmlyZ3VsZSBmbG90dGFudGUuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9PdXRwdXQtRGF0YS1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+RmxvdHRhbnQ8L3N0cm9uZz4gOiBsZSByYXN0ZXIgZW4gc29ydGllIHNlcmEgZGUgdHlwZSDDoCB2aXJndWxlIGZsb3R0YW50ZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX091dHB1dC1EYXRhLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5FbnRpZXI8L3N0cm9uZz4gOiBsZSByYXN0ZXIgZW4gc29ydGllIHNlcmEgZGUgdHlwZSBlbnRpZXIuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9XZWlnaHQtUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIGZhY3VsdGF0aWYgcG91ciBhcHBsaXF1ZXIgdW5lIHBvbmTDqXJhdGlvbiDDoCBjaGFxdWUgcGl4ZWwuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9XZWlnaHQtUmFzdGVyX3RhZzFAQFwiOiBcIlNpIGF1Y3VuIHJhc3RlciBkZSBwb25kw6lyYXRpb24gbuKAmWVzdCBzcMOpY2lmacOpLCB1bmUgcG9uZMOpcmF0aW9uIHBhciBkw6lmYXV0IGRlIDEgZXN0IGFwcGxpcXXDqWUgw6AgY2hhcXVlIHBpeGVsLlwiLFxuXHRcIkBARmxvdy1EaXJlY3Rpb25fRmxvdy1EaXJlY3Rpb24tVHlwZV90YWcwQEBcIjogXCJEw6lmaW5pdCBsZSB0eXBlIGRlIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCBlbiBlbnRyw6llLlwiLFxuXHRcIkBARmxvdy1EaXJlY3Rpb25fRmxvdy1EaXJlY3Rpb24tVHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPkQ4PC9zdHJvbmc+IDogbGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBkZSBmbHV4IGVuIGVudHLDqWUgZXN0IGRlIHR5cGUgRDguIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBGbG93LURpcmVjdGlvbl9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+RElORjwvc3Ryb25nPiA6IGxlIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCBlbiBlbnRyw6llIGVzdCBkZSB0eXBlIEQtSW5maW5pdHkgKERJTkYpLlwiLFxuXHRcIkBARmxvdy1EaXJlY3Rpb25fRmxvdy1EaXJlY3Rpb24tVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPk1GRDwvc3Ryb25nPiA6IGxlIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCBlbiBlbnRyw6llIGVzdCBkZSB0eXBlIE11bHRpIEZsb3cgRGlyZWN0aW9uIChNRkQpLlwiLFxuXHRcIkBARmxvdy1EaXJlY3Rpb25fRm9yY2UtYWxsLWVkZ2UtY2VsbHMtdG8tZmxvdy1vdXR3YXJkX3RhZzBAQFwiOiBcIkluZGlxdWUgc2kgbGVzIHBpeGVscyBkZSB0cm9uw6dvbiBz4oCZw6ljb3VsZW50IHRvdWpvdXJzIHZlcnMgbOKAmWV4dMOpcmlldXIgb3Ugc3VpdmVudCBsZXMgcsOoZ2xlcyBkZSBmbHV4IG5vcm1hbGVzLlwiLFxuXHRcIkBARmxvdy1EaXJlY3Rpb25fRm9yY2UtYWxsLWVkZ2UtY2VsbHMtdG8tZmxvdy1vdXR3YXJkX3RhZzFAQFwiOiBcIjxzdHJvbmc+Tm9uPC9zdHJvbmc+IDogc2kgbGEgcGVudGUgbWF4aW1hbGUgZOKAmXVuIHBpeGVsIGRlIHNlZ21lbnQgZXN0IHN1cMOpcmlldXJlIMOgIHrDqXJvLCBsYSBkaXJlY3Rpb24gZGUgZmx1eCBlc3QgZMOpdGVybWluw6llIGRlIGxhIG1hbmnDqHJlIGhhYml0dWVsbGUuIERhbnMgbGUgY2FzIGNvbnRyYWlyZSwgZWxsZSBzZXJhIG9yaWVudMOpZSB2ZXJzIGxlIHNlZ21lbnQuIExlcyBwaXhlbHMgcXVpIGRldnJhaWVudCBz4oCZw6ljb3VsZXIgZHUgc2VnbWVudCBkZSBsYSBzdXJmYWNlIHJhc3RlciB2ZXJzIGzigJlpbnTDqXJpZXVyIHPigJnDqWNvdWxlcm9udCBhaW5zaS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEZsb3ctRGlyZWN0aW9uX0ZvcmNlLWFsbC1lZGdlLWNlbGxzLXRvLWZsb3ctb3V0d2FyZF90YWczQEBcIjogXCI8c3Ryb25nPk91aTwvc3Ryb25nPiA6IHRvdXMgbGVzIHBpeGVscyBzdXIgbGUgc2VnbWVudCBkdSByYXN0ZXIgZGUgc3VyZmFjZSBz4oCZw6ljb3VsZXJvbnQgdmVycyBs4oCZZXh0w6lyaWV1ciDDoCBwYXJ0aXIgZHUgcmFzdGVyIGRlIHN1cmZhY2UuXCIsXG5cdFwiQEBGbG93LURpcmVjdGlvbl9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgcXVpIHJlcHLDqXNlbnRlIHVuZSBzdXJmYWNlIGTigJlhbHRpdHVkZSBjb250aW51ZS5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRGlzdGFuY2UtVHlwZV90YWcwQEBcIjogXCJEw6l0ZXJtaW5lIHNpIGxlIGNvbXBvc2FudCB2ZXJ0aWNhbCBvdSBob3Jpem9udGFsIGRlIGxhIGRpc3RhbmNlIGQnw6ljb3VsZW1lbnQgZXN0IGNhbGN1bMOpLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9EaXN0YW5jZS1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+SG9yaXpvbnRhbGU8L3N0cm9uZz4gOiBsZXMgY2FsY3VscyBkZSBkaXN0YW5jZSBk4oCZw6ljb3VsZW1lbnQgcmVwcsOpc2VudGVudCBsZSBjb21wb3NhbnQgaG9yaXpvbnRhbCBkZSBsYSBkaXN0YW5jZSBk4oCZw6ljb3VsZW1lbnQgw6AgcGFydGlyIGRlIGNoYXF1ZSBwaXhlbCBkYW5zIGxlIGRvbWFpbmUgdmVycyBsZXMgcGl4ZWxzIGRlIGzigJnDqWNvdWxlbWVudCBkYW5zIGxlcXVlbCBpbHMgdHJhbnNpdGVudC5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRGlzdGFuY2UtVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPlZlcnRpY2FsZTwvc3Ryb25nPiA6IGxlcyBjYWxjdWxzIGRlIGRpc3RhbmNlIGTigJnDqWNvdWxlbWVudCByZXByw6lzZW50ZW50IGxlIGNvbXBvc2FudCB2ZXJ0aWNhbCBkZSBsYSBkaXN0YW5jZSBk4oCZw6ljb3VsZW1lbnQgw6AgcGFydGlyIGRlIGNoYXF1ZSBwaXhlbCBkYW5zIGxlIGRvbWFpbmUgdmVycyBsZXMgcGl4ZWxzIGRlIGzigJnDqWNvdWxlbWVudCBkYW5zIGxlcXVlbCBpbHMgdHJhbnNpdGVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIHF1aSBtb250cmUgbGEgZGlyZWN0aW9uIGR1IGZsdXggc29ydGFudCBkZSBjaGFxdWUgcGl4ZWwuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcxQEBcIjogXCJMb3JzcXXigJl1biByYXN0ZXIgZGUgZGlyZWN0aW9uIGRlIGZsdXggZXN0IGZvdXJuaSwgbGVzIGRpcmVjdGlvbnMgZGUgcGVudGUgZGVzY2VuZGFudGUgc2Vyb250IGxpbWl0w6llcyDDoCBjZWxsZXMgZMOpZmluaWVzIHBhciBsZXMgZGlyZWN0aW9ucyBkZSBmbHV4IGVuIGVudHLDqWUuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcyQEBcIjogXCJMZSByYXN0ZXIgZGUgZGlyZWN0aW9uIGRlIGZsdXggcGV1dCDDqnRyZSBjcsOpw6kgw6AgbOKAmWFpZGUgZGUgbGEgZm9uY3Rpb24gRmxvdyBEaXJlY3Rpb24gKERpcmVjdGlvbiBkZSBmbHV4KS5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRmxvdy1EaXJlY3Rpb24tVHlwZV90YWcwQEBcIjogXCJEw6lmaW5pdCBsZSB0eXBlIGRlIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCBlbiBlbnRyw6llLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+RDg8L3N0cm9uZz4gOiBsZSByYXN0ZXIgZGUgZGlyZWN0aW9uIGRlIGZsdXggZW4gZW50csOpZSBlc3QgZGUgdHlwZSBEOC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRmxvdy1EaXJlY3Rpb24tVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPkRJTkY8L3N0cm9uZz4gOiBsZSByYXN0ZXIgZGUgZGlyZWN0aW9uIGRlIGZsdXggZW4gZW50csOpZSBlc3QgZGUgdHlwZSBELUluZmluaXR5IChESU5GKS5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRmxvdy1EaXJlY3Rpb24tVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPk1GRDwvc3Ryb25nPiA6IGxlIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCBlbiBlbnRyw6llIGVzdCBkZSB0eXBlIE11bHRpIEZsb3cgRGlyZWN0aW9uIChNRkQpLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9TdGF0aXN0aWNzLVR5cGVfdGFnMEBAXCI6IFwiRMOpdGVybWluZSBsZSB0eXBlIGRlIHN0YXRpc3RpcXVlIHV0aWxpc8OpIHBvdXIgY2FsY3VsZXIgbGEgZGlzdGFuY2UgZOKAmcOpY291bGVtZW50IHN1ciBwbHVzaWV1cnMgY2hlbWlucyBkZSBmbHV4LiBMb3JzcXXigJlpbCBu4oCZZXhpc3RlIHF14oCZdW4gc2V1bCBjaGVtaW4gZGUgZmx1eCBkZXB1aXMgY2hhcXVlIGNlbGx1bGUgdmVycyB1bmUgY2VsbHVsZSBkdSBmbHV4LCB0b3VzIGxlcyB0eXBlcyBkZSBzdGF0aXN0aXF1ZXMgcHJvZHVpc2VudCBsZSBtw6ptZSByw6lzdWx0YXQuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX1N0YXRpc3RpY3MtVHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPk1pbmltdW08L3N0cm9uZz4gOiBz4oCZaWwgZXhpc3RlIHBsdXNpZXVycyBjaGVtaW5zIGRlIGZsdXgsIGxhIGRpc3RhbmNlIGTigJnDqWNvdWxlbWVudCBtaW5pbWFsZSBlc3QgY2FsY3Vsw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9TdGF0aXN0aWNzLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5Nb3llbm5lIHBvbmTDqXLDqWU8L3N0cm9uZz4gOiBz4oCZaWwgZXhpc3RlIHBsdXNpZXVycyBjaGVtaW5zIGRlIGZsdXgsIHVuZSBtb3llbm5lIHBvbmTDqXLDqWUgZGUgbGEgZGlzdGFuY2UgZOKAmcOpY291bGVtZW50IGVzdCBjYWxjdWzDqWUuIExhIHByb3BvcnRpb24gZGUgZmx1eCDDoCBwYXJ0aXIgZOKAmXVuZSBjZWxsdWxlIHZlcnMgc2VzIGNlbGx1bGVzIHZvaXNpbmVzIGVuIGF2YWwgZXN0IHV0aWxpc8OpZSBjb21tZSBwb25kw6lyYXRpb24gcG91ciBjYWxjdWxlciBsYSBtb3llbm5lIHBvbmTDqXLDqWUuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX1N0YXRpc3RpY3MtVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPk1heGltdW08L3N0cm9uZz4gOiBz4oCZaWwgZXhpc3RlIHBsdXNpZXVycyBjaGVtaW5zIGRlIGZsdXgsIGxhIGRpc3RhbmNlIGTigJnDqWNvdWxlbWVudCBtYXhpbWFsZSBlc3QgY2FsY3Vsw6llLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9TdHJlYW0tUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBk4oCZw6ljb3VsZW1lbnQgZW4gZW50csOpZSByZXByw6lzZW50YW50IHVuIHLDqXNlYXUgZOKAmcOpY291bGVtZW50IGxpbsOpYWlyZS5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfU3VyZmFjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgcXVpIHJlcHLDqXNlbnRlIHVuZSBzdXJmYWNlIGTigJlhbHRpdHVkZSBjb250aW51ZS5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX0RpcmVjdGlvbi1vZi1NZWFzdXJlbWVudF90YWcwQEBcIjogXCJEaXJlY3Rpb24gbWVzdXLDqWUgbGUgbG9uZyBkdSBjaGVtaW4gZGUgZmx1eC5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX0RpcmVjdGlvbi1vZi1NZWFzdXJlbWVudF90YWcxQEBcIjogXCI8c3Ryb25nPkVuIGF2YWw8L3N0cm9uZz4gOiBjYWxjdWxlIGxhIGRpc3RhbmNlIGRlIHBlbnRlIGxlIGxvbmcgZHUgY2hlbWluIGRlIGZsdXggZGVwdWlzIGNoYXF1ZSBjZWxsdWxlIGp1c3F14oCZw6AgdW5lIGN1dmV0dGUgb3UgdW4gb3JpZmljZSBzdXIgbGUgc2VnbWVudCBkdSByYXN0ZXIuXCIsXG5cdFwiQEBGbG93LUxlbmd0aF9EaXJlY3Rpb24tb2YtTWVhc3VyZW1lbnRfdGFnM0BAXCI6IFwiPHN0cm9uZz5FbiBhbW9udDwvc3Ryb25nPiA6IGNhbGN1bGUgbGEgZGlzdGFuY2UgZGUgbW9udMOpZSBsYSBwbHVzIGdyYW5kZSBsZSBsb25nIGR1IGNoZW1pbiBkZSBmbHV4LCBkZXB1aXMgY2hhcXVlIGNlbGx1bGUganVzcXXigJlhdSBzb21tZXQgZGUgbGEgbGlnbmUgZGUgcGFydGFnZSBkZXMgZWF1eC5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSBxdWkgbW9udHJlIGxhIGRpcmVjdGlvbiBkdSBmbHV4IHNvcnRhbnQgZGUgY2hhcXVlIGNlbGx1bGUuXCIsXG5cdFwiQEBGbG93LUxlbmd0aF9GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMUBAXCI6IFwiTGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBkZSBmbHV4IHBldXQgw6p0cmUgY3LDqcOpIGVuIGV4w6ljdXRhbnQgbGEgZm9uY3Rpb24gPHN0cm9uZz5EaXJlY3Rpb24gZGUgZmx1eDwvc3Ryb25nPi5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX1dlaWdodC1SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgZmFjdWx0YXRpZiBwb3VyIGFwcGxpcXVlciB1bmUgcG9uZMOpcmF0aW9uIMOgIGNoYXF1ZSBjZWxsdWxlLlwiLFxuXHRcIkBARmxvdy1MZW5ndGhfV2VpZ2h0LVJhc3Rlcl90YWcxQEBcIjogXCJTaSBhdWN1biByYXN0ZXIgZGUgcG9uZMOpcmF0aW9uIG4nZXN0IHNww6ljaWZpw6ksIHVuZSBwb25kw6lyYXRpb24gcGFyIGTDqWZhdXQgZGUgMSBlc3QgYXBwbGlxdcOpZSDDoCBjaGFxdWUgY2VsbHVsZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfSWdub3JlLU5vRGF0YS1pbi1jYWxjdWxhdGlvbnNfdGFnMEBAXCI6IFwiSW5kaXF1ZSBzaSBsZXMgdmFsZXVycyAke05vRGF0YX0gc29udCBpZ25vcsOpZXMgcGFyIGxlIGNhbGN1bCBkZSBzdGF0aXN0aXF1ZXMuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX0lnbm9yZS1Ob0RhdGEtaW4tY2FsY3VsYXRpb25zX3RhZzFAQFwiOiBcIjxzdHJvbmc+QWN0aXbDqTwvc3Ryb25nPiA6IHByw6ljaXNlIHF1ZSBzaSB1bmUgdmFsZXVyICR7Tm9EYXRhfSBleGlzdGUgZGFucyB1biB2b2lzaW5hZ2UsIGVsbGUgZXN0IGlnbm9yw6llLiBTZXVsZXMgbGVzIGNlbGx1bGVzIGR1IHZvaXNpbmFnZSBkb3TDqWVzIGRlIHZhbGV1cnMgZGUgZG9ubsOpZXMgc29udCB1dGlsaXPDqWVzIGRhbnMgbGEgZMOpdGVybWluYXRpb24gZGUgbGEgdmFsZXVyIGVuIHNvcnRpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfSWdub3JlLU5vRGF0YS1pbi1jYWxjdWxhdGlvbnNfdGFnM0BAXCI6IFwiPHN0cm9uZz5Ew6lzYWN0aXbDqTwvc3Ryb25nPiA6IHByw6ljaXNlIHF1ZSBzaSB1bmUgY2VsbHVsZSBk4oCZdW4gdm9pc2luYWdlIGEgdW5lIHZhbGV1ciAke05vRGF0YX0sIGxhIHNvcnRpZSBkZSBsYSBjZWxsdWxlIGRlIHRyYWl0ZW1lbnQgZXN0ICR7Tm9EYXRhfS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfTmVpZ2hib3Job29kX3RhZzBAQFwiOiBcIkxhIGZvcm1lIGRlIGxhIHpvbmUgYXV0b3VyIGRlIGNoYXF1ZSBjZWxsdWxlIHV0aWxpc8OpZSBwb3VyIGxlIGNhbGN1bCBkZXMgc3RhdGlzdGlxdWVzLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19OZWlnaGJvcmhvb2RfdGFnMUBAXCI6IFwiQ2hhcXVlIHZvaXNpbmFnZSBwb3Nzw6hkZSBkZXMgcGFyYW3DqHRyZXMgc3VwcGzDqW1lbnRhaXJlcyBhdmVjIGxlc3F1ZWxzIGTDqWZpbmlyIGxhIGZvcm1lLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19OZWlnaGJvcmhvb2RfdGFnMkBAXCI6IFwiQW5uZWF1LCBSYXlvbiBpbnTDqXJpZXVyLCBSYXlvbiBleHTDqXJpZXVyXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWczQEBcIjogXCJDZXJjbGUsIFJheW9uXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWc0QEBcIjogXCJJcnLDqWd1bGllciwgTGFyZ2V1ciwgSGF1dGV1ciwgVmFsZXVycyB2b2lzaW5lc1wiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19OZWlnaGJvcmhvb2RfdGFnNUBAXCI6IFwiUmVjdGFuZ2xlLCBMYXJnZXVyLCBIYXV0ZXVyXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWc2QEBcIjogXCJTZWN0ZXVyLCBSYXlvbiwgQW5nbGUgZGUgZMOpYnV0LCBBbmdsZSBkZSBmaW5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfTmVpZ2hib3Job29kX3RhZzdAQFwiOiBcIlBvbmTDqXJhdGlvbiwgTGFyZ2V1ciwgSGF1dGV1ciwgVmFsZXVycyB2b2lzaW5lc1wiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19OZWlnaGJvcmhvb2RfdGFnOEBAXCI6IFwiTGUgdm9pc2luYWdlIGlycsOpZ3VsaWVyIHBlcm1ldCBkZSBzcMOpY2lmaWVyIHVuIHZvaXNpbmFnZSBkZSBmb3JtZSBpcnLDqWd1bGnDqHJlIGF1dG91ciBkZSBsYSBjZWxsdWxlIGRlIHRyYWl0ZW1lbnQuIFV0aWxpc2V6IGxhIHRhYmxlIGRlcyB2YWxldXJzIHZvaXNpbmVzIHBvdXIgZMOpZmluaXIgbGEgZm9ybWUgZHUgbm95YXUgZGUgdm9pc2luYWdlLiBVbmUgdmFsZXVyIG51bGxlIHBvdXIgdW5lIHBvc2l0aW9uIGRlIGNlbGx1bGUgaW5kaXF1ZSBxdWUgbGEgY2VsbHVsZSBuZSBmYWl0IHBhcyBwYXJ0aWUgZHUgdm9pc2luYWdlIGV0IG5lIHNlcmEgcGFzIHByaXNlIGVuIGNvbXB0ZSBkYW5zIGxlIHRyYWl0ZW1lbnQuIExhIHZhbGV1ciAxIGluZGlxdWUgcXVlIGxhIGNlbGx1bGUgY29ycmVzcG9uZGFudGUgZXN0IHVuIG1lbWJyZSBkdSB2b2lzaW5hZ2UgKGRlIG3Dqm1lIHF1ZSBzYSB2YWxldXIpLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19OZWlnaGJvcmhvb2RfdGFnOUBAXCI6IFwiTGUgdm9pc2luYWdlIGRlIHBvbmTDqXJhdGlvbiBlc3Qgc2ltaWxhaXJlIGF1IHR5cGUgZGUgdm9pc2luYWdlIGlycsOpZ3VsaWVyLCBkYW5zIGxlIHNlbnMgb8O5IGlsIHZvdXMgcGVybWV0IGRlIGTDqWZpbmlyIHVuIHZvaXNpbmFnZSBpcnLDqWd1bGllciBhdXRvdXIgZGUgbGEgY2VsbHVsZSBkZSB0cmFpdGVtZW50LCBtYWlzIMOpZ2FsZW1lbnQgZOKAmWFwcGxpcXVlciBkZXMgcG9uZMOpcmF0aW9ucyBhdXggdmFsZXVycyBlbiBlbnRyw6llLiBMZXMgdmFsZXVycyBkdSBub3lhdSBkZSBwb25kw6lyYXRpb24gc3DDqWNpZmllIGxlcyBwb3NpdGlvbnMgZGUgY2VsbHVsZSBxdWkgZG9pdmVudCDDqnRyZSBjb21wcmlzZXMgZGFucyBsZSB2b2lzaW5hZ2UgZXQgbGVzIHBvbmTDqXJhdGlvbnMgcGFyIGxlc3F1ZWxsZXMgZWxsZXMgc2Vyb250IG11bHRpcGxpw6llcy4gVXRpbGlzZXogbGEgdmFsZXVyIDAgcG91ciBleGNsdXJlIHVuZSBjZWxsdWxlIGR1IHRyYWl0ZW1lbnQuIExlcyB2YWxldXJzIHBvc2l0aXZlcywgbsOpZ2F0aXZlcyBldCBkw6ljaW1hbGVzIHBldXZlbnQgw6p0cmUgdXRpbGlzw6llcyBlbiB0YW50IHF1ZSB2YWxldXJzIGRlIHBvbmTDqXJhdGlvbi4gUG91ciBsZSB0eXBlIGRlIHZvaXNpbmFnZSBkZSBwb25kw6lyYXRpb24sIHNldWxlcyBsZXMgc3RhdGlzdGlxdWVzIE1veWVubmUsIMOJY2FydCB0eXBlIG91IFNvbW1lIHNvbnQgcHJpc2VzIGVuIGNoYXJnZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfUGVyY2VudGlsZS1WYWx1ZV90YWcwQEBcIjogXCJJbmRpcXVlIGxlIGNlbnRpbGUgw6AgY2FsY3VsZXIgbG9yc3F1ZSBsZSB0eXBlIGRlIHN0YXRpc3RpcXVlIDxzdHJvbmc+Q2VudGlsZTwvc3Ryb25nPiBlc3Qgc8OpbGVjdGlvbm7DqS4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCBkZSA5MCwgc29pdCBsZSA5MGUgY2VudGlsZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfUGVyY2VudGlsZS1WYWx1ZV90YWczQEBcIjogXCJMZXMgdmFsZXVycyBwZXV2ZW50IHZhcmllciBlbnRyZSAwIGV0IDEwMC4gTGUgcG91cmNlbnRhZ2UgbnVsIGVzdCBnw6luw6lyYWxlbWVudCDDqXF1aXZhbGVudCDDoCBsYSBzdGF0aXN0aXF1ZSBNaW5pbXVtIGV0IGxlIHBvdXJjZW50YWdlIDEwMCBlc3Qgw6lxdWl2YWxlbnQgw6AgbGEgc3RhdGlzdGlxdWUgTWF4aW11bSwgw6AgbOKAmWV4Y2VwdGlvbiBwcsOocyBxdWUgbGUgcsOpc3VsdGF0IGVzdCBkZSB0eXBlIHZpcmd1bGUgZmxvdHRhbnRlLiBVbmUgdmFsZXVyIGRlIDUwIGRvbm5lIGfDqW7DqXJhbGVtZW50IGxlIG3Dqm1lIHLDqXN1bHRhdCBxdWUgbGEgc3RhdGlzdGlxdWUgTWVkaWFuIChNw6lkaWFuZSkuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1Jhc3Rlcl90YWcwQEBcIjogXCJMZSByYXN0ZXIgZW4gZW50csOpZSByZXF1aXMuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcwQEBcIjogXCJUeXBlIGRlIHN0YXRpc3RpcXVlIMOgIGNhbGN1bGVyLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5NYWpvcml0w6k8L3N0cm9uZz4gOiBjYWxjdWxlIGxhIG1ham9yaXTDqSAodmFsZXVyIGxhIHBsdXMgZnLDqXF1ZW50ZSkgZGVzIGNlbGx1bGVzIGR1IHZvaXNpbmFnZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+TWF4aW11bTwvc3Ryb25nPiA6IGNhbGN1bGUgbGUgbWF4aW11bSAodmFsZXVyIGxhIHBsdXMgw6lsZXbDqWUpIGRlcyBjZWxsdWxlcyBkdSB2b2lzaW5hZ2UuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPk1veWVubmU8L3N0cm9uZz4gOiBjYWxjdWxlIGxhIG1veWVubmUgZGVzIGNlbGx1bGVzIGR1IHZvaXNpbmFnZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzdAQFwiOiBcIjxzdHJvbmc+TcOpZGlhbmU8L3N0cm9uZz4gOiBjYWxjdWxlIGxhIG3DqWRpYW5lIGRlcyBjZWxsdWxlcyBkdSB2b2lzaW5hZ2UuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWc5QEBcIjogXCI8c3Ryb25nPk1pbmltdW08L3N0cm9uZz4gOiBjYWxjdWxlIGxlIG1pbmltdW0gKHZhbGV1ciBsYSBwbHVzIGZhaWJsZSkgZGVzIGNlbGx1bGVzIGR1IHZvaXNpbmFnZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzExQEBcIjogXCI8c3Ryb25nPk1pbm9yaXTDqTwvc3Ryb25nPiA6IGNhbGN1bGUgbGEgbWlub3JpdMOpICh2YWxldXIgbGEgbW9pbnMgZnLDqXF1ZW50ZSkgZGVzIGNlbGx1bGVzIGR1IHZvaXNpbmFnZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzEzQEBcIjogXCI8c3Ryb25nPkNlbnRpbGU8L3N0cm9uZz4gOiBjYWxjdWxlIHVuIGNlbnRpbGUgZGVzIGNlbGx1bGVzIGR1IHZvaXNpbmFnZS4gVm91cyBwb3V2ZXogZMOpdGVybWluZXIgbGUgY2VudGlsZSDDoCBjYWxjdWxlciDDoCBs4oCZYWlkZSBkdSBwYXJhbcOodHJlIDxzdHJvbmc+VmFsZXVyIGRlIGNlbnRpbGU8L3N0cm9uZz4uXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcxN0BAXCI6IFwiPHN0cm9uZz5QbGFnZTwvc3Ryb25nPiA6IGNhbGN1bGUgbGEgcGxhZ2UgKGRpZmbDqXJlbmNlIGVudHJlIGxhIHZhbGV1ciBsYSBwbHVzIMOpbGV2w6llIGV0IGxhIHZhbGV1ciBsYSBwbHVzIGZhaWJsZSkgZGVzIGNlbGx1bGVzIGR1IHZvaXNpbmFnZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzE5QEBcIjogXCI8c3Ryb25nPsOJY2FydCB0eXBlPC9zdHJvbmc+IDogY2FsY3VsZSBs4oCZw6ljYXJ0IHR5cGUgZGVzIGNlbGx1bGVzIGR1IHZvaXNpbmFnZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzIxQEBcIjogXCI8c3Ryb25nPlNvbW1lPC9zdHJvbmc+IDogY2FsY3VsZSBsYSBzb21tZSAodG90YWwgZGUgdG91dGVzIGxlcyB2YWxldXJzKSBkZXMgY2VsbHVsZXMgZHUgdm9pc2luYWdlLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnMjNAQFwiOiBcIjxzdHJvbmc+VmFyacOpdMOpPC9zdHJvbmc+IDogY2FsY3VsZSBsYSB2YXJpw6l0w6kgKGxlIG5vbWJyZSBkZSB2YWxldXJzIHVuaXF1ZXMpIGRlcyBjZWxsdWxlcyBkdSB2b2lzaW5hZ2UuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcyNUBAXCI6IFwiU2kgbGUgcmFzdGVyIGVuIGVudHLDqWUgZXN0IGRlIHR5cGUgdmlyZ3VsZSBmbG90dGFudGUsIHNldWxzIGxlcyB0eXBlcyBkZSBzdGF0aXN0aXF1ZXMgTWVhbiAoTW95ZW5uZSksIE1heGltdW0sIE1lZGlhbiAoTcOpZGlhbmUpLCBNaW5pbXVtLCBQZXJjZW50aWxlIChQb3VyY2VudGFnZSksIFJhbmdlIChQbGFnZSksIFN0YW5kYXJkIGRldmlhdGlvbiAow4ljYXJ0IHR5cGUpIGV0IFN1bSAoU29tbWUpIHNvbnQgZGlzcG9uaWJsZXMuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcyNkBAXCI6IFwiUG91ciBNZWFuIChNb3llbm5lKSwgTWVkaWFuIChNw6lkaWFuZSksIFBlcmNlbnRpbGUgKFBvdXJjZW50YWdlKSBldCBTdGFuZGFyZCBEZXZpYXRpb24gKMOJY2FydCB0eXBlKSwgbGEgc29ydGllIGVzdCB0b3Vqb3VycyBkZSB0eXBlIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnMjdAQFwiOiBcIkxlIHR5cGUgZGUgc3RhdGlzdGlxdWVzIHBhciBkw6lmYXV0IGVzdCBNb3llbm5lLlwiLFxuXHRcIkBAR2VvbWV0cmljX0NvbnN0YW50LVpfdGFnMEBAXCI6IFwiU3DDqWNpZmlleiB1bmUgYWx0aXR1ZGUgY29uc3RhbnRlIMOgIHV0aWxpc2VyIHBvdXIgbGEgZm9uY3Rpb24gR8Opb23DqXRyaXF1ZS5cIixcblx0XCJAQEdlb21ldHJpY19ERU1fdGFnMEBAXCI6IFwiU3DDqWNpZmlleiB1biBNTlQgw6AgdXRpbGlzZXIgcG91ciBsYSBmb25jdGlvbiBHw6lvbcOpdHJpcXVlLiBWb3VzIHBvdXZleiB1dGlsaXNlciB1biBNTkUgY29udGVudSBkYW5zIGxlIGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUgc291cyBmb3JtZSBkZSBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIG91IGRlIGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUgZG9udCBsYSBzb3J0aWUgZXN0IHVuIE1ORS5cIixcblx0XCJAQEdlb21ldHJpY19HZW9pZF90YWcwQEBcIjogXCJMYSBwbHVwYXJ0IGRlcyBqZXV4IGRlIGRvbm7DqWVzIGTigJnDqWzDqXZhdGlvbiwgY29tbWUgVVNHUyBORUQgb3UgQXJjR0lTIE9ubGluZSBXb3JsZCBFbGV2YXRpb24sIHNvbnQgZGVzIGhhdXRldXJzIG9ydGhvbcOpdHJpcXVlcy4gUGFyIGNvbnPDqXF1ZW50LCBpbCBjb252aWVudCBkZSBzw6lsZWN0aW9ubmVyIGxhIGNvcnJlY3Rpb24gR8Opb8OvZGUgcG91ciBhc3N1cmVyIGxhIGNvbXBhdGliaWxpdMOpIGF2ZWMgbGVzIGNvZWZmaWNpZW50cyBwb2x5bm9taWF1eCByYXRpb25uZWxzIChSUEMpIGRlcyBzYXRlbGxpdGVzLCBxdWkgbsOpY2Vzc2l0ZW50IGRlcyBoYXV0ZXVycyBlbGxpcHNvw69kYWxlcy4gQ29jaGV6IGxhIGNhc2UgPHN0cm9uZz5Hw6lvw69kZTwvc3Ryb25nPiBwb3VyIGFwcGxpcXVlciBsYSBjb3JyZWN0aW9uIGfDqW/Dr2RlIChFR005NikgYXV4IHZhbGV1cnMgeiwgc2F1ZiBzaSB2b3RyZSBNTkUgZXN0IGTDqWrDoCByw6lmw6lyZW5jw6kgcGFyIHJhcHBvcnQgw6AgZGVzIGhhdXRldXJzIGVsbGlwc2/Dr2RhbGVzLlwiLFxuXHRcIkBAR2VvbWV0cmljX01ldGhvZF90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIG3DqXRob2RlIGQnYWx0aXR1ZGUgcG91ciBsYSBmb25jdGlvbiBnw6lvbcOpdHJpcXVlIDpcIixcblx0XCJAQEdlb21ldHJpY19NZXRob2RfdGFnMUBAXCI6IFwiVXRpbGlzZXIgbGEgY29uc3RhbnRlIFogOiBzcMOpY2lmaWVyIHVuZSBhbHRpdHVkZSBjb25zdGFudGUgcG91ciBleMOpY3V0ZXIgbGEgZm9uY3Rpb24gZ8Opb23DqXRyaXF1ZS5cIixcblx0XCJAQEdlb21ldHJpY19NZXRob2RfdGFnMkBAXCI6IFwiVXRpbGlzZXIgTU5FIDogc3DDqWNpZmllciB1biBNTkUgcG91ciBleMOpY3V0ZXIgbGEgZm9uY3Rpb24gZ8Opb23DqXRyaXF1ZS5cIixcblx0XCJAQEdlb21ldHJpY19SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBHZW9tZXRyaWNfWi1GYWN0b3JfdGFnMEBAXCI6IFwiTGVzIGNvZWZmaWNpZW50cyBwb2x5bm9taWF1eCByYXRpb25uZWxzIChSUEMpIGRlIHNhdGVsbGl0ZSBzb250IG1pcyDDoCBs4oCZw6ljaGVsbGUgcG91ciBsZXMgamV1eCBkZSBkb25uw6llcyBk4oCZw6lsw6l2YXRpb24gYXZlYyBkZXMgdW5pdMOpcyB2ZXJ0aWNhbGVzIGVuIG3DqHRyZXMuIFNpIHZvdHJlIMOpbMOpdmF0aW9uIHV0aWxpc2UgZOKAmWF1dHJlcyB1bml0w6lzIHZlcnRpY2FsZXMsIHNhaXNpc3NleiB1biA8c3Ryb25nPkZhY3RldXIgWjwvc3Ryb25nPiBwb3VyIHJlZGltZW5zaW9ubmVyIGVuIG3DqHRyZXMuIFBhciBleGVtcGxlLCBzaSBsZXMgdW5pdMOpcyBk4oCZw6lsw6l2YXRpb24gc29udCBlbiBwaWVkcywgdm91cyBkZXZleiB1dGlsaXNlciB1bmUgdmFsZXVyIGRlIDAsMzA0OCBwb3VyIGNvbnZlcnRpciBsZXMgdW5pdMOpcyBk4oCZw6lsw6l2YXRpb24gZGUgcGllZHMgZW4gbcOodHJlcy5cIixcblx0XCJAQEdlb21ldHJpY19aLU9mZnNldF90YWcwQEBcIjogXCJWYWxldXIgZGUgYmFzZSDDoCBham91dGVyIMOgIGxhIHZhbGV1ciBkJ2FsdGl0dWRlIGRhbnMgbGUgbW9kw6hsZSBudW3DqXJpcXVlIGRlIHRlcnJhaW4uIENlbGEgcGVybWV0IGRlIGNvbXBlbnNlciBkZXMgdmFsZXVycyBkJ2FsdGl0dWRlIHF1aSBuZSBkw6ltYXJyZW50IHBhcyBhdSBuaXZlYXUgZGUgbGEgbWVyLlwiLFxuXHRcIkBAR2VvbWV0cmljX1RvbGVyYW5jZV90YWcwQEBcIjogXCJJbmRpcXVleiBs4oCZZXJyZXVyIHRvbMOpcmFibGUgbWF4aW1hbGUgZGFucyBsYSBmb25jdGlvbiBnw6lvbcOpdHJpcXVlLCBlbiBub21icmUgZGUgcGl4ZWxzLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgcG91ciBsZSByYXN0ZXIgZGUgdHlwZSBOSVRGIChOQ0RSRCkgZXN0IGRldXguXCIsXG5cdFwiQEBHcmF5c2NhbGVfUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAR3JheXNjYWxlX0NvbnZlcnNpb24tUGFyYW1ldGVyc190YWcwQEBcIjogXCJQb25kw6lyYXRpb25zIGRlIGNoYXF1ZSBjYW5hbCBjb21wcmVuYW50IGxlIHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgdGVzdMOpZSBwb3VyIGTDqXRlcm1pbmVyIHNpIGVsbGUgZXN0IHN1cMOpcmlldXJlIMOgIGxhIHNlY29uZGUgZW50csOpZS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbl9SYXN0ZXJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbl9SYXN0ZXIyX3RhZzBAQFwiOiBcIkVudHLDqWUgcGFyIHJhcHBvcnQgw6AgbGFxdWVsbGUgbGEgcHJlbWnDqHJlIGVudHLDqWUgZXN0IHRlc3TDqWUgcG91ciBkw6l0ZXJtaW5lciBzaSBlbGxlIGVzdCBzdXDDqXJpZXVyZS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbl9SYXN0ZXIyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSB0ZXN0w6llIHBvdXIgZMOpdGVybWluZXIgc2kgZWxsZSBlc3Qgc3Vww6lyaWV1cmUgb3Ugw6lnYWxlIMOgIGxhIHNlY29uZGUgZW50csOpZS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9SYXN0ZXJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9SYXN0ZXIyX3RhZzBAQFwiOiBcIkVudHLDqWUgcGFyIHJhcHBvcnQgw6AgbGFxdWVsbGUgbGEgcHJlbWnDqHJlIGVudHLDqWUgZXN0IHRlc3TDqWUgcG91ciBkw6l0ZXJtaW5lciBzaSBlbGxlIGVzdCBzdXDDqXJpZXVyZSBvdSDDqWdhbGUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfUmFzdGVyMl90YWcxQEBcIjogXCJVbmUgdmFsZXVyIGNvbnN0YW50ZSBwZXV0IMOqdHJlIHV0aWxpc8OpZSBlbiBlbnRyw6llIHBvdXIgY2UgcGFyYW3DqHRyZSwgw6AgY29uZGl0aW9uIHF14oCZdW4gcmFzdGVyIHNvaXQgc3DDqWNpZmnDqSBwb3VyIGzigJlhdXRyZSBwYXJhbcOodHJlLlwiLFxuXHRcIkBASGVhdC1JbmRleF9IZWF0LUluZGV4LVVuaXRzX3RhZzBAQFwiOiBcIlVuaXTDqSBkZSBtZXN1cmUgYXNzb2Npw6llIGF1IHJhc3RlciBlbiBzb3J0aWUuIExlcyB1bml0w6lzIGRpc3BvbmlibGVzIGVuIHNvcnRpZSBzb250IENlbHNpdXMsIEZhaHJlbmhlaXQgZXQgS2VsdmluLlwiLFxuXHRcIkBASGVhdC1JbmRleF9SZWxhdGl2ZS1IdW1pZGl0eS1SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIG1vbm9jYW5hbCBvw7kgbGVzIHZhbGV1cnMgZGUgcGl4ZWwgcmVwcsOpc2VudGVudCBs4oCZaHVtaWRpdMOpIHJlbGF0aXZlIHNvdXMgZm9ybWUgZGUgdmFsZXVyIGRlIHBvdXJjZW50YWdlIGNvbXByaXNlIGVudHJlIDAgZXQgMTAwLlwiLFxuXHRcIkBASGVhdC1JbmRleF9UZW1wZXJhdHVyZS1SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIG1vbm9jYW5hbCBvw7kgbGVzIHZhbGV1cnMgZGUgcGl4ZWwgcmVwcsOpc2VudGVudCBsYSB0ZW1ww6lyYXR1cmUgZGUgbOKAmWFpciBhbWJpYW50LlwiLFxuXHRcIkBASGVhdC1JbmRleF9UZW1wZXJhdHVyZS1Vbml0c190YWcwQEBcIjogXCJVbml0w6kgZGUgbWVzdXJlIGFzc29jacOpZSBhdSByYXN0ZXIgZGUgdGVtcMOpcmF0dXJlIGVuIGVudHLDqWUuIExlcyB1bml0w6lzIGRpc3BvbmlibGVzIGVuIGVudHLDqWUgc29udCBDZWxzaXVzLCBGYWhyZW5oZWl0IGV0IEtlbHZpbi5cIixcblx0XCJAQEhpbGxzaGFkZV9BbHRpdHVkZV90YWcwQEBcIjogXCJMJ2FsdGl0dWRlIHJlcHLDqXNlbnRlIGwnYW5nbGUgc29sYWlyZSBkZSBsJ2FsdGl0dWRlIGF1LWRlc3N1cyBkZSBsYSBsaWduZSBkJ2hvcml6b24gZXQgcyfDqXRlbmQgZGUgMCDDoCA5MCBkZWdyw6lzLiBVbmUgdmFsZXVyIGRlIDAgZGVncsOpcyBpbmRpcXVlIHF1ZSBsZSBzb2xlaWwgZXN0IHN1ciBsJ2hvcml6b24sIGMnZXN0LcOgLWRpcmUgc3VyIGxlIG3Dqm1lIHBsYW4gaG9yaXpvbnRhbCBxdWUgbGUgY2FkcmUgZGUgcsOpZsOpcmVuY2UuIFVuZSB2YWxldXIgZGUgOTAgZGVncsOpcyBpbmRpcXVlIHF1ZSBsZSBzb2xlaWwgZXN0IGRpcmVjdGVtZW50IGF1LWRlc3N1cy5cIixcblx0XCJAQEhpbGxzaGFkZV9BbHRpdHVkZV90YWcxQEBcIjogXCJDZSBwYXJhbcOodHJlIGVzdCB2YWxpZGUgdW5pcXVlbWVudCBzaSBsZSA8c3Ryb25nPlR5cGUgZOKAmW9tYnJhZ2U8L3N0cm9uZz4gZXN0IDxzdHJvbmc+VHJhZGl0aW9ubmVsPC9zdHJvbmc+LiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IGRlIDQ1IGRlZ3LDqXMgYXUtZGVzc3VzIGRlIGzigJlob3Jpem9uLlwiLFxuXHRcIkBASGlsbHNoYWRlX0F6aW11dGhfdGFnMEBAXCI6IFwiTGEgcHJvcHJpw6l0w6kgQXppbXV0IGTDqWZpbml0IGxhIHBvc2l0aW9uIHJlbGF0aXZlIGR1IHNvbGVpbCBwYXIgcmFwcG9ydCDDoCBsJ2hvcml6b24gKGVuIGRlZ3LDqXMpLiBDZXR0ZSBwb3NpdGlvbiBlc3QgaW5kaXF1w6llIHBhciBsJ2FuZ2xlIGR1IHNvbGVpbCBtZXN1csOpIGRhbnMgbGUgc2VucyBob3JhaXJlIMOgIHBhcnRpciBkdSBub3JkLiBVbiBhemltdXQgZGUgMCBkZWdyw6kgaW5kaXF1ZSBsZSBOb3JkLCBsJ0VzdCBlc3Qgw6AgOTAgZGVncsOpcywgbGUgU3VkIMOgIDE4MCBkZWdyw6lzIGV0IGwnT3Vlc3Qgw6AgMjcwIGRlZ3LDqXMuXCIsXG5cdFwiQEBIaWxsc2hhZGVfQXppbXV0aF90YWcxQEBcIjogXCJDZSBwYXJhbcOodHJlIGVzdCB2YWxpZGUgdW5pcXVlbWVudCBzaSBsZSA8c3Ryb25nPlR5cGUgZOKAmW9tYnJhZ2U8L3N0cm9uZz4gZXN0IDxzdHJvbmc+VHJhZGl0aW9ubmVsPC9zdHJvbmc+LiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IGRlIDMxNSBkZWdyw6lzLCDDoCBwYXJ0aXIgZHUgbm9yZC1vdWVzdC5cIixcblx0XCJAQEhpbGxzaGFkZV9EaXNhYmxlLWRlZmF1bHQtZWRnZS1waXhlbC1pbnRlcnBvbGF0aW9uX3RhZzBAQFwiOiBcIkNldHRlIG9wdGlvbiDDqXZpdGUgbGVzIGFydGVmYWN0cyBkZSByw6nDqWNoYW50aWxsb25uYWdlIHF1aSBwZXV2ZW50IHNlIHByb2R1aXJlIGxlIGxvbmcgZGVzIHRyb27Dp29ucyBkJ3VuIHJhc3Rlci4gTGVzIHBpeGVscyBlbiBzb3J0aWUgbGUgbG9uZyBkdSB0cm9uw6dvbiBkJ3VuIHJhc3RlciBvdSDDoCBjw7R0w6kgZGUgcGl4ZWxzIE5vRGF0YSBzb250IHJlbnNlaWduw6lzIGF2ZWMgTm9EYXRhLiBJbCBlc3QgcGFyIGNvbnPDqXF1ZW50IHJlY29tbWFuZMOpIGQndXRpbGlzZXIgY2UgcGFyYW3DqHRyZSB1bmlxdWVtZW50IGF2ZWMgZGVzIG1vc2HDr3F1ZXMgZCdhbHRpdHVkZSBxdWkgcHLDqXNlbnRlbnQgdW5lIHN1cGVycG9zaXRpb24uIExvcnNxdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBzb250IGRpc3BvbmlibGVzLCBsZXMgc3VyZmFjZXMgZGUgTm9EYXRhIGFmZmljaGVudCBsZXMgdmFsZXVycyBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIGF1IGxpZXUgZGUgcGl4ZWxzIHZpZGVzLlwiLFxuXHRcIkBASGlsbHNoYWRlX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMUBAXCI6IFwiTm9uIGNvY2jDqSA6IGxlIHLDqcOpY2hhbnRpbGxvbm5hZ2UgYmlsaW7DqWFpcmUgZXN0IGFwcGxpcXXDqSB1bmlmb3Jtw6ltZW50IHBvdXIgcsOpw6ljaGFudGlsbG9ubmVyIHZvdHJlIG9tYnJhZ2UuIFV0aWxpc2V6IGNldHRlIG9wdGlvbiBsb3JzcXVlIGxhIG1vc2HDr3F1ZSBjb250ZW5hbnQgdm9zIGRvbm7DqWVzIHJhc3RlciBkJ2FsdGl0dWRlIGEgY29ubnUgdW4gYXNzZW1ibGFnZSBjw7R0ZSDDoCBjw7R0ZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQEhpbGxzaGFkZV9EaXNhYmxlLWRlZmF1bHQtZWRnZS1waXhlbC1pbnRlcnBvbGF0aW9uX3RhZzJAQFwiOiBcIkNvY2jDqSA6IGxlIHLDqcOpY2hhbnRpbGxvbm5hZ2UgYmlsaW7DqWFpcmUgZXN0IHV0aWxpc8OpIGF1IHNlaW4gZGUgbOKAmW9tYnJhZ2UsIHNhdWYgbGUgbG9uZyBkZXMgdHJvbsOnb25zIGRlcyByYXN0ZXJzIG91IMOgIGPDtHTDqSBkZXMgcGl4ZWxzIGRlIHZhbGV1ciBOb0RhdGEuIENlcyBwaXhlbHMgc29udCByZW5zZWlnbsOpcyBhdmVjIE5vRGF0YSBldCBhZmZpY2hlbnQgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIHN1cGVycG9zw6lzLCBjZSBxdWkgcsOpZHVpdCBsZXMgZWZmZXRzIGRlIHRyb27Dp29ucyBhYnJ1cHRzIHBvdXZhbnQgc2UgcHJvZHVpcmUuIFV0aWxpc2V6IGNldHRlIG9wdGlvbiBsb3JzcXVlIGxhIG1vc2HDr3F1ZSBjb250ZW5hbnQgdm9zIGRvbm7DqWVzIHJhc3RlciBkJ2FsdGl0dWRlIHNlIGNvbXBvc2UgZGUgdHVpbGVzIG91IGQnw6lsw6ltZW50cyBzdXBlcnBvc8Opcy5cIixcblx0XCJAQEhpbGxzaGFkZV9EaXNhYmxlLWRlZmF1bHQtZWRnZS1waXhlbC1pbnRlcnBvbGF0aW9uX3RhZzNAQFwiOiBcIkxlcyByw6lzdWx0YXRzIGRlIGxhIGZvbmN0aW9uIHBldXZlbnQgZMOpcGVuZHJlIGRlcyBkb25uw6llcy4gU2kgdm91cyBvYnNlcnZleiBkZXMgYXJ0w6lmYWN0cyBkZSBsaW1pdGVzIGRlIHR1aWxlcyBkYW5zIHZvdHJlIHNvcnRpZSwgc8OpbGVjdGlvbm5leiBsJ2F1dHJlIGNvbmRpdGlvbiBkZSBsYSBjYXNlIMOgIGNvY2hlci5cIixcblx0XCJAQEhpbGxzaGFkZV9IaWxsc2hhZGUtVHlwZV90YWcwQEBcIjogXCJDb250csO0bGUgbGEgc291cmNlIGQnw6ljbGFpcmFnZSBkZSBsJ29tYnJhZ2UgOlwiLFxuXHRcIkBASGlsbHNoYWRlX0hpbGxzaGFkZS1UeXBlX3RhZzFAQFwiOiBcIlRyYWRpdGlvbm5lbCA6IGNhbGN1bGUgbOKAmW9tYnJhZ2Ugw6AgcGFydGlyIGTigJl1bmUgc2V1bGUgZGlyZWN0aW9uIGTigJnDqWNsYWlyYWdlLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LiBWb3VzIHBvdXZleiBkw6lmaW5pciBsZXMgb3B0aW9ucyA8c3Ryb25nPkF6aW11dDwvc3Ryb25nPiBldCA8c3Ryb25nPkFsdGl0dWRlPC9zdHJvbmc+IHBvdXIgY29udHLDtGxlciBs4oCZZW1wbGFjZW1lbnQgZGUgbGEgc291cmNlIGTigJnDqWNsYWlyYWdlLlwiLFxuXHRcIkBASGlsbHNoYWRlX0hpbGxzaGFkZS1UeXBlX3RhZzZAQFwiOiBcIk11bHRpZGlyZWN0aW9ubmVsIDogYXNzb2NpZSBsYSBsdW1pw6hyZSBkZSBwbHVzaWV1cnMgc291cmNlcyBwb3VyIHJlcHLDqXNlbnRlciB1bmUgdmlzdWFsaXNhdGlvbiBvcHRpbWlzw6llIGR1IHRlcnJhaW4uXCIsXG5cdFwiQEBIaWxsc2hhZGVfUGl4ZWwtU2l6ZS1GYWN0b3JfdGFnMEBAXCI6IFwiTOKAmW9wdGlvbiBGYWN0ZXVyIGRlIHRhaWxsZSBkZSBwaXhlbCB0aWVudCBjb21wdGUgZGVzIGNoYW5nZW1lbnRzIGTigJnDqWNoZWxsZSDDoCBtZXN1cmUgcXVlIGzigJl1dGlsaXNhdGV1ciBhcHBsaXF1ZSB1biB6b29tIGF2YW50IG91IGFycmnDqHJlIHN1ciBs4oCZYWZmaWNoYWdlIGNhcnRvZ3JhcGhpcXVlLiBFbGxlIGNvbnRyw7RsZSBsYSB2aXRlc3NlIMOgIGxhcXVlbGxlIGxlIDxzdHJvbmc+RmFjdGV1ciBaPC9zdHJvbmc+IGNoYW5nZS5cIixcblx0XCJAQEhpbGxzaGFkZV9QaXhlbC1TaXplLUZhY3Rvcl90YWczQEBcIjogXCJDZSBwYXJhbcOodHJlIGVzdCB2YWxpZGUgdW5pcXVlbWVudCBzaSBsZSB0eXBlIGRlIDxzdHJvbmc+TWlzZSDDoCBs4oCZw6ljaGVsbGU8L3N0cm9uZz4gZXN0IDxzdHJvbmc+QWp1c3TDqTwvc3Ryb25nPi4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAwLDAyNC5cIixcblx0XCJAQEhpbGxzaGFkZV9QaXhlbC1TaXplLVBvd2VyX3RhZzBAQFwiOiBcIkzigJlvcHRpb24gUHVpc3NhbmNlIGRlIHRhaWxsZSBkZSBwaXhlbCB0aWVudCBjb21wdGUgZGUgbOKAmcOpdm9sdXRpb24gZGUgbOKAmWFsdGl0dWRlIChvdSBkZSBs4oCZw6ljaGVsbGUpIMOgIG1lc3VyZSBxdWUgbGEgdmlzaW9ubmV1c2UgYXBwbGlxdWUgdW4gem9vbSBhdmFudCBvdSBhcnJpw6hyZSBzdXIgbOKAmWFmZmljaGFnZSBjYXJ0b2dyYXBoaXF1ZS4gSWwgc+KAmWFnaXQgZGUgbOKAmWV4cG9zYW50IGFwcGxpcXXDqSBhdSB0ZXJtZSBkZSB0YWlsbGUgZGUgcGl4ZWwgZGFucyBs4oCZw6lxdWF0aW9uIHF1aSBjb250csO0bGUgbGEgZnLDqXF1ZW5jZSDDoCBsYXF1ZWxsZSBsZSA8c3Ryb25nPkZhY3RldXIgWjwvc3Ryb25nPiBjaGFuZ2UgcG91ciDDqXZpdGVyIGxlcyBwZXJ0ZXMgZGUgcmVsaWVmIHNpZ25pZmljYXRpdmVzLlwiLFxuXHRcIkBASGlsbHNoYWRlX1BpeGVsLVNpemUtUG93ZXJfdGFnM0BAXCI6IFwiQ2UgcGFyYW3DqHRyZSBlc3QgdmFsaWRlIHVuaXF1ZW1lbnQgc2kgbGUgdHlwZSBkZSA8c3Ryb25nPk1pc2Ugw6AgbOKAmcOpY2hlbGxlPC9zdHJvbmc+IGVzdCA8c3Ryb25nPkFqdXN0w6k8L3N0cm9uZz4uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMCw2NjQuXCIsXG5cdFwiQEBIaWxsc2hhZGVfUmFzdGVyX3RhZzBAQFwiOiBcIkxlIGpldSBkZSBkb25uw6llcyBkJ2FsdGl0dWRlIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBIaWxsc2hhZGVfU2NhbGluZ190YWcwQEBcIjogXCJMZSByw6lzdWx0YXQgb21icsOpIGVzdCBtaXMgw6AgbCfDqWNoZWxsZSBkeW5hbWlxdWVtZW50IGVuIGFqdXN0YW50IGxlIGZhY3RldXIgeiBncsOiY2Ugw6AgbCd1bmUgZGUgZGV1eCBvcHRpb25zIDpcIixcblx0XCJAQEhpbGxzaGFkZV9TY2FsaW5nX3RhZzFAQFwiOiBcIkFqdXN0w6kgOiBhcHBsaXF1ZSB1biBhanVzdGVtZW50IG5vbiBsaW7DqWFpcmUgZW4gdXRpbGlzYW50IGxlcyB2YWxldXJzIGRlIDxzdHJvbmc+UHVpc3NhbmNlIGRlIHRhaWxsZSBkZSBwaXhlbDwvc3Ryb25nPiBldCBkZSA8c3Ryb25nPkZhY3RldXIgZGUgdGFpbGxlIGRlIHBpeGVsPC9zdHJvbmc+IHBhciBkw6lmYXV0LCBxdWkgdGllbm5lbnQgY29tcHRlIGRlcyBjaGFuZ2VtZW50cyBk4oCZYWx0aXR1ZGUgKMOpY2hlbGxlKSBsb3JzIGTigJl1biB6b29tIGF2YW50IG91IGFycmnDqHJlLiBM4oCZdXRpbGlzYXRpb24gZHUgcGFyYW3DqHRyZSA8c3Ryb25nPkFqdXN0w6k8L3N0cm9uZz4gZXN0IHJlY29tbWFuZMOpZSBlbiBjYXMgZOKAmXV0aWxpc2F0aW9uIGTigJl1biBqZXUgZGUgZG9ubsOpZXMgbW9uZGlhbC5cIixcblx0XCJAQEhpbGxzaGFkZV9TY2FsaW5nX3RhZzhAQFwiOiBcIkF1Y3VuIDogYXVjdW5lIG1pc2Ugw6AgbOKAmcOpY2hlbGxlIG7igJllc3QgYXBwbGlxdcOpZS4gQ2VsYSBlc3QgaWTDqWFsIHBvdXIgdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciB1bmlxdWUgcXVpIGNvdXZyZSB1bmUgem9uZSBsb2NhbGUuIENldHRlIG9wdGlvbiBuJ2VzdCBwYXMgcmVjb21tYW5kw6llIHBvdXIgbGVzIGpldXggZGUgZG9ubsOpZXMgbW9uZGlhdXggZG9udCBsJ2FsdGl0dWRlIHZhcmllIGJlYXVjb3VwIG91IGxlcyBjYXJ0ZXMgw6AgcGx1c2lldXJzIMOpY2hlbGxlcywgY2FyIGVsbGUgZ8OpbsOocmUgdW4gcmVsaWVmIGR1IE1OVCBhdmVjIGRlcyB2YXJpYXRpb25zIHJlc3RyZWludGVzIMOgIGRlIHBldGl0ZXMgw6ljaGVsbGVzLlwiLFxuXHRcIkBASGlsbHNoYWRlX1otRmFjdG9yX3RhZzBAQFwiOiBcIkxlIGZhY3RldXIgWiBlc3QgdW4gZmFjdGV1ciBkJ8OpY2hlbGxlIHV0aWxpc8OpIHBvdXIgY29udmVydGlyIGxlcyB2YWxldXJzIGQnYWx0aXR1ZGUgZGFucyBkZXV4IGJ1dHMgOlwiLFxuXHRcIkBASGlsbHNoYWRlX1otRmFjdG9yX3RhZzFAQFwiOiBcIkNvbnZlcnRpdCBsZXMgdW5pdMOpcyBkJ2FsdGl0dWRlICh0ZWxsZXMgcXVlIGxlcyBtw6h0cmVzIG91IGxlcyBwaWVkcykgZW4gdW5pdMOpcyBkZSBjb29yZG9ubsOpZXMgaG9yaXpvbnRhbGVzIGR1IGpldSBkZSBkb25uw6llcywgcXVpIHBldXZlbnQgw6p0cmUgZGVzIHBpZWRzLCBkZXMgbcOodHJlcyBvdSBkZXMgZGVncsOpcyxcIixcblx0XCJAQEhpbGxzaGFkZV9aLUZhY3Rvcl90YWcyQEBcIjogXCJBam91dGUgdW5lIGV4YWfDqXJhdGlvbiB2ZXJ0aWNhbGUgY29tbWUgZWZmZXQgdmlzdWVsLlwiLFxuXHRcIkBASW50X0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBASW50X0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBJbnRfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQEludF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBASW50X0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBJbnRfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBJbnRfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBASW50X0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBJbnRfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBASW50X0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBJbnRfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBJbnRfUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIMOgIGNvbnZlcnRpciBlbiBlbnRpZXIuXCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1JcnJlZ3VsYXItRGF0YV9DZWxsc2l6ZV90YWcwQEBcIjogXCJMYSB0YWlsbGUgZGUgY2VsbHVsZSBkdSByYXN0ZXIgZW4gc29ydGllIGVzdCBhdXRvbWF0aXF1ZW1lbnQgZMOpdGVjdMOpZSwgbWFpcyB2b3VzIHBvdXZleiBtb2RpZmllciBjZSBjb21wb3J0ZW1lbnQuIExhIHRhaWxsZSBkZSBjZWxsdWxlIHBldXQgw6p0cmUgbW9kaWZpw6llLCBtYWlzIGzigJnDqXRlbmR1ZSBkdSBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIHJlc3RlIGlkZW50aXF1ZS5cIixcblx0XCJAQEludGVycG9sYXRlLUlycmVndWxhci1EYXRhX0lucHV0LVNhbXBsZXNfdGFnMEBAXCI6IFwiTGVzIGRvbm7DqWVzIHBvbmN0dWVsbGVzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1JcnJlZ3VsYXItRGF0YV9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWcwQEBcIjogXCJRdWF0cmUgbcOpdGhvZGVzIGRlIHLDqcOpY2hhbnRpbGxvbm5hZ2Ugc29udCBkaXNwb25pYmxlcyBwb3VyIGNldHRlIGZvbmN0aW9uIDpcIixcblx0XCJAQEludGVycG9sYXRlLUlycmVndWxhci1EYXRhX0ludGVycG9sYXRpb24tTWV0aG9kX3RhZzFAQFwiOiBcIjxzdHJvbmc+UG9uZMOpcmF0aW9uIHBhciBs4oCZaW52ZXJzZSBkZSBsYSBkaXN0YW5jZTwvc3Ryb25nPiA6IGTDqXRlcm1pbmUgbGVzIHZhbGV1cnMgZGVzIGNlbGx1bGVzIHZpYSBsYSBjb21iaW5haXNvbiBwb25kw6lyw6llIGRlIG1hbmnDqHJlIGxpbsOpYWlyZSBk4oCZdW4gZW5zZW1ibGUgZGUgcG9pbnRzIGTigJnDqWNoYW50aWxsb25uYWdlIG91IGRlIGNlbGx1bGVzLiBMYSBwb25kw6lyYXRpb24gZXN0IHVuZSBmb25jdGlvbiBkZSBs4oCZaW52ZXJzZSBkZSBsYSBkaXN0YW5jZSDDoCBwYXJ0aXIgZGVzIGNlbGx1bGVzIG91IGRlcyBwb2ludHMgY29ubnVzLlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtSXJyZWd1bGFyLURhdGFfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnM0BAXCI6IFwiPHN0cm9uZz5USU4gbGluw6lhaXJlPC9zdHJvbmc+IDogdXRpbGlzZSB1biByw6lzZWF1IHRyaWFuZ3Vsw6kgaXJyw6lndWxpZXIgKFRJTikgw6AgcGFydGlyIGRlcyBwb2ludHMgY2VudHJhdXggZGUgY2hhcXVlIGNlbGx1bGUgZHUgcmFzdGVyIGlycsOpZ3VsaWVyIHBvdXIgaW50ZXJwb2xlciB1bmUgc3VyZmFjZSBxdWkgc2VyYSBlbnN1aXRlIGNvbnZlcnRpZSBlbiByYXN0ZXIgcsOpZ3VsaWVyLlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtSXJyZWd1bGFyLURhdGFfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnNUBAXCI6IFwiPHN0cm9uZz5Wb2lzaW4gbmF0dXJlbDwvc3Ryb25nPiA6IHJlY2hlcmNoZSBsZSBzb3VzLWVuc2VtYmxlIGTigJnDqWNoYW50aWxsb25zIGVuIGVudHLDqWUgbGUgcGx1cyBwcm9jaGUgZOKAmXVuIHBvaW50IGRlIHJlcXXDqnRlIGV0IGx1aSBhcHBsaXF1ZSB1bmUgcG9uZMOpcmF0aW9uIHN1ciBsYSBiYXNlIGRlIHN1cmZhY2VzIHByb3BvcnRpb25uZWxsZXMgYWZpbiBk4oCZaW50ZXJwb2xlciB1bmUgdmFsZXVyLlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtSXJyZWd1bGFyLURhdGFfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnN0BAXCI6IFwiPHN0cm9uZz5Wb2lzaW4gbGUgcGx1cyBwcm9jaGU8L3N0cm9uZz4gOiBjYWxjdWxlIGxhIHZhbGV1ciBkdSBwaXhlbCBncsOiY2UgYXUgcGl4ZWwgbGUgcGx1cyBwcm9jaGUuIFNpIGF1Y3VuIHBpeGVsIHNvdXJjZSBu4oCZZXhpc3RlLCBhdWN1biBub3V2ZWF1IHBpeGVsIG5lIHBldXQgw6p0cmUgY3LDqcOpIGRhbnMgbGEgc29ydGllLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtSXJyZWd1bGFyLURhdGFfU2VhcmNoLVJhZGl1c190YWcwQEBcIjogXCJJZGVudGlmaWUgbGUgbm9tYnJlIGRlIHBpeGVscyDDoCBpbmNsdXJlIHBvdXIgbGEgbcOpdGhvZGUgZGUgcsOpw6ljaGFudGlsbG9ubmFnZSBzw6lsZWN0aW9ubsOpZS4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAkezN9IHBpeGVscy5cIixcblx0XCJAQEludGVycG9sYXRlLUlycmVndWxhci1EYXRhX1ZhbHVlLUZpZWxkX3RhZzBAQFwiOiBcIlNpIHZvdXMgc8OpbGVjdGlvbm5leiB1bmUgY2xhc3NlIGTigJllbnRpdMOpcyBwb25jdHVlbGxlcyBlbiBlbnRyw6llLCB2b3VzIGRldnJleiBpZGVudGlmaWVyIGxlIGNoYW1wIGRhbnMgbGEgdGFibGUgYXR0cmlidXRhaXJlIGF2ZWMgbGEgdmFsZXVyIGRlcyBwb2ludHMuXCIsXG5cdFwiQEBJcy1OdWxsX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBASXMtTnVsbF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBASXMtTnVsbF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBASXMtTnVsbF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBASXMtTnVsbF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBASXMtTnVsbF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQElzLU51bGxfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBASXMtTnVsbF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBASXMtTnVsbF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBJcy1OdWxsX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBJcy1OdWxsX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBASXMtTnVsbF9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgdGVzdMOpIHBvdXIgaWRlbnRpZmllciBsZXMgY2VsbHVsZXMgcXVpIG9udCB1bmUgdmFsZXVyICR7Tm9EYXRhfSAobnVsbGUpLlwiLFxuXHRcIkBASXMtTnVsbF9SYXN0ZXJfdGFnMUBAXCI6IFwiTCdlbnRyw6llIHBldXQgw6p0cmUgdW5lIHZhbGV1ciBlbnRpw6hyZSBvdSDDoCB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XCJAQEtleS1NZXRhZGF0YV9CYW5kLU5hbWVzX3RhZzBAQFwiOiBcIlBlcm1ldCBkZSByZW1wbGFjZXIgbGVzIG5vbXMgZGUgY2FuYXV4IGQndW4gcmFzdGVyLiBJbCBzJ2FnaXQgZCd1bmUgY2hhw65uZSBzw6lwYXLDqWUgcGFyIHVuZSB2aXJndWxlIHJlcHLDqXNlbnRhbnQgbGVzIG5vbXMgZGUgY2FuYXV4IG1pcyDDoCBqb3VyLlwiLFxuXHRcIkBAS2V5LU1ldGFkYXRhX0JhbmQtTmFtZXNfdGFnMUBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBlc3QgZmFjdWx0YXRpZi5cIixcblx0XCJAQEtleS1NZXRhZGF0YV9NZXRhZGF0YS1KU09OX3RhZzBAQFwiOiBcIkxlcyBtw6l0YWRvbm7DqWVzIGNsw6lzIMOgIGluamVjdGVyIGRhbnMgbGUgcmFzdGVyIHNvcnRhbnQgZMOpY3JpdCBjb21tZSB1bmUgY2hhw65uZSBKU09OIHJlcHLDqXNlbnRhbnQgdW5lIGNvbGxlY3Rpb24gZGUgcGFpcmVzIGNsw6ktdmFsZXVyLiBWb2ljaSB1biBleGVtcGxlIGRlIGNoYcOubmUgSlNPTiBwb3V2YW50IHNlcnZpciBkJ2VudHLDqWUgw6AgY2V0dGUgZm9uY3Rpb24uIFRvdXRlcyBsZXMgZW50csOpZXMgZGUgY2UgcGFyYW3DqHRyZSBkb2l2ZW50IHN1aXZyZSBsZSBtw6ptZSBmb3JtYXQuXCIsXG5cdFwiQEBLZXktTWV0YWRhdGFfTWV0YWRhdGEtSlNPTl90YWcxQEBcIjogXCJDaGHDrm5lIEpTT04gcmVwcsOpc2VudGFudCBsZXMgbcOpdGFkb25uw6llcyBjbMOpcy5cIixcblx0XCJAQEtleS1NZXRhZGF0YV9NZXRhZGF0YS1KU09OX3RhZzJAQFwiOiBcInsgXFxcIkNsb3VkQ292ZXJcXFwiOiA0LCBcXFwiQmFuZFByb3BlcnRpZXNcXFwiOlsgeyBcXFwiQmFuZE5hbWVcXFwiOiBcXFwiQmx1ZVxcXCIsIFxcXCJXYXZlbGVuZ3RoTWluXFxcIjogNDQ1LCBcXFwiV2F2ZWxlbmd0aE1heFxcXCI6IDUxNiB9LCB7IFxcXCJCYW5kTmFtZVxcXCI6IFxcXCJHcmVlblxcXCIsIFxcXCJXYXZlbGVuZ3RoTWluXFxcIjogNTA2LCBcXFwiV2F2ZWxlbmd0aE1heFxcXCI6IDU5NSB9LCBdfVwiLFxuXHRcIkBAS2V5LU1ldGFkYXRhX1Byb3BlcnR5LU5hbWVfdGFnMEBAXCI6IFwiTGUgbm9tIGRlIGxhIHByb3ByacOpdMOpIGNsw6kgYXUgbml2ZWF1IGR1IGpldSBkZSBkb25uw6llcyBxdWUgdm91cyBzb3VoYWl0ZXogcmVtcGxhY2VyLlwiLFxuXHRcIkBAS2V5LU1ldGFkYXRhX1Jhc3Rlcl90YWcwQEBcIjogXCJMZSBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIG91IGxhIG1vc2HDr3F1ZSBjb250ZW5hbnQgbGVzIG3DqXRhZG9ubsOpZXMgY2zDqXMgcXVlIHZvdXMgc291aGFpdGV6IGluc8OpcmVyIG91IHJlbXBsYWNlci5cIixcblx0XCJAQEtleS1NZXRhZGF0YV9WYWx1ZV90YWcwQEBcIjogXCJMYSB2YWxldXIgZGUgcmVtcGxhY2VtZW50IGRlIGxhIHByb3ByacOpdMOpIGNsw6kgYXUgbml2ZWF1IGR1IGpldSBkZSBkb25uw6llcyBxdWUgdm91cyBzb3VoYWl0ZXogZMOpZmluaXIuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzBAQFwiOiBcIkNlIHBhcmFtw6h0cmUgc2ltdWxlIGzigJlhdWdtZW50YXRpb24gZGUgbOKAmWVmZm9ydCBwb3VyIHN1cm1vbnRlciBsZXMgY2/Du3RzIGF1IGZ1ciBldCDDoCBtZXN1cmUgcXVlIGxlIGNvw7t0IGN1bXVsw6kgYXVnbWVudGUuIElsIHBlcm1ldCBkZSBtb2TDqWxpc2VyIGxhIGZhdGlndWUgZHUgdm95YWdldXIuIExlIGNvw7t0IGN1bXVsw6kgY3JvaXNzYW50IHBvdXIgYXR0ZWluZHJlIHVuZSBjZWxsdWxlIGVzdCBtdWx0aXBsacOpIHBhciBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIGV0IGFqb3V0w6kgYXUgY2/Du3QgZW5nZW5kcsOpIHBhciBsZSBkw6lwbGFjZW1lbnQgdmVycyBsYSBjZWxsdWxlIHN1aXZhbnRlLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcxQEBcIjogXCJJbCBz4oCZYWdpdCBk4oCZdW5lIHZlcnNpb24gbW9kaWZpw6llIGTigJl1bmUgZm9ybXVsZSBkZSB0YXV4IGTigJlpbnTDqXLDqnQgY29tcG9zw6kgcXVpIHBlcm1ldCBkZSBjYWxjdWxlciBsZSBjb8O7dCBhcHBhcmVudCBkdSBkw6lwbGFjZW1lbnQgw6AgdHJhdmVycyB1bmUgY2VsbHVsZS4gQXZlYyBsJ2F1Z21lbnRhdGlvbiBkdSB0YXV4IGRlIHLDqXNpc3RhbmNlLCBsZSBjb8O7dCBkZXMgY2VsbHVsZXMgcXVpIHNvbnQgdmlzaXTDqWVzIHVsdMOpcmlldXJlbWVudCBzJ2FjY3Jvw650IMOpZ2FsZW1lbnQuIFBsdXMgbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBlc3QgaW1wb3J0YW50LCBwbHVzIGxlIGNvw7t0IGRlIGTDqXBsYWNlbWVudCB2ZXJzIGxhIGNlbGx1bGUgc3VpdmFudGUgYXVnbWVudGUsIGxlcXVlbCBlc3QgYWpvdXTDqSBwb3VyIGNoYXF1ZSBtb3V2ZW1lbnQgc3VpdmFudC4gUHVpc3F1ZSBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIGVzdCBzaW1pbGFpcmUgw6AgdW4gdGF1eCBjb21wb3PDqSBldCBxdeKAmWhhYml0dWVsbGVtZW50IGxlcyB2YWxldXJzIGRlIGNvw7t0IGN1bXVsw6kgc29udCB0csOocyBpbXBvcnRhbnRlcywgbm91cyBzdWdnw6lyb25zIGzigJl1dGlsaXNhdGlvbiBkZSB0YXV4IGRlIHLDqXNpc3RhbmNlIGZhaWJsZXMsIHRlbHMgcXVlIDAsMDA1IG91IGVuY29yZSBpbmbDqXJpZXVycywgc2Vsb24gbGVzIHZhbGV1cnMgZGUgY2/Du3QgY3VtdWzDqS5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMkBAXCI6IFwiTGEgdmFsZXVyIGRvaXQgw6p0cmUgc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIGNhcGFjaXTDqSBwYXIgZMOpZmF1dCBlc3QgbGltaXTDqWUgcGFyIGxlIHRyb27Dp29uIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfQ2FwYWNpdHlfdGFnMEBAXCI6IFwiRMOpZmluaXQgbGEgY2FwYWNpdMOpIGRlIGNvw7t0IHBvdXIgbGUgdm95YWdldXIgcG91ciB1bmUgc291cmNlLiBMZXMgY2FsY3VscyBkZSBjb8O7dCBjb250aW51ZW50IHBvdXIgY2hhcXVlIHNvdXJjZSBqdXNxdeKAmcOgIGNlIHF1ZSBsYSBjYXBhY2l0w6kgc3DDqWNpZmnDqWUgc29pdCBhdHRlaW50ZS5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9DYXBhY2l0eV90YWcxQEBcIjogXCJMYSB2YWxldXIgZG9pdCDDqnRyZSBzdXDDqXJpZXVyZSDDoCB6w6lyby4gTGEgY2FwYWNpdMOpIHBhciBkw6lmYXV0IGVzdCBsaW1pdMOpZSBwYXIgbGUgdHJvbsOnb24gZHUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9Db3N0LVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSByZXF1aXMgZMOpZmluaXNzYW50IGxlIGNvw7t0IG91IGzigJlpbXDDqWRhbmNlIGRlIGTDqXBsYWNlbWVudCBwbGFuaW3DqXRyaXF1ZSDDoCB0cmF2ZXJzIGNoYXF1ZSBjZWxsdWxlLiBMYSB2YWxldXIgw6AgY2hhcXVlIGVtcGxhY2VtZW50IGRlIGNlbGx1bGUgcmVwcsOpc2VudGUgbGUgY2/Du3QgcGFyIHVuaXTDqSBkZSBkaXN0YW5jZSBwb3VyIGxlIGTDqXBsYWNlbWVudCDDoCB0cmF2ZXJzIGNoYXF1ZSBjZWxsdWxlLiBDaGFxdWUgdmFsZXVyIGTigJllbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVzdCBtdWx0aXBsacOpZSBwYXIgbGEgcsOpc29sdXRpb24gZGUgY2VsbHVsZSBldCBjb21wZW5zZSDDqWdhbGVtZW50IGxlIG1vdXZlbWVudCBkaWFnb25hbCBhZmluIGTigJlvYnRlbmlyIGxlIGNvw7t0IHRvdGFsIGR1IHBhc3NhZ2Ugw6AgdHJhdmVycyBsYSBjZWxsdWxlLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX0Nvc3QtUmFzdGVyX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGR1IDxzdHJvbmc+UmFzdGVyIGRlIGNvw7t0PC9zdHJvbmc+IHBldXZlbnQgw6p0cmUgZGVzIGVudGllcnMgb3UgZGVzIG5vbWJyZXMgw6AgdmlyZ3VsZSBmbG90dGFudGUsIG1haXMgZWxsZXMgbmUgcGV1dmVudCBwYXMgw6p0cmUgbsOpZ2F0aXZlcyBuaSBudWxsZXMuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfRGVzdGluYXRpb24tRmllbGRfdGFnMEBAXCI6IFwiQ2hhbXAgcGVybWV0dGFudCBkJ29idGVuaXIgZGVzIHZhbGV1cnMgcmVsYXRpdmVzIGF1eCBlbXBsYWNlbWVudHMgZGUgZGVzdGluYXRpb24uXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfRGVzdGluYXRpb24tUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIHJlcXVpcyBpZGVudGlmaWFudCBsZXMgcGl4ZWxzIMOgIHBhcnRpciBkZXNxdWVscyBsZSBjaGVtaW4gZGUgbW9pbmRyZSBjb8O7dCBlc3QgZMOpdGVybWluw6kgdmVycyBsYSBzb3VyY2UgZGUgbW9pbmRyZSBjb8O7dC4gQ2V0dGUgZW50csOpZSBlc3QgY29tcG9zw6llIGRlIHBpeGVscyBheWFudCBkZXMgdmFsZXVycyB2YWxpZGVzIGV0IGxlcyBwaXhlbHMgcmVzdGFudHMgZG9pdmVudCBhdm9pciBsYSB2YWxldXIgJHtOb0RhdGF9LiBMZXMgdmFsZXVycyDDqWdhbGVzIMOgIDAgc29udCB2YWxpZGVzLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiTGUgc2V1aWwgcXVlIGxlcyB2YWxldXJzIGRlIGNvw7t0IGN1bXVsw6kgbmUgcGV1dmVudCBwYXMgZMOpcGFzc2VyLiBTaSB1bmUgZGlzdGFuY2UgZGUgY2/Du3QgY3VtdWzDqSBkw6lwYXNzZSBjZXR0ZSB2YWxldXIsIGxhIHZhbGV1ciBlbiBzb3J0aWUgZGUgbOKAmWVtcGxhY2VtZW50IGRlIGNlbGx1bGUgZXN0ICR7Tm9EYXRhfS4gTGEgZGlzdGFuY2UgbWF4aW1hbGUgZMOpZmluaXQgbOKAmcOpdGVuZHVlIHBvdXIgbGFxdWVsbGUgbGVzIGRpc3RhbmNlcyBkZSBjb8O7dCBjdW11bMOpIHNvbnQgY2FsY3Vsw6llcy4gTGEgZGlzdGFuY2UgcGFyIGTDqWZhdXQgdmEganVzcXXigJnDoCBs4oCZw6l0ZW5kdWUgZHUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzBAQFwiOiBcIkNlIHBhcmFtw6h0cmUgcGVybWV0IGRlIGNvbnRyw7RsZXIgbGUgbW9kZSBkZSBkw6lwbGFjZW1lbnQgb3UgbGEgbWFnbml0dWRlIMOgIHVuZSBzb3VyY2UuIFBsdXMgbGUgbXVsdGlwbGljYXRldXIgZXN0IMOpbGV2w6ksIHBsdXMgbGUgY2/Du3QgZGUgZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSDDoCB1bmUgYXV0cmUgZXN0IGltcG9ydGFudC5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGRvaXZlbnQgw6p0cmUgc3Vww6lyaWV1cmVzIMOgIHrDqXJvLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDEuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfUGF0aC1UeXBlX3RhZzBAQFwiOiBcIk1vdC1jbMOpIGTDqWZpbmlzc2FudCBsYSBmYcOnb24gZG9udCBsZXMgdmFsZXVycyBldCBsZXMgem9uZXMgZGUgbCdlbnRyw6llIGRlIGRlc3RpbmF0aW9uIHNvbnQgaW50ZXJwcsOpdMOpZXMgZGFucyBsZXMgY2FsY3VscyBkdSBjaGVtaW4gZGUgY2/Du3QgOlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1BhdGgtVHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPkxlIG1vaW5zIGNvw7t0ZXV4PC9zdHJvbmc+IDogcG91ciB0b3VzIGxlcyBwaXhlbHMgZGVzIGRvbm7DqWVzIGRlIGRlc3RpbmF0aW9uIGVuIGVudHLDqWUsIGxlIGNoZW1pbiBkdSBtb2luZHJlIGNvw7t0IGVzdCBkw6lyaXbDqSBkdSBwaXhlbCBjb250ZW5hbnQgbGUgbWluaW11bSBkZSBjaGVtaW5zIGRlIG1vaW5kcmUgY2/Du3QgdmVycyBsZXMgY2VsbHVsZXMgc291cmNlcy5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9QYXRoLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5DaGFxdWUgY2VsbHVsZTwvc3Ryb25nPiA6IHVuIGNoZW1pbiBkZSBtb2luZHJlIGNvw7t0IGVzdCBkw6l0ZXJtaW7DqSBwb3VyIGNoYXF1ZSBwaXhlbCBhdmVjIGRlcyB2YWxldXJzIHZhbGlkZXMgZGFucyBsZXMgZG9ubsOpZXMgZGUgZGVzdGluYXRpb24gZW4gZW50csOpZSwgcHVpcyBlbnJlZ2lzdHLDqSBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIENoYXF1ZSBjZWxsdWxlIGRlcyBkb25uw6llcyBkZSBkZXN0aW5hdGlvbiBlbiBlbnRyw6llIGVzdCB0cmFpdMOpZSBzw6lwYXLDqW1lbnQgZXQgdW4gY2hlbWluIGRlIG1vaW5kcmUgY2/Du3QgZXN0IGTDqXRlcm1pbsOpIHBvdXIgY2hhcXVlIGNlbGx1bGUgZGUgZMOpcGFydC5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9QYXRoLVR5cGVfdGFnNUBAXCI6IFwiPHN0cm9uZz5DaGFxdWUgem9uZTwvc3Ryb25nPiA6IHVuIGNoZW1pbiBkZSBtb2luZHJlIGNvw7t0IGVzdCBkw6l0ZXJtaW7DqSBwb3VyIGNoYXF1ZSB6b25lIGRlcyBkb25uw6llcyBkZSBkZXN0aW5hdGlvbiBlbiBlbnRyw6llLCBwdWlzIGVucmVnaXN0csOpIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gTGUgY2hlbWluIGRlIG1vaW5kcmUgY2/Du3QgY29tbWVuY2UgYXUgcGl4ZWwgYXZlYyBsYSBwb25kw6lyYXRpb24gZGUgZGlzdGFuY2UgZGUgcGx1cyBmYWlibGUgY2/Du3QgZGFucyBsYSB6b25lLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1NvdXJjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgcmVxdWlzIHF1aSBpZGVudGlmaWUgbGVzIGNlbGx1bGVzIG91IGxlcyBlbXBsYWNlbWVudHMgw6AgcGFydGlyIGRlc3F1ZWxzIGxhIGRpc3RhbmNlIGRlIG1vaW5kcmUgY2/Du3QgY3VtdWzDqSBlc3QgY2FsY3Vsw6llIHBvdXIgY2hhcXVlIGVtcGxhY2VtZW50IGRlIGNlbGx1bGUgZW4gc29ydGllLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiQ2/Du3QgZGUgZMOpcGFydCBkdSBjYWxjdWwgZGVzIGNvw7t0cy4gQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgc3DDqWNpZmllciBsZSBjb8O7dCBmaXhlIGFzc29jacOpIMOgIHVuZSBzb3VyY2UuIFBsdXTDtHQgcXVlIGRlIGNvbW1lbmNlciBhdmVjIHVuIGNvw7t0IMOpZ2FsIMOgIDAsIGzigJlhbGdvcml0aG1lIGRlIGNvw7t0IGNvbW1lbmNlIGF2ZWMgbGEgdmFsZXVyIGTDqWZpbmllLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1N0YXJ0LUNvc3RfdGFnMUBAXCI6IFwiTGEgdmFsZXVyIGRvaXQgw6p0cmUgw6lnYWxlIG91IHN1cMOpcmlldXJlIMOgIHrDqXJvLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDAuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfVHJhdmVsLURpcmVjdGlvbl90YWcwQEBcIjogXCJEw6lmaW5pdCBsZSBzZW5zIGR1IHZveWFnZXVyIGVuIGNhcyBk4oCZYXBwbGljYXRpb24gZHUgdGF1eCBkZSByw6lzaXN0YW5jZSBzb3VyY2UgZXQgZHUgY2/Du3QgZGUgZMOpcGFydCBzb3VyY2UuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfVHJhdmVsLURpcmVjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPsOAIHBhcnRpciBkZSBsYSBzb3VyY2U8L3N0cm9uZz4gOiBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIHNvdXJjZSBldCBsZSBjb8O7dCBkZSBkw6lwYXJ0IHNvdXJjZSBzb250IGFwcGxpcXXDqXMgw6AgcGFydGlyIGRlIGxhIHNvdXJjZSBlbiBlbnRyw6llIGV0IGVuIHNlIGTDqXBsYcOnYW50IHZlcnMgbGVzIGNlbGx1bGVzIG5vbiBzb3VyY2VzLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1RyYXZlbC1EaXJlY3Rpb25fdGFnM0BAXCI6IFwiPHN0cm9uZz5WZXJzIGxhIHNvdXJjZTwvc3Ryb25nPiA6IGxlIHRhdXggZGUgcsOpc2lzdGFuY2Ugc291cmNlIGV0IGxlIGNvw7t0IGRlIGTDqXBhcnQgc291cmNlIHNvbnQgYXBwbGlxdcOpcyDDoCBwYXJ0aXIgZGUgY2hhcXVlIGNlbGx1bGUgbm9uIHNvdXJjZSBldCBlbiByZXZlbmFudCB2ZXJzIGxhIHNvdXJjZSBlbiBlbnRyw6llLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1RyYXZlbC1EaXJlY3Rpb25fdGFnNUBAXCI6IFwiU3DDqWNpZmlleiBsZSBtb3QtY2zDqSA8c3Ryb25nPsOAIHBhcnRpciBkZSBsYSBzb3VyY2U8L3N0cm9uZz4gb3UgPHN0cm9uZz5WZXJzIGxhIHNvdXJjZTwvc3Ryb25nPiwgcXVpIGVzdCBhcHBsaXF1w6kgw6AgdG91dGVzIGxlcyBzb3VyY2VzLCBvdSBzcMOpY2lmaWV6IHVuIGNoYW1wIGRhbnMgbGUgPHN0cm9uZz5SYXN0ZXIgc291cmNlPC9zdHJvbmc+IHF1aSBjb250aWVudCBsZXMgbW90cy1jbMOpcyBwZXJtZXR0YW50IGTigJlpZGVudGlmaWVyIGxlIHNlbnMgZGUgZMOpcGxhY2VtZW50IHBvdXIgY2hhcXVlIHNvdXJjZS4gQ2UgY2hhbXAgZG9pdCBjb250ZW5pciBsYSBjaGHDrm5lICR7RlJPTV9TT1VSQ0V9IG91ICR7VE9fU09VUkNFfS5cIixcblx0XCJAQExlc3MtVGhhbl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQExlc3MtVGhhbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATGVzcy1UaGFuX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBMZXNzLVRoYW5fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQExlc3MtVGhhbl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATGVzcy1UaGFuX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATGVzcy1UaGFuX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQExlc3MtVGhhbl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATGVzcy1UaGFuX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQExlc3MtVGhhbl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATGVzcy1UaGFuX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATGVzcy1UaGFuX1Jhc3Rlcl90YWcwQEBcIjogXCJFbnRyw6llIHRlc3TDqWUgcG91ciBkw6l0ZXJtaW5lciBzaSBlbGxlIGVzdCBpbmbDqXJpZXVyZSDDoCBsYSBzZWNvbmRlIGVudHLDqWUuXCIsXG5cdFwiQEBMZXNzLVRoYW5fUmFzdGVyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBMZXNzLVRoYW5fUmFzdGVyMl90YWcwQEBcIjogXCJFbnRyw6llIHBhciByYXBwb3J0IMOgIGxhcXVlbGxlIGxhIHByZW1pw6hyZSBlbnRyw6llIGVzdCB0ZXN0w6llIHBvdXIgZMOpdGVybWluZXIgc2kgZWxsZSBlc3QgaW5mw6lyaWV1cmUuXCIsXG5cdFwiQEBMZXNzLVRoYW5fUmFzdGVyMl90YWcxQEBcIjogXCJVbmUgdmFsZXVyIGNvbnN0YW50ZSBwZXV0IMOqdHJlIHV0aWxpc8OpZSBlbiBlbnRyw6llIHBvdXIgY2UgcGFyYW3DqHRyZSwgw6AgY29uZGl0aW9uIHF14oCZdW4gcmFzdGVyIHNvaXQgc3DDqWNpZmnDqSBwb3VyIGzigJlhdXRyZSBwYXJhbcOodHJlLlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgdGVzdMOpZSBwb3VyIGTDqXRlcm1pbmVyIHNpIGVsbGUgZXN0IGluZsOpcmlldXJlIG91IMOpZ2FsZSDDoCBsYSBzZWNvbmRlIGVudHLDqWUuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfUmFzdGVyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfUmFzdGVyMl90YWcwQEBcIjogXCJFbnRyw6llIHBhciByYXBwb3J0IMOgIGxhcXVlbGxlIGxhIHByZW1pw6hyZSBlbnRyw6llIGVzdCB0ZXN0w6llIHBvdXIgZMOpdGVybWluZXIgc2kgZWxsZSBlc3QgaW5mw6lyaWV1cmUgb3Ugw6lnYWxlLlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX1Jhc3RlcjJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQExuX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBATG5fQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQExuX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBMbl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATG5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQExuX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATG5fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBATG5fRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQExuX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQExuX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBMbl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQExuX1Jhc3Rlcl90YWcwQEBcIjogXCJWYWxldXJzIGVuIGVudHLDqWUgcG91ciBsZXNxdWVsbGVzIGNhbGN1bGVyIGxlIGxvZ2FyaXRobWUgbmF0dXJlbCAoTG4pLlwiLFxuXHRcIkBATG9nMTBfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBMb2cxMF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATG9nMTBfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQExvZzEwX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBMb2cxMF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATG9nMTBfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBMb2cxMF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBMb2cxMF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATG9nMTBfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATG9nMTBfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQExvZzEwX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATG9nMTBfUmFzdGVyX3RhZzBAQFwiOiBcIlZhbGV1cnMgZW4gZW50csOpZSBwb3VyIGxlc3F1ZWxsZXMgb24gY2FsY3VsZSBsZSBsb2dhcml0aG1lIGRlIGJhc2UgMTAuXCIsXG5cdFwiQEBMb2cyX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQExvZzJfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBATG9nMl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATG9nMl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBMb2cyX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBMb2cyX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATG9nMl9SYXN0ZXJfdGFnMEBAXCI6IFwiVmFsZXVycyBlbiBlbnRyw6llIHBvdXIgbGVzcXVlbGxlcyBvbiBjYWxjdWxlIGxlIGxvZ2FyaXRobWUgZGUgYmFzZSAyLlwiLFxuXHRcIkBATG9va3VwX0ZpZWxkX3RhZzBAQFwiOiBcIkNoYW1wIGNvbnRlbmFudCBsZXMgdmFsZXVycyBzb3VoYWl0w6llcyBkdSBub3V2ZWF1IHJhc3Rlci5cIixcblx0XCJAQExvb2t1cF9GaWVsZF90YWcxQEBcIjogXCJJbCBkb2l0IHPigJlhZ2lyIGTigJl1biB0eXBlIG51bcOpcmlxdWUuXCIsXG5cdFwiQEBMb29rdXBfUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBlbiBlbnRyw6llIGNvbnRlbmFudCB1biBjaGFtcCDDoCBwYXJ0aXIgZHVxdWVsIHZvdXMgdm91bGV6IGNyw6llciB1biByYXN0ZXIuXCIsXG5cdFwiQEBMb29rdXBfUmFzdGVyX3RhZzFAQFwiOiBcIklsIHBldXQgw6p0cmUgZGUgdHlwZSBlbnRpZXIgb3Ugw6AgdmlyZ3VsZSBmbG90dGFudGUuXCIsXG5cdFwiQEBNYXNrX0luY2x1ZGVkLVJhbmdlc190YWcwQEBcIjogXCJMZXMgcGxhZ2VzIGluY2x1c2VzIHBldXZlbnQgw6p0cmUgc3DDqWNpZmnDqWVzIHBvdXIgY2hhcXVlIGNhbmFsIGVuIGTDqWZpbmlzc2FudCB1bmUgdmFsZXVyIG1pbmltdW0gZXQgdW5lIHZhbGV1ciBtYXhpbXVtIDsgdG91dGUgdmFsZXVyIGVuIGRlaG9ycyBkZSBjZXR0ZSBwbGFnZSByZW52ZXJyYSBsYSB2YWxldXIgJHtOb0RhdGF9LiBVbiBwaXhlbCBu4oCZZXN0IGluY2x1cyBxdWUgc2kgc2EgdmFsZXVyIGVzdCBjb21wcmlzZSBkYW5zIGzigJl1bmUgZGVzIHBsYWdlcyBzcMOpY2lmacOpZXMuIFBhciBjb25zw6lxdWVudCwgc2kgbGUgY2FuYWwgMSBhIHVuZSBwbGFnZSBkZSA1LTEwIGV0IGxlIGNhbmFsIDIgdW5lIHBsYWdlIGRlIDE1LTIwLCBldCBxdWUgbGEgdmFsZXVyIGRlIHBpeGVsIHBvdXIgbGUgY2FuYWwgMSBlc3QgOCwgY2UgcGl4ZWwgbmUgc2VyYSBwYXMgbWFzcXXDqS5cIixcblx0XCJAQE1hc2tfTm9EYXRhLUludGVycHJldGF0aW9uX3RhZzBAQFwiOiBcIkNlbGEgZmFpdCByw6lmw6lyZW5jZSDDoCBsYSBmYcOnb24gZG9udCBsZXMgPHN0cm9uZz5WYWxldXJzICR7Tm9EYXRhfTwvc3Ryb25nPiBpbXBhY3RlbnQgbOKAmWltYWdlIGVuIHNvcnRpZS5cIixcblx0XCJAQE1hc2tfTm9EYXRhLUludGVycHJldGF0aW9uX3RhZzNAQFwiOiBcIlZvdXMgcG91dmV6IGNob2lzaXIgcGFybWkgbGVzIGRldXggb3B0aW9ucyBzdWl2YW50ZXMgOlwiLFxuXHRcIkBATWFza19Ob0RhdGEtSW50ZXJwcmV0YXRpb25fdGFnNEBAXCI6IFwiPHN0cm9uZz5Ub3VzIGxlcyBjcml0w6hyZXM8L3N0cm9uZz4gOiBsZXMgdmFsZXVycyAke05vRGF0YX0gcXVlIHZvdXMgc3DDqWNpZmlleiBwb3VyIGNoYXF1ZSBiYW5kZSBkb2l2ZW50IHNlIHByb2R1aXJlIGRhbnMgbGUgbcOqbWUgcGl4ZWwgcG91ciBxdWUgbOKAmWltYWdlIGVuIHNvcnRpZSBjb250aWVubmUgbGUgcGl4ZWwgJHtOb0RhdGF9LlwiLFxuXHRcIkBATWFza19Ob0RhdGEtSW50ZXJwcmV0YXRpb25fdGFnNkBAXCI6IFwiPHN0cm9uZz5DZXJ0YWlucyBjcml0w6hyZXM8L3N0cm9uZz4gOiBzaSBsYSB2YWxldXIgJHtOb0RhdGF9IHF1ZSB2b3VzIHNww6ljaWZpZXogc2UgcHJvZHVpdCBwb3VyIHVuIHBpeGVsIGRhbnMgdW5lIGJhbmRlIHNww6ljaWZpw6llLCBjZSBwaXhlbCBkYW5zIGzigJlpbWFnZSBlbiBzb3J0aWUgcHJlbmRyYSBsYSB2YWxldXIgJHtOb0RhdGF9LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATWFza19Ob0RhdGEtVmFsdWVzX3RhZzBAQFwiOiBcIkxlcyB2YWxldXJzIE5vRGF0YSBwZXV2ZW50IMOqdHJlIHNww6ljaWZpw6llcyBwb3VyIGNoYXF1ZSBjYW5hbC4gVm91cyBwb3V2ZXogc3DDqWNpZmllciBwbHVzaWV1cnMgdmFsZXVycyBlbiBzYWlzaXNzYW50IHVuZSBsaXN0ZSBkZSB2YWxldXJzIHPDqXBhcsOpZXMgcGFyIHVuIGVzcGFjZS5cIixcblx0XCJAQE1hc2tfUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBATWludXNfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBNaW51c19DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATWludXNfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQE1pbnVzX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBNaW51c19DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATWludXNfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBNaW51c19FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBNaW51c19FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATWludXNfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATWludXNfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQE1pbnVzX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATWludXNfUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgZGUgbGFxdWVsbGUgc291c3RyYWlyZSBsZXMgdmFsZXVycyBkZSBsYSBkZXV4acOobWUgZW50csOpZS5cIixcblx0XCJAQE1pbnVzX1Jhc3Rlcl90YWcxQEBcIjogXCJVbmUgdmFsZXVyIGNvbnN0YW50ZSBwZXV0IMOqdHJlIHV0aWxpc8OpZSBlbiBlbnRyw6llIHBvdXIgY2UgcGFyYW3DqHRyZSwgw6AgY29uZGl0aW9uIHF14oCZdW4gcmFzdGVyIHNvaXQgc3DDqWNpZmnDqSBwb3VyIGzigJlhdXRyZSBwYXJhbcOodHJlLlwiLFxuXHRcIkBATWludXNfUmFzdGVyMl90YWcwQEBcIjogXCJWYWxldXJzIGVuIGVudHLDqWUgw6Agc291c3RyYWlyZSBkZXMgdmFsZXVycyBkZSBsYSBwcmVtacOocmUgZW50csOpZS5cIixcblx0XCJAQE1pbnVzX1Jhc3RlcjJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQE1MLUNsYXNzaWZ5X1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSDDoCBjbGFzc2VyIMOgIGzigJlhaWRlIGRlIGzigJlhbGdvcml0aG1lIGRlIGNsYXNzaWZpY2F0aW9uIGRlIHZyYWlzZW1ibGFuY2UgbWF4aW1hbGUuXCIsXG5cdFwiQEBNTC1DbGFzc2lmeV9TaWduYXR1cmUtRmlsZS1vci1VUkxfdGFnMEBAXCI6IFwiRmljaGllciBkZSBzaWduYXR1cmVzICR7LmdzZ30uXCIsXG5cdFwiQEBNb2RfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBNb2RfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQE1vZF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBATW9kX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBNb2RfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQE1vZF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQE1vZF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBNb2RfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQE1vZF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBNb2RfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQE1vZF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQE1vZF9SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSBkdSBudW3DqXJhdGV1ci5cIixcblx0XCJAQE1vZF9SYXN0ZXJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQE1vZF9SYXN0ZXIyX3RhZzBAQFwiOiBcIkVudHLDqWUgZHUgZMOpbm9taW5hdGV1ci5cIixcblx0XCJAQE1vZF9SYXN0ZXIyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBNb3NhaWMtUmFzdGVyc19PcGVyYXRpb25fdGFnMEBAXCI6IFwiUsOpc291dCBsZXMgY29uZmxpdHMgbG9yc3F1ZSBkZXMgcGFydGllcyBkZSBkZXV4IGltYWdlcyBvdSBwbHVzIHNlIHN1cGVycG9zZW50LiBWb2ljaSBxdWVscXVlcy11bmVzIGRlcyBvcHRpb25zIGRpc3BvbmlibGVzIDpcIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX09wZXJhdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPkZ1c2lvbm5lcjwvc3Ryb25nPiA6IGNhbGN1bGVyIGV0IGFmZmljaGVyIHVuZSBtb3llbm5lIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgZW4gYXR0cmlidWFudCB1bmUgcG9uZMOpcmF0aW9uIHBsdXMgw6lsZXbDqWUgYXV4IHBpeGVscyBsZXMgcGx1cyBwcm9jaGVzIGRlcyBpbWFnZXMgdm9pc2luZXMgYWZpbiBkZSBnw6luw6lyZXIgdW5lIGltYWdlIHBsdXMgbGlzc2UuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBNb3NhaWMtUmFzdGVyc19PcGVyYXRpb25fdGFnM0BAXCI6IFwiPHN0cm9uZz5QcmVtaWVyPC9zdHJvbmc+IDogYWZmaWNoZXIgbGVzIHBpeGVscyBkZSBsYSBwcmVtacOocmUgaW1hZ2UgZGFucyBsYSBsaXN0ZSBkZXMgaW1hZ2VzIHF1aSBzZSBzdXBlcnBvc2VudCDDoCB1bmUgem9uZSBkb25uw6llLlwiLFxuXHRcIkBATW9zYWljLVJhc3RlcnNfT3BlcmF0aW9uX3RhZzVAQFwiOiBcIjxzdHJvbmc+RGVybmllcjwvc3Ryb25nPiA6IGFmZmljaGVyIGxlcyBwaXhlbHMgZGUgbGEgZGVybmnDqHJlIGltYWdlIGRhbnMgbGEgbGlzdGUgZGVzIGltYWdlcyBxdWkgc2Ugc3VwZXJwb3NlbnQgw6AgdW5lIHpvbmUgZG9ubsOpZS5cIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX09wZXJhdGlvbl90YWc3QEBcIjogXCI8c3Ryb25nPk1heDwvc3Ryb25nPiA6IGFmZmljaGVyIGxhIHZhbGV1ciBkZSBwaXhlbCBsYSBwbHVzIMOpbGV2w6llIGRlIHRvdXRlcyBsZXMgY291Y2hlcyBzdXBlcnBvc8OpZXMuIEF2ZWMgY2V0dGUgb3B0aW9uLCByaWVuIG5lIGdhcmFudGl0IHF1ZSB2b3VzIGFmZmljaGlleiBsZXMgcGl4ZWxzIGTigJl1bmUgc2V1bGUgaW1hZ2UgZGFucyBsYSB6b25lIGRlIHN1cGVycG9zaXRpb24uIElsIHPigJlhZ2l0IHBsdXTDtHQgZOKAmXVuZSBjb21iaW5haXNvbiBkZXMgY291Y2hlcyBwb3RlbnRpZWxsZXMuXCIsXG5cdFwiQEBNb3NhaWMtUmFzdGVyc19PcGVyYXRpb25fdGFnOUBAXCI6IFwiPHN0cm9uZz5Nb3llbm5lPC9zdHJvbmc+IDogY2FsY3VsZXIgZXQgYWZmaWNoZXIgdW5lIG1veWVubmUgZGVzIHBpeGVscyBzdXBlcnBvc8Opcy5cIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX09wZXJhdGlvbl90YWcxMUBAXCI6IFwiPHN0cm9uZz5NaW48L3N0cm9uZz4gOiBhZmZpY2hlciBsYSB2YWxldXIgZGUgcGl4ZWwgbGEgcGx1cyBmYWlibGUgZGUgdG91dGVzIGxlcyBjb3VjaGVzIHN1cGVycG9zw6llcy4gQXZlYyBjZXR0ZSBvcHRpb24sIHJpZW4gbmUgZ2FyYW50aXQgcXVlIHZvdXMgYWZmaWNoaWV6IGxlcyBwaXhlbHMgZOKAmXVuZSBzZXVsZSBpbWFnZSBkYW5zIGxhIHpvbmUgZGUgc3VwZXJwb3NpdGlvbi4gSWwgc+KAmWFnaXQgcGx1dMO0dCBk4oCZdW5lIGNvbWJpbmFpc29uIGRlcyBjb3VjaGVzIHBvdGVudGllbGxlcy5cIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX1Jhc3RlcnNfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5lciBsZXMgcmFzdGVyIHF1ZSB2b3VzIHNvdWhhaXRleiBtb3Nhw69xdWVyIGVuc2VtYmxlIHBvdXIgZm9ybWVyIHVuZSBpbWFnZS5cIixcblx0XCJAQE5EVklfSW5mcmFyZWQtQmFuZC1JRF90YWcwQEBcIjogXCJTcMOpY2lmaWUgbOKAmUlEIGRlIGNhbmFsIHF1aSByZXByw6lzZW50ZSBsYSBwYXJ0aWUgaW5mcmFyb3VnZSBwcm9jaGUgZHUgc3BlY3RyZSDDqWxlY3Ryb21hZ27DqXRpcXVlLlwiLFxuXHRcIkBATkRWSV9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIG11bHRpc3BlY3RyYWwgZW4gZW50csOpZS5cIixcblx0XCJAQE5EVklfU2NpZW50aWZpYy1PdXRwdXRfdGFnMEBAXCI6IFwiTGVzIHZhbGV1cnMgZW4gc29ydGllIHZvbnQgZGUgLTEuMCDDoCAxLjAsIGNlIHF1aSBlc3QgdXRpbGlzw6kgZGFucyBkZSBub21icmV1c2VzIGFwcGxpY2F0aW9ucyBzY2llbnRpZmlxdWVzLlwiLFxuXHRcIkBATkRWSV9WaXNpYmxlLUJhbmQtSURfdGFnMEBAXCI6IFwiU3DDqWNpZmllIGzigJlJRCBkZSBjYW5hbCBxdWkgcmVwcsOpc2VudGUgbGEgcGFydGllIHJvdWdlIGR1IHNwZWN0cmUgw6lsZWN0cm9tYWduw6l0aXF1ZS5cIixcblx0XCJAQE5EVkktQ29sb3JpemVkX0NvbG9yLVJhbXBfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiB1biBkw6lncmFkw6kgZGUgY291bGV1cnMgcHLDqWTDqWZpbmkgZGFucyBsYSBsaXN0ZSBkw6lyb3VsYW50ZS5cIixcblx0XCJAQE5EVkktQ29sb3JpemVkX0NvbG9yLVNjaGVtZS1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbGUgdHlwZSBkZSBjb21iaW5haXNvbiBkZSBjb3VsZXVycyBhdmVjIGxlcXVlbCBsYSBzb3J0aWUgTkRWSSBzZXJhIGNvbG9yaXPDqWUgOlwiLFxuXHRcIkBATkRWSS1Db2xvcml6ZWRfQ29sb3ItU2NoZW1lLVR5cGVfdGFnMUBAXCI6IFwiUGFsZXR0ZSBkZSBjb3VsZXVycyA6IGNob2lzaXNzZXogdW5lIHBhbGV0dGUgZGUgY291bGV1cnMgcHLDqWTDqWZpbmllIGRhbnMgbGEgbGlzdGUgZMOpcm91bGFudGUuIFZvdXMgYXZleiDDqWdhbGVtZW50IGxhIHBvc3NpYmlsaXTDqSBk4oCZYWNjw6lkZXIgw6AgdW4gZmljaGllciBkZSBwYWxldHRlIGRlIGNvdWxldXJzIGV4aXN0YW50LlwiLFxuXHRcIkBATkRWSS1Db2xvcml6ZWRfQ29sb3ItU2NoZW1lLVR5cGVfdGFnMkBAXCI6IFwiRMOpZ3JhZMOpIGRlIGNvdWxldXJzIDogY2hvaXNpc3NleiB1bmUgY29tYmluYWlzb24gZGUgY291bGV1cnMgcHLDqWTDqWZpbmllIGRhbnMgbGEgbGlzdGUgZMOpcm91bGFudGUuXCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9Db2xvcm1hcF90YWcwQEBcIjogXCJDaG9pc2lzc2V6IHVuZSBwYWxldHRlIGRlIGNvdWxldXJzIHByw6lkw6lmaW5pZSBkYW5zIGxhIGxpc3RlIGTDqXJvdWxhbnRlLiBWb3VzIHBvdXZleiBhdXNzaSBhY2PDqWRlciDDoCB1biBmaWNoaWVyIGRlIHBhbGV0dGUgZGUgY291bGV1cnMgZXhpc3RhbnQuXCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9JbmZyYXJlZC1CYW5kLUlEX3RhZzBAQFwiOiBcIlNww6ljaWZpZSBs4oCZSUQgZGUgY2FuYWwgcXVpIHJlcHLDqXNlbnRlIGxhIHBhcnRpZSBpbmZyYXJvdWdlIHByb2NoZSBkdSBzcGVjdHJlIMOpbGVjdHJvbWFnbsOpdGlxdWUuXCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIG11bHRpc3BlY3RyYWwgZW4gZW50csOpZS5cIixcblx0XCJAQE5EVkktQ29sb3JpemVkX1NjaWVudGlmaWMtT3V0cHV0X3RhZzBAQFwiOiBcIkxlcyB2YWxldXJzIGVuIHNvcnRpZSB2b250IGRlIC0xLjAgw6AgMS4wLCBjZSBxdWkgZXN0IHV0aWxpc8OpIGRhbnMgZGUgbm9tYnJldXNlcyBhcHBsaWNhdGlvbnMgc2NpZW50aWZpcXVlcy5cIixcblx0XCJAQE5EVkktQ29sb3JpemVkX1Zpc2libGUtQmFuZC1JRF90YWcwQEBcIjogXCJTcMOpY2lmaWUgbOKAmUlEIGRlIGNhbmFsIHF1aSByZXByw6lzZW50ZSBsYSBwYXJ0aWUgcm91Z2UgZHUgc3BlY3RyZSDDqWxlY3Ryb21hZ27DqXRpcXVlLlwiLFxuXHRcIkBATmVnYXRlX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBATmVnYXRlX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBOZWdhdGVfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQE5lZ2F0ZV9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATmVnYXRlX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBOZWdhdGVfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBOZWdhdGVfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBATmVnYXRlX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBOZWdhdGVfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATmVnYXRlX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBOZWdhdGVfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBOZWdhdGVfUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIGRvbnQgbCdvcHBvc8OpIGVzdCBjYWxjdWzDqSAobXVsdGlwbGljYXRpb24gcGFyIC0xKS5cIixcblx0XCJAQE5pYmJsZV9NYXNrLVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSByZXF1aXMgdXRpbGlzw6kgY29tbWUgbWFzcXVlLlwiLFxuXHRcIkBATmliYmxlX01hc2stUmFzdGVyX3RhZzFAQFwiOiBcIkxlcyBjZWxsdWxlcyBhdmVjIGxhIHZhbGV1ciBOb0RhdGEgc29udCBncmlnbm90w6llcyBkYW5zIGxlIDxzdHJvbmc+UmFzdGVyPC9zdHJvbmc+IGVuIGVudHLDqWUuXCIsXG5cdFwiQEBOaWJibGVfTWFzay1SYXN0ZXJfdGFnNEBAXCI6IFwiTGUgcmFzdGVyIGRlIG1hc3F1ZSBwZXV0IMOqdHJlIGRlIHR5cGUgZW50aWVyIG91IMOgIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcIkBATmliYmxlX05pYmJsZS1Ob0RhdGEtY2VsbHNfdGFnMEBAXCI6IFwiRMOpZmluaXQgc2kgbGVzIGNlbGx1bGVzIE5vRGF0YSBkYW5zIGxlIHJhc3RlciBlbiBlbnRyw6llIGNvbnNlcnZlcm9udCB1bmUgdmFsZXVyIE5vRGF0YSBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBOaWJibGVfTmliYmxlLU5vRGF0YS1jZWxsc190YWcxQEBcIjogXCI8c3Ryb25nPk5vbjwvc3Ryb25nPiA6IHNww6ljaWZpZSBxdWUgbGVzIGNlbGx1bGVzIE5vRGF0YSBkdSByYXN0ZXIgZW4gZW50csOpZSByZXN0ZXJvbnQgZGUgdHlwZSBOb0RhdGEgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATmliYmxlX05pYmJsZS1Ob0RhdGEtY2VsbHNfdGFnM0BAXCI6IFwiPHN0cm9uZz5PdWk8L3N0cm9uZz4gOiBzcMOpY2lmaWUgcXVlIGxlcyBjZWxsdWxlcyBOb0RhdGEgZHUgcmFzdGVyIGVuIGVudHLDqWUgZXQgZGFucyBsZSBtYXNxdWUgcGV1dmVudCDDqnRyZSBncmlnbm90w6llcyBlbiB2YWxldXJzIGRlIGNlbGx1bGVzIGVuIHNvcnRpZSB2YWxpZGVzLlwiLFxuXHRcIkBATmliYmxlX1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSByZXF1aXMgcXVpIHNlcmEgZ3JpZ25vdMOpLlwiLFxuXHRcIkBATmliYmxlX1Jhc3Rlcl90YWcxQEBcIjogXCJMZSByYXN0ZXIgZW4gZW50csOpZSBwZXV0IMOqdHJlIHVuZSB2YWxldXIgZW50acOocmUgb3Ugw6AgdmlyZ3VsZSBmbG90dGFudGUuXCIsXG5cdFwiQEBOaWJibGVfVXNlLU5vRGF0YS12YWx1ZXMtaWYtdGhleS1hcmUtdGhlLW5lYXJlc3QtbmVpZ2hib3JfdGFnMEBAXCI6IFwiRMOpZmluaXQgc2kgbGVzIHZhbGV1cnMgJHtOb0RhdGF9IGR1IHJhc3RlciBlbiBlbnRyw6llIHBldXZlbnQgZ3JpZ25vdGVyIGxhIHpvbmUgZMOpZmluaWUgcGFyIGxlIHJhc3RlciBkZSBtYXNxdWUuXCIsXG5cdFwiQEBOaWJibGVfVXNlLU5vRGF0YS12YWx1ZXMtaWYtdGhleS1hcmUtdGhlLW5lYXJlc3QtbmVpZ2hib3JfdGFnMUBAXCI6IFwiPHN0cm9uZz5PdWk8L3N0cm9uZz4gOiBzcMOpY2lmaWUgcXVlIGxhIHZhbGV1ciBkdSB2b2lzaW4gbGUgcGx1cyBwcm9jaGUgc2VyYSB1dGlsaXPDqWUsIHF1ZSBjZXR0ZSB2YWxldXIgc29pdCAke05vRGF0YX0gb3UgdW5lIGF1dHJlIHZhbGV1ciBkZSBkb25uw6llcyBkYW5zIGxlIHJhc3RlciBlbiBlbnRyw6llLiBMZXMgdmFsZXVycyAke05vRGF0YX0gZGFucyBsZSByYXN0ZXIgZW4gZW50csOpZSBwZXV2ZW50IGdyaWdub3RlciBsZXMgem9uZXMgZMOpZmluaWVzIGRhbnMgbGUgbWFzcXVlIHNpIGVsbGVzIGNvbnN0aXR1ZW50IGxlIHZvaXNpbiBsZSBwbHVzIHByb2NoZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQE5pYmJsZV9Vc2UtTm9EYXRhLXZhbHVlcy1pZi10aGV5LWFyZS10aGUtbmVhcmVzdC1uZWlnaGJvcl90YWczQEBcIjogXCI8c3Ryb25nPk5vbjwvc3Ryb25nPiA6IHNww6ljaWZpZSBxdWUgc2V1bGVzIGxlcyB2YWxldXJzIGRlIGRvbm7DqWVzIHBldXZlbnQgZ3JpZ25vdGVyIGxlcyB6b25lcyBkw6lmaW5pZXMgZGFucyBsZSByYXN0ZXIgZGUgbWFzcXVlLiBMZXMgdmFsZXVycyAke05vRGF0YX0gZGFucyBsZSByYXN0ZXIgZW4gZW50csOpZSBuZSBzb250IHBhcyBhdXRvcmlzw6llcyDDoCBncmlnbm90ZXIgbGVzIHpvbmVzIGTDqWZpbmllcyBkYW5zIGxlIHJhc3RlciBkZSBtYXNxdWUsIG3Dqm1lIHNpIGVsbGVzIGNvbnN0aXR1ZW50IGxlIHZvaXNpbiBsZSBwbHVzIHByb2NoZS5cIixcblx0XCJAQE5pYmJsZV9ab25lLVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZGUgem9uZXMgZW4gZW50csOpZS5cIixcblx0XCJAQE5pYmJsZV9ab25lLVJhc3Rlcl90YWcxQEBcIjogXCJVbmUgem9uZSBjb250aWVudCB0b3V0ZXMgbGVzIGNlbGx1bGVzIGTigJl1biByYXN0ZXIgcG9zc8OpZGFudCBsYSBtw6ptZSB2YWxldXIsIHF14oCZZWxsZXMgc29pZW50IGNvbnRpZ3XDq3Mgb3Ugbm9uLiBMYSBjb3VjaGUgZGUgem9uZSBlbiBlbnRyw6llIHLDqWdpdCBsYSBmb3JtZSwgbGVzIHZhbGV1cnMgZXQgbGVzIGVtcGxhY2VtZW50cyBkZXMgem9uZXMuIExlIHJhc3RlciBkZSB6b25lcyBwZXV0IMOqdHJlIGRlIHR5cGUgZW50aWVyIG91IMOgIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcIkBATm90LUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBATm90LUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBOb3QtRXF1YWxfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQE5vdC1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATm90LUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBOb3QtRXF1YWxfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBOb3QtRXF1YWxfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBATm90LUVxdWFsX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATm90LUVxdWFsX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgcXVpIHNlcmEgY29tcGFyw6llIHBvdXIgZMOpdGVybWluZXIgbCdpbsOpZ2FsaXTDqSBhdmVjIGxhIGRldXhpw6htZSBlbnRyw6llLlwiLFxuXHRcIkBATm90LUVxdWFsX1Jhc3Rlcl90YWcxQEBcIjogXCJVbmUgdmFsZXVyIGNvbnN0YW50ZSBwZXV0IMOqdHJlIHV0aWxpc8OpZSBlbiBlbnRyw6llIHBvdXIgY2UgcGFyYW3DqHRyZSwgw6AgY29uZGl0aW9uIHF14oCZdW4gcmFzdGVyIHNvaXQgc3DDqWNpZmnDqSBwb3VyIGzigJlhdXRyZSBwYXJhbcOodHJlLlwiLFxuXHRcIkBATm90LUVxdWFsX1Jhc3RlcjJfdGFnMEBAXCI6IFwiRW50csOpZSBxdWkgc2VyYSBjb21wYXLDqWUgw6AgbGEgcHJlbWnDqHJlIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBsJ2luw6lnYWxpdMOpLlwiLFxuXHRcIkBATm90LUVxdWFsX1Jhc3RlcjJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQFBhbnNoYXJwZW5pbmdfTXVsdGlzcGVjdHJhbF90YWcwQEBcIjogXCJMZSByYXN0ZXIgbXVsdGlzcGVjdHJhbCBxdWUgdm91cyB2b3VsZXogYWZmaW5lciDDoCBs4oCZYWlkZSBkdSBjYW5hbCBwYW5jaHJvbWF0aXF1ZS5cIixcblx0XCJAQFBhbnNoYXJwZW5pbmdfUGFuY2hyb21hdGljX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBtb25vY2FuYWwgaGF1dGUgcsOpc29sdXRpb24gdXRpbGlzw6kgcG91ciBhZmZpbmVyIGxlIHJhc3RlciBtdWx0aXNwZWN0cmFsIGRlIHBsdXMgZmFpYmxlIHLDqXNvbHV0aW9uLlwiLFxuXHRcIkBAUGFuc2hhcnBlbmluZ19QYW5zaGFycGVuaW5nLVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZYWxnb3JpdGhtZSBk4oCZYWZmaW5hZ2UgcGFuY2hyb21hdGlxdWUgw6AgdXRpbGlzZXIuXCIsXG5cdFwiQEBQYW5zaGFycGVuaW5nX1BhbnNoYXJwZW5pbmctVHlwZV90YWcxQEBcIjogXCJCcm92ZXkgOiB1dGlsaXNlIGzigJlhbGdvcml0aG1lIEJyb3ZleSBiYXPDqSBzdXIgbGEgbW9kw6lsaXNhdGlvbiBzcGVjdHJhbGUgcG91ciBsYSBmdXNpb24gZGVzIGRvbm7DqWVzLlwiLFxuXHRcIkBAUGFuc2hhcnBlbmluZ19QYW5zaGFycGVuaW5nLVR5cGVfdGFnMkBAXCI6IFwiRVNSSSA6IHV0aWxpc2UgbOKAmWFsZ29yaXRobWUgRVNSSSBiYXPDqSBzdXIgbGEgbW9kw6lsaXNhdGlvbiBzcGVjdHJhbGUgcG91ciBsYSBmdXNpb24gZGVzIGRvbm7DqWVzLlwiLFxuXHRcIkBAUGFuc2hhcnBlbmluZ19QYW5zaGFycGVuaW5nLVR5cGVfdGFnM0BAXCI6IFwiR3JhbS1TY2htaWR0IDogbOKAmWFsZ29yaXRobWUgZOKAmWFmZmluYWdlIHNwZWN0cmFsIEdyYW0tU2NobWlkdCBwZXJtZXQgZOKAmWFmZmluZXIgbGVzIGRvbm7DqWVzIG11bHRpc3BlY3RyYWxlcy5cIixcblx0XCJAQFBhbnNoYXJwZW5pbmdfUGFuc2hhcnBlbmluZy1UeXBlX3RhZzRAQFwiOiBcIklIUyA6IHV0aWxpc2UgbOKAmWVzcGFjZSBkZSBjb3VsZXVyIEludGVuc2l0w6ksIFRlaW50ZSBldCBTYXR1cmF0aW9uIHBvdXIgbGEgZnVzaW9uIGRlcyBkb25uw6llcy5cIixcblx0XCJAQFBhbnNoYXJwZW5pbmdfUGFuc2hhcnBlbmluZy1UeXBlX3RhZzVAQFwiOiBcIk1veWVubmUgOiB1dGlsaXNlIGxhIHZhbGV1ciBtb3llbm5lIGVudHJlIGxlcyB2YWxldXJzIHJvdWdlLCB2ZXJ0IGV0IGJsZXUgZXQgbGEgdmFsZXVyIGR1IHBpeGVsIHBhbmNocm9tYXRpcXVlLlwiLFxuXHRcIkBAUGFuc2hhcnBlbmluZ19XZWlnaHRzX3RhZzBAQFwiOiBcIlNww6ljaWZpZXogbGVzIHBvbmTDqXJhdGlvbnMgZGVzIGNhbmF1eCByb3VnZSwgdmVydCwgYmxldSBldCBpbmZyYXJvdWdlLiBUb3V0ZXMgbGVzIHZhbGV1cnMgZG9pdmVudCDDqnRyZSBjb21wcmlzZXMgZW50cmUgMCBldCAxLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMEBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBzaW11bGUgbOKAmWF1Z21lbnRhdGlvbiBkZSBs4oCZZWZmb3J0IHBvdXIgc3VybW9udGVyIGxlcyBjb8O7dHMgYXUgZnVyIGV0IMOgIG1lc3VyZSBxdWUgbGUgY2/Du3QgY3VtdWzDqSBhdWdtZW50ZS4gSWwgcGVybWV0IGRlIG1vZMOpbGlzZXIgbGEgZmF0aWd1ZSBkdSB2b3lhZ2V1ci4gTGUgY2/Du3QgY3VtdWzDqSBjcm9pc3NhbnQgcG91ciBhdHRlaW5kcmUgdW5lIGNlbGx1bGUgZXN0IG11bHRpcGxpw6kgcGFyIGxlIHRhdXggZGUgcsOpc2lzdGFuY2UgZXQgYWpvdXTDqSBhdSBjb8O7dCBlbmdlbmRyw6kgcGFyIGxlIGTDqXBsYWNlbWVudCB2ZXJzIGxhIGNlbGx1bGUgc3VpdmFudGUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcxQEBcIjogXCJJbCBz4oCZYWdpdCBk4oCZdW5lIHZlcnNpb24gbW9kaWZpw6llIGTigJl1bmUgZm9ybXVsZSBkZSB0YXV4IGTigJlpbnTDqXLDqnQgY29tcG9zw6kgcXVpIHBlcm1ldCBkZSBjYWxjdWxlciBsZSBjb8O7dCBhcHBhcmVudCBkdSBkw6lwbGFjZW1lbnQgw6AgdHJhdmVycyB1bmUgY2VsbHVsZS4gQXZlYyBsJ2F1Z21lbnRhdGlvbiBkdSB0YXV4IGRlIHLDqXNpc3RhbmNlLCBsZSBjb8O7dCBkZXMgY2VsbHVsZXMgcXVpIHNvbnQgdmlzaXTDqWVzIHVsdMOpcmlldXJlbWVudCBzJ2FjY3Jvw650IMOpZ2FsZW1lbnQuIFBsdXMgbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBlc3QgaW1wb3J0YW50LCBwbHVzIGxlIGNvw7t0IGRlIGTDqXBsYWNlbWVudCB2ZXJzIGxhIGNlbGx1bGUgc3VpdmFudGUgYXVnbWVudGUsIGxlcXVlbCBlc3QgYWpvdXTDqSBwb3VyIGNoYXF1ZSBtb3V2ZW1lbnQgc3VpdmFudC4gUHVpc3F1ZSBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIGVzdCBzaW1pbGFpcmUgw6AgdW4gdGF1eCBjb21wb3PDqSBldCBxdeKAmWhhYml0dWVsbGVtZW50IGxlcyB2YWxldXJzIGRlIGNvw7t0IGN1bXVsw6kgc29udCB0csOocyBpbXBvcnRhbnRlcywgbm91cyBzdWdnw6lyb25zIGzigJl1dGlsaXNhdGlvbiBkZSB0YXV4IGRlIHLDqXNpc3RhbmNlIGZhaWJsZXMsIHRlbHMgcXVlIDAsMDA1IG91IGVuY29yZSBpbmbDqXJpZXVycywgc2Vsb24gbGVzIHZhbGV1cnMgZGUgY2/Du3QgY3VtdWzDqS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIkxhIHZhbGV1ciBkb2l0IMOqdHJlIHN1cMOpcmlldXJlIMOgIHrDqXJvLiBMYSBjYXBhY2l0w6kgcGFyIGTDqWZhdXQgZXN0IGxpbWl0w6llIHBhciBsZSB0cm9uw6dvbiBkdSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9DYXBhY2l0eV90YWcwQEBcIjogXCJEw6lmaW5pdCBsYSBjYXBhY2l0w6kgZGUgY2/Du3QgcG91ciBsZSB2b3lhZ2V1ciBwb3VyIHVuZSBzb3VyY2UuIExlcyBjYWxjdWxzIGRlIGNvw7t0IGNvbnRpbnVlbnQgcG91ciBjaGFxdWUgc291cmNlIGp1c3F14oCZw6AgY2UgcXVlIGxhIGNhcGFjaXTDqSBzcMOpY2lmacOpZSBzb2l0IGF0dGVpbnRlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9DYXBhY2l0eV90YWcxQEBcIjogXCJMYSB2YWxldXIgZG9pdCDDqnRyZSBzdXDDqXJpZXVyZSDDoCB6w6lyby4gTGEgY2FwYWNpdMOpIHBhciBkw6lmYXV0IGVzdCBsaW1pdMOpZSBwYXIgbGUgdHJvbsOnb24gZHUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfQ29zdC1SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgcmVxdWlzIGTDqWZpbmlzc2FudCBsZSBjb8O7dCBvdSBs4oCZaW1ww6lkYW5jZSBkZSBkw6lwbGFjZW1lbnQgcGxhbmltw6l0cmlxdWUgw6AgdHJhdmVycyBjaGFxdWUgY2VsbHVsZS4gTGEgdmFsZXVyIMOgIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlIHJlcHLDqXNlbnRlIGxlIGNvw7t0IHBhciB1bml0w6kgZGUgZGlzdGFuY2UgcG91ciBsZSBkw6lwbGFjZW1lbnQgw6AgdHJhdmVycyBjaGFxdWUgY2VsbHVsZS4gQ2hhcXVlIHZhbGV1ciBk4oCZZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlc3QgbXVsdGlwbGnDqWUgcGFyIGxhIHLDqXNvbHV0aW9uIGRlIGNlbGx1bGUgZXQgY29tcGVuc2Ugw6lnYWxlbWVudCBsZSBtb3V2ZW1lbnQgZGlhZ29uYWwgYWZpbiBk4oCZb2J0ZW5pciBsZSBjb8O7dCB0b3RhbCBkdSBwYXNzYWdlIMOgIHRyYXZlcnMgbGEgY2VsbHVsZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfQ29zdC1SYXN0ZXJfdGFnMUBAXCI6IFwiTGVzIHZhbGV1cnMgZHUgPHN0cm9uZz5SYXN0ZXIgZGUgY2/Du3Q8L3N0cm9uZz4gcGV1dmVudCDDqnRyZSBkZXMgZW50aWVycyBvdSBkZXMgbm9tYnJlcyDDoCB2aXJndWxlIGZsb3R0YW50ZSwgbWFpcyBlbGxlcyBuZSBwZXV2ZW50IHBhcyDDqnRyZSBuw6lnYXRpdmVzIG5pIG51bGxlcy5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfaG9yaXpvbnRhbGZhY3Rvcl90YWcwQEBcIjogXCI8cD5Ew6lmaW5pdCBsYSByZWxhdGlvbiBlbnRyZSBsZSBmYWN0ZXVyIGRlIGNvw7t0IGhvcml6b250YWwgZXQgbOKAmWFuZ2xlIGRlIGTDqXBsYWNlbWVudCByZWxhdGlmIGhvcml6b250YWwgKEhSTUEpLjwvcD48cD5QbHVzaWV1cnMgZmFjdGV1cnMsIGF2ZWMgbW9kaWZpY2F0ZXVycywgaWRlbnRpZmllbnQgdW4gZGlhZ3JhbW1lIGRlIGZhY3RldXJzIHZlcnRpY2F1eCBkw6lmaW5pLiBFbiBvdXRyZSwgdm91cyBwb3V2ZXogdXRpbGlzZXIgdW5lIHRhYmxlIHBvdXIgY3LDqWVyIHVuIGRpYWdyYW1tZSBwZXJzb25uYWxpc8OpLiBMZXMgZGlhZ3JhbW1lcyBwZXJtZXR0ZW50IGTigJlpZGVudGlmaWVyIGxlIGZhY3RldXIgdmVydGljYWwgdXRpbGlzw6kgcG91ciBsZSBjYWxjdWwgZHUgY2/Du3QgdG90YWwgZOKAmXVuIGTDqXBsYWNlbWVudCB2ZXJzIHVuZSBjZWxsdWxlIHZvaXNpbmUuPC9wPjxwPkRhbnMgbGVzIGV4cGxpY2F0aW9ucyBjaS1kZXNzb3VzLCBkZXV4IGFjcm9ueW1lcyBzb250IHV0aWxpc8Opc8KgOiBIRiBldCBIUk1BLiBMZSBmYWN0ZXVyIEhGIGNvcnJlc3BvbmQgYXUgZmFjdGV1ciBob3Jpem9udGFsIHF1aSByZXByw6lzZW50ZSBsYSBkaWZmaWN1bHTDqSBob3Jpem9udGFsZSByZW5jb250csOpZSBsb3JzIGTigJl1biBkw6lwbGFjZW1lbnQgZOKAmXVuZSBjZWxsdWxlIHZlcnMgbGEgc3VpdmFudGUuIEzigJlhbmdsZSBIUk1BIGNvcnJlc3BvbmQgw6AgbOKAmWFuZ2xlIGRlIGTDqXBsYWNlbWVudCByZWxhdGlmIGhvcml6b250YWwsIGxlcXVlbCByZXByw6lzZW50ZSBs4oCZYW5nbGUgZW50cmUgbGEgZGlyZWN0aW9uIGhvcml6b250YWxlIGTigJl1bmUgY2VsbHVsZSBldCBsYSBkaXJlY3Rpb24gZHUgZMOpcGxhY2VtZW50LjwvcD48cD5MZXMgdHlwZXMgZGUgPHN0cm9uZz5GYWN0ZXVyIGhvcml6b250YWw8L3N0cm9uZz4gc29udCBsZXMgc3VpdmFudHPCoDo8L3A+PHVsPjxsaT48c3Ryb25nPkJpbmFpcmU8L3N0cm9uZz7CoDogaW5kaXF1ZSBxdWUgc2kgbOKAmWFuZ2xlIEhSTUEgZXN0IGluZsOpcmlldXIgw6AgbOKAmWFuZ2xlIGTigJlpbmZsZXhpb24sIGxlIGZhY3RldXIgSEYgYSBsYSB2YWxldXIgYXNzb2Npw6llIGF1IGZhY3RldXIgesOpcm8uIERhbnMgbGUgY2FzIGNvbnRyYWlyZSwgbGUgZmFjdGV1ciBob3Jpem9udGFsIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+QXZhbnQ8L3N0cm9uZz7CoDogcHLDqWNpc2UgcXVlIHNldWwgdW4gbW91dmVtZW50IHZlcnMgbOKAmWF2YW50IGVzdCBhdXRvcmlzw6kuIEzigJlhbmdsZSBIUk1BIGRvaXQgw6p0cmUgc3Vww6lyaWV1ciBvdSDDqWdhbCDDoMKgMCBldCBpbmbDqXJpZXVyIMOgIDkwwqBkZWdyw6lzICgwICZsdDs9IEhSTUEgJmx0OyA5MCkuIFNpIGzigJlhbmdsZSBIUk1BIGVzdCBjb21wcmlzIGVudHJlwqAwIGV0IDQ1wqBkZWdyw6lzLCBsZSBmYWN0ZXVyIEhGIGRlIGxhIGNlbGx1bGUgYSBsYSB2YWxldXIgYXNzb2Npw6llIGF1IGZhY3RldXIgesOpcm8uIFNpIGzigJlhbmdsZSBIUk1BIGVzdCBzdXDDqXJpZXVyIG91IMOpZ2FsIMOgIDQ1wqBkZWdyw6lzLCBsYSB2YWxldXIgZHUgbW9kaWZpY2F0ZXVyIGRlIGxhIHZhbGV1ciBkZSBib3JkIGVzdCB1dGlsaXPDqWUuIExlIGZhY3RldXIgSEYgcG91ciB1biBhbmdsZSBIUk1BIMOpZ2FsIG91IHN1cMOpcmlldXIgw6AgOTDCoGRlZ3LDqXMgYSB1bmUgdmFsZXVyIGluZmluaWUuPC9saT48bGk+PHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBsZSBmYWN0ZXVyIEhGIGVzdCB1bmUgZm9uY3Rpb24gbGluw6lhaXJlIGRlIGzigJlhbmdsZSBIUk1BLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlIGludmVyc2U8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBsZSBmYWN0ZXVyIEhGIGVzdCB1bmUgZm9uY3Rpb24gbGluw6lhaXJlIGludmVyc2UgZGUgbOKAmWFuZ2xlIEhSTUEuPC9saT48bGk+PHN0cm9uZz5UYWJsZTwvc3Ryb25nPsKgOiBpbmRpcXVlIHF14oCZdW4gZmljaGllciBkZSB0YWJsZSBzZXJhIHV0aWxpc8OpIHBvdXIgZMOpZmluaXIgbGUgZGlhZ3JhbW1lIGRlcyBmYWN0ZXVycyBob3Jpem9udGF1eCBwZXJtZXR0YW50IGRlIGTDqXRlcm1pbmVyIGxlcyBmYWN0ZXVycyBIRi48L2xpPjwvdWw+PHA+TGVzIG1vZGlmaWNhdGV1cnMgZGVzIGZhY3RldXJzIGhvcml6b250YXV4IHNvbnQgbGVzIHN1aXZhbnRzwqA6PC9wPjx1bD48bGk+PHN0cm9uZz5GYWN0ZXVyIHrDqXJvPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxlIGZhY3RldXIgaG9yaXpvbnRhbCDDoCB1dGlsaXNlciBsb3JzcXVlIGzigJlhbmdsZSBIUk1BIGVzdCBudWwuIENlIGZhY3RldXIgcG9zaXRpb25uZSBs4oCZaW50ZXJzZWN0aW9uIGF2ZWMgbOKAmWF4ZSBkZXMgeSBkZSB0b3V0ZXMgbGVzIGZvbmN0aW9ucyBkZSBmYWN0ZXVyIGhvcml6b250YWwuPC9saT48bGk+PHN0cm9uZz5BbmdsZSBk4oCZaW5mbGV4aW9uPC9zdHJvbmc+wqA6IGTDqWZpbml0IGzigJlhbmdsZSBIUk1BIGF1LWRlbMOgIGR1cXVlbCBsZSBmYWN0ZXVyIEhGIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+UGVudGU8L3N0cm9uZz7CoDogZMOpZmluaXQgbGEgcGVudGUgZGUgbGEgbGlnbmUgZHJvaXRlIHV0aWxpc8OpZSBhdmVjIGxlcyBtb3RzLWNsw6lzIGRlIGZhY3RldXIgaG9yaXpvbnRhbCA8c3Ryb25nPkxpbsOpYWlyZTwvc3Ryb25nPiBldCA8c3Ryb25nPkxpbsOpYWlyZSBpbnZlcnNlPC9zdHJvbmc+LiBMYSBwZW50ZSBlc3Qgc3DDqWNpZmnDqWUgc291cyBmb3JtZSBk4oCZdW4gcmFwcG9ydCBkZSBsYSBoYXV0ZXVyIHN1ciBsYSBkaXN0YW5jZSBwYXJjb3VydWUgKHBhciBleGVtcGxlLCB1bmUgcGVudGUgZGUgNDXCoHBvdXIgY2VudCBjb3JyZXNwb25kIMOgwqAxLzQ1LCBsYSB2YWxldXIgaW50cm9kdWl0ZSDDqXRhbnTCoDAsMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+VmFsZXVyIGRlIGJvcmQ8L3N0cm9uZz7CoDogZMOpZmluaXQgbGUgZmFjdGV1ciBIRiBsb3JzcXVlIGzigJlhbmdsZSBIUk1BIGVzdCBzdXDDqXJpZXVyIG91IMOpZ2FsIMOgIDQ1wqBkZWdyw6lzIGV0IGluZsOpcmlldXIgw6AgOTDCoGRlZ3LDqXMgbG9yc3F1ZSBsZSBtb3QtY2zDqSBkZSBmYWN0ZXVyIGhvcml6b250YWwgPHN0cm9uZz5BdmFudDwvc3Ryb25nPiBlc3Qgc3DDqWNpZmnDqS48L2xpPjxsaT48c3Ryb25nPk5vbSBkZSBsYSB0YWJsZTwvc3Ryb25nPsKgOiBjb3JyZXNwb25kIGF1IG5vbSBkZSBsYSB0YWJsZSBkw6lmaW5pc3NhbnQgbGUgZmFjdGV1ciBIRi48L2xpPjwvdWw+XCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX0hvcml6b250YWwtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBkw6lmaW5pc3NhbnQgbGEgZGlyZWN0aW9uIGhvcml6b250YWxlIHBvdXIgY2hhcXVlIGNlbGx1bGUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX0hvcml6b250YWwtUmFzdGVyX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGR1IHJhc3RlciBkb2l2ZW50IMOqdHJlIGRlcyBlbnRpZXJzIGNvbXByaXMgZW50cmUgMCBldCAzNjAsIDAgZGVncsOpIGNvcnJlc3BvbmRhbnQgYXUgbm9yZCAodmVycyBsZSBoYXV0IGRlIGzigJnDqWNyYW4pLiBFbGxlcyBhdWdtZW50ZW50IGRhbnMgbGUgc2VucyBob3JhaXJlLiBMYSB2YWxldXIgLTEgZG9pdCDDqnRyZSBhdHRyaWJ1w6llIGF1eCBzdXJmYWNlcyBwbGFuZXMuIExlcyB2YWxldXJzIMOgIGNoYXF1ZSBlbXBsYWNlbWVudCBzZXJvbnQgdXRpbGlzw6llcyBjb25qb2ludGVtZW50IGF1IDxzdHJvbmc+RmFjdGV1ciBob3Jpem9udGFsPC9zdHJvbmc+IGFmaW4gZGUgZMOpdGVybWluZXIgbGUgY2/Du3QgaG9yaXpvbnRhbCBlbmNvdXJ1IGxvcnMgZOKAmXVuIGTDqXBsYWNlbWVudCDDoCBwYXJ0aXIgZOKAmXVuZSBjZWxsdWxlIHZlcnMgbGVzIGNlbGx1bGVzIHZvaXNpbmVzLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9NYXhpbXVtLURpc3RhbmNlX3RhZzBAQFwiOiBcIkxlIHNldWlsIHF1ZSBsZXMgdmFsZXVycyBkZSBjb8O7dCBjdW11bMOpIG5lIHBldXZlbnQgcGFzIGTDqXBhc3Nlci4gU2kgdW5lIGRpc3RhbmNlIGRlIGNvw7t0IGN1bXVsw6kgZMOpcGFzc2UgY2V0dGUgdmFsZXVyLCBsYSB2YWxldXIgZW4gc29ydGllIGRlIGzigJllbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVzdCBOb0RhdGEuIExhIGRpc3RhbmNlIG1heGltYWxlIGTDqWZpbml0IGzigJnDqXRlbmR1ZSBwb3VyIGxhcXVlbGxlIGxlcyBkaXN0YW5jZXMgZGUgY2/Du3QgY3VtdWzDqSBzb250IGNhbGN1bMOpZXMuIExhIGRpc3RhbmNlIHBhciBkw6lmYXV0IHZhIGp1c3F14oCZw6AgbOKAmcOpdGVuZHVlIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiTXVsdGlwbGljYXRldXIgw6AgYXBwbGlxdWVyIGF1eCB2YWxldXJzIGRlIGNvw7t0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzFAQFwiOiBcIkNlIHBhcmFtw6h0cmUgcGVybWV0IGRlIGNvbnRyw7RsZXIgbGUgbW9kZSBkZSBkw6lwbGFjZW1lbnQgb3UgbGEgbWFnbml0dWRlIMOgIHVuZSBzb3VyY2UuIFBsdXMgbGUgbXVsdGlwbGljYXRldXIgZXN0IMOpbGV2w6ksIHBsdXMgbGUgY2/Du3QgZGUgZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSDDoCB1bmUgYXV0cmUgZXN0IGltcG9ydGFudC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcyQEBcIjogXCJMZXMgdmFsZXVycyBkb2l2ZW50IMOqdHJlIHN1cMOpcmlldXJlcyDDoCB6w6lyby4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAxLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzNAQFwiOiBcIlZvdXMgcG91dmV6IHV0aWxpc2VyIHBvdXIgY2UgcGFyYW3DqHRyZSB1bmUgdmFsZXVyIG51bcOpcmlxdWUgKGRvdWJsZSkgb3UgdW4gY2hhbXAgZHUgPHN0cm9uZz5SYXN0ZXIgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBlbiBlbnRyw6llIHJlcXVpcyBkZXMgZW1wbGFjZW1lbnRzIHNvdXJjZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfU291cmNlLVJhc3Rlcl90YWcxQEBcIjogXCJSYXN0ZXIgcXVpIGlkZW50aWZpZSBsZXMgY2VsbHVsZXMgb3UgbGVzIGVtcGxhY2VtZW50cyDDoCBwYXJ0aXIgZGVzcXVlbHMgbGEgZGlzdGFuY2UgZGUgbW9pbmRyZSBjb8O7dCBjdW11bMOpIGVzdCBjYWxjdWzDqWUgcG91ciBjaGFxdWUgZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlbiBzb3J0aWUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1NvdXJjZS1SYXN0ZXJfdGFnMkBAXCI6IFwiSWwgcGV1dCBz4oCZYWdpciBk4oCZdW4gZW50aWVyIG91IGTigJl1biBub21icmUgw6AgdmlyZ3VsZSBmbG90dGFudGUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiQ2/Du3QgZGUgZMOpcGFydCBkdSBjYWxjdWwgZGVzIGNvw7t0cy4gQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgc3DDqWNpZmllciBsZSBjb8O7dCBmaXhlIGFzc29jacOpIMOgIHVuZSBzb3VyY2UuIFBsdXTDtHQgcXVlIGRlIGNvbW1lbmNlciBhdmVjIHVuIGNvw7t0IMOpZ2FsIMOgIDAsIGzigJlhbGdvcml0aG1lIGRlIGNvw7t0IGNvbW1lbmNlIGF2ZWMgbGEgdmFsZXVyIGTDqWZpbmllLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9TdGFydC1Db3N0X3RhZzFAQFwiOiBcIkxhIHZhbGV1ciBkb2l0IMOqdHJlIMOpZ2FsZSBvdSBzdXDDqXJpZXVyZSDDoCB6w6lyby4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAwLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9TdXJmYWNlLVJhc3Rlcl90YWcwQEBcIjogXCJVbiByYXN0ZXIgZMOpZmluaXNzYW50IGxlcyB2YWxldXJzIGQnYWx0aXR1ZGVzIMOgIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9TdXJmYWNlLVJhc3Rlcl90YWcxQEBcIjogXCJDZXMgdmFsZXVycyBwZXJtZXR0ZW50IGRlIGNhbGN1bGVyIGxhIGRpc3RhbmNlIMOgIGxhIHN1cmZhY2UgcsOpZWxsZSBxdWkgZXN0IGNvdXZlcnRlIGxvcnMgZHUgcGFzc2FnZSBkJ3VuZSBjZWxsdWxlIMOgIHVuZSBhdXRyZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfVHJhdmVsLURpcmVjdGlvbl90YWcwQEBcIjogXCJEw6lmaW5pdCBsZSBzZW5zIGR1IHZveWFnZXVyIGVuIGNhcyBk4oCZYXBwbGljYXRpb24gZHUgdGF1eCBkZSByw6lzaXN0YW5jZSBzb3VyY2UgZXQgZHUgY2/Du3QgZGUgZMOpcGFydCBzb3VyY2UuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1RyYXZlbC1EaXJlY3Rpb25fdGFnMUBAXCI6IFwiPHN0cm9uZz7DgCBwYXJ0aXIgZGUgbGEgc291cmNlPC9zdHJvbmc+IDogbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBzb3VyY2UgZXQgbGUgY2/Du3QgZGUgZMOpcGFydCBzb3VyY2Ugc29udCBhcHBsaXF1w6lzIMOgIHBhcnRpciBkZSBsYSBzb3VyY2UgZW4gZW50csOpZSBldCBlbiBzZSBkw6lwbGHDp2FudCB2ZXJzIGxlcyBjZWxsdWxlcyBub24gc291cmNlcy4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlZlcnMgbGEgc291cmNlPC9zdHJvbmc+IDogbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBzb3VyY2UgZXQgbGUgY2/Du3QgZGUgZMOpcGFydCBzb3VyY2Ugc29udCBhcHBsaXF1w6lzIMOgIHBhcnRpciBkZSBjaGFxdWUgY2VsbHVsZSBub24gc291cmNlIGV0IGVuIHJldmVuYW50IHZlcnMgbGEgc291cmNlIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1RyYXZlbC1EaXJlY3Rpb25fdGFnNUBAXCI6IFwiU3DDqWNpZmlleiBsZSBtb3QtY2zDqSA8c3Ryb25nPsOAIHBhcnRpciBkZSBsYSBzb3VyY2U8L3N0cm9uZz4gb3UgPHN0cm9uZz5WZXJzIGxhIHNvdXJjZTwvc3Ryb25nPiwgcXVpIGVzdCBhcHBsaXF1w6kgw6AgdG91dGVzIGxlcyBzb3VyY2VzLCBvdSBzcMOpY2lmaWV6IHVuIGNoYW1wIGRhbnMgbGUgPHN0cm9uZz5SYXN0ZXIgc291cmNlPC9zdHJvbmc+IHF1aSBjb250aWVudCBsZXMgbW90cy1jbMOpcyBwZXJtZXR0YW50IGTigJlpZGVudGlmaWVyIGxlIHNlbnMgZGUgZMOpcGxhY2VtZW50IHBvdXIgY2hhcXVlIHNvdXJjZS4gQ2UgY2hhbXAgZG9pdCBjb250ZW5pciBsYSBjaGHDrm5lICR7RlJPTV9TT1VSQ0V9IG91ICR7VE9fU09VUkNFfS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfdmVydGljYWxmYWN0b3JfdGFnMEBAXCI6IFwiPHA+RMOpZmluaXQgbGEgcmVsYXRpb24gZW50cmUgbGUgZmFjdGV1ciBkZSBjb8O7dCB2ZXJ0aWNhbCBldCBs4oCZYW5nbGUgZGUgZMOpcGxhY2VtZW50IHJlbGF0aWYgdmVydGljYWwgKFZSTUEpLjwvcD48cD5QbHVzaWV1cnMgZmFjdGV1cnMsIGF2ZWMgbW9kaWZpY2F0ZXVycywgaWRlbnRpZmllbnQgdW4gZGlhZ3JhbW1lIGRlIGZhY3RldXJzIHZlcnRpY2F1eCBkw6lmaW5pLiBFbiBvdXRyZSwgdm91cyBwb3V2ZXogdXRpbGlzZXIgdW5lIHRhYmxlIHBvdXIgY3LDqWVyIHVuIGRpYWdyYW1tZSBwZXJzb25uYWxpc8OpLiBMZXMgZGlhZ3JhbW1lcyBwZXJtZXR0ZW50IGTigJlpZGVudGlmaWVyIGxlIGZhY3RldXIgdmVydGljYWwgdXRpbGlzw6kgcG91ciBsZSBjYWxjdWwgZHUgY2/Du3QgdG90YWwgZOKAmXVuIGTDqXBsYWNlbWVudCB2ZXJzIHVuZSBjZWxsdWxlIHZvaXNpbmUuPC9wPjxwPkRhbnMgbGVzIGV4cGxpY2F0aW9ucyBjaS1kZXNzb3VzLCBkZXV4IGFjcm9ueW1lcyBzb250IHV0aWxpc8Opc8KgOiBWRiBldCBWUk1BLiBMZSBmYWN0ZXVyIFZGIGNvcnJlc3BvbmQgYXUgZmFjdGV1ciB2ZXJ0aWNhbCwgbGVxdWVsIHJlcHLDqXNlbnRlIGxhIGRpZmZpY3VsdMOpIHZlcnRpY2FsZSByZW5jb250csOpZSBsb3JzIGTigJl1biBkw6lwbGFjZW1lbnQgZOKAmXVuZSBjZWxsdWxlIHZlcnMgbGEgc3VpdmFudGUuIEzigJlhbmdsZSBWUk1BIGNvcnJlc3BvbmQgw6AgbOKAmWFuZ2xlIGRlIGTDqXBsYWNlbWVudCByZWxhdGlmIHZlcnRpY2FsLCBsZXF1ZWwgcmVwcsOpc2VudGUgbOKAmWFuZ2xlIGRlIGxhIHBlbnRlIGVudHJlIGxhIGNlbGx1bGUgRlJPTSAoT3JpZ2luZSksIG91IGRlIHRyYWl0ZW1lbnQsIGV0IGxhIGNlbGx1bGUgVE8gKERlc3RpbmF0aW9uKS48L3A+PHA+TGVzIHR5cGVzIGRlIDxzdHJvbmc+RmFjdGV1ciB2ZXJ0aWNhbDwvc3Ryb25nPiBzb250IGxlcyBzdWl2YW50c8KgOjwvcD48dWw+PGxpPjxzdHJvbmc+QmluYWlyZTwvc3Ryb25nPsKgOiBzcMOpY2lmaWUgcXVlIHNpIGzigJlhbmdsZSBWUk1BIGVzdCBzdXDDqXJpZXVyIMOgIGzigJlhbmdsZSBk4oCZaW5mbGV4aW9uIGluZsOpcmlldXIgZXQgaW5mw6lyaWV1ciDDoCBs4oCZYW5nbGUgZOKAmWluZmxleGlvbiBzdXDDqXJpZXVyLCBsZSBmYWN0ZXVyIFZGIGRvaXQgY29ycmVzcG9uZHJlIMOgIGxhIHZhbGV1ciBhc3NvY2nDqWUgYXUgZmFjdGV1ciB6w6lyby4gRGFucyBsZSBjYXMgY29udHJhaXJlLCBsZSBmYWN0ZXVyIHZlcnRpY2FsIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlPC9zdHJvbmc+wqA6IGluZGlxdWUgcXVlIGxlIGZhY3RldXIgVkYgZXN0IHVuZSBmb25jdGlvbiBsaW7DqWFpcmUgZGUgbOKAmWFuZ2xlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5MaW7DqWFpcmUgc3ltw6l0cmlxdWU8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gbGluw6lhaXJlIGRlIGzigJlhbmdsZSBWUk1BLCBkdSBjw7R0w6kgbsOpZ2F0aWYgb3UgZHUgY8O0dMOpIHBvc2l0aWYgZGUgbOKAmWFuZ2xlIFZSTUEsIHJlc3BlY3RpdmVtZW50LCBldCBxdWUgbGVzIGRldXggZm9uY3Rpb25zIGxpbsOpYWlyZXMgc29udCBzeW3DqXRyaXF1ZXMgcGFyIHJhcHBvcnQgw6AgbOKAmWF4ZSAoeSkgZHUgZmFjdGV1ciBWRi48L2xpPjxsaT48c3Ryb25nPkxpbsOpYWlyZSBpbnZlcnNlPC9zdHJvbmc+wqA6IGluZGlxdWUgcXVlIGxlIGZhY3RldXIgVkYgZXN0IHVuZSBmb25jdGlvbiBsaW7DqWFpcmUgaW52ZXJzZSBkZSBs4oCZYW5nbGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPkxpbsOpYWlyZSBpbnZlcnNlIHN5bcOpdHJpcXVlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBWRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBpbnZlcnNlIGRlIGzigJlhbmdsZSBWUk1BLCBkdSBjw7R0w6kgbsOpZ2F0aWYgb3UgZHUgY8O0dMOpIHBvc2l0aWYgZGUgbOKAmWFuZ2xlIFZSTUEsIHJlc3BlY3RpdmVtZW50LCBldCBxdWUgbGVzIGRldXggZm9uY3Rpb25zIGxpbsOpYWlyZXMgc29udCBzeW3DqXRyaXF1ZXMgcGFyIHJhcHBvcnQgw6AgbOKAmWF4ZSAoeSkgZHUgZmFjdGV1ciBWRi48L2xpPjxsaT48c3Ryb25nPkNvczwvc3Ryb25nPsKgOiBpZGVudGlmaWUgbGUgZmFjdGV1ciBWRiBjb21tZSB1bmUgZm9uY3Rpb24gY29zaW51c2/Dr2RhbGUgZGUgbOKAmWFuZ2xlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5TZWM8L3N0cm9uZz7CoDogaWRlbnRpZmllIGxlIGZhY3RldXIgVkYgY29tbWUgdW5lIGZvbmN0aW9uIHPDqWNhbnRlIGRlIGzigJlhbmdsZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+Q29zLVNlYzwvc3Ryb25nPsKgOiBzcMOpY2lmaWUgcXVlIGxlIGZhY3RldXIgVkYgZXN0IHVuZSBmb25jdGlvbiBjb3NpbnVzb8OvZGFsZSBkZSBs4oCZYW5nbGUgVlJNQSBsb3JzcXVlIGNlIGRlcm5pZXIgZXN0IG7DqWdhdGlmIGV0IHF14oCZaWwgZXN0IHVuZSBmb25jdGlvbiBzw6ljYW50ZSBkZSBs4oCZYW5nbGUgVlJNQSBsb3JzcXVlIGNlIGRlcm5pZXIgbuKAmWVzdCBwYXMgbsOpZ2F0aWYuPC9saT48bGk+PHN0cm9uZz5TZWMtQ29zPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBWRiBlc3QgdW5lIGZvbmN0aW9uIHPDqWNhbnRlIGRlIGzigJlhbmdsZSBWUk1BIGxvcnNxdWUgY2UgZGVybmllciBlc3QgbsOpZ2F0aWYgZXQgcXXigJlpbCBlc3QgdW5lIGZvbmN0aW9uIGNvc2ludXNvw69kYWxlIGRlIGzigJlhbmdsZSBWUk1BIGxvcnNxdWUgY2UgZGVybmllciBu4oCZZXN0IHBhcyBuw6lnYXRpZi48L2xpPjxsaT48c3Ryb25nPlRhYmxlPC9zdHJvbmc+wqA6IGluZGlxdWUgcXXigJl1biBmaWNoaWVyIGRlIHRhYmxlIHNlcmEgdXRpbGlzw6kgcG91ciBkw6lmaW5pciBsZSBkaWFncmFtbWUgZGVzIGZhY3RldXJzIHZlcnRpY2F1eCBwZXJtZXR0YW50IGRlIGTDqXRlcm1pbmVyIGxlcyBmYWN0ZXVycyBWRi48L2xpPjwvdWw+PHA+TGVzIG1vZGlmaWNhdGV1cnMgZGVzIG1vdHMtY2zDqXMgZGUgZmFjdGV1ciB2ZXJ0aWNhbCBzb250IGxlcyBzdWl2YW50c8KgOjwvcD48dWw+PGxpPjxzdHJvbmc+RmFjdGV1ciB6w6lybzwvc3Ryb25nPsKgOiBkw6lmaW5pdCBsZSBmYWN0ZXVyIHZlcnRpY2FsIHV0aWxpc8OpIGxvcnNxdWUgbOKAmWFuZ2xlIFZSTUEgZXN0IG51bC4gQ2UgZmFjdGV1ciBwb3NpdGlvbm5lIGzigJlpbnRlcnNlY3Rpb24gYXZlYyBs4oCZYXhlIGRlcyB5IGRlIGxhIGZvbmN0aW9uIHNww6ljaWZpw6llLiBQYXIgZMOpZmluaXRpb24sIGxlIGZhY3RldXIgesOpcm8gbmUgc+KAmWFwcGxpcXVlIMOgIGF1Y3VuZSBmb25jdGlvbiB2ZXJ0aWNhbGUgdHJpZ29ub23DqXRyaXF1ZSAoQ09TLCBTRUMsIENPUy1TRUMgb3UgU0VDLUNPUykuIENlcyBmb25jdGlvbnMgZMOpZmluaXNzZW50IGzigJlpbnRlcmNlcHRpb24gZGUgbOKAmWF4ZSBkZXMgeS48L2xpPjxsaT48c3Ryb25nPkFuZ2xlIGTigJlpbmZsZXhpb24gaW5mw6lyaWV1cjwvc3Ryb25nPsKgOiBkw6lmaW5pdCBs4oCZYW5nbGUgVlJNQSBlbiBkZXNzb3VzIGR1cXVlbCBsZSBmYWN0ZXVyIFZGIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+QW5nbGUgZOKAmWluZmxleGlvbiBzdXDDqXJpZXVyPC9zdHJvbmc+wqA6IGTDqWZpbml0IGzigJlhbmdsZSBWUk1BIGF1LWRlc3N1cyBkdXF1ZWwgbGUgZmFjdGV1csKgVkYgYSB1bmUgdmFsZXVyIGluZmluaWUuPC9saT48bGk+PHN0cm9uZz5QZW50ZTwvc3Ryb25nPsKgOiBkw6lmaW5pdCBsYSBwZW50ZSBkZSBsYSBsaWduZSBkcm9pdGUgdXRpbGlzw6llIGF2ZWMgbGVzIG1vdHMtY2zDqXMgZGUgZmFjdGV1ciB2ZXJ0aWNhbCA8c3Ryb25nPkxpbsOpYWlyZTwvc3Ryb25nPiBldCA8c3Ryb25nPkxpbsOpYWlyZSBpbnZlcnNlPC9zdHJvbmc+LiBMYSBwZW50ZSBlc3Qgc3DDqWNpZmnDqWUgc291cyBmb3JtZSBk4oCZdW4gcmFwcG9ydCBkZSBsYSBoYXV0ZXVyIHN1ciBsYSBkaXN0YW5jZSBwYXJjb3VydWUgKHBhciBleGVtcGxlLCB1bmUgcGVudGUgZGUgNDXCoHBvdXIgY2VudCBjb3JyZXNwb25kIMOgwqAxLzQ1LCBsYSB2YWxldXIgaW50cm9kdWl0ZSDDqXRhbnTCoDAsMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+Tm9tIGRlIGxhIHRhYmxlPC9zdHJvbmc+wqA6IGNvcnJlc3BvbmQgYXUgbm9tIGRlIGxhIHRhYmxlIGTDqWZpbmlzc2FudCBsZSBmYWN0ZXVyIFZGLjwvbGk+PC91bD5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfVmVydGljYWwtUmFzdGVyX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxhIHJlbGF0aW9uIGVudHJlIGxlIGZhY3RldXIgZGUgY2/Du3QgdmVydGljYWwgZXQgbCdhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiB2ZXJ0aWNhbCAoVlJNQSwgdmVydGljYWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlKS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfVmVydGljYWwtUmFzdGVyX3RhZzFAQFwiOiBcIkNlcyB2YWxldXJzIHBlcm1ldHRlbnQgZGUgY2FsY3VsZXIgbGEgcGVudGUgdXRpbGlzw6llIHBvdXIgaWRlbnRpZmllciBsZSBmYWN0ZXVyIHZlcnRpY2FsIHJlbGF0aWYgYXUgZMOpcGxhY2VtZW50IGQndW5lIGNlbGx1bGUgw6AgdW5lIGF1dHJlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcwQEBcIjogXCJDZSBwYXJhbcOodHJlIHNpbXVsZSBs4oCZYXVnbWVudGF0aW9uIGRlIGzigJllZmZvcnQgcG91ciBzdXJtb250ZXIgbGVzIGNvw7t0cyBhdSBmdXIgZXQgw6AgbWVzdXJlIHF1ZSBsZSBjb8O7dCBjdW11bMOpIGF1Z21lbnRlLiBJbCBwZXJtZXQgZGUgbW9kw6lsaXNlciBsYSBmYXRpZ3VlIGR1IHZveWFnZXVyLiBMZSBjb8O7dCBjdW11bMOpIGNyb2lzc2FudCBwb3VyIGF0dGVpbmRyZSB1bmUgY2VsbHVsZSBlc3QgbXVsdGlwbGnDqSBwYXIgbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBldCBham91dMOpIGF1IGNvw7t0IGVuZ2VuZHLDqSBwYXIgbGUgZMOpcGxhY2VtZW50IHZlcnMgbGEgY2VsbHVsZSBzdWl2YW50ZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMUBAXCI6IFwiSWwgc+KAmWFnaXQgZOKAmXVuZSB2ZXJzaW9uIG1vZGlmacOpZSBk4oCZdW5lIGZvcm11bGUgZGUgdGF1eCBk4oCZaW50w6lyw6p0IGNvbXBvc8OpIHF1aSBwZXJtZXQgZGUgY2FsY3VsZXIgbGUgY2/Du3QgYXBwYXJlbnQgZHUgZMOpcGxhY2VtZW50IMOgIHRyYXZlcnMgdW5lIGNlbGx1bGUuIEF2ZWMgbCdhdWdtZW50YXRpb24gZHUgdGF1eCBkZSByw6lzaXN0YW5jZSwgbGUgY2/Du3QgZGVzIGNlbGx1bGVzIHF1aSBzb250IHZpc2l0w6llcyB1bHTDqXJpZXVyZW1lbnQgcydhY2Nyb8OudCDDqWdhbGVtZW50LiBQbHVzIGxlIHRhdXggZGUgcsOpc2lzdGFuY2UgZXN0IGltcG9ydGFudCwgcGx1cyBsZSBjb8O7dCBkZSBkw6lwbGFjZW1lbnQgdmVycyBsYSBjZWxsdWxlIHN1aXZhbnRlIGF1Z21lbnRlLCBsZXF1ZWwgZXN0IGFqb3V0w6kgcG91ciBjaGFxdWUgbW91dmVtZW50IHN1aXZhbnQuIFB1aXNxdWUgbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBlc3Qgc2ltaWxhaXJlIMOgIHVuIHRhdXggY29tcG9zw6kgZXQgcXXigJloYWJpdHVlbGxlbWVudCBsZXMgdmFsZXVycyBkZSBjb8O7dCBjdW11bMOpIHNvbnQgdHLDqHMgaW1wb3J0YW50ZXMsIG5vdXMgc3VnZ8Opcm9ucyBs4oCZdXRpbGlzYXRpb24gZGUgdGF1eCBkZSByw6lzaXN0YW5jZSBmYWlibGVzLCB0ZWxzIHF1ZSAwLDAwNSBvdSBlbmNvcmUgaW5mw6lyaWV1cnMsIHNlbG9uIGxlcyB2YWxldXJzIGRlIGNvw7t0IGN1bXVsw6kuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIkxhIHZhbGV1ciBkb2l0IMOqdHJlIHN1cMOpcmlldXJlIMOgIHrDqXJvLiBMYSBjYXBhY2l0w6kgcGFyIGTDqWZhdXQgZXN0IGxpbWl0w6llIHBhciBsZSB0cm9uw6dvbiBkdSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX0NhcGFjaXR5X3RhZzBAQFwiOiBcIkTDqWZpbml0IGxhIGNhcGFjaXTDqSBkZSBjb8O7dCBwb3VyIGxlIHZveWFnZXVyIHBvdXIgdW5lIHNvdXJjZS4gTGVzIGNhbGN1bHMgZGUgY2/Du3QgY29udGludWVudCBwb3VyIGNoYXF1ZSBzb3VyY2UganVzcXXigJnDoCBjZSBxdWUgbGEgY2FwYWNpdMOpIHNww6ljaWZpw6llIHNvaXQgYXR0ZWludGUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fQ2FwYWNpdHlfdGFnMUBAXCI6IFwiTGEgdmFsZXVyIGRvaXQgw6p0cmUgc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIGNhcGFjaXTDqSBwYXIgZMOpZmF1dCBlc3QgbGltaXTDqWUgcGFyIGxlIHRyb27Dp29uIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fQ29zdC1SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgcmVxdWlzIGTDqWZpbmlzc2FudCBsZSBjb8O7dCBvdSBs4oCZaW1ww6lkYW5jZSBkZSBkw6lwbGFjZW1lbnQgcGxhbmltw6l0cmlxdWUgw6AgdHJhdmVycyBjaGFxdWUgY2VsbHVsZS4gTGEgdmFsZXVyIMOgIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlIHJlcHLDqXNlbnRlIGxlIGNvw7t0IHBhciB1bml0w6kgZGUgZGlzdGFuY2UgcG91ciBsZSBkw6lwbGFjZW1lbnQgw6AgdHJhdmVycyBjaGFxdWUgY2VsbHVsZS4gQ2hhcXVlIHZhbGV1ciBk4oCZZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlc3QgbXVsdGlwbGnDqWUgcGFyIGxhIHLDqXNvbHV0aW9uIGRlIGNlbGx1bGUgZXQgY29tcGVuc2Ugw6lnYWxlbWVudCBsZSBtb3V2ZW1lbnQgZGlhZ29uYWwgYWZpbiBk4oCZb2J0ZW5pciBsZSBjb8O7dCB0b3RhbCBkdSBwYXNzYWdlIMOgIHRyYXZlcnMgbGEgY2VsbHVsZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9Db3N0LVJhc3Rlcl90YWcxQEBcIjogXCJMZXMgdmFsZXVycyBkdSA8c3Ryb25nPlJhc3RlciBkZSBjb8O7dDwvc3Ryb25nPiBwZXV2ZW50IMOqdHJlIGRlcyBlbnRpZXJzIG91IGRlcyBub21icmVzIMOgIHZpcmd1bGUgZmxvdHRhbnRlLCBtYWlzIGVsbGVzIG5lIHBldXZlbnQgcGFzIMOqdHJlIG7DqWdhdGl2ZXMgbmkgbnVsbGVzLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX2hvcml6b250YWxmYWN0b3JfdGFnMEBAXCI6IFwiPHA+RMOpZmluaXQgbGEgcmVsYXRpb24gZW50cmUgbGUgZmFjdGV1ciBkZSBjb8O7dCBob3Jpem9udGFsIGV0IGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiBob3Jpem9udGFsIChIUk1BKS48L3A+PHA+UGx1c2lldXJzIGZhY3RldXJzLCBhdmVjIG1vZGlmaWNhdGV1cnMsIGlkZW50aWZpZW50IHVuIGRpYWdyYW1tZSBkZSBmYWN0ZXVycyB2ZXJ0aWNhdXggZMOpZmluaS4gRW4gb3V0cmUsIHZvdXMgcG91dmV6IHV0aWxpc2VyIHVuZSB0YWJsZSBwb3VyIGNyw6llciB1biBkaWFncmFtbWUgcGVyc29ubmFsaXPDqS4gTGVzIGRpYWdyYW1tZXMgcGVybWV0dGVudCBk4oCZaWRlbnRpZmllciBsZSBmYWN0ZXVyIHZlcnRpY2FsIHV0aWxpc8OpIHBvdXIgbGUgY2FsY3VsIGR1IGNvw7t0IHRvdGFsIGTigJl1biBkw6lwbGFjZW1lbnQgdmVycyB1bmUgY2VsbHVsZSB2b2lzaW5lLjwvcD48cD5EYW5zIGxlcyBleHBsaWNhdGlvbnMgY2ktZGVzc291cywgZGV1eCBhY3JvbnltZXMgc29udCB1dGlsaXPDqXPCoDogSEYgZXQgSFJNQS4gTGUgZmFjdGV1ciBIRiBjb3JyZXNwb25kIGF1IGZhY3RldXIgaG9yaXpvbnRhbCBxdWkgcmVwcsOpc2VudGUgbGEgZGlmZmljdWx0w6kgaG9yaXpvbnRhbGUgcmVuY29udHLDqWUgbG9ycyBk4oCZdW4gZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSB2ZXJzIGxhIHN1aXZhbnRlLiBM4oCZYW5nbGUgSFJNQSBjb3JyZXNwb25kIMOgIGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiBob3Jpem9udGFsLCBsZXF1ZWwgcmVwcsOpc2VudGUgbOKAmWFuZ2xlIGVudHJlIGxhIGRpcmVjdGlvbiBob3Jpem9udGFsZSBk4oCZdW5lIGNlbGx1bGUgZXQgbGEgZGlyZWN0aW9uIGR1IGTDqXBsYWNlbWVudC48L3A+PHA+TGVzIHR5cGVzIGRlIDxzdHJvbmc+RmFjdGV1ciBob3Jpem9udGFsPC9zdHJvbmc+IHNvbnQgbGVzIHN1aXZhbnRzwqA6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5haXJlPC9zdHJvbmc+wqA6IGluZGlxdWUgcXVlIHNpIGzigJlhbmdsZSBIUk1BIGVzdCBpbmbDqXJpZXVyIMOgIGzigJlhbmdsZSBk4oCZaW5mbGV4aW9uLCBsZSBmYWN0ZXVyIEhGIGEgbGEgdmFsZXVyIGFzc29jacOpZSBhdSBmYWN0ZXVyIHrDqXJvLiBEYW5zIGxlIGNhcyBjb250cmFpcmUsIGxlIGZhY3RldXIgaG9yaXpvbnRhbCBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPkF2YW50PC9zdHJvbmc+wqA6IHByw6ljaXNlIHF1ZSBzZXVsIHVuIG1vdXZlbWVudCB2ZXJzIGzigJlhdmFudCBlc3QgYXV0b3Jpc8OpLiBM4oCZYW5nbGUgSFJNQSBkb2l0IMOqdHJlIHN1cMOpcmlldXIgb3Ugw6lnYWwgw6DCoDAgZXQgaW5mw6lyaWV1ciDDoCA5MMKgZGVncsOpcyAoMCAmbHQ7PSBIUk1BICZsdDsgOTApLiBTaSBs4oCZYW5nbGUgSFJNQSBlc3QgY29tcHJpcyBlbnRyZcKgMCBldCA0NcKgZGVncsOpcywgbGUgZmFjdGV1ciBIRiBkZSBsYSBjZWxsdWxlIGEgbGEgdmFsZXVyIGFzc29jacOpZSBhdSBmYWN0ZXVyIHrDqXJvLiBTaSBs4oCZYW5nbGUgSFJNQSBlc3Qgc3Vww6lyaWV1ciBvdSDDqWdhbCDDoCA0NcKgZGVncsOpcywgbGEgdmFsZXVyIGR1IG1vZGlmaWNhdGV1ciBkZSBsYSB2YWxldXIgZGUgYm9yZCBlc3QgdXRpbGlzw6llLiBMZSBmYWN0ZXVyIEhGIHBvdXIgdW4gYW5nbGUgSFJNQSDDqWdhbCBvdSBzdXDDqXJpZXVyIMOgIDkwwqBkZWdyw6lzIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBIRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBkZSBs4oCZYW5nbGUgSFJNQS48L2xpPjxsaT48c3Ryb25nPkxpbsOpYWlyZSBpbnZlcnNlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBIRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBpbnZlcnNlIGRlIGzigJlhbmdsZSBIUk1BLjwvbGk+PGxpPjxzdHJvbmc+VGFibGU8L3N0cm9uZz7CoDogaW5kaXF1ZSBxdeKAmXVuIGZpY2hpZXIgZGUgdGFibGUgc2VyYSB1dGlsaXPDqSBwb3VyIGTDqWZpbmlyIGxlIGRpYWdyYW1tZSBkZXMgZmFjdGV1cnMgaG9yaXpvbnRhdXggcGVybWV0dGFudCBkZSBkw6l0ZXJtaW5lciBsZXMgZmFjdGV1cnMgSEYuPC9saT48L3VsPjxwPkxlcyBtb2RpZmljYXRldXJzIGRlcyBmYWN0ZXVycyBob3Jpem9udGF1eCBzb250IGxlcyBzdWl2YW50c8KgOjwvcD48dWw+PGxpPjxzdHJvbmc+RmFjdGV1ciB6w6lybzwvc3Ryb25nPsKgOiBkw6lmaW5pdCBsZSBmYWN0ZXVyIGhvcml6b250YWwgw6AgdXRpbGlzZXIgbG9yc3F1ZSBs4oCZYW5nbGUgSFJNQSBlc3QgbnVsLiBDZSBmYWN0ZXVyIHBvc2l0aW9ubmUgbOKAmWludGVyc2VjdGlvbiBhdmVjIGzigJlheGUgZGVzIHkgZGUgdG91dGVzIGxlcyBmb25jdGlvbnMgZGUgZmFjdGV1ciBob3Jpem9udGFsLjwvbGk+PGxpPjxzdHJvbmc+QW5nbGUgZOKAmWluZmxleGlvbjwvc3Ryb25nPsKgOiBkw6lmaW5pdCBs4oCZYW5nbGUgSFJNQSBhdS1kZWzDoCBkdXF1ZWwgbGUgZmFjdGV1ciBIRiBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPlBlbnRlPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxhIHBlbnRlIGRlIGxhIGxpZ25lIGRyb2l0ZSB1dGlsaXPDqWUgYXZlYyBsZXMgbW90cy1jbMOpcyBkZSBmYWN0ZXVyIGhvcml6b250YWwgPHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz4gZXQgPHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZTwvc3Ryb25nPi4gTGEgcGVudGUgZXN0IHNww6ljaWZpw6llIHNvdXMgZm9ybWUgZOKAmXVuIHJhcHBvcnQgZGUgbGEgaGF1dGV1ciBzdXIgbGEgZGlzdGFuY2UgcGFyY291cnVlIChwYXIgZXhlbXBsZSwgdW5lIHBlbnRlIGRlIDQ1wqBwb3VyIGNlbnQgY29ycmVzcG9uZCDDoMKgMS80NSwgbGEgdmFsZXVyIGludHJvZHVpdGUgw6l0YW50wqAwLDAyMjIyKS48L2xpPjxsaT48c3Ryb25nPlZhbGV1ciBkZSBib3JkPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxlIGZhY3RldXIgSEYgbG9yc3F1ZSBs4oCZYW5nbGUgSFJNQSBlc3Qgc3Vww6lyaWV1ciBvdSDDqWdhbCDDoCA0NcKgZGVncsOpcyBldCBpbmbDqXJpZXVyIMOgIDkwwqBkZWdyw6lzIGxvcnNxdWUgbGUgbW90LWNsw6kgZGUgZmFjdGV1ciBob3Jpem9udGFsIDxzdHJvbmc+QXZhbnQ8L3N0cm9uZz4gZXN0IHNww6ljaWZpw6kuPC9saT48bGk+PHN0cm9uZz5Ob20gZGUgbGEgdGFibGU8L3N0cm9uZz7CoDogY29ycmVzcG9uZCBhdSBub20gZGUgbGEgdGFibGUgZMOpZmluaXNzYW50IGxlIGZhY3RldXIgSEYuPC9saT48L3VsPlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX0hvcml6b250YWwtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBkw6lmaW5pc3NhbnQgbGEgZGlyZWN0aW9uIGhvcml6b250YWxlIHBvdXIgY2hhcXVlIGNlbGx1bGUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fSG9yaXpvbnRhbC1SYXN0ZXJfdGFnMUBAXCI6IFwiTGVzIHZhbGV1cnMgZHUgcmFzdGVyIGRvaXZlbnQgw6p0cmUgZGVzIGVudGllcnMgY29tcHJpcyBlbnRyZSAwIGV0IDM2MCwgMCBkZWdyw6kgY29ycmVzcG9uZGFudCBhdSBub3JkICh2ZXJzIGxlIGhhdXQgZGUgbOKAmcOpY3JhbikuIEVsbGVzIGF1Z21lbnRlbnQgZGFucyBsZSBzZW5zIGhvcmFpcmUuIExhIHZhbGV1ciAtMSBkb2l0IMOqdHJlIGF0dHJpYnXDqWUgYXV4IHN1cmZhY2VzIHBsYW5lcy4gTGVzIHZhbGV1cnMgw6AgY2hhcXVlIGVtcGxhY2VtZW50IHNlcm9udCB1dGlsaXPDqWVzIGNvbmpvaW50ZW1lbnQgYXUgPHN0cm9uZz5GYWN0ZXVyIGhvcml6b250YWw8L3N0cm9uZz4gYWZpbiBkZSBkw6l0ZXJtaW5lciBsZSBjb8O7dCBob3Jpem9udGFsIGVuY291cnUgbG9ycyBk4oCZdW4gZMOpcGxhY2VtZW50IMOgIHBhcnRpciBk4oCZdW5lIGNlbGx1bGUgdmVycyBsZXMgY2VsbHVsZXMgdm9pc2luZXMuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fTWF4aW11bS1EaXN0YW5jZV90YWcwQEBcIjogXCJMZSBzZXVpbCBxdWUgbGVzIHZhbGV1cnMgZGUgY2/Du3QgY3VtdWzDqSBuZSBwZXV2ZW50IHBhcyBkw6lwYXNzZXIuIFNpIHVuZSBkaXN0YW5jZSBkZSBjb8O7dCBjdW11bMOpIGTDqXBhc3NlIGNldHRlIHZhbGV1ciwgbGEgdmFsZXVyIGVuIHNvcnRpZSBkZSBs4oCZZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlc3QgTm9EYXRhLiBMYSBkaXN0YW5jZSBtYXhpbWFsZSBkw6lmaW5pdCBs4oCZw6l0ZW5kdWUgcG91ciBsYXF1ZWxsZSBsZXMgZGlzdGFuY2VzIGRlIGNvw7t0IGN1bXVsw6kgc29udCBjYWxjdWzDqWVzLiBMYSBkaXN0YW5jZSBwYXIgZMOpZmF1dCB2YSBqdXNxdeKAmcOgIGzigJnDqXRlbmR1ZSBkdSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiTXVsdGlwbGljYXRldXIgw6AgYXBwbGlxdWVyIGF1eCB2YWxldXJzIGRlIGNvw7t0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMUBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgY29udHLDtGxlciBsZSBtb2RlIGRlIGTDqXBsYWNlbWVudCBvdSBsYSBtYWduaXR1ZGUgw6AgdW5lIHNvdXJjZS4gUGx1cyBsZSBtdWx0aXBsaWNhdGV1ciBlc3Qgw6lsZXbDqSwgcGx1cyBsZSBjb8O7dCBkZSBkw6lwbGFjZW1lbnQgZOKAmXVuZSBjZWxsdWxlIMOgIHVuZSBhdXRyZSBlc3QgaW1wb3J0YW50LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMkBAXCI6IFwiTGVzIHZhbGV1cnMgZG9pdmVudCDDqnRyZSBzdXDDqXJpZXVyZXMgw6AgesOpcm8uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzNAQFwiOiBcIlZvdXMgcG91dmV6IHV0aWxpc2VyIHBvdXIgY2UgcGFyYW3DqHRyZSB1bmUgdmFsZXVyIG51bcOpcmlxdWUgKGRvdWJsZSkgb3UgdW4gY2hhbXAgZHUgPHN0cm9uZz5SYXN0ZXIgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1NvdXJjZS1GaWVsZF90YWcwQEBcIjogXCJDaGFtcCBwZXJtZXR0YW50IGTigJlhdHRyaWJ1ZXIgZGVzIHZhbGV1cnMgYXV4IGVtcGxhY2VtZW50cyBzb3VyY2VzLiBJbCBkb2l0IMOqdHJlIGRlIHR5cGUgZW50aWVyLiBTaSBsZSA8c3Ryb25nPlJhc3RlciBkZSB2YWxldXI8L3N0cm9uZz4gYSDDqXTDqSBkw6lmaW5pLCBsZXMgdmFsZXVycyBkYW5zIGNldHRlIGVudHLDqWUgc29udCBwcmlvcml0YWlyZXMgc3VyIHRvdXQgcGFyYW3DqHRyZSBkdSA8c3Ryb25nPkNoYW1wIHNvdXJjZTwvc3Ryb25nPi5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBlbiBlbnRyw6llIHJlcXVpcyBkZXMgZW1wbGFjZW1lbnRzIHNvdXJjZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzFAQFwiOiBcIlJhc3RlciBxdWkgaWRlbnRpZmllIGxlcyBjZWxsdWxlcyBvdSBsZXMgZW1wbGFjZW1lbnRzIMOgIHBhcnRpciBkZXNxdWVscyBsYSBkaXN0YW5jZSBkZSBtb2luZHJlIGNvw7t0IGN1bXVsw6kgZXN0IGNhbGN1bMOpZSBwb3VyIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVuIHNvcnRpZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzJAQFwiOiBcIklsIHBldXQgc+KAmWFnaXIgZOKAmXVuIGVudGllciBvdSBk4oCZdW4gbm9tYnJlIMOgIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiQ2/Du3QgZGUgZMOpcGFydCBkdSBjYWxjdWwgZGVzIGNvw7t0cy4gQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgc3DDqWNpZmllciBsZSBjb8O7dCBmaXhlIGFzc29jacOpIMOgIHVuZSBzb3VyY2UuIFBsdXTDtHQgcXVlIGRlIGNvbW1lbmNlciBhdmVjIHVuIGNvw7t0IMOpZ2FsIMOgIDAsIGzigJlhbGdvcml0aG1lIGRlIGNvw7t0IGNvbW1lbmNlIGF2ZWMgbGEgdmFsZXVyIGTDqWZpbmllLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1N0YXJ0LUNvc3RfdGFnMUBAXCI6IFwiTGEgdmFsZXVyIGRvaXQgw6p0cmUgw6lnYWxlIG91IHN1cMOpcmlldXJlIMOgIHrDqXJvLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDAuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fU3VyZmFjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGTDqWZpbmlzc2FudCBsZXMgdmFsZXVycyBkJ2FsdGl0dWRlcyDDoCBjaGFxdWUgZW1wbGFjZW1lbnQgZGUgY2VsbHVsZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9TdXJmYWNlLVJhc3Rlcl90YWcxQEBcIjogXCJDZXMgdmFsZXVycyBwZXJtZXR0ZW50IGRlIGNhbGN1bGVyIGxhIGRpc3RhbmNlIMOgIGxhIHN1cmZhY2UgcsOpZWxsZSBxdWkgZXN0IGNvdXZlcnRlIGxvcnMgZHUgcGFzc2FnZSBkJ3VuZSBjZWxsdWxlIMOgIHVuZSBhdXRyZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxlIHNlbnMgZHUgdm95YWdldXIgZW4gY2FzIGTigJlhcHBsaWNhdGlvbiBkdSB0YXV4IGRlIHLDqXNpc3RhbmNlIHNvdXJjZSBldCBkdSBjb8O7dCBkZSBkw6lwYXJ0IHNvdXJjZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+w4AgcGFydGlyIGRlIGxhIHNvdXJjZTwvc3Ryb25nPiA6IGxlIHRhdXggZGUgcsOpc2lzdGFuY2Ugc291cmNlIGV0IGxlIGNvw7t0IGRlIGTDqXBhcnQgc291cmNlIHNvbnQgYXBwbGlxdcOpcyDDoCBwYXJ0aXIgZGUgbGEgc291cmNlIGVuIGVudHLDqWUgZXQgZW4gc2UgZMOpcGxhw6dhbnQgdmVycyBsZXMgY2VsbHVsZXMgbm9uIHNvdXJjZXMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlZlcnMgbGEgc291cmNlPC9zdHJvbmc+IDogbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBzb3VyY2UgZXQgbGUgY2/Du3QgZGUgZMOpcGFydCBzb3VyY2Ugc29udCBhcHBsaXF1w6lzIMOgIHBhcnRpciBkZSBjaGFxdWUgY2VsbHVsZSBub24gc291cmNlIGV0IGVuIHJldmVuYW50IHZlcnMgbGEgc291cmNlIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fVHJhdmVsLURpcmVjdGlvbl90YWc1QEBcIjogXCJTcMOpY2lmaWV6IGxlIG1vdC1jbMOpIDxzdHJvbmc+w4AgcGFydGlyIGRlIGxhIHNvdXJjZTwvc3Ryb25nPiBvdSA8c3Ryb25nPlZlcnMgbGEgc291cmNlPC9zdHJvbmc+LCBxdWkgZXN0IGFwcGxpcXXDqSDDoCB0b3V0ZXMgbGVzIHNvdXJjZXMsIG91IHNww6ljaWZpZXogdW4gY2hhbXAgZGFucyBsZSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4gcXVpIGNvbnRpZW50IGxlcyBtb3RzLWNsw6lzIHBlcm1ldHRhbnQgZOKAmWlkZW50aWZpZXIgbGUgc2VucyBkZSBkw6lwbGFjZW1lbnQgcG91ciBjaGFxdWUgc291cmNlLiBDZSBjaGFtcCBkb2l0IGNvbnRlbmlyIGxhIGNoYcOubmUgJHtGUk9NX1NPVVJDRX0gb3UgJHtUT19TT1VSQ0V9LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1ZhbHVlLVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZOKAmWVudGllcnMgZW4gZW50csOpZSBxdWkgaWRlbnRpZmllIGxlcyB2YWxldXJzIGRlIHpvbmUgw6AgdXRpbGlzZXIgcG91ciBjaGFxdWUgZW1wbGFjZW1lbnQgc291cmNlIGVuIGVudHLDqWUuIFBvdXIgY2hhcXVlIGNlbGx1bGUgZOKAmWVtcGxhY2VtZW50IHNvdXJjZSwgbGEgdmFsZXVyIGTDqWZpbmllIHBhciBsZSA8c3Ryb25nPlJhc3RlciBkZSB2YWxldXI8L3N0cm9uZz4gZXN0IGF0dHJpYnXDqWUgw6AgdG91dGVzIGxlcyBjZWxsdWxlcyBhbGxvdcOpZXMgw6AgbOKAmWVtcGxhY2VtZW50IHNvdXJjZSBwb3VyIGxlIGNhbGN1bC4gTGUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyPC9zdHJvbmc+IGVzdCBwcmlvcml0YWlyZSBzdXIgdG91dCBwYXJhbcOodHJlIGR1IDxzdHJvbmc+Q2hhbXAgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX3ZlcnRpY2FsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkTDqWZpbml0IGxhIHJlbGF0aW9uIGVudHJlIGxlIGZhY3RldXIgZGUgY2/Du3QgdmVydGljYWwgZXQgbOKAmWFuZ2xlIGRlIGTDqXBsYWNlbWVudCByZWxhdGlmIHZlcnRpY2FsIChWUk1BKS48L3A+PHA+UGx1c2lldXJzIGZhY3RldXJzLCBhdmVjIG1vZGlmaWNhdGV1cnMsIGlkZW50aWZpZW50IHVuIGRpYWdyYW1tZSBkZSBmYWN0ZXVycyB2ZXJ0aWNhdXggZMOpZmluaS4gRW4gb3V0cmUsIHZvdXMgcG91dmV6IHV0aWxpc2VyIHVuZSB0YWJsZSBwb3VyIGNyw6llciB1biBkaWFncmFtbWUgcGVyc29ubmFsaXPDqS4gTGVzIGRpYWdyYW1tZXMgcGVybWV0dGVudCBk4oCZaWRlbnRpZmllciBsZSBmYWN0ZXVyIHZlcnRpY2FsIHV0aWxpc8OpIHBvdXIgbGUgY2FsY3VsIGR1IGNvw7t0IHRvdGFsIGTigJl1biBkw6lwbGFjZW1lbnQgdmVycyB1bmUgY2VsbHVsZSB2b2lzaW5lLjwvcD48cD5EYW5zIGxlcyBleHBsaWNhdGlvbnMgY2ktZGVzc291cywgZGV1eCBhY3JvbnltZXMgc29udCB1dGlsaXPDqXPCoDogVkYgZXQgVlJNQS4gTGUgZmFjdGV1ciBWRiBjb3JyZXNwb25kIGF1IGZhY3RldXIgdmVydGljYWwsIGxlcXVlbCByZXByw6lzZW50ZSBsYSBkaWZmaWN1bHTDqSB2ZXJ0aWNhbGUgcmVuY29udHLDqWUgbG9ycyBk4oCZdW4gZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSB2ZXJzIGxhIHN1aXZhbnRlLiBM4oCZYW5nbGUgVlJNQSBjb3JyZXNwb25kIMOgIGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiB2ZXJ0aWNhbCwgbGVxdWVsIHJlcHLDqXNlbnRlIGzigJlhbmdsZSBkZSBsYSBwZW50ZSBlbnRyZSBsYSBjZWxsdWxlIEZST00gKE9yaWdpbmUpLCBvdSBkZSB0cmFpdGVtZW50LCBldCBsYSBjZWxsdWxlIFRPIChEZXN0aW5hdGlvbikuPC9wPjxwPkxlcyB0eXBlcyBkZSA8c3Ryb25nPkZhY3RldXIgdmVydGljYWw8L3N0cm9uZz4gc29udCBsZXMgc3VpdmFudHPCoDo8L3A+PHVsPjxsaT48c3Ryb25nPkJpbmFpcmU8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBzaSBs4oCZYW5nbGUgVlJNQSBlc3Qgc3Vww6lyaWV1ciDDoCBs4oCZYW5nbGUgZOKAmWluZmxleGlvbiBpbmbDqXJpZXVyIGV0IGluZsOpcmlldXIgw6AgbOKAmWFuZ2xlIGTigJlpbmZsZXhpb24gc3Vww6lyaWV1ciwgbGUgZmFjdGV1ciBWRiBkb2l0IGNvcnJlc3BvbmRyZSDDoCBsYSB2YWxldXIgYXNzb2Npw6llIGF1IGZhY3RldXIgesOpcm8uIERhbnMgbGUgY2FzIGNvbnRyYWlyZSwgbGUgZmFjdGV1ciB2ZXJ0aWNhbCBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPkxpbsOpYWlyZTwvc3Ryb25nPsKgOiBpbmRpcXVlIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gbGluw6lhaXJlIGRlIGzigJlhbmdsZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlIHN5bcOpdHJpcXVlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBWRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBkZSBs4oCZYW5nbGUgVlJNQSwgZHUgY8O0dMOpIG7DqWdhdGlmIG91IGR1IGPDtHTDqSBwb3NpdGlmIGRlIGzigJlhbmdsZSBWUk1BLCByZXNwZWN0aXZlbWVudCwgZXQgcXVlIGxlcyBkZXV4IGZvbmN0aW9ucyBsaW7DqWFpcmVzIHNvbnQgc3ltw6l0cmlxdWVzIHBhciByYXBwb3J0IMOgIGzigJlheGUgKHkpIGR1IGZhY3RldXIgVkYuPC9saT48bGk+PHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZTwvc3Ryb25nPsKgOiBpbmRpcXVlIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gbGluw6lhaXJlIGludmVyc2UgZGUgbOKAmWFuZ2xlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZSBzeW3DqXRyaXF1ZTwvc3Ryb25nPsKgOiBzcMOpY2lmaWUgcXVlIGxlIGZhY3RldXIgVkYgZXN0IHVuZSBmb25jdGlvbiBsaW7DqWFpcmUgaW52ZXJzZSBkZSBs4oCZYW5nbGUgVlJNQSwgZHUgY8O0dMOpIG7DqWdhdGlmIG91IGR1IGPDtHTDqSBwb3NpdGlmIGRlIGzigJlhbmdsZSBWUk1BLCByZXNwZWN0aXZlbWVudCwgZXQgcXVlIGxlcyBkZXV4IGZvbmN0aW9ucyBsaW7DqWFpcmVzIHNvbnQgc3ltw6l0cmlxdWVzIHBhciByYXBwb3J0IMOgIGzigJlheGUgKHkpIGR1IGZhY3RldXIgVkYuPC9saT48bGk+PHN0cm9uZz5Db3M8L3N0cm9uZz7CoDogaWRlbnRpZmllIGxlIGZhY3RldXIgVkYgY29tbWUgdW5lIGZvbmN0aW9uIGNvc2ludXNvw69kYWxlIGRlIGzigJlhbmdsZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+U2VjPC9zdHJvbmc+wqA6IGlkZW50aWZpZSBsZSBmYWN0ZXVyIFZGIGNvbW1lIHVuZSBmb25jdGlvbiBzw6ljYW50ZSBkZSBs4oCZYW5nbGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPkNvcy1TZWM8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gY29zaW51c2/Dr2RhbGUgZGUgbOKAmWFuZ2xlIFZSTUEgbG9yc3F1ZSBjZSBkZXJuaWVyIGVzdCBuw6lnYXRpZiBldCBxdeKAmWlsIGVzdCB1bmUgZm9uY3Rpb24gc8OpY2FudGUgZGUgbOKAmWFuZ2xlIFZSTUEgbG9yc3F1ZSBjZSBkZXJuaWVyIG7igJllc3QgcGFzIG7DqWdhdGlmLjwvbGk+PGxpPjxzdHJvbmc+U2VjLUNvczwvc3Ryb25nPsKgOiBzcMOpY2lmaWUgcXVlIGxlIGZhY3RldXIgVkYgZXN0IHVuZSBmb25jdGlvbiBzw6ljYW50ZSBkZSBs4oCZYW5nbGUgVlJNQSBsb3JzcXVlIGNlIGRlcm5pZXIgZXN0IG7DqWdhdGlmIGV0IHF14oCZaWwgZXN0IHVuZSBmb25jdGlvbiBjb3NpbnVzb8OvZGFsZSBkZSBs4oCZYW5nbGUgVlJNQSBsb3JzcXVlIGNlIGRlcm5pZXIgbuKAmWVzdCBwYXMgbsOpZ2F0aWYuPC9saT48bGk+PHN0cm9uZz5UYWJsZTwvc3Ryb25nPsKgOiBpbmRpcXVlIHF14oCZdW4gZmljaGllciBkZSB0YWJsZSBzZXJhIHV0aWxpc8OpIHBvdXIgZMOpZmluaXIgbGUgZGlhZ3JhbW1lIGRlcyBmYWN0ZXVycyB2ZXJ0aWNhdXggcGVybWV0dGFudCBkZSBkw6l0ZXJtaW5lciBsZXMgZmFjdGV1cnMgVkYuPC9saT48L3VsPjxwPkxlcyBtb2RpZmljYXRldXJzIGRlcyBtb3RzLWNsw6lzIGRlIGZhY3RldXIgdmVydGljYWwgc29udCBsZXMgc3VpdmFudHPCoDo8L3A+PHVsPjxsaT48c3Ryb25nPkZhY3RldXIgesOpcm88L3N0cm9uZz7CoDogZMOpZmluaXQgbGUgZmFjdGV1ciB2ZXJ0aWNhbCB1dGlsaXPDqSBsb3JzcXVlIGzigJlhbmdsZSBWUk1BIGVzdCBudWwuIENlIGZhY3RldXIgcG9zaXRpb25uZSBs4oCZaW50ZXJzZWN0aW9uIGF2ZWMgbOKAmWF4ZSBkZXMgeSBkZSBsYSBmb25jdGlvbiBzcMOpY2lmacOpZS4gUGFyIGTDqWZpbml0aW9uLCBsZSBmYWN0ZXVyIHrDqXJvIG5lIHPigJlhcHBsaXF1ZSDDoCBhdWN1bmUgZm9uY3Rpb24gdmVydGljYWxlIHRyaWdvbm9tw6l0cmlxdWUgKENPUywgU0VDLCBDT1MtU0VDIG91IFNFQy1DT1MpLiBDZXMgZm9uY3Rpb25zIGTDqWZpbmlzc2VudCBs4oCZaW50ZXJjZXB0aW9uIGRlIGzigJlheGUgZGVzIHkuPC9saT48bGk+PHN0cm9uZz5BbmdsZSBk4oCZaW5mbGV4aW9uIGluZsOpcmlldXI8L3N0cm9uZz7CoDogZMOpZmluaXQgbOKAmWFuZ2xlIFZSTUEgZW4gZGVzc291cyBkdXF1ZWwgbGUgZmFjdGV1ciBWRiBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPkFuZ2xlIGTigJlpbmZsZXhpb24gc3Vww6lyaWV1cjwvc3Ryb25nPsKgOiBkw6lmaW5pdCBs4oCZYW5nbGUgVlJNQSBhdS1kZXNzdXMgZHVxdWVsIGxlIGZhY3RldXLCoFZGIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+UGVudGU8L3N0cm9uZz7CoDogZMOpZmluaXQgbGEgcGVudGUgZGUgbGEgbGlnbmUgZHJvaXRlIHV0aWxpc8OpZSBhdmVjIGxlcyBtb3RzLWNsw6lzIGRlIGZhY3RldXIgdmVydGljYWwgPHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz4gZXQgPHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZTwvc3Ryb25nPi4gTGEgcGVudGUgZXN0IHNww6ljaWZpw6llIHNvdXMgZm9ybWUgZOKAmXVuIHJhcHBvcnQgZGUgbGEgaGF1dGV1ciBzdXIgbGEgZGlzdGFuY2UgcGFyY291cnVlIChwYXIgZXhlbXBsZSwgdW5lIHBlbnRlIGRlIDQ1wqBwb3VyIGNlbnQgY29ycmVzcG9uZCDDoMKgMS80NSwgbGEgdmFsZXVyIGludHJvZHVpdGUgw6l0YW50wqAwLDAyMjIyKS48L2xpPjxsaT48c3Ryb25nPk5vbSBkZSBsYSB0YWJsZTwvc3Ryb25nPsKgOiBjb3JyZXNwb25kIGF1IG5vbSBkZSBsYSB0YWJsZSBkw6lmaW5pc3NhbnQgbGUgZmFjdGV1ciBWRi48L2xpPjwvdWw+XCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fVmVydGljYWwtUmFzdGVyX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxhIHJlbGF0aW9uIGVudHJlIGxlIGZhY3RldXIgZGUgY2/Du3QgdmVydGljYWwgZXQgbCdhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiB2ZXJ0aWNhbCAoVlJNQSwgdmVydGljYWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlKS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9WZXJ0aWNhbC1SYXN0ZXJfdGFnMUBAXCI6IFwiQ2VzIHZhbGV1cnMgcGVybWV0dGVudCBkZSBjYWxjdWxlciBsYSBwZW50ZSB1dGlsaXPDqWUgcG91ciBpZGVudGlmaWVyIGxlIGZhY3RldXIgdmVydGljYWwgcmVsYXRpZiBhdSBkw6lwbGFjZW1lbnQgZCd1bmUgY2VsbHVsZSDDoCB1bmUgYXV0cmUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMEBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBzaW11bGUgbOKAmWF1Z21lbnRhdGlvbiBkZSBs4oCZZWZmb3J0IHBvdXIgc3VybW9udGVyIGxlcyBjb8O7dHMgYXUgZnVyIGV0IMOgIG1lc3VyZSBxdWUgbGUgY2/Du3QgY3VtdWzDqSBhdWdtZW50ZS4gSWwgcGVybWV0IGRlIG1vZMOpbGlzZXIgbGEgZmF0aWd1ZSBkdSB2b3lhZ2V1ci4gTGUgY2/Du3QgY3VtdWzDqSBjcm9pc3NhbnQgcG91ciBhdHRlaW5kcmUgdW5lIGNlbGx1bGUgZXN0IG11bHRpcGxpw6kgcGFyIGxlIHRhdXggZGUgcsOpc2lzdGFuY2UgZXQgYWpvdXTDqSBhdSBjb8O7dCBlbmdlbmRyw6kgcGFyIGxlIGTDqXBsYWNlbWVudCB2ZXJzIGxhIGNlbGx1bGUgc3VpdmFudGUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMUBAXCI6IFwiSWwgc+KAmWFnaXQgZOKAmXVuZSB2ZXJzaW9uIG1vZGlmacOpZSBk4oCZdW5lIGZvcm11bGUgZGUgdGF1eCBk4oCZaW50w6lyw6p0IGNvbXBvc8OpIHF1aSBwZXJtZXQgZGUgY2FsY3VsZXIgbGUgY2/Du3QgYXBwYXJlbnQgZHUgZMOpcGxhY2VtZW50IMOgIHRyYXZlcnMgdW5lIGNlbGx1bGUuIEF2ZWMgbCdhdWdtZW50YXRpb24gZHUgdGF1eCBkZSByw6lzaXN0YW5jZSwgbGUgY2/Du3QgZGVzIGNlbGx1bGVzIHF1aSBzb250IHZpc2l0w6llcyB1bHTDqXJpZXVyZW1lbnQgcydhY2Nyb8OudCDDqWdhbGVtZW50LiBQbHVzIGxlIHRhdXggZGUgcsOpc2lzdGFuY2UgZXN0IGltcG9ydGFudCwgcGx1cyBsZSBjb8O7dCBkZSBkw6lwbGFjZW1lbnQgdmVycyBsYSBjZWxsdWxlIHN1aXZhbnRlIGF1Z21lbnRlLCBsZXF1ZWwgZXN0IGFqb3V0w6kgcG91ciBjaGFxdWUgbW91dmVtZW50IHN1aXZhbnQuIFB1aXNxdWUgbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBlc3Qgc2ltaWxhaXJlIMOgIHVuIHRhdXggY29tcG9zw6kgZXQgcXXigJloYWJpdHVlbGxlbWVudCBsZXMgdmFsZXVycyBkZSBjb8O7dCBjdW11bMOpIHNvbnQgdHLDqHMgaW1wb3J0YW50ZXMsIG5vdXMgc3VnZ8Opcm9ucyBs4oCZdXRpbGlzYXRpb24gZGUgdGF1eCBkZSByw6lzaXN0YW5jZSBmYWlibGVzLCB0ZWxzIHF1ZSAwLDAwNSBvdSBlbmNvcmUgaW5mw6lyaWV1cnMsIHNlbG9uIGxlcyB2YWxldXJzIGRlIGNvw7t0IGN1bXVsw6kuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMkBAXCI6IFwiTGEgdmFsZXVyIGRvaXQgw6p0cmUgc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIGNhcGFjaXTDqSBwYXIgZMOpZmF1dCBlc3QgbGltaXTDqWUgcGFyIGxlIHRyb27Dp29uIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19DYXBhY2l0eV90YWcwQEBcIjogXCJEw6lmaW5pdCBsYSBjYXBhY2l0w6kgZGUgY2/Du3QgcG91ciBsZSB2b3lhZ2V1ciBwb3VyIHVuZSBzb3VyY2UuIExlcyBjYWxjdWxzIGRlIGNvw7t0IGNvbnRpbnVlbnQgcG91ciBjaGFxdWUgc291cmNlIGp1c3F14oCZw6AgY2UgcXVlIGxhIGNhcGFjaXTDqSBzcMOpY2lmacOpZSBzb2l0IGF0dGVpbnRlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfQ2FwYWNpdHlfdGFnMUBAXCI6IFwiTGEgdmFsZXVyIGRvaXQgw6p0cmUgc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIGNhcGFjaXTDqSBwYXIgZMOpZmF1dCBlc3QgbGltaXTDqWUgcGFyIGxlIHRyb27Dp29uIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19Db3N0LVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSByZXF1aXMgZMOpZmluaXNzYW50IGxlIGNvw7t0IG91IGzigJlpbXDDqWRhbmNlIGRlIGTDqXBsYWNlbWVudCBwbGFuaW3DqXRyaXF1ZSDDoCB0cmF2ZXJzIGNoYXF1ZSBjZWxsdWxlLiBMYSB2YWxldXIgw6AgY2hhcXVlIGVtcGxhY2VtZW50IGRlIGNlbGx1bGUgcmVwcsOpc2VudGUgbGUgY2/Du3QgcGFyIHVuaXTDqSBkZSBkaXN0YW5jZSBwb3VyIGxlIGTDqXBsYWNlbWVudCDDoCB0cmF2ZXJzIGNoYXF1ZSBjZWxsdWxlLiBDaGFxdWUgdmFsZXVyIGTigJllbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVzdCBtdWx0aXBsacOpZSBwYXIgbGEgcsOpc29sdXRpb24gZGUgY2VsbHVsZSBldCBjb21wZW5zZSDDqWdhbGVtZW50IGxlIG1vdXZlbWVudCBkaWFnb25hbCBhZmluIGTigJlvYnRlbmlyIGxlIGNvw7t0IHRvdGFsIGR1IHBhc3NhZ2Ugw6AgdHJhdmVycyBsYSBjZWxsdWxlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfQ29zdC1SYXN0ZXJfdGFnMUBAXCI6IFwiTGVzIHZhbGV1cnMgZHUgPHN0cm9uZz5SYXN0ZXIgZGUgY2/Du3Q8L3N0cm9uZz4gcGV1dmVudCDDqnRyZSBkZXMgZW50aWVycyBvdSBkZXMgbm9tYnJlcyDDoCB2aXJndWxlIGZsb3R0YW50ZSwgbWFpcyBlbGxlcyBuZSBwZXV2ZW50IHBhcyDDqnRyZSBuw6lnYXRpdmVzIG5pIG51bGxlcy5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX2hvcml6b250YWxmYWN0b3JfdGFnMEBAXCI6IFwiPHA+RMOpZmluaXQgbGEgcmVsYXRpb24gZW50cmUgbGUgZmFjdGV1ciBkZSBjb8O7dCBob3Jpem9udGFsIGV0IGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiBob3Jpem9udGFsIChIUk1BKS48L3A+PHA+UGx1c2lldXJzIGZhY3RldXJzLCBhdmVjIG1vZGlmaWNhdGV1cnMsIGlkZW50aWZpZW50IHVuIGRpYWdyYW1tZSBkZSBmYWN0ZXVycyB2ZXJ0aWNhdXggZMOpZmluaS4gRW4gb3V0cmUsIHZvdXMgcG91dmV6IHV0aWxpc2VyIHVuZSB0YWJsZSBwb3VyIGNyw6llciB1biBkaWFncmFtbWUgcGVyc29ubmFsaXPDqS4gTGVzIGRpYWdyYW1tZXMgcGVybWV0dGVudCBk4oCZaWRlbnRpZmllciBsZSBmYWN0ZXVyIHZlcnRpY2FsIHV0aWxpc8OpIHBvdXIgbGUgY2FsY3VsIGR1IGNvw7t0IHRvdGFsIGTigJl1biBkw6lwbGFjZW1lbnQgdmVycyB1bmUgY2VsbHVsZSB2b2lzaW5lLjwvcD48cD5EYW5zIGxlcyBleHBsaWNhdGlvbnMgY2ktZGVzc291cywgZGV1eCBhY3JvbnltZXMgc29udCB1dGlsaXPDqXPCoDogSEYgZXQgSFJNQS4gTGUgZmFjdGV1ciBIRiBjb3JyZXNwb25kIGF1IGZhY3RldXIgaG9yaXpvbnRhbCBxdWkgcmVwcsOpc2VudGUgbGEgZGlmZmljdWx0w6kgaG9yaXpvbnRhbGUgcmVuY29udHLDqWUgbG9ycyBk4oCZdW4gZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSB2ZXJzIGxhIHN1aXZhbnRlLiBM4oCZYW5nbGUgSFJNQSBjb3JyZXNwb25kIMOgIGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiBob3Jpem9udGFsLCBsZXF1ZWwgcmVwcsOpc2VudGUgbOKAmWFuZ2xlIGVudHJlIGxhIGRpcmVjdGlvbiBob3Jpem9udGFsZSBk4oCZdW5lIGNlbGx1bGUgZXQgbGEgZGlyZWN0aW9uIGR1IGTDqXBsYWNlbWVudC48L3A+PHA+TGVzIHR5cGVzIGRlIDxzdHJvbmc+RmFjdGV1ciBob3Jpem9udGFsPC9zdHJvbmc+IHNvbnQgbGVzIHN1aXZhbnRzwqA6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5haXJlPC9zdHJvbmc+wqA6IGluZGlxdWUgcXVlIHNpIGzigJlhbmdsZSBIUk1BIGVzdCBpbmbDqXJpZXVyIMOgIGzigJlhbmdsZSBk4oCZaW5mbGV4aW9uLCBsZSBmYWN0ZXVyIEhGIGEgbGEgdmFsZXVyIGFzc29jacOpZSBhdSBmYWN0ZXVyIHrDqXJvLiBEYW5zIGxlIGNhcyBjb250cmFpcmUsIGxlIGZhY3RldXIgaG9yaXpvbnRhbCBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPkF2YW50PC9zdHJvbmc+wqA6IHByw6ljaXNlIHF1ZSBzZXVsIHVuIG1vdXZlbWVudCB2ZXJzIGzigJlhdmFudCBlc3QgYXV0b3Jpc8OpLiBM4oCZYW5nbGUgSFJNQSBkb2l0IMOqdHJlIHN1cMOpcmlldXIgb3Ugw6lnYWwgw6DCoDAgZXQgaW5mw6lyaWV1ciDDoCA5MMKgZGVncsOpcyAoMCAmbHQ7PSBIUk1BICZsdDsgOTApLiBTaSBs4oCZYW5nbGUgSFJNQSBlc3QgY29tcHJpcyBlbnRyZcKgMCBldCA0NcKgZGVncsOpcywgbGUgZmFjdGV1ciBIRiBkZSBsYSBjZWxsdWxlIGEgbGEgdmFsZXVyIGFzc29jacOpZSBhdSBmYWN0ZXVyIHrDqXJvLiBTaSBs4oCZYW5nbGUgSFJNQSBlc3Qgc3Vww6lyaWV1ciBvdSDDqWdhbCDDoCA0NcKgZGVncsOpcywgbGEgdmFsZXVyIGR1IG1vZGlmaWNhdGV1ciBkZSBsYSB2YWxldXIgZGUgYm9yZCBlc3QgdXRpbGlzw6llLiBMZSBmYWN0ZXVyIEhGIHBvdXIgdW4gYW5nbGUgSFJNQSDDqWdhbCBvdSBzdXDDqXJpZXVyIMOgIDkwwqBkZWdyw6lzIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBIRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBkZSBs4oCZYW5nbGUgSFJNQS48L2xpPjxsaT48c3Ryb25nPkxpbsOpYWlyZSBpbnZlcnNlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBIRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBpbnZlcnNlIGRlIGzigJlhbmdsZSBIUk1BLjwvbGk+PGxpPjxzdHJvbmc+VGFibGU8L3N0cm9uZz7CoDogaW5kaXF1ZSBxdeKAmXVuIGZpY2hpZXIgZGUgdGFibGUgc2VyYSB1dGlsaXPDqSBwb3VyIGTDqWZpbmlyIGxlIGRpYWdyYW1tZSBkZXMgZmFjdGV1cnMgaG9yaXpvbnRhdXggcGVybWV0dGFudCBkZSBkw6l0ZXJtaW5lciBsZXMgZmFjdGV1cnMgSEYuPC9saT48L3VsPjxwPkxlcyBtb2RpZmljYXRldXJzIGRlcyBmYWN0ZXVycyBob3Jpem9udGF1eCBzb250IGxlcyBzdWl2YW50c8KgOjwvcD48dWw+PGxpPjxzdHJvbmc+RmFjdGV1ciB6w6lybzwvc3Ryb25nPsKgOiBkw6lmaW5pdCBsZSBmYWN0ZXVyIGhvcml6b250YWwgw6AgdXRpbGlzZXIgbG9yc3F1ZSBs4oCZYW5nbGUgSFJNQSBlc3QgbnVsLiBDZSBmYWN0ZXVyIHBvc2l0aW9ubmUgbOKAmWludGVyc2VjdGlvbiBhdmVjIGzigJlheGUgZGVzIHkgZGUgdG91dGVzIGxlcyBmb25jdGlvbnMgZGUgZmFjdGV1ciBob3Jpem9udGFsLjwvbGk+PGxpPjxzdHJvbmc+QW5nbGUgZOKAmWluZmxleGlvbjwvc3Ryb25nPsKgOiBkw6lmaW5pdCBs4oCZYW5nbGUgSFJNQSBhdS1kZWzDoCBkdXF1ZWwgbGUgZmFjdGV1ciBIRiBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPlBlbnRlPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxhIHBlbnRlIGRlIGxhIGxpZ25lIGRyb2l0ZSB1dGlsaXPDqWUgYXZlYyBsZXMgbW90cy1jbMOpcyBkZSBmYWN0ZXVyIGhvcml6b250YWwgPHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz4gZXQgPHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZTwvc3Ryb25nPi4gTGEgcGVudGUgZXN0IHNww6ljaWZpw6llIHNvdXMgZm9ybWUgZOKAmXVuIHJhcHBvcnQgZGUgbGEgaGF1dGV1ciBzdXIgbGEgZGlzdGFuY2UgcGFyY291cnVlIChwYXIgZXhlbXBsZSwgdW5lIHBlbnRlIGRlIDQ1wqBwb3VyIGNlbnQgY29ycmVzcG9uZCDDoMKgMS80NSwgbGEgdmFsZXVyIGludHJvZHVpdGUgw6l0YW50wqAwLDAyMjIyKS48L2xpPjxsaT48c3Ryb25nPlZhbGV1ciBkZSBib3JkPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxlIGZhY3RldXIgSEYgbG9yc3F1ZSBs4oCZYW5nbGUgSFJNQSBlc3Qgc3Vww6lyaWV1ciBvdSDDqWdhbCDDoCA0NcKgZGVncsOpcyBldCBpbmbDqXJpZXVyIMOgIDkwwqBkZWdyw6lzIGxvcnNxdWUgbGUgbW90LWNsw6kgZGUgZmFjdGV1ciBob3Jpem9udGFsIDxzdHJvbmc+QXZhbnQ8L3N0cm9uZz4gZXN0IHNww6ljaWZpw6kuPC9saT48bGk+PHN0cm9uZz5Ob20gZGUgbGEgdGFibGU8L3N0cm9uZz7CoDogY29ycmVzcG9uZCBhdSBub20gZGUgbGEgdGFibGUgZMOpZmluaXNzYW50IGxlIGZhY3RldXIgSEYuPC9saT48L3VsPlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfSG9yaXpvbnRhbC1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGTDqWZpbmlzc2FudCBsYSBkaXJlY3Rpb24gaG9yaXpvbnRhbGUgcG91ciBjaGFxdWUgY2VsbHVsZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX0hvcml6b250YWwtUmFzdGVyX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGR1IHJhc3RlciBkb2l2ZW50IMOqdHJlIGRlcyBlbnRpZXJzIGNvbXByaXMgZW50cmUgMCBldCAzNjAsIDAgZGVncsOpIGNvcnJlc3BvbmRhbnQgYXUgbm9yZCAodmVycyBsZSBoYXV0IGRlIGzigJnDqWNyYW4pLiBFbGxlcyBhdWdtZW50ZW50IGRhbnMgbGUgc2VucyBob3JhaXJlLiBMYSB2YWxldXIgLTEgZG9pdCDDqnRyZSBhdHRyaWJ1w6llIGF1eCBzdXJmYWNlcyBwbGFuZXMuIExlcyB2YWxldXJzIMOgIGNoYXF1ZSBlbXBsYWNlbWVudCBzZXJvbnQgdXRpbGlzw6llcyBjb25qb2ludGVtZW50IGF1IDxzdHJvbmc+RmFjdGV1ciBob3Jpem9udGFsPC9zdHJvbmc+IGFmaW4gZGUgZMOpdGVybWluZXIgbGUgY2/Du3QgaG9yaXpvbnRhbCBlbmNvdXJ1IGxvcnMgZOKAmXVuIGTDqXBsYWNlbWVudCDDoCBwYXJ0aXIgZOKAmXVuZSBjZWxsdWxlIHZlcnMgbGVzIGNlbGx1bGVzIHZvaXNpbmVzLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfTWF4aW11bS1EaXN0YW5jZV90YWcwQEBcIjogXCJMZSBzZXVpbCBxdWUgbGVzIHZhbGV1cnMgZGUgY2/Du3QgY3VtdWzDqSBuZSBwZXV2ZW50IHBhcyBkw6lwYXNzZXIuIFNpIHVuZSBkaXN0YW5jZSBkZSBjb8O7dCBjdW11bMOpIGTDqXBhc3NlIGNldHRlIHZhbGV1ciwgbGEgdmFsZXVyIGVuIHNvcnRpZSBkZSBs4oCZZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlc3QgTm9EYXRhLiBMYSBkaXN0YW5jZSBtYXhpbWFsZSBkw6lmaW5pdCBs4oCZw6l0ZW5kdWUgcG91ciBsYXF1ZWxsZSBsZXMgZGlzdGFuY2VzIGRlIGNvw7t0IGN1bXVsw6kgc29udCBjYWxjdWzDqWVzLiBMYSBkaXN0YW5jZSBwYXIgZMOpZmF1dCB2YSBqdXNxdeKAmcOgIGzigJnDqXRlbmR1ZSBkdSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcwQEBcIjogXCJNdWx0aXBsaWNhdGV1ciDDoCBhcHBsaXF1ZXIgYXV4IHZhbGV1cnMgZGUgY2/Du3QuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzFAQFwiOiBcIkNlIHBhcmFtw6h0cmUgcGVybWV0IGRlIGNvbnRyw7RsZXIgbGUgbW9kZSBkZSBkw6lwbGFjZW1lbnQgb3UgbGEgbWFnbml0dWRlIMOgIHVuZSBzb3VyY2UuIFBsdXMgbGUgbXVsdGlwbGljYXRldXIgZXN0IMOpbGV2w6ksIHBsdXMgbGUgY2/Du3QgZGUgZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSDDoCB1bmUgYXV0cmUgZXN0IGltcG9ydGFudC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMkBAXCI6IFwiTGVzIHZhbGV1cnMgZG9pdmVudCDDqnRyZSBzdXDDqXJpZXVyZXMgw6AgesOpcm8uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnM0BAXCI6IFwiVm91cyBwb3V2ZXogdXRpbGlzZXIgcG91ciBjZSBwYXJhbcOodHJlIHVuZSB2YWxldXIgbnVtw6lyaXF1ZSAoZG91YmxlKSBvdSB1biBjaGFtcCBkdSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4uXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBlbiBlbnRyw6llIHJlcXVpcyBkZXMgZW1wbGFjZW1lbnRzIHNvdXJjZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1NvdXJjZS1SYXN0ZXJfdGFnMUBAXCI6IFwiUmFzdGVyIHF1aSBpZGVudGlmaWUgbGVzIGNlbGx1bGVzIG91IGxlcyBlbXBsYWNlbWVudHMgw6AgcGFydGlyIGRlc3F1ZWxzIGxhIGRpc3RhbmNlIGRlIG1vaW5kcmUgY2/Du3QgY3VtdWzDqSBlc3QgY2FsY3Vsw6llIHBvdXIgY2hhcXVlIGVtcGxhY2VtZW50IGRlIGNlbGx1bGUgZW4gc29ydGllLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfU291cmNlLVJhc3Rlcl90YWcyQEBcIjogXCJJbCBwZXV0IHPigJlhZ2lyIGTigJl1biBlbnRpZXIgb3UgZOKAmXVuIG5vbWJyZSDDoCB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiQ2/Du3QgZGUgZMOpcGFydCBkdSBjYWxjdWwgZGVzIGNvw7t0cy4gQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgc3DDqWNpZmllciBsZSBjb8O7dCBmaXhlIGFzc29jacOpIMOgIHVuZSBzb3VyY2UuIFBsdXTDtHQgcXVlIGRlIGNvbW1lbmNlciBhdmVjIHVuIGNvw7t0IMOpZ2FsIMOgIDAsIGzigJlhbGdvcml0aG1lIGRlIGNvw7t0IGNvbW1lbmNlIGF2ZWMgbGEgdmFsZXVyIGTDqWZpbmllLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfU3RhcnQtQ29zdF90YWcxQEBcIjogXCJMYSB2YWxldXIgZG9pdCDDqnRyZSDDqWdhbGUgb3Ugc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1N1cmZhY2UtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBkw6lmaW5pc3NhbnQgbGVzIHZhbGV1cnMgZCdhbHRpdHVkZXMgw6AgY2hhcXVlIGVtcGxhY2VtZW50IGRlIGNlbGx1bGUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19TdXJmYWNlLVJhc3Rlcl90YWcxQEBcIjogXCJDZXMgdmFsZXVycyBwZXJtZXR0ZW50IGRlIGNhbGN1bGVyIGxhIGRpc3RhbmNlIMOgIGxhIHN1cmZhY2UgcsOpZWxsZSBxdWkgZXN0IGNvdXZlcnRlIGxvcnMgZHUgcGFzc2FnZSBkJ3VuZSBjZWxsdWxlIMOgIHVuZSBhdXRyZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1RyYXZlbC1EaXJlY3Rpb25fdGFnMEBAXCI6IFwiRMOpZmluaXQgbGUgc2VucyBkdSB2b3lhZ2V1ciBlbiBjYXMgZOKAmWFwcGxpY2F0aW9uIGR1IHRhdXggZGUgcsOpc2lzdGFuY2Ugc291cmNlIGV0IGR1IGNvw7t0IGRlIGTDqXBhcnQgc291cmNlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfVHJhdmVsLURpcmVjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPsOAIHBhcnRpciBkZSBsYSBzb3VyY2U8L3N0cm9uZz4gOiBsZSB0YXV4IGRlIHLDqXNpc3RhbmNlIHNvdXJjZSBldCBsZSBjb8O7dCBkZSBkw6lwYXJ0IHNvdXJjZSBzb250IGFwcGxpcXXDqXMgw6AgcGFydGlyIGRlIGxhIHNvdXJjZSBlbiBlbnRyw6llIGV0IGVuIHNlIGTDqXBsYcOnYW50IHZlcnMgbGVzIGNlbGx1bGVzIG5vbiBzb3VyY2VzLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlZlcnMgbGEgc291cmNlPC9zdHJvbmc+IDogbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBzb3VyY2UgZXQgbGUgY2/Du3QgZGUgZMOpcGFydCBzb3VyY2Ugc29udCBhcHBsaXF1w6lzIMOgIHBhcnRpciBkZSBjaGFxdWUgY2VsbHVsZSBub24gc291cmNlIGV0IGVuIHJldmVuYW50IHZlcnMgbGEgc291cmNlIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19UcmF2ZWwtRGlyZWN0aW9uX3RhZzVAQFwiOiBcIlNww6ljaWZpZXogbGUgbW90LWNsw6kgPHN0cm9uZz7DgCBwYXJ0aXIgZGUgbGEgc291cmNlPC9zdHJvbmc+IG91IDxzdHJvbmc+VmVycyBsYSBzb3VyY2U8L3N0cm9uZz4sIHF1aSBlc3QgYXBwbGlxdcOpIMOgIHRvdXRlcyBsZXMgc291cmNlcywgb3Ugc3DDqWNpZmlleiB1biBjaGFtcCBkYW5zIGxlIDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPiBxdWkgY29udGllbnQgbGVzIG1vdHMtY2zDqXMgcGVybWV0dGFudCBk4oCZaWRlbnRpZmllciBsZSBzZW5zIGRlIGTDqXBsYWNlbWVudCBwb3VyIGNoYXF1ZSBzb3VyY2UuIENlIGNoYW1wIGRvaXQgY29udGVuaXIgbGEgY2hhw65uZSAke0ZST01fU09VUkNFfSBvdSAke1RPX1NPVVJDRX0uXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua192ZXJ0aWNhbGZhY3Rvcl90YWcwQEBcIjogXCI8cD5Ew6lmaW5pdCBsYSByZWxhdGlvbiBlbnRyZSBsZSBmYWN0ZXVyIGRlIGNvw7t0IHZlcnRpY2FsIGV0IGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiB2ZXJ0aWNhbCAoVlJNQSkuPC9wPjxwPlBsdXNpZXVycyBmYWN0ZXVycywgYXZlYyBtb2RpZmljYXRldXJzLCBpZGVudGlmaWVudCB1biBkaWFncmFtbWUgZGUgZmFjdGV1cnMgdmVydGljYXV4IGTDqWZpbmkuIEVuIG91dHJlLCB2b3VzIHBvdXZleiB1dGlsaXNlciB1bmUgdGFibGUgcG91ciBjcsOpZXIgdW4gZGlhZ3JhbW1lIHBlcnNvbm5hbGlzw6kuIExlcyBkaWFncmFtbWVzIHBlcm1ldHRlbnQgZOKAmWlkZW50aWZpZXIgbGUgZmFjdGV1ciB2ZXJ0aWNhbCB1dGlsaXPDqSBwb3VyIGxlIGNhbGN1bCBkdSBjb8O7dCB0b3RhbCBk4oCZdW4gZMOpcGxhY2VtZW50IHZlcnMgdW5lIGNlbGx1bGUgdm9pc2luZS48L3A+PHA+RGFucyBsZXMgZXhwbGljYXRpb25zIGNpLWRlc3NvdXMsIGRldXggYWNyb255bWVzIHNvbnQgdXRpbGlzw6lzwqA6IFZGIGV0IFZSTUEuIExlIGZhY3RldXIgVkYgY29ycmVzcG9uZCBhdSBmYWN0ZXVyIHZlcnRpY2FsLCBsZXF1ZWwgcmVwcsOpc2VudGUgbGEgZGlmZmljdWx0w6kgdmVydGljYWxlIHJlbmNvbnRyw6llIGxvcnMgZOKAmXVuIGTDqXBsYWNlbWVudCBk4oCZdW5lIGNlbGx1bGUgdmVycyBsYSBzdWl2YW50ZS4gTOKAmWFuZ2xlIFZSTUEgY29ycmVzcG9uZCDDoCBs4oCZYW5nbGUgZGUgZMOpcGxhY2VtZW50IHJlbGF0aWYgdmVydGljYWwsIGxlcXVlbCByZXByw6lzZW50ZSBs4oCZYW5nbGUgZGUgbGEgcGVudGUgZW50cmUgbGEgY2VsbHVsZSBGUk9NIChPcmlnaW5lKSwgb3UgZGUgdHJhaXRlbWVudCwgZXQgbGEgY2VsbHVsZSBUTyAoRGVzdGluYXRpb24pLjwvcD48cD5MZXMgdHlwZXMgZGUgPHN0cm9uZz5GYWN0ZXVyIHZlcnRpY2FsPC9zdHJvbmc+IHNvbnQgbGVzIHN1aXZhbnRzwqA6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5haXJlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgc2kgbOKAmWFuZ2xlIFZSTUEgZXN0IHN1cMOpcmlldXIgw6AgbOKAmWFuZ2xlIGTigJlpbmZsZXhpb24gaW5mw6lyaWV1ciBldCBpbmbDqXJpZXVyIMOgIGzigJlhbmdsZSBk4oCZaW5mbGV4aW9uIHN1cMOpcmlldXIsIGxlIGZhY3RldXIgVkYgZG9pdCBjb3JyZXNwb25kcmUgw6AgbGEgdmFsZXVyIGFzc29jacOpZSBhdSBmYWN0ZXVyIHrDqXJvLiBEYW5zIGxlIGNhcyBjb250cmFpcmUsIGxlIGZhY3RldXIgdmVydGljYWwgYSB1bmUgdmFsZXVyIGluZmluaWUuPC9saT48bGk+PHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz7CoDogaW5kaXF1ZSBxdWUgbGUgZmFjdGV1ciBWRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBkZSBs4oCZYW5nbGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPkxpbsOpYWlyZSBzeW3DqXRyaXF1ZTwvc3Ryb25nPsKgOiBzcMOpY2lmaWUgcXVlIGxlIGZhY3RldXIgVkYgZXN0IHVuZSBmb25jdGlvbiBsaW7DqWFpcmUgZGUgbOKAmWFuZ2xlIFZSTUEsIGR1IGPDtHTDqSBuw6lnYXRpZiBvdSBkdSBjw7R0w6kgcG9zaXRpZiBkZSBs4oCZYW5nbGUgVlJNQSwgcmVzcGVjdGl2ZW1lbnQsIGV0IHF1ZSBsZXMgZGV1eCBmb25jdGlvbnMgbGluw6lhaXJlcyBzb250IHN5bcOpdHJpcXVlcyBwYXIgcmFwcG9ydCDDoCBs4oCZYXhlICh5KSBkdSBmYWN0ZXVyIFZGLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlIGludmVyc2U8L3N0cm9uZz7CoDogaW5kaXF1ZSBxdWUgbGUgZmFjdGV1ciBWRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBpbnZlcnNlIGRlIGzigJlhbmdsZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlIGludmVyc2Ugc3ltw6l0cmlxdWU8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gbGluw6lhaXJlIGludmVyc2UgZGUgbOKAmWFuZ2xlIFZSTUEsIGR1IGPDtHTDqSBuw6lnYXRpZiBvdSBkdSBjw7R0w6kgcG9zaXRpZiBkZSBs4oCZYW5nbGUgVlJNQSwgcmVzcGVjdGl2ZW1lbnQsIGV0IHF1ZSBsZXMgZGV1eCBmb25jdGlvbnMgbGluw6lhaXJlcyBzb250IHN5bcOpdHJpcXVlcyBwYXIgcmFwcG9ydCDDoCBs4oCZYXhlICh5KSBkdSBmYWN0ZXVyIFZGLjwvbGk+PGxpPjxzdHJvbmc+Q29zPC9zdHJvbmc+wqA6IGlkZW50aWZpZSBsZSBmYWN0ZXVyIFZGIGNvbW1lIHVuZSBmb25jdGlvbiBjb3NpbnVzb8OvZGFsZSBkZSBs4oCZYW5nbGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPlNlYzwvc3Ryb25nPsKgOiBpZGVudGlmaWUgbGUgZmFjdGV1ciBWRiBjb21tZSB1bmUgZm9uY3Rpb24gc8OpY2FudGUgZGUgbOKAmWFuZ2xlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5Db3MtU2VjPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBWRiBlc3QgdW5lIGZvbmN0aW9uIGNvc2ludXNvw69kYWxlIGRlIGzigJlhbmdsZSBWUk1BIGxvcnNxdWUgY2UgZGVybmllciBlc3QgbsOpZ2F0aWYgZXQgcXXigJlpbCBlc3QgdW5lIGZvbmN0aW9uIHPDqWNhbnRlIGRlIGzigJlhbmdsZSBWUk1BIGxvcnNxdWUgY2UgZGVybmllciBu4oCZZXN0IHBhcyBuw6lnYXRpZi48L2xpPjxsaT48c3Ryb25nPlNlYy1Db3M8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gc8OpY2FudGUgZGUgbOKAmWFuZ2xlIFZSTUEgbG9yc3F1ZSBjZSBkZXJuaWVyIGVzdCBuw6lnYXRpZiBldCBxdeKAmWlsIGVzdCB1bmUgZm9uY3Rpb24gY29zaW51c2/Dr2RhbGUgZGUgbOKAmWFuZ2xlIFZSTUEgbG9yc3F1ZSBjZSBkZXJuaWVyIG7igJllc3QgcGFzIG7DqWdhdGlmLjwvbGk+PGxpPjxzdHJvbmc+VGFibGU8L3N0cm9uZz7CoDogaW5kaXF1ZSBxdeKAmXVuIGZpY2hpZXIgZGUgdGFibGUgc2VyYSB1dGlsaXPDqSBwb3VyIGTDqWZpbmlyIGxlIGRpYWdyYW1tZSBkZXMgZmFjdGV1cnMgdmVydGljYXV4IHBlcm1ldHRhbnQgZGUgZMOpdGVybWluZXIgbGVzIGZhY3RldXJzIFZGLjwvbGk+PC91bD48cD5MZXMgbW9kaWZpY2F0ZXVycyBkZXMgbW90cy1jbMOpcyBkZSBmYWN0ZXVyIHZlcnRpY2FsIHNvbnQgbGVzIHN1aXZhbnRzwqA6PC9wPjx1bD48bGk+PHN0cm9uZz5GYWN0ZXVyIHrDqXJvPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxlIGZhY3RldXIgdmVydGljYWwgdXRpbGlzw6kgbG9yc3F1ZSBs4oCZYW5nbGUgVlJNQSBlc3QgbnVsLiBDZSBmYWN0ZXVyIHBvc2l0aW9ubmUgbOKAmWludGVyc2VjdGlvbiBhdmVjIGzigJlheGUgZGVzIHkgZGUgbGEgZm9uY3Rpb24gc3DDqWNpZmnDqWUuIFBhciBkw6lmaW5pdGlvbiwgbGUgZmFjdGV1ciB6w6lybyBuZSBz4oCZYXBwbGlxdWUgw6AgYXVjdW5lIGZvbmN0aW9uIHZlcnRpY2FsZSB0cmlnb25vbcOpdHJpcXVlIChDT1MsIFNFQywgQ09TLVNFQyBvdSBTRUMtQ09TKS4gQ2VzIGZvbmN0aW9ucyBkw6lmaW5pc3NlbnQgbOKAmWludGVyY2VwdGlvbiBkZSBs4oCZYXhlIGRlcyB5LjwvbGk+PGxpPjxzdHJvbmc+QW5nbGUgZOKAmWluZmxleGlvbiBpbmbDqXJpZXVyPC9zdHJvbmc+wqA6IGTDqWZpbml0IGzigJlhbmdsZSBWUk1BIGVuIGRlc3NvdXMgZHVxdWVsIGxlIGZhY3RldXIgVkYgYSB1bmUgdmFsZXVyIGluZmluaWUuPC9saT48bGk+PHN0cm9uZz5BbmdsZSBk4oCZaW5mbGV4aW9uIHN1cMOpcmlldXI8L3N0cm9uZz7CoDogZMOpZmluaXQgbOKAmWFuZ2xlIFZSTUEgYXUtZGVzc3VzIGR1cXVlbCBsZSBmYWN0ZXVywqBWRiBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPlBlbnRlPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxhIHBlbnRlIGRlIGxhIGxpZ25lIGRyb2l0ZSB1dGlsaXPDqWUgYXZlYyBsZXMgbW90cy1jbMOpcyBkZSBmYWN0ZXVyIHZlcnRpY2FsIDxzdHJvbmc+TGluw6lhaXJlPC9zdHJvbmc+IGV0IDxzdHJvbmc+TGluw6lhaXJlIGludmVyc2U8L3N0cm9uZz4uIExhIHBlbnRlIGVzdCBzcMOpY2lmacOpZSBzb3VzIGZvcm1lIGTigJl1biByYXBwb3J0IGRlIGxhIGhhdXRldXIgc3VyIGxhIGRpc3RhbmNlIHBhcmNvdXJ1ZSAocGFyIGV4ZW1wbGUsIHVuZSBwZW50ZSBkZSA0NcKgcG91ciBjZW50IGNvcnJlc3BvbmQgw6DCoDEvNDUsIGxhIHZhbGV1ciBpbnRyb2R1aXRlIMOpdGFudMKgMCwwMjIyMikuPC9saT48bGk+PHN0cm9uZz5Ob20gZGUgbGEgdGFibGU8L3N0cm9uZz7CoDogY29ycmVzcG9uZCBhdSBub20gZGUgbGEgdGFibGUgZMOpZmluaXNzYW50IGxlIGZhY3RldXIgVkYuPC9saT48L3VsPlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfVmVydGljYWwtUmFzdGVyX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxhIHJlbGF0aW9uIGVudHJlIGxlIGZhY3RldXIgZGUgY2/Du3QgdmVydGljYWwgZXQgbCdhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiB2ZXJ0aWNhbCAoVlJNQSwgdmVydGljYWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlKS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1ZlcnRpY2FsLVJhc3Rlcl90YWcxQEBcIjogXCJDZXMgdmFsZXVycyBwZXJtZXR0ZW50IGRlIGNhbGN1bGVyIGxhIHBlbnRlIHV0aWxpc8OpZSBwb3VyIGlkZW50aWZpZXIgbGUgZmFjdGV1ciB2ZXJ0aWNhbCByZWxhdGlmIGF1IGTDqXBsYWNlbWVudCBkJ3VuZSBjZWxsdWxlIMOgIHVuZSBhdXRyZS5cIixcblx0XCJAQFBsdXNfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUGx1c19FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBQbHVzX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBQbHVzX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFBsdXNfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFBsdXNfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBQbHVzX1Jhc3Rlcl90YWcwQEBcIjogXCJFbnRyw6llIGRvbnQgbGVzIHZhbGV1cnMgc29udCBham91dMOpZXMuXCIsXG5cdFwiQEBQbHVzX1Jhc3Rlcl90YWcxQEBcIjogXCJVbmUgdmFsZXVyIGNvbnN0YW50ZSBwZXV0IMOqdHJlIHV0aWxpc8OpZSBlbiBlbnRyw6llIHBvdXIgY2UgcGFyYW3DqHRyZSwgw6AgY29uZGl0aW9uIHF14oCZdW4gcmFzdGVyIHNvaXQgc3DDqWNpZmnDqSBwb3VyIGzigJlhdXRyZSBwYXJhbcOodHJlLlwiLFxuXHRcIkBAUGx1c19SYXN0ZXIyX3RhZzBAQFwiOiBcIkVudHLDqWUgZG9udCBsZXMgdmFsZXVycyBzb250IGFqb3V0w6llcyDDoCBsYSBwcmVtacOocmUgZW50csOpZS5cIixcblx0XCJAQFBsdXNfUmFzdGVyMl90YWcxQEBcIjogXCJVbmUgdmFsZXVyIGNvbnN0YW50ZSBwZXV0IMOqdHJlIHV0aWxpc8OpZSBlbiBlbnRyw6llIHBvdXIgY2UgcGFyYW3DqHRyZSwgw6AgY29uZGl0aW9uIHF14oCZdW4gcmFzdGVyIHNvaXQgc3DDqWNpZmnDqSBwb3VyIGzigJlhdXRyZSBwYXJhbcOodHJlLlwiLFxuXHRcIkBATG9jYWxfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgdG91dGVzIGxlcyB0YWlsbGVzIGRlIGNlbGx1bGUgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQExvY2FsX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZcKgOiB1dGlsaXNlciBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQExvY2FsX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZcKgOiB1dGlsaXNlciBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQExvY2FsX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlwqA6IHV0aWxpc2VyIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQExvY2FsX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZcKgOiB1dGlsaXNlciBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQExvY2FsX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIGRlwqA6IHV0aWxpc2VyIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQExvY2FsX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZcKgOlwiLFxuXHRcIkBATG9jYWxfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZcKgOiB1dGlsaXNlciBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATG9jYWxfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlwqA6IHV0aWxpc2VyIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBMb2NhbF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlwqA6IHV0aWxpc2VyIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBMb2NhbF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZcKgOiB1dGlsaXNlciBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBATG9jYWxfUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgZG9udCBsZXMgdmFsZXVycyBzdWJpc3NlbnQgbOKAmWFqb3V0LlwiLFxuXHRcIkBATG9jYWxfUmFzdGVyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBMb2NhbF9SYXN0ZXIyX3RhZzBAQFwiOiBcIkVudHLDqWUgZG9udCBsZXMgdmFsZXVycyBzb250IGFqb3V0w6llcyDDoCBsYSBwcmVtacOocmUgZW50csOpZS5cIixcblx0XCJAQExvY2FsX1Jhc3RlcjJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQExvY2FsX0ZhbHNlLVJhc3Rlcl90YWcwQEBcIjogXCJFbnRyw6llIGRvbnQgbGVzIHZhbGV1cnMgc29udCB1dGlsaXPDqWVzIGVuIHRhbnQgcXVlIHZhbGV1cnMgZGUgcGl4ZWwgZW4gc29ydGllIHNpIGxhIGNvbmRpdGlvbiBlc3QgZmF1c3NlLiBJbCBwZXV0IHPigJlhZ2lyIGTigJl1biByYXN0ZXIgZGUgdHlwZSBlbnRpZXIgb3Ugw6AgdmlyZ3VsZSBmbG90dGFudGUsIG91IGTigJl1bmUgdmFsZXVyIGNvbnN0YW50ZS5cIixcblx0XCJAQExvY2FsX1RydWUtUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgZG9udCBsZXMgdmFsZXVycyBzb250IHV0aWxpc8OpZXMgZW4gdGFudCBxdWUgdmFsZXVycyBkZSBwaXhlbCBlbiBzb3J0aWUgc2kgbGEgY29uZGl0aW9uIGVzdCB2cmFpZS4gSWwgcGV1dCBz4oCZYWdpciBk4oCZdW4gcmFzdGVyIGRlIHR5cGUgZW50aWVyIG91IMOgIHZpcmd1bGUgZmxvdHRhbnRlLCBvdSBk4oCZdW5lIHZhbGV1ciBjb25zdGFudGUuXCIsXG5cdFwiQEBQb3dlcl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQFBvd2VyX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBQb3dlcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUG93ZXJfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFBvd2VyX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBQb3dlcl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFBvd2VyX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQFBvd2VyX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBQb3dlcl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBQb3dlcl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAUG93ZXJfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBQb3dlcl9SYXN0ZXJfdGFnMEBAXCI6IFwiVmFsZXVycyBlbiBlbnRyw6llIMOgIMOpbGV2ZXIgw6AgbGEgcHVpc3NhbmNlIGTDqWZpbmllIHBhciA8c3Ryb25nPlJhc3RlcjI8L3N0cm9uZz4uXCIsXG5cdFwiQEBQb3dlcl9SYXN0ZXJfdGFnM0BAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQFBvd2VyX1Jhc3RlcjJfdGFnMEBAXCI6IFwiRW50csOpZSBxdWkgZMOpdGVybWluZSBsYSBwdWlzc2FuY2Ugw6AgbGFxdWVsbGUgbGVzIHZhbGV1cnMgPHN0cm9uZz5SYXN0ZXI8L3N0cm9uZz4gc2Vyb250IMOpbGV2w6llcy5cIixcblx0XCJAQFBvd2VyX1Jhc3RlcjJfdGFnM0BAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQFJhZGFyLUNhbGlicmF0aW9uX0NhbGlicmF0aW9uLVR5cGVfdGFnMEBAXCI6IFwiVHlwZSBkZSBjYWxpYnJhZ2Ugw6AgcsOpYWxpc2VyLlwiLFxuXHRcIkBAUmFkYXItQ2FsaWJyYXRpb25fQ2FsaWJyYXRpb24tVHlwZV90YWcxQEBcIjogXCJCZXRhLW5vdWdodCAoQsOqdGEgesOpcm8pIDogbGEgZm9uY3Rpb24gcmVudm9pZSBsYSByw6lmbGVjdGl2aXTDqSBkdSByYWRhciBwYXIgdW5pdMOpIGRlIHN1cmZhY2UgZW4gZGlzdGFuY2Ugb2JsaXF1ZS4gSWwgc+KAmWFnaXQgZHUgdHlwZSBkZSBjYWxpYnJhZ2UgcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBSYWRhci1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzJAQFwiOiBcIlNpZ21hLW5vdWdodCAoU2lnbWEgesOpcm8pIDogbGEgZm9uY3Rpb24gcmVudm9pZSBsYSByw6lmbGVjdGl2aXTDqSBkdSByYWRhciBwYXIgdW5pdMOpIGRlIHN1cmZhY2UgZW4gcG9ydMOpZSBhdSBzb2wuIExlcyByw6lzdWx0YXRzIHNvbnQgZGVzIHZhbGV1cnMgw6AgdmlyZ3VsZSBmbG90dGFudGUgMzIgYml0cyBnw6luw6lyYWxlbWVudCBjb21wcmlzZXMgZW50cmUgMCwwIGV0IDEsMC4gQXVjdW4gZMOpY291cGFnZSBkZSBkb25uw6llIG4nZXN0IGVmZmVjdHXDqSBzaSBjZXR0ZSBvcHRpb24gZXN0IHPDqWxlY3Rpb25uw6llLlwiLFxuXHRcIkBAUmFkYXItQ2FsaWJyYXRpb25fQ2FsaWJyYXRpb24tVHlwZV90YWczQEBcIjogXCJHYW1tYSA6IGxhIGZvbmN0aW9uIHJlbnZvaWUgbGEgcsOpZmxlY3Rpdml0w6kgZHUgcmFkYXIgcGFyIHVuaXTDqSBkZSBzdXJmYWNlIGRhbnMgbGUgcGxhbiBwZXJwZW5kaWN1bGFpcmUgw6AgbGEgZGlyZWN0aW9uIGRlIGxhIG1lc3VyZS5cIixcblx0XCJAQFJhZGFyLUNhbGlicmF0aW9uX0NhbGlicmF0aW9uLVR5cGVfdGFnNEBAXCI6IFwiQXVjdW5cIixcblx0XCJAQFJhZGFyLUNhbGlicmF0aW9uX1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQFJhc3RlckluZm9fUmFzdGVyLUluZm9fdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiB1biBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIMOgIHV0aWxpc2VyIGNvbW1lIG1vZMOobGUuXCIsXG5cdFwiQEBSYXN0ZXJJbmZvX1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX0F0dHJpYnV0ZS1GaWVsZC1OYW1lc190YWcwQEBcIjogXCJMaXN0ZSBkZXMgY2hhbXBzIGRlIGxhIDxzdHJvbmc+VGFibGUgZGVzIGF0dHJpYnV0cyB6b25hdXg8L3N0cm9uZz4sIG/DuSBjaGFxdWUgY2hhbXAgZXN0IHPDqXBhcsOpIHBhciB1bmUgdmlyZ3VsZS4gTGVzIHZhbGV1cnMgZGFucyBjaGFxdWUgY2hhbXAgc2Vyb250IHJlcHLDqXNlbnTDqWVzIHBhciB1bmUgYmFuZGUgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfQmFja2dyb3VuZC1WYWx1ZV90YWcwQEBcIjogXCJMYSB2YWxldXIgZGUgcGl4ZWwgaW5pdGlhbGUgZGVzIGNhbmF1eCBlbiBzb3J0aWUgZGFucyB1biByYXN0ZXIsIGF2YW50IGxldXIgY2xhc3NlbWVudC5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX0JhY2tncm91bmQtVmFsdWVfdGFnMUBAXCI6IFwiU2kgdW4gcGl4ZWwgbmUgc2UgdHJvdXZlIHBhcyBhdSBzZWluIGTigJl1bmUgem9uZSwgaWwgZGVtZXVyZSBlbiB0YW50IHF1ZSB2YWxldXIgZOKAmWFycmnDqHJlLXBsYW4uXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19WYWx1ZS1SYXN0ZXJfdGFnMEBAXCI6IFwiTGUgcmFzdGVyIGVuIGVudHLDqWUgcmVxdWlzLlwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfVmFsdWUtUmFzdGVyX3RhZzFAQFwiOiBcIkwnZW50csOpZSBkb2l0IMOqdHJlIHVuIHJhc3RlciBtb25vY2FuYWwuIFNpIHVuIHJhc3RlciBtdWx0aWNhbmFsIGVzdCB1dGlsaXPDqSwgc2V1bCBsZSBwcmVtaWVyIGNhbmFsIGVzdCBlbXBsb3nDqS5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX1doZXJlLUNsYXVzZV90YWcwQEBcIjogXCJSZXF1w6p0ZSBzdXBwbMOpbWVudGFpcmUgZmFjdWx0YXRpdmUgYXBwbGlxdcOpZSDDoCBsYSA8c3Ryb25nPlRhYmxlIGRlcyBhdHRyaWJ1dHMgem9uYXV4PC9zdHJvbmc+LlwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfV2hlcmUtQ2xhdXNlX3RhZzNAQFwiOiBcIlNpIHZvdXMgdXRpbGlzaWV6IGxhIHRhYmxlIGNpLWRlc3N1cyBjb21tZSBleGVtcGxlLCBsYSByZXF1w6p0ZSBzZXJhaXQgJHtWYXJpYWJsZTEgPSAnYmFyZSBlYXJ0aCd9LlwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfWm9uYWwtQXR0cmlidXRlcy1UYWJsZV90YWcwQEBcIjogXCJMZXMgYXR0cmlidXRzIHpvbmF1eCBzcMOpY2lmacOpcyBlbiB0YW50IHF1ZSBjaGVtaW4gZCdhY2PDqHMgw6AgdW5lIGNsYXNzZSBkJ2VudGl0w6lzIGxvY2FsZSwgY2hlbWluIGQnYWNjw6hzIMOgIHVuZSB0YWJsZSwgVVJMIGQndW5lIGNvdWNoZSBkZSBzZXJ2aWNlIGQnZW50aXTDqXMgb3UgY2hhw65uZSBKU09OLlwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfWm9uYWwtQXR0cmlidXRlcy1UYWJsZV90YWcxQEBcIjogXCJEYW5zIEpTT04sIGNlY2kgZXN0IGTDqWNyaXQgZW4gdGFudCBxdWUgY29sbGVjdGlvbiBjYXJ0b2dyYXBoaXF1ZSBhbGxhbnQgZGVzIElEIGRlIHpvbmUgw6AgdW5lIG1hdHJpY2UgZOKAmWVudGllcnMuICR7eyB6b25lSWQ6W2YxLGYyLC4uLixmbl0sIC4uLiB9IH1cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX1pvbmUtRmllbGRfdGFnMEBAXCI6IFwiTGUgbm9tIGRlIGNoYW1wIGNvbnRlbmFudCBsZXMgdmFsZXVycyBkJ0lEIGRlIHpvbmUuXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19ab25lLVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgbW9ub2NhbmFsIGZhY3VsdGF0aWYgb8O5IGNoYXF1ZSBwaXhlbCBjb250aWVudCBsJ0lEIGRlIHpvbmUgYXNzb2Npw6kgw6AgbCdlbXBsYWNlbWVudC4gTCdJRCBkZSB6b25lIHBlcm1ldCBkZSByZWNoZXJjaGVyIGRlcyBsaWduZXMgZGFucyBsYSB0YWJsZSBkZXMgYXR0cmlidXRzIHpvbmF1eCBhZmluIGRlIHJlY2V2b2lyIGRlcyB6b25lcyBzcMOpY2lmaXF1ZXMuXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19ab25lLVJhc3Rlcl90YWcxQEBcIjogXCJOZSBzcMOpY2lmaWV6IHBhcyBjZSBwYXJhbcOodHJlIHNpIHZvdXMgc291aGFpdGV6IHVuaXF1ZW1lbnQgaW1wb3J0ZXIgbCdhdHRyaWJ1dC5cIixcblx0XCJAQFJhc3Rlcml6ZS1GZWF0dXJlc19GaWVsZF90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGxlIGNoYW1wIMOgIHV0aWxpc2VyIHBvdXIgaWRlbnRpZmllciBjaGFxdWUgZW50aXTDqS5cIixcblx0XCJAQFJhc3Rlcml6ZS1GZWF0dXJlc19JbnB1dC1GZWF0dXJlc190YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGxhIGNsYXNzZSBkJ2VudGl0w6lzIMOgIGNvbnZlcnRpciBlbiBmb3JtYXQgcmFzdGVyLlwiLFxuXHRcIkBAUmFzdGVyaXplLUZlYXR1cmVzX1Jhc3Rlcl90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IHVuIHJhc3RlciBwb3VyIGTDqWZpbmlyIGxhIHRhaWxsZSBkZSBjZWxsdWxlIGV0IGzigJnDqXRlbmR1ZSBwb3VyIGxhIGNvbnZlcnNpb24gZGVzIGVudGl0w6lzLlwiLFxuXHRcIkBAUmFzdGVyaXplLUZlYXR1cmVzX1Jlc29sdmUtT3ZlcmxhcC1NZXRob2RfdGFnMEBAXCI6IFwiSW5kaXF1ZXogY29tbWVudCBnw6lyZXIgbGVzIGVudGl0w6lzIHN1cGVycG9zw6llcyA6XCIsXG5cdFwiQEBSYXN0ZXJpemUtRmVhdHVyZXNfUmVzb2x2ZS1PdmVybGFwLU1ldGhvZF90YWcxQEBcIjogXCI8c3Ryb25nPlByZW1pZXI8L3N0cm9uZz4gOiB1bmUgdmFsZXVyIGlzc3VlIGR1IHByZW1pZXIgamV1IGRlIGRvbm7DqWVzIHLDqXBlcnRvcmnDqSBlc3QgYXR0cmlidcOpZSBhdXggem9uZXMgc3VwZXJwb3PDqWVzLlwiLFxuXHRcIkBAUmFzdGVyaXplLUZlYXR1cmVzX1Jlc29sdmUtT3ZlcmxhcC1NZXRob2RfdGFnM0BAXCI6IFwiPHN0cm9uZz5EZXJuaWVyPC9zdHJvbmc+IDogdW5lIHZhbGV1ciBpc3N1ZSBkdSBkZXJuaWVyIGpldSBkZSBkb25uw6llcyByw6lwZXJ0b3Jpw6kgZXN0IGF0dHJpYnXDqWUgYXV4IHpvbmVzIHN1cGVycG9zw6llcy5cIixcblx0XCJAQFJhc3Rlcml6ZS1GZWF0dXJlc19SZXNvbHZlLU92ZXJsYXAtTWV0aG9kX3RhZzVAQFwiOiBcIjxzdHJvbmc+TGUgcGx1cyBwZXRpdDwvc3Ryb25nPiA6IHVuZSB2YWxldXIgaXNzdWUgZGVzIHBsdXMgcGV0aXRlcyBlbnRpdMOpcyBlc3QgYXR0cmlidcOpZSBhdXggem9uZXMgc3VwZXJwb3PDqWVzLlwiLFxuXHRcIkBAUmFzdGVyaXplLUZlYXR1cmVzX1Jlc29sdmUtT3ZlcmxhcC1NZXRob2RfdGFnN0BAXCI6IFwiPHN0cm9uZz5MZSBwbHVzIGdyYW5kPC9zdHJvbmc+IDogdW5lIHZhbGV1ciBpc3N1ZSBkZXMgcGx1cyBncmFuZGVzIGVudGl0w6lzIGVzdCBhdHRyaWJ1w6llIGF1eCB6b25lcyBzdXBlcnBvc8OpZXMuXCIsXG5cdFwiQEBSZWNhc3RfT3ZlcnJpZGVzX3RhZzBAQFwiOiBcIlVuZSB0YWJsZSBkZXMgbm9tcyBkZSB2YXJpYWJsZXMgZXQgZGVzIHZhbGV1cnMgZMOpZmluaWVzIHBhciBs4oCZdXRpbGlzYXRldXIgdXRpbGlzw6llIHBvdXIgbW9kaWZpZXIgdW4gamV1IGRlIGRvbm7DqWVzIG1vc2HDr3F1ZS5cIixcblx0XCJAQFJlY2FzdF9SYXN0ZXJfdGFnMEBAXCI6IFwiUHJvZHVpdCByYXN0ZXIgc3VyIGxlcXVlbCBhdXF1ZWwgbGEgZm9uY3Rpb24gUsOpZMOpZmluaXIgZXN0IGFwcGxpcXXDqS5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9BZGQtTGlua190YWcwQEBcIjogXCJTcMOpY2lmaWUgc2kgdW4gY2hhbXAgTElOSyBlc3QgYWpvdXTDqSDDoCBsYSB0YWJsZSBkdSByw6lzdWx0YXQgZW4gc29ydGllLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX0FkZC1MaW5rX3RhZzFAQFwiOiBcIjxzdHJvbmc+QWpvdXRlciB1biBsaWVuPC9zdHJvbmc+IDogdW4gw6lsw6ltZW50ICR7TElOS30gc2VyYSBham91dMOpIMOgIGxhIHRhYmxlIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfQWRkLUxpbmtfdGFnM0BAXCI6IFwiPHN0cm9uZz5BdWN1biBsaWVuPC9zdHJvbmc+IDogbGEgdGFibGUgYXR0cmlidXRhaXJlIGR1IHJhc3RlciBlbiBzb3J0aWUgY29udGllbmRyYSB1bmlxdWVtZW50IGxlcyDDqWzDqW1lbnRzICR7VmFsdWV9IGV0ICR7Q291bnR9LlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX0V4Y2x1ZGVkLVZhbHVlX3RhZzBAQFwiOiBcIklkZW50aWZpZSB1bmUgdmFsZXVyIHRlbGxlIHF1ZSBzaSB1biBlbXBsYWNlbWVudCBkZSBjZWxsdWxlIGNvbnRpZW50IGNldHRlIHZhbGV1ciwgYXVjdW5lIGNvbm5lY3Rpdml0w6kgc3BhdGlhbGUgbmUgcG91cnJhIMOqdHJlIMOpdmFsdcOpZSwgcXVlbCBxdWUgc29pdCBsZSBub21icmUgZGUgdm9pc2luIHNww6ljaWZpw6kgKEZPVVIgb3UgRUlHSFQpLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX0V4Y2x1ZGVkLVZhbHVlX3RhZzFAQFwiOiBcIkxlcyBjZWxsdWxlcyBkb3TDqWVzIGRlIGxhIHZhbGV1ciBleGNsdWUgc29udCB0cmFpdMOpZXMgZW4gTm9EYXRhIGV0IHNvbnQgw6lsaW1pbsOpZXMgZGUgdG91dCBjYWxjdWwuIERhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZSwgbGEgdmFsZXVyIHrDqXJvIGVzdCBhdHRyaWJ1w6llIGF1eCBlbXBsYWNlbWVudHMgZGUgY2VsbHVsZSBxdWkgY29udGllbm5lbnQgbGEgdmFsZXVyIGV4Y2x1ZS5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9FeGNsdWRlZC1WYWx1ZV90YWcyQEBcIjogXCJMYSB2YWxldXIgZXhjbHVlIHJlcG9zZSBzdXIgbGUgbcOqbWUgY29uY2VwdCBxdeKAmXVuZSB2YWxldXIgZOKAmWFycmnDqHJlLXBsYW4gb3UgcXVlIGzigJlhcHBsaWNhdGlvbiBk4oCZdW4gbWFzcXVlLiBVbmUgdmFsZXVyIGRvaXQgw6p0cmUgc3DDqWNpZmnDqWUgcG91ciBjZSBwYXJhbcOodHJlIHNpIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz4ke0NST1NTfTwvc3Ryb25nPiBlc3Qgc3DDqWNpZmnDqS5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9OdW1iZXItb2YtTmVpZ2hib3ItQ2VsbHNfdGFnMEBAXCI6IFwiTm9tYnJlIGRlIGNlbGx1bGVzIHZvaXNpbmVzIMOgIHV0aWxpc2VyIGFmaW4gZCfDqXZhbHVlciBsYSBjb25uZWN0aXZpdMOpIGVudHJlIGxlcyBjZWxsdWxlcy5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9OdW1iZXItb2YtTmVpZ2hib3ItQ2VsbHNfdGFnMUBAXCI6IFwiPHN0cm9uZz5RVUFUUkU8L3N0cm9uZz4gOiBkw6lmaW5pdCBsYSBjb25uZWN0aXZpdMOpIGVudHJlIGRlcyBjZWxsdWxlcyBk4oCZdW5lIG3Dqm1lIHZhbGV1ciB1bmlxdWVtZW50IHNpIGVsbGVzIHNlIHRyb3V2ZW50IGRpcmVjdGVtZW50IMOgIGdhdWNoZSwgw6AgZHJvaXRlLCBhdS1kZXNzdXMgb3UgZW4gZGVzc291cyBkZXMgcXVhdHJlIHZvaXNpbnMgbGVzIHBsdXMgcHJvY2hlcy4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9OdW1iZXItb2YtTmVpZ2hib3ItQ2VsbHNfdGFnM0BAXCI6IFwiPHN0cm9uZz5IVUlUPC9zdHJvbmc+IDogZMOpZmluaXQgbGEgY29ubmVjdGl2aXTDqSBlbnRyZSBkZXMgY2VsbHVsZXMgZGUgbcOqbWUgdmFsZXVyIHNpIGVsbGVzIHNlIHRyb3V2ZW50IGRhbnMgbGUgdm9pc2luYWdlIGltbcOpZGlhdCBkZSBodWl0IGNlbGx1bGVzLiBFbGxlcyBwZXV2ZW50IHNlIHNpdHVlciDDoCBkcm9pdGUsIMOgIGdhdWNoZSwgYXUtZGVzc3VzIG91IGVuIGRpYWdvbmFsZS5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLUNvbm5lY3Rpdml0eV90YWcwQEBcIjogXCJEw6lmaW5pdCBsZXMgdmFsZXVycyBkZSBjZWxsdWxlcyBxdWkgZG9pdmVudCDDqnRyZSBwcmlzZXMgZW4gY29tcHRlIGRhbnMgbGUgY2FkcmUgZGVzIHRlc3RzIGRlIGNvbm5lY3Rpdml0w6kuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfWm9uZS1Db25uZWN0aXZpdHlfdGFnMUBAXCI6IFwiPHN0cm9uZz5EQU5TPC9zdHJvbmc+IDogdGVzdGUgbGEgY29ubmVjdGl2aXTDqSBlbnRyZSBkZXMgdmFsZXVycyBpZGVudGlxdWVzIGVuIGVudHLDqWUgYXUgc2VpbiBkZSBsYSBtw6ptZSB6b25lLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX1pvbmUtQ29ubmVjdGl2aXR5X3RhZzNAQFwiOiBcIkxlcyBzZXVsZXMgY2VsbHVsZXMgcXVpIHBldXZlbnQgw6p0cmUgcmVncm91cMOpZXMgc29udCBkZXMgY2VsbHVsZXMgZGUgbGEgbcOqbWUgem9uZSAodmFsZXVyKSBldCBxdWkgcsOpcG9uZGVudCBhdXggZXhpZ2VuY2VzIHNwYXRpYWxlcyBkZSBjb25uZWN0aXZpdMOpIHNww6ljaWZpw6llcyBwYXIgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPk5vbWJyZSBkZSB2b2lzaW5zPC9zdHJvbmc+IChxdWF0cmUgb3UgaHVpdCB2b2lzaW5zKS5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLUNvbm5lY3Rpdml0eV90YWc2QEBcIjogXCI8c3Ryb25nPkNST0lTRVI8L3N0cm9uZz4gOiB0ZXN0ZSBsYSBjb25uZWN0aXZpdMOpIHN1ciBsYSBiYXNlIGRlcyBleGlnZW5jZXMgc3BhdGlhbGVzIHNww6ljaWZpw6llcyBwYXIgbGUgbm9tYnJlIGRlIHZvaXNpbnMgZW50cmUgbGVzIGNlbGx1bGVzIGRvdMOpZXMgZGUgdmFsZXVycyBxdWVsY29ucXVlcywgw6AgbOKAmWV4Y2VwdGlvbiBkZSBsYSB2YWxldXIgaWRlbnRpZmnDqWUgw6AgZXhjbHVyZSB2aWEgbGUgcGFyYW3DqHRyZSBkZSB2YWxldXIgZXhjbHVlLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX1pvbmUtQ29ubmVjdGl2aXR5X3RhZzhAQFwiOiBcIkxvcnNxdWUgY2V0dGUgb3B0aW9uIGVzdCB1dGlsaXPDqWUsIHVuZSB2YWxldXIgZG9pdCDDqnRyZSBzcMOpY2lmacOpZSBwb3VyIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5WYWxldXIgZXhjbHVlPC9zdHJvbmc+LlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX1pvbmUtUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIHJlcXVpcyBkb250IGxlcyB1bmlxdWVzIHLDqWdpb25zIGNvbm5lY3TDqWVzIHNlcm9udCBpZGVudGlmacOpZXMuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfWm9uZS1SYXN0ZXJfdGFnMUBAXCI6IFwiSWwgZG9pdCDDqnRyZSBkZSB0eXBlIGVudGllci5cIixcblx0XCJAQFJlZ2lvbi1Hcm93X0ZpbGwtVmFsdWUtRmllbGRfdGFnMEBAXCI6IFwiQ2hhbXAgZGUgbGEgdGFibGUgYXR0cmlidXRhaXJlIHF1aSBkw6lmaW5pdCBsYSB2YWxldXIgZGUgcmVtcGxpc3NhZ2UgYXR0cmlidcOpZSBhdSBncm91cGUgZGUgcGl4ZWxzLiBEYW5zIHVuZSBpbWFnZSBtdWx0aWNhbmFsLCBjZXR0ZSB2YWxldXIgZXN0IGF0dHJpYnXDqWUgw6AgdG91cyBsZXMgY2FuYXV4LlwiLFxuXHRcIkBAUmVnaW9uLUdyb3dfTWF4LUdyb3d0aC1SYWRpdXMtRmllbGRfdGFnMEBAXCI6IFwiQ2hhbXAgZGUgbGEgdGFibGUgYXR0cmlidXRhaXJlIHF1aSBkw6lmaW5pdCBsZSByYXlvbiBkJ8Opdm9sdXRpb24gbWF4aW1hbGUsIGRhbnMgbGVzIHVuaXTDqXMgZGUgbGEgcsOpZsOpcmVuY2Ugc3BhdGlhbGUgZGUgbCdpbWFnZS5cIixcblx0XCJAQFJlZ2lvbi1Hcm93X1Jhc3Rlcl90YWcwQEBcIjogXCJMZSByYXN0ZXIgc3VyIGxlcXVlbCB2b3VzIHNvdWhhaXRleiBhcHBsaXF1ZXIgY2V0dGUgZm9uY3Rpb24uXCIsXG5cdFwiQEBSZWdpb24tR3Jvd19TZWVkLVBvaW50c190YWcwQEBcIjogXCJDbGFzc2UgZCdlbnRpdMOpcyBwb2ludHMgcXVpIHNlcnQgZGUgdmFsZXVycyBpbml0aWFsZXMgw6AgbCdhbGdvcml0aG1lLiBDaGFxdWUgcG9pbnQgZOKAmW9yaWdpbmUgY29ycmVzcG9uZCDDoCB1bmUgZW50csOpZSBkZSBsYSB0YWJsZSBhdHRyaWJ1dGFpcmUsIHF1aSBjb21wb3J0ZSBkZXMgaW5mb3JtYXRpb25zIHN1ciBsZSByYXlvbiBk4oCZw6l2b2x1dGlvbiBtYXhpbWFsZSwgbGUgc2V1aWwgZGUgc2ltaWxhcml0w6kgZXQgbGEgdmFsZXVyIGRlIHJlbXBsaXNzYWdlLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3dfU2ltaWxhcml0eS1UaHJlc2hvbGQtRmllbGRfdGFnMEBAXCI6IFwiQ2hhbXAgZGUgbGEgdGFibGUgYXR0cmlidXRhaXJlIHF1aSBkw6lmaW5pdCBsZSBzZXVpbCBkZSBzaW1pbGFyaXTDqSwgZW4gdGFudCBxdWUgZGlzdGFuY2UgZXVjbGlkaWVubmUgZGUgbCdlc3BhY2Ugc3BlY3RyYWwuXCIsXG5cdFwiQEBSZW1hcF9BbGxvdy1Vbm1hdGNoZWQtUGl4ZWwtVmFsdWVzX3RhZzBAQFwiOiBcIkxlcyB2YWxldXJzIG1hbnF1YW50ZXMgZGFucyBsYSB0YWJsZSBkZSByZWNsYXNzZW1lbnQgcGV1dmVudCBjb25zZXJ2ZXIgbGV1ciB2YWxldXIgb3Ugw6p0cmUgY2xhc3NpZmnDqWVzIHN1ciBOb0RhdGEuXCIsXG5cdFwiQEBSZW1hcF9BbGxvdy1Vbm1hdGNoZWQtUGl4ZWwtVmFsdWVzX3RhZzFAQFwiOiBcIkTDqXNhY3RpdsOpwqA6IHRvdXQgcGl4ZWwgZHUgcmFzdGVyIGVuIGVudHLDqWUgcXVpIG7igJllc3QgcGFzIHJlY2xhc3PDqSBkYW5zIHVuZSB0YWJsZSBkZSBjbGFzc2lmaWNhdGlvbiBjb25zZXJ2ZXJhIHNhIHZhbGV1ciBldCBzZXJhIGVucmVnaXN0csOpIHBvdXIgc29uIGVtcGxhY2VtZW50IGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFJlbWFwX0FsbG93LVVubWF0Y2hlZC1QaXhlbC1WYWx1ZXNfdGFnMkBAXCI6IFwiQWN0aXbDqcKgOiB0b3V0IHBpeGVsIGR1IHJhc3RlciBlbiBlbnRyw6llIHF1aSBu4oCZZXN0IHBhcyByZWNsYXNzw6kgZGFucyB1bmUgdGFibGUgZGUgY2xhc3NpZmljYXRpb24gcHJlbmRyYSBsYSB2YWxldXIgTm9EYXRhIHBvdXIgc29uIGVtcGxhY2VtZW50IGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQFJlbWFwX0lucHV0LUZpZWxkX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGUgY2hhbXAgcXVpIGluZGlxdWUgbGEgdmFsZXVyIGRlIHBpeGVsIMOgIGNsYXNzaWZpZXIuXCIsXG5cdFwiQEBSZW1hcF9JbnB1dC1GaWVsZF90YWcxQEBcIjogXCJTaSB2b3RyZSB0YWJsZSBjb21wb3J0ZSB1bmUgcGxhZ2UgZGUgdmFsZXVycywgaWwgc+KAmWFnaXQgZHUgY2hhbXAgZGUgbGEgdmFsZXVyIG1pbmltYWxlLCBldCBsZSBwYXJhbcOodHJlIDxzdHJvbmc+Q2hhbXAgbWF4IGVuIGVudHLDqWU8L3N0cm9uZz4gZG9pdCDDqWdhbGVtZW50IMOqdHJlIHNww6ljaWZpw6kuXCIsXG5cdFwiQEBSZW1hcF9JbnB1dC1NYXgtRmllbGRfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsZSBjaGFtcCBkZSBsYSB2YWxldXIgbWF4aW1hbGUgc2kgdm90cmUgdGFibGUgaW5kaXF1ZSB1bmUgcGxhZ2UgZGUgdmFsZXVycy5cIixcblx0XCJAQFJlbWFwX0xpc3RfdGFnMEBAXCI6IFwiSW5kaXF1ZXogbGVzIHZhbGV1cnMgw6AgYXBwYXJpZXIsIGFpbnNpIHF1ZSBsYSBwbGFnZSBkZXMgdmFsZXVycyBtaW5pbWFsZSBldCBtYXhpbWFsZSBldCBsZXMgbm91dmVsbGVzIHZhbGV1cnMgZGUgY2xhc3NpZmljYXRpb24uIExhIHBsYWdlIGRlcyB2YWxldXJzIHBldXQgZW4gb3V0cmUgw6p0cmUgZMOpZmluaWUgc3VyIHBpeGVscyBOb0RhdGEuXCIsXG5cdFwiQEBSZW1hcF9PdXRwdXQtRmllbGRfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsZSBjaGFtcCBxdWkgc2VyYSB1dGlsaXPDqSBjb21tZSB2YWxldXIgY2xhc3NpZmnDqWUgZW4gc29ydGllLlwiLFxuXHRcIkBAUmVtYXBfUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUmVtYXBfUmVtYXAtRGVmaW5pdGlvbi1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbOKAmW9wdGlvbiBxdWUgdm91cyBzb3VoYWl0ZXogdXRpbGlzZXIgcG91ciBkw6lmaW5pciBsZXMgdmFsZXVycyBkZSBjbGFzc2lmaWNhdGlvbiA6XCIsXG5cdFwiQEBSZW1hcF9SZW1hcC1EZWZpbml0aW9uLVR5cGVfdGFnMUBAXCI6IFwiTGlzdGUgOiBzcMOpY2lmaWVyIHVuZSBwbGFnZSBkZSB2YWxldXJzIGRlIHBpeGVsIMOgIGFwcGFyaWVyIMOgIHVuZSB2YWxldXIgZGUgcGl4ZWwgZW4gc29ydGllXCIsXG5cdFwiQEBSZW1hcF9SZW1hcC1UYWJsZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGUgdHlwZSBkZSB0YWJsZSBxdWUgdm91cyB1dGlsaXNlcmV6IHBvdXIgY2xhc3NpZmllciB2b3RyZSByYXN0ZXIgZW4gZW50csOpZSA6XCIsXG5cdFwiQEBSZW1hcF9SZW1hcC1UYWJsZS1UeXBlX3RhZzFAQFwiOiBcIlNpbXBsZSA6IHV0aWxpc2UgbGEgPHN0cm9uZz5UYWJsZSBkZSBjbGFzc2lmaWNhdGlvbjwvc3Ryb25nPiBlbiBlbnRyw6llIHBvdXIgYXBwYXJpZXIgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIGR1IDxzdHJvbmc+Q2hhbXAgZW4gZW50csOpZTwvc3Ryb25nPiBhdmVjIGxhIHZhbGV1ciBjb3JyZXNwb25kYW50ZSBkYW5zIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5DaGFtcCBlbiBzb3J0aWU8L3N0cm9uZz4uIENldHRlIG3DqXRob2RlIG1ldCBlbiBjYWNoZSBsYSB0YWJsZSBkZSBjbGFzc2lmaWNhdGlvbiBhZmluIGTigJlhY2Nyb8OudHJlIGxhIHJhcGlkaXTDqSBk4oCZZXjDqWN1dGlvbi5cIixcblx0XCJAQFJlbWFwX1JlbWFwLVRhYmxlLVR5cGVfdGFnOEBAXCI6IFwiRHluYW1pcXVlIDogY2V0dGUgbcOpdGhvZGUgbmUgbWV0IHBhcyBlbiBjYWNoZSBsYSB0YWJsZSBkZSBjbGFzc2lmaWNhdGlvbiBldCBlZmZlY3R1ZSB1bmUgcmVxdcOqdGUgY2hhcXVlIGZvaXMgcXVlIGzigJl1dGlsaXNhdGV1ciBlZmZlY3R1ZSB1biBkw6lwbGFjZW1lbnQsIHpvb20gb3UgYWN0dWFsaXNlIGxhIGNhcnRlLiBTaSBsYSB0YWJsZSBlc3QgbW9kaWZpw6llLCBsYSBkZW1hbmRlIHN1aXZhbnRlIHBldXQgY2xhc3NpZmllciBkeW5hbWlxdWVtZW50IGxlcyB2YWxldXJzIGVuIGNvbnPDqXF1ZW5jZS5cIixcblx0XCJAQFJlbWFwX1JlbWFwLVRhYmxlLVR5cGVfdGFnOUBAXCI6IFwiUsOpYWZmZWN0YXRpb24gOiB1bmUgdGFibGUgc3DDqWNpZmlxdWUgZXN0IHV0aWxpc8OpZSBwb3VyIGxlIHByb2Nlc3N1cyBkZSByZWNsYXNzaWZpY2F0aW9uLCBkYW5zIGxlcXVlbCBjaGFxdWUgbGlnbmUgZGUgbGEgdGFibGUgbuKAmWVzdCByZWNsYXNzw6llIHF14oCZZW4gZm9uY3Rpb24gZGUgY2hhcXVlIGxpbWl0ZSBk4oCZZW50aXTDqS5cIixcblx0XCJAQFJlbWFwX1JlbWFwLVRhYmxlX3RhZzBAQFwiOiBcIkFjY8OpZGV6IMOgIGxhIHRhYmxlIHF1aSBkw6lmaW5pdCB2b3MgdmFsZXVycyBkZSBjbGFzc2lmaWNhdGlvbi5cIixcblx0XCJAQFJlcHJvamVjdF9SYXN0ZXJfdGFnMEBAXCI6IFwiTGUgamV1IGRlIGRvbm7DqWVzIHJhc3RlciDDoCByZXByb2pldGVyIG91IHLDqS3DqWNoYW50aWxsb25lci5cIixcblx0XCJAQFJlcHJvamVjdF9TcGF0aWFsLVJlZmVyZW5jZV90YWcwQEBcIjogXCJTeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgdXRpbGlzw6kgcG91ciByZXByb2pldGVyIGxlcyBkb25uw6llcy5cIixcblx0XCJAQFJlcHJvamVjdF9YLUNlbGxzaXplX3RhZzBAQFwiOiBcIkRpbWVuc2lvbiB4IGRhbnMgbGFxdWVsbGUgbGVzIGRvbm7DqWVzIGRvaXZlbnQgw6p0cmUgcsOpw6ljaGFudGlsbG9ubsOpZXMuIENlIHBhcmFtw6h0cmUgZXN0IGZhY3VsdGF0aWYuIFNpIGxhIHZhbGV1ciBlc3QgaW5mw6lyaWV1cmUgb3Ugw6lnYWxlIMOgIDAsIGzigJllbnZlbG9wcGUgZW4gc29ydGllICjDqXRlbmR1ZSBldCB0YWlsbGVzIGRlIGNlbGx1bGUpIGVzdCBjYWxjdWzDqWUgw6AgcGFydGlyIGR1IHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUmVwcm9qZWN0X1gtUmVnaXN0cmF0aW9uLVBvaW50X3RhZzBAQFwiOiBcIkNvb3Jkb25uw6llIHggdXRpbGlzw6llIHBvdXIgZMOpZmluaXIgbOKAmWFuZ2xlIHN1cMOpcmlldXIgZ2F1Y2hlIGR1IGpldSBkZSBkb25uw6llcy4gQ2V0dGUgY29vcmRvbm7DqWUgZG9pdCDDqnRyZSBkw6lmaW5pZSBkYW5zIGxlcyB1bml0w6lzIGRlIGxhIG5vdXZlbGxlIHLDqWbDqXJlbmNlIHNwYXRpYWxlLiBTaSBsZXMgcGFyYW3DqHRyZXMgPHN0cm9uZz5UYWlsbGUgZGUgY2VsbHVsZSBYPC9zdHJvbmc+IGV0IDxzdHJvbmc+VGFpbGxlIGRlIGNlbGx1bGUgWTwvc3Ryb25nPiBzb250IHRvdXMgZGV1eCBzdXDDqXJpZXVycyDDoCAwLCBpbHMgc29udCB1dGlsaXPDqXMgYXZlYyBsZXMgcGFyYW3DqHRyZXMgPHN0cm9uZz5Qb2ludCBkZSBjYWxhZ2UgWDwvc3Ryb25nPiBldCA8c3Ryb25nPlBvaW50IGRlIGNhbGFnZSBZPC9zdHJvbmc+IHBvdXIgZMOpZmluaXIgbOKAmWVudmVsb3BwZSBlbiBzb3J0aWUuXCIsXG5cdFwiQEBSZXByb2plY3RfWS1DZWxsc2l6ZV90YWcwQEBcIjogXCJEaW1lbnNpb24geSBkYW5zIGxhcXVlbGxlIGxlcyBkb25uw6llcyBkb2l2ZW50IMOqdHJlIHLDqcOpY2hhbnRpbGxvbm7DqWVzLiBDZSBwYXJhbcOodHJlIGVzdCBmYWN1bHRhdGlmLiBTaSBsYSB2YWxldXIgZXN0IGluZsOpcmlldXJlIG91IMOpZ2FsZSDDoCAwLCBs4oCZZW52ZWxvcHBlIGVuIHNvcnRpZSAow6l0ZW5kdWUgZXQgdGFpbGxlcyBkZSBjZWxsdWxlKSBlc3QgY2FsY3Vsw6llIMOgIHBhcnRpciBkdSByYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQFJlcHJvamVjdF9ZLVJlZ2lzdHJhdGlvbi1Qb2ludF90YWcwQEBcIjogXCJDb29yZG9ubsOpZSB5IHV0aWxpc8OpZSBwb3VyIGTDqWZpbmlyIGzigJlhbmdsZSBzdXDDqXJpZXVyIGdhdWNoZSBkdSBqZXUgZGUgZG9ubsOpZXMuIENldHRlIGNvb3Jkb25uw6llIGRvaXQgw6p0cmUgZMOpZmluaWUgZGFucyBsZXMgdW5pdMOpcyBkZSBsYSBub3V2ZWxsZSByw6lmw6lyZW5jZSBzcGF0aWFsZS4gU2kgbGVzIHBhcmFtw6h0cmVzIDxzdHJvbmc+VGFpbGxlIGRlIGNlbGx1bGUgWDwvc3Ryb25nPiBldCA8c3Ryb25nPlRhaWxsZSBkZSBjZWxsdWxlIFk8L3N0cm9uZz4gc29udCB0b3VzIGRldXggc3Vww6lyaWV1cnMgw6AgMCwgaWxzIHNvbnQgdXRpbGlzw6lzIGF2ZWMgbGVzIHBhcmFtw6h0cmVzIDxzdHJvbmc+UG9pbnQgZGUgY2FsYWdlIFg8L3N0cm9uZz4gZXQgPHN0cm9uZz5Qb2ludCBkZSBjYWxhZ2UgWTwvc3Ryb25nPiBwb3VyIGTDqWZpbmlyIGzigJllbnZlbG9wcGUgZW4gc29ydGllLlwiLFxuXHRcIkBAUmVzYW1wbGVfSW5wdXQtQ2VsbHNpemVfdGFnMEBAXCI6IFwiVGFpbGxlIGRlIGNlbGx1bGUgKHBpeGVsKSBkdSByYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQFJlc2FtcGxlX091dHB1dC1DZWxsc2l6ZV90YWcwQEBcIjogXCJMYSB0YWlsbGUgZGUgbGEgY2VsbHVsZSAocGl4ZWwpIGR1IHJhc3RlciBlbiBzb3J0aWUuIExhIHRhaWxsZSBkZSBjZWxsdWxlIHBldXQgw6p0cmUgbW9kaWZpw6llLCBtYWlzIGzigJnDqXRlbmR1ZSBkdSBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIHJlc3RlIGlkZW50aXF1ZS4gTGUgcsOpLcOpY2hhbnRpbGxvbm5hZ2Ugw6AgcGFydGlyIGQndW5lIHRhaWxsZSBkZSBjZWxsdWxlIGTDqWZpbmllIHBhciBsJ3V0aWxpc2F0ZXVyIHBldXQgcydhdsOpcmVyIGJlYXVjb3VwIHBsdXMgbGVudCBxdWUgbGEgdmFsZXVyIHBhciBkw6lmYXV0IGR1IHN5c3TDqG1lLCBjYXIgbGUgcsOpLcOpY2hhbnRpbGxvbm5hZ2UgcGFyIGTDqWZhdXQgZHUgc3lzdMOobWUgdHJhaXRlIGxhIHF1YW50aXTDqSBtaW5pbWFsZSBkZSBkb25uw6llcyDDoCBwYXJ0aXIgZGUgbGEgcsOpc29sdXRpb24gbGEgcGx1cyBwcm9jaGUgcG9zc2libGUuXCIsXG5cdFwiQEBSZXNhbXBsZV9SYXN0ZXJfdGFnMEBAXCI6IFwiTGUgcmFzdGVyIGVuIGVudHLDqWUgw6AgcsOpLcOpY2hhbnRpbGxvbmVyLlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzBAQFwiOiBcIjxzdHJvbmc+Vm9pc2luIGxlIHBsdXMgcHJvY2hlPC9zdHJvbmc+IDogY2FsY3VsZSBsYSB2YWxldXIgZHUgcGl4ZWwgZW4gc29ydGllIGdyw6JjZSBhdSBwaXhlbCBlbiBlbnRyw6llIGxlIHBsdXMgcHJvY2hlLiBMZXMgcGl4ZWxzIE5vRGF0YSBuZSBzb250IHBhcyBtb2RpZmnDqXMgZGFucyBsZSBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIGVuIHNvcnRpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFJlc2FtcGxlX1Jlc2FtcGxpbmctVHlwZV90YWcyQEBcIjogXCI8c3Ryb25nPkludGVycG9sYXRpb24gYmlsaW7DqWFpcmU8L3N0cm9uZz4gOiBjYWxjdWxlIGxhIHZhbGV1ciBkdSBwaXhlbCBlbiB1dGlsaXNhbnQgbGEgdmFsZXVyIGRlIGRpc3RhbmNlIHBvbmTDqXLDqWUgZGVzIHF1YXRyZSBwaXhlbHMgbGVzIHBsdXMgcHJvY2hlcy4gTOKAmWV4w6ljdXRpb24gZGUgY2V0dGUgbcOpdGhvZGUgZXN0IGVmZmljYWNlIGF1IHBvaW50IGRlIHZ1ZSBkdSBjYWxjdWwuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnNEBAXCI6IFwiPHN0cm9uZz5Db252b2x1dGlvbiBjdWJpcXVlPC9zdHJvbmc+IDogZMOpdGVybWluZSBsYSBub3V2ZWxsZSB2YWxldXIgZOKAmXVuIHBpeGVsIGVuIGZhaXNhbnQgcGFzc2VyIHVuZSBjb3VyYmUgbGlzc8OpZSBwYXIgbGVzIGNlbnRyZXMgZGVzIDE2IHBpeGVscyBlbiBlbnRyw6llIGxlcyBwbHVzIHByb2NoZXMuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnNkBAXCI6IFwiPHN0cm9uZz5NYWpvcml0w6k8L3N0cm9uZz4gOiBjYWxjdWxlIGxhIHZhbGV1ciBkdSBwaXhlbCBlbiB1dGlsaXNhbnQgbGEgdmFsZXVyIGRlIHBpeGVsIG1ham9yaXRhaXJlIGRlcyAxNiBwaXhlbHMgbGVzIHBsdXMgcHJvY2hlcy4gTGVzIHBpeGVscyBOb0RhdGEgbmUgc29udCBwYXMgbW9kaWZpw6lzIGRhbnMgbGUgamV1IGRlIGRvbm7DqWVzIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnOEBAXCI6IFwiPHN0cm9uZz5JbnRlcnBvbGF0aW9uIGJpbGluw6lhaXJlIFBsdXM8L3N0cm9uZz4gOiB1dGlsaXNlIGzigJk8c3Ryb25nPkludGVycG9sYXRpb24gYmlsaW7DqWFpcmU8L3N0cm9uZz4sIG1haXMgbGVzIHBpeGVscyBsZSBsb25nIGRlcyBzZWdtZW50cyBzb250IGTDqWZpbmlzIHN1ciBsYSB2YWxldXIgTm9EYXRhIGV0IG5lIHNvbnQgbmkgcsOpcGxpcXXDqXMgbmkgcHJpcyBlbiBjb21wdGUgZGFucyBsZSBjYWxjdWwuIFV0aWxpc2V6IGzigJk8c3Ryb25nPkludGVycG9sYXRpb24gYmlsaW7DqWFpcmUgUGx1czwvc3Ryb25nPiBwb3VyIGxlcyBkb25uw6llcyB0dWlsw6llcyBjYXIgbGVzIHNlZ21lbnRzIHNlcm9udCBtaWV1eCBhanVzdMOpcy5cIixcblx0XCJAQFJlc2FtcGxlX1Jlc2FtcGxpbmctVHlwZV90YWcxNEBAXCI6IFwiPHN0cm9uZz5GbG91IGdhdXNzaWVuPC9zdHJvbmc+IDogYXBwbGlxdWUgdW5lIGNvbnZvbHV0aW9uIGdhdXNzaWVubmUgYXUgcmFzdGVyIHNvdXJjZSBldCBjYWxjdWxlIGxhIHZhbGV1ciBkdSBwaXhlbCBlbiB1dGlsaXNhbnQgbGEgdmFsZXVyIGRlIGRpc3RhbmNlIHBvbmTDqXLDqWUgZGVzIHF1YXRyZSBwaXhlbHMgbGVzIHBsdXMgcHJvY2hlcyBkdSByYXN0ZXIgZmxvdS4gQ2V0dGUgbcOpdGhvZGUgZXN0IGFwcHJvcHJpw6llIHBvdXIgc3VwcHJpbWVyIGxlIGJydWl0IGRhbnMgbGVzIGRvbm7DqWVzIHLDqcOpY2hhbnRpbGxvbm7DqWVzIGV0IHBvdXIgc291cy3DqWNoYW50aWxsb25uZXIgYWZpbiBk4oCZb2J0ZW5pciB1bmUgdGFpbGxlIGRlIHBpeGVsIHBsdXMgZ3JhbmRlLlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzE2QEBcIjogXCI8c3Ryb25nPkZsb3UgZ2F1c3NpZW4gUGx1czwvc3Ryb25nPiA6IGFwcGxpcXVlIGxhIG3DqXRob2RlIGRlIDxzdHJvbmc+RmxvdSBnYXVzc2llbjwvc3Ryb25nPiwgbWFpcyBsZXMgcGl4ZWxzIGxlIGxvbmcgZGVzIHNlZ21lbnRzIHNvbnQgZMOpZmluaXMgc3VyIGxhIHZhbGV1ciBOb0RhdGEgZXQgbmUgc29udCBuaSByw6lwbGlxdcOpcyBuaSBwcmlzIGVuIGNvbXB0ZSBkYW5zIGxlIGNhbGN1bC4gVXRpbGlzZXogbGUgPHN0cm9uZz5GbG91IGdhdXNzaWVuIFBsdXM8L3N0cm9uZz4gcG91ciBsZXMgZG9ubsOpZXMgdHVpbMOpZXMgY2FyIGxlcyBzZWdtZW50cyBzZXJvbnQgbWlldXggYWp1c3TDqXMuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnMjJAQFwiOiBcIjxzdHJvbmc+TW95ZW5uZTwvc3Ryb25nPiA6IGNhbGN1bGUgbGVzIHZhbGV1cnMgZGVzIHBpeGVscyBlbiB1dGlsaXNhbnQgbGEgdmFsZXVyIG1veWVubmUgZGUgdG91cyBsZXMgcGl4ZWxzIHN1cGVycG9zw6lzLCBwb3VyIGNoYXF1ZSBwaXhlbCBjaWJsZS5cIixcblx0XCJAQFJlc2FtcGxlX1Jlc2FtcGxpbmctVHlwZV90YWcyNEBAXCI6IFwiPHN0cm9uZz5NaW5pbXVtPC9zdHJvbmc+IDogY2FsY3VsZSBsYSB2YWxldXIgZHUgcGl4ZWwgZW4gdXRpbGlzYW50IGxhIHZhbGV1ciBtaW5pbWFsZSBkZSB0b3VzIGxlcyBwaXhlbHMgc3VwZXJwb3PDqXMuIExlcyBwaXhlbHMgTm9EYXRhIG5lIHNvbnQgcGFzIG1vZGlmacOpcyBkYW5zIGxlIGpldSBkZSBkb25uw6llcyByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzI2QEBcIjogXCI8c3Ryb25nPk1heGltdW08L3N0cm9uZz4gOiBhZGFwdMOpZSBhdXggZG9ubsOpZXMgY29udGludWVzLCBjZXR0ZSBtw6l0aG9kZSBwcm9kdWl0IHVuZSBpbWFnZSBlbiBzb3J0aWUgcGx1cyBsaXNzZSBxdWUgbGEgbcOpdGhvZGUgZGUgcsOpw6ljaGFudGlsbG9ubmFnZSBwYXIgbGUgdm9pc2luIGxlIHBsdXMgcHJvY2hlLlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzI4QEBcIjogXCI8c3Ryb25nPk1veWVubmUgdmVjdG9yaWVsbGU8L3N0cm9uZz4gOiBjYWxjdWxlIGxhIG1veWVubmUgdmVjdG9yaWVsbGUgZGUgbWFnbml0dWRlLWRpcmVjdGlvbiBlbiB1dGlsaXNhbnQgdG91cyBsZXMgcGl4ZWxzIGltcGxpcXXDqXMuIENldHRlIG3DqXRob2RlIHPigJlhcHBsaXF1ZSB1bmlxdWVtZW50IMOgIGRldXggcmFzdGVycyBiYW5kZXMgcmVwcsOpc2VudGFudCBsYSBtYWduaXR1ZGUgZXQgbGEgZGlyZWN0aW9uLiBFbGxlIGNvbnZlcnRpdCBk4oCZYWJvcmQgbGEgbWFnbml0dWRlLWRpcmVjdGlvbiBlbiBVLVYsIHB1aXMgcHJlbmQgbGEgbW95ZW5uZSBhcml0aG3DqXRpcXVlIGRlIHRvdXMgbGVzIHBpeGVscyBpbXBsaXF1w6lzIHBvdXIgb2J0ZW5pciBs4oCZVS1WIGR1IHBpeGVsIGNpYmxlIGV0IGxlIHJlY29udmVydGlyIGVuIG1hZ25pdHVkZS1kaXJlY3Rpb24uXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAUm91bmQtRG93bl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUm91bmQtRG93bl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUm91bmQtRG93bl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAUm91bmQtRG93bl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUm91bmQtRG93bl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFJvdW5kLURvd25fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAUm91bmQtRG93bl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAUm91bmQtRG93bl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAUm91bmQtRG93bl9SYXN0ZXJfdGFnMEBAXCI6IFwiVmFsZXVycyBlbiBlbnRyw6llIMOgIGFycm9uZGlyIGF1IG5vbWJyZSBpbmbDqXJpZXVyLlwiLFxuXHRcIkBAUm91bmQtVXBfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBSb3VuZC1VcF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUm91bmQtVXBfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFJvdW5kLVVwX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBSb3VuZC1VcF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUm91bmQtVXBfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBSb3VuZC1VcF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBSb3VuZC1VcF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAUm91bmQtVXBfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAUm91bmQtVXBfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFJvdW5kLVVwX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAUm91bmQtVXBfUmFzdGVyX3RhZzBAQFwiOiBcIlZhbGV1cnMgZW4gZW50csOpZSDDoCBhcnJvbmRpciBhdSBub21icmUgc3Vww6lyaWV1ci5cIixcblx0XCJAQFNlZ21lbnQtTWVhbi1TaGlmdF9NaW5pbXVtLVNlZ21lbnQtU2l6ZS1pbi1QaXhlbHNfdGFnMEBAXCI6IFwiVGFpbGxlIG1pbmltYWxlIGR1IHNlZ21lbnQgZXhwcmltw6llIGVuIHBpeGVscy4gQ2V0dGUgdmFsZXVyIGVzdCBhc3NvY2nDqWUgw6Agdm90cmUgdW5pdMOpIGRlIG1hcHBhZ2UgbWluaW1hbGUgZXQgcGVybWV0IGRlIGZpbHRyZXIgbGVzIGJsb2NzIGRlIHBpeGVscyBwbHVzIHBldGl0cy4gVG91cyBsZXMgc2VnbWVudHMgZG9udCBsYSB0YWlsbGUgZXN0IGluZsOpcmlldXJlIMOgIGxhIHZhbGV1ciBwcsOpY2lzw6llIGZ1c2lvbm5lbnQgbGVzIHBsdXMgcGV0aXRzIHNlZ21lbnRzIGF2ZWMgbGV1ciBzZWdtZW50IHZvaXNpbiBsZSBtaWV1eCBhZGFwdMOpLlwiLFxuXHRcIkBAU2VnbWVudC1NZWFuLVNoaWZ0X1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSDDoCBzZWdtZW50ZXIuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfU2VnbWVudC1ib3VuZGFyaWVzLW9ubHlfdGFnMEBAXCI6IFwiTGVzIGxpbWl0ZXMgZHUgc2VnbWVudCBkZXNzaW5lbnQgdW5lIGlzb2xpZ25lIGF1dG91ciBkZSBjaGFxdWUgc2VnbWVudC4gQ2VsYSBwZXJtZXQgZGUgZGlzdGluZ3VlciBkZXMgc2VnbWVudHMgYWRqYWNlbnRzIGRlIGNvdWxldXJzIHNpbWlsYWlyZXMuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfU2VnbWVudC1ib3VuZGFyaWVzLW9ubHlfdGFnMUBAXCI6IFwiTm9uIHPDqWxlY3Rpb25uw6kgOiBsZXMgbGltaXRlcyBkZXMgc2VnbWVudHMgbmUgc+KAmWFmZmljaGVudCBwYXMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfU2VnbWVudC1ib3VuZGFyaWVzLW9ubHlfdGFnMkBAXCI6IFwiU8OpbGVjdGlvbm7DqSA6IGxlcyBsaW1pdGVzIGRlcyBzZWdtZW50cyBz4oCZYWZmaWNoZW50IGF2ZWMgZGVzIGlzb2xpZ25lcyBub2lyZXMgYXV0b3VyIGRlIGNoYXF1ZSBzZWdtZW50LlwiLFxuXHRcIkBAU2VnbWVudC1NZWFuLVNoaWZ0X1NwYXRpYWwtRGV0YWlsX3RhZzBAQFwiOiBcIkltcG9ydGFuY2UgcmVsYXRpdmUgZGUgbGEgc8OpcGFyYXRpb24gZGVzIG9iamV0cyBlbiBmb25jdGlvbiBkZSBjYXJhY3TDqXJpc3RpcXVlcyBzcGF0aWFsZXMuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfU3BhdGlhbC1EZXRhaWxfdGFnMUBAXCI6IFwiTGVzIHZhbGV1cnMgZW50acOocmVzIGNvcnJlY3RlcyBzb250IGNvbXByaXNlcyBlbnRyZSAxIGV0IDIwLiBQbHVzIGxlcyB2YWxldXJzIHNvbnQgZmFpYmxlcywgcGx1cyBsZXMgY2xhc3NlcyBzb250IGdyYW5kZXMgZXQgbGUgbGlzc2FnZSBpbXBvcnRhbnQuIFVuZSB2YWxldXIgw6lsZXbDqWUgY29udmllbnQgcG91ciBkaXN0aW5ndWVyIGRlcyBlbnRpdMOpcyBwZXRpdGVzIGV0IGFncsOpZ8OpZXMuIFBhciBleGVtcGxlLCBkYW5zIHVuZSBzY8OobmUgdXJiYWluZSwgdm91cyBwb3V2ZXogY2xhc3NlciB1bmUgc3VyZmFjZSBpbXBlcm3DqWFibGUgZ8OpbsOpcmFsZSDDoCBs4oCZYWlkZSBk4oCZdW5lIHZhbGV1ciBkZSBkw6l0YWlsIHNwYXRpYWwgcGx1cyBwZXRpdGUgb3UgY2xhc3NlciBkZXMgYsOidGltZW50cyBldCBkZXMgcm91dGVzIGVuIHRhbnQgcXVlIGNsYXNzZXMgc8OpcGFyw6llcyDDoCBs4oCZYWlkZSBk4oCZdW5lIHZhbGV1ciBkZSBkw6l0YWlsIHNwYXRpYWwgc3Vww6lyaWV1cmUuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfU3BlY3RyYWwtRGV0YWlsX3RhZzBAQFwiOiBcIkltcG9ydGFuY2UgcmVsYXRpdmUgZGUgbGEgc8OpcGFyYXRpb24gZGVzIG9iamV0cyBlbiBmb25jdGlvbiBkZSBjYXJhY3TDqXJpc3RpcXVlcyBkZSBjb3VsZXVyLlwiLFxuXHRcIkBAU2VnbWVudC1NZWFuLVNoaWZ0X1NwZWN0cmFsLURldGFpbF90YWcxQEBcIjogXCJMZXMgdmFsZXVycyDDoCB2aXJndWxlIGZsb3R0YW50ZSB2YWxpZGVzIHNvbnQgY29tcHJpc2VzIGVudHJlIDEsMCBldCAyMCwwLiBQbHVzIGxlcyB2YWxldXJzIHNvbnQgZmFpYmxlcywgcGx1cyBsZXMgY2xhc3NlcyBzb250IGdyYW5kZXMgZXQgbGUgbGlzc2FnZSBpbXBvcnRhbnQuIElsIGNvbnZpZW50IGTigJlhdHRyaWJ1ZXIgdW5lIHZhbGV1ciDDqWxldsOpZSBsb3JzcXVlIHZvdXMgc291aGFpdGV6IGRpc3Rpbmd1ZXIgbGVzIGVudGl0w6lzIGRvbnQgbGVzIGNhcmFjdMOpcmlzdGlxdWVzIHNwZWN0cmFsZXMgc29udCByZWxhdGl2ZW1lbnQgc2ltaWxhaXJlcy4gUGFyIGV4ZW1wbGUsIGzigJl1dGlsaXNhdGlvbiBk4oCZdW5lIHZhbGV1ciBkZSBkw6l0YWlsIHNwZWN0cmFsIMOpbGV2w6llIGRhbnMgdW5lIHNjw6huZSBlbiB6b25lIGZvcmVzdGnDqHJlIHZvdXMgcGVybWV0IGRlIG1pZXV4IGRpc3Rpbmd1ZXIgbGVzIGVzcMOoY2VzIGTigJlhcmJyZXMuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfbWF4aW11bXNlZ21lbnRzaXplaW5waXhlbHNfdGFnMEBAXCI6IFwiPHA+VGFpbGxlIG1heGltYWxlIGTigJl1biBzZWdtZW50LiBMZXMgc2VnbWVudHMgZGUgdGFpbGxlIHN1cMOpcmlldXJlIMOgIGNlbGxlIHNww6ljaWZpw6llIHNlcm9udCBkaXZpc8Opcy4gVXRpbGlzZXogY2UgcGFyYW3DqHRyZSBwb3VyIMOpdml0ZXIgbGVzIGFydGVmYWN0cyBkYW5zIGxhIGNvdWNoZSBlbiBzb3J0aWUgcXVpIHLDqXN1bHRlbnQgZGUgc2VnbWVudHMgdm9sdW1pbmV1eC4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdMKgLTEuPC9wPlwiLFxuXHRcIkBAU2VudGluZWwtMS1SYWRpb21ldHJpYy1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmXVuIGRlcyBxdWF0cmUgdHlwZXMgZGUgY2FsaWJyYWdlIDpcIixcblx0XCJAQFNlbnRpbmVsLTEtUmFkaW9tZXRyaWMtQ2FsaWJyYXRpb25fQ2FsaWJyYXRpb24tVHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPkJldGEgbm91Z2h0PC9zdHJvbmc+IDogcHJvZHVpdCB1bmUgc29ydGllIGNvbnRlbmFudCBsZSBjb2VmZmljaWVudCBkZSBsdW1pbm9zaXTDqSBkdSByYWRhci5cIixcblx0XCJAQFNlbnRpbmVsLTEtUmFkaW9tZXRyaWMtQ2FsaWJyYXRpb25fQ2FsaWJyYXRpb24tVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPlNpZ21hIG5vdWdodDwvc3Ryb25nPiA6IHLDqXRyb2RpZmZ1c2lvbiByZW52b3nDqWUgw6AgbOKAmWFudGVubmUgw6AgcGFydGlyIGRlIGxhIHN1cmZhY2UgZOKAmXVuZSB1bml0w6kgYXUgc29sLCBsacOpZSDDoCBsYSBkaXN0YW5jZSBhdSBzb2wuXCIsXG5cdFwiQEBTZW50aW5lbC0xLVJhZGlvbWV0cmljLUNhbGlicmF0aW9uX0NhbGlicmF0aW9uLVR5cGVfdGFnNUBAXCI6IFwiPHN0cm9uZz5HYW1tYTwvc3Ryb25nPiA6IG1lc3VyZSBkZSBs4oCZw6luZXJnaWUgw6ltaXNlIGV0IHJlbnZvecOpZSB1dGlsZSBwb3VyIGTDqXRlcm1pbmVyIGxlcyBtb2TDqGxlcyBk4oCZYW50ZW5uZS5cIixcblx0XCJAQFNlbnRpbmVsLTEtUmFkaW9tZXRyaWMtQ2FsaWJyYXRpb25fQ2FsaWJyYXRpb24tVHlwZV90YWc3QEBcIjogXCI8c3Ryb25nPkF1Y3VuPC9zdHJvbmc+IDogYXVjdW5lIGNvcnJlY3Rpb24gbuKAmWVzdCBhcHBsaXF1w6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAU2VudGluZWwtMS1SYWRpb21ldHJpYy1DYWxpYnJhdGlvbl9SYXN0ZXJfdGFnMEBAXCI6IFwiTGUgcmFzdGVyIGVuIGVudHLDqWUgR1JEIG91IFNMQyBTZW50aW5lbC0xIGRlIG5pdmVhdSAxIHF1ZSB2b3VzIHNvdWhhaXRleiB0cmFpdGVyLlwiLFxuXHRcIkBAU2VudGluZWwtMS1SYWRpb21ldHJpYy1DYWxpYnJhdGlvbl9SYXN0ZXJfdGFnMUBAXCI6IFwiTGEgZm9uY3Rpb24gdXRpbGlzZXJhIGxlIGZpY2hpZXIgTFVUIHBvdXIgYXBwbGlxdWVyIGxhIGNvcnJlY3Rpb24gdGhlcm1pcXVlIG91IHBvdXIgc3VwcHJpbWVyIGxhIGNvcnJlY3Rpb24sIHNlbG9uIGxlIGNvbnRlbnUgZHUgZmljaGllciBMVVQuXCIsXG5cdFwiQEBTZW50aW5lbC0xLVRoZXJtYWwtTm9pc2UtUmVtb3ZhbF9SYXN0ZXJfdGFnMEBAXCI6IFwiTGUgcmFzdGVyIGVuIGVudHLDqWUgU2VudGluZWwtMSBxdWUgdm91cyBzb3VoYWl0ZXogdHJhaXRlci5cIixcblx0XCJAQFNlbnRpbmVsLTEtVGhlcm1hbC1Ob2lzZS1SZW1vdmFsX1Jhc3Rlcl90YWcxQEBcIjogXCJMYSBmb25jdGlvbiB1dGlsaXNlcmEgbGUgZmljaGllciBMVVQgcG91ciBhcHBsaXF1ZXIgbGEgY29ycmVjdGlvbiB0aGVybWlxdWUgb3UgcG91ciBzdXBwcmltZXIgbGEgY29ycmVjdGlvbiwgc2Vsb24gbGUgY29udGVudSBkdSBmaWNoaWVyIExVVC5cIixcblx0XCJAQFNldC1OdWxsX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAU2V0LU51bGxfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFNldC1OdWxsX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBTZXQtTnVsbF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAU2V0LU51bGxfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFNldC1OdWxsX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAU2V0LU51bGxfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAU2V0LU51bGxfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFNldC1OdWxsX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFNldC1OdWxsX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBTZXQtTnVsbF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFNldC1OdWxsX0ZhbHNlLVJhc3Rlcl90YWcwQEBcIjogXCJFbnRyw6llIGRvbnQgbGVzIHZhbGV1cnMgc2Vyb250IHV0aWxpc8OpZXMgZW4gdGFudCBxdWUgdmFsZXVycyBkZSBwaXhlbCBlbiBzb3J0aWUgc2kgbGEgY29uZGl0aW9uIGVzdCBmYXVzc2UuIElsIHBldXQgc+KAmWFnaXIgZOKAmXVuIHJhc3RlciBkZSB0eXBlIGVudGllciwgw6AgdmlyZ3VsZSBmbG90dGFudGUgb3UgZOKAmXVuZSB2YWxldXIgY29uc3RhbnRlLlwiLFxuXHRcIkBAU2V0LU51bGxfUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBlbiBlbnRyw6llIHF1aSByZXByw6lzZW50ZSBsZSByw6lzdWx0YXQgYm9vbMOpZW4gZOKAmXVuZSBmb25jdGlvbiByYXN0ZXIgbWF0aMOpbWF0aXF1ZSBsb2dpcXVlLiBMZXMgdmFsZXVycyBzb250IMOpZ2FsZXMgw6AgMSAocG91ciBWcmFpKSBvdSDDoCAwIChwb3VyIEZhdXgpLiBJbCBwZXV0IHMnYWdpciBkJ3VuIGVudGllciBvdSBkJ3VuIHJhc3RlciBlbiB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfQWx0aXR1ZGVfdGFnMEBAXCI6IFwiTCdhbHRpdHVkZSByZXByw6lzZW50ZSBsJ2FuZ2xlIHNvbGFpcmUgZGUgbCdhbHRpdHVkZSBhdS1kZXNzdXMgZGUgbGEgbGlnbmUgZCdob3Jpem9uIGV0IHMnw6l0ZW5kIGRlIDAgw6AgOTAgZGVncsOpcy4gVW5lIHZhbGV1ciBkZSAwIGRlZ3LDqXMgaW5kaXF1ZSBxdWUgbGUgc29sZWlsIGVzdCBzdXIgbCdob3Jpem9uLCBjJ2VzdC3DoC1kaXJlIHN1ciBsZSBtw6ptZSBwbGFuIGhvcml6b250YWwgcXVlIGxlIGNhZHJlIGRlIHLDqWbDqXJlbmNlLiBVbmUgdmFsZXVyIGRlIDkwIGRlZ3LDqXMgaW5kaXF1ZSBxdWUgbGUgc29sZWlsIGVzdCBkaXJlY3RlbWVudCBhdS1kZXNzdXMuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgZGUgNDUgZGVncsOpcywgYXUtZGVzc3VzIGRlIGwnaG9yaXpvbi5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfQXppbXV0aF90YWcwQEBcIjogXCJMYSBwcm9wcmnDqXTDqSBBemltdXQgZMOpZmluaXQgbGEgcG9zaXRpb24gcmVsYXRpdmUgZHUgc29sZWlsIHBhciByYXBwb3J0IMOgIGwnaG9yaXpvbiAoZW4gZGVncsOpcykuIENldHRlIHBvc2l0aW9uIGVzdCBpbmRpcXXDqWUgcGFyIGwnYW5nbGUgZHUgc29sZWlsIG1lc3Vyw6kgZGFucyBsZSBzZW5zIGhvcmFpcmUgw6AgcGFydGlyIGR1IG5vcmQuIFVuIGF6aW11dCBkZSAwIGRlZ3LDqSBpbmRpcXVlIGxlIE5vcmQsIGwnRXN0IGVzdCDDoCA5MCBkZWdyw6lzLCBsZSBTdWQgw6AgMTgwIGRlZ3LDqXMgZXQgbCdPdWVzdCDDoCAyNzAgZGVncsOpcy5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfQ29sb3ItU2NoZW1lLVR5cGVfdGFnMEBAXCI6IFwiU3DDqWNpZmlleiBzaSB1biBkw6lncmFkw6kgZGUgY291bGV1cnMgb3UgdW5lIHBhbGV0dGUgZGUgY291bGV1cnMgc2VyYSB1dGlsaXPDqSBwb3VyIHJlcHLDqXNlbnRlciBsZSByZWxpZWYgb21icsOpLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9Db2xvci1TY2hlbWUtVHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPkTDqWdyYWTDqSBkZSBjb3VsZXVyczwvc3Ryb25nPiA6IGxvcnNxdWUgdm91cyBjaG9pc2lzc2V6IDxzdHJvbmc+RMOpZ3JhZMOpIGRlIGNvdWxldXJzPC9zdHJvbmc+LCB2b3VzIMOqdGVzIGludml0w6kgw6Agc8OpbGVjdGlvbm5lciBsZSBkw6lncmFkw6kgZGUgY291bGV1cnMgYXBwcm9wcmnDqS5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfQ29sb3ItU2NoZW1lLVR5cGVfdGFnNUBAXCI6IFwiPHN0cm9uZz5QYWxldHRlIGRlIGNvdWxldXJzPC9zdHJvbmc+IDogbG9yc3F1ZSB2b3VzIGNob2lzaXNzZXogPHN0cm9uZz5QYWxldHRlIGRlIGNvdWxldXJzPC9zdHJvbmc+LCB2b3VzIMOqdGVzIGludml0w6kgw6Agc3DDqWNpZmllciBsZSBmaWNoaWVyIGRlIHBhbGV0dGUgZGUgY291bGV1cnMgw6AgdXRpbGlzZXIuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMEBAXCI6IFwiU3DDqWNpZmlleiBzaSBs4oCZaW50ZXJwb2xhdGlvbiBkZXMgcGl4ZWxzIGRlIHRyb27Dp29uIHBhciBkw6lmYXV0IGVzdCBkw6lzYWN0aXbDqWUuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMUBAXCI6IFwiTm9uIGNvY2jDqSA6IGxlIHLDqcOpY2hhbnRpbGxvbm5hZ2UgYmlsaW7DqWFpcmUgZXN0IGFwcGxpcXXDqSB1bmlmb3Jtw6ltZW50IHBvdXIgcsOpw6ljaGFudGlsbG9ubmVyIGxlIHJlbGllZiBvbWJyw6kuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMkBAXCI6IFwiQ29jaMOpIDogbGUgcsOpw6ljaGFudGlsbG9ubmFnZSBiaWxpbsOpYWlyZSBlc3QgdXRpbGlzw6kgYXUgc2VpbiBkdSByZWxpZWYgb21icsOpLCBzYXVmIGxlIGxvbmcgZGVzIHRyb27Dp29ucyBkZXMgcmFzdGVycyBvdSDDoCBjw7R0w6kgZGVzIHBpeGVscyBkZSB2YWxldXIgTm9EYXRhLiBDZXMgcGl4ZWxzIHNvbnQgcmVuc2VpZ27DqXMgYXZlYyBOb0RhdGEsIGNhciBpbHMgcsOpZHVpc2VudCBsZXMgZWZmZXRzIGRlIHRyb27Dp29ucyBhYnJ1cHRzIHBvdXZhbnQgc2UgcHJvZHVpcmUuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnM0BAXCI6IFwiQ2V0dGUgb3B0aW9uIMOpdml0ZSBsZXMgYXJ0ZWZhY3RzIGRlIHLDqcOpY2hhbnRpbGxvbm5hZ2UgcXVpIHBldXZlbnQgc2UgcHJvZHVpcmUgbGUgbG9uZyBkZXMgdHJvbsOnb25zIGQndW4gcmFzdGVyLiBMZXMgcGl4ZWxzIGVuIHNvcnRpZSBsZSBsb25nIGR1IHRyb27Dp29uIGQndW4gcmFzdGVyIG91IMOgIGPDtHTDqSBkZSBwaXhlbHMgc2FucyB2YWxldXIgc29udCByZW5zZWlnbsOpcyBhdmVjIE5vRGF0YS4gSWwgZXN0IHBhciBjb25zw6lxdWVudCByZWNvbW1hbmTDqSBkJ3V0aWxpc2VyIGNldHRlIG9wdGlvbiB1bmlxdWVtZW50IGxvcnNxdWUgZCdhdXRyZXMgcmFzdGVycyBhdmVjIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgc29udCBkaXNwb25pYmxlcy4gTG9yc3F1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHNvbnQgZGlzcG9uaWJsZXMsIGNlcyBzdXJmYWNlcyBkZSBOb0RhdGEgYWZmaWNoZW50IGxlcyBwaXhlbHMgc3VwZXJwb3PDqXMgYXUgbGlldSBkJ8OqdHJlIHZpZGVzLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9SYXN0ZXJfdGFnMEBAXCI6IFwiTGUgcmFzdGVyIGTigJlhbHRpdHVkZSBlbiBlbnRyw6llLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9TY2FsaW5nX3RhZzBAQFwiOiBcIkxlIHLDqXN1bHRhdCBvbWJyw6kgZXN0IG1pcyDDoCBsJ8OpY2hlbGxlIGR5bmFtaXF1ZW1lbnQgZW4gYWp1c3RhbnQgbGUgZmFjdGV1ciB6IGdyw6JjZSDDoCBsJ3VuZSBkZSBkZXV4IG9wdGlvbnMgOlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9TY2FsaW5nX3RhZzFAQFwiOiBcIjxzdHJvbmc+QXVjdW5lPC9zdHJvbmc+IDogYXVjdW5lIG1pc2Ugw6AgbOKAmcOpY2hlbGxlIG7igJllc3QgYXBwbGlxdcOpZS4gQ2V0dGUgb3B0aW9uIGVzdCBpZMOpYWxlIHBvdXIgdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciB1bmlxdWUgcXVpIGNvdXZyZSB1bmUgem9uZSBsb2NhbGUuIENldHRlIG9wdGlvbiBu4oCZZXN0IHBhcyByZWNvbW1hbmTDqWUgcG91ciBsZXMgamV1eCBkZSBkb25uw6llcyBtb25kaWF1eCBkb250IGzigJnDqWzDqXZhdGlvbiB2YXJpZSBiZWF1Y291cCBvdSBwb3VyIGxlcyBjYXJ0ZXMgw6AgcGx1c2lldXJzIMOpY2hlbGxlcywgY2FyIGVsbGUgZ8OpbsOocmUgdW4gcmVsaWVmIGRlIHRlcnJhaW4gYXZlYyBkZXMgdmFyaWF0aW9ucyByZXN0cmVpbnRlcyDDoCBkZSBwZXRpdGVzIMOpY2hlbGxlcy5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfU2NhbGluZ190YWczQEBcIjogXCI8c3Ryb25nPkFqdXN0w6k8L3N0cm9uZz4gOiBhcHBsaXF1ZSB1biBhanVzdGVtZW50IG5vbiBsaW7DqWFpcmUgZW4gdXRpbGlzYW50IGxlcyB2YWxldXJzIGRlIDxzdHJvbmc+UHVpc3NhbmNlIGRlIHRhaWxsZSBkZSBwaXhlbDwvc3Ryb25nPiBldCBkZSA8c3Ryb25nPkZhY3RldXIgZGUgdGFpbGxlIGRlIHBpeGVsPC9zdHJvbmc+IHBhciBkw6lmYXV0LCBxdWkgdGllbm5lbnQgY29tcHRlIGRlcyBjaGFuZ2VtZW50cyBk4oCZYWx0aXR1ZGUgKMOpY2hlbGxlKSBsb3JzIGTigJl1biB6b29tIGF2YW50IG91IGFycmnDqHJlLiBM4oCZb3B0aW9uIDxzdHJvbmc+QWp1c3TDqTwvc3Ryb25nPiBlc3QgcmVjb21tYW5kw6llIGVuIGNhcyBk4oCZdXRpbGlzYXRpb24gZOKAmXVuIGpldSBkZSBkb25uw6llcyBtb25kaWFsLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9aLUZhY3Rvcl90YWcwQEBcIjogXCJMZSBmYWN0ZXVyIFogZXN0IHVuIGZhY3RldXIgZCfDqWNoZWxsZSB1dGlsaXPDqSBwb3VyIGNvbnZlcnRpciBsZXMgdmFsZXVycyBkJ2FsdGl0dWRlIGRhbnMgZGV1eCBidXRzIDpcIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfWi1GYWN0b3JfdGFnMUBAXCI6IFwicG91ciBjb252ZXJ0aXIgbGVzIHVuaXTDqXMgYWx0aW3DqXRyaXF1ZXMgKHRlbGxlcyBxdWUgbGVzIG3DqHRyZXMgb3UgbGVzIHBpZWRzKSBlbiB1bml0w6lzIGRlIGNvb3Jkb25uw6llcyBob3Jpem9udGFsZXMgZHUgamV1IGRlIGRvbm7DqWVzLCBxdWkgcGV1dmVudCDDqnRyZSBkZXMgcGllZHMsIGRlcyBtw6h0cmVzIG91IGRlcyBkZWdyw6lzIDtcIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfWi1GYWN0b3JfdGFnMkBAXCI6IFwicG91ciBham91dGVyIHVuZSBleGFnw6lyYXRpb24gdmVydGljYWxlIGNvbW1lIGVmZmV0IHZpc3VlbC5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfWi1GYWN0b3JfdGFnM0BAXCI6IFwiTGUgcsOpc3VsdGF0IG9tYnLDqSBlc3QgbWlzIMOgIGwnw6ljaGVsbGUgZHluYW1pcXVlbWVudCBlbiBhanVzdGFudCBsZSBmYWN0ZXVyIHogZ3LDomNlIMOgIGwndW5lIGRlIGRldXggb3B0aW9ucyA6XCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1otRmFjdG9yX3RhZzRAQFwiOiBcIjxzdHJvbmc+QXVjdW5lPC9zdHJvbmc+IDogYXVjdW5lIG1pc2Ugw6AgbOKAmcOpY2hlbGxlIG7igJllc3QgYXBwbGlxdcOpZS4gQ2V0dGUgb3B0aW9uIGVzdCBpZMOpYWxlIHBvdXIgdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciB1bmlxdWUgcXVpIGNvdXZyZSB1bmUgem9uZSBsb2NhbGUuIENldHRlIG9wdGlvbiBu4oCZZXN0IHBhcyByZWNvbW1hbmTDqWUgcG91ciBsZXMgamV1eCBkZSBkb25uw6llcyBtb25kaWF1eCBkb250IGzigJnDqWzDqXZhdGlvbiB2YXJpZSBiZWF1Y291cCBvdSBwb3VyIGxlcyBjYXJ0ZXMgw6AgcGx1c2lldXJzIMOpY2hlbGxlcywgY2FyIGVsbGUgZ8OpbsOocmUgdW4gcmVsaWVmIGRlIHRlcnJhaW4gYXZlYyBkZXMgdmFyaWF0aW9ucyByZXN0cmVpbnRlcyDDoCBkZSBwZXRpdGVzIMOpY2hlbGxlcy5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfWi1GYWN0b3JfdGFnNkBAXCI6IFwiPHN0cm9uZz5BanVzdMOpPC9zdHJvbmc+IDogYXBwbGlxdWUgdW4gYWp1c3RlbWVudCBub24gbGluw6lhaXJlIGVuIHV0aWxpc2FudCBsZXMgdmFsZXVycyBkZSA8c3Ryb25nPlB1aXNzYW5jZSBkZSB0YWlsbGUgZGUgcGl4ZWw8L3N0cm9uZz4gZXQgZGUgPHN0cm9uZz5GYWN0ZXVyIGRlIHRhaWxsZSBkZSBwaXhlbDwvc3Ryb25nPiBwYXIgZMOpZmF1dCwgcXVpIHRpZW5uZW50IGNvbXB0ZSBkZXMgY2hhbmdlbWVudHMgZOKAmWFsdGl0dWRlICjDqWNoZWxsZSkgbG9ycyBk4oCZdW4gem9vbSBhdmFudCBvdSBhcnJpw6hyZS4gTOKAmW9wdGlvbiA8c3Ryb25nPkFqdXN0w6k8L3N0cm9uZz4gZXN0IHJlY29tbWFuZMOpZSBlbiBjYXMgZOKAmXV0aWxpc2F0aW9uIGTigJl1biBqZXUgZGUgZG9ubsOpZXMgbW9uZGlhbC5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfaGlsbHNoYWRldHlwZV90YWcwQEBcIjogXCJDb250csO0bGUgbGEgc291cmNlIGTigJnDqWNsYWlyYWdlIGRlIGzigJlvbWJyYWdlLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9oaWxsc2hhZGV0eXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+VHJhZGl0aW9ubmVsPC9zdHJvbmc+IDogY2FsY3VsZSBs4oCZb21icmFnZSDDoCBwYXJ0aXIgZOKAmXVuZSBzZXVsZSBkaXJlY3Rpb24gZOKAmcOpY2xhaXJhZ2UuIFZvdXMgcG91dmV6IGTDqWZpbmlyIGxlcyBvcHRpb25zIDxzdHJvbmc+QXppbXV0PC9zdHJvbmc+IGV0IDxzdHJvbmc+QWx0aXR1ZGU8L3N0cm9uZz4gcG91ciBjb250csO0bGVyIGzigJllbXBsYWNlbWVudCBkZSBsYSBzb3VyY2UgZOKAmcOpY2xhaXJhZ2UuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX2hpbGxzaGFkZXR5cGVfdGFnMkBAXCI6IFwiPHN0cm9uZz5NdWx0aWRpcmVjdGlvbm5lbDwvc3Ryb25nPiA6IGFzc29jaWUgbGEgbHVtacOocmUgZGUgcGx1c2lldXJzIHNvdXJjZXMgcG91ciByZXByw6lzZW50ZXIgdW5lIHZpc3VhbGlzYXRpb24gb3B0aW1pc8OpZSBkdSB0ZXJyYWluLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9QU1Bvd2VyX3RhZzBAQFwiOiBcIkzigJlvcHRpb24gPHN0cm9uZz5QdWlzc2FuY2UgZGUgdGFpbGxlIGRlIHBpeGVsPC9zdHJvbmc+IHRpZW50IGNvbXB0ZSBkZXMgY2hhbmdlbWVudHMgZOKAmWFsdGl0dWRlIChvdSBk4oCZw6ljaGVsbGUpIMOgIG1lc3VyZSBxdWUgZGVzIHpvb21zIGF2YW50IG91IGFycmnDqHJlIHNvbnQgYXBwbGlxdcOpcyBzdXIgbOKAmWFmZmljaGFnZSBjYXJ0b2dyYXBoaXF1ZS4gSWwgc+KAmWFnaXQgZGUgbOKAmWV4cG9zYW50IGFwcGxpcXXDqSBhdSB0ZXJtZSBkZSB0YWlsbGUgZGUgcGl4ZWwgZGFucyBs4oCZw6lxdWF0aW9uIHF1aSBjb250csO0bGUgbGEgZnLDqXF1ZW5jZSDDoCBsYXF1ZWxsZSBsZSA8c3Ryb25nPkZhY3RldXLCoFo8L3N0cm9uZz4gY2hhbmdlIHBvdXIgw6l2aXRlciBsZXMgcGVydGVzIGRlIHJlbGllZiBzaWduaWZpY2F0aXZlcy5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfUFNQb3dlcl90YWcxQEBcIjogXCJDZSBwYXJhbcOodHJlIGVzdCB2YWxpZGUgdW5pcXVlbWVudCBzaSBsZSB0eXBlIDxzdHJvbmc+TWlzZSDDoCBs4oCZw6ljaGVsbGU8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+QWp1c3TDqTwvc3Ryb25nPi4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdMKgMCw2NjQuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1BTWkZhY3Rvcl90YWcwQEBcIjogXCJM4oCZb3B0aW9uIDxzdHJvbmc+RmFjdGV1ciBkZSB0YWlsbGUgZGUgcGl4ZWw8L3N0cm9uZz4gdGllbnQgY29tcHRlIGRlcyBjaGFuZ2VtZW50cyBk4oCZw6ljaGVsbGUgw6AgbWVzdXJlIHF1ZSBkZXMgem9vbXMgYXZhbnQgb3UgYXJyacOocmUgc29udCBhcHBsaXF1w6lzIHN1ciBs4oCZYWZmaWNoYWdlIGNhcnRvZ3JhcGhpcXVlLiBFbGxlIGNvbnRyw7RsZSBsYSBmcsOpcXVlbmNlIMOgIGxhcXVlbGxlIGxlIDxzdHJvbmc+RmFjdGV1csKgWjwvc3Ryb25nPiBjaGFuZ2UuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1BTWkZhY3Rvcl90YWcxQEBcIjogXCJDZSBwYXJhbcOodHJlIGVzdCB2YWxpZGUgdW5pcXVlbWVudCBzaSBsZSB0eXBlIDxzdHJvbmc+TWlzZSDDoCBs4oCZw6ljaGVsbGU8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+QWp1c3TDqTwvc3Ryb25nPi4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdMKgMCwwMjQuXCIsXG5cdFwiQEBTaW5fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBTaW5fQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFNpbl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAU2luX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBTaW5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFNpbl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFNpbl9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBTaW5fRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFNpbl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBTaW5fRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFNpbl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFNpbl9SYXN0ZXJfdGFnMEBAXCI6IFwiRW50csOpZSBwb3VyIGxhcXVlbGxlIGNhbGN1bGVyIGxlcyB2YWxldXJzIGRlIHNpbnVzLlwiLFxuXHRcIkBAU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggZGUgOiB1dGlsaXNlIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBTaW5IX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQFNpbkhfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFNpbkhfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAU2luSF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAU2luSF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFNpbkhfUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgcG91ciBsYXF1ZWxsZSBjYWxjdWxlciBsZXMgdmFsZXVycyBkZSBzaW51cyBoeXBlcmJvbGlxdWUuXCIsXG5cdFwiQEBTaW5rX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSBxdWkgbW9udHJlIGxhIGRpcmVjdGlvbiBkdSBmbHV4IHNvcnRhbnQgZGUgY2hhcXVlIGNlbGx1bGUuXCIsXG5cdFwiQEBTaW5rX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcxQEBcIjogXCJMZSByYXN0ZXIgZGUgZGlyZWN0aW9uIGRlIGZsdXggcGV1dCDDqnRyZSBjcsOpw6kgZW4gZXjDqWN1dGFudCBsYSBmb25jdGlvbiA8c3Ryb25nPkRpcmVjdGlvbiBkZSBmbHV4PC9zdHJvbmc+LlwiLFxuXHRcIkBAU2xvcGVfREVNX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBk4oCZYWx0aXR1ZGUgZW4gZW50csOpZS5cIixcblx0XCJAQFNsb3BlX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMEBAXCI6IFwiQ2V0dGUgb3B0aW9uIMOpdml0ZSBsZXMgYXJ0ZWZhY3RzIGRlIHLDqcOpY2hhbnRpbGxvbm5hZ2UgcXVpIHBldXZlbnQgc2UgcHJvZHVpcmUgbGUgbG9uZyBkZXMgdHJvbsOnb25zIGQndW4gcmFzdGVyLiBMZXMgcGl4ZWxzIGVuIHNvcnRpZSBsZSBsb25nIGR1IHRyb27Dp29uIGQndW4gcmFzdGVyIG91IMOgIGPDtHTDqSBkZSBwaXhlbHMgc2FucyB2YWxldXIgc29udCByZW5zZWlnbsOpcyBhdmVjIE5vRGF0YS4gSWwgZXN0IHBhciBjb25zw6lxdWVudCByZWNvbW1hbmTDqSBkJ3V0aWxpc2VyIGNldHRlIG9wdGlvbiB1bmlxdWVtZW50IGxvcnNxdWUgZCdhdXRyZXMgcmFzdGVycyBhdmVjIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgc29udCBkaXNwb25pYmxlcy4gTG9yc3F1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHNvbnQgZGlzcG9uaWJsZXMsIGNlcyBzdXJmYWNlcyBkZSBOb0RhdGEgYWZmaWNoZW50IGxlcyBwaXhlbHMgc3VwZXJwb3PDqXMgYXUgbGlldSBkJ8OqdHJlIHZpZGVzLlwiLFxuXHRcIkBAU2xvcGVfRGlzYWJsZS1kZWZhdWx0LWVkZ2UtcGl4ZWwtaW50ZXJwb2xhdGlvbl90YWcxQEBcIjogXCJOb24gc8OpbGVjdGlvbm7DqWUgOiBsZSByw6ktw6ljaGFudGlsbG9ubmFnZSBiaWxpbsOpYWlyZSBzZXJhIGFwcGxpcXXDqSB1bmlmb3Jtw6ltZW50IHBvdXIgcsOpLcOpY2hhbnRpbGxvbm5lciBsYSBwZW50ZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFNsb3BlX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMkBAXCI6IFwiU8OpbGVjdGlvbm7DqWUgOiBsZSByw6ktw6ljaGFudGlsbG9ubmFnZSBiaWxpbsOpYWlyZSBzZXJhIHV0aWxpc8OpIGRhbnMgbGEgcGVudGUsIHNhdWYgbGUgbG9uZyBkZXMgbGltaXRlcyBkZXMgcmFzdGVycyBvdSBlbiBkZWhvcnMgZGVzIHBpeGVscyBkZSB2YWxldXIgTm9EYXRhLiBDZXMgcGl4ZWxzIHNvbnQgcmVuc2VpZ27DqXMgYXZlYyBOb0RhdGEsIGNhciBpbHMgcsOpZHVpc2VudCBsZXMgZWZmZXRzIGRlIHRyb27Dp29ucyBhYnJ1cHRzIHBvdXZhbnQgc2UgcHJvZHVpcmUuXCIsXG5cdFwiQEBTbG9wZV9TY2FsaW5nX3RhZzBAQFwiOiBcIkzigJlpbmNsaW5haXNvbiBkZSBsYSBwZW50ZSBwZXV0IMOqdHJlIGfDqW7DqXLDqWUgc291cyBsYSBmb3JtZSBk4oCZdW5lIHZhbGV1ciBleHByaW3DqWUgZW4gZGVncsOpcyBvdSBlbiBwb3VyY2VudGFnZSBk4oCZw6lsw6l2YXRpb24uIElsIGV4aXN0ZSB0cm9pcyBvcHRpb25zIHBvdXIgbGEgPHN0cm9uZz5NaXNlIMOgIGzigJnDqWNoZWxsZTwvc3Ryb25nPiA6XCIsXG5cdFwiQEBTbG9wZV9TY2FsaW5nX3RhZzNAQFwiOiBcIjxzdHJvbmc+RGVncsOpPC9zdHJvbmc+IDogbOKAmWluY2xpbmFpc29uIGRlIGxhIHBlbnRlIGVzdCBjYWxjdWzDqWUgZW4gZGVncsOpcy4gTGVzIHZhbGV1cnMgc29udCBjb21wcmlzZXMgZW50cmUgMCBldCA5MC5cIixcblx0XCJAQFNsb3BlX1NjYWxpbmdfdGFnNUBAXCI6IFwiPHN0cm9uZz5Qb3VyY2VudGFnZSBk4oCZw6lsw6l2YXRpb248L3N0cm9uZz4gOiBs4oCZaW5jbGluYWlzb24gZGUgbGEgcGVudGUgZXN0IGNhbGN1bMOpZSBlbiB2YWxldXJzIGRlIHBvdXJjZW50YWdlLiBMZXMgdmFsZXVycyBzb250IGNvbXByaXNlcyBlbnRyZSAwIGV0IGzigJlpbmZpbmkuIFVuZSBzdXJmYWNlIHBsYW5lIGNvcnJlc3BvbmQgw6AgdW4gcG91cmNlbnRhZ2UgZOKAmcOpbMOpdmF0aW9uIGRlIDAgcG91ciBjZW50IGV0IHVuZSBzdXJmYWNlIMOgIDQ1IGRlZ3LDqXMgw6AgdW4gcG91cmNlbnRhZ2UgZOKAmcOpbMOpdmF0aW9uIGRlIDEwMCBwb3VyIGNlbnQuIEF1IGZ1ciBldCDDoCBtZXN1cmUgcXVlIGxhIHN1cmZhY2UgZGV2aWVudCBkZSBwbHVzIGVuIHBsdXMgdmVydGljYWxlLCBsZSBwb3VyY2VudGFnZSBk4oCZw6lsw6l2YXRpb24gYXVnbWVudGUuXCIsXG5cdFwiQEBTbG9wZV9TY2FsaW5nX3RhZzdAQFwiOiBcIjxzdHJvbmc+TWlzZSDDoCBs4oCZw6ljaGVsbGU8L3N0cm9uZz4gOiBs4oCZaW5jbGluYWlzb24gZGUgbGEgcGVudGUgZXN0IGNhbGN1bMOpZSBkZSBsYSBtw6ptZSBtYW5pw6hyZSBxdeKAmWF2ZWMgREVHUsOJLCBtYWlzIGxlIGZhY3RldXIgeiBlc3QgYWp1c3TDqSBwb3VyIGzigJnDqWNoZWxsZS4gQ2V0dGUgb3B0aW9uIHV0aWxpc2UgbGVzIHZhbGV1cnMgZGUgPHN0cm9uZz5QdWlzc2FuY2UgZGUgdGFpbGxlIGRlIHBpeGVsPC9zdHJvbmc+IGV0IGRlIDxzdHJvbmc+RmFjdGV1ciBkZSB0YWlsbGUgZGUgcGl4ZWw8L3N0cm9uZz4sIHF1aSB0aWVubmVudCBjb21wdGUgZGVzIGNoYW5nZW1lbnRzIGRlIHLDqXNvbHV0aW9uICjDqWNoZWxsZSkgbG9ycyBk4oCZdW4gem9vbSBhdmFudCBvdSBhcnJpw6hyZS4gRWxsZSBlc3QgcmVjb21tYW5kw6llIGxvcnMgZGUgbOKAmXV0aWxpc2F0aW9uIGRlIGpldXggZGUgZG9ubsOpZXMgYXUgbml2ZWF1IG1vbmRpYWwsIHBsdXMgcGFydGljdWxpw6hyZW1lbnQgc2kgdm91cyB1dGlsaXNleiB1bmUgcGVudGUgY29tbWUgc3VyZmFjZSBkZSB2aXN1YWxpc2F0aW9uLlwiLFxuXHRcIkBAU2xvcGVfU2NhbGluZ190YWcxM0BAXCI6IFwiTGUgZmFjdGV1ciB6IGVzdCBhanVzdMOpIMOgIGwnYWlkZSBkZSBsJ8OpcXVhdGlvbiBzdWl2YW50ZSA6XCIsXG5cdFwiQEBTbG9wZV9TY2FsaW5nX3RhZzE0QEBcIjogXCJGYWN0ZXVyIFogYWp1c3TDqSA9IChmYWN0ZXVyIFopICsgKHRhaWxsZSBkZSBwaXhlbClcIixcblx0XCJAQFNsb3BlX1NjYWxpbmdfdGFnMTVAQFwiOiBcInjCoChGYWN0ZXVyIGRlIHRhaWxsZSBkZSBwaXhlbClcIixcblx0XCJAQFNsb3BlX1NjYWxpbmdfdGFnMTZAQFwiOiBcIlB1aXNzYW5jZSBkZSBsYSB0YWlsbGUgZGUgcGl4ZWxcIixcblx0XCJAQFNsb3BlX1otRmFjdG9yX3RhZzBAQFwiOiBcIkxlIDxzdHJvbmc+RmFjdGV1ciBaPC9zdHJvbmc+IGVzdCB1biBmYWN0ZXVyIGTigJnDqWNoZWxsZSB1dGlsaXPDqSBwb3VyIGNvbnZlcnRpciBsZXMgdmFsZXVycyBk4oCZw6lsw6l2YXRpb24gZGFucyBkZXV4IGJ1dHMgOlwiLFxuXHRcIkBAU2xvcGVfWi1GYWN0b3JfdGFnM0BAXCI6IFwicG91ciBjb252ZXJ0aXIgbGVzIHVuaXTDqXMgYWx0aW3DqXRyaXF1ZXMgKHRlbGxlcyBxdWUgbGVzIG3DqHRyZXMgb3UgbGVzIHBpZWRzKSBlbiB1bml0w6lzIGRlIGNvb3Jkb25uw6llcyBob3Jpem9udGFsZXMgZHUgamV1IGRlIGRvbm7DqWVzLCBxdWkgcGV1dmVudCDDqnRyZSBkZXMgcGllZHMsIGRlcyBtw6h0cmVzIG91IGRlcyBkZWdyw6lzIDtcIixcblx0XCJAQFNsb3BlX1otRmFjdG9yX3RhZzRAQFwiOiBcInBvdXIgYWpvdXRlciB1bmUgZXhhZ8OpcmF0aW9uIHZlcnRpY2FsZSBjb21tZSBlZmZldCB2aXN1ZWwuXCIsXG5cdFwiQEBTbG9wZV9QU1Bvd2VyX3RhZzBAQFwiOiBcIkzigJlvcHRpb24gPHN0cm9uZz5QdWlzc2FuY2UgZGUgdGFpbGxlIGRlIHBpeGVsPC9zdHJvbmc+IHRpZW50IGNvbXB0ZSBkZXMgY2hhbmdlbWVudHMgZOKAmWFsdGl0dWRlIChvdSBk4oCZw6ljaGVsbGUpIMOgIG1lc3VyZSBxdWUgZGVzIHpvb21zIGF2YW50IG91IGFycmnDqHJlIHNvbnQgYXBwbGlxdcOpcyBzdXIgbOKAmWFmZmljaGFnZSBjYXJ0b2dyYXBoaXF1ZS4gSWwgc+KAmWFnaXQgZGUgbOKAmWV4cG9zYW50IGFwcGxpcXXDqSBhdSB0ZXJtZSBkZSB0YWlsbGUgZGUgcGl4ZWwgZGFucyBs4oCZw6lxdWF0aW9uIHF1aSBjb250csO0bGUgbGEgZnLDqXF1ZW5jZSDDoCBsYXF1ZWxsZSBsZSA8c3Ryb25nPkZhY3RldXLCoFo8L3N0cm9uZz4gY2hhbmdlIHBvdXIgw6l2aXRlciBsZXMgcGVydGVzIGRlIHJlbGllZiBzaWduaWZpY2F0aXZlcy5cIixcblx0XCJAQFNsb3BlX1BTUG93ZXJfdGFnMUBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBlc3QgdmFsaWRlIHVuaXF1ZW1lbnQgc2kgbGUgdHlwZSA8c3Ryb25nPk1pc2Ugw6AgbOKAmcOpY2hlbGxlPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPkF2ZWMgbWlzZSDDoCBs4oCZw6ljaGVsbGU8L3N0cm9uZz4uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3TCoDAsNjY0LlwiLFxuXHRcIkBAU2xvcGVfUFNaRmFjdG9yX3RhZzBAQFwiOiBcIkzigJlvcHRpb24gPHN0cm9uZz5GYWN0ZXVyIGRlIHRhaWxsZSBkZSBwaXhlbDwvc3Ryb25nPiB0aWVudCBjb21wdGUgZGVzIGNoYW5nZW1lbnRzIGTigJnDqWNoZWxsZSDDoCBtZXN1cmUgcXVlIGRlcyB6b29tcyBhdmFudCBvdSBhcnJpw6hyZSBzb250IGFwcGxpcXXDqXMgc3VyIGzigJlhZmZpY2hhZ2UgY2FydG9ncmFwaGlxdWUuIEVsbGUgY29udHLDtGxlIGxhIGZyw6lxdWVuY2Ugw6AgbGFxdWVsbGUgbGUgPHN0cm9uZz5GYWN0ZXVywqBaPC9zdHJvbmc+IGNoYW5nZS5cIixcblx0XCJAQFNsb3BlX1BTWkZhY3Rvcl90YWcxQEBcIjogXCJDZSBwYXJhbcOodHJlIGVzdCB2YWxpZGUgdW5pcXVlbWVudCBzaSBsZSB0eXBlIDxzdHJvbmc+TWlzZSDDoCBs4oCZw6ljaGVsbGU8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+QXZlYyBtaXNlIMOgIGzigJnDqWNoZWxsZTwvc3Ryb25nPi4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdMKgMCwwMjQuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfRmxvdy1BY2N1bXVsYXRpb24tUmFzdGVyX3RhZzBAQFwiOiBcIkNvdWNoZSByYXN0ZXIgZOKAmWFjY3VtdWxhdGlvbiBkZSBmbHV4IGVuIGVudHLDqWUuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfRmxvdy1BY2N1bXVsYXRpb24tUmFzdGVyX3RhZzFAQFwiOiBcIkNlbHVpLWNpIHBldXQgw6p0cmUgY3LDqcOpIGF2ZWMgbGEgZm9uY3Rpb24gPHN0cm9uZz5BY2N1bXVsYXRpb24gZGUgZmx1eDwvc3Ryb25nPi5cIixcblx0XCJAQFNuYXAtUG91ci1Qb2ludF9Qb3VyLVBvaW50LUZpZWxkX3RhZzBAQFwiOiBcIkNoYW1wIHV0aWxpc8OpIHBvdXIgYXR0cmlidWVyIGRlcyB2YWxldXJzIGF1eCBlbXBsYWNlbWVudHMgZGUgcG9pbnRzIGQnw6ljb3VsZW1lbnQuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfUG91ci1Qb2ludC1SYXN0ZXJfdGFnMEBAXCI6IFwiRW1wbGFjZW1lbnRzIGRlIHBvaW50IGQnw6ljb3VsZW1lbnQgZW4gZW50csOpZSBxdWkgc2Vyb250IGNhcHR1csOpcy5cIixcblx0XCJAQFNuYXAtUG91ci1Qb2ludF9Qb3VyLVBvaW50LVJhc3Rlcl90YWcxQEBcIjogXCJQb3VyIHVuZSBjb3VjaGUgcmFzdGVyIGVuIGVudHLDqWUsIHRvdXRlcyBsZXMgY2VsbHVsZXMgZG9udCBsYSB2YWxldXIgbuKAmWVzdCBwYXMgTm9EYXRhIChxdWkgb250IHVuZSB2YWxldXIpIHNvbnQgY29uc2lkw6lyw6llcyBjb21tZSBkZXMgcG9pbnRzIGTigJnDqWNvdWxlbWVudCBldCBzb250IGNhcHR1csOpZXMuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfU25hcC1EaXN0YW5jZV90YWcwQEBcIjogXCJEaXN0YW5jZSBtYXhpbWFsZSAoZW4gdW5pdMOpcyBkZSBjYXJ0ZSkgZGUgcmVjaGVyY2hlIGTigJl1bmUgY2VsbHVsZSBk4oCZYWNjdW11bGF0aW9uIGRlIGZsdXggcGx1cyDDqWxldsOpZS5cIixcblx0XCJAQFNwZWNrbGVfQWRkaXRpdmUtTm9pc2UtTWVhbl90YWcwQEBcIjogXCJTcMOpY2lmaWUgbGEgdmFsZXVyIG1veWVubmUgZHUgYnJ1aXQgYWRkaXRpZi4gVW5lIHZhbGV1ciBkZSBtb3llbm5lIGRlIGJydWl0IHBsdXMgw6lsZXbDqWUgcHJvZHVpdCB1biBsaXNzYWdlIG1vaW5kcmUsIHRhbmRpcyBxdeKAmXVuZSB2YWxldXIgcGx1cyBwZXRpdGUgZ8OpbsOocmUgdW4gbGlzc2FnZSBwbHVzIGltcG9ydGFudC5cIixcblx0XCJAQFNwZWNrbGVfQWRkaXRpdmUtTm9pc2UtTWVhbl90YWcxQEBcIjogXCJDZSBwYXJhbcOodHJlIGVzdCB2YWxpZGUgdW5pcXVlbWVudCBzaSBs4oCZb3B0aW9uIDxzdHJvbmc+VHlwZSBkZSBmaWx0cmU8L3N0cm9uZz4gZXN0IGTDqWZpbmllIHN1ciA8c3Ryb25nPkZpbHRyZSBMZWU8L3N0cm9uZz4gZXQgcXVlIGxlIDxzdHJvbmc+TW9kw6hsZSBkZSBicnVpdDwvc3Ryb25nPiBlc3QgZMOpZmluaSBzdXIgPHN0cm9uZz5CcnVpdCBhZGRpdGlmPC9zdHJvbmc+IG91IHN1ciA8c3Ryb25nPkJydWl0IGFkZGl0aWYgZXQgbXVsdGlwbGljYXRpZjwvc3Ryb25nPi4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAwLlwiLFxuXHRcIkBAU3BlY2tsZV9EYW1waW5nLUZhY3Rvcl90YWcwQEBcIjogXCJTcMOpY2lmaWUgbOKAmcOpdGVuZHVlIGRlIGzigJllZmZldCBk4oCZaHVtaWRpdMOpIGV4cG9uZW50aWVsbGUgc3VyIGxlIGZpbHRyYWdlLiBVbmUgdmFsZXVyIGTigJlodW1pZGl0w6kgcGx1cyDDqWxldsOpZSBwcsOpc2VydmUgbWlldXggbGVzIHRyb27Dp29ucyBtYWlzIGfDqW7DqHJlIHVuIGxpc3NhZ2UgbW9pbmRyZSwgdGFuZGlzIHF14oCZdW5lIHZhbGV1ciBtb2lucyDDqWxldsOpZSBwcm9kdWl0IHVuIHBsdXMgZ3JhbmQgbGlzc2FnZS4gTGEgdmFsZXVyIDAgcHJvZHVpdCBsZSBtw6ptZSByw6lzdWx0YXQgcXUndW4gZmlsdHJlIHBhc3NlLWJhcy5cIixcblx0XCJAQFNwZWNrbGVfRGFtcGluZy1GYWN0b3JfdGFnMUBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBlc3QgdmFsaWRlIHVuaXF1ZW1lbnQgc2kgbOKAmW9wdGlvbiA8c3Ryb25nPlR5cGUgZGUgZmlsdHJlPC9zdHJvbmc+IGVzdCBkw6lmaW5pZSBzdXIgPHN0cm9uZz5GaWx0cmUgTGVlIGFtw6lsaW9yw6k8L3N0cm9uZz4gb3Ugc3VyIDxzdHJvbmc+RmlsdHJlIEZyb3N0PC9zdHJvbmc+LiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDEuXCIsXG5cdFwiQEBTcGVja2xlX0ZpbHRlci1TaXplX3RhZzBAQFwiOiBcIlNww6ljaWZpZSBsYSB0YWlsbGUgZGUgbGEgZmVuw6p0cmUgZGUgcGl4ZWwgdXRpbGlzw6llIHBvdXIgZmlsdHJlciBsZSBicnVpdCA6XCIsXG5cdFwiQEBTcGVja2xlX0ZpbHRlci1TaXplX3RhZzFAQFwiOiBcIjN4M1wiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItU2l6ZV90YWcyQEBcIjogXCI1eDVcIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVNpemVfdGFnM0BAXCI6IFwiN3g3XCIsXG5cdFwiQEBTcGVja2xlX0ZpbHRlci1TaXplX3RhZzRAQFwiOiBcIjl4OVwiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItU2l6ZV90YWc1QEBcIjogXCIxMXgxMVwiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItVHlwZV90YWcwQEBcIjogXCJTcMOpY2lmaWUgbGUgdHlwZSBkZSBmaWx0cmUgw6AgdXRpbGlzZXIgZGFucyBs4oCZYWxnb3JpdGhtZSBkZSBsaXNzYWdlIGVuIHZ1ZSBkZSBzdXBwcmltZXIgbGEgZ3JhbnVsYXJpdMOpIDpcIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5GaWx0cmUgTGVlPC9zdHJvbmc+IDogcsOpZHVpdCBsYSBncmFudWxhcml0w6kgZW4gYXBwbGlxdWFudCB1biBmaWx0cmUgc3BhdGlhbCDDoCBjaGFxdWUgcGl4ZWwgZOKAmXVuZSBpbWFnZSwgY2UgcXVpIGZpbHRyZSBsZXMgZG9ubsOpZXMgZW4gZm9uY3Rpb24gZGVzIHN0YXRpc3RpcXVlcyBsb2NhbGVzIGNhbGN1bMOpZXMgZGFucyB1bmUgZmVuw6p0cmUgY2FycsOpZS4gQ2UgZmlsdHJlIGVzdCB1dGlsZSBwb3VyIGxpc3NlciBsZXMgZG9ubsOpZXMgZ3JhbnVsZXVzZXMgcXVpIGNvbXBvcnRlbnQgdW4gY29tcG9zYW50IGFkZGl0aWYgZXQvb3UgbXVsdGlwbGljYXRpZi4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5GaWx0cmUgTGVlIGFtw6lsaW9yw6k8L3N0cm9uZz4gOiB2ZXJzaW9uIGFkYXB0w6llIGR1IGZpbHRyZSBMZWUgcXVpIGluY2x1dCBsZXMgcGFyYW3DqHRyZXMgPHN0cm9uZz5GYWN0ZXVyIGTigJlhdHTDqW51YXRpb248L3N0cm9uZz4gZXQgPHN0cm9uZz5Ob21icmUgZGUgdnVlczwvc3Ryb25nPi4gQ2UgZmlsdHJlIGVzdCB1dGlsZSBwb3VyIHLDqWR1aXJlIGxhIGdyYW51bGFyaXTDqSB0b3V0IGVuIHByw6lzZXJ2YW50IGxlcyBpbmZvcm1hdGlvbnMgZGUgdGV4dHVyZS5cIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVR5cGVfdGFnOUBAXCI6IFwiPHN0cm9uZz5GaWx0cmUgRnJvc3Q8L3N0cm9uZz4gOiByw6lkdWl0IGxhIGdyYW51bGFyaXTDqSDDoCBs4oCZYWlkZSBk4oCZdW4gZmlsdHJlIHN5bcOpdHJpcXVlIGNpcmN1bGFpcmUgZOKAmWF0dMOpbnVhdGlvbiBleHBvbmVudGllbGxlIHF1aSB1dGlsaXNlIGRlcyBzdGF0aXN0aXF1ZXMgbG9jYWxlcyBkYW5zIGxlcyBmZW7DqnRyZXMgZGUgY2hhcXVlIGZpbHRyZS4gQ2UgZmlsdHJlIGVzdCB1dGlsZSBwb3VyIHLDqWR1aXJlIGxhIGdyYW51bGFyaXTDqSB0b3V0IGVuIHByw6lzZXJ2YW50IGxlcyBzZWdtZW50cyBkYW5zIGxlcyBpbWFnZXMgcmFkYXIuXCIsXG5cdFwiQEBTcGVja2xlX0ZpbHRlci1UeXBlX3RhZzExQEBcIjogXCI8c3Ryb25nPkZpbHRyZSBLdWFuPC9zdHJvbmc+IDogc2ltaWxhaXJlIGF1IGZpbHRyZSBMZWUsIGNlIGZpbHRyZSBhcHBsaXF1ZSB1biBmaWx0cmUgc3BhdGlhbCDDoCBjaGFxdWUgcGl4ZWwgZOKAmXVuZSBpbWFnZSBldCBmaWx0cmUgbGVzIGRvbm7DqWVzIGVuIGZvbmN0aW9uIGRlcyBzdGF0aXN0aXF1ZXMgbG9jYWxlcyBjYWxjdWzDqWVzIGRhbnMgdW5lIGZlbsOqdHJlIGNhcnLDqWUuIENlIGZpbHRyZSBlc3QgdXRpbGUgcG91ciByw6lkdWlyZSBsYSBncmFudWxhcml0w6kgdG91dCBlbiBwcsOpc2VydmFudCBsZXMgc2VnbWVudHMgZGFucyBsZXMgaW1hZ2VzIHJhZGFyLlwiLFxuXHRcIkBAU3BlY2tsZV9NdWx0aXBsaWNhdGl2ZS1Ob2lzZS1NZWFuX3RhZzBAQFwiOiBcIlNww6ljaWZpZSBsYSB2YWxldXIgbW95ZW5uZSBkdSBicnVpdCBtdWx0aXBsaWNhdGlmLiBVbmUgdmFsZXVyIGRlIG1veWVubmUgZGUgYnJ1aXQgcGx1cyDDqWxldsOpZSBwcm9kdWl0IHVuIGxpc3NhZ2UgbW9pbmRyZSwgdGFuZGlzIHF14oCZdW5lIHZhbGV1ciBwbHVzIHBldGl0ZSBnw6luw6hyZSB1biBsaXNzYWdlIHBsdXMgaW1wb3J0YW50LlwiLFxuXHRcIkBAU3BlY2tsZV9NdWx0aXBsaWNhdGl2ZS1Ob2lzZS1NZWFuX3RhZzFAQFwiOiBcIkNlIHBhcmFtw6h0cmUgZXN0IHZhbGlkZSB1bmlxdWVtZW50IHNpIGzigJlvcHRpb24gPHN0cm9uZz5UeXBlIGRlIGZpbHRyZTwvc3Ryb25nPiBlc3QgZMOpZmluaWUgc3VyIDxzdHJvbmc+RmlsdHJlIExlZTwvc3Ryb25nPiBldCBxdWUgbGUgPHN0cm9uZz5Nb2TDqGxlIGRlIGJydWl0PC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPkJydWl0IGFkZGl0aWY8L3N0cm9uZz4gb3Ugc3VyIDxzdHJvbmc+QnJ1aXQgYWRkaXRpZiBldCBtdWx0aXBsaWNhdGlmPC9zdHJvbmc+LiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDEuXCIsXG5cdFwiQEBTcGVja2xlX05vaXNlLU1vZGVsX3RhZzBAQFwiOiBcIlNww6ljaWZpZSBsZSB0eXBlIGRlIGJydWl0IHF1aSByw6lkdWl0IGxhIHF1YWxpdMOpIGRlIGzigJlpbWFnZSByYWRhciA6XCIsXG5cdFwiQEBTcGVja2xlX05vaXNlLU1vZGVsX3RhZzFAQFwiOiBcIjxzdHJvbmc+QnJ1aXQgbXVsdGlwbGljYXRpZjwvc3Ryb25nPiA6IGJydWl0IGRlIHNpZ25hbCBhbMOpYXRvaXJlIHF1aSBlc3QgbXVsdGlwbGnDqSBkYW5zIGxlIHNpZ25hbCBwZXJ0aW5lbnQgYXUgY291cnMgZGUgbGEgY2FwdHVyZSBvdSBkZSBsYSB0cmFuc21pc3Npb24uXCIsXG5cdFwiQEBTcGVja2xlX05vaXNlLU1vZGVsX3RhZzNAQFwiOiBcIjxzdHJvbmc+QnJ1aXQgYWRkaXRpZjwvc3Ryb25nPiA6IGJydWl0IGRlIHNpZ25hbCBhbMOpYXRvaXJlIHF1aSBlc3QgYWpvdXTDqSBhdSBzaWduYWwgcGVydGluZW50IGF1IGNvdXJzIGRlIGxhIGNhcHR1cmUgb3UgZGUgbGEgdHJhbnNtaXNzaW9uLlwiLFxuXHRcIkBAU3BlY2tsZV9Ob2lzZS1Nb2RlbF90YWc1QEBcIjogXCI8c3Ryb25nPkJydWl0IGFkZGl0aWYgZXQgbXVsdGlwbGljYXRpZjwvc3Ryb25nPiA6IGxlcyBkZXV4IG1vZMOobGVzIGRlIGJydWl0LlwiLFxuXHRcIkBAU3BlY2tsZV9Ob2lzZS1WYXJpYW5jZV90YWcwQEBcIjogXCJTcMOpY2lmaWUgbGEgdmFyaWFuY2UgZGUgYnJ1aXQgZGUgbOKAmWltYWdlIHJhZGFyLlwiLFxuXHRcIkBAU3BlY2tsZV9Ob2lzZS1WYXJpYW5jZV90YWcxQEBcIjogXCJDZSBwYXJhbcOodHJlIGVzdCB2YWxpZGUgdW5pcXVlbWVudCBzaSBs4oCZb3B0aW9uIDxzdHJvbmc+VHlwZSBkZSBmaWx0cmU8L3N0cm9uZz4gZXN0IGTDqWZpbmllIHN1ciA8c3Ryb25nPkZpbHRyZSBMZWU8L3N0cm9uZz4gZXQgcXVlIGxlIDxzdHJvbmc+TW9kw6hsZSBkZSBicnVpdDwvc3Ryb25nPiBlc3QgZMOpZmluaSBzdXIgPHN0cm9uZz5CcnVpdCBhZGRpdGlmPC9zdHJvbmc+IG91IHN1ciA8c3Ryb25nPkJydWl0IGFkZGl0aWYgZXQgbXVsdGlwbGljYXRpZjwvc3Ryb25nPi4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAwLDI1LlwiLFxuXHRcIkBAU3BlY2tsZV9OdW1iZXItb2YtTG9va3NfdGFnMEBAXCI6IFwiU3DDqWNpZmllIGxlIG5vbWJyZSBkZSB2dWVzIGRlIGzigJlpbWFnZSwgY2UgcXVpIGNvbnRyw7RsZSBsZSBsaXNzYWdlIGRlcyBpbWFnZXMgZXQgZXN0aW1lIGxhIHZhcmlhbmNlIGRlIGJydWl0LiBVbmUgdmFsZXVyIHBsdXMgcGV0aXRlIHByb2R1aXQgdW4gcGx1cyBncmFuZCBsaXNzYWdlLCB0YW5kaXMgcXXigJl1bmUgdmFsZXVyIHBsdXMgw6lsZXbDqWUgY29uc2VydmUgZGF2YW50YWdlIGTigJllbnRpdMOpcyBk4oCZaW1hZ2VzLlwiLFxuXHRcIkBAU3BlY2tsZV9OdW1iZXItb2YtTG9va3NfdGFnMUBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBlc3QgdmFsaWRlIHVuaXF1ZW1lbnQgc2kgbOKAmW9wdGlvbiA8c3Ryb25nPlR5cGUgZGUgZmlsdHJlPC9zdHJvbmc+IGVzdCBkw6lmaW5pZSBzdXIgPHN0cm9uZz5GaWx0cmUgTGVlPC9zdHJvbmc+IGV0IHF1ZSBsZSA8c3Ryb25nPk1vZMOobGUgZGUgYnJ1aXQ8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+QnJ1aXQgbXVsdGlwbGljYXRpZjwvc3Ryb25nPiwgb3Ugc2kgbOKAmW9wdGlvbiA8c3Ryb25nPlR5cGUgZGUgZmlsdHJlPC9zdHJvbmc+IGVzdCBkw6lmaW5pZSBzdXIgPHN0cm9uZz5GaWx0cmUgS3Vhbjwvc3Ryb25nPi4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAxLlwiLFxuXHRcIkBAU3BlY2tsZV9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tTWF0cml4X3RhZzBAQFwiOiBcIk1hdHJpY2UgdXRpbGlzw6llIHBvdXIgY29udmVydGlyIGxlIHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWcxQEBcIjogXCJMJ8OpcXVhdGlvbiB1dGlsaXPDqWUgcG91ciBlZmZlY3R1ZXIgY2V0dGUgY29udmVyc2lvbiBlc3QgbGEgc3VpdmFudGUgOlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWcyQEBcIjogXCJDYW5hbCBlbiBzb3J0aWUgQmFuZF9SID0gV2VpZ2h0X1AgKiBCYW5kX0NcIixcblx0XCJAQFNwZWN0cmFsLUNvbnZlcnNpb25fQ29udmVyc2lvbi1NYXRyaXhfdGFnM0BAXCI6IFwib8O5IDpcIixcblx0XCJAQFNwZWN0cmFsLUNvbnZlcnNpb25fQ29udmVyc2lvbi1NYXRyaXhfdGFnNEBAXCI6IFwiQmFuZF9SIGVzdCB1biBjYW5hbCBlbiBzb3J0aWUsIG/DuSBSIGVzdCB1biBub21icmUgY29tcHJpcyBlbnRyZSAxIGV0IGxlIG5vbWJyZSBkZSBjYW5hdXggZW4gc29ydGllLlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWc1QEBcIjogXCJXZWlnaHRfUCBlc3QgdW5lIGxpc3RlIGRlIHBvbmTDqXJhdGlvbnMgZMOpbGltaXTDqWUgcGFyIGRlcyB2aXJndWxlcywgMSBwb3VyIGNoYXF1ZSBjYW5hbCBlbiBlbnRyw6llLiBMYSBzb21tZSBkZXMgcG9uZMOpcmF0aW9ucyBkZSBjaGFxdWUgY2FuYWwgZG9pdCDDqWdhbGVyIGxhIHZhbGV1ciAxLlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWc2QEBcIjogXCJCYW5kX0MgZXN0IGwnaW1hZ2UgZW4gZW50csOpZSwgb8O5IEMgZXN0IHVuIG5vbWJyZSBjb21wcmlzIGVudHJlIDEgZXQgbGUgbm9tYnJlIGRlIGNhbmF1eCBkZSBsJ2ltYWdlIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQFNwZWN0cmFsLUNvbnZlcnNpb25fUmFzdGVyX3RhZzFAQFwiOiBcIklsIHBldXQgc+KAmWFnaXIgZOKAmXVuIGpldSBkZSBkb25uw6llcyByYXN0ZXIsIGTigJl1bmUgbW9zYcOvcXVlIG91IGTigJl1biBzZXJ2aWNlIGTigJlpbWFnZXJpZS5cIixcblx0XCJAQFNwZWN0cmFsLUNvbnZlcnNpb25fU2l6ZV90YWcwQEBcIjogXCJOb21icmUgZGUgbGlnbmVzIGV0IGRlIGNvbG9ubmVzIGRlIGxhIDxzdHJvbmc+TWF0cmljZSBkZSBjb252ZXJzaW9uPC9zdHJvbmc+LlwiLFxuXHRcIkBAU3F1YXJlX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAU3F1YXJlX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBTcXVhcmVfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFNxdWFyZV9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAU3F1YXJlX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBTcXVhcmVfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBTcXVhcmVfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAU3F1YXJlX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBTcXVhcmVfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAU3F1YXJlX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBTcXVhcmVfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBTcXVhcmVfUmFzdGVyX3RhZzBAQFwiOiBcIlZhbGV1cnMgZW4gZW50csOpZSDDoCBtZXR0cmUgYXUgY2FycsOpLlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFNxdWFyZS1Sb290X0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1veWVubmUgZGUgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFNxdWFyZS1Sb290X0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfUmFzdGVyX3RhZzBAQFwiOiBcIlZhbGV1cnMgZW4gZW50csOpZSB1dGlsaXPDqWVzIHBvdXIgY2FsY3VsZXIgbGEgcmFjaW5lIGNhcnLDqWUuXCIsXG5cdFwiQEBTdGF0aXN0aWNzLWFuZC1IaXN0b2dyYW1fRGVmaW5lLVN0YXRpc3RpY3MtYW5kLUhpc3RvZ3JhbV90YWcwQEBcIjogXCJEw6lmaW5pc3NleiBsZXMgdmFsZXVycyBkZSBzdGF0aXN0aXF1ZXMgZGUgY2hhcXVlIGNhbmFsLlwiLFxuXHRcIkBAU3RhdGlzdGljcy1hbmQtSGlzdG9ncmFtX0RlZmluZS1TdGF0aXN0aWNzLWFuZC1IaXN0b2dyYW1fdGFnMUBAXCI6IFwiTGEgY29sb25uZSAke0hpc3RvZ3JhbX0gZXN0IHVuIGNoYW1wIGVuIGxlY3R1cmUgc2V1bGUgcXVpIHBldXQgw6p0cmUgcmVuc2VpZ27DqSBncsOiY2UgYXUgcGFyYW3DqHRyZSA8c3Ryb25nPkltcG9ydGVyPC9zdHJvbmc+LiBTaSB2b3VzIGltcG9ydGV6IHVuIGZpY2hpZXIgZOKAmWhpc3RvZ3JhbW1lLCBsYSBjb2xvbm5lICR7SGlzdG9ncmFtfSBlc3QgbWFycXXDqWUgY29tbWUgPHN0cm9uZz5Ew6lmaW5pZTwvc3Ryb25nPi5cIixcblx0XCJAQFN0YXRpc3RpY3MtYW5kLUhpc3RvZ3JhbV9JbXBvcnRfdGFnMEBAXCI6IFwiSW1wb3J0ZSBsZXMgaW5mb3JtYXRpb25zIGxpw6llcyBhdXggc3RhdGlzdGlxdWVzIGV0IMOgIGwnaGlzdG9ncmFtbWUgZCd1biByYXN0ZXIgb3UgZCd1biBmaWNoaWVyIFhNTCBleGlzdGFudC5cIixcblx0XCJAQFN0YXRpc3RpY3MtYW5kLUhpc3RvZ3JhbV9SYXN0ZXJfdGFnMEBAXCI6IFwiTGUgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBsZXF1ZWwgbGVzIHN0YXRpc3RpcXVlcyBldCBs4oCZaGlzdG9ncmFtbWUgZG9pdmVudCDDqnRyZSBkw6lmaW5pcy5cIixcblx0XCJAQFN0YXRpc3RpY3MtYW5kLUhpc3RvZ3JhbV9TdGF0aXN0aWNzX3RhZzBAQFwiOiBcIkTDqWZpbmlzc2V6IGxlcyB2YWxldXJzIGRlIHN0YXRpc3RpcXVlcyBkZSBjaGFxdWUgY2FuYWwuXCIsXG5cdFwiQEBTdHJlYW0tTGlua19GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgcXVpIG1vbnRyZSBsYSBkaXJlY3Rpb24gZHUgZmx1eCBzb3J0YW50IGRlIGNoYXF1ZSBjZWxsdWxlLlwiLFxuXHRcIkBAU3RyZWFtLUxpbmtfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzFAQFwiOiBcIkxlIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCBwZXV0IMOqdHJlIGNyw6nDqSBlbiBleMOpY3V0YW50IGxhIGZvbmN0aW9uIDxzdHJvbmc+RGlyZWN0aW9uIGRlIGZsdXg8L3N0cm9uZz4uXCIsXG5cdFwiQEBTdHJlYW0tTGlua19TdHJlYW0tUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIHJlcHLDqXNlbnRhbnQgdW4gcsOpc2VhdSBk4oCZw6ljb3VsZW1lbnQgbGluw6lhaXJlLlwiLFxuXHRcIkBAU3RyZWFtLU9yZGVyX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSBxdWkgbW9udHJlIGxhIGRpcmVjdGlvbiBkdSBmbHV4IHNvcnRhbnQgZGUgY2hhcXVlIGNlbGx1bGUuXCIsXG5cdFwiQEBTdHJlYW0tT3JkZXJfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzFAQFwiOiBcIkxlIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCBwZXV0IMOqdHJlIGNyw6nDqSBlbiBleMOpY3V0YW50IGxhIGZvbmN0aW9uIDxzdHJvbmc+RGlyZWN0aW9uIGRlIGZsdXg8L3N0cm9uZz4uXCIsXG5cdFwiQEBTdHJlYW0tT3JkZXJfT3JkZXItTWV0aG9kX3RhZzBAQFwiOiBcIk3DqXRob2RlIHV0aWxpc8OpZSBwb3VyIGF0dHJpYnVlciBsJ29yZHJlIGQnw6ljb3VsZW1lbnQuXCIsXG5cdFwiQEBTdHJlYW0tT3JkZXJfT3JkZXItTWV0aG9kX3RhZzFAQFwiOiBcIjxzdHJvbmc+U1RSQUhMRVI8L3N0cm9uZz4gOiBtw6l0aG9kZSBkZSBoacOpcmFyY2hpc2F0aW9uIGTigJnDqWNvdWxlbWVudCBwcm9wb3PDqWUgcGFyIFN0cmFobGVyIGVuIDE5NTIuIEzigJlvcmRyZSBk4oCZw6ljb3VsZW1lbnQgYXVnbWVudGUgdW5pcXVlbWVudCBsb3JzcXVlIGRlcyBjb3VycyBk4oCZZWF1IGR1IG3Dqm1lIG9yZHJlIHNlIGNyb2lzZW50LiBM4oCZaW50ZXJzZWN0aW9uIGTigJl1bmUgbGlhaXNvbiBkZSBwcmVtaWVyIG9yZHJlIGV0IGTigJl1bmUgbGlhaXNvbiBkZSBkZXV4acOobWUgb3JkcmUgcmVzdGUgdW5lIGxpYWlzb24gZGUgZGV1eGnDqG1lIG9yZHJlIHBsdXTDtHQgcXVlIGRlIGNyw6llciB1bmUgbGlhaXNvbiBkZSB0cm9pc2nDqG1lIG9yZHJlLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAU3RyZWFtLU9yZGVyX09yZGVyLU1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPlNIUkVWRTwvc3Ryb25nPiA6IG3DqXRob2RlIGRlIGhpw6lyYXJjaGlzYXRpb24gZOKAmcOpY291bGVtZW50IHBhciBtYWduaXR1ZGUsIHByb3Bvc8OpZSBwYXIgU2hyZXZlIGVuIDE5NjcuIFRvdXMgbGVzIGxpZW5zIHNhbnMgYWZmbHVlbnQgb250IHVuZSBtYWduaXR1ZGUgKG9yZHJlKSBkZSB1bi4gTGVzIG1hZ25pdHVkZXMgc29udCBkZXMgcGVudGVzIGRlc2NlbmRhbnRlcyBhZGRpdGl2ZXMuIExvcnNxdWUgZGV1eCBsaWFpc29ucyBzZSBjcm9pc2VudCwgbGV1cnMgbWFnbml0dWRlcyBzb250IGFkZGl0aW9ubsOpZXMgZXQgbGUgcsOpc3VsdGF0IGVzdCBhdHRyaWJ1w6kgYXUgbGllbiBkZSBwZW50ZSBkZXNjZW5kYW50ZS5cIixcblx0XCJAQFN0cmVhbS1PcmRlcl9TdHJlYW0tUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBk4oCZw6ljb3VsZW1lbnQgZW4gZW50csOpZSByZXByw6lzZW50YW50IHVuIHLDqXNlYXUgZOKAmcOpY291bGVtZW50IGxpbsOpYWlyZS5cIixcblx0XCJAQFN0cmV0Y2hfQXV0by1HYW1tYV90YWcwQEBcIjogXCJVdGlsaXNleiBsYSA8c3Ryb25nPlZhbGV1ciBHYW1tYSBhdXRvbWF0aXF1ZTwvc3Ryb25nPiBwb3VyIGNhbGN1bGVyIGxhIHZhbGV1ciBHYW1tYSDDoCBwYXJ0aXIgZGVzIHN0YXRpc3RpcXVlcyBldCBkZSBs4oCZaGlzdG9ncmFtbWUgZHUgamV1IGRlIGRvbm7DqWVzLiBMZXMgc3RhdGlzdGlxdWVzIHBldXZlbnQgw6p0cmUgZXN0aW3DqWVzIHBhciBsYSBmb25jdGlvbiBtw6ptZSBvdSBwYXIgbGUgbG9naWNpZWwgc2kgdm91cyBhdmV6IGNob2lzaSB1bmUgY291Y2hlLlwiLFxuXHRcIkBAU3RyZXRjaF9EeW5hbWljLVJhbmdlLUFkanVzdG1lbnRfdGFnMEBAXCI6IFwiQ29jaGV6IGxhIGNhc2UgPHN0cm9uZz5BanVzdGVtZW50IGR5bmFtaXF1ZSBkZSBsYSBwbGFnZTwvc3Ryb25nPiBwb3VyIGNhbGN1bGVyIGxlcyBzdGF0aXN0aXF1ZXMgdW5pcXVlbWVudCDDoCBwYXJ0aXIgZGVzIHBpeGVscyBhZmZpY2jDqXMgw6AgbOKAmcOpY3Jhbi4gQ2V0dGUgb3B0aW9uIGVzdCBhcHBsaXF1w6llIGVuIGfDqW7DqXJhbCBsb3JzcXVlIGzigJlpbWFnZSBlc3QgZGVzdGluw6llIMOgIMOqdHJlIHB1Ymxpw6llIGV0IHV0aWxpc8OpZSBkYW5zIHVuZSBhcHBsaWNhdGlvbiBXZWIgcXVpIG5lIHBldXQgcGFzIGVmZmVjdHVlciBjZSB0eXBlIGTigJnDqXRpcmVtZW50LlwiLFxuXHRcIkBAU3RyZXRjaF9Fc3RpbWF0ZS1TdGF0aXN0aWNzX3RhZzBAQFwiOiBcIkNvY2hleiBsYSBjYXNlIDxzdHJvbmc+RXN0aW1lciBsZXMgc3RhdGlzdGlxdWVzPC9zdHJvbmc+IHBvdXIgZXN0aW1lciB2b3Mgc3RhdGlzdGlxdWVzLiBMZXMgc3RhdGlzdGlxdWVzIGVzdGltw6llcyBzb250IGNhbGN1bMOpZXMgw6AgcGFydGlyIGTigJl1biDDqWNoYW50aWxsb24gZGUgMSAwMDAgc3VyIDEgMDAwIGRlcHVpcyBsZSBjZW50cmUgZHUgcmFzdGVyIGV0IHV0aWxpc8OpZXMgcGFyIGzigJnDqXRpcmVtZW50LlwiLFxuXHRcIkBAU3RyZXRjaF9Fc3RpbWF0ZS1TdGF0aXN0aWNzX3RhZzNAQFwiOiBcIlNpIGNldHRlIG9wdGlvbiBlc3Qgc8OpbGVjdGlvbm7DqWUgZXQgcXVlIGxlIHJhc3RlciBjb21wb3J0ZSBkZXMgc3RhdGlzdGlxdWVzLCBvdSBzaSB2b3VzIGF2ZXogc2Fpc2kgZGVzIHZhbGV1cnMgZGFucyBsYSB0YWJsZSA8c3Ryb25nPlN0YXRpc3RpcXVlczwvc3Ryb25nPiwgZWxsZXMgc29udCB1dGlsaXPDqWVzIGF1IGxpZXUgZOKAmWVmZmVjdHVlciB1bmUgZXN0aW1hdGlvbiwgc2F1ZiBzaSBs4oCZw6l0aXJlbWVudCBuw6ljZXNzaXRlIHVuIGhpc3RvZ3JhbW1lLiBTaSBs4oCZw6l0aXJlbWVudCBuw6ljZXNzaXRlIHVuIGhpc3RvZ3JhbW1lIHF1aSBu4oCZZXhpc3RlIHBhcywgaWwgZXN0IGVzdGltw6kuXCIsXG5cdFwiQEBTdHJldGNoX0dhbW1hX3RhZzBAQFwiOiBcIlV0aWxpc2V6IGxhIGJhcnJlIGR1IGN1cnNldXIgcG91ciBkw6lmaW5pciBtYW51ZWxsZW1lbnQgbGEgdmFsZXVyIDxzdHJvbmc+R2FtbWE8L3N0cm9uZz4uXCIsXG5cdFwiQEBTdHJldGNoX051bWJlci1PZi1TdGFuZGFyZC1EZXZpYXRpb25zX3RhZzBAQFwiOiBcIlNww6ljaWZpZXogbGEgdmFsZXVyIG4gcG91ciBsZSBub21icmUgZCfDqWNhcnQgdHlwZXMgw6AgdXRpbGlzZXIuIENldHRlIG3DqXRob2RlIHBlcm1ldCBkJ2FjY2VudHVlciBkYW5zIHF1ZWxsZSBtZXN1cmUgbGVzIHZhbGV1cnMgZCdlbnRpdMOpcyB2YXJpZW50IHBhciByYXBwb3J0IMOgIGxhIHZhbGV1ciBtb3llbm5lLiBFbGxlIGVzdCBwbHVzIHV0aWxlIGxvcnNxdSdlbGxlIGVzdCB1dGlsaXPDqWUgc3VyIGRlcyBkb25uw6llcyByw6lwYXJ0aWVzIG5vcm1hbGVtZW50LlwiLFxuXHRcIkBAU3RyZXRjaF9PdXRwdXQtTWF4aW11bV90YWcwQEBcIjogXCJEw6lmaW5pc3NleiBsYSB2YWxldXIgZGUgcGl4ZWwgbGEgcGx1cyDDqWxldsOpZSBwb3VyIGwnaGlzdG9ncmFtbWUuXCIsXG5cdFwiQEBTdHJldGNoX091dHB1dC1NYXhpbXVtX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGRlIDxzdHJvbmc+U29ydGllIG1pbmltYWxlPC9zdHJvbmc+IGV0IGRlIDxzdHJvbmc+U29ydGllIG1heGltYWxlPC9zdHJvbmc+IGTDqWZpbmlzc2VudCBsYSBwbGFnZSBkZXMgdmFsZXVycyBxdWkgcHLDqXNlbnRlcm9udCBlbnN1aXRlIHVuIMOpdGlyZW1lbnQgZGUgY29udHJhc3RlIGxpbsOpYWlyZS5cIixcblx0XCJAQFN0cmV0Y2hfT3V0cHV0LU1pbmltdW1fdGFnMEBAXCI6IFwiRMOpZmluaXNzZXogbGEgdmFsZXVyIGRlIHBpeGVsIGxhIHBsdXMgZmFpYmxlIHBvdXIgbCdoaXN0b2dyYW1tZS5cIixcblx0XCJAQFN0cmV0Y2hfT3V0cHV0LU1pbmltdW1fdGFnMUBAXCI6IFwiTGVzIHZhbGV1cnMgZGUgPHN0cm9uZz5Tb3J0aWUgbWluaW1hbGU8L3N0cm9uZz4gZXQgZGUgPHN0cm9uZz5Tb3J0aWUgbWF4aW1hbGU8L3N0cm9uZz4gZMOpZmluaXNzZW50IGxhIHBsYWdlIGRlcyB2YWxldXJzIHF1aSBwcsOpc2VudGVyb250IGVuc3VpdGUgdW4gw6l0aXJlbWVudCBkZSBjb250cmFzdGUgbGluw6lhaXJlLlwiLFxuXHRcIkBAU3RyZXRjaF9QZXJjZW50LUNsaXAtTWF4aW11bV90YWcwQEBcIjogXCJTcMOpY2lmaWV6IGxlIHBvdXJjZW50YWdlIGRlcyB2YWxldXJzIMOpbGV2w6llcyDDoCBleGNsdXJlIGRlIGwnw6l0aXJlbWVudC5cIixcblx0XCJAQFN0cmV0Y2hfUGVyY2VudC1DbGlwLU1heGltdW1fdGFnMUBAXCI6IFwiTGVzIHZhbGV1cnMgY29ycmVjdGVzIHNvbnQgY29tcHJpc2VzIGVudHJlIDAgZXQgOTkuXCIsXG5cdFwiQEBTdHJldGNoX1BlcmNlbnQtQ2xpcC1NaW5pbXVtX3RhZzBAQFwiOiBcIlNww6ljaWZpZXogbGUgcG91cmNlbnRhZ2UgZGVzIHZhbGV1cnMgZmFpYmxlcyDDoCBleGNsdXJlIGRlIGwnw6l0aXJlbWVudC5cIixcblx0XCJAQFN0cmV0Y2hfUGVyY2VudC1DbGlwLU1pbmltdW1fdGFnMUBAXCI6IFwiTGVzIHZhbGV1cnMgY29ycmVjdGVzIHNvbnQgY29tcHJpc2VzIGVudHJlIDAgZXQgOTkuXCIsXG5cdFwiQEBTdHJldGNoX1Jhc3Rlcl90YWcwQEBcIjogXCJMZSByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGwnw6l0aXJlbWVudCBkZSBjb250cmFzdGUuXCIsXG5cdFwiQEBTdHJldGNoX1NpZ21vaWQtU3RyZW5ndGgtTGV2ZWxfdGFnMEBAXCI6IFwiTGUgPHN0cm9uZz5OaXZlYXUgZGUgZm9yY2U8L3N0cm9uZz4gZMOpdGVybWluZSBxdWVsbGUgcGFydGllIGRlIGxhIGZvbmN0aW9uIHNpZ21vw69kYWxlIHNlcmEgdXRpbGlzw6llIGRhbnMgbOKAmcOpdGlyZW1lbnQuIFVuZSB2YWxldXIgZmFpYmxlIChwYXIgZXhlbXBsZSwgMSkgdXRpbGlzZSB1bmlxdWVtZW50IGxhIHBhcnRpZSBjZW50cmFsZSBkZSBsYSBjb3VyYmUsIGNlIHF1aSB0ZW5kIMOgIGfDqW7DqXJlciBkZXMgY291bGV1cnMgdGVybmVzIGV0IGZsb3Vlcy4gVW5lIHZhbGV1ciDDqWxldsOpZSAocGFyIGV4ZW1wbGUsIDYpIHV0aWxpc2UgbOKAmWludMOpZ3JhbGl0w6kgZGUgbGEgY291cmJlLCBjZSBxdWkgdGVuZCDDoCBnw6luw6lyZXIgZGVzIGNvdWxldXJzIHZpdmVzIGV0IG5ldHRlcy5cIixcblx0XCJAQFN0cmV0Y2hfU3RhdGlzdGljc190YWcwQEBcIjogXCJWb3VzIHBvdXZleiBzYWlzaXIgdm9zIHByb3ByZXMgc3RhdGlzdGlxdWVzIGRhbnMgbGEgYm/DrnRlIGRlIGRpYWxvZ3VlLiBQYXIgZMOpZmF1dCwgbGVzIHN0YXRpc3RpcXVlcyBzb250IGV4dHJhaXRlcyBkZXMgZG9ubsOpZXMuIFRvdXRlZm9pcywgc2kgdm91cyBlbnRyZXogZGVzIHZhbGV1cnMgZGFucyBjZSBwYXJhbcOodHJlLCBlbGxlcyBzZXJvbnQgdXRpbGlzw6llcyDDoCBsYSBwbGFjZS5cIixcblx0XCJAQFN0cmV0Y2hfVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIG3DqXRob2RlIGR1IHR5cGUgZCfDqXRpcmVtZW50OlwiLFxuXHRcIkBAU3RyZXRjaF9UeXBlX3RhZzFAQFwiOiBcIkF1Y3VuIDogYXVjdW4gw6l0aXJlbWVudCBkZSBjb250cmFzdGVcIixcblx0XCJAQFN0cmV0Y2hfVHlwZV90YWcyQEBcIjogXCLDiWNhcnQgdHlwZSA6IMOpdGlyZW1lbnQgw4ljYXJ0IHR5cGVcIixcblx0XCJAQFN0cmV0Y2hfVHlwZV90YWczQEBcIjogXCJNaW5NYXggOiDDqXRpcmVtZW50IE1pbmltdW0tTWF4aW11bVwiLFxuXHRcIkBAU3RyZXRjaF9UeXBlX3RhZzRAQFwiOiBcIlBvdXJjZW50YWdlTWluTWF4IDogw6l0aXJlbWVudCBQb3VyY2VudGFnZSBkZSBkw6ljb3VwZVwiLFxuXHRcIkBAU3RyZXRjaF9UeXBlX3RhZzVAQFwiOiBcIlNpZ21vw69kZSA6IMOpdGlyZW1lbnQgU2lnbW/Dr2RlXCIsXG5cdFwiQEBTdHJldGNoX1VzZS1HYW1tYV90YWcwQEBcIjogXCJDb2NoZXogbGEgY2FzZSA8c3Ryb25nPlV0aWxpc2VyIGxhIHZhbGV1ciBHYW1tYTwvc3Ryb25nPiBwb3VyIGFwcGxpcXVlciB1biDDqXRpcmVtZW50IGdhbW1hLlwiLFxuXHRcIkBAU3dhdGhfQ2VsbHNpemVfdGFnMEBAXCI6IFwiTGEgdGFpbGxlIGRlIGNlbGx1bGUgZHUgcmFzdGVyIGVuIHNvcnRpZSBlc3QgYXV0b21hdGlxdWVtZW50IGTDqXRlY3TDqWUsIG1haXMgY2VjaSBwZXV0IMOqdHJlIG1vZGlmacOpIHNpIHZvdXMgbGUgc291aGFpdGV6LiBMYSB0YWlsbGUgZGUgY2VsbHVsZSBwZXV0IMOqdHJlIG1vZGlmacOpZSwgbWFpcyBsJ8OpdGVuZHVlIGR1IGpldSBkZSBkb25uw6llcyByYXN0ZXIgcmVzdGUgaWRlbnRpcXVlLlwiLFxuXHRcIkBAU3dhdGhfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnMEBAXCI6IFwiUXVhdHJlIG3DqXRob2RlcyBkZSByw6nDqWNoYW50aWxsb25uYWdlIHNvbnQgZGlzcG9uaWJsZXMgcG91ciBjZXR0ZSBmb25jdGlvbiA6XCIsXG5cdFwiQEBTd2F0aF9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWcxQEBcIjogXCI8c3Ryb25nPlZvaXNpbiBsZSBwbHVzIHByb2NoZTwvc3Ryb25nPiA6IGNhbGN1bGUgbGEgdmFsZXVyIGR1IHBpeGVsIGdyw6JjZSBhdSBwaXhlbCBsZSBwbHVzIHByb2NoZS4gU2kgYXVjdW4gcGl4ZWwgc291cmNlIG7igJlleGlzdGUsIGF1Y3VuIG5vdXZlYXUgcGl4ZWwgbmUgcGV1dCDDqnRyZSBjcsOpw6kgZGFucyBsYSBzb3J0aWUuXCIsXG5cdFwiQEBTd2F0aF9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPkJpbGluw6lhaXJlPC9zdHJvbmc+IDogY2FsY3VsZSBsYSB2YWxldXIgZHUgcGl4ZWwgZW4gdXRpbGlzYW50IGxhIHZhbGV1ciBkZSBkaXN0YW5jZSBwb25kw6lyw6llIGRlcyBxdWF0cmUgcGl4ZWxzIGxlcyBwbHVzIHByb2NoZXMuXCIsXG5cdFwiQEBTd2F0aF9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWc1QEBcIjogXCI8c3Ryb25nPlRJTiBsaW7DqWFpcmU8L3N0cm9uZz4gOiB1dGlsaXNlIHVuIHLDqXNlYXUgdHJpYW5ndWzDqSBpcnLDqWd1bGllciAoVElOKSDDoCBwYXJ0aXIgZGVzIHBvaW50cyBjZW50cmF1eCBkZSBjaGFxdWUgY2VsbHVsZSBkdSByYXN0ZXIgaXJyw6lndWxpZXIgcG91ciBpbnRlcnBvbGVyIHVuZSBzdXJmYWNlIHF1aSBzZXJhIGVuc3VpdGUgY29udmVydGllIGVuIHJhc3RlciByw6lndWxpZXIuXCIsXG5cdFwiQEBTd2F0aF9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWc3QEBcIjogXCI8c3Ryb25nPlZvaXNpbiBuYXR1cmVsPC9zdHJvbmc+IDogZWZmZWN0dWUgdW5lIGFmZmVjdGF0aW9uIGR1IHZvaXNpbiBsZSBwbHVzIHByb2NoZS4gSWwgc+KAmWFnaXQgZGUgbGEgcGx1cyByYXBpZGUgZGVzIG3DqXRob2RlcyBk4oCZaW50ZXJwb2xhdGlvbi4gRWxsZSBlc3QgZXNzZW50aWVsbGVtZW50IHV0aWxpc8OpZSBwb3VyIGxlcyBkb25uw6llcyBkaXNjcsOodGVzLCB0ZWxsZXMgcXXigJl1bmUgY2xhc3NpZmljYXRpb24gZGUgbOKAmXV0aWxpc2F0aW9uIGR1IHNvbCwgY2FyIGVsbGUgbmUgbW9kaWZpZSBwYXMgbGVzIHZhbGV1cnMgZGVzIGNlbGx1bGVzLiBM4oCZZXJyZXVyIHNwYXRpYWxlIG1heGltYWxlIHNlcmEgZGUgbGEgbW9pdGnDqSBk4oCZdW5lIHRhaWxsZSBkZSBjZWxsdWxlLlwiLFxuXHRcIkBAU3dhdGhfUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBkZSBwb2ludHMgcXVhZHJpbGzDqXMgZGUgZmHDp29uIGlycsOpZ3VsacOocmUgw6AgcsOpw6ljaGFudGlsbG9ubmVyLlwiLFxuXHRcIkBAVGFuX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAVGFuX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBUYW5fQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBsYSBkZXJuacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFRhbl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAVGFuX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBUYW5fQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBUYW5fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAVGFuX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBUYW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAVGFuX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBUYW5fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBUYW5fUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgcG91ciBsYXF1ZWxsZSBjYWxjdWxlciBsZXMgdmFsZXVycyBkZSB0YW5nZW50ZS5cIixcblx0XCJAQFRhbkhfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBUYW5IX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBUYW5IX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBUYW5IX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBUYW5IX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBUYW5IX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAVGFuSF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBUYW5IX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByZW1pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBwcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBUYW5IX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFRhbkhfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFRhbkhfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBUYW5IX1Jhc3Rlcl90YWcwQEBcIjogXCJFbnRyw6llIHBvdXIgbGFxdWVsbGUgY2FsY3VsZXIgbGVzIHZhbGV1cnMgZGUgdGFuZ2VudGUgaHlwZXJib2xpcXVlLlwiLFxuXHRcIkBAVGFzc2VsZWQtQ2FwX1Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZSBzdXIgbGVxdWVsIGV4w6ljdXRlciBsYSB0cmFuc2Zvcm1hdGlvbi5cIixcblx0XCJAQFRpbWVzX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvaXNpc3NleiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAVGltZXNfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFRpbWVzX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBUaW1lc19DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAVGltZXNfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFRpbWVzX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaSBkZSA6IHV0aWxpc2UgbGEgcGx1cyBwZXRpdGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAVGltZXNfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLlwiLFxuXHRcIkBAVGltZXNfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFRpbWVzX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFRpbWVzX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkdSBkZXJuaWVyIHJhc3RlciBlbiBlbnRyw6llIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBUaW1lc19FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFRpbWVzX1Jhc3Rlcl90YWcwQEBcIjogXCJFbnRyw6llIHF1aSBjb250aWVudCBsZXMgdmFsZXVycyDDoCBtdWx0aXBsaWVyLlwiLFxuXHRcIkBAVGltZXNfUmFzdGVyX3RhZzFAQFwiOiBcIlVuZSB2YWxldXIgY29uc3RhbnRlIHBldXQgw6p0cmUgdXRpbGlzw6llIGVuIGVudHLDqWUgcG91ciBjZSBwYXJhbcOodHJlLCDDoCBjb25kaXRpb24gcXXigJl1biByYXN0ZXIgc29pdCBzcMOpY2lmacOpIHBvdXIgbOKAmWF1dHJlIHBhcmFtw6h0cmUuXCIsXG5cdFwiQEBUaW1lc19SYXN0ZXIyX3RhZzBAQFwiOiBcIkVudHLDqWUgcXVpIGNvbnRpZW50IGxlcyB2YWxldXJzIHBhciBsZXNxdWVsbGVzIGxhIHByZW1pw6hyZSBlbnRyw6llIGVzdCBtdWx0aXBsacOpZS5cIixcblx0XCJAQFRpbWVzX1Jhc3RlcjJfdGFnMUBAXCI6IFwiVW5lIHZhbGV1ciBjb25zdGFudGUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgZW4gZW50csOpZSBwb3VyIGNlIHBhcmFtw6h0cmUsIMOgIGNvbmRpdGlvbiBxdeKAmXVuIHJhc3RlciBzb2l0IHNww6ljaWZpw6kgcG91ciBs4oCZYXV0cmUgcGFyYW3DqHRyZS5cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGUgdHlwZSBkZSB0cmFuc3Bvc2l0aW9uIMOgIGVmZmVjdHVlciBvdSBzcMOpY2lmaWV6IHVuIHR5cGUgcGVyc29ubmFsaXPDqS5cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzFAQFwiOiBcIkxhbmRzYXQgOCBDaXJydXNcIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzJAQFwiOiBcIkxhbmRzYXQgOCBOdWFnZVwiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfQml0LVBhdHRlcm5fdGFnM0BAXCI6IFwiTGFuZHNhdCA4IE9tYnJlIG51YWdlXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWc0QEBcIjogXCJMYW5kc2F0IDggUmVtcGxpc3NhZ2UgZMOpc2lnbsOpXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWc1QEBcIjogXCJMYW5kc2F0IDggSW1hZ2UgZMOpcGxhY8OpZVwiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfQml0LVBhdHRlcm5fdGFnNkBAXCI6IFwiTGFuZHNhdCA4IE5laWdlL2dsYWNlXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWc3QEBcIjogXCJMYW5kc2F0IDggT2NjbHVzaW9uIGRlIHRlcnJhaW5cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzhAQFwiOiBcIkxhbmRzYXQgOCBWw6lnw6l0YXRpb25cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzlAQFwiOiBcIkxhbmRzYXQgOCBFYXVcIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzEwQEBcIjogXCJEw6lmaW5pIHBhciBs4oCZdXRpbGlzYXRldXJcIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0NvbnN0YW50LVZhbHVlX3RhZzBAQFwiOiBcIlZhbGV1ciBmYWN1bHRhdGl2ZSBxdWkgcGVybWV0IGRlIHJlbnNlaWduZXIgdG91cyBsZXMgYml0cyBub24gaW1wbGlxdcOpcyBkYW5zIGxhIHRyYW5zcG9zaXRpb24uIENlIHBhcmFtw6h0cmUgZXN0IHZpc2libGUgc2kgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPkfDqW7DqXJlciB1biByYXN0ZXIgZGUgcmVtcGxpc3NhZ2Ugw6AgcGFydGlyIGTigJl1bmUgY29uc3RhbnRlPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPk91aTwvc3Ryb25nPi5cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0ZpbGwtUmFzdGVyX3RhZzBAQFwiOiBcIlNww6ljaWZpZXogdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciBwZXJtZXR0YW50IGRlIHJlbnNlaWduZXIgdG91cyBsZXMgYml0cyBub24gaW1wbGlxdcOpcyBkYW5zIGxhIHRyYW5zcG9zaXRpb24uIENlIHBhcmFtw6h0cmUgZXN0IHZpc2libGUgc2kgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPkfDqW7DqXJlciB1biByYXN0ZXIgZGUgcmVtcGxpc3NhZ2Ugw6AgcGFydGlyIGTigJl1bmUgY29uc3RhbnRlPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPk5vbjwvc3Ryb25nPi5cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0dlbmVyYXRlLUZpbGwtUmFzdGVyLWZyb20tQ29uc3RhbnRfdGFnMEBAXCI6IFwiR8OpbsOpcmVyIHVuIHJhc3RlciBkZSByZW1wbGlzc2FnZSDDoCBs4oCZYWlkZSBk4oCZdW5lIHZhbGV1ciBjb25zdGFudGUuXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19HZW5lcmF0ZS1GaWxsLVJhc3Rlci1mcm9tLUNvbnN0YW50X3RhZzFAQFwiOiBcIjxzdHJvbmc+T3VpPC9zdHJvbmc+IDogdW4gcmFzdGVyIHNlcmEgZ8OpbsOpcsOpIMOgIGzigJlhaWRlIGTigJl1bmUgdmFsZXVyIGNvbnN0YW50ZSBwb3VyIHJlbnNlaWduZXIgdG91cyBsZXMgYml0cyBub24gaW1wbGlxdcOpcyBkYW5zIGxhIHRyYW5zcG9zaXRpb24uIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19HZW5lcmF0ZS1GaWxsLVJhc3Rlci1mcm9tLUNvbnN0YW50X3RhZzNAQFwiOiBcIjxzdHJvbmc+Tm9uPC9zdHJvbmc+IDogdW4gcmFzdGVyIHNlcmEgZ8OpbsOpcsOpIMOgIGzigJlhaWRlIGRlIHZhbGV1cnMgZGUgcGl4ZWxzIHByb3ZlbmFudCBk4oCZdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciBleGlzdGFudCBwb3VyIHJlbnNlaWduZXIgdG91cyBsZXMgYml0cyBub24gaW1wbGlxdcOpcyBkYW5zIGxhIHRyYW5zcG9zaXRpb24uXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19PdXRwdXQtQml0LWFuZC1JbnB1dC1CaXRfdGFnMEBAXCI6IFwiVW5lIHRhYmxlIGVuIGxlY3R1cmUgc2V1bGUgcHLDqXNlbnRhbnQgbGVzIGJpdHMgZW4gc29ydGllIGV0IGxlcyBlbnRyw6llcyBxdWkgc2Vyb250IMOgIGxldXIgcGxhY2UuXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19SYXN0ZXJfdGFnMEBAXCI6IFwiTGUgcmFzdGVyIGVuIGVudHLDqWUgw6AgZMOpY29tcHJlc3NlciBldCBhcHBhcmllciDDoCBub3V2ZWF1LlwiLFxuXHRcIkBAVW5pdC1Db252ZXJzaW9uX0Zyb20tVW5pdF90YWcwQEBcIjogXCJUeXBlIGTigJl1bml0w6kgZOKAmW9yaWdpbmUgZGVzIHBpeGVscy5cIixcblx0XCJAQFVuaXQtQ29udmVyc2lvbl9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgcXVpIGNvbnRpZW50IGxlcyB1bml0w6lzIGNvbnZlcnRpZXMuXCIsXG5cdFwiQEBVbml0LUNvbnZlcnNpb25fVG8tVW5pdF90YWcwQEBcIjogXCJUeXBlIGTigJl1bml0w6kgY29udmVydGllIGRlcyBwaXhlbHMuXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfQW5nbGUtUmVmZXJlbmNlLVN5c3RlbV90YWcwQEBcIjogXCJTcMOpY2lmaWUgbGEgZmHDp29uIGRvbnQgbGUgY29tcG9zYW50IGRlIGRpcmVjdGlvbiBhIMOpdMOpIG1lc3Vyw6kuXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfQW5nbGUtUmVmZXJlbmNlLVN5c3RlbV90YWcxQEBcIjogXCJHw6lvZ3JhcGhpcXVlwqA6IDDCsCBwb2ludGUgdmVycyBsZSBub3JkIGV0IDkwwrAgcG9pbnRlIHZlcnMgbOKAmWVzdFwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX0FuZ2xlLVJlZmVyZW5jZS1TeXN0ZW1fdGFnMkBAXCI6IFwiQXJpdGhtw6l0aXF1ZcKgOiAwwrAgcG9pbnRlIHZlcnMgbOKAmWVzdCBldCA5MMKwIHBvaW50ZSB2ZXJzIGxlIG5vcmRcIixcblx0XCJAQFZlY3Rvci1GaWVsZF9JbnB1dC1EYXRhLVR5cGVfdGFnMEBAXCI6IFwiVHlwZSBkZSBjaGFtcCB2ZWN0b3JpZWwgcmVwcsOpc2VudMOpIHBhciB2b3MgZW50csOpZXMuXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfSW5wdXQtRGF0YS1UeXBlX3RhZzFAQFwiOiBcIlVua25vd24gKEluY29ubnUpIDogdm91cyBuZSBzYXZleiBwYXMgc2kgbGVzIGVudHLDqWVzIHJlcHLDqXNlbnRlbnQgZGVzIHZhbGV1cnMgVS1WIG91IGRlcyB2YWxldXJzIE1hZ25pdHVkZS1EaXJlY3Rpb24uXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfSW5wdXQtRGF0YS1UeXBlX3RhZzJAQFwiOiBcIlUtViA6IGxlcyBkb25uw6llcyBlbiBlbnRyw6llIHJlcHLDqXNlbnRlbnQgbGVzIGNvbXBvc2FudHMgVSBldCBWLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX0lucHV0LURhdGEtVHlwZV90YWczQEBcIjogXCJNYWduaXR1ZGUtRGlyZWN0aW9uIDogbGVzIGRvbm7DqWVzIGVuIGVudHLDqWUgcmVwcsOpc2VudGVudCBsYSBtYWduaXR1ZGUgZXQgbGEgZGlyZWN0aW9uLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX091dHB1dC1EYXRhLVR5cGVfdGFnMEBAXCI6IFwiSW5kaXF1ZSBsZSB0eXBlIGRlIGNoYW1wIHZlY3RvcmllbCByZXByw6lzZW50w6kgcGFyIHZvdHJlIHNvcnRpZS5cIixcblx0XCJAQFZlY3Rvci1GaWVsZF9PdXRwdXQtRGF0YS1UeXBlX3RhZzFAQFwiOiBcIk1hZ25pdHVkZS1EaXJlY3Rpb24gOiBsZXMgZG9ubsOpZXMgZW4gc29ydGllIHJlcHLDqXNlbnRlbnQgbGEgbWFnbml0dWRlIGV0IGxhIGRpcmVjdGlvbi5cIixcblx0XCJAQFZlY3Rvci1GaWVsZF9PdXRwdXQtRGF0YS1UeXBlX3RhZzJAQFwiOiBcIlUtViA6IGxlcyBkb25uw6llcyBlbiBzb3J0aWUgcmVwcsOpc2VudGVudCBsZXMgY29tcG9zYW50cyBVIGV0IFYuXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfUmFzdGVyMV90YWcwQEBcIjogXCJQcmVtaWVyIHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX1Jhc3RlcjFfdGFnMUBAXCI6IFwiSWwgc+KAmWFnaXQgZGUgbGEgdmFsZXVyIFUgb3UgZGUgbGEgbWFnbml0dWRlLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX1Jhc3RlcjJfdGFnMEBAXCI6IFwiU2Vjb25kIHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX1Jhc3RlcjJfdGFnMUBAXCI6IFwiSWwgc+KAmWFnaXQgZGUgbGEgdmFsZXVyIFYgb3UgZGUgbGEgZGlyZWN0aW9uLlwiLFxuXHRcIkBAVmlld3NoZWRfQW5hbHlzaXMtTWV0aG9kX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgbcOpdGhvZGUgcXVpIHBlcm1ldHRyYSBkZSBjYWxjdWxlciBsYSB2aXNpYmlsaXTDqS4gQ2V0dGUgb3B0aW9uIHZvdXMgcGVybWV0IGQnYWRhcHRlciBsYSBwcsOpY2lzaW9uIGFmaW4gZCdvcHRpbWlzZXIgbGVzIHBlcmZvcm1hbmNlcy5cIixcblx0XCJAQFZpZXdzaGVkX0FuYWx5c2lzLU1ldGhvZF90YWcxQEBcIjogXCJUb3V0ZXMgbGVzIGxpZ25lcyBkZSB2aXPDqWUgOiB1bmUgbGlnbmUgZGUgdmlzw6llIGVzdCBlZmZlY3R1w6llIHN1ciBjaGFxdWUgcGl4ZWwgZHUgcmFzdGVyIGFmaW4gZOKAmcOpdGFibGlyIGRlcyB6b25lcyB2aXNpYmxlcy4gSWwgcydhZ2l0IGRlIGxhIG3DqXRob2RlIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAVmlld3NoZWRfQW5hbHlzaXMtTWV0aG9kX3RhZzJAQFwiOiBcIkxpZ25lcyBkZSB2aXPDqWUgZHUgcMOpcmltw6h0cmUgOiBkZXMgbGlnbmVzIGRlIHZpc8OpZSBzb250IHVuaXF1ZW1lbnQgZWZmZWN0dcOpZXMgc3VyIGxlcyBwaXhlbHMgc2l0dcOpcyBkYW5zIGxlIHDDqXJpbcOodHJlIGRlcyB6b25lcyB2aXNpYmxlcyBhZmluIGTigJnDqXRhYmxpciBkZXMgem9uZXMgZGUgdmlzaWJpbGl0w6kuIExlcyBwZXJmb3JtYW5jZXMgZGUgY2V0dGUgbcOpdGhvZGUgc29udCBtZWlsbGV1cmVzIHF1ZSBjZWxsZXMgZGUgbGEgbcOpdGhvZGUgPHN0cm9uZz5Ub3V0ZXMgbGVzIGxpZ25lcyBkZSB2aXPDqWU8L3N0cm9uZz4sIGNhciB1biBtb2lucyBncmFuZCBub21icmUgZGUgbGlnbmVzIGRlIHZpc8OpZSBzb250IHByw6lzZW50ZXMgZGFucyBsZSBjYWxjdWwuXCIsXG5cdFwiQEBWaWV3c2hlZF9BbmFseXNpcy1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGUgdHlwZSBkJ2FuYWx5c2UgZGUgdmlzaWJpbGl0w6kgcXVlIHZvdXMgc291aGFpdGV6IGVmZmVjdHVlciwgc29pdCBlbiBkw6l0ZXJtaW5hbnQgbGUgZGVncsOpIGRlIHZpc2liaWxpdMOpIGRlIGNoYXF1ZSBjZWxsdWxlIHBhciByYXBwb3J0IGF1eCBwb2ludHMgZCdvYnNlcnZhdGlvbiwgc29pdCBlbiBpZGVudGlmaWFudCBwb3VyIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBsYSBzdXJmYWNlIHF1ZWxzIHBvaW50cyBkJ29ic2VydmF0aW9uIHNvbnQgdmlzaWJsZXMuXCIsXG5cdFwiQEBWaWV3c2hlZF9BbmFseXNpcy1UeXBlX3RhZzFAQFwiOiBcIkZyw6lxdWVuY2UgOiBsZSBub21icmUgZGUgZm9pcyBvw7kgY2hhcXVlIGVtcGxhY2VtZW50IGRlIHBpeGVsIGRhbnMgbGUgcmFzdGVyIGRlIHN1cmZhY2UgZW4gZW50csOpZSBlc3QgdmlzaWJsZSBkZXB1aXMgbGVzIGVtcGxhY2VtZW50cyBkZXMgcG9pbnRzIGTigJlvYnNlcnZhdGlvbiBlbiBlbnRyw6llIChlbiB0YW50IHF1ZSBwb2ludHMgb3UgZW4gdGFudCBxdWUgc29tbWV0cyBwb3VyIGxlcyBlbnRpdMOpcyBwb2x5bGlnbmVzIGTigJlvYnNlcnZhdGlvbikuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBWaWV3c2hlZF9BbmFseXNpcy1UeXBlX3RhZzJAQFwiOiBcIlBvaW50cyBk4oCZb2JzZXJ2YXRpb24gOiBsYSBzb3J0aWUgaWRlbnRpZmllIGF2ZWMgcHLDqWNpc2lvbiBsZXMgcG9pbnRzIGTigJlvYnNlcnZhdGlvbiB2aXNpYmxlcyBkZXB1aXMgY2hhcXVlIGVtcGxhY2VtZW50IGRlIGxhIHN1cmZhY2UgcmFzdGVyLiBMZSBub21icmUgbWF4aW1hbCBhdXRvcmlzw6kgZGUgcG9pbnRzIGQnb2JzZXJ2YXRpb24gZW4gZW50csOpZSBlc3QgMzIgYXZlYyBjZSB0eXBlIGQnYW5hbHlzZS5cIixcblx0XCJAQFZpZXdzaGVkX0hvcml6b250YWwtRW5kLUFuZ2xlX3RhZzBAQFwiOiBcIkNldHRlIHZhbGV1ciBkw6lmaW5pdCBsJ2FuZ2xlIGRlIGZpbiBkZSBsYSBwbGFnZSBkJ2FuYWx5c2UgaG9yaXpvbnRhbGUuIExhIHZhbGV1ciBkb2l0IMOqdHJlIGV4cHJpbcOpZSBlbiBkZWdyw6lzIGRlIDAgw6AgMzYwLjAsIDAgw6l0YW50IG9yaWVudMOpIHZlcnMgbGUgbm9yZC4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAzNjAuMC5cIixcblx0XCJAQFZpZXdzaGVkX0hvcml6b250YWwtRW5kLUFuZ2xlX3RhZzFAQFwiOiBcIklsIHBldXQgc+KAmWFnaXIgZOKAmXVuIGNoYW1wIGR1IGpldSBkZSBkb25uw6llcyA8c3Ryb25nPkVudGl0w6lzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb248L3N0cm9uZz4gZW4gZW50csOpZSBvdSBk4oCZdW5lIHZhbGV1ciBudW3DqXJpcXVlLiBTaSB1bmUgdmFsZXVyIGVzdCBhdHRyaWJ1w6llIMOgIGNlIHBhcmFtw6h0cmUsIGVsbGUgZXN0IGFwcGxpcXXDqWUgw6AgdG91cyBsZXMgcG9pbnRzIGTigJlvYnNlcnZhdGlvbi4gUG91ciBzcMOpY2lmaWVyIGRlcyB2YWxldXJzIGRpZmbDqXJlbnRlcyBwb3VyIGNoYXF1ZSBwb2ludCBk4oCZb2JzZXJ2YXRpb24sIGTDqWZpbmlzc2V6IGNlIHBhcmFtw6h0cmUgc3VyIHVuIGNoYW1wIGR1IGpldSBkZSBkb25uw6llcyA8c3Ryb25nPkVudGl0w6lzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb248L3N0cm9uZz4uXCIsXG5cdFwiQEBWaWV3c2hlZF9Ib3Jpem9udGFsLVN0YXJ0LUFuZ2xlX3RhZzBAQFwiOiBcIkNldHRlIHZhbGV1ciBkw6lmaW5pdCBsJ2FuZ2xlIGRlIGTDqXBhcnQgZGUgbGEgcGxhZ2UgZCdhbmFseXNlIGhvcml6b250YWxlLiBMYSB2YWxldXIgZG9pdCDDqnRyZSBleHByaW3DqWUgZW4gZGVncsOpcyBkZSAwIMOgIDM2MC4wLCAwIMOpdGFudCBvcmllbnTDqSB2ZXJzIGxlIG5vcmQuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMC5cIixcblx0XCJAQFZpZXdzaGVkX0hvcml6b250YWwtU3RhcnQtQW5nbGVfdGFnMUBAXCI6IFwiSWwgcGV1dCBz4oCZYWdpciBk4oCZdW4gY2hhbXAgZHUgamV1IGRlIGRvbm7DqWVzIDxzdHJvbmc+RW50aXTDqXMgcG9pbnRzIGTigJlvYnNlcnZhdGlvbjwvc3Ryb25nPiBlbiBlbnRyw6llIG91IGTigJl1bmUgdmFsZXVyIG51bcOpcmlxdWUuIFNpIHVuZSB2YWxldXIgZXN0IGF0dHJpYnXDqWUgw6AgY2UgcGFyYW3DqHRyZSwgZWxsZSBlc3QgYXBwbGlxdcOpZSDDoCB0b3VzIGxlcyBwb2ludHMgZOKAmW9ic2VydmF0aW9uLiBQb3VyIHNww6ljaWZpZXIgZGVzIHZhbGV1cnMgZGlmZsOpcmVudGVzIHBvdXIgY2hhcXVlIHBvaW50IGTigJlvYnNlcnZhdGlvbiwgZMOpZmluaXNzZXogY2UgcGFyYW3DqHRyZSBzdXIgdW4gY2hhbXAgZHUgamV1IGRlIGRvbm7DqWVzIDxzdHJvbmc+RW50aXTDqXMgcG9pbnRzIGTigJlvYnNlcnZhdGlvbjwvc3Ryb25nPi5cIixcblx0XCJAQFZpZXdzaGVkX0lubmVyLVJhZGl1cy1pcy0zRC1EaXN0YW5jZV90YWcwQEBcIjogXCJUeXBlIGRlIGRpc3RhbmNlIHBvdXIgbGUgcGFyYW3DqHRyZSBkZSByYXlvbiBpbnTDqXJpZXVyLlwiLFxuXHRcIkBAVmlld3NoZWRfSW5uZXItUmFkaXVzLWlzLTNELURpc3RhbmNlX3RhZzFAQFwiOiBcIkTDqXNhY3RpdsOpIDogbGUgPHN0cm9uZz5SYXlvbiBpbnTDqXJpZXVyPC9zdHJvbmc+IGRvaXQgw6p0cmUgaW50ZXJwcsOpdMOpIGNvbW1lIHVuZSBkaXN0YW5jZSAyRC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFZpZXdzaGVkX0lubmVyLVJhZGl1cy1pcy0zRC1EaXN0YW5jZV90YWc0QEBcIjogXCJBY3RpdsOpIDogbGUgPHN0cm9uZz5SYXlvbiBpbnTDqXJpZXVyPC9zdHJvbmc+IGRvaXQgw6p0cmUgaW50ZXJwcsOpdMOpIGNvbW1lIHVuZSBkaXN0YW5jZSAzRC5cIixcblx0XCJAQFZpZXdzaGVkX0lubmVyLVJhZGl1c190YWcwQEBcIjogXCJDZXR0ZSB2YWxldXIgZMOpZmluaXQgbGEgZGlzdGFuY2UgZGUgZMOpcGFydCAobWluaW11bSkgw6AgcGFydGlyIGRlIGxhcXVlbGxlIGxhIHZpc2liaWxpdMOpIGVzdCBkw6l0ZXJtaW7DqWUuIExlcyBwaXhlbHMgcGx1cyBwcm9jaGVzIHF1ZSBjZXR0ZSBkaXN0YW5jZSBzb250IGNvbnNpZMOpcsOpcyBjb21tZSBub24gdmlzaWJsZXMgZGFucyBsYSBzb3J0aWUsIG1haXMgcGV1dmVudCB0b3Vqb3VycyBlbXDDqmNoZXIgbGEgdmlzaWJpbGl0w6kgZGVzIHBpeGVscyBzaXR1w6lzIGVudHJlIGxlIDxzdHJvbmc+UmF5b24gaW50w6lyaWV1cjwvc3Ryb25nPiBldCBsZSA8c3Ryb25nPlJheW9uIGV4dMOpcmlldXI8L3N0cm9uZz4uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMC5cIixcblx0XCJAQFZpZXdzaGVkX0lubmVyLVJhZGl1c190YWc1QEBcIjogXCJJbCBwZXV0IHPigJlhZ2lyIGTigJl1biBjaGFtcCBkdSBqZXUgZGUgZG9ubsOpZXMgPHN0cm9uZz5FbnRpdMOpcyBwb2ludHMgZOKAmW9ic2VydmF0aW9uPC9zdHJvbmc+IGVuIGVudHLDqWUgb3UgZOKAmXVuZSB2YWxldXIgbnVtw6lyaXF1ZS4gU2kgdW5lIHZhbGV1ciBlc3QgYXR0cmlidcOpZSDDoCBjZSBwYXJhbcOodHJlLCBlbGxlIGVzdCBhcHBsaXF1w6llIMOgIHRvdXMgbGVzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb24uIFBvdXIgc3DDqWNpZmllciBkZXMgdmFsZXVycyBkaWZmw6lyZW50ZXMgcG91ciBjaGFxdWUgcG9pbnQgZOKAmW9ic2VydmF0aW9uLCBkw6lmaW5pc3NleiBjZSBwYXJhbcOodHJlIHN1ciB1biBjaGFtcCBkdSBqZXUgZGUgZG9ubsOpZXMgPHN0cm9uZz5FbnRpdMOpcyBwb2ludHMgZOKAmW9ic2VydmF0aW9uPC9zdHJvbmc+LlwiLFxuXHRcIkBAVmlld3NoZWRfT2JzZXJ2ZXItRWxldmF0aW9uX3RhZzBAQFwiOiBcIkNldHRlIHZhbGV1ciBwZXJtZXQgZGUgZMOpZmluaXIgbGVzIGFsdGl0dWRlcyBkZXMgc3VyZmFjZXMgZGVzIHBvaW50cyBkJ29ic2VydmF0aW9uIG91IGRlcyBzb21tZXRzLlwiLFxuXHRcIkBAVmlld3NoZWRfT2JzZXJ2ZXItRWxldmF0aW9uX3RhZzFAQFwiOiBcIklsIHBldXQgc+KAmWFnaXIgZOKAmXVuIGNoYW1wIGR1IGpldSBkZSBkb25uw6llcyA8c3Ryb25nPkVudGl0w6lzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb248L3N0cm9uZz4gZW4gZW50csOpZSBvdSBk4oCZdW5lIHZhbGV1ciBudW3DqXJpcXVlLiBTaSBjZSBwYXJhbcOodHJlIG7igJllc3QgcGFzIHNww6ljaWZpw6ksIGzigJnDqWzDqXZhdGlvbiBkdSBwb2ludCBk4oCZb2JzZXJ2YXRpb24gc+KAmW9idGllbnQgw6AgcGFydGlyIGR1IHJhc3RlciBkZSBzdXJmYWNlIMOgIGzigJlhaWRlIGRlIGzigJlpbnRlcnBvbGF0aW9uIGJpbGluw6lhaXJlLiBTaSB1bmUgdmFsZXVyIGVzdCBhdHRyaWJ1w6llIMOgIGNlIHBhcmFtw6h0cmUsIGVsbGUgZXN0IGFwcGxpcXXDqWUgw6AgdG91cyBsZXMgcG9pbnRzIGTigJlvYnNlcnZhdGlvbi4gUG91ciBzcMOpY2lmaWVyIGRlcyB2YWxldXJzIGRpZmbDqXJlbnRlcyBwb3VyIGNoYXF1ZSBwb2ludCBk4oCZb2JzZXJ2YXRpb24sIGTDqWZpbmlzc2V6IGNlIHBhcmFtw6h0cmUgc3VyIHVuIGNoYW1wIGR1IGpldSBkZSBkb25uw6llcyA8c3Ryb25nPkVudGl0w6lzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb248L3N0cm9uZz4uXCIsXG5cdFwiQEBWaWV3c2hlZF9PYnNlcnZlci1GZWF0dXJlc190YWcwQEBcIjogXCJMYSBjbGFzc2UgZOKAmWVudGl0w6lzIHJlcXVpc2UgZW4gZW50csOpZSBxdWkgaWRlbnRpZmllIGxlcyBlbXBsYWNlbWVudHMgZGVzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb24uIElsIHBldXQgcydhZ2lyIGQnZW50aXTDqXMgcG9uY3R1ZWxsZXMsIG11bHRpLXBvaW50cyBvdSBwb2x5bGluw6lhaXJlcy5cIixcblx0XCJAQFZpZXdzaGVkX09ic2VydmVyLUZlYXR1cmVzX3RhZzFAQFwiOiBcIkxhIGNsYXNzZSBkJ2VudGl0w6lzIGVuIGVudHLDqWUgZXN0IHRyYW5zZm9ybcOpZSBlbiBzeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgM0QgZ8Opb2NlbnRyaXF1ZXMgYXUgY291cnMgZHUgY2FsY3VsIGRlIGxhIHZpc2liaWxpdMOpLiBMZXMgcG9pbnRzIGQnb2JzZXJ2YXRpb24gZW4gZGVob3JzIGRlIGwnw6l0ZW5kdWUgZHUgcmFzdGVyIGRlIHN1cmZhY2UsIG91IHNlIHRyb3V2YW50IHN1ciBsZXMgY2VsbHVsZXMgTm9EYXRhLCBuZSBzb250IHBhcyBwcmlzIGVuIGNvbXB0ZSBkYW5zIGxlIGNhbGN1bC5cIixcblx0XCJAQFZpZXdzaGVkX09ic2VydmVyLU9mZnNldF90YWcwQEBcIjogXCJDZXR0ZSB2YWxldXIgaW5kaXF1ZSBsYSBkaXN0YW5jZSB2ZXJ0aWNhbGUgKGVuIHVuaXTDqXMgZGUgc3VyZmFjZSkgw6AgYWpvdXRlciDDoCBsJ2FsdGl0dWRlIGR1IHBvaW50IGQnb2JzZXJ2YXRpb24uIExhIHZhbGV1ciBkb2l0IMOqdHJlIHVuIGVudGllciBwb3NpdGlmIG91IHVuIG5vbWJyZSDDoCB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XCJAQFZpZXdzaGVkX09ic2VydmVyLU9mZnNldF90YWcxQEBcIjogXCJJbCBwZXV0IHPigJlhZ2lyIGTigJl1biBjaGFtcCBkdSBqZXUgZGUgZG9ubsOpZXMgPHN0cm9uZz5FbnRpdMOpcyBwb2ludHMgZOKAmW9ic2VydmF0aW9uPC9zdHJvbmc+IGVuIGVudHLDqWUgb3UgZOKAmXVuZSB2YWxldXIgbnVtw6lyaXF1ZS4gU2kgdW5lIHZhbGV1ciBlc3QgYXR0cmlidcOpZSDDoCBjZSBwYXJhbcOodHJlLCBlbGxlIGVzdCBhcHBsaXF1w6llIMOgIHRvdXMgbGVzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb24uIFBvdXIgc3DDqWNpZmllciBkZXMgdmFsZXVycyBkaWZmw6lyZW50ZXMgcG91ciBjaGFxdWUgcG9pbnQgZOKAmW9ic2VydmF0aW9uLCBkw6lmaW5pc3NleiBjZSBwYXJhbcOodHJlIHN1ciB1biBjaGFtcCBkdSBqZXUgZGUgZG9ubsOpZXMgPHN0cm9uZz5FbnRpdMOpcyBwb2ludHMgZOKAmW9ic2VydmF0aW9uPC9zdHJvbmc+LlwiLFxuXHRcIkBAVmlld3NoZWRfT3V0ZXItUmFkaXVzLWlzLTNELURpc3RhbmNlX3RhZzBAQFwiOiBcIlR5cGUgZGUgZGlzdGFuY2UgcG91ciBsZSBwYXJhbcOodHJlIGRlIHJheW9uIGV4dMOpcmlldXIuXCIsXG5cdFwiQEBWaWV3c2hlZF9PdXRlci1SYWRpdXMtaXMtM0QtRGlzdGFuY2VfdGFnMUBAXCI6IFwiRMOpc2FjdGl2w6kgOiBsZSA8c3Ryb25nPlJheW9uIGV4dMOpcmlldXI8L3N0cm9uZz4gZG9pdCDDqnRyZSBpbnRlcnByw6l0w6kgY29tbWUgdW5lIGRpc3RhbmNlIDJELiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAVmlld3NoZWRfT3V0ZXItUmFkaXVzLWlzLTNELURpc3RhbmNlX3RhZzRAQFwiOiBcIkFjdGl2w6kgOiBsZSA8c3Ryb25nPlJheW9uIGV4dMOpcmlldXI8L3N0cm9uZz4gZG9pdCDDqnRyZSBpbnRlcnByw6l0w6kgY29tbWUgdW5lIGRpc3RhbmNlIDNELlwiLFxuXHRcIkBAVmlld3NoZWRfT3V0ZXItUmFkaXVzX3RhZzBAQFwiOiBcIkNldHRlIHZhbGV1ciBkw6lmaW5pdCBsYSBkaXN0YW5jZSBtYXhpbWFsZSDDoCBwYXJ0aXIgZGUgbGFxdWVsbGUgbGEgdmlzaWJpbGl0w6kgZXN0IGTDqXRlcm1pbsOpZS4gTGVzIHBpeGVscyBzaXR1w6lzIGF1LWRlbMOgIGRlIGNldHRlIGRpc3RhbmNlIHNvbnQgZXhjbHVzIGRlIGwnYW5hbHlzZS5cIixcblx0XCJAQFZpZXdzaGVkX091dGVyLVJhZGl1c190YWcxQEBcIjogXCJJbCBwZXV0IHPigJlhZ2lyIGTigJl1biBjaGFtcCBkdSBqZXUgZGUgZG9ubsOpZXMgPHN0cm9uZz5FbnRpdMOpcyBwb2ludHMgZOKAmW9ic2VydmF0aW9uPC9zdHJvbmc+IGVuIGVudHLDqWUgb3UgZOKAmXVuZSB2YWxldXIgbnVtw6lyaXF1ZS4gU2kgdW5lIHZhbGV1ciBlc3QgYXR0cmlidcOpZSDDoCBjZSBwYXJhbcOodHJlLCBlbGxlIGVzdCBhcHBsaXF1w6llIMOgIHRvdXMgbGVzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb24uIFBvdXIgc3DDqWNpZmllciBkZXMgdmFsZXVycyBkaWZmw6lyZW50ZXMgcG91ciBjaGFxdWUgcG9pbnQgZOKAmW9ic2VydmF0aW9uLCBkw6lmaW5pc3NleiBjZSBwYXJhbcOodHJlIHN1ciB1biBjaGFtcCBkdSBqZXUgZGUgZG9ubsOpZXMgPHN0cm9uZz5FbnRpdMOpcyBwb2ludHMgZOKAmW9ic2VydmF0aW9uPC9zdHJvbmc+LlwiLFxuXHRcIkBAVmlld3NoZWRfUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBkZSBzdXJmYWNlIGVuIGVudHLDqWUgcmVxdWlzLiBJbCBwZXV0IHMnYWdpciBkJ3VuIGVudGllciBvdSBkJ3VuIHJhc3RlciBlbiB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XCJAQFZpZXdzaGVkX1Jhc3Rlcl90YWcxQEBcIjogXCJMJ2VudHLDqWUgZXN0IHRyYW5zZm9ybcOpZSBlbiBzeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgM0QgZ8Opb2NlbnRyaXF1ZXMgYXUgY291cnMgZHUgY2FsY3VsIGRlIGxhIHZpc2liaWxpdMOpLiBMZXMgY2VsbHVsZXMgTm9EYXRhIGR1IHJhc3RlciBlbiBlbnRyw6llIG4nZW1ww6pjaGVudCBwYXMgZGUgZMOpdGVybWluZXIgbGEgdmlzaWJpbGl0w6kuXCIsXG5cdFwiQEBWaWV3c2hlZF9SZWZyYWN0aXZlLUNvZWZmaWNpZW50X3RhZzBAQFwiOiBcIkNvZWZmaWNpZW50IGRlIHLDqWZyYWN0aW9uIGRlIGxhIGx1bWnDqHJlIHZpc2libGUgZGFucyBsJ2Fpci5cIixcblx0XCJAQFZpZXdzaGVkX1JlZnJhY3RpdmUtQ29lZmZpY2llbnRfdGFnMUBAXCI6IFwiTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAwLDEzLlwiLFxuXHRcIkBAVmlld3NoZWRfU3VyZmFjZS1PZmZzZXRfdGFnMEBAXCI6IFwiQ2V0dGUgdmFsZXVyIGluZGlxdWUgbGEgZGlzdGFuY2UgdmVydGljYWxlIChlbiB1bml0w6lzIGRlIHN1cmZhY2UpIMOgIGFqb3V0ZXIgw6AgbGEgdmFsZXVyIHogZGUgY2hhcXVlIHBpeGVsIGNpYmxlLCB0ZWxsZSBxdSdlbGxlIGVzdCBwcmlzZSBlbiBjb21wdGUgcG91ciBsYSB2aXNpYmlsaXTDqS4gTGEgdmFsZXVyIGRvaXQgw6p0cmUgdW4gZW50aWVyIHBvc2l0aWYgb3UgdW4gbm9tYnJlIMOgIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcIkBAVmlld3NoZWRfU3VyZmFjZS1PZmZzZXRfdGFnMUBAXCI6IFwiSWwgcGV1dCBz4oCZYWdpciBk4oCZdW4gY2hhbXAgZHUgamV1IGRlIGRvbm7DqWVzIDxzdHJvbmc+RW50aXTDqXMgcG9pbnRzIGTigJlvYnNlcnZhdGlvbjwvc3Ryb25nPiBlbiBlbnRyw6llIG91IGTigJl1bmUgdmFsZXVyIG51bcOpcmlxdWUuIFNpIHVuZSB2YWxldXIgZXN0IGF0dHJpYnXDqWUgw6AgY2UgcGFyYW3DqHRyZSwgZWxsZSBlc3QgYXBwbGlxdcOpZSDDoCB0b3VzIGxlcyBwb2ludHMgZOKAmW9ic2VydmF0aW9uLiBQb3VyIHNww6ljaWZpZXIgZGVzIHZhbGV1cnMgZGlmZsOpcmVudGVzIHBvdXIgY2hhcXVlIHBvaW50IGTigJlvYnNlcnZhdGlvbiwgZMOpZmluaXNzZXogY2UgcGFyYW3DqHRyZSBzdXIgdW4gY2hhbXAgZHUgamV1IGRlIGRvbm7DqWVzIDxzdHJvbmc+RW50aXTDqXMgcG9pbnRzIGTigJlvYnNlcnZhdGlvbjwvc3Ryb25nPi5cIixcblx0XCJAQFZpZXdzaGVkX1ZlcnRpY2FsLUVycm9yX3RhZzBAQFwiOiBcIk5pdmVhdSBkJ2luY2VydGl0dWRlLCBtZXN1csOpIGVuIHRhbnQgcXUnZXJyZXVyIHF1YWRyYXRpcXVlIG1veWVubmUgKEVRTSkgZGVzIHZhbGV1cnMgZCdhbHRpdHVkZSBkZSBzdXJmYWNlLiBJbCBzJ2FnaXQgZGUgbGEgdmFsZXVyIMOgIHZpcmd1bGUgZmxvdHRhbnRlIHJlcHLDqXNlbnRhbnQgbCdlcnJldXIgYXR0ZW5kdWUgZGVzIHZhbGV1cnMgZCdhbHRpdHVkZSBlbiBlbnRyw6llLiBMb3JzcXVlIGNlIHBhcmFtw6h0cmUgc2Ugdm9pdCBhdHRyaWJ1ZXIgdW5lIHZhbGV1ciBzdXDDqXJpZXVyZSDDoCAwLCBsZSByYXN0ZXIgZGUgdmlzaWJpbGl0w6kgZW4gc29ydGllIHNlcmEgw6AgdmlyZ3VsZSBmbG90dGFudGUuIERhbnMgY2UgY2FzLCBjaGFxdWUgdmFsZXVyIGRlIHBpeGVsIGR1IHJhc3RlciBkZSB2aXNpYmlsaXTDqSBlbiBzb3J0aWUgcmVwcsOpc2VudGUgbGEgc29tbWUgZGVzIHByb2JhYmlsaXTDqXMgcXVlIGxhIGNlbGx1bGUgcHVpc3NlIMOqdHJlIHZ1ZSBkJ3VuIHF1ZWxjb25xdWUgcG9pbnQgZCdvYnNlcnZhdGlvbi5cIixcblx0XCJAQFZpZXdzaGVkX1ZlcnRpY2FsLUVycm9yX3RhZzFAQFwiOiBcIkxvcnNxdWUgbGUgPHN0cm9uZz5UeXBlIGTigJlhbmFseXNlPC9zdHJvbmc+IGVzdCA8c3Ryb25nPlBvaW50cyBk4oCZb2JzZXJ2YXRpb248L3N0cm9uZz4gb3UgcXVlIGxhIDxzdHJvbmc+TcOpdGhvZGUgZOKAmWFuYWx5c2U8L3N0cm9uZz4gZXN0IDxzdHJvbmc+TGlnbmVzIGRlIHZpc8OpZSBkdSBww6lyaW3DqHRyZTwvc3Ryb25nPiwgY2UgcGFyYW3DqHRyZSBlc3QgZMOpc2FjdGl2w6kuXCIsXG5cdFwiQEBWaWV3c2hlZF9WZXJ0aWNhbC1Mb3dlci1BbmdsZV90YWcwQEBcIjogXCJDZXR0ZSB2YWxldXIgZMOpZmluaXQgbGEgbGltaXRlIGRlIGwnYW5nbGUgdmVydGljYWwgaW5mw6lyaWV1ciBkZSBsJ2FuYWx5c2UgYXUtZGVzc291cyBkdSBwbGFuIGhvcml6b250YWwuIExhIHZhbGV1ciBkb2l0IMOqdHJlIGV4cHJpbcOpZSBlbiBkZWdyw6lzIGRlIC05MC4wIMOgIDAgZXQgcGV1dCDDqnRyZSB1biBlbnRpZXIgb3UgdW5lIHZhbGV1ciDDoCB2aXJndWxlIGZsb3R0YW50ZS4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAtOTAuMC5cIixcblx0XCJAQFZpZXdzaGVkX1ZlcnRpY2FsLUxvd2VyLUFuZ2xlX3RhZzFAQFwiOiBcIklsIHBldXQgc+KAmWFnaXIgZOKAmXVuIGNoYW1wIGR1IGpldSBkZSBkb25uw6llcyA8c3Ryb25nPkVudGl0w6lzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb248L3N0cm9uZz4gZW4gZW50csOpZSBvdSBk4oCZdW5lIHZhbGV1ciBudW3DqXJpcXVlLiBTaSB1bmUgdmFsZXVyIGVzdCBhdHRyaWJ1w6llIMOgIGNlIHBhcmFtw6h0cmUsIGVsbGUgZXN0IGFwcGxpcXXDqWUgw6AgdG91cyBsZXMgcG9pbnRzIGTigJlvYnNlcnZhdGlvbi4gUG91ciBzcMOpY2lmaWVyIGRlcyB2YWxldXJzIGRpZmbDqXJlbnRlcyBwb3VyIGNoYXF1ZSBwb2ludCBk4oCZb2JzZXJ2YXRpb24sIGTDqWZpbmlzc2V6IGNlIHBhcmFtw6h0cmUgc3VyIHVuIGNoYW1wIGR1IGpldSBkZSBkb25uw6llcyA8c3Ryb25nPkVudGl0w6lzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb248L3N0cm9uZz4uXCIsXG5cdFwiQEBWaWV3c2hlZF9WZXJ0aWNhbC1VcHBlci1BbmdsZV90YWcwQEBcIjogXCJDZXR0ZSB2YWxldXIgZMOpZmluaXQgbGEgbGltaXRlIGRlIGwnYW5nbGUgdmVydGljYWwgc3Vww6lyaWV1ciBkZSBsJ2FuYWx5c2UgYXUtZGVzc3VzIGR1IHBsYW4gaG9yaXpvbnRhbC4gTGEgdmFsZXVyIGRvaXQgw6p0cmUgZXhwcmltw6llIGVuIGRlZ3LDqXMgZGUgMCDDoCA5MC4wIGV0IHBldXQgw6p0cmUgdW4gZW50aWVyIG91IHVuZSB2YWxldXIgw6AgdmlyZ3VsZSBmbG90dGFudGUuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgOTAuMC5cIixcblx0XCJAQFZpZXdzaGVkX1ZlcnRpY2FsLVVwcGVyLUFuZ2xlX3RhZzFAQFwiOiBcIklsIHBldXQgc+KAmWFnaXIgZOKAmXVuIGNoYW1wIGR1IGpldSBkZSBkb25uw6llcyA8c3Ryb25nPkVudGl0w6lzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb248L3N0cm9uZz4gZW4gZW50csOpZSBvdSBk4oCZdW5lIHZhbGV1ciBudW3DqXJpcXVlLiBTaSB1bmUgdmFsZXVyIGVzdCBhdHRyaWJ1w6llIMOgIGNlIHBhcmFtw6h0cmUsIGVsbGUgZXN0IGFwcGxpcXXDqWUgw6AgdG91cyBsZXMgcG9pbnRzIGTigJlvYnNlcnZhdGlvbi4gUG91ciBzcMOpY2lmaWVyIGRlcyB2YWxldXJzIGRpZmbDqXJlbnRlcyBwb3VyIGNoYXF1ZSBwb2ludCBk4oCZb2JzZXJ2YXRpb24sIGTDqWZpbmlzc2V6IGNlIHBhcmFtw6h0cmUgc3VyIHVuIGNoYW1wIGR1IGpldSBkZSBkb25uw6llcyA8c3Ryb25nPkVudGl0w6lzIHBvaW50cyBk4oCZb2JzZXJ2YXRpb248L3N0cm9uZz4uXCIsXG5cdFwiQEBXYXRlcnNoZWRfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIHF1aSBtb250cmUgbGEgZGlyZWN0aW9uIGR1IGZsdXggc29ydGFudCBkZSBjaGFxdWUgY2VsbHVsZS5cIixcblx0XCJAQFdhdGVyc2hlZF9GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMUBAXCI6IFwiTGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBkZSBmbHV4IHBldXQgw6p0cmUgY3LDqcOpIGVuIGV4w6ljdXRhbnQgbGEgZm9uY3Rpb24gPHN0cm9uZz5EaXJlY3Rpb24gZGUgZmx1eDwvc3Ryb25nPi5cIixcblx0XCJAQFdhdGVyc2hlZF9Qb3VyLVBvaW50KHMpLVJhc3Rlcl90YWcwQEBcIjogXCJFbXBsYWNlbWVudHMgZGVzIHBvaW50cyBkJ8OpY291bGVtZW50IGVuIGVudHLDqWUuXCIsXG5cdFwiQEBXYXRlcnNoZWRfUG91ci1Qb2ludChzKS1SYXN0ZXJfdGFnMUBAXCI6IFwiQ2UgcmFzdGVyIHJlcHLDqXNlbnRlIGxlcyBjZWxsdWxlcyBhdS1kZXNzdXMgZGVzcXVlbGxlcyBsYSBzdXJmYWNlIGRlIGNhcHRhdGlvbiBlc3QgZMOpdGVybWluw6llLiBUb3V0ZXMgbGVzIGNlbGx1bGVzIG4nYXlhbnQgcGFzIGxhIHZhbGV1ciBOb0RhdGEgc29udCB1dGlsaXPDqWVzIGVuIHRhbnQgcXVlIGNlbGx1bGVzIHNvdXJjZXMuXCIsXG5cdFwiQEBXYXRlcnNoZWRfUG91ci1Qb2ludC1GaWVsZF90YWcwQEBcIjogXCJDaGFtcCB1dGlsaXPDqSBwb3VyIGF0dHJpYnVlciBkZXMgdmFsZXVycyBhdXggZW1wbGFjZW1lbnRzIGRlIHBvaW50cyBkJ8OpY291bGVtZW50LlwiLFxuXHRcIkBAV2F0ZXJzaGVkX1BvdXItUG9pbnQtRmllbGRfdGFnMUBAXCI6IFwiRGFucyBsZSBjYXMgZOKAmXVuIGpldSBkZSBkb25uw6llcyByYXN0ZXIgZGUgcG9pbnRzIGTigJnDqWNvdWxlbWVudCwgbOKAmW9wdGlvbiAke1ZhbHVlfSBlc3QgdXRpbGlzw6llIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob2lzaXNzZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJNaW5pIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTW95ZW5uZSBkZSA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfU2NhbGVzX3RhZzBAQFwiOiBcIlBsYWdlIGRlcyBub3V2ZWxsZXMgdmFsZXVycyBwZXJtZXR0YW50IGRlIGNsYXNzaWZpZXIgbGVzIGFuY2llbm5lcyB2YWxldXJzLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9XZWlnaHRlZC1PdmVybGF5LVRhYmxlX3RhZzBAQFwiOiBcIkxhIHRhYmxlIGRlIHN1cGVycG9zaXRpb24gcG9uZMOpcsOpZSBzZSBjb21wb3NlIGRlIHF1YXRyZSBwYXJ0aWVzIDpcIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfV2VpZ2h0ZWQtT3ZlcmxheS1UYWJsZV90YWcxQEBcIjogXCJDb3VjaGUgOiB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUgZG9pdmVudCDDqnRyZSBkZXMgZW50aWVycy5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfV2VpZ2h0ZWQtT3ZlcmxheS1UYWJsZV90YWcyQEBcIjogXCJJbmZsdWVuY2UgOiBjaGFxdWUgcmFzdGVyIGVuIGVudHLDqWUgZXN0IHBvbmTDqXLDqSBzZWxvbiBzb24gaW1wb3J0YW5jZSwgb3Ugc29uIGluZmx1ZW5jZSwgZW4gcG91cmNlbnRhZ2UgcmVsYXRpZi4gTGEgc29tbWUgZGVzIHBvbmTDqXJhdGlvbnMgZGVzIHBvdXJjZW50YWdlcyBk4oCZaW5mbHVlbmNlIGRvaXQgw6p0cmUgw6lnYWxlIMOgIDEwMCBldCBjaGFxdWUgcG9uZMOpcmF0aW9uIGRvaXQgw6p0cmUgc3DDqWNpZmnDqWUgw6AgbOKAmWFpZGUgZGUgdmFsZXVycyBlbnRpw6hyZXMuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X1dlaWdodGVkLU92ZXJsYXktVGFibGVfdGFnM0BAXCI6IFwiQ2hhbXAgOiB1biBjaGFtcCBkZSB0eXBlIGVudGllciBvdSBjaGHDrm5lIGRhbnMgbGUgcmFzdGVyIGVuIGVudHLDqWUgw6AgdXRpbGlzZXIgcG91ciBsYSBwb25kw6lyYXRpb24uXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X1dlaWdodGVkLU92ZXJsYXktVGFibGVfdGFnNEBAXCI6IFwiVGFibGUgZGUgY2xhc3NpZmljYXRpb24gOiB1bmUgbm91dmVsbGUgdmFsZXVyIGTigJnDqWNoZWxsZSBiYXPDqWUgc3VyIGxhIHRhYmxlIGRlIGNsYXNzaWZpY2F0aW9uIGVzdCBhZmZlY3TDqWUgw6AgY2hhcXVlIHZhbGV1ciBkYW5zIHVuIHJhc3RlciBlbiBlbnRyw6llLiBMYSB2YWxldXIgZOKAmcOpY2hlbGxlIHBldXQgw6p0cmUgdW5lIHZhbGV1ciB2YWxpZGUgb3UgdW5lIHZhbGV1ciBOb0RhdGEuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9pc2lzc2V6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgbGVzIHRhaWxsZXMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc29udCBpZGVudGlxdWVzLCB0b3V0ZXMgbGVzIG9wdGlvbnMgZG9ubmVudCBsZXMgbcOqbWVzIHLDqXN1bHRhdHMuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkRlcm5pZXIgZGUgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IGRlIDogdXRpbGlzZSBsYSBwbHVzIGdyYW5kZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmkgZGUgOiB1dGlsaXNlIGxhIHBsdXMgcGV0aXRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJlbWllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBkZSA6IHV0aWxpc2UgbOKAmcOpdGVuZHVlIGRlIHRvdXMgbGVzIHJhc3RlcnMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9XZWlnaHRlZC1TdW0tVGFibGVfdGFnMEBAXCI6IFwiTGEgdGFibGUgZGUgc29tbWUgcG9uZMOpcsOpZSBlc3QgZMOpZmluaWUgcGFyIHRyb2lzIHByb3ByacOpdMOpcyA6XCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fV2VpZ2h0ZWQtU3VtLVRhYmxlX3RhZzFAQFwiOiBcIkNvdWNoZSA6IGxlIHJhc3RlciBxdWkgZXN0IHBvbmTDqXLDqS5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9XZWlnaHRlZC1TdW0tVGFibGVfdGFnMkBAXCI6IFwiQ2hhbXAgOiBsZSBjaGFtcCBkdSByYXN0ZXIgw6AgdXRpbGlzZXIgcG91ciBsYSBwb25kw6lyYXRpb24uXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fV2VpZ2h0ZWQtU3VtLVRhYmxlX3RhZzNAQFwiOiBcIlBvbmTDqXJhdGlvbiA6IGxhIHZhbGV1ciBkZSBwb25kw6lyYXRpb24gcGFyIGxhcXVlbGxlIG11bHRpcGxpZXIgbGUgcmFzdGVyLiBJbCBwZXV0IHMnYWdpciBkZSB0b3V0ZSB2YWxldXIgZMOpY2ltYWxlIHBvc2l0aXZlIG91IG7DqWdhdGl2ZS5cIixcblx0XCJAQFdpbmQtQ2hpbGxfVGVtcGVyYXR1cmUtUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBtb25vY2FuYWwgb8O5IGxlcyB2YWxldXJzIGRlIHBpeGVsIHJlcHLDqXNlbnRlbnQgbGEgdGVtcMOpcmF0dXJlIGRlIGzigJlhaXIgYW1iaWFudC5cIixcblx0XCJAQFdpbmQtQ2hpbGxfVGVtcGVyYXR1cmUtVW5pdHNfdGFnMEBAXCI6IFwiVW5pdMOpIGRlIG1lc3VyZSBhc3NvY2nDqWUgYXUgcmFzdGVyIGRlIHRlbXDDqXJhdHVyZSBlbiBlbnRyw6llLiBMZXMgdW5pdMOpcyBkaXNwb25pYmxlcyBlbiBlbnRyw6llIHNvbnQgQ2Vsc2l1cywgRmFocmVuaGVpdCBldCBLZWx2aW4uXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1dpbmQtQ2hpbGwtVW5pdHNfdGFnMEBAXCI6IFwiVW5pdMOpIGRlIG1lc3VyZSBhc3NvY2nDqWUgYXUgcmFzdGVyIGVuIHNvcnRpZS4gTGVzIHVuaXTDqXMgZGlzcG9uaWJsZXMgZW4gc29ydGllIHNvbnQgQ2Vsc2l1cywgRmFocmVuaGVpdCBldCBLZWx2aW4uXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1dpbmQtU3BlZWQtUmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBtb25vY2FuYWwgb8O5IGxlcyB2YWxldXJzIGRlIHBpeGVsIHJlcHLDqXNlbnRlbnQgbGEgdml0ZXNzZSBkdSB2ZW50LlwiLFxuXHRcIkBAV2luZC1DaGlsbF9XaW5kLVNwZWVkLVVuaXRzX3RhZzBAQFwiOiBcIkTDqWZpbml0IGzigJl1bml0w6kgZGUgbWVzdXJlIGR1IHJhc3RlciBkZSB2aXRlc3NlIGR1IHZlbnQuXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1dpbmQtU3BlZWQtVW5pdHNfdGFnMUBAXCI6IFwiTWlsZXMgcGFyIGhldXJlIChtcGgpXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1dpbmQtU3BlZWQtVW5pdHNfdGFnMkBAXCI6IFwiS2lsb23DqHRyZXMgcGFyIGhldXJlIChrbS9oKVwiLFxuXHRcIkBAV2luZC1DaGlsbF9XaW5kLVNwZWVkLVVuaXRzX3RhZzNAQFwiOiBcIk3DqHRyZXMgcGFyIHNlY29uZGUgKG0vcylcIixcblx0XCJAQFdpbmQtQ2hpbGxfV2luZC1TcGVlZC1Vbml0c190YWc0QEBcIjogXCJQaWVkcyBwYXIgc2Vjb25kZSAocGQvcylcIixcblx0XCJAQFdpbmQtQ2hpbGxfV2luZC1TcGVlZC1Vbml0c190YWc1QEBcIjogXCJOxZN1ZHMgKG5kKVwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfQmFja2dyb3VuZC1WYWx1ZV90YWcwQEBcIjogXCJMYSB2YWxldXIgZGUgcGl4ZWwgaW5pdGlhbGUgZHUgcmFzdGVyIGVuIHNvcnRpZSwgYXZhbnQgbGUgY2xhc3NlbWVudCBkZXMgcGl4ZWxzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBab25hbC1SZW1hcF9EZWZhdWx0LU91dHB1dC1WYWx1ZV90YWcwQEBcIjogXCJWYWxldXIgcXVpIHNlcmEgYXR0cmlidcOpZSDDoCB1biBwaXhlbCBxdWkgbmUgcsOpcG9uZCDDoCBhdWN1bmUgZGVzIGNvbmRpdGlvbnMgZMOpZmluaWVzIGRhbnMgbGEgPHN0cm9uZz5UYWJsZSBkZXMgYXR0cmlidXRzIHpvbmF1eDwvc3Ryb25nPi5cIixcblx0XCJAQFpvbmFsLVJlbWFwX0RlZmF1bHQtT3V0cHV0LVZhbHVlX3RhZzNAQFwiOiBcIklsIHPigJlhZ2l0IMOpZ2FsZW1lbnQgZGUgbGEgdmFsZXVyIGR1IHBpeGVsIGVuIHNvcnRpZSBzaSBsZSBwYXJhbcOodHJlIDxzdHJvbmc+Tm9tIGR1IGNoYW1wIGRlIGxhIHZhbGV1ciBlbiBzb3J0aWU8L3N0cm9uZz4gbuKAmWVzdCBwYXMgc3DDqWNpZmnDqSBvdSBzaSBsYSB2YWxldXIgZW4gc29ydGllIGR1IHNldWlsIHpvbmFsIGNvcnJlc3BvbmRhbnQgbuKAmWVzdCBwYXMgc3DDqWNpZmnDqWUgZGFucyBsYSA8c3Ryb25nPlRhYmxlIGRlcyBhdHRyaWJ1dHMgem9uYXV4PC9zdHJvbmc+LlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfTWF4aW11bS1WYWx1ZS1GaWVsZC1OYW1lX3RhZzBAQFwiOiBcIk5vbSBkdSBjaGFtcCBjb250ZW5hbnQgbGEgdmFsZXVyIG1heGltYWxlIGNpLWRlc3NvdXMsIGRhbnMgbGFxdWVsbGUgdW4gcGl4ZWwgZW4gZW50csOpZSBlc3QgY2xhc3PDqS5cIixcblx0XCJAQFpvbmFsLVJlbWFwX01heGltdW0tVmFsdWUtRmllbGQtTmFtZV90YWcxQEBcIjogXCJTaSBhdWN1bmUgdmFsZXVyIG4nZXN0IHNww6ljaWZpw6llIG91IHNpIGxhIHZhbGV1ciBkZSBjaGFtcCBlc3QgTnVsbCwgbGVzIHZhbGV1cnMgZGUgcGl4ZWwgbWF4aW11bSBuZSBzb250IHBhcyB0ZXN0w6llcy5cIixcblx0XCJAQFpvbmFsLVJlbWFwX01pbmltdW0tVmFsdWUtRmllbGQtTmFtZV90YWcwQEBcIjogXCJOb20gZHUgY2hhbXAgY29udGVuYW50IGxhIHZhbGV1ciBtaW5pbWFsZSBjaS1kZXNzdXMsIGRhbnMgbGFxdWVsbGUgdW4gcGl4ZWwgZW4gZW50csOpZSBlc3QgY2xhc3PDqS5cIixcblx0XCJAQFpvbmFsLVJlbWFwX01pbmltdW0tVmFsdWUtRmllbGQtTmFtZV90YWcxQEBcIjogXCJTaSBhdWN1bmUgdmFsZXVyIG4nZXN0IHNww6ljaWZpw6llIG91IHNpIGxhIHZhbGV1ciBkZSBjaGFtcCBlc3QgTnVsbCwgbGVzIHZhbGV1cnMgZGUgcGl4ZWwgbWluaW11bSBuZSBzb250IHBhcyB0ZXN0w6llcy5cIixcblx0XCJAQFpvbmFsLVJlbWFwX091dHB1dC1WYWx1ZS1GaWVsZC1OYW1lX3RhZzBAQFwiOiBcIk5vbSBkdSBjaGFtcCBjb250ZW5hbnQgbGEgdmFsZXVyIGNpYmxlIGRhbnMgbGFxdWVsbGUgdW4gcGl4ZWwgZW4gZW50csOpZSBlc3QgY2xhc3PDqS5cIixcblx0XCJAQFpvbmFsLVJlbWFwX091dHB1dC1WYWx1ZS1GaWVsZC1OYW1lX3RhZzFAQFwiOiBcIlNpIGF1Y3VuZSB2YWxldXIgbuKAmWVzdCBzcMOpY2lmacOpZSBvdSBzaSBsYSB2YWxldXIgZGUgY2hhbXAgZXN0IE51bGwsIGxlcyB2YWxldXJzIGRlIHBpeGVscyByZWNsYXNzw6llcyBzb250IGTDqWZpbmllcyBzdXIgPHN0cm9uZz5WYWxldXIgZW4gc29ydGllIHBhciBkw6lmYXV0PC9zdHJvbmc+LlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfVmFsdWUtUmFzdGVyX3RhZzBAQFwiOiBcIkVudHLDqWUgZGUgcmFzdGVyIG1vbm9jYW5hbCByZXF1aXNlIGNvbnRlbmFudCBkZXMgdmFsZXVycyBkZSBwaXhlbHMgw6AgY2xhc3Nlci5cIixcblx0XCJAQFpvbmFsLVJlbWFwX1doZXJlLUNsYXVzZV90YWcwQEBcIjogXCJSZXF1w6p0ZSBmYWN1bHRhdGl2ZSBhcHBsaXF1w6llIMOgIGxhIDxzdHJvbmc+VGFibGUgZGVzIGF0dHJpYnV0cyB6b25hdXg8L3N0cm9uZz4uXCIsXG5cdFwiQEBab25hbC1SZW1hcF9XaGVyZS1DbGF1c2VfdGFnM0BAXCI6IFwiU2kgdm91cyB1dGlsaXNpZXogbGEgdGFibGUgY2ktZGVzc3VzIGNvbW1lIGV4ZW1wbGUsIGxhIHJlcXXDqnRlIHNlcmFpdCAke1ZhcmlhYmxlMSA9ICdiYXJlIGVhcnRoJyBBTkQgVmFyaWFibGUyID0gJ0NhbGlmb3JuaWEnfS5cIixcblx0XCJAQFpvbmFsLVJlbWFwX1pvbmFsLUF0dHJpYnV0ZXMtVGFibGVfdGFnMEBAXCI6IFwiVW5lIHRhYmxlIGVuIGVudHLDqWUgcmVxdWlzZSBjb250ZW5hbnQgYXUgbW9pbnMgdHJvaXMgY2hhbXBzLiBFbGxlIGRvaXQgY29tcG9ydGVyIHVuZSB2YWxldXIgZGUgc2V1aWwgbWluaW1hbGUsIHVuZSB2YWxldXIgZGUgc2V1aWwgbWF4aW1hbGUgZXQgdW5lIHZhbGV1ciBjaWJsZS4gTGEgdmFsZXVyIGNpYmxlIGVzdCBsZSBjaGFtcCBxdWkgY29udGllbmRyYSBsYSB2YWxldXIgY2xhc3PDqWUuXCIsXG5cdFwiQEBab25hbC1SZW1hcF9ab25hbC1BdHRyaWJ1dGVzLVRhYmxlX3RhZzFAQFwiOiBcIkxlIGZvcm1hdCBkdSBmaWNoaWVyIHBldXQgw6p0cmUgdW5lIGNsYXNzZSBk4oCZZW50aXTDqXMsIHVuIHNlcnZpY2UgZOKAmWVudGl0w6lzIG91IG7igJlpbXBvcnRlIHF1ZWwgdHlwZSBkZSB0YWJsZSBwcmlzIGVuIGNoYXJnZSBwYXIgQXJjR0lTLlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfWm9uZS1GaWVsZF90YWcwQEBcIjogXCJOb20gZHUgY2hhbXAgZGFucyBsYSA8c3Ryb25nPlRhYmxlIGRlcyBhdHRyaWJ1dHMgem9uYXV4PC9zdHJvbmc+IHF1aSBjb250aWVudCBsZXMgdmFsZXVycyBk4oCZSUQgZGUgem9uZS5cIixcblx0XCJAQFpvbmFsLVJlbWFwX1pvbmUtRmllbGRfdGFnM0BAXCI6IFwiTGVzIHZhbGV1cnMgZCdJRCBkZSB6b25lIHNvbnQgZGlyZWN0ZW1lbnQgbGnDqWVzIGF1eCBJRCBkZSB6b25lIGRhbnMgdm90cmUgcmFzdGVyIHpvbmFsLiBMZSBjbGFzc2VtZW50IGLDqW7DqWZpY2llIGFpbnNpIGTigJl1biBuaXZlYXUgZGUgZmlsdHJhZ2Ugc3VwcGzDqW1lbnRhaXJlLiBTaSBhdWN1biBJRCBkZSB6b25lIG4nZXN0IGFzc29jacOpIMOgIHVuIGVucmVnaXN0cmVtZW50IGVuIHBhcnRpY3VsaWVyIGRhbnMgbGEgdGFibGUsIGlsIG5lIGZlcmEgcGFzIHBhcnRpZSBkdSBjbGFzc2VtZW50LlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfWm9uZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIG1vbm9jYW5hbCBvw7kgY2hhcXVlIHBpeGVsIGTDqWZpbml0IGxlcyB6b25lcyBhc3NvY2nDqWVzIMOgIHVuIGVtcGxhY2VtZW50IGVuIHBhcnRpY3VsaWVyLiBVbmUgem9uZSBlc3QgZMOpZmluaWUgY29tbWUgbCdlbnNlbWJsZSBkZXMgc3VyZmFjZXMgZW4gZW50csOpZSBheWFudCBsYSBtw6ptZSB2YWxldXIuIExlcyBzdXJmYWNlcyBuZSBzb250IHBhcyBuw6ljZXNzYWlyZW1lbnQgY29udGlndcOrcy5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfZGltZW5zaW9uZGVmaW5pdGlvbl90YWcwQEBcIjogXCJTcMOpY2lmaWUgbGEgbcOpdGhvZGUgdXRpbGlzw6llIHBvdXIgZm91cm5pciBsZXMgdmFsZXVycyBkZSBkaW1lbnNpb24gZGUgcHLDqXZpc2lvbi5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfZGltZW5zaW9uZGVmaW5pdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPlBhciB2YWxldXI8L3N0cm9uZz4gOiBsYSBwcsOpdmlzaW9uIGVzdCBjYWxjdWzDqWUgcG91ciB1bmUgc2V1bGUgdmFsZXVyIGRlIGRpbWVuc2lvbi4gUGFyIGV4ZW1wbGUsIHZvdXMgc291aGFpdGV6IHByw6l2b2lyIGxlcyBwcsOpY2lwaXRhdGlvbnMgYW5udWVsbGVzIHBvdXIgbGVzIGFubsOpZXMgMjA1MCwgMjEwMCBldCAyMTUwLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzJAQFwiOiBcIjxzdHJvbmc+UGFyIGludGVydmFsbGU8L3N0cm9uZz4gOiBsYSBwcsOpdmlzaW9uIGVzdCBjYWxjdWzDqWUgcG91ciB1biBpbnRlcnZhbGxlIGRlIGxhIGRpbWVuc2lvbiBkw6lmaW5pIHBhciB1bmUgdmFsZXVyIGRlIGTDqWJ1dCBldCB1bmUgdmFsZXVyIGRlIGZpbi4gUGFyIGV4ZW1wbGUsIHZvdXMgc291aGFpdGV6IHByw6l2b2lyIGxlcyBwcsOpY2lwaXRhdGlvbnMgYW5udWVsbGVzIHBvdXIgbGVzIGFubsOpZXMgY29tcHJpc2VzIGVudHJlIDIwNTAgZXQgMjE1MC5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfZW5kX3RhZzBAQFwiOiBcIkRhdGUgZGUgZmluLCBoYXV0ZXVyIG91IHByb2ZvbmRldXIgZGUgbOKAmWludGVydmFsbGUgZGUgZGltZW5zaW9uIMOgIHV0aWxpc2VyIGRhbnMgbGEgcHLDqXZpc2lvbi5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfZW5kX3RhZzFAQFwiOiBcIkNlIHBhcmFtw6h0cmUgZXN0IG9ibGlnYXRvaXJlIHNpIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Ew6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb248L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UGFyIGludGVydmFsbGU8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZGUgdGVuZGFuY2UgbXVsdGltZW5zaW9ubmVsIGVuIGVudHLDqWUgZGUgbGEgZm9uY3Rpb24gPHN0cm9uZz5Hw6luw6lyZXIgdW4gcmFzdGVyIGRlIHRlbmRhbmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF9zdGFydF90YWcwQEBcIjogXCJEYXRlIGRlIGTDqWJ1dCwgaGF1dGV1ciBvdSBwcm9mb25kZXVyIGRlIGzigJlpbnRlcnZhbGxlIGRlIGRpbWVuc2lvbiDDoCB1dGlsaXNlciBkYW5zIGxhIHByw6l2aXNpb24uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3N0YXJ0X3RhZzFAQFwiOiBcIkNlIHBhcmFtw6h0cmUgZXN0IG9ibGlnYXRvaXJlIHNpIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Ew6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb248L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UGFyIGludGVydmFsbGU8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3VuaXRfdGFnMEBAXCI6IFwiVW5pdMOpIHV0aWxpc8OpZSBwb3VyIGzigJlpbnRlcnZhbGxlIGRlIHZhbGV1cnMuIENlIHBhcmFtw6h0cmUgc+KAmWFwcGxpcXVlIHVuaXF1ZW1lbnQgc2kgbGEgZGltZW5zaW9uIGRlIGzigJlhbmFseXNlIGVzdCB1bmUgZGltZW5zaW9uIHRlbXBvcmVsbGUuXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3VuaXRfdGFnMUBAXCI6IFwiPHN0cm9uZz5IZXVyZXM8L3N0cm9uZz4gOiBsYSBwcsOpdmlzaW9uIGVzdCBjYWxjdWzDqWUgcG91ciBjaGFxdWUgaGV1cmUgZGUgbGEgcGxhZ2UgdGVtcG9yZWxsZSBkw6lmaW5pZSBwYXIgbGVzIHBhcmFtw6h0cmVzIDxzdHJvbmc+RMOpYnV0PC9zdHJvbmc+LCA8c3Ryb25nPkZpbjwvc3Ryb25nPiBldCA8c3Ryb25nPkludGVydmFsbGUgZGUgdmFsZXVyPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF91bml0X3RhZzJAQFwiOiBcIjxzdHJvbmc+Sm91cnM8L3N0cm9uZz4gOiBsYSBwcsOpdmlzaW9uIGVzdCBjYWxjdWzDqWUgcG91ciBjaGFxdWUgam91ciBkZSBsYSBwbGFnZSB0ZW1wb3JlbGxlIGTDqWZpbmllIHBhciBsZXMgcGFyYW3DqHRyZXMgPHN0cm9uZz5Ew6lidXQ8L3N0cm9uZz4sIDxzdHJvbmc+RmluPC9zdHJvbmc+IGV0IDxzdHJvbmc+SW50ZXJ2YWxsZSBkZSB2YWxldXI8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3VuaXRfdGFnM0BAXCI6IFwiPHN0cm9uZz5TZW1haW5lczwvc3Ryb25nPiA6IGxhIHByw6l2aXNpb24gZXN0IGNhbGN1bMOpZSBwb3VyIGNoYXF1ZSBzZW1haW5lIGRlIGxhIHBsYWdlIHRlbXBvcmVsbGUgZMOpZmluaWUgcGFyIGxlcyBwYXJhbcOodHJlcyA8c3Ryb25nPkTDqWJ1dDwvc3Ryb25nPiwgPHN0cm9uZz5GaW48L3N0cm9uZz4gZXQgPHN0cm9uZz5JbnRlcnZhbGxlIGRlIHZhbGV1cjwvc3Ryb25nPi5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfdW5pdF90YWc0QEBcIjogXCI8c3Ryb25nPk1vaXM8L3N0cm9uZz4gOiBsYSBwcsOpdmlzaW9uIGVzdCBjYWxjdWzDqWUgcG91ciBjaGFxdWUgbW9pcyBkZSBsYSBwbGFnZSB0ZW1wb3JlbGxlIGTDqWZpbmllIHBhciBsZXMgcGFyYW3DqHRyZXMgPHN0cm9uZz5Ew6lidXQ8L3N0cm9uZz4sIDxzdHJvbmc+RmluPC9zdHJvbmc+IGV0IDxzdHJvbmc+SW50ZXJ2YWxsZSBkZSB2YWxldXI8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3VuaXRfdGFnNUBAXCI6IFwiPHN0cm9uZz5Bbm7DqWVzPC9zdHJvbmc+IDogbGEgcHLDqXZpc2lvbiBlc3QgY2FsY3Vsw6llIHBvdXIgY2hhcXVlIGFubsOpZSBkZSBsYSBwbGFnZSB0ZW1wb3JlbGxlIGTDqWZpbmllIHBhciBsZXMgcGFyYW3DqHRyZXMgPHN0cm9uZz5Ew6lidXQ8L3N0cm9uZz4sIDxzdHJvbmc+RmluPC9zdHJvbmc+IGV0IDxzdHJvbmc+SW50ZXJ2YWxsZSBkZSB2YWxldXI8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3ZhbHVlaW50ZXJ2YWxfdGFnMEBAXCI6IFwiTm9tYnJlIGTigJnDqXRhcGVzIGVudHJlIGRldXggdmFsZXVycyBkZSBkaW1lbnNpb24gw6AgaW5jbHVyZSBkYW5zIGxhIHByw6l2aXNpb24uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMS5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfdmFsdWVpbnRlcnZhbF90YWcxQEBcIjogXCJDZSBwYXJhbcOodHJlIGVzdCBvYmxpZ2F0b2lyZSBzaSBsZSBwYXJhbcOodHJlIDxzdHJvbmc+RMOpZmluaXRpb24gZGUgbGEgZGltZW5zaW9uPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPlBhciBpbnRlcnZhbGxlPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF92YWx1ZXNfdGFnMEBAXCI6IFwiVmFsZXVyKHMpIGRlIGRpbWVuc2lvbiDDoCB1dGlsaXNlciBkYW5zIGxhIHByw6l2aXNpb24uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3ZhbHVlc190YWcxQEBcIjogXCJMZSBmb3JtYXQgZGVzIHZhbGV1cnMgdGVtcG9yZWxsZXMsIGRlIHByb2ZvbmRldXIgZXQgZGUgaGF1dGV1ciBkb2l0IGNvcnJlc3BvbmRyZSBhdSBmb3JtYXQgZGVzIHZhbGV1cnMgZGUgZGltZW5zaW9uIHV0aWxpc8OpZXMgcG91ciBnw6luw6lyZXIgbGUgcmFzdGVyIGRlIHRlbmRhbmNlLiBTaSBsZSByYXN0ZXIgZGUgdGVuZGFuY2UgYSDDqXTDqSBnw6luw6lyw6kgcG91ciBsYSBkaW1lbnNpb24gU3RkVGltZSwgbGUgZm9ybWF0IGRvaXQgw6p0cmUgQUFBQS1NTS1KSlRISDpNTTpTUyAocGFyIGV4ZW1wbGUsIDIwNTAtMDEtMDFUMDA6MDA6MDApLiBMZXMgdmFsZXVycyBtdWx0aXBsZXMgc29udCBzw6lwYXLDqWVzIHBhciBkZXMgcG9pbnRzLXZpcmd1bGVzLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9hZ2dyZWdhdGlvbmZ1bmN0aW9uX3RhZzBAQFwiOiBcIlNww6ljaWZpZXogbGUgbW9kw6hsZSBkZSBmb25jdGlvbiByYXN0ZXIgdXRpbGlzw6kgcG91ciBhZ3LDqWdlciBwbHVzaWV1cnMgdHJhbmNoZXMgZW4gdW4gbm9tYnJlIGRlIHRyYW5jaGVzIGluZsOpcmlldXIgb3UgZW4gdW5lIHNldWxlIHRyYW5jaGUuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2RpbWVuc2lvbl90YWcwQEBcIjogXCJEaW1lbnNpb24gZGUgbOKAmWFncsOpZ2F0aW9uLiBJbCBz4oCZYWdpdCBkZSBsYSBkaW1lbnNpb24gbGUgbG9uZyBkZSBsYXF1ZWxsZSBsZXMgdmFyaWFibGVzIHNvbnQgYWdyw6lnw6llcy5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25faXRlbWZ1bmN0aW9uX3RhZzBAQFwiOiBcIlNww6ljaWZpZXogbGUgbW9kw6hsZSBkZSBmb25jdGlvbiByYXN0ZXIgdXRpbGlzw6kgcG91ciB0cmFpdGVyIGNoYXF1ZSB0cmFuY2hlIG91IMOpbMOpbWVudCBkZSBs4oCZZW5zZW1ibGUgZGUgcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnMEBAXCI6IFwiU3DDqWNpZmllIGxlIG1vdC1jbMOpIGRlIGzigJlpbnRlcnZhbGxlIMOgIHV0aWxpc2VyIGxvcnMgZGUgbOKAmWFncsOpZ2F0aW9uIGxlIGxvbmcgZGUgbGEgZGltZW5zaW9uLiBDZSBwYXJhbcOodHJlIGVzdCBvYmxpZ2F0b2lyZSBzaSBsZSA8c3Ryb25nPlR5cGU8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+TW90LWNsw6kgZGUgbOKAmWludGVydmFsbGU8L3N0cm9uZz4uIERhbnMgY2UgY2FzLCBs4oCZYWdyw6lnYXRpb24gZG9pdCBzZSBmYWlyZSBkYW5zIGxlIHRlbXBzLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnMUBAXCI6IFwiPHN0cm9uZz5QYXIgaGV1cmU8L3N0cm9uZz4gOiBsZXMgdmFsZXVycyBkZXMgZG9ubsOpZXMgc29udCBhZ3LDqWfDqWVzIHNlbG9uIGRlcyBpbnRlcnZhbGxlcyBob3JhaXJlcyBldCBsZSByw6lzdWx0YXQgY29tcHJlbmQgY2hhcXVlIGhldXJlIGRlIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnMkBAXCI6IFwiPHN0cm9uZz5QYXIgam91cjwvc3Ryb25nPiA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgc2Vsb24gZGVzIGludGVydmFsbGVzIHF1b3RpZGllbnMgZXQgbGUgcsOpc3VsdGF0IGNvbXByZW5kIGNoYXF1ZSBqb3VyIGRlIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnM0BAXCI6IFwiPHN0cm9uZz5QYXIgc2VtYWluZTwvc3Ryb25nPiA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgc2Vsb24gZGVzIGludGVydmFsbGVzIGhlYmRvbWFkYWlyZXMgZXQgbGUgcsOpc3VsdGF0IGNvbXByZW5kIGNoYXF1ZSBzZW1haW5lIGRlIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnNEBAXCI6IFwiPHN0cm9uZz5QYXIgZGl4IGpvdXJzPC9zdHJvbmc+IDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBlbiAzIHDDqXJpb2RlcyBkZSAxMCBqb3VycyBjaGFjdW5lLiBMYSBkZXJuacOocmUgcMOpcmlvZGUgcGV1dCBjb250ZW5pciBwbHVzIG91IG1vaW5zIGRlIDEwIGpvdXJzLiBMYSBzb3J0aWUgY29tcHJlbmQgMyB0cmFuY2hlcyBwb3VyIGNoYXF1ZSBtb2lzLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnNUBAXCI6IFwiPHN0cm9uZz5QYXIgY2lucSBqb3Vyczwvc3Ryb25nPiA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgZW4gNiBww6lyaW9kZXMgZGUgNSBqb3VycyBjaGFjdW5lLiBMYSBkZXJuacOocmUgcMOpcmlvZGUgcGV1dCBjb250ZW5pciBwbHVzIG91IG1vaW5zIGRlIDUgam91cnMuIExhIHNvcnRpZSBjb21wcmVuZCA2IHRyYW5jaGVzIHBvdXIgY2hhcXVlIG1vaXMuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWc2QEBcIjogXCI8c3Ryb25nPlBhciBtb2lzPC9zdHJvbmc+IDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBzZWxvbiBkZXMgaW50ZXJ2YWxsZXMgbWVuc3VlbHMgZXQgbGUgcsOpc3VsdGF0IGNvbXByZW5kIGNoYXF1ZSBtb2lzIGRlIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnN0BAXCI6IFwiPHN0cm9uZz5QYXIgdHJpbWVzdHJlPC9zdHJvbmc+IDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBzZWxvbiBkZXMgaW50ZXJ2YWxsZXMgdHJpbWVzdHJpZWxzIGV0IGxlIHLDqXN1bHRhdCBjb21wcmVuZCBjaGFxdWUgdHJpbWVzdHJlIGRlIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnOEBAXCI6IFwiPHN0cm9uZz5QYXIgYW48L3N0cm9uZz4gOiBsZXMgdmFsZXVycyBkZXMgZG9ubsOpZXMgc29udCBhZ3LDqWfDqWVzIHNlbG9uIGRlcyBpbnRlcnZhbGxlcyBhbm51ZWxzIGV0IGxlIHLDqXN1bHRhdCBjb21wcmVuZCBjaGFxdWUgYW5uw6llIGRlIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnOUBAXCI6IFwiPHN0cm9uZz5Sw6ljdXJyZW5jZSBxdW90aWRpZW5uZTwvc3Ryb25nPiA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgc2Vsb24gZGVzIGludGVydmFsbGVzIHF1b3RpZGllbnMgZXQgbGUgcsOpc3VsdGF0IGluY2x1dCB1bmUgdmFsZXVyIGFncsOpZ8OpZSBwYXIgam91ciBkdSBjYWxlbmRyaWVyIGp1bGllbi4gTGUgcsOpc3VsdGF0IGNvbXByZW5kIDM2NiB0cmFuY2hlcyBkZSB0ZW1wcyBxdW90aWRpZW5uZXMgYXUgbWF4aW11bS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fa2V5d29yZGludGVydmFsX3RhZzEwQEBcIjogXCI8c3Ryb25nPlLDqWN1cnJlbmNlIGhlYmRvbWFkYWlyZTwvc3Ryb25nPiA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgc2Vsb24gZGVzIGludGVydmFsbGVzIGhlYmRvbWFkYWlyZXMgZXQgbGUgcsOpc3VsdGF0IGluY2x1dCB1bmUgdmFsZXVyIGFncsOpZ8OpZSBwYXIgc2VtYWluZS4gTGUgcsOpc3VsdGF0IGNvbXByZW5kIDUzIHRyYW5jaGVzIGRlIHRlbXBzIGhlYmRvbWFkYWlyZXMgYXUgbWF4aW11bS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fa2V5d29yZGludGVydmFsX3RhZzExQEBcIjogXCI8c3Ryb25nPlLDqWN1cnJlbmNlIG1lbnN1ZWxsZTwvc3Ryb25nPiA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgc2Vsb24gZGVzIGludGVydmFsbGVzIG1lbnN1ZWxzIGV0IGxlIHLDqXN1bHRhdCBpbmNsdXQgdW5lIHZhbGV1ciBhZ3LDqWfDqWUgcGFyIG1vaXMuIExlIHLDqXN1bHRhdCBjb21wcmVuZCAxMiB0cmFuY2hlcyBkZSB0ZW1wcyBtZW5zdWVsbGVzIGF1IG1heGltdW0uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWcxMkBAXCI6IFwiPHN0cm9uZz5Sw6ljdXJyZW5jZSB0cmltZXN0cmllbGxlPC9zdHJvbmc+IDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBzZWxvbiBkZXMgaW50ZXJ2YWxsZXMgdHJpbWVzdHJpZWxzIGV0IGxlIHLDqXN1bHRhdCBpbmNsdXQgdW5lIHZhbGV1ciBhZ3LDqWfDqWUgcGFyIHRyaW1lc3RyZS4gTGUgcsOpc3VsdGF0IGNvbXByZW5kIDQgdHJhbmNoZXMgZGUgdGVtcHMgdHJpbWVzdHJpZWxsZXMgYXUgbWF4aW11bS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fbWF4aW11bXZhbHVlX3RhZzBAQFwiOiBcIlZhbGV1ciBtYXhpbXVtIGTigJl1bmUgcGxhZ2UuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX21heGltdW12YWx1ZV90YWcxQEBcIjogXCJDZSBwYXJhbcOodHJlIGVzdCBvYmxpZ2F0b2lyZSBzaSBsZSBwYXJhbcOodHJlIDxzdHJvbmc+VHlwZTwvc3Ryb25nPiBlc3QgZMOpZmluaSBzdXIgPHN0cm9uZz5QbGFnZXMgZOKAmWludGVydmFsbGU8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX21pbmltdW12YWx1ZV90YWcwQEBcIjogXCJWYWxldXIgbWluaW11bSBk4oCZdW5lIHBsYWdlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9taW5pbXVtdmFsdWVfdGFnMUBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBlc3Qgb2JsaWdhdG9pcmUgc2kgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPlR5cGU8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UGxhZ2VzIGTigJlpbnRlcnZhbGxlPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9wcm9jZXNzaW5nZnVuY3Rpb25fdGFnMEBAXCI6IFwiU3DDqWNpZmlleiBsZSBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlciB1dGlsaXPDqSBwb3VyIGFmZmljaGVyIGxhIGNvdWNoZSByYXN0ZXIgdHJhaXTDqWUuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3Jhc3RlcmNvbGxlY3Rpb25fdGFnMEBAXCI6IFwiUmFzdGVyIG11bHRpZGltZW5zaW9ubmVsLCBjb3VjaGUgbW9zYcOvcXVlIG91IGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUgZW4gZW50csOpZS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fdHlwZV90YWcwQEBcIjogXCJTcMOpY2lmaWUgbOKAmWludGVydmFsbGUgZGltZW5zaW9ubmVsIHNlbG9uIGxlcXVlbCBsZXMgZG9ubsOpZXMgc29udCBhZ3LDqWfDqWVzLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl90eXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+VG91dDwvc3Ryb25nPiA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgc3VyIHRvdXRlcyBsZXMgdHJhbmNoZXMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3R5cGVfdGFnMkBAXCI6IFwiPHN0cm9uZz5Nb3QtY2zDqSBkZSBs4oCZaW50ZXJ2YWxsZTwvc3Ryb25nPiA6IGxlcyBkb25uw6llcyBkZXMgdmFyaWFibGVzIHNvbnQgYWdyw6lnw6llcyDDoCBs4oCZYWlkZSBk4oCZdW4gaW50ZXJ2YWxsZSBjb3VyYW50IGNvbm51LlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl90eXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+UGxhZ2VzIGTigJlpbnRlcnZhbGxlPC9zdHJvbmc+IDogbGVzIGRvbm7DqWVzIGRlcyB2YXJpYWJsZXMgc29udCBhZ3LDqWfDqWVzIGVudHJlIGxlcyBwYWlyZXMgZGUgdmFsZXVycyBvdSBkZSBkYXRlcyBzcMOpY2lmacOpZXMuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3R5cGVfdGFnNEBAXCI6IFwiPHN0cm9uZz5WYWxldXJzIGTigJlpbnRlcnZhbGxlPC9zdHJvbmc+IDogbGVzIGRvbm7DqWVzIGRlcyB2YXJpYWJsZXMgc29udCBhZ3LDqWfDqWVzIMOgIGzigJlhaWRlIGTigJl1biBpbnRlcnZhbGxlIGV0IGTigJl1bmUgdW5pdMOpIGTDqWZpbmlzIHBhciBs4oCZdXRpbGlzYXRldXIuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3VuaXRfdGFnMEBAXCI6IFwiVW5pdMOpIHV0aWxpc8OpZSBwb3VyIGxhIHZhbGV1ciBkZSBs4oCZaW50ZXJ2YWxsZS4gQ2UgcGFyYW3DqHRyZSBlc3Qgb2JsaWdhdG9pcmUgc2kgbGEgPHN0cm9uZz5EaW1lbnNpb248L3N0cm9uZz4gZXN0IHVuIGNoYW1wIHRlbXBvcmVsIGV0IHF1ZSBsZSBwYXJhbcOodHJlIDxzdHJvbmc+VHlwZTwvc3Ryb25nPiBlc3QgZMOpZmluaSBzdXIgPHN0cm9uZz5WYWxldXIgZGUgbOKAmWludGVydmFsbGU8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3VuaXRfdGFnMUBAXCI6IFwiU2kgdm91cyBwcm9jw6lkZXogw6AgdW5lIGFncsOpZ2F0aW9uIHN1ciB1bmUgZGltZW5zaW9uIGF1dHJlIHF1ZSB0ZW1wb3JlbGxlLCBjZXR0ZSBvcHRpb24gbuKAmWVzdCBwYXMgZGlzcG9uaWJsZSBldCBs4oCZdW5pdMOpIGRlIGxhIHZhbGV1ciBkZSBs4oCZaW50ZXJ2YWxsZSBjb3JyZXNwb25kIMOgIGzigJl1bml0w6kgZGUgdmFyaWFibGUgZGVzIGRvbm7DqWVzIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbGxlcyBlbiBlbnRyw6llLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzJAQFwiOiBcIjxzdHJvbmc+SGV1cmVzPC9zdHJvbmc+IDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBwYXIgdHJhbmNoZXMgaG9yYWlyZXMgc3VpdmFudCBs4oCZaW50ZXJ2YWxsZSBmb3VybmkuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3VuaXRfdGFnM0BAXCI6IFwiPHN0cm9uZz5Kb3Vyczwvc3Ryb25nPiA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgcGFyIHRyYW5jaGVzIHF1b3RpZGllbm5lcyBzdWl2YW50IGzigJlpbnRlcnZhbGxlIGZvdXJuaS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fdW5pdF90YWc0QEBcIjogXCI8c3Ryb25nPlNlbWFpbmVzPC9zdHJvbmc+IDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBwYXIgdHJhbmNoZXMgaGViZG9tYWRhaXJlcyBzdWl2YW50IGzigJlpbnRlcnZhbGxlIGZvdXJuaS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fdW5pdF90YWc1QEBcIjogXCI8c3Ryb25nPk1vaXM8L3N0cm9uZz4gOiBsZXMgdmFsZXVycyBkZXMgZG9ubsOpZXMgc29udCBhZ3LDqWfDqWVzIHBhciB0cmFuY2hlcyBtZW5zdWVsbGVzIHN1aXZhbnQgbOKAmWludGVydmFsbGUgZm91cm5pLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzZAQFwiOiBcIjxzdHJvbmc+QW5uw6llczwvc3Ryb25nPiA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgcGFyIHRyYW5jaGVzIGFubnVlbGxlcyBzdWl2YW50IGzigJlpbnRlcnZhbGxlIGZvdXJuaS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fdmFsdWVpbnRlcnZhbF90YWcwQEBcIjogXCJUYWlsbGUgZGUgbOKAmWludGVydmFsbGUgw6AgYXBwbGlxdWVyIMOgIGzigJlhZ3LDqWdhdGlvbi4gQ2UgcGFyYW3DqHRyZSBlc3Qgb2JsaWdhdG9pcmUgc2kgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPlR5cGU8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+VmFsZXVyIGRlIGzigJlpbnRlcnZhbGxlPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl92YWx1ZWludGVydmFsX3RhZzFAQFwiOiBcIlBhciBleGVtcGxlLCBwb3VyIGFncsOpZ2VyIDMwIGFubsOpZXMgZGUgZG9ubsOpZXMgZGUgdGVtcMOpcmF0dXJlIG1lbnN1ZWxsZXMgcGFyIGluY3LDqW1lbnRzIGRlIDUgYW5zLCBzYWlzaXNzZXogNSBjb21tZSA8c3Ryb25nPlZhbGV1ciBkZSBs4oCZaW50ZXJ2YWxsZTwvc3Ryb25nPiBldCBkw6lmaW5pc3NleiA8c3Ryb25nPlVuaXTDqTwvc3Ryb25nPiBzdXIgPHN0cm9uZz5Bbm7DqWVzPC9zdHJvbmc+LlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX25vbi1uZWdhdGl2ZV90YWcwQEBcIjogXCJTcMOpY2lmaWUgbGVzIG9wdGlvbnMgcGVybWV0dGFudCBkZSBkw6lmaW5pciBsZXMgdmFsZXVycyBkZSBwaXhlbHMgZW4gc29ydGllLlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX25vbi1uZWdhdGl2ZV90YWcxQEBcIjogXCJBY3RpdsOpIDogaWwgbuKAmXkgYXVyYSBwYXMgZGUgdmFsZXVycyBuw6lnYXRpdmVzIGVuIHNvcnRpZS5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19ub24tbmVnYXRpdmVfdGFnMkBAXCI6IFwiRMOpc2FjdGl2w6kgOiBsZXMgZnJhY3Rpb25zIGTigJlvY2N1cGF0aW9uIGR1IHNvbCBwZXV2ZW50IGNvbXBvcnRlciBkZXMgdmFsZXVycyBuw6lnYXRpdmVzLlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3Jhc3Rlcl90YWcwQEBcIjogXCJSYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19zcGVjdHJhbHByb2ZpbGVfdGFnMEBAXCI6IFwiRmljaGllciBkZSBwcm9maWwgc3BlY3RyYWwgZW4gZW50csOpZS5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19zcGVjdHJhbHByb2ZpbGV0eXBlX3RhZzBAQFwiOiBcIkluZm9ybWF0aW9ucyBzcGVjdHJhbGVzIHBvdXIgbGVzIGRpZmbDqXJlbnRlcyBjbGFzc2VzIGTigJlvY2N1cGF0aW9uIGR1IHNvbC5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19zcGVjdHJhbHByb2ZpbGV0eXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+UHJvZmlsIHNwZWN0cmFsPC9zdHJvbmc+IDogdW4gZmljaGllciBkZSBkw6lmaW5pdGlvbiBkZSBjbGFzc2lmaWNhdGV1ciAoJHsuZWNkfSksIGfDqW7DqXLDqSB2aWEgbOKAmW91dGlsIDxzdHJvbmc+PHN0cm9uZz5QcsOpcGFyZXIgbGUgY2xhc3NpZmljYXRldXIgZGUgdnJhaXNlbWJsYW5jZSBtYXhpbWFsZTwvc3Ryb25nPjwvc3Ryb25nPiwgb3UgdW4gZmljaGllciBKYXZhU2NyaXB0IE9iamVjdCBOb3RhdGlvbiAoJHsuanNvbn0pIHF1aSBjb250aWVudCBsZXMgcHJvZmlscyBzcGVjdHJhdXggZGUgY2xhc3NlLlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3NwZWN0cmFscHJvZmlsZXR5cGVfdGFnMkBAXCI6IFwiPHN0cm9uZz5FbnRpdMOpcyBk4oCZZW50cmHDrm5lbWVudDwvc3Ryb25nPiA6IGRlcyBlbnRpdMOpcyBzdXJmYWNpcXVlcyBvdSB1bmUgY2xhc3NlIGTigJllbnRpdMOpcyBk4oCZw6ljaGFudGlsbG9ucyBk4oCZZW50cmHDrm5lbWVudCwgZ8OpbsOpcsOpZXMgw6AgcGFydGlyIGR1IDxzdHJvbmc+R2VzdGlvbm5haXJlIGTigJnDqWNoYW50aWxsb25zIGTigJllbnRyYcOubmVtZW50PC9zdHJvbmc+LlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3N1bXRvb25lX3RhZzBAQFwiOiBcIlNww6ljaWZpZSBsZXMgb3B0aW9ucyBwZXJtZXR0YW50IGRlIGTDqWZpbmlyIGxlcyB2YWxldXJzIGRlIHBpeGVscyBlbiBzb3J0aWUuXCIsXG5cdFwiQEBMaW5lYXItU3BlY3RyYWwtVW5taXhpbmdfc3VtdG9vbmVfdGFnMUBAXCI6IFwiQWN0aXbDqSA6IGxlcyB2YWxldXJzIGRlIGNsYXNzZSBwb3VyIGNoYXF1ZSBwaXhlbCBzb250IGZvdXJuaWVzIGF1IGZvcm1hdCBkw6ljaW1hbCwgbGEgc29tbWUgZGUgdG91dGVzIGxlcyBjbGFzc2VzIMOpdGFudCDDqWdhbGUgw6AgMS4gRXhlbXBsZSA6IENsYXNzZTEgPSAwLDE2IDsgQ2xhc3NlMiA9IDAsMjQgOyBDbGFzc2UzID0gMCw2MC5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19zdW10b29uZV90YWcyQEBcIjogXCJEw6lzYWN0aXbDqSA6IGxhIHNvbW1lIGRlIHRvdXRlcyBsZXMgY2xhc3NlcyBk4oCZdW4gcGl4ZWwgcGV1dCDDqnRyZSBzdXDDqXJpZXVyZSDDoCAxLlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3RyYWluaW5nZmVhdHVyZV90YWcwQEBcIjogXCJGaWNoaWVyIGTigJllbnRpdMOpcyBk4oCZZW50cmHDrm5lbWVudCBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQWdncmVnYXRlX2FnZ3JlZ2F0aW9udGVjaG5pcXVlX3RhZzBAQFwiOiBcIk3DqXRob2RlIGVtcGxvecOpZSBwb3VyIGzigJlhZ3LDqWdhdGlvbi4gTGVzIHZhbGV1cnMgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgaW5jbHVzZXMgZGFucyBsZXMgY2VsbHVsZXMgZW4gc29ydGllIGxlcyBwbHVzIGdyb3NzacOocmVzIHNvbnQgYWdyw6lnw6llcyBzZWxvbiBs4oCZdW5lIGRlcyBzdGF0aXN0aXF1ZXMgc3VpdmFudGVzIDpcIixcblx0XCJAQEFnZ3JlZ2F0ZV9hZ2dyZWdhdGlvbnRlY2huaXF1ZV90YWcxQEBcIjogXCI8c3Ryb25nPlNvbW1lPC9zdHJvbmc+IDogdG90YWwgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfYWdncmVnYXRpb250ZWNobmlxdWVfdGFnMkBAXCI6IFwiPHN0cm9uZz5NYXhpbXVtPC9zdHJvbmc+IDogdmFsZXVyIGxhIHBsdXMgw6lsZXbDqWUgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfYWdncmVnYXRpb250ZWNobmlxdWVfdGFnM0BAXCI6IFwiPHN0cm9uZz5Nb3llbm5lPC9zdHJvbmc+IDogdmFsZXVyIG1veWVubmUgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfYWdncmVnYXRpb250ZWNobmlxdWVfdGFnNEBAXCI6IFwiPHN0cm9uZz5Nw6lkaWFuZTwvc3Ryb25nPiA6IHZhbGV1ciBtw6lkaWFuZSBkZXMgY2VsbHVsZXMgZW4gZW50csOpZS5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9hZ2dyZWdhdGlvbnRlY2huaXF1ZV90YWc1QEBcIjogXCI8c3Ryb25nPk1pbmltdW08L3N0cm9uZz4gOiB2YWxldXIgbGEgcGx1cyBmYWlibGUgZGVzIGNlbGx1bGVzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfY2VsbGZhY3Rvcl90YWcwQEBcIjogXCJGYWN0ZXVyIGRlIG11bHRpcGxpY2F0aW9uIGRlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIGR1IHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQWdncmVnYXRlX2NlbGxmYWN0b3JfdGFnMUBAXCI6IFwiUGFyIGV4ZW1wbGUsIHVuZSB2YWxldXIgZGUgZmFjdGV1ciBkZSBjZWxsdWxlIGRlIHRyb2lzIGVudHJhw65uZSB1bmUgdGFpbGxlIGRlIGNlbGx1bGUgZW4gc29ydGllIHRyb2lzIGZvaXMgc3Vww6lyaWV1cmUgw6AgY2VsbGUgZHUgcmFzdGVyIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfZXhwYW5kZXh0ZW50aWZuZWVkZWRfdGFnMEBAXCI6IFwiRMOpZmluaXQgbGEgZ2VzdGlvbiBkZXMgbGltaXRlcyBkdSByYXN0ZXIgZW4gZW50csOpZSBzaSBzZXMgbGlnbmVzIG91IHNlcyBjb2xvbm5lcyBuZSBzb250IHBhcyBkZXMgbXVsdGlwbGVzIGR1IGZhY3RldXIgZGUgY2VsbHVsZS5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9leHBhbmRleHRlbnRpZm5lZWRlZF90YWcxQEBcIjogXCJBY3RpdsOpIDogw6l0ZW5kIGxlcyBsaW1pdGVzIGVuIGhhdXQgb3Ugw6AgZHJvaXRlIGR1IHJhc3RlciBlbiBlbnRyw6llIGFmaW4gcXVlIGxlIG5vbWJyZSB0b3RhbCBkZSBjZWxsdWxlcyBk4oCZdW5lIGxpZ25lIG91IGTigJl1bmUgY29sb25uZSBzb2l0IHVuIG11bHRpcGxlIGR1IGZhY3RldXIgZGUgY2VsbHVsZS4gQ2V0dGUgb3B0aW9uIHBlcm1ldCBhdSByYXN0ZXIgZW4gc29ydGllIGRlIGNvdXZyaXIgdW5lIMOpdGVuZHVlIHNwYXRpYWxlIHBsdXMgaW1wb3J0YW50ZSBxdWUgY2VsbGUgZHUgcmFzdGVyIGVuIGVudHLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfZXhwYW5kZXh0ZW50aWZuZWVkZWRfdGFnMkBAXCI6IFwiRMOpc2FjdGl2w6kgOiByw6lkdWl0IGxlIG5vbWJyZSBkZSBsaWduZXMgb3UgZGUgY29sb25uZXMgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBDZXR0ZSBvcHRpb24gdHJvbnF1ZSBsZXMgY2VsbHVsZXMgcmVzdGFudGVzIHN1ciBsZXMgbGltaXRlcyBlbiBoYXV0IG91IMOgIGRyb2l0ZSBkdSByYXN0ZXIgZW4gZW50csOpZSwgY2UgcXVpIGZhaXQgZHUgbm9tYnJlIGRlIGxpZ25lcyBvdSBkZSBjb2xvbm5lcyBkdSByYXN0ZXIgZW4gZW50csOpZSB1biBtdWx0aXBsZSBkdSBmYWN0ZXVyIGRlIGNlbGx1bGUuIENldHRlIG9wdGlvbiBwZXJtZXQgYXUgcmFzdGVyIGVuIHNvcnRpZSBkZSBjb3V2cmlyIHVuZSDDqXRlbmR1ZSBzcGF0aWFsZSBwbHVzIHLDqWR1aXRlIHF1ZSBjZWxsZSBkdSByYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9pZ25vcmVub2RhdGFpbmNhbGN1bGF0aW9uc190YWcwQEBcIjogXCJJbmRpcXVlIHNpIGxlcyB2YWxldXJzICR7Tm9EYXRhfSBzb250IGV4Y2x1ZXMgZHUgY2FsY3VsIGTigJlhZ3LDqWdhdGlvbi5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9pZ25vcmVub2RhdGFpbmNhbGN1bGF0aW9uc190YWcxQEBcIjogXCJBY3RpdsOpIDogcHLDqWNpc2UgcXVlIHNpIGRlcyB2YWxldXJzICR7Tm9EYXRhfSBleGlzdGVudCBwb3VyIGRlcyBjZWxsdWxlcyBpbmNsdXNlcyBkYW5zIGzigJnDqXRlbmR1ZSBzcGF0aWFsZSBk4oCZdW5lIHBsdXMgZ3JhbmRlIGNlbGx1bGUgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLCBsZXMgdmFsZXVycyAke05vRGF0YX0gc29udCBpZ25vcsOpZXMgbG9ycyBkZSBsYSBkw6l0ZXJtaW5hdGlvbiBkZSBsYSB2YWxldXIgZGVzIGVtcGxhY2VtZW50cyBkZXMgY2VsbHVsZXMgZW4gc29ydGllLiBTZXVsZXMgbGVzIGNlbGx1bGVzIGVuIGVudHLDqWUgc2UgdHJvdXZhbnQgZGFucyBs4oCZw6l0ZW5kdWUgZOKAmXVuZSBjZWxsdWxlIGVuIHNvcnRpZSBjb250ZW5hbnQgZGVzIHZhbGV1cnMgZGUgZG9ubsOpZXMgc29udCB1dGlsaXPDqWVzIHBvdXIgZMOpdGVybWluZXIgbGEgdmFsZXVyIGRlIGxhIGNlbGx1bGUgZW4gc29ydGllLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQWdncmVnYXRlX2lnbm9yZW5vZGF0YWluY2FsY3VsYXRpb25zX3RhZzJAQFwiOiBcIkTDqXNhY3RpdsOpIDogcHLDqWNpc2UgcXVlIHNpIHVuZSBjZWxsdWxlIGluY2x1c2UgZGFucyBs4oCZw6l0ZW5kdWUgc3BhdGlhbGUgZOKAmXVuZSBjZWxsdWxlIHBsdXMgZ3JhbmRlIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZSBhIHVuZSB2YWxldXIgJHtOb0RhdGF9LCBsYSB2YWxldXIgZGUgbOKAmWVtcGxhY2VtZW50IGRlIGNldHRlIGNlbGx1bGUgZW4gc29ydGllIGVzdCDDqWdhbGVtZW50ICR7Tm9EYXRhfS4gTOKAmXV0aWxpc2F0aW9uIGRlIGNldHRlIG9wdGlvbiBpbXBsaXF1ZSBxdWUsIGxvcnNxdWUgbGVzIGNlbGx1bGVzIGTigJl1bmUgYWdyw6lnYXRpb24gY29udGllbm5lbnQgbGEgdmFsZXVyICR7Tm9EYXRhfSwgaWwgbWFucXVlIGRlcyBpbmZvcm1hdGlvbnMgcG91ciBlZmZlY3R1ZXIgbGVzIGNhbGN1bHMgc3DDqWNpZmnDqXMgbsOpY2Vzc2FpcmVzIMOgIGxhIGTDqXRlcm1pbmF0aW9uIGTigJl1bmUgdmFsZXVyIGVuIHNvcnRpZS5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9yYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgw6AgYWdyw6lnZXIuXCIsXG5cdFwiQEBFeHBhbmRfbnVtYmVyb2ZjZWxsc190YWcwQEBcIjogXCJOb21icmUgZGUgY2VsbHVsZXMgw6AgdXRpbGlzZXIgcG91ciBkw6l2ZWxvcHBlciBsZXMgem9uZXMuXCIsXG5cdFwiQEBFeHBhbmRfbnVtYmVyb2ZjZWxsc190YWcxQEBcIjogXCJMYSB2YWxldXIgZG9pdCDDqnRyZSB1biBlbnRpZXIgZXQgcGV1dCDDqnRyZSDDqWdhbGUgb3Ugc3Vww6lyaWV1cmUgw6AgMS5cIixcblx0XCJAQEV4cGFuZF9yYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGVuIGVudHLDqWUgcG91ciBsZXF1ZWwgbGVzIHpvbmVzIGlkZW50aWZpw6llcyBzZXJvbnQgZMOpdmVsb3Bww6llcy5cIixcblx0XCJAQEV4cGFuZF9yYXN0ZXJfdGFnMUBAXCI6IFwiSWwgZG9pdCDDqnRyZSBkZSB0eXBlIGVudGllci5cIixcblx0XCJAQEV4cGFuZF96b25ldmFsdWVzX3RhZzBAQFwiOiBcIkxpc3RlIGRlcyB6b25lcyDDoCBkw6l2ZWxvcHBlci5cIixcblx0XCJAQEV4cGFuZF96b25ldmFsdWVzX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGRlIHpvbmUgZG9pdmVudCDDqnRyZSBkZXMgZW50aWVycyBldCBwZXV2ZW50IMOqdHJlIGRhbnMgbuKAmWltcG9ydGUgcXVlbCBvcmRyZS5cIixcblx0XCJAQEV4cGFuZF96b25ldmFsdWVzX3RhZzJAQFwiOiBcIlBvdXIgcHLDqWNpc2VyIHBsdXNpZXVycyB6b25lcywgdXRpbGlzZXogdW4gZXNwYWNlIHBvdXIgc8OpcGFyZXIgbGVzIHZhbGV1cnMgZGUgem9uZS5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX2RpbWVuc2lvbl90YWcwQEBcIjogXCJEaW1lbnNpb24gZGUgbGFxdWVsbGUgbGVzIHZhcmlhYmxlcyBkb2l2ZW50IMOqdHJlIGV4dHJhaXRlcy5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX2RpbWVuc2lvbmRlZmluaXRpb25fdGFnMEBAXCI6IFwiUHLDqWNpc2UgbGEgbcOpdGhvZGUgdXRpbGlzw6llIHBvdXIgZMOpY291cGVyIGxhIGRpbWVuc2lvbiBlbiB0cmFuY2hlcy5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX2RpbWVuc2lvbmRlZmluaXRpb25fdGFnMUBAXCI6IFwiPHN0cm9uZz5Ub3V0PC9zdHJvbmc+IDogbGEgcGxhZ2UgY29tcGzDqHRlIGRlIGNoYXF1ZSBkaW1lbnNpb24gZXN0IHV0aWxpc8OpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX2RpbWVuc2lvbmRlZmluaXRpb25fdGFnMkBAXCI6IFwiPHN0cm9uZz5QYXIgdmFsZXVyczwvc3Ryb25nPiA6IGxhIGRpbWVuc2lvbiBlc3QgZMOpY291cMOpZSBlbiB0cmFuY2hlcyBzZWxvbiB1bmUgdmFsZXVyIGRlIGRpbWVuc2lvbiBvdSB1bmUgbGlzdGUgZGUgdmFsZXVycy5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX2RpbWVuc2lvbmRlZmluaXRpb25fdGFnM0BAXCI6IFwiPHN0cm9uZz5QYXIgcGxhZ2VzPC9zdHJvbmc+IDogbGEgZGltZW5zaW9uIGVzdCBkw6ljb3Vww6llIGVuIHRyYW5jaGVzIHNlbG9uIHVuZSBwbGFnZSBvdSB1bmUgbGlzdGUgZGUgcGxhZ2VzLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9uZGVmaW5pdGlvbl90YWc0QEBcIjogXCI8c3Ryb25nPlBhciBpdMOpcmF0aW9uPC9zdHJvbmc+IDogbGEgZGltZW5zaW9uIGVzdCBkw6ljb3Vww6llIGVuIHRyYW5jaGVzIHNlbG9uIHVuZSB0YWlsbGUgZOKAmWludGVydmFsbGUgcHLDqWNpc8OpZS5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX2VuZG9mZmlyc3RpdGVyYXRpb25fdGFnMEBAXCI6IFwiRmluIGR1IHByZW1pZXIgaW50ZXJ2YWxsZS4gQ2V0IGludGVydmFsbGUgZXN0IGVtcGxvecOpIHBvdXIgbOKAmWl0w6lyYXRpb24gYXUgc2VpbiBkdSBqZXUgZGUgZG9ubsOpZXMuIENlIHBhcmFtw6h0cmUgZXN0IG9ibGlnYXRvaXJlIHNpIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Ew6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb248L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UGFyIGl0w6lyYXRpb248L3N0cm9uZz4uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9tYXhpbXVtdmFsdWVfdGFnMEBAXCI6IFwiVmFsZXVyIG1heGltYWxlIGRlIGxhIHBsYWdlLiBDZSBwYXJhbcOodHJlIGVzdCBvYmxpZ2F0b2lyZSBzaSBsZSBwYXJhbcOodHJlIDxzdHJvbmc+RMOpZmluaXRpb24gZGUgbGEgZGltZW5zaW9uPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPlBhciBwbGFnZXM8L3N0cm9uZz4uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9taW5pbXVtdmFsdWVfdGFnMEBAXCI6IFwiVmFsZXVyIG1pbmltYWxlIGRlIGxhIHBsYWdlLiBDZSBwYXJhbcOodHJlIGVzdCBvYmxpZ2F0b2lyZSBzaSBsZSBwYXJhbcOodHJlIDxzdHJvbmc+RMOpZmluaXRpb24gZGUgbGEgZGltZW5zaW9uPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPlBhciBwbGFnZXM8L3N0cm9uZz4uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9yYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIG11bHRpZGltZW5zaW9ubmVsIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9yYW5nZXNfdGFnMEBAXCI6IFwiPHA+UGxhZ2VzIGTigJlpbnRlcnZhbGxlIHNww6ljaWZpw6llcyBkYW5zIHVuZSB0YWJsZSwgdXRpbGlzw6llcyBwb3VyIGFncsOpZ2VyIGRlcyBncm91cGVzIGRlIHZhbGV1cnMuIExlcyB2YWxldXJzIG1pbmltYWxlcyBldCBtYXhpbWFsZXMgZMOpdGVybWluZW50IGxhIHBsYWdlIMOgIGluY2x1cmUuPC9wPjxwPkNlIHBhcmFtw6h0cmUgZXN0IHJlcXVpcyBsb3JzcXVlIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5UeXBlPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPlBsYWdlcyBk4oCZaW50ZXJ2YWxsZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9zdGFydG9mZmlyc3RpdGVyYXRpb25fdGFnMEBAXCI6IFwiRMOpYnV0IGR1IHByZW1pZXIgaW50ZXJ2YWxsZS4gQ2V0IGludGVydmFsbGUgZXN0IGVtcGxvecOpIHBvdXIgbOKAmWl0w6lyYXRpb24gYXUgc2VpbiBkdSBqZXUgZGUgZG9ubsOpZXMuIENlIHBhcmFtw6h0cmUgZXN0IG9ibGlnYXRvaXJlIHNpIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Ew6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb248L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UGFyIGl0w6lyYXRpb248L3N0cm9uZz4uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9zdGVwX3RhZzBAQFwiOiBcIkZyw6lxdWVuY2Ugw6AgbGFxdWVsbGUgbGVzIGRvbm7DqWVzIHNvbnQgZMOpY291cMOpZXMgZW4gdHJhbmNoZXMuIENlIHBhcmFtw6h0cmUgZXN0IG9ibGlnYXRvaXJlIHNpIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Ew6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb248L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UGFyIGl0w6lyYXRpb248L3N0cm9uZz4uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMy5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX3VuaXRfdGFnMEBAXCI6IFwiU3DDqWNpZmllIGzigJl1bml0w6kgZGUgbOKAmWl0w6lyYXRpb24uIENlIHBhcmFtw6h0cmUgZXN0IG9ibGlnYXRvaXJlIHNpIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Ew6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb248L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UGFyIGl0w6lyYXRpb248L3N0cm9uZz4gZXQgcXVlIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5EaW1lbnNpb248L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+U3RkVGltZTwvc3Ryb25nPi5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX3ZhbHVlX3RhZzBAQFwiOiBcIlZhbGV1ciBkZSBsYSBkaW1lbnNpb24gc3DDqWNpZmnDqWUuIENlIHBhcmFtw6h0cmUgZXN0IG9ibGlnYXRvaXJlIHNpIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Ew6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb248L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UGFyIHZhbGV1cnM8L3N0cm9uZz4uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl92YXJpYWJsZXNfdGFnMEBAXCI6IFwiVmFyaWFibGVzIGluY2x1c2VzIGRhbnMgbGEgY291Y2hlIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbGxlIGVuIHNvcnRpZS4gU2kgYXVjdW5lIHZhcmlhYmxlIG7igJllc3Qgc3DDqWNpZmnDqWUsIGxhIHByZW1pw6hyZSB2YXJpYWJsZSBlc3QgdXRpbGlzw6llLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9ubGVzc190YWcwQEBcIjogXCJTcMOpY2lmaWUgc2kgbGEgY291Y2hlIHBvc3PDqGRlIGRlcyB2YWxldXJzIGRlIGRpbWVuc2lvbi4gQ2V0dGUgb3B0aW9uIGVzdCBkaXNwb25pYmxlIHNldWxlbWVudCBzaSB1bmUgc2V1bGUgdHJhbmNoZSBlc3Qgc8OpbGVjdGlvbm7DqWUgcG91ciBsYSBjcsOpYXRpb24gZOKAmXVuZSBjb3VjaGUuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9kaW1lbnNpb25sZXNzX3RhZzFAQFwiOiBcIkFjdGl2w6kgOiBsYSBjb3VjaGUgbmUgY29udGllbnQgcGFzIGRlIHZhbGV1cnMgZGUgZGltZW5zaW9uLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9ubGVzc190YWcyQEBcIjogXCJEw6lzYWN0aXbDqSA6IGxhIGNvdWNoZSBjb250aWVudCBkZXMgdmFsZXVycyBkZSBkaW1lbnNpb24uIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLVJhc3Rlcl9pbnRlcnBvbGF0aW9uY2VsbHNpemVfdGFnMEBAXCI6IFwiVGFpbGxlIGRlIGNlbGx1bGUgZHUgcmFzdGVyIGludGVycG9sw6kuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgJHsxfS5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtUmFzdGVyX2ludGVycG9sYXRpb25tZXRob2RfdGFnMEBAXCI6IFwiTcOpdGhvZGUgZGUgcsOpw6ljaGFudGlsbG9ubmFnZSB1dGlsaXPDqWUgcG91ciBpbnRlcnBvbGVyIGxlcyBkb25uw6llcyBpcnLDqWd1bGnDqHJlcy5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtUmFzdGVyX2ludGVycG9sYXRpb25tZXRob2RfdGFnMUBAXCI6IFwiPHN0cm9uZz5Wb2lzaW4gbGUgcGx1cyBwcm9jaGU8L3N0cm9uZz4gOiBjYWxjdWxlIGxhIHZhbGV1ciBkdSBwaXhlbCBlbiBzb3J0aWUgZ3LDomNlIGF1IHBpeGVsIGVuIGVudHLDqWUgbGUgcGx1cyBwcm9jaGUuIFNpIGF1Y3VuIHBpeGVsIHNvdXJjZSBu4oCZZXhpc3RlLCBhdWN1biBub3V2ZWF1IHBpeGVsIG5lIHBldXQgw6p0cmUgY3LDqcOpIGRhbnMgbGEgc29ydGllLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1SYXN0ZXJfaW50ZXJwb2xhdGlvbm1ldGhvZF90YWcyQEBcIjogXCI8c3Ryb25nPlRJTiBsaW7DqWFpcmU8L3N0cm9uZz4gOiB1dGlsaXNlIHVuIHLDqXNlYXUgdHJpYW5ndWzDqSBpcnLDqWd1bGllciAoVElOKSDDoCBwYXJ0aXIgZHUgcG9pbnQgY2VudHJhbCBkZSBjaGFxdWUgcGl4ZWwgZHUgcmFzdGVyIGlycsOpZ3VsaWVyIHBvdXIgaW50ZXJwb2xlciB1bmUgc3VyZmFjZSBxdWkgc2VyYSBlbnN1aXRlIGNvbnZlcnRpZSBlbiByYXN0ZXIgcsOpZ3VsaWVyLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1SYXN0ZXJfaW50ZXJwb2xhdGlvbm1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPlZvaXNpbiBuYXR1cmVsPC9zdHJvbmc+IDogcmVjaGVyY2hlIGxlIHNvdXMtZW5zZW1ibGUgZOKAmcOpY2hhbnRpbGxvbnMgZW4gZW50csOpZSBsZSBwbHVzIHByb2NoZSBk4oCZdW4gcG9pbnQgZGUgcmVxdcOqdGUgZXQgbHVpIGFwcGxpcXVlIHVuZSBwb25kw6lyYXRpb24gc3VyIGxhIGJhc2UgZGUgc3VyZmFjZXMgcHJvcG9ydGlvbm5lbGxlcyBhZmluIGTigJlpbnRlcnBvbGVyIHVuZSB2YWxldXIuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLVJhc3Rlcl9pbnRlcnBvbGF0aW9ubWV0aG9kX3RhZzRAQFwiOiBcIjxzdHJvbmc+UG9uZMOpcmF0aW9uIHBhciBs4oCZaW52ZXJzZSBkZSBsYSBkaXN0YW5jZTwvc3Ryb25nPiA6IGTDqXRlcm1pbmUgbGVzIHZhbGV1cnMgZGVzIHBpeGVscyB2aWEgbGEgY29tYmluYWlzb24gcG9uZMOpcsOpZSBkZSBtYW5pw6hyZSBsaW7DqWFpcmUgZOKAmXVuIGVuc2VtYmxlIGRlIHBvaW50cyBk4oCZw6ljaGFudGlsbG9ubmFnZSBvdSBkZSBwaXhlbHMuIExhIHBvbmTDqXJhdGlvbiBlc3QgdW5lIGZvbmN0aW9uIGRlIGzigJlpbnZlcnNlIGRlIGxhIGRpc3RhbmNlIMOgIHBhcnRpciBkZXMgcGl4ZWxzIG91IGRlcyBwb2ludHMgY29ubnVzLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1SYXN0ZXJfcmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbCBlbiBlbnRyw6llLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1SYXN0ZXJfdmFyaWFibGVzX3RhZzBAQFwiOiBcIlZhcmlhYmxlKHMpIMOgIGluY2x1cmUgZGFucyBsYSBjb3VjaGUgcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsbGUuXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzBAQFwiOiBcIkluZGlxdWV6IGxhIG3DqXRob2RlIGRlIGRpc3RyaWJ1dGlvbiBkZSB2YWxldXJzIGFsw6lhdG9pcmVzIMOgIHV0aWxpc2VyLlwiLFxuXHRcIkBAUmFuZG9tX2Rpc3RyaWJ1dGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPlVuaWZvcm1lPC9zdHJvbmc+IChNaW5pbXVtLCBNYXhpbXVtKSA6IGRpc3RyaWJ1dGlvbiB1bmlmb3JtZSBhdmVjIHVuZSBwbGFnZSBkw6lmaW5pZS4gTGVzIHZhbGV1cnMgcGFyIGTDqWZhdXQgc29udCAwIHBvdXIgTWluaW11bSBldCAxIHBvdXIgTWF4aW11bS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnMkBAXCI6IFwiPHN0cm9uZz5FbnRpZXJzPC9zdHJvbmc+IChNaW5pbXVtLCBNYXhpbXVtKSA6IGRpc3RyaWJ1dGlvbiBk4oCZZW50aWVycyBhdmVjIHVuZSBwbGFnZSBkw6lmaW5pZS4gTGVzIHZhbGV1cnMgcGFyIGTDqWZhdXQgc29udCAxIHBvdXIgTWluaW11bSBldCAxMCBwb3VyIE1heGltdW0uXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzNAQFwiOiBcIjxzdHJvbmc+Tm9ybWFsZTwvc3Ryb25nPiAoTW95ZW5uZSwgw4ljYXJ0IHR5cGUpIDogZGlzdHJpYnV0aW9uIG5vcm1hbGUgYXZlYyBkw6lmaW5pdGlvbiBkZXMgdmFsZXVycyBNb3llbm5lIGV0IMOJY2FydCB0eXBlLiBMZXMgdmFsZXVycyBwYXIgZMOpZmF1dCBzb250IDAgcG91ciBNb3llbm5lIGV0IDEgcG91ciDDiWNhcnQgdHlwZS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnNEBAXCI6IFwiPHN0cm9uZz5FeHBvbmVudGllbGxlPC9zdHJvbmc+IChNb3llbm5lKSA6IGRpc3RyaWJ1dGlvbiBleHBvbmVudGllbGxlIGF2ZWMgZMOpZmluaXRpb24gZGUgbGEgdmFsZXVyIE1veWVubmUuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnNUBAXCI6IFwiPHN0cm9uZz5Qb2lzc29uPC9zdHJvbmc+IChNb3llbm5lKSA6IGRpc3RyaWJ1dGlvbiBQb2lzc29uIGF2ZWMgZMOpZmluaXRpb24gZGUgbGEgdmFsZXVyIE1veWVubmUuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnNkBAXCI6IFwiPHN0cm9uZz5HYW1tYTwvc3Ryb25nPiAoQWxwaGEsIELDqnRhKSA6IGRpc3RyaWJ1dGlvbiBnYW1tYSBhdmVjIGTDqWZpbml0aW9uIGRlcyB2YWxldXJzIEFscGhhIGV0IELDqnRhLiBMZXMgdmFsZXVycyBwYXIgZMOpZmF1dCBzb250IDEgcG91ciBBbHBoYSBldCAxIHBvdXIgQsOqdGEuXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzdAQFwiOiBcIjxzdHJvbmc+Qmlub21pYWxlPC9zdHJvbmc+IChOLCBQcm9iYWJpbGl0w6kpIDogZGlzdHJpYnV0aW9uIGJpbm9taWFsZSBhdmVjIGTDqWZpbml0aW9uIGRlcyB2YWxldXJzIE4gZXQgUHJvYmFiaWxpdMOpLiBMZXMgdmFsZXVycyBwYXIgZMOpZmF1dCBzb250IDEwIHBvdXIgTiBldCAwLDUgcG91ciBQcm9iYWJpbGl0w6kuXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzhAQFwiOiBcIjxzdHJvbmc+R8Opb23DqXRyaXF1ZTwvc3Ryb25nPiAoUHJvYmFiaWxpdMOpKSA6IGRpc3RyaWJ1dGlvbiBnw6lvbcOpdHJpcXVlIGF2ZWMgZMOpZmluaXRpb24gZGUgbGEgdmFsZXVyIFByb2JhYmlsaXTDqS4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAwLDUuXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzlAQFwiOiBcIjxzdHJvbmc+Qmlub21pYWxlIG7DqWdhdGl2ZTwvc3Ryb25nPiAociwgUHJvYmFiaWxpdMOpKSA6IGRpc3RyaWJ1dGlvbiBQYXNjYWwgYXZlYyBkw6lmaW5pdGlvbiBkZXMgdmFsZXVycyByIGV0IFByb2JhYmlsaXTDqS4gTGVzIHZhbGV1cnMgcGFyIGTDqWZhdXQgc29udCAxMCwwIHBvdXIgciBldCAwLDUgcG91ciBQcm9iYWJpbGl0w6kuXCIsXG5cdFwiQEBSYW5kb21fcmFuZG9tbnVtYmVyZ2VuZXJhdG9yX3RhZzBAQFwiOiBcIlNww6ljaWZpZXogbOKAmWFsZ29yaXRobWUgZHUgZ8OpbsOpcmF0ZXVyIGRlIG5vbWJyZXMgYWzDqWF0b2lyZXMgcXVpIHV0aWxpc2UgbGEgdmFsZXVyIGluaXRpYWxlIGV0IGxhIGRpc3RyaWJ1dGlvbiBwb3VyIGfDqW7DqXJlciB1bmUgc8OpcXVlbmNlIGRlIG5vbWJyZXMgYWzDqWF0b2lyZXMuIExlcyBvcHRpb25zIGRpc3BvbmlibGVzIHNvbnQgbGVzIHN1aXZhbnRlcyA6XCIsXG5cdFwiQEBSYW5kb21fcmFuZG9tbnVtYmVyZ2VuZXJhdG9yX3RhZzFAQFwiOiBcIlN0YW5kYXJkIEMgUmFuZFwiLFxuXHRcIkBAUmFuZG9tX3JhbmRvbW51bWJlcmdlbmVyYXRvcl90YWcyQEBcIjogXCJBbGdvcml0aG1lIGRlIGNvbGxlY3RlIEFDTSA1OTlcIixcblx0XCJAQFJhbmRvbV9yYW5kb21udW1iZXJnZW5lcmF0b3JfdGFnM0BAXCI6IFwiTWVyc2VubmUgVHdpc3RlclwiLFxuXHRcIkBAUmFuZG9tX3JhbmRvbW51bWJlcmdlbmVyYXRvcl90YWc0QEBcIjogXCJMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IE1lcnNlbm5lIFR3aXN0ZXIuXCIsXG5cdFwiQEBSYW5kb21fcmFzdGVyaW5mb190YWcwQEBcIjogXCJVdGlsaXNleiBsZSBib3V0b24gPHN0cm9uZz5DaGFyZ2VyIGxlIHJhc3RlciBtb2TDqGxlPC9zdHJvbmc+IHBvdXIgY2hhcmdlciB1biBtb2TDqGxlIMOgIHBhcnRpciBk4oCZdW4gcsOpcGVydG9pcmUgb3UgZOKAmXVuIHBvcnRhaWwuXCIsXG5cdFwiQEBSYW5kb21fc2VlZF90YWcwQEBcIjogXCJMYSB2YWxldXIgaW5pdGlhbGUgZXN0IHVuZSB2YWxldXIgZW50acOocmUgdXRpbGlzw6llIHBvdXIgaW5pdGlhbGlzZXIgbGUgZ8OpbsOpcmF0ZXVyIGRlIG5vbWJyZXMgYWzDqWF0b2lyZXMuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMS5cIixcblx0XCJAQFNocmlua19udW1iZXJvZmNlbGxzX3RhZzBAQFwiOiBcIk5vbWJyZSBkZSBjZWxsdWxlcyDDoCB1dGlsaXNlciBwb3VyIHLDqWR1aXJlIGNoYXF1ZSB6b25lIHNww6ljaWZpw6llLlwiLFxuXHRcIkBAU2hyaW5rX251bWJlcm9mY2VsbHNfdGFnMUBAXCI6IFwiTGEgdmFsZXVyIGRvaXQgw6p0cmUgdW4gZW50aWVyIGV0IHBldXQgw6p0cmUgw6lnYWxlIG91IHN1cMOpcmlldXJlIMOgIDEuXCIsXG5cdFwiQEBTaHJpbmtfcmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBlbiBlbnRyw6llIHBvdXIgbGVxdWVsIGxlcyB6b25lcyBpZGVudGlmacOpZXMgc2Vyb250IHLDqWR1aXRlcy5cIixcblx0XCJAQFNocmlua19yYXN0ZXJfdGFnMUBAXCI6IFwiSWwgZG9pdCDDqnRyZSBkZSB0eXBlIGVudGllci5cIixcblx0XCJAQFNocmlua196b25ldmFsdWVzX3RhZzBAQFwiOiBcIkxpc3RlIGRlcyB6b25lcyDDoCByw6lkdWlyZS5cIixcblx0XCJAQFNocmlua196b25ldmFsdWVzX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGRlIHpvbmUgZG9pdmVudCDDqnRyZSBkZXMgZW50aWVycyBldCBwZXV2ZW50IMOqdHJlIGRhbnMgbuKAmWltcG9ydGUgcXVlbCBvcmRyZS5cIixcblx0XCJAQFNocmlua196b25ldmFsdWVzX3RhZzJAQFwiOiBcIlBvdXIgcHLDqWNpc2VyIHBsdXNpZXVycyB6b25lcywgdXRpbGlzZXogdW4gZXNwYWNlIHBvdXIgc8OpcGFyZXIgbGVzIHZhbGV1cnMgZGUgem9uZS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9jb3N0cmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBkw6lmaW5pc3NhbnQgbGUgY2/Du3Qgb3UgbOKAmWltcMOpZGFuY2UgZGUgZMOpcGxhY2VtZW50IHBsYW5pbcOpdHJpcXVlIMOgIHRyYXZlcnMgY2hhcXVlIGNlbGx1bGUuIExhIHZhbGV1ciDDoCBjaGFxdWUgZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSByZXByw6lzZW50ZSBsZSBjb8O7dCBwYXIgdW5pdMOpIGRlIGRpc3RhbmNlIHBvdXIgbGUgZMOpcGxhY2VtZW50IMOgIHRyYXZlcnMgbGEgY2VsbHVsZS4gQ2hhcXVlIHZhbGV1ciBk4oCZZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlc3QgbXVsdGlwbGnDqWUgcGFyIGxhIHLDqXNvbHV0aW9uIGRlIGNlbGx1bGUgZXQgY29tcGVuc2Ugw6lnYWxlbWVudCBsZSBkw6lwbGFjZW1lbnQgZGlhZ29uYWwgYWZpbiBk4oCZb2J0ZW5pciBsZSBjb8O7dCB0b3RhbCBkdSBwYXNzYWdlIMOgIHRyYXZlcnMgbGEgY2VsbHVsZS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9jb3N0cmFzdGVyX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGR1IDxzdHJvbmc+UmFzdGVyIGRlIGNvw7t0PC9zdHJvbmc+IHBldXZlbnQgw6p0cmUgZGVzIGVudGllcnMgb3UgZGVzIG5vbWJyZXMgw6AgdmlyZ3VsZSBmbG90dGFudGUsIG1haXMgZWxsZXMgbmUgcGV1dmVudCBwYXMgw6p0cmUgbsOpZ2F0aXZlcyBuaSBudWxsZXMuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fZGlzdGFuY2VtZXRob2RfdGFnMEBAXCI6IFwiRMOpdGVybWluZSBzaSBsYSBkaXN0YW5jZSBkb2l0IMOqdHJlIGNhbGN1bMOpZSBhdmVjIHVuZSBtw6l0aG9kZSBwbGFuZSAoVGVycmUgcGxhdGUpIG91IGfDqW9kw6lzaXF1ZSAoZWxsaXBzb8OvZGUpLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzFAQFwiOiBcIlBsYW5lIDogbGVzIG1lc3VyZXMgcGxhbmVzIHV0aWxpc2VudCBkZXMgbWF0aMOpbWF0aXF1ZXMgY2FydMOpc2llbm5lcyBlbiAyRCBwb3VyIGNhbGN1bGVyIGxhIGxvbmd1ZXVyIGV0IGxhIHN1cmZhY2UuIENldHRlIG9wdGlvbiBlc3QgdW5pcXVlbWVudCBkaXNwb25pYmxlIGxvcnNxdWUgbGVzIG1lc3VyZXMgc29udCBlZmZlY3R1w6llcyBkYW5zIHVuIHN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBwcm9qZXTDqWVzLiBMZSBwbGFuIDJEIGRlIGNlIHN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBlc3QgYWxvcnMgdXRpbGlzw6kgY29tbWUgYmFzZSBkZXMgbWVzdXJlcy5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9kaXN0YW5jZW1ldGhvZF90YWcyQEBcIjogXCJHw6lvZMOpc2lxdWUgOiBsaWduZSBsYSBwbHVzIGNvdXJ0ZSBlbnRyZSBkZXV4IHBvaW50cyBkZSBsYSBzdXJmYWNlIGRlIGxhIFRlcnJlIHN1ciB1biBzcGjDqXJvw69kZSAoZWxsaXBzb8OvZGUpLiBMZXMgcsOpc3VsdGF0cyBuZSBjaGFuZ2VudCBkb25jIHBhcyBxdWVsbGUgcXVlIHNvaXQgbGEgcHJvamVjdGlvbiBlbiBlbnRyw6llIG91IGVuIHNvcnRpZS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9kaXN0YW5jZW1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPlJlbWFycXVlIDo8L3N0cm9uZz4gdm91cyBwb3V2ZXogdXRpbGlzZXIgdW5lIGxpZ25lIGfDqW9kw6lzaXF1ZSBzaSB2b3VzIHNvdWhhaXRleiBkw6l0ZXJtaW5lciBsYSBkaXN0YW5jZSBsYSBwbHVzIGNvdXJ0ZSBlbnRyZSBkZXV4IHZpbGxlcyBwb3VyIGxhIHRyYWplY3RvaXJlIGRlIHZvbCBk4oCZdW4gYXZpb24uIE9uIHBhcmxlIMOpZ2FsZW1lbnQgZGUgwqsgbGlnbmUgb3J0aG9kcm9taXF1ZSDCuyBzaSBlbGxlIHJlcG9zZSBzdXIgdW5lIHNwaMOocmUgcGx1dMO0dCBxdWUgc3VyIHVuIGVsbGlwc2/Dr2RlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2dlbmVyYXRlYmFja2RpcmVjdGlvbmJhbmRhc2FkZGl0aW9uYWxiYW5kaW5vdXRwdXRfdGFnMEBAXCI6IFwiRMOpdGVybWluZSBzaSBzZXVsIGxlIHJhc3RlciBk4oCZYWNjdW11bGF0aW9uIGRlIGRpc3RhbmNlIGVzdCBjcsOpw6kgb3Ugc2kgdW4gcmFzdGVyIG11bHRpYmFuZGUgY29uc3RpdHXDqSDDoCBsYSBmb2lzIGR1IHJhc3RlciBk4oCZYWNjdW11bGF0aW9uIGRlIGRpc3RhbmNlIGV0IGR1IHJhc3RlciBkZSBkaXJlY3Rpb24gYXJyacOocmUgZXN0IGNyw6nDqS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9nZW5lcmF0ZWJhY2tkaXJlY3Rpb25iYW5kYXNhZGRpdGlvbmFsYmFuZGlub3V0cHV0X3RhZzFAQFwiOiBcIkTDqXNhY3RpdsOpIDogbGUgcsOpc3VsdGF0IGVzdCBsZSByYXN0ZXIgZOKAmWFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZS4gSWwgc+KAmWFnaXQgZOKAmXVuIHLDqXN1bHRhdCDDoCB1bmUgc2V1bGUgYmFuZGUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fZ2VuZXJhdGViYWNrZGlyZWN0aW9uYmFuZGFzYWRkaXRpb25hbGJhbmRpbm91dHB1dF90YWcyQEBcIjogXCJBY3RpdsOpIDogdW4gcsOpc3VsdGF0IG11bHRpYmFuZGUgZXN0IGNyw6nDqS4gTGEgcHJlbWnDqHJlIGJhbmRlIGNvcnJlc3BvbmQgYXUgcmFzdGVyIGTigJlhY2N1bXVsYXRpb24gZGUgZGlzdGFuY2UgZXQgbGEgZGV1eGnDqG1lLCBhdSByYXN0ZXIgZGUgZGlyZWN0aW9uIGFycmnDqHJlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2dlbmVyYXRlYmFja2RpcmVjdGlvbmJhbmRhc2FkZGl0aW9uYWxiYW5kaW5vdXRwdXRfdGFnM0BAXCI6IFwiTGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBhcnJpw6hyZSBjYWxjdWxlIHBvdXIgY2hhcXVlIGNlbGx1bGUgbGEgZGlyZWN0aW9uLCBlbiBkZWdyw6lzLCB2ZXJzIGxhIGNlbGx1bGUgdm9pc2luZSBzdXIgbGUgY2hlbWluIGxlIHBsdXMgY291cnQgZW4gcmV2ZW5hbnQgdmVycyBsYSBjZWxsdWxlIHNvdXJjZSBsYSBwbHVzIHByb2NoZSwgZW4gw6l2aXRhbnQgdG91dGUgaW50ZXJydXB0aW9uLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2hvcml6b250YWxmYWN0b3JfdGFnMEBAXCI6IFwiPHA+RMOpZmluaXQgbGEgcmVsYXRpb24gZW50cmUgbGUgZmFjdGV1ciBkZSBjb8O7dCBob3Jpem9udGFsIGV0IGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiBob3Jpem9udGFsIChIUk1BKS48L3A+PHA+UGx1c2lldXJzIGZhY3RldXJzLCBhdmVjIG1vZGlmaWNhdGV1cnMsIGlkZW50aWZpZW50IHVuIGRpYWdyYW1tZSBkZSBmYWN0ZXVycyB2ZXJ0aWNhdXggZMOpZmluaS4gRW4gb3V0cmUsIHZvdXMgcG91dmV6IHV0aWxpc2VyIHVuZSB0YWJsZSBwb3VyIGNyw6llciB1biBkaWFncmFtbWUgcGVyc29ubmFsaXPDqS4gTGVzIGRpYWdyYW1tZXMgcGVybWV0dGVudCBk4oCZaWRlbnRpZmllciBsZSBmYWN0ZXVyIHZlcnRpY2FsIHV0aWxpc8OpIHBvdXIgbGUgY2FsY3VsIGR1IGNvw7t0IHRvdGFsIGTigJl1biBkw6lwbGFjZW1lbnQgdmVycyB1bmUgY2VsbHVsZSB2b2lzaW5lLjwvcD48cD5EYW5zIGxlcyBleHBsaWNhdGlvbnMgY2ktZGVzc291cywgZGV1eCBhY3JvbnltZXMgc29udCB1dGlsaXPDqXPCoDogSEYgZXQgSFJNQS4gTGUgZmFjdGV1ciBIRiBjb3JyZXNwb25kIGF1IGZhY3RldXIgaG9yaXpvbnRhbCBxdWkgcmVwcsOpc2VudGUgbGEgZGlmZmljdWx0w6kgaG9yaXpvbnRhbGUgcmVuY29udHLDqWUgbG9ycyBk4oCZdW4gZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSB2ZXJzIGxhIHN1aXZhbnRlLiBM4oCZYW5nbGUgSFJNQSBjb3JyZXNwb25kIMOgIGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiBob3Jpem9udGFsLCBsZXF1ZWwgcmVwcsOpc2VudGUgbOKAmWFuZ2xlIGVudHJlIGxhIGRpcmVjdGlvbiBob3Jpem9udGFsZSBk4oCZdW5lIGNlbGx1bGUgZXQgbGEgZGlyZWN0aW9uIGR1IGTDqXBsYWNlbWVudC48L3A+PHA+TGVzIHR5cGVzIGRlIDxzdHJvbmc+RmFjdGV1ciBob3Jpem9udGFsPC9zdHJvbmc+IHNvbnQgbGVzIHN1aXZhbnRzwqA6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5haXJlPC9zdHJvbmc+wqA6IGluZGlxdWUgcXVlIHNpIGzigJlhbmdsZSBIUk1BIGVzdCBpbmbDqXJpZXVyIMOgIGzigJlhbmdsZSBk4oCZaW5mbGV4aW9uLCBsZSBmYWN0ZXVyIEhGIGEgbGEgdmFsZXVyIGFzc29jacOpZSBhdSBmYWN0ZXVyIHrDqXJvLiBEYW5zIGxlIGNhcyBjb250cmFpcmUsIGxlIGZhY3RldXIgaG9yaXpvbnRhbCBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPkF2YW50PC9zdHJvbmc+wqA6IHByw6ljaXNlIHF1ZSBzZXVsIHVuIG1vdXZlbWVudCB2ZXJzIGzigJlhdmFudCBlc3QgYXV0b3Jpc8OpLiBM4oCZYW5nbGUgSFJNQSBkb2l0IMOqdHJlIHN1cMOpcmlldXIgb3Ugw6lnYWwgw6DCoDAgZXQgaW5mw6lyaWV1ciDDoCA5MMKgZGVncsOpcyAoMCAmbHQ7PSBIUk1BICZsdDsgOTApLiBTaSBs4oCZYW5nbGUgSFJNQSBlc3QgY29tcHJpcyBlbnRyZcKgMCBldCA0NcKgZGVncsOpcywgbGUgZmFjdGV1ciBIRiBkZSBsYSBjZWxsdWxlIGEgbGEgdmFsZXVyIGFzc29jacOpZSBhdSBmYWN0ZXVyIHrDqXJvLiBTaSBs4oCZYW5nbGUgSFJNQSBlc3Qgc3Vww6lyaWV1ciBvdSDDqWdhbCDDoCA0NcKgZGVncsOpcywgbGEgdmFsZXVyIGR1IG1vZGlmaWNhdGV1ciBkZSBsYSB2YWxldXIgZGUgYm9yZCBlc3QgdXRpbGlzw6llLiBMZSBmYWN0ZXVyIEhGIHBvdXIgdW4gYW5nbGUgSFJNQSDDqWdhbCBvdSBzdXDDqXJpZXVyIMOgIDkwwqBkZWdyw6lzIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBIRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBkZSBs4oCZYW5nbGUgSFJNQS48L2xpPjxsaT48c3Ryb25nPkxpbsOpYWlyZSBpbnZlcnNlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBIRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBpbnZlcnNlIGRlIGzigJlhbmdsZSBIUk1BLjwvbGk+PGxpPjxzdHJvbmc+VGFibGU8L3N0cm9uZz7CoDogaW5kaXF1ZSBxdeKAmXVuIGZpY2hpZXIgZGUgdGFibGUgc2VyYSB1dGlsaXPDqSBwb3VyIGTDqWZpbmlyIGxlIGRpYWdyYW1tZSBkZXMgZmFjdGV1cnMgaG9yaXpvbnRhdXggcGVybWV0dGFudCBkZSBkw6l0ZXJtaW5lciBsZXMgZmFjdGV1cnMgSEYuPC9saT48L3VsPjxwPkxlcyBtb2RpZmljYXRldXJzIGRlcyBmYWN0ZXVycyBob3Jpem9udGF1eCBzb250IGxlcyBzdWl2YW50c8KgOjwvcD48dWw+PGxpPjxzdHJvbmc+RmFjdGV1ciB6w6lybzwvc3Ryb25nPsKgOiBkw6lmaW5pdCBsZSBmYWN0ZXVyIGhvcml6b250YWwgw6AgdXRpbGlzZXIgbG9yc3F1ZSBs4oCZYW5nbGUgSFJNQSBlc3QgbnVsLiBDZSBmYWN0ZXVyIHBvc2l0aW9ubmUgbOKAmWludGVyc2VjdGlvbiBhdmVjIGzigJlheGUgZGVzIHkgZGUgdG91dGVzIGxlcyBmb25jdGlvbnMgZGUgZmFjdGV1ciBob3Jpem9udGFsLjwvbGk+PGxpPjxzdHJvbmc+QW5nbGUgZOKAmWluZmxleGlvbjwvc3Ryb25nPsKgOiBkw6lmaW5pdCBs4oCZYW5nbGUgSFJNQSBhdS1kZWzDoCBkdXF1ZWwgbGUgZmFjdGV1ciBIRiBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPlBlbnRlPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxhIHBlbnRlIGRlIGxhIGxpZ25lIGRyb2l0ZSB1dGlsaXPDqWUgYXZlYyBsZXMgbW90cy1jbMOpcyBkZSBmYWN0ZXVyIGhvcml6b250YWwgPHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz4gZXQgPHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZTwvc3Ryb25nPi4gTGEgcGVudGUgZXN0IHNww6ljaWZpw6llIHNvdXMgZm9ybWUgZOKAmXVuIHJhcHBvcnQgZGUgbGEgaGF1dGV1ciBzdXIgbGEgZGlzdGFuY2UgcGFyY291cnVlIChwYXIgZXhlbXBsZSwgdW5lIHBlbnRlIGRlIDQ1wqBwb3VyIGNlbnQgY29ycmVzcG9uZCDDoMKgMS80NSwgbGEgdmFsZXVyIGludHJvZHVpdGUgw6l0YW50wqAwLDAyMjIyKS48L2xpPjxsaT48c3Ryb25nPlZhbGV1ciBkZSBib3JkPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxlIGZhY3RldXIgSEYgbG9yc3F1ZSBs4oCZYW5nbGUgSFJNQSBlc3Qgc3Vww6lyaWV1ciBvdSDDqWdhbCDDoCA0NcKgZGVncsOpcyBldCBpbmbDqXJpZXVyIMOgIDkwwqBkZWdyw6lzIGxvcnNxdWUgbGUgbW90LWNsw6kgZGUgZmFjdGV1ciBob3Jpem9udGFsIDxzdHJvbmc+QXZhbnQ8L3N0cm9uZz4gZXN0IHNww6ljaWZpw6kuPC9saT48bGk+PHN0cm9uZz5Ob20gZGUgbGEgdGFibGU8L3N0cm9uZz7CoDogY29ycmVzcG9uZCBhdSBub20gZGUgbGEgdGFibGUgZMOpZmluaXNzYW50IGxlIGZhY3RldXIgSEYuPC9saT48L3VsPlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2hvcml6b250YWxyYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGTDqWZpbmlzc2FudCBsYSBkaXJlY3Rpb24gaG9yaXpvbnRhbGUgcG91ciBjaGFxdWUgY2VsbHVsZS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9ob3Jpem9udGFscmFzdGVyX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGR1IHJhc3RlciBkb2l2ZW50IMOqdHJlIGRlcyBlbnRpZXJzIGNvbXByaXMgZW50cmUgMCBldCAzNjAsIDAgZGVncsOpIGNvcnJlc3BvbmRhbnQgYXUgbm9yZCAodmVycyBsZSBoYXV0IGRlIGzigJnDqWNyYW4pLiBFbGxlcyBhdWdtZW50ZW50IGRhbnMgbGUgc2VucyBob3JhaXJlLiBMYSB2YWxldXIgLTEgZG9pdCDDqnRyZSBhdHRyaWJ1w6llIGF1eCBzdXJmYWNlcyBwbGFuZXMuIExlcyB2YWxldXJzIMOgIGNoYXF1ZSBlbXBsYWNlbWVudCBzZXJvbnQgdXRpbGlzw6llcyBjb25qb2ludGVtZW50IGF1IDxzdHJvbmc+RmFjdGV1ciBob3Jpem9udGFsPC9zdHJvbmc+IGFmaW4gZGUgZMOpdGVybWluZXIgbGUgY2/Du3QgaG9yaXpvbnRhbCBlbmNvdXJ1IGxvcnMgZOKAmXVuIGTDqXBsYWNlbWVudCDDoCBwYXJ0aXIgZOKAmXVuZSBjZWxsdWxlIHZlcnMgbGVzIGNlbGx1bGVzIHZvaXNpbmVzLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2luaXRpYWxhY2N1bXVsYXRpb25fdGFnMEBAXCI6IFwiQ2/Du3QgY3VtdWzDqSBpbml0aWFsIHBvdXIgY29tbWVuY2VyIGxlIGNhbGN1bCBkZSBjb8O7dC4gQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgc3DDqWNpZmllciBsZSBjb8O7dCBmaXhlIGFzc29jacOpIMOgIHVuZSBzb3VyY2UuIFBsdXTDtHQgcXVlIGRlIGNvbW1lbmNlciBhdmVjIHVuIGNvw7t0IMOpZ2FsIMOgIDAsIGzigJlhbGdvcml0aG1lIGRlIGNvw7t0IGNvbW1lbmNlIGF2ZWMgbGEgdmFsZXVyIGTDqWZpbmllLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2luaXRpYWxhY2N1bXVsYXRpb25fdGFnMUBAXCI6IFwiVm91cyBwb3V2ZXogdXRpbGlzZXIgcG91ciBjZSBwYXJhbcOodHJlIHVuZSB2YWxldXIgbnVtw6lyaXF1ZSAoZG91YmxlKSBvdSB1biBjaGFtcCBkdSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4uXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25faW5pdGlhbGFjY3VtdWxhdGlvbl90YWcyQEBcIjogXCJMYSB2YWxldXIgZG9pdCDDqnRyZSDDqWdhbGUgb3Ugc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMC5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9tYXhpbXVtYWNjdW11bGF0aW9uX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxlIGNvw7t0IGN1bXVsw6kgbWF4aW1hbCBwb3VyIGxlIHZveWFnZXVyIHBvdXIgdW5lIHNvdXJjZS4gTGVzIGNhbGN1bHMgZGUgY2/Du3QgY29udGludWVudCBwb3VyIGNoYXF1ZSBzb3VyY2UganVzcXXigJnDoCBjZSBxdWUgbGEgY2FwYWNpdMOpIHNww6ljaWZpw6llIHNvaXQgYXR0ZWludGUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbWF4aW11bWFjY3VtdWxhdGlvbl90YWcxQEBcIjogXCJWb3VzIHBvdXZleiB1dGlsaXNlciBwb3VyIGNlIHBhcmFtw6h0cmUgdW5lIHZhbGV1ciBudW3DqXJpcXVlIChkb3VibGUpIG91IHVuIGNoYW1wIGR1IDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPi5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9tYXhpbXVtYWNjdW11bGF0aW9uX3RhZzJAQFwiOiBcIkxhIHZhbGV1ciBkb2l0IMOqdHJlIHN1cMOpcmlldXJlIMOgIHrDqXJvLiBMYSBjYXBhY2l0w6kgcGFyIGTDqWZhdXQgZXN0IGxpbWl0w6llIHBhciBsZSBzZWdtZW50IGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzBAQFwiOiBcIk11bHRpcGxpY2F0ZXVyIMOgIGFwcGxpcXVlciBhdXggdmFsZXVycyBkZSBjb8O7dC5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9tdWx0aXBsaWVydG9hcHBseXRvY29zdHNfdGFnMUBAXCI6IFwiQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgY29udHLDtGxlciBsZSBtb2RlIGRlIGTDqXBsYWNlbWVudCBvdSBsYSBtYWduaXR1ZGUgw6AgdW5lIHNvdXJjZS4gUGx1cyBsZSBtdWx0aXBsaWNhdGV1ciBlc3Qgw6lsZXbDqSwgcGx1cyBsZSBjb8O7dCBkZSBkw6lwbGFjZW1lbnQgZOKAmXVuZSBjZWxsdWxlIMOgIHVuZSBhdXRyZSBlc3QgaW1wb3J0YW50LlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX211bHRpcGxpZXJ0b2FwcGx5dG9jb3N0c190YWcyQEBcIjogXCJWb3VzIHBvdXZleiB1dGlsaXNlciBwb3VyIGNlIHBhcmFtw6h0cmUgdW5lIHZhbGV1ciBudW3DqXJpcXVlIChkb3VibGUpIG91IHVuIGNoYW1wIGR1IDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPi5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9tdWx0aXBsaWVydG9hcHBseXRvY29zdHNfdGFnM0BAXCI6IFwiTGVzIHZhbGV1cnMgZG9pdmVudCDDqnRyZSBzdXDDqXJpZXVyZXMgw6AgesOpcm8uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9yYXN0ZXJiYXJyaWVyc190YWcwQEBcIjogXCJSYXN0ZXIgcXVpIGTDqWZpbml0IGxlcyBpbnRlcnJ1cHRpb25zLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3Jhc3RlcmJhcnJpZXJzX3RhZzFAQFwiOiBcIkxlIGpldSBkZSBkb25uw6llcyBkb2l0IGNvbnRlbmlyIHVuZSB2YWxldXIgTm9EYXRhIGxvcnNxdeKAmWlsIG7igJl5IGEgcGFzIGTigJlpbnRlcnJ1cHRpb24uIExlcyBpbnRlcnJ1cHRpb25zIHNvbnQgcmVwcsOpc2VudMOpZXMgcGFyIGRlcyB2YWxldXJzIHZhbGlkZXMsIHkgY29tcHJpcyB6w6lyby5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9yYXN0ZXJiYXJyaWVyc190YWcyQEBcIjogXCJMZXMgaW50ZXJydXB0aW9ucyBwZXV2ZW50IMOqdHJlIGTDqWZpbmllcyBwYXIgdW4gcmFzdGVyIGRlIHR5cGUgZW50aWVyIG91IMOgIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3NvdXJjZXJhc3Rlcl90YWcwQEBcIjogXCJFbXBsYWNlbWVudCBkZXMgc291cmNlcyBlbiBlbnRyw6llLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3NvdXJjZXJhc3Rlcl90YWcxQEBcIjogXCJKZXUgZGUgZG9ubsOpZXMgcmFzdGVyIHF1aSBpZGVudGlmaWUgbGVzIGNlbGx1bGVzIG91IGxlcyBlbXBsYWNlbWVudHMgZGVwdWlzIG91IHZlcnMgbGVzcXVlbHMgbGEgZGlzdGFuY2UgZGUgbW9pbmRyZSBjb8O7dCBjdW11bMOpIGVzdCBjYWxjdWzDqWUgcG91ciBjaGFxdWUgZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlbiBzb3J0aWUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fc291cmNlcmFzdGVyX3RhZzJAQFwiOiBcIklsIHBldXQgc+KAmWFnaXIgZOKAmXVuIHJhc3RlciBkZSB0eXBlIGVudGllciBvdSDDoCB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9zdXJmYWNlcmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBkw6lmaW5pc3NhbnQgbGVzIHZhbGV1cnMgZOKAmcOpbMOpdmF0aW9uIMOgIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3N1cmZhY2VyYXN0ZXJfdGFnMUBAXCI6IFwiQ2VzIHZhbGV1cnMgcGVybWV0dGVudCBkZSBjYWxjdWxlciBsYSBkaXN0YW5jZSBkZSBzdXJmYWNlIHLDqWVsbGUgcXVpIGVzdCBjb3V2ZXJ0ZSBsb3JzIGR1IHBhc3NhZ2UgZOKAmXVuZSBjZWxsdWxlIMOgIHVuZSBhdXRyZS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl90cmF2ZWxkaXJlY3Rpb25fdGFnMEBAXCI6IFwiRMOpZmluaXQgbGUgc2VucyBkdSB2b3lhZ2V1ciBlbiBjYXMgZOKAmWFwcGxpY2F0aW9uIGR1IGZhY3RldXIgdmVydGljYWwsIGR1IGZhY3RldXIgaG9yaXpvbnRhbCBldCBkdSB0YXV4IGRlIHLDqXNpc3RhbmNlIHNvdXJjZS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl90cmF2ZWxkaXJlY3Rpb25fdGFnMUBAXCI6IFwiPHN0cm9uZz7DgCBwYXJ0aXIgZGUgbGEgc291cmNlPC9zdHJvbmc+IDogbGUgZmFjdGV1ciB2ZXJ0aWNhbCwgbGUgZmFjdGV1ciBob3Jpem9udGFsIGV0IGxlIHRhdXggZGUgcsOpc2lzdGFuY2Ugc291cmNlIHNvbnQgYXBwbGlxdcOpcyDDoCBwYXJ0aXIgZGUgbGEgc291cmNlIGVuIGVudHLDqWUgZXQgZW4gc2UgZMOpcGxhw6dhbnQgdmVycyBsZXMgY2VsbHVsZXMgbm9uIHNvdXJjZXMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fdHJhdmVsZGlyZWN0aW9uX3RhZzJAQFwiOiBcIjxzdHJvbmc+VmVycyBsYSBzb3VyY2U8L3N0cm9uZz4gOiBsZSBmYWN0ZXVyIHZlcnRpY2FsLCBsZSBmYWN0ZXVyIGhvcml6b250YWwgZXQgbGUgdGF1eCBkZSByw6lzaXN0YW5jZSBzb3VyY2Ugc29udCBhcHBsaXF1w6lzIMOgIHBhcnRpciBkZSBjaGFxdWUgY2VsbHVsZSBub24gc291cmNlIGV0IGxvcnMgZHUgcmV0b3VyIMOgIGxhIHNvdXJjZSBlbiBlbnRyw6llLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3RyYXZlbGRpcmVjdGlvbl90YWczQEBcIjogXCJTcMOpY2lmaWV6IGxlIG1vdC1jbMOpIDxzdHJvbmc+w4AgcGFydGlyIGRlIGxhIHNvdXJjZTwvc3Ryb25nPiBvdSA8c3Ryb25nPlZlcnMgbGEgc291cmNlPC9zdHJvbmc+LCBxdWkgZXN0IGFwcGxpcXXDqSDDoCB0b3V0ZXMgbGVzIHNvdXJjZXMsIG91IHNww6ljaWZpZXogdW4gY2hhbXAgZGFucyBsZSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4gcXVpIGNvbnRpZW50IGxlcyBtb3RzLWNsw6lzIHBlcm1ldHRhbnQgZOKAmWlkZW50aWZpZXIgbGUgc2VucyBkZSBkw6lwbGFjZW1lbnQgcG91ciBjaGFxdWUgc291cmNlLiBDZSBjaGFtcCBkb2l0IGNvbnRlbmlyIGxhIGNoYcOubmUgJHtGUk9NX1NPVVJDRX0gb3UgJHtUT19TT1VSQ0V9LlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3ZlcnRpY2FsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkTDqWZpbml0IGxhIHJlbGF0aW9uIGVudHJlIGxlIGZhY3RldXIgZGUgY2/Du3QgdmVydGljYWwgZXQgbOKAmWFuZ2xlIGRlIGTDqXBsYWNlbWVudCByZWxhdGlmIHZlcnRpY2FsIChWUk1BKS48L3A+PHA+UGx1c2lldXJzIGZhY3RldXJzLCBhdmVjIG1vZGlmaWNhdGV1cnMsIGlkZW50aWZpZW50IHVuIGRpYWdyYW1tZSBkZSBmYWN0ZXVycyB2ZXJ0aWNhdXggZMOpZmluaS4gRW4gb3V0cmUsIHZvdXMgcG91dmV6IHV0aWxpc2VyIHVuZSB0YWJsZSBwb3VyIGNyw6llciB1biBkaWFncmFtbWUgcGVyc29ubmFsaXPDqS4gTGVzIGRpYWdyYW1tZXMgcGVybWV0dGVudCBk4oCZaWRlbnRpZmllciBsZSBmYWN0ZXVyIHZlcnRpY2FsIHV0aWxpc8OpIHBvdXIgbGUgY2FsY3VsIGR1IGNvw7t0IHRvdGFsIGTigJl1biBkw6lwbGFjZW1lbnQgdmVycyB1bmUgY2VsbHVsZSB2b2lzaW5lLjwvcD48cD5EYW5zIGxlcyBleHBsaWNhdGlvbnMgY2ktZGVzc291cywgZGV1eCBhY3JvbnltZXMgc29udCB1dGlsaXPDqXPCoDogVkYgZXQgVlJNQS4gTGUgZmFjdGV1ciBWRiBjb3JyZXNwb25kIGF1IGZhY3RldXIgdmVydGljYWwsIGxlcXVlbCByZXByw6lzZW50ZSBsYSBkaWZmaWN1bHTDqSB2ZXJ0aWNhbGUgcmVuY29udHLDqWUgbG9ycyBk4oCZdW4gZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSB2ZXJzIGxhIHN1aXZhbnRlLiBM4oCZYW5nbGUgVlJNQSBjb3JyZXNwb25kIMOgIGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiB2ZXJ0aWNhbCwgbGVxdWVsIHJlcHLDqXNlbnRlIGzigJlhbmdsZSBkZSBsYSBwZW50ZSBlbnRyZSBsYSBjZWxsdWxlIEZST00gKE9yaWdpbmUpLCBvdSBkZSB0cmFpdGVtZW50LCBldCBsYSBjZWxsdWxlIFRPIChEZXN0aW5hdGlvbikuPC9wPjxwPkxlcyB0eXBlcyBkZSA8c3Ryb25nPkZhY3RldXIgdmVydGljYWw8L3N0cm9uZz4gc29udCBsZXMgc3VpdmFudHPCoDo8L3A+PHVsPjxsaT48c3Ryb25nPkJpbmFpcmU8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBzaSBs4oCZYW5nbGUgVlJNQSBlc3Qgc3Vww6lyaWV1ciDDoCBs4oCZYW5nbGUgZOKAmWluZmxleGlvbiBpbmbDqXJpZXVyIGV0IGluZsOpcmlldXIgw6AgbOKAmWFuZ2xlIGTigJlpbmZsZXhpb24gc3Vww6lyaWV1ciwgbGUgZmFjdGV1ciBWRiBkb2l0IGNvcnJlc3BvbmRyZSDDoCBsYSB2YWxldXIgYXNzb2Npw6llIGF1IGZhY3RldXIgesOpcm8uIERhbnMgbGUgY2FzIGNvbnRyYWlyZSwgbGUgZmFjdGV1ciB2ZXJ0aWNhbCBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPkxpbsOpYWlyZTwvc3Ryb25nPsKgOiBpbmRpcXVlIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gbGluw6lhaXJlIGRlIGzigJlhbmdsZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlIHN5bcOpdHJpcXVlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBWRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBkZSBs4oCZYW5nbGUgVlJNQSwgZHUgY8O0dMOpIG7DqWdhdGlmIG91IGR1IGPDtHTDqSBwb3NpdGlmIGRlIGzigJlhbmdsZSBWUk1BLCByZXNwZWN0aXZlbWVudCwgZXQgcXVlIGxlcyBkZXV4IGZvbmN0aW9ucyBsaW7DqWFpcmVzIHNvbnQgc3ltw6l0cmlxdWVzIHBhciByYXBwb3J0IMOgIGzigJlheGUgKHkpIGR1IGZhY3RldXIgVkYuPC9saT48bGk+PHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZTwvc3Ryb25nPsKgOiBpbmRpcXVlIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gbGluw6lhaXJlIGludmVyc2UgZGUgbOKAmWFuZ2xlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZSBzeW3DqXRyaXF1ZTwvc3Ryb25nPsKgOiBzcMOpY2lmaWUgcXVlIGxlIGZhY3RldXIgVkYgZXN0IHVuZSBmb25jdGlvbiBsaW7DqWFpcmUgaW52ZXJzZSBkZSBs4oCZYW5nbGUgVlJNQSwgZHUgY8O0dMOpIG7DqWdhdGlmIG91IGR1IGPDtHTDqSBwb3NpdGlmIGRlIGzigJlhbmdsZSBWUk1BLCByZXNwZWN0aXZlbWVudCwgZXQgcXVlIGxlcyBkZXV4IGZvbmN0aW9ucyBsaW7DqWFpcmVzIHNvbnQgc3ltw6l0cmlxdWVzIHBhciByYXBwb3J0IMOgIGzigJlheGUgKHkpIGR1IGZhY3RldXIgVkYuPC9saT48bGk+PHN0cm9uZz5Db3M8L3N0cm9uZz7CoDogaWRlbnRpZmllIGxlIGZhY3RldXIgVkYgY29tbWUgdW5lIGZvbmN0aW9uIGNvc2ludXNvw69kYWxlIGRlIGzigJlhbmdsZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+U2VjPC9zdHJvbmc+wqA6IGlkZW50aWZpZSBsZSBmYWN0ZXVyIFZGIGNvbW1lIHVuZSBmb25jdGlvbiBzw6ljYW50ZSBkZSBs4oCZYW5nbGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPkNvcy1TZWM8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gY29zaW51c2/Dr2RhbGUgZGUgbOKAmWFuZ2xlIFZSTUEgbG9yc3F1ZSBjZSBkZXJuaWVyIGVzdCBuw6lnYXRpZiBldCBxdeKAmWlsIGVzdCB1bmUgZm9uY3Rpb24gc8OpY2FudGUgZGUgbOKAmWFuZ2xlIFZSTUEgbG9yc3F1ZSBjZSBkZXJuaWVyIG7igJllc3QgcGFzIG7DqWdhdGlmLjwvbGk+PGxpPjxzdHJvbmc+U2VjLUNvczwvc3Ryb25nPsKgOiBzcMOpY2lmaWUgcXVlIGxlIGZhY3RldXIgVkYgZXN0IHVuZSBmb25jdGlvbiBzw6ljYW50ZSBkZSBs4oCZYW5nbGUgVlJNQSBsb3JzcXVlIGNlIGRlcm5pZXIgZXN0IG7DqWdhdGlmIGV0IHF14oCZaWwgZXN0IHVuZSBmb25jdGlvbiBjb3NpbnVzb8OvZGFsZSBkZSBs4oCZYW5nbGUgVlJNQSBsb3JzcXVlIGNlIGRlcm5pZXIgbuKAmWVzdCBwYXMgbsOpZ2F0aWYuPC9saT48bGk+PHN0cm9uZz5UYWJsZTwvc3Ryb25nPsKgOiBpbmRpcXVlIHF14oCZdW4gZmljaGllciBkZSB0YWJsZSBzZXJhIHV0aWxpc8OpIHBvdXIgZMOpZmluaXIgbGUgZGlhZ3JhbW1lIGRlcyBmYWN0ZXVycyB2ZXJ0aWNhdXggcGVybWV0dGFudCBkZSBkw6l0ZXJtaW5lciBsZXMgZmFjdGV1cnMgVkYuPC9saT48L3VsPjxwPkxlcyBtb2RpZmljYXRldXJzIGRlcyBtb3RzLWNsw6lzIGRlIGZhY3RldXIgdmVydGljYWwgc29udCBsZXMgc3VpdmFudHPCoDo8L3A+PHVsPjxsaT48c3Ryb25nPkZhY3RldXIgesOpcm88L3N0cm9uZz7CoDogZMOpZmluaXQgbGUgZmFjdGV1ciB2ZXJ0aWNhbCB1dGlsaXPDqSBsb3JzcXVlIGzigJlhbmdsZSBWUk1BIGVzdCBudWwuIENlIGZhY3RldXIgcG9zaXRpb25uZSBs4oCZaW50ZXJzZWN0aW9uIGF2ZWMgbOKAmWF4ZSBkZXMgeSBkZSBsYSBmb25jdGlvbiBzcMOpY2lmacOpZS4gUGFyIGTDqWZpbml0aW9uLCBsZSBmYWN0ZXVyIHrDqXJvIG5lIHPigJlhcHBsaXF1ZSDDoCBhdWN1bmUgZm9uY3Rpb24gdmVydGljYWxlIHRyaWdvbm9tw6l0cmlxdWUgKENPUywgU0VDLCBDT1MtU0VDIG91IFNFQy1DT1MpLiBDZXMgZm9uY3Rpb25zIGTDqWZpbmlzc2VudCBs4oCZaW50ZXJjZXB0aW9uIGRlIGzigJlheGUgZGVzIHkuPC9saT48bGk+PHN0cm9uZz5BbmdsZSBk4oCZaW5mbGV4aW9uIGluZsOpcmlldXI8L3N0cm9uZz7CoDogZMOpZmluaXQgbOKAmWFuZ2xlIFZSTUEgZW4gZGVzc291cyBkdXF1ZWwgbGUgZmFjdGV1ciBWRiBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPkFuZ2xlIGTigJlpbmZsZXhpb24gc3Vww6lyaWV1cjwvc3Ryb25nPsKgOiBkw6lmaW5pdCBs4oCZYW5nbGUgVlJNQSBhdS1kZXNzdXMgZHVxdWVsIGxlIGZhY3RldXLCoFZGIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+UGVudGU8L3N0cm9uZz7CoDogZMOpZmluaXQgbGEgcGVudGUgZGUgbGEgbGlnbmUgZHJvaXRlIHV0aWxpc8OpZSBhdmVjIGxlcyBtb3RzLWNsw6lzIGRlIGZhY3RldXIgdmVydGljYWwgPHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz4gZXQgPHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZTwvc3Ryb25nPi4gTGEgcGVudGUgZXN0IHNww6ljaWZpw6llIHNvdXMgZm9ybWUgZOKAmXVuIHJhcHBvcnQgZGUgbGEgaGF1dGV1ciBzdXIgbGEgZGlzdGFuY2UgcGFyY291cnVlIChwYXIgZXhlbXBsZSwgdW5lIHBlbnRlIGRlIDQ1wqBwb3VyIGNlbnQgY29ycmVzcG9uZCDDoMKgMS80NSwgbGEgdmFsZXVyIGludHJvZHVpdGUgw6l0YW50wqAwLDAyMjIyKS48L2xpPjxsaT48c3Ryb25nPk5vbSBkZSBsYSB0YWJsZTwvc3Ryb25nPsKgOiBjb3JyZXNwb25kIGF1IG5vbSBkZSBsYSB0YWJsZSBkw6lmaW5pc3NhbnQgbGUgZmFjdGV1ciBWRi48L2xpPjwvdWw+XCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fdmVydGljYWxyYXN0ZXJfdGFnMEBAXCI6IFwiRMOpZmluaXQgbGEgcmVsYXRpb24gZW50cmUgbGUgZmFjdGV1ciBkZSBjb8O7dCB2ZXJ0aWNhbCBldCBs4oCZYW5nbGUgZGUgZMOpcGxhY2VtZW50IHJlbGF0aWYgdmVydGljYWwgKFZSTUEpLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3ZlcnRpY2FscmFzdGVyX3RhZzFAQFwiOiBcIkNlcyB2YWxldXJzIHBlcm1ldHRlbnQgZGUgY2FsY3VsZXIgbGEgcGVudGUgdXRpbGlzw6llIHBvdXIgaWRlbnRpZmllciBsZSBmYWN0ZXVyIHZlcnRpY2FsIGFzc29jacOpIGF1IGTDqXBsYWNlbWVudCBk4oCZdW5lIGNlbGx1bGUgw6AgdW5lIGF1dHJlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9jb3N0cmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBkw6lmaW5pc3NhbnQgbGUgY2/Du3Qgb3UgbOKAmWltcMOpZGFuY2UgZGUgZMOpcGxhY2VtZW50IHBsYW5pbcOpdHJpcXVlIMOgIHRyYXZlcnMgY2hhcXVlIGNlbGx1bGUuIExhIHZhbGV1ciDDoCBjaGFxdWUgZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSByZXByw6lzZW50ZSBsZSBjb8O7dCBwYXIgdW5pdMOpIGRlIGRpc3RhbmNlIHBvdXIgbGUgZMOpcGxhY2VtZW50IMOgIHRyYXZlcnMgbGEgY2VsbHVsZS4gQ2hhcXVlIHZhbGV1ciBk4oCZZW1wbGFjZW1lbnQgZGUgY2VsbHVsZSBlc3QgbXVsdGlwbGnDqWUgcGFyIGxhIHLDqXNvbHV0aW9uIGRlIGNlbGx1bGUgZXQgY29tcGVuc2Ugw6lnYWxlbWVudCBsZSBkw6lwbGFjZW1lbnQgZGlhZ29uYWwgYWZpbiBk4oCZb2J0ZW5pciBsZSBjb8O7dCB0b3RhbCBkdSBwYXNzYWdlIMOgIHRyYXZlcnMgbGEgY2VsbHVsZS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fY29zdHJhc3Rlcl90YWcxQEBcIjogXCJMZXMgdmFsZXVycyBkdSA8c3Ryb25nPlJhc3RlciBkZSBjb8O7dDwvc3Ryb25nPiBwZXV2ZW50IMOqdHJlIGRlcyBlbnRpZXJzIG91IGRlcyBub21icmVzIMOgIHZpcmd1bGUgZmxvdHRhbnRlLCBtYWlzIGVsbGVzIG5lIHBldXZlbnQgcGFzIMOqdHJlIG7DqWdhdGl2ZXMgbmkgbnVsbGVzLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9kaXN0YW5jZW1ldGhvZF90YWcwQEBcIjogXCJEw6l0ZXJtaW5lIHNpIGxhIGRpc3RhbmNlIGRvaXQgw6p0cmUgY2FsY3Vsw6llIGF2ZWMgdW5lIG3DqXRob2RlIHBsYW5lIChUZXJyZSBwbGF0ZSkgb3UgZ8Opb2TDqXNpcXVlIChlbGxpcHNvw69kZSkuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzFAQFwiOiBcIlBsYW5lIDogbGVzIG1lc3VyZXMgcGxhbmVzIHV0aWxpc2VudCBkZXMgbWF0aMOpbWF0aXF1ZXMgY2FydMOpc2llbm5lcyBlbiAyRCBwb3VyIGNhbGN1bGVyIGxhIGxvbmd1ZXVyIGV0IGxhIHN1cmZhY2UuIENldHRlIG9wdGlvbiBlc3QgdW5pcXVlbWVudCBkaXNwb25pYmxlIGxvcnNxdWUgbGVzIG1lc3VyZXMgc29udCBlZmZlY3R1w6llcyBkYW5zIHVuIHN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBwcm9qZXTDqWVzLiBMZSBwbGFuIDJEIGRlIGNlIHN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBlc3QgYWxvcnMgdXRpbGlzw6kgY29tbWUgYmFzZSBkZXMgbWVzdXJlcy5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fZGlzdGFuY2VtZXRob2RfdGFnMkBAXCI6IFwiR8Opb2TDqXNpcXVlIDogbGlnbmUgbGEgcGx1cyBjb3VydGUgZW50cmUgZGV1eCBwb2ludHMgZGUgbGEgc3VyZmFjZSBkZSBsYSBUZXJyZSBzdXIgdW4gc3Bow6lyb8OvZGUgKGVsbGlwc2/Dr2RlKS4gTGVzIHLDqXN1bHRhdHMgbmUgY2hhbmdlbnQgZG9uYyBwYXMgcXVlbGxlIHF1ZSBzb2l0IGxhIHByb2plY3Rpb24gZW4gZW50csOpZSBvdSBlbiBzb3J0aWUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzNAQFwiOiBcIjxzdHJvbmc+UmVtYXJxdWUgOjwvc3Ryb25nPiB2b3VzIHBvdXZleiB1dGlsaXNlciB1bmUgbGlnbmUgZ8Opb2TDqXNpcXVlIHNpIHZvdXMgc291aGFpdGV6IGTDqXRlcm1pbmVyIGxhIGRpc3RhbmNlIGxhIHBsdXMgY291cnRlIGVudHJlIGRldXggdmlsbGVzIHBvdXIgbGEgdHJhamVjdG9pcmUgZGUgdm9sIGTigJl1biBhdmlvbi4gT24gcGFybGUgw6lnYWxlbWVudCBkZSDCqyBsaWduZSBvcnRob2Ryb21pcXVlIMK7IHNpIGVsbGUgcmVwb3NlIHN1ciB1bmUgc3Bow6hyZSBwbHV0w7R0IHF1ZSBzdXIgdW4gZWxsaXBzb8OvZGUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2hvcml6b250YWxmYWN0b3JfdGFnMEBAXCI6IFwiPHA+RMOpZmluaXQgbGEgcmVsYXRpb24gZW50cmUgbGUgZmFjdGV1ciBkZSBjb8O7dCBob3Jpem9udGFsIGV0IGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiBob3Jpem9udGFsIChIUk1BKS48L3A+PHA+UGx1c2lldXJzIGZhY3RldXJzLCBhdmVjIG1vZGlmaWNhdGV1cnMsIGlkZW50aWZpZW50IHVuIGRpYWdyYW1tZSBkZSBmYWN0ZXVycyB2ZXJ0aWNhdXggZMOpZmluaS4gRW4gb3V0cmUsIHZvdXMgcG91dmV6IHV0aWxpc2VyIHVuZSB0YWJsZSBwb3VyIGNyw6llciB1biBkaWFncmFtbWUgcGVyc29ubmFsaXPDqS4gTGVzIGRpYWdyYW1tZXMgcGVybWV0dGVudCBk4oCZaWRlbnRpZmllciBsZSBmYWN0ZXVyIHZlcnRpY2FsIHV0aWxpc8OpIHBvdXIgbGUgY2FsY3VsIGR1IGNvw7t0IHRvdGFsIGTigJl1biBkw6lwbGFjZW1lbnQgdmVycyB1bmUgY2VsbHVsZSB2b2lzaW5lLjwvcD48cD5EYW5zIGxlcyBleHBsaWNhdGlvbnMgY2ktZGVzc291cywgZGV1eCBhY3JvbnltZXMgc29udCB1dGlsaXPDqXPCoDogSEYgZXQgSFJNQS4gTGUgZmFjdGV1ciBIRiBjb3JyZXNwb25kIGF1IGZhY3RldXIgaG9yaXpvbnRhbCBxdWkgcmVwcsOpc2VudGUgbGEgZGlmZmljdWx0w6kgaG9yaXpvbnRhbGUgcmVuY29udHLDqWUgbG9ycyBk4oCZdW4gZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSB2ZXJzIGxhIHN1aXZhbnRlLiBM4oCZYW5nbGUgSFJNQSBjb3JyZXNwb25kIMOgIGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiBob3Jpem9udGFsLCBsZXF1ZWwgcmVwcsOpc2VudGUgbOKAmWFuZ2xlIGVudHJlIGxhIGRpcmVjdGlvbiBob3Jpem9udGFsZSBk4oCZdW5lIGNlbGx1bGUgZXQgbGEgZGlyZWN0aW9uIGR1IGTDqXBsYWNlbWVudC48L3A+PHA+TGVzIHR5cGVzIGRlIDxzdHJvbmc+RmFjdGV1ciBob3Jpem9udGFsPC9zdHJvbmc+IHNvbnQgbGVzIHN1aXZhbnRzwqA6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5haXJlPC9zdHJvbmc+wqA6IGluZGlxdWUgcXVlIHNpIGzigJlhbmdsZSBIUk1BIGVzdCBpbmbDqXJpZXVyIMOgIGzigJlhbmdsZSBk4oCZaW5mbGV4aW9uLCBsZSBmYWN0ZXVyIEhGIGEgbGEgdmFsZXVyIGFzc29jacOpZSBhdSBmYWN0ZXVyIHrDqXJvLiBEYW5zIGxlIGNhcyBjb250cmFpcmUsIGxlIGZhY3RldXIgaG9yaXpvbnRhbCBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPkF2YW50PC9zdHJvbmc+wqA6IHByw6ljaXNlIHF1ZSBzZXVsIHVuIG1vdXZlbWVudCB2ZXJzIGzigJlhdmFudCBlc3QgYXV0b3Jpc8OpLiBM4oCZYW5nbGUgSFJNQSBkb2l0IMOqdHJlIHN1cMOpcmlldXIgb3Ugw6lnYWwgw6DCoDAgZXQgaW5mw6lyaWV1ciDDoCA5MMKgZGVncsOpcyAoMCAmbHQ7PSBIUk1BICZsdDsgOTApLiBTaSBs4oCZYW5nbGUgSFJNQSBlc3QgY29tcHJpcyBlbnRyZcKgMCBldCA0NcKgZGVncsOpcywgbGUgZmFjdGV1ciBIRiBkZSBsYSBjZWxsdWxlIGEgbGEgdmFsZXVyIGFzc29jacOpZSBhdSBmYWN0ZXVyIHrDqXJvLiBTaSBs4oCZYW5nbGUgSFJNQSBlc3Qgc3Vww6lyaWV1ciBvdSDDqWdhbCDDoCA0NcKgZGVncsOpcywgbGEgdmFsZXVyIGR1IG1vZGlmaWNhdGV1ciBkZSBsYSB2YWxldXIgZGUgYm9yZCBlc3QgdXRpbGlzw6llLiBMZSBmYWN0ZXVyIEhGIHBvdXIgdW4gYW5nbGUgSFJNQSDDqWdhbCBvdSBzdXDDqXJpZXVyIMOgIDkwwqBkZWdyw6lzIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBIRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBkZSBs4oCZYW5nbGUgSFJNQS48L2xpPjxsaT48c3Ryb25nPkxpbsOpYWlyZSBpbnZlcnNlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBIRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBpbnZlcnNlIGRlIGzigJlhbmdsZSBIUk1BLjwvbGk+PGxpPjxzdHJvbmc+VGFibGU8L3N0cm9uZz7CoDogaW5kaXF1ZSBxdeKAmXVuIGZpY2hpZXIgZGUgdGFibGUgc2VyYSB1dGlsaXPDqSBwb3VyIGTDqWZpbmlyIGxlIGRpYWdyYW1tZSBkZXMgZmFjdGV1cnMgaG9yaXpvbnRhdXggcGVybWV0dGFudCBkZSBkw6l0ZXJtaW5lciBsZXMgZmFjdGV1cnMgSEYuPC9saT48L3VsPjxwPkxlcyBtb2RpZmljYXRldXJzIGRlcyBmYWN0ZXVycyBob3Jpem9udGF1eCBzb250IGxlcyBzdWl2YW50c8KgOjwvcD48dWw+PGxpPjxzdHJvbmc+RmFjdGV1ciB6w6lybzwvc3Ryb25nPsKgOiBkw6lmaW5pdCBsZSBmYWN0ZXVyIGhvcml6b250YWwgw6AgdXRpbGlzZXIgbG9yc3F1ZSBs4oCZYW5nbGUgSFJNQSBlc3QgbnVsLiBDZSBmYWN0ZXVyIHBvc2l0aW9ubmUgbOKAmWludGVyc2VjdGlvbiBhdmVjIGzigJlheGUgZGVzIHkgZGUgdG91dGVzIGxlcyBmb25jdGlvbnMgZGUgZmFjdGV1ciBob3Jpem9udGFsLjwvbGk+PGxpPjxzdHJvbmc+QW5nbGUgZOKAmWluZmxleGlvbjwvc3Ryb25nPsKgOiBkw6lmaW5pdCBs4oCZYW5nbGUgSFJNQSBhdS1kZWzDoCBkdXF1ZWwgbGUgZmFjdGV1ciBIRiBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPlBlbnRlPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxhIHBlbnRlIGRlIGxhIGxpZ25lIGRyb2l0ZSB1dGlsaXPDqWUgYXZlYyBsZXMgbW90cy1jbMOpcyBkZSBmYWN0ZXVyIGhvcml6b250YWwgPHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz4gZXQgPHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZTwvc3Ryb25nPi4gTGEgcGVudGUgZXN0IHNww6ljaWZpw6llIHNvdXMgZm9ybWUgZOKAmXVuIHJhcHBvcnQgZGUgbGEgaGF1dGV1ciBzdXIgbGEgZGlzdGFuY2UgcGFyY291cnVlIChwYXIgZXhlbXBsZSwgdW5lIHBlbnRlIGRlIDQ1wqBwb3VyIGNlbnQgY29ycmVzcG9uZCDDoMKgMS80NSwgbGEgdmFsZXVyIGludHJvZHVpdGUgw6l0YW50wqAwLDAyMjIyKS48L2xpPjxsaT48c3Ryb25nPlZhbGV1ciBkZSBib3JkPC9zdHJvbmc+wqA6IGTDqWZpbml0IGxlIGZhY3RldXIgSEYgbG9yc3F1ZSBs4oCZYW5nbGUgSFJNQSBlc3Qgc3Vww6lyaWV1ciBvdSDDqWdhbCDDoCA0NcKgZGVncsOpcyBldCBpbmbDqXJpZXVyIMOgIDkwwqBkZWdyw6lzIGxvcnNxdWUgbGUgbW90LWNsw6kgZGUgZmFjdGV1ciBob3Jpem9udGFsIDxzdHJvbmc+QXZhbnQ8L3N0cm9uZz4gZXN0IHNww6ljaWZpw6kuPC9saT48bGk+PHN0cm9uZz5Ob20gZGUgbGEgdGFibGU8L3N0cm9uZz7CoDogY29ycmVzcG9uZCBhdSBub20gZGUgbGEgdGFibGUgZMOpZmluaXNzYW50IGxlIGZhY3RldXIgSEYuPC9saT48L3VsPlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9ob3Jpem9udGFscmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBkw6lmaW5pc3NhbnQgbGEgZGlyZWN0aW9uIGhvcml6b250YWxlIHBvdXIgY2hhcXVlIGNlbGx1bGUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2hvcml6b250YWxyYXN0ZXJfdGFnMUBAXCI6IFwiTGVzIHZhbGV1cnMgZHUgcmFzdGVyIGRvaXZlbnQgw6p0cmUgZGVzIGVudGllcnMgY29tcHJpcyBlbnRyZSAwIGV0IDM2MCwgMCBkZWdyw6kgY29ycmVzcG9uZGFudCBhdSBub3JkICh2ZXJzIGxlIGhhdXQgZGUgbOKAmcOpY3JhbikuIEVsbGVzIGF1Z21lbnRlbnQgZGFucyBsZSBzZW5zIGhvcmFpcmUuIExhIHZhbGV1ciAtMSBkb2l0IMOqdHJlIGF0dHJpYnXDqWUgYXV4IHN1cmZhY2VzIHBsYW5lcy4gTGVzIHZhbGV1cnMgw6AgY2hhcXVlIGVtcGxhY2VtZW50IHNlcm9udCB1dGlsaXPDqWVzIGNvbmpvaW50ZW1lbnQgYXUgPHN0cm9uZz5GYWN0ZXVyIGhvcml6b250YWw8L3N0cm9uZz4gYWZpbiBkZSBkw6l0ZXJtaW5lciBsZSBjb8O7dCBob3Jpem9udGFsIGVuY291cnUgbG9ycyBk4oCZdW4gZMOpcGxhY2VtZW50IMOgIHBhcnRpciBk4oCZdW5lIGNlbGx1bGUgdmVycyBsZXMgY2VsbHVsZXMgdm9pc2luZXMuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2luaXRpYWxhY2N1bXVsYXRpb25fdGFnMEBAXCI6IFwiQ2/Du3QgY3VtdWzDqSBpbml0aWFsIHBvdXIgY29tbWVuY2VyIGxlIGNhbGN1bCBkZSBjb8O7dC4gQ2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgc3DDqWNpZmllciBsZSBjb8O7dCBmaXhlIGFzc29jacOpIMOgIHVuZSBzb3VyY2UuIFBsdXTDtHQgcXVlIGRlIGNvbW1lbmNlciBhdmVjIHVuIGNvw7t0IMOpZ2FsIMOgIDAsIGzigJlhbGdvcml0aG1lIGRlIGNvw7t0IGNvbW1lbmNlIGF2ZWMgbGEgdmFsZXVyIGTDqWZpbmllLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9pbml0aWFsYWNjdW11bGF0aW9uX3RhZzFAQFwiOiBcIlZvdXMgcG91dmV6IHV0aWxpc2VyIHBvdXIgY2UgcGFyYW3DqHRyZSB1bmUgdmFsZXVyIG51bcOpcmlxdWUgKGRvdWJsZSkgb3UgdW4gY2hhbXAgZHUgPHN0cm9uZz5SYXN0ZXIgc291cmNlPC9zdHJvbmc+LlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9pbml0aWFsYWNjdW11bGF0aW9uX3RhZzJAQFwiOiBcIkxhIHZhbGV1ciBkb2l0IMOqdHJlIMOpZ2FsZSBvdSBzdXDDqXJpZXVyZSDDoCB6w6lyby4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAwLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9tYXhpbXVtYWNjdW11bGF0aW9uX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxlIGNvw7t0IGN1bXVsw6kgbWF4aW1hbCBwb3VyIGxlIHZveWFnZXVyIHBvdXIgdW5lIHNvdXJjZS4gTGVzIGNhbGN1bHMgZGUgY2/Du3QgY29udGludWVudCBwb3VyIGNoYXF1ZSBzb3VyY2UganVzcXXigJnDoCBjZSBxdWUgbGEgY2FwYWNpdMOpIHNww6ljaWZpw6llIHNvaXQgYXR0ZWludGUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX21heGltdW1hY2N1bXVsYXRpb25fdGFnMUBAXCI6IFwiVm91cyBwb3V2ZXogdXRpbGlzZXIgcG91ciBjZSBwYXJhbcOodHJlIHVuZSB2YWxldXIgbnVtw6lyaXF1ZSAoZG91YmxlKSBvdSB1biBjaGFtcCBkdSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4uXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX21heGltdW1hY2N1bXVsYXRpb25fdGFnMkBAXCI6IFwiTGEgdmFsZXVyIGRvaXQgw6p0cmUgc3Vww6lyaWV1cmUgw6AgesOpcm8uIExhIGNhcGFjaXTDqSBwYXIgZMOpZmF1dCBlc3QgbGltaXTDqWUgcGFyIGxlIHNlZ21lbnQgZHUgcmFzdGVyIGVuIHNvcnRpZS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzBAQFwiOiBcIk11bHRpcGxpY2F0ZXVyIMOgIGFwcGxpcXVlciBhdXggdmFsZXVycyBkZSBjb8O7dC5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzFAQFwiOiBcIkNlIHBhcmFtw6h0cmUgcGVybWV0IGRlIGNvbnRyw7RsZXIgbGUgbW9kZSBkZSBkw6lwbGFjZW1lbnQgb3UgbGEgbWFnbml0dWRlIMOgIHVuZSBzb3VyY2UuIFBsdXMgbGUgbXVsdGlwbGljYXRldXIgZXN0IMOpbGV2w6ksIHBsdXMgbGUgY2/Du3QgZGUgZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSDDoCB1bmUgYXV0cmUgZXN0IGltcG9ydGFudC5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzJAQFwiOiBcIkxlcyB2YWxldXJzIGRvaXZlbnQgw6p0cmUgc3Vww6lyaWV1cmVzIMOgIHrDqXJvLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDEuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX211bHRpcGxpZXJ0b2FwcGx5dG9jb3N0c190YWczQEBcIjogXCJWb3VzIHBvdXZleiB1dGlsaXNlciBwb3VyIGNlIHBhcmFtw6h0cmUgdW5lIHZhbGV1ciBudW3DqXJpcXVlIChkb3VibGUpIG91IHVuIGNoYW1wIGR1IDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPi5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fcmFzdGVyYmFycmllcnNfdGFnMEBAXCI6IFwiUmFzdGVyIHF1aSBkw6lmaW5pdCBsZXMgaW50ZXJydXB0aW9ucy5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fcmFzdGVyYmFycmllcnNfdGFnMUBAXCI6IFwiTGUgamV1IGRlIGRvbm7DqWVzIGRvaXQgY29udGVuaXIgdW5lIHZhbGV1ciBOb0RhdGEgbG9yc3F14oCZaWwgbuKAmXkgYSBwYXMgZOKAmWludGVycnVwdGlvbi4gTGVzIGludGVycnVwdGlvbnMgc29udCByZXByw6lzZW50w6llcyBwYXIgZGVzIHZhbGV1cnMgdmFsaWRlcywgeSBjb21wcmlzIHrDqXJvLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9yYXN0ZXJiYXJyaWVyc190YWcyQEBcIjogXCJMZXMgaW50ZXJydXB0aW9ucyBwZXV2ZW50IMOqdHJlIGTDqWZpbmllcyBwYXIgdW4gcmFzdGVyIGRlIHR5cGUgZW50aWVyIG91IMOgIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zb3VyY2VmaWVsZF90YWcwQEBcIjogXCJDaGFtcCBwZXJtZXR0YW50IGTigJlhdHRyaWJ1ZXIgZGVzIHZhbGV1cnMgYXV4IGVtcGxhY2VtZW50cyBzb3VyY2VzLiBJbCBkb2l0IMOqdHJlIGRlIHR5cGUgZW50aWVyLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zb3VyY2VyYXN0ZXJfdGFnMEBAXCI6IFwiRW1wbGFjZW1lbnQgZGVzIHNvdXJjZXMgZW4gZW50csOpZS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fc291cmNlcmFzdGVyX3RhZzFAQFwiOiBcIkpldSBkZSBkb25uw6llcyByYXN0ZXIgcXVpIGlkZW50aWZpZSBsZXMgY2VsbHVsZXMgb3UgbGVzIGVtcGxhY2VtZW50cyBkZXB1aXMgb3UgdmVycyBsZXNxdWVscyBsYSBkaXN0YW5jZSBkZSBtb2luZHJlIGNvw7t0IGN1bXVsw6kgZXN0IGNhbGN1bMOpZSBwb3VyIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVuIHNvcnRpZS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fc291cmNlcm93YW5kY29sdW1uYmFuZHNfdGFnMEBAXCI6IFwiRMOpdGVybWluZSBzaSBzZXVsIGxlIHJhc3RlciBk4oCZYWxsb2NhdGlvbiBlc3QgY3LDqcOpIG91IHNpIHVuIHJhc3RlciBtdWx0aWJhbmRlIGVzdCDDqWdhbGVtZW50IGNyw6nDqS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fc291cmNlcm93YW5kY29sdW1uYmFuZHNfdGFnMUBAXCI6IFwiRMOpc2FjdGl2w6kgOiBsZSByw6lzdWx0YXQgZXN0IGxlIHJhc3RlciBk4oCZYWxsb2NhdGlvbiBkZSBkaXN0YW5jZS4gSWwgc+KAmWFnaXQgZOKAmXVuIHLDqXN1bHRhdCDDoCB1bmUgc2V1bGUgYmFuZGUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3NvdXJjZXJvd2FuZGNvbHVtbmJhbmRzX3RhZzJAQFwiOiBcIkFjdGl2w6kgOiB1biByYXN0ZXIgbXVsdGliYW5kZSBlc3QgY3LDqcOpLiBMYSBwcmVtacOocmUgYmFuZGUgZXN0IGxlIHJhc3RlciBk4oCZYWxsb2NhdGlvbiBkZSBkaXN0YW5jZSwgbGEgc2Vjb25kZSBjb250aWVudCB1biBpbmRleCBkZSBsaWduZXMsIGV0IGxhIHRyb2lzacOobWUgYmFuZGUgY29udGllbnQgdW4gaW5kZXggZGUgY29sb25uZXMuIENlcyBpbmRleCBpZGVudGlmaWVudCBs4oCZZW1wbGFjZW1lbnQgZGUgbGEgY2VsbHVsZSBzb3VyY2UgcXVpIHNlIHRyb3V2ZSDDoCBsYSBkaXN0YW5jZSBkZSBwbHVzIGZhaWJsZSBjb8O7dCBjdW11bMOpLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zdXJmYWNlcmFzdGVyX3RhZzBAQFwiOiBcIlJhc3RlciBkw6lmaW5pc3NhbnQgbGVzIHZhbGV1cnMgZOKAmcOpbMOpdmF0aW9uIMOgIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zdXJmYWNlcmFzdGVyX3RhZzFAQFwiOiBcIkNlcyB2YWxldXJzIHBlcm1ldHRlbnQgZGUgY2FsY3VsZXIgbGEgZGlzdGFuY2UgZGUgc3VyZmFjZSByw6llbGxlIHF1aSBlc3QgY291dmVydGUgbG9ycyBkdSBwYXNzYWdlIGTigJl1bmUgY2VsbHVsZSDDoCB1bmUgYXV0cmUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3RyYXZlbGRpcmVjdGlvbl90YWcwQEBcIjogXCJEw6lmaW5pdCBsZSBzZW5zIGR1IHZveWFnZXVyIGVuIGNhcyBk4oCZYXBwbGljYXRpb24gZHUgZmFjdGV1ciB2ZXJ0aWNhbCwgZHUgZmFjdGV1ciBob3Jpem9udGFsIGV0IGR1IHRhdXggZGUgcsOpc2lzdGFuY2Ugc291cmNlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl90cmF2ZWxkaXJlY3Rpb25fdGFnMUBAXCI6IFwiPHN0cm9uZz7DgCBwYXJ0aXIgZGUgbGEgc291cmNlPC9zdHJvbmc+IDogbGUgZmFjdGV1ciB2ZXJ0aWNhbCwgbGUgZmFjdGV1ciBob3Jpem9udGFsIGV0IGxlIHRhdXggZGUgcsOpc2lzdGFuY2Ugc291cmNlIHNvbnQgYXBwbGlxdcOpcyDDoCBwYXJ0aXIgZGUgbGEgc291cmNlIGVuIGVudHLDqWUgZXQgZW4gc2UgZMOpcGxhw6dhbnQgdmVycyBsZXMgY2VsbHVsZXMgbm9uIHNvdXJjZXMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3RyYXZlbGRpcmVjdGlvbl90YWcyQEBcIjogXCI8c3Ryb25nPlZlcnMgbGEgc291cmNlPC9zdHJvbmc+IDogbGUgZmFjdGV1ciB2ZXJ0aWNhbCwgbGUgZmFjdGV1ciBob3Jpem9udGFsIGV0IGxlIHRhdXggZGUgcsOpc2lzdGFuY2Ugc291cmNlIHNvbnQgYXBwbGlxdcOpcyDDoCBwYXJ0aXIgZGUgY2hhcXVlIGNlbGx1bGUgbm9uIHNvdXJjZSBldCBsb3JzIGR1IHJldG91ciDDoCBsYSBzb3VyY2UgZW4gZW50csOpZS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fdHJhdmVsZGlyZWN0aW9uX3RhZzNAQFwiOiBcIlNww6ljaWZpZXogbGUgbW90LWNsw6kgPHN0cm9uZz7DgCBwYXJ0aXIgZGUgbGEgc291cmNlPC9zdHJvbmc+IG91IDxzdHJvbmc+VmVycyBsYSBzb3VyY2U8L3N0cm9uZz4sIHF1aSBlc3QgYXBwbGlxdcOpIMOgIHRvdXRlcyBsZXMgc291cmNlcywgb3Ugc3DDqWNpZmlleiB1biBjaGFtcCBkYW5zIGxlIDxzdHJvbmc+UmFzdGVyIHNvdXJjZTwvc3Ryb25nPiBxdWkgY29udGllbnQgbGVzIG1vdHMtY2zDqXMgcGVybWV0dGFudCBk4oCZaWRlbnRpZmllciBsZSBzZW5zIGRlIGTDqXBsYWNlbWVudCBwb3VyIGNoYXF1ZSBzb3VyY2UuIENlIGNoYW1wIGRvaXQgY29udGVuaXIgbGEgY2hhw65uZSAke0ZST01fU09VUkNFfSBvdSAke1RPX1NPVVJDRX0uXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3ZlcnRpY2FsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkTDqWZpbml0IGxhIHJlbGF0aW9uIGVudHJlIGxlIGZhY3RldXIgZGUgY2/Du3QgdmVydGljYWwgZXQgbOKAmWFuZ2xlIGRlIGTDqXBsYWNlbWVudCByZWxhdGlmIHZlcnRpY2FsIChWUk1BKS48L3A+PHA+UGx1c2lldXJzIGZhY3RldXJzLCBhdmVjIG1vZGlmaWNhdGV1cnMsIGlkZW50aWZpZW50IHVuIGRpYWdyYW1tZSBkZSBmYWN0ZXVycyB2ZXJ0aWNhdXggZMOpZmluaS4gRW4gb3V0cmUsIHZvdXMgcG91dmV6IHV0aWxpc2VyIHVuZSB0YWJsZSBwb3VyIGNyw6llciB1biBkaWFncmFtbWUgcGVyc29ubmFsaXPDqS4gTGVzIGRpYWdyYW1tZXMgcGVybWV0dGVudCBk4oCZaWRlbnRpZmllciBsZSBmYWN0ZXVyIHZlcnRpY2FsIHV0aWxpc8OpIHBvdXIgbGUgY2FsY3VsIGR1IGNvw7t0IHRvdGFsIGTigJl1biBkw6lwbGFjZW1lbnQgdmVycyB1bmUgY2VsbHVsZSB2b2lzaW5lLjwvcD48cD5EYW5zIGxlcyBleHBsaWNhdGlvbnMgY2ktZGVzc291cywgZGV1eCBhY3JvbnltZXMgc29udCB1dGlsaXPDqXPCoDogVkYgZXQgVlJNQS4gTGUgZmFjdGV1ciBWRiBjb3JyZXNwb25kIGF1IGZhY3RldXIgdmVydGljYWwsIGxlcXVlbCByZXByw6lzZW50ZSBsYSBkaWZmaWN1bHTDqSB2ZXJ0aWNhbGUgcmVuY29udHLDqWUgbG9ycyBk4oCZdW4gZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSB2ZXJzIGxhIHN1aXZhbnRlLiBM4oCZYW5nbGUgVlJNQSBjb3JyZXNwb25kIMOgIGzigJlhbmdsZSBkZSBkw6lwbGFjZW1lbnQgcmVsYXRpZiB2ZXJ0aWNhbCwgbGVxdWVsIHJlcHLDqXNlbnRlIGzigJlhbmdsZSBkZSBsYSBwZW50ZSBlbnRyZSBsYSBjZWxsdWxlIEZST00gKE9yaWdpbmUpLCBvdSBkZSB0cmFpdGVtZW50LCBldCBsYSBjZWxsdWxlIFRPIChEZXN0aW5hdGlvbikuPC9wPjxwPkxlcyB0eXBlcyBkZSA8c3Ryb25nPkZhY3RldXIgdmVydGljYWw8L3N0cm9uZz4gc29udCBsZXMgc3VpdmFudHPCoDo8L3A+PHVsPjxsaT48c3Ryb25nPkJpbmFpcmU8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBzaSBs4oCZYW5nbGUgVlJNQSBlc3Qgc3Vww6lyaWV1ciDDoCBs4oCZYW5nbGUgZOKAmWluZmxleGlvbiBpbmbDqXJpZXVyIGV0IGluZsOpcmlldXIgw6AgbOKAmWFuZ2xlIGTigJlpbmZsZXhpb24gc3Vww6lyaWV1ciwgbGUgZmFjdGV1ciBWRiBkb2l0IGNvcnJlc3BvbmRyZSDDoCBsYSB2YWxldXIgYXNzb2Npw6llIGF1IGZhY3RldXIgesOpcm8uIERhbnMgbGUgY2FzIGNvbnRyYWlyZSwgbGUgZmFjdGV1ciB2ZXJ0aWNhbCBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPkxpbsOpYWlyZTwvc3Ryb25nPsKgOiBpbmRpcXVlIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gbGluw6lhaXJlIGRlIGzigJlhbmdsZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlIHN5bcOpdHJpcXVlPC9zdHJvbmc+wqA6IHNww6ljaWZpZSBxdWUgbGUgZmFjdGV1ciBWRiBlc3QgdW5lIGZvbmN0aW9uIGxpbsOpYWlyZSBkZSBs4oCZYW5nbGUgVlJNQSwgZHUgY8O0dMOpIG7DqWdhdGlmIG91IGR1IGPDtHTDqSBwb3NpdGlmIGRlIGzigJlhbmdsZSBWUk1BLCByZXNwZWN0aXZlbWVudCwgZXQgcXVlIGxlcyBkZXV4IGZvbmN0aW9ucyBsaW7DqWFpcmVzIHNvbnQgc3ltw6l0cmlxdWVzIHBhciByYXBwb3J0IMOgIGzigJlheGUgKHkpIGR1IGZhY3RldXIgVkYuPC9saT48bGk+PHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZTwvc3Ryb25nPsKgOiBpbmRpcXVlIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gbGluw6lhaXJlIGludmVyc2UgZGUgbOKAmWFuZ2xlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZSBzeW3DqXRyaXF1ZTwvc3Ryb25nPsKgOiBzcMOpY2lmaWUgcXVlIGxlIGZhY3RldXIgVkYgZXN0IHVuZSBmb25jdGlvbiBsaW7DqWFpcmUgaW52ZXJzZSBkZSBs4oCZYW5nbGUgVlJNQSwgZHUgY8O0dMOpIG7DqWdhdGlmIG91IGR1IGPDtHTDqSBwb3NpdGlmIGRlIGzigJlhbmdsZSBWUk1BLCByZXNwZWN0aXZlbWVudCwgZXQgcXVlIGxlcyBkZXV4IGZvbmN0aW9ucyBsaW7DqWFpcmVzIHNvbnQgc3ltw6l0cmlxdWVzIHBhciByYXBwb3J0IMOgIGzigJlheGUgKHkpIGR1IGZhY3RldXIgVkYuPC9saT48bGk+PHN0cm9uZz5Db3M8L3N0cm9uZz7CoDogaWRlbnRpZmllIGxlIGZhY3RldXIgVkYgY29tbWUgdW5lIGZvbmN0aW9uIGNvc2ludXNvw69kYWxlIGRlIGzigJlhbmdsZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+U2VjPC9zdHJvbmc+wqA6IGlkZW50aWZpZSBsZSBmYWN0ZXVyIFZGIGNvbW1lIHVuZSBmb25jdGlvbiBzw6ljYW50ZSBkZSBs4oCZYW5nbGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPkNvcy1TZWM8L3N0cm9uZz7CoDogc3DDqWNpZmllIHF1ZSBsZSBmYWN0ZXVyIFZGIGVzdCB1bmUgZm9uY3Rpb24gY29zaW51c2/Dr2RhbGUgZGUgbOKAmWFuZ2xlIFZSTUEgbG9yc3F1ZSBjZSBkZXJuaWVyIGVzdCBuw6lnYXRpZiBldCBxdeKAmWlsIGVzdCB1bmUgZm9uY3Rpb24gc8OpY2FudGUgZGUgbOKAmWFuZ2xlIFZSTUEgbG9yc3F1ZSBjZSBkZXJuaWVyIG7igJllc3QgcGFzIG7DqWdhdGlmLjwvbGk+PGxpPjxzdHJvbmc+U2VjLUNvczwvc3Ryb25nPsKgOiBzcMOpY2lmaWUgcXVlIGxlIGZhY3RldXIgVkYgZXN0IHVuZSBmb25jdGlvbiBzw6ljYW50ZSBkZSBs4oCZYW5nbGUgVlJNQSBsb3JzcXVlIGNlIGRlcm5pZXIgZXN0IG7DqWdhdGlmIGV0IHF14oCZaWwgZXN0IHVuZSBmb25jdGlvbiBjb3NpbnVzb8OvZGFsZSBkZSBs4oCZYW5nbGUgVlJNQSBsb3JzcXVlIGNlIGRlcm5pZXIgbuKAmWVzdCBwYXMgbsOpZ2F0aWYuPC9saT48bGk+PHN0cm9uZz5UYWJsZTwvc3Ryb25nPsKgOiBpbmRpcXVlIHF14oCZdW4gZmljaGllciBkZSB0YWJsZSBzZXJhIHV0aWxpc8OpIHBvdXIgZMOpZmluaXIgbGUgZGlhZ3JhbW1lIGRlcyBmYWN0ZXVycyB2ZXJ0aWNhdXggcGVybWV0dGFudCBkZSBkw6l0ZXJtaW5lciBsZXMgZmFjdGV1cnMgVkYuPC9saT48L3VsPjxwPkxlcyBtb2RpZmljYXRldXJzIGRlcyBtb3RzLWNsw6lzIGRlIGZhY3RldXIgdmVydGljYWwgc29udCBsZXMgc3VpdmFudHPCoDo8L3A+PHVsPjxsaT48c3Ryb25nPkZhY3RldXIgesOpcm88L3N0cm9uZz7CoDogZMOpZmluaXQgbGUgZmFjdGV1ciB2ZXJ0aWNhbCB1dGlsaXPDqSBsb3JzcXVlIGzigJlhbmdsZSBWUk1BIGVzdCBudWwuIENlIGZhY3RldXIgcG9zaXRpb25uZSBs4oCZaW50ZXJzZWN0aW9uIGF2ZWMgbOKAmWF4ZSBkZXMgeSBkZSBsYSBmb25jdGlvbiBzcMOpY2lmacOpZS4gUGFyIGTDqWZpbml0aW9uLCBsZSBmYWN0ZXVyIHrDqXJvIG5lIHPigJlhcHBsaXF1ZSDDoCBhdWN1bmUgZm9uY3Rpb24gdmVydGljYWxlIHRyaWdvbm9tw6l0cmlxdWUgKENPUywgU0VDLCBDT1MtU0VDIG91IFNFQy1DT1MpLiBDZXMgZm9uY3Rpb25zIGTDqWZpbmlzc2VudCBs4oCZaW50ZXJjZXB0aW9uIGRlIGzigJlheGUgZGVzIHkuPC9saT48bGk+PHN0cm9uZz5BbmdsZSBk4oCZaW5mbGV4aW9uIGluZsOpcmlldXI8L3N0cm9uZz7CoDogZMOpZmluaXQgbOKAmWFuZ2xlIFZSTUEgZW4gZGVzc291cyBkdXF1ZWwgbGUgZmFjdGV1ciBWRiBhIHVuZSB2YWxldXIgaW5maW5pZS48L2xpPjxsaT48c3Ryb25nPkFuZ2xlIGTigJlpbmZsZXhpb24gc3Vww6lyaWV1cjwvc3Ryb25nPsKgOiBkw6lmaW5pdCBs4oCZYW5nbGUgVlJNQSBhdS1kZXNzdXMgZHVxdWVsIGxlIGZhY3RldXLCoFZGIGEgdW5lIHZhbGV1ciBpbmZpbmllLjwvbGk+PGxpPjxzdHJvbmc+UGVudGU8L3N0cm9uZz7CoDogZMOpZmluaXQgbGEgcGVudGUgZGUgbGEgbGlnbmUgZHJvaXRlIHV0aWxpc8OpZSBhdmVjIGxlcyBtb3RzLWNsw6lzIGRlIGZhY3RldXIgdmVydGljYWwgPHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz4gZXQgPHN0cm9uZz5MaW7DqWFpcmUgaW52ZXJzZTwvc3Ryb25nPi4gTGEgcGVudGUgZXN0IHNww6ljaWZpw6llIHNvdXMgZm9ybWUgZOKAmXVuIHJhcHBvcnQgZGUgbGEgaGF1dGV1ciBzdXIgbGEgZGlzdGFuY2UgcGFyY291cnVlIChwYXIgZXhlbXBsZSwgdW5lIHBlbnRlIGRlIDQ1wqBwb3VyIGNlbnQgY29ycmVzcG9uZCDDoMKgMS80NSwgbGEgdmFsZXVyIGludHJvZHVpdGUgw6l0YW50wqAwLDAyMjIyKS48L2xpPjxsaT48c3Ryb25nPk5vbSBkZSBsYSB0YWJsZTwvc3Ryb25nPsKgOiBjb3JyZXNwb25kIGF1IG5vbSBkZSBsYSB0YWJsZSBkw6lmaW5pc3NhbnQgbGUgZmFjdGV1ciBWRi48L2xpPjwvdWw+XCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3ZlcnRpY2FscmFzdGVyX3RhZzBAQFwiOiBcIkTDqWZpbml0IGxhIHJlbGF0aW9uIGVudHJlIGxlIGZhY3RldXIgZGUgY2/Du3QgdmVydGljYWwgZXQgbOKAmWFuZ2xlIGRlIGTDqXBsYWNlbWVudCByZWxhdGlmIHZlcnRpY2FsIChWUk1BKS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fdmVydGljYWxyYXN0ZXJfdGFnMUBAXCI6IFwiQ2VzIHZhbGV1cnMgcGVybWV0dGVudCBkZSBjYWxjdWxlciBsYSBwZW50ZSB1dGlsaXPDqWUgcG91ciBpZGVudGlmaWVyIGxlIGZhY3RldXIgdmVydGljYWwgYXNzb2Npw6kgYXUgZMOpcGxhY2VtZW50IGTigJl1bmUgY2VsbHVsZSDDoCB1bmUgYXV0cmUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fY2VsbHNpemVfdGFnMEBAXCI6IFwiVGFpbGxlIGRlIGNlbGx1bGUgcXVpIHNlcmEgdXRpbGlzw6llIHBvdXIgbGEgY3LDqWF0aW9uIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fY2VsbHNpemVfdGFnMUBAXCI6IFwiU2kgbGEgdGFpbGxlIGRlIGNlbGx1bGUgYSDDqXTDqSBleHBsaWNpdGVtZW50IGTDqWZpbmllIGRhbnMgPHN0cm9uZz5FbnZpcm9ubmVtZW50czwvc3Ryb25nPiwgaWwgc+KAmWFnaXQgZGUgbGEgdGFpbGxlIGRlIGNlbGx1bGUgcGFyIGTDqWZhdXQuIFNpIGVsbGUgbuKAmWEgcGFzIMOpdMOpIGTDqWZpbmllLCBsYSB0YWlsbGUgZGUgY2VsbHVsZSBlbiBzb3J0aWUgZXN0IGlkZW50aXF1ZSDDoCBjZWxsZSBkdSA8c3Ryb25nPlJhc3RlciBzb3VyY2U8L3N0cm9uZz4uXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fZGlzdGFuY2VtZXRob2RfdGFnMEBAXCI6IFwiRMOpdGVybWluZSBzaSBsYSBkaXN0YW5jZSBkb2l0IMOqdHJlIGNhbGN1bMOpZSBhdmVjIHVuZSBtw6l0aG9kZSBwbGFuZSAoVGVycmUgcGxhdGUpIG91IGfDqW9kw6lzaXF1ZSAoZWxsaXBzb8OvZGUpLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzFAQFwiOiBcIlBsYW5lIDogbGVzIG1lc3VyZXMgcGxhbmVzIHV0aWxpc2VudCBkZXMgbWF0aMOpbWF0aXF1ZXMgY2FydMOpc2llbm5lcyBlbiAyRCBwb3VyIGNhbGN1bGVyIGxhIGxvbmd1ZXVyIGV0IGxhIHN1cmZhY2UuIENldHRlIG9wdGlvbiBlc3QgdW5pcXVlbWVudCBkaXNwb25pYmxlIGxvcnNxdWUgbGVzIG1lc3VyZXMgc29udCBlZmZlY3R1w6llcyBkYW5zIHVuIHN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBwcm9qZXTDqWVzLiBMZSBwbGFuIDJEIGRlIGNlIHN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBlc3QgYWxvcnMgdXRpbGlzw6kgY29tbWUgYmFzZSBkZXMgbWVzdXJlcy5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9kaXN0YW5jZW1ldGhvZF90YWcyQEBcIjogXCJHw6lvZMOpc2lxdWUgOiBsaWduZSBsYSBwbHVzIGNvdXJ0ZSBlbnRyZSBkZXV4IHBvaW50cyBkZSBsYSBzdXJmYWNlIGRlIGxhIFRlcnJlIHN1ciB1biBzcGjDqXJvw69kZSAoZWxsaXBzb8OvZGUpLiBMZXMgcsOpc3VsdGF0cyBuZSBjaGFuZ2VudCBkb25jIHBhcyBxdWVsbGUgcXVlIHNvaXQgbGEgcHJvamVjdGlvbiBlbiBlbnRyw6llIG91IGVuIHNvcnRpZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9kaXN0YW5jZW1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPlJlbWFycXVlIDo8L3N0cm9uZz4gdm91cyBwb3V2ZXogdXRpbGlzZXIgdW5lIGxpZ25lIGfDqW9kw6lzaXF1ZSBzaSB2b3VzIHNvdWhhaXRleiBkw6l0ZXJtaW5lciBsYSBkaXN0YW5jZSBsYSBwbHVzIGNvdXJ0ZSBlbnRyZSBkZXV4IHZpbGxlcyBwb3VyIGxhIHRyYWplY3RvaXJlIGRlIHZvbCBk4oCZdW4gYXZpb24uIE9uIHBhcmxlIMOpZ2FsZW1lbnQgZGUgwqsgbGlnbmUgb3J0aG9kcm9taXF1ZSDCuyBzaSBlbGxlIHJlcG9zZSBzdXIgdW5lIHNwaMOocmUgcGx1dMO0dCBxdWUgc3VyIHVuIGVsbGlwc2/Dr2RlLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX21heGltdW1kaXN0YW5jZV90YWcwQEBcIjogXCJEw6lmaW5pdCBsYSBkaXN0YW5jZSBkZSBzZXVpbCBwcmlzZSBlbiBjb21wdGUgcG91ciBjYWxjdWxlciBsYSBkaXJlY3Rpb24gcGFyIHJhcHBvcnQgw6AgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlLiBTaSBsYSBkaXN0YW5jZSBwYXIgcmFwcG9ydCDDoCBsYSBzb3VyY2UgbGEgcGx1cyBwcm9jaGUgZMOpcGFzc2UgY2Ugc2V1aWwsIGxhIHNvcnRpZSBkZSBjZXR0ZSBjZWxsdWxlIHByZW5kIGxhIHZhbGV1ciBOb0RhdGEuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fbWF4aW11bWRpc3RhbmNlX3RhZzFAQFwiOiBcIkxhIGRpc3RhbmNlIHBhciBkw6lmYXV0IHZhIGp1c3F14oCZw6AgbOKAmcOpdGVuZHVlIGR1IHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fcmFzdGVyYmFycmllcnNfdGFnMEBAXCI6IFwiUmFzdGVyIHF1aSBkw6lmaW5pdCBsZXMgaW50ZXJydXB0aW9ucy5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9yYXN0ZXJiYXJyaWVyc190YWcxQEBcIjogXCJMZSBqZXUgZGUgZG9ubsOpZXMgZG9pdCBjb250ZW5pciB1bmUgdmFsZXVyIE5vRGF0YSBsb3JzcXXigJlpbCBu4oCZeSBhIHBhcyBk4oCZaW50ZXJydXB0aW9uLiBMZXMgaW50ZXJydXB0aW9ucyBzb250IHJlcHLDqXNlbnTDqWVzIHBhciBkZXMgdmFsZXVycyB2YWxpZGVzLCB5IGNvbXByaXMgesOpcm8uXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fcmFzdGVyYmFycmllcnNfdGFnMkBAXCI6IFwiTGVzIGludGVycnVwdGlvbnMgcGV1dmVudCDDqnRyZSBkw6lmaW5pZXMgcGFyIHVuIHJhc3RlciBkZSB0eXBlIGVudGllciBvdSDDoCB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9zb3VyY2VyYXN0ZXJfdGFnMEBAXCI6IFwiSmV1IGRlIGRvbm7DqWVzIHJhc3RlciBxdWkgaWRlbnRpZmllIGxlcyBjZWxsdWxlcyBvdSBsZXMgZW1wbGFjZW1lbnRzIHBhciByYXBwb3J0IGF1eHF1ZWxzIGxhIGRpcmVjdGlvbiBldWNsaWRpZW5uZSBwb3VyIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBjZWxsdWxlIGVuIHNvcnRpZSBlc3QgY2FsY3Vsw6llLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX3NvdXJjZXJhc3Rlcl90YWcxQEBcIjogXCJMZSByYXN0ZXIgZW4gZW50csOpZSBwZXV0IMOqdHJlIGRlIHR5cGUgZW50aWVyIG91IMOgIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcIkBAQ29zdC1QYXRoX2Nvc3RiYWNrbGlua3Jhc3Rlcl90YWcwQEBcIjogXCJOb20gZGUgbGEgY291Y2hlIHJhc3RlciBk4oCZYW50w6ljw6lkZW5jZSBkZSBjb8O7dCB1dGlsaXPDqWUgcG91ciBkw6l0ZXJtaW5lciBsZSBjaGVtaW4gcGVybWV0dGFudCBkZSByZXZlbmlyIHZlcnMgdW5lIHNvdXJjZSB2aWEgbGUgY2hlbWluIGRlIG1vaW5kcmUgY2/Du3QuXCIsXG5cdFwiQEBDb3N0LVBhdGhfY29zdGJhY2tsaW5rcmFzdGVyX3RhZzFAQFwiOiBcIlBvdXIgY2hhcXVlIGNlbGx1bGUgZGFucyBsZSByYXN0ZXIgZOKAmWFudMOpY8OpZGVuY2UsIHVuZSB2YWxldXIgaWRlbnRpZmllIGxlIHZvaXNpbiwgw6Agc2F2b2lyIGxhIGNlbGx1bGUgc3VpdmFudGUgc3VyIGxlIGNoZW1pbiBkZSBtb2luZHJlIGNvw7t0IGN1bXVsw6kgw6AgcGFydGlyIGRlIGxhIGNlbGx1bGUgdmVycyB1bmUgc2V1bGUgY2VsbHVsZSBzb3VyY2Ugb3UgdW4gamV1IGRlIGNlbGx1bGVzIHNvdXJjZXMuXCIsXG5cdFwiQEBDb3N0LVBhdGhfY29zdGRpc3RhbmNlcmFzdGVyX3RhZzBAQFwiOiBcIk5vbSBkdSByYXN0ZXIgZGUgZGlzdGFuY2UgZGUgY2/Du3Qgw6AgdXRpbGlzZXIgcG91ciBkw6l0ZXJtaW5lciBsZSBjaGVtaW4gZGUgbW9pbmRyZSBjb8O7dCDDoCBwYXJ0aXIgZGVzIGVtcGxhY2VtZW50cyBjaWJsZXMgdmVycyB1bmUgc291cmNlLlwiLFxuXHRcIkBAQ29zdC1QYXRoX2Nvc3RkaXN0YW5jZXJhc3Rlcl90YWcxQEBcIjogXCJFbiBnw6luw6lyYWwsIHZvdXMgcG91dmV6IGNyw6llciB1biByYXN0ZXIgZGUgZGlzdGFuY2UgZGUgY2/Du3QgZ3LDomNlIGF1eCBmb25jdGlvbnMgRGlzdGFuY2UgZGUgY2/Du3QsIEFsbG9jYXRpb24gZGUgY2/Du3Qgb3UgQW50w6ljw6lkZW5jZSBkZSBjb8O7dC4gTGEgY291Y2hlIHJhc3RlciBkZSBkaXN0YW5jZSBkZSBjb8O7dCBzdG9ja2UsIHBvdXIgY2hhcXVlIGNlbGx1bGUsIGxhIGRpc3RhbmNlIGRlIGNvw7t0IGN1bXVsw6kgbWluaW1hbGUgc3VyIHVuZSBzdXJmYWNlIGRlIGNvw7t0IMOgIHBhcnRpciBkZSBjaGFxdWUgY2VsbHVsZSB2ZXJzIHVuIGVuc2VtYmxlIGRlIGNlbGx1bGVzIHNvdXJjZXMuXCIsXG5cdFwiQEBDb3N0LVBhdGhfZGVzdGluYXRpb25maWVsZF90YWcwQEBcIjogXCJDaGFtcCBwZXJtZXR0YW50IGTigJlvYnRlbmlyIGRlcyB2YWxldXJzIHBvdXIgbGVzIGVtcGxhY2VtZW50cyBkZSBkZXN0aW5hdGlvbi4gTGVzIGRvbm7DqWVzIGTigJllbnRpdMOpcyBlbiBlbnRyw6llIGRvaXZlbnQgY29udGVuaXIgYXUgbW9pbnMgdW4gY2hhbXAgYXV0b3Jpc8OpLlwiLFxuXHRcIkBAQ29zdC1QYXRoX2Rlc3RpbmF0aW9ucmFzdGVyX3RhZzBAQFwiOiBcIkNvdWNoZSBkZSBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIGlkZW50aWZpYW50IGxlcyBjZWxsdWxlcyDDoCBwYXJ0aXIgZGVzcXVlbGxlcyBsZSBjaGVtaW4gZGUgbW9pbmRyZSBjb8O7dCBlc3QgZMOpdGVybWluw6kgcGFyIHJhcHBvcnQgw6AgbGEgc291cmNlIGRlIG1vaW5kcmUgY2/Du3QuXCIsXG5cdFwiQEBDb3N0LVBhdGhfZGVzdGluYXRpb25yYXN0ZXJfdGFnMUBAXCI6IFwiTGEgY291Y2hlIHJhc3RlciBlbiBlbnRyw6llIGNvbXBvcnRlIGRlcyBjZWxsdWxlcyBxdWkgb250IGRlcyB2YWxldXJzIHZhbGlkZXMgKHrDqXJvIGVzdCB1bmUgdmFsZXVyIHZhbGlkZSkgZXQgbGVzIGNlbGx1bGVzIHJlc3RhbnRlcyBkb2l2ZW50IGF2b2lyIGxhIHZhbGV1ciBOb0RhdGEuXCIsXG5cdFwiQEBDb3N0LVBhdGhfZm9yY2VmbG93ZGlyZWN0aW9uY29udmVudGlvbmZvcmJhY2tsaW5rcmFzdGVyX3RhZzBAQFwiOiBcIk9ibGlnZSBsYSBmb25jdGlvbiDDoCB0cmFpdGVyIGxlIHJhc3RlciBk4oCZYW50w6ljw6lkZW5jZSBlbiBlbnRyw6llIGNvbW1lIHVuIHJhc3RlciBkZSBzZW5zIGRlIGNpcmN1bGF0aW9uLiBMZXMgdmFsZXVycyBkZXMgcmFzdGVycyBkZSBzZW5zIGRlIGNpcmN1bGF0aW9uIHBldXZlbnQgw6p0cmUgZGVzIGVudGllcnMgY29tcHJpcyBlbnRyZSAwIGV0IDI1NS5cIixcblx0XCJAQENvc3QtUGF0aF9mb3JjZWZsb3dkaXJlY3Rpb25jb252ZW50aW9uZm9yYmFja2xpbmtyYXN0ZXJfdGFnMUBAXCI6IFwiRMOpc2FjdGl2w6kgOiBzaSBsZXMgdmFsZXVycyBkdSByYXN0ZXIgZOKAmWFudMOpY8OpZGVuY2Ugc3DDqWNpZmnDqSBzb250IGRlcyBlbnRpZXJzIGNvbXByaXMgZW50cmUgMCBldCA4LCBsZSBqZXUgZGUgZG9ubsOpZXMgZXN0IHRyYWl0w6kgY29tbWUgdW4gcmFzdGVyIGTigJlhbnTDqWPDqWRlbmNlIGRlIGNvw7t0LiBTaSBsZXMgdmFsZXVycyBzb250IGNvbXByaXNlcyBlbnRyZSAwIGV0IDI1NSwgbOKAmWVudHLDqWUgZXN0IHRyYWl0w6llIGNvbW1lIHVuIHJhc3RlciBkZSBzZW5zIGRlIGNpcmN1bGF0aW9uLiBTaSBsZXMgdmFsZXVycyBzb250IGNvbXByaXNlcyBlbnRyZSAwIGV0IDM2MCBhdmVjIHVuZSB2aXJndWxlIGZsb3R0YW50ZSwgbOKAmWVudHLDqWUgZXN0IHRyYWl0w6llIGNvbW1lIHVuIHJhc3RlciBkZSBkaXJlY3Rpb24gYXJyacOocmUuXCIsXG5cdFwiQEBDb3N0LVBhdGhfZm9yY2VmbG93ZGlyZWN0aW9uY29udmVudGlvbmZvcmJhY2tsaW5rcmFzdGVyX3RhZzJAQFwiOiBcIkFjdGl2w6kgOiBsZSByYXN0ZXIgZm91cm5pIHBvdXIgbGUgcmFzdGVyIGTigJlhbnTDqWPDqWRlbmNlIGVzdCB0cmFpdMOpIGNvbW1lIHVuIHJhc3RlciBkZSBzZW5zIGRlIGNpcmN1bGF0aW9uLiBVdGlsaXNleiBjZXR0ZSBvcHRpb24gc2kgbGUgcmFzdGVyIGRlIHNlbnMgZGUgY2lyY3VsYXRpb24gcG9zc8OoZGUgdW5lIHZhbGV1ciBtYXhpbWFsZSBpbmbDqXJpZXVyZSBvdSDDqWdhbGUgw6AgOC5cIixcblx0XCJAQENvc3QtUGF0aF9wYXRodHlwZV90YWcwQEBcIjogXCJNb3QtY2zDqSBkw6lmaW5pc3NhbnQgbGEgZmHDp29uIGRvbnQgbGVzIHZhbGV1cnMgZXQgbGVzIHpvbmVzIGRlcyBkb25uw6llcyBkZSBkZXN0aW5hdGlvbiBlbiBlbnRyw6llIHNvbnQgaW50ZXJwcsOpdMOpZXMgZGFucyBsZXMgY2FsY3VscyBkdSBjaGVtaW4gZGUgY2/Du3QuIExlcyBvcHRpb25zIHNvbnQgbGVzIHN1aXZhbnRlcyA6XCIsXG5cdFwiQEBDb3N0LVBhdGhfcGF0aHR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5DaGFxdWUgY2VsbHVsZTwvc3Ryb25nPiA6IHBvdXIgY2hhcXVlIGNlbGx1bGUgY29udGVuYW50IGRlcyB2YWxldXJzIHZhbGlkZXMgZGUgZG9ubsOpZXMgZGUgZGVzdGluYXRpb24gZW4gZW50csOpZSwgdW4gY2hlbWluIGRlIG1vaW5kcmUgY2/Du3QgZXN0IGTDqXRlcm1pbsOpIGV0IGVucmVnaXN0csOpIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gQXZlYyBjZXR0ZSBvcHRpb24sIGNoYXF1ZSBjZWxsdWxlIGRlcyBkb25uw6llcyBkZSBkZXN0aW5hdGlvbiBlbiBlbnRyw6llIGVzdCB0cmFpdMOpZSBzw6lwYXLDqW1lbnQgZXQgdW4gY2hlbWluIGRlIG1vaW5kcmUgY2/Du3QgZXN0IGTDqXRlcm1pbsOpIHBvdXIgY2hhcXVlIGNlbGx1bGUuXCIsXG5cdFwiQEBDb3N0LVBhdGhfcGF0aHR5cGVfdGFnMkBAXCI6IFwiPHN0cm9uZz5DaGFxdWUgem9uZTwvc3Ryb25nPiA6IHBvdXIgY2hhcXVlIHpvbmUgZGVzIGRvbm7DqWVzIGRlIGRlc3RpbmF0aW9uIGVuIGVudHLDqWUsIHVuIGNoZW1pbiBkZSBtb2luZHJlIGNvw7t0IGVzdCBkw6l0ZXJtaW7DqSBldCBlbnJlZ2lzdHLDqSBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIEF2ZWMgY2V0dGUgb3B0aW9uLCBwb3VyIGNoYXF1ZSB6b25lLCBsZSBjaGVtaW4gZGUgbW9pbmRyZSBjb8O7dCBjb21tZW5jZSDDoCBsYSBjZWxsdWxlIGF2ZWMgbGEgcG9uZMOpcmF0aW9uIGRlIGRpc3RhbmNlIGRlIHBsdXMgZmFpYmxlIGNvw7t0IGRhbnMgbGEgem9uZS5cIixcblx0XCJAQENvc3QtUGF0aF9wYXRodHlwZV90YWczQEBcIjogXCI8c3Ryb25nPkxlIG1vaW5zIGNvw7t0ZXV4PC9zdHJvbmc+IDogcG91ciB0b3V0ZXMgbGVzIGNlbGx1bGVzIGRlcyBkb25uw6llcyBkZSBkZXN0aW5hdGlvbiBlbiBlbnRyw6llLCBsZSBjaGVtaW4gZHUgbW9pbmRyZSBjb8O7dCBlc3QgZMOpcml2w6kgZGUgbGEgY2VsbHVsZSBjb250ZW5hbnQgbGUgbWluaW11bSBkZSBjaGVtaW5zIGRlIG1vaW5kcmUgY2/Du3QgdmVycyBsZXMgY2VsbHVsZXMgc291cmNlcy5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19jZWxsc2l6ZXR5cGVfdGFnMEBAXCI6IFwiU8OpbGVjdGlvbm5leiBsYSB0YWlsbGUgZGUgY2VsbHVsZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxlcyB0YWlsbGVzIGRlcyBjZWxsdWxlcyBlbiBlbnRyw6llIHNvbnQgaWRlbnRpcXVlcywgdG91dGVzIGxlcyBvcHRpb25zIGRvbm5lbnQgbGVzIG3Dqm1lcyByw6lzdWx0YXRzLlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2NlbGxzaXpldHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBsYSBwcmVtacOocmUgdGFpbGxlIGRlIGNlbGx1bGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19jZWxsc2l6ZXR5cGVfdGFnMkBAXCI6IFwiTWluIGRlIDogdXRpbGlzZSBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfY2VsbHNpemV0eXBlX3RhZzNAQFwiOiBcIk1heCBkZSA6IHV0aWxpc2UgbGEgcGx1cyBncmFuZGUgdGFpbGxlIGRlIGNlbGx1bGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2NlbGxzaXpldHlwZV90YWc0QEBcIjogXCJNb3llbm5lIGRlIDogdXRpbGlzZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBtb3llbm5lIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19jZWxsc2l6ZXR5cGVfdGFnNUBAXCI6IFwiRGVybmllciBkZSA6IHV0aWxpc2UgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfZXh0ZW50dHlwZV90YWcwQEBcIjogXCJTw6lsZWN0aW9ubmV6IGzigJnDqXRlbmR1ZSDDoCB1dGlsaXNlciBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfZXh0ZW50dHlwZV90YWcxQEBcIjogXCJQcmVtaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2V4dGVudHR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGVzIHBpeGVscyBzdXBlcnBvc8OpcyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2V4dGVudHR5cGVfdGFnM0BAXCI6IFwiVW5pb24gZGUgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZSB0b3VzIGxlcyByYXN0ZXJzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfZXh0ZW50dHlwZV90YWc0QEBcIjogXCJEZXJuaWVyIGRlIDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX3Byb2Nlc3Nhc211bHRpYmFuZF90YWcwQEBcIjogXCJEw6l0ZXJtaW5lIGxlIG1vZGUgZGUgdHJhaXRlbWVudCBkZXMgYmFuZGVzIHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX3Byb2Nlc3Nhc211bHRpYmFuZF90YWcxQEBcIjogXCJEw6lzYWN0aXbDqSA6IHRvdXRlcyBsZXMgZW50csOpZXMgbXVsdGliYW5kZXMgc29udCB0cmFpdMOpZXMgY29tbWUgZGVzIGJhbmRlcyBpbmRpdmlkdWVsbGVzLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX3Byb2Nlc3Nhc211bHRpYmFuZF90YWcyQEBcIjogXCJBY3RpdsOpIDogdG91dGVzIGxlcyBlbnRyw6llcyBtdWx0aWJhbmRlcyBzb250IHRyYWl0w6llcyBjb21tZSBkZXMgYmFuZGVzIG11bHRpcGxlcy5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19yYXN0ZXJzX3RhZzBAQFwiOiBcIkxpc3RlIGRlcyByYXN0ZXJzIMOgIHBhcnRpciBkZXNxdWVscyBjYWxjdWxlciBsZXMgc3RhdGlzdGlxdWVzLCBwaXhlbCBwYXIgcGl4ZWwuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfcGVyY2VudGlsZWludGVycG9sYXRpb250eXBlX3RhZzBAQFwiOiBcIjxwPkTDqWZpbml0IGxhIG3DqXRob2RlIGTigJlpbnRlcnBvbGF0aW9uIMOgIHV0aWxpc2VyIGxvcnNxdWUgbGEgdmFsZXVyIGRlIGNlbnRpbGUgc3DDqWNpZmnDqWUgc2Ugc2l0dWUgZW50cmUgZGV1eCB2YWxldXJzIGRlIGNlbGx1bGUgZW4gZW50csOpZS48L3A+PHVsPjxsaT48c3Ryb25nPkTDqXRlY3Rpb24gYXV0b21hdGlxdWU8L3N0cm9uZz7CoDogc2kgbGUgdHlwZSBkZSBwaXhlbCBkZXMgcmFzdGVycyBlbiBlbnRyw6llIGVzdCBlbnRpZXIsIGxhIG3DqXRob2RlIDxzdHJvbmc+TGUgcGx1cyBwcm9jaGU8L3N0cm9uZz4gZXN0IHV0aWxpc8OpZS4gU2kgbGUgcmFzdGVyIGVuIGVudHLDqWUgZXN0IGRlIHR5cGUgZGUgcGl4ZWwgw6AgdmlyZ3VsZSBmbG90dGFudGUsIGxhIG3DqXRob2RlIDxzdHJvbmc+TGluw6lhaXJlPC9zdHJvbmc+IGVzdCB1dGlsaXPDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+PHN0cm9uZz5MZSBwbHVzIHByb2NoZTwvc3Ryb25nPsKgOiBsYSB2YWxldXIgZGlzcG9uaWJsZSBsYSBwbHVzIHByb2NoZSBkdSBjZW50aWxlIHNvdWhhaXTDqSBlc3QgdXRpbGlzw6llLiBEYW5zIGNlIGNhcywgbGUgdHlwZSBkZSBwaXhlbCBlbiBzb3J0aWUgZXN0IGlkZW50aXF1ZSDDoCBjZWx1aSBkdSByYXN0ZXIgZGUgdmFsZXVycyBlbiBlbnRyw6llLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlPC9zdHJvbmc+wqA6IGxhIG1veWVubmUgcG9uZMOpcsOpZSBkZXMgZGV1eCB2YWxldXJzIGVudmlyb25uYW50ZXMgZHUgY2VudGlsZSBzb3VoYWl0w6kgZXN0IHV0aWxpc8OpZS4gRGFucyBjZSBjYXMsIGxlIHR5cGUgZGUgcGl4ZWwgZW4gc29ydGllIGVzdCDDoCB2aXJndWxlIGZsb3R0YW50ZS48L2xpPjwvdWw+PHA+Q2V0dGUgb3B0aW9uIGVzdCBkaXNwb25pYmxlIHVuaXF1ZW1lbnQgc2kgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPk9ww6lyYXRpb248L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+TcOpZGlhbmU8L3N0cm9uZz4gb3UgPHN0cm9uZz5DZW50aWxlPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19wZXJjZW50aWxldmFsdWVfdGFnMEBAXCI6IFwiPHA+Q2VudGlsZSDDoCBjYWxjdWxlci4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCBkZcKgOTAsIHNvaXQgbGUgOTBlwqBjZW50aWxlLjwvcD48cD5MZXMgdmFsZXVycyBwZXV2ZW50IGFsbGVyIGRlwqAwIMOgwqAxMDAuIExlIGNlbnRpbGXCoDAgZXN0IMOpcXVpdmFsZW50IMOgIGxhIHN0YXRpc3RpcXVlIG1pbmltYWxlLCB0YW5kaXMgcXVlIGxlIDEwMGXCoGNlbnRpbGUgw6lxdWl2YXV0IGF1IG1heGltdW0uIFVuZSB2YWxldXIgZGXCoDUwIGRvbm5lIGxlIG3Dqm1lIHLDqXN1bHRhdCBxdWUgbGEgc3RhdGlzdGlxdWUgTcOpZGlhbmUuPC9wPjxwPkNldHRlIG9wdGlvbiBlc3QgZGlzcG9uaWJsZSB1bmlxdWVtZW50IHNpIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5PcMOpcmF0aW9uPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPkNlbnRpbGU8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9iYWNrZGlyZWN0aW9ucmFzdGVyb3JmbG93ZGlyZWN0aW9ucmFzdGVyX3RhZzBAQFwiOiBcIkxlIHJhc3RlciBkZSBkaXJlY3Rpb24gYXJyacOocmUgY29udGllbnQgZGVzIGRpcmVjdGlvbnMgY2FsY3Vsw6llcyBlbiBkZWdyw6lzLiBMYSBkaXJlY3Rpb24gaWRlbnRpZmllIGxhIGNlbGx1bGUgc3VpdmFudGUgc3VyIGxlIGNoZW1pbiBvcHRpbWFsIGRlIHJldG91ciB2ZXJzIGxhIHNvdXJjZSBkZSBwbHVzIGZhaWJsZSBjb8O7dCBjdW11bMOpLCBlbiDDqXZpdGFudCBsZXMgaW50ZXJydXB0aW9ucy5cIixcblx0XCJAQE9wdGltYWwtUGF0aC1Bcy1SYXN0ZXJfYmFja2RpcmVjdGlvbnJhc3Rlcm9yZmxvd2RpcmVjdGlvbnJhc3Rlcl90YWcxQEBcIjogXCJMYSBwbGFnZSBkZSB2YWxldXJzIHPigJnDqXRlbmQgZGUgMCDDoCAzNjAgZGVncsOpcywgMCDDqXRhbnQgcsOpc2VydsOpIGF1eCBjZWxsdWxlcyBzb3VyY2UuIExhIGRpcmVjdGlvbiBwbGVpbiBFc3QgKGRyb2l0ZSkgZXN0IGRlIDkwIGV0IGxlcyB2YWxldXJzIGF1Z21lbnRlbnQgZGFucyBsZSBzZW5zIGhvcmFpcmUgKDE4MCwgU3VkIDsgMjcwLCBPdWVzdCBldCAzNjAsIE5vcmQpLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9kZXN0aW5hdGlvbmZpZWxkX3RhZzBAQFwiOiBcIkNoYW1wIHBlcm1ldHRhbnQgZOKAmW9idGVuaXIgZGVzIHZhbGV1cnMgcmVsYXRpdmVzIGF1eCBlbXBsYWNlbWVudHMgZGUgZGVzdGluYXRpb24uXCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX2Rlc3RpbmF0aW9ucmFzdGVyX3RhZzBAQFwiOiBcIkxhIGNvdWNoZSBkZSBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIHF1aSBpZGVudGlmaWUgbGVzIGNlbGx1bGVzIMOgIHBhcnRpciBkZXNxdWVsbGVzIGxlIGNoZW1pbiBvcHRpbWFsIGVzdCBkw6l0ZXJtaW7DqSBwYXIgcmFwcG9ydCDDoCBsYSBzb3VyY2UgZGUgbW9pbmRyZSBjb8O7dC4gQ2V0dGUgZW50csOpZSBlc3Qgb2JsaWdhdG9pcmUuXCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX2Rlc3RpbmF0aW9ucmFzdGVyX3RhZzFAQFwiOiBcIkxhIGNvdWNoZSByYXN0ZXIgZW4gZW50csOpZSBjb21wb3J0ZSBkZXMgY2VsbHVsZXMgcXVpIG9udCBkZXMgdmFsZXVycyB2YWxpZGVzICh6w6lybyBlc3QgdW5lIHZhbGV1ciB2YWxpZGUpIGV0IGxlcyBjZWxsdWxlcyByZXN0YW50ZXMgZG9pdmVudCBhdm9pciBsYSB2YWxldXIgTm9EYXRhLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9kaXN0YW5jZWFjY3VtdWxhdGlvbnJhc3Rlcl90YWcwQEBcIjogXCJMZSByYXN0ZXIgZOKAmWFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZSBwZXJtZXQgZGUgZMOpdGVybWluZXIgbGUgY2hlbWluIG9wdGltYWwgZW50cmUgbGVzIGRlc3RpbmF0aW9ucyBldCBsZXMgc291cmNlcy4gTGUgcmFzdGVyIGTigJlhY2N1bXVsYXRpb24gZGUgZGlzdGFuY2UgZXN0IGfDqW7DqXJhbGVtZW50IGNyw6nDqSDDoCBs4oCZYWlkZSBkZSBsYSBmb25jdGlvbiA8c3Ryb25nPkFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZTwvc3Ryb25nPi4gQ2hhcXVlIGNlbGx1bGUgZHUgcmFzdGVyIGTigJlhY2N1bXVsYXRpb24gZGUgZGlzdGFuY2UgcmVwcsOpc2VudGUgbGEgZGlzdGFuY2UgZGUgY2/Du3QgY3VtdWzDqWUgbWluaW11bSBzdXIgdW5lIHN1cmZhY2UgYWxsYW50IGRlIGNoYXF1ZSBjZWxsdWxlIMOgIHVuIGVuc2VtYmxlIGRlIGNlbGx1bGVzIHNvdXJjZS5cIixcblx0XCJAQE9wdGltYWwtUGF0aC1Bcy1SYXN0ZXJfcGF0aHR5cGVfdGFnMEBAXCI6IFwiU3DDqWNpZmllIHVuIG1vdC1jbMOpIGTDqWZpbmlzc2FudCBsYSBmYcOnb24gZG9udCBsZXMgdmFsZXVycyBldCBsZXMgem9uZXMgZGUgbOKAmWVudHLDqWUgZGUgZGVzdGluYXRpb24gc29udCBpbnRlcnByw6l0w6llcyBkYW5zIGxlcyBjYWxjdWxzIGR1IGNoZW1pbiBkZSBjb8O7dC5cIixcblx0XCJAQE9wdGltYWwtUGF0aC1Bcy1SYXN0ZXJfcGF0aHR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5DaGFxdWUgem9uZTwvc3Ryb25nPiA6IHBvdXIgY2hhcXVlIHpvbmUgZGVzIGRvbm7DqWVzIGRlIGRlc3RpbmF0aW9uIGVuIGVudHLDqWUsIHVuIGNoZW1pbiBkZSBtb2luZHJlIGNvw7t0IGVzdCBkw6l0ZXJtaW7DqSBldCBlbnJlZ2lzdHLDqSBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUuIEF2ZWMgY2V0dGUgb3B0aW9uLCBwb3VyIGNoYXF1ZSB6b25lLCBsZSBjaGVtaW4gb3B0aW1hbCBjb21tZW5jZSDDoCBsYSBjZWxsdWxlIGF2ZWMgbGEgcG9uZMOpcmF0aW9uIGRlIGRpc3RhbmNlIGRlIHBsdXMgZmFpYmxlIGNvw7t0IGRhbnMgbGEgem9uZS5cIixcblx0XCJAQE9wdGltYWwtUGF0aC1Bcy1SYXN0ZXJfcGF0aHR5cGVfdGFnMkBAXCI6IFwiPHN0cm9uZz5MZSBtb2lucyBjb8O7dGV1eDwvc3Ryb25nPiA6IHBvdXIgdG91dGVzIGxlcyBjZWxsdWxlcyBkZXMgZG9ubsOpZXMgZGUgZGVzdGluYXRpb24gZW4gZW50csOpZSwgbGUgY2hlbWluIG9wdGltYWwgZXN0IGTDqXJpdsOpIGRlIGxhIGNlbGx1bGUgY29udGVuYW50IGxlIG1pbmltdW0gZGUgY2hlbWlucyBkZSBtb2luZHJlIGNvw7t0IHZlcnMgbGVzIGNlbGx1bGVzIHNvdXJjZXMuXCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX3BhdGh0eXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+Q2hhcXVlIGNlbGx1bGU8L3N0cm9uZz4gOiBwb3VyIGNoYXF1ZSBjZWxsdWxlIGNvbnRlbmFudCBkZXMgdmFsZXVycyB2YWxpZGVzIGRlIGRvbm7DqWVzIGRlIGRlc3RpbmF0aW9uIGVuIGVudHLDqWUsIHVuIGNoZW1pbiBvcHRpbWFsIGVzdCBkw6l0ZXJtaW7DqS4gQXZlYyBjZXR0ZSBvcHRpb24sIGNoYXF1ZSBjZWxsdWxlIGRlcyBkb25uw6llcyBkZSBkZXN0aW5hdGlvbiBlbiBlbnRyw6llIGVzdCB0cmFpdMOpZSBzw6lwYXLDqW1lbnQgZXQgdW4gY2hlbWluIG9wdGltYWwgZXN0IGTDqXRlcm1pbsOpIHBvdXIgY2hhcXVlIGNlbGx1bGUuXCIsXG5cdFwiQEBDQ0RDLUFuYWx5c2lzX2JhbmRzZm9yZGV0ZWN0aW5nY2hhbmdlX3RhZzBAQFwiOiBcIklkZW50aWZpYW50cyBkZXMgY2FuYXV4IMOgIHV0aWxpc2VyIHBvdXIgbGEgZMOpdGVjdGlvbiBkZSBjaGFuZ2VtZW50cy4gU2kgYXVjdW4gaWRlbnRpZmlhbnQgZGVzIGNhbmF1eCBu4oCZZXN0IGZvdXJuaSwgdG91cyBsZXMgY2FuYXV4IGR1IGpldSBkZSBkb25uw6llcyByYXN0ZXIgZW4gZW50csOpZSBzZXJvbnQgdXRpbGlzw6lzLlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc19iYW5kc2ZvcmRldGVjdGluZ2NoYW5nZV90YWcxQEBcIjogXCJMZXMgdmFsZXVycyBk4oCZaWRlbnRpZmlhbnQgZG9pdmVudCDDqnRyZSBkZXMgZW50aWVycyBzw6lwYXLDqXMgcGFyIHVuIGVzcGFjZS5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfYmFuZHNmb3J0ZW1wb3JhbG1hc2tpbmdfdGFnMEBAXCI6IFwiTGVzIGlkZW50aWZpYW50cyBkZXMgY2FuYXV4IHZlcnQgZXQgU1dJUiwgw6AgdXRpbGlzZXIgcG91ciBtYXNxdWVyIGxlcyBudWFnZXMsIGzigJlvbWJyZSBkZXMgbnVhZ2VzIGV0IGxhIG5laWdlLiBFbiBs4oCZYWJzZW5jZSBk4oCZaWRlbnRpZmlhbnRzIGRlcyBjYW5hdXgsIGF1Y3VuIG1hc3F1YWdlIG5lIHNlIHByb2R1aXQuXCIsXG5cdFwiQEBDQ0RDLUFuYWx5c2lzX2JhbmRzZm9ydGVtcG9yYWxtYXNraW5nX3RhZzFAQFwiOiBcIkxlcyB2YWxldXJzIGTigJlpZGVudGlmaWFudCBkb2l2ZW50IMOqdHJlIGRlcyBlbnRpZXJzIHPDqXBhcsOpcyBwYXIgdW4gZXNwYWNlLlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc19iYW5kc2ZvcnRlbXBvcmFsbWFza2luZ190YWcyQEBcIjogXCJDZSBwYXJhbcOodHJlIHNww6ljaWZpZSBsZXMgY2FuYXV4IMOgIHV0aWxpc2VyIHBvdXIgbGUgbWFzcXVhZ2UgZGVzIG51YWdlcywgZGUgbOKAmW9tYnJlIGRlcyBudWFnZXMgZXQgZGUgbGEgbmVpZ2UuIEzigJlvbWJyZSBkZXMgbnVhZ2VzIGV0IGxhIG5laWdlIGFwcGFyYWlzc2FudCB0csOocyBzb21icmVzIGRhbnMgbGUgY2FuYWwgw6Agb25kZSBjb3VydGUgaW5mcmFyb3VnZSAoU1dJUikgZXQgbGVzIG51YWdlcyBldCBsYSBuZWlnZSDDqXRhbnQgdHLDqHMgbHVtaW5ldXggZGFucyBsZSBjYW5hbCB2ZXJ0LCBpbCBlc3QgcmVjb21tYW5kw6kgZGUgbWFzcXVlciBsZXMgaW5kZXggZGVzIGNhbmF1eCBTV0lSIGV0IHZlcnQuXCIsXG5cdFwiQEBDQ0RDLUFuYWx5c2lzX2NoaS1zcXVhcmVkdGhyZXNob2xkZm9yZGV0ZWN0Y2hhbmdlX3RhZzBAQFwiOiBcIlNldWlsIGR1IGtoaSBkZXV4IGRlIHByb2JhYmlsaXTDqSBkZXMgY2hhbmdlbWVudHMuIFNpIHVuZSBvYnNlcnZhdGlvbiBhIHVuZSBwcm9iYWJpbGl0w6kgZGUgY2hhbmdlbWVudCBjYWxjdWzDqWUgc3Vww6lyaWV1cmUgw6AgY2Ugc2V1aWwsIGVsbGUgZXN0IHNpZ25hbMOpZSBjb21tZSB1bmUgYW5vbWFsaWUsIGNlIHF1aSBjb3JyZXNwb25kIMOgIHVuIMOpdsOpbmVtZW50IGRlIGNoYW5nZW1lbnQgcG90ZW50aWVsLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDAsOTkuXCIsXG5cdFwiQEBDQ0RDLUFuYWx5c2lzX21pbmltdW1jb25zZWN1dGl2ZWFub21hbHlvYnNlcnZhdGlvbnNfdGFnMEBAXCI6IFwiTm9tYnJlIG1pbmltdW0gZOKAmW9ic2VydmF0aW9ucyBk4oCZYW5vbWFsaWVzIGNvbnPDqWN1dGl2ZXMgZGV2YW50IHNlIHByb2R1aXJlIHBvdXIgcXXigJl1biDDqXbDqW5lbWVudCBzb2l0IGNvbnNpZMOpcsOpIGNvbW1lIHVuIGNoYW5nZW1lbnQuIFVuIHBpeGVsIGRvaXQgw6p0cmUgc2lnbmFsw6kgY29tbWUgdW5lIGFub21hbGllIHBvdXIgbGUgbm9tYnJlIHNww6ljaWZpw6kgZGUgdHJhbmNoZXMgdGVtcG9yZWxsZXMgY29uc8OpY3V0aXZlcyBwb3VyIHF14oCZaWwgc29pdCBjb25zaWTDqXLDqSBjb21tZSB1biBjaGFuZ2VtZW50IHbDqXJpdGFibGUuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgNi5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfcmFzdGVyX3RhZzBAQFwiOiBcIkNvdWNoZSByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWxsZSBlbiBlbnRyw6llLlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc191cGRhdGluZ2ZpdHRpbmdmcmVxdWVuY3koaW55ZWFycylfdGFnMEBAXCI6IFwiRnLDqXF1ZW5jZSDDoCBsYXF1ZWxsZSBsZSBtb2TDqGxlIGRlIHPDqXJpZSBjaHJvbm9sb2dpcXVlIGVzdCBtaXMgw6Agam91ciBhdmVjIGxlcyBub3V2ZWxsZXMgb2JzZXJ2YXRpb25zLiBQYXIgZMOpZmF1dCwgbGUgbW9kw6hsZSBlc3QgbWlzIMOgIGpvdXIgY2hhcXVlIGFubsOpZS5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfdXBkYXRpbmdmaXR0aW5nZnJlcXVlbmN5KGlueWVhcnMpX3RhZzFAQFwiOiBcIkNlIHBhcmFtw6h0cmUgZMOpZmluaXQgbGEgZnLDqXF1ZW5jZSDDoCBsYXF1ZWxsZSBsZSBtb2TDqGxlIGRlIHPDqXJpZSBjaHJvbm9sb2dpcXVlIGVzdCBtaXMgw6Agam91ciBhdmVjIGxlcyBub3V2ZWxsZXMgb2JzZXJ2YXRpb25zLiBMYSBtaXNlIMOgIGpvdXIgZnLDqXF1ZW50ZSBk4oCZdW4gbW9kw6hsZSBwZXV0IG9jY2FzaW9ubmVyIHVuIGdyYW5kIG5vbWJyZSBkZSBjYWxjdWxzIHBvdXIgdW4gYXZhbnRhZ2UgbWluaW1hbC4gU2ksIHBhciBleGVtcGxlLCBsZSByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgY29udGllbnQgMzY1IHRyYW5jaGVzIG91IG9ic2VydmF0aW9ucyBjbGFpcmVzIHBhciBhbiBldCBxdWUgbGEgZnLDqXF1ZW5jZSBkZSBtaXNlIMOgIGpvdXIgY29uY2VybmUgY2hhY3VuZSBkZSBjZXMgb2JzZXJ2YXRpb25zLCBsZSB0cmFpdGVtZW50IGRlbWFuZGVyYSAzNjUgZm9pcyBwbHVzIGRlIGNhbGN1bHMgcXXigJl1bmUgbWlzZSDDoCBqb3VyIGFubnVlbGxlLCBzYW5zIHBvdXIgYXV0YW50IHF1ZSBsYSBwcsOpY2lzaW9uIG5lIHNvaXQgc3Vww6lyaWV1cmUuXCIsXG5cdFwiQEBUcmVuZC1Uby1SR0JfbW9kZWx0eXBlX3RhZzBAQFwiOiBcIlR5cGUgZGVzIGluZm9ybWF0aW9ucyBkdSBtb2TDqGxlIMOgIGNvbnZlcnRpciBlbiBSR0IuXCIsXG5cdFwiQEBUcmVuZC1Uby1SR0JfbW9kZWx0eXBlX3RhZzFAQFwiOiBcIkxpbsOpYWlyZSA6IGxlcyBpbmZvcm1hdGlvbnMgc3VyIGxhIHRlbmRhbmNlIGxpbsOpYWlyZSBzZXJvbnQgY29udmVydGllcyBlbiBSVkIuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuXCIsXG5cdFwiQEBUcmVuZC1Uby1SR0JfbW9kZWx0eXBlX3RhZzJAQFwiOiBcIkhhcm1vbmlxdWUgOiBsZXMgaW5mb3JtYXRpb25zIHN1ciBsYSB0ZW5kYW5jZSBoYXJtb25pcXVlIHNlcm9udCBjb252ZXJ0aWVzIGVuIFJWQi5cIixcblx0XCJAQFRyZW5kLVRvLVJHQl9yYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGRlIHRlbmRhbmNlIGVuIGVudHLDqWUuXCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX2Jlc3Rtb2RlbHByb3BvcnRpb25fdGFnMEBAXCI6IFwiPHA+TWVpbGxldXJlIHZhbGV1ciBkZSBwcm9wb3J0aW9uIGRlIG1vZMOobGUuIFBlbmRhbnQgbGUgcHJvY2Vzc3VzIGRlIHPDqWxlY3Rpb24gZHUgbW9kw6hsZSwgbOKAmW91dGlsIGNhbGN1bGUgbGEgdmFsZXVywqBwIHBvdXIgY2hhcXVlIG1vZMOobGUgZXQgc8OpbGVjdGlvbm5lIGxlIG1vZMOobGUgcXVpIGEgbGUgcGx1cyBkZSBzb21tZXRzIHRvdXQgZW4gY29uc2VydmFudCBsYSB2YWxldXLCoHAgbGEgcGx1cyBwZXRpdGUgKGxhIHBsdXMgc2lnbmlmaWNhdGl2ZSkgZW4gZm9uY3Rpb24gZGUgY2V0dGUgdmFsZXVyIGRlIHByb3BvcnRpb24uIExhIHZhbGV1csKgMSBzaWduaWZpZSBxdWUgbGUgbW9kw6hsZSBhIGxhIHZhbGV1csKgcCBsYSBwbHVzIGJhc3NlIG1haXMgbuKAmWEgcGV1dC3DqnRyZSBwYXMgdW4gZ3JhbmQgbm9tYnJlIGRlIHNvbW1ldHMuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMSwyNS48L3A+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX21heGltdW1udW1iZXJvZnNlZ21lbnRzX3RhZzBAQFwiOiBcIjxwPk5vbWJyZSBtYXhpbWFsIGRlIHNlZ21lbnRzIMOgIGFzc29jaWVyIMOgIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlIGRlIGNoYXF1ZSBwaXhlbC4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCA1LjwvcD5cIixcblx0XCJAQExhbmRUcmVuZHItQW5hbHlzaXNfbWluaW11bW51bWJlcm9mb2JzZXJ2YXRpb25zX3RhZzBAQFwiOiBcIjxwPk5vbWJyZSBtaW5pbXVtIGTigJlvYnNlcnZhdGlvbnMgdmFsaWRlcyBuw6ljZXNzYWlyZSBwb3VyIGVmZmVjdHVlciBs4oCZYWp1c3RlbWVudC4gTGUgbm9tYnJlIGTigJlhbm7DqWVzIGRhbnMgbGUgamV1IGRlIGRvbm7DqWVzIG11bHRpZGltZW5zaW9ubmVsbGVzIGVuIGVudHLDqWUgZG9pdCDDqnRyZSBzdXDDqXJpZXVyIG91IMOpZ2FsIMOgIGNldHRlIHZhbGV1ci4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCA2LjwvcD5cIixcblx0XCJAQExhbmRUcmVuZHItQW5hbHlzaXNfb3V0cHV0b3RoZXJiYW5kc190YWcwQEBcIjogXCI8cD5JbmRpcXVlIHNpIGxlcyBhdXRyZXMgY2FuYXV4IHNvbnQgaW5jbHVzIGRhbnMgbGVzIHLDqXN1bHRhdHMuPC9wPjx1bD48bGk+QWN0aXbDqcKgOiBsZXMgYXV0cmVzIGNhbmF1eCBzb250IGluY2x1cyBkYW5zIGxlcyByw6lzdWx0YXRzLiBMZXMgaW5mb3JtYXRpb25zIHN1ciBsYSBzZWdtZW50YXRpb24gZXQgbGVzIHNvbW1ldHMgaXNzdWVzIGR1IGNhbmFsIGRlIHNlZ21lbnRhdGlvbiBpbml0aWFsIHNww6ljaWZpw6kgZGFucyBsZSBwYXJhbcOodHJlIDxzdHJvbmc+Q2FuYWwgZGUgdHJhaXRlbWVudDwvc3Ryb25nPiBzb250IMOpZ2FsZW1lbnQgYWp1c3TDqWVzIGF1eCBhdXRyZXMgY2FuYXV4IGRlcyBpbWFnZXMgbXVsdGljYW5hbC4gTGVzIHLDqXN1bHRhdHMgZHUgbW9kw6hsZSBpbmNsdWVudCBk4oCZYWJvcmQgbGUgY2FuYWwgZGUgc2VnbWVudGF0aW9uLCBwdWlzIGxlcyBhdXRyZXMgY2FuYXV4LjwvbGk+PGxpPkTDqXNhY3RpdsOpwqA6IGxlcyBhdXRyZXMgY2FuYXV4IG5lIHNvbnQgcGFzIGluY2x1cy4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjwvdWw+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3ByZXZlbnRvbmV5ZWFycmVjb3ZlcnlfdGFnMEBAXCI6IFwiPHA+SW5kaXF1ZSBzaSBsZXMgc2VnbWVudHMgcXVpIHByw6lzZW50ZW50IHVuZSByw6ljdXDDqXJhdGlvbiBzdXIgdW4gYW4gZG9pdmVudCDDqnRyZSBleGNsdXMuPC9wPjx1bD48bGk+QWN0aXbDqcKgOiBsZXMgc2VnbWVudHMgcXVpIHByw6lzZW50ZW50IHVuZSByw6ljdXDDqXJhdGlvbiBzdXIgdW4gYW4gZG9pdmVudCDDqnRyZSBleGNsdXMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+RMOpc2FjdGl2w6nCoDogbGVzIHNlZ21lbnRzIHF1aSBwcsOpc2VudGVudCB1bmUgcsOpY3Vww6lyYXRpb24gc3VyIHVuIGFuIG5lIGRvaXZlbnQgcGFzIMOqdHJlIGV4Y2x1cy48L2xpPjwvdWw+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3Byb2Nlc3NpbmdiYW5kX3RhZzBAQFwiOiBcIjxwPkNhbmFsIHV0aWxpc8OpIHBvdXIgZMOpY291cGVyIGxlcyB0cmFqZWN0b2lyZXMgZGUgdmFsZXVyIGRlIHBpeGVsIGF1IGZpbCBkdSB0ZW1wcyBlbiBzZWdtZW50cy4gU8OpbGVjdGlvbm5leiBsZSBjYW5hbCBxdWkgY2FwdHVyZSBsZSBtaWV1eCBsZXMgY2hhbmdlbWVudHMgc3VyIGzigJllbnRpdMOpIMOgIG9ic2VydmVyLjwvcD5cIixcblx0XCJAQExhbmRUcmVuZHItQW5hbHlzaXNfcC12YWx1ZXRocmVzaG9sZF90YWcwQEBcIjogXCI8cD5TZXVpbCBkZSBsYSB2YWxldXLCoHAgcG91ciBsYSBzw6lsZWN0aW9uIGTigJl1biBtb2TDqGxlLiBVbmUgZm9pcyBsZXMgc29tbWV0cyBkw6l0ZWN0w6lzIMOgIGzigJnDqXRhcGUgaW5pdGlhbGUgZOKAmWFqdXN0ZW1lbnQgZHUgbW9kw6hsZSwgbOKAmW91dGlsIGFqdXN0ZSBjaGFxdWUgc2VnbWVudCBldCBjYWxjdWxlIGxhIHZhbGV1csKgcCBwb3VyIGTDqXRlcm1pbmVyIGxlIG5pdmVhdSBk4oCZaW1wb3J0YW5jZSBkdSBtb2TDqGxlLiDDgCBs4oCZaXTDqXJhdGlvbiBzdWl2YW50ZSwgbGUgbW9kw6hsZSBkaW1pbnVlIGxlIG5vbWJyZSBkZSBzZWdtZW50cyBk4oCZdW4gZXQgcmVjYWxjdWxlIGxhIHZhbGV1csKgcC4gTGUgcHJvY2Vzc3VzIGNvbnRpbnVlIGFpbnNpIGV0LCBzaSBsYSB2YWxldXLCoHAgZGV2aWVudCBpbmbDqXJpZXVyZSDDoCBsYSB2YWxldXIgc3DDqWNpZmnDqWUgZGFucyBjZSBwYXJhbcOodHJlLCBsZSBtb2TDqGxlIGVzdCBzw6lsZWN0aW9ubsOpIGV0IGzigJlvdXRpbCBhcnLDqnRlIGRlIHJlY2hlcmNoZXIgdW4gbWVpbGxldXIgbW9kw6hsZS4gU2kgYXVjdW4gbW9kw6hsZSBu4oCZZXN0IHPDqWxlY3Rpb25uw6ksIGzigJlvdXRpbCBzw6lsZWN0aW9ubmUgdW4gbW9kw6hsZSBhdmVjIHVuZSB2YWxldXLCoHAgaW5mw6lyaWV1cmUgw6AgbGEgPHN0cm9uZz52YWxldXLCoHAgbGEgcGx1cyBwZXRpdGXCoHjCoGxhIG1laWxsZXVyZSB2YWxldXIgZGUgcHJvcG9ydGlvbiBkZSBtb2TDqGxlPC9zdHJvbmc+LiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDAsMDEuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19yYXN0ZXJfdGFnMEBAXCI6IFwiPHA+Q291Y2hlIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbGxlIExhbmRzYXQgZW4gZW50csOpZS48L3A+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3JlY292ZXJ5aGFzaW5jcmVhc2V0cmVuZF90YWcwQEBcIjogXCI8cD5JbmRpcXVlIHNpIGxhIHLDqWN1cMOpcmF0aW9uIHByw6lzZW50ZSB1bmUgdGVuZGFuY2Ugw6AgbGEgaGF1c3NlIChwb3NpdGl2ZSkuPC9wPjx1bD48bGk+QWN0aXbDqcKgOiBsYSByw6ljdXDDqXJhdGlvbiBwcsOpc2VudGUgdW5lIHRlbmRhbmNlIMOgIGxhIGhhdXNzZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT5Ew6lzYWN0aXbDqcKgOiBsYSByw6ljdXDDqXJhdGlvbiBwcsOpc2VudGUgdW5lIHRlbmRhbmNlIMOgIGxhIGJhaXNzZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3JlY292ZXJ5dGhyZXNob2xkX3RhZzBAQFwiOiBcIjxwPlZhbGV1ciBkdSBzZXVpbCBkZSByw6ljdXDDqXJhdGlvbiwgZW4gYW5uw6llcy4gU2kgbGUgdGF1eCBkZSByw6ljdXDDqXJhdGlvbiBk4oCZdW4gc2VnbWVudCBlc3QgcGx1cyByYXBpZGUgcXVlIGxhIHZhbGV1ciA8c3Ryb25nPjEvc2V1aWwgZGUgcsOpY3Vww6lyYXRpb248L3N0cm9uZz4sIGNlIHNlZ21lbnQgZXN0IGlnbm9yw6kgZXQgbuKAmWVzdCBwYXMgaW5jbHVzIGRhbnMgbGUgbW9kw6hsZSBkZSBzw6lyaWUgY2hyb25vbG9naXF1ZS4gTGEgdmFsZXVyIGRvaXQgw6p0cmUgY29tcHJpc2UgZW50cmUgMCBldCAxLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDAsMjUuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19zbmFwcGluZ2RhdGVfdGFnMEBAXCI6IFwiPHA+RGF0ZSB1dGlsaXPDqWUgcG91ciBzw6lsZWN0aW9ubmVyIHVuZSB0cmFuY2hlIHBvdXIgY2hhcXVlIGFubsOpZSBkYW5zIGxlIGpldSBkZSBkb25uw6llcyBtdWx0aWRpbWVuc2lvbm5lbGxlcyBlbiBlbnRyw6llLiBMYSB0cmFuY2hlIGRvbnQgbGEgZGF0ZSBlc3QgbGEgcGx1cyBwcm9jaGUgZGUgbGEgZGF0ZSBkZSBjYXB0dXJlIGVzdCBzw6lsZWN0aW9ubsOpZS4gQ2UgcGFyYW3DqHRyZSBlc3QgcmVxdWlzIHNpIGxlIGpldSBkZSBkb25uw6llcyBlbiBlbnRyw6llIGNvbnRpZW50IGRlcyBkb25uw6llcyBwb3VyIGRlcyBww6lyaW9kZXMgaW5mw6lyaWV1cmVzIGF1eCBhbm7DqWVzLjwvcD5cIixcblx0XCJAQExhbmRUcmVuZHItQW5hbHlzaXNfc3Bpa2V0aHJlc2hvbGRfdGFnMEBAXCI6IFwiPHA+U2V1aWwgw6AgdXRpbGlzZXIgcG91ciBhbW9ydGlyIGxlcyBwaWNzIG91IGxlcyBhbm9tYWxpZXMgZGFucyBsYSB0cmFqZWN0b2lyZSBkZSB2YWxldXIgZGUgcGl4ZWwuIENldHRlIHZhbGV1ciBkb2l0IMOqdHJlIGNvbXByaXNlIGVudHJlIDAgZXQgMSwgb8O5IDEgc2lnbmlmaWUgcXXigJlpbCBu4oCZeSBhIHBhcyBk4oCZYW1vcnRpc3NlbWVudC4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCAwLDkuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc192ZXJ0ZXhjb3VudG92ZXJzaG9vdF90YWcwQEBcIjogXCI8cD5Ob21icmUgZGUgc29tbWV0cyBzdXBwbMOpbWVudGFpcmVzIGF1LWRlbMOgIGRlIDxzdHJvbmc+bm9tYnJlX21heF9zZWdtZW50cyArIDE8L3N0cm9uZz4gcXVpIHBldXQgw6p0cmUgdXRpbGlzw6kgcG91ciBhanVzdGVyIGxlIG1vZMOobGUgcGVuZGFudCBsYSBwaGFzZSBpbml0aWFsZSBk4oCZaWRlbnRpZmljYXRpb24gZGVzIHNvbW1ldHMuIFBsdXMgdGFyZCBkYW5zIGxlIHByb2Nlc3N1cyBkZSBtb2TDqWxpc2F0aW9uLCBsZSBub21icmUgZGUgc29tbWV0cyBzdXBwbMOpbWVudGFpcmVzIGVzdCByw6lkdWl0IMOgIDxzdHJvbmc+bm9tYnJlX21heF9zZWdtZW50cyArIDE8L3N0cm9uZz4uIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMi48L3A+XCIsXG5cdFwiQEBNZXJnZS1SYXN0ZXJzX3Jhc3RlcnNfdGFnMEBAXCI6IFwiPHA+SmV1eCBkZSBkb25uw6llcyByYXN0ZXIgb3UgamV1eCBkZSBkb25uw6llcyByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWxsZXMgZW4gZW50csOpZSDDoCBmdXNpb25uZXIuPC9wPlwiLFxuXHRcIkBATWVyZ2UtUmFzdGVyc19yZXNvbHZlb3ZlcmxhcG1ldGhvZF90YWcwQEBcIjogXCI8cD5JbmRpcXVlIGxhIG3DqXRob2RlIMOgIHV0aWxpc2VyIHBvdXIgcsOpc291ZHJlIGxlcyBwaXhlbHMgc3VwZXJwb3PDqXMgZGFucyBsZXMgamV1eCBkZSBkb25uw6llcyBjb21iaW7DqXMuPC9wPjx1bD48bGk+PHN0cm9uZz5QcmVtaWVyPC9zdHJvbmc+wqA6IGxhIHZhbGV1ciBkZSBwaXhlbCBkZXMgem9uZXMgc3VwZXJwb3PDqWVzIGVzdCBjZWxsZSBpc3N1ZSBkdSBwcmVtaWVyIHJhc3RlciBkZSBsYSBsaXN0ZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPjxzdHJvbmc+RGVybmllcjwvc3Ryb25nPsKgOiBsYSB2YWxldXIgZGUgcGl4ZWwgZGVzIHpvbmVzIHN1cGVycG9zw6llcyBlc3QgY2VsbGUgaXNzdWUgZHUgZGVybmllciByYXN0ZXIgZGUgbGEgbGlzdGUgZGVzIHJhc3RlcnMgZW4gZW50csOpZS48L2xpPjxsaT48c3Ryb25nPk1pbjwvc3Ryb25nPsKgOiBsYSB2YWxldXIgZGUgcGl4ZWwgZGVzIHpvbmVzIHN1cGVycG9zw6llcyBlc3QgbGEgdmFsZXVyIG1pbmltYWxlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMuPC9saT48bGk+PHN0cm9uZz5NYXg8L3N0cm9uZz7CoDogbGEgdmFsZXVyIGRlIHBpeGVsIGRlcyB6b25lcyBzdXBlcnBvc8OpZXMgZXN0IGxhIHZhbGV1ciBtYXhpbWFsZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzLjwvbGk+PGxpPjxzdHJvbmc+TW95ZW5uZTwvc3Ryb25nPsKgOiBsYSB2YWxldXIgZGUgcGl4ZWwgZGVzIHpvbmVzIHN1cGVycG9zw6llcyBlc3QgbGEgdmFsZXVyIG1veWVubmUgZGVzIHBpeGVscyBzdXBlcnBvc8Opcy48L2xpPjxsaT48c3Ryb25nPlNvbW1lPC9zdHJvbmc+wqA6IGxhIHZhbGV1ciBkZSBwaXhlbCBkZXMgem9uZXMgc3VwZXJwb3PDqWVzIGVzdCBsYSBzb21tZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzLjwvbGk+PC91bD5cIixcblx0XCJAQEdlbmVyYXRlLVRyZW5kX2N5Y2xldW5pdF90YWcwQEBcIjogXCI8cD5TcMOpY2lmaWUgbOKAmXVuaXTDqSBkZSB0ZW1wcyDDoCB1dGlsaXNlciBwb3VyIGxhIGR1csOpZSBk4oCZdW4gY3ljbGUgaGFybW9uaXF1ZS48L3A+PHVsPjxsaT48c3Ryb25nPkpvdXJzPC9zdHJvbmc+wqA6IEzigJl1bml0w6kgZGUgZHVyw6llIGR1IGN5Y2xlIGhhcm1vbmlxdWUgc2UgZMOpZmluaXQgZW4gam91cnMuPC9saT48bGk+PHN0cm9uZz5Bbm7DqWVzPC9zdHJvbmc+wqA6IEzigJl1bml0w6kgZGUgZHVyw6llIGR1IGN5Y2xlIGhhcm1vbmlxdWUgc2UgZMOpZmluaXQgZW4gYW5uw6llcy4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9kaW1lbnNpb25uYW1lX3RhZzBAQFwiOiBcIjxwPkRpbWVuc2lvbiBsZSBsb25nIGRlIGxhcXVlbGxlIHVuZSB0ZW5kYW5jZSBzZXJhIGV4dHJhaXRlIHBvdXIgbGEgb3UgbGVzIHZhcmlhYmxlcyBzw6lsZWN0aW9ubsOpZXMgZGFucyBs4oCZYW5hbHlzZS48L3A+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9oYXJtb25pY2ZyZXF1ZW5jeV90YWcwQEBcIjogXCI8cD5OdW3DqXJvIGRlIGZyw6lxdWVuY2Ugw6AgdXRpbGlzZXIgZGFucyBs4oCZYWp1c3RlbWVudCBkZSB0ZW5kYW5jZS4gQ2UgcGFyYW3DqHRyZSBzcMOpY2lmaWUgbGEgZnLDqXF1ZW5jZSBkZXMgY3ljbGVzIGF1IGNvdXJzIGTigJl1bmUgYW5uw6llLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDEsIHNvaXQgdW4gY3ljbGUgaGFybW9uaXF1ZSBwYXIgYW4uPC9wPjxwPkNlIHBhcmFtw6h0cmUgbuKAmWVzdCBpbmNsdXMgZGFucyBs4oCZYW5hbHlzZSBkZSB0ZW5kYW5jZSBxdWUgcG91ciB1bmUgcsOpZ3Jlc3Npb24gaGFybW9uaXF1ZS48L3A+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9pZ25vcmVub2RhdGFfdGFnMEBAXCI6IFwiPHA+SW5kaXF1ZSBzaSBsZXMgdmFsZXVycyBOb0RhdGEgc29udCBpZ25vcsOpZXMgbG9ycyBkZSBs4oCZYW5hbHlzZS48L3A+PHVsPjxsaT5BY3RpdsOpwqA6IGzigJlhbmFseXNlIGluY2x1dCB0b3VzIGxlcyBwaXhlbHMgdmFsaWRlcyBsZSBsb25nIGTigJl1bmUgZGltZW5zaW9uIGRvbm7DqWUgZXQgaWdub3JlIGxlcyBwaXhlbHMgTm9EYXRhLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPkTDqXNhY3RpdsOpwqA6IGxlIHLDqXN1bHRhdCBkZSBs4oCZYW5hbHlzZSBlc3QgTm9EYXRhIHPigJlpbCBleGlzdGUgZGVzIHZhbGV1cnMgTm9EYXRhIHBvdXIgbGVzIHBpeGVscyBsZSBsb25nIGRlIGxhIGRpbWVuc2lvbiBkb25uw6llLjwvbGk+PC91bD5cIixcblx0XCJAQEdlbmVyYXRlLVRyZW5kX2xlbmd0aG9mY3ljbGVfdGFnMEBAXCI6IFwiPHA+RHVyw6llIGRlIGxhIHZhcmlhdGlvbiBww6lyaW9kaXF1ZSDDoCBtb2TDqWxpc2VyLiBM4oCZdW5pdMOpIGVzdCBsZSBqb3VyLCBxdWVsbGUgcXVlIHNvaXQgbOKAmXVuaXTDqSB0ZW1wb3JlbGxlIGRlcyBkb25uw6llcyBlbiBlbnRyw6llLiBQYXIgZXhlbXBsZSwgbGEgY291bGV1ciB2ZXJ0ZSBkZXMgZmV1aWxsZXMgcG9zc8OoZGUgZ8OpbsOpcmFsZW1lbnQgdW4gY3ljbGUgZGUgdmFyaWF0aW9uIGltcG9ydGFudCBhdSBjb3VycyBk4oCZdW5lIGFubsOpZcKgOyBsYSBkdXLDqWUgZHUgY3ljbGUgZXN0IMOpZ2FsZSDDoCAzNjUsMjUsIG3Dqm1lIHNpIGxlcyBkb25uw6llcyBlbiBlbnRyw6llIGZvbnQgcsOpZsOpcmVuY2Ugw6AgdW5lIGNvdWxldXIgdmVydGUgbWVuc3VlbGxlLiBMZXMgZG9ubsOpZXMgZGUgdGVtcMOpcmF0dXJlIGhvcmFpcmVzIG9udCB1biBjeWNsZSBkZSB2YXJpYXRpb24gaW1wb3J0YW50IHN1ciBsYSBqb3VybsOpZSwgbGEgZHVyw6llIGR1IGN5Y2xlIGVzdCDDqWdhbGUgw6AgMS48L3A+PHA+TGEgZHVyw6llIHBhciBkw6lmYXV0IGVzdCBkZSAzNjUsMjXCoGpvdXJzIHBvdXIgbGVzIGRvbm7DqWVzIHZhcmlhbnQgc3VyIHVuIGN5Y2xlIGFubnVlbC48L3A+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9wLXZhbHVlb2ZzbG9wZWNvZWZmaWNpZW50X3RhZzBAQFwiOiBcIjxwPkluZGlxdWUgc+KAmWlsIGNvbnZpZW50IGRlIGNhbGN1bGVyIGxhIHN0YXRpc3RpcXVlIGRlIHZhbGV1csKgcCBkdSBjb2VmZmljaWVudCBkZSBwZW50ZSBkZSBsYSBsaWduZSBkZSB0ZW5kYW5jZS48L3A+PHVsPjxsaT5BY3RpdsOpwqA6IGxhIHZhbGV1csKgcCBlc3QgY2FsY3Vsw6llIGV0IGFmZmljaMOpZSBkYW5zIGxlcyBkw6l0YWlscyDDoCBsYSBmaW4gZHUgY2FsY3VsIGRlIGxhIGZvbmN0aW9uLjwvbGk+PGxpPkTDqXNhY3RpdsOpwqA6IGxhIHZhbGV1csKgcCBu4oCZZXN0IHBhcyBjYWxjdWzDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfcG9seW5vbWlhbG9yZGVyX3RhZzBAQFwiOiBcIjxwPk51bcOpcm8gZOKAmW9yZHJlIHBvbHlub21pYWwgw6AgdXRpbGlzZXIgZGFucyBs4oCZYWp1c3RlbWVudCBkZSB0ZW5kYW5jZS4gQ2UgcGFyYW3DqHRyZSBzcMOpY2lmaWUgbOKAmW9yZHJlIHBvbHlub21pYWwuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMiBvdSB1biBwb2x5bsO0bWUgZGUgZGV1eGnDqG1lIGRlZ3LDqS48L3A+PHA+Q2UgcGFyYW3DqHRyZSBu4oCZZXN0IGluY2x1cyBkYW5zIGzigJlhbmFseXNlIGRlIHRlbmRhbmNlIHF1ZSBwb3VyIHVuZSByw6lncmVzc2lvbiBwb2x5bm9taWFsZS48L3A+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9yLXNxdWFyZWRfdGFnMEBAXCI6IFwiPHA+SW5kaXF1ZSBz4oCZaWwgY29udmllbnQgZGUgY2FsY3VsZXIgbGEgc3RhdGlzdGlxdWUgZGUgbGEgcXVhbGl0w6kgZGUgbOKAmWFqdXN0ZW1lbnQgUi1jYXJyw6kgcG91ciBsYSBsaWduZSBk4oCZYWp1c3RlbWVudCBkZSBsYSB0ZW5kYW5jZS48L3A+PHVsPjxsaT5BY3RpdsOpwqA6IGxhIHZhbGV1ciBSLWNhcnLDqSBlc3QgY2FsY3Vsw6llIGV0IGFmZmljaMOpZSBkYW5zIGxlcyBkw6l0YWlscyDDoCBsYSBmaW4gZHUgY2FsY3VsIGRlIGxhIGZvbmN0aW9uLjwvbGk+PGxpPkTDqXNhY3RpdsOpwqA6IGxhIHZhbGV1ciBSLWNhcnLDqSBu4oCZZXN0IHBhcyBjYWxjdWzDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfcmFzdGVyX3RhZzBAQFwiOiBcIjxwPlJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbCBlbiBlbnRyw6llLjwvcD5cIixcblx0XCJAQEdlbmVyYXRlLVRyZW5kX3Jtc2VfdGFnMEBAXCI6IFwiPHA+SW5kaXF1ZSBz4oCZaWwgY29udmllbnQgZGUgZ8OpbsOpcmVyIGxhIHJhY2luZSBjYXJyw6llIGRlIGzigJllcnJldXIgcXVhZHJhdGlxdWUgbW95ZW5uZSAoRVFNKSBkZSBsYSBsaWduZSBk4oCZYWp1c3RlbWVudCBkZSBsYSB0ZW5kYW5jZS48L3A+PHVsPjxsaT5BY3RpdsOpwqA6IGxhIHZhbGV1ciBFUU0gZXN0IGNhbGN1bMOpZSBldCBhZmZpY2jDqWUgZGFucyBsZXMgZMOpdGFpbHMgw6AgbGEgZmluIGR1IGNhbGN1bCBkZSBsYSBmb25jdGlvbi4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT5Ew6lzYWN0aXbDqcKgOiBsYSB2YWxldXIgRVFNIG7igJllc3QgcGFzIGNhbGN1bMOpZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9zZWFzb25hbHBlcmlvZF90YWcwQEBcIjogXCI8cD5TcMOpY2lmaWUgbOKAmXVuaXTDqSBkZSB0ZW1wcyDDoCB1dGlsaXNlciBwb3VyIG1lc3VyZXIgbGEgbG9uZ3VldXIgZGUgbGEgcMOpcmlvZGUgc2Fpc29ubmnDqHJlIGxvcnMgZHUgdGVzdCBkZSBLZW5kYWxsIHNhaXNvbm5pZXI8L3A+PHVsPjxsaT5Kb3Vyc8KgOiBs4oCZdW5pdMOpIGRlIGR1csOpZSBkZSBsYSBww6lyaW9kZSBzYWlzb25uacOocmUgc2UgZMOpZmluaXQgZW4gam91cnMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+TW9pc8KgOiBs4oCZdW5pdMOpIGRlIGR1csOpZSBkZSBsYSBww6lyaW9kZSBzYWlzb25uacOocmUgc2UgZMOpZmluaXQgZW4gbW9pcy48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF90cmVuZHR5cGVfdGFnMEBAXCI6IFwiPHA+U3DDqWNpZmllIGxlIHR5cGUgZGUgbGlnbmUgw6AgdXRpbGlzZXIgcG91ciBhanVzdGVyIGxlcyB2YWxldXJzIGRlIHBpeGVsIGxlIGxvbmcgZOKAmXVuZSBkaW1lbnNpb24uPC9wPjx1bD48bGk+PHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz7CoDogYWp1c3RlIGxlcyB2YWxldXJzIGRlIHBpeGVsIGTigJl1bmUgdmFyaWFibGUgbGUgbG9uZyBk4oCZdW5lIGxpZ25lIGRlIHRlbmRhbmNlIGxpbsOpYWlyZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT48c3Ryb25nPkhhcm1vbmlxdWU8L3N0cm9uZz7CoDogYWp1c3RlIGxlcyB2YWxldXJzIGRlIHBpeGVsIGTigJl1bmUgdmFyaWFibGUgbGUgbG9uZyBk4oCZdW5lIGxpZ25lIGRlIHRlbmRhbmNlIGhhcm1vbmlxdWUuPC9saT48bGk+PHN0cm9uZz5Qb2x5bm9taWFsZTwvc3Ryb25nPsKgOiBhanVzdGUgbGVzIHZhbGV1cnMgZGUgcGl4ZWwgZOKAmXVuZSB2YXJpYWJsZSBsZSBsb25nIGTigJl1bmUgbGlnbmUgZGUgdGVuZGFuY2UgcG9seW5vbWlhbGUgZGUgZGV1eGnDqG1lIGRlZ3LDqS48L2xpPjxsaT48c3Ryb25nPk1hbm4tS2VuZGFsbDwvc3Ryb25nPsKgOiBsZXMgdmFsZXVycyBkZSBwaXhlbCB2YXJpYWJsZXMgc29udCDDqXZhbHXDqWVzIMOgIGzigJlhaWRlIGR1IHRlc3QgZGUgdGVuZGFuY2UgZGUgTWFubi1LZW5kYWxsLjwvbGk+PGxpPjxzdHJvbmc+S2VuZGFsbCBzYWlzb25uaWVyPC9zdHJvbmc+wqA6IGxlcyB2YWxldXJzIGRlIHBpeGVsIHZhcmlhYmxlcyBzb250IMOpdmFsdcOpZXMgw6AgbOKAmWFpZGUgZHUgdGVzdCBkZSB0ZW5kYW5jZSBkZSBLZW5kYWxsIHNhaXNvbm5pZXIuPC9saT48L3VsPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfY2VsbHNpemV0eXBlX3RhZzBAQFwiOiBcIjxwPlPDqWxlY3Rpb25uZXogbGEgdGFpbGxlIGRlIGNlbGx1bGUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBTaSBsZXMgdGFpbGxlcyBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy48L3A+PHVsPjxsaT5QcmVtaWVyIGRlwqA6IHV0aWxpc2UgbGEgcHJlbWnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuPC9saT48bGk+TWluIGRlwqA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbGEgcGx1cyBwZXRpdGUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLjwvbGk+PGxpPk1heCBkZcKgOiB1dGlsaXNlIGxhIHRhaWxsZSBkZSBjZWxsdWxlIGxhIHBsdXMgZ3JhbmRlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT5Nb3llbm5lIGRlwqA6IHV0aWxpc2UgbGEgdGFpbGxlIGRlIGNlbGx1bGUgbW95ZW5uZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuPC9saT48bGk+RGVybmllciBkZcKgOiB1dGlsaXNlIGxhIGRlcm5pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLjwvbGk+PC91bD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX2NvbXB1dGVjaGFuZ2VtZXRob2RfdGFnMEBAXCI6IFwiPHA+TcOpdGhvZGUgZW1wbG95w6llIHBvdXIgbGUgY2FsY3VsLjwvcD48dWw+PGxpPjxzdHJvbmc+RGlmZsOpcmVuY2U8L3N0cm9uZz7CoDogY2FsY3VsZSBsYSBkaWZmw6lyZW5jZSBtYXRow6ltYXRpcXVlLCBvdSBzb3VzdHJhY3Rpb24sIGVudHJlIGxlcyB2YWxldXJzIGRlIHBpeGVsIGRhbnMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT48c3Ryb25nPkRpZmbDqXJlbmNlIHJlbGF0aXZlPC9zdHJvbmc+IC3CoENhbGN1bGUgbGEgZGlmZsOpcmVuY2UgZW4gdmFsZXVycyBkZSBwaXhlbCwgZW4gdGVuYW50IGNvbXB0ZSBkZXMgbWFnbml0dWRlcyBkZXMgdmFsZXVycyBjb21wYXLDqWVzLjwvbGk+PGxpPjxzdHJvbmc+RGlmZsOpcmVuY2UgY2F0w6lnb3JpZWxsZTwvc3Ryb25nPiAtwqBDYWxjdWxlIGxhIGRpZmbDqXJlbmNlIGVudHJlIGRldXggcmFzdGVycyBjYXTDqWdvcmllbHMgb3UgdGjDqW1hdGlxdWVzLiBMYSBzb3J0aWUgY29udGllbnQgbGVzIHRyYW5zaXRpb25zIGRlIGNsYXNzZSBheWFudCBldSBsaWV1IGVudHJlIGxlcyBkZXV4IHJhc3RlcnMuPC9saT48bGk+PHN0cm9uZz5EaXN0YW5jZSBldWNsaWRpZW5uZSBzcGVjdHJhbGU8L3N0cm9uZz4gLcKgQ2FsY3VsZSBsYSBkaXN0YW5jZSBldWNsaWRpZW5uZSBlbnRyZSBsZXMgdmFsZXVycyBkZSBwaXhlbCBkZSBkZXV4IHJhc3RlcnMgbXVsdGliYW5kZXMuPC9saT48bGk+PHN0cm9uZz7DiWNhcnQgZGUgbOKAmWFuZ2xlIHNwZWN0cmFsPC9zdHJvbmc+IC3CoENhbGN1bGUgbOKAmWFuZ2xlIHNwZWN0cmFsIGVudHJlIGxlcyB2YWxldXJzIGRlIHBpeGVsIGRlIGRldXggcmFzdGVycyBtdWx0aWJhbmRlcy4gTGEgc29ydGllIGVzdCBleHByaW3DqWUgZW4gcmFkaWFucy48L2xpPjxsaT48c3Ryb25nPkJhbmRlIGF2ZWMgbGUgcGx1cyBkZSBjaGFuZ2VtZW50czwvc3Ryb25nPiAtwqBDYWxjdWxlIGxhIGJhbmRlIGNvbXBvcnRhbnQgbGUgcGx1cyBncmFuZCBub21icmUgZGUgY2hhbmdlbWVudHMgcG91ciBjaGFxdWUgcGl4ZWwgZW50cmUgZGV1eCByYXN0ZXJzIG11bHRpYmFuZGVzLjwvbGk+PC91bD48cD5TaSBs4oCZb3B0aW9uIDxzdHJvbmc+TW9kZSBkZSBjYWxjdWwgZGVzIGNoYW5nZW1lbnRzPC9zdHJvbmc+IGVzdCBkw6lmaW5pZSBzdXIgPHN0cm9uZz5EaWZmw6lyZW5jZSBjYXTDqWdvcmllbGxlPC9zdHJvbmc+LCBldCBxdWUgbOKAmXVuZSBkZXMgZW50csOpZXMgbuKAmWVzdCBwYXMgY2F0w6lnb3JpcXVlLCB1bmUgZGlmZsOpcmVuY2Ugc2ltcGxlIGVzdCBjYWxjdWzDqWUuPC9wPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfZGVmaW5ldHJhbnNpdGlvbmNvbG9yc190YWcwQEBcIjogXCI8cD5TcMOpY2lmaWVyIGxhIG3DqXRob2RlIMOgIHV0aWxpc2VyIHBvdXIgc3ltYm9saXNlciBsZXMgcGl4ZWxzIGF5YW50IGNoYW5nw6kgZGUgY2xhc3NlLjwvcD48dWw+PGxpPjxzdHJvbmc+VXRpbGlzZXIgbGEgbW95ZW5uZSBkZXMgY291bGV1cnMgZOKAmW9yaWdpbmUgZXQgZGUgZGVzdGluYXRpb248L3N0cm9uZz7CoDogbGEgY291bGV1ciBkdSBwaXhlbCBjb3JyZXNwb25kIMOgIGxhIG1veWVubmUgZGUgbGEgY291bGV1ciBkZSBzYSBjbGFzc2UgZOKAmW9yaWdpbmUgZXQgZGUgbGEgY291bGV1ciBkZSBzYSBjbGFzc2UgZGUgZGVzdGluYXRpb24uPC9saT48bGk+PHN0cm9uZz5VdGlsaXNlciBsZXMgY291bGV1cnMgZOKAmW9yaWdpbmU8L3N0cm9uZz7CoDogbGUgcGl4ZWwgcHJlbmQgbGEgY291bGV1ciBkZSBzYSBjbGFzc2UgZOKAmW9yaWdpbmUuPC9saT48bGk+PHN0cm9uZz5VdGlsaXNlciBsZXMgY291bGV1cnMgZGUgZGVzdGluYXRpb248L3N0cm9uZz7CoDogbGUgcGl4ZWwgcHJlbmRyYSBsYSBjb3VsZXVyIGRlIHNhIGNsYXNzZSBkZSBkZXN0aW5hdGlvbi48L2xpPjwvdWw+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9leHRlbnR0eXBlX3RhZzBAQFwiOiBcIjxwPlPDqWxlY3Rpb25uZXogbOKAmcOpdGVuZHVlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZcKgOjwvcD48dWw+PGxpPlByZW1pZXIgZGXCoDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LjwvbGk+PGxpPkludGVyc2VjdGlvbiBkZcKgOiB1dGlsaXNlIGzigJnDqXRlbmR1ZSBkZXMgcGl4ZWxzIHN1cGVycG9zw6lzIHBvdXIgZMOpdGVybWluZXIgbOKAmcOpdGVuZHVlIGRlIHRyYWl0ZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+VW5pb24gZGXCoDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LjwvbGk+PGxpPkRlcm5pZXIgZGXCoDogdXRpbGlzZSBs4oCZw6l0ZW5kdWUgZHUgZGVybmllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LjwvbGk+PC91bD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX2ZpbHRlcm1ldGhvZF90YWcwQEBcIjogXCI8cD5DaG9pc2lzc2V6IGxhIG3DqXRob2RlIGRlIGZpbHRyYWdlIMOgIHV0aWxpc2VyIHBvdXIgbGUgY2FsY3VsIGRlcyBjaGFuZ2VtZW50cyBjYXTDqWdvcmllbHMuPC9wPjx1bD48bGk+PHN0cm9uZz5Ub3V0IGNvbnNlcnZlcjwvc3Ryb25nPsKgOiB0b3V0ZXMgbGVzIGNsYXNzZXMgc29udCBpbmNsdXNlcyBkYW5zIGxhIHNvcnRpZSwgZXQgaWwgbuKAmXkgYSBwYXMgZGUgZmlsdHJhZ2UuIFPDqWxlY3Rpb25uZXogY2V0dGUgb3B0aW9uIHBvdXIgb2JzZXJ2ZXIgbGVzIGNoYW5nZW1lbnRzIGV0IGxlcyBwZXJzaXN0YW5jZXMgZGFucyB1biBzZXVsIGpldSBkZSBkb25uw6llcy48L2xpPjxsaT48c3Ryb25nPkNvbnNlcnZlciB1bmlxdWVtZW50IGxlcyBwaXhlbHMgbW9kaWZpw6lzPC9zdHJvbmc+wqA6IHNldWxlcyBsZXMgY2xhc3NlcyBxdWkgb250IGNoYW5nw6kgZGUgdHlwZSBkZSBjbGFzc2Ugc29udCBpbmNsdXNlcyBkYW5zIGxhIHNvcnRpZS4gU8OpbGVjdGlvbm5leiBjZXR0ZSBvcHRpb24gc2kgc2V1bHMgbGVzIGNoYW5nZW1lbnRzIHZvdXMgaW50w6lyZXNzZW50LjwvbGk+PGxpPjxzdHJvbmc+Q29uc2VydmVyIHVuaXF1ZW1lbnQgbGVzIHBpeGVscyBub24gbW9kaWZpw6lzPC9zdHJvbmc+wqA6IHNldWxlcyBsZXMgY2xhc3NlcyBxdWkgcmVzdGVudCBpbmNoYW5nw6llcyBzb250IGluY2x1c2VzIGRhbnMgbGEgc29ydGllLiBTw6lsZWN0aW9ubmV6IGNldHRlIG9wdGlvbiBzaSBzZXVsZXMgbGVzIHBlcnNpc3RhbmNlcyB2b3VzIGludMOpcmVzc2VudC48L2xpPjwvdWw+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9mcm9tY2xhc3N2YWx1ZXNfdGFnMEBAXCI6IFwiPHA+VmFsZXVycyBkZSBsYSBjbGFzc2UgcHJvdmVuYW50IGRlIDxzdHJvbmc+UmFzdGVyIGTigJlvcmlnaW5lPC9zdHJvbmc+IMOgIGluY2x1cmUgZGFucyBsZSBjYWxjdWwsIGxvcnNxdeKAmW9uIGNvbXBhcmUgZGV1eCByYXN0ZXJzIGNhdMOpZ29yaWVscy4gSWwgc+KAmWFnaXQgZOKAmXVuZSBsaXN0ZSBkZSB2YWxldXJzIGVudGnDqHJlcyBkw6lsaW1pdMOpZXMgcGFyIGRlcyBlc3BhY2VzIGNvcnJlc3BvbmRhbnQgYXUgY2hhbXAgPHN0cm9uZz5DbGFzc1ZhbHVlPC9zdHJvbmc+IGRhbnMgdm90cmUgamV1IGRlIGRvbm7DqWVzIHJhc3RlciBlbiBlbnRyw6llLjwvcD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX2Zyb21yYXN0ZXJfdGFnMEBAXCI6IFwiPHA+UHJlbWllciByYXN0ZXIgdXRpbGlzw6kgZGFucyBsZSBjYWxjdWwuIFBvdXIgw6l2YWx1ZXIgbGUgY2hhbmdlbWVudCBkZSBs4oCZaW50ZXJ2YWxsZcKgMSAocHLDqWPDqWRlbW1lbnQpIMOgIGzigJlpbnRlcnZhbGxlIDIgKHVsdMOpcmlldXJlbWVudCksIHNhaXNpc3NleiBsZSByYXN0ZXIgZGUgbOKAmWludGVydmFsbGXCoDEgaWNpLjwvcD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX3RvY2xhc3N2YWx1ZXNfdGFnMEBAXCI6IFwiPHA+VmFsZXVycyBkZSBsYSBjbGFzc2UgcHJvdmVuYW50IGRlIDxzdHJvbmc+UmFzdGVyIGRlIGRlc3RpbmF0aW9uPC9zdHJvbmc+IMOgIGluY2x1cmUgZGFucyBsZSBjYWxjdWwsIGxvcnNxdeKAmW9uIGNvbXBhcmUgZGV1eCByYXN0ZXJzIGNhdMOpZ29yaWVscy4gSWwgc+KAmWFnaXQgZOKAmXVuZSBsaXN0ZSBkZSB2YWxldXJzIGVudGnDqHJlcyBkw6lsaW1pdMOpZXMgcGFyIGRlcyBlc3BhY2VzIGNvcnJlc3BvbmRhbnQgYXUgY2hhbXAgPHN0cm9uZz5DbGFzc1ZhbHVlPC9zdHJvbmc+IGRhbnMgdm90cmUgamV1IGRlIGRvbm7DqWVzIHJhc3RlciBlbiBlbnRyw6llLjwvcD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX3RvcmFzdGVyX3RhZzBAQFwiOiBcIjxwPlNlY29uZCByYXN0ZXIgdXRpbGlzw6kgZGFucyBsZSBjYWxjdWwuIFBvdXIgw6l2YWx1ZXIgbGUgY2hhbmdlbWVudCBkZSBs4oCZaW50ZXJ2YWxsZcKgMSAocHLDqWPDqWRlbW1lbnQpIMOgIGzigJlpbnRlcnZhbGxlIDIgKHVsdMOpcmlldXJlbWVudCksIHNhaXNpc3NleiBsZSByYXN0ZXIgZGUgbOKAmWludGVydmFsbGXCoDIuPC9wPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfdXNlY29sb3JtZXRob2RfdGFnMEBAXCI6IFwiPHA+U3DDqWNpZmllciBsYSBtw6l0aG9kZSDDoCB1dGlsaXNlciBwb3VyIHN5bWJvbGlzZXIgbGVzIHBpeGVscyBheWFudCBjaGFuZ8OpIGRlIGNsYXNzZS48L3A+PHVsPjxsaT48c3Ryb25nPlV0aWxpc2VyIGxhIG1veWVubmUgZGVzIGNvdWxldXJzIGTigJlvcmlnaW5lIGV0IGRlIGRlc3RpbmF0aW9uPC9zdHJvbmc+wqA6IGxhIGNvdWxldXIgZHUgcGl4ZWwgY29ycmVzcG9uZCDDoCBsYSBtb3llbm5lIGRlIGxhIGNvdWxldXIgZGUgc2EgY2xhc3NlIGTigJlvcmlnaW5lIGV0IGRlIGxhIGNvdWxldXIgZGUgc2EgY2xhc3NlIGRlIGRlc3RpbmF0aW9uLjwvbGk+PGxpPjxzdHJvbmc+VXRpbGlzZXIgbGVzIGNvdWxldXJzIGTigJlvcmlnaW5lPC9zdHJvbmc+wqA6IGxlIHBpeGVsIHByZW5kIGxhIGNvdWxldXIgZGUgc2EgY2xhc3NlIGTigJlvcmlnaW5lLjwvbGk+PGxpPjxzdHJvbmc+VXRpbGlzZXIgbGVzIGNvdWxldXJzIGRlIGRlc3RpbmF0aW9uPC9zdHJvbmc+wqA6IGxlIHBpeGVsIHByZW5kcmEgbGEgY291bGV1ciBkZSBzYSBjbGFzc2UgZGUgZGVzdGluYXRpb24uPC9saT48L3VsPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfZmllbGRuYW1lZm9yY2xhc3NuYW1lc2luZnJvbXJhc3Rlcl90YWcwQEBcIjogXCI8cD5DaGFtcCBzdG9ja2FudCBsZXMgbm9tcyBkZSBjbGFzc2UgZGFucyBs4oCZZW50csOpZSA8c3Ryb25nPlJhc3RlciBk4oCZb3JpZ2luZTwvc3Ryb25nPi4gTOKAmW91dGlsIHJlY2hlcmNoZSBhdXRvbWF0aXF1ZW1lbnQgbGUgY2hhbXAgPHN0cm9uZz5DbGFzc05hbWU8L3N0cm9uZz4gb3UgPHN0cm9uZz5DbGFzc19OYW1lPC9zdHJvbmc+IMOgIHV0aWxpc2VyLjwvcD48cD5VdGlsaXNleiBjZXR0ZSBvcHRpb24gc2kgbOKAmWVudHLDqWUgbmUgY29udGllbnQgcGFzIGNlcyBub21zIGRlIGNoYW1wIHN0YW5kYXJkcy48L3A+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9maWVsZG5hbWVmb3JjbGFzc25hbWVzaW50b3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5DaGFtcCBzdG9ja2FudCBsZXMgbm9tcyBkZSBjbGFzc2UgZGFucyBs4oCZZW50csOpZSA8c3Ryb25nPlJhc3RlciBkZSBkZXN0aW5hdGlvbjwvc3Ryb25nPi4gTOKAmW91dGlsIHJlY2hlcmNoZSBhdXRvbWF0aXF1ZW1lbnQgbGUgY2hhbXAgPHN0cm9uZz5DbGFzc05hbWU8L3N0cm9uZz4gb3UgPHN0cm9uZz5DbGFzc19OYW1lPC9zdHJvbmc+IMOgIHV0aWxpc2VyLjwvcD48cD5VdGlsaXNleiBjZXR0ZSBvcHRpb24gc2kgbOKAmWVudHLDqWUgbmUgY29udGllbnQgcGFzIGNlcyBub21zIGRlIGNoYW1wIHN0YW5kYXJkcy48L3A+XCIsXG5cdFwiQEBTdGF0aXN0aWNzX251bWJlcm9mY29sdW1uc190YWcwQEBcIjogXCI8cD5Ob21icmUgZGUgY29sb25uZXMgZGUgcGl4ZWxzIMOgIHV0aWxpc2VyIGRhbnMgdW5lIGRpbWVuc2lvbiBkZSB2b2lzaW5hZ2UgZm9jYWxlLjwvcD5cIixcblx0XCJAQFN0YXRpc3RpY3NfbnVtYmVyb2Zyb3dzX3RhZzBAQFwiOiBcIjxwPk5vbWJyZSBkZSBsaWduZXMgZGUgcGl4ZWxzIHF1ZSB2b3VzIHV0aWxpc2V6IGRhbnMgdW5lIGRpbWVuc2lvbiBkZSB2b2lzaW5hZ2UgZm9jYWxlLjwvcD5cIixcblx0XCJAQFN0YXRpc3RpY3Nfb25seWZpbGxub2RhdGFwaXhlbHNfdGFnMEBAXCI6IFwiPHA+Q29tYmxlIGxlcyBpbnRlcnZhbGxlcyBOb0RhdGEgZGFucyBsYSBzb3J0aWUuIENldHRlIGZvbmN0aW9uIGVzdCB1dGlsZSBsb3JzcXXigJlpbCBzZSBwZXV0IHF1ZSB2b3RyZSBpbWFnZXJpZSBhaXQgc3VwcHJpbcOpIGRlcyBsaWduZXMuPC9wPlwiLFxuXHRcIkBAU3RhdGlzdGljc19yYXN0ZXJfdGFnMEBAXCI6IFwiPHA+UmFzdGVyIGVuIGVudHLDqWUgc3VyIGxlcXVlbCByw6lhbGlzZXIgbGVzIHN0YXRpc3RpcXVlcyBmb2NhbGVzLjwvcD5cIixcblx0XCJAQFN0YXRpc3RpY3Nfc3RhdGlzdGljc3R5cGVfdGFnMEBAXCI6IFwiPHA+TGVzIHNlcHQgdHlwZXMgZGUgZm9uY3Rpb25zIHN0YXRpc3RpcXVlcyBmb2NhbGVzIHNvbnQgbGVzIHN1aXZhbnRzwqA6PC9wPjx1bD48bGk+TWluaW11bcKgOiBjYWxjdWxlIGxhIHZhbGV1ciBtaW5pbWFsZSBkZXMgcGl4ZWxzIGRhbnMgbGUgdm9pc2luYWdlLjwvbGk+PGxpPk1heGltdW3CoDogY2FsY3VsZSBsYSB2YWxldXIgbWF4aW1hbGUgZGVzIHBpeGVscyBkYW5zIGxlIHZvaXNpbmFnZS48L2xpPjxsaT5Nb3llbm5lwqA6IGNhbGN1bGUgbGEgdmFsZXVyIG1veWVubmUgZGVzIHBpeGVscyBkYW5zIGxlIHZvaXNpbmFnZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT7DiWNhcnQgdHlwZcKgOiBjYWxjdWxlIGxhIHZhbGV1ciBk4oCZw6ljYXJ0IHR5cGUgZGVzIHBpeGVscyBkYW5zIGxlIHZvaXNpbmFnZS48L2xpPjxsaT5Nw6lkaWFuZcKgOiBjYWxjdWxlIGxhIHZhbGV1ciBtw6lkaWFuZSBkZXMgcGl4ZWxzIGRhbnMgbGUgdm9pc2luYWdlLjwvbGk+PGxpPk1ham9yaXTDqcKgOiBjYWxjdWxlIGxhIG1ham9yaXTDqSBvdSBsYSB2YWxldXIgbGEgcGx1cyBmcsOpcXVlbnRlIGRlcyBwaXhlbHMgZGFucyBsZSB2b2lzaW5hZ2UuPC9saT48bGk+TWlub3JpdMOpwqA6IGNhbGN1bGUgbGEgbWlub3JpdMOpIG91IGxhIHZhbGV1ciBsYSBtb2lucyBmcsOpcXVlbnRlIGRlcyBwaXhlbHMgZGFucyBsZSB2b2lzaW5hZ2UuPC9saT48L3VsPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfY2hhbmdlZGlyZWN0aW9uX3RhZzBAQFwiOiBcIjxwPkluZGlxdWUgbGEgZGlyZWN0aW9uIGR1IGNoYW5nZW1lbnQgw6AgaW5jbHVyZSBkYW5zIGzigJlhbmFseXNlLjwvcD48cD5DZSBwYXJhbcOodHJlIGVzdCBkaXNwb25pYmxlIHVuaXF1ZW1lbnQgc2kgbGUgcmFzdGVyIGTigJlhbmFseXNlIGRlcyBjaGFuZ2VtZW50cyBlbiBlbnRyw6llIGVzdCBsYSBzb3J0aWUgZGVzIG91dGlscyBMYW5kVHJlbmRyLjwvcD48dWw+PGxpPjxzdHJvbmc+VG91dGVzIGxlcyBkaXJlY3Rpb25zPC9zdHJvbmc+wqA6IHRvdXRlcyBsZXMgZGlyZWN0aW9ucyBkZSBjaGFuZ2VtZW50IHNvbnQgaW5jbHVzZXMgZGFucyBsYSBzb3J0aWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+PHN0cm9uZz5Dcm9pc3NhbnQ8L3N0cm9uZz7CoDogc2V1bHMgbGVzIGNoYW5nZW1lbnRzIGRvbnQgbGEgZGlyZWN0aW9uIGVzdCBwb3NpdGl2ZSBvdSBjcm9pc3NhbnRlIHNvbnQgaW5jbHVzIGRhbnMgbGEgc29ydGllLjwvbGk+PGxpPjxzdHJvbmc+RMOpY3JvaXNzYW50PC9zdHJvbmc+wqA6IHNldWxzIGxlcyBjaGFuZ2VtZW50cyBkb250IGxhIGRpcmVjdGlvbiBlc3QgbsOpZ2F0aXZlIG91IGTDqWNyb2lzc2FudGUgc29udCBpbmNsdXMgZGFucyBsYSBzb3J0aWUuPC9saT48L3VsPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfY2hhbmdldHlwZV90YWcwQEBcIjogXCI8cD5JbmRpcXVlIGxlcyBpbmZvcm1hdGlvbnMgZGUgY2hhbmdlbWVudCDDoCBjYWxjdWxlci48L3A+PHVsPjxsaT48c3Ryb25nPkhldXJlIGR1IGNoYW5nZW1lbnQgbGUgcGx1cyByw6ljZW50PC9zdHJvbmc+wqA6IGNoYXF1ZSBwaXhlbCBjb21wcmVuZCBsYSBkYXRlIGRlIHNvbiBjaGFuZ2VtZW50IGxlIHBsdXMgcsOpY2VudCBkYW5zIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPjxzdHJvbmc+SGV1cmUgZHUgcHJlbWllciBjaGFuZ2VtZW50PC9zdHJvbmc+wqA6IGNoYXF1ZSBwaXhlbCBjb21wcmVuZCBsYSBkYXRlIGRlIHNvbiBwcmVtaWVyIGNoYW5nZW1lbnQgZGFucyBsYSBzw6lyaWUgY2hyb25vbG9naXF1ZS48L2xpPjxsaT48c3Ryb25nPkhldXJlIGR1IHBsdXMgZ3JhbmQgY2hhbmdlbWVudDwvc3Ryb25nPsKgOiBjaGFxdWUgcGl4ZWwgY29tcHJlbmQgbGEgZGF0ZSBkZSBzb24gY2hhbmdlbWVudCBsZSBwbHVzIGltcG9ydGFudCBkYW5zIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLjwvbGk+PGxpPjxzdHJvbmc+Tm9tYnJlIGRlIGNoYW5nZW1lbnRzPC9zdHJvbmc+wqA6IGNoYXF1ZSBwaXhlbCBjb21wcmVuZCBsZSBub21icmUgdG90YWwgZGUgZm9pcyBvw7kgaWwgYSDDqXTDqSBjaGFuZ8OpIGRhbnMgbGEgc8OpcmllIGNocm9ub2xvZ2lxdWUuPC9saT48bGk+PHN0cm9uZz5EYXRlL2hldXJlIGR1IHBsdXMgbG9uZyBjaGFuZ2VtZW50PC9zdHJvbmc+wqA6IGNoYXF1ZSBwaXhlbCBjb21wcmVuZCBsYSBkYXRlIGRlIGNoYW5nZW1lbnQgw6AgbGEgZmluIGR1IHBsdXMgbG9uZyBzZWdtZW50IGRlIHRyYW5zaXRpb24gZGUgbGEgc8OpcmllIGNocm9ub2xvZ2lxdWUuPC9saT48bGk+PHN0cm9uZz5EYXRlL2hldXJlIGR1IHBsdXMgY291cnQgY2hhbmdlbWVudDwvc3Ryb25nPsKgOiBjaGFxdWUgcGl4ZWwgY29tcHJlbmQgbGEgZGF0ZSBkZSBjaGFuZ2VtZW50IMOgIGxhIGZpbiBkdSBwbHVzIGNvdXJ0IHNlZ21lbnQgZGUgdHJhbnNpdGlvbiBkZSBsYSBzw6lyaWUgY2hyb25vbG9naXF1ZS48L2xpPjxsaT48c3Ryb25nPkRhdGUvaGV1cmUgZHUgY2hhbmdlbWVudCBsZSBwbHVzIHJhcGlkZTwvc3Ryb25nPsKgOiBjaGFxdWUgcGl4ZWwgY29tcHJlbmQgbGEgZGF0ZSBkZSBjaGFuZ2VtZW50IMOgIGxhIGZpbiBkZSBsYSB0cmFuc2l0aW9uIHF1aSBlc3Qgc3VydmVudWUgbGUgcGx1cyByYXBpZGVtZW50LjwvbGk+PGxpPjxzdHJvbmc+RGF0ZS9oZXVyZSBkdSBjaGFuZ2VtZW50IGxlIHBsdXMgbGVudDwvc3Ryb25nPsKgOiBjaGFxdWUgcGl4ZWwgY29tcHJlbmQgbGEgZGF0ZSBkZSBjaGFuZ2VtZW50IMOgIGxhIGZpbiBkZSBsYSB0cmFuc2l0aW9uIHF1aSBlc3Qgc3VydmVudWUgbGUgcGx1cyBsZW50ZW1lbnQuPC9saT48L3VsPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfZmlsdGVyYnlkdXJhdGlvbl90YWcwQEBcIjogXCI8cD5JbmRpcXVlIHNpIGxlIGZpbHRyYWdlIHPigJllZmZlY3R1ZSBzdXIgbGEgZHVyw6llIGRlcyBjaGFuZ2VtZW50cy48L3A+PHA+PC9wPjx1bD48bGk+QWN0aXbDqcKgOiBsZXMgcsOpc3VsdGF0cyBzb250IGZpbHRyw6lzIHBhciBkdXLDqWUsIGRlIGZhw6dvbiDDoCBjZSBxdWUgc2V1bHMgbGVzIGNoYW5nZW1lbnRzIGF5YW50IHVuZSBkdXLDqWUgZG9ubsOpZSBzb2llbnQgaW5jbHVzIGRhbnMgbGEgc29ydGllLjwvbGk+PGxpPkTDqXNhY3RpdsOpwqA6IGxlcyByw6lzdWx0YXRzIG5lIHNvbnQgcGFzIGZpbHRyw6lzIHBhciBkdXLDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48L3VsPjxwPkNlIHBhcmFtw6h0cmUgZXN0IGRpc3BvbmlibGUgdW5pcXVlbWVudCBzaSBsZSByYXN0ZXIgZOKAmWFuYWx5c2UgZGVzIGNoYW5nZW1lbnRzIGVuIGVudHLDqWUgZXN0IGxhIHNvcnRpZSBkZXMgb3V0aWxzIExhbmRUcmVuZHIuPC9wPjxwPlNpIGNlIHBhcmFtw6h0cmUgZXN0IGFjdGl2w6ksIHZvdXMgZGV2ZXogZMOpZmluaXIgbGVzIHBhcmFtw6h0cmVzIDxzdHJvbmc+RHVyw6llIG1pbmltYWxlPC9zdHJvbmc+IGV0IDxzdHJvbmc+RHVyw6llIG1heGltYWxlPC9zdHJvbmc+IHBvdXIgbGUgZmlsdHJhZ2UuPC9wPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfZmlsdGVyYnltYWduaXR1ZGVfdGFnMEBAXCI6IFwiPHA+SW5kaXF1ZSBzaSBsZSBmaWx0cmFnZSBz4oCZZWZmZWN0dWUgc3VyIGxhIG1hZ25pdHVkZSBkZXMgY2hhbmdlbWVudHMuIDwvcD48dWw+PGxpPkFjdGl2w6nCoDogbGVzIHLDqXN1bHRhdHMgc29udCBmaWx0csOpcyBwYXIgbWFnbml0dWRlLCBkZSBmYcOnb24gw6AgY2UgcXVlIHNldWxzIGxlcyBjaGFuZ2VtZW50cyBheWFudCB1bmUgbWFnbml0dWRlIGRvbm7DqWUgc29pZW50IGluY2x1cyBkYW5zIGxhIHNvcnRpZS48L2xpPjxsaT5Ew6lzYWN0aXbDqcKgOiBsZXMgcsOpc3VsdGF0cyBuZSBzb250IHBhcyBmaWx0csOpcyBwYXIgbWFnbml0dWRlLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PC91bD48cD5DZSBwYXJhbcOodHJlIGVzdCBkaXNwb25pYmxlIHVuaXF1ZW1lbnQgc2kgbGUgcmFzdGVyIGTigJlhbmFseXNlIGRlcyBjaGFuZ2VtZW50cyBlbiBlbnRyw6llIGVzdCBsYSBzb3J0aWUgZGVzIG91dGlscyBMYW5kVHJlbmRyLjwvcD48cD5TaSBjZSBwYXJhbcOodHJlIGVzdCBhY3RpdsOpLCB2b3VzIGRldmV6IGTDqWZpbmlyIGxlcyBwYXJhbcOodHJlcyA8c3Ryb25nPk1hZ25pdHVkZSBtaW5pbWFsZTwvc3Ryb25nPiBldCA8c3Ryb25nPk1hZ25pdHVkZSBtYXhpbWFsZTwvc3Ryb25nPiBwb3VyIGxlIGZpbHRyYWdlLjwvcD5cIixcblx0XCJAQERldGVjdC1DaGFuZ2UtVXNpbmctQ2hhbmdlLUFuYWx5c2lzX2ZpbHRlcmJ5eWVhcl90YWcwQEBcIjogXCI8cD5JbmRpcXVlIHNpIGxhIHNvcnRpZSBkb2l0IMOqdHJlIGxpbWl0w6llIMOgIHVuIG5vbWJyZSBk4oCZYW5uw6llcy4gPC9wPjx1bD48bGk+QWN0aXbDqcKgOiBsZXMgcsOpc3VsdGF0cyBzb250IGZpbHRyw6lzIGRlIGZhw6dvbiDDoCBjZSBxdWUgc2V1bHMgbGVzIGNoYW5nZW1lbnRzIHN1cnZlbnVzIGRhbnMgdW4gbm9tYnJlIGTigJlhbm7DqWVzIHNww6ljaWZpcXVlIHNvaWVudCBpbmNsdXMgZGFucyBsYSBzb3J0aWUuPC9saT48bGk+RMOpc2FjdGl2w6nCoDogbGVzIHLDqXN1bHRhdHMgbmUgc29udCBwYXMgZmlsdHLDqXMgcGFyIGFubsOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjwvdWw+PHA+U2kgY2UgcGFyYW3DqHRyZSBlc3QgYWN0aXbDqSwgdm91cyBkZXZleiBkw6lmaW5pciBsZXMgcGFyYW3DqHRyZXMgPHN0cm9uZz5WYWxldXIgbWluaW1hbGU8L3N0cm9uZz4gZXQgPHN0cm9uZz5WYWxldXIgbWF4aW1hbGU8L3N0cm9uZz4gcG91ciBsZSBmaWx0cmFnZS48L3A+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19maWx0ZXJieXN0YXJ0dmFsdWVfdGFnMEBAXCI6IFwiPHA+RmlsdHJleiBsZXMgcsOpc3VsdGF0cyBwYXIgdmFsZXVyIGRlIGTDqXBhcnQgZGUgZmHDp29uIMOgIGNlIHF1ZSBzZXVscyBsZXMgY2hhbmdlbWVudHMgZOKAmXVuZSB2YWxldXIgZGUgZMOpcGFydCBkb25uw6llIHNvaWVudCBpbmNsdXMgZGFucyBsYSBzb3J0aWUuPC9wPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfZmlsdGVyYnllbmR2YWx1ZV90YWcwQEBcIjogXCI8cD5GaWx0cmV6IGxlcyByw6lzdWx0YXRzIHBhciB2YWxldXIgZGUgZmluIGRlIGZhw6dvbiDDoCBjZSBxdWUgc2V1bHMgbGVzIGNoYW5nZW1lbnRzIGTigJl1bmUgdmFsZXVyIGRlIGZpbiBkb25uw6llIHNvaWVudCBpbmNsdXMgZGFucyBsYSBzb3J0aWUuPC9wPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfbWF4aW11bW51bWJlcm9mY2hhbmdlc190YWcwQEBcIjogXCI8cD5Ob21icmUgbWF4aW1hbCBkZSBjaGFuZ2VtZW50cyBwYXIgcGl4ZWwgw6AgY2FsY3VsZXIuIExlIG5vbWJyZSBzYWlzaSBjb3JyZXNwb25kIGF1IG5vbWJyZSBkZSBjYW5hdXggZGFucyBsZSByYXN0ZXIgZW4gc29ydGllLiBQYXIgZMOpZmF1dCwgbGEgdmFsZXVyIGVzdMKgMS4gQXV0cmVtZW50IGRpdCwgdW5lIHNldWxlIGRhdGUgZGUgY2hhbmdlbWVudCBlc3QgY2FsY3Vsw6llLCBldCBsZSByYXN0ZXIgZW4gc29ydGllIG5lIGNvbXByZW5kIHF14oCZdW5lIHNldWxlIGJhbmRlLjwvcD48cD5DZSBwYXJhbcOodHJlIG7igJllc3QgcGFzIGRpc3BvbmlibGUgc2kgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPlR5cGUgZGUgY2hhbmdlbWVudDwvc3Ryb25nPiBlc3QgZMOpZmluaSBzdXIgPHN0cm9uZz5Ob21icmUgZGUgY2hhbmdlbWVudHM8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfcmFzdGVyX3RhZzBAQFwiOiBcIjxwPlJhc3RlciBk4oCZYW5hbHlzZSBkZXMgY2hhbmdlbWVudHMgZW4gZW50csOpZS48L3A+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19zZWdtZW50ZGF0ZV90YWcwQEBcIjogXCI8cD5JbmRpcXVlIHPigJlpbCBmYXV0IGV4dHJhaXJlIGxhIGRhdGUgYXUgZMOpYnV0IG91IMOgIGxhIGZpbiBk4oCZdW4gc2VnbWVudCBkZSBjaGFuZ2VtZW50LjwvcD48cD5DZSBwYXJhbcOodHJlIGVzdCBkaXNwb25pYmxlIHVuaXF1ZW1lbnQgc2kgbGUgcmFzdGVyIGTigJlhbmFseXNlIGRlcyBjaGFuZ2VtZW50cyBlbiBlbnRyw6llIGVzdCBsYSBzb3J0aWUgZGVzIG91dGlscyBMYW5kVHJlbmRyLjwvcD48dWw+PGxpPjxzdHJvbmc+RMOpYnV0IGR1IHNlZ21lbnQ8L3N0cm9uZz7CoDogbGEgZGF0ZSBlc3QgZXh0cmFpdGUgYXUgZMOpYnV0IGTigJl1biBzZWdtZW50IGRlIGNoYW5nZW1lbnQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+PHN0cm9uZz5GaW4gZHUgc2VnbWVudDwvc3Ryb25nPsKgOiBsYSBkYXRlIGVzdCBleHRyYWl0ZSDDoCBsYSBmaW4gZOKAmXVuIHNlZ21lbnQgZGUgY2hhbmdlbWVudC48L2xpPjwvdWw+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9hcmVhdW5pdHNfdGFnMEBAXCI6IFwiPHA+VW5pdMOpcyBkZSBzdXJmYWNlIGRlcyB2YWxldXJzIGRlIGRlbnNpdMOpIGVuIHNvcnRpZS48L3A+PHVsPjxsaT5Vbml0w6kgZGUgY2FydGUgYXUgY2FycsOpwqA6IHBvdXIgbGUgY2FycsOpIGRlcyB1bml0w6lzIGxpbsOpYWlyZXMgZGUgbGEgcsOpZsOpcmVuY2Ugc3BhdGlhbGUgZW4gc29ydGllLjwvbGk+PGxpPk1pbGVzIGNhcnLDqXPCoDogcG91ciBsZXMgbWlsZXMgKFUuUy4pLjwvbGk+PGxpPktpbG9tw6h0cmVzIGNhcnLDqXPCoDogcG91ciBsZXMga2lsb23DqHRyZXMuPC9saT48bGk+QWNyZXPCoDogcG91ciBsZXMgYWNyZXMgKFUuUy4pLjwvbGk+PGxpPkhlY3RhcmVzwqA6IHBvdXIgbGVzIGhlY3RhcmVzLjwvbGk+PGxpPk3DqHRyZXMgY2FycsOpc8KgOiBwb3VyIGxlcyBtw6h0cmVzLjwvbGk+PGxpPllhcmRzIGNhcnLDqXPCoDogcG91ciBsZXMgeWFyZHMgKFUuUy4pLjwvbGk+PGxpPlBpZWRzIGNhcnLDqXPCoDogcG91ciBsZXMgcGllZHMgKFUuUy4pLjwvbGk+PGxpPlBvdWNlcyBjYXJyw6lzwqA6IHBvdXIgbGVzIHBvdWNlcyAoVS5TLikuPC9saT48bGk+Q2VudGltw6h0cmVzIGNhcnLDqXPCoDogcG91ciBsZXMgY2VudGltw6h0cmVzLjwvbGk+PGxpPk1pbGxpbcOodHJlcyBjYXJyw6lzwqA6IHBvdXIgbGVzIG1pbGxpbcOodHJlcy48L2xpPjwvdWw+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9jZWxsc2l6ZV90YWcwQEBcIjogXCI8cD5UYWlsbGUgZGUgcGl4ZWwgZHUgamV1IGRlIGRvbm7DqWVzIHJhc3RlciBlbiBzb3J0aWUuIFNpIGxhIHZhbGV1ciBkdSBwYXJhbcOodHJlIDxzdHJvbmc+VGFpbGxlIGRlIGNlbGx1bGU8L3N0cm9uZz4gYSDDqXTDqSBjb25maWd1csOpZSBkYW5zIGxlcyBlbnZpcm9ubmVtZW50cyBkZSBnw6lvdHJhaXRlbWVudCwgaWwgc+KAmWFnaXQgZGUgbGEgdmFsZXVyIHBhciBkw6lmYXV0LjwvcD5cIixcblx0XCJAQEtlcm5lbC1EZW5zaXR5X2lucHV0YmFycmllcnNfdGFnMEBAXCI6IFwiPHA+SmV1IGRlIGRvbm7DqWVzIHF1aSBkw6lmaW5pdCBsZXMgaW50ZXJydXB0aW9ucy48L3A+PHA+TGVzIGludGVycnVwdGlvbnMgcGV1dmVudCDDqnRyZSB1bmUgY291Y2hlIGTigJllbnRpdMOpcyBwb2x5bGlnbmVzIG91IHN1cmZhY2lxdWVzLjwvcD5cIixcblx0XCJAQEtlcm5lbC1EZW5zaXR5X2lucHV0ZmVhdHVyZXNfdGFnMEBAXCI6IFwiPHA+RW50aXTDqXMgcG9uY3R1ZWxsZXMgb3UgbGluw6lhaXJlcyBlbiBlbnRyw6llIHBvdXIgbGVzcXVlbGxlcyBjYWxjdWxlciBsYSBkZW5zaXTDqS48L3A+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9tZXRob2RfdGFnMEBAXCI6IFwiPHA+RMOpdGVybWluZSBz4oCZaWwgY29udmllbnQgZOKAmXV0aWxpc2VyIHVuIHBsdXMgY291cnQgY2hlbWluIHN1ciB1bmUgc3Bow6lyb8OvZGUgKGfDqW9kw6lzaXF1ZSkgb3UgdW5lIHRlcnJlIHBsYXRlIChwbGFuZSkuPC9wPjx1bD48bGk+PHN0cm9uZz5QbGFuYWlyZTwvc3Ryb25nPsKgOiB1dGlsaXNlIGRlcyBkaXN0YW5jZXMgcGxhbmVzIGVudHJlIGxlcyBlbnRpdMOpcy4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT48c3Ryb25nPkfDqW9kw6lzaXF1ZTwvc3Ryb25nPsKgOiB1dGlsaXNlIGRlcyBkaXN0YW5jZXMgZ8Opb2TDqXNpcXVlcyBlbnRyZSBsZXMgZW50aXTDqXMuIENldHRlIG3DqXRob2RlIHRpZW50IGNvbXB0ZSBkZSBsYSBjb3VyYnVyZSBkdSBzcGjDqXJvw69kZSBldCBnw6hyZSBjb3JyZWN0ZW1lbnQgbGVzIGRvbm7DqWVzIHNpdHXDqWVzIHByw6hzIGRlcyBww7RsZXMgZXQgbGEgbGlnbmUgaW50ZXJuYXRpb25hbGUgZGUgY2hhbmdlbWVudCBkZSBqb3VyLjwvbGk+PC91bD48cD5JbCBlc3QgY29uc2VpbGzDqSBk4oCZdXRpbGlzZXIgbGEgbcOpdGhvZGUgPHN0cm9uZz5Hw6lvZMOpc2lxdWU8L3N0cm9uZz4gYXZlYyBkZXMgZG9ubsOpZXMgc3RvY2vDqWVzIGRhbnMgdW4gc3lzdMOobWUgZGUgY29vcmRvbm7DqWVzIG5vbiBhcHByb3ByacOpIHBvdXIgbGVzIG1lc3VyZXMgZGUgZGlzdGFuY2UgZXQgdG91dGUgYW5hbHlzZSBjb3V2cmFudCB1bmUgem9uZSBnw6lvZ3JhcGhpcXVlIGltcG9ydGFudGUuIFBhciBleGVtcGxlLCBXZWIgTWVyY2F0b3Igb3UgdG91dCBzeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgZ8Opb2dyYXBoaXF1ZXMgZG9pdCB1dGlsaXNlciBsYSBtw6l0aG9kZSA8c3Ryb25nPkfDqW9kw6lzaXF1ZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9vdXRwdXRjZWxsdmFsdWVzX3RhZzBAQFwiOiBcIjxwPkTDqXRlcm1pbmUgY2UgcXVlIGxlcyB2YWxldXJzIGR1IHJhc3RlciBlbiBzb3J0aWUgcmVwcsOpc2VudGVudC48L3A+PHVsPjxsaT48c3Ryb25nPkRlbnNpdMOpczwvc3Ryb25nPsKgOiBsZXMgdmFsZXVycyBlbiBzb3J0aWUgcmVwcsOpc2VudGVudCBsYSB2YWxldXIgZGUgZGVuc2l0w6kgcHLDqXZ1ZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT48c3Ryb25nPlZvbHVtZXMgYXR0ZW5kdXM8L3N0cm9uZz7CoDogbGVzIHZhbGV1cnMgZW4gc29ydGllIHJlcHLDqXNlbnRlbnQgbOKAmWludGVuc2l0w6kgcHLDqXZ1ZSBkdSBwaMOpbm9tw6huZSBkYW5zIGNoYXF1ZSBwaXhlbC4gUHVpc3F1ZSBsYSB2YWxldXIgZGUgcGl4ZWwgZXN0IGxpw6llIMOgIGxhIHZhbGV1ciBkdSBwYXJhbcOodHJlIDxzdHJvbmc+VGFpbGxlIGRlIGNlbGx1bGU8L3N0cm9uZz4gc3DDqWNpZmnDqWUsIGlsIGVzdCBpbXBvc3NpYmxlIGRlIHLDqS3DqWNoYW50aWxsb25uZXIgbGUgcmFzdGVyIHLDqXN1bHRhbnQgc3VyIHVuZSBhdXRyZSB0YWlsbGUgZGUgcGl4ZWwsIGNhciBpbCByZXByw6lzZW50ZSBs4oCZaW50ZW5zaXTDqSBkdSBwaMOpbm9tw6huZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9wb3B1bGF0aW9uZmllbGRfdGFnMEBAXCI6IFwiPHA+Q2hhbXAgaW5kaXF1YW50IGxlcyB2YWxldXJzIGRlIHBvcHVsYXRpb24gcG91ciBjaGFxdWUgZW50aXTDqS4gTGEgdmFsZXVyIGR1IHBhcmFtw6h0cmUgPHN0cm9uZz5DaGFtcCBkZSBwb3B1bGF0aW9uPC9zdHJvbmc+IHJlcHLDqXNlbnRlIGxlIHRvdGFsIG91IGxhIHF1YW50aXTDqSDDoCByw6lwYXJ0aXIgc3VyIHRvdXQgbGUgcGF5c2FnZSBwb3VyIGNyw6llciB1bmUgc3VyZmFjZSBjb250aW51ZS4gTGUgcGFyYW3DqHRyZSA8c3Ryb25nPkNoYW1wIGRlIHBvcHVsYXRpb248L3N0cm9uZz4gcGV1dCBjb250ZW5pciBkZXMgdmFsZXVycyBlbnRpw6hyZXMgb3Ugw6AgdmlyZ3VsZSBmbG90dGFudGUuPC9wPjxwPkxlcyBvcHRpb25zIGV0IGxlcyBjb21wb3J0ZW1lbnRzIHBhciBkw6lmYXV0IHBvdXIgbGUgY2hhbXAgc29udCByw6lwZXJ0b3Jpw6lzIGNpLWRlc3NvdXMgcGFyIG9yZHJlIGRlIHByaW9yaXTDqS48L3A+PHVsPjxsaT5VdGlsaXNleiA8c3Ryb25nPkF1Y3VuPC9zdHJvbmc+IHNpIGF1Y3VuIMOpbMOpbWVudCBvdSB2YWxldXIgc3DDqWNpYWxlIG7igJllc3QgdXRpbGlzw6kgZXQgcXVlIGNoYXF1ZSBlbnRpdMOpIGVzdCBjb21wdMOpZSB1bmUgc2V1bGUgZm9pcy48L2xpPjxsaT5VdGlsaXNleiA8c3Ryb25nPlNoYXBlPC9zdHJvbmc+IHNpIGxlcyBlbnRpdMOpcyBlbiBlbnRyw6llIGNvbnRpZW5uZW50IGRlcyB2YWxldXJzIHouPC9saT48bGk+U2lub24sIGxlIGNoYW1wIHBhciBkw6lmYXV0IGVzdCA8c3Ryb25nPlBPUFVMQVRJT048L3N0cm9uZz4sIG91IHRvdXRlIGTDqXJpdsOpZSBhY2NlcHRhYmxlIGRlIGxhIHBvcHVsYXRpb27CoDo8dWw+PGxpPjxzdHJvbmc+UE9QVUxBVElPTnh4eHg8L3N0cm9uZz4gb8O5IDxzdHJvbmc+eHh4eDwvc3Ryb25nPiByZXByw6lzZW50ZSBu4oCZaW1wb3J0ZSBxdWVsIGNhcmFjdMOocmUgdmFsaWRlLCB0ZWwgcXVlIDxzdHJvbmc+UE9QVUxBVElPTjY8L3N0cm9uZz4sIDxzdHJvbmc+UE9QVUxBVElPTjE5NzQ8L3N0cm9uZz4sIG91IDxzdHJvbmc+UE9QVUxBVElPTlJPQURUWVBFPC9zdHJvbmc+LjwvbGk+PGxpPjxzdHJvbmc+UE9QPC9zdHJvbmc+LjwvbGk+PGxpPjxzdHJvbmc+UE9QeHh4eDwvc3Ryb25nPi48L2xpPjxsaT5TaSBhdWN1bmUgZGVzIGNvbmRpdGlvbnMgY2ktZGVzc3VzIG5lIHPigJlhcHBsaXF1ZSwgbGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCA8c3Ryb25nPkF1Y3VuPC9zdHJvbmc+LjwvbGk+PC91bD48L2xpPjwvdWw+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9zZWFyY2hyYWRpdXNfdGFnMEBAXCI6IFwiPHA+UmF5b24gZGUgcmVjaGVyY2hlIGRhbnMgbGVxdWVsIGxlIGNhbGN1bCBkZSBsYSBkZW5zaXTDqSBlc3QgZWZmZWN0dcOpLiBMZXMgdW5pdMOpcyBzb250IGJhc8OpZXMgc3VyIGzigJl1bml0w6kgbGluw6lhaXJlIGRlIGxhIHByb2plY3Rpb24uPC9wPjxwPlBhciBleGVtcGxlLCBzaSBsZXMgdW5pdMOpcyBzb250IGV4cHJpbcOpZXMgZW4gbcOodHJlcyBwb3VyIGluY2x1cmUgdG91dGVzIGxlcyBlbnRpdMOpcyBkYW5zIHVuIHZvaXNpbmFnZSBk4oCZdW4gbWlsZSwgZMOpZmluaXNzZXogbGUgcmF5b24gZGUgcmVjaGVyY2hlIHN1ciAxwqA2MDksMzQ0IChjYXIgMcKgbWlsZcKgPcKgMcKgNjA5LDM0NMKgbcOodHJlcykuPC9wPlwiLFxuXHRcIkBAWm9uYWwtU3RhdGlzdGljc19pZ25vcmVub2RhdGFpbmNhbGN1bGF0aW9uc190YWcwQEBcIjogXCI8cD5JbmRpcXVlIHNpIGxlcyB2YWxldXJzIDxzdHJvbmc+Tm9EYXRhPC9zdHJvbmc+IGRhbnMgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyczwvc3Ryb25nPiBpbmZsdWVuY2VudCBsZXMgcsOpc3VsdGF0cyBkZSBsYSB6b25lIGRhbnMgbGFxdWVsbGUgZWxsZXMgc2UgdHJvdXZlbnQuPC9wPjx1bD48bGk+PHN0cm9uZz5PdWk8L3N0cm9uZz7CoDogZGFucyB1bmUgem9uZSBwYXJ0aWN1bGnDqHJlLCBzZXVscyBsZXMgcGl4ZWxzIHF1aSBvbnQgdW5lIHZhbGV1ciBkYW5zIGxlIDxzdHJvbmc+cmFzdGVyIGRlIHZhbGV1cnM8L3N0cm9uZz4gc29udCB1dGlsaXPDqXMgcG91ciBkw6l0ZXJtaW5lciBsYSB2YWxldXIgZW4gc29ydGllIGRlIGNldHRlIHpvbmUuIExlcyBwaXhlbHMgPHN0cm9uZz5Ob0RhdGE8L3N0cm9uZz4gZGFucyBsZSA8c3Ryb25nPlJhc3RlciBkZSB2YWxldXJzPC9zdHJvbmc+IHNvbnQgaWdub3LDqWVzIGRhbnMgbGUgY2FsY3VsIHN0YXRpc3RpcXVlLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPjxzdHJvbmc+Tm9uPC9zdHJvbmc+wqA6IGRhbnMgdW5lIHpvbmUgcGFydGljdWxpw6hyZSwgc+KAmWlsIGV4aXN0ZSBkZXMgcGl4ZWxzIDxzdHJvbmc+Tm9EYXRhPC9zdHJvbmc+IGRhbnMgbGUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyczwvc3Ryb25nPiwgb24gY29uc2lkw6hyZSBxdWUgbGVzIGluZm9ybWF0aW9ucyBzb250IGluc3VmZmlzYW50ZXMgcG91ciBleMOpY3V0ZXIgZGVzIGNhbGN1bHMgc3RhdGlzdGlxdWVzIHBvdXIgbOKAmWVuc2VtYmxlIGRlcyBwaXhlbHMgZGUgY2V0dGUgem9uZS4gUGFyIGNvbnPDqXF1ZW50LCBsYSB6b25lIGVudGnDqHJlIHJlw6dvaXQgbGEgdmFsZXVyIDxzdHJvbmc+Tm9EYXRhPC9zdHJvbmc+IHN1ciBsZSByYXN0ZXIgZW4gc29ydGllLjwvbGk+PC91bD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3NfcGVyY2VudGlsZWludGVycG9sYXRpb250eXBlX3RhZzBAQFwiOiBcIjxwPkTDqXRlcm1pbmUgbGEgbcOpdGhvZGUgZOKAmWludGVycG9sYXRpb24gZW4gY2VudGlsZSDDoCB1dGlsaXNlciBsb3JzcXVlIGxlIG5vbWJyZSBkZSB2YWxldXJzIGR1IHJhc3RlciBlbiBlbnRyw6llIMOgIGNhbGN1bGVyIGVzdCBwYWlyLjwvcD48dWw+PGxpPjxzdHJvbmc+RMOpdGVjdGlvbiBhdXRvbWF0aXF1ZTwvc3Ryb25nPsKgOiBzaSBsZSB0eXBlIGRlIHBpeGVsIGR1IHJhc3RlciBkZSB2YWxldXJzIGVuIGVudHLDqWUgZXN0IGRlIHR5cGUgZW50aWVyLCBsYSBtw6l0aG9kZSA8c3Ryb25nPkxlIHBsdXMgcHJvY2hlPC9zdHJvbmc+IGVzdCB1dGlsaXPDqWUuIFNpIGxlIHR5cGUgZGUgcGl4ZWwgZHUgcmFzdGVyIGRlIHZhbGV1cnMgZW4gZW50csOpZSBlc3QgZGUgdHlwZSB2aXJndWxlIGZsb3R0YW50ZSwgbGEgbcOpdGhvZGUgPHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz4gZXN0IHV0aWxpc8OpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT48c3Ryb25nPkxhIHBsdXMgcHJvY2hlPC9zdHJvbmc+wqA6IGxhIHZhbGV1ciBkaXNwb25pYmxlIGxhIHBsdXMgcHJvY2hlIGR1IGNlbnRpbGUgc291aGFpdMOpIGVzdCB1dGlsaXPDqWUuIERhbnMgY2UgY2FzLCBsZSB0eXBlIGRlIHBpeGVsIGVuIHNvcnRpZSBlc3QgaWRlbnRpcXVlIMOgIGNlbHVpIGR1IHJhc3RlciBkZSB2YWxldXJzIGVuIGVudHLDqWUuPC9saT48bGk+PHN0cm9uZz5MaW7DqWFpcmU8L3N0cm9uZz7CoDogbGEgbW95ZW5uZSBwb25kw6lyw6llIGRlcyBkZXV4IHZhbGV1cnMgZW52aXJvbm5hbnRlcyBkdSBjZW50aWxlIHNvdWhhaXTDqSBlc3QgdXRpbGlzw6llLiBEYW5zIGNlIGNhcywgbGUgdHlwZSBkZSBwaXhlbCBlbiBzb3J0aWUgZXN0IMOgIHZpcmd1bGUgZmxvdHRhbnRlLjwvbGk+PC91bD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3NfcGVyY2VudGlsZXZhbHVlX3RhZzBAQFwiOiBcIjxwPlBlcmNlbnRpbGUgw6AgY2FsY3VsZXIuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgZGUgOTAsIHNvaXQgbGUgOTDDqG1lIGNlbnRpbGUuPC9wPjxwPkxlcyB2YWxldXJzIHBldXZlbnQgc+KAmcOpY2hlbG9ubmVyIGRlIDAgw6AgMTAwLiBMZSBjZW50aWxlIG7CsMKgMCBlc3Qgw6lxdWl2YWxlbnQgw6AgbGEgc3RhdGlzdGlxdWUgTWluaW11bSB0YW5kaXMgcXVlIGxlIDEwMMOoIGNlbnRpbGUgw6lxdWl2YXV0IGF1IE1heGltdW0uIDwvcD5VbmUgdmFsZXVyIGRlIDUwIGRvbm5lIGxlIG3Dqm1lIHLDqXN1bHRhdCBxdWUgbGEgc3RhdGlzdGlxdWUgTcOpZGlhbmUuXCIsXG5cdFwiQEBab25hbC1TdGF0aXN0aWNzX3Byb2Nlc3Nhc211bHRpZGltZW5zaW9uYWxfdGFnMEBAXCI6IFwiPHA+RMOpdGVybWluZSBsZSBtb2RlIGRlIHRyYWl0ZW1lbnQgZHUgcmFzdGVyIGRlIHZhbGV1cnMgbXVsdGlkaW1lbnNpb25uZWxsZXMgZW4gZW50csOpZS48L3A+PHVsPjxsaT48c3Ryb25nPlRyYW5jaGUgYWN0dWVsbGU8L3N0cm9uZz7CoDogbGVzIHN0YXRpc3RpcXVlcyBzb250IGNhbGN1bMOpZXMgw6AgcGFydGlyIGRlIGxhIHRyYW5jaGUgYWN0dWVsbGUgZOKAmXVuIGpldSBkZSBkb25uw6llcyBtdWx0aWRpbWVuc2lvbm5lbGxlcy4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT48c3Ryb25nPlRvdXRlcyBsZXMgdHJhbmNoZXM8L3N0cm9uZz7CoDogbGVzIHN0YXRpc3RpcXVlcyBzb250IGNhbGN1bMOpZXMgcG91ciB0b3V0ZXMgbGVzIGRpbWVuc2lvbnMgKHBhciBleGVtcGxlLCB0ZW1wcyBvdSBwcm9mb25kZXVyKSBk4oCZdW4gamV1IGRlIGRvbm7DqWVzIG11bHRpZGltZW5zaW9ubmVsbGVzLjwvbGk+PC91bD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3Nfc3RhdGlzdGljc3R5cGVfdGFnMEBAXCI6IFwiPHA+VHlwZSBkZSBzdGF0aXN0aXF1ZSDDoCBjYWxjdWxlci48L3A+PHVsPjxsaT48c3Ryb25nPk1veWVubmXCoDwvc3Ryb25nPsKgOiBjYWxjdWxlIGxhIG1veWVubmUgZGUgdG91cyBsZXMgcGl4ZWxzIGRhbnMgbGUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyczwvc3Ryb25nPiBxdWkgYXBwYXJ0aWVubmVudCDDoCBsYSBtw6ptZSB6b25lIHF1ZSBsZSBwaXhlbCBlbiBzb3J0aWUuPC9saT48bGk+PHN0cm9uZz5NYWpvcml0w6k8L3N0cm9uZz7CoDpkw6l0ZXJtaW5lIGxhIHZhbGV1ciBxdWkgc2UgcHJvZHVpdCBsZSBwbHVzIHNvdXZlbnQgcGFybWkgdG91cyBsZXMgcGl4ZWxzIGR1IDxzdHJvbmc+UmFzdGVyIGRlIHZhbGV1cnM8L3N0cm9uZz4gcXVpIGFwcGFydGllbm5lbnQgw6AgbGEgbcOqbWUgem9uZSBxdWUgbGUgcGl4ZWwgZW4gc29ydGllLjwvbGk+PGxpPjxzdHJvbmc+TWF4aW11bTwvc3Ryb25nPsKgOiBkw6l0ZXJtaW5lIGxhIHBsdXMgZ3JhbmRlIHZhbGV1ciBwYXJtaSB0b3VzIGxlcyBwaXhlbHMgZHUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyczwvc3Ryb25nPiBxdWkgYXBwYXJ0aWVubmVudCDDoCBsYSBtw6ptZSB6b25lIHF1ZSBsZSBwaXhlbCBlbiBzb3J0aWUuPC9saT48bGk+PHN0cm9uZz5Nw6lkaWFuZTwvc3Ryb25nPsKgOiBkw6l0ZXJtaW5lIGxhIHZhbGV1ciBtw6lkaWFuZSBwYXJtaSB0b3VzIGxlcyBwaXhlbHMgZHUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyczwvc3Ryb25nPiBxdWkgYXBwYXJ0aWVubmVudCDDoCBsYSBtw6ptZSB6b25lIHF1ZSBsZSBwaXhlbCBlbiBzb3J0aWUuPC9saT48bGk+PHN0cm9uZz5NaW5pbXVtPC9zdHJvbmc+wqA6IGTDqXRlcm1pbmUgbGEgcGx1cyBwZXRpdGUgdmFsZXVyIHBhcm1pIHRvdXMgbGVzIHBpeGVscyBkdSA8c3Ryb25nPlJhc3RlciBkZSB2YWxldXJzPC9zdHJvbmc+IHF1aSBhcHBhcnRpZW5uZW50IMOgIGxhIG3Dqm1lIHpvbmUgcXVlIGxlIHBpeGVsIGVuIHNvcnRpZS48L2xpPjxsaT48c3Ryb25nPk1pbm9yaXTDqTwvc3Ryb25nPsKgOiBkw6l0ZXJtaW5lIGxhIHZhbGV1ciBxdWkgc2UgcHJvZHVpdCBsZSBtb2lucyBzb3V2ZW50IHBhcm1pIHRvdXMgbGVzIHBpeGVscyBkdSA8c3Ryb25nPlJhc3RlciBkZSB2YWxldXJzPC9zdHJvbmc+IHF1aSBhcHBhcnRpZW5uZW50IMOgIGxhIG3Dqm1lIHpvbmUgcXVlIGxlIHBpeGVsIGVuIHNvcnRpZS48L2xpPjxsaT48c3Ryb25nPlBlcmNlbnRpbGU8L3N0cm9uZz7CoDogY2FsY3VsZSB1biBwb3VyY2VudGFnZSBkZSB0b3VzIGxlcyBwaXhlbHMgZGFucyBsZSA8c3Ryb25nPlJhc3RlciBkZSB2YWxldXJzPC9zdHJvbmc+IHF1aSBhcHBhcnRpZW5uZW50IMOgIGxhIG3Dqm1lIHpvbmUgcXVlIGxlIHBpeGVsIGVuIHNvcnRpZS4gTGUgOTDDqCBjZW50aWxlIGVzdCBjYWxjdWzDqSBwYXIgZMOpZmF1dC4gVm91cyBwb3V2ZXogZMOpdGVybWluZXIgbGUgcG91cmNlbnRhZ2Ugw6AgY2FsY3VsZXIgw6AgbOKAmWFpZGUgZHUgcGFyYW3DqHRyZSA8c3Ryb25nPlZhbGV1ciBkZSBjZW50aWxlPC9zdHJvbmc+LjwvbGk+PGxpPjxzdHJvbmc+UGxhZ2U8L3N0cm9uZz7CoDogY2FsY3VsZSBs4oCZw6ljYXJ0IGVudHJlIGxhIHBsdXMgcGV0aXRlIHZhbGV1ciBldCBsYSBwbHVzIGdyYW5kZSB2YWxldXIgcGFybWkgdG91cyBsZXMgcGl4ZWxzIGR1IDxzdHJvbmc+UmFzdGVyIGRlIHZhbGV1cnM8L3N0cm9uZz4gcXVpIGFwcGFydGllbm5lbnQgw6AgbGEgbcOqbWUgem9uZSBxdWUgbGUgcGl4ZWwgZW4gc29ydGllLjwvbGk+PGxpPjxzdHJvbmc+w4ljYXJ0IHR5cGU8L3N0cm9uZz7CoDogY2FsY3VsZSBs4oCZw6ljYXJ0IHR5cGUgZGUgdG91cyBsZXMgcGl4ZWxzIGRhbnMgbGUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyczwvc3Ryb25nPiBxdWkgYXBwYXJ0aWVubmVudCDDoCBsYSBtw6ptZSB6b25lIHF1ZSBsZSBwaXhlbCBlbiBzb3J0aWUuPC9saT48bGk+PHN0cm9uZz5Tb21tZTwvc3Ryb25nPsKgOiBjYWxjdWxlIGxhIHZhbGV1ciB0b3RhbGUgZGUgdG91cyBsZXMgcGl4ZWxzIGRhbnMgbGUgPHN0cm9uZz5SYXN0ZXIgZGUgdmFsZXVyczwvc3Ryb25nPiBxdWkgYXBwYXJ0aWVubmVudCDDoCBsYSBtw6ptZSB6b25lIHF1ZSBsZSBwaXhlbCBlbiBzb3J0aWUuPC9saT48bGk+PHN0cm9uZz5WYXJpw6l0w6k8L3N0cm9uZz7CoDogY2FsY3VsZSBsZSBub21icmUgZGUgdmFsZXVycyB1bmlxdWVzIHBvdXIgdG91cyBsZXMgcGl4ZWxzIGR1IDxzdHJvbmc+UmFzdGVyIGRlIHZhbGV1cnM8L3N0cm9uZz4gcXVpIGFwcGFydGllbm5lbnQgw6AgbGEgbcOqbWUgem9uZSBxdWUgbGUgcGl4ZWwgZW4gc29ydGllLjwvbGk+PC91bD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3NfdmFsdWVyYXN0ZXJfdGFnMEBAXCI6IFwiPHA+UmFzdGVyIGNvbnRlbmFudCBsZXMgdmFsZXVycyBzdXIgbGVzcXVlbGxlcyB2b3VzIHZvdWxleiBjYWxjdWxlciB1bmUgc3RhdGlzdGlxdWUuPC9wPlwiLFxuXHRcIkBAWm9uYWwtU3RhdGlzdGljc196b25lZmllbGRfdGFnMEBAXCI6IFwiPHA+Q2hhbXAgY29udGVuYW50IGxlcyB2YWxldXJzIHF1aSBkw6lmaW5pc3NlbnQgY2hhcXVlIHpvbmUuIElsIHBldXQgc+KAmWFnaXIgZOKAmXVuIGNoYW1wIGRlIHR5cGUgZW50aWVyIG91IGNoYcOubmUgZHUgcmFzdGVyIGRlIHpvbmVzLjwvcD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3Nfem9uZXJhc3Rlcl90YWcwQEBcIjogXCI8cD5KZXUgZGUgZG9ubsOpZXMgZMOpZmluaXNzYW50IGxlcyB6b25lcy4gTGVzIHpvbmVzIHBldXZlbnQgw6p0cmUgZMOpZmluaWVzIHBhciB1biByYXN0ZXIgZGUgdHlwZSBlbnRpZXIuPC9wPlwiLFxuXHRcIkBAWm9uYWwtU3RhdGlzdGljc19jYWxjdWxhdGVjaXJjdWxhcnN0YXRpc3RpY3NfdGFnMEBAXCI6IFwiPHA+RMOpdGVybWluZSBsZSBtb2RlIGRlIGNhbGN1bCBkdSB0eXBlIGRlIHN0YXRpc3RpcXVlLjwvcD48dWw+PGxpPjxzdHJvbmc+QXJpdGhtw6l0aXF1ZTwvc3Ryb25nPsKgOiBjYWxjdWxlIGRlcyBzdGF0aXN0aXF1ZXMgYXJpdGhtw6l0aXF1ZXMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+PHN0cm9uZz5DaXJjdWxhaXJlPC9zdHJvbmc+wqA6IGNhbGN1bGUgbGVzIHN0YXRpc3RpcXVlcyBjaXJjdWxhaXJlcyBhcHByb3ByacOpZXMgYXV4IHF1YW50aXTDqXMgY3ljbGlxdWVzLCB0ZWxsZXMgcXVlIGxhIGRpcmVjdGlvbiBkZSBsYSBib3Vzc29sZSBlbiBkZWdyw6lzLCBsZXMgam91cm7DqWVzIG91IGxhIHBhcnRpZSBkw6ljaW1hbGUgZGVzIG5vbWJyZXMgcsOpZWxzLjwvbGk+PC91bD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3NfY2lyY3VsYXJ3cmFwdmFsdWVfdGFnMEBAXCI6IFwiPHA+VmFsZXVyIHBvc3NpYmxlIGxhIHBsdXMgw6lsZXbDqWUgKGxpbWl0ZSBzdXDDqXJpZXVyZSkgZGFucyBsZXMgZG9ubsOpZXMgY3ljbGlxdWVzLiBJbCBz4oCZYWdpdCBk4oCZdW4gbm9tYnJlIHBvc2l0aWYgZG9udCBsYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0wqAzNjAuIENldHRlIHZhbGV1ciByZXByw6lzZW50ZSDDqWdhbGVtZW50IGxhIG3Dqm1lIHF1YW50aXTDqSBxdWUgbGEgdmFsZXVyIHBvc3NpYmxlIGxhIHBsdXMgZmFpYmxlIChsaW1pdGUgaW5mw6lyaWV1cmUpLjwvcD48cD5DZSBwYXJhbcOodHJlIG7igJllc3QgYXBwbGljYWJsZSBxdWUgbG9yc3F1ZSBkZXMgc3RhdGlzdGlxdWVzIGNpcmN1bGFpcmVzIHNvbnQgY2FsY3Vsw6llcy48L3A+XCIsXG5cdFwiQEBCb3VuZGFyeS1DbGVhbi1mdW5jdGlvbl9pbnB1dHJhc3Rlcl90YWcwQEBcIjogXCI8cD5SYXN0ZXIgZW4gZW50csOpZSBkb250IGxhIGxpbWl0ZSBlbnRyZSBsZXMgem9uZXMgZG9pdCDDqnRyZSBsaXNzw6llLjwvcD48cD5JbCBkb2l0IMOqdHJlIGRlIHR5cGUgZW50aWVyLjwvcD5cIixcblx0XCJAQEJvdW5kYXJ5LUNsZWFuLWZ1bmN0aW9uX3J1bmV4cGFuc2lvbmFuZHNocmlua2luZ3R3aWNlX3RhZzBAQFwiOiBcIjxwPkluZGlxdWUgbGUgbm9tYnJlIGTigJlleMOpY3V0aW9ucyBkdSBsaXNzYWdlwqA6IHVuZSBvdSBkZXV4IGZvaXMuIDwvcD48dWw+PGxpPjxwPjxzdHJvbmc+QWN0aXbDqTwvc3Ryb25nPsKgOiBs4oCZb3DDqXJhdGlvbiBk4oCZZXhwYW5zaW9uIGV0IGRlIGNvbnRyYWN0aW9uIGVzdCBlZmZlY3R1w6llIGRldXggZm9pcy4gTGEgcHJlbWnDqHJlIGZvaXMsIGzigJlvcMOpcmF0aW9uIGVzdCBlZmZlY3R1w6llIHNlbG9uIGxlIHR5cGUgZGUgdHJpIHNww6ljaWZpw6kuIEVuc3VpdGUsIHVuZSBvcMOpcmF0aW9uIGTigJlleHBhbnNpb24gZXQgZGUgY29udHJhY3Rpb24gc3VwcGzDqW1lbnRhaXJlIGVzdCBlZmZlY3R1w6llIGF2ZWMgbGEgcHJpb3JpdMOpIGludmVyc2UuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9wPjwvbGk+PGxpPjxwPjxzdHJvbmc+RMOpc2FjdGl2w6k8L3N0cm9uZz7CoDogbOKAmW9ww6lyYXRpb24gZOKAmWV4cGFuc2lvbiBldCBkZSBjb250cmFjdGlvbiBlc3QgZWZmZWN0dcOpZSB1bmUgc2V1bGUgZm9pcyBlbiBmb25jdGlvbiBkdSB0eXBlIGRlIHRyaS4gPC9wPjwvbGk+PC91bD5cIixcblx0XCJAQEJvdW5kYXJ5LUNsZWFuLWZ1bmN0aW9uX3NvcnR0eXBlX3RhZzBAQFwiOiBcIjxwPkluZGlxdWUgbGUgdHlwZSBkZSB0cmkgw6AgdXRpbGlzZXIgZGFucyBsZSBwcm9jZXNzdXMgZGUgbGlzc2FnZS4gQ2VsdWktY2kgZMOpZmluaXQgbGEgcHJpb3JpdMOpIGRlcyBjZWxsdWxlcyDDoCDDqXRlbmRyZSBkYW5zIGxldXIgdm9pc2luYWdlLjwvcD48cD5MZSB0cmkgcGV1dCDDqnRyZSBiYXPDqSBzdXIgbGEgdmFsZXVyIGRlIGxhIHpvbmUgb3Ugc3VyIGxhIHN1cmZhY2UgZGUgbGEgem9uZS48L3A+PHVsPjxsaT48cD48c3Ryb25nPk5lIHBhcyB0cmllcjwvc3Ryb25nPsKgOiBsZXMgem9uZXMgbmUgc29udCBwYXMgdHJpw6llcyBwYXIgdGFpbGxlLiBMZXMgem9uZXMgZG90w6llcyBkZSB2YWxldXJzIHBsdXMgaW1wb3J0YW50ZXMgc29udCBwcmlvcml0YWlyZXMgcG91ciBz4oCZw6l0ZW5kcmUgZGFucyBkZXMgem9uZXMgw6AgdmFsZXVycyBtb2luZHJlcyBkYW5zIGxhIHNvcnRpZSBsaXNzw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvcD48L2xpPjxsaT48cD48c3Ryb25nPkTDqWNyb2lzc2FudDwvc3Ryb25nPsKgOiB0cmllIGxlcyB6b25lcyBwYXIgb3JkcmUgZGUgdGFpbGxlIGTDqWNyb2lzc2FudC4gTGVzIHpvbmVzIGRvdMOpZXMgZGUgc3VyZmFjZXMgdG90YWxlcyBwbHVzIGltcG9ydGFudGVzIHNvbnQgcHJpb3JpdGFpcmVzIHBvdXIgcyfDqXRlbmRyZSBkYW5zIGRlcyB6b25lcyDDoCBzdXJmYWNlcyB0b3RhbGVzIG1vaW5kcmVzLiBDZXR0ZSBvcHRpb24gdGVuZCDDoCDDqWxpbWluZXIgb3Ugw6AgcsOpZHVpcmUgbGEgcHLDqXZhbGVuY2UgZGVzIGNlbGx1bGVzIGRlcyB6b25lcyBwbHVzIHBldGl0ZXMgZGFucyBsYSBzb3J0aWUgbGlzc8OpZS48L3A+PC9saT48bGk+PHA+PHN0cm9uZz5Dcm9pc3NhbnQ8L3N0cm9uZz7CoDogdHJpZSBsZXMgem9uZXMgcGFyIG9yZHJlIGRlIHRhaWxsZSBjcm9pc3NhbnQuIExlcyB6b25lcyBkb3TDqWVzIGRlIHN1cmZhY2VzIHRvdGFsZXMgcGx1cyByw6lkdWl0ZXMgc29udCBwcmlvcml0YWlyZXMgcG91ciBzJ8OpdGVuZHJlIGRhbnMgZGVzIHpvbmVzIMOgIHN1cmZhY2VzIHRvdGFsZXMgcGx1cyBpbXBvcnRhbnRlcy4gQ2V0dGUgb3B0aW9uIHRlbmQgw6AgY29uc2VydmVyIG91IMOgIGF1Z21lbnRlciBsYSBwcsOpdmFsZW5jZSBkZXMgY2VsbHVsZXMgZGVzIHpvbmVzIHBsdXMgcGV0aXRlcyBkYW5zIGxhIHNvcnRpZSBsaXNzw6llLjwvcD48L2xpPjwvdWw+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF9kaW1lbnNpb25fdGFnMEBAXCI6IFwiPHA+RGltZW5zaW9uIGRlIGzigJlhZ3LDqWdhdGlvbi4gSWwgc+KAmWFnaXQgZGUgbGEgZGltZW5zaW9uIHN1ciBsYXF1ZWxsZSBsZXMgdmFyaWFibGVzIHNvbnQgYWdyw6lnw6llcy48L3A+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzBAQFwiOiBcIjxwPkluZGlxdWUgbGEgbcOpdGhvZGUgw6AgdXRpbGlzZXIgcG91ciBmaWx0cmVyIGxlcyBkb25uw6llcyBtdWx0aWRpbWVuc2lvbm5lbGxlcyBlbiBlbnRyw6llIGF2YW50IGTigJllZmZlY3R1ZXIgbOKAmWFncsOpZ2F0aW9uLjwvcD48dWw+PGxpPjxzdHJvbmc+VG91dDwvc3Ryb25nPsKgOiBsYSBwbGFnZSBjb21wbMOodGUgZGUgY2hhcXVlIGRpbWVuc2lvbiBlc3QgdXRpbGlzw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPjxzdHJvbmc+UGFyIHZhbGV1cnM8L3N0cm9uZz7CoDogbGEgZGltZW5zaW9uIGVzdCBkw6ljb3Vww6llIGVuIHRyYW5jaGVzIHNlbG9uIHVuZSB2YWxldXIgZGUgbGEgZGltZW5zaW9uIG91IHVuZSBsaXN0ZSBkZSB2YWxldXJzLjwvbGk+PGxpPjxzdHJvbmc+UGFyIHBsYWdlczwvc3Ryb25nPsKgOiBsYSBkaW1lbnNpb24gZXN0IGTDqWNvdXDDqWUgZW4gdHJhbmNoZXMgc2Vsb24gdW5lIHBsYWdlIG91IHVuZSBsaXN0ZSBkZSBwbGFnZXMuPC9saT48bGk+PHN0cm9uZz5QYXIgaXTDqXJhdGlvbjwvc3Ryb25nPsKgOiBsYSBkaW1lbnNpb24gZXN0IGTDqWNvdXDDqWUgZW4gdHJhbmNoZXMgc2Vsb24gdW5lIHRhaWxsZSBk4oCZaW50ZXJ2YWxsZSBwcsOpY2lzw6llLjwvbGk+PC91bD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX2l0ZXJhdGlvbmRlZmluaXRpb25wYXJhbWV0ZXJzX3RhZzBAQFwiOiBcIjxwPkxlcyBwYXJhbcOodHJlcyBkZSBkw6lmaW5pdGlvbiBkZSBs4oCZaXTDqXJhdGlvbiBwZXJtZXR0ZW50IGRlIGTDqWZpbmlyIGxlcyB2YWxldXJzIGRlIGxhIGRpbWVuc2lvbiDDoCB1dGlsaXNlciBwb3VyIGZpbHRyZXIgbGVzIGRvbm7DqWVzIG11bHRpZGltZW5zaW9ubmVsbGVzIGVuIGVudHLDqWUgYXV4IGZpbnMgZOKAmWFuYWx5c2UgbG9yc3F1ZSBsZSBwYXJhbcOodHJlIDxzdHJvbmc+RMOpZmluaXRpb24gZGUgbGEgZGltZW5zaW9uPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPlBhciBpdMOpcmF0aW9uPC9zdHJvbmc+LjwvcD48dWw+PGxpPjxzdHJvbmc+RGltZW5zaW9uPC9zdHJvbmc+wqA6IGxhIGRpbWVuc2lvbiDDoCB1dGlsaXNlciBwb3VyIGxlIGZpbHRyYWdlLjwvbGk+PGxpPjxzdHJvbmc+RMOpYnV0IGRlIGxhIHByZW1pw6hyZSBpdMOpcmF0aW9uPC9zdHJvbmc+wqA6IGTDqWJ1dCBkdSBwcmVtaWVyIGludGVydmFsbGUuIENldCBpbnRlcnZhbGxlIGVzdCBlbXBsb3nDqSBwb3VyIGzigJlpdMOpcmF0aW9uIGF1IHNlaW4gZHUgamV1IGRlIGRvbm7DqWVzLjwvbGk+PGxpPjxzdHJvbmc+RmluIGRlIGxhIHByZW1pw6hyZSBpdMOpcmF0aW9uPC9zdHJvbmc+wqA6IGZpbiBkdSBwcmVtaWVyIGludGVydmFsbGUuIENldCBpbnRlcnZhbGxlIGVzdCBlbXBsb3nDqSBwb3VyIGzigJlpdMOpcmF0aW9uIGF1IHNlaW4gZHUgamV1IGRlIGRvbm7DqWVzLjwvbGk+PGxpPjxzdHJvbmc+w4l0YXBlPC9zdHJvbmc+wqA6IGZyw6lxdWVuY2Ugw6AgbGFxdWVsbGUgbGVzIGRvbm7DqWVzIHNvbnQgZMOpY291cMOpZXMgZW4gdHJhbmNoZXMuPC9saT48bGk+PHN0cm9uZz5Vbml0w6k8L3N0cm9uZz7CoDogdW5pdMOpIGRlIGzigJlpdMOpcmF0aW9uLjwvbGk+PC91bD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX2tleXdvcmRpbnRlcnZhbF90YWcwQEBcIjogXCI8cD5TcMOpY2lmaWUgbGUgbW90LWNsw6kgZGUgbOKAmWludGVydmFsbGUgw6AgdXRpbGlzZXIgbG9ycyBkZSBs4oCZYWdyw6lnYXRpb24gc3VyIGxhIGRpbWVuc2lvbi48L3A+PHA+Q2UgcGFyYW3DqHRyZSBlc3QgcmVxdWlzIGxvcnNxdWUgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPlR5cGU8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+TW90LWNsw6kgZGUgbOKAmWludGVydmFsbGU8L3N0cm9uZz4uPC9wPjx1bD48bGk+PHN0cm9uZz5QYXIgaGV1cmU8L3N0cm9uZz7CoDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBzZWxvbiBkZXMgaW50ZXJ2YWxsZXMgaG9yYWlyZXMgZXQgbGUgcsOpc3VsdGF0IGNvbXByZW5kIGNoYXF1ZSBoZXVyZSBkZSBsYSBzw6lyaWUgY2hyb25vbG9naXF1ZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT48c3Ryb25nPlBhciBqb3VyPC9zdHJvbmc+wqA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgc2Vsb24gZGVzIGludGVydmFsbGVzIHF1b3RpZGllbnMgZXQgbGUgcsOpc3VsdGF0IGNvbXByZW5kIGNoYXF1ZSBqb3VyIGRlIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLjwvbGk+PGxpPjxzdHJvbmc+UGFyIHNlbWFpbmU8L3N0cm9uZz7CoDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBzZWxvbiBkZXMgaW50ZXJ2YWxsZXMgaGViZG9tYWRhaXJlcyBldCBsZSByw6lzdWx0YXQgY29tcHJlbmQgY2hhcXVlIHNlbWFpbmUgZGUgbGEgc8OpcmllIGNocm9ub2xvZ2lxdWUuPC9saT48bGk+PHN0cm9uZz5QYXIgZGl4wqBqb3Vyczwvc3Ryb25nPsKgOiBsZXMgdmFsZXVycyBkZXMgZG9ubsOpZXMgc29udCBhZ3LDqWfDqWVzIGVuIDPCoHDDqXJpb2RlcyBkZSAxMMKgam91cnMgY2hhY3VuZS4gTGEgZGVybmnDqHJlIHDDqXJpb2RlIHBldXQgY29udGVuaXIgcGx1cyBvdSBtb2lucyBkZSAxMMKgam91cnMuIExhIHNvcnRpZSBjb21wcmVuZCAzwqB0cmFuY2hlcyBwb3VyIGNoYXF1ZSBtb2lzLjwvbGk+PGxpPjxzdHJvbmc+UGFyIGNpbnHCoGpvdXJzPC9zdHJvbmc+wqA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgZW4gNsKgcMOpcmlvZGVzIGRlIDXCoGpvdXJzIGNoYWN1bmUuIExhIGRlcm5pw6hyZSBww6lyaW9kZSBwZXV0IGNvbnRlbmlyIHBsdXMgb3UgbW9pbnMgZGUgNcKgam91cnMuIExhIHNvcnRpZSBjb21wcmVuZCA2wqB0cmFuY2hlcyBwb3VyIGNoYXF1ZSBtb2lzLjwvbGk+PGxpPjxzdHJvbmc+UGFyIG1vaXM8L3N0cm9uZz7CoDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBzZWxvbiBkZXMgaW50ZXJ2YWxsZXMgbWVuc3VlbHMgZXQgbGUgcsOpc3VsdGF0IGNvbXByZW5kIGNoYXF1ZSBtb2lzIGRlIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLjwvbGk+PGxpPjxzdHJvbmc+UGFyIHRyaW1lc3RyZTwvc3Ryb25nPsKgOiBsZXMgdmFsZXVycyBkZXMgZG9ubsOpZXMgc29udCBhZ3LDqWfDqWVzIHNlbG9uIGRlcyBpbnRlcnZhbGxlcyB0cmltZXN0cmllbHMgZXQgbGUgcsOpc3VsdGF0IGNvbXByZW5kIGNoYXF1ZSB0cmltZXN0cmUgZGUgbGEgc8OpcmllIGNocm9ub2xvZ2lxdWUuPC9saT48bGk+PHN0cm9uZz5QYXIgYW48L3N0cm9uZz7CoDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBzZWxvbiBkZXMgaW50ZXJ2YWxsZXMgYW5udWVscyBldCBsZSByw6lzdWx0YXQgY29tcHJlbmQgY2hhcXVlIGFubsOpZSBkZSBsYSBzw6lyaWUgY2hyb25vbG9naXF1ZS48L2xpPjxsaT48c3Ryb25nPlLDqWN1cnJlbmNlIHF1b3RpZGllbm5lPC9zdHJvbmc+wqA6IGxlcyB2YWxldXJzIGRlcyBkb25uw6llcyBzb250IGFncsOpZ8OpZXMgc2Vsb24gZGVzIGludGVydmFsbGVzIHF1b3RpZGllbnMgZXQgbGUgcsOpc3VsdGF0IGNvbXByZW5kIHVuZSB2YWxldXIgYWdyw6lnw6llIHBhciBqb3VyIGR1IGNhbGVuZHJpZXIganVsaWVuLiBMYSBzb3J0aWUgY29tcHJlbmQgYXUgbWF4aW11bSAzNjbCoHRyYW5jaGVzIHRlbXBvcmVsbGVzIHF1b3RpZGllbm5lcy48L2xpPjxsaT48c3Ryb25nPlLDqWN1cnJlbmNlIGhlYmRvbWFkYWlyZTwvc3Ryb25nPsKgOiBsZXMgdmFsZXVycyBkZXMgZG9ubsOpZXMgc29udCBhZ3LDqWfDqWVzIHNlbG9uIGRlcyBpbnRlcnZhbGxlcyBoZWJkb21hZGFpcmVzIGV0IGxlIHLDqXN1bHRhdCBjb21wcmVuZCB1bmUgdmFsZXVyIGFncsOpZ8OpZSBwYXIgc2VtYWluZS4gTGEgc29ydGllIGNvbXByZW5kIGF1IG1heGltdW0gNTPCoHRyYW5jaGVzIHRlbXBvcmVsbGVzIGhlYmRvbWFkYWlyZXMuPC9saT48bGk+PHN0cm9uZz5Sw6ljdXJyZW5jZSBtZW5zdWVsbGU8L3N0cm9uZz7CoDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBzZWxvbiBkZXMgaW50ZXJ2YWxsZXMgbWVuc3VlbHMgZXQgbGUgcsOpc3VsdGF0IGNvbXByZW5kIHVuZSB2YWxldXIgYWdyw6lnw6llIHBhciBtb2lzLiBMYSBzb3J0aWUgY29tcHJlbmQgYXUgbWF4aW11bSAxMsKgdHJhbmNoZXMgdGVtcG9yZWxsZXMgbWVuc3VlbGxlcy48L2xpPjxsaT48c3Ryb25nPlLDqWN1cnJlbmNlIHRyaW1lc3RyaWVsbGU8L3N0cm9uZz7CoDogbGVzIHZhbGV1cnMgZGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcyBzZWxvbiBkZXMgaW50ZXJ2YWxsZXMgdHJpbWVzdHJpZWxzIGV0IGxlIHLDqXN1bHRhdCBjb21wcmVuZCB1bmUgdmFsZXVyIGFncsOpZ8OpZSBwYXIgdHJpbWVzdHJlLiBMYSBzb3J0aWUgY29tcHJlbmQgYXUgbWF4aW11bSA0wqB0cmFuY2hlcyB0ZW1wb3JlbGxlcyB0cmltZXN0cmllbGxlcy48L2xpPjwvdWw+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF9vcGVyYXRpb25fdGFnMEBAXCI6IFwiPHA+SW5kaXF1ZSBsYSBtw6l0aG9kZSBtYXRow6ltYXRpcXVlIHV0aWxpc8OpZSBwb3VyIGNvbWJpbmVyIGxlcyB0cmFuY2hlcyBhZ3LDqWfDqWVzIGRhbnMgdW4gaW50ZXJ2YWxsZS48L3A+PHVsPjxsaT48c3Ryb25nPk1ham9yaXTDqTwvc3Ryb25nPsKgOiB2YWxldXIgZGUgcGl4ZWwgbGEgcGx1cyBmcsOpcXVlbnRlLCBjYWxjdWzDqWUgc3VyIHRvdXRlcyBsZXMgdHJhbmNoZXMgY29tcHJpc2VzIGRhbnMgbOKAmWludGVydmFsbGUuPC9saT48bGk+PHN0cm9uZz5NYXhpbXVtPC9zdHJvbmc+wqA6IHZhbGV1ciBtYXhpbWFsZSBk4oCZdW4gcGl4ZWwsIGNhbGN1bMOpZSBzdXIgdG91dGVzIGxlcyB0cmFuY2hlcyBjb21wcmlzZXMgZGFucyBs4oCZaW50ZXJ2YWxsZS48L2xpPjxsaT48c3Ryb25nPk1veWVubmU8L3N0cm9uZz7CoDogbW95ZW5uZSBkZXMgdmFsZXVycyBk4oCZdW4gcGl4ZWwsIGNhbGN1bMOpZSBzdXIgdG91dGVzIGxlcyB0cmFuY2hlcyBjb21wcmlzZXMgZGFucyBs4oCZaW50ZXJ2YWxsZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT48c3Ryb25nPk3DqWRpYW5lPC9zdHJvbmc+wqA6IHZhbGV1ciBtw6lkaWFuZSBk4oCZdW4gcGl4ZWwsIGNhbGN1bMOpZSBzdXIgdG91dGVzIGxlcyB0cmFuY2hlcyBjb21wcmlzZXMgZGFucyBs4oCZaW50ZXJ2YWxsZS48L2xpPjxsaT48c3Ryb25nPk1pbmltdW08L3N0cm9uZz7CoDogdmFsZXVyIG1pbmltYWxlIGTigJl1biBwaXhlbCwgY2FsY3Vsw6llIHN1ciB0b3V0ZXMgbGVzIHRyYW5jaGVzIGNvbXByaXNlcyBkYW5zIGzigJlpbnRlcnZhbGxlLjwvbGk+PGxpPjxzdHJvbmc+TWlub3JpdMOpPC9zdHJvbmc+wqA6IHZhbGV1ciBkZSBwaXhlbCBsYSBtb2lucyBmcsOpcXVlbnRlLCBjYWxjdWzDqWUgc3VyIHRvdXRlcyBsZXMgdHJhbmNoZXMgY29tcHJpc2VzIGRhbnMgbOKAmWludGVydmFsbGUuPC9saT48bGk+PHN0cm9uZz5QbGFnZTwvc3Ryb25nPsKgOiBwbGFnZSBkZXMgdmFsZXVycyBk4oCZdW4gcGl4ZWwsIGNhbGN1bMOpZSBzdXIgdG91dGVzIGxlcyB0cmFuY2hlcyBjb21wcmlzZXMgZGFucyBs4oCZaW50ZXJ2YWxsZS48L2xpPjxsaT48c3Ryb25nPsOJY2FydCB0eXBlPC9zdHJvbmc+wqA6IMOpY2FydCB0eXBlIGRlcyB2YWxldXJzIGTigJl1biBwaXhlbCwgY2FsY3Vsw6kgc3VyIHRvdXRlcyBsZXMgdHJhbmNoZXMgY29tcHJpc2VzIGRhbnMgbOKAmWludGVydmFsbGUuPC9saT48bGk+PHN0cm9uZz5Tb21tZTwvc3Ryb25nPsKgOiBzb21tZSBkZXMgdmFsZXVycyBk4oCZdW4gcGl4ZWwsIGNhbGN1bMOpZSBzdXIgdG91dGVzIGxlcyB0cmFuY2hlcyBjb21wcmlzZXMgZGFucyBs4oCZaW50ZXJ2YWxsZS48L2xpPjxsaT48c3Ryb25nPlZhcmnDqXTDqTwvc3Ryb25nPsKgOiBub21icmUgZGUgdmFsZXVycyBkZSBwaXhlbCB1bmlxdWVzLCBjYWxjdWzDqSBzdXIgdG91dGVzIGxlcyB0cmFuY2hlcyBjb21wcmlzZXMgZGFucyBs4oCZaW50ZXJ2YWxsZS48L2xpPjwvdWw+PHA+Q2hhY3VuZSBkZSBjZXMgb3B0aW9ucyBhIMOpZ2FsZW1lbnQgdW5lIG9wdGlvbiBJZ25vcmVyIE5vRGF0YSDDqXF1aXZhbGVudGUuIEVsbGUgcGVybWV0IGTigJllZmZlY3R1ZXIgbOKAmW9ww6lyYXRpb24gbWF0aMOpbWF0aXF1ZSBzdXIgdG91cyBsZXMgcGl4ZWxzIHZhbGlkZXMgZGUgbGEgZGltZW5zaW9uIGV0IGTigJlpZ25vcmVyIGxlcyBwaXhlbHMgTm9EYXRhLjwvcD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX3Jhbmdlc190YWcwQEBcIjogXCI8cD5QbGFnZXMgZOKAmWludGVydmFsbGUgc3DDqWNpZmnDqWVzIGRhbnMgdW5lIHRhYmxlLCB1dGlsaXPDqWVzIHBvdXIgYWdyw6lnZXIgZGVzIGdyb3VwZXMgZGUgdmFsZXVycy4gTGVzIHZhbGV1cnMgbWluaW1hbGVzIGV0IG1heGltYWxlcyBkw6l0ZXJtaW5lbnQgbGEgcGxhZ2Ugw6AgaW5jbHVyZS48L3A+PHA+Q2UgcGFyYW3DqHRyZSBlc3QgcmVxdWlzIGxvcnNxdWUgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPlR5cGU8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UGxhZ2VzIGTigJlpbnRlcnZhbGxlPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5SYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgZW4gZW50csOpZS48L3A+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF90eXBlX3RhZzBAQFwiOiBcIjxwPlNww6ljaWZpZSBs4oCZaW50ZXJ2YWxsZSBkaW1lbnNpb25uZWwgcG91ciBsZXF1ZWwgbGVzIGRvbm7DqWVzIHNvbnQgYWdyw6lnw6llcy48L3A+PHVsPjxsaT48c3Ryb25nPlRvdXQ8L3N0cm9uZz7CoDogbGVzIGRvbm7DqWVzIGRlcyB2YXJpYWJsZXMgc29udCBhZ3LDqWfDqWVzIHN1ciB0b3V0ZXMgbGVzIHRyYW5jaGVzLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPjxzdHJvbmc+TW90LWNsw6kgZGUgbOKAmWludGVydmFsbGU8L3N0cm9uZz7CoDogbGVzIGRvbm7DqWVzIGRlcyB2YXJpYWJsZXMgc29udCBhZ3LDqWfDqWVzIMOgIGzigJlhaWRlIGTigJl1biBpbnRlcnZhbGxlIGNvdXJhbnQgY29ubnUuPC9saT48bGk+PHN0cm9uZz5WYWxldXIgZOKAmWludGVydmFsbGU8L3N0cm9uZz7CoDogbGVzIGRvbm7DqWVzIGRlcyB2YXJpYWJsZXMgc29udCBhZ3LDqWfDqWVzIMOgIGzigJlhaWRlIGTigJl1biBpbnRlcnZhbGxlIGV0IGTigJl1bmUgdW5pdMOpIGTDqWZpbmlzIHBhciBs4oCZdXRpbGlzYXRldXIuPC9saT48bGk+PHN0cm9uZz5QbGFnZXMgZOKAmWludGVydmFsbGU8L3N0cm9uZz7CoDogbGVzIGRvbm7DqWVzIGRlcyB2YXJpYWJsZXMgc29udCBhZ3LDqWfDqWVzIGVudHJlIGxlcyBwYWlyZXMgZGUgdmFsZXVycyBvdSBkZSBkYXRlcyBzcMOpY2lmacOpZXMuPC9saT48L3VsPlwiLFxuXHRcIkBAQWdncmVnYXRlLU11bHRpZGltZW5zaW9uYWxfdmFsdWVpbnRlcnZhbF90YWcwQEBcIjogXCI8cD5UYWlsbGUgZGUgbOKAmWludGVydmFsbGUgw6AgdXRpbGlzZXIgcG91ciBs4oCZYWdyw6lnYXRpb24uPC9wPjxwPkNlIHBhcmFtw6h0cmUgZXN0IHJlcXVpcyBsb3JzcXVlIGxlIHBhcmFtw6h0cmU8c3Ryb25nPlR5cGU8L3N0cm9uZz5lc3QgZMOpZmluaSBzdXI8c3Ryb25nPlZhbGV1ciBk4oCZaW50ZXJ2YWxsZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF92YWx1ZXNfdGFnMEBAXCI6IFwiPHA+TGVzIHZhbGV1cnMgZGUgbGEgZGltZW5zaW9uIMOgIHV0aWxpc2VyIHBvdXIgZmlsdHJlciBsZXMgZG9ubsOpZXMgbXVsdGlkaW1lbnNpb25uZWxsZXMgZW4gZW50csOpZSBhdXggZmlucyBk4oCZYW5hbHlzZS4gQ2UgcGFyYW3DqHRyZSBlc3QgcmVxdWlzIGxvcnNxdWUgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPkTDqWZpbml0aW9uIGRlIGxhIGRpbWVuc2lvbjwvc3Ryb25nPiBlc3QgZMOpZmluaSBzdXIgPHN0cm9uZz5QYXIgdmFsZXVyczwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF92YXJpYWJsZXNfdGFnMEBAXCI6IFwiPHA+TGEgb3UgbGVzIHZhcmlhYmxlcyBxdWkgc29udCBhZ3LDqWfDqWVzIHN1ciBsYSBkaW1lbnNpb24gZG9ubsOpZS48L3A+XCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVJlZ3Jlc3Npb25faW5wdXRkZWZpbml0aW9uZmlsZV90YWcwQEBcIjogXCI8cD5GaWNoaWVyIGRlIGTDqWZpbml0aW9uIGRlIHLDqWdyZXNzaW9uIEVzcmkgKDxzdHJvbmc+LmVjZDwvc3Ryb25nPikgZW4gZW50csOpZSBxdWkgY29udGllbnQgbGVzIHN0YXRpc3RpcXVlcyBldCBsZXMgaW5mb3JtYXRpb25zIHBvdXIgbGUgamV1IGRlIGRvbm7DqWVzIHNww6ljaWZpcXVlLCBsZSBtb2TDqGxlIGRlIHLDqWdyZXNzaW9uIGV0IGxlcyBhdHRyaWJ1dHMgY2hvaXNpcy48L3A+XCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVJlZ3Jlc3Npb25fcmFzdGVyc190YWcwQEBcIjogXCI8cD5KZXUgb3UgamV1eCBkZSBkb25uw6llcyByYXN0ZXIgcmVwcsOpc2VudGFudCBsZXMgdmFyaWFibGVzIGRlIHByw6l2aXNpb24uIElsIHBldXQgc+KAmWFnaXIgZOKAmXVuIHJhc3RlciDDoCB1bmUgc2V1bGUgYmFuZGUgb3Ugw6AgcGx1c2lldXJzIGJhbmRlcywgZOKAmXVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbCwgZOKAmXVuIGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUgb3UgZOKAmXVuIGVuc2VtYmxlIGRlIHJhc3RlcnMuPC9wPlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX29wZXJhdGlvbl90YWcwQEBcIjogXCI8cD5UeXBlIGRlIGNhbGN1bCBzdGF0aXN0aXF1ZSBxdWUgdm91cyBzb3VoYWl0ZXogZWZmZWN0dWVyLjwvcD48cD5MZXMgc3RhdGlzdGlxdWVzIGRpc3BvbmlibGVzIHNvbnQgbGVzIHN1aXZhbnRlc8KgOjxzdHJvbmc+TWFqb3JpdMOpPC9zdHJvbmc+LDxzdHJvbmc+TWF4aW11bTwvc3Ryb25nPiw8c3Ryb25nPk1veWVubmU8L3N0cm9uZz4sPHN0cm9uZz5Nw6lkaWFuZTwvc3Ryb25nPiw8c3Ryb25nPk1pbmltdW08L3N0cm9uZz4sPHN0cm9uZz5NaW5vcml0w6k8L3N0cm9uZz4sPHN0cm9uZz5DZW50aWxlPC9zdHJvbmc+LDxzdHJvbmc+UGxhZ2U8L3N0cm9uZz4sPHN0cm9uZz7DiWNhcnQgdHlwZTwvc3Ryb25nPiw8c3Ryb25nPlNvbW1lPC9zdHJvbmc+IGV0PHN0cm9uZz5WYXJpw6l0w6k8L3N0cm9uZz4uPC9wPjxwPkxhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3Q8c3Ryb25nPk1veWVubmU8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBAQ29sb3JtYXAtVG8tUkdCX3JhbmRvbWx5YXNzaWduY29sb3J0b3VubWFwcGVkcGl4ZWxzX3RhZzBAQFwiOiBcIjxwPkxlcyBjb3VsZXVycyBzb250IGF0dHJpYnXDqWVzIGRlIG1hbmnDqHJlIGFsw6lhdG9pcmUgYXV4IHBpeGVscyBub24gaW5jbHVzIGRhbnMgbGEgcGFsZXR0ZSBkZSBjb3VsZXVycy48L3A+PHVsPjxsaT5Ew6lzYWN0aXbDqcKgOiBhdWN1bmUgY291bGV1ciBu4oCZZXN0IGF0dHJpYnXDqWUgYXV4IHBpeGVscyBub24gYXBwYXJpw6lzLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPkFjdGl2w6nCoDogdW5lIGNvdWxldXIgZXN0IGF0dHJpYnXDqWUgYXV4IHBpeGVscyBub24gYXBwYXJpw6lzLjwvbGk+PC91bD5cIixcblx0XCJAQFBhbnNoYXJwZW5fc2Vuc29yX3RhZzBAQFwiOiBcIjxwPkxvcnNxdWUgbOKAmWFsZ29yaXRobWUgR3JhbS1TY2htaWR0IGVzdCBjaG9pc2ksIHZvdXMgcG91dmV6IMOpZ2FsZW1lbnQgc3DDqWNpZmllciBsZSBjYXB0ZXVyIGR1IHJhc3RlciBtdWx0aWNhbmFsIGVuIGVudHLDqWUuIExlIGNob2l4IGR1IHR5cGUgZGUgY2FwdGV1ciBkw6lmaW5pdCBsZXMgcG9uZMOpcmF0aW9ucyBkZSBjYW5hbCBhcHByb3ByacOpZXMuPC9wPlwiLFxuXHRcIkBARGltZW5zaW9uYWwtTW92aW5nLVN0YXRpc3RpY3NfYmFja3dhcmR3aW5kb3dfdGFnMEBAXCI6IFwiPHA+VmFsZXVyIGR1IG5vbWJyZSBkZSBjb3VwZXMgYXZhbnQgb3UgYXUtZGVzc3VzIMOgIGluY2x1cmUgZGFucyBsYSBmZW7DqnRyZSBkw6lmaW5pZS4gTGEgdmFsZXVyIGRvaXQgw6p0cmUgdW4gZW50aWVyIHBvc2l0aWYgY29tcHJpcyBlbnRyZcKgMSBldMKgMTAwLiBMYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0wqAxLjwvcD48cD5M4oCZdW5pdMOpIGRlIGNlIHBhcmFtw6h0cmUgZXN0IGxhIGNvdXBlLjwvcD5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX2NpcmN1bGFyd3JhcHZhbHVlX3RhZzBAQFwiOiBcIjxwPlZhbGV1ciBhbGxhbnQgw6p0cmUgdXRpbGlzw6llIHBvdXIgYXJyb25kaXIgdW5lIHZhbGV1ciBsaW7DqWFpcmUgw6AgbGEgcGxhZ2UgZOKAmXVuZSBtb3llbm5lIGNpcmN1bGFpcmUgZG9ubsOpZS48L3A+PHA+U2EgdmFsZXVyIGRvaXQgw6p0cmUgcG9zaXRpdmUuIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgMzYwwqBkZWdyw6lzPC9wPi5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX2RpbWVuc2lvbl90YWcwQEBcIjogXCI8cD5Ob20gZGUgbGEgZGltZW5zaW9uIGxlIGxvbmcgZGUgbGFxdWVsbGUgbGEgZmVuw6p0cmUgc2UgZMOpcGxhY2UuPC9wPjxwPkxhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgbGEgcHJlbWnDqHJlIGRpbWVuc2lvbiBhdXRyZSBxdWUgeCx5IHRyb3V2w6llIGRhbnMgbGUgcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsIGVuIGVudHLDqWUuPC9wPlwiLFxuXHRcIkBARGltZW5zaW9uYWwtTW92aW5nLVN0YXRpc3RpY3NfZm9yd2FyZHdpbmRvd190YWcwQEBcIjogXCI8cD5WYWxldXIgZHUgbm9tYnJlIGRlIGNvdXBlcyBhcHLDqHMgb3UgYXUtZGVzc291cyDDoCBpbmNsdXJlIGRhbnMgbGEgZmVuw6p0cmUgZMOpZmluaWUuIExhIHZhbGV1ciBkb2l0IMOqdHJlIHVuIGVudGllciBwb3NpdGlmIGNvbXByaXMgZW50cmXCoDEgZXTCoDEwMC4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdMKgMS48L3A+PHA+TOKAmXVuaXTDqSBkZSBjZSBwYXJhbcOodHJlIGVzdCBsYSBjb3VwZS48L3A+XCIsXG5cdFwiQEBEaW1lbnNpb25hbC1Nb3ZpbmctU3RhdGlzdGljc19pbnB1dHJhc3Rlcl90YWcwQEBcIjogXCI8cD5MZSByYXN0ZXIgZW4gZW50csOpZSBuZSBwZXV0IMOqdHJlIHF14oCZdW4gcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsIGF1IGZvcm1hdCBDbG91ZCBSYXN0ZXIgRm9ybWF0IChmaWNoaWVyPHN0cm9uZz4uY3JmPC9zdHJvbmc+KS48L3A+XCIsXG5cdFwiQEBEaW1lbnNpb25hbC1Nb3ZpbmctU3RhdGlzdGljc19ub2RhdGFoYW5kbGluZ190YWcwQEBcIjogXCI8cD5JbmRpcXVlIGNvbW1lbnQgbGVzIHZhbGV1cnMgTm9EYXRhIHNvbnQgdHJhaXTDqWVzIHBhciBsZSBjYWxjdWwgZGUgc3RhdGlzdGlxdWVzLjwvcD48dWw+PGxpPjxzdHJvbmc+RG9ubsOpZXM8L3N0cm9uZz7CoDogbGVzIHZhbGV1cnMgTm9EYXRhIGRlIGxhIHZhbGV1ciBlbiBlbnRyw6llIHNvbnQgaWdub3LDqWVzIGRhbnMgbGVzIHLDqXN1bHRhdHMgZGUgbGEgZmVuw6p0cmUgZMOpZmluaWUgZGFucyBsYXF1ZWxsZSBlbGxlcyBzZSB0cm91dmVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT48c3Ryb25nPk5vRGF0YTwvc3Ryb25nPsKgOiBsZXMgdmFsZXVycyBlbiBzb3J0aWUgc29udCBOb0RhdGEgc+KAmWlsIGV4aXN0ZSBkZXMgdmFsZXVycyBOb0RhdGEgZGFucyBs4oCZZW50csOpZSBkYW5zIGxhIGZlbsOqdHJlIGTDqWZpbmllLjwvbGk+PGxpPjxzdHJvbmc+UmVtcGxpciBsZXMgdmFsZXVycyBOb0RhdGE8L3N0cm9uZz7CoDogbGVzIHZhbGV1cnMgZGUgY2VsbHVsZSBOb0RhdGEgc29udCByZW1wbGFjw6llcyDDoCBs4oCZYWlkZSBkZSBsYSBzdGF0aXN0aXF1ZSBzw6lsZWN0aW9ubsOpZSBkYW5zIGxhIGZlbsOqdHJlIGTDqWZpbmllLjwvbGk+PC91bD5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX3BlcmNlbnRpbGVpbnRlcnBvbGF0aW9udHlwZV90YWcwQEBcIjogXCI8cD5Ew6lmaW5pdCBsYSBtw6l0aG9kZSBk4oCZaW50ZXJwb2xhdGlvbiDDoCB1dGlsaXNlciBsb3JzcXVlIGxhIHZhbGV1ciBkZSBjZW50aWxlIHNlIHNpdHVlIGVudHJlIGRldXggdmFsZXVycyBkZSBjZWxsdWxlLjwvcD48dWw+PGxpPjxzdHJvbmc+RMOpdGVjdGlvbiBhdXRvbWF0aXF1ZTwvc3Ryb25nPsKgOiBzaSBsZSByYXN0ZXIgZW4gZW50csOpZSBlc3QgZGUgdHlwZSBlbnRpZXIsIGxhIG3DqXRob2RlPHN0cm9uZz5MZSBwbHVzIHByb2NoZTwvc3Ryb25nPiBlc3QgdXRpbGlzw6llLiBTaSBsZSByYXN0ZXIgZW4gZW50csOpZSBlc3QgZGUgdHlwZSBwaXhlbCBmbG90dGFudCwgbGEgbcOpdGhvZGU8c3Ryb25nPkxpbsOpYWlyZTwvc3Ryb25nPmVzdCB1dGlsaXPDqWUuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+PHN0cm9uZz5MZSBwbHVzIHByb2NoZTwvc3Ryb25nPsKgOiBsYSB2YWxldXIgZGlzcG9uaWJsZSBsYSBwbHVzIHByb2NoZSBkdSBjZW50aWxlIHNvdWhhaXTDqSBlc3QgdXRpbGlzw6llLiBEYW5zIGNlIGNhcywgbGUgdHlwZSBkZSBwaXhlbCBlbiBzb3J0aWUgZXN0IGlkZW50aXF1ZSDDoCBjZWx1aSBkdSByYXN0ZXIgZGUgdmFsZXVycyBlbiBlbnRyw6llLjwvbGk+PGxpPjxzdHJvbmc+TGluw6lhaXJlPC9zdHJvbmc+wqA6IGxhIG1veWVubmUgcG9uZMOpcsOpZSBkZXMgZGV1eCB2YWxldXJzIGVudmlyb25uYW50ZXMgZHUgY2VudGlsZSBzb3VoYWl0w6kgZXN0IHV0aWxpc8OpZS4gRGFucyBjZSBjYXMsIGxlIHR5cGUgZGUgcGl4ZWwgZW4gc29ydGllIGVzdCDDoCB2aXJndWxlIGZsb3R0YW50ZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBEaW1lbnNpb25hbC1Nb3ZpbmctU3RhdGlzdGljc19wZXJjZW50aWxldmFsdWVfdGFnMEBAXCI6IFwiPHA+Q2VudGlsZSBjYWxjdWzDqSBsb3JzcXVlIGxlIHR5cGUgZGUgc3RhdGlzdGlxdWU8c3Ryb25nPkNlbnRpbGU8L3N0cm9uZz5lc3Qgc8OpbGVjdGlvbm7DqS4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCBkZcKgOTAsIHNvaXQgbGUgOTBlwqBjZW50aWxlLjwvcD48cD5MZXMgdmFsZXVycyBwZXV2ZW50IGFsbGVyIGRlwqAwIMOgwqAxMDAuIExlIGNlbnRpbGUgbsKwwqAwIMOpcXVpdmF1dCBlc3NlbnRpZWxsZW1lbnQgw6AgbGEgc3RhdGlzdGlxdWUgbWluaW1hbGUgdGFuZGlzIHF1ZSBsZSAxMDBlwqBjZW50aWxlIMOpcXVpdmF1dCDDoCBsYSBzdGF0aXN0aXF1ZSBtYXhpbWFsZSwgw6AgY2VjaSBwcsOocyBxdWUgbGUgcsOpc3VsdGF0IGVzdCB1bmUgdmlyZ3VsZSBmbG90dGFudGUuIFVuZSB2YWxldXIgZGUgNTAgZ8OpbsOocmUgbGUgbcOqbWUgcsOpc3VsdGF0IHF1ZSBsYSBzdGF0aXN0aXF1ZSBNw6lkaWFuZS48L3A+XCIsXG5cdFwiQEBEaW1lbnNpb25hbC1Nb3ZpbmctU3RhdGlzdGljc19zdGF0aXN0aWNzdHlwZV90YWcwQEBcIjogXCI8cD5TcMOpY2lmaWUgbGUgdHlwZSBkZSBzdGF0aXN0aXF1ZSDDoCBjYWxjdWxlci48L3A+PHA+PC9wPjx1bD48bGk+PHN0cm9uZz5Nb3llbm5lPC9zdHJvbmc+wqA6IGxhIG1veWVubmUgKHZhbGV1ciBtb3llbm5lKSBkZXMgY2VsbHVsZXMgZGFucyBsYSBmZW7DqnRyZSBkw6lmaW5pZSBlc3QgY2FsY3Vsw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPjxzdHJvbmc+TW95ZW5uZSBjaXJjdWxhaXJlPC9zdHJvbmc+wqA6IGxhIG1veWVubmUgY2lyY3VsYWlyZSBkZXMgY2VsbHVsZXMgZGFucyBsYSBmZW7DqnRyZSBkw6lmaW5pZSBlc3QgY2FsY3Vsw6llLiBMb3JzcXVlIGNlIHR5cGUgZGUgc3RhdGlzdGlxdWUgZXN0IHPDqWxlY3Rpb25uw6ksIGxlIHBhcmFtw6h0cmU8c3Ryb25nPlZhbGV1ciBkZSByZXBsaSBjaXJjdWxhaXJlPC9zdHJvbmc+ZGV2aWVudCBkaXNwb25pYmxlLjwvbGk+PGxpPjxzdHJvbmc+TWFqb3JpdMOpPC9zdHJvbmc+wqA6IGxhIG1ham9yaXTDqSAodmFsZXVyIGxhIHBsdXMgZnLDqXF1ZW50ZSkgZGVzIGNlbGx1bGVzIGRhbnMgbGEgZmVuw6p0cmUgZMOpZmluaWUgZXN0IGlkZW50aWZpw6llLjwvbGk+PGxpPjxzdHJvbmc+TWF4aW11bTwvc3Ryb25nPsKgOiBsZSBtYXhpbXVtICh2YWxldXIgbGEgcGx1cyDDqWxldsOpZSkgZGVzIGNlbGx1bGVzIGRhbnMgbGEgZmVuw6p0cmUgZMOpZmluaWUgZXN0IGlkZW50aWZpw6kuPC9saT48bGk+PHN0cm9uZz5Nw6lkaWFuZTwvc3Ryb25nPsKgOiBsYSBtw6lkaWFuZSBkZXMgY2VsbHVsZXMgZHUgdm9pc2luYWdlIGVzdCBpZGVudGlmacOpZS48L2xpPjxsaT48c3Ryb25nPk1pbmltdW08L3N0cm9uZz7CoDogbGUgbWluaW11bSAodmFsZXVyIGxhIHBsdXMgZmFpYmxlKSBkZXMgY2VsbHVsZXMgZHUgdm9pc2luYWdlIGVzdCBpZGVudGlmacOpLjwvbGk+PGxpPjxzdHJvbmc+Q2VudGlsZTwvc3Ryb25nPsKgOiB1biBjZW50aWxlIGRlcyBjZWxsdWxlcyBkdSB2b2lzaW5hZ2UgZXN0IGNhbGN1bMOpLiBMb3JzcXVlIGNlIHR5cGUgZGUgc3RhdGlzdGlxdWUgZXN0IHPDqWxlY3Rpb25uw6ksIGxlcyBwYXJhbcOodHJlczxzdHJvbmc+VmFsZXVyIGRlIGNlbnRpbGU8L3N0cm9uZz5ldDxzdHJvbmc+VHlwZSBk4oCZaW50ZXJwb2xhdGlvbiBlbiBjZW50aWxlPC9zdHJvbmc+ZGV2aWVubmVudCBkaXNwb25pYmxlcy4gVXRpbGlzZXogY2VzIG5vdXZlYXV4IHBhcmFtw6h0cmVzIGFmaW4gZGUgZMOpc2lnbmVyIGxlIGNlbnRpbGUgw6AgY2FsY3VsZXIgZXQgZGUgY2hvaXNpciBsZSB0eXBlIGTigJlpbnRlcnBvbGF0aW9uIMOgIHV0aWxpc2VyLCByZXNwZWN0aXZlbWVudC48L2xpPjwvdWw+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX2RpbWVuc2lvbl90YWcwQEBcIjogXCI8cD5EaW1lbnNpb24gw6AgdXRpbGlzZXIgcG91ciBs4oCZaW50ZXJwb2xhdGlvbi48L3A+PHA+Q2UgcGFyYW3DqHRyZSBlc3QgcmVxdWlzIHNpIGxlIHBhcmFtw6h0cmU8c3Ryb25nPkTDqWZpbml0aW9uIGRlIGxhIGRpbWVuc2lvbjwvc3Ryb25nPmVzdCBkw6lmaW5pIHN1cjxzdHJvbmc+UGFyIGludGVydmFsbGU8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtUmFzdGVyLUJ5LURpbWVuc2lvbl9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzBAQFwiOiBcIjxwPlNww6ljaWZpZSBsYSBtw6l0aG9kZSB1dGlsaXPDqWUgcG91ciBmaWx0cmVyIGxlcyBkb25uw6llcyBtdWx0aWRpbWVuc2lvbm5lbGxlcyBlbiBlbnRyw6llIGF2YW50IGTigJllZmZlY3R1ZXIgbOKAmWludGVycG9sYXRpb24uPC9wPjx1bD48bGk+PHN0cm9uZz5QYXIgdmFsZXVyczwvc3Ryb25nPsKgOiBsYSBkaW1lbnNpb24gZXN0IGTDqWNvdXDDqWUgZW4gdHJhbmNoZXMgw6AgbOKAmWFpZGUgZOKAmXVuZSB2YWxldXIgZGUgZGltZW5zaW9uIG91IGTigJl1bmUgbGlzdGUgZGUgdmFsZXVycy48L2xpPjxsaT48c3Ryb25nPlBhciBpbnRlcnZhbGxlPC9zdHJvbmc+wqA6IGxhIGRpbWVuc2lvbiBlc3QgZMOpY291cMOpZSBlbiB0cmFuY2hlcyBzZWxvbiB1bmUgcGxhZ2Ugb3UgdW5lIGxpc3RlIGRlIHBsYWdlcy48L2xpPjxsaT48c3Ryb25nPlBhciByYXN0ZXIgY2libGU8L3N0cm9uZz7CoDogbGEgZGltZW5zaW9uIGVzdCBkw6ljb3Vww6llIMOgIGzigJlhaWRlIGTigJl1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgY2libGUgc3DDqWNpZmlxdWUuPC9saT48L3VsPlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtUmFzdGVyLUJ5LURpbWVuc2lvbl9lbmRvZmludGVydmFsX3RhZzBAQFwiOiBcIjxwPkZpbiBkZSBs4oCZaW50ZXJ2YWxsZSwgdXRpbGlzw6llIHBvdXIgbGVzIGl0w6lyYXRpb25zIGRhbnMgbGUgamV1IGRlIGRvbm7DqWVzLjwvcD48cD5DZSBwYXJhbcOodHJlIGVzdCByZXF1aXMgc2kgbGUgcGFyYW3DqHRyZTxzdHJvbmc+RMOpZmluaXRpb24gZGUgbGEgZGltZW5zaW9uPC9zdHJvbmc+ZXN0IGTDqWZpbmkgc3VyPHN0cm9uZz5QYXIgaW50ZXJ2YWxsZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX2lnbm9yZW5vZGF0YV90YWcwQEBcIjogXCI8cD5TcMOpY2lmaWUgc2kgbGVzIHZhbGV1cnMgTm9EYXRhIHNvbnQgaWdub3LDqWVzIGxvcnMgZGUgbOKAmWFuYWx5c2UuPC9wPjx1bD48bGk+RMOpc2FjdGl2w6nCoDogbOKAmWFuYWx5c2UgcmVudm9pZSB1bmUgdmFsZXVyIE5vRGF0YSBzaSBsZXMgdHJhbmNoZXMgYWRqYWNlbnRlcyBjb21wb3J0ZW50IGRlcyB2YWxldXJzIE5vRGF0YS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT5BY3RpdsOpwqA6IGzigJlhbmFseXNlIG7igJl1dGlsaXNlIHF1ZSBsZXMgdHJhbmNoZXMgY29tcG9ydGFudCBkZXMgcGl4ZWxzIHZhbGlkZXMgZXQgaWdub3JlIGxlcyB0cmFuY2hlcyBOb0RhdGEuPC9saT48L3VsPlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtUmFzdGVyLUJ5LURpbWVuc2lvbl9pbnRlcnBvbGF0aW9ubWV0aG9kX3RhZzBAQFwiOiBcIjxwPlNww6ljaWZpZSBsYSBtw6l0aG9kZSDDoCB1dGlsaXNlciBwb3VyIGludGVycG9sZXIgbGUgcmFzdGVyLjwvcD48dWw+PGxpPjxzdHJvbmc+TGluw6lhaXJlPC9zdHJvbmc+wqA6IGxhIHNvcnRpZSBlc3QgaW50ZXJwb2zDqWUgZGUgZmHDp29uIGxpbsOpYWlyZSDDoCBs4oCZYWlkZSBkZXMgdHJhbmNoZXMgYWRqYWNlbnRlcy4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT48c3Ryb25nPlZvaXNpbiBwYXIgZMOpZmF1dDwvc3Ryb25nPsKgOiBsYSBzb3J0aWUgdXRpbGlzZSBsYSB0cmFuY2hlIGFkamFjZW50ZSBsYSBwbHVzIHByb2NoZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5SYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgZW4gZW50csOpZS48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX3N0YXJ0b2ZpbnRlcnZhbF90YWcwQEBcIjogXCI8cD5Ew6lidXQgZGUgbOKAmWludGVydmFsbGUsIHV0aWxpc8OpIHBvdXIgbGVzIGl0w6lyYXRpb25zIGRhbnMgbGUgamV1IGRlIGRvbm7DqWVzLjwvcD48cD5DZSBwYXJhbcOodHJlIGVzdCByZXF1aXMgc2kgbGUgcGFyYW3DqHRyZTxzdHJvbmc+RMOpZmluaXRpb24gZGUgbGEgZGltZW5zaW9uPC9zdHJvbmc+ZXN0IGTDqWZpbmkgc3VyPHN0cm9uZz5QYXIgaW50ZXJ2YWxsZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX3N0ZXBfdGFnMEBAXCI6IFwiPHA+RnLDqXF1ZW5jZSDDoCBsYXF1ZWxsZSBsZXMgZG9ubsOpZXMgc29udCBpbnRlcnBvbMOpZXMuPC9wPjxwPkNlIHBhcmFtw6h0cmUgZXN0IHJlcXVpcyBzaSBsZSBwYXJhbcOodHJlPHN0cm9uZz5Ew6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb248L3N0cm9uZz5lc3QgZMOpZmluaSBzdXI8c3Ryb25nPlBhciBpbnRlcnZhbGxlPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25fdGFyZ2V0cmFzdGVyX3RhZzBAQFwiOiBcIjxwPlJhc3RlciBjaWJsZSBzcMOpY2lmacOpIHBhciBsYSBkw6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb24uPC9wPjxwPkNlIHBhcmFtw6h0cmUgZXN0IHJlcXVpcyBzaSBsZSBwYXJhbcOodHJlPHN0cm9uZz5Ew6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb248L3N0cm9uZz5lc3QgZMOpZmluaSBzdXI8c3Ryb25nPlBhciByYXN0ZXIgY2libGU8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtUmFzdGVyLUJ5LURpbWVuc2lvbl91bml0X3RhZzBAQFwiOiBcIjxwPlVuaXTDqSBk4oCZaW50ZXJ2YWxsZS48L3A+PHA+Q2UgcGFyYW3DqHRyZSBlc3QgcmVxdWlzIHNpIGxlIHBhcmFtw6h0cmU8c3Ryb25nPkTDqWZpbml0aW9uIGRlIGxhIGRpbWVuc2lvbjwvc3Ryb25nPmVzdCBkw6lmaW5pIHN1cjxzdHJvbmc+UGFyIGludGVydmFsbGU8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtUmFzdGVyLUJ5LURpbWVuc2lvbl92YWx1ZXNfdGFnMEBAXCI6IFwiPHA+VmFsZXVycyBkZSBkaW1lbnNpb24gw6AgdXRpbGlzZXIgYWZpbiBkZSBmaWx0cmVyIGxlcyBkb25uw6llcyBtdWx0aWRpbWVuc2lvbm5lbGxlcyBlbiBlbnRyw6llIHBvdXIgbOKAmWFuYWx5c2UuPC9wPjxwPkNlIHBhcmFtw6h0cmUgZXN0IHJlcXVpcyBzaSBsZSBwYXJhbcOodHJlPHN0cm9uZz5Ew6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb248L3N0cm9uZz5lc3QgZMOpZmluaSBzdXI8c3Ryb25nPlBhciB2YWxldXJzPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25fdmFyaWFibGVzX3RhZzBAQFwiOiBcIjxwPkxhIG91IGxlcyB2YXJpYWJsZXMgaW50ZXJwb2zDqWVzIHBhciBsYSBkw6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb24uPC9wPlwiLFxuXHRcIkBAVGVycmFpbi1GbGF0dGVuX2NhbGlicmF0aW9udHlwZV90YWcwQEBcIjogXCI8cD5JbmRpcXVlIHNpIGxlIHRlcnJhaW4gZGUgbGEgc29ydGllIGVzdCBhcGxhbmkgw6AgbOKAmWFpZGUgZGUgPHN0cm9uZz5TaWdtYSB6w6lybzwvc3Ryb25nPiBvdSA8c3Ryb25nPkdhbW1hIHrDqXJvPC9zdHJvbmc+LjwvcD48dWw+PGxpPjxzdHJvbmc+R2FtbWEgesOpcm88L3N0cm9uZz4gLcKgTGEgcsOpdHJvZGlmZnVzaW9uIGLDqnRhIHrDqXJvIGVzdCBub3JtYWxpc8OpZSDDoCBs4oCZYWlkZSBkZSBsYSBzdXJmYWNlIGTigJl1bml0w6kgZOKAmXVuIHBsYW4gbG9jYWxlbWVudCB0YW5nZW50IGF1IE1ORSwgY291cmFtbWVudCBhcHBlbMOpIGFuZ2xlIGTigJlpbmNpZGVuY2UgbG9jYWwuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+PHN0cm9uZz5TaWdtYSB6w6lybzwvc3Ryb25nPiAtwqBMYSByw6l0cm9kaWZmdXNpb24gYsOqdGEgesOpcm8gZXN0IG5vcm1hbGlzw6llIMOgIGzigJlhaWRlIGTigJl1biBNTkUgcG91ciBjYWxjdWxlciBsYSBzdXJmYWNlLjwvbGk+PC91bD5cIixcblx0XCJAQFRlcnJhaW4tRmxhdHRlbl9kZW1fdGFnMEBAXCI6IFwiPHA+TU5FIGVuIGVudHLDqWUuPC9wPjxwPkxlIE1ORSBwZXJtZXQgZOKAmWVzdGltZXIgbGEgem9uZSBsb2NhbGUgw6ljbGFpcsOpZS48L3A+XCIsXG5cdFwiQEBUZXJyYWluLUZsYXR0ZW5fZ2VvaWRfdGFnMEBAXCI6IFwiPHA+SW5kaXF1ZSBzaSBsZSBzeXN0w6htZSBkZSByw6lmw6lyZW5jZSB2ZXJ0aWNhbGUgZHUgTU5FIGVuIGVudHLDqWUgZXN0IHRyYW5zZm9ybcOpIGVuIGhhdXRldXIgZWxsaXBzb8OvZGFsZS4gTGEgcGx1cGFydCBkZXMgamV1eCBkZSBkb25uw6llcyBk4oCZw6lsw6l2YXRpb24gw6l0YW50IHLDqWbDqXJlbmPDqXMgcGFyIHJhcHBvcnQgw6AgbGEgaGF1dGV1ciBvcnRob23DqXRyaXF1ZSBkdSBuaXZlYXUgZGUgbGEgbWVyLCB1bmUgY29ycmVjdGlvbiBlc3QgZG9uYyBuw6ljZXNzYWlyZSBwb3VyIGVmZmVjdHVlciBsYSBjb252ZXJzaW9uIGVuIGhhdXRldXIgZWxsaXBzb8OvZGFsZS48L3A+PHVsPjxsaT5BY3RpdsOpIC3CoFVuZSBjb3JyZWN0aW9uIGfDqW9kw6lzaXF1ZSBlc3QgZWZmZWN0dcOpZSBwb3VyIGNvbnZlcnRpciBsYSBoYXV0ZXVyIG9ydGhvbcOpdHJpcXVlIGVuIGhhdXRldXIgZWxsaXBzb8OvZGFsZSAoZW4gZm9uY3Rpb24gZHUgZ8Opb8OvZGUgRUdNOTYpLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPkTDqXNhY3RpdsOpIC0gQXVjdW5lIGNvcnJlY3Rpb24gZ8Opb2TDqXNpcXVlIG7igJllc3QgZWZmZWN0dcOpZS4gVXRpbGlzZXogY2V0dGUgb3B0aW9uIHVuaXF1ZW1lbnQgc2kgbGUgTU5FIGVzdCBleHByaW3DqSBlbiBoYXV0ZXVyIGVsbGlwc2/Dr2RhbGUuPC9saT48L3VsPlwiLFxuXHRcIkBAVGVycmFpbi1GbGF0dGVuX3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5Eb25uw6llcyByYWRhciBlbiBlbnRyw6llLjwvcD48cD5DZSByYXN0ZXIgZG9pdCDDqnRyZSBwcsOpYWxhYmxlbWVudCBjYWxpYnLDqSBwYXIgcmFkaW9tw6l0cmllIHN1ciBiw6p0YSB6w6lyby48L3A+XCIsXG5cdFwiQEBDcmVhdGUtQ29sb3ItQ29tcG9zaXRlX2JsdWVleHByZXNzaW9uX3RhZzBAQFwiOiBcIjxwPkNhbGN1bCBhZmZlY3TDqSDDoCBsYSB0cm9pc2nDqG1lIGJhbmRlLjwvcD48cD5Ob20gZGUgYmFuZGUsIGlkZW50aWZpYW50IGRlIGJhbmRlIG91IGV4cHJlc3Npb24gYWxnw6licmlxdWUgdXRpbGlzYW50IGxlcyBiYW5kZXMuPC9wPjxwPkxlcyBvcMOpcmF0ZXVycyBwcmlzIGVuIGNoYXJnZSBzb250IHVuYWlyZXPCoDogYWRkaXRpb27CoCgrKSwgc291c3RyYWN0aW9uwqAoLSksIG11bHRpcGxpY2F0aW9uwqAoKikgZXQgZGl2aXNpb27CoCgvKS48L3A+XCIsXG5cdFwiQEBDcmVhdGUtQ29sb3ItQ29tcG9zaXRlX2dyZWVuZXhwcmVzc2lvbl90YWcwQEBcIjogXCI8cD5DYWxjdWwgYWZmZWN0w6kgw6AgbGEgZGV1eGnDqG1lIGJhbmRlLjwvcD48cD5Ob20gZGUgYmFuZGUsIGlkZW50aWZpYW50IGRlIGJhbmRlIG91IGV4cHJlc3Npb24gYWxnw6licmlxdWUgdXRpbGlzYW50IGxlcyBiYW5kZXMuPC9wPjxwPkxlcyBvcMOpcmF0ZXVycyBwcmlzIGVuIGNoYXJnZSBzb250IHVuYWlyZXPCoDogYWRkaXRpb27CoCgrKSwgc291c3RyYWN0aW9uwqAoLSksIG11bHRpcGxpY2F0aW9uwqAoKikgZXQgZGl2aXNpb27CoCgvKS48L3A+XCIsXG5cdFwiQEBDcmVhdGUtQ29sb3ItQ29tcG9zaXRlX2lucHV0cmFzdGVyX3RhZzBAQFwiOiBcIjxwPkRvbm7DqWVzIHJhc3RlciBtdWx0aWJhbmRlIGVuIGVudHLDqWUuPC9wPlwiLFxuXHRcIkBAQ3JlYXRlLUNvbG9yLUNvbXBvc2l0ZV9tZXRob2RfdGFnMEBAXCI6IFwiPHA+SW5kaXF1ZSBsYSBtw6l0aG9kZSDDoCB1dGlsaXNlciBwb3VyIGV4dHJhaXJlIGxlcyBiYW5kZXMuPC9wPjx1bD48bGk+Tm9tcyBkZXMgYmFuZGVzIC3CoFV0aWxpc2UgbGUgbm9tIGRlIGxhIGJhbmRlIHJlcHLDqXNlbnRhbnQgbOKAmWludGVydmFsbGUgZGUgbG9uZ3VldXIgZOKAmW9uZGUgc3VyIGxlIHNwZWN0cmUgw6lsZWN0cm9tYWduw6l0aXF1ZSAocm91Z2UsIHByb2NoZSBpbmZyYXJvdWdlIG91IGluZnJhcm91Z2UgdGhlcm1pcXVlLCBwYXIgZXhlbXBsZSkgb3UgbGEgcG9sYXJpc2F0aW9uIChWSCwgVlYsIEhIIG91wqBIVikuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+SUQgZGVzIGJhbmRlcyAtwqBVdGlsaXNlIGxlIG51bcOpcm8gZGUgbGEgYmFuZGUgKEIxLCBCMiwgQjMsIGV0Yy4pLjwvbGk+PC91bD5cIixcblx0XCJAQENyZWF0ZS1Db2xvci1Db21wb3NpdGVfcmVkZXhwcmVzc2lvbl90YWcwQEBcIjogXCI8cD5DYWxjdWwgYWZmZWN0w6kgw6AgbGEgcHJlbWnDqHJlIGJhbmRlLjwvcD48cD5Ob20gZGUgYmFuZGUsIGlkZW50aWZpYW50IGRlIGJhbmRlIG91IGV4cHJlc3Npb24gYWxnw6licmlxdWUgdXRpbGlzYW50IGxlcyBiYW5kZXMuPC9wPjxwPkxlcyBvcMOpcmF0ZXVycyBwcmlzIGVuIGNoYXJnZSBzb250IHVuYWlyZXPCoDogYWRkaXRpb27CoCgrKSwgc291c3RyYWN0aW9uwqAoLSksIG11bHRpcGxpY2F0aW9uwqAoKikgZXQgZGl2aXNpb27CoCgvKS48L3A+XCIsXG5cdFwiQEBTdXJmYWNlLVBhcmFtZXRlcnNfbG9jYWxzdXJmYWNldHlwZV90YWcwQEBcIjogXCI8cD5DaG9pc2lyIGxlIHR5cGUgZGUgZm9uY3Rpb24gZGUgc3VyZmFjZSBxdWkgZXN0IGFwcGxpcXXDqSBhdXRvdXIgZGUgbGEgY2VsbHVsZSBjaWJsZS48L3A+PHVsPjxsaT5RdWFkcmF0aXF1ZcKgOiB1bmUgZm9uY3Rpb24gZGUgc3VyZmFjZSBxdWFkcmF0aXF1ZSBlc3QgYXBwbGlxdcOpZSBhdXggY2VsbHVsZXMgZHUgdm9pc2luYWdlLiBJbCBz4oCZYWdpdCBkdSB0eXBlIHBhciBkw6lmYXV0LjwvbGk+PGxpPkJpcXVhZHJhdGlxdWXCoDogdW5lIGZvbmN0aW9uIGRlIHN1cmZhY2UgYmlxdWFkcmF0aXF1ZSBlc3QgYXBwbGlxdcOpZSBhdXggY2VsbHVsZXMgZGUgdm9pc2luYWdlLjwvbGk+PC91bD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc19uZWlnaGJvcmhvb2RkaXN0YW5jZV90YWcwQEBcIjogXCI8cD5MYSBzb3J0aWUgZXN0IGNhbGN1bMOpZSBzdXIgY2V0dGUgZGlzdGFuY2Ugw6AgcGFydGlyIGR1IGNlbnRyZSBkZSBsYSBjZWxsdWxlIGNpYmxlLiBFbGxlIGTDqXRlcm1pbmUgbGEgdGFpbGxlIGR1IHZvaXNpbmFnZS4gTGEgdmFsZXVyIHBhciBkw6lmYXV0IGVzdCBsYSB0YWlsbGUgZGUgY2VsbHVsZSBkdSByYXN0ZXIgZW4gZW50csOpZSwgc29pdCB1biB2b2lzaW5hZ2UgZGUgM8KgcGFywqAzLjwvcD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc19vdXRwdXRzbG9wZW1lYXN1cmVtZW50X3RhZzBAQFwiOiBcIjxwPlVuaXTDqXMgZGUgbWVzdXJlIChkZWdyw6lzIG91IHBvdXJjZW50YWdlcykgdXRpbGlzw6llcyBwb3VyIGxlIHJhc3RlciBkZSBwZW50ZSBlbiBzb3J0aWUuIENlIHBhcmFtw6h0cmUgZXN0IGFjdGlmIHVuaXF1ZW1lbnQgc2kgPHN0cm9uZz5UeXBlIGRlIHBhcmFtw6h0cmU8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UGVudGU8L3N0cm9uZz4uPC9wPjx1bD48bGk+RGVncsOpwqA6IGzigJlpbmNsaW5haXNvbiBkZSBsYSBwZW50ZSBlc3QgY2FsY3Vsw6llIGVuIGRlZ3LDqXMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+UG91cmNlbnRhZ2UgZOKAmcOpbMOpdmF0aW9uwqA6IGzigJlpbmNsaW5haXNvbiBkZSBsYSBwZW50ZSBlc3QgY2FsY3Vsw6llIGVuIHBvdXJjZW50YWdlIGTigJnDqWzDqXZhdGlvbiwgw6lnYWxlbWVudCBkw6lzaWduw6kgc291cyBsZSBub20gZGUgcG91cmNlbnRhZ2UgZGUgcGVudGUuPC9saT48L3VsPlwiLFxuXHRcIkBAU3VyZmFjZS1QYXJhbWV0ZXJzX3BhcmFtZXRlcnR5cGVfdGFnMEBAXCI6IFwiPHA+U3DDqWNpZmllIGxlIHR5cGUgZGUgcGFyYW3DqHRyZSBkZSBzdXJmYWNlIGVuIHNvcnRpZSDDoCBjYWxjdWxlci48L3A+PHVsPjxsaT5QZW50ZcKgOiBsZSB0YXV4IGRlIHZhcmlhdGlvbiBkZSBs4oCZw6lsw6l2YXRpb24gZXN0IGNhbGN1bMOpLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPkV4cG9zaXRpb27CoDogbGEgZGlyZWN0aW9uIGRlIGxhIHBlbnRlIGRlc2NlbmRhbnRlIGR1IHRhdXggZGUgdmFyaWF0aW9uIG1heGltYWwgcG91ciBjaGFxdWUgY2VsbHVsZSBlc3QgY2FsY3Vsw6llLjwvbGk+PGxpPkNvdXJidXJlIG1veWVubmXCoDogbGEgY291cmJ1cmUgZ2xvYmFsZSBkZSBsYSBzdXJmYWNlIGVzdCBtZXN1csOpZS4gRWxsZSBlc3QgY2FsY3Vsw6llIGNvbW1lIMOpdGFudCBsYSBtb3llbm5lIGRlcyBjb3VyYnVyZXMgbWF4aW1hbGUgZXQgbWluaW1hbGUuIENldHRlIGNvdXJidXJlIGTDqWNyaXQgbGEgY29udmV4aXTDqSBvdSBsYSBjb25jYXZpdMOpIGludHJpbnPDqHF1ZSBkZSBsYSBzdXJmYWNlLCBpbmTDqXBlbmRhbW1lbnQgZGUgbGEgZGlyZWN0aW9uIG91IGRlIGzigJlpbmZsdWVuY2UgZGUgbGEgZ3Jhdml0w6kuPC9saT48bGk+Q291cmJ1cmUgdGFuZ2VudGllbGxlIChpc29saWduZSBub3JtYWxlKcKgOiBsYSBjb3VyYnVyZSBub3JtYWxlIGfDqW9tw6l0cmlxdWUgcGVycGVuZGljdWxhaXJlIMOgIGxhIGxpZ25lIGRlIHBlbnRlLCB0YW5nZW50ZSDDoCBs4oCZaXNvbGlnbmUsIGVzdCBtZXN1csOpZS4gQ2V0dGUgY291cmJ1cmUgZXN0IGfDqW7DqXJhbGVtZW50IGFwcGxpcXXDqWUgcG91ciBjYXJhY3TDqXJpc2VyIGxhIGNvbnZlcmdlbmNlIG91IGxhIGRpdmVyZ2VuY2UgZHUgZmx1eCBzdXIgbGEgc3VyZmFjZS48L2xpPjxsaT5Db3VyYnVyZSBsb25naXR1ZGluYWxlIChsaWduZSBkZSBwZW50ZSBub3JtYWxlKcKgOiBsYSBjb3VyYnVyZSBub3JtYWxlIGfDqW9tw6l0cmlxdWUgbGUgbG9uZyBkZSBsYSBsaWduZSBkZSBwZW50ZSBlc3QgbWVzdXLDqWUuIENldHRlIGNvdXJidXJlIGVzdCBnw6luw6lyYWxlbWVudCBhcHBsaXF1w6llIHBvdXIgY2FyYWN0w6lyaXNlciBs4oCZYWNjw6lsw6lyYXRpb24gZXQgbGEgZMOpY8OpbMOpcmF0aW9uIGR1IGZsdXggc3VyIGxhIHN1cmZhY2UuPC9saT48bGk+Q291cmJ1cmUgdHJhbnN2ZXJzYWxlIChpc29saWduZSBwcm9qZXTDqWUpwqA6IGxhIGNvdXJidXJlIGxlIGxvbmcgZGVzIGlzb2xpZ25lcyBlc3QgbWVzdXLDqWUuPC9saT48bGk+VG9yc2lvbiBnw6lvZMOpc2lxdWUgZGVzIGlzb2xpZ25lc8KgOiBsZSB0YXV4IGRlIHZhcmlhdGlvbiBkZSBs4oCZYW5nbGUgZGUgcGVudGUgbGUgbG9uZyBkZXMgaXNvbGlnbmVzIGVzdCBtZXN1csOpLjwvbGk+PGxpPkNvdXJidXJlIGdhdXNzaWVubmXCoDogbGEgY291cmJ1cmUgZ2xvYmFsZSBkZSBsYSBzdXJmYWNlIGVzdCBtZXN1csOpZS4gRWxsZSBlc3QgY2FsY3Vsw6llIGNvbW1lIGxlIHByb2R1aXQgZGVzIGNvdXJidXJlcyBtYXhpbWFsZSBldCBtaW5pbWFsZS48L2xpPjxsaT5Db3VyYnVyZSBDYXNvcmF0acKgOiBsYSBjb3VyYnVyZSBnw6luw6lyYWxlIGRlIGxhIHN1cmZhY2UgZXN0IG1lc3Vyw6llLiBFbGxlIHBldXQgw6p0cmUgw6lnYWxlIMOgIHrDqXJvIG91IMOgIHRvdXQgYXV0cmUgbm9tYnJlIHBvc2l0aWYuPC9saT48L3VsPlwiLFxuXHRcIkBAU3VyZmFjZS1QYXJhbWV0ZXJzX3Byb2plY3RnZW9kZXNpY2F6aW11dGhzX3RhZzBAQFwiOiBcIjxwPlNww6ljaWZpZSBzaSBsZXMgYXppbXV0cyBnw6lvZMOpc2lxdWVzIHNvbnQgcHJvamV0w6lzIGFmaW4gZGUgY29ycmlnZXIgbGEgZGlzdG9yc2lvbiBkZSBs4oCZYW5nbGUgcHJvdm9xdcOpZSBwYXIgbGEgcsOpZsOpcmVuY2Ugc3BhdGlhbGUgZW4gc29ydGllLiBDZSBwYXJhbcOodHJlIGVzdCBhY3RpZiB1bmlxdWVtZW50IHNpIDxzdHJvbmc+VHlwZSBkZSBwYXJhbcOodHJlPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPkV4cG9zaXRpb248L3N0cm9uZz4uPC9wPjx1bD48bGk+RMOpc2FjdGl2w6nCoDogbGVzIGF6aW11dHMgZ8Opb2TDqXNpcXVlcyBuZSBzb250IHBhcyBwcm9qZXTDqXMuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+QWN0aXbDqcKgOiBsZXMgYXppbXV0cyBnw6lvZMOpc2lxdWVzIHNvbnQgcHJvamV0w6lzLjwvbGk+PC91bD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc19yYXN0ZXJfdGFnMEBAXCI6IFwiPHA+UmFzdGVyIGRlIHN1cmZhY2UgZW4gZW50csOpZS4gSWwgcGV1dCBz4oCZYWdpciBk4oCZdW4gcmFzdGVyIGRlIHR5cGUgZW50aWVyIG91IMOgIHZpcmd1bGUgZmxvdHRhbnRlLjwvcD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc191c2VhZGFwdGl2ZW5laWdoYm9yaG9vZF90YWcwQEBcIjogXCI8cD5TcMOpY2lmaWUgc2kgbGEgZGlzdGFuY2UgZGUgdm9pc2luYWdlIHZhcmllIHNlbG9uIGxlcyBjaGFuZ2VtZW50cyBkdSBwYXlzYWdlIChkaXN0YW5jZSBhZGFwdGF0aXZlKS4gTGEgZGlzdGFuY2UgbWF4aW1hbGUgZXN0IGTDqXRlcm1pbsOpZSBwYXIgbGEgZGlzdGFuY2UgZGUgdm9pc2luYWdlLiBMYSBkaXN0YW5jZSBtaW5pbWFsZSBjb3JyZXNwb25kIMOgIGxhIHRhaWxsZSBkZSBjZWxsdWxlIGR1IHJhc3RlciBlbiBlbnRyw6llLjwvcD48dWw+PGxpPkTDqXNhY3RpdsOpwqA6IHVuZSBkaXN0YW5jZSBkZSB2b2lzaW5hZ2UgdW5pcXVlIChmaXhlKSBlc3QgdXRpbGlzw6llIMOgIHRvdXRlcyBsZXMgbG9jYWxpc2F0aW9ucy4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT5BY3RpdsOpwqA6IHVuZSBkaXN0YW5jZSBkZSB2b2lzaW5hZ2UgYWRhcHRhdGl2ZSBlc3QgdXRpbGlzw6llIMOgIHRvdXRlcyBsZXMgbG9jYWxpc2F0aW9ucy48L2xpPjwvdWw+XCIsXG5cdFwiQEBTdXJmYWNlLVBhcmFtZXRlcnNfdXNlZXF1YXRvcmlhbGFzcGVjdF90YWcwQEBcIjogXCI8cD5TcMOpY2lmaWUgc2kgbOKAmWV4cG9zaXRpb24gZXN0IG1lc3Vyw6llIMOgIHBhcnRpciBk4oCZdW4gcG9pbnQgc3VyIGzigJnDqXF1YXRldXIgb3Ugw6AgcGFydGlyIGR1IHDDtGxlIE5vcmQuIENlIHBhcmFtw6h0cmUgZXN0IGFjdGlmIHVuaXF1ZW1lbnQgc2kgPHN0cm9uZz5UeXBlIGRlIHBhcmFtw6h0cmU8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+RXhwb3NpdGlvbjwvc3Ryb25nPi48L3A+PHVsPjxsaT5Ew6lzYWN0aXbDqcKgOiBs4oCZZXhwb3NpdGlvbiBlc3QgbWVzdXLDqWUgw6AgcGFydGlyIGR1IHDDtGxlIE5vcmQuIElsIHPigJlhZ2l0IGRlIGzigJlvcHRpb24gcGFyIGTDqWZhdXQuPC9saT48bGk+QWN0aXbDqcKgOiBs4oCZZXhwb3NpdGlvbiBlc3QgbWVzdXLDqWUgw6AgcGFydGlyIGTigJl1biBwb2ludCBzdXIgbOKAmcOpcXVhdGV1ci48L2xpPjwvdWw+XCIsXG5cdFwiQEBTdXJmYWNlLVBhcmFtZXRlcnNfenVuaXRfdGFnMEBAXCI6IFwiPHA+VW5pdMOpIGxpbsOpYWlyZSBkZXMgdmFsZXVyc8KgeiB2ZXJ0aWNhbGVzLjwvcD48cD5FbGxlIGVzdCBkw6lmaW5pZSBwYXIgdW4gc3lzdMOobWUgZGUgY29vcmRvbm7DqWVzIHZlcnRpY2FsZXMsIHPigJlpbCBlbiBleGlzdGUgdW4uIEVuIGzigJlhYnNlbmNlIGTigJl1biBzeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgdmVydGljYWxlcywgbOKAmXVuaXTDqcKgeiBkb2l0IMOqdHJlIGTDqWZpbmllIMOgIHBhcnRpciBkZSBsYSBsaXN0ZSBkZXMgdW5pdMOpcyBwb3VyIGdhcmFudGlyIHVuIGNhbGN1bCBnw6lvZMOpc2lxdWUgY29ycmVjdC48L3A+PHVsPjxsaT5Qb3VjZcKgOiBs4oCZdW5pdMOpIGxpbsOpYWlyZSBlc3QgbGUgcG91Y2UuPC9saT48bGk+UGllZMKgOiBs4oCZdW5pdMOpIGxpbsOpYWlyZSBlc3QgbGUgcGllZC48L2xpPjxsaT5ZYXJkwqA6IGzigJl1bml0w6kgbGluw6lhaXJlIGVzdCBsZSB5YXJkLjwvbGk+PGxpPk1pbGUgKMOJdGF0cy1VbmlzKcKgOiBs4oCZdW5pdMOpIGxpbsOpYWlyZSBlc3QgbGUgbWlsZS48L2xpPjxsaT5NaWxsZSBuYXV0aXF1ZcKgOiBs4oCZdW5pdMOpIGxpbsOpYWlyZSBlc3QgbGUgbWlsbGUgbmF1dGlxdWUuPC9saT48bGk+TWlsbGltw6h0cmXCoDogbOKAmXVuaXTDqSBsaW7DqWFpcmUgZXN0IGxlIG1pbGxpbcOodHJlLjwvbGk+PGxpPkNlbnRpbcOodHJlwqA6IGzigJl1bml0w6kgbGluw6lhaXJlIGVzdCBsZSBjZW50aW3DqHRyZS48L2xpPjxsaT5Nw6h0cmXCoDogbOKAmXVuaXTDqSBsaW7DqWFpcmUgZXN0IGxlIG3DqHRyZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT5LaWxvbcOodHJlwqA6IGzigJl1bml0w6kgbGluw6lhaXJlIGVzdCBsZSBraWxvbcOodHJlLjwvbGk+PGxpPkTDqWNpbcOodHJlwqA6IGzigJl1bml0w6kgbGluw6lhaXJlIGVzdCBsZSBkw6ljaW3DqHRyZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBTdXJmYWNlLVBhcmFtZXRlcnNfYW5hbHlzaXNtYXNrX3RhZzBAQFwiOiBcIjxwPlJhc3RlciBpbmRpcXVhbnQgbGVzIGxvY2FsaXNhdGlvbnMgb8O5IGzigJlhbmFseXNlIGVzdCBlZmZlY3R1w6llLjwvcD48cD5MZSByYXN0ZXIgcGV1dCDDqnRyZSBkZSB0eXBlIGVudGllciBvdSDDoCB2aXJndWxlIGZsb3R0YW50ZS48L3A+PHA+VG91dGVzIGxlcyBjZWxsdWxlcyBheWFudCB1bmUgdmFsZXVyIHZhbGlkZSwgesOpcm8geSBjb21wcmlzLCBjb21wb3NlbnQgbGUgbWFzcXVlLiBMZXMgY2VsbHVsZXPCoE5vRGF0YSBkYW5zIGxlIG1hc3F1ZSBkZSBzYWlzaWUgYXVyb250IHVuZSB2YWxldXLCoE5vRGF0YSBkYW5zIGxhIHNvcnRpZS48L3A+XCIsXG5cdFwiQEBHZW9tZXRyaWMtTWVkaWFuX2NlbGxzaXpldHlwZV90YWcwQEBcIjogXCI8cD5Tw6lsZWN0aW9ubmV6IGxhIHRhaWxsZSBkZSBjZWxsdWxlIMOgIHV0aWxpc2VyIGRhbnMgbGUgcmFzdGVyIGVuIHNvcnRpZS4gU2kgdG91dGVzIGxlcyB0YWlsbGVzIGRlIGNlbGx1bGUgZW4gZW50csOpZSBzb250IGlkZW50aXF1ZXMsIHRvdXRlcyBsZXMgb3B0aW9ucyBkb25uZW50IGxlcyBtw6ptZXMgcsOpc3VsdGF0cy48L3A+PHVsPjxsaT5QcmVtaWVyIGRlwqA6IHV0aWxpc2VyIGxhIHByZW1pw6hyZSB0YWlsbGUgZGUgY2VsbHVsZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLjwvbGk+PGxpPk1pbiBkZcKgOiB1dGlsaXNlciBsYSBwbHVzIHBldGl0ZSB0YWlsbGUgZGUgY2VsbHVsZSBkZSB0b3VzIGxlcyByYXN0ZXJzIGVuIGVudHLDqWUuPC9saT48bGk+TWF4IGRlwqA6IHV0aWxpc2VyIGxhIHBsdXMgZ3JhbmRlIHRhaWxsZSBkZSBjZWxsdWxlIGRlIHRvdXMgbGVzIHJhc3RlcnMgZW4gZW50csOpZS4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT5Nb3llbm5lIGRlwqA6IHV0aWxpc2VyIGxhIHRhaWxsZSBkZSBjZWxsdWxlIG1veWVubmUgZGUgdG91cyBsZXMgcmFzdGVycyBlbiBlbnRyw6llLjwvbGk+PGxpPkRlcm5pZXIgZGXCoDogdXRpbGlzZXIgbGEgZGVybmnDqHJlIHRhaWxsZSBkZSBjZWxsdWxlIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VvbWV0cmljLU1lZGlhbl9lcHNpbG9uX3RhZzBAQFwiOiBcIjxwPlNww6ljaWZpZSBsYSB2YWxldXIgZGUgY29udmVyZ2VuY2UgZW50cmUgZGV1eCBpdMOpcmF0aW9ucyBjb25zw6ljdXRpdmVzLiBTaSBlcHNpbG9uIGVzdCBpbmbDqXJpZXVyIG91IMOpZ2FsIMOgIGxhIHZhbGV1ciBzcMOpY2lmacOpZSwgbOKAmWl0w6lyYXRpb24gc+KAmWFycsOqdGUgZXQgbGUgcsOpc3VsdGF0IGRlIGxhIGRlcm5pw6hyZSBpdMOpcmF0aW9uIGVzdCB1dGlsaXPDqS48L3A+XCIsXG5cdFwiQEBHZW9tZXRyaWMtTWVkaWFuX2V4dGVudHR5cGVfdGFnMEBAXCI6IFwiPHA+U8OpbGVjdGlvbm5leiBs4oCZw6l0ZW5kdWUgw6AgdXRpbGlzZXIgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllwqA6PC9wPjx1bD48bGk+PHA+UHJlbWllciBkZcKgOiB1dGlsaXNlciBs4oCZw6l0ZW5kdWUgZHUgcHJlbWllciByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LjwvcD48L2xpPjxsaT5JbnRlcnNlY3Rpb24gZGXCoDogdXRpbGlzZXIgbOKAmcOpdGVuZHVlIGRlcyBwaXhlbHMgc3VwZXJwb3PDqXMgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC4gSWwgc+KAmWFnaXQgZGUgbOKAmW9wdGlvbiBwYXIgZMOpZmF1dC48L2xpPjxsaT5VbmlvbiBkZcKgOiB1dGlsaXNlciBs4oCZw6l0ZW5kdWUgZGUgdG91cyBsZXMgcmFzdGVycyBwb3VyIGTDqXRlcm1pbmVyIGzigJnDqXRlbmR1ZSBkZSB0cmFpdGVtZW50LjwvbGk+PGxpPkRlcm5pZXIgZGXCoDogdXRpbGlzZXIgbOKAmcOpdGVuZHVlIGR1IGRlcm5pZXIgcmFzdGVyIGVuIGVudHLDqWUgcG91ciBkw6l0ZXJtaW5lciBs4oCZw6l0ZW5kdWUgZGUgdHJhaXRlbWVudC48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW9tZXRyaWMtTWVkaWFuX21heGltdW1udW1iZXJvZml0ZXJhdGlvbnNfdGFnMEBAXCI6IFwiPHA+U3DDqWNpZmllIGxlIG5vbWJyZSBtYXhpbWFsIGTigJlpdMOpcmF0aW9ucyDDoCBlZmZlY3R1ZXIuIExlIGNhbGN1bCBwcmVuZCBmaW4gbG9yc3F1ZSBjZXR0ZSB2YWxldXIgZXN0IGF0dGVpbnRlLCBxdWVsbGUgcXVlIHNvaXQgbGEgdmFsZXVyIGR1IHBhcmFtw6h0cmUgPHN0cm9uZz5FcHNpbG9uPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEdlb21ldHJpYy1NZWRpYW5fcmFzdGVyc190YWcwQEBcIjogXCI8cD5SYXN0ZXJzIG11bHRpYmFuZGVzIGVuIGVudHLDqWUuPC9wPlwiLFxuXHRcIkBATGVhc3QtQ29zdC1Db3JyaWRvcl9pbnB1dGFjY3VtdWxhdGl2ZWNvc3RkaXN0YW5jZXJhc3RlcjFfdGFnMEBAXCI6IFwiPHA+UmFzdGVyIGVuIGVudHLDqWUgcmVwcsOpc2VudGFudCBsYSBkaXN0YW5jZSBkZSBjb8O7dCBjdW11bMOpIHBvdXIgbGEgcHJlbWnDqHJlIHNvdXJjZS48L3A+PHA+SWwgZG9pdCBz4oCZYWdpciBk4oCZdW5lIGRpc3RhbmNlIGRlIGNvw7t0IGN1bXVsw6kgZ8OpbsOpcsOpZSBlbiBzb3J0aWUgZGUgbGEgZm9uY3Rpb24gPHN0cm9uZz5BY2N1bXVsYXRpb24gZGUgZGlzdGFuY2U8L3N0cm9uZz4gb3UgPHN0cm9uZz5BbGxvY2F0aW9uIGRlIGRpc3RhbmNlPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQExlYXN0LUNvc3QtQ29ycmlkb3JfaW5wdXRhY2N1bXVsYXRpdmVjb3N0ZGlzdGFuY2VyYXN0ZXIyX3RhZzBAQFwiOiBcIjxwPlJhc3RlciBlbiBlbnRyw6llIHJlcHLDqXNlbnRhbnQgbGEgZGlzdGFuY2UgZGUgY2/Du3QgY3VtdWzDqSBwb3VyIGxhIGRldXhpw6htZSBzb3VyY2UuPC9wPjxwPklsIGRvaXQgc+KAmWFnaXIgZOKAmXVuZSBkaXN0YW5jZSBkZSBjb8O7dCBjdW11bMOpIGfDqW7DqXLDqWUgZW4gc29ydGllIGRlIGxhIGZvbmN0aW9uIDxzdHJvbmc+QWNjdW11bGF0aW9uIGRlIGRpc3RhbmNlPC9zdHJvbmc+IG91IDxzdHJvbmc+QWxsb2NhdGlvbiBkZSBkaXN0YW5jZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBMZWFzdC1Db3N0LUNvcnJpZG9yX2lucHV0YmFja2RpcmVjdGlvbnJhc3RlcjFfdGFnMEBAXCI6IFwiPHA+UmFzdGVyIGRlIGRpcmVjdGlvbiBhcnJpw6hyZSBlbiBlbnRyw6llIHBvdXIgbGEgcHJlbWnDqHJlIHNvdXJjZS48L3A+PHA+SWwgc+KAmWFnaXQgZOKAmXVuIGpldSBkZSBkb25uw6llcyByYXN0ZXIgaW5kaXF1YW50IGxhIGRpcmVjdGlvbiBkZSBsYSBjZWxsdWxlIHN1aXZhbnRlIHN1ciBsZSBjaGVtaW4gZGUgbW9pbmRyZSBjb8O7dCBlbiByZXZlbmFudCB2ZXJzIGxhIHByZW1pw6hyZSBzb3VyY2UuIElsIGRvaXQgc+KAmWFnaXIgZGUgbGEgc29ydGllIGfDqW7DqXLDqWUgcGFyIGxhIGZvbmN0aW9uIDxzdHJvbmc+QWNjdW11bGF0aW9uIGRlIGRpc3RhbmNlPC9zdHJvbmc+IG91IDxzdHJvbmc+QWxsb2NhdGlvbiBkZSBkaXN0YW5jZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBMZWFzdC1Db3N0LUNvcnJpZG9yX2lucHV0YmFja2RpcmVjdGlvbnJhc3RlcjJfdGFnMEBAXCI6IFwiPHA+UmFzdGVyIGRlIGRpcmVjdGlvbiBhcnJpw6hyZSBlbiBlbnRyw6llIHBvdXIgbGEgc2Vjb25kZSBzb3VyY2UuPC9wPjxwPklsIHPigJlhZ2l0IGTigJl1biBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIGluZGlxdWFudCBsYSBkaXJlY3Rpb24gZGUgbGEgY2VsbHVsZSBzdWl2YW50ZSBzdXIgbGUgY2hlbWluIGRlIG1vaW5kcmUgY2/Du3QgZW4gcmV2ZW5hbnQgdmVycyBsYSBwcmVtacOocmUgc291cmNlLiBJbCBkb2l0IHPigJlhZ2lyIGRlIGxhIHNvcnRpZSBnw6luw6lyw6llIHBhciBsYSBmb25jdGlvbiA8c3Ryb25nPkFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZTwvc3Ryb25nPiBvdSA8c3Ryb25nPkFsbG9jYXRpb24gZGUgZGlzdGFuY2U8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBATGVhc3QtQ29zdC1Db3JyaWRvcl90aHJlc2hvbGRfdGFnMEBAXCI6IFwiPHA+UG91cmNlbnRhZ2Ugb3Ugc2V1aWwgZGUgY2/Du3QgY3VtdWzDqSBxdWkgZMOpdGVybWluZSBzaSB1bmUgY2VsbHVsZSBkb25uw6llIGVzdCBvdSBub24gaW5jbHVzZSBkYW5zIGxlIHJhc3RlciBkZSBjb3Vsb2lyIGVuIHNvcnRpZS48L3A+PHA+TG9yc3F1ZSBsZSBwYXJhbcOodHJlIDxzdHJvbmc+TcOpdGhvZGUgZGUgc2V1aWw8L3N0cm9uZz4gZXN0IGTDqWZpbmkgc3VyIDxzdHJvbmc+UG91cmNlbnRhZ2UgZGUgbW9pbmRyZSBjb8O7dDwvc3Ryb25nPiwgbGEgdmFsZXVyIHNww6ljaWZpw6llIGluZGlxdWUgbGUgcG91cmNlbnRhZ2UgZGUgaGF1c3NlIMOgIGFwcGxpcXVlciDDoCBwYXJ0aXIgZGUgbGEgdmFsZXVyIG1pbmltYWxlIGRlcyByYXN0ZXJzIGRlIGRpc3RhbmNlIGRlIGNvw7t0IGN1bXVsw6kgYWRkaXRpb25uw6lzLiBMb3JzcXVlIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Nw6l0aG9kZSBkZSBzZXVpbDwvc3Ryb25nPiBlc3QgZMOpZmluaSBzdXIgPHN0cm9uZz5Db8O7dCBjdW11bMOpPC9zdHJvbmc+LCBsYSB2YWxldXIgaW5kaXF1ZSBsZXMgY2VsbHVsZXMgZG9udCBsYSBzb21tZSBkdSBjb8O7dCBjdW11bMOpIGVzdCBpbmbDqXJpZXVyZSBvdSDDqWdhbGUgw6AgbGEgdmFsZXVyIMOgIGluY2x1cmUgZGFucyBsZSBjb3Vsb2lyLjwvcD48cD5DZSBwYXJhbcOodHJlIGVzdCBhY3RpZiB1bmlxdWVtZW50IHNpIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Nw6l0aG9kZSBkZSBzZXVpbDwvc3Ryb25nPiBlc3QgZMOpZmluaSBzdXIgPHN0cm9uZz5Qb3VyY2VudGFnZSBkZSBtb2luZHJlIGNvw7t0PC9zdHJvbmc+IG91IDxzdHJvbmc+Q2/Du3QgY3VtdWzDqTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBMZWFzdC1Db3N0LUNvcnJpZG9yX3RocmVzaG9sZG1ldGhvZF90YWcwQEBcIjogXCI8cD5JbmRpcXVlIGxlIG1vZGUgZGUgZMOpZmluaXRpb24gZHUgc2V1aWwuPC9wPjxwPjwvcD48dWw+PGxpPjxzdHJvbmc+QXVjdW4gc2V1aWw8L3N0cm9uZz7CoDogYXVjdW4gc2V1aWwgbuKAmWVzdCBhcHBsaXF1w6kgZXQgbGUgY291bG9pciBnw6luw6lyw6kgY291dnJlIGzigJnDqXRlbmR1ZSBlbnRpw6hyZSBkZXMgcmFzdGVycyBlbiBlbnRyw6llLiBJbCBz4oCZYWdpdCBkZSBs4oCZb3B0aW9uIHBhciBkw6lmYXV0LjwvbGk+PGxpPjxzdHJvbmc+UG91cmNlbnRhZ2UgZGUgbW9pbmRyZSBjb8O7dDwvc3Ryb25nPsKgOiBsZSBzZXVpbCBlc3QgZXhwcmltw6kgZW4gdW4gcG91cmNlbnRhZ2UgZGUgbGEgdmFsZXVyIG1pbmltYWxlIGRlcyByYXN0ZXJzIGRlIGRpc3RhbmNlIGRlIGNvw7t0IGN1bXVsw6kgYWRkaXRpb25uw6lzLjwvbGk+PGxpPjxzdHJvbmc+Q2/Du3QgY3VtdWzDqTwvc3Ryb25nPsKgOiBsZSBzZXVpbCBlc3QgZXhwcmltw6kgZW4gdW5pdMOpcyBkZSBkaXN0YW5jZSBkZSBjb8O7dCBjdW11bMOpLjwvbGk+PC91bD5cIlxufTtcbmNvbnN0IGhlbHBUZXh0c19mciA9IHtcblx0cmZ4QXJnc0hlbHBUZXh0czogcmZ4QXJnc0hlbHBUZXh0c1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaGVscFRleHRzX2ZyO1xuZXhwb3J0IHsgcmZ4QXJnc0hlbHBUZXh0cyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwLXRleHRzLmZyLTc2NzFhNjAwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==