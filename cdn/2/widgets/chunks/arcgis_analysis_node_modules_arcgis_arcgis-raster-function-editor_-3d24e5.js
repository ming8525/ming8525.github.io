"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-3d24e5"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.da-55c733be.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.da-55c733be.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "OK";
const cancel = "Annuller";
const enterURL = "Indtast billedtjeneste-URL";
const serviceURL = "Tjeneste-URL";
const selectRaster = "Vælg raster";
const failedToLoadLayer = "Kunne ikke indlæse lag";
const loadingLayer = "Indlæser lag";
const selectFeature = "Vælg vektorlag";
const enterFURL = "Indtast featuretjeneste-URL";
const addRaster = "Tilføj rastervariabel";
const addScalar = "Tilføj konstant";
const raster = "Raster";
const scalar = "Skalar";
const defaultModelName = "Rasterfunktionsskabelon";
const general = "Generelt";
const parameters = "Parametre";
const variables = "Variabler";
const name = "Navn";
const description = "Beskrivelse";
const parameter = "parameter";
const isPublic = "IsPublic";
const isDataset = "IsDataset";
const unknownPixelType = "Ukendt";
const outputPixelType = "Output-pixeltype";
const u8PixelType = "8 bit usigneret";
const s8PixelType = "8 bit signeret";
const u16PixelType = "16 bit usigneret";
const s16PixelType = "16 bit signeret";
const u32PixelType = "32 bit usigneret";
const s32PixelType = "32 bit signeret";
const f32PixelType = "32 bit flydende";
const f64PixelType = "64 bit doblet";
const properties = "Egenskaber";
const multidimensionalRules = "Flerdimensionale regler";
const matchVariables = "Match-variabler";
const unionDimensions = "Union-dimensioner";
const rasterFunctionEditor = {
	invalidRFTMessage: "Skabelonen til rasterfunktionen er ikke gyldig.",
	rfxArgsEditor: {
		outputRaster: "OutputRaster",
		raster: "Raster",
		unsupportedDataTypeWarning: "Følgende argumenter vises ikke, fordi de ikke understøttes på nuværende tidspunkt.",
		unsupportedFunction: "Indeholder en eller flere rasterfunktioner, der ikke understøttes."
	},
	rfxRasterInput: {
		selectLayer: "Vælg lag",
		browseLayers: "Gennemse lag",
		rfxVariable: "RasterFunctionVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Metode",
		bandLabel: "Bånd",
		combinationLabel: "Kombination"
	},
	rfxRemapGrid: {
		minimum: "Minimum",
		maximum: "Maksimum",
		output: "Output",
		noData: "NoData",
		remapValuesLabel: "Genberegn værdier"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Rastervariabler",
		deleteSelectedVars: "Fjern de valgte variabler"
	},
	rfxClippingGeometry: {
		clippingLayer: "Klip-lag",
		clippingRaster: "Klip-raster",
		clippingGeometry: "Klip-geometri",
		customExtent: "Brugerdefineret udstrækning",
		outputExtent: "Output-udstrækning",
		currentExtent: "Aktuel kortudstrækning",
		drawLabel: "Tegn"
	},
	rfxCustomExtent: {
		top: "Top",
		right: "Højre",
		bottom: "Bund",
		left: "Venstre"
	},
	rfxRasterArrayEditor: {
		moveUp: "Flyt op",
		moveDown: "Flyt ned",
		remove: "Fjern"
	},
	rfxStatisticsGrid: {
		stdDev: "Std. afv.",
		min: "Min.",
		max: "Maks.",
		mean: "Middel"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Vægtet sumtabel",
		id: "ID",
		layer: "Lag",
		field: "Felt",
		weight: "Vægt",
		value: "Værdi",
		selectLayer: "Vælg lag"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Vægtet overlay-tabel",
		id: "ID",
		layer: "Lag",
		field: "Felt",
		influence: "Påvirkning",
		sumOfInfluence: "Summen af påvirkning",
		value: "Værdi",
		remapTable: "Genberegn tabel",
		scale: "Målestok",
		scales: "Vægte",
		selectRaster: "Vælg raster"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Søg efter et vektorlag",
		addPointLayer: "Søg efter et punktlag"
	},
	rfxFieldSelect: {
		value: "Værdi",
		count: "Tælling"
	},
	rfxAttributeTable: {
		tableType: "Tabeltype",
		manual: "Manuel",
		external: "Ekstern",
		minVal: "Minimumværdi",
		maxVal: "Maksimumværdi",
		baseClassName: "Klassebasisnavn",
		colorScheme: "Farveskema",
		defaultClassName: "Label_",
		generateTable: "Generer tabel",
		browseTable: "Gennemse tabel",
		value: "Værdi",
		classname: "ClassName",
		color: "Farve"
	},
	rfxFieldNumberSwitchable: {
		number: "Numerisk",
		field: "Felt",
		string: "Streng",
		linearUnit: "Lineær enhed"
	},
	rfxPropertySet: {
		name: "Navn",
		value: "Værdi"
	},
	rfxConversionGrid: {
		size: "Størrelse"
	},
	rfxTransposeBit: {
		bitPattern: "Bit-mønster",
		outputBit: "Output-bit",
		inputBit: "Input-bit"
	},
	rfxSpatialReference: {
		placeHolder: "Forfin med nøgleord",
		coordinateSystem: "Koordinatsystem",
		gcs: "Geografisk koordinatsystem",
		pcs: "Forudberegnet koordinatsystem",
		vcs: "Vertikalt koordinatsystem"
	}
};
const rfxLicenseInfo = "Denne rasterfunktionsskabelon kan bruges til at behandle dine billeder ved hjælp af ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "ARCCOSH",
		aCosHSnip: "Beregner den omvendte hyperbolske cosinus for celler i en raster.",
		aCosHDesc: "Funktionen beregner den omvendte hyperbolske cosinus for pixels i en raster.",
		aCosName: "ARCCOS",
		aCosSnip: "Beregner den omvendte cosinus for pixels i en raster.",
		aCosDesc: "Denne rasterfunktion beregner den omvendte cosinus for cellerne i en raster. Inden for matematikken har alle trigonometriske funktioner et defineret område med gyldige inputværdier, kaldet domænet. Outputværdierne fra enhver funktion har også et defineret område. For dette værktøj er domænet [-1, 1], og området er [0, pi].",
		aSinHName: "ARCSINH",
		aSinHSnip: "Beregner den omvendte hyperbolske sinus for celler i en raster.",
		aSinHDesc: "Funktionen beregner den omvendte hyperbolske sinus for pixels i en raster.",
		aSinName: "ARCSIN",
		aSinSnip: "Beregner den omvendte sinus for celler i en raster.",
		aSinDesc: "Funktionen beregner den omvendte sinus for pixels i en raster.",
		aTan2Name: "ARCTAN2",
		aTan2Snip: "Beregner den omvendte tangens (baseret på x,y) for celler i en raster.",
		aTan2Desc: "Funktionen beregner den omvendte tangens (baseret på x,y) for pixels i en raster.",
		aTanHName: "ARCTANH",
		aTanHSnip: "Beregner den omvendte hyperbolske tangens for celler i en raster.",
		aTanHDesc: "Funktionen beregner den omvendte hyperbolske tangens for pixels i en raster.",
		aTanName: "ARCTAN",
		aTanSnip: "Beregner den omvendte tangens for celler i en raster.",
		aTanDesc: "Funktionen beregner den omvendte tangens for pixels i en raster.",
		absName: "ABS",
		absSnip: "Beregner den absolutte værdi for cellerne i en raster.",
		absDesc: "Funktionen ABS beregner den absolutte værdi for pixels i en raster.",
		reflectanceName: "Synlig reflektans",
		reflectanceSnip: "Konverterer råbilleder til Top of Atmosphere-værdier ved at tage hensyn til sensoregenskaber, solens position og overtagelsestidspunktet.",
		reflectanceDesc: "Denne funktion justerer de digitale værdier for billedlysstyrke for visse satellitsensorer. Justeringerne er baseret på solhøjde, optagelsesdato og sensoregenskaber og indstiller stigning og afvigelse for hvert bånd. Denne funktion bruges til at justere reflektans, eller lysstyrke, og værdier for visse satellitbilleder baseret på scenebelysning og indstillinger for sensor-stigning. Billederne justeres til et teoretisk almindeligt lysforhold, så der bliver mindre variation mellem scener fra forskellige datoer og forskellige sensorer. Dette kan være nyttigt til billedklassificering, farvebalancering og mosaik. Denne funktion kan kun bruges med bestemte billeder. De anvendelige sensorer er Landsat MSS, Landsat TM, Landsat ETM +, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 og Pleiades.<div><br/>Funktionen udfører to korrektioner. Den første er baseret på indstillingerne for stigning. De oprindelige lysstyrkeværdier genskabes ud fra billedværdierne ved at vende stignings-ligningerne. Den anden korrektion er relateret til forskelle i solvinkel og lysstyrke. De oprindelige lysstyrkeværdier justeres til et almindeligt lysforhold ved at normalisere scener, der er optaget under skiftende lysforhold. Outputbilleddatatypen er generelt den samme som inputbilleddatatypen, men outputværdierne er lavere end inputværdierne og klippes til det gyldige dataområde.</div>",
		argStatisticsName: "ArgStatistics",
		argStatisticsSnip: "Beregner arg-statistikker, herunder Arg Max, Arg Min, Arg Median og Varighed.",
		argStatisticsDesc: "Funktionen beregner arg-statistikker. Der er fire metoder i ArgStatistics-funktionen: ArgMax, ArgMin, ArgMedian og Varighed.",
		arithmeticName: "Aritmetisk",
		arithmeticSnip: "Udfører en aritmetisk operation mellem to raster eller en raster og en skalar.",
		arithmeticDesc: "Funktionen Aritmetisk udfører en aritmetisk operation mellem to raster eller en raster og en skalar og omvendt.",
		aspectSlopeName: "Aspekt-hældning",
		aspectSlopeSnip: "Opretter en raster, der på samme tid viser aspektet (retning) og hældning (stejlhed) for en sammenhængende overflade, som repræsenteret i en digital elevationsmodel.",
		aspectSlopeDesc: "Funktionen Aspekt-hældning skaber et rasterlag, der samtidig viser en flades aspekt og hældning. Aspekt angiver den nedadgående hældning ud fra den maksimale ændring af værdien af hver pixel i forhold til de tilstødende pixels. Man kan tænke på aspekt som en hældningsretning. Værdierne i output-rasteren vil udgøre kompasretningen for aspektet, repræsenteret af en farvetone (farve). Stigningen repræsenterer ændringen af højden for hver pixel i den digitale elevationsmodel (DEM). Hældningen repræsenterer overfladens stejlhed og er symboliseret i tre klasser, der vises ved hjælp af farvemætning (lysstyrke).<div><br/>Pixelværdierne i outputrasteren for aspekt-hældning afspejler en kombination af aspekt og hældning. Pixler med værdier under 20 betragtes som flade og vises med grå farve. Værdier for aspekt-hældning på 21 og derover vises med forskellig farvemætning som følger: 21 til 30 —Lille hældning, 31 til 40—Moderat hældning, 41 og derover—Stor hældning",
		aspectName: "Aspekt",
		aspectSnip: "Viser hvilken retning en pixel vender, hvor 0 er nord og vinklerne stiger med uret til 360.",
		aspectDesc: "Funktionen Aspekt angiver den nedadgående hældning ud fra den maksimale ændring af værdien af hver celle i forhold til de tilstødende celler. Man kan tænke på aspekt som en hældningsretning. Værdierne i output-rasterdataene vil udgøre kompasretningen for aspektet.<div><br/>Input til denne funktion er Inputraster. Funktionen Aspekt anvendes ofte på en digital elevationsmodel (DEM). Som standard vises aspektet som et gråtonebillede. Du kan tilføje Farvekort-funktionen for at angive et bestemt farveskema eller for at tillade, at personen, der ser mosaikken, ændre symbologien med deres eget farveskema.</div>",
		tableName: "Attributtabel",
		tableSnip: "Bruger en tabel til at navngive og symbolisere værdierne i et datasæt. Kolonner til tabellen er kommaseparerede: PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "Funktionen Attributtabel giver mulighed for at definere et attributtabel for at symbolisere et enkeltbånds mosaikdatasæt eller rasterdatasæt. <div><br/>Det er nyttigt, når du vil præsentere billeder, der er blevet klassificeret til arealanvendelse, f.eks. skov, vådområder, opdyrkede arealer og byområder. Hvis din tabel indeholder felter, der hedder rød, grøn og blå, anvendes værdierne i disse felter som et farvekort, når du gengiver billedet.</div>",
		bandArithmeticName: "Bånd-aritmetik",
		bandArithmeticSnip: "Beregner indekser ved hjælp af foruddefinerede formler eller et brugerdefineret udtryk.",
		bandArithmeticDesc: "Funktionen Bånd-aritmetik udfører en aritmetisk operation på båndene i et rasterdatasæt. Du kan vælge foruddefinerede algoritmer, eller du kan indtaste din egen enkeltlinjeformel. De understøttede operatører er -, +, /, * og unært -.",
		thresholdName: "Binær tærskelværdi",
		thresholdSnip: "Organiserer kontinuerlige data i forgrunden og baggrunden ved at minimere kovariansen mellem de to klasser.",
		thresholdDesc: "Når et raster datasæt har en bimodal distribution, skaber denne funktion en ny raster, der deler dataene i to forskellige klasser. Den opretter en klasse med lav værdi, der vises med sorte pixels, og en klasse med høj værdi, der vises med hvide pixels.",
		bitwiseAndName: "Bitwise Og",
		bitwiseAndSnip: "Udfører en Bitvis Og-operation på de binære værdier for to inputraster.",
		bitwiseAndDesc: "Bitwise Og udfører en Bitwise Og-operation på de binære værdier for to inputraster",
		bitwiseLeftShiftName: "Bitwise Venstre skift",
		bitwiseLeftShiftSnip: "Udfører en Bitwise Venstre skift-operation på de binære værdier for to inputraster.",
		bitwiseLeftShiftDesc: "Bitwise Venstre skift udfører en Bitwise Venstre skift-operation på de binære værdier for to inputraster",
		bitwiseNotName: "Bitwise Ikke",
		bitwiseNotSnip: "Udfører en Bitwise Ikke (supplement)-operation på den binære værdi for to inputraster.",
		bitwiseNotDesc: "Funktionen udfører en Bitwise Ikke (supplement)-operation på den binære værdi for en inputraster.",
		bitwiseOrName: "Bitwise Eller",
		bitwiseOrSnip: "Udfører en Bitwise Eller-operation på de binære værdier for to inputraster.",
		bitwiseOrDesc: "Funktionen udfører en Bitwise Eller-operation på de binære værdier for to inputraster. ",
		bitwiseRightShiftName: "Bitwise Højre skift",
		bitwiseRightShiftSnip: "Udfører en Bitwise Højre skift-operation på de binære værdier for to inputraster.",
		bitwiseRightShiftDesc: "Funktionen udfører en Bitwise Højre skift-operation på de binære værdier for to inputraster.",
		bitwiseXorName: "Bitwise Xor",
		bitwiseXorSnip: "Udfører en Bitwise eXclusive Or-operation på de binære værdier for to inputraster.",
		bitwiseXorDesc: "Funktionen udfører en Bitwise eXclusive Or-operation på de binære værdier for to inputraster",
		booleanAndName: "Boolesk Og",
		booleanAndSnip: "Udfører en Boolesk Og-operation på celleværdierne for to inputraster. Hvis begge inputværdier er sande (ikke-nul), er outputværdien 1. Hvis en eller begge inputværdier er falske (nul), er outputværdien 0.",
		booleanAndDesc: "Funktionen udfører en Boolesk Og-operation på pixelværdierne for to input. Hvis begge inputværdier er sande (ikke nul), er outputværdien 1. Hvis en eller begge inputværdier er falske (nul), er outputværdien 0. ",
		booleanNotName: "Boolesk Ikke",
		booleanNotSnip: "Udfører en Boolesk Ikke (supplement)-operation på celleværdierne i inputrasteren. Hvis inputværdierne er sande (ikke nul), er outputværdien 0. Hvis inputværdierne er falske (nul), er outputværdien 1.",
		booleanNotDesc: "Funktionen udfører en Boolesk Ikke (supplement)-operation på pixelværdierne i inputrasteren. Hvis inputværdierne er sande (ikke nul), er outputværdien 0. Hvis inputværdierne er falske (nul), er outputværdien 1.",
		booleanOrName: "Boolesk Eller",
		booleanOrSnip: "Udfører en Boolesk Eller-operation på celleværdierne for de to inputraster. Hvis en eller begge inputværdier er sande (ikke nul), er outputværdien 1. Hvis begge inputværdier er falske (nul), er outputværdien 0.",
		booleanOrDesc: "Funktionen udfører en Boolesk Eller-operation på celleværdierne for to inputraster. Hvis en eller begge inputværdier er sande (ikke nul), er outputværdien 1. Hvis begge indgangsværdier er falske (nul), er outputværdien 0.",
		booleanXorName: "Boolesk Xor",
		booleanXorSnip: "Udfører en Boolesk eXclusive Or-operation på celleværdierne for to inputraster. Hvis den ene inputværdi er sand (ikke nul), og den anden er falsk (nul), er outputværdien 1. Hvis begge inputværdier er sande, eller de begge er falske, er outputværdien 0.",
		booleanXorDesc: "Funktionen udfører en Boolesk eXclusive Or-operation på celleværdierne for to inputraster. Hvis den ene inputværdi er sand (ikke nul), og den anden er falsk (nul), er outputværdien 1. Hvis begge inputværdier er sande, eller de begge er falske, er outputværdien 0.",
		bufferedRasterName: "Buffered",
		bufferedRasterSnip: "Placerer de(n) sidst tilgåede pixelblok(ke) i bufferen.",
		bufferedRasterDesc: "Funktionen Buffered benyttes til at optimere ydelsen for komplekse funktionskæder. Den gemmer output fra den del af funktionskæden, der kommer før den, i hukommelsen. <div><br/>Indsæt denne funktion i Funktionseditoren der, hvor du vil gemme outputtet.</div>",
		rasterCalculatorName: "Regnemaskine",
		rasterCalculatorSnip: "Beregner en raster ud fra et rasterbaseret matematisk udtryk.",
		rasterCalculatorDesc: "Funktionen Regnemaskine giver dig mulighed for at oprette og køre udtryk og indarbejde dem i funktionskæder.",
		cellStatisticsName: "Cellestatistik",
		cellStatisticsSnip: "Beregner statistik pr. celle fra flere rastere. Den tilgængelige statistik er majoritet, maksimum, middel, median, minimum, minoritet, percentil, interval, standardafvigelse, sum og variation.",
		cellStatisticsDesc: "Denne funktion beregner statistikker ud fra flere raster pixel for pixel. De tilgængelige statistiktyper er majoritet, maksimum, middel, median, minimum, minoritet, interval, standardafvigelse, sum og variation.",
		classifyName: "Klassificér",
		classifySnip: "Tildeler hver pixel til en klasse. Indarbejder hjælpedata såsom et segmenteret billede.",
		classifyDesc: "Denne rasterfunktion klassificerer et rasterdatasæt baseret på en Esri-klassificeringsdefinitionsfil (.ecd) og rasterdatasæt-input. Den .ecd-fil, der anvendes i funktionen Klassifikation, indeholder alle oplysningerne til et bestemt datasæt og en bestemt klassifikator og genereres af uddannelsesværktøjerne til klassifikation, f.eks. Train Support Vector Machine eller Train Random Trees.",
		clipName: "Klip",
		clipSnip: "Angiver udstrækningen af en raster ved hjælp af koordinater eller et andet datasæt.",
		clipDesc: "Denne funktion klipper en raster ved hjælp af en rektangulær form i henhold til de definerede udstrækninger eller klipper en raster i samme form som en inputpolygon-objektklasse. Formen, der definerer klippet, kan klippe udstrækningen af rasteren eller klippe et område ud inde i rasteren.",
		colorspaceConversionName: "Konvertering af farvemodel",
		colorspaceConversionSnip: "Konverterer en raster fra RGB til HSV og omvendt.",
		colorspaceConversionDesc: "Funktionen Konvertering af farvemodel konverterer farvemodellen af et billede fra farverummet farvetone, mætning og værdi (HSV) til rødt, grønt og blåt (RGB) eller omvendt.<div><br/>Denne funktion kan bruges i et mosaik-datasæt.</div>",
		colormapToRGBName: "Farvekort til RGB",
		colormapToRGBSnip: "Konverterer en enkeltbåndsraster med et farvekort til en trebåndsraster (rød, grøn og blå).",
		colormapToRGBDesc: "Denne funktion konverterer en enkeltbåndsraster med et farvekort til en trebåndsraster (rød, grøn og blå).<div><br/>Denne funktion er nyttig, når du skal oprette en trebåndsraster ud fra en enkeltbåndsraster med et tilknyttet farvekort. Værdierne i farvekortet bruges til at oprette hvert enkelt rødt, grønt og blåt bånd. Denne funktion kan bruges i et mosaik-datasæt.</div>",
		colormapName: "Farvekort",
		colormapSnip: "Ændrer pixelværdier for at vise rasterdataene som en gråtoneskala eller et rødt, grønt og blåt billede (RGB), baseret på et farvekort eller en farveskala.",
		colormapDesc: "Funktionen Farvekort et rasterdata-gengivelsesværktøj. Den omdanner pixelværdierne, så de viser rasterdataene som enten en gråtoneskala eller et RGB-farvebillede baseret på et farveskema eller bestemte farver i en farvekortfil. Du kan bruge et farvekort til at repræsentere analyserede data, f.eks. et klassificeret billede, eller når der vises et topografisk kort (eller et indeks-farvescannet billede).<div><br/>Farvekort indeholder et sæt værdier, der er forbundet med de farver, der bruges til at vise en enkeltbåndsraster med de samme farver. Hver pixelværdi er forbundet med en farve, der er defineret som et sæt RGB-værdier. Farvekort kan understøtte alle bitdybder, undtagen flydende komma. De understøtter også positive og negative værdier og kan indeholde manglende farvekortværdier. Når der vises et datasæt med et farvekort med manglende værdier, vises pixels med de manglende værdier ikke.</div>",
		complexName: "Kompleks",
		complexSnip: "Uddrager størrelsen fra komplekse tal.",
		complexDesc: "Denne funktion beregner størrelsen ud fra komplekse værdier.<div><br/>Denne funktion bruges typisk med RADAR-billeder, der har en kompleks datatype. Den kan bruges i et mosaik-datasæt.</div>",
		compositeBandName: "Sammensatte bånd",
		compositeBandSnip: "Kombinerer flere datasæt i en flerbåndraster.",
		compositeBandDesc: "Med funktionen Sammensatte bånd kan du kombinere raster og danne et flerbåndsbillede.",
		conName: "Betinget",
		conSnip: "Udfører en betinget If, Then, Else-operation. Når en betingelses-operatør anvendes, skal der normalt være to eller flere funktioner, der er kædet sammen, hvor den ene funktion angiver kriterierne, og den anden funktion er betingelses-operatøren, der bruger kriterierne og bestemmer, hvad de sande og falske output skal være.",
		conDesc: "Funktionen Betinget angiver pixels for outputraster baseret på en ifelse-evaluering af hver inputpixel. Den returnerer pixelværdier fra Sand-rasteren, hvis den betingede evaluering er sand (1) eller returnerer pixelværdierne fra Falsk-rasteren, hvis den betingede evaluering er falsk (0). Dette kriterium er angivet af outputtet fra en logisk matematisk funktion, som er inputrasteren.",
		constantName: "Konstant",
		constantSnip: "Opretter en virtuel raster med en enkelt pixelværdi.",
		constantDesc: "Denne funktion skaber en virtuel raster med en enkelt pixelværdi, som kan bruges i rasterfunktionsskabeloner og til at behandle et mosaikdatasæt.<div><br/>Den konstante værdi anvendes til alle pixelværdier i rasteren.</div>",
		contourName: "Kontur",
		contourSnip: "Opretter konturlinjer.",
		contourDesc: "Funktionen genererer konturlinjer ved at forbinde punkter med samme højde fra et raster højdedatasæt. Konturerne er isolinjer, der er oprettet som raster med henblik på visualisering. Funktionen har følgende stærke nøglefunktioner: Konturer genereres hurtigt og dynamisk på meget store datasæt, som World Elevation; konturer kan glattes ud for at give et mere kartografisk udseende, samtidig med at konturernes nøjagtighed bevares; dynamisk kontrol over konturintervallet; muligheder for output omfatter konturlinjer, indekskonturer og udfyldte konturer.<div><br/>Oprettelsen af ​​et konturlag som et rasterprodukt er nyttigt for en bred vifte af anvendelser, da konturerne kan placeres oven på hinanden på et kort og give oplysninger om terrænet uden at skjule de underliggende data. De er nyttige inden for teknik, landbrug og vand.</div>",
		contrastBrightnessName: "Kontrast og lysstyrke",
		contrastBrightnessSnip: "Justerer kontrast og lysstyrke for en raster.",
		contrastBrightnessDesc: "Funktionen Kontrast og lysstyrke forbedrer udseendet af rasterdata ved at ændre lysstyrken og kontrasten i billedet. Lysstyrke øger billedets generelle lysstyrke f.eks. bliver mørke farver lysere og lyse farver hvidere, mens Kontrast justerer forskellen mellem de mørkeste og de lyseste farver.<div><br/>Denne funktion ændrer pixelværdierne. Derfor skal den bruges, når du vil forbedre dataenes udseende, og ikke hvis du har til hensigt at bruge dataene som en del af en analyse, der kræver de rå pixelværdier. Denne funktion er nyttig, når du offentliggør dataene som en billedtjeneste, som kan bruges i applikationer, der ikke kan ændre billedets kontrast og lysstyrke, eller for at sikre, at den vises med dine foretrukne indstillinger.</div>",
		convolutionName: "Foldning",
		convolutionSnip: "Anvender et filter til at skærpe, sløre, registrere kanter, glatte ud eller oprette en gradient på tværs af en raster.",
		convolutionDesc: "Funktionen Foldning udfører filtrering på pixelværdierne i et billede, og kan bruges til at gøre et billede skarpere, sløre et billede, registrere kanter inden for et billede eller andre kernebaserede forbedringer. Filtre bruges til at forbedre kvaliteten af rasterbilledet ved at eliminere falske data eller forbedre objekter i dataene. Disse foldningsfiltre anvendes på en overlappende kerne i bevægelse (vindue eller tilstødende), f.eks. 3 x 3. Foldningsfiltre fungerer ved at beregne pixelværdien baseret på vægtningen af tilstødende værdier.",
		corridorName: "Korridor",
		corridorSnip: "Beregner summen af akkumulerede omkostninger for to akkumulerede inputraster.",
		corridorDesc: "Funktionen Korridor beregner summen af akkumulerede omkostninger for to inputraster med akkumulerede omkostninger. To vilkårlige raster kan bruges som input, men hvis funktionen skal give et meningsfuldt resultat, bør de være uændrede outputraster med akkumulerede omkostninger. Rækkefølgen af de to input er ligegyldig.",
		cosHName: "CosH",
		cosHSnip: "Beregner den hyperbolske cosinus af celler i en raster.",
		cosHDesc: "Funktionen beregner den hyperbolske cosinus for pixels i en raster.",
		cosName: "Cos",
		cosSnip: "Beregner cosinus for en celle i raster.",
		cosDesc: "Funktionen beregner cosinus for pixels i en raster.",
		costAllocationName: "Omkostningsfordeling",
		costAllocationSnip: "Beregner for hver celle den kilde med de laveste omkostninger baseret på den mindste akkumulerede omkostning over en omkostningsoverflade.",
		costAllocationDesc: "Funktionen Omkostningsfordeling beregner for hver celle den kilde med de laveste omkostninger baseret på den mindste akkumulerede omkostning over en omkostningsoverflade.",
		costBackLinkName: "Omkostning BackLink",
		costBackLinkSnip: "Definerer nabocellen, der er den næste celle på ruten med de laveste akkumulerede omkostninger til den kilde med de laveste omkostninger.",
		costBackLinkDesc: "Funktionen Omkostning BackLink definerer den tilstødende værdi, som er den næste celle på ruten med de laveste akkumulerede omkostninger til den kilde med de laveste omkostninger.<div><br/>Backlink-rasteren indeholder værdier fra nul til otte, som definerer retningen eller identificerer den næste nabocelle (den efterfølgende celle) langs den rute med de laveste akkumulerede omkostninger fra en celle for at nå den kilde med de laveste omkostninger. Hvis stien skal gå til den rigtige nabocelle, tildeles cellen værdien 1, 2 for nederste højre diagonale celle og værditildelingen fortsættes i retning med uret. Værdien 0 er reserveret til kildeceller.</div>",
		costDistanceName: "Omkostning/afstand",
		costDistanceSnip: "Beregner afstanden med de laveste akkumulerede omkostninger for hver celle fra eller til kilden med de laveste omkostninger over en omkostningsoverflade.",
		costDistanceDesc: "Funktionen Omkostning/afstand beregner afstanden med de laveste akkumulerede omkostninger for hver celle fra eller til kilden med de laveste omkostninger over en omkostningsoverflade.",
		costPathName: "Omkostning/rute",
		costPathSnip: "Beregner ruten med de laveste omkostninger fra en kilde til en destination.",
		costPathDesc: "Den globale funktion Omkostning/rute beregner ruten med de laveste omkostninger fra en kilde til en destination.<div><br/>Denne funktion producerer en outputraster, der registrerer den eller de ruter med de laveste omkostninger fra udvalgte steder til den nærmeste kildecelle, der er defineret inden for den akkumulative omkostningsoverflade, hvad angår omkostninger/afstand.</div>",
		curvatureName: "Krumning",
		curvatureSnip: "Beregner krumningen af en rasteroverflade, der kan omfatte profil- og plankrumning.",
		curvatureDesc: "Funktionen Krumning viser formen eller krumningen af hældningen. En del af en overflade kan være konkav eller konveks. Det kan man se ved hjælp af krumningsværdien. Krumningen bestemmes ved at beregne den anden afledte værdi af overfladen.<div><br/>Outputtet fra funktionen Krumning kan bruges til at beskrive de fysiske egenskaber ved et dræningsbasin for at forstå erosions- og afstrømningsprocesser. Krumningsværdien kan bruges til at finde mønstre i jorderosion såvel som fordeling af vand på land. Profilkrumningen påvirker accelerationen og decelerationen af strømmen og påvirker derfor erosion og aflejring. Planformkrumningen påvirker strømmens konvergens og divergens.</div>",
		divideName: "Dividér",
		divideSnip: "Deler værdierne for to raster celle til celle.",
		divideDesc: "Funktionen Dividér deler værdierne for to raster pixel for pixel.",
		elevationVoidFillName: "Udfyldning af højdetomrum",
		elevationVoidFillSnip: "Opretter pixels, der hvor der er huller i dine højdedata.",
		elevationVoidFillDesc: "Funktionen Udfyldning af højdetomrum bruges til at oprette pixels, der hvor der er huller i dine højdedata.<div><br/>Der opstår tomrum, når der ikke er opsamlet punkter inden for det område, der repræsenteres af en pixel i den resulterende raster. Tomrum er ofte forårsaget af vandområder, klassetypevalg eller udelukkelse. Udfyldning af tomrum bruges mest til dannelse af en jordoverflade.</div>",
		equalToName: "Lig med",
		equalToSnip: "Udfører en relationsbaseret Lig med-operation på to input celle for celle. Returnerer 1 for celler, hvor den første raster er lig med den anden raster og 0 for celler, hvor den ikke er det.",
		equalToDesc: "Funktionen udfører en Lig med-operation på to raster pixel for pixel. Den returnerer værdien 1 for pixels, hvor den første raster er lig med den anden raster og værdien 0 for pixels, hvor de ikke er lig med hinanden.",
		eucAllocationName: "Euklidisk allokering",
		eucAllocationSnip: "Beregner den nærmeste kilde baseret på euklidisk afstand for hver celle.",
		eucAllocationDesc: "Funktionen Euklidisk allokering beregner den nærmeste kilde baseret på euklidisk afstand for hver celle.",
		eucDirectionName: "Euklidisk retning",
		eucDirectionSnip: "Beregner retningen i grader til nærmeste kilde for hver celle.",
		eucDirectionDesc: "Funktionen Euklidisk retning beregner retningen i grader til nærmeste kilde for hver celle. <div><br/>Retningen beregnes fra midten af hver celle til midten af ​​den kildecelle, der er nærmest på cellen. Intervallet af værdier er fra 0 grader til 360 grader, hvor 0 er forbeholdt kildecellerne. Stik øst (højre) er 90, og værdierne stiger i retning med uret (180 er syd, 270 er vest og 360 er nord).</div>",
		eucDistanceName: "Euklidisk afstand",
		eucDistanceSnip: "Beregner den euklidiske afstand til den nærmeste kilde for hver celle.",
		eucDistanceDesc: "Funktionen Euklidisk afstand beregner den euklidiske afstand til den nærmeste kilde for hver celle.",
		exp10Name: "EKSP10",
		exp10Snip: "Beregner grundtal 10-eksponentialfunktionen for cellerne i en raster.",
		exp10Desc: "Funktionen EKSP 10 beregner grundtal 10-eksponentialfunktionen for pixels i en raster.",
		exp2Name: "EKSP2",
		exp2Snip: "Beregner grundtal 2-eksponentialfunktionen for cellerne i en raster.",
		exp2Desc: "Denne funktion beregner grundtal 2-eksponentialfunktionen for pixels i en raster.",
		expName: "EKSP",
		expSnip: "Beregner grundtal e-eksponentialfunktionen for cellerne i en raster.",
		expDesc: "Denne funktion beregner grundtal e-eksponentialfunktionen for pixels i en raster.",
		extractBandName: "Udtræk bånd",
		extractBandSnip: "Angiver hvilke bånd, der skal arbejdes med, når du bruger flerbåndsdatasæt.",
		extractBandDesc: " Funktionen Udtræk bånd giver dig mulighed for at udtrække et eller flere bånd fra, eller ændre rækkefølge på bånd i, et rasterdatasæt med flere bånd.<div><br/>Du kan bruge funktionen Udtræk bånd før andre funktioner, såsom Aritmetik, til at styre, hvilke bånd der bruges som input i den næste funktion.</div>",
		fillName: "Fyld",
		fillSnip: "Fylder fordybninger i en overfladeraster for at fjerne små ufuldkommenheder i dataene.",
		fillDesc: "Den globale funktion Fyld lokaliserer og fylder fordybninger og toppe i en højdeoverfladeraster for at fjerne små ufuldkommenheder i dataene. Funktionen fylder i en gentagen proces, indtil alle fordybninger er fyldt inden for den angivne Z-grænse.<div><br/>Når en højdeoverflade er oprettet med Orto-kortlægningsværktøjer eller på anden måde, er der ofte små men betydelige fejl i form af fordybninger og toppe i dataene. I fotogrammetri betegnes fordybninger og toppe ofte som huller og spidser. Da overfladedata ofte anvendes til modellering, f.eks. hydrologisk modellering, er det vigtigt at rette disse fordybnings- og topfejl på en måde, der er i overensstemmelse med de omgivende data.</div>",
		floatName: "Flydende",
		floatSnip: "Konverterer hver enkelt celleværdi for en raster til en repræsentation med flydende komma.",
		floatDesc: "Funktionen Flydende konverterer hver enkelt pixelværdi for en raster til en repræsentation med flydende komma.",
		flowAccumulationName: "Flow-akkumulering",
		flowAccumulationSnip: "Opretter en raster af akkumuleret flow i hver celle. En vægtfaktor kan eventuelt anvendes.",
		flowAccumulationDesc: "Den globale funktion Flow-akkumulering skaber en raster af akkumuleret flow i hver pixel, som er fastlagt ved at akkumulere vægten for alle pixels, der strømmer ind i hver nedadgående pixel. Hvis der ikke er angivet nogen vægtraster, anvendes en vægt på 1 for hver pixel, og værdien af pixels i outputrasteren er antallet af pixels, der strømmer ind i hver pixel.<div><br/>Outputpixels med en høj flow-akkumulering er områder med koncentreret flow og kan bruges til at identificere strømkanaler. Outputpixels med en flow-akkumulering på nul er lokale topografiske højdepunkter og kan bruges til at identificere højderygge.</div>",
		flowDirectionName: "Flowretning",
		flowDirectionSnip: "Opretter en raster for flowretning fra hver celle til dens nabo med den stejleste nedadgående hældning.",
		flowDirectionDesc: "En af de vigtige ting, når man skal udlede hydrologiske egenskaber ved en overflade, er evnen til at fastslå flowretningen fra hver pixel i rasteren. Raster-funktionen Flowretning bruger en overflade som input og opretter en raster for flowretning fra hver pixel til dens nabo med den stejleste nedadgående hældning. funktionen Flowretning understøtter tre metoder til flowmodellering: D8 (otte retninger), Multi-Flow Direction (MFD) og D-Infinity (DINF). ",
		flowDistanceName: "Flow-afstand",
		flowDistanceSnip: "Beregner den minimale nedadgående vandrette eller lodrette afstand for hver celle til celler på en strøm eller en flod, som de strømmer i.",
		flowDistanceDesc: "For hver pixel beregner funktionen den laveste nedadgående vandrette eller lodrette afstand til pixel(s) på en flod eller strøm, som de strømmer i. Hvis en valgfri flowretningsraster findes, vil nedløbsretningerne være begrænset til dem, der er defineret af rasteren for inputflowets retning. Output er raster for flow-afstand.",
		focalName: "Fokuseret statistik",
		focalSnip: "Beregner fokuseret statistik for hver pixel i et billede baseret på et defineret fokusområde.",
		focalDesc: "Funktionen Fokuseret statistik beregner fokuseret statistik for hver pixel i et billede baseret på et bestemt fokusområde.",
		geometricName: "Geometrisk",
		geometricSnip: "Øger positionsnøjagtigheden for et datasæt ved at tage hensyn til højde.",
		geometricDesc: "Funktionen Geometrisk frembringer et orto-tilpasset billede baseret på en sensordefinition og en terrænmodel. Den øger positionsnøjagtigheden for et datasæt ved at tage hensyn til højde.",
		grayscaleName: "Gråtoneskala",
		grayscaleSnip: "Konverterer konverterer et flerbåndsbillede til et enkeltbåndsbillede i gråtoneskala.",
		grayscaleDesc: "Denne funktion konverterer et flerbåndsbillede til et enkeltbåndsbillede i gråtoneskala.<div><br/>Denne funktion anvender specificerede vægte for hvert inputbånd og normaliserer outputbilledet. Vægtene anvendes ofte, fordi nogle bånd har skiftende betydning afhængigt af anvendelsen. For eksempel indeholder det blå bånd ofte mere støj end andre bånd.</div>",
		greaterThanEqualName: "Større end eller lig med",
		greaterThanEqualSnip: "Udfører en relationsbaseret Større end eller lig med-handling på to inputs celle for celle. Returnerer 1 for celler, hvor den første raster er større end eller lig med den anden raster, og returnerer 0, hvis det ikke er tilfældet.",
		greaterThanEqualDesc: "Funktionen udfører en relationsbaseret Større end eller lig med-handling på to inputs pixel for pixel. Den returnerer en værdi på 1 for pixels, hvor den første raster er større end eller lig med den anden raster, og en værdi på 0 for pixels, hvor den første raster ikke er større end eller lig med den anden raster.",
		greaterThanName: "Større end",
		greaterThanSnip: "Udfører en relationsbaseret Større end-handling på to inputs celle for celle. Returnerer 1 for celler, hvor den første raster er større end den anden raster, og 0 for celler, hvis det ikke er tilfældet.",
		greaterThanDesc: "Funktionen udfører en relationsbaseret Større end-operation på to inputs pixel for pixel. Returnerer en værdi på 1 for pixels, hvor den første raster er større end den anden raster, og en værdi på 0 for pixels, hvor den første raster ikke er større end den anden raster.",
		heatIndexName: "Varmeindeks",
		heatIndexSnip: "Kombinerer omgivende temperatur og relativ fugtighed og returnerer oplevet temperatur.",
		heatIndexDesc: "Denne funktion beregner den oplevede temperatur baseret på omgivende temperatur og relativ fugtighed. Den oplevede temperatur beskrives ofte som hvor varmt det føles for menneskekroppen.<div><br/>Dette indeks kan være nyttigt til beregning af risiko i relation til medicinske problemer som muskelkrampe, dehydrering, varmeudmattelse eller, mere alvorligt, hedeslag på varme og fugtige dage. Når den relative fugtighed er høj, bliver det vanskeligere for kroppens sved at fordampe, hvilket gør det sværere for mennesker at blive afkølet på en naturlig måde. Kort over varmeguider eller advarsler er ofte et produkt af at omklassificere varmeindeksresultatet til klasser. Jo højere indeksværdien er, jo mere sandsynligt er det, at det bliver en advarsel frem for blot en vejledning.</div>",
		hillshadeName: "Skyggevirkning",
		hillshadeSnip: "Opretter en 3D-repræsentation af overfladen med solens relative position taget i betragtning ved skyggevirkning på billedet",
		hillshadeDesc: "Funktionen Skyggevirkning frembringer en 3D-repræsentation i gråtoneskala af terrænoverfladen med solens relative position, så der kommer skyggevirkning på billedet. <div><br/>Skyggevirkning er en teknik til visualisering af terræn på baggrund af en lyskilde og hældning og aspekt for højdeoverfladen. Det er en kvalitativ metode til visualisering af topografi og giver ikke absolutte højdeværdier. </div>",
		intName: "Heltal",
		intSnip: "Konverterer hver celleværdi for en raster til et helt tal ved afkortning.",
		intDesc: "Funktionen Heltal konverterer hver enkelt pixelværdi for en raster til et helt tal ved afkortning.",
		interpolateIrregularDataName: "Interpolér uregelmæssige data",
		interpolateIrregularDataSnip: "Interpolerer fra punktskyer eller uregelmæssige gitre.",
		interpolateIrregularDataDesc: "Nogle netCDF- eller HDF-datasæt gemmer deres geoplacering som uregelmæssigt adskilte arrayer af pixels eller punktdata. Når du tilføjer disse datasæt til et mosaikdatasæt, tager den interpolerede uregelmæssige datafunktion de uregelmæssige gitterdata og omstrukturerer dem, så hver pixel får samme størrelse og er firkantet.<div><br/>Når du tilføjer variabler fra netCDF eller HDF til et mosaikdatasæt, vil det automatisk kontrollere, om dataene er regelmæssigt opstillet. Hvis det ikke er tilfældet, kan den funktionen Interpolér uregelmæssige data bruges til at konvertere de uregelmæssige data til en raster med regelmæssigt gitter. Du kan ændre interpoationsmetoden og cellestørrelsen, der bruges i rasterfunktionen Interpolér uregelmæssige data. For rasterdata med regelmæssigt mellemrum vil der ikke blive anvendt interpolation, og dataene vil blive læst, som de er.</div>",
		isNullName: "er nul",
		isNullSnip: "Bestemmer hvilke værdier fra inputrasterne, der er NoData, celle for celle. Returnerer en værdi på 1, hvis inputværdierne er NoData, og 0 for celler, der ikke er.",
		isNullDesc: "Funktionen Er nul bestemmer, hvilke værdier fra inputrasteren der er NoData pixel for pixel. Den returnerer en værdi på 1, hvis inputværdien er NoData, og en værdi på 0 for pixels, der ikke er NoData.",
		kernelDensityName: "Kernetæthed",
		kernelDensitySnip: "Beregner en størrelse pr. område ud fra punkt- eller polylinje-egenskaber ved hjælp af en kernefunktion, så den tilpasser til en jævnt konisk overflade til hvert punkt eller hver polylinje.",
		kernelDensityDesc: "Denne funktion beregner en størrelse pr. område ud fra punkt- eller polylinje-egenskaber ved hjælp af en kernefunktion, så den tilpasser til en jævnt konisk overflade til hvert punkt eller hver polylinje.",
		keyMetadataName: "Vigtige metadata",
		keyMetadataSnip: "Tilsidesætter eller indsætter vigtige metadata for en raster i en funktionskæde.",
		keyMetadataDesc: "Denne funktion gør det muligt at indsætte eller tilsidesætte vigtige metadata for en raster.<div><br/>Oplysningerne i vigtige metadata bruges til at hjælpe applikationen med behandling og gengivelse, herunder at levere nyttige oplysninger som sensornavn, båndnavne eller skydække, der er forbundet med billedet.</div>",
		shortestPathName: "Rute med de laveste omkostninger",
		shortestPathSnip: "Udfører en omkostning/afstand-analyse ved hjælp af kilde- og destinationsinput, som derefter bruges til at fastlægge ruten med de laveste omkostninger fra en kilde til en destination.",
		shortestPathDesc: "Funktionen Rute med de laveste omkostninger beregner ruten med de laveste omkostninger fra en kilde til en destination. Afstanden med de laveste akkumulerede omkostninger beregnes for hver pixel over en omkostningsoverflade til nærmeste kilde. Det frembringer en outputraster, der registrerer den eller de ruter med de laveste omkostninger fra udvalgte steder til de nærmeste kildepixels, der er defineret inden for den akkumulative omkostningsoverflade, hvad angår omkostninger/afstand.<div><br/>Hver rute med de laveste omkostninger tildeles en værdi, når den registreres i scanningsprocessen. Den sidste pixel på kilderasteren på en omkostningsrute får værdien 1. Den første rute får værdien 3, den anden 4 osv. Når flere ruter fusionerer og følger den resterende afstand tilbage til en kilde ad samme rute, tildeles det segment, hvor de to ruter følges ad, værdien 2. Den fusionerede del af ruten kan ikke tildeles værdien fra en af ruterne, da den fusionerede del hører til begge ruter.</div>",
		lessThanEqualName: "Mindre end eller lig med",
		lessThanEqualSnip: "Udfører en relationsbaseret Mindre end eller lig med-handling på to inputs celle for celle. Returnerer 1 for celler, hvor den første raster er mindre end eller lig med den anden raster, og returnerer 0, når det ikke er tilfældet.",
		lessThanEqualDesc: "Funktionen udfører en relationsbaseret Mindre end eller lig med-operation på to inputs pixel for pixel. Den returnerer en værdi på 1 for pixels, hvor den første raster er mindre end eller lig med den anden raster, og en værdi på 0, hvor den ikke er mindre end eller lig med den anden raster.",
		lessThanName: "Mindre end",
		lessThanSnip: "Udfører en relationsbaseret Mindre end-handling på to inputs celle for celle. Returnerer 1 for celler, hvor den første raster er mindre end den anden raster og 0, hvis den ikke er.",
		lessThanDesc: "Funktionen udfører en relationsbaseret Mindre end-operation på to inputs pixel for pixel. Den returnerer en værdi på 1 for pixels, hvor den første raster er mindre end den anden raster, og en værdi på 0, hvis den ikke er mindre end den anden raster.",
		lnName: "Ln",
		lnSnip: "Beregner den naturlige logaritme (grundtal e) for celler i en raster.",
		lnDesc: "Funktionen Ln beregner den naturlige logaritme (grundtal e) for hver pixel i en raster.",
		log10Name: "Log10",
		log10Snip: "Beregner grundtal 10-logaritmen for celler i en raster.",
		log10Desc: "Funktionen Log10 beregner grundtal 10-logaritmen for hver pixel i en raster.",
		log2Name: "Log2",
		log2Snip: "Beregner grundtal 2-logaritmen for celler i en raster.",
		log2Desc: "Funktionen Log2 beregner grundtal 2-logaritmen for hver pixel i en raster.",
		lookupName: "Søgning",
		lookupSnip: "Opretter en ny raster ved at søge efter værdier, der findes i et andet felt i tabellen for inputrasteren.",
		lookupDesc: "Funktionen opretter en ny raster ved at slå værdier op, der findes i et andet felt i tabellen for inputrasteren.",
		mlClassifyName: "ML-klassifikation",
		mlClassifySnip: "Klassificerer billeder ved at vurdere hver enkelt pixel. Blandede pixels tildeles til de objekt med den højeste procentdel i den pågældende pixel.",
		mlClassifyDesc: "Funktionen ML-klassifikation giver dig mulighed for at udføre en overvåget klassifikation ved hjælp af algoritmen for den højeste sandsynlighedsklassifikation på et raster datasæt eller et mosaikdatasæt. Denne funktion kræver en klassifikationssignaturfil.",
		maskName: "Maske",
		maskSnip: "Indstiller værdier, som ikke skal vises.",
		maskDesc: "Denne raster-funktion angiver værdier, som ikke skal vises i din raster. Ved hjælp af funktionen Maske angives en eller flere NoData-værdier eller en række gyldige pixelværdier. ",
		minusName: "Minus",
		minusSnip: "Trækker værdien af den anden inputraster fra værdien af den første inputraster celle for celle.",
		minusDesc: "Funktionen Minus trækker værdien af den anden inputraster fra værdien af den første inputraster pixel for pixel.",
		modName: "Mod",
		modSnip: "Finder restværdien (modulo) af den første raster, når den divideres med den anden raster celle for celle.",
		modDesc: "Funktionen Mod finder restværdien (modulo) af den første raster, når den divideres med den anden raster pixel for pixel. Rækkefølgen af input er vigtig og påvirker outputresultatet.",
		mosaicRastersName: "Mosaikraster",
		mosaicRastersSnip: "Sætter et sæt rasterdatasæt sammen for at oprette et enkelt datasæt.",
		mosaicRastersDesc: "Funktionen Mosaikraster opretter et mosaikbillede ud fra flere billeder. Når der er overlapning mellem billederne, er der flere metoder, du kan vælge imellem for at bestemme, hvilke billeder der vises.",
		ndviColorizedName: "NDVI-farvelægning",
		ndviColorizedSnip: "Opretter et flerbåndsdatasæt, der repræsenterer vegetationssundhed baseret på forskellen mellem de røde og nær-infrarøde bånd.",
		ndviColorizedDesc: "Funktionen NDVI-farvelægning anvender NDVI-funktionen på inputbilledet og bruger derefter et farvekort eller en farveskala til at vise resultatet.",
		ndviName: "NDVI",
		ndviSnip: "Beregner Normalized Difference Vegetation Index (NDVI).",
		ndviDesc: "Funktionen NDVI skaber et enkeltbåndsdatasæt, der repræsenterer vegetationssundhed baseret på forskellen mellem de røde og nær-infrarøde bånd.<div><br/>NDVI er et standardiseret indeks, der gør det muligt at generere et billede, der viser grønhed, også kendt som relativ biomasse. Dette indeks drager fordel af kontrasten mellem de to bånds egenskaber ud fra et multispektralt rasterdatasæt. Absorberingen af klorofylpigment i det røde bånd og plantematerialernes høje refleksion i det nær-infrarøde (NIR) bånd. Ekstremt lave eller negative NDVI-værdier repræsenterer områder uden vegetation overhovedet, som f.eks. skyer, vand eller sne. Meget lave værdier repræsenterer områder med lav til ingen vegetation, såsom beton, sten eller bar jord. Moderate værdier repræsenterer områder med buske og græsarealer. Høje værdier repræsenterer skovområder og frodig vegetation.</div>",
		negateName: "Negér",
		negateSnip: "Ændrer fortegnet (ganger med -1) for celleværdierne for inputrasteren celle for celle.",
		negateDesc: "Funktionen Negér ændrer fortegnet (ganger med -1) for pixelværdierne for inputrasteren på en pixel ",
		nibbleName: "Nibble",
		nibbleSnip: "Erstatter celler i en raster, der svarer til en maske, med værdierne for de nærmeste naboer.",
		nibbleDesc: "Den globale funktion Nibble tillader, at udvalgte områder af en raster tildeles værdien for deres nærmeste nabo. Dette er nyttigt ved redigering af områder i en raster, hvor dataene kan være fejlagtige.",
		notEqualName: "Ikke lig med",
		notEqualSnip: "Udfører en relationsbaseret Ikke lig med-operation på to input celle for celle. Returnerer 1 for celler, hvor den første raster ikke er lig med den anden raster, og returnerer 0, når den er lig med.",
		notEqualDesc: "Funktionen udfører en relationsbaseret Ikke lig med-handling på to inputs pixel for pixel. Den returnerer en værdi på 1 for pixels, hvor den første raster ikke er lig med den anden raster, og en værdi på 0 for pixels, hvor den er lig med den anden raster.",
		pansharpeningName: "Pansharpen",
		pansharpeningSnip: "Forbedrer kunstigt den spatiale opløsning af et flerbåndsbillede ved at fusionere det med et pankromatisk billede med højere opløsning.",
		pansharpeningDesc: "Funktionen Pansharpen fusionerer et pankromatisk billede eller et rasterbånd med højere opløsning med en flerbåndsraster-datasæt med lavere opløsning for at øge flerbåndsbilledets spatiale opløsning.<div><br/>Formålet med Pansharpen er at skabe et billede med en højere visuel kvalitet. Da teknikkerne ændrer flerbåndsbilledets radiometri og spektrale egenskaber, skal Pansharpen-billeder bruges med forsigtighed til analytisk fjernmåling.</div>",
		pathAllocationName: "Rute-/afstandsallokering",
		pathAllocationSnip: "Beregner kilden med de laveste omkostninger for hver celle baseret på den laveste akkumulerede omkostning over en omkostningsoverflade, hvor der tages hensyn til overfladeafstand samt vandrette og lodrette omkostningsfaktorer.",
		pathAllocationDesc: "Funktionen Rute-/afstandsallokering beregner nærmeste kilde for hver celle baseret på den laveste akkumulerede omkostning over en omkostningsoverflade, hvor der tages hensyn til overfladeafstand samt vandrette og lodrette omkostningsfaktorer.",
		pathBackLinkName: "Rute/afstand BackLink",
		pathBackLinkSnip: "Definerer naboen, der er den næste celle på den rute med de laveste akkumulerede omkostninger til den kilde med de laveste omkostninger, hvor der tages hensyn til overfladeafstand samt vandrette og lodrette omkostningsfaktorer.",
		pathBackLinkDesc: "Funktionen Rute/afstand BackLink identificerer retningen for naboen, der er den næste celle på den rute med de laveste akkumulerede omkostninger til nærmeste kilde, hvor der tages hensyn til overfladeafstand samt vandrette og lodrette omkostningsfaktorer.",
		pathDistanceName: "Rute/afstand",
		pathDistanceSnip: "Beregner afstanden med de laveste akkumulerede omkostninger for hver celle fra eller til kilden med de laveste omkostninger, hvor der tages hensyn til overfladeafstand samt vandrette og lodrette omkostningsfaktorer.",
		pathDistanceDesc: "Funktionen Rute/afstand beregner afstanden med de laveste akkumulerede omkostninger for hver celle til nærmeste kilde, hvor der tages hensyn til overfladeafstand og vandrette og lodrette omkostningsfaktorer.",
		plusName: "Plus",
		plusSnip: "Lægger værdierne for to raster sammen celle for celle.",
		plusDesc: "Funktionen Plus lægger værdierne for to raster sammen pixel for pixel.",
		powerName: "Potens",
		powerSnip: "Opløfter celleværdierne i en raster til potensen af de værdier, der findes i en anden raster.",
		powerDesc: "Funktionen Potens opløfter pixelværdierne i en raster til potensen af de værdier, der findes i en anden raster.",
		radarCalibrationName: "Radarkalibrering",
		radarCalibrationSnip: "Konverterer RADARSAT-2-tilbagekastning.",
		radarCalibrationDesc: "Denne funktion kan bruges til at kalibrere RADARSAT-2-billeder i et mosaikdatasæt eller som et rasterprodukt. Kalibrering udføres på radarbilleder, så pixelværdierne er en sand repræsentation af radarens tilbagekastning.",
		rasterInfoName: "RasterInfo",
		rasterInfoSnip: "Ændrer egenskaberne i rasteren, f.eks. bitdybde, NoData-værdi, cellestørrelse osv.",
		rasterInfoDesc: "RasterInfo åbner en dialogboks med egenskaber for rasterdatasæt, såsom antallet af kolonner og rækker, antallet af bånd, pixeltype, udstrækning og den spatiale reference. Du kan redigere disse egenskaber ved at vælge et rasterdatasæt, der skal bruges som skabelon. ",
		rasterizeAttributesName: "Attributter for konvertering til raster",
		rasterizeAttributesSnip: "Beriger en raster gennem yderligere bånd, der kommer fra værdier af specificerede attributter fra en ekstern tabel eller en featuretjeneste.",
		rasterizeAttributesDesc: "Funktionen Attributter for konvertering til raster beriger en raster ved at tilføje bånd, der kommer fra værdier af specificerede attributter fra en ekstern tabel eller en featuretjeneste. Du kan eventuelt angive en zoneraster og den tilknyttede zone-ID-attribut for at aktivere regionsbaseret opslag.",
		rasterizeFeatureClassName: "Konverter objekter til raster",
		rasterizeFeatureClassSnip: "Konverterer objekter til raster.",
		rasterizeFeatureClassDesc: "Denne funktion konverterer polygon-, polylinje- og punktklassedata til et rasterlag.<div><br/>Objekter tildeles pixelværdier baseret på objekternes OBJECTID (standard). Eventuelt kan pixelværdierne baseres på et brugerdefineret værdifelt i inputobjektets attributtabel.</div>",
		recastName: "Omarbejd",
		recastSnip: "Ændrer parametrene for en funktionskæde i et mosaikdatasæt eller en billedtjeneste. Dette bruges ofte med LAS-datasæt for at undgå at skulle oprette et separat mosaikdatasæt til forskellige repræsentationer af terræn.",
		recastDesc: "Funktionen Omarbejd bruges til dynamisk at ændre funktionsparameteren, der anvendes i et mosaikdatasæt eller billedtjeneste, uden at ændringerne bevares fysisk.",
		regionGroupName: "Regionsgruppe",
		regionGroupSnip: "For hver celle i outputtet registreres identiteten af det forbundne område, som den pågældende celle tilhører. Der tildeles et unikt nummer til hver region.",
		regionGroupDesc: "Den globale funktion Regionsgruppe registrerer for hver celle i outputtet identiteten af det forbundne region, som den pågældende celle tilhører. Der tildeles et unikt nummer til hver region.<div><br/>Den første region, der scannes, modtager værdien en, den anden værdien to osv., indtil alle regioner har fået tildelt en værdi. Scanningen går fra venstre til højre, fra top til bund. De værdier, der tildeles outputzonerne, er baseret på, hvornår de registreres i scanningsprocessen.</div>",
		regionGrowName: "Regionsvækst",
		regionGrowSnip: "Frembringer regioner ud fra seed-punkter.",
		regionGrowDesc: "Funktionen Regionsvækst inddeler nabopixels i grupper ud fra den angivne radius fra seed-punktet. Gruppen af pixels eller objektet tildeles en angivet fyldværdi.",
		remapName: "Genberegn",
		remapSnip: "Ændrer pixelværdier ved at tildele nye værdier til intervaller af pixelværdier eller ved hjælp af en ekstern tabel.",
		remapDesc: "Funktionen Genberegn giver dig mulighed for at ændre eller omklassificere pixelværdierne for rasterdataene. Dette kan gøres ved enten at angive et interval af pixelværdier, der skal kortlægges til en output-pixelværdi, eller ved at bruge en tabel til at kortlægge pixelværdierne til outputpixelværdien.",
		reprojectName: "Genprojektion",
		reprojectSnip: "Ændrer projektionen af et rasterdatasæt, mosaikdatasæt eller rasterelement i et mosaikdatasæt. Det kan også omstrukturere dataene til en ny cellestørrelse og definere en oprindelse.",
		reprojectDesc: "Funktionen Genprojektion ændrer projektionen af et rasterdatasæt, mosaikdatasæt eller rasterelement i et mosaikdatasæt. Det kan også omstrukturere dataene til en ny cellestørrelse og definere en oprindelse.<div><br/>Funktionen Genprojektion kan bruges, når der oprettes en cache ud fra et raster- eller mosaikdatasæt, der ikke er i den påkrævede projektion. Når du f.eks. opretter en cachelagret billedtjeneste, som kan integreres af applikationer med andre cache-tjenester, er det vigtigt, at de alle er i samme projektion. Dette er ofte en Web Mercator-projektion. Eftersom mosaikdatasættet ikke kan genprojiceres, kan du gøre et af to: Du kan enten oprette et mosaikdatasæt, der refereres til, ud fra dit mosaikdatasæt i den ønskede projektion, eller du kan tilføje funktionen Genprojektion til mosaikdatasættets funktionskæde. Et andet eksempel bruger denne funktion på raster-elementet i et mosaikdatasæt. Når du bruger funktionen Cachelagret raster, ønsker du muligvis at indsætte funktionen Genprojektion, så cachen oprettes i den nye projektion. Rasteremner i et mosaikdatasæt kan cachelagres, når behandlingen er intens, og du forsøger at udgive en billedtjeneste, der er hurtig, uden at cachelagre hele billedtjenesten.</div>",
		resampleName: "Omstrukturering",
		resampleSnip: "Ændrer cellestørrelsen på en raster.",
		resampleDesc: "Funktionen Omstrukturering ændrer cellestørrelse, omstruktureringstype eller begge dele.<div><br/>Funktionen Omstrukturering bør kun bruges sammen med specifikke beregningskrav; for eksempel når du beregner vind- eller strømretningen, hvilket kræver omstrukturering fra kildeopløsningen.</div>",
		roundDownName: "Rund ned",
		roundDownSnip: "Returnerer den næste lavere heltalværdi, kun repræsenteret som en værdi med flydende komma, for hver celle i en raster.",
		roundDownDesc: "Funktionen Rund ned returnerer det næste lavere heltal som en værdi med flydende komma for hver pixel i en raster.",
		roundUpName: "Rund op",
		roundUpSnip: "Returnerer den næste højere heltalværdi, kun repræsenteret som en værdi med flydende komma, for hver celle i en raster.",
		roundUpDesc: "Rund op returnerer det næste højere heltal som en værdi med flydende komma for hver pixel i en raster.",
		segmentMeanShiftName: "Segment Mean Shift",
		segmentMeanShiftSnip: "Grupperer nabopixels med lignende spektrale egenskaber i segmenter.",
		segmentMeanShiftDesc: "Denne funktion identificerer objekter eller segmenter i dine billeder ved at gruppere tilstødende pixels, der har lignende spektrale og spatiale egenskaber. Du kan styre mængden af spatial og spektral udglatning for at hjælpe med at udlede funktioner, der har interesse.",
		s1RadiometricCalibrationName: "Sentinel-1 radiometrisk kalibrering",
		s1RadiometricCalibrationSnip: "Udfører forskellige typer radiometrisk kalibrering på Sentinel-1 data.",
		s1RadiometricCalibrationDesc: "Denne raster-funktion udfører tre forskellige kalibreringer for Sentinel 1-datasæt, herunder beta nought og gamma, og output er det kalibrerede datasæt. Målet med SAR-kalibrering er at tilvejebringe billeder, hvor pixelværdier kan relateres direkte til radarens tilbagekastning af scenen. Selvom ukalibrerede SAR-billeder er tilstrækkelige til kvalitativ brug, er kalibrerede SAR-billeder afgørende for kvantitativ brug af SAR-data.<div><br/>Typisk SAR-databehandling, som frembringer niveau 1-billeder, omfatter ikke radiometriske korrektioner og signifikante radiometriske biasrester. Derfor er det nødvendigt at anvende radiometrisk korrektion på SAR-billeder, så pixelværdierne for billederne virkelig repræsenterer radar-tilbagekastningen af den reflekterende overflade. Radiometrisk korrektion er også nødvendig for sammenligning af SAR-billeder, der kommer fra forskellige sensorer eller fra samme sensor på forskellige tidspunkter, i forskellige tilstande eller som er behandlet af forskellige processorer.</div>",
		s1ThermalNoiseRemovalName: "Fjernelse af termisk støj fra Sentinel-1 data",
		s1ThermalNoiseRemovalSnip: "Fjerner termisk støj fra Sentinel-1 data.",
		s1ThermalNoiseRemovalDesc: "Termisk støjkorrektion kan anvendes på fra Sentinel-1 Level-1 Single Look Complex (SLC)-produkter samt GRD-produkter (Level-1 Ground Range Detection), som ikke allerede er rettet. Operatøren kan også fjerne denne korrektion baseret på produktanmærkningerne for at genindføre det støjsignal, der blev fjernet for at frembringe det oprindelige produkt. Produktanmærkningerne bliver opdateret i overensstemmelse hermed, så korrektionen kan genanvendes. ",
		setNullName: "Angiv nul",
		setNullSnip: "Angiv nul angiver identificerede celleplaceringer til NoData baseret på et specificeret kriterium. Det returnerer NoData, hvis en betinget evaluering er sand, og returnerer værdien, der er angivet af en anden raster, hvis den er falsk.",
		setNullDesc: "Funktionen Angiv nul angiver de identificerede pixels til NoData, baseret på de specifikke kriterier. Den returnerer NoData, hvis en betinget vurdering er sand (1) og returnerer værdien, der er angivet i rasteren Falsk, hvis en betinget evaluering er falsk (0). Dette kriterium er angivet af outputtet fra en logisk matematisk funktion, som er inputrasteren.",
		shadedReliefName: "Skyggeeffekt",
		shadedReliefSnip: "Opretter en farvekodet, flerbånds 3D-repræsentation af overfladen med solens relative position taget i betragtning ved skyggelægning af billedet.",
		shadedReliefDesc: "Funktionen Skyggeeffekt skaber en 3D-repræsentation i farver af terrænet, som er skabt ved at fusionere billederne fra metoderne højdekode og skyggevirkning. Denne funktion bruger højde- og azimutegenskaberne til at angive solens position.<div><br/></div>",
		sinHName: "SinH",
		sinHSnip: "Beregner den hyperbolske sinus for celler i en raster.",
		sinHDesc: "Funktionen beregner den hyperbolske sinus for pixels i en raster.",
		sinName: "Sin",
		sinSnip: "Beregner sinus for celler i en raster.",
		sinDesc: "Funktionen beregner sinus for pixels i en raster.",
		slopeName: "Stigning",
		slopeSnip: "Beregner ændringshastigheden fra en pixelværdi til dens naboer.",
		slopeDesc: "Denne rasterfunktion beregner hældning, hvilket er hastigheden af ændring i højde for hver celle i en digital elevationsmodel (DEM). Det er den første afledte værdi af en DEM.<div><br/>Denne funktion bruger en accelereret atan()-funktion. Det er seks gange hurtigere, og tilnærmelsesfejlen er altid mindre end 0,3 grader.</div>",
		speckleName: "Speckle",
		speckleSnip: "Indeholder filtre til fjernelse af støj fra syntetiske aperturradar-datasæt.",
		speckleDesc: "Speckle er højfrekvent støj på radardata. Billederne, der genereres af SAR-systemer, er meget udsat for speckling-effekter på grund af behandlingen af spredte signaler og interferens fra elektromagnetiske bølger, der spredes fra overflader eller objekter. Denne Speckle-funktion filtrerer det specklede radardatasæt og udjævner støjen, mens kanter eller skarpe objekter i billedet bevares.",
		spectralConversionName: "Spektralkonvertering",
		spectralConversionSnip: "Anvender en matrix på et flerbåndsbillede.",
		spectralConversionDesc: "Funktionen Spektralkonvertering anvender en matrix på et flerbåndsbillede til at påvirke outputtets farveværdier.<div><br/>Nogle sensorer indsamler ikke blå bånd på grund af et lavt signal i forhold til støjen. Det kan f.eks. bruges til at konvertere et forkert farvet infrarødt billede til et pseudo-naturligt farvebillede.</div>",
		squareRootName: "Kvadratrod",
		squareRootSnip: "Beregner kvadratroden af celleværdierne i en raster.",
		squareRootDesc: "Funktionen Kvadratrod beregner kvadratroden af pixelværdierne i en raster.",
		squareName: "Kvadrat",
		squareSnip: "Beregner kvadratet af celleværdierne i en raster.",
		squareDesc: "Kvadrat beregner kvadratet af pixelværdierne i en raster.",
		statisticsHistogramName: "Statistik og histogram",
		statisticsHistogramSnip: "Definer eller tilknyt statistik og histogram.",
		statisticsHistogramDesc: "Funktionen Statistik og histogram bruges til at definere statistikken og histogrammet for en raster. Du kan indsætte denne funktion i slutningen af funktionskæden for at beskrive statistikken og histogrammet for en rasterfunktionsskabelon (RFT). Det kan være nødvendigt for at styre standardvisningen af behandlingsresultatet, især når der defineres en funktionskæde, der indeholder mange funktioner.<div><br/>Du kan definere statistikker ved at skrive værdierne eller importere fra et rasterdatasæt eller en XML-fil. Histogrammer kan kun defineres ved at importere en fil.</div>",
		statisticsName: "Statistik",
		statisticsSnip: "Beregner fokuseret statistik for hver pixel i et billede baseret på et defineret fokusområde.",
		statisticsDesc: "Funktionen Statistik beregner fokuseret statistik for hver pixel i et billede baseret på et defineret nærliggende fokusområde.<div><br/>Funktionen Statistik kan bruges til at udfylde tabte linjer i et billede. Tabte linjer skyldes ofte problemer i sensoren, hvor der ikke bliver indsamlet data. Dette er sket i sensorer som Landsat 7s Enhanced Thematic Mapper Plus (ETM+). Disse manglende data giver problemer ved analyse, samt når man ser på billedet. Der er ikke meget, der kan gøres, når man bruger billedet til analyse. Men hvis der findes et overlappende billede, kan det bruges i stedet for det manglende indhold. Det samme kan gøres, hvis billedet bruges til visualisering. Der findes dog ikke altid et ekstra billede til at udfylde det manglende indhold, så det skal udledes af de eksisterende data.</div>",
		streamLinkName: "Strømlink",
		streamLinkSnip: "Tildeler unikke værdier til dele af et lineært rasternetværk mellem skæringer.",
		streamLinkDesc: "Den globale funktion Strømlink tildeler unikke værdier til dele af et lineært rasternetværk mellem skæringer.<div><br/>Links er delen af en strømkanal, der forbinder to på hinanden følgende knudepunkter, et knudepunkt og udløbet, eller et knudepunkt og dræningsdelingen. Inden for hydrologi kaldes disse strømsegmenter for lige strækninger. Et knudepunkt er relateret til et punkt for vandløbsretning og medvirker til at markere et vandskel eller grænsen til et dræningsunderbasin.</div>",
		stretchName: "Stræk",
		stretchSnip: "Forbedrer et billede ved at justere rækkevidden af de viste værdier. Dette ændrer ikke de underliggende pixelværdier. Hvis en pixel har en værdi, der ligger uden for det angivne interval, vises den som enten minimum- eller maksimumværdien.",
		stretchDesc: "Funktionen Stræk forbedrer et billede ved at ændre egenskaber som lysstyrke, kontrast og gamma gennem flere stræktyper. Denne funktion bruger statistikkerne fra raster inden for mosaikdatasættet. Derfor skal du sørge for, at der er beregnet statistikker, hvis du benytter denne funktion.<div><br/>Stræktypen definerer et histogram-træk, som vil blive anvendt på rasterne for at forbedre deres udseende. Strækning forbedrer dataenes udseende ved at sprede pixelværdierne langs et histogram ud fra minimum- og maksimumværdierne, der er defineret af deres bitdybde. </div>",
		swathName: "Swath",
		swathSnip: "Interpolerer fra uregelmæssige grids eller swath-data.",
		swathDesc: "Nogle netCDF- eller HDF-datasæt gemmer deres geoplacering som uregelmæssigt adskilte arrayer. Når du tilføjer disse datasæt til et mosaikdatasæt, tager den interpolerede uregelmæssige datafunktion de uregelmæssige gitterdata og omstrukturerer dem, så hver pixel får samme størrelse og er firkantet.<div><br/>Når du tilføjer variabler fra netCDF eller HDF til et mosaikdatasæt, vil det automatisk kontrollere, om dataene er regelmæssigt opstillet. Hvis det ikke er tilfældet, bliver Swath-funktionen automatisk anvendt til at konvertere den uregelmæssige raster til punkter og derefter til en raster med regelmæssigt gitter. Du kan ændre interpoationsmetoden og cellestørrelsen, der bruges i rasterfunktionen Swath. For rasterdata med regelmæssigt mellemrum vil der ikke blive anvendt interpolation, og dataene vil blive læst, som de er.</div>",
		tanHName: "TanH",
		tanHSnip: "Beregner den hyperbolske tangens for pixels i en raster.",
		tanHDesc: "Funktionen beregner den hyperbolske tangens for pixels i en raster.",
		tanName: "Tan",
		tanSnip: "Beregner tastens for celler i en raster.",
		tanDesc: "Funktionen beregner tangens for pixels i en raster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Beregner niveauer for vegetation, vådhed og lysstyrke. Denne teknik er baseret på koefficienter, der skal beregnes specifikt til en sensor.",
		tasseledCapDesc: "Tasseled Cap (Kauth-Thomas)-transformationen er beregnet til at analysere og kortlægge vegetationsfænomenologi og ændringer i byudvikling, der registreres af forskellige satellitsensorsystemer. Det er kaldes Tasseled Cap-transformation på grund af formen på den grafiske distribution af data. Transformationen tilvejebragte et rationale for de mønstre, der findes i Landsat MSS-data for landbrugsarealer som en funktion af afgrødens livscyklus. Når afgrøder vokser fra frø til moden plante, sker der en nettoforøgelse i nær-infrarød reflektion og et fald i rød reflektion baseret på jordfarve<div><br/>Anvendelsen af ​​denne transformation er udvidet fra overvågning af afgrøder til analyse og kortlægning af vegetation til en række anvendelser som skovbrug, industriel vegetationsstyring, kortlægning og styring af økosystemer, opgørelse og overvågning af kulstofudledning og -kreditter, byudvikling og meget mere. Det er også udvidet sig fra kun at understøtte Landsat MSS til at omfatte andre populære satellitsystemer som Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, WorldView-2 og RapidEye multispektrale sensorer.</div>",
		timesName: "Tider",
		timesSnip: "Multiplicerer værdierne af to raster celle for celle.",
		timesDesc: "Funktionen Tider multiplicerer værdierne for to raster pixel for pixel.",
		transposeBitsName: "Transponer bits",
		transposeBitsSnip: "Udpakker bitsene i inputpixlen og mapper dem til specificerede bits i outputpixlen. Formålet med denne funktion er at manipulere bits fra nogle få input, såsom Landsat 8 kvalitetsbåndprodukterne.",
		transposeBitsDesc: "Funktionen Transponer bits udpakker bitsene i inputpixlen og mapper dem til specificerede bits i outputpixlen. Formålet med denne funktion er at manipulere bits fra nogle få input, såsom Landsat 8 kvalitetsbåndprodukterne.",
		unitConversionName: "Enhedskonvertering",
		unitConversionSnip: "Ændrer værdier fra en måleenhed til en anden.",
		unitConversionDesc: "Denne funktion konverterer pixels fra en enhed til en anden. Den understøtter konvertering af afstand, hastighed og temperatur.",
		vectorFieldName: "Vektorfelt",
		vectorFieldSnip: "Viser datasæt med både størrelse (u) og retning (v) som pile, hvor størrelsen er repræsenteret af størrelse og retningen er repræsenteret af pilens vinkel.",
		vectorFieldDesc: "Funktionen Vektorfelt bruges til at sammensætte og konvertere to raster til en tobåndsraster, der enten har datatypen Størrelse-Retning eller datatypen UV.<div><br/>U-værdien betegnes undertiden som zonehastigheden, og V-værdien betegnes undertiden som meridionalhastigheden.</div>",
		viewshed2Name: "Synsfelt",
		viewshed2Snip: "Bestemmer, hvilke placeringer af rasteroverflader, der er synlige for et sæt observatør-objekter ved hjælp af geodætiske metoder.",
		viewshed2Desc: "Funktionen Synsfelt bestemmer, hvilke placeringer af rasteroverflader, der er synlige for et sæt observatør-objekter ved hjælp af geodætiske metoder<div><br/>Sigtbarheden af ​​hvert pixelcenter bestemmes af en synslinjetest mellem målet og hver enkelt observatør. Hvis en observatør kan se målet ved pixelcentret, betragtes en pixel som synlig. Dette værktøj tager altid hensyn til jordens krumning, når synligheden fastlægges.</div>",
		watershedName: "Vandskel",
		watershedSnip: "Fastlægger det bidragende område, der ligger over et sæt pixels i en raster",
		watershedDesc: "Den globale funktion Vandskel fastlægger det bidragende område, der ligger over et sæt pixels i en raster. Vandskel af markeret ud fra en strømretningsraster, der identificerer strømretningen ud fra hver pixel.",
		weightedOverlayName: "Vægtet overlay",
		weightedOverlaySnip: "Lægger flere raster oven på hinanden ed hjælp af en fælles måleskala og vægt i overensstemmelse med deres individuelle vigtighed.",
		weightedOverlayDesc: "Denne funktion gør det muligt at lægge flere raster oven på hinanden ved hjælp af en fælles måleskala og vægt i overensstemmelse med deres individuelle vigtighed.",
		weightedSumName: "Vægtet sum",
		weightedSumSnip: "Vægter og tilføjer en array af raster celle for celle.",
		weightedSumDesc: "Funktionen Vægtet sum giver mulighed for at udføre overlay på flere raster, multiplicere hver enkelt med deres givne vægt og lægge dem sammen.",
		windchillName: "Vindafkøling",
		windchillSnip: "Kombinerer den omgivende temperatur og vindhastighed for at beregne Vindafkølingsfaktoren.",
		windchillDesc: "Funktionen Vindafkøling er nyttig til at identificere farlige vinterforhold, der kan resultere i forfrysninger eller endog hypotermi, afhængig af hvor længe man udsættes for elementerne. Vindafkøling er en måde at måle på, hvor koldt en person føler det, når der tages hensyn til vinden ved kolde temperaturer. Jo større vindhastighed, jo hurtigere mister kroppen varme, og jo koldere det vil føles.",
		zonalRemapName: "Genberegning af zoner",
		zonalRemapSnip: "Genberegner pixels i en raster baseret på zoner, der er defineret i en anden raster, og zone-afhængig værdi-kortlægning, der er defineret i en tabel.",
		zonalRemapDesc: "Denne funktion giver mulighed for at genberegne pixels i en raster baseret på zoner, der er defineret i en anden raster, og zone-afhængig værdi-kortlægning, der er defineret i en tabel.",
		zonalStatisticsName: "Zonestatistik",
		zonalStatisticsSnip: "Beregner statistik for værdier i en raster inden for zonerne i et andet datasæt.",
		zonalStatisticsDesc: "Funktionen beregner statistik for værdier i en raster inden for zonerne i et andet datasæt. En zone er defineret som alle områder i inputtet, der har samme værdi. Disse områder behøver ikke at støde op til hinanden. Når zone- og værdi-input begge er raster med samme opløsning, bruges de direkte. Hvis opløsningerne er forskellige, anvendes en intern omstrukturering for at gøre opløsningerne ens, inden zoneoperationen udføres.",
		flowLengthName: "Flow-længde",
		flowLengthSnip: "Beregner opstrøms- eller nedstrømsafstanden eller den vægtede afstand langs strømningsvejen for hver celle.",
		flowLengthDesc: "Dette er en global rasterfunktion. Denne funktion opretter et rasterlag med opstrøms- eller nedstrømsafstand eller vægtet afstand langs strømningsvejen for hver celle.<div><br/>En primær anvendelse af funktionen Flow-længde er at beregne længden af ​​den længste strømningsvej inden for et givet bassin. Denne måling bruges ofte til at beregne koncentrationstiden for et bassin. Dette gøres ved hjælp af indstillingen Opstrøms. Funktionen kan også bruges til at oprette afstandsdiagrammer over hypotetisk nedbør og afstrømningshændelser ved hjælp af vægtrasteren som en impedans for nedadgående bevægelse.</div>",
		streamOrderName: "Strømrækkefølge",
		streamOrderSnip: "Tildeler en numerisk rækkefølge til segmenter i en raster, der repræsenterer grene i et lineært netværk",
		streamOrderDesc: "Dette er en global rasterfunktion. Denne funktion opretter et rasterlag, der tildeler en numerisk rækkefølge til segmenter i en raster, der repræsenterer grene i et lineært netværk.<div><br/>Outputtet fra funktionen Strømrækkefølge vil være af højere kvalitet, hvis input strøm-rasterlaget og input-flowretnings-rasterlaget er afledt fra samme overflade. Hvis strømrasteren er afledt fra et rasteriseret strømsdatasæt, er output muligvis ikke anvendeligt, fordi retningen, celle for celle, ikke svarer til placeringen af strømceller. Resultaterne af funktionen Flow-akkumulering kan bruges til at skabe et raster strøm-netværk ved at anvende en tærskelværdi til at vælge celler med et høj akkumuleret flow. F.eks. bruges celler, hvor mere end 100 celler strømmer ind i dem, til at definere strøm-netværket. Brug funktionerne Betinget eller Angiv nul til at oprette en strømnetværksraster, hvor flowakkumuleringsværdier på 100 eller derover går til en, og resten sendes i baggrunden (NoData). Det resulterende strømnetværk kan bruges i funktionen Strømrækkefølge. Denne funktion understøtter kun et D8-inputflow-retnings-rasterlag. D8-flowretninger kan oprettes ved hjælp af funktionen Flowretning og køres med standardflowretningstypen D8.</div>",
		snapPourPointName: "Fastgør punkt for vandløbsretning",
		snapPourPointSnip: "Fastgør punkter for vandløbsretning til cellen med højeste flowakkumulering inden for en specificeret afstand",
		snapPourPointDesc: "Dette er en global rasterfunktion. Denne funktion fastgør punkter for vandløbsretning til cellen med højeste flowakkumulering inden for en specificeret afstand.<div><br/>Funktionen Fastgør punkt for vandløbsretning bruges til at sikre valget af punkter med højt akkumuleret flow ved afgrænsning af dræningsbassiner ved hjælp af funktionen Vandskel. Fastgør punkt for vandløbsretning søger inden for fastgørelsesafstanden omkring de specificerede punkter for vandløbsretning for cellen med det højeste akkumulerede flow og flytter punktet for vandløbsretning til det sted. Output er et heltal-rasterlag, når de originale placeringer for punkter for vandløbsretning er blevet fastgjort til steder med højere akkumuleret flow.</div>",
		sinkName: "Fordybning",
		sinkSnip: "Opretter en raster, der identificerer alle fordybninger eller områder med intern dræning",
		sinkDesc: "Dette er en global rasterfunktion. Denne funktion skaber et rasterlag, der identificerer alle fordybninger eller områder med intern dræning. En fordybninger er en celle eller et sæt spatialt forbundne celler med en flowretning, der ikke kan tildeles en af de otte gyldige værdier i en flowretningsraster. Dette kan opstå, når alle tilstødende celler er højere end behandlingscellen, eller når to celler strømmer ind i hinanden, hvilket skaber en to-celle-sløjfe.<div><br/>Funktionen Fordybning understøtter kun et D8-inputflow-rasterlag. D8-flowretninger kan oprettes ved hjælp af funktionen Flowretning og køres med standard flowretningstypen D8. Outputtet fra funktionen Fordybning er en heltal-raster, hvor hver fordybning tildeles en unik værdi. Disse unikke værdier har et interval mellem et og det samlede antal fordybninger. Hvis det samlede antal dræn f.eks. er 1000, så spænder de unikke værdier fra 1 til 1000.</div>",
		aggregateName: "Aggregér",
		aggregateSnip: "Genererer en version af en raster med lavere opløsning.",
		aggregateDesc: "Funktionen Aggregér omstrukturerer en input-raster til en grovere opløsning baseret på en specificeret aggregeringsstrategi. Enhver output-celle indeholder Sum, Minimum, Maksimum, Middelværdi eller Median for de input-celler, som er omgivet af den pågældende celles udstrækning.<div><br/>Du kan angive den faktor, som input-rasterens cellestørrelse skal ganges med. For eksempel vil en cellefaktor på 3 resultere i en output-cellestørrelse, der er er 3 gange større end input-rasterens cellestørrelse. Du kan definere, hvordan outputtets udstrækning skal håndteres, hvis antallet af rækker eller kolonner i inputtet ikke er nøjagtig multipel af cellefaktoren. Som standard vil de øverste og højre grænser blive udvidet til at dække en større spatial udstrækning end input-rasteren for at sikre, at alle input-cellerne behandles. De øverste og højre grænser kan også reduceres med henblik på at dække en mindre udstrækning, så antallet af rækker og kolonner er en nøjagtig multipel af cellefaktoren. Du kan definere, hvordan NoData-celler skal behandles af aggregeringsberegningen. Standardmekanismen er, at input-NoData-celler, der falder inden for den spatiale udstrækning af en større celle i output-rasteren, vil blive tilsidesat, når den pågældende output-celles værdi skal fastsættes. Du kan også angive, at hvis der blot er en enkelt input-NoData-celle inden for den spatiale udstrækning af en output-celle, vil denne celle være en NoData-celle i output-rasteren.</div>",
		ccdcName: "CCDC-analyse",
		ccdcSnip: "Evaluerer ændringer i pixelværdier over tid ved hjælp af algoritmen Continuous Change Detection and Classification (CCDC) og genererer modelresultater.",
		ccdcDesc: "Funktionen CCDC-analyse evaluerer ændringer i pixelværdier over tid ved hjælp af algoritmen Continuous Change Detection and Classification (CCDC) og genererer en flerdimensional raster, der indeholder modelresultater. Den understøttes udelukkende i sammenhæng med funktionen Detektér ændring ved hjælp af ændringsanalyse i en rasterfunktionsskabelon. Hvis du vil generere et raster-output, skal du knytte funktionen CCDC-analyse til funktionen Detektér ændring ved hjælp af ændringsanalyse, gemme den som en rasterfunktionsskabelon og køre rasteranalyse sammen med funktionsskabelonen.<div><br/>Denne funktion anvender algoritmen Continuous Change Detection and Classification (CCDC) til at evaluere ændringer i pixelværdier over tid for en stak billeder. I en tidsserie med optiske billeder eller afledte billeder (f.eks. NDVI) kan pixelværdierne variere af flere årsager: 1. Sæsonbestemt ændring – Ændringer i pixelværdierne reflekterer ændringer i vegetationen på grund af sæsonbestemte variationer i temperatur og nedbør. På den nordlige halvkugle forventer vi f.eks. at se en højere tæthed af grøn vegetation om sommeren end om vinteren; 2. Gradvis ændring – Ændringer i pixelværdierne reflekterer tendenser i vegetation eller overfladevand på grund af klimavariation eller arealforvaltningspraksis over lang tid. For eksempel kan omfanget af jordbund uden bevoksning vokse gradvist på grund af nedgang i nedbørsmængderne over lang tid; og 3. Pludselig ændring – Ændringer i pixelværdierne reflekterer ændringer i arealdække, der opstår pludseligt pga. skovrydning, byudvikling, naturkatastrofer osv. CCDC-algoritmen identificerer alle tre ændringstyper med det primære formål at identificere pludselige ændringer. Harmoniske regressions- og tendensmodeller knyttes til dataene med henblik på at beregne sæsonbestemte eller gradvise ændringer, og pludseligt opståede afvigelser fra tendensmodellerne er indikation på pludselige ændringer.<div><br/>CCDC-algoritmen blev oprindeligt udviklet til Landsat TM-, Landsat ETM+- og Landsat OLI-data, Surface Reflectance- eller Brightness Temperature-data. Dog vil funktionen Detektér ændring ved hjælp af ændringsanalyse sammen med denne funktion detektere ændringer af flerbåndsbilleder fra enhver understøttet sensor samt afledte enkeltbåndsbilleder, såsom båndindekser. Du kan f.eks. udføre kontinuerlig ændringsdetektering på en Normalize Difference Vegetation Index (NDVI)-raster, fordi pludselige ændringer i NDVI kan indikere skovrydning.</div>",
		computeChangeName: "Beregn ændring",
		computeChangeSnip: "Beregner forskellen på to kategoriske eller kontinuerlige rasterdatasæt.",
		computeChangeDesc: "Funktionen Beregn ændring kan anvendes til at beregne forskellene på to klassificerede rastere for arealdække-ændringsanalyse, eller den kan anvendes til at undersøge ændringer mellem to enkeltbånds kontinuerlige rastere, såsom højde, temperatur, kronedækningsgrad osv.",
		detectChangeName: "Detektér ændring ved hjælp af ændringsanalyse",
		detectChangeSnip: "Genererer et rasterlag, der indeholder oplysninger om pixelændringer ved brug af output-ændringsanalyseraster.",
		detectChangeDesc: "<div>Funktionen Detektér ændring ved hjælp af ændringsanalyse genererer et rasterlag, der indeholder oplysninger om pixel-datoændringer ved brug af ændringsanalyseraster. Ændringsanalyserasteren skal genereres af værktøjet Analysér ændringer ved hjælp af CCDC eller værktøjet Analysér ændringer ved hjælp af LandTrendr eller rasterfunktionen CCDC-analyse eller funktionen LandTrendr-analyse.</div><br><div>Denne rasterfunktion kan kombineres med rasterfunktionen CCDC-analyse eller funktionen LandTrendr-analyse i en rasterfunktionsskabelon. For at generere et permanent rasteroutput skal du knytte outputtet fra funktionen CCDC-analyse eller LandTrendr-analyse til funktionen Detektér ændring ved hjælp af ændringsanalyse, gemme det som en raster-funktionsskabelon og køre Raster-analyse med skabelonen.</div><br><div>Parameteren <strong>Ændringstype</strong> angiver de oplysninger, der genereres. Oplysningerne hentes fra ændringsanalyserasteren. Når du kører denne funktion på outputtet fra CCDC-funktionen/-værktøjet, kan du vælge mellem følgende indstillinger:</div><ul><li><strong> Tid for seneste ændring</strong>–Den seneste dato og det seneste tidspunkt, hvor en pixel blev markeret som ændret.</li><li><strong>Tid for tidligste ændring</strong>–Den tidligste dato og det tidligste tidspunkt, hvor en pixel blev markeret som ændret.</li><li><strong>Tid for største ændring</strong>–Den dato og det tidspunkt, hvor den beregnede ændring var den vigtigste for en pixel.</li><li> <strong>Antal ændringer</strong>–Det samlede antal gange, pixlen er blevet ændret.</li></ul><div>Når denne funktion køres på outputtet fra LandTrendr-funktionen/-værktøjet, er følgende yderligere indstillinger tilgængelige: </div><ul><li><strong>Tid for længste ændring</strong>–Den dato, hvor en pixel blev markeret som ændret ved begyndelsen eller slutningen af den længste ændringsperiode.</li><li><strong>Tid for korteste ændring</strong>Den dato, hvor en pixel blev markeret som ændret, ved begyndelsen eller slutningen af den korteste ændringsperiode.</li><li><strong>Tid for hurtigste ændring</strong>–Den dato, hvor en pixel blev markeret som ændret, ved begyndelsen eller slutningen af den hurtigste ændringsperiode.</li><li><strong>Tid for langsomste ændring</strong>–Den dato, hvor en pixel blev markeret som ændret, ved begyndelsen eller slutningen af den langsomste ændringsperiode.</li></ul><div>Output-rasteren er en multibåndsraster, hvori hvert bånd indeholder ændringsoplysninger afhængigt af den valgte ændringstype og det maksimale antal ændringer, der er angivet. Hvis <strong>Ændringstype</strong> f.eks. er indstillet til <strong>Tid for tidligste ændring</strong>og <strong>Maksimalt antal ændringer</strong>er indstilet til 2, beregner funktionen de to tidligste datoer, hvor der forekom ændringer i hele tidsserien for hver pixel. Resultatet er en raster, hvori det første bånd indeholder datoerne for den tidligste ændring pr. pixel, og det andet bånd indeholder datoerne for den andentidligste ændring pr. pixel.</div><br><div>Ved anvendelse af denne funktion på outputtet fra LandTrendr-værktøjerne kan du vælge, om du vil hente den dato, der markerer begyndelsen af en ændring eller slutningen af en ændring ved hjælp af parameteren <strong>Segmentdato</strong>. Hvis du f.eks. ønsker at forstå, hvordan den seneste ændring i tidsserien er startet, skal du indstille <strong>Ændringstype</strong> til <strong>Tid for seneste ændring</strong> og <strong>Segmentdato</strong> til <strong>Start på segment</strong>.</div><br><div>Brug følgende filtreringsparametre til at udtrække flere specifikke ændringsdatoer fra din ændringsanalyseraster:</div><ul><li><strong>Filtrér efter år</strong>– Identificér ændringer, der er opstået inden for en bestemt tidsperiode, hvis du f.eks. er på udkig efter ændringer, der er opstået i et landskab i løbet af fem år med tørke.</li><li><strong>Filtrér efter varighed</strong>–Identificér ændringer, der er opstået inden for en givet årrække, hvis du f.eks. er på udkig efter pludselige ændringer, der er indtruffet i løbet af 1 eller 2 år. Du kan beregne den varighed, du er interesseret i, ved hjælp af formlen <strong>slutår - startår +1</strong>. Der vil være inkluderet \"huller\" i tidsserien.</li><li><strong>Filtrér efter størrelse</strong>– Identificér ændringer af en given størrelse, hvis du f.eks. er på udkig efter store ændringer i vegetationsindekset NDVI. Størrelse er en absolut værdi, så minimum- og maksimumværdierne kan ikke være negative. Hvis du vil angive retningsændring, skal du bruge parameteren <strong>Ændre retning</strong>.</li></ul>",
		distanceAccumulationName: "Afstandsakkumulering",
		distanceAccumulationSnip: "Beregner den akkumulerede afstand fra hver celle til kilderne, hvilket tager højde for ligelinje-afstand, omkostningsafstand, virkelig overfladeafstand samt vandrette og lodrette omkostningsfaktorer.",
		distanceAccumulationDesc: "Funktionen Afstandsakkumulering beregner afstanden til hver position i undersøgelsesområdet i forhold til den nærmeste eller mindst omkostningstunge kilde. Hvis det kun er kilderne, der angives som input, beregnes ligelinje-afstanden til hver position i undersøgelsesområdet. Hvis både kilder og barrierer anvendes som input, beregner funktionen Afstandsakkumulering ligelinje-afstanden omkring barriererne. Baggrundsværdien skal være NoData for både kilderaster og barriereraster, når kilder og barrierer repræsenteres med gyldige celleværdier. Gyldige værdier omfatter nul. <div><br/>Når en overfladeraster angives som input, beregnes den faktiske overfladeafstand mellem cellerne. Hvis der skal udføres omkostningsanalyse ved hjælp af Afstandsakkumulering, er der brug for en omkostningsoverflade. Hvis en omkostningsoverflade angives, er resultatet en akkumuleret omkostningsafstands-raster. Når horisontale og vertikale faktorer angives, inddrages retningsbestemthed som akkumuleret omkostning. Der er fire kildeegenskaber, der kan anvendes. Disse kildeegenskaber, der enten kan være kilder eller egenskaber, der er flyttet væk fra kilden, styres af specifikke parametre: 1. Første akkumulering: angiver den første omkostning før flytningen begynder. 2. Maksimal akkumulering: angiver, hvor mange omkostninger en kilde kan akkumulere, før den når sin grænse. 3. Multiplikator, der skal anvendes til omkostninger: angiver rejsemåden eller størrelsen ved kilden. 4. Rejseretning: angiver, om \"flytteren\" starter ved kilden og bevæger sig mod ikke-kilde-positioner, eller starter ved ikke-kilde-positioner og bevæger sig tilbage til en kilde.<div><br/>Resultatet af Afstandsakkumulering er som standard et enkelt bånd, som er afstandsakkumuleringsrasteren. Men et andet bånd kan også oprettes – tilbageretningsbåndet.  Dette bånd angiver fra hver position i undersøgelsesområdet, hvilken retning der skal tages for at opnå den mindst omkostningstunge kilde.  Begge bånd er nødvendige for at kunne fastlægge de mest optimale ruter i undersøgelsesområdet. For at genere en rute skal du først bruge funktionen Udtræk bånd til at udtrække afstandsakkumuleringsrasteren og tilbageretningsrasteren. Brug disse lag som input til Omkostningsrute-funktionen. I denne funktion skal du bruge afstandsakkumuleringsrasteren som input til Omkostningsafstandsraster og tilbageretningsrasteren som input til Omkostning BackLink-raster.</div>",
		distanceAllocationName: "Afstandsallokering",
		distanceAllocationSnip: "Beregner afstandsallokeringen fra hver celle til de angivne kilder, baseret på ligelinje-afstand, omkostningsafstand, virkelig overfladeafstand samt vandrette og lodrette omkostningsfaktorer.",
		distanceAllocationDesc: "Afstandsallokering beregner, hvilken kilde hver position i undersøgelsesområdet er allokeret til. Hvis det kun er kilder, der angives som input, allokeres positionerne ved brug af ligelinje-afstand til den nærmeste kilde. Hvis både kilder og barrierer anvendes som input, beregner funktionen Afstandsallokering ligelinje-afstanden omkring barriererne for at bestemme, hvilken kilde en position skal allokeres til. Baggrundsværdien skal være NoData for både kilderaster og barriereraster, når kilder og barrierer repræsenteres med gyldige celleværdier. Gyldige værdier omfatter nul.<div><br/>Hvis der skal udføres omkostningsanalyse ved hjælp af Afstandsallokering, er der brug for en omkostningsoverflade. Hvis der angives en omkostningsoverflade, er resultatet en allokeringsraster, der er baseret på de akkumulerede omkostninger, ikke en ligelinje-afstand. Når horisontale og vertikale faktorer angives, inddrages retningsbestemthed som akkumuleret omkostning. Når en overfladeraster angives som input, beregnes den faktisk dækkede overfladeafstand, når overførslen mellem cellerne beregnes, og allokeringen bestemmes. Der er fire kildeegenskaber, der kan anvendes. Disse kildeegenskaber, der enten kan være kilder eller egenskaber, der er flyttet væk fra kilden, styres af specifikke parametre: 1. Første akkumulering: angiver den første omkostning før flytningen begynder. 2. Maksimal akkumulering: angiver, hvor mange omkostninger en kilde kan akkumulere, før den når sin grænse. 3. Multiplikator, der skal anvendes til omkostninger: angiver rejsemåden eller størrelsen ved kilden. 4. Rejseretning: angiver, om \"flytteren\" starter ved kilden og bevæger sig mod ikke-kilde-positioner, eller starter ved ikke-kilde-positioner og bevæger sig tilbage til en kilde.<div><br/>Resultatet af Afstandsallokering er som standard et enkelt bånd, som er afstandsallokeringsrasteren. Valg af den boolske operation Generer kilderække og -kolonne som yderligere bånd i output vil resultere i en multibåndsraster, der består af tre bånd. Det første bånd er afstandsallokeringsbåndet, det andet bånd indeholder et rækkeindeks, og det tredje bånd indeholder et kolonneindeks. Disse indekser identificerer placeringen af ​​kildecellen, der er afstanden med de laveste akkumulerede omkostninger væk. Kilderækkeindekset og kildekolonneindekset kan anvendes sammen med henblik på at udføre intensitetskortlægning. Hvis du forespørger på en vilkårlig position i dit undersøgelsesområde på tværs af bånd to og tre, vil du kende række og kolonne for den mindst omkostningstunge kilde for den pågældende position.</div>",
		eucBackDirectionName: "Euklidisk tilbageretning",
		eucBackDirectionSnip: "Beregner, for hver celle, retningen, i grader, til nabocellen ad den korteste vej tilbage til den nærmeste kilde, idet barrierer undgås.",
		eucBackDirectionDesc: "Funktionen Euklidisk tilbageretning resulterer i en kontinuerlig raster med flydende komma, som repræsenterer retningen i grader tilbage til den nærmeste kilde, idet barrierer undgås, hvis der er angivet barrierer.<div><br/>Input til Euklidisk tilbageretning er den kilde, som retningen beregnes til. Et valgfrit input er en raster, der repræsenterer barrierer inden for undersøgelsesområdet. Baggrundsværdien skal være NoData for både kilderaster og barriereraster, når kilder og barrierer repræsenteres med gyldige værdier. Gyldige værdier omfatter nul. Beregningen vil som standard behandle den kombinerede udstrækning af kilder og barrierer, plus to rækker og kolonner. Hvis analysen kun er påkrævet inden for den angivne afstand fra kilderne, kan parameteren Maksimal afstand anvendes. Euklidisk tilbageretning understøtter både en Planar-metode og en Geodætisk metode i forbindelse med beregningen. Beregningen med Planar-metoden foretages på et projekteret fladt plan ved hjælp af et 2D kartesisk koordinatsystem. Beregningen med Geodætisk metode vil blive foretaget på ellipsoiden, hvilket betyder, at resultatet ikke ændres, uanset input- eller output-projektionen.<div><br/>Resultatet fra funktionen Euklidisk tilbageretning kan anvendes sammen med resultatet fra funktionen Euklidisk afstand til at fastlægge de korteste ruter fra positioner inden for undersøgelsesområdet tilbage fra kilden. Resultatet af både Euklidisk tilbageretning og Euklidisk afstand anvendes i Omkostningsrute-funktionen sammen med destinationerne til at generere de korteste ruter.</div>",
		expandName: "Vis",
		expandSnip: "Udvider de valgte zoner for en raster med zoner med et angivet antal celler.",
		expandDesc: "Med funktionen Udvid globalt kan du generalisere – eller forenkle – rastere ved at gøre bestemte zoner større. Du kan også kontrollere graden af generalisering, der vil forekomme.<div><br/>De zoner, du vælger, vil blive større ved, at de udvides ind i andre zoner. De valgte zoneværdier kan – rent begrebsmæssigt – vises som forgrundszoner, mens andre værdier fortsat vises som baggrundszoner. Forgrundszonerne kan udvides ind i baggrundszonerne.<div><br/>Graden af generalisering kan kontrolleres med parameteren Antal celler. Denne værdi er som standard 1, hvilket betyder, at de valgte zoner vil blive udvidet med en værdi, der svarer til én celles størrelse. Hvis du vil øge graden af generalisering, kan du angive en større værdi for denne parameter. Rent begrebsmæssigt svarer dette til at køre værktøjet så mange gange som det angivne antal, hvilket betyder, at resultaterne fra den forrige kørsel bliver indsat i den efterfølgende kørsel.</div>",
		trendAnalysisName: "Generer tendens",
		trendAnalysisSnip: "Estimerer tendensen for hver pixel langs en dimension for en eller flere variabler i en flerdimensional  raster.",
		trendAnalysisDesc: "<div>Denne funktion kan bruges til at tilpasse data langs med en lineær harmonisk eller polynomisk tendenskurve, eller den kan bruges til at udføre detektering af tendenser ved hjælp af Mann-Kendall eller Seasonal-Kendall-testen.</div><br><div>Output-tendensrasteren, der genereres med denne funktion, bruges som input til funktionen <strong>Forudsig ved brug tendensraster</strong>.</div><br><div>Mann-Kendall- og Seasonal-Kendall-testene bruges som input til at afgøre, om der er en monoton tendens i dataene. Disse er ikke-parametriske, hvilket betyder, at de ikke forudsætter en specifik datafordeling. Mann-Kendall-testen tager ikke højde for seriel korrelation eller sæsonbestemte virkninger. Hvis dataene er sæsonbestemte, er Seasonal-Kendall-testen mere velegnet.</div><br><div>Hvis værktøjet bruges til at udføre enten Mann-Kendall eller Seasonal-Kendall-testen, er outputtet en fem-bånds raster som følger:</div><ul><li>Bånd 1 = Sen's slope (Sen's hældning)</li><li>Bånd 2 = p-værdi</li><li>Bånd 3 = Mann-Kendall-score (S)</li><li>Bånd 4 = S-varians </li><li>Bånd 4 = S-varians </li><li>Bånd 5 = Z-score</li></ul><div>Outputtene fra Mann-Kendall- eller Seasonal-Kendall-testene kan anvendes til at afgøre, hvilke pixels i dine flerdimensionale tidsserier der har en statistisk signifikant tendens. Du kan bruge disse oplysninger sammen med lineære, harmoniske eller polynomiske tendensanalyser til at udtrække signifikante tendenser i din tidsserie. Du kan generere en maske, der indeholder pixels med signifikante p-værdier, anvende masken på den flerdimensionale raster og bruge denne maskerede multidimensionelle raster som input til værktøjet til at udføre lineær, harmonisk. eller polynomisk tendensanalyse.</div><br><div>Der er tre tendenskurveindstillinger til tilpasning af en tendens for de variable værdier langs med en dimension: lineær, polynomisk og harmonisk.</div><br><div>For lineær tendensanalyse er outputtet en trebåndsraster som følger:</div><ul><li>Bånd 1 = Hældning</li><li>Bånd 2 Skæringspunkt</li><li>Bånd 3 = Fejl i kvadratroden af den gennemsnitlige kvadratafvigelse (RMSE) eller fejl omkring best-fit linjen</li></ul><div>For den polynomiske tendensanalyse afhænger antallet af bånd i outputtet af polynomiets grad. Andenordenspolynomiet genererer en firebåndsraster, hvor:</div><ul><li>Bånd 1 = Polynomium_2</li><li>Bånd 2 = Polynomium_1</li><li>Bånd 3 = Polynomium_0</li><li>Bånd 4 = RMSE</li></ul><div>Tredjeordenspolynomiet genererer en fembåndsraster, hvor:</div><ul><li>Bånd 1 = Polynomium_3</li><li>Bånd 2 = Polynomium_2</li><li>Bånd 3 = Polynomium_1</li><li>Bånd 4 = Polynomium_0</li><li>Bånd 5 = RMSE</li></ul><div>For harmonisk tendensanalyse afhænger antallet af bånd i outputtet af den harmoniske frekvens. Når frekvensen er indstillet til 1, er outputtet en fembåndsraster, hvor:</div><ul><li>Båd 1 = Hældning</li><li>Bånd 2 = Skæringspunkt</li><li>Bånd 3 = Harmonic_sin1</li><li>Bånd 4 = Harmonic_cos1</li><li>Bånd 5 = RMSE</li></ul><div>Når frekvensen er indstillet til 2, er outputtet en syvbåndsraster, hvor:</div><ul><li>Bånd 1 = Hældning</li><li>Bånd 2 = Skæringspunkt</li><li>Bånd 3 = Harmonic_sin1</li><li>Bånd 4 = Harmonic_cos1</li><li>Bånd 5 = Harmonic_sin2</li><li>Bånd 6 = Harmonic_cos2</li><li>Bånd 7 = RMSE</li></ul><div>Parameteren <strong>Cykluslængde</strong> for harmoniske tendensanalyse anvendes til at angive antallet af og længden af de cyklusser, som du forventer at se i dine data i løbet af en dag eller et år. Hvis du f.eks. forventer, at dine data vil gennemgå to variationscyklusser på ét år, vil cykluslængden være 182,5 dage eller 0,5 år. Hvis du har temperaturdata, der er indsamlet hver tredje time, og der er én variationscyklus pr. dag, vil cykluslængden være én dag.</div><br><div>Parameteren <strong>Frekvens</strong> for harmonisk tendensanalyse anvendes til at beskrive den harmoniske model, der passer til dataene. Hvis frekvensen indstilles til 1, anvendes en kombination af en lineær og en førsteordens harmonisk kurve til modellen. Hvis frekvensen er 2, anvendes en kombination af en lineær og en førsteordens og andenordens harmonisk kurve til dataene. Hvis frekvensen er til 3, anvendes der yderligere en tredjeordens harmonisk kurve til at modellere dataene osv.</div><br><div>Model goodness-of-fit-statistik kan genereres som valgfri output. Kvadratroden af den gennemsnitlige kvadratafvigelse (RMSE), den R-kvadratiske værdi og p-værdien for tendenshældning kan beregnes og symboliseres. Symbolisér output-tendensrasterlaget ved hjælp af <strong>RGB</strong>-symbologi, og angiv statistikken som røde, grønne og blå bånd.</div><br>",
		spectralUnmixingName: "Linear Spectral Unmixing",
		spectralUnmixingSnip: "Udfører underpixel-klassificering og beregner hyppigheden i brøkdele af forskellige typer arealdække for individuelle pixels.",
		spectralUnmixingDesc: "Funktionen Linear Spectral Unmixing beregner arealdækket i brøkdele for individuelle pixels, der indeholder flere typer arealdække. Funktionen genererer et multiband-lag, hvor hvert bånd svarer til hyppigheden i brøkdele for hver klasse af arealdække. Du kan f.eks. bruge denne funktion til at gennemføre klassificering af arealdække på et multispektralt billede med henblik på at identificere fotosyntetisk vegetation, jordbund uden bevoksning og udgået eller ikke-fotosyntetisk vegetation.<div><br/>Rækkefølgen for output-multiband-rasteren følger rækkefølgen for input-spektralprofilen. Antallet af klasser kan ikke overskride antallet af bånd i input-rasteren. Du kan f.eks. ikke udtrække oplysninger om mere end 8 klasser fra en 8-bånds raster.</div>",
		multidimensionalFilterName: "Flerdimensionelt filter",
		interpolateRasterByDimensionFunctionName: "Interpolér raster efter dimension",
		interpolateRasterByDimensionFunctionSnip: "Interpolerer en multidimensional raster ved angivne dimensionsværdier ved hjælp af tilstødende udsnit.",
		interpolateRasterByDimensionFunctionDesc: "<p>Med denne funktion kan du estimere pixelværdier for et ikke-defineret dimensionsudsnit i en multidimensional raster. Hvis du f.eks. har et datasæt, der indeholder en havtemperatur ved overfladen og 100 meter under overfladen, og du vil estimere temperaturen ved 50 meter under overfladen, kan du bruge denne funktion til at få et estimat ved den pågældende dybde ved hjælp af dimensionsdefinitionen Efter værdier.</p><p>Du kan også downsample et månedligt datasæt til et dagligt datasæt ved hjælp af dimensionsdefinitionen Efter værdier og angive parameterværdien for Trin til 1 og parameterværdien for Enhed til dage.</p><p>Brug dimensionsdefinitionen Efter målraster til at estimere værdien for målrasteren.</p>",
		multidimensionalFilterSnip: "Opretter et rasterlag ud fra et flerdimensionalt rasterdatasæt eller et flerdimensionalt rasterlag ved at opdele data i udsnit langs med definerede variabler og dimensioner.",
		multidimensionalFilterDesc: "Det flerdimensionelle filter opretter et flerdimensionelt rasterlag ved at filtrere og udtrække et undersæt af variabler fra en flerdimensionel raster. Du har f.eks. et flerdimensionalt datasæt, der indeholder månedlige nedbørsdata for 30 år, og du ønsker kun at udtrække data for hver januar måned for at få vist, hvordan nedbørsmængderne har ændret sig for denne måned.<div><br/>Brug parameteren Dimensionsdefinition til at opdele dimensioner ved brug af et interval, en værdi eller en række værdier. Hvis du f.eks. har 10 års data om saltholdighed i havet, der er indsamlet hver måned for hver 2 meters dybde op til 500 meters dybde, kan du anvende de forskellige dimensionsdefinitionsindstillinger til følgende scenarier. Scenarie 1: Udtræk saltholdighedsdata for måneden januar over en periode på 10 år. Vælg Efter værdier, indstil Dimension til StdTime, og indstil Værdier til Januar. Scenarie 2: Opdel saltholdighedsdata over et dybdeområde fra 0 til 150 meter. Vælg Efter områder, indstil Dimension til StdZ, og indstil Minimumværdi til -150 og Maksimumværdi til 0. Scenarie 3: Udtræk saltholdighedsdata for de første 10 dage i hver januar måned over en periode på 10 år. Vælg Efter gentagelse, indstil Dimension til StdTime, indstil Start på første gentagelse og Slut på første gentagelse til den tilsvarende start og slutning på gentagelsesperioden, indstil Trin til 1, og indstil Enhed til År.</div>",
		multidimensionalRasterName: "Flerdimensional raster",
		multidimensionalRasterSnip: "Tilføjer flerdimensionale data til et kort som et flerdimensionalt rasterlag.",
		multidimensionalRasterDesc: "Funktionen Flerdimensional raster føjer flerdimensionale data til et kort som et flerdimensionalt rasterlag. Denne funktion er nyttig, når der udføres rasteranalyse-arbejdsgange ved hjælp af en funktionskæde.<div><br/>Understøttede flerdimensionale rasterdatasæt omfatter netCDF, GRIB, HDF og Esris CRF. Flerdimensionale mosaikdatasæt understøttes også.</div>",
		optimalPathAsRasterName: "Optimal rute som raster",
		optimalPathAsRasterSnip: "Beregner ruten med de laveste omkostninger fra en kilde til en destination.",
		optimalPathAsRasterDesc: "Denne global funktion genererer en outputraster, der registrerer de(n) optimale rute(r) fra udvalgte steder til den nærmeste kildecelle, der er defineret inden for den akkumulerede omkostningsoverflade, hvad angår omkostningsafstand.<div><br/>Det kræves generelt, at der køres en eller flere vægtede omkostningsfunktioner (Afstandsakkumulering eller Afstandsallokering), før funktionen Optimal rute som raster køres for at oprette input-afstandsakkumulerings- og tilbageretningsrastere. Disse er obligatoriske input-rasterlag i forhold til funktionen Optimal rute. Værdierne for den optimale output-rute repræsenterer antallet af ruter på en given position. I mange tilfælde går ruterne i samme retning, når de forlader kilden, hvorefter de ændrer retning for at nå forskellige destinationer. En værdi på 1 indikerer f.eks., at der kun er én optimal rute for en given position, mens en værdi på 5 angiver, at der for den pågældende position er fem optimale ruter, der går igennem den pågældende celle i undersøgelsesområdet.<div><br/>Input-destinationsdataene skal være et rasterlag. Sættet med destinationsceller består af celler i input-rasteren, der har gyldige værdier. Celler, der har NoData-værdier, er ikke medtaget i datasættet. Værdien nul anses for at være en gyldig destination. Der kan oprettes en destinationsraster med udtrækningsværktøjerne. Hvis du har destinations- eller kildeobjekter, kan du konvertere dem til raster med funktionen Konverter objekter til raster. Brug afstandsakkumulering eller tilbageretningsraster som raster-input til rasterfunktionen. Dette vil sikre, at objektet konverteres til raster med den samme cellestørrelse, udstrækning og spatiale reference som de andre rastere, der indgår i funktionen Optimal rute som raster. Funktionen Optimal rute som raster kan også anvendes til at udlede ruten med den mindste modstand for en digital højdemodel (DEM). I dette tilfælde kan du bruge DEM'en som input-afstandsakkumuleringsraster og output fra funktionen Flowretning som tilbageretningsraster.</div>",
		trendName: "Forudsig ved brug tendensraster",
		trendSnip: "Beregner et forventet flerdimensionalt rasterlag ved hjælp af output-tendensrasteren fra funktionen Generer tendens eller geoprocesseringsværktøjet Generer tendensraster.",
		trendDesc: "Funktionen Forudsig ved brug tendensraster beregner et forventet flerdimensionalt rasterlag ved hjælp af output-tendensrasteren fra funktionen Generer tendens eller geoprocesseringsværktøjet Generer tendensraster.",
		rasterCollectionName: "Behandl rastersamling",
		rasterCollectionSnip: "Behandler hvert udsnit i en flerdimensional raster eller hvert element i en mosaikraster. Denne funktion kan også aggregere flere udsnit til et enkelt udsnit.",
		rasterCollectionDesc: "Funktionen Behandl rastersamling behandler hvert udsnit i en flerdimensional raster eller hvert element i en mosaikraster. Denne funktion kan også aggregere flere udsnit til et enkelt udsnit.<div><br/>Denne funktion behandler hvert udsnit i en flerdimensional raster eller mosaikraster ved hjælp af en rasterfunktionsskabelon. Denne funktion understøtter følgende indstillinger: 1. Angiv en rasterfunktionsskabelon for Elementfunktionen. Du har f.eks. et mosaikdatasæt, der indeholder 20 års Landsat-billeder, og du ønsker at beregne NDVI for hver scene i tidsserien. For Elementfunktionen skal du angive en rasterfunktionsskabelon, som indeholder NDVI-rasterfunktionen. 2. Angiv en rasterfunktionsskabelon for Aggregeringsfunktionen. Du har f.eks. en flerdimensional raster, der indeholder 10 års daglige temperaturdata, og du ønsker at beregne den maksimale temperatur for hvert år. For Aggregeringsfunktionen skal du angive en rasterfunktionsskabelon, som indeholder funktionen Cellestatistik, og handlingen skal være indstillet til Maksimum. Under Aggregeringsdefinition skal du indstille Dimension til StdTime, indstille Type til Interval-nøgleord og indstille Nøgleordsinterval til Årlig. Bemærk, at hvis input-mosaikdatasættet ikke er flerdimensionalt, vil aggregeringsfunktionen ikke overholde aggregeringsdefinitionen. Aggregeringsfunktionen vil aggregere alle elementer eller hver gruppe til én/ét, hvis disse er defineret i aggregeringsfunktionsskabelonen. For yderligere oplysninger om brug af grupper i et mosaikdatasæt, se Brug af mosaikdatasæt i Rasterfunktionsskabeloner. 3. Angiv en rasterfunktionsskabelon for Behandlingsfunktionen. Funktionen eller funktionskæden i denne skabelon anvendes til at vise den nye behandlede raster. Angiv f.eks. en rasterfunktionsskabelon, der indeholder funktionen Farvekort, for at ændre måden, hvorpå det behandlede rasterlag vises. Bemærk, at hvis inputtet er en flerdimensional raster, så anvendes behandlingsfunktionen til det aktuelle visningsudsnit. Hvis inputtet er et mosaiklag eller et mosaikdatasæt, så anvendes behandlingsfunktionen til mosaikrasteren ved brug af den første metode til opløsning af overlap. 3. Angiv skabeloner til enhver kombination af de tre funktioner. Du har f.eks. et mosaikdatasæt, der indeholder tidsserier med Landsat-billeder, og du ønsker  at generere et sammensat billede med maksimal NDVI. For Elementfunktionen skal du angive en rasterfunktionsskabelon, som indeholder NDVI-rasterfunktionen. For Aggregeringsfunktionen skal du angive en rasterfunktionsskabelon, som indeholder funktionen Cellestatistik, og handlingen skal være indstillet til Maksimum. For Behandlingsfunktionen skal du angive en rasterfunktionsskabelon, som indeholder funktionen Farvekort. Bemærk, at funktionsbehandlingsrækkefølgen følger inputparametrenes rækkefølge. Elementfunktionen vil f.eks. blive behandlet først.</div>",
		randomName: "Vilkårlig",
		randomSnip: "Opretter en raster med vilkårlige pixelværdier, der trækkes fra en pseudo-vilkårlig distribution. Flere distributioner og generatorer af tilfældige tal understøttes.",
		randomDesc: "Funktionen Vilkårlig opretter en raster med vilkårlige pixelværdier, der kan anvendes i rasterfunktionsskabeloner eller mosaikdatasæt.<div><br/>Mens mange funktioner fungerer sammen med én eller flere input-rastere, kræver funktionen Vilkårlig ikke nogen input-raster. Dette betyder, at den i højere grad agerer som et rasterdatasæt end som en funktion, så der skal udvises særlig forsigtighed, når den tilføjes til eller fjernes fra funktionskæden.</div>",
		shrinkName: "Formindsk",
		shrinkSnip: "Formindsker de valgte zoner med et angivet antal celler ved at erstatte dem med værdien af den celle, der er den oftest forekommende i dens omgivelser.",
		shrinkDesc: "Med funktionen Formindsk globalt kan du generalisere – eller forenkle – rastere ved at gøre bestemte zoner mindre. Du kan også kontrollere graden af generalisering, der vil forekomme.<div><br/>De zoner, du vælger, vil blive formindsket – eller reduceret – i størrelse, ved at celler fra de omgivende zoner udvides ind i dem. De valgte zoneværdier kan – rent begrebsmæssigt – vises som forgrundszoner, mens andre værdier fortsat vises som baggrundszoner. Cellerne i forgrundszonerne kan erstattes af celler i baggrundszonerne. \"Tynde øer\" inde i en zone, som har fælles grænser med zonen, kan også udskiftes.<div><br/>Graden af generalisering kan kontrolleres med parameteren Antal celler. Denne værdi er som standard 1, hvilket betyder, at de valgte zoner vil blive formindsket med den værdi, der svarer til én celles størrelse. Hvis du vil øge graden af generalisering, kan du angive en større værdi for denne parameter. Rent begrebsmæssigt svarer dette til at køre værktøjet så mange gange som det angivne antal, hvilket betyder, at resultaterne fra den forrige kørsel bliver indsat i den efterfølgende kørsel.</div>",
		trendToRGBName: "Tendens til RGB",
		trendToRGBSnip: "Konverterer en tendensraster til en trebåndsraster (rød, grøn og blå).",
		trendToRGBDesc: "Funktionen Tendens til RGB konverterer en tendensraster til en trebåndsraster (rød, grøn og blå). Tendensrasteren genereres fra funktionen Generer tendensraster eller rasterfunktionen CCDC-analyse.<div><br/>Denne funktion er nyttig til visualisering af model-koefficient-data fra funktionen Generer tendens eller funktionen CCDC-analyse. Begge funktioner beregner tendenser i pixelværdier, der ændres, men det er vanskeligt at fortolke resultaterne af funktionerne direkte.<div><br/>På samme måde som med andre rasterfunktioner er du måske nødt til at anvende Dynamisk justering af område (DRA) for at få vist resultaterne af denne funktion.</div>",
		landTrendrName: "LandTrendr-analyse",
		landTrendrSnip: "Evaluerer ændringer i pixelværdier over tid ved hjælp af den Landsat-baserede metode til detektering af tendenser i forstyrrelser og genopretning (LandTrendr) og genererer en ændringsanalyseraster, der indeholder modelresultaterne.",
		landTrendrDesc: "Denne rasterfunktion kan kun anvendes som input til funktionen Detektér ændring ved hjælp af ændringsanalyseraster. For at generere et raster-output skal funktionen LandTrendr-analyse forbindes med funktionen Detektér ændring ved hjælp af ændringsanalyse i en rasterfunktionsskabelon, og brug skabelonen som input i geoprocesseringsværktøjet Generér raster fra rasterfunktion. Resultatet er en raster, som indeholder oplysninger om det tidspunkt, hvor pixelværdierne ændrede sig.<div><br>Formålet med denne rasterfunktion er at udtrække ændringer i et observeret objekt, således at det ideelle flerdimensionale inputbillede bør indfange en ensartet observation over tid og bør ikke indeholde atmosfærisk eller sensorinterferens, skyer eller skygge fra skyer. Den bedste praksis er at anvende data, der er blevet normaliseret og kan maskeres ved hjælp af et Qa-bånd, f.eks. Landsat Collection 1 Surface Reflectance-produkter med en skymaske.<div><br>Funktionen udfører analyse på ét billede pr. år, og antallet af årlige udsnit skal være lig med eller større end den værdi, der er angivet i <strong>minimumsantallet af observations-</strong> parametre. Det anbefales, at du har data for mindst seks år.<div><br>Hvis du har månedlige, ugentlige eller daglige data, anbefales det, at du vælger flere billeder fra hvert år (helst fra samme årstid), fjerner skyer og skygge fra skyer og kombinerer billederne for at generere ét enkelt billede, som indfanger observationen godt. Hvis månedlige, ugentlige eller daglige data angives som den flerdimensionale input-raster, vil funktionen identificere et udsnit til analyse baseret på den dato, der ligger tættest på den, der er angivet i <strong>snappingdato-</strong> parameteren.<div><br>Det vil ofte tage tid for et objekt i et landskab at blive genoprettet fra en ikke-permanent ændring såsom skovbrand eller insektangreb. For at kontrollere den genopretningsgrad, som genkendes af modellen, indstil parameteren Genopretningstærskel. Et forskelligt segment kan ikke have en genopretningsgrad, der er hurtigere end 1/genopretningstærskel.<div><br>Genopretningen fra en ændring i landskab kan ske i positiv eller negativ retning. Hvis et landskab f.eks. oplever skovtab, viser en tidsserie af vegetationsindeksværdier et fald i indeksværdier, og genopretningen viser en gradvis stigning i vegetationsindeksværdier eller en positiv genopretningstendens. Angiv retningen for genopretningstendensen med parameteren <strong>Genopretning har en stigende tendens</strong>.",
		aggregateMultidimensionalName: "Aggregér flerdimensionalt",
		aggregateMultidimensionalSnip: "Kombinerer eksisterende flerdimensionale rastervariabeldata langs en dimension.",
		aggregateMultidimensionalDesc: "Den aggregerede flerdimensionale funktion opretter et flerdimensionalt rasterlag ved at kombinere eksisterende flerdimensionale rastervariabeldata langs en dimension.<div><br>Anvend <strong>Dimensionsdefinitions-</strong>Â  parameteren til først at filtre de inputdata, du vil aggregere. Hvis du f.eks. har månedlige data for 30 år, men du kun ønsker at oprette et aggregeret lag for de første 15 år, kan du anvende <strong>Dimensionsdefinitions-</strong>Â  parameteren til at angive de år, der skal medtages i analysen.<div><br><ul><li>Udtræk saltholdighedsdata for måneden januar over en periode på 10 år. Vælg <strong>efter værdier</strong>, indstil <strong>dimension</strong>til <strong>StdTime</strong>, og indstil <strong>værdier</strong>til <strong>januar</strong>.</li><li>Opdel saltholdighedsdata over et dybdeområde fra 0 til 150 meter. Vælg <strong>efter områder</strong>, indstil <strong>dimension</strong>til <strong>StdZ</strong>, og indstil<strong>minimums- værdi</strong>til <strong>-150</strong>og <strong>maksimums- værdi</strong>til <strong>0</strong>.</li><li>Udtræk saltholdighedsdata for de første 10 dage af hver januar måned i en 10 års periode. Vælg<strong>efter gentagelse</strong>, indstil<strong>dimension</strong>til <strong>StdTime</strong>, indstil <strong>start på første gentagelse</strong>og<strong>slutning på første gentagelse</strong>til den tilsvarende start og slutning på gentagelsesperioden, indstil<strong>trin</strong>til <strong>1</strong>, og indstil <strong>enhed</strong>til <strong>år</strong>.</li></ul><div><br>Anvend parametrene <strong>Aggregering Definition</strong>til at vælge den dimension, der skal vurderes, og aggregeringsintervallet ved hjælp af et nøgleord, en værdi eller et interval af værdier. Hvis man f.eks. har 30 års temperaturdata for havoverfladen, der er indsamlet dagligt og for hver 5 meters dybde ned til 100 meter, kan du anvende de forskellige indstillinger til følgende scenarier:<div><br><ul><li>Aggregér de daglige temperaturdata til månedlige data, hvis resultatet er en flerdimensional raster med 12 tidsudsnit, og hvert udsnit er aggregatet af hver måned på tværs af alle årene. Vælg <strong>intervalnøgleord</strong>og indstil nøgleordet til <strong>gentages månedligt</strong>.</li><li>Aggregér de daglige temperaturdata til månedlige data, hvis resultatet er en flerdimensional raster med 360 udsnit eller 12 tidsudsnit pr. år (30 år x 12 måneder = 360 udsnit). Vælg<strong>intervalnøgleord</strong>Â og indstil nøgleordet til <strong>månedligt</strong>.</li><li>Aggregér månedlige temperaturdata til 4-måneds intervaller. Vælg <strong>intervalværdi</strong>, indstil<strong>værdiinterval</strong>til 4, og indstil <strong>enhed</strong>til <strong>måneder</strong>.</li><li>Aggregér temperaturdata fra 0 til 25 meter, derefter fra 25 til 50 meter, derefter fra 50 til 100 meter. Vælg <strong>intervalområder</strong>og angiv minimums- og maksimumsdybder som <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Flet rastere",
		mergeRastersSnip: "Kombinerer flere rasterdatasæt rumligt eller på tværs af variabler og dimensioner.",
		mergeRastersDesc: "Denne funktion opretter en flettet raster fra en liste af rastere. Hvis du eksempelvis har et mosaikdatasæt, som indeholder månedlige nedbørsdata for 30 år, og et andet datasæt med månedlige temperaturdata for 10 år, kan du kombinere dem til en flerdimensional raster med begge variabler. <div><br>Hvis de flerdimensionale input-rastere indeholder forskellige variabler, vil de flerdimensionale output-rastere indeholde alle variablerne. <div><br>Hvis de flerdimensionale input-rastere indeholder forskellige dimensionsværdier, vil den flerdimensionale output-raster indeholde alle dimensionerne og dimensionsværdierne. <div><br>Hvis de flerdimensionale input-rastere indeholder forskellige dimensioner og variabler, men forskellige spatiale udstrækninger, vil den flerdimensionale output-raster indeholde variablerne og dimensionerne på tværs af de flettede spatiale udstrækninger.<div><br>Denne funktion kan også bruges, hvis du har flere rastere, som du ønsker behandlet som ét element, f.eks. beregning af samme statistikker for alle, eller hvis der er farveafbalancering, behøver du ikke at farveafbalancere hvert enkelt billede separat. Dette er nyttigt ved arbejde med billeder, der er gemt som separate tiles på grund af begrænsninger i filstørrelse. På den måde vil de pågældende tiles blive behandlet som en del af det samme billede.",
		boundaryCleanName: "Grænseudjævning",
		boundaryCleanSnip: "Udjævner grænsen mellem zoner.",
		boundaryCleanDesc: "<p>Funktionen generaliserer – eller forenkler – rastere ved at udjævne grænserne mellem zoner. Funktionen giver mulighed for at kontrollere, hvordan cellerne i zonerne i inputtet påvirker udjævningen og den mængde udjævning, der vil blive anvendt. Hver inputcelle vurderes ved hjælp af sine otte nærmeste naboer.</p><p>Udjævningsprocessen sorterer først nabocellerne ud fra en bestemt prioritering. Denne prioritering bestemmer, hvilken zone fra nabocellerne der kan erstatte værdien af den behandlede celle i outputtet.</p><p>Prioriteringen kan være baseret på zonernes værdi eller størrelse. Parameteren <strong>Sorteringstype</strong> bestemmer, hvilken sorteringstype der anvendes. </p><p>Standardindstillingen <strong>Sortér ikke</strong> vurderer prioriteringen ud fra zonernes værdi. Celler fra zoner med større værdier vil have en højere prioritering med henblik på at udvide sig til zoner med mindre værdier.</p><p>Størrelsen – eller det samlede område – af zonerne kan bruges til at sortere prioriteringen. Med indstillingen <strong>Faldende</strong> sorteres zonerne efter størrelse i faldende rækkefølge. Zoner med større samlede områder vil have prioritering med henblik på at udvide sig til zoner med mindre områder. Med indstillingen <strong>Stigende</strong> er det omvendte sandt: zoner med mindre samlede områder vil have prioritering til at udvide sig til zoner med større samlede områder.</p><p>Mængden af udjævning styres af parameteren <strong>Kør udvidelse og formindskelse to gange</strong>, hvilket bestemmer det antal gange udvidelses- og formindskelsesprocessen vil blive udført.</p><p>Hvis indstillingen ikke er markeret, udføres udvidelses- og formindskelsesprocessen én gang. Når indstillingen er markeret, udføres udvidelses- og formindskelsesprocessen to gange, hvilket resulterer i en yderligere udjævning af zonegrænserne.</p><p>Hvis værdierne for alle otte naboceller er de samme som for behandlingscellen, bevarer outputcellen den samme værdi som input-cellen.</p>",
		predictUsingRegressionName: "Forudsig ved brug af regression",
		predictUsingRegressionSnip: "Beregner en prognosebaseret raster baseret på input om rasterdata og en regressionsmodel. Regressionsmodellen er outputtet fra <strong>Train Random Trees Regression Model</strong>, der er et værktøj til geobehandling af raster.",
		predictUsingRegressionDesc: "<p>Regressionsmodellen er defineret i en Esri-regressionsdefinitionsfil (.ecd). Den indeholder alle oplysningerne for et specifikt datasæt eller et sæt af datasæt og regressionsmodellen og genereres af <strong>Train Random Trees Regression Model</strong>, der er et værktøj til geobehandling af raster.</p><p>Inputtet kan være raster med et enkelt bånd, flere bånd eller flere dimensioner eller en liste over disse typer. Typerne af inputraster skal være af samme type som dem, der er trænet af regressionsmodellen.</p><ul><li>Når inputtet er raster med flere bånd, behandles hvert bånd som en prognosebaseret variabel. Båndene skal være i samme rækkefølge som input med flere bånd for værktøjet til træning af regressionsmodeller.</li><li>Når inputtet er raster i flere dimensioner, behandles hver raster som en prognosebaseret variabel, og variablen skal være et enkelt bånd og have en tidsdimension. Variabelrækkefølgen og -navne skal være det samme som inputtet, når regressionsmodellen blev trænet. Outputtet er raster med flere dimensioner.</li><li>Inputtet kan være en liste over elementer. Antallet af elementer og rækkefølgen af elementerne skal matche inputtet, da regressionsmodellen blev trænet.</li></ul>",
		dimensionalMovingStatisticsName: "Statistik for dimensional flytning",
		dimensionalMovingStatisticsSnip: "Beregner statistik for et bevægeligt vindue på flerdimensionale data langs en angivet dimension.",
		dimensionalMovingStatisticsDesc: "<p>Funktionen Statistik for dimensional flytning beregner forskellige statistiske data i et foruddefineret vindue for alle dimensionsværdier langs en dimension. Denne funktion tager et flerdimensionalt rasterlag som input og opretter et flerdimensionalt rasterlag som output, der har den samme dimensionale størrelse som inputlaget.</p><p>Du kan angive en dimension, for hvilken dimensionsværdierne skal tages i betragtning ved beregningen. Som standard beregnes den langs den første ikke-spatiale dimension. Du kan også angive en vinduesstørrelse ved at angive parametrene for det bagudrettede vindue og det fremadrettede vindue.</p><p>Når statistiktypen er indstillet til percentil, bliver parametrene percentilværdi og percentil interpolationstype tilgængelige. Du kan bruge disse parametre til at angive percentilen til henholdsvis at beregne og vælge den interpolationstype, der skal bruges. Når statistiktypen er indstillet til Cirkulær middelværdi, bliver parameteren Cirkulær ombrydningsværdi tilgængelig. Den cirkulære ombrydningsværdi bruges til at konvertere en lineær værdi til området for et givet cirkulært gennemsnit.</p>",
		terrainFlattenFunctionName: "Terræn udjævnes",
		terrainFlattenFunctionSnip: "Korrigerer inputdata fra syntetisk aperturradar (SAR) for radiometriske forvrængninger på grund af topografi.",
		terrainFlattenFunctionDesc: "<p>Rasterfunktionen Terræn udjævnes korrigerer inputdata fra syntetisk aperturradar (SAR) for radiometriske forvrængninger på grund af topografi.</p><p>Inputradardata skal først kalibreres til beta-nought. Brug værktøjet Anvend radiometrisk kalibrering til at kalibrere radardata til beta-nought.</p><p>Hvis input-DEM ikke spænder over hele SAR-datasættet, vil værktøjet generere NoData-værdier for pixels uden for DEM-udstrækningen for gamma-nought, sigma-nought, punktområde, og geometriske forvrængningsoutput. For det geometriske forvrængningsmaske-output vil værktøjet generere ubestemte værdier for pixels uden for DEM-udstrækningen.</p><p>Input DEM skal være i WGS 1984 (EPSG:4326) geografisk koordinatsystem.</p>",
		createColorCompositeFunctionName: "Opret farvesammensætning",
		createColorCompositeFunctionSnip: "Opretter et trebåndsraster ud fra et multibånds-rasterdatasæt, hvor hvert bånd kan bruge en algebraisk beregning baseret på båndalgebra.",
		createColorCompositeFunctionDesc: "<p>Funktionen Opret farvesammensætningsraster opretter en trebåndsraster ud fra et multibånds-rasterdatasæt, hvor hvert bånd kan bruge en algebraisk beregning baseret på båndalgebra.</p><p>Når du definerer en båndaritmetisk algoritme, kan du indtaste en algebraisk formel på en enkelt linje for hvert udtryk for at oprette et flerbåndsoutput. De understøttede operatorer er unitære, plus (+), minus (-), gange (*) og divider (/).</p><p>Når du bruger et bånd-id i et udtryk, skal du identificere båndet ved at sætte B eller b foran båndnummeret.</p><p>En almindelig båndkombination, der bruges til syntetisk aperturradar (SAR) i lineære enheder, er VV for rød, VH for grøn og VV/VH for blå. Hvis inputdata er i decibel, skal båndkombinationen være VV for rød, VH for grøn og VV-VH for blå.</p>",
		surfaceParametersName: "Overfladeparametre",
		surfaceParametersSnip: "Bestemmer parametre for en rasteroverflade såsom aspekt, hældning og adskillige typer krumninger ved brug af geodætiske metoder.",
		surfaceParametersDesc: "<p>Funktionen Overfladeparametre bestemmer parametre for en rasteroverflade såsom aspekt, hældning og adskillige typer krumninger ved brug af geodætiske metoder.</p><p>Denne funktion kan anvendes til følgende applikationer:</p><ul><li>Beregning af aspekt og hældning ved brug af geodætiske metoder.</li><li>Beregning af forskellige typer krumninger ud fra en input-rasteroverflade f.eks. <strong>Tangential krumning (normal kontur)</strong>, der karakteriserer strømmens topografiske konvergens og divergens henover en overflade.</li></ul>",
		leastCostCorridorName: "Mindst omkostningsfulde korridor",
		leastCostCorridorSnip: "Beregner summen af to afstandsrastere med akkumulerede omkostninger med mulighed for at anvende en tærskel baseret på procent eller akkumulerede omkostninger.",
		leastCostCorridorDesc: "<p>Inputrasterne skal være afstandsakkumulerings- og tilbageretningsrastere fra funktionen<strong>Afstandsakkumulering</strong> eller <strong>Afstandsallokering</strong>. Disse skal være baseret på omkostning/afstand, og de samme parameterindstillinger skal bruges, når lagene for hver kilde oprettes. Ingen parametre, der afhænger af retning (horisontal faktor, vertikal faktor og bevægelsesretning), bør bruges til at oprette disse rastere.</p><p>Værdierne i output-korridor-rasteren er summen af de akkumulerede omkostninger for at nå en given placering med de samme enheder som inputrasteren for akkumulerede omkostninger.</p><p>Hvis en angivet <strong>Tærskel</strong>-værdi er større end de maksimale akkumulerede omkostninger, når to afstandsakkumuleringsrastere summeres, vil output-korridor-rasteren dække det samme område som de akkumulerede inputrastere.</p><p>Hvis en angivet tærskelværdi er mindre end minimumsværdien i korridor-rasteren, returneres der en advarselsmeddelelse, og outputrasteren vil være tom.</p><p>Output-korridor-rasteren kan indeholde celler med lidt større akkumulerede omkostninger end tærskelværdien. Dette er fra de tilbageretningsrastere, der bruger celler, som er tildelt lidt højere omkostninger end tærsklen med henblik på at forbinde frakoblede celler til korridoren.</p>",
		geometricMedianName: "Geometrisk median",
		geometricMedianSnip: "Den geometriske median-funktion beregner den geometriske median på tværs af pixels i en tidsserie af multibånd-billeder.",
		geometricMedianDesc: "<p>Denne funktion reducerer støj og afvigelser i tidsseriebilleder ved at beregne en geometrisk medianpixel for hvert pixel-array på tværs af billedstakken. Algoritmen bevarer de spektrale relationer mellem båndene i pixelspektrene, så resultatet kan bruges i analyser såsom vegetationsindekser.</p><p>Skyer og skygger skal maskeres ved hjælp af datasættets QA-bånd, før denne funktion anvendes.</p><p>Hvis inputbilledet er med flydende komma, såsom overfladereflektans, med værdier mellem 0 og 1, bør en epsilon-værdi på 0,001 give kvalitetsresultater.</p>"
	},
	rfxArgs: {
		rasterName: "Raster",
		colorSchemeTypeName: "Farveskematype",
		colormapName: "Farvekort",
		colormapNameName: "Navn på farvekort",
		colorRampName: "Farveskala",
		contrastOffsetName: "Kontrastforskydning",
		brightnessOffsetName: "Lysstyrkeforskydning",
		methodName: "Metode",
		bandNamesName: "Båndnavne",
		bandWavelengthsName: "Båndbølgelængder",
		bandIdsName: "Bånd-ID'er",
		missingBandActionName: "Manglende båndhandling",
		conversionParametersName: "Konverteringsparametre",
		hillshadeTypeName: "Hillshade-type",
		azimuthName: "Azimut",
		altitudeName: "Højde",
		slopeTypeName: "Skalering",
		zFactorName: "Z-faktor",
		PSPowerName: "Pixelstørrelseseffekt",
		PSZFactorName: "Pixelstørrelsesfaktor",
		removeEdgeEffectName: "Deaktivér standard-kantpixel-interpolation",
		fromUnitName: "Fra enhed",
		toUnitName: "Til enhed",
		rasterTypeName: "Type",
		minName: "Output-minimum",
		maxName: "Output-maksimum",
		minPercentName: "Procent clip-minimum",
		maxPercentName: "Procent clip-maksimum",
		numberOfStandardDeviationName: "Antal standardafvigelser",
		sigmoidStrengthLevelName: "Sigmoid-styrkeniveau",
		estimateStatsHistogramName: "Beregn statistik",
		DRAName: "Dynamisk justering af område",
		statisticsName: "Statistik",
		histogramsName: "Histogrammer",
		statisticsHistogramName: "Definer statistik og histogram",
		computeGammaName: "Auto Gamma",
		useGammaName: "Brug Gamma",
		gammaName: "Gamma",
		inputNamesName: "Navne",
		expressionName: "Udtryk",
		cellsizeTypeName: "Cellestørrelsestype",
		extentTypeName: "Udstrækningstype",
		classifierDefinitionFileName: "Input-definitionsfil",
		raster1Name: "Raster1",
		raster2Name: "Raster2",
		raster3Name: "Raster3",
		trueRasterName: "Sand raster",
		falseRasterName: "Falsk raster",
		noDataInterpretationName: "NoData-fortolkning",
		noDataValuesName: "NoData-værdier",
		includedRangesName: "Inkluderede områder",
		curvatureTypeName: "Krumningstype",
		rastersName: "Rastere",
		attributeTableName: "Tabel",
		attributeTableTypeName: "Tabeltype",
		rowsName: "Antal rækker",
		columnsName: "Antal kolonner",
		kernelName: "Kerne",
		mirrorEdgesName: "Spejlkanter",
		influencesName: "Inflydelser",
		fieldsName: "Felter",
		remapsName: "Genberegn tabel",
		evalFromName: "Evalueringsskala fra",
		evalToName: "Evalueringsskala til",
		weightsName: "Vægte",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "IDW-radius for kort område",
		maxVoidWidthName: "Maks. tomrumsbredde",
		sigmaGaussianName: "Adaptiv udjævning",
		contourTypeName: "Konturtype",
		zBaseName: "Z-base",
		numberOfContoursName: "Antal konturer",
		contourIntervalName: "Konturinterval",
		nthContourLineInBoldName: "Nth ContourLine i fed",
		featureClassName: "Input-objekter",
		classIndexFieldName: "Felt",
		resolveOverlapMethodName: "Opløs overlapningsmetode",
		resamplingTypeName: "Resampling-type",
		inputCellsizeName: "Input-cellestørrelse",
		outputCellsizeName: "Output-cellestørrelse",
		pointFeatureClassName: "Seed-punkter",
		maxGrowthRadiusFieldName: "Radiusfelt for maks. vækst",
		similarityThresholdFieldName: "Tærskelfelt for lighed",
		fillValueFieldName: "Udfyldningsværdifelt",
		spectralDetailName: "Spektrale detaljer [1..20]",
		spatialDetailName: "Spatiale detaljer [1..20]",
		minNumPixelsPerSegmentName: "Mindste segmentstørrelse i pixels",
		boundariesOnlyName: "Kun segmentgrænser",
		statisticsTypeName: "Statistiktype",
		fillNoDataOnlyName: "Udfyld kun NoData-pixels",
		inputDataTypeName: "Inputdatatype",
		angleReferenceSystemName: "Vinkelreferencesystem",
		outputDataTypeName: "Outputdatatype",
		inputSamplePointFeatureClassName: "Inputeksempler",
		valueFieldName: "Værdifelt",
		rasterInfoName: "Raster-info",
		interpolationMethodName: "Interpolationsmetode",
		radiusName: "Radius",
		radianceGainValuesName: "Radiansstigning",
		radianceBiasValuesName: "Radiansafvigelse",
		reflectedGainValuesName: "Reflekteret stigning",
		reflectedBiasValuesName: "Reflekteret afvigelse",
		sunElevationName: "Solhøjde (grader)",
		albedoName: "Albedo",
		scaleFactorName: "Skalafaktor",
		offsetName: "Forskydning",
		thresholdTypeName: "Tærskeltype",
		thresholdsName: "Tærskler",
		undefinedClassName: "Ikke-defineret klasse",
		minValueName: "Min.",
		maxValueName: "Maks.",
		operationName: "Handling",
		clippingTypeName: "Klip-type",
		clippingGeometryName: "Klip-geometri/raster",
		extentName: "Output-udstrækning",
		useInputFeatureGeometryName: "Brug input-objekter til klip-geometri",
		remapDefinitionTypeName: "Genberegn definitionstype",
		inputRangeName: "Input-områder",
		outputValuesName: "Output-værdier",
		noDataRangeName: "NoData-områder",
		inputFieldName: "Inputfelt",
		outputFieldName: "Outputfelt",
		inputMaxFieldName: "Input-maks. felt (valgfrit)",
		remapTableTypeName: "Genberegn tabeltype",
		allowUnmatchedName: "Tillad ikke-matchede pixelværdier",
		changeMissingValuesToNoDataName: "Ændre manglende værdier til NoData",
		visibleBandIDName: "Synligt bånd-ID",
		infraredBandIDName: "Infrarødt bånd-ID",
		scientificOutputName: "Videnskabeligt output",
		bandIndexesName: "Båndindekser",
		constantName: "Konstant",
		weightName: "Vægt",
		minimumName: "Minimum",
		maximumName: "Maksimum",
		sourceDataName: "Kilderaster",
		sourceFieldName: "Kildefelt",
		costRasterName: "Omkostningsraster",
		maxDistanceName: "Maksimal afstand",
		valueRasterName: "Værdiraster",
		costMultiplierName: "Multiplikator, der skal anvendes til omkostninger",
		startCostName: "Startomkostning",
		accumCostResistanceRateName: "Akkumuleret omkostnings-resistens-sats",
		capacityName: "Kapacitet",
		travelDirectionName: "Rejseretning",
		cellSizeName: "Cellestørrelse",
		populationFieldName: "Populationsfelt",
		areaUnitsName: "Områdeenheder",
		outputValueTypeName: "Output-celleværdier",
		barriersName: "Inputbarrierer",
		destinationDataName: "Destinationsraster",
		destinationFieldName: "Destinationsfelt",
		pathTypeName: "Stitype",
		observerFeaturesName: "Observationsobjekter",
		analysisMethodName: "Analysemetode",
		analysisTypeName: "Analysetype",
		verticalErrorName: "Vertikal fejl",
		refractivityCoefficientName: "Koefficient for refraktivitet",
		surfaceOffsetName: "Overfladeforskydning",
		observerElevationName: "Observationshøjde",
		observerOffsetName: "Observationsforskydning",
		innerRadiusName: "Indre radius",
		innerRadiusIs3DDistanceName: "Indre radius er 3D-afstand",
		outerRadiusName: "Ydre radius",
		outerRadiusIs3DDistanceName: "Ydre radius er 3D-afstand",
		horizontalStartAngleName: "Horisontal startvinkel",
		horizontalEndAngleName: "Horisontal slutvinkel",
		verticalUpperAngleName: "Vertikal øvre vinkel",
		verticalLowerAngleName: "Vertikal nedre vinkel",
		zoneDataName: "Zoneraster",
		zoneFieldName: "Zonefelt",
		ignoreNoDataName: "Tilsidesæt NoData i beregninger",
		temperatureRasterName: "Temperaturraster",
		inTemperatureUnitsName: "Temperaturenheder",
		outHeatIndexTemperatureUnitsName: "Varmeindeksenheder",
		relativeHumidityRasterName: "Relativ fugtighedsraster",
		outWindChillTemperatureUnitsName: "Vindafkølingsenheder",
		windSpeedRasterName: "Vindhastighedsraster",
		inWindSpeedUnitsName: "Vindhastighedsenheder",
		valueName: "Værdi",
		propertyName: "Navn på egenskab",
		jsonName: "Metadata JSON",
		zoneTableName: "Zoneattributtabel",
		attributeFieldNames: "Attributfeltnavne",
		backgroundName: "Baggrundsværdi",
		whereClauseName: "WHERE-sætning",
		minimumValueFieldName: "Navn på minimumsværdifelt",
		maximumValueFieldName: "Navn på maksimumsværdifelt",
		outValueFieldName: "Navn på output-værdifelt",
		defaultValueName: "Standard-output-værdi",
		conversionMatrixName: "Konverteringsmatrix",
		IsPseudoColorOutputName: "Er et pseudo-farve-output",
		unmappedAsRandomColorName: "Tildel farver tilfældigt til ikke-kortlagte pixels",
		distanceMethodName: "Afstandsmetode",
		flowDirRasterName: "Flowretningsraster",
		pourPointName: "Raster for punkt(er) for vandløbsretning",
		pourPointFieldName: "Felt for punkt(er) for vandløbsretning",
		constantZName: "Konstant Z",
		zOffsetName: "Z-forskydning",
		geoIdName: "Geoide",
		calibrationTypeName: "Kalibreringstype",
		filterTypeName: "Filtertype",
		filterSizeName: "Filterstørrelse",
		noiseModelName: "Støjmodel",
		noiseVarianceName: "Støjvarians",
		additiveNoiseMeanName: "Additiv middelværdi for støj",
		multiplicativeNoiseMeanName: "Multiplikativ middelværdi for støj",
		numberofLooksName: "Antal udseender",
		dampingFactorName: "Dæmpningsfaktor",
		maskRasterName: "Maskeraster",
		nibbleValuesName: "Brug NoData-værdier, hvis de er den nærmeste nabo",
		nibbleNoDataName: "Nibble NoData-celler",
		zLimitName: "Z-grænse",
		flowDirectionTypeName: "Flowretningstype",
		weightRasterName: "Vægtraster",
		forceEdgeName: "Tving alle kantceller til at strømme væk",
		streamRasterName: "Strømraster",
		surfaceRasterName: "Overfladeraster",
		conversionType: "Konverteringstype",
		distanceRaster1: "Afstandsraster 1",
		distanceRaster2: "Afstandsraster 2",
		costDistanceRaster: "Omkostning/afstand-raster",
		costBacklinkRaster: "Omkostning BackLink-raster",
		overridesName: "Tilsidesætter",
		fieldName: "Felt",
		signatureFileOrUrl: "Signatur-fil eller URL",
		redName: "Rød",
		greenName: "Grøn",
		blueName: "Blå",
		infraredName: "Infrarød",
		panchromaticName: "Pankromatisk",
		multispectralName: "Multispektral",
		pansharpeningType: "Pansharpening-type",
		sensorName: "Sensor",
		spatialReferenceName: "Spatial reference",
		xCellsizeName: "X-cellestørrelse",
		yCellsizeName: "Y-cellestørrelse",
		xOriginName: "X-registreringspunkt",
		yOriginName: "Y-registreringspunkt",
		percentileName: "Percentilværdi",
		neighborhoodType: "Nabotype",
		widthName: "Bredde",
		heightName: "Højde",
		startAngleName: "Startvinkel",
		endAngleName: "Slutvinkel",
		neighborhoodValues: "Naboværdier",
		horizontalRaster: "Horisontal raster",
		horizontalFactor: "Horisontal faktor",
		verticalRaster: "Vertikal raster",
		verticalFactor: "Vertikal faktor",
		streamRaster: "Strømraster",
		flowDirRaster: "Flowretningsraster",
		numberNeighborCells: "Antal naboceller",
		zoneConnectivity: "Zoneforbindelse",
		addLinkBehavior: "Tilføj link",
		excludedValue: "Udelukket værdi",
		constantFillCheck: "Generer fyldraster ud fra konstant",
		fillRaster: "Fyldraster",
		constantFillValue: "Konstant værdi",
		inputBitPositions: "Input-bit",
		outputBitPositions: "Output-bit",
		distanceTypeName: "Afstandstype",
		barrierDataName: "Rasterbarrierer",
		pourPointDataName: "Raster for punkt(er) for vandløbsretning",
		accumulationRasterName: "Raster for flow-akkumulering",
		snapDistanceName: "Snap-afstand",
		orderMethodName: "Ordremetode",
		directionMeasurementName: "Måleretning",
		processAsMultiband: "Behandl som flerbånd",
		processMultidimensional: "Behandl som flerdimensional",
		forceFlowDirectionConvention: "Tving flowretningskonvention til backlink-raster",
		initialAccumulation: "Første akkumulering",
		maximumAccumulation: "Maksimal akkumulering",
		sourceLocationBands: "Generer kilderække og -kolonne som yderligere bånd i output",
		backDirectionBand: "Generer tilbageretning som ekstra bånd i output",
		numberOfCells: "Antal celler",
		zoneValues: "Zoneværdier",
		shrinkMethod: "Formindsk metode",
		expandMethod: "Udvid metode",
		inputSpectralProfileType: "Spektral profiltype",
		spectralProfileFileName: "Spektral profil",
		trainingFeatureFileName: "Træningsfunktion",
		nonNegative: "Ikke-negativ",
		sumToOne: "Sum til én",
		randomDistribution: "Distribution",
		meanName: "Middel",
		probabilityName: "Sandsynlighed",
		alphaName: "Alfa",
		betaName: "Beta",
		rName: "r",
		nName: "N",
		seed: "Frø",
		randomNumberGenerator: "Generator af tilfældigt tal",
		cellFactor: "Cellefaktor",
		aggregationType: "Aggregeringsteknik",
		extentHandling: "Udvid udstrækning om nødvendigt",
		trendAnalysisDimensionName: "Dimensionsnavn",
		trendAnalysisType: "Trendtype",
		harmonicFrequency: "Harmonisk frekvens",
		polynomialOrder: "Polynomisk rækkefølge",
		cycleLengthName: "Cykluslængde",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R-kvadratisk",
		trendAnalysisSlopePValue: "P-værdi af hældningskoefficient",
		trendAnalysisSeasonalPeriod: "Sæsonbestemt periode",
		cycleUnitName: "Cykusenhed",
		predictDimensionValues: "Værdier",
		dimensionDefinitionType: "Dimensionsdefinition",
		predictDimensionStart: "Start",
		predictDimensionEnd: "Slut",
		predictDimensionInterval: "Værdiinterval",
		dimensionUnit: "Enhed",
		interpolationCellsizeName: "Interpolation-cellestørrelse",
		variableName: "Variabler",
		dimensionlessName: "Dimensionsløs",
		mdimDefinition: "Dimensionsdefinition",
		dimensionName: "Dimension",
		iterationStart: "Start på første gentagelse",
		iterationEnd: "Slut på første gentagelse",
		intervalStart: "Start på interval",
		intervalEnd: "Slut på interval",
		stepName: "Trin",
		rangesName: "Områder",
		minValue: "Minimumværdi",
		maxValue: "Maksimumværdi",
		changeAnalysisRasterName: "Ændre analyseraster",
		changeTypeName: "Ændringstype",
		segmentDate: "Segmentdato",
		changeDirectionName: "Ændre retning",
		maxNumChangesName: "Maksimalt antal ændringer",
		filterByYear: "Filtrér efter år",
		minimumYear: "Minimumsværdi",
		maximumYear: "Maksimumsværdi",
		filterByDuration: "Filtrér efter varighed",
		minimumDuration: "Minimumsvarighed",
		maximumDuration: "Maksimumsvarighed",
		filterByMagnitude: "Filtrér efter størrelse",
		minimumMagnitude: "Minimumsstørrelse",
		maximumMagnitude: "Maksimumsstørrelse",
		filterByStartValue: "Filtrér efter startværdi",
		minimumStartValue: "Minimal startværdi",
		maximumStartValue: "Maksimal startværdi",
		filterByEndValue: "Filtrér efter slutværdi",
		minimumEndValue: "Minimal slutværdi",
		maximumEndValue: "Maksimal slutværdi",
		modelTypeName: "Modeltype",
		fromRasterName: "Fra raster",
		toRasterName: "Til raster",
		computeChangeMethod: "Beregn ændringsmetode",
		fromClassValues: "Fra klasseværdier (eksempel: 2 5)",
		toClassValues: "Til klasseværdier (eksempel: 2 5)",
		keepMethod: "Filtreringsmetode",
		useColorMethod: "Definér overgangsfarver",
		detectChangeBands: "Bånd til registrering af ændring (start ved 0)",
		tmaskBands: "Bånd til temporal maskering (start ved 0)",
		chiSquaredThreshold: "Khi2-tærskel til detektering af ændring",
		minAnomaly: "Minimalt antal på hinanden følgende anomaliobservationer",
		updatingFrequency: "Opdatering af tilpasningsfrekvens (i år)",
		distanceAccumulationRasterName: "Afstandsakkumuleringsraster",
		costBackdirectionRasterName: "Tilbageretnings- eller Flowretningsraster",
		rasterCollectionName: "Rastersamling",
		itemFunctionName: "Elementfunktion",
		aggregationFunctionName: "Aggregeringsfunktion",
		processingFunctionName: "Behandlingsfunktion",
		aggregationDefinitionName: "Aggregeringsdefinition",
		queryGeometryName: "Forespørgselsgeometri",
		factorFunctionZeroFactor: "Nulfaktor",
		factorFunctionCutAngle: "Skæringsvinkel",
		factorFunctionSideFactor: "Sidefaktor",
		factorFunctionSlope: "Stigning",
		factorFunctionLowCutAngle: "Lavt skåret vinkel",
		factorFunctionHighCutAngle: "Højt skåret vinkel",
		factorFunctionCosPower: "Cosinusfunktion",
		factorFunctionSecPower: "Sekantfunktion",
		factorFunctionTablePath: "Tabelsti",
		processingBand: "Behandlingsbånd",
		processingBandName: "Navn på behandlingsbånd",
		snappingDate: "Snappingdato",
		maxNumSegments: "Maksimalt antal segmenter",
		vertexCountOvershoot: "Koordinatpunkttælling overskydning",
		spikeThreshold: "Spike-tærskel",
		recoveryThreshold: "Genopretningstærskel",
		minNumObs: "Minimalt antal observationer",
		pValueThreshold: "P-værditærskel",
		bestModelProportion: "Bedste modelandel",
		preventOneYearRecovery: "Forhindre 1 års genopretning",
		recoveryIncreaseTrend: "Genopretning har en stigende tendens",
		outputOtherBands: "Output andre bånd",
		sortType: "Sorteringstype",
		numberOfRuns: "Kør udvidelse og formindskelse to gange",
		percentileValue: "Percentilværdi",
		percentileInterpolationType: "Percentilinterpolationstype",
		rasterInfoProperty: "Egenskab",
		rasterInfoValue: "Værdi",
		rasterInfoColumns: "Kolonner",
		rasterInfoRows: "Rækker",
		rasterInfoBandCount: "Antal bånd",
		rasterInfoPixelSizeX: "Cellestørrelse X",
		rasterInfoPixelSizeY: "Cellesstørrelse Y",
		rasterInfoPixelType: "Pixel-type",
		rasterExtentTop: "Top",
		rasterExtentBottom: "Bund",
		rasterExtentLeft: "Venstre",
		rasterExtentRight: "Højre",
		rasterStatisticsNotCalculated: "Statistik er ikke blevet beregnet.",
		spatialReferenceProjection: "Projektion",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "Forrige WKID",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "Forrige VCSWKID",
		spatialReferenceAuthority: "Autoritet",
		spatialReferenceLinearUnit: "Lineær enhed",
		spatialReferenceAngularUnit: "Vinkelenhed",
		spatialReferenceFalseEasting: "Falsk easting",
		spatialReferenceFalseNorthing: "Falsk northing",
		spatialReferenceCentralMeridian: "Midtermeridian",
		spatialReferencePrimeMeridian: "Nulmeridian",
		spatialReferenceStandardParallel1: "Standardparallel 1",
		spatialReferenceStandardParallel2: "Standardparallel 2",
		spatialReferenceLatitudeOfOrigin: "Oprindelses breddegrad",
		spatialReferenceAuxiliarySphereType: "Auxiliary Sphere-type",
		spatialReferenceDatum: "Datum",
		spatialReferenceSpheroid: "Sfæroid",
		spatialReferenceSemimajorAxis: "Ækvatorialradius for sfæroide (a-akse)",
		spatialReferenceSemiminorAxis: "Polarradius for sfæroide (b-akse)",
		spatialReferenceInverseFlattening: "Omvendt udjævning",
		inputDefinitionFileName: "Input-definitionsfil",
		deleteName: "Slet",
		addVariableName: "Tilføj variabel",
		maxNumPixelsPerSegment: "Højste segmentstørrelse i pixels",
		forwardWindowName: "Fremad-vindue",
		backwardWindowName: "Bagud-vindue",
		noDataHandlingName: "NoData-håndtering",
		circularWrapValueName: "Circulær ombrydningsværdi",
		fromClassNameFieldName: "Feltnavn for klassenavne i Fra raster",
		toClassNameFieldName: "Feltnavn for klassenavne i Til raster",
		targetRasterName: "Mål-raster",
		circularWrapValue: "Circulær ombrydningsværdi",
		bandIndexesR: "Rødt udtryk",
		bandIndexesG: "Grønt udtryk",
		bandIndexesB: "Blåt udtryk",
		exampleName: "Eksempel",
		inputName: "Input",
		outputName: "Output",
		optionalName: "Valgfrit",
		browseDefinitionFile: "Gennemse definitionsfil",
		selectDefinitionFile: "Vælg input-definitionsfil",
		inputDefinitionURL: "Input-definitionsfils URL",
		enterDefinitionFileURL: "Indtast input-definitionsfils URL",
		browseXMLFile: "Gennemse XML-fil",
		selectStatsFile: "Vælg statistik- og histogramfil",
		enterXMLFileURL: "Indtast XML-fils URL",
		xmlFileURL: "XML-fils URL",
		circularCalculation: "Beregn cirkulær statistik",
		localSurfaceType: "Lokal overfladetype",
		surfaceParameterType: "Parametertype",
		neighborhoodDistance: "Naboafstand",
		useAdaptiveNeighborhood: "Brug adaptivt nabolag",
		outputSlopeType: "Måling af output-hældning",
		projectAzimuths: "Projicer geodætiske azimutter",
		useEquatorialAspect: "Brug ækvatorialaspekt",
		zUnit: "Z-enhed",
		analysisMask: "Analysemaske",
		stdDeviation: "Standardafvigelse",
		"true": "Sandt",
		"false": "Falsk",
		costDistanceRaster1: "Input-raster 1 for akkumuleret omkostningsafstand",
		costDistanceRaster2: "Input-raster 2 for akkumuleret omkostningsafstand",
		threshold: "Tærskel",
		thresholdMethod: "Tærskelmetode",
		directionRaster1: "Input-tilbageretningsraster 1",
		directionRaster2: "Input-tilbageretningsraster 2",
		maxIterations: "Maks. antal gentagelser",
		epsilon: "Epsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manuel",
		attributeTableTypeExternal: "Ekstern",
		clrSchemeTypeColormap: "Farvekort",
		clrSchemeTypeColorRamp: "Farveskala",
		colormapTypeElevation: "Højde",
		colormapTypeGray: "Grå",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Vilkårlig",
		none: "Ingen",
		slopeTypeAdjusted: "Justeret",
		slopeTypeDegree: "Grad",
		slopeTypePercentRise: "Procentstigning",
		slopeTypeScaled: "Skaleret",
		stretchTypeMinMax: "Min.-Maks.",
		stretchTypePercentMinMax: "PercentMinMax",
		stretchTypeSigmoid: "Sigmoid",
		stretchTypeStdDev: "StdAfv",
		hillshadeTypeSimple: "Traditionel",
		hillshadeTypeMultidirectional: "Mange retninger",
		bandComboByNames: "Båndnavne",
		bandComboByWavelength: "Båndbølgelængder",
		bandComboByIDs: "Bånd-ID'er",
		missingBandActionBestMatch: "Bedste match",
		missingBandActionFail: "Mislykket",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Centimeter",
		unitTypeDecimeters: "Decimeter",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Fod",
		unitTypeFeetPerSec: "Fod pr. sekund (ft/s)",
		unitTypeInches: "Tommer",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Kilometer",
		unitTypeKmsPerHour: "Kilometer pr. time (km/t)",
		unitTypeKnots: "Knob (kn)",
		unitTypeMeters: "Meter",
		unitTypeMetersPerSec: "Meter pr. sekund (m/s)",
		unitTypeMiles: "Miles",
		unitTypeMilesPerHour: "Miles pr. time (mph)",
		unitTypeMillimeters: "Millimeter",
		unitTypeNauticalMiles: "Sømil",
		unitTypeYards: "Yards",
		unitTypeDecimalDegrees: "Decimalgrader",
		unitTypePoints: "Punkter",
		unitTypeUnknown: "Ukendt",
		unitTypeSqMapUnits: "Kvadratkortenheder",
		unitTypeSqMiles: "Kvadratmiles",
		unitTypeSqKms: "Kvadratkilometer",
		unitTypeAcres: "Acres",
		unitTypeHectares: "Hektarer",
		unitTypeSqYards: "Kvadratyard",
		unitTypeSqFt: "Kvadratfod",
		unitTypeSqInches: "Kvadrattommer",
		unitTypeSqMts: "Kvadratmeter",
		unitTypeSqCms: "Kvadratcentimeter",
		unitTypeSqMms: "Kvadratmillimeter",
		cellsizeTypeFirst: "Første af",
		cellsizeTypeMin: "Min. af",
		cellsizeTypeMax: "Maks. af",
		cellsizeTypeMean: "Middelværdi af",
		cellsizeTypeLast: "Sidste af",
		extentTypeFirst: "Første af",
		extentTypeIntersection: "Gennemskæring af",
		extentTypeUnion: "Forening af",
		extentTypeLast: "Sidste af",
		noDataInterpretAny: "Match enhver",
		noDataInterpretAll: "Match alle",
		curvatureTypeStandard: "Standard",
		curvatureTypeProfile: "Profil",
		curvatureTypePlanform: "Planform",
		filterTypeLineDetectionHorizontal: "Linjedetektering vandret",
		filterTypeLineDetectionVertical: "Linjedetektering lodret",
		filterTypeLineDetectionLeftDiagonal: "Linjedetektering venstre diagonal",
		filterTypeLineDetectionRightDiagonal: "Linjedetektering højre diagonal",
		filterTypeGradientNorth: "Hældning nord",
		filterTypeGradientWest: "Hældning vest",
		filterTypeGradientEast: "Hældning øst",
		filterTypeGradientSouth: "Hældning syd",
		filterTypeGradientNorthEast: "Hældning nordøst",
		filterTypeGradientNorthWest: "Hældning nordvest",
		filterTypeSmoothArithmeticMean: "Jævn aritmetisk middelværdi",
		filterTypeSmoothing3x3: "Udjævner 3x3",
		filterTypeSmoothing5x5: "Udjævner 5x5",
		filterTypeSharpening3x3: "Skærper 3x3",
		filterTypeSharpening5x5: "Skærper 5x5",
		filterTypeLaplacian3x3: "Laplace-fordeling 3x3",
		filterTypeLaplacian5x5: "Laplace-fordeling 5x5",
		filterTypeSobelHorizontal: "Sobel vandret",
		filterTypeSobelVertical: "Sobel lodret",
		filterTypeSharpen: "Skærpning",
		filterTypeSharpen2: "Skærp mere",
		filterTypePointSpread: "Punktspredning",
		userDefined: "Brugerdefineret",
		ContourTypeLines: "Konturlinjer",
		ContourTypeFill: "Konturfyld",
		ContourTypeSmoothOnly: "Kun jævn overflade",
		rasterizeFirst: "Første",
		rasterizeLast: "Sidste",
		rasterizeSmallest: "Mindst",
		rasterizeLargest: "Størst",
		resamplingTypeNearest: "Nærmeste nabo",
		resamplingTypeBilinear: "Bilineær interpolation",
		resamplingTypeCubic: "Kubik-konvolution",
		resamplingTypeMajority: "Majoritet",
		resamplingTypeBilinearPlus: "Bilineær Interpolation Plus",
		resamplingTypeGauss: "Gaussisk sløring",
		resamplingTypeGaussPlus: "Gaussisk sløring Plus",
		resamplingTypeAverage: "Gennemsnit",
		resamplingTypeMinimum: "Minimum",
		resamplingTypeMaximum: "Maksimum",
		resamplingTypeVectorAvg: "Vektorgennemsnit",
		minimum: "Minimum",
		maximum: "Maksimum",
		mean: "Middel",
		stdDeviation: "Standardafvigelse",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Størrelse-Retning",
		unknown: "Ukendt",
		angleRefSysGeographic: "Geografisk",
		angleRefSysArithmetic: "Aritmetisk",
		interpolateIrregularDataNearest: "Nærmeste nabo",
		interpolateIrregularDataBilinear: "Bilineær",
		interpolateIrregularDataTinningLinear: "Lineær tinning",
		interpolateIrregularDataTinningNaturalNeighbor: "Naturlig nabo",
		interpolateIrregularDataTinningIDW: "Vægtet omvendt afstand",
		esriRasterThresholdTypeConstant: "Konstant",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "Arg Max",
		argStatsTypeMin: "Arg Min",
		argStatsTypeMedian: "Arg Median",
		argStatsTypeDuration: "Varighed",
		arithmeticOpPlus: "Plus",
		arithmeticOpMinus: "Minus",
		arithmeticOpMultiply: "Multiplicér",
		arithmeticOpDivide: "Dividér",
		arithmeticOpPower: "Potens",
		arithmeticOpMode: "Tilstand",
		clipTypeOutside: "Klip udenfor",
		clipTypeInside: "Klip indeni",
		yes: "Ja",
		no: "Nej",
		densities: "Tætheder",
		expectedCounts: "Forventede antal",
		planar: "Plan",
		geodesic: "Geodætisk",
		eachCell: "Hver celle",
		eachZone: "Hver zone",
		bestSingle: "Bedste enkelt",
		allSightlines: "Alle sigtelinjer",
		perimeterSightlines: "Perimeter-sigtelinjer",
		frequency: "Frekvens",
		observers: "Observatører",
		majority: "Majoritet",
		median: "Median",
		minority: "Minoritet",
		percentile: "Percentil",
		range: "Område",
		sum: "Sum",
		variety: "Variation",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "Transformeret SAVI",
		bandArithmeticMethodMSAVI: "Modificeret SAVI",
		bandArithmeticMethodSultan: "Sultan's Formula",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Jernoxid",
		ferrousMinerals: "Jernholdige mineraler",
		clayMinerals: "Lerholdige mineraler",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Kvadratrod",
		localACos: "ARCCOS",
		localASin: "ARCSIN",
		localATan: "ARCTAN",
		localATanH: "ARCTANH",
		localAbs: "ABS",
		localBitwiseNot: "Bitwise Ikke",
		localBooleanNot: "Boolesk Ikke",
		localCos: "Cos",
		localCosH: "CosH",
		localExp: "EKSP",
		localExp10: "EKSP10",
		localExp2: "EKSP2",
		localInt: "Heltal",
		localIsNull: "er nul",
		localFloat: "Flydende",
		localLn: "Ln",
		localLog10: "Log10",
		localLog2: "Log2",
		localNegate: "Negér",
		localRoundDown: "Rund ned",
		localRoundUp: "Rund op",
		localSin: "Sin",
		localSinH: "SinH",
		localTan: "Tan",
		localTanH: "TanH",
		localACosH: "ARCCOSH",
		localASinH: "ARCSINH",
		localPlus: "Plus",
		localMinus: "Minus",
		localTimes: "Tider",
		localPower: "Potens",
		localBitwiseAnd: "Bitwise Og",
		localBitwiseLeftShift: "Bitwise Venstre skift",
		localBitwiseOr: "Bitwise Eller",
		localBitwiseRightShift: "Bitwise Højre skift",
		localBitwiseXor: "Bitwise Xor",
		localBooleanAnd: "Boolesk Og",
		localBooleanOr: "Boolesk Eller",
		localBooleanXor: "Boolesk Xor",
		localDivide: "Dividér",
		localEqualTo: "Lig med",
		localGreaterThan: "Større end",
		localGreaterThanEqual: "Større end eller lig med",
		localLessThan: "Mindre end",
		localLessThanEqual: "Mindre end eller lig med",
		localMod: "Mod",
		localNotEqual: "Ikke lig med",
		localATan2: "ARCTAN2",
		localSquare: "Kvadrat",
		localSetNull: "Angiv nul",
		remapDefTypeList: "Liste",
		remapDefTypeTable: "Tabel",
		remapTableTypeSimple: "Enkel",
		remapTableTypeDynamic: "Dynamisk",
		remapTableTypeReassignment: "Gentildeling",
		geomCorrectionByConstZ: "Brug konstant Z",
		geomCorrectionByDEM: "Brug DEM",
		radarCalibBetaNought: "Beta-nought",
		radarCalibSigmaNought: "Sigma-nought",
		radarCalibGammaNought: "Gamma-nought",
		speckleFilterTypeLee: "Lee-filter",
		speckleFilterTypeEnhancedLee: "Udvidet Lee-filter",
		speckleFilterTypeFrost: "Frost-filter",
		speckleFilterTypeKuan: "Kuan-filter",
		speckleNoiseModelMul: "Multiplikativ støj",
		speckleNoiseModelAdd: "Additiv støj",
		speckleNoiseModelAddnMul: "Additiv og multiplikativ støj",
		mosaicOpTypeFirst: "Første",
		mosaicOpTypeLast: "Sidste",
		mosaicOpTypeMin: "Min.",
		mosaicOpTypeMax: "Maks.",
		mosaicOpTypeMean: "Middel",
		mosaicOpTypeBlend: "Bland",
		mosaicOpTypeSum: "Sum",
		integer: "Heltal",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Lodret",
		horizontal: "Vandret",
		localCellStatisticsMajority: "Majoritet",
		localCellStatisticsMax: "Maksimum",
		localCellStatisticsMean: "Middel",
		localCellStatisticsMedian: "Median",
		localCellStatisticsMin: "Minimum",
		localCellStatisticsMinority: "Minoritet",
		localCellStatisticsRange: "Område",
		localCellStatisticsStdDev: "Standardafvigelse",
		localCellStatisticsSum: "Sum",
		localCellStatisticsVariety: "Variation",
		localCellStatisticsMajorityIgnoreND: "Majoritet (ignorer NoData)",
		localCellStatisticsMaxIgnoreND: "Maksimum (ignorer NoData)",
		localCellStatisticsMeanIgnoreND: "Middel (ignorer NoData)",
		localCellStatisticsMedianIgnoreND: "Median (ignorer NoData)",
		localCellStatisticsMinIgnoreND: "Minimum (ignorer NoData)",
		localCellStatisticsMinorityIgnoreND: "Minoritet (ignorer NoData)",
		localCellStatisticsRangeIgnoreND: "Interval (ignorer NoData)",
		localCellStatisticsStdDevIgnoreND: "Standard-afvigelse (ignorer NoData)",
		localCellStatisticsSumIgnoreND: "Sum (ignorer NoData)",
		localCellStatisticsVarietyIgnoreND: "Variation (ignorer NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Percentil (Ignorer NoData)",
		fromSource: "Fra kilde",
		toSource: "Til kilde",
		colorspaceConversionRgbToHsv: "RGB til HSV",
		colorspaceConversionHsvToRgb: "HSV til RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Middel",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Rektangel",
		circleNeighborhood: "Cirkel",
		annulusNeighborhood: "Annulus",
		wedgeNeighborhood: "Kile",
		irregularNeighborhood: "Uregelmæssig",
		weightNeighborhood: "Vægt",
		four: "Fire",
		eight: "Otte",
		within: "Inden for",
		cross: "Kryds",
		addLink: "Tilføj link",
		noLink: "Intet link",
		weightedMean: "Vægtet gennemsnit",
		ls8QCBitPatternCirrus: "Landsat 8 cirrusskyer",
		ls8QCBitPatternCloud: "Landsat 8 skyer",
		ls8QCBitPatternCloudShadow: "Landsat 8 skygge fra skyer",
		ls8QCBitPatternDesignatedFill: "Landsat 8 udfyldning",
		ls8QCBitPatternDroppedFrame: "Landsat 8 undertrykt billede",
		ls8QCBitPatternSnowIce: "Landsat 8 sne/is",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 terræn-okklusion",
		ls8QCBitPatternVegetation: "Landsat 8 vegetation",
		ls8QCBitPatternWater: "Landsat 8 vand",
		downStream: "Nedstrøms",
		upStream: "Opstrøms",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Nuværende udsnit",
		allSlices: "Alle udsnit",
		expandDistance: "DISTANCE",
		expandMorphological: "MORFOLOGISK",
		spectralProfileFile: "Spektral profil",
		trainingFeatureFile: "Træningsfunktion",
		randomDistributionTypeUniform: "Ensartet",
		randomDistributionTypeUniformInteger: "Heltal",
		randomDistributionTypeNormal: "Normal",
		randomDistributionTypeExponential: "Eksponentiel",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gamma",
		randomDistributionTypeBinomial: "Binomisk",
		randomDistributionTypeGeometric: "Geometrisk",
		randomDistributionTypeNegativeBinomial: "Negativ binomisk",
		randomGeneratorTypeStandardCRand: "Standard C Rand",
		randomGeneratorTypeAlgorithmACM599: "ACM-indsamlet algoritme 599",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Sum",
		medainName: "Median",
		trendLinear: "Lineær",
		trendHarmonic: "Harmonisk",
		trendPolynomial: "Polynomial",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Sæsonbestemt Kendall",
		dimensionByValue: "Efter værdi",
		dimensionByInterval: "Efter interval",
		mdimDefTypeAll: "Alle",
		mdimDefTypeByValues: "Efter værdier",
		mdimDefTypeByRanges: "Efter områder",
		mdimDefTypeByIteration: "Efter gentagelse",
		mdimDefTypeByInterval: "Efter interval",
		mdimDefTypeByTargetRaster: "Efter mål-raster",
		esriTimeUnitsHours: "Timer",
		esriTimeUnitsDays: "Dage",
		esriTimeUnitsWeeks: "Uger",
		esriTimeUnitsMonths: "Måneder",
		esriTimeUnitsYears: "År",
		esriTimeIntervalKeywordHourly: "Hver time",
		esriTimeIntervalKeywordDaily: "Hver dag",
		esriTimeIntervalKeywordWeekly: "Hver uge",
		esriTimeIntervalKeywordDekadly: "Hvert tiende år",
		esriTimeIntervalKeywordPentadly: "Hvert femte år",
		esriTimeIntervalKeywordMonthly: "Hver måned",
		esriTimeIntervalKeywordQuarterly: "Hver kvartal",
		esriTimeIntervalKeywordYearly: "Årligt",
		esriTimeIntervalKeywordRecurringDaily: "Dagligt tilbagevendende",
		esriTimeIntervalKeywordRecurringWeekly: "Ugentligt tilbagevendende",
		esriTimeIntervalKeywordRecurringMonthly: "Månedligt tilbagevendende",
		esriTimeIntervalKeywordRecurringQuarterly: "Kvartalsvist tilbagevendende",
		aggDefTypeAll: "Alle",
		aggDefTypeIntervalKeyword: "Interval-nøgleord",
		aggDefTypeIntervalValue: "Interval-værdi",
		aggDefTypeIntervalRanges: "Interval-område",
		latestChange: "Tid for seneste ændring",
		earliestChange: "Tid for tidligste ændring",
		largestChange: "Tid for største ændring",
		numberOfChanges: "Antal ændringer",
		longestChange: "Tid for længste ændring",
		shortestChange: "Tid for korteste ændring",
		fastestChange: "Tid for hurtigste ændring",
		slowestChange: "Tid for langsomste ændring",
		allChanges: "Alle",
		increaseChanges: "Øg",
		decreaseChanges: "Formindsk",
		segmentBeginning: "Start på segment",
		segmentEnd: "Slutning på segment",
		esriComputeChangeMethodDifference: "Forskel",
		esriComputeChangeMethodRelativeDifference: "Relativ forskel",
		esriComputeChangeMethodCategorical: "Kategorisk forskel",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Spektral euklidisk afstand",
		esriComputeChangeMethodMultispectralAngularDifference: "Spektral vinkelforskel",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Bånd med mest ændring",
		esriComputeChangeKeepAll: "Bevar alle",
		esriComputeChangeKeepChangedOnly: "Bevar kun ændrede pixels",
		esriComputeChangeKeepUnchangedOnly: "Bevar kun uændrede pixels",
		esriComputeChangeUseColorAverage: "Gennemsnit fra og til farver",
		esriComputeChangeUseColorFrom: "Anvend fra farver",
		esriComputeChangeUseColorTo: "Anvend til farver",
		factorFunctionBinary: "Binær",
		factorFunctionForward: "Frem",
		factorFunctionLinear: "Lineær",
		factorFunctionInvLinear: "Omvendt lineær",
		factorFunctionTable: "Tabel",
		factorFunctionSymLinear: "Symetrisk lineær",
		factorFunctionSymInvLinear: "Symmetrisk omvendt lineær",
		factorFunctionCos: "Cosinus",
		factorFunctionSec: "Sekant",
		factorFunctionCosSec: "Cosinus sekant",
		factorFunctionSecCos: "Sekant Cosinus",
		noSort: "Sortér ikke",
		ascend: "Stigende",
		descend: "Faldende",
		autoDetect: "Auto-registrering",
		nearest: "Nærmest",
		linear: "Lineær",
		esriMonthJanuary: "Januar",
		esriMonthFebruary: "Februar",
		esriMonthMarch: "Marts",
		esriMonthApril: "April",
		esriMonthMay: "Maj",
		esriMonthJune: "Juni",
		esriMonthJuly: "Juli",
		esriMonthAugust: "August",
		esriMonthSeptember: "September",
		esriMonthOctober: "Oktober",
		esriMonthNovember: "November",
		esriMonthDecember: "December",
		dimensionalMovingIgnoreNoData: "Data",
		dimensionalMovingPropagateNoData: "NoData",
		dimensionalMovingFillOnlyNoData: "Udfyld NoData",
		circularMean: "Cirkulær middelværdi",
		circularName: "Cirkulær",
		arithmeticName: "Aritmetisk",
		slopeName: "Stigning",
		aspectName: "Aspekt",
		meanCurvature: "Middelkrumning",
		profileCurvature: "Profilkrumning (normal stigningslinje)",
		tangentialCurvature: "Tangential krumning (normal kontur)",
		planCurvature: "Plankrumning (projiceret kontur)",
		contourGeodesicTorsion: "Kontur – geodætisk vridning",
		gaussianCurvature: "Gaussisk krumning",
		casoratiCurvature: "Casoratisk krumning",
		localSurfaceTypeQuadratic: "kvadratisk",
		localSurfaceTypeBiquadratic: "Bikvadratisk",
		thresholdNoThreshold: "Ingen tærskel",
		thresholdPercentLeastCost: "Procent for laveste omkostning",
		thresholdAccumulativeCost: "Akkumuleret omkostning",
		clrmapTypeHillshade: "Skyggevirkning"
	},
	categoryLabels: {
		sourceCharacteristics: "Kildeegenskaber",
		neighborhoodSettings: "Naboindstillinger",
		statistics: "Statistik",
		gamma: "Gamma",
		viewshedParameters: "Parametre for udsigtsområde",
		observerParameters: "Parametre for observation",
		irregularDataInterpolation: "Uregelmæssig datainterpolation",
		modelStatistics: "Modelstatistik",
		aggregationDef: "Aggregeringsdefinition",
		filterByAttributes: "Filtrér efter attributter",
		percentileName: "Percentil",
		rasterInfo: "Rasteoplysninger",
		extent: "Udstrækning",
		spatialReference: "Spatial reference"
	},
	outputRasterHelpTexts: {
		outputName: "<p>Navnet på det, der oprettes og føjes til kortet.</p>",
		resultType: "<p>Den type output, der oprettes. Outputtene kan være tile-billedlag eller dynamiske billedlag.</p>",
		saveResultIn: "<p>Navnet på mappen <b>Mit indhold</b>, hvor resultatet gemmes.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Miljøindstillinger for analyse i Map Viewer. </p>",
		outSR: "<p>Angiver koordinatsystemet for analyse og resultatlaget.</p>",
		extent: "<p>Angiver det område, der skal anvendes til analyse.</p>",
		snapRaster: "<p>Justerer udstrækningen for outputtet, så det passer til cellejusteringen for det angivne snap-raster-lag.</p>",
		cellSize: "<p>Angiver den cellestørrelse eller opløsning, som skal bruges til analyse og til at oprette outputrasterlaget.</p>",
		mask: "<p>Angiver et maskelag, hvor kun de celler, der falder inden for maskeområdet, vil blive brugt til analyse.</p>",
		resamplingMethod: "<p>Angiver, hvordan pixelværdierne skal interpoleres, når input- og outputraster ikke stemmer overens.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Ikke-understøttet type",
		currentlyUnsupported: " En standard editor til ${missingType} kommer snart. Midlertidig pladsholder-tekstboks til angivelse af strengbaseret input",
		unsupportedOverrideWarning: "En tilsidesæt editor-komponent, der giver en bedre UX ved arbejde med følgende parametre, kommer snart:",
		overrideWidgetMissing: "Tilsidesæt editor-komponent mangler!",
		uiIncomplete: "Jobafsendelse mislykkedes. Funktionen kan ikke køre, fordi nogle af de krævede felter er ufuldstændige eller mangler i UI.",
		count: "Tælling",
		selectVariables: "Vælg variabler",
		selectFeature: "Vælg objektlag",
		greaterThanErrorMessage: "Input-tallet skal være større end ${min}",
		lesserThanErrorMessage: "Input-tallet skal være mindre end ${max}",
		greaterThanOrEqualErrorMessage: "Input-tallet skal være større end eller lig med ${min}",
		lesserThanOrEqualErrorMessage: "Input-tallet skal være mindre end eller lig med ${max}",
		allowScalar: "Vælg et lag, eller angiv en konstant",
		selectField: "Vælg felt",
		parameterRequired: "Denne parameter er påkrævet.",
		enterAValue: "Angiv en værdi...",
		invalidInput: "Den angivne værdi er ikke gyldig.",
		itemNotFound: "Elementet eksisterer ikke eller er ikke tilgængeligt.",
		itemPermissionDenied: "Du har ikke adgangsrettigheder til dette element.",
		layerNotAvailable: "Kan ikke indlæse lag ${layerName}.",
		multipleLayersNotAvailable: "Kan ikke indlæse lag ${layerName} og andet.",
		learnMoreLabel: "Få mere at vide",
		fieldNotAvailable: "Kunne ikke indlæse felt.",
		allowAnalysis: "Analyse er ikke tilladt i billedtjenesten.",
		allowAnalysisReason: "Et eller flere lag fra dette kort er ikke angivet her, fordi de ikke tillader analyse.",
		learnMoreText: "Få mere at vide",
		atLeastOneRasterInput: "Mindst ét inputlag skal være et rasterlag.",
		browseAnalysisLayers: "Gennemse lag",
		activeMapViewExtent: "Brug aktuel kortudstrækning",
		chooseRaster: "Vælg klip-raster",
		chooseGeometry: "Vælg klip-geometri",
		resultType: "Resultattype",
		saveInFolder: "Gem i mappe",
		outputName: "Outputnavn",
		outputLayerType: "Outputlagtype",
		dynamicImageryLayer: "Dynamisk billedlag",
		tiledImageryLayer: "Tile-billedlag",
		custom: "Brugerdefineret",
		loading: "Indlæser...",
		layerMissing: "Et eller flere lag fra dette kort er ikke angivet her, fordi de ikke tillader analyse. Lær mere.",
		browseCoordinateSystems: "Gennemse koordinatsystemer",
		unableToRepopulateOutSR: "Kan ikke udfylde output-koordinatsystem.",
		defaultTitle: "Se mere",
		"ARC (equal arc-second)": "ARC (lige buesekund)",
		Africa: "Afrika",
		Antarctica: "Antarktis",
		Argentina: "Argentina",
		Asia: "Asien",
		"Asteroid Belt": "Asteroidebæltet",
		"Atlantic Ocean": "Atlanterhavet",
		Australia: "Australien",
		"Australia and New Zealand": "Australien og New Zealand",
		Austria: "Østrig",
		"BLM (US Feet)": "BLM (amerikanske fod)",
		Bangladesh: "Bangladesh",
		"Beijing 1954": "Beijing 1954",
		Bhutan: "Bhutan",
		CGCS2000: "CGCS2000",
		Canada: "Canada",
		Caribbean: "Caribien",
		"Caribbean Sea": "Det Caribiske Hav",
		"Central America": "Centralamerika",
		"Central and North America": "Central- og Nordamerika",
		Colombia: "Colombia",
		Continental: "Kontinental",
		"County Systems": "Amtsystemer",
		"Democratic Republic of the Congo": "Demokratiske Republik Congo",
		"EPSG Arctic": "EPSG – arktisk",
		Earth: "Jorden",
		"Ellipsoidal-based": "Ellipsoide-baseret",
		Europe: "Europa",
		Finland: "Finland",
		France: "Frankrig",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss Kruger",
		"Geographic Coordinate Systems": "Geografiske koordinatsystemer",
		Germany: "Tyskland",
		"Gravity-related": "Tyngdekraftrelateret",
		"Greenwich-based": "Greenwich-baseret",
		"Highways England": "Motorveje – England",
		Illinois: "Illinois",
		"Indian Ocean": "Det Indiske Ocean",
		"Indian Subcontinent": "Det Indiske Subkontinent",
		Indiana: "Indiana",
		Indonesia: "Indonesien",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irland og Storbritannien",
		Italy: "Italien",
		Japan: "Japan",
		Jupiter: "Jupiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Libyen",
		Malaysia: "Malaysia",
		"Malaysia and Singapore": "Malaysia og Singapore",
		Mars: "Mars",
		Mercury: "Merkur",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (amerikanske fod)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (internationale fod)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (meter)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (amerikanske fod)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (internationale fod)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (meter)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (amerikanske fod)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (internationale fod)",
		"NAD 1983 (Meters)": "NAD 1983 (meter)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (meter)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (amerikanske fod)",
		"NAD 1983 (US Feet)": "NAD 1983 (amerikanske fod)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (internationale fod)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (meter)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (amerikanske fod)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (internationale fod)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (meter)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (internationale fod)",
		"National Grids": "Nationale gitre",
		Navajo: "Navajo",
		Neptune: "Neptun",
		"New Beijing": "Nyt Beijing",
		"New Zealand": "New Zealand",
		"North America": "Nordamerika",
		"Northern Hemisphere": "Nordlig halvkugle",
		Norway: "Norge",
		Oceans: "Oceaner",
		Oregon: "Oregon",
		"Other GCS": "Andet GCS",
		"Pacific Ocean": "Stillehavet",
		Pluto: "Pluto",
		Polar: "Polar",
		Portugal: "Portugal",
		"Projected Coordinate Systems": "Forudberegnede koordinatsystemer",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Erstattet",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturn",
		"Solar System": "Solsystemet",
		"South Africa": "Sydafrika",
		"South America": "Sydamerika",
		"South Korea": "Sydkorea",
		"Southern Hemisphere": "Sydlig halvkugle",
		"Spheroid-based": "Sfæroid-baseret",
		"State Plane": "Delstatsplan",
		"State Systems": "Delstatssystemer",
		Sweden: "Sverige",
		"Switzerland and Liechtenstein": "Schweiz og Liechtenstein",
		Texas: "Texas",
		Tribal: "Stammerelateret",
		Turkey: "Tyrkiet",
		"US Feet": "Amerikanske fod",
		"USA and territories": "USA og territorier",
		UTM: "UTM",
		Ukraine: "Ukraine",
		"Unknown Height Systems": "Ukendte højdesystemer",
		Uranus: "Uranus",
		Venus: "Venus",
		"Vertical Coordinate Systems": "Vertikale koordinatsystemer",
		Vietnam: "Vietnam",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Verden",
		"World (Sphere-based)": "Verden (sfærisk-baseret)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Udført",
		noResults: "Der blev ikke fundet nogen resultater",
		searchPlaceholder: "Navn eller WKID",
		browseTemplate: "Gennemse rasterfunktionsskabeloner",
		saveTemplate: "Gem rasterfunktionsskabelon",
		preview: "Forhåndsvisning",
		previewDescription: "Vis resultatet, før analysen køres.",
		showPreview: "Vis forhåndsvisning",
		previewLayer: "Forhåndsvisningslag ${number}",
		newPreview: "Ny forhåndsvisning",
		previewPopup: "Aktivér forhåndsvisning af analyseresultaterne baseret på inputparametrene.",
		updatePreviewLayer: "Opdatér det valgte forhåndsvisningslag",
		createPreviewLayer: "Opret nyt forhåndsvisningslag",
		maximumPreviewAllowed: "Det maksimale tilladte antal forhåndsvisningslag: ${maxCount}",
		previewFailure: "Forhåndsvisningslaget er ikke tilgængeligt. Kontrollér inputparametrene, og opdater forhåndsvisningslaget igen.",
		header: "Vælg element",
		content: "Du har ændringer, der ikke er gemt, i ${rftTitle}. Hvis du starter forfra med en ny skabelon, går disse ændringer tabt.",
		dontSave: "Gem ikke",
		"continue": "Fortsæt",
		stretch: "Tilpas til vindue",
		pan: "Panorér",
		newTemplate: "Opret ny skabelon",
		openTemplate: "Åbn skabelon",
		addFunction: "Tilføj rasterfunktioner",
		addConstant: "Tilføj kontrast",
		addRaster: "Tilføj rastervariabel",
		move: "Flyt",
		zoom: "Zoom",
		saveAs: "Gem som",
		clear: "Ryd",
		addRasterFunctionTitle: "Tilføj rasterfunktioner",
		templatePropertiesTitle: "Egenskaber for skabelon",
		browseRFT: "Gennemse rasterfunktionsskabeloner",
		defaultToolDescription: "${toolTitle}-analyseværktøj.",
		openToolText: "Åbn værktøj",
		toolDropdownText: "Værktøjsrullemenu",
		addToMap: "Bekræft og tilføj kort",
		confirm: "Bekræft",
		select: "Vælg",
		selectTask: "Vælg opgave",
		unsupportedLayer: "Denne parameter undersøtter ikke følgende lag: ${layerName}.",
		viewDetails: "Vis alle oplysninger om elementet",
		rename: "Omdøb",
		duplicate: "Duplikér",
		launch: "Åbn for at køre",
		templateEditor: "Skabeloneditor",
		createItem: "Gem rasterfunktionsskabelon",
		actionLabel: "Filtrér",
		filterPopoverHeading: "Filtrer funktionerne",
		defaultSearchPlaceholder: "Søg efter navn",
		settings: "Indstillinger",
		summary: "Resumé",
		definitionQuery: "Definitionsforespørgsel",
		matchVariables: "Matchvariabler",
		unionDimension: "Foreningsdimension",
		nameEditorPlaceholder: "Indtast titel",
		summaryEditorPlaceholder: "Angiv en kort beskrivelse.",
		definitionQueryPlaceholder: "Indtast...",
		upload: "Overfør",
		chooseImage: "Klik for at vælge en fil",
		update: "Opdatér",
		thumbnailErrors: {
			wrongImageType: "Der er valgt den forkerte billedtype.",
			notAvailable: "Miniaturen er ikke tilgængelig",
			loadError: "Kunne ikke indlæse billedet",
			chooseFile: "Klik for at vælge fil"
		}
	}
};
const copy = "Kopiér";
const save = "Gem";
const title = "Titel";
const folder = "Mappe";
const tags = "\"Tags\"";
const savingMessage = "Gemmer elementet i";
const shareWith = "Del med";
const share = "Del";
const setSharingLevel = "Angiv delingsniveau";
const setGroupSharing = "Angiv deling med grupper";
const owner = "Ejer";
const organization = "Organisation";
const everyone = "Alle (offentlig)";
const groups = "Grupper:";
const type = "Type";
const mosaic = "Mosaik";
const itemGroup = "Elementgruppe";
const item = "Element";
const definitionQuery = "Definitionsforespørgsel";
const groupItemsBy = "Gruppér elementer efter";
const groupFieldName = "Gruppér feltnavn";
const tagFieldName = "Tag feltnavn";
const noTitleTagErrorMsg = "Du skal angive en titel til dit element samt nøgleord, der gør det muligt at finde dit kort ved hjælp af søgninger.";
const noTitleErrorMsg = "Du skal angive en titel på elementet.";
const noTagErrorMsg = "Du skal angive mindst ét nøgleord for at hjælpe folk med at finde dit element via søgninger.";
const error = "Fejl";
const warning = "Advarsel";
const success = "Succes";
const details = "Oplysninger:";
const tryAgain = "Prøv igen";
const toolModeler = {
	save: "Gem",
	editProperties: "Rediger egenskaber",
	saveAs: "Gem som",
	savingNotification: "Gemmer ændringer til elementet...",
	savingTitle: "Gemmer",
	saveFailedMessage: "Kunne ikke gemme ændringer.",
	saveWithErrorsMessage: "Ændringerne blev gemt med følgende fejl.",
	viewItemMessage: "Vis det gemte element",
	here: "her.",
	itemCreatedMessage: "Nyt element er blevet oprettet.",
	clickToViewItemMessage: "Klik på OK for at få vist siden med elementoplysninger; klik på Annullér for at fortsætte.",
	readingFailed: "Kunne ikke indlæse den valgte skabelon til rasterfunktionen.",
	failedToLoadXML: "Kan ikke indlæse den valgte skabelon til rasterfunktionen i XML-format.",
	learnMore: "Få mere at vide",
	overwriteTitle: "Bekræft overskrivning",
	overwriteMessage: "Vil du overskrive et eksisterende element?",
	overwriteSuccessMessage: "Element er blevet opdateret."
};
const toolEditor = {
	run: "Kør",
	save: "Gem",
	deleteSelected: "Slet de markerede elementer",
	addRaster: "Tilføj raster",
	addScalar: "Tilføj skalar",
	layout: "Autolayout",
	errorTitle: "Fejl",
	invalidToolMessage: "Skabelonen til rasterfunktionen er ikke gyldig.",
	out: "Ud",
	zoomIn: "Zoom In",
	zoomOut: "Zoom Out",
	zoomToFit: "Tilpas til vindue",
	panOn: "Skift til panoreringstilstand",
	panOff: "Slå panoreringstilstand fra",
	defaultModelName: "Værktøjet Model",
	defaultRasterName: "Raster"
};
const toolDetailsEditor = {
	defaultToolName: "Rasterfunktionsskabelon",
	defaultToolDescription: "Tilføj et kort resumé om rasterfunktionen.",
	defaultHelpText: "Klik på hjælp-ikonet for at redigere hjælp-teksten",
	editHelpTitle: "Rediger Hjælp",
	saveLabel: "Gem",
	cancelLabel: "Annuller",
	thumbnail: {
		wrongImageType: "Der er valgt den forkerte billedtype.",
		notAvailable: "Miniaturen er ikke tilgængelig",
		loadError: "Kunne ikke indlæse billedet",
		chooseFile: "Klik for at vælge fil"
	}
};
const saveUtils = {
	thumbnail: "Miniaturebillede",
	sharing: "Deler"
};
const close = "Luk";
const unsavedWarningExisting = "Vil du gerne gemme ændringerne til elementet <b>${itemTitle}</b> ?";
const unsavedWarningNew = "Vil du gemme dine ændringer?";
const saveAs = "Gem som";
const dontSave = "Gem ikke";
const unsavedTitle = "Ændringer, der ikke er gemt";
const invalidRFTMessage = "Den oprettede skabelon til rasterfunktion er ikke gyldig.";
const errorTitle = "Fejl";
const breadcrumb = "Rasterfunktionseditor";
const breadcrumbEditor = "Indhold > Rasterfunktionseditor";
const viewerModeTitle = "Skrivebeskyttet";
const viewerModeMessage = "Rasterfunktionsskabelon-element er skrivebeskyttet. Ændringer kan ikke gemmes.";
const userStartDirection = "Vælg en funktion for at begynde at oprette en skabelon til rasterfunktion.";
const selectFunction = "Tilføj funktion";
const deselectFunction = "Fjern funktion";
const dialogTitle = "System";
const category = "Kategorier";
const search = "Søg i rasterfunktioner";
const categoryNames = {
	analysis: "Analyse",
	appearance: "Udseende",
	classification: "Klassifikation",
	conversion: "Konvertering",
	correction: "Korrektion",
	dataManagement: "Datahåndtering",
	distance: "Afstand",
	distanceLegacy: "Afstand (udfaset)",
	hydrology: "Hydrologi",
	math: "Matematik",
	mathConditional: "Matematik: Betinget",
	mathLogical: "Matematik: Logisk",
	mathTrigonometric: "Matematik: Trigonometrisk",
	reclass: "Omklassificering",
	statistical: "Statistisk",
	surface: "Overflade"
};
const commonStrings_da = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_da);


//# sourceMappingURL=common-strings.da-55c733be.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTNkMjRlNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNFVBQTRVLG9IQUFvSCx5Q0FBeUM7QUFDemU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1NQUFtTTtBQUNuTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb29DQUFvb0MsMlNBQTJTO0FBQy82QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZzdGQUFnN0YsT0FBTztBQUN2N0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFLCtEQUErRCxJQUFJO0FBQ25FLHFGQUFxRixJQUFJO0FBQ3pGLG9GQUFvRixJQUFJO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQsc0RBQXNELFdBQVc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxTQUFTO0FBQ3ZGO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxVQUFVO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFVBQVU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxnQkFBZ0IsRUFBQztBQUNpb0M7O0FBRWpxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL2NvbW1vbi1zdHJpbmdzLmRhLTU1YzczM2JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG9rID0gXCJPS1wiO1xuY29uc3QgY2FuY2VsID0gXCJBbm51bGxlclwiO1xuY29uc3QgZW50ZXJVUkwgPSBcIkluZHRhc3QgYmlsbGVkdGplbmVzdGUtVVJMXCI7XG5jb25zdCBzZXJ2aWNlVVJMID0gXCJUamVuZXN0ZS1VUkxcIjtcbmNvbnN0IHNlbGVjdFJhc3RlciA9IFwiVsOmbGcgcmFzdGVyXCI7XG5jb25zdCBmYWlsZWRUb0xvYWRMYXllciA9IFwiS3VubmUgaWtrZSBpbmRsw6ZzZSBsYWdcIjtcbmNvbnN0IGxvYWRpbmdMYXllciA9IFwiSW5kbMOmc2VyIGxhZ1wiO1xuY29uc3Qgc2VsZWN0RmVhdHVyZSA9IFwiVsOmbGcgdmVrdG9ybGFnXCI7XG5jb25zdCBlbnRlckZVUkwgPSBcIkluZHRhc3QgZmVhdHVyZXRqZW5lc3RlLVVSTFwiO1xuY29uc3QgYWRkUmFzdGVyID0gXCJUaWxmw7hqIHJhc3RlcnZhcmlhYmVsXCI7XG5jb25zdCBhZGRTY2FsYXIgPSBcIlRpbGbDuGoga29uc3RhbnRcIjtcbmNvbnN0IHJhc3RlciA9IFwiUmFzdGVyXCI7XG5jb25zdCBzY2FsYXIgPSBcIlNrYWxhclwiO1xuY29uc3QgZGVmYXVsdE1vZGVsTmFtZSA9IFwiUmFzdGVyZnVua3Rpb25zc2thYmVsb25cIjtcbmNvbnN0IGdlbmVyYWwgPSBcIkdlbmVyZWx0XCI7XG5jb25zdCBwYXJhbWV0ZXJzID0gXCJQYXJhbWV0cmVcIjtcbmNvbnN0IHZhcmlhYmxlcyA9IFwiVmFyaWFibGVyXCI7XG5jb25zdCBuYW1lID0gXCJOYXZuXCI7XG5jb25zdCBkZXNjcmlwdGlvbiA9IFwiQmVza3JpdmVsc2VcIjtcbmNvbnN0IHBhcmFtZXRlciA9IFwicGFyYW1ldGVyXCI7XG5jb25zdCBpc1B1YmxpYyA9IFwiSXNQdWJsaWNcIjtcbmNvbnN0IGlzRGF0YXNldCA9IFwiSXNEYXRhc2V0XCI7XG5jb25zdCB1bmtub3duUGl4ZWxUeXBlID0gXCJVa2VuZHRcIjtcbmNvbnN0IG91dHB1dFBpeGVsVHlwZSA9IFwiT3V0cHV0LXBpeGVsdHlwZVwiO1xuY29uc3QgdThQaXhlbFR5cGUgPSBcIjggYml0IHVzaWduZXJldFwiO1xuY29uc3QgczhQaXhlbFR5cGUgPSBcIjggYml0IHNpZ25lcmV0XCI7XG5jb25zdCB1MTZQaXhlbFR5cGUgPSBcIjE2IGJpdCB1c2lnbmVyZXRcIjtcbmNvbnN0IHMxNlBpeGVsVHlwZSA9IFwiMTYgYml0IHNpZ25lcmV0XCI7XG5jb25zdCB1MzJQaXhlbFR5cGUgPSBcIjMyIGJpdCB1c2lnbmVyZXRcIjtcbmNvbnN0IHMzMlBpeGVsVHlwZSA9IFwiMzIgYml0IHNpZ25lcmV0XCI7XG5jb25zdCBmMzJQaXhlbFR5cGUgPSBcIjMyIGJpdCBmbHlkZW5kZVwiO1xuY29uc3QgZjY0UGl4ZWxUeXBlID0gXCI2NCBiaXQgZG9ibGV0XCI7XG5jb25zdCBwcm9wZXJ0aWVzID0gXCJFZ2Vuc2thYmVyXCI7XG5jb25zdCBtdWx0aWRpbWVuc2lvbmFsUnVsZXMgPSBcIkZsZXJkaW1lbnNpb25hbGUgcmVnbGVyXCI7XG5jb25zdCBtYXRjaFZhcmlhYmxlcyA9IFwiTWF0Y2gtdmFyaWFibGVyXCI7XG5jb25zdCB1bmlvbkRpbWVuc2lvbnMgPSBcIlVuaW9uLWRpbWVuc2lvbmVyXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbkVkaXRvciA9IHtcblx0aW52YWxpZFJGVE1lc3NhZ2U6IFwiU2thYmVsb25lbiB0aWwgcmFzdGVyZnVua3Rpb25lbiBlciBpa2tlIGd5bGRpZy5cIixcblx0cmZ4QXJnc0VkaXRvcjoge1xuXHRcdG91dHB1dFJhc3RlcjogXCJPdXRwdXRSYXN0ZXJcIixcblx0XHRyYXN0ZXI6IFwiUmFzdGVyXCIsXG5cdFx0dW5zdXBwb3J0ZWREYXRhVHlwZVdhcm5pbmc6IFwiRsO4bGdlbmRlIGFyZ3VtZW50ZXIgdmlzZXMgaWtrZSwgZm9yZGkgZGUgaWtrZSB1bmRlcnN0w7h0dGVzIHDDpSBudXbDpnJlbmRlIHRpZHNwdW5rdC5cIixcblx0XHR1bnN1cHBvcnRlZEZ1bmN0aW9uOiBcIkluZGVob2xkZXIgZW4gZWxsZXIgZmxlcmUgcmFzdGVyZnVua3Rpb25lciwgZGVyIGlra2UgdW5kZXJzdMO4dHRlcy5cIlxuXHR9LFxuXHRyZnhSYXN0ZXJJbnB1dDoge1xuXHRcdHNlbGVjdExheWVyOiBcIlbDpmxnIGxhZ1wiLFxuXHRcdGJyb3dzZUxheWVyczogXCJHZW5uZW1zZSBsYWdcIixcblx0XHRyZnhWYXJpYWJsZTogXCJSYXN0ZXJGdW5jdGlvblZhcmlhYmxlXCJcblx0fSxcblx0cmZ4QmFuZENvbWJpbmF0aW9uRWRpdG9yOiB7XG5cdFx0bWV0aG9kTGFiZWw6IFwiTWV0b2RlXCIsXG5cdFx0YmFuZExhYmVsOiBcIkLDpW5kXCIsXG5cdFx0Y29tYmluYXRpb25MYWJlbDogXCJLb21iaW5hdGlvblwiXG5cdH0sXG5cdHJmeFJlbWFwR3JpZDoge1xuXHRcdG1pbmltdW06IFwiTWluaW11bVwiLFxuXHRcdG1heGltdW06IFwiTWFrc2ltdW1cIixcblx0XHRvdXRwdXQ6IFwiT3V0cHV0XCIsXG5cdFx0bm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdHJlbWFwVmFsdWVzTGFiZWw6IFwiR2VuYmVyZWduIHbDpnJkaWVyXCJcblx0fSxcblx0cmZ4TmFtZWRSYXN0ZXJFZGl0b3I6IHtcblx0XHRyYXN0ZXJWYXJpYWJsZXM6IFwiUmFzdGVydmFyaWFibGVyXCIsXG5cdFx0ZGVsZXRlU2VsZWN0ZWRWYXJzOiBcIkZqZXJuIGRlIHZhbGd0ZSB2YXJpYWJsZXJcIlxuXHR9LFxuXHRyZnhDbGlwcGluZ0dlb21ldHJ5OiB7XG5cdFx0Y2xpcHBpbmdMYXllcjogXCJLbGlwLWxhZ1wiLFxuXHRcdGNsaXBwaW5nUmFzdGVyOiBcIktsaXAtcmFzdGVyXCIsXG5cdFx0Y2xpcHBpbmdHZW9tZXRyeTogXCJLbGlwLWdlb21ldHJpXCIsXG5cdFx0Y3VzdG9tRXh0ZW50OiBcIkJydWdlcmRlZmluZXJldCB1ZHN0csOma25pbmdcIixcblx0XHRvdXRwdXRFeHRlbnQ6IFwiT3V0cHV0LXVkc3Ryw6ZrbmluZ1wiLFxuXHRcdGN1cnJlbnRFeHRlbnQ6IFwiQWt0dWVsIGtvcnR1ZHN0csOma25pbmdcIixcblx0XHRkcmF3TGFiZWw6IFwiVGVnblwiXG5cdH0sXG5cdHJmeEN1c3RvbUV4dGVudDoge1xuXHRcdHRvcDogXCJUb3BcIixcblx0XHRyaWdodDogXCJIw7hqcmVcIixcblx0XHRib3R0b206IFwiQnVuZFwiLFxuXHRcdGxlZnQ6IFwiVmVuc3RyZVwiXG5cdH0sXG5cdHJmeFJhc3RlckFycmF5RWRpdG9yOiB7XG5cdFx0bW92ZVVwOiBcIkZseXQgb3BcIixcblx0XHRtb3ZlRG93bjogXCJGbHl0IG5lZFwiLFxuXHRcdHJlbW92ZTogXCJGamVyblwiXG5cdH0sXG5cdHJmeFN0YXRpc3RpY3NHcmlkOiB7XG5cdFx0c3RkRGV2OiBcIlN0ZC4gYWZ2LlwiLFxuXHRcdG1pbjogXCJNaW4uXCIsXG5cdFx0bWF4OiBcIk1ha3MuXCIsXG5cdFx0bWVhbjogXCJNaWRkZWxcIlxuXHR9LFxuXHRyZnhXZWlnaHRlZFN1bVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRTdW1UYWJsZTogXCJWw6ZndGV0IHN1bXRhYmVsXCIsXG5cdFx0aWQ6IFwiSURcIixcblx0XHRsYXllcjogXCJMYWdcIixcblx0XHRmaWVsZDogXCJGZWx0XCIsXG5cdFx0d2VpZ2h0OiBcIlbDpmd0XCIsXG5cdFx0dmFsdWU6IFwiVsOmcmRpXCIsXG5cdFx0c2VsZWN0TGF5ZXI6IFwiVsOmbGcgbGFnXCJcblx0fSxcblx0cmZ4V2VpZ2h0ZWRPdmVybGF5VGFibGVFZGl0b3I6IHtcblx0XHR3ZWlnaHRlZE92ZXJsYXlUYWJsZTogXCJWw6ZndGV0IG92ZXJsYXktdGFiZWxcIixcblx0XHRpZDogXCJJRFwiLFxuXHRcdGxheWVyOiBcIkxhZ1wiLFxuXHRcdGZpZWxkOiBcIkZlbHRcIixcblx0XHRpbmZsdWVuY2U6IFwiUMOldmlya25pbmdcIixcblx0XHRzdW1PZkluZmx1ZW5jZTogXCJTdW1tZW4gYWYgcMOldmlya25pbmdcIixcblx0XHR2YWx1ZTogXCJWw6ZyZGlcIixcblx0XHRyZW1hcFRhYmxlOiBcIkdlbmJlcmVnbiB0YWJlbFwiLFxuXHRcdHNjYWxlOiBcIk3DpWxlc3Rva1wiLFxuXHRcdHNjYWxlczogXCJWw6ZndGVcIixcblx0XHRzZWxlY3RSYXN0ZXI6IFwiVsOmbGcgcmFzdGVyXCJcblx0fSxcblx0cmZ4RmVhdHVyZVNlbGVjdDoge1xuXHRcdGFkZEZlYXR1cmVMYXllcjogXCJTw7hnIGVmdGVyIGV0IHZla3RvcmxhZ1wiLFxuXHRcdGFkZFBvaW50TGF5ZXI6IFwiU8O4ZyBlZnRlciBldCBwdW5rdGxhZ1wiXG5cdH0sXG5cdHJmeEZpZWxkU2VsZWN0OiB7XG5cdFx0dmFsdWU6IFwiVsOmcmRpXCIsXG5cdFx0Y291bnQ6IFwiVMOmbGxpbmdcIlxuXHR9LFxuXHRyZnhBdHRyaWJ1dGVUYWJsZToge1xuXHRcdHRhYmxlVHlwZTogXCJUYWJlbHR5cGVcIixcblx0XHRtYW51YWw6IFwiTWFudWVsXCIsXG5cdFx0ZXh0ZXJuYWw6IFwiRWtzdGVyblwiLFxuXHRcdG1pblZhbDogXCJNaW5pbXVtdsOmcmRpXCIsXG5cdFx0bWF4VmFsOiBcIk1ha3NpbXVtdsOmcmRpXCIsXG5cdFx0YmFzZUNsYXNzTmFtZTogXCJLbGFzc2ViYXNpc25hdm5cIixcblx0XHRjb2xvclNjaGVtZTogXCJGYXJ2ZXNrZW1hXCIsXG5cdFx0ZGVmYXVsdENsYXNzTmFtZTogXCJMYWJlbF9cIixcblx0XHRnZW5lcmF0ZVRhYmxlOiBcIkdlbmVyZXIgdGFiZWxcIixcblx0XHRicm93c2VUYWJsZTogXCJHZW5uZW1zZSB0YWJlbFwiLFxuXHRcdHZhbHVlOiBcIlbDpnJkaVwiLFxuXHRcdGNsYXNzbmFtZTogXCJDbGFzc05hbWVcIixcblx0XHRjb2xvcjogXCJGYXJ2ZVwiXG5cdH0sXG5cdHJmeEZpZWxkTnVtYmVyU3dpdGNoYWJsZToge1xuXHRcdG51bWJlcjogXCJOdW1lcmlza1wiLFxuXHRcdGZpZWxkOiBcIkZlbHRcIixcblx0XHRzdHJpbmc6IFwiU3RyZW5nXCIsXG5cdFx0bGluZWFyVW5pdDogXCJMaW5lw6ZyIGVuaGVkXCJcblx0fSxcblx0cmZ4UHJvcGVydHlTZXQ6IHtcblx0XHRuYW1lOiBcIk5hdm5cIixcblx0XHR2YWx1ZTogXCJWw6ZyZGlcIlxuXHR9LFxuXHRyZnhDb252ZXJzaW9uR3JpZDoge1xuXHRcdHNpemU6IFwiU3TDuHJyZWxzZVwiXG5cdH0sXG5cdHJmeFRyYW5zcG9zZUJpdDoge1xuXHRcdGJpdFBhdHRlcm46IFwiQml0LW3DuG5zdGVyXCIsXG5cdFx0b3V0cHV0Qml0OiBcIk91dHB1dC1iaXRcIixcblx0XHRpbnB1dEJpdDogXCJJbnB1dC1iaXRcIlxuXHR9LFxuXHRyZnhTcGF0aWFsUmVmZXJlbmNlOiB7XG5cdFx0cGxhY2VIb2xkZXI6IFwiRm9yZmluIG1lZCBuw7hnbGVvcmRcIixcblx0XHRjb29yZGluYXRlU3lzdGVtOiBcIktvb3JkaW5hdHN5c3RlbVwiLFxuXHRcdGdjczogXCJHZW9ncmFmaXNrIGtvb3JkaW5hdHN5c3RlbVwiLFxuXHRcdHBjczogXCJGb3J1ZGJlcmVnbmV0IGtvb3JkaW5hdHN5c3RlbVwiLFxuXHRcdHZjczogXCJWZXJ0aWthbHQga29vcmRpbmF0c3lzdGVtXCJcblx0fVxufTtcbmNvbnN0IHJmeExpY2Vuc2VJbmZvID0gXCJEZW5uZSByYXN0ZXJmdW5rdGlvbnNza2FiZWxvbiBrYW4gYnJ1Z2VzIHRpbCBhdCBiZWhhbmRsZSBkaW5lIGJpbGxlZGVyIHZlZCBoasOmbHAgYWYgQXJjR0lTIEltYWdlIFNlcnZlci5cIjtcbmNvbnN0IHJhc3RlckZ1bmN0aW9ucyA9IHtcblx0cmZ4OiB7XG5cdFx0YUNvc0hOYW1lOiBcIkFSQ0NPU0hcIixcblx0XHRhQ29zSFNuaXA6IFwiQmVyZWduZXIgZGVuIG9tdmVuZHRlIGh5cGVyYm9sc2tlIGNvc2ludXMgZm9yIGNlbGxlciBpIGVuIHJhc3Rlci5cIixcblx0XHRhQ29zSERlc2M6IFwiRnVua3Rpb25lbiBiZXJlZ25lciBkZW4gb212ZW5kdGUgaHlwZXJib2xza2UgY29zaW51cyBmb3IgcGl4ZWxzIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGFDb3NOYW1lOiBcIkFSQ0NPU1wiLFxuXHRcdGFDb3NTbmlwOiBcIkJlcmVnbmVyIGRlbiBvbXZlbmR0ZSBjb3NpbnVzIGZvciBwaXhlbHMgaSBlbiByYXN0ZXIuXCIsXG5cdFx0YUNvc0Rlc2M6IFwiRGVubmUgcmFzdGVyZnVua3Rpb24gYmVyZWduZXIgZGVuIG9tdmVuZHRlIGNvc2ludXMgZm9yIGNlbGxlcm5lIGkgZW4gcmFzdGVyLiBJbmRlbiBmb3IgbWF0ZW1hdGlra2VuIGhhciBhbGxlIHRyaWdvbm9tZXRyaXNrZSBmdW5rdGlvbmVyIGV0IGRlZmluZXJldCBvbXLDpWRlIG1lZCBneWxkaWdlIGlucHV0dsOmcmRpZXIsIGthbGRldCBkb23Dpm5ldC4gT3V0cHV0dsOmcmRpZXJuZSBmcmEgZW5odmVyIGZ1bmt0aW9uIGhhciBvZ3PDpSBldCBkZWZpbmVyZXQgb21yw6VkZS4gRm9yIGRldHRlIHbDpnJrdMO4aiBlciBkb23Dpm5ldCBbLTEsIDFdLCBvZyBvbXLDpWRldCBlciBbMCwgcGldLlwiLFxuXHRcdGFTaW5ITmFtZTogXCJBUkNTSU5IXCIsXG5cdFx0YVNpbkhTbmlwOiBcIkJlcmVnbmVyIGRlbiBvbXZlbmR0ZSBoeXBlcmJvbHNrZSBzaW51cyBmb3IgY2VsbGVyIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGFTaW5IRGVzYzogXCJGdW5rdGlvbmVuIGJlcmVnbmVyIGRlbiBvbXZlbmR0ZSBoeXBlcmJvbHNrZSBzaW51cyBmb3IgcGl4ZWxzIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGFTaW5OYW1lOiBcIkFSQ1NJTlwiLFxuXHRcdGFTaW5TbmlwOiBcIkJlcmVnbmVyIGRlbiBvbXZlbmR0ZSBzaW51cyBmb3IgY2VsbGVyIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGFTaW5EZXNjOiBcIkZ1bmt0aW9uZW4gYmVyZWduZXIgZGVuIG9tdmVuZHRlIHNpbnVzIGZvciBwaXhlbHMgaSBlbiByYXN0ZXIuXCIsXG5cdFx0YVRhbjJOYW1lOiBcIkFSQ1RBTjJcIixcblx0XHRhVGFuMlNuaXA6IFwiQmVyZWduZXIgZGVuIG9tdmVuZHRlIHRhbmdlbnMgKGJhc2VyZXQgcMOlIHgseSkgZm9yIGNlbGxlciBpIGVuIHJhc3Rlci5cIixcblx0XHRhVGFuMkRlc2M6IFwiRnVua3Rpb25lbiBiZXJlZ25lciBkZW4gb212ZW5kdGUgdGFuZ2VucyAoYmFzZXJldCBww6UgeCx5KSBmb3IgcGl4ZWxzIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGFUYW5ITmFtZTogXCJBUkNUQU5IXCIsXG5cdFx0YVRhbkhTbmlwOiBcIkJlcmVnbmVyIGRlbiBvbXZlbmR0ZSBoeXBlcmJvbHNrZSB0YW5nZW5zIGZvciBjZWxsZXIgaSBlbiByYXN0ZXIuXCIsXG5cdFx0YVRhbkhEZXNjOiBcIkZ1bmt0aW9uZW4gYmVyZWduZXIgZGVuIG9tdmVuZHRlIGh5cGVyYm9sc2tlIHRhbmdlbnMgZm9yIHBpeGVscyBpIGVuIHJhc3Rlci5cIixcblx0XHRhVGFuTmFtZTogXCJBUkNUQU5cIixcblx0XHRhVGFuU25pcDogXCJCZXJlZ25lciBkZW4gb212ZW5kdGUgdGFuZ2VucyBmb3IgY2VsbGVyIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGFUYW5EZXNjOiBcIkZ1bmt0aW9uZW4gYmVyZWduZXIgZGVuIG9tdmVuZHRlIHRhbmdlbnMgZm9yIHBpeGVscyBpIGVuIHJhc3Rlci5cIixcblx0XHRhYnNOYW1lOiBcIkFCU1wiLFxuXHRcdGFic1NuaXA6IFwiQmVyZWduZXIgZGVuIGFic29sdXR0ZSB2w6ZyZGkgZm9yIGNlbGxlcm5lIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGFic0Rlc2M6IFwiRnVua3Rpb25lbiBBQlMgYmVyZWduZXIgZGVuIGFic29sdXR0ZSB2w6ZyZGkgZm9yIHBpeGVscyBpIGVuIHJhc3Rlci5cIixcblx0XHRyZWZsZWN0YW5jZU5hbWU6IFwiU3lubGlnIHJlZmxla3RhbnNcIixcblx0XHRyZWZsZWN0YW5jZVNuaXA6IFwiS29udmVydGVyZXIgcsOlYmlsbGVkZXIgdGlsIFRvcCBvZiBBdG1vc3BoZXJlLXbDpnJkaWVyIHZlZCBhdCB0YWdlIGhlbnN5biB0aWwgc2Vuc29yZWdlbnNrYWJlciwgc29sZW5zIHBvc2l0aW9uIG9nIG92ZXJ0YWdlbHNlc3RpZHNwdW5rdGV0LlwiLFxuXHRcdHJlZmxlY3RhbmNlRGVzYzogXCJEZW5uZSBmdW5rdGlvbiBqdXN0ZXJlciBkZSBkaWdpdGFsZSB2w6ZyZGllciBmb3IgYmlsbGVkbHlzc3R5cmtlIGZvciB2aXNzZSBzYXRlbGxpdHNlbnNvcmVyLiBKdXN0ZXJpbmdlcm5lIGVyIGJhc2VyZXQgcMOlIHNvbGjDuGpkZSwgb3B0YWdlbHNlc2RhdG8gb2cgc2Vuc29yZWdlbnNrYWJlciBvZyBpbmRzdGlsbGVyIHN0aWduaW5nIG9nIGFmdmlnZWxzZSBmb3IgaHZlcnQgYsOlbmQuIERlbm5lIGZ1bmt0aW9uIGJydWdlcyB0aWwgYXQganVzdGVyZSByZWZsZWt0YW5zLCBlbGxlciBseXNzdHlya2UsIG9nIHbDpnJkaWVyIGZvciB2aXNzZSBzYXRlbGxpdGJpbGxlZGVyIGJhc2VyZXQgcMOlIHNjZW5lYmVseXNuaW5nIG9nIGluZHN0aWxsaW5nZXIgZm9yIHNlbnNvci1zdGlnbmluZy4gQmlsbGVkZXJuZSBqdXN0ZXJlcyB0aWwgZXQgdGVvcmV0aXNrIGFsbWluZGVsaWd0IGx5c2ZvcmhvbGQsIHPDpSBkZXIgYmxpdmVyIG1pbmRyZSB2YXJpYXRpb24gbWVsbGVtIHNjZW5lciBmcmEgZm9yc2tlbGxpZ2UgZGF0b2VyIG9nIGZvcnNrZWxsaWdlIHNlbnNvcmVyLiBEZXR0ZSBrYW4gdsOmcmUgbnl0dGlndCB0aWwgYmlsbGVka2xhc3NpZmljZXJpbmcsIGZhcnZlYmFsYW5jZXJpbmcgb2cgbW9zYWlrLiBEZW5uZSBmdW5rdGlvbiBrYW4ga3VuIGJydWdlcyBtZWQgYmVzdGVtdGUgYmlsbGVkZXIuIERlIGFudmVuZGVsaWdlIHNlbnNvcmVyIGVyIExhbmRzYXQgTVNTLCBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSArLCBMYW5kc2F0IDgsIElLT05PUywgUXVpY2tCaXJkLCBHZW9FeWUtMSwgUmFwaWRFeWUsIERNQ2lpLCBXb3JsZFZpZXctMSwgV29ybGRWaWV3LTIsIFNQT1QgNiBvZyBQbGVpYWRlcy48ZGl2Pjxici8+RnVua3Rpb25lbiB1ZGbDuHJlciB0byBrb3JyZWt0aW9uZXIuIERlbiBmw7hyc3RlIGVyIGJhc2VyZXQgcMOlIGluZHN0aWxsaW5nZXJuZSBmb3Igc3RpZ25pbmcuIERlIG9wcmluZGVsaWdlIGx5c3N0eXJrZXbDpnJkaWVyIGdlbnNrYWJlcyB1ZCBmcmEgYmlsbGVkdsOmcmRpZXJuZSB2ZWQgYXQgdmVuZGUgc3RpZ25pbmdzLWxpZ25pbmdlcm5lLiBEZW4gYW5kZW4ga29ycmVrdGlvbiBlciByZWxhdGVyZXQgdGlsIGZvcnNrZWxsZSBpIHNvbHZpbmtlbCBvZyBseXNzdHlya2UuIERlIG9wcmluZGVsaWdlIGx5c3N0eXJrZXbDpnJkaWVyIGp1c3RlcmVzIHRpbCBldCBhbG1pbmRlbGlndCBseXNmb3Job2xkIHZlZCBhdCBub3JtYWxpc2VyZSBzY2VuZXIsIGRlciBlciBvcHRhZ2V0IHVuZGVyIHNraWZ0ZW5kZSBseXNmb3Job2xkLiBPdXRwdXRiaWxsZWRkYXRhdHlwZW4gZXIgZ2VuZXJlbHQgZGVuIHNhbW1lIHNvbSBpbnB1dGJpbGxlZGRhdGF0eXBlbiwgbWVuIG91dHB1dHbDpnJkaWVybmUgZXIgbGF2ZXJlIGVuZCBpbnB1dHbDpnJkaWVybmUgb2cga2xpcHBlcyB0aWwgZGV0IGd5bGRpZ2UgZGF0YW9tcsOlZGUuPC9kaXY+XCIsXG5cdFx0YXJnU3RhdGlzdGljc05hbWU6IFwiQXJnU3RhdGlzdGljc1wiLFxuXHRcdGFyZ1N0YXRpc3RpY3NTbmlwOiBcIkJlcmVnbmVyIGFyZy1zdGF0aXN0aWtrZXIsIGhlcnVuZGVyIEFyZyBNYXgsIEFyZyBNaW4sIEFyZyBNZWRpYW4gb2cgVmFyaWdoZWQuXCIsXG5cdFx0YXJnU3RhdGlzdGljc0Rlc2M6IFwiRnVua3Rpb25lbiBiZXJlZ25lciBhcmctc3RhdGlzdGlra2VyLiBEZXIgZXIgZmlyZSBtZXRvZGVyIGkgQXJnU3RhdGlzdGljcy1mdW5rdGlvbmVuOiBBcmdNYXgsIEFyZ01pbiwgQXJnTWVkaWFuIG9nIFZhcmlnaGVkLlwiLFxuXHRcdGFyaXRobWV0aWNOYW1lOiBcIkFyaXRtZXRpc2tcIixcblx0XHRhcml0aG1ldGljU25pcDogXCJVZGbDuHJlciBlbiBhcml0bWV0aXNrIG9wZXJhdGlvbiBtZWxsZW0gdG8gcmFzdGVyIGVsbGVyIGVuIHJhc3RlciBvZyBlbiBza2FsYXIuXCIsXG5cdFx0YXJpdGhtZXRpY0Rlc2M6IFwiRnVua3Rpb25lbiBBcml0bWV0aXNrIHVkZsO4cmVyIGVuIGFyaXRtZXRpc2sgb3BlcmF0aW9uIG1lbGxlbSB0byByYXN0ZXIgZWxsZXIgZW4gcmFzdGVyIG9nIGVuIHNrYWxhciBvZyBvbXZlbmR0LlwiLFxuXHRcdGFzcGVjdFNsb3BlTmFtZTogXCJBc3Bla3QtaMOmbGRuaW5nXCIsXG5cdFx0YXNwZWN0U2xvcGVTbmlwOiBcIk9wcmV0dGVyIGVuIHJhc3RlciwgZGVyIHDDpSBzYW1tZSB0aWQgdmlzZXIgYXNwZWt0ZXQgKHJldG5pbmcpIG9nIGjDpmxkbmluZyAoc3RlamxoZWQpIGZvciBlbiBzYW1tZW5ow6ZuZ2VuZGUgb3ZlcmZsYWRlLCBzb20gcmVwcsOmc2VudGVyZXQgaSBlbiBkaWdpdGFsIGVsZXZhdGlvbnNtb2RlbC5cIixcblx0XHRhc3BlY3RTbG9wZURlc2M6IFwiRnVua3Rpb25lbiBBc3Bla3QtaMOmbGRuaW5nIHNrYWJlciBldCByYXN0ZXJsYWcsIGRlciBzYW10aWRpZyB2aXNlciBlbiBmbGFkZXMgYXNwZWt0IG9nIGjDpmxkbmluZy4gQXNwZWt0IGFuZ2l2ZXIgZGVuIG5lZGFkZ8OlZW5kZSBow6ZsZG5pbmcgdWQgZnJhIGRlbiBtYWtzaW1hbGUgw6ZuZHJpbmcgYWYgdsOmcmRpZW4gYWYgaHZlciBwaXhlbCBpIGZvcmhvbGQgdGlsIGRlIHRpbHN0w7hkZW5kZSBwaXhlbHMuIE1hbiBrYW4gdMOmbmtlIHDDpSBhc3Bla3Qgc29tIGVuIGjDpmxkbmluZ3NyZXRuaW5nLiBWw6ZyZGllcm5lIGkgb3V0cHV0LXJhc3RlcmVuIHZpbCB1ZGfDuHJlIGtvbXBhc3JldG5pbmdlbiBmb3IgYXNwZWt0ZXQsIHJlcHLDpnNlbnRlcmV0IGFmIGVuIGZhcnZldG9uZSAoZmFydmUpLiBTdGlnbmluZ2VuIHJlcHLDpnNlbnRlcmVyIMOmbmRyaW5nZW4gYWYgaMO4amRlbiBmb3IgaHZlciBwaXhlbCBpIGRlbiBkaWdpdGFsZSBlbGV2YXRpb25zbW9kZWwgKERFTSkuIEjDpmxkbmluZ2VuIHJlcHLDpnNlbnRlcmVyIG92ZXJmbGFkZW5zIHN0ZWpsaGVkIG9nIGVyIHN5bWJvbGlzZXJldCBpIHRyZSBrbGFzc2VyLCBkZXIgdmlzZXMgdmVkIGhqw6ZscCBhZiBmYXJ2ZW3DpnRuaW5nIChseXNzdHlya2UpLjxkaXY+PGJyLz5QaXhlbHbDpnJkaWVybmUgaSBvdXRwdXRyYXN0ZXJlbiBmb3IgYXNwZWt0LWjDpmxkbmluZyBhZnNwZWpsZXIgZW4ga29tYmluYXRpb24gYWYgYXNwZWt0IG9nIGjDpmxkbmluZy4gUGl4bGVyIG1lZCB2w6ZyZGllciB1bmRlciAyMCBiZXRyYWd0ZXMgc29tIGZsYWRlIG9nIHZpc2VzIG1lZCBncsOlIGZhcnZlLiBWw6ZyZGllciBmb3IgYXNwZWt0LWjDpmxkbmluZyBww6UgMjEgb2cgZGVyb3ZlciB2aXNlcyBtZWQgZm9yc2tlbGxpZyBmYXJ2ZW3DpnRuaW5nIHNvbSBmw7hsZ2VyOiAyMSB0aWwgMzAg4oCUTGlsbGUgaMOmbGRuaW5nLCAzMSB0aWwgNDDigJRNb2RlcmF0IGjDpmxkbmluZywgNDEgb2cgZGVyb3ZlcuKAlFN0b3IgaMOmbGRuaW5nXCIsXG5cdFx0YXNwZWN0TmFtZTogXCJBc3Bla3RcIixcblx0XHRhc3BlY3RTbmlwOiBcIlZpc2VyIGh2aWxrZW4gcmV0bmluZyBlbiBwaXhlbCB2ZW5kZXIsIGh2b3IgMCBlciBub3JkIG9nIHZpbmtsZXJuZSBzdGlnZXIgbWVkIHVyZXQgdGlsIDM2MC5cIixcblx0XHRhc3BlY3REZXNjOiBcIkZ1bmt0aW9uZW4gQXNwZWt0IGFuZ2l2ZXIgZGVuIG5lZGFkZ8OlZW5kZSBow6ZsZG5pbmcgdWQgZnJhIGRlbiBtYWtzaW1hbGUgw6ZuZHJpbmcgYWYgdsOmcmRpZW4gYWYgaHZlciBjZWxsZSBpIGZvcmhvbGQgdGlsIGRlIHRpbHN0w7hkZW5kZSBjZWxsZXIuIE1hbiBrYW4gdMOmbmtlIHDDpSBhc3Bla3Qgc29tIGVuIGjDpmxkbmluZ3NyZXRuaW5nLiBWw6ZyZGllcm5lIGkgb3V0cHV0LXJhc3RlcmRhdGFlbmUgdmlsIHVkZ8O4cmUga29tcGFzcmV0bmluZ2VuIGZvciBhc3Bla3RldC48ZGl2Pjxici8+SW5wdXQgdGlsIGRlbm5lIGZ1bmt0aW9uIGVyIElucHV0cmFzdGVyLiBGdW5rdGlvbmVuIEFzcGVrdCBhbnZlbmRlcyBvZnRlIHDDpSBlbiBkaWdpdGFsIGVsZXZhdGlvbnNtb2RlbCAoREVNKS4gU29tIHN0YW5kYXJkIHZpc2VzIGFzcGVrdGV0IHNvbSBldCBncsOldG9uZWJpbGxlZGUuIER1IGthbiB0aWxmw7hqZSBGYXJ2ZWtvcnQtZnVua3Rpb25lbiBmb3IgYXQgYW5naXZlIGV0IGJlc3RlbXQgZmFydmVza2VtYSBlbGxlciBmb3IgYXQgdGlsbGFkZSwgYXQgcGVyc29uZW4sIGRlciBzZXIgbW9zYWlra2VuLCDDpm5kcmUgc3ltYm9sb2dpZW4gbWVkIGRlcmVzIGVnZXQgZmFydmVza2VtYS48L2Rpdj5cIixcblx0XHR0YWJsZU5hbWU6IFwiQXR0cmlidXR0YWJlbFwiLFxuXHRcdHRhYmxlU25pcDogXCJCcnVnZXIgZW4gdGFiZWwgdGlsIGF0IG5hdm5naXZlIG9nIHN5bWJvbGlzZXJlIHbDpnJkaWVybmUgaSBldCBkYXRhc8OmdC4gS29sb25uZXIgdGlsIHRhYmVsbGVuIGVyIGtvbW1hc2VwYXJlcmVkZTogUGl4ZWxWYWx1ZSwgQXR0cmlidXRlTmFtZSwgUmVkVmFsdWUsIEdyZWVuVmFsdWUsIEJsdWVWYWx1ZS5cIixcblx0XHR0YWJsZURlc2M6IFwiRnVua3Rpb25lbiBBdHRyaWJ1dHRhYmVsIGdpdmVyIG11bGlnaGVkIGZvciBhdCBkZWZpbmVyZSBldCBhdHRyaWJ1dHRhYmVsIGZvciBhdCBzeW1ib2xpc2VyZSBldCBlbmtlbHRiw6VuZHMgbW9zYWlrZGF0YXPDpnQgZWxsZXIgcmFzdGVyZGF0YXPDpnQuIDxkaXY+PGJyLz5EZXQgZXIgbnl0dGlndCwgbsOlciBkdSB2aWwgcHLDpnNlbnRlcmUgYmlsbGVkZXIsIGRlciBlciBibGV2ZXQga2xhc3NpZmljZXJldCB0aWwgYXJlYWxhbnZlbmRlbHNlLCBmLmVrcy4gc2tvdiwgdsOlZG9tcsOlZGVyLCBvcGR5cmtlZGUgYXJlYWxlciBvZyBieW9tcsOlZGVyLiBIdmlzIGRpbiB0YWJlbCBpbmRlaG9sZGVyIGZlbHRlciwgZGVyIGhlZGRlciByw7hkLCBncsO4biBvZyBibMOlLCBhbnZlbmRlcyB2w6ZyZGllcm5lIGkgZGlzc2UgZmVsdGVyIHNvbSBldCBmYXJ2ZWtvcnQsIG7DpXIgZHUgZ2VuZ2l2ZXIgYmlsbGVkZXQuPC9kaXY+XCIsXG5cdFx0YmFuZEFyaXRobWV0aWNOYW1lOiBcIkLDpW5kLWFyaXRtZXRpa1wiLFxuXHRcdGJhbmRBcml0aG1ldGljU25pcDogXCJCZXJlZ25lciBpbmRla3NlciB2ZWQgaGrDpmxwIGFmIGZvcnVkZGVmaW5lcmVkZSBmb3JtbGVyIGVsbGVyIGV0IGJydWdlcmRlZmluZXJldCB1ZHRyeWsuXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNEZXNjOiBcIkZ1bmt0aW9uZW4gQsOlbmQtYXJpdG1ldGlrIHVkZsO4cmVyIGVuIGFyaXRtZXRpc2sgb3BlcmF0aW9uIHDDpSBiw6VuZGVuZSBpIGV0IHJhc3RlcmRhdGFzw6Z0LiBEdSBrYW4gdsOmbGdlIGZvcnVkZGVmaW5lcmVkZSBhbGdvcml0bWVyLCBlbGxlciBkdSBrYW4gaW5kdGFzdGUgZGluIGVnZW4gZW5rZWx0bGluamVmb3JtZWwuIERlIHVuZGVyc3TDuHR0ZWRlIG9wZXJhdMO4cmVyIGVyIC0sICssIC8sICogb2cgdW7DpnJ0IC0uXCIsXG5cdFx0dGhyZXNob2xkTmFtZTogXCJCaW7DpnIgdMOmcnNrZWx2w6ZyZGlcIixcblx0XHR0aHJlc2hvbGRTbmlwOiBcIk9yZ2FuaXNlcmVyIGtvbnRpbnVlcmxpZ2UgZGF0YSBpIGZvcmdydW5kZW4gb2cgYmFnZ3J1bmRlbiB2ZWQgYXQgbWluaW1lcmUga292YXJpYW5zZW4gbWVsbGVtIGRlIHRvIGtsYXNzZXIuXCIsXG5cdFx0dGhyZXNob2xkRGVzYzogXCJOw6VyIGV0IHJhc3RlciBkYXRhc8OmdCBoYXIgZW4gYmltb2RhbCBkaXN0cmlidXRpb24sIHNrYWJlciBkZW5uZSBmdW5rdGlvbiBlbiBueSByYXN0ZXIsIGRlciBkZWxlciBkYXRhZW5lIGkgdG8gZm9yc2tlbGxpZ2Uga2xhc3Nlci4gRGVuIG9wcmV0dGVyIGVuIGtsYXNzZSBtZWQgbGF2IHbDpnJkaSwgZGVyIHZpc2VzIG1lZCBzb3J0ZSBwaXhlbHMsIG9nIGVuIGtsYXNzZSBtZWQgaMO4aiB2w6ZyZGksIGRlciB2aXNlcyBtZWQgaHZpZGUgcGl4ZWxzLlwiLFxuXHRcdGJpdHdpc2VBbmROYW1lOiBcIkJpdHdpc2UgT2dcIixcblx0XHRiaXR3aXNlQW5kU25pcDogXCJVZGbDuHJlciBlbiBCaXR2aXMgT2ctb3BlcmF0aW9uIHDDpSBkZSBiaW7DpnJlIHbDpnJkaWVyIGZvciB0byBpbnB1dHJhc3Rlci5cIixcblx0XHRiaXR3aXNlQW5kRGVzYzogXCJCaXR3aXNlIE9nIHVkZsO4cmVyIGVuIEJpdHdpc2UgT2ctb3BlcmF0aW9uIHDDpSBkZSBiaW7DpnJlIHbDpnJkaWVyIGZvciB0byBpbnB1dHJhc3RlclwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnROYW1lOiBcIkJpdHdpc2UgVmVuc3RyZSBza2lmdFwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnRTbmlwOiBcIlVkZsO4cmVyIGVuIEJpdHdpc2UgVmVuc3RyZSBza2lmdC1vcGVyYXRpb24gcMOlIGRlIGJpbsOmcmUgdsOmcmRpZXIgZm9yIHRvIGlucHV0cmFzdGVyLlwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnREZXNjOiBcIkJpdHdpc2UgVmVuc3RyZSBza2lmdCB1ZGbDuHJlciBlbiBCaXR3aXNlIFZlbnN0cmUgc2tpZnQtb3BlcmF0aW9uIHDDpSBkZSBiaW7DpnJlIHbDpnJkaWVyIGZvciB0byBpbnB1dHJhc3RlclwiLFxuXHRcdGJpdHdpc2VOb3ROYW1lOiBcIkJpdHdpc2UgSWtrZVwiLFxuXHRcdGJpdHdpc2VOb3RTbmlwOiBcIlVkZsO4cmVyIGVuIEJpdHdpc2UgSWtrZSAoc3VwcGxlbWVudCktb3BlcmF0aW9uIHDDpSBkZW4gYmluw6ZyZSB2w6ZyZGkgZm9yIHRvIGlucHV0cmFzdGVyLlwiLFxuXHRcdGJpdHdpc2VOb3REZXNjOiBcIkZ1bmt0aW9uZW4gdWRmw7hyZXIgZW4gQml0d2lzZSBJa2tlIChzdXBwbGVtZW50KS1vcGVyYXRpb24gcMOlIGRlbiBiaW7DpnJlIHbDpnJkaSBmb3IgZW4gaW5wdXRyYXN0ZXIuXCIsXG5cdFx0Yml0d2lzZU9yTmFtZTogXCJCaXR3aXNlIEVsbGVyXCIsXG5cdFx0Yml0d2lzZU9yU25pcDogXCJVZGbDuHJlciBlbiBCaXR3aXNlIEVsbGVyLW9wZXJhdGlvbiBww6UgZGUgYmluw6ZyZSB2w6ZyZGllciBmb3IgdG8gaW5wdXRyYXN0ZXIuXCIsXG5cdFx0Yml0d2lzZU9yRGVzYzogXCJGdW5rdGlvbmVuIHVkZsO4cmVyIGVuIEJpdHdpc2UgRWxsZXItb3BlcmF0aW9uIHDDpSBkZSBiaW7DpnJlIHbDpnJkaWVyIGZvciB0byBpbnB1dHJhc3Rlci4gXCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnROYW1lOiBcIkJpdHdpc2UgSMO4anJlIHNraWZ0XCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnRTbmlwOiBcIlVkZsO4cmVyIGVuIEJpdHdpc2UgSMO4anJlIHNraWZ0LW9wZXJhdGlvbiBww6UgZGUgYmluw6ZyZSB2w6ZyZGllciBmb3IgdG8gaW5wdXRyYXN0ZXIuXCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnREZXNjOiBcIkZ1bmt0aW9uZW4gdWRmw7hyZXIgZW4gQml0d2lzZSBIw7hqcmUgc2tpZnQtb3BlcmF0aW9uIHDDpSBkZSBiaW7DpnJlIHbDpnJkaWVyIGZvciB0byBpbnB1dHJhc3Rlci5cIixcblx0XHRiaXR3aXNlWG9yTmFtZTogXCJCaXR3aXNlIFhvclwiLFxuXHRcdGJpdHdpc2VYb3JTbmlwOiBcIlVkZsO4cmVyIGVuIEJpdHdpc2UgZVhjbHVzaXZlIE9yLW9wZXJhdGlvbiBww6UgZGUgYmluw6ZyZSB2w6ZyZGllciBmb3IgdG8gaW5wdXRyYXN0ZXIuXCIsXG5cdFx0Yml0d2lzZVhvckRlc2M6IFwiRnVua3Rpb25lbiB1ZGbDuHJlciBlbiBCaXR3aXNlIGVYY2x1c2l2ZSBPci1vcGVyYXRpb24gcMOlIGRlIGJpbsOmcmUgdsOmcmRpZXIgZm9yIHRvIGlucHV0cmFzdGVyXCIsXG5cdFx0Ym9vbGVhbkFuZE5hbWU6IFwiQm9vbGVzayBPZ1wiLFxuXHRcdGJvb2xlYW5BbmRTbmlwOiBcIlVkZsO4cmVyIGVuIEJvb2xlc2sgT2ctb3BlcmF0aW9uIHDDpSBjZWxsZXbDpnJkaWVybmUgZm9yIHRvIGlucHV0cmFzdGVyLiBIdmlzIGJlZ2dlIGlucHV0dsOmcmRpZXIgZXIgc2FuZGUgKGlra2UtbnVsKSwgZXIgb3V0cHV0dsOmcmRpZW4gMS4gSHZpcyBlbiBlbGxlciBiZWdnZSBpbnB1dHbDpnJkaWVyIGVyIGZhbHNrZSAobnVsKSwgZXIgb3V0cHV0dsOmcmRpZW4gMC5cIixcblx0XHRib29sZWFuQW5kRGVzYzogXCJGdW5rdGlvbmVuIHVkZsO4cmVyIGVuIEJvb2xlc2sgT2ctb3BlcmF0aW9uIHDDpSBwaXhlbHbDpnJkaWVybmUgZm9yIHRvIGlucHV0LiBIdmlzIGJlZ2dlIGlucHV0dsOmcmRpZXIgZXIgc2FuZGUgKGlra2UgbnVsKSwgZXIgb3V0cHV0dsOmcmRpZW4gMS4gSHZpcyBlbiBlbGxlciBiZWdnZSBpbnB1dHbDpnJkaWVyIGVyIGZhbHNrZSAobnVsKSwgZXIgb3V0cHV0dsOmcmRpZW4gMC4gXCIsXG5cdFx0Ym9vbGVhbk5vdE5hbWU6IFwiQm9vbGVzayBJa2tlXCIsXG5cdFx0Ym9vbGVhbk5vdFNuaXA6IFwiVWRmw7hyZXIgZW4gQm9vbGVzayBJa2tlIChzdXBwbGVtZW50KS1vcGVyYXRpb24gcMOlIGNlbGxldsOmcmRpZXJuZSBpIGlucHV0cmFzdGVyZW4uIEh2aXMgaW5wdXR2w6ZyZGllcm5lIGVyIHNhbmRlIChpa2tlIG51bCksIGVyIG91dHB1dHbDpnJkaWVuIDAuIEh2aXMgaW5wdXR2w6ZyZGllcm5lIGVyIGZhbHNrZSAobnVsKSwgZXIgb3V0cHV0dsOmcmRpZW4gMS5cIixcblx0XHRib29sZWFuTm90RGVzYzogXCJGdW5rdGlvbmVuIHVkZsO4cmVyIGVuIEJvb2xlc2sgSWtrZSAoc3VwcGxlbWVudCktb3BlcmF0aW9uIHDDpSBwaXhlbHbDpnJkaWVybmUgaSBpbnB1dHJhc3RlcmVuLiBIdmlzIGlucHV0dsOmcmRpZXJuZSBlciBzYW5kZSAoaWtrZSBudWwpLCBlciBvdXRwdXR2w6ZyZGllbiAwLiBIdmlzIGlucHV0dsOmcmRpZXJuZSBlciBmYWxza2UgKG51bCksIGVyIG91dHB1dHbDpnJkaWVuIDEuXCIsXG5cdFx0Ym9vbGVhbk9yTmFtZTogXCJCb29sZXNrIEVsbGVyXCIsXG5cdFx0Ym9vbGVhbk9yU25pcDogXCJVZGbDuHJlciBlbiBCb29sZXNrIEVsbGVyLW9wZXJhdGlvbiBww6UgY2VsbGV2w6ZyZGllcm5lIGZvciBkZSB0byBpbnB1dHJhc3Rlci4gSHZpcyBlbiBlbGxlciBiZWdnZSBpbnB1dHbDpnJkaWVyIGVyIHNhbmRlIChpa2tlIG51bCksIGVyIG91dHB1dHbDpnJkaWVuIDEuIEh2aXMgYmVnZ2UgaW5wdXR2w6ZyZGllciBlciBmYWxza2UgKG51bCksIGVyIG91dHB1dHbDpnJkaWVuIDAuXCIsXG5cdFx0Ym9vbGVhbk9yRGVzYzogXCJGdW5rdGlvbmVuIHVkZsO4cmVyIGVuIEJvb2xlc2sgRWxsZXItb3BlcmF0aW9uIHDDpSBjZWxsZXbDpnJkaWVybmUgZm9yIHRvIGlucHV0cmFzdGVyLiBIdmlzIGVuIGVsbGVyIGJlZ2dlIGlucHV0dsOmcmRpZXIgZXIgc2FuZGUgKGlra2UgbnVsKSwgZXIgb3V0cHV0dsOmcmRpZW4gMS4gSHZpcyBiZWdnZSBpbmRnYW5nc3bDpnJkaWVyIGVyIGZhbHNrZSAobnVsKSwgZXIgb3V0cHV0dsOmcmRpZW4gMC5cIixcblx0XHRib29sZWFuWG9yTmFtZTogXCJCb29sZXNrIFhvclwiLFxuXHRcdGJvb2xlYW5Yb3JTbmlwOiBcIlVkZsO4cmVyIGVuIEJvb2xlc2sgZVhjbHVzaXZlIE9yLW9wZXJhdGlvbiBww6UgY2VsbGV2w6ZyZGllcm5lIGZvciB0byBpbnB1dHJhc3Rlci4gSHZpcyBkZW4gZW5lIGlucHV0dsOmcmRpIGVyIHNhbmQgKGlra2UgbnVsKSwgb2cgZGVuIGFuZGVuIGVyIGZhbHNrIChudWwpLCBlciBvdXRwdXR2w6ZyZGllbiAxLiBIdmlzIGJlZ2dlIGlucHV0dsOmcmRpZXIgZXIgc2FuZGUsIGVsbGVyIGRlIGJlZ2dlIGVyIGZhbHNrZSwgZXIgb3V0cHV0dsOmcmRpZW4gMC5cIixcblx0XHRib29sZWFuWG9yRGVzYzogXCJGdW5rdGlvbmVuIHVkZsO4cmVyIGVuIEJvb2xlc2sgZVhjbHVzaXZlIE9yLW9wZXJhdGlvbiBww6UgY2VsbGV2w6ZyZGllcm5lIGZvciB0byBpbnB1dHJhc3Rlci4gSHZpcyBkZW4gZW5lIGlucHV0dsOmcmRpIGVyIHNhbmQgKGlra2UgbnVsKSwgb2cgZGVuIGFuZGVuIGVyIGZhbHNrIChudWwpLCBlciBvdXRwdXR2w6ZyZGllbiAxLiBIdmlzIGJlZ2dlIGlucHV0dsOmcmRpZXIgZXIgc2FuZGUsIGVsbGVyIGRlIGJlZ2dlIGVyIGZhbHNrZSwgZXIgb3V0cHV0dsOmcmRpZW4gMC5cIixcblx0XHRidWZmZXJlZFJhc3Rlck5hbWU6IFwiQnVmZmVyZWRcIixcblx0XHRidWZmZXJlZFJhc3RlclNuaXA6IFwiUGxhY2VyZXIgZGUobikgc2lkc3QgdGlsZ8OlZWRlIHBpeGVsYmxvayhrZSkgaSBidWZmZXJlbi5cIixcblx0XHRidWZmZXJlZFJhc3RlckRlc2M6IFwiRnVua3Rpb25lbiBCdWZmZXJlZCBiZW55dHRlcyB0aWwgYXQgb3B0aW1lcmUgeWRlbHNlbiBmb3Iga29tcGxla3NlIGZ1bmt0aW9uc2vDpmRlci4gRGVuIGdlbW1lciBvdXRwdXQgZnJhIGRlbiBkZWwgYWYgZnVua3Rpb25za8OmZGVuLCBkZXIga29tbWVyIGbDuHIgZGVuLCBpIGh1a29tbWVsc2VuLiA8ZGl2Pjxici8+SW5kc8OmdCBkZW5uZSBmdW5rdGlvbiBpIEZ1bmt0aW9uc2VkaXRvcmVuIGRlciwgaHZvciBkdSB2aWwgZ2VtbWUgb3V0cHV0dGV0LjwvZGl2PlwiLFxuXHRcdHJhc3RlckNhbGN1bGF0b3JOYW1lOiBcIlJlZ25lbWFza2luZVwiLFxuXHRcdHJhc3RlckNhbGN1bGF0b3JTbmlwOiBcIkJlcmVnbmVyIGVuIHJhc3RlciB1ZCBmcmEgZXQgcmFzdGVyYmFzZXJldCBtYXRlbWF0aXNrIHVkdHJ5ay5cIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yRGVzYzogXCJGdW5rdGlvbmVuIFJlZ25lbWFza2luZSBnaXZlciBkaWcgbXVsaWdoZWQgZm9yIGF0IG9wcmV0dGUgb2cga8O4cmUgdWR0cnlrIG9nIGluZGFyYmVqZGUgZGVtIGkgZnVua3Rpb25za8OmZGVyLlwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzTmFtZTogXCJDZWxsZXN0YXRpc3Rpa1wiLFxuXHRcdGNlbGxTdGF0aXN0aWNzU25pcDogXCJCZXJlZ25lciBzdGF0aXN0aWsgcHIuIGNlbGxlIGZyYSBmbGVyZSByYXN0ZXJlLiBEZW4gdGlsZ8OmbmdlbGlnZSBzdGF0aXN0aWsgZXIgbWFqb3JpdGV0LCBtYWtzaW11bSwgbWlkZGVsLCBtZWRpYW4sIG1pbmltdW0sIG1pbm9yaXRldCwgcGVyY2VudGlsLCBpbnRlcnZhbCwgc3RhbmRhcmRhZnZpZ2Vsc2UsIHN1bSBvZyB2YXJpYXRpb24uXCIsXG5cdFx0Y2VsbFN0YXRpc3RpY3NEZXNjOiBcIkRlbm5lIGZ1bmt0aW9uIGJlcmVnbmVyIHN0YXRpc3Rpa2tlciB1ZCBmcmEgZmxlcmUgcmFzdGVyIHBpeGVsIGZvciBwaXhlbC4gRGUgdGlsZ8OmbmdlbGlnZSBzdGF0aXN0aWt0eXBlciBlciBtYWpvcml0ZXQsIG1ha3NpbXVtLCBtaWRkZWwsIG1lZGlhbiwgbWluaW11bSwgbWlub3JpdGV0LCBpbnRlcnZhbCwgc3RhbmRhcmRhZnZpZ2Vsc2UsIHN1bSBvZyB2YXJpYXRpb24uXCIsXG5cdFx0Y2xhc3NpZnlOYW1lOiBcIktsYXNzaWZpY8OpclwiLFxuXHRcdGNsYXNzaWZ5U25pcDogXCJUaWxkZWxlciBodmVyIHBpeGVsIHRpbCBlbiBrbGFzc2UuIEluZGFyYmVqZGVyIGhqw6ZscGVkYXRhIHPDpXNvbSBldCBzZWdtZW50ZXJldCBiaWxsZWRlLlwiLFxuXHRcdGNsYXNzaWZ5RGVzYzogXCJEZW5uZSByYXN0ZXJmdW5rdGlvbiBrbGFzc2lmaWNlcmVyIGV0IHJhc3RlcmRhdGFzw6Z0IGJhc2VyZXQgcMOlIGVuIEVzcmkta2xhc3NpZmljZXJpbmdzZGVmaW5pdGlvbnNmaWwgKC5lY2QpIG9nIHJhc3RlcmRhdGFzw6Z0LWlucHV0LiBEZW4gLmVjZC1maWwsIGRlciBhbnZlbmRlcyBpIGZ1bmt0aW9uZW4gS2xhc3NpZmlrYXRpb24sIGluZGVob2xkZXIgYWxsZSBvcGx5c25pbmdlcm5lIHRpbCBldCBiZXN0ZW10IGRhdGFzw6Z0IG9nIGVuIGJlc3RlbXQga2xhc3NpZmlrYXRvciBvZyBnZW5lcmVyZXMgYWYgdWRkYW5uZWxzZXN2w6Zya3TDuGplcm5lIHRpbCBrbGFzc2lmaWthdGlvbiwgZi5la3MuIFRyYWluIFN1cHBvcnQgVmVjdG9yIE1hY2hpbmUgZWxsZXIgVHJhaW4gUmFuZG9tIFRyZWVzLlwiLFxuXHRcdGNsaXBOYW1lOiBcIktsaXBcIixcblx0XHRjbGlwU25pcDogXCJBbmdpdmVyIHVkc3Ryw6ZrbmluZ2VuIGFmIGVuIHJhc3RlciB2ZWQgaGrDpmxwIGFmIGtvb3JkaW5hdGVyIGVsbGVyIGV0IGFuZGV0IGRhdGFzw6Z0LlwiLFxuXHRcdGNsaXBEZXNjOiBcIkRlbm5lIGZ1bmt0aW9uIGtsaXBwZXIgZW4gcmFzdGVyIHZlZCBoasOmbHAgYWYgZW4gcmVrdGFuZ3Vsw6ZyIGZvcm0gaSBoZW5ob2xkIHRpbCBkZSBkZWZpbmVyZWRlIHVkc3Ryw6ZrbmluZ2VyIGVsbGVyIGtsaXBwZXIgZW4gcmFzdGVyIGkgc2FtbWUgZm9ybSBzb20gZW4gaW5wdXRwb2x5Z29uLW9iamVrdGtsYXNzZS4gRm9ybWVuLCBkZXIgZGVmaW5lcmVyIGtsaXBwZXQsIGthbiBrbGlwcGUgdWRzdHLDpmtuaW5nZW4gYWYgcmFzdGVyZW4gZWxsZXIga2xpcHBlIGV0IG9tcsOlZGUgdWQgaW5kZSBpIHJhc3RlcmVuLlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uTmFtZTogXCJLb252ZXJ0ZXJpbmcgYWYgZmFydmVtb2RlbFwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uU25pcDogXCJLb252ZXJ0ZXJlciBlbiByYXN0ZXIgZnJhIFJHQiB0aWwgSFNWIG9nIG9tdmVuZHQuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25EZXNjOiBcIkZ1bmt0aW9uZW4gS29udmVydGVyaW5nIGFmIGZhcnZlbW9kZWwga29udmVydGVyZXIgZmFydmVtb2RlbGxlbiBhZiBldCBiaWxsZWRlIGZyYSBmYXJ2ZXJ1bW1ldCBmYXJ2ZXRvbmUsIG3DpnRuaW5nIG9nIHbDpnJkaSAoSFNWKSB0aWwgcsO4ZHQsIGdyw7hudCBvZyBibMOldCAoUkdCKSBlbGxlciBvbXZlbmR0LjxkaXY+PGJyLz5EZW5uZSBmdW5rdGlvbiBrYW4gYnJ1Z2VzIGkgZXQgbW9zYWlrLWRhdGFzw6Z0LjwvZGl2PlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JOYW1lOiBcIkZhcnZla29ydCB0aWwgUkdCXCIsXG5cdFx0Y29sb3JtYXBUb1JHQlNuaXA6IFwiS29udmVydGVyZXIgZW4gZW5rZWx0YsOlbmRzcmFzdGVyIG1lZCBldCBmYXJ2ZWtvcnQgdGlsIGVuIHRyZWLDpW5kc3Jhc3RlciAocsO4ZCwgZ3LDuG4gb2cgYmzDpSkuXCIsXG5cdFx0Y29sb3JtYXBUb1JHQkRlc2M6IFwiRGVubmUgZnVua3Rpb24ga29udmVydGVyZXIgZW4gZW5rZWx0YsOlbmRzcmFzdGVyIG1lZCBldCBmYXJ2ZWtvcnQgdGlsIGVuIHRyZWLDpW5kc3Jhc3RlciAocsO4ZCwgZ3LDuG4gb2cgYmzDpSkuPGRpdj48YnIvPkRlbm5lIGZ1bmt0aW9uIGVyIG55dHRpZywgbsOlciBkdSBza2FsIG9wcmV0dGUgZW4gdHJlYsOlbmRzcmFzdGVyIHVkIGZyYSBlbiBlbmtlbHRiw6VuZHNyYXN0ZXIgbWVkIGV0IHRpbGtueXR0ZXQgZmFydmVrb3J0LiBWw6ZyZGllcm5lIGkgZmFydmVrb3J0ZXQgYnJ1Z2VzIHRpbCBhdCBvcHJldHRlIGh2ZXJ0IGVua2VsdCByw7hkdCwgZ3LDuG50IG9nIGJsw6V0IGLDpW5kLiBEZW5uZSBmdW5rdGlvbiBrYW4gYnJ1Z2VzIGkgZXQgbW9zYWlrLWRhdGFzw6Z0LjwvZGl2PlwiLFxuXHRcdGNvbG9ybWFwTmFtZTogXCJGYXJ2ZWtvcnRcIixcblx0XHRjb2xvcm1hcFNuaXA6IFwiw4ZuZHJlciBwaXhlbHbDpnJkaWVyIGZvciBhdCB2aXNlIHJhc3RlcmRhdGFlbmUgc29tIGVuIGdyw6V0b25lc2thbGEgZWxsZXIgZXQgcsO4ZHQsIGdyw7hudCBvZyBibMOldCBiaWxsZWRlIChSR0IpLCBiYXNlcmV0IHDDpSBldCBmYXJ2ZWtvcnQgZWxsZXIgZW4gZmFydmVza2FsYS5cIixcblx0XHRjb2xvcm1hcERlc2M6IFwiRnVua3Rpb25lbiBGYXJ2ZWtvcnQgZXQgcmFzdGVyZGF0YS1nZW5naXZlbHNlc3bDpnJrdMO4ai4gRGVuIG9tZGFubmVyIHBpeGVsdsOmcmRpZXJuZSwgc8OlIGRlIHZpc2VyIHJhc3RlcmRhdGFlbmUgc29tIGVudGVuIGVuIGdyw6V0b25lc2thbGEgZWxsZXIgZXQgUkdCLWZhcnZlYmlsbGVkZSBiYXNlcmV0IHDDpSBldCBmYXJ2ZXNrZW1hIGVsbGVyIGJlc3RlbXRlIGZhcnZlciBpIGVuIGZhcnZla29ydGZpbC4gRHUga2FuIGJydWdlIGV0IGZhcnZla29ydCB0aWwgYXQgcmVwcsOmc2VudGVyZSBhbmFseXNlcmVkZSBkYXRhLCBmLmVrcy4gZXQga2xhc3NpZmljZXJldCBiaWxsZWRlLCBlbGxlciBuw6VyIGRlciB2aXNlcyBldCB0b3BvZ3JhZmlzayBrb3J0IChlbGxlciBldCBpbmRla3MtZmFydmVzY2FubmV0IGJpbGxlZGUpLjxkaXY+PGJyLz5GYXJ2ZWtvcnQgaW5kZWhvbGRlciBldCBzw6Z0IHbDpnJkaWVyLCBkZXIgZXIgZm9yYnVuZGV0IG1lZCBkZSBmYXJ2ZXIsIGRlciBicnVnZXMgdGlsIGF0IHZpc2UgZW4gZW5rZWx0YsOlbmRzcmFzdGVyIG1lZCBkZSBzYW1tZSBmYXJ2ZXIuIEh2ZXIgcGl4ZWx2w6ZyZGkgZXIgZm9yYnVuZGV0IG1lZCBlbiBmYXJ2ZSwgZGVyIGVyIGRlZmluZXJldCBzb20gZXQgc8OmdCBSR0ItdsOmcmRpZXIuIEZhcnZla29ydCBrYW4gdW5kZXJzdMO4dHRlIGFsbGUgYml0ZHliZGVyLCB1bmR0YWdlbiBmbHlkZW5kZSBrb21tYS4gRGUgdW5kZXJzdMO4dHRlciBvZ3PDpSBwb3NpdGl2ZSBvZyBuZWdhdGl2ZSB2w6ZyZGllciBvZyBrYW4gaW5kZWhvbGRlIG1hbmdsZW5kZSBmYXJ2ZWtvcnR2w6ZyZGllci4gTsOlciBkZXIgdmlzZXMgZXQgZGF0YXPDpnQgbWVkIGV0IGZhcnZla29ydCBtZWQgbWFuZ2xlbmRlIHbDpnJkaWVyLCB2aXNlcyBwaXhlbHMgbWVkIGRlIG1hbmdsZW5kZSB2w6ZyZGllciBpa2tlLjwvZGl2PlwiLFxuXHRcdGNvbXBsZXhOYW1lOiBcIktvbXBsZWtzXCIsXG5cdFx0Y29tcGxleFNuaXA6IFwiVWRkcmFnZXIgc3TDuHJyZWxzZW4gZnJhIGtvbXBsZWtzZSB0YWwuXCIsXG5cdFx0Y29tcGxleERlc2M6IFwiRGVubmUgZnVua3Rpb24gYmVyZWduZXIgc3TDuHJyZWxzZW4gdWQgZnJhIGtvbXBsZWtzZSB2w6ZyZGllci48ZGl2Pjxici8+RGVubmUgZnVua3Rpb24gYnJ1Z2VzIHR5cGlzayBtZWQgUkFEQVItYmlsbGVkZXIsIGRlciBoYXIgZW4ga29tcGxla3MgZGF0YXR5cGUuIERlbiBrYW4gYnJ1Z2VzIGkgZXQgbW9zYWlrLWRhdGFzw6Z0LjwvZGl2PlwiLFxuXHRcdGNvbXBvc2l0ZUJhbmROYW1lOiBcIlNhbW1lbnNhdHRlIGLDpW5kXCIsXG5cdFx0Y29tcG9zaXRlQmFuZFNuaXA6IFwiS29tYmluZXJlciBmbGVyZSBkYXRhc8OmdCBpIGVuIGZsZXJiw6VuZHJhc3Rlci5cIixcblx0XHRjb21wb3NpdGVCYW5kRGVzYzogXCJNZWQgZnVua3Rpb25lbiBTYW1tZW5zYXR0ZSBiw6VuZCBrYW4gZHUga29tYmluZXJlIHJhc3RlciBvZyBkYW5uZSBldCBmbGVyYsOlbmRzYmlsbGVkZS5cIixcblx0XHRjb25OYW1lOiBcIkJldGluZ2V0XCIsXG5cdFx0Y29uU25pcDogXCJVZGbDuHJlciBlbiBiZXRpbmdldCBJZiwgVGhlbiwgRWxzZS1vcGVyYXRpb24uIE7DpXIgZW4gYmV0aW5nZWxzZXMtb3BlcmF0w7hyIGFudmVuZGVzLCBza2FsIGRlciBub3JtYWx0IHbDpnJlIHRvIGVsbGVyIGZsZXJlIGZ1bmt0aW9uZXIsIGRlciBlciBrw6ZkZXQgc2FtbWVuLCBodm9yIGRlbiBlbmUgZnVua3Rpb24gYW5naXZlciBrcml0ZXJpZXJuZSwgb2cgZGVuIGFuZGVuIGZ1bmt0aW9uIGVyIGJldGluZ2Vsc2VzLW9wZXJhdMO4cmVuLCBkZXIgYnJ1Z2VyIGtyaXRlcmllcm5lIG9nIGJlc3RlbW1lciwgaHZhZCBkZSBzYW5kZSBvZyBmYWxza2Ugb3V0cHV0IHNrYWwgdsOmcmUuXCIsXG5cdFx0Y29uRGVzYzogXCJGdW5rdGlvbmVuIEJldGluZ2V0IGFuZ2l2ZXIgcGl4ZWxzIGZvciBvdXRwdXRyYXN0ZXIgYmFzZXJldCBww6UgZW4gaWZlbHNlLWV2YWx1ZXJpbmcgYWYgaHZlciBpbnB1dHBpeGVsLiBEZW4gcmV0dXJuZXJlciBwaXhlbHbDpnJkaWVyIGZyYSBTYW5kLXJhc3RlcmVuLCBodmlzIGRlbiBiZXRpbmdlZGUgZXZhbHVlcmluZyBlciBzYW5kICgxKSBlbGxlciByZXR1cm5lcmVyIHBpeGVsdsOmcmRpZXJuZSBmcmEgRmFsc2stcmFzdGVyZW4sIGh2aXMgZGVuIGJldGluZ2VkZSBldmFsdWVyaW5nIGVyIGZhbHNrICgwKS4gRGV0dGUga3JpdGVyaXVtIGVyIGFuZ2l2ZXQgYWYgb3V0cHV0dGV0IGZyYSBlbiBsb2dpc2sgbWF0ZW1hdGlzayBmdW5rdGlvbiwgc29tIGVyIGlucHV0cmFzdGVyZW4uXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIktvbnN0YW50XCIsXG5cdFx0Y29uc3RhbnRTbmlwOiBcIk9wcmV0dGVyIGVuIHZpcnR1ZWwgcmFzdGVyIG1lZCBlbiBlbmtlbHQgcGl4ZWx2w6ZyZGkuXCIsXG5cdFx0Y29uc3RhbnREZXNjOiBcIkRlbm5lIGZ1bmt0aW9uIHNrYWJlciBlbiB2aXJ0dWVsIHJhc3RlciBtZWQgZW4gZW5rZWx0IHBpeGVsdsOmcmRpLCBzb20ga2FuIGJydWdlcyBpIHJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uZXIgb2cgdGlsIGF0IGJlaGFuZGxlIGV0IG1vc2Fpa2RhdGFzw6Z0LjxkaXY+PGJyLz5EZW4ga29uc3RhbnRlIHbDpnJkaSBhbnZlbmRlcyB0aWwgYWxsZSBwaXhlbHbDpnJkaWVyIGkgcmFzdGVyZW4uPC9kaXY+XCIsXG5cdFx0Y29udG91ck5hbWU6IFwiS29udHVyXCIsXG5cdFx0Y29udG91clNuaXA6IFwiT3ByZXR0ZXIga29udHVybGluamVyLlwiLFxuXHRcdGNvbnRvdXJEZXNjOiBcIkZ1bmt0aW9uZW4gZ2VuZXJlcmVyIGtvbnR1cmxpbmplciB2ZWQgYXQgZm9yYmluZGUgcHVua3RlciBtZWQgc2FtbWUgaMO4amRlIGZyYSBldCByYXN0ZXIgaMO4amRlZGF0YXPDpnQuIEtvbnR1cmVybmUgZXIgaXNvbGluamVyLCBkZXIgZXIgb3ByZXR0ZXQgc29tIHJhc3RlciBtZWQgaGVuYmxpayBww6UgdmlzdWFsaXNlcmluZy4gRnVua3Rpb25lbiBoYXIgZsO4bGdlbmRlIHN0w6Zya2UgbsO4Z2xlZnVua3Rpb25lcjogS29udHVyZXIgZ2VuZXJlcmVzIGh1cnRpZ3Qgb2cgZHluYW1pc2sgcMOlIG1lZ2V0IHN0b3JlIGRhdGFzw6Z0LCBzb20gV29ybGQgRWxldmF0aW9uOyBrb250dXJlciBrYW4gZ2xhdHRlcyB1ZCBmb3IgYXQgZ2l2ZSBldCBtZXJlIGthcnRvZ3JhZmlzayB1ZHNlZW5kZSwgc2FtdGlkaWcgbWVkIGF0IGtvbnR1cmVybmVzIG7DuGphZ3RpZ2hlZCBiZXZhcmVzOyBkeW5hbWlzayBrb250cm9sIG92ZXIga29udHVyaW50ZXJ2YWxsZXQ7IG11bGlnaGVkZXIgZm9yIG91dHB1dCBvbWZhdHRlciBrb250dXJsaW5qZXIsIGluZGVrc2tvbnR1cmVyIG9nIHVkZnlsZHRlIGtvbnR1cmVyLjxkaXY+PGJyLz5PcHJldHRlbHNlbiBhZiDigIvigItldCBrb250dXJsYWcgc29tIGV0IHJhc3RlcnByb2R1a3QgZXIgbnl0dGlndCBmb3IgZW4gYnJlZCB2aWZ0ZSBhZiBhbnZlbmRlbHNlciwgZGEga29udHVyZXJuZSBrYW4gcGxhY2VyZXMgb3ZlbiBww6UgaGluYW5kZW4gcMOlIGV0IGtvcnQgb2cgZ2l2ZSBvcGx5c25pbmdlciBvbSB0ZXJyw6ZuZXQgdWRlbiBhdCBza2p1bGUgZGUgdW5kZXJsaWdnZW5kZSBkYXRhLiBEZSBlciBueXR0aWdlIGluZGVuIGZvciB0ZWtuaWssIGxhbmRicnVnIG9nIHZhbmQuPC9kaXY+XCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzTmFtZTogXCJLb250cmFzdCBvZyBseXNzdHlya2VcIixcblx0XHRjb250cmFzdEJyaWdodG5lc3NTbmlwOiBcIkp1c3RlcmVyIGtvbnRyYXN0IG9nIGx5c3N0eXJrZSBmb3IgZW4gcmFzdGVyLlwiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc0Rlc2M6IFwiRnVua3Rpb25lbiBLb250cmFzdCBvZyBseXNzdHlya2UgZm9yYmVkcmVyIHVkc2VlbmRldCBhZiByYXN0ZXJkYXRhIHZlZCBhdCDDpm5kcmUgbHlzc3R5cmtlbiBvZyBrb250cmFzdGVuIGkgYmlsbGVkZXQuIEx5c3N0eXJrZSDDuGdlciBiaWxsZWRldHMgZ2VuZXJlbGxlIGx5c3N0eXJrZSBmLmVrcy4gYmxpdmVyIG3DuHJrZSBmYXJ2ZXIgbHlzZXJlIG9nIGx5c2UgZmFydmVyIGh2aWRlcmUsIG1lbnMgS29udHJhc3QganVzdGVyZXIgZm9yc2tlbGxlbiBtZWxsZW0gZGUgbcO4cmtlc3RlIG9nIGRlIGx5c2VzdGUgZmFydmVyLjxkaXY+PGJyLz5EZW5uZSBmdW5rdGlvbiDDpm5kcmVyIHBpeGVsdsOmcmRpZXJuZS4gRGVyZm9yIHNrYWwgZGVuIGJydWdlcywgbsOlciBkdSB2aWwgZm9yYmVkcmUgZGF0YWVuZXMgdWRzZWVuZGUsIG9nIGlra2UgaHZpcyBkdSBoYXIgdGlsIGhlbnNpZ3QgYXQgYnJ1Z2UgZGF0YWVuZSBzb20gZW4gZGVsIGFmIGVuIGFuYWx5c2UsIGRlciBrcsOmdmVyIGRlIHLDpSBwaXhlbHbDpnJkaWVyLiBEZW5uZSBmdW5rdGlvbiBlciBueXR0aWcsIG7DpXIgZHUgb2ZmZW50bGlnZ8O4ciBkYXRhZW5lIHNvbSBlbiBiaWxsZWR0amVuZXN0ZSwgc29tIGthbiBicnVnZXMgaSBhcHBsaWthdGlvbmVyLCBkZXIgaWtrZSBrYW4gw6ZuZHJlIGJpbGxlZGV0cyBrb250cmFzdCBvZyBseXNzdHlya2UsIGVsbGVyIGZvciBhdCBzaWtyZSwgYXQgZGVuIHZpc2VzIG1lZCBkaW5lIGZvcmV0cnVrbmUgaW5kc3RpbGxpbmdlci48L2Rpdj5cIixcblx0XHRjb252b2x1dGlvbk5hbWU6IFwiRm9sZG5pbmdcIixcblx0XHRjb252b2x1dGlvblNuaXA6IFwiQW52ZW5kZXIgZXQgZmlsdGVyIHRpbCBhdCBza8OmcnBlLCBzbMO4cmUsIHJlZ2lzdHJlcmUga2FudGVyLCBnbGF0dGUgdWQgZWxsZXIgb3ByZXR0ZSBlbiBncmFkaWVudCBww6UgdHbDpnJzIGFmIGVuIHJhc3Rlci5cIixcblx0XHRjb252b2x1dGlvbkRlc2M6IFwiRnVua3Rpb25lbiBGb2xkbmluZyB1ZGbDuHJlciBmaWx0cmVyaW5nIHDDpSBwaXhlbHbDpnJkaWVybmUgaSBldCBiaWxsZWRlLCBvZyBrYW4gYnJ1Z2VzIHRpbCBhdCBnw7hyZSBldCBiaWxsZWRlIHNrYXJwZXJlLCBzbMO4cmUgZXQgYmlsbGVkZSwgcmVnaXN0cmVyZSBrYW50ZXIgaW5kZW4gZm9yIGV0IGJpbGxlZGUgZWxsZXIgYW5kcmUga2VybmViYXNlcmVkZSBmb3JiZWRyaW5nZXIuIEZpbHRyZSBicnVnZXMgdGlsIGF0IGZvcmJlZHJlIGt2YWxpdGV0ZW4gYWYgcmFzdGVyYmlsbGVkZXQgdmVkIGF0IGVsaW1pbmVyZSBmYWxza2UgZGF0YSBlbGxlciBmb3JiZWRyZSBvYmpla3RlciBpIGRhdGFlbmUuIERpc3NlIGZvbGRuaW5nc2ZpbHRyZSBhbnZlbmRlcyBww6UgZW4gb3ZlcmxhcHBlbmRlIGtlcm5lIGkgYmV2w6ZnZWxzZSAodmluZHVlIGVsbGVyIHRpbHN0w7hkZW5kZSksIGYuZWtzLiAzIHggMy4gRm9sZG5pbmdzZmlsdHJlIGZ1bmdlcmVyIHZlZCBhdCBiZXJlZ25lIHBpeGVsdsOmcmRpZW4gYmFzZXJldCBww6UgdsOmZ3RuaW5nZW4gYWYgdGlsc3TDuGRlbmRlIHbDpnJkaWVyLlwiLFxuXHRcdGNvcnJpZG9yTmFtZTogXCJLb3JyaWRvclwiLFxuXHRcdGNvcnJpZG9yU25pcDogXCJCZXJlZ25lciBzdW1tZW4gYWYgYWtrdW11bGVyZWRlIG9ta29zdG5pbmdlciBmb3IgdG8gYWtrdW11bGVyZWRlIGlucHV0cmFzdGVyLlwiLFxuXHRcdGNvcnJpZG9yRGVzYzogXCJGdW5rdGlvbmVuIEtvcnJpZG9yIGJlcmVnbmVyIHN1bW1lbiBhZiBha2t1bXVsZXJlZGUgb21rb3N0bmluZ2VyIGZvciB0byBpbnB1dHJhc3RlciBtZWQgYWtrdW11bGVyZWRlIG9ta29zdG5pbmdlci4gVG8gdmlsa8OlcmxpZ2UgcmFzdGVyIGthbiBicnVnZXMgc29tIGlucHV0LCBtZW4gaHZpcyBmdW5rdGlvbmVuIHNrYWwgZ2l2ZSBldCBtZW5pbmdzZnVsZHQgcmVzdWx0YXQsIGLDuHIgZGUgdsOmcmUgdcOmbmRyZWRlIG91dHB1dHJhc3RlciBtZWQgYWtrdW11bGVyZWRlIG9ta29zdG5pbmdlci4gUsOma2tlZsO4bGdlbiBhZiBkZSB0byBpbnB1dCBlciBsaWdlZ3lsZGlnLlwiLFxuXHRcdGNvc0hOYW1lOiBcIkNvc0hcIixcblx0XHRjb3NIU25pcDogXCJCZXJlZ25lciBkZW4gaHlwZXJib2xza2UgY29zaW51cyBhZiBjZWxsZXIgaSBlbiByYXN0ZXIuXCIsXG5cdFx0Y29zSERlc2M6IFwiRnVua3Rpb25lbiBiZXJlZ25lciBkZW4gaHlwZXJib2xza2UgY29zaW51cyBmb3IgcGl4ZWxzIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGNvc05hbWU6IFwiQ29zXCIsXG5cdFx0Y29zU25pcDogXCJCZXJlZ25lciBjb3NpbnVzIGZvciBlbiBjZWxsZSBpIHJhc3Rlci5cIixcblx0XHRjb3NEZXNjOiBcIkZ1bmt0aW9uZW4gYmVyZWduZXIgY29zaW51cyBmb3IgcGl4ZWxzIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uTmFtZTogXCJPbWtvc3RuaW5nc2ZvcmRlbGluZ1wiLFxuXHRcdGNvc3RBbGxvY2F0aW9uU25pcDogXCJCZXJlZ25lciBmb3IgaHZlciBjZWxsZSBkZW4ga2lsZGUgbWVkIGRlIGxhdmVzdGUgb21rb3N0bmluZ2VyIGJhc2VyZXQgcMOlIGRlbiBtaW5kc3RlIGFra3VtdWxlcmVkZSBvbWtvc3RuaW5nIG92ZXIgZW4gb21rb3N0bmluZ3NvdmVyZmxhZGUuXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25EZXNjOiBcIkZ1bmt0aW9uZW4gT21rb3N0bmluZ3Nmb3JkZWxpbmcgYmVyZWduZXIgZm9yIGh2ZXIgY2VsbGUgZGVuIGtpbGRlIG1lZCBkZSBsYXZlc3RlIG9ta29zdG5pbmdlciBiYXNlcmV0IHDDpSBkZW4gbWluZHN0ZSBha2t1bXVsZXJlZGUgb21rb3N0bmluZyBvdmVyIGVuIG9ta29zdG5pbmdzb3ZlcmZsYWRlLlwiLFxuXHRcdGNvc3RCYWNrTGlua05hbWU6IFwiT21rb3N0bmluZyBCYWNrTGlua1wiLFxuXHRcdGNvc3RCYWNrTGlua1NuaXA6IFwiRGVmaW5lcmVyIG5hYm9jZWxsZW4sIGRlciBlciBkZW4gbsOmc3RlIGNlbGxlIHDDpSBydXRlbiBtZWQgZGUgbGF2ZXN0ZSBha2t1bXVsZXJlZGUgb21rb3N0bmluZ2VyIHRpbCBkZW4ga2lsZGUgbWVkIGRlIGxhdmVzdGUgb21rb3N0bmluZ2VyLlwiLFxuXHRcdGNvc3RCYWNrTGlua0Rlc2M6IFwiRnVua3Rpb25lbiBPbWtvc3RuaW5nIEJhY2tMaW5rIGRlZmluZXJlciBkZW4gdGlsc3TDuGRlbmRlIHbDpnJkaSwgc29tIGVyIGRlbiBuw6ZzdGUgY2VsbGUgcMOlIHJ1dGVuIG1lZCBkZSBsYXZlc3RlIGFra3VtdWxlcmVkZSBvbWtvc3RuaW5nZXIgdGlsIGRlbiBraWxkZSBtZWQgZGUgbGF2ZXN0ZSBvbWtvc3RuaW5nZXIuPGRpdj48YnIvPkJhY2tsaW5rLXJhc3RlcmVuIGluZGVob2xkZXIgdsOmcmRpZXIgZnJhIG51bCB0aWwgb3R0ZSwgc29tIGRlZmluZXJlciByZXRuaW5nZW4gZWxsZXIgaWRlbnRpZmljZXJlciBkZW4gbsOmc3RlIG5hYm9jZWxsZSAoZGVuIGVmdGVyZsO4bGdlbmRlIGNlbGxlKSBsYW5ncyBkZW4gcnV0ZSBtZWQgZGUgbGF2ZXN0ZSBha2t1bXVsZXJlZGUgb21rb3N0bmluZ2VyIGZyYSBlbiBjZWxsZSBmb3IgYXQgbsOlIGRlbiBraWxkZSBtZWQgZGUgbGF2ZXN0ZSBvbWtvc3RuaW5nZXIuIEh2aXMgc3RpZW4gc2thbCBnw6UgdGlsIGRlbiByaWd0aWdlIG5hYm9jZWxsZSwgdGlsZGVsZXMgY2VsbGVuIHbDpnJkaWVuIDEsIDIgZm9yIG5lZGVyc3RlIGjDuGpyZSBkaWFnb25hbGUgY2VsbGUgb2cgdsOmcmRpdGlsZGVsaW5nZW4gZm9ydHPDpnR0ZXMgaSByZXRuaW5nIG1lZCB1cmV0LiBWw6ZyZGllbiAwIGVyIHJlc2VydmVyZXQgdGlsIGtpbGRlY2VsbGVyLjwvZGl2PlwiLFxuXHRcdGNvc3REaXN0YW5jZU5hbWU6IFwiT21rb3N0bmluZy9hZnN0YW5kXCIsXG5cdFx0Y29zdERpc3RhbmNlU25pcDogXCJCZXJlZ25lciBhZnN0YW5kZW4gbWVkIGRlIGxhdmVzdGUgYWtrdW11bGVyZWRlIG9ta29zdG5pbmdlciBmb3IgaHZlciBjZWxsZSBmcmEgZWxsZXIgdGlsIGtpbGRlbiBtZWQgZGUgbGF2ZXN0ZSBvbWtvc3RuaW5nZXIgb3ZlciBlbiBvbWtvc3RuaW5nc292ZXJmbGFkZS5cIixcblx0XHRjb3N0RGlzdGFuY2VEZXNjOiBcIkZ1bmt0aW9uZW4gT21rb3N0bmluZy9hZnN0YW5kIGJlcmVnbmVyIGFmc3RhbmRlbiBtZWQgZGUgbGF2ZXN0ZSBha2t1bXVsZXJlZGUgb21rb3N0bmluZ2VyIGZvciBodmVyIGNlbGxlIGZyYSBlbGxlciB0aWwga2lsZGVuIG1lZCBkZSBsYXZlc3RlIG9ta29zdG5pbmdlciBvdmVyIGVuIG9ta29zdG5pbmdzb3ZlcmZsYWRlLlwiLFxuXHRcdGNvc3RQYXRoTmFtZTogXCJPbWtvc3RuaW5nL3J1dGVcIixcblx0XHRjb3N0UGF0aFNuaXA6IFwiQmVyZWduZXIgcnV0ZW4gbWVkIGRlIGxhdmVzdGUgb21rb3N0bmluZ2VyIGZyYSBlbiBraWxkZSB0aWwgZW4gZGVzdGluYXRpb24uXCIsXG5cdFx0Y29zdFBhdGhEZXNjOiBcIkRlbiBnbG9iYWxlIGZ1bmt0aW9uIE9ta29zdG5pbmcvcnV0ZSBiZXJlZ25lciBydXRlbiBtZWQgZGUgbGF2ZXN0ZSBvbWtvc3RuaW5nZXIgZnJhIGVuIGtpbGRlIHRpbCBlbiBkZXN0aW5hdGlvbi48ZGl2Pjxici8+RGVubmUgZnVua3Rpb24gcHJvZHVjZXJlciBlbiBvdXRwdXRyYXN0ZXIsIGRlciByZWdpc3RyZXJlciBkZW4gZWxsZXIgZGUgcnV0ZXIgbWVkIGRlIGxhdmVzdGUgb21rb3N0bmluZ2VyIGZyYSB1ZHZhbGd0ZSBzdGVkZXIgdGlsIGRlbiBuw6ZybWVzdGUga2lsZGVjZWxsZSwgZGVyIGVyIGRlZmluZXJldCBpbmRlbiBmb3IgZGVuIGFra3VtdWxhdGl2ZSBvbWtvc3RuaW5nc292ZXJmbGFkZSwgaHZhZCBhbmfDpXIgb21rb3N0bmluZ2VyL2Fmc3RhbmQuPC9kaXY+XCIsXG5cdFx0Y3VydmF0dXJlTmFtZTogXCJLcnVtbmluZ1wiLFxuXHRcdGN1cnZhdHVyZVNuaXA6IFwiQmVyZWduZXIga3J1bW5pbmdlbiBhZiBlbiByYXN0ZXJvdmVyZmxhZGUsIGRlciBrYW4gb21mYXR0ZSBwcm9maWwtIG9nIHBsYW5rcnVtbmluZy5cIixcblx0XHRjdXJ2YXR1cmVEZXNjOiBcIkZ1bmt0aW9uZW4gS3J1bW5pbmcgdmlzZXIgZm9ybWVuIGVsbGVyIGtydW1uaW5nZW4gYWYgaMOmbGRuaW5nZW4uIEVuIGRlbCBhZiBlbiBvdmVyZmxhZGUga2FuIHbDpnJlIGtvbmthdiBlbGxlciBrb252ZWtzLiBEZXQga2FuIG1hbiBzZSB2ZWQgaGrDpmxwIGFmIGtydW1uaW5nc3bDpnJkaWVuLiBLcnVtbmluZ2VuIGJlc3RlbW1lcyB2ZWQgYXQgYmVyZWduZSBkZW4gYW5kZW4gYWZsZWR0ZSB2w6ZyZGkgYWYgb3ZlcmZsYWRlbi48ZGl2Pjxici8+T3V0cHV0dGV0IGZyYSBmdW5rdGlvbmVuIEtydW1uaW5nIGthbiBicnVnZXMgdGlsIGF0IGJlc2tyaXZlIGRlIGZ5c2lza2UgZWdlbnNrYWJlciB2ZWQgZXQgZHLDpm5pbmdzYmFzaW4gZm9yIGF0IGZvcnN0w6UgZXJvc2lvbnMtIG9nIGFmc3Ryw7htbmluZ3Nwcm9jZXNzZXIuIEtydW1uaW5nc3bDpnJkaWVuIGthbiBicnVnZXMgdGlsIGF0IGZpbmRlIG3DuG5zdHJlIGkgam9yZGVyb3Npb24gc8OldmVsIHNvbSBmb3JkZWxpbmcgYWYgdmFuZCBww6UgbGFuZC4gUHJvZmlsa3J1bW5pbmdlbiBww6V2aXJrZXIgYWNjZWxlcmF0aW9uZW4gb2cgZGVjZWxlcmF0aW9uZW4gYWYgc3Ryw7htbWVuIG9nIHDDpXZpcmtlciBkZXJmb3IgZXJvc2lvbiBvZyBhZmxlanJpbmcuIFBsYW5mb3Jta3J1bW5pbmdlbiBww6V2aXJrZXIgc3Ryw7htbWVucyBrb252ZXJnZW5zIG9nIGRpdmVyZ2Vucy48L2Rpdj5cIixcblx0XHRkaXZpZGVOYW1lOiBcIkRpdmlkw6lyXCIsXG5cdFx0ZGl2aWRlU25pcDogXCJEZWxlciB2w6ZyZGllcm5lIGZvciB0byByYXN0ZXIgY2VsbGUgdGlsIGNlbGxlLlwiLFxuXHRcdGRpdmlkZURlc2M6IFwiRnVua3Rpb25lbiBEaXZpZMOpciBkZWxlciB2w6ZyZGllcm5lIGZvciB0byByYXN0ZXIgcGl4ZWwgZm9yIHBpeGVsLlwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsTmFtZTogXCJVZGZ5bGRuaW5nIGFmIGjDuGpkZXRvbXJ1bVwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsU25pcDogXCJPcHJldHRlciBwaXhlbHMsIGRlciBodm9yIGRlciBlciBodWxsZXIgaSBkaW5lIGjDuGpkZWRhdGEuXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxEZXNjOiBcIkZ1bmt0aW9uZW4gVWRmeWxkbmluZyBhZiBow7hqZGV0b21ydW0gYnJ1Z2VzIHRpbCBhdCBvcHJldHRlIHBpeGVscywgZGVyIGh2b3IgZGVyIGVyIGh1bGxlciBpIGRpbmUgaMO4amRlZGF0YS48ZGl2Pjxici8+RGVyIG9wc3TDpXIgdG9tcnVtLCBuw6VyIGRlciBpa2tlIGVyIG9wc2FtbGV0IHB1bmt0ZXIgaW5kZW4gZm9yIGRldCBvbXLDpWRlLCBkZXIgcmVwcsOmc2VudGVyZXMgYWYgZW4gcGl4ZWwgaSBkZW4gcmVzdWx0ZXJlbmRlIHJhc3Rlci4gVG9tcnVtIGVyIG9mdGUgZm9yw6Vyc2FnZXQgYWYgdmFuZG9tcsOlZGVyLCBrbGFzc2V0eXBldmFsZyBlbGxlciB1ZGVsdWtrZWxzZS4gVWRmeWxkbmluZyBhZiB0b21ydW0gYnJ1Z2VzIG1lc3QgdGlsIGRhbm5lbHNlIGFmIGVuIGpvcmRvdmVyZmxhZGUuPC9kaXY+XCIsXG5cdFx0ZXF1YWxUb05hbWU6IFwiTGlnIG1lZFwiLFxuXHRcdGVxdWFsVG9TbmlwOiBcIlVkZsO4cmVyIGVuIHJlbGF0aW9uc2Jhc2VyZXQgTGlnIG1lZC1vcGVyYXRpb24gcMOlIHRvIGlucHV0IGNlbGxlIGZvciBjZWxsZS4gUmV0dXJuZXJlciAxIGZvciBjZWxsZXIsIGh2b3IgZGVuIGbDuHJzdGUgcmFzdGVyIGVyIGxpZyBtZWQgZGVuIGFuZGVuIHJhc3RlciBvZyAwIGZvciBjZWxsZXIsIGh2b3IgZGVuIGlra2UgZXIgZGV0LlwiLFxuXHRcdGVxdWFsVG9EZXNjOiBcIkZ1bmt0aW9uZW4gdWRmw7hyZXIgZW4gTGlnIG1lZC1vcGVyYXRpb24gcMOlIHRvIHJhc3RlciBwaXhlbCBmb3IgcGl4ZWwuIERlbiByZXR1cm5lcmVyIHbDpnJkaWVuIDEgZm9yIHBpeGVscywgaHZvciBkZW4gZsO4cnN0ZSByYXN0ZXIgZXIgbGlnIG1lZCBkZW4gYW5kZW4gcmFzdGVyIG9nIHbDpnJkaWVuIDAgZm9yIHBpeGVscywgaHZvciBkZSBpa2tlIGVyIGxpZyBtZWQgaGluYW5kZW4uXCIsXG5cdFx0ZXVjQWxsb2NhdGlvbk5hbWU6IFwiRXVrbGlkaXNrIGFsbG9rZXJpbmdcIixcblx0XHRldWNBbGxvY2F0aW9uU25pcDogXCJCZXJlZ25lciBkZW4gbsOmcm1lc3RlIGtpbGRlIGJhc2VyZXQgcMOlIGV1a2xpZGlzayBhZnN0YW5kIGZvciBodmVyIGNlbGxlLlwiLFxuXHRcdGV1Y0FsbG9jYXRpb25EZXNjOiBcIkZ1bmt0aW9uZW4gRXVrbGlkaXNrIGFsbG9rZXJpbmcgYmVyZWduZXIgZGVuIG7DpnJtZXN0ZSBraWxkZSBiYXNlcmV0IHDDpSBldWtsaWRpc2sgYWZzdGFuZCBmb3IgaHZlciBjZWxsZS5cIixcblx0XHRldWNEaXJlY3Rpb25OYW1lOiBcIkV1a2xpZGlzayByZXRuaW5nXCIsXG5cdFx0ZXVjRGlyZWN0aW9uU25pcDogXCJCZXJlZ25lciByZXRuaW5nZW4gaSBncmFkZXIgdGlsIG7DpnJtZXN0ZSBraWxkZSBmb3IgaHZlciBjZWxsZS5cIixcblx0XHRldWNEaXJlY3Rpb25EZXNjOiBcIkZ1bmt0aW9uZW4gRXVrbGlkaXNrIHJldG5pbmcgYmVyZWduZXIgcmV0bmluZ2VuIGkgZ3JhZGVyIHRpbCBuw6ZybWVzdGUga2lsZGUgZm9yIGh2ZXIgY2VsbGUuIDxkaXY+PGJyLz5SZXRuaW5nZW4gYmVyZWduZXMgZnJhIG1pZHRlbiBhZiBodmVyIGNlbGxlIHRpbCBtaWR0ZW4gYWYg4oCL4oCLZGVuIGtpbGRlY2VsbGUsIGRlciBlciBuw6ZybWVzdCBww6UgY2VsbGVuLiBJbnRlcnZhbGxldCBhZiB2w6ZyZGllciBlciBmcmEgMCBncmFkZXIgdGlsIDM2MCBncmFkZXIsIGh2b3IgMCBlciBmb3JiZWhvbGR0IGtpbGRlY2VsbGVybmUuIFN0aWsgw7hzdCAoaMO4anJlKSBlciA5MCwgb2cgdsOmcmRpZXJuZSBzdGlnZXIgaSByZXRuaW5nIG1lZCB1cmV0ICgxODAgZXIgc3lkLCAyNzAgZXIgdmVzdCBvZyAzNjAgZXIgbm9yZCkuPC9kaXY+XCIsXG5cdFx0ZXVjRGlzdGFuY2VOYW1lOiBcIkV1a2xpZGlzayBhZnN0YW5kXCIsXG5cdFx0ZXVjRGlzdGFuY2VTbmlwOiBcIkJlcmVnbmVyIGRlbiBldWtsaWRpc2tlIGFmc3RhbmQgdGlsIGRlbiBuw6ZybWVzdGUga2lsZGUgZm9yIGh2ZXIgY2VsbGUuXCIsXG5cdFx0ZXVjRGlzdGFuY2VEZXNjOiBcIkZ1bmt0aW9uZW4gRXVrbGlkaXNrIGFmc3RhbmQgYmVyZWduZXIgZGVuIGV1a2xpZGlza2UgYWZzdGFuZCB0aWwgZGVuIG7DpnJtZXN0ZSBraWxkZSBmb3IgaHZlciBjZWxsZS5cIixcblx0XHRleHAxME5hbWU6IFwiRUtTUDEwXCIsXG5cdFx0ZXhwMTBTbmlwOiBcIkJlcmVnbmVyIGdydW5kdGFsIDEwLWVrc3BvbmVudGlhbGZ1bmt0aW9uZW4gZm9yIGNlbGxlcm5lIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGV4cDEwRGVzYzogXCJGdW5rdGlvbmVuIEVLU1AgMTAgYmVyZWduZXIgZ3J1bmR0YWwgMTAtZWtzcG9uZW50aWFsZnVua3Rpb25lbiBmb3IgcGl4ZWxzIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGV4cDJOYW1lOiBcIkVLU1AyXCIsXG5cdFx0ZXhwMlNuaXA6IFwiQmVyZWduZXIgZ3J1bmR0YWwgMi1la3Nwb25lbnRpYWxmdW5rdGlvbmVuIGZvciBjZWxsZXJuZSBpIGVuIHJhc3Rlci5cIixcblx0XHRleHAyRGVzYzogXCJEZW5uZSBmdW5rdGlvbiBiZXJlZ25lciBncnVuZHRhbCAyLWVrc3BvbmVudGlhbGZ1bmt0aW9uZW4gZm9yIHBpeGVscyBpIGVuIHJhc3Rlci5cIixcblx0XHRleHBOYW1lOiBcIkVLU1BcIixcblx0XHRleHBTbmlwOiBcIkJlcmVnbmVyIGdydW5kdGFsIGUtZWtzcG9uZW50aWFsZnVua3Rpb25lbiBmb3IgY2VsbGVybmUgaSBlbiByYXN0ZXIuXCIsXG5cdFx0ZXhwRGVzYzogXCJEZW5uZSBmdW5rdGlvbiBiZXJlZ25lciBncnVuZHRhbCBlLWVrc3BvbmVudGlhbGZ1bmt0aW9uZW4gZm9yIHBpeGVscyBpIGVuIHJhc3Rlci5cIixcblx0XHRleHRyYWN0QmFuZE5hbWU6IFwiVWR0csOmayBiw6VuZFwiLFxuXHRcdGV4dHJhY3RCYW5kU25pcDogXCJBbmdpdmVyIGh2aWxrZSBiw6VuZCwgZGVyIHNrYWwgYXJiZWpkZXMgbWVkLCBuw6VyIGR1IGJydWdlciBmbGVyYsOlbmRzZGF0YXPDpnQuXCIsXG5cdFx0ZXh0cmFjdEJhbmREZXNjOiBcIiBGdW5rdGlvbmVuIFVkdHLDpmsgYsOlbmQgZ2l2ZXIgZGlnIG11bGlnaGVkIGZvciBhdCB1ZHRyw6Zra2UgZXQgZWxsZXIgZmxlcmUgYsOlbmQgZnJhLCBlbGxlciDDpm5kcmUgcsOma2tlZsO4bGdlIHDDpSBiw6VuZCBpLCBldCByYXN0ZXJkYXRhc8OmdCBtZWQgZmxlcmUgYsOlbmQuPGRpdj48YnIvPkR1IGthbiBicnVnZSBmdW5rdGlvbmVuIFVkdHLDpmsgYsOlbmQgZsO4ciBhbmRyZSBmdW5rdGlvbmVyLCBzw6Vzb20gQXJpdG1ldGlrLCB0aWwgYXQgc3R5cmUsIGh2aWxrZSBiw6VuZCBkZXIgYnJ1Z2VzIHNvbSBpbnB1dCBpIGRlbiBuw6ZzdGUgZnVua3Rpb24uPC9kaXY+XCIsXG5cdFx0ZmlsbE5hbWU6IFwiRnlsZFwiLFxuXHRcdGZpbGxTbmlwOiBcIkZ5bGRlciBmb3JkeWJuaW5nZXIgaSBlbiBvdmVyZmxhZGVyYXN0ZXIgZm9yIGF0IGZqZXJuZSBzbcOlIHVmdWxka29tbWVuaGVkZXIgaSBkYXRhZW5lLlwiLFxuXHRcdGZpbGxEZXNjOiBcIkRlbiBnbG9iYWxlIGZ1bmt0aW9uIEZ5bGQgbG9rYWxpc2VyZXIgb2cgZnlsZGVyIGZvcmR5Ym5pbmdlciBvZyB0b3BwZSBpIGVuIGjDuGpkZW92ZXJmbGFkZXJhc3RlciBmb3IgYXQgZmplcm5lIHNtw6UgdWZ1bGRrb21tZW5oZWRlciBpIGRhdGFlbmUuIEZ1bmt0aW9uZW4gZnlsZGVyIGkgZW4gZ2VudGFnZW4gcHJvY2VzLCBpbmR0aWwgYWxsZSBmb3JkeWJuaW5nZXIgZXIgZnlsZHQgaW5kZW4gZm9yIGRlbiBhbmdpdm5lIFotZ3LDpm5zZS48ZGl2Pjxici8+TsOlciBlbiBow7hqZGVvdmVyZmxhZGUgZXIgb3ByZXR0ZXQgbWVkIE9ydG8ta29ydGzDpmduaW5nc3bDpnJrdMO4amVyIGVsbGVyIHDDpSBhbmRlbiBtw6VkZSwgZXIgZGVyIG9mdGUgc23DpSBtZW4gYmV0eWRlbGlnZSBmZWpsIGkgZm9ybSBhZiBmb3JkeWJuaW5nZXIgb2cgdG9wcGUgaSBkYXRhZW5lLiBJIGZvdG9ncmFtbWV0cmkgYmV0ZWduZXMgZm9yZHlibmluZ2VyIG9nIHRvcHBlIG9mdGUgc29tIGh1bGxlciBvZyBzcGlkc2VyLiBEYSBvdmVyZmxhZGVkYXRhIG9mdGUgYW52ZW5kZXMgdGlsIG1vZGVsbGVyaW5nLCBmLmVrcy4gaHlkcm9sb2dpc2sgbW9kZWxsZXJpbmcsIGVyIGRldCB2aWd0aWd0IGF0IHJldHRlIGRpc3NlIGZvcmR5Ym5pbmdzLSBvZyB0b3BmZWpsIHDDpSBlbiBtw6VkZSwgZGVyIGVyIGkgb3ZlcmVuc3N0ZW1tZWxzZSBtZWQgZGUgb21naXZlbmRlIGRhdGEuPC9kaXY+XCIsXG5cdFx0ZmxvYXROYW1lOiBcIkZseWRlbmRlXCIsXG5cdFx0ZmxvYXRTbmlwOiBcIktvbnZlcnRlcmVyIGh2ZXIgZW5rZWx0IGNlbGxldsOmcmRpIGZvciBlbiByYXN0ZXIgdGlsIGVuIHJlcHLDpnNlbnRhdGlvbiBtZWQgZmx5ZGVuZGUga29tbWEuXCIsXG5cdFx0ZmxvYXREZXNjOiBcIkZ1bmt0aW9uZW4gRmx5ZGVuZGUga29udmVydGVyZXIgaHZlciBlbmtlbHQgcGl4ZWx2w6ZyZGkgZm9yIGVuIHJhc3RlciB0aWwgZW4gcmVwcsOmc2VudGF0aW9uIG1lZCBmbHlkZW5kZSBrb21tYS5cIixcblx0XHRmbG93QWNjdW11bGF0aW9uTmFtZTogXCJGbG93LWFra3VtdWxlcmluZ1wiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25TbmlwOiBcIk9wcmV0dGVyIGVuIHJhc3RlciBhZiBha2t1bXVsZXJldCBmbG93IGkgaHZlciBjZWxsZS4gRW4gdsOmZ3RmYWt0b3Iga2FuIGV2ZW50dWVsdCBhbnZlbmRlcy5cIixcblx0XHRmbG93QWNjdW11bGF0aW9uRGVzYzogXCJEZW4gZ2xvYmFsZSBmdW5rdGlvbiBGbG93LWFra3VtdWxlcmluZyBza2FiZXIgZW4gcmFzdGVyIGFmIGFra3VtdWxlcmV0IGZsb3cgaSBodmVyIHBpeGVsLCBzb20gZXIgZmFzdGxhZ3QgdmVkIGF0IGFra3VtdWxlcmUgdsOmZ3RlbiBmb3IgYWxsZSBwaXhlbHMsIGRlciBzdHLDuG1tZXIgaW5kIGkgaHZlciBuZWRhZGfDpWVuZGUgcGl4ZWwuIEh2aXMgZGVyIGlra2UgZXIgYW5naXZldCBub2dlbiB2w6ZndHJhc3RlciwgYW52ZW5kZXMgZW4gdsOmZ3QgcMOlIDEgZm9yIGh2ZXIgcGl4ZWwsIG9nIHbDpnJkaWVuIGFmIHBpeGVscyBpIG91dHB1dHJhc3RlcmVuIGVyIGFudGFsbGV0IGFmIHBpeGVscywgZGVyIHN0csO4bW1lciBpbmQgaSBodmVyIHBpeGVsLjxkaXY+PGJyLz5PdXRwdXRwaXhlbHMgbWVkIGVuIGjDuGogZmxvdy1ha2t1bXVsZXJpbmcgZXIgb21yw6VkZXIgbWVkIGtvbmNlbnRyZXJldCBmbG93IG9nIGthbiBicnVnZXMgdGlsIGF0IGlkZW50aWZpY2VyZSBzdHLDuG1rYW5hbGVyLiBPdXRwdXRwaXhlbHMgbWVkIGVuIGZsb3ctYWtrdW11bGVyaW5nIHDDpSBudWwgZXIgbG9rYWxlIHRvcG9ncmFmaXNrZSBow7hqZGVwdW5rdGVyIG9nIGthbiBicnVnZXMgdGlsIGF0IGlkZW50aWZpY2VyZSBow7hqZGVyeWdnZS48L2Rpdj5cIixcblx0XHRmbG93RGlyZWN0aW9uTmFtZTogXCJGbG93cmV0bmluZ1wiLFxuXHRcdGZsb3dEaXJlY3Rpb25TbmlwOiBcIk9wcmV0dGVyIGVuIHJhc3RlciBmb3IgZmxvd3JldG5pbmcgZnJhIGh2ZXIgY2VsbGUgdGlsIGRlbnMgbmFibyBtZWQgZGVuIHN0ZWpsZXN0ZSBuZWRhZGfDpWVuZGUgaMOmbGRuaW5nLlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25EZXNjOiBcIkVuIGFmIGRlIHZpZ3RpZ2UgdGluZywgbsOlciBtYW4gc2thbCB1ZGxlZGUgaHlkcm9sb2dpc2tlIGVnZW5za2FiZXIgdmVkIGVuIG92ZXJmbGFkZSwgZXIgZXZuZW4gdGlsIGF0IGZhc3RzbMOlIGZsb3dyZXRuaW5nZW4gZnJhIGh2ZXIgcGl4ZWwgaSByYXN0ZXJlbi4gUmFzdGVyLWZ1bmt0aW9uZW4gRmxvd3JldG5pbmcgYnJ1Z2VyIGVuIG92ZXJmbGFkZSBzb20gaW5wdXQgb2cgb3ByZXR0ZXIgZW4gcmFzdGVyIGZvciBmbG93cmV0bmluZyBmcmEgaHZlciBwaXhlbCB0aWwgZGVucyBuYWJvIG1lZCBkZW4gc3Rlamxlc3RlIG5lZGFkZ8OlZW5kZSBow6ZsZG5pbmcuIGZ1bmt0aW9uZW4gRmxvd3JldG5pbmcgdW5kZXJzdMO4dHRlciB0cmUgbWV0b2RlciB0aWwgZmxvd21vZGVsbGVyaW5nOiBEOCAob3R0ZSByZXRuaW5nZXIpLCBNdWx0aS1GbG93IERpcmVjdGlvbiAoTUZEKSBvZyBELUluZmluaXR5IChESU5GKS4gXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlTmFtZTogXCJGbG93LWFmc3RhbmRcIixcblx0XHRmbG93RGlzdGFuY2VTbmlwOiBcIkJlcmVnbmVyIGRlbiBtaW5pbWFsZSBuZWRhZGfDpWVuZGUgdmFuZHJldHRlIGVsbGVyIGxvZHJldHRlIGFmc3RhbmQgZm9yIGh2ZXIgY2VsbGUgdGlsIGNlbGxlciBww6UgZW4gc3Ryw7htIGVsbGVyIGVuIGZsb2QsIHNvbSBkZSBzdHLDuG1tZXIgaS5cIixcblx0XHRmbG93RGlzdGFuY2VEZXNjOiBcIkZvciBodmVyIHBpeGVsIGJlcmVnbmVyIGZ1bmt0aW9uZW4gZGVuIGxhdmVzdGUgbmVkYWRnw6VlbmRlIHZhbmRyZXR0ZSBlbGxlciBsb2RyZXR0ZSBhZnN0YW5kIHRpbCBwaXhlbChzKSBww6UgZW4gZmxvZCBlbGxlciBzdHLDuG0sIHNvbSBkZSBzdHLDuG1tZXIgaS4gSHZpcyBlbiB2YWxnZnJpIGZsb3dyZXRuaW5nc3Jhc3RlciBmaW5kZXMsIHZpbCBuZWRsw7hic3JldG5pbmdlcm5lIHbDpnJlIGJlZ3LDpm5zZXQgdGlsIGRlbSwgZGVyIGVyIGRlZmluZXJldCBhZiByYXN0ZXJlbiBmb3IgaW5wdXRmbG93ZXRzIHJldG5pbmcuIE91dHB1dCBlciByYXN0ZXIgZm9yIGZsb3ctYWZzdGFuZC5cIixcblx0XHRmb2NhbE5hbWU6IFwiRm9rdXNlcmV0IHN0YXRpc3Rpa1wiLFxuXHRcdGZvY2FsU25pcDogXCJCZXJlZ25lciBmb2t1c2VyZXQgc3RhdGlzdGlrIGZvciBodmVyIHBpeGVsIGkgZXQgYmlsbGVkZSBiYXNlcmV0IHDDpSBldCBkZWZpbmVyZXQgZm9rdXNvbXLDpWRlLlwiLFxuXHRcdGZvY2FsRGVzYzogXCJGdW5rdGlvbmVuIEZva3VzZXJldCBzdGF0aXN0aWsgYmVyZWduZXIgZm9rdXNlcmV0IHN0YXRpc3RpayBmb3IgaHZlciBwaXhlbCBpIGV0IGJpbGxlZGUgYmFzZXJldCBww6UgZXQgYmVzdGVtdCBmb2t1c29tcsOlZGUuXCIsXG5cdFx0Z2VvbWV0cmljTmFtZTogXCJHZW9tZXRyaXNrXCIsXG5cdFx0Z2VvbWV0cmljU25pcDogXCLDmGdlciBwb3NpdGlvbnNuw7hqYWd0aWdoZWRlbiBmb3IgZXQgZGF0YXPDpnQgdmVkIGF0IHRhZ2UgaGVuc3luIHRpbCBow7hqZGUuXCIsXG5cdFx0Z2VvbWV0cmljRGVzYzogXCJGdW5rdGlvbmVuIEdlb21ldHJpc2sgZnJlbWJyaW5nZXIgZXQgb3J0by10aWxwYXNzZXQgYmlsbGVkZSBiYXNlcmV0IHDDpSBlbiBzZW5zb3JkZWZpbml0aW9uIG9nIGVuIHRlcnLDpm5tb2RlbC4gRGVuIMO4Z2VyIHBvc2l0aW9uc27DuGphZ3RpZ2hlZGVuIGZvciBldCBkYXRhc8OmdCB2ZWQgYXQgdGFnZSBoZW5zeW4gdGlsIGjDuGpkZS5cIixcblx0XHRncmF5c2NhbGVOYW1lOiBcIkdyw6V0b25lc2thbGFcIixcblx0XHRncmF5c2NhbGVTbmlwOiBcIktvbnZlcnRlcmVyIGtvbnZlcnRlcmVyIGV0IGZsZXJiw6VuZHNiaWxsZWRlIHRpbCBldCBlbmtlbHRiw6VuZHNiaWxsZWRlIGkgZ3LDpXRvbmVza2FsYS5cIixcblx0XHRncmF5c2NhbGVEZXNjOiBcIkRlbm5lIGZ1bmt0aW9uIGtvbnZlcnRlcmVyIGV0IGZsZXJiw6VuZHNiaWxsZWRlIHRpbCBldCBlbmtlbHRiw6VuZHNiaWxsZWRlIGkgZ3LDpXRvbmVza2FsYS48ZGl2Pjxici8+RGVubmUgZnVua3Rpb24gYW52ZW5kZXIgc3BlY2lmaWNlcmVkZSB2w6ZndGUgZm9yIGh2ZXJ0IGlucHV0YsOlbmQgb2cgbm9ybWFsaXNlcmVyIG91dHB1dGJpbGxlZGV0LiBWw6ZndGVuZSBhbnZlbmRlcyBvZnRlLCBmb3JkaSBub2dsZSBiw6VuZCBoYXIgc2tpZnRlbmRlIGJldHlkbmluZyBhZmjDpm5naWd0IGFmIGFudmVuZGVsc2VuLiBGb3IgZWtzZW1wZWwgaW5kZWhvbGRlciBkZXQgYmzDpSBiw6VuZCBvZnRlIG1lcmUgc3TDuGogZW5kIGFuZHJlIGLDpW5kLjwvZGl2PlwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxOYW1lOiBcIlN0w7hycmUgZW5kIGVsbGVyIGxpZyBtZWRcIixcblx0XHRncmVhdGVyVGhhbkVxdWFsU25pcDogXCJVZGbDuHJlciBlbiByZWxhdGlvbnNiYXNlcmV0IFN0w7hycmUgZW5kIGVsbGVyIGxpZyBtZWQtaGFuZGxpbmcgcMOlIHRvIGlucHV0cyBjZWxsZSBmb3IgY2VsbGUuIFJldHVybmVyZXIgMSBmb3IgY2VsbGVyLCBodm9yIGRlbiBmw7hyc3RlIHJhc3RlciBlciBzdMO4cnJlIGVuZCBlbGxlciBsaWcgbWVkIGRlbiBhbmRlbiByYXN0ZXIsIG9nIHJldHVybmVyZXIgMCwgaHZpcyBkZXQgaWtrZSBlciB0aWxmw6ZsZGV0LlwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxEZXNjOiBcIkZ1bmt0aW9uZW4gdWRmw7hyZXIgZW4gcmVsYXRpb25zYmFzZXJldCBTdMO4cnJlIGVuZCBlbGxlciBsaWcgbWVkLWhhbmRsaW5nIHDDpSB0byBpbnB1dHMgcGl4ZWwgZm9yIHBpeGVsLiBEZW4gcmV0dXJuZXJlciBlbiB2w6ZyZGkgcMOlIDEgZm9yIHBpeGVscywgaHZvciBkZW4gZsO4cnN0ZSByYXN0ZXIgZXIgc3TDuHJyZSBlbmQgZWxsZXIgbGlnIG1lZCBkZW4gYW5kZW4gcmFzdGVyLCBvZyBlbiB2w6ZyZGkgcMOlIDAgZm9yIHBpeGVscywgaHZvciBkZW4gZsO4cnN0ZSByYXN0ZXIgaWtrZSBlciBzdMO4cnJlIGVuZCBlbGxlciBsaWcgbWVkIGRlbiBhbmRlbiByYXN0ZXIuXCIsXG5cdFx0Z3JlYXRlclRoYW5OYW1lOiBcIlN0w7hycmUgZW5kXCIsXG5cdFx0Z3JlYXRlclRoYW5TbmlwOiBcIlVkZsO4cmVyIGVuIHJlbGF0aW9uc2Jhc2VyZXQgU3TDuHJyZSBlbmQtaGFuZGxpbmcgcMOlIHRvIGlucHV0cyBjZWxsZSBmb3IgY2VsbGUuIFJldHVybmVyZXIgMSBmb3IgY2VsbGVyLCBodm9yIGRlbiBmw7hyc3RlIHJhc3RlciBlciBzdMO4cnJlIGVuZCBkZW4gYW5kZW4gcmFzdGVyLCBvZyAwIGZvciBjZWxsZXIsIGh2aXMgZGV0IGlra2UgZXIgdGlsZsOmbGRldC5cIixcblx0XHRncmVhdGVyVGhhbkRlc2M6IFwiRnVua3Rpb25lbiB1ZGbDuHJlciBlbiByZWxhdGlvbnNiYXNlcmV0IFN0w7hycmUgZW5kLW9wZXJhdGlvbiBww6UgdG8gaW5wdXRzIHBpeGVsIGZvciBwaXhlbC4gUmV0dXJuZXJlciBlbiB2w6ZyZGkgcMOlIDEgZm9yIHBpeGVscywgaHZvciBkZW4gZsO4cnN0ZSByYXN0ZXIgZXIgc3TDuHJyZSBlbmQgZGVuIGFuZGVuIHJhc3Rlciwgb2cgZW4gdsOmcmRpIHDDpSAwIGZvciBwaXhlbHMsIGh2b3IgZGVuIGbDuHJzdGUgcmFzdGVyIGlra2UgZXIgc3TDuHJyZSBlbmQgZGVuIGFuZGVuIHJhc3Rlci5cIixcblx0XHRoZWF0SW5kZXhOYW1lOiBcIlZhcm1laW5kZWtzXCIsXG5cdFx0aGVhdEluZGV4U25pcDogXCJLb21iaW5lcmVyIG9tZ2l2ZW5kZSB0ZW1wZXJhdHVyIG9nIHJlbGF0aXYgZnVndGlnaGVkIG9nIHJldHVybmVyZXIgb3BsZXZldCB0ZW1wZXJhdHVyLlwiLFxuXHRcdGhlYXRJbmRleERlc2M6IFwiRGVubmUgZnVua3Rpb24gYmVyZWduZXIgZGVuIG9wbGV2ZWRlIHRlbXBlcmF0dXIgYmFzZXJldCBww6Ugb21naXZlbmRlIHRlbXBlcmF0dXIgb2cgcmVsYXRpdiBmdWd0aWdoZWQuIERlbiBvcGxldmVkZSB0ZW1wZXJhdHVyIGJlc2tyaXZlcyBvZnRlIHNvbSBodm9yIHZhcm10IGRldCBmw7hsZXMgZm9yIG1lbm5lc2tla3JvcHBlbi48ZGl2Pjxici8+RGV0dGUgaW5kZWtzIGthbiB2w6ZyZSBueXR0aWd0IHRpbCBiZXJlZ25pbmcgYWYgcmlzaWtvIGkgcmVsYXRpb24gdGlsIG1lZGljaW5za2UgcHJvYmxlbWVyIHNvbSBtdXNrZWxrcmFtcGUsIGRlaHlkcmVyaW5nLCB2YXJtZXVkbWF0dGVsc2UgZWxsZXIsIG1lcmUgYWx2b3JsaWd0LCBoZWRlc2xhZyBww6UgdmFybWUgb2cgZnVndGlnZSBkYWdlLiBOw6VyIGRlbiByZWxhdGl2ZSBmdWd0aWdoZWQgZXIgaMO4aiwgYmxpdmVyIGRldCB2YW5za2VsaWdlcmUgZm9yIGtyb3BwZW5zIHN2ZWQgYXQgZm9yZGFtcGUsIGh2aWxrZXQgZ8O4ciBkZXQgc3bDpnJlcmUgZm9yIG1lbm5lc2tlciBhdCBibGl2ZSBhZmvDuGxldCBww6UgZW4gbmF0dXJsaWcgbcOlZGUuIEtvcnQgb3ZlciB2YXJtZWd1aWRlciBlbGxlciBhZHZhcnNsZXIgZXIgb2Z0ZSBldCBwcm9kdWt0IGFmIGF0IG9ta2xhc3NpZmljZXJlIHZhcm1laW5kZWtzcmVzdWx0YXRldCB0aWwga2xhc3Nlci4gSm8gaMO4amVyZSBpbmRla3N2w6ZyZGllbiBlciwgam8gbWVyZSBzYW5kc3lubGlndCBlciBkZXQsIGF0IGRldCBibGl2ZXIgZW4gYWR2YXJzZWwgZnJlbSBmb3IgYmxvdCBlbiB2ZWpsZWRuaW5nLjwvZGl2PlwiLFxuXHRcdGhpbGxzaGFkZU5hbWU6IFwiU2t5Z2dldmlya25pbmdcIixcblx0XHRoaWxsc2hhZGVTbmlwOiBcIk9wcmV0dGVyIGVuIDNELXJlcHLDpnNlbnRhdGlvbiBhZiBvdmVyZmxhZGVuIG1lZCBzb2xlbnMgcmVsYXRpdmUgcG9zaXRpb24gdGFnZXQgaSBiZXRyYWd0bmluZyB2ZWQgc2t5Z2dldmlya25pbmcgcMOlIGJpbGxlZGV0XCIsXG5cdFx0aGlsbHNoYWRlRGVzYzogXCJGdW5rdGlvbmVuIFNreWdnZXZpcmtuaW5nIGZyZW1icmluZ2VyIGVuIDNELXJlcHLDpnNlbnRhdGlvbiBpIGdyw6V0b25lc2thbGEgYWYgdGVycsOmbm92ZXJmbGFkZW4gbWVkIHNvbGVucyByZWxhdGl2ZSBwb3NpdGlvbiwgc8OlIGRlciBrb21tZXIgc2t5Z2dldmlya25pbmcgcMOlIGJpbGxlZGV0LiA8ZGl2Pjxici8+U2t5Z2dldmlya25pbmcgZXIgZW4gdGVrbmlrIHRpbCB2aXN1YWxpc2VyaW5nIGFmIHRlcnLDpm4gcMOlIGJhZ2dydW5kIGFmIGVuIGx5c2tpbGRlIG9nIGjDpmxkbmluZyBvZyBhc3Bla3QgZm9yIGjDuGpkZW92ZXJmbGFkZW4uIERldCBlciBlbiBrdmFsaXRhdGl2IG1ldG9kZSB0aWwgdmlzdWFsaXNlcmluZyBhZiB0b3BvZ3JhZmkgb2cgZ2l2ZXIgaWtrZSBhYnNvbHV0dGUgaMO4amRldsOmcmRpZXIuIDwvZGl2PlwiLFxuXHRcdGludE5hbWU6IFwiSGVsdGFsXCIsXG5cdFx0aW50U25pcDogXCJLb252ZXJ0ZXJlciBodmVyIGNlbGxldsOmcmRpIGZvciBlbiByYXN0ZXIgdGlsIGV0IGhlbHQgdGFsIHZlZCBhZmtvcnRuaW5nLlwiLFxuXHRcdGludERlc2M6IFwiRnVua3Rpb25lbiBIZWx0YWwga29udmVydGVyZXIgaHZlciBlbmtlbHQgcGl4ZWx2w6ZyZGkgZm9yIGVuIHJhc3RlciB0aWwgZXQgaGVsdCB0YWwgdmVkIGFma29ydG5pbmcuXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmFtZTogXCJJbnRlcnBvbMOpciB1cmVnZWxtw6Zzc2lnZSBkYXRhXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhU25pcDogXCJJbnRlcnBvbGVyZXIgZnJhIHB1bmt0c2t5ZXIgZWxsZXIgdXJlZ2VsbcOmc3NpZ2UgZ2l0cmUuXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhRGVzYzogXCJOb2dsZSBuZXRDREYtIGVsbGVyIEhERi1kYXRhc8OmdCBnZW1tZXIgZGVyZXMgZ2VvcGxhY2VyaW5nIHNvbSB1cmVnZWxtw6Zzc2lndCBhZHNraWx0ZSBhcnJheWVyIGFmIHBpeGVscyBlbGxlciBwdW5rdGRhdGEuIE7DpXIgZHUgdGlsZsO4amVyIGRpc3NlIGRhdGFzw6Z0IHRpbCBldCBtb3NhaWtkYXRhc8OmdCwgdGFnZXIgZGVuIGludGVycG9sZXJlZGUgdXJlZ2VsbcOmc3NpZ2UgZGF0YWZ1bmt0aW9uIGRlIHVyZWdlbG3DpnNzaWdlIGdpdHRlcmRhdGEgb2cgb21zdHJ1a3R1cmVyZXIgZGVtLCBzw6UgaHZlciBwaXhlbCBmw6VyIHNhbW1lIHN0w7hycmVsc2Ugb2cgZXIgZmlya2FudGV0LjxkaXY+PGJyLz5Ow6VyIGR1IHRpbGbDuGplciB2YXJpYWJsZXIgZnJhIG5ldENERiBlbGxlciBIREYgdGlsIGV0IG1vc2Fpa2RhdGFzw6Z0LCB2aWwgZGV0IGF1dG9tYXRpc2sga29udHJvbGxlcmUsIG9tIGRhdGFlbmUgZXIgcmVnZWxtw6Zzc2lndCBvcHN0aWxsZXQuIEh2aXMgZGV0IGlra2UgZXIgdGlsZsOmbGRldCwga2FuIGRlbiBmdW5rdGlvbmVuIEludGVycG9sw6lyIHVyZWdlbG3DpnNzaWdlIGRhdGEgYnJ1Z2VzIHRpbCBhdCBrb252ZXJ0ZXJlIGRlIHVyZWdlbG3DpnNzaWdlIGRhdGEgdGlsIGVuIHJhc3RlciBtZWQgcmVnZWxtw6Zzc2lndCBnaXR0ZXIuIER1IGthbiDDpm5kcmUgaW50ZXJwb2F0aW9uc21ldG9kZW4gb2cgY2VsbGVzdMO4cnJlbHNlbiwgZGVyIGJydWdlcyBpIHJhc3RlcmZ1bmt0aW9uZW4gSW50ZXJwb2zDqXIgdXJlZ2VsbcOmc3NpZ2UgZGF0YS4gRm9yIHJhc3RlcmRhdGEgbWVkIHJlZ2VsbcOmc3NpZ3QgbWVsbGVtcnVtIHZpbCBkZXIgaWtrZSBibGl2ZSBhbnZlbmR0IGludGVycG9sYXRpb24sIG9nIGRhdGFlbmUgdmlsIGJsaXZlIGzDpnN0LCBzb20gZGUgZXIuPC9kaXY+XCIsXG5cdFx0aXNOdWxsTmFtZTogXCJlciBudWxcIixcblx0XHRpc051bGxTbmlwOiBcIkJlc3RlbW1lciBodmlsa2UgdsOmcmRpZXIgZnJhIGlucHV0cmFzdGVybmUsIGRlciBlciBOb0RhdGEsIGNlbGxlIGZvciBjZWxsZS4gUmV0dXJuZXJlciBlbiB2w6ZyZGkgcMOlIDEsIGh2aXMgaW5wdXR2w6ZyZGllcm5lIGVyIE5vRGF0YSwgb2cgMCBmb3IgY2VsbGVyLCBkZXIgaWtrZSBlci5cIixcblx0XHRpc051bGxEZXNjOiBcIkZ1bmt0aW9uZW4gRXIgbnVsIGJlc3RlbW1lciwgaHZpbGtlIHbDpnJkaWVyIGZyYSBpbnB1dHJhc3RlcmVuIGRlciBlciBOb0RhdGEgcGl4ZWwgZm9yIHBpeGVsLiBEZW4gcmV0dXJuZXJlciBlbiB2w6ZyZGkgcMOlIDEsIGh2aXMgaW5wdXR2w6ZyZGllbiBlciBOb0RhdGEsIG9nIGVuIHbDpnJkaSBww6UgMCBmb3IgcGl4ZWxzLCBkZXIgaWtrZSBlciBOb0RhdGEuXCIsXG5cdFx0a2VybmVsRGVuc2l0eU5hbWU6IFwiS2VybmV0w6Z0aGVkXCIsXG5cdFx0a2VybmVsRGVuc2l0eVNuaXA6IFwiQmVyZWduZXIgZW4gc3TDuHJyZWxzZSBwci4gb21yw6VkZSB1ZCBmcmEgcHVua3QtIGVsbGVyIHBvbHlsaW5qZS1lZ2Vuc2thYmVyIHZlZCBoasOmbHAgYWYgZW4ga2VybmVmdW5rdGlvbiwgc8OlIGRlbiB0aWxwYXNzZXIgdGlsIGVuIGrDpnZudCBrb25pc2sgb3ZlcmZsYWRlIHRpbCBodmVydCBwdW5rdCBlbGxlciBodmVyIHBvbHlsaW5qZS5cIixcblx0XHRrZXJuZWxEZW5zaXR5RGVzYzogXCJEZW5uZSBmdW5rdGlvbiBiZXJlZ25lciBlbiBzdMO4cnJlbHNlIHByLiBvbXLDpWRlIHVkIGZyYSBwdW5rdC0gZWxsZXIgcG9seWxpbmplLWVnZW5za2FiZXIgdmVkIGhqw6ZscCBhZiBlbiBrZXJuZWZ1bmt0aW9uLCBzw6UgZGVuIHRpbHBhc3NlciB0aWwgZW4gasOmdm50IGtvbmlzayBvdmVyZmxhZGUgdGlsIGh2ZXJ0IHB1bmt0IGVsbGVyIGh2ZXIgcG9seWxpbmplLlwiLFxuXHRcdGtleU1ldGFkYXRhTmFtZTogXCJWaWd0aWdlIG1ldGFkYXRhXCIsXG5cdFx0a2V5TWV0YWRhdGFTbmlwOiBcIlRpbHNpZGVzw6Z0dGVyIGVsbGVyIGluZHPDpnR0ZXIgdmlndGlnZSBtZXRhZGF0YSBmb3IgZW4gcmFzdGVyIGkgZW4gZnVua3Rpb25za8OmZGUuXCIsXG5cdFx0a2V5TWV0YWRhdGFEZXNjOiBcIkRlbm5lIGZ1bmt0aW9uIGfDuHIgZGV0IG11bGlndCBhdCBpbmRzw6Z0dGUgZWxsZXIgdGlsc2lkZXPDpnR0ZSB2aWd0aWdlIG1ldGFkYXRhIGZvciBlbiByYXN0ZXIuPGRpdj48YnIvPk9wbHlzbmluZ2VybmUgaSB2aWd0aWdlIG1ldGFkYXRhIGJydWdlcyB0aWwgYXQgaGrDpmxwZSBhcHBsaWthdGlvbmVuIG1lZCBiZWhhbmRsaW5nIG9nIGdlbmdpdmVsc2UsIGhlcnVuZGVyIGF0IGxldmVyZSBueXR0aWdlIG9wbHlzbmluZ2VyIHNvbSBzZW5zb3JuYXZuLCBiw6VuZG5hdm5lIGVsbGVyIHNreWTDpmtrZSwgZGVyIGVyIGZvcmJ1bmRldCBtZWQgYmlsbGVkZXQuPC9kaXY+XCIsXG5cdFx0c2hvcnRlc3RQYXRoTmFtZTogXCJSdXRlIG1lZCBkZSBsYXZlc3RlIG9ta29zdG5pbmdlclwiLFxuXHRcdHNob3J0ZXN0UGF0aFNuaXA6IFwiVWRmw7hyZXIgZW4gb21rb3N0bmluZy9hZnN0YW5kLWFuYWx5c2UgdmVkIGhqw6ZscCBhZiBraWxkZS0gb2cgZGVzdGluYXRpb25zaW5wdXQsIHNvbSBkZXJlZnRlciBicnVnZXMgdGlsIGF0IGZhc3Rsw6ZnZ2UgcnV0ZW4gbWVkIGRlIGxhdmVzdGUgb21rb3N0bmluZ2VyIGZyYSBlbiBraWxkZSB0aWwgZW4gZGVzdGluYXRpb24uXCIsXG5cdFx0c2hvcnRlc3RQYXRoRGVzYzogXCJGdW5rdGlvbmVuIFJ1dGUgbWVkIGRlIGxhdmVzdGUgb21rb3N0bmluZ2VyIGJlcmVnbmVyIHJ1dGVuIG1lZCBkZSBsYXZlc3RlIG9ta29zdG5pbmdlciBmcmEgZW4ga2lsZGUgdGlsIGVuIGRlc3RpbmF0aW9uLiBBZnN0YW5kZW4gbWVkIGRlIGxhdmVzdGUgYWtrdW11bGVyZWRlIG9ta29zdG5pbmdlciBiZXJlZ25lcyBmb3IgaHZlciBwaXhlbCBvdmVyIGVuIG9ta29zdG5pbmdzb3ZlcmZsYWRlIHRpbCBuw6ZybWVzdGUga2lsZGUuIERldCBmcmVtYnJpbmdlciBlbiBvdXRwdXRyYXN0ZXIsIGRlciByZWdpc3RyZXJlciBkZW4gZWxsZXIgZGUgcnV0ZXIgbWVkIGRlIGxhdmVzdGUgb21rb3N0bmluZ2VyIGZyYSB1ZHZhbGd0ZSBzdGVkZXIgdGlsIGRlIG7DpnJtZXN0ZSBraWxkZXBpeGVscywgZGVyIGVyIGRlZmluZXJldCBpbmRlbiBmb3IgZGVuIGFra3VtdWxhdGl2ZSBvbWtvc3RuaW5nc292ZXJmbGFkZSwgaHZhZCBhbmfDpXIgb21rb3N0bmluZ2VyL2Fmc3RhbmQuPGRpdj48YnIvPkh2ZXIgcnV0ZSBtZWQgZGUgbGF2ZXN0ZSBvbWtvc3RuaW5nZXIgdGlsZGVsZXMgZW4gdsOmcmRpLCBuw6VyIGRlbiByZWdpc3RyZXJlcyBpIHNjYW5uaW5nc3Byb2Nlc3Nlbi4gRGVuIHNpZHN0ZSBwaXhlbCBww6Uga2lsZGVyYXN0ZXJlbiBww6UgZW4gb21rb3N0bmluZ3NydXRlIGbDpXIgdsOmcmRpZW4gMS4gRGVuIGbDuHJzdGUgcnV0ZSBmw6VyIHbDpnJkaWVuIDMsIGRlbiBhbmRlbiA0IG9zdi4gTsOlciBmbGVyZSBydXRlciBmdXNpb25lcmVyIG9nIGbDuGxnZXIgZGVuIHJlc3RlcmVuZGUgYWZzdGFuZCB0aWxiYWdlIHRpbCBlbiBraWxkZSBhZCBzYW1tZSBydXRlLCB0aWxkZWxlcyBkZXQgc2VnbWVudCwgaHZvciBkZSB0byBydXRlciBmw7hsZ2VzIGFkLCB2w6ZyZGllbiAyLiBEZW4gZnVzaW9uZXJlZGUgZGVsIGFmIHJ1dGVuIGthbiBpa2tlIHRpbGRlbGVzIHbDpnJkaWVuIGZyYSBlbiBhZiBydXRlcm5lLCBkYSBkZW4gZnVzaW9uZXJlZGUgZGVsIGjDuHJlciB0aWwgYmVnZ2UgcnV0ZXIuPC9kaXY+XCIsXG5cdFx0bGVzc1RoYW5FcXVhbE5hbWU6IFwiTWluZHJlIGVuZCBlbGxlciBsaWcgbWVkXCIsXG5cdFx0bGVzc1RoYW5FcXVhbFNuaXA6IFwiVWRmw7hyZXIgZW4gcmVsYXRpb25zYmFzZXJldCBNaW5kcmUgZW5kIGVsbGVyIGxpZyBtZWQtaGFuZGxpbmcgcMOlIHRvIGlucHV0cyBjZWxsZSBmb3IgY2VsbGUuIFJldHVybmVyZXIgMSBmb3IgY2VsbGVyLCBodm9yIGRlbiBmw7hyc3RlIHJhc3RlciBlciBtaW5kcmUgZW5kIGVsbGVyIGxpZyBtZWQgZGVuIGFuZGVuIHJhc3Rlciwgb2cgcmV0dXJuZXJlciAwLCBuw6VyIGRldCBpa2tlIGVyIHRpbGbDpmxkZXQuXCIsXG5cdFx0bGVzc1RoYW5FcXVhbERlc2M6IFwiRnVua3Rpb25lbiB1ZGbDuHJlciBlbiByZWxhdGlvbnNiYXNlcmV0IE1pbmRyZSBlbmQgZWxsZXIgbGlnIG1lZC1vcGVyYXRpb24gcMOlIHRvIGlucHV0cyBwaXhlbCBmb3IgcGl4ZWwuIERlbiByZXR1cm5lcmVyIGVuIHbDpnJkaSBww6UgMSBmb3IgcGl4ZWxzLCBodm9yIGRlbiBmw7hyc3RlIHJhc3RlciBlciBtaW5kcmUgZW5kIGVsbGVyIGxpZyBtZWQgZGVuIGFuZGVuIHJhc3Rlciwgb2cgZW4gdsOmcmRpIHDDpSAwLCBodm9yIGRlbiBpa2tlIGVyIG1pbmRyZSBlbmQgZWxsZXIgbGlnIG1lZCBkZW4gYW5kZW4gcmFzdGVyLlwiLFxuXHRcdGxlc3NUaGFuTmFtZTogXCJNaW5kcmUgZW5kXCIsXG5cdFx0bGVzc1RoYW5TbmlwOiBcIlVkZsO4cmVyIGVuIHJlbGF0aW9uc2Jhc2VyZXQgTWluZHJlIGVuZC1oYW5kbGluZyBww6UgdG8gaW5wdXRzIGNlbGxlIGZvciBjZWxsZS4gUmV0dXJuZXJlciAxIGZvciBjZWxsZXIsIGh2b3IgZGVuIGbDuHJzdGUgcmFzdGVyIGVyIG1pbmRyZSBlbmQgZGVuIGFuZGVuIHJhc3RlciBvZyAwLCBodmlzIGRlbiBpa2tlIGVyLlwiLFxuXHRcdGxlc3NUaGFuRGVzYzogXCJGdW5rdGlvbmVuIHVkZsO4cmVyIGVuIHJlbGF0aW9uc2Jhc2VyZXQgTWluZHJlIGVuZC1vcGVyYXRpb24gcMOlIHRvIGlucHV0cyBwaXhlbCBmb3IgcGl4ZWwuIERlbiByZXR1cm5lcmVyIGVuIHbDpnJkaSBww6UgMSBmb3IgcGl4ZWxzLCBodm9yIGRlbiBmw7hyc3RlIHJhc3RlciBlciBtaW5kcmUgZW5kIGRlbiBhbmRlbiByYXN0ZXIsIG9nIGVuIHbDpnJkaSBww6UgMCwgaHZpcyBkZW4gaWtrZSBlciBtaW5kcmUgZW5kIGRlbiBhbmRlbiByYXN0ZXIuXCIsXG5cdFx0bG5OYW1lOiBcIkxuXCIsXG5cdFx0bG5TbmlwOiBcIkJlcmVnbmVyIGRlbiBuYXR1cmxpZ2UgbG9nYXJpdG1lIChncnVuZHRhbCBlKSBmb3IgY2VsbGVyIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGxuRGVzYzogXCJGdW5rdGlvbmVuIExuIGJlcmVnbmVyIGRlbiBuYXR1cmxpZ2UgbG9nYXJpdG1lIChncnVuZHRhbCBlKSBmb3IgaHZlciBwaXhlbCBpIGVuIHJhc3Rlci5cIixcblx0XHRsb2cxME5hbWU6IFwiTG9nMTBcIixcblx0XHRsb2cxMFNuaXA6IFwiQmVyZWduZXIgZ3J1bmR0YWwgMTAtbG9nYXJpdG1lbiBmb3IgY2VsbGVyIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGxvZzEwRGVzYzogXCJGdW5rdGlvbmVuIExvZzEwIGJlcmVnbmVyIGdydW5kdGFsIDEwLWxvZ2FyaXRtZW4gZm9yIGh2ZXIgcGl4ZWwgaSBlbiByYXN0ZXIuXCIsXG5cdFx0bG9nMk5hbWU6IFwiTG9nMlwiLFxuXHRcdGxvZzJTbmlwOiBcIkJlcmVnbmVyIGdydW5kdGFsIDItbG9nYXJpdG1lbiBmb3IgY2VsbGVyIGkgZW4gcmFzdGVyLlwiLFxuXHRcdGxvZzJEZXNjOiBcIkZ1bmt0aW9uZW4gTG9nMiBiZXJlZ25lciBncnVuZHRhbCAyLWxvZ2FyaXRtZW4gZm9yIGh2ZXIgcGl4ZWwgaSBlbiByYXN0ZXIuXCIsXG5cdFx0bG9va3VwTmFtZTogXCJTw7hnbmluZ1wiLFxuXHRcdGxvb2t1cFNuaXA6IFwiT3ByZXR0ZXIgZW4gbnkgcmFzdGVyIHZlZCBhdCBzw7hnZSBlZnRlciB2w6ZyZGllciwgZGVyIGZpbmRlcyBpIGV0IGFuZGV0IGZlbHQgaSB0YWJlbGxlbiBmb3IgaW5wdXRyYXN0ZXJlbi5cIixcblx0XHRsb29rdXBEZXNjOiBcIkZ1bmt0aW9uZW4gb3ByZXR0ZXIgZW4gbnkgcmFzdGVyIHZlZCBhdCBzbMOlIHbDpnJkaWVyIG9wLCBkZXIgZmluZGVzIGkgZXQgYW5kZXQgZmVsdCBpIHRhYmVsbGVuIGZvciBpbnB1dHJhc3RlcmVuLlwiLFxuXHRcdG1sQ2xhc3NpZnlOYW1lOiBcIk1MLWtsYXNzaWZpa2F0aW9uXCIsXG5cdFx0bWxDbGFzc2lmeVNuaXA6IFwiS2xhc3NpZmljZXJlciBiaWxsZWRlciB2ZWQgYXQgdnVyZGVyZSBodmVyIGVua2VsdCBwaXhlbC4gQmxhbmRlZGUgcGl4ZWxzIHRpbGRlbGVzIHRpbCBkZSBvYmpla3QgbWVkIGRlbiBow7hqZXN0ZSBwcm9jZW50ZGVsIGkgZGVuIHDDpWfDpmxkZW5kZSBwaXhlbC5cIixcblx0XHRtbENsYXNzaWZ5RGVzYzogXCJGdW5rdGlvbmVuIE1MLWtsYXNzaWZpa2F0aW9uIGdpdmVyIGRpZyBtdWxpZ2hlZCBmb3IgYXQgdWRmw7hyZSBlbiBvdmVydsOlZ2V0IGtsYXNzaWZpa2F0aW9uIHZlZCBoasOmbHAgYWYgYWxnb3JpdG1lbiBmb3IgZGVuIGjDuGplc3RlIHNhbmRzeW5saWdoZWRza2xhc3NpZmlrYXRpb24gcMOlIGV0IHJhc3RlciBkYXRhc8OmdCBlbGxlciBldCBtb3NhaWtkYXRhc8OmdC4gRGVubmUgZnVua3Rpb24ga3LDpnZlciBlbiBrbGFzc2lmaWthdGlvbnNzaWduYXR1cmZpbC5cIixcblx0XHRtYXNrTmFtZTogXCJNYXNrZVwiLFxuXHRcdG1hc2tTbmlwOiBcIkluZHN0aWxsZXIgdsOmcmRpZXIsIHNvbSBpa2tlIHNrYWwgdmlzZXMuXCIsXG5cdFx0bWFza0Rlc2M6IFwiRGVubmUgcmFzdGVyLWZ1bmt0aW9uIGFuZ2l2ZXIgdsOmcmRpZXIsIHNvbSBpa2tlIHNrYWwgdmlzZXMgaSBkaW4gcmFzdGVyLiBWZWQgaGrDpmxwIGFmIGZ1bmt0aW9uZW4gTWFza2UgYW5naXZlcyBlbiBlbGxlciBmbGVyZSBOb0RhdGEtdsOmcmRpZXIgZWxsZXIgZW4gcsOma2tlIGd5bGRpZ2UgcGl4ZWx2w6ZyZGllci4gXCIsXG5cdFx0bWludXNOYW1lOiBcIk1pbnVzXCIsXG5cdFx0bWludXNTbmlwOiBcIlRyw6Zra2VyIHbDpnJkaWVuIGFmIGRlbiBhbmRlbiBpbnB1dHJhc3RlciBmcmEgdsOmcmRpZW4gYWYgZGVuIGbDuHJzdGUgaW5wdXRyYXN0ZXIgY2VsbGUgZm9yIGNlbGxlLlwiLFxuXHRcdG1pbnVzRGVzYzogXCJGdW5rdGlvbmVuIE1pbnVzIHRyw6Zra2VyIHbDpnJkaWVuIGFmIGRlbiBhbmRlbiBpbnB1dHJhc3RlciBmcmEgdsOmcmRpZW4gYWYgZGVuIGbDuHJzdGUgaW5wdXRyYXN0ZXIgcGl4ZWwgZm9yIHBpeGVsLlwiLFxuXHRcdG1vZE5hbWU6IFwiTW9kXCIsXG5cdFx0bW9kU25pcDogXCJGaW5kZXIgcmVzdHbDpnJkaWVuIChtb2R1bG8pIGFmIGRlbiBmw7hyc3RlIHJhc3RlciwgbsOlciBkZW4gZGl2aWRlcmVzIG1lZCBkZW4gYW5kZW4gcmFzdGVyIGNlbGxlIGZvciBjZWxsZS5cIixcblx0XHRtb2REZXNjOiBcIkZ1bmt0aW9uZW4gTW9kIGZpbmRlciByZXN0dsOmcmRpZW4gKG1vZHVsbykgYWYgZGVuIGbDuHJzdGUgcmFzdGVyLCBuw6VyIGRlbiBkaXZpZGVyZXMgbWVkIGRlbiBhbmRlbiByYXN0ZXIgcGl4ZWwgZm9yIHBpeGVsLiBSw6Zra2Vmw7hsZ2VuIGFmIGlucHV0IGVyIHZpZ3RpZyBvZyBww6V2aXJrZXIgb3V0cHV0cmVzdWx0YXRldC5cIixcblx0XHRtb3NhaWNSYXN0ZXJzTmFtZTogXCJNb3NhaWtyYXN0ZXJcIixcblx0XHRtb3NhaWNSYXN0ZXJzU25pcDogXCJTw6Z0dGVyIGV0IHPDpnQgcmFzdGVyZGF0YXPDpnQgc2FtbWVuIGZvciBhdCBvcHJldHRlIGV0IGVua2VsdCBkYXRhc8OmdC5cIixcblx0XHRtb3NhaWNSYXN0ZXJzRGVzYzogXCJGdW5rdGlvbmVuIE1vc2Fpa3Jhc3RlciBvcHJldHRlciBldCBtb3NhaWtiaWxsZWRlIHVkIGZyYSBmbGVyZSBiaWxsZWRlci4gTsOlciBkZXIgZXIgb3ZlcmxhcG5pbmcgbWVsbGVtIGJpbGxlZGVybmUsIGVyIGRlciBmbGVyZSBtZXRvZGVyLCBkdSBrYW4gdsOmbGdlIGltZWxsZW0gZm9yIGF0IGJlc3RlbW1lLCBodmlsa2UgYmlsbGVkZXIgZGVyIHZpc2VzLlwiLFxuXHRcdG5kdmlDb2xvcml6ZWROYW1lOiBcIk5EVkktZmFydmVsw6ZnbmluZ1wiLFxuXHRcdG5kdmlDb2xvcml6ZWRTbmlwOiBcIk9wcmV0dGVyIGV0IGZsZXJiw6VuZHNkYXRhc8OmdCwgZGVyIHJlcHLDpnNlbnRlcmVyIHZlZ2V0YXRpb25zc3VuZGhlZCBiYXNlcmV0IHDDpSBmb3Jza2VsbGVuIG1lbGxlbSBkZSByw7hkZSBvZyBuw6ZyLWluZnJhcsO4ZGUgYsOlbmQuXCIsXG5cdFx0bmR2aUNvbG9yaXplZERlc2M6IFwiRnVua3Rpb25lbiBORFZJLWZhcnZlbMOmZ25pbmcgYW52ZW5kZXIgTkRWSS1mdW5rdGlvbmVuIHDDpSBpbnB1dGJpbGxlZGV0IG9nIGJydWdlciBkZXJlZnRlciBldCBmYXJ2ZWtvcnQgZWxsZXIgZW4gZmFydmVza2FsYSB0aWwgYXQgdmlzZSByZXN1bHRhdGV0LlwiLFxuXHRcdG5kdmlOYW1lOiBcIk5EVklcIixcblx0XHRuZHZpU25pcDogXCJCZXJlZ25lciBOb3JtYWxpemVkIERpZmZlcmVuY2UgVmVnZXRhdGlvbiBJbmRleCAoTkRWSSkuXCIsXG5cdFx0bmR2aURlc2M6IFwiRnVua3Rpb25lbiBORFZJIHNrYWJlciBldCBlbmtlbHRiw6VuZHNkYXRhc8OmdCwgZGVyIHJlcHLDpnNlbnRlcmVyIHZlZ2V0YXRpb25zc3VuZGhlZCBiYXNlcmV0IHDDpSBmb3Jza2VsbGVuIG1lbGxlbSBkZSByw7hkZSBvZyBuw6ZyLWluZnJhcsO4ZGUgYsOlbmQuPGRpdj48YnIvPk5EVkkgZXIgZXQgc3RhbmRhcmRpc2VyZXQgaW5kZWtzLCBkZXIgZ8O4ciBkZXQgbXVsaWd0IGF0IGdlbmVyZXJlIGV0IGJpbGxlZGUsIGRlciB2aXNlciBncsO4bmhlZCwgb2dzw6Uga2VuZHQgc29tIHJlbGF0aXYgYmlvbWFzc2UuIERldHRlIGluZGVrcyBkcmFnZXIgZm9yZGVsIGFmIGtvbnRyYXN0ZW4gbWVsbGVtIGRlIHRvIGLDpW5kcyBlZ2Vuc2thYmVyIHVkIGZyYSBldCBtdWx0aXNwZWt0cmFsdCByYXN0ZXJkYXRhc8OmdC4gQWJzb3JiZXJpbmdlbiBhZiBrbG9yb2Z5bHBpZ21lbnQgaSBkZXQgcsO4ZGUgYsOlbmQgb2cgcGxhbnRlbWF0ZXJpYWxlcm5lcyBow7hqZSByZWZsZWtzaW9uIGkgZGV0IG7DpnItaW5mcmFyw7hkZSAoTklSKSBiw6VuZC4gRWtzdHJlbXQgbGF2ZSBlbGxlciBuZWdhdGl2ZSBORFZJLXbDpnJkaWVyIHJlcHLDpnNlbnRlcmVyIG9tcsOlZGVyIHVkZW4gdmVnZXRhdGlvbiBvdmVyaG92ZWRldCwgc29tIGYuZWtzLiBza3llciwgdmFuZCBlbGxlciBzbmUuIE1lZ2V0IGxhdmUgdsOmcmRpZXIgcmVwcsOmc2VudGVyZXIgb21yw6VkZXIgbWVkIGxhdiB0aWwgaW5nZW4gdmVnZXRhdGlvbiwgc8Olc29tIGJldG9uLCBzdGVuIGVsbGVyIGJhciBqb3JkLiBNb2RlcmF0ZSB2w6ZyZGllciByZXByw6ZzZW50ZXJlciBvbXLDpWRlciBtZWQgYnVza2Ugb2cgZ3LDpnNhcmVhbGVyLiBIw7hqZSB2w6ZyZGllciByZXByw6ZzZW50ZXJlciBza292b21yw6VkZXIgb2cgZnJvZGlnIHZlZ2V0YXRpb24uPC9kaXY+XCIsXG5cdFx0bmVnYXRlTmFtZTogXCJOZWfDqXJcIixcblx0XHRuZWdhdGVTbmlwOiBcIsOGbmRyZXIgZm9ydGVnbmV0IChnYW5nZXIgbWVkIC0xKSBmb3IgY2VsbGV2w6ZyZGllcm5lIGZvciBpbnB1dHJhc3RlcmVuIGNlbGxlIGZvciBjZWxsZS5cIixcblx0XHRuZWdhdGVEZXNjOiBcIkZ1bmt0aW9uZW4gTmVnw6lyIMOmbmRyZXIgZm9ydGVnbmV0IChnYW5nZXIgbWVkIC0xKSBmb3IgcGl4ZWx2w6ZyZGllcm5lIGZvciBpbnB1dHJhc3RlcmVuIHDDpSBlbiBwaXhlbCBcIixcblx0XHRuaWJibGVOYW1lOiBcIk5pYmJsZVwiLFxuXHRcdG5pYmJsZVNuaXA6IFwiRXJzdGF0dGVyIGNlbGxlciBpIGVuIHJhc3RlciwgZGVyIHN2YXJlciB0aWwgZW4gbWFza2UsIG1lZCB2w6ZyZGllcm5lIGZvciBkZSBuw6ZybWVzdGUgbmFib2VyLlwiLFxuXHRcdG5pYmJsZURlc2M6IFwiRGVuIGdsb2JhbGUgZnVua3Rpb24gTmliYmxlIHRpbGxhZGVyLCBhdCB1ZHZhbGd0ZSBvbXLDpWRlciBhZiBlbiByYXN0ZXIgdGlsZGVsZXMgdsOmcmRpZW4gZm9yIGRlcmVzIG7DpnJtZXN0ZSBuYWJvLiBEZXR0ZSBlciBueXR0aWd0IHZlZCByZWRpZ2VyaW5nIGFmIG9tcsOlZGVyIGkgZW4gcmFzdGVyLCBodm9yIGRhdGFlbmUga2FuIHbDpnJlIGZlamxhZ3RpZ2UuXCIsXG5cdFx0bm90RXF1YWxOYW1lOiBcIklra2UgbGlnIG1lZFwiLFxuXHRcdG5vdEVxdWFsU25pcDogXCJVZGbDuHJlciBlbiByZWxhdGlvbnNiYXNlcmV0IElra2UgbGlnIG1lZC1vcGVyYXRpb24gcMOlIHRvIGlucHV0IGNlbGxlIGZvciBjZWxsZS4gUmV0dXJuZXJlciAxIGZvciBjZWxsZXIsIGh2b3IgZGVuIGbDuHJzdGUgcmFzdGVyIGlra2UgZXIgbGlnIG1lZCBkZW4gYW5kZW4gcmFzdGVyLCBvZyByZXR1cm5lcmVyIDAsIG7DpXIgZGVuIGVyIGxpZyBtZWQuXCIsXG5cdFx0bm90RXF1YWxEZXNjOiBcIkZ1bmt0aW9uZW4gdWRmw7hyZXIgZW4gcmVsYXRpb25zYmFzZXJldCBJa2tlIGxpZyBtZWQtaGFuZGxpbmcgcMOlIHRvIGlucHV0cyBwaXhlbCBmb3IgcGl4ZWwuIERlbiByZXR1cm5lcmVyIGVuIHbDpnJkaSBww6UgMSBmb3IgcGl4ZWxzLCBodm9yIGRlbiBmw7hyc3RlIHJhc3RlciBpa2tlIGVyIGxpZyBtZWQgZGVuIGFuZGVuIHJhc3Rlciwgb2cgZW4gdsOmcmRpIHDDpSAwIGZvciBwaXhlbHMsIGh2b3IgZGVuIGVyIGxpZyBtZWQgZGVuIGFuZGVuIHJhc3Rlci5cIixcblx0XHRwYW5zaGFycGVuaW5nTmFtZTogXCJQYW5zaGFycGVuXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1NuaXA6IFwiRm9yYmVkcmVyIGt1bnN0aWd0IGRlbiBzcGF0aWFsZSBvcGzDuHNuaW5nIGFmIGV0IGZsZXJiw6VuZHNiaWxsZWRlIHZlZCBhdCBmdXNpb25lcmUgZGV0IG1lZCBldCBwYW5rcm9tYXRpc2sgYmlsbGVkZSBtZWQgaMO4amVyZSBvcGzDuHNuaW5nLlwiLFxuXHRcdHBhbnNoYXJwZW5pbmdEZXNjOiBcIkZ1bmt0aW9uZW4gUGFuc2hhcnBlbiBmdXNpb25lcmVyIGV0IHBhbmtyb21hdGlzayBiaWxsZWRlIGVsbGVyIGV0IHJhc3RlcmLDpW5kIG1lZCBow7hqZXJlIG9wbMO4c25pbmcgbWVkIGVuIGZsZXJiw6VuZHNyYXN0ZXItZGF0YXPDpnQgbWVkIGxhdmVyZSBvcGzDuHNuaW5nIGZvciBhdCDDuGdlIGZsZXJiw6VuZHNiaWxsZWRldHMgc3BhdGlhbGUgb3Bsw7hzbmluZy48ZGl2Pjxici8+Rm9ybcOlbGV0IG1lZCBQYW5zaGFycGVuIGVyIGF0IHNrYWJlIGV0IGJpbGxlZGUgbWVkIGVuIGjDuGplcmUgdmlzdWVsIGt2YWxpdGV0LiBEYSB0ZWtuaWtrZXJuZSDDpm5kcmVyIGZsZXJiw6VuZHNiaWxsZWRldHMgcmFkaW9tZXRyaSBvZyBzcGVrdHJhbGUgZWdlbnNrYWJlciwgc2thbCBQYW5zaGFycGVuLWJpbGxlZGVyIGJydWdlcyBtZWQgZm9yc2lndGlnaGVkIHRpbCBhbmFseXRpc2sgZmplcm5tw6VsaW5nLjwvZGl2PlwiLFxuXHRcdHBhdGhBbGxvY2F0aW9uTmFtZTogXCJSdXRlLS9hZnN0YW5kc2FsbG9rZXJpbmdcIixcblx0XHRwYXRoQWxsb2NhdGlvblNuaXA6IFwiQmVyZWduZXIga2lsZGVuIG1lZCBkZSBsYXZlc3RlIG9ta29zdG5pbmdlciBmb3IgaHZlciBjZWxsZSBiYXNlcmV0IHDDpSBkZW4gbGF2ZXN0ZSBha2t1bXVsZXJlZGUgb21rb3N0bmluZyBvdmVyIGVuIG9ta29zdG5pbmdzb3ZlcmZsYWRlLCBodm9yIGRlciB0YWdlcyBoZW5zeW4gdGlsIG92ZXJmbGFkZWFmc3RhbmQgc2FtdCB2YW5kcmV0dGUgb2cgbG9kcmV0dGUgb21rb3N0bmluZ3NmYWt0b3Jlci5cIixcblx0XHRwYXRoQWxsb2NhdGlvbkRlc2M6IFwiRnVua3Rpb25lbiBSdXRlLS9hZnN0YW5kc2FsbG9rZXJpbmcgYmVyZWduZXIgbsOmcm1lc3RlIGtpbGRlIGZvciBodmVyIGNlbGxlIGJhc2VyZXQgcMOlIGRlbiBsYXZlc3RlIGFra3VtdWxlcmVkZSBvbWtvc3RuaW5nIG92ZXIgZW4gb21rb3N0bmluZ3NvdmVyZmxhZGUsIGh2b3IgZGVyIHRhZ2VzIGhlbnN5biB0aWwgb3ZlcmZsYWRlYWZzdGFuZCBzYW10IHZhbmRyZXR0ZSBvZyBsb2RyZXR0ZSBvbWtvc3RuaW5nc2Zha3RvcmVyLlwiLFxuXHRcdHBhdGhCYWNrTGlua05hbWU6IFwiUnV0ZS9hZnN0YW5kIEJhY2tMaW5rXCIsXG5cdFx0cGF0aEJhY2tMaW5rU25pcDogXCJEZWZpbmVyZXIgbmFib2VuLCBkZXIgZXIgZGVuIG7DpnN0ZSBjZWxsZSBww6UgZGVuIHJ1dGUgbWVkIGRlIGxhdmVzdGUgYWtrdW11bGVyZWRlIG9ta29zdG5pbmdlciB0aWwgZGVuIGtpbGRlIG1lZCBkZSBsYXZlc3RlIG9ta29zdG5pbmdlciwgaHZvciBkZXIgdGFnZXMgaGVuc3luIHRpbCBvdmVyZmxhZGVhZnN0YW5kIHNhbXQgdmFuZHJldHRlIG9nIGxvZHJldHRlIG9ta29zdG5pbmdzZmFrdG9yZXIuXCIsXG5cdFx0cGF0aEJhY2tMaW5rRGVzYzogXCJGdW5rdGlvbmVuIFJ1dGUvYWZzdGFuZCBCYWNrTGluayBpZGVudGlmaWNlcmVyIHJldG5pbmdlbiBmb3IgbmFib2VuLCBkZXIgZXIgZGVuIG7DpnN0ZSBjZWxsZSBww6UgZGVuIHJ1dGUgbWVkIGRlIGxhdmVzdGUgYWtrdW11bGVyZWRlIG9ta29zdG5pbmdlciB0aWwgbsOmcm1lc3RlIGtpbGRlLCBodm9yIGRlciB0YWdlcyBoZW5zeW4gdGlsIG92ZXJmbGFkZWFmc3RhbmQgc2FtdCB2YW5kcmV0dGUgb2cgbG9kcmV0dGUgb21rb3N0bmluZ3NmYWt0b3Jlci5cIixcblx0XHRwYXRoRGlzdGFuY2VOYW1lOiBcIlJ1dGUvYWZzdGFuZFwiLFxuXHRcdHBhdGhEaXN0YW5jZVNuaXA6IFwiQmVyZWduZXIgYWZzdGFuZGVuIG1lZCBkZSBsYXZlc3RlIGFra3VtdWxlcmVkZSBvbWtvc3RuaW5nZXIgZm9yIGh2ZXIgY2VsbGUgZnJhIGVsbGVyIHRpbCBraWxkZW4gbWVkIGRlIGxhdmVzdGUgb21rb3N0bmluZ2VyLCBodm9yIGRlciB0YWdlcyBoZW5zeW4gdGlsIG92ZXJmbGFkZWFmc3RhbmQgc2FtdCB2YW5kcmV0dGUgb2cgbG9kcmV0dGUgb21rb3N0bmluZ3NmYWt0b3Jlci5cIixcblx0XHRwYXRoRGlzdGFuY2VEZXNjOiBcIkZ1bmt0aW9uZW4gUnV0ZS9hZnN0YW5kIGJlcmVnbmVyIGFmc3RhbmRlbiBtZWQgZGUgbGF2ZXN0ZSBha2t1bXVsZXJlZGUgb21rb3N0bmluZ2VyIGZvciBodmVyIGNlbGxlIHRpbCBuw6ZybWVzdGUga2lsZGUsIGh2b3IgZGVyIHRhZ2VzIGhlbnN5biB0aWwgb3ZlcmZsYWRlYWZzdGFuZCBvZyB2YW5kcmV0dGUgb2cgbG9kcmV0dGUgb21rb3N0bmluZ3NmYWt0b3Jlci5cIixcblx0XHRwbHVzTmFtZTogXCJQbHVzXCIsXG5cdFx0cGx1c1NuaXA6IFwiTMOmZ2dlciB2w6ZyZGllcm5lIGZvciB0byByYXN0ZXIgc2FtbWVuIGNlbGxlIGZvciBjZWxsZS5cIixcblx0XHRwbHVzRGVzYzogXCJGdW5rdGlvbmVuIFBsdXMgbMOmZ2dlciB2w6ZyZGllcm5lIGZvciB0byByYXN0ZXIgc2FtbWVuIHBpeGVsIGZvciBwaXhlbC5cIixcblx0XHRwb3dlck5hbWU6IFwiUG90ZW5zXCIsXG5cdFx0cG93ZXJTbmlwOiBcIk9wbMO4ZnRlciBjZWxsZXbDpnJkaWVybmUgaSBlbiByYXN0ZXIgdGlsIHBvdGVuc2VuIGFmIGRlIHbDpnJkaWVyLCBkZXIgZmluZGVzIGkgZW4gYW5kZW4gcmFzdGVyLlwiLFxuXHRcdHBvd2VyRGVzYzogXCJGdW5rdGlvbmVuIFBvdGVucyBvcGzDuGZ0ZXIgcGl4ZWx2w6ZyZGllcm5lIGkgZW4gcmFzdGVyIHRpbCBwb3RlbnNlbiBhZiBkZSB2w6ZyZGllciwgZGVyIGZpbmRlcyBpIGVuIGFuZGVuIHJhc3Rlci5cIixcblx0XHRyYWRhckNhbGlicmF0aW9uTmFtZTogXCJSYWRhcmthbGlicmVyaW5nXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvblNuaXA6IFwiS29udmVydGVyZXIgUkFEQVJTQVQtMi10aWxiYWdla2FzdG5pbmcuXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvbkRlc2M6IFwiRGVubmUgZnVua3Rpb24ga2FuIGJydWdlcyB0aWwgYXQga2FsaWJyZXJlIFJBREFSU0FULTItYmlsbGVkZXIgaSBldCBtb3NhaWtkYXRhc8OmdCBlbGxlciBzb20gZXQgcmFzdGVycHJvZHVrdC4gS2FsaWJyZXJpbmcgdWRmw7hyZXMgcMOlIHJhZGFyYmlsbGVkZXIsIHPDpSBwaXhlbHbDpnJkaWVybmUgZXIgZW4gc2FuZCByZXByw6ZzZW50YXRpb24gYWYgcmFkYXJlbnMgdGlsYmFnZWthc3RuaW5nLlwiLFxuXHRcdHJhc3RlckluZm9OYW1lOiBcIlJhc3RlckluZm9cIixcblx0XHRyYXN0ZXJJbmZvU25pcDogXCLDhm5kcmVyIGVnZW5za2FiZXJuZSBpIHJhc3RlcmVuLCBmLmVrcy4gYml0ZHliZGUsIE5vRGF0YS12w6ZyZGksIGNlbGxlc3TDuHJyZWxzZSBvc3YuXCIsXG5cdFx0cmFzdGVySW5mb0Rlc2M6IFwiUmFzdGVySW5mbyDDpWJuZXIgZW4gZGlhbG9nYm9rcyBtZWQgZWdlbnNrYWJlciBmb3IgcmFzdGVyZGF0YXPDpnQsIHPDpXNvbSBhbnRhbGxldCBhZiBrb2xvbm5lciBvZyByw6Zra2VyLCBhbnRhbGxldCBhZiBiw6VuZCwgcGl4ZWx0eXBlLCB1ZHN0csOma25pbmcgb2cgZGVuIHNwYXRpYWxlIHJlZmVyZW5jZS4gRHUga2FuIHJlZGlnZXJlIGRpc3NlIGVnZW5za2FiZXIgdmVkIGF0IHbDpmxnZSBldCByYXN0ZXJkYXRhc8OmdCwgZGVyIHNrYWwgYnJ1Z2VzIHNvbSBza2FiZWxvbi4gXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc05hbWU6IFwiQXR0cmlidXR0ZXIgZm9yIGtvbnZlcnRlcmluZyB0aWwgcmFzdGVyXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc1NuaXA6IFwiQmVyaWdlciBlbiByYXN0ZXIgZ2VubmVtIHlkZXJsaWdlcmUgYsOlbmQsIGRlciBrb21tZXIgZnJhIHbDpnJkaWVyIGFmIHNwZWNpZmljZXJlZGUgYXR0cmlidXR0ZXIgZnJhIGVuIGVrc3Rlcm4gdGFiZWwgZWxsZXIgZW4gZmVhdHVyZXRqZW5lc3RlLlwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNEZXNjOiBcIkZ1bmt0aW9uZW4gQXR0cmlidXR0ZXIgZm9yIGtvbnZlcnRlcmluZyB0aWwgcmFzdGVyIGJlcmlnZXIgZW4gcmFzdGVyIHZlZCBhdCB0aWxmw7hqZSBiw6VuZCwgZGVyIGtvbW1lciBmcmEgdsOmcmRpZXIgYWYgc3BlY2lmaWNlcmVkZSBhdHRyaWJ1dHRlciBmcmEgZW4gZWtzdGVybiB0YWJlbCBlbGxlciBlbiBmZWF0dXJldGplbmVzdGUuIER1IGthbiBldmVudHVlbHQgYW5naXZlIGVuIHpvbmVyYXN0ZXIgb2cgZGVuIHRpbGtueXR0ZWRlIHpvbmUtSUQtYXR0cmlidXQgZm9yIGF0IGFrdGl2ZXJlIHJlZ2lvbnNiYXNlcmV0IG9wc2xhZy5cIixcblx0XHRyYXN0ZXJpemVGZWF0dXJlQ2xhc3NOYW1lOiBcIktvbnZlcnRlciBvYmpla3RlciB0aWwgcmFzdGVyXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzU25pcDogXCJLb252ZXJ0ZXJlciBvYmpla3RlciB0aWwgcmFzdGVyLlwiLFxuXHRcdHJhc3Rlcml6ZUZlYXR1cmVDbGFzc0Rlc2M6IFwiRGVubmUgZnVua3Rpb24ga29udmVydGVyZXIgcG9seWdvbi0sIHBvbHlsaW5qZS0gb2cgcHVua3RrbGFzc2VkYXRhIHRpbCBldCByYXN0ZXJsYWcuPGRpdj48YnIvPk9iamVrdGVyIHRpbGRlbGVzIHBpeGVsdsOmcmRpZXIgYmFzZXJldCBww6Ugb2JqZWt0ZXJuZXMgT0JKRUNUSUQgKHN0YW5kYXJkKS4gRXZlbnR1ZWx0IGthbiBwaXhlbHbDpnJkaWVybmUgYmFzZXJlcyBww6UgZXQgYnJ1Z2VyZGVmaW5lcmV0IHbDpnJkaWZlbHQgaSBpbnB1dG9iamVrdGV0cyBhdHRyaWJ1dHRhYmVsLjwvZGl2PlwiLFxuXHRcdHJlY2FzdE5hbWU6IFwiT21hcmJlamRcIixcblx0XHRyZWNhc3RTbmlwOiBcIsOGbmRyZXIgcGFyYW1ldHJlbmUgZm9yIGVuIGZ1bmt0aW9uc2vDpmRlIGkgZXQgbW9zYWlrZGF0YXPDpnQgZWxsZXIgZW4gYmlsbGVkdGplbmVzdGUuIERldHRlIGJydWdlcyBvZnRlIG1lZCBMQVMtZGF0YXPDpnQgZm9yIGF0IHVuZGfDpSBhdCBza3VsbGUgb3ByZXR0ZSBldCBzZXBhcmF0IG1vc2Fpa2RhdGFzw6Z0IHRpbCBmb3Jza2VsbGlnZSByZXByw6ZzZW50YXRpb25lciBhZiB0ZXJyw6ZuLlwiLFxuXHRcdHJlY2FzdERlc2M6IFwiRnVua3Rpb25lbiBPbWFyYmVqZCBicnVnZXMgdGlsIGR5bmFtaXNrIGF0IMOmbmRyZSBmdW5rdGlvbnNwYXJhbWV0ZXJlbiwgZGVyIGFudmVuZGVzIGkgZXQgbW9zYWlrZGF0YXPDpnQgZWxsZXIgYmlsbGVkdGplbmVzdGUsIHVkZW4gYXQgw6ZuZHJpbmdlcm5lIGJldmFyZXMgZnlzaXNrLlwiLFxuXHRcdHJlZ2lvbkdyb3VwTmFtZTogXCJSZWdpb25zZ3J1cHBlXCIsXG5cdFx0cmVnaW9uR3JvdXBTbmlwOiBcIkZvciBodmVyIGNlbGxlIGkgb3V0cHV0dGV0IHJlZ2lzdHJlcmVzIGlkZW50aXRldGVuIGFmIGRldCBmb3JidW5kbmUgb21yw6VkZSwgc29tIGRlbiBww6Vnw6ZsZGVuZGUgY2VsbGUgdGlsaMO4cmVyLiBEZXIgdGlsZGVsZXMgZXQgdW5pa3QgbnVtbWVyIHRpbCBodmVyIHJlZ2lvbi5cIixcblx0XHRyZWdpb25Hcm91cERlc2M6IFwiRGVuIGdsb2JhbGUgZnVua3Rpb24gUmVnaW9uc2dydXBwZSByZWdpc3RyZXJlciBmb3IgaHZlciBjZWxsZSBpIG91dHB1dHRldCBpZGVudGl0ZXRlbiBhZiBkZXQgZm9yYnVuZG5lIHJlZ2lvbiwgc29tIGRlbiBww6Vnw6ZsZGVuZGUgY2VsbGUgdGlsaMO4cmVyLiBEZXIgdGlsZGVsZXMgZXQgdW5pa3QgbnVtbWVyIHRpbCBodmVyIHJlZ2lvbi48ZGl2Pjxici8+RGVuIGbDuHJzdGUgcmVnaW9uLCBkZXIgc2Nhbm5lcywgbW9kdGFnZXIgdsOmcmRpZW4gZW4sIGRlbiBhbmRlbiB2w6ZyZGllbiB0byBvc3YuLCBpbmR0aWwgYWxsZSByZWdpb25lciBoYXIgZsOlZXQgdGlsZGVsdCBlbiB2w6ZyZGkuIFNjYW5uaW5nZW4gZ8OlciBmcmEgdmVuc3RyZSB0aWwgaMO4anJlLCBmcmEgdG9wIHRpbCBidW5kLiBEZSB2w6ZyZGllciwgZGVyIHRpbGRlbGVzIG91dHB1dHpvbmVybmUsIGVyIGJhc2VyZXQgcMOlLCBodm9ybsOlciBkZSByZWdpc3RyZXJlcyBpIHNjYW5uaW5nc3Byb2Nlc3Nlbi48L2Rpdj5cIixcblx0XHRyZWdpb25Hcm93TmFtZTogXCJSZWdpb25zdsOma3N0XCIsXG5cdFx0cmVnaW9uR3Jvd1NuaXA6IFwiRnJlbWJyaW5nZXIgcmVnaW9uZXIgdWQgZnJhIHNlZWQtcHVua3Rlci5cIixcblx0XHRyZWdpb25Hcm93RGVzYzogXCJGdW5rdGlvbmVuIFJlZ2lvbnN2w6Zrc3QgaW5kZGVsZXIgbmFib3BpeGVscyBpIGdydXBwZXIgdWQgZnJhIGRlbiBhbmdpdm5lIHJhZGl1cyBmcmEgc2VlZC1wdW5rdGV0LiBHcnVwcGVuIGFmIHBpeGVscyBlbGxlciBvYmpla3RldCB0aWxkZWxlcyBlbiBhbmdpdmV0IGZ5bGR2w6ZyZGkuXCIsXG5cdFx0cmVtYXBOYW1lOiBcIkdlbmJlcmVnblwiLFxuXHRcdHJlbWFwU25pcDogXCLDhm5kcmVyIHBpeGVsdsOmcmRpZXIgdmVkIGF0IHRpbGRlbGUgbnllIHbDpnJkaWVyIHRpbCBpbnRlcnZhbGxlciBhZiBwaXhlbHbDpnJkaWVyIGVsbGVyIHZlZCBoasOmbHAgYWYgZW4gZWtzdGVybiB0YWJlbC5cIixcblx0XHRyZW1hcERlc2M6IFwiRnVua3Rpb25lbiBHZW5iZXJlZ24gZ2l2ZXIgZGlnIG11bGlnaGVkIGZvciBhdCDDpm5kcmUgZWxsZXIgb21rbGFzc2lmaWNlcmUgcGl4ZWx2w6ZyZGllcm5lIGZvciByYXN0ZXJkYXRhZW5lLiBEZXR0ZSBrYW4gZ8O4cmVzIHZlZCBlbnRlbiBhdCBhbmdpdmUgZXQgaW50ZXJ2YWwgYWYgcGl4ZWx2w6ZyZGllciwgZGVyIHNrYWwga29ydGzDpmdnZXMgdGlsIGVuIG91dHB1dC1waXhlbHbDpnJkaSwgZWxsZXIgdmVkIGF0IGJydWdlIGVuIHRhYmVsIHRpbCBhdCBrb3J0bMOmZ2dlIHBpeGVsdsOmcmRpZXJuZSB0aWwgb3V0cHV0cGl4ZWx2w6ZyZGllbi5cIixcblx0XHRyZXByb2plY3ROYW1lOiBcIkdlbnByb2pla3Rpb25cIixcblx0XHRyZXByb2plY3RTbmlwOiBcIsOGbmRyZXIgcHJvamVrdGlvbmVuIGFmIGV0IHJhc3RlcmRhdGFzw6Z0LCBtb3NhaWtkYXRhc8OmdCBlbGxlciByYXN0ZXJlbGVtZW50IGkgZXQgbW9zYWlrZGF0YXPDpnQuIERldCBrYW4gb2dzw6Ugb21zdHJ1a3R1cmVyZSBkYXRhZW5lIHRpbCBlbiBueSBjZWxsZXN0w7hycmVsc2Ugb2cgZGVmaW5lcmUgZW4gb3ByaW5kZWxzZS5cIixcblx0XHRyZXByb2plY3REZXNjOiBcIkZ1bmt0aW9uZW4gR2VucHJvamVrdGlvbiDDpm5kcmVyIHByb2pla3Rpb25lbiBhZiBldCByYXN0ZXJkYXRhc8OmdCwgbW9zYWlrZGF0YXPDpnQgZWxsZXIgcmFzdGVyZWxlbWVudCBpIGV0IG1vc2Fpa2RhdGFzw6Z0LiBEZXQga2FuIG9nc8OlIG9tc3RydWt0dXJlcmUgZGF0YWVuZSB0aWwgZW4gbnkgY2VsbGVzdMO4cnJlbHNlIG9nIGRlZmluZXJlIGVuIG9wcmluZGVsc2UuPGRpdj48YnIvPkZ1bmt0aW9uZW4gR2VucHJvamVrdGlvbiBrYW4gYnJ1Z2VzLCBuw6VyIGRlciBvcHJldHRlcyBlbiBjYWNoZSB1ZCBmcmEgZXQgcmFzdGVyLSBlbGxlciBtb3NhaWtkYXRhc8OmdCwgZGVyIGlra2UgZXIgaSBkZW4gcMOla3LDpnZlZGUgcHJvamVrdGlvbi4gTsOlciBkdSBmLmVrcy4gb3ByZXR0ZXIgZW4gY2FjaGVsYWdyZXQgYmlsbGVkdGplbmVzdGUsIHNvbSBrYW4gaW50ZWdyZXJlcyBhZiBhcHBsaWthdGlvbmVyIG1lZCBhbmRyZSBjYWNoZS10amVuZXN0ZXIsIGVyIGRldCB2aWd0aWd0LCBhdCBkZSBhbGxlIGVyIGkgc2FtbWUgcHJvamVrdGlvbi4gRGV0dGUgZXIgb2Z0ZSBlbiBXZWIgTWVyY2F0b3ItcHJvamVrdGlvbi4gRWZ0ZXJzb20gbW9zYWlrZGF0YXPDpnR0ZXQgaWtrZSBrYW4gZ2VucHJvamljZXJlcywga2FuIGR1IGfDuHJlIGV0IGFmIHRvOiBEdSBrYW4gZW50ZW4gb3ByZXR0ZSBldCBtb3NhaWtkYXRhc8OmdCwgZGVyIHJlZmVyZXJlcyB0aWwsIHVkIGZyYSBkaXQgbW9zYWlrZGF0YXPDpnQgaSBkZW4gw7huc2tlZGUgcHJvamVrdGlvbiwgZWxsZXIgZHUga2FuIHRpbGbDuGplIGZ1bmt0aW9uZW4gR2VucHJvamVrdGlvbiB0aWwgbW9zYWlrZGF0YXPDpnR0ZXRzIGZ1bmt0aW9uc2vDpmRlLiBFdCBhbmRldCBla3NlbXBlbCBicnVnZXIgZGVubmUgZnVua3Rpb24gcMOlIHJhc3Rlci1lbGVtZW50ZXQgaSBldCBtb3NhaWtkYXRhc8OmdC4gTsOlciBkdSBicnVnZXIgZnVua3Rpb25lbiBDYWNoZWxhZ3JldCByYXN0ZXIsIMO4bnNrZXIgZHUgbXVsaWd2aXMgYXQgaW5kc8OmdHRlIGZ1bmt0aW9uZW4gR2VucHJvamVrdGlvbiwgc8OlIGNhY2hlbiBvcHJldHRlcyBpIGRlbiBueWUgcHJvamVrdGlvbi4gUmFzdGVyZW1uZXIgaSBldCBtb3NhaWtkYXRhc8OmdCBrYW4gY2FjaGVsYWdyZXMsIG7DpXIgYmVoYW5kbGluZ2VuIGVyIGludGVucywgb2cgZHUgZm9yc8O4Z2VyIGF0IHVkZ2l2ZSBlbiBiaWxsZWR0amVuZXN0ZSwgZGVyIGVyIGh1cnRpZywgdWRlbiBhdCBjYWNoZWxhZ3JlIGhlbGUgYmlsbGVkdGplbmVzdGVuLjwvZGl2PlwiLFxuXHRcdHJlc2FtcGxlTmFtZTogXCJPbXN0cnVrdHVyZXJpbmdcIixcblx0XHRyZXNhbXBsZVNuaXA6IFwiw4ZuZHJlciBjZWxsZXN0w7hycmVsc2VuIHDDpSBlbiByYXN0ZXIuXCIsXG5cdFx0cmVzYW1wbGVEZXNjOiBcIkZ1bmt0aW9uZW4gT21zdHJ1a3R1cmVyaW5nIMOmbmRyZXIgY2VsbGVzdMO4cnJlbHNlLCBvbXN0cnVrdHVyZXJpbmdzdHlwZSBlbGxlciBiZWdnZSBkZWxlLjxkaXY+PGJyLz5GdW5rdGlvbmVuIE9tc3RydWt0dXJlcmluZyBiw7hyIGt1biBicnVnZXMgc2FtbWVuIG1lZCBzcGVjaWZpa2tlIGJlcmVnbmluZ3NrcmF2OyBmb3IgZWtzZW1wZWwgbsOlciBkdSBiZXJlZ25lciB2aW5kLSBlbGxlciBzdHLDuG1yZXRuaW5nZW4sIGh2aWxrZXQga3LDpnZlciBvbXN0cnVrdHVyZXJpbmcgZnJhIGtpbGRlb3Bsw7hzbmluZ2VuLjwvZGl2PlwiLFxuXHRcdHJvdW5kRG93bk5hbWU6IFwiUnVuZCBuZWRcIixcblx0XHRyb3VuZERvd25TbmlwOiBcIlJldHVybmVyZXIgZGVuIG7DpnN0ZSBsYXZlcmUgaGVsdGFsdsOmcmRpLCBrdW4gcmVwcsOmc2VudGVyZXQgc29tIGVuIHbDpnJkaSBtZWQgZmx5ZGVuZGUga29tbWEsIGZvciBodmVyIGNlbGxlIGkgZW4gcmFzdGVyLlwiLFxuXHRcdHJvdW5kRG93bkRlc2M6IFwiRnVua3Rpb25lbiBSdW5kIG5lZCByZXR1cm5lcmVyIGRldCBuw6ZzdGUgbGF2ZXJlIGhlbHRhbCBzb20gZW4gdsOmcmRpIG1lZCBmbHlkZW5kZSBrb21tYSBmb3IgaHZlciBwaXhlbCBpIGVuIHJhc3Rlci5cIixcblx0XHRyb3VuZFVwTmFtZTogXCJSdW5kIG9wXCIsXG5cdFx0cm91bmRVcFNuaXA6IFwiUmV0dXJuZXJlciBkZW4gbsOmc3RlIGjDuGplcmUgaGVsdGFsdsOmcmRpLCBrdW4gcmVwcsOmc2VudGVyZXQgc29tIGVuIHbDpnJkaSBtZWQgZmx5ZGVuZGUga29tbWEsIGZvciBodmVyIGNlbGxlIGkgZW4gcmFzdGVyLlwiLFxuXHRcdHJvdW5kVXBEZXNjOiBcIlJ1bmQgb3AgcmV0dXJuZXJlciBkZXQgbsOmc3RlIGjDuGplcmUgaGVsdGFsIHNvbSBlbiB2w6ZyZGkgbWVkIGZseWRlbmRlIGtvbW1hIGZvciBodmVyIHBpeGVsIGkgZW4gcmFzdGVyLlwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnROYW1lOiBcIlNlZ21lbnQgTWVhbiBTaGlmdFwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnRTbmlwOiBcIkdydXBwZXJlciBuYWJvcGl4ZWxzIG1lZCBsaWduZW5kZSBzcGVrdHJhbGUgZWdlbnNrYWJlciBpIHNlZ21lbnRlci5cIixcblx0XHRzZWdtZW50TWVhblNoaWZ0RGVzYzogXCJEZW5uZSBmdW5rdGlvbiBpZGVudGlmaWNlcmVyIG9iamVrdGVyIGVsbGVyIHNlZ21lbnRlciBpIGRpbmUgYmlsbGVkZXIgdmVkIGF0IGdydXBwZXJlIHRpbHN0w7hkZW5kZSBwaXhlbHMsIGRlciBoYXIgbGlnbmVuZGUgc3Bla3RyYWxlIG9nIHNwYXRpYWxlIGVnZW5za2FiZXIuIER1IGthbiBzdHlyZSBtw6ZuZ2RlbiBhZiBzcGF0aWFsIG9nIHNwZWt0cmFsIHVkZ2xhdG5pbmcgZm9yIGF0IGhqw6ZscGUgbWVkIGF0IHVkbGVkZSBmdW5rdGlvbmVyLCBkZXIgaGFyIGludGVyZXNzZS5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25OYW1lOiBcIlNlbnRpbmVsLTEgcmFkaW9tZXRyaXNrIGthbGlicmVyaW5nXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uU25pcDogXCJVZGbDuHJlciBmb3Jza2VsbGlnZSB0eXBlciByYWRpb21ldHJpc2sga2FsaWJyZXJpbmcgcMOlIFNlbnRpbmVsLTEgZGF0YS5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25EZXNjOiBcIkRlbm5lIHJhc3Rlci1mdW5rdGlvbiB1ZGbDuHJlciB0cmUgZm9yc2tlbGxpZ2Uga2FsaWJyZXJpbmdlciBmb3IgU2VudGluZWwgMS1kYXRhc8OmdCwgaGVydW5kZXIgYmV0YSBub3VnaHQgb2cgZ2FtbWEsIG9nIG91dHB1dCBlciBkZXQga2FsaWJyZXJlZGUgZGF0YXPDpnQuIE3DpWxldCBtZWQgU0FSLWthbGlicmVyaW5nIGVyIGF0IHRpbHZlamVicmluZ2UgYmlsbGVkZXIsIGh2b3IgcGl4ZWx2w6ZyZGllciBrYW4gcmVsYXRlcmVzIGRpcmVrdGUgdGlsIHJhZGFyZW5zIHRpbGJhZ2VrYXN0bmluZyBhZiBzY2VuZW4uIFNlbHZvbSB1a2FsaWJyZXJlZGUgU0FSLWJpbGxlZGVyIGVyIHRpbHN0csOma2tlbGlnZSB0aWwga3ZhbGl0YXRpdiBicnVnLCBlciBrYWxpYnJlcmVkZSBTQVItYmlsbGVkZXIgYWZnw7hyZW5kZSBmb3Iga3ZhbnRpdGF0aXYgYnJ1ZyBhZiBTQVItZGF0YS48ZGl2Pjxici8+VHlwaXNrIFNBUi1kYXRhYmVoYW5kbGluZywgc29tIGZyZW1icmluZ2VyIG5pdmVhdSAxLWJpbGxlZGVyLCBvbWZhdHRlciBpa2tlIHJhZGlvbWV0cmlza2Uga29ycmVrdGlvbmVyIG9nIHNpZ25pZmlrYW50ZSByYWRpb21ldHJpc2tlIGJpYXNyZXN0ZXIuIERlcmZvciBlciBkZXQgbsO4ZHZlbmRpZ3QgYXQgYW52ZW5kZSByYWRpb21ldHJpc2sga29ycmVrdGlvbiBww6UgU0FSLWJpbGxlZGVyLCBzw6UgcGl4ZWx2w6ZyZGllcm5lIGZvciBiaWxsZWRlcm5lIHZpcmtlbGlnIHJlcHLDpnNlbnRlcmVyIHJhZGFyLXRpbGJhZ2VrYXN0bmluZ2VuIGFmIGRlbiByZWZsZWt0ZXJlbmRlIG92ZXJmbGFkZS4gUmFkaW9tZXRyaXNrIGtvcnJla3Rpb24gZXIgb2dzw6UgbsO4ZHZlbmRpZyBmb3Igc2FtbWVubGlnbmluZyBhZiBTQVItYmlsbGVkZXIsIGRlciBrb21tZXIgZnJhIGZvcnNrZWxsaWdlIHNlbnNvcmVyIGVsbGVyIGZyYSBzYW1tZSBzZW5zb3IgcMOlIGZvcnNrZWxsaWdlIHRpZHNwdW5rdGVyLCBpIGZvcnNrZWxsaWdlIHRpbHN0YW5kZSBlbGxlciBzb20gZXIgYmVoYW5kbGV0IGFmIGZvcnNrZWxsaWdlIHByb2Nlc3NvcmVyLjwvZGl2PlwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbE5hbWU6IFwiRmplcm5lbHNlIGFmIHRlcm1pc2sgc3TDuGogZnJhIFNlbnRpbmVsLTEgZGF0YVwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbFNuaXA6IFwiRmplcm5lciB0ZXJtaXNrIHN0w7hqIGZyYSBTZW50aW5lbC0xIGRhdGEuXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsRGVzYzogXCJUZXJtaXNrIHN0w7hqa29ycmVrdGlvbiBrYW4gYW52ZW5kZXMgcMOlIGZyYSBTZW50aW5lbC0xIExldmVsLTEgU2luZ2xlIExvb2sgQ29tcGxleCAoU0xDKS1wcm9kdWt0ZXIgc2FtdCBHUkQtcHJvZHVrdGVyIChMZXZlbC0xIEdyb3VuZCBSYW5nZSBEZXRlY3Rpb24pLCBzb20gaWtrZSBhbGxlcmVkZSBlciByZXR0ZXQuIE9wZXJhdMO4cmVuIGthbiBvZ3PDpSBmamVybmUgZGVubmUga29ycmVrdGlvbiBiYXNlcmV0IHDDpSBwcm9kdWt0YW5tw6Zya25pbmdlcm5lIGZvciBhdCBnZW5pbmRmw7hyZSBkZXQgc3TDuGpzaWduYWwsIGRlciBibGV2IGZqZXJuZXQgZm9yIGF0IGZyZW1icmluZ2UgZGV0IG9wcmluZGVsaWdlIHByb2R1a3QuIFByb2R1a3Rhbm3DpnJrbmluZ2VybmUgYmxpdmVyIG9wZGF0ZXJldCBpIG92ZXJlbnNzdGVtbWVsc2UgaGVybWVkLCBzw6Uga29ycmVrdGlvbmVuIGthbiBnZW5hbnZlbmRlcy4gXCIsXG5cdFx0c2V0TnVsbE5hbWU6IFwiQW5naXYgbnVsXCIsXG5cdFx0c2V0TnVsbFNuaXA6IFwiQW5naXYgbnVsIGFuZ2l2ZXIgaWRlbnRpZmljZXJlZGUgY2VsbGVwbGFjZXJpbmdlciB0aWwgTm9EYXRhIGJhc2VyZXQgcMOlIGV0IHNwZWNpZmljZXJldCBrcml0ZXJpdW0uIERldCByZXR1cm5lcmVyIE5vRGF0YSwgaHZpcyBlbiBiZXRpbmdldCBldmFsdWVyaW5nIGVyIHNhbmQsIG9nIHJldHVybmVyZXIgdsOmcmRpZW4sIGRlciBlciBhbmdpdmV0IGFmIGVuIGFuZGVuIHJhc3RlciwgaHZpcyBkZW4gZXIgZmFsc2suXCIsXG5cdFx0c2V0TnVsbERlc2M6IFwiRnVua3Rpb25lbiBBbmdpdiBudWwgYW5naXZlciBkZSBpZGVudGlmaWNlcmVkZSBwaXhlbHMgdGlsIE5vRGF0YSwgYmFzZXJldCBww6UgZGUgc3BlY2lmaWtrZSBrcml0ZXJpZXIuIERlbiByZXR1cm5lcmVyIE5vRGF0YSwgaHZpcyBlbiBiZXRpbmdldCB2dXJkZXJpbmcgZXIgc2FuZCAoMSkgb2cgcmV0dXJuZXJlciB2w6ZyZGllbiwgZGVyIGVyIGFuZ2l2ZXQgaSByYXN0ZXJlbiBGYWxzaywgaHZpcyBlbiBiZXRpbmdldCBldmFsdWVyaW5nIGVyIGZhbHNrICgwKS4gRGV0dGUga3JpdGVyaXVtIGVyIGFuZ2l2ZXQgYWYgb3V0cHV0dGV0IGZyYSBlbiBsb2dpc2sgbWF0ZW1hdGlzayBmdW5rdGlvbiwgc29tIGVyIGlucHV0cmFzdGVyZW4uXCIsXG5cdFx0c2hhZGVkUmVsaWVmTmFtZTogXCJTa3lnZ2VlZmZla3RcIixcblx0XHRzaGFkZWRSZWxpZWZTbmlwOiBcIk9wcmV0dGVyIGVuIGZhcnZla29kZXQsIGZsZXJiw6VuZHMgM0QtcmVwcsOmc2VudGF0aW9uIGFmIG92ZXJmbGFkZW4gbWVkIHNvbGVucyByZWxhdGl2ZSBwb3NpdGlvbiB0YWdldCBpIGJldHJhZ3RuaW5nIHZlZCBza3lnZ2Vsw6ZnbmluZyBhZiBiaWxsZWRldC5cIixcblx0XHRzaGFkZWRSZWxpZWZEZXNjOiBcIkZ1bmt0aW9uZW4gU2t5Z2dlZWZmZWt0IHNrYWJlciBlbiAzRC1yZXByw6ZzZW50YXRpb24gaSBmYXJ2ZXIgYWYgdGVycsOmbmV0LCBzb20gZXIgc2thYnQgdmVkIGF0IGZ1c2lvbmVyZSBiaWxsZWRlcm5lIGZyYSBtZXRvZGVybmUgaMO4amRla29kZSBvZyBza3lnZ2V2aXJrbmluZy4gRGVubmUgZnVua3Rpb24gYnJ1Z2VyIGjDuGpkZS0gb2cgYXppbXV0ZWdlbnNrYWJlcm5lIHRpbCBhdCBhbmdpdmUgc29sZW5zIHBvc2l0aW9uLjxkaXY+PGJyLz48L2Rpdj5cIixcblx0XHRzaW5ITmFtZTogXCJTaW5IXCIsXG5cdFx0c2luSFNuaXA6IFwiQmVyZWduZXIgZGVuIGh5cGVyYm9sc2tlIHNpbnVzIGZvciBjZWxsZXIgaSBlbiByYXN0ZXIuXCIsXG5cdFx0c2luSERlc2M6IFwiRnVua3Rpb25lbiBiZXJlZ25lciBkZW4gaHlwZXJib2xza2Ugc2ludXMgZm9yIHBpeGVscyBpIGVuIHJhc3Rlci5cIixcblx0XHRzaW5OYW1lOiBcIlNpblwiLFxuXHRcdHNpblNuaXA6IFwiQmVyZWduZXIgc2ludXMgZm9yIGNlbGxlciBpIGVuIHJhc3Rlci5cIixcblx0XHRzaW5EZXNjOiBcIkZ1bmt0aW9uZW4gYmVyZWduZXIgc2ludXMgZm9yIHBpeGVscyBpIGVuIHJhc3Rlci5cIixcblx0XHRzbG9wZU5hbWU6IFwiU3RpZ25pbmdcIixcblx0XHRzbG9wZVNuaXA6IFwiQmVyZWduZXIgw6ZuZHJpbmdzaGFzdGlnaGVkZW4gZnJhIGVuIHBpeGVsdsOmcmRpIHRpbCBkZW5zIG5hYm9lci5cIixcblx0XHRzbG9wZURlc2M6IFwiRGVubmUgcmFzdGVyZnVua3Rpb24gYmVyZWduZXIgaMOmbGRuaW5nLCBodmlsa2V0IGVyIGhhc3RpZ2hlZGVuIGFmIMOmbmRyaW5nIGkgaMO4amRlIGZvciBodmVyIGNlbGxlIGkgZW4gZGlnaXRhbCBlbGV2YXRpb25zbW9kZWwgKERFTSkuIERldCBlciBkZW4gZsO4cnN0ZSBhZmxlZHRlIHbDpnJkaSBhZiBlbiBERU0uPGRpdj48YnIvPkRlbm5lIGZ1bmt0aW9uIGJydWdlciBlbiBhY2NlbGVyZXJldCBhdGFuKCktZnVua3Rpb24uIERldCBlciBzZWtzIGdhbmdlIGh1cnRpZ2VyZSwgb2cgdGlsbsOmcm1lbHNlc2ZlamxlbiBlciBhbHRpZCBtaW5kcmUgZW5kIDAsMyBncmFkZXIuPC9kaXY+XCIsXG5cdFx0c3BlY2tsZU5hbWU6IFwiU3BlY2tsZVwiLFxuXHRcdHNwZWNrbGVTbmlwOiBcIkluZGVob2xkZXIgZmlsdHJlIHRpbCBmamVybmVsc2UgYWYgc3TDuGogZnJhIHN5bnRldGlza2UgYXBlcnR1cnJhZGFyLWRhdGFzw6Z0LlwiLFxuXHRcdHNwZWNrbGVEZXNjOiBcIlNwZWNrbGUgZXIgaMO4amZyZWt2ZW50IHN0w7hqIHDDpSByYWRhcmRhdGEuIEJpbGxlZGVybmUsIGRlciBnZW5lcmVyZXMgYWYgU0FSLXN5c3RlbWVyLCBlciBtZWdldCB1ZHNhdCBmb3Igc3BlY2tsaW5nLWVmZmVrdGVyIHDDpSBncnVuZCBhZiBiZWhhbmRsaW5nZW4gYWYgc3ByZWR0ZSBzaWduYWxlciBvZyBpbnRlcmZlcmVucyBmcmEgZWxla3Ryb21hZ25ldGlza2UgYsO4bGdlciwgZGVyIHNwcmVkZXMgZnJhIG92ZXJmbGFkZXIgZWxsZXIgb2JqZWt0ZXIuIERlbm5lIFNwZWNrbGUtZnVua3Rpb24gZmlsdHJlcmVyIGRldCBzcGVja2xlZGUgcmFkYXJkYXRhc8OmdCBvZyB1ZGrDpnZuZXIgc3TDuGplbiwgbWVucyBrYW50ZXIgZWxsZXIgc2thcnBlIG9iamVrdGVyIGkgYmlsbGVkZXQgYmV2YXJlcy5cIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25OYW1lOiBcIlNwZWt0cmFsa29udmVydGVyaW5nXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uU25pcDogXCJBbnZlbmRlciBlbiBtYXRyaXggcMOlIGV0IGZsZXJiw6VuZHNiaWxsZWRlLlwiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvbkRlc2M6IFwiRnVua3Rpb25lbiBTcGVrdHJhbGtvbnZlcnRlcmluZyBhbnZlbmRlciBlbiBtYXRyaXggcMOlIGV0IGZsZXJiw6VuZHNiaWxsZWRlIHRpbCBhdCBww6V2aXJrZSBvdXRwdXR0ZXRzIGZhcnZldsOmcmRpZXIuPGRpdj48YnIvPk5vZ2xlIHNlbnNvcmVyIGluZHNhbWxlciBpa2tlIGJsw6UgYsOlbmQgcMOlIGdydW5kIGFmIGV0IGxhdnQgc2lnbmFsIGkgZm9yaG9sZCB0aWwgc3TDuGplbi4gRGV0IGthbiBmLmVrcy4gYnJ1Z2VzIHRpbCBhdCBrb252ZXJ0ZXJlIGV0IGZvcmtlcnQgZmFydmV0IGluZnJhcsO4ZHQgYmlsbGVkZSB0aWwgZXQgcHNldWRvLW5hdHVybGlndCBmYXJ2ZWJpbGxlZGUuPC9kaXY+XCIsXG5cdFx0c3F1YXJlUm9vdE5hbWU6IFwiS3ZhZHJhdHJvZFwiLFxuXHRcdHNxdWFyZVJvb3RTbmlwOiBcIkJlcmVnbmVyIGt2YWRyYXRyb2RlbiBhZiBjZWxsZXbDpnJkaWVybmUgaSBlbiByYXN0ZXIuXCIsXG5cdFx0c3F1YXJlUm9vdERlc2M6IFwiRnVua3Rpb25lbiBLdmFkcmF0cm9kIGJlcmVnbmVyIGt2YWRyYXRyb2RlbiBhZiBwaXhlbHbDpnJkaWVybmUgaSBlbiByYXN0ZXIuXCIsXG5cdFx0c3F1YXJlTmFtZTogXCJLdmFkcmF0XCIsXG5cdFx0c3F1YXJlU25pcDogXCJCZXJlZ25lciBrdmFkcmF0ZXQgYWYgY2VsbGV2w6ZyZGllcm5lIGkgZW4gcmFzdGVyLlwiLFxuXHRcdHNxdWFyZURlc2M6IFwiS3ZhZHJhdCBiZXJlZ25lciBrdmFkcmF0ZXQgYWYgcGl4ZWx2w6ZyZGllcm5lIGkgZW4gcmFzdGVyLlwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1OYW1lOiBcIlN0YXRpc3RpayBvZyBoaXN0b2dyYW1cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtU25pcDogXCJEZWZpbmVyIGVsbGVyIHRpbGtueXQgc3RhdGlzdGlrIG9nIGhpc3RvZ3JhbS5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtRGVzYzogXCJGdW5rdGlvbmVuIFN0YXRpc3RpayBvZyBoaXN0b2dyYW0gYnJ1Z2VzIHRpbCBhdCBkZWZpbmVyZSBzdGF0aXN0aWtrZW4gb2cgaGlzdG9ncmFtbWV0IGZvciBlbiByYXN0ZXIuIER1IGthbiBpbmRzw6Z0dGUgZGVubmUgZnVua3Rpb24gaSBzbHV0bmluZ2VuIGFmIGZ1bmt0aW9uc2vDpmRlbiBmb3IgYXQgYmVza3JpdmUgc3RhdGlzdGlra2VuIG9nIGhpc3RvZ3JhbW1ldCBmb3IgZW4gcmFzdGVyZnVua3Rpb25zc2thYmVsb24gKFJGVCkuIERldCBrYW4gdsOmcmUgbsO4ZHZlbmRpZ3QgZm9yIGF0IHN0eXJlIHN0YW5kYXJkdmlzbmluZ2VuIGFmIGJlaGFuZGxpbmdzcmVzdWx0YXRldCwgaXPDpnIgbsOlciBkZXIgZGVmaW5lcmVzIGVuIGZ1bmt0aW9uc2vDpmRlLCBkZXIgaW5kZWhvbGRlciBtYW5nZSBmdW5rdGlvbmVyLjxkaXY+PGJyLz5EdSBrYW4gZGVmaW5lcmUgc3RhdGlzdGlra2VyIHZlZCBhdCBza3JpdmUgdsOmcmRpZXJuZSBlbGxlciBpbXBvcnRlcmUgZnJhIGV0IHJhc3RlcmRhdGFzw6Z0IGVsbGVyIGVuIFhNTC1maWwuIEhpc3RvZ3JhbW1lciBrYW4ga3VuIGRlZmluZXJlcyB2ZWQgYXQgaW1wb3J0ZXJlIGVuIGZpbC48L2Rpdj5cIixcblx0XHRzdGF0aXN0aWNzTmFtZTogXCJTdGF0aXN0aWtcIixcblx0XHRzdGF0aXN0aWNzU25pcDogXCJCZXJlZ25lciBmb2t1c2VyZXQgc3RhdGlzdGlrIGZvciBodmVyIHBpeGVsIGkgZXQgYmlsbGVkZSBiYXNlcmV0IHDDpSBldCBkZWZpbmVyZXQgZm9rdXNvbXLDpWRlLlwiLFxuXHRcdHN0YXRpc3RpY3NEZXNjOiBcIkZ1bmt0aW9uZW4gU3RhdGlzdGlrIGJlcmVnbmVyIGZva3VzZXJldCBzdGF0aXN0aWsgZm9yIGh2ZXIgcGl4ZWwgaSBldCBiaWxsZWRlIGJhc2VyZXQgcMOlIGV0IGRlZmluZXJldCBuw6ZybGlnZ2VuZGUgZm9rdXNvbXLDpWRlLjxkaXY+PGJyLz5GdW5rdGlvbmVuIFN0YXRpc3RpayBrYW4gYnJ1Z2VzIHRpbCBhdCB1ZGZ5bGRlIHRhYnRlIGxpbmplciBpIGV0IGJpbGxlZGUuIFRhYnRlIGxpbmplciBza3lsZGVzIG9mdGUgcHJvYmxlbWVyIGkgc2Vuc29yZW4sIGh2b3IgZGVyIGlra2UgYmxpdmVyIGluZHNhbWxldCBkYXRhLiBEZXR0ZSBlciBza2V0IGkgc2Vuc29yZXIgc29tIExhbmRzYXQgN3MgRW5oYW5jZWQgVGhlbWF0aWMgTWFwcGVyIFBsdXMgKEVUTSspLiBEaXNzZSBtYW5nbGVuZGUgZGF0YSBnaXZlciBwcm9ibGVtZXIgdmVkIGFuYWx5c2UsIHNhbXQgbsOlciBtYW4gc2VyIHDDpSBiaWxsZWRldC4gRGVyIGVyIGlra2UgbWVnZXQsIGRlciBrYW4gZ8O4cmVzLCBuw6VyIG1hbiBicnVnZXIgYmlsbGVkZXQgdGlsIGFuYWx5c2UuIE1lbiBodmlzIGRlciBmaW5kZXMgZXQgb3ZlcmxhcHBlbmRlIGJpbGxlZGUsIGthbiBkZXQgYnJ1Z2VzIGkgc3RlZGV0IGZvciBkZXQgbWFuZ2xlbmRlIGluZGhvbGQuIERldCBzYW1tZSBrYW4gZ8O4cmVzLCBodmlzIGJpbGxlZGV0IGJydWdlcyB0aWwgdmlzdWFsaXNlcmluZy4gRGVyIGZpbmRlcyBkb2cgaWtrZSBhbHRpZCBldCBla3N0cmEgYmlsbGVkZSB0aWwgYXQgdWRmeWxkZSBkZXQgbWFuZ2xlbmRlIGluZGhvbGQsIHPDpSBkZXQgc2thbCB1ZGxlZGVzIGFmIGRlIGVrc2lzdGVyZW5kZSBkYXRhLjwvZGl2PlwiLFxuXHRcdHN0cmVhbUxpbmtOYW1lOiBcIlN0csO4bWxpbmtcIixcblx0XHRzdHJlYW1MaW5rU25pcDogXCJUaWxkZWxlciB1bmlra2UgdsOmcmRpZXIgdGlsIGRlbGUgYWYgZXQgbGluZcOmcnQgcmFzdGVybmV0dsOmcmsgbWVsbGVtIHNrw6ZyaW5nZXIuXCIsXG5cdFx0c3RyZWFtTGlua0Rlc2M6IFwiRGVuIGdsb2JhbGUgZnVua3Rpb24gU3Ryw7htbGluayB0aWxkZWxlciB1bmlra2UgdsOmcmRpZXIgdGlsIGRlbGUgYWYgZXQgbGluZcOmcnQgcmFzdGVybmV0dsOmcmsgbWVsbGVtIHNrw6ZyaW5nZXIuPGRpdj48YnIvPkxpbmtzIGVyIGRlbGVuIGFmIGVuIHN0csO4bWthbmFsLCBkZXIgZm9yYmluZGVyIHRvIHDDpSBoaW5hbmRlbiBmw7hsZ2VuZGUga251ZGVwdW5rdGVyLCBldCBrbnVkZXB1bmt0IG9nIHVkbMO4YmV0LCBlbGxlciBldCBrbnVkZXB1bmt0IG9nIGRyw6ZuaW5nc2RlbGluZ2VuLiBJbmRlbiBmb3IgaHlkcm9sb2dpIGthbGRlcyBkaXNzZSBzdHLDuG1zZWdtZW50ZXIgZm9yIGxpZ2Ugc3Ryw6ZrbmluZ2VyLiBFdCBrbnVkZXB1bmt0IGVyIHJlbGF0ZXJldCB0aWwgZXQgcHVua3QgZm9yIHZhbmRsw7hic3JldG5pbmcgb2cgbWVkdmlya2VyIHRpbCBhdCBtYXJrZXJlIGV0IHZhbmRza2VsIGVsbGVyIGdyw6Zuc2VuIHRpbCBldCBkcsOmbmluZ3N1bmRlcmJhc2luLjwvZGl2PlwiLFxuXHRcdHN0cmV0Y2hOYW1lOiBcIlN0csOma1wiLFxuXHRcdHN0cmV0Y2hTbmlwOiBcIkZvcmJlZHJlciBldCBiaWxsZWRlIHZlZCBhdCBqdXN0ZXJlIHLDpmtrZXZpZGRlbiBhZiBkZSB2aXN0ZSB2w6ZyZGllci4gRGV0dGUgw6ZuZHJlciBpa2tlIGRlIHVuZGVybGlnZ2VuZGUgcGl4ZWx2w6ZyZGllci4gSHZpcyBlbiBwaXhlbCBoYXIgZW4gdsOmcmRpLCBkZXIgbGlnZ2VyIHVkZW4gZm9yIGRldCBhbmdpdm5lIGludGVydmFsLCB2aXNlcyBkZW4gc29tIGVudGVuIG1pbmltdW0tIGVsbGVyIG1ha3NpbXVtdsOmcmRpZW4uXCIsXG5cdFx0c3RyZXRjaERlc2M6IFwiRnVua3Rpb25lbiBTdHLDpmsgZm9yYmVkcmVyIGV0IGJpbGxlZGUgdmVkIGF0IMOmbmRyZSBlZ2Vuc2thYmVyIHNvbSBseXNzdHlya2UsIGtvbnRyYXN0IG9nIGdhbW1hIGdlbm5lbSBmbGVyZSBzdHLDpmt0eXBlci4gRGVubmUgZnVua3Rpb24gYnJ1Z2VyIHN0YXRpc3Rpa2tlcm5lIGZyYSByYXN0ZXIgaW5kZW4gZm9yIG1vc2Fpa2RhdGFzw6Z0dGV0LiBEZXJmb3Igc2thbCBkdSBzw7hyZ2UgZm9yLCBhdCBkZXIgZXIgYmVyZWduZXQgc3RhdGlzdGlra2VyLCBodmlzIGR1IGJlbnl0dGVyIGRlbm5lIGZ1bmt0aW9uLjxkaXY+PGJyLz5TdHLDpmt0eXBlbiBkZWZpbmVyZXIgZXQgaGlzdG9ncmFtLXRyw6ZrLCBzb20gdmlsIGJsaXZlIGFudmVuZHQgcMOlIHJhc3Rlcm5lIGZvciBhdCBmb3JiZWRyZSBkZXJlcyB1ZHNlZW5kZS4gU3Ryw6ZrbmluZyBmb3JiZWRyZXIgZGF0YWVuZXMgdWRzZWVuZGUgdmVkIGF0IHNwcmVkZSBwaXhlbHbDpnJkaWVybmUgbGFuZ3MgZXQgaGlzdG9ncmFtIHVkIGZyYSBtaW5pbXVtLSBvZyBtYWtzaW11bXbDpnJkaWVybmUsIGRlciBlciBkZWZpbmVyZXQgYWYgZGVyZXMgYml0ZHliZGUuIDwvZGl2PlwiLFxuXHRcdHN3YXRoTmFtZTogXCJTd2F0aFwiLFxuXHRcdHN3YXRoU25pcDogXCJJbnRlcnBvbGVyZXIgZnJhIHVyZWdlbG3DpnNzaWdlIGdyaWRzIGVsbGVyIHN3YXRoLWRhdGEuXCIsXG5cdFx0c3dhdGhEZXNjOiBcIk5vZ2xlIG5ldENERi0gZWxsZXIgSERGLWRhdGFzw6Z0IGdlbW1lciBkZXJlcyBnZW9wbGFjZXJpbmcgc29tIHVyZWdlbG3DpnNzaWd0IGFkc2tpbHRlIGFycmF5ZXIuIE7DpXIgZHUgdGlsZsO4amVyIGRpc3NlIGRhdGFzw6Z0IHRpbCBldCBtb3NhaWtkYXRhc8OmdCwgdGFnZXIgZGVuIGludGVycG9sZXJlZGUgdXJlZ2VsbcOmc3NpZ2UgZGF0YWZ1bmt0aW9uIGRlIHVyZWdlbG3DpnNzaWdlIGdpdHRlcmRhdGEgb2cgb21zdHJ1a3R1cmVyZXIgZGVtLCBzw6UgaHZlciBwaXhlbCBmw6VyIHNhbW1lIHN0w7hycmVsc2Ugb2cgZXIgZmlya2FudGV0LjxkaXY+PGJyLz5Ow6VyIGR1IHRpbGbDuGplciB2YXJpYWJsZXIgZnJhIG5ldENERiBlbGxlciBIREYgdGlsIGV0IG1vc2Fpa2RhdGFzw6Z0LCB2aWwgZGV0IGF1dG9tYXRpc2sga29udHJvbGxlcmUsIG9tIGRhdGFlbmUgZXIgcmVnZWxtw6Zzc2lndCBvcHN0aWxsZXQuIEh2aXMgZGV0IGlra2UgZXIgdGlsZsOmbGRldCwgYmxpdmVyIFN3YXRoLWZ1bmt0aW9uZW4gYXV0b21hdGlzayBhbnZlbmR0IHRpbCBhdCBrb252ZXJ0ZXJlIGRlbiB1cmVnZWxtw6Zzc2lnZSByYXN0ZXIgdGlsIHB1bmt0ZXIgb2cgZGVyZWZ0ZXIgdGlsIGVuIHJhc3RlciBtZWQgcmVnZWxtw6Zzc2lndCBnaXR0ZXIuIER1IGthbiDDpm5kcmUgaW50ZXJwb2F0aW9uc21ldG9kZW4gb2cgY2VsbGVzdMO4cnJlbHNlbiwgZGVyIGJydWdlcyBpIHJhc3RlcmZ1bmt0aW9uZW4gU3dhdGguIEZvciByYXN0ZXJkYXRhIG1lZCByZWdlbG3DpnNzaWd0IG1lbGxlbXJ1bSB2aWwgZGVyIGlra2UgYmxpdmUgYW52ZW5kdCBpbnRlcnBvbGF0aW9uLCBvZyBkYXRhZW5lIHZpbCBibGl2ZSBsw6ZzdCwgc29tIGRlIGVyLjwvZGl2PlwiLFxuXHRcdHRhbkhOYW1lOiBcIlRhbkhcIixcblx0XHR0YW5IU25pcDogXCJCZXJlZ25lciBkZW4gaHlwZXJib2xza2UgdGFuZ2VucyBmb3IgcGl4ZWxzIGkgZW4gcmFzdGVyLlwiLFxuXHRcdHRhbkhEZXNjOiBcIkZ1bmt0aW9uZW4gYmVyZWduZXIgZGVuIGh5cGVyYm9sc2tlIHRhbmdlbnMgZm9yIHBpeGVscyBpIGVuIHJhc3Rlci5cIixcblx0XHR0YW5OYW1lOiBcIlRhblwiLFxuXHRcdHRhblNuaXA6IFwiQmVyZWduZXIgdGFzdGVucyBmb3IgY2VsbGVyIGkgZW4gcmFzdGVyLlwiLFxuXHRcdHRhbkRlc2M6IFwiRnVua3Rpb25lbiBiZXJlZ25lciB0YW5nZW5zIGZvciBwaXhlbHMgaSBlbiByYXN0ZXIuIFwiLFxuXHRcdHRhc3NlbGVkQ2FwTmFtZTogXCJUYXNzZWxlZCBDYXAgKEthdXRoLVRob21hcylcIixcblx0XHR0YXNzZWxlZENhcFNuaXA6IFwiQmVyZWduZXIgbml2ZWF1ZXIgZm9yIHZlZ2V0YXRpb24sIHbDpWRoZWQgb2cgbHlzc3R5cmtlLiBEZW5uZSB0ZWtuaWsgZXIgYmFzZXJldCBww6Uga29lZmZpY2llbnRlciwgZGVyIHNrYWwgYmVyZWduZXMgc3BlY2lmaWt0IHRpbCBlbiBzZW5zb3IuXCIsXG5cdFx0dGFzc2VsZWRDYXBEZXNjOiBcIlRhc3NlbGVkIENhcCAoS2F1dGgtVGhvbWFzKS10cmFuc2Zvcm1hdGlvbmVuIGVyIGJlcmVnbmV0IHRpbCBhdCBhbmFseXNlcmUgb2cga29ydGzDpmdnZSB2ZWdldGF0aW9uc2bDpm5vbWVub2xvZ2kgb2cgw6ZuZHJpbmdlciBpIGJ5dWR2aWtsaW5nLCBkZXIgcmVnaXN0cmVyZXMgYWYgZm9yc2tlbGxpZ2Ugc2F0ZWxsaXRzZW5zb3JzeXN0ZW1lci4gRGV0IGVyIGthbGRlcyBUYXNzZWxlZCBDYXAtdHJhbnNmb3JtYXRpb24gcMOlIGdydW5kIGFmIGZvcm1lbiBww6UgZGVuIGdyYWZpc2tlIGRpc3RyaWJ1dGlvbiBhZiBkYXRhLiBUcmFuc2Zvcm1hdGlvbmVuIHRpbHZlamVicmFndGUgZXQgcmF0aW9uYWxlIGZvciBkZSBtw7huc3RyZSwgZGVyIGZpbmRlcyBpIExhbmRzYXQgTVNTLWRhdGEgZm9yIGxhbmRicnVnc2FyZWFsZXIgc29tIGVuIGZ1bmt0aW9uIGFmIGFmZ3LDuGRlbnMgbGl2c2N5a2x1cy4gTsOlciBhZmdyw7hkZXIgdm9rc2VyIGZyYSBmcsO4IHRpbCBtb2RlbiBwbGFudGUsIHNrZXIgZGVyIGVuIG5ldHRvZm9yw7hnZWxzZSBpIG7DpnItaW5mcmFyw7hkIHJlZmxla3Rpb24gb2cgZXQgZmFsZCBpIHLDuGQgcmVmbGVrdGlvbiBiYXNlcmV0IHDDpSBqb3JkZmFydmU8ZGl2Pjxici8+QW52ZW5kZWxzZW4gYWYg4oCL4oCLZGVubmUgdHJhbnNmb3JtYXRpb24gZXIgdWR2aWRldCBmcmEgb3ZlcnbDpWduaW5nIGFmIGFmZ3LDuGRlciB0aWwgYW5hbHlzZSBvZyBrb3J0bMOmZ25pbmcgYWYgdmVnZXRhdGlvbiB0aWwgZW4gcsOma2tlIGFudmVuZGVsc2VyIHNvbSBza292YnJ1ZywgaW5kdXN0cmllbCB2ZWdldGF0aW9uc3N0eXJpbmcsIGtvcnRsw6ZnbmluZyBvZyBzdHlyaW5nIGFmIMO4a29zeXN0ZW1lciwgb3Bnw7hyZWxzZSBvZyBvdmVydsOlZ25pbmcgYWYga3Vsc3RvZnVkbGVkbmluZyBvZyAta3JlZGl0dGVyLCBieXVkdmlrbGluZyBvZyBtZWdldCBtZXJlLiBEZXQgZXIgb2dzw6UgdWR2aWRldCBzaWcgZnJhIGt1biBhdCB1bmRlcnN0w7h0dGUgTGFuZHNhdCBNU1MgdGlsIGF0IG9tZmF0dGUgYW5kcmUgcG9wdWzDpnJlIHNhdGVsbGl0c3lzdGVtZXIgc29tIExhbmRzYXQgVE0sIExhbmRzYXQgRVRNKywgTGFuZHNhdCA4LCBJS09OT1MsIFF1aWNrQmlyZCwgV29ybGRWaWV3LTIgb2cgUmFwaWRFeWUgbXVsdGlzcGVrdHJhbGUgc2Vuc29yZXIuPC9kaXY+XCIsXG5cdFx0dGltZXNOYW1lOiBcIlRpZGVyXCIsXG5cdFx0dGltZXNTbmlwOiBcIk11bHRpcGxpY2VyZXIgdsOmcmRpZXJuZSBhZiB0byByYXN0ZXIgY2VsbGUgZm9yIGNlbGxlLlwiLFxuXHRcdHRpbWVzRGVzYzogXCJGdW5rdGlvbmVuIFRpZGVyIG11bHRpcGxpY2VyZXIgdsOmcmRpZXJuZSBmb3IgdG8gcmFzdGVyIHBpeGVsIGZvciBwaXhlbC5cIixcblx0XHR0cmFuc3Bvc2VCaXRzTmFtZTogXCJUcmFuc3BvbmVyIGJpdHNcIixcblx0XHR0cmFuc3Bvc2VCaXRzU25pcDogXCJVZHBha2tlciBiaXRzZW5lIGkgaW5wdXRwaXhsZW4gb2cgbWFwcGVyIGRlbSB0aWwgc3BlY2lmaWNlcmVkZSBiaXRzIGkgb3V0cHV0cGl4bGVuLiBGb3Jtw6VsZXQgbWVkIGRlbm5lIGZ1bmt0aW9uIGVyIGF0IG1hbmlwdWxlcmUgYml0cyBmcmEgbm9nbGUgZsOlIGlucHV0LCBzw6Vzb20gTGFuZHNhdCA4IGt2YWxpdGV0c2LDpW5kcHJvZHVrdGVybmUuXCIsXG5cdFx0dHJhbnNwb3NlQml0c0Rlc2M6IFwiRnVua3Rpb25lbiBUcmFuc3BvbmVyIGJpdHMgdWRwYWtrZXIgYml0c2VuZSBpIGlucHV0cGl4bGVuIG9nIG1hcHBlciBkZW0gdGlsIHNwZWNpZmljZXJlZGUgYml0cyBpIG91dHB1dHBpeGxlbi4gRm9ybcOlbGV0IG1lZCBkZW5uZSBmdW5rdGlvbiBlciBhdCBtYW5pcHVsZXJlIGJpdHMgZnJhIG5vZ2xlIGbDpSBpbnB1dCwgc8Olc29tIExhbmRzYXQgOCBrdmFsaXRldHNiw6VuZHByb2R1a3Rlcm5lLlwiLFxuXHRcdHVuaXRDb252ZXJzaW9uTmFtZTogXCJFbmhlZHNrb252ZXJ0ZXJpbmdcIixcblx0XHR1bml0Q29udmVyc2lvblNuaXA6IFwiw4ZuZHJlciB2w6ZyZGllciBmcmEgZW4gbcOlbGVlbmhlZCB0aWwgZW4gYW5kZW4uXCIsXG5cdFx0dW5pdENvbnZlcnNpb25EZXNjOiBcIkRlbm5lIGZ1bmt0aW9uIGtvbnZlcnRlcmVyIHBpeGVscyBmcmEgZW4gZW5oZWQgdGlsIGVuIGFuZGVuLiBEZW4gdW5kZXJzdMO4dHRlciBrb252ZXJ0ZXJpbmcgYWYgYWZzdGFuZCwgaGFzdGlnaGVkIG9nIHRlbXBlcmF0dXIuXCIsXG5cdFx0dmVjdG9yRmllbGROYW1lOiBcIlZla3RvcmZlbHRcIixcblx0XHR2ZWN0b3JGaWVsZFNuaXA6IFwiVmlzZXIgZGF0YXPDpnQgbWVkIGLDpWRlIHN0w7hycmVsc2UgKHUpIG9nIHJldG5pbmcgKHYpIHNvbSBwaWxlLCBodm9yIHN0w7hycmVsc2VuIGVyIHJlcHLDpnNlbnRlcmV0IGFmIHN0w7hycmVsc2Ugb2cgcmV0bmluZ2VuIGVyIHJlcHLDpnNlbnRlcmV0IGFmIHBpbGVucyB2aW5rZWwuXCIsXG5cdFx0dmVjdG9yRmllbGREZXNjOiBcIkZ1bmt0aW9uZW4gVmVrdG9yZmVsdCBicnVnZXMgdGlsIGF0IHNhbW1lbnPDpnR0ZSBvZyBrb252ZXJ0ZXJlIHRvIHJhc3RlciB0aWwgZW4gdG9iw6VuZHNyYXN0ZXIsIGRlciBlbnRlbiBoYXIgZGF0YXR5cGVuIFN0w7hycmVsc2UtUmV0bmluZyBlbGxlciBkYXRhdHlwZW4gVVYuPGRpdj48YnIvPlUtdsOmcmRpZW4gYmV0ZWduZXMgdW5kZXJ0aWRlbiBzb20gem9uZWhhc3RpZ2hlZGVuLCBvZyBWLXbDpnJkaWVuIGJldGVnbmVzIHVuZGVydGlkZW4gc29tIG1lcmlkaW9uYWxoYXN0aWdoZWRlbi48L2Rpdj5cIixcblx0XHR2aWV3c2hlZDJOYW1lOiBcIlN5bnNmZWx0XCIsXG5cdFx0dmlld3NoZWQyU25pcDogXCJCZXN0ZW1tZXIsIGh2aWxrZSBwbGFjZXJpbmdlciBhZiByYXN0ZXJvdmVyZmxhZGVyLCBkZXIgZXIgc3lubGlnZSBmb3IgZXQgc8OmdCBvYnNlcnZhdMO4ci1vYmpla3RlciB2ZWQgaGrDpmxwIGFmIGdlb2TDpnRpc2tlIG1ldG9kZXIuXCIsXG5cdFx0dmlld3NoZWQyRGVzYzogXCJGdW5rdGlvbmVuIFN5bnNmZWx0IGJlc3RlbW1lciwgaHZpbGtlIHBsYWNlcmluZ2VyIGFmIHJhc3Rlcm92ZXJmbGFkZXIsIGRlciBlciBzeW5saWdlIGZvciBldCBzw6Z0IG9ic2VydmF0w7hyLW9iamVrdGVyIHZlZCBoasOmbHAgYWYgZ2VvZMOmdGlza2UgbWV0b2RlcjxkaXY+PGJyLz5TaWd0YmFyaGVkZW4gYWYg4oCL4oCLaHZlcnQgcGl4ZWxjZW50ZXIgYmVzdGVtbWVzIGFmIGVuIHN5bnNsaW5qZXRlc3QgbWVsbGVtIG3DpWxldCBvZyBodmVyIGVua2VsdCBvYnNlcnZhdMO4ci4gSHZpcyBlbiBvYnNlcnZhdMO4ciBrYW4gc2UgbcOlbGV0IHZlZCBwaXhlbGNlbnRyZXQsIGJldHJhZ3RlcyBlbiBwaXhlbCBzb20gc3lubGlnLiBEZXR0ZSB2w6Zya3TDuGogdGFnZXIgYWx0aWQgaGVuc3luIHRpbCBqb3JkZW5zIGtydW1uaW5nLCBuw6VyIHN5bmxpZ2hlZGVuIGZhc3Rsw6ZnZ2VzLjwvZGl2PlwiLFxuXHRcdHdhdGVyc2hlZE5hbWU6IFwiVmFuZHNrZWxcIixcblx0XHR3YXRlcnNoZWRTbmlwOiBcIkZhc3Rsw6ZnZ2VyIGRldCBiaWRyYWdlbmRlIG9tcsOlZGUsIGRlciBsaWdnZXIgb3ZlciBldCBzw6Z0IHBpeGVscyBpIGVuIHJhc3RlclwiLFxuXHRcdHdhdGVyc2hlZERlc2M6IFwiRGVuIGdsb2JhbGUgZnVua3Rpb24gVmFuZHNrZWwgZmFzdGzDpmdnZXIgZGV0IGJpZHJhZ2VuZGUgb21yw6VkZSwgZGVyIGxpZ2dlciBvdmVyIGV0IHPDpnQgcGl4ZWxzIGkgZW4gcmFzdGVyLiBWYW5kc2tlbCBhZiBtYXJrZXJldCB1ZCBmcmEgZW4gc3Ryw7htcmV0bmluZ3NyYXN0ZXIsIGRlciBpZGVudGlmaWNlcmVyIHN0csO4bXJldG5pbmdlbiB1ZCBmcmEgaHZlciBwaXhlbC5cIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlOYW1lOiBcIlbDpmd0ZXQgb3ZlcmxheVwiLFxuXHRcdHdlaWdodGVkT3ZlcmxheVNuaXA6IFwiTMOmZ2dlciBmbGVyZSByYXN0ZXIgb3ZlbiBww6UgaGluYW5kZW4gZWQgaGrDpmxwIGFmIGVuIGbDpmxsZXMgbcOlbGVza2FsYSBvZyB2w6ZndCBpIG92ZXJlbnNzdGVtbWVsc2UgbWVkIGRlcmVzIGluZGl2aWR1ZWxsZSB2aWd0aWdoZWQuXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5RGVzYzogXCJEZW5uZSBmdW5rdGlvbiBnw7hyIGRldCBtdWxpZ3QgYXQgbMOmZ2dlIGZsZXJlIHJhc3RlciBvdmVuIHDDpSBoaW5hbmRlbiB2ZWQgaGrDpmxwIGFmIGVuIGbDpmxsZXMgbcOlbGVza2FsYSBvZyB2w6ZndCBpIG92ZXJlbnNzdGVtbWVsc2UgbWVkIGRlcmVzIGluZGl2aWR1ZWxsZSB2aWd0aWdoZWQuXCIsXG5cdFx0d2VpZ2h0ZWRTdW1OYW1lOiBcIlbDpmd0ZXQgc3VtXCIsXG5cdFx0d2VpZ2h0ZWRTdW1TbmlwOiBcIlbDpmd0ZXIgb2cgdGlsZsO4amVyIGVuIGFycmF5IGFmIHJhc3RlciBjZWxsZSBmb3IgY2VsbGUuXCIsXG5cdFx0d2VpZ2h0ZWRTdW1EZXNjOiBcIkZ1bmt0aW9uZW4gVsOmZ3RldCBzdW0gZ2l2ZXIgbXVsaWdoZWQgZm9yIGF0IHVkZsO4cmUgb3ZlcmxheSBww6UgZmxlcmUgcmFzdGVyLCBtdWx0aXBsaWNlcmUgaHZlciBlbmtlbHQgbWVkIGRlcmVzIGdpdm5lIHbDpmd0IG9nIGzDpmdnZSBkZW0gc2FtbWVuLlwiLFxuXHRcdHdpbmRjaGlsbE5hbWU6IFwiVmluZGFma8O4bGluZ1wiLFxuXHRcdHdpbmRjaGlsbFNuaXA6IFwiS29tYmluZXJlciBkZW4gb21naXZlbmRlIHRlbXBlcmF0dXIgb2cgdmluZGhhc3RpZ2hlZCBmb3IgYXQgYmVyZWduZSBWaW5kYWZrw7hsaW5nc2Zha3RvcmVuLlwiLFxuXHRcdHdpbmRjaGlsbERlc2M6IFwiRnVua3Rpb25lbiBWaW5kYWZrw7hsaW5nIGVyIG55dHRpZyB0aWwgYXQgaWRlbnRpZmljZXJlIGZhcmxpZ2UgdmludGVyZm9yaG9sZCwgZGVyIGthbiByZXN1bHRlcmUgaSBmb3JmcnlzbmluZ2VyIGVsbGVyIGVuZG9nIGh5cG90ZXJtaSwgYWZow6ZuZ2lnIGFmIGh2b3IgbMOmbmdlIG1hbiB1ZHPDpnR0ZXMgZm9yIGVsZW1lbnRlcm5lLiBWaW5kYWZrw7hsaW5nIGVyIGVuIG3DpWRlIGF0IG3DpWxlIHDDpSwgaHZvciBrb2xkdCBlbiBwZXJzb24gZsO4bGVyIGRldCwgbsOlciBkZXIgdGFnZXMgaGVuc3luIHRpbCB2aW5kZW4gdmVkIGtvbGRlIHRlbXBlcmF0dXJlci4gSm8gc3TDuHJyZSB2aW5kaGFzdGlnaGVkLCBqbyBodXJ0aWdlcmUgbWlzdGVyIGtyb3BwZW4gdmFybWUsIG9nIGpvIGtvbGRlcmUgZGV0IHZpbCBmw7hsZXMuXCIsXG5cdFx0em9uYWxSZW1hcE5hbWU6IFwiR2VuYmVyZWduaW5nIGFmIHpvbmVyXCIsXG5cdFx0em9uYWxSZW1hcFNuaXA6IFwiR2VuYmVyZWduZXIgcGl4ZWxzIGkgZW4gcmFzdGVyIGJhc2VyZXQgcMOlIHpvbmVyLCBkZXIgZXIgZGVmaW5lcmV0IGkgZW4gYW5kZW4gcmFzdGVyLCBvZyB6b25lLWFmaMOmbmdpZyB2w6ZyZGkta29ydGzDpmduaW5nLCBkZXIgZXIgZGVmaW5lcmV0IGkgZW4gdGFiZWwuXCIsXG5cdFx0em9uYWxSZW1hcERlc2M6IFwiRGVubmUgZnVua3Rpb24gZ2l2ZXIgbXVsaWdoZWQgZm9yIGF0IGdlbmJlcmVnbmUgcGl4ZWxzIGkgZW4gcmFzdGVyIGJhc2VyZXQgcMOlIHpvbmVyLCBkZXIgZXIgZGVmaW5lcmV0IGkgZW4gYW5kZW4gcmFzdGVyLCBvZyB6b25lLWFmaMOmbmdpZyB2w6ZyZGkta29ydGzDpmduaW5nLCBkZXIgZXIgZGVmaW5lcmV0IGkgZW4gdGFiZWwuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzTmFtZTogXCJab25lc3RhdGlzdGlrXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzU25pcDogXCJCZXJlZ25lciBzdGF0aXN0aWsgZm9yIHbDpnJkaWVyIGkgZW4gcmFzdGVyIGluZGVuIGZvciB6b25lcm5lIGkgZXQgYW5kZXQgZGF0YXPDpnQuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzRGVzYzogXCJGdW5rdGlvbmVuIGJlcmVnbmVyIHN0YXRpc3RpayBmb3IgdsOmcmRpZXIgaSBlbiByYXN0ZXIgaW5kZW4gZm9yIHpvbmVybmUgaSBldCBhbmRldCBkYXRhc8OmdC4gRW4gem9uZSBlciBkZWZpbmVyZXQgc29tIGFsbGUgb21yw6VkZXIgaSBpbnB1dHRldCwgZGVyIGhhciBzYW1tZSB2w6ZyZGkuIERpc3NlIG9tcsOlZGVyIGJlaMO4dmVyIGlra2UgYXQgc3TDuGRlIG9wIHRpbCBoaW5hbmRlbi4gTsOlciB6b25lLSBvZyB2w6ZyZGktaW5wdXQgYmVnZ2UgZXIgcmFzdGVyIG1lZCBzYW1tZSBvcGzDuHNuaW5nLCBicnVnZXMgZGUgZGlyZWt0ZS4gSHZpcyBvcGzDuHNuaW5nZXJuZSBlciBmb3Jza2VsbGlnZSwgYW52ZW5kZXMgZW4gaW50ZXJuIG9tc3RydWt0dXJlcmluZyBmb3IgYXQgZ8O4cmUgb3Bsw7hzbmluZ2VybmUgZW5zLCBpbmRlbiB6b25lb3BlcmF0aW9uZW4gdWRmw7hyZXMuXCIsXG5cdFx0Zmxvd0xlbmd0aE5hbWU6IFwiRmxvdy1sw6ZuZ2RlXCIsXG5cdFx0Zmxvd0xlbmd0aFNuaXA6IFwiQmVyZWduZXIgb3BzdHLDuG1zLSBlbGxlciBuZWRzdHLDuG1zYWZzdGFuZGVuIGVsbGVyIGRlbiB2w6ZndGVkZSBhZnN0YW5kIGxhbmdzIHN0csO4bW5pbmdzdmVqZW4gZm9yIGh2ZXIgY2VsbGUuXCIsXG5cdFx0Zmxvd0xlbmd0aERlc2M6IFwiRGV0dGUgZXIgZW4gZ2xvYmFsIHJhc3RlcmZ1bmt0aW9uLiBEZW5uZSBmdW5rdGlvbiBvcHJldHRlciBldCByYXN0ZXJsYWcgbWVkIG9wc3Ryw7htcy0gZWxsZXIgbmVkc3Ryw7htc2Fmc3RhbmQgZWxsZXIgdsOmZ3RldCBhZnN0YW5kIGxhbmdzIHN0csO4bW5pbmdzdmVqZW4gZm9yIGh2ZXIgY2VsbGUuPGRpdj48YnIvPkVuIHByaW3DpnIgYW52ZW5kZWxzZSBhZiBmdW5rdGlvbmVuIEZsb3ctbMOmbmdkZSBlciBhdCBiZXJlZ25lIGzDpm5nZGVuIGFmIOKAi+KAi2RlbiBsw6ZuZ3N0ZSBzdHLDuG1uaW5nc3ZlaiBpbmRlbiBmb3IgZXQgZ2l2ZXQgYmFzc2luLiBEZW5uZSBtw6VsaW5nIGJydWdlcyBvZnRlIHRpbCBhdCBiZXJlZ25lIGtvbmNlbnRyYXRpb25zdGlkZW4gZm9yIGV0IGJhc3Npbi4gRGV0dGUgZ8O4cmVzIHZlZCBoasOmbHAgYWYgaW5kc3RpbGxpbmdlbiBPcHN0csO4bXMuIEZ1bmt0aW9uZW4ga2FuIG9nc8OlIGJydWdlcyB0aWwgYXQgb3ByZXR0ZSBhZnN0YW5kc2RpYWdyYW1tZXIgb3ZlciBoeXBvdGV0aXNrIG5lZGLDuHIgb2cgYWZzdHLDuG1uaW5nc2jDpm5kZWxzZXIgdmVkIGhqw6ZscCBhZiB2w6ZndHJhc3RlcmVuIHNvbSBlbiBpbXBlZGFucyBmb3IgbmVkYWRnw6VlbmRlIGJldsOmZ2Vsc2UuPC9kaXY+XCIsXG5cdFx0c3RyZWFtT3JkZXJOYW1lOiBcIlN0csO4bXLDpmtrZWbDuGxnZVwiLFxuXHRcdHN0cmVhbU9yZGVyU25pcDogXCJUaWxkZWxlciBlbiBudW1lcmlzayByw6Zra2Vmw7hsZ2UgdGlsIHNlZ21lbnRlciBpIGVuIHJhc3RlciwgZGVyIHJlcHLDpnNlbnRlcmVyIGdyZW5lIGkgZXQgbGluZcOmcnQgbmV0dsOmcmtcIixcblx0XHRzdHJlYW1PcmRlckRlc2M6IFwiRGV0dGUgZXIgZW4gZ2xvYmFsIHJhc3RlcmZ1bmt0aW9uLiBEZW5uZSBmdW5rdGlvbiBvcHJldHRlciBldCByYXN0ZXJsYWcsIGRlciB0aWxkZWxlciBlbiBudW1lcmlzayByw6Zra2Vmw7hsZ2UgdGlsIHNlZ21lbnRlciBpIGVuIHJhc3RlciwgZGVyIHJlcHLDpnNlbnRlcmVyIGdyZW5lIGkgZXQgbGluZcOmcnQgbmV0dsOmcmsuPGRpdj48YnIvPk91dHB1dHRldCBmcmEgZnVua3Rpb25lbiBTdHLDuG1yw6Zra2Vmw7hsZ2UgdmlsIHbDpnJlIGFmIGjDuGplcmUga3ZhbGl0ZXQsIGh2aXMgaW5wdXQgc3Ryw7htLXJhc3RlcmxhZ2V0IG9nIGlucHV0LWZsb3dyZXRuaW5ncy1yYXN0ZXJsYWdldCBlciBhZmxlZHQgZnJhIHNhbW1lIG92ZXJmbGFkZS4gSHZpcyBzdHLDuG1yYXN0ZXJlbiBlciBhZmxlZHQgZnJhIGV0IHJhc3RlcmlzZXJldCBzdHLDuG1zZGF0YXPDpnQsIGVyIG91dHB1dCBtdWxpZ3ZpcyBpa2tlIGFudmVuZGVsaWd0LCBmb3JkaSByZXRuaW5nZW4sIGNlbGxlIGZvciBjZWxsZSwgaWtrZSBzdmFyZXIgdGlsIHBsYWNlcmluZ2VuIGFmIHN0csO4bWNlbGxlci4gUmVzdWx0YXRlcm5lIGFmIGZ1bmt0aW9uZW4gRmxvdy1ha2t1bXVsZXJpbmcga2FuIGJydWdlcyB0aWwgYXQgc2thYmUgZXQgcmFzdGVyIHN0csO4bS1uZXR2w6ZyayB2ZWQgYXQgYW52ZW5kZSBlbiB0w6Zyc2tlbHbDpnJkaSB0aWwgYXQgdsOmbGdlIGNlbGxlciBtZWQgZXQgaMO4aiBha2t1bXVsZXJldCBmbG93LiBGLmVrcy4gYnJ1Z2VzIGNlbGxlciwgaHZvciBtZXJlIGVuZCAxMDAgY2VsbGVyIHN0csO4bW1lciBpbmQgaSBkZW0sIHRpbCBhdCBkZWZpbmVyZSBzdHLDuG0tbmV0dsOmcmtldC4gQnJ1ZyBmdW5rdGlvbmVybmUgQmV0aW5nZXQgZWxsZXIgQW5naXYgbnVsIHRpbCBhdCBvcHJldHRlIGVuIHN0csO4bW5ldHbDpnJrc3Jhc3RlciwgaHZvciBmbG93YWtrdW11bGVyaW5nc3bDpnJkaWVyIHDDpSAxMDAgZWxsZXIgZGVyb3ZlciBnw6VyIHRpbCBlbiwgb2cgcmVzdGVuIHNlbmRlcyBpIGJhZ2dydW5kZW4gKE5vRGF0YSkuIERldCByZXN1bHRlcmVuZGUgc3Ryw7htbmV0dsOmcmsga2FuIGJydWdlcyBpIGZ1bmt0aW9uZW4gU3Ryw7htcsOma2tlZsO4bGdlLiBEZW5uZSBmdW5rdGlvbiB1bmRlcnN0w7h0dGVyIGt1biBldCBEOC1pbnB1dGZsb3ctcmV0bmluZ3MtcmFzdGVybGFnLiBEOC1mbG93cmV0bmluZ2VyIGthbiBvcHJldHRlcyB2ZWQgaGrDpmxwIGFmIGZ1bmt0aW9uZW4gRmxvd3JldG5pbmcgb2cga8O4cmVzIG1lZCBzdGFuZGFyZGZsb3dyZXRuaW5nc3R5cGVuIEQ4LjwvZGl2PlwiLFxuXHRcdHNuYXBQb3VyUG9pbnROYW1lOiBcIkZhc3Rnw7hyIHB1bmt0IGZvciB2YW5kbMO4YnNyZXRuaW5nXCIsXG5cdFx0c25hcFBvdXJQb2ludFNuaXA6IFwiRmFzdGfDuHIgcHVua3RlciBmb3IgdmFuZGzDuGJzcmV0bmluZyB0aWwgY2VsbGVuIG1lZCBow7hqZXN0ZSBmbG93YWtrdW11bGVyaW5nIGluZGVuIGZvciBlbiBzcGVjaWZpY2VyZXQgYWZzdGFuZFwiLFxuXHRcdHNuYXBQb3VyUG9pbnREZXNjOiBcIkRldHRlIGVyIGVuIGdsb2JhbCByYXN0ZXJmdW5rdGlvbi4gRGVubmUgZnVua3Rpb24gZmFzdGfDuHIgcHVua3RlciBmb3IgdmFuZGzDuGJzcmV0bmluZyB0aWwgY2VsbGVuIG1lZCBow7hqZXN0ZSBmbG93YWtrdW11bGVyaW5nIGluZGVuIGZvciBlbiBzcGVjaWZpY2VyZXQgYWZzdGFuZC48ZGl2Pjxici8+RnVua3Rpb25lbiBGYXN0Z8O4ciBwdW5rdCBmb3IgdmFuZGzDuGJzcmV0bmluZyBicnVnZXMgdGlsIGF0IHNpa3JlIHZhbGdldCBhZiBwdW5rdGVyIG1lZCBow7hqdCBha2t1bXVsZXJldCBmbG93IHZlZCBhZmdyw6Zuc25pbmcgYWYgZHLDpm5pbmdzYmFzc2luZXIgdmVkIGhqw6ZscCBhZiBmdW5rdGlvbmVuIFZhbmRza2VsLiBGYXN0Z8O4ciBwdW5rdCBmb3IgdmFuZGzDuGJzcmV0bmluZyBzw7hnZXIgaW5kZW4gZm9yIGZhc3Rnw7hyZWxzZXNhZnN0YW5kZW4gb21rcmluZyBkZSBzcGVjaWZpY2VyZWRlIHB1bmt0ZXIgZm9yIHZhbmRsw7hic3JldG5pbmcgZm9yIGNlbGxlbiBtZWQgZGV0IGjDuGplc3RlIGFra3VtdWxlcmVkZSBmbG93IG9nIGZseXR0ZXIgcHVua3RldCBmb3IgdmFuZGzDuGJzcmV0bmluZyB0aWwgZGV0IHN0ZWQuIE91dHB1dCBlciBldCBoZWx0YWwtcmFzdGVybGFnLCBuw6VyIGRlIG9yaWdpbmFsZSBwbGFjZXJpbmdlciBmb3IgcHVua3RlciBmb3IgdmFuZGzDuGJzcmV0bmluZyBlciBibGV2ZXQgZmFzdGdqb3J0IHRpbCBzdGVkZXIgbWVkIGjDuGplcmUgYWtrdW11bGVyZXQgZmxvdy48L2Rpdj5cIixcblx0XHRzaW5rTmFtZTogXCJGb3JkeWJuaW5nXCIsXG5cdFx0c2lua1NuaXA6IFwiT3ByZXR0ZXIgZW4gcmFzdGVyLCBkZXIgaWRlbnRpZmljZXJlciBhbGxlIGZvcmR5Ym5pbmdlciBlbGxlciBvbXLDpWRlciBtZWQgaW50ZXJuIGRyw6ZuaW5nXCIsXG5cdFx0c2lua0Rlc2M6IFwiRGV0dGUgZXIgZW4gZ2xvYmFsIHJhc3RlcmZ1bmt0aW9uLiBEZW5uZSBmdW5rdGlvbiBza2FiZXIgZXQgcmFzdGVybGFnLCBkZXIgaWRlbnRpZmljZXJlciBhbGxlIGZvcmR5Ym5pbmdlciBlbGxlciBvbXLDpWRlciBtZWQgaW50ZXJuIGRyw6ZuaW5nLiBFbiBmb3JkeWJuaW5nZXIgZXIgZW4gY2VsbGUgZWxsZXIgZXQgc8OmdCBzcGF0aWFsdCBmb3JidW5kbmUgY2VsbGVyIG1lZCBlbiBmbG93cmV0bmluZywgZGVyIGlra2Uga2FuIHRpbGRlbGVzIGVuIGFmIGRlIG90dGUgZ3lsZGlnZSB2w6ZyZGllciBpIGVuIGZsb3dyZXRuaW5nc3Jhc3Rlci4gRGV0dGUga2FuIG9wc3TDpSwgbsOlciBhbGxlIHRpbHN0w7hkZW5kZSBjZWxsZXIgZXIgaMO4amVyZSBlbmQgYmVoYW5kbGluZ3NjZWxsZW4sIGVsbGVyIG7DpXIgdG8gY2VsbGVyIHN0csO4bW1lciBpbmQgaSBoaW5hbmRlbiwgaHZpbGtldCBza2FiZXIgZW4gdG8tY2VsbGUtc2zDuGpmZS48ZGl2Pjxici8+RnVua3Rpb25lbiBGb3JkeWJuaW5nIHVuZGVyc3TDuHR0ZXIga3VuIGV0IEQ4LWlucHV0Zmxvdy1yYXN0ZXJsYWcuIEQ4LWZsb3dyZXRuaW5nZXIga2FuIG9wcmV0dGVzIHZlZCBoasOmbHAgYWYgZnVua3Rpb25lbiBGbG93cmV0bmluZyBvZyBrw7hyZXMgbWVkIHN0YW5kYXJkIGZsb3dyZXRuaW5nc3R5cGVuIEQ4LiBPdXRwdXR0ZXQgZnJhIGZ1bmt0aW9uZW4gRm9yZHlibmluZyBlciBlbiBoZWx0YWwtcmFzdGVyLCBodm9yIGh2ZXIgZm9yZHlibmluZyB0aWxkZWxlcyBlbiB1bmlrIHbDpnJkaS4gRGlzc2UgdW5pa2tlIHbDpnJkaWVyIGhhciBldCBpbnRlcnZhbCBtZWxsZW0gZXQgb2cgZGV0IHNhbWxlZGUgYW50YWwgZm9yZHlibmluZ2VyLiBIdmlzIGRldCBzYW1sZWRlIGFudGFsIGRyw6ZuIGYuZWtzLiBlciAxMDAwLCBzw6Ugc3DDpm5kZXIgZGUgdW5pa2tlIHbDpnJkaWVyIGZyYSAxIHRpbCAxMDAwLjwvZGl2PlwiLFxuXHRcdGFnZ3JlZ2F0ZU5hbWU6IFwiQWdncmVnw6lyXCIsXG5cdFx0YWdncmVnYXRlU25pcDogXCJHZW5lcmVyZXIgZW4gdmVyc2lvbiBhZiBlbiByYXN0ZXIgbWVkIGxhdmVyZSBvcGzDuHNuaW5nLlwiLFxuXHRcdGFnZ3JlZ2F0ZURlc2M6IFwiRnVua3Rpb25lbiBBZ2dyZWfDqXIgb21zdHJ1a3R1cmVyZXIgZW4gaW5wdXQtcmFzdGVyIHRpbCBlbiBncm92ZXJlIG9wbMO4c25pbmcgYmFzZXJldCBww6UgZW4gc3BlY2lmaWNlcmV0IGFnZ3JlZ2VyaW5nc3N0cmF0ZWdpLiBFbmh2ZXIgb3V0cHV0LWNlbGxlIGluZGVob2xkZXIgU3VtLCBNaW5pbXVtLCBNYWtzaW11bSwgTWlkZGVsdsOmcmRpIGVsbGVyIE1lZGlhbiBmb3IgZGUgaW5wdXQtY2VsbGVyLCBzb20gZXIgb21naXZldCBhZiBkZW4gcMOlZ8OmbGRlbmRlIGNlbGxlcyB1ZHN0csOma25pbmcuPGRpdj48YnIvPkR1IGthbiBhbmdpdmUgZGVuIGZha3Rvciwgc29tIGlucHV0LXJhc3RlcmVucyBjZWxsZXN0w7hycmVsc2Ugc2thbCBnYW5nZXMgbWVkLiBGb3IgZWtzZW1wZWwgdmlsIGVuIGNlbGxlZmFrdG9yIHDDpSAzIHJlc3VsdGVyZSBpIGVuIG91dHB1dC1jZWxsZXN0w7hycmVsc2UsIGRlciBlciBlciAzIGdhbmdlIHN0w7hycmUgZW5kIGlucHV0LXJhc3RlcmVucyBjZWxsZXN0w7hycmVsc2UuIER1IGthbiBkZWZpbmVyZSwgaHZvcmRhbiBvdXRwdXR0ZXRzIHVkc3Ryw6ZrbmluZyBza2FsIGjDpW5kdGVyZXMsIGh2aXMgYW50YWxsZXQgYWYgcsOma2tlciBlbGxlciBrb2xvbm5lciBpIGlucHV0dGV0IGlra2UgZXIgbsO4amFndGlnIG11bHRpcGVsIGFmIGNlbGxlZmFrdG9yZW4uIFNvbSBzdGFuZGFyZCB2aWwgZGUgw7h2ZXJzdGUgb2cgaMO4anJlIGdyw6Zuc2VyIGJsaXZlIHVkdmlkZXQgdGlsIGF0IGTDpmtrZSBlbiBzdMO4cnJlIHNwYXRpYWwgdWRzdHLDpmtuaW5nIGVuZCBpbnB1dC1yYXN0ZXJlbiBmb3IgYXQgc2lrcmUsIGF0IGFsbGUgaW5wdXQtY2VsbGVybmUgYmVoYW5kbGVzLiBEZSDDuHZlcnN0ZSBvZyBow7hqcmUgZ3LDpm5zZXIga2FuIG9nc8OlIHJlZHVjZXJlcyBtZWQgaGVuYmxpayBww6UgYXQgZMOma2tlIGVuIG1pbmRyZSB1ZHN0csOma25pbmcsIHPDpSBhbnRhbGxldCBhZiByw6Zra2VyIG9nIGtvbG9ubmVyIGVyIGVuIG7DuGphZ3RpZyBtdWx0aXBlbCBhZiBjZWxsZWZha3RvcmVuLiBEdSBrYW4gZGVmaW5lcmUsIGh2b3JkYW4gTm9EYXRhLWNlbGxlciBza2FsIGJlaGFuZGxlcyBhZiBhZ2dyZWdlcmluZ3NiZXJlZ25pbmdlbi4gU3RhbmRhcmRtZWthbmlzbWVuIGVyLCBhdCBpbnB1dC1Ob0RhdGEtY2VsbGVyLCBkZXIgZmFsZGVyIGluZGVuIGZvciBkZW4gc3BhdGlhbGUgdWRzdHLDpmtuaW5nIGFmIGVuIHN0w7hycmUgY2VsbGUgaSBvdXRwdXQtcmFzdGVyZW4sIHZpbCBibGl2ZSB0aWxzaWRlc2F0LCBuw6VyIGRlbiBww6Vnw6ZsZGVuZGUgb3V0cHV0LWNlbGxlcyB2w6ZyZGkgc2thbCBmYXN0c8OmdHRlcy4gRHUga2FuIG9nc8OlIGFuZ2l2ZSwgYXQgaHZpcyBkZXIgYmxvdCBlciBlbiBlbmtlbHQgaW5wdXQtTm9EYXRhLWNlbGxlIGluZGVuIGZvciBkZW4gc3BhdGlhbGUgdWRzdHLDpmtuaW5nIGFmIGVuIG91dHB1dC1jZWxsZSwgdmlsIGRlbm5lIGNlbGxlIHbDpnJlIGVuIE5vRGF0YS1jZWxsZSBpIG91dHB1dC1yYXN0ZXJlbi48L2Rpdj5cIixcblx0XHRjY2RjTmFtZTogXCJDQ0RDLWFuYWx5c2VcIixcblx0XHRjY2RjU25pcDogXCJFdmFsdWVyZXIgw6ZuZHJpbmdlciBpIHBpeGVsdsOmcmRpZXIgb3ZlciB0aWQgdmVkIGhqw6ZscCBhZiBhbGdvcml0bWVuIENvbnRpbnVvdXMgQ2hhbmdlIERldGVjdGlvbiBhbmQgQ2xhc3NpZmljYXRpb24gKENDREMpIG9nIGdlbmVyZXJlciBtb2RlbHJlc3VsdGF0ZXIuXCIsXG5cdFx0Y2NkY0Rlc2M6IFwiRnVua3Rpb25lbiBDQ0RDLWFuYWx5c2UgZXZhbHVlcmVyIMOmbmRyaW5nZXIgaSBwaXhlbHbDpnJkaWVyIG92ZXIgdGlkIHZlZCBoasOmbHAgYWYgYWxnb3JpdG1lbiBDb250aW51b3VzIENoYW5nZSBEZXRlY3Rpb24gYW5kIENsYXNzaWZpY2F0aW9uIChDQ0RDKSBvZyBnZW5lcmVyZXIgZW4gZmxlcmRpbWVuc2lvbmFsIHJhc3RlciwgZGVyIGluZGVob2xkZXIgbW9kZWxyZXN1bHRhdGVyLiBEZW4gdW5kZXJzdMO4dHRlcyB1ZGVsdWtrZW5kZSBpIHNhbW1lbmjDpm5nIG1lZCBmdW5rdGlvbmVuIERldGVrdMOpciDDpm5kcmluZyB2ZWQgaGrDpmxwIGFmIMOmbmRyaW5nc2FuYWx5c2UgaSBlbiByYXN0ZXJmdW5rdGlvbnNza2FiZWxvbi4gSHZpcyBkdSB2aWwgZ2VuZXJlcmUgZXQgcmFzdGVyLW91dHB1dCwgc2thbCBkdSBrbnl0dGUgZnVua3Rpb25lbiBDQ0RDLWFuYWx5c2UgdGlsIGZ1bmt0aW9uZW4gRGV0ZWt0w6lyIMOmbmRyaW5nIHZlZCBoasOmbHAgYWYgw6ZuZHJpbmdzYW5hbHlzZSwgZ2VtbWUgZGVuIHNvbSBlbiByYXN0ZXJmdW5rdGlvbnNza2FiZWxvbiBvZyBrw7hyZSByYXN0ZXJhbmFseXNlIHNhbW1lbiBtZWQgZnVua3Rpb25zc2thYmVsb25lbi48ZGl2Pjxici8+RGVubmUgZnVua3Rpb24gYW52ZW5kZXIgYWxnb3JpdG1lbiBDb250aW51b3VzIENoYW5nZSBEZXRlY3Rpb24gYW5kIENsYXNzaWZpY2F0aW9uIChDQ0RDKSB0aWwgYXQgZXZhbHVlcmUgw6ZuZHJpbmdlciBpIHBpeGVsdsOmcmRpZXIgb3ZlciB0aWQgZm9yIGVuIHN0YWsgYmlsbGVkZXIuIEkgZW4gdGlkc3NlcmllIG1lZCBvcHRpc2tlIGJpbGxlZGVyIGVsbGVyIGFmbGVkdGUgYmlsbGVkZXIgKGYuZWtzLiBORFZJKSBrYW4gcGl4ZWx2w6ZyZGllcm5lIHZhcmllcmUgYWYgZmxlcmUgw6Vyc2FnZXI6IDEuIFPDpnNvbmJlc3RlbXQgw6ZuZHJpbmcg4oCTIMOGbmRyaW5nZXIgaSBwaXhlbHbDpnJkaWVybmUgcmVmbGVrdGVyZXIgw6ZuZHJpbmdlciBpIHZlZ2V0YXRpb25lbiBww6UgZ3J1bmQgYWYgc8Omc29uYmVzdGVtdGUgdmFyaWF0aW9uZXIgaSB0ZW1wZXJhdHVyIG9nIG5lZGLDuHIuIFDDpSBkZW4gbm9yZGxpZ2UgaGFsdmt1Z2xlIGZvcnZlbnRlciB2aSBmLmVrcy4gYXQgc2UgZW4gaMO4amVyZSB0w6Z0aGVkIGFmIGdyw7huIHZlZ2V0YXRpb24gb20gc29tbWVyZW4gZW5kIG9tIHZpbnRlcmVuOyAyLiBHcmFkdmlzIMOmbmRyaW5nIOKAkyDDhm5kcmluZ2VyIGkgcGl4ZWx2w6ZyZGllcm5lIHJlZmxla3RlcmVyIHRlbmRlbnNlciBpIHZlZ2V0YXRpb24gZWxsZXIgb3ZlcmZsYWRldmFuZCBww6UgZ3J1bmQgYWYga2xpbWF2YXJpYXRpb24gZWxsZXIgYXJlYWxmb3J2YWx0bmluZ3NwcmFrc2lzIG92ZXIgbGFuZyB0aWQuIEZvciBla3NlbXBlbCBrYW4gb21mYW5nZXQgYWYgam9yZGJ1bmQgdWRlbiBiZXZva3NuaW5nIHZva3NlIGdyYWR2aXN0IHDDpSBncnVuZCBhZiBuZWRnYW5nIGkgbmVkYsO4cnNtw6ZuZ2Rlcm5lIG92ZXIgbGFuZyB0aWQ7IG9nIDMuIFBsdWRzZWxpZyDDpm5kcmluZyDigJMgw4ZuZHJpbmdlciBpIHBpeGVsdsOmcmRpZXJuZSByZWZsZWt0ZXJlciDDpm5kcmluZ2VyIGkgYXJlYWxkw6Zra2UsIGRlciBvcHN0w6VyIHBsdWRzZWxpZ3QgcGdhLiBza292cnlkbmluZywgYnl1ZHZpa2xpbmcsIG5hdHVya2F0YXN0cm9mZXIgb3N2LiBDQ0RDLWFsZ29yaXRtZW4gaWRlbnRpZmljZXJlciBhbGxlIHRyZSDDpm5kcmluZ3N0eXBlciBtZWQgZGV0IHByaW3DpnJlIGZvcm3DpWwgYXQgaWRlbnRpZmljZXJlIHBsdWRzZWxpZ2Ugw6ZuZHJpbmdlci4gSGFybW9uaXNrZSByZWdyZXNzaW9ucy0gb2cgdGVuZGVuc21vZGVsbGVyIGtueXR0ZXMgdGlsIGRhdGFlbmUgbWVkIGhlbmJsaWsgcMOlIGF0IGJlcmVnbmUgc8Omc29uYmVzdGVtdGUgZWxsZXIgZ3JhZHZpc2Ugw6ZuZHJpbmdlciwgb2cgcGx1ZHNlbGlndCBvcHN0w6VlZGUgYWZ2aWdlbHNlciBmcmEgdGVuZGVuc21vZGVsbGVybmUgZXIgaW5kaWthdGlvbiBww6UgcGx1ZHNlbGlnZSDDpm5kcmluZ2VyLjxkaXY+PGJyLz5DQ0RDLWFsZ29yaXRtZW4gYmxldiBvcHJpbmRlbGlndCB1ZHZpa2xldCB0aWwgTGFuZHNhdCBUTS0sIExhbmRzYXQgRVRNKy0gb2cgTGFuZHNhdCBPTEktZGF0YSwgU3VyZmFjZSBSZWZsZWN0YW5jZS0gZWxsZXIgQnJpZ2h0bmVzcyBUZW1wZXJhdHVyZS1kYXRhLiBEb2cgdmlsIGZ1bmt0aW9uZW4gRGV0ZWt0w6lyIMOmbmRyaW5nIHZlZCBoasOmbHAgYWYgw6ZuZHJpbmdzYW5hbHlzZSBzYW1tZW4gbWVkIGRlbm5lIGZ1bmt0aW9uIGRldGVrdGVyZSDDpm5kcmluZ2VyIGFmIGZsZXJiw6VuZHNiaWxsZWRlciBmcmEgZW5odmVyIHVuZGVyc3TDuHR0ZXQgc2Vuc29yIHNhbXQgYWZsZWR0ZSBlbmtlbHRiw6VuZHNiaWxsZWRlciwgc8Olc29tIGLDpW5kaW5kZWtzZXIuIER1IGthbiBmLmVrcy4gdWRmw7hyZSBrb250aW51ZXJsaWcgw6ZuZHJpbmdzZGV0ZWt0ZXJpbmcgcMOlIGVuIE5vcm1hbGl6ZSBEaWZmZXJlbmNlIFZlZ2V0YXRpb24gSW5kZXggKE5EVkkpLXJhc3RlciwgZm9yZGkgcGx1ZHNlbGlnZSDDpm5kcmluZ2VyIGkgTkRWSSBrYW4gaW5kaWtlcmUgc2tvdnJ5ZG5pbmcuPC9kaXY+XCIsXG5cdFx0Y29tcHV0ZUNoYW5nZU5hbWU6IFwiQmVyZWduIMOmbmRyaW5nXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZVNuaXA6IFwiQmVyZWduZXIgZm9yc2tlbGxlbiBww6UgdG8ga2F0ZWdvcmlza2UgZWxsZXIga29udGludWVybGlnZSByYXN0ZXJkYXRhc8OmdC5cIixcblx0XHRjb21wdXRlQ2hhbmdlRGVzYzogXCJGdW5rdGlvbmVuIEJlcmVnbiDDpm5kcmluZyBrYW4gYW52ZW5kZXMgdGlsIGF0IGJlcmVnbmUgZm9yc2tlbGxlbmUgcMOlIHRvIGtsYXNzaWZpY2VyZWRlIHJhc3RlcmUgZm9yIGFyZWFsZMOma2tlLcOmbmRyaW5nc2FuYWx5c2UsIGVsbGVyIGRlbiBrYW4gYW52ZW5kZXMgdGlsIGF0IHVuZGVyc8O4Z2Ugw6ZuZHJpbmdlciBtZWxsZW0gdG8gZW5rZWx0YsOlbmRzIGtvbnRpbnVlcmxpZ2UgcmFzdGVyZSwgc8Olc29tIGjDuGpkZSwgdGVtcGVyYXR1ciwga3JvbmVkw6ZrbmluZ3NncmFkIG9zdi5cIixcblx0XHRkZXRlY3RDaGFuZ2VOYW1lOiBcIkRldGVrdMOpciDDpm5kcmluZyB2ZWQgaGrDpmxwIGFmIMOmbmRyaW5nc2FuYWx5c2VcIixcblx0XHRkZXRlY3RDaGFuZ2VTbmlwOiBcIkdlbmVyZXJlciBldCByYXN0ZXJsYWcsIGRlciBpbmRlaG9sZGVyIG9wbHlzbmluZ2VyIG9tIHBpeGVsw6ZuZHJpbmdlciB2ZWQgYnJ1ZyBhZiBvdXRwdXQtw6ZuZHJpbmdzYW5hbHlzZXJhc3Rlci5cIixcblx0XHRkZXRlY3RDaGFuZ2VEZXNjOiBcIjxkaXY+RnVua3Rpb25lbiBEZXRla3TDqXIgw6ZuZHJpbmcgdmVkIGhqw6ZscCBhZiDDpm5kcmluZ3NhbmFseXNlIGdlbmVyZXJlciBldCByYXN0ZXJsYWcsIGRlciBpbmRlaG9sZGVyIG9wbHlzbmluZ2VyIG9tIHBpeGVsLWRhdG/Dpm5kcmluZ2VyIHZlZCBicnVnIGFmIMOmbmRyaW5nc2FuYWx5c2VyYXN0ZXIuIMOGbmRyaW5nc2FuYWx5c2VyYXN0ZXJlbiBza2FsIGdlbmVyZXJlcyBhZiB2w6Zya3TDuGpldCBBbmFseXPDqXIgw6ZuZHJpbmdlciB2ZWQgaGrDpmxwIGFmIENDREMgZWxsZXIgdsOmcmt0w7hqZXQgQW5hbHlzw6lyIMOmbmRyaW5nZXIgdmVkIGhqw6ZscCBhZiBMYW5kVHJlbmRyIGVsbGVyIHJhc3RlcmZ1bmt0aW9uZW4gQ0NEQy1hbmFseXNlIGVsbGVyIGZ1bmt0aW9uZW4gTGFuZFRyZW5kci1hbmFseXNlLjwvZGl2Pjxicj48ZGl2PkRlbm5lIHJhc3RlcmZ1bmt0aW9uIGthbiBrb21iaW5lcmVzIG1lZCByYXN0ZXJmdW5rdGlvbmVuIENDREMtYW5hbHlzZSBlbGxlciBmdW5rdGlvbmVuIExhbmRUcmVuZHItYW5hbHlzZSBpIGVuIHJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uLiBGb3IgYXQgZ2VuZXJlcmUgZXQgcGVybWFuZW50IHJhc3Rlcm91dHB1dCBza2FsIGR1IGtueXR0ZSBvdXRwdXR0ZXQgZnJhIGZ1bmt0aW9uZW4gQ0NEQy1hbmFseXNlIGVsbGVyIExhbmRUcmVuZHItYW5hbHlzZSB0aWwgZnVua3Rpb25lbiBEZXRla3TDqXIgw6ZuZHJpbmcgdmVkIGhqw6ZscCBhZiDDpm5kcmluZ3NhbmFseXNlLCBnZW1tZSBkZXQgc29tIGVuIHJhc3Rlci1mdW5rdGlvbnNza2FiZWxvbiBvZyBrw7hyZSBSYXN0ZXItYW5hbHlzZSBtZWQgc2thYmVsb25lbi48L2Rpdj48YnI+PGRpdj5QYXJhbWV0ZXJlbiA8c3Ryb25nPsOGbmRyaW5nc3R5cGU8L3N0cm9uZz4gYW5naXZlciBkZSBvcGx5c25pbmdlciwgZGVyIGdlbmVyZXJlcy4gT3BseXNuaW5nZXJuZSBoZW50ZXMgZnJhIMOmbmRyaW5nc2FuYWx5c2VyYXN0ZXJlbi4gTsOlciBkdSBrw7hyZXIgZGVubmUgZnVua3Rpb24gcMOlIG91dHB1dHRldCBmcmEgQ0NEQy1mdW5rdGlvbmVuLy12w6Zya3TDuGpldCwga2FuIGR1IHbDpmxnZSBtZWxsZW0gZsO4bGdlbmRlIGluZHN0aWxsaW5nZXI6PC9kaXY+PHVsPjxsaT48c3Ryb25nPiBUaWQgZm9yIHNlbmVzdGUgw6ZuZHJpbmc8L3N0cm9uZz7igJNEZW4gc2VuZXN0ZSBkYXRvIG9nIGRldCBzZW5lc3RlIHRpZHNwdW5rdCwgaHZvciBlbiBwaXhlbCBibGV2IG1hcmtlcmV0IHNvbSDDpm5kcmV0LjwvbGk+PGxpPjxzdHJvbmc+VGlkIGZvciB0aWRsaWdzdGUgw6ZuZHJpbmc8L3N0cm9uZz7igJNEZW4gdGlkbGlnc3RlIGRhdG8gb2cgZGV0IHRpZGxpZ3N0ZSB0aWRzcHVua3QsIGh2b3IgZW4gcGl4ZWwgYmxldiBtYXJrZXJldCBzb20gw6ZuZHJldC48L2xpPjxsaT48c3Ryb25nPlRpZCBmb3Igc3TDuHJzdGUgw6ZuZHJpbmc8L3N0cm9uZz7igJNEZW4gZGF0byBvZyBkZXQgdGlkc3B1bmt0LCBodm9yIGRlbiBiZXJlZ25lZGUgw6ZuZHJpbmcgdmFyIGRlbiB2aWd0aWdzdGUgZm9yIGVuIHBpeGVsLjwvbGk+PGxpPiA8c3Ryb25nPkFudGFsIMOmbmRyaW5nZXI8L3N0cm9uZz7igJNEZXQgc2FtbGVkZSBhbnRhbCBnYW5nZSwgcGl4bGVuIGVyIGJsZXZldCDDpm5kcmV0LjwvbGk+PC91bD48ZGl2Pk7DpXIgZGVubmUgZnVua3Rpb24ga8O4cmVzIHDDpSBvdXRwdXR0ZXQgZnJhIExhbmRUcmVuZHItZnVua3Rpb25lbi8tdsOmcmt0w7hqZXQsIGVyIGbDuGxnZW5kZSB5ZGVybGlnZXJlIGluZHN0aWxsaW5nZXIgdGlsZ8OmbmdlbGlnZTogPC9kaXY+PHVsPjxsaT48c3Ryb25nPlRpZCBmb3IgbMOmbmdzdGUgw6ZuZHJpbmc8L3N0cm9uZz7igJNEZW4gZGF0bywgaHZvciBlbiBwaXhlbCBibGV2IG1hcmtlcmV0IHNvbSDDpm5kcmV0IHZlZCBiZWd5bmRlbHNlbiBlbGxlciBzbHV0bmluZ2VuIGFmIGRlbiBsw6ZuZ3N0ZSDDpm5kcmluZ3NwZXJpb2RlLjwvbGk+PGxpPjxzdHJvbmc+VGlkIGZvciBrb3J0ZXN0ZSDDpm5kcmluZzwvc3Ryb25nPkRlbiBkYXRvLCBodm9yIGVuIHBpeGVsIGJsZXYgbWFya2VyZXQgc29tIMOmbmRyZXQsIHZlZCBiZWd5bmRlbHNlbiBlbGxlciBzbHV0bmluZ2VuIGFmIGRlbiBrb3J0ZXN0ZSDDpm5kcmluZ3NwZXJpb2RlLjwvbGk+PGxpPjxzdHJvbmc+VGlkIGZvciBodXJ0aWdzdGUgw6ZuZHJpbmc8L3N0cm9uZz7igJNEZW4gZGF0bywgaHZvciBlbiBwaXhlbCBibGV2IG1hcmtlcmV0IHNvbSDDpm5kcmV0LCB2ZWQgYmVneW5kZWxzZW4gZWxsZXIgc2x1dG5pbmdlbiBhZiBkZW4gaHVydGlnc3RlIMOmbmRyaW5nc3BlcmlvZGUuPC9saT48bGk+PHN0cm9uZz5UaWQgZm9yIGxhbmdzb21zdGUgw6ZuZHJpbmc8L3N0cm9uZz7igJNEZW4gZGF0bywgaHZvciBlbiBwaXhlbCBibGV2IG1hcmtlcmV0IHNvbSDDpm5kcmV0LCB2ZWQgYmVneW5kZWxzZW4gZWxsZXIgc2x1dG5pbmdlbiBhZiBkZW4gbGFuZ3NvbXN0ZSDDpm5kcmluZ3NwZXJpb2RlLjwvbGk+PC91bD48ZGl2Pk91dHB1dC1yYXN0ZXJlbiBlciBlbiBtdWx0aWLDpW5kc3Jhc3RlciwgaHZvcmkgaHZlcnQgYsOlbmQgaW5kZWhvbGRlciDDpm5kcmluZ3NvcGx5c25pbmdlciBhZmjDpm5naWd0IGFmIGRlbiB2YWxndGUgw6ZuZHJpbmdzdHlwZSBvZyBkZXQgbWFrc2ltYWxlIGFudGFsIMOmbmRyaW5nZXIsIGRlciBlciBhbmdpdmV0LiBIdmlzIDxzdHJvbmc+w4ZuZHJpbmdzdHlwZTwvc3Ryb25nPiBmLmVrcy4gZXIgaW5kc3RpbGxldCB0aWwgPHN0cm9uZz5UaWQgZm9yIHRpZGxpZ3N0ZSDDpm5kcmluZzwvc3Ryb25nPm9nIDxzdHJvbmc+TWFrc2ltYWx0IGFudGFsIMOmbmRyaW5nZXI8L3N0cm9uZz5lciBpbmRzdGlsZXQgdGlsIDIsIGJlcmVnbmVyIGZ1bmt0aW9uZW4gZGUgdG8gdGlkbGlnc3RlIGRhdG9lciwgaHZvciBkZXIgZm9yZWtvbSDDpm5kcmluZ2VyIGkgaGVsZSB0aWRzc2VyaWVuIGZvciBodmVyIHBpeGVsLiBSZXN1bHRhdGV0IGVyIGVuIHJhc3RlciwgaHZvcmkgZGV0IGbDuHJzdGUgYsOlbmQgaW5kZWhvbGRlciBkYXRvZXJuZSBmb3IgZGVuIHRpZGxpZ3N0ZSDDpm5kcmluZyBwci4gcGl4ZWwsIG9nIGRldCBhbmRldCBiw6VuZCBpbmRlaG9sZGVyIGRhdG9lcm5lIGZvciBkZW4gYW5kZW50aWRsaWdzdGUgw6ZuZHJpbmcgcHIuIHBpeGVsLjwvZGl2Pjxicj48ZGl2PlZlZCBhbnZlbmRlbHNlIGFmIGRlbm5lIGZ1bmt0aW9uIHDDpSBvdXRwdXR0ZXQgZnJhIExhbmRUcmVuZHItdsOmcmt0w7hqZXJuZSBrYW4gZHUgdsOmbGdlLCBvbSBkdSB2aWwgaGVudGUgZGVuIGRhdG8sIGRlciBtYXJrZXJlciBiZWd5bmRlbHNlbiBhZiBlbiDDpm5kcmluZyBlbGxlciBzbHV0bmluZ2VuIGFmIGVuIMOmbmRyaW5nIHZlZCBoasOmbHAgYWYgcGFyYW1ldGVyZW4gPHN0cm9uZz5TZWdtZW50ZGF0bzwvc3Ryb25nPi4gSHZpcyBkdSBmLmVrcy4gw7huc2tlciBhdCBmb3JzdMOlLCBodm9yZGFuIGRlbiBzZW5lc3RlIMOmbmRyaW5nIGkgdGlkc3NlcmllbiBlciBzdGFydGV0LCBza2FsIGR1IGluZHN0aWxsZSA8c3Ryb25nPsOGbmRyaW5nc3R5cGU8L3N0cm9uZz4gdGlsIDxzdHJvbmc+VGlkIGZvciBzZW5lc3RlIMOmbmRyaW5nPC9zdHJvbmc+IG9nIDxzdHJvbmc+U2VnbWVudGRhdG88L3N0cm9uZz4gdGlsIDxzdHJvbmc+U3RhcnQgcMOlIHNlZ21lbnQ8L3N0cm9uZz4uPC9kaXY+PGJyPjxkaXY+QnJ1ZyBmw7hsZ2VuZGUgZmlsdHJlcmluZ3NwYXJhbWV0cmUgdGlsIGF0IHVkdHLDpmtrZSBmbGVyZSBzcGVjaWZpa2tlIMOmbmRyaW5nc2RhdG9lciBmcmEgZGluIMOmbmRyaW5nc2FuYWx5c2VyYXN0ZXI6PC9kaXY+PHVsPjxsaT48c3Ryb25nPkZpbHRyw6lyIGVmdGVyIMOlcjwvc3Ryb25nPuKAkyBJZGVudGlmaWPDqXIgw6ZuZHJpbmdlciwgZGVyIGVyIG9wc3TDpWV0IGluZGVuIGZvciBlbiBiZXN0ZW10IHRpZHNwZXJpb2RlLCBodmlzIGR1IGYuZWtzLiBlciBww6UgdWRraWcgZWZ0ZXIgw6ZuZHJpbmdlciwgZGVyIGVyIG9wc3TDpWV0IGkgZXQgbGFuZHNrYWIgaSBsw7hiZXQgYWYgZmVtIMOlciBtZWQgdMO4cmtlLjwvbGk+PGxpPjxzdHJvbmc+RmlsdHLDqXIgZWZ0ZXIgdmFyaWdoZWQ8L3N0cm9uZz7igJNJZGVudGlmaWPDqXIgw6ZuZHJpbmdlciwgZGVyIGVyIG9wc3TDpWV0IGluZGVuIGZvciBlbiBnaXZldCDDpXJyw6Zra2UsIGh2aXMgZHUgZi5la3MuIGVyIHDDpSB1ZGtpZyBlZnRlciBwbHVkc2VsaWdlIMOmbmRyaW5nZXIsIGRlciBlciBpbmR0cnVmZmV0IGkgbMO4YmV0IGFmIDEgZWxsZXIgMiDDpXIuIER1IGthbiBiZXJlZ25lIGRlbiB2YXJpZ2hlZCwgZHUgZXIgaW50ZXJlc3NlcmV0IGksIHZlZCBoasOmbHAgYWYgZm9ybWxlbiA8c3Ryb25nPnNsdXTDpXIgLSBzdGFydMOlciArMTwvc3Ryb25nPi4gRGVyIHZpbCB2w6ZyZSBpbmtsdWRlcmV0IFxcXCJodWxsZXJcXFwiIGkgdGlkc3Nlcmllbi48L2xpPjxsaT48c3Ryb25nPkZpbHRyw6lyIGVmdGVyIHN0w7hycmVsc2U8L3N0cm9uZz7igJMgSWRlbnRpZmljw6lyIMOmbmRyaW5nZXIgYWYgZW4gZ2l2ZW4gc3TDuHJyZWxzZSwgaHZpcyBkdSBmLmVrcy4gZXIgcMOlIHVka2lnIGVmdGVyIHN0b3JlIMOmbmRyaW5nZXIgaSB2ZWdldGF0aW9uc2luZGVrc2V0IE5EVkkuIFN0w7hycmVsc2UgZXIgZW4gYWJzb2x1dCB2w6ZyZGksIHPDpSBtaW5pbXVtLSBvZyBtYWtzaW11bXbDpnJkaWVybmUga2FuIGlra2UgdsOmcmUgbmVnYXRpdmUuIEh2aXMgZHUgdmlsIGFuZ2l2ZSByZXRuaW5nc8OmbmRyaW5nLCBza2FsIGR1IGJydWdlIHBhcmFtZXRlcmVuIDxzdHJvbmc+w4ZuZHJlIHJldG5pbmc8L3N0cm9uZz4uPC9saT48L3VsPlwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uTmFtZTogXCJBZnN0YW5kc2Fra3VtdWxlcmluZ1wiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uU25pcDogXCJCZXJlZ25lciBkZW4gYWtrdW11bGVyZWRlIGFmc3RhbmQgZnJhIGh2ZXIgY2VsbGUgdGlsIGtpbGRlcm5lLCBodmlsa2V0IHRhZ2VyIGjDuGpkZSBmb3IgbGlnZWxpbmplLWFmc3RhbmQsIG9ta29zdG5pbmdzYWZzdGFuZCwgdmlya2VsaWcgb3ZlcmZsYWRlYWZzdGFuZCBzYW10IHZhbmRyZXR0ZSBvZyBsb2RyZXR0ZSBvbWtvc3RuaW5nc2Zha3RvcmVyLlwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uRGVzYzogXCJGdW5rdGlvbmVuIEFmc3RhbmRzYWtrdW11bGVyaW5nIGJlcmVnbmVyIGFmc3RhbmRlbiB0aWwgaHZlciBwb3NpdGlvbiBpIHVuZGVyc8O4Z2Vsc2Vzb21yw6VkZXQgaSBmb3Job2xkIHRpbCBkZW4gbsOmcm1lc3RlIGVsbGVyIG1pbmRzdCBvbWtvc3RuaW5nc3R1bmdlIGtpbGRlLiBIdmlzIGRldCBrdW4gZXIga2lsZGVybmUsIGRlciBhbmdpdmVzIHNvbSBpbnB1dCwgYmVyZWduZXMgbGlnZWxpbmplLWFmc3RhbmRlbiB0aWwgaHZlciBwb3NpdGlvbiBpIHVuZGVyc8O4Z2Vsc2Vzb21yw6VkZXQuIEh2aXMgYsOlZGUga2lsZGVyIG9nIGJhcnJpZXJlciBhbnZlbmRlcyBzb20gaW5wdXQsIGJlcmVnbmVyIGZ1bmt0aW9uZW4gQWZzdGFuZHNha2t1bXVsZXJpbmcgbGlnZWxpbmplLWFmc3RhbmRlbiBvbWtyaW5nIGJhcnJpZXJlcm5lLiBCYWdncnVuZHN2w6ZyZGllbiBza2FsIHbDpnJlIE5vRGF0YSBmb3IgYsOlZGUga2lsZGVyYXN0ZXIgb2cgYmFycmllcmVyYXN0ZXIsIG7DpXIga2lsZGVyIG9nIGJhcnJpZXJlciByZXByw6ZzZW50ZXJlcyBtZWQgZ3lsZGlnZSBjZWxsZXbDpnJkaWVyLiBHeWxkaWdlIHbDpnJkaWVyIG9tZmF0dGVyIG51bC4gPGRpdj48YnIvPk7DpXIgZW4gb3ZlcmZsYWRlcmFzdGVyIGFuZ2l2ZXMgc29tIGlucHV0LCBiZXJlZ25lcyBkZW4gZmFrdGlza2Ugb3ZlcmZsYWRlYWZzdGFuZCBtZWxsZW0gY2VsbGVybmUuIEh2aXMgZGVyIHNrYWwgdWRmw7hyZXMgb21rb3N0bmluZ3NhbmFseXNlIHZlZCBoasOmbHAgYWYgQWZzdGFuZHNha2t1bXVsZXJpbmcsIGVyIGRlciBicnVnIGZvciBlbiBvbWtvc3RuaW5nc292ZXJmbGFkZS4gSHZpcyBlbiBvbWtvc3RuaW5nc292ZXJmbGFkZSBhbmdpdmVzLCBlciByZXN1bHRhdGV0IGVuIGFra3VtdWxlcmV0IG9ta29zdG5pbmdzYWZzdGFuZHMtcmFzdGVyLiBOw6VyIGhvcmlzb250YWxlIG9nIHZlcnRpa2FsZSBmYWt0b3JlciBhbmdpdmVzLCBpbmRkcmFnZXMgcmV0bmluZ3NiZXN0ZW10aGVkIHNvbSBha2t1bXVsZXJldCBvbWtvc3RuaW5nLiBEZXIgZXIgZmlyZSBraWxkZWVnZW5za2FiZXIsIGRlciBrYW4gYW52ZW5kZXMuIERpc3NlIGtpbGRlZWdlbnNrYWJlciwgZGVyIGVudGVuIGthbiB2w6ZyZSBraWxkZXIgZWxsZXIgZWdlbnNrYWJlciwgZGVyIGVyIGZseXR0ZXQgdsOmayBmcmEga2lsZGVuLCBzdHlyZXMgYWYgc3BlY2lmaWtrZSBwYXJhbWV0cmU6IDEuIEbDuHJzdGUgYWtrdW11bGVyaW5nOuKAr2FuZ2l2ZXIgZGVuIGbDuHJzdGUgb21rb3N0bmluZyBmw7hyIGZseXRuaW5nZW4gYmVneW5kZXIuIDIuIE1ha3NpbWFsIGFra3VtdWxlcmluZzrigK9hbmdpdmVyLCBodm9yIG1hbmdlIG9ta29zdG5pbmdlciBlbiBraWxkZSBrYW4gYWtrdW11bGVyZSwgZsO4ciBkZW4gbsOlciBzaW4gZ3LDpm5zZS4gMy4gTXVsdGlwbGlrYXRvciwgZGVyIHNrYWwgYW52ZW5kZXMgdGlsIG9ta29zdG5pbmdlcjrigK9hbmdpdmVyIHJlanNlbcOlZGVuIGVsbGVyIHN0w7hycmVsc2VuIHZlZCBraWxkZW4uIDQuIFJlanNlcmV0bmluZzrigK9hbmdpdmVyLCBvbSBcXFwiZmx5dHRlcmVuXFxcIiBzdGFydGVyIHZlZCBraWxkZW4gb2cgYmV2w6ZnZXIgc2lnIG1vZCBpa2tlLWtpbGRlLXBvc2l0aW9uZXIsIGVsbGVyIHN0YXJ0ZXIgdmVkIGlra2Uta2lsZGUtcG9zaXRpb25lciBvZyBiZXbDpmdlciBzaWcgdGlsYmFnZSB0aWwgZW4ga2lsZGUuPGRpdj48YnIvPlJlc3VsdGF0ZXQgYWYgQWZzdGFuZHNha2t1bXVsZXJpbmcgZXIgc29tIHN0YW5kYXJkIGV0IGVua2VsdCBiw6VuZCwgc29tIGVyIGFmc3RhbmRzYWtrdW11bGVyaW5nc3Jhc3RlcmVuLiBNZW4gZXQgYW5kZXQgYsOlbmQga2FuIG9nc8OlIG9wcmV0dGVzIOKAkyB0aWxiYWdlcmV0bmluZ3Niw6VuZGV0LiAgRGV0dGUgYsOlbmQgYW5naXZlciBmcmEgaHZlciBwb3NpdGlvbiBpIHVuZGVyc8O4Z2Vsc2Vzb21yw6VkZXQsIGh2aWxrZW4gcmV0bmluZyBkZXIgc2thbCB0YWdlcyBmb3IgYXQgb3Buw6UgZGVuIG1pbmRzdCBvbWtvc3RuaW5nc3R1bmdlIGtpbGRlLiAgQmVnZ2UgYsOlbmQgZXIgbsO4ZHZlbmRpZ2UgZm9yIGF0IGt1bm5lIGZhc3Rsw6ZnZ2UgZGUgbWVzdCBvcHRpbWFsZSBydXRlciBpIHVuZGVyc8O4Z2Vsc2Vzb21yw6VkZXQuIEZvciBhdCBnZW5lcmUgZW4gcnV0ZSBza2FsIGR1IGbDuHJzdCBicnVnZSBmdW5rdGlvbmVuIFVkdHLDpmsgYsOlbmQgdGlsIGF0IHVkdHLDpmtrZSBhZnN0YW5kc2Fra3VtdWxlcmluZ3NyYXN0ZXJlbiBvZyB0aWxiYWdlcmV0bmluZ3NyYXN0ZXJlbi4gQnJ1ZyBkaXNzZSBsYWcgc29tIGlucHV0IHRpbCBPbWtvc3RuaW5nc3J1dGUtZnVua3Rpb25lbi4gSSBkZW5uZSBmdW5rdGlvbiBza2FsIGR1IGJydWdlIGFmc3RhbmRzYWtrdW11bGVyaW5nc3Jhc3RlcmVuIHNvbSBpbnB1dCB0aWwgT21rb3N0bmluZ3NhZnN0YW5kc3Jhc3RlciBvZyB0aWxiYWdlcmV0bmluZ3NyYXN0ZXJlbiBzb20gaW5wdXQgdGlsIE9ta29zdG5pbmcgQmFja0xpbmstcmFzdGVyLjwvZGl2PlwiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvbk5hbWU6IFwiQWZzdGFuZHNhbGxva2VyaW5nXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uU25pcDogXCJCZXJlZ25lciBhZnN0YW5kc2FsbG9rZXJpbmdlbiBmcmEgaHZlciBjZWxsZSB0aWwgZGUgYW5naXZuZSBraWxkZXIsIGJhc2VyZXQgcMOlIGxpZ2VsaW5qZS1hZnN0YW5kLCBvbWtvc3RuaW5nc2Fmc3RhbmQsIHZpcmtlbGlnIG92ZXJmbGFkZWFmc3RhbmQgc2FtdCB2YW5kcmV0dGUgb2cgbG9kcmV0dGUgb21rb3N0bmluZ3NmYWt0b3Jlci5cIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25EZXNjOiBcIkFmc3RhbmRzYWxsb2tlcmluZyBiZXJlZ25lciwgaHZpbGtlbiBraWxkZSBodmVyIHBvc2l0aW9uIGkgdW5kZXJzw7hnZWxzZXNvbXLDpWRldCBlciBhbGxva2VyZXQgdGlsLiBIdmlzIGRldCBrdW4gZXIga2lsZGVyLCBkZXIgYW5naXZlcyBzb20gaW5wdXQsIGFsbG9rZXJlcyBwb3NpdGlvbmVybmUgdmVkIGJydWcgYWYgbGlnZWxpbmplLWFmc3RhbmQgdGlsIGRlbiBuw6ZybWVzdGUga2lsZGUuIEh2aXMgYsOlZGUga2lsZGVyIG9nIGJhcnJpZXJlciBhbnZlbmRlcyBzb20gaW5wdXQsIGJlcmVnbmVyIGZ1bmt0aW9uZW4gQWZzdGFuZHNhbGxva2VyaW5nIGxpZ2VsaW5qZS1hZnN0YW5kZW4gb21rcmluZyBiYXJyaWVyZXJuZSBmb3IgYXQgYmVzdGVtbWUsIGh2aWxrZW4ga2lsZGUgZW4gcG9zaXRpb24gc2thbCBhbGxva2VyZXMgdGlsLiBCYWdncnVuZHN2w6ZyZGllbiBza2FsIHbDpnJlIE5vRGF0YSBmb3IgYsOlZGUga2lsZGVyYXN0ZXIgb2cgYmFycmllcmVyYXN0ZXIsIG7DpXIga2lsZGVyIG9nIGJhcnJpZXJlciByZXByw6ZzZW50ZXJlcyBtZWQgZ3lsZGlnZSBjZWxsZXbDpnJkaWVyLiBHeWxkaWdlIHbDpnJkaWVyIG9tZmF0dGVyIG51bC48ZGl2Pjxici8+SHZpcyBkZXIgc2thbCB1ZGbDuHJlcyBvbWtvc3RuaW5nc2FuYWx5c2UgdmVkIGhqw6ZscCBhZiBBZnN0YW5kc2FsbG9rZXJpbmcsIGVyIGRlciBicnVnIGZvciBlbiBvbWtvc3RuaW5nc292ZXJmbGFkZS4gSHZpcyBkZXIgYW5naXZlcyBlbiBvbWtvc3RuaW5nc292ZXJmbGFkZSwgZXIgcmVzdWx0YXRldCBlbiBhbGxva2VyaW5nc3Jhc3RlciwgZGVyIGVyIGJhc2VyZXQgcMOlIGRlIGFra3VtdWxlcmVkZSBvbWtvc3RuaW5nZXIsIGlra2UgZW4gbGlnZWxpbmplLWFmc3RhbmQuIE7DpXIgaG9yaXNvbnRhbGUgb2cgdmVydGlrYWxlIGZha3RvcmVyIGFuZ2l2ZXMsIGluZGRyYWdlcyByZXRuaW5nc2Jlc3RlbXRoZWQgc29tIGFra3VtdWxlcmV0IG9ta29zdG5pbmcuIE7DpXIgZW4gb3ZlcmZsYWRlcmFzdGVyIGFuZ2l2ZXMgc29tIGlucHV0LCBiZXJlZ25lcyBkZW4gZmFrdGlzayBkw6Zra2VkZSBvdmVyZmxhZGVhZnN0YW5kLCBuw6VyIG92ZXJmw7hyc2xlbiBtZWxsZW0gY2VsbGVybmUgYmVyZWduZXMsIG9nIGFsbG9rZXJpbmdlbiBiZXN0ZW1tZXMuIERlciBlciBmaXJlIGtpbGRlZWdlbnNrYWJlciwgZGVyIGthbiBhbnZlbmRlcy4gRGlzc2Uga2lsZGVlZ2Vuc2thYmVyLCBkZXIgZW50ZW4ga2FuIHbDpnJlIGtpbGRlciBlbGxlciBlZ2Vuc2thYmVyLCBkZXIgZXIgZmx5dHRldCB2w6ZrIGZyYSBraWxkZW4sIHN0eXJlcyBhZiBzcGVjaWZpa2tlIHBhcmFtZXRyZTogMS4gRsO4cnN0ZSBha2t1bXVsZXJpbmc64oCvYW5naXZlciBkZW4gZsO4cnN0ZSBvbWtvc3RuaW5nIGbDuHIgZmx5dG5pbmdlbiBiZWd5bmRlci4gMi4gTWFrc2ltYWwgYWtrdW11bGVyaW5nOuKAr2FuZ2l2ZXIsIGh2b3IgbWFuZ2Ugb21rb3N0bmluZ2VyIGVuIGtpbGRlIGthbiBha2t1bXVsZXJlLCBmw7hyIGRlbiBuw6VyIHNpbiBncsOmbnNlLiAzLiBNdWx0aXBsaWthdG9yLCBkZXIgc2thbCBhbnZlbmRlcyB0aWwgb21rb3N0bmluZ2VyOuKAr2FuZ2l2ZXIgcmVqc2Vtw6VkZW4gZWxsZXIgc3TDuHJyZWxzZW4gdmVkIGtpbGRlbi4gNC4gUmVqc2VyZXRuaW5nOuKAr2FuZ2l2ZXIsIG9tIFxcXCJmbHl0dGVyZW5cXFwiIHN0YXJ0ZXIgdmVkIGtpbGRlbiBvZyBiZXbDpmdlciBzaWcgbW9kIGlra2Uta2lsZGUtcG9zaXRpb25lciwgZWxsZXIgc3RhcnRlciB2ZWQgaWtrZS1raWxkZS1wb3NpdGlvbmVyIG9nIGJldsOmZ2VyIHNpZyB0aWxiYWdlIHRpbCBlbiBraWxkZS48ZGl2Pjxici8+UmVzdWx0YXRldCBhZiBBZnN0YW5kc2FsbG9rZXJpbmcgZXIgc29tIHN0YW5kYXJkIGV0IGVua2VsdCBiw6VuZCwgc29tIGVyIGFmc3RhbmRzYWxsb2tlcmluZ3NyYXN0ZXJlbi4gVmFsZyBhZiBkZW4gYm9vbHNrZSBvcGVyYXRpb24gR2VuZXJlciBraWxkZXLDpmtrZSBvZyAta29sb25uZSBzb20geWRlcmxpZ2VyZSBiw6VuZCBpIG91dHB1dCB2aWwgcmVzdWx0ZXJlIGkgZW4gbXVsdGliw6VuZHNyYXN0ZXIsIGRlciBiZXN0w6VyIGFmIHRyZSBiw6VuZC4gRGV0IGbDuHJzdGUgYsOlbmQgZXIgYWZzdGFuZHNhbGxva2VyaW5nc2LDpW5kZXQsIGRldCBhbmRldCBiw6VuZCBpbmRlaG9sZGVyIGV0IHLDpmtrZWluZGVrcywgb2cgZGV0IHRyZWRqZSBiw6VuZCBpbmRlaG9sZGVyIGV0IGtvbG9ubmVpbmRla3MuIERpc3NlIGluZGVrc2VyIGlkZW50aWZpY2VyZXIgcGxhY2VyaW5nZW4gYWYg4oCL4oCLa2lsZGVjZWxsZW4sIGRlciBlciBhZnN0YW5kZW4gbWVkIGRlIGxhdmVzdGUgYWtrdW11bGVyZWRlIG9ta29zdG5pbmdlciB2w6ZrLiBLaWxkZXLDpmtrZWluZGVrc2V0IG9nIGtpbGRla29sb25uZWluZGVrc2V0IGthbiBhbnZlbmRlcyBzYW1tZW4gbWVkIGhlbmJsaWsgcMOlIGF0IHVkZsO4cmUgaW50ZW5zaXRldHNrb3J0bMOmZ25pbmcuIEh2aXMgZHUgZm9yZXNww7hyZ2VyIHDDpSBlbiB2aWxrw6VybGlnIHBvc2l0aW9uIGkgZGl0IHVuZGVyc8O4Z2Vsc2Vzb21yw6VkZSBww6UgdHbDpnJzIGFmIGLDpW5kIHRvIG9nIHRyZSwgdmlsIGR1IGtlbmRlIHLDpmtrZSBvZyBrb2xvbm5lIGZvciBkZW4gbWluZHN0IG9ta29zdG5pbmdzdHVuZ2Uga2lsZGUgZm9yIGRlbiBww6Vnw6ZsZGVuZGUgcG9zaXRpb24uPC9kaXY+XCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvbk5hbWU6IFwiRXVrbGlkaXNrIHRpbGJhZ2VyZXRuaW5nXCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvblNuaXA6IFwiQmVyZWduZXIsIGZvciBodmVyIGNlbGxlLCByZXRuaW5nZW4sIGkgZ3JhZGVyLCB0aWwgbmFib2NlbGxlbiBhZCBkZW4ga29ydGVzdGUgdmVqIHRpbGJhZ2UgdGlsIGRlbiBuw6ZybWVzdGUga2lsZGUsIGlkZXQgYmFycmllcmVyIHVuZGfDpXMuXCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvbkRlc2M6IFwiRnVua3Rpb25lbiBFdWtsaWRpc2sgdGlsYmFnZXJldG5pbmcgcmVzdWx0ZXJlciBpIGVuIGtvbnRpbnVlcmxpZyByYXN0ZXIgbWVkIGZseWRlbmRlIGtvbW1hLCBzb20gcmVwcsOmc2VudGVyZXIgcmV0bmluZ2VuIGkgZ3JhZGVyIHRpbGJhZ2UgdGlsIGRlbiBuw6ZybWVzdGUga2lsZGUsIGlkZXQgYmFycmllcmVyIHVuZGfDpXMsIGh2aXMgZGVyIGVyIGFuZ2l2ZXQgYmFycmllcmVyLjxkaXY+PGJyLz5JbnB1dCB0aWwgRXVrbGlkaXNrIHRpbGJhZ2VyZXRuaW5nIGVyIGRlbiBraWxkZSwgc29tIHJldG5pbmdlbiBiZXJlZ25lcyB0aWwuIEV0IHZhbGdmcml0IGlucHV0IGVyIGVuIHJhc3RlciwgZGVyIHJlcHLDpnNlbnRlcmVyIGJhcnJpZXJlciBpbmRlbiBmb3IgdW5kZXJzw7hnZWxzZXNvbXLDpWRldC4gQmFnZ3J1bmRzdsOmcmRpZW4gc2thbCB2w6ZyZSBOb0RhdGEgZm9yIGLDpWRlIGtpbGRlcmFzdGVyIG9nIGJhcnJpZXJlcmFzdGVyLCBuw6VyIGtpbGRlciBvZyBiYXJyaWVyZXIgcmVwcsOmc2VudGVyZXMgbWVkIGd5bGRpZ2UgdsOmcmRpZXIuIEd5bGRpZ2UgdsOmcmRpZXIgb21mYXR0ZXIgbnVsLiBCZXJlZ25pbmdlbiB2aWwgc29tIHN0YW5kYXJkIGJlaGFuZGxlIGRlbiBrb21iaW5lcmVkZSB1ZHN0csOma25pbmcgYWYga2lsZGVyIG9nIGJhcnJpZXJlciwgcGx1cyB0byByw6Zra2VyIG9nIGtvbG9ubmVyLiBIdmlzIGFuYWx5c2VuIGt1biBlciBww6VrcsOmdmV0IGluZGVuIGZvciBkZW4gYW5naXZuZSBhZnN0YW5kIGZyYSBraWxkZXJuZSwga2FuIHBhcmFtZXRlcmVuIE1ha3NpbWFsIGFmc3RhbmQgYW52ZW5kZXMuIEV1a2xpZGlzayB0aWxiYWdlcmV0bmluZyB1bmRlcnN0w7h0dGVyIGLDpWRlIGVuIFBsYW5hci1tZXRvZGUgb2cgZW4gR2VvZMOmdGlzayBtZXRvZGUgaSBmb3JiaW5kZWxzZSBtZWQgYmVyZWduaW5nZW4uIEJlcmVnbmluZ2VuIG1lZCBQbGFuYXItbWV0b2RlbiBmb3JldGFnZXMgcMOlIGV0IHByb2pla3RlcmV0IGZsYWR0IHBsYW4gdmVkIGhqw6ZscCBhZiBldCAyRCBrYXJ0ZXNpc2sga29vcmRpbmF0c3lzdGVtLiBCZXJlZ25pbmdlbiBtZWQgR2VvZMOmdGlzayBtZXRvZGUgdmlsIGJsaXZlIGZvcmV0YWdldCBww6UgZWxsaXBzb2lkZW4sIGh2aWxrZXQgYmV0eWRlciwgYXQgcmVzdWx0YXRldCBpa2tlIMOmbmRyZXMsIHVhbnNldCBpbnB1dC0gZWxsZXIgb3V0cHV0LXByb2pla3Rpb25lbi48ZGl2Pjxici8+UmVzdWx0YXRldCBmcmEgZnVua3Rpb25lbiBFdWtsaWRpc2sgdGlsYmFnZXJldG5pbmcga2FuIGFudmVuZGVzIHNhbW1lbiBtZWQgcmVzdWx0YXRldCBmcmEgZnVua3Rpb25lbiBFdWtsaWRpc2sgYWZzdGFuZCB0aWwgYXQgZmFzdGzDpmdnZSBkZSBrb3J0ZXN0ZSBydXRlciBmcmEgcG9zaXRpb25lciBpbmRlbiBmb3IgdW5kZXJzw7hnZWxzZXNvbXLDpWRldCB0aWxiYWdlIGZyYSBraWxkZW4uIFJlc3VsdGF0ZXQgYWYgYsOlZGUgRXVrbGlkaXNrIHRpbGJhZ2VyZXRuaW5nIG9nIEV1a2xpZGlzayBhZnN0YW5kIGFudmVuZGVzIGkgT21rb3N0bmluZ3NydXRlLWZ1bmt0aW9uZW4gc2FtbWVuIG1lZCBkZXN0aW5hdGlvbmVybmUgdGlsIGF0IGdlbmVyZXJlIGRlIGtvcnRlc3RlIHJ1dGVyLjwvZGl2PlwiLFxuXHRcdGV4cGFuZE5hbWU6IFwiVmlzXCIsXG5cdFx0ZXhwYW5kU25pcDogXCJVZHZpZGVyIGRlIHZhbGd0ZSB6b25lciBmb3IgZW4gcmFzdGVyIG1lZCB6b25lciBtZWQgZXQgYW5naXZldCBhbnRhbCBjZWxsZXIuXCIsXG5cdFx0ZXhwYW5kRGVzYzogXCJNZWQgZnVua3Rpb25lbiBVZHZpZCBnbG9iYWx0IGthbiBkdSBnZW5lcmFsaXNlcmUg4oCTIGVsbGVyIGZvcmVua2xlIOKAkyByYXN0ZXJlIHZlZCBhdCBnw7hyZSBiZXN0ZW10ZSB6b25lciBzdMO4cnJlLiBEdSBrYW4gb2dzw6Uga29udHJvbGxlcmUgZ3JhZGVuIGFmIGdlbmVyYWxpc2VyaW5nLCBkZXIgdmlsIGZvcmVrb21tZS48ZGl2Pjxici8+RGUgem9uZXIsIGR1IHbDpmxnZXIsIHZpbCBibGl2ZSBzdMO4cnJlIHZlZCwgYXQgZGUgdWR2aWRlcyBpbmQgaSBhbmRyZSB6b25lci4gRGUgdmFsZ3RlIHpvbmV2w6ZyZGllciBrYW4g4oCTIHJlbnQgYmVncmVic23DpnNzaWd0IOKAkyB2aXNlcyBzb20gZm9yZ3J1bmRzem9uZXIsIG1lbnMgYW5kcmUgdsOmcmRpZXIgZm9ydHNhdCB2aXNlcyBzb20gYmFnZ3J1bmRzem9uZXIuIEZvcmdydW5kc3pvbmVybmUga2FuIHVkdmlkZXMgaW5kIGkgYmFnZ3J1bmRzem9uZXJuZS48ZGl2Pjxici8+R3JhZGVuIGFmIGdlbmVyYWxpc2VyaW5nIGthbiBrb250cm9sbGVyZXMgbWVkIHBhcmFtZXRlcmVuIEFudGFsIGNlbGxlci4gRGVubmUgdsOmcmRpIGVyIHNvbSBzdGFuZGFyZCAxLCBodmlsa2V0IGJldHlkZXIsIGF0IGRlIHZhbGd0ZSB6b25lciB2aWwgYmxpdmUgdWR2aWRldCBtZWQgZW4gdsOmcmRpLCBkZXIgc3ZhcmVyIHRpbCDDqW4gY2VsbGVzIHN0w7hycmVsc2UuIEh2aXMgZHUgdmlsIMO4Z2UgZ3JhZGVuIGFmIGdlbmVyYWxpc2VyaW5nLCBrYW4gZHUgYW5naXZlIGVuIHN0w7hycmUgdsOmcmRpIGZvciBkZW5uZSBwYXJhbWV0ZXIuIFJlbnQgYmVncmVic23DpnNzaWd0IHN2YXJlciBkZXR0ZSB0aWwgYXQga8O4cmUgdsOmcmt0w7hqZXQgc8OlIG1hbmdlIGdhbmdlIHNvbSBkZXQgYW5naXZuZSBhbnRhbCwgaHZpbGtldCBiZXR5ZGVyLCBhdCByZXN1bHRhdGVybmUgZnJhIGRlbiBmb3JyaWdlIGvDuHJzZWwgYmxpdmVyIGluZHNhdCBpIGRlbiBlZnRlcmbDuGxnZW5kZSBrw7hyc2VsLjwvZGl2PlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNOYW1lOiBcIkdlbmVyZXIgdGVuZGVuc1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNTbmlwOiBcIkVzdGltZXJlciB0ZW5kZW5zZW4gZm9yIGh2ZXIgcGl4ZWwgbGFuZ3MgZW4gZGltZW5zaW9uIGZvciBlbiBlbGxlciBmbGVyZSB2YXJpYWJsZXIgaSBlbiBmbGVyZGltZW5zaW9uYWwgIHJhc3Rlci5cIixcblx0XHR0cmVuZEFuYWx5c2lzRGVzYzogXCI8ZGl2PkRlbm5lIGZ1bmt0aW9uIGthbiBicnVnZXMgdGlsIGF0IHRpbHBhc3NlIGRhdGEgbGFuZ3MgbWVkIGVuIGxpbmXDpnIgaGFybW9uaXNrIGVsbGVyIHBvbHlub21pc2sgdGVuZGVuc2t1cnZlLCBlbGxlciBkZW4ga2FuIGJydWdlcyB0aWwgYXQgdWRmw7hyZSBkZXRla3RlcmluZyBhZiB0ZW5kZW5zZXIgdmVkIGhqw6ZscCBhZiBNYW5uLUtlbmRhbGwgZWxsZXIgU2Vhc29uYWwtS2VuZGFsbC10ZXN0ZW4uPC9kaXY+PGJyPjxkaXY+T3V0cHV0LXRlbmRlbnNyYXN0ZXJlbiwgZGVyIGdlbmVyZXJlcyBtZWQgZGVubmUgZnVua3Rpb24sIGJydWdlcyBzb20gaW5wdXQgdGlsIGZ1bmt0aW9uZW4gPHN0cm9uZz5Gb3J1ZHNpZyB2ZWQgYnJ1ZyB0ZW5kZW5zcmFzdGVyPC9zdHJvbmc+LjwvZGl2Pjxicj48ZGl2Pk1hbm4tS2VuZGFsbC0gb2cgU2Vhc29uYWwtS2VuZGFsbC10ZXN0ZW5lIGJydWdlcyBzb20gaW5wdXQgdGlsIGF0IGFmZ8O4cmUsIG9tIGRlciBlciBlbiBtb25vdG9uIHRlbmRlbnMgaSBkYXRhZW5lLiBEaXNzZSBlciBpa2tlLXBhcmFtZXRyaXNrZSwgaHZpbGtldCBiZXR5ZGVyLCBhdCBkZSBpa2tlIGZvcnVkc8OmdHRlciBlbiBzcGVjaWZpayBkYXRhZm9yZGVsaW5nLiBNYW5uLUtlbmRhbGwtdGVzdGVuIHRhZ2VyIGlra2UgaMO4amRlIGZvciBzZXJpZWwga29ycmVsYXRpb24gZWxsZXIgc8Omc29uYmVzdGVtdGUgdmlya25pbmdlci4gSHZpcyBkYXRhZW5lIGVyIHPDpnNvbmJlc3RlbXRlLCBlciBTZWFzb25hbC1LZW5kYWxsLXRlc3RlbiBtZXJlIHZlbGVnbmV0LjwvZGl2Pjxicj48ZGl2Pkh2aXMgdsOmcmt0w7hqZXQgYnJ1Z2VzIHRpbCBhdCB1ZGbDuHJlIGVudGVuIE1hbm4tS2VuZGFsbCBlbGxlciBTZWFzb25hbC1LZW5kYWxsLXRlc3RlbiwgZXIgb3V0cHV0dGV0IGVuIGZlbS1iw6VuZHMgcmFzdGVyIHNvbSBmw7hsZ2VyOjwvZGl2Pjx1bD48bGk+QsOlbmQgMSA9IFNlbidzIHNsb3BlIChTZW4ncyBow6ZsZG5pbmcpPC9saT48bGk+QsOlbmQgMiA9IHAtdsOmcmRpPC9saT48bGk+QsOlbmQgMyA9IE1hbm4tS2VuZGFsbC1zY29yZSAoUyk8L2xpPjxsaT5Cw6VuZCA0ID0gUy12YXJpYW5zIDwvbGk+PGxpPkLDpW5kIDQgPSBTLXZhcmlhbnMgPC9saT48bGk+QsOlbmQgNSA9IFotc2NvcmU8L2xpPjwvdWw+PGRpdj5PdXRwdXR0ZW5lIGZyYSBNYW5uLUtlbmRhbGwtIGVsbGVyIFNlYXNvbmFsLUtlbmRhbGwtdGVzdGVuZSBrYW4gYW52ZW5kZXMgdGlsIGF0IGFmZ8O4cmUsIGh2aWxrZSBwaXhlbHMgaSBkaW5lIGZsZXJkaW1lbnNpb25hbGUgdGlkc3NlcmllciBkZXIgaGFyIGVuIHN0YXRpc3Rpc2sgc2lnbmlmaWthbnQgdGVuZGVucy4gRHUga2FuIGJydWdlIGRpc3NlIG9wbHlzbmluZ2VyIHNhbW1lbiBtZWQgbGluZcOmcmUsIGhhcm1vbmlza2UgZWxsZXIgcG9seW5vbWlza2UgdGVuZGVuc2FuYWx5c2VyIHRpbCBhdCB1ZHRyw6Zra2Ugc2lnbmlmaWthbnRlIHRlbmRlbnNlciBpIGRpbiB0aWRzc2VyaWUuIER1IGthbiBnZW5lcmVyZSBlbiBtYXNrZSwgZGVyIGluZGVob2xkZXIgcGl4ZWxzIG1lZCBzaWduaWZpa2FudGUgcC12w6ZyZGllciwgYW52ZW5kZSBtYXNrZW4gcMOlIGRlbiBmbGVyZGltZW5zaW9uYWxlIHJhc3RlciBvZyBicnVnZSBkZW5uZSBtYXNrZXJlZGUgbXVsdGlkaW1lbnNpb25lbGxlIHJhc3RlciBzb20gaW5wdXQgdGlsIHbDpnJrdMO4amV0IHRpbCBhdCB1ZGbDuHJlIGxpbmXDpnIsIGhhcm1vbmlzay4gZWxsZXIgcG9seW5vbWlzayB0ZW5kZW5zYW5hbHlzZS48L2Rpdj48YnI+PGRpdj5EZXIgZXIgdHJlIHRlbmRlbnNrdXJ2ZWluZHN0aWxsaW5nZXIgdGlsIHRpbHBhc25pbmcgYWYgZW4gdGVuZGVucyBmb3IgZGUgdmFyaWFibGUgdsOmcmRpZXIgbGFuZ3MgbWVkIGVuIGRpbWVuc2lvbjogbGluZcOmciwgcG9seW5vbWlzayBvZyBoYXJtb25pc2suPC9kaXY+PGJyPjxkaXY+Rm9yIGxpbmXDpnIgdGVuZGVuc2FuYWx5c2UgZXIgb3V0cHV0dGV0IGVuIHRyZWLDpW5kc3Jhc3RlciBzb20gZsO4bGdlcjo8L2Rpdj48dWw+PGxpPkLDpW5kIDEgPSBIw6ZsZG5pbmc8L2xpPjxsaT5Cw6VuZCAyIFNrw6ZyaW5nc3B1bmt0PC9saT48bGk+QsOlbmQgMyA9IEZlamwgaSBrdmFkcmF0cm9kZW4gYWYgZGVuIGdlbm5lbXNuaXRsaWdlIGt2YWRyYXRhZnZpZ2Vsc2UgKFJNU0UpIGVsbGVyIGZlamwgb21rcmluZyBiZXN0LWZpdCBsaW5qZW48L2xpPjwvdWw+PGRpdj5Gb3IgZGVuIHBvbHlub21pc2tlIHRlbmRlbnNhbmFseXNlIGFmaMOmbmdlciBhbnRhbGxldCBhZiBiw6VuZCBpIG91dHB1dHRldCBhZiBwb2x5bm9taWV0cyBncmFkLiBBbmRlbm9yZGVuc3BvbHlub21pZXQgZ2VuZXJlcmVyIGVuIGZpcmViw6VuZHNyYXN0ZXIsIGh2b3I6PC9kaXY+PHVsPjxsaT5Cw6VuZCAxID0gUG9seW5vbWl1bV8yPC9saT48bGk+QsOlbmQgMiA9IFBvbHlub21pdW1fMTwvbGk+PGxpPkLDpW5kIDMgPSBQb2x5bm9taXVtXzA8L2xpPjxsaT5Cw6VuZCA0ID0gUk1TRTwvbGk+PC91bD48ZGl2PlRyZWRqZW9yZGVuc3BvbHlub21pZXQgZ2VuZXJlcmVyIGVuIGZlbWLDpW5kc3Jhc3RlciwgaHZvcjo8L2Rpdj48dWw+PGxpPkLDpW5kIDEgPSBQb2x5bm9taXVtXzM8L2xpPjxsaT5Cw6VuZCAyID0gUG9seW5vbWl1bV8yPC9saT48bGk+QsOlbmQgMyA9IFBvbHlub21pdW1fMTwvbGk+PGxpPkLDpW5kIDQgPSBQb2x5bm9taXVtXzA8L2xpPjxsaT5Cw6VuZCA1ID0gUk1TRTwvbGk+PC91bD48ZGl2PkZvciBoYXJtb25pc2sgdGVuZGVuc2FuYWx5c2UgYWZow6ZuZ2VyIGFudGFsbGV0IGFmIGLDpW5kIGkgb3V0cHV0dGV0IGFmIGRlbiBoYXJtb25pc2tlIGZyZWt2ZW5zLiBOw6VyIGZyZWt2ZW5zZW4gZXIgaW5kc3RpbGxldCB0aWwgMSwgZXIgb3V0cHV0dGV0IGVuIGZlbWLDpW5kc3Jhc3RlciwgaHZvcjo8L2Rpdj48dWw+PGxpPkLDpWQgMSA9IEjDpmxkbmluZzwvbGk+PGxpPkLDpW5kIDIgPSBTa8OmcmluZ3NwdW5rdDwvbGk+PGxpPkLDpW5kIDMgPSBIYXJtb25pY19zaW4xPC9saT48bGk+QsOlbmQgNCA9IEhhcm1vbmljX2NvczE8L2xpPjxsaT5Cw6VuZCA1ID0gUk1TRTwvbGk+PC91bD48ZGl2Pk7DpXIgZnJla3ZlbnNlbiBlciBpbmRzdGlsbGV0IHRpbCAyLCBlciBvdXRwdXR0ZXQgZW4gc3l2YsOlbmRzcmFzdGVyLCBodm9yOjwvZGl2Pjx1bD48bGk+QsOlbmQgMSA9IEjDpmxkbmluZzwvbGk+PGxpPkLDpW5kIDIgPSBTa8OmcmluZ3NwdW5rdDwvbGk+PGxpPkLDpW5kIDMgPSBIYXJtb25pY19zaW4xPC9saT48bGk+QsOlbmQgNCA9IEhhcm1vbmljX2NvczE8L2xpPjxsaT5Cw6VuZCA1ID0gSGFybW9uaWNfc2luMjwvbGk+PGxpPkLDpW5kIDYgPSBIYXJtb25pY19jb3MyPC9saT48bGk+QsOlbmQgNyA9IFJNU0U8L2xpPjwvdWw+PGRpdj5QYXJhbWV0ZXJlbiA8c3Ryb25nPkN5a2x1c2zDpm5nZGU8L3N0cm9uZz4gZm9yIGhhcm1vbmlza2UgdGVuZGVuc2FuYWx5c2UgYW52ZW5kZXMgdGlsIGF0IGFuZ2l2ZSBhbnRhbGxldCBhZiBvZyBsw6ZuZ2RlbiBhZiBkZSBjeWtsdXNzZXIsIHNvbSBkdSBmb3J2ZW50ZXIgYXQgc2UgaSBkaW5lIGRhdGEgaSBsw7hiZXQgYWYgZW4gZGFnIGVsbGVyIGV0IMOlci4gSHZpcyBkdSBmLmVrcy4gZm9ydmVudGVyLCBhdCBkaW5lIGRhdGEgdmlsIGdlbm5lbWfDpSB0byB2YXJpYXRpb25zY3lrbHVzc2VyIHDDpSDDqXQgw6VyLCB2aWwgY3lrbHVzbMOmbmdkZW4gdsOmcmUgMTgyLDUgZGFnZSBlbGxlciAwLDUgw6VyLiBIdmlzIGR1IGhhciB0ZW1wZXJhdHVyZGF0YSwgZGVyIGVyIGluZHNhbWxldCBodmVyIHRyZWRqZSB0aW1lLCBvZyBkZXIgZXIgw6luIHZhcmlhdGlvbnNjeWtsdXMgcHIuIGRhZywgdmlsIGN5a2x1c2zDpm5nZGVuIHbDpnJlIMOpbiBkYWcuPC9kaXY+PGJyPjxkaXY+UGFyYW1ldGVyZW4gPHN0cm9uZz5GcmVrdmVuczwvc3Ryb25nPiBmb3IgaGFybW9uaXNrIHRlbmRlbnNhbmFseXNlIGFudmVuZGVzIHRpbCBhdCBiZXNrcml2ZSBkZW4gaGFybW9uaXNrZSBtb2RlbCwgZGVyIHBhc3NlciB0aWwgZGF0YWVuZS4gSHZpcyBmcmVrdmVuc2VuIGluZHN0aWxsZXMgdGlsIDEsIGFudmVuZGVzIGVuIGtvbWJpbmF0aW9uIGFmIGVuIGxpbmXDpnIgb2cgZW4gZsO4cnN0ZW9yZGVucyBoYXJtb25pc2sga3VydmUgdGlsIG1vZGVsbGVuLiBIdmlzIGZyZWt2ZW5zZW4gZXIgMiwgYW52ZW5kZXMgZW4ga29tYmluYXRpb24gYWYgZW4gbGluZcOmciBvZyBlbiBmw7hyc3Rlb3JkZW5zIG9nIGFuZGVub3JkZW5zIGhhcm1vbmlzayBrdXJ2ZSB0aWwgZGF0YWVuZS4gSHZpcyBmcmVrdmVuc2VuIGVyIHRpbCAzLCBhbnZlbmRlcyBkZXIgeWRlcmxpZ2VyZSBlbiB0cmVkamVvcmRlbnMgaGFybW9uaXNrIGt1cnZlIHRpbCBhdCBtb2RlbGxlcmUgZGF0YWVuZSBvc3YuPC9kaXY+PGJyPjxkaXY+TW9kZWwgZ29vZG5lc3Mtb2YtZml0LXN0YXRpc3RpayBrYW4gZ2VuZXJlcmVzIHNvbSB2YWxnZnJpIG91dHB1dC4gS3ZhZHJhdHJvZGVuIGFmIGRlbiBnZW5uZW1zbml0bGlnZSBrdmFkcmF0YWZ2aWdlbHNlIChSTVNFKSwgZGVuIFIta3ZhZHJhdGlza2UgdsOmcmRpIG9nIHAtdsOmcmRpZW4gZm9yIHRlbmRlbnNow6ZsZG5pbmcga2FuIGJlcmVnbmVzIG9nIHN5bWJvbGlzZXJlcy4gU3ltYm9saXPDqXIgb3V0cHV0LXRlbmRlbnNyYXN0ZXJsYWdldCB2ZWQgaGrDpmxwIGFmIDxzdHJvbmc+UkdCPC9zdHJvbmc+LXN5bWJvbG9naSwgb2cgYW5naXYgc3RhdGlzdGlra2VuIHNvbSByw7hkZSwgZ3LDuG5uZSBvZyBibMOlIGLDpW5kLjwvZGl2Pjxicj5cIixcblx0XHRzcGVjdHJhbFVubWl4aW5nTmFtZTogXCJMaW5lYXIgU3BlY3RyYWwgVW5taXhpbmdcIixcblx0XHRzcGVjdHJhbFVubWl4aW5nU25pcDogXCJVZGbDuHJlciB1bmRlcnBpeGVsLWtsYXNzaWZpY2VyaW5nIG9nIGJlcmVnbmVyIGh5cHBpZ2hlZGVuIGkgYnLDuGtkZWxlIGFmIGZvcnNrZWxsaWdlIHR5cGVyIGFyZWFsZMOma2tlIGZvciBpbmRpdmlkdWVsbGUgcGl4ZWxzLlwiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdEZXNjOiBcIkZ1bmt0aW9uZW4gTGluZWFyIFNwZWN0cmFsIFVubWl4aW5nIGJlcmVnbmVyIGFyZWFsZMOma2tldCBpIGJyw7hrZGVsZSBmb3IgaW5kaXZpZHVlbGxlIHBpeGVscywgZGVyIGluZGVob2xkZXIgZmxlcmUgdHlwZXIgYXJlYWxkw6Zra2UuIEZ1bmt0aW9uZW4gZ2VuZXJlcmVyIGV0IG11bHRpYmFuZC1sYWcsIGh2b3IgaHZlcnQgYsOlbmQgc3ZhcmVyIHRpbCBoeXBwaWdoZWRlbiBpIGJyw7hrZGVsZSBmb3IgaHZlciBrbGFzc2UgYWYgYXJlYWxkw6Zra2UuIER1IGthbiBmLmVrcy4gYnJ1Z2UgZGVubmUgZnVua3Rpb24gdGlsIGF0IGdlbm5lbWbDuHJlIGtsYXNzaWZpY2VyaW5nIGFmIGFyZWFsZMOma2tlIHDDpSBldCBtdWx0aXNwZWt0cmFsdCBiaWxsZWRlIG1lZCBoZW5ibGlrIHDDpSBhdCBpZGVudGlmaWNlcmUgZm90b3N5bnRldGlzayB2ZWdldGF0aW9uLCBqb3JkYnVuZCB1ZGVuIGJldm9rc25pbmcgb2cgdWRnw6VldCBlbGxlciBpa2tlLWZvdG9zeW50ZXRpc2sgdmVnZXRhdGlvbi48ZGl2Pjxici8+UsOma2tlZsO4bGdlbiBmb3Igb3V0cHV0LW11bHRpYmFuZC1yYXN0ZXJlbiBmw7hsZ2VyIHLDpmtrZWbDuGxnZW4gZm9yIGlucHV0LXNwZWt0cmFscHJvZmlsZW4uIEFudGFsbGV0IGFmIGtsYXNzZXIga2FuIGlra2Ugb3ZlcnNrcmlkZSBhbnRhbGxldCBhZiBiw6VuZCBpIGlucHV0LXJhc3RlcmVuLiBEdSBrYW4gZi5la3MuIGlra2UgdWR0csOma2tlIG9wbHlzbmluZ2VyIG9tIG1lcmUgZW5kIDgga2xhc3NlciBmcmEgZW4gOC1iw6VuZHMgcmFzdGVyLjwvZGl2PlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJOYW1lOiBcIkZsZXJkaW1lbnNpb25lbHQgZmlsdGVyXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uTmFtZTogXCJJbnRlcnBvbMOpciByYXN0ZXIgZWZ0ZXIgZGltZW5zaW9uXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uU25pcDogXCJJbnRlcnBvbGVyZXIgZW4gbXVsdGlkaW1lbnNpb25hbCByYXN0ZXIgdmVkIGFuZ2l2bmUgZGltZW5zaW9uc3bDpnJkaWVyIHZlZCBoasOmbHAgYWYgdGlsc3TDuGRlbmRlIHVkc25pdC5cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25EZXNjOiBcIjxwPk1lZCBkZW5uZSBmdW5rdGlvbiBrYW4gZHUgZXN0aW1lcmUgcGl4ZWx2w6ZyZGllciBmb3IgZXQgaWtrZS1kZWZpbmVyZXQgZGltZW5zaW9uc3Vkc25pdCBpIGVuIG11bHRpZGltZW5zaW9uYWwgcmFzdGVyLiBIdmlzIGR1IGYuZWtzLiBoYXIgZXQgZGF0YXPDpnQsIGRlciBpbmRlaG9sZGVyIGVuIGhhdnRlbXBlcmF0dXIgdmVkIG92ZXJmbGFkZW4gb2cgMTAwIG1ldGVyIHVuZGVyIG92ZXJmbGFkZW4sIG9nIGR1IHZpbCBlc3RpbWVyZSB0ZW1wZXJhdHVyZW4gdmVkIDUwIG1ldGVyIHVuZGVyIG92ZXJmbGFkZW4sIGthbiBkdSBicnVnZSBkZW5uZSBmdW5rdGlvbiB0aWwgYXQgZsOlIGV0IGVzdGltYXQgdmVkIGRlbiBww6Vnw6ZsZGVuZGUgZHliZGUgdmVkIGhqw6ZscCBhZiBkaW1lbnNpb25zZGVmaW5pdGlvbmVuIEVmdGVyIHbDpnJkaWVyLjwvcD48cD5EdSBrYW4gb2dzw6UgZG93bnNhbXBsZSBldCBtw6VuZWRsaWd0IGRhdGFzw6Z0IHRpbCBldCBkYWdsaWd0IGRhdGFzw6Z0IHZlZCBoasOmbHAgYWYgZGltZW5zaW9uc2RlZmluaXRpb25lbiBFZnRlciB2w6ZyZGllciBvZyBhbmdpdmUgcGFyYW1ldGVydsOmcmRpZW4gZm9yIFRyaW4gdGlsIDEgb2cgcGFyYW1ldGVydsOmcmRpZW4gZm9yIEVuaGVkIHRpbCBkYWdlLjwvcD48cD5CcnVnIGRpbWVuc2lvbnNkZWZpbml0aW9uZW4gRWZ0ZXIgbcOlbHJhc3RlciB0aWwgYXQgZXN0aW1lcmUgdsOmcmRpZW4gZm9yIG3DpWxyYXN0ZXJlbi48L3A+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlclNuaXA6IFwiT3ByZXR0ZXIgZXQgcmFzdGVybGFnIHVkIGZyYSBldCBmbGVyZGltZW5zaW9uYWx0IHJhc3RlcmRhdGFzw6Z0IGVsbGVyIGV0IGZsZXJkaW1lbnNpb25hbHQgcmFzdGVybGFnIHZlZCBhdCBvcGRlbGUgZGF0YSBpIHVkc25pdCBsYW5ncyBtZWQgZGVmaW5lcmVkZSB2YXJpYWJsZXIgb2cgZGltZW5zaW9uZXIuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlckRlc2M6IFwiRGV0IGZsZXJkaW1lbnNpb25lbGxlIGZpbHRlciBvcHJldHRlciBldCBmbGVyZGltZW5zaW9uZWx0IHJhc3RlcmxhZyB2ZWQgYXQgZmlsdHJlcmUgb2cgdWR0csOma2tlIGV0IHVuZGVyc8OmdCBhZiB2YXJpYWJsZXIgZnJhIGVuIGZsZXJkaW1lbnNpb25lbCByYXN0ZXIuIER1IGhhciBmLmVrcy4gZXQgZmxlcmRpbWVuc2lvbmFsdCBkYXRhc8OmdCwgZGVyIGluZGVob2xkZXIgbcOlbmVkbGlnZSBuZWRiw7hyc2RhdGEgZm9yIDMwIMOlciwgb2cgZHUgw7huc2tlciBrdW4gYXQgdWR0csOma2tlIGRhdGEgZm9yIGh2ZXIgamFudWFyIG3DpW5lZCBmb3IgYXQgZsOlIHZpc3QsIGh2b3JkYW4gbmVkYsO4cnNtw6ZuZ2Rlcm5lIGhhciDDpm5kcmV0IHNpZyBmb3IgZGVubmUgbcOlbmVkLjxkaXY+PGJyLz5CcnVnIHBhcmFtZXRlcmVuIERpbWVuc2lvbnNkZWZpbml0aW9uIHRpbCBhdCBvcGRlbGUgZGltZW5zaW9uZXIgdmVkIGJydWcgYWYgZXQgaW50ZXJ2YWwsIGVuIHbDpnJkaSBlbGxlciBlbiByw6Zra2UgdsOmcmRpZXIuIEh2aXMgZHUgZi5la3MuIGhhciAxMCDDpXJzIGRhdGEgb20gc2FsdGhvbGRpZ2hlZCBpIGhhdmV0LCBkZXIgZXIgaW5kc2FtbGV0IGh2ZXIgbcOlbmVkIGZvciBodmVyIDIgbWV0ZXJzIGR5YmRlIG9wIHRpbCA1MDAgbWV0ZXJzIGR5YmRlLCBrYW4gZHUgYW52ZW5kZSBkZSBmb3Jza2VsbGlnZSBkaW1lbnNpb25zZGVmaW5pdGlvbnNpbmRzdGlsbGluZ2VyIHRpbCBmw7hsZ2VuZGUgc2NlbmFyaWVyLiBTY2VuYXJpZSAxOiBVZHRyw6ZrIHNhbHRob2xkaWdoZWRzZGF0YSBmb3IgbcOlbmVkZW4gamFudWFyIG92ZXIgZW4gcGVyaW9kZSBww6UgMTAgw6VyLiBWw6ZsZyBFZnRlciB2w6ZyZGllciwgaW5kc3RpbCBEaW1lbnNpb24gdGlsIFN0ZFRpbWUsIG9nIGluZHN0aWwgVsOmcmRpZXIgdGlsIEphbnVhci4gU2NlbmFyaWUgMjogT3BkZWwgc2FsdGhvbGRpZ2hlZHNkYXRhIG92ZXIgZXQgZHliZGVvbXLDpWRlIGZyYSAwIHRpbCAxNTAgbWV0ZXIuIFbDpmxnIEVmdGVyIG9tcsOlZGVyLCBpbmRzdGlsIERpbWVuc2lvbiB0aWwgU3RkWiwgb2cgaW5kc3RpbCBNaW5pbXVtdsOmcmRpIHRpbCAtMTUwIG9nIE1ha3NpbXVtdsOmcmRpIHRpbCAwLiBTY2VuYXJpZSAzOiBVZHRyw6ZrIHNhbHRob2xkaWdoZWRzZGF0YSBmb3IgZGUgZsO4cnN0ZSAxMCBkYWdlIGkgaHZlciBqYW51YXIgbcOlbmVkIG92ZXIgZW4gcGVyaW9kZSBww6UgMTAgw6VyLiBWw6ZsZyBFZnRlciBnZW50YWdlbHNlLCBpbmRzdGlsIERpbWVuc2lvbiB0aWwgU3RkVGltZSwgaW5kc3RpbCBTdGFydCBww6UgZsO4cnN0ZSBnZW50YWdlbHNlIG9nIFNsdXQgcMOlIGbDuHJzdGUgZ2VudGFnZWxzZSB0aWwgZGVuIHRpbHN2YXJlbmRlIHN0YXJ0IG9nIHNsdXRuaW5nIHDDpSBnZW50YWdlbHNlc3BlcmlvZGVuLCBpbmRzdGlsIFRyaW4gdGlsIDEsIG9nIGluZHN0aWwgRW5oZWQgdGlsIMOFci48L2Rpdj5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyTmFtZTogXCJGbGVyZGltZW5zaW9uYWwgcmFzdGVyXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlclNuaXA6IFwiVGlsZsO4amVyIGZsZXJkaW1lbnNpb25hbGUgZGF0YSB0aWwgZXQga29ydCBzb20gZXQgZmxlcmRpbWVuc2lvbmFsdCByYXN0ZXJsYWcuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlckRlc2M6IFwiRnVua3Rpb25lbiBGbGVyZGltZW5zaW9uYWwgcmFzdGVyIGbDuGplciBmbGVyZGltZW5zaW9uYWxlIGRhdGEgdGlsIGV0IGtvcnQgc29tIGV0IGZsZXJkaW1lbnNpb25hbHQgcmFzdGVybGFnLiBEZW5uZSBmdW5rdGlvbiBlciBueXR0aWcsIG7DpXIgZGVyIHVkZsO4cmVzIHJhc3RlcmFuYWx5c2UtYXJiZWpkc2dhbmdlIHZlZCBoasOmbHAgYWYgZW4gZnVua3Rpb25za8OmZGUuPGRpdj48YnIvPlVuZGVyc3TDuHR0ZWRlIGZsZXJkaW1lbnNpb25hbGUgcmFzdGVyZGF0YXPDpnQgb21mYXR0ZXIgbmV0Q0RGLCBHUklCLCBIREYgb2cgRXNyaXMgQ1JGLiBGbGVyZGltZW5zaW9uYWxlIG1vc2Fpa2RhdGFzw6Z0IHVuZGVyc3TDuHR0ZXMgb2dzw6UuPC9kaXY+XCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3Rlck5hbWU6IFwiT3B0aW1hbCBydXRlIHNvbSByYXN0ZXJcIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyU25pcDogXCJCZXJlZ25lciBydXRlbiBtZWQgZGUgbGF2ZXN0ZSBvbWtvc3RuaW5nZXIgZnJhIGVuIGtpbGRlIHRpbCBlbiBkZXN0aW5hdGlvbi5cIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyRGVzYzogXCJEZW5uZSBnbG9iYWwgZnVua3Rpb24gZ2VuZXJlcmVyIGVuIG91dHB1dHJhc3RlciwgZGVyIHJlZ2lzdHJlcmVyIGRlKG4pIG9wdGltYWxlIHJ1dGUocikgZnJhIHVkdmFsZ3RlIHN0ZWRlciB0aWwgZGVuIG7DpnJtZXN0ZSBraWxkZWNlbGxlLCBkZXIgZXIgZGVmaW5lcmV0IGluZGVuIGZvciBkZW4gYWtrdW11bGVyZWRlIG9ta29zdG5pbmdzb3ZlcmZsYWRlLCBodmFkIGFuZ8OlciBvbWtvc3RuaW5nc2Fmc3RhbmQuPGRpdj48YnIvPkRldCBrcsOmdmVzIGdlbmVyZWx0LCBhdCBkZXIga8O4cmVzIGVuIGVsbGVyIGZsZXJlIHbDpmd0ZWRlIG9ta29zdG5pbmdzZnVua3Rpb25lciAoQWZzdGFuZHNha2t1bXVsZXJpbmcgZWxsZXIgQWZzdGFuZHNhbGxva2VyaW5nKSwgZsO4ciBmdW5rdGlvbmVuIE9wdGltYWwgcnV0ZSBzb20gcmFzdGVyIGvDuHJlcyBmb3IgYXQgb3ByZXR0ZSBpbnB1dC1hZnN0YW5kc2Fra3VtdWxlcmluZ3MtIG9nIHRpbGJhZ2VyZXRuaW5nc3Jhc3RlcmUuIERpc3NlIGVyIG9ibGlnYXRvcmlza2UgaW5wdXQtcmFzdGVybGFnIGkgZm9yaG9sZCB0aWwgZnVua3Rpb25lbiBPcHRpbWFsIHJ1dGUuIFbDpnJkaWVybmUgZm9yIGRlbiBvcHRpbWFsZSBvdXRwdXQtcnV0ZSByZXByw6ZzZW50ZXJlciBhbnRhbGxldCBhZiBydXRlciBww6UgZW4gZ2l2ZW4gcG9zaXRpb24uIEkgbWFuZ2UgdGlsZsOmbGRlIGfDpXIgcnV0ZXJuZSBpIHNhbW1lIHJldG5pbmcsIG7DpXIgZGUgZm9ybGFkZXIga2lsZGVuLCBodm9yZWZ0ZXIgZGUgw6ZuZHJlciByZXRuaW5nIGZvciBhdCBuw6UgZm9yc2tlbGxpZ2UgZGVzdGluYXRpb25lci4gRW4gdsOmcmRpIHDDpSAxIGluZGlrZXJlciBmLmVrcy4sIGF0IGRlciBrdW4gZXIgw6luIG9wdGltYWwgcnV0ZSBmb3IgZW4gZ2l2ZW4gcG9zaXRpb24sIG1lbnMgZW4gdsOmcmRpIHDDpSA1IGFuZ2l2ZXIsIGF0IGRlciBmb3IgZGVuIHDDpWfDpmxkZW5kZSBwb3NpdGlvbiBlciBmZW0gb3B0aW1hbGUgcnV0ZXIsIGRlciBnw6VyIGlnZW5uZW0gZGVuIHDDpWfDpmxkZW5kZSBjZWxsZSBpIHVuZGVyc8O4Z2Vsc2Vzb21yw6VkZXQuPGRpdj48YnIvPklucHV0LWRlc3RpbmF0aW9uc2RhdGFlbmUgc2thbCB2w6ZyZSBldCByYXN0ZXJsYWcuIFPDpnR0ZXQgbWVkIGRlc3RpbmF0aW9uc2NlbGxlciBiZXN0w6VyIGFmIGNlbGxlciBpIGlucHV0LXJhc3RlcmVuLCBkZXIgaGFyIGd5bGRpZ2UgdsOmcmRpZXIuIENlbGxlciwgZGVyIGhhciBOb0RhdGEtdsOmcmRpZXIsIGVyIGlra2UgbWVkdGFnZXQgaSBkYXRhc8OmdHRldC4gVsOmcmRpZW4gbnVsIGFuc2VzIGZvciBhdCB2w6ZyZSBlbiBneWxkaWcgZGVzdGluYXRpb24uIERlciBrYW4gb3ByZXR0ZXMgZW4gZGVzdGluYXRpb25zcmFzdGVyIG1lZCB1ZHRyw6ZrbmluZ3N2w6Zya3TDuGplcm5lLiBIdmlzIGR1IGhhciBkZXN0aW5hdGlvbnMtIGVsbGVyIGtpbGRlb2JqZWt0ZXIsIGthbiBkdSBrb252ZXJ0ZXJlIGRlbSB0aWwgcmFzdGVyIG1lZCBmdW5rdGlvbmVuIEtvbnZlcnRlciBvYmpla3RlciB0aWwgcmFzdGVyLiBCcnVnIGFmc3RhbmRzYWtrdW11bGVyaW5nIGVsbGVyIHRpbGJhZ2VyZXRuaW5nc3Jhc3RlciBzb20gcmFzdGVyLWlucHV0IHRpbCByYXN0ZXJmdW5rdGlvbmVuLiBEZXR0ZSB2aWwgc2lrcmUsIGF0IG9iamVrdGV0IGtvbnZlcnRlcmVzIHRpbCByYXN0ZXIgbWVkIGRlbiBzYW1tZSBjZWxsZXN0w7hycmVsc2UsIHVkc3Ryw6ZrbmluZyBvZyBzcGF0aWFsZSByZWZlcmVuY2Ugc29tIGRlIGFuZHJlIHJhc3RlcmUsIGRlciBpbmRnw6VyIGkgZnVua3Rpb25lbiBPcHRpbWFsIHJ1dGUgc29tIHJhc3Rlci4gRnVua3Rpb25lbiBPcHRpbWFsIHJ1dGUgc29tIHJhc3RlciBrYW4gb2dzw6UgYW52ZW5kZXMgdGlsIGF0IHVkbGVkZSBydXRlbiBtZWQgZGVuIG1pbmRzdGUgbW9kc3RhbmQgZm9yIGVuIGRpZ2l0YWwgaMO4amRlbW9kZWwgKERFTSkuIEkgZGV0dGUgdGlsZsOmbGRlIGthbiBkdSBicnVnZSBERU0nZW4gc29tIGlucHV0LWFmc3RhbmRzYWtrdW11bGVyaW5nc3Jhc3RlciBvZyBvdXRwdXQgZnJhIGZ1bmt0aW9uZW4gRmxvd3JldG5pbmcgc29tIHRpbGJhZ2VyZXRuaW5nc3Jhc3Rlci48L2Rpdj5cIixcblx0XHR0cmVuZE5hbWU6IFwiRm9ydWRzaWcgdmVkIGJydWcgdGVuZGVuc3Jhc3RlclwiLFxuXHRcdHRyZW5kU25pcDogXCJCZXJlZ25lciBldCBmb3J2ZW50ZXQgZmxlcmRpbWVuc2lvbmFsdCByYXN0ZXJsYWcgdmVkIGhqw6ZscCBhZiBvdXRwdXQtdGVuZGVuc3Jhc3RlcmVuIGZyYSBmdW5rdGlvbmVuIEdlbmVyZXIgdGVuZGVucyBlbGxlciBnZW9wcm9jZXNzZXJpbmdzdsOmcmt0w7hqZXQgR2VuZXJlciB0ZW5kZW5zcmFzdGVyLlwiLFxuXHRcdHRyZW5kRGVzYzogXCJGdW5rdGlvbmVuIEZvcnVkc2lnIHZlZCBicnVnIHRlbmRlbnNyYXN0ZXIgYmVyZWduZXIgZXQgZm9ydmVudGV0IGZsZXJkaW1lbnNpb25hbHQgcmFzdGVybGFnIHZlZCBoasOmbHAgYWYgb3V0cHV0LXRlbmRlbnNyYXN0ZXJlbiBmcmEgZnVua3Rpb25lbiBHZW5lcmVyIHRlbmRlbnMgZWxsZXIgZ2VvcHJvY2Vzc2VyaW5nc3bDpnJrdMO4amV0IEdlbmVyZXIgdGVuZGVuc3Jhc3Rlci5cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uTmFtZTogXCJCZWhhbmRsIHJhc3RlcnNhbWxpbmdcIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uU25pcDogXCJCZWhhbmRsZXIgaHZlcnQgdWRzbml0IGkgZW4gZmxlcmRpbWVuc2lvbmFsIHJhc3RlciBlbGxlciBodmVydCBlbGVtZW50IGkgZW4gbW9zYWlrcmFzdGVyLiBEZW5uZSBmdW5rdGlvbiBrYW4gb2dzw6UgYWdncmVnZXJlIGZsZXJlIHVkc25pdCB0aWwgZXQgZW5rZWx0IHVkc25pdC5cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uRGVzYzogXCJGdW5rdGlvbmVuIEJlaGFuZGwgcmFzdGVyc2FtbGluZyBiZWhhbmRsZXIgaHZlcnQgdWRzbml0IGkgZW4gZmxlcmRpbWVuc2lvbmFsIHJhc3RlciBlbGxlciBodmVydCBlbGVtZW50IGkgZW4gbW9zYWlrcmFzdGVyLiBEZW5uZSBmdW5rdGlvbiBrYW4gb2dzw6UgYWdncmVnZXJlIGZsZXJlIHVkc25pdCB0aWwgZXQgZW5rZWx0IHVkc25pdC48ZGl2Pjxici8+RGVubmUgZnVua3Rpb24gYmVoYW5kbGVyIGh2ZXJ0IHVkc25pdCBpIGVuIGZsZXJkaW1lbnNpb25hbCByYXN0ZXIgZWxsZXIgbW9zYWlrcmFzdGVyIHZlZCBoasOmbHAgYWYgZW4gcmFzdGVyZnVua3Rpb25zc2thYmVsb24uIERlbm5lIGZ1bmt0aW9uIHVuZGVyc3TDuHR0ZXIgZsO4bGdlbmRlIGluZHN0aWxsaW5nZXI6IDEuIEFuZ2l2IGVuIHJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uIGZvciBFbGVtZW50ZnVua3Rpb25lbi4gRHUgaGFyIGYuZWtzLiBldCBtb3NhaWtkYXRhc8OmdCwgZGVyIGluZGVob2xkZXIgMjAgw6VycyBMYW5kc2F0LWJpbGxlZGVyLCBvZyBkdSDDuG5za2VyIGF0IGJlcmVnbmUgTkRWSSBmb3IgaHZlciBzY2VuZSBpIHRpZHNzZXJpZW4uIEZvciBFbGVtZW50ZnVua3Rpb25lbiBza2FsIGR1IGFuZ2l2ZSBlbiByYXN0ZXJmdW5rdGlvbnNza2FiZWxvbiwgc29tIGluZGVob2xkZXIgTkRWSS1yYXN0ZXJmdW5rdGlvbmVuLiAyLiBBbmdpdiBlbiByYXN0ZXJmdW5rdGlvbnNza2FiZWxvbiBmb3IgQWdncmVnZXJpbmdzZnVua3Rpb25lbi4gRHUgaGFyIGYuZWtzLiBlbiBmbGVyZGltZW5zaW9uYWwgcmFzdGVyLCBkZXIgaW5kZWhvbGRlciAxMCDDpXJzIGRhZ2xpZ2UgdGVtcGVyYXR1cmRhdGEsIG9nIGR1IMO4bnNrZXIgYXQgYmVyZWduZSBkZW4gbWFrc2ltYWxlIHRlbXBlcmF0dXIgZm9yIGh2ZXJ0IMOlci4gRm9yIEFnZ3JlZ2VyaW5nc2Z1bmt0aW9uZW4gc2thbCBkdSBhbmdpdmUgZW4gcmFzdGVyZnVua3Rpb25zc2thYmVsb24sIHNvbSBpbmRlaG9sZGVyIGZ1bmt0aW9uZW4gQ2VsbGVzdGF0aXN0aWssIG9nIGhhbmRsaW5nZW4gc2thbCB2w6ZyZSBpbmRzdGlsbGV0IHRpbCBNYWtzaW11bS4gVW5kZXIgQWdncmVnZXJpbmdzZGVmaW5pdGlvbiBza2FsIGR1IGluZHN0aWxsZSBEaW1lbnNpb24gdGlsIFN0ZFRpbWUsIGluZHN0aWxsZSBUeXBlIHRpbCBJbnRlcnZhbC1uw7hnbGVvcmQgb2cgaW5kc3RpbGxlIE7DuGdsZW9yZHNpbnRlcnZhbCB0aWwgw4VybGlnLiBCZW3DpnJrLCBhdCBodmlzIGlucHV0LW1vc2Fpa2RhdGFzw6Z0dGV0IGlra2UgZXIgZmxlcmRpbWVuc2lvbmFsdCwgdmlsIGFnZ3JlZ2VyaW5nc2Z1bmt0aW9uZW4gaWtrZSBvdmVyaG9sZGUgYWdncmVnZXJpbmdzZGVmaW5pdGlvbmVuLiBBZ2dyZWdlcmluZ3NmdW5rdGlvbmVuIHZpbCBhZ2dyZWdlcmUgYWxsZSBlbGVtZW50ZXIgZWxsZXIgaHZlciBncnVwcGUgdGlsIMOpbi/DqXQsIGh2aXMgZGlzc2UgZXIgZGVmaW5lcmV0IGkgYWdncmVnZXJpbmdzZnVua3Rpb25zc2thYmVsb25lbi4gRm9yIHlkZXJsaWdlcmUgb3BseXNuaW5nZXIgb20gYnJ1ZyBhZiBncnVwcGVyIGkgZXQgbW9zYWlrZGF0YXPDpnQsIHNlIEJydWcgYWYgbW9zYWlrZGF0YXPDpnQgaSBSYXN0ZXJmdW5rdGlvbnNza2FiZWxvbmVyLiAzLiBBbmdpdiBlbiByYXN0ZXJmdW5rdGlvbnNza2FiZWxvbiBmb3IgQmVoYW5kbGluZ3NmdW5rdGlvbmVuLiBGdW5rdGlvbmVuIGVsbGVyIGZ1bmt0aW9uc2vDpmRlbiBpIGRlbm5lIHNrYWJlbG9uIGFudmVuZGVzIHRpbCBhdCB2aXNlIGRlbiBueWUgYmVoYW5kbGVkZSByYXN0ZXIuIEFuZ2l2IGYuZWtzLiBlbiByYXN0ZXJmdW5rdGlvbnNza2FiZWxvbiwgZGVyIGluZGVob2xkZXIgZnVua3Rpb25lbiBGYXJ2ZWtvcnQsIGZvciBhdCDDpm5kcmUgbcOlZGVuLCBodm9ycMOlIGRldCBiZWhhbmRsZWRlIHJhc3RlcmxhZyB2aXNlcy4gQmVtw6ZyaywgYXQgaHZpcyBpbnB1dHRldCBlciBlbiBmbGVyZGltZW5zaW9uYWwgcmFzdGVyLCBzw6UgYW52ZW5kZXMgYmVoYW5kbGluZ3NmdW5rdGlvbmVuIHRpbCBkZXQgYWt0dWVsbGUgdmlzbmluZ3N1ZHNuaXQuIEh2aXMgaW5wdXR0ZXQgZXIgZXQgbW9zYWlrbGFnIGVsbGVyIGV0IG1vc2Fpa2RhdGFzw6Z0LCBzw6UgYW52ZW5kZXMgYmVoYW5kbGluZ3NmdW5rdGlvbmVuIHRpbCBtb3NhaWtyYXN0ZXJlbiB2ZWQgYnJ1ZyBhZiBkZW4gZsO4cnN0ZSBtZXRvZGUgdGlsIG9wbMO4c25pbmcgYWYgb3ZlcmxhcC4gMy4gQW5naXYgc2thYmVsb25lciB0aWwgZW5odmVyIGtvbWJpbmF0aW9uIGFmIGRlIHRyZSBmdW5rdGlvbmVyLiBEdSBoYXIgZi5la3MuIGV0IG1vc2Fpa2RhdGFzw6Z0LCBkZXIgaW5kZWhvbGRlciB0aWRzc2VyaWVyIG1lZCBMYW5kc2F0LWJpbGxlZGVyLCBvZyBkdSDDuG5za2VyICBhdCBnZW5lcmVyZSBldCBzYW1tZW5zYXQgYmlsbGVkZSBtZWQgbWFrc2ltYWwgTkRWSS4gRm9yIEVsZW1lbnRmdW5rdGlvbmVuIHNrYWwgZHUgYW5naXZlIGVuIHJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uLCBzb20gaW5kZWhvbGRlciBORFZJLXJhc3RlcmZ1bmt0aW9uZW4uIEZvciBBZ2dyZWdlcmluZ3NmdW5rdGlvbmVuIHNrYWwgZHUgYW5naXZlIGVuIHJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uLCBzb20gaW5kZWhvbGRlciBmdW5rdGlvbmVuIENlbGxlc3RhdGlzdGlrLCBvZyBoYW5kbGluZ2VuIHNrYWwgdsOmcmUgaW5kc3RpbGxldCB0aWwgTWFrc2ltdW0uIEZvciBCZWhhbmRsaW5nc2Z1bmt0aW9uZW4gc2thbCBkdSBhbmdpdmUgZW4gcmFzdGVyZnVua3Rpb25zc2thYmVsb24sIHNvbSBpbmRlaG9sZGVyIGZ1bmt0aW9uZW4gRmFydmVrb3J0LiBCZW3DpnJrLCBhdCBmdW5rdGlvbnNiZWhhbmRsaW5nc3LDpmtrZWbDuGxnZW4gZsO4bGdlciBpbnB1dHBhcmFtZXRyZW5lcyByw6Zra2Vmw7hsZ2UuIEVsZW1lbnRmdW5rdGlvbmVuIHZpbCBmLmVrcy4gYmxpdmUgYmVoYW5kbGV0IGbDuHJzdC48L2Rpdj5cIixcblx0XHRyYW5kb21OYW1lOiBcIlZpbGvDpXJsaWdcIixcblx0XHRyYW5kb21TbmlwOiBcIk9wcmV0dGVyIGVuIHJhc3RlciBtZWQgdmlsa8OlcmxpZ2UgcGl4ZWx2w6ZyZGllciwgZGVyIHRyw6Zra2VzIGZyYSBlbiBwc2V1ZG8tdmlsa8OlcmxpZyBkaXN0cmlidXRpb24uIEZsZXJlIGRpc3RyaWJ1dGlvbmVyIG9nIGdlbmVyYXRvcmVyIGFmIHRpbGbDpmxkaWdlIHRhbCB1bmRlcnN0w7h0dGVzLlwiLFxuXHRcdHJhbmRvbURlc2M6IFwiRnVua3Rpb25lbiBWaWxrw6VybGlnIG9wcmV0dGVyIGVuIHJhc3RlciBtZWQgdmlsa8OlcmxpZ2UgcGl4ZWx2w6ZyZGllciwgZGVyIGthbiBhbnZlbmRlcyBpIHJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uZXIgZWxsZXIgbW9zYWlrZGF0YXPDpnQuPGRpdj48YnIvPk1lbnMgbWFuZ2UgZnVua3Rpb25lciBmdW5nZXJlciBzYW1tZW4gbWVkIMOpbiBlbGxlciBmbGVyZSBpbnB1dC1yYXN0ZXJlLCBrcsOmdmVyIGZ1bmt0aW9uZW4gVmlsa8OlcmxpZyBpa2tlIG5vZ2VuIGlucHV0LXJhc3Rlci4gRGV0dGUgYmV0eWRlciwgYXQgZGVuIGkgaMO4amVyZSBncmFkIGFnZXJlciBzb20gZXQgcmFzdGVyZGF0YXPDpnQgZW5kIHNvbSBlbiBmdW5rdGlvbiwgc8OlIGRlciBza2FsIHVkdmlzZXMgc8OmcmxpZyBmb3JzaWd0aWdoZWQsIG7DpXIgZGVuIHRpbGbDuGplcyB0aWwgZWxsZXIgZmplcm5lcyBmcmEgZnVua3Rpb25za8OmZGVuLjwvZGl2PlwiLFxuXHRcdHNocmlua05hbWU6IFwiRm9ybWluZHNrXCIsXG5cdFx0c2hyaW5rU25pcDogXCJGb3JtaW5kc2tlciBkZSB2YWxndGUgem9uZXIgbWVkIGV0IGFuZ2l2ZXQgYW50YWwgY2VsbGVyIHZlZCBhdCBlcnN0YXR0ZSBkZW0gbWVkIHbDpnJkaWVuIGFmIGRlbiBjZWxsZSwgZGVyIGVyIGRlbiBvZnRlc3QgZm9yZWtvbW1lbmRlIGkgZGVucyBvbWdpdmVsc2VyLlwiLFxuXHRcdHNocmlua0Rlc2M6IFwiTWVkIGZ1bmt0aW9uZW4gRm9ybWluZHNrIGdsb2JhbHQga2FuIGR1IGdlbmVyYWxpc2VyZSDigJMgZWxsZXIgZm9yZW5rbGUg4oCTIHJhc3RlcmUgdmVkIGF0IGfDuHJlIGJlc3RlbXRlIHpvbmVyIG1pbmRyZS4gRHUga2FuIG9nc8OlIGtvbnRyb2xsZXJlIGdyYWRlbiBhZiBnZW5lcmFsaXNlcmluZywgZGVyIHZpbCBmb3Jla29tbWUuPGRpdj48YnIvPkRlIHpvbmVyLCBkdSB2w6ZsZ2VyLCB2aWwgYmxpdmUgZm9ybWluZHNrZXQg4oCTIGVsbGVyIHJlZHVjZXJldCDigJMgaSBzdMO4cnJlbHNlLCB2ZWQgYXQgY2VsbGVyIGZyYSBkZSBvbWdpdmVuZGUgem9uZXIgdWR2aWRlcyBpbmQgaSBkZW0uIERlIHZhbGd0ZSB6b25ldsOmcmRpZXIga2FuIOKAkyByZW50IGJlZ3JlYnNtw6Zzc2lndCDigJMgdmlzZXMgc29tIGZvcmdydW5kc3pvbmVyLCBtZW5zIGFuZHJlIHbDpnJkaWVyIGZvcnRzYXQgdmlzZXMgc29tIGJhZ2dydW5kc3pvbmVyLiBDZWxsZXJuZSBpIGZvcmdydW5kc3pvbmVybmUga2FuIGVyc3RhdHRlcyBhZiBjZWxsZXIgaSBiYWdncnVuZHN6b25lcm5lLiBcXFwiVHluZGUgw7hlclxcXCIgaW5kZSBpIGVuIHpvbmUsIHNvbSBoYXIgZsOmbGxlcyBncsOmbnNlciBtZWQgem9uZW4sIGthbiBvZ3PDpSB1ZHNraWZ0ZXMuPGRpdj48YnIvPkdyYWRlbiBhZiBnZW5lcmFsaXNlcmluZyBrYW4ga29udHJvbGxlcmVzIG1lZCBwYXJhbWV0ZXJlbiBBbnRhbCBjZWxsZXIuIERlbm5lIHbDpnJkaSBlciBzb20gc3RhbmRhcmQgMSwgaHZpbGtldCBiZXR5ZGVyLCBhdCBkZSB2YWxndGUgem9uZXIgdmlsIGJsaXZlIGZvcm1pbmRza2V0IG1lZCBkZW4gdsOmcmRpLCBkZXIgc3ZhcmVyIHRpbCDDqW4gY2VsbGVzIHN0w7hycmVsc2UuIEh2aXMgZHUgdmlsIMO4Z2UgZ3JhZGVuIGFmIGdlbmVyYWxpc2VyaW5nLCBrYW4gZHUgYW5naXZlIGVuIHN0w7hycmUgdsOmcmRpIGZvciBkZW5uZSBwYXJhbWV0ZXIuIFJlbnQgYmVncmVic23DpnNzaWd0IHN2YXJlciBkZXR0ZSB0aWwgYXQga8O4cmUgdsOmcmt0w7hqZXQgc8OlIG1hbmdlIGdhbmdlIHNvbSBkZXQgYW5naXZuZSBhbnRhbCwgaHZpbGtldCBiZXR5ZGVyLCBhdCByZXN1bHRhdGVybmUgZnJhIGRlbiBmb3JyaWdlIGvDuHJzZWwgYmxpdmVyIGluZHNhdCBpIGRlbiBlZnRlcmbDuGxnZW5kZSBrw7hyc2VsLjwvZGl2PlwiLFxuXHRcdHRyZW5kVG9SR0JOYW1lOiBcIlRlbmRlbnMgdGlsIFJHQlwiLFxuXHRcdHRyZW5kVG9SR0JTbmlwOiBcIktvbnZlcnRlcmVyIGVuIHRlbmRlbnNyYXN0ZXIgdGlsIGVuIHRyZWLDpW5kc3Jhc3RlciAocsO4ZCwgZ3LDuG4gb2cgYmzDpSkuXCIsXG5cdFx0dHJlbmRUb1JHQkRlc2M6IFwiRnVua3Rpb25lbiBUZW5kZW5zIHRpbCBSR0Iga29udmVydGVyZXIgZW4gdGVuZGVuc3Jhc3RlciB0aWwgZW4gdHJlYsOlbmRzcmFzdGVyIChyw7hkLCBncsO4biBvZyBibMOlKS4gVGVuZGVuc3Jhc3RlcmVuIGdlbmVyZXJlcyBmcmEgZnVua3Rpb25lbiBHZW5lcmVyIHRlbmRlbnNyYXN0ZXIgZWxsZXIgcmFzdGVyZnVua3Rpb25lbiBDQ0RDLWFuYWx5c2UuPGRpdj48YnIvPkRlbm5lIGZ1bmt0aW9uIGVyIG55dHRpZyB0aWwgdmlzdWFsaXNlcmluZyBhZiBtb2RlbC1rb2VmZmljaWVudC1kYXRhIGZyYSBmdW5rdGlvbmVuIEdlbmVyZXIgdGVuZGVucyBlbGxlciBmdW5rdGlvbmVuIENDREMtYW5hbHlzZS4gQmVnZ2UgZnVua3Rpb25lciBiZXJlZ25lciB0ZW5kZW5zZXIgaSBwaXhlbHbDpnJkaWVyLCBkZXIgw6ZuZHJlcywgbWVuIGRldCBlciB2YW5za2VsaWd0IGF0IGZvcnRvbGtlIHJlc3VsdGF0ZXJuZSBhZiBmdW5rdGlvbmVybmUgZGlyZWt0ZS48ZGl2Pjxici8+UMOlIHNhbW1lIG3DpWRlIHNvbSBtZWQgYW5kcmUgcmFzdGVyZnVua3Rpb25lciBlciBkdSBtw6Vza2UgbsO4ZHQgdGlsIGF0IGFudmVuZGUgRHluYW1pc2sganVzdGVyaW5nIGFmIG9tcsOlZGUgKERSQSkgZm9yIGF0IGbDpSB2aXN0IHJlc3VsdGF0ZXJuZSBhZiBkZW5uZSBmdW5rdGlvbi48L2Rpdj5cIixcblx0XHRsYW5kVHJlbmRyTmFtZTogXCJMYW5kVHJlbmRyLWFuYWx5c2VcIixcblx0XHRsYW5kVHJlbmRyU25pcDogXCJFdmFsdWVyZXIgw6ZuZHJpbmdlciBpIHBpeGVsdsOmcmRpZXIgb3ZlciB0aWQgdmVkIGhqw6ZscCBhZiBkZW4gTGFuZHNhdC1iYXNlcmVkZSBtZXRvZGUgdGlsIGRldGVrdGVyaW5nIGFmIHRlbmRlbnNlciBpIGZvcnN0eXJyZWxzZXIgb2cgZ2Vub3ByZXRuaW5nIChMYW5kVHJlbmRyKSBvZyBnZW5lcmVyZXIgZW4gw6ZuZHJpbmdzYW5hbHlzZXJhc3RlciwgZGVyIGluZGVob2xkZXIgbW9kZWxyZXN1bHRhdGVybmUuXCIsXG5cdFx0bGFuZFRyZW5kckRlc2M6IFwiRGVubmUgcmFzdGVyZnVua3Rpb24ga2FuIGt1biBhbnZlbmRlcyBzb20gaW5wdXQgdGlsIGZ1bmt0aW9uZW4gRGV0ZWt0w6lyIMOmbmRyaW5nIHZlZCBoasOmbHAgYWYgw6ZuZHJpbmdzYW5hbHlzZXJhc3Rlci4gRm9yIGF0IGdlbmVyZXJlIGV0IHJhc3Rlci1vdXRwdXQgc2thbCBmdW5rdGlvbmVuIExhbmRUcmVuZHItYW5hbHlzZSBmb3JiaW5kZXMgbWVkIGZ1bmt0aW9uZW4gRGV0ZWt0w6lyIMOmbmRyaW5nIHZlZCBoasOmbHAgYWYgw6ZuZHJpbmdzYW5hbHlzZSBpIGVuIHJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uLCBvZyBicnVnIHNrYWJlbG9uZW4gc29tIGlucHV0IGkgZ2VvcHJvY2Vzc2VyaW5nc3bDpnJrdMO4amV0IEdlbmVyw6lyIHJhc3RlciBmcmEgcmFzdGVyZnVua3Rpb24uIFJlc3VsdGF0ZXQgZXIgZW4gcmFzdGVyLCBzb20gaW5kZWhvbGRlciBvcGx5c25pbmdlciBvbSBkZXQgdGlkc3B1bmt0LCBodm9yIHBpeGVsdsOmcmRpZXJuZSDDpm5kcmVkZSBzaWcuPGRpdj48YnI+Rm9ybcOlbGV0IG1lZCBkZW5uZSByYXN0ZXJmdW5rdGlvbiBlciBhdCB1ZHRyw6Zra2Ugw6ZuZHJpbmdlciBpIGV0IG9ic2VydmVyZXQgb2JqZWt0LCBzw6VsZWRlcyBhdCBkZXQgaWRlZWxsZSBmbGVyZGltZW5zaW9uYWxlIGlucHV0YmlsbGVkZSBiw7hyIGluZGZhbmdlIGVuIGVuc2FydGV0IG9ic2VydmF0aW9uIG92ZXIgdGlkIG9nIGLDuHIgaWtrZSBpbmRlaG9sZGUgYXRtb3Nmw6ZyaXNrIGVsbGVyIHNlbnNvcmludGVyZmVyZW5zLCBza3llciBlbGxlciBza3lnZ2UgZnJhIHNreWVyLiBEZW4gYmVkc3RlIHByYWtzaXMgZXIgYXQgYW52ZW5kZSBkYXRhLCBkZXIgZXIgYmxldmV0IG5vcm1hbGlzZXJldCBvZyBrYW4gbWFza2VyZXMgdmVkIGhqw6ZscCBhZiBldCBRYS1iw6VuZCwgZi5la3MuIExhbmRzYXQgQ29sbGVjdGlvbiAxIFN1cmZhY2UgUmVmbGVjdGFuY2UtcHJvZHVrdGVyIG1lZCBlbiBza3ltYXNrZS48ZGl2Pjxicj5GdW5rdGlvbmVuIHVkZsO4cmVyIGFuYWx5c2UgcMOlIMOpdCBiaWxsZWRlIHByLiDDpXIsIG9nIGFudGFsbGV0IGFmIMOlcmxpZ2UgdWRzbml0IHNrYWwgdsOmcmUgbGlnIG1lZCBlbGxlciBzdMO4cnJlIGVuZCBkZW4gdsOmcmRpLCBkZXIgZXIgYW5naXZldCBpIDxzdHJvbmc+bWluaW11bXNhbnRhbGxldCBhZiBvYnNlcnZhdGlvbnMtPC9zdHJvbmc+IHBhcmFtZXRyZS4gRGV0IGFuYmVmYWxlcywgYXQgZHUgaGFyIGRhdGEgZm9yIG1pbmRzdCBzZWtzIMOlci48ZGl2Pjxicj5IdmlzIGR1IGhhciBtw6VuZWRsaWdlLCB1Z2VudGxpZ2UgZWxsZXIgZGFnbGlnZSBkYXRhLCBhbmJlZmFsZXMgZGV0LCBhdCBkdSB2w6ZsZ2VyIGZsZXJlIGJpbGxlZGVyIGZyYSBodmVydCDDpXIgKGhlbHN0IGZyYSBzYW1tZSDDpXJzdGlkKSwgZmplcm5lciBza3llciBvZyBza3lnZ2UgZnJhIHNreWVyIG9nIGtvbWJpbmVyZXIgYmlsbGVkZXJuZSBmb3IgYXQgZ2VuZXJlcmUgw6l0IGVua2VsdCBiaWxsZWRlLCBzb20gaW5kZmFuZ2VyIG9ic2VydmF0aW9uZW4gZ29kdC4gSHZpcyBtw6VuZWRsaWdlLCB1Z2VudGxpZ2UgZWxsZXIgZGFnbGlnZSBkYXRhIGFuZ2l2ZXMgc29tIGRlbiBmbGVyZGltZW5zaW9uYWxlIGlucHV0LXJhc3RlciwgdmlsIGZ1bmt0aW9uZW4gaWRlbnRpZmljZXJlIGV0IHVkc25pdCB0aWwgYW5hbHlzZSBiYXNlcmV0IHDDpSBkZW4gZGF0bywgZGVyIGxpZ2dlciB0w6Z0dGVzdCBww6UgZGVuLCBkZXIgZXIgYW5naXZldCBpIDxzdHJvbmc+c25hcHBpbmdkYXRvLTwvc3Ryb25nPiBwYXJhbWV0ZXJlbi48ZGl2Pjxicj5EZXQgdmlsIG9mdGUgdGFnZSB0aWQgZm9yIGV0IG9iamVrdCBpIGV0IGxhbmRza2FiIGF0IGJsaXZlIGdlbm9wcmV0dGV0IGZyYSBlbiBpa2tlLXBlcm1hbmVudCDDpm5kcmluZyBzw6Vzb20gc2tvdmJyYW5kIGVsbGVyIGluc2VrdGFuZ3JlYi4gRm9yIGF0IGtvbnRyb2xsZXJlIGRlbiBnZW5vcHJldG5pbmdzZ3JhZCwgc29tIGdlbmtlbmRlcyBhZiBtb2RlbGxlbiwgaW5kc3RpbCBwYXJhbWV0ZXJlbiBHZW5vcHJldG5pbmdzdMOmcnNrZWwuIEV0IGZvcnNrZWxsaWd0IHNlZ21lbnQga2FuIGlra2UgaGF2ZSBlbiBnZW5vcHJldG5pbmdzZ3JhZCwgZGVyIGVyIGh1cnRpZ2VyZSBlbmQgMS9nZW5vcHJldG5pbmdzdMOmcnNrZWwuPGRpdj48YnI+R2Vub3ByZXRuaW5nZW4gZnJhIGVuIMOmbmRyaW5nIGkgbGFuZHNrYWIga2FuIHNrZSBpIHBvc2l0aXYgZWxsZXIgbmVnYXRpdiByZXRuaW5nLiBIdmlzIGV0IGxhbmRza2FiIGYuZWtzLiBvcGxldmVyIHNrb3Z0YWIsIHZpc2VyIGVuIHRpZHNzZXJpZSBhZiB2ZWdldGF0aW9uc2luZGVrc3bDpnJkaWVyIGV0IGZhbGQgaSBpbmRla3N2w6ZyZGllciwgb2cgZ2Vub3ByZXRuaW5nZW4gdmlzZXIgZW4gZ3JhZHZpcyBzdGlnbmluZyBpIHZlZ2V0YXRpb25zaW5kZWtzdsOmcmRpZXIgZWxsZXIgZW4gcG9zaXRpdiBnZW5vcHJldG5pbmdzdGVuZGVucy4gQW5naXYgcmV0bmluZ2VuIGZvciBnZW5vcHJldG5pbmdzdGVuZGVuc2VuIG1lZCBwYXJhbWV0ZXJlbiA8c3Ryb25nPkdlbm9wcmV0bmluZyBoYXIgZW4gc3RpZ2VuZGUgdGVuZGVuczwvc3Ryb25nPi5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsTmFtZTogXCJBZ2dyZWfDqXIgZmxlcmRpbWVuc2lvbmFsdFwiLFxuXHRcdGFnZ3JlZ2F0ZU11bHRpZGltZW5zaW9uYWxTbmlwOiBcIktvbWJpbmVyZXIgZWtzaXN0ZXJlbmRlIGZsZXJkaW1lbnNpb25hbGUgcmFzdGVydmFyaWFiZWxkYXRhIGxhbmdzIGVuIGRpbWVuc2lvbi5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsRGVzYzogXCJEZW4gYWdncmVnZXJlZGUgZmxlcmRpbWVuc2lvbmFsZSBmdW5rdGlvbiBvcHJldHRlciBldCBmbGVyZGltZW5zaW9uYWx0IHJhc3RlcmxhZyB2ZWQgYXQga29tYmluZXJlIGVrc2lzdGVyZW5kZSBmbGVyZGltZW5zaW9uYWxlIHJhc3RlcnZhcmlhYmVsZGF0YSBsYW5ncyBlbiBkaW1lbnNpb24uPGRpdj48YnI+QW52ZW5kIDxzdHJvbmc+RGltZW5zaW9uc2RlZmluaXRpb25zLTwvc3Ryb25nPsOCwqAgcGFyYW1ldGVyZW4gdGlsIGbDuHJzdCBhdCBmaWx0cmUgZGUgaW5wdXRkYXRhLCBkdSB2aWwgYWdncmVnZXJlLiBIdmlzIGR1IGYuZWtzLiBoYXIgbcOlbmVkbGlnZSBkYXRhIGZvciAzMCDDpXIsIG1lbiBkdSBrdW4gw7huc2tlciBhdCBvcHJldHRlIGV0IGFnZ3JlZ2VyZXQgbGFnIGZvciBkZSBmw7hyc3RlIDE1IMOlciwga2FuIGR1IGFudmVuZGUgPHN0cm9uZz5EaW1lbnNpb25zZGVmaW5pdGlvbnMtPC9zdHJvbmc+w4LCoCBwYXJhbWV0ZXJlbiB0aWwgYXQgYW5naXZlIGRlIMOlciwgZGVyIHNrYWwgbWVkdGFnZXMgaSBhbmFseXNlbi48ZGl2Pjxicj48dWw+PGxpPlVkdHLDpmsgc2FsdGhvbGRpZ2hlZHNkYXRhIGZvciBtw6VuZWRlbiBqYW51YXIgb3ZlciBlbiBwZXJpb2RlIHDDpSAxMCDDpXIuIFbDpmxnwqA8c3Ryb25nPmVmdGVyIHbDpnJkaWVyPC9zdHJvbmc+LCBpbmRzdGlswqA8c3Ryb25nPmRpbWVuc2lvbjwvc3Ryb25nPnRpbMKgPHN0cm9uZz5TdGRUaW1lPC9zdHJvbmc+LCBvZyBpbmRzdGlswqA8c3Ryb25nPnbDpnJkaWVyPC9zdHJvbmc+dGlswqA8c3Ryb25nPmphbnVhcjwvc3Ryb25nPi48L2xpPjxsaT5PcGRlbCBzYWx0aG9sZGlnaGVkc2RhdGEgb3ZlciBldCBkeWJkZW9tcsOlZGUgZnJhIDAgdGlsIDE1MCBtZXRlci4gVsOmbGfCoDxzdHJvbmc+ZWZ0ZXIgb21yw6VkZXI8L3N0cm9uZz4sIGluZHN0aWzCoDxzdHJvbmc+ZGltZW5zaW9uPC9zdHJvbmc+dGlswqA8c3Ryb25nPlN0ZFo8L3N0cm9uZz4sIG9nIGluZHN0aWw8c3Ryb25nPm1pbmltdW1zLSB2w6ZyZGk8L3N0cm9uZz50aWzCoDxzdHJvbmc+LTE1MDwvc3Ryb25nPm9nwqA8c3Ryb25nPm1ha3NpbXVtcy0gdsOmcmRpPC9zdHJvbmc+dGlswqA8c3Ryb25nPjA8L3N0cm9uZz4uPC9saT48bGk+VWR0csOmayBzYWx0aG9sZGlnaGVkc2RhdGEgZm9yIGRlIGbDuHJzdGUgMTAgZGFnZSBhZiBodmVyIGphbnVhciBtw6VuZWQgaSBlbiAxMCDDpXJzIHBlcmlvZGUuIFbDpmxnPHN0cm9uZz5lZnRlciBnZW50YWdlbHNlPC9zdHJvbmc+LCBpbmRzdGlsPHN0cm9uZz5kaW1lbnNpb248L3N0cm9uZz50aWzCoDxzdHJvbmc+U3RkVGltZTwvc3Ryb25nPiwgaW5kc3RpbMKgPHN0cm9uZz5zdGFydCBww6UgZsO4cnN0ZSBnZW50YWdlbHNlPC9zdHJvbmc+b2c8c3Ryb25nPnNsdXRuaW5nIHDDpSBmw7hyc3RlIGdlbnRhZ2Vsc2U8L3N0cm9uZz50aWwgZGVuIHRpbHN2YXJlbmRlIHN0YXJ0IG9nIHNsdXRuaW5nIHDDpSBnZW50YWdlbHNlc3BlcmlvZGVuLCBpbmRzdGlsPHN0cm9uZz50cmluPC9zdHJvbmc+dGlswqA8c3Ryb25nPjE8L3N0cm9uZz4sIG9nIGluZHN0aWzCoDxzdHJvbmc+ZW5oZWQ8L3N0cm9uZz50aWzCoDxzdHJvbmc+w6VyPC9zdHJvbmc+LjwvbGk+PC91bD48ZGl2Pjxicj5BbnZlbmQgcGFyYW1ldHJlbmXCoDxzdHJvbmc+QWdncmVnZXJpbmcgRGVmaW5pdGlvbjwvc3Ryb25nPnRpbCBhdCB2w6ZsZ2UgZGVuIGRpbWVuc2lvbiwgZGVyIHNrYWwgdnVyZGVyZXMsIG9nIGFnZ3JlZ2VyaW5nc2ludGVydmFsbGV0IHZlZCBoasOmbHAgYWYgZXQgbsO4Z2xlb3JkLCBlbiB2w6ZyZGkgZWxsZXIgZXQgaW50ZXJ2YWwgYWYgdsOmcmRpZXIuIEh2aXMgbWFuIGYuZWtzLiBoYXIgMzAgw6VycyB0ZW1wZXJhdHVyZGF0YSBmb3IgaGF2b3ZlcmZsYWRlbiwgZGVyIGVyIGluZHNhbWxldCBkYWdsaWd0IG9nIGZvciBodmVyIDUgbWV0ZXJzIGR5YmRlIG5lZCB0aWwgMTAwIG1ldGVyLCBrYW4gZHUgYW52ZW5kZSBkZSBmb3Jza2VsbGlnZSBpbmRzdGlsbGluZ2VyIHRpbCBmw7hsZ2VuZGUgc2NlbmFyaWVyOjxkaXY+PGJyPjx1bD48bGk+QWdncmVnw6lyIGRlIGRhZ2xpZ2UgdGVtcGVyYXR1cmRhdGEgdGlsIG3DpW5lZGxpZ2UgZGF0YSwgaHZpcyByZXN1bHRhdGV0IGVyIGVuIGZsZXJkaW1lbnNpb25hbCByYXN0ZXIgbWVkIDEyIHRpZHN1ZHNuaXQsIG9nIGh2ZXJ0IHVkc25pdCBlciBhZ2dyZWdhdGV0IGFmIGh2ZXIgbcOlbmVkIHDDpSB0dsOmcnMgYWYgYWxsZSDDpXJlbmUuIFbDpmxnwqA8c3Ryb25nPmludGVydmFsbsO4Z2xlb3JkPC9zdHJvbmc+b2cgaW5kc3RpbCBuw7hnbGVvcmRldCB0aWzCoDxzdHJvbmc+Z2VudGFnZXMgbcOlbmVkbGlndDwvc3Ryb25nPi48L2xpPjxsaT5BZ2dyZWfDqXIgZGUgZGFnbGlnZSB0ZW1wZXJhdHVyZGF0YSB0aWwgbcOlbmVkbGlnZSBkYXRhLCBodmlzIHJlc3VsdGF0ZXQgZXIgZW4gZmxlcmRpbWVuc2lvbmFsIHJhc3RlciBtZWQgMzYwIHVkc25pdCBlbGxlciAxMiB0aWRzdWRzbml0IHByLiDDpXIgKDMwIMOlciB4IDEyIG3DpW5lZGVyID0gMzYwIHVkc25pdCkuIFbDpmxnPHN0cm9uZz5pbnRlcnZhbG7DuGdsZW9yZDwvc3Ryb25nPsOCwqBvZyBpbmRzdGlsIG7DuGdsZW9yZGV0IHRpbMKgPHN0cm9uZz5tw6VuZWRsaWd0PC9zdHJvbmc+LjwvbGk+PGxpPkFnZ3JlZ8OpciBtw6VuZWRsaWdlIHRlbXBlcmF0dXJkYXRhIHRpbCA0LW3DpW5lZHMgaW50ZXJ2YWxsZXIuIFbDpmxnwqA8c3Ryb25nPmludGVydmFsdsOmcmRpPC9zdHJvbmc+LCBpbmRzdGlsPHN0cm9uZz52w6ZyZGlpbnRlcnZhbDwvc3Ryb25nPnRpbMKgNCwgb2cgaW5kc3RpbMKgPHN0cm9uZz5lbmhlZDwvc3Ryb25nPnRpbMKgPHN0cm9uZz5tw6VuZWRlcjwvc3Ryb25nPi48L2xpPjxsaT5BZ2dyZWfDqXIgdGVtcGVyYXR1cmRhdGEgZnJhIDAgdGlsIDI1IG1ldGVyLCBkZXJlZnRlciBmcmEgMjUgdGlsIDUwIG1ldGVyLCBkZXJlZnRlciBmcmEgNTAgdGlsIDEwMCBtZXRlci4gVsOmbGfCoDxzdHJvbmc+aW50ZXJ2YWxvbXLDpWRlcjwvc3Ryb25nPm9nIGFuZ2l2IG1pbmltdW1zLSBvZyBtYWtzaW11bXNkeWJkZXIgc29twqA8c3Ryb25nPjAgMjU7IDI1IDUwOyA1MCAxMDA8L3N0cm9uZz4uPC9saT48L3VsPlwiLFxuXHRcdG1lcmdlUmFzdGVyc05hbWU6IFwiRmxldCByYXN0ZXJlXCIsXG5cdFx0bWVyZ2VSYXN0ZXJzU25pcDogXCJLb21iaW5lcmVyIGZsZXJlIHJhc3RlcmRhdGFzw6Z0IHJ1bWxpZ3QgZWxsZXIgcMOlIHR2w6ZycyBhZiB2YXJpYWJsZXIgb2cgZGltZW5zaW9uZXIuXCIsXG5cdFx0bWVyZ2VSYXN0ZXJzRGVzYzogXCJEZW5uZSBmdW5rdGlvbiBvcHJldHRlciBlbiBmbGV0dGV0IHJhc3RlciBmcmEgZW4gbGlzdGUgYWYgcmFzdGVyZS4gSHZpcyBkdSBla3NlbXBlbHZpcyBoYXIgZXQgbW9zYWlrZGF0YXPDpnQsIHNvbSBpbmRlaG9sZGVyIG3DpW5lZGxpZ2UgbmVkYsO4cnNkYXRhIGZvciAzMCDDpXIsIG9nIGV0IGFuZGV0IGRhdGFzw6Z0IG1lZCBtw6VuZWRsaWdlIHRlbXBlcmF0dXJkYXRhIGZvciAxMCDDpXIsIGthbiBkdSBrb21iaW5lcmUgZGVtIHRpbCBlbiBmbGVyZGltZW5zaW9uYWwgcmFzdGVyIG1lZCBiZWdnZSB2YXJpYWJsZXIuIDxkaXY+PGJyPkh2aXMgZGUgZmxlcmRpbWVuc2lvbmFsZSBpbnB1dC1yYXN0ZXJlIGluZGVob2xkZXIgZm9yc2tlbGxpZ2UgdmFyaWFibGVyLCB2aWwgZGUgZmxlcmRpbWVuc2lvbmFsZSBvdXRwdXQtcmFzdGVyZSBpbmRlaG9sZGUgYWxsZSB2YXJpYWJsZXJuZS4gPGRpdj48YnI+SHZpcyBkZSBmbGVyZGltZW5zaW9uYWxlIGlucHV0LXJhc3RlcmUgaW5kZWhvbGRlciBmb3Jza2VsbGlnZSBkaW1lbnNpb25zdsOmcmRpZXIsIHZpbCBkZW4gZmxlcmRpbWVuc2lvbmFsZSBvdXRwdXQtcmFzdGVyIGluZGVob2xkZSBhbGxlIGRpbWVuc2lvbmVybmUgb2cgZGltZW5zaW9uc3bDpnJkaWVybmUuIDxkaXY+PGJyPkh2aXMgZGUgZmxlcmRpbWVuc2lvbmFsZSBpbnB1dC1yYXN0ZXJlIGluZGVob2xkZXIgZm9yc2tlbGxpZ2UgZGltZW5zaW9uZXIgb2cgdmFyaWFibGVyLCBtZW4gZm9yc2tlbGxpZ2Ugc3BhdGlhbGUgdWRzdHLDpmtuaW5nZXIsIHZpbCBkZW4gZmxlcmRpbWVuc2lvbmFsZSBvdXRwdXQtcmFzdGVyIGluZGVob2xkZSB2YXJpYWJsZXJuZSBvZyBkaW1lbnNpb25lcm5lIHDDpSB0dsOmcnMgYWYgZGUgZmxldHRlZGUgc3BhdGlhbGUgdWRzdHLDpmtuaW5nZXIuPGRpdj48YnI+RGVubmUgZnVua3Rpb24ga2FuIG9nc8OlIGJydWdlcywgaHZpcyBkdSBoYXIgZmxlcmUgcmFzdGVyZSwgc29tIGR1IMO4bnNrZXIgYmVoYW5kbGV0IHNvbSDDqXQgZWxlbWVudCwgZi5la3MuIGJlcmVnbmluZyBhZiBzYW1tZSBzdGF0aXN0aWtrZXIgZm9yIGFsbGUsIGVsbGVyIGh2aXMgZGVyIGVyIGZhcnZlYWZiYWxhbmNlcmluZywgYmVow7h2ZXIgZHUgaWtrZSBhdCBmYXJ2ZWFmYmFsYW5jZXJlIGh2ZXJ0IGVua2VsdCBiaWxsZWRlIHNlcGFyYXQuIERldHRlIGVyIG55dHRpZ3QgdmVkIGFyYmVqZGUgbWVkIGJpbGxlZGVyLCBkZXIgZXIgZ2VtdCBzb20gc2VwYXJhdGUgdGlsZXMgcMOlIGdydW5kIGFmIGJlZ3LDpm5zbmluZ2VyIGkgZmlsc3TDuHJyZWxzZS4gUMOlIGRlbiBtw6VkZSB2aWwgZGUgcMOlZ8OmbGRlbmRlIHRpbGVzIGJsaXZlIGJlaGFuZGxldCBzb20gZW4gZGVsIGFmIGRldCBzYW1tZSBiaWxsZWRlLlwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5OYW1lOiBcIkdyw6Zuc2V1ZGrDpnZuaW5nXCIsXG5cdFx0Ym91bmRhcnlDbGVhblNuaXA6IFwiVWRqw6Z2bmVyIGdyw6Zuc2VuIG1lbGxlbSB6b25lci5cIixcblx0XHRib3VuZGFyeUNsZWFuRGVzYzogXCI8cD5GdW5rdGlvbmVuIGdlbmVyYWxpc2VyZXIg4oCTIGVsbGVyIGZvcmVua2xlciDigJMgcmFzdGVyZSB2ZWQgYXQgdWRqw6Z2bmUgZ3LDpm5zZXJuZSBtZWxsZW0gem9uZXIuIEZ1bmt0aW9uZW4gZ2l2ZXIgbXVsaWdoZWQgZm9yIGF0IGtvbnRyb2xsZXJlLCBodm9yZGFuIGNlbGxlcm5lIGkgem9uZXJuZSBpIGlucHV0dGV0IHDDpXZpcmtlciB1ZGrDpnZuaW5nZW4gb2cgZGVuIG3Dpm5nZGUgdWRqw6Z2bmluZywgZGVyIHZpbCBibGl2ZSBhbnZlbmR0LiBIdmVyIGlucHV0Y2VsbGUgdnVyZGVyZXMgdmVkIGhqw6ZscCBhZiBzaW5lIG90dGUgbsOmcm1lc3RlIG5hYm9lci48L3A+PHA+VWRqw6Z2bmluZ3Nwcm9jZXNzZW4gc29ydGVyZXIgZsO4cnN0IG5hYm9jZWxsZXJuZSB1ZCBmcmEgZW4gYmVzdGVtdCBwcmlvcml0ZXJpbmcuIERlbm5lIHByaW9yaXRlcmluZyBiZXN0ZW1tZXIsIGh2aWxrZW4gem9uZSBmcmEgbmFib2NlbGxlcm5lIGRlciBrYW4gZXJzdGF0dGUgdsOmcmRpZW4gYWYgZGVuIGJlaGFuZGxlZGUgY2VsbGUgaSBvdXRwdXR0ZXQuPC9wPjxwPlByaW9yaXRlcmluZ2VuIGthbiB2w6ZyZSBiYXNlcmV0IHDDpSB6b25lcm5lcyB2w6ZyZGkgZWxsZXIgc3TDuHJyZWxzZS4gUGFyYW1ldGVyZW4gPHN0cm9uZz5Tb3J0ZXJpbmdzdHlwZTwvc3Ryb25nPiBiZXN0ZW1tZXIsIGh2aWxrZW4gc29ydGVyaW5nc3R5cGUgZGVyIGFudmVuZGVzLiA8L3A+PHA+U3RhbmRhcmRpbmRzdGlsbGluZ2VuIDxzdHJvbmc+U29ydMOpciBpa2tlPC9zdHJvbmc+IHZ1cmRlcmVyIHByaW9yaXRlcmluZ2VuIHVkIGZyYSB6b25lcm5lcyB2w6ZyZGkuIENlbGxlciBmcmEgem9uZXIgbWVkIHN0w7hycmUgdsOmcmRpZXIgdmlsIGhhdmUgZW4gaMO4amVyZSBwcmlvcml0ZXJpbmcgbWVkIGhlbmJsaWsgcMOlIGF0IHVkdmlkZSBzaWcgdGlsIHpvbmVyIG1lZCBtaW5kcmUgdsOmcmRpZXIuPC9wPjxwPlN0w7hycmVsc2VuIOKAkyBlbGxlciBkZXQgc2FtbGVkZSBvbXLDpWRlIOKAkyBhZiB6b25lcm5lIGthbiBicnVnZXMgdGlsIGF0IHNvcnRlcmUgcHJpb3JpdGVyaW5nZW4uIE1lZCBpbmRzdGlsbGluZ2VuIDxzdHJvbmc+RmFsZGVuZGU8L3N0cm9uZz4gc29ydGVyZXMgem9uZXJuZSBlZnRlciBzdMO4cnJlbHNlIGkgZmFsZGVuZGUgcsOma2tlZsO4bGdlLiBab25lciBtZWQgc3TDuHJyZSBzYW1sZWRlIG9tcsOlZGVyIHZpbCBoYXZlIHByaW9yaXRlcmluZyBtZWQgaGVuYmxpayBww6UgYXQgdWR2aWRlIHNpZyB0aWwgem9uZXIgbWVkIG1pbmRyZSBvbXLDpWRlci4gTWVkIGluZHN0aWxsaW5nZW4gPHN0cm9uZz5TdGlnZW5kZTwvc3Ryb25nPiBlciBkZXQgb212ZW5kdGUgc2FuZHQ6IHpvbmVyIG1lZCBtaW5kcmUgc2FtbGVkZSBvbXLDpWRlciB2aWwgaGF2ZSBwcmlvcml0ZXJpbmcgdGlsIGF0IHVkdmlkZSBzaWcgdGlsIHpvbmVyIG1lZCBzdMO4cnJlIHNhbWxlZGUgb21yw6VkZXIuPC9wPjxwPk3Dpm5nZGVuIGFmIHVkasOmdm5pbmcgc3R5cmVzIGFmIHBhcmFtZXRlcmVuIDxzdHJvbmc+S8O4ciB1ZHZpZGVsc2Ugb2cgZm9ybWluZHNrZWxzZSB0byBnYW5nZTwvc3Ryb25nPiwgaHZpbGtldCBiZXN0ZW1tZXIgZGV0IGFudGFsIGdhbmdlIHVkdmlkZWxzZXMtIG9nIGZvcm1pbmRza2Vsc2VzcHJvY2Vzc2VuIHZpbCBibGl2ZSB1ZGbDuHJ0LjwvcD48cD5IdmlzIGluZHN0aWxsaW5nZW4gaWtrZSBlciBtYXJrZXJldCwgdWRmw7hyZXMgdWR2aWRlbHNlcy0gb2cgZm9ybWluZHNrZWxzZXNwcm9jZXNzZW4gw6luIGdhbmcuIE7DpXIgaW5kc3RpbGxpbmdlbiBlciBtYXJrZXJldCwgdWRmw7hyZXMgdWR2aWRlbHNlcy0gb2cgZm9ybWluZHNrZWxzZXNwcm9jZXNzZW4gdG8gZ2FuZ2UsIGh2aWxrZXQgcmVzdWx0ZXJlciBpIGVuIHlkZXJsaWdlcmUgdWRqw6Z2bmluZyBhZiB6b25lZ3LDpm5zZXJuZS48L3A+PHA+SHZpcyB2w6ZyZGllcm5lIGZvciBhbGxlIG90dGUgbmFib2NlbGxlciBlciBkZSBzYW1tZSBzb20gZm9yIGJlaGFuZGxpbmdzY2VsbGVuLCBiZXZhcmVyIG91dHB1dGNlbGxlbiBkZW4gc2FtbWUgdsOmcmRpIHNvbSBpbnB1dC1jZWxsZW4uPC9wPlwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25OYW1lOiBcIkZvcnVkc2lnIHZlZCBicnVnIGFmIHJlZ3Jlc3Npb25cIixcblx0XHRwcmVkaWN0VXNpbmdSZWdyZXNzaW9uU25pcDogXCJCZXJlZ25lciBlbiBwcm9nbm9zZWJhc2VyZXQgcmFzdGVyIGJhc2VyZXQgcMOlIGlucHV0IG9tIHJhc3RlcmRhdGEgb2cgZW4gcmVncmVzc2lvbnNtb2RlbC4gUmVncmVzc2lvbnNtb2RlbGxlbiBlciBvdXRwdXR0ZXQgZnJhIDxzdHJvbmc+VHJhaW4gUmFuZG9tIFRyZWVzIFJlZ3Jlc3Npb24gTW9kZWw8L3N0cm9uZz4sIGRlciBlciBldCB2w6Zya3TDuGogdGlsIGdlb2JlaGFuZGxpbmcgYWYgcmFzdGVyLlwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25EZXNjOiBcIjxwPlJlZ3Jlc3Npb25zbW9kZWxsZW4gZXIgZGVmaW5lcmV0IGkgZW4gRXNyaS1yZWdyZXNzaW9uc2RlZmluaXRpb25zZmlsICguZWNkKS4gRGVuIGluZGVob2xkZXIgYWxsZSBvcGx5c25pbmdlcm5lIGZvciBldCBzcGVjaWZpa3QgZGF0YXPDpnQgZWxsZXIgZXQgc8OmdCBhZiBkYXRhc8OmdCBvZyByZWdyZXNzaW9uc21vZGVsbGVuIG9nIGdlbmVyZXJlcyBhZiA8c3Ryb25nPlRyYWluIFJhbmRvbSBUcmVlcyBSZWdyZXNzaW9uIE1vZGVsPC9zdHJvbmc+LCBkZXIgZXIgZXQgdsOmcmt0w7hqIHRpbCBnZW9iZWhhbmRsaW5nIGFmIHJhc3Rlci48L3A+PHA+SW5wdXR0ZXQga2FuIHbDpnJlIHJhc3RlciBtZWQgZXQgZW5rZWx0IGLDpW5kLCBmbGVyZSBiw6VuZCBlbGxlciBmbGVyZSBkaW1lbnNpb25lciBlbGxlciBlbiBsaXN0ZSBvdmVyIGRpc3NlIHR5cGVyLiBUeXBlcm5lIGFmIGlucHV0cmFzdGVyIHNrYWwgdsOmcmUgYWYgc2FtbWUgdHlwZSBzb20gZGVtLCBkZXIgZXIgdHLDpm5ldCBhZiByZWdyZXNzaW9uc21vZGVsbGVuLjwvcD48dWw+PGxpPk7DpXIgaW5wdXR0ZXQgZXIgcmFzdGVyIG1lZCBmbGVyZSBiw6VuZCwgYmVoYW5kbGVzIGh2ZXJ0IGLDpW5kIHNvbSBlbiBwcm9nbm9zZWJhc2VyZXQgdmFyaWFiZWwuIELDpW5kZW5lIHNrYWwgdsOmcmUgaSBzYW1tZSByw6Zra2Vmw7hsZ2Ugc29tIGlucHV0IG1lZCBmbGVyZSBiw6VuZCBmb3IgdsOmcmt0w7hqZXQgdGlsIHRyw6ZuaW5nIGFmIHJlZ3Jlc3Npb25zbW9kZWxsZXIuPC9saT48bGk+TsOlciBpbnB1dHRldCBlciByYXN0ZXIgaSBmbGVyZSBkaW1lbnNpb25lciwgYmVoYW5kbGVzIGh2ZXIgcmFzdGVyIHNvbSBlbiBwcm9nbm9zZWJhc2VyZXQgdmFyaWFiZWwsIG9nIHZhcmlhYmxlbiBza2FsIHbDpnJlIGV0IGVua2VsdCBiw6VuZCBvZyBoYXZlIGVuIHRpZHNkaW1lbnNpb24uIFZhcmlhYmVscsOma2tlZsO4bGdlbiBvZyAtbmF2bmUgc2thbCB2w6ZyZSBkZXQgc2FtbWUgc29tIGlucHV0dGV0LCBuw6VyIHJlZ3Jlc3Npb25zbW9kZWxsZW4gYmxldiB0csOmbmV0LiBPdXRwdXR0ZXQgZXIgcmFzdGVyIG1lZCBmbGVyZSBkaW1lbnNpb25lci48L2xpPjxsaT5JbnB1dHRldCBrYW4gdsOmcmUgZW4gbGlzdGUgb3ZlciBlbGVtZW50ZXIuIEFudGFsbGV0IGFmIGVsZW1lbnRlciBvZyByw6Zra2Vmw7hsZ2VuIGFmIGVsZW1lbnRlcm5lIHNrYWwgbWF0Y2hlIGlucHV0dGV0LCBkYSByZWdyZXNzaW9uc21vZGVsbGVuIGJsZXYgdHLDpm5ldC48L2xpPjwvdWw+XCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdTdGF0aXN0aWNzTmFtZTogXCJTdGF0aXN0aWsgZm9yIGRpbWVuc2lvbmFsIGZseXRuaW5nXCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdTdGF0aXN0aWNzU25pcDogXCJCZXJlZ25lciBzdGF0aXN0aWsgZm9yIGV0IGJldsOmZ2VsaWd0IHZpbmR1ZSBww6UgZmxlcmRpbWVuc2lvbmFsZSBkYXRhIGxhbmdzIGVuIGFuZ2l2ZXQgZGltZW5zaW9uLlwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc0Rlc2M6IFwiPHA+RnVua3Rpb25lbiBTdGF0aXN0aWsgZm9yIGRpbWVuc2lvbmFsIGZseXRuaW5nIGJlcmVnbmVyIGZvcnNrZWxsaWdlIHN0YXRpc3Rpc2tlIGRhdGEgaSBldCBmb3J1ZGRlZmluZXJldCB2aW5kdWUgZm9yIGFsbGUgZGltZW5zaW9uc3bDpnJkaWVyIGxhbmdzIGVuIGRpbWVuc2lvbi4gRGVubmUgZnVua3Rpb24gdGFnZXIgZXQgZmxlcmRpbWVuc2lvbmFsdCByYXN0ZXJsYWcgc29tIGlucHV0IG9nIG9wcmV0dGVyIGV0IGZsZXJkaW1lbnNpb25hbHQgcmFzdGVybGFnIHNvbSBvdXRwdXQsIGRlciBoYXIgZGVuIHNhbW1lIGRpbWVuc2lvbmFsZSBzdMO4cnJlbHNlIHNvbSBpbnB1dGxhZ2V0LjwvcD48cD5EdSBrYW4gYW5naXZlIGVuIGRpbWVuc2lvbiwgZm9yIGh2aWxrZW4gZGltZW5zaW9uc3bDpnJkaWVybmUgc2thbCB0YWdlcyBpIGJldHJhZ3RuaW5nIHZlZCBiZXJlZ25pbmdlbi4gU29tIHN0YW5kYXJkIGJlcmVnbmVzIGRlbiBsYW5ncyBkZW4gZsO4cnN0ZSBpa2tlLXNwYXRpYWxlIGRpbWVuc2lvbi4gRHUga2FuIG9nc8OlIGFuZ2l2ZSBlbiB2aW5kdWVzc3TDuHJyZWxzZSB2ZWQgYXQgYW5naXZlIHBhcmFtZXRyZW5lIGZvciBkZXQgYmFndWRyZXR0ZWRlIHZpbmR1ZSBvZyBkZXQgZnJlbWFkcmV0dGVkZSB2aW5kdWUuPC9wPjxwPk7DpXIgc3RhdGlzdGlrdHlwZW4gZXIgaW5kc3RpbGxldCB0aWwgcGVyY2VudGlsLCBibGl2ZXIgcGFyYW1ldHJlbmUgcGVyY2VudGlsdsOmcmRpIG9nIHBlcmNlbnRpbCBpbnRlcnBvbGF0aW9uc3R5cGUgdGlsZ8OmbmdlbGlnZS4gRHUga2FuIGJydWdlIGRpc3NlIHBhcmFtZXRyZSB0aWwgYXQgYW5naXZlIHBlcmNlbnRpbGVuIHRpbCBoZW5ob2xkc3ZpcyBhdCBiZXJlZ25lIG9nIHbDpmxnZSBkZW4gaW50ZXJwb2xhdGlvbnN0eXBlLCBkZXIgc2thbCBicnVnZXMuIE7DpXIgc3RhdGlzdGlrdHlwZW4gZXIgaW5kc3RpbGxldCB0aWwgQ2lya3Vsw6ZyIG1pZGRlbHbDpnJkaSwgYmxpdmVyIHBhcmFtZXRlcmVuIENpcmt1bMOmciBvbWJyeWRuaW5nc3bDpnJkaSB0aWxnw6ZuZ2VsaWcuIERlbiBjaXJrdWzDpnJlIG9tYnJ5ZG5pbmdzdsOmcmRpIGJydWdlcyB0aWwgYXQga29udmVydGVyZSBlbiBsaW5lw6ZyIHbDpnJkaSB0aWwgb21yw6VkZXQgZm9yIGV0IGdpdmV0IGNpcmt1bMOmcnQgZ2VubmVtc25pdC48L3A+XCIsXG5cdFx0dGVycmFpbkZsYXR0ZW5GdW5jdGlvbk5hbWU6IFwiVGVycsOmbiB1ZGrDpnZuZXNcIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uU25pcDogXCJLb3JyaWdlcmVyIGlucHV0ZGF0YSBmcmEgc3ludGV0aXNrIGFwZXJ0dXJyYWRhciAoU0FSKSBmb3IgcmFkaW9tZXRyaXNrZSBmb3J2csOmbmduaW5nZXIgcMOlIGdydW5kIGFmIHRvcG9ncmFmaS5cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uRGVzYzogXCI8cD5SYXN0ZXJmdW5rdGlvbmVuIFRlcnLDpm4gdWRqw6Z2bmVzIGtvcnJpZ2VyZXIgaW5wdXRkYXRhIGZyYSBzeW50ZXRpc2sgYXBlcnR1cnJhZGFyIChTQVIpIGZvciByYWRpb21ldHJpc2tlIGZvcnZyw6ZuZ25pbmdlciBww6UgZ3J1bmQgYWYgdG9wb2dyYWZpLjwvcD48cD5JbnB1dHJhZGFyZGF0YSBza2FsIGbDuHJzdCBrYWxpYnJlcmVzIHRpbCBiZXRhLW5vdWdodC4gQnJ1ZyB2w6Zya3TDuGpldCBBbnZlbmQgcmFkaW9tZXRyaXNrIGthbGlicmVyaW5nIHRpbCBhdCBrYWxpYnJlcmUgcmFkYXJkYXRhIHRpbCBiZXRhLW5vdWdodC48L3A+PHA+SHZpcyBpbnB1dC1ERU0gaWtrZSBzcMOmbmRlciBvdmVyIGhlbGUgU0FSLWRhdGFzw6Z0dGV0LCB2aWwgdsOmcmt0w7hqZXQgZ2VuZXJlcmUgTm9EYXRhLXbDpnJkaWVyIGZvciBwaXhlbHMgdWRlbiBmb3IgREVNLXVkc3Ryw6ZrbmluZ2VuIGZvciBnYW1tYS1ub3VnaHQsIHNpZ21hLW5vdWdodCwgcHVua3RvbXLDpWRlLCBvZyBnZW9tZXRyaXNrZSBmb3J2csOmbmduaW5nc291dHB1dC4gRm9yIGRldCBnZW9tZXRyaXNrZSBmb3J2csOmbmduaW5nc21hc2tlLW91dHB1dCB2aWwgdsOmcmt0w7hqZXQgZ2VuZXJlcmUgdWJlc3RlbXRlIHbDpnJkaWVyIGZvciBwaXhlbHMgdWRlbiBmb3IgREVNLXVkc3Ryw6ZrbmluZ2VuLjwvcD48cD5JbnB1dCBERU0gc2thbCB2w6ZyZSBpIFdHUyAxOTg0IChFUFNHOjQzMjYpIGdlb2dyYWZpc2sga29vcmRpbmF0c3lzdGVtLjwvcD5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uTmFtZTogXCJPcHJldCBmYXJ2ZXNhbW1lbnPDpnRuaW5nXCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvblNuaXA6IFwiT3ByZXR0ZXIgZXQgdHJlYsOlbmRzcmFzdGVyIHVkIGZyYSBldCBtdWx0aWLDpW5kcy1yYXN0ZXJkYXRhc8OmdCwgaHZvciBodmVydCBiw6VuZCBrYW4gYnJ1Z2UgZW4gYWxnZWJyYWlzayBiZXJlZ25pbmcgYmFzZXJldCBww6UgYsOlbmRhbGdlYnJhLlwiLFxuXHRcdGNyZWF0ZUNvbG9yQ29tcG9zaXRlRnVuY3Rpb25EZXNjOiBcIjxwPkZ1bmt0aW9uZW4gT3ByZXQgZmFydmVzYW1tZW5zw6Z0bmluZ3NyYXN0ZXIgb3ByZXR0ZXIgZW4gdHJlYsOlbmRzcmFzdGVyIHVkIGZyYSBldCBtdWx0aWLDpW5kcy1yYXN0ZXJkYXRhc8OmdCwgaHZvciBodmVydCBiw6VuZCBrYW4gYnJ1Z2UgZW4gYWxnZWJyYWlzayBiZXJlZ25pbmcgYmFzZXJldCBww6UgYsOlbmRhbGdlYnJhLjwvcD48cD5Ow6VyIGR1IGRlZmluZXJlciBlbiBiw6VuZGFyaXRtZXRpc2sgYWxnb3JpdG1lLCBrYW4gZHUgaW5kdGFzdGUgZW4gYWxnZWJyYWlzayBmb3JtZWwgcMOlIGVuIGVua2VsdCBsaW5qZSBmb3IgaHZlcnQgdWR0cnlrIGZvciBhdCBvcHJldHRlIGV0IGZsZXJiw6VuZHNvdXRwdXQuIERlIHVuZGVyc3TDuHR0ZWRlIG9wZXJhdG9yZXIgZXIgdW5pdMOmcmUsIHBsdXMgKCspLCBtaW51cyAoLSksIGdhbmdlICgqKSBvZyBkaXZpZGVyICgvKS48L3A+PHA+TsOlciBkdSBicnVnZXIgZXQgYsOlbmQtaWQgaSBldCB1ZHRyeWssIHNrYWwgZHUgaWRlbnRpZmljZXJlIGLDpW5kZXQgdmVkIGF0IHPDpnR0ZSBCIGVsbGVyIGIgZm9yYW4gYsOlbmRudW1tZXJldC48L3A+PHA+RW4gYWxtaW5kZWxpZyBiw6VuZGtvbWJpbmF0aW9uLCBkZXIgYnJ1Z2VzIHRpbCBzeW50ZXRpc2sgYXBlcnR1cnJhZGFyIChTQVIpIGkgbGluZcOmcmUgZW5oZWRlciwgZXIgVlYgZm9yIHLDuGQsIFZIIGZvciBncsO4biBvZyBWVi9WSCBmb3IgYmzDpS4gSHZpcyBpbnB1dGRhdGEgZXIgaSBkZWNpYmVsLCBza2FsIGLDpW5ka29tYmluYXRpb25lbiB2w6ZyZSBWViBmb3IgcsO4ZCwgVkggZm9yIGdyw7huIG9nIFZWLVZIIGZvciBibMOlLjwvcD5cIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc05hbWU6IFwiT3ZlcmZsYWRlcGFyYW1ldHJlXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNTbmlwOiBcIkJlc3RlbW1lciBwYXJhbWV0cmUgZm9yIGVuIHJhc3Rlcm92ZXJmbGFkZSBzw6Vzb20gYXNwZWt0LCBow6ZsZG5pbmcgb2cgYWRza2lsbGlnZSB0eXBlciBrcnVtbmluZ2VyIHZlZCBicnVnIGFmIGdlb2TDpnRpc2tlIG1ldG9kZXIuXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNEZXNjOiBcIjxwPkZ1bmt0aW9uZW4gT3ZlcmZsYWRlcGFyYW1ldHJlIGJlc3RlbW1lciBwYXJhbWV0cmUgZm9yIGVuIHJhc3Rlcm92ZXJmbGFkZSBzw6Vzb20gYXNwZWt0LCBow6ZsZG5pbmcgb2cgYWRza2lsbGlnZSB0eXBlciBrcnVtbmluZ2VyIHZlZCBicnVnIGFmIGdlb2TDpnRpc2tlIG1ldG9kZXIuPC9wPjxwPkRlbm5lIGZ1bmt0aW9uIGthbiBhbnZlbmRlcyB0aWwgZsO4bGdlbmRlIGFwcGxpa2F0aW9uZXI6PC9wPjx1bD48bGk+QmVyZWduaW5nIGFmIGFzcGVrdCBvZyBow6ZsZG5pbmcgdmVkIGJydWcgYWYgZ2VvZMOmdGlza2UgbWV0b2Rlci48L2xpPjxsaT5CZXJlZ25pbmcgYWYgZm9yc2tlbGxpZ2UgdHlwZXIga3J1bW5pbmdlciB1ZCBmcmEgZW4gaW5wdXQtcmFzdGVyb3ZlcmZsYWRlIGYuZWtzLiA8c3Ryb25nPlRhbmdlbnRpYWwga3J1bW5pbmcgKG5vcm1hbCBrb250dXIpPC9zdHJvbmc+LCBkZXIga2FyYWt0ZXJpc2VyZXIgc3Ryw7htbWVucyB0b3BvZ3JhZmlza2Uga29udmVyZ2VucyBvZyBkaXZlcmdlbnMgaGVub3ZlciBlbiBvdmVyZmxhZGUuPC9saT48L3VsPlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yTmFtZTogXCJNaW5kc3Qgb21rb3N0bmluZ3NmdWxkZSBrb3JyaWRvclwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yU25pcDogXCJCZXJlZ25lciBzdW1tZW4gYWYgdG8gYWZzdGFuZHNyYXN0ZXJlIG1lZCBha2t1bXVsZXJlZGUgb21rb3N0bmluZ2VyIG1lZCBtdWxpZ2hlZCBmb3IgYXQgYW52ZW5kZSBlbiB0w6Zyc2tlbCBiYXNlcmV0IHDDpSBwcm9jZW50IGVsbGVyIGFra3VtdWxlcmVkZSBvbWtvc3RuaW5nZXIuXCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JEZXNjOiBcIjxwPklucHV0cmFzdGVybmUgc2thbCB2w6ZyZSBhZnN0YW5kc2Fra3VtdWxlcmluZ3MtIG9nIHRpbGJhZ2VyZXRuaW5nc3Jhc3RlcmUgZnJhIGZ1bmt0aW9uZW48c3Ryb25nPkFmc3RhbmRzYWtrdW11bGVyaW5nPC9zdHJvbmc+IGVsbGVyIDxzdHJvbmc+QWZzdGFuZHNhbGxva2VyaW5nPC9zdHJvbmc+LiBEaXNzZSBza2FsIHbDpnJlIGJhc2VyZXQgcMOlIG9ta29zdG5pbmcvYWZzdGFuZCwgb2cgZGUgc2FtbWUgcGFyYW1ldGVyaW5kc3RpbGxpbmdlciBza2FsIGJydWdlcywgbsOlciBsYWdlbmUgZm9yIGh2ZXIga2lsZGUgb3ByZXR0ZXMuIEluZ2VuIHBhcmFtZXRyZSwgZGVyIGFmaMOmbmdlciBhZiByZXRuaW5nIChob3Jpc29udGFsIGZha3RvciwgdmVydGlrYWwgZmFrdG9yIG9nIGJldsOmZ2Vsc2VzcmV0bmluZyksIGLDuHIgYnJ1Z2VzIHRpbCBhdCBvcHJldHRlIGRpc3NlIHJhc3RlcmUuPC9wPjxwPlbDpnJkaWVybmUgaSBvdXRwdXQta29ycmlkb3ItcmFzdGVyZW4gZXIgc3VtbWVuIGFmIGRlIGFra3VtdWxlcmVkZSBvbWtvc3RuaW5nZXIgZm9yIGF0IG7DpSBlbiBnaXZlbiBwbGFjZXJpbmcgbWVkIGRlIHNhbW1lIGVuaGVkZXIgc29tIGlucHV0cmFzdGVyZW4gZm9yIGFra3VtdWxlcmVkZSBvbWtvc3RuaW5nZXIuPC9wPjxwPkh2aXMgZW4gYW5naXZldCA8c3Ryb25nPlTDpnJza2VsPC9zdHJvbmc+LXbDpnJkaSBlciBzdMO4cnJlIGVuZCBkZSBtYWtzaW1hbGUgYWtrdW11bGVyZWRlIG9ta29zdG5pbmdlciwgbsOlciB0byBhZnN0YW5kc2Fra3VtdWxlcmluZ3NyYXN0ZXJlIHN1bW1lcmVzLCB2aWwgb3V0cHV0LWtvcnJpZG9yLXJhc3RlcmVuIGTDpmtrZSBkZXQgc2FtbWUgb21yw6VkZSBzb20gZGUgYWtrdW11bGVyZWRlIGlucHV0cmFzdGVyZS48L3A+PHA+SHZpcyBlbiBhbmdpdmV0IHTDpnJza2VsdsOmcmRpIGVyIG1pbmRyZSBlbmQgbWluaW11bXN2w6ZyZGllbiBpIGtvcnJpZG9yLXJhc3RlcmVuLCByZXR1cm5lcmVzIGRlciBlbiBhZHZhcnNlbHNtZWRkZWxlbHNlLCBvZyBvdXRwdXRyYXN0ZXJlbiB2aWwgdsOmcmUgdG9tLjwvcD48cD5PdXRwdXQta29ycmlkb3ItcmFzdGVyZW4ga2FuIGluZGVob2xkZSBjZWxsZXIgbWVkIGxpZHQgc3TDuHJyZSBha2t1bXVsZXJlZGUgb21rb3N0bmluZ2VyIGVuZCB0w6Zyc2tlbHbDpnJkaWVuLiBEZXR0ZSBlciBmcmEgZGUgdGlsYmFnZXJldG5pbmdzcmFzdGVyZSwgZGVyIGJydWdlciBjZWxsZXIsIHNvbSBlciB0aWxkZWx0IGxpZHQgaMO4amVyZSBvbWtvc3RuaW5nZXIgZW5kIHTDpnJza2xlbiBtZWQgaGVuYmxpayBww6UgYXQgZm9yYmluZGUgZnJha29ibGVkZSBjZWxsZXIgdGlsIGtvcnJpZG9yZW4uPC9wPlwiLFxuXHRcdGdlb21ldHJpY01lZGlhbk5hbWU6IFwiR2VvbWV0cmlzayBtZWRpYW5cIixcblx0XHRnZW9tZXRyaWNNZWRpYW5TbmlwOiBcIkRlbiBnZW9tZXRyaXNrZSBtZWRpYW4tZnVua3Rpb24gYmVyZWduZXIgZGVuIGdlb21ldHJpc2tlIG1lZGlhbiBww6UgdHbDpnJzIGFmIHBpeGVscyBpIGVuIHRpZHNzZXJpZSBhZiBtdWx0aWLDpW5kLWJpbGxlZGVyLlwiLFxuXHRcdGdlb21ldHJpY01lZGlhbkRlc2M6IFwiPHA+RGVubmUgZnVua3Rpb24gcmVkdWNlcmVyIHN0w7hqIG9nIGFmdmlnZWxzZXIgaSB0aWRzc2VyaWViaWxsZWRlciB2ZWQgYXQgYmVyZWduZSBlbiBnZW9tZXRyaXNrIG1lZGlhbnBpeGVsIGZvciBodmVydCBwaXhlbC1hcnJheSBww6UgdHbDpnJzIGFmIGJpbGxlZHN0YWtrZW4uIEFsZ29yaXRtZW4gYmV2YXJlciBkZSBzcGVrdHJhbGUgcmVsYXRpb25lciBtZWxsZW0gYsOlbmRlbmUgaSBwaXhlbHNwZWt0cmVuZSwgc8OlIHJlc3VsdGF0ZXQga2FuIGJydWdlcyBpIGFuYWx5c2VyIHPDpXNvbSB2ZWdldGF0aW9uc2luZGVrc2VyLjwvcD48cD5Ta3llciBvZyBza3lnZ2VyIHNrYWwgbWFza2VyZXMgdmVkIGhqw6ZscCBhZiBkYXRhc8OmdHRldHMgUUEtYsOlbmQsIGbDuHIgZGVubmUgZnVua3Rpb24gYW52ZW5kZXMuPC9wPjxwPkh2aXMgaW5wdXRiaWxsZWRldCBlciBtZWQgZmx5ZGVuZGUga29tbWEsIHPDpXNvbSBvdmVyZmxhZGVyZWZsZWt0YW5zLCBtZWQgdsOmcmRpZXIgbWVsbGVtIDAgb2cgMSwgYsO4ciBlbiBlcHNpbG9uLXbDpnJkaSBww6UgMCwwMDEgZ2l2ZSBrdmFsaXRldHNyZXN1bHRhdGVyLjwvcD5cIlxuXHR9LFxuXHRyZnhBcmdzOiB7XG5cdFx0cmFzdGVyTmFtZTogXCJSYXN0ZXJcIixcblx0XHRjb2xvclNjaGVtZVR5cGVOYW1lOiBcIkZhcnZlc2tlbWF0eXBlXCIsXG5cdFx0Y29sb3JtYXBOYW1lOiBcIkZhcnZla29ydFwiLFxuXHRcdGNvbG9ybWFwTmFtZU5hbWU6IFwiTmF2biBww6UgZmFydmVrb3J0XCIsXG5cdFx0Y29sb3JSYW1wTmFtZTogXCJGYXJ2ZXNrYWxhXCIsXG5cdFx0Y29udHJhc3RPZmZzZXROYW1lOiBcIktvbnRyYXN0Zm9yc2t5ZG5pbmdcIixcblx0XHRicmlnaHRuZXNzT2Zmc2V0TmFtZTogXCJMeXNzdHlya2Vmb3Jza3lkbmluZ1wiLFxuXHRcdG1ldGhvZE5hbWU6IFwiTWV0b2RlXCIsXG5cdFx0YmFuZE5hbWVzTmFtZTogXCJCw6VuZG5hdm5lXCIsXG5cdFx0YmFuZFdhdmVsZW5ndGhzTmFtZTogXCJCw6VuZGLDuGxnZWzDpm5nZGVyXCIsXG5cdFx0YmFuZElkc05hbWU6IFwiQsOlbmQtSUQnZXJcIixcblx0XHRtaXNzaW5nQmFuZEFjdGlvbk5hbWU6IFwiTWFuZ2xlbmRlIGLDpW5kaGFuZGxpbmdcIixcblx0XHRjb252ZXJzaW9uUGFyYW1ldGVyc05hbWU6IFwiS29udmVydGVyaW5nc3BhcmFtZXRyZVwiLFxuXHRcdGhpbGxzaGFkZVR5cGVOYW1lOiBcIkhpbGxzaGFkZS10eXBlXCIsXG5cdFx0YXppbXV0aE5hbWU6IFwiQXppbXV0XCIsXG5cdFx0YWx0aXR1ZGVOYW1lOiBcIkjDuGpkZVwiLFxuXHRcdHNsb3BlVHlwZU5hbWU6IFwiU2thbGVyaW5nXCIsXG5cdFx0ekZhY3Rvck5hbWU6IFwiWi1mYWt0b3JcIixcblx0XHRQU1Bvd2VyTmFtZTogXCJQaXhlbHN0w7hycmVsc2VzZWZmZWt0XCIsXG5cdFx0UFNaRmFjdG9yTmFtZTogXCJQaXhlbHN0w7hycmVsc2VzZmFrdG9yXCIsXG5cdFx0cmVtb3ZlRWRnZUVmZmVjdE5hbWU6IFwiRGVha3RpdsOpciBzdGFuZGFyZC1rYW50cGl4ZWwtaW50ZXJwb2xhdGlvblwiLFxuXHRcdGZyb21Vbml0TmFtZTogXCJGcmEgZW5oZWRcIixcblx0XHR0b1VuaXROYW1lOiBcIlRpbCBlbmhlZFwiLFxuXHRcdHJhc3RlclR5cGVOYW1lOiBcIlR5cGVcIixcblx0XHRtaW5OYW1lOiBcIk91dHB1dC1taW5pbXVtXCIsXG5cdFx0bWF4TmFtZTogXCJPdXRwdXQtbWFrc2ltdW1cIixcblx0XHRtaW5QZXJjZW50TmFtZTogXCJQcm9jZW50IGNsaXAtbWluaW11bVwiLFxuXHRcdG1heFBlcmNlbnROYW1lOiBcIlByb2NlbnQgY2xpcC1tYWtzaW11bVwiLFxuXHRcdG51bWJlck9mU3RhbmRhcmREZXZpYXRpb25OYW1lOiBcIkFudGFsIHN0YW5kYXJkYWZ2aWdlbHNlclwiLFxuXHRcdHNpZ21vaWRTdHJlbmd0aExldmVsTmFtZTogXCJTaWdtb2lkLXN0eXJrZW5pdmVhdVwiLFxuXHRcdGVzdGltYXRlU3RhdHNIaXN0b2dyYW1OYW1lOiBcIkJlcmVnbiBzdGF0aXN0aWtcIixcblx0XHREUkFOYW1lOiBcIkR5bmFtaXNrIGp1c3RlcmluZyBhZiBvbXLDpWRlXCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGlrXCIsXG5cdFx0aGlzdG9ncmFtc05hbWU6IFwiSGlzdG9ncmFtbWVyXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbU5hbWU6IFwiRGVmaW5lciBzdGF0aXN0aWsgb2cgaGlzdG9ncmFtXCIsXG5cdFx0Y29tcHV0ZUdhbW1hTmFtZTogXCJBdXRvIEdhbW1hXCIsXG5cdFx0dXNlR2FtbWFOYW1lOiBcIkJydWcgR2FtbWFcIixcblx0XHRnYW1tYU5hbWU6IFwiR2FtbWFcIixcblx0XHRpbnB1dE5hbWVzTmFtZTogXCJOYXZuZVwiLFxuXHRcdGV4cHJlc3Npb25OYW1lOiBcIlVkdHJ5a1wiLFxuXHRcdGNlbGxzaXplVHlwZU5hbWU6IFwiQ2VsbGVzdMO4cnJlbHNlc3R5cGVcIixcblx0XHRleHRlbnRUeXBlTmFtZTogXCJVZHN0csOma25pbmdzdHlwZVwiLFxuXHRcdGNsYXNzaWZpZXJEZWZpbml0aW9uRmlsZU5hbWU6IFwiSW5wdXQtZGVmaW5pdGlvbnNmaWxcIixcblx0XHRyYXN0ZXIxTmFtZTogXCJSYXN0ZXIxXCIsXG5cdFx0cmFzdGVyMk5hbWU6IFwiUmFzdGVyMlwiLFxuXHRcdHJhc3RlcjNOYW1lOiBcIlJhc3RlcjNcIixcblx0XHR0cnVlUmFzdGVyTmFtZTogXCJTYW5kIHJhc3RlclwiLFxuXHRcdGZhbHNlUmFzdGVyTmFtZTogXCJGYWxzayByYXN0ZXJcIixcblx0XHRub0RhdGFJbnRlcnByZXRhdGlvbk5hbWU6IFwiTm9EYXRhLWZvcnRvbGtuaW5nXCIsXG5cdFx0bm9EYXRhVmFsdWVzTmFtZTogXCJOb0RhdGEtdsOmcmRpZXJcIixcblx0XHRpbmNsdWRlZFJhbmdlc05hbWU6IFwiSW5rbHVkZXJlZGUgb21yw6VkZXJcIixcblx0XHRjdXJ2YXR1cmVUeXBlTmFtZTogXCJLcnVtbmluZ3N0eXBlXCIsXG5cdFx0cmFzdGVyc05hbWU6IFwiUmFzdGVyZVwiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlTmFtZTogXCJUYWJlbFwiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZU5hbWU6IFwiVGFiZWx0eXBlXCIsXG5cdFx0cm93c05hbWU6IFwiQW50YWwgcsOma2tlclwiLFxuXHRcdGNvbHVtbnNOYW1lOiBcIkFudGFsIGtvbG9ubmVyXCIsXG5cdFx0a2VybmVsTmFtZTogXCJLZXJuZVwiLFxuXHRcdG1pcnJvckVkZ2VzTmFtZTogXCJTcGVqbGthbnRlclwiLFxuXHRcdGluZmx1ZW5jZXNOYW1lOiBcIkluZmx5ZGVsc2VyXCIsXG5cdFx0ZmllbGRzTmFtZTogXCJGZWx0ZXJcIixcblx0XHRyZW1hcHNOYW1lOiBcIkdlbmJlcmVnbiB0YWJlbFwiLFxuXHRcdGV2YWxGcm9tTmFtZTogXCJFdmFsdWVyaW5nc3NrYWxhIGZyYVwiLFxuXHRcdGV2YWxUb05hbWU6IFwiRXZhbHVlcmluZ3Nza2FsYSB0aWxcIixcblx0XHR3ZWlnaHRzTmFtZTogXCJWw6ZndGVcIixcblx0XHRERU1OYW1lOiBcIkRFTVwiLFxuXHRcdHNob3J0UmFuZ2VJRFdSYWRpdXNOYW1lOiBcIklEVy1yYWRpdXMgZm9yIGtvcnQgb21yw6VkZVwiLFxuXHRcdG1heFZvaWRXaWR0aE5hbWU6IFwiTWFrcy4gdG9tcnVtc2JyZWRkZVwiLFxuXHRcdHNpZ21hR2F1c3NpYW5OYW1lOiBcIkFkYXB0aXYgdWRqw6Z2bmluZ1wiLFxuXHRcdGNvbnRvdXJUeXBlTmFtZTogXCJLb250dXJ0eXBlXCIsXG5cdFx0ekJhc2VOYW1lOiBcIlotYmFzZVwiLFxuXHRcdG51bWJlck9mQ29udG91cnNOYW1lOiBcIkFudGFsIGtvbnR1cmVyXCIsXG5cdFx0Y29udG91ckludGVydmFsTmFtZTogXCJLb250dXJpbnRlcnZhbFwiLFxuXHRcdG50aENvbnRvdXJMaW5lSW5Cb2xkTmFtZTogXCJOdGggQ29udG91ckxpbmUgaSBmZWRcIixcblx0XHRmZWF0dXJlQ2xhc3NOYW1lOiBcIklucHV0LW9iamVrdGVyXCIsXG5cdFx0Y2xhc3NJbmRleEZpZWxkTmFtZTogXCJGZWx0XCIsXG5cdFx0cmVzb2x2ZU92ZXJsYXBNZXRob2ROYW1lOiBcIk9wbMO4cyBvdmVybGFwbmluZ3NtZXRvZGVcIixcblx0XHRyZXNhbXBsaW5nVHlwZU5hbWU6IFwiUmVzYW1wbGluZy10eXBlXCIsXG5cdFx0aW5wdXRDZWxsc2l6ZU5hbWU6IFwiSW5wdXQtY2VsbGVzdMO4cnJlbHNlXCIsXG5cdFx0b3V0cHV0Q2VsbHNpemVOYW1lOiBcIk91dHB1dC1jZWxsZXN0w7hycmVsc2VcIixcblx0XHRwb2ludEZlYXR1cmVDbGFzc05hbWU6IFwiU2VlZC1wdW5rdGVyXCIsXG5cdFx0bWF4R3Jvd3RoUmFkaXVzRmllbGROYW1lOiBcIlJhZGl1c2ZlbHQgZm9yIG1ha3MuIHbDpmtzdFwiLFxuXHRcdHNpbWlsYXJpdHlUaHJlc2hvbGRGaWVsZE5hbWU6IFwiVMOmcnNrZWxmZWx0IGZvciBsaWdoZWRcIixcblx0XHRmaWxsVmFsdWVGaWVsZE5hbWU6IFwiVWRmeWxkbmluZ3N2w6ZyZGlmZWx0XCIsXG5cdFx0c3BlY3RyYWxEZXRhaWxOYW1lOiBcIlNwZWt0cmFsZSBkZXRhbGplciBbMS4uMjBdXCIsXG5cdFx0c3BhdGlhbERldGFpbE5hbWU6IFwiU3BhdGlhbGUgZGV0YWxqZXIgWzEuLjIwXVwiLFxuXHRcdG1pbk51bVBpeGVsc1BlclNlZ21lbnROYW1lOiBcIk1pbmRzdGUgc2VnbWVudHN0w7hycmVsc2UgaSBwaXhlbHNcIixcblx0XHRib3VuZGFyaWVzT25seU5hbWU6IFwiS3VuIHNlZ21lbnRncsOmbnNlclwiLFxuXHRcdHN0YXRpc3RpY3NUeXBlTmFtZTogXCJTdGF0aXN0aWt0eXBlXCIsXG5cdFx0ZmlsbE5vRGF0YU9ubHlOYW1lOiBcIlVkZnlsZCBrdW4gTm9EYXRhLXBpeGVsc1wiLFxuXHRcdGlucHV0RGF0YVR5cGVOYW1lOiBcIklucHV0ZGF0YXR5cGVcIixcblx0XHRhbmdsZVJlZmVyZW5jZVN5c3RlbU5hbWU6IFwiVmlua2VscmVmZXJlbmNlc3lzdGVtXCIsXG5cdFx0b3V0cHV0RGF0YVR5cGVOYW1lOiBcIk91dHB1dGRhdGF0eXBlXCIsXG5cdFx0aW5wdXRTYW1wbGVQb2ludEZlYXR1cmVDbGFzc05hbWU6IFwiSW5wdXRla3NlbXBsZXJcIixcblx0XHR2YWx1ZUZpZWxkTmFtZTogXCJWw6ZyZGlmZWx0XCIsXG5cdFx0cmFzdGVySW5mb05hbWU6IFwiUmFzdGVyLWluZm9cIixcblx0XHRpbnRlcnBvbGF0aW9uTWV0aG9kTmFtZTogXCJJbnRlcnBvbGF0aW9uc21ldG9kZVwiLFxuXHRcdHJhZGl1c05hbWU6IFwiUmFkaXVzXCIsXG5cdFx0cmFkaWFuY2VHYWluVmFsdWVzTmFtZTogXCJSYWRpYW5zc3RpZ25pbmdcIixcblx0XHRyYWRpYW5jZUJpYXNWYWx1ZXNOYW1lOiBcIlJhZGlhbnNhZnZpZ2Vsc2VcIixcblx0XHRyZWZsZWN0ZWRHYWluVmFsdWVzTmFtZTogXCJSZWZsZWt0ZXJldCBzdGlnbmluZ1wiLFxuXHRcdHJlZmxlY3RlZEJpYXNWYWx1ZXNOYW1lOiBcIlJlZmxla3RlcmV0IGFmdmlnZWxzZVwiLFxuXHRcdHN1bkVsZXZhdGlvbk5hbWU6IFwiU29saMO4amRlIChncmFkZXIpXCIsXG5cdFx0YWxiZWRvTmFtZTogXCJBbGJlZG9cIixcblx0XHRzY2FsZUZhY3Rvck5hbWU6IFwiU2thbGFmYWt0b3JcIixcblx0XHRvZmZzZXROYW1lOiBcIkZvcnNreWRuaW5nXCIsXG5cdFx0dGhyZXNob2xkVHlwZU5hbWU6IFwiVMOmcnNrZWx0eXBlXCIsXG5cdFx0dGhyZXNob2xkc05hbWU6IFwiVMOmcnNrbGVyXCIsXG5cdFx0dW5kZWZpbmVkQ2xhc3NOYW1lOiBcIklra2UtZGVmaW5lcmV0IGtsYXNzZVwiLFxuXHRcdG1pblZhbHVlTmFtZTogXCJNaW4uXCIsXG5cdFx0bWF4VmFsdWVOYW1lOiBcIk1ha3MuXCIsXG5cdFx0b3BlcmF0aW9uTmFtZTogXCJIYW5kbGluZ1wiLFxuXHRcdGNsaXBwaW5nVHlwZU5hbWU6IFwiS2xpcC10eXBlXCIsXG5cdFx0Y2xpcHBpbmdHZW9tZXRyeU5hbWU6IFwiS2xpcC1nZW9tZXRyaS9yYXN0ZXJcIixcblx0XHRleHRlbnROYW1lOiBcIk91dHB1dC11ZHN0csOma25pbmdcIixcblx0XHR1c2VJbnB1dEZlYXR1cmVHZW9tZXRyeU5hbWU6IFwiQnJ1ZyBpbnB1dC1vYmpla3RlciB0aWwga2xpcC1nZW9tZXRyaVwiLFxuXHRcdHJlbWFwRGVmaW5pdGlvblR5cGVOYW1lOiBcIkdlbmJlcmVnbiBkZWZpbml0aW9uc3R5cGVcIixcblx0XHRpbnB1dFJhbmdlTmFtZTogXCJJbnB1dC1vbXLDpWRlclwiLFxuXHRcdG91dHB1dFZhbHVlc05hbWU6IFwiT3V0cHV0LXbDpnJkaWVyXCIsXG5cdFx0bm9EYXRhUmFuZ2VOYW1lOiBcIk5vRGF0YS1vbXLDpWRlclwiLFxuXHRcdGlucHV0RmllbGROYW1lOiBcIklucHV0ZmVsdFwiLFxuXHRcdG91dHB1dEZpZWxkTmFtZTogXCJPdXRwdXRmZWx0XCIsXG5cdFx0aW5wdXRNYXhGaWVsZE5hbWU6IFwiSW5wdXQtbWFrcy4gZmVsdCAodmFsZ2ZyaXQpXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVOYW1lOiBcIkdlbmJlcmVnbiB0YWJlbHR5cGVcIixcblx0XHRhbGxvd1VubWF0Y2hlZE5hbWU6IFwiVGlsbGFkIGlra2UtbWF0Y2hlZGUgcGl4ZWx2w6ZyZGllclwiLFxuXHRcdGNoYW5nZU1pc3NpbmdWYWx1ZXNUb05vRGF0YU5hbWU6IFwiw4ZuZHJlIG1hbmdsZW5kZSB2w6ZyZGllciB0aWwgTm9EYXRhXCIsXG5cdFx0dmlzaWJsZUJhbmRJRE5hbWU6IFwiU3lubGlndCBiw6VuZC1JRFwiLFxuXHRcdGluZnJhcmVkQmFuZElETmFtZTogXCJJbmZyYXLDuGR0IGLDpW5kLUlEXCIsXG5cdFx0c2NpZW50aWZpY091dHB1dE5hbWU6IFwiVmlkZW5za2FiZWxpZ3Qgb3V0cHV0XCIsXG5cdFx0YmFuZEluZGV4ZXNOYW1lOiBcIkLDpW5kaW5kZWtzZXJcIixcblx0XHRjb25zdGFudE5hbWU6IFwiS29uc3RhbnRcIixcblx0XHR3ZWlnaHROYW1lOiBcIlbDpmd0XCIsXG5cdFx0bWluaW11bU5hbWU6IFwiTWluaW11bVwiLFxuXHRcdG1heGltdW1OYW1lOiBcIk1ha3NpbXVtXCIsXG5cdFx0c291cmNlRGF0YU5hbWU6IFwiS2lsZGVyYXN0ZXJcIixcblx0XHRzb3VyY2VGaWVsZE5hbWU6IFwiS2lsZGVmZWx0XCIsXG5cdFx0Y29zdFJhc3Rlck5hbWU6IFwiT21rb3N0bmluZ3NyYXN0ZXJcIixcblx0XHRtYXhEaXN0YW5jZU5hbWU6IFwiTWFrc2ltYWwgYWZzdGFuZFwiLFxuXHRcdHZhbHVlUmFzdGVyTmFtZTogXCJWw6ZyZGlyYXN0ZXJcIixcblx0XHRjb3N0TXVsdGlwbGllck5hbWU6IFwiTXVsdGlwbGlrYXRvciwgZGVyIHNrYWwgYW52ZW5kZXMgdGlsIG9ta29zdG5pbmdlclwiLFxuXHRcdHN0YXJ0Q29zdE5hbWU6IFwiU3RhcnRvbWtvc3RuaW5nXCIsXG5cdFx0YWNjdW1Db3N0UmVzaXN0YW5jZVJhdGVOYW1lOiBcIkFra3VtdWxlcmV0IG9ta29zdG5pbmdzLXJlc2lzdGVucy1zYXRzXCIsXG5cdFx0Y2FwYWNpdHlOYW1lOiBcIkthcGFjaXRldFwiLFxuXHRcdHRyYXZlbERpcmVjdGlvbk5hbWU6IFwiUmVqc2VyZXRuaW5nXCIsXG5cdFx0Y2VsbFNpemVOYW1lOiBcIkNlbGxlc3TDuHJyZWxzZVwiLFxuXHRcdHBvcHVsYXRpb25GaWVsZE5hbWU6IFwiUG9wdWxhdGlvbnNmZWx0XCIsXG5cdFx0YXJlYVVuaXRzTmFtZTogXCJPbXLDpWRlZW5oZWRlclwiLFxuXHRcdG91dHB1dFZhbHVlVHlwZU5hbWU6IFwiT3V0cHV0LWNlbGxldsOmcmRpZXJcIixcblx0XHRiYXJyaWVyc05hbWU6IFwiSW5wdXRiYXJyaWVyZXJcIixcblx0XHRkZXN0aW5hdGlvbkRhdGFOYW1lOiBcIkRlc3RpbmF0aW9uc3Jhc3RlclwiLFxuXHRcdGRlc3RpbmF0aW9uRmllbGROYW1lOiBcIkRlc3RpbmF0aW9uc2ZlbHRcIixcblx0XHRwYXRoVHlwZU5hbWU6IFwiU3RpdHlwZVwiLFxuXHRcdG9ic2VydmVyRmVhdHVyZXNOYW1lOiBcIk9ic2VydmF0aW9uc29iamVrdGVyXCIsXG5cdFx0YW5hbHlzaXNNZXRob2ROYW1lOiBcIkFuYWx5c2VtZXRvZGVcIixcblx0XHRhbmFseXNpc1R5cGVOYW1lOiBcIkFuYWx5c2V0eXBlXCIsXG5cdFx0dmVydGljYWxFcnJvck5hbWU6IFwiVmVydGlrYWwgZmVqbFwiLFxuXHRcdHJlZnJhY3Rpdml0eUNvZWZmaWNpZW50TmFtZTogXCJLb2VmZmljaWVudCBmb3IgcmVmcmFrdGl2aXRldFwiLFxuXHRcdHN1cmZhY2VPZmZzZXROYW1lOiBcIk92ZXJmbGFkZWZvcnNreWRuaW5nXCIsXG5cdFx0b2JzZXJ2ZXJFbGV2YXRpb25OYW1lOiBcIk9ic2VydmF0aW9uc2jDuGpkZVwiLFxuXHRcdG9ic2VydmVyT2Zmc2V0TmFtZTogXCJPYnNlcnZhdGlvbnNmb3Jza3lkbmluZ1wiLFxuXHRcdGlubmVyUmFkaXVzTmFtZTogXCJJbmRyZSByYWRpdXNcIixcblx0XHRpbm5lclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiSW5kcmUgcmFkaXVzIGVyIDNELWFmc3RhbmRcIixcblx0XHRvdXRlclJhZGl1c05hbWU6IFwiWWRyZSByYWRpdXNcIixcblx0XHRvdXRlclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiWWRyZSByYWRpdXMgZXIgM0QtYWZzdGFuZFwiLFxuXHRcdGhvcml6b250YWxTdGFydEFuZ2xlTmFtZTogXCJIb3Jpc29udGFsIHN0YXJ0dmlua2VsXCIsXG5cdFx0aG9yaXpvbnRhbEVuZEFuZ2xlTmFtZTogXCJIb3Jpc29udGFsIHNsdXR2aW5rZWxcIixcblx0XHR2ZXJ0aWNhbFVwcGVyQW5nbGVOYW1lOiBcIlZlcnRpa2FsIMO4dnJlIHZpbmtlbFwiLFxuXHRcdHZlcnRpY2FsTG93ZXJBbmdsZU5hbWU6IFwiVmVydGlrYWwgbmVkcmUgdmlua2VsXCIsXG5cdFx0em9uZURhdGFOYW1lOiBcIlpvbmVyYXN0ZXJcIixcblx0XHR6b25lRmllbGROYW1lOiBcIlpvbmVmZWx0XCIsXG5cdFx0aWdub3JlTm9EYXRhTmFtZTogXCJUaWxzaWRlc8OmdCBOb0RhdGEgaSBiZXJlZ25pbmdlclwiLFxuXHRcdHRlbXBlcmF0dXJlUmFzdGVyTmFtZTogXCJUZW1wZXJhdHVycmFzdGVyXCIsXG5cdFx0aW5UZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJUZW1wZXJhdHVyZW5oZWRlclwiLFxuXHRcdG91dEhlYXRJbmRleFRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlZhcm1laW5kZWtzZW5oZWRlclwiLFxuXHRcdHJlbGF0aXZlSHVtaWRpdHlSYXN0ZXJOYW1lOiBcIlJlbGF0aXYgZnVndGlnaGVkc3Jhc3RlclwiLFxuXHRcdG91dFdpbmRDaGlsbFRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlZpbmRhZmvDuGxpbmdzZW5oZWRlclwiLFxuXHRcdHdpbmRTcGVlZFJhc3Rlck5hbWU6IFwiVmluZGhhc3RpZ2hlZHNyYXN0ZXJcIixcblx0XHRpbldpbmRTcGVlZFVuaXRzTmFtZTogXCJWaW5kaGFzdGlnaGVkc2VuaGVkZXJcIixcblx0XHR2YWx1ZU5hbWU6IFwiVsOmcmRpXCIsXG5cdFx0cHJvcGVydHlOYW1lOiBcIk5hdm4gcMOlIGVnZW5za2FiXCIsXG5cdFx0anNvbk5hbWU6IFwiTWV0YWRhdGEgSlNPTlwiLFxuXHRcdHpvbmVUYWJsZU5hbWU6IFwiWm9uZWF0dHJpYnV0dGFiZWxcIixcblx0XHRhdHRyaWJ1dGVGaWVsZE5hbWVzOiBcIkF0dHJpYnV0ZmVsdG5hdm5lXCIsXG5cdFx0YmFja2dyb3VuZE5hbWU6IFwiQmFnZ3J1bmRzdsOmcmRpXCIsXG5cdFx0d2hlcmVDbGF1c2VOYW1lOiBcIldIRVJFLXPDpnRuaW5nXCIsXG5cdFx0bWluaW11bVZhbHVlRmllbGROYW1lOiBcIk5hdm4gcMOlIG1pbmltdW1zdsOmcmRpZmVsdFwiLFxuXHRcdG1heGltdW1WYWx1ZUZpZWxkTmFtZTogXCJOYXZuIHDDpSBtYWtzaW11bXN2w6ZyZGlmZWx0XCIsXG5cdFx0b3V0VmFsdWVGaWVsZE5hbWU6IFwiTmF2biBww6Ugb3V0cHV0LXbDpnJkaWZlbHRcIixcblx0XHRkZWZhdWx0VmFsdWVOYW1lOiBcIlN0YW5kYXJkLW91dHB1dC12w6ZyZGlcIixcblx0XHRjb252ZXJzaW9uTWF0cml4TmFtZTogXCJLb252ZXJ0ZXJpbmdzbWF0cml4XCIsXG5cdFx0SXNQc2V1ZG9Db2xvck91dHB1dE5hbWU6IFwiRXIgZXQgcHNldWRvLWZhcnZlLW91dHB1dFwiLFxuXHRcdHVubWFwcGVkQXNSYW5kb21Db2xvck5hbWU6IFwiVGlsZGVsIGZhcnZlciB0aWxmw6ZsZGlndCB0aWwgaWtrZS1rb3J0bGFndGUgcGl4ZWxzXCIsXG5cdFx0ZGlzdGFuY2VNZXRob2ROYW1lOiBcIkFmc3RhbmRzbWV0b2RlXCIsXG5cdFx0Zmxvd0RpclJhc3Rlck5hbWU6IFwiRmxvd3JldG5pbmdzcmFzdGVyXCIsXG5cdFx0cG91clBvaW50TmFtZTogXCJSYXN0ZXIgZm9yIHB1bmt0KGVyKSBmb3IgdmFuZGzDuGJzcmV0bmluZ1wiLFxuXHRcdHBvdXJQb2ludEZpZWxkTmFtZTogXCJGZWx0IGZvciBwdW5rdChlcikgZm9yIHZhbmRsw7hic3JldG5pbmdcIixcblx0XHRjb25zdGFudFpOYW1lOiBcIktvbnN0YW50IFpcIixcblx0XHR6T2Zmc2V0TmFtZTogXCJaLWZvcnNreWRuaW5nXCIsXG5cdFx0Z2VvSWROYW1lOiBcIkdlb2lkZVwiLFxuXHRcdGNhbGlicmF0aW9uVHlwZU5hbWU6IFwiS2FsaWJyZXJpbmdzdHlwZVwiLFxuXHRcdGZpbHRlclR5cGVOYW1lOiBcIkZpbHRlcnR5cGVcIixcblx0XHRmaWx0ZXJTaXplTmFtZTogXCJGaWx0ZXJzdMO4cnJlbHNlXCIsXG5cdFx0bm9pc2VNb2RlbE5hbWU6IFwiU3TDuGptb2RlbFwiLFxuXHRcdG5vaXNlVmFyaWFuY2VOYW1lOiBcIlN0w7hqdmFyaWFuc1wiLFxuXHRcdGFkZGl0aXZlTm9pc2VNZWFuTmFtZTogXCJBZGRpdGl2IG1pZGRlbHbDpnJkaSBmb3Igc3TDuGpcIixcblx0XHRtdWx0aXBsaWNhdGl2ZU5vaXNlTWVhbk5hbWU6IFwiTXVsdGlwbGlrYXRpdiBtaWRkZWx2w6ZyZGkgZm9yIHN0w7hqXCIsXG5cdFx0bnVtYmVyb2ZMb29rc05hbWU6IFwiQW50YWwgdWRzZWVuZGVyXCIsXG5cdFx0ZGFtcGluZ0ZhY3Rvck5hbWU6IFwiRMOmbXBuaW5nc2Zha3RvclwiLFxuXHRcdG1hc2tSYXN0ZXJOYW1lOiBcIk1hc2tlcmFzdGVyXCIsXG5cdFx0bmliYmxlVmFsdWVzTmFtZTogXCJCcnVnIE5vRGF0YS12w6ZyZGllciwgaHZpcyBkZSBlciBkZW4gbsOmcm1lc3RlIG5hYm9cIixcblx0XHRuaWJibGVOb0RhdGFOYW1lOiBcIk5pYmJsZSBOb0RhdGEtY2VsbGVyXCIsXG5cdFx0ekxpbWl0TmFtZTogXCJaLWdyw6Zuc2VcIixcblx0XHRmbG93RGlyZWN0aW9uVHlwZU5hbWU6IFwiRmxvd3JldG5pbmdzdHlwZVwiLFxuXHRcdHdlaWdodFJhc3Rlck5hbWU6IFwiVsOmZ3RyYXN0ZXJcIixcblx0XHRmb3JjZUVkZ2VOYW1lOiBcIlR2aW5nIGFsbGUga2FudGNlbGxlciB0aWwgYXQgc3Ryw7htbWUgdsOma1wiLFxuXHRcdHN0cmVhbVJhc3Rlck5hbWU6IFwiU3Ryw7htcmFzdGVyXCIsXG5cdFx0c3VyZmFjZVJhc3Rlck5hbWU6IFwiT3ZlcmZsYWRlcmFzdGVyXCIsXG5cdFx0Y29udmVyc2lvblR5cGU6IFwiS29udmVydGVyaW5nc3R5cGVcIixcblx0XHRkaXN0YW5jZVJhc3RlcjE6IFwiQWZzdGFuZHNyYXN0ZXIgMVwiLFxuXHRcdGRpc3RhbmNlUmFzdGVyMjogXCJBZnN0YW5kc3Jhc3RlciAyXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyOiBcIk9ta29zdG5pbmcvYWZzdGFuZC1yYXN0ZXJcIixcblx0XHRjb3N0QmFja2xpbmtSYXN0ZXI6IFwiT21rb3N0bmluZyBCYWNrTGluay1yYXN0ZXJcIixcblx0XHRvdmVycmlkZXNOYW1lOiBcIlRpbHNpZGVzw6Z0dGVyXCIsXG5cdFx0ZmllbGROYW1lOiBcIkZlbHRcIixcblx0XHRzaWduYXR1cmVGaWxlT3JVcmw6IFwiU2lnbmF0dXItZmlsIGVsbGVyIFVSTFwiLFxuXHRcdHJlZE5hbWU6IFwiUsO4ZFwiLFxuXHRcdGdyZWVuTmFtZTogXCJHcsO4blwiLFxuXHRcdGJsdWVOYW1lOiBcIkJsw6VcIixcblx0XHRpbmZyYXJlZE5hbWU6IFwiSW5mcmFyw7hkXCIsXG5cdFx0cGFuY2hyb21hdGljTmFtZTogXCJQYW5rcm9tYXRpc2tcIixcblx0XHRtdWx0aXNwZWN0cmFsTmFtZTogXCJNdWx0aXNwZWt0cmFsXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1R5cGU6IFwiUGFuc2hhcnBlbmluZy10eXBlXCIsXG5cdFx0c2Vuc29yTmFtZTogXCJTZW5zb3JcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTmFtZTogXCJTcGF0aWFsIHJlZmVyZW5jZVwiLFxuXHRcdHhDZWxsc2l6ZU5hbWU6IFwiWC1jZWxsZXN0w7hycmVsc2VcIixcblx0XHR5Q2VsbHNpemVOYW1lOiBcIlktY2VsbGVzdMO4cnJlbHNlXCIsXG5cdFx0eE9yaWdpbk5hbWU6IFwiWC1yZWdpc3RyZXJpbmdzcHVua3RcIixcblx0XHR5T3JpZ2luTmFtZTogXCJZLXJlZ2lzdHJlcmluZ3NwdW5rdFwiLFxuXHRcdHBlcmNlbnRpbGVOYW1lOiBcIlBlcmNlbnRpbHbDpnJkaVwiLFxuXHRcdG5laWdoYm9yaG9vZFR5cGU6IFwiTmFib3R5cGVcIixcblx0XHR3aWR0aE5hbWU6IFwiQnJlZGRlXCIsXG5cdFx0aGVpZ2h0TmFtZTogXCJIw7hqZGVcIixcblx0XHRzdGFydEFuZ2xlTmFtZTogXCJTdGFydHZpbmtlbFwiLFxuXHRcdGVuZEFuZ2xlTmFtZTogXCJTbHV0dmlua2VsXCIsXG5cdFx0bmVpZ2hib3Job29kVmFsdWVzOiBcIk5hYm92w6ZyZGllclwiLFxuXHRcdGhvcml6b250YWxSYXN0ZXI6IFwiSG9yaXNvbnRhbCByYXN0ZXJcIixcblx0XHRob3Jpem9udGFsRmFjdG9yOiBcIkhvcmlzb250YWwgZmFrdG9yXCIsXG5cdFx0dmVydGljYWxSYXN0ZXI6IFwiVmVydGlrYWwgcmFzdGVyXCIsXG5cdFx0dmVydGljYWxGYWN0b3I6IFwiVmVydGlrYWwgZmFrdG9yXCIsXG5cdFx0c3RyZWFtUmFzdGVyOiBcIlN0csO4bXJhc3RlclwiLFxuXHRcdGZsb3dEaXJSYXN0ZXI6IFwiRmxvd3JldG5pbmdzcmFzdGVyXCIsXG5cdFx0bnVtYmVyTmVpZ2hib3JDZWxsczogXCJBbnRhbCBuYWJvY2VsbGVyXCIsXG5cdFx0em9uZUNvbm5lY3Rpdml0eTogXCJab25lZm9yYmluZGVsc2VcIixcblx0XHRhZGRMaW5rQmVoYXZpb3I6IFwiVGlsZsO4aiBsaW5rXCIsXG5cdFx0ZXhjbHVkZWRWYWx1ZTogXCJVZGVsdWtrZXQgdsOmcmRpXCIsXG5cdFx0Y29uc3RhbnRGaWxsQ2hlY2s6IFwiR2VuZXJlciBmeWxkcmFzdGVyIHVkIGZyYSBrb25zdGFudFwiLFxuXHRcdGZpbGxSYXN0ZXI6IFwiRnlsZHJhc3RlclwiLFxuXHRcdGNvbnN0YW50RmlsbFZhbHVlOiBcIktvbnN0YW50IHbDpnJkaVwiLFxuXHRcdGlucHV0Qml0UG9zaXRpb25zOiBcIklucHV0LWJpdFwiLFxuXHRcdG91dHB1dEJpdFBvc2l0aW9uczogXCJPdXRwdXQtYml0XCIsXG5cdFx0ZGlzdGFuY2VUeXBlTmFtZTogXCJBZnN0YW5kc3R5cGVcIixcblx0XHRiYXJyaWVyRGF0YU5hbWU6IFwiUmFzdGVyYmFycmllcmVyXCIsXG5cdFx0cG91clBvaW50RGF0YU5hbWU6IFwiUmFzdGVyIGZvciBwdW5rdChlcikgZm9yIHZhbmRsw7hic3JldG5pbmdcIixcblx0XHRhY2N1bXVsYXRpb25SYXN0ZXJOYW1lOiBcIlJhc3RlciBmb3IgZmxvdy1ha2t1bXVsZXJpbmdcIixcblx0XHRzbmFwRGlzdGFuY2VOYW1lOiBcIlNuYXAtYWZzdGFuZFwiLFxuXHRcdG9yZGVyTWV0aG9kTmFtZTogXCJPcmRyZW1ldG9kZVwiLFxuXHRcdGRpcmVjdGlvbk1lYXN1cmVtZW50TmFtZTogXCJNw6VsZXJldG5pbmdcIixcblx0XHRwcm9jZXNzQXNNdWx0aWJhbmQ6IFwiQmVoYW5kbCBzb20gZmxlcmLDpW5kXCIsXG5cdFx0cHJvY2Vzc011bHRpZGltZW5zaW9uYWw6IFwiQmVoYW5kbCBzb20gZmxlcmRpbWVuc2lvbmFsXCIsXG5cdFx0Zm9yY2VGbG93RGlyZWN0aW9uQ29udmVudGlvbjogXCJUdmluZyBmbG93cmV0bmluZ3Nrb252ZW50aW9uIHRpbCBiYWNrbGluay1yYXN0ZXJcIixcblx0XHRpbml0aWFsQWNjdW11bGF0aW9uOiBcIkbDuHJzdGUgYWtrdW11bGVyaW5nXCIsXG5cdFx0bWF4aW11bUFjY3VtdWxhdGlvbjogXCJNYWtzaW1hbCBha2t1bXVsZXJpbmdcIixcblx0XHRzb3VyY2VMb2NhdGlvbkJhbmRzOiBcIkdlbmVyZXIga2lsZGVyw6Zra2Ugb2cgLWtvbG9ubmUgc29tIHlkZXJsaWdlcmUgYsOlbmQgaSBvdXRwdXRcIixcblx0XHRiYWNrRGlyZWN0aW9uQmFuZDogXCJHZW5lcmVyIHRpbGJhZ2VyZXRuaW5nIHNvbSBla3N0cmEgYsOlbmQgaSBvdXRwdXRcIixcblx0XHRudW1iZXJPZkNlbGxzOiBcIkFudGFsIGNlbGxlclwiLFxuXHRcdHpvbmVWYWx1ZXM6IFwiWm9uZXbDpnJkaWVyXCIsXG5cdFx0c2hyaW5rTWV0aG9kOiBcIkZvcm1pbmRzayBtZXRvZGVcIixcblx0XHRleHBhbmRNZXRob2Q6IFwiVWR2aWQgbWV0b2RlXCIsXG5cdFx0aW5wdXRTcGVjdHJhbFByb2ZpbGVUeXBlOiBcIlNwZWt0cmFsIHByb2ZpbHR5cGVcIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlTmFtZTogXCJTcGVrdHJhbCBwcm9maWxcIixcblx0XHR0cmFpbmluZ0ZlYXR1cmVGaWxlTmFtZTogXCJUcsOmbmluZ3NmdW5rdGlvblwiLFxuXHRcdG5vbk5lZ2F0aXZlOiBcIklra2UtbmVnYXRpdlwiLFxuXHRcdHN1bVRvT25lOiBcIlN1bSB0aWwgw6luXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uOiBcIkRpc3RyaWJ1dGlvblwiLFxuXHRcdG1lYW5OYW1lOiBcIk1pZGRlbFwiLFxuXHRcdHByb2JhYmlsaXR5TmFtZTogXCJTYW5kc3lubGlnaGVkXCIsXG5cdFx0YWxwaGFOYW1lOiBcIkFsZmFcIixcblx0XHRiZXRhTmFtZTogXCJCZXRhXCIsXG5cdFx0ck5hbWU6IFwiclwiLFxuXHRcdG5OYW1lOiBcIk5cIixcblx0XHRzZWVkOiBcIkZyw7hcIixcblx0XHRyYW5kb21OdW1iZXJHZW5lcmF0b3I6IFwiR2VuZXJhdG9yIGFmIHRpbGbDpmxkaWd0IHRhbFwiLFxuXHRcdGNlbGxGYWN0b3I6IFwiQ2VsbGVmYWt0b3JcIixcblx0XHRhZ2dyZWdhdGlvblR5cGU6IFwiQWdncmVnZXJpbmdzdGVrbmlrXCIsXG5cdFx0ZXh0ZW50SGFuZGxpbmc6IFwiVWR2aWQgdWRzdHLDpmtuaW5nIG9tIG7DuGR2ZW5kaWd0XCIsXG5cdFx0dHJlbmRBbmFseXNpc0RpbWVuc2lvbk5hbWU6IFwiRGltZW5zaW9uc25hdm5cIixcblx0XHR0cmVuZEFuYWx5c2lzVHlwZTogXCJUcmVuZHR5cGVcIixcblx0XHRoYXJtb25pY0ZyZXF1ZW5jeTogXCJIYXJtb25pc2sgZnJla3ZlbnNcIixcblx0XHRwb2x5bm9taWFsT3JkZXI6IFwiUG9seW5vbWlzayByw6Zra2Vmw7hsZ2VcIixcblx0XHRjeWNsZUxlbmd0aE5hbWU6IFwiQ3lrbHVzbMOmbmdkZVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNSTVNFOiBcIlJNU0VcIixcblx0XHR0cmVuZEFuYWx5c2lzUjI6IFwiUi1rdmFkcmF0aXNrXCIsXG5cdFx0dHJlbmRBbmFseXNpc1Nsb3BlUFZhbHVlOiBcIlAtdsOmcmRpIGFmIGjDpmxkbmluZ3Nrb2VmZmljaWVudFwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTZWFzb25hbFBlcmlvZDogXCJTw6Zzb25iZXN0ZW10IHBlcmlvZGVcIixcblx0XHRjeWNsZVVuaXROYW1lOiBcIkN5a3VzZW5oZWRcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uVmFsdWVzOiBcIlbDpnJkaWVyXCIsXG5cdFx0ZGltZW5zaW9uRGVmaW5pdGlvblR5cGU6IFwiRGltZW5zaW9uc2RlZmluaXRpb25cIixcblx0XHRwcmVkaWN0RGltZW5zaW9uU3RhcnQ6IFwiU3RhcnRcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uRW5kOiBcIlNsdXRcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uSW50ZXJ2YWw6IFwiVsOmcmRpaW50ZXJ2YWxcIixcblx0XHRkaW1lbnNpb25Vbml0OiBcIkVuaGVkXCIsXG5cdFx0aW50ZXJwb2xhdGlvbkNlbGxzaXplTmFtZTogXCJJbnRlcnBvbGF0aW9uLWNlbGxlc3TDuHJyZWxzZVwiLFxuXHRcdHZhcmlhYmxlTmFtZTogXCJWYXJpYWJsZXJcIixcblx0XHRkaW1lbnNpb25sZXNzTmFtZTogXCJEaW1lbnNpb25zbMO4c1wiLFxuXHRcdG1kaW1EZWZpbml0aW9uOiBcIkRpbWVuc2lvbnNkZWZpbml0aW9uXCIsXG5cdFx0ZGltZW5zaW9uTmFtZTogXCJEaW1lbnNpb25cIixcblx0XHRpdGVyYXRpb25TdGFydDogXCJTdGFydCBww6UgZsO4cnN0ZSBnZW50YWdlbHNlXCIsXG5cdFx0aXRlcmF0aW9uRW5kOiBcIlNsdXQgcMOlIGbDuHJzdGUgZ2VudGFnZWxzZVwiLFxuXHRcdGludGVydmFsU3RhcnQ6IFwiU3RhcnQgcMOlIGludGVydmFsXCIsXG5cdFx0aW50ZXJ2YWxFbmQ6IFwiU2x1dCBww6UgaW50ZXJ2YWxcIixcblx0XHRzdGVwTmFtZTogXCJUcmluXCIsXG5cdFx0cmFuZ2VzTmFtZTogXCJPbXLDpWRlclwiLFxuXHRcdG1pblZhbHVlOiBcIk1pbmltdW12w6ZyZGlcIixcblx0XHRtYXhWYWx1ZTogXCJNYWtzaW11bXbDpnJkaVwiLFxuXHRcdGNoYW5nZUFuYWx5c2lzUmFzdGVyTmFtZTogXCLDhm5kcmUgYW5hbHlzZXJhc3RlclwiLFxuXHRcdGNoYW5nZVR5cGVOYW1lOiBcIsOGbmRyaW5nc3R5cGVcIixcblx0XHRzZWdtZW50RGF0ZTogXCJTZWdtZW50ZGF0b1wiLFxuXHRcdGNoYW5nZURpcmVjdGlvbk5hbWU6IFwiw4ZuZHJlIHJldG5pbmdcIixcblx0XHRtYXhOdW1DaGFuZ2VzTmFtZTogXCJNYWtzaW1hbHQgYW50YWwgw6ZuZHJpbmdlclwiLFxuXHRcdGZpbHRlckJ5WWVhcjogXCJGaWx0csOpciBlZnRlciDDpXJcIixcblx0XHRtaW5pbXVtWWVhcjogXCJNaW5pbXVtc3bDpnJkaVwiLFxuXHRcdG1heGltdW1ZZWFyOiBcIk1ha3NpbXVtc3bDpnJkaVwiLFxuXHRcdGZpbHRlckJ5RHVyYXRpb246IFwiRmlsdHLDqXIgZWZ0ZXIgdmFyaWdoZWRcIixcblx0XHRtaW5pbXVtRHVyYXRpb246IFwiTWluaW11bXN2YXJpZ2hlZFwiLFxuXHRcdG1heGltdW1EdXJhdGlvbjogXCJNYWtzaW11bXN2YXJpZ2hlZFwiLFxuXHRcdGZpbHRlckJ5TWFnbml0dWRlOiBcIkZpbHRyw6lyIGVmdGVyIHN0w7hycmVsc2VcIixcblx0XHRtaW5pbXVtTWFnbml0dWRlOiBcIk1pbmltdW1zc3TDuHJyZWxzZVwiLFxuXHRcdG1heGltdW1NYWduaXR1ZGU6IFwiTWFrc2ltdW1zc3TDuHJyZWxzZVwiLFxuXHRcdGZpbHRlckJ5U3RhcnRWYWx1ZTogXCJGaWx0csOpciBlZnRlciBzdGFydHbDpnJkaVwiLFxuXHRcdG1pbmltdW1TdGFydFZhbHVlOiBcIk1pbmltYWwgc3RhcnR2w6ZyZGlcIixcblx0XHRtYXhpbXVtU3RhcnRWYWx1ZTogXCJNYWtzaW1hbCBzdGFydHbDpnJkaVwiLFxuXHRcdGZpbHRlckJ5RW5kVmFsdWU6IFwiRmlsdHLDqXIgZWZ0ZXIgc2x1dHbDpnJkaVwiLFxuXHRcdG1pbmltdW1FbmRWYWx1ZTogXCJNaW5pbWFsIHNsdXR2w6ZyZGlcIixcblx0XHRtYXhpbXVtRW5kVmFsdWU6IFwiTWFrc2ltYWwgc2x1dHbDpnJkaVwiLFxuXHRcdG1vZGVsVHlwZU5hbWU6IFwiTW9kZWx0eXBlXCIsXG5cdFx0ZnJvbVJhc3Rlck5hbWU6IFwiRnJhIHJhc3RlclwiLFxuXHRcdHRvUmFzdGVyTmFtZTogXCJUaWwgcmFzdGVyXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZU1ldGhvZDogXCJCZXJlZ24gw6ZuZHJpbmdzbWV0b2RlXCIsXG5cdFx0ZnJvbUNsYXNzVmFsdWVzOiBcIkZyYSBrbGFzc2V2w6ZyZGllciAoZWtzZW1wZWw6IDIgNSlcIixcblx0XHR0b0NsYXNzVmFsdWVzOiBcIlRpbCBrbGFzc2V2w6ZyZGllciAoZWtzZW1wZWw6IDIgNSlcIixcblx0XHRrZWVwTWV0aG9kOiBcIkZpbHRyZXJpbmdzbWV0b2RlXCIsXG5cdFx0dXNlQ29sb3JNZXRob2Q6IFwiRGVmaW7DqXIgb3ZlcmdhbmdzZmFydmVyXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlQmFuZHM6IFwiQsOlbmQgdGlsIHJlZ2lzdHJlcmluZyBhZiDDpm5kcmluZyAoc3RhcnQgdmVkIDApXCIsXG5cdFx0dG1hc2tCYW5kczogXCJCw6VuZCB0aWwgdGVtcG9yYWwgbWFza2VyaW5nIChzdGFydCB2ZWQgMClcIixcblx0XHRjaGlTcXVhcmVkVGhyZXNob2xkOiBcIktoaTItdMOmcnNrZWwgdGlsIGRldGVrdGVyaW5nIGFmIMOmbmRyaW5nXCIsXG5cdFx0bWluQW5vbWFseTogXCJNaW5pbWFsdCBhbnRhbCBww6UgaGluYW5kZW4gZsO4bGdlbmRlIGFub21hbGlvYnNlcnZhdGlvbmVyXCIsXG5cdFx0dXBkYXRpbmdGcmVxdWVuY3k6IFwiT3BkYXRlcmluZyBhZiB0aWxwYXNuaW5nc2ZyZWt2ZW5zIChpIMOlcilcIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvblJhc3Rlck5hbWU6IFwiQWZzdGFuZHNha2t1bXVsZXJpbmdzcmFzdGVyXCIsXG5cdFx0Y29zdEJhY2tkaXJlY3Rpb25SYXN0ZXJOYW1lOiBcIlRpbGJhZ2VyZXRuaW5ncy0gZWxsZXIgRmxvd3JldG5pbmdzcmFzdGVyXCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvbk5hbWU6IFwiUmFzdGVyc2FtbGluZ1wiLFxuXHRcdGl0ZW1GdW5jdGlvbk5hbWU6IFwiRWxlbWVudGZ1bmt0aW9uXCIsXG5cdFx0YWdncmVnYXRpb25GdW5jdGlvbk5hbWU6IFwiQWdncmVnZXJpbmdzZnVua3Rpb25cIixcblx0XHRwcm9jZXNzaW5nRnVuY3Rpb25OYW1lOiBcIkJlaGFuZGxpbmdzZnVua3Rpb25cIixcblx0XHRhZ2dyZWdhdGlvbkRlZmluaXRpb25OYW1lOiBcIkFnZ3JlZ2VyaW5nc2RlZmluaXRpb25cIixcblx0XHRxdWVyeUdlb21ldHJ5TmFtZTogXCJGb3Jlc3DDuHJnc2Vsc2dlb21ldHJpXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25aZXJvRmFjdG9yOiBcIk51bGZha3RvclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ3V0QW5nbGU6IFwiU2vDpnJpbmdzdmlua2VsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TaWRlRmFjdG9yOiBcIlNpZGVmYWt0b3JcIixcblx0XHRmYWN0b3JGdW5jdGlvblNsb3BlOiBcIlN0aWduaW5nXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Mb3dDdXRBbmdsZTogXCJMYXZ0IHNrw6VyZXQgdmlua2VsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25IaWdoQ3V0QW5nbGU6IFwiSMO4anQgc2vDpXJldCB2aW5rZWxcIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvc1Bvd2VyOiBcIkNvc2ludXNmdW5rdGlvblwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2VjUG93ZXI6IFwiU2VrYW50ZnVua3Rpb25cIixcblx0XHRmYWN0b3JGdW5jdGlvblRhYmxlUGF0aDogXCJUYWJlbHN0aVwiLFxuXHRcdHByb2Nlc3NpbmdCYW5kOiBcIkJlaGFuZGxpbmdzYsOlbmRcIixcblx0XHRwcm9jZXNzaW5nQmFuZE5hbWU6IFwiTmF2biBww6UgYmVoYW5kbGluZ3Niw6VuZFwiLFxuXHRcdHNuYXBwaW5nRGF0ZTogXCJTbmFwcGluZ2RhdG9cIixcblx0XHRtYXhOdW1TZWdtZW50czogXCJNYWtzaW1hbHQgYW50YWwgc2VnbWVudGVyXCIsXG5cdFx0dmVydGV4Q291bnRPdmVyc2hvb3Q6IFwiS29vcmRpbmF0cHVua3R0w6ZsbGluZyBvdmVyc2t5ZG5pbmdcIixcblx0XHRzcGlrZVRocmVzaG9sZDogXCJTcGlrZS10w6Zyc2tlbFwiLFxuXHRcdHJlY292ZXJ5VGhyZXNob2xkOiBcIkdlbm9wcmV0bmluZ3N0w6Zyc2tlbFwiLFxuXHRcdG1pbk51bU9iczogXCJNaW5pbWFsdCBhbnRhbCBvYnNlcnZhdGlvbmVyXCIsXG5cdFx0cFZhbHVlVGhyZXNob2xkOiBcIlAtdsOmcmRpdMOmcnNrZWxcIixcblx0XHRiZXN0TW9kZWxQcm9wb3J0aW9uOiBcIkJlZHN0ZSBtb2RlbGFuZGVsXCIsXG5cdFx0cHJldmVudE9uZVllYXJSZWNvdmVyeTogXCJGb3JoaW5kcmUgMSDDpXJzIGdlbm9wcmV0bmluZ1wiLFxuXHRcdHJlY292ZXJ5SW5jcmVhc2VUcmVuZDogXCJHZW5vcHJldG5pbmcgaGFyIGVuIHN0aWdlbmRlIHRlbmRlbnNcIixcblx0XHRvdXRwdXRPdGhlckJhbmRzOiBcIk91dHB1dCBhbmRyZSBiw6VuZFwiLFxuXHRcdHNvcnRUeXBlOiBcIlNvcnRlcmluZ3N0eXBlXCIsXG5cdFx0bnVtYmVyT2ZSdW5zOiBcIkvDuHIgdWR2aWRlbHNlIG9nIGZvcm1pbmRza2Vsc2UgdG8gZ2FuZ2VcIixcblx0XHRwZXJjZW50aWxlVmFsdWU6IFwiUGVyY2VudGlsdsOmcmRpXCIsXG5cdFx0cGVyY2VudGlsZUludGVycG9sYXRpb25UeXBlOiBcIlBlcmNlbnRpbGludGVycG9sYXRpb25zdHlwZVwiLFxuXHRcdHJhc3RlckluZm9Qcm9wZXJ0eTogXCJFZ2Vuc2thYlwiLFxuXHRcdHJhc3RlckluZm9WYWx1ZTogXCJWw6ZyZGlcIixcblx0XHRyYXN0ZXJJbmZvQ29sdW1uczogXCJLb2xvbm5lclwiLFxuXHRcdHJhc3RlckluZm9Sb3dzOiBcIlLDpmtrZXJcIixcblx0XHRyYXN0ZXJJbmZvQmFuZENvdW50OiBcIkFudGFsIGLDpW5kXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsU2l6ZVg6IFwiQ2VsbGVzdMO4cnJlbHNlIFhcIixcblx0XHRyYXN0ZXJJbmZvUGl4ZWxTaXplWTogXCJDZWxsZXNzdMO4cnJlbHNlIFlcIixcblx0XHRyYXN0ZXJJbmZvUGl4ZWxUeXBlOiBcIlBpeGVsLXR5cGVcIixcblx0XHRyYXN0ZXJFeHRlbnRUb3A6IFwiVG9wXCIsXG5cdFx0cmFzdGVyRXh0ZW50Qm90dG9tOiBcIkJ1bmRcIixcblx0XHRyYXN0ZXJFeHRlbnRMZWZ0OiBcIlZlbnN0cmVcIixcblx0XHRyYXN0ZXJFeHRlbnRSaWdodDogXCJIw7hqcmVcIixcblx0XHRyYXN0ZXJTdGF0aXN0aWNzTm90Q2FsY3VsYXRlZDogXCJTdGF0aXN0aWsgZXIgaWtrZSBibGV2ZXQgYmVyZWduZXQuXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVByb2plY3Rpb246IFwiUHJvamVrdGlvblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa2lkOiBcIldLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0V2tpZDogXCJGb3JyaWdlIFdLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlV2t0OiBcIldLVFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VWY3NXa2lkOiBcIlZDU1dLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0VmNzV2tpZDogXCJGb3JyaWdlIFZDU1dLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQXV0aG9yaXR5OiBcIkF1dG9yaXRldFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMaW5lYXJVbml0OiBcIkxpbmXDpnIgZW5oZWRcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQW5ndWxhclVuaXQ6IFwiVmlua2VsZW5oZWRcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VFYXN0aW5nOiBcIkZhbHNrIGVhc3RpbmdcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VOb3J0aGluZzogXCJGYWxzayBub3J0aGluZ1wiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VDZW50cmFsTWVyaWRpYW46IFwiTWlkdGVybWVyaWRpYW5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlUHJpbWVNZXJpZGlhbjogXCJOdWxtZXJpZGlhblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTdGFuZGFyZFBhcmFsbGVsMTogXCJTdGFuZGFyZHBhcmFsbGVsIDFcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3RhbmRhcmRQYXJhbGxlbDI6IFwiU3RhbmRhcmRwYXJhbGxlbCAyXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGl0dWRlT2ZPcmlnaW46IFwiT3ByaW5kZWxzZXMgYnJlZGRlZ3JhZFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBdXhpbGlhcnlTcGhlcmVUeXBlOiBcIkF1eGlsaWFyeSBTcGhlcmUtdHlwZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VEYXR1bTogXCJEYXR1bVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTcGhlcm9pZDogXCJTZsOmcm9pZFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTZW1pbWFqb3JBeGlzOiBcIsOGa3ZhdG9yaWFscmFkaXVzIGZvciBzZsOmcm9pZGUgKGEtYWtzZSlcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU2VtaW1pbm9yQXhpczogXCJQb2xhcnJhZGl1cyBmb3Igc2bDpnJvaWRlIChiLWFrc2UpXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUludmVyc2VGbGF0dGVuaW5nOiBcIk9tdmVuZHQgdWRqw6Z2bmluZ1wiLFxuXHRcdGlucHV0RGVmaW5pdGlvbkZpbGVOYW1lOiBcIklucHV0LWRlZmluaXRpb25zZmlsXCIsXG5cdFx0ZGVsZXRlTmFtZTogXCJTbGV0XCIsXG5cdFx0YWRkVmFyaWFibGVOYW1lOiBcIlRpbGbDuGogdmFyaWFiZWxcIixcblx0XHRtYXhOdW1QaXhlbHNQZXJTZWdtZW50OiBcIkjDuGpzdGUgc2VnbWVudHN0w7hycmVsc2UgaSBwaXhlbHNcIixcblx0XHRmb3J3YXJkV2luZG93TmFtZTogXCJGcmVtYWQtdmluZHVlXCIsXG5cdFx0YmFja3dhcmRXaW5kb3dOYW1lOiBcIkJhZ3VkLXZpbmR1ZVwiLFxuXHRcdG5vRGF0YUhhbmRsaW5nTmFtZTogXCJOb0RhdGEtaMOlbmR0ZXJpbmdcIixcblx0XHRjaXJjdWxhcldyYXBWYWx1ZU5hbWU6IFwiQ2lyY3Vsw6ZyIG9tYnJ5ZG5pbmdzdsOmcmRpXCIsXG5cdFx0ZnJvbUNsYXNzTmFtZUZpZWxkTmFtZTogXCJGZWx0bmF2biBmb3Iga2xhc3NlbmF2bmUgaSBGcmEgcmFzdGVyXCIsXG5cdFx0dG9DbGFzc05hbWVGaWVsZE5hbWU6IFwiRmVsdG5hdm4gZm9yIGtsYXNzZW5hdm5lIGkgVGlsIHJhc3RlclwiLFxuXHRcdHRhcmdldFJhc3Rlck5hbWU6IFwiTcOlbC1yYXN0ZXJcIixcblx0XHRjaXJjdWxhcldyYXBWYWx1ZTogXCJDaXJjdWzDpnIgb21icnlkbmluZ3N2w6ZyZGlcIixcblx0XHRiYW5kSW5kZXhlc1I6IFwiUsO4ZHQgdWR0cnlrXCIsXG5cdFx0YmFuZEluZGV4ZXNHOiBcIkdyw7hudCB1ZHRyeWtcIixcblx0XHRiYW5kSW5kZXhlc0I6IFwiQmzDpXQgdWR0cnlrXCIsXG5cdFx0ZXhhbXBsZU5hbWU6IFwiRWtzZW1wZWxcIixcblx0XHRpbnB1dE5hbWU6IFwiSW5wdXRcIixcblx0XHRvdXRwdXROYW1lOiBcIk91dHB1dFwiLFxuXHRcdG9wdGlvbmFsTmFtZTogXCJWYWxnZnJpdFwiLFxuXHRcdGJyb3dzZURlZmluaXRpb25GaWxlOiBcIkdlbm5lbXNlIGRlZmluaXRpb25zZmlsXCIsXG5cdFx0c2VsZWN0RGVmaW5pdGlvbkZpbGU6IFwiVsOmbGcgaW5wdXQtZGVmaW5pdGlvbnNmaWxcIixcblx0XHRpbnB1dERlZmluaXRpb25VUkw6IFwiSW5wdXQtZGVmaW5pdGlvbnNmaWxzIFVSTFwiLFxuXHRcdGVudGVyRGVmaW5pdGlvbkZpbGVVUkw6IFwiSW5kdGFzdCBpbnB1dC1kZWZpbml0aW9uc2ZpbHMgVVJMXCIsXG5cdFx0YnJvd3NlWE1MRmlsZTogXCJHZW5uZW1zZSBYTUwtZmlsXCIsXG5cdFx0c2VsZWN0U3RhdHNGaWxlOiBcIlbDpmxnIHN0YXRpc3Rpay0gb2cgaGlzdG9ncmFtZmlsXCIsXG5cdFx0ZW50ZXJYTUxGaWxlVVJMOiBcIkluZHRhc3QgWE1MLWZpbHMgVVJMXCIsXG5cdFx0eG1sRmlsZVVSTDogXCJYTUwtZmlscyBVUkxcIixcblx0XHRjaXJjdWxhckNhbGN1bGF0aW9uOiBcIkJlcmVnbiBjaXJrdWzDpnIgc3RhdGlzdGlrXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZTogXCJMb2thbCBvdmVyZmxhZGV0eXBlXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlclR5cGU6IFwiUGFyYW1ldGVydHlwZVwiLFxuXHRcdG5laWdoYm9yaG9vZERpc3RhbmNlOiBcIk5hYm9hZnN0YW5kXCIsXG5cdFx0dXNlQWRhcHRpdmVOZWlnaGJvcmhvb2Q6IFwiQnJ1ZyBhZGFwdGl2dCBuYWJvbGFnXCIsXG5cdFx0b3V0cHV0U2xvcGVUeXBlOiBcIk3DpWxpbmcgYWYgb3V0cHV0LWjDpmxkbmluZ1wiLFxuXHRcdHByb2plY3RBemltdXRoczogXCJQcm9qaWNlciBnZW9kw6Z0aXNrZSBhemltdXR0ZXJcIixcblx0XHR1c2VFcXVhdG9yaWFsQXNwZWN0OiBcIkJydWcgw6ZrdmF0b3JpYWxhc3Bla3RcIixcblx0XHR6VW5pdDogXCJaLWVuaGVkXCIsXG5cdFx0YW5hbHlzaXNNYXNrOiBcIkFuYWx5c2VtYXNrZVwiLFxuXHRcdHN0ZERldmlhdGlvbjogXCJTdGFuZGFyZGFmdmlnZWxzZVwiLFxuXHRcdFwidHJ1ZVwiOiBcIlNhbmR0XCIsXG5cdFx0XCJmYWxzZVwiOiBcIkZhbHNrXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMTogXCJJbnB1dC1yYXN0ZXIgMSBmb3IgYWtrdW11bGVyZXQgb21rb3N0bmluZ3NhZnN0YW5kXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMjogXCJJbnB1dC1yYXN0ZXIgMiBmb3IgYWtrdW11bGVyZXQgb21rb3N0bmluZ3NhZnN0YW5kXCIsXG5cdFx0dGhyZXNob2xkOiBcIlTDpnJza2VsXCIsXG5cdFx0dGhyZXNob2xkTWV0aG9kOiBcIlTDpnJza2VsbWV0b2RlXCIsXG5cdFx0ZGlyZWN0aW9uUmFzdGVyMTogXCJJbnB1dC10aWxiYWdlcmV0bmluZ3NyYXN0ZXIgMVwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjI6IFwiSW5wdXQtdGlsYmFnZXJldG5pbmdzcmFzdGVyIDJcIixcblx0XHRtYXhJdGVyYXRpb25zOiBcIk1ha3MuIGFudGFsIGdlbnRhZ2Vsc2VyXCIsXG5cdFx0ZXBzaWxvbjogXCJFcHNpbG9uXCJcblx0fSxcblx0ZW51bUxhYmVsczoge1xuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZU1hbnVhbDogXCJNYW51ZWxcIixcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVFeHRlcm5hbDogXCJFa3N0ZXJuXCIsXG5cdFx0Y2xyU2NoZW1lVHlwZUNvbG9ybWFwOiBcIkZhcnZla29ydFwiLFxuXHRcdGNsclNjaGVtZVR5cGVDb2xvclJhbXA6IFwiRmFydmVza2FsYVwiLFxuXHRcdGNvbG9ybWFwVHlwZUVsZXZhdGlvbjogXCJIw7hqZGVcIixcblx0XHRjb2xvcm1hcFR5cGVHcmF5OiBcIkdyw6VcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJOiBcIk5EVklcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJMjogXCJORFZJMlwiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkkzOiBcIk5EVkkzXCIsXG5cdFx0Y29sb3JtYXBUeXBlUmFuZG9tOiBcIlZpbGvDpXJsaWdcIixcblx0XHRub25lOiBcIkluZ2VuXCIsXG5cdFx0c2xvcGVUeXBlQWRqdXN0ZWQ6IFwiSnVzdGVyZXRcIixcblx0XHRzbG9wZVR5cGVEZWdyZWU6IFwiR3JhZFwiLFxuXHRcdHNsb3BlVHlwZVBlcmNlbnRSaXNlOiBcIlByb2NlbnRzdGlnbmluZ1wiLFxuXHRcdHNsb3BlVHlwZVNjYWxlZDogXCJTa2FsZXJldFwiLFxuXHRcdHN0cmV0Y2hUeXBlTWluTWF4OiBcIk1pbi4tTWFrcy5cIixcblx0XHRzdHJldGNoVHlwZVBlcmNlbnRNaW5NYXg6IFwiUGVyY2VudE1pbk1heFwiLFxuXHRcdHN0cmV0Y2hUeXBlU2lnbW9pZDogXCJTaWdtb2lkXCIsXG5cdFx0c3RyZXRjaFR5cGVTdGREZXY6IFwiU3RkQWZ2XCIsXG5cdFx0aGlsbHNoYWRlVHlwZVNpbXBsZTogXCJUcmFkaXRpb25lbFwiLFxuXHRcdGhpbGxzaGFkZVR5cGVNdWx0aWRpcmVjdGlvbmFsOiBcIk1hbmdlIHJldG5pbmdlclwiLFxuXHRcdGJhbmRDb21ib0J5TmFtZXM6IFwiQsOlbmRuYXZuZVwiLFxuXHRcdGJhbmRDb21ib0J5V2F2ZWxlbmd0aDogXCJCw6VuZGLDuGxnZWzDpm5nZGVyXCIsXG5cdFx0YmFuZENvbWJvQnlJRHM6IFwiQsOlbmQtSUQnZXJcIixcblx0XHRtaXNzaW5nQmFuZEFjdGlvbkJlc3RNYXRjaDogXCJCZWRzdGUgbWF0Y2hcIixcblx0XHRtaXNzaW5nQmFuZEFjdGlvbkZhaWw6IFwiTWlzbHlra2V0XCIsXG5cdFx0dW5pdFR5cGVDZWxzaXVzOiBcIkNlbHNpdXNcIixcblx0XHR1bml0VHlwZUNlbnRpbWV0ZXJzOiBcIkNlbnRpbWV0ZXJcIixcblx0XHR1bml0VHlwZURlY2ltZXRlcnM6IFwiRGVjaW1ldGVyXCIsXG5cdFx0dW5pdFR5cGVGYWhyZW5oZWl0OiBcIkZhaHJlbmhlaXRcIixcblx0XHR1bml0VHlwZUZlZXQ6IFwiRm9kXCIsXG5cdFx0dW5pdFR5cGVGZWV0UGVyU2VjOiBcIkZvZCBwci4gc2VrdW5kIChmdC9zKVwiLFxuXHRcdHVuaXRUeXBlSW5jaGVzOiBcIlRvbW1lclwiLFxuXHRcdHVuaXRUeXBlS2VsdmluOiBcIktlbHZpblwiLFxuXHRcdHVuaXRUeXBlS2lsb21ldGVyczogXCJLaWxvbWV0ZXJcIixcblx0XHR1bml0VHlwZUttc1BlckhvdXI6IFwiS2lsb21ldGVyIHByLiB0aW1lIChrbS90KVwiLFxuXHRcdHVuaXRUeXBlS25vdHM6IFwiS25vYiAoa24pXCIsXG5cdFx0dW5pdFR5cGVNZXRlcnM6IFwiTWV0ZXJcIixcblx0XHR1bml0VHlwZU1ldGVyc1BlclNlYzogXCJNZXRlciBwci4gc2VrdW5kIChtL3MpXCIsXG5cdFx0dW5pdFR5cGVNaWxlczogXCJNaWxlc1wiLFxuXHRcdHVuaXRUeXBlTWlsZXNQZXJIb3VyOiBcIk1pbGVzIHByLiB0aW1lIChtcGgpXCIsXG5cdFx0dW5pdFR5cGVNaWxsaW1ldGVyczogXCJNaWxsaW1ldGVyXCIsXG5cdFx0dW5pdFR5cGVOYXV0aWNhbE1pbGVzOiBcIlPDuG1pbFwiLFxuXHRcdHVuaXRUeXBlWWFyZHM6IFwiWWFyZHNcIixcblx0XHR1bml0VHlwZURlY2ltYWxEZWdyZWVzOiBcIkRlY2ltYWxncmFkZXJcIixcblx0XHR1bml0VHlwZVBvaW50czogXCJQdW5rdGVyXCIsXG5cdFx0dW5pdFR5cGVVbmtub3duOiBcIlVrZW5kdFwiLFxuXHRcdHVuaXRUeXBlU3FNYXBVbml0czogXCJLdmFkcmF0a29ydGVuaGVkZXJcIixcblx0XHR1bml0VHlwZVNxTWlsZXM6IFwiS3ZhZHJhdG1pbGVzXCIsXG5cdFx0dW5pdFR5cGVTcUttczogXCJLdmFkcmF0a2lsb21ldGVyXCIsXG5cdFx0dW5pdFR5cGVBY3JlczogXCJBY3Jlc1wiLFxuXHRcdHVuaXRUeXBlSGVjdGFyZXM6IFwiSGVrdGFyZXJcIixcblx0XHR1bml0VHlwZVNxWWFyZHM6IFwiS3ZhZHJhdHlhcmRcIixcblx0XHR1bml0VHlwZVNxRnQ6IFwiS3ZhZHJhdGZvZFwiLFxuXHRcdHVuaXRUeXBlU3FJbmNoZXM6IFwiS3ZhZHJhdHRvbW1lclwiLFxuXHRcdHVuaXRUeXBlU3FNdHM6IFwiS3ZhZHJhdG1ldGVyXCIsXG5cdFx0dW5pdFR5cGVTcUNtczogXCJLdmFkcmF0Y2VudGltZXRlclwiLFxuXHRcdHVuaXRUeXBlU3FNbXM6IFwiS3ZhZHJhdG1pbGxpbWV0ZXJcIixcblx0XHRjZWxsc2l6ZVR5cGVGaXJzdDogXCJGw7hyc3RlIGFmXCIsXG5cdFx0Y2VsbHNpemVUeXBlTWluOiBcIk1pbi4gYWZcIixcblx0XHRjZWxsc2l6ZVR5cGVNYXg6IFwiTWFrcy4gYWZcIixcblx0XHRjZWxsc2l6ZVR5cGVNZWFuOiBcIk1pZGRlbHbDpnJkaSBhZlwiLFxuXHRcdGNlbGxzaXplVHlwZUxhc3Q6IFwiU2lkc3RlIGFmXCIsXG5cdFx0ZXh0ZW50VHlwZUZpcnN0OiBcIkbDuHJzdGUgYWZcIixcblx0XHRleHRlbnRUeXBlSW50ZXJzZWN0aW9uOiBcIkdlbm5lbXNrw6ZyaW5nIGFmXCIsXG5cdFx0ZXh0ZW50VHlwZVVuaW9uOiBcIkZvcmVuaW5nIGFmXCIsXG5cdFx0ZXh0ZW50VHlwZUxhc3Q6IFwiU2lkc3RlIGFmXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QW55OiBcIk1hdGNoIGVuaHZlclwiLFxuXHRcdG5vRGF0YUludGVycHJldEFsbDogXCJNYXRjaCBhbGxlXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVN0YW5kYXJkOiBcIlN0YW5kYXJkXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVByb2ZpbGU6IFwiUHJvZmlsXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVBsYW5mb3JtOiBcIlBsYW5mb3JtXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25Ib3Jpem9udGFsOiBcIkxpbmplZGV0ZWt0ZXJpbmcgdmFuZHJldFwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uVmVydGljYWw6IFwiTGluamVkZXRla3RlcmluZyBsb2RyZXRcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvbkxlZnREaWFnb25hbDogXCJMaW5qZWRldGVrdGVyaW5nIHZlbnN0cmUgZGlhZ29uYWxcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvblJpZ2h0RGlhZ29uYWw6IFwiTGluamVkZXRla3RlcmluZyBow7hqcmUgZGlhZ29uYWxcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aDogXCJIw6ZsZG5pbmcgbm9yZFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudFdlc3Q6IFwiSMOmbGRuaW5nIHZlc3RcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRFYXN0OiBcIkjDpmxkbmluZyDDuHN0XCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50U291dGg6IFwiSMOmbGRuaW5nIHN5ZFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudE5vcnRoRWFzdDogXCJIw6ZsZG5pbmcgbm9yZMO4c3RcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aFdlc3Q6IFwiSMOmbGRuaW5nIG5vcmR2ZXN0XCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aEFyaXRobWV0aWNNZWFuOiBcIkrDpnZuIGFyaXRtZXRpc2sgbWlkZGVsdsOmcmRpXCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aGluZzN4MzogXCJVZGrDpnZuZXIgM3gzXCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aGluZzV4NTogXCJVZGrDpnZuZXIgNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW5pbmczeDM6IFwiU2vDpnJwZXIgM3gzXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW5pbmc1eDU6IFwiU2vDpnJwZXIgNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZUxhcGxhY2lhbjN4MzogXCJMYXBsYWNlLWZvcmRlbGluZyAzeDNcIixcblx0XHRmaWx0ZXJUeXBlTGFwbGFjaWFuNXg1OiBcIkxhcGxhY2UtZm9yZGVsaW5nIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbEhvcml6b250YWw6IFwiU29iZWwgdmFuZHJldFwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbFZlcnRpY2FsOiBcIlNvYmVsIGxvZHJldFwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuOiBcIlNrw6ZycG5pbmdcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbjI6IFwiU2vDpnJwIG1lcmVcIixcblx0XHRmaWx0ZXJUeXBlUG9pbnRTcHJlYWQ6IFwiUHVua3RzcHJlZG5pbmdcIixcblx0XHR1c2VyRGVmaW5lZDogXCJCcnVnZXJkZWZpbmVyZXRcIixcblx0XHRDb250b3VyVHlwZUxpbmVzOiBcIktvbnR1cmxpbmplclwiLFxuXHRcdENvbnRvdXJUeXBlRmlsbDogXCJLb250dXJmeWxkXCIsXG5cdFx0Q29udG91clR5cGVTbW9vdGhPbmx5OiBcIkt1biBqw6Z2biBvdmVyZmxhZGVcIixcblx0XHRyYXN0ZXJpemVGaXJzdDogXCJGw7hyc3RlXCIsXG5cdFx0cmFzdGVyaXplTGFzdDogXCJTaWRzdGVcIixcblx0XHRyYXN0ZXJpemVTbWFsbGVzdDogXCJNaW5kc3RcIixcblx0XHRyYXN0ZXJpemVMYXJnZXN0OiBcIlN0w7hyc3RcIixcblx0XHRyZXNhbXBsaW5nVHlwZU5lYXJlc3Q6IFwiTsOmcm1lc3RlIG5hYm9cIixcblx0XHRyZXNhbXBsaW5nVHlwZUJpbGluZWFyOiBcIkJpbGluZcOmciBpbnRlcnBvbGF0aW9uXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVDdWJpYzogXCJLdWJpay1rb252b2x1dGlvblwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWFqb3JpdHk6IFwiTWFqb3JpdGV0XCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhclBsdXM6IFwiQmlsaW5lw6ZyIEludGVycG9sYXRpb24gUGx1c1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlR2F1c3M6IFwiR2F1c3Npc2sgc2zDuHJpbmdcIixcblx0XHRyZXNhbXBsaW5nVHlwZUdhdXNzUGx1czogXCJHYXVzc2lzayBzbMO4cmluZyBQbHVzXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVBdmVyYWdlOiBcIkdlbm5lbXNuaXRcIixcblx0XHRyZXNhbXBsaW5nVHlwZU1pbmltdW06IFwiTWluaW11bVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWF4aW11bTogXCJNYWtzaW11bVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlVmVjdG9yQXZnOiBcIlZla3Rvcmdlbm5lbXNuaXRcIixcblx0XHRtaW5pbXVtOiBcIk1pbmltdW1cIixcblx0XHRtYXhpbXVtOiBcIk1ha3NpbXVtXCIsXG5cdFx0bWVhbjogXCJNaWRkZWxcIixcblx0XHRzdGREZXZpYXRpb246IFwiU3RhbmRhcmRhZnZpZ2Vsc2VcIixcblx0XHR1dk1hZ0RpclR5cGVVVjogXCJVLVZcIixcblx0XHR1dk1hZ0RpclR5cGVNYWdEaXI6IFwiU3TDuHJyZWxzZS1SZXRuaW5nXCIsXG5cdFx0dW5rbm93bjogXCJVa2VuZHRcIixcblx0XHRhbmdsZVJlZlN5c0dlb2dyYXBoaWM6IFwiR2VvZ3JhZmlza1wiLFxuXHRcdGFuZ2xlUmVmU3lzQXJpdGhtZXRpYzogXCJBcml0bWV0aXNrXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmVhcmVzdDogXCJOw6ZybWVzdGUgbmFib1wiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YUJpbGluZWFyOiBcIkJpbGluZcOmclwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdMaW5lYXI6IFwiTGluZcOmciB0aW5uaW5nXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhVGlubmluZ05hdHVyYWxOZWlnaGJvcjogXCJOYXR1cmxpZyBuYWJvXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhVGlubmluZ0lEVzogXCJWw6ZndGV0IG9tdmVuZHQgYWZzdGFuZFwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlQ29uc3RhbnQ6IFwiS29uc3RhbnRcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZU90c3U6IFwiT3RzdVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlVHNhaTogXCJUc2FpXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVLYXB1cjogXCJLYXB1clwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlS2l0dGxlcjogXCJLaXR0bGVyXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVSb3NpbjogXCJSb3NpblwiLFxuXHRcdGFyZ1N0YXRzVHlwZU1heDogXCJBcmcgTWF4XCIsXG5cdFx0YXJnU3RhdHNUeXBlTWluOiBcIkFyZyBNaW5cIixcblx0XHRhcmdTdGF0c1R5cGVNZWRpYW46IFwiQXJnIE1lZGlhblwiLFxuXHRcdGFyZ1N0YXRzVHlwZUR1cmF0aW9uOiBcIlZhcmlnaGVkXCIsXG5cdFx0YXJpdGhtZXRpY09wUGx1czogXCJQbHVzXCIsXG5cdFx0YXJpdGhtZXRpY09wTWludXM6IFwiTWludXNcIixcblx0XHRhcml0aG1ldGljT3BNdWx0aXBseTogXCJNdWx0aXBsaWPDqXJcIixcblx0XHRhcml0aG1ldGljT3BEaXZpZGU6IFwiRGl2aWTDqXJcIixcblx0XHRhcml0aG1ldGljT3BQb3dlcjogXCJQb3RlbnNcIixcblx0XHRhcml0aG1ldGljT3BNb2RlOiBcIlRpbHN0YW5kXCIsXG5cdFx0Y2xpcFR5cGVPdXRzaWRlOiBcIktsaXAgdWRlbmZvclwiLFxuXHRcdGNsaXBUeXBlSW5zaWRlOiBcIktsaXAgaW5kZW5pXCIsXG5cdFx0eWVzOiBcIkphXCIsXG5cdFx0bm86IFwiTmVqXCIsXG5cdFx0ZGVuc2l0aWVzOiBcIlTDpnRoZWRlclwiLFxuXHRcdGV4cGVjdGVkQ291bnRzOiBcIkZvcnZlbnRlZGUgYW50YWxcIixcblx0XHRwbGFuYXI6IFwiUGxhblwiLFxuXHRcdGdlb2Rlc2ljOiBcIkdlb2TDpnRpc2tcIixcblx0XHRlYWNoQ2VsbDogXCJIdmVyIGNlbGxlXCIsXG5cdFx0ZWFjaFpvbmU6IFwiSHZlciB6b25lXCIsXG5cdFx0YmVzdFNpbmdsZTogXCJCZWRzdGUgZW5rZWx0XCIsXG5cdFx0YWxsU2lnaHRsaW5lczogXCJBbGxlIHNpZ3RlbGluamVyXCIsXG5cdFx0cGVyaW1ldGVyU2lnaHRsaW5lczogXCJQZXJpbWV0ZXItc2lndGVsaW5qZXJcIixcblx0XHRmcmVxdWVuY3k6IFwiRnJla3ZlbnNcIixcblx0XHRvYnNlcnZlcnM6IFwiT2JzZXJ2YXTDuHJlclwiLFxuXHRcdG1ham9yaXR5OiBcIk1ham9yaXRldFwiLFxuXHRcdG1lZGlhbjogXCJNZWRpYW5cIixcblx0XHRtaW5vcml0eTogXCJNaW5vcml0ZXRcIixcblx0XHRwZXJjZW50aWxlOiBcIlBlcmNlbnRpbFwiLFxuXHRcdHJhbmdlOiBcIk9tcsOlZGVcIixcblx0XHRzdW06IFwiU3VtXCIsXG5cdFx0dmFyaWV0eTogXCJWYXJpYXRpb25cIixcblx0XHRuZHZpOiBcIk5EVklcIixcblx0XHRzYXZpOiBcIlNBVklcIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZFRTQVZJOiBcIlRyYW5zZm9ybWVyZXQgU0FWSVwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kTVNBVkk6IFwiTW9kaWZpY2VyZXQgU0FWSVwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kU3VsdGFuOiBcIlN1bHRhbidzIEZvcm11bGFcIixcblx0XHRnZW1pOiBcIkdFTUlcIixcblx0XHRwdmk6IFwiUFZJXCIsXG5cdFx0Z3ZpOiBcIkdWSSAoTGFuZHNhdCBUTSlcIixcblx0XHR2YXJpOiBcIlZBUklcIixcblx0XHRzcjogXCJTUlwiLFxuXHRcdGduZHZpOiBcIkdORFZJXCIsXG5cdFx0bmR2aXJlOiBcIk5EVklyZVwiLFxuXHRcdHNycmU6IFwiU1JyZVwiLFxuXHRcdG10dmkyOiBcIk1UVkkyXCIsXG5cdFx0cnR2aUNvcmU6IFwiUlRWSUNvcmVcIixcblx0XHRjaXJlOiBcIkNJcmVcIixcblx0XHRjaWc6IFwiQ0lnXCIsXG5cdFx0bmR3aTogXCJORFdJXCIsXG5cdFx0ZXZpOiBcIkVWSVwiLFxuXHRcdGlyb25PeGlkZTogXCJKZXJub3hpZFwiLFxuXHRcdGZlcnJvdXNNaW5lcmFsczogXCJKZXJuaG9sZGlnZSBtaW5lcmFsZXJcIixcblx0XHRjbGF5TWluZXJhbHM6IFwiTGVyaG9sZGlnZSBtaW5lcmFsZXJcIixcblx0XHR3bmR3aTogXCJXTkRXSVwiLFxuXHRcdGJhaTogXCJCQUlcIixcblx0XHRtbmR3aTogXCJNTkRXSVwiLFxuXHRcdG5icjogXCJOQlJcIixcblx0XHRuZGJpOiBcIk5EQklcIixcblx0XHRuZG1pOiBcIk5ETUlcIixcblx0XHRuZHNpOiBcIk5EU0lcIixcblx0XHRsb2NhbFNxdWFyZVJvb3Q6IFwiS3ZhZHJhdHJvZFwiLFxuXHRcdGxvY2FsQUNvczogXCJBUkNDT1NcIixcblx0XHRsb2NhbEFTaW46IFwiQVJDU0lOXCIsXG5cdFx0bG9jYWxBVGFuOiBcIkFSQ1RBTlwiLFxuXHRcdGxvY2FsQVRhbkg6IFwiQVJDVEFOSFwiLFxuXHRcdGxvY2FsQWJzOiBcIkFCU1wiLFxuXHRcdGxvY2FsQml0d2lzZU5vdDogXCJCaXR3aXNlIElra2VcIixcblx0XHRsb2NhbEJvb2xlYW5Ob3Q6IFwiQm9vbGVzayBJa2tlXCIsXG5cdFx0bG9jYWxDb3M6IFwiQ29zXCIsXG5cdFx0bG9jYWxDb3NIOiBcIkNvc0hcIixcblx0XHRsb2NhbEV4cDogXCJFS1NQXCIsXG5cdFx0bG9jYWxFeHAxMDogXCJFS1NQMTBcIixcblx0XHRsb2NhbEV4cDI6IFwiRUtTUDJcIixcblx0XHRsb2NhbEludDogXCJIZWx0YWxcIixcblx0XHRsb2NhbElzTnVsbDogXCJlciBudWxcIixcblx0XHRsb2NhbEZsb2F0OiBcIkZseWRlbmRlXCIsXG5cdFx0bG9jYWxMbjogXCJMblwiLFxuXHRcdGxvY2FsTG9nMTA6IFwiTG9nMTBcIixcblx0XHRsb2NhbExvZzI6IFwiTG9nMlwiLFxuXHRcdGxvY2FsTmVnYXRlOiBcIk5lZ8OpclwiLFxuXHRcdGxvY2FsUm91bmREb3duOiBcIlJ1bmQgbmVkXCIsXG5cdFx0bG9jYWxSb3VuZFVwOiBcIlJ1bmQgb3BcIixcblx0XHRsb2NhbFNpbjogXCJTaW5cIixcblx0XHRsb2NhbFNpbkg6IFwiU2luSFwiLFxuXHRcdGxvY2FsVGFuOiBcIlRhblwiLFxuXHRcdGxvY2FsVGFuSDogXCJUYW5IXCIsXG5cdFx0bG9jYWxBQ29zSDogXCJBUkNDT1NIXCIsXG5cdFx0bG9jYWxBU2luSDogXCJBUkNTSU5IXCIsXG5cdFx0bG9jYWxQbHVzOiBcIlBsdXNcIixcblx0XHRsb2NhbE1pbnVzOiBcIk1pbnVzXCIsXG5cdFx0bG9jYWxUaW1lczogXCJUaWRlclwiLFxuXHRcdGxvY2FsUG93ZXI6IFwiUG90ZW5zXCIsXG5cdFx0bG9jYWxCaXR3aXNlQW5kOiBcIkJpdHdpc2UgT2dcIixcblx0XHRsb2NhbEJpdHdpc2VMZWZ0U2hpZnQ6IFwiQml0d2lzZSBWZW5zdHJlIHNraWZ0XCIsXG5cdFx0bG9jYWxCaXR3aXNlT3I6IFwiQml0d2lzZSBFbGxlclwiLFxuXHRcdGxvY2FsQml0d2lzZVJpZ2h0U2hpZnQ6IFwiQml0d2lzZSBIw7hqcmUgc2tpZnRcIixcblx0XHRsb2NhbEJpdHdpc2VYb3I6IFwiQml0d2lzZSBYb3JcIixcblx0XHRsb2NhbEJvb2xlYW5BbmQ6IFwiQm9vbGVzayBPZ1wiLFxuXHRcdGxvY2FsQm9vbGVhbk9yOiBcIkJvb2xlc2sgRWxsZXJcIixcblx0XHRsb2NhbEJvb2xlYW5Yb3I6IFwiQm9vbGVzayBYb3JcIixcblx0XHRsb2NhbERpdmlkZTogXCJEaXZpZMOpclwiLFxuXHRcdGxvY2FsRXF1YWxUbzogXCJMaWcgbWVkXCIsXG5cdFx0bG9jYWxHcmVhdGVyVGhhbjogXCJTdMO4cnJlIGVuZFwiLFxuXHRcdGxvY2FsR3JlYXRlclRoYW5FcXVhbDogXCJTdMO4cnJlIGVuZCBlbGxlciBsaWcgbWVkXCIsXG5cdFx0bG9jYWxMZXNzVGhhbjogXCJNaW5kcmUgZW5kXCIsXG5cdFx0bG9jYWxMZXNzVGhhbkVxdWFsOiBcIk1pbmRyZSBlbmQgZWxsZXIgbGlnIG1lZFwiLFxuXHRcdGxvY2FsTW9kOiBcIk1vZFwiLFxuXHRcdGxvY2FsTm90RXF1YWw6IFwiSWtrZSBsaWcgbWVkXCIsXG5cdFx0bG9jYWxBVGFuMjogXCJBUkNUQU4yXCIsXG5cdFx0bG9jYWxTcXVhcmU6IFwiS3ZhZHJhdFwiLFxuXHRcdGxvY2FsU2V0TnVsbDogXCJBbmdpdiBudWxcIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkxpc3RlXCIsXG5cdFx0cmVtYXBEZWZUeXBlVGFibGU6IFwiVGFiZWxcIixcblx0XHRyZW1hcFRhYmxlVHlwZVNpbXBsZTogXCJFbmtlbFwiLFxuXHRcdHJlbWFwVGFibGVUeXBlRHluYW1pYzogXCJEeW5hbWlza1wiLFxuXHRcdHJlbWFwVGFibGVUeXBlUmVhc3NpZ25tZW50OiBcIkdlbnRpbGRlbGluZ1wiLFxuXHRcdGdlb21Db3JyZWN0aW9uQnlDb25zdFo6IFwiQnJ1ZyBrb25zdGFudCBaXCIsXG5cdFx0Z2VvbUNvcnJlY3Rpb25CeURFTTogXCJCcnVnIERFTVwiLFxuXHRcdHJhZGFyQ2FsaWJCZXRhTm91Z2h0OiBcIkJldGEtbm91Z2h0XCIsXG5cdFx0cmFkYXJDYWxpYlNpZ21hTm91Z2h0OiBcIlNpZ21hLW5vdWdodFwiLFxuXHRcdHJhZGFyQ2FsaWJHYW1tYU5vdWdodDogXCJHYW1tYS1ub3VnaHRcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUxlZTogXCJMZWUtZmlsdGVyXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVFbmhhbmNlZExlZTogXCJVZHZpZGV0IExlZS1maWx0ZXJcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUZyb3N0OiBcIkZyb3N0LWZpbHRlclwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlS3VhbjogXCJLdWFuLWZpbHRlclwiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsTXVsOiBcIk11bHRpcGxpa2F0aXYgc3TDuGpcIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbEFkZDogXCJBZGRpdGl2IHN0w7hqXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxBZGRuTXVsOiBcIkFkZGl0aXYgb2cgbXVsdGlwbGlrYXRpdiBzdMO4alwiLFxuXHRcdG1vc2FpY09wVHlwZUZpcnN0OiBcIkbDuHJzdGVcIixcblx0XHRtb3NhaWNPcFR5cGVMYXN0OiBcIlNpZHN0ZVwiLFxuXHRcdG1vc2FpY09wVHlwZU1pbjogXCJNaW4uXCIsXG5cdFx0bW9zYWljT3BUeXBlTWF4OiBcIk1ha3MuXCIsXG5cdFx0bW9zYWljT3BUeXBlTWVhbjogXCJNaWRkZWxcIixcblx0XHRtb3NhaWNPcFR5cGVCbGVuZDogXCJCbGFuZFwiLFxuXHRcdG1vc2FpY09wVHlwZVN1bTogXCJTdW1cIixcblx0XHRpbnRlZ2VyOiBcIkhlbHRhbFwiLFxuXHRcdHJmeEQ4OiBcIkQ4XCIsXG5cdFx0cmZ4TUZEOiBcIk1GRFwiLFxuXHRcdGRpbmY6IFwiRGluZlwiLFxuXHRcdHZlcnRpY2FsOiBcIkxvZHJldFwiLFxuXHRcdGhvcml6b250YWw6IFwiVmFuZHJldFwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eTogXCJNYWpvcml0ZXRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWF4OiBcIk1ha3NpbXVtXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW46IFwiTWlkZGVsXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbjogXCJNZWRpYW5cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWluOiBcIk1pbmltdW1cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHk6IFwiTWlub3JpdGV0XCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1JhbmdlOiBcIk9tcsOlZGVcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3RkRGV2OiBcIlN0YW5kYXJkYWZ2aWdlbHNlXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N1bTogXCJTdW1cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVmFyaWV0eTogXCJWYXJpYXRpb25cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWFqb3JpdHlJZ25vcmVORDogXCJNYWpvcml0ZXQgKGlnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYXhJZ25vcmVORDogXCJNYWtzaW11bSAoaWdub3JlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW5JZ25vcmVORDogXCJNaWRkZWwgKGlnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWRpYW5JZ25vcmVORDogXCJNZWRpYW4gKGlnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5JZ25vcmVORDogXCJNaW5pbXVtIChpZ25vcmVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHlJZ25vcmVORDogXCJNaW5vcml0ZXQgKGlnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NSYW5nZUlnbm9yZU5EOiBcIkludGVydmFsIChpZ25vcmVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3RkRGV2SWdub3JlTkQ6IFwiU3RhbmRhcmQtYWZ2aWdlbHNlIChpZ25vcmVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtSWdub3JlTkQ6IFwiU3VtIChpZ25vcmVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVmFyaWV0eUlnbm9yZU5EOiBcIlZhcmlhdGlvbiAoaWdub3JlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1R5cGVQZXJjZW50aWxlSWdub3JlTkQ6IFwiUGVyY2VudGlsIChJZ25vcmVyIE5vRGF0YSlcIixcblx0XHRmcm9tU291cmNlOiBcIkZyYSBraWxkZVwiLFxuXHRcdHRvU291cmNlOiBcIlRpbCBraWxkZVwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uUmdiVG9Ic3Y6IFwiUkdCIHRpbCBIU1ZcIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvbkhzdlRvUmdiOiBcIkhTViB0aWwgUkdCXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVJSFM6IFwiSUhTXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVCcm92ZXk6IFwiQnJvdmV5XCIsXG5cdFx0cGFuc2hhcnBlblR5cGVFc3JpOiBcIkVzcmlcIixcblx0XHRwYW5zaGFycGVuVHlwZU1lYW46IFwiTWlkZGVsXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVHcmFtU2NobWlkdDogXCJHcmFtLVNjaG1pZHRcIixcblx0XHRyZWN0YW5nbGVOZWlnaGJvcmhvb2Q6IFwiUmVrdGFuZ2VsXCIsXG5cdFx0Y2lyY2xlTmVpZ2hib3Job29kOiBcIkNpcmtlbFwiLFxuXHRcdGFubnVsdXNOZWlnaGJvcmhvb2Q6IFwiQW5udWx1c1wiLFxuXHRcdHdlZGdlTmVpZ2hib3Job29kOiBcIktpbGVcIixcblx0XHRpcnJlZ3VsYXJOZWlnaGJvcmhvb2Q6IFwiVXJlZ2VsbcOmc3NpZ1wiLFxuXHRcdHdlaWdodE5laWdoYm9yaG9vZDogXCJWw6ZndFwiLFxuXHRcdGZvdXI6IFwiRmlyZVwiLFxuXHRcdGVpZ2h0OiBcIk90dGVcIixcblx0XHR3aXRoaW46IFwiSW5kZW4gZm9yXCIsXG5cdFx0Y3Jvc3M6IFwiS3J5ZHNcIixcblx0XHRhZGRMaW5rOiBcIlRpbGbDuGogbGlua1wiLFxuXHRcdG5vTGluazogXCJJbnRldCBsaW5rXCIsXG5cdFx0d2VpZ2h0ZWRNZWFuOiBcIlbDpmd0ZXQgZ2VubmVtc25pdFwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNpcnJ1czogXCJMYW5kc2F0IDggY2lycnVzc2t5ZXJcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5DbG91ZDogXCJMYW5kc2F0IDggc2t5ZXJcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5DbG91ZFNoYWRvdzogXCJMYW5kc2F0IDggc2t5Z2dlIGZyYSBza3llclwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkRlc2lnbmF0ZWRGaWxsOiBcIkxhbmRzYXQgOCB1ZGZ5bGRuaW5nXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuRHJvcHBlZEZyYW1lOiBcIkxhbmRzYXQgOCB1bmRlcnRyeWt0IGJpbGxlZGVcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Tbm93SWNlOiBcIkxhbmRzYXQgOCBzbmUvaXNcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5UZXJyYWluT2NjbHVzaW9uOiBcIkxhbmRzYXQgOCB0ZXJyw6ZuLW9ra2x1c2lvblwiLFxuXHRcdGxzOFFDQml0UGF0dGVyblZlZ2V0YXRpb246IFwiTGFuZHNhdCA4IHZlZ2V0YXRpb25cIixcblx0XHRsczhRQ0JpdFBhdHRlcm5XYXRlcjogXCJMYW5kc2F0IDggdmFuZFwiLFxuXHRcdGRvd25TdHJlYW06IFwiTmVkc3Ryw7htc1wiLFxuXHRcdHVwU3RyZWFtOiBcIk9wc3Ryw7htc1wiLFxuXHRcdHN0cmFobGVyOiBcIlNUUkFITEVSXCIsXG5cdFx0c2hyZXZlOiBcIlNIUkVWRVwiLFxuXHRcdGN1cnJlbnRTbGljZTogXCJOdXbDpnJlbmRlIHVkc25pdFwiLFxuXHRcdGFsbFNsaWNlczogXCJBbGxlIHVkc25pdFwiLFxuXHRcdGV4cGFuZERpc3RhbmNlOiBcIkRJU1RBTkNFXCIsXG5cdFx0ZXhwYW5kTW9ycGhvbG9naWNhbDogXCJNT1JGT0xPR0lTS1wiLFxuXHRcdHNwZWN0cmFsUHJvZmlsZUZpbGU6IFwiU3Bla3RyYWwgcHJvZmlsXCIsXG5cdFx0dHJhaW5pbmdGZWF0dXJlRmlsZTogXCJUcsOmbmluZ3NmdW5rdGlvblwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVVbmlmb3JtOiBcIkVuc2FydGV0XCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVVuaWZvcm1JbnRlZ2VyOiBcIkhlbHRhbFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVOb3JtYWw6IFwiTm9ybWFsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUV4cG9uZW50aWFsOiBcIkVrc3BvbmVudGllbFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVQb2lzc29uOiBcIlBvaXNzb25cIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlR2FtbWE6IFwiR2FtbWFcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlQmlub21pYWw6IFwiQmlub21pc2tcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlR2VvbWV0cmljOiBcIkdlb21ldHJpc2tcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlTmVnYXRpdmVCaW5vbWlhbDogXCJOZWdhdGl2IGJpbm9taXNrXCIsXG5cdFx0cmFuZG9tR2VuZXJhdG9yVHlwZVN0YW5kYXJkQ1JhbmQ6IFwiU3RhbmRhcmQgQyBSYW5kXCIsXG5cdFx0cmFuZG9tR2VuZXJhdG9yVHlwZUFsZ29yaXRobUFDTTU5OTogXCJBQ00taW5kc2FtbGV0IGFsZ29yaXRtZSA1OTlcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlTWVyc2VubmVUd2lzdGVyOiBcIk1lcnNlbm5lIFR3aXN0ZXJcIixcblx0XHRzdW1OYW1lOiBcIlN1bVwiLFxuXHRcdG1lZGFpbk5hbWU6IFwiTWVkaWFuXCIsXG5cdFx0dHJlbmRMaW5lYXI6IFwiTGluZcOmclwiLFxuXHRcdHRyZW5kSGFybW9uaWM6IFwiSGFybW9uaXNrXCIsXG5cdFx0dHJlbmRQb2x5bm9taWFsOiBcIlBvbHlub21pYWxcIixcblx0XHR0cmVuZE1hbm5LZW5kYWxsOiBcIk1hbm4tS2VuZGFsbFwiLFxuXHRcdHRyZW5kU2Vhc29uYWxLZW5kYWxsOiBcIlPDpnNvbmJlc3RlbXQgS2VuZGFsbFwiLFxuXHRcdGRpbWVuc2lvbkJ5VmFsdWU6IFwiRWZ0ZXIgdsOmcmRpXCIsXG5cdFx0ZGltZW5zaW9uQnlJbnRlcnZhbDogXCJFZnRlciBpbnRlcnZhbFwiLFxuXHRcdG1kaW1EZWZUeXBlQWxsOiBcIkFsbGVcIixcblx0XHRtZGltRGVmVHlwZUJ5VmFsdWVzOiBcIkVmdGVyIHbDpnJkaWVyXCIsXG5cdFx0bWRpbURlZlR5cGVCeVJhbmdlczogXCJFZnRlciBvbXLDpWRlclwiLFxuXHRcdG1kaW1EZWZUeXBlQnlJdGVyYXRpb246IFwiRWZ0ZXIgZ2VudGFnZWxzZVwiLFxuXHRcdG1kaW1EZWZUeXBlQnlJbnRlcnZhbDogXCJFZnRlciBpbnRlcnZhbFwiLFxuXHRcdG1kaW1EZWZUeXBlQnlUYXJnZXRSYXN0ZXI6IFwiRWZ0ZXIgbcOlbC1yYXN0ZXJcIixcblx0XHRlc3JpVGltZVVuaXRzSG91cnM6IFwiVGltZXJcIixcblx0XHRlc3JpVGltZVVuaXRzRGF5czogXCJEYWdlXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1dlZWtzOiBcIlVnZXJcIixcblx0XHRlc3JpVGltZVVuaXRzTW9udGhzOiBcIk3DpW5lZGVyXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1llYXJzOiBcIsOFclwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkSG91cmx5OiBcIkh2ZXIgdGltZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkRGFpbHk6IFwiSHZlciBkYWdcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFdlZWtseTogXCJIdmVyIHVnZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkRGVrYWRseTogXCJIdmVydCB0aWVuZGUgw6VyXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRQZW50YWRseTogXCJIdmVydCBmZW10ZSDDpXJcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZE1vbnRobHk6IFwiSHZlciBtw6VuZWRcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFF1YXJ0ZXJseTogXCJIdmVyIGt2YXJ0YWxcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFllYXJseTogXCLDhXJsaWd0XCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdEYWlseTogXCJEYWdsaWd0IHRpbGJhZ2V2ZW5kZW5kZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nV2Vla2x5OiBcIlVnZW50bGlndCB0aWxiYWdldmVuZGVuZGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ01vbnRobHk6IFwiTcOlbmVkbGlndCB0aWxiYWdldmVuZGVuZGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1F1YXJ0ZXJseTogXCJLdmFydGFsc3Zpc3QgdGlsYmFnZXZlbmRlbmRlXCIsXG5cdFx0YWdnRGVmVHlwZUFsbDogXCJBbGxlXCIsXG5cdFx0YWdnRGVmVHlwZUludGVydmFsS2V5d29yZDogXCJJbnRlcnZhbC1uw7hnbGVvcmRcIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxWYWx1ZTogXCJJbnRlcnZhbC12w6ZyZGlcIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxSYW5nZXM6IFwiSW50ZXJ2YWwtb21yw6VkZVwiLFxuXHRcdGxhdGVzdENoYW5nZTogXCJUaWQgZm9yIHNlbmVzdGUgw6ZuZHJpbmdcIixcblx0XHRlYXJsaWVzdENoYW5nZTogXCJUaWQgZm9yIHRpZGxpZ3N0ZSDDpm5kcmluZ1wiLFxuXHRcdGxhcmdlc3RDaGFuZ2U6IFwiVGlkIGZvciBzdMO4cnN0ZSDDpm5kcmluZ1wiLFxuXHRcdG51bWJlck9mQ2hhbmdlczogXCJBbnRhbCDDpm5kcmluZ2VyXCIsXG5cdFx0bG9uZ2VzdENoYW5nZTogXCJUaWQgZm9yIGzDpm5nc3RlIMOmbmRyaW5nXCIsXG5cdFx0c2hvcnRlc3RDaGFuZ2U6IFwiVGlkIGZvciBrb3J0ZXN0ZSDDpm5kcmluZ1wiLFxuXHRcdGZhc3Rlc3RDaGFuZ2U6IFwiVGlkIGZvciBodXJ0aWdzdGUgw6ZuZHJpbmdcIixcblx0XHRzbG93ZXN0Q2hhbmdlOiBcIlRpZCBmb3IgbGFuZ3NvbXN0ZSDDpm5kcmluZ1wiLFxuXHRcdGFsbENoYW5nZXM6IFwiQWxsZVwiLFxuXHRcdGluY3JlYXNlQ2hhbmdlczogXCLDmGdcIixcblx0XHRkZWNyZWFzZUNoYW5nZXM6IFwiRm9ybWluZHNrXCIsXG5cdFx0c2VnbWVudEJlZ2lubmluZzogXCJTdGFydCBww6Ugc2VnbWVudFwiLFxuXHRcdHNlZ21lbnRFbmQ6IFwiU2x1dG5pbmcgcMOlIHNlZ21lbnRcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZERpZmZlcmVuY2U6IFwiRm9yc2tlbFwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kUmVsYXRpdmVEaWZmZXJlbmNlOiBcIlJlbGF0aXYgZm9yc2tlbFwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kQ2F0ZWdvcmljYWw6IFwiS2F0ZWdvcmlzayBmb3Jza2VsXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RNdWx0aXNwZWN0cmFsRXVjbGlkZWFuRGlzdGFuY2U6IFwiU3Bla3RyYWwgZXVrbGlkaXNrIGFmc3RhbmRcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBbmd1bGFyRGlmZmVyZW5jZTogXCJTcGVrdHJhbCB2aW5rZWxmb3Jza2VsXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RNdWx0aXNwZWN0cmFsQXhpc1dpdGhCaWdnZXN0Q2hhbmdlOiBcIkLDpW5kIG1lZCBtZXN0IMOmbmRyaW5nXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwQWxsOiBcIkJldmFyIGFsbGVcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBDaGFuZ2VkT25seTogXCJCZXZhciBrdW4gw6ZuZHJlZGUgcGl4ZWxzXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwVW5jaGFuZ2VkT25seTogXCJCZXZhciBrdW4gdcOmbmRyZWRlIHBpeGVsc1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JBdmVyYWdlOiBcIkdlbm5lbXNuaXQgZnJhIG9nIHRpbCBmYXJ2ZXJcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yRnJvbTogXCJBbnZlbmQgZnJhIGZhcnZlclwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JUbzogXCJBbnZlbmQgdGlsIGZhcnZlclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQmluYXJ5OiBcIkJpbsOmclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uRm9yd2FyZDogXCJGcmVtXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25MaW5lYXI6IFwiTGluZcOmclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSW52TGluZWFyOiBcIk9tdmVuZHQgbGluZcOmclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uVGFibGU6IFwiVGFiZWxcIixcblx0XHRmYWN0b3JGdW5jdGlvblN5bUxpbmVhcjogXCJTeW1ldHJpc2sgbGluZcOmclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU3ltSW52TGluZWFyOiBcIlN5bW1ldHJpc2sgb212ZW5kdCBsaW5lw6ZyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3M6IFwiQ29zaW51c1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2VjOiBcIlNla2FudFwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zU2VjOiBcIkNvc2ludXMgc2VrYW50XCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWNDb3M6IFwiU2VrYW50IENvc2ludXNcIixcblx0XHRub1NvcnQ6IFwiU29ydMOpciBpa2tlXCIsXG5cdFx0YXNjZW5kOiBcIlN0aWdlbmRlXCIsXG5cdFx0ZGVzY2VuZDogXCJGYWxkZW5kZVwiLFxuXHRcdGF1dG9EZXRlY3Q6IFwiQXV0by1yZWdpc3RyZXJpbmdcIixcblx0XHRuZWFyZXN0OiBcIk7DpnJtZXN0XCIsXG5cdFx0bGluZWFyOiBcIkxpbmXDpnJcIixcblx0XHRlc3JpTW9udGhKYW51YXJ5OiBcIkphbnVhclwiLFxuXHRcdGVzcmlNb250aEZlYnJ1YXJ5OiBcIkZlYnJ1YXJcIixcblx0XHRlc3JpTW9udGhNYXJjaDogXCJNYXJ0c1wiLFxuXHRcdGVzcmlNb250aEFwcmlsOiBcIkFwcmlsXCIsXG5cdFx0ZXNyaU1vbnRoTWF5OiBcIk1halwiLFxuXHRcdGVzcmlNb250aEp1bmU6IFwiSnVuaVwiLFxuXHRcdGVzcmlNb250aEp1bHk6IFwiSnVsaVwiLFxuXHRcdGVzcmlNb250aEF1Z3VzdDogXCJBdWd1c3RcIixcblx0XHRlc3JpTW9udGhTZXB0ZW1iZXI6IFwiU2VwdGVtYmVyXCIsXG5cdFx0ZXNyaU1vbnRoT2N0b2JlcjogXCJPa3RvYmVyXCIsXG5cdFx0ZXNyaU1vbnRoTm92ZW1iZXI6IFwiTm92ZW1iZXJcIixcblx0XHRlc3JpTW9udGhEZWNlbWJlcjogXCJEZWNlbWJlclwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nSWdub3JlTm9EYXRhOiBcIkRhdGFcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1Byb3BhZ2F0ZU5vRGF0YTogXCJOb0RhdGFcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ0ZpbGxPbmx5Tm9EYXRhOiBcIlVkZnlsZCBOb0RhdGFcIixcblx0XHRjaXJjdWxhck1lYW46IFwiQ2lya3Vsw6ZyIG1pZGRlbHbDpnJkaVwiLFxuXHRcdGNpcmN1bGFyTmFtZTogXCJDaXJrdWzDpnJcIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0bWV0aXNrXCIsXG5cdFx0c2xvcGVOYW1lOiBcIlN0aWduaW5nXCIsXG5cdFx0YXNwZWN0TmFtZTogXCJBc3Bla3RcIixcblx0XHRtZWFuQ3VydmF0dXJlOiBcIk1pZGRlbGtydW1uaW5nXCIsXG5cdFx0cHJvZmlsZUN1cnZhdHVyZTogXCJQcm9maWxrcnVtbmluZyAobm9ybWFsIHN0aWduaW5nc2xpbmplKVwiLFxuXHRcdHRhbmdlbnRpYWxDdXJ2YXR1cmU6IFwiVGFuZ2VudGlhbCBrcnVtbmluZyAobm9ybWFsIGtvbnR1cilcIixcblx0XHRwbGFuQ3VydmF0dXJlOiBcIlBsYW5rcnVtbmluZyAocHJvamljZXJldCBrb250dXIpXCIsXG5cdFx0Y29udG91ckdlb2Rlc2ljVG9yc2lvbjogXCJLb250dXIg4oCTIGdlb2TDpnRpc2sgdnJpZG5pbmdcIixcblx0XHRnYXVzc2lhbkN1cnZhdHVyZTogXCJHYXVzc2lzayBrcnVtbmluZ1wiLFxuXHRcdGNhc29yYXRpQ3VydmF0dXJlOiBcIkNhc29yYXRpc2sga3J1bW5pbmdcIixcblx0XHRsb2NhbFN1cmZhY2VUeXBlUXVhZHJhdGljOiBcImt2YWRyYXRpc2tcIixcblx0XHRsb2NhbFN1cmZhY2VUeXBlQmlxdWFkcmF0aWM6IFwiQmlrdmFkcmF0aXNrXCIsXG5cdFx0dGhyZXNob2xkTm9UaHJlc2hvbGQ6IFwiSW5nZW4gdMOmcnNrZWxcIixcblx0XHR0aHJlc2hvbGRQZXJjZW50TGVhc3RDb3N0OiBcIlByb2NlbnQgZm9yIGxhdmVzdGUgb21rb3N0bmluZ1wiLFxuXHRcdHRocmVzaG9sZEFjY3VtdWxhdGl2ZUNvc3Q6IFwiQWtrdW11bGVyZXQgb21rb3N0bmluZ1wiLFxuXHRcdGNscm1hcFR5cGVIaWxsc2hhZGU6IFwiU2t5Z2dldmlya25pbmdcIlxuXHR9LFxuXHRjYXRlZ29yeUxhYmVsczoge1xuXHRcdHNvdXJjZUNoYXJhY3RlcmlzdGljczogXCJLaWxkZWVnZW5za2FiZXJcIixcblx0XHRuZWlnaGJvcmhvb2RTZXR0aW5nczogXCJOYWJvaW5kc3RpbGxpbmdlclwiLFxuXHRcdHN0YXRpc3RpY3M6IFwiU3RhdGlzdGlrXCIsXG5cdFx0Z2FtbWE6IFwiR2FtbWFcIixcblx0XHR2aWV3c2hlZFBhcmFtZXRlcnM6IFwiUGFyYW1ldHJlIGZvciB1ZHNpZ3Rzb21yw6VkZVwiLFxuXHRcdG9ic2VydmVyUGFyYW1ldGVyczogXCJQYXJhbWV0cmUgZm9yIG9ic2VydmF0aW9uXCIsXG5cdFx0aXJyZWd1bGFyRGF0YUludGVycG9sYXRpb246IFwiVXJlZ2VsbcOmc3NpZyBkYXRhaW50ZXJwb2xhdGlvblwiLFxuXHRcdG1vZGVsU3RhdGlzdGljczogXCJNb2RlbHN0YXRpc3Rpa1wiLFxuXHRcdGFnZ3JlZ2F0aW9uRGVmOiBcIkFnZ3JlZ2VyaW5nc2RlZmluaXRpb25cIixcblx0XHRmaWx0ZXJCeUF0dHJpYnV0ZXM6IFwiRmlsdHLDqXIgZWZ0ZXIgYXR0cmlidXR0ZXJcIixcblx0XHRwZXJjZW50aWxlTmFtZTogXCJQZXJjZW50aWxcIixcblx0XHRyYXN0ZXJJbmZvOiBcIlJhc3Rlb3BseXNuaW5nZXJcIixcblx0XHRleHRlbnQ6IFwiVWRzdHLDpmtuaW5nXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZTogXCJTcGF0aWFsIHJlZmVyZW5jZVwiXG5cdH0sXG5cdG91dHB1dFJhc3RlckhlbHBUZXh0czoge1xuXHRcdG91dHB1dE5hbWU6IFwiPHA+TmF2bmV0IHDDpSBkZXQsIGRlciBvcHJldHRlcyBvZyBmw7hqZXMgdGlsIGtvcnRldC48L3A+XCIsXG5cdFx0cmVzdWx0VHlwZTogXCI8cD5EZW4gdHlwZSBvdXRwdXQsIGRlciBvcHJldHRlcy4gT3V0cHV0dGVuZSBrYW4gdsOmcmUgdGlsZS1iaWxsZWRsYWcgZWxsZXIgZHluYW1pc2tlIGJpbGxlZGxhZy48L3A+XCIsXG5cdFx0c2F2ZVJlc3VsdEluOiBcIjxwPk5hdm5ldCBww6UgbWFwcGVuIDxiPk1pdCBpbmRob2xkPC9iPiwgaHZvciByZXN1bHRhdGV0IGdlbW1lcy48L3A+XCJcblx0fSxcblx0YW5hbHlzaXNFbnZpcm9ubWVudHNIZWxwVGV4dHM6IHtcblx0XHRkZXNjcmlwdGlvbjogXCI8cD5NaWxqw7hpbmRzdGlsbGluZ2VyIGZvciBhbmFseXNlIGkgTWFwIFZpZXdlci4gPC9wPlwiLFxuXHRcdG91dFNSOiBcIjxwPkFuZ2l2ZXIga29vcmRpbmF0c3lzdGVtZXQgZm9yIGFuYWx5c2Ugb2cgcmVzdWx0YXRsYWdldC48L3A+XCIsXG5cdFx0ZXh0ZW50OiBcIjxwPkFuZ2l2ZXIgZGV0IG9tcsOlZGUsIGRlciBza2FsIGFudmVuZGVzIHRpbCBhbmFseXNlLjwvcD5cIixcblx0XHRzbmFwUmFzdGVyOiBcIjxwPkp1c3RlcmVyIHVkc3Ryw6ZrbmluZ2VuIGZvciBvdXRwdXR0ZXQsIHPDpSBkZXQgcGFzc2VyIHRpbCBjZWxsZWp1c3RlcmluZ2VuIGZvciBkZXQgYW5naXZuZSBzbmFwLXJhc3Rlci1sYWcuPC9wPlwiLFxuXHRcdGNlbGxTaXplOiBcIjxwPkFuZ2l2ZXIgZGVuIGNlbGxlc3TDuHJyZWxzZSBlbGxlciBvcGzDuHNuaW5nLCBzb20gc2thbCBicnVnZXMgdGlsIGFuYWx5c2Ugb2cgdGlsIGF0IG9wcmV0dGUgb3V0cHV0cmFzdGVybGFnZXQuPC9wPlwiLFxuXHRcdG1hc2s6IFwiPHA+QW5naXZlciBldCBtYXNrZWxhZywgaHZvciBrdW4gZGUgY2VsbGVyLCBkZXIgZmFsZGVyIGluZGVuIGZvciBtYXNrZW9tcsOlZGV0LCB2aWwgYmxpdmUgYnJ1Z3QgdGlsIGFuYWx5c2UuPC9wPlwiLFxuXHRcdHJlc2FtcGxpbmdNZXRob2Q6IFwiPHA+QW5naXZlciwgaHZvcmRhbiBwaXhlbHbDpnJkaWVybmUgc2thbCBpbnRlcnBvbGVyZXMsIG7DpXIgaW5wdXQtIG9nIG91dHB1dHJhc3RlciBpa2tlIHN0ZW1tZXIgb3ZlcmVucy48L3A+XCJcblx0fSxcblx0bWFpbkdlblN0cmluZ3M6IHtcblx0XHR1bnN1cHBvcnRlZERhdGFUeXBlOiBcIklra2UtdW5kZXJzdMO4dHRldCB0eXBlXCIsXG5cdFx0Y3VycmVudGx5VW5zdXBwb3J0ZWQ6IFwiIEVuIHN0YW5kYXJkIGVkaXRvciB0aWwgJHttaXNzaW5nVHlwZX0ga29tbWVyIHNuYXJ0LiBNaWRsZXJ0aWRpZyBwbGFkc2hvbGRlci10ZWtzdGJva3MgdGlsIGFuZ2l2ZWxzZSBhZiBzdHJlbmdiYXNlcmV0IGlucHV0XCIsXG5cdFx0dW5zdXBwb3J0ZWRPdmVycmlkZVdhcm5pbmc6IFwiRW4gdGlsc2lkZXPDpnQgZWRpdG9yLWtvbXBvbmVudCwgZGVyIGdpdmVyIGVuIGJlZHJlIFVYIHZlZCBhcmJlamRlIG1lZCBmw7hsZ2VuZGUgcGFyYW1ldHJlLCBrb21tZXIgc25hcnQ6XCIsXG5cdFx0b3ZlcnJpZGVXaWRnZXRNaXNzaW5nOiBcIlRpbHNpZGVzw6Z0IGVkaXRvci1rb21wb25lbnQgbWFuZ2xlciFcIixcblx0XHR1aUluY29tcGxldGU6IFwiSm9iYWZzZW5kZWxzZSBtaXNseWtrZWRlcy4gRnVua3Rpb25lbiBrYW4gaWtrZSBrw7hyZSwgZm9yZGkgbm9nbGUgYWYgZGUga3LDpnZlZGUgZmVsdGVyIGVyIHVmdWxkc3TDpm5kaWdlIGVsbGVyIG1hbmdsZXIgaSBVSS5cIixcblx0XHRjb3VudDogXCJUw6ZsbGluZ1wiLFxuXHRcdHNlbGVjdFZhcmlhYmxlczogXCJWw6ZsZyB2YXJpYWJsZXJcIixcblx0XHRzZWxlY3RGZWF0dXJlOiBcIlbDpmxnIG9iamVrdGxhZ1wiLFxuXHRcdGdyZWF0ZXJUaGFuRXJyb3JNZXNzYWdlOiBcIklucHV0LXRhbGxldCBza2FsIHbDpnJlIHN0w7hycmUgZW5kICR7bWlufVwiLFxuXHRcdGxlc3NlclRoYW5FcnJvck1lc3NhZ2U6IFwiSW5wdXQtdGFsbGV0IHNrYWwgdsOmcmUgbWluZHJlIGVuZCAke21heH1cIixcblx0XHRncmVhdGVyVGhhbk9yRXF1YWxFcnJvck1lc3NhZ2U6IFwiSW5wdXQtdGFsbGV0IHNrYWwgdsOmcmUgc3TDuHJyZSBlbmQgZWxsZXIgbGlnIG1lZCAke21pbn1cIixcblx0XHRsZXNzZXJUaGFuT3JFcXVhbEVycm9yTWVzc2FnZTogXCJJbnB1dC10YWxsZXQgc2thbCB2w6ZyZSBtaW5kcmUgZW5kIGVsbGVyIGxpZyBtZWQgJHttYXh9XCIsXG5cdFx0YWxsb3dTY2FsYXI6IFwiVsOmbGcgZXQgbGFnLCBlbGxlciBhbmdpdiBlbiBrb25zdGFudFwiLFxuXHRcdHNlbGVjdEZpZWxkOiBcIlbDpmxnIGZlbHRcIixcblx0XHRwYXJhbWV0ZXJSZXF1aXJlZDogXCJEZW5uZSBwYXJhbWV0ZXIgZXIgcMOla3LDpnZldC5cIixcblx0XHRlbnRlckFWYWx1ZTogXCJBbmdpdiBlbiB2w6ZyZGkuLi5cIixcblx0XHRpbnZhbGlkSW5wdXQ6IFwiRGVuIGFuZ2l2bmUgdsOmcmRpIGVyIGlra2UgZ3lsZGlnLlwiLFxuXHRcdGl0ZW1Ob3RGb3VuZDogXCJFbGVtZW50ZXQgZWtzaXN0ZXJlciBpa2tlIGVsbGVyIGVyIGlra2UgdGlsZ8OmbmdlbGlndC5cIixcblx0XHRpdGVtUGVybWlzc2lvbkRlbmllZDogXCJEdSBoYXIgaWtrZSBhZGdhbmdzcmV0dGlnaGVkZXIgdGlsIGRldHRlIGVsZW1lbnQuXCIsXG5cdFx0bGF5ZXJOb3RBdmFpbGFibGU6IFwiS2FuIGlra2UgaW5kbMOmc2UgbGFnICR7bGF5ZXJOYW1lfS5cIixcblx0XHRtdWx0aXBsZUxheWVyc05vdEF2YWlsYWJsZTogXCJLYW4gaWtrZSBpbmRsw6ZzZSBsYWcgJHtsYXllck5hbWV9IG9nIGFuZGV0LlwiLFxuXHRcdGxlYXJuTW9yZUxhYmVsOiBcIkbDpSBtZXJlIGF0IHZpZGVcIixcblx0XHRmaWVsZE5vdEF2YWlsYWJsZTogXCJLdW5uZSBpa2tlIGluZGzDpnNlIGZlbHQuXCIsXG5cdFx0YWxsb3dBbmFseXNpczogXCJBbmFseXNlIGVyIGlra2UgdGlsbGFkdCBpIGJpbGxlZHRqZW5lc3Rlbi5cIixcblx0XHRhbGxvd0FuYWx5c2lzUmVhc29uOiBcIkV0IGVsbGVyIGZsZXJlIGxhZyBmcmEgZGV0dGUga29ydCBlciBpa2tlIGFuZ2l2ZXQgaGVyLCBmb3JkaSBkZSBpa2tlIHRpbGxhZGVyIGFuYWx5c2UuXCIsXG5cdFx0bGVhcm5Nb3JlVGV4dDogXCJGw6UgbWVyZSBhdCB2aWRlXCIsXG5cdFx0YXRMZWFzdE9uZVJhc3RlcklucHV0OiBcIk1pbmRzdCDDqXQgaW5wdXRsYWcgc2thbCB2w6ZyZSBldCByYXN0ZXJsYWcuXCIsXG5cdFx0YnJvd3NlQW5hbHlzaXNMYXllcnM6IFwiR2VubmVtc2UgbGFnXCIsXG5cdFx0YWN0aXZlTWFwVmlld0V4dGVudDogXCJCcnVnIGFrdHVlbCBrb3J0dWRzdHLDpmtuaW5nXCIsXG5cdFx0Y2hvb3NlUmFzdGVyOiBcIlbDpmxnIGtsaXAtcmFzdGVyXCIsXG5cdFx0Y2hvb3NlR2VvbWV0cnk6IFwiVsOmbGcga2xpcC1nZW9tZXRyaVwiLFxuXHRcdHJlc3VsdFR5cGU6IFwiUmVzdWx0YXR0eXBlXCIsXG5cdFx0c2F2ZUluRm9sZGVyOiBcIkdlbSBpIG1hcHBlXCIsXG5cdFx0b3V0cHV0TmFtZTogXCJPdXRwdXRuYXZuXCIsXG5cdFx0b3V0cHV0TGF5ZXJUeXBlOiBcIk91dHB1dGxhZ3R5cGVcIixcblx0XHRkeW5hbWljSW1hZ2VyeUxheWVyOiBcIkR5bmFtaXNrIGJpbGxlZGxhZ1wiLFxuXHRcdHRpbGVkSW1hZ2VyeUxheWVyOiBcIlRpbGUtYmlsbGVkbGFnXCIsXG5cdFx0Y3VzdG9tOiBcIkJydWdlcmRlZmluZXJldFwiLFxuXHRcdGxvYWRpbmc6IFwiSW5kbMOmc2VyLi4uXCIsXG5cdFx0bGF5ZXJNaXNzaW5nOiBcIkV0IGVsbGVyIGZsZXJlIGxhZyBmcmEgZGV0dGUga29ydCBlciBpa2tlIGFuZ2l2ZXQgaGVyLCBmb3JkaSBkZSBpa2tlIHRpbGxhZGVyIGFuYWx5c2UuIEzDpnIgbWVyZS5cIixcblx0XHRicm93c2VDb29yZGluYXRlU3lzdGVtczogXCJHZW5uZW1zZSBrb29yZGluYXRzeXN0ZW1lclwiLFxuXHRcdHVuYWJsZVRvUmVwb3B1bGF0ZU91dFNSOiBcIkthbiBpa2tlIHVkZnlsZGUgb3V0cHV0LWtvb3JkaW5hdHN5c3RlbS5cIixcblx0XHRkZWZhdWx0VGl0bGU6IFwiU2UgbWVyZVwiLFxuXHRcdFwiQVJDIChlcXVhbCBhcmMtc2Vjb25kKVwiOiBcIkFSQyAobGlnZSBidWVzZWt1bmQpXCIsXG5cdFx0QWZyaWNhOiBcIkFmcmlrYVwiLFxuXHRcdEFudGFyY3RpY2E6IFwiQW50YXJrdGlzXCIsXG5cdFx0QXJnZW50aW5hOiBcIkFyZ2VudGluYVwiLFxuXHRcdEFzaWE6IFwiQXNpZW5cIixcblx0XHRcIkFzdGVyb2lkIEJlbHRcIjogXCJBc3Rlcm9pZGViw6ZsdGV0XCIsXG5cdFx0XCJBdGxhbnRpYyBPY2VhblwiOiBcIkF0bGFudGVyaGF2ZXRcIixcblx0XHRBdXN0cmFsaWE6IFwiQXVzdHJhbGllblwiLFxuXHRcdFwiQXVzdHJhbGlhIGFuZCBOZXcgWmVhbGFuZFwiOiBcIkF1c3RyYWxpZW4gb2cgTmV3IFplYWxhbmRcIixcblx0XHRBdXN0cmlhOiBcIsOYc3RyaWdcIixcblx0XHRcIkJMTSAoVVMgRmVldClcIjogXCJCTE0gKGFtZXJpa2Fuc2tlIGZvZClcIixcblx0XHRCYW5nbGFkZXNoOiBcIkJhbmdsYWRlc2hcIixcblx0XHRcIkJlaWppbmcgMTk1NFwiOiBcIkJlaWppbmcgMTk1NFwiLFxuXHRcdEJodXRhbjogXCJCaHV0YW5cIixcblx0XHRDR0NTMjAwMDogXCJDR0NTMjAwMFwiLFxuXHRcdENhbmFkYTogXCJDYW5hZGFcIixcblx0XHRDYXJpYmJlYW46IFwiQ2FyaWJpZW5cIixcblx0XHRcIkNhcmliYmVhbiBTZWFcIjogXCJEZXQgQ2FyaWJpc2tlIEhhdlwiLFxuXHRcdFwiQ2VudHJhbCBBbWVyaWNhXCI6IFwiQ2VudHJhbGFtZXJpa2FcIixcblx0XHRcIkNlbnRyYWwgYW5kIE5vcnRoIEFtZXJpY2FcIjogXCJDZW50cmFsLSBvZyBOb3JkYW1lcmlrYVwiLFxuXHRcdENvbG9tYmlhOiBcIkNvbG9tYmlhXCIsXG5cdFx0Q29udGluZW50YWw6IFwiS29udGluZW50YWxcIixcblx0XHRcIkNvdW50eSBTeXN0ZW1zXCI6IFwiQW10c3lzdGVtZXJcIixcblx0XHRcIkRlbW9jcmF0aWMgUmVwdWJsaWMgb2YgdGhlIENvbmdvXCI6IFwiRGVtb2tyYXRpc2tlIFJlcHVibGlrIENvbmdvXCIsXG5cdFx0XCJFUFNHIEFyY3RpY1wiOiBcIkVQU0cg4oCTIGFya3Rpc2tcIixcblx0XHRFYXJ0aDogXCJKb3JkZW5cIixcblx0XHRcIkVsbGlwc29pZGFsLWJhc2VkXCI6IFwiRWxsaXBzb2lkZS1iYXNlcmV0XCIsXG5cdFx0RXVyb3BlOiBcIkV1cm9wYVwiLFxuXHRcdEZpbmxhbmQ6IFwiRmlubGFuZFwiLFxuXHRcdEZyYW5jZTogXCJGcmFua3JpZ1wiLFxuXHRcdFwiR1NLIDIwMTFcIjogXCJHU0sgMjAxMVwiLFxuXHRcdFwiR2F1c3MgS3J1Z2VyXCI6IFwiR2F1c3MgS3J1Z2VyXCIsXG5cdFx0XCJHZW9ncmFwaGljIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIkdlb2dyYWZpc2tlIGtvb3JkaW5hdHN5c3RlbWVyXCIsXG5cdFx0R2VybWFueTogXCJUeXNrbGFuZFwiLFxuXHRcdFwiR3Jhdml0eS1yZWxhdGVkXCI6IFwiVHluZ2Rla3JhZnRyZWxhdGVyZXRcIixcblx0XHRcIkdyZWVud2ljaC1iYXNlZFwiOiBcIkdyZWVud2ljaC1iYXNlcmV0XCIsXG5cdFx0XCJIaWdod2F5cyBFbmdsYW5kXCI6IFwiTW90b3J2ZWplIOKAkyBFbmdsYW5kXCIsXG5cdFx0SWxsaW5vaXM6IFwiSWxsaW5vaXNcIixcblx0XHRcIkluZGlhbiBPY2VhblwiOiBcIkRldCBJbmRpc2tlIE9jZWFuXCIsXG5cdFx0XCJJbmRpYW4gU3ViY29udGluZW50XCI6IFwiRGV0IEluZGlza2UgU3Via29udGluZW50XCIsXG5cdFx0SW5kaWFuYTogXCJJbmRpYW5hXCIsXG5cdFx0SW5kb25lc2lhOiBcIkluZG9uZXNpZW5cIixcblx0XHRJb3dhOiBcIklvd2FcIixcblx0XHRcIklyZWxhbmQgYW5kIFVuaXRlZCBLaW5nZG9tXCI6IFwiSXJsYW5kIG9nIFN0b3Jicml0YW5uaWVuXCIsXG5cdFx0SXRhbHk6IFwiSXRhbGllblwiLFxuXHRcdEphcGFuOiBcIkphcGFuXCIsXG5cdFx0SnVwaXRlcjogXCJKdXBpdGVyXCIsXG5cdFx0S2Fuc2FzOiBcIkthbnNhc1wiLFxuXHRcdFwiTGFzIFZlZ2FzXCI6IFwiTGFzIFZlZ2FzXCIsXG5cdFx0TGlieWE6IFwiTGlieWVuXCIsXG5cdFx0TWFsYXlzaWE6IFwiTWFsYXlzaWFcIixcblx0XHRcIk1hbGF5c2lhIGFuZCBTaW5nYXBvcmVcIjogXCJNYWxheXNpYSBvZyBTaW5nYXBvcmVcIixcblx0XHRNYXJzOiBcIk1hcnNcIixcblx0XHRNZXJjdXJ5OiBcIk1lcmt1clwiLFxuXHRcdE1pbm5lc290YTogXCJNaW5uZXNvdGFcIixcblx0XHRNb250YW5hOiBcIk1vbnRhbmFcIixcblx0XHRcIk5BRCAxOTI3XCI6IFwiTkFEIDE5MjdcIixcblx0XHRcIk5BRCAxOTI3IChVUyBGZWV0KVwiOiBcIk5BRCAxOTI3IChhbWVyaWthbnNrZSBmb2QpXCIsXG5cdFx0XCJOQUQgMTk4M1wiOiBcIk5BRCAxOTgzXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSlcIjogXCJOQUQgMTk4MyAoMjAxMSlcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzICgyMDExKSAoaW50ZXJuYXRpb25hbGUgZm9kKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKDIwMTEpIChtZXRlcilcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoMjAxMSkgKGFtZXJpa2Fuc2tlIGZvZClcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKGludGVybmF0aW9uYWxlIGZvZClcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKG1ldGVyKVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKGFtZXJpa2Fuc2tlIGZvZClcIixcblx0XHRcIk5BRCAxOTgzIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKGludGVybmF0aW9uYWxlIGZvZClcIixcblx0XHRcIk5BRCAxOTgzIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKG1ldGVyKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKFBBMTEpIChtZXRlcilcIixcblx0XHRcIk5BRCAxOTgzIChQQTExKSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoUEExMSkgKGFtZXJpa2Fuc2tlIGZvZClcIixcblx0XHRcIk5BRCAxOTgzIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChhbWVyaWthbnNrZSBmb2QpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgSEFSTiAoaW50ZXJuYXRpb25hbGUgZm9kKVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIEhBUk4gKG1ldGVyKVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoVVMgRmVldClcIjogXCJOQUQgMTk4MyBIQVJOIChhbWVyaWthbnNrZSBmb2QpXCIsXG5cdFx0XCJOQUQgMTk4MyBOU1JTMjAwNyAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzIE5TUlMyMDA3IChpbnRlcm5hdGlvbmFsZSBmb2QpXCIsXG5cdFx0XCJOQUQgMTk4MyBOU1JTMjAwNyAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIE5TUlMyMDA3IChtZXRlcilcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIE5TUlMyMDA3IChpbnRlcm5hdGlvbmFsZSBmb2QpXCIsXG5cdFx0XCJOYXRpb25hbCBHcmlkc1wiOiBcIk5hdGlvbmFsZSBnaXRyZVwiLFxuXHRcdE5hdmFqbzogXCJOYXZham9cIixcblx0XHROZXB0dW5lOiBcIk5lcHR1blwiLFxuXHRcdFwiTmV3IEJlaWppbmdcIjogXCJOeXQgQmVpamluZ1wiLFxuXHRcdFwiTmV3IFplYWxhbmRcIjogXCJOZXcgWmVhbGFuZFwiLFxuXHRcdFwiTm9ydGggQW1lcmljYVwiOiBcIk5vcmRhbWVyaWthXCIsXG5cdFx0XCJOb3J0aGVybiBIZW1pc3BoZXJlXCI6IFwiTm9yZGxpZyBoYWx2a3VnbGVcIixcblx0XHROb3J3YXk6IFwiTm9yZ2VcIixcblx0XHRPY2VhbnM6IFwiT2NlYW5lclwiLFxuXHRcdE9yZWdvbjogXCJPcmVnb25cIixcblx0XHRcIk90aGVyIEdDU1wiOiBcIkFuZGV0IEdDU1wiLFxuXHRcdFwiUGFjaWZpYyBPY2VhblwiOiBcIlN0aWxsZWhhdmV0XCIsXG5cdFx0UGx1dG86IFwiUGx1dG9cIixcblx0XHRQb2xhcjogXCJQb2xhclwiLFxuXHRcdFBvcnR1Z2FsOiBcIlBvcnR1Z2FsXCIsXG5cdFx0XCJQcm9qZWN0ZWQgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiRm9ydWRiZXJlZ25lZGUga29vcmRpbmF0c3lzdGVtZXJcIixcblx0XHRcIlB1bGtvdm8gMTk0MlwiOiBcIlB1bGtvdm8gMTk0MlwiLFxuXHRcdFwiUHVsa292byAxOTk1XCI6IFwiUHVsa292byAxOTk1XCIsXG5cdFx0UmVwbGFjZWQ6IFwiRXJzdGF0dGV0XCIsXG5cdFx0XCJTQUQgMTk2OVwiOiBcIlNBRCAxOTY5XCIsXG5cdFx0U0lSR0FTOiBcIlNJUkdBU1wiLFxuXHRcdFwiU0lSR0FTIDIwMDBcIjogXCJTSVJHQVMgMjAwMFwiLFxuXHRcdFNhdHVybjogXCJTYXR1cm5cIixcblx0XHRcIlNvbGFyIFN5c3RlbVwiOiBcIlNvbHN5c3RlbWV0XCIsXG5cdFx0XCJTb3V0aCBBZnJpY2FcIjogXCJTeWRhZnJpa2FcIixcblx0XHRcIlNvdXRoIEFtZXJpY2FcIjogXCJTeWRhbWVyaWthXCIsXG5cdFx0XCJTb3V0aCBLb3JlYVwiOiBcIlN5ZGtvcmVhXCIsXG5cdFx0XCJTb3V0aGVybiBIZW1pc3BoZXJlXCI6IFwiU3lkbGlnIGhhbHZrdWdsZVwiLFxuXHRcdFwiU3BoZXJvaWQtYmFzZWRcIjogXCJTZsOmcm9pZC1iYXNlcmV0XCIsXG5cdFx0XCJTdGF0ZSBQbGFuZVwiOiBcIkRlbHN0YXRzcGxhblwiLFxuXHRcdFwiU3RhdGUgU3lzdGVtc1wiOiBcIkRlbHN0YXRzc3lzdGVtZXJcIixcblx0XHRTd2VkZW46IFwiU3ZlcmlnZVwiLFxuXHRcdFwiU3dpdHplcmxhbmQgYW5kIExpZWNodGVuc3RlaW5cIjogXCJTY2h3ZWl6IG9nIExpZWNodGVuc3RlaW5cIixcblx0XHRUZXhhczogXCJUZXhhc1wiLFxuXHRcdFRyaWJhbDogXCJTdGFtbWVyZWxhdGVyZXRcIixcblx0XHRUdXJrZXk6IFwiVHlya2lldFwiLFxuXHRcdFwiVVMgRmVldFwiOiBcIkFtZXJpa2Fuc2tlIGZvZFwiLFxuXHRcdFwiVVNBIGFuZCB0ZXJyaXRvcmllc1wiOiBcIlVTQSBvZyB0ZXJyaXRvcmllclwiLFxuXHRcdFVUTTogXCJVVE1cIixcblx0XHRVa3JhaW5lOiBcIlVrcmFpbmVcIixcblx0XHRcIlVua25vd24gSGVpZ2h0IFN5c3RlbXNcIjogXCJVa2VuZHRlIGjDuGpkZXN5c3RlbWVyXCIsXG5cdFx0VXJhbnVzOiBcIlVyYW51c1wiLFxuXHRcdFZlbnVzOiBcIlZlbnVzXCIsXG5cdFx0XCJWZXJ0aWNhbCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJWZXJ0aWthbGUga29vcmRpbmF0c3lzdGVtZXJcIixcblx0XHRWaWV0bmFtOiBcIlZpZXRuYW1cIixcblx0XHRcIldHUyAxOTcyXCI6IFwiV0dTIDE5NzJcIixcblx0XHRcIldHUyAxOTg0XCI6IFwiV0dTIDE5ODRcIixcblx0XHRXaXNjb25zaW46IFwiV2lzY29uc2luXCIsXG5cdFx0XCJXaXNjb25zaW4gQ1JTXCI6IFwiV2lzY29uc2luIENSU1wiLFxuXHRcdFdvcmxkOiBcIlZlcmRlblwiLFxuXHRcdFwiV29ybGQgKFNwaGVyZS1iYXNlZClcIjogXCJWZXJkZW4gKHNmw6ZyaXNrLWJhc2VyZXQpXCIsXG5cdFx0V3lvbWluZzogXCJXeW9taW5nXCIsXG5cdFx0XCJYaWFuIDE5ODBcIjogXCJYaWFuIDE5ODBcIixcblx0XHRkb25lOiBcIlVkZsO4cnRcIixcblx0XHRub1Jlc3VsdHM6IFwiRGVyIGJsZXYgaWtrZSBmdW5kZXQgbm9nZW4gcmVzdWx0YXRlclwiLFxuXHRcdHNlYXJjaFBsYWNlaG9sZGVyOiBcIk5hdm4gZWxsZXIgV0tJRFwiLFxuXHRcdGJyb3dzZVRlbXBsYXRlOiBcIkdlbm5lbXNlIHJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uZXJcIixcblx0XHRzYXZlVGVtcGxhdGU6IFwiR2VtIHJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uXCIsXG5cdFx0cHJldmlldzogXCJGb3Jow6VuZHN2aXNuaW5nXCIsXG5cdFx0cHJldmlld0Rlc2NyaXB0aW9uOiBcIlZpcyByZXN1bHRhdGV0LCBmw7hyIGFuYWx5c2VuIGvDuHJlcy5cIixcblx0XHRzaG93UHJldmlldzogXCJWaXMgZm9yaMOlbmRzdmlzbmluZ1wiLFxuXHRcdHByZXZpZXdMYXllcjogXCJGb3Jow6VuZHN2aXNuaW5nc2xhZyAke251bWJlcn1cIixcblx0XHRuZXdQcmV2aWV3OiBcIk55IGZvcmjDpW5kc3Zpc25pbmdcIixcblx0XHRwcmV2aWV3UG9wdXA6IFwiQWt0aXbDqXIgZm9yaMOlbmRzdmlzbmluZyBhZiBhbmFseXNlcmVzdWx0YXRlcm5lIGJhc2VyZXQgcMOlIGlucHV0cGFyYW1ldHJlbmUuXCIsXG5cdFx0dXBkYXRlUHJldmlld0xheWVyOiBcIk9wZGF0w6lyIGRldCB2YWxndGUgZm9yaMOlbmRzdmlzbmluZ3NsYWdcIixcblx0XHRjcmVhdGVQcmV2aWV3TGF5ZXI6IFwiT3ByZXQgbnl0IGZvcmjDpW5kc3Zpc25pbmdzbGFnXCIsXG5cdFx0bWF4aW11bVByZXZpZXdBbGxvd2VkOiBcIkRldCBtYWtzaW1hbGUgdGlsbGFkdGUgYW50YWwgZm9yaMOlbmRzdmlzbmluZ3NsYWc6ICR7bWF4Q291bnR9XCIsXG5cdFx0cHJldmlld0ZhaWx1cmU6IFwiRm9yaMOlbmRzdmlzbmluZ3NsYWdldCBlciBpa2tlIHRpbGfDpm5nZWxpZ3QuIEtvbnRyb2xsw6lyIGlucHV0cGFyYW1ldHJlbmUsIG9nIG9wZGF0ZXIgZm9yaMOlbmRzdmlzbmluZ3NsYWdldCBpZ2VuLlwiLFxuXHRcdGhlYWRlcjogXCJWw6ZsZyBlbGVtZW50XCIsXG5cdFx0Y29udGVudDogXCJEdSBoYXIgw6ZuZHJpbmdlciwgZGVyIGlra2UgZXIgZ2VtdCwgaSAke3JmdFRpdGxlfS4gSHZpcyBkdSBzdGFydGVyIGZvcmZyYSBtZWQgZW4gbnkgc2thYmVsb24sIGfDpXIgZGlzc2Ugw6ZuZHJpbmdlciB0YWJ0LlwiLFxuXHRcdGRvbnRTYXZlOiBcIkdlbSBpa2tlXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIkZvcnRzw6Z0XCIsXG5cdFx0c3RyZXRjaDogXCJUaWxwYXMgdGlsIHZpbmR1ZVwiLFxuXHRcdHBhbjogXCJQYW5vcsOpclwiLFxuXHRcdG5ld1RlbXBsYXRlOiBcIk9wcmV0IG55IHNrYWJlbG9uXCIsXG5cdFx0b3BlblRlbXBsYXRlOiBcIsOFYm4gc2thYmVsb25cIixcblx0XHRhZGRGdW5jdGlvbjogXCJUaWxmw7hqIHJhc3RlcmZ1bmt0aW9uZXJcIixcblx0XHRhZGRDb25zdGFudDogXCJUaWxmw7hqIGtvbnRyYXN0XCIsXG5cdFx0YWRkUmFzdGVyOiBcIlRpbGbDuGogcmFzdGVydmFyaWFiZWxcIixcblx0XHRtb3ZlOiBcIkZseXRcIixcblx0XHR6b29tOiBcIlpvb21cIixcblx0XHRzYXZlQXM6IFwiR2VtIHNvbVwiLFxuXHRcdGNsZWFyOiBcIlJ5ZFwiLFxuXHRcdGFkZFJhc3RlckZ1bmN0aW9uVGl0bGU6IFwiVGlsZsO4aiByYXN0ZXJmdW5rdGlvbmVyXCIsXG5cdFx0dGVtcGxhdGVQcm9wZXJ0aWVzVGl0bGU6IFwiRWdlbnNrYWJlciBmb3Igc2thYmVsb25cIixcblx0XHRicm93c2VSRlQ6IFwiR2VubmVtc2UgcmFzdGVyZnVua3Rpb25zc2thYmVsb25lclwiLFxuXHRcdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiJHt0b29sVGl0bGV9LWFuYWx5c2V2w6Zya3TDuGouXCIsXG5cdFx0b3BlblRvb2xUZXh0OiBcIsOFYm4gdsOmcmt0w7hqXCIsXG5cdFx0dG9vbERyb3Bkb3duVGV4dDogXCJWw6Zya3TDuGpzcnVsbGVtZW51XCIsXG5cdFx0YWRkVG9NYXA6IFwiQmVrcsOmZnQgb2cgdGlsZsO4aiBrb3J0XCIsXG5cdFx0Y29uZmlybTogXCJCZWtyw6ZmdFwiLFxuXHRcdHNlbGVjdDogXCJWw6ZsZ1wiLFxuXHRcdHNlbGVjdFRhc2s6IFwiVsOmbGcgb3BnYXZlXCIsXG5cdFx0dW5zdXBwb3J0ZWRMYXllcjogXCJEZW5uZSBwYXJhbWV0ZXIgdW5kZXJzw7h0dGVyIGlra2UgZsO4bGdlbmRlIGxhZzogJHtsYXllck5hbWV9LlwiLFxuXHRcdHZpZXdEZXRhaWxzOiBcIlZpcyBhbGxlIG9wbHlzbmluZ2VyIG9tIGVsZW1lbnRldFwiLFxuXHRcdHJlbmFtZTogXCJPbWTDuGJcIixcblx0XHRkdXBsaWNhdGU6IFwiRHVwbGlrw6lyXCIsXG5cdFx0bGF1bmNoOiBcIsOFYm4gZm9yIGF0IGvDuHJlXCIsXG5cdFx0dGVtcGxhdGVFZGl0b3I6IFwiU2thYmVsb25lZGl0b3JcIixcblx0XHRjcmVhdGVJdGVtOiBcIkdlbSByYXN0ZXJmdW5rdGlvbnNza2FiZWxvblwiLFxuXHRcdGFjdGlvbkxhYmVsOiBcIkZpbHRyw6lyXCIsXG5cdFx0ZmlsdGVyUG9wb3ZlckhlYWRpbmc6IFwiRmlsdHJlciBmdW5rdGlvbmVybmVcIixcblx0XHRkZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXI6IFwiU8O4ZyBlZnRlciBuYXZuXCIsXG5cdFx0c2V0dGluZ3M6IFwiSW5kc3RpbGxpbmdlclwiLFxuXHRcdHN1bW1hcnk6IFwiUmVzdW3DqVwiLFxuXHRcdGRlZmluaXRpb25RdWVyeTogXCJEZWZpbml0aW9uc2ZvcmVzcMO4cmdzZWxcIixcblx0XHRtYXRjaFZhcmlhYmxlczogXCJNYXRjaHZhcmlhYmxlclwiLFxuXHRcdHVuaW9uRGltZW5zaW9uOiBcIkZvcmVuaW5nc2RpbWVuc2lvblwiLFxuXHRcdG5hbWVFZGl0b3JQbGFjZWhvbGRlcjogXCJJbmR0YXN0IHRpdGVsXCIsXG5cdFx0c3VtbWFyeUVkaXRvclBsYWNlaG9sZGVyOiBcIkFuZ2l2IGVuIGtvcnQgYmVza3JpdmVsc2UuXCIsXG5cdFx0ZGVmaW5pdGlvblF1ZXJ5UGxhY2Vob2xkZXI6IFwiSW5kdGFzdC4uLlwiLFxuXHRcdHVwbG9hZDogXCJPdmVyZsO4clwiLFxuXHRcdGNob29zZUltYWdlOiBcIktsaWsgZm9yIGF0IHbDpmxnZSBlbiBmaWxcIixcblx0XHR1cGRhdGU6IFwiT3BkYXTDqXJcIixcblx0XHR0aHVtYm5haWxFcnJvcnM6IHtcblx0XHRcdHdyb25nSW1hZ2VUeXBlOiBcIkRlciBlciB2YWxndCBkZW4gZm9ya2VydGUgYmlsbGVkdHlwZS5cIixcblx0XHRcdG5vdEF2YWlsYWJsZTogXCJNaW5pYXR1cmVuIGVyIGlra2UgdGlsZ8OmbmdlbGlnXCIsXG5cdFx0XHRsb2FkRXJyb3I6IFwiS3VubmUgaWtrZSBpbmRsw6ZzZSBiaWxsZWRldFwiLFxuXHRcdFx0Y2hvb3NlRmlsZTogXCJLbGlrIGZvciBhdCB2w6ZsZ2UgZmlsXCJcblx0XHR9XG5cdH1cbn07XG5jb25zdCBjb3B5ID0gXCJLb3Bpw6lyXCI7XG5jb25zdCBzYXZlID0gXCJHZW1cIjtcbmNvbnN0IHRpdGxlID0gXCJUaXRlbFwiO1xuY29uc3QgZm9sZGVyID0gXCJNYXBwZVwiO1xuY29uc3QgdGFncyA9IFwiXFxcIlRhZ3NcXFwiXCI7XG5jb25zdCBzYXZpbmdNZXNzYWdlID0gXCJHZW1tZXIgZWxlbWVudGV0IGlcIjtcbmNvbnN0IHNoYXJlV2l0aCA9IFwiRGVsIG1lZFwiO1xuY29uc3Qgc2hhcmUgPSBcIkRlbFwiO1xuY29uc3Qgc2V0U2hhcmluZ0xldmVsID0gXCJBbmdpdiBkZWxpbmdzbml2ZWF1XCI7XG5jb25zdCBzZXRHcm91cFNoYXJpbmcgPSBcIkFuZ2l2IGRlbGluZyBtZWQgZ3J1cHBlclwiO1xuY29uc3Qgb3duZXIgPSBcIkVqZXJcIjtcbmNvbnN0IG9yZ2FuaXphdGlvbiA9IFwiT3JnYW5pc2F0aW9uXCI7XG5jb25zdCBldmVyeW9uZSA9IFwiQWxsZSAob2ZmZW50bGlnKVwiO1xuY29uc3QgZ3JvdXBzID0gXCJHcnVwcGVyOlwiO1xuY29uc3QgdHlwZSA9IFwiVHlwZVwiO1xuY29uc3QgbW9zYWljID0gXCJNb3NhaWtcIjtcbmNvbnN0IGl0ZW1Hcm91cCA9IFwiRWxlbWVudGdydXBwZVwiO1xuY29uc3QgaXRlbSA9IFwiRWxlbWVudFwiO1xuY29uc3QgZGVmaW5pdGlvblF1ZXJ5ID0gXCJEZWZpbml0aW9uc2ZvcmVzcMO4cmdzZWxcIjtcbmNvbnN0IGdyb3VwSXRlbXNCeSA9IFwiR3J1cHDDqXIgZWxlbWVudGVyIGVmdGVyXCI7XG5jb25zdCBncm91cEZpZWxkTmFtZSA9IFwiR3J1cHDDqXIgZmVsdG5hdm5cIjtcbmNvbnN0IHRhZ0ZpZWxkTmFtZSA9IFwiVGFnIGZlbHRuYXZuXCI7XG5jb25zdCBub1RpdGxlVGFnRXJyb3JNc2cgPSBcIkR1IHNrYWwgYW5naXZlIGVuIHRpdGVsIHRpbCBkaXQgZWxlbWVudCBzYW10IG7DuGdsZW9yZCwgZGVyIGfDuHIgZGV0IG11bGlndCBhdCBmaW5kZSBkaXQga29ydCB2ZWQgaGrDpmxwIGFmIHPDuGduaW5nZXIuXCI7XG5jb25zdCBub1RpdGxlRXJyb3JNc2cgPSBcIkR1IHNrYWwgYW5naXZlIGVuIHRpdGVsIHDDpSBlbGVtZW50ZXQuXCI7XG5jb25zdCBub1RhZ0Vycm9yTXNnID0gXCJEdSBza2FsIGFuZ2l2ZSBtaW5kc3Qgw6l0IG7DuGdsZW9yZCBmb3IgYXQgaGrDpmxwZSBmb2xrIG1lZCBhdCBmaW5kZSBkaXQgZWxlbWVudCB2aWEgc8O4Z25pbmdlci5cIjtcbmNvbnN0IGVycm9yID0gXCJGZWpsXCI7XG5jb25zdCB3YXJuaW5nID0gXCJBZHZhcnNlbFwiO1xuY29uc3Qgc3VjY2VzcyA9IFwiU3VjY2VzXCI7XG5jb25zdCBkZXRhaWxzID0gXCJPcGx5c25pbmdlcjpcIjtcbmNvbnN0IHRyeUFnYWluID0gXCJQcsO4diBpZ2VuXCI7XG5jb25zdCB0b29sTW9kZWxlciA9IHtcblx0c2F2ZTogXCJHZW1cIixcblx0ZWRpdFByb3BlcnRpZXM6IFwiUmVkaWdlciBlZ2Vuc2thYmVyXCIsXG5cdHNhdmVBczogXCJHZW0gc29tXCIsXG5cdHNhdmluZ05vdGlmaWNhdGlvbjogXCJHZW1tZXIgw6ZuZHJpbmdlciB0aWwgZWxlbWVudGV0Li4uXCIsXG5cdHNhdmluZ1RpdGxlOiBcIkdlbW1lclwiLFxuXHRzYXZlRmFpbGVkTWVzc2FnZTogXCJLdW5uZSBpa2tlIGdlbW1lIMOmbmRyaW5nZXIuXCIsXG5cdHNhdmVXaXRoRXJyb3JzTWVzc2FnZTogXCLDhm5kcmluZ2VybmUgYmxldiBnZW10IG1lZCBmw7hsZ2VuZGUgZmVqbC5cIixcblx0dmlld0l0ZW1NZXNzYWdlOiBcIlZpcyBkZXQgZ2VtdGUgZWxlbWVudFwiLFxuXHRoZXJlOiBcImhlci5cIixcblx0aXRlbUNyZWF0ZWRNZXNzYWdlOiBcIk55dCBlbGVtZW50IGVyIGJsZXZldCBvcHJldHRldC5cIixcblx0Y2xpY2tUb1ZpZXdJdGVtTWVzc2FnZTogXCJLbGlrIHDDpSBPSyBmb3IgYXQgZsOlIHZpc3Qgc2lkZW4gbWVkIGVsZW1lbnRvcGx5c25pbmdlcjsga2xpayBww6UgQW5udWxsw6lyIGZvciBhdCBmb3J0c8OmdHRlLlwiLFxuXHRyZWFkaW5nRmFpbGVkOiBcIkt1bm5lIGlra2UgaW5kbMOmc2UgZGVuIHZhbGd0ZSBza2FiZWxvbiB0aWwgcmFzdGVyZnVua3Rpb25lbi5cIixcblx0ZmFpbGVkVG9Mb2FkWE1MOiBcIkthbiBpa2tlIGluZGzDpnNlIGRlbiB2YWxndGUgc2thYmVsb24gdGlsIHJhc3RlcmZ1bmt0aW9uZW4gaSBYTUwtZm9ybWF0LlwiLFxuXHRsZWFybk1vcmU6IFwiRsOlIG1lcmUgYXQgdmlkZVwiLFxuXHRvdmVyd3JpdGVUaXRsZTogXCJCZWtyw6ZmdCBvdmVyc2tyaXZuaW5nXCIsXG5cdG92ZXJ3cml0ZU1lc3NhZ2U6IFwiVmlsIGR1IG92ZXJza3JpdmUgZXQgZWtzaXN0ZXJlbmRlIGVsZW1lbnQ/XCIsXG5cdG92ZXJ3cml0ZVN1Y2Nlc3NNZXNzYWdlOiBcIkVsZW1lbnQgZXIgYmxldmV0IG9wZGF0ZXJldC5cIlxufTtcbmNvbnN0IHRvb2xFZGl0b3IgPSB7XG5cdHJ1bjogXCJLw7hyXCIsXG5cdHNhdmU6IFwiR2VtXCIsXG5cdGRlbGV0ZVNlbGVjdGVkOiBcIlNsZXQgZGUgbWFya2VyZWRlIGVsZW1lbnRlclwiLFxuXHRhZGRSYXN0ZXI6IFwiVGlsZsO4aiByYXN0ZXJcIixcblx0YWRkU2NhbGFyOiBcIlRpbGbDuGogc2thbGFyXCIsXG5cdGxheW91dDogXCJBdXRvbGF5b3V0XCIsXG5cdGVycm9yVGl0bGU6IFwiRmVqbFwiLFxuXHRpbnZhbGlkVG9vbE1lc3NhZ2U6IFwiU2thYmVsb25lbiB0aWwgcmFzdGVyZnVua3Rpb25lbiBlciBpa2tlIGd5bGRpZy5cIixcblx0b3V0OiBcIlVkXCIsXG5cdHpvb21JbjogXCJab29tIEluXCIsXG5cdHpvb21PdXQ6IFwiWm9vbSBPdXRcIixcblx0em9vbVRvRml0OiBcIlRpbHBhcyB0aWwgdmluZHVlXCIsXG5cdHBhbk9uOiBcIlNraWZ0IHRpbCBwYW5vcmVyaW5nc3RpbHN0YW5kXCIsXG5cdHBhbk9mZjogXCJTbMOlIHBhbm9yZXJpbmdzdGlsc3RhbmQgZnJhXCIsXG5cdGRlZmF1bHRNb2RlbE5hbWU6IFwiVsOmcmt0w7hqZXQgTW9kZWxcIixcblx0ZGVmYXVsdFJhc3Rlck5hbWU6IFwiUmFzdGVyXCJcbn07XG5jb25zdCB0b29sRGV0YWlsc0VkaXRvciA9IHtcblx0ZGVmYXVsdFRvb2xOYW1lOiBcIlJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uXCIsXG5cdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiVGlsZsO4aiBldCBrb3J0IHJlc3Vtw6kgb20gcmFzdGVyZnVua3Rpb25lbi5cIixcblx0ZGVmYXVsdEhlbHBUZXh0OiBcIktsaWsgcMOlIGhqw6ZscC1pa29uZXQgZm9yIGF0IHJlZGlnZXJlIGhqw6ZscC10ZWtzdGVuXCIsXG5cdGVkaXRIZWxwVGl0bGU6IFwiUmVkaWdlciBIasOmbHBcIixcblx0c2F2ZUxhYmVsOiBcIkdlbVwiLFxuXHRjYW5jZWxMYWJlbDogXCJBbm51bGxlclwiLFxuXHR0aHVtYm5haWw6IHtcblx0XHR3cm9uZ0ltYWdlVHlwZTogXCJEZXIgZXIgdmFsZ3QgZGVuIGZvcmtlcnRlIGJpbGxlZHR5cGUuXCIsXG5cdFx0bm90QXZhaWxhYmxlOiBcIk1pbmlhdHVyZW4gZXIgaWtrZSB0aWxnw6ZuZ2VsaWdcIixcblx0XHRsb2FkRXJyb3I6IFwiS3VubmUgaWtrZSBpbmRsw6ZzZSBiaWxsZWRldFwiLFxuXHRcdGNob29zZUZpbGU6IFwiS2xpayBmb3IgYXQgdsOmbGdlIGZpbFwiXG5cdH1cbn07XG5jb25zdCBzYXZlVXRpbHMgPSB7XG5cdHRodW1ibmFpbDogXCJNaW5pYXR1cmViaWxsZWRlXCIsXG5cdHNoYXJpbmc6IFwiRGVsZXJcIlxufTtcbmNvbnN0IGNsb3NlID0gXCJMdWtcIjtcbmNvbnN0IHVuc2F2ZWRXYXJuaW5nRXhpc3RpbmcgPSBcIlZpbCBkdSBnZXJuZSBnZW1tZSDDpm5kcmluZ2VybmUgdGlsIGVsZW1lbnRldCA8Yj4ke2l0ZW1UaXRsZX08L2I+ID9cIjtcbmNvbnN0IHVuc2F2ZWRXYXJuaW5nTmV3ID0gXCJWaWwgZHUgZ2VtbWUgZGluZSDDpm5kcmluZ2VyP1wiO1xuY29uc3Qgc2F2ZUFzID0gXCJHZW0gc29tXCI7XG5jb25zdCBkb250U2F2ZSA9IFwiR2VtIGlra2VcIjtcbmNvbnN0IHVuc2F2ZWRUaXRsZSA9IFwiw4ZuZHJpbmdlciwgZGVyIGlra2UgZXIgZ2VtdFwiO1xuY29uc3QgaW52YWxpZFJGVE1lc3NhZ2UgPSBcIkRlbiBvcHJldHRlZGUgc2thYmVsb24gdGlsIHJhc3RlcmZ1bmt0aW9uIGVyIGlra2UgZ3lsZGlnLlwiO1xuY29uc3QgZXJyb3JUaXRsZSA9IFwiRmVqbFwiO1xuY29uc3QgYnJlYWRjcnVtYiA9IFwiUmFzdGVyZnVua3Rpb25zZWRpdG9yXCI7XG5jb25zdCBicmVhZGNydW1iRWRpdG9yID0gXCJJbmRob2xkID4gUmFzdGVyZnVua3Rpb25zZWRpdG9yXCI7XG5jb25zdCB2aWV3ZXJNb2RlVGl0bGUgPSBcIlNrcml2ZWJlc2t5dHRldFwiO1xuY29uc3Qgdmlld2VyTW9kZU1lc3NhZ2UgPSBcIlJhc3RlcmZ1bmt0aW9uc3NrYWJlbG9uLWVsZW1lbnQgZXIgc2tyaXZlYmVza3l0dGV0LiDDhm5kcmluZ2VyIGthbiBpa2tlIGdlbW1lcy5cIjtcbmNvbnN0IHVzZXJTdGFydERpcmVjdGlvbiA9IFwiVsOmbGcgZW4gZnVua3Rpb24gZm9yIGF0IGJlZ3luZGUgYXQgb3ByZXR0ZSBlbiBza2FiZWxvbiB0aWwgcmFzdGVyZnVua3Rpb24uXCI7XG5jb25zdCBzZWxlY3RGdW5jdGlvbiA9IFwiVGlsZsO4aiBmdW5rdGlvblwiO1xuY29uc3QgZGVzZWxlY3RGdW5jdGlvbiA9IFwiRmplcm4gZnVua3Rpb25cIjtcbmNvbnN0IGRpYWxvZ1RpdGxlID0gXCJTeXN0ZW1cIjtcbmNvbnN0IGNhdGVnb3J5ID0gXCJLYXRlZ29yaWVyXCI7XG5jb25zdCBzZWFyY2ggPSBcIlPDuGcgaSByYXN0ZXJmdW5rdGlvbmVyXCI7XG5jb25zdCBjYXRlZ29yeU5hbWVzID0ge1xuXHRhbmFseXNpczogXCJBbmFseXNlXCIsXG5cdGFwcGVhcmFuY2U6IFwiVWRzZWVuZGVcIixcblx0Y2xhc3NpZmljYXRpb246IFwiS2xhc3NpZmlrYXRpb25cIixcblx0Y29udmVyc2lvbjogXCJLb252ZXJ0ZXJpbmdcIixcblx0Y29ycmVjdGlvbjogXCJLb3JyZWt0aW9uXCIsXG5cdGRhdGFNYW5hZ2VtZW50OiBcIkRhdGFow6VuZHRlcmluZ1wiLFxuXHRkaXN0YW5jZTogXCJBZnN0YW5kXCIsXG5cdGRpc3RhbmNlTGVnYWN5OiBcIkFmc3RhbmQgKHVkZmFzZXQpXCIsXG5cdGh5ZHJvbG9neTogXCJIeWRyb2xvZ2lcIixcblx0bWF0aDogXCJNYXRlbWF0aWtcIixcblx0bWF0aENvbmRpdGlvbmFsOiBcIk1hdGVtYXRpazogQmV0aW5nZXRcIixcblx0bWF0aExvZ2ljYWw6IFwiTWF0ZW1hdGlrOiBMb2dpc2tcIixcblx0bWF0aFRyaWdvbm9tZXRyaWM6IFwiTWF0ZW1hdGlrOiBUcmlnb25vbWV0cmlza1wiLFxuXHRyZWNsYXNzOiBcIk9ta2xhc3NpZmljZXJpbmdcIixcblx0c3RhdGlzdGljYWw6IFwiU3RhdGlzdGlza1wiLFxuXHRzdXJmYWNlOiBcIk92ZXJmbGFkZVwiXG59O1xuY29uc3QgY29tbW9uU3RyaW5nc19kYSA9IHtcblx0b2s6IG9rLFxuXHRjYW5jZWw6IGNhbmNlbCxcblx0ZW50ZXJVUkw6IGVudGVyVVJMLFxuXHRzZXJ2aWNlVVJMOiBzZXJ2aWNlVVJMLFxuXHRzZWxlY3RSYXN0ZXI6IHNlbGVjdFJhc3Rlcixcblx0ZmFpbGVkVG9Mb2FkTGF5ZXI6IGZhaWxlZFRvTG9hZExheWVyLFxuXHRsb2FkaW5nTGF5ZXI6IGxvYWRpbmdMYXllcixcblx0c2VsZWN0RmVhdHVyZTogc2VsZWN0RmVhdHVyZSxcblx0ZW50ZXJGVVJMOiBlbnRlckZVUkwsXG5cdGFkZFJhc3RlcjogYWRkUmFzdGVyLFxuXHRhZGRTY2FsYXI6IGFkZFNjYWxhcixcblx0cmFzdGVyOiByYXN0ZXIsXG5cdHNjYWxhcjogc2NhbGFyLFxuXHRkZWZhdWx0TW9kZWxOYW1lOiBkZWZhdWx0TW9kZWxOYW1lLFxuXHRnZW5lcmFsOiBnZW5lcmFsLFxuXHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuXHR2YXJpYWJsZXM6IHZhcmlhYmxlcyxcblx0bmFtZTogbmFtZSxcblx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuXHRwYXJhbWV0ZXI6IHBhcmFtZXRlcixcblx0aXNQdWJsaWM6IGlzUHVibGljLFxuXHRpc0RhdGFzZXQ6IGlzRGF0YXNldCxcblx0dW5rbm93blBpeGVsVHlwZTogdW5rbm93blBpeGVsVHlwZSxcblx0b3V0cHV0UGl4ZWxUeXBlOiBvdXRwdXRQaXhlbFR5cGUsXG5cdHU4UGl4ZWxUeXBlOiB1OFBpeGVsVHlwZSxcblx0czhQaXhlbFR5cGU6IHM4UGl4ZWxUeXBlLFxuXHR1MTZQaXhlbFR5cGU6IHUxNlBpeGVsVHlwZSxcblx0czE2UGl4ZWxUeXBlOiBzMTZQaXhlbFR5cGUsXG5cdHUzMlBpeGVsVHlwZTogdTMyUGl4ZWxUeXBlLFxuXHRzMzJQaXhlbFR5cGU6IHMzMlBpeGVsVHlwZSxcblx0ZjMyUGl4ZWxUeXBlOiBmMzJQaXhlbFR5cGUsXG5cdGY2NFBpeGVsVHlwZTogZjY0UGl4ZWxUeXBlLFxuXHRwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRtdWx0aWRpbWVuc2lvbmFsUnVsZXM6IG11bHRpZGltZW5zaW9uYWxSdWxlcyxcblx0bWF0Y2hWYXJpYWJsZXM6IG1hdGNoVmFyaWFibGVzLFxuXHR1bmlvbkRpbWVuc2lvbnM6IHVuaW9uRGltZW5zaW9ucyxcblx0cmFzdGVyRnVuY3Rpb25FZGl0b3I6IHJhc3RlckZ1bmN0aW9uRWRpdG9yLFxuXHRyZnhMaWNlbnNlSW5mbzogcmZ4TGljZW5zZUluZm8sXG5cdHJhc3RlckZ1bmN0aW9uczogcmFzdGVyRnVuY3Rpb25zLFxuXHRjb3B5OiBjb3B5LFxuXHRzYXZlOiBzYXZlLFxuXHR0aXRsZTogdGl0bGUsXG5cdGZvbGRlcjogZm9sZGVyLFxuXHR0YWdzOiB0YWdzLFxuXHRzYXZpbmdNZXNzYWdlOiBzYXZpbmdNZXNzYWdlLFxuXHRzaGFyZVdpdGg6IHNoYXJlV2l0aCxcblx0c2hhcmU6IHNoYXJlLFxuXHRzZXRTaGFyaW5nTGV2ZWw6IHNldFNoYXJpbmdMZXZlbCxcblx0c2V0R3JvdXBTaGFyaW5nOiBzZXRHcm91cFNoYXJpbmcsXG5cdG93bmVyOiBvd25lcixcblx0b3JnYW5pemF0aW9uOiBvcmdhbml6YXRpb24sXG5cdGV2ZXJ5b25lOiBldmVyeW9uZSxcblx0Z3JvdXBzOiBncm91cHMsXG5cdHR5cGU6IHR5cGUsXG5cdG1vc2FpYzogbW9zYWljLFxuXHRpdGVtR3JvdXA6IGl0ZW1Hcm91cCxcblx0aXRlbTogaXRlbSxcblx0ZGVmaW5pdGlvblF1ZXJ5OiBkZWZpbml0aW9uUXVlcnksXG5cdGdyb3VwSXRlbXNCeTogZ3JvdXBJdGVtc0J5LFxuXHRncm91cEZpZWxkTmFtZTogZ3JvdXBGaWVsZE5hbWUsXG5cdHRhZ0ZpZWxkTmFtZTogdGFnRmllbGROYW1lLFxuXHRub1RpdGxlVGFnRXJyb3JNc2c6IG5vVGl0bGVUYWdFcnJvck1zZyxcblx0bm9UaXRsZUVycm9yTXNnOiBub1RpdGxlRXJyb3JNc2csXG5cdG5vVGFnRXJyb3JNc2c6IG5vVGFnRXJyb3JNc2csXG5cdGVycm9yOiBlcnJvcixcblx0d2FybmluZzogd2FybmluZyxcblx0c3VjY2Vzczogc3VjY2Vzcyxcblx0ZGV0YWlsczogZGV0YWlscyxcblx0dHJ5QWdhaW46IHRyeUFnYWluLFxuXHR0b29sTW9kZWxlcjogdG9vbE1vZGVsZXIsXG5cdHRvb2xFZGl0b3I6IHRvb2xFZGl0b3IsXG5cdHRvb2xEZXRhaWxzRWRpdG9yOiB0b29sRGV0YWlsc0VkaXRvcixcblx0c2F2ZVV0aWxzOiBzYXZlVXRpbHMsXG5cdGNsb3NlOiBjbG9zZSxcblx0dW5zYXZlZFdhcm5pbmdFeGlzdGluZzogdW5zYXZlZFdhcm5pbmdFeGlzdGluZyxcblx0dW5zYXZlZFdhcm5pbmdOZXc6IHVuc2F2ZWRXYXJuaW5nTmV3LFxuXHRzYXZlQXM6IHNhdmVBcyxcblx0ZG9udFNhdmU6IGRvbnRTYXZlLFxuXHR1bnNhdmVkVGl0bGU6IHVuc2F2ZWRUaXRsZSxcblx0aW52YWxpZFJGVE1lc3NhZ2U6IGludmFsaWRSRlRNZXNzYWdlLFxuXHRlcnJvclRpdGxlOiBlcnJvclRpdGxlLFxuXHRicmVhZGNydW1iOiBicmVhZGNydW1iLFxuXHRicmVhZGNydW1iRWRpdG9yOiBicmVhZGNydW1iRWRpdG9yLFxuXHR2aWV3ZXJNb2RlVGl0bGU6IHZpZXdlck1vZGVUaXRsZSxcblx0dmlld2VyTW9kZU1lc3NhZ2U6IHZpZXdlck1vZGVNZXNzYWdlLFxuXHR1c2VyU3RhcnREaXJlY3Rpb246IHVzZXJTdGFydERpcmVjdGlvbixcblx0c2VsZWN0RnVuY3Rpb246IHNlbGVjdEZ1bmN0aW9uLFxuXHRkZXNlbGVjdEZ1bmN0aW9uOiBkZXNlbGVjdEZ1bmN0aW9uLFxuXHRkaWFsb2dUaXRsZTogZGlhbG9nVGl0bGUsXG5cdGNhdGVnb3J5OiBjYXRlZ29yeSxcblx0c2VhcmNoOiBzZWFyY2gsXG5cdGNhdGVnb3J5TmFtZXM6IGNhdGVnb3J5TmFtZXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbW1vblN0cmluZ3NfZGE7XG5leHBvcnQgeyBhZGRSYXN0ZXIsIGFkZFNjYWxhciwgYnJlYWRjcnVtYiwgYnJlYWRjcnVtYkVkaXRvciwgY2FuY2VsLCBjYXRlZ29yeSwgY2F0ZWdvcnlOYW1lcywgY2xvc2UsIGNvcHksIGRlZmF1bHRNb2RlbE5hbWUsIGRlZmluaXRpb25RdWVyeSwgZGVzY3JpcHRpb24sIGRlc2VsZWN0RnVuY3Rpb24sIGRldGFpbHMsIGRpYWxvZ1RpdGxlLCBkb250U2F2ZSwgZW50ZXJGVVJMLCBlbnRlclVSTCwgZXJyb3IsIGVycm9yVGl0bGUsIGV2ZXJ5b25lLCBmMzJQaXhlbFR5cGUsIGY2NFBpeGVsVHlwZSwgZmFpbGVkVG9Mb2FkTGF5ZXIsIGZvbGRlciwgZ2VuZXJhbCwgZ3JvdXBGaWVsZE5hbWUsIGdyb3VwSXRlbXNCeSwgZ3JvdXBzLCBpbnZhbGlkUkZUTWVzc2FnZSwgaXNEYXRhc2V0LCBpc1B1YmxpYywgaXRlbSwgaXRlbUdyb3VwLCBsb2FkaW5nTGF5ZXIsIG1hdGNoVmFyaWFibGVzLCBtb3NhaWMsIG11bHRpZGltZW5zaW9uYWxSdWxlcywgbmFtZSwgbm9UYWdFcnJvck1zZywgbm9UaXRsZUVycm9yTXNnLCBub1RpdGxlVGFnRXJyb3JNc2csIG9rLCBvcmdhbml6YXRpb24sIG91dHB1dFBpeGVsVHlwZSwgb3duZXIsIHBhcmFtZXRlciwgcGFyYW1ldGVycywgcHJvcGVydGllcywgcmFzdGVyLCByYXN0ZXJGdW5jdGlvbkVkaXRvciwgcmFzdGVyRnVuY3Rpb25zLCByZnhMaWNlbnNlSW5mbywgczE2UGl4ZWxUeXBlLCBzMzJQaXhlbFR5cGUsIHM4UGl4ZWxUeXBlLCBzYXZlLCBzYXZlQXMsIHNhdmVVdGlscywgc2F2aW5nTWVzc2FnZSwgc2NhbGFyLCBzZWFyY2gsIHNlbGVjdEZlYXR1cmUsIHNlbGVjdEZ1bmN0aW9uLCBzZWxlY3RSYXN0ZXIsIHNlcnZpY2VVUkwsIHNldEdyb3VwU2hhcmluZywgc2V0U2hhcmluZ0xldmVsLCBzaGFyZSwgc2hhcmVXaXRoLCBzdWNjZXNzLCB0YWdGaWVsZE5hbWUsIHRhZ3MsIHRpdGxlLCB0b29sRGV0YWlsc0VkaXRvciwgdG9vbEVkaXRvciwgdG9vbE1vZGVsZXIsIHRyeUFnYWluLCB0eXBlLCB1MTZQaXhlbFR5cGUsIHUzMlBpeGVsVHlwZSwgdThQaXhlbFR5cGUsIHVuaW9uRGltZW5zaW9ucywgdW5rbm93blBpeGVsVHlwZSwgdW5zYXZlZFRpdGxlLCB1bnNhdmVkV2FybmluZ0V4aXN0aW5nLCB1bnNhdmVkV2FybmluZ05ldywgdXNlclN0YXJ0RGlyZWN0aW9uLCB2YXJpYWJsZXMsIHZpZXdlck1vZGVNZXNzYWdlLCB2aWV3ZXJNb2RlVGl0bGUsIHdhcm5pbmcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLXN0cmluZ3MuZGEtNTVjNzMzYmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9