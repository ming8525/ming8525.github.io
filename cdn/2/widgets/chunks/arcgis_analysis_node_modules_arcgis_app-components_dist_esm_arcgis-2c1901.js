"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-2c1901"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-effects_2.entry.js":
/*!*******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-effects_2.entry.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_effects: () => (/* binding */ ArcgisEffects),
/* harmony export */   arcgis_effects_popovers: () => (/* binding */ ArcgisEffectsPopovers)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./localStorage-9c4e7a3a.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-9c4e7a3a.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */









const CSS$1 = {
    flow: "flow",
    panel: "panel",
    notice: "notice",
    hint: "hint",
    basemapType: "basemap-type",
    radioButtons: "radio-buttons",
    switch: "switch",
    list: "list",
    effectThumb: "effect-thumb",
    effectThumbImg: "effect-thumb-img",
    effectCount: "effect-count"
};

/**
 * Returns true if the value is defined
 * @param value - value to check
 */
function isDefined(value) {
    return value !== undefined && value !== null;
}

let allLayerEffectTypes = [
    "bloom",
    "dropShadow",
    "blur",
    "brightnessContrast",
    "grayscale",
    "hueRotate",
    "saturate",
    "invert",
    "sepia"
];
let allLightFeatureEffectTypes = [
    "dropShadow_gray",
    "strongDropShadow",
    "dropShadow_transparency",
    "dropShadow_blur",
    "mutedBlur",
    "mutedGray"
];
let allDarkFeatureEffectTypes = ["bloom_gray", "bloom_blur", "bloom_transparency", "mutedBlur", "mutedGray"];
/* Neutral values :
bloom - (0,0,0)
blur - 0
brightness - 100%
contrast - 100%
dropshadow - 0,0,0,black
grayscale - 0%
hue-rotate - 0
invert - 0%
opacity - 100%
saturate - 100%
sepia - 0%
*/
// all applicable values stored as pt (not px)
const layerEffectDefaults = {
    bloom: { strength: 2, radius: 0.75, threshold: 0.1 },
    dropShadow: {
        line: { color: [0, 0, 0, 255], xoffset: 0.75, yoffset: 0.75, blurRadius: 1.125 },
        point: { color: [0, 0, 0, 255], xoffset: 1.125, yoffset: 1.125, blurRadius: 1.875 },
        polygon: { color: [0, 0, 0, 255], xoffset: 1.125, yoffset: 1.125, blurRadius: 2.25 }
    },
    blur: { radius: 1.5 },
    brightness: { amount: 1.5 },
    contrast: { amount: 2 },
    grayscale: { amount: 1 },
    hueRotate: { angle: 100 },
    saturate: { amount: 1 },
    invert: { amount: 1 },
    sepia: { amount: 0.7 }
};
const lastLayerEffectValues = JSON.parse(JSON.stringify(layerEffectDefaults));
// all applicable values stored as pt (not px)
// Drop Shadow + Gray: dropshadow (2/2/3px RGB 50,50,50) for active, 100% greyscale + 50% transparency for mute
// Strong Drop Shadow: dropshadow (4/4/4px, Hex#000000) for active, nothing on mute
// Drop Shadow + Transparency: dropshadow (2/2/6px, RGB 50,50,50) for active, 65% transparency for mute
// Drop Shadow + Blur: dropshadow (2/2/3px RGB 50,50,50) for active, 3px blur + 50% transparency for mute
// Bloom + Gray: Bloom (1.3/0.75/0) for active, Greyscale 100% + 50% opacity for mute
// Bloom + Blur:: Bloom (1.3/0.75/0) for active, 3px blur + 50% transparency for mute
// Bloom + Transparency: Bloom (1.3/0.75/0) for active, 65% opacity for mute
// Muted Blur: nothing for active, 3px blur + 50% transparency for mute
// Muted Grayscale: nothing for active, 100% greyscale + 50% transparency for mute-
const featureEffectDefaults = {
    dropShadow_gray: {
        included: [{ type: "drop-shadow", color: [50, 50, 50, 255], xoffset: 1.5, yoffset: 1.5, blurRadius: 2.25 }],
        excluded: [
            { type: "grayscale", amount: 1 },
            { type: "opacity", amount: 0.5 }
        ]
    },
    strongDropShadow: {
        included: [{ type: "drop-shadow", color: [0, 0, 0, 255], xoffset: 3, yoffset: 3, blurRadius: 3 }],
        excluded: []
    },
    dropShadow_transparency: {
        included: [{ type: "drop-shadow", color: [50, 50, 50, 255], xoffset: 1.5, yoffset: 1.5, blurRadius: 4.5 }],
        excluded: [{ type: "opacity", amount: 0.35 }]
    },
    dropShadow_blur: {
        included: [{ type: "drop-shadow", color: [50, 50, 50, 255], xoffset: 1.5, yoffset: 1.5, blurRadius: 2.25 }],
        excluded: [
            { type: "blur", radius: 2.25 },
            { type: "opacity", amount: 0.5 }
        ]
    },
    bloom_gray: {
        included: [{ type: "bloom", strength: 1.3, radius: 0.6, threshold: 0 }],
        excluded: [
            { type: "grayscale", amount: 1 },
            { type: "opacity", amount: 0.5 }
        ]
    },
    bloom_blur: {
        included: [{ type: "bloom", strength: 1.3, radius: 0.6, threshold: 0 }],
        excluded: [
            { type: "blur", radius: 2.25 },
            { type: "opacity", amount: 0.5 }
        ]
    },
    bloom_transparency: {
        included: [{ type: "bloom", strength: 1.3, radius: 0.6, threshold: 0 }],
        excluded: [{ type: "opacity", amount: 0.35 }]
    },
    mutedBlur: {
        included: [],
        excluded: [
            { type: "blur", radius: 2.25 },
            { type: "opacity", amount: 0.5 }
        ]
    },
    mutedGray: {
        included: [],
        excluded: [
            { type: "grayscale", amount: 1 },
            { type: "opacity", amount: 0.5 }
        ]
    }
};
function buildEffectsInfo(node, popovers /* HTMLArcgisEffectsPopoversElement[] */, props) {
    const parts = Array.from(node.children)
        .filter((child) => {
        if (child.tagName.toLowerCase() === "calcite-value-list-item") {
            const itemNode = child;
            const switchNode = itemNode.querySelector("calcite-switch");
            return switchNode.checked;
        }
        return false;
    })
        .map((child) => buildEffectInfo(child, popovers, props));
    let effectsString = "";
    let effects;
    let connector = "";
    parts.forEach((part) => {
        if (part && typeof part === "string") {
            if (!effects) {
                effectsString += connector + part;
            }
            else {
                effects.forEach((item) => {
                    item.value += connector + part;
                });
            }
        }
        else if (part && typeof part === "object") {
            if (!effects) {
                effects = part;
                effects.forEach((item) => {
                    item.value = effectsString + connector + item.value;
                });
            }
            else {
                effects.forEach((item) => {
                    Array.from(part)
                        .filter((newItem) => item.scale === newItem.scale)
                        .forEach((newItem) => (item.value += connector + newItem.value));
                });
            }
        }
        connector = " ";
    });
    if (effects) {
        return effects;
    }
    return effectsString;
}
function parseEffects(props) {
    const { layer, modules, supportsFeatureEffects } = props;
    const anyLayer = layer;
    if (anyLayer.effect && anyLayer.featureEffect) {
        throw new Error("unsupported effect");
    }
    else if (anyLayer.featureEffect && !supportsFeatureEffects) {
        throw new Error("unsupported effect");
    }
    else if (anyLayer.effect) {
        // layer effect
        const effect = anyLayer.effect;
        if (typeof effect === "string") {
            //console.log("EffectJSON", modules.effectsUtils.toJSON(effect));
            return modules.effectsUtils.toJSON(effect);
        }
        else if (effect.length === 3) {
            if (minimalAutoCheckOK(effect)) {
                //console.log("EffectJSON", modules.effectsUtils.toJSON(effect[1].value));
                //console.log("EffectPropertyAPI", modules.effectsUtils.fromJSON(modules.effectsUtils.toJSON(effect[1].value)));
                return modules.effectsUtils.toJSON(effect[1].value);
            }
            else {
                throw new Error("unsupported effect");
            }
        }
        else {
            throw new Error("unsupported effect");
        }
    }
    else if (anyLayer.featureEffect) {
        // feature effect
        const effect = anyLayer.featureEffect;
        if (effect.excludedLabelsVisible &&
            (!effect.includedEffect || typeof effect.includedEffect === "string") &&
            (!effect.excludedEffect || typeof effect.excludedEffect === "string") &&
            (!effect.filter || !effect.filter.geometry)) {
            const included = effect.includedEffect ? modules.effectsUtils.toJSON(effect.includedEffect) : [];
            const excluded = effect.excludedEffect ? modules.effectsUtils.toJSON(effect.excludedEffect) : [];
            //console.log("parsed feature effect - included:", included, "excluded:", excluded, "where:", effect.filter.where);
            let key;
            let effectType;
            for (key in featureEffectDefaults) {
                const defaultJSON = featureEffectDefaults[key];
                if (isSameEffect(defaultJSON.included, included) && isSameEffect(defaultJSON.excluded, excluded)) {
                    effectType = key;
                    break;
                }
            }
            return effectType;
        }
        else {
            throw new Error("unsupported effect");
        }
    }
    return null;
}
function sortEffects(props) {
    const { effectsJSON } = props;
    if (!effectsJSON) {
        return;
    }
    const usedEffectTypes = effectsJSON.map((effect) => effect.type);
    allLayerEffectTypes.sort((typeA, typeB) => {
        const indexA = usedEffectTypes.indexOf(convertToAPIType(typeA));
        const indexB = usedEffectTypes.indexOf(convertToAPIType(typeB));
        const value = indexA > -1 && indexB > -1 && indexA < indexB
            ? -1
            : indexA > -1 && indexB > -1 && indexA > indexB
                ? 1
                : indexA > -1
                    ? -1
                    : indexB > -1
                        ? 1
                        : 0;
        return value;
    });
}
function getEffectProps(type, props) {
    var _a, _b;
    const { effectsJSON } = props;
    const layerEffect = effectsJSON && ((_b = (_a = Array.from(effectsJSON)) === null || _a === void 0 ? void 0 : _a.filter((effect) => effect.type === convertToAPIType(type))) === null || _b === void 0 ? void 0 : _b[0]);
    if (!layerEffect) {
        if (type === "dropShadow") {
            let geometryType = getSimpleGeometryType(props);
            return lastLayerEffectValues[type][geometryType];
        }
        else {
            return lastLayerEffectValues[type];
        }
    }
    return layerEffect;
}
function getSimpleGeometryType(props) {
    const { layer } = props;
    let simpleType = "point";
    const anyLayer = layer;
    if (layer.type === "csv") {
        simpleType = "point";
    }
    else if (anyLayer.geometryType) {
        simpleType =
            anyLayer.geometryType === "polyline"
                ? "line"
                : ["point", "multipoint"].includes(anyLayer.geometryType)
                    ? "point"
                    : "polygon";
    }
    return simpleType;
}
function convertToAPIType(type) {
    switch (type) {
        case "dropShadow":
            return "drop-shadow";
        case "hueRotate":
            return "hue-rotate";
        case "brightnessContrast":
            return "brightness";
        default:
            return type;
    }
}
function buildFeatureEffect(effectType, where, props) {
    const { modules } = props;
    const { FeatureEffect } = modules;
    const json = featureEffectDefaults[effectType];
    const featureEffect = new FeatureEffect({
        filter: {
            where
        },
        includedEffect: modules.effectsUtils.fromJSON(json.included),
        excludedEffect: modules.effectsUtils.fromJSON(json.excluded),
        excludedLabelsVisible: true
    });
    //console.log("buildFeatureEffect", effectType, featureEffect, json);
    return featureEffect;
}
function minimalAutoCheckOK(effect) {
    // make sure each effect type is mentioned in all 3 or none of the strings
    const strings = [effect[0].value, effect[1].value, effect[2].value];
    return !allLayerEffectTypes.some((type) => {
        if (type === "brightnessContrast") {
            const apiType1 = "brightness";
            const apiType2 = "contrast";
            if (strings[0].indexOf(apiType1) > -1 && strings[0].indexOf(apiType2) > -1) {
                return (strings[1].indexOf(apiType1) === -1 ||
                    strings[2].indexOf(apiType1) === -1 ||
                    strings[1].indexOf(apiType2) === -1 ||
                    strings[2].indexOf(apiType2) === -1);
            }
            else if (strings[0].indexOf(apiType1) === -1 && strings[0].indexOf(apiType2) === -1) {
                return (strings[1].indexOf(apiType1) > -1 ||
                    strings[2].indexOf(apiType1) > -1 ||
                    strings[1].indexOf(apiType2) > -1 ||
                    strings[2].indexOf(apiType2) > -1);
            }
            else {
                return true;
            }
        }
        else {
            const apiType = convertToAPIType(type);
            if (strings[0].indexOf(apiType) > -1) {
                return strings[1].indexOf(apiType) === -1 || strings[2].indexOf(apiType) === -1;
            }
            else {
                return strings[1].indexOf(apiType) > -1 || strings[2].indexOf(apiType) > -1;
            }
        }
    });
}
function isSameEffect(effectA_ /* __esri.EffectJSON[] */, effectB_ /* __esri.EffectJSON[] */) {
    // different order is OK
    // make copies so ordering won't affect the original
    const effectA = JSON.parse(JSON.stringify(effectA_));
    const effectB = JSON.parse(JSON.stringify(effectB_));
    // check length
    if (effectA.length !== effectB.length) {
        return false;
    }
    // sort by type name
    effectA.sort((a, b) => a.type.localeCompare(b.type));
    effectB.sort((a, b) => a.type.localeCompare(b.type));
    // loop through array
    let same = true;
    for (let i = 0; i < effectA.length; i++) {
        const a = effectA[i];
        const b = effectB[i];
        // same number of props?
        if (Object.keys(a).length !== Object.keys(b).length) {
            same = false;
            break;
        }
        // look at each prop
        for (let key in a) {
            if (typeof a[key] === "string" && typeof b[key] === "string" && a[key] === b[key]) {
                continue;
            }
            else if (typeof a[key] === "number" && typeof b[key] === "number" && a[key] === b[key]) {
                continue;
            }
            else if (a[key].length &&
                a[key].length === b[key].length &&
                a[key].every((val, idx) => val === b[key][idx])) {
                continue;
            }
            else {
                same = false;
                break;
            }
        }
        if (!same) {
            break;
        }
    }
    return same;
}
function buildEffectInfo(node, popovers /* HTMLArcgisEffectsPopoversElement[] */, props) {
    const type = node.value;
    switch (type) {
        case "bloom":
            return buildEffectInfoBloom(popovers[type], props);
        case "dropShadow":
            return buildEffectInfoDropShadow(popovers[type], props);
        case "blur":
            return buildEffectInfoBlur(popovers[type], props);
        case "brightnessContrast":
            return buildEffectInfoBrightnessContrast(popovers[type]);
        case "grayscale":
            return buildEffectInfoGrayscale(popovers[type]);
        case "hueRotate":
            return buildEffectInfoHueRotate(popovers[type]);
        case "saturate":
            return buildEffectInfoSaturate(popovers[type]);
        case "invert":
            return buildEffectInfoInvert(popovers[type]);
        case "sepia":
            return buildEffectInfoSepia(popovers[type]);
    }
}
function buildEffectInfoBloom(node /* HTMLArcgisEffectsPopoversElement */, props) {
    // strength, radius, threshold
    // bloom(200%, 1px, 0.2)";
    // bloom(2, 1px, 20%)";
    // bloom(2, 1px, 0.1)
    const numberNodes = node.querySelectorAll("calcite-input");
    let strength = getValue(numberNodes[0]);
    let radius = getValue(numberNodes[1]);
    let threshold = getValue(numberNodes[2]);
    if (!isDefined(strength) || !isDefined(radius) || !isDefined(threshold)) {
        return null;
    }
    strength = Math.round(strength * 10) / 10;
    radius = px2ptRoundTo3(Math.round(radius * 10) / 10, props);
    threshold = Math.round(threshold);
    threshold /= 100;
    lastLayerEffectValues.bloom = { strength, radius, threshold };
    const autoNode = node.querySelector(".auto");
    if (!autoNode.checked) {
        return `bloom(${strength}, ${radius}pt, ${threshold})`;
    }
    else {
        const { view } = props;
        const currentScale = view.scale;
        const factor = 2;
        const invFactor = 1 / factor;
        return [
            {
                // the original values have been doubled after two zoom level in
                scale: currentScale * 0.25,
                value: `bloom(${strength * factor}, ${radius * factor}pt, ${threshold})`
            },
            {
                scale: currentScale,
                value: `bloom(${strength}, ${radius}pt, ${threshold})`
            },
            {
                // the original values have been halved after two zooms level out
                scale: currentScale * 4,
                value: `bloom(${strength * invFactor}, ${radius * invFactor}pt, ${threshold})`
            }
        ];
    }
}
function buildEffectInfoDropShadow(node /* HTMLArcgisEffectsPopoversElement */, props) {
    // x offset, y offset, blur radius (=width) hsl(hue, saturation, lightness, alpha)
    // "drop-shadow(3px, 3px, 4px)"
    const color = node.querySelector("calcite-color-picker");
    const rgb = hexToRgb(color.value);
    const numberNodes = node.querySelectorAll("calcite-input");
    let blurRadius = getValue(numberNodes[0]);
    let xoffset = getValue(numberNodes[1]);
    let yoffset = getValue(numberNodes[2]);
    let opacity = getValue(numberNodes[3]);
    if (!isDefined(color.value) ||
        !isDefined(blurRadius) ||
        !isDefined(xoffset) ||
        !isDefined(yoffset) ||
        !isDefined(opacity)) {
        return null;
    }
    blurRadius = px2ptRoundTo3(Math.round(blurRadius), props);
    xoffset = px2ptRoundTo3(Math.round(xoffset), props);
    yoffset = px2ptRoundTo3(Math.round(yoffset), props);
    opacity = Math.round(opacity);
    opacity /= 100;
    lastLayerEffectValues.dropShadow[getSimpleGeometryType(props)] = {
        color: [rgb.r, rgb.g, rgb.b, opacity * 255],
        xoffset,
        yoffset,
        blurRadius
    };
    //const hsl = hexToHSL(color.value as any);
    //const colorStr = `hsla(${Math.round(hsl.h * 360)}, ${hsl.s * 100}%, ${hsl.l * 100}%, ${opacity})`;
    const colorStr = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
    const autoNode = node.querySelector(".auto");
    if (!autoNode.checked) {
        return `drop-shadow(${xoffset}pt ${yoffset}pt ${blurRadius}pt ${colorStr})`;
    }
    else {
        const { view } = props;
        const currentScale = view.scale;
        const factor = 2;
        const invFactor = 1 / factor;
        return [
            {
                // the original values have been doubled after two zoom level in
                scale: currentScale * 0.25,
                value: `drop-shadow(${xoffset * factor}pt ${yoffset * factor}pt ${blurRadius * factor}pt ${colorStr})`
            },
            {
                scale: currentScale,
                value: `drop-shadow(${xoffset}pt ${yoffset}pt ${blurRadius}pt ${colorStr})`
            },
            {
                // the original values have been halved after two zooms level out
                scale: currentScale * 4,
                value: `drop-shadow(${xoffset * invFactor}pt ${yoffset * invFactor}pt ${blurRadius * invFactor}pt ${colorStr})`
            }
        ];
    }
}
function buildEffectInfoBlur(node /* HTMLArcgisEffectsPopoversElement */, props) {
    // blur(10px)
    const numberNode = node.querySelector("calcite-input");
    let radius = getValue(numberNode);
    if (!isDefined(radius)) {
        return null;
    }
    radius = px2ptRoundTo3(Math.round(radius * 10) / 10, props);
    lastLayerEffectValues.blur = { radius };
    return `blur(${radius}pt)`;
}
function buildEffectInfoBrightnessContrast(node /* HTMLArcgisEffectsPopoversElement */) {
    // brightness(100%) contrast(100%)
    const numberNodes = node.querySelectorAll("calcite-input");
    let brightness = getValue(numberNodes[0]);
    let contrast = getValue(numberNodes[1]);
    if (!isDefined(brightness) || !isDefined(contrast)) {
        return null;
    }
    brightness = Math.round(brightness) / 100;
    contrast = Math.round(contrast) / 100;
    lastLayerEffectValues.brightness = { amount: brightness };
    lastLayerEffectValues.contrast = { amount: contrast };
    return `brightness(${brightness}) contrast(${contrast})`;
}
function buildEffectInfoGrayscale(node /* HTMLArcgisEffectsPopoversElement */) {
    // grayscale(25%)
    const numberNode = node.querySelector("calcite-input");
    let amount = getValue(numberNode);
    if (!isDefined(amount)) {
        return null;
    }
    amount = Math.round(amount) / 100;
    lastLayerEffectValues.grayscale = { amount };
    return `grayscale(${amount})`;
}
function buildEffectInfoHueRotate(node /* HTMLArcgisEffectsPopoversElement */) {
    // hue-rotate(270deg)
    const numberNode = node.querySelector("calcite-input");
    let angle = getValue(numberNode);
    if (!isDefined(angle)) {
        return null;
    }
    angle = Math.round(angle);
    lastLayerEffectValues.hueRotate = { angle };
    return `hue-rotate(${angle}deg)`;
}
function buildEffectInfoSaturate(node /* HTMLArcgisEffectsPopoversElement */) {
    // saturate(100%)
    const numberNode = node.querySelector("calcite-input");
    let amount = getValue(numberNode);
    if (!isDefined(amount)) {
        return null;
    }
    amount = Math.round(amount) / 100;
    lastLayerEffectValues.saturate = { amount };
    return `saturate(${amount})`;
}
function buildEffectInfoInvert(node /* HTMLArcgisEffectsPopoversElement */) {
    // invert(100%)
    const numberNode = node.querySelector("calcite-input");
    let amount = getValue(numberNode);
    if (!isDefined(amount)) {
        return null;
    }
    amount = Math.round(amount) / 100;
    lastLayerEffectValues.invert = { amount };
    return `invert(${amount})`;
}
function buildEffectInfoSepia(node /* HTMLArcgisEffectsPopoversElement */) {
    // sepia(50%)
    const numberNode = node.querySelector("calcite-input");
    let amount = getValue(numberNode);
    if (!isDefined(amount)) {
        return null;
    }
    amount = Math.round(amount) / 100;
    lastLayerEffectValues.sepia = { amount };
    return `sepia(${amount})`;
}
/* function hexToHSL(hex: string): any {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  let r = parseInt(result[1], 16);
  let g = parseInt(result[2], 16);
  let b = parseInt(result[3], 16);
  (r /= 255), (g /= 255), (b /= 255);
  const max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  let h,
    s,
    l = (max + min) / 2;
  if (max == min) {
    h = s = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  const HSL = new Object();
  HSL["h"] = h;
  HSL["s"] = s;
  HSL["l"] = l;
  return HSL;
} */
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        }
        : null;
}
function getValue(node) {
    const value = Number(node.value);
    if (!isDefined(value)) {
        return null;
    }
    const clamped = Math.min(node.max, Math.max(node.min, value));
    // ensure value is within allowed range
    node.value = `${clamped}`;
    return clamped;
}
function px2ptRoundTo3(value, props) {
    const { modules } = props;
    const { screenUtils } = modules;
    return Math.round(screenUtils.px2pt(value) * 1000) / 1000;
}

function getDefaultField(props) {
    var _a, _b, _c, _d, _e;
    const { layer } = props;
    const { renderer } = layer;
    if (!renderer) {
        return null;
    }
    // not looking at Arcade expressions
    switch (renderer.type) {
        case "unique-value": {
            // types, predominance, relationship
            if (((_a = renderer.authoringInfo) === null || _a === void 0 ? void 0 : _a.type) === "predominance") {
                return renderer.uniqueValueInfos[0].value;
            }
            else if (((_b = renderer.authoringInfo) === null || _b === void 0 ? void 0 : _b.type) === "relationship") {
                return renderer.authoringInfo.field1.field;
            }
            else {
                return renderer.field;
            }
        }
        case "class-breaks": {
            // color, size
            if (renderer.visualVariables) {
                let fieldName = (_c = renderer.visualVariables.find((visVar) => visVar.type === "color")) === null || _c === void 0 ? void 0 : _c.field;
                if (fieldName) {
                    return fieldName;
                }
                fieldName = (_d = renderer.visualVariables.find((visVar) => visVar.type === "size" && !visVar.target && visVar.valueExpression !== "$view.scale")) === null || _d === void 0 ? void 0 : _d.field;
                if (fieldName) {
                    return fieldName;
                }
            }
            else {
                return renderer.field;
            }
            break;
        }
        case "dot-density":
            return (_e = renderer.attributes) === null || _e === void 0 ? void 0 : _e[0].field;
    }
    return null;
}

const arcgisEffectsCss = ":host{height:100%}.flow{height:100%}.panel{height:100%}.notice{margin:0.5rem}.radio-buttons{padding:0.5rem;background-color:white}.hint{padding:0.25rem 0.5rem;background-color:white}.basemap-type{padding:0.75rem 0.5rem 0.25rem 0.5rem}.switch{margin-right:0.75rem;margin-left:0;align-self:center}.list{flex-flow:column nowrap;margin:1px}.effect-thumb{display:flex;align-items:center;padding-left:0.5rem;cursor:pointer}.effect-thumb-img{margin-top:0.25rem;margin-bottom:0.25rem;height:48px;width:48px}.arcgis--rtl .switch{margin-left:0.75rem;margin-right:0}.arcgis--rtl .effect-thumb{padding-left:0;padding-right:0.5rem}";

const ArcgisEffects = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisEffectsClose = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsClose", 7);
        this.arcgisEffectsChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsChange", 7);
        this.arcgisEffectsApplyLayerEffect = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsApplyLayerEffect", 7);
        this.popovers = [];
        this.imagesPath = "../arcgis-app-assets/images/effects/test.jpg";
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.afterCreatePanel = (node) => {
            this.panelNode = node;
            const { props } = this;
            const { featureEffectType, supportsFeatureEffects } = props;
            // open all popovers so we have access to all current props
            // feature effects all share one popover
            const { popovers, panelNode } = this;
            if (popovers) {
                // remove them
                this.done();
            }
            // wait until panelNode has dimensions
            setTimeout(() => {
                let allTypes = supportsFeatureEffects
                    ? allLayerEffectTypes.concat(["featureEffect"])
                    : allLayerEffectTypes;
                allTypes.forEach((type) => {
                    popovers[type] = document.createElement(`arcgis-effects-popovers`);
                    popovers[type].props = props;
                    popovers[type].type = type;
                    popovers[type].referenceElement = panelNode;
                    popovers[type].popovers = popovers;
                    document.body.appendChild(popovers[type]);
                });
                if (featureEffectType) {
                    // we're starting with a set feature effect
                    const popover = popovers["featureEffect"];
                    popover.open = true;
                    popover.updateHeader(featureEffectType);
                }
            }, 1000);
        };
        this.onSwitchEffectType = (event) => {
            const { props, popovers } = this;
            const layer = props.layer;
            const node = event.target;
            // close all popovers
            let key;
            for (key in popovers) {
                popovers[key].open = false;
            }
            if (node.selectedItem.value === "layer") {
                this.lastFeatureEffect = layer.featureEffect || this.lastFeatureEffect;
                layer.featureEffect = null;
                layer.effect = this.lastLayerEffect;
                this.showFeatureEffects = false;
            }
            else {
                // "feature"
                this.lastLayerEffect = layer.effect;
                layer.effect = null;
                if (this.lastFeatureEffect) {
                    layer.featureEffect = this.lastFeatureEffect;
                    props.featureEffectType = parseEffects(props);
                }
                else {
                    const { backgroundTheme } = props;
                    this.selectFeatureEffectType(backgroundTheme === "light" ? allLightFeatureEffectTypes[0] : allDarkFeatureEffectTypes[0]);
                }
                this.showFeatureEffects = true;
                const popover = popovers["featureEffect"];
                popover.open = true;
                popover.updateHeader(props.featureEffectType);
            }
            this.reRender = !this.reRender;
        };
        this.onRemoveEffect = () => {
            const { props } = this;
            const { layer } = props;
            layer.effect = null;
            layer.featureEffect = null;
            this.isUnsupported = false;
        };
        this.onSwitchChange = (event) => {
            const { popovers } = this;
            const switchNode = event.target;
            const itemNode = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.q)(switchNode, "calcite-value-list-item");
            const type = itemNode.value;
            if (!switchNode.checked) {
                popovers[type].open = false;
                itemNode.selected = false;
            }
            this.arcgisEffectsApplyLayerEffect.emit({ type, keepSwitch: true });
        };
        this.onFeatureEffectEnabledSwitchChange = (event) => {
            const { popovers, props, lightListNode, darkListNode } = this;
            const layer = props.layer;
            const switchNode = event.target;
            if (!switchNode.checked) {
                popovers["featureEffect"].open = false;
                lightListNode === null || lightListNode === void 0 ? void 0 : lightListNode.querySelectorAll("calcite-value-list-item").forEach((item) => (item.selected = false));
                darkListNode === null || darkListNode === void 0 ? void 0 : darkListNode.querySelectorAll("calcite-value-list-item").forEach((item) => (item.selected = false));
                this.lastFeatureEffect = layer.featureEffect;
                layer.featureEffect = null;
                this.arcgisEffectsChange.emit();
            }
            else {
                if (this.lastFeatureEffect) {
                    layer.featureEffect = this.lastFeatureEffect;
                    props.featureEffectType = parseEffects(props);
                }
                else {
                    const { backgroundTheme } = props;
                    props.featureEffectType =
                        backgroundTheme === "light"
                            ? allLightFeatureEffectTypes[0]
                            : allDarkFeatureEffectTypes[0];
                }
                lightListNode === null || lightListNode === void 0 ? void 0 : lightListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
                    if (item.value === props.featureEffectType) {
                        item.selected = true;
                    }
                });
                darkListNode === null || darkListNode === void 0 ? void 0 : darkListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
                    if (item.value === props.featureEffectType) {
                        item.selected = true;
                    }
                });
                this.selectFeatureEffectType(props.featureEffectType);
            }
        };
        this.openPopover = (event) => {
            const { popovers } = this;
            const target = event.target;
            const tagName = target.tagName.toLowerCase();
            let itemNode;
            if (tagName === "img") {
                itemNode = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.q)(target, "calcite-value-list-item");
            }
            else if (tagName === "calcite-switch") {
                if (target.checked) {
                    itemNode = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.q)(target, "calcite-value-list-item");
                }
                else {
                    return;
                }
            }
            else if (tagName === "calcite-value-list-item") {
                itemNode = target;
            }
            else {
                return;
            }
            itemNode.selected = true;
            const type = itemNode.value;
            const isFeatureEffectType = allLightFeatureEffectTypes.concat(allDarkFeatureEffectTypes).indexOf(type) > -1;
            if (isFeatureEffectType) {
                this.selectFeatureEffectType(type);
            }
            else {
                // layer effects
                const switchNode = itemNode.querySelector("calcite-switch");
                if (popovers[type].open) {
                    // if already open then close popover and toggle off
                    popovers[type].open = false;
                    switchNode.checked = false;
                    itemNode.selected = false;
                    this.arcgisEffectsApplyLayerEffect.emit();
                }
                else {
                    // switch effect on
                    if (!switchNode.checked) {
                        switchNode.checked = true;
                        this.arcgisEffectsApplyLayerEffect.emit();
                    }
                    // close other popovers
                    let key;
                    for (key in popovers) {
                        popovers[key].open = false;
                    }
                    popovers[type].open = true;
                }
            }
        };
        this.view = undefined;
        this.layer = undefined;
        this.hideLayerTitle = false;
        this.props = undefined;
        this.reRender = false;
        this.isUnsupported = false;
        this.showFeatureEffects = false;
    }
    arcgisEffectsApplyLayerEffectHandler(event) {
        var _a, _b;
        const { props, listNode } = this;
        const { layer } = props;
        const type = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.type;
        if (type && !((_b = event.detail) === null || _b === void 0 ? void 0 : _b.keepSwitch)) {
            // toggle effect on if it's not already
            const itemNode = Array.from(listNode.querySelectorAll("calcite-value-list-item")).filter((item) => item.value === type)[0];
            itemNode.querySelector("calcite-switch").checked = true;
        }
        const effects = buildEffectsInfo(this.listNode, this.popovers, props);
        layer.effect = effects;
        this.arcgisEffectsChange.emit();
        props.effectsJSON = parseEffects(props);
        // refresh to get the numbers
        //this.reRender = !this.reRender;
    }
    arcgisEffectsPopoverFilterChangeHandler(event) {
        const { props, hostElement } = this;
        const { layer } = props;
        const where = event.detail;
        const itemNode = Array.from(hostElement.shadowRoot.querySelectorAll("calcite-value-list-item")).find((node) => node.selected);
        const type = itemNode === null || itemNode === void 0 ? void 0 : itemNode.value;
        if (!type) {
            // we're too early, but need to apply the filter later once a type gets selected
            this.defaultWhere = where;
        }
        else {
            // a feature effect type is selected
            layer.featureEffect = buildFeatureEffect(type, where, props);
            this.arcgisEffectsChange.emit();
        }
    }
    arcgisEffectsPopoverCloseHandler() {
        const { listNode, lightListNode, darkListNode } = this;
        listNode === null || listNode === void 0 ? void 0 : listNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
            if (item.selected) {
                item.selected = false;
                item.setFocus();
            }
        });
        lightListNode === null || lightListNode === void 0 ? void 0 : lightListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
            if (item.selected) {
                item.setFocus();
            }
        });
        darkListNode === null || darkListNode === void 0 ? void 0 : darkListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
            if (item.selected) {
                item.setFocus();
            }
        });
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Set focus on component
     */
    async setFocus(focusId) {
        var _a, _b;
        if (!focusId || focusId === "dismiss-button") {
            (_a = this.panelNode) === null || _a === void 0 ? void 0 : _a.setFocus();
            return;
        }
        (_b = this.listNode) === null || _b === void 0 ? void 0 : _b.setFocus();
    }
    /**
     * Cleans up component, closes popovers
     */
    async done() {
        const { popovers } = this;
        // close  popovers
        let key;
        for (key in popovers) {
            popovers[key].open = false;
        }
        document.body
            .querySelectorAll("arcgis-effects-popovers")
            .forEach((node) => node.parentNode.removeChild(node));
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const { view, layer } = this;
        const [strings, currentLanguage] = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.hostElement);
        this.strings = strings;
        const supportsFeatureEffects = !layer.featureReduction &&
            ["feature", "geojson", "ogc-feature", "wfs", "csv", "stream"].indexOf(layer.type) > -1;
        this.props = { view, layer, strings, supportsFeatureEffects };
        const { props } = this;
        props.locale = currentLanguage;
        const [FeatureEffect, effectsUtils, screenUtils, colorUtils] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_4__.l)([
            "esri/layers/support/FeatureEffect",
            "esri/layers/effects/jsonUtils",
            "esri/core/screenUtils",
            "esri/views/support/colorUtils"
        ]);
        props.modules = { FeatureEffect, effectsUtils, screenUtils };
        props.backgroundTheme = view && (await colorUtils.getBackgroundColorTheme(view));
        try {
            const anyLayer = layer;
            if (anyLayer.effect && anyLayer.featureEffect) {
                this.isUnsupported = true;
            }
            else if (anyLayer.effect) {
                props.effectsJSON = parseEffects(props);
                //console.log("layer.effect", (layer as any).effect, props.effectsJSON);
                sortEffects(props);
            }
            else if (anyLayer.featureEffect) {
                props.featureEffectType = parseEffects(props);
            }
        }
        catch (e) {
            this.isUnsupported = true;
        }
    }
    componentDidLoad() {
        requestAnimationFrame(() => this.setFocus());
    }
    disconnectedCallback() {
        this.done();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        // filter (9.4) only for these layer types (not heatmap): __esri.FeatureLayer | __esri.CSVLayer | __esri.WFSLayer | __esri.StreamLayer
        const { isUnsupported } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow", { class: CSS$1.flow, dir: (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement), ref: (node) => (this.flowNode = node) }, isUnsupported ? this.renderUnsupported() : this.renderContent())));
    }
    renderUnsupported() {
        const { props, hideLayerTitle } = this;
        const { layer, strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { heading: strings.general.effects, description: !hideLayerTitle ? layer.title : undefined, class: {
                [CSS$1.panel]: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__.C.rtl]: rtl
            }, closable: true, onCalcitePanelClose: () => {
                this.arcgisEffectsClose.emit();
            }, ref: (node) => (this.panelNode = node) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tip", { heading: strings.error.title, closeDisabled: true }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, strings.error.text1), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, strings.error.text2)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-fab", { class: "autofocus", slot: "fab", appearance: "outline-fill", kind: "neutral", scale: "s", textEnabled: true, icon: null, label: strings.error.button, text: strings.error.button, onClick: this.onRemoveEffect })));
    }
    renderContent() {
        const { props, hideLayerTitle, showFeatureEffects } = this;
        const { layer, supportsFeatureEffects, strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement) === "rtl";
        const hasFeatureEffect = supportsFeatureEffects && !!layer.featureEffect;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { heading: strings.general.effects, description: !hideLayerTitle ? layer.title : undefined, class: {
                [CSS$1.panel]: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__.C.rtl]: rtl
            }, closable: true, onCalcitePanelClose: () => {
                // close all popovers
                const { popovers } = this;
                let key;
                for (key in popovers) {
                    popovers[key].open = false;
                }
                this.arcgisEffectsClose.emit();
            }, ref: this.afterCreatePanel }, this.renderTip(), supportsFeatureEffects ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.radioButtons }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control", { layout: "horizontal", appearance: "solid", scale: "s", width: "full", onCalciteSegmentedControlChange: this.onSwitchEffectType }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "layer", checked: !(hasFeatureEffect || showFeatureEffects) }, strings.general.wholeLayer), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "feature", checked: hasFeatureEffect || showFeatureEffects }, strings.general.featureSpecific)))) : null, hasFeatureEffect || showFeatureEffects
            ? this.renderFeatureEffectsContent()
            : this.renderLayerEffectsContent()));
    }
    renderTip() {
        const { props } = this;
        const { strings } = props;
        if ((0,_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_5__.g)(_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_5__.l.ARCGIS_COMPONENT_NOTIFICATIONS, _localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_5__.a.EFFECTS_TIP_DISMISSED)) {
            return null;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.notice }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { scale: "s", width: "full", open: true, closable: true, onCalciteNoticeClose: () => {
                (0,_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_5__.s)(_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_5__.l.ARCGIS_COMPONENT_NOTIFICATIONS, {
                    key: _localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_5__.a.EFFECTS_TIP_DISMISSED,
                    value: "true"
                });
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, strings.general.notice))));
    }
    renderLayerEffectsContent() {
        const { strings } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.hint }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.general.dragToReorder)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list", { class: CSS$1.list, dragEnabled: true, onCalciteListOrderChange: () => this.arcgisEffectsApplyLayerEffect.emit(), ref: (node) => (this.listNode = node) }, allLayerEffectTypes.map((type) => this.renderLayerEffectItem(type)))));
    }
    renderLayerEffectItem(type) {
        var _a;
        const { props } = this;
        const { effectsJSON, strings } = props;
        let effectPos = -1;
        effectsJSON &&
            ((_a = Array.from(effectsJSON)) === null || _a === void 0 ? void 0 : _a.forEach((effect, idx) => {
                if (effect.type === convertToAPIType(type)) {
                    effectPos = idx + 1;
                }
            }));
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list-item", { label: strings.effectsTitle[type], description: strings.effectsSummary[type], value: type, onClick: this.openPopover, onKeyDown: (event) => {
                if (event.key === "Enter") {
                    this.openPopover(event);
                }
                // space key is reserved for drag-n-drop
                if (event.key === " ") {
                    const composedPath = event.composedPath();
                    const firstElement = composedPath[0];
                    if (firstElement.tagName !== "SPAN" || !firstElement.classList.contains("handle")) {
                        this.openPopover(event);
                    }
                }
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "actions-start", class: CSS$1.effectThumb }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("img", { class: CSS$1.effectThumbImg,
            //class={`${CSS.effectThumbImg} ${effectPos > 0 ? `blur` : ``}`}
            src: (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/effect-thumbs/${type}.png`), alt: "" })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { scale: "s", checked: effectPos > 0, slot: "actions-end", class: CSS$1.switch, onCalciteSwitchChange: this.onSwitchChange })));
    }
    renderFeatureEffectsContent() {
        const { props, lastFeatureEffect, strings } = this;
        const { layer, backgroundTheme } = props;
        const isLightBackground = backgroundTheme === "light";
        const lightContent = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.basemapType }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.general.lightBasemaps)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list", { class: CSS$1.list, "data-value": "light", ref: (node) => (this.lightListNode = node) }, allLightFeatureEffectTypes.map((type) => this.renderFeatureEffectItem(type, "light")))));
        const darkContent = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.basemapType }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.general.darkBasemaps)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list", { class: CSS$1.list, "data-value": "dark", ref: (node) => (this.darkListNode = node) }, allDarkFeatureEffectTypes.map((type) => this.renderFeatureEffectItem(type, "dark")))));
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.hint }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.general.emphasize), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", layout: "inline-space-between" }, strings.general.enabled, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { scale: "s", checked: !!(layer.featureEffect || lastFeatureEffect), onCalciteSwitchChange: this.onFeatureEffectEnabledSwitchChange, ref: (node) => (this.enabledSwitchNode = node) }))), isLightBackground ? lightContent : darkContent, isLightBackground ? darkContent : lightContent));
    }
    renderFeatureEffectItem(type, theme) {
        const { props } = this;
        const { featureEffectType, strings } = props;
        const inLight = allLightFeatureEffectTypes.find((feType) => type === feType);
        const inDark = allDarkFeatureEffectTypes.find((feType) => type === feType);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list-item", { label: strings.featureEffectsTitle[type], description: strings.featureEffectsSummary[type], value: type, selected: featureEffectType === type, onClick: this.openPopover, onKeyDown: (event) => {
                if (event.key === "Enter") {
                    this.openPopover(event);
                }
                // space key is reserved for drag-n-drop
                if (event.key === " ") {
                    const composedPath = event.composedPath();
                    const firstElement = composedPath[0];
                    if (firstElement.tagName !== "SPAN" || !firstElement.classList.contains("handle")) {
                        this.openPopover(event);
                    }
                }
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "actions-start", class: CSS$1.effectThumb }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("img", { class: `${CSS$1.effectThumbImg} feature`, src: (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/effect-thumbs/${type}${inLight && inDark ? `_${theme}` : ``}.png`), alt: "" }))));
    }
    selectFeatureEffectType(type) {
        var _a, _b;
        const { popovers, props, lightListNode, darkListNode, defaultWhere, enabledSwitchNode } = this;
        const { layer } = props;
        props.featureEffectType = type;
        // unselect item from second list
        lightListNode === null || lightListNode === void 0 ? void 0 : lightListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
            if (item.selected && item.value !== type) {
                item.selected = false;
            }
        });
        darkListNode === null || darkListNode === void 0 ? void 0 : darkListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
            if (item.selected && item.value !== type) {
                item.selected = false;
            }
        });
        // feature effects
        layer.featureEffect = buildFeatureEffect(type, ((_b = (_a = layer.featureEffect) === null || _a === void 0 ? void 0 : _a.filter) === null || _b === void 0 ? void 0 : _b.where) || defaultWhere, props);
        this.defaultWhere = undefined;
        this.arcgisEffectsChange.emit();
        const popover = popovers["featureEffect"];
        if (popover.open) {
            // if already open then just rename title
            popover.updateHeader(type);
        }
        else {
            // close other popovers
            let key;
            for (key in popovers) {
                popovers[key].open = false;
            }
            popover.open = true;
            popover.updateHeader(type);
        }
        if (enabledSwitchNode) {
            // after a list click
            enabledSwitchNode.checked = true;
        }
        else {
            // after a layer effect -> feature effect switch
            this.reRender = !this.reRender;
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisEffects.style = arcgisEffectsCss;

const CSS = {
    popover: "popover",
    panel: "panel",
    auto: "auto",
    content: "effects-content",
    bottomSpace: "bottom-space",
    bottomSpaceLittle: "bottom-space-little",
    switch: "switch",
    reset: "reset",
    subHeader: "sub-header"
};

const SelectCSS$1 = {
    base: "select-number",
    input: "select-number__input"
};
const stepperClickHandlerForProperFocus$1 = (event) => {
    // workaround for calcite-label wrapped SelectNumber focus bug
    event.stopPropagation();
};
const calciteLabelClickHandlerForProperFocus = (event) => {
    var _a, _b;
    // workaround for calcite-label wrapped SelectNumber focus bug
    (_b = (_a = event.target).setFocus) === null || _b === void 0 ? void 0 : _b.call(_a);
    event.preventDefault();
};
const SelectNumber = (props) => {
    const { disabled, min, max, step, value, units, classNames, label } = props;
    return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `${SelectCSS$1.base} ${classNames}` },
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-slider", { disabled: disabled, min: min, max: max, value: value, step: step, snap: true, labelTicks: true, ticks: max - min, minLabel: label, onCalciteSliderInput: (event) => applyValueOnChange$1(event, props) }),
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { type: "number", onClick: stepperClickHandlerForProperFocus$1, disabled: disabled, min: min, max: max, value: `${value}`, scale: "s", step: step, suffixText: units, onCalciteInputInput: (event) => applyValueOnChange$1(event, props), class: SelectCSS$1.input, label: label })));
};
function applyValueOnChange$1(event, props) {
    const { locale } = props;
    const node = event.currentTarget;
    const sliderNode = node.parentElement.querySelector("calcite-slider");
    const inputNode = node.parentElement.querySelector("calcite-input");
    const value = Number(node.value);
    const clamped = Math.min(props.max, Math.max(props.min, value));
    if (clamped === sliderNode.value && `${clamped}` === inputNode.value) {
        // no changes
        return;
    }
    // ensure value we show is within allowed range
    sliderNode.value = clamped;
    inputNode.value = `${clamped}`;
    // TODO workaround for https://github.com/Esri/calcite-components/issues/3003
    const clampedString = clamped.toLocaleString(locale);
    inputNode
        .querySelectorAll("input")
        .forEach((input) => (input.value = clampedString));
    props.onValueChange(clamped, node);
}

const SelectCSS = {
    base: "select-xy",
    input: "select-xy__input"
};
const stepperClickHandlerForProperFocus = (event) => {
    // workaround for calcite-label wrapped SelectXy focus bug
    event.stopPropagation();
};
const SelectXy = (props) => {
    const { min, max, step, x, y, classNames, strings, locale } = props;
    let hostNode;
    return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `${SelectCSS.base} ${classNames}`, ref: (node) => (hostNode = node) },
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-xy-slider", { "data-value": "slider", minX: min, maxX: max, minY: min, maxY: max, x: x, y: y, step: step, snappable: true, onArcgisXYSliderInput: (event) => {
                const slider = event.currentTarget;
                const emittingActiveFlagAttribute = "data-active";
                // we ignore the first event since it's caused by the
                // value snapping to a step interval during initialization
                if (!slider.hasAttribute(emittingActiveFlagAttribute)) {
                    slider.setAttribute(emittingActiveFlagAttribute, "");
                    return;
                }
                applyValueOnChange(event, props, hostNode);
            } }),
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
            (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" },
                strings.effectsProps.xOffset,
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { "data-value": "x", type: "number", min: min, max: max, step: step, lang: locale, value: `${x}`, class: SelectCSS.input, scale: "s", onClick: stepperClickHandlerForProperFocus, onCalciteInputInput: (event) => applyValueOnChange(event, props, hostNode) })),
            (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" },
                strings.effectsProps.yOffset,
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { "data-value": "y", type: "number", min: min, max: max, step: step, lang: locale, value: `${y}`, class: SelectCSS.input, scale: "s", onClick: stepperClickHandlerForProperFocus, onCalciteInputInput: (event) => applyValueOnChange(event, props, hostNode) })))));
};
function applyValueOnChange(event, props, hostNode) {
    const { step, locale } = props;
    const node = event.currentTarget;
    const dataValue = node.getAttribute("data-value");
    const sliderNode = hostNode.querySelector("arcgis-xy-slider");
    const inputNodes = hostNode.querySelectorAll("calcite-input");
    const origValueX = Number(dataValue === "slider"
        ? node.x
        : dataValue === "x"
            ? node.value
            : inputNodes[0].value);
    const origValueY = Number(dataValue === "slider"
        ? node.y
        : dataValue === "y"
            ? node.value
            : inputNodes[1].value);
    // make sure we don't get more precision than step
    // slider returns values like 1.9000000000000001 (#2928)
    const decimalsCount = countDecimalDigits(step);
    const factor = Math.pow(10, decimalsCount);
    const x = Math.round(origValueX * factor) / factor;
    const y = Math.round(origValueY * factor) / factor;
    const xClamped = Math.min(props.max, Math.max(props.min, x));
    const yClamped = Math.min(props.max, Math.max(props.min, y));
    if (xClamped === sliderNode.x &&
        `${xClamped}` === inputNodes[0].value &&
        yClamped === sliderNode.y &&
        `${yClamped}` === inputNodes[1].value) {
        // no changes
        return;
    }
    // ensure value we show is within allowed range
    sliderNode.x = xClamped;
    sliderNode.y = yClamped;
    inputNodes[0].value = `${xClamped}`;
    inputNodes[1].value = `${yClamped}`;
    // TODO workaround for https://github.com/Esri/calcite-components/issues/3003
    const xClampedString = xClamped.toLocaleString(locale);
    const yClampedString = yClamped.toLocaleString(locale);
    inputNodes[0]
        .querySelectorAll("input")
        .forEach((input) => (input.value = xClampedString));
    inputNodes[1]
        .querySelectorAll("input")
        .forEach((input) => (input.value = yClampedString));
    props.onValueChange(xClamped, yClamped, node);
}
function countDecimalDigits(number) {
    if (number === null || number === undefined) {
        return 0;
    }
    const char_array = number.toString().split(""); // split every single char
    const not_decimal = char_array.lastIndexOf(".");
    return not_decimal < 0 ? 0 : char_array.length - not_decimal;
}

const arcgisEffectsPopoversCss = ".select-number.sc-arcgis-effects-popovers{display:flex;align-items:center;justify-content:space-between;position:relative}.select-number.sc-arcgis-effects-popovers calcite-slider.sc-arcgis-effects-popovers{width:58%;height:30px;margin:0 4px;overflow-wrap:normal;word-break:normal}.select-number__input.sc-arcgis-effects-popovers{width:35%;font-size:var(--arcgis-app-font-size-0);font-family:var(--arcgis-app-font-family)}.select-xy.sc-arcgis-effects-popovers{display:flex;align-items:center}.select-xy.sc-arcgis-effects-popovers arcgis-xy-slider.sc-arcgis-effects-popovers{width:120px;min-width:120px;margin:0 10px}.select-xy__input.sc-arcgis-effects-popovers{width:100%;font-size:var(--arcgis-app-font-size-0);font-family:var(--arcgis-app-font-family)}.popover.sc-arcgis-effects-popovers{z-index:99}.panel.sc-arcgis-effects-popovers{width:325px}.panel.filter.sc-arcgis-effects-popovers{min-height:500px;background-color:var(--calcite-color-background)}.effects-content.sc-arcgis-effects-popovers{padding:1rem;background-color:white;max-height:80vh}.bottom-space.sc-arcgis-effects-popovers{margin-bottom:1.8rem}.bottom-space-little.sc-arcgis-effects-popovers{margin-bottom:0.5rem}.switch.sc-arcgis-effects-popovers{width:100%;display:flex;justify-content:space-between}.reset.sc-arcgis-effects-popovers{display:flex;align-items:center}.sub-header.sc-arcgis-effects-popovers{margin-left:0.75rem;margin-right:0}.arcgis--rtl.sc-arcgis-effects-popovers .sub-header.sc-arcgis-effects-popovers{margin-right:0.75rem;margin-left:0}";

const ArcgisEffectsPopovers = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisEffectsApplyLayerEffect = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsApplyLayerEffect", 7);
        this.arcgisEffectsPopoverFilterChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsPopoverFilterChange", 7);
        this.arcgisEffectsPopoverClose = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsPopoverClose", 7);
        //--------------------------------------------------------------------------
        //
        //  Private Properties
        //
        //--------------------------------------------------------------------------
        this.defaultExpression = false;
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.onOpen = () => {
            setTimeout(() => requestAnimationFrame(() => { var _a; return (_a = this.closeNode) === null || _a === void 0 ? void 0 : _a.setFocus(); }), 1);
        };
        this.onClose = () => {
            var _a;
            (_a = this.filterNode) === null || _a === void 0 ? void 0 : _a.closePopovers();
        };
        this.onPropChange = () => {
            const { type } = this;
            this.arcgisEffectsApplyLayerEffect.emit({ type });
        };
        this.onReset = () => {
            const { type, props, popoverNode } = this;
            const { modules } = props;
            const { screenUtils } = modules;
            const defaults = layerEffectDefaults[type];
            switch (type) {
                case "bloom": {
                    const inputs = popoverNode.querySelectorAll("calcite-input");
                    inputs[0].value = `${defaults.strength}`;
                    inputs[1].value = `${screenUtils.pt2px(defaults.radius)}`;
                    inputs[2].value = `${Math.round(defaults.threshold * 100)}`;
                    const sliders = popoverNode.querySelectorAll("calcite-slider");
                    sliders[0].value = defaults.strength;
                    sliders[1].value = screenUtils.pt2px(defaults.radius);
                    sliders[2].value = Math.round(defaults.threshold * 100);
                    break;
                }
                case "dropShadow": {
                    let geometryType = getSimpleGeometryType(props);
                    const colorPicker = popoverNode.querySelector("calcite-color-picker");
                    colorPicker.value = `${this.rgb2Hex(defaults[geometryType].color)}`;
                    const inputs = popoverNode.querySelectorAll("calcite-input");
                    inputs[0].value = `${Math.round(screenUtils.pt2px(defaults[geometryType].blurRadius))}`;
                    inputs[1].value = `${Math.round(screenUtils.pt2px(defaults[geometryType].xoffset))}`;
                    inputs[2].value = `${Math.round(screenUtils.pt2px(defaults[geometryType].yoffset))}`;
                    inputs[3].value = `${(defaults[geometryType].color[3] / 255) * 100}`;
                    const sliders = popoverNode.querySelectorAll("calcite-slider");
                    sliders[0].value = Math.round(screenUtils.pt2px(defaults[geometryType].blurRadius));
                    sliders[1].value = (defaults[geometryType].color[3] / 255) * 100;
                    const xySliders = popoverNode.querySelectorAll("arcgis-xy-slider");
                    xySliders[0].x = Math.round(screenUtils.pt2px(defaults[geometryType].xoffset));
                    xySliders[0].y = Math.round(screenUtils.pt2px(defaults[geometryType].yoffset));
                    break;
                }
                case "blur": {
                    popoverNode.querySelector("calcite-input").value = `${screenUtils.pt2px(defaults.radius)}`;
                    popoverNode.querySelector("calcite-slider").value = screenUtils.pt2px(defaults.radius);
                    break;
                }
                case "brightnessContrast": {
                    const defaultsBrightness = layerEffectDefaults["brightness"];
                    const defaultsContrast = layerEffectDefaults["contrast"];
                    const inputs = popoverNode.querySelectorAll("calcite-input");
                    inputs[0].value = `${Math.round(defaultsBrightness.amount * 100)}`;
                    inputs[1].value = `${Math.round(defaultsContrast.amount * 100)}`;
                    const sliders = popoverNode.querySelectorAll("calcite-slider");
                    sliders[0].value = Math.round(defaultsBrightness.amount * 100);
                    sliders[1].value = Math.round(defaultsContrast.amount * 100);
                    break;
                }
                case "grayscale": {
                    popoverNode.querySelector("calcite-input").value = `${defaults.amount * 100}`;
                    popoverNode.querySelector("calcite-slider").value = defaults.amount * 100;
                    break;
                }
                case "hueRotate": {
                    popoverNode.querySelector("calcite-input").value = `${defaults.angle}`;
                    popoverNode.querySelector("calcite-slider").value = defaults.angle;
                    break;
                }
                case "saturate": {
                    popoverNode.querySelector("calcite-input").value = `${defaults.amount * 100}`;
                    popoverNode.querySelector("calcite-slider").value = defaults.amount * 100;
                    break;
                }
                case "invert": {
                    popoverNode.querySelector("calcite-input").value = `${defaults.amount * 100}`;
                    popoverNode.querySelector("calcite-slider").value = defaults.amount * 100;
                    break;
                }
                case "sepia": {
                    popoverNode.querySelector("calcite-input").value = `${defaults.amount * 100}`;
                    popoverNode.querySelector("calcite-slider").value = defaults.amount * 100;
                    break;
                }
            }
            this.arcgisEffectsApplyLayerEffect.emit({ type });
        };
        this.props = undefined;
        this.type = undefined;
        this.open = false;
        this.referenceElement = undefined;
        this.popovers = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  public calls
    //
    //--------------------------------------------------------------------------
    async reposition() {
        var _a;
        (_a = this.popoverNode) === null || _a === void 0 ? void 0 : _a.reposition();
    }
    async updateHeader(type) {
        const { props, filterNode } = this;
        const { strings } = props;
        if (filterNode) {
            // close field-pick-list
            filterNode.closePopovers();
            filterNode.panelHeading = strings.featureEffectsTitle[type] || strings.effectsTitle[type];
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const { props } = this;
        const { layer } = props;
        if (!layer.featureEffect) {
            // don't start with empty filter, if possible
            this.defaultExpression = true;
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { props, referenceElement, type, open } = this;
        const { strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement) === "rtl";
        const isLongPopover = ["featureEffect", "dropShadow"].indexOf(type) > -1;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "js-app-flyout" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-popover", { dir: (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement), pointerDisabled: true, label: strings.effectsTitle[type], offsetDistance: 10, offsetSkidding: isLongPopover ? 10 : 100, open: open, placement: "leading-start", triggerDisabled: true, class: {
                "arcgis-effects-popover": true,
                popover: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__.C.rtl]: rtl
            }, referenceElement: referenceElement, onCalcitePopoverOpen: this.onOpen, onCalcitePopoverClose: this.onClose, ref: (node) => {
                this.popoverNode = node;
                //", popovers[type], node);
                //popovers[type] = node;
            } }, type === "featureEffect"
            ? this.renderFeatureEffectProps()
            : this.renderLayerEffectProps())));
    }
    renderLayerEffectProps() {
        const { props, referenceElement, type } = this;
        const { strings } = props;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement) === "rtl";
        const panelRect = referenceElement.getBoundingClientRect();
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { closable: false, heading: strings.effectsTitle[type], class: CSS.panel, style: {
                maxHeight: `${panelRect.height * 0.9}px`
            }, ref: (node) => (this.panelNode = node) }, [
            "bloom",
            "dropShadow",
            "blur",
            "brightnessContrast",
            "grayscale",
            "hueRotate",
            "saturate",
            "invert",
            "sepia"
        ].indexOf(type) > -1 ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: strings.effectsProps.reset, scale: "s", slot: "header-actions-end", title: strings.effectsProps.reset, onClick: this.onReset }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "s", icon: rtl ? "redo" : "undo" }))) : null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: strings.general.close, icon: "x", slot: "header-actions-end", title: strings.general.close, ref: (node) => (this.closeNode = node), onClick: () => {
                this.arcgisEffectsPopoverClose.emit();
                this.open = false;
                this.popoverNode.open = false;
                this.panelNode.closed = false;
            } }), type === "bloom" ? this.renderBloom() : null, type === "dropShadow" ? this.renderDropShadow() : null, type === "blur" ? this.renderBlur() : null, type === "brightnessContrast" ? this.renderBrightnessContrast() : null, type === "grayscale" ? this.renderGrayscale() : null, type === "hueRotate" ? this.renderHueRotate() : null, type === "saturate" ? this.renderSaturate() : null, type === "invert" ? this.renderInvert() : null, type === "sepia" ? this.renderSepia() : null));
    }
    renderBloom() {
        // "Bloom": `bloom(2,1px,0.1)`,
        // Strength (0-5) - step 0.1
        // Radius (0-5) - step 0.1
        // Threshold (0-1) - step 0.1
        const { props, type } = this;
        const { layer, strings, locale, modules } = props;
        const { screenUtils } = modules;
        const anyLayer = layer;
        const effectProps = getEffectProps(type, props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 5, step: 0.1, locale: locale, value: Math.round(effectProps.strength * 10) / 10, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.radius), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 5, step: 0.1, locale: locale, value: Math.round(screenUtils.pt2px(effectProps.radius) * 10) / 10, classNames: CSS.bottomSpace, label: strings.effectsProps.radius, onValueChange: this.onPropChange }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.threshold), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 100, step: 1, locale: locale, value: Math.round(effectProps.threshold * 100), classNames: CSS.bottomSpace, label: strings.effectsProps.threshold, onValueChange: this.onPropChange }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline-space-between", scale: "s", class: CSS.switch }, strings.effectsProps.autoAdjust, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { checked: !!(!anyLayer.effect || typeof anyLayer.effect !== "string"), scale: "s", class: CSS.auto, onCalciteSwitchChange: this.onPropChange }))));
    }
    renderDropShadow() {
        // "Drop shadow": `drop-shadow(1px,1px,2px,#000000)`,
        // X offset (-20-20) - step 1
        // Y offset (-20-20) - step 1
        // Blur radius (0-20) - step 1
        const { props, type } = this;
        const { layer, strings, locale, modules } = props;
        const { screenUtils } = modules;
        const anyLayer = layer;
        const effectProps = getEffectProps(type, props);
        const hexValue = this.rgb2Hex(effectProps.color);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.effectsProps.color, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-color-picker", { scale: "m", value: hexValue, hideSaved: true, onCalciteColorPickerInput: this.onPropChange })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.effectsProps.width), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 20, step: 1, locale: locale, value: Math.round(screenUtils.pt2px(effectProps.blurRadius)), classNames: CSS.bottomSpace, label: strings.effectsProps.width, onValueChange: this.onPropChange }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.effectsProps.offset, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectXy, { min: -20, max: 20, step: 1, locale: locale, x: Math.round(screenUtils.pt2px(effectProps.xoffset)), y: Math.round(screenUtils.pt2px(effectProps.yoffset)), classNames: CSS.bottomSpaceLittle, strings: strings, onValueChange: this.onPropChange })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.opacity), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 100, step: 1, locale: locale, value: (effectProps.color[3] / 255) * 100, classNames: CSS.bottomSpace, label: strings.effectsProps.opacity, onValueChange: this.onPropChange }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline-space-between", scale: "s", class: CSS.switch }, strings.effectsProps.autoAdjust, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { checked: !!(!anyLayer.effect || typeof anyLayer.effect !== "string"), scale: "s", class: CSS.auto, onCalciteSwitchChange: this.onPropChange }))));
    }
    renderBlur() {
        // "Blur": `blur(2px)`,
        // Blur (0-30) - step 0.1
        const { props, type } = this;
        const { strings, locale, modules } = props;
        const { screenUtils } = modules;
        const effectProps = getEffectProps(type, props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 30, step: 0.1, locale: locale, value: Math.round(screenUtils.pt2px(effectProps.radius) * 10) / 10, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange })));
    }
    renderBrightnessContrast() {
        // brightness(100%) contrast(100%)
        // Brightness (0-300) - step 1 + Contrast (0-300) - step 1
        const { props } = this;
        const { strings, locale } = props;
        const effectPropsBrightness = getEffectProps("brightness", props);
        const effectPropsContrast = getEffectProps("contrast", props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.brightness), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 300, step: 1, locale: locale, value: Math.round(effectPropsBrightness.amount * 100), classNames: CSS.bottomSpace, label: strings.effectsProps.brightness, onValueChange: this.onPropChange }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.contrast), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 300, step: 1, locale: locale, value: Math.round(effectPropsContrast.amount * 100), classNames: CSS.bottomSpace, label: strings.effectsProps.contrast, onValueChange: this.onPropChange })));
    }
    renderGrayscale() {
        // grayscale(25%)
        // Grayscale (0-100) - step 1
        const { props, type } = this;
        const { strings, locale } = props;
        const effectProps = getEffectProps(type, props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 100, step: 1, locale: locale, value: effectProps.amount * 100, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange })));
    }
    renderHueRotate() {
        // hue-rotate(270deg),
        // Hue rotate (0-360) - step 1
        const { props, type } = this;
        const { strings, locale } = props;
        const effectProps = getEffectProps(type, props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.degrees), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 360, step: 1, locale: locale, value: effectProps.angle, classNames: CSS.bottomSpace, label: strings.effectsProps.degrees, onValueChange: this.onPropChange })));
    }
    renderSaturate() {
        // saturate(100%)
        // Saturate (0-200) - step 1
        const { props, type } = this;
        const { strings, locale } = props;
        const effectProps = getEffectProps(type, props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 200, step: 1, locale: locale, value: effectProps.amount * 100, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange })));
    }
    renderInvert() {
        // invert(100%)
        // Invert (0-100) or (0-1) - step 1 or 0.01
        const { props, type } = this;
        const { strings, locale } = props;
        const effectProps = getEffectProps(type, props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 100, step: 1, locale: locale, value: effectProps.amount * 100, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange })));
    }
    renderSepia() {
        // sepia(50%)
        // Sepia (0-100) - step 1
        const { props, type } = this;
        const { strings, locale } = props;
        const effectProps = getEffectProps(type, props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 100, step: 1, locale: locale, value: effectProps.amount * 100, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange })));
    }
    renderFeatureEffectProps() {
        const { props, type, defaultExpression } = this;
        const { view, layer, strings } = props;
        const defaultField = getDefaultField(props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-filter", { class: `${CSS.panel} filter`, view: view, layer: layer, hideLayerTitle: true, panelHeading: strings.featureEffectsTitle[type], tipHeading: strings.filter.tipHeading, tipMsg: strings.filter.tipMsg, invalidHeading: strings.filter.invalidHeading, invalidMsg: strings.filter.invalidMsg, mode: "effects", defaultFieldName: defaultField, defaultOperator: ">", defaultExpression: !!defaultField && defaultExpression, hideButtons: true, dismissible: true, panelMaxHeight: "80vh", onArcgisFilterDismissedChange: () => {
                this.arcgisEffectsPopoverClose.emit();
                this.popoverNode.open = false;
                this.open = false;
            }, onArcgisFilterWhereChange: ({ detail: where }) => {
                this.arcgisEffectsPopoverFilterChange.emit(where);
            }, ref: (node) => (this.filterNode = node) }));
    }
    rgb2Hex(color) {
        return ("#" +
            this.componentToHex(Math.max(0, Math.min(255, color[0]))) +
            this.componentToHex(Math.max(0, Math.min(255, color[1]))) +
            this.componentToHex(Math.max(0, Math.min(255, color[2]))));
    }
    componentToHex(c) {
        const hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisEffectsPopovers.style = arcgisEffectsPopoversCss;



//# sourceMappingURL=arcgis-effects_2.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-9c4e7a3a.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-9c4e7a3a.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arcgisComponentNotificationsKeys),
/* harmony export */   g: () => (/* binding */ getSingleObjectLocalStorage),
/* harmony export */   l: () => (/* binding */ localStorageKeys),
/* harmony export */   s: () => (/* binding */ setSingleObjectLocalStorage)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
var localStorageKeys;
(function (localStorageKeys) {
    localStorageKeys["ARCGIS_COMPONENT_NOTIFICATIONS"] = "arcgisComponent_notifications";
})(localStorageKeys || (localStorageKeys = {}));
var arcgisComponentNotificationsKeys;
(function (arcgisComponentNotificationsKeys) {
    arcgisComponentNotificationsKeys["FEATURE_REDUCTION_WARNING_DISMISSED"] = "arcgis_feature_reduction_warning_dismissed";
    arcgisComponentNotificationsKeys["POPUP_WARNING_DISMISSED"] = "arcgis_popup_warning_dismissed";
    arcgisComponentNotificationsKeys["INCOMPATIBLE_VECTOR_SYMBOLS_DISMISSED"] = "arcgis_symbol_styler_incompatible_vector_symbols_dismissed";
    arcgisComponentNotificationsKeys["EFFECTS_TIP_DISMISSED"] = "arcgis_effects_tip_dismissed";
    arcgisComponentNotificationsKeys["LAYER_VIEW_DEFINITION_DISMISSED"] = "arcgis_layer_view_definition_dismissed";
    arcgisComponentNotificationsKeys["LAYER_OVERRIDE_STATUS_TIP_DISMISSED"] = "arcgis_layer_override_status_tip_dismissed";
    arcgisComponentNotificationsKeys["SMART_MAPPING_TIP1_DISMISSED"] = "arcgis_smart_mapping_tip1_dismissed";
    arcgisComponentNotificationsKeys["SMART_MAPPING_TIP2_DISMISSED"] = "arcgis_smart_mapping_tip2_dismissed";
    arcgisComponentNotificationsKeys["LAYER_VIEW_JOIN_TIP_DISMISSED"] = "arcgis_layer_view_join_tip_dismissed";
    arcgisComponentNotificationsKeys["MULTIDIMENSIONAL_INFO_TIP_DISMISSED"] = "arcgis_multidimensional_info_tip_dismissed";
})(arcgisComponentNotificationsKeys || (arcgisComponentNotificationsKeys = {}));
const getLocalStorage = (localStorageKey) => {
    return localStorage.getItem(localStorageKey);
};
const setLocalStorage = (localStorageKey, value) => {
    localStorage.setItem(localStorageKey, value);
};
const getObjectLocalStorage = (localStorageKey) => {
    return JSON.parse(getLocalStorage(localStorageKey)) || {};
};
const setSingleObjectLocalStorage = (localStorageKey, keyValueObject) => {
    const setLocalStorageVal = getObjectLocalStorage(localStorageKey);
    setLocalStorageVal[keyValueObject.key] = keyValueObject.value;
    setLocalStorage(localStorageKey, JSON.stringify(setLocalStorageVal));
};
const getSingleObjectLocalStorage = (localStorageKey, objectKey) => {
    const getLocalStorageVal = getObjectLocalStorage(localStorageKey);
    if (getLocalStorageVal === null || getLocalStorageVal === void 0 ? void 0 : getLocalStorageVal.hasOwnProperty(objectKey)) {
        return getLocalStorageVal[objectKey];
    }
    else {
        return null;
    }
};



//# sourceMappingURL=localStorage-9c4e7a3a.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTJjMTkwMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDZ0k7QUFDMUQ7QUFDWTtBQUNWO0FBQ1g7QUFDaUg7QUFDbko7QUFDUTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkNBQTJDO0FBQ3hEO0FBQ0EsZ0JBQWdCLHdFQUF3RTtBQUN4RixpQkFBaUIsMEVBQTBFO0FBQzNGLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0wsWUFBWSxhQUFhO0FBQ3pCLGtCQUFrQixhQUFhO0FBQy9CLGdCQUFnQixXQUFXO0FBQzNCLGlCQUFpQixXQUFXO0FBQzVCLGlCQUFpQixZQUFZO0FBQzdCLGdCQUFnQixXQUFXO0FBQzNCLGNBQWMsV0FBVztBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2RkFBNkY7QUFDbEg7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QyxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsbUZBQW1GO0FBQ3hHO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLDRGQUE0RjtBQUNqSCxxQkFBcUIsK0JBQStCO0FBQ3BELEtBQUs7QUFDTDtBQUNBLHFCQUFxQiw2RkFBNkY7QUFDbEg7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQyxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIseURBQXlEO0FBQzlFO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLHlEQUF5RDtBQUM5RTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQix5REFBeUQ7QUFDOUUscUJBQXFCLCtCQUErQjtBQUNwRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUMsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RXhEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFXO0FBQ3ZCLG1CQUFtQix3REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0EsWUFBWSx3REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBWSw4QkFBOEIsY0FBYyxRQUFRLE9BQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLEVBQUUsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZSxHQUFHLGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEU7O0FBRTVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLWVmZmVjdHNfMi5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2NhbFN0b3JhZ2UtOWM0ZTdhM2EuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxlLTA1MGI2ZGI5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIGEgYXMgZ2V0QXNzZXRQYXRoLCBkIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyB9IGZyb20gJy4vbG9jYWxlLTA1MGI2ZGI5LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0RWxlbWVudERpciwgQyBhcyBDU1NfVVRJTElUWSB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCB7IHEgYXMgcXVlcnlQYXJlbnRFbGVtZW50IH0gZnJvbSAnLi9jb21tb25GdW5jdGlvbnMtYjA4MzBlOWUuanMnO1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UsIHMgYXMgc2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlLCBhIGFzIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzLCBsIGFzIGxvY2FsU3RvcmFnZUtleXMgfSBmcm9tICcuL2xvY2FsU3RvcmFnZS05YzRlN2EzYS5qcyc7XG5pbXBvcnQgJy4vZG9tLTRkMzY3Njc3LmpzJztcbmltcG9ydCAnLi9jb21tb25FbnVtcy1mY2YxMzY2MS5qcyc7XG5cbmNvbnN0IENTUyQxID0ge1xuICAgIGZsb3c6IFwiZmxvd1wiLFxuICAgIHBhbmVsOiBcInBhbmVsXCIsXG4gICAgbm90aWNlOiBcIm5vdGljZVwiLFxuICAgIGhpbnQ6IFwiaGludFwiLFxuICAgIGJhc2VtYXBUeXBlOiBcImJhc2VtYXAtdHlwZVwiLFxuICAgIHJhZGlvQnV0dG9uczogXCJyYWRpby1idXR0b25zXCIsXG4gICAgc3dpdGNoOiBcInN3aXRjaFwiLFxuICAgIGxpc3Q6IFwibGlzdFwiLFxuICAgIGVmZmVjdFRodW1iOiBcImVmZmVjdC10aHVtYlwiLFxuICAgIGVmZmVjdFRodW1iSW1nOiBcImVmZmVjdC10aHVtYi1pbWdcIixcbiAgICBlZmZlY3RDb3VudDogXCJlZmZlY3QtY291bnRcIlxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGRlZmluZWRcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG5sZXQgYWxsTGF5ZXJFZmZlY3RUeXBlcyA9IFtcbiAgICBcImJsb29tXCIsXG4gICAgXCJkcm9wU2hhZG93XCIsXG4gICAgXCJibHVyXCIsXG4gICAgXCJicmlnaHRuZXNzQ29udHJhc3RcIixcbiAgICBcImdyYXlzY2FsZVwiLFxuICAgIFwiaHVlUm90YXRlXCIsXG4gICAgXCJzYXR1cmF0ZVwiLFxuICAgIFwiaW52ZXJ0XCIsXG4gICAgXCJzZXBpYVwiXG5dO1xubGV0IGFsbExpZ2h0RmVhdHVyZUVmZmVjdFR5cGVzID0gW1xuICAgIFwiZHJvcFNoYWRvd19ncmF5XCIsXG4gICAgXCJzdHJvbmdEcm9wU2hhZG93XCIsXG4gICAgXCJkcm9wU2hhZG93X3RyYW5zcGFyZW5jeVwiLFxuICAgIFwiZHJvcFNoYWRvd19ibHVyXCIsXG4gICAgXCJtdXRlZEJsdXJcIixcbiAgICBcIm11dGVkR3JheVwiXG5dO1xubGV0IGFsbERhcmtGZWF0dXJlRWZmZWN0VHlwZXMgPSBbXCJibG9vbV9ncmF5XCIsIFwiYmxvb21fYmx1clwiLCBcImJsb29tX3RyYW5zcGFyZW5jeVwiLCBcIm11dGVkQmx1clwiLCBcIm11dGVkR3JheVwiXTtcbi8qIE5ldXRyYWwgdmFsdWVzIDpcbmJsb29tIC0gKDAsMCwwKVxuYmx1ciAtIDBcbmJyaWdodG5lc3MgLSAxMDAlXG5jb250cmFzdCAtIDEwMCVcbmRyb3BzaGFkb3cgLSAwLDAsMCxibGFja1xuZ3JheXNjYWxlIC0gMCVcbmh1ZS1yb3RhdGUgLSAwXG5pbnZlcnQgLSAwJVxub3BhY2l0eSAtIDEwMCVcbnNhdHVyYXRlIC0gMTAwJVxuc2VwaWEgLSAwJVxuKi9cbi8vIGFsbCBhcHBsaWNhYmxlIHZhbHVlcyBzdG9yZWQgYXMgcHQgKG5vdCBweClcbmNvbnN0IGxheWVyRWZmZWN0RGVmYXVsdHMgPSB7XG4gICAgYmxvb206IHsgc3RyZW5ndGg6IDIsIHJhZGl1czogMC43NSwgdGhyZXNob2xkOiAwLjEgfSxcbiAgICBkcm9wU2hhZG93OiB7XG4gICAgICAgIGxpbmU6IHsgY29sb3I6IFswLCAwLCAwLCAyNTVdLCB4b2Zmc2V0OiAwLjc1LCB5b2Zmc2V0OiAwLjc1LCBibHVyUmFkaXVzOiAxLjEyNSB9LFxuICAgICAgICBwb2ludDogeyBjb2xvcjogWzAsIDAsIDAsIDI1NV0sIHhvZmZzZXQ6IDEuMTI1LCB5b2Zmc2V0OiAxLjEyNSwgYmx1clJhZGl1czogMS44NzUgfSxcbiAgICAgICAgcG9seWdvbjogeyBjb2xvcjogWzAsIDAsIDAsIDI1NV0sIHhvZmZzZXQ6IDEuMTI1LCB5b2Zmc2V0OiAxLjEyNSwgYmx1clJhZGl1czogMi4yNSB9XG4gICAgfSxcbiAgICBibHVyOiB7IHJhZGl1czogMS41IH0sXG4gICAgYnJpZ2h0bmVzczogeyBhbW91bnQ6IDEuNSB9LFxuICAgIGNvbnRyYXN0OiB7IGFtb3VudDogMiB9LFxuICAgIGdyYXlzY2FsZTogeyBhbW91bnQ6IDEgfSxcbiAgICBodWVSb3RhdGU6IHsgYW5nbGU6IDEwMCB9LFxuICAgIHNhdHVyYXRlOiB7IGFtb3VudDogMSB9LFxuICAgIGludmVydDogeyBhbW91bnQ6IDEgfSxcbiAgICBzZXBpYTogeyBhbW91bnQ6IDAuNyB9XG59O1xuY29uc3QgbGFzdExheWVyRWZmZWN0VmFsdWVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsYXllckVmZmVjdERlZmF1bHRzKSk7XG4vLyBhbGwgYXBwbGljYWJsZSB2YWx1ZXMgc3RvcmVkIGFzIHB0IChub3QgcHgpXG4vLyBEcm9wIFNoYWRvdyArIEdyYXk6IGRyb3BzaGFkb3cgKDIvMi8zcHggUkdCIDUwLDUwLDUwKSBmb3IgYWN0aXZlLCAxMDAlIGdyZXlzY2FsZSArIDUwJSB0cmFuc3BhcmVuY3kgZm9yIG11dGVcbi8vIFN0cm9uZyBEcm9wIFNoYWRvdzogZHJvcHNoYWRvdyAoNC80LzRweCwgSGV4IzAwMDAwMCkgZm9yIGFjdGl2ZSwgbm90aGluZyBvbiBtdXRlXG4vLyBEcm9wIFNoYWRvdyArIFRyYW5zcGFyZW5jeTogZHJvcHNoYWRvdyAoMi8yLzZweCwgUkdCIDUwLDUwLDUwKSBmb3IgYWN0aXZlLCA2NSUgdHJhbnNwYXJlbmN5IGZvciBtdXRlXG4vLyBEcm9wIFNoYWRvdyArIEJsdXI6IGRyb3BzaGFkb3cgKDIvMi8zcHggUkdCIDUwLDUwLDUwKSBmb3IgYWN0aXZlLCAzcHggYmx1ciArIDUwJSB0cmFuc3BhcmVuY3kgZm9yIG11dGVcbi8vIEJsb29tICsgR3JheTogQmxvb20gKDEuMy8wLjc1LzApIGZvciBhY3RpdmUsIEdyZXlzY2FsZSAxMDAlICsgNTAlIG9wYWNpdHkgZm9yIG11dGVcbi8vIEJsb29tICsgQmx1cjo6IEJsb29tICgxLjMvMC43NS8wKSBmb3IgYWN0aXZlLCAzcHggYmx1ciArIDUwJSB0cmFuc3BhcmVuY3kgZm9yIG11dGVcbi8vIEJsb29tICsgVHJhbnNwYXJlbmN5OiBCbG9vbSAoMS4zLzAuNzUvMCkgZm9yIGFjdGl2ZSwgNjUlIG9wYWNpdHkgZm9yIG11dGVcbi8vIE11dGVkIEJsdXI6IG5vdGhpbmcgZm9yIGFjdGl2ZSwgM3B4IGJsdXIgKyA1MCUgdHJhbnNwYXJlbmN5IGZvciBtdXRlXG4vLyBNdXRlZCBHcmF5c2NhbGU6IG5vdGhpbmcgZm9yIGFjdGl2ZSwgMTAwJSBncmV5c2NhbGUgKyA1MCUgdHJhbnNwYXJlbmN5IGZvciBtdXRlLVxuY29uc3QgZmVhdHVyZUVmZmVjdERlZmF1bHRzID0ge1xuICAgIGRyb3BTaGFkb3dfZ3JheToge1xuICAgICAgICBpbmNsdWRlZDogW3sgdHlwZTogXCJkcm9wLXNoYWRvd1wiLCBjb2xvcjogWzUwLCA1MCwgNTAsIDI1NV0sIHhvZmZzZXQ6IDEuNSwgeW9mZnNldDogMS41LCBibHVyUmFkaXVzOiAyLjI1IH1dLFxuICAgICAgICBleGNsdWRlZDogW1xuICAgICAgICAgICAgeyB0eXBlOiBcImdyYXlzY2FsZVwiLCBhbW91bnQ6IDEgfSxcbiAgICAgICAgICAgIHsgdHlwZTogXCJvcGFjaXR5XCIsIGFtb3VudDogMC41IH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgc3Ryb25nRHJvcFNoYWRvdzoge1xuICAgICAgICBpbmNsdWRlZDogW3sgdHlwZTogXCJkcm9wLXNoYWRvd1wiLCBjb2xvcjogWzAsIDAsIDAsIDI1NV0sIHhvZmZzZXQ6IDMsIHlvZmZzZXQ6IDMsIGJsdXJSYWRpdXM6IDMgfV0sXG4gICAgICAgIGV4Y2x1ZGVkOiBbXVxuICAgIH0sXG4gICAgZHJvcFNoYWRvd190cmFuc3BhcmVuY3k6IHtcbiAgICAgICAgaW5jbHVkZWQ6IFt7IHR5cGU6IFwiZHJvcC1zaGFkb3dcIiwgY29sb3I6IFs1MCwgNTAsIDUwLCAyNTVdLCB4b2Zmc2V0OiAxLjUsIHlvZmZzZXQ6IDEuNSwgYmx1clJhZGl1czogNC41IH1dLFxuICAgICAgICBleGNsdWRlZDogW3sgdHlwZTogXCJvcGFjaXR5XCIsIGFtb3VudDogMC4zNSB9XVxuICAgIH0sXG4gICAgZHJvcFNoYWRvd19ibHVyOiB7XG4gICAgICAgIGluY2x1ZGVkOiBbeyB0eXBlOiBcImRyb3Atc2hhZG93XCIsIGNvbG9yOiBbNTAsIDUwLCA1MCwgMjU1XSwgeG9mZnNldDogMS41LCB5b2Zmc2V0OiAxLjUsIGJsdXJSYWRpdXM6IDIuMjUgfV0sXG4gICAgICAgIGV4Y2x1ZGVkOiBbXG4gICAgICAgICAgICB7IHR5cGU6IFwiYmx1clwiLCByYWRpdXM6IDIuMjUgfSxcbiAgICAgICAgICAgIHsgdHlwZTogXCJvcGFjaXR5XCIsIGFtb3VudDogMC41IH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgYmxvb21fZ3JheToge1xuICAgICAgICBpbmNsdWRlZDogW3sgdHlwZTogXCJibG9vbVwiLCBzdHJlbmd0aDogMS4zLCByYWRpdXM6IDAuNiwgdGhyZXNob2xkOiAwIH1dLFxuICAgICAgICBleGNsdWRlZDogW1xuICAgICAgICAgICAgeyB0eXBlOiBcImdyYXlzY2FsZVwiLCBhbW91bnQ6IDEgfSxcbiAgICAgICAgICAgIHsgdHlwZTogXCJvcGFjaXR5XCIsIGFtb3VudDogMC41IH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgYmxvb21fYmx1cjoge1xuICAgICAgICBpbmNsdWRlZDogW3sgdHlwZTogXCJibG9vbVwiLCBzdHJlbmd0aDogMS4zLCByYWRpdXM6IDAuNiwgdGhyZXNob2xkOiAwIH1dLFxuICAgICAgICBleGNsdWRlZDogW1xuICAgICAgICAgICAgeyB0eXBlOiBcImJsdXJcIiwgcmFkaXVzOiAyLjI1IH0sXG4gICAgICAgICAgICB7IHR5cGU6IFwib3BhY2l0eVwiLCBhbW91bnQ6IDAuNSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIGJsb29tX3RyYW5zcGFyZW5jeToge1xuICAgICAgICBpbmNsdWRlZDogW3sgdHlwZTogXCJibG9vbVwiLCBzdHJlbmd0aDogMS4zLCByYWRpdXM6IDAuNiwgdGhyZXNob2xkOiAwIH1dLFxuICAgICAgICBleGNsdWRlZDogW3sgdHlwZTogXCJvcGFjaXR5XCIsIGFtb3VudDogMC4zNSB9XVxuICAgIH0sXG4gICAgbXV0ZWRCbHVyOiB7XG4gICAgICAgIGluY2x1ZGVkOiBbXSxcbiAgICAgICAgZXhjbHVkZWQ6IFtcbiAgICAgICAgICAgIHsgdHlwZTogXCJibHVyXCIsIHJhZGl1czogMi4yNSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBcIm9wYWNpdHlcIiwgYW1vdW50OiAwLjUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICBtdXRlZEdyYXk6IHtcbiAgICAgICAgaW5jbHVkZWQ6IFtdLFxuICAgICAgICBleGNsdWRlZDogW1xuICAgICAgICAgICAgeyB0eXBlOiBcImdyYXlzY2FsZVwiLCBhbW91bnQ6IDEgfSxcbiAgICAgICAgICAgIHsgdHlwZTogXCJvcGFjaXR5XCIsIGFtb3VudDogMC41IH1cbiAgICAgICAgXVxuICAgIH1cbn07XG5mdW5jdGlvbiBidWlsZEVmZmVjdHNJbmZvKG5vZGUsIHBvcG92ZXJzIC8qIEhUTUxBcmNnaXNFZmZlY3RzUG9wb3ZlcnNFbGVtZW50W10gKi8sIHByb3BzKSB7XG4gICAgY29uc3QgcGFydHMgPSBBcnJheS5mcm9tKG5vZGUuY2hpbGRyZW4pXG4gICAgICAgIC5maWx0ZXIoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikge1xuICAgICAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgIGNvbnN0IHN3aXRjaE5vZGUgPSBpdGVtTm9kZS5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1zd2l0Y2hcIik7XG4gICAgICAgICAgICByZXR1cm4gc3dpdGNoTm9kZS5jaGVja2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KVxuICAgICAgICAubWFwKChjaGlsZCkgPT4gYnVpbGRFZmZlY3RJbmZvKGNoaWxkLCBwb3BvdmVycywgcHJvcHMpKTtcbiAgICBsZXQgZWZmZWN0c1N0cmluZyA9IFwiXCI7XG4gICAgbGV0IGVmZmVjdHM7XG4gICAgbGV0IGNvbm5lY3RvciA9IFwiXCI7XG4gICAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICBpZiAocGFydCAmJiB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKCFlZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0c1N0cmluZyArPSBjb25uZWN0b3IgKyBwYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0cy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udmFsdWUgKz0gY29ubmVjdG9yICsgcGFydDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0ICYmIHR5cGVvZiBwYXJ0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAoIWVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBlZmZlY3RzID0gcGFydDtcbiAgICAgICAgICAgICAgICBlZmZlY3RzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS52YWx1ZSA9IGVmZmVjdHNTdHJpbmcgKyBjb25uZWN0b3IgKyBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0cy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmZyb20ocGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKG5ld0l0ZW0pID0+IGl0ZW0uc2NhbGUgPT09IG5ld0l0ZW0uc2NhbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgobmV3SXRlbSkgPT4gKGl0ZW0udmFsdWUgKz0gY29ubmVjdG9yICsgbmV3SXRlbS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RvciA9IFwiIFwiO1xuICAgIH0pO1xuICAgIGlmIChlZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiBlZmZlY3RzO1xuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0c1N0cmluZztcbn1cbmZ1bmN0aW9uIHBhcnNlRWZmZWN0cyhwcm9wcykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1vZHVsZXMsIHN1cHBvcnRzRmVhdHVyZUVmZmVjdHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGFueUxheWVyID0gbGF5ZXI7XG4gICAgaWYgKGFueUxheWVyLmVmZmVjdCAmJiBhbnlMYXllci5mZWF0dXJlRWZmZWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGVmZmVjdFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYW55TGF5ZXIuZmVhdHVyZUVmZmVjdCAmJiAhc3VwcG9ydHNGZWF0dXJlRWZmZWN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBlZmZlY3RcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFueUxheWVyLmVmZmVjdCkge1xuICAgICAgICAvLyBsYXllciBlZmZlY3RcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gYW55TGF5ZXIuZWZmZWN0O1xuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkVmZmVjdEpTT05cIiwgbW9kdWxlcy5lZmZlY3RzVXRpbHMudG9KU09OKGVmZmVjdCkpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZXMuZWZmZWN0c1V0aWxzLnRvSlNPTihlZmZlY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVmZmVjdC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIGlmIChtaW5pbWFsQXV0b0NoZWNrT0soZWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJFZmZlY3RKU09OXCIsIG1vZHVsZXMuZWZmZWN0c1V0aWxzLnRvSlNPTihlZmZlY3RbMV0udmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRWZmZWN0UHJvcGVydHlBUElcIiwgbW9kdWxlcy5lZmZlY3RzVXRpbHMuZnJvbUpTT04obW9kdWxlcy5lZmZlY3RzVXRpbHMudG9KU09OKGVmZmVjdFsxXS52YWx1ZSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlcy5lZmZlY3RzVXRpbHMudG9KU09OKGVmZmVjdFsxXS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBlZmZlY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBlZmZlY3RcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYW55TGF5ZXIuZmVhdHVyZUVmZmVjdCkge1xuICAgICAgICAvLyBmZWF0dXJlIGVmZmVjdFxuICAgICAgICBjb25zdCBlZmZlY3QgPSBhbnlMYXllci5mZWF0dXJlRWZmZWN0O1xuICAgICAgICBpZiAoZWZmZWN0LmV4Y2x1ZGVkTGFiZWxzVmlzaWJsZSAmJlxuICAgICAgICAgICAgKCFlZmZlY3QuaW5jbHVkZWRFZmZlY3QgfHwgdHlwZW9mIGVmZmVjdC5pbmNsdWRlZEVmZmVjdCA9PT0gXCJzdHJpbmdcIikgJiZcbiAgICAgICAgICAgICghZWZmZWN0LmV4Y2x1ZGVkRWZmZWN0IHx8IHR5cGVvZiBlZmZlY3QuZXhjbHVkZWRFZmZlY3QgPT09IFwic3RyaW5nXCIpICYmXG4gICAgICAgICAgICAoIWVmZmVjdC5maWx0ZXIgfHwgIWVmZmVjdC5maWx0ZXIuZ2VvbWV0cnkpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlZCA9IGVmZmVjdC5pbmNsdWRlZEVmZmVjdCA/IG1vZHVsZXMuZWZmZWN0c1V0aWxzLnRvSlNPTihlZmZlY3QuaW5jbHVkZWRFZmZlY3QpIDogW107XG4gICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGVmZmVjdC5leGNsdWRlZEVmZmVjdCA/IG1vZHVsZXMuZWZmZWN0c1V0aWxzLnRvSlNPTihlZmZlY3QuZXhjbHVkZWRFZmZlY3QpIDogW107XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicGFyc2VkIGZlYXR1cmUgZWZmZWN0IC0gaW5jbHVkZWQ6XCIsIGluY2x1ZGVkLCBcImV4Y2x1ZGVkOlwiLCBleGNsdWRlZCwgXCJ3aGVyZTpcIiwgZWZmZWN0LmZpbHRlci53aGVyZSk7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgbGV0IGVmZmVjdFR5cGU7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBmZWF0dXJlRWZmZWN0RGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0SlNPTiA9IGZlYXR1cmVFZmZlY3REZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChpc1NhbWVFZmZlY3QoZGVmYXVsdEpTT04uaW5jbHVkZWQsIGluY2x1ZGVkKSAmJiBpc1NhbWVFZmZlY3QoZGVmYXVsdEpTT04uZXhjbHVkZWQsIGV4Y2x1ZGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3RUeXBlID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGVmZmVjdFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNvcnRFZmZlY3RzKHByb3BzKSB7XG4gICAgY29uc3QgeyBlZmZlY3RzSlNPTiB9ID0gcHJvcHM7XG4gICAgaWYgKCFlZmZlY3RzSlNPTikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVzZWRFZmZlY3RUeXBlcyA9IGVmZmVjdHNKU09OLm1hcCgoZWZmZWN0KSA9PiBlZmZlY3QudHlwZSk7XG4gICAgYWxsTGF5ZXJFZmZlY3RUeXBlcy5zb3J0KCh0eXBlQSwgdHlwZUIpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXhBID0gdXNlZEVmZmVjdFR5cGVzLmluZGV4T2YoY29udmVydFRvQVBJVHlwZSh0eXBlQSkpO1xuICAgICAgICBjb25zdCBpbmRleEIgPSB1c2VkRWZmZWN0VHlwZXMuaW5kZXhPZihjb252ZXJ0VG9BUElUeXBlKHR5cGVCKSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5kZXhBID4gLTEgJiYgaW5kZXhCID4gLTEgJiYgaW5kZXhBIDwgaW5kZXhCXG4gICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICA6IGluZGV4QSA+IC0xICYmIGluZGV4QiA+IC0xICYmIGluZGV4QSA+IGluZGV4QlxuICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgIDogaW5kZXhBID4gLTFcbiAgICAgICAgICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgICAgICAgICA6IGluZGV4QiA+IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RWZmZWN0UHJvcHModHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgZWZmZWN0c0pTT04gfSA9IHByb3BzO1xuICAgIGNvbnN0IGxheWVyRWZmZWN0ID0gZWZmZWN0c0pTT04gJiYgKChfYiA9IChfYSA9IEFycmF5LmZyb20oZWZmZWN0c0pTT04pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKChlZmZlY3QpID0+IGVmZmVjdC50eXBlID09PSBjb252ZXJ0VG9BUElUeXBlKHR5cGUpKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKTtcbiAgICBpZiAoIWxheWVyRWZmZWN0KSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcImRyb3BTaGFkb3dcIikge1xuICAgICAgICAgICAgbGV0IGdlb21ldHJ5VHlwZSA9IGdldFNpbXBsZUdlb21ldHJ5VHlwZShwcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gbGFzdExheWVyRWZmZWN0VmFsdWVzW3R5cGVdW2dlb21ldHJ5VHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdExheWVyRWZmZWN0VmFsdWVzW3R5cGVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYXllckVmZmVjdDtcbn1cbmZ1bmN0aW9uIGdldFNpbXBsZUdlb21ldHJ5VHlwZShwcm9wcykge1xuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHByb3BzO1xuICAgIGxldCBzaW1wbGVUeXBlID0gXCJwb2ludFwiO1xuICAgIGNvbnN0IGFueUxheWVyID0gbGF5ZXI7XG4gICAgaWYgKGxheWVyLnR5cGUgPT09IFwiY3N2XCIpIHtcbiAgICAgICAgc2ltcGxlVHlwZSA9IFwicG9pbnRcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYW55TGF5ZXIuZ2VvbWV0cnlUeXBlKSB7XG4gICAgICAgIHNpbXBsZVR5cGUgPVxuICAgICAgICAgICAgYW55TGF5ZXIuZ2VvbWV0cnlUeXBlID09PSBcInBvbHlsaW5lXCJcbiAgICAgICAgICAgICAgICA/IFwibGluZVwiXG4gICAgICAgICAgICAgICAgOiBbXCJwb2ludFwiLCBcIm11bHRpcG9pbnRcIl0uaW5jbHVkZXMoYW55TGF5ZXIuZ2VvbWV0cnlUeXBlKVxuICAgICAgICAgICAgICAgICAgICA/IFwicG9pbnRcIlxuICAgICAgICAgICAgICAgICAgICA6IFwicG9seWdvblwiO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxlVHlwZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0FQSVR5cGUodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiZHJvcFNoYWRvd1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZHJvcC1zaGFkb3dcIjtcbiAgICAgICAgY2FzZSBcImh1ZVJvdGF0ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaHVlLXJvdGF0ZVwiO1xuICAgICAgICBjYXNlIFwiYnJpZ2h0bmVzc0NvbnRyYXN0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJicmlnaHRuZXNzXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZEZlYXR1cmVFZmZlY3QoZWZmZWN0VHlwZSwgd2hlcmUsIHByb3BzKSB7XG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IEZlYXR1cmVFZmZlY3QgfSA9IG1vZHVsZXM7XG4gICAgY29uc3QganNvbiA9IGZlYXR1cmVFZmZlY3REZWZhdWx0c1tlZmZlY3RUeXBlXTtcbiAgICBjb25zdCBmZWF0dXJlRWZmZWN0ID0gbmV3IEZlYXR1cmVFZmZlY3Qoe1xuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgIHdoZXJlXG4gICAgICAgIH0sXG4gICAgICAgIGluY2x1ZGVkRWZmZWN0OiBtb2R1bGVzLmVmZmVjdHNVdGlscy5mcm9tSlNPTihqc29uLmluY2x1ZGVkKSxcbiAgICAgICAgZXhjbHVkZWRFZmZlY3Q6IG1vZHVsZXMuZWZmZWN0c1V0aWxzLmZyb21KU09OKGpzb24uZXhjbHVkZWQpLFxuICAgICAgICBleGNsdWRlZExhYmVsc1Zpc2libGU6IHRydWVcbiAgICB9KTtcbiAgICAvL2NvbnNvbGUubG9nKFwiYnVpbGRGZWF0dXJlRWZmZWN0XCIsIGVmZmVjdFR5cGUsIGZlYXR1cmVFZmZlY3QsIGpzb24pO1xuICAgIHJldHVybiBmZWF0dXJlRWZmZWN0O1xufVxuZnVuY3Rpb24gbWluaW1hbEF1dG9DaGVja09LKGVmZmVjdCkge1xuICAgIC8vIG1ha2Ugc3VyZSBlYWNoIGVmZmVjdCB0eXBlIGlzIG1lbnRpb25lZCBpbiBhbGwgMyBvciBub25lIG9mIHRoZSBzdHJpbmdzXG4gICAgY29uc3Qgc3RyaW5ncyA9IFtlZmZlY3RbMF0udmFsdWUsIGVmZmVjdFsxXS52YWx1ZSwgZWZmZWN0WzJdLnZhbHVlXTtcbiAgICByZXR1cm4gIWFsbExheWVyRWZmZWN0VHlwZXMuc29tZSgodHlwZSkgPT4ge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJicmlnaHRuZXNzQ29udHJhc3RcIikge1xuICAgICAgICAgICAgY29uc3QgYXBpVHlwZTEgPSBcImJyaWdodG5lc3NcIjtcbiAgICAgICAgICAgIGNvbnN0IGFwaVR5cGUyID0gXCJjb250cmFzdFwiO1xuICAgICAgICAgICAgaWYgKHN0cmluZ3NbMF0uaW5kZXhPZihhcGlUeXBlMSkgPiAtMSAmJiBzdHJpbmdzWzBdLmluZGV4T2YoYXBpVHlwZTIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHN0cmluZ3NbMV0uaW5kZXhPZihhcGlUeXBlMSkgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3NbMl0uaW5kZXhPZihhcGlUeXBlMSkgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3NbMV0uaW5kZXhPZihhcGlUeXBlMikgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3NbMl0uaW5kZXhPZihhcGlUeXBlMikgPT09IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmluZ3NbMF0uaW5kZXhPZihhcGlUeXBlMSkgPT09IC0xICYmIHN0cmluZ3NbMF0uaW5kZXhPZihhcGlUeXBlMikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzdHJpbmdzWzFdLmluZGV4T2YoYXBpVHlwZTEpID4gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nc1syXS5pbmRleE9mKGFwaVR5cGUxKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3NbMV0uaW5kZXhPZihhcGlUeXBlMikgPiAtMSB8fFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdzWzJdLmluZGV4T2YoYXBpVHlwZTIpID4gLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhcGlUeXBlID0gY29udmVydFRvQVBJVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdzWzBdLmluZGV4T2YoYXBpVHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzWzFdLmluZGV4T2YoYXBpVHlwZSkgPT09IC0xIHx8IHN0cmluZ3NbMl0uaW5kZXhPZihhcGlUeXBlKSA9PT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nc1sxXS5pbmRleE9mKGFwaVR5cGUpID4gLTEgfHwgc3RyaW5nc1syXS5pbmRleE9mKGFwaVR5cGUpID4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzU2FtZUVmZmVjdChlZmZlY3RBXyAvKiBfX2VzcmkuRWZmZWN0SlNPTltdICovLCBlZmZlY3RCXyAvKiBfX2VzcmkuRWZmZWN0SlNPTltdICovKSB7XG4gICAgLy8gZGlmZmVyZW50IG9yZGVyIGlzIE9LXG4gICAgLy8gbWFrZSBjb3BpZXMgc28gb3JkZXJpbmcgd29uJ3QgYWZmZWN0IHRoZSBvcmlnaW5hbFxuICAgIGNvbnN0IGVmZmVjdEEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVmZmVjdEFfKSk7XG4gICAgY29uc3QgZWZmZWN0QiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZWZmZWN0Ql8pKTtcbiAgICAvLyBjaGVjayBsZW5ndGhcbiAgICBpZiAoZWZmZWN0QS5sZW5ndGggIT09IGVmZmVjdEIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gc29ydCBieSB0eXBlIG5hbWVcbiAgICBlZmZlY3RBLnNvcnQoKGEsIGIpID0+IGEudHlwZS5sb2NhbGVDb21wYXJlKGIudHlwZSkpO1xuICAgIGVmZmVjdEIuc29ydCgoYSwgYikgPT4gYS50eXBlLmxvY2FsZUNvbXBhcmUoYi50eXBlKSk7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGFycmF5XG4gICAgbGV0IHNhbWUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWZmZWN0QS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gZWZmZWN0QVtpXTtcbiAgICAgICAgY29uc3QgYiA9IGVmZmVjdEJbaV07XG4gICAgICAgIC8vIHNhbWUgbnVtYmVyIG9mIHByb3BzP1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgYXQgZWFjaCBwcm9wXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBhKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFba2V5XSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYltrZXldID09PSBcInN0cmluZ1wiICYmIGFba2V5XSA9PT0gYltrZXldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYVtrZXldID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBiW2tleV0gPT09IFwibnVtYmVyXCIgJiYgYVtrZXldID09PSBiW2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFba2V5XS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBhW2tleV0ubGVuZ3RoID09PSBiW2tleV0ubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgYVtrZXldLmV2ZXJ5KCh2YWwsIGlkeCkgPT4gdmFsID09PSBiW2tleV1baWR4XSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNhbWUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzYW1lO1xufVxuZnVuY3Rpb24gYnVpbGRFZmZlY3RJbmZvKG5vZGUsIHBvcG92ZXJzIC8qIEhUTUxBcmNnaXNFZmZlY3RzUG9wb3ZlcnNFbGVtZW50W10gKi8sIHByb3BzKSB7XG4gICAgY29uc3QgdHlwZSA9IG5vZGUudmFsdWU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJibG9vbVwiOlxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkRWZmZWN0SW5mb0Jsb29tKHBvcG92ZXJzW3R5cGVdLCBwcm9wcyk7XG4gICAgICAgIGNhc2UgXCJkcm9wU2hhZG93XCI6XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRFZmZlY3RJbmZvRHJvcFNoYWRvdyhwb3BvdmVyc1t0eXBlXSwgcHJvcHMpO1xuICAgICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkRWZmZWN0SW5mb0JsdXIocG9wb3ZlcnNbdHlwZV0sIHByb3BzKTtcbiAgICAgICAgY2FzZSBcImJyaWdodG5lc3NDb250cmFzdFwiOlxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkRWZmZWN0SW5mb0JyaWdodG5lc3NDb250cmFzdChwb3BvdmVyc1t0eXBlXSk7XG4gICAgICAgIGNhc2UgXCJncmF5c2NhbGVcIjpcbiAgICAgICAgICAgIHJldHVybiBidWlsZEVmZmVjdEluZm9HcmF5c2NhbGUocG9wb3ZlcnNbdHlwZV0pO1xuICAgICAgICBjYXNlIFwiaHVlUm90YXRlXCI6XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRFZmZlY3RJbmZvSHVlUm90YXRlKHBvcG92ZXJzW3R5cGVdKTtcbiAgICAgICAgY2FzZSBcInNhdHVyYXRlXCI6XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRFZmZlY3RJbmZvU2F0dXJhdGUocG9wb3ZlcnNbdHlwZV0pO1xuICAgICAgICBjYXNlIFwiaW52ZXJ0XCI6XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRFZmZlY3RJbmZvSW52ZXJ0KHBvcG92ZXJzW3R5cGVdKTtcbiAgICAgICAgY2FzZSBcInNlcGlhXCI6XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRFZmZlY3RJbmZvU2VwaWEocG9wb3ZlcnNbdHlwZV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRWZmZWN0SW5mb0Jsb29tKG5vZGUgLyogSFRNTEFyY2dpc0VmZmVjdHNQb3BvdmVyc0VsZW1lbnQgKi8sIHByb3BzKSB7XG4gICAgLy8gc3RyZW5ndGgsIHJhZGl1cywgdGhyZXNob2xkXG4gICAgLy8gYmxvb20oMjAwJSwgMXB4LCAwLjIpXCI7XG4gICAgLy8gYmxvb20oMiwgMXB4LCAyMCUpXCI7XG4gICAgLy8gYmxvb20oMiwgMXB4LCAwLjEpXG4gICAgY29uc3QgbnVtYmVyTm9kZXMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLWlucHV0XCIpO1xuICAgIGxldCBzdHJlbmd0aCA9IGdldFZhbHVlKG51bWJlck5vZGVzWzBdKTtcbiAgICBsZXQgcmFkaXVzID0gZ2V0VmFsdWUobnVtYmVyTm9kZXNbMV0pO1xuICAgIGxldCB0aHJlc2hvbGQgPSBnZXRWYWx1ZShudW1iZXJOb2Rlc1syXSk7XG4gICAgaWYgKCFpc0RlZmluZWQoc3RyZW5ndGgpIHx8ICFpc0RlZmluZWQocmFkaXVzKSB8fCAhaXNEZWZpbmVkKHRocmVzaG9sZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0cmVuZ3RoID0gTWF0aC5yb3VuZChzdHJlbmd0aCAqIDEwKSAvIDEwO1xuICAgIHJhZGl1cyA9IHB4MnB0Um91bmRUbzMoTWF0aC5yb3VuZChyYWRpdXMgKiAxMCkgLyAxMCwgcHJvcHMpO1xuICAgIHRocmVzaG9sZCA9IE1hdGgucm91bmQodGhyZXNob2xkKTtcbiAgICB0aHJlc2hvbGQgLz0gMTAwO1xuICAgIGxhc3RMYXllckVmZmVjdFZhbHVlcy5ibG9vbSA9IHsgc3RyZW5ndGgsIHJhZGl1cywgdGhyZXNob2xkIH07XG4gICAgY29uc3QgYXV0b05vZGUgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCIuYXV0b1wiKTtcbiAgICBpZiAoIWF1dG9Ob2RlLmNoZWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIGBibG9vbSgke3N0cmVuZ3RofSwgJHtyYWRpdXN9cHQsICR7dGhyZXNob2xkfSlgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB2aWV3IH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgY3VycmVudFNjYWxlID0gdmlldy5zY2FsZTtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gMjtcbiAgICAgICAgY29uc3QgaW52RmFjdG9yID0gMSAvIGZhY3RvcjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgdmFsdWVzIGhhdmUgYmVlbiBkb3VibGVkIGFmdGVyIHR3byB6b29tIGxldmVsIGluXG4gICAgICAgICAgICAgICAgc2NhbGU6IGN1cnJlbnRTY2FsZSAqIDAuMjUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGBibG9vbSgke3N0cmVuZ3RoICogZmFjdG9yfSwgJHtyYWRpdXMgKiBmYWN0b3J9cHQsICR7dGhyZXNob2xkfSlgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNjYWxlOiBjdXJyZW50U2NhbGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGBibG9vbSgke3N0cmVuZ3RofSwgJHtyYWRpdXN9cHQsICR7dGhyZXNob2xkfSlgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCB2YWx1ZXMgaGF2ZSBiZWVuIGhhbHZlZCBhZnRlciB0d28gem9vbXMgbGV2ZWwgb3V0XG4gICAgICAgICAgICAgICAgc2NhbGU6IGN1cnJlbnRTY2FsZSAqIDQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGBibG9vbSgke3N0cmVuZ3RoICogaW52RmFjdG9yfSwgJHtyYWRpdXMgKiBpbnZGYWN0b3J9cHQsICR7dGhyZXNob2xkfSlgXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRFZmZlY3RJbmZvRHJvcFNoYWRvdyhub2RlIC8qIEhUTUxBcmNnaXNFZmZlY3RzUG9wb3ZlcnNFbGVtZW50ICovLCBwcm9wcykge1xuICAgIC8vIHggb2Zmc2V0LCB5IG9mZnNldCwgYmx1ciByYWRpdXMgKD13aWR0aCkgaHNsKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSlcbiAgICAvLyBcImRyb3Atc2hhZG93KDNweCwgM3B4LCA0cHgpXCJcbiAgICBjb25zdCBjb2xvciA9IG5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtY29sb3ItcGlja2VyXCIpO1xuICAgIGNvbnN0IHJnYiA9IGhleFRvUmdiKGNvbG9yLnZhbHVlKTtcbiAgICBjb25zdCBudW1iZXJOb2RlcyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtaW5wdXRcIik7XG4gICAgbGV0IGJsdXJSYWRpdXMgPSBnZXRWYWx1ZShudW1iZXJOb2Rlc1swXSk7XG4gICAgbGV0IHhvZmZzZXQgPSBnZXRWYWx1ZShudW1iZXJOb2Rlc1sxXSk7XG4gICAgbGV0IHlvZmZzZXQgPSBnZXRWYWx1ZShudW1iZXJOb2Rlc1syXSk7XG4gICAgbGV0IG9wYWNpdHkgPSBnZXRWYWx1ZShudW1iZXJOb2Rlc1szXSk7XG4gICAgaWYgKCFpc0RlZmluZWQoY29sb3IudmFsdWUpIHx8XG4gICAgICAgICFpc0RlZmluZWQoYmx1clJhZGl1cykgfHxcbiAgICAgICAgIWlzRGVmaW5lZCh4b2Zmc2V0KSB8fFxuICAgICAgICAhaXNEZWZpbmVkKHlvZmZzZXQpIHx8XG4gICAgICAgICFpc0RlZmluZWQob3BhY2l0eSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGJsdXJSYWRpdXMgPSBweDJwdFJvdW5kVG8zKE1hdGgucm91bmQoYmx1clJhZGl1cyksIHByb3BzKTtcbiAgICB4b2Zmc2V0ID0gcHgycHRSb3VuZFRvMyhNYXRoLnJvdW5kKHhvZmZzZXQpLCBwcm9wcyk7XG4gICAgeW9mZnNldCA9IHB4MnB0Um91bmRUbzMoTWF0aC5yb3VuZCh5b2Zmc2V0KSwgcHJvcHMpO1xuICAgIG9wYWNpdHkgPSBNYXRoLnJvdW5kKG9wYWNpdHkpO1xuICAgIG9wYWNpdHkgLz0gMTAwO1xuICAgIGxhc3RMYXllckVmZmVjdFZhbHVlcy5kcm9wU2hhZG93W2dldFNpbXBsZUdlb21ldHJ5VHlwZShwcm9wcyldID0ge1xuICAgICAgICBjb2xvcjogW3JnYi5yLCByZ2IuZywgcmdiLmIsIG9wYWNpdHkgKiAyNTVdLFxuICAgICAgICB4b2Zmc2V0LFxuICAgICAgICB5b2Zmc2V0LFxuICAgICAgICBibHVyUmFkaXVzXG4gICAgfTtcbiAgICAvL2NvbnN0IGhzbCA9IGhleFRvSFNMKGNvbG9yLnZhbHVlIGFzIGFueSk7XG4gICAgLy9jb25zdCBjb2xvclN0ciA9IGBoc2xhKCR7TWF0aC5yb3VuZChoc2wuaCAqIDM2MCl9LCAke2hzbC5zICogMTAwfSUsICR7aHNsLmwgKiAxMDB9JSwgJHtvcGFjaXR5fSlgO1xuICAgIGNvbnN0IGNvbG9yU3RyID0gYHJnYmEoJHtyZ2Iucn0sICR7cmdiLmd9LCAke3JnYi5ifSwgJHtvcGFjaXR5fSlgO1xuICAgIGNvbnN0IGF1dG9Ob2RlID0gbm9kZS5xdWVyeVNlbGVjdG9yKFwiLmF1dG9cIik7XG4gICAgaWYgKCFhdXRvTm9kZS5jaGVja2VkKSB7XG4gICAgICAgIHJldHVybiBgZHJvcC1zaGFkb3coJHt4b2Zmc2V0fXB0ICR7eW9mZnNldH1wdCAke2JsdXJSYWRpdXN9cHQgJHtjb2xvclN0cn0pYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgdmlldyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IHZpZXcuc2NhbGU7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IDI7XG4gICAgICAgIGNvbnN0IGludkZhY3RvciA9IDEgLyBmYWN0b3I7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlcyBoYXZlIGJlZW4gZG91YmxlZCBhZnRlciB0d28gem9vbSBsZXZlbCBpblxuICAgICAgICAgICAgICAgIHNjYWxlOiBjdXJyZW50U2NhbGUgKiAwLjI1LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBgZHJvcC1zaGFkb3coJHt4b2Zmc2V0ICogZmFjdG9yfXB0ICR7eW9mZnNldCAqIGZhY3Rvcn1wdCAke2JsdXJSYWRpdXMgKiBmYWN0b3J9cHQgJHtjb2xvclN0cn0pYFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzY2FsZTogY3VycmVudFNjYWxlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBgZHJvcC1zaGFkb3coJHt4b2Zmc2V0fXB0ICR7eW9mZnNldH1wdCAke2JsdXJSYWRpdXN9cHQgJHtjb2xvclN0cn0pYFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgdmFsdWVzIGhhdmUgYmVlbiBoYWx2ZWQgYWZ0ZXIgdHdvIHpvb21zIGxldmVsIG91dFxuICAgICAgICAgICAgICAgIHNjYWxlOiBjdXJyZW50U2NhbGUgKiA0LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBgZHJvcC1zaGFkb3coJHt4b2Zmc2V0ICogaW52RmFjdG9yfXB0ICR7eW9mZnNldCAqIGludkZhY3Rvcn1wdCAke2JsdXJSYWRpdXMgKiBpbnZGYWN0b3J9cHQgJHtjb2xvclN0cn0pYFxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRWZmZWN0SW5mb0JsdXIobm9kZSAvKiBIVE1MQXJjZ2lzRWZmZWN0c1BvcG92ZXJzRWxlbWVudCAqLywgcHJvcHMpIHtcbiAgICAvLyBibHVyKDEwcHgpXG4gICAgY29uc3QgbnVtYmVyTm9kZSA9IG5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIik7XG4gICAgbGV0IHJhZGl1cyA9IGdldFZhbHVlKG51bWJlck5vZGUpO1xuICAgIGlmICghaXNEZWZpbmVkKHJhZGl1cykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJhZGl1cyA9IHB4MnB0Um91bmRUbzMoTWF0aC5yb3VuZChyYWRpdXMgKiAxMCkgLyAxMCwgcHJvcHMpO1xuICAgIGxhc3RMYXllckVmZmVjdFZhbHVlcy5ibHVyID0geyByYWRpdXMgfTtcbiAgICByZXR1cm4gYGJsdXIoJHtyYWRpdXN9cHQpYDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRWZmZWN0SW5mb0JyaWdodG5lc3NDb250cmFzdChub2RlIC8qIEhUTUxBcmNnaXNFZmZlY3RzUG9wb3ZlcnNFbGVtZW50ICovKSB7XG4gICAgLy8gYnJpZ2h0bmVzcygxMDAlKSBjb250cmFzdCgxMDAlKVxuICAgIGNvbnN0IG51bWJlck5vZGVzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS1pbnB1dFwiKTtcbiAgICBsZXQgYnJpZ2h0bmVzcyA9IGdldFZhbHVlKG51bWJlck5vZGVzWzBdKTtcbiAgICBsZXQgY29udHJhc3QgPSBnZXRWYWx1ZShudW1iZXJOb2Rlc1sxXSk7XG4gICAgaWYgKCFpc0RlZmluZWQoYnJpZ2h0bmVzcykgfHwgIWlzRGVmaW5lZChjb250cmFzdCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGJyaWdodG5lc3MgPSBNYXRoLnJvdW5kKGJyaWdodG5lc3MpIC8gMTAwO1xuICAgIGNvbnRyYXN0ID0gTWF0aC5yb3VuZChjb250cmFzdCkgLyAxMDA7XG4gICAgbGFzdExheWVyRWZmZWN0VmFsdWVzLmJyaWdodG5lc3MgPSB7IGFtb3VudDogYnJpZ2h0bmVzcyB9O1xuICAgIGxhc3RMYXllckVmZmVjdFZhbHVlcy5jb250cmFzdCA9IHsgYW1vdW50OiBjb250cmFzdCB9O1xuICAgIHJldHVybiBgYnJpZ2h0bmVzcygke2JyaWdodG5lc3N9KSBjb250cmFzdCgke2NvbnRyYXN0fSlgO1xufVxuZnVuY3Rpb24gYnVpbGRFZmZlY3RJbmZvR3JheXNjYWxlKG5vZGUgLyogSFRNTEFyY2dpc0VmZmVjdHNQb3BvdmVyc0VsZW1lbnQgKi8pIHtcbiAgICAvLyBncmF5c2NhbGUoMjUlKVxuICAgIGNvbnN0IG51bWJlck5vZGUgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpO1xuICAgIGxldCBhbW91bnQgPSBnZXRWYWx1ZShudW1iZXJOb2RlKTtcbiAgICBpZiAoIWlzRGVmaW5lZChhbW91bnQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhbW91bnQgPSBNYXRoLnJvdW5kKGFtb3VudCkgLyAxMDA7XG4gICAgbGFzdExheWVyRWZmZWN0VmFsdWVzLmdyYXlzY2FsZSA9IHsgYW1vdW50IH07XG4gICAgcmV0dXJuIGBncmF5c2NhbGUoJHthbW91bnR9KWA7XG59XG5mdW5jdGlvbiBidWlsZEVmZmVjdEluZm9IdWVSb3RhdGUobm9kZSAvKiBIVE1MQXJjZ2lzRWZmZWN0c1BvcG92ZXJzRWxlbWVudCAqLykge1xuICAgIC8vIGh1ZS1yb3RhdGUoMjcwZGVnKVxuICAgIGNvbnN0IG51bWJlck5vZGUgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpO1xuICAgIGxldCBhbmdsZSA9IGdldFZhbHVlKG51bWJlck5vZGUpO1xuICAgIGlmICghaXNEZWZpbmVkKGFuZ2xlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYW5nbGUgPSBNYXRoLnJvdW5kKGFuZ2xlKTtcbiAgICBsYXN0TGF5ZXJFZmZlY3RWYWx1ZXMuaHVlUm90YXRlID0geyBhbmdsZSB9O1xuICAgIHJldHVybiBgaHVlLXJvdGF0ZSgke2FuZ2xlfWRlZylgO1xufVxuZnVuY3Rpb24gYnVpbGRFZmZlY3RJbmZvU2F0dXJhdGUobm9kZSAvKiBIVE1MQXJjZ2lzRWZmZWN0c1BvcG92ZXJzRWxlbWVudCAqLykge1xuICAgIC8vIHNhdHVyYXRlKDEwMCUpXG4gICAgY29uc3QgbnVtYmVyTm9kZSA9IG5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIik7XG4gICAgbGV0IGFtb3VudCA9IGdldFZhbHVlKG51bWJlck5vZGUpO1xuICAgIGlmICghaXNEZWZpbmVkKGFtb3VudCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFtb3VudCA9IE1hdGgucm91bmQoYW1vdW50KSAvIDEwMDtcbiAgICBsYXN0TGF5ZXJFZmZlY3RWYWx1ZXMuc2F0dXJhdGUgPSB7IGFtb3VudCB9O1xuICAgIHJldHVybiBgc2F0dXJhdGUoJHthbW91bnR9KWA7XG59XG5mdW5jdGlvbiBidWlsZEVmZmVjdEluZm9JbnZlcnQobm9kZSAvKiBIVE1MQXJjZ2lzRWZmZWN0c1BvcG92ZXJzRWxlbWVudCAqLykge1xuICAgIC8vIGludmVydCgxMDAlKVxuICAgIGNvbnN0IG51bWJlck5vZGUgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpO1xuICAgIGxldCBhbW91bnQgPSBnZXRWYWx1ZShudW1iZXJOb2RlKTtcbiAgICBpZiAoIWlzRGVmaW5lZChhbW91bnQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhbW91bnQgPSBNYXRoLnJvdW5kKGFtb3VudCkgLyAxMDA7XG4gICAgbGFzdExheWVyRWZmZWN0VmFsdWVzLmludmVydCA9IHsgYW1vdW50IH07XG4gICAgcmV0dXJuIGBpbnZlcnQoJHthbW91bnR9KWA7XG59XG5mdW5jdGlvbiBidWlsZEVmZmVjdEluZm9TZXBpYShub2RlIC8qIEhUTUxBcmNnaXNFZmZlY3RzUG9wb3ZlcnNFbGVtZW50ICovKSB7XG4gICAgLy8gc2VwaWEoNTAlKVxuICAgIGNvbnN0IG51bWJlck5vZGUgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpO1xuICAgIGxldCBhbW91bnQgPSBnZXRWYWx1ZShudW1iZXJOb2RlKTtcbiAgICBpZiAoIWlzRGVmaW5lZChhbW91bnQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhbW91bnQgPSBNYXRoLnJvdW5kKGFtb3VudCkgLyAxMDA7XG4gICAgbGFzdExheWVyRWZmZWN0VmFsdWVzLnNlcGlhID0geyBhbW91bnQgfTtcbiAgICByZXR1cm4gYHNlcGlhKCR7YW1vdW50fSlgO1xufVxuLyogZnVuY3Rpb24gaGV4VG9IU0woaGV4OiBzdHJpbmcpOiBhbnkge1xuICBjb25zdCByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgbGV0IHIgPSBwYXJzZUludChyZXN1bHRbMV0sIDE2KTtcbiAgbGV0IGcgPSBwYXJzZUludChyZXN1bHRbMl0sIDE2KTtcbiAgbGV0IGIgPSBwYXJzZUludChyZXN1bHRbM10sIDE2KTtcbiAgKHIgLz0gMjU1KSwgKGcgLz0gMjU1KSwgKGIgLz0gMjU1KTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gIGxldCBoLFxuICAgIHMsXG4gICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKG1heCA9PSBtaW4pIHtcbiAgICBoID0gcyA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgY2FzZSByOlxuICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnOlxuICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjpcbiAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGggLz0gNjtcbiAgfVxuICBjb25zdCBIU0wgPSBuZXcgT2JqZWN0KCk7XG4gIEhTTFtcImhcIl0gPSBoO1xuICBIU0xbXCJzXCJdID0gcztcbiAgSFNMW1wibFwiXSA9IGw7XG4gIHJldHVybiBIU0w7XG59ICovXG5mdW5jdGlvbiBoZXhUb1JnYihoZXgpIHtcbiAgICBjb25zdCByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgID8ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgICAgICAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDE2KSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUobm9kZSkge1xuICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyKG5vZGUudmFsdWUpO1xuICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY2xhbXBlZCA9IE1hdGgubWluKG5vZGUubWF4LCBNYXRoLm1heChub2RlLm1pbiwgdmFsdWUpKTtcbiAgICAvLyBlbnN1cmUgdmFsdWUgaXMgd2l0aGluIGFsbG93ZWQgcmFuZ2VcbiAgICBub2RlLnZhbHVlID0gYCR7Y2xhbXBlZH1gO1xuICAgIHJldHVybiBjbGFtcGVkO1xufVxuZnVuY3Rpb24gcHgycHRSb3VuZFRvMyh2YWx1ZSwgcHJvcHMpIHtcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgc2NyZWVuVXRpbHMgfSA9IG1vZHVsZXM7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoc2NyZWVuVXRpbHMucHgycHQodmFsdWUpICogMTAwMCkgLyAxMDAwO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RmllbGQocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgcmVuZGVyZXIgfSA9IGxheWVyO1xuICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIG5vdCBsb29raW5nIGF0IEFyY2FkZSBleHByZXNzaW9uc1xuICAgIHN3aXRjaCAocmVuZGVyZXIudHlwZSkge1xuICAgICAgICBjYXNlIFwidW5pcXVlLXZhbHVlXCI6IHtcbiAgICAgICAgICAgIC8vIHR5cGVzLCBwcmVkb21pbmFuY2UsIHJlbGF0aW9uc2hpcFxuICAgICAgICAgICAgaWYgKCgoX2EgPSByZW5kZXJlci5hdXRob3JpbmdJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwicHJlZG9taW5hbmNlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvc1swXS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgoX2IgPSByZW5kZXJlci5hdXRob3JpbmdJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHlwZSkgPT09IFwicmVsYXRpb25zaGlwXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIuYXV0aG9yaW5nSW5mby5maWVsZDEuZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIuZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImNsYXNzLWJyZWFrc1wiOiB7XG4gICAgICAgICAgICAvLyBjb2xvciwgc2l6ZVxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZE5hbWUgPSAoX2MgPSByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMuZmluZCgodmlzVmFyKSA9PiB2aXNWYXIudHlwZSA9PT0gXCJjb2xvclwiKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpZWxkO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmllbGROYW1lID0gKF9kID0gcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzLmZpbmQoKHZpc1ZhcikgPT4gdmlzVmFyLnR5cGUgPT09IFwic2l6ZVwiICYmICF2aXNWYXIudGFyZ2V0ICYmIHZpc1Zhci52YWx1ZUV4cHJlc3Npb24gIT09IFwiJHZpZXcuc2NhbGVcIikpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5maWVsZDtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImRvdC1kZW5zaXR5XCI6XG4gICAgICAgICAgICByZXR1cm4gKF9lID0gcmVuZGVyZXIuYXR0cmlidXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdLmZpZWxkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgYXJjZ2lzRWZmZWN0c0NzcyA9IFwiOmhvc3R7aGVpZ2h0OjEwMCV9LmZsb3d7aGVpZ2h0OjEwMCV9LnBhbmVse2hlaWdodDoxMDAlfS5ub3RpY2V7bWFyZ2luOjAuNXJlbX0ucmFkaW8tYnV0dG9uc3twYWRkaW5nOjAuNXJlbTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlfS5oaW50e3BhZGRpbmc6MC4yNXJlbSAwLjVyZW07YmFja2dyb3VuZC1jb2xvcjp3aGl0ZX0uYmFzZW1hcC10eXBle3BhZGRpbmc6MC43NXJlbSAwLjVyZW0gMC4yNXJlbSAwLjVyZW19LnN3aXRjaHttYXJnaW4tcmlnaHQ6MC43NXJlbTttYXJnaW4tbGVmdDowO2FsaWduLXNlbGY6Y2VudGVyfS5saXN0e2ZsZXgtZmxvdzpjb2x1bW4gbm93cmFwO21hcmdpbjoxcHh9LmVmZmVjdC10aHVtYntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO3BhZGRpbmctbGVmdDowLjVyZW07Y3Vyc29yOnBvaW50ZXJ9LmVmZmVjdC10aHVtYi1pbWd7bWFyZ2luLXRvcDowLjI1cmVtO21hcmdpbi1ib3R0b206MC4yNXJlbTtoZWlnaHQ6NDhweDt3aWR0aDo0OHB4fS5hcmNnaXMtLXJ0bCAuc3dpdGNoe21hcmdpbi1sZWZ0OjAuNzVyZW07bWFyZ2luLXJpZ2h0OjB9LmFyY2dpcy0tcnRsIC5lZmZlY3QtdGh1bWJ7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowLjVyZW19XCI7XG5cbmNvbnN0IEFyY2dpc0VmZmVjdHMgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNDbG9zZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRWZmZWN0c0Nsb3NlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0VmZmVjdHNDaGFuZ2VcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzRWZmZWN0c0FwcGx5TGF5ZXJFZmZlY3QgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0VmZmVjdHNBcHBseUxheWVyRWZmZWN0XCIsIDcpO1xuICAgICAgICB0aGlzLnBvcG92ZXJzID0gW107XG4gICAgICAgIHRoaXMuaW1hZ2VzUGF0aCA9IFwiLi4vYXJjZ2lzLWFwcC1hc3NldHMvaW1hZ2VzL2VmZmVjdHMvdGVzdC5qcGdcIjtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIFByaXZhdGUgbWV0aG9kc1xuICAgICAgICAvL1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmFmdGVyQ3JlYXRlUGFuZWwgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYW5lbE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZmVhdHVyZUVmZmVjdFR5cGUsIHN1cHBvcnRzRmVhdHVyZUVmZmVjdHMgfSA9IHByb3BzO1xuICAgICAgICAgICAgLy8gb3BlbiBhbGwgcG9wb3ZlcnMgc28gd2UgaGF2ZSBhY2Nlc3MgdG8gYWxsIGN1cnJlbnQgcHJvcHNcbiAgICAgICAgICAgIC8vIGZlYXR1cmUgZWZmZWN0cyBhbGwgc2hhcmUgb25lIHBvcG92ZXJcbiAgICAgICAgICAgIGNvbnN0IHsgcG9wb3ZlcnMsIHBhbmVsTm9kZSB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmIChwb3BvdmVycykge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGVtXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3YWl0IHVudGlsIHBhbmVsTm9kZSBoYXMgZGltZW5zaW9uc1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGFsbFR5cGVzID0gc3VwcG9ydHNGZWF0dXJlRWZmZWN0c1xuICAgICAgICAgICAgICAgICAgICA/IGFsbExheWVyRWZmZWN0VHlwZXMuY29uY2F0KFtcImZlYXR1cmVFZmZlY3RcIl0pXG4gICAgICAgICAgICAgICAgICAgIDogYWxsTGF5ZXJFZmZlY3RUeXBlcztcbiAgICAgICAgICAgICAgICBhbGxUeXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvcG92ZXJzW3R5cGVdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChgYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnNgKTtcbiAgICAgICAgICAgICAgICAgICAgcG9wb3ZlcnNbdHlwZV0ucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICAgICAgcG9wb3ZlcnNbdHlwZV0udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHBvcG92ZXJzW3R5cGVdLnJlZmVyZW5jZUVsZW1lbnQgPSBwYW5lbE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHBvcG92ZXJzW3R5cGVdLnBvcG92ZXJzID0gcG9wb3ZlcnM7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocG9wb3ZlcnNbdHlwZV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlRWZmZWN0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBzdGFydGluZyB3aXRoIGEgc2V0IGZlYXR1cmUgZWZmZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcG92ZXIgPSBwb3BvdmVyc1tcImZlYXR1cmVFZmZlY3RcIl07XG4gICAgICAgICAgICAgICAgICAgIHBvcG92ZXIub3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBvcG92ZXIudXBkYXRlSGVhZGVyKGZlYXR1cmVFZmZlY3RUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblN3aXRjaEVmZmVjdFR5cGUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIHBvcG92ZXJzIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBwcm9wcy5sYXllcjtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAvLyBjbG9zZSBhbGwgcG9wb3ZlcnNcbiAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBwb3BvdmVycykge1xuICAgICAgICAgICAgICAgIHBvcG92ZXJzW2tleV0ub3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuc2VsZWN0ZWRJdGVtLnZhbHVlID09PSBcImxheWVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RGZWF0dXJlRWZmZWN0ID0gbGF5ZXIuZmVhdHVyZUVmZmVjdCB8fCB0aGlzLmxhc3RGZWF0dXJlRWZmZWN0O1xuICAgICAgICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxheWVyLmVmZmVjdCA9IHRoaXMubGFzdExheWVyRWZmZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0ZlYXR1cmVFZmZlY3RzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBcImZlYXR1cmVcIlxuICAgICAgICAgICAgICAgIHRoaXMubGFzdExheWVyRWZmZWN0ID0gbGF5ZXIuZWZmZWN0O1xuICAgICAgICAgICAgICAgIGxheWVyLmVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdEZlYXR1cmVFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZmVhdHVyZUVmZmVjdCA9IHRoaXMubGFzdEZlYXR1cmVFZmZlY3Q7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmZlYXR1cmVFZmZlY3RUeXBlID0gcGFyc2VFZmZlY3RzKHByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYmFja2dyb3VuZFRoZW1lIH0gPSBwcm9wcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RGZWF0dXJlRWZmZWN0VHlwZShiYWNrZ3JvdW5kVGhlbWUgPT09IFwibGlnaHRcIiA/IGFsbExpZ2h0RmVhdHVyZUVmZmVjdFR5cGVzWzBdIDogYWxsRGFya0ZlYXR1cmVFZmZlY3RUeXBlc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0ZlYXR1cmVFZmZlY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3BvdmVyID0gcG9wb3ZlcnNbXCJmZWF0dXJlRWZmZWN0XCJdO1xuICAgICAgICAgICAgICAgIHBvcG92ZXIub3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcG9wb3Zlci51cGRhdGVIZWFkZXIocHJvcHMuZmVhdHVyZUVmZmVjdFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUmVtb3ZlRWZmZWN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHByb3BzO1xuICAgICAgICAgICAgbGF5ZXIuZWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pc1Vuc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Td2l0Y2hDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9wb3ZlcnMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBzd2l0Y2hOb2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBxdWVyeVBhcmVudEVsZW1lbnQoc3dpdGNoTm9kZSwgXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBpdGVtTm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGlmICghc3dpdGNoTm9kZS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgcG9wb3ZlcnNbdHlwZV0ub3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGl0ZW1Ob2RlLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNBcHBseUxheWVyRWZmZWN0LmVtaXQoeyB0eXBlLCBrZWVwU3dpdGNoOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRmVhdHVyZUVmZmVjdEVuYWJsZWRTd2l0Y2hDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9wb3ZlcnMsIHByb3BzLCBsaWdodExpc3ROb2RlLCBkYXJrTGlzdE5vZGUgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBsYXllciA9IHByb3BzLmxheWVyO1xuICAgICAgICAgICAgY29uc3Qgc3dpdGNoTm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGlmICghc3dpdGNoTm9kZS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgcG9wb3ZlcnNbXCJmZWF0dXJlRWZmZWN0XCJdLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsaWdodExpc3ROb2RlID09PSBudWxsIHx8IGxpZ2h0TGlzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpZ2h0TGlzdE5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIpLmZvckVhY2goKGl0ZW0pID0+IChpdGVtLnNlbGVjdGVkID0gZmFsc2UpKTtcbiAgICAgICAgICAgICAgICBkYXJrTGlzdE5vZGUgPT09IG51bGwgfHwgZGFya0xpc3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXJrTGlzdE5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIpLmZvckVhY2goKGl0ZW0pID0+IChpdGVtLnNlbGVjdGVkID0gZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RGZWF0dXJlRWZmZWN0ID0gbGF5ZXIuZmVhdHVyZUVmZmVjdDtcbiAgICAgICAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNDaGFuZ2UuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdEZlYXR1cmVFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZmVhdHVyZUVmZmVjdCA9IHRoaXMubGFzdEZlYXR1cmVFZmZlY3Q7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmZlYXR1cmVFZmZlY3RUeXBlID0gcGFyc2VFZmZlY3RzKHByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYmFja2dyb3VuZFRoZW1lIH0gPSBwcm9wcztcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZmVhdHVyZUVmZmVjdFR5cGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZFRoZW1lID09PSBcImxpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFsbExpZ2h0RmVhdHVyZUVmZmVjdFR5cGVzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhbGxEYXJrRmVhdHVyZUVmZmVjdFR5cGVzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaWdodExpc3ROb2RlID09PSBudWxsIHx8IGxpZ2h0TGlzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpZ2h0TGlzdE5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IHByb3BzLmZlYXR1cmVFZmZlY3RUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRhcmtMaXN0Tm9kZSA9PT0gbnVsbCB8fCBkYXJrTGlzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhcmtMaXN0Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS52YWx1ZSA9PT0gcHJvcHMuZmVhdHVyZUVmZmVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RGZWF0dXJlRWZmZWN0VHlwZShwcm9wcy5mZWF0dXJlRWZmZWN0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3BlblBvcG92ZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9wb3ZlcnMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGxldCBpdGVtTm9kZTtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSBcImltZ1wiKSB7XG4gICAgICAgICAgICAgICAgaXRlbU5vZGUgPSBxdWVyeVBhcmVudEVsZW1lbnQodGFyZ2V0LCBcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFnTmFtZSA9PT0gXCJjYWxjaXRlLXN3aXRjaFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Ob2RlID0gcXVlcnlQYXJlbnRFbGVtZW50KHRhcmdldCwgXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YWdOYW1lID09PSBcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIpIHtcbiAgICAgICAgICAgICAgICBpdGVtTm9kZSA9IHRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1Ob2RlLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBpdGVtTm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGlzRmVhdHVyZUVmZmVjdFR5cGUgPSBhbGxMaWdodEZlYXR1cmVFZmZlY3RUeXBlcy5jb25jYXQoYWxsRGFya0ZlYXR1cmVFZmZlY3RUeXBlcykuaW5kZXhPZih0eXBlKSA+IC0xO1xuICAgICAgICAgICAgaWYgKGlzRmVhdHVyZUVmZmVjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZlYXR1cmVFZmZlY3RUeXBlKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbGF5ZXIgZWZmZWN0c1xuICAgICAgICAgICAgICAgIGNvbnN0IHN3aXRjaE5vZGUgPSBpdGVtTm9kZS5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1zd2l0Y2hcIik7XG4gICAgICAgICAgICAgICAgaWYgKHBvcG92ZXJzW3R5cGVdLm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSBvcGVuIHRoZW4gY2xvc2UgcG9wb3ZlciBhbmQgdG9nZ2xlIG9mZlxuICAgICAgICAgICAgICAgICAgICBwb3BvdmVyc1t0eXBlXS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaE5vZGUuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpdGVtTm9kZS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNBcHBseUxheWVyRWZmZWN0LmVtaXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBlZmZlY3Qgb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzd2l0Y2hOb2RlLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaE5vZGUuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNBcHBseUxheWVyRWZmZWN0LmVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSBvdGhlciBwb3BvdmVyc1xuICAgICAgICAgICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBwb3BvdmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wb3ZlcnNba2V5XS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9wb3ZlcnNbdHlwZV0ub3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnZpZXcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGlkZUxheWVyVGl0bGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZVJlbmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVW5zdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93RmVhdHVyZUVmZmVjdHMgPSBmYWxzZTtcbiAgICB9XG4gICAgYXJjZ2lzRWZmZWN0c0FwcGx5TGF5ZXJFZmZlY3RIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGxpc3ROb2RlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGxheWVyIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgdHlwZSA9IChfYSA9IGV2ZW50LmRldGFpbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGU7XG4gICAgICAgIGlmICh0eXBlICYmICEoKF9iID0gZXZlbnQuZGV0YWlsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iua2VlcFN3aXRjaCkpIHtcbiAgICAgICAgICAgIC8vIHRvZ2dsZSBlZmZlY3Qgb24gaWYgaXQncyBub3QgYWxyZWFkeVxuICAgICAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBBcnJheS5mcm9tKGxpc3ROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiKSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnZhbHVlID09PSB0eXBlKVswXTtcbiAgICAgICAgICAgIGl0ZW1Ob2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLXN3aXRjaFwiKS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZmZlY3RzID0gYnVpbGRFZmZlY3RzSW5mbyh0aGlzLmxpc3ROb2RlLCB0aGlzLnBvcG92ZXJzLCBwcm9wcyk7XG4gICAgICAgIGxheWVyLmVmZmVjdCA9IGVmZmVjdHM7XG4gICAgICAgIHRoaXMuYXJjZ2lzRWZmZWN0c0NoYW5nZS5lbWl0KCk7XG4gICAgICAgIHByb3BzLmVmZmVjdHNKU09OID0gcGFyc2VFZmZlY3RzKHByb3BzKTtcbiAgICAgICAgLy8gcmVmcmVzaCB0byBnZXQgdGhlIG51bWJlcnNcbiAgICAgICAgLy90aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgfVxuICAgIGFyY2dpc0VmZmVjdHNQb3BvdmVyRmlsdGVyQ2hhbmdlSGFuZGxlcihldmVudCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBob3N0RWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHdoZXJlID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBpdGVtTm9kZSA9IEFycmF5LmZyb20oaG9zdEVsZW1lbnQuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikpLmZpbmQoKG5vZGUpID0+IG5vZGUuc2VsZWN0ZWQpO1xuICAgICAgICBjb25zdCB0eXBlID0gaXRlbU5vZGUgPT09IG51bGwgfHwgaXRlbU5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW1Ob2RlLnZhbHVlO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIHRvbyBlYXJseSwgYnV0IG5lZWQgdG8gYXBwbHkgdGhlIGZpbHRlciBsYXRlciBvbmNlIGEgdHlwZSBnZXRzIHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRXaGVyZSA9IHdoZXJlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYSBmZWF0dXJlIGVmZmVjdCB0eXBlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0ID0gYnVpbGRGZWF0dXJlRWZmZWN0KHR5cGUsIHdoZXJlLCBwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNDaGFuZ2UuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFyY2dpc0VmZmVjdHNQb3BvdmVyQ2xvc2VIYW5kbGVyKCkge1xuICAgICAgICBjb25zdCB7IGxpc3ROb2RlLCBsaWdodExpc3ROb2RlLCBkYXJrTGlzdE5vZGUgfSA9IHRoaXM7XG4gICAgICAgIGxpc3ROb2RlID09PSBudWxsIHx8IGxpc3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRGb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGlnaHRMaXN0Tm9kZSA9PT0gbnVsbCB8fCBsaWdodExpc3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaWdodExpc3ROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRhcmtMaXN0Tm9kZSA9PT0gbnVsbCB8fCBkYXJrTGlzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhcmtMaXN0Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNldEZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHVibGljIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKipcbiAgICAgKiBTZXQgZm9jdXMgb24gY29tcG9uZW50XG4gICAgICovXG4gICAgYXN5bmMgc2V0Rm9jdXMoZm9jdXNJZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIWZvY3VzSWQgfHwgZm9jdXNJZCA9PT0gXCJkaXNtaXNzLWJ1dHRvblwiKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnBhbmVsTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy5saXN0Tm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldEZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBjb21wb25lbnQsIGNsb3NlcyBwb3BvdmVyc1xuICAgICAqL1xuICAgIGFzeW5jIGRvbmUoKSB7XG4gICAgICAgIGNvbnN0IHsgcG9wb3ZlcnMgfSA9IHRoaXM7XG4gICAgICAgIC8vIGNsb3NlICBwb3BvdmVyc1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiBwb3BvdmVycykge1xuICAgICAgICAgICAgcG9wb3ZlcnNba2V5XS5vcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhcmNnaXMtZWZmZWN0cy1wb3BvdmVyc1wiKVxuICAgICAgICAgICAgLmZvckVhY2goKG5vZGUpID0+IG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKSk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBsYXllciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgW3N0cmluZ3MsIGN1cnJlbnRMYW5ndWFnZV0gPSBhd2FpdCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICBjb25zdCBzdXBwb3J0c0ZlYXR1cmVFZmZlY3RzID0gIWxheWVyLmZlYXR1cmVSZWR1Y3Rpb24gJiZcbiAgICAgICAgICAgIFtcImZlYXR1cmVcIiwgXCJnZW9qc29uXCIsIFwib2djLWZlYXR1cmVcIiwgXCJ3ZnNcIiwgXCJjc3ZcIiwgXCJzdHJlYW1cIl0uaW5kZXhPZihsYXllci50eXBlKSA+IC0xO1xuICAgICAgICB0aGlzLnByb3BzID0geyB2aWV3LCBsYXllciwgc3RyaW5ncywgc3VwcG9ydHNGZWF0dXJlRWZmZWN0cyB9O1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBwcm9wcy5sb2NhbGUgPSBjdXJyZW50TGFuZ3VhZ2U7XG4gICAgICAgIGNvbnN0IFtGZWF0dXJlRWZmZWN0LCBlZmZlY3RzVXRpbHMsIHNjcmVlblV0aWxzLCBjb2xvclV0aWxzXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgICAgIFwiZXNyaS9sYXllcnMvc3VwcG9ydC9GZWF0dXJlRWZmZWN0XCIsXG4gICAgICAgICAgICBcImVzcmkvbGF5ZXJzL2VmZmVjdHMvanNvblV0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvY29yZS9zY3JlZW5VdGlsc1wiLFxuICAgICAgICAgICAgXCJlc3JpL3ZpZXdzL3N1cHBvcnQvY29sb3JVdGlsc1wiXG4gICAgICAgIF0pO1xuICAgICAgICBwcm9wcy5tb2R1bGVzID0geyBGZWF0dXJlRWZmZWN0LCBlZmZlY3RzVXRpbHMsIHNjcmVlblV0aWxzIH07XG4gICAgICAgIHByb3BzLmJhY2tncm91bmRUaGVtZSA9IHZpZXcgJiYgKGF3YWl0IGNvbG9yVXRpbHMuZ2V0QmFja2dyb3VuZENvbG9yVGhlbWUodmlldykpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYW55TGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICAgIGlmIChhbnlMYXllci5lZmZlY3QgJiYgYW55TGF5ZXIuZmVhdHVyZUVmZmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNVbnN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbnlMYXllci5lZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5lZmZlY3RzSlNPTiA9IHBhcnNlRWZmZWN0cyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImxheWVyLmVmZmVjdFwiLCAobGF5ZXIgYXMgYW55KS5lZmZlY3QsIHByb3BzLmVmZmVjdHNKU09OKTtcbiAgICAgICAgICAgICAgICBzb3J0RWZmZWN0cyhwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbnlMYXllci5mZWF0dXJlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuZmVhdHVyZUVmZmVjdFR5cGUgPSBwYXJzZUVmZmVjdHMocHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmlzVW5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnNldEZvY3VzKCkpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIGZpbHRlciAoOS40KSBvbmx5IGZvciB0aGVzZSBsYXllciB0eXBlcyAobm90IGhlYXRtYXApOiBfX2VzcmkuRmVhdHVyZUxheWVyIHwgX19lc3JpLkNTVkxheWVyIHwgX19lc3JpLldGU0xheWVyIHwgX19lc3JpLlN0cmVhbUxheWVyXG4gICAgICAgIGNvbnN0IHsgaXNVbnN1cHBvcnRlZCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IFwiY2FsY2l0ZS1tYXRjaC1oZWlnaHRcIiB9LCBoKFwiY2FsY2l0ZS1mbG93XCIsIHsgY2xhc3M6IENTUyQxLmZsb3csIGRpcjogZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZmxvd05vZGUgPSBub2RlKSB9LCBpc1Vuc3VwcG9ydGVkID8gdGhpcy5yZW5kZXJVbnN1cHBvcnRlZCgpIDogdGhpcy5yZW5kZXJDb250ZW50KCkpKSk7XG4gICAgfVxuICAgIHJlbmRlclVuc3VwcG9ydGVkKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBoaWRlTGF5ZXJUaXRsZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtcGFuZWxcIiwgeyBoZWFkaW5nOiBzdHJpbmdzLmdlbmVyYWwuZWZmZWN0cywgZGVzY3JpcHRpb246ICFoaWRlTGF5ZXJUaXRsZSA/IGxheWVyLnRpdGxlIDogdW5kZWZpbmVkLCBjbGFzczoge1xuICAgICAgICAgICAgICAgIFtDU1MkMS5wYW5lbF06IHRydWUsXG4gICAgICAgICAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IHJ0bFxuICAgICAgICAgICAgfSwgY2xvc2FibGU6IHRydWUsIG9uQ2FsY2l0ZVBhbmVsQ2xvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNDbG9zZS5lbWl0KCk7XG4gICAgICAgICAgICB9LCByZWY6IChub2RlKSA9PiAodGhpcy5wYW5lbE5vZGUgPSBub2RlKSB9LCBoKFwiY2FsY2l0ZS10aXBcIiwgeyBoZWFkaW5nOiBzdHJpbmdzLmVycm9yLnRpdGxlLCBjbG9zZURpc2FibGVkOiB0cnVlIH0sIGgoXCJkaXZcIiwgbnVsbCwgc3RyaW5ncy5lcnJvci50ZXh0MSksIGgoXCJkaXZcIiwgbnVsbCwgc3RyaW5ncy5lcnJvci50ZXh0MikpLCBoKFwiY2FsY2l0ZS1mYWJcIiwgeyBjbGFzczogXCJhdXRvZm9jdXNcIiwgc2xvdDogXCJmYWJcIiwgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwga2luZDogXCJuZXV0cmFsXCIsIHNjYWxlOiBcInNcIiwgdGV4dEVuYWJsZWQ6IHRydWUsIGljb246IG51bGwsIGxhYmVsOiBzdHJpbmdzLmVycm9yLmJ1dHRvbiwgdGV4dDogc3RyaW5ncy5lcnJvci5idXR0b24sIG9uQ2xpY2s6IHRoaXMub25SZW1vdmVFZmZlY3QgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyQ29udGVudCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgaGlkZUxheWVyVGl0bGUsIHNob3dGZWF0dXJlRWZmZWN0cyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgc3VwcG9ydHNGZWF0dXJlRWZmZWN0cywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIGNvbnN0IGhhc0ZlYXR1cmVFZmZlY3QgPSBzdXBwb3J0c0ZlYXR1cmVFZmZlY3RzICYmICEhbGF5ZXIuZmVhdHVyZUVmZmVjdDtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1wYW5lbFwiLCB7IGhlYWRpbmc6IHN0cmluZ3MuZ2VuZXJhbC5lZmZlY3RzLCBkZXNjcmlwdGlvbjogIWhpZGVMYXllclRpdGxlID8gbGF5ZXIudGl0bGUgOiB1bmRlZmluZWQsIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgW0NTUyQxLnBhbmVsXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICAgICAgICB9LCBjbG9zYWJsZTogdHJ1ZSwgb25DYWxjaXRlUGFuZWxDbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlIGFsbCBwb3BvdmVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9wb3ZlcnMgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBwb3BvdmVycykge1xuICAgICAgICAgICAgICAgICAgICBwb3BvdmVyc1trZXldLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNFZmZlY3RzQ2xvc2UuZW1pdCgpO1xuICAgICAgICAgICAgfSwgcmVmOiB0aGlzLmFmdGVyQ3JlYXRlUGFuZWwgfSwgdGhpcy5yZW5kZXJUaXAoKSwgc3VwcG9ydHNGZWF0dXJlRWZmZWN0cyA/IChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQxLnJhZGlvQnV0dG9ucyB9LCBoKFwiY2FsY2l0ZS1zZWdtZW50ZWQtY29udHJvbFwiLCB7IGxheW91dDogXCJob3Jpem9udGFsXCIsIGFwcGVhcmFuY2U6IFwic29saWRcIiwgc2NhbGU6IFwic1wiLCB3aWR0aDogXCJmdWxsXCIsIG9uQ2FsY2l0ZVNlZ21lbnRlZENvbnRyb2xDaGFuZ2U6IHRoaXMub25Td2l0Y2hFZmZlY3RUeXBlIH0sIGgoXCJjYWxjaXRlLXNlZ21lbnRlZC1jb250cm9sLWl0ZW1cIiwgeyB2YWx1ZTogXCJsYXllclwiLCBjaGVja2VkOiAhKGhhc0ZlYXR1cmVFZmZlY3QgfHwgc2hvd0ZlYXR1cmVFZmZlY3RzKSB9LCBzdHJpbmdzLmdlbmVyYWwud2hvbGVMYXllciksIGgoXCJjYWxjaXRlLXNlZ21lbnRlZC1jb250cm9sLWl0ZW1cIiwgeyB2YWx1ZTogXCJmZWF0dXJlXCIsIGNoZWNrZWQ6IGhhc0ZlYXR1cmVFZmZlY3QgfHwgc2hvd0ZlYXR1cmVFZmZlY3RzIH0sIHN0cmluZ3MuZ2VuZXJhbC5mZWF0dXJlU3BlY2lmaWMpKSkpIDogbnVsbCwgaGFzRmVhdHVyZUVmZmVjdCB8fCBzaG93RmVhdHVyZUVmZmVjdHNcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJGZWF0dXJlRWZmZWN0c0NvbnRlbnQoKVxuICAgICAgICAgICAgOiB0aGlzLnJlbmRlckxheWVyRWZmZWN0c0NvbnRlbnQoKSkpO1xuICAgIH1cbiAgICByZW5kZXJUaXAoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGlmIChnZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5cy5BUkNHSVNfQ09NUE9ORU5UX05PVElGSUNBVElPTlMsIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzLkVGRkVDVFNfVElQX0RJU01JU1NFRCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMS5ub3RpY2UgfSwgaChcImNhbGNpdGUtbm90aWNlXCIsIHsgc2NhbGU6IFwic1wiLCB3aWR0aDogXCJmdWxsXCIsIG9wZW46IHRydWUsIGNsb3NhYmxlOiB0cnVlLCBvbkNhbGNpdGVOb3RpY2VDbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXlzLkFSQ0dJU19DT01QT05FTlRfTk9USUZJQ0FUSU9OUywge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzLkVGRkVDVFNfVElQX0RJU01JU1NFRCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IH0sIGgoXCJkaXZcIiwgeyBzbG90OiBcIm1lc3NhZ2VcIiB9LCBzdHJpbmdzLmdlbmVyYWwubm90aWNlKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyTGF5ZXJFZmZlY3RzQ29udGVudCgpIHtcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgbnVsbCwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMS5oaW50IH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwic1wiIH0sIHN0cmluZ3MuZ2VuZXJhbC5kcmFnVG9SZW9yZGVyKSksIGgoXCJjYWxjaXRlLXZhbHVlLWxpc3RcIiwgeyBjbGFzczogQ1NTJDEubGlzdCwgZHJhZ0VuYWJsZWQ6IHRydWUsIG9uQ2FsY2l0ZUxpc3RPcmRlckNoYW5nZTogKCkgPT4gdGhpcy5hcmNnaXNFZmZlY3RzQXBwbHlMYXllckVmZmVjdC5lbWl0KCksIHJlZjogKG5vZGUpID0+ICh0aGlzLmxpc3ROb2RlID0gbm9kZSkgfSwgYWxsTGF5ZXJFZmZlY3RUeXBlcy5tYXAoKHR5cGUpID0+IHRoaXMucmVuZGVyTGF5ZXJFZmZlY3RJdGVtKHR5cGUpKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyTGF5ZXJFZmZlY3RJdGVtKHR5cGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGVmZmVjdHNKU09OLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGVmZmVjdFBvcyA9IC0xO1xuICAgICAgICBlZmZlY3RzSlNPTiAmJlxuICAgICAgICAgICAgKChfYSA9IEFycmF5LmZyb20oZWZmZWN0c0pTT04pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoZWZmZWN0LCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IGNvbnZlcnRUb0FQSVR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0UG9zID0gaWR4ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIsIHsgbGFiZWw6IHN0cmluZ3MuZWZmZWN0c1RpdGxlW3R5cGVdLCBkZXNjcmlwdGlvbjogc3RyaW5ncy5lZmZlY3RzU3VtbWFyeVt0eXBlXSwgdmFsdWU6IHR5cGUsIG9uQ2xpY2s6IHRoaXMub3BlblBvcG92ZXIsIG9uS2V5RG93bjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlblBvcG92ZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzcGFjZSBrZXkgaXMgcmVzZXJ2ZWQgZm9yIGRyYWctbi1kcm9wXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RWxlbWVudCA9IGNvbXBvc2VkUGF0aFswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RWxlbWVudC50YWdOYW1lICE9PSBcIlNQQU5cIiB8fCAhZmlyc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImhhbmRsZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuUG9wb3ZlcihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IH0sIGgoXCJkaXZcIiwgeyBzbG90OiBcImFjdGlvbnMtc3RhcnRcIiwgY2xhc3M6IENTUyQxLmVmZmVjdFRodW1iIH0sIGgoXCJpbWdcIiwgeyBjbGFzczogQ1NTJDEuZWZmZWN0VGh1bWJJbWcsXG4gICAgICAgICAgICAvL2NsYXNzPXtgJHtDU1MuZWZmZWN0VGh1bWJJbWd9ICR7ZWZmZWN0UG9zID4gMCA/IGBibHVyYCA6IGBgfWB9XG4gICAgICAgICAgICBzcmM6IGdldEFzc2V0UGF0aChgLi9hc3NldHMvZWZmZWN0LXRodW1icy8ke3R5cGV9LnBuZ2ApLCBhbHQ6IFwiXCIgfSkpLCBoKFwiY2FsY2l0ZS1zd2l0Y2hcIiwgeyBzY2FsZTogXCJzXCIsIGNoZWNrZWQ6IGVmZmVjdFBvcyA+IDAsIHNsb3Q6IFwiYWN0aW9ucy1lbmRcIiwgY2xhc3M6IENTUyQxLnN3aXRjaCwgb25DYWxjaXRlU3dpdGNoQ2hhbmdlOiB0aGlzLm9uU3dpdGNoQ2hhbmdlIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckZlYXR1cmVFZmZlY3RzQ29udGVudCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgbGFzdEZlYXR1cmVFZmZlY3QsIHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIGJhY2tncm91bmRUaGVtZSB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGlzTGlnaHRCYWNrZ3JvdW5kID0gYmFja2dyb3VuZFRoZW1lID09PSBcImxpZ2h0XCI7XG4gICAgICAgIGNvbnN0IGxpZ2h0Q29udGVudCA9IChoKFwiZGl2XCIsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEuYmFzZW1hcFR5cGUgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSwgc3RyaW5ncy5nZW5lcmFsLmxpZ2h0QmFzZW1hcHMpKSwgaChcImNhbGNpdGUtdmFsdWUtbGlzdFwiLCB7IGNsYXNzOiBDU1MkMS5saXN0LCBcImRhdGEtdmFsdWVcIjogXCJsaWdodFwiLCByZWY6IChub2RlKSA9PiAodGhpcy5saWdodExpc3ROb2RlID0gbm9kZSkgfSwgYWxsTGlnaHRGZWF0dXJlRWZmZWN0VHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLnJlbmRlckZlYXR1cmVFZmZlY3RJdGVtKHR5cGUsIFwibGlnaHRcIikpKSkpO1xuICAgICAgICBjb25zdCBkYXJrQ29udGVudCA9IChoKFwiZGl2XCIsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEuYmFzZW1hcFR5cGUgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSwgc3RyaW5ncy5nZW5lcmFsLmRhcmtCYXNlbWFwcykpLCBoKFwiY2FsY2l0ZS12YWx1ZS1saXN0XCIsIHsgY2xhc3M6IENTUyQxLmxpc3QsIFwiZGF0YS12YWx1ZVwiOiBcImRhcmtcIiwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZGFya0xpc3ROb2RlID0gbm9kZSkgfSwgYWxsRGFya0ZlYXR1cmVFZmZlY3RUeXBlcy5tYXAoKHR5cGUpID0+IHRoaXMucmVuZGVyRmVhdHVyZUVmZmVjdEl0ZW0odHlwZSwgXCJkYXJrXCIpKSkpKTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEuaGludCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiB9LCBzdHJpbmdzLmdlbmVyYWwuZW1waGFzaXplKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIsIGxheW91dDogXCJpbmxpbmUtc3BhY2UtYmV0d2VlblwiIH0sIHN0cmluZ3MuZ2VuZXJhbC5lbmFibGVkLCBoKFwiY2FsY2l0ZS1zd2l0Y2hcIiwgeyBzY2FsZTogXCJzXCIsIGNoZWNrZWQ6ICEhKGxheWVyLmZlYXR1cmVFZmZlY3QgfHwgbGFzdEZlYXR1cmVFZmZlY3QpLCBvbkNhbGNpdGVTd2l0Y2hDaGFuZ2U6IHRoaXMub25GZWF0dXJlRWZmZWN0RW5hYmxlZFN3aXRjaENoYW5nZSwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZW5hYmxlZFN3aXRjaE5vZGUgPSBub2RlKSB9KSkpLCBpc0xpZ2h0QmFja2dyb3VuZCA/IGxpZ2h0Q29udGVudCA6IGRhcmtDb250ZW50LCBpc0xpZ2h0QmFja2dyb3VuZCA/IGRhcmtDb250ZW50IDogbGlnaHRDb250ZW50KSk7XG4gICAgfVxuICAgIHJlbmRlckZlYXR1cmVFZmZlY3RJdGVtKHR5cGUsIHRoZW1lKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgZmVhdHVyZUVmZmVjdFR5cGUsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBpbkxpZ2h0ID0gYWxsTGlnaHRGZWF0dXJlRWZmZWN0VHlwZXMuZmluZCgoZmVUeXBlKSA9PiB0eXBlID09PSBmZVR5cGUpO1xuICAgICAgICBjb25zdCBpbkRhcmsgPSBhbGxEYXJrRmVhdHVyZUVmZmVjdFR5cGVzLmZpbmQoKGZlVHlwZSkgPT4gdHlwZSA9PT0gZmVUeXBlKTtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIiwgeyBsYWJlbDogc3RyaW5ncy5mZWF0dXJlRWZmZWN0c1RpdGxlW3R5cGVdLCBkZXNjcmlwdGlvbjogc3RyaW5ncy5mZWF0dXJlRWZmZWN0c1N1bW1hcnlbdHlwZV0sIHZhbHVlOiB0eXBlLCBzZWxlY3RlZDogZmVhdHVyZUVmZmVjdFR5cGUgPT09IHR5cGUsIG9uQ2xpY2s6IHRoaXMub3BlblBvcG92ZXIsIG9uS2V5RG93bjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlblBvcG92ZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzcGFjZSBrZXkgaXMgcmVzZXJ2ZWQgZm9yIGRyYWctbi1kcm9wXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RWxlbWVudCA9IGNvbXBvc2VkUGF0aFswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RWxlbWVudC50YWdOYW1lICE9PSBcIlNQQU5cIiB8fCAhZmlyc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImhhbmRsZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuUG9wb3ZlcihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IH0sIGgoXCJkaXZcIiwgeyBzbG90OiBcImFjdGlvbnMtc3RhcnRcIiwgY2xhc3M6IENTUyQxLmVmZmVjdFRodW1iIH0sIGgoXCJpbWdcIiwgeyBjbGFzczogYCR7Q1NTJDEuZWZmZWN0VGh1bWJJbWd9IGZlYXR1cmVgLCBzcmM6IGdldEFzc2V0UGF0aChgLi9hc3NldHMvZWZmZWN0LXRodW1icy8ke3R5cGV9JHtpbkxpZ2h0ICYmIGluRGFyayA/IGBfJHt0aGVtZX1gIDogYGB9LnBuZ2ApLCBhbHQ6IFwiXCIgfSkpKSk7XG4gICAgfVxuICAgIHNlbGVjdEZlYXR1cmVFZmZlY3RUeXBlKHR5cGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBwb3BvdmVycywgcHJvcHMsIGxpZ2h0TGlzdE5vZGUsIGRhcmtMaXN0Tm9kZSwgZGVmYXVsdFdoZXJlLCBlbmFibGVkU3dpdGNoTm9kZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciB9ID0gcHJvcHM7XG4gICAgICAgIHByb3BzLmZlYXR1cmVFZmZlY3RUeXBlID0gdHlwZTtcbiAgICAgICAgLy8gdW5zZWxlY3QgaXRlbSBmcm9tIHNlY29uZCBsaXN0XG4gICAgICAgIGxpZ2h0TGlzdE5vZGUgPT09IG51bGwgfHwgbGlnaHRMaXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlnaHRMaXN0Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQgJiYgaXRlbS52YWx1ZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRhcmtMaXN0Tm9kZSA9PT0gbnVsbCB8fCBkYXJrTGlzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhcmtMaXN0Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQgJiYgaXRlbS52YWx1ZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGZlYXR1cmUgZWZmZWN0c1xuICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0ID0gYnVpbGRGZWF0dXJlRWZmZWN0KHR5cGUsICgoX2IgPSAoX2EgPSBsYXllci5mZWF0dXJlRWZmZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud2hlcmUpIHx8IGRlZmF1bHRXaGVyZSwgcHJvcHMpO1xuICAgICAgICB0aGlzLmRlZmF1bHRXaGVyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hcmNnaXNFZmZlY3RzQ2hhbmdlLmVtaXQoKTtcbiAgICAgICAgY29uc3QgcG9wb3ZlciA9IHBvcG92ZXJzW1wiZmVhdHVyZUVmZmVjdFwiXTtcbiAgICAgICAgaWYgKHBvcG92ZXIub3Blbikge1xuICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSBvcGVuIHRoZW4ganVzdCByZW5hbWUgdGl0bGVcbiAgICAgICAgICAgIHBvcG92ZXIudXBkYXRlSGVhZGVyKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY2xvc2Ugb3RoZXIgcG9wb3ZlcnNcbiAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBwb3BvdmVycykge1xuICAgICAgICAgICAgICAgIHBvcG92ZXJzW2tleV0ub3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9wb3Zlci5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHBvcG92ZXIudXBkYXRlSGVhZGVyKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmFibGVkU3dpdGNoTm9kZSkge1xuICAgICAgICAgICAgLy8gYWZ0ZXIgYSBsaXN0IGNsaWNrXG4gICAgICAgICAgICBlbmFibGVkU3dpdGNoTm9kZS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFmdGVyIGEgbGF5ZXIgZWZmZWN0IC0+IGZlYXR1cmUgZWZmZWN0IHN3aXRjaFxuICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgYXNzZXRzRGlycygpIHsgcmV0dXJuIFtcImFzc2V0c1wiXTsgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNFZmZlY3RzLnN0eWxlID0gYXJjZ2lzRWZmZWN0c0NzcztcblxuY29uc3QgQ1NTID0ge1xuICAgIHBvcG92ZXI6IFwicG9wb3ZlclwiLFxuICAgIHBhbmVsOiBcInBhbmVsXCIsXG4gICAgYXV0bzogXCJhdXRvXCIsXG4gICAgY29udGVudDogXCJlZmZlY3RzLWNvbnRlbnRcIixcbiAgICBib3R0b21TcGFjZTogXCJib3R0b20tc3BhY2VcIixcbiAgICBib3R0b21TcGFjZUxpdHRsZTogXCJib3R0b20tc3BhY2UtbGl0dGxlXCIsXG4gICAgc3dpdGNoOiBcInN3aXRjaFwiLFxuICAgIHJlc2V0OiBcInJlc2V0XCIsXG4gICAgc3ViSGVhZGVyOiBcInN1Yi1oZWFkZXJcIlxufTtcblxuY29uc3QgU2VsZWN0Q1NTJDEgPSB7XG4gICAgYmFzZTogXCJzZWxlY3QtbnVtYmVyXCIsXG4gICAgaW5wdXQ6IFwic2VsZWN0LW51bWJlcl9faW5wdXRcIlxufTtcbmNvbnN0IHN0ZXBwZXJDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyQxID0gKGV2ZW50KSA9PiB7XG4gICAgLy8gd29ya2Fyb3VuZCBmb3IgY2FsY2l0ZS1sYWJlbCB3cmFwcGVkIFNlbGVjdE51bWJlciBmb2N1cyBidWdcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5jb25zdCBjYWxjaXRlTGFiZWxDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyA9IChldmVudCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLy8gd29ya2Fyb3VuZCBmb3IgY2FsY2l0ZS1sYWJlbCB3cmFwcGVkIFNlbGVjdE51bWJlciBmb2N1cyBidWdcbiAgICAoX2IgPSAoX2EgPSBldmVudC50YXJnZXQpLnNldEZvY3VzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn07XG5jb25zdCBTZWxlY3ROdW1iZXIgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGRpc2FibGVkLCBtaW4sIG1heCwgc3RlcCwgdmFsdWUsIHVuaXRzLCBjbGFzc05hbWVzLCBsYWJlbCB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IGAke1NlbGVjdENTUyQxLmJhc2V9ICR7Y2xhc3NOYW1lc31gIH0sXG4gICAgICAgIGgoXCJjYWxjaXRlLXNsaWRlclwiLCB7IGRpc2FibGVkOiBkaXNhYmxlZCwgbWluOiBtaW4sIG1heDogbWF4LCB2YWx1ZTogdmFsdWUsIHN0ZXA6IHN0ZXAsIHNuYXA6IHRydWUsIGxhYmVsVGlja3M6IHRydWUsIHRpY2tzOiBtYXggLSBtaW4sIG1pbkxhYmVsOiBsYWJlbCwgb25DYWxjaXRlU2xpZGVySW5wdXQ6IChldmVudCkgPT4gYXBwbHlWYWx1ZU9uQ2hhbmdlJDEoZXZlbnQsIHByb3BzKSB9KSxcbiAgICAgICAgaChcImNhbGNpdGUtaW5wdXRcIiwgeyB0eXBlOiBcIm51bWJlclwiLCBvbkNsaWNrOiBzdGVwcGVyQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMkMSwgZGlzYWJsZWQ6IGRpc2FibGVkLCBtaW46IG1pbiwgbWF4OiBtYXgsIHZhbHVlOiBgJHt2YWx1ZX1gLCBzY2FsZTogXCJzXCIsIHN0ZXA6IHN0ZXAsIHN1ZmZpeFRleHQ6IHVuaXRzLCBvbkNhbGNpdGVJbnB1dElucHV0OiAoZXZlbnQpID0+IGFwcGx5VmFsdWVPbkNoYW5nZSQxKGV2ZW50LCBwcm9wcyksIGNsYXNzOiBTZWxlY3RDU1MkMS5pbnB1dCwgbGFiZWw6IGxhYmVsIH0pKSk7XG59O1xuZnVuY3Rpb24gYXBwbHlWYWx1ZU9uQ2hhbmdlJDEoZXZlbnQsIHByb3BzKSB7XG4gICAgY29uc3QgeyBsb2NhbGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IG5vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGNvbnN0IHNsaWRlck5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2xpZGVyXCIpO1xuICAgIGNvbnN0IGlucHV0Tm9kZSA9IG5vZGUucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1pbnB1dFwiKTtcbiAgICBjb25zdCB2YWx1ZSA9IE51bWJlcihub2RlLnZhbHVlKTtcbiAgICBjb25zdCBjbGFtcGVkID0gTWF0aC5taW4ocHJvcHMubWF4LCBNYXRoLm1heChwcm9wcy5taW4sIHZhbHVlKSk7XG4gICAgaWYgKGNsYW1wZWQgPT09IHNsaWRlck5vZGUudmFsdWUgJiYgYCR7Y2xhbXBlZH1gID09PSBpbnB1dE5vZGUudmFsdWUpIHtcbiAgICAgICAgLy8gbm8gY2hhbmdlc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGVuc3VyZSB2YWx1ZSB3ZSBzaG93IGlzIHdpdGhpbiBhbGxvd2VkIHJhbmdlXG4gICAgc2xpZGVyTm9kZS52YWx1ZSA9IGNsYW1wZWQ7XG4gICAgaW5wdXROb2RlLnZhbHVlID0gYCR7Y2xhbXBlZH1gO1xuICAgIC8vIFRPRE8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2lzc3Vlcy8zMDAzXG4gICAgY29uc3QgY2xhbXBlZFN0cmluZyA9IGNsYW1wZWQudG9Mb2NhbGVTdHJpbmcobG9jYWxlKTtcbiAgICBpbnB1dE5vZGVcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKVxuICAgICAgICAuZm9yRWFjaCgoaW5wdXQpID0+IChpbnB1dC52YWx1ZSA9IGNsYW1wZWRTdHJpbmcpKTtcbiAgICBwcm9wcy5vblZhbHVlQ2hhbmdlKGNsYW1wZWQsIG5vZGUpO1xufVxuXG5jb25zdCBTZWxlY3RDU1MgPSB7XG4gICAgYmFzZTogXCJzZWxlY3QteHlcIixcbiAgICBpbnB1dDogXCJzZWxlY3QteHlfX2lucHV0XCJcbn07XG5jb25zdCBzdGVwcGVyQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMgPSAoZXZlbnQpID0+IHtcbiAgICAvLyB3b3JrYXJvdW5kIGZvciBjYWxjaXRlLWxhYmVsIHdyYXBwZWQgU2VsZWN0WHkgZm9jdXMgYnVnXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuY29uc3QgU2VsZWN0WHkgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IG1pbiwgbWF4LCBzdGVwLCB4LCB5LCBjbGFzc05hbWVzLCBzdHJpbmdzLCBsb2NhbGUgfSA9IHByb3BzO1xuICAgIGxldCBob3N0Tm9kZTtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogYCR7U2VsZWN0Q1NTLmJhc2V9ICR7Y2xhc3NOYW1lc31gLCByZWY6IChub2RlKSA9PiAoaG9zdE5vZGUgPSBub2RlKSB9LFxuICAgICAgICBoKFwiYXJjZ2lzLXh5LXNsaWRlclwiLCB7IFwiZGF0YS12YWx1ZVwiOiBcInNsaWRlclwiLCBtaW5YOiBtaW4sIG1heFg6IG1heCwgbWluWTogbWluLCBtYXhZOiBtYXgsIHg6IHgsIHk6IHksIHN0ZXA6IHN0ZXAsIHNuYXBwYWJsZTogdHJ1ZSwgb25BcmNnaXNYWVNsaWRlcklucHV0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbGlkZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtaXR0aW5nQWN0aXZlRmxhZ0F0dHJpYnV0ZSA9IFwiZGF0YS1hY3RpdmVcIjtcbiAgICAgICAgICAgICAgICAvLyB3ZSBpZ25vcmUgdGhlIGZpcnN0IGV2ZW50IHNpbmNlIGl0J3MgY2F1c2VkIGJ5IHRoZVxuICAgICAgICAgICAgICAgIC8vIHZhbHVlIHNuYXBwaW5nIHRvIGEgc3RlcCBpbnRlcnZhbCBkdXJpbmcgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIXNsaWRlci5oYXNBdHRyaWJ1dGUoZW1pdHRpbmdBY3RpdmVGbGFnQXR0cmlidXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXIuc2V0QXR0cmlidXRlKGVtaXR0aW5nQWN0aXZlRmxhZ0F0dHJpYnV0ZSwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwbHlWYWx1ZU9uQ2hhbmdlKGV2ZW50LCBwcm9wcywgaG9zdE5vZGUpO1xuICAgICAgICAgICAgfSB9KSxcbiAgICAgICAgaChcImRpdlwiLCBudWxsLFxuICAgICAgICAgICAgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSxcbiAgICAgICAgICAgICAgICBzdHJpbmdzLmVmZmVjdHNQcm9wcy54T2Zmc2V0LFxuICAgICAgICAgICAgICAgIGgoXCJjYWxjaXRlLWlucHV0XCIsIHsgXCJkYXRhLXZhbHVlXCI6IFwieFwiLCB0eXBlOiBcIm51bWJlclwiLCBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IHN0ZXAsIGxhbmc6IGxvY2FsZSwgdmFsdWU6IGAke3h9YCwgY2xhc3M6IFNlbGVjdENTUy5pbnB1dCwgc2NhbGU6IFwic1wiLCBvbkNsaWNrOiBzdGVwcGVyQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMsIG9uQ2FsY2l0ZUlucHV0SW5wdXQ6IChldmVudCkgPT4gYXBwbHlWYWx1ZU9uQ2hhbmdlKGV2ZW50LCBwcm9wcywgaG9zdE5vZGUpIH0pKSxcbiAgICAgICAgICAgIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwic1wiIH0sXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5lZmZlY3RzUHJvcHMueU9mZnNldCxcbiAgICAgICAgICAgICAgICBoKFwiY2FsY2l0ZS1pbnB1dFwiLCB7IFwiZGF0YS12YWx1ZVwiOiBcInlcIiwgdHlwZTogXCJudW1iZXJcIiwgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiBzdGVwLCBsYW5nOiBsb2NhbGUsIHZhbHVlOiBgJHt5fWAsIGNsYXNzOiBTZWxlY3RDU1MuaW5wdXQsIHNjYWxlOiBcInNcIiwgb25DbGljazogc3RlcHBlckNsaWNrSGFuZGxlckZvclByb3BlckZvY3VzLCBvbkNhbGNpdGVJbnB1dElucHV0OiAoZXZlbnQpID0+IGFwcGx5VmFsdWVPbkNoYW5nZShldmVudCwgcHJvcHMsIGhvc3ROb2RlKSB9KSkpKSk7XG59O1xuZnVuY3Rpb24gYXBwbHlWYWx1ZU9uQ2hhbmdlKGV2ZW50LCBwcm9wcywgaG9zdE5vZGUpIHtcbiAgICBjb25zdCB7IHN0ZXAsIGxvY2FsZSB9ID0gcHJvcHM7XG4gICAgY29uc3Qgbm9kZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgY29uc3QgZGF0YVZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpO1xuICAgIGNvbnN0IHNsaWRlck5vZGUgPSBob3N0Tm9kZS5xdWVyeVNlbGVjdG9yKFwiYXJjZ2lzLXh5LXNsaWRlclwiKTtcbiAgICBjb25zdCBpbnB1dE5vZGVzID0gaG9zdE5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtaW5wdXRcIik7XG4gICAgY29uc3Qgb3JpZ1ZhbHVlWCA9IE51bWJlcihkYXRhVmFsdWUgPT09IFwic2xpZGVyXCJcbiAgICAgICAgPyBub2RlLnhcbiAgICAgICAgOiBkYXRhVmFsdWUgPT09IFwieFwiXG4gICAgICAgICAgICA/IG5vZGUudmFsdWVcbiAgICAgICAgICAgIDogaW5wdXROb2Rlc1swXS52YWx1ZSk7XG4gICAgY29uc3Qgb3JpZ1ZhbHVlWSA9IE51bWJlcihkYXRhVmFsdWUgPT09IFwic2xpZGVyXCJcbiAgICAgICAgPyBub2RlLnlcbiAgICAgICAgOiBkYXRhVmFsdWUgPT09IFwieVwiXG4gICAgICAgICAgICA/IG5vZGUudmFsdWVcbiAgICAgICAgICAgIDogaW5wdXROb2Rlc1sxXS52YWx1ZSk7XG4gICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IGdldCBtb3JlIHByZWNpc2lvbiB0aGFuIHN0ZXBcbiAgICAvLyBzbGlkZXIgcmV0dXJucyB2YWx1ZXMgbGlrZSAxLjkwMDAwMDAwMDAwMDAwMDEgKCMyOTI4KVxuICAgIGNvbnN0IGRlY2ltYWxzQ291bnQgPSBjb3VudERlY2ltYWxEaWdpdHMoc3RlcCk7XG4gICAgY29uc3QgZmFjdG9yID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzQ291bnQpO1xuICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKG9yaWdWYWx1ZVggKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKG9yaWdWYWx1ZVkgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIGNvbnN0IHhDbGFtcGVkID0gTWF0aC5taW4ocHJvcHMubWF4LCBNYXRoLm1heChwcm9wcy5taW4sIHgpKTtcbiAgICBjb25zdCB5Q2xhbXBlZCA9IE1hdGgubWluKHByb3BzLm1heCwgTWF0aC5tYXgocHJvcHMubWluLCB5KSk7XG4gICAgaWYgKHhDbGFtcGVkID09PSBzbGlkZXJOb2RlLnggJiZcbiAgICAgICAgYCR7eENsYW1wZWR9YCA9PT0gaW5wdXROb2Rlc1swXS52YWx1ZSAmJlxuICAgICAgICB5Q2xhbXBlZCA9PT0gc2xpZGVyTm9kZS55ICYmXG4gICAgICAgIGAke3lDbGFtcGVkfWAgPT09IGlucHV0Tm9kZXNbMV0udmFsdWUpIHtcbiAgICAgICAgLy8gbm8gY2hhbmdlc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGVuc3VyZSB2YWx1ZSB3ZSBzaG93IGlzIHdpdGhpbiBhbGxvd2VkIHJhbmdlXG4gICAgc2xpZGVyTm9kZS54ID0geENsYW1wZWQ7XG4gICAgc2xpZGVyTm9kZS55ID0geUNsYW1wZWQ7XG4gICAgaW5wdXROb2Rlc1swXS52YWx1ZSA9IGAke3hDbGFtcGVkfWA7XG4gICAgaW5wdXROb2Rlc1sxXS52YWx1ZSA9IGAke3lDbGFtcGVkfWA7XG4gICAgLy8gVE9ETyB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvaXNzdWVzLzMwMDNcbiAgICBjb25zdCB4Q2xhbXBlZFN0cmluZyA9IHhDbGFtcGVkLnRvTG9jYWxlU3RyaW5nKGxvY2FsZSk7XG4gICAgY29uc3QgeUNsYW1wZWRTdHJpbmcgPSB5Q2xhbXBlZC50b0xvY2FsZVN0cmluZyhsb2NhbGUpO1xuICAgIGlucHV0Tm9kZXNbMF1cbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKVxuICAgICAgICAuZm9yRWFjaCgoaW5wdXQpID0+IChpbnB1dC52YWx1ZSA9IHhDbGFtcGVkU3RyaW5nKSk7XG4gICAgaW5wdXROb2Rlc1sxXVxuICAgICAgICAucXVlcnlTZWxlY3RvckFsbChcImlucHV0XCIpXG4gICAgICAgIC5mb3JFYWNoKChpbnB1dCkgPT4gKGlucHV0LnZhbHVlID0geUNsYW1wZWRTdHJpbmcpKTtcbiAgICBwcm9wcy5vblZhbHVlQ2hhbmdlKHhDbGFtcGVkLCB5Q2xhbXBlZCwgbm9kZSk7XG59XG5mdW5jdGlvbiBjb3VudERlY2ltYWxEaWdpdHMobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA9PT0gbnVsbCB8fCBudW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgY2hhcl9hcnJheSA9IG51bWJlci50b1N0cmluZygpLnNwbGl0KFwiXCIpOyAvLyBzcGxpdCBldmVyeSBzaW5nbGUgY2hhclxuICAgIGNvbnN0IG5vdF9kZWNpbWFsID0gY2hhcl9hcnJheS5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgcmV0dXJuIG5vdF9kZWNpbWFsIDwgMCA/IDAgOiBjaGFyX2FycmF5Lmxlbmd0aCAtIG5vdF9kZWNpbWFsO1xufVxuXG5jb25zdCBhcmNnaXNFZmZlY3RzUG9wb3ZlcnNDc3MgPSBcIi5zZWxlY3QtbnVtYmVyLnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47cG9zaXRpb246cmVsYXRpdmV9LnNlbGVjdC1udW1iZXIuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnMgY2FsY2l0ZS1zbGlkZXIuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7d2lkdGg6NTglO2hlaWdodDozMHB4O21hcmdpbjowIDRweDtvdmVyZmxvdy13cmFwOm5vcm1hbDt3b3JkLWJyZWFrOm5vcm1hbH0uc2VsZWN0LW51bWJlcl9faW5wdXQuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7d2lkdGg6MzUlO2ZvbnQtc2l6ZTp2YXIoLS1hcmNnaXMtYXBwLWZvbnQtc2l6ZS0wKTtmb250LWZhbWlseTp2YXIoLS1hcmNnaXMtYXBwLWZvbnQtZmFtaWx5KX0uc2VsZWN0LXh5LnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9LnNlbGVjdC14eS5zYy1hcmNnaXMtZWZmZWN0cy1wb3BvdmVycyBhcmNnaXMteHktc2xpZGVyLnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze3dpZHRoOjEyMHB4O21pbi13aWR0aDoxMjBweDttYXJnaW46MCAxMHB4fS5zZWxlY3QteHlfX2lucHV0LnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze3dpZHRoOjEwMCU7Zm9udC1zaXplOnZhcigtLWFyY2dpcy1hcHAtZm9udC1zaXplLTApO2ZvbnQtZmFtaWx5OnZhcigtLWFyY2dpcy1hcHAtZm9udC1mYW1pbHkpfS5wb3BvdmVyLnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze3otaW5kZXg6OTl9LnBhbmVsLnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze3dpZHRoOjMyNXB4fS5wYW5lbC5maWx0ZXIuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7bWluLWhlaWdodDo1MDBweDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItYmFja2dyb3VuZCl9LmVmZmVjdHMtY29udGVudC5zYy1hcmNnaXMtZWZmZWN0cy1wb3BvdmVyc3twYWRkaW5nOjFyZW07YmFja2dyb3VuZC1jb2xvcjp3aGl0ZTttYXgtaGVpZ2h0Ojgwdmh9LmJvdHRvbS1zcGFjZS5zYy1hcmNnaXMtZWZmZWN0cy1wb3BvdmVyc3ttYXJnaW4tYm90dG9tOjEuOHJlbX0uYm90dG9tLXNwYWNlLWxpdHRsZS5zYy1hcmNnaXMtZWZmZWN0cy1wb3BvdmVyc3ttYXJnaW4tYm90dG9tOjAuNXJlbX0uc3dpdGNoLnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze3dpZHRoOjEwMCU7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5yZXNldC5zYy1hcmNnaXMtZWZmZWN0cy1wb3BvdmVyc3tkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyfS5zdWItaGVhZGVyLnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze21hcmdpbi1sZWZ0OjAuNzVyZW07bWFyZ2luLXJpZ2h0OjB9LmFyY2dpcy0tcnRsLnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJzIC5zdWItaGVhZGVyLnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze21hcmdpbi1yaWdodDowLjc1cmVtO21hcmdpbi1sZWZ0OjB9XCI7XG5cbmNvbnN0IEFyY2dpc0VmZmVjdHNQb3BvdmVycyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzRWZmZWN0c0FwcGx5TGF5ZXJFZmZlY3QgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0VmZmVjdHNBcHBseUxheWVyRWZmZWN0XCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNQb3BvdmVyRmlsdGVyQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNFZmZlY3RzUG9wb3ZlckZpbHRlckNoYW5nZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNFZmZlY3RzUG9wb3ZlckNsb3NlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNFZmZlY3RzUG9wb3ZlckNsb3NlXCIsIDcpO1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vXG4gICAgICAgIC8vICBQcml2YXRlIFByb3BlcnRpZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmRlZmF1bHRFeHByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vXG4gICAgICAgIC8vICBQcml2YXRlIG1ldGhvZHNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5vbk9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuY2xvc2VOb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTsgfSksIDEpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmZpbHRlck5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZVBvcG92ZXJzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qcm9wQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNFZmZlY3RzQXBwbHlMYXllckVmZmVjdC5lbWl0KHsgdHlwZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblJlc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcG9wb3Zlck5vZGUgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBzY3JlZW5VdGlscyB9ID0gbW9kdWxlcztcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRzID0gbGF5ZXJFZmZlY3REZWZhdWx0c1t0eXBlXTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJibG9vbVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLWlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHNbMF0udmFsdWUgPSBgJHtkZWZhdWx0cy5zdHJlbmd0aH1gO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHNbMV0udmFsdWUgPSBgJHtzY3JlZW5VdGlscy5wdDJweChkZWZhdWx0cy5yYWRpdXMpfWA7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0c1syXS52YWx1ZSA9IGAke01hdGgucm91bmQoZGVmYXVsdHMudGhyZXNob2xkICogMTAwKX1gO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGlkZXJzID0gcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtc2xpZGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXJzWzBdLnZhbHVlID0gZGVmYXVsdHMuc3RyZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlcnNbMV0udmFsdWUgPSBzY3JlZW5VdGlscy5wdDJweChkZWZhdWx0cy5yYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXJzWzJdLnZhbHVlID0gTWF0aC5yb3VuZChkZWZhdWx0cy50aHJlc2hvbGQgKiAxMDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImRyb3BTaGFkb3dcIjoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ2VvbWV0cnlUeXBlID0gZ2V0U2ltcGxlR2VvbWV0cnlUeXBlKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3JQaWNrZXIgPSBwb3BvdmVyTm9kZS5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1jb2xvci1waWNrZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUGlja2VyLnZhbHVlID0gYCR7dGhpcy5yZ2IySGV4KGRlZmF1bHRzW2dlb21ldHJ5VHlwZV0uY29sb3IpfWA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLWlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHNbMF0udmFsdWUgPSBgJHtNYXRoLnJvdW5kKHNjcmVlblV0aWxzLnB0MnB4KGRlZmF1bHRzW2dlb21ldHJ5VHlwZV0uYmx1clJhZGl1cykpfWA7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0c1sxXS52YWx1ZSA9IGAke01hdGgucm91bmQoc2NyZWVuVXRpbHMucHQycHgoZGVmYXVsdHNbZ2VvbWV0cnlUeXBlXS54b2Zmc2V0KSl9YDtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzWzJdLnZhbHVlID0gYCR7TWF0aC5yb3VuZChzY3JlZW5VdGlscy5wdDJweChkZWZhdWx0c1tnZW9tZXRyeVR5cGVdLnlvZmZzZXQpKX1gO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHNbM10udmFsdWUgPSBgJHsoZGVmYXVsdHNbZ2VvbWV0cnlUeXBlXS5jb2xvclszXSAvIDI1NSkgKiAxMDB9YDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xpZGVycyA9IHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXNsaWRlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVyc1swXS52YWx1ZSA9IE1hdGgucm91bmQoc2NyZWVuVXRpbHMucHQycHgoZGVmYXVsdHNbZ2VvbWV0cnlUeXBlXS5ibHVyUmFkaXVzKSk7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlcnNbMV0udmFsdWUgPSAoZGVmYXVsdHNbZ2VvbWV0cnlUeXBlXS5jb2xvclszXSAvIDI1NSkgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHh5U2xpZGVycyA9IHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhcmNnaXMteHktc2xpZGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB4eVNsaWRlcnNbMF0ueCA9IE1hdGgucm91bmQoc2NyZWVuVXRpbHMucHQycHgoZGVmYXVsdHNbZ2VvbWV0cnlUeXBlXS54b2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgIHh5U2xpZGVyc1swXS55ID0gTWF0aC5yb3VuZChzY3JlZW5VdGlscy5wdDJweChkZWZhdWx0c1tnZW9tZXRyeVR5cGVdLnlvZmZzZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJibHVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIikudmFsdWUgPSBgJHtzY3JlZW5VdGlscy5wdDJweChkZWZhdWx0cy5yYWRpdXMpfWA7XG4gICAgICAgICAgICAgICAgICAgIHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLXNsaWRlclwiKS52YWx1ZSA9IHNjcmVlblV0aWxzLnB0MnB4KGRlZmF1bHRzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiYnJpZ2h0bmVzc0NvbnRyYXN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdHNCcmlnaHRuZXNzID0gbGF5ZXJFZmZlY3REZWZhdWx0c1tcImJyaWdodG5lc3NcIl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRzQ29udHJhc3QgPSBsYXllckVmZmVjdERlZmF1bHRzW1wiY29udHJhc3RcIl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLWlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHNbMF0udmFsdWUgPSBgJHtNYXRoLnJvdW5kKGRlZmF1bHRzQnJpZ2h0bmVzcy5hbW91bnQgKiAxMDApfWA7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0c1sxXS52YWx1ZSA9IGAke01hdGgucm91bmQoZGVmYXVsdHNDb250cmFzdC5hbW91bnQgKiAxMDApfWA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsaWRlcnMgPSBwb3BvdmVyTm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS1zbGlkZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlcnNbMF0udmFsdWUgPSBNYXRoLnJvdW5kKGRlZmF1bHRzQnJpZ2h0bmVzcy5hbW91bnQgKiAxMDApO1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXJzWzFdLnZhbHVlID0gTWF0aC5yb3VuZChkZWZhdWx0c0NvbnRyYXN0LmFtb3VudCAqIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZ3JheXNjYWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIikudmFsdWUgPSBgJHtkZWZhdWx0cy5hbW91bnQgKiAxMDB9YDtcbiAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2xpZGVyXCIpLnZhbHVlID0gZGVmYXVsdHMuYW1vdW50ICogMTAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImh1ZVJvdGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpLnZhbHVlID0gYCR7ZGVmYXVsdHMuYW5nbGV9YDtcbiAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2xpZGVyXCIpLnZhbHVlID0gZGVmYXVsdHMuYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwic2F0dXJhdGVcIjoge1xuICAgICAgICAgICAgICAgICAgICBwb3BvdmVyTm9kZS5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1pbnB1dFwiKS52YWx1ZSA9IGAke2RlZmF1bHRzLmFtb3VudCAqIDEwMH1gO1xuICAgICAgICAgICAgICAgICAgICBwb3BvdmVyTm9kZS5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1zbGlkZXJcIikudmFsdWUgPSBkZWZhdWx0cy5hbW91bnQgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiaW52ZXJ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIikudmFsdWUgPSBgJHtkZWZhdWx0cy5hbW91bnQgKiAxMDB9YDtcbiAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2xpZGVyXCIpLnZhbHVlID0gZGVmYXVsdHMuYW1vdW50ICogMTAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlcGlhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIikudmFsdWUgPSBgJHtkZWZhdWx0cy5hbW91bnQgKiAxMDB9YDtcbiAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2xpZGVyXCIpLnZhbHVlID0gZGVmYXVsdHMuYW1vdW50ICogMTAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNBcHBseUxheWVyRWZmZWN0LmVtaXQoeyB0eXBlIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucG9wb3ZlcnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBwdWJsaWMgY2FsbHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyByZXBvc2l0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMucG9wb3Zlck5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBvc2l0aW9uKCk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUhlYWRlcih0eXBlKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGZpbHRlck5vZGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGlmIChmaWx0ZXJOb2RlKSB7XG4gICAgICAgICAgICAvLyBjbG9zZSBmaWVsZC1waWNrLWxpc3RcbiAgICAgICAgICAgIGZpbHRlck5vZGUuY2xvc2VQb3BvdmVycygpO1xuICAgICAgICAgICAgZmlsdGVyTm9kZS5wYW5lbEhlYWRpbmcgPSBzdHJpbmdzLmZlYXR1cmVFZmZlY3RzVGl0bGVbdHlwZV0gfHwgc3RyaW5ncy5lZmZlY3RzVGl0bGVbdHlwZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGxheWVyIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFsYXllci5mZWF0dXJlRWZmZWN0KSB7XG4gICAgICAgICAgICAvLyBkb24ndCBzdGFydCB3aXRoIGVtcHR5IGZpbHRlciwgaWYgcG9zc2libGVcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEV4cHJlc3Npb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHJlZmVyZW5jZUVsZW1lbnQsIHR5cGUsIG9wZW4gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIGNvbnN0IGlzTG9uZ1BvcG92ZXIgPSBbXCJmZWF0dXJlRWZmZWN0XCIsIFwiZHJvcFNoYWRvd1wiXS5pbmRleE9mKHR5cGUpID4gLTE7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiBcImpzLWFwcC1mbHlvdXRcIiB9LCBoKFwiY2FsY2l0ZS1wb3BvdmVyXCIsIHsgZGlyOiBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpLCBwb2ludGVyRGlzYWJsZWQ6IHRydWUsIGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNUaXRsZVt0eXBlXSwgb2Zmc2V0RGlzdGFuY2U6IDEwLCBvZmZzZXRTa2lkZGluZzogaXNMb25nUG9wb3ZlciA/IDEwIDogMTAwLCBvcGVuOiBvcGVuLCBwbGFjZW1lbnQ6IFwibGVhZGluZy1zdGFydFwiLCB0cmlnZ2VyRGlzYWJsZWQ6IHRydWUsIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgXCJhcmNnaXMtZWZmZWN0cy1wb3BvdmVyXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgcG9wb3ZlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICAgICAgICB9LCByZWZlcmVuY2VFbGVtZW50OiByZWZlcmVuY2VFbGVtZW50LCBvbkNhbGNpdGVQb3BvdmVyT3BlbjogdGhpcy5vbk9wZW4sIG9uQ2FsY2l0ZVBvcG92ZXJDbG9zZTogdGhpcy5vbkNsb3NlLCByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgLy9cIiwgcG9wb3ZlcnNbdHlwZV0sIG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vcG9wb3ZlcnNbdHlwZV0gPSBub2RlO1xuICAgICAgICAgICAgfSB9LCB0eXBlID09PSBcImZlYXR1cmVFZmZlY3RcIlxuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckZlYXR1cmVFZmZlY3RQcm9wcygpXG4gICAgICAgICAgICA6IHRoaXMucmVuZGVyTGF5ZXJFZmZlY3RQcm9wcygpKSkpO1xuICAgIH1cbiAgICByZW5kZXJMYXllckVmZmVjdFByb3BzKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCByZWZlcmVuY2VFbGVtZW50LCB0eXBlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBydGwgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgICAgICBjb25zdCBwYW5lbFJlY3QgPSByZWZlcmVuY2VFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLXBhbmVsXCIsIHsgY2xvc2FibGU6IGZhbHNlLCBoZWFkaW5nOiBzdHJpbmdzLmVmZmVjdHNUaXRsZVt0eXBlXSwgY2xhc3M6IENTUy5wYW5lbCwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IGAke3BhbmVsUmVjdC5oZWlnaHQgKiAwLjl9cHhgXG4gICAgICAgICAgICB9LCByZWY6IChub2RlKSA9PiAodGhpcy5wYW5lbE5vZGUgPSBub2RlKSB9LCBbXG4gICAgICAgICAgICBcImJsb29tXCIsXG4gICAgICAgICAgICBcImRyb3BTaGFkb3dcIixcbiAgICAgICAgICAgIFwiYmx1clwiLFxuICAgICAgICAgICAgXCJicmlnaHRuZXNzQ29udHJhc3RcIixcbiAgICAgICAgICAgIFwiZ3JheXNjYWxlXCIsXG4gICAgICAgICAgICBcImh1ZVJvdGF0ZVwiLFxuICAgICAgICAgICAgXCJzYXR1cmF0ZVwiLFxuICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgIFwic2VwaWFcIlxuICAgICAgICBdLmluZGV4T2YodHlwZSkgPiAtMSA/IChoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyB0ZXh0OiBzdHJpbmdzLmVmZmVjdHNQcm9wcy5yZXNldCwgc2NhbGU6IFwic1wiLCBzbG90OiBcImhlYWRlci1hY3Rpb25zLWVuZFwiLCB0aXRsZTogc3RyaW5ncy5lZmZlY3RzUHJvcHMucmVzZXQsIG9uQ2xpY2s6IHRoaXMub25SZXNldCB9LCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgc2NhbGU6IFwic1wiLCBpY29uOiBydGwgPyBcInJlZG9cIiA6IFwidW5kb1wiIH0pKSkgOiBudWxsLCBoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyB0ZXh0OiBzdHJpbmdzLmdlbmVyYWwuY2xvc2UsIGljb246IFwieFwiLCBzbG90OiBcImhlYWRlci1hY3Rpb25zLWVuZFwiLCB0aXRsZTogc3RyaW5ncy5nZW5lcmFsLmNsb3NlLCByZWY6IChub2RlKSA9PiAodGhpcy5jbG9zZU5vZGUgPSBub2RlKSwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzRWZmZWN0c1BvcG92ZXJDbG9zZS5lbWl0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyTm9kZS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5wYW5lbE5vZGUuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9IH0pLCB0eXBlID09PSBcImJsb29tXCIgPyB0aGlzLnJlbmRlckJsb29tKCkgOiBudWxsLCB0eXBlID09PSBcImRyb3BTaGFkb3dcIiA/IHRoaXMucmVuZGVyRHJvcFNoYWRvdygpIDogbnVsbCwgdHlwZSA9PT0gXCJibHVyXCIgPyB0aGlzLnJlbmRlckJsdXIoKSA6IG51bGwsIHR5cGUgPT09IFwiYnJpZ2h0bmVzc0NvbnRyYXN0XCIgPyB0aGlzLnJlbmRlckJyaWdodG5lc3NDb250cmFzdCgpIDogbnVsbCwgdHlwZSA9PT0gXCJncmF5c2NhbGVcIiA/IHRoaXMucmVuZGVyR3JheXNjYWxlKCkgOiBudWxsLCB0eXBlID09PSBcImh1ZVJvdGF0ZVwiID8gdGhpcy5yZW5kZXJIdWVSb3RhdGUoKSA6IG51bGwsIHR5cGUgPT09IFwic2F0dXJhdGVcIiA/IHRoaXMucmVuZGVyU2F0dXJhdGUoKSA6IG51bGwsIHR5cGUgPT09IFwiaW52ZXJ0XCIgPyB0aGlzLnJlbmRlckludmVydCgpIDogbnVsbCwgdHlwZSA9PT0gXCJzZXBpYVwiID8gdGhpcy5yZW5kZXJTZXBpYSgpIDogbnVsbCkpO1xuICAgIH1cbiAgICByZW5kZXJCbG9vbSgpIHtcbiAgICAgICAgLy8gXCJCbG9vbVwiOiBgYmxvb20oMiwxcHgsMC4xKWAsXG4gICAgICAgIC8vIFN0cmVuZ3RoICgwLTUpIC0gc3RlcCAwLjFcbiAgICAgICAgLy8gUmFkaXVzICgwLTUpIC0gc3RlcCAwLjFcbiAgICAgICAgLy8gVGhyZXNob2xkICgwLTEpIC0gc3RlcCAwLjFcbiAgICAgICAgY29uc3QgeyBwcm9wcywgdHlwZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgc3RyaW5ncywgbG9jYWxlLCBtb2R1bGVzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgeyBzY3JlZW5VdGlscyB9ID0gbW9kdWxlcztcbiAgICAgICAgY29uc3QgYW55TGF5ZXIgPSBsYXllcjtcbiAgICAgICAgY29uc3QgZWZmZWN0UHJvcHMgPSBnZXRFZmZlY3RQcm9wcyh0eXBlLCBwcm9wcyk7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGVudCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiwgb25DbGljazogY2FsY2l0ZUxhYmVsQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgpLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogNSwgc3RlcDogMC4xLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IE1hdGgucm91bmQoZWZmZWN0UHJvcHMuc3RyZW5ndGggKiAxMCkgLyAxMCwgY2xhc3NOYW1lczogQ1NTLmJvdHRvbVNwYWNlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiwgb25DbGljazogY2FsY2l0ZUxhYmVsQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMucmFkaXVzKSwgaChTZWxlY3ROdW1iZXIsIHsgbWluOiAwLCBtYXg6IDUsIHN0ZXA6IDAuMSwgbG9jYWxlOiBsb2NhbGUsIHZhbHVlOiBNYXRoLnJvdW5kKHNjcmVlblV0aWxzLnB0MnB4KGVmZmVjdFByb3BzLnJhZGl1cykgKiAxMCkgLyAxMCwgY2xhc3NOYW1lczogQ1NTLmJvdHRvbVNwYWNlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzUHJvcHMucmFkaXVzLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uUHJvcENoYW5nZSB9KSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IGNhbGNpdGVMYWJlbENsaWNrSGFuZGxlckZvclByb3BlckZvY3VzIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLnRocmVzaG9sZCksIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogMCwgbWF4OiAxMDAsIHN0ZXA6IDEsIGxvY2FsZTogbG9jYWxlLCB2YWx1ZTogTWF0aC5yb3VuZChlZmZlY3RQcm9wcy50aHJlc2hvbGQgKiAxMDApLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2UsIGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNQcm9wcy50aHJlc2hvbGQsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGxheW91dDogXCJpbmxpbmUtc3BhY2UtYmV0d2VlblwiLCBzY2FsZTogXCJzXCIsIGNsYXNzOiBDU1Muc3dpdGNoIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLmF1dG9BZGp1c3QsIGgoXCJjYWxjaXRlLXN3aXRjaFwiLCB7IGNoZWNrZWQ6ICEhKCFhbnlMYXllci5lZmZlY3QgfHwgdHlwZW9mIGFueUxheWVyLmVmZmVjdCAhPT0gXCJzdHJpbmdcIiksIHNjYWxlOiBcInNcIiwgY2xhc3M6IENTUy5hdXRvLCBvbkNhbGNpdGVTd2l0Y2hDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSkpO1xuICAgIH1cbiAgICByZW5kZXJEcm9wU2hhZG93KCkge1xuICAgICAgICAvLyBcIkRyb3Agc2hhZG93XCI6IGBkcm9wLXNoYWRvdygxcHgsMXB4LDJweCwjMDAwMDAwKWAsXG4gICAgICAgIC8vIFggb2Zmc2V0ICgtMjAtMjApIC0gc3RlcCAxXG4gICAgICAgIC8vIFkgb2Zmc2V0ICgtMjAtMjApIC0gc3RlcCAxXG4gICAgICAgIC8vIEJsdXIgcmFkaXVzICgwLTIwKSAtIHN0ZXAgMVxuICAgICAgICBjb25zdCB7IHByb3BzLCB0eXBlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGxheWVyLCBzdHJpbmdzLCBsb2NhbGUsIG1vZHVsZXMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB7IHNjcmVlblV0aWxzIH0gPSBtb2R1bGVzO1xuICAgICAgICBjb25zdCBhbnlMYXllciA9IGxheWVyO1xuICAgICAgICBjb25zdCBlZmZlY3RQcm9wcyA9IGdldEVmZmVjdFByb3BzKHR5cGUsIHByb3BzKTtcbiAgICAgICAgY29uc3QgaGV4VmFsdWUgPSB0aGlzLnJnYjJIZXgoZWZmZWN0UHJvcHMuY29sb3IpO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnQgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMuY29sb3IsIGgoXCJjYWxjaXRlLWNvbG9yLXBpY2tlclwiLCB7IHNjYWxlOiBcIm1cIiwgdmFsdWU6IGhleFZhbHVlLCBoaWRlU2F2ZWQ6IHRydWUsIG9uQ2FsY2l0ZUNvbG9yUGlja2VySW5wdXQ6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMud2lkdGgpLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogMjAsIHN0ZXA6IDEsIGxvY2FsZTogbG9jYWxlLCB2YWx1ZTogTWF0aC5yb3VuZChzY3JlZW5VdGlscy5wdDJweChlZmZlY3RQcm9wcy5ibHVyUmFkaXVzKSksIGNsYXNzTmFtZXM6IENTUy5ib3R0b21TcGFjZSwgbGFiZWw6IHN0cmluZ3MuZWZmZWN0c1Byb3BzLndpZHRoLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uUHJvcENoYW5nZSB9KSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMub2Zmc2V0LCBoKFNlbGVjdFh5LCB7IG1pbjogLTIwLCBtYXg6IDIwLCBzdGVwOiAxLCBsb2NhbGU6IGxvY2FsZSwgeDogTWF0aC5yb3VuZChzY3JlZW5VdGlscy5wdDJweChlZmZlY3RQcm9wcy54b2Zmc2V0KSksIHk6IE1hdGgucm91bmQoc2NyZWVuVXRpbHMucHQycHgoZWZmZWN0UHJvcHMueW9mZnNldCkpLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2VMaXR0bGUsIHN0cmluZ3M6IHN0cmluZ3MsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IGNhbGNpdGVMYWJlbENsaWNrSGFuZGxlckZvclByb3BlckZvY3VzIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLm9wYWNpdHkpLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogMTAwLCBzdGVwOiAxLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IChlZmZlY3RQcm9wcy5jb2xvclszXSAvIDI1NSkgKiAxMDAsIGNsYXNzTmFtZXM6IENTUy5ib3R0b21TcGFjZSwgbGFiZWw6IHN0cmluZ3MuZWZmZWN0c1Byb3BzLm9wYWNpdHksIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGxheW91dDogXCJpbmxpbmUtc3BhY2UtYmV0d2VlblwiLCBzY2FsZTogXCJzXCIsIGNsYXNzOiBDU1Muc3dpdGNoIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLmF1dG9BZGp1c3QsIGgoXCJjYWxjaXRlLXN3aXRjaFwiLCB7IGNoZWNrZWQ6ICEhKCFhbnlMYXllci5lZmZlY3QgfHwgdHlwZW9mIGFueUxheWVyLmVmZmVjdCAhPT0gXCJzdHJpbmdcIiksIHNjYWxlOiBcInNcIiwgY2xhc3M6IENTUy5hdXRvLCBvbkNhbGNpdGVTd2l0Y2hDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSkpO1xuICAgIH1cbiAgICByZW5kZXJCbHVyKCkge1xuICAgICAgICAvLyBcIkJsdXJcIjogYGJsdXIoMnB4KWAsXG4gICAgICAgIC8vIEJsdXIgKDAtMzApIC0gc3RlcCAwLjFcbiAgICAgICAgY29uc3QgeyBwcm9wcywgdHlwZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzLCBsb2NhbGUsIG1vZHVsZXMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB7IHNjcmVlblV0aWxzIH0gPSBtb2R1bGVzO1xuICAgICAgICBjb25zdCBlZmZlY3RQcm9wcyA9IGdldEVmZmVjdFByb3BzKHR5cGUsIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb250ZW50IH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwic1wiLCBvbkNsaWNrOiBjYWxjaXRlTGFiZWxDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyB9LCBzdHJpbmdzLmVmZmVjdHNQcm9wcy5zdHJlbmd0aCksIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogMCwgbWF4OiAzMCwgc3RlcDogMC4xLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IE1hdGgucm91bmQoc2NyZWVuVXRpbHMucHQycHgoZWZmZWN0UHJvcHMucmFkaXVzKSAqIDEwKSAvIDEwLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2UsIGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNQcm9wcy5zdHJlbmd0aCwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblByb3BDaGFuZ2UgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyQnJpZ2h0bmVzc0NvbnRyYXN0KCkge1xuICAgICAgICAvLyBicmlnaHRuZXNzKDEwMCUpIGNvbnRyYXN0KDEwMCUpXG4gICAgICAgIC8vIEJyaWdodG5lc3MgKDAtMzAwKSAtIHN0ZXAgMSArIENvbnRyYXN0ICgwLTMwMCkgLSBzdGVwIDFcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzLCBsb2NhbGUgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBlZmZlY3RQcm9wc0JyaWdodG5lc3MgPSBnZXRFZmZlY3RQcm9wcyhcImJyaWdodG5lc3NcIiwgcHJvcHMpO1xuICAgICAgICBjb25zdCBlZmZlY3RQcm9wc0NvbnRyYXN0ID0gZ2V0RWZmZWN0UHJvcHMoXCJjb250cmFzdFwiLCBwcm9wcyk7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGVudCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiwgb25DbGljazogY2FsY2l0ZUxhYmVsQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMuYnJpZ2h0bmVzcyksIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogMCwgbWF4OiAzMDAsIHN0ZXA6IDEsIGxvY2FsZTogbG9jYWxlLCB2YWx1ZTogTWF0aC5yb3VuZChlZmZlY3RQcm9wc0JyaWdodG5lc3MuYW1vdW50ICogMTAwKSwgY2xhc3NOYW1lczogQ1NTLmJvdHRvbVNwYWNlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzUHJvcHMuYnJpZ2h0bmVzcywgb25WYWx1ZUNoYW5nZTogdGhpcy5vblByb3BDaGFuZ2UgfSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwic1wiLCBvbkNsaWNrOiBjYWxjaXRlTGFiZWxDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyB9LCBzdHJpbmdzLmVmZmVjdHNQcm9wcy5jb250cmFzdCksIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogMCwgbWF4OiAzMDAsIHN0ZXA6IDEsIGxvY2FsZTogbG9jYWxlLCB2YWx1ZTogTWF0aC5yb3VuZChlZmZlY3RQcm9wc0NvbnRyYXN0LmFtb3VudCAqIDEwMCksIGNsYXNzTmFtZXM6IENTUy5ib3R0b21TcGFjZSwgbGFiZWw6IHN0cmluZ3MuZWZmZWN0c1Byb3BzLmNvbnRyYXN0LCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uUHJvcENoYW5nZSB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJHcmF5c2NhbGUoKSB7XG4gICAgICAgIC8vIGdyYXlzY2FsZSgyNSUpXG4gICAgICAgIC8vIEdyYXlzY2FsZSAoMC0xMDApIC0gc3RlcCAxXG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHR5cGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncywgbG9jYWxlIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgZWZmZWN0UHJvcHMgPSBnZXRFZmZlY3RQcm9wcyh0eXBlLCBwcm9wcyk7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGVudCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiwgb25DbGljazogY2FsY2l0ZUxhYmVsQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgpLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogMTAwLCBzdGVwOiAxLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IGVmZmVjdFByb3BzLmFtb3VudCAqIDEwMCwgY2xhc3NOYW1lczogQ1NTLmJvdHRvbVNwYWNlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckh1ZVJvdGF0ZSgpIHtcbiAgICAgICAgLy8gaHVlLXJvdGF0ZSgyNzBkZWcpLFxuICAgICAgICAvLyBIdWUgcm90YXRlICgwLTM2MCkgLSBzdGVwIDFcbiAgICAgICAgY29uc3QgeyBwcm9wcywgdHlwZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzLCBsb2NhbGUgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBlZmZlY3RQcm9wcyA9IGdldEVmZmVjdFByb3BzKHR5cGUsIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb250ZW50IH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwic1wiLCBvbkNsaWNrOiBjYWxjaXRlTGFiZWxDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyB9LCBzdHJpbmdzLmVmZmVjdHNQcm9wcy5kZWdyZWVzKSwgaChTZWxlY3ROdW1iZXIsIHsgbWluOiAwLCBtYXg6IDM2MCwgc3RlcDogMSwgbG9jYWxlOiBsb2NhbGUsIHZhbHVlOiBlZmZlY3RQcm9wcy5hbmdsZSwgY2xhc3NOYW1lczogQ1NTLmJvdHRvbVNwYWNlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzUHJvcHMuZGVncmVlcywgb25WYWx1ZUNoYW5nZTogdGhpcy5vblByb3BDaGFuZ2UgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyU2F0dXJhdGUoKSB7XG4gICAgICAgIC8vIHNhdHVyYXRlKDEwMCUpXG4gICAgICAgIC8vIFNhdHVyYXRlICgwLTIwMCkgLSBzdGVwIDFcbiAgICAgICAgY29uc3QgeyBwcm9wcywgdHlwZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzLCBsb2NhbGUgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBlZmZlY3RQcm9wcyA9IGdldEVmZmVjdFByb3BzKHR5cGUsIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb250ZW50IH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwic1wiLCBvbkNsaWNrOiBjYWxjaXRlTGFiZWxDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyB9LCBzdHJpbmdzLmVmZmVjdHNQcm9wcy5zdHJlbmd0aCksIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogMCwgbWF4OiAyMDAsIHN0ZXA6IDEsIGxvY2FsZTogbG9jYWxlLCB2YWx1ZTogZWZmZWN0UHJvcHMuYW1vdW50ICogMTAwLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2UsIGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNQcm9wcy5zdHJlbmd0aCwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblByb3BDaGFuZ2UgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVySW52ZXJ0KCkge1xuICAgICAgICAvLyBpbnZlcnQoMTAwJSlcbiAgICAgICAgLy8gSW52ZXJ0ICgwLTEwMCkgb3IgKDAtMSkgLSBzdGVwIDEgb3IgMC4wMVxuICAgICAgICBjb25zdCB7IHByb3BzLCB0eXBlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MsIGxvY2FsZSB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGVmZmVjdFByb3BzID0gZ2V0RWZmZWN0UHJvcHModHlwZSwgcHJvcHMpO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnQgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IGNhbGNpdGVMYWJlbENsaWNrSGFuZGxlckZvclByb3BlckZvY3VzIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLnN0cmVuZ3RoKSwgaChTZWxlY3ROdW1iZXIsIHsgbWluOiAwLCBtYXg6IDEwMCwgc3RlcDogMSwgbG9jYWxlOiBsb2NhbGUsIHZhbHVlOiBlZmZlY3RQcm9wcy5hbW91bnQgKiAxMDAsIGNsYXNzTmFtZXM6IENTUy5ib3R0b21TcGFjZSwgbGFiZWw6IHN0cmluZ3MuZWZmZWN0c1Byb3BzLnN0cmVuZ3RoLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uUHJvcENoYW5nZSB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJTZXBpYSgpIHtcbiAgICAgICAgLy8gc2VwaWEoNTAlKVxuICAgICAgICAvLyBTZXBpYSAoMC0xMDApIC0gc3RlcCAxXG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHR5cGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncywgbG9jYWxlIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgZWZmZWN0UHJvcHMgPSBnZXRFZmZlY3RQcm9wcyh0eXBlLCBwcm9wcyk7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGVudCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiwgb25DbGljazogY2FsY2l0ZUxhYmVsQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgpLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogMTAwLCBzdGVwOiAxLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IGVmZmVjdFByb3BzLmFtb3VudCAqIDEwMCwgY2xhc3NOYW1lczogQ1NTLmJvdHRvbVNwYWNlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckZlYXR1cmVFZmZlY3RQcm9wcygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgdHlwZSwgZGVmYXVsdEV4cHJlc3Npb24gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlldywgbGF5ZXIsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBkZWZhdWx0RmllbGQgPSBnZXREZWZhdWx0RmllbGQocHJvcHMpO1xuICAgICAgICByZXR1cm4gKGgoXCJhcmNnaXMtZmlsdGVyXCIsIHsgY2xhc3M6IGAke0NTUy5wYW5lbH0gZmlsdGVyYCwgdmlldzogdmlldywgbGF5ZXI6IGxheWVyLCBoaWRlTGF5ZXJUaXRsZTogdHJ1ZSwgcGFuZWxIZWFkaW5nOiBzdHJpbmdzLmZlYXR1cmVFZmZlY3RzVGl0bGVbdHlwZV0sIHRpcEhlYWRpbmc6IHN0cmluZ3MuZmlsdGVyLnRpcEhlYWRpbmcsIHRpcE1zZzogc3RyaW5ncy5maWx0ZXIudGlwTXNnLCBpbnZhbGlkSGVhZGluZzogc3RyaW5ncy5maWx0ZXIuaW52YWxpZEhlYWRpbmcsIGludmFsaWRNc2c6IHN0cmluZ3MuZmlsdGVyLmludmFsaWRNc2csIG1vZGU6IFwiZWZmZWN0c1wiLCBkZWZhdWx0RmllbGROYW1lOiBkZWZhdWx0RmllbGQsIGRlZmF1bHRPcGVyYXRvcjogXCI+XCIsIGRlZmF1bHRFeHByZXNzaW9uOiAhIWRlZmF1bHRGaWVsZCAmJiBkZWZhdWx0RXhwcmVzc2lvbiwgaGlkZUJ1dHRvbnM6IHRydWUsIGRpc21pc3NpYmxlOiB0cnVlLCBwYW5lbE1heEhlaWdodDogXCI4MHZoXCIsIG9uQXJjZ2lzRmlsdGVyRGlzbWlzc2VkQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNFZmZlY3RzUG9wb3ZlckNsb3NlLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcG92ZXJOb2RlLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIG9uQXJjZ2lzRmlsdGVyV2hlcmVDaGFuZ2U6ICh7IGRldGFpbDogd2hlcmUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzRWZmZWN0c1BvcG92ZXJGaWx0ZXJDaGFuZ2UuZW1pdCh3aGVyZSk7XG4gICAgICAgICAgICB9LCByZWY6IChub2RlKSA9PiAodGhpcy5maWx0ZXJOb2RlID0gbm9kZSkgfSkpO1xuICAgIH1cbiAgICByZ2IySGV4KGNvbG9yKSB7XG4gICAgICAgIHJldHVybiAoXCIjXCIgK1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRUb0hleChNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGNvbG9yWzBdKSkpICtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VG9IZXgoTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBjb2xvclsxXSkpKSArXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFRvSGV4KE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgY29sb3JbMl0pKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnRUb0hleChjKSB7XG4gICAgICAgIGNvbnN0IGhleCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gXCIwXCIgKyBoZXggOiBoZXg7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNFZmZlY3RzUG9wb3ZlcnMuc3R5bGUgPSBhcmNnaXNFZmZlY3RzUG9wb3ZlcnNDc3M7XG5cbmV4cG9ydCB7IEFyY2dpc0VmZmVjdHMgYXMgYXJjZ2lzX2VmZmVjdHMsIEFyY2dpc0VmZmVjdHNQb3BvdmVycyBhcyBhcmNnaXNfZWZmZWN0c19wb3BvdmVycyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtZWZmZWN0c18yLmVudHJ5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xudmFyIGxvY2FsU3RvcmFnZUtleXM7XG4oZnVuY3Rpb24gKGxvY2FsU3RvcmFnZUtleXMpIHtcbiAgICBsb2NhbFN0b3JhZ2VLZXlzW1wiQVJDR0lTX0NPTVBPTkVOVF9OT1RJRklDQVRJT05TXCJdID0gXCJhcmNnaXNDb21wb25lbnRfbm90aWZpY2F0aW9uc1wiO1xufSkobG9jYWxTdG9yYWdlS2V5cyB8fCAobG9jYWxTdG9yYWdlS2V5cyA9IHt9KSk7XG52YXIgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXM7XG4oZnVuY3Rpb24gKGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzKSB7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJGRUFUVVJFX1JFRFVDVElPTl9XQVJOSU5HX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX2ZlYXR1cmVfcmVkdWN0aW9uX3dhcm5pbmdfZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJQT1BVUF9XQVJOSU5HX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX3BvcHVwX3dhcm5pbmdfZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJJTkNPTVBBVElCTEVfVkVDVE9SX1NZTUJPTFNfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfc3ltYm9sX3N0eWxlcl9pbmNvbXBhdGlibGVfdmVjdG9yX3N5bWJvbHNfZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJFRkZFQ1RTX1RJUF9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19lZmZlY3RzX3RpcF9kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkxBWUVSX1ZJRVdfREVGSU5JVElPTl9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19sYXllcl92aWV3X2RlZmluaXRpb25fZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJMQVlFUl9PVkVSUklERV9TVEFUVVNfVElQX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX2xheWVyX292ZXJyaWRlX3N0YXR1c190aXBfZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJTTUFSVF9NQVBQSU5HX1RJUDFfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfc21hcnRfbWFwcGluZ190aXAxX2Rpc21pc3NlZFwiO1xuICAgIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzW1wiU01BUlRfTUFQUElOR19USVAyX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX3NtYXJ0X21hcHBpbmdfdGlwMl9kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkxBWUVSX1ZJRVdfSk9JTl9USVBfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfbGF5ZXJfdmlld19qb2luX3RpcF9kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIk1VTFRJRElNRU5TSU9OQUxfSU5GT19USVBfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfbXVsdGlkaW1lbnNpb25hbF9pbmZvX3RpcF9kaXNtaXNzZWRcIjtcbn0pKGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzIHx8IChhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cyA9IHt9KSk7XG5jb25zdCBnZXRMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5KSA9PiB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvY2FsU3RvcmFnZUtleSk7XG59O1xuY29uc3Qgc2V0TG9jYWxTdG9yYWdlID0gKGxvY2FsU3RvcmFnZUtleSwgdmFsdWUpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VLZXksIHZhbHVlKTtcbn07XG5jb25zdCBnZXRPYmplY3RMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5KSA9PiB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZ2V0TG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleSkpIHx8IHt9O1xufTtcbmNvbnN0IHNldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZSA9IChsb2NhbFN0b3JhZ2VLZXksIGtleVZhbHVlT2JqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2V0TG9jYWxTdG9yYWdlVmFsID0gZ2V0T2JqZWN0TG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleSk7XG4gICAgc2V0TG9jYWxTdG9yYWdlVmFsW2tleVZhbHVlT2JqZWN0LmtleV0gPSBrZXlWYWx1ZU9iamVjdC52YWx1ZTtcbiAgICBzZXRMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeShzZXRMb2NhbFN0b3JhZ2VWYWwpKTtcbn07XG5jb25zdCBnZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5LCBvYmplY3RLZXkpID0+IHtcbiAgICBjb25zdCBnZXRMb2NhbFN0b3JhZ2VWYWwgPSBnZXRPYmplY3RMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5KTtcbiAgICBpZiAoZ2V0TG9jYWxTdG9yYWdlVmFsID09PSBudWxsIHx8IGdldExvY2FsU3RvcmFnZVZhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0TG9jYWxTdG9yYWdlVmFsLmhhc093blByb3BlcnR5KG9iamVjdEtleSkpIHtcbiAgICAgICAgcmV0dXJuIGdldExvY2FsU3RvcmFnZVZhbFtvYmplY3RLZXldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMgYXMgYSwgZ2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlIGFzIGcsIGxvY2FsU3RvcmFnZUtleXMgYXMgbCwgc2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlIGFzIHMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxTdG9yYWdlLTljNGU3YTNhLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgeyBsIGFzIGxhbmd1YWdlTWFwIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL3N0ZW5jaWwtdHJpY2tzL2ltcGxlbWVudGluZy1pbnRlcm5hdGlvbmFsaXNhdGlvbi1pMThuLXdpdGgtc3RlbmNpbC01ZTY1NTk1NTQxMTdcbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gICAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgMiBsZXR0ZXIgY29kZWQgbGFuZ3VhZ2VcbiAgICAgICAgICAgIC8vIGUuZy4gaXQtQ0ggdnMgaXRcbiAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gICAgfSk7XG59XG5jb25zdCBzdHJpbmdDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICAgIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nQ2FjaGVbaWRdO1xufVxuLyoqXG4gKiBHZXQgc3RyaW5ncyBhbmQgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIDIgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGUgZmlyc3Qgb25lIHJldHVybnMgYSBjb2RlIHRoYXQncyBhbHNvIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlIGZpbGUuXG4gKiBUaGUgc2Vjb25kIG9uZSByZXR1cm5zIGEgY29kZSB3aGVyZSB0aGVyZSBpcyBzdXBwb3J0IGZvciB0aGUgZmlyc3QgMiBsZXR0ZXJzIG9mIHRoZSBjb2RlIGFzIHBhcnQgb2YgYSBsYW5ndWFnZSBmaWxlLFxuICogYnV0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCA0IGxldHRlciBjb2RlIGZyb20gdGhlIHBhZ2UuXG4gKiBFLmcuIEZvciBcIml0LWNoXCIgaXQgd2lsbCByZXR1cm4gXCJpdFwiIGFzIHRoZSBmaXJzdCBsYW5ndWFnZSBjb2RlIGFuZCBcIml0LWNoXCIgYXMgdGhlIHNlY29uZC5cbiAqIFRoZSBzZWNvbmQgb25lIGlzIHJlcXVpcmVkIGZvciBlc3JpLmludGwuc2V0TG9jYWxlKCkgdG8gZ2V0IHRoZSBjb3JyZWN0IGZvcm1hdHRpbmcuXG4gKlxuICogSWYgYSB0YWdOYW1lIGlzIHByb3ZpZGVkIGl0IHdpbGwgb3ZlcndpdGUgdGhlIGVsZW1lbnQncyB0YWdOYW1lXG4gKlxuICogIEByZXR1cm4gWyBzdHJpbmdzLCBmaXJzdCBsYW5ndWFnZSBjb2RlLCBzZWNvbmQgbGFuZ3VhZ2UgY29kZV1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyhlbGVtZW50LCB0YWdOYW1lKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2VJbnRsID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KTtcbiAgICBsZXQgc3RyaW5ncztcbiAgICB0cnkge1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyaW5ncywgY29tcG9uZW50TGFuZ3VhZ2UsIGNvbXBvbmVudExhbmd1YWdlSW50bF07XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSBhcyBhLCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxlLTA1MGI2ZGI5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==