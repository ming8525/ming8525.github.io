"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-7900af"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-sketch-actions-popover_2.entry.js":
/*!**********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-sketch-actions-popover_2.entry.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_sketch_actions_popover: () => (/* binding */ ArcgisSketchActionsPopover),
/* harmony export */   arcgis_sketch_features: () => (/* binding */ ArcgisSketchFeatures)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _storage_0353a769_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storage-0353a769.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/storage-0353a769.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */









const sketchFeaturesStore = (0,_index_05956cab_js__WEBPACK_IMPORTED_MODULE_1__.c)({
    strings: null,
    snappingOptions: null,
    snappingSessionStorageIds: null
});
const sketchFeaturesState = sketchFeaturesStore.state;

const ArcgisSketchActionsPopover = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisSketchActionsBulkEdit = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSketchActionsBulkEdit", 7);
        this.arcgisSketchActionsBulkDuplicate = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSketchActionsBulkDuplicate", 7);
        this.arcgisSketchActionsAddToNewSketch = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSketchActionsAddToNewSketch", 7);
        this.arcgisSketchActionsBulkDelete = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSketchActionsBulkDelete", 7);
        this.arcgisSketchActionsPopoverClose = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSketchActionsPopoverClose", 7);
        this.referenceElement = undefined;
        this.selectedGraphics = undefined;
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    async componentWillLoad() {
        this.strings = sketchFeaturesState.strings;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    async setFocus() {
        setTimeout(() => { var _a; return (_a = this.editNode) === null || _a === void 0 ? void 0 : _a.setFocus(); }, 300);
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        var _a, _b;
        const { strings } = this;
        if (!((_a = this.selectedGraphics) === null || _a === void 0 ? void 0 : _a.length)) {
            return null;
        }
        const rect = (_b = this.referenceElement) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-popover", { class: "js-app-flyout", placement: "leading-start", offsetDistance: 10, offsetSkidding: (rect.height - 120) / 4 + 70, pointerDisabled: true, label: strings.edit, triggerDisabled: true, referenceElement: this.referenceElement, open: true, onCalcitePopoverClose: () => this.arcgisSketchActionsPopoverClose.emit() }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { heading: strings.actions }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { label: strings.edit, text: strings.edit, textEnabled: true, onClick: () => this.arcgisSketchActionsBulkEdit.emit({ graphics: this.selectedGraphics }), ref: (node) => (this.editNode = node) }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { label: strings.duplicate, text: strings.duplicate, textEnabled: true, onClick: () => this.arcgisSketchActionsBulkDuplicate.emit() }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { label: strings.addToNewSketch, text: strings.addToNewSketch, textEnabled: true, onClick: () => this.arcgisSketchActionsAddToNewSketch.emit() }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { label: strings.delete, text: strings.delete, textEnabled: true, onClick: () => this.arcgisSketchActionsBulkDelete.emit() })))));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};

class svModel {
    constructor(mapNotesLayer, mapView, SketchViewModel, snappingOptions, onGraphicUpdate) {
        this.mapNotesLayer = mapNotesLayer;
        this.mapView = mapView;
        // Point
        this.sketchViewModelPoint = new SketchViewModel({
            layer: this.mapNotesLayer.pointLayer,
            view: this.mapView,
            updateOnGraphicClick: false,
            snappingOptions
        });
        this.sketchViewModelPoint.on("update", (event) => onGraphicUpdate(event));
        // Line
        this.sketchViewModelLine = new SketchViewModel({
            layer: this.mapNotesLayer.polylineLayer,
            view: this.mapView,
            updateOnGraphicClick: false,
            snappingOptions
        });
        this.sketchViewModelLine.on("update", (event) => onGraphicUpdate(event));
        // Polygon
        this.sketchViewModelPolygon = new SketchViewModel({
            layer: this.mapNotesLayer.polygonLayer,
            view: this.mapView,
            updateOnGraphicClick: false,
            snappingOptions
        });
        this.sketchViewModelPolygon.on("update", (event) => onGraphicUpdate(event));
        // Text
        this.sketchViewModelText = new SketchViewModel({
            layer: this.mapNotesLayer.textLayer,
            view: this.mapView,
            updateOnGraphicClick: false,
            snappingOptions
        });
        this.sketchViewModelText.on("update", (event) => onGraphicUpdate(event));
    }
    cancel() {
        this.cancelPoint();
        this.cancelLine();
        this.cancelPolygon();
        this.cancelText();
    }
    delete() {
        this.deletePoint();
        this.deleteLine();
        this.deletePolygon();
        this.deleteText();
    }
    duplicate() {
        this.duplicatePoint();
        this.duplicateLine();
        this.duplicatePolygon();
        this.duplicateText();
    }
    destroy() {
        this.destroyPoint();
        this.destroyLine();
        this.destroyPolygon();
        this.destroyText();
    }
    // Point
    updatePoint(graphics) {
        this.sketchViewModelPoint.update(graphics);
    }
    cancelPoint() {
        this.sketchViewModelPoint.cancel();
    }
    deletePoint() {
        this.sketchViewModelPoint.delete();
    }
    duplicatePoint() {
        this.sketchViewModelPoint.duplicate();
    }
    destroyPoint() {
        this.sketchViewModelPoint.destroy();
    }
    // Line
    updateLine(graphics) {
        this.sketchViewModelLine.update(graphics);
    }
    cancelLine() {
        this.sketchViewModelLine.cancel();
    }
    deleteLine() {
        this.sketchViewModelLine.delete();
    }
    duplicateLine() {
        this.sketchViewModelLine.duplicate();
    }
    destroyLine() {
        this.sketchViewModelLine.destroy();
    }
    // Polygon
    updatePolygon(graphics) {
        this.sketchViewModelPolygon.update(graphics);
    }
    cancelPolygon() {
        this.sketchViewModelPolygon.cancel();
    }
    deletePolygon() {
        this.sketchViewModelPolygon.delete();
    }
    duplicatePolygon() {
        this.sketchViewModelPolygon.duplicate();
    }
    destroyPolygon() {
        this.sketchViewModelPolygon.destroy();
    }
    // Text
    updateText(graphics) {
        this.sketchViewModelText.update(graphics);
    }
    cancelText() {
        this.sketchViewModelText.cancel();
    }
    deleteText() {
        this.sketchViewModelText.delete();
    }
    duplicateText() {
        this.sketchViewModelText.duplicate();
    }
    destroyText() {
        this.sketchViewModelText.destroy();
    }
}

function getGeometryTypeFromGraphic(currGraphic) {
    var _a, _b;
    switch ((_a = currGraphic === null || currGraphic === void 0 ? void 0 : currGraphic.geometry) === null || _a === void 0 ? void 0 : _a.type) {
        case "point":
            if (((_b = currGraphic === null || currGraphic === void 0 ? void 0 : currGraphic.symbol) === null || _b === void 0 ? void 0 : _b.type) === "text") {
                return "text";
            }
            else {
                return "point";
            }
        case "polyline":
            return "polyline";
        default:
            return "polygon";
    }
}

const saveSnappingToStorage = (snappingOptions, currentSnappingSessionStorageId) => {
    // get enabled layers and save object in session storage
    const featureSourcesIds = [
        ...new Set([...snappingOptions.featureSources.filter((source) => source.enabled).map((source) => source.layer.id)])
    ];
    const snappingObject = {
        enabled: snappingOptions.enabled,
        selfEnabled: snappingOptions.selfEnabled,
        featureEnabled: snappingOptions.featureEnabled,
        featureSourcesIds: featureSourcesIds
    };
    (0,_storage_0353a769_js__WEBPACK_IMPORTED_MODULE_4__.a)(currentSnappingSessionStorageId, snappingObject, true);
};
const getSnappingOptions = (snappingSessionStorageIds, layer, mapView, SnappingOptions) => {
    const snapping = getSnappingFromStorage(snappingSessionStorageIds) || {
        enabled: true,
        selfEnabled: true,
        featureEnabled: true,
        featureSourcesIds: [layer.id]
    };
    return new SnappingOptions({
        enabled: snapping.enabled,
        selfEnabled: snapping.selfEnabled,
        featureEnabled: snapping.featureEnabled,
        featureSources: getFeatureSourcesFromLayerIds(mapView, snapping.featureSourcesIds)
    });
};
const getFeatureSourcesFromLayerIds = (mapView, layerIds) => {
    const featureSources = [];
    layerIds.forEach((layerId) => {
        mapView.map.allLayers.toArray().find((layer) => {
            if ((layer === null || layer === void 0 ? void 0 : layer.type) === "map-notes" && layer.id === layerId) {
                featureSources.push({ layer, enabled: true });
            }
        });
    });
    return featureSources;
};
const getSnappingFromStorage = (snappingSessionStorageIds) => {
    if (snappingSessionStorageIds) {
        return ((0,_storage_0353a769_js__WEBPACK_IMPORTED_MODULE_4__.b)(snappingSessionStorageIds.webmap, true) ||
            (0,_storage_0353a769_js__WEBPACK_IMPORTED_MODULE_4__.b)(snappingSessionStorageIds.current, true) ||
            null);
    }
    return null;
};

const arcgisSketchFeaturesCss = ".actions-start-padding{padding:8px}";

const ArcgisSketchFeatures = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisSketchFeaturesAddSketch = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSketchFeaturesAddSketch", 7);
        this.arcgisSketchFeaturesEditFeature = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSketchFeaturesEditFeature", 7);
        this.arcgisSketchFeaturesEditMultipleFeatures = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSketchFeaturesEditMultipleFeatures", 7);
        this.arcgisSketchFeaturesAddToNewSketch = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSketchFeaturesAddToNewSketch", 7);
        this.arcgisSketchFeaturesUpdated = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSketchFeaturesUpdated", 7);
        this.graphicChange = [];
        this.graphicUpdate = [];
        this.checkboxNodes = [];
        this.selectedGraphics = [];
        this.duplicatedGraphicIndices = [];
        this.checkboxUpdate = false;
        this.numberOfActiveSVMs = 0;
        this.currentlyRenderingSymbolPreviews = false;
        this.onGraphicUpdate = (event) => {
            this.checkboxNodes = this.checkboxNodes.slice(0, this.graphics.length);
            if (event.state === "start") {
                if (this.checkboxUpdate || this.numberOfActiveSVMs) {
                    this.checkboxNodes.forEach((_, idx) => (this.checkboxNodes[idx].checked = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_5__.i)(this.selectedGraphics.find((selectedGraphic) => selectedGraphic.index === idx))));
                    this.checkboxUpdate = false;
                    this.numberOfActiveSVMs -= 1;
                }
                else {
                    let found = false;
                    this.selectedGraphics = [];
                    this.graphics.forEach((graphic, index) => {
                        if (!found &&
                            JSON.stringify(graphic.toJSON()) === JSON.stringify(event.graphics[0].toJSON())) {
                            found = true;
                            this.selectedGraphics.push({ index, graphic });
                            this.checkboxNodes[index].checked = true;
                            this.addActionsPopover();
                        }
                        else {
                            this.checkboxNodes[index].checked = false;
                        }
                    });
                }
            }
            if (event.state === "complete") {
                this.arcgisSketchFeaturesUpdated.emit();
            }
        };
        this.pickListItem = (graphic, index) => {
            var _a;
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list-item", { label: ((_a = graphic === null || graphic === void 0 ? void 0 : graphic.attributes) === null || _a === void 0 ? void 0 : _a.title) || this.getStringFromType(graphic) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "actions-start", class: "actions-start-padding" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { ref: (node) => this.checkboxNodes.push(node), scale: "l", onCalciteCheckboxChange: (event) => {
                    if (event.target.checked) {
                        this.checkboxUpdate = true;
                        this.selectedGraphics.push({ index, graphic });
                    }
                    else {
                        this.selectedGraphics = this.selectedGraphics.filter((selectedGraphic) => selectedGraphic.index !== index);
                    }
                    if (this.selectedGraphics.length) {
                        this.addActionsPopover();
                        this.actionsPopoverNode.selectedGraphics = this.selectedGraphics;
                        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.actionsPopoverNode);
                    }
                    else {
                        this.removeActionsPopover();
                    }
                    let tempPoint = [];
                    let tempLine = [];
                    let tempPolygon = [];
                    let tempText = [];
                    this.selectedGraphics.forEach((selectedGraphic) => {
                        switch (getGeometryTypeFromGraphic(selectedGraphic.graphic)) {
                            case "polyline":
                                tempLine = [...tempLine, selectedGraphic.graphic];
                                break;
                            case "polygon":
                                tempPolygon = [...tempPolygon, selectedGraphic.graphic];
                                break;
                            case "text":
                                tempText = [...tempText, selectedGraphic.graphic];
                                break;
                            default:
                                tempPoint = [...tempPoint, selectedGraphic.graphic];
                                break;
                        }
                    });
                    const graphicArrays = [tempPoint, tempLine, tempPolygon, tempText];
                    const activeSVMs = graphicArrays.filter((graphicArray) => graphicArray.length);
                    this.numberOfActiveSVMs = activeSVMs.length;
                    this.checkboxUpdate = true;
                    tempPoint.length ? this.svModel.updatePoint(tempPoint) : this.svModel.cancelPoint();
                    tempLine.length ? this.svModel.updateLine(tempLine) : this.svModel.cancelLine();
                    tempPolygon.length
                        ? this.svModel.updatePolygon(tempPolygon)
                        : this.svModel.cancelPolygon();
                    tempText.length ? this.svModel.updateText(tempText) : this.svModel.cancelText();
                    this.watchForGraphicSelectionOnClick();
                    if (!this.selectedGraphics.length) {
                        this.svModel.cancel();
                        this.combineMapNotesGraphics();
                        this.checkboxUpdate = false;
                        this.numberOfActiveSVMs = 0;
                    }
                } })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "content-start", id: `image-${index}` }), this.showEditFeature ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { slot: "actions-end", text: this.strings.edit, title: this.strings.edit, scale: "s", icon: "pencil", onClick: () => {
                    this.selectedGraphics.push({ index, graphic });
                    this.arcgisSketchFeaturesEditFeature.emit({ layer: this.layer, feature: graphic });
                } })) : null));
        };
        this.layer = undefined;
        this.mapView = undefined;
        this.showAddSketch = true;
        this.showEditFeature = true;
        this.snappingSessionStorageIds = undefined;
        this.open = true;
        this.graphics = undefined;
    }
    sketchUpdatedHandler(event) {
        event.stopPropagation();
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    async componentWillLoad() {
        [this.strings] = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement);
        await this.loadAllModules();
        this.snappingOptions = getSnappingOptions(this.snappingSessionStorageIds, this.layer, this.mapView, this.SnappingOptions);
        this.svModel = new svModel(this.layer, this.mapView, this.SketchViewModel, this.snappingOptions, this.onGraphicUpdate);
        this.combineMapNotesGraphics();
        sketchFeaturesState.strings = this.strings;
        sketchFeaturesState.snappingOptions = this.snappingOptions;
        sketchFeaturesState.snappingSessionStorageIds = this.snappingSessionStorageIds;
    }
    componentDidLoad() {
        this.watchForChangesToMapNotesLayer();
        this.watchForGraphicSelectionOnClick();
    }
    async componentDidRender() {
        var _a, _b, _c;
        // preview each graphic
        if (this.currentlyRenderingSymbolPreviews) {
            return;
        }
        this.currentlyRenderingSymbolPreviews = true;
        for (let x = 0; x < this.graphics.length; x++) {
            const currElement = this.hostElement.shadowRoot.getElementById(`image-${x}`);
            currElement.textContent = "";
            await this.symbolUtils.renderPreviewHTML(this.graphics[x].symbol, Object.assign({ node: currElement, scale: true, maxSize: 20, size: { width: 20, height: this.graphics[x].geometry.type === "polyline" ? 6 : 20 } }, (((_a = this.graphics[x].symbol) === null || _a === void 0 ? void 0 : _a.type) === "text" && {
                overrideText: ((_c = (_b = this.graphics[x].symbol) === null || _b === void 0 ? void 0 : _b.text) === null || _c === void 0 ? void 0 : _c[0]) || this.strings.textPreview
            })));
        }
        this.currentlyRenderingSymbolPreviews = false;
    }
    componentDidUpdate() {
        if (this.duplicatedGraphicIndices.length) {
            this.checkboxNodes.forEach((_, idx) => (this.checkboxNodes[idx].checked = this.duplicatedGraphicIndices.includes(idx)));
            this.selectedGraphics = [];
            this.checkboxNodes.forEach((checkboxNode, index) => {
                if (checkboxNode.checked) {
                    this.selectedGraphics.push({ index, graphic: this.graphics[index] });
                }
            });
            this.duplicatedGraphicIndices = [];
        }
    }
    disconnectedCallback() {
        var _a;
        this.graphicChange.forEach((currentHandle) => currentHandle === null || currentHandle === void 0 ? void 0 : currentHandle.remove());
        this.graphicUpdate.forEach((currentHandle) => currentHandle === null || currentHandle === void 0 ? void 0 : currentHandle.remove());
        this.unselectAllGraphics();
        (_a = this.hitTestHandle) === null || _a === void 0 ? void 0 : _a.remove();
        this.hitTestHandle = undefined;
        this.svModel.cancel();
        this.svModel.destroy();
    }
    // --------------------------------------------------------------------------
    //
    // Public Methods
    //
    // --------------------------------------------------------------------------
    async setFocus() {
        this.addFeatureNode.setFocus();
    }
    // Public Methods
    async done() {
        var _a;
        if ((_a = this.snappingSessionStorageIds) === null || _a === void 0 ? void 0 : _a.current) {
            saveSnappingToStorage(this.snappingOptions, this.snappingSessionStorageIds.current);
        }
        this.svModel.destroy();
        // enable popup in the map view
        this.mapView.popupEnabled = true;
    }
    // --------------------------------------------------------------------------
    //
    // Private Methods
    //
    // --------------------------------------------------------------------------
    async loadAllModules() {
        [this.reactiveUtils, this.symbolUtils, this.SketchViewModel, this.SnappingOptions] =
            await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)([
                "esri/core/reactiveUtils",
                "esri/symbols/support/symbolUtils",
                "esri/widgets/Sketch/SketchViewModel",
                "esri/views/interactive/snapping/SnappingOptions"
            ]);
    }
    watchForChangesToMapNotesLayer() {
        for (const sublayer of [
            this.layer.pointLayer,
            this.layer.polylineLayer,
            this.layer.polygonLayer,
            this.layer.textLayer
        ]) {
            const currGraphicsChange = this.reactiveUtils.on(() => sublayer.graphics, "change", () => {
                if (!this.checkboxUpdate) {
                    this.combineMapNotesGraphics();
                }
            });
            this.graphicChange.push(currGraphicsChange);
            // changes on clone
            const currGraphicsUpdate = this.reactiveUtils.on(() => sublayer, "graphic-update", (event) => {
                if ((event === null || event === void 0 ? void 0 : event.property) !== "geometry") {
                    this.combineMapNotesGraphics();
                }
            });
            this.graphicUpdate.push(currGraphicsUpdate);
        }
    }
    combineMapNotesGraphics() {
        this.graphics = [
            ...this.layer.pointLayer.graphics,
            ...this.layer.polylineLayer.graphics,
            ...this.layer.polygonLayer.graphics,
            ...this.layer.textLayer.graphics
        ];
    }
    getStringFromType(currGraphic) {
        var _a, _b;
        switch ((_a = currGraphic === null || currGraphic === void 0 ? void 0 : currGraphic.geometry) === null || _a === void 0 ? void 0 : _a.type) {
            case "point":
                if (((_b = currGraphic === null || currGraphic === void 0 ? void 0 : currGraphic.symbol) === null || _b === void 0 ? void 0 : _b.type) === "text") {
                    return this.strings.text;
                }
                else {
                    return this.strings.point;
                }
            case "polyline":
                return this.strings.line;
            case "polygon":
                return this.strings.polygon;
            default:
                return this.strings.point;
        }
    }
    addActionsPopover() {
        if (this.actionsPopoverNode) {
            this.actionsPopoverNode.setFocus();
            return;
        }
        this.actionsPopoverNode = document.createElement("arcgis-sketch-actions-popover");
        this.actionsPopoverNode.referenceElement = this.blockNode;
        this.actionsPopoverNode.selectedGraphics = this.selectedGraphics;
        this.actionsPopoverNode.addEventListener("arcgisSketchActionsBulkEdit", (event) => {
            this.removeActionsPopover();
            this.unselectAllGraphics();
            const features = event.detail.graphics.map((selectedGraphic) => selectedGraphic.graphic);
            this.arcgisSketchFeaturesEditMultipleFeatures.emit({ features });
        });
        this.actionsPopoverNode.addEventListener("arcgisSketchActionsBulkDuplicate", () => {
            this.svModel.duplicate();
            this.combineMapNotesGraphics();
            const selectedFeatures = this.selectedGraphics.map((selectedGraphic) => selectedGraphic.graphic);
            this.duplicatedGraphicIndices = [];
            selectedFeatures.forEach((selectedFeature) => {
                let found = false;
                this.graphics.forEach((graphic, idx) => {
                    if (!found &&
                        JSON.stringify(graphic.toJSON()) === JSON.stringify(selectedFeature.toJSON())) {
                        if (!this.duplicatedGraphicIndices.includes(idx)) {
                            this.duplicatedGraphicIndices.push(idx);
                            found = true;
                        }
                    }
                });
            });
        });
        this.actionsPopoverNode.addEventListener("arcgisSketchActionsAddToNewSketch", () => {
            const selectedFeatures = this.selectedGraphics.map((selectedGraphic) => selectedGraphic.graphic);
            this.arcgisSketchFeaturesAddToNewSketch.emit({ features: selectedFeatures });
        });
        this.actionsPopoverNode.addEventListener("arcgisSketchActionsBulkDelete", () => {
            this.removeActionsPopover();
            this.unselectAllGraphics();
            this.svModel.delete();
            this.combineMapNotesGraphics();
            this.checkboxUpdate = false;
            this.numberOfActiveSVMs = 0;
        });
        this.actionsPopoverNode.addEventListener("arcgisSketchActionsPopoverClose", () => {
            this.removeActionsPopover();
            this.svModel.cancel();
            this.unselectAllGraphics();
            this.checkboxUpdate = false;
            this.numberOfActiveSVMs = 0;
        });
        document.body.appendChild(this.actionsPopoverNode);
        this.actionsPopoverNode.setFocus();
    }
    removeActionsPopover() {
        var _a, _b;
        (_b = (_a = this.actionsPopoverNode) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(this.actionsPopoverNode);
        this.actionsPopoverNode = null;
    }
    unselectAllGraphics(keepActionsPopover) {
        this.selectedGraphics = [];
        this.checkboxNodes.forEach((checkboxNode) => {
            if (checkboxNode) {
                checkboxNode.checked = false;
            }
        });
        if (!keepActionsPopover) {
            this.removeActionsPopover();
        }
    }
    selectSingleGraphic(currGraphic) {
        var _a;
        switch (currGraphic.layer) {
            case this.layer.pointLayer:
                this.svModel.updatePoint([currGraphic]);
                break;
            case this.layer.textLayer:
                this.svModel.updateText([currGraphic]);
                break;
            case this.layer.polylineLayer:
                this.svModel.updateLine([currGraphic]);
                break;
            case this.layer.polygonLayer:
                this.svModel.updatePolygon([currGraphic]);
            default:
                return;
        }
        (_a = this.graphics) === null || _a === void 0 ? void 0 : _a.forEach((graphic, index) => {
            if (JSON.stringify(graphic.toJSON()) === JSON.stringify(currGraphic.toJSON())) {
                const graphicAlreadySelected = this.selectedGraphics.find((selectedGraphic) => JSON.stringify(selectedGraphic.graphic.toJSON()) ===
                    JSON.stringify(currGraphic.toJSON()));
                if (!graphicAlreadySelected) {
                    this.selectedGraphics.push({ index, graphic });
                    this.checkboxNodes[index].checked = true;
                }
            }
        });
        this.addActionsPopover();
    }
    watchForGraphicSelectionOnClick() {
        var _a;
        (_a = this.hitTestHandle) === null || _a === void 0 ? void 0 : _a.remove();
        this.hitTestHandle = this.mapView.on("click", async (event) => {
            var _a;
            const hitTestResults = await this.mapView.hitTest(event, {
                include: this.layer
            });
            const results = hitTestResults.results;
            if (results.length) {
                const order = ["point", "polyline", "polygon"];
                results.sort(function (a, b) {
                    return order.indexOf(a.graphic.geometry.type) - order.indexOf(b.graphic.geometry.type);
                });
                const currGraphic = results[0].graphic;
                this.unselectAllGraphics(true);
                this.selectSingleGraphic(currGraphic);
            }
            else {
                (_a = this.checkboxNodes) === null || _a === void 0 ? void 0 : _a.forEach((checkboxNode) => {
                    if (checkboxNode) {
                        checkboxNode.checked = false;
                    }
                });
                this.removeActionsPopover();
                this.unselectAllGraphics();
                this.svModel.cancel();
                this.checkboxUpdate = false;
                this.numberOfActiveSVMs = 0;
            }
        });
    }
    // --------------------------------------------------------------------------
    //
    // Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        this.checkboxNodes = [];
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { ref: (node) => (this.blockNode = node), heading: this.strings.sketches, open: this.open, collapsible: true, onCalciteBlockOpen: () => {
                if (this.selectedGraphics.length) {
                    this.addActionsPopover();
                }
            }, onCalciteBlockClose: () => this.removeActionsPopover() }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", null, this.graphics.map((graphic, index) => {
            return this.pickListItem(graphic, index);
        })), this.showAddSketch ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { ref: (element) => (this.addFeatureNode = element), iconStart: "pencil-mark", appearance: "transparent", width: "full", onClick: () => {
                this.removeActionsPopover();
                this.unselectAllGraphics();
                this.svModel.cancel();
                this.arcgisSketchFeaturesAddSketch.emit({ layer: this.layer });
            } }, this.strings.addSketch)) : null)));
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisSketchFeatures.style = arcgisSketchFeaturesCss;



//# sourceMappingURL=arcgis-sketch-actions-popover_2.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};



//# sourceMappingURL=index-05956cab.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/storage-0353a769.js":
/*!*************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/storage-0353a769.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ setSessionStorageItem),
/* harmony export */   b: () => (/* binding */ getSessionStorageItem),
/* harmony export */   c: () => (/* binding */ getCookie),
/* harmony export */   d: () => (/* binding */ setCookie),
/* harmony export */   g: () => (/* binding */ getLocalStorageItem),
/* harmony export */   s: () => (/* binding */ setLocalStorageItem)
/* harmony export */ });
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


// import stringUtil from "./strings";
/**
 * Utility methods for dealing with storage of various forms (cookies, local storage, and session storage).
 */
function setCookie(name, cookie, properties, stringify) {
    writeCookie(name, stringify ? JSON.stringify(cookie) : cookie, properties);
}
function getCookie(name, parse) {
    const cookie = readCookie(name);
    return cookie && parse ? JSON.parse(cookie) : cookie;
}
function setLocalStorageItem(name, item, stringify) {
    window.localStorage.setItem(name, stringify ? JSON.stringify(item) : item);
}
function getLocalStorageItem(name, parse) {
    const item = window.localStorage.getItem(name);
    return item && parse ? JSON.parse(item) : item;
}
function setSessionStorageItem(name, item, stringify) {
    window.sessionStorage.setItem(name, stringify ? JSON.stringify(item) : item);
}
function getSessionStorageItem(name, parse) {
    const item = window.sessionStorage.getItem(name);
    return item && parse ? JSON.parse(item) : item;
}
function readCookie(name) {
    const cookie = document.cookie;
    const cookieNameRE = new RegExp(`(?:^|; )${(0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_0__.e)(name)}=([^;]*)`);
    const matchedCookies = cookie.match(cookieNameRE);
    return matchedCookies ? decodeURIComponent(matchedCookies[1]) : undefined;
}
function writeCookie(name, value, properties) {
    properties = properties || {};
    let expires = properties === null || properties === void 0 ? void 0 : properties.expires;
    if (typeof expires === "number") {
        const expirationDate = new Date();
        const daysFromTodayInMs = expires * 24 * 60 * 60 * 1000;
        expirationDate.setTime(Date.now() + daysFromTodayInMs);
        expires = properties.expires = expirationDate;
    }
    if (typeof expires !== "string" && (expires === null || expires === void 0 ? void 0 : expires.toUTCString)) {
        properties.expires = expires.toUTCString();
    }
    let cookie = `${name}=${encodeURIComponent(value)}`;
    let property;
    for (property in properties) {
        cookie += `; ${property}`;
        const propertyValue = properties[property];
        if (propertyValue !== true) {
            cookie += `=${propertyValue}`;
        }
    }
    document.cookie = cookie;
}



//# sourceMappingURL=storage-0353a769.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTc5MDBhZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDK0g7QUFDeEU7QUFDTTtBQUNTO0FBQ3lCO0FBQ3JDO0FBQy9CO0FBQ1M7O0FBRXBDLDRCQUE0QixxREFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLFFBQVEscURBQWdCO0FBQ3hCLDJDQUEyQyxxREFBVztBQUN0RCxnREFBZ0QscURBQVc7QUFDM0QsaURBQWlELHFEQUFXO0FBQzVELDZDQUE2QyxxREFBVztBQUN4RCwrQ0FBK0MscURBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRLGlGQUFpRjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQUMsQ0FBQyxpREFBSSxRQUFRLHFEQUFDLHNCQUFzQix3VEFBd1QsRUFBRSxxREFBQyxvQkFBb0IsMEJBQTBCLEVBQUUscURBQUMscUJBQXFCLG1IQUFtSCxpQ0FBaUMsMENBQTBDLEdBQUcscURBQUMscUJBQXFCLG1JQUFtSSxHQUFHLHFEQUFDLHFCQUFxQiw4SUFBOEksR0FBRyxxREFBQyxxQkFBcUIsMEhBQTBIO0FBQzFrQztBQUNBLHdCQUF3QixPQUFPLHFEQUFVO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBcUI7QUFDckMsWUFBWSx1REFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELFlBQVk7O0FBRXBFO0FBQ0E7QUFDQSxRQUFRLHFEQUFnQjtBQUN4Qiw2Q0FBNkMscURBQVc7QUFDeEQsK0NBQStDLHFEQUFXO0FBQzFELHdEQUF3RCxxREFBVztBQUNuRSxrREFBa0QscURBQVc7QUFDN0QsMkNBQTJDLHFEQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RiwwREFBUztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQUMsd0JBQXdCLHVLQUF1SyxFQUFFLHFEQUFDLFVBQVUsdURBQXVELEVBQUUscURBQUMsdUJBQXVCO0FBQ2xUO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJLHFEQUFDLFVBQVUsb0NBQW9DLE1BQU0sR0FBRywyQkFBMkIscURBQUMscUJBQXFCO0FBQ2hJLGlEQUFpRCxnQkFBZ0I7QUFDakUsZ0VBQWdFLHFDQUFxQztBQUNyRyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0RBQXlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRCxvRkFBb0YsRUFBRTtBQUN0RjtBQUNBLDhGQUE4RixxREFBcUQsNkVBQTZFO0FBQ2hPO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxzQ0FBc0M7QUFDdkY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSwyREFBMkQsNEJBQTRCO0FBQ3ZGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFDLENBQUMsaURBQUksUUFBUSxxREFBQyxvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwREFBMEQsRUFBRSxxREFBQztBQUMxRTtBQUNBLFNBQVMsMEJBQTBCLHFEQUFDLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsbUJBQW1CO0FBQzdFLGVBQWU7QUFDZjtBQUNBLHdCQUF3QixPQUFPLHFEQUFVO0FBQ3pDO0FBQ0E7O0FBRXVIOztBQUV2SDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNXBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFaU07O0FBRWpNOzs7Ozs7Ozs7Ozs7Ozs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDNkU7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlLGlEQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpREFBVztBQUN0RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0RBQXdELGlEQUFXO0FBQ25FO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCOztBQUU1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ2M7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQWlDLFNBQVMsS0FBSztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0EsNkJBQTZCLDJEQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVFQUF1RSw4QkFBOEIsYUFBYTtBQUNsSDtBQUNBLCtCQUErQiwyREFBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU8sTUFBTSxPQUFPO0FBQ2pFO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTyxNQUFNLE9BQU87QUFDNUQ7O0FBRXlIOztBQUV6SDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQzJFO0FBQ2I7QUFDTjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1EQUFpQztBQUNsRTtBQUNBO0FBQ0EsUUFBUSx3REFBVztBQUNuQixlQUFlLHdEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQVc7QUFDdkIsbUJBQW1CLHdEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1EQUFpQztBQUNsRTtBQUNBO0FBQ0EsUUFBUSx3REFBVztBQUNuQixlQUFlLHdEQUFXO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLHdEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFZLDhCQUE4QixjQUFjLFFBQVEsT0FBTztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWMsRUFBRSxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFlLEdBQUcsa0JBQWtCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUU0RTs7QUFFNUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsR0FBRywwREFBWSxPQUFPLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUssR0FBRywwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBLHFCQUFxQixFQUFFLFNBQVM7QUFDaEM7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVzSjs7QUFFdEoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtc2tldGNoLWFjdGlvbnMtcG9wb3Zlcl8yLmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vaW5kZXgtMDU5NTZjYWIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsZS0wNTBiNmRiOS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9zdG9yYWdlLTAzNTNhNzY5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIGQgYXMgZ2V0RWxlbWVudCwgZiBhcyBmb3JjZVVwZGF0ZSB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVTdG9yZSB9IGZyb20gJy4vaW5kZXgtMDU5NTZjYWIuanMnO1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIH0gZnJvbSAnLi9sb2NhbGUtMDUwYjZkYjkuanMnO1xuaW1wb3J0IHsgYSBhcyBzZXRTZXNzaW9uU3RvcmFnZUl0ZW0sIGIgYXMgZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtIH0gZnJvbSAnLi9zdG9yYWdlLTAzNTNhNzY5LmpzJztcbmltcG9ydCB7IGkgYXMgaXNEZWZpbmVkIH0gZnJvbSAnLi9mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzJztcbmltcG9ydCAnLi9kb20tNGQzNjc2NzcuanMnO1xuaW1wb3J0ICcuL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyc7XG5cbmNvbnN0IHNrZXRjaEZlYXR1cmVzU3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgc3RyaW5nczogbnVsbCxcbiAgICBzbmFwcGluZ09wdGlvbnM6IG51bGwsXG4gICAgc25hcHBpbmdTZXNzaW9uU3RvcmFnZUlkczogbnVsbFxufSk7XG5jb25zdCBza2V0Y2hGZWF0dXJlc1N0YXRlID0gc2tldGNoRmVhdHVyZXNTdG9yZS5zdGF0ZTtcblxuY29uc3QgQXJjZ2lzU2tldGNoQWN0aW9uc1BvcG92ZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc1NrZXRjaEFjdGlvbnNCdWxrRWRpdCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU2tldGNoQWN0aW9uc0J1bGtFZGl0XCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc1NrZXRjaEFjdGlvbnNCdWxrRHVwbGljYXRlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNTa2V0Y2hBY3Rpb25zQnVsa0R1cGxpY2F0ZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNTa2V0Y2hBY3Rpb25zQWRkVG9OZXdTa2V0Y2ggPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1NrZXRjaEFjdGlvbnNBZGRUb05ld1NrZXRjaFwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNTa2V0Y2hBY3Rpb25zQnVsa0RlbGV0ZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU2tldGNoQWN0aW9uc0J1bGtEZWxldGVcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzU2tldGNoQWN0aW9uc1BvcG92ZXJDbG9zZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU2tldGNoQWN0aW9uc1BvcG92ZXJDbG9zZVwiLCA3KTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNlbGVjdGVkR3JhcGhpY3MgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBza2V0Y2hGZWF0dXJlc1N0YXRlLnN0cmluZ3M7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQdWJsaWMgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIHNldEZvY3VzKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5lZGl0Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7IH0sIDMwMCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBSZW5kZXIgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbGVjdGVkR3JhcGhpY3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWN0ID0gKF9iID0gdGhpcy5yZWZlcmVuY2VFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiY2FsY2l0ZS1wb3BvdmVyXCIsIHsgY2xhc3M6IFwianMtYXBwLWZseW91dFwiLCBwbGFjZW1lbnQ6IFwibGVhZGluZy1zdGFydFwiLCBvZmZzZXREaXN0YW5jZTogMTAsIG9mZnNldFNraWRkaW5nOiAocmVjdC5oZWlnaHQgLSAxMjApIC8gNCArIDcwLCBwb2ludGVyRGlzYWJsZWQ6IHRydWUsIGxhYmVsOiBzdHJpbmdzLmVkaXQsIHRyaWdnZXJEaXNhYmxlZDogdHJ1ZSwgcmVmZXJlbmNlRWxlbWVudDogdGhpcy5yZWZlcmVuY2VFbGVtZW50LCBvcGVuOiB0cnVlLCBvbkNhbGNpdGVQb3BvdmVyQ2xvc2U6ICgpID0+IHRoaXMuYXJjZ2lzU2tldGNoQWN0aW9uc1BvcG92ZXJDbG9zZS5lbWl0KCkgfSwgaChcImNhbGNpdGUtcGFuZWxcIiwgeyBoZWFkaW5nOiBzdHJpbmdzLmFjdGlvbnMgfSwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgbGFiZWw6IHN0cmluZ3MuZWRpdCwgdGV4dDogc3RyaW5ncy5lZGl0LCB0ZXh0RW5hYmxlZDogdHJ1ZSwgb25DbGljazogKCkgPT4gdGhpcy5hcmNnaXNTa2V0Y2hBY3Rpb25zQnVsa0VkaXQuZW1pdCh7IGdyYXBoaWNzOiB0aGlzLnNlbGVjdGVkR3JhcGhpY3MgfSksIHJlZjogKG5vZGUpID0+ICh0aGlzLmVkaXROb2RlID0gbm9kZSkgfSksIGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IGxhYmVsOiBzdHJpbmdzLmR1cGxpY2F0ZSwgdGV4dDogc3RyaW5ncy5kdXBsaWNhdGUsIHRleHRFbmFibGVkOiB0cnVlLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmFyY2dpc1NrZXRjaEFjdGlvbnNCdWxrRHVwbGljYXRlLmVtaXQoKSB9KSwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgbGFiZWw6IHN0cmluZ3MuYWRkVG9OZXdTa2V0Y2gsIHRleHQ6IHN0cmluZ3MuYWRkVG9OZXdTa2V0Y2gsIHRleHRFbmFibGVkOiB0cnVlLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmFyY2dpc1NrZXRjaEFjdGlvbnNBZGRUb05ld1NrZXRjaC5lbWl0KCkgfSksIGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IGxhYmVsOiBzdHJpbmdzLmRlbGV0ZSwgdGV4dDogc3RyaW5ncy5kZWxldGUsIHRleHRFbmFibGVkOiB0cnVlLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmFyY2dpc1NrZXRjaEFjdGlvbnNCdWxrRGVsZXRlLmVtaXQoKSB9KSkpKSk7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5cbmNsYXNzIHN2TW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKG1hcE5vdGVzTGF5ZXIsIG1hcFZpZXcsIFNrZXRjaFZpZXdNb2RlbCwgc25hcHBpbmdPcHRpb25zLCBvbkdyYXBoaWNVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5tYXBOb3Rlc0xheWVyID0gbWFwTm90ZXNMYXllcjtcbiAgICAgICAgdGhpcy5tYXBWaWV3ID0gbWFwVmlldztcbiAgICAgICAgLy8gUG9pbnRcbiAgICAgICAgdGhpcy5za2V0Y2hWaWV3TW9kZWxQb2ludCA9IG5ldyBTa2V0Y2hWaWV3TW9kZWwoe1xuICAgICAgICAgICAgbGF5ZXI6IHRoaXMubWFwTm90ZXNMYXllci5wb2ludExheWVyLFxuICAgICAgICAgICAgdmlldzogdGhpcy5tYXBWaWV3LFxuICAgICAgICAgICAgdXBkYXRlT25HcmFwaGljQ2xpY2s6IGZhbHNlLFxuICAgICAgICAgICAgc25hcHBpbmdPcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbFBvaW50Lm9uKFwidXBkYXRlXCIsIChldmVudCkgPT4gb25HcmFwaGljVXBkYXRlKGV2ZW50KSk7XG4gICAgICAgIC8vIExpbmVcbiAgICAgICAgdGhpcy5za2V0Y2hWaWV3TW9kZWxMaW5lID0gbmV3IFNrZXRjaFZpZXdNb2RlbCh7XG4gICAgICAgICAgICBsYXllcjogdGhpcy5tYXBOb3Rlc0xheWVyLnBvbHlsaW5lTGF5ZXIsXG4gICAgICAgICAgICB2aWV3OiB0aGlzLm1hcFZpZXcsXG4gICAgICAgICAgICB1cGRhdGVPbkdyYXBoaWNDbGljazogZmFsc2UsXG4gICAgICAgICAgICBzbmFwcGluZ09wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsTGluZS5vbihcInVwZGF0ZVwiLCAoZXZlbnQpID0+IG9uR3JhcGhpY1VwZGF0ZShldmVudCkpO1xuICAgICAgICAvLyBQb2x5Z29uXG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsUG9seWdvbiA9IG5ldyBTa2V0Y2hWaWV3TW9kZWwoe1xuICAgICAgICAgICAgbGF5ZXI6IHRoaXMubWFwTm90ZXNMYXllci5wb2x5Z29uTGF5ZXIsXG4gICAgICAgICAgICB2aWV3OiB0aGlzLm1hcFZpZXcsXG4gICAgICAgICAgICB1cGRhdGVPbkdyYXBoaWNDbGljazogZmFsc2UsXG4gICAgICAgICAgICBzbmFwcGluZ09wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsUG9seWdvbi5vbihcInVwZGF0ZVwiLCAoZXZlbnQpID0+IG9uR3JhcGhpY1VwZGF0ZShldmVudCkpO1xuICAgICAgICAvLyBUZXh0XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsVGV4dCA9IG5ldyBTa2V0Y2hWaWV3TW9kZWwoe1xuICAgICAgICAgICAgbGF5ZXI6IHRoaXMubWFwTm90ZXNMYXllci50ZXh0TGF5ZXIsXG4gICAgICAgICAgICB2aWV3OiB0aGlzLm1hcFZpZXcsXG4gICAgICAgICAgICB1cGRhdGVPbkdyYXBoaWNDbGljazogZmFsc2UsXG4gICAgICAgICAgICBzbmFwcGluZ09wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsVGV4dC5vbihcInVwZGF0ZVwiLCAoZXZlbnQpID0+IG9uR3JhcGhpY1VwZGF0ZShldmVudCkpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsUG9pbnQoKTtcbiAgICAgICAgdGhpcy5jYW5jZWxMaW5lKCk7XG4gICAgICAgIHRoaXMuY2FuY2VsUG9seWdvbigpO1xuICAgICAgICB0aGlzLmNhbmNlbFRleHQoKTtcbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICB0aGlzLmRlbGV0ZVBvaW50KCk7XG4gICAgICAgIHRoaXMuZGVsZXRlTGluZSgpO1xuICAgICAgICB0aGlzLmRlbGV0ZVBvbHlnb24oKTtcbiAgICAgICAgdGhpcy5kZWxldGVUZXh0KCk7XG4gICAgfVxuICAgIGR1cGxpY2F0ZSgpIHtcbiAgICAgICAgdGhpcy5kdXBsaWNhdGVQb2ludCgpO1xuICAgICAgICB0aGlzLmR1cGxpY2F0ZUxpbmUoKTtcbiAgICAgICAgdGhpcy5kdXBsaWNhdGVQb2x5Z29uKCk7XG4gICAgICAgIHRoaXMuZHVwbGljYXRlVGV4dCgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lQb2ludCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lMaW5lKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveVBvbHlnb24oKTtcbiAgICAgICAgdGhpcy5kZXN0cm95VGV4dCgpO1xuICAgIH1cbiAgICAvLyBQb2ludFxuICAgIHVwZGF0ZVBvaW50KGdyYXBoaWNzKSB7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsUG9pbnQudXBkYXRlKGdyYXBoaWNzKTtcbiAgICB9XG4gICAgY2FuY2VsUG9pbnQoKSB7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsUG9pbnQuY2FuY2VsKCk7XG4gICAgfVxuICAgIGRlbGV0ZVBvaW50KCkge1xuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbFBvaW50LmRlbGV0ZSgpO1xuICAgIH1cbiAgICBkdXBsaWNhdGVQb2ludCgpIHtcbiAgICAgICAgdGhpcy5za2V0Y2hWaWV3TW9kZWxQb2ludC5kdXBsaWNhdGUoKTtcbiAgICB9XG4gICAgZGVzdHJveVBvaW50KCkge1xuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbFBvaW50LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgLy8gTGluZVxuICAgIHVwZGF0ZUxpbmUoZ3JhcGhpY3MpIHtcbiAgICAgICAgdGhpcy5za2V0Y2hWaWV3TW9kZWxMaW5lLnVwZGF0ZShncmFwaGljcyk7XG4gICAgfVxuICAgIGNhbmNlbExpbmUoKSB7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsTGluZS5jYW5jZWwoKTtcbiAgICB9XG4gICAgZGVsZXRlTGluZSgpIHtcbiAgICAgICAgdGhpcy5za2V0Y2hWaWV3TW9kZWxMaW5lLmRlbGV0ZSgpO1xuICAgIH1cbiAgICBkdXBsaWNhdGVMaW5lKCkge1xuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbExpbmUuZHVwbGljYXRlKCk7XG4gICAgfVxuICAgIGRlc3Ryb3lMaW5lKCkge1xuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbExpbmUuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvLyBQb2x5Z29uXG4gICAgdXBkYXRlUG9seWdvbihncmFwaGljcykge1xuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbFBvbHlnb24udXBkYXRlKGdyYXBoaWNzKTtcbiAgICB9XG4gICAgY2FuY2VsUG9seWdvbigpIHtcbiAgICAgICAgdGhpcy5za2V0Y2hWaWV3TW9kZWxQb2x5Z29uLmNhbmNlbCgpO1xuICAgIH1cbiAgICBkZWxldGVQb2x5Z29uKCkge1xuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbFBvbHlnb24uZGVsZXRlKCk7XG4gICAgfVxuICAgIGR1cGxpY2F0ZVBvbHlnb24oKSB7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsUG9seWdvbi5kdXBsaWNhdGUoKTtcbiAgICB9XG4gICAgZGVzdHJveVBvbHlnb24oKSB7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsUG9seWdvbi5kZXN0cm95KCk7XG4gICAgfVxuICAgIC8vIFRleHRcbiAgICB1cGRhdGVUZXh0KGdyYXBoaWNzKSB7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsVGV4dC51cGRhdGUoZ3JhcGhpY3MpO1xuICAgIH1cbiAgICBjYW5jZWxUZXh0KCkge1xuICAgICAgICB0aGlzLnNrZXRjaFZpZXdNb2RlbFRleHQuY2FuY2VsKCk7XG4gICAgfVxuICAgIGRlbGV0ZVRleHQoKSB7XG4gICAgICAgIHRoaXMuc2tldGNoVmlld01vZGVsVGV4dC5kZWxldGUoKTtcbiAgICB9XG4gICAgZHVwbGljYXRlVGV4dCgpIHtcbiAgICAgICAgdGhpcy5za2V0Y2hWaWV3TW9kZWxUZXh0LmR1cGxpY2F0ZSgpO1xuICAgIH1cbiAgICBkZXN0cm95VGV4dCgpIHtcbiAgICAgICAgdGhpcy5za2V0Y2hWaWV3TW9kZWxUZXh0LmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZUZyb21HcmFwaGljKGN1cnJHcmFwaGljKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBzd2l0Y2ggKChfYSA9IGN1cnJHcmFwaGljID09PSBudWxsIHx8IGN1cnJHcmFwaGljID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyR3JhcGhpYy5nZW9tZXRyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInBvaW50XCI6XG4gICAgICAgICAgICBpZiAoKChfYiA9IGN1cnJHcmFwaGljID09PSBudWxsIHx8IGN1cnJHcmFwaGljID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyR3JhcGhpYy5zeW1ib2wpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZXh0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwb2ludFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwicG9seWxpbmVcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlsaW5lXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5Z29uXCI7XG4gICAgfVxufVxuXG5jb25zdCBzYXZlU25hcHBpbmdUb1N0b3JhZ2UgPSAoc25hcHBpbmdPcHRpb25zLCBjdXJyZW50U25hcHBpbmdTZXNzaW9uU3RvcmFnZUlkKSA9PiB7XG4gICAgLy8gZ2V0IGVuYWJsZWQgbGF5ZXJzIGFuZCBzYXZlIG9iamVjdCBpbiBzZXNzaW9uIHN0b3JhZ2VcbiAgICBjb25zdCBmZWF0dXJlU291cmNlc0lkcyA9IFtcbiAgICAgICAgLi4ubmV3IFNldChbLi4uc25hcHBpbmdPcHRpb25zLmZlYXR1cmVTb3VyY2VzLmZpbHRlcigoc291cmNlKSA9PiBzb3VyY2UuZW5hYmxlZCkubWFwKChzb3VyY2UpID0+IHNvdXJjZS5sYXllci5pZCldKVxuICAgIF07XG4gICAgY29uc3Qgc25hcHBpbmdPYmplY3QgPSB7XG4gICAgICAgIGVuYWJsZWQ6IHNuYXBwaW5nT3B0aW9ucy5lbmFibGVkLFxuICAgICAgICBzZWxmRW5hYmxlZDogc25hcHBpbmdPcHRpb25zLnNlbGZFbmFibGVkLFxuICAgICAgICBmZWF0dXJlRW5hYmxlZDogc25hcHBpbmdPcHRpb25zLmZlYXR1cmVFbmFibGVkLFxuICAgICAgICBmZWF0dXJlU291cmNlc0lkczogZmVhdHVyZVNvdXJjZXNJZHNcbiAgICB9O1xuICAgIHNldFNlc3Npb25TdG9yYWdlSXRlbShjdXJyZW50U25hcHBpbmdTZXNzaW9uU3RvcmFnZUlkLCBzbmFwcGluZ09iamVjdCwgdHJ1ZSk7XG59O1xuY29uc3QgZ2V0U25hcHBpbmdPcHRpb25zID0gKHNuYXBwaW5nU2Vzc2lvblN0b3JhZ2VJZHMsIGxheWVyLCBtYXBWaWV3LCBTbmFwcGluZ09wdGlvbnMpID0+IHtcbiAgICBjb25zdCBzbmFwcGluZyA9IGdldFNuYXBwaW5nRnJvbVN0b3JhZ2Uoc25hcHBpbmdTZXNzaW9uU3RvcmFnZUlkcykgfHwge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBzZWxmRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZmVhdHVyZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGZlYXR1cmVTb3VyY2VzSWRzOiBbbGF5ZXIuaWRdXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFNuYXBwaW5nT3B0aW9ucyh7XG4gICAgICAgIGVuYWJsZWQ6IHNuYXBwaW5nLmVuYWJsZWQsXG4gICAgICAgIHNlbGZFbmFibGVkOiBzbmFwcGluZy5zZWxmRW5hYmxlZCxcbiAgICAgICAgZmVhdHVyZUVuYWJsZWQ6IHNuYXBwaW5nLmZlYXR1cmVFbmFibGVkLFxuICAgICAgICBmZWF0dXJlU291cmNlczogZ2V0RmVhdHVyZVNvdXJjZXNGcm9tTGF5ZXJJZHMobWFwVmlldywgc25hcHBpbmcuZmVhdHVyZVNvdXJjZXNJZHMpXG4gICAgfSk7XG59O1xuY29uc3QgZ2V0RmVhdHVyZVNvdXJjZXNGcm9tTGF5ZXJJZHMgPSAobWFwVmlldywgbGF5ZXJJZHMpID0+IHtcbiAgICBjb25zdCBmZWF0dXJlU291cmNlcyA9IFtdO1xuICAgIGxheWVySWRzLmZvckVhY2goKGxheWVySWQpID0+IHtcbiAgICAgICAgbWFwVmlldy5tYXAuYWxsTGF5ZXJzLnRvQXJyYXkoKS5maW5kKChsYXllcikgPT4ge1xuICAgICAgICAgICAgaWYgKChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIudHlwZSkgPT09IFwibWFwLW5vdGVzXCIgJiYgbGF5ZXIuaWQgPT09IGxheWVySWQpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlU291cmNlcy5wdXNoKHsgbGF5ZXIsIGVuYWJsZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmZWF0dXJlU291cmNlcztcbn07XG5jb25zdCBnZXRTbmFwcGluZ0Zyb21TdG9yYWdlID0gKHNuYXBwaW5nU2Vzc2lvblN0b3JhZ2VJZHMpID0+IHtcbiAgICBpZiAoc25hcHBpbmdTZXNzaW9uU3RvcmFnZUlkcykge1xuICAgICAgICByZXR1cm4gKGdldFNlc3Npb25TdG9yYWdlSXRlbShzbmFwcGluZ1Nlc3Npb25TdG9yYWdlSWRzLndlYm1hcCwgdHJ1ZSkgfHxcbiAgICAgICAgICAgIGdldFNlc3Npb25TdG9yYWdlSXRlbShzbmFwcGluZ1Nlc3Npb25TdG9yYWdlSWRzLmN1cnJlbnQsIHRydWUpIHx8XG4gICAgICAgICAgICBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBhcmNnaXNTa2V0Y2hGZWF0dXJlc0NzcyA9IFwiLmFjdGlvbnMtc3RhcnQtcGFkZGluZ3twYWRkaW5nOjhweH1cIjtcblxuY29uc3QgQXJjZ2lzU2tldGNoRmVhdHVyZXMgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc1NrZXRjaEZlYXR1cmVzQWRkU2tldGNoID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNTa2V0Y2hGZWF0dXJlc0FkZFNrZXRjaFwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNTa2V0Y2hGZWF0dXJlc0VkaXRGZWF0dXJlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNTa2V0Y2hGZWF0dXJlc0VkaXRGZWF0dXJlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc1NrZXRjaEZlYXR1cmVzRWRpdE11bHRpcGxlRmVhdHVyZXMgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1NrZXRjaEZlYXR1cmVzRWRpdE11bHRpcGxlRmVhdHVyZXNcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzU2tldGNoRmVhdHVyZXNBZGRUb05ld1NrZXRjaCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU2tldGNoRmVhdHVyZXNBZGRUb05ld1NrZXRjaFwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNTa2V0Y2hGZWF0dXJlc1VwZGF0ZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1NrZXRjaEZlYXR1cmVzVXBkYXRlZFwiLCA3KTtcbiAgICAgICAgdGhpcy5ncmFwaGljQ2hhbmdlID0gW107XG4gICAgICAgIHRoaXMuZ3JhcGhpY1VwZGF0ZSA9IFtdO1xuICAgICAgICB0aGlzLmNoZWNrYm94Tm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEdyYXBoaWNzID0gW107XG4gICAgICAgIHRoaXMuZHVwbGljYXRlZEdyYXBoaWNJbmRpY2VzID0gW107XG4gICAgICAgIHRoaXMuY2hlY2tib3hVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5udW1iZXJPZkFjdGl2ZVNWTXMgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRseVJlbmRlcmluZ1N5bWJvbFByZXZpZXdzID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25HcmFwaGljVXBkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrYm94Tm9kZXMgPSB0aGlzLmNoZWNrYm94Tm9kZXMuc2xpY2UoMCwgdGhpcy5ncmFwaGljcy5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja2JveFVwZGF0ZSB8fCB0aGlzLm51bWJlck9mQWN0aXZlU1ZNcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrYm94Tm9kZXMuZm9yRWFjaCgoXywgaWR4KSA9PiAodGhpcy5jaGVja2JveE5vZGVzW2lkeF0uY2hlY2tlZCA9IGlzRGVmaW5lZCh0aGlzLnNlbGVjdGVkR3JhcGhpY3MuZmluZCgoc2VsZWN0ZWRHcmFwaGljKSA9PiBzZWxlY3RlZEdyYXBoaWMuaW5kZXggPT09IGlkeCkpKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tib3hVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5udW1iZXJPZkFjdGl2ZVNWTXMgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR3JhcGhpY3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5mb3JFYWNoKChncmFwaGljLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGdyYXBoaWMudG9KU09OKCkpID09PSBKU09OLnN0cmluZ2lmeShldmVudC5ncmFwaGljc1swXS50b0pTT04oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdyYXBoaWNzLnB1c2goeyBpbmRleCwgZ3JhcGhpYyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrYm94Tm9kZXNbaW5kZXhdLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQWN0aW9uc1BvcG92ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tib3hOb2Rlc1tpbmRleF0uY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQuc3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzU2tldGNoRmVhdHVyZXNVcGRhdGVkLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5waWNrTGlzdEl0ZW0gPSAoZ3JhcGhpYywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtbGlzdC1pdGVtXCIsIHsgbGFiZWw6ICgoX2EgPSBncmFwaGljID09PSBudWxsIHx8IGdyYXBoaWMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyYXBoaWMuYXR0cmlidXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRpdGxlKSB8fCB0aGlzLmdldFN0cmluZ0Zyb21UeXBlKGdyYXBoaWMpIH0sIGgoXCJkaXZcIiwgeyBzbG90OiBcImFjdGlvbnMtc3RhcnRcIiwgY2xhc3M6IFwiYWN0aW9ucy1zdGFydC1wYWRkaW5nXCIgfSwgaChcImNhbGNpdGUtY2hlY2tib3hcIiwgeyByZWY6IChub2RlKSA9PiB0aGlzLmNoZWNrYm94Tm9kZXMucHVzaChub2RlKSwgc2NhbGU6IFwibFwiLCBvbkNhbGNpdGVDaGVja2JveENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2JveFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR3JhcGhpY3MucHVzaCh7IGluZGV4LCBncmFwaGljIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdyYXBoaWNzID0gdGhpcy5zZWxlY3RlZEdyYXBoaWNzLmZpbHRlcigoc2VsZWN0ZWRHcmFwaGljKSA9PiBzZWxlY3RlZEdyYXBoaWMuaW5kZXggIT09IGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEdyYXBoaWNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBY3Rpb25zUG9wb3ZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zUG9wb3Zlck5vZGUuc2VsZWN0ZWRHcmFwaGljcyA9IHRoaXMuc2VsZWN0ZWRHcmFwaGljcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuYWN0aW9uc1BvcG92ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aW9uc1BvcG92ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcFBvaW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wTGluZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcFBvbHlnb24gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBUZXh0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHcmFwaGljcy5mb3JFYWNoKChzZWxlY3RlZEdyYXBoaWMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZ2V0R2VvbWV0cnlUeXBlRnJvbUdyYXBoaWMoc2VsZWN0ZWRHcmFwaGljLmdyYXBoaWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBvbHlsaW5lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBMaW5lID0gWy4uLnRlbXBMaW5lLCBzZWxlY3RlZEdyYXBoaWMuZ3JhcGhpY107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBQb2x5Z29uID0gWy4uLnRlbXBQb2x5Z29uLCBzZWxlY3RlZEdyYXBoaWMuZ3JhcGhpY107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBUZXh0ID0gWy4uLnRlbXBUZXh0LCBzZWxlY3RlZEdyYXBoaWMuZ3JhcGhpY107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBQb2ludCA9IFsuLi50ZW1wUG9pbnQsIHNlbGVjdGVkR3JhcGhpYy5ncmFwaGljXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncmFwaGljQXJyYXlzID0gW3RlbXBQb2ludCwgdGVtcExpbmUsIHRlbXBQb2x5Z29uLCB0ZW1wVGV4dF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVNWTXMgPSBncmFwaGljQXJyYXlzLmZpbHRlcigoZ3JhcGhpY0FycmF5KSA9PiBncmFwaGljQXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5udW1iZXJPZkFjdGl2ZVNWTXMgPSBhY3RpdmVTVk1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2JveFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBQb2ludC5sZW5ndGggPyB0aGlzLnN2TW9kZWwudXBkYXRlUG9pbnQodGVtcFBvaW50KSA6IHRoaXMuc3ZNb2RlbC5jYW5jZWxQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wTGluZS5sZW5ndGggPyB0aGlzLnN2TW9kZWwudXBkYXRlTGluZSh0ZW1wTGluZSkgOiB0aGlzLnN2TW9kZWwuY2FuY2VsTGluZSgpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wUG9seWdvbi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5zdk1vZGVsLnVwZGF0ZVBvbHlnb24odGVtcFBvbHlnb24pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuc3ZNb2RlbC5jYW5jZWxQb2x5Z29uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBUZXh0Lmxlbmd0aCA/IHRoaXMuc3ZNb2RlbC51cGRhdGVUZXh0KHRlbXBUZXh0KSA6IHRoaXMuc3ZNb2RlbC5jYW5jZWxUZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2F0Y2hGb3JHcmFwaGljU2VsZWN0aW9uT25DbGljaygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRHcmFwaGljcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ZNb2RlbC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tYmluZU1hcE5vdGVzR3JhcGhpY3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tib3hVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZBY3RpdmVTVk1zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gfSkpLCBoKFwiZGl2XCIsIHsgc2xvdDogXCJjb250ZW50LXN0YXJ0XCIsIGlkOiBgaW1hZ2UtJHtpbmRleH1gIH0pLCB0aGlzLnNob3dFZGl0RmVhdHVyZSA/IChoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBzbG90OiBcImFjdGlvbnMtZW5kXCIsIHRleHQ6IHRoaXMuc3RyaW5ncy5lZGl0LCB0aXRsZTogdGhpcy5zdHJpbmdzLmVkaXQsIHNjYWxlOiBcInNcIiwgaWNvbjogXCJwZW5jaWxcIiwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR3JhcGhpY3MucHVzaCh7IGluZGV4LCBncmFwaGljIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc1NrZXRjaEZlYXR1cmVzRWRpdEZlYXR1cmUuZW1pdCh7IGxheWVyOiB0aGlzLmxheWVyLCBmZWF0dXJlOiBncmFwaGljIH0pO1xuICAgICAgICAgICAgICAgIH0gfSkpIDogbnVsbCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxheWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1hcFZpZXcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2hvd0FkZFNrZXRjaCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hvd0VkaXRGZWF0dXJlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zbmFwcGluZ1Nlc3Npb25TdG9yYWdlSWRzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmdyYXBoaWNzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBza2V0Y2hVcGRhdGVkSGFuZGxlcihldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICBbdGhpcy5zdHJpbmdzXSA9IGF3YWl0IGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3ModGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZEFsbE1vZHVsZXMoKTtcbiAgICAgICAgdGhpcy5zbmFwcGluZ09wdGlvbnMgPSBnZXRTbmFwcGluZ09wdGlvbnModGhpcy5zbmFwcGluZ1Nlc3Npb25TdG9yYWdlSWRzLCB0aGlzLmxheWVyLCB0aGlzLm1hcFZpZXcsIHRoaXMuU25hcHBpbmdPcHRpb25zKTtcbiAgICAgICAgdGhpcy5zdk1vZGVsID0gbmV3IHN2TW9kZWwodGhpcy5sYXllciwgdGhpcy5tYXBWaWV3LCB0aGlzLlNrZXRjaFZpZXdNb2RlbCwgdGhpcy5zbmFwcGluZ09wdGlvbnMsIHRoaXMub25HcmFwaGljVXBkYXRlKTtcbiAgICAgICAgdGhpcy5jb21iaW5lTWFwTm90ZXNHcmFwaGljcygpO1xuICAgICAgICBza2V0Y2hGZWF0dXJlc1N0YXRlLnN0cmluZ3MgPSB0aGlzLnN0cmluZ3M7XG4gICAgICAgIHNrZXRjaEZlYXR1cmVzU3RhdGUuc25hcHBpbmdPcHRpb25zID0gdGhpcy5zbmFwcGluZ09wdGlvbnM7XG4gICAgICAgIHNrZXRjaEZlYXR1cmVzU3RhdGUuc25hcHBpbmdTZXNzaW9uU3RvcmFnZUlkcyA9IHRoaXMuc25hcHBpbmdTZXNzaW9uU3RvcmFnZUlkcztcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgdGhpcy53YXRjaEZvckNoYW5nZXNUb01hcE5vdGVzTGF5ZXIoKTtcbiAgICAgICAgdGhpcy53YXRjaEZvckdyYXBoaWNTZWxlY3Rpb25PbkNsaWNrKCk7XG4gICAgfVxuICAgIGFzeW5jIGNvbXBvbmVudERpZFJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIC8vIHByZXZpZXcgZWFjaCBncmFwaGljXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRseVJlbmRlcmluZ1N5bWJvbFByZXZpZXdzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50bHlSZW5kZXJpbmdTeW1ib2xQcmV2aWV3cyA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5ncmFwaGljcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyckVsZW1lbnQgPSB0aGlzLmhvc3RFbGVtZW50LnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoYGltYWdlLSR7eH1gKTtcbiAgICAgICAgICAgIGN1cnJFbGVtZW50LnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3ltYm9sVXRpbHMucmVuZGVyUHJldmlld0hUTUwodGhpcy5ncmFwaGljc1t4XS5zeW1ib2wsIE9iamVjdC5hc3NpZ24oeyBub2RlOiBjdXJyRWxlbWVudCwgc2NhbGU6IHRydWUsIG1heFNpemU6IDIwLCBzaXplOiB7IHdpZHRoOiAyMCwgaGVpZ2h0OiB0aGlzLmdyYXBoaWNzW3hdLmdlb21ldHJ5LnR5cGUgPT09IFwicG9seWxpbmVcIiA/IDYgOiAyMCB9IH0sICgoKF9hID0gdGhpcy5ncmFwaGljc1t4XS5zeW1ib2wpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJ0ZXh0XCIgJiYge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlVGV4dDogKChfYyA9IChfYiA9IHRoaXMuZ3JhcGhpY3NbeF0uc3ltYm9sKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGV4dCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jWzBdKSB8fCB0aGlzLnN0cmluZ3MudGV4dFByZXZpZXdcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50bHlSZW5kZXJpbmdTeW1ib2xQcmV2aWV3cyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmR1cGxpY2F0ZWRHcmFwaGljSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tib3hOb2Rlcy5mb3JFYWNoKChfLCBpZHgpID0+ICh0aGlzLmNoZWNrYm94Tm9kZXNbaWR4XS5jaGVja2VkID0gdGhpcy5kdXBsaWNhdGVkR3JhcGhpY0luZGljZXMuaW5jbHVkZXMoaWR4KSkpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdyYXBoaWNzID0gW107XG4gICAgICAgICAgICB0aGlzLmNoZWNrYm94Tm9kZXMuZm9yRWFjaCgoY2hlY2tib3hOb2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja2JveE5vZGUuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR3JhcGhpY3MucHVzaCh7IGluZGV4LCBncmFwaGljOiB0aGlzLmdyYXBoaWNzW2luZGV4XSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZHVwbGljYXRlZEdyYXBoaWNJbmRpY2VzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5ncmFwaGljQ2hhbmdlLmZvckVhY2goKGN1cnJlbnRIYW5kbGUpID0+IGN1cnJlbnRIYW5kbGUgPT09IG51bGwgfHwgY3VycmVudEhhbmRsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEhhbmRsZS5yZW1vdmUoKSk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY1VwZGF0ZS5mb3JFYWNoKChjdXJyZW50SGFuZGxlKSA9PiBjdXJyZW50SGFuZGxlID09PSBudWxsIHx8IGN1cnJlbnRIYW5kbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRIYW5kbGUucmVtb3ZlKCkpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0QWxsR3JhcGhpY3MoKTtcbiAgICAgICAgKF9hID0gdGhpcy5oaXRUZXN0SGFuZGxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuaGl0VGVzdEhhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdk1vZGVsLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnN2TW9kZWwuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gUHVibGljIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZU5vZGUuc2V0Rm9jdXMoKTtcbiAgICB9XG4gICAgLy8gUHVibGljIE1ldGhvZHNcbiAgICBhc3luYyBkb25lKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnNuYXBwaW5nU2Vzc2lvblN0b3JhZ2VJZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50KSB7XG4gICAgICAgICAgICBzYXZlU25hcHBpbmdUb1N0b3JhZ2UodGhpcy5zbmFwcGluZ09wdGlvbnMsIHRoaXMuc25hcHBpbmdTZXNzaW9uU3RvcmFnZUlkcy5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN2TW9kZWwuZGVzdHJveSgpO1xuICAgICAgICAvLyBlbmFibGUgcG9wdXAgaW4gdGhlIG1hcCB2aWV3XG4gICAgICAgIHRoaXMubWFwVmlldy5wb3B1cEVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gUHJpdmF0ZSBNZXRob2RzXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGxvYWRBbGxNb2R1bGVzKCkge1xuICAgICAgICBbdGhpcy5yZWFjdGl2ZVV0aWxzLCB0aGlzLnN5bWJvbFV0aWxzLCB0aGlzLlNrZXRjaFZpZXdNb2RlbCwgdGhpcy5TbmFwcGluZ09wdGlvbnNdID1cbiAgICAgICAgICAgIGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgICAgICAgICBcImVzcmkvY29yZS9yZWFjdGl2ZVV0aWxzXCIsXG4gICAgICAgICAgICAgICAgXCJlc3JpL3N5bWJvbHMvc3VwcG9ydC9zeW1ib2xVdGlsc1wiLFxuICAgICAgICAgICAgICAgIFwiZXNyaS93aWRnZXRzL1NrZXRjaC9Ta2V0Y2hWaWV3TW9kZWxcIixcbiAgICAgICAgICAgICAgICBcImVzcmkvdmlld3MvaW50ZXJhY3RpdmUvc25hcHBpbmcvU25hcHBpbmdPcHRpb25zXCJcbiAgICAgICAgICAgIF0pO1xuICAgIH1cbiAgICB3YXRjaEZvckNoYW5nZXNUb01hcE5vdGVzTGF5ZXIoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3VibGF5ZXIgb2YgW1xuICAgICAgICAgICAgdGhpcy5sYXllci5wb2ludExheWVyLFxuICAgICAgICAgICAgdGhpcy5sYXllci5wb2x5bGluZUxheWVyLFxuICAgICAgICAgICAgdGhpcy5sYXllci5wb2x5Z29uTGF5ZXIsXG4gICAgICAgICAgICB0aGlzLmxheWVyLnRleHRMYXllclxuICAgICAgICBdKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyR3JhcGhpY3NDaGFuZ2UgPSB0aGlzLnJlYWN0aXZlVXRpbHMub24oKCkgPT4gc3VibGF5ZXIuZ3JhcGhpY3MsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tib3hVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21iaW5lTWFwTm90ZXNHcmFwaGljcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljQ2hhbmdlLnB1c2goY3VyckdyYXBoaWNzQ2hhbmdlKTtcbiAgICAgICAgICAgIC8vIGNoYW5nZXMgb24gY2xvbmVcbiAgICAgICAgICAgIGNvbnN0IGN1cnJHcmFwaGljc1VwZGF0ZSA9IHRoaXMucmVhY3RpdmVVdGlscy5vbigoKSA9PiBzdWJsYXllciwgXCJncmFwaGljLXVwZGF0ZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoKGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC5wcm9wZXJ0eSkgIT09IFwiZ2VvbWV0cnlcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbWJpbmVNYXBOb3Rlc0dyYXBoaWNzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNVcGRhdGUucHVzaChjdXJyR3JhcGhpY3NVcGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbWJpbmVNYXBOb3Rlc0dyYXBoaWNzKCkge1xuICAgICAgICB0aGlzLmdyYXBoaWNzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5sYXllci5wb2ludExheWVyLmdyYXBoaWNzLFxuICAgICAgICAgICAgLi4udGhpcy5sYXllci5wb2x5bGluZUxheWVyLmdyYXBoaWNzLFxuICAgICAgICAgICAgLi4udGhpcy5sYXllci5wb2x5Z29uTGF5ZXIuZ3JhcGhpY3MsXG4gICAgICAgICAgICAuLi50aGlzLmxheWVyLnRleHRMYXllci5ncmFwaGljc1xuICAgICAgICBdO1xuICAgIH1cbiAgICBnZXRTdHJpbmdGcm9tVHlwZShjdXJyR3JhcGhpYykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzd2l0Y2ggKChfYSA9IGN1cnJHcmFwaGljID09PSBudWxsIHx8IGN1cnJHcmFwaGljID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyR3JhcGhpYy5nZW9tZXRyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICAgICAgICAgIGlmICgoKF9iID0gY3VyckdyYXBoaWMgPT09IG51bGwgfHwgY3VyckdyYXBoaWMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJHcmFwaGljLnN5bWJvbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdzLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdzLnBvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJwb2x5bGluZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ3MubGluZTtcbiAgICAgICAgICAgIGNhc2UgXCJwb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5ncy5wb2x5Z29uO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdzLnBvaW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEFjdGlvbnNQb3BvdmVyKCkge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25zUG9wb3Zlck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uc1BvcG92ZXJOb2RlLnNldEZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zUG9wb3Zlck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXJjZ2lzLXNrZXRjaC1hY3Rpb25zLXBvcG92ZXJcIik7XG4gICAgICAgIHRoaXMuYWN0aW9uc1BvcG92ZXJOb2RlLnJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLmJsb2NrTm9kZTtcbiAgICAgICAgdGhpcy5hY3Rpb25zUG9wb3Zlck5vZGUuc2VsZWN0ZWRHcmFwaGljcyA9IHRoaXMuc2VsZWN0ZWRHcmFwaGljcztcbiAgICAgICAgdGhpcy5hY3Rpb25zUG9wb3Zlck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1NrZXRjaEFjdGlvbnNCdWxrRWRpdFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aW9uc1BvcG92ZXIoKTtcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3RBbGxHcmFwaGljcygpO1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBldmVudC5kZXRhaWwuZ3JhcGhpY3MubWFwKChzZWxlY3RlZEdyYXBoaWMpID0+IHNlbGVjdGVkR3JhcGhpYy5ncmFwaGljKTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzU2tldGNoRmVhdHVyZXNFZGl0TXVsdGlwbGVGZWF0dXJlcy5lbWl0KHsgZmVhdHVyZXMgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGlvbnNQb3BvdmVyTm9kZS5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU2tldGNoQWN0aW9uc0J1bGtEdXBsaWNhdGVcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdk1vZGVsLmR1cGxpY2F0ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb21iaW5lTWFwTm90ZXNHcmFwaGljcygpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlcyA9IHRoaXMuc2VsZWN0ZWRHcmFwaGljcy5tYXAoKHNlbGVjdGVkR3JhcGhpYykgPT4gc2VsZWN0ZWRHcmFwaGljLmdyYXBoaWMpO1xuICAgICAgICAgICAgdGhpcy5kdXBsaWNhdGVkR3JhcGhpY0luZGljZXMgPSBbXTtcbiAgICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZXMuZm9yRWFjaCgoc2VsZWN0ZWRGZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5mb3JFYWNoKChncmFwaGljLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZ3JhcGhpYy50b0pTT04oKSkgPT09IEpTT04uc3RyaW5naWZ5KHNlbGVjdGVkRmVhdHVyZS50b0pTT04oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5kdXBsaWNhdGVkR3JhcGhpY0luZGljZXMuaW5jbHVkZXMoaWR4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHVwbGljYXRlZEdyYXBoaWNJbmRpY2VzLnB1c2goaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3Rpb25zUG9wb3Zlck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1NrZXRjaEFjdGlvbnNBZGRUb05ld1NrZXRjaFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEZlYXR1cmVzID0gdGhpcy5zZWxlY3RlZEdyYXBoaWNzLm1hcCgoc2VsZWN0ZWRHcmFwaGljKSA9PiBzZWxlY3RlZEdyYXBoaWMuZ3JhcGhpYyk7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc1NrZXRjaEZlYXR1cmVzQWRkVG9OZXdTa2V0Y2guZW1pdCh7IGZlYXR1cmVzOiBzZWxlY3RlZEZlYXR1cmVzIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3Rpb25zUG9wb3Zlck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1NrZXRjaEFjdGlvbnNCdWxrRGVsZXRlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aW9uc1BvcG92ZXIoKTtcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3RBbGxHcmFwaGljcygpO1xuICAgICAgICAgICAgdGhpcy5zdk1vZGVsLmRlbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb21iaW5lTWFwTm90ZXNHcmFwaGljcygpO1xuICAgICAgICAgICAgdGhpcy5jaGVja2JveFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZkFjdGl2ZVNWTXMgPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3Rpb25zUG9wb3Zlck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1NrZXRjaEFjdGlvbnNQb3BvdmVyQ2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3Rpb25zUG9wb3ZlcigpO1xuICAgICAgICAgICAgdGhpcy5zdk1vZGVsLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy51bnNlbGVjdEFsbEdyYXBoaWNzKCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrYm94VXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mQWN0aXZlU1ZNcyA9IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYWN0aW9uc1BvcG92ZXJOb2RlKTtcbiAgICAgICAgdGhpcy5hY3Rpb25zUG9wb3Zlck5vZGUuc2V0Rm9jdXMoKTtcbiAgICB9XG4gICAgcmVtb3ZlQWN0aW9uc1BvcG92ZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuYWN0aW9uc1BvcG92ZXJOb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW92ZUNoaWxkKHRoaXMuYWN0aW9uc1BvcG92ZXJOb2RlKTtcbiAgICAgICAgdGhpcy5hY3Rpb25zUG9wb3Zlck5vZGUgPSBudWxsO1xuICAgIH1cbiAgICB1bnNlbGVjdEFsbEdyYXBoaWNzKGtlZXBBY3Rpb25zUG9wb3Zlcikge1xuICAgICAgICB0aGlzLnNlbGVjdGVkR3JhcGhpY3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaGVja2JveE5vZGVzLmZvckVhY2goKGNoZWNrYm94Tm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrYm94Tm9kZSkge1xuICAgICAgICAgICAgICAgIGNoZWNrYm94Tm9kZS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWtlZXBBY3Rpb25zUG9wb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3Rpb25zUG9wb3ZlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdFNpbmdsZUdyYXBoaWMoY3VyckdyYXBoaWMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzd2l0Y2ggKGN1cnJHcmFwaGljLmxheWVyKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMubGF5ZXIucG9pbnRMYXllcjpcbiAgICAgICAgICAgICAgICB0aGlzLnN2TW9kZWwudXBkYXRlUG9pbnQoW2N1cnJHcmFwaGljXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMubGF5ZXIudGV4dExheWVyOlxuICAgICAgICAgICAgICAgIHRoaXMuc3ZNb2RlbC51cGRhdGVUZXh0KFtjdXJyR3JhcGhpY10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLmxheWVyLnBvbHlsaW5lTGF5ZXI6XG4gICAgICAgICAgICAgICAgdGhpcy5zdk1vZGVsLnVwZGF0ZUxpbmUoW2N1cnJHcmFwaGljXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMubGF5ZXIucG9seWdvbkxheWVyOlxuICAgICAgICAgICAgICAgIHRoaXMuc3ZNb2RlbC51cGRhdGVQb2x5Z29uKFtjdXJyR3JhcGhpY10pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5ncmFwaGljcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGdyYXBoaWMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoZ3JhcGhpYy50b0pTT04oKSkgPT09IEpTT04uc3RyaW5naWZ5KGN1cnJHcmFwaGljLnRvSlNPTigpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyYXBoaWNBbHJlYWR5U2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkR3JhcGhpY3MuZmluZCgoc2VsZWN0ZWRHcmFwaGljKSA9PiBKU09OLnN0cmluZ2lmeShzZWxlY3RlZEdyYXBoaWMuZ3JhcGhpYy50b0pTT04oKSkgPT09XG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGN1cnJHcmFwaGljLnRvSlNPTigpKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFncmFwaGljQWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHcmFwaGljcy5wdXNoKHsgaW5kZXgsIGdyYXBoaWMgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tib3hOb2Rlc1tpbmRleF0uY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRBY3Rpb25zUG9wb3ZlcigpO1xuICAgIH1cbiAgICB3YXRjaEZvckdyYXBoaWNTZWxlY3Rpb25PbkNsaWNrKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuaGl0VGVzdEhhbmRsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmhpdFRlc3RIYW5kbGUgPSB0aGlzLm1hcFZpZXcub24oXCJjbGlja1wiLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGhpdFRlc3RSZXN1bHRzID0gYXdhaXQgdGhpcy5tYXBWaWV3LmhpdFRlc3QoZXZlbnQsIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB0aGlzLmxheWVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBoaXRUZXN0UmVzdWx0cy5yZXN1bHRzO1xuICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBbXCJwb2ludFwiLCBcInBvbHlsaW5lXCIsIFwicG9seWdvblwiXTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyLmluZGV4T2YoYS5ncmFwaGljLmdlb21ldHJ5LnR5cGUpIC0gb3JkZXIuaW5kZXhPZihiLmdyYXBoaWMuZ2VvbWV0cnkudHlwZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckdyYXBoaWMgPSByZXN1bHRzWzBdLmdyYXBoaWM7XG4gICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdEFsbEdyYXBoaWNzKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0U2luZ2xlR3JhcGhpYyhjdXJyR3JhcGhpYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNoZWNrYm94Tm9kZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChjaGVja2JveE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrYm94Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3hOb2RlLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aW9uc1BvcG92ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VsZWN0QWxsR3JhcGhpY3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN2TW9kZWwuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja2JveFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZBY3RpdmVTVk1zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBSZW5kZXIgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tib3hOb2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImNhbGNpdGUtYmxvY2tcIiwgeyByZWY6IChub2RlKSA9PiAodGhpcy5ibG9ja05vZGUgPSBub2RlKSwgaGVhZGluZzogdGhpcy5zdHJpbmdzLnNrZXRjaGVzLCBvcGVuOiB0aGlzLm9wZW4sIGNvbGxhcHNpYmxlOiB0cnVlLCBvbkNhbGNpdGVCbG9ja09wZW46ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEdyYXBoaWNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEFjdGlvbnNQb3BvdmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgb25DYWxjaXRlQmxvY2tDbG9zZTogKCkgPT4gdGhpcy5yZW1vdmVBY3Rpb25zUG9wb3ZlcigpIH0sIGgoXCJjYWxjaXRlLWxpc3RcIiwgbnVsbCwgdGhpcy5ncmFwaGljcy5tYXAoKGdyYXBoaWMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5waWNrTGlzdEl0ZW0oZ3JhcGhpYywgaW5kZXgpO1xuICAgICAgICB9KSksIHRoaXMuc2hvd0FkZFNrZXRjaCA/IChoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyByZWY6IChlbGVtZW50KSA9PiAodGhpcy5hZGRGZWF0dXJlTm9kZSA9IGVsZW1lbnQpLCBpY29uU3RhcnQ6IFwicGVuY2lsLW1hcmtcIiwgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCB3aWR0aDogXCJmdWxsXCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGlvbnNQb3BvdmVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdEFsbEdyYXBoaWNzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdk1vZGVsLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzU2tldGNoRmVhdHVyZXNBZGRTa2V0Y2guZW1pdCh7IGxheWVyOiB0aGlzLmxheWVyIH0pO1xuICAgICAgICAgICAgfSB9LCB0aGlzLnN0cmluZ3MuYWRkU2tldGNoKSkgOiBudWxsKSkpO1xuICAgIH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzU2tldGNoRmVhdHVyZXMuc3R5bGUgPSBhcmNnaXNTa2V0Y2hGZWF0dXJlc0NzcztcblxuZXhwb3J0IHsgQXJjZ2lzU2tldGNoQWN0aW9uc1BvcG92ZXIgYXMgYXJjZ2lzX3NrZXRjaF9hY3Rpb25zX3BvcG92ZXIsIEFyY2dpc1NrZXRjaEZlYXR1cmVzIGFzIGFyY2dpc19za2V0Y2hfZmVhdHVyZXMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJjZ2lzLXNrZXRjaC1hY3Rpb25zLXBvcG92ZXJfMi5lbnRyeS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCBkZWJvdW5jZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZW91dDtcbiAgICBsZXQgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgZnVuY3Rpb24gZmx1c2goLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImZsdXNoZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJpbnZva2VkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbCguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgY29uc3QgZGVib3VuY2VkID0gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmx1c2hlZFwiOlxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnZva2VkXCI6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICBkZWJvdW5jZWQuaW52b2tlID0gaW52b2tlO1xuICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgZGVib3VuY2VkLmdldFN0YXR1cyA9IGdldFN0YXR1cztcbiAgICByZXR1cm4gZGVib3VuY2VkO1xufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgbiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgdGhyb3R0bGUgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxuICogU2V0IGEgbWluaW11bSB0aW1lIGZvciBhIHByb21pc2UgdG8gcmVzb2x2ZSAodXNlZnVsIGZvciBwcmV2ZW50aW5nIGZsYXNoIG9mIGxvYWRlcnMpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1pbkRlbGF5KHByb21pc2UsIG1pbkRlbGF5KSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3Byb21pc2UsIHRpbWVvdXQobWluRGVsYXkpXSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gaW5saW5lIHNldFRpbWVvdXQgYXMgYW4gYXdhaXQgaW4gYXN5bmMgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbmNvbnN0IGFycmF5VG9Mb29rdXBNYXAgPSAoZGF0YUFyciwgZ2V0S2V5QW5kSXRlbSkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKChkYXRhQXJyIHx8IFtdKS5tYXAoKGl0ZW0pID0+IHtcbiAgICBjb25zdCB7IGtleSwgZGF0YSB9ID0gZ2V0S2V5QW5kSXRlbShpdGVtKTtcbiAgICByZXR1cm4gW2tleSwgZGF0YV07XG59KSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1xuICogYW5kIHdoZXRoZXIgdGhleSBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzXG4gKiByZWdhcmRsZXNzIG9mIG9yZGVyXG4gKi9cbmNvbnN0IGFycmF5c0FyZUVxdWl2YWxlbnQgPSAoYXJyMSwgYXJyMikgPT4gYXJyMS5sZW5ndGggPT09IGFycjIubGVuZ3RoICYmIGFycjEucmVkdWNlKChtZW1vLCBzdHIpID0+IG1lbW8gJiYgYXJyMi5pbmRleE9mKHN0cikgPiAtMSwgdHJ1ZSk7XG5mdW5jdGlvbiB1bmlxdWVCeShteUFyciwgZ2V0SXRlbUlkKSB7XG4gICAgY29uc3QgcmVzdWx0QXJyID0gW107XG4gICAgY29uc3QgbG9va3VwTWFwID0ge307XG4gICAgbXlBcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGdldEl0ZW1JZChpdGVtKTtcbiAgICAgICAgaWYgKGxvb2t1cE1hcFtpZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9va3VwTWFwW2lkXSA9IGl0ZW07XG4gICAgICAgICAgICByZXN1bHRBcnIucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRBcnI7XG59XG5mdW5jdGlvbiB1bmlxdWUobXlBcnIpIHtcbiAgICBjb25zdCBwcmltaXRpdmVzID0geyBib29sZWFuOiB7fSwgbnVtYmVyOiB7fSwgc3RyaW5nOiB7fSB9O1xuICAgIGNvbnN0IG9ianMgPSBbXTtcbiAgICByZXR1cm4gbXlBcnIuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZW9mIGl0ZW07XG4gICAgICAgIGlmICh0eXBlIGluIHByaW1pdGl2ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVzW3R5cGVdLmhhc093blByb3BlcnR5KGl0ZW0pID8gZmFsc2UgOiAocHJpbWl0aXZlc1t0eXBlXVtpdGVtXSA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9ianMuaW5kZXhPZihpdGVtKSA+PSAwID8gZmFsc2UgOiBvYmpzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGNodW5rID0gKGFyciwgc2l6ZSkgPT4gWy4uLkFycmF5KE1hdGguY2VpbChhcnIubGVuZ3RoIC8gc2l6ZSkpXS5tYXAoKF8sIGkpID0+IGFyci5zbGljZShzaXplICogaSwgc2l6ZSArIHNpemUgKiBpKSk7XG5cbmV4cG9ydCB7IGFycmF5VG9Mb29rdXBNYXAgYXMgYSwgdW5pcXVlIGFzIGIsIHRocm90dGxlIGFzIGMsIGRlYm91bmNlIGFzIGQsIGVzY2FwZVJlZ0V4cCBhcyBlLCBhcnJheXNBcmVFcXVpdmFsZW50IGFzIGYsIGNodW5rIGFzIGcsIGlzRGVmaW5lZCBhcyBpLCBtaW5EZWxheSBhcyBtLCB0aW1lb3V0IGFzIHQsIHVuaXF1ZUJ5IGFzIHUgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25hbC00NGRlOGZjZi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0UmVuZGVyaW5nUmVmLCBmIGFzIGZvcmNlVXBkYXRlIH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5cbmNvbnN0IGFwcGVuZFRvTWFwID0gKG1hcCwgcHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBtYXAuZ2V0KHByb3BOYW1lKTtcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgIG1hcC5zZXQocHJvcE5hbWUsIFt2YWx1ZV0pO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXRlbXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbn07XG5jb25zdCBkZWJvdW5jZSA9IChmbiwgbXMpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgfSwgbXMpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcG9zc2libGUgZWxlbWVudCBpc0Nvbm5lY3RlZC5cbiAqIFRoZSBwcm9wZXJ0eSBtaWdodCBub3QgYmUgdGhlcmUsIHNvIHdlIGNoZWNrIGZvciBpdC5cbiAqXG4gKiBXZSB3YW50IGl0IHRvIHJldHVybiB0cnVlIGlmIGlzQ29ubmVjdGVkIGlzIG5vdCBhIHByb3BlcnR5LFxuICogb3RoZXJ3aXNlIHdlIHdvdWxkIHJlbW92ZSB0aGVzZSBlbGVtZW50cyBhbmQgd291bGQgbm90IHVwZGF0ZS5cbiAqXG4gKiBCZXR0ZXIgbGVhayBpbiBFZGdlIHRoYW4gdG8gYmUgdXNlbGVzcy5cbiAqL1xuY29uc3QgaXNDb25uZWN0ZWQgPSAobWF5YmVFbGVtZW50KSA9PiAhKCdpc0Nvbm5lY3RlZCcgaW4gbWF5YmVFbGVtZW50KSB8fCBtYXliZUVsZW1lbnQuaXNDb25uZWN0ZWQ7XG5jb25zdCBjbGVhbnVwRWxlbWVudHMgPSBkZWJvdW5jZSgobWFwKSA9PiB7XG4gICAgZm9yIChsZXQga2V5IG9mIG1hcC5rZXlzKCkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcC5nZXQoa2V5KS5maWx0ZXIoaXNDb25uZWN0ZWQpKTtcbiAgICB9XG59LCAyMDAwKTtcbmNvbnN0IHN0ZW5jaWxTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnZXRSZW5kZXJpbmdSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBpbiBhIHN0ZW5jaWwgcHJvamVjdCwgd2UgZG8gbm90aGluZy5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IGV4cG9ydGVkIGJ5IEBzdGVuY2lsL2NvcmUuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZWxtc1RvVXBkYXRlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IGVsbXNUb1VwZGF0ZS5jbGVhcigpLFxuICAgICAgICBnZXQ6IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxtID0gZ2V0UmVuZGVyaW5nUmVmKCk7XG4gICAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kVG9NYXAoZWxtc1RvVXBkYXRlLCBwcm9wTmFtZSwgZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxtc1RvVXBkYXRlLmdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBlbG1zVG9VcGRhdGUuc2V0KHByb3BOYW1lLCBlbGVtZW50cy5maWx0ZXIoZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgZWxtc1RvVXBkYXRlLmZvckVhY2goKGVsbXMpID0+IGVsbXMuZm9yRWFjaChmb3JjZVVwZGF0ZSkpO1xuICAgICAgICAgICAgY2xlYW51cEVsZW1lbnRzKGVsbXNUb1VwZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IHVud3JhcCA9ICh2YWwpID0+ICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID8gdmFsKCkgOiB2YWwpO1xuY29uc3QgY3JlYXRlT2JzZXJ2YWJsZU1hcCA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSA9IChhLCBiKSA9PiBhICE9PSBiKSA9PiB7XG4gICAgY29uc3QgdW53cmFwcGVkU3RhdGUgPSB1bndyYXAoZGVmYXVsdFN0YXRlKTtcbiAgICBsZXQgc3RhdGVzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyh1bndyYXBwZWRTdGF0ZSAhPT0gbnVsbCAmJiB1bndyYXBwZWRTdGF0ZSAhPT0gdm9pZCAwID8gdW53cmFwcGVkU3RhdGUgOiB7fSkpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgICBkaXNwb3NlOiBbXSxcbiAgICAgICAgZ2V0OiBbXSxcbiAgICAgICAgc2V0OiBbXSxcbiAgICAgICAgcmVzZXQ6IFtdLFxuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gV2hlbiByZXNldHRpbmcgdGhlIHN0YXRlLCB0aGUgZGVmYXVsdCBzdGF0ZSBtYXkgYmUgYSBmdW5jdGlvbiAtIHVud3JhcCBpdCB0byBpbnZva2UgaXQuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIHN0YXRlIHdvbid0IGJlIHByb3Blcmx5IHJlc2V0XG4gICAgICAgIHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoKF9hID0gdW53cmFwKGRlZmF1bHRTdGF0ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KSk7XG4gICAgICAgIGhhbmRsZXJzLnJlc2V0LmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIENhbGwgZmlyc3QgZGlzcG9zZSBhcyByZXNldHRpbmcgdGhlIHN0YXRlIHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIGxlc3MgdXBkYXRlcyA7KVxuICAgICAgICBoYW5kbGVycy5kaXNwb3NlLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCA9IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICBoYW5kbGVycy5nZXQuZm9yRWFjaCgoY2IpID0+IGNiKHByb3BOYW1lKSk7XG4gICAgICAgIHJldHVybiBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldCA9IChwcm9wTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSh2YWx1ZSwgb2xkVmFsdWUsIHByb3BOYW1lKSkge1xuICAgICAgICAgICAgc3RhdGVzLnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSwgdmFsdWUsIG9sZFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN0YXRlID0gKHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB7fVxuICAgICAgICA6IG5ldyBQcm94eSh1bndyYXBwZWRTdGF0ZSwge1xuICAgICAgICAgICAgZ2V0KF8sIHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3duS2V5cyhfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGVzLmtleXMoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhcyhfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXMuaGFzKHByb3BOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoXywgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgY29uc3Qgb24gPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBoYW5kbGVyc1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGhhbmRsZXJzW2V2ZW50TmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKHByb3BOYW1lLCBjYikgPT4ge1xuICAgICAgICBjb25zdCB1blNldCA9IG9uKCdzZXQnLCAoa2V5LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVud3JhcCB0aGUgZGVmYXVsdFN0YXRlIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG1pZ2h0IG5vdCBiZSBzZW5kaW5nIHRoZSByaWdodCByZXNldCB2YWx1ZS5cbiAgICAgICAgY29uc3QgdW5SZXNldCA9IG9uKCdyZXNldCcsICgpID0+IGNiKHVud3JhcChkZWZhdWx0U3RhdGUpW3Byb3BOYW1lXSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdW5TZXQoKTtcbiAgICAgICAgICAgIHVuUmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZSA9ICguLi5zdWJzY3JpcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3VicyA9IHN1YnNjcmlwdGlvbnMucmVkdWNlKCh1bnN1YnMsIHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignc2V0Jywgc3Vic2NyaXB0aW9uLnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5nZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignZ2V0Jywgc3Vic2NyaXB0aW9uLmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5yZXNldCkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdyZXNldCcsIHN1YnNjcmlwdGlvbi5yZXNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5kaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2Rpc3Bvc2UnLCBzdWJzY3JpcHRpb24uZGlzcG9zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuc3VicztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5zdWJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHN0YXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihrZXksIG9sZFZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0LFxuICAgICAgICBvbixcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIHVzZSxcbiAgICAgICAgZGlzcG9zZSxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIGZvcmNlVXBkYXRlLFxuICAgIH07XG59O1xuY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gKGFycmF5LCBpdGVtKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBhcnJheS5sZW5ndGgtLTtcbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGNyZWF0ZU9ic2VydmFibGVNYXAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpO1xuICAgIG1hcC51c2Uoc3RlbmNpbFN1YnNjcmlwdGlvbigpKTtcbiAgICByZXR1cm4gbWFwO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUgYXMgYyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC0wNTk1NmNhYi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tNGQzNjc2NzcuanMnO1xuXG5jb25zdCBsYW5ndWFnZU1hcCA9IG5ldyBNYXAoW1xuICAgIFtcImFyXCIsIFwiYXJcIl0sXG4gICAgW1wiYmdcIiwgXCJiZ1wiXSxcbiAgICBbXCJic1wiLCBcImJzXCJdLFxuICAgIFtcImNhXCIsIFwiY2FcIl0sXG4gICAgW1wiY3NcIiwgXCJjc1wiXSxcbiAgICBbXCJkYVwiLCBcImRhXCJdLFxuICAgIFtcImRlXCIsIFwiZGVcIl0sXG4gICAgW1wiZWxcIiwgXCJlbFwiXSxcbiAgICBbXCJlblwiLCBcImVuXCJdLFxuICAgIFtcImVzXCIsIFwiZXNcIl0sXG4gICAgW1wiZXRcIiwgXCJldFwiXSxcbiAgICBbXCJmaVwiLCBcImZpXCJdLFxuICAgIFtcImZyXCIsIFwiZnJcIl0sXG4gICAgW1wiaGVcIiwgXCJoZVwiXSxcbiAgICBbXCJoclwiLCBcImhyXCJdLFxuICAgIFtcImh1XCIsIFwiaHVcIl0sXG4gICAgW1wiaWRcIiwgXCJpZFwiXSxcbiAgICBbXCJpdFwiLCBcIml0XCJdLFxuICAgIFtcImphXCIsIFwiamFcIl0sXG4gICAgW1wia29cIiwgXCJrb1wiXSxcbiAgICBbXCJsdFwiLCBcImx0XCJdLFxuICAgIFtcImx2XCIsIFwibHZcIl0sXG4gICAgW1wibmJcIiwgXCJuYlwiXSxcbiAgICBbXCJubFwiLCBcIm5sXCJdLFxuICAgIFtcInBsXCIsIFwicGxcIl0sXG4gICAgW1wicHQtYnJcIiwgXCJwdC1CUlwiXSxcbiAgICBbXCJwdC1wdFwiLCBcInB0LVBUXCJdLFxuICAgIFtcInJvXCIsIFwicm9cIl0sXG4gICAgW1wicnVcIiwgXCJydVwiXSxcbiAgICBbXCJza1wiLCBcInNrXCJdLFxuICAgIFtcInNsXCIsIFwic2xcIl0sXG4gICAgW1wic3JcIiwgXCJzclwiXSxcbiAgICBbXCJzdlwiLCBcInN2XCJdLFxuICAgIFtcInRoXCIsIFwidGhcIl0sXG4gICAgW1widHJcIiwgXCJ0clwiXSxcbiAgICBbXCJ1a1wiLCBcInVrXCJdLFxuICAgIFtcInZpXCIsIFwidmlcIl0sXG4gICAgW1wiemgtY25cIiwgXCJ6aC1DTlwiXSxcbiAgICBbXCJ6aC1oa1wiLCBcInpoLUhLXCJdLFxuICAgIFtcInpoLXR3XCIsIFwiemgtVFdcIl1cbl0pO1xuLy8gcnRsXG5mdW5jdGlvbiBnZXRFbGVtZW50RGlyKGVsKSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRQcm9wKGVsLCBcImRpclwiLCBcImx0clwiKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRQcm9wKGVsLCBwcm9wLCB2YWx1ZSkge1xuICAgIGNvbnN0IGNsb3Nlc3RXaXRoUHJvcCA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbCwgYFske3Byb3B9XWApO1xuICAgIHJldHVybiBjbG9zZXN0V2l0aFByb3AgPyBjbG9zZXN0V2l0aFByb3AuZ2V0QXR0cmlidXRlKHByb3ApIDogdmFsdWU7XG59XG4vLyBjc3NcbmNvbnN0IENTU19VVElMSVRZID0ge1xuICAgIHJ0bDogXCJhcmNnaXMtLXJ0bFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bWJlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXBpLCB0eXBlLCBwbGFjZXMgfSA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKGFwaSA9PT0gNCkge1xuICAgICAgICBjb25zdCBbaW50bF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2ludGxcIl0pO1xuICAgICAgICBjb25zdCBudW1iZXJGb3JtYXRJbnRsT3B0aW9ucyA9IGludGwuY29udmVydE51bWJlckZvcm1hdFRvSW50bE9wdGlvbnMoe1xuICAgICAgICAgICAgcGxhY2VzLFxuICAgICAgICAgICAgc3R5bGU6IHR5cGUsXG4gICAgICAgICAgICBkaWdpdFNlcGFyYXRvcjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGludGwuZm9ybWF0TnVtYmVyKG51bWJlciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBudW1iZXJGb3JtYXRJbnRsT3B0aW9ucyksIHsgc3R5bGU6IHR5cGUgfSkpO1xuICAgIH1cbiAgICBjb25zdCBbZG9qb051bWJlcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJkb2pvL251bWJlclwiXSk7XG4gICAgcmV0dXJuIGRvam9OdW1iZXIuZm9ybWF0KG51bWJlciwge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwbGFjZXMsXG4gICAgICAgIHBhdHRlcm46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXR0ZXJuXG4gICAgfSk7XG59XG5jb25zdCBjYWNoZSA9IHt9O1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gICAgY29uc3QgbGFuZyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nO1xuICAgIGNvbnN0IGRheVNob3J0TW9udGhZZWFyID0ge1xuICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgICAgbW9udGg6IFwic2hvcnRcIixcbiAgICAgICAgZGF5OiBcIm51bWVyaWNcIlxuICAgIH07XG4gICAgaWYgKCFjYWNoZVtsYW5nXSkge1xuICAgICAgICBjYWNoZVtsYW5nXSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nLCBkYXlTaG9ydE1vbnRoWWVhcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtsYW5nXS5mb3JtYXQoZGF0ZSk7XG59XG5mdW5jdGlvbiBmb3JtYXRQbHVyYWwobGFuZywgc3RyaW5nT2JqLCBudW1iZXIpIHtcbiAgICBjb25zdCBzaW5nbGVzID0gW1wiaWRcIiwgXCJqYVwiLCBcImtvXCIsIFwidGhcIiwgXCJ2aVwiLCBcInpoLWNuXCIsIFwiemgtaGtcIiwgXCJ6aC10d1wiXTtcbiAgICBjb25zdCBsaWtlRW5nbGlzaCA9IFtcbiAgICAgICAgXCJlblwiLFxuICAgICAgICBcImNhXCIsXG4gICAgICAgIFwiZGFcIixcbiAgICAgICAgXCJkZVwiLFxuICAgICAgICBcImVsXCIsXG4gICAgICAgIFwiZXNcIixcbiAgICAgICAgXCJldFwiLFxuICAgICAgICBcImZpXCIsXG4gICAgICAgIFwiaGlcIixcbiAgICAgICAgXCJodVwiLFxuICAgICAgICBcIml0XCIsXG4gICAgICAgIFwibmJcIixcbiAgICAgICAgXCJubFwiLFxuICAgICAgICBcInB0LXB0XCIsXG4gICAgICAgIFwic3ZcIixcbiAgICAgICAgXCJ0clwiXG4gICAgXTtcbiAgICBjb25zdCBsb2NhbGUgPSBsYW5nICE9PSBudWxsICYmIGxhbmcgIT09IHZvaWQgMCA/IGxhbmcgOiBcImVuXCI7XG4gICAgLy8gaWYgdGhlIG51bWJlciBpcyBvbmUsIG9yIGl0IGlzIGEgXCJzaW1wbGVcIiBsYW5ndWFnZSwgcmV0dXJuIHRoZSAxIHN0cmluZ1xuICAgIGlmIChudW1iZXIgPT09IDEgfHwgc2luZ2xlcy5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdPYmouc2luZ2xlLnJlcGxhY2UoXCIke251bWJlcn1cIiwgXCIxXCIpO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIG5vdCAxIGFuZCB0aGUgbGFuZ3VhZ2UgdXNlcyB0aGUgc2FtZSBwbHVyYWxpemF0aW9uIHN0cmF0ZWd5IGFzIGVuZ2xpc2gsXG4gICAgLy8gcmV0dXJuIHRoZSBtdWx0aXBsZSBzdHJpbmdcbiAgICBpZiAobnVtYmVyICE9PSAxICYmIGxpa2VFbmdsaXNoLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ09iai5tdWx0aXBsZS5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIGAke251bWJlcn1gKTtcbiAgICB9XG4gICAgLy8gaWYgbm9uZSBvZiB0aGUgYWJvdmUgd29ya2VkLCByZXR1cm4gdGhlIFwidW5rbm93blwiIHN0cmluZ1xuICAgIHJldHVybiBzdHJpbmdPYmoudW5rbm93bi5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIGAke251bWJlcn1gKTtcbn1cblxuZXhwb3J0IHsgQ1NTX1VUSUxJVFkgYXMgQywgZm9ybWF0RGF0ZSBhcyBhLCBmb3JtYXRQbHVyYWwgYXMgYiwgZm9ybWF0TnVtYmVyIGFzIGYsIGdldEVsZW1lbnREaXIgYXMgZywgbGFuZ3VhZ2VNYXAgYXMgbCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTRkMzY3Njc3LmpzJztcbmltcG9ydCB7IGwgYXMgbGFuZ3VhZ2VNYXAgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyc7XG5pbXBvcnQgeyBhIGFzIGdldEFzc2V0UGF0aCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuXG4vLyBodHRwczovL21lZGl1bS5jb20vc3RlbmNpbC10cmlja3MvaW1wbGVtZW50aW5nLWludGVybmF0aW9uYWxpc2F0aW9uLWkxOG4td2l0aC1zdGVuY2lsLTVlNjU1OTU1NDExN1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFwicnUtUlVcIiBtYXBzIHRvIFwicnVcIiB1c2UgY2FzZVxuICAgICAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcuc2xpY2UoMCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIC8vIGl0J3MgT0sgaWYgd2UgZG9uJ3QgaGF2ZSB0aGUgNCBsZXR0ZXIgbGFuZ3VhZ2UgZmlsZSBmb3IgaXRcbiAgICAvLyA0IGxldHRlciBsYW5ndWFnZSBjb2RlIG5lZWRlZCBmb3IgZm9ybWF0dGluZyBudW1iZXJzXG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAgICAgICAvLyB3ZSBzdXBwb3J0IHRoZSAyIGxldHRlciBjb2RlZCBsYW5ndWFnZVxuICAgICAgICAgICAgLy8gZS5nLiBpdC1DSCB2cyBpdFxuICAgICAgICAgICAgcmV0dXJuIGxhbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlblwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZldGNoKGdldEFzc2V0UGF0aChgLi4vYXJjZ2lzLWFwcC1hc3NldHMvaTE4bi8ke2NvbXBvbmVudE5hbWV9LmkxOG4uJHtsb2NhbGV9Lmpzb25gKSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm9rKVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0Lmpzb24oKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0sICgpID0+IHJlamVjdCgpKTtcbiAgICB9KTtcbn1cbmNvbnN0IHN0cmluZ0NhY2hlID0ge307XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gICAgY29uc3QgaWQgPSBgJHtjb21wb25lbnROYW1lfSR7bG9jYWxlfWA7XG4gICAgaWYgKCFzdHJpbmdDYWNoZVtpZF0pIHtcbiAgICAgICAgc3RyaW5nQ2FjaGVbaWRdID0gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdDYWNoZVtpZF07XG59XG4vKipcbiAqIEdldCBzdHJpbmdzIGFuZCBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgMiBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoZSBmaXJzdCBvbmUgcmV0dXJucyBhIGNvZGUgdGhhdCdzIGFsc28gc3VwcG9ydGVkIGFzIGEgbGFuZ3VhZ2UgZmlsZS5cbiAqIFRoZSBzZWNvbmQgb25lIHJldHVybnMgYSBjb2RlIHdoZXJlIHRoZXJlIGlzIHN1cHBvcnQgZm9yIHRoZSBmaXJzdCAyIGxldHRlcnMgb2YgdGhlIGNvZGUgYXMgcGFydCBvZiBhIGxhbmd1YWdlIGZpbGUsXG4gKiBidXQgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIDQgbGV0dGVyIGNvZGUgZnJvbSB0aGUgcGFnZS5cbiAqIEUuZy4gRm9yIFwiaXQtY2hcIiBpdCB3aWxsIHJldHVybiBcIml0XCIgYXMgdGhlIGZpcnN0IGxhbmd1YWdlIGNvZGUgYW5kIFwiaXQtY2hcIiBhcyB0aGUgc2Vjb25kLlxuICogVGhlIHNlY29uZCBvbmUgaXMgcmVxdWlyZWQgZm9yIGVzcmkuaW50bC5zZXRMb2NhbGUoKSB0byBnZXQgdGhlIGNvcnJlY3QgZm9ybWF0dGluZy5cbiAqXG4gKiBJZiBhIHRhZ05hbWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBvdmVyd2l0ZSB0aGUgZWxlbWVudCdzIHRhZ05hbWVcbiAqXG4gKiAgQHJldHVybiBbIHN0cmluZ3MsIGZpcnN0IGxhbmd1YWdlIGNvZGUsIHNlY29uZCBsYW5ndWFnZSBjb2RlXVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKGVsZW1lbnQsIHRhZ05hbWUpIHtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gdGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjb21wb25lbnRMYW5ndWFnZSA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KTtcbiAgICBjb25zdCBjb21wb25lbnRMYW5ndWFnZUludGwgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpO1xuICAgIGxldCBzdHJpbmdzO1xuICAgIHRyeSB7XG4gICAgICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgY29tcG9uZW50TGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYG5vIGxvY2FsZSBmb3IgJHtjb21wb25lbnROYW1lfSAoJHtjb21wb25lbnRMYW5ndWFnZX0pIGxvYWRpbmcgZGVmYXVsdCBsb2NhbGUgZW4uYCk7XG4gICAgICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgXCJlblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHJpbmdzLCBjb21wb25lbnRMYW5ndWFnZSwgY29tcG9uZW50TGFuZ3VhZ2VJbnRsXTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlIGFzIGEsIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgYXMgZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGUtMDUwYjZkYjkuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBlIGFzIGVzY2FwZVJlZ0V4cCB9IGZyb20gJy4vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyc7XG5cbi8vIGltcG9ydCBzdHJpbmdVdGlsIGZyb20gXCIuL3N0cmluZ3NcIjtcbi8qKlxuICogVXRpbGl0eSBtZXRob2RzIGZvciBkZWFsaW5nIHdpdGggc3RvcmFnZSBvZiB2YXJpb3VzIGZvcm1zIChjb29raWVzLCBsb2NhbCBzdG9yYWdlLCBhbmQgc2Vzc2lvbiBzdG9yYWdlKS5cbiAqL1xuZnVuY3Rpb24gc2V0Q29va2llKG5hbWUsIGNvb2tpZSwgcHJvcGVydGllcywgc3RyaW5naWZ5KSB7XG4gICAgd3JpdGVDb29raWUobmFtZSwgc3RyaW5naWZ5ID8gSlNPTi5zdHJpbmdpZnkoY29va2llKSA6IGNvb2tpZSwgcHJvcGVydGllcyk7XG59XG5mdW5jdGlvbiBnZXRDb29raWUobmFtZSwgcGFyc2UpIHtcbiAgICBjb25zdCBjb29raWUgPSByZWFkQ29va2llKG5hbWUpO1xuICAgIHJldHVybiBjb29raWUgJiYgcGFyc2UgPyBKU09OLnBhcnNlKGNvb2tpZSkgOiBjb29raWU7XG59XG5mdW5jdGlvbiBzZXRMb2NhbFN0b3JhZ2VJdGVtKG5hbWUsIGl0ZW0sIHN0cmluZ2lmeSkge1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCBzdHJpbmdpZnkgPyBKU09OLnN0cmluZ2lmeShpdGVtKSA6IGl0ZW0pO1xufVxuZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlSXRlbShuYW1lLCBwYXJzZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgcmV0dXJuIGl0ZW0gJiYgcGFyc2UgPyBKU09OLnBhcnNlKGl0ZW0pIDogaXRlbTtcbn1cbmZ1bmN0aW9uIHNldFNlc3Npb25TdG9yYWdlSXRlbShuYW1lLCBpdGVtLCBzdHJpbmdpZnkpIHtcbiAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShuYW1lLCBzdHJpbmdpZnkgPyBKU09OLnN0cmluZ2lmeShpdGVtKSA6IGl0ZW0pO1xufVxuZnVuY3Rpb24gZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtKG5hbWUsIHBhcnNlKSB7XG4gICAgY29uc3QgaXRlbSA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICAgIHJldHVybiBpdGVtICYmIHBhcnNlID8gSlNPTi5wYXJzZShpdGVtKSA6IGl0ZW07XG59XG5mdW5jdGlvbiByZWFkQ29va2llKG5hbWUpIHtcbiAgICBjb25zdCBjb29raWUgPSBkb2N1bWVudC5jb29raWU7XG4gICAgY29uc3QgY29va2llTmFtZVJFID0gbmV3IFJlZ0V4cChgKD86Xnw7ICkke2VzY2FwZVJlZ0V4cChuYW1lKX09KFteO10qKWApO1xuICAgIGNvbnN0IG1hdGNoZWRDb29raWVzID0gY29va2llLm1hdGNoKGNvb2tpZU5hbWVSRSk7XG4gICAgcmV0dXJuIG1hdGNoZWRDb29raWVzID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoZWRDb29raWVzWzFdKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHdyaXRlQ29va2llKG5hbWUsIHZhbHVlLCBwcm9wZXJ0aWVzKSB7XG4gICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gICAgbGV0IGV4cGlyZXMgPSBwcm9wZXJ0aWVzID09PSBudWxsIHx8IHByb3BlcnRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BlcnRpZXMuZXhwaXJlcztcbiAgICBpZiAodHlwZW9mIGV4cGlyZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29uc3QgZXhwaXJhdGlvbkRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBkYXlzRnJvbVRvZGF5SW5NcyA9IGV4cGlyZXMgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgICAgICBleHBpcmF0aW9uRGF0ZS5zZXRUaW1lKERhdGUubm93KCkgKyBkYXlzRnJvbVRvZGF5SW5Ncyk7XG4gICAgICAgIGV4cGlyZXMgPSBwcm9wZXJ0aWVzLmV4cGlyZXMgPSBleHBpcmF0aW9uRGF0ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleHBpcmVzICE9PSBcInN0cmluZ1wiICYmIChleHBpcmVzID09PSBudWxsIHx8IGV4cGlyZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4cGlyZXMudG9VVENTdHJpbmcpKSB7XG4gICAgICAgIHByb3BlcnRpZXMuZXhwaXJlcyA9IGV4cGlyZXMudG9VVENTdHJpbmcoKTtcbiAgICB9XG4gICAgbGV0IGNvb2tpZSA9IGAke25hbWV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gO1xuICAgIGxldCBwcm9wZXJ0eTtcbiAgICBmb3IgKHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgY29va2llICs9IGA7ICR7cHJvcGVydHl9YDtcbiAgICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IHByb3BlcnRpZXNbcHJvcGVydHldO1xuICAgICAgICBpZiAocHJvcGVydHlWYWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llICs9IGA9JHtwcm9wZXJ0eVZhbHVlfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llO1xufVxuXG5leHBvcnQgeyBzZXRTZXNzaW9uU3RvcmFnZUl0ZW0gYXMgYSwgZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtIGFzIGIsIGdldENvb2tpZSBhcyBjLCBzZXRDb29raWUgYXMgZCwgZ2V0TG9jYWxTdG9yYWdlSXRlbSBhcyBnLCBzZXRMb2NhbFN0b3JhZ2VJdGVtIGFzIHMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RvcmFnZS0wMzUzYTc2OS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=