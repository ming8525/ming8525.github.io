"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_ba-infographic_node_modules_arcgis_business-analyst-components_dis-50d863"],{

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/calcite-graph.entry.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/calcite-graph.entry.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calcite_graph: () => (/* binding */ Graph)
/* harmony export */ });
/* harmony import */ var _index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-4e647411.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/index-4e647411.js");
/* harmony import */ var _guid_88a3729f_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./guid-88a3729f.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/guid-88a3729f.js");
/* harmony import */ var _observers_56740e99_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./observers-56740e99.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/observers-56740e99.js");




/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
/**
 * Calculate slope of the tangents
 * uses Steffen interpolation as it's monotonic
 * http://jrwalsh1.github.io/posts/interpolations/
 *
 * @param p0
 * @param p1
 * @param p2
 */
function slope(p0, p1, p2) {
  const dx = p1[0] - p0[0];
  const dx1 = p2[0] - p1[0];
  const dy = p1[1] - p0[1];
  const dy1 = p2[1] - p1[1];
  const m = dy / (dx || (dx1 < 0 && 0));
  const m1 = dy1 / (dx1 || (dx < 0 && 0));
  const p = (m * dx1 + m1 * dx) / (dx + dx1);
  return (Math.sign(m) + Math.sign(m1)) * Math.min(Math.abs(m), Math.abs(m1), 0.5 * Math.abs(p)) || 0;
}
/**
 * Calculate slope for just one tangent (single-sided)
 *
 * @param p0
 * @param p1
 * @param m
 */
function slopeSingle(p0, p1, m) {
  const dx = p1[0] - p0[0];
  const dy = p1[1] - p0[1];
  return dx ? ((3 * dy) / dx - m) / 2 : m;
}
/**
 * Given two points and their tangent slopes,
 * calculate the bezier handle coordinates and return draw command.
 *
 * Translates Hermite Spline to BeziÃ©r curve:
 * stackoverflow.com/questions/42574940/
 *
 * @param p0
 * @param p1
 * @param m0
 * @param m1
 * @param t
 */
function bezier(p0, p1, m0, m1, t) {
  const [x0, y0] = p0;
  const [x1, y1] = p1;
  const dx = (x1 - x0) / 3;
  const h1 = t([x0 + dx, y0 + dx * m0]).join(",");
  const h2 = t([x1 - dx, y1 - dx * m1]).join(",");
  const p = t([x1, y1]).join(",");
  return `C ${h1} ${h2} ${p}`;
}
/**
 * Generate a function which will translate a point
 * from the data coordinate space to svg viewbox oriented pixels
 *
 * @param root0
 * @param root0.width
 * @param root0.height
 * @param root0.min
 * @param root0.max
 */
function translate({ width, height, min, max }) {
  const rangeX = max[0] - min[0];
  const rangeY = max[1] - min[1];
  return (point) => {
    const x = ((point[0] - min[0]) / rangeX) * width;
    const y = height - (point[1] / rangeY) * height;
    return [x, y];
  };
}
/**
 * Get the min and max values from the dataset
 *
 * @param data
 */
function range(data) {
  const [startX, startY] = data[0];
  const min = [startX, startY];
  const max = [startX, startY];
  return data.reduce(({ min, max }, [x, y]) => ({
    min: [Math.min(min[0], x), Math.min(min[1], y)],
    max: [Math.max(max[0], x), Math.max(max[1], y)]
  }), { min, max });
}
/**
 * Generate drawing commands for an area graph
 * returns a string can can be passed directly to a path element's `d` attribute
 *
 * @param root0
 * @param root0.data
 * @param root0.min
 * @param root0.max
 * @param root0.t
 */
function area({ data, min, max, t }) {
  if (data.length === 0) {
    return "";
  }
  // important points for beginning and ending the path
  const [startX, startY] = t(data[0]);
  const [minX, minY] = t(min);
  const [maxX] = t(max);
  // keep track of previous slope/points
  let m;
  let p0;
  let p1;
  // iterate over data points, calculating command for each
  const commands = data.reduce((acc, point, i) => {
    p0 = data[i - 2];
    p1 = data[i - 1];
    if (i > 1) {
      const m1 = slope(p0, p1, point);
      const m0 = m === undefined ? slopeSingle(p0, p1, m1) : m;
      const command = bezier(p0, p1, m0, m1, t);
      m = m1;
      return `${acc} ${command}`;
    }
    return acc;
  }, `M ${minX},${minY} L ${minX},${startY} L ${startX},${startY}`);
  // close the path
  const last = data[data.length - 1];
  const end = bezier(p1, last, m, slopeSingle(p1, last, m), t);
  return `${commands} ${end} L ${maxX},${minY} Z`;
}

const graphCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host{display:block;block-size:100%}.svg{fill:currentColor;stroke:transparent;margin:0px;display:block;block-size:100%;inline-size:100%;padding:0px}.svg .graph-path--highlight{fill:var(--calcite-ui-brand);opacity:0.5}";

const Graph = class {
  constructor(hostRef) {
    (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    //--------------------------------------------------------------------------
    //
    //  Private State/Props
    //
    //--------------------------------------------------------------------------
    this.graphId = `calcite-graph-${(0,_guid_88a3729f_js__WEBPACK_IMPORTED_MODULE_1__.g)()}`;
    this.resizeObserver = (0,_observers_56740e99_js__WEBPACK_IMPORTED_MODULE_2__.c)("resize", () => (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.f)(this));
    this.data = [];
    this.colorStops = undefined;
    this.highlightMin = undefined;
    this.highlightMax = undefined;
    this.min = undefined;
    this.max = undefined;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    this.resizeObserver?.observe(this.el);
  }
  disconnectedCallback() {
    this.resizeObserver?.disconnect();
  }
  render() {
    const { data, colorStops, el, highlightMax, highlightMin, min, max } = this;
    const id = this.graphId;
    const { clientHeight: height, clientWidth: width } = el;
    // if we have no data, return empty svg
    if (!data || data.length === 0) {
      return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { "aria-hidden": "true", class: "svg", height: height, preserveAspectRatio: "none", viewBox: `0 0 ${width} ${height}`, width: width }));
    }
    const { min: rangeMin, max: rangeMax } = range(data);
    let currentMin = rangeMin;
    let currentMax = rangeMax;
    if (min < rangeMin[0] || min > rangeMin[0]) {
      currentMin = [min, 0];
    }
    if (max > rangeMax[0] || max < rangeMax[0]) {
      currentMax = [max, rangeMax[1]];
    }
    const t = translate({ min: currentMin, max: currentMax, width, height });
    const [hMinX] = t([highlightMin, currentMax[1]]);
    const [hMaxX] = t([highlightMax, currentMax[1]]);
    const areaPath = area({ data, min: rangeMin, max: rangeMax, t });
    const fill = colorStops ? `url(#linear-gradient-${id})` : undefined;
    return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { "aria-hidden": "true", class: "svg", height: height, preserveAspectRatio: "none", viewBox: `0 0 ${width} ${height}`, width: width }, colorStops ? ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("defs", null, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("linearGradient", { id: `linear-gradient-${id}`, x1: "0", x2: "1", y1: "0", y2: "0" }, colorStops.map(({ offset, color, opacity }) => ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("stop", { offset: `${offset * 100}%`, "stop-color": color, "stop-opacity": opacity })))))) : null, highlightMin !== undefined ? ([
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("mask", { height: "100%", id: `${id}1`, width: "100%", x: "0%", y: "0%" }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: `
            M 0,0
            L ${hMinX - 1},0
            L ${hMinX - 1},${height}
            L 0,${height}
            Z
          `, fill: "white" })),
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("mask", { height: "100%", id: `${id}2`, width: "100%", x: "0%", y: "0%" }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: `
            M ${hMinX + 1},0
            L ${hMaxX - 1},0
            L ${hMaxX - 1},${height}
            L ${hMinX + 1}, ${height}
            Z
          `, fill: "white" })),
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("mask", { height: "100%", id: `${id}3`, width: "100%", x: "0%", y: "0%" }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: `
                M ${hMaxX + 1},0
                L ${width},0
                L ${width},${height}
                L ${hMaxX + 1}, ${height}
                Z
              `, fill: "white" })),
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("path", { class: "graph-path", d: areaPath, fill: fill, mask: `url(#${id}1)` }),
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("path", { class: "graph-path--highlight", d: areaPath, fill: fill, mask: `url(#${id}2)` }),
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("path", { class: "graph-path", d: areaPath, fill: fill, mask: `url(#${id}3)` })
    ]) : ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("path", { class: "graph-path", d: areaPath, fill: fill }))));
  }
  get el() { return (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
};
Graph.style = graphCss;



//# sourceMappingURL=calcite-graph.entry.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/guid-88a3729f.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/guid-88a3729f.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ guid)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
function gen(counts) {
  return counts
    .map((count) => {
    let out = "";
    for (let i = 0; i < count; i++) {
      out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    }
    return out;
  })
    .join("-");
}
const guid = () => gen([2, 1, 1, 1, 3]);



//# sourceMappingURL=guid-88a3729f.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/observers-56740e99.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/observers-56740e99.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createObserver)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
/**
 * This utility ensures observers are created only for browser contexts.
 *
 * @param type - the type of observer to create
 * @param callback - the observer callback
 * @param options - the observer options
 */
function createObserver(type, callback, options) {
  const Observer = getObserver(type);
  return new Observer(callback, options);
}
function getObserver(type) {
  // based on https://github.com/whatwg/dom/issues/126#issuecomment-1049814948
  class ExtendedMutationObserver extends window.MutationObserver {
    constructor(callback) {
      super(callback);
      this.observedEntry = [];
      this.callback = callback;
    }
    observe(target, options) {
      this.observedEntry.push({ target, options });
      return super.observe(target, options);
    }
    unobserve(target) {
      const newObservedEntries = this.observedEntry.filter((observed) => observed.target !== target);
      this.observedEntry = [];
      this.callback(super.takeRecords(), this);
      this.disconnect();
      newObservedEntries.forEach((observed) => this.observe(observed.target, observed.options));
    }
  }
  return (function () {
    return (type === "intersection"
      ? window.IntersectionObserver
      : type === "mutation"
        ? ExtendedMutationObserver
        : window.ResizeObserver);
  })();
}



//# sourceMappingURL=observers-56740e99.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYmEtaW5mb2dyYXBoaWNfbm9kZV9tb2R1bGVzX2FyY2dpc19idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHNfZGlzLTUwZDg2My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWtHO0FBQ25EO0FBQ2U7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBLEdBQUcsS0FBSyxVQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSyxFQUFFLFFBQVE7QUFDL0I7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFcUI7O0FBRXJCOzs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRStCOztBQUUvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYmEtaW5mb2dyYXBoaWMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYnVzaW5lc3MtYW5hbHlzdC1jb21wb25lbnRzL2Rpc3Qvc3RlbmNpbC1jb21wb25lbnRzL2Rpc3QvZXNtL2NhbGNpdGUtZ3JhcGguZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9iYS1pbmZvZ3JhcGhpYy9ub2RlX21vZHVsZXMvQGFyY2dpcy9idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHMvZGlzdC9zdGVuY2lsLWNvbXBvbmVudHMvZGlzdC9lc20vZ3VpZC04OGEzNzI5Zi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9vYnNlcnZlcnMtNTY3NDBlOTkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBoLCBnIGFzIGdldEVsZW1lbnQsIGYgYXMgZm9yY2VVcGRhdGUgfSBmcm9tICcuL2luZGV4LTRlNjQ3NDExLmpzJztcbmltcG9ydCB7IGcgYXMgZ3VpZCB9IGZyb20gJy4vZ3VpZC04OGEzNzI5Zi5qcyc7XG5pbXBvcnQgeyBjIGFzIGNyZWF0ZU9ic2VydmVyIH0gZnJvbSAnLi9vYnNlcnZlcnMtNTY3NDBlOTkuanMnO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuLyoqXG4gKiBDYWxjdWxhdGUgc2xvcGUgb2YgdGhlIHRhbmdlbnRzXG4gKiB1c2VzIFN0ZWZmZW4gaW50ZXJwb2xhdGlvbiBhcyBpdCdzIG1vbm90b25pY1xuICogaHR0cDovL2pyd2Fsc2gxLmdpdGh1Yi5pby9wb3N0cy9pbnRlcnBvbGF0aW9ucy9cbiAqXG4gKiBAcGFyYW0gcDBcbiAqIEBwYXJhbSBwMVxuICogQHBhcmFtIHAyXG4gKi9cbmZ1bmN0aW9uIHNsb3BlKHAwLCBwMSwgcDIpIHtcbiAgY29uc3QgZHggPSBwMVswXSAtIHAwWzBdO1xuICBjb25zdCBkeDEgPSBwMlswXSAtIHAxWzBdO1xuICBjb25zdCBkeSA9IHAxWzFdIC0gcDBbMV07XG4gIGNvbnN0IGR5MSA9IHAyWzFdIC0gcDFbMV07XG4gIGNvbnN0IG0gPSBkeSAvIChkeCB8fCAoZHgxIDwgMCAmJiAwKSk7XG4gIGNvbnN0IG0xID0gZHkxIC8gKGR4MSB8fCAoZHggPCAwICYmIDApKTtcbiAgY29uc3QgcCA9IChtICogZHgxICsgbTEgKiBkeCkgLyAoZHggKyBkeDEpO1xuICByZXR1cm4gKE1hdGguc2lnbihtKSArIE1hdGguc2lnbihtMSkpICogTWF0aC5taW4oTWF0aC5hYnMobSksIE1hdGguYWJzKG0xKSwgMC41ICogTWF0aC5hYnMocCkpIHx8IDA7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBzbG9wZSBmb3IganVzdCBvbmUgdGFuZ2VudCAoc2luZ2xlLXNpZGVkKVxuICpcbiAqIEBwYXJhbSBwMFxuICogQHBhcmFtIHAxXG4gKiBAcGFyYW0gbVxuICovXG5mdW5jdGlvbiBzbG9wZVNpbmdsZShwMCwgcDEsIG0pIHtcbiAgY29uc3QgZHggPSBwMVswXSAtIHAwWzBdO1xuICBjb25zdCBkeSA9IHAxWzFdIC0gcDBbMV07XG4gIHJldHVybiBkeCA/ICgoMyAqIGR5KSAvIGR4IC0gbSkgLyAyIDogbTtcbn1cbi8qKlxuICogR2l2ZW4gdHdvIHBvaW50cyBhbmQgdGhlaXIgdGFuZ2VudCBzbG9wZXMsXG4gKiBjYWxjdWxhdGUgdGhlIGJlemllciBoYW5kbGUgY29vcmRpbmF0ZXMgYW5kIHJldHVybiBkcmF3IGNvbW1hbmQuXG4gKlxuICogVHJhbnNsYXRlcyBIZXJtaXRlIFNwbGluZSB0byBCZXppw6lyIGN1cnZlOlxuICogc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQyNTc0OTQwL1xuICpcbiAqIEBwYXJhbSBwMFxuICogQHBhcmFtIHAxXG4gKiBAcGFyYW0gbTBcbiAqIEBwYXJhbSBtMVxuICogQHBhcmFtIHRcbiAqL1xuZnVuY3Rpb24gYmV6aWVyKHAwLCBwMSwgbTAsIG0xLCB0KSB7XG4gIGNvbnN0IFt4MCwgeTBdID0gcDA7XG4gIGNvbnN0IFt4MSwgeTFdID0gcDE7XG4gIGNvbnN0IGR4ID0gKHgxIC0geDApIC8gMztcbiAgY29uc3QgaDEgPSB0KFt4MCArIGR4LCB5MCArIGR4ICogbTBdKS5qb2luKFwiLFwiKTtcbiAgY29uc3QgaDIgPSB0KFt4MSAtIGR4LCB5MSAtIGR4ICogbTFdKS5qb2luKFwiLFwiKTtcbiAgY29uc3QgcCA9IHQoW3gxLCB5MV0pLmpvaW4oXCIsXCIpO1xuICByZXR1cm4gYEMgJHtoMX0gJHtoMn0gJHtwfWA7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCB0cmFuc2xhdGUgYSBwb2ludFxuICogZnJvbSB0aGUgZGF0YSBjb29yZGluYXRlIHNwYWNlIHRvIHN2ZyB2aWV3Ym94IG9yaWVudGVkIHBpeGVsc1xuICpcbiAqIEBwYXJhbSByb290MFxuICogQHBhcmFtIHJvb3QwLndpZHRoXG4gKiBAcGFyYW0gcm9vdDAuaGVpZ2h0XG4gKiBAcGFyYW0gcm9vdDAubWluXG4gKiBAcGFyYW0gcm9vdDAubWF4XG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh7IHdpZHRoLCBoZWlnaHQsIG1pbiwgbWF4IH0pIHtcbiAgY29uc3QgcmFuZ2VYID0gbWF4WzBdIC0gbWluWzBdO1xuICBjb25zdCByYW5nZVkgPSBtYXhbMV0gLSBtaW5bMV07XG4gIHJldHVybiAocG9pbnQpID0+IHtcbiAgICBjb25zdCB4ID0gKChwb2ludFswXSAtIG1pblswXSkgLyByYW5nZVgpICogd2lkdGg7XG4gICAgY29uc3QgeSA9IGhlaWdodCAtIChwb2ludFsxXSAvIHJhbmdlWSkgKiBoZWlnaHQ7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfTtcbn1cbi8qKlxuICogR2V0IHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgZnJvbSB0aGUgZGF0YXNldFxuICpcbiAqIEBwYXJhbSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHJhbmdlKGRhdGEpIHtcbiAgY29uc3QgW3N0YXJ0WCwgc3RhcnRZXSA9IGRhdGFbMF07XG4gIGNvbnN0IG1pbiA9IFtzdGFydFgsIHN0YXJ0WV07XG4gIGNvbnN0IG1heCA9IFtzdGFydFgsIHN0YXJ0WV07XG4gIHJldHVybiBkYXRhLnJlZHVjZSgoeyBtaW4sIG1heCB9LCBbeCwgeV0pID0+ICh7XG4gICAgbWluOiBbTWF0aC5taW4obWluWzBdLCB4KSwgTWF0aC5taW4obWluWzFdLCB5KV0sXG4gICAgbWF4OiBbTWF0aC5tYXgobWF4WzBdLCB4KSwgTWF0aC5tYXgobWF4WzFdLCB5KV1cbiAgfSksIHsgbWluLCBtYXggfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGRyYXdpbmcgY29tbWFuZHMgZm9yIGFuIGFyZWEgZ3JhcGhcbiAqIHJldHVybnMgYSBzdHJpbmcgY2FuIGNhbiBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gYSBwYXRoIGVsZW1lbnQncyBgZGAgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHJvb3QwXG4gKiBAcGFyYW0gcm9vdDAuZGF0YVxuICogQHBhcmFtIHJvb3QwLm1pblxuICogQHBhcmFtIHJvb3QwLm1heFxuICogQHBhcmFtIHJvb3QwLnRcbiAqL1xuZnVuY3Rpb24gYXJlYSh7IGRhdGEsIG1pbiwgbWF4LCB0IH0pIHtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgLy8gaW1wb3J0YW50IHBvaW50cyBmb3IgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdGhlIHBhdGhcbiAgY29uc3QgW3N0YXJ0WCwgc3RhcnRZXSA9IHQoZGF0YVswXSk7XG4gIGNvbnN0IFttaW5YLCBtaW5ZXSA9IHQobWluKTtcbiAgY29uc3QgW21heFhdID0gdChtYXgpO1xuICAvLyBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHNsb3BlL3BvaW50c1xuICBsZXQgbTtcbiAgbGV0IHAwO1xuICBsZXQgcDE7XG4gIC8vIGl0ZXJhdGUgb3ZlciBkYXRhIHBvaW50cywgY2FsY3VsYXRpbmcgY29tbWFuZCBmb3IgZWFjaFxuICBjb25zdCBjb21tYW5kcyA9IGRhdGEucmVkdWNlKChhY2MsIHBvaW50LCBpKSA9PiB7XG4gICAgcDAgPSBkYXRhW2kgLSAyXTtcbiAgICBwMSA9IGRhdGFbaSAtIDFdO1xuICAgIGlmIChpID4gMSkge1xuICAgICAgY29uc3QgbTEgPSBzbG9wZShwMCwgcDEsIHBvaW50KTtcbiAgICAgIGNvbnN0IG0wID0gbSA9PT0gdW5kZWZpbmVkID8gc2xvcGVTaW5nbGUocDAsIHAxLCBtMSkgOiBtO1xuICAgICAgY29uc3QgY29tbWFuZCA9IGJlemllcihwMCwgcDEsIG0wLCBtMSwgdCk7XG4gICAgICBtID0gbTE7XG4gICAgICByZXR1cm4gYCR7YWNjfSAke2NvbW1hbmR9YDtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgYE0gJHttaW5YfSwke21pbll9IEwgJHttaW5YfSwke3N0YXJ0WX0gTCAke3N0YXJ0WH0sJHtzdGFydFl9YCk7XG4gIC8vIGNsb3NlIHRoZSBwYXRoXG4gIGNvbnN0IGxhc3QgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGVuZCA9IGJlemllcihwMSwgbGFzdCwgbSwgc2xvcGVTaW5nbGUocDEsIGxhc3QsIG0pLCB0KTtcbiAgcmV0dXJuIGAke2NvbW1hbmRzfSAke2VuZH0gTCAke21heFh9LCR7bWluWX0gWmA7XG59XG5cbmNvbnN0IGdyYXBoQ3NzID0gXCJAa2V5ZnJhbWVzIGluezAle29wYWNpdHk6MH0xMDAle29wYWNpdHk6MX19QGtleWZyYW1lcyBpbi1kb3duezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgLTVweCwgMCl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIDAsIDApfX1Aa2V5ZnJhbWVzIGluLXVwezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tc2NhbGV7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZTNEKDAuOTUsIDAuOTUsIDEpfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNEKDEsIDEsIDEpfX06cm9vdHstLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZzpjYWxjKDE1MG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yOnZhcigtLWNhbGNpdGUtZHVyYXRpb24tZmFjdG9yLCAxKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1mYXN0OmNhbGMoMTAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLW1lZGl1bTpjYWxjKDIwMG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1zbG93OmNhbGMoMzAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpfS5jYWxjaXRlLWFuaW1hdGV7b3BhY2l0eTowO2FuaW1hdGlvbi1maWxsLW1vZGU6Ym90aDthbmltYXRpb24tZHVyYXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKX0uY2FsY2l0ZS1hbmltYXRlX19pbnthbmltYXRpb24tbmFtZTppbn0uY2FsY2l0ZS1hbmltYXRlX19pbi1kb3due2FuaW1hdGlvbi1uYW1lOmluLWRvd259LmNhbGNpdGUtYW5pbWF0ZV9faW4tdXB7YW5pbWF0aW9uLW5hbWU6aW4tdXB9LmNhbGNpdGUtYW5pbWF0ZV9faW4tc2NhbGV7YW5pbWF0aW9uLW5hbWU6aW4tc2NhbGV9QG1lZGlhIChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2Upezpyb290ey0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6MH19OnJvb3R7LS1jYWxjaXRlLWZsb2F0aW5nLXVpLXRyYW5zaXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKTstLWNhbGNpdGUtZmxvYXRpbmctdWktei1pbmRleDo2MDB9Omhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX06aG9zdHtkaXNwbGF5OmJsb2NrO2Jsb2NrLXNpemU6MTAwJX0uc3Zne2ZpbGw6Y3VycmVudENvbG9yO3N0cm9rZTp0cmFuc3BhcmVudDttYXJnaW46MHB4O2Rpc3BsYXk6YmxvY2s7YmxvY2stc2l6ZToxMDAlO2lubGluZS1zaXplOjEwMCU7cGFkZGluZzowcHh9LnN2ZyAuZ3JhcGgtcGF0aC0taGlnaGxpZ2h0e2ZpbGw6dmFyKC0tY2FsY2l0ZS11aS1icmFuZCk7b3BhY2l0eTowLjV9XCI7XG5cbmNvbnN0IEdyYXBoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBTdGF0ZS9Qcm9wc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHRoaXMuZ3JhcGhJZCA9IGBjYWxjaXRlLWdyYXBoLSR7Z3VpZCgpfWA7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IGNyZWF0ZU9ic2VydmVyKFwicmVzaXplXCIsICgpID0+IGZvcmNlVXBkYXRlKHRoaXMpKTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLmNvbG9yU3RvcHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oaWdobGlnaHRNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oaWdobGlnaHRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlcj8ub2JzZXJ2ZSh0aGlzLmVsKTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZGF0YSwgY29sb3JTdG9wcywgZWwsIGhpZ2hsaWdodE1heCwgaGlnaGxpZ2h0TWluLCBtaW4sIG1heCB9ID0gdGhpcztcbiAgICBjb25zdCBpZCA9IHRoaXMuZ3JhcGhJZDtcbiAgICBjb25zdCB7IGNsaWVudEhlaWdodDogaGVpZ2h0LCBjbGllbnRXaWR0aDogd2lkdGggfSA9IGVsO1xuICAgIC8vIGlmIHdlIGhhdmUgbm8gZGF0YSwgcmV0dXJuIGVtcHR5IHN2Z1xuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIChoKFwic3ZnXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgY2xhc3M6IFwic3ZnXCIsIGhlaWdodDogaGVpZ2h0LCBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIiwgdmlld0JveDogYDAgMCAke3dpZHRofSAke2hlaWdodH1gLCB3aWR0aDogd2lkdGggfSkpO1xuICAgIH1cbiAgICBjb25zdCB7IG1pbjogcmFuZ2VNaW4sIG1heDogcmFuZ2VNYXggfSA9IHJhbmdlKGRhdGEpO1xuICAgIGxldCBjdXJyZW50TWluID0gcmFuZ2VNaW47XG4gICAgbGV0IGN1cnJlbnRNYXggPSByYW5nZU1heDtcbiAgICBpZiAobWluIDwgcmFuZ2VNaW5bMF0gfHwgbWluID4gcmFuZ2VNaW5bMF0pIHtcbiAgICAgIGN1cnJlbnRNaW4gPSBbbWluLCAwXTtcbiAgICB9XG4gICAgaWYgKG1heCA+IHJhbmdlTWF4WzBdIHx8IG1heCA8IHJhbmdlTWF4WzBdKSB7XG4gICAgICBjdXJyZW50TWF4ID0gW21heCwgcmFuZ2VNYXhbMV1dO1xuICAgIH1cbiAgICBjb25zdCB0ID0gdHJhbnNsYXRlKHsgbWluOiBjdXJyZW50TWluLCBtYXg6IGN1cnJlbnRNYXgsIHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgY29uc3QgW2hNaW5YXSA9IHQoW2hpZ2hsaWdodE1pbiwgY3VycmVudE1heFsxXV0pO1xuICAgIGNvbnN0IFtoTWF4WF0gPSB0KFtoaWdobGlnaHRNYXgsIGN1cnJlbnRNYXhbMV1dKTtcbiAgICBjb25zdCBhcmVhUGF0aCA9IGFyZWEoeyBkYXRhLCBtaW46IHJhbmdlTWluLCBtYXg6IHJhbmdlTWF4LCB0IH0pO1xuICAgIGNvbnN0IGZpbGwgPSBjb2xvclN0b3BzID8gYHVybCgjbGluZWFyLWdyYWRpZW50LSR7aWR9KWAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIChoKFwic3ZnXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgY2xhc3M6IFwic3ZnXCIsIGhlaWdodDogaGVpZ2h0LCBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIiwgdmlld0JveDogYDAgMCAke3dpZHRofSAke2hlaWdodH1gLCB3aWR0aDogd2lkdGggfSwgY29sb3JTdG9wcyA/IChoKFwiZGVmc1wiLCBudWxsLCBoKFwibGluZWFyR3JhZGllbnRcIiwgeyBpZDogYGxpbmVhci1ncmFkaWVudC0ke2lkfWAsIHgxOiBcIjBcIiwgeDI6IFwiMVwiLCB5MTogXCIwXCIsIHkyOiBcIjBcIiB9LCBjb2xvclN0b3BzLm1hcCgoeyBvZmZzZXQsIGNvbG9yLCBvcGFjaXR5IH0pID0+IChoKFwic3RvcFwiLCB7IG9mZnNldDogYCR7b2Zmc2V0ICogMTAwfSVgLCBcInN0b3AtY29sb3JcIjogY29sb3IsIFwic3RvcC1vcGFjaXR5XCI6IG9wYWNpdHkgfSkpKSkpKSA6IG51bGwsIGhpZ2hsaWdodE1pbiAhPT0gdW5kZWZpbmVkID8gKFtcbiAgICAgIGgoXCJtYXNrXCIsIHsgaGVpZ2h0OiBcIjEwMCVcIiwgaWQ6IGAke2lkfTFgLCB3aWR0aDogXCIxMDAlXCIsIHg6IFwiMCVcIiwgeTogXCIwJVwiIH0sIGgoXCJwYXRoXCIsIHsgZDogYFxuICAgICAgICAgICAgTSAwLDBcbiAgICAgICAgICAgIEwgJHtoTWluWCAtIDF9LDBcbiAgICAgICAgICAgIEwgJHtoTWluWCAtIDF9LCR7aGVpZ2h0fVxuICAgICAgICAgICAgTCAwLCR7aGVpZ2h0fVxuICAgICAgICAgICAgWlxuICAgICAgICAgIGAsIGZpbGw6IFwid2hpdGVcIiB9KSksXG4gICAgICBoKFwibWFza1wiLCB7IGhlaWdodDogXCIxMDAlXCIsIGlkOiBgJHtpZH0yYCwgd2lkdGg6IFwiMTAwJVwiLCB4OiBcIjAlXCIsIHk6IFwiMCVcIiB9LCBoKFwicGF0aFwiLCB7IGQ6IGBcbiAgICAgICAgICAgIE0gJHtoTWluWCArIDF9LDBcbiAgICAgICAgICAgIEwgJHtoTWF4WCAtIDF9LDBcbiAgICAgICAgICAgIEwgJHtoTWF4WCAtIDF9LCR7aGVpZ2h0fVxuICAgICAgICAgICAgTCAke2hNaW5YICsgMX0sICR7aGVpZ2h0fVxuICAgICAgICAgICAgWlxuICAgICAgICAgIGAsIGZpbGw6IFwid2hpdGVcIiB9KSksXG4gICAgICBoKFwibWFza1wiLCB7IGhlaWdodDogXCIxMDAlXCIsIGlkOiBgJHtpZH0zYCwgd2lkdGg6IFwiMTAwJVwiLCB4OiBcIjAlXCIsIHk6IFwiMCVcIiB9LCBoKFwicGF0aFwiLCB7IGQ6IGBcbiAgICAgICAgICAgICAgICBNICR7aE1heFggKyAxfSwwXG4gICAgICAgICAgICAgICAgTCAke3dpZHRofSwwXG4gICAgICAgICAgICAgICAgTCAke3dpZHRofSwke2hlaWdodH1cbiAgICAgICAgICAgICAgICBMICR7aE1heFggKyAxfSwgJHtoZWlnaHR9XG4gICAgICAgICAgICAgICAgWlxuICAgICAgICAgICAgICBgLCBmaWxsOiBcIndoaXRlXCIgfSkpLFxuICAgICAgaChcInBhdGhcIiwgeyBjbGFzczogXCJncmFwaC1wYXRoXCIsIGQ6IGFyZWFQYXRoLCBmaWxsOiBmaWxsLCBtYXNrOiBgdXJsKCMke2lkfTEpYCB9KSxcbiAgICAgIGgoXCJwYXRoXCIsIHsgY2xhc3M6IFwiZ3JhcGgtcGF0aC0taGlnaGxpZ2h0XCIsIGQ6IGFyZWFQYXRoLCBmaWxsOiBmaWxsLCBtYXNrOiBgdXJsKCMke2lkfTIpYCB9KSxcbiAgICAgIGgoXCJwYXRoXCIsIHsgY2xhc3M6IFwiZ3JhcGgtcGF0aFwiLCBkOiBhcmVhUGF0aCwgZmlsbDogZmlsbCwgbWFzazogYHVybCgjJHtpZH0zKWAgfSlcbiAgICBdKSA6IChoKFwicGF0aFwiLCB7IGNsYXNzOiBcImdyYXBoLXBhdGhcIiwgZDogYXJlYVBhdGgsIGZpbGw6IGZpbGwgfSkpKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkdyYXBoLnN0eWxlID0gZ3JhcGhDc3M7XG5cbmV4cG9ydCB7IEdyYXBoIGFzIGNhbGNpdGVfZ3JhcGggfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsY2l0ZS1ncmFwaC5lbnRyeS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuZnVuY3Rpb24gZ2VuKGNvdW50cykge1xuICByZXR1cm4gY291bnRzXG4gICAgLm1hcCgoY291bnQpID0+IHtcbiAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIG91dCArPSAoKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKSB8IDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0pXG4gICAgLmpvaW4oXCItXCIpO1xufVxuY29uc3QgZ3VpZCA9ICgpID0+IGdlbihbMiwgMSwgMSwgMSwgM10pO1xuXG5leHBvcnQgeyBndWlkIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3VpZC04OGEzNzI5Zi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuLyoqXG4gKiBUaGlzIHV0aWxpdHkgZW5zdXJlcyBvYnNlcnZlcnMgYXJlIGNyZWF0ZWQgb25seSBmb3IgYnJvd3NlciBjb250ZXh0cy5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIG9ic2VydmVyIHRvIGNyZWF0ZVxuICogQHBhcmFtIGNhbGxiYWNrIC0gdGhlIG9ic2VydmVyIGNhbGxiYWNrXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBvYnNlcnZlciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGNvbnN0IE9ic2VydmVyID0gZ2V0T2JzZXJ2ZXIodHlwZSk7XG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIoY2FsbGJhY2ssIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXIodHlwZSkge1xuICAvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2RvbS9pc3N1ZXMvMTI2I2lzc3VlY29tbWVudC0xMDQ5ODE0OTQ4XG4gIGNsYXNzIEV4dGVuZGVkTXV0YXRpb25PYnNlcnZlciBleHRlbmRzIHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgICAgc3VwZXIoY2FsbGJhY2spO1xuICAgICAgdGhpcy5vYnNlcnZlZEVudHJ5ID0gW107XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9ic2VydmUodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLm9ic2VydmVkRW50cnkucHVzaCh7IHRhcmdldCwgb3B0aW9ucyB9KTtcbiAgICAgIHJldHVybiBzdXBlci5vYnNlcnZlKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHVub2JzZXJ2ZSh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IG5ld09ic2VydmVkRW50cmllcyA9IHRoaXMub2JzZXJ2ZWRFbnRyeS5maWx0ZXIoKG9ic2VydmVkKSA9PiBvYnNlcnZlZC50YXJnZXQgIT09IHRhcmdldCk7XG4gICAgICB0aGlzLm9ic2VydmVkRW50cnkgPSBbXTtcbiAgICAgIHRoaXMuY2FsbGJhY2soc3VwZXIudGFrZVJlY29yZHMoKSwgdGhpcyk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIG5ld09ic2VydmVkRW50cmllcy5mb3JFYWNoKChvYnNlcnZlZCkgPT4gdGhpcy5vYnNlcnZlKG9ic2VydmVkLnRhcmdldCwgb2JzZXJ2ZWQub3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHR5cGUgPT09IFwiaW50ZXJzZWN0aW9uXCJcbiAgICAgID8gd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyXG4gICAgICA6IHR5cGUgPT09IFwibXV0YXRpb25cIlxuICAgICAgICA/IEV4dGVuZGVkTXV0YXRpb25PYnNlcnZlclxuICAgICAgICA6IHdpbmRvdy5SZXNpemVPYnNlcnZlcik7XG4gIH0pKCk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZU9ic2VydmVyIGFzIGMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXJzLTU2NzQwZTk5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==