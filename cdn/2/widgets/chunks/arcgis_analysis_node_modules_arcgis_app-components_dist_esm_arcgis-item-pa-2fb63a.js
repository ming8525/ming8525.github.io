"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-item-pa-2fb63a"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-item-palette.entry.js":
/*!**********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-item-palette.entry.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_item_palette: () => (/* binding */ ArcgisItemPalette)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const arcgisItemPaletteCss = ".sc-arcgis-item-palette-h{display:flex;flex-wrap:wrap;width:100%}.palette.sc-arcgis-item-palette{display:grid;justify-content:space-between;-moz-column-gap:4px;column-gap:4px;row-gap:4px;width:100%}.palette.sc-arcgis-item-palette:focus-within .item--active.sc-arcgis-item-palette:not(.item--selected){border-color:#ccc}.item.sc-arcgis-item-palette{display:flex;align-items:center;justify-content:center;cursor:pointer;border:2px solid transparent;outline:none}.item--selected.sc-arcgis-item-palette{border-color:#0079c1;font-weight:bolder}.marker-item.sc-arcgis-item-palette>div.sc-arcgis-item-palette>img.sc-arcgis-item-palette{width:100%}";

const ItemPaletteCSS = {
    palette: "palette",
    item: "item",
    itemActive: "item--active",
    itemSelected: "item--selected"
};
const indexToXY = (index, width) => {
    const x = index % width;
    const y = Math.floor(index / width);
    return { x, y };
};
const xyToIndex = (x, y, width) => x + width * y;
function ensureItemIsInView(scrollerContainer, blockOrSection) {
    if (!scrollerContainer) {
        return;
    }
    const scrollerRect = scrollerContainer.getBoundingClientRect();
    const blockOrSectionRect = blockOrSection.getBoundingClientRect();
    const blockOrSectionHeight = blockOrSectionRect.top + blockOrSectionRect.height;
    const scrollerHeight = scrollerRect.top + scrollerRect.height;
    const needToScrollDown = blockOrSectionHeight > scrollerHeight;
    if (needToScrollDown) {
        const scrollAmount = Math.abs(scrollerHeight - blockOrSectionHeight);
        scrollerContainer.scrollTop += scrollAmount;
        return;
    }
    const needToScrollUp = blockOrSectionRect.top < scrollerRect.top;
    if (needToScrollUp) {
        const scrollAmount = Math.abs(blockOrSectionRect.top - scrollerRect.top);
        scrollerContainer.scrollTop -= scrollAmount;
    }
}
const ArcgisItemPalette = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisItemSelect = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisItemSelect", 7);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.handleFocus = () => {
            const { items, selected } = this;
            const selectedItemIndex = items.findIndex((item) => typeof selected === "function"
                ? selected(item)
                : item === selected);
            this.selectedItemIndex = selectedItemIndex;
            this.activeItemIndex = selectedItemIndex < 0 ? 0 : selectedItemIndex;
        };
        this.handleKeyDown = (event) => {
            const { key } = event;
            const { el, itemsPerRow, items } = this;
            const NAVIGATION_KEYS = [" ", "Enter", "ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp"];
            if (NAVIGATION_KEYS.indexOf(key) === -1) {
                return;
            }
            if (key === "ArrowLeft") {
                this.activeItemIndex = this.moveItemIndex("left", itemsPerRow);
            }
            else if (key === "ArrowRight") {
                this.activeItemIndex = this.moveItemIndex("right", itemsPerRow);
            }
            else if (key === "ArrowUp") {
                this.activeItemIndex = this.moveItemIndex("up", itemsPerRow);
            }
            else if (key === "ArrowDown") {
                this.activeItemIndex = this.moveItemIndex("down", itemsPerRow);
            }
            else if (key === "Enter" || key === " ") {
                this.selectItem(items[this.activeItemIndex]);
            }
            const activeItem = el.querySelectorAll(`.${ItemPaletteCSS.item}`)[this.activeItemIndex];
            ensureItemIsInView(el.parentElement, activeItem);
            event.preventDefault();
            event.stopPropagation();
        };
        this.moveItemIndex = (direction, itemsPerRow) => {
            const currentIndex = this.activeItemIndex;
            const totalItems = this.items.length;
            let { x, y } = indexToXY(currentIndex, itemsPerRow);
            const origX = x;
            const origY = y;
            if (direction === "left") {
                x -= 1;
            }
            else if (direction === "right") {
                x += 1;
            }
            if (x < 0) {
                x = 0;
            }
            else if (x > itemsPerRow - 1) {
                x = itemsPerRow - 1;
            }
            else if (direction === "up") {
                y -= 1;
            }
            else if (direction === "down") {
                y += 1;
            }
            const rows = Math.ceil(totalItems / itemsPerRow);
            if (y < 0) {
                y = 0;
            }
            else if (y > rows - 1) {
                y = rows - 1;
            }
            const futureIndex = x + itemsPerRow * y;
            if (futureIndex > totalItems - 1) {
                return xyToIndex(origX, origY, itemsPerRow);
            }
            return xyToIndex(x, y, itemsPerRow);
        };
        this.handleClick = (event) => {
            const node = event.currentTarget;
            const itemIndex = Number(node.getAttribute("data-index"));
            this.selectItem(this.items[itemIndex]);
        };
        this.selectItem = (item) => {
            const { items, arcgisItemSelect } = this;
            const itemIndex = items.indexOf(item);
            this.selectedItemIndex = itemIndex;
            this.activeItemIndex = itemIndex;
            arcgisItemSelect.emit(item);
        };
        this.extraItemProps = undefined;
        this.ItemRenderer = undefined;
        this.items = undefined;
        this.itemsPerRow = 5;
        this.itemProperty = undefined;
        this.selected = undefined;
        this.activeItemIndex = 0;
        this.selectedItemIndex = 0;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Set focus on selected item, e.g. when item gets selected without a mouse click
     */
    async setFocus() {
        var _a;
        this.handleFocus();
        (_a = this.el.querySelector(`.${ItemPaletteCSS.itemSelected}`)) === null || _a === void 0 ? void 0 : _a.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    render() {
        var _a;
        const { items, ItemRenderer, extraItemProps, itemProperty, selected, itemsPerRow } = this;
        const itemWrappers = [];
        const totalRows = Math.ceil(items.length / itemsPerRow);
        const gridTemplateColumns = Array(itemsPerRow).fill("auto").join(" ");
        for (let y = 0; y < totalRows; y++) {
            for (let x = 0, index = xyToIndex(x, y, itemsPerRow); x < itemsPerRow; x++, index = xyToIndex(x, y, itemsPerRow)) {
                const item = items[index];
                if (index >= items.length) {
                    break;
                }
                itemWrappers.push((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: {
                        [ItemPaletteCSS.item]: true,
                        [ItemPaletteCSS.itemActive]: index === this.activeItemIndex,
                        [ItemPaletteCSS.itemSelected]: typeof selected === "function"
                            ? selected(item)
                            : item === selected
                    }, "data-index": index, key: index, onClick: this.handleClick, tabIndex: -1, "aria-label": ((_a = item.item) === null || _a === void 0 ? void 0 : _a.data) ? (item.item.data.title || item.item.data.name) : item.name }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(ItemRenderer, Object.assign({}, (itemProperty ? { [itemProperty]: item } : item), extraItemProps))));
            }
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: ItemPaletteCSS.palette, "data-row-size": itemsPerRow, onFocus: this.handleFocus, onKeyDown: this.handleKeyDown, tabIndex: 0, style: { gridTemplateColumns } }, itemWrappers));
    }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisItemPalette.style = arcgisItemPaletteCss;



//# sourceMappingURL=arcgis-item-palette.entry.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWl0ZW0tcGEtMmZiNjNhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDa0c7O0FBRWxHLHdEQUF3RCxhQUFhLGVBQWUsV0FBVyxnQ0FBZ0MsYUFBYSw4QkFBOEIsb0JBQW9CLGVBQWUsWUFBWSxXQUFXLHVHQUF1RyxrQkFBa0IsNkJBQTZCLGFBQWEsbUJBQW1CLHVCQUF1QixlQUFlLDZCQUE2QixhQUFhLHVDQUF1QyxxQkFBcUIsbUJBQW1CLDBGQUEwRixXQUFXOztBQUU5cEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQWdCO0FBQ3hCLGdDQUFnQyxxREFBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxvQkFBb0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJFQUEyRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QyxrRUFBa0UsaUJBQWlCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFEQUFDLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1TkFBdU4sRUFBRSxxREFBQywrQkFBK0Isb0JBQW9CLHVCQUF1QjtBQUN6VDtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFDLFVBQVUsNklBQTZJLHVCQUF1QjtBQUMvTDtBQUNBLGVBQWUsT0FBTyxxREFBVTtBQUNoQztBQUNBOztBQUVvRDs7QUFFcEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtaXRlbS1wYWxldHRlLmVudHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBkIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcblxuY29uc3QgYXJjZ2lzSXRlbVBhbGV0dGVDc3MgPSBcIi5zYy1hcmNnaXMtaXRlbS1wYWxldHRlLWh7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO3dpZHRoOjEwMCV9LnBhbGV0dGUuc2MtYXJjZ2lzLWl0ZW0tcGFsZXR0ZXtkaXNwbGF5OmdyaWQ7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47LW1vei1jb2x1bW4tZ2FwOjRweDtjb2x1bW4tZ2FwOjRweDtyb3ctZ2FwOjRweDt3aWR0aDoxMDAlfS5wYWxldHRlLnNjLWFyY2dpcy1pdGVtLXBhbGV0dGU6Zm9jdXMtd2l0aGluIC5pdGVtLS1hY3RpdmUuc2MtYXJjZ2lzLWl0ZW0tcGFsZXR0ZTpub3QoLml0ZW0tLXNlbGVjdGVkKXtib3JkZXItY29sb3I6I2NjY30uaXRlbS5zYy1hcmNnaXMtaXRlbS1wYWxldHRle2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtib3JkZXI6MnB4IHNvbGlkIHRyYW5zcGFyZW50O291dGxpbmU6bm9uZX0uaXRlbS0tc2VsZWN0ZWQuc2MtYXJjZ2lzLWl0ZW0tcGFsZXR0ZXtib3JkZXItY29sb3I6IzAwNzljMTtmb250LXdlaWdodDpib2xkZXJ9Lm1hcmtlci1pdGVtLnNjLWFyY2dpcy1pdGVtLXBhbGV0dGU+ZGl2LnNjLWFyY2dpcy1pdGVtLXBhbGV0dGU+aW1nLnNjLWFyY2dpcy1pdGVtLXBhbGV0dGV7d2lkdGg6MTAwJX1cIjtcblxuY29uc3QgSXRlbVBhbGV0dGVDU1MgPSB7XG4gICAgcGFsZXR0ZTogXCJwYWxldHRlXCIsXG4gICAgaXRlbTogXCJpdGVtXCIsXG4gICAgaXRlbUFjdGl2ZTogXCJpdGVtLS1hY3RpdmVcIixcbiAgICBpdGVtU2VsZWN0ZWQ6IFwiaXRlbS0tc2VsZWN0ZWRcIlxufTtcbmNvbnN0IGluZGV4VG9YWSA9IChpbmRleCwgd2lkdGgpID0+IHtcbiAgICBjb25zdCB4ID0gaW5kZXggJSB3aWR0aDtcbiAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihpbmRleCAvIHdpZHRoKTtcbiAgICByZXR1cm4geyB4LCB5IH07XG59O1xuY29uc3QgeHlUb0luZGV4ID0gKHgsIHksIHdpZHRoKSA9PiB4ICsgd2lkdGggKiB5O1xuZnVuY3Rpb24gZW5zdXJlSXRlbUlzSW5WaWV3KHNjcm9sbGVyQ29udGFpbmVyLCBibG9ja09yU2VjdGlvbikge1xuICAgIGlmICghc2Nyb2xsZXJDb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxlclJlY3QgPSBzY3JvbGxlckNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBibG9ja09yU2VjdGlvblJlY3QgPSBibG9ja09yU2VjdGlvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBibG9ja09yU2VjdGlvbkhlaWdodCA9IGJsb2NrT3JTZWN0aW9uUmVjdC50b3AgKyBibG9ja09yU2VjdGlvblJlY3QuaGVpZ2h0O1xuICAgIGNvbnN0IHNjcm9sbGVySGVpZ2h0ID0gc2Nyb2xsZXJSZWN0LnRvcCArIHNjcm9sbGVyUmVjdC5oZWlnaHQ7XG4gICAgY29uc3QgbmVlZFRvU2Nyb2xsRG93biA9IGJsb2NrT3JTZWN0aW9uSGVpZ2h0ID4gc2Nyb2xsZXJIZWlnaHQ7XG4gICAgaWYgKG5lZWRUb1Njcm9sbERvd24pIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gTWF0aC5hYnMoc2Nyb2xsZXJIZWlnaHQgLSBibG9ja09yU2VjdGlvbkhlaWdodCk7XG4gICAgICAgIHNjcm9sbGVyQ29udGFpbmVyLnNjcm9sbFRvcCArPSBzY3JvbGxBbW91bnQ7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmVlZFRvU2Nyb2xsVXAgPSBibG9ja09yU2VjdGlvblJlY3QudG9wIDwgc2Nyb2xsZXJSZWN0LnRvcDtcbiAgICBpZiAobmVlZFRvU2Nyb2xsVXApIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gTWF0aC5hYnMoYmxvY2tPclNlY3Rpb25SZWN0LnRvcCAtIHNjcm9sbGVyUmVjdC50b3ApO1xuICAgICAgICBzY3JvbGxlckNvbnRhaW5lci5zY3JvbGxUb3AgLT0gc2Nyb2xsQW1vdW50O1xuICAgIH1cbn1cbmNvbnN0IEFyY2dpc0l0ZW1QYWxldHRlID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNJdGVtU2VsZWN0ID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNJdGVtU2VsZWN0XCIsIDcpO1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vXG4gICAgICAgIC8vICBQcml2YXRlIE1ldGhvZHNcbiAgICAgICAgLy9cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpdGVtcywgc2VsZWN0ZWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEl0ZW1JbmRleCA9IGl0ZW1zLmZpbmRJbmRleCgoaXRlbSkgPT4gdHlwZW9mIHNlbGVjdGVkID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICA/IHNlbGVjdGVkKGl0ZW0pXG4gICAgICAgICAgICAgICAgOiBpdGVtID09PSBzZWxlY3RlZCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbUluZGV4ID0gc2VsZWN0ZWRJdGVtSW5kZXg7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW1JbmRleCA9IHNlbGVjdGVkSXRlbUluZGV4IDwgMCA/IDAgOiBzZWxlY3RlZEl0ZW1JbmRleDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCB7IGVsLCBpdGVtc1BlclJvdywgaXRlbXMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBOQVZJR0FUSU9OX0tFWVMgPSBbXCIgXCIsIFwiRW50ZXJcIiwgXCJBcnJvd0Rvd25cIiwgXCJBcnJvd0xlZnRcIiwgXCJBcnJvd1JpZ2h0XCIsIFwiQXJyb3dVcFwiXTtcbiAgICAgICAgICAgIGlmIChOQVZJR0FUSU9OX0tFWVMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW1JbmRleCA9IHRoaXMubW92ZUl0ZW1JbmRleChcImxlZnRcIiwgaXRlbXNQZXJSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIkFycm93UmlnaHRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbUluZGV4ID0gdGhpcy5tb3ZlSXRlbUluZGV4KFwicmlnaHRcIiwgaXRlbXNQZXJSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIkFycm93VXBcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbUluZGV4ID0gdGhpcy5tb3ZlSXRlbUluZGV4KFwidXBcIiwgaXRlbXNQZXJSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIkFycm93RG93blwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVJdGVtSW5kZXggPSB0aGlzLm1vdmVJdGVtSW5kZXgoXCJkb3duXCIsIGl0ZW1zUGVyUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJFbnRlclwiIHx8IGtleSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0oaXRlbXNbdGhpcy5hY3RpdmVJdGVtSW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUl0ZW0gPSBlbC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtJdGVtUGFsZXR0ZUNTUy5pdGVtfWApW3RoaXMuYWN0aXZlSXRlbUluZGV4XTtcbiAgICAgICAgICAgIGVuc3VyZUl0ZW1Jc0luVmlldyhlbC5wYXJlbnRFbGVtZW50LCBhY3RpdmVJdGVtKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb3ZlSXRlbUluZGV4ID0gKGRpcmVjdGlvbiwgaXRlbXNQZXJSb3cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuYWN0aXZlSXRlbUluZGV4O1xuICAgICAgICAgICAgY29uc3QgdG90YWxJdGVtcyA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHsgeCwgeSB9ID0gaW5kZXhUb1hZKGN1cnJlbnRJbmRleCwgaXRlbXNQZXJSb3cpO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ1ggPSB4O1xuICAgICAgICAgICAgY29uc3Qgb3JpZ1kgPSB5O1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICB4IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgIHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeCA+IGl0ZW1zUGVyUm93IC0gMSkge1xuICAgICAgICAgICAgICAgIHggPSBpdGVtc1BlclJvdyAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwidXBcIikge1xuICAgICAgICAgICAgICAgIHkgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJkb3duXCIpIHtcbiAgICAgICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3dzID0gTWF0aC5jZWlsKHRvdGFsSXRlbXMgLyBpdGVtc1BlclJvdyk7XG4gICAgICAgICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHkgPiByb3dzIC0gMSkge1xuICAgICAgICAgICAgICAgIHkgPSByb3dzIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZ1dHVyZUluZGV4ID0geCArIGl0ZW1zUGVyUm93ICogeTtcbiAgICAgICAgICAgIGlmIChmdXR1cmVJbmRleCA+IHRvdGFsSXRlbXMgLSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHh5VG9JbmRleChvcmlnWCwgb3JpZ1ksIGl0ZW1zUGVyUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4eVRvSW5kZXgoeCwgeSwgaXRlbXNQZXJSb3cpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IE51bWJlcihub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtaW5kZXhcIikpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RJdGVtKHRoaXMuaXRlbXNbaXRlbUluZGV4XSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZWN0SXRlbSA9IChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGl0ZW1zLCBhcmNnaXNJdGVtU2VsZWN0IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtSW5kZXggPSBpdGVtSW5kZXg7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW1JbmRleCA9IGl0ZW1JbmRleDtcbiAgICAgICAgICAgIGFyY2dpc0l0ZW1TZWxlY3QuZW1pdChpdGVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHRyYUl0ZW1Qcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5JdGVtUmVuZGVyZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXRlbXNQZXJSb3cgPSA1O1xuICAgICAgICB0aGlzLml0ZW1Qcm9wZXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbUluZGV4ID0gMDtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFB1YmxpYyBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyoqXG4gICAgICogU2V0IGZvY3VzIG9uIHNlbGVjdGVkIGl0ZW0sIGUuZy4gd2hlbiBpdGVtIGdldHMgc2VsZWN0ZWQgd2l0aG91dCBhIG1vdXNlIGNsaWNrXG4gICAgICovXG4gICAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1cygpO1xuICAgICAgICAoX2EgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoYC4ke0l0ZW1QYWxldHRlQ1NTLml0ZW1TZWxlY3RlZH1gKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBpdGVtcywgSXRlbVJlbmRlcmVyLCBleHRyYUl0ZW1Qcm9wcywgaXRlbVByb3BlcnR5LCBzZWxlY3RlZCwgaXRlbXNQZXJSb3cgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGl0ZW1XcmFwcGVycyA9IFtdO1xuICAgICAgICBjb25zdCB0b3RhbFJvd3MgPSBNYXRoLmNlaWwoaXRlbXMubGVuZ3RoIC8gaXRlbXNQZXJSb3cpO1xuICAgICAgICBjb25zdCBncmlkVGVtcGxhdGVDb2x1bW5zID0gQXJyYXkoaXRlbXNQZXJSb3cpLmZpbGwoXCJhdXRvXCIpLmpvaW4oXCIgXCIpO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRvdGFsUm93czsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgaW5kZXggPSB4eVRvSW5kZXgoeCwgeSwgaXRlbXNQZXJSb3cpOyB4IDwgaXRlbXNQZXJSb3c7IHgrKywgaW5kZXggPSB4eVRvSW5kZXgoeCwgeSwgaXRlbXNQZXJSb3cpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtV3JhcHBlcnMucHVzaChoKFwiZGl2XCIsIHsgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtJdGVtUGFsZXR0ZUNTUy5pdGVtXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtJdGVtUGFsZXR0ZUNTUy5pdGVtQWN0aXZlXTogaW5kZXggPT09IHRoaXMuYWN0aXZlSXRlbUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgW0l0ZW1QYWxldHRlQ1NTLml0ZW1TZWxlY3RlZF06IHR5cGVvZiBzZWxlY3RlZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxlY3RlZChpdGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbSA9PT0gc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgfSwgXCJkYXRhLWluZGV4XCI6IGluZGV4LCBrZXk6IGluZGV4LCBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLCB0YWJJbmRleDogLTEsIFwiYXJpYS1sYWJlbFwiOiAoKF9hID0gaXRlbS5pdGVtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YSkgPyAoaXRlbS5pdGVtLmRhdGEudGl0bGUgfHwgaXRlbS5pdGVtLmRhdGEubmFtZSkgOiBpdGVtLm5hbWUgfSwgaChJdGVtUmVuZGVyZXIsIE9iamVjdC5hc3NpZ24oe30sIChpdGVtUHJvcGVydHkgPyB7IFtpdGVtUHJvcGVydHldOiBpdGVtIH0gOiBpdGVtKSwgZXh0cmFJdGVtUHJvcHMpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBJdGVtUGFsZXR0ZUNTUy5wYWxldHRlLCBcImRhdGEtcm93LXNpemVcIjogaXRlbXNQZXJSb3csIG9uRm9jdXM6IHRoaXMuaGFuZGxlRm9jdXMsIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlEb3duLCB0YWJJbmRleDogMCwgc3R5bGU6IHsgZ3JpZFRlbXBsYXRlQ29sdW1ucyB9IH0sIGl0ZW1XcmFwcGVycykpO1xuICAgIH1cbiAgICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzSXRlbVBhbGV0dGUuc3R5bGUgPSBhcmNnaXNJdGVtUGFsZXR0ZUNzcztcblxuZXhwb3J0IHsgQXJjZ2lzSXRlbVBhbGV0dGUgYXMgYXJjZ2lzX2l0ZW1fcGFsZXR0ZSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtaXRlbS1wYWxldHRlLmVudHJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==