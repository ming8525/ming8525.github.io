"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_featur-c46c25"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-1ce1b984.js":
/*!*************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-1ce1b984.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ useArcadeEditor)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




/**
 * Creates Arcade Editor
 */
async function useArcadeEditor(fieldInfo) {
    const { layer: smLayer, strings, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const defaultExpressionScript = "// " +
        strings.arcade.defaultExpressionScript_line1 +
        "\r\n// " +
        strings.arcade.defaultExpressionScript_line2 +
        "\r\n// Round(($feature.oak_count / $feature.all_trees_count) * 100, 2)\r\n\r\n";
    const arcadeEditor = document.createElement("arcgis-modal-arcade");
    arcadeEditor.arcadeScript = (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.expression) || defaultExpressionScript;
    arcadeEditor.arcadeProfile = getArcadeProfile();
    arcadeEditor.testData = await getArcadeTestData();
    arcadeEditor.addExistingExpressions = true;
    arcadeEditor.layer = layer; // StreamLayer is missing
    arcadeEditor.arcadeTitle = (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.expressionTitle) || strings.arcade.newExpression;
    arcadeEditor.arcadeTitleEditable = true;
    arcadeEditor.arcadeTitleEditingEnabled = !(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.expressionTitle);
    document.body.appendChild(arcadeEditor);
    return new Promise((resolve, reject) => {
        arcadeEditor.addEventListener("arcgisModalArcadeClose", (event) => {
            //console.log("arcgisModalArcadeClose", event.detail);
            document.body.removeChild(arcadeEditor);
            if (!event.detail) {
                reject();
                return;
            }
            const { script, title, predictOutputType } = event.detail;
            if (!script || script === defaultExpressionScript) {
                reject();
                return;
            }
            // make sure layer gets needed fields; WFSLayer is missing
            return modules.fieldUtils.getExpressionFields(layer, [script]).then((outFields) => {
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.O)(outFields);
                resolve({
                    expression: script,
                    expressionTitle: title,
                    simpleFieldType: predictOutputType === "number"
                        ? _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.NUMBER
                        : predictOutputType === "string"
                            ? _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.STRING
                            : predictOutputType === "date"
                                ? _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.NUMBER // DATE - not supported
                                : _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.UNKNOWN
                });
            });
        });
    });
}
function getArcadeProfile() {
    const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    return {
        id: "visualization",
        definitions: {
            /**
             * Note: there are no current official plans to support Arcade
             * for Oriented Imagery layers, even though this button is
             * shown and functions properly
             */
            $feature: layer
        }
    };
}
async function getArcadeTestData() {
    const { mapView } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    return {
        profileVariableInstances: {
            $feature: await getOneArcadeFeature(),
            $view: {
                scale: mapView.scale
            }
        },
        spatialReference: mapView.spatialReference
    };
}
async function getOneArcadeFeature() {
    var _a;
    const { layer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    let feature;
    if (!("fields" in layer)) {
        return null;
    }
    else {
        await getOneFeature();
        const { oneFeatureResponse } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
        if ((_a = oneFeatureResponse === null || oneFeatureResponse === void 0 ? void 0 : oneFeatureResponse.features) === null || _a === void 0 ? void 0 : _a.length) {
            feature = modules.esriLang.clone(oneFeatureResponse.features[0]);
        }
        else {
            // we need to create a feature
            const attributes = {};
            layer.fields.forEach((field) => {
                if ([
                    "small-integer",
                    "big-integer",
                    "integer",
                    "single",
                    "double",
                    "string",
                    "date",
                    "date-only",
                    "oid",
                    "guid"
                ].indexOf(field.type) > -1) {
                    if (field.nullable === false) {
                        if (field.defaultValue) {
                            attributes[field.name] = field.defaultValue;
                        }
                        else if (field.type === "string") {
                            attributes[field.name] = "";
                        }
                        else {
                            attributes[field.name] = 0;
                        }
                    }
                    else {
                        attributes[field.name] = null;
                    }
                }
                else {
                    attributes[field.name] = null;
                }
            });
            // make up some geometry using the map extent
            const ext = mapView.extent;
            let geometry, symbol;
            if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer) /* || layer.getCustomRasterFields */) {
                geometry = new modules.Polygon({
                    spatialReference: new modules.SpatialReference(mapView.spatialReference.toJSON())
                });
                geometry.addRing([
                    [ext.xmin, ext.ymin],
                    [ext.xmax, ext.ymin],
                    [ext.xmax, ext.ymax],
                    [ext.xmin, ext.ymax],
                    [ext.xmin, ext.ymin]
                ]);
                symbol = new modules.SimpleLineSymbol();
            }
            else if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer)) {
                geometry = new modules.Point(ext.center.toJSON());
                symbol = new modules.SimpleMarkerSymbol();
            }
            else if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer)) {
                geometry = new modules.Polyline({
                    spatialReference: new modules.SpatialReference(mapView.spatialReference.toJSON())
                });
                geometry.addPath([
                    [ext.xmin, ext.ymin],
                    [ext.xmax, ext.ymax]
                ]);
                symbol = new modules.SimpleFillSymbol();
            }
            feature = new modules.Graphic({
                geometry,
                symbol: symbol,
                attributes
            });
        }
    }
    return feature;
}

async function getOneFeature() {
    const { oneFeatureResponse, oneFeatureResponseStatus } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    if (!oneFeatureResponse || oneFeatureResponseStatus === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.b.MISSING) {
        const result = await _getOneFeature();
        _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s.oneFeatureResponse = (result === null || result === void 0 ? void 0 : result.features.length) && result;
        _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s.oneFeatureResponseStatus = (result === null || result === void 0 ? void 0 : result.features.length) ? _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.b.SUCCESS : _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.b.FAILED;
        return result;
    }
    else {
        return _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s.oneFeatureResponse;
    }
}
function _getOneFeature() {
    const { mapView, layer, mapImageSublayer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    if (!("fields" in layer)) {
        return Promise.reject("getOneFeature: wrong layer type");
    }
    if (mapImageSublayer) {
        // layer is not in the map, get feature from service
        return queryOneFeature();
    }
    return mapView.whenLayerView(layer).then((layerView) => {
        if ((layer.type === "feature" && !layer.url) || layer.type === "wfs") {
            // feature collection or wfs
            const query = layer.createQuery();
            query.start = 0;
            query.num = 5;
            query.outFields = ["*"];
            return layer.queryFeatures(query).then((result) => {
                if (result.features && result.features.length) {
                    return Promise.resolve(result);
                }
                else {
                    return Promise.resolve(createOneFeature());
                }
            });
        }
        else {
            // service
            const hasM = "hasM" in layer && layer.hasM;
            const hasZ = "hasZ" in layer && layer.hasZ;
            const hasAllFields = layerView.availableFields.length === layer.fields.length && !hasM && !hasZ;
            if ("createQuery" in layer && hasAllFields) {
                // || (["stream", "ogc-feature"].indexOf(layer.type) > -1 && layerView.availableFields.length > 0)
                // features on client have all fields
                const query = layer.createQuery();
                query.start = 0;
                query.num = 5;
                query.outFields = ["*"];
                return layerView.queryFeatures(query).then((result) => {
                    if (result.features && result.features.length) {
                        // client side features
                        return Promise.resolve(result);
                    }
                    else {
                        // get feature from service
                        return queryOneFeature();
                    }
                });
            }
            else {
                // get feature from service
                return queryOneFeature();
            }
        }
    });
}
function queryOneFeature() {
    var _a, _b;
    const { layer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    /*
    // could maybe use layer.queryFeatures(query) instead???
    const queryTask = new QueryTask({ url: layer.url + "/" + layer.layerId });
    const query = new Query();
    query.where = "1=1";
    if (layer.sourceJSON?.advancedQueryCapabilities?.supportsPagination) {
      query.num = 1;
    }
    query.outFields = ["*"];
    query.outSpatialReference = mapView.spatialReference;
    query.returnGeometry = true;
    return queryTask.execute(query).then(
      (result: FeatureSet) => Promise.resolve(result),
      (error: Error) => {
        return Promise.resolve(createOneFeature());
      }
    );
    */
    if (!("queryFeatures" in layer)) {
        return Promise.resolve(createOneFeature());
    }
    const query = new modules.Query({
        outFields: ["*"],
        where: "1=1",
        outSpatialReference: mapView.spatialReference,
        returnGeometry: true,
        returnM: "hasM" in layer && layer.hasM,
        returnZ: "hasZ" in layer && layer.hasZ
    });
    if ("sourceJSON" in layer && ((_b = (_a = layer.sourceJSON) === null || _a === void 0 ? void 0 : _a.advancedQueryCapabilities) === null || _b === void 0 ? void 0 : _b.supportsPagination)) {
        query.num = 1;
    }
    return layer.queryFeatures(query).then((result) => Promise.resolve(result), () => {
        return Promise.resolve(createOneFeature());
    });
}
function createOneFeature() {
    const { layer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const attributes = {};
    if ("fields" in layer) {
        layer.fields.forEach((field) => {
            if (field.defaultValue) {
                attributes[field.name] = field.defaultValue;
            }
            else {
                if (["small-integer", "big-integer", "integer", "single", "double", "long", "date", "oid"].indexOf(field.type) > -1) {
                    attributes[field.name] = 0;
                }
                else if (field.type === "date-only") {
                    attributes[field.name] = null;
                }
                else {
                    attributes[field.name] = "";
                }
            }
        });
    }
    const graphic = new modules.Graphic({
        geometry: undefined,
        symbol: undefined,
        attributes: attributes
    });
    const featureSet = new modules.FeatureSet({
        features: [graphic],
        fields: [],
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer),
        spatialReference: "spatialReference" in layer && layer.spatialReference.clone()
    });
    return featureSet;
}



//# sourceMappingURL=feature-1ce1b984.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fZmVhdHVyLWM0NmMyNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDMk47QUFDeEw7QUFDQTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQyxFQUFFLCtEQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxnQkFBZ0IsbUVBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUFnQjtBQUMxQztBQUNBLDhCQUE4QiwrREFBZ0I7QUFDOUM7QUFDQSxrQ0FBa0MsK0RBQWdCO0FBQ2xELGtDQUFrQywrREFBZ0I7QUFDbEQsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLFFBQVEsRUFBRSwrREFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVUsRUFBRSwrREFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQixFQUFFLCtEQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCLEVBQUUsK0RBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBYTtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtRUFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQWM7QUFDbkM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0NBQStDLEVBQUUsK0RBQWlCO0FBQzlFLDREQUE0RCwrREFBTTtBQUNsRTtBQUNBLFFBQVEsK0RBQWlCO0FBQ3pCLFFBQVEsK0RBQWlCLHVHQUF1RywrREFBTSxXQUFXLCtEQUFNO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DLEVBQUUsK0RBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsRUFBRSwrREFBaUI7QUFDekQ7QUFDQTtBQUNBLHNDQUFzQyxzQ0FBc0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxpQkFBaUIsRUFBRSwrREFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtRUFBZTtBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVnQzs7QUFFaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9mZWF0dXJlLTFjZTFiOTg0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgTyBhcyBhZGRGaWVsZHNUb091dEZpZWxkcywgdyBhcyBzaW1wbGVGaWVsZFR5cGVzLCBzIGFzIHNtYXJ0TWFwcGluZ1N0YXRlLCBxIGFzIGlzUG9seWdvblR5cGUsIEEgYXMgaXNQb2ludFR5cGUsIEIgYXMgaXNQb2x5bGluZVR5cGUsIGIgYXMgc3RhdHVzLCBEIGFzIGdldEdlb21ldHJ5VHlwZSB9IGZyb20gJy4vcmFzdGVyLXVuaXF1ZS12YWx1ZS0wOTc2ZWM3Zi5qcyc7XG5pbXBvcnQgJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0ICcuL2NvbW1vbkVudW1zLWZjZjEzNjYxLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIEFyY2FkZSBFZGl0b3JcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXNlQXJjYWRlRWRpdG9yKGZpZWxkSW5mbykge1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIHN0cmluZ3MsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBjb25zdCBkZWZhdWx0RXhwcmVzc2lvblNjcmlwdCA9IFwiLy8gXCIgK1xuICAgICAgICBzdHJpbmdzLmFyY2FkZS5kZWZhdWx0RXhwcmVzc2lvblNjcmlwdF9saW5lMSArXG4gICAgICAgIFwiXFxyXFxuLy8gXCIgK1xuICAgICAgICBzdHJpbmdzLmFyY2FkZS5kZWZhdWx0RXhwcmVzc2lvblNjcmlwdF9saW5lMiArXG4gICAgICAgIFwiXFxyXFxuLy8gUm91bmQoKCRmZWF0dXJlLm9ha19jb3VudCAvICRmZWF0dXJlLmFsbF90cmVlc19jb3VudCkgKiAxMDAsIDIpXFxyXFxuXFxyXFxuXCI7XG4gICAgY29uc3QgYXJjYWRlRWRpdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1tb2RhbC1hcmNhZGVcIik7XG4gICAgYXJjYWRlRWRpdG9yLmFyY2FkZVNjcmlwdCA9IChmaWVsZEluZm8gPT09IG51bGwgfHwgZmllbGRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZEluZm8uZXhwcmVzc2lvbikgfHwgZGVmYXVsdEV4cHJlc3Npb25TY3JpcHQ7XG4gICAgYXJjYWRlRWRpdG9yLmFyY2FkZVByb2ZpbGUgPSBnZXRBcmNhZGVQcm9maWxlKCk7XG4gICAgYXJjYWRlRWRpdG9yLnRlc3REYXRhID0gYXdhaXQgZ2V0QXJjYWRlVGVzdERhdGEoKTtcbiAgICBhcmNhZGVFZGl0b3IuYWRkRXhpc3RpbmdFeHByZXNzaW9ucyA9IHRydWU7XG4gICAgYXJjYWRlRWRpdG9yLmxheWVyID0gbGF5ZXI7IC8vIFN0cmVhbUxheWVyIGlzIG1pc3NpbmdcbiAgICBhcmNhZGVFZGl0b3IuYXJjYWRlVGl0bGUgPSAoZmllbGRJbmZvID09PSBudWxsIHx8IGZpZWxkSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGRJbmZvLmV4cHJlc3Npb25UaXRsZSkgfHwgc3RyaW5ncy5hcmNhZGUubmV3RXhwcmVzc2lvbjtcbiAgICBhcmNhZGVFZGl0b3IuYXJjYWRlVGl0bGVFZGl0YWJsZSA9IHRydWU7XG4gICAgYXJjYWRlRWRpdG9yLmFyY2FkZVRpdGxlRWRpdGluZ0VuYWJsZWQgPSAhKGZpZWxkSW5mbyA9PT0gbnVsbCB8fCBmaWVsZEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkSW5mby5leHByZXNzaW9uVGl0bGUpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYXJjYWRlRWRpdG9yKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhcmNhZGVFZGl0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc01vZGFsQXJjYWRlQ2xvc2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYXJjZ2lzTW9kYWxBcmNhZGVDbG9zZVwiLCBldmVudC5kZXRhaWwpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhcmNhZGVFZGl0b3IpO1xuICAgICAgICAgICAgaWYgKCFldmVudC5kZXRhaWwpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHNjcmlwdCwgdGl0bGUsIHByZWRpY3RPdXRwdXRUeXBlIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICBpZiAoIXNjcmlwdCB8fCBzY3JpcHQgPT09IGRlZmF1bHRFeHByZXNzaW9uU2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGxheWVyIGdldHMgbmVlZGVkIGZpZWxkczsgV0ZTTGF5ZXIgaXMgbWlzc2luZ1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZXMuZmllbGRVdGlscy5nZXRFeHByZXNzaW9uRmllbGRzKGxheWVyLCBbc2NyaXB0XSkudGhlbigob3V0RmllbGRzKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkRmllbGRzVG9PdXRGaWVsZHMob3V0RmllbGRzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc2NyaXB0LFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uVGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBzaW1wbGVGaWVsZFR5cGU6IHByZWRpY3RPdXRwdXRUeXBlID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHByZWRpY3RPdXRwdXRUeXBlID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzaW1wbGVGaWVsZFR5cGVzLlNUUklOR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcHJlZGljdE91dHB1dFR5cGUgPT09IFwiZGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2ltcGxlRmllbGRUeXBlcy5OVU1CRVIgLy8gREFURSAtIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzaW1wbGVGaWVsZFR5cGVzLlVOS05PV05cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFyY2FkZVByb2ZpbGUoKSB7XG4gICAgY29uc3QgeyBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IFwidmlzdWFsaXphdGlvblwiLFxuICAgICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3RlOiB0aGVyZSBhcmUgbm8gY3VycmVudCBvZmZpY2lhbCBwbGFucyB0byBzdXBwb3J0IEFyY2FkZVxuICAgICAgICAgICAgICogZm9yIE9yaWVudGVkIEltYWdlcnkgbGF5ZXJzLCBldmVuIHRob3VnaCB0aGlzIGJ1dHRvbiBpc1xuICAgICAgICAgICAgICogc2hvd24gYW5kIGZ1bmN0aW9ucyBwcm9wZXJseVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAkZmVhdHVyZTogbGF5ZXJcbiAgICAgICAgfVxuICAgIH07XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBcmNhZGVUZXN0RGF0YSgpIHtcbiAgICBjb25zdCB7IG1hcFZpZXcgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb2ZpbGVWYXJpYWJsZUluc3RhbmNlczoge1xuICAgICAgICAgICAgJGZlYXR1cmU6IGF3YWl0IGdldE9uZUFyY2FkZUZlYXR1cmUoKSxcbiAgICAgICAgICAgICR2aWV3OiB7XG4gICAgICAgICAgICAgICAgc2NhbGU6IG1hcFZpZXcuc2NhbGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3BhdGlhbFJlZmVyZW5jZTogbWFwVmlldy5zcGF0aWFsUmVmZXJlbmNlXG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldE9uZUFyY2FkZUZlYXR1cmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGxldCBmZWF0dXJlO1xuICAgIGlmICghKFwiZmllbGRzXCIgaW4gbGF5ZXIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXdhaXQgZ2V0T25lRmVhdHVyZSgpO1xuICAgICAgICBjb25zdCB7IG9uZUZlYXR1cmVSZXNwb25zZSB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgICAgIGlmICgoX2EgPSBvbmVGZWF0dXJlUmVzcG9uc2UgPT09IG51bGwgfHwgb25lRmVhdHVyZVJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbmVGZWF0dXJlUmVzcG9uc2UuZmVhdHVyZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZlYXR1cmUgPSBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKG9uZUZlYXR1cmVSZXNwb25zZS5mZWF0dXJlc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGZlYXR1cmVcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIGxheWVyLmZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChbXG4gICAgICAgICAgICAgICAgICAgIFwic21hbGwtaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImJpZy1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNpbmdsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRvdWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRlLW9ubHlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvaWRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJndWlkXCJcbiAgICAgICAgICAgICAgICBdLmluZGV4T2YoZmllbGQudHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQubnVsbGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1tmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2ZpZWxkLm5hbWVdID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbZmllbGQubmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1tmaWVsZC5uYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbZmllbGQubmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gbWFrZSB1cCBzb21lIGdlb21ldHJ5IHVzaW5nIHRoZSBtYXAgZXh0ZW50XG4gICAgICAgICAgICBjb25zdCBleHQgPSBtYXBWaWV3LmV4dGVudDtcbiAgICAgICAgICAgIGxldCBnZW9tZXRyeSwgc3ltYm9sO1xuICAgICAgICAgICAgaWYgKGlzUG9seWdvblR5cGUobGF5ZXIpIC8qIHx8IGxheWVyLmdldEN1c3RvbVJhc3RlckZpZWxkcyAqLykge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IG1vZHVsZXMuUG9seWdvbih7XG4gICAgICAgICAgICAgICAgICAgIHNwYXRpYWxSZWZlcmVuY2U6IG5ldyBtb2R1bGVzLlNwYXRpYWxSZWZlcmVuY2UobWFwVmlldy5zcGF0aWFsUmVmZXJlbmNlLnRvSlNPTigpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmFkZFJpbmcoW1xuICAgICAgICAgICAgICAgICAgICBbZXh0LnhtaW4sIGV4dC55bWluXSxcbiAgICAgICAgICAgICAgICAgICAgW2V4dC54bWF4LCBleHQueW1pbl0sXG4gICAgICAgICAgICAgICAgICAgIFtleHQueG1heCwgZXh0LnltYXhdLFxuICAgICAgICAgICAgICAgICAgICBbZXh0LnhtaW4sIGV4dC55bWF4XSxcbiAgICAgICAgICAgICAgICAgICAgW2V4dC54bWluLCBleHQueW1pbl1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBuZXcgbW9kdWxlcy5TaW1wbGVMaW5lU3ltYm9sKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1BvaW50VHlwZShsYXllcikpIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBtb2R1bGVzLlBvaW50KGV4dC5jZW50ZXIudG9KU09OKCkpO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBtb2R1bGVzLlNpbXBsZU1hcmtlclN5bWJvbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQb2x5bGluZVR5cGUobGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgbW9kdWxlcy5Qb2x5bGluZSh7XG4gICAgICAgICAgICAgICAgICAgIHNwYXRpYWxSZWZlcmVuY2U6IG5ldyBtb2R1bGVzLlNwYXRpYWxSZWZlcmVuY2UobWFwVmlldy5zcGF0aWFsUmVmZXJlbmNlLnRvSlNPTigpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmFkZFBhdGgoW1xuICAgICAgICAgICAgICAgICAgICBbZXh0LnhtaW4sIGV4dC55bWluXSxcbiAgICAgICAgICAgICAgICAgICAgW2V4dC54bWF4LCBleHQueW1heF1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBuZXcgbW9kdWxlcy5TaW1wbGVGaWxsU3ltYm9sKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmZWF0dXJlID0gbmV3IG1vZHVsZXMuR3JhcGhpYyh7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnksXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE9uZUZlYXR1cmUoKSB7XG4gICAgY29uc3QgeyBvbmVGZWF0dXJlUmVzcG9uc2UsIG9uZUZlYXR1cmVSZXNwb25zZVN0YXR1cyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgaWYgKCFvbmVGZWF0dXJlUmVzcG9uc2UgfHwgb25lRmVhdHVyZVJlc3BvbnNlU3RhdHVzID09PSBzdGF0dXMuTUlTU0lORykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBfZ2V0T25lRmVhdHVyZSgpO1xuICAgICAgICBzbWFydE1hcHBpbmdTdGF0ZS5vbmVGZWF0dXJlUmVzcG9uc2UgPSAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmZlYXR1cmVzLmxlbmd0aCkgJiYgcmVzdWx0O1xuICAgICAgICBzbWFydE1hcHBpbmdTdGF0ZS5vbmVGZWF0dXJlUmVzcG9uc2VTdGF0dXMgPSAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmZlYXR1cmVzLmxlbmd0aCkgPyBzdGF0dXMuU1VDQ0VTUyA6IHN0YXR1cy5GQUlMRUQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc21hcnRNYXBwaW5nU3RhdGUub25lRmVhdHVyZVJlc3BvbnNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9nZXRPbmVGZWF0dXJlKCkge1xuICAgIGNvbnN0IHsgbWFwVmlldywgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGlmICghKFwiZmllbGRzXCIgaW4gbGF5ZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcImdldE9uZUZlYXR1cmU6IHdyb25nIGxheWVyIHR5cGVcIik7XG4gICAgfVxuICAgIGlmIChtYXBJbWFnZVN1YmxheWVyKSB7XG4gICAgICAgIC8vIGxheWVyIGlzIG5vdCBpbiB0aGUgbWFwLCBnZXQgZmVhdHVyZSBmcm9tIHNlcnZpY2VcbiAgICAgICAgcmV0dXJuIHF1ZXJ5T25lRmVhdHVyZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwVmlldy53aGVuTGF5ZXJWaWV3KGxheWVyKS50aGVuKChsYXllclZpZXcpID0+IHtcbiAgICAgICAgaWYgKChsYXllci50eXBlID09PSBcImZlYXR1cmVcIiAmJiAhbGF5ZXIudXJsKSB8fCBsYXllci50eXBlID09PSBcIndmc1wiKSB7XG4gICAgICAgICAgICAvLyBmZWF0dXJlIGNvbGxlY3Rpb24gb3Igd2ZzXG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IGxheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgICAgICAgICBxdWVyeS5zdGFydCA9IDA7XG4gICAgICAgICAgICBxdWVyeS5udW0gPSA1O1xuICAgICAgICAgICAgcXVlcnkub3V0RmllbGRzID0gW1wiKlwiXTtcbiAgICAgICAgICAgIHJldHVybiBsYXllci5xdWVyeUZlYXR1cmVzKHF1ZXJ5KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmZlYXR1cmVzICYmIHJlc3VsdC5mZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVPbmVGZWF0dXJlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2VydmljZVxuICAgICAgICAgICAgY29uc3QgaGFzTSA9IFwiaGFzTVwiIGluIGxheWVyICYmIGxheWVyLmhhc007XG4gICAgICAgICAgICBjb25zdCBoYXNaID0gXCJoYXNaXCIgaW4gbGF5ZXIgJiYgbGF5ZXIuaGFzWjtcbiAgICAgICAgICAgIGNvbnN0IGhhc0FsbEZpZWxkcyA9IGxheWVyVmlldy5hdmFpbGFibGVGaWVsZHMubGVuZ3RoID09PSBsYXllci5maWVsZHMubGVuZ3RoICYmICFoYXNNICYmICFoYXNaO1xuICAgICAgICAgICAgaWYgKFwiY3JlYXRlUXVlcnlcIiBpbiBsYXllciAmJiBoYXNBbGxGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAvLyB8fCAoW1wic3RyZWFtXCIsIFwib2djLWZlYXR1cmVcIl0uaW5kZXhPZihsYXllci50eXBlKSA+IC0xICYmIGxheWVyVmlldy5hdmFpbGFibGVGaWVsZHMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAvLyBmZWF0dXJlcyBvbiBjbGllbnQgaGF2ZSBhbGwgZmllbGRzXG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBsYXllci5jcmVhdGVRdWVyeSgpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5LnN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBxdWVyeS5udW0gPSA1O1xuICAgICAgICAgICAgICAgIHF1ZXJ5Lm91dEZpZWxkcyA9IFtcIipcIl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxheWVyVmlldy5xdWVyeUZlYXR1cmVzKHF1ZXJ5KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5mZWF0dXJlcyAmJiByZXN1bHQuZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQgc2lkZSBmZWF0dXJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGZlYXR1cmUgZnJvbSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlPbmVGZWF0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdldCBmZWF0dXJlIGZyb20gc2VydmljZVxuICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeU9uZUZlYXR1cmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcXVlcnlPbmVGZWF0dXJlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBsYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgLypcbiAgICAvLyBjb3VsZCBtYXliZSB1c2UgbGF5ZXIucXVlcnlGZWF0dXJlcyhxdWVyeSkgaW5zdGVhZD8/P1xuICAgIGNvbnN0IHF1ZXJ5VGFzayA9IG5ldyBRdWVyeVRhc2soeyB1cmw6IGxheWVyLnVybCArIFwiL1wiICsgbGF5ZXIubGF5ZXJJZCB9KTtcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSgpO1xuICAgIHF1ZXJ5LndoZXJlID0gXCIxPTFcIjtcbiAgICBpZiAobGF5ZXIuc291cmNlSlNPTj8uYWR2YW5jZWRRdWVyeUNhcGFiaWxpdGllcz8uc3VwcG9ydHNQYWdpbmF0aW9uKSB7XG4gICAgICBxdWVyeS5udW0gPSAxO1xuICAgIH1cbiAgICBxdWVyeS5vdXRGaWVsZHMgPSBbXCIqXCJdO1xuICAgIHF1ZXJ5Lm91dFNwYXRpYWxSZWZlcmVuY2UgPSBtYXBWaWV3LnNwYXRpYWxSZWZlcmVuY2U7XG4gICAgcXVlcnkucmV0dXJuR2VvbWV0cnkgPSB0cnVlO1xuICAgIHJldHVybiBxdWVyeVRhc2suZXhlY3V0ZShxdWVyeSkudGhlbihcbiAgICAgIChyZXN1bHQ6IEZlYXR1cmVTZXQpID0+IFByb21pc2UucmVzb2x2ZShyZXN1bHQpLFxuICAgICAgKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZU9uZUZlYXR1cmUoKSk7XG4gICAgICB9XG4gICAgKTtcbiAgICAqL1xuICAgIGlmICghKFwicXVlcnlGZWF0dXJlc1wiIGluIGxheWVyKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZU9uZUZlYXR1cmUoKSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IG1vZHVsZXMuUXVlcnkoe1xuICAgICAgICBvdXRGaWVsZHM6IFtcIipcIl0sXG4gICAgICAgIHdoZXJlOiBcIjE9MVwiLFxuICAgICAgICBvdXRTcGF0aWFsUmVmZXJlbmNlOiBtYXBWaWV3LnNwYXRpYWxSZWZlcmVuY2UsXG4gICAgICAgIHJldHVybkdlb21ldHJ5OiB0cnVlLFxuICAgICAgICByZXR1cm5NOiBcImhhc01cIiBpbiBsYXllciAmJiBsYXllci5oYXNNLFxuICAgICAgICByZXR1cm5aOiBcImhhc1pcIiBpbiBsYXllciAmJiBsYXllci5oYXNaXG4gICAgfSk7XG4gICAgaWYgKFwic291cmNlSlNPTlwiIGluIGxheWVyICYmICgoX2IgPSAoX2EgPSBsYXllci5zb3VyY2VKU09OKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWR2YW5jZWRRdWVyeUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN1cHBvcnRzUGFnaW5hdGlvbikpIHtcbiAgICAgICAgcXVlcnkubnVtID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxheWVyLnF1ZXJ5RmVhdHVyZXMocXVlcnkpLnRoZW4oKHJlc3VsdCkgPT4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCksICgpID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVPbmVGZWF0dXJlKCkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlT25lRmVhdHVyZSgpIHtcbiAgICBjb25zdCB7IGxheWVyLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKFwiZmllbGRzXCIgaW4gbGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1tmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChbXCJzbWFsbC1pbnRlZ2VyXCIsIFwiYmlnLWludGVnZXJcIiwgXCJpbnRlZ2VyXCIsIFwic2luZ2xlXCIsIFwiZG91YmxlXCIsIFwibG9uZ1wiLCBcImRhdGVcIiwgXCJvaWRcIl0uaW5kZXhPZihmaWVsZC50eXBlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbZmllbGQubmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC50eXBlID09PSBcImRhdGUtb25seVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbZmllbGQubmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1tmaWVsZC5uYW1lXSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZ3JhcGhpYyA9IG5ldyBtb2R1bGVzLkdyYXBoaWMoe1xuICAgICAgICBnZW9tZXRyeTogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2w6IHVuZGVmaW5lZCxcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlc1xuICAgIH0pO1xuICAgIGNvbnN0IGZlYXR1cmVTZXQgPSBuZXcgbW9kdWxlcy5GZWF0dXJlU2V0KHtcbiAgICAgICAgZmVhdHVyZXM6IFtncmFwaGljXSxcbiAgICAgICAgZmllbGRzOiBbXSxcbiAgICAgICAgZ2VvbWV0cnlUeXBlOiBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpLFxuICAgICAgICBzcGF0aWFsUmVmZXJlbmNlOiBcInNwYXRpYWxSZWZlcmVuY2VcIiBpbiBsYXllciAmJiBsYXllci5zcGF0aWFsUmVmZXJlbmNlLmNsb25lKClcbiAgICB9KTtcbiAgICByZXR1cm4gZmVhdHVyZVNldDtcbn1cblxuZXhwb3J0IHsgdXNlQXJjYWRlRWRpdG9yIGFzIHUgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmVhdHVyZS0xY2UxYjk4NC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=