"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-80e72e"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.nl-bb99c2fc.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.nl-bb99c2fc.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "OK";
const cancel = "Afbreken";
const enterURL = "Imageservice URL invoeren";
const serviceURL = "Service-URL";
const selectRaster = "Raster selecteren";
const failedToLoadLayer = "Kaartlaag laden mislukt";
const loadingLayer = "Kaartlaag laden";
const selectFeature = "Objectlaag selecteren";
const enterFURL = "Featureservice URL invoeren";
const addRaster = "Rastervariabele toevoegen";
const addScalar = "Constante toevoegen";
const raster = "Raster";
const scalar = "Scalair";
const defaultModelName = "Template rasterfunctie";
const general = "Algemeen";
const parameters = "Parameters";
const variables = "Variabelen";
const name = "Naam";
const description = "Beschrijving";
const parameter = "Parameter";
const isPublic = "IsOpenbaar";
const isDataset = "IsDataset";
const unknownPixelType = "Onbekend";
const outputPixelType = "Uitvoerpixeltype";
const u8PixelType = "8 bits niet-ondertekend";
const s8PixelType = "8 bits ondertekend";
const u16PixelType = "16 bits niet-ondertekend";
const s16PixelType = "16 bits ondertekend";
const u32PixelType = "32 bits niet-ondertekend";
const s32PixelType = "32 bits ondertekend";
const f32PixelType = "32 bits zwevend";
const f64PixelType = "64 bits dubbel";
const properties = "Eigenschappen";
const multidimensionalRules = "Multidimensionale Regels";
const matchVariables = "Overeenkomstvariabelen";
const unionDimensions = "Verenigingsdimensies";
const rasterFunctionEditor = {
	invalidRFTMessage: "De rasterfunctietemplate is niet geldig.",
	rfxArgsEditor: {
		outputRaster: "OutputRaster",
		raster: "Raster",
		unsupportedDataTypeWarning: "De volgende argumenten worden niet weergegeven omdat ze momenteel niet worden ondersteund.",
		unsupportedFunction: "Bevat momenteel ondersteunde rasterfuncties."
	},
	rfxRasterInput: {
		selectLayer: "Kaartlaag selecteren",
		browseLayers: "Blader door lagen",
		rfxVariable: "RasterFunctieVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Methode",
		bandLabel: "Band",
		combinationLabel: "Combinatie"
	},
	rfxRemapGrid: {
		minimum: "Minimum",
		maximum: "Maximum",
		output: "Uitvoer",
		noData: "NoData",
		remapValuesLabel: "Waarden opnieuw bepalen"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Rastervariabelen",
		deleteSelectedVars: "Geselecteerde variabelen verwijderen"
	},
	rfxClippingGeometry: {
		clippingLayer: "Kaartlaag knippen",
		clippingRaster: "Raster knippen",
		clippingGeometry: "Geometrie bijsnijden",
		customExtent: "Aangepaste extent",
		outputExtent: "Uitvoerextent",
		currentExtent: "Huidige kaartextent",
		drawLabel: "Tekenen"
	},
	rfxCustomExtent: {
		top: "Boven",
		right: "Rechts",
		bottom: "Onder",
		left: "Links"
	},
	rfxRasterArrayEditor: {
		moveUp: "Naar boven verplaatsen",
		moveDown: "Naar beneden verplaatsen",
		remove: "Verwijderen"
	},
	rfxStatisticsGrid: {
		stdDev: "Std. Afw",
		min: "Min",
		max: "Max",
		mean: "Mediaan"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Gewogen Somtabel",
		id: "ID",
		layer: "Kaartlaag",
		field: "Veld",
		weight: "Gewicht",
		value: "Waarde",
		selectLayer: "Kaartlaag selecteren"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Weighted Overlay-tabel",
		id: "ID",
		layer: "Kaartlaag",
		field: "Veld",
		influence: "Invloed",
		sumOfInfluence: "Som van invloed",
		value: "Waarde",
		remapTable: "Remaptabel",
		scale: "Schaal",
		scales: "Schalen",
		selectRaster: "Raster selecteren"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Bladeren naar een objectlaag",
		addPointLayer: "Bladeren naar een puntlaag"
	},
	rfxFieldSelect: {
		value: "Waarde",
		count: "Aantal"
	},
	rfxAttributeTable: {
		tableType: "Tabeltype",
		manual: "Handmatig",
		external: "Extern",
		minVal: "Minimumwaarde",
		maxVal: "Maximumwaarde",
		baseClassName: "Klasse basisnaam",
		colorScheme: "Kleurenschema",
		defaultClassName: "Label_",
		generateTable: "Tabel genereren",
		browseTable: "Tabel Bekijken",
		value: "Waarde",
		classname: "Klassenaam",
		color: "Kleur"
	},
	rfxFieldNumberSwitchable: {
		number: "Numeriek",
		field: "Veld",
		string: "Tekenreeks",
		linearUnit: "Lineaire eenheid"
	},
	rfxPropertySet: {
		name: "Naam",
		value: "Waarde"
	},
	rfxConversionGrid: {
		size: "Grootte"
	},
	rfxTransposeBit: {
		bitPattern: "Bitpatroon",
		outputBit: "Uitvoerbit",
		inputBit: "Invoerbit"
	},
	rfxSpatialReference: {
		placeHolder: "Verfijnen op trefwoord",
		coordinateSystem: "Coördinatensysteem",
		gcs: "Geografisch coördinaatsysteem",
		pcs: "Geprojecteerd coördinaatsysteem",
		vcs: "Verticaal coördinaatsysteem"
	}
};
const rfxLicenseInfo = "Deze rasterfunctietemplate kan worden gebruikt om uw satellietbeelden te verwerken met behulp van ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "ACosH",
		aCosHSnip: "Berekent de inverse hyperbole cosinus van cellen in een raster.",
		aCosHDesc: "De functie berekent de inverse hyperbole cosinus van de pixels in een raster.",
		aCosName: "ACos",
		aCosSnip: "Berekent de inverse cosinus van de pixels in een raster.",
		aCosDesc: "Deze rasterfunctie berekent de arccosinus van cellen in een raster. In de wiskunde hebben alle trigonometrische functies een gedefinieerd bereik van geldige invoerwaarden, het domein genoemd. De uitvoerwaarden van elke functie hebben ook een gedefinieerd bereik. Voor deze tool is het domein [-1, 1] en het bereik is [0, pi].",
		aSinHName: "ASinH",
		aSinHSnip: "Berekent de inverse hyperbole sinus van cellen in een raster.",
		aSinHDesc: "De functie berekent de inverse hyperbole sinus van de pixels in een raster.",
		aSinName: "ASin",
		aSinSnip: "Berekent de inverse sinus van cellen in een raster.",
		aSinDesc: "De functie berekent de inverse sinus van de pixels in een raster.",
		aTan2Name: "ATan2",
		aTan2Snip: "Berekent de inverse tangens (gebaseerd op x,y) van cellen in een raster.",
		aTan2Desc: "De functie berekent de inverse tangens (gebaseerd op x,y) van de pixels in een raster.",
		aTanHName: "ATanH",
		aTanHSnip: "Berekent de inverse hyperbole tangens van cellen in een raster.",
		aTanHDesc: "De functie berekent de inverse hyperbole tangens van de pixels in een raster.",
		aTanName: "ATan",
		aTanSnip: "Berekent de inverse tangens van cellen in een raster.",
		aTanDesc: "De functie berekent de inverse tangens van de pixels in een raster.",
		absName: "Abs",
		absSnip: "Berekent de absolute waarde van de cellen in een raster.",
		absDesc: "De Abs-functie berekent de absolute waarde van de pixels in een raster.",
		reflectanceName: "Schijnbare reflectie",
		reflectanceSnip: "Zet onbewerkte beelden om in waarden voor Top of Atmosphere door rekening te houden met sensoreigenschappen, de positie van de zon en de acquisitietijd.",
		reflectanceDesc: "Met deze functie worden de waarden voor het digitale aantal (DN) van de beeldhelderheid aangepast voor sommige satellietsensoren. De aanpassingen zijn gebaseerd op de hoogte van de zon, de opnamedatum en de sensoreigenschappen om de versterking en bias in te stellen voor elke band. Deze functie wordt gebruikt om de reflectantie- of helderheidswaarden van sommige satellietbeelden aan te passen op basis van de scèneverlichting en sensorversterkingsinstellingen. De afbeeldingen zijn aangepast aan een theoretisch gebruikelijke belichtingsvoorwaarde, dus er moet minder variatie zijn tussen scenes van verschillende data en verschillende sensoren. Dit kan handig zijn voor beeldclassificatie, kleurbalans en mozaïeken. Deze functie kan alleen worden gebruikt met specifieke afbeeldingen. De toepasselijke sensoren zijn Landsat MSS, Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 en Pleiades.<div><br/>De functie voert twee correcties uit. De eerste is gebaseerd op de versterkingsinstellingen. De oorspronkelijke helderheidswaarden worden opnieuw gemaakt uit de afbeeldingswaarden door de versterkingsvergelijkingen om te keren. De tweede correctie heeft te maken met verschillen in zonhoek en helderheid. De oorspronkelijke helderheidswaarden worden aangepast aan gewone lichtomstandigheden door scenes te normaliseren die zijn vastgelegd onder variabele belichtingsomstandigheden. In het algemeen geldt dat, hoewel het gegevenstype van de uitvoerafbeelding hetzelfde is als het gegevenstype van de invoerafbeelding, de uitvoerwaarden lager zijn dan de invoerwaarden en worden bijgesneden naar het geldige gegevensbereik.</div>",
		argStatisticsName: "ArgStatistieken",
		argStatisticsSnip: "Berekent argstatistieken inclusief Arg Max, Arg Min, Arg Median en Duration.",
		argStatisticsDesc: "De functie berekent arg-statistieken. Er zijn vier methoden in de ArgStatistics-functie: ArgMax, ArgMin, ArgMedian en Duration.",
		arithmeticName: "Rekenkundig",
		arithmeticSnip: "Voert een rekenkundige bewerking uit tussen twee rasters of een raster en een scalair.",
		arithmeticDesc: "De rekenkundige functie voert een rekenkundige bewerking uit tussen twee rasters of een raster en een scalair en omgekeerd.",
		aspectSlopeName: "Aspect-Helling",
		aspectSlopeSnip: "Creëert een raster dat tegelijkertijd het aspect (richting) en de helling (steilheid) van een continu oppervlak weergeeft, zoals weergegeven in een digitaal hoogtemodel.",
		aspectSlopeDesc: "De functie Aspect Slope creëert een rasterlaag die tegelijkertijd het aspect en de helling van een oppervlak weergeeft. Aspect identificeert de richting bergafwaarts van de maximale mate van verandering in waarde van elke pixel tot de buurcellen. Aspect kan worden gezien als de hellingrichting. De waarden van de uitgaande raster zal de kompasrichting van het aspect zijn, weergegeven door een tint (kleur). Helling geeft de mate van verandering in de hoogte weer voor elke pixel van het digitaal elevatiemodel (DEM). Helling geeft de steilte van het oppervlak weer en wordt gesymboliseerd in drie klassen die worden weergegeven met behulp van kleurverzadiging (helderheid).<div><br/>De pixelwaarden in het uitvoeraspect-hellingsraster weerspiegelen een combinatie van aspect en helling. Pixels met waarden onder 20 worden als plat beschouwd en worden grijs weergegeven. Aspect-hellingwaarden van 21 en hoger worden als volgt weergegeven met variërende verzadiging: 21 tot 30 —Lage hellingsverzadiging, 31 tot 40—Gemiddelde hellingsverzadiging, 41 en hoger—Hoge hellingsverzadiging</div>",
		aspectName: "Aspect",
		aspectSnip: "Geeft aan in welke richting een pixel wordt weergegeven, waarbij 0 richting het noorden ligt en de hoeken met de klok mee toenemen tot 360.",
		aspectDesc: "De functie Aspect identificeert de richting bergafwaarts van de maximale mate van verandering in waarde van elke cel tot de buurcellen. Aspect kan worden gezien als de hellingrichting. De waarden van de uitvoerraster zal de kompasrichting van het aspect zijn.<div><br/>De invoer voor deze functie is Invoerraster. De aspectfunctie wordt vaak toegepast op een digitaal hoogtemodel (DEM). Standaard wordt het aspect weergegeven als een grijswaardenafbeelding. U kunt de functie Colormap toevoegen om een bepaald kleurenschema op te geven of de persoon die het mozaïek bekijkt, toestaan de symbologie met zijn eigen kleurenschema te wijzigen.</div>",
		tableName: "Attribuuttabel",
		tableSnip: "Gebruikt een tabel om de waarden in een dataset te benoemen en te symboliseren. Kolommen voor de tabel zijn door komma's gescheiden: PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "Met de functie Attribuuttabel kunt u een attribuuttabel definiëren om een mozaïekdataset of rasterdataset met één band te symboliseren. <div><br/>Dit is handig wanneer u afbeeldingen wilt presenteren die een classificatie hebben ondergaan voor landgebruik, zoals bosland, wetlands, akkerland en stedelijk gebied. Als uw tabel velden met de namen rood, groen en blauw bevat, worden de waarden in die velden ook als een kleurenschema gebruikt bij het renderen van de afbeelding.</div>",
		bandArithmeticName: "Band rekenkundig",
		bandArithmeticSnip: "Berekent indexen met vooraf gedefinieerde formules of een door de gebruiker gedefinieerde expressie.",
		bandArithmeticDesc: "De functie Band rekenkundig voert een rekenkundige bewerking uit op de banden van een rasterdataset. U kunt vooraf gedefinieerde algoritmen kiezen of u kunt uw eigen formule met één regel invoeren. De ondersteunde operators zijn -, +, /, * en unary -.",
		thresholdName: "Binaire drempel",
		thresholdSnip: "Organiseert continue gegevens in de voorgrond en achtergrond door de covariantie tussen de twee klassen te minimaliseren.",
		thresholdDesc: "Wanneer een rasterdataset een bimodale verdeling heeft, maakt deze functie een nieuw raster dat de gegevens verdeelt in twee afzonderlijke klassen. Hiermee wordt een klasse met een lage waarde weergegeven met zwarte pixels en een klasse met een hoge waarde weergegeven met witte pixels.",
		bitwiseAndName: "Bitwise en",
		bitwiseAndSnip: "Voert een Bitwise en-bewerking uit op de binaire waarden van twee invoerrasters.",
		bitwiseAndDesc: "Bitwise en voert een Bitwise en-bewerking uit op de binaire waarden van twee invoerrasters",
		bitwiseLeftShiftName: "Bitwise verschuiving links",
		bitwiseLeftShiftSnip: "Voert een Bitwise verschuiving links-bewerking uit op de binaire waarden van twee invoerrasters.",
		bitwiseLeftShiftDesc: "Bitwise verschuiving links voert een Bitwise verschuiving links bewerking uit op de binaire waarden van twee invoerrasters",
		bitwiseNotName: "Bitwise Not",
		bitwiseNotSnip: "Voert een Bitwise Not (aanvulling)-bewerking uit op de binaire waarden van twee invoerrasters.",
		bitwiseNotDesc: "De functie voert een Bitwise Not-bewerking (aanvulling) uit op de binaire waarden van een invoerraster.",
		bitwiseOrName: "Bitwise of",
		bitwiseOrSnip: "Voert een Bitwise of-bewerking uit op de binaire waarden van twee invoerrasters.",
		bitwiseOrDesc: "De functie voert Bitwise of-bewerking uit op de binaire waarden van twee invoerrasters. ",
		bitwiseRightShiftName: "Bitwise verschuiving rechts",
		bitwiseRightShiftSnip: "Voert een Bitwise verschuiving rechts-bewerking uit op de binaire waarden van twee invoerrasters.",
		bitwiseRightShiftDesc: "De functie voert een Bitwise verschuiving rechts-bewerking uit op de binaire waarden van twee invoerrasters.",
		bitwiseXorName: "Bitwise Xof",
		bitwiseXorSnip: "Voert een Bitwise eXclusive Of-bewerking uit op de binaire waarden van twee invoerrasters.",
		bitwiseXorDesc: "De functie voert een Bitwise eXclusive Of-bewerking uit op de binaire waarden van twee invoerrasters",
		booleanAndName: "Boolean en",
		booleanAndSnip: "Voert een Boolean en-bewerking uit op de celwaarden van twee invoerrasters. Als beide invoerwaarden waar zijn (niet nul), is de uitvoerwaarde 1. Als één of beide invoeren niet waar zijn (nul), is de uitvoer 0.",
		booleanAndDesc: "De functie voert een Boolean en-bewerking uit op de pixelwaarden van twee ingangen. Als beide invoerwaarden waar zijn (niet nul), is de uitvoerwaarde 1. Als één of beide invoerwaarden niet waar zijn (nul), is de uitvoerwaarde 0. ",
		booleanNotName: "Boolean Not",
		booleanNotSnip: "Voert een Boolean Not-bewerking (aanvulling) uit op de celwaarden van het invoerraster. Als de invoerwaarden waar zijn (niet nul), is de uitvoerwaarde 0. Als de invoerwaarden niet waar zijn (nul), is de uitvoer 1.",
		booleanNotDesc: "De functie voert een Boolean Not-bewerking (aanvulling) uit op de pixelwaarden van het invoerraster. Als beide invoerwaarden waar zijn (niet nul), is de uitvoerwaarde 0. Als beide invoerwaarden niet waar zijn (nul), is de uitvoerwaarde 1.",
		booleanOrName: "Boolean of",
		booleanOrSnip: "Voert een Boolean Not-bewerking uit op de celwaarden van de twee invoerrasters. Als één of beide invoerwaarden waar zijn (niet nul), is de uitvoerwaarde 1. Als beide invoerwaarden niet waar zijn (nul), is de uitvoer 0.",
		booleanOrDesc: "De functie voert Boolean Not-bewerking uit op de celwaarden van twee invoerrasters. Als één of beide invoerwaarden waar zijn (niet nul), is de uitvoerwaarde 1. Als beide invoerwaarden niet waar zijn (nul), is de uitvoerwaarde 0.",
		booleanXorName: "Boolean Xof",
		booleanXorSnip: "Voert een Boolean eXclusive of-bewerking uit op de celwaarden van twee invoerrasters. Als één invoerwaarde waar is (niet nul) en de andere waarde is niet waar (nul), is de uitvoer 1. Als beide invoerwaarden waar of niet waar zijn, is de uitvoer 0.",
		booleanXorDesc: "De functie voert een Boolean of-bewerking uit op de celwaarden van twee invoerrasters. Als één invoerwaarde waar is (niet nul) en de andere waarde is niet waar (nul), is de uitvoerwaarde 1. Als beide invoerwaarden waar of niet waar zijn, is de uitvoerwaarde 0.",
		bufferedRasterName: "Gebufferd",
		bufferedRasterSnip: "Buffert de laatst benaderde pixelblok(ken).",
		bufferedRasterDesc: "De functie Gebufferd wordt gebruikt om de prestaties van complexe functieketens te optimaliseren. Het slaat de uitvoer op in het geheugen van het deel van de functieketen dat ervoor komt. <div><br/>Voeg deze functie toe in de Functie-editor waar u de uitvoer wilt opslaan.</div>",
		rasterCalculatorName: "Rekenmachine",
		rasterCalculatorSnip: "Berekent een raster van een op rasters gebaseerde rekenkundige expressie.",
		rasterCalculatorDesc: "Met de functie Rekenmachine kunt u expressies maken en uitvoeren en deze opnemen in functieketens.",
		cellStatisticsName: "Celstatistieken",
		cellStatisticsSnip: "Berekent statistieken per cel van meerdere rasters. De beschikbare statistieken zijn: meerderheid, maximum, gemiddelde, mediaan, minimum, minderheid, percentiel, bereik, standaardafwijking, som en variëteit.",
		cellStatisticsDesc: "Deze functie berekent statistieken van meerdere rasters, op een pixel-per-pixel basis. De beschikbare statistieken zijn: meerderheid, maximum, gemiddelde, mediaan, minimum, minderheid, bereik, standaardafwijking, som en variëteit.",
		classifyName: "Classificeren",
		classifySnip: "Wijst elke pixel toe aan een klasse. Voeg aanvullende gegevens toe, zoals een gesegmenteerde afbeelding.",
		classifyDesc: "Deze rasterfunctie classificeert een rasterdataset op basis van een Esri Classifier Definition (.ecd)-bestand en rasterdatasetinvoer. Het .ecd-bestand dat wordt gebruikt in de functie Classificeren bevat alle informatie voor een specifieke dataset en classifier en wordt gegenereerd door de classificatietools voor trainingen, zoals de Train Support Vector Machine of Train Random Trees-tools.",
		clipName: "Bijsnijden",
		clipSnip: "Stelt de mate van een raster in met behulp van coördinaten of een andere dataset.",
		clipDesc: "Met deze functie wordt een raster bijgesneden met behulp van een rechthoekige vorm volgens de gedefinieerde extensies of wordt een raster bijgesneden in de vorm van een objectklasse van een invoerpolygoon. De vorm die het bijsnijden definieert, kan de reikwijdte van het raster bijsnijden of een gebied in het raster bijsnijden.",
		colorspaceConversionName: "Kleurmodelconversie",
		colorspaceConversionSnip: "Converteert een raster van RGB naar HSV en omgekeerd.",
		colorspaceConversionDesc: "De functie Kleurmodelconversie converteert het kleurenmodel van een afbeelding van de tint-, verzadigings- en waarde (HSV) naar rood, groen en blauw (RGB) of omgekeerd.<div><br/>Deze functie kan worden gebruikt in een mozaïekgegevensset.</div>",
		colormapToRGBName: "Colormap naar RGB",
		colormapToRGBSnip: "Converteert een single-band raster met een Colormap naar een driebanden (rood, groen en blauw) raster.",
		colormapToRGBDesc: "Deze functie converteert een single-band raster met een Colormap naar een driebanden (rood, groen en blauw) raster.<div><br/>Deze functie is handig wanneer u een driebandsraster moet maken van een enkelbandraster met een bijbehorende Colormap. De waarden in de Colormap worden gebruikt om elke rode, groene en blauwe band te maken. Deze functie kan worden gebruikt in een mozaïekgegevensset.</div>",
		colormapName: "Kleurmap",
		colormapSnip: "Wijzigt pixelwaarden om de rastergegevens weer te geven als grijswaarden- of een rood, groen, blauw (RGB) -afbeelding, gebaseerd op een Colormap of kleurverloop.",
		colormapDesc: "De functie Colormap is een type rasterdata-renderer. Het transformeert de pixelwaarden om de rasterdata weer te geven als een grijsschaal of een RGB-kleurenafbeelding op basis van een kleurenschema of specifieke kleuren in een Colormapbestand. U kunt een Colormap gebruiken om geanalyseerde gegevens weer te geven, zoals een geclassificeerde afbeelding of bij het weergeven van een topografische kaart (of een indexkleurgescande afbeelding).<div><br/>Colormaps bevatten een reeks waarden die zijn gekoppeld aan kleuren die worden gebruikt om een enkelbandraster consistent weer te geven met dezelfde kleuren. Elke pixelwaarde is gekoppeld aan een kleur, gedefinieerd als een reeks RGB-waarden. Colormaps kunnen elke bitdiepte ondersteunen, behalve zwevende komma. Ze ondersteunen ook positieve en negatieve waarden en kunnen Colormaps met ontbrekende waarden bevatten. Bij het weergeven van een dataset met een Colormap met ontbrekende waarden, worden de pixels met die ontbrekende waarden niet weergegeven.</div>",
		complexName: "Complex",
		complexSnip: "Haalt de grootte uit complexe getallen.",
		complexDesc: "Deze functie berekent de grootte van complexe waarden.<div><br/>Deze functie wordt meestal gebruikt bij RADAR-beelden met een complex datatype. Kan worden gebruikt in een mozaïekgegevensset.</div>",
		compositeBandName: "Samengestelde banden",
		compositeBandSnip: "Combineert meerdere datasets in een multiband-raster.",
		compositeBandDesc: "Met de functie Samengestelde banden kunt u rasters combineren om een multiband-afbeelding te vormen.",
		conName: "Voorwaardelijk",
		conSnip: "Voert een voorwaardelijke als, dan, andere-bewerking uit. Wanneer een Voorwaardelijke operator wordt gebruikt, moeten er gewoonlijk twee of meer aaneengekoppelde functies zijn, waarbij één functie de criteria vermeldt en de tweede functie de Voorwaardelijke operator is die de criteria gebruikt en dicteert wat de ware en onware uitvoer zou moeten zijn.",
		conDesc: "De functie Voorwaardelijk stelt de pixels van het uitvoerraster in op basis van een als\\dan-evaluatie van elke invoerpixel. Het retourneert pixelwaarden van het ware raster als de voorwaardelijke evaluatie waar is (1) of retourneert de pixelwaarden van het onware raster als de voorwaardelijke evaluatie onwaar is (0). Dit criterium wordt gespecificeerd door de uitvoer van een logische rekenkundige functie, die het invoerraster zal zijn.",
		constantName: "Constante",
		constantSnip: "Creëert een virtueel raster met een waarde van één pixel.",
		constantDesc: "Met deze functie wordt een virtueel raster gemaakt met een waarde van één pixel die kan worden gebruikt in rasterfunctietemplates en om een mozaïekdataset te verwerken.<div><br/>De constante waarde wordt gebruikt voor elke pixelwaarde in het raster.</div>",
		contourName: "Contour",
		contourSnip: "Maakt contourlijnen.",
		contourDesc: "De functie Contour genereert contourlijnen door punten samen te voegen met dezelfde hoogte ten opzichte van een rasterhoogtedataset. De contouren zijn isolijnen die zijn gemaakt als rasters voor visualisatie. De volgende belangrijke eigenschappen maken deze functie krachtig: contouren worden snel en dynamisch gegenereerd op zeer grote datareeksen, zoals de World Elevation; contouren kunnen glad worden gemaakt voor een cartografisch mooier uiterlijk met behoud van de nauwkeurigheid van de contouren; dynamische controle over de contourinterval is aanwezig; uitvoeropties omvatten contourlijnen, indexcontouren en gevulde contouren.<div><br/>Het maken van een contourlaag als een rasterproduct is waardevol voor een breed scala aan toepassingen, omdat de contouren op een kaart kunnen worden gelegd en informatie over het terrein kunnen verschaffen zonder de onderliggende gegevens te verbergen. Ze zijn nuttig in toepassingen zoals techniek, landbouw en waterbeheer.</div>",
		contrastBrightnessName: "Contrast en helderheid",
		contrastBrightnessSnip: "Past het contrast en de helderheid van een raster aan.",
		contrastBrightnessDesc: "De functie Contrast en helderheid verbetert de weergave van rasterdata door de helderheid en het contrast in het beeld aan te passen. Helderheid verhoogt bijvoorbeeld de totale lichtheid van de afbeelding—bijvoorbeeld, waardoor donkere kleuren lichter en lichtere kleuren witter—worden terwijl contrast het verschil tussen de donkerste en lichtste kleuren aanpast.<div><br/>Met deze functie worden de pixelwaarden gewijzigd; darom moet deze functie worden gebruikt als u de weergave van de gegevens wilt verbeteren en niet als u de gegevens wilt gebruiken als onderdeel van een analyse waarvoor de onbewerkte pixelwaarden moeten worden gebruikt. Deze functie is handig wanneer u de gegevens publiceert als een afbeeldingsservice die in toepassingen kan worden gebruikt zonder dat u het contrast en de helderheid van de afbeelding kunt wijzigen of om ervoor te zorgen dat deze wordt weergegeven met de instellingen van uw voorkeur.</div>",
		convolutionName: "Convolutie",
		convolutionSnip: "Past een filter toe om te verscherpen, vervagen, randen te detecteren, vloeiend te maken of voor een verloop over een raster.",
		convolutionDesc: "De functie Convolutie voert filtering uit op de pixelwaarden in een afbeelding, die kan worden gebruikt voor het verscherpen van een afbeelding, vervaging van een afbeelding, het detecteren van randen in een afbeelding of andere op kernel gebaseerde verbeteringen. Filters worden gebruikt om de kwaliteit van de rasterafbeelding te verbeteren door onjuiste gegevens te verwijderen of functies in de gegevens te verbeteren. Deze convolutiefilters worden toegepast op een bewegende, elkaar overlappende kernel (venster of buurt), zoals 3 bij 3. Convolutiefilters berekenen de pixelwaarde op basis van het gewicht van de buren.",
		corridorName: "Corridor",
		corridorSnip: "Berekent de som van de cumulatieve kosten voor twee accummulatieve invoerrasters.",
		corridorDesc: "De functie Corridor berekent de som van de cumulatieve kosten voor twee accummulatieve kosteninvoerrasters. Hoewel er twee rasters voor de invoer kunnen worden gebruikt, moeten het om een zinvol resultaat te krijgen, ongewijzigde accumulatieve kostenuitvoerrasters zijn. De volgorde van de twee invoeren is niet relevant.",
		cosHName: "CosH",
		cosHSnip: "Berekent de hyperbole cosinus van cellen in een raster.",
		cosHDesc: "De functie berekent de hyperbole cosinus van de pixels in een raster.",
		cosName: "Cos",
		cosSnip: "Berekent de cosinus van een cel in een raster.",
		cosDesc: "De functie berekent de cosinus van de pixels in een raster.",
		costAllocationName: "Kostentoewijzing",
		costAllocationSnip: "Berekent voor elke cel de bron met de laagste kosten op basis van de minst cumulatieve kosten over een kostenoppervlak.",
		costAllocationDesc: "De functie Kostentoewijzing berekent voor elke cel de bron met de laagste kosten op basis van de minst cumulatieve kosten over een kostenoppervlak.",
		costBackLinkName: "Cost Back Link",
		costBackLinkSnip: "Definieert de buur die de volgende cel is op het minst accumulatieve kostenpad naar de bron met de minste kosten.",
		costBackLinkDesc: "De functie Cost Back Link definieert de volgende aangrenzende cel op het minst accumulatieve kostenpad naar de bron met de minste kosten.<div><br/>Het raster van de back link bevat waarden van nul tot en met acht die de richting bepalen of de volgende aangrenzende cel (de volgende cel) identificeren langs het minst accumulatieve kostenpad van een cel om de bron met de minste kosten te bereiken. Als het pad naar de rechterbuur moet gaan, krijgt de cel de waarde 1, 2 voor de diagonale cel rechtsonder en gaat deze met de klok mee verder. De waarde 0 is gereserveerd voor broncellen.</div>",
		costDistanceName: "Kostenafstand",
		costDistanceSnip: "Berekent de laagste cumulatieve kostenafstand voor elke cel van of naar de bron met de laagste kosten over een kostenoppervlak.",
		costDistanceDesc: "De functie Kostenafstand berekent de kleinste cumulatieve kostenafstand voor elke cel van of naar de bron met de laagste kosten over een kostenoppervlak.",
		costPathName: "Kostenpad",
		costPathSnip: "Berekent het pad met de minste kosten van een bron naar een bestemming.",
		costPathDesc: "De globale functie Kostenpad berekent het pad met de laagste kosten van een bron naar een bestemming.<div><br/>Deze functie produceert een uitvoerraster waarmee het pad met de minste kosten of paden van geselecteerde locaties naar de dichtstbijzijnde broncel worden vastgelegd binnen het geaccumuleerde kostenoppervlak, in termen van kostenafstand.</div>",
		curvatureName: "Kromming",
		curvatureSnip: "Berekent de kromming van een rasteroppervlak, optioneel inclusief profiel en vlakkromming.",
		curvatureDesc: "De functie Kromming geeft de vorm of kromming van de helling weer. Een deel van een oppervlak kan hol of bol zijn; dat is te zien aan de krommingswaarde. De kromming wordt berekend door de tweede afgeleide van het oppervlak te berekenen.<div><br/>De uitvoer van de krommingsfunctie kan worden gebruikt om de fysieke kenmerken van een drainagebekken te beschrijven om erosie- en afvoerprocessen te begrijpen. De krommingswaarde kan worden gebruikt om bodemerosiepatronen te zoeken of de verdeling van water op het land. De profielkromming beïnvloedt de versnelling en vertraging van de stroming en beïnvloedt daarmee de erosie en afzetting. De kromming van de vlakke vorm beïnvloedt de convergentie en divergentie van de stroming.</div>",
		divideName: "Delen door",
		divideSnip: "Verdeelt de waarden van twee rasters op een cel-voor-cel basis.",
		divideDesc: "De functie Delen door deelt de waarden van twee rasters op een pixel-voor-pixel basis.",
		elevationVoidFillName: "Elevation Void Fill",
		elevationVoidFillSnip: "Creëert pixels waar gaten voorkomen in uw hoogtegegevens.",
		elevationVoidFillDesc: "De functie Elevation Void Fill wordt gebruikt om pixels te creëren waar gaten voorkomen in uw hoogtegegevens.<div><br/>Gaten treden op wanneer er geen verzamelde punten zijn binnen het gebied dat wordt weergegeven door een pixel in het resulterende raster. Gaten worden vaak veroorzaakt door waterlichamen, klasse-type selectie of uitsluiting. Leegtevulling wordt meestal gebruikt bij het genereren van een grondoppervlak.</div>",
		equalToName: "Gelijk aan",
		equalToSnip: "Voert een relationele gelijk-aan-bewerking uit op twee invoeren op cel-voor-cel basis. Retourneert 1 voor cellen waarbij het eerste raster gelijk is aan het tweede raster en 0 voor cellen waar ze niet gelijk zijn.",
		equalToDesc: "De functie voert een gelijk-aan-bewerking uit op twee rasters op een pixel-per-pixel basis. Het retourneert de waarde 1 voor pixels waarbij het eerste raster gelijk is aan het tweede raster en waarde 0 voor pixels waar ze niet gelijk zijn.",
		eucAllocationName: "Euclidische toewijzing",
		eucAllocationSnip: "Berekent voor elke cel de dichtstbijzijnde bron op basis van de Euclidische afstand.",
		eucAllocationDesc: "De functie Euclidische toewijzing berekent voor elke cel de dichtstbijzijnde bron op basis van de Euclidische afstand.",
		eucDirectionName: "Euclidische richting",
		eucDirectionSnip: "Berekent voor elke cel de richting in graden naar de dichtstbijzijnde bron.",
		eucDirectionDesc: "De functie Euclidische richting berekent voor elke cel de richting in graden naar de dichtstbijzijnde bron. <div><br/>De richting wordt berekend vanaf elk celcentrum tot het midden van de broncel die het dichtst bij is. Het bereik van de waarden loopt van 0 graden tot 360 graden, met 0 gereserveerd voor de broncellen. Oost (rechts) is 90 en de waarden lopen rechtsom (180 is zuid, 270 is west en 360 is noord).</div>",
		eucDistanceName: "Euclidische afstand",
		eucDistanceSnip: "Berekent voor elke cel de Euclidische afstand naar de dichtstbijzijnde bron.",
		eucDistanceDesc: "De functie Euclidische afstand berekent voor elke cel de Euclidische afstand naar de dichtstbijzijnde bron.",
		exp10Name: "Exp10",
		exp10Snip: "Berekent de basis 10 exponentiële cellen in een raster.",
		exp10Desc: "De functie Exp 10 berekent de basis 10 exponentiële pixels in een raster.",
		exp2Name: "Exp2",
		exp2Snip: "Berekent de basis 2 exponentiële cellen in een raster.",
		exp2Desc: "De functie berekent de basis 2 exponentiële pixels in een raster.",
		expName: "Exp",
		expSnip: "Berekent de basis e exponentiële cellen in een raster.",
		expDesc: "De functie berekent de basis e exponentiële pixels in een raster.",
		extractBandName: "Banden exporteren",
		extractBandSnip: "Geeft aan met welke banden moet worden gewerkt bij het gebruik van multibands-datasets.",
		extractBandDesc: " Met de functie Banden exporteren kunt u een of meer banden exporteren uit, of opnieuw ordenen in, een multibands rasterdataset.<div><br/>U kunt de functie Banden exporteren gebruiken voor andere functies, zoals Aritmetisch, om te bepalen welke banden worden gebruikt als invoer in de volgende functie.</div>",
		fillName: "Vulling",
		fillSnip: "Vult putjes in een oppervlakraster om kleine onvolkomenheden in de gegevens te verwijderen.",
		fillDesc: "De globale functie Vullen lokaliseert en vult putten en pieken in een hoogteoppervlakraster om kleine onvolkomenheden in de gegevens te verwijderen. De functie vult een iteratief proces in totdat alle putten zijn gevuld binnen de opgegeven Z-limiet.<div><br/>Wanneer een hoogtevlak wordt gemaakt met Ortho Mapping-tools of met andere middelen, zijn er vaak kleine maar significante fouten in de vorm van putten en pieken in de gegevens. In fotogrammetrie worden putten en pieken vaak gaten en pieken genoemd. Omdat oppervlaktegegevens vaak worden gebruikt in modellering, zoals hydrologische modellering, is het belangrijk om deze fouten met putten en pieken op een manier te corrigeren die consistent is met de omringende gegevens.</div>",
		floatName: "Zweven",
		floatSnip: "Converteert elke celwaarde van een raster in een zwevende-puntweergave.",
		floatDesc: "De functie Zweven converteert elke pixelwaarde van een raster in een zwevende-puntweergave.",
		flowAccumulationName: "Stroomaccumulatie",
		flowAccumulationSnip: "Creëert een raster van geaccumuleerde stroom in elke cel. Een gewichtsfactor kan optioneel worden toegepast.",
		flowAccumulationDesc: "Met de algemene functie Stroomaccumulatie wordt een raster van geaccumuleerde stroom in elk pixel gemaakt, zoals bepaald door het verzamelen van het gewicht voor alle pixels die in elke neerwaartse pixel vloeien. Als er geen gewichtsraster is, wordt een gewicht van 1 toegepast op elke pixel en is de waarde van pixels in het uitvoerraster het aantal pixels dat in elke pixel stroomt.<div><br/>Uitvoerpixels met een hoge stroomaccumulatie zijn gebieden met geconcentreerde stroom en kunnen worden gebruikt om stroomkanalen te identificeren. Uitvoerpixels met een stroomaccumulatie van nul zijn lokale topografische hoogtepunten en kunnen worden gebruikt om bergkammen te identificeren.</div>",
		flowDirectionName: "Stroomrichting",
		flowDirectionSnip: "Creëert een raster van stroomrichting van elke cel naar de steilste neerwaartse buur.",
		flowDirectionDesc: "Een van de sleutels tot het afleiden van hydrologische eigenschappen van een oppervlak is het vermogen om de stroomrichting van elke pixel in het raster te bepalen. De rasterfunctie van de Stroomrichting neemt een oppervlak als invoer en creëert een raster van stroomrichting van elke pixel naar de steilste neerwaartse buur. De functie Stroomrichting ondersteunt drie stroommodelmethoden: de D8 (acht richtingen), Multi-Flow Direction (MFD) en D-Infinity (DINF). ",
		flowDistanceName: "Stroomafstand",
		flowDistanceSnip: "Berekent, voor elke cel, de minimale neerwaartse horizontale of verticale afstand tot cellen op een stroom of rivier waarin ze stromen.",
		flowDistanceDesc: "Voor elke pixel berekent de functie de minimale neerwaartse horizontale of verticale afstand tot pixel(s) op een rivier of stroom waarin ze stromen. Als er een optioneel stroomrichtingraster is, wordt/worden de neerwaartse richting(en) beperkt tot die die worden gedefinieerd door het raster van de invoerstroomrichting. De uitvoer is een stroomafstandraster.",
		focalName: "Focale statistieken",
		focalSnip: "Berekent focale statistieken voor elke pixel van een afbeelding op basis van een gedefinieerde focale buurt.",
		focalDesc: "De functie Focale statistieken berekent focale statistieken voor elke pixel van een afbeelding op basis van een gedefinieerde focale buurt.",
		geometricName: "Geometrisch",
		geometricSnip: "Verhoogt de positienauwkeurigheid van een dataset door rekening te houden met de hoogte.",
		geometricDesc: "De functie Geometrisch produceert een orthogerectificeerde afbeelding op basis van een sensordefinitie en een terreinmodel. Het verhoogt de positienauwkeurigheid van een dataset door rekening te houden met de hoogte.",
		grayscaleName: "Grijstinten",
		grayscaleSnip: "Converteert een multiband-afbeelding naar een afbeelding in grijstinten met één band.",
		grayscaleDesc: "Met deze functie converteert u een multiband-afbeelding naar een afbeelding in grijstinten met één band.<div><br/>Deze functie past gespecificeerde gewichten toe op elk van de invoerbanden en normaliseert het uitvoerbeeld. De gewichten worden vaak toegepast omdat sommige banden afhankelijk van de toepassing van variabel belang zijn. De blauwe band bevat bijvoorbeeld vaak meer ruis dan andere banden.</div>",
		greaterThanEqualName: "Groter dan of gelijk aan",
		greaterThanEqualSnip: "Voert een Relationele-groter-dan-gelijk-aan-bewerking uit op twee invoeren op cel-voor-cel basis. Retourneert 1 voor cellen waarvan het eerste raster groter is dan of gelijk is aan het tweede raster en 0 als dit niet het geval is.",
		greaterThanEqualDesc: "De functie voert een Relationele-groter-dan-of-gelijk-aan-bewerking uit op twee invoeren op een pixel-per-pixel basis. Het retourneert een waarde van 1 voor pixels waarbij het eerste raster groter is dan of gelijk aan het tweede raster en een waarde van 0 voor pixels waarbij het eerste raster niet groter is dan of gelijk is aan het tweede raster.",
		greaterThanName: "Groter dan",
		greaterThanSnip: "Voert een Relationele-groter-dan-bewerking uit op twee invoeren op cel-voor-cel basis. Retourneert 1 voor cellen waarbij het eerste groter is dan het tweede raster en 0 voor cellen als dit niet het geval is.",
		greaterThanDesc: "De functie voert een Relationele-groter-dan-bewerking uit op twee invoeren op een pixel-per-pixel basis. Retourneert een waarde van 1 voor pixels waarbij het eerste raster groter is dan of gelijk aan het tweede raster en een waarde van 0 voor pixels waarbij het eerste raster niet groter is dan het tweede raster.",
		heatIndexName: "Warmte-index",
		heatIndexSnip: "Combineert de omgevingsluchttemperatuur en de relatieve vochtigheid om de schijnbare temperatuur terug te brengen.",
		heatIndexDesc: "Deze functie berekent de schijnbare temperatuur op basis van de omgevingstemperatuur en relatieve vochtigheid. De schijnbare temperatuur wordt vaak beschreven als hoe heet het voor het menselijk lichaam is.<div><br/>Deze index kan nuttig zijn voor het berekenen van de gevaren die verband houden met medische problemen zoals spierkramp, uitdroging, hitte-uitputting of een ernstige zonnesteek op warme en vochtige dagen. Als de relatieve vochtigheid hoog is, wordt het steeds moeilijker voor het lichaam om zweet te verdampen, waardoor een mens niet meer effectief op natuurlijke manier kan afkoelen. Kaarten met warmte-adviezen of waarschuwingen zijn vaak een gevolg van het herclassificeren van het resultaat van de warmte-index naar klassen, waarbij hoe hoger de indexwaarde is, hoe groter de kans is dat het eerder een waarschuwing dan een advies wordt.</div>",
		hillshadeName: "Bergschaduwen",
		hillshadeSnip: "Creëert een 3D-weergave van het oppervlak, waarbij de relatieve positie van de zon in aanmerking wordt genomen voor het verduisteren van het beeld.",
		hillshadeDesc: "De functie Bergschaduw produceert een 3D-weergave in grijstinten van het terreinoppervlak, waarbij de relatieve positie van de zon in aanmerking wordt genomen voor het verduisteren van het beeld. <div><br/>Bergschaduw is een techniek voor het visualiseren van terrein dat wordt bepaald door een lichtbron en de helling en het aspect van het hoogtevlak. Het is een kwalitatieve methode voor het visualiseren van topografie en geeft geen absolute hoogtewaarden. </div>",
		intName: "Int",
		intSnip: "Converteert elke celwaarde van een raster naar een geheel getal door af te korten.",
		intDesc: "De functie Int converteert elke pixelwaarde van een raster naar een geheel getal door af te korten.",
		interpolateIrregularDataName: "Interpoleren van onregelmatige gegevens",
		interpolateIrregularDataSnip: "Interpoleert van pointclouds of onregelmatige rasters.",
		interpolateIrregularDataDesc: "Sommige netCDF- of HDF-datasets slaan hun geolocatie op als onregelmatig verdeelde rijen pixels of puntgegevens. Bij het toevoegen van deze datasets aan een mozaïekdataset, neemt de interpolerende onregelmatige gegevensfunctie de onregelmatig gerasterde gegevens op en herverzamelt deze zodat elke pixel een uniforme grootte heeft en vierkant is.<div><br/>Bij het toevoegen van variabelen uit netCDF of HDF aan een mozaïekdataset, wordt automatisch gecontroleerd of de gegevens regelmatig worden gerangschikt. Als dit niet het geval is, kan de interpoleerfunctie voor onregelmatige data worden gebruikt om de onregelmatige gegevens om te zetten in een raster dat regelmatig wordt gerasterd. U kunt de interpolatiemethode en de celgrootte wijzigen die worden gebruikt in de interpoleerfunctie voor onregelmatige datarasters. Voor rasterdata op regelmatige afstanden wordt geen interpolatie toegepast en worden de gegevens gelezen zoals ze zijn.</div>",
		isNullName: "Is null",
		isNullSnip: "Bepaalt welke waarden van de invoerrasters NoData zijn op een cel-voor-cel basis. Retourneert een waarde van 1 als de invoerwaarden NoData zijn en 0 voor cellen die dat niet zijn.",
		isNullDesc: "De Is null-functie bepaalt welke waarden van het invoerraster NoData zijn op een pixel-voor-pixel basis. Het geeft een waarde van 1 als de invoerwaarde NoData is en een waarde van 0 voor pixels die geen NoData zijn.",
		kernelDensityName: "Kerndichtheid",
		kernelDensitySnip: "Berekent een magnitude-per-eenheid gebied van punt- of polylijnobjecten met behulp van een kernfunctie om een vloeiend, taps toelopend oppervlak op elk punt of polylijn te passen.",
		kernelDensityDesc: "Deze functie berekent een magnitude-per-eenheid gebied van punt- of polylijnobjecten met behulp van een kernfunctie om een vloeiend, taps toelopend oppervlak op elk punt of polylijn te passen.",
		keyMetadataName: "Belangrijke metadata",
		keyMetadataSnip: "Overschrijft of voegt belangrijke metadata van een raster in een functieketen in.",
		keyMetadataDesc: "Met deze functie kunt u metadata van een raster invoegen of vervangen.<div><br/>De informatie in belangrijke metadata wordt gebruikt om de toepassing te helpen bij sommige bewerkingen en weergaven, waaronder het verstrekken van nuttige informatie, zoals de sensornaam, bandnamen of cloud cover die aan de beelden is gekoppeld.</div>",
		shortestPathName: "Laagste kostenpad",
		shortestPathSnip: "Voert een kostenafstandsanalyse uit met bron- en bestemmingsinvoer die vervolgens wordt gebruikt om het pad met de minste kosten van een bron naar een bestemming te bepalen.",
		shortestPathDesc: "De functie Laagste kostenpad berekent het pad met de laagste kosten van een bron naar een bestemming. De minst cumulatieve kostenafstand wordt berekend voor elke pixel over een kostenoppervlak naar de dichtstbijzijnde bron. Dit produceert een uitvoerraster waarmee het pad met de minste kosten of paden van geselecteerde locaties naar de dichtstbijzijnde bronpixels vastgelegd binnen het geaccumuleerde kostenoppervlak, in termen van kostenafstand.<div><br/>Aan elk pad met de laagste kosten wordt een waarde toegewezen wanneer deze tijdens het scanproces wordt aangetroffen. De eindpixel op het bronraster van een kostenpad krijgt een waarde van 1. Het eerste pad krijgt een waarde van 3, de tweede 4, enzovoort. Wanneer meerdere paden samenvloeien en de resterende afstand naar een bron op dezelfde route volgen, krijgt het segment waar de twee paden samen komen een waarde van 2. Het samengevoegde deel van het pad kan niet de waarde van een van de paden krijgen toegewezen, omdat het samengevoegde deel bij beide routes hoort.</div>",
		lessThanEqualName: "Kleiner dan of gelijk aan",
		lessThanEqualSnip: "Voert een Relationele-kleiner-dan-gelijk-aan-bewerking uit op twee invoeren op een cel-voor-cel basis. Retourneert 1 voor cellen waarvan het eerste raster kleiner is dan of gelijk is aan het tweede raster en 0 als dit niet het geval is.",
		lessThanEqualDesc: "De functie voert een Relationele-kleiner-dan-of-gelijk-aan-bewerking uit op twee invoeren op een pixel-per-pixel basis. Het retourneert een waarde van 1 voor pixels waarbij het eerste raster kleiner is dan of gelijk aan het tweede raster en een waarde van 0 voor pixels waarbij het niet kleiner is dan of gelijk is aan het tweede raster.",
		lessThanName: "Kleiner dan",
		lessThanSnip: "Voert een Relationele-kleiner-dan-bewerking uit op twee invoeren op een cel-voor-cel basis. Retourneert 1 voor cellen waarvan het eerste raster kleiner is dan het tweede raster en 0 als dit niet het geval is.",
		lessThanDesc: "De functie voert een Relationele-kleiner-dan-bewerking uit op twee invoeren op een pixel-per-pixel basis. Het retourneert een waarde van 1 voor pixels waarbij het eerste raster kleiner is dan het tweede raster en een waarde van 0 waarbij het niet kleiner is dan het tweede raster.",
		lnName: "Ln",
		lnSnip: "Berekent het natuurlijke logaritme (basis e) van cellen in een raster.",
		lnDesc: "De functie Ln berekent het natuurlijk logaritme (basis e) van elk pixel in een raster.",
		log10Name: "Log10",
		log10Snip: "Berekent de basis 10 logaritme van cellen in een raster.",
		log10Desc: "De functie Log10 berekent de basis 10 logaritme van elk pixel in een raster.",
		log2Name: "Log2",
		log2Snip: "Berekent de basis 2 logaritme van cellen in een raster.",
		log2Desc: "De functie Log2 berekent de basis 2 logaritme van elk pixel in een raster.",
		lookupName: "Opzoeken",
		lookupSnip: "Maakt een nieuw raster door waarden op te zoeken die in een ander veld in de tabel van het invoerraster zijn gevonden.",
		lookupDesc: "De functie maakt een nieuw raster door waarden op te zoeken die in een ander veld in de tabel van het invoerraster zijn gevonden.",
		mlClassifyName: "ML Classificeren",
		mlClassifySnip: "Classificeert afbeeldingen met behulp van een per-pixel benadering. Gemengde pixels worden toegewezen aan het object met het hoogste percentage in dat pixel.",
		mlClassifyDesc: "Met de functie ML Classificeren kunt u onder toezicht een classificatie uitvoeren, met behulp van het classificatie-algoritme voor maximale waarschijnlijkheid, op een rasterdataset of mozaïekdataset. Voor deze functie is een classificatiesignatuurbestand vereist.",
		maskName: "Masker",
		maskSnip: "Stelt waarden in die u niet wilt weergeven.",
		maskDesc: "Deze rasterfunctie stelt waarden in die u niet in uw raster wilt weergeven. Met behulp van de functie Masker geeft u een of meer NoData-waarden of een reeks geldige pixelwaarden op. ",
		minusName: "Min",
		minusSnip: "Hiermee wordt de waarde van het tweede invoerraster van de waarde van het eerste invoerraster afgetrokken op een cel-voor-cel-basis.",
		minusDesc: "De functie Minus trekt de waarde van het tweede invoerrooster af van de waarde van het eerste invoerraster op een pixel per pixel basis.",
		modName: "Mod",
		modSnip: "Vindt de rest (modulo) van het eerste raster wanneer het gedeeld wordt door het tweede raster op een cel-voor-cel basis.",
		modDesc: "Mod-functie vindt de rest (modulo) van het eerste raster, gedeeld door het tweede raster op een pixel-voor-pixel basis. De volgorde van de invoer is belangrijk en beïnvloedt het resultaat van de uitvoer.",
		mosaicRastersName: "Mozaïekrasters",
		mosaicRastersSnip: "Voegt verschillende rasterdatasets samen om één dataset te maken.",
		mosaicRastersDesc: "De functie Mozaïekrasters maakt een mozaïekafbeelding uit meerdere afbeeldingen. Wanneer er overlapping is tussen de afbeeldingen, zijn er verschillende methoden waaruit u kunt kiezen om te bepalen welke afbeeldingen worden weergegeven.",
		ndviColorizedName: "NDVI ingekleurd",
		ndviColorizedSnip: "Creëert een multiband-dataset die de gezondheid van de vegetatie vertegenwoordigt, op basis van het verschil tussen de rode en de nabij-infraroodbanden.",
		ndviColorizedDesc: "De functie NDVI Ingekleurd past de NDVI-functie toe op het invoerbeeld en gebruikt vervolgens een kleurkaart of kleurverloop om het resultaat weer te geven.",
		ndviName: "NDVI",
		ndviSnip: "Berekent de Normalized Difference Vegetation Index (NDVI)",
		ndviDesc: "De NDVI-functie maakt een dataset met één band die de gezondheid van de vegetatie weergeeft, op basis van het verschil tussen de rode en de nabij-infraroodbanden.<div><br/>NDVI is een gestandaardiseerde index zodat u een beeld komt vormen van de groenheid, ook wel relatieve biomassa genoemd. Deze index maakt gebruik van het contrast van de kenmerken van de twee banden van een multispectraal rasterdataset; de chlorofylpigmentabsorptie in de rode band en de hoge reflectiviteit van plantaardige materialen in het nabij-infrarood (NIR) band. Extreem lage of negatieve NDVI-waarden vertegenwoordigen gebieden zonder enige vegetatie, zoals wolken, water of sneeuw. Zeer lage waarden vertegenwoordigen gebieden met weinig tot geen vegetatie, zoals beton, rotsen of kale grond. Gematigde waarden vertegenwoordigen gebieden met struiken en grasland. Hoge waarden vertegenwoordigen bosgebieden en weelderige vegetatie.</div>",
		negateName: "Negatie",
		negateSnip: "Wijzigt het teken (vermenigvuldigd met -1) van de celwaarden van het invoerraster op cel voor cel basis.",
		negateDesc: "De functie Negatie verandert het teken (vermendigvulgd met -1) van de pixelwaarden van het invoerraster op een pixel ",
		nibbleName: "Nibble",
		nibbleSnip: "Vervangt cellen van een raster die overeenkomen met een masker met de waarden van naaste buren.",
		nibbleDesc: "Met de functie Nibble kan aan geselecteerde gebieden van een raster de waarde van hun dichtstbijzijnde buur worden toegewezen. Dit is handig voor het bewerken van gebieden van een raster waar de gegevens mogelijk onjuist zijn.",
		notEqualName: "Niet gelijk",
		notEqualSnip: "Voert een Relationele niet- gelijk-aan-bewerking uit op twee invoeren op cel-voor-cel basis. Retourneert 1 voor cellen waarvan het eerste raster niet gelijk is aan het tweede raster en 0 als het gelijk is.",
		notEqualDesc: "De functie voert een Relationele-niet-gelijk-aan-bewerking uit op twee invoeren op een pixel-per-pixel basis. Het retourneert een waarde van 1 voor pixels waarbij het eerste raster niet gelijk is aan het tweede raster en een waarde van 0 voor pixels waarbij het gelijk is aan het tweede raster.",
		pansharpeningName: "Pansharpen",
		pansharpeningSnip: "Verhoogt kunstmatig de ruimtelijke resolutie van een multibandbeeld door deze te fuseren met een panchromatisch beeld met hogere resolutie.",
		pansharpeningDesc: "De functie Pansharpening gebruikt een panchromatisch beeld met hogere resolutie of een rasterband om te fuseren met een multiband rasterdataset met een lagere resolutie om de ruimtelijke resolutie van het multibandbeeld te vergroten.<div><br/>Het doel van pansharpening is om een visueel beeld van hogere kwaliteit te creëren. Aangezien de technieken de radiometrie en spectrale karakteristieken van de multibandbeelden veranderen, moeten beelden met pansharpening voorzichtig worden gebruikt voor analytische detectiedoeleinden.</div>",
		pathAllocationName: "Padafstandtoewijzing",
		pathAllocationSnip: "Berekent de bron met de laagste kosten voor elke cel op basis van de minst cumulatieve kosten over een kostenoppervlak, waarbij rekening wordt gehouden met de oppervlakafstand samen met de horizontale en verticale kostenfactoren.",
		pathAllocationDesc: "De functie Padafstandtoewijzing berekent de dichtstbijzijnde bron voor elke cel op basis van de minst cumulatieve kosten over een kostenoppervlak, waarbij rekening wordt gehouden met oppervlakafstand en horizontale en verticale kostenfactoren.",
		pathBackLinkName: "Path Distance Back Link",
		pathBackLinkSnip: "Definieert de buur die de volgende cel is op het minst cumulatieve kostenpad naar de bron met de laagste kosten, waarbij rekening wordt gehouden met de oppervlakafstand samen met horizontale en verticale kostenfactoren.",
		pathBackLinkDesc: "De functie Path Distance Back Link identificeert de directionaliteit van de buur die de volgende cel is op het minst cumulatieve kostenpad naar de dichtstbijzijnde bron, rekening houdend met oppervlakafstand en horizontale en verticale kostenfactoren.",
		pathDistanceName: "Padafstand",
		pathDistanceSnip: "Berekent voor elke cel de minst cumulatieve kostenafstand van of naar de bron met de minste kosten, waarbij rekening wordt gehouden met oppervlakafstand samen met horizontale en verticale kostenfactoren.",
		pathDistanceDesc: "De functie Padafstand berekent voor elke cel de minst cumulatieve kostenafstand naar de dichtstbijzijnde bron, waarbij rekening wordt gehouden met oppervlakafstand en horizontale en verticale kostenfactoren.",
		plusName: "Plus",
		plusSnip: "Voegt de waarden van twee rasters toe op een cel-voor-cel basis.",
		plusDesc: "Plusfunctie voegt de waarden van twee rasters op een pixel-voor-pixel basis toe.",
		powerName: "Macht",
		powerSnip: "Verhoogt de celwaarden in een raster naar de macht van de waarden in een ander raster.",
		powerDesc: "De functie Macht verhoogt de pixelwaarden in een raster naar de macht van de waarden die in een ander raster zijn gevonden.",
		radarCalibrationName: "Radarkalibratie",
		radarCalibrationSnip: "Converteert RADARSAT-2-terugverstrooiing.",
		radarCalibrationDesc: "Deze functie kan worden gebruikt voor het kalibreren van RADARSAT-2-beelden in een mozaïekdataset of als een rasterproduct. Kalibratie wordt uitgevoerd op radarbeelden, zodat de pixelwaarden een getrouwe weergave zijn van de terugverstrooiing van de radar.",
		rasterInfoName: "RasterInfo",
		rasterInfoSnip: "Wijzigt eigenschappen van het raster, zoals bitdiepte, NoData-waarde, celgrootte, enzovoort.",
		rasterInfoDesc: "De Rasterinfo opent een dialoogvenster met eigenschappen van rasterdata, zoals het aantal kolommen en rijen, het aantal banden, het pixeltype, de omvang en de ruimtelijke referentie. U kunt deze eigenschappen bewerken door een rasterdataset te selecteren die u als template kunt gebruiken. ",
		rasterizeAttributesName: "Attributen rasteren",
		rasterizeAttributesSnip: "Verrijkt een raster door extra banden die zijn afgeleid van waarden van gespecificeerde attributen van een externe tabel of een objectservice.",
		rasterizeAttributesDesc: "De functie Attributen rasteren verrijkt een raster door banden toe te voegen die zijn afgeleid van waarden van gespecificeerde attributen, van een externe tabel of een objectservice. U kunt optioneel een zoneraster en het bijbehorende kenmerk voor zone-ID opgeven om zoeken op basis van regio's in te schakelen.",
		rasterizeFeatureClassName: "Objecten rasteren",
		rasterizeFeatureClassSnip: "Converteert objecten naar raster.",
		rasterizeFeatureClassDesc: "Met deze functie worden polygoon-, polylijn- en puntobjectklassedata geconverteerd naar een rasterlaag.<div><br/>Aan objecten worden pixelwaarden toegewezen op basis van OBJECTID van de objecten (standaard). Optioneel kunnen de pixelwaarden worden gebaseerd op een veld met door de gebruiker gedefinieerde waarden in de attribuuttabel van het invoerobject.</div>",
		recastName: "Herschikken",
		recastSnip: "Wijzigt de parameters van een functieketen in een mozaïekdataset of beeldservice. Dit wordt vaak gebruikt met LAS-datasets om te voorkomen dat een afzonderlijke mozaïekdataset moet worden gemaakt voor verschillende weergaven van het terrein.",
		recastDesc: "De functie Herschikken wordt gebruikt om de functieparameter die in een mozaïekdataset of beeldservice wordt gebruikt, dynamisch te wijzigen zonder de wijzigingen fysiek aan te houden.",
		regionGroupName: "Regiogroep",
		regionGroupSnip: "Voor elke cel in de uitvoer wordt de identificatie geregistreerd van het aangesloten gebied waartoe die cel behoort. Aan elke regio wordt een uniek nummer toegewezen.",
		regionGroupDesc: "De globale functie van de Regiogroep registreert voor elke cel in de uitvoer de identificatie van het aangesloten gebied waartoe die cel behoort. Aan elke regio wordt een uniek nummer toegewezen.<div><br/>Het eerste gescande gebied krijgt waarde één, de tweede twee, enzovoort, totdat aan alle gebieden een waarde is toegewezen. De scan beweegt van links naar rechts en van boven naar beneden. De waarden die zijn toegewezen aan de uitvoerzones zijn gebaseerd op wanneer ze worden gevonden tijdens het scanproces.</div>",
		regionGrowName: "Regiogroei",
		regionGrowSnip: "Laat regio's groeien vanaf beginpunten.",
		regionGrowDesc: "De functie Regiogroep groepeert naburige pixels in groepen, afhankelijk van de opgegeven radius vanaf het beginpunt. Aan de groep pixels of objecten wordt een opgegeven vulwaarde toegewezen.",
		remapName: "Remap",
		remapSnip: "Wijzigt pixelwaarden door nieuwe waarden toe te wijzen aan bereiken van pixelwaarden of door een externe tabel te gebruiken.",
		remapDesc: "Met de functie Remap kunt u de pixelwaarden wijzigen of herindelen van de rastergegevens. Dit kan worden gedaan door een bereik van pixelwaarden op te geven om aan een uitvoerpixelwaarde toe te wijzen, of door een tabel te gebruiken om de pixelwaarden toe te wijzen aan de uitvoerpixelwaarde.",
		reprojectName: "Herprojecteren",
		reprojectSnip: "Wijzigt de projectie van een rasterdataset, mozaïekdataset of rasteritem in een mozaïekdataset. Het kan ook de gegevens resamplen naar een nieuwe celgrootte en een oorsprong definiëren.",
		reprojectDesc: "De functie Opnieuw projecteren wijzigt de projectie van een rasterdataset, mozaïekdataset of rasteritem in een mozaïekdataset. Het kan ook de gegevens resamplen naar een nieuwe celgrootte en een oorsprong definiëren.<div><br/>De functie Opnieuw projecteren kan worden gebruikt bij het maken van een cache uit een raster- of mozaïekdataset die zich niet in de vereiste projectie bevindt. Als u bijvoorbeeld een gecachte imageservice maakt die mogelijk wordt geïntegreerd door toepassingen met andere cachediensten, is het belangrijk dat ze allemaal in dezelfde projectie zijn. Dit is vaak een Web Mercator-projectie. Omdat de mozaïekdataset niet opnieuw kan worden geprojecteerd, kunt u twee dingen doen—u kunt een gemarkeerde mozaïekdataset maken van uw mozaïekdataset in de benodigde projectie, of de functie Opnieuw projecteren toevoegen aan de functieketen van de mozaïekdataset. Een ander voorbeeld gebruikt deze functie op het rasteritem in een mozaïekdataset. Als u de functie Raster in cache gebruikt, wilt u mogelijk de functie Herprojecten invoegen, zodat de cache in de nieuwe projectie wordt gemaakt. Rasteritems in een mozaïekdataset kunnen in de cache worden opgeslagen wanneer de verwerking intensief is en u een snelle imageservice wilt publiceren, zonder de volledige imageservice in cache op te slaan.</div>",
		resampleName: "Resample",
		resampleSnip: "Verandert de celgrootte van een raster.",
		resampleDesc: "De functie Resample wijzigt de celgrootte, het resampletype of beide.<div><br/>De functie Resample mag alleen worden gebruikt met specifieke computervereisten; bijvoorbeeld wanneer u de wind of de huidige magnituderichting berekent waarvoor resampling vanuit de bronresolutie nodig is.</div>",
		roundDownName: "Naar beneden afronden",
		roundDownSnip: "Retourneert de volgende lagere gehele waarde, net voorgesteld als een zwevend punt, voor elke cel in een raster.",
		roundDownDesc: "De functie Naar beneden afronden retourneert het volgende lagere gehele getal, als zwevende puntwaarde, voor elke pixel in een raster.",
		roundUpName: "Naar boven afronden",
		roundUpSnip: "Retourneert de volgende hogere gehele waarde, net voorgesteld als een zwevend punt, voor elke cel in een raster.",
		roundUpDesc: "Naar beneden afronden retourneert het volgende hogere gehele getal, als zwevende puntwaarde, voor elke pixel in een raster.",
		segmentMeanShiftName: "Segment Mean Shift",
		segmentMeanShiftSnip: "Groepeer aangrenzende pixels met vergelijkbare spectrale kenmerken samen in segmenten.",
		segmentMeanShiftDesc: "Met deze functie identificeert u voorwerpen, objecten of segmenten in uw afbeeldingen door aangrenzende pixels samen te voegen die vergelijkbare spectrale en ruimtelijke kenmerken hebben. U kunt de hoeveelheid ruimtelijke en spectrale afvlakking regelen om zo interessante kenmerken af te leiden.",
		s1RadiometricCalibrationName: "Sentinel-1 Radiometrische kalibratie",
		s1RadiometricCalibrationSnip: "Voert verschillende soorten radiometrische kalibratie uit op Sentinel-1-data.",
		s1RadiometricCalibrationDesc: "Deze rasterfunctie voert drie verschillende kalibraties uit voor Sentinel 1-datasets, inclusief bèta-nul en gamma, en voert de gekalibreerde dataset uit. Het doel van de SAR-kalibratie is satellietbeelden te bieden waarin pixelwaarden direct kunnen worden gerelateerd aan de radarterugverstrooiing van de scene. Hoewel niet-gekalibreerde SAR-satellietbeelden voldoende zijn voor een kwalitatief gebruik, zijn gekalibreerde SAR-beelden essentieel voor het kwantitatieve gebruik van SAR-data.<div><br/>Typische SAR-dataverwerking, die beelden van niveau 1 produceert, omvat geen radiometrische correcties en significante radiometrische gemiddelde afwijkingen. Daarom is het noodzakelijk om radiometrische correctie toe te passen op SAR-beelden, zodat de pixelwaarden van de afbeeldingen echt de terugverstrooiing van de radar van het reflecterende oppervlak weergeven. Radiometrische correctie is ook nodig voor de vergelijking van SAR-beelden die met verschillende sensoren zijn verkregen of met dezelfde sensor op verschillende tijdstippen, in verschillende modi of door verschillende processors zijn verwerkt.</div>",
		s1ThermalNoiseRemovalName: "Sentinel-1 thermische ruis verwijderen",
		s1ThermalNoiseRemovalSnip: "Verwijdert thermische ruis uit Sentinel-1-data.",
		s1ThermalNoiseRemovalDesc: "Thermische ruiscorrectie kan worden toegepast op Sentinel-1 Level-1 Single Look Complex (SLC)-producten, evenals Level-1 Ground Range Detection (GRD)-producten die nog niet zijn gecorrigeerd. De operator kan deze correctie ook verwijderen op basis van de productannotaties om het ruissignaal dat werd verwijderd opnieuw in te voeren om het originele product te produceren. Productannotaties worden overeenkomstig bijgewerkt om de correctie opnieuw toe te passen. ",
		setNullName: "Null instellen",
		setNullSnip: "Null instellen stelt de geïdentificeerde cellocaties in op NoData, op basis van de specifieke criteria. Het retourneert NoData als de voorwaardelijke evaluatie waar is en retourneert de waarde gespecificeerd door een ander raster als het onwaar is.",
		setNullDesc: "De functie Null instellen stelt de geïdentificeerde pixels in op NoData, op basis van de specifieke criteria. Het retourneert NoData als de voorwaardelijke evaluatie waar is (1) of retourneert de waarde gespecificeerd in het onware raster als de voorwaardelijke evaluatie onwaar is (0). Dit criterium wordt gespecificeerd door de uitvoer van een logische rekenkundige functie, die het invoerraster zal zijn.",
		shadedReliefName: "Shaded Relief",
		shadedReliefSnip: "Creëert een multiband, kleurgecodeerde 3D-weergave van het oppervlak, waarbij de relatieve positie van de zon in aanmerking wordt genomen voor het verduisteren van het beeld.",
		shadedReliefDesc: "De functie Shaded Relief creëert een 3D-weergave in kleur van het terrein door de beelden van de hoogtecodering en de reliëfschaduwmethoden samen te voegen. Deze functie gebruikt de hoogte- en azimutheigenschappen om de positie van de zon te bepalen.<div><br/></div>",
		sinHName: "SinH",
		sinHSnip: "Berekent de hyperbole sinus van cellen in een raster.",
		sinHDesc: "De functie berekent de hyperbole sinus van de pixels in een raster.",
		sinName: "Sin",
		sinSnip: "Berekent de sinus van cellen in een raster.",
		sinDesc: "De functie berekent de sinus van de pixels in een raster.",
		slopeName: "Helling",
		slopeSnip: "Berekent de veranderingssnelheid van één pixelwaarde naar zijn buren.",
		slopeDesc: "Deze rasterfunctie berekent de helling en geeft de mate van verandering in de hoogte weer voor elke pixel van het digitaal elevatiemodel (DEM). Het is de eerste afgeleide van een DEM.<div><br/>Deze functie gebruikt een versnelde atan()-functie. Het is zes keer sneller en de benaderingsfout is altijd minder dan 0,3 graden.</div>",
		speckleName: "Spikkel",
		speckleSnip: "Biedt filters om de ruis weg te nemen van radardatsets van synthetische apertuur.",
		speckleDesc: "Spikkel is de hoogfrequente ruis op radargegevens. De afbeeldingen gegenereerd door synthetische apertuurradar (SAR)-systemen zijn sterk onderhevig aan spikkeleffecten door de verwerking van verstrooide signalen en interferentie van elektromagnetische golven die worden verstrooid van oppervlakken of objecten. Deze Spikkel-functie filtert de gespikkelde radardataset en effent de ruis met behoud van de randen of scherpe objecten in de afbeelding.",
		spectralConversionName: "Spectrale conversie",
		spectralConversionSnip: "Past een matrix toe op een multiband-afbeelding.",
		spectralConversionDesc: "De functie Spectrale conversie past een matrix toe op een multiband-afbeelding om de kleurwaarden van de uitvoer te beïnvloeden.<div><br/>Sommige sensoren verzamelen geen blauwe banden vanwege een lage verhouding tussen signaal en ruis. Dit kan bijvoorbeeld worden gebruikt om een infraroodbeeld met valse kleuren om te zetten in een meer natuurlijke kleurenafbeelding.</div>",
		squareRootName: "Vierkantswortel",
		squareRootSnip: "Berekent de vierkantswortel van de cellen in een raster.",
		squareRootDesc: "De functie Vierkantswortel berekent de vierkantswortel van de pixelwaarden in een raster.",
		squareName: "Vierkant",
		squareSnip: "Berekent het vierkant van de cellen in een raster.",
		squareDesc: "De functie Vierkant berekent het vierkant van de pixelwaarden in een raster.",
		statisticsHistogramName: "Statistieken en histogram",
		statisticsHistogramSnip: "Statistieken en histogram definiëren of koppelen.",
		statisticsHistogramDesc: "De functie Statistieken en histogram wordt gebruikt om de statistieken en het histogram van een raster te definiëren. U kunt deze functie aan het einde van de functieketen invoegen om de statistieken en het histogram van een raster function template (RFT) te beschrijven. Dit kan nodig zijn om de standaardweergave van het verwerkingsresultaat te regelen, vooral bij het definiëren van een functieketen die veel functies bevat.<div><br/>U kunt statistieken definiëren door de waarden in te voeren of te importeren uit een rasterdataset of een XML-bestand. Histogrammen kunnen alleen worden gedefinieerd door een bestand te importeren.</div>",
		statisticsName: "Statistieken",
		statisticsSnip: "Berekent focale statistieken voor elke pixel van een afbeelding op basis van een gedefinieerde focale buurt.",
		statisticsDesc: "De functie Statistieken berekent focale statistieken voor elke pixel van een afbeelding op basis van een gedefinieerde focale buurt.<div><br/>De functie Statistieken kan worden gebruikt om gedropte lijnen in een afbeelding te vullen. Gedropte lijnen worden vaak veroorzaakt door problemen in de sensor waar geen data wordt verzameld. Dit is gebeurd in sensoren zoals Landsat 7's Enhanced Thematic Mapper Plus (ETM+). Deze ontbrekende gegevens veroorzaken problemen voor de analyse en ook bij het bekijken van de afbeeldingen. Er is weinig dat kan worden gedaan wanneer de beelden worden gebruikt voor analyse; als er echter een overlappende afbeelding is, kan deze worden gebruikt in plaats van de ontbrekende inhoud. Hetzelfde kan worden gedaan als de afbeelding wordt gebruikt voor visualisatie. Er is echter niet altijd een extra afbeelding om de ontbrekende inhoud in te vullen, dus deze moet worden afgeleid van de bestaande gegevens.</div>",
		streamLinkName: "Stream Link",
		streamLinkSnip: "Wijst unieke waarden toe aan secties van een raster-lineair netwerk tussen kruispunten.",
		streamLinkDesc: "De globale functie Stream Link wijst unieke waarden toe aan secties van een raster-lineair netwerk tussen kruispunten.<div><br/>Links zijn de secties van een stroomkanaal dat twee opeenvolgende kruispunten verbindt, een kruispunt en de uitvoer of een kruispunt en de afvoerkloof. In de hydrologie worden deze streamsegmenten bereiken genoemd. Een kruispunt is gerelateerd aan een stortpunt en helpt bij het afbakenen van een stroomgebied of drainagebekkengrens.</div>",
		stretchName: "Uitrekken",
		stretchSnip: "Verbetert een afbeelding door het weergegeven waardebereik aan te passen. Dit verandert niets aan de onderliggende pixelwaarden. Als een pixel een waarde buiten het opgegeven bereik heeft, wordt deze weergegeven als de minimum- of maximumwaarde.",
		stretchDesc: "De functie Uitrekken verbetert een afbeelding door eigenschappen zoals helderheid, contrast en gamma te wijzigen door middel van meerdere uittrektypes. Deze functie gebruikt de statistieken van de rasters binnen de mozaïekdataset; daarom moet u als u deze functie gebruikt ervoor zorgen dat de statistieken zijn berekend.<div><br/>Het uitrektype definieert een histogramrek die op de rasters wordt toegepast om hun uiterlijk te verbeteren. Uitrekken verbetert de weergave van de data door de pixelwaarden langs een histogram te verspreiden van de minimum- en maximumwaarden die worden gedefinieerd door hun bitdiepte. </div>",
		swathName: "Swath",
		swathSnip: "Interpoleert van onregelmatige rasters of swath-data.",
		swathDesc: "Sommige netCDF- of HDF-datasets slaan hun geolocatie op als onregelmatig verdeelde rijen. Bij het toevoegen van deze datasets aan een mozaïekdataset, neemt de functie swath de onregelmatig gerasterde gegevens op en herverzamelt deze zodat elke pixel een uniforme grootte heeft en vierkant is.<div><br/>Bij het toevoegen van variabelen uit netCDF of HDF aan een mozaïekdataset, wordt automatisch gecontroleerd of de gegevens regelmatig worden gerangschikt. Als dat niet het geval is, wordt de functie swath automatisch toegepast om het onregelmatige raster om te zetten in punten en vervolgens naar een rooster dat regelmatig wordt gerasterd. U kunt de interpolatiemethode en de celgrootte wijzigen die worden gebruikt in de swath raster-functie. Voor rasterdata op regelmatige afstanden wordt geen interpolatie toegepast en worden de gegevens gelezen zoals ze zijn.</div>",
		tanHName: "TanH",
		tanHSnip: "Berekent de hyperbole tangens van cellen in een raster.",
		tanHDesc: "De functie berekent de hyperbole tangens van de pixels in een raster.",
		tanName: "Tan",
		tanSnip: "Berekent de tangens van cellen in een raster.",
		tanDesc: "De functie berekent de tangens van de pixels in een raster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Berekent niveaus van vegetatie, natheid en helderheid. Deze techniek is gebaseerd op coëfficiënten die specifiek voor een sensor moeten worden berekend.",
		tasseledCapDesc: "De Tasseled Cap (Kauth-Thomas) transformatie is ontworpen voor het analyseren en in kaart brengen van vegetatiefenomenen en veranderingen in stedelijke ontwikkeling gedetecteerd door verschillende satellietsensorsystemen. Het staat bekend als de Tasseled Cap-transformatie vanwege de vorm van de grafische distributie van data. De transformatie biedt een rationale voor de patronen gevonden in Landsat MSS-data van landbouwvelden als een functie van de levenscyclus van het gewas. Omdat de gewassen groeien van zaad tot volwassenheid, is er een netto toename van nabij-infrarood en een afname van de rode reflectie op basis van de kleur van de grond<div><br/>Het nut van deze transformatie is uitgebreid van het monitoren van gewassen tot het analyseren en in kaart brengen van vegetatie om verschillende toepassingen te ondersteunen, zoals bosbouw, industrieel vegetatiemanagement, het in kaart brengen en beheren van ecosystemen, inventarisatie en monitoring voor het sekwestreren van koolstof en credits, stedelijke ontwikkeling en meer. Het is ook uitgebreid van ondersteunende Landsat MSS naar andere populaire satellietsystemen zoals Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, WorldView-2 en RapidEye multispectrale sensoren.</div>",
		timesName: "Aantal keer",
		timesSnip: "Vermenigvuldigt de waarden van twee rasters op een cel-voor-cel basis.",
		timesDesc: "De functie Vermenigvuldig verdeelt de waarden van twee rasters op een pixel-voor-pixel basis.",
		transposeBitsName: "Transpose Bits",
		transposeBitsSnip: "Pakt de bits van de invoerpixel uit en kent ze toe aan specifieke bits in de uitvoerpixel. Het doel van deze functie is om bits van een aantal ingangen te manipuleren, zoals de Landsat 8-kwaliteitsbandproducten.",
		transposeBitsDesc: "De functie Transpose Bit pakt de bits van de invoerpixel uit en kent ze toe aan specifieke bits in de uitvoerpixel. Het doel van deze functie is om bits van een aantal ingangen te manipuleren, zoals de Landsat 8-kwaliteitsbandproducten.",
		unitConversionName: "Eenheidsconversie",
		unitConversionSnip: "Verandert waarden van de ene meeteenheid naar de andere.",
		unitConversionDesc: "Deze functie converteert pixels van de ene eenheid naar de andere. Het ondersteunt de conversie van afstand, snelheid en temperatuur.",
		vectorFieldName: "Vectorveld",
		vectorFieldSnip: "Geeft datasets weer met zowel magnitude (u) als richting (v) als pijlen waarbij magnitude wordt weergegeven door de grootte en de richting wordt weergegeven door de hoek van de pijl.",
		vectorFieldDesc: "De functie Vectorveld wordt gebruikt om twee rasters samen te stellen en om te zetten in een tweeband raster van het datatype Magnitude-Direction of datatype U-V.<div><br/>De U-waarde wordt soms de zonale snelheid genoemd en de V-waarde wordt soms de meridionale snelheid genoemd.</div>",
		viewshed2Name: "Viewshed",
		viewshed2Snip: "Bepaalt de rasteroppervlaklocaties die zichtbaar zijn voor een aantal waarnemerobjecten met behulp van geodetische methoden.",
		viewshed2Desc: "De functie Viewshed bepaalt de rasteroppervlaklocaties die zichtbaar zijn voor een aantal waarnemerobjecten met behulp van geodetische methoden<div><br/>De zichtbaarheid van elk pixelcentrum wordt bepaald door een gezichtslijntest tussen het doel en elke waarnemer. Als een waarnemer het doel in het midden van de pixel kan zien, wordt de pixel als zichtbaar beschouwd. Deze tool houdt altijd rekening met de kromming van de aarde wanneer de zichtbaarheid wordt bepaald.</div>",
		watershedName: "Watershed",
		watershedSnip: "Bepaalt het bijdragende gebied boven een set cellen in een raster.",
		watershedDesc: "De globale functie Stroomgebied bepaalt het bijdragende gebied boven een set pixels in een raster. Stroomgebieden zijn afgebakend van een stroomrichtingraster dat de stroomrichting van elke pixel identificeert.",
		weightedOverlayName: "Gewogen overlapping",
		weightedOverlaySnip: "Overlapt verschillende rasters met behulp van een gemeenschappelijke meetschaal en weegt elk op basis van het belang ervan.",
		weightedOverlayDesc: "Met deze functie kunt u verschillende rasters over elkaar leggen met behulp van een gemeenschappelijke meetschaal en elk wegen op basis van het belang ervan.",
		weightedSumName: "Gewogen som",
		weightedSumSnip: "Weegt en voegt een reeks rasters toe op een cel-voor-cel basis.",
		weightedSumDesc: "Met de functie Gewogen som kunt u verschillende rasters over elkaar leggen en ze vermenigvuldigen met het opgegeven gewicht en ze optellen.",
		windchillName: "Gevoelstemperatuur",
		windchillSnip: "Combineert omgevingsluchttemperatuur en windsnelheid om de factor gevoelstemperatuur te berekenen.",
		windchillDesc: "De functie Gevoelstemperatuur is handig voor het identificeren van gevaarlijke winteromstandigheden die, afhankelijk van de blootstelling aan de weersomstandigheden, kunnen resulteren in bevriezing of zelfs onderkoeling. Gevoelstemperatuur is een manier om te meten hoe koud iemand het zal hebben als rekening wordt gehouden met al koude temperaturen. Hoe sneller de windsnelheid, hoe sneller het lichaam warmte verliest en hoe kouder men het krijgt.",
		zonalRemapName: "Opnieuw toewijzen op basis van zones",
		zonalRemapSnip: "Pixels in een raster opnieuw toewijzen op basis van zones die zijn gedefinieerd in een ander raster en zoneafhankelijke waardetoewijzing die in een tabel is gedefinieerd.",
		zonalRemapDesc: "Met deze functie kunt u pixels in een raster opnieuw toewijzen op basis van zones die zijn gedefinieerd in een ander raster en zoneafhankelijke waardetoewijzing die in een tabel is vastgelegd.",
		zonalStatisticsName: "Gebiedsstatistieken",
		zonalStatisticsSnip: "Berekent statistieken over waarden van een raster in de zones van een andere dataset.",
		zonalStatisticsDesc: "De functie berekent statistieken over waarden van een raster in de zones van een andere dataset. Een zone is gedefinieerd als alle gebieden in de invoer die dezelfde waarde hebben. Deze gebieden hoeven niet aaneengesloten te zijn. Als de zone- en waarde-invoer beide rasters zijn met dezelfde resolutie, worden ze direct gebruikt. Als de resoluties anders zijn, wordt een interne resampling toegepast om de resoluties overeen te laten komen voordat de zonebewerking wordt uitgevoerd.",
		flowLengthName: "Stromingslengte",
		flowLengthSnip: "Berekent de stroomopwaartse of stroomafwaartse afstand, of gewogen afstand, langs het stromingstraject voor elke cel.",
		flowLengthDesc: "Dit is een globale rasterfunctie. Deze functie creëert een rasterlaag van stroomopwaartse of stroomafwaartse afstand, of gewogen afstand, langs het stromingstraject voor elke cel.<div><br/>Een primaire toepassing van de functie Stromingslengte is het berekenen van de lengte van het langste stromingstraject binnen een bepaald bekken. Deze maat wordt vaak gebruikt om de concentratietijd van een bekken te berekenen. Dit wordt gedaan met de optie Stroomopwaarts. De functie kan ook worden gebruikt om afstandsdiagrammen te maken van hypothetische neerslag en afvloeiingen met behulp van het gewichtenraster als een belemmering voor een neerwaartse beweging.</div>",
		streamOrderName: "Stromingsvolgorde",
		streamOrderSnip: "Wijst een numerieke volgorde toe aan segmenten van een raster die takken van een lineair netwerk voorstellen",
		streamOrderDesc: "Dit is een globale rasterfunctie. Deze functie creëert een rasterlaag die een numerieke volgorde toekent aan segmenten van een raster die aftakkingen van een lineair netwerk voorstellen.<div><br/>De output van de functie Stromingsvolgorde zal van hogere kwaliteit zijn als de input van de stroommrasterlaag en de input stromingsrichting van de rasterlaag worden van hetzelfde oppervlak afgeleid. Als het stroomraster is afgeleid van een gerasterde stroomdataset, dan is de output mogelijk niet bruikbaar, omdat de richting op celbasis niet zal overeenkomen met de locatie van de stroomcellen. De resultaten van de functie Stroomaccumulatie kunnen worden gebruikt om een rasterstroomnetwerk te creëren door een drempelwaarde toe te passen voor het selecteren van cellen met een hoge geaccumuleerde stroom. Zo worden bijvoorbeeld cellen met meer dan 100 cellen gebruikt om het stroomnet te definiëren. Gebruik de Con- of Set Null-functie om een stroomnetwerkraster te maken waarbij stroomaccumulatiewaarden van 100 of meer naar één raster gaan en de rest naar de achtergrond wordt geplaatst (NoData). Het resulterende stroomnetwerk kan worden gebruikt in de functie Stromingsvolgorde. Deze functie ondersteunt alleen een D8-invoerstroomrichtingrasterlaag. D8-stromingsrichtingen kunnen met behulp van de functie Stroomrichting worden aangemaakt en met de standaardstroomrichting type D8 worden uitgevoerd.</div>",
		snapPourPointName: "Stortpunt koppelen",
		snapPourPointSnip: "Koppelt stortpunten aan de cel met de hoogste stroomaccumulatie binnen een bepaalde afstand",
		snapPourPointDesc: "Dit is een globale rasterfunctie. Deze functie koppelt stortpunten aan de cel van de hoogste stroomaccumulatie binnen een bepaalde afstand.<div><br/>De functie Stortpunten koppelen wordt gebruikt om de selectie van punten met een hoge geaccumuleerde stroming te garanderen bij het afbakenen van afwateringsbekkens met behulp van de functie Stroomgebied. Stortpunten koppelen zoekt binnen een korte afstand rond de gespecificeerde stortpunten voor de cel met de hoogste geaccumuleerde stroming en verplaatst het stortpunt naar die locatie. De uitgang is een gehele rasterlaag wanneer de oorspronkelijke stortlocaties zijn gekoppeld aan locaties met een hogere geaccumuleerde stroming.</div>",
		sinkName: "Basin",
		sinkSnip: "Creëert een raster dat alle putten of gebieden van interne drainage identificeert",
		sinkDesc: "Dit is een globale rasterfunctie. Deze functie creëert een rasterlaag die alle basins of gebieden van interne drainage identificeert. Een put is een cel of set van ruimtelijk verbonden cellen met een stroomrichting die niet kan worden toegewezen aan één van de acht geldige waarden in een stromingsrichtingraster. Dit kan gebeuren wanneer alle aangrenzende cellen hoger zijn dan de verwerkende cel of wanneer twee cellen in elkaar vloeien, waardoor een tweecellenlus ontstaat.<div><br/>De functie Put ondersteunt alleen een D8-ingangstromingsrichting rasterlaag. D8-stromingsrichtingen kunnen met behulp van de functie Stroomrichting worden aangemaakt en met de standaardstroomrichting type D8 worden uitgevoerd. De uitgang van de functie Put is een geheel raster, waarbij aan elke put een unieke waarde wordt toegekend. Deze unieke waarden hebben een bereik dat ligt tussen één en het totale aantal putten. Als het totaal aantal putten bijvoorbeeld 1000 is, variëren de unieke waarden van 1 tot 1000.</div>",
		aggregateName: "Aggregeren",
		aggregateSnip: "Genereert een versie met een verkleinde resolutie van een raster.",
		aggregateDesc: "De functie Aggregeren herstelt een invoerraster naar een grovere resolutie op basis van een gespecificeerde aggregatiestrategie. Elke uitvoercel bevat de som, het minimum, het maximum, het gemiddelde of de mediaan van de invoercellen die door de omvang van die cel worden bestreken.<div><br/>U kunt de factor opgeven waarmee de celgrootte van het invoerraster vermenigvuldigd moet worden. Bijvoorbeeld, een celfactorwaarde van 3 zou resulteren in een uitvoer waarbij de celgrootte drie keer groter is dan die van het invoerraster. U kunt bepalen hoe de omvang van de uitvoer moet worden verwerkt als het aantal rijen of kolommen in de invoer geen exacte veelvoud is van de celfactor. Standaard worden de boven- en rechtergrenzen uitgebreid tot een grotere ruimtelijke omvang dan die van het invoerraster, zodat alle invoercellen worden verwerkt. Als alternatief kunnen de boven- en rechtergrenzen worden gereduceerd tot een kleiner aantal rijen en kolommen, zodat het aantal verwerkte rijen en kolommen een exacte veelvoud is van de celfactor. U kunt bepalen hoe NoData-cellen moeten worden behandeld door de aggregatieberekening. In het standaardmechanisme worden NoData-cellen die in de ruimtelijke omvang van een grotere cel in het uitvoerraster vallen genegeerd bij het bepalen van de waarde van die uitvoercel. Als alternatief kunt u opgeven dat als er ook maar één enkele invoer NoData-cel binnen de ruimtelijke omvang van een uitvoercel is, die cel NoData in het uitvoerraster zal zijn.</div>",
		ccdcName: "CCDC-analyse",
		ccdcSnip: "Evalueert veranderingen in pixelwaarden in de loop van de tijd met behulp van het Continuous Change Detection and Classification (CCDC)-algoritme en genereert modelresultaten.",
		ccdcDesc: "De CCDC-analysefunctie evalueert veranderingen in pixelwaarden na verloop van tijd met behulp van het Continuous Change Detection and Classification (CCDC)-algoritme en genereert een multidimensionaal raster dat de modelresultaten bevat. Het wordt alleen ondersteund in combinatie met de functie 'Detect Change Using Change Analysis' in een rasterfunctietemplate. Om een rasteruitvoer te produceren, verbindt u de CCDC-analysefunctie met de functie Detect Change Using Change Analysis-functie, slaat u op als een rasterfunctietemplate en voert u Rasteranalyse uit met de functietemplate.<div><br/>Deze functie maakt gebruik van het Continuous Change Detection and Classification (CCDC)-algoritme om veranderingen in de pixelwaarden in de loop van de tijd te evalueren voor meerdere afbeeldingen. In een tijdreeks van optische beelden of beeldderivaten (bijvoorbeeld NDVI) kunnen pixelwaarden om verschillende redenen fluctueren: 1. Seizoensverandering -- Pixelwaardeveranderingen weerspiegelen veranderingen in de vegetatie als gevolg van seizoensgebonden variaties in temperatuur en neerslag. Op het noordelijk halfrond verwachten we bijvoorbeeld in de zomer een hogere dichtheid van de groene vegetatie te zien dan in de winter; 2. Geleidelijke verandering -- Pixelwaardeveranderingen weerspiegelen trends in de vegetatie of het oppervlaktewater als gevolg van klimaatvariabiliteit of landbeheer op lange termijn. Zo kan bijvoorbeeld de kale grond geleidelijk aan toenemen als gevolg van een langdurige daling van de neerslag; en 3. Abrupte verandering -- Pixelwaardeveranderingen weerspiegelen veranderingen in de landbedekking die plotseling optreden als gevolg van ontbossing, stedelijke ontwikkeling, natuurrampen, enzovoort. Het CCDC-algoritme identificeert alle drie de veranderingstypes met als hoofddoel het identificeren van abrupte veranderingen. Harmonische regressie- en trendmodellen zijn afgestemd op de data om seizoensgebonden en geleidelijke veranderingen in te schatten. Plotselinge afwijkingen van de trendmodellen zijn aanwijzingen voor abrupte veranderingen.<div><br/>Het CCDC-algoritme is oorspronkelijk ontworpen voor Landsat TM, Landsat ETM+ en Landsat OLI data Surface Reflectance of Brightness Temperature data. . Maar de functie Verandering detecteren met behulp van veranderingsanalyse in combinatie met deze functie detecteert veranderingen voor multibandbeelden van elke ondersteunde sensor, evenals van afzonderlijke bandbeeldderivaten, zoals bandindexen. U kunt bijvoorbeeld een continue veranderingsdetectie uitvoeren op een Normalize Difference Vegetation Index (NDVI) raster, omdat abrupte veranderingen in NDVI indicatief kunnen zijn voor ontbossing.</div>",
		computeChangeName: "Verandering berekenen",
		computeChangeSnip: "Berekent het verschil tussen twee categorische of continue rasterdatasets.",
		computeChangeDesc: "De functie \"Verandering berekenen\" kan worden gebruikt om de verschillen tussen twee geclassificeerde rasters op te sommen voor de analyse van landbedekkingsverandering of het kan worden gebruikt om veranderingen tussen twee single-band continu rasters te onderzoeken, zoals hoogte, temperatuur, bladerbedekking, enzovoort.",
		detectChangeName: "Verandering detecteren met behulp van veranderingsanalyse",
		detectChangeSnip: "Genereert een rasterlaag met informatie over pixelveranderingen met behulp van het uitvoer veranderingsanalyseraster.",
		detectChangeDesc: "<div>De functie Verandering detecteren met behulp van veranderingsanalyse genereert een rasterlaag met informatie over pixelveranderingen met behulp van het uitvoerraster voor de analyse van veranderingen. Het veranderingsanalyseraster moet worden gegenereerd door de tool Veranderingen analyseren met behulp van CCDC of de tool Veranderingen analyseren met behulp van de LandTrendr of de CCDC-analyserasterfunctie of de rasterfunctie LandTrendr-analyse.</div><br><div>Deze rasterfunctie kan worden gecombineerd met de CCDC analyse rasterfunctie of de rasterfunctie van de LandTrendr-analyse in een rasterobject. Om een permanente rasteruitvoer te produceren verbindt u de CCDC-analyse of LandTrendr-analyse uitvoer met de functie Veranderen met behulp van Wijzigingsanalyse, slaat u op als een rasterfunctietemplate en voert u Rasteranalyse uit met de template.</div><br><div>De parameter<strong>Type Wijzigen</strong> geeft de informatie aan die wordt gegenereerd. De informatie wordt gehaald uit het veranderingsanalyseraster. Wanneer u deze functie op de uitvoer van de CCDC-functie/tool uitvoert, kunt u kiezen uit de volgende opties:</div><ul><li><strong>Tijdstip van laatste wijziging</strong>--de meest recente datum en tijd waarop een pixel is gemarkeerd als zijnde gewijzigd.</li><li><strong>Tijdstip van vroegste wijziging</strong>--de vroegste datum en tijd waarop een pixel is gemarkeerd als zijnde gewijzigd.</li><li><strong>Tijdstip van grootste wijziging</strong>--de datum en tijd waarop de berekende wijziging het meest significant was voor een pixel.</li><li> <strong>Aantal wijzigingen</strong>--Het totale aantal keren dat de pixel is gewijzigd.</li></ul><div>Bij het uitvoeren van deze functie op de uitvoer van de LandTrendr-functie/tool zijn de volgende extra opties beschikbaar:</div><ul><li><strong>Tijdstip van langste wijziging</strong>--Het tijdstip waarop een pixel is gemarkeerd als zijnde gewijzigd, aan het begin of einde van de langste periode van wijziging.</li><li><strong>Tijdstip van kortste wijziging</strong>--Het tijdstip waarop een pixel is gemarkeerd als zijnde gewijzigd, aan het begin of einde van de kortste periode van wijziging.</li><li><strong>Tijdstip van snelste wijziging</strong>--de datum waarop een pixel als gewijzigd is gemarkeerd, aan het begin of einde van de snelste veranderingsperiode.</li><li><strong>Tijdstip van langzaamste wijziging</strong>--de datum waarop een pixel als gewijzigd is gemarkeerd, aan het begin of einde van de langzaamste veranderingsperiode.</li></ul><div>Het uitvoerraster is een multibandraster waarin elke band wijzigingsinformatie bevat, afhankelijk van het geselecteerde wijzigingstype en het maximale aantal wijzigingen dat is gespecificeerd. Als bijvoorbeeld <strong>Type wijzigen</strong> is ingesteld op <strong>Tijd vroegste verandering</strong> en <strong>Maximum aantal veranderingen</strong> is ingesteld op 2, berekent de functie voor elke pixel de twee vroegste data waarop de verandering zich in de gehele tijdreeks heeft voorgedaan. Het resultaat is een raster waarin de eerste band de data van de vroegste verandering per pixel bevat, en de tweede band de data van de op één na oudste verandering per pixel.</div><br><div>Wanneer u deze functie toepast op de uitvoer van de LandTrendr tools, kunt u kiezen of u de datum die het begin van een verandering markeert of het einde van een verandering extraheert met behulp van de parameter <strong>Segmentdatum</strong> . Om bijvoorbeeld te begrijpen hoe de meest recente verandering in de tijdreeks begon, stelt u de <strong>Veranderingstype</strong> in op <strong>Tijdstip van de laatste verandering</strong> en de <strong>Segmentdatum</strong> tot <strong>Begin van het segment</strong>.</div><br><div>Gebruik de volgende filterparameters om meer specifieke wijzigingsdatums uit uw wijzigingsanalyseraster te halen:</div><ul><li><strong>Filter op jaar</strong>--Identificeer wijzigingen die binnen een bepaalde tijdsperiode zijn opgetreden, bijvoorbeeld als u op zoek bent naar wijzigingen die zijn opgetreden in een landschap gedurende vijf jaar droogte.</li><li><strong>Filter op duur</strong>--Identificeer wijzigingen die zijn opgetreden gedurende een bepaalde tijdspanne, bijvoorbeeld als u alleen op zoek bent naar abrupte wijzigingen die zijn opgetreden gedurende 1 of 2 jaar. U kunt de duur die u interesseert berekenen aan de hand van de formule <strong>eindjaar - beginjaar +1</strong>. Hiaten in de tijdreeks zullen worden opgenomen.</li><li><strong>Filter op grootte</strong>--Identificeer veranderingen van een bepaalde grootte, bijvoorbeeld als u alleen op zoek bent naar grote veranderingen in de vegetatie-index NDVI. De grootte is een absolute waarde, dus de minimum- en maximumwaarde kunnen niet negatief zijn. Gebruik de parameter <strong>Richting veranderen</strong> om een richtingsverandering aan te geven</li></ul>",
		distanceAccumulationName: "Afstandsaccumulatie",
		distanceAccumulationSnip: "Berekent de verzamelde afstand voor elke cel naar de bronnen met mogelijkheid tot lineaire afstand, kostenafstand, afstand daadwerkelijk oppervlak alsmede verticale en horizontale kostenfactoren.",
		distanceAccumulationDesc: "Afstandsaccumulatie berekent de afstand tot elke locatie in het onderzoeksgebied tot de dichtstbijzijnde, of goedkoopste, bron. Als alleen de bronnen voor de invoer zijn voorzien, dan wordt een rechte afstand berekend tot elke locatie in het onderzoeksgebied. Als beide bronnen en barrières als invoer worden gebruikt, dan berekent Afstandsaccumulatie de lineaire afstand rond de barrières. Voor zowel de bron- als de barrièreraster moet de achtergrondwaarde NoData zijn, terwijl bronnen en barrières met geldige celwaarden worden weergegeven. Geldige waarden bevatten nul. <div><br/>Wanneer een oppervlakteraster als invoer wordt geleverd, dan wordt de werkelijke oppervlakteafstand tussen de cellen berekend. Voor het uitvoeren van een kostenanalyse met behulp van Afstandsaccumulatie is een kostenoppervlak nodig. Als er een kostenoppervlak wordt voorzien, dan is het resultaat een geaccumuleerd kostenafstandsraster. Wanneer horizontale en verticale factoren worden geleverd, dan wordt de directionaliteit geaccumuleerd als kosten. Er zijn vier bronkenmerken die kunnen worden gebruikt. Deze kenmerken, die zowel van de bron als van de verplaatsers van de bron kunnen zijn, worden gecontroleerd door specifieke parameters: 1. De initiële accumulatie: stelt de initiële kosten in voordat de verplaatsing begint. 2. Maximale accumulatie: specificeert hoeveel kosten een bron kan accumuleren voordat hij zijn limiet bereikt. 3. Vermenigvuldigingsfactor voor de kosten: specificeert de wijze van reizen of de grootte bij de bron. 4. Reisrichting: identificeert of de verplaatser begint bij een bron en zich verplaatst naar niet-bronlocaties, of, begint bij niet-bronlocaties en zich terug verplaatst naar een bron.<div><br/>Standaard is het resultaat van Afstandsaccumulatie een enkele band, dat is het afstandsaccumulatieraster. Er kan echter ook een tweede band worden gecreëerd, de band terugweg. Deze band geeft vanuit elke locatie in het onderzoeksgebied aan in welke richting je moet gaan om de goedkoopste bron te bereiken. Beide banden zijn nodig om optimale paden binnen het onderzoeksgebied te bepalen. Gebruik om een pad te genereren eerst de functie Band extraheren om het raster afstandsaccumulatie en het raster terugweg te extraheren. Gebruik deze lagen als invoer voor de functie Kostenpad. Gebruik in deze functie het raster afstandsaccumulatie als de invoer Raster afstand kosten en het raster terugweg als de invoer Raster terugkoppeling kosten.</div>",
		distanceAllocationName: "Afstandtoewijzing",
		distanceAllocationSnip: "Berekent de afstandstoewijzing voor elke cel tot de gegeven bronnen op basis van de lineaire afstand, kostenafstand, daadwerkelijke oppervlakte-afstand en verticale en horizontale kostenfactoren.",
		distanceAllocationDesc: "Afstandstoewijzing berekent aan welke bron elke locatie in het onderzoeksgebied wordt toegewezen. Als alleen de bronnen zijn voorzien voor de invoer, dan worden de locaties toegewezen met behulp van een lineaire afstand tot de dichtstbijzijnde bron. Als beide bronnen en barrières als invoer worden gebruikt, dan berekent Afstandtoewijzing de lineaire afstand rond barrières om te bepalen aan welke bron een locatie wordt toegewezen. Voor zowel de bron- als de barrièreraster moet de achtergrondwaarde NoData zijn, terwijl bronnen en barrières met geldige celwaarden worden weergegeven. Geldige waarden bevatten nul.<div><br/>Voor het uitvoeren van een kostenanalyse met behulp van Afstandtoewijzing is een kostenoppervlak nodig. Als er een kostenoppervlak wordt opgegeven, dan is het resultaat een verdeelraster op basis van de cumulatieve kosten, niet op basis van de lineaire afstand. Wanneer horizontale en verticale factoren worden geleverd, dan wordt de directionaliteit geaccumuleerd als kosten. Wanneer er een oppervlakteraster wordt geleverd als invoer, dan wordt bij de bepaling van de allocatie de werkelijke oppervlakteafstand berekend die wordt afgelegd tussen de cellen. Er zijn vier bronkenmerken die kunnen worden gebruikt. Deze kenmerken, die zowel van de bron als van de verplaatsers van de bron kunnen zijn, worden gecontroleerd door specifieke parameters: 1. Initiële accumulatie: stelt de initiële kosten in voordat de verplaatsing begint. 2. Maximale accumulatie: specificeert hoeveel kosten een bron kan accumuleren voordat hij zijn limiet bereikt. 3. Vermenigvuldigingsfactor voor de kosten: specificeert de wijze van reizen of de grootte bij de bron. 4. Reisrichting: identificeert of de verplaatser begint bij een bron en zich verplaatst naar niet-bronlocaties, of, begint bij niet-bronlocaties en zich terug verplaatst naar een bron.<div><br/>Standaard is het resultaat van Afstandstoewijzing een enkele band, dat is het afstandstoewijzingsraster. Het aanvinken van de Booleaanse optie Genereer bronrij en kolom als extra banden in de uitvoer zal resulteren in een multibandraster bestaande uit drie banden. De eerste band is de afstandtoewijzingsband, de tweede band bevat een rijindex en de derde band bevat een kolomindex. Deze indexen identificeren de locatie van de broncel die de minst geaccumuleerde kostenafstand is. De bronrij-index en de bronkolomindex kunnen samen worden gebruikt om de intensiteit in kaart te brengen. Als u een locatie in uw onderzoeksgebied over de banden twee en drie bevraagt, weet u de rij en de kolom van de laagste kostenbron voor die locatie.</div>",
		eucBackDirectionName: "Euclidische terugweg",
		eucBackDirectionSnip: "Berekent voor elke cel de richting, in graden, naar de naburige cel langs het kortste pad terug naar de dichtstbijzijnde bron, terwijl barrières worden vermeden.",
		eucBackDirectionDesc: "De Euclidische terugweg resulteert in een continu drijfpuntraster dat de richting in graden terug naar de dichtstbijzijnde bron weergeeft, terwijl barrières worden vermeden, als er barrières worden aangebracht.<div><br/>De ingangen naar Euclidische terugweg zijn de bron waarvoor de richting wordt berekend. Een optionele invoer is een raster dat barrières binnen het onderzoeksgebied vertegenwoordigt. Voor zowel de bron- als de barrièreraster moet de achtergrondwaarde NoData zijn, terwijl bronnen en barrières met geldige waarden worden weergegeven. Geldige waarden bevatten nul. Standaard verwerkt de berekening de gecombineerde omvang van de bronnen en barrières, plus 2 rijen en kolommen. Als de analyse alleen nodig is binnen een bepaalde afstand van de bronnen, dan kan de parameter Maximale afstand worden gebruikt. Euclidische terugweg ondersteunt zowel een Planaire methode als een Geodetische methode in de berekening. De berekening Planaire methode wordt uitgevoerd op een geprojecteerd plat vlak met behulp van een 2D Cartesiaans coördinatensysteem. De berekening van de geodetische methode wordt uitgevoerd op de ellipsoïde, wat betekent dat de resultaten, ongeacht de in- of uitvoerprojectie, niet veranderen.<div><br/>Het resultaat van de functie Euclidische terugweg kan samen met het resultaat van de functie Euclidische afstand worden gebruikt om de kortste paden van locaties binnen het onderzoeksgebied terug naar de bron te bepalen. Zowel het resultaat van de Euclidische terugweg als het resultaat van de Euclidische afstand worden in de functie Kostenpad gebruikt, samen met de bestemmingen om de kortste paden te genereren.</div>",
		expandName: "Uitklappen",
		expandSnip: "Klapt geselecteerde zones van een raster uit met een bepaald aantal cellen.",
		expandDesc: "Met de functie Uitklappen kunt u rasters veralgemenen of vereenvoudigen door bepaalde zones groter te maken. U kunt ook de hoeveelheid veralgemening die zal optreden controleren.<div><br/>De zones die u selecteert, worden groter door uitbreiding naar andere zones. Conceptueel kunnen de geselecteerde zonewaarden worden gezien als voorgrondzones, terwijl de andere waarden achtergrondzones blijven. De voorgrondzones kunnen zich uitbreiden naar de achtergrondzones.<div><br/>De hoeveelheid generalisatie kan worden geregeld met de parameter Aantal cellen. Standaard is deze waarde 1, wat betekent dat de geselecteerde zones zich uitbreiden in een matie die overeenkomt met de grootte van een cel. Om de mate van generalisatie te verhogen, kunt u een grotere waarde voor deze parameter opgeven. Conceptueel is dit als het uitvoeren van de tool zo vaak als het opgegeven aantal, waarbij de resultaten van de vorige run de input zijn voor de volgende iteratie.</div>",
		trendAnalysisName: "Trend genereren",
		trendAnalysisSnip: "Schat de trend voor elke pixel in een afmeting voor een of meerdere variabelen in een multidimensionaal raster.",
		trendAnalysisDesc: "<div>Deze functie kan worden gebruikt om gegevens langs een lineaire, harmonische of polynomiale trendlijn te plaatsen, of het kan worden gebruikt om trenddetectie uit te voeren met behulp van de Mann-Kendall of Seasonal-Kendall test.</div><br><div>Het uitvoertrendraster dat met deze functie wordt gegenereerd, wordt gebruikt als input voor de <strong>Predict Using Trend</strong> functie.</div><br><div>De Mann-Kendall en Seasonal-Kendall tests worden gebruikt om te bepalen of er een monotone trend in de gegevens zit. Ze zijn niet-parametrisch, wat betekent dat ze niet uitgaan van een specifieke verdeling van gegevens. De Mann-Kendall test houdt geen rekening met seriële correlatie of seizoensgebonden effecten. Als de gegevens seizoensgebonden zijn, is de Seasonal-Kendall-test geschikter.</div><br><div>Als de tool wordt gebruikt om de Mann-Kendall- of Seasonal-Kendall-test uit te voeren, is de output een vijfbanden-raster als volgt:</div><ul><li>Band 1 = Sen's slope</li><li>Band 2 = p-waarde</li><li>Band 3 = Mann-Kendall score (S)</li><li>Band 4 = S Variance</li><li>Band 4 = S Variance</li><li>Band 5 = Z-score</li></ul><div>De output van de Mann-Kendall of Seasonal-Kendall test kan worden gebruikt om te bepalen welke pixels in uw multidimensionale tijdreeksen een statistisch significante trend hebben. U kunt deze informatie gebruiken in combinatie met de lineaire, harmonische of polynomiale trendanalyse om significante trends in uw tijdreeksen te extraheren. U kunt een masker inclusief pixels met significante p-waarden genereren, het masker op het multidimensionale raster toepassen en dit gemaskerde multidimensionale raster gebruiken als input voor de tool om een lineaire, harmonische of polynomiale trendanalyse uit te voeren.</div><br><div>Er zijn drie trendlijnopties voor het aanpassen van een trend aan de variabele waarden langs een dimensie: lineair, polynomiaal en harmonisch.</div><br><div>Voor de lineaire trendanalyse is de output een drie-bands raster als volgt:</div><ul><li>Band 1 = Helling</li><li>Band 2 = Onderscheppen</li><li>Band 3 = Root Mean Square Error (RMSE) of de fout rond de best passende lijn</li></ul><div>Voor polynomiale trendanalyse is het aantal banden in de uitgang afhankelijk van de polynomiale volgorde. Tweede-orde polynomiale montage produceert een vier-bands raster als volgt:</div><ul><li>Band 1 = Polynomiaal_2</li><li>Band 2 = Polynomiaal_1</li><li>Band 3 = Polynomiaal_0</li><li>Band 4 = RMSE</li></ul><div>Polynomiaal beslag van derde orde produceert een vijfbandsraster als volgt:</div><ul><li>Band 1 = Polynomiaal_3</li><li>Band 2 = Polynomiaal_2</li><li>Band 3 = Polynomiaal_1</li><li>Band 4 = Polynomiaal_0</li><li>Band 5 = RMSE</li></ul><div>Voor de harmonische trendanalyse is het aantal banden in de uitgang afhankelijk van de harmonische frequentie. Wanneer de frequentie op 1 staat, is de uitgang een vijfbandsraster als volgt:</div><ul><li>Band 1 = Slope</li><li>Band 2 = Intercept</li><li>Band 3 = Harmonic_sin1</li><li>Band 4 = Harmonic_cos1</li><li>Band 5 = RMSE</li></ul><div>Wanneer de frequentie op 2 is ingesteld, is de uitgang een zevenbandsraster als volgt:</div><ul><li>Band 1 = Slope</li><li>Band 2 = Intercept</li><li>Band 3 = Harmonic_sin1</li><li>Band 4 = Harmonic_sin2</li><li>Band 5 = Harmonic_sin2</li><li>Band 6 = Harmonic_cos2</li><li>Band 7 = RMSE</li></ul><div>De parameter <strong>Lengte van de cyclus</strong> voor de analyse van harmonische trends wordt gebruikt om het aantal en de lengte van de cycli aan te geven die u gedurende een dag of een jaar in uw gegevens verwacht te zien. Als u bijvoorbeeld verwacht dat uw gegevens twee variatiecycli in een jaar zullen doorlopen, zal de lengte van de cyclus 182,5 dagen of 0,5 jaar zijn. Als er om de drie uur temperatuurgegevens worden verzameld en er is één variatiecyclus per dag, dan is de lengte van de cyclus één dag.</div><br><div>De parameter <strong>Frequentie</strong> voor de analyse van harmonische tendensen wordt gebruikt om het harmonische model te beschrijven dat bij de gegevens past. Als de frequentie op 1 wordt ingesteld, wordt een combinatie van lineaire en de harmonische curve van de eerste volgorde gebruikt om het model te passen. Als de frequentie 2 is, zal een combinatie van lineaire, eerste volgorde harmonische curve, en tweede volgorde harmonische curve worden gebruikt om de gegevens aan te passen. Als de frequentie 3 is, wordt een extra harmonische curve van de derde volgorde gebruikt om de gegevens te modelleren, enzovoort.</div><br><div>Model goodness-of-fit statistieken kunnen gegenereerd worden als optionele outputs. De root mean-square error (RMSE), R-kwadraat en de trendhelling p-waarde kunnen worden berekend en gesymboliseerd. Symboliseer de uitvoertrendrasterlaag met behulp van de <strong>RGB</strong> symbologie en specificeer de statistieken als de rode, groene en blauwe banden</div><br>",
		spectralUnmixingName: "Lineaire spectrale ontmenging",
		spectralUnmixingSnip: "Voert subpixelclassificatie uit en berekent de fractionele overvloed aan verschillende landbedekkingstypes voor individuele pixels.",
		spectralUnmixingDesc: "De functie Lineaire spectrale ontmenging berekent de fractionele dekking voor individuele pixels die meerdere landbedekkingstypes bevatten. Het genereert een multibandlaag, waarbij elke band overeenkomt met de fractionele overvloed van elke landbedekkingsklasse. U kunt het bijvoorbeeld gebruiken om een landbedekkingsclassificatie uit te voeren op een multispectraal beeld om fotosynthetische vegetatie, kale grond en dode of niet-fotosynthetische vegetatie te identificeren.<div><br/>De volgorde van het uitvoermultibandraster volgt de volgorde van de invoer spectraal profiel. Het aantal klassen mag niet groter zijn dan het aantal banden in het invoerraster. U kunt bijvoorbeeld geen informatie over meer dan 8 klassen uit een 8-bands raster halen.</div>",
		multidimensionalFilterName: "Multidimensionale filter",
		interpolateRasterByDimensionFunctionName: "Raster interpoleren op afmeting",
		interpolateRasterByDimensionFunctionSnip: "Interpoleert een multidimensionaal raster met opgegeven dimensiewaarden, gebruik makend van aangrenzende slices.",
		interpolateRasterByDimensionFunctionDesc: "<p>Deze functie stelt u ertoe in staat pixelwaarden te schatten voor een ongedefinieerde dimensieslice in een multidimensionaal raster. Als u bijvoorbeeld een gegevensset hebt die de oceaantemperatuur aan het oppervlak en die op 100 meter onder zeeniveau bevat en de temperatuur op 50 meter onder zeeniveau wilt schatten, kunt u deze functie gebruiken om een schatting voor die diepte te krijgen met behulp van de dimensiedefinitie By Values (Op waarden).</p><p>U kunt ook een maandelijkse gegevensset downsamplen naar een dagelijkse gegevenset via de dimensiedefinitie By Interval (Op interval) en het opgeven van de Stap-parameterwaarde als 1 en de Eenheid-parameter als dagen.</p><p>Gebruik de dimensiedefinitie By Target Raster (Op doelraster) om de waarde voor het doelraster te schatten.</p>",
		multidimensionalFilterSnip: "Maakt een rasterlaag van een multidimensionale rasterdataset of een multidimensionale rasterlaag door data in stukjes op te delen aan de hand van gedefinieerde variabelen en afmetingen.",
		multidimensionalFilterDesc: "Het Multidimensionale filter creëert een multidimensionale rasterlaag door een subset van variabelen uit een multidimensionaal raster te filteren en te extraheren. U hebt bijvoorbeeld een multidimensionale dataset die 30 jaar aan maandelijkse neerslaggegevens bevat, en u wilt alleen gegevens voor elke januari extraheren om te zien hoe de neerslag voor die maand is veranderd.<div><br/>Gebruik de parameter Dimensiedefinitie om dimensies te snijden met behulp van een interval, een waarde of een reeks van waarden. Als u bijvoorbeeld over 10 jaar gegevens over het zeezoutgehalte beschikt, die maandelijks worden verzameld en op zowel 2 meter diepte als op 500 meter, kunt u voor de volgende scenario's gebruik maken van de verschillende dimensioneringsopties. Scenario 1: Extraheer de zoutgehaltegegevens voor de maand januari over de periode van 10 jaar. Kies Op waarden, stel Dimensie in op StdTijd en stel Waarden in op Januari. Scenario 2: Verdeel de zoutgehaltegegevens over een dieptebereik van 0 tot 150 meter. Kies op Op bereik, stel Dimensie in op StdZ en stel Minimumwaarde in op -150 en Maximumwaarde op 0. Scenario 3: Extraheer de zoutgehaltegegevens voor de eerste 10 dagen van elke januari over een periode van 10 jaar. Kies Per iteratie, stel Dimensie in op StdTime, stel Start van de eerste iteratie en Einde van de eerste iteratie in op het overeenkomstige begin en einde van de iteratieperiode, stel Stap in op 1, en stel Eenheid in op Jaren.</div>",
		multidimensionalRasterName: "Multidimensionaal raster",
		multidimensionalRasterSnip: "Voegt multidimensionale gegevens toe aan een kaart als een multidimensionale rasterlaag.",
		multidimensionalRasterDesc: "De functie Multidimensionaal raster voegt multidimensionale gegevens toe aan een kaart als een multidimensionale rasterlaag. Deze functie is nuttig bij het uitvoeren van rasteranalyses met behulp van een functieketen.<div><br/>Ondersteunde multidimensionale rasterdatasets zijn onder andere netCDF, GRIB, HDF en Esri's CRF. Multidimensionale mosaic datasets worden ook ondersteund.</div>",
		optimalPathAsRasterName: "Optimaal pad als raster",
		optimalPathAsRasterSnip: "Berekent het pad met de minste kosten van een bron naar een bestemming.",
		optimalPathAsRasterDesc: "Deze globale functie produceert een uitvoerraster waarmee het optimale pad of paden van geselecteerde locaties naar de dichtstbijzijnde broncel worden vastgelegd binnen het geaccumuleerde kostenoppervlak, in termen van kostenafstand.<div><br/>Een of meer van de gewogen kostenfuncties (Afstandsaccumulatie of Afstandtoewijzing) moeten over het algemeen worden uitgevoerd voordat de functie Optimaal pad als raster worden uitgevoerd om de input afstandsaccumulatie en terugwegrasters te creëren. Dit zijn verplichte invoerrasterlagen voor de functie Optimaal pad. De waarden op de uitvoer optimaal pad geven het aantal paden op een bepaalde locatie weer. In veel gevallen volgen de paden dezelfde route, waarbij een bron wordt verlaten en vervolgens wordt afgeweken om naar verschillende bestemmingen te gaan. Zo geeft een waarde van één aan dat er op een bepaalde locatie slechts één optimaal pad is, terwijl een waarde van vijf betekent dat er op die locatie vijf optimale paden door die cel in het onderzoeksgebied lopen.<div><br/>De ingevoerde bestemmingsgegevens moeten een rasterlaag zijn. De set bestemmingscellen bestaat uit alle cellen in het invoerraster die geldige waarden hebben. Cellen die NoData waarden hebben zijn niet in de set opgenomen. De waarde nul wordt beschouwd als een legitieme bestemming. Een bestemmingsraster kan worden gemaakt met behulp van de extractietools. Als u bestemmings- of bronobjecten heeft, kunt u deze met behulp van de Rasterize Features-functie omzetten naar een raster. Gebruik de afstandaccumulatie of de raster terugweg als de rasterinvoer voor de functie rasterisatie. Dit zorgt ervoor dat de functie wordt gerasterd met behulp van dezelfde celgrootte, omvang en ruimtelijke referentie als de andere rasters die in de functie Optimaal pad als raster gaan. De functie Optimaal pad als raster kan ook worden gebruikt om de weg van de minste weerstand af te leiden langs een digitaal hoogtemodel (DEM). Gebruik in dit geval de DEM voor het accumulatieraster invoerafstabden de uitgang van de functie Stroomrichting voor het raster terugweg.</div>",
		trendName: "Voorspellen met behulp van trends",
		trendSnip: "Berekent een voorspeld multidimensionaal raster met behulp van het uitgevoerde trendraster van de functie Trend genereren of de geoprocessingtool Trendraster genereren.",
		trendDesc: "De functie Voorspellen met behulp van trends berekent een voorspelde multidimensionale rasterlaag met behulp van het uitvoertrendraster van de functie Trend genereren of de geoprocessingtool Trendraster genereren.",
		rasterCollectionName: "Rastercollectie verzamelen",
		rasterCollectionSnip: "Verwerkt elk stukje in een multidimensionaal raster of elk item in een mozaïekraster. Deze functie kan ook meerdere stukjes samenvoegen tot één stukje.",
		rasterCollectionDesc: "De functie Rastercollectie verzamelen verwerkt elke stukje in een multidimensionaal raster of elk item in een mozaïekraster. Deze functie kan ook meerdere stukjes samenvoegen tot één stukje.<div><br/>Deze functie verwerkt elk stukje in een multidimensionaal raster of mozaïekraster met behulp van een rasterfunctietemplate. Deze functie ondersteunt de volgende opties: 1. Specificeer een rasterfunctietemplate voor Itemfunctie. U hebt bijvoorbeeld een mozaïekdataset met 20 jaar Landsat-beelden en u wilt de NDVI voor elke scene in de tijdreeks berekenen. Specificeer voor Itemfunctie een rasterfunctietemplate die de NDVI rasterfunctie bevat. 2. Specificeer een rasterfunctietemplate voor de functie Aggregatie. U hebt bijvoorbeeld een multidimensionaal raster dat 10 jaar dagelijkse temperatuurgegevens bevat en u wilt de maximale temperatuur voor elk jaar berekenen. Geef in de functie Aggregatie een template op voor een rasterfunctietemplate op die de functie Celstatistieken bevat, waarbij de bewerking is ingesteld op Maximum. Stel onder de definitie Aggregatie de Dimensie in op StdTijd, stel Type in op Interval trefwoord en stel de Trefwoord Interval in op Jaarlijks. Houd er rekening mee dat als de invoermozaïek dataset niet multidimensionaal is, de aggregatiefunctie de aggregatiedefinitie niet zal honoreren. De aggregatiefunctie zal alle items of elke groep samenvoegen tot één als ze zijn gedefinieerd in de template van de aggregatiefunctie. Voor meer informatie over het gebruik van groepen in een mozaïekdataset, zie Mozaïekdataset-items gebruiken in Rasterfunctietemplates. 3. Specificeer een rasterfunctietemplate voor de functie Verwerking. De functie of functieketen in deze template wordt gebruikt om het nieuwe verwerkte raster weer te geven. Specificeer bijvoorbeeld een rasterfunctietemplate die de functie Kleurenkaart bevat om te wijzigen hoe de verwerkte rasterlaag wordt weergegeven. Houd er rekening mee dat als de invoer een multidimensionaal raster is, de verwerkingsfunctie wordt toegepast op het huidige stukje. Als de invoer een mozaïeklaag of mozaïekdataset is, wordt de verwerkingsfunctie toegepast op het mozaïekraster met behulp van de eerste methode om overlappingen op te lossen. 3. Specificeer templates voor elke combinatie van de drie functies. U hebt bijvoorbeeld een mozaïekdataset met tijdreeksen Landsat-beelden en u wilt een compositiefoto van maximaal NDVI genereren. Specificeer voor Itemfunctie een rasterfunctietemplate die de NDVI rasterfunctie bevat. Geef voor de functie Aggregatie een template op voor een rasterfunctietemplate op die de functie Celstatistieken bevat, waarbij de bewerking is ingesteld op Maximum. Specificeer voor de verwerkingsfunctie een rasterfunctietemplate die de functie Kleurenkaart bevat. Zorg dat de volgorde van de functieverwerking de volgorde van de invoerparameters volgt. Zo zal bijvoorbeeld de Itemfunctie als eerste worden verwerkt.</div>",
		randomName: "Willekeurig",
		randomSnip: "Creëert een raster met willekeurige pixelwaarden die zijn afgeleid van een pseudorandom-verdeling. Verschillende verdelingen en willekeurige nummergeneratoren worden ondersteund.",
		randomDesc: "De functie Willekeurig creëert een raster met willekeurige pixelwaarden dat kan worden gebruikt in rasterfunctietemplates of mozaïekdatasets.<div><br/>Hoewel veel functies werken op een of meer invoerrasters, heeft de functie Willekeurig geen invoerraster nodig. Dit betekent dat het zich meer gedraagt als een rasterdataset dan als een functie, dus er moet bijzondere zorg worden besteed aan het toevoegen aan of verwijderen van de functieketen.</div>",
		shrinkName: "Krimpen",
		shrinkSnip: "Krimpt de geselecteerde zones met een bepaald aantal cellen door ze te vervangen door de waarde van de cel die het meest voorkomt in de buurt.",
		shrinkDesc: "Met de functie Globaal krimpen u rasters veralgemenen of vereenvoudigen door bepaalde zones kleiner te maken. U kunt ook de hoeveelheid veralgemening die zal optreden controleren.<div><br/>De zones die u selecteert zullen krimpen, of kleiner worden, door cellen uit de omliggende zones uit te klappen. Conceptueel kunnen de geselecteerde zonewaarden worden gezien als voorgrondzones, terwijl de andere waarden achtergrondzones blijven. De cellen in de voorgrondzones kunnen worden vervangen door cellen in de achtergrondzones. Dunne eilandjes binnen een zone, die als gedeelde grenzen met de zone kunnen worden beschouwd, kunnen ook worden vervangen.<div><br/>De hoeveelheid generalisatie kan worden geregeld met de parameter Aantal cellen. Standaard is deze waarde 1, wat betekent dat de geselecteerde zones zullen krimpen met de grootte die overeenkomt met de grootte van een cel. Om de mate van generalisatie te verhogen, kunt u een grotere waarde voor deze parameter opgeven. Conceptueel is dit als het uitvoeren van de tool zo vaak als het opgegeven aantal, waarbij de resultaten van de vorige run de input zijn voor de volgende iteratie.</div>",
		trendToRGBName: "Trend naar RGB",
		trendToRGBSnip: "Converteert een trendraster naar driebanden (rood, groen en blauw) raster.",
		trendToRGBDesc: "De functie Trend naar RGB converteert een trendraster naar een driebanden (rood, groen en blauw) raster. De trendraster wordt gegenereerd van de rasterfunctie Trend genereren of de rasterfunctie CCDC-analyse.<div><br/>Deze functie is nuttig voor het visualiseren van modelcoefficiëntiedata van de functie Trend genereren of de functie CCDC-analyse. Beide functies schatten trends in veranderende pixelwaarden in, maar de resultaten van de functies zijn moeilijk direct te interpreteren.<div><br/>Zoals bij veel rasterfuncties is het mogelijk dat u Dynamic Range Adjustment (DRA) moet gebruiken om de resultaten van deze functie beter weer te geven.</div>",
		landTrendrName: "LandTrendr analyse",
		landTrendrSnip: "Evalueert veranderingen in pixelwaarden na verloop van tijd met behulp van de Landsat-based detectie van trends in verstoring en herstel (LandTrendr)- methode en genereert een multidimensionaal raster dat de modelresultaten bevat.",
		landTrendrDesc: "Deze rasterfunctie kan alleen worden gebruikt als invoer voor de rasterfunctie 'Detect Change Using Change Analysis'. Om een rasteruitvoer te genereren, verbindt u de LandTrendr-analysefunctie met de functie Detect Change Using Change Analysis-functie in een rasterfunctietemplate en gebruikt u de template als invoer in de geoprocessingtool Generate Raster From Raster-functie. Het resultaat is een raster met informatie over het tijdstip waarop pixelwaarden zijn gewijzigd.<div><br>Het doel van deze rasterfunctie is om veranderingen in een geobserveerd object te extraheren, dus de ideale multidimensionale invoer moet een consistente observatie door de tijd heen vastleggen en mag geen atmosferische of sensorinterferentie, wolken of wolkenschaduw bevatten. De beste methode is om gegevens te gebruiken die zijn genormaliseerd en kunnen worden gemaskeerd met een QA-band, bijvoorbeeld Landsat Collection 1 Surface Reflectance-producten met een wolkenmasker.<div><br>De functie voert een analyse uit op één afbeelding per jaar en het aantal jaarlijkse stukken moet gelijk zijn aan of groter zijn dan de waarde gespecificeerd in de parameted <strong>Minimaal aantal observaties</strong>. Het wordt aanbevolen om voor minimaal zes jaar aan data te hebben.<div><br>Als u maandelijkse, wekelijkse of dagelijkse data hebt, is het raadzaam om verschillende afbeeldingen van elk jaar te selecteren (bij voorkeur van hetzelfde seizoen), wolken en wolkenschaduw te verwijderen en de afbeeldingen te combineren om een enkele afbeelding te genereren die de waarneming goed vastlegt. Als maandelijkse, wekelijkse of dagelijkse gegevens worden verstrekt als het multidimensionale invoerraster, identificeert de functie één segment voor analyse op basis van de datum die het dichtst bij de datum in de parameter <strong>Snappingdatum</strong>.<div><br>Een object in een landschap heeft vaak tijd nodig om te herstellen van een niet-permanente verandering, zoals een bosbrand of een insectenplaag. Stel de parameter Hersteldrempel in om de herstelsnelheid te regelen die door het model wordt herkend. Een afzonderlijk segment kan geen herstelsnelheid hebben die sneller is dan 1/hersteldrempel.<div><br>Het herstel van een verandering in landschap kan in positieve of negatieve richting plaatsvinden. Wanneer een landschap bijvoorbeeld bosverlies vertoont, laat een tijdreeks van vegetatie-indexwaarden een daling van de indexwaarden zien, en het herstel toont een geleidelijke toename van de vegetatie-indexwaarden of een positieve hersteltrend. Specificeer de richting van de hersteltrend met de parameter <strong>Herstel heeft een stijgende trend</strong>.",
		aggregateMultidimensionalName: "Multidimensionaal aggregeren",
		aggregateMultidimensionalSnip: "Combineert bestaande multidimensionale gegevens van rastervariabelen langs een dimensie.",
		aggregateMultidimensionalDesc: "De functie Multidimensionaal aggregeren creëert een multidimensionale rasterlaag door bestaande multidimensionale rastervariabele gegevens langs een afmeting te combineren.<div><br>Gebruik de <strong>Dimensiedefinitie</strong> parameter om eerst de invoergegevens te filteren die u wenst te aggregeren. Als u bijvoorbeeld 30 jaar aan maandelijkse gegevens hebt, maar u wilt alleen een geaggregeerde laag maken voor de eerste 15 jaar, dan kunt u de parameter <strong>Dimensiedefinitie</strong> gebruiken om de jaren op te geven die u in de analyse wilt opnemen. Extractiegegevens<div><br><ul><li>voor de maand januari over de periode 10 jaar. Kies <strong>Op waarden</strong>, stel <strong>Dimensie</strong> in op <strong>StdTime</strong> en stel <strong>Waarden</strong> in op <strong>januari</strong>.</li><li> Splits zoutgegevens over een diepte van 0 tot 150 meter. Kies <strong>Op bereik</strong>, stel <strong>Dimensie</strong> in op <strong>StdZ</strong> en stel <strong>Minimumwaarde</strong> in op <strong>-150</strong> en <strong>Maximumwaarde</strong> op <strong>0.</strong>.</li><li>Voer zoutgegevens uit voor de eerste 10 dagen van elke januari over een periode van 10 jaar. Kies <strong>Op iteratie</strong> en stel <strong>Dimensie</strong> in op <strong>StdTime</strong>, stel <strong>Start van eerste iteratie</strong> en <strong>Eind van de eerste iteratie</strong> in op het overeenkomende begin en einde van de iteratieperiode, stel <strong>Stap</strong> in op <strong>1</strong> en stel <strong>Eenheid</strong> inop <strong>Jaren</strong>.</li></ul><div><br>Gebruik de parameters <strong>Aggregatiedefinitie</strong> om de afmeting te kiezen om de afmeting te kiezen en het aggregatieinterval met behulp van een trefwoord, een waarde of een reeks waarden. Als u bijvoorbeeld 30 jaar aan gegevens over de zeeoppervlaktetemperatuur hebt, dagelijks verzameld en op elke 5 meter diepte tot 100 meter, kunt u de verschillende intervalopties gebruiken voor de volgende scenario's:<div><br><ul><li>Dagelijkse temperatuurgegevens samenvoegen tot maandelijkse gegevens, waarbij het resultaat een multidimensionaal raster is met 12 tijdschijven, en elke schijf is het totaal van elke maand over alle jaren heen. Kies <strong>Interval trefwoord</strong> en stel het trefwoord in op <strong>Maandelijks terugkerend</strong>.</li><li> Aggereer dagelijkse temperatuurgegevens in maandelijkse gegevens, waarbij het resultaat een multidimensionaal raster is met 360 stukken, of 12 tijdsdelen per jaar (30 jaar x 12 maanden = 360 stukken). Kies <strong>Interval trefwoord</strong> en stel het trefwoord in op <strong>Maandelijks</strong>.</li><li>Aggregeer maandelijkse temperatuurgegevens in intervallen van 4 maanden. Kies <strong>Intervalwaarde</strong>, stel <strong>Waarde-interval</strong> in op 4, en stel <strong>Eenheid</strong> in op <strong>Maanden</strong>.</li><li>Aggregeer temperatuurdata van 0 tot 25 meter, vervolgens van 25 tot 50 meter, vervolgens van 50 tot 100 meter. Kies <strong>Intervalbereiken</strong> en specificeer minimum- en maximale dieptes als <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Rasters samenvoegen",
		mergeRastersSnip: "Combineert ruimtelijk meerdere rastergegevenssets of over variabelen en dimensies heen.",
		mergeRastersDesc: "Deze functie maakt een samengevoegd raster uit een lijst met rasters. Als u bijvoorbeeld een mozaïekgegevensset hebt die 30 jaar aan maandelijkse neerslaggegevens bevat en een andere gegevensset met 10 jaar aan maandelijkse temperatuurgegevens, kunt u deze combineren tot een multidimensionaal raster met beide variabelen. <div><br>Als de multidimensionale ingevoerde rasters verschillende variabelen bevatten, zal het multidimensionale uitvoerraster alle variabelen bevatten. <div><br>Als de multidimensionale ingevoerde rasters verschillende dimensies of dimensiewaarden bevatten, zal het multidimensionale outputraster alle dimensies en dimensiewaarden bevatten. <div><br>Als de multidimensionale ingevoerde rasters dezelfde afmetingen en variabelen bevatten, maar verschillende ruimtelijke extensies, zal het multidimensionale outputraster de variabelen en dimensies over de samengevoegde ruimtelijke extensies bevatten.<div><br>Deze functie kan ook worden gebruikt als u meerdere rasters hebt die u als één item, zoals het berekenen van dezelfde statistieken voor iedereen, of bij kleurbalans, zodat u niet elke afbeelding afzonderlijk hoeft te balanceren. Dit is handig wanneer u werkt met afbeeldingen die zijn opgeslagen als afzonderlijke tegels vanwege beperkingen in de bestandsgrootte; op deze manier worden de tegels behandeld als onderdeel van dezelfde afbeelding.",
		boundaryCleanName: "Schone grens",
		boundaryCleanSnip: "Maakt de grens tussen de zones glad.",
		boundaryCleanDesc: "<p>De functie veralgemeent of vereenvoudigt de rasters door de grenzen tussen de zones glad te strijken. De functie biedt mogelijkheden om te controleren hoe de cellen van de zones in de invoer de afvlakking beïnvloeden en de hoeveelheid afvlakking die zal worden toegepast. Elke invoercel wordt geëvalueerd met behulp van zijn acht directe buren.</p><p>Het afvlakkingsproces sorteert de buurcellen eerst op een bepaalde prioriteit. De prioriteit bepaalt welke zone van de aangrenzende cellen de waarde van de verwerkingscel in de uitgang kan vervangen.</p><p>De prioriteit kan gebaseerd zijn op de waarde van de zones of de grootte van de zones. De parameter <strong>Sorteertype</strong> bepaalt het te gebruiken sorteertype. </p><p>De standaardinstelling <strong>Niet sorteren</strong> beoordeelt de prioriteit op basis van de waarde van de zones. Cellen uit zones met grotere waarden hebben een hogere prioriteit om uit te breiden naar zones met kleinere waarden.</p><p>De grootte, of de totale oppervlakte, van de zones kan worden gebruikt om de prioriteit te sorteren. Met de instelling <strong>Aflopend</strong> worden de zones in aflopende volgorde op grootte gesorteerd. De zones met grotere totale oppervlakten zullen de prioriteit hebben om uit te breiden naar zones met kleinere oppervlakten. Met de instelling <strong>Oplopend</strong> is het tegenovergestelde het geval: zones met kleinere totale oppervlakten zullen de prioriteit hebben om uit te breiden naar zones met grotere totale oppervlakten.</p><p>De hoeveelheid afvlakking wordt geregeld door de parameter <strong>Uitzetten en krimpen twee keer uitvoeren</strong> die het aantal keren bepaalt dat het uitzettings- en krimpproces wordt uitgevoerd.</p><p>Met de onaangevinkte instelling wordt het uitzet- en krimpproces één keer uitgevoerd. Met de aangevinkte instelling wordt het uitzet- en krimpproces twee keer uitgevoerd, waardoor de zonegrenzen extra worden gladgestreken.</p><p>Als de waarden van alle acht buurcellen gelijk zijn aan die van de verwerkingscel, behoudt de uitgangscel de waarde van de invoercel.</p>",
		predictUsingRegressionName: "Voorspellen met regressie",
		predictUsingRegressionSnip: "Berekent een voorspeld raster op basis van de invoer van rastergegevens en een regressiemodel. Het regressiemodel is de uitvoer van het raster geoprocessing tool van het<strong>regressiemodel Train Random Trees</strong>.",
		predictUsingRegressionDesc: "<p>Het regressiemodel is gedefinieerd in aan Esri-regressiedefinitiebestand (.ecd). Het bevat alle informatie voor een sepcifieke gegevensset of een set gegevenssets, en het regressiemodel, en wordt gegenereerd door het raster geoprocessing tool van het <strong>regressiemodel Train Random Trees</strong>. </p><p>De input kan een enkele band, een meervoudige band of een multidimensionaal raster zijn, of een lijst van deze types. De types inputrasters moeten van hetzelfde type van het raster dat is aangeleerd door het regressiemodel.</p><ul><li>Wanneer de input een meervoudige band heeft, wordt elke band behandeld als een variabele van een voorspeller. De banden moeten in dezelfde volgorde als de meervoudige band-input zijn voor de trainingtool van het regressiemodel.</li><li>Wanneer de input een multidimensionaal raster is, wordt elke variabele behandeld als de variabele van een voorspeller en moet de variabele een enkele band zijn en een tijddimensie hebben. De volgorde en namen van de variabelen moeten dezelfde zijn als de input wanneer het regressiemodel werd getraind. De output is een multidimensionaal raster.</li><li>De input kan een lijst van items zijn. Het aantal items en de volgorde van de items moeten dezelfde zijn als de input wanneer het regressiemodel werd getraind.</li></ul>",
		dimensionalMovingStatisticsName: "Dimensionale bewegende statistieken",
		dimensionalMovingStatisticsSnip: "Berekent statistieken over een bewegend venster op multidimensionale gegevens langs een gespecificeerde dimensie.",
		dimensionalMovingStatisticsDesc: "<p>De functie Dimensional Moving Statistics berekent diverse statistieken binnen een vooraf gedefinieerd venster voor alle dimensiewaarden binnen een dimensie. Deze functie neemt een multidimensionale rasterlaag als invoer en maakt een multidimensionale rasterlaag, die dezelfde dimensionale grootte heeft als de invoerlaag, als uitvoer.</p><p>U kunt een dimensie opgeven waarvoor dimensiewaarden worden overwogen tijdens berekening. Het berekent standaard langs de eerste niet-ruimtelijke dimensie. U kunt ook een venstergrootte specificeren door de parameters voor het Backward-venster en het Forward-venster te specificeren.</p><p>Wanneer het statistiektype op Percentiel is ingesteld, worden de parameters Percentile Value en Percentile Interpolation Type beschikbaar. U kunt deze parameters gebruiken om respectievelijk het percentiel te specificeren dat moet worden berekend en het interpolatietype te kiezen dat moet worden gebruikt. Wanneer het statistiektype is ingesteld op Circular Mean, wordt de parameter Circular Wrap Value beschikbaar. De circular wrap value wordt gebruikt om een lineaire waarde om te zetten in het bereik van een opgegeven circulair gemiddelde.</p>",
		terrainFlattenFunctionName: "Terrein effenen",
		terrainFlattenFunctionSnip: "Corrigeert de ingevoerde SAR-gegevens (SAR = synthetic aperture radar) voor radiometrische vervormingen als gevolg van topografie.",
		terrainFlattenFunctionDesc: "<p>De rasterfunctie van Terrein effenen corrigeert de ingevoerde SAR-gegevens (SAR = synthetic aperture radar) voor radiometrische vervormingen als gevolg van topografie.</p><p>De ingevoerde radargegevens moeten eerst worden gekalibreerd op beta nul. Gebruik de tool Apply Radiometric Calibration om radargegevens op beta nul te kalibreren.</p><p>Als de ingevoerde DEM niet de volledige SAR-gegevensset omspant, zal de tool GeenData-waarden uitvoeren voor de pixels die buiten de DEM-extent vallen voor gamma nul-, sigma nul-, verstrooiingsgebied- en geometrische vervormingsuitvoer. De tool zal voor het geometrische vervormingsmasker onbepaalde waarden uitvoeren voor pixels die buiten de DEM-extent vallen.</p><p>De ingevoerde DEM moet in het geografisch coördinaatsysteem WGS 1984 (EPSG:4326) vallen.</p>",
		createColorCompositeFunctionName: "Kleurencomposiet maken",
		createColorCompositeFunctionSnip: "Maakt een raster met drie banden uit een multiband-rasterdataset, waarbij elke band een algebraïsche berekening op basis van bandalgebra kan gebruiken.",
		createColorCompositeFunctionDesc: "<p>De rasterfunctie Kleurencomposiet maken maakt een raster met drie banden uit een multiband-rasterdatasetband een algebraïsche berekening op basis van bandalgebra kan gebruiken.</p><p>Wanneer u een bandrekenkundig algoritme definieert, kunt u voor elke uitdrukking een eenregelige algebraïsche formule invoeren om een multiband-uitvoer te creëren. De ondersteunde operators zijn unair, plus (+), min (-), vermenigvuldigen (*) en gedeeld door (/).</p><p>Wanneer u een Band-id in een uitdrukking gebruikt, dient u de band te identificeren door het bandnummer de prefix B of b te geven.</p><p>Een veel voorkomende bandcombinatie die voor SAR (synthetic aperture radar) wordt gebruikt in lineaire eenheden is VV voor rood, VH voor groen en VV/VH voor blauw. Als de invoergegevens in decibel zijn aangegeven, moet de bandcombinatie VV zijn voor rood, VH voor groen en VV-VH voor blauw.</p>",
		surfaceParametersName: "Oppervlakteparameters",
		surfaceParametersSnip: "Bepaalt parameters van een oppervlakteraster zoals aspect, helling, en verschillende soorten krommingen met behulp van geodetische methoden.",
		surfaceParametersDesc: "<p>De functie Oppervlakteparameters bepaalt parameters van een oppervlakteraster zoals aspect, helling en verschillende soorten krommingen met behulp van geodetische methoden.</p><p>Deze functie kan voor de volgende toepassingen worden gebruikt:</p><ul><li>Bereken aspect en helling met behulp van geodetische methoden.</li><li>Berekenen van verschillende soorten krommingen van een ingevoerd oppervlakteraster, bijvoorbeeld <strong>Tangentiële (normale contour) kromming</strong> die de topografische convergentie en divergentie van de stroming over het oppervlak karakteriseert.</li></ul>",
		leastCostCorridorName: "Goedkoopste corridor",
		leastCostCorridorSnip: "Berekent de som van twee cumulatieve kostenafstandrasters met de optie een drempel toe te passen op basis van een percentage of van cumulatieve kosten.",
		leastCostCorridorDesc: "<p>De invoerrasters moeten bestaan uit de afstandsaccumulatie- en terugwegrasteruitvoer uit de functie <strong>Afstandsaccumulatie</strong> of <strong>Afstandstoewijzing</strong>. Deze moeten worden gebaseerd op kostenafstand en dezelfde parameterinstellingen moeten worden gebruikt bij het maken van de lagen voor elke bron. Er mogen bij het maken van deze rasters geen parameters worden gebruikt die gebaseerd zijn op directionaliteit (horizontale factor, verticale factor en reisrichting).</p><p>De waarden in het uitvoercorridorraster zijn de som van de cumulatieve kosten voor het bereiken van een gegeven locatie met dezelfde eenheden als de ingevoerde cumulatieve kostenafstandrasters.</p><p>Als een opgegeven <strong>Drempel</strong>waarde bij het optellen van de twee afstandsaccumulatierasters hoger is dan de maximale cumulatieve kosten, zal het uitvoercorridorraster hetzelfde gebied dekken als de invoeraccumulatierasters.</p><p>Als een opgegeven drempelwaarde lager is dan de minimumwaarde in het corridorraster, wordt een waarschuwing geretourneerd en zal het uitvoerraster leeg zijn.</p><p>Het uitvoercorridorraster kan cellen bevatten die licht hogere cumulatieve kosten hebben dan de drempelwaarde. Dit is afkomstig uit de terugwegrasters die cellen gebruiken waaraan licht hogere kosten zijn toegewezen dan de drempelwaarde om de verbinding tussen losgekoppelde cellen en de corridor te herstellen.</p>",
		geometricMedianName: "Geometrische mediaan",
		geometricMedianSnip: "De functie Geometrische mediaan berekent de geometrische mediaan voor pixels in een tijdreeks van multibandafbeeldingen.",
		geometricMedianDesc: "<p>Deze functie reduceert ruis en uitzonderingen in tijdreeksafbeeldingen door een geometrische mediaan-pixel te berekenen voor elke pixelarray in de afbeeldingsstapel. Het algoritme onderhoudt de specale relaties tussen banden in de pixelspectra, zodat de uitvoer kan worden gebruikt in analyse, zoals vegetatie-indicatoren.</p><p>Wolken en schaduwen moeten met de QA-band voor de gegevensset worden gemaskeerd voordat deze functie wordt toegepast.</p><p>Als de invoerafbeelding een zwevende punt is, zoals een oppervlakreflectie met waarden tussen 0 en 1, zou een epsilonwaarde van 0,001 kwalitatief goede resultaten moeten produceren.</p>"
	},
	rfxArgs: {
		rasterName: "Raster",
		colorSchemeTypeName: "Type kleurenschema",
		colormapName: "Kleurmap",
		colormapNameName: "Naam kleurmap",
		colorRampName: "Kleurverloop",
		contrastOffsetName: "Contrast-offset",
		brightnessOffsetName: "Helderheidscompensatie",
		methodName: "Methode",
		bandNamesName: "Bandnamen",
		bandWavelengthsName: "Band golflengten",
		bandIdsName: "Band ID's",
		missingBandActionName: "Actie Ontbrekende band",
		conversionParametersName: "Conversieparameters",
		hillshadeTypeName: "Type schaduwreliëf",
		azimuthName: "Azimut",
		altitudeName: "Hoogte",
		slopeTypeName: "Schalen",
		zFactorName: "Z-factor",
		PSPowerName: "Vermogen pixelgrootte",
		PSZFactorName: "Factor pixelgrootte",
		removeEdgeEffectName: "Standaardinterpolatie van randpixel deactiveren",
		fromUnitName: "Van unit",
		toUnitName: "Naar unit",
		rasterTypeName: "Type",
		minName: "Uitvoerminimum",
		maxName: "Uitvoermaximum",
		minPercentName: "Minimum van percentclip",
		maxPercentName: "Maximum van percentclip",
		numberOfStandardDeviationName: "Aantal standaardafwijkingen",
		sigmoidStrengthLevelName: "Niveau van de Sigmoid-sterkte",
		estimateStatsHistogramName: "Statistieken schatten",
		DRAName: "Aanpassing van het dynamisch bereik",
		statisticsName: "Statistieken",
		histogramsName: "Histogrammen",
		statisticsHistogramName: "Statistieken en Histogram Definiëren",
		computeGammaName: "Auto Gamma",
		useGammaName: "Gamma gebruiken",
		gammaName: "Gamma",
		inputNamesName: "Namen",
		expressionName: "Expressie",
		cellsizeTypeName: "Type celgrootte",
		extentTypeName: "Extenttype",
		classifierDefinitionFileName: "Invoerdefinitiebestand",
		raster1Name: "Raster1",
		raster2Name: "Raster2",
		raster3Name: "Raster3",
		trueRasterName: "Ware raster",
		falseRasterName: "Onware raster",
		noDataInterpretationName: "NoData-interpretatie",
		noDataValuesName: "NoData-waarden",
		includedRangesName: "Inclusief reeksen",
		curvatureTypeName: "Curvaturetype",
		rastersName: "Rasters",
		attributeTableName: "Tabel",
		attributeTableTypeName: "Tabeltype",
		rowsName: "Aantal rijen",
		columnsName: "Aantal kolommen",
		kernelName: "Kernel",
		mirrorEdgesName: "Spiegelranden",
		influencesName: "Invloeden",
		fieldsName: "Velden",
		remapsName: "Remaptabel",
		evalFromName: "Evaluatieschaal van",
		evalToName: "Evaluatieschaal tot",
		weightsName: "Gewichten",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "Kort bereik IDW Radius",
		maxVoidWidthName: "Max. breedte leegte",
		sigmaGaussianName: "Bewerkelijk Smoothing",
		contourTypeName: "Contourtype",
		zBaseName: "Z-basis",
		numberOfContoursName: "Aantal contouren",
		contourIntervalName: "Contourinterval",
		nthContourLineInBoldName: "Nth contourlijn vet",
		featureClassName: "Invoerobjecten",
		classIndexFieldName: "Veld",
		resolveOverlapMethodName: "Overlapmethode oplossen",
		resamplingTypeName: "Resampling Type",
		inputCellsizeName: "Invoer celgrootte",
		outputCellsizeName: "Uitvoer celgrootte",
		pointFeatureClassName: "Beginpunten",
		maxGrowthRadiusFieldName: "Max groothoekveld",
		similarityThresholdFieldName: "Gelijkwaardigheidsdrempelveld",
		fillValueFieldName: "Vulwaardeveld",
		spectralDetailName: "Spectraal detail [1..20]",
		spatialDetailName: "Spatiaal detail [1..20]",
		minNumPixelsPerSegmentName: "Minimumgrootte van segmenten in pixels",
		boundariesOnlyName: "Enkel grenzen van segmenten",
		statisticsTypeName: "Statistiektype",
		fillNoDataOnlyName: "Enkel NoData-pixels vullen",
		inputDataTypeName: "Invoerdatatype",
		angleReferenceSystemName: "Hoekreferentiesysteem",
		outputDataTypeName: "Uitvoergegevenstype",
		inputSamplePointFeatureClassName: "Invoervoorbeelden",
		valueFieldName: "Waardeveld",
		rasterInfoName: "Rasterinfo",
		interpolationMethodName: "Interpolatiemethode",
		radiusName: "Straal",
		radianceGainValuesName: "Stralingstoename",
		radianceBiasValuesName: "Straling gemiddelde afwijking",
		reflectedGainValuesName: "Reflectiewinst",
		reflectedBiasValuesName: "Reflectievertekening",
		sunElevationName: "Zonelevatie (graden)",
		albedoName: "Albedo",
		scaleFactorName: "Schaalfactor",
		offsetName: "Offset",
		thresholdTypeName: "Drempeltype",
		thresholdsName: "Drempels",
		undefinedClassName: "Ongedefinieerde klasse",
		minValueName: "Min",
		maxValueName: "Max",
		operationName: "Werk",
		clippingTypeName: "Kniptype",
		clippingGeometryName: "Geometrie/raster afknippen",
		extentName: "Uitvoerextent",
		useInputFeatureGeometryName: "Invoerobjecten gebruiken voor het knippen van geometrie",
		remapDefinitionTypeName: "Definitietype opnieuw in kaart brengen",
		inputRangeName: "Invoerbereiken",
		outputValuesName: "Uitvoerwaarden",
		noDataRangeName: "NoData-bereiken",
		inputFieldName: "Invoerveld",
		outputFieldName: "Uitvoerveld",
		inputMaxFieldName: "Maximumveld voor invoer (optioneel)",
		remapTableTypeName: "Tabeltype opnieuw in kaart brengen",
		allowUnmatchedName: "Sta ongeëvenaarde pixelwaarden toe",
		changeMissingValuesToNoDataName: "Ontbrekende waarden veranderen naar NoData",
		visibleBandIDName: "Zichtbare band-ID",
		infraredBandIDName: "Infrarode band-ID",
		scientificOutputName: "Wetenschappelijke uitvoer",
		bandIndexesName: "Bandindexen",
		constantName: "Constante",
		weightName: "Gewicht",
		minimumName: "Minimum",
		maximumName: "Maximum",
		sourceDataName: "Bronraster",
		sourceFieldName: "Bronveld",
		costRasterName: "Kostraster",
		maxDistanceName: "Maximumafstand",
		valueRasterName: "Waarderaster",
		costMultiplierName: "Vermenigvuldigingsfactor om toe te passen op de kosten",
		startCostName: "Kosten starten",
		accumCostResistanceRateName: "Weerstandstempo van accumulatieve kosten",
		capacityName: "Capaciteit",
		travelDirectionName: "Routerichting",
		cellSizeName: "Celgrootte",
		populationFieldName: "Populatieveld",
		areaUnitsName: "Oppervlakte-eenheden",
		outputValueTypeName: "Uitvoercelwaarden",
		barriersName: "Invoerbarrières",
		destinationDataName: "Bestemmingsraster",
		destinationFieldName: "Bestemmingsveld",
		pathTypeName: "Padtype",
		observerFeaturesName: "Observeerderobjecten",
		analysisMethodName: "Analysemethode",
		analysisTypeName: "Analysetype",
		verticalErrorName: "Verticale fout",
		refractivityCoefficientName: "Refractiecoëfficiënt",
		surfaceOffsetName: "Oppervlaktecompensatie",
		observerElevationName: "Observeerderelevatie",
		observerOffsetName: "Observeerdercompensatie",
		innerRadiusName: "Binnenste straal",
		innerRadiusIs3DDistanceName: "Binnenste Radius is 3D-afstand",
		outerRadiusName: "Buitenste straal",
		outerRadiusIs3DDistanceName: "Buitenste Radius is 3D-afstand",
		horizontalStartAngleName: "Horizontale starthoek",
		horizontalEndAngleName: "Horizontale eindhoek",
		verticalUpperAngleName: "Verticale bovenhoek",
		verticalLowerAngleName: "Verticale benedenhoek",
		zoneDataName: "Zoneraster",
		zoneFieldName: "Zoneveld",
		ignoreNoDataName: "NoData negeren in berekeningen",
		temperatureRasterName: "Temperatuurraster",
		inTemperatureUnitsName: "Temperatuureenheden",
		outHeatIndexTemperatureUnitsName: "Warmte-indexeenheden",
		relativeHumidityRasterName: "Raster voor relatieve vochtigheid",
		outWindChillTemperatureUnitsName: "Eenheden voor gevoelstemperatuur",
		windSpeedRasterName: "Windsnelheidsraster",
		inWindSpeedUnitsName: "Windsnelheidseenheden",
		valueName: "Waarde",
		propertyName: "Eigendomsnaam",
		jsonName: "Metadata JSON",
		zoneTableName: "Tabel met zoneattributen",
		attributeFieldNames: "Veldnamen van attributen",
		backgroundName: "Achtergrondwaarde",
		whereClauseName: "Waar-bepaling",
		minimumValueFieldName: "Minimumwaarde voor veldnaam",
		maximumValueFieldName: "Maximumwaarde voor veldnaam",
		outValueFieldName: "Uitvoerwaarde van veldnaam",
		defaultValueName: "Standaarduitvoerwaarde",
		conversionMatrixName: "Conversiematrix",
		IsPseudoColorOutputName: "Is een pseudokleurenuitvoer",
		unmappedAsRandomColorName: "Willekeurig kleur aan niet-toegewezen pixels toewijzen",
		distanceMethodName: "Afstandmethode",
		flowDirRasterName: "Stroomrichting raster",
		pourPointName: "Stortpunt(en) raster",
		pourPointFieldName: "Stortpunt veld",
		constantZName: "Constante Z",
		zOffsetName: "Z Offset",
		geoIdName: "Geoïde",
		calibrationTypeName: "Kalibratietype",
		filterTypeName: "Filtertype",
		filterSizeName: "Filtergrootte",
		noiseModelName: "Noisemodel",
		noiseVarianceName: "Noise-variatie",
		additiveNoiseMeanName: "Gemiddelde toegevoegd noise",
		multiplicativeNoiseMeanName: "Gemiddelde vermenigvuldigd noise",
		numberofLooksName: "Aantal looks",
		dampingFactorName: "Dempingsfactor",
		maskRasterName: "Maskerraster",
		nibbleValuesName: "Gebruik NoData-waarden als ze de naaste buur zijn",
		nibbleNoDataName: "Nibble NoData-cellen",
		zLimitName: "Z Limiet",
		flowDirectionTypeName: "Stroomrichting type",
		weightRasterName: "Gewichtsraster",
		forceEdgeName: "Forceer alle randcellen om naar buiten te stromen",
		streamRasterName: "Stroomraster",
		surfaceRasterName: "Oppervlakraster",
		conversionType: "Conversietype",
		distanceRaster1: "Afstandsraster 1",
		distanceRaster2: "Afstandsraster 2",
		costDistanceRaster: "Kostenafstandraster",
		costBacklinkRaster: "Kostenraster backlink",
		overridesName: "Overschrijden",
		fieldName: "Veld",
		signatureFileOrUrl: "Handtekeningbestand of URL",
		redName: "Rood",
		greenName: "Groen",
		blueName: "Blauw",
		infraredName: "Infrarood",
		panchromaticName: "Panchromatisch",
		multispectralName: "Multispectraal",
		pansharpeningType: "Pansharpening type",
		sensorName: "Sensor",
		spatialReferenceName: "Ruimtelijke referentie",
		xCellsizeName: "X Celgrootte",
		yCellsizeName: "Y Celgrootte",
		xOriginName: "X Registratiepunt",
		yOriginName: "Y Registratiepunt",
		percentileName: "Percentielwaarde",
		neighborhoodType: "Type buurt",
		widthName: "Breedte",
		heightName: "Hoogte",
		startAngleName: "Starthoek",
		endAngleName: "Eindhoek",
		neighborhoodValues: "Buurtwaarden",
		horizontalRaster: "Horizontaal raster",
		horizontalFactor: "Horizontale factor",
		verticalRaster: "Verticaal raster",
		verticalFactor: "Verticale factor",
		streamRaster: "Stroomraster",
		flowDirRaster: "Stroomrichting raster",
		numberNeighborCells: "Aantal buurcellen",
		zoneConnectivity: "Zone-connectiviteit",
		addLinkBehavior: "Voeg koppeling toe",
		excludedValue: "Uitgesloten waarde",
		constantFillCheck: "Genereer opvulraster van constante",
		fillRaster: "Opvulraster",
		constantFillValue: "Constante waarde",
		inputBitPositions: "Invoerbit",
		outputBitPositions: "Uitvoerbit",
		distanceTypeName: "Afstandstype",
		barrierDataName: "Rasterbarrières",
		pourPointDataName: "Stortpuntraster",
		accumulationRasterName: "Stroomaccumulatieraster",
		snapDistanceName: "Snap-afstand",
		orderMethodName: "Andere methode",
		directionMeasurementName: "Richting van meting",
		processAsMultiband: "Verwerken als multiband",
		processMultidimensional: "Verwerken als multidimensionaal",
		forceFlowDirectionConvention: "Forceer stroomrichting naar backlinkraster",
		initialAccumulation: "Initiële accumulatie",
		maximumAccumulation: "Maximale accumulatie",
		sourceLocationBands: "Genereer bronrij en kolom als extra banden in de uitvoer",
		backDirectionBand: "Genereer de terugrichting als extra band in output",
		numberOfCells: "Aantal cellen",
		zoneValues: "Zonewaarden",
		shrinkMethod: "Krimpmethode",
		expandMethod: "Uitvergrootmethode",
		inputSpectralProfileType: "Type spectraal profiel",
		spectralProfileFileName: "Spectraal profiel",
		trainingFeatureFileName: "Opleidingsobject",
		nonNegative: "Niet-negatief",
		sumToOne: "Som op één",
		randomDistribution: "Distributie",
		meanName: "Mediaan",
		probabilityName: "Kans",
		alphaName: "Alpha",
		betaName: "Bèta",
		rName: "r",
		nName: "N",
		seed: "Begin",
		randomNumberGenerator: "Willekeurige nummergeneratie",
		cellFactor: "Celfactor",
		aggregationType: "Aggregatietechniek",
		extentHandling: "Extent uitvouwen indien nodig",
		trendAnalysisDimensionName: "Formaatnaam",
		trendAnalysisType: "Trendtype",
		harmonicFrequency: "Harmonische frequentie",
		polynomialOrder: "Polynomiale volgorde",
		cycleLengthName: "Lengte van de cyclus",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R-Squared",
		trendAnalysisSlopePValue: "P-waarde van de hellingshoekcoëfficiënt",
		trendAnalysisSeasonalPeriod: "Seizoensperiode",
		cycleUnitName: "Cycluseenheid",
		predictDimensionValues: "Waarden",
		dimensionDefinitionType: "Formaatdefinitie",
		predictDimensionStart: "Start",
		predictDimensionEnd: "Einde",
		predictDimensionInterval: "Waarde-interval",
		dimensionUnit: "Eenheid",
		interpolationCellsizeName: "Interpolatie celgrootte",
		variableName: "Variabelen",
		dimensionlessName: "Maatloos",
		mdimDefinition: "Formaatdefinitie",
		dimensionName: "Afmeting",
		iterationStart: "Begin van de eerste iteratie",
		iterationEnd: "Einde van de eerste iteratie",
		intervalStart: "Start van interval",
		intervalEnd: "Einde van interval",
		stepName: "Stap",
		rangesName: "Bereik",
		minValue: "Minimumwaarde",
		maxValue: "Maximumwaarde",
		changeAnalysisRasterName: "Analyseraster wijzigen",
		changeTypeName: "Type Wijzigen",
		segmentDate: "Segmentdata",
		changeDirectionName: "Richting wijzigen",
		maxNumChangesName: "Maximaal aantal veranderingen",
		filterByYear: "Filteren op jaar",
		minimumYear: "Minimumwaarde",
		maximumYear: "Maximumwaarde",
		filterByDuration: "Filteren op duur",
		minimumDuration: "Minimumduur",
		maximumDuration: "Maximumduur",
		filterByMagnitude: "Filteren op magnitude",
		minimumMagnitude: "Minimummagnitude",
		maximumMagnitude: "Maximummagnitude",
		filterByStartValue: "Filteren op startwaarde",
		minimumStartValue: "Minimale startwaarde",
		maximumStartValue: "Maximale startwaarde",
		filterByEndValue: "Filteren op eindwaarde",
		minimumEndValue: "Minimale eindwaarde",
		maximumEndValue: "Maximale eindwaarde",
		modelTypeName: "Modeltype",
		fromRasterName: "Van raster",
		toRasterName: "Naar raster",
		computeChangeMethod: "Veranderingsmethode berekenen",
		fromClassValues: "Van klassewaarden (voorbeeld: 2 5)",
		toClassValues: "Naar klassewaarden (voorbeeld: 2 5)",
		keepMethod: "Filtermethode",
		useColorMethod: "Transitiekleuren bepalen",
		detectChangeBands: "Banden voor het detecteren van wijzigingen (starten bij 0)",
		tmaskBands: "Banden voor tijdelijke maskering (starten bij 0)",
		chiSquaredThreshold: "Chi-kwadraat drempel voor het detecteren van verandering",
		minAnomaly: "Observaties minimum opeenvolgende anomalie",
		updatingFrequency: "Bijwerken van de pasfrequentie (in jaren)",
		distanceAccumulationRasterName: "Raster afstandsaccumulatie",
		costBackdirectionRasterName: "Raster terugweg of stroomrichting",
		rasterCollectionName: "Rastercollectie",
		itemFunctionName: "Itemfunctie",
		aggregationFunctionName: "Aggregatiefunctie",
		processingFunctionName: "Verwerkingsfunctie",
		aggregationDefinitionName: "Aggregatiedefinitie",
		queryGeometryName: "Query-geometrie",
		factorFunctionZeroFactor: "Nulfactor",
		factorFunctionCutAngle: "Snijhoek",
		factorFunctionSideFactor: "Zijfactor",
		factorFunctionSlope: "Helling",
		factorFunctionLowCutAngle: "Lage snijhoek",
		factorFunctionHighCutAngle: "Hoge snijhoek",
		factorFunctionCosPower: "Kracht cosinus",
		factorFunctionSecPower: "Kracht snijlijn",
		factorFunctionTablePath: "Tabelpad",
		processingBand: "Verwerkingsband",
		processingBandName: "Naam verwerkingsband",
		snappingDate: "Snappingdatum",
		maxNumSegments: "Maximaal aantal segmenten",
		vertexCountOvershoot: "Vertex Count Overshoot",
		spikeThreshold: "Piekdrempel",
		recoveryThreshold: "Hersteldrempel",
		minNumObs: "Minimum aantal observaties",
		pValueThreshold: "P-waarde drempel",
		bestModelProportion: "Beste modelverhouding",
		preventOneYearRecovery: "Een jaar herstel voorkomen",
		recoveryIncreaseTrend: "Herstel heeft toenemende trend",
		outputOtherBands: "Uitvoer overige banden",
		sortType: "Sorteertype",
		numberOfRuns: "Uitzetten en krimpen twee keer uitvoeren",
		percentileValue: "Percentielwaarde",
		percentileInterpolationType: "Percentielinterpolatietype",
		rasterInfoProperty: "Eigendom",
		rasterInfoValue: "Waarde",
		rasterInfoColumns: "Kolommen",
		rasterInfoRows: "Rijen",
		rasterInfoBandCount: "Aantal banden",
		rasterInfoPixelSizeX: "Celgrootte X",
		rasterInfoPixelSizeY: "Celgrootte Y",
		rasterInfoPixelType: "Pixeltype",
		rasterExtentTop: "Boven",
		rasterExtentBottom: "Onder",
		rasterExtentLeft: "Links",
		rasterExtentRight: "Rechts",
		rasterStatisticsNotCalculated: "Statistieken zijn niet berekend.",
		spatialReferenceProjection: "Projectie",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "Vorige WKID",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "Vorige VCSWKID",
		spatialReferenceAuthority: "Autoriteit",
		spatialReferenceLinearUnit: "Lineaire eenheid",
		spatialReferenceAngularUnit: "Hoekige eenheid",
		spatialReferenceFalseEasting: "False easting",
		spatialReferenceFalseNorthing: "False northing",
		spatialReferenceCentralMeridian: "Centrale meridiaan",
		spatialReferencePrimeMeridian: "Nulmeridiaan",
		spatialReferenceStandardParallel1: "Standaard parallel 1",
		spatialReferenceStandardParallel2: "Standaard parallel 2",
		spatialReferenceLatitudeOfOrigin: "Breedtegraad van oorsprong",
		spatialReferenceAuxiliarySphereType: "Type Auxiliary Sphere",
		spatialReferenceDatum: "Datum",
		spatialReferenceSpheroid: "Bolvormig",
		spatialReferenceSemimajorAxis: "Halve lange as",
		spatialReferenceSemiminorAxis: "Halve korte as",
		spatialReferenceInverseFlattening: "Omgekeerde afvlakking",
		inputDefinitionFileName: "Invoerdefinitiebestand",
		deleteName: "Verwijderen",
		addVariableName: "Variabele toevoegen",
		maxNumPixelsPerSegment: "Minimumgrootte van segmenten in pixels",
		forwardWindowName: "Venster Voorwaarts",
		backwardWindowName: "Venster Achterwaarts",
		noDataHandlingName: "NoData Handling",
		circularWrapValueName: "Waarde circulaire wikkeling",
		fromClassNameFieldName: "Veldnaam voor klassenaam in van raster",
		toClassNameFieldName: "Veldnaam voor klassenaam in naar raster",
		targetRasterName: "Doelraster",
		circularWrapValue: "Waarde circulaire wikkeling",
		bandIndexesR: "Rode expressie",
		bandIndexesG: "Groene expressie",
		bandIndexesB: "Blauwe expressie",
		exampleName: "Voorbeeld",
		inputName: "Invoer",
		outputName: "Uitvoer",
		optionalName: "Optioneel",
		browseDefinitionFile: "Definitiebestand bladeren",
		selectDefinitionFile: "Invoerdefinitiebestand selecteren",
		inputDefinitionURL: "Definitiebestand URL invoer",
		enterDefinitionFileURL: "Definitiebestand URL invoeren",
		browseXMLFile: "XML-bestand bladeren",
		selectStatsFile: "Selecteer statistieken en histogrambestand",
		enterXMLFileURL: "XML-bestand URL invoeren",
		xmlFileURL: "XML-bestand URL",
		circularCalculation: "Circulaire statistieken berekenen",
		localSurfaceType: "Plaatselijk oppervlaktetype",
		surfaceParameterType: "Parametertype",
		neighborhoodDistance: "Afstand tot de buurt",
		useAdaptiveNeighborhood: "Gebruik Adaptieve buurt",
		outputSlopeType: "Meting uitgangshelling",
		projectAzimuths: "Project Geodetische Azimuths",
		useEquatorialAspect: "Gebruik Equatoriaal Aspect",
		zUnit: "Z-Eenheid",
		analysisMask: "Analysemasker",
		stdDeviation: "Standaarddeviatie",
		"true": "True",
		"false": "False",
		costDistanceRaster1: "Cumulatief kosten-afstandraster 1 invoeren",
		costDistanceRaster2: "Cumulatief kosten-afstandraster 2 invoeren",
		threshold: "Drempel",
		thresholdMethod: "Drempelmethode",
		directionRaster1: "Terugwegraster 1 invoeren",
		directionRaster2: "Terugwegraster 2 invoeren",
		maxIterations: "Maximumaantal iteraties",
		epsilon: "Epsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Handmatig",
		attributeTableTypeExternal: "Extern",
		clrSchemeTypeColormap: "Kleurmap",
		clrSchemeTypeColorRamp: "Kleurverloop",
		colormapTypeElevation: "Hoogte",
		colormapTypeGray: "Grijs",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Willekeurig",
		none: "Geen",
		slopeTypeAdjusted: "Gecorrigeerd",
		slopeTypeDegree: "Graad",
		slopeTypePercentRise: "Procentstijging",
		slopeTypeScaled: "Geschaald",
		stretchTypeMinMax: "MinMax",
		stretchTypePercentMinMax: "ProcentMinMax",
		stretchTypeSigmoid: "Sigmoide",
		stretchTypeStdDev: "StdDev",
		hillshadeTypeSimple: "Traditioneel",
		hillshadeTypeMultidirectional: "Multidirectioneel",
		bandComboByNames: "Bandnamen",
		bandComboByWavelength: "Band golflengten",
		bandComboByIDs: "Band ID's",
		missingBandActionBestMatch: "Beste match",
		missingBandActionFail: "Mislukt",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Centimeter",
		unitTypeDecimeters: "Decimeter",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Voet",
		unitTypeFeetPerSec: "Voet per seconde (ft/s)",
		unitTypeInches: "Inch",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Kilometer",
		unitTypeKmsPerHour: "Kilometer per uur (km/u)",
		unitTypeKnots: "Knopen (kn)",
		unitTypeMeters: "Meter",
		unitTypeMetersPerSec: "Meter per seconde (m/s)",
		unitTypeMiles: "Mijl",
		unitTypeMilesPerHour: "Mijl per uur (mpu)",
		unitTypeMillimeters: "Millimeter",
		unitTypeNauticalMiles: "Zeemijl",
		unitTypeYards: "Yard",
		unitTypeDecimalDegrees: "Decimale graden",
		unitTypePoints: "Punten",
		unitTypeUnknown: "Onbekend",
		unitTypeSqMapUnits: "Vierkante kaarteenheden",
		unitTypeSqMiles: "Vierkante mijl",
		unitTypeSqKms: "Vierkante kilometer",
		unitTypeAcres: "Hectare",
		unitTypeHectares: "Hectare",
		unitTypeSqYards: "Vierkante yard",
		unitTypeSqFt: "Vierkante voet",
		unitTypeSqInches: "Vierkante inch",
		unitTypeSqMts: "Vierkante meter",
		unitTypeSqCms: "Vierkante centimeter",
		unitTypeSqMms: "Vierkante millimeter",
		cellsizeTypeFirst: "Eerste van",
		cellsizeTypeMin: "Min van",
		cellsizeTypeMax: "Max van",
		cellsizeTypeMean: "Gemiddelde van",
		cellsizeTypeLast: "Laatste van",
		extentTypeFirst: "Eerste van",
		extentTypeIntersection: "Kruispunt van",
		extentTypeUnion: "Vereniging van",
		extentTypeLast: "Laatste van",
		noDataInterpretAny: "Komt overeen met",
		noDataInterpretAll: "Komt overeen met alles",
		curvatureTypeStandard: "Standaard",
		curvatureTypeProfile: "Profiel",
		curvatureTypePlanform: "Planform",
		filterTypeLineDetectionHorizontal: "Lijndetectie horizontaal",
		filterTypeLineDetectionVertical: "Lijndetectie verticaal",
		filterTypeLineDetectionLeftDiagonal: "Lijndetectie links diagonaal",
		filterTypeLineDetectionRightDiagonal: "Lijndetectie rechts diagonaal",
		filterTypeGradientNorth: "Overgang noord",
		filterTypeGradientWest: "Overgang west",
		filterTypeGradientEast: "Overgang oost",
		filterTypeGradientSouth: "Overgang zuid",
		filterTypeGradientNorthEast: "Overgang noord-oost",
		filterTypeGradientNorthWest: "Overgang noord-west",
		filterTypeSmoothArithmeticMean: "Versoepeling rekenkundige betekenis",
		filterTypeSmoothing3x3: "Versoepeling 3x3",
		filterTypeSmoothing5x5: "Versoepeling 5x5",
		filterTypeSharpening3x3: "Verscherping 3x3",
		filterTypeSharpening5x5: "Verscherping 5x5",
		filterTypeLaplacian3x3: "Laplacian 3x3",
		filterTypeLaplacian5x5: "Laplacian 5x5",
		filterTypeSobelHorizontal: "Sobel Horizontaal",
		filterTypeSobelVertical: "Sobel Verticaal",
		filterTypeSharpen: "Verscherpen",
		filterTypeSharpen2: "Meer verscherpen",
		filterTypePointSpread: "Puntverspreiding",
		userDefined: "Gebruikergedefinieerd",
		ContourTypeLines: "Contourlijnen",
		ContourTypeFill: "Contourvulling",
		ContourTypeSmoothOnly: "Alleen glad oppervlak",
		rasterizeFirst: "Eerste",
		rasterizeLast: "Laatste",
		rasterizeSmallest: "Kleinste",
		rasterizeLargest: "Grootste",
		resamplingTypeNearest: "Dichtstbijzijnde Buur",
		resamplingTypeBilinear: "Bilineaire Interpolatie",
		resamplingTypeCubic: "Kubieke Convolutie",
		resamplingTypeMajority: "Meerderheid",
		resamplingTypeBilinearPlus: "Bilineaire Interpolatie Plus",
		resamplingTypeGauss: "Gauss Vervagen",
		resamplingTypeGaussPlus: "Gauss Vervagen Plus",
		resamplingTypeAverage: "Gemiddelde",
		resamplingTypeMinimum: "Minimum",
		resamplingTypeMaximum: "Maximum",
		resamplingTypeVectorAvg: "Vectorgemiddelde",
		minimum: "Minimum",
		maximum: "Maximum",
		mean: "Mediaan",
		stdDeviation: "Standaarddeviatie",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Magnituderichting",
		unknown: "Onbekend",
		angleRefSysGeographic: "Geografisch",
		angleRefSysArithmetic: "Rekenkundig",
		interpolateIrregularDataNearest: "Dichtstbijzijnde buur",
		interpolateIrregularDataBilinear: "Bilineair",
		interpolateIrregularDataTinningLinear: "Lineaire verdunning",
		interpolateIrregularDataTinningNaturalNeighbor: "Natuurlijke buur",
		interpolateIrregularDataTinningIDW: "Omgekeerde afstand gewogen",
		esriRasterThresholdTypeConstant: "Constante",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Hars",
		argStatsTypeMax: "Arg Max",
		argStatsTypeMin: "Arg Min",
		argStatsTypeMedian: "Arg Median",
		argStatsTypeDuration: "Duur",
		arithmeticOpPlus: "Plus",
		arithmeticOpMinus: "Min",
		arithmeticOpMultiply: "Vermenigvuldigen",
		arithmeticOpDivide: "Delen door",
		arithmeticOpPower: "Macht",
		arithmeticOpMode: "Modus",
		clipTypeOutside: "Knippen buiten",
		clipTypeInside: "Knippen binnen",
		yes: "Ja",
		no: "Nee",
		densities: "Dichtheden",
		expectedCounts: "Verwachte tellingen",
		planar: "Planair",
		geodesic: "Geodetisch",
		eachCell: "Elke cel",
		eachZone: "Elke zone",
		bestSingle: "Beste enkel",
		allSightlines: "Alle zichtlijnen",
		perimeterSightlines: "Perimeter zichtlijnen",
		frequency: "Frequentie",
		observers: "Waarnemers",
		majority: "Meerderheid",
		median: "Mediaan",
		minority: "Minderheid",
		percentile: "Percentiel",
		range: "Bereik",
		sum: "Som",
		variety: "Variëteit",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "Getransformeerde SAVI",
		bandArithmeticMethodMSAVI: "Aangepaste SAVI",
		bandArithmeticMethodSultan: "Sultan's formule",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "IJzeroxide",
		ferrousMinerals: "IJzerhoudende mineralen",
		clayMinerals: "Kleimineralen",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Vierkantswortel",
		localACos: "ACos",
		localASin: "ASin",
		localATan: "ATan",
		localATanH: "ATanH",
		localAbs: "Abs",
		localBitwiseNot: "Bitwise Not",
		localBooleanNot: "Boolean Not",
		localCos: "Cos",
		localCosH: "CosH",
		localExp: "Exp",
		localExp10: "Exp10",
		localExp2: "Exp2",
		localInt: "Int",
		localIsNull: "Is null",
		localFloat: "Getal met decimalen",
		localLn: "Ln",
		localLog10: "Log10",
		localLog2: "Log2",
		localNegate: "Ontkennen",
		localRoundDown: "Naar beneden afronden",
		localRoundUp: "Naar boven afronden",
		localSin: "Sin",
		localSinH: "SinH",
		localTan: "Tan",
		localTanH: "TanH",
		localACosH: "ACosH",
		localASinH: "ASinH",
		localPlus: "Plus",
		localMinus: "Min",
		localTimes: "Aantal keer",
		localPower: "Macht",
		localBitwiseAnd: "Bitwise en",
		localBitwiseLeftShift: "Bitwise verschuiving links",
		localBitwiseOr: "Bitwise of",
		localBitwiseRightShift: "Bitwise verschuiving rechts",
		localBitwiseXor: "Bitwise Xof",
		localBooleanAnd: "Boolean en",
		localBooleanOr: "Boolean of",
		localBooleanXor: "Boolean Xof",
		localDivide: "Delen door",
		localEqualTo: "Gelijk aan",
		localGreaterThan: "Groter dan",
		localGreaterThanEqual: "Groter dan of gelijk aan",
		localLessThan: "Kleiner dan",
		localLessThanEqual: "Kleiner dan of gelijk aan",
		localMod: "Mod",
		localNotEqual: "Niet gelijk",
		localATan2: "ATan2",
		localSquare: "Vierkant",
		localSetNull: "Null instellen",
		remapDefTypeList: "Lijst",
		remapDefTypeTable: "Tabel",
		remapTableTypeSimple: "Eenvoudig",
		remapTableTypeDynamic: "Dynamisch",
		remapTableTypeReassignment: "Hertoewijzing",
		geomCorrectionByConstZ: "Constante Z gebruiken",
		geomCorrectionByDEM: "DEM gebruiken",
		radarCalibBetaNought: "Beta nul",
		radarCalibSigmaNought: "Sigma nul",
		radarCalibGammaNought: "Gamma nul",
		speckleFilterTypeLee: "Lee Filter",
		speckleFilterTypeEnhancedLee: "Verbeterde Lee Filter",
		speckleFilterTypeFrost: "Frost-filter",
		speckleFilterTypeKuan: "Kuan-filter",
		speckleNoiseModelMul: "Vermenigvuldigd noise",
		speckleNoiseModelAdd: "Toegevoegd noise",
		speckleNoiseModelAddnMul: "Toegevoegd en vermenigvuldigd noise",
		mosaicOpTypeFirst: "Eerste",
		mosaicOpTypeLast: "Laatste",
		mosaicOpTypeMin: "Min",
		mosaicOpTypeMax: "Max",
		mosaicOpTypeMean: "Mediaan",
		mosaicOpTypeBlend: "Mengsel",
		mosaicOpTypeSum: "Som",
		integer: "Integer",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Verticaal",
		horizontal: "Horizontaal",
		localCellStatisticsMajority: "Meerderheid",
		localCellStatisticsMax: "Maximum",
		localCellStatisticsMean: "Mediaan",
		localCellStatisticsMedian: "Mediaan",
		localCellStatisticsMin: "Minimum",
		localCellStatisticsMinority: "Minderheid",
		localCellStatisticsRange: "Bereik",
		localCellStatisticsStdDev: "Standaarddeviatie",
		localCellStatisticsSum: "Som",
		localCellStatisticsVariety: "Variëteit",
		localCellStatisticsMajorityIgnoreND: "Meerderheid (Negeer NoData)",
		localCellStatisticsMaxIgnoreND: "Maximum (Negeer NoData)",
		localCellStatisticsMeanIgnoreND: "Gemiddelde (Negeer NoData)",
		localCellStatisticsMedianIgnoreND: "Mediaan (Negeer NoData)",
		localCellStatisticsMinIgnoreND: "Minimum (Negeer NoData)",
		localCellStatisticsMinorityIgnoreND: "Minderheid (Negeer NoData)",
		localCellStatisticsRangeIgnoreND: "Reeks (Negeer NoData)",
		localCellStatisticsStdDevIgnoreND: "Standaardafwijking (Negeer NoData)",
		localCellStatisticsSumIgnoreND: "Som (Negeer NoData)",
		localCellStatisticsVarietyIgnoreND: "Variëteit (Negeer NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Percentiel (NoData negeren)",
		fromSource: "Van bron",
		toSource: "Naar bron",
		colorspaceConversionRgbToHsv: "RGB naar HSV",
		colorspaceConversionHsvToRgb: "HSV naar RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Mediaan",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Rechthoek",
		circleNeighborhood: "Cirkel",
		annulusNeighborhood: "Annulus",
		wedgeNeighborhood: "Wedge",
		irregularNeighborhood: "Onregelmatig",
		weightNeighborhood: "Gewicht",
		four: "Vier",
		eight: "Acht",
		within: "In",
		cross: "Kruis",
		addLink: "Voeg koppeling toe",
		noLink: "Geen koppeling",
		weightedMean: "Gewogen gemiddelde",
		ls8QCBitPatternCirrus: "Landsat 8 Cirrus",
		ls8QCBitPatternCloud: "Landsat 8 Cirrus",
		ls8QCBitPatternCloudShadow: "Landsat 8 Cloud Shadow",
		ls8QCBitPatternDesignatedFill: "Landsat 8 Designated Fill",
		ls8QCBitPatternDroppedFrame: "Landsat 8 Dropped Frame",
		ls8QCBitPatternSnowIce: "Landsat 8 Snow/Ice",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 Terrain Occlusion",
		ls8QCBitPatternVegetation: "Landsat 8 Vegetation",
		ls8QCBitPatternWater: "Landsat 8 Water",
		downStream: "Downstream",
		upStream: "Upstream",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Huidige doorsnede",
		allSlices: "Alle doorsnedes",
		expandDistance: "AFSTAND",
		expandMorphological: "MORFOLOGISCH",
		spectralProfileFile: "Spectraal profiel",
		trainingFeatureFile: "Opleidingsobject",
		randomDistributionTypeUniform: "Uniform",
		randomDistributionTypeUniformInteger: "Geheel getal",
		randomDistributionTypeNormal: "Normaal",
		randomDistributionTypeExponential: "Exponentieel",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gamma",
		randomDistributionTypeBinomial: "Binomiaal",
		randomDistributionTypeGeometric: "Geometrisch",
		randomDistributionTypeNegativeBinomial: "Negatieve binomiaal",
		randomGeneratorTypeStandardCRand: "Standaard C Rand",
		randomGeneratorTypeAlgorithmACM599: "ACM verzameld algoritme 599",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Som",
		medainName: "Mediaan",
		trendLinear: "Lineair",
		trendHarmonic: "Harmonisch",
		trendPolynomial: "Polynomiaal",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Seasonal-Kendall",
		dimensionByValue: "Op waarde",
		dimensionByInterval: "Op interval",
		mdimDefTypeAll: "Alle",
		mdimDefTypeByValues: "Op waarden",
		mdimDefTypeByRanges: "Op bereik",
		mdimDefTypeByIteration: "Op iteratie",
		mdimDefTypeByInterval: "Op interval",
		mdimDefTypeByTargetRaster: "Op doelraster",
		esriTimeUnitsHours: "Uren",
		esriTimeUnitsDays: "Dagen",
		esriTimeUnitsWeeks: "Weken",
		esriTimeUnitsMonths: "Maanden",
		esriTimeUnitsYears: "Jaren",
		esriTimeIntervalKeywordHourly: "Elk uur",
		esriTimeIntervalKeywordDaily: "Dagelijks",
		esriTimeIntervalKeywordWeekly: "Wekelijks",
		esriTimeIntervalKeywordDekadly: "Dekadly",
		esriTimeIntervalKeywordPentadly: "Pentadly",
		esriTimeIntervalKeywordMonthly: "Maandelijks",
		esriTimeIntervalKeywordQuarterly: "Per kwartaal",
		esriTimeIntervalKeywordYearly: "Jaarlijks",
		esriTimeIntervalKeywordRecurringDaily: "Dagelijks terugkerend",
		esriTimeIntervalKeywordRecurringWeekly: "Wekelijks terugkerend",
		esriTimeIntervalKeywordRecurringMonthly: "Maandelijks terugkerend",
		esriTimeIntervalKeywordRecurringQuarterly: "Elk kwartaal terugkerend",
		aggDefTypeAll: "Alle",
		aggDefTypeIntervalKeyword: "Intervaltrefwoord",
		aggDefTypeIntervalValue: "Intervalwaarde",
		aggDefTypeIntervalRanges: "Intervalbereiken",
		latestChange: "Tijd van de laatste verandering",
		earliestChange: "Tijd van de vroegste verandering",
		largestChange: "Tijd van de grootste verandering",
		numberOfChanges: "Aantal wijzigingen",
		longestChange: "Tijd van langste wijziging",
		shortestChange: "Tijd van kortste wijziging",
		fastestChange: "Tijd van snelste wijziging",
		slowestChange: "Tijd van langzaamste wijziging",
		allChanges: "Alle",
		increaseChanges: "Vergroten",
		decreaseChanges: "Verkleinen",
		segmentBeginning: "Begin van segment",
		segmentEnd: "Eind van segment",
		esriComputeChangeMethodDifference: "Verschil",
		esriComputeChangeMethodRelativeDifference: "Relatief verschil",
		esriComputeChangeMethodCategorical: "Categorisch verschil",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Spectrale Euclidische afstand",
		esriComputeChangeMethodMultispectralAngularDifference: "Spectraal hoekverschil",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Band met meeste verandering",
		esriComputeChangeKeepAll: "Alles behouden",
		esriComputeChangeKeepChangedOnly: "Enkel gewijzigde pixels behouden",
		esriComputeChangeKeepUnchangedOnly: "Enkel ongewijzigde pixels behouden",
		esriComputeChangeUseColorAverage: "Gemiddelde van en naar kleuren",
		esriComputeChangeUseColorFrom: "Gebruiken van kleuren",
		esriComputeChangeUseColorTo: "Gebruiken naar kleuren",
		factorFunctionBinary: "Binair",
		factorFunctionForward: "Voorwaarts",
		factorFunctionLinear: "Lineair",
		factorFunctionInvLinear: "Omgekeerd Lineair",
		factorFunctionTable: "Tabel",
		factorFunctionSymLinear: "Symmetrisch lineair",
		factorFunctionSymInvLinear: "Symmetrisch omgekeerd lineair",
		factorFunctionCos: "Cosinus",
		factorFunctionSec: "Snijlijn",
		factorFunctionCosSec: "Cosinus snijlijn",
		factorFunctionSecCos: "Snijlijn cosinus",
		noSort: "Niet sorteren",
		ascend: "Oplopend",
		descend: "Aflopend",
		autoDetect: "Auto-detect",
		nearest: "Dichtstbijzijnde",
		linear: "Lineair",
		esriMonthJanuary: "Januari",
		esriMonthFebruary: "Februari",
		esriMonthMarch: "Maart",
		esriMonthApril: "April",
		esriMonthMay: "Mei",
		esriMonthJune: "Juni",
		esriMonthJuly: "Juli",
		esriMonthAugust: "Augustus",
		esriMonthSeptember: "September",
		esriMonthOctober: "Oktober",
		esriMonthNovember: "November",
		esriMonthDecember: "December",
		dimensionalMovingIgnoreNoData: "Gegevens",
		dimensionalMovingPropagateNoData: "NoData",
		dimensionalMovingFillOnlyNoData: "NoData invullen",
		circularMean: "Circulair gemiddelde",
		circularName: "Circulair",
		arithmeticName: "Rekenkundig",
		slopeName: "Helling",
		aspectName: "Aspect",
		meanCurvature: "Gemiddelde kromming",
		profileCurvature: "Profiel (normale hellingslijn) kromming",
		tangentialCurvature: "Tangentiële (normale contour) kromming",
		planCurvature: "Plan (geprojecteerde contour) kromming",
		contourGeodesicTorsion: "Contour geodetische torsie",
		gaussianCurvature: "Gaussiaanse kromming",
		casoratiCurvature: "Casorati kromming",
		localSurfaceTypeQuadratic: "Quadratic",
		localSurfaceTypeBiquadratic: "Biquadratic",
		thresholdNoThreshold: "Geen drempel",
		thresholdPercentLeastCost: "Percentage van goedkoopste",
		thresholdAccumulativeCost: "Cumulatieve kosten",
		clrmapTypeHillshade: "Bergschaduwen"
	},
	categoryLabels: {
		sourceCharacteristics: "Bronkenmerken",
		neighborhoodSettings: "Buurtinstellingen",
		statistics: "Statistieken",
		gamma: "Gamma",
		viewshedParameters: "Viewshed-parameters",
		observerParameters: "Observer-parameters",
		irregularDataInterpolation: "Onregelmatige gegevensinterpolatie",
		modelStatistics: "Modelstatistieken",
		aggregationDef: "Aggregatiedefinitie",
		filterByAttributes: "Filteren op attributen",
		percentileName: "Percentiel",
		rasterInfo: "Rasterinformatie",
		extent: "Extent",
		spatialReference: "Ruimtelijke referentie"
	},
	outputRasterHelpTexts: {
		outputName: "<p>De naam van de laag die wordt aangemaakt en toegevoegd aan de kaart.</p>",
		resultType: "<p>Het type output dat wordt gemaakt. De uitvoer kan bestaan uit getegelde beeldlagen of dynamische beeldlagen.</p>",
		saveResultIn: "<p>De naam van de map in <b>Mijn content</b> waar het resultaat wordt opgeslagen.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Omgevingsinstellingen voor analyse in Map Viewer. </p>",
		outSR: "<p>Specificeert het coördinatensysteem voor de analyse en de resultaatlaag.</p>",
		extent: "<p>Specificeert voor de analyse te gebruiken gebied.</p>",
		snapRaster: "<p>Past de extent van de uitvoer aan zodat deze overeenkomt met de celuitlijning van de opgegeven snaprasterlaag.</p>",
		cellSize: "<p>Bepaalt de celgrootte of resolutie die wordt gebruikt voor de analyse en om de uitvoerrasterlaag te maken.</p>",
		mask: "<p>Specificeert een maskerlaag waarin alleen de cellen die binnen het maskergebied vallen voor de analyse worden gebruikt.</p>",
		resamplingMethod: "<p>Specificeert hoe pixelwaarden moeten worden geïnterpoleerd wanneer de invoer- en uitvoerrasters niet op één lijn liggen.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Niet-ondersteund type",
		currentlyUnsupported: " Er wordt gewerkt aan een standaard-editor voor de ${missingType}; deze is binnenkort beschikbaar. Tijdelijke plaatshouder voor tekstvak voor het specificeren van op tekenreeksen gebaseerde invoer.",
		unsupportedOverrideWarning: "Er is binnenkort een overschrijvingsonderdeel beschikbaar voor de editor, dat een betere UX biedt voor werk met de volgende parameter(s):",
		overrideWidgetMissing: "Overschrijvingsonderdeel editor ontbreekt!",
		uiIncomplete: "Taakindiening is mislukt. De functie kan niet worden uitgevoerd omdat een aantal van de vereiste velden onvolledig is of ontbreekt in de UI.",
		count: "Aantal",
		selectVariables: "Variabelen selecteren",
		selectFeature: "Feature layer selecteren",
		greaterThanErrorMessage: "De invoerwaarde moet groter zijn dan ${min}",
		lesserThanErrorMessage: "De invoerwaarde moet kleiner zijn dan ${max}",
		greaterThanOrEqualErrorMessage: "De invoerwaarde moet groter dan of gelijk zijn aan ${min}",
		lesserThanOrEqualErrorMessage: "De invoerwaarde moet kleiner dan of gelijk zijn aan ${max}",
		allowScalar: "Selecteer een laag of voer een constante in",
		selectField: "Veld selecteren",
		parameterRequired: "Deze parameter is vereist.",
		enterAValue: "Voer een waarde in...",
		invalidInput: "De ingevoerde waarde is niet geldig.",
		itemNotFound: "Het item bestaat niet of is niet toegankelijk.",
		itemPermissionDenied: "U heeft geen toegangsmachtigingen voor dit item.",
		layerNotAvailable: "Kaartlaag laden mislukt ${layerName}.",
		multipleLayersNotAvailable: "Kaartlaag ${layerName} en andere laden mislukt.",
		learnMoreLabel: "Meer informatie",
		fieldNotAvailable: "Veld laden mislukt.",
		allowAnalysis: "Analyse is niet toegestaan op de image service.",
		allowAnalysisReason: "Een of meer lagen van de kaart zijn hier niet opgenomen omdat ze geen analyse mogelijk maken.",
		learnMoreText: "Meer informatie",
		atLeastOneRasterInput: "Ten minste één invoerlaag moet een rasterlaag zijn.",
		browseAnalysisLayers: "Blader door lagen",
		activeMapViewExtent: "Huidige extent van de kaart gebruiken",
		chooseRaster: "Raster knippen kiezen",
		chooseGeometry: "Geometrie bijsnijden kiezen",
		resultType: "Resultaattype",
		saveInFolder: "Opslaan in map",
		outputName: "Uitvoernaam",
		outputLayerType: "Uitvoer kaartlaagtype",
		dynamicImageryLayer: "Dynamische imagery layer",
		tiledImageryLayer: "Tiled imagery layer",
		custom: "Aangepast",
		loading: "Bezig met laden...",
		layerMissing: "Een of meer lagen van de kaart worden hier niet vermeld omdat daarin geen analyse is toegestaan. Meer informatie.",
		browseCoordinateSystems: "Coördinatensystemen doorbladeren",
		unableToRepopulateOutSR: "Kan uitvoercoördinatensysteem niet invullen.",
		defaultTitle: "Meer bekijken",
		"ARC (equal arc-second)": "ARC (gelijke boogseconde)",
		Africa: "Afrika",
		Antarctica: "Antarctica",
		Argentina: "Argentinië",
		Asia: "Azië",
		"Asteroid Belt": "Asteroïdengordel",
		"Atlantic Ocean": "Atlantische Oceaan",
		Australia: "Australië",
		"Australia and New Zealand": "Australië en Nieuw-Zeeland",
		Austria: "Oostenrijk",
		"BLM (US Feet)": "BLM (US Feet)",
		Bangladesh: "Bangladesh",
		"Beijing 1954": "Beijing 1954",
		Bhutan: "Bhutan",
		CGCS2000: "CGCS2000",
		Canada: "Canada",
		Caribbean: "Caribisch gebied",
		"Caribbean Sea": "Caribische zee",
		"Central America": "Midden-Amerika",
		"Central and North America": "Midden- en Noord-Amerika",
		Colombia: "Colombia",
		Continental: "Continentaal",
		"County Systems": "County Systems",
		"Democratic Republic of the Congo": "Democratische Republiek Congo",
		"EPSG Arctic": "EPSG Arctic",
		Earth: "Aarde",
		"Ellipsoidal-based": "Ellipsoïdaal",
		Europe: "Europa",
		Finland: "Finland",
		France: "Frankrijk",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss Kruger",
		"Geographic Coordinate Systems": "Geografische coördinatensystemen",
		Germany: "Duitsland",
		"Gravity-related": "Zwaartekrachtgerelateerde",
		"Greenwich-based": "Greenwich-gebaseerd",
		"Highways England": "Snelwegen Engeland",
		Illinois: "Illinois",
		"Indian Ocean": "Indische Oceaan",
		"Indian Subcontinent": "Indisch subcontinent",
		Indiana: "Indiana",
		Indonesia: "Indonesië",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Ierland en Verenigd Koninkrijk",
		Italy: "Italië",
		Japan: "Japan",
		Jupiter: "Jupiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Libië",
		Malaysia: "Maleisië",
		"Malaysia and Singapore": "Maleisië en Singapore",
		Mars: "Mars",
		Mercury: "Mercurius",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (US Feet)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (Intl Feet)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (Meters)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (US Feet)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (Intl Feet)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (Meters)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (US Feet)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (Intl Feet)",
		"NAD 1983 (Meters)": "NAD 1983 (Meters)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (Meters)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (US Feet)",
		"NAD 1983 (US Feet)": "NAD 1983 (US Feet)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (Intl Feet)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (Meters)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (US Feet)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (Intl Feet)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (Meters)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (US Feet)",
		"National Grids": "National Grids",
		Navajo: "Navajo",
		Neptune: "Neptunus",
		"New Beijing": "New Beijing",
		"New Zealand": "Nieuw-Zeeland",
		"North America": "Noord-Amerika",
		"Northern Hemisphere": "Noordelijk halfrond",
		Norway: "Noorwegen",
		Oceans: "Oceanen",
		Oregon: "Oregon",
		"Other GCS": "Overig GCS",
		"Pacific Ocean": "Stille Oceaan",
		Pluto: "Pluto",
		Polar: "Polair",
		Portugal: "Portugal",
		"Projected Coordinate Systems": "Geprojecteerde coördinatensystemen",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Vervangen",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturnus",
		"Solar System": "Zonnestelsel",
		"South Africa": "Zuid-Afrika",
		"South America": "Zuid-Amerika",
		"South Korea": "Zuid-Korea",
		"Southern Hemisphere": "Zuidelijk halfrond",
		"Spheroid-based": "Sferoïdaal",
		"State Plane": "Staatsvlak",
		"State Systems": "Staatssystemen",
		Sweden: "Zweden",
		"Switzerland and Liechtenstein": "Zwitserland en Liechtenstein",
		Texas: "Texas",
		Tribal: "Tribal",
		Turkey: "Turkije",
		"US Feet": "US Feet",
		"USA and territories": "USA en gebieden",
		UTM: "UTM",
		Ukraine: "Oekraïne",
		"Unknown Height Systems": "Onbekende hoogtesystemen",
		Uranus: "Uranus",
		Venus: "Venus",
		"Vertical Coordinate Systems": "Verticale coördinatensystemen",
		Vietnam: "Vietnam",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Wereld",
		"World (Sphere-based)": "Wereld (op bolbasis)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Gereed",
		noResults: "Kan geen resultaten vinden",
		searchPlaceholder: "Naam of WKID",
		browseTemplate: "Door rasterfunctiesjablonen bladeren",
		saveTemplate: "Rasterfunctiesjabloon opslaan",
		preview: "Voorbeeld",
		previewDescription: "Geef een voorbeeld weer voordat de analyse wordt uitgevoerd.",
		showPreview: "Voorbeeld weergeven",
		previewLayer: "Voorbeeld laag ${number}",
		newPreview: "Nieuw voorbeeld",
		previewPopup: "Schakel het voorbeeld van de analyseresultaten in op basis van de invoerparameters.",
		updatePreviewLayer: "Geselecteerde voorbeeldlaag updaten",
		createPreviewLayer: "Nieuwe voorbeeldlaag maken",
		maximumPreviewAllowed: "Maximumaantal toegestane voorbeeldlagen: ${maxCount}",
		previewFailure: "Deze voorbeeldlaag is niet beschikbaar. Controleer de invoerparameters en werk de voorbeeldlaag opnieuw bij.",
		header: "Item selecteren",
		content: "Er zijn niet-opgeslagen wijzigingen in ${rftTitle}. Als u opnieuw begint met een nieuwe sjabloon, gaan al die wijzigingen verloren.",
		dontSave: "Niet opslaan",
		"continue": "Doorgaan",
		stretch: "Aanpassen aan venster",
		pan: "Pannen",
		newTemplate: "Nieuwe sjabloon maken",
		openTemplate: "Sjabloon openen",
		addFunction: "Rasterfuncties toevoegen",
		addConstant: "Constante toevoegen",
		addRaster: "Rastervariabele toevoegen",
		move: "Verplaatsen",
		zoom: "Zoomen",
		saveAs: "Opslaan als",
		clear: "Wissen",
		addRasterFunctionTitle: "Rasterfuncties toevoegen",
		templatePropertiesTitle: "Eigenschappen sjabloon",
		browseRFT: "Door rasterfunctiesjablonen bladeren",
		defaultToolDescription: "${toolTitle} analysetool.",
		openToolText: "Tool openen",
		toolDropdownText: "Tool vervolgkeuzelijst",
		addToMap: "Bevestigen en aan kaart toevoegen",
		confirm: "Bevestigen",
		select: "Selecteren",
		selectTask: "Taak selecteren",
		unsupportedLayer: "Deze parameter biedt geen ondersteuning voor de volgende kaartlagen: ${layerName}.",
		viewDetails: "Volledige itemdetails bekijken",
		rename: "Naam wijzigen",
		duplicate: "Dupliceren",
		launch: "Openen voor uitvoering",
		templateEditor: "Sjablooneditor",
		createItem: "Rasterfunctiesjabloon opslaan",
		actionLabel: "Filteren",
		filterPopoverHeading: "De functies filteren",
		defaultSearchPlaceholder: "Op naam zoeken",
		settings: "Instellingen",
		summary: "Samenvatting",
		definitionQuery: "Definitiequery",
		matchVariables: "Overeenkomstvariabelen",
		unionDimension: "Samenvoegingsafmeting",
		nameEditorPlaceholder: "Titel invoeren",
		summaryEditorPlaceholder: "Voer een korte beschrijving in.",
		definitionQueryPlaceholder: "Invoeren...",
		upload: "Uploaden",
		chooseImage: "Klik om een bestand te kiezen",
		update: "Bijwerken",
		thumbnailErrors: {
			wrongImageType: "Verkeerd beeldtype geselecteerd",
			notAvailable: "Thumbnail is niet beschikbaar",
			loadError: "Kan afbeelding niet laden",
			chooseFile: "Klik om bestand te kiezen"
		}
	}
};
const copy = "Kopiëren";
const save = "Opslaan";
const title = "Titel";
const folder = "Folder";
const tags = "Labels";
const savingMessage = "Item opslaan in";
const shareWith = "Delen met";
const share = "Delen";
const setSharingLevel = "Deelniveau instellen";
const setGroupSharing = "Groep delen instellen";
const owner = "Eigenaar";
const organization = "Organisatie";
const everyone = "Iedereen (openbaar)";
const groups = "Groepen:";
const type = "Type";
const mosaic = "Mozaïek";
const itemGroup = "Itemgroep";
const item = "Item";
const definitionQuery = "Definition Query";
const groupItemsBy = "Items groeperen op";
const groupFieldName = "Veldnaam groeperen";
const tagFieldName = "Veldnaam taggen";
const noTitleTagErrorMsg = "U moet een titel en tags opgeven voor uw item zodat er naar uw kaart kan worden gezocht.";
const noTitleErrorMsg = "U moet een titel opgeven voor uw item.";
const noTagErrorMsg = "U moet minimaal één tag opgeven zodat uw item kan worden gevonden via zoekacties.";
const error = "Fout";
const warning = "Waarschuwing";
const success = "Succes";
const details = "Details:";
const tryAgain = "Opnieuw proberen";
const toolModeler = {
	save: "Opslaan",
	editProperties: "Eigenschappen bewerken",
	saveAs: "Opslaan als",
	savingNotification: "Wijzigingen in item opslaan ...",
	savingTitle: "Opslaan",
	saveFailedMessage: "wijzigingen opslaan mislukt.",
	saveWithErrorsMessage: "Wijzigingen zijn opgeslagen met de volgende fouten.",
	viewItemMessage: "Bekijk het opgeslagen item",
	here: "here.",
	itemCreatedMessage: "Er is een nieuw item gemaakt.",
	clickToViewItemMessage: "Klik op OK om de pagina met itemdetails weer te geven; klik op Annuleren om door te gaan.",
	readingFailed: "De geselecteerde rasterfunctietemplate kon niet worden geladen.",
	failedToLoadXML: "De geselecteerde rasterfunctietemplate kon niet worden geladen in XML-formaat.",
	learnMore: "Meer informatie",
	overwriteTitle: "Overschrijven bevestigen",
	overwriteMessage: "Wilt u het bestaande item overschrijven?",
	overwriteSuccessMessage: "Het item is bijgewerkt."
};
const toolEditor = {
	run: "Uitvoeren",
	save: "Opslaan",
	deleteSelected: "Verwijder geselecteerde items",
	addRaster: "Raster toevoegen",
	addScalar: "Scalair toevoegen",
	layout: "Automatische lay-out",
	errorTitle: "Fout",
	invalidToolMessage: "Rasterfunctietemplate is niet geldig.",
	out: "Uit",
	zoomIn: "Zoom In",
	zoomOut: "Zoom Out",
	zoomToFit: "Aanpassen aan venster",
	panOn: "Omschakelen naar panmodus",
	panOff: "Panmodus uitschakelen",
	defaultModelName: "Toolmodel",
	defaultRasterName: "Raster"
};
const toolDetailsEditor = {
	defaultToolName: "Template rasterfunctie",
	defaultToolDescription: "Voeg een korte samenvatting over de rasterfunctie toe.",
	defaultHelpText: "Klik op het Help-pictogram om de helptekst te bewerken.",
	editHelpTitle: "Help bewerken",
	saveLabel: "Opslaan",
	cancelLabel: "Afbreken",
	thumbnail: {
		wrongImageType: "Verkeerd beeldtype geselecteerd",
		notAvailable: "Thumbnail niet beschikbaar",
		loadError: "Kon de afbeelding niet laden",
		chooseFile: "Klik om bestand te kiezen."
	}
};
const saveUtils = {
	thumbnail: "Miniatuur",
	sharing: "Delen"
};
const close = "Sluiten";
const unsavedWarningExisting = "Wilt u de wijzigingen in het item opslaan <b>${itemTitle}</b> ?";
const unsavedWarningNew = "Wilt u uw wijzigingen opslaan?";
const saveAs = "Opslaan als";
const dontSave = "Niet opslaan";
const unsavedTitle = "Niet-opgeslagen wijzigingen";
const invalidRFTMessage = "De gemaakte rasterfunctietemplate is niet geldig.";
const errorTitle = "Fout";
const breadcrumb = "Raster Function Editor";
const breadcrumbEditor = "Content > Raster Function Editor";
const viewerModeTitle = "Alleen lezen";
const viewerModeMessage = "Rasterfunctie template-item is alleen-lezen. Veranderingen zijn niet opgeslagen.";
const userStartDirection = "Selecteer een functie om een rasterfunctietemplate te maken.";
const selectFunction = "Functie toevoegen";
const deselectFunction = "Functie verwijderen";
const dialogTitle = "Systeem";
const category = "Categorieën";
const search = "Rasterfuncties zoeken";
const categoryNames = {
	analysis: "Analyse",
	appearance: "Weergave",
	classification: "Classificatie",
	conversion: "Conversie",
	correction: "Correctie",
	dataManagement: "Databeheer",
	distance: "Afstand",
	distanceLegacy: "Afstand (Legacy)",
	hydrology: "Hydrologie",
	math: "Berekeningen",
	mathConditional: "Rekenkundig: Voorwaardelijk",
	mathLogical: "Rekenkundig: logisch",
	mathTrigonometric: "Rekenkundig: trigonometrisch",
	reclass: "Herclassificeren",
	statistical: "Statistisch",
	surface: "Oppervlak"
};
const commonStrings_nl = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_nl);


//# sourceMappingURL=common-strings.nl-bb99c2fc.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTgwZTcyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd1lBQXdZLGdJQUFnSSx5REFBeUQ7QUFDamtCO0FBQ0E7QUFDQSxvY0FBb2M7QUFDcGM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFJQUFxSTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc2FBQXNhO0FBQ3RhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpTEFBaUw7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFuQkFBcW5CO0FBQ3JuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdVBBQXVQO0FBQ3ZQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0dENBQTR0QywwU0FBMFM7QUFDdGdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3akdBQXdqRyxPQUFPO0FBQy9qRztBQUNBO0FBQ0Esc3lDQUFzeUM7QUFDdHlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSw4RUFBOEUsY0FBYztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsSUFBSTtBQUN2RSxtRUFBbUUsSUFBSTtBQUN2RSx3RkFBd0YsSUFBSTtBQUM1Rix3RkFBd0YsSUFBSTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFELDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsU0FBUztBQUM5RTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsVUFBVTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxVQUFVO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsZ0JBQWdCLEVBQUM7QUFDaW9DOztBQUVqcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS9jb21tb24tc3RyaW5ncy5ubC1iYjk5YzJmYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvayA9IFwiT0tcIjtcbmNvbnN0IGNhbmNlbCA9IFwiQWZicmVrZW5cIjtcbmNvbnN0IGVudGVyVVJMID0gXCJJbWFnZXNlcnZpY2UgVVJMIGludm9lcmVuXCI7XG5jb25zdCBzZXJ2aWNlVVJMID0gXCJTZXJ2aWNlLVVSTFwiO1xuY29uc3Qgc2VsZWN0UmFzdGVyID0gXCJSYXN0ZXIgc2VsZWN0ZXJlblwiO1xuY29uc3QgZmFpbGVkVG9Mb2FkTGF5ZXIgPSBcIkthYXJ0bGFhZyBsYWRlbiBtaXNsdWt0XCI7XG5jb25zdCBsb2FkaW5nTGF5ZXIgPSBcIkthYXJ0bGFhZyBsYWRlblwiO1xuY29uc3Qgc2VsZWN0RmVhdHVyZSA9IFwiT2JqZWN0bGFhZyBzZWxlY3RlcmVuXCI7XG5jb25zdCBlbnRlckZVUkwgPSBcIkZlYXR1cmVzZXJ2aWNlIFVSTCBpbnZvZXJlblwiO1xuY29uc3QgYWRkUmFzdGVyID0gXCJSYXN0ZXJ2YXJpYWJlbGUgdG9ldm9lZ2VuXCI7XG5jb25zdCBhZGRTY2FsYXIgPSBcIkNvbnN0YW50ZSB0b2V2b2VnZW5cIjtcbmNvbnN0IHJhc3RlciA9IFwiUmFzdGVyXCI7XG5jb25zdCBzY2FsYXIgPSBcIlNjYWxhaXJcIjtcbmNvbnN0IGRlZmF1bHRNb2RlbE5hbWUgPSBcIlRlbXBsYXRlIHJhc3RlcmZ1bmN0aWVcIjtcbmNvbnN0IGdlbmVyYWwgPSBcIkFsZ2VtZWVuXCI7XG5jb25zdCBwYXJhbWV0ZXJzID0gXCJQYXJhbWV0ZXJzXCI7XG5jb25zdCB2YXJpYWJsZXMgPSBcIlZhcmlhYmVsZW5cIjtcbmNvbnN0IG5hbWUgPSBcIk5hYW1cIjtcbmNvbnN0IGRlc2NyaXB0aW9uID0gXCJCZXNjaHJpanZpbmdcIjtcbmNvbnN0IHBhcmFtZXRlciA9IFwiUGFyYW1ldGVyXCI7XG5jb25zdCBpc1B1YmxpYyA9IFwiSXNPcGVuYmFhclwiO1xuY29uc3QgaXNEYXRhc2V0ID0gXCJJc0RhdGFzZXRcIjtcbmNvbnN0IHVua25vd25QaXhlbFR5cGUgPSBcIk9uYmVrZW5kXCI7XG5jb25zdCBvdXRwdXRQaXhlbFR5cGUgPSBcIlVpdHZvZXJwaXhlbHR5cGVcIjtcbmNvbnN0IHU4UGl4ZWxUeXBlID0gXCI4IGJpdHMgbmlldC1vbmRlcnRla2VuZFwiO1xuY29uc3QgczhQaXhlbFR5cGUgPSBcIjggYml0cyBvbmRlcnRla2VuZFwiO1xuY29uc3QgdTE2UGl4ZWxUeXBlID0gXCIxNiBiaXRzIG5pZXQtb25kZXJ0ZWtlbmRcIjtcbmNvbnN0IHMxNlBpeGVsVHlwZSA9IFwiMTYgYml0cyBvbmRlcnRla2VuZFwiO1xuY29uc3QgdTMyUGl4ZWxUeXBlID0gXCIzMiBiaXRzIG5pZXQtb25kZXJ0ZWtlbmRcIjtcbmNvbnN0IHMzMlBpeGVsVHlwZSA9IFwiMzIgYml0cyBvbmRlcnRla2VuZFwiO1xuY29uc3QgZjMyUGl4ZWxUeXBlID0gXCIzMiBiaXRzIHp3ZXZlbmRcIjtcbmNvbnN0IGY2NFBpeGVsVHlwZSA9IFwiNjQgYml0cyBkdWJiZWxcIjtcbmNvbnN0IHByb3BlcnRpZXMgPSBcIkVpZ2Vuc2NoYXBwZW5cIjtcbmNvbnN0IG11bHRpZGltZW5zaW9uYWxSdWxlcyA9IFwiTXVsdGlkaW1lbnNpb25hbGUgUmVnZWxzXCI7XG5jb25zdCBtYXRjaFZhcmlhYmxlcyA9IFwiT3ZlcmVlbmtvbXN0dmFyaWFiZWxlblwiO1xuY29uc3QgdW5pb25EaW1lbnNpb25zID0gXCJWZXJlbmlnaW5nc2RpbWVuc2llc1wiO1xuY29uc3QgcmFzdGVyRnVuY3Rpb25FZGl0b3IgPSB7XG5cdGludmFsaWRSRlRNZXNzYWdlOiBcIkRlIHJhc3RlcmZ1bmN0aWV0ZW1wbGF0ZSBpcyBuaWV0IGdlbGRpZy5cIixcblx0cmZ4QXJnc0VkaXRvcjoge1xuXHRcdG91dHB1dFJhc3RlcjogXCJPdXRwdXRSYXN0ZXJcIixcblx0XHRyYXN0ZXI6IFwiUmFzdGVyXCIsXG5cdFx0dW5zdXBwb3J0ZWREYXRhVHlwZVdhcm5pbmc6IFwiRGUgdm9sZ2VuZGUgYXJndW1lbnRlbiB3b3JkZW4gbmlldCB3ZWVyZ2VnZXZlbiBvbWRhdCB6ZSBtb21lbnRlZWwgbmlldCB3b3JkZW4gb25kZXJzdGV1bmQuXCIsXG5cdFx0dW5zdXBwb3J0ZWRGdW5jdGlvbjogXCJCZXZhdCBtb21lbnRlZWwgb25kZXJzdGV1bmRlIHJhc3RlcmZ1bmN0aWVzLlwiXG5cdH0sXG5cdHJmeFJhc3RlcklucHV0OiB7XG5cdFx0c2VsZWN0TGF5ZXI6IFwiS2FhcnRsYWFnIHNlbGVjdGVyZW5cIixcblx0XHRicm93c2VMYXllcnM6IFwiQmxhZGVyIGRvb3IgbGFnZW5cIixcblx0XHRyZnhWYXJpYWJsZTogXCJSYXN0ZXJGdW5jdGllVmFyaWFibGVcIlxuXHR9LFxuXHRyZnhCYW5kQ29tYmluYXRpb25FZGl0b3I6IHtcblx0XHRtZXRob2RMYWJlbDogXCJNZXRob2RlXCIsXG5cdFx0YmFuZExhYmVsOiBcIkJhbmRcIixcblx0XHRjb21iaW5hdGlvbkxhYmVsOiBcIkNvbWJpbmF0aWVcIlxuXHR9LFxuXHRyZnhSZW1hcEdyaWQ6IHtcblx0XHRtaW5pbXVtOiBcIk1pbmltdW1cIixcblx0XHRtYXhpbXVtOiBcIk1heGltdW1cIixcblx0XHRvdXRwdXQ6IFwiVWl0dm9lclwiLFxuXHRcdG5vRGF0YTogXCJOb0RhdGFcIixcblx0XHRyZW1hcFZhbHVlc0xhYmVsOiBcIldhYXJkZW4gb3BuaWV1dyBiZXBhbGVuXCJcblx0fSxcblx0cmZ4TmFtZWRSYXN0ZXJFZGl0b3I6IHtcblx0XHRyYXN0ZXJWYXJpYWJsZXM6IFwiUmFzdGVydmFyaWFiZWxlblwiLFxuXHRcdGRlbGV0ZVNlbGVjdGVkVmFyczogXCJHZXNlbGVjdGVlcmRlIHZhcmlhYmVsZW4gdmVyd2lqZGVyZW5cIlxuXHR9LFxuXHRyZnhDbGlwcGluZ0dlb21ldHJ5OiB7XG5cdFx0Y2xpcHBpbmdMYXllcjogXCJLYWFydGxhYWcga25pcHBlblwiLFxuXHRcdGNsaXBwaW5nUmFzdGVyOiBcIlJhc3RlciBrbmlwcGVuXCIsXG5cdFx0Y2xpcHBpbmdHZW9tZXRyeTogXCJHZW9tZXRyaWUgYmlqc25pamRlblwiLFxuXHRcdGN1c3RvbUV4dGVudDogXCJBYW5nZXBhc3RlIGV4dGVudFwiLFxuXHRcdG91dHB1dEV4dGVudDogXCJVaXR2b2VyZXh0ZW50XCIsXG5cdFx0Y3VycmVudEV4dGVudDogXCJIdWlkaWdlIGthYXJ0ZXh0ZW50XCIsXG5cdFx0ZHJhd0xhYmVsOiBcIlRla2VuZW5cIlxuXHR9LFxuXHRyZnhDdXN0b21FeHRlbnQ6IHtcblx0XHR0b3A6IFwiQm92ZW5cIixcblx0XHRyaWdodDogXCJSZWNodHNcIixcblx0XHRib3R0b206IFwiT25kZXJcIixcblx0XHRsZWZ0OiBcIkxpbmtzXCJcblx0fSxcblx0cmZ4UmFzdGVyQXJyYXlFZGl0b3I6IHtcblx0XHRtb3ZlVXA6IFwiTmFhciBib3ZlbiB2ZXJwbGFhdHNlblwiLFxuXHRcdG1vdmVEb3duOiBcIk5hYXIgYmVuZWRlbiB2ZXJwbGFhdHNlblwiLFxuXHRcdHJlbW92ZTogXCJWZXJ3aWpkZXJlblwiXG5cdH0sXG5cdHJmeFN0YXRpc3RpY3NHcmlkOiB7XG5cdFx0c3RkRGV2OiBcIlN0ZC4gQWZ3XCIsXG5cdFx0bWluOiBcIk1pblwiLFxuXHRcdG1heDogXCJNYXhcIixcblx0XHRtZWFuOiBcIk1lZGlhYW5cIlxuXHR9LFxuXHRyZnhXZWlnaHRlZFN1bVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRTdW1UYWJsZTogXCJHZXdvZ2VuIFNvbXRhYmVsXCIsXG5cdFx0aWQ6IFwiSURcIixcblx0XHRsYXllcjogXCJLYWFydGxhYWdcIixcblx0XHRmaWVsZDogXCJWZWxkXCIsXG5cdFx0d2VpZ2h0OiBcIkdld2ljaHRcIixcblx0XHR2YWx1ZTogXCJXYWFyZGVcIixcblx0XHRzZWxlY3RMYXllcjogXCJLYWFydGxhYWcgc2VsZWN0ZXJlblwiXG5cdH0sXG5cdHJmeFdlaWdodGVkT3ZlcmxheVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRPdmVybGF5VGFibGU6IFwiV2VpZ2h0ZWQgT3ZlcmxheS10YWJlbFwiLFxuXHRcdGlkOiBcIklEXCIsXG5cdFx0bGF5ZXI6IFwiS2FhcnRsYWFnXCIsXG5cdFx0ZmllbGQ6IFwiVmVsZFwiLFxuXHRcdGluZmx1ZW5jZTogXCJJbnZsb2VkXCIsXG5cdFx0c3VtT2ZJbmZsdWVuY2U6IFwiU29tIHZhbiBpbnZsb2VkXCIsXG5cdFx0dmFsdWU6IFwiV2FhcmRlXCIsXG5cdFx0cmVtYXBUYWJsZTogXCJSZW1hcHRhYmVsXCIsXG5cdFx0c2NhbGU6IFwiU2NoYWFsXCIsXG5cdFx0c2NhbGVzOiBcIlNjaGFsZW5cIixcblx0XHRzZWxlY3RSYXN0ZXI6IFwiUmFzdGVyIHNlbGVjdGVyZW5cIlxuXHR9LFxuXHRyZnhGZWF0dXJlU2VsZWN0OiB7XG5cdFx0YWRkRmVhdHVyZUxheWVyOiBcIkJsYWRlcmVuIG5hYXIgZWVuIG9iamVjdGxhYWdcIixcblx0XHRhZGRQb2ludExheWVyOiBcIkJsYWRlcmVuIG5hYXIgZWVuIHB1bnRsYWFnXCJcblx0fSxcblx0cmZ4RmllbGRTZWxlY3Q6IHtcblx0XHR2YWx1ZTogXCJXYWFyZGVcIixcblx0XHRjb3VudDogXCJBYW50YWxcIlxuXHR9LFxuXHRyZnhBdHRyaWJ1dGVUYWJsZToge1xuXHRcdHRhYmxlVHlwZTogXCJUYWJlbHR5cGVcIixcblx0XHRtYW51YWw6IFwiSGFuZG1hdGlnXCIsXG5cdFx0ZXh0ZXJuYWw6IFwiRXh0ZXJuXCIsXG5cdFx0bWluVmFsOiBcIk1pbmltdW13YWFyZGVcIixcblx0XHRtYXhWYWw6IFwiTWF4aW11bXdhYXJkZVwiLFxuXHRcdGJhc2VDbGFzc05hbWU6IFwiS2xhc3NlIGJhc2lzbmFhbVwiLFxuXHRcdGNvbG9yU2NoZW1lOiBcIktsZXVyZW5zY2hlbWFcIixcblx0XHRkZWZhdWx0Q2xhc3NOYW1lOiBcIkxhYmVsX1wiLFxuXHRcdGdlbmVyYXRlVGFibGU6IFwiVGFiZWwgZ2VuZXJlcmVuXCIsXG5cdFx0YnJvd3NlVGFibGU6IFwiVGFiZWwgQmVraWprZW5cIixcblx0XHR2YWx1ZTogXCJXYWFyZGVcIixcblx0XHRjbGFzc25hbWU6IFwiS2xhc3NlbmFhbVwiLFxuXHRcdGNvbG9yOiBcIktsZXVyXCJcblx0fSxcblx0cmZ4RmllbGROdW1iZXJTd2l0Y2hhYmxlOiB7XG5cdFx0bnVtYmVyOiBcIk51bWVyaWVrXCIsXG5cdFx0ZmllbGQ6IFwiVmVsZFwiLFxuXHRcdHN0cmluZzogXCJUZWtlbnJlZWtzXCIsXG5cdFx0bGluZWFyVW5pdDogXCJMaW5lYWlyZSBlZW5oZWlkXCJcblx0fSxcblx0cmZ4UHJvcGVydHlTZXQ6IHtcblx0XHRuYW1lOiBcIk5hYW1cIixcblx0XHR2YWx1ZTogXCJXYWFyZGVcIlxuXHR9LFxuXHRyZnhDb252ZXJzaW9uR3JpZDoge1xuXHRcdHNpemU6IFwiR3Jvb3R0ZVwiXG5cdH0sXG5cdHJmeFRyYW5zcG9zZUJpdDoge1xuXHRcdGJpdFBhdHRlcm46IFwiQml0cGF0cm9vblwiLFxuXHRcdG91dHB1dEJpdDogXCJVaXR2b2VyYml0XCIsXG5cdFx0aW5wdXRCaXQ6IFwiSW52b2VyYml0XCJcblx0fSxcblx0cmZ4U3BhdGlhbFJlZmVyZW5jZToge1xuXHRcdHBsYWNlSG9sZGVyOiBcIlZlcmZpam5lbiBvcCB0cmVmd29vcmRcIixcblx0XHRjb29yZGluYXRlU3lzdGVtOiBcIkNvw7ZyZGluYXRlbnN5c3RlZW1cIixcblx0XHRnY3M6IFwiR2VvZ3JhZmlzY2ggY2/DtnJkaW5hYXRzeXN0ZWVtXCIsXG5cdFx0cGNzOiBcIkdlcHJvamVjdGVlcmQgY2/DtnJkaW5hYXRzeXN0ZWVtXCIsXG5cdFx0dmNzOiBcIlZlcnRpY2FhbCBjb8O2cmRpbmFhdHN5c3RlZW1cIlxuXHR9XG59O1xuY29uc3QgcmZ4TGljZW5zZUluZm8gPSBcIkRlemUgcmFzdGVyZnVuY3RpZXRlbXBsYXRlIGthbiB3b3JkZW4gZ2VicnVpa3Qgb20gdXcgc2F0ZWxsaWV0YmVlbGRlbiB0ZSB2ZXJ3ZXJrZW4gbWV0IGJlaHVscCB2YW4gQXJjR0lTIEltYWdlIFNlcnZlci5cIjtcbmNvbnN0IHJhc3RlckZ1bmN0aW9ucyA9IHtcblx0cmZ4OiB7XG5cdFx0YUNvc0hOYW1lOiBcIkFDb3NIXCIsXG5cdFx0YUNvc0hTbmlwOiBcIkJlcmVrZW50IGRlIGludmVyc2UgaHlwZXJib2xlIGNvc2ludXMgdmFuIGNlbGxlbiBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGFDb3NIRGVzYzogXCJEZSBmdW5jdGllIGJlcmVrZW50IGRlIGludmVyc2UgaHlwZXJib2xlIGNvc2ludXMgdmFuIGRlIHBpeGVscyBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGFDb3NOYW1lOiBcIkFDb3NcIixcblx0XHRhQ29zU25pcDogXCJCZXJla2VudCBkZSBpbnZlcnNlIGNvc2ludXMgdmFuIGRlIHBpeGVscyBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGFDb3NEZXNjOiBcIkRlemUgcmFzdGVyZnVuY3RpZSBiZXJla2VudCBkZSBhcmNjb3NpbnVzIHZhbiBjZWxsZW4gaW4gZWVuIHJhc3Rlci4gSW4gZGUgd2lza3VuZGUgaGViYmVuIGFsbGUgdHJpZ29ub21ldHJpc2NoZSBmdW5jdGllcyBlZW4gZ2VkZWZpbmllZXJkIGJlcmVpayB2YW4gZ2VsZGlnZSBpbnZvZXJ3YWFyZGVuLCBoZXQgZG9tZWluIGdlbm9lbWQuIERlIHVpdHZvZXJ3YWFyZGVuIHZhbiBlbGtlIGZ1bmN0aWUgaGViYmVuIG9vayBlZW4gZ2VkZWZpbmllZXJkIGJlcmVpay4gVm9vciBkZXplIHRvb2wgaXMgaGV0IGRvbWVpbiBbLTEsIDFdIGVuIGhldCBiZXJlaWsgaXMgWzAsIHBpXS5cIixcblx0XHRhU2luSE5hbWU6IFwiQVNpbkhcIixcblx0XHRhU2luSFNuaXA6IFwiQmVyZWtlbnQgZGUgaW52ZXJzZSBoeXBlcmJvbGUgc2ludXMgdmFuIGNlbGxlbiBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGFTaW5IRGVzYzogXCJEZSBmdW5jdGllIGJlcmVrZW50IGRlIGludmVyc2UgaHlwZXJib2xlIHNpbnVzIHZhbiBkZSBwaXhlbHMgaW4gZWVuIHJhc3Rlci5cIixcblx0XHRhU2luTmFtZTogXCJBU2luXCIsXG5cdFx0YVNpblNuaXA6IFwiQmVyZWtlbnQgZGUgaW52ZXJzZSBzaW51cyB2YW4gY2VsbGVuIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0YVNpbkRlc2M6IFwiRGUgZnVuY3RpZSBiZXJla2VudCBkZSBpbnZlcnNlIHNpbnVzIHZhbiBkZSBwaXhlbHMgaW4gZWVuIHJhc3Rlci5cIixcblx0XHRhVGFuMk5hbWU6IFwiQVRhbjJcIixcblx0XHRhVGFuMlNuaXA6IFwiQmVyZWtlbnQgZGUgaW52ZXJzZSB0YW5nZW5zIChnZWJhc2VlcmQgb3AgeCx5KSB2YW4gY2VsbGVuIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0YVRhbjJEZXNjOiBcIkRlIGZ1bmN0aWUgYmVyZWtlbnQgZGUgaW52ZXJzZSB0YW5nZW5zIChnZWJhc2VlcmQgb3AgeCx5KSB2YW4gZGUgcGl4ZWxzIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0YVRhbkhOYW1lOiBcIkFUYW5IXCIsXG5cdFx0YVRhbkhTbmlwOiBcIkJlcmVrZW50IGRlIGludmVyc2UgaHlwZXJib2xlIHRhbmdlbnMgdmFuIGNlbGxlbiBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGFUYW5IRGVzYzogXCJEZSBmdW5jdGllIGJlcmVrZW50IGRlIGludmVyc2UgaHlwZXJib2xlIHRhbmdlbnMgdmFuIGRlIHBpeGVscyBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGFUYW5OYW1lOiBcIkFUYW5cIixcblx0XHRhVGFuU25pcDogXCJCZXJla2VudCBkZSBpbnZlcnNlIHRhbmdlbnMgdmFuIGNlbGxlbiBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGFUYW5EZXNjOiBcIkRlIGZ1bmN0aWUgYmVyZWtlbnQgZGUgaW52ZXJzZSB0YW5nZW5zIHZhbiBkZSBwaXhlbHMgaW4gZWVuIHJhc3Rlci5cIixcblx0XHRhYnNOYW1lOiBcIkFic1wiLFxuXHRcdGFic1NuaXA6IFwiQmVyZWtlbnQgZGUgYWJzb2x1dGUgd2FhcmRlIHZhbiBkZSBjZWxsZW4gaW4gZWVuIHJhc3Rlci5cIixcblx0XHRhYnNEZXNjOiBcIkRlIEFicy1mdW5jdGllIGJlcmVrZW50IGRlIGFic29sdXRlIHdhYXJkZSB2YW4gZGUgcGl4ZWxzIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0cmVmbGVjdGFuY2VOYW1lOiBcIlNjaGlqbmJhcmUgcmVmbGVjdGllXCIsXG5cdFx0cmVmbGVjdGFuY2VTbmlwOiBcIlpldCBvbmJld2Vya3RlIGJlZWxkZW4gb20gaW4gd2FhcmRlbiB2b29yIFRvcCBvZiBBdG1vc3BoZXJlIGRvb3IgcmVrZW5pbmcgdGUgaG91ZGVuIG1ldCBzZW5zb3JlaWdlbnNjaGFwcGVuLCBkZSBwb3NpdGllIHZhbiBkZSB6b24gZW4gZGUgYWNxdWlzaXRpZXRpamQuXCIsXG5cdFx0cmVmbGVjdGFuY2VEZXNjOiBcIk1ldCBkZXplIGZ1bmN0aWUgd29yZGVuIGRlIHdhYXJkZW4gdm9vciBoZXQgZGlnaXRhbGUgYWFudGFsIChETikgdmFuIGRlIGJlZWxkaGVsZGVyaGVpZCBhYW5nZXBhc3Qgdm9vciBzb21taWdlIHNhdGVsbGlldHNlbnNvcmVuLiBEZSBhYW5wYXNzaW5nZW4gemlqbiBnZWJhc2VlcmQgb3AgZGUgaG9vZ3RlIHZhbiBkZSB6b24sIGRlIG9wbmFtZWRhdHVtIGVuIGRlIHNlbnNvcmVpZ2Vuc2NoYXBwZW4gb20gZGUgdmVyc3RlcmtpbmcgZW4gYmlhcyBpbiB0ZSBzdGVsbGVuIHZvb3IgZWxrZSBiYW5kLiBEZXplIGZ1bmN0aWUgd29yZHQgZ2VicnVpa3Qgb20gZGUgcmVmbGVjdGFudGllLSBvZiBoZWxkZXJoZWlkc3dhYXJkZW4gdmFuIHNvbW1pZ2Ugc2F0ZWxsaWV0YmVlbGRlbiBhYW4gdGUgcGFzc2VuIG9wIGJhc2lzIHZhbiBkZSBzY8OobmV2ZXJsaWNodGluZyBlbiBzZW5zb3J2ZXJzdGVya2luZ3NpbnN0ZWxsaW5nZW4uIERlIGFmYmVlbGRpbmdlbiB6aWpuIGFhbmdlcGFzdCBhYW4gZWVuIHRoZW9yZXRpc2NoIGdlYnJ1aWtlbGlqa2UgYmVsaWNodGluZ3N2b29yd2FhcmRlLCBkdXMgZXIgbW9ldCBtaW5kZXIgdmFyaWF0aWUgemlqbiB0dXNzZW4gc2NlbmVzIHZhbiB2ZXJzY2hpbGxlbmRlIGRhdGEgZW4gdmVyc2NoaWxsZW5kZSBzZW5zb3Jlbi4gRGl0IGthbiBoYW5kaWcgemlqbiB2b29yIGJlZWxkY2xhc3NpZmljYXRpZSwga2xldXJiYWxhbnMgZW4gbW96YcOvZWtlbi4gRGV6ZSBmdW5jdGllIGthbiBhbGxlZW4gd29yZGVuIGdlYnJ1aWt0IG1ldCBzcGVjaWZpZWtlIGFmYmVlbGRpbmdlbi4gRGUgdG9lcGFzc2VsaWprZSBzZW5zb3JlbiB6aWpuIExhbmRzYXQgTVNTLCBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIEdlb0V5ZS0xLCBSYXBpZEV5ZSwgRE1DaWksIFdvcmxkVmlldy0xLCBXb3JsZFZpZXctMiwgU1BPVCA2IGVuIFBsZWlhZGVzLjxkaXY+PGJyLz5EZSBmdW5jdGllIHZvZXJ0IHR3ZWUgY29ycmVjdGllcyB1aXQuIERlIGVlcnN0ZSBpcyBnZWJhc2VlcmQgb3AgZGUgdmVyc3RlcmtpbmdzaW5zdGVsbGluZ2VuLiBEZSBvb3JzcHJvbmtlbGlqa2UgaGVsZGVyaGVpZHN3YWFyZGVuIHdvcmRlbiBvcG5pZXV3IGdlbWFha3QgdWl0IGRlIGFmYmVlbGRpbmdzd2FhcmRlbiBkb29yIGRlIHZlcnN0ZXJraW5nc3ZlcmdlbGlqa2luZ2VuIG9tIHRlIGtlcmVuLiBEZSB0d2VlZGUgY29ycmVjdGllIGhlZWZ0IHRlIG1ha2VuIG1ldCB2ZXJzY2hpbGxlbiBpbiB6b25ob2VrIGVuIGhlbGRlcmhlaWQuIERlIG9vcnNwcm9ua2VsaWprZSBoZWxkZXJoZWlkc3dhYXJkZW4gd29yZGVuIGFhbmdlcGFzdCBhYW4gZ2V3b25lIGxpY2h0b21zdGFuZGlnaGVkZW4gZG9vciBzY2VuZXMgdGUgbm9ybWFsaXNlcmVuIGRpZSB6aWpuIHZhc3RnZWxlZ2Qgb25kZXIgdmFyaWFiZWxlIGJlbGljaHRpbmdzb21zdGFuZGlnaGVkZW4uIEluIGhldCBhbGdlbWVlbiBnZWxkdCBkYXQsIGhvZXdlbCBoZXQgZ2VnZXZlbnN0eXBlIHZhbiBkZSB1aXR2b2VyYWZiZWVsZGluZyBoZXR6ZWxmZGUgaXMgYWxzIGhldCBnZWdldmVuc3R5cGUgdmFuIGRlIGludm9lcmFmYmVlbGRpbmcsIGRlIHVpdHZvZXJ3YWFyZGVuIGxhZ2VyIHppam4gZGFuIGRlIGludm9lcndhYXJkZW4gZW4gd29yZGVuIGJpamdlc25lZGVuIG5hYXIgaGV0IGdlbGRpZ2UgZ2VnZXZlbnNiZXJlaWsuPC9kaXY+XCIsXG5cdFx0YXJnU3RhdGlzdGljc05hbWU6IFwiQXJnU3RhdGlzdGlla2VuXCIsXG5cdFx0YXJnU3RhdGlzdGljc1NuaXA6IFwiQmVyZWtlbnQgYXJnc3RhdGlzdGlla2VuIGluY2x1c2llZiBBcmcgTWF4LCBBcmcgTWluLCBBcmcgTWVkaWFuIGVuIER1cmF0aW9uLlwiLFxuXHRcdGFyZ1N0YXRpc3RpY3NEZXNjOiBcIkRlIGZ1bmN0aWUgYmVyZWtlbnQgYXJnLXN0YXRpc3RpZWtlbi4gRXIgemlqbiB2aWVyIG1ldGhvZGVuIGluIGRlIEFyZ1N0YXRpc3RpY3MtZnVuY3RpZTogQXJnTWF4LCBBcmdNaW4sIEFyZ01lZGlhbiBlbiBEdXJhdGlvbi5cIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJSZWtlbmt1bmRpZ1wiLFxuXHRcdGFyaXRobWV0aWNTbmlwOiBcIlZvZXJ0IGVlbiByZWtlbmt1bmRpZ2UgYmV3ZXJraW5nIHVpdCB0dXNzZW4gdHdlZSByYXN0ZXJzIG9mIGVlbiByYXN0ZXIgZW4gZWVuIHNjYWxhaXIuXCIsXG5cdFx0YXJpdGhtZXRpY0Rlc2M6IFwiRGUgcmVrZW5rdW5kaWdlIGZ1bmN0aWUgdm9lcnQgZWVuIHJla2Vua3VuZGlnZSBiZXdlcmtpbmcgdWl0IHR1c3NlbiB0d2VlIHJhc3RlcnMgb2YgZWVuIHJhc3RlciBlbiBlZW4gc2NhbGFpciBlbiBvbWdla2VlcmQuXCIsXG5cdFx0YXNwZWN0U2xvcGVOYW1lOiBcIkFzcGVjdC1IZWxsaW5nXCIsXG5cdFx0YXNwZWN0U2xvcGVTbmlwOiBcIkNyZcOrZXJ0IGVlbiByYXN0ZXIgZGF0IHRlZ2VsaWprZXJ0aWpkIGhldCBhc3BlY3QgKHJpY2h0aW5nKSBlbiBkZSBoZWxsaW5nIChzdGVpbGhlaWQpIHZhbiBlZW4gY29udGludSBvcHBlcnZsYWsgd2VlcmdlZWZ0LCB6b2FscyB3ZWVyZ2VnZXZlbiBpbiBlZW4gZGlnaXRhYWwgaG9vZ3RlbW9kZWwuXCIsXG5cdFx0YXNwZWN0U2xvcGVEZXNjOiBcIkRlIGZ1bmN0aWUgQXNwZWN0IFNsb3BlIGNyZcOrZXJ0IGVlbiByYXN0ZXJsYWFnIGRpZSB0ZWdlbGlqa2VydGlqZCBoZXQgYXNwZWN0IGVuIGRlIGhlbGxpbmcgdmFuIGVlbiBvcHBlcnZsYWsgd2VlcmdlZWZ0LiBBc3BlY3QgaWRlbnRpZmljZWVydCBkZSByaWNodGluZyBiZXJnYWZ3YWFydHMgdmFuIGRlIG1heGltYWxlIG1hdGUgdmFuIHZlcmFuZGVyaW5nIGluIHdhYXJkZSB2YW4gZWxrZSBwaXhlbCB0b3QgZGUgYnV1cmNlbGxlbi4gQXNwZWN0IGthbiB3b3JkZW4gZ2V6aWVuIGFscyBkZSBoZWxsaW5ncmljaHRpbmcuIERlIHdhYXJkZW4gdmFuIGRlIHVpdGdhYW5kZSByYXN0ZXIgemFsIGRlIGtvbXBhc3JpY2h0aW5nIHZhbiBoZXQgYXNwZWN0IHppam4sIHdlZXJnZWdldmVuIGRvb3IgZWVuIHRpbnQgKGtsZXVyKS4gSGVsbGluZyBnZWVmdCBkZSBtYXRlIHZhbiB2ZXJhbmRlcmluZyBpbiBkZSBob29ndGUgd2VlciB2b29yIGVsa2UgcGl4ZWwgdmFuIGhldCBkaWdpdGFhbCBlbGV2YXRpZW1vZGVsIChERU0pLiBIZWxsaW5nIGdlZWZ0IGRlIHN0ZWlsdGUgdmFuIGhldCBvcHBlcnZsYWsgd2VlciBlbiB3b3JkdCBnZXN5bWJvbGlzZWVyZCBpbiBkcmllIGtsYXNzZW4gZGllIHdvcmRlbiB3ZWVyZ2VnZXZlbiBtZXQgYmVodWxwIHZhbiBrbGV1cnZlcnphZGlnaW5nIChoZWxkZXJoZWlkKS48ZGl2Pjxici8+RGUgcGl4ZWx3YWFyZGVuIGluIGhldCB1aXR2b2VyYXNwZWN0LWhlbGxpbmdzcmFzdGVyIHdlZXJzcGllZ2VsZW4gZWVuIGNvbWJpbmF0aWUgdmFuIGFzcGVjdCBlbiBoZWxsaW5nLiBQaXhlbHMgbWV0IHdhYXJkZW4gb25kZXIgMjAgd29yZGVuIGFscyBwbGF0IGJlc2Nob3V3ZCBlbiB3b3JkZW4gZ3JpanMgd2VlcmdlZ2V2ZW4uIEFzcGVjdC1oZWxsaW5nd2FhcmRlbiB2YW4gMjEgZW4gaG9nZXIgd29yZGVuIGFscyB2b2xndCB3ZWVyZ2VnZXZlbiBtZXQgdmFyacOrcmVuZGUgdmVyemFkaWdpbmc6IDIxIHRvdCAzMCDigJRMYWdlIGhlbGxpbmdzdmVyemFkaWdpbmcsIDMxIHRvdCA0MOKAlEdlbWlkZGVsZGUgaGVsbGluZ3N2ZXJ6YWRpZ2luZywgNDEgZW4gaG9nZXLigJRIb2dlIGhlbGxpbmdzdmVyemFkaWdpbmc8L2Rpdj5cIixcblx0XHRhc3BlY3ROYW1lOiBcIkFzcGVjdFwiLFxuXHRcdGFzcGVjdFNuaXA6IFwiR2VlZnQgYWFuIGluIHdlbGtlIHJpY2h0aW5nIGVlbiBwaXhlbCB3b3JkdCB3ZWVyZ2VnZXZlbiwgd2FhcmJpaiAwIHJpY2h0aW5nIGhldCBub29yZGVuIGxpZ3QgZW4gZGUgaG9la2VuIG1ldCBkZSBrbG9rIG1lZSB0b2VuZW1lbiB0b3QgMzYwLlwiLFxuXHRcdGFzcGVjdERlc2M6IFwiRGUgZnVuY3RpZSBBc3BlY3QgaWRlbnRpZmljZWVydCBkZSByaWNodGluZyBiZXJnYWZ3YWFydHMgdmFuIGRlIG1heGltYWxlIG1hdGUgdmFuIHZlcmFuZGVyaW5nIGluIHdhYXJkZSB2YW4gZWxrZSBjZWwgdG90IGRlIGJ1dXJjZWxsZW4uIEFzcGVjdCBrYW4gd29yZGVuIGdlemllbiBhbHMgZGUgaGVsbGluZ3JpY2h0aW5nLiBEZSB3YWFyZGVuIHZhbiBkZSB1aXR2b2VycmFzdGVyIHphbCBkZSBrb21wYXNyaWNodGluZyB2YW4gaGV0IGFzcGVjdCB6aWpuLjxkaXY+PGJyLz5EZSBpbnZvZXIgdm9vciBkZXplIGZ1bmN0aWUgaXMgSW52b2VycmFzdGVyLiBEZSBhc3BlY3RmdW5jdGllIHdvcmR0IHZhYWsgdG9lZ2VwYXN0IG9wIGVlbiBkaWdpdGFhbCBob29ndGVtb2RlbCAoREVNKS4gU3RhbmRhYXJkIHdvcmR0IGhldCBhc3BlY3Qgd2VlcmdlZ2V2ZW4gYWxzIGVlbiBncmlqc3dhYXJkZW5hZmJlZWxkaW5nLiBVIGt1bnQgZGUgZnVuY3RpZSBDb2xvcm1hcCB0b2V2b2VnZW4gb20gZWVuIGJlcGFhbGQga2xldXJlbnNjaGVtYSBvcCB0ZSBnZXZlbiBvZiBkZSBwZXJzb29uIGRpZSBoZXQgbW96YcOvZWsgYmVraWprdCwgdG9lc3RhYW4gZGUgc3ltYm9sb2dpZSBtZXQgemlqbiBlaWdlbiBrbGV1cmVuc2NoZW1hIHRlIHdpanppZ2VuLjwvZGl2PlwiLFxuXHRcdHRhYmxlTmFtZTogXCJBdHRyaWJ1dXR0YWJlbFwiLFxuXHRcdHRhYmxlU25pcDogXCJHZWJydWlrdCBlZW4gdGFiZWwgb20gZGUgd2FhcmRlbiBpbiBlZW4gZGF0YXNldCB0ZSBiZW5vZW1lbiBlbiB0ZSBzeW1ib2xpc2VyZW4uIEtvbG9tbWVuIHZvb3IgZGUgdGFiZWwgemlqbiBkb29yIGtvbW1hJ3MgZ2VzY2hlaWRlbjogUGl4ZWxWYWx1ZSwgQXR0cmlidXRlTmFtZSwgUmVkVmFsdWUsIEdyZWVuVmFsdWUsIEJsdWVWYWx1ZS5cIixcblx0XHR0YWJsZURlc2M6IFwiTWV0IGRlIGZ1bmN0aWUgQXR0cmlidXV0dGFiZWwga3VudCB1IGVlbiBhdHRyaWJ1dXR0YWJlbCBkZWZpbmnDq3JlbiBvbSBlZW4gbW96YcOvZWtkYXRhc2V0IG9mIHJhc3RlcmRhdGFzZXQgbWV0IMOpw6luIGJhbmQgdGUgc3ltYm9saXNlcmVuLiA8ZGl2Pjxici8+RGl0IGlzIGhhbmRpZyB3YW5uZWVyIHUgYWZiZWVsZGluZ2VuIHdpbHQgcHJlc2VudGVyZW4gZGllIGVlbiBjbGFzc2lmaWNhdGllIGhlYmJlbiBvbmRlcmdhYW4gdm9vciBsYW5kZ2VicnVpaywgem9hbHMgYm9zbGFuZCwgd2V0bGFuZHMsIGFra2VybGFuZCBlbiBzdGVkZWxpamsgZ2ViaWVkLiBBbHMgdXcgdGFiZWwgdmVsZGVuIG1ldCBkZSBuYW1lbiByb29kLCBncm9lbiBlbiBibGF1dyBiZXZhdCwgd29yZGVuIGRlIHdhYXJkZW4gaW4gZGllIHZlbGRlbiBvb2sgYWxzIGVlbiBrbGV1cmVuc2NoZW1hIGdlYnJ1aWt0IGJpaiBoZXQgcmVuZGVyZW4gdmFuIGRlIGFmYmVlbGRpbmcuPC9kaXY+XCIsXG5cdFx0YmFuZEFyaXRobWV0aWNOYW1lOiBcIkJhbmQgcmVrZW5rdW5kaWdcIixcblx0XHRiYW5kQXJpdGhtZXRpY1NuaXA6IFwiQmVyZWtlbnQgaW5kZXhlbiBtZXQgdm9vcmFmIGdlZGVmaW5pZWVyZGUgZm9ybXVsZXMgb2YgZWVuIGRvb3IgZGUgZ2VicnVpa2VyIGdlZGVmaW5pZWVyZGUgZXhwcmVzc2llLlwiLFxuXHRcdGJhbmRBcml0aG1ldGljRGVzYzogXCJEZSBmdW5jdGllIEJhbmQgcmVrZW5rdW5kaWcgdm9lcnQgZWVuIHJla2Vua3VuZGlnZSBiZXdlcmtpbmcgdWl0IG9wIGRlIGJhbmRlbiB2YW4gZWVuIHJhc3RlcmRhdGFzZXQuIFUga3VudCB2b29yYWYgZ2VkZWZpbmllZXJkZSBhbGdvcml0bWVuIGtpZXplbiBvZiB1IGt1bnQgdXcgZWlnZW4gZm9ybXVsZSBtZXQgw6nDqW4gcmVnZWwgaW52b2VyZW4uIERlIG9uZGVyc3RldW5kZSBvcGVyYXRvcnMgemlqbiAtLCArLCAvLCAqIGVuIHVuYXJ5IC0uXCIsXG5cdFx0dGhyZXNob2xkTmFtZTogXCJCaW5haXJlIGRyZW1wZWxcIixcblx0XHR0aHJlc2hvbGRTbmlwOiBcIk9yZ2FuaXNlZXJ0IGNvbnRpbnVlIGdlZ2V2ZW5zIGluIGRlIHZvb3Jncm9uZCBlbiBhY2h0ZXJncm9uZCBkb29yIGRlIGNvdmFyaWFudGllIHR1c3NlbiBkZSB0d2VlIGtsYXNzZW4gdGUgbWluaW1hbGlzZXJlbi5cIixcblx0XHR0aHJlc2hvbGREZXNjOiBcIldhbm5lZXIgZWVuIHJhc3RlcmRhdGFzZXQgZWVuIGJpbW9kYWxlIHZlcmRlbGluZyBoZWVmdCwgbWFha3QgZGV6ZSBmdW5jdGllIGVlbiBuaWV1dyByYXN0ZXIgZGF0IGRlIGdlZ2V2ZW5zIHZlcmRlZWx0IGluIHR3ZWUgYWZ6b25kZXJsaWprZSBrbGFzc2VuLiBIaWVybWVlIHdvcmR0IGVlbiBrbGFzc2UgbWV0IGVlbiBsYWdlIHdhYXJkZSB3ZWVyZ2VnZXZlbiBtZXQgendhcnRlIHBpeGVscyBlbiBlZW4ga2xhc3NlIG1ldCBlZW4gaG9nZSB3YWFyZGUgd2VlcmdlZ2V2ZW4gbWV0IHdpdHRlIHBpeGVscy5cIixcblx0XHRiaXR3aXNlQW5kTmFtZTogXCJCaXR3aXNlIGVuXCIsXG5cdFx0Yml0d2lzZUFuZFNuaXA6IFwiVm9lcnQgZWVuIEJpdHdpc2UgZW4tYmV3ZXJraW5nIHVpdCBvcCBkZSBiaW5haXJlIHdhYXJkZW4gdmFuIHR3ZWUgaW52b2VycmFzdGVycy5cIixcblx0XHRiaXR3aXNlQW5kRGVzYzogXCJCaXR3aXNlIGVuIHZvZXJ0IGVlbiBCaXR3aXNlIGVuLWJld2Vya2luZyB1aXQgb3AgZGUgYmluYWlyZSB3YWFyZGVuIHZhbiB0d2VlIGludm9lcnJhc3RlcnNcIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0TmFtZTogXCJCaXR3aXNlIHZlcnNjaHVpdmluZyBsaW5rc1wiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnRTbmlwOiBcIlZvZXJ0IGVlbiBCaXR3aXNlIHZlcnNjaHVpdmluZyBsaW5rcy1iZXdlcmtpbmcgdWl0IG9wIGRlIGJpbmFpcmUgd2FhcmRlbiB2YW4gdHdlZSBpbnZvZXJyYXN0ZXJzLlwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnREZXNjOiBcIkJpdHdpc2UgdmVyc2NodWl2aW5nIGxpbmtzIHZvZXJ0IGVlbiBCaXR3aXNlIHZlcnNjaHVpdmluZyBsaW5rcyBiZXdlcmtpbmcgdWl0IG9wIGRlIGJpbmFpcmUgd2FhcmRlbiB2YW4gdHdlZSBpbnZvZXJyYXN0ZXJzXCIsXG5cdFx0Yml0d2lzZU5vdE5hbWU6IFwiQml0d2lzZSBOb3RcIixcblx0XHRiaXR3aXNlTm90U25pcDogXCJWb2VydCBlZW4gQml0d2lzZSBOb3QgKGFhbnZ1bGxpbmcpLWJld2Vya2luZyB1aXQgb3AgZGUgYmluYWlyZSB3YWFyZGVuIHZhbiB0d2VlIGludm9lcnJhc3RlcnMuXCIsXG5cdFx0Yml0d2lzZU5vdERlc2M6IFwiRGUgZnVuY3RpZSB2b2VydCBlZW4gQml0d2lzZSBOb3QtYmV3ZXJraW5nIChhYW52dWxsaW5nKSB1aXQgb3AgZGUgYmluYWlyZSB3YWFyZGVuIHZhbiBlZW4gaW52b2VycmFzdGVyLlwiLFxuXHRcdGJpdHdpc2VPck5hbWU6IFwiQml0d2lzZSBvZlwiLFxuXHRcdGJpdHdpc2VPclNuaXA6IFwiVm9lcnQgZWVuIEJpdHdpc2Ugb2YtYmV3ZXJraW5nIHVpdCBvcCBkZSBiaW5haXJlIHdhYXJkZW4gdmFuIHR3ZWUgaW52b2VycmFzdGVycy5cIixcblx0XHRiaXR3aXNlT3JEZXNjOiBcIkRlIGZ1bmN0aWUgdm9lcnQgQml0d2lzZSBvZi1iZXdlcmtpbmcgdWl0IG9wIGRlIGJpbmFpcmUgd2FhcmRlbiB2YW4gdHdlZSBpbnZvZXJyYXN0ZXJzLiBcIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdE5hbWU6IFwiQml0d2lzZSB2ZXJzY2h1aXZpbmcgcmVjaHRzXCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnRTbmlwOiBcIlZvZXJ0IGVlbiBCaXR3aXNlIHZlcnNjaHVpdmluZyByZWNodHMtYmV3ZXJraW5nIHVpdCBvcCBkZSBiaW5haXJlIHdhYXJkZW4gdmFuIHR3ZWUgaW52b2VycmFzdGVycy5cIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdERlc2M6IFwiRGUgZnVuY3RpZSB2b2VydCBlZW4gQml0d2lzZSB2ZXJzY2h1aXZpbmcgcmVjaHRzLWJld2Vya2luZyB1aXQgb3AgZGUgYmluYWlyZSB3YWFyZGVuIHZhbiB0d2VlIGludm9lcnJhc3RlcnMuXCIsXG5cdFx0Yml0d2lzZVhvck5hbWU6IFwiQml0d2lzZSBYb2ZcIixcblx0XHRiaXR3aXNlWG9yU25pcDogXCJWb2VydCBlZW4gQml0d2lzZSBlWGNsdXNpdmUgT2YtYmV3ZXJraW5nIHVpdCBvcCBkZSBiaW5haXJlIHdhYXJkZW4gdmFuIHR3ZWUgaW52b2VycmFzdGVycy5cIixcblx0XHRiaXR3aXNlWG9yRGVzYzogXCJEZSBmdW5jdGllIHZvZXJ0IGVlbiBCaXR3aXNlIGVYY2x1c2l2ZSBPZi1iZXdlcmtpbmcgdWl0IG9wIGRlIGJpbmFpcmUgd2FhcmRlbiB2YW4gdHdlZSBpbnZvZXJyYXN0ZXJzXCIsXG5cdFx0Ym9vbGVhbkFuZE5hbWU6IFwiQm9vbGVhbiBlblwiLFxuXHRcdGJvb2xlYW5BbmRTbmlwOiBcIlZvZXJ0IGVlbiBCb29sZWFuIGVuLWJld2Vya2luZyB1aXQgb3AgZGUgY2Vsd2FhcmRlbiB2YW4gdHdlZSBpbnZvZXJyYXN0ZXJzLiBBbHMgYmVpZGUgaW52b2Vyd2FhcmRlbiB3YWFyIHppam4gKG5pZXQgbnVsKSwgaXMgZGUgdWl0dm9lcndhYXJkZSAxLiBBbHMgw6nDqW4gb2YgYmVpZGUgaW52b2VyZW4gbmlldCB3YWFyIHppam4gKG51bCksIGlzIGRlIHVpdHZvZXIgMC5cIixcblx0XHRib29sZWFuQW5kRGVzYzogXCJEZSBmdW5jdGllIHZvZXJ0IGVlbiBCb29sZWFuIGVuLWJld2Vya2luZyB1aXQgb3AgZGUgcGl4ZWx3YWFyZGVuIHZhbiB0d2VlIGluZ2FuZ2VuLiBBbHMgYmVpZGUgaW52b2Vyd2FhcmRlbiB3YWFyIHppam4gKG5pZXQgbnVsKSwgaXMgZGUgdWl0dm9lcndhYXJkZSAxLiBBbHMgw6nDqW4gb2YgYmVpZGUgaW52b2Vyd2FhcmRlbiBuaWV0IHdhYXIgemlqbiAobnVsKSwgaXMgZGUgdWl0dm9lcndhYXJkZSAwLiBcIixcblx0XHRib29sZWFuTm90TmFtZTogXCJCb29sZWFuIE5vdFwiLFxuXHRcdGJvb2xlYW5Ob3RTbmlwOiBcIlZvZXJ0IGVlbiBCb29sZWFuIE5vdC1iZXdlcmtpbmcgKGFhbnZ1bGxpbmcpIHVpdCBvcCBkZSBjZWx3YWFyZGVuIHZhbiBoZXQgaW52b2VycmFzdGVyLiBBbHMgZGUgaW52b2Vyd2FhcmRlbiB3YWFyIHppam4gKG5pZXQgbnVsKSwgaXMgZGUgdWl0dm9lcndhYXJkZSAwLiBBbHMgZGUgaW52b2Vyd2FhcmRlbiBuaWV0IHdhYXIgemlqbiAobnVsKSwgaXMgZGUgdWl0dm9lciAxLlwiLFxuXHRcdGJvb2xlYW5Ob3REZXNjOiBcIkRlIGZ1bmN0aWUgdm9lcnQgZWVuIEJvb2xlYW4gTm90LWJld2Vya2luZyAoYWFudnVsbGluZykgdWl0IG9wIGRlIHBpeGVsd2FhcmRlbiB2YW4gaGV0IGludm9lcnJhc3Rlci4gQWxzIGJlaWRlIGludm9lcndhYXJkZW4gd2FhciB6aWpuIChuaWV0IG51bCksIGlzIGRlIHVpdHZvZXJ3YWFyZGUgMC4gQWxzIGJlaWRlIGludm9lcndhYXJkZW4gbmlldCB3YWFyIHppam4gKG51bCksIGlzIGRlIHVpdHZvZXJ3YWFyZGUgMS5cIixcblx0XHRib29sZWFuT3JOYW1lOiBcIkJvb2xlYW4gb2ZcIixcblx0XHRib29sZWFuT3JTbmlwOiBcIlZvZXJ0IGVlbiBCb29sZWFuIE5vdC1iZXdlcmtpbmcgdWl0IG9wIGRlIGNlbHdhYXJkZW4gdmFuIGRlIHR3ZWUgaW52b2VycmFzdGVycy4gQWxzIMOpw6luIG9mIGJlaWRlIGludm9lcndhYXJkZW4gd2FhciB6aWpuIChuaWV0IG51bCksIGlzIGRlIHVpdHZvZXJ3YWFyZGUgMS4gQWxzIGJlaWRlIGludm9lcndhYXJkZW4gbmlldCB3YWFyIHppam4gKG51bCksIGlzIGRlIHVpdHZvZXIgMC5cIixcblx0XHRib29sZWFuT3JEZXNjOiBcIkRlIGZ1bmN0aWUgdm9lcnQgQm9vbGVhbiBOb3QtYmV3ZXJraW5nIHVpdCBvcCBkZSBjZWx3YWFyZGVuIHZhbiB0d2VlIGludm9lcnJhc3RlcnMuIEFscyDDqcOpbiBvZiBiZWlkZSBpbnZvZXJ3YWFyZGVuIHdhYXIgemlqbiAobmlldCBudWwpLCBpcyBkZSB1aXR2b2Vyd2FhcmRlIDEuIEFscyBiZWlkZSBpbnZvZXJ3YWFyZGVuIG5pZXQgd2FhciB6aWpuIChudWwpLCBpcyBkZSB1aXR2b2Vyd2FhcmRlIDAuXCIsXG5cdFx0Ym9vbGVhblhvck5hbWU6IFwiQm9vbGVhbiBYb2ZcIixcblx0XHRib29sZWFuWG9yU25pcDogXCJWb2VydCBlZW4gQm9vbGVhbiBlWGNsdXNpdmUgb2YtYmV3ZXJraW5nIHVpdCBvcCBkZSBjZWx3YWFyZGVuIHZhbiB0d2VlIGludm9lcnJhc3RlcnMuIEFscyDDqcOpbiBpbnZvZXJ3YWFyZGUgd2FhciBpcyAobmlldCBudWwpIGVuIGRlIGFuZGVyZSB3YWFyZGUgaXMgbmlldCB3YWFyIChudWwpLCBpcyBkZSB1aXR2b2VyIDEuIEFscyBiZWlkZSBpbnZvZXJ3YWFyZGVuIHdhYXIgb2YgbmlldCB3YWFyIHppam4sIGlzIGRlIHVpdHZvZXIgMC5cIixcblx0XHRib29sZWFuWG9yRGVzYzogXCJEZSBmdW5jdGllIHZvZXJ0IGVlbiBCb29sZWFuIG9mLWJld2Vya2luZyB1aXQgb3AgZGUgY2Vsd2FhcmRlbiB2YW4gdHdlZSBpbnZvZXJyYXN0ZXJzLiBBbHMgw6nDqW4gaW52b2Vyd2FhcmRlIHdhYXIgaXMgKG5pZXQgbnVsKSBlbiBkZSBhbmRlcmUgd2FhcmRlIGlzIG5pZXQgd2FhciAobnVsKSwgaXMgZGUgdWl0dm9lcndhYXJkZSAxLiBBbHMgYmVpZGUgaW52b2Vyd2FhcmRlbiB3YWFyIG9mIG5pZXQgd2FhciB6aWpuLCBpcyBkZSB1aXR2b2Vyd2FhcmRlIDAuXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJOYW1lOiBcIkdlYnVmZmVyZFwiLFxuXHRcdGJ1ZmZlcmVkUmFzdGVyU25pcDogXCJCdWZmZXJ0IGRlIGxhYXRzdCBiZW5hZGVyZGUgcGl4ZWxibG9rKGtlbikuXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJEZXNjOiBcIkRlIGZ1bmN0aWUgR2VidWZmZXJkIHdvcmR0IGdlYnJ1aWt0IG9tIGRlIHByZXN0YXRpZXMgdmFuIGNvbXBsZXhlIGZ1bmN0aWVrZXRlbnMgdGUgb3B0aW1hbGlzZXJlbi4gSGV0IHNsYWF0IGRlIHVpdHZvZXIgb3AgaW4gaGV0IGdlaGV1Z2VuIHZhbiBoZXQgZGVlbCB2YW4gZGUgZnVuY3RpZWtldGVuIGRhdCBlcnZvb3Iga29tdC4gPGRpdj48YnIvPlZvZWcgZGV6ZSBmdW5jdGllIHRvZSBpbiBkZSBGdW5jdGllLWVkaXRvciB3YWFyIHUgZGUgdWl0dm9lciB3aWx0IG9wc2xhYW4uPC9kaXY+XCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvck5hbWU6IFwiUmVrZW5tYWNoaW5lXCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvclNuaXA6IFwiQmVyZWtlbnQgZWVuIHJhc3RlciB2YW4gZWVuIG9wIHJhc3RlcnMgZ2ViYXNlZXJkZSByZWtlbmt1bmRpZ2UgZXhwcmVzc2llLlwiLFxuXHRcdHJhc3RlckNhbGN1bGF0b3JEZXNjOiBcIk1ldCBkZSBmdW5jdGllIFJla2VubWFjaGluZSBrdW50IHUgZXhwcmVzc2llcyBtYWtlbiBlbiB1aXR2b2VyZW4gZW4gZGV6ZSBvcG5lbWVuIGluIGZ1bmN0aWVrZXRlbnMuXCIsXG5cdFx0Y2VsbFN0YXRpc3RpY3NOYW1lOiBcIkNlbHN0YXRpc3RpZWtlblwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzU25pcDogXCJCZXJla2VudCBzdGF0aXN0aWVrZW4gcGVyIGNlbCB2YW4gbWVlcmRlcmUgcmFzdGVycy4gRGUgYmVzY2hpa2JhcmUgc3RhdGlzdGlla2VuIHppam46IG1lZXJkZXJoZWlkLCBtYXhpbXVtLCBnZW1pZGRlbGRlLCBtZWRpYWFuLCBtaW5pbXVtLCBtaW5kZXJoZWlkLCBwZXJjZW50aWVsLCBiZXJlaWssIHN0YW5kYWFyZGFmd2lqa2luZywgc29tIGVuIHZhcmnDq3RlaXQuXCIsXG5cdFx0Y2VsbFN0YXRpc3RpY3NEZXNjOiBcIkRlemUgZnVuY3RpZSBiZXJla2VudCBzdGF0aXN0aWVrZW4gdmFuIG1lZXJkZXJlIHJhc3RlcnMsIG9wIGVlbiBwaXhlbC1wZXItcGl4ZWwgYmFzaXMuIERlIGJlc2NoaWtiYXJlIHN0YXRpc3RpZWtlbiB6aWpuOiBtZWVyZGVyaGVpZCwgbWF4aW11bSwgZ2VtaWRkZWxkZSwgbWVkaWFhbiwgbWluaW11bSwgbWluZGVyaGVpZCwgYmVyZWlrLCBzdGFuZGFhcmRhZndpamtpbmcsIHNvbSBlbiB2YXJpw6t0ZWl0LlwiLFxuXHRcdGNsYXNzaWZ5TmFtZTogXCJDbGFzc2lmaWNlcmVuXCIsXG5cdFx0Y2xhc3NpZnlTbmlwOiBcIldpanN0IGVsa2UgcGl4ZWwgdG9lIGFhbiBlZW4ga2xhc3NlLiBWb2VnIGFhbnZ1bGxlbmRlIGdlZ2V2ZW5zIHRvZSwgem9hbHMgZWVuIGdlc2VnbWVudGVlcmRlIGFmYmVlbGRpbmcuXCIsXG5cdFx0Y2xhc3NpZnlEZXNjOiBcIkRlemUgcmFzdGVyZnVuY3RpZSBjbGFzc2lmaWNlZXJ0IGVlbiByYXN0ZXJkYXRhc2V0IG9wIGJhc2lzIHZhbiBlZW4gRXNyaSBDbGFzc2lmaWVyIERlZmluaXRpb24gKC5lY2QpLWJlc3RhbmQgZW4gcmFzdGVyZGF0YXNldGludm9lci4gSGV0IC5lY2QtYmVzdGFuZCBkYXQgd29yZHQgZ2VicnVpa3QgaW4gZGUgZnVuY3RpZSBDbGFzc2lmaWNlcmVuIGJldmF0IGFsbGUgaW5mb3JtYXRpZSB2b29yIGVlbiBzcGVjaWZpZWtlIGRhdGFzZXQgZW4gY2xhc3NpZmllciBlbiB3b3JkdCBnZWdlbmVyZWVyZCBkb29yIGRlIGNsYXNzaWZpY2F0aWV0b29scyB2b29yIHRyYWluaW5nZW4sIHpvYWxzIGRlIFRyYWluIFN1cHBvcnQgVmVjdG9yIE1hY2hpbmUgb2YgVHJhaW4gUmFuZG9tIFRyZWVzLXRvb2xzLlwiLFxuXHRcdGNsaXBOYW1lOiBcIkJpanNuaWpkZW5cIixcblx0XHRjbGlwU25pcDogXCJTdGVsdCBkZSBtYXRlIHZhbiBlZW4gcmFzdGVyIGluIG1ldCBiZWh1bHAgdmFuIGNvw7ZyZGluYXRlbiBvZiBlZW4gYW5kZXJlIGRhdGFzZXQuXCIsXG5cdFx0Y2xpcERlc2M6IFwiTWV0IGRlemUgZnVuY3RpZSB3b3JkdCBlZW4gcmFzdGVyIGJpamdlc25lZGVuIG1ldCBiZWh1bHAgdmFuIGVlbiByZWNodGhvZWtpZ2Ugdm9ybSB2b2xnZW5zIGRlIGdlZGVmaW5pZWVyZGUgZXh0ZW5zaWVzIG9mIHdvcmR0IGVlbiByYXN0ZXIgYmlqZ2VzbmVkZW4gaW4gZGUgdm9ybSB2YW4gZWVuIG9iamVjdGtsYXNzZSB2YW4gZWVuIGludm9lcnBvbHlnb29uLiBEZSB2b3JtIGRpZSBoZXQgYmlqc25pamRlbiBkZWZpbmllZXJ0LCBrYW4gZGUgcmVpa3dpamR0ZSB2YW4gaGV0IHJhc3RlciBiaWpzbmlqZGVuIG9mIGVlbiBnZWJpZWQgaW4gaGV0IHJhc3RlciBiaWpzbmlqZGVuLlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uTmFtZTogXCJLbGV1cm1vZGVsY29udmVyc2llXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25TbmlwOiBcIkNvbnZlcnRlZXJ0IGVlbiByYXN0ZXIgdmFuIFJHQiBuYWFyIEhTViBlbiBvbWdla2VlcmQuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25EZXNjOiBcIkRlIGZ1bmN0aWUgS2xldXJtb2RlbGNvbnZlcnNpZSBjb252ZXJ0ZWVydCBoZXQga2xldXJlbm1vZGVsIHZhbiBlZW4gYWZiZWVsZGluZyB2YW4gZGUgdGludC0sIHZlcnphZGlnaW5ncy0gZW4gd2FhcmRlIChIU1YpIG5hYXIgcm9vZCwgZ3JvZW4gZW4gYmxhdXcgKFJHQikgb2Ygb21nZWtlZXJkLjxkaXY+PGJyLz5EZXplIGZ1bmN0aWUga2FuIHdvcmRlbiBnZWJydWlrdCBpbiBlZW4gbW96YcOvZWtnZWdldmVuc3NldC48L2Rpdj5cIixcblx0XHRjb2xvcm1hcFRvUkdCTmFtZTogXCJDb2xvcm1hcCBuYWFyIFJHQlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JTbmlwOiBcIkNvbnZlcnRlZXJ0IGVlbiBzaW5nbGUtYmFuZCByYXN0ZXIgbWV0IGVlbiBDb2xvcm1hcCBuYWFyIGVlbiBkcmllYmFuZGVuIChyb29kLCBncm9lbiBlbiBibGF1dykgcmFzdGVyLlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JEZXNjOiBcIkRlemUgZnVuY3RpZSBjb252ZXJ0ZWVydCBlZW4gc2luZ2xlLWJhbmQgcmFzdGVyIG1ldCBlZW4gQ29sb3JtYXAgbmFhciBlZW4gZHJpZWJhbmRlbiAocm9vZCwgZ3JvZW4gZW4gYmxhdXcpIHJhc3Rlci48ZGl2Pjxici8+RGV6ZSBmdW5jdGllIGlzIGhhbmRpZyB3YW5uZWVyIHUgZWVuIGRyaWViYW5kc3Jhc3RlciBtb2V0IG1ha2VuIHZhbiBlZW4gZW5rZWxiYW5kcmFzdGVyIG1ldCBlZW4gYmlqYmVob3JlbmRlIENvbG9ybWFwLiBEZSB3YWFyZGVuIGluIGRlIENvbG9ybWFwIHdvcmRlbiBnZWJydWlrdCBvbSBlbGtlIHJvZGUsIGdyb2VuZSBlbiBibGF1d2UgYmFuZCB0ZSBtYWtlbi4gRGV6ZSBmdW5jdGllIGthbiB3b3JkZW4gZ2VicnVpa3QgaW4gZWVuIG1vemHDr2VrZ2VnZXZlbnNzZXQuPC9kaXY+XCIsXG5cdFx0Y29sb3JtYXBOYW1lOiBcIktsZXVybWFwXCIsXG5cdFx0Y29sb3JtYXBTbmlwOiBcIldpanppZ3QgcGl4ZWx3YWFyZGVuIG9tIGRlIHJhc3RlcmdlZ2V2ZW5zIHdlZXIgdGUgZ2V2ZW4gYWxzIGdyaWpzd2FhcmRlbi0gb2YgZWVuIHJvb2QsIGdyb2VuLCBibGF1dyAoUkdCKSAtYWZiZWVsZGluZywgZ2ViYXNlZXJkIG9wIGVlbiBDb2xvcm1hcCBvZiBrbGV1cnZlcmxvb3AuXCIsXG5cdFx0Y29sb3JtYXBEZXNjOiBcIkRlIGZ1bmN0aWUgQ29sb3JtYXAgaXMgZWVuIHR5cGUgcmFzdGVyZGF0YS1yZW5kZXJlci4gSGV0IHRyYW5zZm9ybWVlcnQgZGUgcGl4ZWx3YWFyZGVuIG9tIGRlIHJhc3RlcmRhdGEgd2VlciB0ZSBnZXZlbiBhbHMgZWVuIGdyaWpzc2NoYWFsIG9mIGVlbiBSR0Ita2xldXJlbmFmYmVlbGRpbmcgb3AgYmFzaXMgdmFuIGVlbiBrbGV1cmVuc2NoZW1hIG9mIHNwZWNpZmlla2Uga2xldXJlbiBpbiBlZW4gQ29sb3JtYXBiZXN0YW5kLiBVIGt1bnQgZWVuIENvbG9ybWFwIGdlYnJ1aWtlbiBvbSBnZWFuYWx5c2VlcmRlIGdlZ2V2ZW5zIHdlZXIgdGUgZ2V2ZW4sIHpvYWxzIGVlbiBnZWNsYXNzaWZpY2VlcmRlIGFmYmVlbGRpbmcgb2YgYmlqIGhldCB3ZWVyZ2V2ZW4gdmFuIGVlbiB0b3BvZ3JhZmlzY2hlIGthYXJ0IChvZiBlZW4gaW5kZXhrbGV1cmdlc2NhbmRlIGFmYmVlbGRpbmcpLjxkaXY+PGJyLz5Db2xvcm1hcHMgYmV2YXR0ZW4gZWVuIHJlZWtzIHdhYXJkZW4gZGllIHppam4gZ2Vrb3BwZWxkIGFhbiBrbGV1cmVuIGRpZSB3b3JkZW4gZ2VicnVpa3Qgb20gZWVuIGVua2VsYmFuZHJhc3RlciBjb25zaXN0ZW50IHdlZXIgdGUgZ2V2ZW4gbWV0IGRlemVsZmRlIGtsZXVyZW4uIEVsa2UgcGl4ZWx3YWFyZGUgaXMgZ2Vrb3BwZWxkIGFhbiBlZW4ga2xldXIsIGdlZGVmaW5pZWVyZCBhbHMgZWVuIHJlZWtzIFJHQi13YWFyZGVuLiBDb2xvcm1hcHMga3VubmVuIGVsa2UgYml0ZGllcHRlIG9uZGVyc3RldW5lbiwgYmVoYWx2ZSB6d2V2ZW5kZSBrb21tYS4gWmUgb25kZXJzdGV1bmVuIG9vayBwb3NpdGlldmUgZW4gbmVnYXRpZXZlIHdhYXJkZW4gZW4ga3VubmVuIENvbG9ybWFwcyBtZXQgb250YnJla2VuZGUgd2FhcmRlbiBiZXZhdHRlbi4gQmlqIGhldCB3ZWVyZ2V2ZW4gdmFuIGVlbiBkYXRhc2V0IG1ldCBlZW4gQ29sb3JtYXAgbWV0IG9udGJyZWtlbmRlIHdhYXJkZW4sIHdvcmRlbiBkZSBwaXhlbHMgbWV0IGRpZSBvbnRicmVrZW5kZSB3YWFyZGVuIG5pZXQgd2VlcmdlZ2V2ZW4uPC9kaXY+XCIsXG5cdFx0Y29tcGxleE5hbWU6IFwiQ29tcGxleFwiLFxuXHRcdGNvbXBsZXhTbmlwOiBcIkhhYWx0IGRlIGdyb290dGUgdWl0IGNvbXBsZXhlIGdldGFsbGVuLlwiLFxuXHRcdGNvbXBsZXhEZXNjOiBcIkRlemUgZnVuY3RpZSBiZXJla2VudCBkZSBncm9vdHRlIHZhbiBjb21wbGV4ZSB3YWFyZGVuLjxkaXY+PGJyLz5EZXplIGZ1bmN0aWUgd29yZHQgbWVlc3RhbCBnZWJydWlrdCBiaWogUkFEQVItYmVlbGRlbiBtZXQgZWVuIGNvbXBsZXggZGF0YXR5cGUuIEthbiB3b3JkZW4gZ2VicnVpa3QgaW4gZWVuIG1vemHDr2VrZ2VnZXZlbnNzZXQuPC9kaXY+XCIsXG5cdFx0Y29tcG9zaXRlQmFuZE5hbWU6IFwiU2FtZW5nZXN0ZWxkZSBiYW5kZW5cIixcblx0XHRjb21wb3NpdGVCYW5kU25pcDogXCJDb21iaW5lZXJ0IG1lZXJkZXJlIGRhdGFzZXRzIGluIGVlbiBtdWx0aWJhbmQtcmFzdGVyLlwiLFxuXHRcdGNvbXBvc2l0ZUJhbmREZXNjOiBcIk1ldCBkZSBmdW5jdGllIFNhbWVuZ2VzdGVsZGUgYmFuZGVuIGt1bnQgdSByYXN0ZXJzIGNvbWJpbmVyZW4gb20gZWVuIG11bHRpYmFuZC1hZmJlZWxkaW5nIHRlIHZvcm1lbi5cIixcblx0XHRjb25OYW1lOiBcIlZvb3J3YWFyZGVsaWprXCIsXG5cdFx0Y29uU25pcDogXCJWb2VydCBlZW4gdm9vcndhYXJkZWxpamtlIGFscywgZGFuLCBhbmRlcmUtYmV3ZXJraW5nIHVpdC4gV2FubmVlciBlZW4gVm9vcndhYXJkZWxpamtlIG9wZXJhdG9yIHdvcmR0IGdlYnJ1aWt0LCBtb2V0ZW4gZXIgZ2V3b29ubGlqayB0d2VlIG9mIG1lZXIgYWFuZWVuZ2Vrb3BwZWxkZSBmdW5jdGllcyB6aWpuLCB3YWFyYmlqIMOpw6luIGZ1bmN0aWUgZGUgY3JpdGVyaWEgdmVybWVsZHQgZW4gZGUgdHdlZWRlIGZ1bmN0aWUgZGUgVm9vcndhYXJkZWxpamtlIG9wZXJhdG9yIGlzIGRpZSBkZSBjcml0ZXJpYSBnZWJydWlrdCBlbiBkaWN0ZWVydCB3YXQgZGUgd2FyZSBlbiBvbndhcmUgdWl0dm9lciB6b3UgbW9ldGVuIHppam4uXCIsXG5cdFx0Y29uRGVzYzogXCJEZSBmdW5jdGllIFZvb3J3YWFyZGVsaWprIHN0ZWx0IGRlIHBpeGVscyB2YW4gaGV0IHVpdHZvZXJyYXN0ZXIgaW4gb3AgYmFzaXMgdmFuIGVlbiBhbHNcXFxcZGFuLWV2YWx1YXRpZSB2YW4gZWxrZSBpbnZvZXJwaXhlbC4gSGV0IHJldG91cm5lZXJ0IHBpeGVsd2FhcmRlbiB2YW4gaGV0IHdhcmUgcmFzdGVyIGFscyBkZSB2b29yd2FhcmRlbGlqa2UgZXZhbHVhdGllIHdhYXIgaXMgKDEpIG9mIHJldG91cm5lZXJ0IGRlIHBpeGVsd2FhcmRlbiB2YW4gaGV0IG9ud2FyZSByYXN0ZXIgYWxzIGRlIHZvb3J3YWFyZGVsaWprZSBldmFsdWF0aWUgb253YWFyIGlzICgwKS4gRGl0IGNyaXRlcml1bSB3b3JkdCBnZXNwZWNpZmljZWVyZCBkb29yIGRlIHVpdHZvZXIgdmFuIGVlbiBsb2dpc2NoZSByZWtlbmt1bmRpZ2UgZnVuY3RpZSwgZGllIGhldCBpbnZvZXJyYXN0ZXIgemFsIHppam4uXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIkNvbnN0YW50ZVwiLFxuXHRcdGNvbnN0YW50U25pcDogXCJDcmXDq2VydCBlZW4gdmlydHVlZWwgcmFzdGVyIG1ldCBlZW4gd2FhcmRlIHZhbiDDqcOpbiBwaXhlbC5cIixcblx0XHRjb25zdGFudERlc2M6IFwiTWV0IGRlemUgZnVuY3RpZSB3b3JkdCBlZW4gdmlydHVlZWwgcmFzdGVyIGdlbWFha3QgbWV0IGVlbiB3YWFyZGUgdmFuIMOpw6luIHBpeGVsIGRpZSBrYW4gd29yZGVuIGdlYnJ1aWt0IGluIHJhc3RlcmZ1bmN0aWV0ZW1wbGF0ZXMgZW4gb20gZWVuIG1vemHDr2VrZGF0YXNldCB0ZSB2ZXJ3ZXJrZW4uPGRpdj48YnIvPkRlIGNvbnN0YW50ZSB3YWFyZGUgd29yZHQgZ2VicnVpa3Qgdm9vciBlbGtlIHBpeGVsd2FhcmRlIGluIGhldCByYXN0ZXIuPC9kaXY+XCIsXG5cdFx0Y29udG91ck5hbWU6IFwiQ29udG91clwiLFxuXHRcdGNvbnRvdXJTbmlwOiBcIk1hYWt0IGNvbnRvdXJsaWpuZW4uXCIsXG5cdFx0Y29udG91ckRlc2M6IFwiRGUgZnVuY3RpZSBDb250b3VyIGdlbmVyZWVydCBjb250b3VybGlqbmVuIGRvb3IgcHVudGVuIHNhbWVuIHRlIHZvZWdlbiBtZXQgZGV6ZWxmZGUgaG9vZ3RlIHRlbiBvcHppY2h0ZSB2YW4gZWVuIHJhc3Rlcmhvb2d0ZWRhdGFzZXQuIERlIGNvbnRvdXJlbiB6aWpuIGlzb2xpam5lbiBkaWUgemlqbiBnZW1hYWt0IGFscyByYXN0ZXJzIHZvb3IgdmlzdWFsaXNhdGllLiBEZSB2b2xnZW5kZSBiZWxhbmdyaWprZSBlaWdlbnNjaGFwcGVuIG1ha2VuIGRlemUgZnVuY3RpZSBrcmFjaHRpZzogY29udG91cmVuIHdvcmRlbiBzbmVsIGVuIGR5bmFtaXNjaCBnZWdlbmVyZWVyZCBvcCB6ZWVyIGdyb3RlIGRhdGFyZWVrc2VuLCB6b2FscyBkZSBXb3JsZCBFbGV2YXRpb247IGNvbnRvdXJlbiBrdW5uZW4gZ2xhZCB3b3JkZW4gZ2VtYWFrdCB2b29yIGVlbiBjYXJ0b2dyYWZpc2NoIG1vb2llciB1aXRlcmxpamsgbWV0IGJlaG91ZCB2YW4gZGUgbmF1d2tldXJpZ2hlaWQgdmFuIGRlIGNvbnRvdXJlbjsgZHluYW1pc2NoZSBjb250cm9sZSBvdmVyIGRlIGNvbnRvdXJpbnRlcnZhbCBpcyBhYW53ZXppZzsgdWl0dm9lcm9wdGllcyBvbXZhdHRlbiBjb250b3VybGlqbmVuLCBpbmRleGNvbnRvdXJlbiBlbiBnZXZ1bGRlIGNvbnRvdXJlbi48ZGl2Pjxici8+SGV0IG1ha2VuIHZhbiBlZW4gY29udG91cmxhYWcgYWxzIGVlbiByYXN0ZXJwcm9kdWN0IGlzIHdhYXJkZXZvbCB2b29yIGVlbiBicmVlZCBzY2FsYSBhYW4gdG9lcGFzc2luZ2VuLCBvbWRhdCBkZSBjb250b3VyZW4gb3AgZWVuIGthYXJ0IGt1bm5lbiB3b3JkZW4gZ2VsZWdkIGVuIGluZm9ybWF0aWUgb3ZlciBoZXQgdGVycmVpbiBrdW5uZW4gdmVyc2NoYWZmZW4gem9uZGVyIGRlIG9uZGVybGlnZ2VuZGUgZ2VnZXZlbnMgdGUgdmVyYmVyZ2VuLiBaZSB6aWpuIG51dHRpZyBpbiB0b2VwYXNzaW5nZW4gem9hbHMgdGVjaG5pZWssIGxhbmRib3V3IGVuIHdhdGVyYmVoZWVyLjwvZGl2PlwiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc05hbWU6IFwiQ29udHJhc3QgZW4gaGVsZGVyaGVpZFwiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc1NuaXA6IFwiUGFzdCBoZXQgY29udHJhc3QgZW4gZGUgaGVsZGVyaGVpZCB2YW4gZWVuIHJhc3RlciBhYW4uXCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzRGVzYzogXCJEZSBmdW5jdGllIENvbnRyYXN0IGVuIGhlbGRlcmhlaWQgdmVyYmV0ZXJ0IGRlIHdlZXJnYXZlIHZhbiByYXN0ZXJkYXRhIGRvb3IgZGUgaGVsZGVyaGVpZCBlbiBoZXQgY29udHJhc3QgaW4gaGV0IGJlZWxkIGFhbiB0ZSBwYXNzZW4uIEhlbGRlcmhlaWQgdmVyaG9vZ3QgYmlqdm9vcmJlZWxkIGRlIHRvdGFsZSBsaWNodGhlaWQgdmFuIGRlIGFmYmVlbGRpbmfigJRiaWp2b29yYmVlbGQsIHdhYXJkb29yIGRvbmtlcmUga2xldXJlbiBsaWNodGVyIGVuIGxpY2h0ZXJlIGtsZXVyZW4gd2l0dGVy4oCUd29yZGVuIHRlcndpamwgY29udHJhc3QgaGV0IHZlcnNjaGlsIHR1c3NlbiBkZSBkb25rZXJzdGUgZW4gbGljaHRzdGUga2xldXJlbiBhYW5wYXN0LjxkaXY+PGJyLz5NZXQgZGV6ZSBmdW5jdGllIHdvcmRlbiBkZSBwaXhlbHdhYXJkZW4gZ2V3aWp6aWdkOyBkYXJvbSBtb2V0IGRlemUgZnVuY3RpZSB3b3JkZW4gZ2VicnVpa3QgYWxzIHUgZGUgd2VlcmdhdmUgdmFuIGRlIGdlZ2V2ZW5zIHdpbHQgdmVyYmV0ZXJlbiBlbiBuaWV0IGFscyB1IGRlIGdlZ2V2ZW5zIHdpbHQgZ2VicnVpa2VuIGFscyBvbmRlcmRlZWwgdmFuIGVlbiBhbmFseXNlIHdhYXJ2b29yIGRlIG9uYmV3ZXJrdGUgcGl4ZWx3YWFyZGVuIG1vZXRlbiB3b3JkZW4gZ2VicnVpa3QuIERlemUgZnVuY3RpZSBpcyBoYW5kaWcgd2FubmVlciB1IGRlIGdlZ2V2ZW5zIHB1YmxpY2VlcnQgYWxzIGVlbiBhZmJlZWxkaW5nc3NlcnZpY2UgZGllIGluIHRvZXBhc3NpbmdlbiBrYW4gd29yZGVuIGdlYnJ1aWt0IHpvbmRlciBkYXQgdSBoZXQgY29udHJhc3QgZW4gZGUgaGVsZGVyaGVpZCB2YW4gZGUgYWZiZWVsZGluZyBrdW50IHdpanppZ2VuIG9mIG9tIGVydm9vciB0ZSB6b3JnZW4gZGF0IGRlemUgd29yZHQgd2VlcmdlZ2V2ZW4gbWV0IGRlIGluc3RlbGxpbmdlbiB2YW4gdXcgdm9vcmtldXIuPC9kaXY+XCIsXG5cdFx0Y29udm9sdXRpb25OYW1lOiBcIkNvbnZvbHV0aWVcIixcblx0XHRjb252b2x1dGlvblNuaXA6IFwiUGFzdCBlZW4gZmlsdGVyIHRvZSBvbSB0ZSB2ZXJzY2hlcnBlbiwgdmVydmFnZW4sIHJhbmRlbiB0ZSBkZXRlY3RlcmVuLCB2bG9laWVuZCB0ZSBtYWtlbiBvZiB2b29yIGVlbiB2ZXJsb29wIG92ZXIgZWVuIHJhc3Rlci5cIixcblx0XHRjb252b2x1dGlvbkRlc2M6IFwiRGUgZnVuY3RpZSBDb252b2x1dGllIHZvZXJ0IGZpbHRlcmluZyB1aXQgb3AgZGUgcGl4ZWx3YWFyZGVuIGluIGVlbiBhZmJlZWxkaW5nLCBkaWUga2FuIHdvcmRlbiBnZWJydWlrdCB2b29yIGhldCB2ZXJzY2hlcnBlbiB2YW4gZWVuIGFmYmVlbGRpbmcsIHZlcnZhZ2luZyB2YW4gZWVuIGFmYmVlbGRpbmcsIGhldCBkZXRlY3RlcmVuIHZhbiByYW5kZW4gaW4gZWVuIGFmYmVlbGRpbmcgb2YgYW5kZXJlIG9wIGtlcm5lbCBnZWJhc2VlcmRlIHZlcmJldGVyaW5nZW4uIEZpbHRlcnMgd29yZGVuIGdlYnJ1aWt0IG9tIGRlIGt3YWxpdGVpdCB2YW4gZGUgcmFzdGVyYWZiZWVsZGluZyB0ZSB2ZXJiZXRlcmVuIGRvb3Igb25qdWlzdGUgZ2VnZXZlbnMgdGUgdmVyd2lqZGVyZW4gb2YgZnVuY3RpZXMgaW4gZGUgZ2VnZXZlbnMgdGUgdmVyYmV0ZXJlbi4gRGV6ZSBjb252b2x1dGllZmlsdGVycyB3b3JkZW4gdG9lZ2VwYXN0IG9wIGVlbiBiZXdlZ2VuZGUsIGVsa2FhciBvdmVybGFwcGVuZGUga2VybmVsICh2ZW5zdGVyIG9mIGJ1dXJ0KSwgem9hbHMgMyBiaWogMy4gQ29udm9sdXRpZWZpbHRlcnMgYmVyZWtlbmVuIGRlIHBpeGVsd2FhcmRlIG9wIGJhc2lzIHZhbiBoZXQgZ2V3aWNodCB2YW4gZGUgYnVyZW4uXCIsXG5cdFx0Y29ycmlkb3JOYW1lOiBcIkNvcnJpZG9yXCIsXG5cdFx0Y29ycmlkb3JTbmlwOiBcIkJlcmVrZW50IGRlIHNvbSB2YW4gZGUgY3VtdWxhdGlldmUga29zdGVuIHZvb3IgdHdlZSBhY2N1bW11bGF0aWV2ZSBpbnZvZXJyYXN0ZXJzLlwiLFxuXHRcdGNvcnJpZG9yRGVzYzogXCJEZSBmdW5jdGllIENvcnJpZG9yIGJlcmVrZW50IGRlIHNvbSB2YW4gZGUgY3VtdWxhdGlldmUga29zdGVuIHZvb3IgdHdlZSBhY2N1bW11bGF0aWV2ZSBrb3N0ZW5pbnZvZXJyYXN0ZXJzLiBIb2V3ZWwgZXIgdHdlZSByYXN0ZXJzIHZvb3IgZGUgaW52b2VyIGt1bm5lbiB3b3JkZW4gZ2VicnVpa3QsIG1vZXRlbiBoZXQgb20gZWVuIHppbnZvbCByZXN1bHRhYXQgdGUga3Jpamdlbiwgb25nZXdpanppZ2RlIGFjY3VtdWxhdGlldmUga29zdGVudWl0dm9lcnJhc3RlcnMgemlqbi4gRGUgdm9sZ29yZGUgdmFuIGRlIHR3ZWUgaW52b2VyZW4gaXMgbmlldCByZWxldmFudC5cIixcblx0XHRjb3NITmFtZTogXCJDb3NIXCIsXG5cdFx0Y29zSFNuaXA6IFwiQmVyZWtlbnQgZGUgaHlwZXJib2xlIGNvc2ludXMgdmFuIGNlbGxlbiBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGNvc0hEZXNjOiBcIkRlIGZ1bmN0aWUgYmVyZWtlbnQgZGUgaHlwZXJib2xlIGNvc2ludXMgdmFuIGRlIHBpeGVscyBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGNvc05hbWU6IFwiQ29zXCIsXG5cdFx0Y29zU25pcDogXCJCZXJla2VudCBkZSBjb3NpbnVzIHZhbiBlZW4gY2VsIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0Y29zRGVzYzogXCJEZSBmdW5jdGllIGJlcmVrZW50IGRlIGNvc2ludXMgdmFuIGRlIHBpeGVscyBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uTmFtZTogXCJLb3N0ZW50b2V3aWp6aW5nXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25TbmlwOiBcIkJlcmVrZW50IHZvb3IgZWxrZSBjZWwgZGUgYnJvbiBtZXQgZGUgbGFhZ3N0ZSBrb3N0ZW4gb3AgYmFzaXMgdmFuIGRlIG1pbnN0IGN1bXVsYXRpZXZlIGtvc3RlbiBvdmVyIGVlbiBrb3N0ZW5vcHBlcnZsYWsuXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25EZXNjOiBcIkRlIGZ1bmN0aWUgS29zdGVudG9ld2lqemluZyBiZXJla2VudCB2b29yIGVsa2UgY2VsIGRlIGJyb24gbWV0IGRlIGxhYWdzdGUga29zdGVuIG9wIGJhc2lzIHZhbiBkZSBtaW5zdCBjdW11bGF0aWV2ZSBrb3N0ZW4gb3ZlciBlZW4ga29zdGVub3BwZXJ2bGFrLlwiLFxuXHRcdGNvc3RCYWNrTGlua05hbWU6IFwiQ29zdCBCYWNrIExpbmtcIixcblx0XHRjb3N0QmFja0xpbmtTbmlwOiBcIkRlZmluaWVlcnQgZGUgYnV1ciBkaWUgZGUgdm9sZ2VuZGUgY2VsIGlzIG9wIGhldCBtaW5zdCBhY2N1bXVsYXRpZXZlIGtvc3RlbnBhZCBuYWFyIGRlIGJyb24gbWV0IGRlIG1pbnN0ZSBrb3N0ZW4uXCIsXG5cdFx0Y29zdEJhY2tMaW5rRGVzYzogXCJEZSBmdW5jdGllIENvc3QgQmFjayBMaW5rIGRlZmluaWVlcnQgZGUgdm9sZ2VuZGUgYWFuZ3JlbnplbmRlIGNlbCBvcCBoZXQgbWluc3QgYWNjdW11bGF0aWV2ZSBrb3N0ZW5wYWQgbmFhciBkZSBicm9uIG1ldCBkZSBtaW5zdGUga29zdGVuLjxkaXY+PGJyLz5IZXQgcmFzdGVyIHZhbiBkZSBiYWNrIGxpbmsgYmV2YXQgd2FhcmRlbiB2YW4gbnVsIHRvdCBlbiBtZXQgYWNodCBkaWUgZGUgcmljaHRpbmcgYmVwYWxlbiBvZiBkZSB2b2xnZW5kZSBhYW5ncmVuemVuZGUgY2VsIChkZSB2b2xnZW5kZSBjZWwpIGlkZW50aWZpY2VyZW4gbGFuZ3MgaGV0IG1pbnN0IGFjY3VtdWxhdGlldmUga29zdGVucGFkIHZhbiBlZW4gY2VsIG9tIGRlIGJyb24gbWV0IGRlIG1pbnN0ZSBrb3N0ZW4gdGUgYmVyZWlrZW4uIEFscyBoZXQgcGFkIG5hYXIgZGUgcmVjaHRlcmJ1dXIgbW9ldCBnYWFuLCBrcmlqZ3QgZGUgY2VsIGRlIHdhYXJkZSAxLCAyIHZvb3IgZGUgZGlhZ29uYWxlIGNlbCByZWNodHNvbmRlciBlbiBnYWF0IGRlemUgbWV0IGRlIGtsb2sgbWVlIHZlcmRlci4gRGUgd2FhcmRlIDAgaXMgZ2VyZXNlcnZlZXJkIHZvb3IgYnJvbmNlbGxlbi48L2Rpdj5cIixcblx0XHRjb3N0RGlzdGFuY2VOYW1lOiBcIktvc3RlbmFmc3RhbmRcIixcblx0XHRjb3N0RGlzdGFuY2VTbmlwOiBcIkJlcmVrZW50IGRlIGxhYWdzdGUgY3VtdWxhdGlldmUga29zdGVuYWZzdGFuZCB2b29yIGVsa2UgY2VsIHZhbiBvZiBuYWFyIGRlIGJyb24gbWV0IGRlIGxhYWdzdGUga29zdGVuIG92ZXIgZWVuIGtvc3Rlbm9wcGVydmxhay5cIixcblx0XHRjb3N0RGlzdGFuY2VEZXNjOiBcIkRlIGZ1bmN0aWUgS29zdGVuYWZzdGFuZCBiZXJla2VudCBkZSBrbGVpbnN0ZSBjdW11bGF0aWV2ZSBrb3N0ZW5hZnN0YW5kIHZvb3IgZWxrZSBjZWwgdmFuIG9mIG5hYXIgZGUgYnJvbiBtZXQgZGUgbGFhZ3N0ZSBrb3N0ZW4gb3ZlciBlZW4ga29zdGVub3BwZXJ2bGFrLlwiLFxuXHRcdGNvc3RQYXRoTmFtZTogXCJLb3N0ZW5wYWRcIixcblx0XHRjb3N0UGF0aFNuaXA6IFwiQmVyZWtlbnQgaGV0IHBhZCBtZXQgZGUgbWluc3RlIGtvc3RlbiB2YW4gZWVuIGJyb24gbmFhciBlZW4gYmVzdGVtbWluZy5cIixcblx0XHRjb3N0UGF0aERlc2M6IFwiRGUgZ2xvYmFsZSBmdW5jdGllIEtvc3RlbnBhZCBiZXJla2VudCBoZXQgcGFkIG1ldCBkZSBsYWFnc3RlIGtvc3RlbiB2YW4gZWVuIGJyb24gbmFhciBlZW4gYmVzdGVtbWluZy48ZGl2Pjxici8+RGV6ZSBmdW5jdGllIHByb2R1Y2VlcnQgZWVuIHVpdHZvZXJyYXN0ZXIgd2Fhcm1lZSBoZXQgcGFkIG1ldCBkZSBtaW5zdGUga29zdGVuIG9mIHBhZGVuIHZhbiBnZXNlbGVjdGVlcmRlIGxvY2F0aWVzIG5hYXIgZGUgZGljaHRzdGJpanppam5kZSBicm9uY2VsIHdvcmRlbiB2YXN0Z2VsZWdkIGJpbm5lbiBoZXQgZ2VhY2N1bXVsZWVyZGUga29zdGVub3BwZXJ2bGFrLCBpbiB0ZXJtZW4gdmFuIGtvc3RlbmFmc3RhbmQuPC9kaXY+XCIsXG5cdFx0Y3VydmF0dXJlTmFtZTogXCJLcm9tbWluZ1wiLFxuXHRcdGN1cnZhdHVyZVNuaXA6IFwiQmVyZWtlbnQgZGUga3JvbW1pbmcgdmFuIGVlbiByYXN0ZXJvcHBlcnZsYWssIG9wdGlvbmVlbCBpbmNsdXNpZWYgcHJvZmllbCBlbiB2bGFra3JvbW1pbmcuXCIsXG5cdFx0Y3VydmF0dXJlRGVzYzogXCJEZSBmdW5jdGllIEtyb21taW5nIGdlZWZ0IGRlIHZvcm0gb2Yga3JvbW1pbmcgdmFuIGRlIGhlbGxpbmcgd2Vlci4gRWVuIGRlZWwgdmFuIGVlbiBvcHBlcnZsYWsga2FuIGhvbCBvZiBib2wgemlqbjsgZGF0IGlzIHRlIHppZW4gYWFuIGRlIGtyb21taW5nc3dhYXJkZS4gRGUga3JvbW1pbmcgd29yZHQgYmVyZWtlbmQgZG9vciBkZSB0d2VlZGUgYWZnZWxlaWRlIHZhbiBoZXQgb3BwZXJ2bGFrIHRlIGJlcmVrZW5lbi48ZGl2Pjxici8+RGUgdWl0dm9lciB2YW4gZGUga3JvbW1pbmdzZnVuY3RpZSBrYW4gd29yZGVuIGdlYnJ1aWt0IG9tIGRlIGZ5c2lla2Uga2VubWVya2VuIHZhbiBlZW4gZHJhaW5hZ2ViZWtrZW4gdGUgYmVzY2hyaWp2ZW4gb20gZXJvc2llLSBlbiBhZnZvZXJwcm9jZXNzZW4gdGUgYmVncmlqcGVuLiBEZSBrcm9tbWluZ3N3YWFyZGUga2FuIHdvcmRlbiBnZWJydWlrdCBvbSBib2RlbWVyb3NpZXBhdHJvbmVuIHRlIHpvZWtlbiBvZiBkZSB2ZXJkZWxpbmcgdmFuIHdhdGVyIG9wIGhldCBsYW5kLiBEZSBwcm9maWVsa3JvbW1pbmcgYmXDr252bG9lZHQgZGUgdmVyc25lbGxpbmcgZW4gdmVydHJhZ2luZyB2YW4gZGUgc3Ryb21pbmcgZW4gYmXDr252bG9lZHQgZGFhcm1lZSBkZSBlcm9zaWUgZW4gYWZ6ZXR0aW5nLiBEZSBrcm9tbWluZyB2YW4gZGUgdmxha2tlIHZvcm0gYmXDr252bG9lZHQgZGUgY29udmVyZ2VudGllIGVuIGRpdmVyZ2VudGllIHZhbiBkZSBzdHJvbWluZy48L2Rpdj5cIixcblx0XHRkaXZpZGVOYW1lOiBcIkRlbGVuIGRvb3JcIixcblx0XHRkaXZpZGVTbmlwOiBcIlZlcmRlZWx0IGRlIHdhYXJkZW4gdmFuIHR3ZWUgcmFzdGVycyBvcCBlZW4gY2VsLXZvb3ItY2VsIGJhc2lzLlwiLFxuXHRcdGRpdmlkZURlc2M6IFwiRGUgZnVuY3RpZSBEZWxlbiBkb29yIGRlZWx0IGRlIHdhYXJkZW4gdmFuIHR3ZWUgcmFzdGVycyBvcCBlZW4gcGl4ZWwtdm9vci1waXhlbCBiYXNpcy5cIixcblx0XHRlbGV2YXRpb25Wb2lkRmlsbE5hbWU6IFwiRWxldmF0aW9uIFZvaWQgRmlsbFwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsU25pcDogXCJDcmXDq2VydCBwaXhlbHMgd2FhciBnYXRlbiB2b29ya29tZW4gaW4gdXcgaG9vZ3RlZ2VnZXZlbnMuXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxEZXNjOiBcIkRlIGZ1bmN0aWUgRWxldmF0aW9uIFZvaWQgRmlsbCB3b3JkdCBnZWJydWlrdCBvbSBwaXhlbHMgdGUgY3Jlw6tyZW4gd2FhciBnYXRlbiB2b29ya29tZW4gaW4gdXcgaG9vZ3RlZ2VnZXZlbnMuPGRpdj48YnIvPkdhdGVuIHRyZWRlbiBvcCB3YW5uZWVyIGVyIGdlZW4gdmVyemFtZWxkZSBwdW50ZW4gemlqbiBiaW5uZW4gaGV0IGdlYmllZCBkYXQgd29yZHQgd2VlcmdlZ2V2ZW4gZG9vciBlZW4gcGl4ZWwgaW4gaGV0IHJlc3VsdGVyZW5kZSByYXN0ZXIuIEdhdGVuIHdvcmRlbiB2YWFrIHZlcm9vcnphYWt0IGRvb3Igd2F0ZXJsaWNoYW1lbiwga2xhc3NlLXR5cGUgc2VsZWN0aWUgb2YgdWl0c2x1aXRpbmcuIExlZWd0ZXZ1bGxpbmcgd29yZHQgbWVlc3RhbCBnZWJydWlrdCBiaWogaGV0IGdlbmVyZXJlbiB2YW4gZWVuIGdyb25kb3BwZXJ2bGFrLjwvZGl2PlwiLFxuXHRcdGVxdWFsVG9OYW1lOiBcIkdlbGlqayBhYW5cIixcblx0XHRlcXVhbFRvU25pcDogXCJWb2VydCBlZW4gcmVsYXRpb25lbGUgZ2VsaWprLWFhbi1iZXdlcmtpbmcgdWl0IG9wIHR3ZWUgaW52b2VyZW4gb3AgY2VsLXZvb3ItY2VsIGJhc2lzLiBSZXRvdXJuZWVydCAxIHZvb3IgY2VsbGVuIHdhYXJiaWogaGV0IGVlcnN0ZSByYXN0ZXIgZ2VsaWprIGlzIGFhbiBoZXQgdHdlZWRlIHJhc3RlciBlbiAwIHZvb3IgY2VsbGVuIHdhYXIgemUgbmlldCBnZWxpamsgemlqbi5cIixcblx0XHRlcXVhbFRvRGVzYzogXCJEZSBmdW5jdGllIHZvZXJ0IGVlbiBnZWxpamstYWFuLWJld2Vya2luZyB1aXQgb3AgdHdlZSByYXN0ZXJzIG9wIGVlbiBwaXhlbC1wZXItcGl4ZWwgYmFzaXMuIEhldCByZXRvdXJuZWVydCBkZSB3YWFyZGUgMSB2b29yIHBpeGVscyB3YWFyYmlqIGhldCBlZXJzdGUgcmFzdGVyIGdlbGlqayBpcyBhYW4gaGV0IHR3ZWVkZSByYXN0ZXIgZW4gd2FhcmRlIDAgdm9vciBwaXhlbHMgd2FhciB6ZSBuaWV0IGdlbGlqayB6aWpuLlwiLFxuXHRcdGV1Y0FsbG9jYXRpb25OYW1lOiBcIkV1Y2xpZGlzY2hlIHRvZXdpanppbmdcIixcblx0XHRldWNBbGxvY2F0aW9uU25pcDogXCJCZXJla2VudCB2b29yIGVsa2UgY2VsIGRlIGRpY2h0c3RiaWp6aWpuZGUgYnJvbiBvcCBiYXNpcyB2YW4gZGUgRXVjbGlkaXNjaGUgYWZzdGFuZC5cIixcblx0XHRldWNBbGxvY2F0aW9uRGVzYzogXCJEZSBmdW5jdGllIEV1Y2xpZGlzY2hlIHRvZXdpanppbmcgYmVyZWtlbnQgdm9vciBlbGtlIGNlbCBkZSBkaWNodHN0YmlqemlqbmRlIGJyb24gb3AgYmFzaXMgdmFuIGRlIEV1Y2xpZGlzY2hlIGFmc3RhbmQuXCIsXG5cdFx0ZXVjRGlyZWN0aW9uTmFtZTogXCJFdWNsaWRpc2NoZSByaWNodGluZ1wiLFxuXHRcdGV1Y0RpcmVjdGlvblNuaXA6IFwiQmVyZWtlbnQgdm9vciBlbGtlIGNlbCBkZSByaWNodGluZyBpbiBncmFkZW4gbmFhciBkZSBkaWNodHN0YmlqemlqbmRlIGJyb24uXCIsXG5cdFx0ZXVjRGlyZWN0aW9uRGVzYzogXCJEZSBmdW5jdGllIEV1Y2xpZGlzY2hlIHJpY2h0aW5nIGJlcmVrZW50IHZvb3IgZWxrZSBjZWwgZGUgcmljaHRpbmcgaW4gZ3JhZGVuIG5hYXIgZGUgZGljaHRzdGJpanppam5kZSBicm9uLiA8ZGl2Pjxici8+RGUgcmljaHRpbmcgd29yZHQgYmVyZWtlbmQgdmFuYWYgZWxrIGNlbGNlbnRydW0gdG90IGhldCBtaWRkZW4gdmFuIGRlIGJyb25jZWwgZGllIGhldCBkaWNodHN0IGJpaiBpcy4gSGV0IGJlcmVpayB2YW4gZGUgd2FhcmRlbiBsb29wdCB2YW4gMCBncmFkZW4gdG90IDM2MCBncmFkZW4sIG1ldCAwIGdlcmVzZXJ2ZWVyZCB2b29yIGRlIGJyb25jZWxsZW4uIE9vc3QgKHJlY2h0cykgaXMgOTAgZW4gZGUgd2FhcmRlbiBsb3BlbiByZWNodHNvbSAoMTgwIGlzIHp1aWQsIDI3MCBpcyB3ZXN0IGVuIDM2MCBpcyBub29yZCkuPC9kaXY+XCIsXG5cdFx0ZXVjRGlzdGFuY2VOYW1lOiBcIkV1Y2xpZGlzY2hlIGFmc3RhbmRcIixcblx0XHRldWNEaXN0YW5jZVNuaXA6IFwiQmVyZWtlbnQgdm9vciBlbGtlIGNlbCBkZSBFdWNsaWRpc2NoZSBhZnN0YW5kIG5hYXIgZGUgZGljaHRzdGJpanppam5kZSBicm9uLlwiLFxuXHRcdGV1Y0Rpc3RhbmNlRGVzYzogXCJEZSBmdW5jdGllIEV1Y2xpZGlzY2hlIGFmc3RhbmQgYmVyZWtlbnQgdm9vciBlbGtlIGNlbCBkZSBFdWNsaWRpc2NoZSBhZnN0YW5kIG5hYXIgZGUgZGljaHRzdGJpanppam5kZSBicm9uLlwiLFxuXHRcdGV4cDEwTmFtZTogXCJFeHAxMFwiLFxuXHRcdGV4cDEwU25pcDogXCJCZXJla2VudCBkZSBiYXNpcyAxMCBleHBvbmVudGnDq2xlIGNlbGxlbiBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGV4cDEwRGVzYzogXCJEZSBmdW5jdGllIEV4cCAxMCBiZXJla2VudCBkZSBiYXNpcyAxMCBleHBvbmVudGnDq2xlIHBpeGVscyBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGV4cDJOYW1lOiBcIkV4cDJcIixcblx0XHRleHAyU25pcDogXCJCZXJla2VudCBkZSBiYXNpcyAyIGV4cG9uZW50acOrbGUgY2VsbGVuIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0ZXhwMkRlc2M6IFwiRGUgZnVuY3RpZSBiZXJla2VudCBkZSBiYXNpcyAyIGV4cG9uZW50acOrbGUgcGl4ZWxzIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0ZXhwTmFtZTogXCJFeHBcIixcblx0XHRleHBTbmlwOiBcIkJlcmVrZW50IGRlIGJhc2lzIGUgZXhwb25lbnRpw6tsZSBjZWxsZW4gaW4gZWVuIHJhc3Rlci5cIixcblx0XHRleHBEZXNjOiBcIkRlIGZ1bmN0aWUgYmVyZWtlbnQgZGUgYmFzaXMgZSBleHBvbmVudGnDq2xlIHBpeGVscyBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGV4dHJhY3RCYW5kTmFtZTogXCJCYW5kZW4gZXhwb3J0ZXJlblwiLFxuXHRcdGV4dHJhY3RCYW5kU25pcDogXCJHZWVmdCBhYW4gbWV0IHdlbGtlIGJhbmRlbiBtb2V0IHdvcmRlbiBnZXdlcmt0IGJpaiBoZXQgZ2VicnVpayB2YW4gbXVsdGliYW5kcy1kYXRhc2V0cy5cIixcblx0XHRleHRyYWN0QmFuZERlc2M6IFwiIE1ldCBkZSBmdW5jdGllIEJhbmRlbiBleHBvcnRlcmVuIGt1bnQgdSBlZW4gb2YgbWVlciBiYW5kZW4gZXhwb3J0ZXJlbiB1aXQsIG9mIG9wbmlldXcgb3JkZW5lbiBpbiwgZWVuIG11bHRpYmFuZHMgcmFzdGVyZGF0YXNldC48ZGl2Pjxici8+VSBrdW50IGRlIGZ1bmN0aWUgQmFuZGVuIGV4cG9ydGVyZW4gZ2VicnVpa2VuIHZvb3IgYW5kZXJlIGZ1bmN0aWVzLCB6b2FscyBBcml0bWV0aXNjaCwgb20gdGUgYmVwYWxlbiB3ZWxrZSBiYW5kZW4gd29yZGVuIGdlYnJ1aWt0IGFscyBpbnZvZXIgaW4gZGUgdm9sZ2VuZGUgZnVuY3RpZS48L2Rpdj5cIixcblx0XHRmaWxsTmFtZTogXCJWdWxsaW5nXCIsXG5cdFx0ZmlsbFNuaXA6IFwiVnVsdCBwdXRqZXMgaW4gZWVuIG9wcGVydmxha3Jhc3RlciBvbSBrbGVpbmUgb252b2xrb21lbmhlZGVuIGluIGRlIGdlZ2V2ZW5zIHRlIHZlcndpamRlcmVuLlwiLFxuXHRcdGZpbGxEZXNjOiBcIkRlIGdsb2JhbGUgZnVuY3RpZSBWdWxsZW4gbG9rYWxpc2VlcnQgZW4gdnVsdCBwdXR0ZW4gZW4gcGlla2VuIGluIGVlbiBob29ndGVvcHBlcnZsYWtyYXN0ZXIgb20ga2xlaW5lIG9udm9sa29tZW5oZWRlbiBpbiBkZSBnZWdldmVucyB0ZSB2ZXJ3aWpkZXJlbi4gRGUgZnVuY3RpZSB2dWx0IGVlbiBpdGVyYXRpZWYgcHJvY2VzIGluIHRvdGRhdCBhbGxlIHB1dHRlbiB6aWpuIGdldnVsZCBiaW5uZW4gZGUgb3BnZWdldmVuIFotbGltaWV0LjxkaXY+PGJyLz5XYW5uZWVyIGVlbiBob29ndGV2bGFrIHdvcmR0IGdlbWFha3QgbWV0IE9ydGhvIE1hcHBpbmctdG9vbHMgb2YgbWV0IGFuZGVyZSBtaWRkZWxlbiwgemlqbiBlciB2YWFrIGtsZWluZSBtYWFyIHNpZ25pZmljYW50ZSBmb3V0ZW4gaW4gZGUgdm9ybSB2YW4gcHV0dGVuIGVuIHBpZWtlbiBpbiBkZSBnZWdldmVucy4gSW4gZm90b2dyYW1tZXRyaWUgd29yZGVuIHB1dHRlbiBlbiBwaWVrZW4gdmFhayBnYXRlbiBlbiBwaWVrZW4gZ2Vub2VtZC4gT21kYXQgb3BwZXJ2bGFrdGVnZWdldmVucyB2YWFrIHdvcmRlbiBnZWJydWlrdCBpbiBtb2RlbGxlcmluZywgem9hbHMgaHlkcm9sb2dpc2NoZSBtb2RlbGxlcmluZywgaXMgaGV0IGJlbGFuZ3Jpamsgb20gZGV6ZSBmb3V0ZW4gbWV0IHB1dHRlbiBlbiBwaWVrZW4gb3AgZWVuIG1hbmllciB0ZSBjb3JyaWdlcmVuIGRpZSBjb25zaXN0ZW50IGlzIG1ldCBkZSBvbXJpbmdlbmRlIGdlZ2V2ZW5zLjwvZGl2PlwiLFxuXHRcdGZsb2F0TmFtZTogXCJad2V2ZW5cIixcblx0XHRmbG9hdFNuaXA6IFwiQ29udmVydGVlcnQgZWxrZSBjZWx3YWFyZGUgdmFuIGVlbiByYXN0ZXIgaW4gZWVuIHp3ZXZlbmRlLXB1bnR3ZWVyZ2F2ZS5cIixcblx0XHRmbG9hdERlc2M6IFwiRGUgZnVuY3RpZSBad2V2ZW4gY29udmVydGVlcnQgZWxrZSBwaXhlbHdhYXJkZSB2YW4gZWVuIHJhc3RlciBpbiBlZW4gendldmVuZGUtcHVudHdlZXJnYXZlLlwiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25OYW1lOiBcIlN0cm9vbWFjY3VtdWxhdGllXCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvblNuaXA6IFwiQ3Jlw6tlcnQgZWVuIHJhc3RlciB2YW4gZ2VhY2N1bXVsZWVyZGUgc3Ryb29tIGluIGVsa2UgY2VsLiBFZW4gZ2V3aWNodHNmYWN0b3Iga2FuIG9wdGlvbmVlbCB3b3JkZW4gdG9lZ2VwYXN0LlwiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25EZXNjOiBcIk1ldCBkZSBhbGdlbWVuZSBmdW5jdGllIFN0cm9vbWFjY3VtdWxhdGllIHdvcmR0IGVlbiByYXN0ZXIgdmFuIGdlYWNjdW11bGVlcmRlIHN0cm9vbSBpbiBlbGsgcGl4ZWwgZ2VtYWFrdCwgem9hbHMgYmVwYWFsZCBkb29yIGhldCB2ZXJ6YW1lbGVuIHZhbiBoZXQgZ2V3aWNodCB2b29yIGFsbGUgcGl4ZWxzIGRpZSBpbiBlbGtlIG5lZXJ3YWFydHNlIHBpeGVsIHZsb2VpZW4uIEFscyBlciBnZWVuIGdld2ljaHRzcmFzdGVyIGlzLCB3b3JkdCBlZW4gZ2V3aWNodCB2YW4gMSB0b2VnZXBhc3Qgb3AgZWxrZSBwaXhlbCBlbiBpcyBkZSB3YWFyZGUgdmFuIHBpeGVscyBpbiBoZXQgdWl0dm9lcnJhc3RlciBoZXQgYWFudGFsIHBpeGVscyBkYXQgaW4gZWxrZSBwaXhlbCBzdHJvb210LjxkaXY+PGJyLz5VaXR2b2VycGl4ZWxzIG1ldCBlZW4gaG9nZSBzdHJvb21hY2N1bXVsYXRpZSB6aWpuIGdlYmllZGVuIG1ldCBnZWNvbmNlbnRyZWVyZGUgc3Ryb29tIGVuIGt1bm5lbiB3b3JkZW4gZ2VicnVpa3Qgb20gc3Ryb29ta2FuYWxlbiB0ZSBpZGVudGlmaWNlcmVuLiBVaXR2b2VycGl4ZWxzIG1ldCBlZW4gc3Ryb29tYWNjdW11bGF0aWUgdmFuIG51bCB6aWpuIGxva2FsZSB0b3BvZ3JhZmlzY2hlIGhvb2d0ZXB1bnRlbiBlbiBrdW5uZW4gd29yZGVuIGdlYnJ1aWt0IG9tIGJlcmdrYW1tZW4gdGUgaWRlbnRpZmljZXJlbi48L2Rpdj5cIixcblx0XHRmbG93RGlyZWN0aW9uTmFtZTogXCJTdHJvb21yaWNodGluZ1wiLFxuXHRcdGZsb3dEaXJlY3Rpb25TbmlwOiBcIkNyZcOrZXJ0IGVlbiByYXN0ZXIgdmFuIHN0cm9vbXJpY2h0aW5nIHZhbiBlbGtlIGNlbCBuYWFyIGRlIHN0ZWlsc3RlIG5lZXJ3YWFydHNlIGJ1dXIuXCIsXG5cdFx0Zmxvd0RpcmVjdGlvbkRlc2M6IFwiRWVuIHZhbiBkZSBzbGV1dGVscyB0b3QgaGV0IGFmbGVpZGVuIHZhbiBoeWRyb2xvZ2lzY2hlIGVpZ2Vuc2NoYXBwZW4gdmFuIGVlbiBvcHBlcnZsYWsgaXMgaGV0IHZlcm1vZ2VuIG9tIGRlIHN0cm9vbXJpY2h0aW5nIHZhbiBlbGtlIHBpeGVsIGluIGhldCByYXN0ZXIgdGUgYmVwYWxlbi4gRGUgcmFzdGVyZnVuY3RpZSB2YW4gZGUgU3Ryb29tcmljaHRpbmcgbmVlbXQgZWVuIG9wcGVydmxhayBhbHMgaW52b2VyIGVuIGNyZcOrZXJ0IGVlbiByYXN0ZXIgdmFuIHN0cm9vbXJpY2h0aW5nIHZhbiBlbGtlIHBpeGVsIG5hYXIgZGUgc3RlaWxzdGUgbmVlcndhYXJ0c2UgYnV1ci4gRGUgZnVuY3RpZSBTdHJvb21yaWNodGluZyBvbmRlcnN0ZXVudCBkcmllIHN0cm9vbW1vZGVsbWV0aG9kZW46IGRlIEQ4IChhY2h0IHJpY2h0aW5nZW4pLCBNdWx0aS1GbG93IERpcmVjdGlvbiAoTUZEKSBlbiBELUluZmluaXR5IChESU5GKS4gXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlTmFtZTogXCJTdHJvb21hZnN0YW5kXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlU25pcDogXCJCZXJla2VudCwgdm9vciBlbGtlIGNlbCwgZGUgbWluaW1hbGUgbmVlcndhYXJ0c2UgaG9yaXpvbnRhbGUgb2YgdmVydGljYWxlIGFmc3RhbmQgdG90IGNlbGxlbiBvcCBlZW4gc3Ryb29tIG9mIHJpdmllciB3YWFyaW4gemUgc3Ryb21lbi5cIixcblx0XHRmbG93RGlzdGFuY2VEZXNjOiBcIlZvb3IgZWxrZSBwaXhlbCBiZXJla2VudCBkZSBmdW5jdGllIGRlIG1pbmltYWxlIG5lZXJ3YWFydHNlIGhvcml6b250YWxlIG9mIHZlcnRpY2FsZSBhZnN0YW5kIHRvdCBwaXhlbChzKSBvcCBlZW4gcml2aWVyIG9mIHN0cm9vbSB3YWFyaW4gemUgc3Ryb21lbi4gQWxzIGVyIGVlbiBvcHRpb25lZWwgc3Ryb29tcmljaHRpbmdyYXN0ZXIgaXMsIHdvcmR0L3dvcmRlbiBkZSBuZWVyd2FhcnRzZSByaWNodGluZyhlbikgYmVwZXJrdCB0b3QgZGllIGRpZSB3b3JkZW4gZ2VkZWZpbmllZXJkIGRvb3IgaGV0IHJhc3RlciB2YW4gZGUgaW52b2Vyc3Ryb29tcmljaHRpbmcuIERlIHVpdHZvZXIgaXMgZWVuIHN0cm9vbWFmc3RhbmRyYXN0ZXIuXCIsXG5cdFx0Zm9jYWxOYW1lOiBcIkZvY2FsZSBzdGF0aXN0aWVrZW5cIixcblx0XHRmb2NhbFNuaXA6IFwiQmVyZWtlbnQgZm9jYWxlIHN0YXRpc3RpZWtlbiB2b29yIGVsa2UgcGl4ZWwgdmFuIGVlbiBhZmJlZWxkaW5nIG9wIGJhc2lzIHZhbiBlZW4gZ2VkZWZpbmllZXJkZSBmb2NhbGUgYnV1cnQuXCIsXG5cdFx0Zm9jYWxEZXNjOiBcIkRlIGZ1bmN0aWUgRm9jYWxlIHN0YXRpc3RpZWtlbiBiZXJla2VudCBmb2NhbGUgc3RhdGlzdGlla2VuIHZvb3IgZWxrZSBwaXhlbCB2YW4gZWVuIGFmYmVlbGRpbmcgb3AgYmFzaXMgdmFuIGVlbiBnZWRlZmluaWVlcmRlIGZvY2FsZSBidXVydC5cIixcblx0XHRnZW9tZXRyaWNOYW1lOiBcIkdlb21ldHJpc2NoXCIsXG5cdFx0Z2VvbWV0cmljU25pcDogXCJWZXJob29ndCBkZSBwb3NpdGllbmF1d2tldXJpZ2hlaWQgdmFuIGVlbiBkYXRhc2V0IGRvb3IgcmVrZW5pbmcgdGUgaG91ZGVuIG1ldCBkZSBob29ndGUuXCIsXG5cdFx0Z2VvbWV0cmljRGVzYzogXCJEZSBmdW5jdGllIEdlb21ldHJpc2NoIHByb2R1Y2VlcnQgZWVuIG9ydGhvZ2VyZWN0aWZpY2VlcmRlIGFmYmVlbGRpbmcgb3AgYmFzaXMgdmFuIGVlbiBzZW5zb3JkZWZpbml0aWUgZW4gZWVuIHRlcnJlaW5tb2RlbC4gSGV0IHZlcmhvb2d0IGRlIHBvc2l0aWVuYXV3a2V1cmlnaGVpZCB2YW4gZWVuIGRhdGFzZXQgZG9vciByZWtlbmluZyB0ZSBob3VkZW4gbWV0IGRlIGhvb2d0ZS5cIixcblx0XHRncmF5c2NhbGVOYW1lOiBcIkdyaWpzdGludGVuXCIsXG5cdFx0Z3JheXNjYWxlU25pcDogXCJDb252ZXJ0ZWVydCBlZW4gbXVsdGliYW5kLWFmYmVlbGRpbmcgbmFhciBlZW4gYWZiZWVsZGluZyBpbiBncmlqc3RpbnRlbiBtZXQgw6nDqW4gYmFuZC5cIixcblx0XHRncmF5c2NhbGVEZXNjOiBcIk1ldCBkZXplIGZ1bmN0aWUgY29udmVydGVlcnQgdSBlZW4gbXVsdGliYW5kLWFmYmVlbGRpbmcgbmFhciBlZW4gYWZiZWVsZGluZyBpbiBncmlqc3RpbnRlbiBtZXQgw6nDqW4gYmFuZC48ZGl2Pjxici8+RGV6ZSBmdW5jdGllIHBhc3QgZ2VzcGVjaWZpY2VlcmRlIGdld2ljaHRlbiB0b2Ugb3AgZWxrIHZhbiBkZSBpbnZvZXJiYW5kZW4gZW4gbm9ybWFsaXNlZXJ0IGhldCB1aXR2b2VyYmVlbGQuIERlIGdld2ljaHRlbiB3b3JkZW4gdmFhayB0b2VnZXBhc3Qgb21kYXQgc29tbWlnZSBiYW5kZW4gYWZoYW5rZWxpamsgdmFuIGRlIHRvZXBhc3NpbmcgdmFuIHZhcmlhYmVsIGJlbGFuZyB6aWpuLiBEZSBibGF1d2UgYmFuZCBiZXZhdCBiaWp2b29yYmVlbGQgdmFhayBtZWVyIHJ1aXMgZGFuIGFuZGVyZSBiYW5kZW4uPC9kaXY+XCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbE5hbWU6IFwiR3JvdGVyIGRhbiBvZiBnZWxpamsgYWFuXCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbFNuaXA6IFwiVm9lcnQgZWVuIFJlbGF0aW9uZWxlLWdyb3Rlci1kYW4tZ2VsaWprLWFhbi1iZXdlcmtpbmcgdWl0IG9wIHR3ZWUgaW52b2VyZW4gb3AgY2VsLXZvb3ItY2VsIGJhc2lzLiBSZXRvdXJuZWVydCAxIHZvb3IgY2VsbGVuIHdhYXJ2YW4gaGV0IGVlcnN0ZSByYXN0ZXIgZ3JvdGVyIGlzIGRhbiBvZiBnZWxpamsgaXMgYWFuIGhldCB0d2VlZGUgcmFzdGVyIGVuIDAgYWxzIGRpdCBuaWV0IGhldCBnZXZhbCBpcy5cIixcblx0XHRncmVhdGVyVGhhbkVxdWFsRGVzYzogXCJEZSBmdW5jdGllIHZvZXJ0IGVlbiBSZWxhdGlvbmVsZS1ncm90ZXItZGFuLW9mLWdlbGlqay1hYW4tYmV3ZXJraW5nIHVpdCBvcCB0d2VlIGludm9lcmVuIG9wIGVlbiBwaXhlbC1wZXItcGl4ZWwgYmFzaXMuIEhldCByZXRvdXJuZWVydCBlZW4gd2FhcmRlIHZhbiAxIHZvb3IgcGl4ZWxzIHdhYXJiaWogaGV0IGVlcnN0ZSByYXN0ZXIgZ3JvdGVyIGlzIGRhbiBvZiBnZWxpamsgYWFuIGhldCB0d2VlZGUgcmFzdGVyIGVuIGVlbiB3YWFyZGUgdmFuIDAgdm9vciBwaXhlbHMgd2FhcmJpaiBoZXQgZWVyc3RlIHJhc3RlciBuaWV0IGdyb3RlciBpcyBkYW4gb2YgZ2VsaWprIGlzIGFhbiBoZXQgdHdlZWRlIHJhc3Rlci5cIixcblx0XHRncmVhdGVyVGhhbk5hbWU6IFwiR3JvdGVyIGRhblwiLFxuXHRcdGdyZWF0ZXJUaGFuU25pcDogXCJWb2VydCBlZW4gUmVsYXRpb25lbGUtZ3JvdGVyLWRhbi1iZXdlcmtpbmcgdWl0IG9wIHR3ZWUgaW52b2VyZW4gb3AgY2VsLXZvb3ItY2VsIGJhc2lzLiBSZXRvdXJuZWVydCAxIHZvb3IgY2VsbGVuIHdhYXJiaWogaGV0IGVlcnN0ZSBncm90ZXIgaXMgZGFuIGhldCB0d2VlZGUgcmFzdGVyIGVuIDAgdm9vciBjZWxsZW4gYWxzIGRpdCBuaWV0IGhldCBnZXZhbCBpcy5cIixcblx0XHRncmVhdGVyVGhhbkRlc2M6IFwiRGUgZnVuY3RpZSB2b2VydCBlZW4gUmVsYXRpb25lbGUtZ3JvdGVyLWRhbi1iZXdlcmtpbmcgdWl0IG9wIHR3ZWUgaW52b2VyZW4gb3AgZWVuIHBpeGVsLXBlci1waXhlbCBiYXNpcy4gUmV0b3VybmVlcnQgZWVuIHdhYXJkZSB2YW4gMSB2b29yIHBpeGVscyB3YWFyYmlqIGhldCBlZXJzdGUgcmFzdGVyIGdyb3RlciBpcyBkYW4gb2YgZ2VsaWprIGFhbiBoZXQgdHdlZWRlIHJhc3RlciBlbiBlZW4gd2FhcmRlIHZhbiAwIHZvb3IgcGl4ZWxzIHdhYXJiaWogaGV0IGVlcnN0ZSByYXN0ZXIgbmlldCBncm90ZXIgaXMgZGFuIGhldCB0d2VlZGUgcmFzdGVyLlwiLFxuXHRcdGhlYXRJbmRleE5hbWU6IFwiV2FybXRlLWluZGV4XCIsXG5cdFx0aGVhdEluZGV4U25pcDogXCJDb21iaW5lZXJ0IGRlIG9tZ2V2aW5nc2x1Y2h0dGVtcGVyYXR1dXIgZW4gZGUgcmVsYXRpZXZlIHZvY2h0aWdoZWlkIG9tIGRlIHNjaGlqbmJhcmUgdGVtcGVyYXR1dXIgdGVydWcgdGUgYnJlbmdlbi5cIixcblx0XHRoZWF0SW5kZXhEZXNjOiBcIkRlemUgZnVuY3RpZSBiZXJla2VudCBkZSBzY2hpam5iYXJlIHRlbXBlcmF0dXVyIG9wIGJhc2lzIHZhbiBkZSBvbWdldmluZ3N0ZW1wZXJhdHV1ciBlbiByZWxhdGlldmUgdm9jaHRpZ2hlaWQuIERlIHNjaGlqbmJhcmUgdGVtcGVyYXR1dXIgd29yZHQgdmFhayBiZXNjaHJldmVuIGFscyBob2UgaGVldCBoZXQgdm9vciBoZXQgbWVuc2VsaWprIGxpY2hhYW0gaXMuPGRpdj48YnIvPkRlemUgaW5kZXgga2FuIG51dHRpZyB6aWpuIHZvb3IgaGV0IGJlcmVrZW5lbiB2YW4gZGUgZ2V2YXJlbiBkaWUgdmVyYmFuZCBob3VkZW4gbWV0IG1lZGlzY2hlIHByb2JsZW1lbiB6b2FscyBzcGllcmtyYW1wLCB1aXRkcm9naW5nLCBoaXR0ZS11aXRwdXR0aW5nIG9mIGVlbiBlcm5zdGlnZSB6b25uZXN0ZWVrIG9wIHdhcm1lIGVuIHZvY2h0aWdlIGRhZ2VuLiBBbHMgZGUgcmVsYXRpZXZlIHZvY2h0aWdoZWlkIGhvb2cgaXMsIHdvcmR0IGhldCBzdGVlZHMgbW9laWxpamtlciB2b29yIGhldCBsaWNoYWFtIG9tIHp3ZWV0IHRlIHZlcmRhbXBlbiwgd2FhcmRvb3IgZWVuIG1lbnMgbmlldCBtZWVyIGVmZmVjdGllZiBvcCBuYXR1dXJsaWprZSBtYW5pZXIga2FuIGFma29lbGVuLiBLYWFydGVuIG1ldCB3YXJtdGUtYWR2aWV6ZW4gb2Ygd2FhcnNjaHV3aW5nZW4gemlqbiB2YWFrIGVlbiBnZXZvbGcgdmFuIGhldCBoZXJjbGFzc2lmaWNlcmVuIHZhbiBoZXQgcmVzdWx0YWF0IHZhbiBkZSB3YXJtdGUtaW5kZXggbmFhciBrbGFzc2VuLCB3YWFyYmlqIGhvZSBob2dlciBkZSBpbmRleHdhYXJkZSBpcywgaG9lIGdyb3RlciBkZSBrYW5zIGlzIGRhdCBoZXQgZWVyZGVyIGVlbiB3YWFyc2NodXdpbmcgZGFuIGVlbiBhZHZpZXMgd29yZHQuPC9kaXY+XCIsXG5cdFx0aGlsbHNoYWRlTmFtZTogXCJCZXJnc2NoYWR1d2VuXCIsXG5cdFx0aGlsbHNoYWRlU25pcDogXCJDcmXDq2VydCBlZW4gM0Qtd2VlcmdhdmUgdmFuIGhldCBvcHBlcnZsYWssIHdhYXJiaWogZGUgcmVsYXRpZXZlIHBvc2l0aWUgdmFuIGRlIHpvbiBpbiBhYW5tZXJraW5nIHdvcmR0IGdlbm9tZW4gdm9vciBoZXQgdmVyZHVpc3RlcmVuIHZhbiBoZXQgYmVlbGQuXCIsXG5cdFx0aGlsbHNoYWRlRGVzYzogXCJEZSBmdW5jdGllIEJlcmdzY2hhZHV3IHByb2R1Y2VlcnQgZWVuIDNELXdlZXJnYXZlIGluIGdyaWpzdGludGVuIHZhbiBoZXQgdGVycmVpbm9wcGVydmxhaywgd2FhcmJpaiBkZSByZWxhdGlldmUgcG9zaXRpZSB2YW4gZGUgem9uIGluIGFhbm1lcmtpbmcgd29yZHQgZ2Vub21lbiB2b29yIGhldCB2ZXJkdWlzdGVyZW4gdmFuIGhldCBiZWVsZC4gPGRpdj48YnIvPkJlcmdzY2hhZHV3IGlzIGVlbiB0ZWNobmllayB2b29yIGhldCB2aXN1YWxpc2VyZW4gdmFuIHRlcnJlaW4gZGF0IHdvcmR0IGJlcGFhbGQgZG9vciBlZW4gbGljaHRicm9uIGVuIGRlIGhlbGxpbmcgZW4gaGV0IGFzcGVjdCB2YW4gaGV0IGhvb2d0ZXZsYWsuIEhldCBpcyBlZW4ga3dhbGl0YXRpZXZlIG1ldGhvZGUgdm9vciBoZXQgdmlzdWFsaXNlcmVuIHZhbiB0b3BvZ3JhZmllIGVuIGdlZWZ0IGdlZW4gYWJzb2x1dGUgaG9vZ3Rld2FhcmRlbi4gPC9kaXY+XCIsXG5cdFx0aW50TmFtZTogXCJJbnRcIixcblx0XHRpbnRTbmlwOiBcIkNvbnZlcnRlZXJ0IGVsa2UgY2Vsd2FhcmRlIHZhbiBlZW4gcmFzdGVyIG5hYXIgZWVuIGdlaGVlbCBnZXRhbCBkb29yIGFmIHRlIGtvcnRlbi5cIixcblx0XHRpbnREZXNjOiBcIkRlIGZ1bmN0aWUgSW50IGNvbnZlcnRlZXJ0IGVsa2UgcGl4ZWx3YWFyZGUgdmFuIGVlbiByYXN0ZXIgbmFhciBlZW4gZ2VoZWVsIGdldGFsIGRvb3IgYWYgdGUga29ydGVuLlwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YU5hbWU6IFwiSW50ZXJwb2xlcmVuIHZhbiBvbnJlZ2VsbWF0aWdlIGdlZ2V2ZW5zXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhU25pcDogXCJJbnRlcnBvbGVlcnQgdmFuIHBvaW50Y2xvdWRzIG9mIG9ucmVnZWxtYXRpZ2UgcmFzdGVycy5cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFEZXNjOiBcIlNvbW1pZ2UgbmV0Q0RGLSBvZiBIREYtZGF0YXNldHMgc2xhYW4gaHVuIGdlb2xvY2F0aWUgb3AgYWxzIG9ucmVnZWxtYXRpZyB2ZXJkZWVsZGUgcmlqZW4gcGl4ZWxzIG9mIHB1bnRnZWdldmVucy4gQmlqIGhldCB0b2V2b2VnZW4gdmFuIGRlemUgZGF0YXNldHMgYWFuIGVlbiBtb3phw69la2RhdGFzZXQsIG5lZW10IGRlIGludGVycG9sZXJlbmRlIG9ucmVnZWxtYXRpZ2UgZ2VnZXZlbnNmdW5jdGllIGRlIG9ucmVnZWxtYXRpZyBnZXJhc3RlcmRlIGdlZ2V2ZW5zIG9wIGVuIGhlcnZlcnphbWVsdCBkZXplIHpvZGF0IGVsa2UgcGl4ZWwgZWVuIHVuaWZvcm1lIGdyb290dGUgaGVlZnQgZW4gdmllcmthbnQgaXMuPGRpdj48YnIvPkJpaiBoZXQgdG9ldm9lZ2VuIHZhbiB2YXJpYWJlbGVuIHVpdCBuZXRDREYgb2YgSERGIGFhbiBlZW4gbW96YcOvZWtkYXRhc2V0LCB3b3JkdCBhdXRvbWF0aXNjaCBnZWNvbnRyb2xlZXJkIG9mIGRlIGdlZ2V2ZW5zIHJlZ2VsbWF0aWcgd29yZGVuIGdlcmFuZ3NjaGlrdC4gQWxzIGRpdCBuaWV0IGhldCBnZXZhbCBpcywga2FuIGRlIGludGVycG9sZWVyZnVuY3RpZSB2b29yIG9ucmVnZWxtYXRpZ2UgZGF0YSB3b3JkZW4gZ2VicnVpa3Qgb20gZGUgb25yZWdlbG1hdGlnZSBnZWdldmVucyBvbSB0ZSB6ZXR0ZW4gaW4gZWVuIHJhc3RlciBkYXQgcmVnZWxtYXRpZyB3b3JkdCBnZXJhc3RlcmQuIFUga3VudCBkZSBpbnRlcnBvbGF0aWVtZXRob2RlIGVuIGRlIGNlbGdyb290dGUgd2lqemlnZW4gZGllIHdvcmRlbiBnZWJydWlrdCBpbiBkZSBpbnRlcnBvbGVlcmZ1bmN0aWUgdm9vciBvbnJlZ2VsbWF0aWdlIGRhdGFyYXN0ZXJzLiBWb29yIHJhc3RlcmRhdGEgb3AgcmVnZWxtYXRpZ2UgYWZzdGFuZGVuIHdvcmR0IGdlZW4gaW50ZXJwb2xhdGllIHRvZWdlcGFzdCBlbiB3b3JkZW4gZGUgZ2VnZXZlbnMgZ2VsZXplbiB6b2FscyB6ZSB6aWpuLjwvZGl2PlwiLFxuXHRcdGlzTnVsbE5hbWU6IFwiSXMgbnVsbFwiLFxuXHRcdGlzTnVsbFNuaXA6IFwiQmVwYWFsdCB3ZWxrZSB3YWFyZGVuIHZhbiBkZSBpbnZvZXJyYXN0ZXJzIE5vRGF0YSB6aWpuIG9wIGVlbiBjZWwtdm9vci1jZWwgYmFzaXMuIFJldG91cm5lZXJ0IGVlbiB3YWFyZGUgdmFuIDEgYWxzIGRlIGludm9lcndhYXJkZW4gTm9EYXRhIHppam4gZW4gMCB2b29yIGNlbGxlbiBkaWUgZGF0IG5pZXQgemlqbi5cIixcblx0XHRpc051bGxEZXNjOiBcIkRlIElzIG51bGwtZnVuY3RpZSBiZXBhYWx0IHdlbGtlIHdhYXJkZW4gdmFuIGhldCBpbnZvZXJyYXN0ZXIgTm9EYXRhIHppam4gb3AgZWVuIHBpeGVsLXZvb3ItcGl4ZWwgYmFzaXMuIEhldCBnZWVmdCBlZW4gd2FhcmRlIHZhbiAxIGFscyBkZSBpbnZvZXJ3YWFyZGUgTm9EYXRhIGlzIGVuIGVlbiB3YWFyZGUgdmFuIDAgdm9vciBwaXhlbHMgZGllIGdlZW4gTm9EYXRhIHppam4uXCIsXG5cdFx0a2VybmVsRGVuc2l0eU5hbWU6IFwiS2VybmRpY2h0aGVpZFwiLFxuXHRcdGtlcm5lbERlbnNpdHlTbmlwOiBcIkJlcmVrZW50IGVlbiBtYWduaXR1ZGUtcGVyLWVlbmhlaWQgZ2ViaWVkIHZhbiBwdW50LSBvZiBwb2x5bGlqbm9iamVjdGVuIG1ldCBiZWh1bHAgdmFuIGVlbiBrZXJuZnVuY3RpZSBvbSBlZW4gdmxvZWllbmQsIHRhcHMgdG9lbG9wZW5kIG9wcGVydmxhayBvcCBlbGsgcHVudCBvZiBwb2x5bGlqbiB0ZSBwYXNzZW4uXCIsXG5cdFx0a2VybmVsRGVuc2l0eURlc2M6IFwiRGV6ZSBmdW5jdGllIGJlcmVrZW50IGVlbiBtYWduaXR1ZGUtcGVyLWVlbmhlaWQgZ2ViaWVkIHZhbiBwdW50LSBvZiBwb2x5bGlqbm9iamVjdGVuIG1ldCBiZWh1bHAgdmFuIGVlbiBrZXJuZnVuY3RpZSBvbSBlZW4gdmxvZWllbmQsIHRhcHMgdG9lbG9wZW5kIG9wcGVydmxhayBvcCBlbGsgcHVudCBvZiBwb2x5bGlqbiB0ZSBwYXNzZW4uXCIsXG5cdFx0a2V5TWV0YWRhdGFOYW1lOiBcIkJlbGFuZ3JpamtlIG1ldGFkYXRhXCIsXG5cdFx0a2V5TWV0YWRhdGFTbmlwOiBcIk92ZXJzY2hyaWpmdCBvZiB2b2VndCBiZWxhbmdyaWprZSBtZXRhZGF0YSB2YW4gZWVuIHJhc3RlciBpbiBlZW4gZnVuY3RpZWtldGVuIGluLlwiLFxuXHRcdGtleU1ldGFkYXRhRGVzYzogXCJNZXQgZGV6ZSBmdW5jdGllIGt1bnQgdSBtZXRhZGF0YSB2YW4gZWVuIHJhc3RlciBpbnZvZWdlbiBvZiB2ZXJ2YW5nZW4uPGRpdj48YnIvPkRlIGluZm9ybWF0aWUgaW4gYmVsYW5ncmlqa2UgbWV0YWRhdGEgd29yZHQgZ2VicnVpa3Qgb20gZGUgdG9lcGFzc2luZyB0ZSBoZWxwZW4gYmlqIHNvbW1pZ2UgYmV3ZXJraW5nZW4gZW4gd2VlcmdhdmVuLCB3YWFyb25kZXIgaGV0IHZlcnN0cmVra2VuIHZhbiBudXR0aWdlIGluZm9ybWF0aWUsIHpvYWxzIGRlIHNlbnNvcm5hYW0sIGJhbmRuYW1lbiBvZiBjbG91ZCBjb3ZlciBkaWUgYWFuIGRlIGJlZWxkZW4gaXMgZ2Vrb3BwZWxkLjwvZGl2PlwiLFxuXHRcdHNob3J0ZXN0UGF0aE5hbWU6IFwiTGFhZ3N0ZSBrb3N0ZW5wYWRcIixcblx0XHRzaG9ydGVzdFBhdGhTbmlwOiBcIlZvZXJ0IGVlbiBrb3N0ZW5hZnN0YW5kc2FuYWx5c2UgdWl0IG1ldCBicm9uLSBlbiBiZXN0ZW1taW5nc2ludm9lciBkaWUgdmVydm9sZ2VucyB3b3JkdCBnZWJydWlrdCBvbSBoZXQgcGFkIG1ldCBkZSBtaW5zdGUga29zdGVuIHZhbiBlZW4gYnJvbiBuYWFyIGVlbiBiZXN0ZW1taW5nIHRlIGJlcGFsZW4uXCIsXG5cdFx0c2hvcnRlc3RQYXRoRGVzYzogXCJEZSBmdW5jdGllIExhYWdzdGUga29zdGVucGFkIGJlcmVrZW50IGhldCBwYWQgbWV0IGRlIGxhYWdzdGUga29zdGVuIHZhbiBlZW4gYnJvbiBuYWFyIGVlbiBiZXN0ZW1taW5nLiBEZSBtaW5zdCBjdW11bGF0aWV2ZSBrb3N0ZW5hZnN0YW5kIHdvcmR0IGJlcmVrZW5kIHZvb3IgZWxrZSBwaXhlbCBvdmVyIGVlbiBrb3N0ZW5vcHBlcnZsYWsgbmFhciBkZSBkaWNodHN0YmlqemlqbmRlIGJyb24uIERpdCBwcm9kdWNlZXJ0IGVlbiB1aXR2b2VycmFzdGVyIHdhYXJtZWUgaGV0IHBhZCBtZXQgZGUgbWluc3RlIGtvc3RlbiBvZiBwYWRlbiB2YW4gZ2VzZWxlY3RlZXJkZSBsb2NhdGllcyBuYWFyIGRlIGRpY2h0c3RiaWp6aWpuZGUgYnJvbnBpeGVscyB2YXN0Z2VsZWdkIGJpbm5lbiBoZXQgZ2VhY2N1bXVsZWVyZGUga29zdGVub3BwZXJ2bGFrLCBpbiB0ZXJtZW4gdmFuIGtvc3RlbmFmc3RhbmQuPGRpdj48YnIvPkFhbiBlbGsgcGFkIG1ldCBkZSBsYWFnc3RlIGtvc3RlbiB3b3JkdCBlZW4gd2FhcmRlIHRvZWdld2V6ZW4gd2FubmVlciBkZXplIHRpamRlbnMgaGV0IHNjYW5wcm9jZXMgd29yZHQgYWFuZ2V0cm9mZmVuLiBEZSBlaW5kcGl4ZWwgb3AgaGV0IGJyb25yYXN0ZXIgdmFuIGVlbiBrb3N0ZW5wYWQga3Jpamd0IGVlbiB3YWFyZGUgdmFuIDEuIEhldCBlZXJzdGUgcGFkIGtyaWpndCBlZW4gd2FhcmRlIHZhbiAzLCBkZSB0d2VlZGUgNCwgZW56b3Zvb3J0LiBXYW5uZWVyIG1lZXJkZXJlIHBhZGVuIHNhbWVudmxvZWllbiBlbiBkZSByZXN0ZXJlbmRlIGFmc3RhbmQgbmFhciBlZW4gYnJvbiBvcCBkZXplbGZkZSByb3V0ZSB2b2xnZW4sIGtyaWpndCBoZXQgc2VnbWVudCB3YWFyIGRlIHR3ZWUgcGFkZW4gc2FtZW4ga29tZW4gZWVuIHdhYXJkZSB2YW4gMi4gSGV0IHNhbWVuZ2V2b2VnZGUgZGVlbCB2YW4gaGV0IHBhZCBrYW4gbmlldCBkZSB3YWFyZGUgdmFuIGVlbiB2YW4gZGUgcGFkZW4ga3JpamdlbiB0b2VnZXdlemVuLCBvbWRhdCBoZXQgc2FtZW5nZXZvZWdkZSBkZWVsIGJpaiBiZWlkZSByb3V0ZXMgaG9vcnQuPC9kaXY+XCIsXG5cdFx0bGVzc1RoYW5FcXVhbE5hbWU6IFwiS2xlaW5lciBkYW4gb2YgZ2VsaWprIGFhblwiLFxuXHRcdGxlc3NUaGFuRXF1YWxTbmlwOiBcIlZvZXJ0IGVlbiBSZWxhdGlvbmVsZS1rbGVpbmVyLWRhbi1nZWxpamstYWFuLWJld2Vya2luZyB1aXQgb3AgdHdlZSBpbnZvZXJlbiBvcCBlZW4gY2VsLXZvb3ItY2VsIGJhc2lzLiBSZXRvdXJuZWVydCAxIHZvb3IgY2VsbGVuIHdhYXJ2YW4gaGV0IGVlcnN0ZSByYXN0ZXIga2xlaW5lciBpcyBkYW4gb2YgZ2VsaWprIGlzIGFhbiBoZXQgdHdlZWRlIHJhc3RlciBlbiAwIGFscyBkaXQgbmlldCBoZXQgZ2V2YWwgaXMuXCIsXG5cdFx0bGVzc1RoYW5FcXVhbERlc2M6IFwiRGUgZnVuY3RpZSB2b2VydCBlZW4gUmVsYXRpb25lbGUta2xlaW5lci1kYW4tb2YtZ2VsaWprLWFhbi1iZXdlcmtpbmcgdWl0IG9wIHR3ZWUgaW52b2VyZW4gb3AgZWVuIHBpeGVsLXBlci1waXhlbCBiYXNpcy4gSGV0IHJldG91cm5lZXJ0IGVlbiB3YWFyZGUgdmFuIDEgdm9vciBwaXhlbHMgd2FhcmJpaiBoZXQgZWVyc3RlIHJhc3RlciBrbGVpbmVyIGlzIGRhbiBvZiBnZWxpamsgYWFuIGhldCB0d2VlZGUgcmFzdGVyIGVuIGVlbiB3YWFyZGUgdmFuIDAgdm9vciBwaXhlbHMgd2FhcmJpaiBoZXQgbmlldCBrbGVpbmVyIGlzIGRhbiBvZiBnZWxpamsgaXMgYWFuIGhldCB0d2VlZGUgcmFzdGVyLlwiLFxuXHRcdGxlc3NUaGFuTmFtZTogXCJLbGVpbmVyIGRhblwiLFxuXHRcdGxlc3NUaGFuU25pcDogXCJWb2VydCBlZW4gUmVsYXRpb25lbGUta2xlaW5lci1kYW4tYmV3ZXJraW5nIHVpdCBvcCB0d2VlIGludm9lcmVuIG9wIGVlbiBjZWwtdm9vci1jZWwgYmFzaXMuIFJldG91cm5lZXJ0IDEgdm9vciBjZWxsZW4gd2FhcnZhbiBoZXQgZWVyc3RlIHJhc3RlciBrbGVpbmVyIGlzIGRhbiBoZXQgdHdlZWRlIHJhc3RlciBlbiAwIGFscyBkaXQgbmlldCBoZXQgZ2V2YWwgaXMuXCIsXG5cdFx0bGVzc1RoYW5EZXNjOiBcIkRlIGZ1bmN0aWUgdm9lcnQgZWVuIFJlbGF0aW9uZWxlLWtsZWluZXItZGFuLWJld2Vya2luZyB1aXQgb3AgdHdlZSBpbnZvZXJlbiBvcCBlZW4gcGl4ZWwtcGVyLXBpeGVsIGJhc2lzLiBIZXQgcmV0b3VybmVlcnQgZWVuIHdhYXJkZSB2YW4gMSB2b29yIHBpeGVscyB3YWFyYmlqIGhldCBlZXJzdGUgcmFzdGVyIGtsZWluZXIgaXMgZGFuIGhldCB0d2VlZGUgcmFzdGVyIGVuIGVlbiB3YWFyZGUgdmFuIDAgd2FhcmJpaiBoZXQgbmlldCBrbGVpbmVyIGlzIGRhbiBoZXQgdHdlZWRlIHJhc3Rlci5cIixcblx0XHRsbk5hbWU6IFwiTG5cIixcblx0XHRsblNuaXA6IFwiQmVyZWtlbnQgaGV0IG5hdHV1cmxpamtlIGxvZ2FyaXRtZSAoYmFzaXMgZSkgdmFuIGNlbGxlbiBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGxuRGVzYzogXCJEZSBmdW5jdGllIExuIGJlcmVrZW50IGhldCBuYXR1dXJsaWprIGxvZ2FyaXRtZSAoYmFzaXMgZSkgdmFuIGVsayBwaXhlbCBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGxvZzEwTmFtZTogXCJMb2cxMFwiLFxuXHRcdGxvZzEwU25pcDogXCJCZXJla2VudCBkZSBiYXNpcyAxMCBsb2dhcml0bWUgdmFuIGNlbGxlbiBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGxvZzEwRGVzYzogXCJEZSBmdW5jdGllIExvZzEwIGJlcmVrZW50IGRlIGJhc2lzIDEwIGxvZ2FyaXRtZSB2YW4gZWxrIHBpeGVsIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0bG9nMk5hbWU6IFwiTG9nMlwiLFxuXHRcdGxvZzJTbmlwOiBcIkJlcmVrZW50IGRlIGJhc2lzIDIgbG9nYXJpdG1lIHZhbiBjZWxsZW4gaW4gZWVuIHJhc3Rlci5cIixcblx0XHRsb2cyRGVzYzogXCJEZSBmdW5jdGllIExvZzIgYmVyZWtlbnQgZGUgYmFzaXMgMiBsb2dhcml0bWUgdmFuIGVsayBwaXhlbCBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdGxvb2t1cE5hbWU6IFwiT3B6b2VrZW5cIixcblx0XHRsb29rdXBTbmlwOiBcIk1hYWt0IGVlbiBuaWV1dyByYXN0ZXIgZG9vciB3YWFyZGVuIG9wIHRlIHpvZWtlbiBkaWUgaW4gZWVuIGFuZGVyIHZlbGQgaW4gZGUgdGFiZWwgdmFuIGhldCBpbnZvZXJyYXN0ZXIgemlqbiBnZXZvbmRlbi5cIixcblx0XHRsb29rdXBEZXNjOiBcIkRlIGZ1bmN0aWUgbWFha3QgZWVuIG5pZXV3IHJhc3RlciBkb29yIHdhYXJkZW4gb3AgdGUgem9la2VuIGRpZSBpbiBlZW4gYW5kZXIgdmVsZCBpbiBkZSB0YWJlbCB2YW4gaGV0IGludm9lcnJhc3RlciB6aWpuIGdldm9uZGVuLlwiLFxuXHRcdG1sQ2xhc3NpZnlOYW1lOiBcIk1MIENsYXNzaWZpY2VyZW5cIixcblx0XHRtbENsYXNzaWZ5U25pcDogXCJDbGFzc2lmaWNlZXJ0IGFmYmVlbGRpbmdlbiBtZXQgYmVodWxwIHZhbiBlZW4gcGVyLXBpeGVsIGJlbmFkZXJpbmcuIEdlbWVuZ2RlIHBpeGVscyB3b3JkZW4gdG9lZ2V3ZXplbiBhYW4gaGV0IG9iamVjdCBtZXQgaGV0IGhvb2dzdGUgcGVyY2VudGFnZSBpbiBkYXQgcGl4ZWwuXCIsXG5cdFx0bWxDbGFzc2lmeURlc2M6IFwiTWV0IGRlIGZ1bmN0aWUgTUwgQ2xhc3NpZmljZXJlbiBrdW50IHUgb25kZXIgdG9lemljaHQgZWVuIGNsYXNzaWZpY2F0aWUgdWl0dm9lcmVuLCBtZXQgYmVodWxwIHZhbiBoZXQgY2xhc3NpZmljYXRpZS1hbGdvcml0bWUgdm9vciBtYXhpbWFsZSB3YWFyc2NoaWpubGlqa2hlaWQsIG9wIGVlbiByYXN0ZXJkYXRhc2V0IG9mIG1vemHDr2VrZGF0YXNldC4gVm9vciBkZXplIGZ1bmN0aWUgaXMgZWVuIGNsYXNzaWZpY2F0aWVzaWduYXR1dXJiZXN0YW5kIHZlcmVpc3QuXCIsXG5cdFx0bWFza05hbWU6IFwiTWFza2VyXCIsXG5cdFx0bWFza1NuaXA6IFwiU3RlbHQgd2FhcmRlbiBpbiBkaWUgdSBuaWV0IHdpbHQgd2VlcmdldmVuLlwiLFxuXHRcdG1hc2tEZXNjOiBcIkRlemUgcmFzdGVyZnVuY3RpZSBzdGVsdCB3YWFyZGVuIGluIGRpZSB1IG5pZXQgaW4gdXcgcmFzdGVyIHdpbHQgd2VlcmdldmVuLiBNZXQgYmVodWxwIHZhbiBkZSBmdW5jdGllIE1hc2tlciBnZWVmdCB1IGVlbiBvZiBtZWVyIE5vRGF0YS13YWFyZGVuIG9mIGVlbiByZWVrcyBnZWxkaWdlIHBpeGVsd2FhcmRlbiBvcC4gXCIsXG5cdFx0bWludXNOYW1lOiBcIk1pblwiLFxuXHRcdG1pbnVzU25pcDogXCJIaWVybWVlIHdvcmR0IGRlIHdhYXJkZSB2YW4gaGV0IHR3ZWVkZSBpbnZvZXJyYXN0ZXIgdmFuIGRlIHdhYXJkZSB2YW4gaGV0IGVlcnN0ZSBpbnZvZXJyYXN0ZXIgYWZnZXRyb2trZW4gb3AgZWVuIGNlbC12b29yLWNlbC1iYXNpcy5cIixcblx0XHRtaW51c0Rlc2M6IFwiRGUgZnVuY3RpZSBNaW51cyB0cmVrdCBkZSB3YWFyZGUgdmFuIGhldCB0d2VlZGUgaW52b2Vycm9vc3RlciBhZiB2YW4gZGUgd2FhcmRlIHZhbiBoZXQgZWVyc3RlIGludm9lcnJhc3RlciBvcCBlZW4gcGl4ZWwgcGVyIHBpeGVsIGJhc2lzLlwiLFxuXHRcdG1vZE5hbWU6IFwiTW9kXCIsXG5cdFx0bW9kU25pcDogXCJWaW5kdCBkZSByZXN0IChtb2R1bG8pIHZhbiBoZXQgZWVyc3RlIHJhc3RlciB3YW5uZWVyIGhldCBnZWRlZWxkIHdvcmR0IGRvb3IgaGV0IHR3ZWVkZSByYXN0ZXIgb3AgZWVuIGNlbC12b29yLWNlbCBiYXNpcy5cIixcblx0XHRtb2REZXNjOiBcIk1vZC1mdW5jdGllIHZpbmR0IGRlIHJlc3QgKG1vZHVsbykgdmFuIGhldCBlZXJzdGUgcmFzdGVyLCBnZWRlZWxkIGRvb3IgaGV0IHR3ZWVkZSByYXN0ZXIgb3AgZWVuIHBpeGVsLXZvb3ItcGl4ZWwgYmFzaXMuIERlIHZvbGdvcmRlIHZhbiBkZSBpbnZvZXIgaXMgYmVsYW5ncmlqayBlbiBiZcOvbnZsb2VkdCBoZXQgcmVzdWx0YWF0IHZhbiBkZSB1aXR2b2VyLlwiLFxuXHRcdG1vc2FpY1Jhc3RlcnNOYW1lOiBcIk1vemHDr2VrcmFzdGVyc1wiLFxuXHRcdG1vc2FpY1Jhc3RlcnNTbmlwOiBcIlZvZWd0IHZlcnNjaGlsbGVuZGUgcmFzdGVyZGF0YXNldHMgc2FtZW4gb20gw6nDqW4gZGF0YXNldCB0ZSBtYWtlbi5cIixcblx0XHRtb3NhaWNSYXN0ZXJzRGVzYzogXCJEZSBmdW5jdGllIE1vemHDr2VrcmFzdGVycyBtYWFrdCBlZW4gbW96YcOvZWthZmJlZWxkaW5nIHVpdCBtZWVyZGVyZSBhZmJlZWxkaW5nZW4uIFdhbm5lZXIgZXIgb3ZlcmxhcHBpbmcgaXMgdHVzc2VuIGRlIGFmYmVlbGRpbmdlbiwgemlqbiBlciB2ZXJzY2hpbGxlbmRlIG1ldGhvZGVuIHdhYXJ1aXQgdSBrdW50IGtpZXplbiBvbSB0ZSBiZXBhbGVuIHdlbGtlIGFmYmVlbGRpbmdlbiB3b3JkZW4gd2VlcmdlZ2V2ZW4uXCIsXG5cdFx0bmR2aUNvbG9yaXplZE5hbWU6IFwiTkRWSSBpbmdla2xldXJkXCIsXG5cdFx0bmR2aUNvbG9yaXplZFNuaXA6IFwiQ3Jlw6tlcnQgZWVuIG11bHRpYmFuZC1kYXRhc2V0IGRpZSBkZSBnZXpvbmRoZWlkIHZhbiBkZSB2ZWdldGF0aWUgdmVydGVnZW53b29yZGlndCwgb3AgYmFzaXMgdmFuIGhldCB2ZXJzY2hpbCB0dXNzZW4gZGUgcm9kZSBlbiBkZSBuYWJpai1pbmZyYXJvb2RiYW5kZW4uXCIsXG5cdFx0bmR2aUNvbG9yaXplZERlc2M6IFwiRGUgZnVuY3RpZSBORFZJIEluZ2VrbGV1cmQgcGFzdCBkZSBORFZJLWZ1bmN0aWUgdG9lIG9wIGhldCBpbnZvZXJiZWVsZCBlbiBnZWJydWlrdCB2ZXJ2b2xnZW5zIGVlbiBrbGV1cmthYXJ0IG9mIGtsZXVydmVybG9vcCBvbSBoZXQgcmVzdWx0YWF0IHdlZXIgdGUgZ2V2ZW4uXCIsXG5cdFx0bmR2aU5hbWU6IFwiTkRWSVwiLFxuXHRcdG5kdmlTbmlwOiBcIkJlcmVrZW50IGRlIE5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBWZWdldGF0aW9uIEluZGV4IChORFZJKVwiLFxuXHRcdG5kdmlEZXNjOiBcIkRlIE5EVkktZnVuY3RpZSBtYWFrdCBlZW4gZGF0YXNldCBtZXQgw6nDqW4gYmFuZCBkaWUgZGUgZ2V6b25kaGVpZCB2YW4gZGUgdmVnZXRhdGllIHdlZXJnZWVmdCwgb3AgYmFzaXMgdmFuIGhldCB2ZXJzY2hpbCB0dXNzZW4gZGUgcm9kZSBlbiBkZSBuYWJpai1pbmZyYXJvb2RiYW5kZW4uPGRpdj48YnIvPk5EVkkgaXMgZWVuIGdlc3RhbmRhYXJkaXNlZXJkZSBpbmRleCB6b2RhdCB1IGVlbiBiZWVsZCBrb210IHZvcm1lbiB2YW4gZGUgZ3JvZW5oZWlkLCBvb2sgd2VsIHJlbGF0aWV2ZSBiaW9tYXNzYSBnZW5vZW1kLiBEZXplIGluZGV4IG1hYWt0IGdlYnJ1aWsgdmFuIGhldCBjb250cmFzdCB2YW4gZGUga2VubWVya2VuIHZhbiBkZSB0d2VlIGJhbmRlbiB2YW4gZWVuIG11bHRpc3BlY3RyYWFsIHJhc3RlcmRhdGFzZXQ7IGRlIGNobG9yb2Z5bHBpZ21lbnRhYnNvcnB0aWUgaW4gZGUgcm9kZSBiYW5kIGVuIGRlIGhvZ2UgcmVmbGVjdGl2aXRlaXQgdmFuIHBsYW50YWFyZGlnZSBtYXRlcmlhbGVuIGluIGhldCBuYWJpai1pbmZyYXJvb2QgKE5JUikgYmFuZC4gRXh0cmVlbSBsYWdlIG9mIG5lZ2F0aWV2ZSBORFZJLXdhYXJkZW4gdmVydGVnZW53b29yZGlnZW4gZ2ViaWVkZW4gem9uZGVyIGVuaWdlIHZlZ2V0YXRpZSwgem9hbHMgd29sa2VuLCB3YXRlciBvZiBzbmVldXcuIFplZXIgbGFnZSB3YWFyZGVuIHZlcnRlZ2Vud29vcmRpZ2VuIGdlYmllZGVuIG1ldCB3ZWluaWcgdG90IGdlZW4gdmVnZXRhdGllLCB6b2FscyBiZXRvbiwgcm90c2VuIG9mIGthbGUgZ3JvbmQuIEdlbWF0aWdkZSB3YWFyZGVuIHZlcnRlZ2Vud29vcmRpZ2VuIGdlYmllZGVuIG1ldCBzdHJ1aWtlbiBlbiBncmFzbGFuZC4gSG9nZSB3YWFyZGVuIHZlcnRlZ2Vud29vcmRpZ2VuIGJvc2dlYmllZGVuIGVuIHdlZWxkZXJpZ2UgdmVnZXRhdGllLjwvZGl2PlwiLFxuXHRcdG5lZ2F0ZU5hbWU6IFwiTmVnYXRpZVwiLFxuXHRcdG5lZ2F0ZVNuaXA6IFwiV2lqemlndCBoZXQgdGVrZW4gKHZlcm1lbmlndnVsZGlnZCBtZXQgLTEpIHZhbiBkZSBjZWx3YWFyZGVuIHZhbiBoZXQgaW52b2VycmFzdGVyIG9wIGNlbCB2b29yIGNlbCBiYXNpcy5cIixcblx0XHRuZWdhdGVEZXNjOiBcIkRlIGZ1bmN0aWUgTmVnYXRpZSB2ZXJhbmRlcnQgaGV0IHRla2VuICh2ZXJtZW5kaWd2dWxnZCBtZXQgLTEpIHZhbiBkZSBwaXhlbHdhYXJkZW4gdmFuIGhldCBpbnZvZXJyYXN0ZXIgb3AgZWVuIHBpeGVsIFwiLFxuXHRcdG5pYmJsZU5hbWU6IFwiTmliYmxlXCIsXG5cdFx0bmliYmxlU25pcDogXCJWZXJ2YW5ndCBjZWxsZW4gdmFuIGVlbiByYXN0ZXIgZGllIG92ZXJlZW5rb21lbiBtZXQgZWVuIG1hc2tlciBtZXQgZGUgd2FhcmRlbiB2YW4gbmFhc3RlIGJ1cmVuLlwiLFxuXHRcdG5pYmJsZURlc2M6IFwiTWV0IGRlIGZ1bmN0aWUgTmliYmxlIGthbiBhYW4gZ2VzZWxlY3RlZXJkZSBnZWJpZWRlbiB2YW4gZWVuIHJhc3RlciBkZSB3YWFyZGUgdmFuIGh1biBkaWNodHN0YmlqemlqbmRlIGJ1dXIgd29yZGVuIHRvZWdld2V6ZW4uIERpdCBpcyBoYW5kaWcgdm9vciBoZXQgYmV3ZXJrZW4gdmFuIGdlYmllZGVuIHZhbiBlZW4gcmFzdGVyIHdhYXIgZGUgZ2VnZXZlbnMgbW9nZWxpamsgb25qdWlzdCB6aWpuLlwiLFxuXHRcdG5vdEVxdWFsTmFtZTogXCJOaWV0IGdlbGlqa1wiLFxuXHRcdG5vdEVxdWFsU25pcDogXCJWb2VydCBlZW4gUmVsYXRpb25lbGUgbmlldC0gZ2VsaWprLWFhbi1iZXdlcmtpbmcgdWl0IG9wIHR3ZWUgaW52b2VyZW4gb3AgY2VsLXZvb3ItY2VsIGJhc2lzLiBSZXRvdXJuZWVydCAxIHZvb3IgY2VsbGVuIHdhYXJ2YW4gaGV0IGVlcnN0ZSByYXN0ZXIgbmlldCBnZWxpamsgaXMgYWFuIGhldCB0d2VlZGUgcmFzdGVyIGVuIDAgYWxzIGhldCBnZWxpamsgaXMuXCIsXG5cdFx0bm90RXF1YWxEZXNjOiBcIkRlIGZ1bmN0aWUgdm9lcnQgZWVuIFJlbGF0aW9uZWxlLW5pZXQtZ2VsaWprLWFhbi1iZXdlcmtpbmcgdWl0IG9wIHR3ZWUgaW52b2VyZW4gb3AgZWVuIHBpeGVsLXBlci1waXhlbCBiYXNpcy4gSGV0IHJldG91cm5lZXJ0IGVlbiB3YWFyZGUgdmFuIDEgdm9vciBwaXhlbHMgd2FhcmJpaiBoZXQgZWVyc3RlIHJhc3RlciBuaWV0IGdlbGlqayBpcyBhYW4gaGV0IHR3ZWVkZSByYXN0ZXIgZW4gZWVuIHdhYXJkZSB2YW4gMCB2b29yIHBpeGVscyB3YWFyYmlqIGhldCBnZWxpamsgaXMgYWFuIGhldCB0d2VlZGUgcmFzdGVyLlwiLFxuXHRcdHBhbnNoYXJwZW5pbmdOYW1lOiBcIlBhbnNoYXJwZW5cIixcblx0XHRwYW5zaGFycGVuaW5nU25pcDogXCJWZXJob29ndCBrdW5zdG1hdGlnIGRlIHJ1aW10ZWxpamtlIHJlc29sdXRpZSB2YW4gZWVuIG11bHRpYmFuZGJlZWxkIGRvb3IgZGV6ZSB0ZSBmdXNlcmVuIG1ldCBlZW4gcGFuY2hyb21hdGlzY2ggYmVlbGQgbWV0IGhvZ2VyZSByZXNvbHV0aWUuXCIsXG5cdFx0cGFuc2hhcnBlbmluZ0Rlc2M6IFwiRGUgZnVuY3RpZSBQYW5zaGFycGVuaW5nIGdlYnJ1aWt0IGVlbiBwYW5jaHJvbWF0aXNjaCBiZWVsZCBtZXQgaG9nZXJlIHJlc29sdXRpZSBvZiBlZW4gcmFzdGVyYmFuZCBvbSB0ZSBmdXNlcmVuIG1ldCBlZW4gbXVsdGliYW5kIHJhc3RlcmRhdGFzZXQgbWV0IGVlbiBsYWdlcmUgcmVzb2x1dGllIG9tIGRlIHJ1aW10ZWxpamtlIHJlc29sdXRpZSB2YW4gaGV0IG11bHRpYmFuZGJlZWxkIHRlIHZlcmdyb3Rlbi48ZGl2Pjxici8+SGV0IGRvZWwgdmFuIHBhbnNoYXJwZW5pbmcgaXMgb20gZWVuIHZpc3VlZWwgYmVlbGQgdmFuIGhvZ2VyZSBrd2FsaXRlaXQgdGUgY3Jlw6tyZW4uIEFhbmdlemllbiBkZSB0ZWNobmlla2VuIGRlIHJhZGlvbWV0cmllIGVuIHNwZWN0cmFsZSBrYXJha3RlcmlzdGlla2VuIHZhbiBkZSBtdWx0aWJhbmRiZWVsZGVuIHZlcmFuZGVyZW4sIG1vZXRlbiBiZWVsZGVuIG1ldCBwYW5zaGFycGVuaW5nIHZvb3J6aWNodGlnIHdvcmRlbiBnZWJydWlrdCB2b29yIGFuYWx5dGlzY2hlIGRldGVjdGllZG9lbGVpbmRlbi48L2Rpdj5cIixcblx0XHRwYXRoQWxsb2NhdGlvbk5hbWU6IFwiUGFkYWZzdGFuZHRvZXdpanppbmdcIixcblx0XHRwYXRoQWxsb2NhdGlvblNuaXA6IFwiQmVyZWtlbnQgZGUgYnJvbiBtZXQgZGUgbGFhZ3N0ZSBrb3N0ZW4gdm9vciBlbGtlIGNlbCBvcCBiYXNpcyB2YW4gZGUgbWluc3QgY3VtdWxhdGlldmUga29zdGVuIG92ZXIgZWVuIGtvc3Rlbm9wcGVydmxhaywgd2FhcmJpaiByZWtlbmluZyB3b3JkdCBnZWhvdWRlbiBtZXQgZGUgb3BwZXJ2bGFrYWZzdGFuZCBzYW1lbiBtZXQgZGUgaG9yaXpvbnRhbGUgZW4gdmVydGljYWxlIGtvc3RlbmZhY3RvcmVuLlwiLFxuXHRcdHBhdGhBbGxvY2F0aW9uRGVzYzogXCJEZSBmdW5jdGllIFBhZGFmc3RhbmR0b2V3aWp6aW5nIGJlcmVrZW50IGRlIGRpY2h0c3RiaWp6aWpuZGUgYnJvbiB2b29yIGVsa2UgY2VsIG9wIGJhc2lzIHZhbiBkZSBtaW5zdCBjdW11bGF0aWV2ZSBrb3N0ZW4gb3ZlciBlZW4ga29zdGVub3BwZXJ2bGFrLCB3YWFyYmlqIHJla2VuaW5nIHdvcmR0IGdlaG91ZGVuIG1ldCBvcHBlcnZsYWthZnN0YW5kIGVuIGhvcml6b250YWxlIGVuIHZlcnRpY2FsZSBrb3N0ZW5mYWN0b3Jlbi5cIixcblx0XHRwYXRoQmFja0xpbmtOYW1lOiBcIlBhdGggRGlzdGFuY2UgQmFjayBMaW5rXCIsXG5cdFx0cGF0aEJhY2tMaW5rU25pcDogXCJEZWZpbmllZXJ0IGRlIGJ1dXIgZGllIGRlIHZvbGdlbmRlIGNlbCBpcyBvcCBoZXQgbWluc3QgY3VtdWxhdGlldmUga29zdGVucGFkIG5hYXIgZGUgYnJvbiBtZXQgZGUgbGFhZ3N0ZSBrb3N0ZW4sIHdhYXJiaWogcmVrZW5pbmcgd29yZHQgZ2Vob3VkZW4gbWV0IGRlIG9wcGVydmxha2Fmc3RhbmQgc2FtZW4gbWV0IGhvcml6b250YWxlIGVuIHZlcnRpY2FsZSBrb3N0ZW5mYWN0b3Jlbi5cIixcblx0XHRwYXRoQmFja0xpbmtEZXNjOiBcIkRlIGZ1bmN0aWUgUGF0aCBEaXN0YW5jZSBCYWNrIExpbmsgaWRlbnRpZmljZWVydCBkZSBkaXJlY3Rpb25hbGl0ZWl0IHZhbiBkZSBidXVyIGRpZSBkZSB2b2xnZW5kZSBjZWwgaXMgb3AgaGV0IG1pbnN0IGN1bXVsYXRpZXZlIGtvc3RlbnBhZCBuYWFyIGRlIGRpY2h0c3RiaWp6aWpuZGUgYnJvbiwgcmVrZW5pbmcgaG91ZGVuZCBtZXQgb3BwZXJ2bGFrYWZzdGFuZCBlbiBob3Jpem9udGFsZSBlbiB2ZXJ0aWNhbGUga29zdGVuZmFjdG9yZW4uXCIsXG5cdFx0cGF0aERpc3RhbmNlTmFtZTogXCJQYWRhZnN0YW5kXCIsXG5cdFx0cGF0aERpc3RhbmNlU25pcDogXCJCZXJla2VudCB2b29yIGVsa2UgY2VsIGRlIG1pbnN0IGN1bXVsYXRpZXZlIGtvc3RlbmFmc3RhbmQgdmFuIG9mIG5hYXIgZGUgYnJvbiBtZXQgZGUgbWluc3RlIGtvc3Rlbiwgd2FhcmJpaiByZWtlbmluZyB3b3JkdCBnZWhvdWRlbiBtZXQgb3BwZXJ2bGFrYWZzdGFuZCBzYW1lbiBtZXQgaG9yaXpvbnRhbGUgZW4gdmVydGljYWxlIGtvc3RlbmZhY3RvcmVuLlwiLFxuXHRcdHBhdGhEaXN0YW5jZURlc2M6IFwiRGUgZnVuY3RpZSBQYWRhZnN0YW5kIGJlcmVrZW50IHZvb3IgZWxrZSBjZWwgZGUgbWluc3QgY3VtdWxhdGlldmUga29zdGVuYWZzdGFuZCBuYWFyIGRlIGRpY2h0c3RiaWp6aWpuZGUgYnJvbiwgd2FhcmJpaiByZWtlbmluZyB3b3JkdCBnZWhvdWRlbiBtZXQgb3BwZXJ2bGFrYWZzdGFuZCBlbiBob3Jpem9udGFsZSBlbiB2ZXJ0aWNhbGUga29zdGVuZmFjdG9yZW4uXCIsXG5cdFx0cGx1c05hbWU6IFwiUGx1c1wiLFxuXHRcdHBsdXNTbmlwOiBcIlZvZWd0IGRlIHdhYXJkZW4gdmFuIHR3ZWUgcmFzdGVycyB0b2Ugb3AgZWVuIGNlbC12b29yLWNlbCBiYXNpcy5cIixcblx0XHRwbHVzRGVzYzogXCJQbHVzZnVuY3RpZSB2b2VndCBkZSB3YWFyZGVuIHZhbiB0d2VlIHJhc3RlcnMgb3AgZWVuIHBpeGVsLXZvb3ItcGl4ZWwgYmFzaXMgdG9lLlwiLFxuXHRcdHBvd2VyTmFtZTogXCJNYWNodFwiLFxuXHRcdHBvd2VyU25pcDogXCJWZXJob29ndCBkZSBjZWx3YWFyZGVuIGluIGVlbiByYXN0ZXIgbmFhciBkZSBtYWNodCB2YW4gZGUgd2FhcmRlbiBpbiBlZW4gYW5kZXIgcmFzdGVyLlwiLFxuXHRcdHBvd2VyRGVzYzogXCJEZSBmdW5jdGllIE1hY2h0IHZlcmhvb2d0IGRlIHBpeGVsd2FhcmRlbiBpbiBlZW4gcmFzdGVyIG5hYXIgZGUgbWFjaHQgdmFuIGRlIHdhYXJkZW4gZGllIGluIGVlbiBhbmRlciByYXN0ZXIgemlqbiBnZXZvbmRlbi5cIixcblx0XHRyYWRhckNhbGlicmF0aW9uTmFtZTogXCJSYWRhcmthbGlicmF0aWVcIixcblx0XHRyYWRhckNhbGlicmF0aW9uU25pcDogXCJDb252ZXJ0ZWVydCBSQURBUlNBVC0yLXRlcnVndmVyc3Ryb29paW5nLlwiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25EZXNjOiBcIkRlemUgZnVuY3RpZSBrYW4gd29yZGVuIGdlYnJ1aWt0IHZvb3IgaGV0IGthbGlicmVyZW4gdmFuIFJBREFSU0FULTItYmVlbGRlbiBpbiBlZW4gbW96YcOvZWtkYXRhc2V0IG9mIGFscyBlZW4gcmFzdGVycHJvZHVjdC4gS2FsaWJyYXRpZSB3b3JkdCB1aXRnZXZvZXJkIG9wIHJhZGFyYmVlbGRlbiwgem9kYXQgZGUgcGl4ZWx3YWFyZGVuIGVlbiBnZXRyb3V3ZSB3ZWVyZ2F2ZSB6aWpuIHZhbiBkZSB0ZXJ1Z3ZlcnN0cm9vaWluZyB2YW4gZGUgcmFkYXIuXCIsXG5cdFx0cmFzdGVySW5mb05hbWU6IFwiUmFzdGVySW5mb1wiLFxuXHRcdHJhc3RlckluZm9TbmlwOiBcIldpanppZ3QgZWlnZW5zY2hhcHBlbiB2YW4gaGV0IHJhc3Rlciwgem9hbHMgYml0ZGllcHRlLCBOb0RhdGEtd2FhcmRlLCBjZWxncm9vdHRlLCBlbnpvdm9vcnQuXCIsXG5cdFx0cmFzdGVySW5mb0Rlc2M6IFwiRGUgUmFzdGVyaW5mbyBvcGVudCBlZW4gZGlhbG9vZ3ZlbnN0ZXIgbWV0IGVpZ2Vuc2NoYXBwZW4gdmFuIHJhc3RlcmRhdGEsIHpvYWxzIGhldCBhYW50YWwga29sb21tZW4gZW4gcmlqZW4sIGhldCBhYW50YWwgYmFuZGVuLCBoZXQgcGl4ZWx0eXBlLCBkZSBvbXZhbmcgZW4gZGUgcnVpbXRlbGlqa2UgcmVmZXJlbnRpZS4gVSBrdW50IGRlemUgZWlnZW5zY2hhcHBlbiBiZXdlcmtlbiBkb29yIGVlbiByYXN0ZXJkYXRhc2V0IHRlIHNlbGVjdGVyZW4gZGllIHUgYWxzIHRlbXBsYXRlIGt1bnQgZ2VicnVpa2VuLiBcIixcblx0XHRyYXN0ZXJpemVBdHRyaWJ1dGVzTmFtZTogXCJBdHRyaWJ1dGVuIHJhc3RlcmVuXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc1NuaXA6IFwiVmVycmlqa3QgZWVuIHJhc3RlciBkb29yIGV4dHJhIGJhbmRlbiBkaWUgemlqbiBhZmdlbGVpZCB2YW4gd2FhcmRlbiB2YW4gZ2VzcGVjaWZpY2VlcmRlIGF0dHJpYnV0ZW4gdmFuIGVlbiBleHRlcm5lIHRhYmVsIG9mIGVlbiBvYmplY3RzZXJ2aWNlLlwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNEZXNjOiBcIkRlIGZ1bmN0aWUgQXR0cmlidXRlbiByYXN0ZXJlbiB2ZXJyaWprdCBlZW4gcmFzdGVyIGRvb3IgYmFuZGVuIHRvZSB0ZSB2b2VnZW4gZGllIHppam4gYWZnZWxlaWQgdmFuIHdhYXJkZW4gdmFuIGdlc3BlY2lmaWNlZXJkZSBhdHRyaWJ1dGVuLCB2YW4gZWVuIGV4dGVybmUgdGFiZWwgb2YgZWVuIG9iamVjdHNlcnZpY2UuIFUga3VudCBvcHRpb25lZWwgZWVuIHpvbmVyYXN0ZXIgZW4gaGV0IGJpamJlaG9yZW5kZSBrZW5tZXJrIHZvb3Igem9uZS1JRCBvcGdldmVuIG9tIHpvZWtlbiBvcCBiYXNpcyB2YW4gcmVnaW8ncyBpbiB0ZSBzY2hha2VsZW4uXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzTmFtZTogXCJPYmplY3RlbiByYXN0ZXJlblwiLFxuXHRcdHJhc3Rlcml6ZUZlYXR1cmVDbGFzc1NuaXA6IFwiQ29udmVydGVlcnQgb2JqZWN0ZW4gbmFhciByYXN0ZXIuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzRGVzYzogXCJNZXQgZGV6ZSBmdW5jdGllIHdvcmRlbiBwb2x5Z29vbi0sIHBvbHlsaWpuLSBlbiBwdW50b2JqZWN0a2xhc3NlZGF0YSBnZWNvbnZlcnRlZXJkIG5hYXIgZWVuIHJhc3RlcmxhYWcuPGRpdj48YnIvPkFhbiBvYmplY3RlbiB3b3JkZW4gcGl4ZWx3YWFyZGVuIHRvZWdld2V6ZW4gb3AgYmFzaXMgdmFuIE9CSkVDVElEIHZhbiBkZSBvYmplY3RlbiAoc3RhbmRhYXJkKS4gT3B0aW9uZWVsIGt1bm5lbiBkZSBwaXhlbHdhYXJkZW4gd29yZGVuIGdlYmFzZWVyZCBvcCBlZW4gdmVsZCBtZXQgZG9vciBkZSBnZWJydWlrZXIgZ2VkZWZpbmllZXJkZSB3YWFyZGVuIGluIGRlIGF0dHJpYnV1dHRhYmVsIHZhbiBoZXQgaW52b2Vyb2JqZWN0LjwvZGl2PlwiLFxuXHRcdHJlY2FzdE5hbWU6IFwiSGVyc2NoaWtrZW5cIixcblx0XHRyZWNhc3RTbmlwOiBcIldpanppZ3QgZGUgcGFyYW1ldGVycyB2YW4gZWVuIGZ1bmN0aWVrZXRlbiBpbiBlZW4gbW96YcOvZWtkYXRhc2V0IG9mIGJlZWxkc2VydmljZS4gRGl0IHdvcmR0IHZhYWsgZ2VicnVpa3QgbWV0IExBUy1kYXRhc2V0cyBvbSB0ZSB2b29ya29tZW4gZGF0IGVlbiBhZnpvbmRlcmxpamtlIG1vemHDr2VrZGF0YXNldCBtb2V0IHdvcmRlbiBnZW1hYWt0IHZvb3IgdmVyc2NoaWxsZW5kZSB3ZWVyZ2F2ZW4gdmFuIGhldCB0ZXJyZWluLlwiLFxuXHRcdHJlY2FzdERlc2M6IFwiRGUgZnVuY3RpZSBIZXJzY2hpa2tlbiB3b3JkdCBnZWJydWlrdCBvbSBkZSBmdW5jdGllcGFyYW1ldGVyIGRpZSBpbiBlZW4gbW96YcOvZWtkYXRhc2V0IG9mIGJlZWxkc2VydmljZSB3b3JkdCBnZWJydWlrdCwgZHluYW1pc2NoIHRlIHdpanppZ2VuIHpvbmRlciBkZSB3aWp6aWdpbmdlbiBmeXNpZWsgYWFuIHRlIGhvdWRlbi5cIixcblx0XHRyZWdpb25Hcm91cE5hbWU6IFwiUmVnaW9ncm9lcFwiLFxuXHRcdHJlZ2lvbkdyb3VwU25pcDogXCJWb29yIGVsa2UgY2VsIGluIGRlIHVpdHZvZXIgd29yZHQgZGUgaWRlbnRpZmljYXRpZSBnZXJlZ2lzdHJlZXJkIHZhbiBoZXQgYWFuZ2VzbG90ZW4gZ2ViaWVkIHdhYXJ0b2UgZGllIGNlbCBiZWhvb3J0LiBBYW4gZWxrZSByZWdpbyB3b3JkdCBlZW4gdW5pZWsgbnVtbWVyIHRvZWdld2V6ZW4uXCIsXG5cdFx0cmVnaW9uR3JvdXBEZXNjOiBcIkRlIGdsb2JhbGUgZnVuY3RpZSB2YW4gZGUgUmVnaW9ncm9lcCByZWdpc3RyZWVydCB2b29yIGVsa2UgY2VsIGluIGRlIHVpdHZvZXIgZGUgaWRlbnRpZmljYXRpZSB2YW4gaGV0IGFhbmdlc2xvdGVuIGdlYmllZCB3YWFydG9lIGRpZSBjZWwgYmVob29ydC4gQWFuIGVsa2UgcmVnaW8gd29yZHQgZWVuIHVuaWVrIG51bW1lciB0b2VnZXdlemVuLjxkaXY+PGJyLz5IZXQgZWVyc3RlIGdlc2NhbmRlIGdlYmllZCBrcmlqZ3Qgd2FhcmRlIMOpw6luLCBkZSB0d2VlZGUgdHdlZSwgZW56b3Zvb3J0LCB0b3RkYXQgYWFuIGFsbGUgZ2ViaWVkZW4gZWVuIHdhYXJkZSBpcyB0b2VnZXdlemVuLiBEZSBzY2FuIGJld2VlZ3QgdmFuIGxpbmtzIG5hYXIgcmVjaHRzIGVuIHZhbiBib3ZlbiBuYWFyIGJlbmVkZW4uIERlIHdhYXJkZW4gZGllIHppam4gdG9lZ2V3ZXplbiBhYW4gZGUgdWl0dm9lcnpvbmVzIHppam4gZ2ViYXNlZXJkIG9wIHdhbm5lZXIgemUgd29yZGVuIGdldm9uZGVuIHRpamRlbnMgaGV0IHNjYW5wcm9jZXMuPC9kaXY+XCIsXG5cdFx0cmVnaW9uR3Jvd05hbWU6IFwiUmVnaW9ncm9laVwiLFxuXHRcdHJlZ2lvbkdyb3dTbmlwOiBcIkxhYXQgcmVnaW8ncyBncm9laWVuIHZhbmFmIGJlZ2lucHVudGVuLlwiLFxuXHRcdHJlZ2lvbkdyb3dEZXNjOiBcIkRlIGZ1bmN0aWUgUmVnaW9ncm9lcCBncm9lcGVlcnQgbmFidXJpZ2UgcGl4ZWxzIGluIGdyb2VwZW4sIGFmaGFua2VsaWprIHZhbiBkZSBvcGdlZ2V2ZW4gcmFkaXVzIHZhbmFmIGhldCBiZWdpbnB1bnQuIEFhbiBkZSBncm9lcCBwaXhlbHMgb2Ygb2JqZWN0ZW4gd29yZHQgZWVuIG9wZ2VnZXZlbiB2dWx3YWFyZGUgdG9lZ2V3ZXplbi5cIixcblx0XHRyZW1hcE5hbWU6IFwiUmVtYXBcIixcblx0XHRyZW1hcFNuaXA6IFwiV2lqemlndCBwaXhlbHdhYXJkZW4gZG9vciBuaWV1d2Ugd2FhcmRlbiB0b2UgdGUgd2lqemVuIGFhbiBiZXJlaWtlbiB2YW4gcGl4ZWx3YWFyZGVuIG9mIGRvb3IgZWVuIGV4dGVybmUgdGFiZWwgdGUgZ2VicnVpa2VuLlwiLFxuXHRcdHJlbWFwRGVzYzogXCJNZXQgZGUgZnVuY3RpZSBSZW1hcCBrdW50IHUgZGUgcGl4ZWx3YWFyZGVuIHdpanppZ2VuIG9mIGhlcmluZGVsZW4gdmFuIGRlIHJhc3RlcmdlZ2V2ZW5zLiBEaXQga2FuIHdvcmRlbiBnZWRhYW4gZG9vciBlZW4gYmVyZWlrIHZhbiBwaXhlbHdhYXJkZW4gb3AgdGUgZ2V2ZW4gb20gYWFuIGVlbiB1aXR2b2VycGl4ZWx3YWFyZGUgdG9lIHRlIHdpanplbiwgb2YgZG9vciBlZW4gdGFiZWwgdGUgZ2VicnVpa2VuIG9tIGRlIHBpeGVsd2FhcmRlbiB0b2UgdGUgd2lqemVuIGFhbiBkZSB1aXR2b2VycGl4ZWx3YWFyZGUuXCIsXG5cdFx0cmVwcm9qZWN0TmFtZTogXCJIZXJwcm9qZWN0ZXJlblwiLFxuXHRcdHJlcHJvamVjdFNuaXA6IFwiV2lqemlndCBkZSBwcm9qZWN0aWUgdmFuIGVlbiByYXN0ZXJkYXRhc2V0LCBtb3phw69la2RhdGFzZXQgb2YgcmFzdGVyaXRlbSBpbiBlZW4gbW96YcOvZWtkYXRhc2V0LiBIZXQga2FuIG9vayBkZSBnZWdldmVucyByZXNhbXBsZW4gbmFhciBlZW4gbmlldXdlIGNlbGdyb290dGUgZW4gZWVuIG9vcnNwcm9uZyBkZWZpbmnDq3Jlbi5cIixcblx0XHRyZXByb2plY3REZXNjOiBcIkRlIGZ1bmN0aWUgT3BuaWV1dyBwcm9qZWN0ZXJlbiB3aWp6aWd0IGRlIHByb2plY3RpZSB2YW4gZWVuIHJhc3RlcmRhdGFzZXQsIG1vemHDr2VrZGF0YXNldCBvZiByYXN0ZXJpdGVtIGluIGVlbiBtb3phw69la2RhdGFzZXQuIEhldCBrYW4gb29rIGRlIGdlZ2V2ZW5zIHJlc2FtcGxlbiBuYWFyIGVlbiBuaWV1d2UgY2VsZ3Jvb3R0ZSBlbiBlZW4gb29yc3Byb25nIGRlZmluacOrcmVuLjxkaXY+PGJyLz5EZSBmdW5jdGllIE9wbmlldXcgcHJvamVjdGVyZW4ga2FuIHdvcmRlbiBnZWJydWlrdCBiaWogaGV0IG1ha2VuIHZhbiBlZW4gY2FjaGUgdWl0IGVlbiByYXN0ZXItIG9mIG1vemHDr2VrZGF0YXNldCBkaWUgemljaCBuaWV0IGluIGRlIHZlcmVpc3RlIHByb2plY3RpZSBiZXZpbmR0LiBBbHMgdSBiaWp2b29yYmVlbGQgZWVuIGdlY2FjaHRlIGltYWdlc2VydmljZSBtYWFrdCBkaWUgbW9nZWxpamsgd29yZHQgZ2XDr250ZWdyZWVyZCBkb29yIHRvZXBhc3NpbmdlbiBtZXQgYW5kZXJlIGNhY2hlZGllbnN0ZW4sIGlzIGhldCBiZWxhbmdyaWprIGRhdCB6ZSBhbGxlbWFhbCBpbiBkZXplbGZkZSBwcm9qZWN0aWUgemlqbi4gRGl0IGlzIHZhYWsgZWVuIFdlYiBNZXJjYXRvci1wcm9qZWN0aWUuIE9tZGF0IGRlIG1vemHDr2VrZGF0YXNldCBuaWV0IG9wbmlldXcga2FuIHdvcmRlbiBnZXByb2plY3RlZXJkLCBrdW50IHUgdHdlZSBkaW5nZW4gZG9lbuKAlHUga3VudCBlZW4gZ2VtYXJrZWVyZGUgbW96YcOvZWtkYXRhc2V0IG1ha2VuIHZhbiB1dyBtb3phw69la2RhdGFzZXQgaW4gZGUgYmVub2RpZ2RlIHByb2plY3RpZSwgb2YgZGUgZnVuY3RpZSBPcG5pZXV3IHByb2plY3RlcmVuIHRvZXZvZWdlbiBhYW4gZGUgZnVuY3RpZWtldGVuIHZhbiBkZSBtb3phw69la2RhdGFzZXQuIEVlbiBhbmRlciB2b29yYmVlbGQgZ2VicnVpa3QgZGV6ZSBmdW5jdGllIG9wIGhldCByYXN0ZXJpdGVtIGluIGVlbiBtb3phw69la2RhdGFzZXQuIEFscyB1IGRlIGZ1bmN0aWUgUmFzdGVyIGluIGNhY2hlIGdlYnJ1aWt0LCB3aWx0IHUgbW9nZWxpamsgZGUgZnVuY3RpZSBIZXJwcm9qZWN0ZW4gaW52b2VnZW4sIHpvZGF0IGRlIGNhY2hlIGluIGRlIG5pZXV3ZSBwcm9qZWN0aWUgd29yZHQgZ2VtYWFrdC4gUmFzdGVyaXRlbXMgaW4gZWVuIG1vemHDr2VrZGF0YXNldCBrdW5uZW4gaW4gZGUgY2FjaGUgd29yZGVuIG9wZ2VzbGFnZW4gd2FubmVlciBkZSB2ZXJ3ZXJraW5nIGludGVuc2llZiBpcyBlbiB1IGVlbiBzbmVsbGUgaW1hZ2VzZXJ2aWNlIHdpbHQgcHVibGljZXJlbiwgem9uZGVyIGRlIHZvbGxlZGlnZSBpbWFnZXNlcnZpY2UgaW4gY2FjaGUgb3AgdGUgc2xhYW4uPC9kaXY+XCIsXG5cdFx0cmVzYW1wbGVOYW1lOiBcIlJlc2FtcGxlXCIsXG5cdFx0cmVzYW1wbGVTbmlwOiBcIlZlcmFuZGVydCBkZSBjZWxncm9vdHRlIHZhbiBlZW4gcmFzdGVyLlwiLFxuXHRcdHJlc2FtcGxlRGVzYzogXCJEZSBmdW5jdGllIFJlc2FtcGxlIHdpanppZ3QgZGUgY2VsZ3Jvb3R0ZSwgaGV0IHJlc2FtcGxldHlwZSBvZiBiZWlkZS48ZGl2Pjxici8+RGUgZnVuY3RpZSBSZXNhbXBsZSBtYWcgYWxsZWVuIHdvcmRlbiBnZWJydWlrdCBtZXQgc3BlY2lmaWVrZSBjb21wdXRlcnZlcmVpc3RlbjsgYmlqdm9vcmJlZWxkIHdhbm5lZXIgdSBkZSB3aW5kIG9mIGRlIGh1aWRpZ2UgbWFnbml0dWRlcmljaHRpbmcgYmVyZWtlbnQgd2FhcnZvb3IgcmVzYW1wbGluZyB2YW51aXQgZGUgYnJvbnJlc29sdXRpZSBub2RpZyBpcy48L2Rpdj5cIixcblx0XHRyb3VuZERvd25OYW1lOiBcIk5hYXIgYmVuZWRlbiBhZnJvbmRlblwiLFxuXHRcdHJvdW5kRG93blNuaXA6IFwiUmV0b3VybmVlcnQgZGUgdm9sZ2VuZGUgbGFnZXJlIGdlaGVsZSB3YWFyZGUsIG5ldCB2b29yZ2VzdGVsZCBhbHMgZWVuIHp3ZXZlbmQgcHVudCwgdm9vciBlbGtlIGNlbCBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdHJvdW5kRG93bkRlc2M6IFwiRGUgZnVuY3RpZSBOYWFyIGJlbmVkZW4gYWZyb25kZW4gcmV0b3VybmVlcnQgaGV0IHZvbGdlbmRlIGxhZ2VyZSBnZWhlbGUgZ2V0YWwsIGFscyB6d2V2ZW5kZSBwdW50d2FhcmRlLCB2b29yIGVsa2UgcGl4ZWwgaW4gZWVuIHJhc3Rlci5cIixcblx0XHRyb3VuZFVwTmFtZTogXCJOYWFyIGJvdmVuIGFmcm9uZGVuXCIsXG5cdFx0cm91bmRVcFNuaXA6IFwiUmV0b3VybmVlcnQgZGUgdm9sZ2VuZGUgaG9nZXJlIGdlaGVsZSB3YWFyZGUsIG5ldCB2b29yZ2VzdGVsZCBhbHMgZWVuIHp3ZXZlbmQgcHVudCwgdm9vciBlbGtlIGNlbCBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdHJvdW5kVXBEZXNjOiBcIk5hYXIgYmVuZWRlbiBhZnJvbmRlbiByZXRvdXJuZWVydCBoZXQgdm9sZ2VuZGUgaG9nZXJlIGdlaGVsZSBnZXRhbCwgYWxzIHp3ZXZlbmRlIHB1bnR3YWFyZGUsIHZvb3IgZWxrZSBwaXhlbCBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnROYW1lOiBcIlNlZ21lbnQgTWVhbiBTaGlmdFwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnRTbmlwOiBcIkdyb2VwZWVyIGFhbmdyZW56ZW5kZSBwaXhlbHMgbWV0IHZlcmdlbGlqa2JhcmUgc3BlY3RyYWxlIGtlbm1lcmtlbiBzYW1lbiBpbiBzZWdtZW50ZW4uXCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdERlc2M6IFwiTWV0IGRlemUgZnVuY3RpZSBpZGVudGlmaWNlZXJ0IHUgdm9vcndlcnBlbiwgb2JqZWN0ZW4gb2Ygc2VnbWVudGVuIGluIHV3IGFmYmVlbGRpbmdlbiBkb29yIGFhbmdyZW56ZW5kZSBwaXhlbHMgc2FtZW4gdGUgdm9lZ2VuIGRpZSB2ZXJnZWxpamtiYXJlIHNwZWN0cmFsZSBlbiBydWltdGVsaWprZSBrZW5tZXJrZW4gaGViYmVuLiBVIGt1bnQgZGUgaG9ldmVlbGhlaWQgcnVpbXRlbGlqa2UgZW4gc3BlY3RyYWxlIGFmdmxha2tpbmcgcmVnZWxlbiBvbSB6byBpbnRlcmVzc2FudGUga2VubWVya2VuIGFmIHRlIGxlaWRlbi5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25OYW1lOiBcIlNlbnRpbmVsLTEgUmFkaW9tZXRyaXNjaGUga2FsaWJyYXRpZVwiLFxuXHRcdHMxUmFkaW9tZXRyaWNDYWxpYnJhdGlvblNuaXA6IFwiVm9lcnQgdmVyc2NoaWxsZW5kZSBzb29ydGVuIHJhZGlvbWV0cmlzY2hlIGthbGlicmF0aWUgdWl0IG9wIFNlbnRpbmVsLTEtZGF0YS5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25EZXNjOiBcIkRlemUgcmFzdGVyZnVuY3RpZSB2b2VydCBkcmllIHZlcnNjaGlsbGVuZGUga2FsaWJyYXRpZXMgdWl0IHZvb3IgU2VudGluZWwgMS1kYXRhc2V0cywgaW5jbHVzaWVmIGLDqHRhLW51bCBlbiBnYW1tYSwgZW4gdm9lcnQgZGUgZ2VrYWxpYnJlZXJkZSBkYXRhc2V0IHVpdC4gSGV0IGRvZWwgdmFuIGRlIFNBUi1rYWxpYnJhdGllIGlzIHNhdGVsbGlldGJlZWxkZW4gdGUgYmllZGVuIHdhYXJpbiBwaXhlbHdhYXJkZW4gZGlyZWN0IGt1bm5lbiB3b3JkZW4gZ2VyZWxhdGVlcmQgYWFuIGRlIHJhZGFydGVydWd2ZXJzdHJvb2lpbmcgdmFuIGRlIHNjZW5lLiBIb2V3ZWwgbmlldC1nZWthbGlicmVlcmRlIFNBUi1zYXRlbGxpZXRiZWVsZGVuIHZvbGRvZW5kZSB6aWpuIHZvb3IgZWVuIGt3YWxpdGF0aWVmIGdlYnJ1aWssIHppam4gZ2VrYWxpYnJlZXJkZSBTQVItYmVlbGRlbiBlc3NlbnRpZWVsIHZvb3IgaGV0IGt3YW50aXRhdGlldmUgZ2VicnVpayB2YW4gU0FSLWRhdGEuPGRpdj48YnIvPlR5cGlzY2hlIFNBUi1kYXRhdmVyd2Vya2luZywgZGllIGJlZWxkZW4gdmFuIG5pdmVhdSAxIHByb2R1Y2VlcnQsIG9tdmF0IGdlZW4gcmFkaW9tZXRyaXNjaGUgY29ycmVjdGllcyBlbiBzaWduaWZpY2FudGUgcmFkaW9tZXRyaXNjaGUgZ2VtaWRkZWxkZSBhZndpamtpbmdlbi4gRGFhcm9tIGlzIGhldCBub29kemFrZWxpamsgb20gcmFkaW9tZXRyaXNjaGUgY29ycmVjdGllIHRvZSB0ZSBwYXNzZW4gb3AgU0FSLWJlZWxkZW4sIHpvZGF0IGRlIHBpeGVsd2FhcmRlbiB2YW4gZGUgYWZiZWVsZGluZ2VuIGVjaHQgZGUgdGVydWd2ZXJzdHJvb2lpbmcgdmFuIGRlIHJhZGFyIHZhbiBoZXQgcmVmbGVjdGVyZW5kZSBvcHBlcnZsYWsgd2VlcmdldmVuLiBSYWRpb21ldHJpc2NoZSBjb3JyZWN0aWUgaXMgb29rIG5vZGlnIHZvb3IgZGUgdmVyZ2VsaWpraW5nIHZhbiBTQVItYmVlbGRlbiBkaWUgbWV0IHZlcnNjaGlsbGVuZGUgc2Vuc29yZW4gemlqbiB2ZXJrcmVnZW4gb2YgbWV0IGRlemVsZmRlIHNlbnNvciBvcCB2ZXJzY2hpbGxlbmRlIHRpamRzdGlwcGVuLCBpbiB2ZXJzY2hpbGxlbmRlIG1vZGkgb2YgZG9vciB2ZXJzY2hpbGxlbmRlIHByb2Nlc3NvcnMgemlqbiB2ZXJ3ZXJrdC48L2Rpdj5cIixcblx0XHRzMVRoZXJtYWxOb2lzZVJlbW92YWxOYW1lOiBcIlNlbnRpbmVsLTEgdGhlcm1pc2NoZSBydWlzIHZlcndpamRlcmVuXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsU25pcDogXCJWZXJ3aWpkZXJ0IHRoZXJtaXNjaGUgcnVpcyB1aXQgU2VudGluZWwtMS1kYXRhLlwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbERlc2M6IFwiVGhlcm1pc2NoZSBydWlzY29ycmVjdGllIGthbiB3b3JkZW4gdG9lZ2VwYXN0IG9wIFNlbnRpbmVsLTEgTGV2ZWwtMSBTaW5nbGUgTG9vayBDb21wbGV4IChTTEMpLXByb2R1Y3RlbiwgZXZlbmFscyBMZXZlbC0xIEdyb3VuZCBSYW5nZSBEZXRlY3Rpb24gKEdSRCktcHJvZHVjdGVuIGRpZSBub2cgbmlldCB6aWpuIGdlY29ycmlnZWVyZC4gRGUgb3BlcmF0b3Iga2FuIGRlemUgY29ycmVjdGllIG9vayB2ZXJ3aWpkZXJlbiBvcCBiYXNpcyB2YW4gZGUgcHJvZHVjdGFubm90YXRpZXMgb20gaGV0IHJ1aXNzaWduYWFsIGRhdCB3ZXJkIHZlcndpamRlcmQgb3BuaWV1dyBpbiB0ZSB2b2VyZW4gb20gaGV0IG9yaWdpbmVsZSBwcm9kdWN0IHRlIHByb2R1Y2VyZW4uIFByb2R1Y3Rhbm5vdGF0aWVzIHdvcmRlbiBvdmVyZWVua29tc3RpZyBiaWpnZXdlcmt0IG9tIGRlIGNvcnJlY3RpZSBvcG5pZXV3IHRvZSB0ZSBwYXNzZW4uIFwiLFxuXHRcdHNldE51bGxOYW1lOiBcIk51bGwgaW5zdGVsbGVuXCIsXG5cdFx0c2V0TnVsbFNuaXA6IFwiTnVsbCBpbnN0ZWxsZW4gc3RlbHQgZGUgZ2XDr2RlbnRpZmljZWVyZGUgY2VsbG9jYXRpZXMgaW4gb3AgTm9EYXRhLCBvcCBiYXNpcyB2YW4gZGUgc3BlY2lmaWVrZSBjcml0ZXJpYS4gSGV0IHJldG91cm5lZXJ0IE5vRGF0YSBhbHMgZGUgdm9vcndhYXJkZWxpamtlIGV2YWx1YXRpZSB3YWFyIGlzIGVuIHJldG91cm5lZXJ0IGRlIHdhYXJkZSBnZXNwZWNpZmljZWVyZCBkb29yIGVlbiBhbmRlciByYXN0ZXIgYWxzIGhldCBvbndhYXIgaXMuXCIsXG5cdFx0c2V0TnVsbERlc2M6IFwiRGUgZnVuY3RpZSBOdWxsIGluc3RlbGxlbiBzdGVsdCBkZSBnZcOvZGVudGlmaWNlZXJkZSBwaXhlbHMgaW4gb3AgTm9EYXRhLCBvcCBiYXNpcyB2YW4gZGUgc3BlY2lmaWVrZSBjcml0ZXJpYS4gSGV0IHJldG91cm5lZXJ0IE5vRGF0YSBhbHMgZGUgdm9vcndhYXJkZWxpamtlIGV2YWx1YXRpZSB3YWFyIGlzICgxKSBvZiByZXRvdXJuZWVydCBkZSB3YWFyZGUgZ2VzcGVjaWZpY2VlcmQgaW4gaGV0IG9ud2FyZSByYXN0ZXIgYWxzIGRlIHZvb3J3YWFyZGVsaWprZSBldmFsdWF0aWUgb253YWFyIGlzICgwKS4gRGl0IGNyaXRlcml1bSB3b3JkdCBnZXNwZWNpZmljZWVyZCBkb29yIGRlIHVpdHZvZXIgdmFuIGVlbiBsb2dpc2NoZSByZWtlbmt1bmRpZ2UgZnVuY3RpZSwgZGllIGhldCBpbnZvZXJyYXN0ZXIgemFsIHppam4uXCIsXG5cdFx0c2hhZGVkUmVsaWVmTmFtZTogXCJTaGFkZWQgUmVsaWVmXCIsXG5cdFx0c2hhZGVkUmVsaWVmU25pcDogXCJDcmXDq2VydCBlZW4gbXVsdGliYW5kLCBrbGV1cmdlY29kZWVyZGUgM0Qtd2VlcmdhdmUgdmFuIGhldCBvcHBlcnZsYWssIHdhYXJiaWogZGUgcmVsYXRpZXZlIHBvc2l0aWUgdmFuIGRlIHpvbiBpbiBhYW5tZXJraW5nIHdvcmR0IGdlbm9tZW4gdm9vciBoZXQgdmVyZHVpc3RlcmVuIHZhbiBoZXQgYmVlbGQuXCIsXG5cdFx0c2hhZGVkUmVsaWVmRGVzYzogXCJEZSBmdW5jdGllIFNoYWRlZCBSZWxpZWYgY3Jlw6tlcnQgZWVuIDNELXdlZXJnYXZlIGluIGtsZXVyIHZhbiBoZXQgdGVycmVpbiBkb29yIGRlIGJlZWxkZW4gdmFuIGRlIGhvb2d0ZWNvZGVyaW5nIGVuIGRlIHJlbGnDq2ZzY2hhZHV3bWV0aG9kZW4gc2FtZW4gdGUgdm9lZ2VuLiBEZXplIGZ1bmN0aWUgZ2VicnVpa3QgZGUgaG9vZ3RlLSBlbiBhemltdXRoZWlnZW5zY2hhcHBlbiBvbSBkZSBwb3NpdGllIHZhbiBkZSB6b24gdGUgYmVwYWxlbi48ZGl2Pjxici8+PC9kaXY+XCIsXG5cdFx0c2luSE5hbWU6IFwiU2luSFwiLFxuXHRcdHNpbkhTbmlwOiBcIkJlcmVrZW50IGRlIGh5cGVyYm9sZSBzaW51cyB2YW4gY2VsbGVuIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0c2luSERlc2M6IFwiRGUgZnVuY3RpZSBiZXJla2VudCBkZSBoeXBlcmJvbGUgc2ludXMgdmFuIGRlIHBpeGVscyBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdHNpbk5hbWU6IFwiU2luXCIsXG5cdFx0c2luU25pcDogXCJCZXJla2VudCBkZSBzaW51cyB2YW4gY2VsbGVuIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0c2luRGVzYzogXCJEZSBmdW5jdGllIGJlcmVrZW50IGRlIHNpbnVzIHZhbiBkZSBwaXhlbHMgaW4gZWVuIHJhc3Rlci5cIixcblx0XHRzbG9wZU5hbWU6IFwiSGVsbGluZ1wiLFxuXHRcdHNsb3BlU25pcDogXCJCZXJla2VudCBkZSB2ZXJhbmRlcmluZ3NzbmVsaGVpZCB2YW4gw6nDqW4gcGl4ZWx3YWFyZGUgbmFhciB6aWpuIGJ1cmVuLlwiLFxuXHRcdHNsb3BlRGVzYzogXCJEZXplIHJhc3RlcmZ1bmN0aWUgYmVyZWtlbnQgZGUgaGVsbGluZyBlbiBnZWVmdCBkZSBtYXRlIHZhbiB2ZXJhbmRlcmluZyBpbiBkZSBob29ndGUgd2VlciB2b29yIGVsa2UgcGl4ZWwgdmFuIGhldCBkaWdpdGFhbCBlbGV2YXRpZW1vZGVsIChERU0pLiBIZXQgaXMgZGUgZWVyc3RlIGFmZ2VsZWlkZSB2YW4gZWVuIERFTS48ZGl2Pjxici8+RGV6ZSBmdW5jdGllIGdlYnJ1aWt0IGVlbiB2ZXJzbmVsZGUgYXRhbigpLWZ1bmN0aWUuIEhldCBpcyB6ZXMga2VlciBzbmVsbGVyIGVuIGRlIGJlbmFkZXJpbmdzZm91dCBpcyBhbHRpamQgbWluZGVyIGRhbiAwLDMgZ3JhZGVuLjwvZGl2PlwiLFxuXHRcdHNwZWNrbGVOYW1lOiBcIlNwaWtrZWxcIixcblx0XHRzcGVja2xlU25pcDogXCJCaWVkdCBmaWx0ZXJzIG9tIGRlIHJ1aXMgd2VnIHRlIG5lbWVuIHZhbiByYWRhcmRhdHNldHMgdmFuIHN5bnRoZXRpc2NoZSBhcGVydHV1ci5cIixcblx0XHRzcGVja2xlRGVzYzogXCJTcGlra2VsIGlzIGRlIGhvb2dmcmVxdWVudGUgcnVpcyBvcCByYWRhcmdlZ2V2ZW5zLiBEZSBhZmJlZWxkaW5nZW4gZ2VnZW5lcmVlcmQgZG9vciBzeW50aGV0aXNjaGUgYXBlcnR1dXJyYWRhciAoU0FSKS1zeXN0ZW1lbiB6aWpuIHN0ZXJrIG9uZGVyaGV2aWcgYWFuIHNwaWtrZWxlZmZlY3RlbiBkb29yIGRlIHZlcndlcmtpbmcgdmFuIHZlcnN0cm9vaWRlIHNpZ25hbGVuIGVuIGludGVyZmVyZW50aWUgdmFuIGVsZWt0cm9tYWduZXRpc2NoZSBnb2x2ZW4gZGllIHdvcmRlbiB2ZXJzdHJvb2lkIHZhbiBvcHBlcnZsYWtrZW4gb2Ygb2JqZWN0ZW4uIERlemUgU3Bpa2tlbC1mdW5jdGllIGZpbHRlcnQgZGUgZ2VzcGlra2VsZGUgcmFkYXJkYXRhc2V0IGVuIGVmZmVudCBkZSBydWlzIG1ldCBiZWhvdWQgdmFuIGRlIHJhbmRlbiBvZiBzY2hlcnBlIG9iamVjdGVuIGluIGRlIGFmYmVlbGRpbmcuXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uTmFtZTogXCJTcGVjdHJhbGUgY29udmVyc2llXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uU25pcDogXCJQYXN0IGVlbiBtYXRyaXggdG9lIG9wIGVlbiBtdWx0aWJhbmQtYWZiZWVsZGluZy5cIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25EZXNjOiBcIkRlIGZ1bmN0aWUgU3BlY3RyYWxlIGNvbnZlcnNpZSBwYXN0IGVlbiBtYXRyaXggdG9lIG9wIGVlbiBtdWx0aWJhbmQtYWZiZWVsZGluZyBvbSBkZSBrbGV1cndhYXJkZW4gdmFuIGRlIHVpdHZvZXIgdGUgYmXDr252bG9lZGVuLjxkaXY+PGJyLz5Tb21taWdlIHNlbnNvcmVuIHZlcnphbWVsZW4gZ2VlbiBibGF1d2UgYmFuZGVuIHZhbndlZ2UgZWVuIGxhZ2UgdmVyaG91ZGluZyB0dXNzZW4gc2lnbmFhbCBlbiBydWlzLiBEaXQga2FuIGJpanZvb3JiZWVsZCB3b3JkZW4gZ2VicnVpa3Qgb20gZWVuIGluZnJhcm9vZGJlZWxkIG1ldCB2YWxzZSBrbGV1cmVuIG9tIHRlIHpldHRlbiBpbiBlZW4gbWVlciBuYXR1dXJsaWprZSBrbGV1cmVuYWZiZWVsZGluZy48L2Rpdj5cIixcblx0XHRzcXVhcmVSb290TmFtZTogXCJWaWVya2FudHN3b3J0ZWxcIixcblx0XHRzcXVhcmVSb290U25pcDogXCJCZXJla2VudCBkZSB2aWVya2FudHN3b3J0ZWwgdmFuIGRlIGNlbGxlbiBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdHNxdWFyZVJvb3REZXNjOiBcIkRlIGZ1bmN0aWUgVmllcmthbnRzd29ydGVsIGJlcmVrZW50IGRlIHZpZXJrYW50c3dvcnRlbCB2YW4gZGUgcGl4ZWx3YWFyZGVuIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0c3F1YXJlTmFtZTogXCJWaWVya2FudFwiLFxuXHRcdHNxdWFyZVNuaXA6IFwiQmVyZWtlbnQgaGV0IHZpZXJrYW50IHZhbiBkZSBjZWxsZW4gaW4gZWVuIHJhc3Rlci5cIixcblx0XHRzcXVhcmVEZXNjOiBcIkRlIGZ1bmN0aWUgVmllcmthbnQgYmVyZWtlbnQgaGV0IHZpZXJrYW50IHZhbiBkZSBwaXhlbHdhYXJkZW4gaW4gZWVuIHJhc3Rlci5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtTmFtZTogXCJTdGF0aXN0aWVrZW4gZW4gaGlzdG9ncmFtXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbVNuaXA6IFwiU3RhdGlzdGlla2VuIGVuIGhpc3RvZ3JhbSBkZWZpbmnDq3JlbiBvZiBrb3BwZWxlbi5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtRGVzYzogXCJEZSBmdW5jdGllIFN0YXRpc3RpZWtlbiBlbiBoaXN0b2dyYW0gd29yZHQgZ2VicnVpa3Qgb20gZGUgc3RhdGlzdGlla2VuIGVuIGhldCBoaXN0b2dyYW0gdmFuIGVlbiByYXN0ZXIgdGUgZGVmaW5pw6tyZW4uIFUga3VudCBkZXplIGZ1bmN0aWUgYWFuIGhldCBlaW5kZSB2YW4gZGUgZnVuY3RpZWtldGVuIGludm9lZ2VuIG9tIGRlIHN0YXRpc3RpZWtlbiBlbiBoZXQgaGlzdG9ncmFtIHZhbiBlZW4gcmFzdGVyIGZ1bmN0aW9uIHRlbXBsYXRlIChSRlQpIHRlIGJlc2NocmlqdmVuLiBEaXQga2FuIG5vZGlnIHppam4gb20gZGUgc3RhbmRhYXJkd2VlcmdhdmUgdmFuIGhldCB2ZXJ3ZXJraW5nc3Jlc3VsdGFhdCB0ZSByZWdlbGVuLCB2b29yYWwgYmlqIGhldCBkZWZpbmnDq3JlbiB2YW4gZWVuIGZ1bmN0aWVrZXRlbiBkaWUgdmVlbCBmdW5jdGllcyBiZXZhdC48ZGl2Pjxici8+VSBrdW50IHN0YXRpc3RpZWtlbiBkZWZpbmnDq3JlbiBkb29yIGRlIHdhYXJkZW4gaW4gdGUgdm9lcmVuIG9mIHRlIGltcG9ydGVyZW4gdWl0IGVlbiByYXN0ZXJkYXRhc2V0IG9mIGVlbiBYTUwtYmVzdGFuZC4gSGlzdG9ncmFtbWVuIGt1bm5lbiBhbGxlZW4gd29yZGVuIGdlZGVmaW5pZWVyZCBkb29yIGVlbiBiZXN0YW5kIHRlIGltcG9ydGVyZW4uPC9kaXY+XCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGlla2VuXCIsXG5cdFx0c3RhdGlzdGljc1NuaXA6IFwiQmVyZWtlbnQgZm9jYWxlIHN0YXRpc3RpZWtlbiB2b29yIGVsa2UgcGl4ZWwgdmFuIGVlbiBhZmJlZWxkaW5nIG9wIGJhc2lzIHZhbiBlZW4gZ2VkZWZpbmllZXJkZSBmb2NhbGUgYnV1cnQuXCIsXG5cdFx0c3RhdGlzdGljc0Rlc2M6IFwiRGUgZnVuY3RpZSBTdGF0aXN0aWVrZW4gYmVyZWtlbnQgZm9jYWxlIHN0YXRpc3RpZWtlbiB2b29yIGVsa2UgcGl4ZWwgdmFuIGVlbiBhZmJlZWxkaW5nIG9wIGJhc2lzIHZhbiBlZW4gZ2VkZWZpbmllZXJkZSBmb2NhbGUgYnV1cnQuPGRpdj48YnIvPkRlIGZ1bmN0aWUgU3RhdGlzdGlla2VuIGthbiB3b3JkZW4gZ2VicnVpa3Qgb20gZ2Vkcm9wdGUgbGlqbmVuIGluIGVlbiBhZmJlZWxkaW5nIHRlIHZ1bGxlbi4gR2Vkcm9wdGUgbGlqbmVuIHdvcmRlbiB2YWFrIHZlcm9vcnphYWt0IGRvb3IgcHJvYmxlbWVuIGluIGRlIHNlbnNvciB3YWFyIGdlZW4gZGF0YSB3b3JkdCB2ZXJ6YW1lbGQuIERpdCBpcyBnZWJldXJkIGluIHNlbnNvcmVuIHpvYWxzIExhbmRzYXQgNydzIEVuaGFuY2VkIFRoZW1hdGljIE1hcHBlciBQbHVzIChFVE0rKS4gRGV6ZSBvbnRicmVrZW5kZSBnZWdldmVucyB2ZXJvb3J6YWtlbiBwcm9ibGVtZW4gdm9vciBkZSBhbmFseXNlIGVuIG9vayBiaWogaGV0IGJla2lqa2VuIHZhbiBkZSBhZmJlZWxkaW5nZW4uIEVyIGlzIHdlaW5pZyBkYXQga2FuIHdvcmRlbiBnZWRhYW4gd2FubmVlciBkZSBiZWVsZGVuIHdvcmRlbiBnZWJydWlrdCB2b29yIGFuYWx5c2U7IGFscyBlciBlY2h0ZXIgZWVuIG92ZXJsYXBwZW5kZSBhZmJlZWxkaW5nIGlzLCBrYW4gZGV6ZSB3b3JkZW4gZ2VicnVpa3QgaW4gcGxhYXRzIHZhbiBkZSBvbnRicmVrZW5kZSBpbmhvdWQuIEhldHplbGZkZSBrYW4gd29yZGVuIGdlZGFhbiBhbHMgZGUgYWZiZWVsZGluZyB3b3JkdCBnZWJydWlrdCB2b29yIHZpc3VhbGlzYXRpZS4gRXIgaXMgZWNodGVyIG5pZXQgYWx0aWpkIGVlbiBleHRyYSBhZmJlZWxkaW5nIG9tIGRlIG9udGJyZWtlbmRlIGluaG91ZCBpbiB0ZSB2dWxsZW4sIGR1cyBkZXplIG1vZXQgd29yZGVuIGFmZ2VsZWlkIHZhbiBkZSBiZXN0YWFuZGUgZ2VnZXZlbnMuPC9kaXY+XCIsXG5cdFx0c3RyZWFtTGlua05hbWU6IFwiU3RyZWFtIExpbmtcIixcblx0XHRzdHJlYW1MaW5rU25pcDogXCJXaWpzdCB1bmlla2Ugd2FhcmRlbiB0b2UgYWFuIHNlY3RpZXMgdmFuIGVlbiByYXN0ZXItbGluZWFpciBuZXR3ZXJrIHR1c3NlbiBrcnVpc3B1bnRlbi5cIixcblx0XHRzdHJlYW1MaW5rRGVzYzogXCJEZSBnbG9iYWxlIGZ1bmN0aWUgU3RyZWFtIExpbmsgd2lqc3QgdW5pZWtlIHdhYXJkZW4gdG9lIGFhbiBzZWN0aWVzIHZhbiBlZW4gcmFzdGVyLWxpbmVhaXIgbmV0d2VyayB0dXNzZW4ga3J1aXNwdW50ZW4uPGRpdj48YnIvPkxpbmtzIHppam4gZGUgc2VjdGllcyB2YW4gZWVuIHN0cm9vbWthbmFhbCBkYXQgdHdlZSBvcGVlbnZvbGdlbmRlIGtydWlzcHVudGVuIHZlcmJpbmR0LCBlZW4ga3J1aXNwdW50IGVuIGRlIHVpdHZvZXIgb2YgZWVuIGtydWlzcHVudCBlbiBkZSBhZnZvZXJrbG9vZi4gSW4gZGUgaHlkcm9sb2dpZSB3b3JkZW4gZGV6ZSBzdHJlYW1zZWdtZW50ZW4gYmVyZWlrZW4gZ2Vub2VtZC4gRWVuIGtydWlzcHVudCBpcyBnZXJlbGF0ZWVyZCBhYW4gZWVuIHN0b3J0cHVudCBlbiBoZWxwdCBiaWogaGV0IGFmYmFrZW5lbiB2YW4gZWVuIHN0cm9vbWdlYmllZCBvZiBkcmFpbmFnZWJla2tlbmdyZW5zLjwvZGl2PlwiLFxuXHRcdHN0cmV0Y2hOYW1lOiBcIlVpdHJla2tlblwiLFxuXHRcdHN0cmV0Y2hTbmlwOiBcIlZlcmJldGVydCBlZW4gYWZiZWVsZGluZyBkb29yIGhldCB3ZWVyZ2VnZXZlbiB3YWFyZGViZXJlaWsgYWFuIHRlIHBhc3Nlbi4gRGl0IHZlcmFuZGVydCBuaWV0cyBhYW4gZGUgb25kZXJsaWdnZW5kZSBwaXhlbHdhYXJkZW4uIEFscyBlZW4gcGl4ZWwgZWVuIHdhYXJkZSBidWl0ZW4gaGV0IG9wZ2VnZXZlbiBiZXJlaWsgaGVlZnQsIHdvcmR0IGRlemUgd2VlcmdlZ2V2ZW4gYWxzIGRlIG1pbmltdW0tIG9mIG1heGltdW13YWFyZGUuXCIsXG5cdFx0c3RyZXRjaERlc2M6IFwiRGUgZnVuY3RpZSBVaXRyZWtrZW4gdmVyYmV0ZXJ0IGVlbiBhZmJlZWxkaW5nIGRvb3IgZWlnZW5zY2hhcHBlbiB6b2FscyBoZWxkZXJoZWlkLCBjb250cmFzdCBlbiBnYW1tYSB0ZSB3aWp6aWdlbiBkb29yIG1pZGRlbCB2YW4gbWVlcmRlcmUgdWl0dHJla3R5cGVzLiBEZXplIGZ1bmN0aWUgZ2VicnVpa3QgZGUgc3RhdGlzdGlla2VuIHZhbiBkZSByYXN0ZXJzIGJpbm5lbiBkZSBtb3phw69la2RhdGFzZXQ7IGRhYXJvbSBtb2V0IHUgYWxzIHUgZGV6ZSBmdW5jdGllIGdlYnJ1aWt0IGVydm9vciB6b3JnZW4gZGF0IGRlIHN0YXRpc3RpZWtlbiB6aWpuIGJlcmVrZW5kLjxkaXY+PGJyLz5IZXQgdWl0cmVrdHlwZSBkZWZpbmllZXJ0IGVlbiBoaXN0b2dyYW1yZWsgZGllIG9wIGRlIHJhc3RlcnMgd29yZHQgdG9lZ2VwYXN0IG9tIGh1biB1aXRlcmxpamsgdGUgdmVyYmV0ZXJlbi4gVWl0cmVra2VuIHZlcmJldGVydCBkZSB3ZWVyZ2F2ZSB2YW4gZGUgZGF0YSBkb29yIGRlIHBpeGVsd2FhcmRlbiBsYW5ncyBlZW4gaGlzdG9ncmFtIHRlIHZlcnNwcmVpZGVuIHZhbiBkZSBtaW5pbXVtLSBlbiBtYXhpbXVtd2FhcmRlbiBkaWUgd29yZGVuIGdlZGVmaW5pZWVyZCBkb29yIGh1biBiaXRkaWVwdGUuIDwvZGl2PlwiLFxuXHRcdHN3YXRoTmFtZTogXCJTd2F0aFwiLFxuXHRcdHN3YXRoU25pcDogXCJJbnRlcnBvbGVlcnQgdmFuIG9ucmVnZWxtYXRpZ2UgcmFzdGVycyBvZiBzd2F0aC1kYXRhLlwiLFxuXHRcdHN3YXRoRGVzYzogXCJTb21taWdlIG5ldENERi0gb2YgSERGLWRhdGFzZXRzIHNsYWFuIGh1biBnZW9sb2NhdGllIG9wIGFscyBvbnJlZ2VsbWF0aWcgdmVyZGVlbGRlIHJpamVuLiBCaWogaGV0IHRvZXZvZWdlbiB2YW4gZGV6ZSBkYXRhc2V0cyBhYW4gZWVuIG1vemHDr2VrZGF0YXNldCwgbmVlbXQgZGUgZnVuY3RpZSBzd2F0aCBkZSBvbnJlZ2VsbWF0aWcgZ2VyYXN0ZXJkZSBnZWdldmVucyBvcCBlbiBoZXJ2ZXJ6YW1lbHQgZGV6ZSB6b2RhdCBlbGtlIHBpeGVsIGVlbiB1bmlmb3JtZSBncm9vdHRlIGhlZWZ0IGVuIHZpZXJrYW50IGlzLjxkaXY+PGJyLz5CaWogaGV0IHRvZXZvZWdlbiB2YW4gdmFyaWFiZWxlbiB1aXQgbmV0Q0RGIG9mIEhERiBhYW4gZWVuIG1vemHDr2VrZGF0YXNldCwgd29yZHQgYXV0b21hdGlzY2ggZ2Vjb250cm9sZWVyZCBvZiBkZSBnZWdldmVucyByZWdlbG1hdGlnIHdvcmRlbiBnZXJhbmdzY2hpa3QuIEFscyBkYXQgbmlldCBoZXQgZ2V2YWwgaXMsIHdvcmR0IGRlIGZ1bmN0aWUgc3dhdGggYXV0b21hdGlzY2ggdG9lZ2VwYXN0IG9tIGhldCBvbnJlZ2VsbWF0aWdlIHJhc3RlciBvbSB0ZSB6ZXR0ZW4gaW4gcHVudGVuIGVuIHZlcnZvbGdlbnMgbmFhciBlZW4gcm9vc3RlciBkYXQgcmVnZWxtYXRpZyB3b3JkdCBnZXJhc3RlcmQuIFUga3VudCBkZSBpbnRlcnBvbGF0aWVtZXRob2RlIGVuIGRlIGNlbGdyb290dGUgd2lqemlnZW4gZGllIHdvcmRlbiBnZWJydWlrdCBpbiBkZSBzd2F0aCByYXN0ZXItZnVuY3RpZS4gVm9vciByYXN0ZXJkYXRhIG9wIHJlZ2VsbWF0aWdlIGFmc3RhbmRlbiB3b3JkdCBnZWVuIGludGVycG9sYXRpZSB0b2VnZXBhc3QgZW4gd29yZGVuIGRlIGdlZ2V2ZW5zIGdlbGV6ZW4gem9hbHMgemUgemlqbi48L2Rpdj5cIixcblx0XHR0YW5ITmFtZTogXCJUYW5IXCIsXG5cdFx0dGFuSFNuaXA6IFwiQmVyZWtlbnQgZGUgaHlwZXJib2xlIHRhbmdlbnMgdmFuIGNlbGxlbiBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdHRhbkhEZXNjOiBcIkRlIGZ1bmN0aWUgYmVyZWtlbnQgZGUgaHlwZXJib2xlIHRhbmdlbnMgdmFuIGRlIHBpeGVscyBpbiBlZW4gcmFzdGVyLlwiLFxuXHRcdHRhbk5hbWU6IFwiVGFuXCIsXG5cdFx0dGFuU25pcDogXCJCZXJla2VudCBkZSB0YW5nZW5zIHZhbiBjZWxsZW4gaW4gZWVuIHJhc3Rlci5cIixcblx0XHR0YW5EZXNjOiBcIkRlIGZ1bmN0aWUgYmVyZWtlbnQgZGUgdGFuZ2VucyB2YW4gZGUgcGl4ZWxzIGluIGVlbiByYXN0ZXIuIFwiLFxuXHRcdHRhc3NlbGVkQ2FwTmFtZTogXCJUYXNzZWxlZCBDYXAgKEthdXRoLVRob21hcylcIixcblx0XHR0YXNzZWxlZENhcFNuaXA6IFwiQmVyZWtlbnQgbml2ZWF1cyB2YW4gdmVnZXRhdGllLCBuYXRoZWlkIGVuIGhlbGRlcmhlaWQuIERlemUgdGVjaG5pZWsgaXMgZ2ViYXNlZXJkIG9wIGNvw6tmZmljacOrbnRlbiBkaWUgc3BlY2lmaWVrIHZvb3IgZWVuIHNlbnNvciBtb2V0ZW4gd29yZGVuIGJlcmVrZW5kLlwiLFxuXHRcdHRhc3NlbGVkQ2FwRGVzYzogXCJEZSBUYXNzZWxlZCBDYXAgKEthdXRoLVRob21hcykgdHJhbnNmb3JtYXRpZSBpcyBvbnR3b3JwZW4gdm9vciBoZXQgYW5hbHlzZXJlbiBlbiBpbiBrYWFydCBicmVuZ2VuIHZhbiB2ZWdldGF0aWVmZW5vbWVuZW4gZW4gdmVyYW5kZXJpbmdlbiBpbiBzdGVkZWxpamtlIG9udHdpa2tlbGluZyBnZWRldGVjdGVlcmQgZG9vciB2ZXJzY2hpbGxlbmRlIHNhdGVsbGlldHNlbnNvcnN5c3RlbWVuLiBIZXQgc3RhYXQgYmVrZW5kIGFscyBkZSBUYXNzZWxlZCBDYXAtdHJhbnNmb3JtYXRpZSB2YW53ZWdlIGRlIHZvcm0gdmFuIGRlIGdyYWZpc2NoZSBkaXN0cmlidXRpZSB2YW4gZGF0YS4gRGUgdHJhbnNmb3JtYXRpZSBiaWVkdCBlZW4gcmF0aW9uYWxlIHZvb3IgZGUgcGF0cm9uZW4gZ2V2b25kZW4gaW4gTGFuZHNhdCBNU1MtZGF0YSB2YW4gbGFuZGJvdXd2ZWxkZW4gYWxzIGVlbiBmdW5jdGllIHZhbiBkZSBsZXZlbnNjeWNsdXMgdmFuIGhldCBnZXdhcy4gT21kYXQgZGUgZ2V3YXNzZW4gZ3JvZWllbiB2YW4gemFhZCB0b3Qgdm9sd2Fzc2VuaGVpZCwgaXMgZXIgZWVuIG5ldHRvIHRvZW5hbWUgdmFuIG5hYmlqLWluZnJhcm9vZCBlbiBlZW4gYWZuYW1lIHZhbiBkZSByb2RlIHJlZmxlY3RpZSBvcCBiYXNpcyB2YW4gZGUga2xldXIgdmFuIGRlIGdyb25kPGRpdj48YnIvPkhldCBudXQgdmFuIGRlemUgdHJhbnNmb3JtYXRpZSBpcyB1aXRnZWJyZWlkIHZhbiBoZXQgbW9uaXRvcmVuIHZhbiBnZXdhc3NlbiB0b3QgaGV0IGFuYWx5c2VyZW4gZW4gaW4ga2FhcnQgYnJlbmdlbiB2YW4gdmVnZXRhdGllIG9tIHZlcnNjaGlsbGVuZGUgdG9lcGFzc2luZ2VuIHRlIG9uZGVyc3RldW5lbiwgem9hbHMgYm9zYm91dywgaW5kdXN0cmllZWwgdmVnZXRhdGllbWFuYWdlbWVudCwgaGV0IGluIGthYXJ0IGJyZW5nZW4gZW4gYmVoZXJlbiB2YW4gZWNvc3lzdGVtZW4sIGludmVudGFyaXNhdGllIGVuIG1vbml0b3Jpbmcgdm9vciBoZXQgc2Vrd2VzdHJlcmVuIHZhbiBrb29sc3RvZiBlbiBjcmVkaXRzLCBzdGVkZWxpamtlIG9udHdpa2tlbGluZyBlbiBtZWVyLiBIZXQgaXMgb29rIHVpdGdlYnJlaWQgdmFuIG9uZGVyc3RldW5lbmRlIExhbmRzYXQgTVNTIG5hYXIgYW5kZXJlIHBvcHVsYWlyZSBzYXRlbGxpZXRzeXN0ZW1lbiB6b2FscyBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIFdvcmxkVmlldy0yIGVuIFJhcGlkRXllIG11bHRpc3BlY3RyYWxlIHNlbnNvcmVuLjwvZGl2PlwiLFxuXHRcdHRpbWVzTmFtZTogXCJBYW50YWwga2VlclwiLFxuXHRcdHRpbWVzU25pcDogXCJWZXJtZW5pZ3Z1bGRpZ3QgZGUgd2FhcmRlbiB2YW4gdHdlZSByYXN0ZXJzIG9wIGVlbiBjZWwtdm9vci1jZWwgYmFzaXMuXCIsXG5cdFx0dGltZXNEZXNjOiBcIkRlIGZ1bmN0aWUgVmVybWVuaWd2dWxkaWcgdmVyZGVlbHQgZGUgd2FhcmRlbiB2YW4gdHdlZSByYXN0ZXJzIG9wIGVlbiBwaXhlbC12b29yLXBpeGVsIGJhc2lzLlwiLFxuXHRcdHRyYW5zcG9zZUJpdHNOYW1lOiBcIlRyYW5zcG9zZSBCaXRzXCIsXG5cdFx0dHJhbnNwb3NlQml0c1NuaXA6IFwiUGFrdCBkZSBiaXRzIHZhbiBkZSBpbnZvZXJwaXhlbCB1aXQgZW4ga2VudCB6ZSB0b2UgYWFuIHNwZWNpZmlla2UgYml0cyBpbiBkZSB1aXR2b2VycGl4ZWwuIEhldCBkb2VsIHZhbiBkZXplIGZ1bmN0aWUgaXMgb20gYml0cyB2YW4gZWVuIGFhbnRhbCBpbmdhbmdlbiB0ZSBtYW5pcHVsZXJlbiwgem9hbHMgZGUgTGFuZHNhdCA4LWt3YWxpdGVpdHNiYW5kcHJvZHVjdGVuLlwiLFxuXHRcdHRyYW5zcG9zZUJpdHNEZXNjOiBcIkRlIGZ1bmN0aWUgVHJhbnNwb3NlIEJpdCBwYWt0IGRlIGJpdHMgdmFuIGRlIGludm9lcnBpeGVsIHVpdCBlbiBrZW50IHplIHRvZSBhYW4gc3BlY2lmaWVrZSBiaXRzIGluIGRlIHVpdHZvZXJwaXhlbC4gSGV0IGRvZWwgdmFuIGRlemUgZnVuY3RpZSBpcyBvbSBiaXRzIHZhbiBlZW4gYWFudGFsIGluZ2FuZ2VuIHRlIG1hbmlwdWxlcmVuLCB6b2FscyBkZSBMYW5kc2F0IDgta3dhbGl0ZWl0c2JhbmRwcm9kdWN0ZW4uXCIsXG5cdFx0dW5pdENvbnZlcnNpb25OYW1lOiBcIkVlbmhlaWRzY29udmVyc2llXCIsXG5cdFx0dW5pdENvbnZlcnNpb25TbmlwOiBcIlZlcmFuZGVydCB3YWFyZGVuIHZhbiBkZSBlbmUgbWVldGVlbmhlaWQgbmFhciBkZSBhbmRlcmUuXCIsXG5cdFx0dW5pdENvbnZlcnNpb25EZXNjOiBcIkRlemUgZnVuY3RpZSBjb252ZXJ0ZWVydCBwaXhlbHMgdmFuIGRlIGVuZSBlZW5oZWlkIG5hYXIgZGUgYW5kZXJlLiBIZXQgb25kZXJzdGV1bnQgZGUgY29udmVyc2llIHZhbiBhZnN0YW5kLCBzbmVsaGVpZCBlbiB0ZW1wZXJhdHV1ci5cIixcblx0XHR2ZWN0b3JGaWVsZE5hbWU6IFwiVmVjdG9ydmVsZFwiLFxuXHRcdHZlY3RvckZpZWxkU25pcDogXCJHZWVmdCBkYXRhc2V0cyB3ZWVyIG1ldCB6b3dlbCBtYWduaXR1ZGUgKHUpIGFscyByaWNodGluZyAodikgYWxzIHBpamxlbiB3YWFyYmlqIG1hZ25pdHVkZSB3b3JkdCB3ZWVyZ2VnZXZlbiBkb29yIGRlIGdyb290dGUgZW4gZGUgcmljaHRpbmcgd29yZHQgd2VlcmdlZ2V2ZW4gZG9vciBkZSBob2VrIHZhbiBkZSBwaWpsLlwiLFxuXHRcdHZlY3RvckZpZWxkRGVzYzogXCJEZSBmdW5jdGllIFZlY3RvcnZlbGQgd29yZHQgZ2VicnVpa3Qgb20gdHdlZSByYXN0ZXJzIHNhbWVuIHRlIHN0ZWxsZW4gZW4gb20gdGUgemV0dGVuIGluIGVlbiB0d2VlYmFuZCByYXN0ZXIgdmFuIGhldCBkYXRhdHlwZSBNYWduaXR1ZGUtRGlyZWN0aW9uIG9mIGRhdGF0eXBlIFUtVi48ZGl2Pjxici8+RGUgVS13YWFyZGUgd29yZHQgc29tcyBkZSB6b25hbGUgc25lbGhlaWQgZ2Vub2VtZCBlbiBkZSBWLXdhYXJkZSB3b3JkdCBzb21zIGRlIG1lcmlkaW9uYWxlIHNuZWxoZWlkIGdlbm9lbWQuPC9kaXY+XCIsXG5cdFx0dmlld3NoZWQyTmFtZTogXCJWaWV3c2hlZFwiLFxuXHRcdHZpZXdzaGVkMlNuaXA6IFwiQmVwYWFsdCBkZSByYXN0ZXJvcHBlcnZsYWtsb2NhdGllcyBkaWUgemljaHRiYWFyIHppam4gdm9vciBlZW4gYWFudGFsIHdhYXJuZW1lcm9iamVjdGVuIG1ldCBiZWh1bHAgdmFuIGdlb2RldGlzY2hlIG1ldGhvZGVuLlwiLFxuXHRcdHZpZXdzaGVkMkRlc2M6IFwiRGUgZnVuY3RpZSBWaWV3c2hlZCBiZXBhYWx0IGRlIHJhc3Rlcm9wcGVydmxha2xvY2F0aWVzIGRpZSB6aWNodGJhYXIgemlqbiB2b29yIGVlbiBhYW50YWwgd2Fhcm5lbWVyb2JqZWN0ZW4gbWV0IGJlaHVscCB2YW4gZ2VvZGV0aXNjaGUgbWV0aG9kZW48ZGl2Pjxici8+RGUgemljaHRiYWFyaGVpZCB2YW4gZWxrIHBpeGVsY2VudHJ1bSB3b3JkdCBiZXBhYWxkIGRvb3IgZWVuIGdlemljaHRzbGlqbnRlc3QgdHVzc2VuIGhldCBkb2VsIGVuIGVsa2Ugd2Fhcm5lbWVyLiBBbHMgZWVuIHdhYXJuZW1lciBoZXQgZG9lbCBpbiBoZXQgbWlkZGVuIHZhbiBkZSBwaXhlbCBrYW4gemllbiwgd29yZHQgZGUgcGl4ZWwgYWxzIHppY2h0YmFhciBiZXNjaG91d2QuIERlemUgdG9vbCBob3VkdCBhbHRpamQgcmVrZW5pbmcgbWV0IGRlIGtyb21taW5nIHZhbiBkZSBhYXJkZSB3YW5uZWVyIGRlIHppY2h0YmFhcmhlaWQgd29yZHQgYmVwYWFsZC48L2Rpdj5cIixcblx0XHR3YXRlcnNoZWROYW1lOiBcIldhdGVyc2hlZFwiLFxuXHRcdHdhdGVyc2hlZFNuaXA6IFwiQmVwYWFsdCBoZXQgYmlqZHJhZ2VuZGUgZ2ViaWVkIGJvdmVuIGVlbiBzZXQgY2VsbGVuIGluIGVlbiByYXN0ZXIuXCIsXG5cdFx0d2F0ZXJzaGVkRGVzYzogXCJEZSBnbG9iYWxlIGZ1bmN0aWUgU3Ryb29tZ2ViaWVkIGJlcGFhbHQgaGV0IGJpamRyYWdlbmRlIGdlYmllZCBib3ZlbiBlZW4gc2V0IHBpeGVscyBpbiBlZW4gcmFzdGVyLiBTdHJvb21nZWJpZWRlbiB6aWpuIGFmZ2ViYWtlbmQgdmFuIGVlbiBzdHJvb21yaWNodGluZ3Jhc3RlciBkYXQgZGUgc3Ryb29tcmljaHRpbmcgdmFuIGVsa2UgcGl4ZWwgaWRlbnRpZmljZWVydC5cIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlOYW1lOiBcIkdld29nZW4gb3ZlcmxhcHBpbmdcIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlTbmlwOiBcIk92ZXJsYXB0IHZlcnNjaGlsbGVuZGUgcmFzdGVycyBtZXQgYmVodWxwIHZhbiBlZW4gZ2VtZWVuc2NoYXBwZWxpamtlIG1lZXRzY2hhYWwgZW4gd2VlZ3QgZWxrIG9wIGJhc2lzIHZhbiBoZXQgYmVsYW5nIGVydmFuLlwiLFxuXHRcdHdlaWdodGVkT3ZlcmxheURlc2M6IFwiTWV0IGRlemUgZnVuY3RpZSBrdW50IHUgdmVyc2NoaWxsZW5kZSByYXN0ZXJzIG92ZXIgZWxrYWFyIGxlZ2dlbiBtZXQgYmVodWxwIHZhbiBlZW4gZ2VtZWVuc2NoYXBwZWxpamtlIG1lZXRzY2hhYWwgZW4gZWxrIHdlZ2VuIG9wIGJhc2lzIHZhbiBoZXQgYmVsYW5nIGVydmFuLlwiLFxuXHRcdHdlaWdodGVkU3VtTmFtZTogXCJHZXdvZ2VuIHNvbVwiLFxuXHRcdHdlaWdodGVkU3VtU25pcDogXCJXZWVndCBlbiB2b2VndCBlZW4gcmVla3MgcmFzdGVycyB0b2Ugb3AgZWVuIGNlbC12b29yLWNlbCBiYXNpcy5cIixcblx0XHR3ZWlnaHRlZFN1bURlc2M6IFwiTWV0IGRlIGZ1bmN0aWUgR2V3b2dlbiBzb20ga3VudCB1IHZlcnNjaGlsbGVuZGUgcmFzdGVycyBvdmVyIGVsa2FhciBsZWdnZW4gZW4gemUgdmVybWVuaWd2dWxkaWdlbiBtZXQgaGV0IG9wZ2VnZXZlbiBnZXdpY2h0IGVuIHplIG9wdGVsbGVuLlwiLFxuXHRcdHdpbmRjaGlsbE5hbWU6IFwiR2V2b2Vsc3RlbXBlcmF0dXVyXCIsXG5cdFx0d2luZGNoaWxsU25pcDogXCJDb21iaW5lZXJ0IG9tZ2V2aW5nc2x1Y2h0dGVtcGVyYXR1dXIgZW4gd2luZHNuZWxoZWlkIG9tIGRlIGZhY3RvciBnZXZvZWxzdGVtcGVyYXR1dXIgdGUgYmVyZWtlbmVuLlwiLFxuXHRcdHdpbmRjaGlsbERlc2M6IFwiRGUgZnVuY3RpZSBHZXZvZWxzdGVtcGVyYXR1dXIgaXMgaGFuZGlnIHZvb3IgaGV0IGlkZW50aWZpY2VyZW4gdmFuIGdldmFhcmxpamtlIHdpbnRlcm9tc3RhbmRpZ2hlZGVuIGRpZSwgYWZoYW5rZWxpamsgdmFuIGRlIGJsb290c3RlbGxpbmcgYWFuIGRlIHdlZXJzb21zdGFuZGlnaGVkZW4sIGt1bm5lbiByZXN1bHRlcmVuIGluIGJldnJpZXppbmcgb2YgemVsZnMgb25kZXJrb2VsaW5nLiBHZXZvZWxzdGVtcGVyYXR1dXIgaXMgZWVuIG1hbmllciBvbSB0ZSBtZXRlbiBob2Uga291ZCBpZW1hbmQgaGV0IHphbCBoZWJiZW4gYWxzIHJla2VuaW5nIHdvcmR0IGdlaG91ZGVuIG1ldCBhbCBrb3VkZSB0ZW1wZXJhdHVyZW4uIEhvZSBzbmVsbGVyIGRlIHdpbmRzbmVsaGVpZCwgaG9lIHNuZWxsZXIgaGV0IGxpY2hhYW0gd2FybXRlIHZlcmxpZXN0IGVuIGhvZSBrb3VkZXIgbWVuIGhldCBrcmlqZ3QuXCIsXG5cdFx0em9uYWxSZW1hcE5hbWU6IFwiT3BuaWV1dyB0b2V3aWp6ZW4gb3AgYmFzaXMgdmFuIHpvbmVzXCIsXG5cdFx0em9uYWxSZW1hcFNuaXA6IFwiUGl4ZWxzIGluIGVlbiByYXN0ZXIgb3BuaWV1dyB0b2V3aWp6ZW4gb3AgYmFzaXMgdmFuIHpvbmVzIGRpZSB6aWpuIGdlZGVmaW5pZWVyZCBpbiBlZW4gYW5kZXIgcmFzdGVyIGVuIHpvbmVhZmhhbmtlbGlqa2Ugd2FhcmRldG9ld2lqemluZyBkaWUgaW4gZWVuIHRhYmVsIGlzIGdlZGVmaW5pZWVyZC5cIixcblx0XHR6b25hbFJlbWFwRGVzYzogXCJNZXQgZGV6ZSBmdW5jdGllIGt1bnQgdSBwaXhlbHMgaW4gZWVuIHJhc3RlciBvcG5pZXV3IHRvZXdpanplbiBvcCBiYXNpcyB2YW4gem9uZXMgZGllIHppam4gZ2VkZWZpbmllZXJkIGluIGVlbiBhbmRlciByYXN0ZXIgZW4gem9uZWFmaGFua2VsaWprZSB3YWFyZGV0b2V3aWp6aW5nIGRpZSBpbiBlZW4gdGFiZWwgaXMgdmFzdGdlbGVnZC5cIixcblx0XHR6b25hbFN0YXRpc3RpY3NOYW1lOiBcIkdlYmllZHNzdGF0aXN0aWVrZW5cIixcblx0XHR6b25hbFN0YXRpc3RpY3NTbmlwOiBcIkJlcmVrZW50IHN0YXRpc3RpZWtlbiBvdmVyIHdhYXJkZW4gdmFuIGVlbiByYXN0ZXIgaW4gZGUgem9uZXMgdmFuIGVlbiBhbmRlcmUgZGF0YXNldC5cIixcblx0XHR6b25hbFN0YXRpc3RpY3NEZXNjOiBcIkRlIGZ1bmN0aWUgYmVyZWtlbnQgc3RhdGlzdGlla2VuIG92ZXIgd2FhcmRlbiB2YW4gZWVuIHJhc3RlciBpbiBkZSB6b25lcyB2YW4gZWVuIGFuZGVyZSBkYXRhc2V0LiBFZW4gem9uZSBpcyBnZWRlZmluaWVlcmQgYWxzIGFsbGUgZ2ViaWVkZW4gaW4gZGUgaW52b2VyIGRpZSBkZXplbGZkZSB3YWFyZGUgaGViYmVuLiBEZXplIGdlYmllZGVuIGhvZXZlbiBuaWV0IGFhbmVlbmdlc2xvdGVuIHRlIHppam4uIEFscyBkZSB6b25lLSBlbiB3YWFyZGUtaW52b2VyIGJlaWRlIHJhc3RlcnMgemlqbiBtZXQgZGV6ZWxmZGUgcmVzb2x1dGllLCB3b3JkZW4gemUgZGlyZWN0IGdlYnJ1aWt0LiBBbHMgZGUgcmVzb2x1dGllcyBhbmRlcnMgemlqbiwgd29yZHQgZWVuIGludGVybmUgcmVzYW1wbGluZyB0b2VnZXBhc3Qgb20gZGUgcmVzb2x1dGllcyBvdmVyZWVuIHRlIGxhdGVuIGtvbWVuIHZvb3JkYXQgZGUgem9uZWJld2Vya2luZyB3b3JkdCB1aXRnZXZvZXJkLlwiLFxuXHRcdGZsb3dMZW5ndGhOYW1lOiBcIlN0cm9taW5nc2xlbmd0ZVwiLFxuXHRcdGZsb3dMZW5ndGhTbmlwOiBcIkJlcmVrZW50IGRlIHN0cm9vbW9wd2FhcnRzZSBvZiBzdHJvb21hZndhYXJ0c2UgYWZzdGFuZCwgb2YgZ2V3b2dlbiBhZnN0YW5kLCBsYW5ncyBoZXQgc3Ryb21pbmdzdHJhamVjdCB2b29yIGVsa2UgY2VsLlwiLFxuXHRcdGZsb3dMZW5ndGhEZXNjOiBcIkRpdCBpcyBlZW4gZ2xvYmFsZSByYXN0ZXJmdW5jdGllLiBEZXplIGZ1bmN0aWUgY3Jlw6tlcnQgZWVuIHJhc3RlcmxhYWcgdmFuIHN0cm9vbW9wd2FhcnRzZSBvZiBzdHJvb21hZndhYXJ0c2UgYWZzdGFuZCwgb2YgZ2V3b2dlbiBhZnN0YW5kLCBsYW5ncyBoZXQgc3Ryb21pbmdzdHJhamVjdCB2b29yIGVsa2UgY2VsLjxkaXY+PGJyLz5FZW4gcHJpbWFpcmUgdG9lcGFzc2luZyB2YW4gZGUgZnVuY3RpZSBTdHJvbWluZ3NsZW5ndGUgaXMgaGV0IGJlcmVrZW5lbiB2YW4gZGUgbGVuZ3RlIHZhbiBoZXQgbGFuZ3N0ZSBzdHJvbWluZ3N0cmFqZWN0IGJpbm5lbiBlZW4gYmVwYWFsZCBiZWtrZW4uIERlemUgbWFhdCB3b3JkdCB2YWFrIGdlYnJ1aWt0IG9tIGRlIGNvbmNlbnRyYXRpZXRpamQgdmFuIGVlbiBiZWtrZW4gdGUgYmVyZWtlbmVuLiBEaXQgd29yZHQgZ2VkYWFuIG1ldCBkZSBvcHRpZSBTdHJvb21vcHdhYXJ0cy4gRGUgZnVuY3RpZSBrYW4gb29rIHdvcmRlbiBnZWJydWlrdCBvbSBhZnN0YW5kc2RpYWdyYW1tZW4gdGUgbWFrZW4gdmFuIGh5cG90aGV0aXNjaGUgbmVlcnNsYWcgZW4gYWZ2bG9laWluZ2VuIG1ldCBiZWh1bHAgdmFuIGhldCBnZXdpY2h0ZW5yYXN0ZXIgYWxzIGVlbiBiZWxlbW1lcmluZyB2b29yIGVlbiBuZWVyd2FhcnRzZSBiZXdlZ2luZy48L2Rpdj5cIixcblx0XHRzdHJlYW1PcmRlck5hbWU6IFwiU3Ryb21pbmdzdm9sZ29yZGVcIixcblx0XHRzdHJlYW1PcmRlclNuaXA6IFwiV2lqc3QgZWVuIG51bWVyaWVrZSB2b2xnb3JkZSB0b2UgYWFuIHNlZ21lbnRlbiB2YW4gZWVuIHJhc3RlciBkaWUgdGFra2VuIHZhbiBlZW4gbGluZWFpciBuZXR3ZXJrIHZvb3JzdGVsbGVuXCIsXG5cdFx0c3RyZWFtT3JkZXJEZXNjOiBcIkRpdCBpcyBlZW4gZ2xvYmFsZSByYXN0ZXJmdW5jdGllLiBEZXplIGZ1bmN0aWUgY3Jlw6tlcnQgZWVuIHJhc3RlcmxhYWcgZGllIGVlbiBudW1lcmlla2Ugdm9sZ29yZGUgdG9la2VudCBhYW4gc2VnbWVudGVuIHZhbiBlZW4gcmFzdGVyIGRpZSBhZnRha2tpbmdlbiB2YW4gZWVuIGxpbmVhaXIgbmV0d2VyayB2b29yc3RlbGxlbi48ZGl2Pjxici8+RGUgb3V0cHV0IHZhbiBkZSBmdW5jdGllIFN0cm9taW5nc3ZvbGdvcmRlIHphbCB2YW4gaG9nZXJlIGt3YWxpdGVpdCB6aWpuIGFscyBkZSBpbnB1dCB2YW4gZGUgc3Ryb29tbXJhc3RlcmxhYWcgZW4gZGUgaW5wdXQgc3Ryb21pbmdzcmljaHRpbmcgdmFuIGRlIHJhc3RlcmxhYWcgd29yZGVuIHZhbiBoZXR6ZWxmZGUgb3BwZXJ2bGFrIGFmZ2VsZWlkLiBBbHMgaGV0IHN0cm9vbXJhc3RlciBpcyBhZmdlbGVpZCB2YW4gZWVuIGdlcmFzdGVyZGUgc3Ryb29tZGF0YXNldCwgZGFuIGlzIGRlIG91dHB1dCBtb2dlbGlqayBuaWV0IGJydWlrYmFhciwgb21kYXQgZGUgcmljaHRpbmcgb3AgY2VsYmFzaXMgbmlldCB6YWwgb3ZlcmVlbmtvbWVuIG1ldCBkZSBsb2NhdGllIHZhbiBkZSBzdHJvb21jZWxsZW4uIERlIHJlc3VsdGF0ZW4gdmFuIGRlIGZ1bmN0aWUgU3Ryb29tYWNjdW11bGF0aWUga3VubmVuIHdvcmRlbiBnZWJydWlrdCBvbSBlZW4gcmFzdGVyc3Ryb29tbmV0d2VyayB0ZSBjcmXDq3JlbiBkb29yIGVlbiBkcmVtcGVsd2FhcmRlIHRvZSB0ZSBwYXNzZW4gdm9vciBoZXQgc2VsZWN0ZXJlbiB2YW4gY2VsbGVuIG1ldCBlZW4gaG9nZSBnZWFjY3VtdWxlZXJkZSBzdHJvb20uIFpvIHdvcmRlbiBiaWp2b29yYmVlbGQgY2VsbGVuIG1ldCBtZWVyIGRhbiAxMDAgY2VsbGVuIGdlYnJ1aWt0IG9tIGhldCBzdHJvb21uZXQgdGUgZGVmaW5pw6tyZW4uIEdlYnJ1aWsgZGUgQ29uLSBvZiBTZXQgTnVsbC1mdW5jdGllIG9tIGVlbiBzdHJvb21uZXR3ZXJrcmFzdGVyIHRlIG1ha2VuIHdhYXJiaWogc3Ryb29tYWNjdW11bGF0aWV3YWFyZGVuIHZhbiAxMDAgb2YgbWVlciBuYWFyIMOpw6luIHJhc3RlciBnYWFuIGVuIGRlIHJlc3QgbmFhciBkZSBhY2h0ZXJncm9uZCB3b3JkdCBnZXBsYWF0c3QgKE5vRGF0YSkuIEhldCByZXN1bHRlcmVuZGUgc3Ryb29tbmV0d2VyayBrYW4gd29yZGVuIGdlYnJ1aWt0IGluIGRlIGZ1bmN0aWUgU3Ryb21pbmdzdm9sZ29yZGUuIERlemUgZnVuY3RpZSBvbmRlcnN0ZXVudCBhbGxlZW4gZWVuIEQ4LWludm9lcnN0cm9vbXJpY2h0aW5ncmFzdGVybGFhZy4gRDgtc3Ryb21pbmdzcmljaHRpbmdlbiBrdW5uZW4gbWV0IGJlaHVscCB2YW4gZGUgZnVuY3RpZSBTdHJvb21yaWNodGluZyB3b3JkZW4gYWFuZ2VtYWFrdCBlbiBtZXQgZGUgc3RhbmRhYXJkc3Ryb29tcmljaHRpbmcgdHlwZSBEOCB3b3JkZW4gdWl0Z2V2b2VyZC48L2Rpdj5cIixcblx0XHRzbmFwUG91clBvaW50TmFtZTogXCJTdG9ydHB1bnQga29wcGVsZW5cIixcblx0XHRzbmFwUG91clBvaW50U25pcDogXCJLb3BwZWx0IHN0b3J0cHVudGVuIGFhbiBkZSBjZWwgbWV0IGRlIGhvb2dzdGUgc3Ryb29tYWNjdW11bGF0aWUgYmlubmVuIGVlbiBiZXBhYWxkZSBhZnN0YW5kXCIsXG5cdFx0c25hcFBvdXJQb2ludERlc2M6IFwiRGl0IGlzIGVlbiBnbG9iYWxlIHJhc3RlcmZ1bmN0aWUuIERlemUgZnVuY3RpZSBrb3BwZWx0IHN0b3J0cHVudGVuIGFhbiBkZSBjZWwgdmFuIGRlIGhvb2dzdGUgc3Ryb29tYWNjdW11bGF0aWUgYmlubmVuIGVlbiBiZXBhYWxkZSBhZnN0YW5kLjxkaXY+PGJyLz5EZSBmdW5jdGllIFN0b3J0cHVudGVuIGtvcHBlbGVuIHdvcmR0IGdlYnJ1aWt0IG9tIGRlIHNlbGVjdGllIHZhbiBwdW50ZW4gbWV0IGVlbiBob2dlIGdlYWNjdW11bGVlcmRlIHN0cm9taW5nIHRlIGdhcmFuZGVyZW4gYmlqIGhldCBhZmJha2VuZW4gdmFuIGFmd2F0ZXJpbmdzYmVra2VucyBtZXQgYmVodWxwIHZhbiBkZSBmdW5jdGllIFN0cm9vbWdlYmllZC4gU3RvcnRwdW50ZW4ga29wcGVsZW4gem9la3QgYmlubmVuIGVlbiBrb3J0ZSBhZnN0YW5kIHJvbmQgZGUgZ2VzcGVjaWZpY2VlcmRlIHN0b3J0cHVudGVuIHZvb3IgZGUgY2VsIG1ldCBkZSBob29nc3RlIGdlYWNjdW11bGVlcmRlIHN0cm9taW5nIGVuIHZlcnBsYWF0c3QgaGV0IHN0b3J0cHVudCBuYWFyIGRpZSBsb2NhdGllLiBEZSB1aXRnYW5nIGlzIGVlbiBnZWhlbGUgcmFzdGVybGFhZyB3YW5uZWVyIGRlIG9vcnNwcm9ua2VsaWprZSBzdG9ydGxvY2F0aWVzIHppam4gZ2Vrb3BwZWxkIGFhbiBsb2NhdGllcyBtZXQgZWVuIGhvZ2VyZSBnZWFjY3VtdWxlZXJkZSBzdHJvbWluZy48L2Rpdj5cIixcblx0XHRzaW5rTmFtZTogXCJCYXNpblwiLFxuXHRcdHNpbmtTbmlwOiBcIkNyZcOrZXJ0IGVlbiByYXN0ZXIgZGF0IGFsbGUgcHV0dGVuIG9mIGdlYmllZGVuIHZhbiBpbnRlcm5lIGRyYWluYWdlIGlkZW50aWZpY2VlcnRcIixcblx0XHRzaW5rRGVzYzogXCJEaXQgaXMgZWVuIGdsb2JhbGUgcmFzdGVyZnVuY3RpZS4gRGV6ZSBmdW5jdGllIGNyZcOrZXJ0IGVlbiByYXN0ZXJsYWFnIGRpZSBhbGxlIGJhc2lucyBvZiBnZWJpZWRlbiB2YW4gaW50ZXJuZSBkcmFpbmFnZSBpZGVudGlmaWNlZXJ0LiBFZW4gcHV0IGlzIGVlbiBjZWwgb2Ygc2V0IHZhbiBydWltdGVsaWprIHZlcmJvbmRlbiBjZWxsZW4gbWV0IGVlbiBzdHJvb21yaWNodGluZyBkaWUgbmlldCBrYW4gd29yZGVuIHRvZWdld2V6ZW4gYWFuIMOpw6luIHZhbiBkZSBhY2h0IGdlbGRpZ2Ugd2FhcmRlbiBpbiBlZW4gc3Ryb21pbmdzcmljaHRpbmdyYXN0ZXIuIERpdCBrYW4gZ2ViZXVyZW4gd2FubmVlciBhbGxlIGFhbmdyZW56ZW5kZSBjZWxsZW4gaG9nZXIgemlqbiBkYW4gZGUgdmVyd2Vya2VuZGUgY2VsIG9mIHdhbm5lZXIgdHdlZSBjZWxsZW4gaW4gZWxrYWFyIHZsb2VpZW4sIHdhYXJkb29yIGVlbiB0d2VlY2VsbGVubHVzIG9udHN0YWF0LjxkaXY+PGJyLz5EZSBmdW5jdGllIFB1dCBvbmRlcnN0ZXVudCBhbGxlZW4gZWVuIEQ4LWluZ2FuZ3N0cm9taW5nc3JpY2h0aW5nIHJhc3RlcmxhYWcuIEQ4LXN0cm9taW5nc3JpY2h0aW5nZW4ga3VubmVuIG1ldCBiZWh1bHAgdmFuIGRlIGZ1bmN0aWUgU3Ryb29tcmljaHRpbmcgd29yZGVuIGFhbmdlbWFha3QgZW4gbWV0IGRlIHN0YW5kYWFyZHN0cm9vbXJpY2h0aW5nIHR5cGUgRDggd29yZGVuIHVpdGdldm9lcmQuIERlIHVpdGdhbmcgdmFuIGRlIGZ1bmN0aWUgUHV0IGlzIGVlbiBnZWhlZWwgcmFzdGVyLCB3YWFyYmlqIGFhbiBlbGtlIHB1dCBlZW4gdW5pZWtlIHdhYXJkZSB3b3JkdCB0b2VnZWtlbmQuIERlemUgdW5pZWtlIHdhYXJkZW4gaGViYmVuIGVlbiBiZXJlaWsgZGF0IGxpZ3QgdHVzc2VuIMOpw6luIGVuIGhldCB0b3RhbGUgYWFudGFsIHB1dHRlbi4gQWxzIGhldCB0b3RhYWwgYWFudGFsIHB1dHRlbiBiaWp2b29yYmVlbGQgMTAwMCBpcywgdmFyacOrcmVuIGRlIHVuaWVrZSB3YWFyZGVuIHZhbiAxIHRvdCAxMDAwLjwvZGl2PlwiLFxuXHRcdGFnZ3JlZ2F0ZU5hbWU6IFwiQWdncmVnZXJlblwiLFxuXHRcdGFnZ3JlZ2F0ZVNuaXA6IFwiR2VuZXJlZXJ0IGVlbiB2ZXJzaWUgbWV0IGVlbiB2ZXJrbGVpbmRlIHJlc29sdXRpZSB2YW4gZWVuIHJhc3Rlci5cIixcblx0XHRhZ2dyZWdhdGVEZXNjOiBcIkRlIGZ1bmN0aWUgQWdncmVnZXJlbiBoZXJzdGVsdCBlZW4gaW52b2VycmFzdGVyIG5hYXIgZWVuIGdyb3ZlcmUgcmVzb2x1dGllIG9wIGJhc2lzIHZhbiBlZW4gZ2VzcGVjaWZpY2VlcmRlIGFnZ3JlZ2F0aWVzdHJhdGVnaWUuIEVsa2UgdWl0dm9lcmNlbCBiZXZhdCBkZSBzb20sIGhldCBtaW5pbXVtLCBoZXQgbWF4aW11bSwgaGV0IGdlbWlkZGVsZGUgb2YgZGUgbWVkaWFhbiB2YW4gZGUgaW52b2VyY2VsbGVuIGRpZSBkb29yIGRlIG9tdmFuZyB2YW4gZGllIGNlbCB3b3JkZW4gYmVzdHJla2VuLjxkaXY+PGJyLz5VIGt1bnQgZGUgZmFjdG9yIG9wZ2V2ZW4gd2Fhcm1lZSBkZSBjZWxncm9vdHRlIHZhbiBoZXQgaW52b2VycmFzdGVyIHZlcm1lbmlndnVsZGlnZCBtb2V0IHdvcmRlbi4gQmlqdm9vcmJlZWxkLCBlZW4gY2VsZmFjdG9yd2FhcmRlIHZhbiAzIHpvdSByZXN1bHRlcmVuIGluIGVlbiB1aXR2b2VyIHdhYXJiaWogZGUgY2VsZ3Jvb3R0ZSBkcmllIGtlZXIgZ3JvdGVyIGlzIGRhbiBkaWUgdmFuIGhldCBpbnZvZXJyYXN0ZXIuIFUga3VudCBiZXBhbGVuIGhvZSBkZSBvbXZhbmcgdmFuIGRlIHVpdHZvZXIgbW9ldCB3b3JkZW4gdmVyd2Vya3QgYWxzIGhldCBhYW50YWwgcmlqZW4gb2Yga29sb21tZW4gaW4gZGUgaW52b2VyIGdlZW4gZXhhY3RlIHZlZWx2b3VkIGlzIHZhbiBkZSBjZWxmYWN0b3IuIFN0YW5kYWFyZCB3b3JkZW4gZGUgYm92ZW4tIGVuIHJlY2h0ZXJncmVuemVuIHVpdGdlYnJlaWQgdG90IGVlbiBncm90ZXJlIHJ1aW10ZWxpamtlIG9tdmFuZyBkYW4gZGllIHZhbiBoZXQgaW52b2VycmFzdGVyLCB6b2RhdCBhbGxlIGludm9lcmNlbGxlbiB3b3JkZW4gdmVyd2Vya3QuIEFscyBhbHRlcm5hdGllZiBrdW5uZW4gZGUgYm92ZW4tIGVuIHJlY2h0ZXJncmVuemVuIHdvcmRlbiBnZXJlZHVjZWVyZCB0b3QgZWVuIGtsZWluZXIgYWFudGFsIHJpamVuIGVuIGtvbG9tbWVuLCB6b2RhdCBoZXQgYWFudGFsIHZlcndlcmt0ZSByaWplbiBlbiBrb2xvbW1lbiBlZW4gZXhhY3RlIHZlZWx2b3VkIGlzIHZhbiBkZSBjZWxmYWN0b3IuIFUga3VudCBiZXBhbGVuIGhvZSBOb0RhdGEtY2VsbGVuIG1vZXRlbiB3b3JkZW4gYmVoYW5kZWxkIGRvb3IgZGUgYWdncmVnYXRpZWJlcmVrZW5pbmcuIEluIGhldCBzdGFuZGFhcmRtZWNoYW5pc21lIHdvcmRlbiBOb0RhdGEtY2VsbGVuIGRpZSBpbiBkZSBydWltdGVsaWprZSBvbXZhbmcgdmFuIGVlbiBncm90ZXJlIGNlbCBpbiBoZXQgdWl0dm9lcnJhc3RlciB2YWxsZW4gZ2VuZWdlZXJkIGJpaiBoZXQgYmVwYWxlbiB2YW4gZGUgd2FhcmRlIHZhbiBkaWUgdWl0dm9lcmNlbC4gQWxzIGFsdGVybmF0aWVmIGt1bnQgdSBvcGdldmVuIGRhdCBhbHMgZXIgb29rIG1hYXIgw6nDqW4gZW5rZWxlIGludm9lciBOb0RhdGEtY2VsIGJpbm5lbiBkZSBydWltdGVsaWprZSBvbXZhbmcgdmFuIGVlbiB1aXR2b2VyY2VsIGlzLCBkaWUgY2VsIE5vRGF0YSBpbiBoZXQgdWl0dm9lcnJhc3RlciB6YWwgemlqbi48L2Rpdj5cIixcblx0XHRjY2RjTmFtZTogXCJDQ0RDLWFuYWx5c2VcIixcblx0XHRjY2RjU25pcDogXCJFdmFsdWVlcnQgdmVyYW5kZXJpbmdlbiBpbiBwaXhlbHdhYXJkZW4gaW4gZGUgbG9vcCB2YW4gZGUgdGlqZCBtZXQgYmVodWxwIHZhbiBoZXQgQ29udGludW91cyBDaGFuZ2UgRGV0ZWN0aW9uIGFuZCBDbGFzc2lmaWNhdGlvbiAoQ0NEQyktYWxnb3JpdG1lIGVuIGdlbmVyZWVydCBtb2RlbHJlc3VsdGF0ZW4uXCIsXG5cdFx0Y2NkY0Rlc2M6IFwiRGUgQ0NEQy1hbmFseXNlZnVuY3RpZSBldmFsdWVlcnQgdmVyYW5kZXJpbmdlbiBpbiBwaXhlbHdhYXJkZW4gbmEgdmVybG9vcCB2YW4gdGlqZCBtZXQgYmVodWxwIHZhbiBoZXQgQ29udGludW91cyBDaGFuZ2UgRGV0ZWN0aW9uIGFuZCBDbGFzc2lmaWNhdGlvbiAoQ0NEQyktYWxnb3JpdG1lIGVuIGdlbmVyZWVydCBlZW4gbXVsdGlkaW1lbnNpb25hYWwgcmFzdGVyIGRhdCBkZSBtb2RlbHJlc3VsdGF0ZW4gYmV2YXQuIEhldCB3b3JkdCBhbGxlZW4gb25kZXJzdGV1bmQgaW4gY29tYmluYXRpZSBtZXQgZGUgZnVuY3RpZSAnRGV0ZWN0IENoYW5nZSBVc2luZyBDaGFuZ2UgQW5hbHlzaXMnIGluIGVlbiByYXN0ZXJmdW5jdGlldGVtcGxhdGUuIE9tIGVlbiByYXN0ZXJ1aXR2b2VyIHRlIHByb2R1Y2VyZW4sIHZlcmJpbmR0IHUgZGUgQ0NEQy1hbmFseXNlZnVuY3RpZSBtZXQgZGUgZnVuY3RpZSBEZXRlY3QgQ2hhbmdlIFVzaW5nIENoYW5nZSBBbmFseXNpcy1mdW5jdGllLCBzbGFhdCB1IG9wIGFscyBlZW4gcmFzdGVyZnVuY3RpZXRlbXBsYXRlIGVuIHZvZXJ0IHUgUmFzdGVyYW5hbHlzZSB1aXQgbWV0IGRlIGZ1bmN0aWV0ZW1wbGF0ZS48ZGl2Pjxici8+RGV6ZSBmdW5jdGllIG1hYWt0IGdlYnJ1aWsgdmFuIGhldCBDb250aW51b3VzIENoYW5nZSBEZXRlY3Rpb24gYW5kIENsYXNzaWZpY2F0aW9uIChDQ0RDKS1hbGdvcml0bWUgb20gdmVyYW5kZXJpbmdlbiBpbiBkZSBwaXhlbHdhYXJkZW4gaW4gZGUgbG9vcCB2YW4gZGUgdGlqZCB0ZSBldmFsdWVyZW4gdm9vciBtZWVyZGVyZSBhZmJlZWxkaW5nZW4uIEluIGVlbiB0aWpkcmVla3MgdmFuIG9wdGlzY2hlIGJlZWxkZW4gb2YgYmVlbGRkZXJpdmF0ZW4gKGJpanZvb3JiZWVsZCBORFZJKSBrdW5uZW4gcGl4ZWx3YWFyZGVuIG9tIHZlcnNjaGlsbGVuZGUgcmVkZW5lbiBmbHVjdHVlcmVuOiAxLiBTZWl6b2Vuc3ZlcmFuZGVyaW5nIC0tIFBpeGVsd2FhcmRldmVyYW5kZXJpbmdlbiB3ZWVyc3BpZWdlbGVuIHZlcmFuZGVyaW5nZW4gaW4gZGUgdmVnZXRhdGllIGFscyBnZXZvbGcgdmFuIHNlaXpvZW5zZ2Vib25kZW4gdmFyaWF0aWVzIGluIHRlbXBlcmF0dXVyIGVuIG5lZXJzbGFnLiBPcCBoZXQgbm9vcmRlbGlqayBoYWxmcm9uZCB2ZXJ3YWNodGVuIHdlIGJpanZvb3JiZWVsZCBpbiBkZSB6b21lciBlZW4gaG9nZXJlIGRpY2h0aGVpZCB2YW4gZGUgZ3JvZW5lIHZlZ2V0YXRpZSB0ZSB6aWVuIGRhbiBpbiBkZSB3aW50ZXI7IDIuIEdlbGVpZGVsaWprZSB2ZXJhbmRlcmluZyAtLSBQaXhlbHdhYXJkZXZlcmFuZGVyaW5nZW4gd2VlcnNwaWVnZWxlbiB0cmVuZHMgaW4gZGUgdmVnZXRhdGllIG9mIGhldCBvcHBlcnZsYWt0ZXdhdGVyIGFscyBnZXZvbGcgdmFuIGtsaW1hYXR2YXJpYWJpbGl0ZWl0IG9mIGxhbmRiZWhlZXIgb3AgbGFuZ2UgdGVybWlqbi4gWm8ga2FuIGJpanZvb3JiZWVsZCBkZSBrYWxlIGdyb25kIGdlbGVpZGVsaWprIGFhbiB0b2VuZW1lbiBhbHMgZ2V2b2xnIHZhbiBlZW4gbGFuZ2R1cmlnZSBkYWxpbmcgdmFuIGRlIG5lZXJzbGFnOyBlbiAzLiBBYnJ1cHRlIHZlcmFuZGVyaW5nIC0tIFBpeGVsd2FhcmRldmVyYW5kZXJpbmdlbiB3ZWVyc3BpZWdlbGVuIHZlcmFuZGVyaW5nZW4gaW4gZGUgbGFuZGJlZGVra2luZyBkaWUgcGxvdHNlbGluZyBvcHRyZWRlbiBhbHMgZ2V2b2xnIHZhbiBvbnRib3NzaW5nLCBzdGVkZWxpamtlIG9udHdpa2tlbGluZywgbmF0dXVycmFtcGVuLCBlbnpvdm9vcnQuIEhldCBDQ0RDLWFsZ29yaXRtZSBpZGVudGlmaWNlZXJ0IGFsbGUgZHJpZSBkZSB2ZXJhbmRlcmluZ3N0eXBlcyBtZXQgYWxzIGhvb2ZkZG9lbCBoZXQgaWRlbnRpZmljZXJlbiB2YW4gYWJydXB0ZSB2ZXJhbmRlcmluZ2VuLiBIYXJtb25pc2NoZSByZWdyZXNzaWUtIGVuIHRyZW5kbW9kZWxsZW4gemlqbiBhZmdlc3RlbWQgb3AgZGUgZGF0YSBvbSBzZWl6b2Vuc2dlYm9uZGVuIGVuIGdlbGVpZGVsaWprZSB2ZXJhbmRlcmluZ2VuIGluIHRlIHNjaGF0dGVuLiBQbG90c2VsaW5nZSBhZndpamtpbmdlbiB2YW4gZGUgdHJlbmRtb2RlbGxlbiB6aWpuIGFhbndpanppbmdlbiB2b29yIGFicnVwdGUgdmVyYW5kZXJpbmdlbi48ZGl2Pjxici8+SGV0IENDREMtYWxnb3JpdG1lIGlzIG9vcnNwcm9ua2VsaWprIG9udHdvcnBlbiB2b29yIExhbmRzYXQgVE0sIExhbmRzYXQgRVRNKyBlbiBMYW5kc2F0IE9MSSBkYXRhIFN1cmZhY2UgUmVmbGVjdGFuY2Ugb2YgQnJpZ2h0bmVzcyBUZW1wZXJhdHVyZSBkYXRhLiAuIE1hYXIgZGUgZnVuY3RpZSBWZXJhbmRlcmluZyBkZXRlY3RlcmVuIG1ldCBiZWh1bHAgdmFuIHZlcmFuZGVyaW5nc2FuYWx5c2UgaW4gY29tYmluYXRpZSBtZXQgZGV6ZSBmdW5jdGllIGRldGVjdGVlcnQgdmVyYW5kZXJpbmdlbiB2b29yIG11bHRpYmFuZGJlZWxkZW4gdmFuIGVsa2Ugb25kZXJzdGV1bmRlIHNlbnNvciwgZXZlbmFscyB2YW4gYWZ6b25kZXJsaWprZSBiYW5kYmVlbGRkZXJpdmF0ZW4sIHpvYWxzIGJhbmRpbmRleGVuLiBVIGt1bnQgYmlqdm9vcmJlZWxkIGVlbiBjb250aW51ZSB2ZXJhbmRlcmluZ3NkZXRlY3RpZSB1aXR2b2VyZW4gb3AgZWVuIE5vcm1hbGl6ZSBEaWZmZXJlbmNlIFZlZ2V0YXRpb24gSW5kZXggKE5EVkkpIHJhc3Rlciwgb21kYXQgYWJydXB0ZSB2ZXJhbmRlcmluZ2VuIGluIE5EVkkgaW5kaWNhdGllZiBrdW5uZW4gemlqbiB2b29yIG9udGJvc3NpbmcuPC9kaXY+XCIsXG5cdFx0Y29tcHV0ZUNoYW5nZU5hbWU6IFwiVmVyYW5kZXJpbmcgYmVyZWtlbmVuXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZVNuaXA6IFwiQmVyZWtlbnQgaGV0IHZlcnNjaGlsIHR1c3NlbiB0d2VlIGNhdGVnb3Jpc2NoZSBvZiBjb250aW51ZSByYXN0ZXJkYXRhc2V0cy5cIixcblx0XHRjb21wdXRlQ2hhbmdlRGVzYzogXCJEZSBmdW5jdGllIFxcXCJWZXJhbmRlcmluZyBiZXJla2VuZW5cXFwiIGthbiB3b3JkZW4gZ2VicnVpa3Qgb20gZGUgdmVyc2NoaWxsZW4gdHVzc2VuIHR3ZWUgZ2VjbGFzc2lmaWNlZXJkZSByYXN0ZXJzIG9wIHRlIHNvbW1lbiB2b29yIGRlIGFuYWx5c2UgdmFuIGxhbmRiZWRla2tpbmdzdmVyYW5kZXJpbmcgb2YgaGV0IGthbiB3b3JkZW4gZ2VicnVpa3Qgb20gdmVyYW5kZXJpbmdlbiB0dXNzZW4gdHdlZSBzaW5nbGUtYmFuZCBjb250aW51IHJhc3RlcnMgdGUgb25kZXJ6b2VrZW4sIHpvYWxzIGhvb2d0ZSwgdGVtcGVyYXR1dXIsIGJsYWRlcmJlZGVra2luZywgZW56b3Zvb3J0LlwiLFxuXHRcdGRldGVjdENoYW5nZU5hbWU6IFwiVmVyYW5kZXJpbmcgZGV0ZWN0ZXJlbiBtZXQgYmVodWxwIHZhbiB2ZXJhbmRlcmluZ3NhbmFseXNlXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlU25pcDogXCJHZW5lcmVlcnQgZWVuIHJhc3RlcmxhYWcgbWV0IGluZm9ybWF0aWUgb3ZlciBwaXhlbHZlcmFuZGVyaW5nZW4gbWV0IGJlaHVscCB2YW4gaGV0IHVpdHZvZXIgdmVyYW5kZXJpbmdzYW5hbHlzZXJhc3Rlci5cIixcblx0XHRkZXRlY3RDaGFuZ2VEZXNjOiBcIjxkaXY+RGUgZnVuY3RpZSBWZXJhbmRlcmluZyBkZXRlY3RlcmVuIG1ldCBiZWh1bHAgdmFuIHZlcmFuZGVyaW5nc2FuYWx5c2UgZ2VuZXJlZXJ0IGVlbiByYXN0ZXJsYWFnIG1ldCBpbmZvcm1hdGllIG92ZXIgcGl4ZWx2ZXJhbmRlcmluZ2VuIG1ldCBiZWh1bHAgdmFuIGhldCB1aXR2b2VycmFzdGVyIHZvb3IgZGUgYW5hbHlzZSB2YW4gdmVyYW5kZXJpbmdlbi4gSGV0IHZlcmFuZGVyaW5nc2FuYWx5c2VyYXN0ZXIgbW9ldCB3b3JkZW4gZ2VnZW5lcmVlcmQgZG9vciBkZSB0b29sIFZlcmFuZGVyaW5nZW4gYW5hbHlzZXJlbiBtZXQgYmVodWxwIHZhbiBDQ0RDIG9mIGRlIHRvb2wgVmVyYW5kZXJpbmdlbiBhbmFseXNlcmVuIG1ldCBiZWh1bHAgdmFuIGRlIExhbmRUcmVuZHIgb2YgZGUgQ0NEQy1hbmFseXNlcmFzdGVyZnVuY3RpZSBvZiBkZSByYXN0ZXJmdW5jdGllIExhbmRUcmVuZHItYW5hbHlzZS48L2Rpdj48YnI+PGRpdj5EZXplIHJhc3RlcmZ1bmN0aWUga2FuIHdvcmRlbiBnZWNvbWJpbmVlcmQgbWV0IGRlIENDREMgYW5hbHlzZSByYXN0ZXJmdW5jdGllIG9mIGRlIHJhc3RlcmZ1bmN0aWUgdmFuIGRlIExhbmRUcmVuZHItYW5hbHlzZSBpbiBlZW4gcmFzdGVyb2JqZWN0LiBPbSBlZW4gcGVybWFuZW50ZSByYXN0ZXJ1aXR2b2VyIHRlIHByb2R1Y2VyZW4gdmVyYmluZHQgdSBkZSBDQ0RDLWFuYWx5c2Ugb2YgTGFuZFRyZW5kci1hbmFseXNlIHVpdHZvZXIgbWV0IGRlIGZ1bmN0aWUgVmVyYW5kZXJlbiBtZXQgYmVodWxwIHZhbiBXaWp6aWdpbmdzYW5hbHlzZSwgc2xhYXQgdSBvcCBhbHMgZWVuIHJhc3RlcmZ1bmN0aWV0ZW1wbGF0ZSBlbiB2b2VydCB1IFJhc3RlcmFuYWx5c2UgdWl0IG1ldCBkZSB0ZW1wbGF0ZS48L2Rpdj48YnI+PGRpdj5EZSBwYXJhbWV0ZXI8c3Ryb25nPlR5cGUgV2lqemlnZW48L3N0cm9uZz4gZ2VlZnQgZGUgaW5mb3JtYXRpZSBhYW4gZGllIHdvcmR0IGdlZ2VuZXJlZXJkLiBEZSBpbmZvcm1hdGllIHdvcmR0IGdlaGFhbGQgdWl0IGhldCB2ZXJhbmRlcmluZ3NhbmFseXNlcmFzdGVyLiBXYW5uZWVyIHUgZGV6ZSBmdW5jdGllIG9wIGRlIHVpdHZvZXIgdmFuIGRlIENDREMtZnVuY3RpZS90b29sIHVpdHZvZXJ0LCBrdW50IHUga2llemVuIHVpdCBkZSB2b2xnZW5kZSBvcHRpZXM6PC9kaXY+PHVsPjxsaT48c3Ryb25nPlRpamRzdGlwIHZhbiBsYWF0c3RlIHdpanppZ2luZzwvc3Ryb25nPi0tZGUgbWVlc3QgcmVjZW50ZSBkYXR1bSBlbiB0aWpkIHdhYXJvcCBlZW4gcGl4ZWwgaXMgZ2VtYXJrZWVyZCBhbHMgemlqbmRlIGdld2lqemlnZC48L2xpPjxsaT48c3Ryb25nPlRpamRzdGlwIHZhbiB2cm9lZ3N0ZSB3aWp6aWdpbmc8L3N0cm9uZz4tLWRlIHZyb2Vnc3RlIGRhdHVtIGVuIHRpamQgd2Fhcm9wIGVlbiBwaXhlbCBpcyBnZW1hcmtlZXJkIGFscyB6aWpuZGUgZ2V3aWp6aWdkLjwvbGk+PGxpPjxzdHJvbmc+VGlqZHN0aXAgdmFuIGdyb290c3RlIHdpanppZ2luZzwvc3Ryb25nPi0tZGUgZGF0dW0gZW4gdGlqZCB3YWFyb3AgZGUgYmVyZWtlbmRlIHdpanppZ2luZyBoZXQgbWVlc3Qgc2lnbmlmaWNhbnQgd2FzIHZvb3IgZWVuIHBpeGVsLjwvbGk+PGxpPiA8c3Ryb25nPkFhbnRhbCB3aWp6aWdpbmdlbjwvc3Ryb25nPi0tSGV0IHRvdGFsZSBhYW50YWwga2VyZW4gZGF0IGRlIHBpeGVsIGlzIGdld2lqemlnZC48L2xpPjwvdWw+PGRpdj5CaWogaGV0IHVpdHZvZXJlbiB2YW4gZGV6ZSBmdW5jdGllIG9wIGRlIHVpdHZvZXIgdmFuIGRlIExhbmRUcmVuZHItZnVuY3RpZS90b29sIHppam4gZGUgdm9sZ2VuZGUgZXh0cmEgb3B0aWVzIGJlc2NoaWtiYWFyOjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5UaWpkc3RpcCB2YW4gbGFuZ3N0ZSB3aWp6aWdpbmc8L3N0cm9uZz4tLUhldCB0aWpkc3RpcCB3YWFyb3AgZWVuIHBpeGVsIGlzIGdlbWFya2VlcmQgYWxzIHppam5kZSBnZXdpanppZ2QsIGFhbiBoZXQgYmVnaW4gb2YgZWluZGUgdmFuIGRlIGxhbmdzdGUgcGVyaW9kZSB2YW4gd2lqemlnaW5nLjwvbGk+PGxpPjxzdHJvbmc+VGlqZHN0aXAgdmFuIGtvcnRzdGUgd2lqemlnaW5nPC9zdHJvbmc+LS1IZXQgdGlqZHN0aXAgd2Fhcm9wIGVlbiBwaXhlbCBpcyBnZW1hcmtlZXJkIGFscyB6aWpuZGUgZ2V3aWp6aWdkLCBhYW4gaGV0IGJlZ2luIG9mIGVpbmRlIHZhbiBkZSBrb3J0c3RlIHBlcmlvZGUgdmFuIHdpanppZ2luZy48L2xpPjxsaT48c3Ryb25nPlRpamRzdGlwIHZhbiBzbmVsc3RlIHdpanppZ2luZzwvc3Ryb25nPi0tZGUgZGF0dW0gd2Fhcm9wIGVlbiBwaXhlbCBhbHMgZ2V3aWp6aWdkIGlzIGdlbWFya2VlcmQsIGFhbiBoZXQgYmVnaW4gb2YgZWluZGUgdmFuIGRlIHNuZWxzdGUgdmVyYW5kZXJpbmdzcGVyaW9kZS48L2xpPjxsaT48c3Ryb25nPlRpamRzdGlwIHZhbiBsYW5nemFhbXN0ZSB3aWp6aWdpbmc8L3N0cm9uZz4tLWRlIGRhdHVtIHdhYXJvcCBlZW4gcGl4ZWwgYWxzIGdld2lqemlnZCBpcyBnZW1hcmtlZXJkLCBhYW4gaGV0IGJlZ2luIG9mIGVpbmRlIHZhbiBkZSBsYW5nemFhbXN0ZSB2ZXJhbmRlcmluZ3NwZXJpb2RlLjwvbGk+PC91bD48ZGl2PkhldCB1aXR2b2VycmFzdGVyIGlzIGVlbiBtdWx0aWJhbmRyYXN0ZXIgd2FhcmluIGVsa2UgYmFuZCB3aWp6aWdpbmdzaW5mb3JtYXRpZSBiZXZhdCwgYWZoYW5rZWxpamsgdmFuIGhldCBnZXNlbGVjdGVlcmRlIHdpanppZ2luZ3N0eXBlIGVuIGhldCBtYXhpbWFsZSBhYW50YWwgd2lqemlnaW5nZW4gZGF0IGlzIGdlc3BlY2lmaWNlZXJkLiBBbHMgYmlqdm9vcmJlZWxkIDxzdHJvbmc+VHlwZSB3aWp6aWdlbjwvc3Ryb25nPiBpcyBpbmdlc3RlbGQgb3AgPHN0cm9uZz5UaWpkIHZyb2Vnc3RlIHZlcmFuZGVyaW5nPC9zdHJvbmc+IGVuIDxzdHJvbmc+TWF4aW11bSBhYW50YWwgdmVyYW5kZXJpbmdlbjwvc3Ryb25nPiBpcyBpbmdlc3RlbGQgb3AgMiwgYmVyZWtlbnQgZGUgZnVuY3RpZSB2b29yIGVsa2UgcGl4ZWwgZGUgdHdlZSB2cm9lZ3N0ZSBkYXRhIHdhYXJvcCBkZSB2ZXJhbmRlcmluZyB6aWNoIGluIGRlIGdlaGVsZSB0aWpkcmVla3MgaGVlZnQgdm9vcmdlZGFhbi4gSGV0IHJlc3VsdGFhdCBpcyBlZW4gcmFzdGVyIHdhYXJpbiBkZSBlZXJzdGUgYmFuZCBkZSBkYXRhIHZhbiBkZSB2cm9lZ3N0ZSB2ZXJhbmRlcmluZyBwZXIgcGl4ZWwgYmV2YXQsIGVuIGRlIHR3ZWVkZSBiYW5kIGRlIGRhdGEgdmFuIGRlIG9wIMOpw6luIG5hIG91ZHN0ZSB2ZXJhbmRlcmluZyBwZXIgcGl4ZWwuPC9kaXY+PGJyPjxkaXY+V2FubmVlciB1IGRlemUgZnVuY3RpZSB0b2VwYXN0IG9wIGRlIHVpdHZvZXIgdmFuIGRlIExhbmRUcmVuZHIgdG9vbHMsIGt1bnQgdSBraWV6ZW4gb2YgdSBkZSBkYXR1bSBkaWUgaGV0IGJlZ2luIHZhbiBlZW4gdmVyYW5kZXJpbmcgbWFya2VlcnQgb2YgaGV0IGVpbmRlIHZhbiBlZW4gdmVyYW5kZXJpbmcgZXh0cmFoZWVydCBtZXQgYmVodWxwIHZhbiBkZSBwYXJhbWV0ZXIgPHN0cm9uZz5TZWdtZW50ZGF0dW08L3N0cm9uZz4gLiBPbSBiaWp2b29yYmVlbGQgdGUgYmVncmlqcGVuIGhvZSBkZSBtZWVzdCByZWNlbnRlIHZlcmFuZGVyaW5nIGluIGRlIHRpamRyZWVrcyBiZWdvbiwgc3RlbHQgdSBkZSA8c3Ryb25nPlZlcmFuZGVyaW5nc3R5cGU8L3N0cm9uZz4gaW4gb3AgPHN0cm9uZz5UaWpkc3RpcCB2YW4gZGUgbGFhdHN0ZSB2ZXJhbmRlcmluZzwvc3Ryb25nPiBlbiBkZSA8c3Ryb25nPlNlZ21lbnRkYXR1bTwvc3Ryb25nPiB0b3QgPHN0cm9uZz5CZWdpbiB2YW4gaGV0IHNlZ21lbnQ8L3N0cm9uZz4uPC9kaXY+PGJyPjxkaXY+R2VicnVpayBkZSB2b2xnZW5kZSBmaWx0ZXJwYXJhbWV0ZXJzIG9tIG1lZXIgc3BlY2lmaWVrZSB3aWp6aWdpbmdzZGF0dW1zIHVpdCB1dyB3aWp6aWdpbmdzYW5hbHlzZXJhc3RlciB0ZSBoYWxlbjo8L2Rpdj48dWw+PGxpPjxzdHJvbmc+RmlsdGVyIG9wIGphYXI8L3N0cm9uZz4tLUlkZW50aWZpY2VlciB3aWp6aWdpbmdlbiBkaWUgYmlubmVuIGVlbiBiZXBhYWxkZSB0aWpkc3BlcmlvZGUgemlqbiBvcGdldHJlZGVuLCBiaWp2b29yYmVlbGQgYWxzIHUgb3Agem9layBiZW50IG5hYXIgd2lqemlnaW5nZW4gZGllIHppam4gb3BnZXRyZWRlbiBpbiBlZW4gbGFuZHNjaGFwIGdlZHVyZW5kZSB2aWpmIGphYXIgZHJvb2d0ZS48L2xpPjxsaT48c3Ryb25nPkZpbHRlciBvcCBkdXVyPC9zdHJvbmc+LS1JZGVudGlmaWNlZXIgd2lqemlnaW5nZW4gZGllIHppam4gb3BnZXRyZWRlbiBnZWR1cmVuZGUgZWVuIGJlcGFhbGRlIHRpamRzcGFubmUsIGJpanZvb3JiZWVsZCBhbHMgdSBhbGxlZW4gb3Agem9layBiZW50IG5hYXIgYWJydXB0ZSB3aWp6aWdpbmdlbiBkaWUgemlqbiBvcGdldHJlZGVuIGdlZHVyZW5kZSAxIG9mIDIgamFhci4gVSBrdW50IGRlIGR1dXIgZGllIHUgaW50ZXJlc3NlZXJ0IGJlcmVrZW5lbiBhYW4gZGUgaGFuZCB2YW4gZGUgZm9ybXVsZSA8c3Ryb25nPmVpbmRqYWFyIC0gYmVnaW5qYWFyICsxPC9zdHJvbmc+LiBIaWF0ZW4gaW4gZGUgdGlqZHJlZWtzIHp1bGxlbiB3b3JkZW4gb3BnZW5vbWVuLjwvbGk+PGxpPjxzdHJvbmc+RmlsdGVyIG9wIGdyb290dGU8L3N0cm9uZz4tLUlkZW50aWZpY2VlciB2ZXJhbmRlcmluZ2VuIHZhbiBlZW4gYmVwYWFsZGUgZ3Jvb3R0ZSwgYmlqdm9vcmJlZWxkIGFscyB1IGFsbGVlbiBvcCB6b2VrIGJlbnQgbmFhciBncm90ZSB2ZXJhbmRlcmluZ2VuIGluIGRlIHZlZ2V0YXRpZS1pbmRleCBORFZJLiBEZSBncm9vdHRlIGlzIGVlbiBhYnNvbHV0ZSB3YWFyZGUsIGR1cyBkZSBtaW5pbXVtLSBlbiBtYXhpbXVtd2FhcmRlIGt1bm5lbiBuaWV0IG5lZ2F0aWVmIHppam4uIEdlYnJ1aWsgZGUgcGFyYW1ldGVyIDxzdHJvbmc+UmljaHRpbmcgdmVyYW5kZXJlbjwvc3Ryb25nPiBvbSBlZW4gcmljaHRpbmdzdmVyYW5kZXJpbmcgYWFuIHRlIGdldmVuPC9saT48L3VsPlwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uTmFtZTogXCJBZnN0YW5kc2FjY3VtdWxhdGllXCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25TbmlwOiBcIkJlcmVrZW50IGRlIHZlcnphbWVsZGUgYWZzdGFuZCB2b29yIGVsa2UgY2VsIG5hYXIgZGUgYnJvbm5lbiBtZXQgbW9nZWxpamtoZWlkIHRvdCBsaW5lYWlyZSBhZnN0YW5kLCBrb3N0ZW5hZnN0YW5kLCBhZnN0YW5kIGRhYWR3ZXJrZWxpamsgb3BwZXJ2bGFrIGFsc21lZGUgdmVydGljYWxlIGVuIGhvcml6b250YWxlIGtvc3RlbmZhY3RvcmVuLlwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uRGVzYzogXCJBZnN0YW5kc2FjY3VtdWxhdGllIGJlcmVrZW50IGRlIGFmc3RhbmQgdG90IGVsa2UgbG9jYXRpZSBpbiBoZXQgb25kZXJ6b2Vrc2dlYmllZCB0b3QgZGUgZGljaHRzdGJpanppam5kZSwgb2YgZ29lZGtvb3BzdGUsIGJyb24uIEFscyBhbGxlZW4gZGUgYnJvbm5lbiB2b29yIGRlIGludm9lciB6aWpuIHZvb3J6aWVuLCBkYW4gd29yZHQgZWVuIHJlY2h0ZSBhZnN0YW5kIGJlcmVrZW5kIHRvdCBlbGtlIGxvY2F0aWUgaW4gaGV0IG9uZGVyem9la3NnZWJpZWQuIEFscyBiZWlkZSBicm9ubmVuIGVuIGJhcnJpw6hyZXMgYWxzIGludm9lciB3b3JkZW4gZ2VicnVpa3QsIGRhbiBiZXJla2VudCBBZnN0YW5kc2FjY3VtdWxhdGllIGRlIGxpbmVhaXJlIGFmc3RhbmQgcm9uZCBkZSBiYXJyacOocmVzLiBWb29yIHpvd2VsIGRlIGJyb24tIGFscyBkZSBiYXJyacOocmVyYXN0ZXIgbW9ldCBkZSBhY2h0ZXJncm9uZHdhYXJkZSBOb0RhdGEgemlqbiwgdGVyd2lqbCBicm9ubmVuIGVuIGJhcnJpw6hyZXMgbWV0IGdlbGRpZ2UgY2Vsd2FhcmRlbiB3b3JkZW4gd2VlcmdlZ2V2ZW4uIEdlbGRpZ2Ugd2FhcmRlbiBiZXZhdHRlbiBudWwuIDxkaXY+PGJyLz5XYW5uZWVyIGVlbiBvcHBlcnZsYWt0ZXJhc3RlciBhbHMgaW52b2VyIHdvcmR0IGdlbGV2ZXJkLCBkYW4gd29yZHQgZGUgd2Vya2VsaWprZSBvcHBlcnZsYWt0ZWFmc3RhbmQgdHVzc2VuIGRlIGNlbGxlbiBiZXJla2VuZC4gVm9vciBoZXQgdWl0dm9lcmVuIHZhbiBlZW4ga29zdGVuYW5hbHlzZSBtZXQgYmVodWxwIHZhbiBBZnN0YW5kc2FjY3VtdWxhdGllIGlzIGVlbiBrb3N0ZW5vcHBlcnZsYWsgbm9kaWcuIEFscyBlciBlZW4ga29zdGVub3BwZXJ2bGFrIHdvcmR0IHZvb3J6aWVuLCBkYW4gaXMgaGV0IHJlc3VsdGFhdCBlZW4gZ2VhY2N1bXVsZWVyZCBrb3N0ZW5hZnN0YW5kc3Jhc3Rlci4gV2FubmVlciBob3Jpem9udGFsZSBlbiB2ZXJ0aWNhbGUgZmFjdG9yZW4gd29yZGVuIGdlbGV2ZXJkLCBkYW4gd29yZHQgZGUgZGlyZWN0aW9uYWxpdGVpdCBnZWFjY3VtdWxlZXJkIGFscyBrb3N0ZW4uIEVyIHppam4gdmllciBicm9ua2VubWVya2VuIGRpZSBrdW5uZW4gd29yZGVuIGdlYnJ1aWt0LiBEZXplIGtlbm1lcmtlbiwgZGllIHpvd2VsIHZhbiBkZSBicm9uIGFscyB2YW4gZGUgdmVycGxhYXRzZXJzIHZhbiBkZSBicm9uIGt1bm5lbiB6aWpuLCB3b3JkZW4gZ2Vjb250cm9sZWVyZCBkb29yIHNwZWNpZmlla2UgcGFyYW1ldGVyczogMS4gRGUgaW5pdGnDq2xlIGFjY3VtdWxhdGllOuKAr3N0ZWx0IGRlIGluaXRpw6tsZSBrb3N0ZW4gaW4gdm9vcmRhdCBkZSB2ZXJwbGFhdHNpbmcgYmVnaW50LiAyLiBNYXhpbWFsZSBhY2N1bXVsYXRpZTrigK9zcGVjaWZpY2VlcnQgaG9ldmVlbCBrb3N0ZW4gZWVuIGJyb24ga2FuIGFjY3VtdWxlcmVuIHZvb3JkYXQgaGlqIHppam4gbGltaWV0IGJlcmVpa3QuIDMuIFZlcm1lbmlndnVsZGlnaW5nc2ZhY3RvciB2b29yIGRlIGtvc3RlbjrigK9zcGVjaWZpY2VlcnQgZGUgd2lqemUgdmFuIHJlaXplbiBvZiBkZSBncm9vdHRlIGJpaiBkZSBicm9uLiA0LiBSZWlzcmljaHRpbmc64oCvaWRlbnRpZmljZWVydCBvZiBkZSB2ZXJwbGFhdHNlciBiZWdpbnQgYmlqIGVlbiBicm9uIGVuIHppY2ggdmVycGxhYXRzdCBuYWFyIG5pZXQtYnJvbmxvY2F0aWVzLCBvZiwgYmVnaW50IGJpaiBuaWV0LWJyb25sb2NhdGllcyBlbiB6aWNoIHRlcnVnIHZlcnBsYWF0c3QgbmFhciBlZW4gYnJvbi48ZGl2Pjxici8+U3RhbmRhYXJkIGlzIGhldCByZXN1bHRhYXQgdmFuIEFmc3RhbmRzYWNjdW11bGF0aWUgZWVuIGVua2VsZSBiYW5kLCBkYXQgaXMgaGV0IGFmc3RhbmRzYWNjdW11bGF0aWVyYXN0ZXIuIEVyIGthbiBlY2h0ZXIgb29rIGVlbiB0d2VlZGUgYmFuZCB3b3JkZW4gZ2VjcmXDq2VyZCwgZGUgYmFuZCB0ZXJ1Z3dlZy4gRGV6ZSBiYW5kIGdlZWZ0IHZhbnVpdCBlbGtlIGxvY2F0aWUgaW4gaGV0IG9uZGVyem9la3NnZWJpZWQgYWFuIGluIHdlbGtlIHJpY2h0aW5nIGplIG1vZXQgZ2FhbiBvbSBkZSBnb2Vka29vcHN0ZSBicm9uIHRlIGJlcmVpa2VuLiBCZWlkZSBiYW5kZW4gemlqbiBub2RpZyBvbSBvcHRpbWFsZSBwYWRlbiBiaW5uZW4gaGV0IG9uZGVyem9la3NnZWJpZWQgdGUgYmVwYWxlbi4gR2VicnVpayBvbSBlZW4gcGFkIHRlIGdlbmVyZXJlbiBlZXJzdCBkZSBmdW5jdGllIEJhbmQgZXh0cmFoZXJlbiBvbSBoZXQgcmFzdGVyIGFmc3RhbmRzYWNjdW11bGF0aWUgZW4gaGV0IHJhc3RlciB0ZXJ1Z3dlZyB0ZSBleHRyYWhlcmVuLiBHZWJydWlrIGRlemUgbGFnZW4gYWxzIGludm9lciB2b29yIGRlIGZ1bmN0aWUgS29zdGVucGFkLiBHZWJydWlrIGluIGRlemUgZnVuY3RpZSBoZXQgcmFzdGVyIGFmc3RhbmRzYWNjdW11bGF0aWUgYWxzIGRlIGludm9lciBSYXN0ZXIgYWZzdGFuZCBrb3N0ZW4gZW4gaGV0IHJhc3RlciB0ZXJ1Z3dlZyBhbHMgZGUgaW52b2VyIFJhc3RlciB0ZXJ1Z2tvcHBlbGluZyBrb3N0ZW4uPC9kaXY+XCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uTmFtZTogXCJBZnN0YW5kdG9ld2lqemluZ1wiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvblNuaXA6IFwiQmVyZWtlbnQgZGUgYWZzdGFuZHN0b2V3aWp6aW5nIHZvb3IgZWxrZSBjZWwgdG90IGRlIGdlZ2V2ZW4gYnJvbm5lbiBvcCBiYXNpcyB2YW4gZGUgbGluZWFpcmUgYWZzdGFuZCwga29zdGVuYWZzdGFuZCwgZGFhZHdlcmtlbGlqa2Ugb3BwZXJ2bGFrdGUtYWZzdGFuZCBlbiB2ZXJ0aWNhbGUgZW4gaG9yaXpvbnRhbGUga29zdGVuZmFjdG9yZW4uXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uRGVzYzogXCJBZnN0YW5kc3RvZXdpanppbmcgYmVyZWtlbnQgYWFuIHdlbGtlIGJyb24gZWxrZSBsb2NhdGllIGluIGhldCBvbmRlcnpvZWtzZ2ViaWVkIHdvcmR0IHRvZWdld2V6ZW4uIEFscyBhbGxlZW4gZGUgYnJvbm5lbiB6aWpuIHZvb3J6aWVuIHZvb3IgZGUgaW52b2VyLCBkYW4gd29yZGVuIGRlIGxvY2F0aWVzIHRvZWdld2V6ZW4gbWV0IGJlaHVscCB2YW4gZWVuIGxpbmVhaXJlIGFmc3RhbmQgdG90IGRlIGRpY2h0c3RiaWp6aWpuZGUgYnJvbi4gQWxzIGJlaWRlIGJyb25uZW4gZW4gYmFycmnDqHJlcyBhbHMgaW52b2VyIHdvcmRlbiBnZWJydWlrdCwgZGFuIGJlcmVrZW50IEFmc3RhbmR0b2V3aWp6aW5nIGRlIGxpbmVhaXJlIGFmc3RhbmQgcm9uZCBiYXJyacOocmVzIG9tIHRlIGJlcGFsZW4gYWFuIHdlbGtlIGJyb24gZWVuIGxvY2F0aWUgd29yZHQgdG9lZ2V3ZXplbi4gVm9vciB6b3dlbCBkZSBicm9uLSBhbHMgZGUgYmFycmnDqHJlcmFzdGVyIG1vZXQgZGUgYWNodGVyZ3JvbmR3YWFyZGUgTm9EYXRhIHppam4sIHRlcndpamwgYnJvbm5lbiBlbiBiYXJyacOocmVzIG1ldCBnZWxkaWdlIGNlbHdhYXJkZW4gd29yZGVuIHdlZXJnZWdldmVuLiBHZWxkaWdlIHdhYXJkZW4gYmV2YXR0ZW4gbnVsLjxkaXY+PGJyLz5Wb29yIGhldCB1aXR2b2VyZW4gdmFuIGVlbiBrb3N0ZW5hbmFseXNlIG1ldCBiZWh1bHAgdmFuIEFmc3RhbmR0b2V3aWp6aW5nIGlzIGVlbiBrb3N0ZW5vcHBlcnZsYWsgbm9kaWcuIEFscyBlciBlZW4ga29zdGVub3BwZXJ2bGFrIHdvcmR0IG9wZ2VnZXZlbiwgZGFuIGlzIGhldCByZXN1bHRhYXQgZWVuIHZlcmRlZWxyYXN0ZXIgb3AgYmFzaXMgdmFuIGRlIGN1bXVsYXRpZXZlIGtvc3RlbiwgbmlldCBvcCBiYXNpcyB2YW4gZGUgbGluZWFpcmUgYWZzdGFuZC4gV2FubmVlciBob3Jpem9udGFsZSBlbiB2ZXJ0aWNhbGUgZmFjdG9yZW4gd29yZGVuIGdlbGV2ZXJkLCBkYW4gd29yZHQgZGUgZGlyZWN0aW9uYWxpdGVpdCBnZWFjY3VtdWxlZXJkIGFscyBrb3N0ZW4uIFdhbm5lZXIgZXIgZWVuIG9wcGVydmxha3RlcmFzdGVyIHdvcmR0IGdlbGV2ZXJkIGFscyBpbnZvZXIsIGRhbiB3b3JkdCBiaWogZGUgYmVwYWxpbmcgdmFuIGRlIGFsbG9jYXRpZSBkZSB3ZXJrZWxpamtlIG9wcGVydmxha3RlYWZzdGFuZCBiZXJla2VuZCBkaWUgd29yZHQgYWZnZWxlZ2QgdHVzc2VuIGRlIGNlbGxlbi4gRXIgemlqbiB2aWVyIGJyb25rZW5tZXJrZW4gZGllIGt1bm5lbiB3b3JkZW4gZ2VicnVpa3QuIERlemUga2VubWVya2VuLCBkaWUgem93ZWwgdmFuIGRlIGJyb24gYWxzIHZhbiBkZSB2ZXJwbGFhdHNlcnMgdmFuIGRlIGJyb24ga3VubmVuIHppam4sIHdvcmRlbiBnZWNvbnRyb2xlZXJkIGRvb3Igc3BlY2lmaWVrZSBwYXJhbWV0ZXJzOiAxLiBJbml0acOrbGUgYWNjdW11bGF0aWU64oCvc3RlbHQgZGUgaW5pdGnDq2xlIGtvc3RlbiBpbiB2b29yZGF0IGRlIHZlcnBsYWF0c2luZyBiZWdpbnQuIDIuIE1heGltYWxlIGFjY3VtdWxhdGllOuKAr3NwZWNpZmljZWVydCBob2V2ZWVsIGtvc3RlbiBlZW4gYnJvbiBrYW4gYWNjdW11bGVyZW4gdm9vcmRhdCBoaWogemlqbiBsaW1pZXQgYmVyZWlrdC4gMy4gVmVybWVuaWd2dWxkaWdpbmdzZmFjdG9yIHZvb3IgZGUga29zdGVuOuKAr3NwZWNpZmljZWVydCBkZSB3aWp6ZSB2YW4gcmVpemVuIG9mIGRlIGdyb290dGUgYmlqIGRlIGJyb24uIDQuIFJlaXNyaWNodGluZzrigK9pZGVudGlmaWNlZXJ0IG9mIGRlIHZlcnBsYWF0c2VyIGJlZ2ludCBiaWogZWVuIGJyb24gZW4gemljaCB2ZXJwbGFhdHN0IG5hYXIgbmlldC1icm9ubG9jYXRpZXMsIG9mLCBiZWdpbnQgYmlqIG5pZXQtYnJvbmxvY2F0aWVzIGVuIHppY2ggdGVydWcgdmVycGxhYXRzdCBuYWFyIGVlbiBicm9uLjxkaXY+PGJyLz5TdGFuZGFhcmQgaXMgaGV0IHJlc3VsdGFhdCB2YW4gQWZzdGFuZHN0b2V3aWp6aW5nIGVlbiBlbmtlbGUgYmFuZCwgZGF0IGlzIGhldCBhZnN0YW5kc3RvZXdpanppbmdzcmFzdGVyLiBIZXQgYWFudmlua2VuIHZhbiBkZSBCb29sZWFhbnNlIG9wdGllIEdlbmVyZWVyIGJyb25yaWogZW4ga29sb20gYWxzIGV4dHJhIGJhbmRlbiBpbiBkZSB1aXR2b2VyIHphbCByZXN1bHRlcmVuIGluIGVlbiBtdWx0aWJhbmRyYXN0ZXIgYmVzdGFhbmRlIHVpdCBkcmllIGJhbmRlbi4gRGUgZWVyc3RlIGJhbmQgaXMgZGUgYWZzdGFuZHRvZXdpanppbmdzYmFuZCwgZGUgdHdlZWRlIGJhbmQgYmV2YXQgZWVuIHJpamluZGV4IGVuIGRlIGRlcmRlIGJhbmQgYmV2YXQgZWVuIGtvbG9taW5kZXguIERlemUgaW5kZXhlbiBpZGVudGlmaWNlcmVuIGRlIGxvY2F0aWUgdmFuIGRlIGJyb25jZWwgZGllIGRlIG1pbnN0IGdlYWNjdW11bGVlcmRlIGtvc3RlbmFmc3RhbmQgaXMuIERlIGJyb25yaWotaW5kZXggZW4gZGUgYnJvbmtvbG9taW5kZXgga3VubmVuIHNhbWVuIHdvcmRlbiBnZWJydWlrdCBvbSBkZSBpbnRlbnNpdGVpdCBpbiBrYWFydCB0ZSBicmVuZ2VuLiBBbHMgdSBlZW4gbG9jYXRpZSBpbiB1dyBvbmRlcnpvZWtzZ2ViaWVkIG92ZXIgZGUgYmFuZGVuIHR3ZWUgZW4gZHJpZSBiZXZyYWFndCwgd2VldCB1IGRlIHJpaiBlbiBkZSBrb2xvbSB2YW4gZGUgbGFhZ3N0ZSBrb3N0ZW5icm9uIHZvb3IgZGllIGxvY2F0aWUuPC9kaXY+XCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvbk5hbWU6IFwiRXVjbGlkaXNjaGUgdGVydWd3ZWdcIixcblx0XHRldWNCYWNrRGlyZWN0aW9uU25pcDogXCJCZXJla2VudCB2b29yIGVsa2UgY2VsIGRlIHJpY2h0aW5nLCBpbiBncmFkZW4sIG5hYXIgZGUgbmFidXJpZ2UgY2VsIGxhbmdzIGhldCBrb3J0c3RlIHBhZCB0ZXJ1ZyBuYWFyIGRlIGRpY2h0c3RiaWp6aWpuZGUgYnJvbiwgdGVyd2lqbCBiYXJyacOocmVzIHdvcmRlbiB2ZXJtZWRlbi5cIixcblx0XHRldWNCYWNrRGlyZWN0aW9uRGVzYzogXCJEZSBFdWNsaWRpc2NoZSB0ZXJ1Z3dlZyByZXN1bHRlZXJ0IGluIGVlbiBjb250aW51IGRyaWpmcHVudHJhc3RlciBkYXQgZGUgcmljaHRpbmcgaW4gZ3JhZGVuIHRlcnVnIG5hYXIgZGUgZGljaHRzdGJpanppam5kZSBicm9uIHdlZXJnZWVmdCwgdGVyd2lqbCBiYXJyacOocmVzIHdvcmRlbiB2ZXJtZWRlbiwgYWxzIGVyIGJhcnJpw6hyZXMgd29yZGVuIGFhbmdlYnJhY2h0LjxkaXY+PGJyLz5EZSBpbmdhbmdlbiBuYWFyIEV1Y2xpZGlzY2hlIHRlcnVnd2VnIHppam4gZGUgYnJvbiB3YWFydm9vciBkZSByaWNodGluZyB3b3JkdCBiZXJla2VuZC4gRWVuIG9wdGlvbmVsZSBpbnZvZXIgaXMgZWVuIHJhc3RlciBkYXQgYmFycmnDqHJlcyBiaW5uZW4gaGV0IG9uZGVyem9la3NnZWJpZWQgdmVydGVnZW53b29yZGlndC4gVm9vciB6b3dlbCBkZSBicm9uLSBhbHMgZGUgYmFycmnDqHJlcmFzdGVyIG1vZXQgZGUgYWNodGVyZ3JvbmR3YWFyZGUgTm9EYXRhIHppam4sIHRlcndpamwgYnJvbm5lbiBlbiBiYXJyacOocmVzIG1ldCBnZWxkaWdlIHdhYXJkZW4gd29yZGVuIHdlZXJnZWdldmVuLiBHZWxkaWdlIHdhYXJkZW4gYmV2YXR0ZW4gbnVsLiBTdGFuZGFhcmQgdmVyd2Vya3QgZGUgYmVyZWtlbmluZyBkZSBnZWNvbWJpbmVlcmRlIG9tdmFuZyB2YW4gZGUgYnJvbm5lbiBlbiBiYXJyacOocmVzLCBwbHVzIDIgcmlqZW4gZW4ga29sb21tZW4uIEFscyBkZSBhbmFseXNlIGFsbGVlbiBub2RpZyBpcyBiaW5uZW4gZWVuIGJlcGFhbGRlIGFmc3RhbmQgdmFuIGRlIGJyb25uZW4sIGRhbiBrYW4gZGUgcGFyYW1ldGVyIE1heGltYWxlIGFmc3RhbmQgd29yZGVuIGdlYnJ1aWt0LiBFdWNsaWRpc2NoZSB0ZXJ1Z3dlZyBvbmRlcnN0ZXVudCB6b3dlbCBlZW4gUGxhbmFpcmUgbWV0aG9kZSBhbHMgZWVuIEdlb2RldGlzY2hlIG1ldGhvZGUgaW4gZGUgYmVyZWtlbmluZy4gRGUgYmVyZWtlbmluZyBQbGFuYWlyZSBtZXRob2RlIHdvcmR0IHVpdGdldm9lcmQgb3AgZWVuIGdlcHJvamVjdGVlcmQgcGxhdCB2bGFrIG1ldCBiZWh1bHAgdmFuIGVlbiAyRCBDYXJ0ZXNpYWFucyBjb8O2cmRpbmF0ZW5zeXN0ZWVtLiBEZSBiZXJla2VuaW5nIHZhbiBkZSBnZW9kZXRpc2NoZSBtZXRob2RlIHdvcmR0IHVpdGdldm9lcmQgb3AgZGUgZWxsaXBzb8OvZGUsIHdhdCBiZXRla2VudCBkYXQgZGUgcmVzdWx0YXRlbiwgb25nZWFjaHQgZGUgaW4tIG9mIHVpdHZvZXJwcm9qZWN0aWUsIG5pZXQgdmVyYW5kZXJlbi48ZGl2Pjxici8+SGV0IHJlc3VsdGFhdCB2YW4gZGUgZnVuY3RpZSBFdWNsaWRpc2NoZSB0ZXJ1Z3dlZyBrYW4gc2FtZW4gbWV0IGhldCByZXN1bHRhYXQgdmFuIGRlIGZ1bmN0aWUgRXVjbGlkaXNjaGUgYWZzdGFuZCB3b3JkZW4gZ2VicnVpa3Qgb20gZGUga29ydHN0ZSBwYWRlbiB2YW4gbG9jYXRpZXMgYmlubmVuIGhldCBvbmRlcnpvZWtzZ2ViaWVkIHRlcnVnIG5hYXIgZGUgYnJvbiB0ZSBiZXBhbGVuLiBab3dlbCBoZXQgcmVzdWx0YWF0IHZhbiBkZSBFdWNsaWRpc2NoZSB0ZXJ1Z3dlZyBhbHMgaGV0IHJlc3VsdGFhdCB2YW4gZGUgRXVjbGlkaXNjaGUgYWZzdGFuZCB3b3JkZW4gaW4gZGUgZnVuY3RpZSBLb3N0ZW5wYWQgZ2VicnVpa3QsIHNhbWVuIG1ldCBkZSBiZXN0ZW1taW5nZW4gb20gZGUga29ydHN0ZSBwYWRlbiB0ZSBnZW5lcmVyZW4uPC9kaXY+XCIsXG5cdFx0ZXhwYW5kTmFtZTogXCJVaXRrbGFwcGVuXCIsXG5cdFx0ZXhwYW5kU25pcDogXCJLbGFwdCBnZXNlbGVjdGVlcmRlIHpvbmVzIHZhbiBlZW4gcmFzdGVyIHVpdCBtZXQgZWVuIGJlcGFhbGQgYWFudGFsIGNlbGxlbi5cIixcblx0XHRleHBhbmREZXNjOiBcIk1ldCBkZSBmdW5jdGllIFVpdGtsYXBwZW4ga3VudCB1IHJhc3RlcnMgdmVyYWxnZW1lbmVuIG9mIHZlcmVlbnZvdWRpZ2VuIGRvb3IgYmVwYWFsZGUgem9uZXMgZ3JvdGVyIHRlIG1ha2VuLiBVIGt1bnQgb29rIGRlIGhvZXZlZWxoZWlkIHZlcmFsZ2VtZW5pbmcgZGllIHphbCBvcHRyZWRlbiBjb250cm9sZXJlbi48ZGl2Pjxici8+RGUgem9uZXMgZGllIHUgc2VsZWN0ZWVydCwgd29yZGVuIGdyb3RlciBkb29yIHVpdGJyZWlkaW5nIG5hYXIgYW5kZXJlIHpvbmVzLiBDb25jZXB0dWVlbCBrdW5uZW4gZGUgZ2VzZWxlY3RlZXJkZSB6b25ld2FhcmRlbiB3b3JkZW4gZ2V6aWVuIGFscyB2b29yZ3JvbmR6b25lcywgdGVyd2lqbCBkZSBhbmRlcmUgd2FhcmRlbiBhY2h0ZXJncm9uZHpvbmVzIGJsaWp2ZW4uIERlIHZvb3Jncm9uZHpvbmVzIGt1bm5lbiB6aWNoIHVpdGJyZWlkZW4gbmFhciBkZSBhY2h0ZXJncm9uZHpvbmVzLjxkaXY+PGJyLz5EZSBob2V2ZWVsaGVpZCBnZW5lcmFsaXNhdGllIGthbiB3b3JkZW4gZ2VyZWdlbGQgbWV0IGRlIHBhcmFtZXRlciBBYW50YWwgY2VsbGVuLiBTdGFuZGFhcmQgaXMgZGV6ZSB3YWFyZGUgMSwgd2F0IGJldGVrZW50IGRhdCBkZSBnZXNlbGVjdGVlcmRlIHpvbmVzIHppY2ggdWl0YnJlaWRlbiBpbiBlZW4gbWF0aWUgZGllIG92ZXJlZW5rb210IG1ldCBkZSBncm9vdHRlIHZhbiBlZW4gY2VsLiBPbSBkZSBtYXRlIHZhbiBnZW5lcmFsaXNhdGllIHRlIHZlcmhvZ2VuLCBrdW50IHUgZWVuIGdyb3RlcmUgd2FhcmRlIHZvb3IgZGV6ZSBwYXJhbWV0ZXIgb3BnZXZlbi4gQ29uY2VwdHVlZWwgaXMgZGl0IGFscyBoZXQgdWl0dm9lcmVuIHZhbiBkZSB0b29sIHpvIHZhYWsgYWxzIGhldCBvcGdlZ2V2ZW4gYWFudGFsLCB3YWFyYmlqIGRlIHJlc3VsdGF0ZW4gdmFuIGRlIHZvcmlnZSBydW4gZGUgaW5wdXQgemlqbiB2b29yIGRlIHZvbGdlbmRlIGl0ZXJhdGllLjwvZGl2PlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNOYW1lOiBcIlRyZW5kIGdlbmVyZXJlblwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTbmlwOiBcIlNjaGF0IGRlIHRyZW5kIHZvb3IgZWxrZSBwaXhlbCBpbiBlZW4gYWZtZXRpbmcgdm9vciBlZW4gb2YgbWVlcmRlcmUgdmFyaWFiZWxlbiBpbiBlZW4gbXVsdGlkaW1lbnNpb25hYWwgcmFzdGVyLlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNEZXNjOiBcIjxkaXY+RGV6ZSBmdW5jdGllIGthbiB3b3JkZW4gZ2VicnVpa3Qgb20gZ2VnZXZlbnMgbGFuZ3MgZWVuIGxpbmVhaXJlLCBoYXJtb25pc2NoZSBvZiBwb2x5bm9taWFsZSB0cmVuZGxpam4gdGUgcGxhYXRzZW4sIG9mIGhldCBrYW4gd29yZGVuIGdlYnJ1aWt0IG9tIHRyZW5kZGV0ZWN0aWUgdWl0IHRlIHZvZXJlbiBtZXQgYmVodWxwIHZhbiBkZSBNYW5uLUtlbmRhbGwgb2YgU2Vhc29uYWwtS2VuZGFsbCB0ZXN0LjwvZGl2Pjxicj48ZGl2PkhldCB1aXR2b2VydHJlbmRyYXN0ZXIgZGF0IG1ldCBkZXplIGZ1bmN0aWUgd29yZHQgZ2VnZW5lcmVlcmQsIHdvcmR0IGdlYnJ1aWt0IGFscyBpbnB1dCB2b29yIGRlIDxzdHJvbmc+UHJlZGljdCBVc2luZyBUcmVuZDwvc3Ryb25nPiBmdW5jdGllLjwvZGl2Pjxicj48ZGl2PkRlIE1hbm4tS2VuZGFsbCBlbiBTZWFzb25hbC1LZW5kYWxsIHRlc3RzIHdvcmRlbiBnZWJydWlrdCBvbSB0ZSBiZXBhbGVuIG9mIGVyIGVlbiBtb25vdG9uZSB0cmVuZCBpbiBkZSBnZWdldmVucyB6aXQuIFplIHppam4gbmlldC1wYXJhbWV0cmlzY2gsIHdhdCBiZXRla2VudCBkYXQgemUgbmlldCB1aXRnYWFuIHZhbiBlZW4gc3BlY2lmaWVrZSB2ZXJkZWxpbmcgdmFuIGdlZ2V2ZW5zLiBEZSBNYW5uLUtlbmRhbGwgdGVzdCBob3VkdCBnZWVuIHJla2VuaW5nIG1ldCBzZXJpw6tsZSBjb3JyZWxhdGllIG9mIHNlaXpvZW5zZ2Vib25kZW4gZWZmZWN0ZW4uIEFscyBkZSBnZWdldmVucyBzZWl6b2Vuc2dlYm9uZGVuIHppam4sIGlzIGRlIFNlYXNvbmFsLUtlbmRhbGwtdGVzdCBnZXNjaGlrdGVyLjwvZGl2Pjxicj48ZGl2PkFscyBkZSB0b29sIHdvcmR0IGdlYnJ1aWt0IG9tIGRlIE1hbm4tS2VuZGFsbC0gb2YgU2Vhc29uYWwtS2VuZGFsbC10ZXN0IHVpdCB0ZSB2b2VyZW4sIGlzIGRlIG91dHB1dCBlZW4gdmlqZmJhbmRlbi1yYXN0ZXIgYWxzIHZvbGd0OjwvZGl2Pjx1bD48bGk+QmFuZCAxID0gU2VuJ3Mgc2xvcGU8L2xpPjxsaT5CYW5kIDIgPSBwLXdhYXJkZTwvbGk+PGxpPkJhbmQgMyA9IE1hbm4tS2VuZGFsbCBzY29yZSAoUyk8L2xpPjxsaT5CYW5kIDQgPSBTIFZhcmlhbmNlPC9saT48bGk+QmFuZCA0ID0gUyBWYXJpYW5jZTwvbGk+PGxpPkJhbmQgNSA9IFotc2NvcmU8L2xpPjwvdWw+PGRpdj5EZSBvdXRwdXQgdmFuIGRlIE1hbm4tS2VuZGFsbCBvZiBTZWFzb25hbC1LZW5kYWxsIHRlc3Qga2FuIHdvcmRlbiBnZWJydWlrdCBvbSB0ZSBiZXBhbGVuIHdlbGtlIHBpeGVscyBpbiB1dyBtdWx0aWRpbWVuc2lvbmFsZSB0aWpkcmVla3NlbiBlZW4gc3RhdGlzdGlzY2ggc2lnbmlmaWNhbnRlIHRyZW5kIGhlYmJlbi4gVSBrdW50IGRlemUgaW5mb3JtYXRpZSBnZWJydWlrZW4gaW4gY29tYmluYXRpZSBtZXQgZGUgbGluZWFpcmUsIGhhcm1vbmlzY2hlIG9mIHBvbHlub21pYWxlIHRyZW5kYW5hbHlzZSBvbSBzaWduaWZpY2FudGUgdHJlbmRzIGluIHV3IHRpamRyZWVrc2VuIHRlIGV4dHJhaGVyZW4uIFUga3VudCBlZW4gbWFza2VyIGluY2x1c2llZiBwaXhlbHMgbWV0IHNpZ25pZmljYW50ZSBwLXdhYXJkZW4gZ2VuZXJlcmVuLCBoZXQgbWFza2VyIG9wIGhldCBtdWx0aWRpbWVuc2lvbmFsZSByYXN0ZXIgdG9lcGFzc2VuIGVuIGRpdCBnZW1hc2tlcmRlIG11bHRpZGltZW5zaW9uYWxlIHJhc3RlciBnZWJydWlrZW4gYWxzIGlucHV0IHZvb3IgZGUgdG9vbCBvbSBlZW4gbGluZWFpcmUsIGhhcm1vbmlzY2hlIG9mIHBvbHlub21pYWxlIHRyZW5kYW5hbHlzZSB1aXQgdGUgdm9lcmVuLjwvZGl2Pjxicj48ZGl2PkVyIHppam4gZHJpZSB0cmVuZGxpam5vcHRpZXMgdm9vciBoZXQgYWFucGFzc2VuIHZhbiBlZW4gdHJlbmQgYWFuIGRlIHZhcmlhYmVsZSB3YWFyZGVuIGxhbmdzIGVlbiBkaW1lbnNpZTogbGluZWFpciwgcG9seW5vbWlhYWwgZW4gaGFybW9uaXNjaC48L2Rpdj48YnI+PGRpdj5Wb29yIGRlIGxpbmVhaXJlIHRyZW5kYW5hbHlzZSBpcyBkZSBvdXRwdXQgZWVuIGRyaWUtYmFuZHMgcmFzdGVyIGFscyB2b2xndDo8L2Rpdj48dWw+PGxpPkJhbmQgMSA9IEhlbGxpbmc8L2xpPjxsaT5CYW5kIDIgPSBPbmRlcnNjaGVwcGVuPC9saT48bGk+QmFuZCAzID0gUm9vdCBNZWFuIFNxdWFyZSBFcnJvciAoUk1TRSkgb2YgZGUgZm91dCByb25kIGRlIGJlc3QgcGFzc2VuZGUgbGlqbjwvbGk+PC91bD48ZGl2PlZvb3IgcG9seW5vbWlhbGUgdHJlbmRhbmFseXNlIGlzIGhldCBhYW50YWwgYmFuZGVuIGluIGRlIHVpdGdhbmcgYWZoYW5rZWxpamsgdmFuIGRlIHBvbHlub21pYWxlIHZvbGdvcmRlLiBUd2VlZGUtb3JkZSBwb2x5bm9taWFsZSBtb250YWdlIHByb2R1Y2VlcnQgZWVuIHZpZXItYmFuZHMgcmFzdGVyIGFscyB2b2xndDo8L2Rpdj48dWw+PGxpPkJhbmQgMSA9IFBvbHlub21pYWFsXzI8L2xpPjxsaT5CYW5kIDIgPSBQb2x5bm9taWFhbF8xPC9saT48bGk+QmFuZCAzID0gUG9seW5vbWlhYWxfMDwvbGk+PGxpPkJhbmQgNCA9IFJNU0U8L2xpPjwvdWw+PGRpdj5Qb2x5bm9taWFhbCBiZXNsYWcgdmFuIGRlcmRlIG9yZGUgcHJvZHVjZWVydCBlZW4gdmlqZmJhbmRzcmFzdGVyIGFscyB2b2xndDo8L2Rpdj48dWw+PGxpPkJhbmQgMSA9IFBvbHlub21pYWFsXzM8L2xpPjxsaT5CYW5kIDIgPSBQb2x5bm9taWFhbF8yPC9saT48bGk+QmFuZCAzID0gUG9seW5vbWlhYWxfMTwvbGk+PGxpPkJhbmQgNCA9IFBvbHlub21pYWFsXzA8L2xpPjxsaT5CYW5kIDUgPSBSTVNFPC9saT48L3VsPjxkaXY+Vm9vciBkZSBoYXJtb25pc2NoZSB0cmVuZGFuYWx5c2UgaXMgaGV0IGFhbnRhbCBiYW5kZW4gaW4gZGUgdWl0Z2FuZyBhZmhhbmtlbGlqayB2YW4gZGUgaGFybW9uaXNjaGUgZnJlcXVlbnRpZS4gV2FubmVlciBkZSBmcmVxdWVudGllIG9wIDEgc3RhYXQsIGlzIGRlIHVpdGdhbmcgZWVuIHZpamZiYW5kc3Jhc3RlciBhbHMgdm9sZ3Q6PC9kaXY+PHVsPjxsaT5CYW5kIDEgPSBTbG9wZTwvbGk+PGxpPkJhbmQgMiA9IEludGVyY2VwdDwvbGk+PGxpPkJhbmQgMyA9IEhhcm1vbmljX3NpbjE8L2xpPjxsaT5CYW5kIDQgPSBIYXJtb25pY19jb3MxPC9saT48bGk+QmFuZCA1ID0gUk1TRTwvbGk+PC91bD48ZGl2Pldhbm5lZXIgZGUgZnJlcXVlbnRpZSBvcCAyIGlzIGluZ2VzdGVsZCwgaXMgZGUgdWl0Z2FuZyBlZW4gemV2ZW5iYW5kc3Jhc3RlciBhbHMgdm9sZ3Q6PC9kaXY+PHVsPjxsaT5CYW5kIDEgPSBTbG9wZTwvbGk+PGxpPkJhbmQgMiA9IEludGVyY2VwdDwvbGk+PGxpPkJhbmQgMyA9IEhhcm1vbmljX3NpbjE8L2xpPjxsaT5CYW5kIDQgPSBIYXJtb25pY19zaW4yPC9saT48bGk+QmFuZCA1ID0gSGFybW9uaWNfc2luMjwvbGk+PGxpPkJhbmQgNiA9IEhhcm1vbmljX2NvczI8L2xpPjxsaT5CYW5kIDcgPSBSTVNFPC9saT48L3VsPjxkaXY+RGUgcGFyYW1ldGVyIDxzdHJvbmc+TGVuZ3RlIHZhbiBkZSBjeWNsdXM8L3N0cm9uZz4gdm9vciBkZSBhbmFseXNlIHZhbiBoYXJtb25pc2NoZSB0cmVuZHMgd29yZHQgZ2VicnVpa3Qgb20gaGV0IGFhbnRhbCBlbiBkZSBsZW5ndGUgdmFuIGRlIGN5Y2xpIGFhbiB0ZSBnZXZlbiBkaWUgdSBnZWR1cmVuZGUgZWVuIGRhZyBvZiBlZW4gamFhciBpbiB1dyBnZWdldmVucyB2ZXJ3YWNodCB0ZSB6aWVuLiBBbHMgdSBiaWp2b29yYmVlbGQgdmVyd2FjaHQgZGF0IHV3IGdlZ2V2ZW5zIHR3ZWUgdmFyaWF0aWVjeWNsaSBpbiBlZW4gamFhciB6dWxsZW4gZG9vcmxvcGVuLCB6YWwgZGUgbGVuZ3RlIHZhbiBkZSBjeWNsdXMgMTgyLDUgZGFnZW4gb2YgMCw1IGphYXIgemlqbi4gQWxzIGVyIG9tIGRlIGRyaWUgdXVyIHRlbXBlcmF0dXVyZ2VnZXZlbnMgd29yZGVuIHZlcnphbWVsZCBlbiBlciBpcyDDqcOpbiB2YXJpYXRpZWN5Y2x1cyBwZXIgZGFnLCBkYW4gaXMgZGUgbGVuZ3RlIHZhbiBkZSBjeWNsdXMgw6nDqW4gZGFnLjwvZGl2Pjxicj48ZGl2PkRlIHBhcmFtZXRlciA8c3Ryb25nPkZyZXF1ZW50aWU8L3N0cm9uZz4gdm9vciBkZSBhbmFseXNlIHZhbiBoYXJtb25pc2NoZSB0ZW5kZW5zZW4gd29yZHQgZ2VicnVpa3Qgb20gaGV0IGhhcm1vbmlzY2hlIG1vZGVsIHRlIGJlc2NocmlqdmVuIGRhdCBiaWogZGUgZ2VnZXZlbnMgcGFzdC4gQWxzIGRlIGZyZXF1ZW50aWUgb3AgMSB3b3JkdCBpbmdlc3RlbGQsIHdvcmR0IGVlbiBjb21iaW5hdGllIHZhbiBsaW5lYWlyZSBlbiBkZSBoYXJtb25pc2NoZSBjdXJ2ZSB2YW4gZGUgZWVyc3RlIHZvbGdvcmRlIGdlYnJ1aWt0IG9tIGhldCBtb2RlbCB0ZSBwYXNzZW4uIEFscyBkZSBmcmVxdWVudGllIDIgaXMsIHphbCBlZW4gY29tYmluYXRpZSB2YW4gbGluZWFpcmUsIGVlcnN0ZSB2b2xnb3JkZSBoYXJtb25pc2NoZSBjdXJ2ZSwgZW4gdHdlZWRlIHZvbGdvcmRlIGhhcm1vbmlzY2hlIGN1cnZlIHdvcmRlbiBnZWJydWlrdCBvbSBkZSBnZWdldmVucyBhYW4gdGUgcGFzc2VuLiBBbHMgZGUgZnJlcXVlbnRpZSAzIGlzLCB3b3JkdCBlZW4gZXh0cmEgaGFybW9uaXNjaGUgY3VydmUgdmFuIGRlIGRlcmRlIHZvbGdvcmRlIGdlYnJ1aWt0IG9tIGRlIGdlZ2V2ZW5zIHRlIG1vZGVsbGVyZW4sIGVuem92b29ydC48L2Rpdj48YnI+PGRpdj5Nb2RlbCBnb29kbmVzcy1vZi1maXQgc3RhdGlzdGlla2VuIGt1bm5lbiBnZWdlbmVyZWVyZCB3b3JkZW4gYWxzIG9wdGlvbmVsZSBvdXRwdXRzLiBEZSByb290IG1lYW4tc3F1YXJlIGVycm9yIChSTVNFKSwgUi1rd2FkcmFhdCBlbiBkZSB0cmVuZGhlbGxpbmcgcC13YWFyZGUga3VubmVuIHdvcmRlbiBiZXJla2VuZCBlbiBnZXN5bWJvbGlzZWVyZC4gU3ltYm9saXNlZXIgZGUgdWl0dm9lcnRyZW5kcmFzdGVybGFhZyBtZXQgYmVodWxwIHZhbiBkZSA8c3Ryb25nPlJHQjwvc3Ryb25nPiBzeW1ib2xvZ2llIGVuIHNwZWNpZmljZWVyIGRlIHN0YXRpc3RpZWtlbiBhbHMgZGUgcm9kZSwgZ3JvZW5lIGVuIGJsYXV3ZSBiYW5kZW48L2Rpdj48YnI+XCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ05hbWU6IFwiTGluZWFpcmUgc3BlY3RyYWxlIG9udG1lbmdpbmdcIixcblx0XHRzcGVjdHJhbFVubWl4aW5nU25pcDogXCJWb2VydCBzdWJwaXhlbGNsYXNzaWZpY2F0aWUgdWl0IGVuIGJlcmVrZW50IGRlIGZyYWN0aW9uZWxlIG92ZXJ2bG9lZCBhYW4gdmVyc2NoaWxsZW5kZSBsYW5kYmVkZWtraW5nc3R5cGVzIHZvb3IgaW5kaXZpZHVlbGUgcGl4ZWxzLlwiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdEZXNjOiBcIkRlIGZ1bmN0aWUgTGluZWFpcmUgc3BlY3RyYWxlIG9udG1lbmdpbmcgYmVyZWtlbnQgZGUgZnJhY3Rpb25lbGUgZGVra2luZyB2b29yIGluZGl2aWR1ZWxlIHBpeGVscyBkaWUgbWVlcmRlcmUgbGFuZGJlZGVra2luZ3N0eXBlcyBiZXZhdHRlbi4gSGV0IGdlbmVyZWVydCBlZW4gbXVsdGliYW5kbGFhZywgd2FhcmJpaiBlbGtlIGJhbmQgb3ZlcmVlbmtvbXQgbWV0IGRlIGZyYWN0aW9uZWxlIG92ZXJ2bG9lZCB2YW4gZWxrZSBsYW5kYmVkZWtraW5nc2tsYXNzZS4gVSBrdW50IGhldCBiaWp2b29yYmVlbGQgZ2VicnVpa2VuIG9tIGVlbiBsYW5kYmVkZWtraW5nc2NsYXNzaWZpY2F0aWUgdWl0IHRlIHZvZXJlbiBvcCBlZW4gbXVsdGlzcGVjdHJhYWwgYmVlbGQgb20gZm90b3N5bnRoZXRpc2NoZSB2ZWdldGF0aWUsIGthbGUgZ3JvbmQgZW4gZG9kZSBvZiBuaWV0LWZvdG9zeW50aGV0aXNjaGUgdmVnZXRhdGllIHRlIGlkZW50aWZpY2VyZW4uPGRpdj48YnIvPkRlIHZvbGdvcmRlIHZhbiBoZXQgdWl0dm9lcm11bHRpYmFuZHJhc3RlciB2b2xndCBkZSB2b2xnb3JkZSB2YW4gZGUgaW52b2VyIHNwZWN0cmFhbCBwcm9maWVsLiBIZXQgYWFudGFsIGtsYXNzZW4gbWFnIG5pZXQgZ3JvdGVyIHppam4gZGFuIGhldCBhYW50YWwgYmFuZGVuIGluIGhldCBpbnZvZXJyYXN0ZXIuIFUga3VudCBiaWp2b29yYmVlbGQgZ2VlbiBpbmZvcm1hdGllIG92ZXIgbWVlciBkYW4gOCBrbGFzc2VuIHVpdCBlZW4gOC1iYW5kcyByYXN0ZXIgaGFsZW4uPC9kaXY+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlck5hbWU6IFwiTXVsdGlkaW1lbnNpb25hbGUgZmlsdGVyXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uTmFtZTogXCJSYXN0ZXIgaW50ZXJwb2xlcmVuIG9wIGFmbWV0aW5nXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uU25pcDogXCJJbnRlcnBvbGVlcnQgZWVuIG11bHRpZGltZW5zaW9uYWFsIHJhc3RlciBtZXQgb3BnZWdldmVuIGRpbWVuc2lld2FhcmRlbiwgZ2VicnVpayBtYWtlbmQgdmFuIGFhbmdyZW56ZW5kZSBzbGljZXMuXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uRGVzYzogXCI8cD5EZXplIGZ1bmN0aWUgc3RlbHQgdSBlcnRvZSBpbiBzdGFhdCBwaXhlbHdhYXJkZW4gdGUgc2NoYXR0ZW4gdm9vciBlZW4gb25nZWRlZmluaWVlcmRlIGRpbWVuc2llc2xpY2UgaW4gZWVuIG11bHRpZGltZW5zaW9uYWFsIHJhc3Rlci4gQWxzIHUgYmlqdm9vcmJlZWxkIGVlbiBnZWdldmVuc3NldCBoZWJ0IGRpZSBkZSBvY2VhYW50ZW1wZXJhdHV1ciBhYW4gaGV0IG9wcGVydmxhayBlbiBkaWUgb3AgMTAwIG1ldGVyIG9uZGVyIHplZW5pdmVhdSBiZXZhdCBlbiBkZSB0ZW1wZXJhdHV1ciBvcCA1MCBtZXRlciBvbmRlciB6ZWVuaXZlYXUgd2lsdCBzY2hhdHRlbiwga3VudCB1IGRlemUgZnVuY3RpZSBnZWJydWlrZW4gb20gZWVuIHNjaGF0dGluZyB2b29yIGRpZSBkaWVwdGUgdGUga3JpamdlbiBtZXQgYmVodWxwIHZhbiBkZSBkaW1lbnNpZWRlZmluaXRpZSBCeSBWYWx1ZXMgKE9wIHdhYXJkZW4pLjwvcD48cD5VIGt1bnQgb29rIGVlbiBtYWFuZGVsaWprc2UgZ2VnZXZlbnNzZXQgZG93bnNhbXBsZW4gbmFhciBlZW4gZGFnZWxpamtzZSBnZWdldmVuc2V0IHZpYSBkZSBkaW1lbnNpZWRlZmluaXRpZSBCeSBJbnRlcnZhbCAoT3AgaW50ZXJ2YWwpIGVuIGhldCBvcGdldmVuIHZhbiBkZSBTdGFwLXBhcmFtZXRlcndhYXJkZSBhbHMgMSBlbiBkZSBFZW5oZWlkLXBhcmFtZXRlciBhbHMgZGFnZW4uPC9wPjxwPkdlYnJ1aWsgZGUgZGltZW5zaWVkZWZpbml0aWUgQnkgVGFyZ2V0IFJhc3RlciAoT3AgZG9lbHJhc3Rlcikgb20gZGUgd2FhcmRlIHZvb3IgaGV0IGRvZWxyYXN0ZXIgdGUgc2NoYXR0ZW4uPC9wPlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJTbmlwOiBcIk1hYWt0IGVlbiByYXN0ZXJsYWFnIHZhbiBlZW4gbXVsdGlkaW1lbnNpb25hbGUgcmFzdGVyZGF0YXNldCBvZiBlZW4gbXVsdGlkaW1lbnNpb25hbGUgcmFzdGVybGFhZyBkb29yIGRhdGEgaW4gc3R1a2plcyBvcCB0ZSBkZWxlbiBhYW4gZGUgaGFuZCB2YW4gZ2VkZWZpbmllZXJkZSB2YXJpYWJlbGVuIGVuIGFmbWV0aW5nZW4uXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlckRlc2M6IFwiSGV0IE11bHRpZGltZW5zaW9uYWxlIGZpbHRlciBjcmXDq2VydCBlZW4gbXVsdGlkaW1lbnNpb25hbGUgcmFzdGVybGFhZyBkb29yIGVlbiBzdWJzZXQgdmFuIHZhcmlhYmVsZW4gdWl0IGVlbiBtdWx0aWRpbWVuc2lvbmFhbCByYXN0ZXIgdGUgZmlsdGVyZW4gZW4gdGUgZXh0cmFoZXJlbi4gVSBoZWJ0IGJpanZvb3JiZWVsZCBlZW4gbXVsdGlkaW1lbnNpb25hbGUgZGF0YXNldCBkaWUgMzAgamFhciBhYW4gbWFhbmRlbGlqa3NlIG5lZXJzbGFnZ2VnZXZlbnMgYmV2YXQsIGVuIHUgd2lsdCBhbGxlZW4gZ2VnZXZlbnMgdm9vciBlbGtlIGphbnVhcmkgZXh0cmFoZXJlbiBvbSB0ZSB6aWVuIGhvZSBkZSBuZWVyc2xhZyB2b29yIGRpZSBtYWFuZCBpcyB2ZXJhbmRlcmQuPGRpdj48YnIvPkdlYnJ1aWsgZGUgcGFyYW1ldGVyIERpbWVuc2llZGVmaW5pdGllIG9tIGRpbWVuc2llcyB0ZSBzbmlqZGVuIG1ldCBiZWh1bHAgdmFuIGVlbiBpbnRlcnZhbCwgZWVuIHdhYXJkZSBvZiBlZW4gcmVla3MgdmFuIHdhYXJkZW4uIEFscyB1IGJpanZvb3JiZWVsZCBvdmVyIDEwIGphYXIgZ2VnZXZlbnMgb3ZlciBoZXQgemVlem91dGdlaGFsdGUgYmVzY2hpa3QsIGRpZSBtYWFuZGVsaWprcyB3b3JkZW4gdmVyemFtZWxkIGVuIG9wIHpvd2VsIDIgbWV0ZXIgZGllcHRlIGFscyBvcCA1MDAgbWV0ZXIsIGt1bnQgdSB2b29yIGRlIHZvbGdlbmRlIHNjZW5hcmlvJ3MgZ2VicnVpayBtYWtlbiB2YW4gZGUgdmVyc2NoaWxsZW5kZSBkaW1lbnNpb25lcmluZ3NvcHRpZXMuIFNjZW5hcmlvIDE6IEV4dHJhaGVlciBkZSB6b3V0Z2VoYWx0ZWdlZ2V2ZW5zIHZvb3IgZGUgbWFhbmQgamFudWFyaSBvdmVyIGRlIHBlcmlvZGUgdmFuIDEwIGphYXIuIEtpZXMgT3Agd2FhcmRlbiwgc3RlbCBEaW1lbnNpZSBpbiBvcCBTdGRUaWpkIGVuIHN0ZWwgV2FhcmRlbiBpbiBvcCBKYW51YXJpLiBTY2VuYXJpbyAyOiBWZXJkZWVsIGRlIHpvdXRnZWhhbHRlZ2VnZXZlbnMgb3ZlciBlZW4gZGllcHRlYmVyZWlrIHZhbiAwIHRvdCAxNTAgbWV0ZXIuIEtpZXMgb3AgT3AgYmVyZWlrLCBzdGVsIERpbWVuc2llIGluIG9wIFN0ZFogZW4gc3RlbCBNaW5pbXVtd2FhcmRlIGluIG9wIC0xNTAgZW4gTWF4aW11bXdhYXJkZSBvcCAwLiBTY2VuYXJpbyAzOiBFeHRyYWhlZXIgZGUgem91dGdlaGFsdGVnZWdldmVucyB2b29yIGRlIGVlcnN0ZSAxMCBkYWdlbiB2YW4gZWxrZSBqYW51YXJpIG92ZXIgZWVuIHBlcmlvZGUgdmFuIDEwIGphYXIuIEtpZXMgUGVyIGl0ZXJhdGllLCBzdGVsIERpbWVuc2llIGluIG9wIFN0ZFRpbWUsIHN0ZWwgU3RhcnQgdmFuIGRlIGVlcnN0ZSBpdGVyYXRpZSBlbiBFaW5kZSB2YW4gZGUgZWVyc3RlIGl0ZXJhdGllIGluIG9wIGhldCBvdmVyZWVua29tc3RpZ2UgYmVnaW4gZW4gZWluZGUgdmFuIGRlIGl0ZXJhdGllcGVyaW9kZSwgc3RlbCBTdGFwIGluIG9wIDEsIGVuIHN0ZWwgRWVuaGVpZCBpbiBvcCBKYXJlbi48L2Rpdj5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyTmFtZTogXCJNdWx0aWRpbWVuc2lvbmFhbCByYXN0ZXJcIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyU25pcDogXCJWb2VndCBtdWx0aWRpbWVuc2lvbmFsZSBnZWdldmVucyB0b2UgYWFuIGVlbiBrYWFydCBhbHMgZWVuIG11bHRpZGltZW5zaW9uYWxlIHJhc3RlcmxhYWcuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlckRlc2M6IFwiRGUgZnVuY3RpZSBNdWx0aWRpbWVuc2lvbmFhbCByYXN0ZXIgdm9lZ3QgbXVsdGlkaW1lbnNpb25hbGUgZ2VnZXZlbnMgdG9lIGFhbiBlZW4ga2FhcnQgYWxzIGVlbiBtdWx0aWRpbWVuc2lvbmFsZSByYXN0ZXJsYWFnLiBEZXplIGZ1bmN0aWUgaXMgbnV0dGlnIGJpaiBoZXQgdWl0dm9lcmVuIHZhbiByYXN0ZXJhbmFseXNlcyBtZXQgYmVodWxwIHZhbiBlZW4gZnVuY3RpZWtldGVuLjxkaXY+PGJyLz5PbmRlcnN0ZXVuZGUgbXVsdGlkaW1lbnNpb25hbGUgcmFzdGVyZGF0YXNldHMgemlqbiBvbmRlciBhbmRlcmUgbmV0Q0RGLCBHUklCLCBIREYgZW4gRXNyaSdzIENSRi4gTXVsdGlkaW1lbnNpb25hbGUgbW9zYWljIGRhdGFzZXRzIHdvcmRlbiBvb2sgb25kZXJzdGV1bmQuPC9kaXY+XCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3Rlck5hbWU6IFwiT3B0aW1hYWwgcGFkIGFscyByYXN0ZXJcIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyU25pcDogXCJCZXJla2VudCBoZXQgcGFkIG1ldCBkZSBtaW5zdGUga29zdGVuIHZhbiBlZW4gYnJvbiBuYWFyIGVlbiBiZXN0ZW1taW5nLlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJEZXNjOiBcIkRlemUgZ2xvYmFsZSBmdW5jdGllIHByb2R1Y2VlcnQgZWVuIHVpdHZvZXJyYXN0ZXIgd2Fhcm1lZSBoZXQgb3B0aW1hbGUgcGFkIG9mIHBhZGVuIHZhbiBnZXNlbGVjdGVlcmRlIGxvY2F0aWVzIG5hYXIgZGUgZGljaHRzdGJpanppam5kZSBicm9uY2VsIHdvcmRlbiB2YXN0Z2VsZWdkIGJpbm5lbiBoZXQgZ2VhY2N1bXVsZWVyZGUga29zdGVub3BwZXJ2bGFrLCBpbiB0ZXJtZW4gdmFuIGtvc3RlbmFmc3RhbmQuPGRpdj48YnIvPkVlbiBvZiBtZWVyIHZhbiBkZSBnZXdvZ2VuIGtvc3RlbmZ1bmN0aWVzIChBZnN0YW5kc2FjY3VtdWxhdGllIG9mIEFmc3RhbmR0b2V3aWp6aW5nKSBtb2V0ZW4gb3ZlciBoZXQgYWxnZW1lZW4gd29yZGVuIHVpdGdldm9lcmQgdm9vcmRhdCBkZSBmdW5jdGllIE9wdGltYWFsIHBhZCBhbHMgcmFzdGVyIHdvcmRlbiB1aXRnZXZvZXJkIG9tIGRlIGlucHV0IGFmc3RhbmRzYWNjdW11bGF0aWUgZW4gdGVydWd3ZWdyYXN0ZXJzIHRlIGNyZcOrcmVuLiBEaXQgemlqbiB2ZXJwbGljaHRlIGludm9lcnJhc3RlcmxhZ2VuIHZvb3IgZGUgZnVuY3RpZSBPcHRpbWFhbCBwYWQuIERlIHdhYXJkZW4gb3AgZGUgdWl0dm9lciBvcHRpbWFhbCBwYWQgZ2V2ZW4gaGV0IGFhbnRhbCBwYWRlbiBvcCBlZW4gYmVwYWFsZGUgbG9jYXRpZSB3ZWVyLiBJbiB2ZWVsIGdldmFsbGVuIHZvbGdlbiBkZSBwYWRlbiBkZXplbGZkZSByb3V0ZSwgd2FhcmJpaiBlZW4gYnJvbiB3b3JkdCB2ZXJsYXRlbiBlbiB2ZXJ2b2xnZW5zIHdvcmR0IGFmZ2V3ZWtlbiBvbSBuYWFyIHZlcnNjaGlsbGVuZGUgYmVzdGVtbWluZ2VuIHRlIGdhYW4uIFpvIGdlZWZ0IGVlbiB3YWFyZGUgdmFuIMOpw6luIGFhbiBkYXQgZXIgb3AgZWVuIGJlcGFhbGRlIGxvY2F0aWUgc2xlY2h0cyDDqcOpbiBvcHRpbWFhbCBwYWQgaXMsIHRlcndpamwgZWVuIHdhYXJkZSB2YW4gdmlqZiBiZXRla2VudCBkYXQgZXIgb3AgZGllIGxvY2F0aWUgdmlqZiBvcHRpbWFsZSBwYWRlbiBkb29yIGRpZSBjZWwgaW4gaGV0IG9uZGVyem9la3NnZWJpZWQgbG9wZW4uPGRpdj48YnIvPkRlIGluZ2V2b2VyZGUgYmVzdGVtbWluZ3NnZWdldmVucyBtb2V0ZW4gZWVuIHJhc3RlcmxhYWcgemlqbi4gRGUgc2V0IGJlc3RlbW1pbmdzY2VsbGVuIGJlc3RhYXQgdWl0IGFsbGUgY2VsbGVuIGluIGhldCBpbnZvZXJyYXN0ZXIgZGllIGdlbGRpZ2Ugd2FhcmRlbiBoZWJiZW4uIENlbGxlbiBkaWUgTm9EYXRhIHdhYXJkZW4gaGViYmVuIHppam4gbmlldCBpbiBkZSBzZXQgb3BnZW5vbWVuLiBEZSB3YWFyZGUgbnVsIHdvcmR0IGJlc2Nob3V3ZCBhbHMgZWVuIGxlZ2l0aWVtZSBiZXN0ZW1taW5nLiBFZW4gYmVzdGVtbWluZ3NyYXN0ZXIga2FuIHdvcmRlbiBnZW1hYWt0IG1ldCBiZWh1bHAgdmFuIGRlIGV4dHJhY3RpZXRvb2xzLiBBbHMgdSBiZXN0ZW1taW5ncy0gb2YgYnJvbm9iamVjdGVuIGhlZWZ0LCBrdW50IHUgZGV6ZSBtZXQgYmVodWxwIHZhbiBkZSBSYXN0ZXJpemUgRmVhdHVyZXMtZnVuY3RpZSBvbXpldHRlbiBuYWFyIGVlbiByYXN0ZXIuIEdlYnJ1aWsgZGUgYWZzdGFuZGFjY3VtdWxhdGllIG9mIGRlIHJhc3RlciB0ZXJ1Z3dlZyBhbHMgZGUgcmFzdGVyaW52b2VyIHZvb3IgZGUgZnVuY3RpZSByYXN0ZXJpc2F0aWUuIERpdCB6b3JndCBlcnZvb3IgZGF0IGRlIGZ1bmN0aWUgd29yZHQgZ2VyYXN0ZXJkIG1ldCBiZWh1bHAgdmFuIGRlemVsZmRlIGNlbGdyb290dGUsIG9tdmFuZyBlbiBydWltdGVsaWprZSByZWZlcmVudGllIGFscyBkZSBhbmRlcmUgcmFzdGVycyBkaWUgaW4gZGUgZnVuY3RpZSBPcHRpbWFhbCBwYWQgYWxzIHJhc3RlciBnYWFuLiBEZSBmdW5jdGllIE9wdGltYWFsIHBhZCBhbHMgcmFzdGVyIGthbiBvb2sgd29yZGVuIGdlYnJ1aWt0IG9tIGRlIHdlZyB2YW4gZGUgbWluc3RlIHdlZXJzdGFuZCBhZiB0ZSBsZWlkZW4gbGFuZ3MgZWVuIGRpZ2l0YWFsIGhvb2d0ZW1vZGVsIChERU0pLiBHZWJydWlrIGluIGRpdCBnZXZhbCBkZSBERU0gdm9vciBoZXQgYWNjdW11bGF0aWVyYXN0ZXIgaW52b2VyYWZzdGFiZGVuIGRlIHVpdGdhbmcgdmFuIGRlIGZ1bmN0aWUgU3Ryb29tcmljaHRpbmcgdm9vciBoZXQgcmFzdGVyIHRlcnVnd2VnLjwvZGl2PlwiLFxuXHRcdHRyZW5kTmFtZTogXCJWb29yc3BlbGxlbiBtZXQgYmVodWxwIHZhbiB0cmVuZHNcIixcblx0XHR0cmVuZFNuaXA6IFwiQmVyZWtlbnQgZWVuIHZvb3JzcGVsZCBtdWx0aWRpbWVuc2lvbmFhbCByYXN0ZXIgbWV0IGJlaHVscCB2YW4gaGV0IHVpdGdldm9lcmRlIHRyZW5kcmFzdGVyIHZhbiBkZSBmdW5jdGllIFRyZW5kIGdlbmVyZXJlbiBvZiBkZSBnZW9wcm9jZXNzaW5ndG9vbCBUcmVuZHJhc3RlciBnZW5lcmVyZW4uXCIsXG5cdFx0dHJlbmREZXNjOiBcIkRlIGZ1bmN0aWUgVm9vcnNwZWxsZW4gbWV0IGJlaHVscCB2YW4gdHJlbmRzIGJlcmVrZW50IGVlbiB2b29yc3BlbGRlIG11bHRpZGltZW5zaW9uYWxlIHJhc3RlcmxhYWcgbWV0IGJlaHVscCB2YW4gaGV0IHVpdHZvZXJ0cmVuZHJhc3RlciB2YW4gZGUgZnVuY3RpZSBUcmVuZCBnZW5lcmVyZW4gb2YgZGUgZ2VvcHJvY2Vzc2luZ3Rvb2wgVHJlbmRyYXN0ZXIgZ2VuZXJlcmVuLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25OYW1lOiBcIlJhc3RlcmNvbGxlY3RpZSB2ZXJ6YW1lbGVuXCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvblNuaXA6IFwiVmVyd2Vya3QgZWxrIHN0dWtqZSBpbiBlZW4gbXVsdGlkaW1lbnNpb25hYWwgcmFzdGVyIG9mIGVsayBpdGVtIGluIGVlbiBtb3phw69la3Jhc3Rlci4gRGV6ZSBmdW5jdGllIGthbiBvb2sgbWVlcmRlcmUgc3R1a2plcyBzYW1lbnZvZWdlbiB0b3Qgw6nDqW4gc3R1a2plLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25EZXNjOiBcIkRlIGZ1bmN0aWUgUmFzdGVyY29sbGVjdGllIHZlcnphbWVsZW4gdmVyd2Vya3QgZWxrZSBzdHVramUgaW4gZWVuIG11bHRpZGltZW5zaW9uYWFsIHJhc3RlciBvZiBlbGsgaXRlbSBpbiBlZW4gbW96YcOvZWtyYXN0ZXIuIERlemUgZnVuY3RpZSBrYW4gb29rIG1lZXJkZXJlIHN0dWtqZXMgc2FtZW52b2VnZW4gdG90IMOpw6luIHN0dWtqZS48ZGl2Pjxici8+RGV6ZSBmdW5jdGllIHZlcndlcmt0IGVsayBzdHVramUgaW4gZWVuIG11bHRpZGltZW5zaW9uYWFsIHJhc3RlciBvZiBtb3phw69la3Jhc3RlciBtZXQgYmVodWxwIHZhbiBlZW4gcmFzdGVyZnVuY3RpZXRlbXBsYXRlLiBEZXplIGZ1bmN0aWUgb25kZXJzdGV1bnQgZGUgdm9sZ2VuZGUgb3B0aWVzOiAxLiBTcGVjaWZpY2VlciBlZW4gcmFzdGVyZnVuY3RpZXRlbXBsYXRlIHZvb3IgSXRlbWZ1bmN0aWUuIFUgaGVidCBiaWp2b29yYmVlbGQgZWVuIG1vemHDr2VrZGF0YXNldCBtZXQgMjAgamFhciBMYW5kc2F0LWJlZWxkZW4gZW4gdSB3aWx0IGRlIE5EVkkgdm9vciBlbGtlIHNjZW5lIGluIGRlIHRpamRyZWVrcyBiZXJla2VuZW4uIFNwZWNpZmljZWVyIHZvb3IgSXRlbWZ1bmN0aWUgZWVuIHJhc3RlcmZ1bmN0aWV0ZW1wbGF0ZSBkaWUgZGUgTkRWSSByYXN0ZXJmdW5jdGllIGJldmF0LiAyLiBTcGVjaWZpY2VlciBlZW4gcmFzdGVyZnVuY3RpZXRlbXBsYXRlIHZvb3IgZGUgZnVuY3RpZSBBZ2dyZWdhdGllLiBVIGhlYnQgYmlqdm9vcmJlZWxkIGVlbiBtdWx0aWRpbWVuc2lvbmFhbCByYXN0ZXIgZGF0IDEwIGphYXIgZGFnZWxpamtzZSB0ZW1wZXJhdHV1cmdlZ2V2ZW5zIGJldmF0IGVuIHUgd2lsdCBkZSBtYXhpbWFsZSB0ZW1wZXJhdHV1ciB2b29yIGVsayBqYWFyIGJlcmVrZW5lbi4gR2VlZiBpbiBkZSBmdW5jdGllIEFnZ3JlZ2F0aWUgZWVuIHRlbXBsYXRlIG9wIHZvb3IgZWVuIHJhc3RlcmZ1bmN0aWV0ZW1wbGF0ZSBvcCBkaWUgZGUgZnVuY3RpZSBDZWxzdGF0aXN0aWVrZW4gYmV2YXQsIHdhYXJiaWogZGUgYmV3ZXJraW5nIGlzIGluZ2VzdGVsZCBvcCBNYXhpbXVtLiBTdGVsIG9uZGVyIGRlIGRlZmluaXRpZSBBZ2dyZWdhdGllIGRlIERpbWVuc2llIGluIG9wIFN0ZFRpamQsIHN0ZWwgVHlwZSBpbiBvcCBJbnRlcnZhbCB0cmVmd29vcmQgZW4gc3RlbCBkZSBUcmVmd29vcmQgSW50ZXJ2YWwgaW4gb3AgSmFhcmxpamtzLiBIb3VkIGVyIHJla2VuaW5nIG1lZSBkYXQgYWxzIGRlIGludm9lcm1vemHDr2VrIGRhdGFzZXQgbmlldCBtdWx0aWRpbWVuc2lvbmFhbCBpcywgZGUgYWdncmVnYXRpZWZ1bmN0aWUgZGUgYWdncmVnYXRpZWRlZmluaXRpZSBuaWV0IHphbCBob25vcmVyZW4uIERlIGFnZ3JlZ2F0aWVmdW5jdGllIHphbCBhbGxlIGl0ZW1zIG9mIGVsa2UgZ3JvZXAgc2FtZW52b2VnZW4gdG90IMOpw6luIGFscyB6ZSB6aWpuIGdlZGVmaW5pZWVyZCBpbiBkZSB0ZW1wbGF0ZSB2YW4gZGUgYWdncmVnYXRpZWZ1bmN0aWUuIFZvb3IgbWVlciBpbmZvcm1hdGllIG92ZXIgaGV0IGdlYnJ1aWsgdmFuIGdyb2VwZW4gaW4gZWVuIG1vemHDr2VrZGF0YXNldCwgemllIE1vemHDr2VrZGF0YXNldC1pdGVtcyBnZWJydWlrZW4gaW4gUmFzdGVyZnVuY3RpZXRlbXBsYXRlcy4gMy4gU3BlY2lmaWNlZXIgZWVuIHJhc3RlcmZ1bmN0aWV0ZW1wbGF0ZSB2b29yIGRlIGZ1bmN0aWUgVmVyd2Vya2luZy4gRGUgZnVuY3RpZSBvZiBmdW5jdGlla2V0ZW4gaW4gZGV6ZSB0ZW1wbGF0ZSB3b3JkdCBnZWJydWlrdCBvbSBoZXQgbmlldXdlIHZlcndlcmt0ZSByYXN0ZXIgd2VlciB0ZSBnZXZlbi4gU3BlY2lmaWNlZXIgYmlqdm9vcmJlZWxkIGVlbiByYXN0ZXJmdW5jdGlldGVtcGxhdGUgZGllIGRlIGZ1bmN0aWUgS2xldXJlbmthYXJ0IGJldmF0IG9tIHRlIHdpanppZ2VuIGhvZSBkZSB2ZXJ3ZXJrdGUgcmFzdGVybGFhZyB3b3JkdCB3ZWVyZ2VnZXZlbi4gSG91ZCBlciByZWtlbmluZyBtZWUgZGF0IGFscyBkZSBpbnZvZXIgZWVuIG11bHRpZGltZW5zaW9uYWFsIHJhc3RlciBpcywgZGUgdmVyd2Vya2luZ3NmdW5jdGllIHdvcmR0IHRvZWdlcGFzdCBvcCBoZXQgaHVpZGlnZSBzdHVramUuIEFscyBkZSBpbnZvZXIgZWVuIG1vemHDr2VrbGFhZyBvZiBtb3phw69la2RhdGFzZXQgaXMsIHdvcmR0IGRlIHZlcndlcmtpbmdzZnVuY3RpZSB0b2VnZXBhc3Qgb3AgaGV0IG1vemHDr2VrcmFzdGVyIG1ldCBiZWh1bHAgdmFuIGRlIGVlcnN0ZSBtZXRob2RlIG9tIG92ZXJsYXBwaW5nZW4gb3AgdGUgbG9zc2VuLiAzLiBTcGVjaWZpY2VlciB0ZW1wbGF0ZXMgdm9vciBlbGtlIGNvbWJpbmF0aWUgdmFuIGRlIGRyaWUgZnVuY3RpZXMuIFUgaGVidCBiaWp2b29yYmVlbGQgZWVuIG1vemHDr2VrZGF0YXNldCBtZXQgdGlqZHJlZWtzZW4gTGFuZHNhdC1iZWVsZGVuIGVuIHUgd2lsdCBlZW4gY29tcG9zaXRpZWZvdG8gdmFuIG1heGltYWFsIE5EVkkgZ2VuZXJlcmVuLiBTcGVjaWZpY2VlciB2b29yIEl0ZW1mdW5jdGllIGVlbiByYXN0ZXJmdW5jdGlldGVtcGxhdGUgZGllIGRlIE5EVkkgcmFzdGVyZnVuY3RpZSBiZXZhdC4gR2VlZiB2b29yIGRlIGZ1bmN0aWUgQWdncmVnYXRpZSBlZW4gdGVtcGxhdGUgb3Agdm9vciBlZW4gcmFzdGVyZnVuY3RpZXRlbXBsYXRlIG9wIGRpZSBkZSBmdW5jdGllIENlbHN0YXRpc3RpZWtlbiBiZXZhdCwgd2FhcmJpaiBkZSBiZXdlcmtpbmcgaXMgaW5nZXN0ZWxkIG9wIE1heGltdW0uIFNwZWNpZmljZWVyIHZvb3IgZGUgdmVyd2Vya2luZ3NmdW5jdGllIGVlbiByYXN0ZXJmdW5jdGlldGVtcGxhdGUgZGllIGRlIGZ1bmN0aWUgS2xldXJlbmthYXJ0IGJldmF0LiBab3JnIGRhdCBkZSB2b2xnb3JkZSB2YW4gZGUgZnVuY3RpZXZlcndlcmtpbmcgZGUgdm9sZ29yZGUgdmFuIGRlIGludm9lcnBhcmFtZXRlcnMgdm9sZ3QuIFpvIHphbCBiaWp2b29yYmVlbGQgZGUgSXRlbWZ1bmN0aWUgYWxzIGVlcnN0ZSB3b3JkZW4gdmVyd2Vya3QuPC9kaXY+XCIsXG5cdFx0cmFuZG9tTmFtZTogXCJXaWxsZWtldXJpZ1wiLFxuXHRcdHJhbmRvbVNuaXA6IFwiQ3Jlw6tlcnQgZWVuIHJhc3RlciBtZXQgd2lsbGVrZXVyaWdlIHBpeGVsd2FhcmRlbiBkaWUgemlqbiBhZmdlbGVpZCB2YW4gZWVuIHBzZXVkb3JhbmRvbS12ZXJkZWxpbmcuIFZlcnNjaGlsbGVuZGUgdmVyZGVsaW5nZW4gZW4gd2lsbGVrZXVyaWdlIG51bW1lcmdlbmVyYXRvcmVuIHdvcmRlbiBvbmRlcnN0ZXVuZC5cIixcblx0XHRyYW5kb21EZXNjOiBcIkRlIGZ1bmN0aWUgV2lsbGVrZXVyaWcgY3Jlw6tlcnQgZWVuIHJhc3RlciBtZXQgd2lsbGVrZXVyaWdlIHBpeGVsd2FhcmRlbiBkYXQga2FuIHdvcmRlbiBnZWJydWlrdCBpbiByYXN0ZXJmdW5jdGlldGVtcGxhdGVzIG9mIG1vemHDr2VrZGF0YXNldHMuPGRpdj48YnIvPkhvZXdlbCB2ZWVsIGZ1bmN0aWVzIHdlcmtlbiBvcCBlZW4gb2YgbWVlciBpbnZvZXJyYXN0ZXJzLCBoZWVmdCBkZSBmdW5jdGllIFdpbGxla2V1cmlnIGdlZW4gaW52b2VycmFzdGVyIG5vZGlnLiBEaXQgYmV0ZWtlbnQgZGF0IGhldCB6aWNoIG1lZXIgZ2VkcmFhZ3QgYWxzIGVlbiByYXN0ZXJkYXRhc2V0IGRhbiBhbHMgZWVuIGZ1bmN0aWUsIGR1cyBlciBtb2V0IGJpanpvbmRlcmUgem9yZyB3b3JkZW4gYmVzdGVlZCBhYW4gaGV0IHRvZXZvZWdlbiBhYW4gb2YgdmVyd2lqZGVyZW4gdmFuIGRlIGZ1bmN0aWVrZXRlbi48L2Rpdj5cIixcblx0XHRzaHJpbmtOYW1lOiBcIktyaW1wZW5cIixcblx0XHRzaHJpbmtTbmlwOiBcIktyaW1wdCBkZSBnZXNlbGVjdGVlcmRlIHpvbmVzIG1ldCBlZW4gYmVwYWFsZCBhYW50YWwgY2VsbGVuIGRvb3IgemUgdGUgdmVydmFuZ2VuIGRvb3IgZGUgd2FhcmRlIHZhbiBkZSBjZWwgZGllIGhldCBtZWVzdCB2b29ya29tdCBpbiBkZSBidXVydC5cIixcblx0XHRzaHJpbmtEZXNjOiBcIk1ldCBkZSBmdW5jdGllIEdsb2JhYWwga3JpbXBlbiB1IHJhc3RlcnMgdmVyYWxnZW1lbmVuIG9mIHZlcmVlbnZvdWRpZ2VuIGRvb3IgYmVwYWFsZGUgem9uZXMga2xlaW5lciB0ZSBtYWtlbi4gVSBrdW50IG9vayBkZSBob2V2ZWVsaGVpZCB2ZXJhbGdlbWVuaW5nIGRpZSB6YWwgb3B0cmVkZW4gY29udHJvbGVyZW4uPGRpdj48YnIvPkRlIHpvbmVzIGRpZSB1IHNlbGVjdGVlcnQgenVsbGVuIGtyaW1wZW4sIG9mIGtsZWluZXIgd29yZGVuLCBkb29yIGNlbGxlbiB1aXQgZGUgb21saWdnZW5kZSB6b25lcyB1aXQgdGUga2xhcHBlbi4gQ29uY2VwdHVlZWwga3VubmVuIGRlIGdlc2VsZWN0ZWVyZGUgem9uZXdhYXJkZW4gd29yZGVuIGdlemllbiBhbHMgdm9vcmdyb25kem9uZXMsIHRlcndpamwgZGUgYW5kZXJlIHdhYXJkZW4gYWNodGVyZ3JvbmR6b25lcyBibGlqdmVuLiBEZSBjZWxsZW4gaW4gZGUgdm9vcmdyb25kem9uZXMga3VubmVuIHdvcmRlbiB2ZXJ2YW5nZW4gZG9vciBjZWxsZW4gaW4gZGUgYWNodGVyZ3JvbmR6b25lcy4gRHVubmUgZWlsYW5kamVzIGJpbm5lbiBlZW4gem9uZSwgZGllIGFscyBnZWRlZWxkZSBncmVuemVuIG1ldCBkZSB6b25lIGt1bm5lbiB3b3JkZW4gYmVzY2hvdXdkLCBrdW5uZW4gb29rIHdvcmRlbiB2ZXJ2YW5nZW4uPGRpdj48YnIvPkRlIGhvZXZlZWxoZWlkIGdlbmVyYWxpc2F0aWUga2FuIHdvcmRlbiBnZXJlZ2VsZCBtZXQgZGUgcGFyYW1ldGVyIEFhbnRhbCBjZWxsZW4uIFN0YW5kYWFyZCBpcyBkZXplIHdhYXJkZSAxLCB3YXQgYmV0ZWtlbnQgZGF0IGRlIGdlc2VsZWN0ZWVyZGUgem9uZXMgenVsbGVuIGtyaW1wZW4gbWV0IGRlIGdyb290dGUgZGllIG92ZXJlZW5rb210IG1ldCBkZSBncm9vdHRlIHZhbiBlZW4gY2VsLiBPbSBkZSBtYXRlIHZhbiBnZW5lcmFsaXNhdGllIHRlIHZlcmhvZ2VuLCBrdW50IHUgZWVuIGdyb3RlcmUgd2FhcmRlIHZvb3IgZGV6ZSBwYXJhbWV0ZXIgb3BnZXZlbi4gQ29uY2VwdHVlZWwgaXMgZGl0IGFscyBoZXQgdWl0dm9lcmVuIHZhbiBkZSB0b29sIHpvIHZhYWsgYWxzIGhldCBvcGdlZ2V2ZW4gYWFudGFsLCB3YWFyYmlqIGRlIHJlc3VsdGF0ZW4gdmFuIGRlIHZvcmlnZSBydW4gZGUgaW5wdXQgemlqbiB2b29yIGRlIHZvbGdlbmRlIGl0ZXJhdGllLjwvZGl2PlwiLFxuXHRcdHRyZW5kVG9SR0JOYW1lOiBcIlRyZW5kIG5hYXIgUkdCXCIsXG5cdFx0dHJlbmRUb1JHQlNuaXA6IFwiQ29udmVydGVlcnQgZWVuIHRyZW5kcmFzdGVyIG5hYXIgZHJpZWJhbmRlbiAocm9vZCwgZ3JvZW4gZW4gYmxhdXcpIHJhc3Rlci5cIixcblx0XHR0cmVuZFRvUkdCRGVzYzogXCJEZSBmdW5jdGllIFRyZW5kIG5hYXIgUkdCIGNvbnZlcnRlZXJ0IGVlbiB0cmVuZHJhc3RlciBuYWFyIGVlbiBkcmllYmFuZGVuIChyb29kLCBncm9lbiBlbiBibGF1dykgcmFzdGVyLiBEZSB0cmVuZHJhc3RlciB3b3JkdCBnZWdlbmVyZWVyZCB2YW4gZGUgcmFzdGVyZnVuY3RpZSBUcmVuZCBnZW5lcmVyZW4gb2YgZGUgcmFzdGVyZnVuY3RpZSBDQ0RDLWFuYWx5c2UuPGRpdj48YnIvPkRlemUgZnVuY3RpZSBpcyBudXR0aWcgdm9vciBoZXQgdmlzdWFsaXNlcmVuIHZhbiBtb2RlbGNvZWZmaWNpw6tudGllZGF0YSB2YW4gZGUgZnVuY3RpZSBUcmVuZCBnZW5lcmVyZW4gb2YgZGUgZnVuY3RpZSBDQ0RDLWFuYWx5c2UuIEJlaWRlIGZ1bmN0aWVzIHNjaGF0dGVuIHRyZW5kcyBpbiB2ZXJhbmRlcmVuZGUgcGl4ZWx3YWFyZGVuIGluLCBtYWFyIGRlIHJlc3VsdGF0ZW4gdmFuIGRlIGZ1bmN0aWVzIHppam4gbW9laWxpamsgZGlyZWN0IHRlIGludGVycHJldGVyZW4uPGRpdj48YnIvPlpvYWxzIGJpaiB2ZWVsIHJhc3RlcmZ1bmN0aWVzIGlzIGhldCBtb2dlbGlqayBkYXQgdSBEeW5hbWljIFJhbmdlIEFkanVzdG1lbnQgKERSQSkgbW9ldCBnZWJydWlrZW4gb20gZGUgcmVzdWx0YXRlbiB2YW4gZGV6ZSBmdW5jdGllIGJldGVyIHdlZXIgdGUgZ2V2ZW4uPC9kaXY+XCIsXG5cdFx0bGFuZFRyZW5kck5hbWU6IFwiTGFuZFRyZW5kciBhbmFseXNlXCIsXG5cdFx0bGFuZFRyZW5kclNuaXA6IFwiRXZhbHVlZXJ0IHZlcmFuZGVyaW5nZW4gaW4gcGl4ZWx3YWFyZGVuIG5hIHZlcmxvb3AgdmFuIHRpamQgbWV0IGJlaHVscCB2YW4gZGUgTGFuZHNhdC1iYXNlZCBkZXRlY3RpZSB2YW4gdHJlbmRzIGluIHZlcnN0b3JpbmcgZW4gaGVyc3RlbCAoTGFuZFRyZW5kciktIG1ldGhvZGUgZW4gZ2VuZXJlZXJ0IGVlbiBtdWx0aWRpbWVuc2lvbmFhbCByYXN0ZXIgZGF0IGRlIG1vZGVscmVzdWx0YXRlbiBiZXZhdC5cIixcblx0XHRsYW5kVHJlbmRyRGVzYzogXCJEZXplIHJhc3RlcmZ1bmN0aWUga2FuIGFsbGVlbiB3b3JkZW4gZ2VicnVpa3QgYWxzIGludm9lciB2b29yIGRlIHJhc3RlcmZ1bmN0aWUgJ0RldGVjdCBDaGFuZ2UgVXNpbmcgQ2hhbmdlIEFuYWx5c2lzJy4gT20gZWVuIHJhc3RlcnVpdHZvZXIgdGUgZ2VuZXJlcmVuLCB2ZXJiaW5kdCB1IGRlIExhbmRUcmVuZHItYW5hbHlzZWZ1bmN0aWUgbWV0IGRlIGZ1bmN0aWUgRGV0ZWN0IENoYW5nZSBVc2luZyBDaGFuZ2UgQW5hbHlzaXMtZnVuY3RpZSBpbiBlZW4gcmFzdGVyZnVuY3RpZXRlbXBsYXRlIGVuIGdlYnJ1aWt0IHUgZGUgdGVtcGxhdGUgYWxzIGludm9lciBpbiBkZSBnZW9wcm9jZXNzaW5ndG9vbCBHZW5lcmF0ZSBSYXN0ZXIgRnJvbSBSYXN0ZXItZnVuY3RpZS4gSGV0IHJlc3VsdGFhdCBpcyBlZW4gcmFzdGVyIG1ldCBpbmZvcm1hdGllIG92ZXIgaGV0IHRpamRzdGlwIHdhYXJvcCBwaXhlbHdhYXJkZW4gemlqbiBnZXdpanppZ2QuPGRpdj48YnI+SGV0IGRvZWwgdmFuIGRlemUgcmFzdGVyZnVuY3RpZSBpcyBvbSB2ZXJhbmRlcmluZ2VuIGluIGVlbiBnZW9ic2VydmVlcmQgb2JqZWN0IHRlIGV4dHJhaGVyZW4sIGR1cyBkZSBpZGVhbGUgbXVsdGlkaW1lbnNpb25hbGUgaW52b2VyIG1vZXQgZWVuIGNvbnNpc3RlbnRlIG9ic2VydmF0aWUgZG9vciBkZSB0aWpkIGhlZW4gdmFzdGxlZ2dlbiBlbiBtYWcgZ2VlbiBhdG1vc2ZlcmlzY2hlIG9mIHNlbnNvcmludGVyZmVyZW50aWUsIHdvbGtlbiBvZiB3b2xrZW5zY2hhZHV3IGJldmF0dGVuLiBEZSBiZXN0ZSBtZXRob2RlIGlzIG9tIGdlZ2V2ZW5zIHRlIGdlYnJ1aWtlbiBkaWUgemlqbiBnZW5vcm1hbGlzZWVyZCBlbiBrdW5uZW4gd29yZGVuIGdlbWFza2VlcmQgbWV0IGVlbiBRQS1iYW5kLCBiaWp2b29yYmVlbGQgTGFuZHNhdCBDb2xsZWN0aW9uIDEgU3VyZmFjZSBSZWZsZWN0YW5jZS1wcm9kdWN0ZW4gbWV0IGVlbiB3b2xrZW5tYXNrZXIuPGRpdj48YnI+RGUgZnVuY3RpZSB2b2VydCBlZW4gYW5hbHlzZSB1aXQgb3Agw6nDqW4gYWZiZWVsZGluZyBwZXIgamFhciBlbiBoZXQgYWFudGFsIGphYXJsaWprc2Ugc3R1a2tlbiBtb2V0IGdlbGlqayB6aWpuIGFhbiBvZiBncm90ZXIgemlqbiBkYW4gZGUgd2FhcmRlIGdlc3BlY2lmaWNlZXJkIGluIGRlIHBhcmFtZXRlZCA8c3Ryb25nPk1pbmltYWFsIGFhbnRhbCBvYnNlcnZhdGllczwvc3Ryb25nPi4gSGV0IHdvcmR0IGFhbmJldm9sZW4gb20gdm9vciBtaW5pbWFhbCB6ZXMgamFhciBhYW4gZGF0YSB0ZSBoZWJiZW4uPGRpdj48YnI+QWxzIHUgbWFhbmRlbGlqa3NlLCB3ZWtlbGlqa3NlIG9mIGRhZ2VsaWprc2UgZGF0YSBoZWJ0LCBpcyBoZXQgcmFhZHphYW0gb20gdmVyc2NoaWxsZW5kZSBhZmJlZWxkaW5nZW4gdmFuIGVsayBqYWFyIHRlIHNlbGVjdGVyZW4gKGJpaiB2b29ya2V1ciB2YW4gaGV0emVsZmRlIHNlaXpvZW4pLCB3b2xrZW4gZW4gd29sa2Vuc2NoYWR1dyB0ZSB2ZXJ3aWpkZXJlbiBlbiBkZSBhZmJlZWxkaW5nZW4gdGUgY29tYmluZXJlbiBvbSBlZW4gZW5rZWxlIGFmYmVlbGRpbmcgdGUgZ2VuZXJlcmVuIGRpZSBkZSB3YWFybmVtaW5nIGdvZWQgdmFzdGxlZ3QuIEFscyBtYWFuZGVsaWprc2UsIHdla2VsaWprc2Ugb2YgZGFnZWxpamtzZSBnZWdldmVucyB3b3JkZW4gdmVyc3RyZWt0IGFscyBoZXQgbXVsdGlkaW1lbnNpb25hbGUgaW52b2VycmFzdGVyLCBpZGVudGlmaWNlZXJ0IGRlIGZ1bmN0aWUgw6nDqW4gc2VnbWVudCB2b29yIGFuYWx5c2Ugb3AgYmFzaXMgdmFuIGRlIGRhdHVtIGRpZSBoZXQgZGljaHRzdCBiaWogZGUgZGF0dW0gaW4gZGUgcGFyYW1ldGVyIDxzdHJvbmc+U25hcHBpbmdkYXR1bTwvc3Ryb25nPi48ZGl2Pjxicj5FZW4gb2JqZWN0IGluIGVlbiBsYW5kc2NoYXAgaGVlZnQgdmFhayB0aWpkIG5vZGlnIG9tIHRlIGhlcnN0ZWxsZW4gdmFuIGVlbiBuaWV0LXBlcm1hbmVudGUgdmVyYW5kZXJpbmcsIHpvYWxzIGVlbiBib3NicmFuZCBvZiBlZW4gaW5zZWN0ZW5wbGFhZy4gU3RlbCBkZSBwYXJhbWV0ZXIgSGVyc3RlbGRyZW1wZWwgaW4gb20gZGUgaGVyc3RlbHNuZWxoZWlkIHRlIHJlZ2VsZW4gZGllIGRvb3IgaGV0IG1vZGVsIHdvcmR0IGhlcmtlbmQuIEVlbiBhZnpvbmRlcmxpamsgc2VnbWVudCBrYW4gZ2VlbiBoZXJzdGVsc25lbGhlaWQgaGViYmVuIGRpZSBzbmVsbGVyIGlzIGRhbiAxL2hlcnN0ZWxkcmVtcGVsLjxkaXY+PGJyPkhldCBoZXJzdGVsIHZhbiBlZW4gdmVyYW5kZXJpbmcgaW4gbGFuZHNjaGFwIGthbiBpbiBwb3NpdGlldmUgb2YgbmVnYXRpZXZlIHJpY2h0aW5nIHBsYWF0c3ZpbmRlbi4gV2FubmVlciBlZW4gbGFuZHNjaGFwIGJpanZvb3JiZWVsZCBib3N2ZXJsaWVzIHZlcnRvb250LCBsYWF0IGVlbiB0aWpkcmVla3MgdmFuIHZlZ2V0YXRpZS1pbmRleHdhYXJkZW4gZWVuIGRhbGluZyB2YW4gZGUgaW5kZXh3YWFyZGVuIHppZW4sIGVuIGhldCBoZXJzdGVsIHRvb250IGVlbiBnZWxlaWRlbGlqa2UgdG9lbmFtZSB2YW4gZGUgdmVnZXRhdGllLWluZGV4d2FhcmRlbiBvZiBlZW4gcG9zaXRpZXZlIGhlcnN0ZWx0cmVuZC4gU3BlY2lmaWNlZXIgZGUgcmljaHRpbmcgdmFuIGRlIGhlcnN0ZWx0cmVuZCBtZXQgZGUgcGFyYW1ldGVyIDxzdHJvbmc+SGVyc3RlbCBoZWVmdCBlZW4gc3RpamdlbmRlIHRyZW5kPC9zdHJvbmc+LlwiLFxuXHRcdGFnZ3JlZ2F0ZU11bHRpZGltZW5zaW9uYWxOYW1lOiBcIk11bHRpZGltZW5zaW9uYWFsIGFnZ3JlZ2VyZW5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsU25pcDogXCJDb21iaW5lZXJ0IGJlc3RhYW5kZSBtdWx0aWRpbWVuc2lvbmFsZSBnZWdldmVucyB2YW4gcmFzdGVydmFyaWFiZWxlbiBsYW5ncyBlZW4gZGltZW5zaWUuXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbERlc2M6IFwiRGUgZnVuY3RpZSBNdWx0aWRpbWVuc2lvbmFhbCBhZ2dyZWdlcmVuIGNyZcOrZXJ0IGVlbiBtdWx0aWRpbWVuc2lvbmFsZSByYXN0ZXJsYWFnIGRvb3IgYmVzdGFhbmRlIG11bHRpZGltZW5zaW9uYWxlIHJhc3RlcnZhcmlhYmVsZSBnZWdldmVucyBsYW5ncyBlZW4gYWZtZXRpbmcgdGUgY29tYmluZXJlbi48ZGl2Pjxicj5HZWJydWlrIGRlwqA8c3Ryb25nPkRpbWVuc2llZGVmaW5pdGllPC9zdHJvbmc+wqBwYXJhbWV0ZXIgb20gZWVyc3QgZGUgaW52b2VyZ2VnZXZlbnMgdGUgZmlsdGVyZW4gZGllIHUgd2Vuc3QgdGUgYWdncmVnZXJlbi4gQWxzIHUgYmlqdm9vcmJlZWxkIDMwIGphYXIgYWFuIG1hYW5kZWxpamtzZSBnZWdldmVucyBoZWJ0LCBtYWFyIHUgd2lsdCBhbGxlZW4gZWVuIGdlYWdncmVnZWVyZGUgbGFhZyBtYWtlbiB2b29yIGRlIGVlcnN0ZSAxNSBqYWFyLCBkYW4ga3VudCB1IGRlIHBhcmFtZXRlcsKgPHN0cm9uZz5EaW1lbnNpZWRlZmluaXRpZTwvc3Ryb25nPiBnZWJydWlrZW4gb20gZGUgamFyZW4gb3AgdGUgZ2V2ZW4gZGllIHUgaW4gZGUgYW5hbHlzZSB3aWx0IG9wbmVtZW4uIEV4dHJhY3RpZWdlZ2V2ZW5zPGRpdj48YnI+PHVsPjxsaT52b29yIGRlIG1hYW5kIGphbnVhcmkgb3ZlciBkZSBwZXJpb2RlIDEwIGphYXIuIEtpZXPCoDxzdHJvbmc+T3Agd2FhcmRlbjwvc3Ryb25nPiwgc3RlbMKgPHN0cm9uZz5EaW1lbnNpZTwvc3Ryb25nPiBpbiBvcCA8c3Ryb25nPlN0ZFRpbWU8L3N0cm9uZz4gZW4gc3RlbMKgPHN0cm9uZz5XYWFyZGVuPC9zdHJvbmc+IGluIG9wIDxzdHJvbmc+amFudWFyaTwvc3Ryb25nPi48L2xpPjxsaT4gU3BsaXRzIHpvdXRnZWdldmVucyBvdmVyIGVlbiBkaWVwdGUgdmFuIDAgdG90IDE1MCBtZXRlci4gS2llc8KgPHN0cm9uZz5PcCBiZXJlaWs8L3N0cm9uZz4sIHN0ZWzCoDxzdHJvbmc+RGltZW5zaWU8L3N0cm9uZz4gaW4gb3AgPHN0cm9uZz5TdGRaPC9zdHJvbmc+IGVuIHN0ZWzCoDxzdHJvbmc+TWluaW11bXdhYXJkZTwvc3Ryb25nPiBpbiBvcCA8c3Ryb25nPi0xNTA8L3N0cm9uZz4gZW4gPHN0cm9uZz5NYXhpbXVtd2FhcmRlPC9zdHJvbmc+wqBvcMKgPHN0cm9uZz4wLjwvc3Ryb25nPi48L2xpPjxsaT5Wb2VyIHpvdXRnZWdldmVucyB1aXQgdm9vciBkZSBlZXJzdGUgMTAgZGFnZW4gdmFuIGVsa2UgamFudWFyaSBvdmVyIGVlbiBwZXJpb2RlIHZhbiAxMCBqYWFyLiBLaWVzwqA8c3Ryb25nPk9wIGl0ZXJhdGllPC9zdHJvbmc+IGVuIHN0ZWzCoDxzdHJvbmc+RGltZW5zaWU8L3N0cm9uZz7CoGluIG9wwqA8c3Ryb25nPlN0ZFRpbWU8L3N0cm9uZz4sIHN0ZWzCoDxzdHJvbmc+U3RhcnQgdmFuIGVlcnN0ZSBpdGVyYXRpZTwvc3Ryb25nPsKgZW7CoDxzdHJvbmc+RWluZCB2YW4gZGUgZWVyc3RlIGl0ZXJhdGllPC9zdHJvbmc+wqBpbiBvcCBoZXQgb3ZlcmVlbmtvbWVuZGUgYmVnaW4gZW4gZWluZGUgdmFuIGRlIGl0ZXJhdGllcGVyaW9kZSwgc3RlbMKgPHN0cm9uZz5TdGFwPC9zdHJvbmc+IGluIG9wwqA8c3Ryb25nPjE8L3N0cm9uZz4gZW4gc3RlbMKgPHN0cm9uZz5FZW5oZWlkPC9zdHJvbmc+wqBpbm9wwqA8c3Ryb25nPkphcmVuPC9zdHJvbmc+LjwvbGk+PC91bD48ZGl2Pjxicj5HZWJydWlrIGRlIHBhcmFtZXRlcnPCoDxzdHJvbmc+QWdncmVnYXRpZWRlZmluaXRpZTwvc3Ryb25nPiBvbSBkZSBhZm1ldGluZyB0ZSBraWV6ZW4gb20gZGUgYWZtZXRpbmcgdGUga2llemVuIGVuIGhldCBhZ2dyZWdhdGllaW50ZXJ2YWwgbWV0IGJlaHVscCB2YW4gZWVuIHRyZWZ3b29yZCwgZWVuIHdhYXJkZSBvZiBlZW4gcmVla3Mgd2FhcmRlbi4gQWxzIHUgYmlqdm9vcmJlZWxkIDMwIGphYXIgYWFuIGdlZ2V2ZW5zIG92ZXIgZGUgemVlb3BwZXJ2bGFrdGV0ZW1wZXJhdHV1ciBoZWJ0LCBkYWdlbGlqa3MgdmVyemFtZWxkIGVuIG9wIGVsa2UgNSBtZXRlciBkaWVwdGUgdG90IDEwMCBtZXRlciwga3VudCB1IGRlIHZlcnNjaGlsbGVuZGUgaW50ZXJ2YWxvcHRpZXMgZ2VicnVpa2VuIHZvb3IgZGUgdm9sZ2VuZGUgc2NlbmFyaW8nczo8ZGl2Pjxicj48dWw+PGxpPkRhZ2VsaWprc2UgdGVtcGVyYXR1dXJnZWdldmVucyBzYW1lbnZvZWdlbiB0b3QgbWFhbmRlbGlqa3NlIGdlZ2V2ZW5zLCB3YWFyYmlqIGhldCByZXN1bHRhYXQgZWVuIG11bHRpZGltZW5zaW9uYWFsIHJhc3RlciBpcyBtZXQgMTIgdGlqZHNjaGlqdmVuLCBlbiBlbGtlIHNjaGlqZiBpcyBoZXQgdG90YWFsIHZhbiBlbGtlIG1hYW5kIG92ZXIgYWxsZSBqYXJlbiBoZWVuLiBLaWVzwqA8c3Ryb25nPkludGVydmFsIHRyZWZ3b29yZDwvc3Ryb25nPsKgZW4gc3RlbCBoZXQgdHJlZndvb3JkIGluIG9wwqA8c3Ryb25nPk1hYW5kZWxpamtzIHRlcnVna2VyZW5kPC9zdHJvbmc+LjwvbGk+PGxpPiBBZ2dlcmVlciBkYWdlbGlqa3NlIHRlbXBlcmF0dXVyZ2VnZXZlbnMgaW4gbWFhbmRlbGlqa3NlIGdlZ2V2ZW5zLCB3YWFyYmlqIGhldCByZXN1bHRhYXQgZWVuIG11bHRpZGltZW5zaW9uYWFsIHJhc3RlciBpcyBtZXQgMzYwIHN0dWtrZW4sIG9mIDEyIHRpamRzZGVsZW4gcGVyIGphYXIgKDMwIGphYXIgeCAxMiBtYWFuZGVuID0gMzYwIHN0dWtrZW4pLiBLaWVzwqA8c3Ryb25nPkludGVydmFsIHRyZWZ3b29yZDwvc3Ryb25nPsKgZW4gc3RlbCBoZXQgdHJlZndvb3JkIGluIG9wwqA8c3Ryb25nPk1hYW5kZWxpamtzPC9zdHJvbmc+LjwvbGk+PGxpPkFnZ3JlZ2VlciBtYWFuZGVsaWprc2UgdGVtcGVyYXR1dXJnZWdldmVucyBpbiBpbnRlcnZhbGxlbiB2YW4gNCBtYWFuZGVuLiBLaWVzwqA8c3Ryb25nPkludGVydmFsd2FhcmRlPC9zdHJvbmc+LCBzdGVswqA8c3Ryb25nPldhYXJkZS1pbnRlcnZhbDwvc3Ryb25nPsKgaW4gb3AgNCwgZW4gc3RlbMKgPHN0cm9uZz5FZW5oZWlkPC9zdHJvbmc+wqBpbiBvcMKgPHN0cm9uZz5NYWFuZGVuPC9zdHJvbmc+LjwvbGk+PGxpPkFnZ3JlZ2VlciB0ZW1wZXJhdHV1cmRhdGEgdmFuIDAgdG90IDI1IG1ldGVyLCB2ZXJ2b2xnZW5zIHZhbiAyNSB0b3QgNTAgbWV0ZXIsIHZlcnZvbGdlbnMgdmFuIDUwIHRvdCAxMDAgbWV0ZXIuIEtpZXPCoDxzdHJvbmc+SW50ZXJ2YWxiZXJlaWtlbjwvc3Ryb25nPsKgZW4gc3BlY2lmaWNlZXIgbWluaW11bS0gZW4gbWF4aW1hbGUgZGllcHRlcyBhbHPCoDxzdHJvbmc+MCAyNTsgMjUgNTA7IDUwIDEwMDwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0bWVyZ2VSYXN0ZXJzTmFtZTogXCJSYXN0ZXJzIHNhbWVudm9lZ2VuXCIsXG5cdFx0bWVyZ2VSYXN0ZXJzU25pcDogXCJDb21iaW5lZXJ0IHJ1aW10ZWxpamsgbWVlcmRlcmUgcmFzdGVyZ2VnZXZlbnNzZXRzIG9mIG92ZXIgdmFyaWFiZWxlbiBlbiBkaW1lbnNpZXMgaGVlbi5cIixcblx0XHRtZXJnZVJhc3RlcnNEZXNjOiBcIkRlemUgZnVuY3RpZSBtYWFrdCBlZW4gc2FtZW5nZXZvZWdkIHJhc3RlciB1aXQgZWVuIGxpanN0IG1ldCByYXN0ZXJzLiBBbHMgdSBiaWp2b29yYmVlbGQgZWVuIG1vemHDr2VrZ2VnZXZlbnNzZXQgaGVidCBkaWUgMzAgamFhciBhYW4gbWFhbmRlbGlqa3NlIG5lZXJzbGFnZ2VnZXZlbnMgYmV2YXQgZW4gZWVuIGFuZGVyZSBnZWdldmVuc3NldCBtZXQgMTAgamFhciBhYW4gbWFhbmRlbGlqa3NlIHRlbXBlcmF0dXVyZ2VnZXZlbnMsIGt1bnQgdSBkZXplIGNvbWJpbmVyZW4gdG90IGVlbiBtdWx0aWRpbWVuc2lvbmFhbCByYXN0ZXIgbWV0IGJlaWRlIHZhcmlhYmVsZW4uIDxkaXY+PGJyPkFscyBkZSBtdWx0aWRpbWVuc2lvbmFsZSBpbmdldm9lcmRlIHJhc3RlcnMgdmVyc2NoaWxsZW5kZSB2YXJpYWJlbGVuIGJldmF0dGVuLCB6YWwgaGV0IG11bHRpZGltZW5zaW9uYWxlIHVpdHZvZXJyYXN0ZXIgYWxsZSB2YXJpYWJlbGVuIGJldmF0dGVuLiA8ZGl2Pjxicj5BbHMgZGUgbXVsdGlkaW1lbnNpb25hbGUgaW5nZXZvZXJkZSByYXN0ZXJzIHZlcnNjaGlsbGVuZGUgZGltZW5zaWVzIG9mIGRpbWVuc2lld2FhcmRlbiBiZXZhdHRlbiwgemFsIGhldCBtdWx0aWRpbWVuc2lvbmFsZSBvdXRwdXRyYXN0ZXIgYWxsZSBkaW1lbnNpZXMgZW4gZGltZW5zaWV3YWFyZGVuIGJldmF0dGVuLiA8ZGl2Pjxicj5BbHMgZGUgbXVsdGlkaW1lbnNpb25hbGUgaW5nZXZvZXJkZSByYXN0ZXJzIGRlemVsZmRlIGFmbWV0aW5nZW4gZW4gdmFyaWFiZWxlbiBiZXZhdHRlbiwgbWFhciB2ZXJzY2hpbGxlbmRlIHJ1aW10ZWxpamtlIGV4dGVuc2llcywgemFsIGhldCBtdWx0aWRpbWVuc2lvbmFsZSBvdXRwdXRyYXN0ZXIgZGUgdmFyaWFiZWxlbiBlbiBkaW1lbnNpZXMgb3ZlciBkZSBzYW1lbmdldm9lZ2RlIHJ1aW10ZWxpamtlIGV4dGVuc2llcyBiZXZhdHRlbi48ZGl2Pjxicj5EZXplIGZ1bmN0aWUga2FuIG9vayB3b3JkZW4gZ2VicnVpa3QgYWxzIHUgbWVlcmRlcmUgcmFzdGVycyBoZWJ0IGRpZSB1IGFscyDDqcOpbiBpdGVtLCB6b2FscyBoZXQgYmVyZWtlbmVuIHZhbiBkZXplbGZkZSBzdGF0aXN0aWVrZW4gdm9vciBpZWRlcmVlbiwgb2YgYmlqIGtsZXVyYmFsYW5zLCB6b2RhdCB1IG5pZXQgZWxrZSBhZmJlZWxkaW5nIGFmem9uZGVybGlqayBob2VmdCB0ZSBiYWxhbmNlcmVuLiBEaXQgaXMgaGFuZGlnIHdhbm5lZXIgdSB3ZXJrdCBtZXQgYWZiZWVsZGluZ2VuIGRpZSB6aWpuIG9wZ2VzbGFnZW4gYWxzIGFmem9uZGVybGlqa2UgdGVnZWxzIHZhbndlZ2UgYmVwZXJraW5nZW4gaW4gZGUgYmVzdGFuZHNncm9vdHRlOyBvcCBkZXplIG1hbmllciB3b3JkZW4gZGUgdGVnZWxzIGJlaGFuZGVsZCBhbHMgb25kZXJkZWVsIHZhbiBkZXplbGZkZSBhZmJlZWxkaW5nLlwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5OYW1lOiBcIlNjaG9uZSBncmVuc1wiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5TbmlwOiBcIk1hYWt0IGRlIGdyZW5zIHR1c3NlbiBkZSB6b25lcyBnbGFkLlwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5EZXNjOiBcIjxwPkRlIGZ1bmN0aWUgdmVyYWxnZW1lZW50IG9mIHZlcmVlbnZvdWRpZ3QgZGUgcmFzdGVycyBkb29yIGRlIGdyZW56ZW4gdHVzc2VuIGRlIHpvbmVzIGdsYWQgdGUgc3RyaWprZW4uIERlIGZ1bmN0aWUgYmllZHQgbW9nZWxpamtoZWRlbiBvbSB0ZSBjb250cm9sZXJlbiBob2UgZGUgY2VsbGVuIHZhbiBkZSB6b25lcyBpbiBkZSBpbnZvZXIgZGUgYWZ2bGFra2luZyBiZcOvbnZsb2VkZW4gZW4gZGUgaG9ldmVlbGhlaWQgYWZ2bGFra2luZyBkaWUgemFsIHdvcmRlbiB0b2VnZXBhc3QuIEVsa2UgaW52b2VyY2VsIHdvcmR0IGdlw6t2YWx1ZWVyZCBtZXQgYmVodWxwIHZhbiB6aWpuIGFjaHQgZGlyZWN0ZSBidXJlbi48L3A+PHA+SGV0IGFmdmxha2tpbmdzcHJvY2VzIHNvcnRlZXJ0IGRlIGJ1dXJjZWxsZW4gZWVyc3Qgb3AgZWVuIGJlcGFhbGRlIHByaW9yaXRlaXQuIERlIHByaW9yaXRlaXQgYmVwYWFsdCB3ZWxrZSB6b25lIHZhbiBkZSBhYW5ncmVuemVuZGUgY2VsbGVuIGRlIHdhYXJkZSB2YW4gZGUgdmVyd2Vya2luZ3NjZWwgaW4gZGUgdWl0Z2FuZyBrYW4gdmVydmFuZ2VuLjwvcD48cD5EZSBwcmlvcml0ZWl0IGthbiBnZWJhc2VlcmQgemlqbiBvcCBkZSB3YWFyZGUgdmFuIGRlIHpvbmVzIG9mIGRlIGdyb290dGUgdmFuIGRlIHpvbmVzLiBEZSBwYXJhbWV0ZXIgPHN0cm9uZz5Tb3J0ZWVydHlwZTwvc3Ryb25nPiBiZXBhYWx0IGhldCB0ZSBnZWJydWlrZW4gc29ydGVlcnR5cGUuIDwvcD48cD5EZSBzdGFuZGFhcmRpbnN0ZWxsaW5nIDxzdHJvbmc+TmlldCBzb3J0ZXJlbjwvc3Ryb25nPiBiZW9vcmRlZWx0IGRlIHByaW9yaXRlaXQgb3AgYmFzaXMgdmFuIGRlIHdhYXJkZSB2YW4gZGUgem9uZXMuIENlbGxlbiB1aXQgem9uZXMgbWV0IGdyb3RlcmUgd2FhcmRlbiBoZWJiZW4gZWVuIGhvZ2VyZSBwcmlvcml0ZWl0IG9tIHVpdCB0ZSBicmVpZGVuIG5hYXIgem9uZXMgbWV0IGtsZWluZXJlIHdhYXJkZW4uPC9wPjxwPkRlIGdyb290dGUsIG9mIGRlIHRvdGFsZSBvcHBlcnZsYWt0ZSwgdmFuIGRlIHpvbmVzIGthbiB3b3JkZW4gZ2VicnVpa3Qgb20gZGUgcHJpb3JpdGVpdCB0ZSBzb3J0ZXJlbi4gTWV0IGRlIGluc3RlbGxpbmcgPHN0cm9uZz5BZmxvcGVuZDwvc3Ryb25nPiB3b3JkZW4gZGUgem9uZXMgaW4gYWZsb3BlbmRlIHZvbGdvcmRlIG9wIGdyb290dGUgZ2Vzb3J0ZWVyZC4gRGUgem9uZXMgbWV0IGdyb3RlcmUgdG90YWxlIG9wcGVydmxha3RlbiB6dWxsZW4gZGUgcHJpb3JpdGVpdCBoZWJiZW4gb20gdWl0IHRlIGJyZWlkZW4gbmFhciB6b25lcyBtZXQga2xlaW5lcmUgb3BwZXJ2bGFrdGVuLiBNZXQgZGUgaW5zdGVsbGluZyA8c3Ryb25nPk9wbG9wZW5kPC9zdHJvbmc+IGlzIGhldCB0ZWdlbm92ZXJnZXN0ZWxkZSBoZXQgZ2V2YWw6IHpvbmVzIG1ldCBrbGVpbmVyZSB0b3RhbGUgb3BwZXJ2bGFrdGVuIHp1bGxlbiBkZSBwcmlvcml0ZWl0IGhlYmJlbiBvbSB1aXQgdGUgYnJlaWRlbiBuYWFyIHpvbmVzIG1ldCBncm90ZXJlIHRvdGFsZSBvcHBlcnZsYWt0ZW4uPC9wPjxwPkRlIGhvZXZlZWxoZWlkIGFmdmxha2tpbmcgd29yZHQgZ2VyZWdlbGQgZG9vciBkZSBwYXJhbWV0ZXIgPHN0cm9uZz5VaXR6ZXR0ZW4gZW4ga3JpbXBlbiB0d2VlIGtlZXIgdWl0dm9lcmVuPC9zdHJvbmc+IGRpZSBoZXQgYWFudGFsIGtlcmVuIGJlcGFhbHQgZGF0IGhldCB1aXR6ZXR0aW5ncy0gZW4ga3JpbXBwcm9jZXMgd29yZHQgdWl0Z2V2b2VyZC48L3A+PHA+TWV0IGRlIG9uYWFuZ2V2aW5rdGUgaW5zdGVsbGluZyB3b3JkdCBoZXQgdWl0emV0LSBlbiBrcmltcHByb2NlcyDDqcOpbiBrZWVyIHVpdGdldm9lcmQuIE1ldCBkZSBhYW5nZXZpbmt0ZSBpbnN0ZWxsaW5nIHdvcmR0IGhldCB1aXR6ZXQtIGVuIGtyaW1wcHJvY2VzIHR3ZWUga2VlciB1aXRnZXZvZXJkLCB3YWFyZG9vciBkZSB6b25lZ3JlbnplbiBleHRyYSB3b3JkZW4gZ2xhZGdlc3RyZWtlbi48L3A+PHA+QWxzIGRlIHdhYXJkZW4gdmFuIGFsbGUgYWNodCBidXVyY2VsbGVuIGdlbGlqayB6aWpuIGFhbiBkaWUgdmFuIGRlIHZlcndlcmtpbmdzY2VsLCBiZWhvdWR0IGRlIHVpdGdhbmdzY2VsIGRlIHdhYXJkZSB2YW4gZGUgaW52b2VyY2VsLjwvcD5cIixcblx0XHRwcmVkaWN0VXNpbmdSZWdyZXNzaW9uTmFtZTogXCJWb29yc3BlbGxlbiBtZXQgcmVncmVzc2llXCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvblNuaXA6IFwiQmVyZWtlbnQgZWVuIHZvb3JzcGVsZCByYXN0ZXIgb3AgYmFzaXMgdmFuIGRlIGludm9lciB2YW4gcmFzdGVyZ2VnZXZlbnMgZW4gZWVuIHJlZ3Jlc3NpZW1vZGVsLiBIZXQgcmVncmVzc2llbW9kZWwgaXMgZGUgdWl0dm9lciB2YW4gaGV0IHJhc3RlciBnZW9wcm9jZXNzaW5nIHRvb2wgdmFuIGhldDxzdHJvbmc+cmVncmVzc2llbW9kZWwgVHJhaW4gUmFuZG9tIFRyZWVzPC9zdHJvbmc+LlwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25EZXNjOiBcIjxwPkhldCByZWdyZXNzaWVtb2RlbCBpcyBnZWRlZmluaWVlcmQgaW4gYWFuIEVzcmktcmVncmVzc2llZGVmaW5pdGllYmVzdGFuZCAoLmVjZCkuIEhldCBiZXZhdCBhbGxlIGluZm9ybWF0aWUgdm9vciBlZW4gc2VwY2lmaWVrZSBnZWdldmVuc3NldCBvZiBlZW4gc2V0IGdlZ2V2ZW5zc2V0cywgZW4gaGV0IHJlZ3Jlc3NpZW1vZGVsLCBlbiB3b3JkdCBnZWdlbmVyZWVyZCBkb29yIGhldCByYXN0ZXIgZ2VvcHJvY2Vzc2luZyB0b29sIHZhbiBoZXQgPHN0cm9uZz5yZWdyZXNzaWVtb2RlbCBUcmFpbiBSYW5kb20gVHJlZXM8L3N0cm9uZz4uIDwvcD48cD5EZSBpbnB1dCBrYW4gZWVuIGVua2VsZSBiYW5kLCBlZW4gbWVlcnZvdWRpZ2UgYmFuZCBvZiBlZW4gbXVsdGlkaW1lbnNpb25hYWwgcmFzdGVyIHppam4sIG9mIGVlbiBsaWpzdCB2YW4gZGV6ZSB0eXBlcy4gRGUgdHlwZXMgaW5wdXRyYXN0ZXJzIG1vZXRlbiB2YW4gaGV0emVsZmRlIHR5cGUgdmFuIGhldCByYXN0ZXIgZGF0IGlzIGFhbmdlbGVlcmQgZG9vciBoZXQgcmVncmVzc2llbW9kZWwuPC9wPjx1bD48bGk+V2FubmVlciBkZSBpbnB1dCBlZW4gbWVlcnZvdWRpZ2UgYmFuZCBoZWVmdCwgd29yZHQgZWxrZSBiYW5kIGJlaGFuZGVsZCBhbHMgZWVuIHZhcmlhYmVsZSB2YW4gZWVuIHZvb3JzcGVsbGVyLiBEZSBiYW5kZW4gbW9ldGVuIGluIGRlemVsZmRlIHZvbGdvcmRlIGFscyBkZSBtZWVydm91ZGlnZSBiYW5kLWlucHV0IHppam4gdm9vciBkZSB0cmFpbmluZ3Rvb2wgdmFuIGhldCByZWdyZXNzaWVtb2RlbC48L2xpPjxsaT5XYW5uZWVyIGRlIGlucHV0IGVlbiBtdWx0aWRpbWVuc2lvbmFhbCByYXN0ZXIgaXMsIHdvcmR0IGVsa2UgdmFyaWFiZWxlIGJlaGFuZGVsZCBhbHMgZGUgdmFyaWFiZWxlIHZhbiBlZW4gdm9vcnNwZWxsZXIgZW4gbW9ldCBkZSB2YXJpYWJlbGUgZWVuIGVua2VsZSBiYW5kIHppam4gZW4gZWVuIHRpamRkaW1lbnNpZSBoZWJiZW4uIERlIHZvbGdvcmRlIGVuIG5hbWVuIHZhbiBkZSB2YXJpYWJlbGVuIG1vZXRlbiBkZXplbGZkZSB6aWpuIGFscyBkZSBpbnB1dCB3YW5uZWVyIGhldCByZWdyZXNzaWVtb2RlbCB3ZXJkIGdldHJhaW5kLiBEZSBvdXRwdXQgaXMgZWVuIG11bHRpZGltZW5zaW9uYWFsIHJhc3Rlci48L2xpPjxsaT5EZSBpbnB1dCBrYW4gZWVuIGxpanN0IHZhbiBpdGVtcyB6aWpuLiBIZXQgYWFudGFsIGl0ZW1zIGVuIGRlIHZvbGdvcmRlIHZhbiBkZSBpdGVtcyBtb2V0ZW4gZGV6ZWxmZGUgemlqbiBhbHMgZGUgaW5wdXQgd2FubmVlciBoZXQgcmVncmVzc2llbW9kZWwgd2VyZCBnZXRyYWluZC48L2xpPjwvdWw+XCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdTdGF0aXN0aWNzTmFtZTogXCJEaW1lbnNpb25hbGUgYmV3ZWdlbmRlIHN0YXRpc3RpZWtlblwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc1NuaXA6IFwiQmVyZWtlbnQgc3RhdGlzdGlla2VuIG92ZXIgZWVuIGJld2VnZW5kIHZlbnN0ZXIgb3AgbXVsdGlkaW1lbnNpb25hbGUgZ2VnZXZlbnMgbGFuZ3MgZWVuIGdlc3BlY2lmaWNlZXJkZSBkaW1lbnNpZS5cIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NEZXNjOiBcIjxwPkRlIGZ1bmN0aWUgRGltZW5zaW9uYWwgTW92aW5nIFN0YXRpc3RpY3MgYmVyZWtlbnQgZGl2ZXJzZSBzdGF0aXN0aWVrZW4gYmlubmVuIGVlbiB2b29yYWYgZ2VkZWZpbmllZXJkIHZlbnN0ZXIgdm9vciBhbGxlIGRpbWVuc2lld2FhcmRlbiBiaW5uZW4gZWVuIGRpbWVuc2llLiBEZXplIGZ1bmN0aWUgbmVlbXQgZWVuIG11bHRpZGltZW5zaW9uYWxlIHJhc3RlcmxhYWcgYWxzIGludm9lciBlbiBtYWFrdCBlZW4gbXVsdGlkaW1lbnNpb25hbGUgcmFzdGVybGFhZywgZGllIGRlemVsZmRlIGRpbWVuc2lvbmFsZSBncm9vdHRlIGhlZWZ0IGFscyBkZSBpbnZvZXJsYWFnLCBhbHMgdWl0dm9lci48L3A+PHA+VSBrdW50IGVlbiBkaW1lbnNpZSBvcGdldmVuIHdhYXJ2b29yIGRpbWVuc2lld2FhcmRlbiB3b3JkZW4gb3ZlcndvZ2VuIHRpamRlbnMgYmVyZWtlbmluZy4gSGV0IGJlcmVrZW50IHN0YW5kYWFyZCBsYW5ncyBkZSBlZXJzdGUgbmlldC1ydWltdGVsaWprZSBkaW1lbnNpZS4gVSBrdW50IG9vayBlZW4gdmVuc3Rlcmdyb290dGUgc3BlY2lmaWNlcmVuIGRvb3IgZGUgcGFyYW1ldGVycyB2b29yIGhldCBCYWNrd2FyZC12ZW5zdGVyIGVuIGhldCBGb3J3YXJkLXZlbnN0ZXIgdGUgc3BlY2lmaWNlcmVuLjwvcD48cD5XYW5uZWVyIGhldCBzdGF0aXN0aWVrdHlwZSBvcCBQZXJjZW50aWVsIGlzIGluZ2VzdGVsZCwgd29yZGVuIGRlIHBhcmFtZXRlcnMgUGVyY2VudGlsZSBWYWx1ZSBlbiBQZXJjZW50aWxlIEludGVycG9sYXRpb24gVHlwZSBiZXNjaGlrYmFhci4gVSBrdW50IGRlemUgcGFyYW1ldGVycyBnZWJydWlrZW4gb20gcmVzcGVjdGlldmVsaWprIGhldCBwZXJjZW50aWVsIHRlIHNwZWNpZmljZXJlbiBkYXQgbW9ldCB3b3JkZW4gYmVyZWtlbmQgZW4gaGV0IGludGVycG9sYXRpZXR5cGUgdGUga2llemVuIGRhdCBtb2V0IHdvcmRlbiBnZWJydWlrdC4gV2FubmVlciBoZXQgc3RhdGlzdGlla3R5cGUgaXMgaW5nZXN0ZWxkIG9wIENpcmN1bGFyIE1lYW4sIHdvcmR0IGRlIHBhcmFtZXRlciBDaXJjdWxhciBXcmFwIFZhbHVlIGJlc2NoaWtiYWFyLiBEZSBjaXJjdWxhciB3cmFwIHZhbHVlIHdvcmR0IGdlYnJ1aWt0IG9tIGVlbiBsaW5lYWlyZSB3YWFyZGUgb20gdGUgemV0dGVuIGluIGhldCBiZXJlaWsgdmFuIGVlbiBvcGdlZ2V2ZW4gY2lyY3VsYWlyIGdlbWlkZGVsZGUuPC9wPlwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25OYW1lOiBcIlRlcnJlaW4gZWZmZW5lblwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25TbmlwOiBcIkNvcnJpZ2VlcnQgZGUgaW5nZXZvZXJkZSBTQVItZ2VnZXZlbnMgKFNBUiA9IHN5bnRoZXRpYyBhcGVydHVyZSByYWRhcikgdm9vciByYWRpb21ldHJpc2NoZSB2ZXJ2b3JtaW5nZW4gYWxzIGdldm9sZyB2YW4gdG9wb2dyYWZpZS5cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uRGVzYzogXCI8cD5EZSByYXN0ZXJmdW5jdGllIHZhbiBUZXJyZWluIGVmZmVuZW4gY29ycmlnZWVydCBkZSBpbmdldm9lcmRlIFNBUi1nZWdldmVucyAoU0FSID0gc3ludGhldGljIGFwZXJ0dXJlIHJhZGFyKSB2b29yIHJhZGlvbWV0cmlzY2hlIHZlcnZvcm1pbmdlbiBhbHMgZ2V2b2xnIHZhbiB0b3BvZ3JhZmllLjwvcD48cD5EZSBpbmdldm9lcmRlIHJhZGFyZ2VnZXZlbnMgbW9ldGVuIGVlcnN0IHdvcmRlbiBnZWthbGlicmVlcmQgb3AgYmV0YSBudWwuIEdlYnJ1aWsgZGUgdG9vbCBBcHBseSBSYWRpb21ldHJpYyBDYWxpYnJhdGlvbiBvbSByYWRhcmdlZ2V2ZW5zIG9wIGJldGEgbnVsIHRlIGthbGlicmVyZW4uPC9wPjxwPkFscyBkZSBpbmdldm9lcmRlIERFTSBuaWV0IGRlIHZvbGxlZGlnZSBTQVItZ2VnZXZlbnNzZXQgb21zcGFudCwgemFsIGRlIHRvb2wgR2VlbkRhdGEtd2FhcmRlbiB1aXR2b2VyZW4gdm9vciBkZSBwaXhlbHMgZGllIGJ1aXRlbiBkZSBERU0tZXh0ZW50IHZhbGxlbiB2b29yIGdhbW1hIG51bC0sIHNpZ21hIG51bC0sIHZlcnN0cm9vaWluZ3NnZWJpZWQtIGVuIGdlb21ldHJpc2NoZSB2ZXJ2b3JtaW5nc3VpdHZvZXIuIERlIHRvb2wgemFsIHZvb3IgaGV0IGdlb21ldHJpc2NoZSB2ZXJ2b3JtaW5nc21hc2tlciBvbmJlcGFhbGRlIHdhYXJkZW4gdWl0dm9lcmVuIHZvb3IgcGl4ZWxzIGRpZSBidWl0ZW4gZGUgREVNLWV4dGVudCB2YWxsZW4uPC9wPjxwPkRlIGluZ2V2b2VyZGUgREVNIG1vZXQgaW4gaGV0IGdlb2dyYWZpc2NoIGNvw7ZyZGluYWF0c3lzdGVlbSBXR1MgMTk4NCAoRVBTRzo0MzI2KSB2YWxsZW4uPC9wPlwiLFxuXHRcdGNyZWF0ZUNvbG9yQ29tcG9zaXRlRnVuY3Rpb25OYW1lOiBcIktsZXVyZW5jb21wb3NpZXQgbWFrZW5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uU25pcDogXCJNYWFrdCBlZW4gcmFzdGVyIG1ldCBkcmllIGJhbmRlbiB1aXQgZWVuIG11bHRpYmFuZC1yYXN0ZXJkYXRhc2V0LCB3YWFyYmlqIGVsa2UgYmFuZCBlZW4gYWxnZWJyYcOvc2NoZSBiZXJla2VuaW5nIG9wIGJhc2lzIHZhbiBiYW5kYWxnZWJyYSBrYW4gZ2VicnVpa2VuLlwiLFxuXHRcdGNyZWF0ZUNvbG9yQ29tcG9zaXRlRnVuY3Rpb25EZXNjOiBcIjxwPkRlIHJhc3RlcmZ1bmN0aWUgS2xldXJlbmNvbXBvc2lldCBtYWtlbiBtYWFrdCBlZW4gcmFzdGVyIG1ldCBkcmllIGJhbmRlbiB1aXQgZWVuIG11bHRpYmFuZC1yYXN0ZXJkYXRhc2V0YmFuZCBlZW4gYWxnZWJyYcOvc2NoZSBiZXJla2VuaW5nIG9wIGJhc2lzIHZhbiBiYW5kYWxnZWJyYSBrYW4gZ2VicnVpa2VuLjwvcD48cD5XYW5uZWVyIHUgZWVuIGJhbmRyZWtlbmt1bmRpZyBhbGdvcml0bWUgZGVmaW5pZWVydCwga3VudCB1IHZvb3IgZWxrZSB1aXRkcnVra2luZyBlZW4gZWVucmVnZWxpZ2UgYWxnZWJyYcOvc2NoZSBmb3JtdWxlIGludm9lcmVuIG9tIGVlbiBtdWx0aWJhbmQtdWl0dm9lciB0ZSBjcmXDq3Jlbi4gRGUgb25kZXJzdGV1bmRlIG9wZXJhdG9ycyB6aWpuIHVuYWlyLCBwbHVzICgrKSwgbWluICgtKSwgdmVybWVuaWd2dWxkaWdlbiAoKikgZW4gZ2VkZWVsZCBkb29yICgvKS48L3A+PHA+V2FubmVlciB1IGVlbiBCYW5kLWlkIGluIGVlbiB1aXRkcnVra2luZyBnZWJydWlrdCwgZGllbnQgdSBkZSBiYW5kIHRlIGlkZW50aWZpY2VyZW4gZG9vciBoZXQgYmFuZG51bW1lciBkZSBwcmVmaXggQiBvZiBiIHRlIGdldmVuLjwvcD48cD5FZW4gdmVlbCB2b29ya29tZW5kZSBiYW5kY29tYmluYXRpZSBkaWUgdm9vciBTQVIgKHN5bnRoZXRpYyBhcGVydHVyZSByYWRhcikgd29yZHQgZ2VicnVpa3QgaW4gbGluZWFpcmUgZWVuaGVkZW4gaXMgVlYgdm9vciByb29kLCBWSCB2b29yIGdyb2VuIGVuIFZWL1ZIIHZvb3IgYmxhdXcuIEFscyBkZSBpbnZvZXJnZWdldmVucyBpbiBkZWNpYmVsIHppam4gYWFuZ2VnZXZlbiwgbW9ldCBkZSBiYW5kY29tYmluYXRpZSBWViB6aWpuIHZvb3Igcm9vZCwgVkggdm9vciBncm9lbiBlbiBWVi1WSCB2b29yIGJsYXV3LjwvcD5cIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc05hbWU6IFwiT3BwZXJ2bGFrdGVwYXJhbWV0ZXJzXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNTbmlwOiBcIkJlcGFhbHQgcGFyYW1ldGVycyB2YW4gZWVuIG9wcGVydmxha3RlcmFzdGVyIHpvYWxzIGFzcGVjdCwgaGVsbGluZywgZW4gdmVyc2NoaWxsZW5kZSBzb29ydGVuIGtyb21taW5nZW4gbWV0IGJlaHVscCB2YW4gZ2VvZGV0aXNjaGUgbWV0aG9kZW4uXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNEZXNjOiBcIjxwPkRlIGZ1bmN0aWUgT3BwZXJ2bGFrdGVwYXJhbWV0ZXJzIGJlcGFhbHQgcGFyYW1ldGVycyB2YW4gZWVuIG9wcGVydmxha3RlcmFzdGVyIHpvYWxzIGFzcGVjdCwgaGVsbGluZyBlbiB2ZXJzY2hpbGxlbmRlIHNvb3J0ZW4ga3JvbW1pbmdlbiBtZXQgYmVodWxwIHZhbiBnZW9kZXRpc2NoZSBtZXRob2Rlbi48L3A+PHA+RGV6ZSBmdW5jdGllIGthbiB2b29yIGRlIHZvbGdlbmRlIHRvZXBhc3NpbmdlbiB3b3JkZW4gZ2VicnVpa3Q6PC9wPjx1bD48bGk+QmVyZWtlbiBhc3BlY3QgZW4gaGVsbGluZyBtZXQgYmVodWxwIHZhbiBnZW9kZXRpc2NoZSBtZXRob2Rlbi48L2xpPjxsaT5CZXJla2VuZW4gdmFuIHZlcnNjaGlsbGVuZGUgc29vcnRlbiBrcm9tbWluZ2VuIHZhbiBlZW4gaW5nZXZvZXJkIG9wcGVydmxha3RlcmFzdGVyLCBiaWp2b29yYmVlbGQgPHN0cm9uZz5UYW5nZW50acOrbGUgKG5vcm1hbGUgY29udG91cikga3JvbW1pbmc8L3N0cm9uZz4gZGllIGRlIHRvcG9ncmFmaXNjaGUgY29udmVyZ2VudGllIGVuIGRpdmVyZ2VudGllIHZhbiBkZSBzdHJvbWluZyBvdmVyIGhldCBvcHBlcnZsYWsga2FyYWt0ZXJpc2VlcnQuPC9saT48L3VsPlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yTmFtZTogXCJHb2Vka29vcHN0ZSBjb3JyaWRvclwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yU25pcDogXCJCZXJla2VudCBkZSBzb20gdmFuIHR3ZWUgY3VtdWxhdGlldmUga29zdGVuYWZzdGFuZHJhc3RlcnMgbWV0IGRlIG9wdGllIGVlbiBkcmVtcGVsIHRvZSB0ZSBwYXNzZW4gb3AgYmFzaXMgdmFuIGVlbiBwZXJjZW50YWdlIG9mIHZhbiBjdW11bGF0aWV2ZSBrb3N0ZW4uXCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JEZXNjOiBcIjxwPkRlIGludm9lcnJhc3RlcnMgbW9ldGVuIGJlc3RhYW4gdWl0IGRlIGFmc3RhbmRzYWNjdW11bGF0aWUtIGVuIHRlcnVnd2VncmFzdGVydWl0dm9lciB1aXQgZGUgZnVuY3RpZSA8c3Ryb25nPkFmc3RhbmRzYWNjdW11bGF0aWU8L3N0cm9uZz4gb2YgPHN0cm9uZz5BZnN0YW5kc3RvZXdpanppbmc8L3N0cm9uZz4uIERlemUgbW9ldGVuIHdvcmRlbiBnZWJhc2VlcmQgb3Aga29zdGVuYWZzdGFuZCBlbiBkZXplbGZkZSBwYXJhbWV0ZXJpbnN0ZWxsaW5nZW4gbW9ldGVuIHdvcmRlbiBnZWJydWlrdCBiaWogaGV0IG1ha2VuIHZhbiBkZSBsYWdlbiB2b29yIGVsa2UgYnJvbi4gRXIgbW9nZW4gYmlqIGhldCBtYWtlbiB2YW4gZGV6ZSByYXN0ZXJzIGdlZW4gcGFyYW1ldGVycyB3b3JkZW4gZ2VicnVpa3QgZGllIGdlYmFzZWVyZCB6aWpuIG9wIGRpcmVjdGlvbmFsaXRlaXQgKGhvcml6b250YWxlIGZhY3RvciwgdmVydGljYWxlIGZhY3RvciBlbiByZWlzcmljaHRpbmcpLjwvcD48cD5EZSB3YWFyZGVuIGluIGhldCB1aXR2b2VyY29ycmlkb3JyYXN0ZXIgemlqbiBkZSBzb20gdmFuIGRlIGN1bXVsYXRpZXZlIGtvc3RlbiB2b29yIGhldCBiZXJlaWtlbiB2YW4gZWVuIGdlZ2V2ZW4gbG9jYXRpZSBtZXQgZGV6ZWxmZGUgZWVuaGVkZW4gYWxzIGRlIGluZ2V2b2VyZGUgY3VtdWxhdGlldmUga29zdGVuYWZzdGFuZHJhc3RlcnMuPC9wPjxwPkFscyBlZW4gb3BnZWdldmVuIDxzdHJvbmc+RHJlbXBlbDwvc3Ryb25nPndhYXJkZSBiaWogaGV0IG9wdGVsbGVuIHZhbiBkZSB0d2VlIGFmc3RhbmRzYWNjdW11bGF0aWVyYXN0ZXJzIGhvZ2VyIGlzIGRhbiBkZSBtYXhpbWFsZSBjdW11bGF0aWV2ZSBrb3N0ZW4sIHphbCBoZXQgdWl0dm9lcmNvcnJpZG9ycmFzdGVyIGhldHplbGZkZSBnZWJpZWQgZGVra2VuIGFscyBkZSBpbnZvZXJhY2N1bXVsYXRpZXJhc3RlcnMuPC9wPjxwPkFscyBlZW4gb3BnZWdldmVuIGRyZW1wZWx3YWFyZGUgbGFnZXIgaXMgZGFuIGRlIG1pbmltdW13YWFyZGUgaW4gaGV0IGNvcnJpZG9ycmFzdGVyLCB3b3JkdCBlZW4gd2FhcnNjaHV3aW5nIGdlcmV0b3VybmVlcmQgZW4gemFsIGhldCB1aXR2b2VycmFzdGVyIGxlZWcgemlqbi48L3A+PHA+SGV0IHVpdHZvZXJjb3JyaWRvcnJhc3RlciBrYW4gY2VsbGVuIGJldmF0dGVuIGRpZSBsaWNodCBob2dlcmUgY3VtdWxhdGlldmUga29zdGVuIGhlYmJlbiBkYW4gZGUgZHJlbXBlbHdhYXJkZS4gRGl0IGlzIGFma29tc3RpZyB1aXQgZGUgdGVydWd3ZWdyYXN0ZXJzIGRpZSBjZWxsZW4gZ2VicnVpa2VuIHdhYXJhYW4gbGljaHQgaG9nZXJlIGtvc3RlbiB6aWpuIHRvZWdld2V6ZW4gZGFuIGRlIGRyZW1wZWx3YWFyZGUgb20gZGUgdmVyYmluZGluZyB0dXNzZW4gbG9zZ2Vrb3BwZWxkZSBjZWxsZW4gZW4gZGUgY29ycmlkb3IgdGUgaGVyc3RlbGxlbi48L3A+XCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuTmFtZTogXCJHZW9tZXRyaXNjaGUgbWVkaWFhblwiLFxuXHRcdGdlb21ldHJpY01lZGlhblNuaXA6IFwiRGUgZnVuY3RpZSBHZW9tZXRyaXNjaGUgbWVkaWFhbiBiZXJla2VudCBkZSBnZW9tZXRyaXNjaGUgbWVkaWFhbiB2b29yIHBpeGVscyBpbiBlZW4gdGlqZHJlZWtzIHZhbiBtdWx0aWJhbmRhZmJlZWxkaW5nZW4uXCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuRGVzYzogXCI8cD5EZXplIGZ1bmN0aWUgcmVkdWNlZXJ0IHJ1aXMgZW4gdWl0em9uZGVyaW5nZW4gaW4gdGlqZHJlZWtzYWZiZWVsZGluZ2VuIGRvb3IgZWVuIGdlb21ldHJpc2NoZSBtZWRpYWFuLXBpeGVsIHRlIGJlcmVrZW5lbiB2b29yIGVsa2UgcGl4ZWxhcnJheSBpbiBkZSBhZmJlZWxkaW5nc3N0YXBlbC4gSGV0IGFsZ29yaXRtZSBvbmRlcmhvdWR0IGRlIHNwZWNhbGUgcmVsYXRpZXMgdHVzc2VuIGJhbmRlbiBpbiBkZSBwaXhlbHNwZWN0cmEsIHpvZGF0IGRlIHVpdHZvZXIga2FuIHdvcmRlbiBnZWJydWlrdCBpbiBhbmFseXNlLCB6b2FscyB2ZWdldGF0aWUtaW5kaWNhdG9yZW4uPC9wPjxwPldvbGtlbiBlbiBzY2hhZHV3ZW4gbW9ldGVuIG1ldCBkZSBRQS1iYW5kIHZvb3IgZGUgZ2VnZXZlbnNzZXQgd29yZGVuIGdlbWFza2VlcmQgdm9vcmRhdCBkZXplIGZ1bmN0aWUgd29yZHQgdG9lZ2VwYXN0LjwvcD48cD5BbHMgZGUgaW52b2VyYWZiZWVsZGluZyBlZW4gendldmVuZGUgcHVudCBpcywgem9hbHMgZWVuIG9wcGVydmxha3JlZmxlY3RpZSBtZXQgd2FhcmRlbiB0dXNzZW4gMCBlbiAxLCB6b3UgZWVuIGVwc2lsb253YWFyZGUgdmFuIDAsMDAxIGt3YWxpdGF0aWVmIGdvZWRlIHJlc3VsdGF0ZW4gbW9ldGVuIHByb2R1Y2VyZW4uPC9wPlwiXG5cdH0sXG5cdHJmeEFyZ3M6IHtcblx0XHRyYXN0ZXJOYW1lOiBcIlJhc3RlclwiLFxuXHRcdGNvbG9yU2NoZW1lVHlwZU5hbWU6IFwiVHlwZSBrbGV1cmVuc2NoZW1hXCIsXG5cdFx0Y29sb3JtYXBOYW1lOiBcIktsZXVybWFwXCIsXG5cdFx0Y29sb3JtYXBOYW1lTmFtZTogXCJOYWFtIGtsZXVybWFwXCIsXG5cdFx0Y29sb3JSYW1wTmFtZTogXCJLbGV1cnZlcmxvb3BcIixcblx0XHRjb250cmFzdE9mZnNldE5hbWU6IFwiQ29udHJhc3Qtb2Zmc2V0XCIsXG5cdFx0YnJpZ2h0bmVzc09mZnNldE5hbWU6IFwiSGVsZGVyaGVpZHNjb21wZW5zYXRpZVwiLFxuXHRcdG1ldGhvZE5hbWU6IFwiTWV0aG9kZVwiLFxuXHRcdGJhbmROYW1lc05hbWU6IFwiQmFuZG5hbWVuXCIsXG5cdFx0YmFuZFdhdmVsZW5ndGhzTmFtZTogXCJCYW5kIGdvbGZsZW5ndGVuXCIsXG5cdFx0YmFuZElkc05hbWU6IFwiQmFuZCBJRCdzXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25OYW1lOiBcIkFjdGllIE9udGJyZWtlbmRlIGJhbmRcIixcblx0XHRjb252ZXJzaW9uUGFyYW1ldGVyc05hbWU6IFwiQ29udmVyc2llcGFyYW1ldGVyc1wiLFxuXHRcdGhpbGxzaGFkZVR5cGVOYW1lOiBcIlR5cGUgc2NoYWR1d3JlbGnDq2ZcIixcblx0XHRhemltdXRoTmFtZTogXCJBemltdXRcIixcblx0XHRhbHRpdHVkZU5hbWU6IFwiSG9vZ3RlXCIsXG5cdFx0c2xvcGVUeXBlTmFtZTogXCJTY2hhbGVuXCIsXG5cdFx0ekZhY3Rvck5hbWU6IFwiWi1mYWN0b3JcIixcblx0XHRQU1Bvd2VyTmFtZTogXCJWZXJtb2dlbiBwaXhlbGdyb290dGVcIixcblx0XHRQU1pGYWN0b3JOYW1lOiBcIkZhY3RvciBwaXhlbGdyb290dGVcIixcblx0XHRyZW1vdmVFZGdlRWZmZWN0TmFtZTogXCJTdGFuZGFhcmRpbnRlcnBvbGF0aWUgdmFuIHJhbmRwaXhlbCBkZWFjdGl2ZXJlblwiLFxuXHRcdGZyb21Vbml0TmFtZTogXCJWYW4gdW5pdFwiLFxuXHRcdHRvVW5pdE5hbWU6IFwiTmFhciB1bml0XCIsXG5cdFx0cmFzdGVyVHlwZU5hbWU6IFwiVHlwZVwiLFxuXHRcdG1pbk5hbWU6IFwiVWl0dm9lcm1pbmltdW1cIixcblx0XHRtYXhOYW1lOiBcIlVpdHZvZXJtYXhpbXVtXCIsXG5cdFx0bWluUGVyY2VudE5hbWU6IFwiTWluaW11bSB2YW4gcGVyY2VudGNsaXBcIixcblx0XHRtYXhQZXJjZW50TmFtZTogXCJNYXhpbXVtIHZhbiBwZXJjZW50Y2xpcFwiLFxuXHRcdG51bWJlck9mU3RhbmRhcmREZXZpYXRpb25OYW1lOiBcIkFhbnRhbCBzdGFuZGFhcmRhZndpamtpbmdlblwiLFxuXHRcdHNpZ21vaWRTdHJlbmd0aExldmVsTmFtZTogXCJOaXZlYXUgdmFuIGRlIFNpZ21vaWQtc3Rlcmt0ZVwiLFxuXHRcdGVzdGltYXRlU3RhdHNIaXN0b2dyYW1OYW1lOiBcIlN0YXRpc3RpZWtlbiBzY2hhdHRlblwiLFxuXHRcdERSQU5hbWU6IFwiQWFucGFzc2luZyB2YW4gaGV0IGR5bmFtaXNjaCBiZXJlaWtcIixcblx0XHRzdGF0aXN0aWNzTmFtZTogXCJTdGF0aXN0aWVrZW5cIixcblx0XHRoaXN0b2dyYW1zTmFtZTogXCJIaXN0b2dyYW1tZW5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtTmFtZTogXCJTdGF0aXN0aWVrZW4gZW4gSGlzdG9ncmFtIERlZmluacOrcmVuXCIsXG5cdFx0Y29tcHV0ZUdhbW1hTmFtZTogXCJBdXRvIEdhbW1hXCIsXG5cdFx0dXNlR2FtbWFOYW1lOiBcIkdhbW1hIGdlYnJ1aWtlblwiLFxuXHRcdGdhbW1hTmFtZTogXCJHYW1tYVwiLFxuXHRcdGlucHV0TmFtZXNOYW1lOiBcIk5hbWVuXCIsXG5cdFx0ZXhwcmVzc2lvbk5hbWU6IFwiRXhwcmVzc2llXCIsXG5cdFx0Y2VsbHNpemVUeXBlTmFtZTogXCJUeXBlIGNlbGdyb290dGVcIixcblx0XHRleHRlbnRUeXBlTmFtZTogXCJFeHRlbnR0eXBlXCIsXG5cdFx0Y2xhc3NpZmllckRlZmluaXRpb25GaWxlTmFtZTogXCJJbnZvZXJkZWZpbml0aWViZXN0YW5kXCIsXG5cdFx0cmFzdGVyMU5hbWU6IFwiUmFzdGVyMVwiLFxuXHRcdHJhc3RlcjJOYW1lOiBcIlJhc3RlcjJcIixcblx0XHRyYXN0ZXIzTmFtZTogXCJSYXN0ZXIzXCIsXG5cdFx0dHJ1ZVJhc3Rlck5hbWU6IFwiV2FyZSByYXN0ZXJcIixcblx0XHRmYWxzZVJhc3Rlck5hbWU6IFwiT253YXJlIHJhc3RlclwiLFxuXHRcdG5vRGF0YUludGVycHJldGF0aW9uTmFtZTogXCJOb0RhdGEtaW50ZXJwcmV0YXRpZVwiLFxuXHRcdG5vRGF0YVZhbHVlc05hbWU6IFwiTm9EYXRhLXdhYXJkZW5cIixcblx0XHRpbmNsdWRlZFJhbmdlc05hbWU6IFwiSW5jbHVzaWVmIHJlZWtzZW5cIixcblx0XHRjdXJ2YXR1cmVUeXBlTmFtZTogXCJDdXJ2YXR1cmV0eXBlXCIsXG5cdFx0cmFzdGVyc05hbWU6IFwiUmFzdGVyc1wiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlTmFtZTogXCJUYWJlbFwiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZU5hbWU6IFwiVGFiZWx0eXBlXCIsXG5cdFx0cm93c05hbWU6IFwiQWFudGFsIHJpamVuXCIsXG5cdFx0Y29sdW1uc05hbWU6IFwiQWFudGFsIGtvbG9tbWVuXCIsXG5cdFx0a2VybmVsTmFtZTogXCJLZXJuZWxcIixcblx0XHRtaXJyb3JFZGdlc05hbWU6IFwiU3BpZWdlbHJhbmRlblwiLFxuXHRcdGluZmx1ZW5jZXNOYW1lOiBcIkludmxvZWRlblwiLFxuXHRcdGZpZWxkc05hbWU6IFwiVmVsZGVuXCIsXG5cdFx0cmVtYXBzTmFtZTogXCJSZW1hcHRhYmVsXCIsXG5cdFx0ZXZhbEZyb21OYW1lOiBcIkV2YWx1YXRpZXNjaGFhbCB2YW5cIixcblx0XHRldmFsVG9OYW1lOiBcIkV2YWx1YXRpZXNjaGFhbCB0b3RcIixcblx0XHR3ZWlnaHRzTmFtZTogXCJHZXdpY2h0ZW5cIixcblx0XHRERU1OYW1lOiBcIkRFTVwiLFxuXHRcdHNob3J0UmFuZ2VJRFdSYWRpdXNOYW1lOiBcIktvcnQgYmVyZWlrIElEVyBSYWRpdXNcIixcblx0XHRtYXhWb2lkV2lkdGhOYW1lOiBcIk1heC4gYnJlZWR0ZSBsZWVndGVcIixcblx0XHRzaWdtYUdhdXNzaWFuTmFtZTogXCJCZXdlcmtlbGlqayBTbW9vdGhpbmdcIixcblx0XHRjb250b3VyVHlwZU5hbWU6IFwiQ29udG91cnR5cGVcIixcblx0XHR6QmFzZU5hbWU6IFwiWi1iYXNpc1wiLFxuXHRcdG51bWJlck9mQ29udG91cnNOYW1lOiBcIkFhbnRhbCBjb250b3VyZW5cIixcblx0XHRjb250b3VySW50ZXJ2YWxOYW1lOiBcIkNvbnRvdXJpbnRlcnZhbFwiLFxuXHRcdG50aENvbnRvdXJMaW5lSW5Cb2xkTmFtZTogXCJOdGggY29udG91cmxpam4gdmV0XCIsXG5cdFx0ZmVhdHVyZUNsYXNzTmFtZTogXCJJbnZvZXJvYmplY3RlblwiLFxuXHRcdGNsYXNzSW5kZXhGaWVsZE5hbWU6IFwiVmVsZFwiLFxuXHRcdHJlc29sdmVPdmVybGFwTWV0aG9kTmFtZTogXCJPdmVybGFwbWV0aG9kZSBvcGxvc3NlblwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmFtZTogXCJSZXNhbXBsaW5nIFR5cGVcIixcblx0XHRpbnB1dENlbGxzaXplTmFtZTogXCJJbnZvZXIgY2VsZ3Jvb3R0ZVwiLFxuXHRcdG91dHB1dENlbGxzaXplTmFtZTogXCJVaXR2b2VyIGNlbGdyb290dGVcIixcblx0XHRwb2ludEZlYXR1cmVDbGFzc05hbWU6IFwiQmVnaW5wdW50ZW5cIixcblx0XHRtYXhHcm93dGhSYWRpdXNGaWVsZE5hbWU6IFwiTWF4IGdyb290aG9la3ZlbGRcIixcblx0XHRzaW1pbGFyaXR5VGhyZXNob2xkRmllbGROYW1lOiBcIkdlbGlqa3dhYXJkaWdoZWlkc2RyZW1wZWx2ZWxkXCIsXG5cdFx0ZmlsbFZhbHVlRmllbGROYW1lOiBcIlZ1bHdhYXJkZXZlbGRcIixcblx0XHRzcGVjdHJhbERldGFpbE5hbWU6IFwiU3BlY3RyYWFsIGRldGFpbCBbMS4uMjBdXCIsXG5cdFx0c3BhdGlhbERldGFpbE5hbWU6IFwiU3BhdGlhYWwgZGV0YWlsIFsxLi4yMF1cIixcblx0XHRtaW5OdW1QaXhlbHNQZXJTZWdtZW50TmFtZTogXCJNaW5pbXVtZ3Jvb3R0ZSB2YW4gc2VnbWVudGVuIGluIHBpeGVsc1wiLFxuXHRcdGJvdW5kYXJpZXNPbmx5TmFtZTogXCJFbmtlbCBncmVuemVuIHZhbiBzZWdtZW50ZW5cIixcblx0XHRzdGF0aXN0aWNzVHlwZU5hbWU6IFwiU3RhdGlzdGlla3R5cGVcIixcblx0XHRmaWxsTm9EYXRhT25seU5hbWU6IFwiRW5rZWwgTm9EYXRhLXBpeGVscyB2dWxsZW5cIixcblx0XHRpbnB1dERhdGFUeXBlTmFtZTogXCJJbnZvZXJkYXRhdHlwZVwiLFxuXHRcdGFuZ2xlUmVmZXJlbmNlU3lzdGVtTmFtZTogXCJIb2VrcmVmZXJlbnRpZXN5c3RlZW1cIixcblx0XHRvdXRwdXREYXRhVHlwZU5hbWU6IFwiVWl0dm9lcmdlZ2V2ZW5zdHlwZVwiLFxuXHRcdGlucHV0U2FtcGxlUG9pbnRGZWF0dXJlQ2xhc3NOYW1lOiBcIkludm9lcnZvb3JiZWVsZGVuXCIsXG5cdFx0dmFsdWVGaWVsZE5hbWU6IFwiV2FhcmRldmVsZFwiLFxuXHRcdHJhc3RlckluZm9OYW1lOiBcIlJhc3RlcmluZm9cIixcblx0XHRpbnRlcnBvbGF0aW9uTWV0aG9kTmFtZTogXCJJbnRlcnBvbGF0aWVtZXRob2RlXCIsXG5cdFx0cmFkaXVzTmFtZTogXCJTdHJhYWxcIixcblx0XHRyYWRpYW5jZUdhaW5WYWx1ZXNOYW1lOiBcIlN0cmFsaW5nc3RvZW5hbWVcIixcblx0XHRyYWRpYW5jZUJpYXNWYWx1ZXNOYW1lOiBcIlN0cmFsaW5nIGdlbWlkZGVsZGUgYWZ3aWpraW5nXCIsXG5cdFx0cmVmbGVjdGVkR2FpblZhbHVlc05hbWU6IFwiUmVmbGVjdGlld2luc3RcIixcblx0XHRyZWZsZWN0ZWRCaWFzVmFsdWVzTmFtZTogXCJSZWZsZWN0aWV2ZXJ0ZWtlbmluZ1wiLFxuXHRcdHN1bkVsZXZhdGlvbk5hbWU6IFwiWm9uZWxldmF0aWUgKGdyYWRlbilcIixcblx0XHRhbGJlZG9OYW1lOiBcIkFsYmVkb1wiLFxuXHRcdHNjYWxlRmFjdG9yTmFtZTogXCJTY2hhYWxmYWN0b3JcIixcblx0XHRvZmZzZXROYW1lOiBcIk9mZnNldFwiLFxuXHRcdHRocmVzaG9sZFR5cGVOYW1lOiBcIkRyZW1wZWx0eXBlXCIsXG5cdFx0dGhyZXNob2xkc05hbWU6IFwiRHJlbXBlbHNcIixcblx0XHR1bmRlZmluZWRDbGFzc05hbWU6IFwiT25nZWRlZmluaWVlcmRlIGtsYXNzZVwiLFxuXHRcdG1pblZhbHVlTmFtZTogXCJNaW5cIixcblx0XHRtYXhWYWx1ZU5hbWU6IFwiTWF4XCIsXG5cdFx0b3BlcmF0aW9uTmFtZTogXCJXZXJrXCIsXG5cdFx0Y2xpcHBpbmdUeXBlTmFtZTogXCJLbmlwdHlwZVwiLFxuXHRcdGNsaXBwaW5nR2VvbWV0cnlOYW1lOiBcIkdlb21ldHJpZS9yYXN0ZXIgYWZrbmlwcGVuXCIsXG5cdFx0ZXh0ZW50TmFtZTogXCJVaXR2b2VyZXh0ZW50XCIsXG5cdFx0dXNlSW5wdXRGZWF0dXJlR2VvbWV0cnlOYW1lOiBcIkludm9lcm9iamVjdGVuIGdlYnJ1aWtlbiB2b29yIGhldCBrbmlwcGVuIHZhbiBnZW9tZXRyaWVcIixcblx0XHRyZW1hcERlZmluaXRpb25UeXBlTmFtZTogXCJEZWZpbml0aWV0eXBlIG9wbmlldXcgaW4ga2FhcnQgYnJlbmdlblwiLFxuXHRcdGlucHV0UmFuZ2VOYW1lOiBcIkludm9lcmJlcmVpa2VuXCIsXG5cdFx0b3V0cHV0VmFsdWVzTmFtZTogXCJVaXR2b2Vyd2FhcmRlblwiLFxuXHRcdG5vRGF0YVJhbmdlTmFtZTogXCJOb0RhdGEtYmVyZWlrZW5cIixcblx0XHRpbnB1dEZpZWxkTmFtZTogXCJJbnZvZXJ2ZWxkXCIsXG5cdFx0b3V0cHV0RmllbGROYW1lOiBcIlVpdHZvZXJ2ZWxkXCIsXG5cdFx0aW5wdXRNYXhGaWVsZE5hbWU6IFwiTWF4aW11bXZlbGQgdm9vciBpbnZvZXIgKG9wdGlvbmVlbClcIixcblx0XHRyZW1hcFRhYmxlVHlwZU5hbWU6IFwiVGFiZWx0eXBlIG9wbmlldXcgaW4ga2FhcnQgYnJlbmdlblwiLFxuXHRcdGFsbG93VW5tYXRjaGVkTmFtZTogXCJTdGEgb25nZcOrdmVuYWFyZGUgcGl4ZWx3YWFyZGVuIHRvZVwiLFxuXHRcdGNoYW5nZU1pc3NpbmdWYWx1ZXNUb05vRGF0YU5hbWU6IFwiT250YnJla2VuZGUgd2FhcmRlbiB2ZXJhbmRlcmVuIG5hYXIgTm9EYXRhXCIsXG5cdFx0dmlzaWJsZUJhbmRJRE5hbWU6IFwiWmljaHRiYXJlIGJhbmQtSURcIixcblx0XHRpbmZyYXJlZEJhbmRJRE5hbWU6IFwiSW5mcmFyb2RlIGJhbmQtSURcIixcblx0XHRzY2llbnRpZmljT3V0cHV0TmFtZTogXCJXZXRlbnNjaGFwcGVsaWprZSB1aXR2b2VyXCIsXG5cdFx0YmFuZEluZGV4ZXNOYW1lOiBcIkJhbmRpbmRleGVuXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIkNvbnN0YW50ZVwiLFxuXHRcdHdlaWdodE5hbWU6IFwiR2V3aWNodFwiLFxuXHRcdG1pbmltdW1OYW1lOiBcIk1pbmltdW1cIixcblx0XHRtYXhpbXVtTmFtZTogXCJNYXhpbXVtXCIsXG5cdFx0c291cmNlRGF0YU5hbWU6IFwiQnJvbnJhc3RlclwiLFxuXHRcdHNvdXJjZUZpZWxkTmFtZTogXCJCcm9udmVsZFwiLFxuXHRcdGNvc3RSYXN0ZXJOYW1lOiBcIktvc3RyYXN0ZXJcIixcblx0XHRtYXhEaXN0YW5jZU5hbWU6IFwiTWF4aW11bWFmc3RhbmRcIixcblx0XHR2YWx1ZVJhc3Rlck5hbWU6IFwiV2FhcmRlcmFzdGVyXCIsXG5cdFx0Y29zdE11bHRpcGxpZXJOYW1lOiBcIlZlcm1lbmlndnVsZGlnaW5nc2ZhY3RvciBvbSB0b2UgdGUgcGFzc2VuIG9wIGRlIGtvc3RlblwiLFxuXHRcdHN0YXJ0Q29zdE5hbWU6IFwiS29zdGVuIHN0YXJ0ZW5cIixcblx0XHRhY2N1bUNvc3RSZXNpc3RhbmNlUmF0ZU5hbWU6IFwiV2VlcnN0YW5kc3RlbXBvIHZhbiBhY2N1bXVsYXRpZXZlIGtvc3RlblwiLFxuXHRcdGNhcGFjaXR5TmFtZTogXCJDYXBhY2l0ZWl0XCIsXG5cdFx0dHJhdmVsRGlyZWN0aW9uTmFtZTogXCJSb3V0ZXJpY2h0aW5nXCIsXG5cdFx0Y2VsbFNpemVOYW1lOiBcIkNlbGdyb290dGVcIixcblx0XHRwb3B1bGF0aW9uRmllbGROYW1lOiBcIlBvcHVsYXRpZXZlbGRcIixcblx0XHRhcmVhVW5pdHNOYW1lOiBcIk9wcGVydmxha3RlLWVlbmhlZGVuXCIsXG5cdFx0b3V0cHV0VmFsdWVUeXBlTmFtZTogXCJVaXR2b2VyY2Vsd2FhcmRlblwiLFxuXHRcdGJhcnJpZXJzTmFtZTogXCJJbnZvZXJiYXJyacOocmVzXCIsXG5cdFx0ZGVzdGluYXRpb25EYXRhTmFtZTogXCJCZXN0ZW1taW5nc3Jhc3RlclwiLFxuXHRcdGRlc3RpbmF0aW9uRmllbGROYW1lOiBcIkJlc3RlbW1pbmdzdmVsZFwiLFxuXHRcdHBhdGhUeXBlTmFtZTogXCJQYWR0eXBlXCIsXG5cdFx0b2JzZXJ2ZXJGZWF0dXJlc05hbWU6IFwiT2JzZXJ2ZWVyZGVyb2JqZWN0ZW5cIixcblx0XHRhbmFseXNpc01ldGhvZE5hbWU6IFwiQW5hbHlzZW1ldGhvZGVcIixcblx0XHRhbmFseXNpc1R5cGVOYW1lOiBcIkFuYWx5c2V0eXBlXCIsXG5cdFx0dmVydGljYWxFcnJvck5hbWU6IFwiVmVydGljYWxlIGZvdXRcIixcblx0XHRyZWZyYWN0aXZpdHlDb2VmZmljaWVudE5hbWU6IFwiUmVmcmFjdGllY2/Dq2ZmaWNpw6tudFwiLFxuXHRcdHN1cmZhY2VPZmZzZXROYW1lOiBcIk9wcGVydmxha3RlY29tcGVuc2F0aWVcIixcblx0XHRvYnNlcnZlckVsZXZhdGlvbk5hbWU6IFwiT2JzZXJ2ZWVyZGVyZWxldmF0aWVcIixcblx0XHRvYnNlcnZlck9mZnNldE5hbWU6IFwiT2JzZXJ2ZWVyZGVyY29tcGVuc2F0aWVcIixcblx0XHRpbm5lclJhZGl1c05hbWU6IFwiQmlubmVuc3RlIHN0cmFhbFwiLFxuXHRcdGlubmVyUmFkaXVzSXMzRERpc3RhbmNlTmFtZTogXCJCaW5uZW5zdGUgUmFkaXVzIGlzIDNELWFmc3RhbmRcIixcblx0XHRvdXRlclJhZGl1c05hbWU6IFwiQnVpdGVuc3RlIHN0cmFhbFwiLFxuXHRcdG91dGVyUmFkaXVzSXMzRERpc3RhbmNlTmFtZTogXCJCdWl0ZW5zdGUgUmFkaXVzIGlzIDNELWFmc3RhbmRcIixcblx0XHRob3Jpem9udGFsU3RhcnRBbmdsZU5hbWU6IFwiSG9yaXpvbnRhbGUgc3RhcnRob2VrXCIsXG5cdFx0aG9yaXpvbnRhbEVuZEFuZ2xlTmFtZTogXCJIb3Jpem9udGFsZSBlaW5kaG9la1wiLFxuXHRcdHZlcnRpY2FsVXBwZXJBbmdsZU5hbWU6IFwiVmVydGljYWxlIGJvdmVuaG9la1wiLFxuXHRcdHZlcnRpY2FsTG93ZXJBbmdsZU5hbWU6IFwiVmVydGljYWxlIGJlbmVkZW5ob2VrXCIsXG5cdFx0em9uZURhdGFOYW1lOiBcIlpvbmVyYXN0ZXJcIixcblx0XHR6b25lRmllbGROYW1lOiBcIlpvbmV2ZWxkXCIsXG5cdFx0aWdub3JlTm9EYXRhTmFtZTogXCJOb0RhdGEgbmVnZXJlbiBpbiBiZXJla2VuaW5nZW5cIixcblx0XHR0ZW1wZXJhdHVyZVJhc3Rlck5hbWU6IFwiVGVtcGVyYXR1dXJyYXN0ZXJcIixcblx0XHRpblRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlRlbXBlcmF0dXVyZWVuaGVkZW5cIixcblx0XHRvdXRIZWF0SW5kZXhUZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJXYXJtdGUtaW5kZXhlZW5oZWRlblwiLFxuXHRcdHJlbGF0aXZlSHVtaWRpdHlSYXN0ZXJOYW1lOiBcIlJhc3RlciB2b29yIHJlbGF0aWV2ZSB2b2NodGlnaGVpZFwiLFxuXHRcdG91dFdpbmRDaGlsbFRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIkVlbmhlZGVuIHZvb3IgZ2V2b2Vsc3RlbXBlcmF0dXVyXCIsXG5cdFx0d2luZFNwZWVkUmFzdGVyTmFtZTogXCJXaW5kc25lbGhlaWRzcmFzdGVyXCIsXG5cdFx0aW5XaW5kU3BlZWRVbml0c05hbWU6IFwiV2luZHNuZWxoZWlkc2VlbmhlZGVuXCIsXG5cdFx0dmFsdWVOYW1lOiBcIldhYXJkZVwiLFxuXHRcdHByb3BlcnR5TmFtZTogXCJFaWdlbmRvbXNuYWFtXCIsXG5cdFx0anNvbk5hbWU6IFwiTWV0YWRhdGEgSlNPTlwiLFxuXHRcdHpvbmVUYWJsZU5hbWU6IFwiVGFiZWwgbWV0IHpvbmVhdHRyaWJ1dGVuXCIsXG5cdFx0YXR0cmlidXRlRmllbGROYW1lczogXCJWZWxkbmFtZW4gdmFuIGF0dHJpYnV0ZW5cIixcblx0XHRiYWNrZ3JvdW5kTmFtZTogXCJBY2h0ZXJncm9uZHdhYXJkZVwiLFxuXHRcdHdoZXJlQ2xhdXNlTmFtZTogXCJXYWFyLWJlcGFsaW5nXCIsXG5cdFx0bWluaW11bVZhbHVlRmllbGROYW1lOiBcIk1pbmltdW13YWFyZGUgdm9vciB2ZWxkbmFhbVwiLFxuXHRcdG1heGltdW1WYWx1ZUZpZWxkTmFtZTogXCJNYXhpbXVtd2FhcmRlIHZvb3IgdmVsZG5hYW1cIixcblx0XHRvdXRWYWx1ZUZpZWxkTmFtZTogXCJVaXR2b2Vyd2FhcmRlIHZhbiB2ZWxkbmFhbVwiLFxuXHRcdGRlZmF1bHRWYWx1ZU5hbWU6IFwiU3RhbmRhYXJkdWl0dm9lcndhYXJkZVwiLFxuXHRcdGNvbnZlcnNpb25NYXRyaXhOYW1lOiBcIkNvbnZlcnNpZW1hdHJpeFwiLFxuXHRcdElzUHNldWRvQ29sb3JPdXRwdXROYW1lOiBcIklzIGVlbiBwc2V1ZG9rbGV1cmVudWl0dm9lclwiLFxuXHRcdHVubWFwcGVkQXNSYW5kb21Db2xvck5hbWU6IFwiV2lsbGVrZXVyaWcga2xldXIgYWFuIG5pZXQtdG9lZ2V3ZXplbiBwaXhlbHMgdG9ld2lqemVuXCIsXG5cdFx0ZGlzdGFuY2VNZXRob2ROYW1lOiBcIkFmc3RhbmRtZXRob2RlXCIsXG5cdFx0Zmxvd0RpclJhc3Rlck5hbWU6IFwiU3Ryb29tcmljaHRpbmcgcmFzdGVyXCIsXG5cdFx0cG91clBvaW50TmFtZTogXCJTdG9ydHB1bnQoZW4pIHJhc3RlclwiLFxuXHRcdHBvdXJQb2ludEZpZWxkTmFtZTogXCJTdG9ydHB1bnQgdmVsZFwiLFxuXHRcdGNvbnN0YW50Wk5hbWU6IFwiQ29uc3RhbnRlIFpcIixcblx0XHR6T2Zmc2V0TmFtZTogXCJaIE9mZnNldFwiLFxuXHRcdGdlb0lkTmFtZTogXCJHZW/Dr2RlXCIsXG5cdFx0Y2FsaWJyYXRpb25UeXBlTmFtZTogXCJLYWxpYnJhdGlldHlwZVwiLFxuXHRcdGZpbHRlclR5cGVOYW1lOiBcIkZpbHRlcnR5cGVcIixcblx0XHRmaWx0ZXJTaXplTmFtZTogXCJGaWx0ZXJncm9vdHRlXCIsXG5cdFx0bm9pc2VNb2RlbE5hbWU6IFwiTm9pc2Vtb2RlbFwiLFxuXHRcdG5vaXNlVmFyaWFuY2VOYW1lOiBcIk5vaXNlLXZhcmlhdGllXCIsXG5cdFx0YWRkaXRpdmVOb2lzZU1lYW5OYW1lOiBcIkdlbWlkZGVsZGUgdG9lZ2V2b2VnZCBub2lzZVwiLFxuXHRcdG11bHRpcGxpY2F0aXZlTm9pc2VNZWFuTmFtZTogXCJHZW1pZGRlbGRlIHZlcm1lbmlndnVsZGlnZCBub2lzZVwiLFxuXHRcdG51bWJlcm9mTG9va3NOYW1lOiBcIkFhbnRhbCBsb29rc1wiLFxuXHRcdGRhbXBpbmdGYWN0b3JOYW1lOiBcIkRlbXBpbmdzZmFjdG9yXCIsXG5cdFx0bWFza1Jhc3Rlck5hbWU6IFwiTWFza2VycmFzdGVyXCIsXG5cdFx0bmliYmxlVmFsdWVzTmFtZTogXCJHZWJydWlrIE5vRGF0YS13YWFyZGVuIGFscyB6ZSBkZSBuYWFzdGUgYnV1ciB6aWpuXCIsXG5cdFx0bmliYmxlTm9EYXRhTmFtZTogXCJOaWJibGUgTm9EYXRhLWNlbGxlblwiLFxuXHRcdHpMaW1pdE5hbWU6IFwiWiBMaW1pZXRcIixcblx0XHRmbG93RGlyZWN0aW9uVHlwZU5hbWU6IFwiU3Ryb29tcmljaHRpbmcgdHlwZVwiLFxuXHRcdHdlaWdodFJhc3Rlck5hbWU6IFwiR2V3aWNodHNyYXN0ZXJcIixcblx0XHRmb3JjZUVkZ2VOYW1lOiBcIkZvcmNlZXIgYWxsZSByYW5kY2VsbGVuIG9tIG5hYXIgYnVpdGVuIHRlIHN0cm9tZW5cIixcblx0XHRzdHJlYW1SYXN0ZXJOYW1lOiBcIlN0cm9vbXJhc3RlclwiLFxuXHRcdHN1cmZhY2VSYXN0ZXJOYW1lOiBcIk9wcGVydmxha3Jhc3RlclwiLFxuXHRcdGNvbnZlcnNpb25UeXBlOiBcIkNvbnZlcnNpZXR5cGVcIixcblx0XHRkaXN0YW5jZVJhc3RlcjE6IFwiQWZzdGFuZHNyYXN0ZXIgMVwiLFxuXHRcdGRpc3RhbmNlUmFzdGVyMjogXCJBZnN0YW5kc3Jhc3RlciAyXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyOiBcIktvc3RlbmFmc3RhbmRyYXN0ZXJcIixcblx0XHRjb3N0QmFja2xpbmtSYXN0ZXI6IFwiS29zdGVucmFzdGVyIGJhY2tsaW5rXCIsXG5cdFx0b3ZlcnJpZGVzTmFtZTogXCJPdmVyc2NocmlqZGVuXCIsXG5cdFx0ZmllbGROYW1lOiBcIlZlbGRcIixcblx0XHRzaWduYXR1cmVGaWxlT3JVcmw6IFwiSGFuZHRla2VuaW5nYmVzdGFuZCBvZiBVUkxcIixcblx0XHRyZWROYW1lOiBcIlJvb2RcIixcblx0XHRncmVlbk5hbWU6IFwiR3JvZW5cIixcblx0XHRibHVlTmFtZTogXCJCbGF1d1wiLFxuXHRcdGluZnJhcmVkTmFtZTogXCJJbmZyYXJvb2RcIixcblx0XHRwYW5jaHJvbWF0aWNOYW1lOiBcIlBhbmNocm9tYXRpc2NoXCIsXG5cdFx0bXVsdGlzcGVjdHJhbE5hbWU6IFwiTXVsdGlzcGVjdHJhYWxcIixcblx0XHRwYW5zaGFycGVuaW5nVHlwZTogXCJQYW5zaGFycGVuaW5nIHR5cGVcIixcblx0XHRzZW5zb3JOYW1lOiBcIlNlbnNvclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VOYW1lOiBcIlJ1aW10ZWxpamtlIHJlZmVyZW50aWVcIixcblx0XHR4Q2VsbHNpemVOYW1lOiBcIlggQ2VsZ3Jvb3R0ZVwiLFxuXHRcdHlDZWxsc2l6ZU5hbWU6IFwiWSBDZWxncm9vdHRlXCIsXG5cdFx0eE9yaWdpbk5hbWU6IFwiWCBSZWdpc3RyYXRpZXB1bnRcIixcblx0XHR5T3JpZ2luTmFtZTogXCJZIFJlZ2lzdHJhdGllcHVudFwiLFxuXHRcdHBlcmNlbnRpbGVOYW1lOiBcIlBlcmNlbnRpZWx3YWFyZGVcIixcblx0XHRuZWlnaGJvcmhvb2RUeXBlOiBcIlR5cGUgYnV1cnRcIixcblx0XHR3aWR0aE5hbWU6IFwiQnJlZWR0ZVwiLFxuXHRcdGhlaWdodE5hbWU6IFwiSG9vZ3RlXCIsXG5cdFx0c3RhcnRBbmdsZU5hbWU6IFwiU3RhcnRob2VrXCIsXG5cdFx0ZW5kQW5nbGVOYW1lOiBcIkVpbmRob2VrXCIsXG5cdFx0bmVpZ2hib3Job29kVmFsdWVzOiBcIkJ1dXJ0d2FhcmRlblwiLFxuXHRcdGhvcml6b250YWxSYXN0ZXI6IFwiSG9yaXpvbnRhYWwgcmFzdGVyXCIsXG5cdFx0aG9yaXpvbnRhbEZhY3RvcjogXCJIb3Jpem9udGFsZSBmYWN0b3JcIixcblx0XHR2ZXJ0aWNhbFJhc3RlcjogXCJWZXJ0aWNhYWwgcmFzdGVyXCIsXG5cdFx0dmVydGljYWxGYWN0b3I6IFwiVmVydGljYWxlIGZhY3RvclwiLFxuXHRcdHN0cmVhbVJhc3RlcjogXCJTdHJvb21yYXN0ZXJcIixcblx0XHRmbG93RGlyUmFzdGVyOiBcIlN0cm9vbXJpY2h0aW5nIHJhc3RlclwiLFxuXHRcdG51bWJlck5laWdoYm9yQ2VsbHM6IFwiQWFudGFsIGJ1dXJjZWxsZW5cIixcblx0XHR6b25lQ29ubmVjdGl2aXR5OiBcIlpvbmUtY29ubmVjdGl2aXRlaXRcIixcblx0XHRhZGRMaW5rQmVoYXZpb3I6IFwiVm9lZyBrb3BwZWxpbmcgdG9lXCIsXG5cdFx0ZXhjbHVkZWRWYWx1ZTogXCJVaXRnZXNsb3RlbiB3YWFyZGVcIixcblx0XHRjb25zdGFudEZpbGxDaGVjazogXCJHZW5lcmVlciBvcHZ1bHJhc3RlciB2YW4gY29uc3RhbnRlXCIsXG5cdFx0ZmlsbFJhc3RlcjogXCJPcHZ1bHJhc3RlclwiLFxuXHRcdGNvbnN0YW50RmlsbFZhbHVlOiBcIkNvbnN0YW50ZSB3YWFyZGVcIixcblx0XHRpbnB1dEJpdFBvc2l0aW9uczogXCJJbnZvZXJiaXRcIixcblx0XHRvdXRwdXRCaXRQb3NpdGlvbnM6IFwiVWl0dm9lcmJpdFwiLFxuXHRcdGRpc3RhbmNlVHlwZU5hbWU6IFwiQWZzdGFuZHN0eXBlXCIsXG5cdFx0YmFycmllckRhdGFOYW1lOiBcIlJhc3RlcmJhcnJpw6hyZXNcIixcblx0XHRwb3VyUG9pbnREYXRhTmFtZTogXCJTdG9ydHB1bnRyYXN0ZXJcIixcblx0XHRhY2N1bXVsYXRpb25SYXN0ZXJOYW1lOiBcIlN0cm9vbWFjY3VtdWxhdGllcmFzdGVyXCIsXG5cdFx0c25hcERpc3RhbmNlTmFtZTogXCJTbmFwLWFmc3RhbmRcIixcblx0XHRvcmRlck1ldGhvZE5hbWU6IFwiQW5kZXJlIG1ldGhvZGVcIixcblx0XHRkaXJlY3Rpb25NZWFzdXJlbWVudE5hbWU6IFwiUmljaHRpbmcgdmFuIG1ldGluZ1wiLFxuXHRcdHByb2Nlc3NBc011bHRpYmFuZDogXCJWZXJ3ZXJrZW4gYWxzIG11bHRpYmFuZFwiLFxuXHRcdHByb2Nlc3NNdWx0aWRpbWVuc2lvbmFsOiBcIlZlcndlcmtlbiBhbHMgbXVsdGlkaW1lbnNpb25hYWxcIixcblx0XHRmb3JjZUZsb3dEaXJlY3Rpb25Db252ZW50aW9uOiBcIkZvcmNlZXIgc3Ryb29tcmljaHRpbmcgbmFhciBiYWNrbGlua3Jhc3RlclwiLFxuXHRcdGluaXRpYWxBY2N1bXVsYXRpb246IFwiSW5pdGnDq2xlIGFjY3VtdWxhdGllXCIsXG5cdFx0bWF4aW11bUFjY3VtdWxhdGlvbjogXCJNYXhpbWFsZSBhY2N1bXVsYXRpZVwiLFxuXHRcdHNvdXJjZUxvY2F0aW9uQmFuZHM6IFwiR2VuZXJlZXIgYnJvbnJpaiBlbiBrb2xvbSBhbHMgZXh0cmEgYmFuZGVuIGluIGRlIHVpdHZvZXJcIixcblx0XHRiYWNrRGlyZWN0aW9uQmFuZDogXCJHZW5lcmVlciBkZSB0ZXJ1Z3JpY2h0aW5nIGFscyBleHRyYSBiYW5kIGluIG91dHB1dFwiLFxuXHRcdG51bWJlck9mQ2VsbHM6IFwiQWFudGFsIGNlbGxlblwiLFxuXHRcdHpvbmVWYWx1ZXM6IFwiWm9uZXdhYXJkZW5cIixcblx0XHRzaHJpbmtNZXRob2Q6IFwiS3JpbXBtZXRob2RlXCIsXG5cdFx0ZXhwYW5kTWV0aG9kOiBcIlVpdHZlcmdyb290bWV0aG9kZVwiLFxuXHRcdGlucHV0U3BlY3RyYWxQcm9maWxlVHlwZTogXCJUeXBlIHNwZWN0cmFhbCBwcm9maWVsXCIsXG5cdFx0c3BlY3RyYWxQcm9maWxlRmlsZU5hbWU6IFwiU3BlY3RyYWFsIHByb2ZpZWxcIixcblx0XHR0cmFpbmluZ0ZlYXR1cmVGaWxlTmFtZTogXCJPcGxlaWRpbmdzb2JqZWN0XCIsXG5cdFx0bm9uTmVnYXRpdmU6IFwiTmlldC1uZWdhdGllZlwiLFxuXHRcdHN1bVRvT25lOiBcIlNvbSBvcCDDqcOpblwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvbjogXCJEaXN0cmlidXRpZVwiLFxuXHRcdG1lYW5OYW1lOiBcIk1lZGlhYW5cIixcblx0XHRwcm9iYWJpbGl0eU5hbWU6IFwiS2Fuc1wiLFxuXHRcdGFscGhhTmFtZTogXCJBbHBoYVwiLFxuXHRcdGJldGFOYW1lOiBcIkLDqHRhXCIsXG5cdFx0ck5hbWU6IFwiclwiLFxuXHRcdG5OYW1lOiBcIk5cIixcblx0XHRzZWVkOiBcIkJlZ2luXCIsXG5cdFx0cmFuZG9tTnVtYmVyR2VuZXJhdG9yOiBcIldpbGxla2V1cmlnZSBudW1tZXJnZW5lcmF0aWVcIixcblx0XHRjZWxsRmFjdG9yOiBcIkNlbGZhY3RvclwiLFxuXHRcdGFnZ3JlZ2F0aW9uVHlwZTogXCJBZ2dyZWdhdGlldGVjaG5pZWtcIixcblx0XHRleHRlbnRIYW5kbGluZzogXCJFeHRlbnQgdWl0dm91d2VuIGluZGllbiBub2RpZ1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNEaW1lbnNpb25OYW1lOiBcIkZvcm1hYXRuYWFtXCIsXG5cdFx0dHJlbmRBbmFseXNpc1R5cGU6IFwiVHJlbmR0eXBlXCIsXG5cdFx0aGFybW9uaWNGcmVxdWVuY3k6IFwiSGFybW9uaXNjaGUgZnJlcXVlbnRpZVwiLFxuXHRcdHBvbHlub21pYWxPcmRlcjogXCJQb2x5bm9taWFsZSB2b2xnb3JkZVwiLFxuXHRcdGN5Y2xlTGVuZ3RoTmFtZTogXCJMZW5ndGUgdmFuIGRlIGN5Y2x1c1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNSTVNFOiBcIlJNU0VcIixcblx0XHR0cmVuZEFuYWx5c2lzUjI6IFwiUi1TcXVhcmVkXCIsXG5cdFx0dHJlbmRBbmFseXNpc1Nsb3BlUFZhbHVlOiBcIlAtd2FhcmRlIHZhbiBkZSBoZWxsaW5nc2hvZWtjb8OrZmZpY2nDq250XCIsXG5cdFx0dHJlbmRBbmFseXNpc1NlYXNvbmFsUGVyaW9kOiBcIlNlaXpvZW5zcGVyaW9kZVwiLFxuXHRcdGN5Y2xlVW5pdE5hbWU6IFwiQ3ljbHVzZWVuaGVpZFwiLFxuXHRcdHByZWRpY3REaW1lbnNpb25WYWx1ZXM6IFwiV2FhcmRlblwiLFxuXHRcdGRpbWVuc2lvbkRlZmluaXRpb25UeXBlOiBcIkZvcm1hYXRkZWZpbml0aWVcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uU3RhcnQ6IFwiU3RhcnRcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uRW5kOiBcIkVpbmRlXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvbkludGVydmFsOiBcIldhYXJkZS1pbnRlcnZhbFwiLFxuXHRcdGRpbWVuc2lvblVuaXQ6IFwiRWVuaGVpZFwiLFxuXHRcdGludGVycG9sYXRpb25DZWxsc2l6ZU5hbWU6IFwiSW50ZXJwb2xhdGllIGNlbGdyb290dGVcIixcblx0XHR2YXJpYWJsZU5hbWU6IFwiVmFyaWFiZWxlblwiLFxuXHRcdGRpbWVuc2lvbmxlc3NOYW1lOiBcIk1hYXRsb29zXCIsXG5cdFx0bWRpbURlZmluaXRpb246IFwiRm9ybWFhdGRlZmluaXRpZVwiLFxuXHRcdGRpbWVuc2lvbk5hbWU6IFwiQWZtZXRpbmdcIixcblx0XHRpdGVyYXRpb25TdGFydDogXCJCZWdpbiB2YW4gZGUgZWVyc3RlIGl0ZXJhdGllXCIsXG5cdFx0aXRlcmF0aW9uRW5kOiBcIkVpbmRlIHZhbiBkZSBlZXJzdGUgaXRlcmF0aWVcIixcblx0XHRpbnRlcnZhbFN0YXJ0OiBcIlN0YXJ0IHZhbiBpbnRlcnZhbFwiLFxuXHRcdGludGVydmFsRW5kOiBcIkVpbmRlIHZhbiBpbnRlcnZhbFwiLFxuXHRcdHN0ZXBOYW1lOiBcIlN0YXBcIixcblx0XHRyYW5nZXNOYW1lOiBcIkJlcmVpa1wiLFxuXHRcdG1pblZhbHVlOiBcIk1pbmltdW13YWFyZGVcIixcblx0XHRtYXhWYWx1ZTogXCJNYXhpbXVtd2FhcmRlXCIsXG5cdFx0Y2hhbmdlQW5hbHlzaXNSYXN0ZXJOYW1lOiBcIkFuYWx5c2VyYXN0ZXIgd2lqemlnZW5cIixcblx0XHRjaGFuZ2VUeXBlTmFtZTogXCJUeXBlIFdpanppZ2VuXCIsXG5cdFx0c2VnbWVudERhdGU6IFwiU2VnbWVudGRhdGFcIixcblx0XHRjaGFuZ2VEaXJlY3Rpb25OYW1lOiBcIlJpY2h0aW5nIHdpanppZ2VuXCIsXG5cdFx0bWF4TnVtQ2hhbmdlc05hbWU6IFwiTWF4aW1hYWwgYWFudGFsIHZlcmFuZGVyaW5nZW5cIixcblx0XHRmaWx0ZXJCeVllYXI6IFwiRmlsdGVyZW4gb3AgamFhclwiLFxuXHRcdG1pbmltdW1ZZWFyOiBcIk1pbmltdW13YWFyZGVcIixcblx0XHRtYXhpbXVtWWVhcjogXCJNYXhpbXVtd2FhcmRlXCIsXG5cdFx0ZmlsdGVyQnlEdXJhdGlvbjogXCJGaWx0ZXJlbiBvcCBkdXVyXCIsXG5cdFx0bWluaW11bUR1cmF0aW9uOiBcIk1pbmltdW1kdXVyXCIsXG5cdFx0bWF4aW11bUR1cmF0aW9uOiBcIk1heGltdW1kdXVyXCIsXG5cdFx0ZmlsdGVyQnlNYWduaXR1ZGU6IFwiRmlsdGVyZW4gb3AgbWFnbml0dWRlXCIsXG5cdFx0bWluaW11bU1hZ25pdHVkZTogXCJNaW5pbXVtbWFnbml0dWRlXCIsXG5cdFx0bWF4aW11bU1hZ25pdHVkZTogXCJNYXhpbXVtbWFnbml0dWRlXCIsXG5cdFx0ZmlsdGVyQnlTdGFydFZhbHVlOiBcIkZpbHRlcmVuIG9wIHN0YXJ0d2FhcmRlXCIsXG5cdFx0bWluaW11bVN0YXJ0VmFsdWU6IFwiTWluaW1hbGUgc3RhcnR3YWFyZGVcIixcblx0XHRtYXhpbXVtU3RhcnRWYWx1ZTogXCJNYXhpbWFsZSBzdGFydHdhYXJkZVwiLFxuXHRcdGZpbHRlckJ5RW5kVmFsdWU6IFwiRmlsdGVyZW4gb3AgZWluZHdhYXJkZVwiLFxuXHRcdG1pbmltdW1FbmRWYWx1ZTogXCJNaW5pbWFsZSBlaW5kd2FhcmRlXCIsXG5cdFx0bWF4aW11bUVuZFZhbHVlOiBcIk1heGltYWxlIGVpbmR3YWFyZGVcIixcblx0XHRtb2RlbFR5cGVOYW1lOiBcIk1vZGVsdHlwZVwiLFxuXHRcdGZyb21SYXN0ZXJOYW1lOiBcIlZhbiByYXN0ZXJcIixcblx0XHR0b1Jhc3Rlck5hbWU6IFwiTmFhciByYXN0ZXJcIixcblx0XHRjb21wdXRlQ2hhbmdlTWV0aG9kOiBcIlZlcmFuZGVyaW5nc21ldGhvZGUgYmVyZWtlbmVuXCIsXG5cdFx0ZnJvbUNsYXNzVmFsdWVzOiBcIlZhbiBrbGFzc2V3YWFyZGVuICh2b29yYmVlbGQ6IDIgNSlcIixcblx0XHR0b0NsYXNzVmFsdWVzOiBcIk5hYXIga2xhc3Nld2FhcmRlbiAodm9vcmJlZWxkOiAyIDUpXCIsXG5cdFx0a2VlcE1ldGhvZDogXCJGaWx0ZXJtZXRob2RlXCIsXG5cdFx0dXNlQ29sb3JNZXRob2Q6IFwiVHJhbnNpdGlla2xldXJlbiBiZXBhbGVuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlQmFuZHM6IFwiQmFuZGVuIHZvb3IgaGV0IGRldGVjdGVyZW4gdmFuIHdpanppZ2luZ2VuIChzdGFydGVuIGJpaiAwKVwiLFxuXHRcdHRtYXNrQmFuZHM6IFwiQmFuZGVuIHZvb3IgdGlqZGVsaWprZSBtYXNrZXJpbmcgKHN0YXJ0ZW4gYmlqIDApXCIsXG5cdFx0Y2hpU3F1YXJlZFRocmVzaG9sZDogXCJDaGkta3dhZHJhYXQgZHJlbXBlbCB2b29yIGhldCBkZXRlY3RlcmVuIHZhbiB2ZXJhbmRlcmluZ1wiLFxuXHRcdG1pbkFub21hbHk6IFwiT2JzZXJ2YXRpZXMgbWluaW11bSBvcGVlbnZvbGdlbmRlIGFub21hbGllXCIsXG5cdFx0dXBkYXRpbmdGcmVxdWVuY3k6IFwiQmlqd2Vya2VuIHZhbiBkZSBwYXNmcmVxdWVudGllIChpbiBqYXJlbilcIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvblJhc3Rlck5hbWU6IFwiUmFzdGVyIGFmc3RhbmRzYWNjdW11bGF0aWVcIixcblx0XHRjb3N0QmFja2RpcmVjdGlvblJhc3Rlck5hbWU6IFwiUmFzdGVyIHRlcnVnd2VnIG9mIHN0cm9vbXJpY2h0aW5nXCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvbk5hbWU6IFwiUmFzdGVyY29sbGVjdGllXCIsXG5cdFx0aXRlbUZ1bmN0aW9uTmFtZTogXCJJdGVtZnVuY3RpZVwiLFxuXHRcdGFnZ3JlZ2F0aW9uRnVuY3Rpb25OYW1lOiBcIkFnZ3JlZ2F0aWVmdW5jdGllXCIsXG5cdFx0cHJvY2Vzc2luZ0Z1bmN0aW9uTmFtZTogXCJWZXJ3ZXJraW5nc2Z1bmN0aWVcIixcblx0XHRhZ2dyZWdhdGlvbkRlZmluaXRpb25OYW1lOiBcIkFnZ3JlZ2F0aWVkZWZpbml0aWVcIixcblx0XHRxdWVyeUdlb21ldHJ5TmFtZTogXCJRdWVyeS1nZW9tZXRyaWVcIixcblx0XHRmYWN0b3JGdW5jdGlvblplcm9GYWN0b3I6IFwiTnVsZmFjdG9yXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25DdXRBbmdsZTogXCJTbmlqaG9la1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2lkZUZhY3RvcjogXCJaaWpmYWN0b3JcIixcblx0XHRmYWN0b3JGdW5jdGlvblNsb3BlOiBcIkhlbGxpbmdcIixcblx0XHRmYWN0b3JGdW5jdGlvbkxvd0N1dEFuZ2xlOiBcIkxhZ2Ugc25pamhvZWtcIixcblx0XHRmYWN0b3JGdW5jdGlvbkhpZ2hDdXRBbmdsZTogXCJIb2dlIHNuaWpob2VrXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3NQb3dlcjogXCJLcmFjaHQgY29zaW51c1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2VjUG93ZXI6IFwiS3JhY2h0IHNuaWpsaWpuXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZVBhdGg6IFwiVGFiZWxwYWRcIixcblx0XHRwcm9jZXNzaW5nQmFuZDogXCJWZXJ3ZXJraW5nc2JhbmRcIixcblx0XHRwcm9jZXNzaW5nQmFuZE5hbWU6IFwiTmFhbSB2ZXJ3ZXJraW5nc2JhbmRcIixcblx0XHRzbmFwcGluZ0RhdGU6IFwiU25hcHBpbmdkYXR1bVwiLFxuXHRcdG1heE51bVNlZ21lbnRzOiBcIk1heGltYWFsIGFhbnRhbCBzZWdtZW50ZW5cIixcblx0XHR2ZXJ0ZXhDb3VudE92ZXJzaG9vdDogXCJWZXJ0ZXggQ291bnQgT3ZlcnNob290XCIsXG5cdFx0c3Bpa2VUaHJlc2hvbGQ6IFwiUGlla2RyZW1wZWxcIixcblx0XHRyZWNvdmVyeVRocmVzaG9sZDogXCJIZXJzdGVsZHJlbXBlbFwiLFxuXHRcdG1pbk51bU9iczogXCJNaW5pbXVtIGFhbnRhbCBvYnNlcnZhdGllc1wiLFxuXHRcdHBWYWx1ZVRocmVzaG9sZDogXCJQLXdhYXJkZSBkcmVtcGVsXCIsXG5cdFx0YmVzdE1vZGVsUHJvcG9ydGlvbjogXCJCZXN0ZSBtb2RlbHZlcmhvdWRpbmdcIixcblx0XHRwcmV2ZW50T25lWWVhclJlY292ZXJ5OiBcIkVlbiBqYWFyIGhlcnN0ZWwgdm9vcmtvbWVuXCIsXG5cdFx0cmVjb3ZlcnlJbmNyZWFzZVRyZW5kOiBcIkhlcnN0ZWwgaGVlZnQgdG9lbmVtZW5kZSB0cmVuZFwiLFxuXHRcdG91dHB1dE90aGVyQmFuZHM6IFwiVWl0dm9lciBvdmVyaWdlIGJhbmRlblwiLFxuXHRcdHNvcnRUeXBlOiBcIlNvcnRlZXJ0eXBlXCIsXG5cdFx0bnVtYmVyT2ZSdW5zOiBcIlVpdHpldHRlbiBlbiBrcmltcGVuIHR3ZWUga2VlciB1aXR2b2VyZW5cIixcblx0XHRwZXJjZW50aWxlVmFsdWU6IFwiUGVyY2VudGllbHdhYXJkZVwiLFxuXHRcdHBlcmNlbnRpbGVJbnRlcnBvbGF0aW9uVHlwZTogXCJQZXJjZW50aWVsaW50ZXJwb2xhdGlldHlwZVwiLFxuXHRcdHJhc3RlckluZm9Qcm9wZXJ0eTogXCJFaWdlbmRvbVwiLFxuXHRcdHJhc3RlckluZm9WYWx1ZTogXCJXYWFyZGVcIixcblx0XHRyYXN0ZXJJbmZvQ29sdW1uczogXCJLb2xvbW1lblwiLFxuXHRcdHJhc3RlckluZm9Sb3dzOiBcIlJpamVuXCIsXG5cdFx0cmFzdGVySW5mb0JhbmRDb3VudDogXCJBYW50YWwgYmFuZGVuXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsU2l6ZVg6IFwiQ2VsZ3Jvb3R0ZSBYXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsU2l6ZVk6IFwiQ2VsZ3Jvb3R0ZSBZXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsVHlwZTogXCJQaXhlbHR5cGVcIixcblx0XHRyYXN0ZXJFeHRlbnRUb3A6IFwiQm92ZW5cIixcblx0XHRyYXN0ZXJFeHRlbnRCb3R0b206IFwiT25kZXJcIixcblx0XHRyYXN0ZXJFeHRlbnRMZWZ0OiBcIkxpbmtzXCIsXG5cdFx0cmFzdGVyRXh0ZW50UmlnaHQ6IFwiUmVjaHRzXCIsXG5cdFx0cmFzdGVyU3RhdGlzdGljc05vdENhbGN1bGF0ZWQ6IFwiU3RhdGlzdGlla2VuIHppam4gbmlldCBiZXJla2VuZC5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlUHJvamVjdGlvbjogXCJQcm9qZWN0aWVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlV2tpZDogXCJXS0lEXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGVzdFdraWQ6IFwiVm9yaWdlIFdLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlV2t0OiBcIldLVFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VWY3NXa2lkOiBcIlZDU1dLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0VmNzV2tpZDogXCJWb3JpZ2UgVkNTV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBdXRob3JpdHk6IFwiQXV0b3JpdGVpdFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMaW5lYXJVbml0OiBcIkxpbmVhaXJlIGVlbmhlaWRcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQW5ndWxhclVuaXQ6IFwiSG9la2lnZSBlZW5oZWlkXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUZhbHNlRWFzdGluZzogXCJGYWxzZSBlYXN0aW5nXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUZhbHNlTm9ydGhpbmc6IFwiRmFsc2Ugbm9ydGhpbmdcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQ2VudHJhbE1lcmlkaWFuOiBcIkNlbnRyYWxlIG1lcmlkaWFhblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VQcmltZU1lcmlkaWFuOiBcIk51bG1lcmlkaWFhblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTdGFuZGFyZFBhcmFsbGVsMTogXCJTdGFuZGFhcmQgcGFyYWxsZWwgMVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTdGFuZGFyZFBhcmFsbGVsMjogXCJTdGFuZGFhcmQgcGFyYWxsZWwgMlwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRpdHVkZU9mT3JpZ2luOiBcIkJyZWVkdGVncmFhZCB2YW4gb29yc3Byb25nXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUF1eGlsaWFyeVNwaGVyZVR5cGU6IFwiVHlwZSBBdXhpbGlhcnkgU3BoZXJlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZURhdHVtOiBcIkRhdHVtXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNwaGVyb2lkOiBcIkJvbHZvcm1pZ1wiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTZW1pbWFqb3JBeGlzOiBcIkhhbHZlIGxhbmdlIGFzXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNlbWltaW5vckF4aXM6IFwiSGFsdmUga29ydGUgYXNcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlSW52ZXJzZUZsYXR0ZW5pbmc6IFwiT21nZWtlZXJkZSBhZnZsYWtraW5nXCIsXG5cdFx0aW5wdXREZWZpbml0aW9uRmlsZU5hbWU6IFwiSW52b2VyZGVmaW5pdGllYmVzdGFuZFwiLFxuXHRcdGRlbGV0ZU5hbWU6IFwiVmVyd2lqZGVyZW5cIixcblx0XHRhZGRWYXJpYWJsZU5hbWU6IFwiVmFyaWFiZWxlIHRvZXZvZWdlblwiLFxuXHRcdG1heE51bVBpeGVsc1BlclNlZ21lbnQ6IFwiTWluaW11bWdyb290dGUgdmFuIHNlZ21lbnRlbiBpbiBwaXhlbHNcIixcblx0XHRmb3J3YXJkV2luZG93TmFtZTogXCJWZW5zdGVyIFZvb3J3YWFydHNcIixcblx0XHRiYWNrd2FyZFdpbmRvd05hbWU6IFwiVmVuc3RlciBBY2h0ZXJ3YWFydHNcIixcblx0XHRub0RhdGFIYW5kbGluZ05hbWU6IFwiTm9EYXRhIEhhbmRsaW5nXCIsXG5cdFx0Y2lyY3VsYXJXcmFwVmFsdWVOYW1lOiBcIldhYXJkZSBjaXJjdWxhaXJlIHdpa2tlbGluZ1wiLFxuXHRcdGZyb21DbGFzc05hbWVGaWVsZE5hbWU6IFwiVmVsZG5hYW0gdm9vciBrbGFzc2VuYWFtIGluIHZhbiByYXN0ZXJcIixcblx0XHR0b0NsYXNzTmFtZUZpZWxkTmFtZTogXCJWZWxkbmFhbSB2b29yIGtsYXNzZW5hYW0gaW4gbmFhciByYXN0ZXJcIixcblx0XHR0YXJnZXRSYXN0ZXJOYW1lOiBcIkRvZWxyYXN0ZXJcIixcblx0XHRjaXJjdWxhcldyYXBWYWx1ZTogXCJXYWFyZGUgY2lyY3VsYWlyZSB3aWtrZWxpbmdcIixcblx0XHRiYW5kSW5kZXhlc1I6IFwiUm9kZSBleHByZXNzaWVcIixcblx0XHRiYW5kSW5kZXhlc0c6IFwiR3JvZW5lIGV4cHJlc3NpZVwiLFxuXHRcdGJhbmRJbmRleGVzQjogXCJCbGF1d2UgZXhwcmVzc2llXCIsXG5cdFx0ZXhhbXBsZU5hbWU6IFwiVm9vcmJlZWxkXCIsXG5cdFx0aW5wdXROYW1lOiBcIkludm9lclwiLFxuXHRcdG91dHB1dE5hbWU6IFwiVWl0dm9lclwiLFxuXHRcdG9wdGlvbmFsTmFtZTogXCJPcHRpb25lZWxcIixcblx0XHRicm93c2VEZWZpbml0aW9uRmlsZTogXCJEZWZpbml0aWViZXN0YW5kIGJsYWRlcmVuXCIsXG5cdFx0c2VsZWN0RGVmaW5pdGlvbkZpbGU6IFwiSW52b2VyZGVmaW5pdGllYmVzdGFuZCBzZWxlY3RlcmVuXCIsXG5cdFx0aW5wdXREZWZpbml0aW9uVVJMOiBcIkRlZmluaXRpZWJlc3RhbmQgVVJMIGludm9lclwiLFxuXHRcdGVudGVyRGVmaW5pdGlvbkZpbGVVUkw6IFwiRGVmaW5pdGllYmVzdGFuZCBVUkwgaW52b2VyZW5cIixcblx0XHRicm93c2VYTUxGaWxlOiBcIlhNTC1iZXN0YW5kIGJsYWRlcmVuXCIsXG5cdFx0c2VsZWN0U3RhdHNGaWxlOiBcIlNlbGVjdGVlciBzdGF0aXN0aWVrZW4gZW4gaGlzdG9ncmFtYmVzdGFuZFwiLFxuXHRcdGVudGVyWE1MRmlsZVVSTDogXCJYTUwtYmVzdGFuZCBVUkwgaW52b2VyZW5cIixcblx0XHR4bWxGaWxlVVJMOiBcIlhNTC1iZXN0YW5kIFVSTFwiLFxuXHRcdGNpcmN1bGFyQ2FsY3VsYXRpb246IFwiQ2lyY3VsYWlyZSBzdGF0aXN0aWVrZW4gYmVyZWtlbmVuXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZTogXCJQbGFhdHNlbGlqayBvcHBlcnZsYWt0ZXR5cGVcIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyVHlwZTogXCJQYXJhbWV0ZXJ0eXBlXCIsXG5cdFx0bmVpZ2hib3Job29kRGlzdGFuY2U6IFwiQWZzdGFuZCB0b3QgZGUgYnV1cnRcIixcblx0XHR1c2VBZGFwdGl2ZU5laWdoYm9yaG9vZDogXCJHZWJydWlrIEFkYXB0aWV2ZSBidXVydFwiLFxuXHRcdG91dHB1dFNsb3BlVHlwZTogXCJNZXRpbmcgdWl0Z2FuZ3NoZWxsaW5nXCIsXG5cdFx0cHJvamVjdEF6aW11dGhzOiBcIlByb2plY3QgR2VvZGV0aXNjaGUgQXppbXV0aHNcIixcblx0XHR1c2VFcXVhdG9yaWFsQXNwZWN0OiBcIkdlYnJ1aWsgRXF1YXRvcmlhYWwgQXNwZWN0XCIsXG5cdFx0elVuaXQ6IFwiWi1FZW5oZWlkXCIsXG5cdFx0YW5hbHlzaXNNYXNrOiBcIkFuYWx5c2VtYXNrZXJcIixcblx0XHRzdGREZXZpYXRpb246IFwiU3RhbmRhYXJkZGV2aWF0aWVcIixcblx0XHRcInRydWVcIjogXCJUcnVlXCIsXG5cdFx0XCJmYWxzZVwiOiBcIkZhbHNlXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMTogXCJDdW11bGF0aWVmIGtvc3Rlbi1hZnN0YW5kcmFzdGVyIDEgaW52b2VyZW5cIixcblx0XHRjb3N0RGlzdGFuY2VSYXN0ZXIyOiBcIkN1bXVsYXRpZWYga29zdGVuLWFmc3RhbmRyYXN0ZXIgMiBpbnZvZXJlblwiLFxuXHRcdHRocmVzaG9sZDogXCJEcmVtcGVsXCIsXG5cdFx0dGhyZXNob2xkTWV0aG9kOiBcIkRyZW1wZWxtZXRob2RlXCIsXG5cdFx0ZGlyZWN0aW9uUmFzdGVyMTogXCJUZXJ1Z3dlZ3Jhc3RlciAxIGludm9lcmVuXCIsXG5cdFx0ZGlyZWN0aW9uUmFzdGVyMjogXCJUZXJ1Z3dlZ3Jhc3RlciAyIGludm9lcmVuXCIsXG5cdFx0bWF4SXRlcmF0aW9uczogXCJNYXhpbXVtYWFudGFsIGl0ZXJhdGllc1wiLFxuXHRcdGVwc2lsb246IFwiRXBzaWxvblwiXG5cdH0sXG5cdGVudW1MYWJlbHM6IHtcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVNYW51YWw6IFwiSGFuZG1hdGlnXCIsXG5cdFx0YXR0cmlidXRlVGFibGVUeXBlRXh0ZXJuYWw6IFwiRXh0ZXJuXCIsXG5cdFx0Y2xyU2NoZW1lVHlwZUNvbG9ybWFwOiBcIktsZXVybWFwXCIsXG5cdFx0Y2xyU2NoZW1lVHlwZUNvbG9yUmFtcDogXCJLbGV1cnZlcmxvb3BcIixcblx0XHRjb2xvcm1hcFR5cGVFbGV2YXRpb246IFwiSG9vZ3RlXCIsXG5cdFx0Y29sb3JtYXBUeXBlR3JheTogXCJHcmlqc1wiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkk6IFwiTkRWSVwiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkkyOiBcIk5EVkkyXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTM6IFwiTkRWSTNcIixcblx0XHRjb2xvcm1hcFR5cGVSYW5kb206IFwiV2lsbGVrZXVyaWdcIixcblx0XHRub25lOiBcIkdlZW5cIixcblx0XHRzbG9wZVR5cGVBZGp1c3RlZDogXCJHZWNvcnJpZ2VlcmRcIixcblx0XHRzbG9wZVR5cGVEZWdyZWU6IFwiR3JhYWRcIixcblx0XHRzbG9wZVR5cGVQZXJjZW50UmlzZTogXCJQcm9jZW50c3RpamdpbmdcIixcblx0XHRzbG9wZVR5cGVTY2FsZWQ6IFwiR2VzY2hhYWxkXCIsXG5cdFx0c3RyZXRjaFR5cGVNaW5NYXg6IFwiTWluTWF4XCIsXG5cdFx0c3RyZXRjaFR5cGVQZXJjZW50TWluTWF4OiBcIlByb2NlbnRNaW5NYXhcIixcblx0XHRzdHJldGNoVHlwZVNpZ21vaWQ6IFwiU2lnbW9pZGVcIixcblx0XHRzdHJldGNoVHlwZVN0ZERldjogXCJTdGREZXZcIixcblx0XHRoaWxsc2hhZGVUeXBlU2ltcGxlOiBcIlRyYWRpdGlvbmVlbFwiLFxuXHRcdGhpbGxzaGFkZVR5cGVNdWx0aWRpcmVjdGlvbmFsOiBcIk11bHRpZGlyZWN0aW9uZWVsXCIsXG5cdFx0YmFuZENvbWJvQnlOYW1lczogXCJCYW5kbmFtZW5cIixcblx0XHRiYW5kQ29tYm9CeVdhdmVsZW5ndGg6IFwiQmFuZCBnb2xmbGVuZ3RlblwiLFxuXHRcdGJhbmRDb21ib0J5SURzOiBcIkJhbmQgSUQnc1wiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uQmVzdE1hdGNoOiBcIkJlc3RlIG1hdGNoXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25GYWlsOiBcIk1pc2x1a3RcIixcblx0XHR1bml0VHlwZUNlbHNpdXM6IFwiQ2Vsc2l1c1wiLFxuXHRcdHVuaXRUeXBlQ2VudGltZXRlcnM6IFwiQ2VudGltZXRlclwiLFxuXHRcdHVuaXRUeXBlRGVjaW1ldGVyczogXCJEZWNpbWV0ZXJcIixcblx0XHR1bml0VHlwZUZhaHJlbmhlaXQ6IFwiRmFocmVuaGVpdFwiLFxuXHRcdHVuaXRUeXBlRmVldDogXCJWb2V0XCIsXG5cdFx0dW5pdFR5cGVGZWV0UGVyU2VjOiBcIlZvZXQgcGVyIHNlY29uZGUgKGZ0L3MpXCIsXG5cdFx0dW5pdFR5cGVJbmNoZXM6IFwiSW5jaFwiLFxuXHRcdHVuaXRUeXBlS2VsdmluOiBcIktlbHZpblwiLFxuXHRcdHVuaXRUeXBlS2lsb21ldGVyczogXCJLaWxvbWV0ZXJcIixcblx0XHR1bml0VHlwZUttc1BlckhvdXI6IFwiS2lsb21ldGVyIHBlciB1dXIgKGttL3UpXCIsXG5cdFx0dW5pdFR5cGVLbm90czogXCJLbm9wZW4gKGtuKVwiLFxuXHRcdHVuaXRUeXBlTWV0ZXJzOiBcIk1ldGVyXCIsXG5cdFx0dW5pdFR5cGVNZXRlcnNQZXJTZWM6IFwiTWV0ZXIgcGVyIHNlY29uZGUgKG0vcylcIixcblx0XHR1bml0VHlwZU1pbGVzOiBcIk1pamxcIixcblx0XHR1bml0VHlwZU1pbGVzUGVySG91cjogXCJNaWpsIHBlciB1dXIgKG1wdSlcIixcblx0XHR1bml0VHlwZU1pbGxpbWV0ZXJzOiBcIk1pbGxpbWV0ZXJcIixcblx0XHR1bml0VHlwZU5hdXRpY2FsTWlsZXM6IFwiWmVlbWlqbFwiLFxuXHRcdHVuaXRUeXBlWWFyZHM6IFwiWWFyZFwiLFxuXHRcdHVuaXRUeXBlRGVjaW1hbERlZ3JlZXM6IFwiRGVjaW1hbGUgZ3JhZGVuXCIsXG5cdFx0dW5pdFR5cGVQb2ludHM6IFwiUHVudGVuXCIsXG5cdFx0dW5pdFR5cGVVbmtub3duOiBcIk9uYmVrZW5kXCIsXG5cdFx0dW5pdFR5cGVTcU1hcFVuaXRzOiBcIlZpZXJrYW50ZSBrYWFydGVlbmhlZGVuXCIsXG5cdFx0dW5pdFR5cGVTcU1pbGVzOiBcIlZpZXJrYW50ZSBtaWpsXCIsXG5cdFx0dW5pdFR5cGVTcUttczogXCJWaWVya2FudGUga2lsb21ldGVyXCIsXG5cdFx0dW5pdFR5cGVBY3JlczogXCJIZWN0YXJlXCIsXG5cdFx0dW5pdFR5cGVIZWN0YXJlczogXCJIZWN0YXJlXCIsXG5cdFx0dW5pdFR5cGVTcVlhcmRzOiBcIlZpZXJrYW50ZSB5YXJkXCIsXG5cdFx0dW5pdFR5cGVTcUZ0OiBcIlZpZXJrYW50ZSB2b2V0XCIsXG5cdFx0dW5pdFR5cGVTcUluY2hlczogXCJWaWVya2FudGUgaW5jaFwiLFxuXHRcdHVuaXRUeXBlU3FNdHM6IFwiVmllcmthbnRlIG1ldGVyXCIsXG5cdFx0dW5pdFR5cGVTcUNtczogXCJWaWVya2FudGUgY2VudGltZXRlclwiLFxuXHRcdHVuaXRUeXBlU3FNbXM6IFwiVmllcmthbnRlIG1pbGxpbWV0ZXJcIixcblx0XHRjZWxsc2l6ZVR5cGVGaXJzdDogXCJFZXJzdGUgdmFuXCIsXG5cdFx0Y2VsbHNpemVUeXBlTWluOiBcIk1pbiB2YW5cIixcblx0XHRjZWxsc2l6ZVR5cGVNYXg6IFwiTWF4IHZhblwiLFxuXHRcdGNlbGxzaXplVHlwZU1lYW46IFwiR2VtaWRkZWxkZSB2YW5cIixcblx0XHRjZWxsc2l6ZVR5cGVMYXN0OiBcIkxhYXRzdGUgdmFuXCIsXG5cdFx0ZXh0ZW50VHlwZUZpcnN0OiBcIkVlcnN0ZSB2YW5cIixcblx0XHRleHRlbnRUeXBlSW50ZXJzZWN0aW9uOiBcIktydWlzcHVudCB2YW5cIixcblx0XHRleHRlbnRUeXBlVW5pb246IFwiVmVyZW5pZ2luZyB2YW5cIixcblx0XHRleHRlbnRUeXBlTGFzdDogXCJMYWF0c3RlIHZhblwiLFxuXHRcdG5vRGF0YUludGVycHJldEFueTogXCJLb210IG92ZXJlZW4gbWV0XCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QWxsOiBcIktvbXQgb3ZlcmVlbiBtZXQgYWxsZXNcIixcblx0XHRjdXJ2YXR1cmVUeXBlU3RhbmRhcmQ6IFwiU3RhbmRhYXJkXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVByb2ZpbGU6IFwiUHJvZmllbFwiLFxuXHRcdGN1cnZhdHVyZVR5cGVQbGFuZm9ybTogXCJQbGFuZm9ybVwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uSG9yaXpvbnRhbDogXCJMaWpuZGV0ZWN0aWUgaG9yaXpvbnRhYWxcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvblZlcnRpY2FsOiBcIkxpam5kZXRlY3RpZSB2ZXJ0aWNhYWxcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvbkxlZnREaWFnb25hbDogXCJMaWpuZGV0ZWN0aWUgbGlua3MgZGlhZ29uYWFsXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25SaWdodERpYWdvbmFsOiBcIkxpam5kZXRlY3RpZSByZWNodHMgZGlhZ29uYWFsXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50Tm9ydGg6IFwiT3Zlcmdhbmcgbm9vcmRcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRXZXN0OiBcIk92ZXJnYW5nIHdlc3RcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRFYXN0OiBcIk92ZXJnYW5nIG9vc3RcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRTb3V0aDogXCJPdmVyZ2FuZyB6dWlkXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50Tm9ydGhFYXN0OiBcIk92ZXJnYW5nIG5vb3JkLW9vc3RcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aFdlc3Q6IFwiT3Zlcmdhbmcgbm9vcmQtd2VzdFwiLFxuXHRcdGZpbHRlclR5cGVTbW9vdGhBcml0aG1ldGljTWVhbjogXCJWZXJzb2VwZWxpbmcgcmVrZW5rdW5kaWdlIGJldGVrZW5pc1wiLFxuXHRcdGZpbHRlclR5cGVTbW9vdGhpbmczeDM6IFwiVmVyc29lcGVsaW5nIDN4M1wiLFxuXHRcdGZpbHRlclR5cGVTbW9vdGhpbmc1eDU6IFwiVmVyc29lcGVsaW5nIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuaW5nM3gzOiBcIlZlcnNjaGVycGluZyAzeDNcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbmluZzV4NTogXCJWZXJzY2hlcnBpbmcgNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZUxhcGxhY2lhbjN4MzogXCJMYXBsYWNpYW4gM3gzXCIsXG5cdFx0ZmlsdGVyVHlwZUxhcGxhY2lhbjV4NTogXCJMYXBsYWNpYW4gNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZVNvYmVsSG9yaXpvbnRhbDogXCJTb2JlbCBIb3Jpem9udGFhbFwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbFZlcnRpY2FsOiBcIlNvYmVsIFZlcnRpY2FhbFwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuOiBcIlZlcnNjaGVycGVuXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW4yOiBcIk1lZXIgdmVyc2NoZXJwZW5cIixcblx0XHRmaWx0ZXJUeXBlUG9pbnRTcHJlYWQ6IFwiUHVudHZlcnNwcmVpZGluZ1wiLFxuXHRcdHVzZXJEZWZpbmVkOiBcIkdlYnJ1aWtlcmdlZGVmaW5pZWVyZFwiLFxuXHRcdENvbnRvdXJUeXBlTGluZXM6IFwiQ29udG91cmxpam5lblwiLFxuXHRcdENvbnRvdXJUeXBlRmlsbDogXCJDb250b3VydnVsbGluZ1wiLFxuXHRcdENvbnRvdXJUeXBlU21vb3RoT25seTogXCJBbGxlZW4gZ2xhZCBvcHBlcnZsYWtcIixcblx0XHRyYXN0ZXJpemVGaXJzdDogXCJFZXJzdGVcIixcblx0XHRyYXN0ZXJpemVMYXN0OiBcIkxhYXRzdGVcIixcblx0XHRyYXN0ZXJpemVTbWFsbGVzdDogXCJLbGVpbnN0ZVwiLFxuXHRcdHJhc3Rlcml6ZUxhcmdlc3Q6IFwiR3Jvb3RzdGVcIixcblx0XHRyZXNhbXBsaW5nVHlwZU5lYXJlc3Q6IFwiRGljaHRzdGJpanppam5kZSBCdXVyXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhcjogXCJCaWxpbmVhaXJlIEludGVycG9sYXRpZVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQ3ViaWM6IFwiS3ViaWVrZSBDb252b2x1dGllXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNYWpvcml0eTogXCJNZWVyZGVyaGVpZFwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQmlsaW5lYXJQbHVzOiBcIkJpbGluZWFpcmUgSW50ZXJwb2xhdGllIFBsdXNcIixcblx0XHRyZXNhbXBsaW5nVHlwZUdhdXNzOiBcIkdhdXNzIFZlcnZhZ2VuXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVHYXVzc1BsdXM6IFwiR2F1c3MgVmVydmFnZW4gUGx1c1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQXZlcmFnZTogXCJHZW1pZGRlbGRlXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNaW5pbXVtOiBcIk1pbmltdW1cIixcblx0XHRyZXNhbXBsaW5nVHlwZU1heGltdW06IFwiTWF4aW11bVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlVmVjdG9yQXZnOiBcIlZlY3RvcmdlbWlkZGVsZGVcIixcblx0XHRtaW5pbXVtOiBcIk1pbmltdW1cIixcblx0XHRtYXhpbXVtOiBcIk1heGltdW1cIixcblx0XHRtZWFuOiBcIk1lZGlhYW5cIixcblx0XHRzdGREZXZpYXRpb246IFwiU3RhbmRhYXJkZGV2aWF0aWVcIixcblx0XHR1dk1hZ0RpclR5cGVVVjogXCJVLVZcIixcblx0XHR1dk1hZ0RpclR5cGVNYWdEaXI6IFwiTWFnbml0dWRlcmljaHRpbmdcIixcblx0XHR1bmtub3duOiBcIk9uYmVrZW5kXCIsXG5cdFx0YW5nbGVSZWZTeXNHZW9ncmFwaGljOiBcIkdlb2dyYWZpc2NoXCIsXG5cdFx0YW5nbGVSZWZTeXNBcml0aG1ldGljOiBcIlJla2Vua3VuZGlnXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmVhcmVzdDogXCJEaWNodHN0YmlqemlqbmRlIGJ1dXJcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFCaWxpbmVhcjogXCJCaWxpbmVhaXJcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFUaW5uaW5nTGluZWFyOiBcIkxpbmVhaXJlIHZlcmR1bm5pbmdcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFUaW5uaW5nTmF0dXJhbE5laWdoYm9yOiBcIk5hdHV1cmxpamtlIGJ1dXJcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFUaW5uaW5nSURXOiBcIk9tZ2VrZWVyZGUgYWZzdGFuZCBnZXdvZ2VuXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVDb25zdGFudDogXCJDb25zdGFudGVcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZU90c3U6IFwiT3RzdVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlVHNhaTogXCJUc2FpXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVLYXB1cjogXCJLYXB1clwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlS2l0dGxlcjogXCJLaXR0bGVyXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVSb3NpbjogXCJIYXJzXCIsXG5cdFx0YXJnU3RhdHNUeXBlTWF4OiBcIkFyZyBNYXhcIixcblx0XHRhcmdTdGF0c1R5cGVNaW46IFwiQXJnIE1pblwiLFxuXHRcdGFyZ1N0YXRzVHlwZU1lZGlhbjogXCJBcmcgTWVkaWFuXCIsXG5cdFx0YXJnU3RhdHNUeXBlRHVyYXRpb246IFwiRHV1clwiLFxuXHRcdGFyaXRobWV0aWNPcFBsdXM6IFwiUGx1c1wiLFxuXHRcdGFyaXRobWV0aWNPcE1pbnVzOiBcIk1pblwiLFxuXHRcdGFyaXRobWV0aWNPcE11bHRpcGx5OiBcIlZlcm1lbmlndnVsZGlnZW5cIixcblx0XHRhcml0aG1ldGljT3BEaXZpZGU6IFwiRGVsZW4gZG9vclwiLFxuXHRcdGFyaXRobWV0aWNPcFBvd2VyOiBcIk1hY2h0XCIsXG5cdFx0YXJpdGhtZXRpY09wTW9kZTogXCJNb2R1c1wiLFxuXHRcdGNsaXBUeXBlT3V0c2lkZTogXCJLbmlwcGVuIGJ1aXRlblwiLFxuXHRcdGNsaXBUeXBlSW5zaWRlOiBcIktuaXBwZW4gYmlubmVuXCIsXG5cdFx0eWVzOiBcIkphXCIsXG5cdFx0bm86IFwiTmVlXCIsXG5cdFx0ZGVuc2l0aWVzOiBcIkRpY2h0aGVkZW5cIixcblx0XHRleHBlY3RlZENvdW50czogXCJWZXJ3YWNodGUgdGVsbGluZ2VuXCIsXG5cdFx0cGxhbmFyOiBcIlBsYW5haXJcIixcblx0XHRnZW9kZXNpYzogXCJHZW9kZXRpc2NoXCIsXG5cdFx0ZWFjaENlbGw6IFwiRWxrZSBjZWxcIixcblx0XHRlYWNoWm9uZTogXCJFbGtlIHpvbmVcIixcblx0XHRiZXN0U2luZ2xlOiBcIkJlc3RlIGVua2VsXCIsXG5cdFx0YWxsU2lnaHRsaW5lczogXCJBbGxlIHppY2h0bGlqbmVuXCIsXG5cdFx0cGVyaW1ldGVyU2lnaHRsaW5lczogXCJQZXJpbWV0ZXIgemljaHRsaWpuZW5cIixcblx0XHRmcmVxdWVuY3k6IFwiRnJlcXVlbnRpZVwiLFxuXHRcdG9ic2VydmVyczogXCJXYWFybmVtZXJzXCIsXG5cdFx0bWFqb3JpdHk6IFwiTWVlcmRlcmhlaWRcIixcblx0XHRtZWRpYW46IFwiTWVkaWFhblwiLFxuXHRcdG1pbm9yaXR5OiBcIk1pbmRlcmhlaWRcIixcblx0XHRwZXJjZW50aWxlOiBcIlBlcmNlbnRpZWxcIixcblx0XHRyYW5nZTogXCJCZXJlaWtcIixcblx0XHRzdW06IFwiU29tXCIsXG5cdFx0dmFyaWV0eTogXCJWYXJpw6t0ZWl0XCIsXG5cdFx0bmR2aTogXCJORFZJXCIsXG5cdFx0c2F2aTogXCJTQVZJXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNNZXRob2RUU0FWSTogXCJHZXRyYW5zZm9ybWVlcmRlIFNBVklcIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZE1TQVZJOiBcIkFhbmdlcGFzdGUgU0FWSVwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kU3VsdGFuOiBcIlN1bHRhbidzIGZvcm11bGVcIixcblx0XHRnZW1pOiBcIkdFTUlcIixcblx0XHRwdmk6IFwiUFZJXCIsXG5cdFx0Z3ZpOiBcIkdWSSAoTGFuZHNhdCBUTSlcIixcblx0XHR2YXJpOiBcIlZBUklcIixcblx0XHRzcjogXCJTUlwiLFxuXHRcdGduZHZpOiBcIkdORFZJXCIsXG5cdFx0bmR2aXJlOiBcIk5EVklyZVwiLFxuXHRcdHNycmU6IFwiU1JyZVwiLFxuXHRcdG10dmkyOiBcIk1UVkkyXCIsXG5cdFx0cnR2aUNvcmU6IFwiUlRWSUNvcmVcIixcblx0XHRjaXJlOiBcIkNJcmVcIixcblx0XHRjaWc6IFwiQ0lnXCIsXG5cdFx0bmR3aTogXCJORFdJXCIsXG5cdFx0ZXZpOiBcIkVWSVwiLFxuXHRcdGlyb25PeGlkZTogXCJJSnplcm94aWRlXCIsXG5cdFx0ZmVycm91c01pbmVyYWxzOiBcIklKemVyaG91ZGVuZGUgbWluZXJhbGVuXCIsXG5cdFx0Y2xheU1pbmVyYWxzOiBcIktsZWltaW5lcmFsZW5cIixcblx0XHR3bmR3aTogXCJXTkRXSVwiLFxuXHRcdGJhaTogXCJCQUlcIixcblx0XHRtbmR3aTogXCJNTkRXSVwiLFxuXHRcdG5icjogXCJOQlJcIixcblx0XHRuZGJpOiBcIk5EQklcIixcblx0XHRuZG1pOiBcIk5ETUlcIixcblx0XHRuZHNpOiBcIk5EU0lcIixcblx0XHRsb2NhbFNxdWFyZVJvb3Q6IFwiVmllcmthbnRzd29ydGVsXCIsXG5cdFx0bG9jYWxBQ29zOiBcIkFDb3NcIixcblx0XHRsb2NhbEFTaW46IFwiQVNpblwiLFxuXHRcdGxvY2FsQVRhbjogXCJBVGFuXCIsXG5cdFx0bG9jYWxBVGFuSDogXCJBVGFuSFwiLFxuXHRcdGxvY2FsQWJzOiBcIkFic1wiLFxuXHRcdGxvY2FsQml0d2lzZU5vdDogXCJCaXR3aXNlIE5vdFwiLFxuXHRcdGxvY2FsQm9vbGVhbk5vdDogXCJCb29sZWFuIE5vdFwiLFxuXHRcdGxvY2FsQ29zOiBcIkNvc1wiLFxuXHRcdGxvY2FsQ29zSDogXCJDb3NIXCIsXG5cdFx0bG9jYWxFeHA6IFwiRXhwXCIsXG5cdFx0bG9jYWxFeHAxMDogXCJFeHAxMFwiLFxuXHRcdGxvY2FsRXhwMjogXCJFeHAyXCIsXG5cdFx0bG9jYWxJbnQ6IFwiSW50XCIsXG5cdFx0bG9jYWxJc051bGw6IFwiSXMgbnVsbFwiLFxuXHRcdGxvY2FsRmxvYXQ6IFwiR2V0YWwgbWV0IGRlY2ltYWxlblwiLFxuXHRcdGxvY2FsTG46IFwiTG5cIixcblx0XHRsb2NhbExvZzEwOiBcIkxvZzEwXCIsXG5cdFx0bG9jYWxMb2cyOiBcIkxvZzJcIixcblx0XHRsb2NhbE5lZ2F0ZTogXCJPbnRrZW5uZW5cIixcblx0XHRsb2NhbFJvdW5kRG93bjogXCJOYWFyIGJlbmVkZW4gYWZyb25kZW5cIixcblx0XHRsb2NhbFJvdW5kVXA6IFwiTmFhciBib3ZlbiBhZnJvbmRlblwiLFxuXHRcdGxvY2FsU2luOiBcIlNpblwiLFxuXHRcdGxvY2FsU2luSDogXCJTaW5IXCIsXG5cdFx0bG9jYWxUYW46IFwiVGFuXCIsXG5cdFx0bG9jYWxUYW5IOiBcIlRhbkhcIixcblx0XHRsb2NhbEFDb3NIOiBcIkFDb3NIXCIsXG5cdFx0bG9jYWxBU2luSDogXCJBU2luSFwiLFxuXHRcdGxvY2FsUGx1czogXCJQbHVzXCIsXG5cdFx0bG9jYWxNaW51czogXCJNaW5cIixcblx0XHRsb2NhbFRpbWVzOiBcIkFhbnRhbCBrZWVyXCIsXG5cdFx0bG9jYWxQb3dlcjogXCJNYWNodFwiLFxuXHRcdGxvY2FsQml0d2lzZUFuZDogXCJCaXR3aXNlIGVuXCIsXG5cdFx0bG9jYWxCaXR3aXNlTGVmdFNoaWZ0OiBcIkJpdHdpc2UgdmVyc2NodWl2aW5nIGxpbmtzXCIsXG5cdFx0bG9jYWxCaXR3aXNlT3I6IFwiQml0d2lzZSBvZlwiLFxuXHRcdGxvY2FsQml0d2lzZVJpZ2h0U2hpZnQ6IFwiQml0d2lzZSB2ZXJzY2h1aXZpbmcgcmVjaHRzXCIsXG5cdFx0bG9jYWxCaXR3aXNlWG9yOiBcIkJpdHdpc2UgWG9mXCIsXG5cdFx0bG9jYWxCb29sZWFuQW5kOiBcIkJvb2xlYW4gZW5cIixcblx0XHRsb2NhbEJvb2xlYW5PcjogXCJCb29sZWFuIG9mXCIsXG5cdFx0bG9jYWxCb29sZWFuWG9yOiBcIkJvb2xlYW4gWG9mXCIsXG5cdFx0bG9jYWxEaXZpZGU6IFwiRGVsZW4gZG9vclwiLFxuXHRcdGxvY2FsRXF1YWxUbzogXCJHZWxpamsgYWFuXCIsXG5cdFx0bG9jYWxHcmVhdGVyVGhhbjogXCJHcm90ZXIgZGFuXCIsXG5cdFx0bG9jYWxHcmVhdGVyVGhhbkVxdWFsOiBcIkdyb3RlciBkYW4gb2YgZ2VsaWprIGFhblwiLFxuXHRcdGxvY2FsTGVzc1RoYW46IFwiS2xlaW5lciBkYW5cIixcblx0XHRsb2NhbExlc3NUaGFuRXF1YWw6IFwiS2xlaW5lciBkYW4gb2YgZ2VsaWprIGFhblwiLFxuXHRcdGxvY2FsTW9kOiBcIk1vZFwiLFxuXHRcdGxvY2FsTm90RXF1YWw6IFwiTmlldCBnZWxpamtcIixcblx0XHRsb2NhbEFUYW4yOiBcIkFUYW4yXCIsXG5cdFx0bG9jYWxTcXVhcmU6IFwiVmllcmthbnRcIixcblx0XHRsb2NhbFNldE51bGw6IFwiTnVsbCBpbnN0ZWxsZW5cIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkxpanN0XCIsXG5cdFx0cmVtYXBEZWZUeXBlVGFibGU6IFwiVGFiZWxcIixcblx0XHRyZW1hcFRhYmxlVHlwZVNpbXBsZTogXCJFZW52b3VkaWdcIixcblx0XHRyZW1hcFRhYmxlVHlwZUR5bmFtaWM6IFwiRHluYW1pc2NoXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVSZWFzc2lnbm1lbnQ6IFwiSGVydG9ld2lqemluZ1wiLFxuXHRcdGdlb21Db3JyZWN0aW9uQnlDb25zdFo6IFwiQ29uc3RhbnRlIFogZ2VicnVpa2VuXCIsXG5cdFx0Z2VvbUNvcnJlY3Rpb25CeURFTTogXCJERU0gZ2VicnVpa2VuXCIsXG5cdFx0cmFkYXJDYWxpYkJldGFOb3VnaHQ6IFwiQmV0YSBudWxcIixcblx0XHRyYWRhckNhbGliU2lnbWFOb3VnaHQ6IFwiU2lnbWEgbnVsXCIsXG5cdFx0cmFkYXJDYWxpYkdhbW1hTm91Z2h0OiBcIkdhbW1hIG51bFwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlTGVlOiBcIkxlZSBGaWx0ZXJcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUVuaGFuY2VkTGVlOiBcIlZlcmJldGVyZGUgTGVlIEZpbHRlclwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlRnJvc3Q6IFwiRnJvc3QtZmlsdGVyXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVLdWFuOiBcIkt1YW4tZmlsdGVyXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxNdWw6IFwiVmVybWVuaWd2dWxkaWdkIG5vaXNlXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxBZGQ6IFwiVG9lZ2V2b2VnZCBub2lzZVwiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsQWRkbk11bDogXCJUb2VnZXZvZWdkIGVuIHZlcm1lbmlndnVsZGlnZCBub2lzZVwiLFxuXHRcdG1vc2FpY09wVHlwZUZpcnN0OiBcIkVlcnN0ZVwiLFxuXHRcdG1vc2FpY09wVHlwZUxhc3Q6IFwiTGFhdHN0ZVwiLFxuXHRcdG1vc2FpY09wVHlwZU1pbjogXCJNaW5cIixcblx0XHRtb3NhaWNPcFR5cGVNYXg6IFwiTWF4XCIsXG5cdFx0bW9zYWljT3BUeXBlTWVhbjogXCJNZWRpYWFuXCIsXG5cdFx0bW9zYWljT3BUeXBlQmxlbmQ6IFwiTWVuZ3NlbFwiLFxuXHRcdG1vc2FpY09wVHlwZVN1bTogXCJTb21cIixcblx0XHRpbnRlZ2VyOiBcIkludGVnZXJcIixcblx0XHRyZnhEODogXCJEOFwiLFxuXHRcdHJmeE1GRDogXCJNRkRcIixcblx0XHRkaW5mOiBcIkRpbmZcIixcblx0XHR2ZXJ0aWNhbDogXCJWZXJ0aWNhYWxcIixcblx0XHRob3Jpem9udGFsOiBcIkhvcml6b250YWFsXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01ham9yaXR5OiBcIk1lZXJkZXJoZWlkXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01heDogXCJNYXhpbXVtXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW46IFwiTWVkaWFhblwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWRpYW46IFwiTWVkaWFhblwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW46IFwiTWluaW11bVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5vcml0eTogXCJNaW5kZXJoZWlkXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1JhbmdlOiBcIkJlcmVpa1wiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdGREZXY6IFwiU3RhbmRhYXJkZGV2aWF0aWVcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtOiBcIlNvbVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NWYXJpZXR5OiBcIlZhcmnDq3RlaXRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWFqb3JpdHlJZ25vcmVORDogXCJNZWVyZGVyaGVpZCAoTmVnZWVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWF4SWdub3JlTkQ6IFwiTWF4aW11bSAoTmVnZWVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVhbklnbm9yZU5EOiBcIkdlbWlkZGVsZGUgKE5lZ2VlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbklnbm9yZU5EOiBcIk1lZGlhYW4gKE5lZ2VlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbklnbm9yZU5EOiBcIk1pbmltdW0gKE5lZ2VlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbm9yaXR5SWdub3JlTkQ6IFwiTWluZGVyaGVpZCAoTmVnZWVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzUmFuZ2VJZ25vcmVORDogXCJSZWVrcyAoTmVnZWVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3RkRGV2SWdub3JlTkQ6IFwiU3RhbmRhYXJkYWZ3aWpraW5nIChOZWdlZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdW1JZ25vcmVORDogXCJTb20gKE5lZ2VlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1ZhcmlldHlJZ25vcmVORDogXCJWYXJpw6t0ZWl0IChOZWdlZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NUeXBlUGVyY2VudGlsZUlnbm9yZU5EOiBcIlBlcmNlbnRpZWwgKE5vRGF0YSBuZWdlcmVuKVwiLFxuXHRcdGZyb21Tb3VyY2U6IFwiVmFuIGJyb25cIixcblx0XHR0b1NvdXJjZTogXCJOYWFyIGJyb25cIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvblJnYlRvSHN2OiBcIlJHQiBuYWFyIEhTVlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uSHN2VG9SZ2I6IFwiSFNWIG5hYXIgUkdCXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVJSFM6IFwiSUhTXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVCcm92ZXk6IFwiQnJvdmV5XCIsXG5cdFx0cGFuc2hhcnBlblR5cGVFc3JpOiBcIkVzcmlcIixcblx0XHRwYW5zaGFycGVuVHlwZU1lYW46IFwiTWVkaWFhblwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlR3JhbVNjaG1pZHQ6IFwiR3JhbS1TY2htaWR0XCIsXG5cdFx0cmVjdGFuZ2xlTmVpZ2hib3Job29kOiBcIlJlY2h0aG9la1wiLFxuXHRcdGNpcmNsZU5laWdoYm9yaG9vZDogXCJDaXJrZWxcIixcblx0XHRhbm51bHVzTmVpZ2hib3Job29kOiBcIkFubnVsdXNcIixcblx0XHR3ZWRnZU5laWdoYm9yaG9vZDogXCJXZWRnZVwiLFxuXHRcdGlycmVndWxhck5laWdoYm9yaG9vZDogXCJPbnJlZ2VsbWF0aWdcIixcblx0XHR3ZWlnaHROZWlnaGJvcmhvb2Q6IFwiR2V3aWNodFwiLFxuXHRcdGZvdXI6IFwiVmllclwiLFxuXHRcdGVpZ2h0OiBcIkFjaHRcIixcblx0XHR3aXRoaW46IFwiSW5cIixcblx0XHRjcm9zczogXCJLcnVpc1wiLFxuXHRcdGFkZExpbms6IFwiVm9lZyBrb3BwZWxpbmcgdG9lXCIsXG5cdFx0bm9MaW5rOiBcIkdlZW4ga29wcGVsaW5nXCIsXG5cdFx0d2VpZ2h0ZWRNZWFuOiBcIkdld29nZW4gZ2VtaWRkZWxkZVwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNpcnJ1czogXCJMYW5kc2F0IDggQ2lycnVzXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWQ6IFwiTGFuZHNhdCA4IENpcnJ1c1wiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNsb3VkU2hhZG93OiBcIkxhbmRzYXQgOCBDbG91ZCBTaGFkb3dcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5EZXNpZ25hdGVkRmlsbDogXCJMYW5kc2F0IDggRGVzaWduYXRlZCBGaWxsXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuRHJvcHBlZEZyYW1lOiBcIkxhbmRzYXQgOCBEcm9wcGVkIEZyYW1lXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuU25vd0ljZTogXCJMYW5kc2F0IDggU25vdy9JY2VcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5UZXJyYWluT2NjbHVzaW9uOiBcIkxhbmRzYXQgOCBUZXJyYWluIE9jY2x1c2lvblwiLFxuXHRcdGxzOFFDQml0UGF0dGVyblZlZ2V0YXRpb246IFwiTGFuZHNhdCA4IFZlZ2V0YXRpb25cIixcblx0XHRsczhRQ0JpdFBhdHRlcm5XYXRlcjogXCJMYW5kc2F0IDggV2F0ZXJcIixcblx0XHRkb3duU3RyZWFtOiBcIkRvd25zdHJlYW1cIixcblx0XHR1cFN0cmVhbTogXCJVcHN0cmVhbVwiLFxuXHRcdHN0cmFobGVyOiBcIlNUUkFITEVSXCIsXG5cdFx0c2hyZXZlOiBcIlNIUkVWRVwiLFxuXHRcdGN1cnJlbnRTbGljZTogXCJIdWlkaWdlIGRvb3JzbmVkZVwiLFxuXHRcdGFsbFNsaWNlczogXCJBbGxlIGRvb3JzbmVkZXNcIixcblx0XHRleHBhbmREaXN0YW5jZTogXCJBRlNUQU5EXCIsXG5cdFx0ZXhwYW5kTW9ycGhvbG9naWNhbDogXCJNT1JGT0xPR0lTQ0hcIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlOiBcIlNwZWN0cmFhbCBwcm9maWVsXCIsXG5cdFx0dHJhaW5pbmdGZWF0dXJlRmlsZTogXCJPcGxlaWRpbmdzb2JqZWN0XCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVVuaWZvcm06IFwiVW5pZm9ybVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVVbmlmb3JtSW50ZWdlcjogXCJHZWhlZWwgZ2V0YWxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlTm9ybWFsOiBcIk5vcm1hYWxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlRXhwb25lbnRpYWw6IFwiRXhwb25lbnRpZWVsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVBvaXNzb246IFwiUG9pc3NvblwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVHYW1tYTogXCJHYW1tYVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVCaW5vbWlhbDogXCJCaW5vbWlhYWxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlR2VvbWV0cmljOiBcIkdlb21ldHJpc2NoXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZU5lZ2F0aXZlQmlub21pYWw6IFwiTmVnYXRpZXZlIGJpbm9taWFhbFwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVTdGFuZGFyZENSYW5kOiBcIlN0YW5kYWFyZCBDIFJhbmRcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlQWxnb3JpdGhtQUNNNTk5OiBcIkFDTSB2ZXJ6YW1lbGQgYWxnb3JpdG1lIDU5OVwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVNZXJzZW5uZVR3aXN0ZXI6IFwiTWVyc2VubmUgVHdpc3RlclwiLFxuXHRcdHN1bU5hbWU6IFwiU29tXCIsXG5cdFx0bWVkYWluTmFtZTogXCJNZWRpYWFuXCIsXG5cdFx0dHJlbmRMaW5lYXI6IFwiTGluZWFpclwiLFxuXHRcdHRyZW5kSGFybW9uaWM6IFwiSGFybW9uaXNjaFwiLFxuXHRcdHRyZW5kUG9seW5vbWlhbDogXCJQb2x5bm9taWFhbFwiLFxuXHRcdHRyZW5kTWFubktlbmRhbGw6IFwiTWFubi1LZW5kYWxsXCIsXG5cdFx0dHJlbmRTZWFzb25hbEtlbmRhbGw6IFwiU2Vhc29uYWwtS2VuZGFsbFwiLFxuXHRcdGRpbWVuc2lvbkJ5VmFsdWU6IFwiT3Agd2FhcmRlXCIsXG5cdFx0ZGltZW5zaW9uQnlJbnRlcnZhbDogXCJPcCBpbnRlcnZhbFwiLFxuXHRcdG1kaW1EZWZUeXBlQWxsOiBcIkFsbGVcIixcblx0XHRtZGltRGVmVHlwZUJ5VmFsdWVzOiBcIk9wIHdhYXJkZW5cIixcblx0XHRtZGltRGVmVHlwZUJ5UmFuZ2VzOiBcIk9wIGJlcmVpa1wiLFxuXHRcdG1kaW1EZWZUeXBlQnlJdGVyYXRpb246IFwiT3AgaXRlcmF0aWVcIixcblx0XHRtZGltRGVmVHlwZUJ5SW50ZXJ2YWw6IFwiT3AgaW50ZXJ2YWxcIixcblx0XHRtZGltRGVmVHlwZUJ5VGFyZ2V0UmFzdGVyOiBcIk9wIGRvZWxyYXN0ZXJcIixcblx0XHRlc3JpVGltZVVuaXRzSG91cnM6IFwiVXJlblwiLFxuXHRcdGVzcmlUaW1lVW5pdHNEYXlzOiBcIkRhZ2VuXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1dlZWtzOiBcIldla2VuXCIsXG5cdFx0ZXNyaVRpbWVVbml0c01vbnRoczogXCJNYWFuZGVuXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1llYXJzOiBcIkphcmVuXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRIb3VybHk6IFwiRWxrIHV1clwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkRGFpbHk6IFwiRGFnZWxpamtzXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRXZWVrbHk6IFwiV2VrZWxpamtzXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmREZWthZGx5OiBcIkRla2FkbHlcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFBlbnRhZGx5OiBcIlBlbnRhZGx5XCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRNb250aGx5OiBcIk1hYW5kZWxpamtzXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRRdWFydGVybHk6IFwiUGVyIGt3YXJ0YWFsXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRZZWFybHk6IFwiSmFhcmxpamtzXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdEYWlseTogXCJEYWdlbGlqa3MgdGVydWdrZXJlbmRcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1dlZWtseTogXCJXZWtlbGlqa3MgdGVydWdrZXJlbmRcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ01vbnRobHk6IFwiTWFhbmRlbGlqa3MgdGVydWdrZXJlbmRcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1F1YXJ0ZXJseTogXCJFbGsga3dhcnRhYWwgdGVydWdrZXJlbmRcIixcblx0XHRhZ2dEZWZUeXBlQWxsOiBcIkFsbGVcIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxLZXl3b3JkOiBcIkludGVydmFsdHJlZndvb3JkXCIsXG5cdFx0YWdnRGVmVHlwZUludGVydmFsVmFsdWU6IFwiSW50ZXJ2YWx3YWFyZGVcIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxSYW5nZXM6IFwiSW50ZXJ2YWxiZXJlaWtlblwiLFxuXHRcdGxhdGVzdENoYW5nZTogXCJUaWpkIHZhbiBkZSBsYWF0c3RlIHZlcmFuZGVyaW5nXCIsXG5cdFx0ZWFybGllc3RDaGFuZ2U6IFwiVGlqZCB2YW4gZGUgdnJvZWdzdGUgdmVyYW5kZXJpbmdcIixcblx0XHRsYXJnZXN0Q2hhbmdlOiBcIlRpamQgdmFuIGRlIGdyb290c3RlIHZlcmFuZGVyaW5nXCIsXG5cdFx0bnVtYmVyT2ZDaGFuZ2VzOiBcIkFhbnRhbCB3aWp6aWdpbmdlblwiLFxuXHRcdGxvbmdlc3RDaGFuZ2U6IFwiVGlqZCB2YW4gbGFuZ3N0ZSB3aWp6aWdpbmdcIixcblx0XHRzaG9ydGVzdENoYW5nZTogXCJUaWpkIHZhbiBrb3J0c3RlIHdpanppZ2luZ1wiLFxuXHRcdGZhc3Rlc3RDaGFuZ2U6IFwiVGlqZCB2YW4gc25lbHN0ZSB3aWp6aWdpbmdcIixcblx0XHRzbG93ZXN0Q2hhbmdlOiBcIlRpamQgdmFuIGxhbmd6YWFtc3RlIHdpanppZ2luZ1wiLFxuXHRcdGFsbENoYW5nZXM6IFwiQWxsZVwiLFxuXHRcdGluY3JlYXNlQ2hhbmdlczogXCJWZXJncm90ZW5cIixcblx0XHRkZWNyZWFzZUNoYW5nZXM6IFwiVmVya2xlaW5lblwiLFxuXHRcdHNlZ21lbnRCZWdpbm5pbmc6IFwiQmVnaW4gdmFuIHNlZ21lbnRcIixcblx0XHRzZWdtZW50RW5kOiBcIkVpbmQgdmFuIHNlZ21lbnRcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZERpZmZlcmVuY2U6IFwiVmVyc2NoaWxcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZFJlbGF0aXZlRGlmZmVyZW5jZTogXCJSZWxhdGllZiB2ZXJzY2hpbFwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kQ2F0ZWdvcmljYWw6IFwiQ2F0ZWdvcmlzY2ggdmVyc2NoaWxcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxFdWNsaWRlYW5EaXN0YW5jZTogXCJTcGVjdHJhbGUgRXVjbGlkaXNjaGUgYWZzdGFuZFwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEFuZ3VsYXJEaWZmZXJlbmNlOiBcIlNwZWN0cmFhbCBob2VrdmVyc2NoaWxcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBeGlzV2l0aEJpZ2dlc3RDaGFuZ2U6IFwiQmFuZCBtZXQgbWVlc3RlIHZlcmFuZGVyaW5nXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwQWxsOiBcIkFsbGVzIGJlaG91ZGVuXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwQ2hhbmdlZE9ubHk6IFwiRW5rZWwgZ2V3aWp6aWdkZSBwaXhlbHMgYmVob3VkZW5cIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBVbmNoYW5nZWRPbmx5OiBcIkVua2VsIG9uZ2V3aWp6aWdkZSBwaXhlbHMgYmVob3VkZW5cIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yQXZlcmFnZTogXCJHZW1pZGRlbGRlIHZhbiBlbiBuYWFyIGtsZXVyZW5cIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yRnJvbTogXCJHZWJydWlrZW4gdmFuIGtsZXVyZW5cIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yVG86IFwiR2VicnVpa2VuIG5hYXIga2xldXJlblwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQmluYXJ5OiBcIkJpbmFpclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uRm9yd2FyZDogXCJWb29yd2FhcnRzXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25MaW5lYXI6IFwiTGluZWFpclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSW52TGluZWFyOiBcIk9tZ2VrZWVyZCBMaW5lYWlyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZTogXCJUYWJlbFwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU3ltTGluZWFyOiBcIlN5bW1ldHJpc2NoIGxpbmVhaXJcIixcblx0XHRmYWN0b3JGdW5jdGlvblN5bUludkxpbmVhcjogXCJTeW1tZXRyaXNjaCBvbWdla2VlcmQgbGluZWFpclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zOiBcIkNvc2ludXNcIixcblx0XHRmYWN0b3JGdW5jdGlvblNlYzogXCJTbmlqbGlqblwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zU2VjOiBcIkNvc2ludXMgc25pamxpam5cIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY0NvczogXCJTbmlqbGlqbiBjb3NpbnVzXCIsXG5cdFx0bm9Tb3J0OiBcIk5pZXQgc29ydGVyZW5cIixcblx0XHRhc2NlbmQ6IFwiT3Bsb3BlbmRcIixcblx0XHRkZXNjZW5kOiBcIkFmbG9wZW5kXCIsXG5cdFx0YXV0b0RldGVjdDogXCJBdXRvLWRldGVjdFwiLFxuXHRcdG5lYXJlc3Q6IFwiRGljaHRzdGJpanppam5kZVwiLFxuXHRcdGxpbmVhcjogXCJMaW5lYWlyXCIsXG5cdFx0ZXNyaU1vbnRoSmFudWFyeTogXCJKYW51YXJpXCIsXG5cdFx0ZXNyaU1vbnRoRmVicnVhcnk6IFwiRmVicnVhcmlcIixcblx0XHRlc3JpTW9udGhNYXJjaDogXCJNYWFydFwiLFxuXHRcdGVzcmlNb250aEFwcmlsOiBcIkFwcmlsXCIsXG5cdFx0ZXNyaU1vbnRoTWF5OiBcIk1laVwiLFxuXHRcdGVzcmlNb250aEp1bmU6IFwiSnVuaVwiLFxuXHRcdGVzcmlNb250aEp1bHk6IFwiSnVsaVwiLFxuXHRcdGVzcmlNb250aEF1Z3VzdDogXCJBdWd1c3R1c1wiLFxuXHRcdGVzcmlNb250aFNlcHRlbWJlcjogXCJTZXB0ZW1iZXJcIixcblx0XHRlc3JpTW9udGhPY3RvYmVyOiBcIk9rdG9iZXJcIixcblx0XHRlc3JpTW9udGhOb3ZlbWJlcjogXCJOb3ZlbWJlclwiLFxuXHRcdGVzcmlNb250aERlY2VtYmVyOiBcIkRlY2VtYmVyXCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdJZ25vcmVOb0RhdGE6IFwiR2VnZXZlbnNcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1Byb3BhZ2F0ZU5vRGF0YTogXCJOb0RhdGFcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ0ZpbGxPbmx5Tm9EYXRhOiBcIk5vRGF0YSBpbnZ1bGxlblwiLFxuXHRcdGNpcmN1bGFyTWVhbjogXCJDaXJjdWxhaXIgZ2VtaWRkZWxkZVwiLFxuXHRcdGNpcmN1bGFyTmFtZTogXCJDaXJjdWxhaXJcIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJSZWtlbmt1bmRpZ1wiLFxuXHRcdHNsb3BlTmFtZTogXCJIZWxsaW5nXCIsXG5cdFx0YXNwZWN0TmFtZTogXCJBc3BlY3RcIixcblx0XHRtZWFuQ3VydmF0dXJlOiBcIkdlbWlkZGVsZGUga3JvbW1pbmdcIixcblx0XHRwcm9maWxlQ3VydmF0dXJlOiBcIlByb2ZpZWwgKG5vcm1hbGUgaGVsbGluZ3NsaWpuKSBrcm9tbWluZ1wiLFxuXHRcdHRhbmdlbnRpYWxDdXJ2YXR1cmU6IFwiVGFuZ2VudGnDq2xlIChub3JtYWxlIGNvbnRvdXIpIGtyb21taW5nXCIsXG5cdFx0cGxhbkN1cnZhdHVyZTogXCJQbGFuIChnZXByb2plY3RlZXJkZSBjb250b3VyKSBrcm9tbWluZ1wiLFxuXHRcdGNvbnRvdXJHZW9kZXNpY1RvcnNpb246IFwiQ29udG91ciBnZW9kZXRpc2NoZSB0b3JzaWVcIixcblx0XHRnYXVzc2lhbkN1cnZhdHVyZTogXCJHYXVzc2lhYW5zZSBrcm9tbWluZ1wiLFxuXHRcdGNhc29yYXRpQ3VydmF0dXJlOiBcIkNhc29yYXRpIGtyb21taW5nXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZVF1YWRyYXRpYzogXCJRdWFkcmF0aWNcIixcblx0XHRsb2NhbFN1cmZhY2VUeXBlQmlxdWFkcmF0aWM6IFwiQmlxdWFkcmF0aWNcIixcblx0XHR0aHJlc2hvbGROb1RocmVzaG9sZDogXCJHZWVuIGRyZW1wZWxcIixcblx0XHR0aHJlc2hvbGRQZXJjZW50TGVhc3RDb3N0OiBcIlBlcmNlbnRhZ2UgdmFuIGdvZWRrb29wc3RlXCIsXG5cdFx0dGhyZXNob2xkQWNjdW11bGF0aXZlQ29zdDogXCJDdW11bGF0aWV2ZSBrb3N0ZW5cIixcblx0XHRjbHJtYXBUeXBlSGlsbHNoYWRlOiBcIkJlcmdzY2hhZHV3ZW5cIlxuXHR9LFxuXHRjYXRlZ29yeUxhYmVsczoge1xuXHRcdHNvdXJjZUNoYXJhY3RlcmlzdGljczogXCJCcm9ua2VubWVya2VuXCIsXG5cdFx0bmVpZ2hib3Job29kU2V0dGluZ3M6IFwiQnV1cnRpbnN0ZWxsaW5nZW5cIixcblx0XHRzdGF0aXN0aWNzOiBcIlN0YXRpc3RpZWtlblwiLFxuXHRcdGdhbW1hOiBcIkdhbW1hXCIsXG5cdFx0dmlld3NoZWRQYXJhbWV0ZXJzOiBcIlZpZXdzaGVkLXBhcmFtZXRlcnNcIixcblx0XHRvYnNlcnZlclBhcmFtZXRlcnM6IFwiT2JzZXJ2ZXItcGFyYW1ldGVyc1wiLFxuXHRcdGlycmVndWxhckRhdGFJbnRlcnBvbGF0aW9uOiBcIk9ucmVnZWxtYXRpZ2UgZ2VnZXZlbnNpbnRlcnBvbGF0aWVcIixcblx0XHRtb2RlbFN0YXRpc3RpY3M6IFwiTW9kZWxzdGF0aXN0aWVrZW5cIixcblx0XHRhZ2dyZWdhdGlvbkRlZjogXCJBZ2dyZWdhdGllZGVmaW5pdGllXCIsXG5cdFx0ZmlsdGVyQnlBdHRyaWJ1dGVzOiBcIkZpbHRlcmVuIG9wIGF0dHJpYnV0ZW5cIixcblx0XHRwZXJjZW50aWxlTmFtZTogXCJQZXJjZW50aWVsXCIsXG5cdFx0cmFzdGVySW5mbzogXCJSYXN0ZXJpbmZvcm1hdGllXCIsXG5cdFx0ZXh0ZW50OiBcIkV4dGVudFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2U6IFwiUnVpbXRlbGlqa2UgcmVmZXJlbnRpZVwiXG5cdH0sXG5cdG91dHB1dFJhc3RlckhlbHBUZXh0czoge1xuXHRcdG91dHB1dE5hbWU6IFwiPHA+RGUgbmFhbSB2YW4gZGUgbGFhZyBkaWUgd29yZHQgYWFuZ2VtYWFrdCBlbiB0b2VnZXZvZWdkIGFhbiBkZSBrYWFydC48L3A+XCIsXG5cdFx0cmVzdWx0VHlwZTogXCI8cD5IZXQgdHlwZSBvdXRwdXQgZGF0IHdvcmR0IGdlbWFha3QuIERlIHVpdHZvZXIga2FuIGJlc3RhYW4gdWl0IGdldGVnZWxkZSBiZWVsZGxhZ2VuIG9mIGR5bmFtaXNjaGUgYmVlbGRsYWdlbi48L3A+XCIsXG5cdFx0c2F2ZVJlc3VsdEluOiBcIjxwPkRlIG5hYW0gdmFuIGRlIG1hcCBpbiA8Yj5NaWpuIGNvbnRlbnQ8L2I+IHdhYXIgaGV0IHJlc3VsdGFhdCB3b3JkdCBvcGdlc2xhZ2VuLjwvcD5cIlxuXHR9LFxuXHRhbmFseXNpc0Vudmlyb25tZW50c0hlbHBUZXh0czoge1xuXHRcdGRlc2NyaXB0aW9uOiBcIjxwPk9tZ2V2aW5nc2luc3RlbGxpbmdlbiB2b29yIGFuYWx5c2UgaW4gTWFwIFZpZXdlci4gPC9wPlwiLFxuXHRcdG91dFNSOiBcIjxwPlNwZWNpZmljZWVydCBoZXQgY2/DtnJkaW5hdGVuc3lzdGVlbSB2b29yIGRlIGFuYWx5c2UgZW4gZGUgcmVzdWx0YWF0bGFhZy48L3A+XCIsXG5cdFx0ZXh0ZW50OiBcIjxwPlNwZWNpZmljZWVydCB2b29yIGRlIGFuYWx5c2UgdGUgZ2VicnVpa2VuIGdlYmllZC48L3A+XCIsXG5cdFx0c25hcFJhc3RlcjogXCI8cD5QYXN0IGRlIGV4dGVudCB2YW4gZGUgdWl0dm9lciBhYW4gem9kYXQgZGV6ZSBvdmVyZWVua29tdCBtZXQgZGUgY2VsdWl0bGlqbmluZyB2YW4gZGUgb3BnZWdldmVuIHNuYXByYXN0ZXJsYWFnLjwvcD5cIixcblx0XHRjZWxsU2l6ZTogXCI8cD5CZXBhYWx0IGRlIGNlbGdyb290dGUgb2YgcmVzb2x1dGllIGRpZSB3b3JkdCBnZWJydWlrdCB2b29yIGRlIGFuYWx5c2UgZW4gb20gZGUgdWl0dm9lcnJhc3RlcmxhYWcgdGUgbWFrZW4uPC9wPlwiLFxuXHRcdG1hc2s6IFwiPHA+U3BlY2lmaWNlZXJ0IGVlbiBtYXNrZXJsYWFnIHdhYXJpbiBhbGxlZW4gZGUgY2VsbGVuIGRpZSBiaW5uZW4gaGV0IG1hc2tlcmdlYmllZCB2YWxsZW4gdm9vciBkZSBhbmFseXNlIHdvcmRlbiBnZWJydWlrdC48L3A+XCIsXG5cdFx0cmVzYW1wbGluZ01ldGhvZDogXCI8cD5TcGVjaWZpY2VlcnQgaG9lIHBpeGVsd2FhcmRlbiBtb2V0ZW4gd29yZGVuIGdlw69udGVycG9sZWVyZCB3YW5uZWVyIGRlIGludm9lci0gZW4gdWl0dm9lcnJhc3RlcnMgbmlldCBvcCDDqcOpbiBsaWpuIGxpZ2dlbi48L3A+XCJcblx0fSxcblx0bWFpbkdlblN0cmluZ3M6IHtcblx0XHR1bnN1cHBvcnRlZERhdGFUeXBlOiBcIk5pZXQtb25kZXJzdGV1bmQgdHlwZVwiLFxuXHRcdGN1cnJlbnRseVVuc3VwcG9ydGVkOiBcIiBFciB3b3JkdCBnZXdlcmt0IGFhbiBlZW4gc3RhbmRhYXJkLWVkaXRvciB2b29yIGRlICR7bWlzc2luZ1R5cGV9OyBkZXplIGlzIGJpbm5lbmtvcnQgYmVzY2hpa2JhYXIuIFRpamRlbGlqa2UgcGxhYXRzaG91ZGVyIHZvb3IgdGVrc3R2YWsgdm9vciBoZXQgc3BlY2lmaWNlcmVuIHZhbiBvcCB0ZWtlbnJlZWtzZW4gZ2ViYXNlZXJkZSBpbnZvZXIuXCIsXG5cdFx0dW5zdXBwb3J0ZWRPdmVycmlkZVdhcm5pbmc6IFwiRXIgaXMgYmlubmVua29ydCBlZW4gb3ZlcnNjaHJpanZpbmdzb25kZXJkZWVsIGJlc2NoaWtiYWFyIHZvb3IgZGUgZWRpdG9yLCBkYXQgZWVuIGJldGVyZSBVWCBiaWVkdCB2b29yIHdlcmsgbWV0IGRlIHZvbGdlbmRlIHBhcmFtZXRlcihzKTpcIixcblx0XHRvdmVycmlkZVdpZGdldE1pc3Npbmc6IFwiT3ZlcnNjaHJpanZpbmdzb25kZXJkZWVsIGVkaXRvciBvbnRicmVla3QhXCIsXG5cdFx0dWlJbmNvbXBsZXRlOiBcIlRhYWtpbmRpZW5pbmcgaXMgbWlzbHVrdC4gRGUgZnVuY3RpZSBrYW4gbmlldCB3b3JkZW4gdWl0Z2V2b2VyZCBvbWRhdCBlZW4gYWFudGFsIHZhbiBkZSB2ZXJlaXN0ZSB2ZWxkZW4gb252b2xsZWRpZyBpcyBvZiBvbnRicmVla3QgaW4gZGUgVUkuXCIsXG5cdFx0Y291bnQ6IFwiQWFudGFsXCIsXG5cdFx0c2VsZWN0VmFyaWFibGVzOiBcIlZhcmlhYmVsZW4gc2VsZWN0ZXJlblwiLFxuXHRcdHNlbGVjdEZlYXR1cmU6IFwiRmVhdHVyZSBsYXllciBzZWxlY3RlcmVuXCIsXG5cdFx0Z3JlYXRlclRoYW5FcnJvck1lc3NhZ2U6IFwiRGUgaW52b2Vyd2FhcmRlIG1vZXQgZ3JvdGVyIHppam4gZGFuICR7bWlufVwiLFxuXHRcdGxlc3NlclRoYW5FcnJvck1lc3NhZ2U6IFwiRGUgaW52b2Vyd2FhcmRlIG1vZXQga2xlaW5lciB6aWpuIGRhbiAke21heH1cIixcblx0XHRncmVhdGVyVGhhbk9yRXF1YWxFcnJvck1lc3NhZ2U6IFwiRGUgaW52b2Vyd2FhcmRlIG1vZXQgZ3JvdGVyIGRhbiBvZiBnZWxpamsgemlqbiBhYW4gJHttaW59XCIsXG5cdFx0bGVzc2VyVGhhbk9yRXF1YWxFcnJvck1lc3NhZ2U6IFwiRGUgaW52b2Vyd2FhcmRlIG1vZXQga2xlaW5lciBkYW4gb2YgZ2VsaWprIHppam4gYWFuICR7bWF4fVwiLFxuXHRcdGFsbG93U2NhbGFyOiBcIlNlbGVjdGVlciBlZW4gbGFhZyBvZiB2b2VyIGVlbiBjb25zdGFudGUgaW5cIixcblx0XHRzZWxlY3RGaWVsZDogXCJWZWxkIHNlbGVjdGVyZW5cIixcblx0XHRwYXJhbWV0ZXJSZXF1aXJlZDogXCJEZXplIHBhcmFtZXRlciBpcyB2ZXJlaXN0LlwiLFxuXHRcdGVudGVyQVZhbHVlOiBcIlZvZXIgZWVuIHdhYXJkZSBpbi4uLlwiLFxuXHRcdGludmFsaWRJbnB1dDogXCJEZSBpbmdldm9lcmRlIHdhYXJkZSBpcyBuaWV0IGdlbGRpZy5cIixcblx0XHRpdGVtTm90Rm91bmQ6IFwiSGV0IGl0ZW0gYmVzdGFhdCBuaWV0IG9mIGlzIG5pZXQgdG9lZ2Fua2VsaWprLlwiLFxuXHRcdGl0ZW1QZXJtaXNzaW9uRGVuaWVkOiBcIlUgaGVlZnQgZ2VlbiB0b2VnYW5nc21hY2h0aWdpbmdlbiB2b29yIGRpdCBpdGVtLlwiLFxuXHRcdGxheWVyTm90QXZhaWxhYmxlOiBcIkthYXJ0bGFhZyBsYWRlbiBtaXNsdWt0ICR7bGF5ZXJOYW1lfS5cIixcblx0XHRtdWx0aXBsZUxheWVyc05vdEF2YWlsYWJsZTogXCJLYWFydGxhYWcgJHtsYXllck5hbWV9IGVuIGFuZGVyZSBsYWRlbiBtaXNsdWt0LlwiLFxuXHRcdGxlYXJuTW9yZUxhYmVsOiBcIk1lZXIgaW5mb3JtYXRpZVwiLFxuXHRcdGZpZWxkTm90QXZhaWxhYmxlOiBcIlZlbGQgbGFkZW4gbWlzbHVrdC5cIixcblx0XHRhbGxvd0FuYWx5c2lzOiBcIkFuYWx5c2UgaXMgbmlldCB0b2VnZXN0YWFuIG9wIGRlIGltYWdlIHNlcnZpY2UuXCIsXG5cdFx0YWxsb3dBbmFseXNpc1JlYXNvbjogXCJFZW4gb2YgbWVlciBsYWdlbiB2YW4gZGUga2FhcnQgemlqbiBoaWVyIG5pZXQgb3BnZW5vbWVuIG9tZGF0IHplIGdlZW4gYW5hbHlzZSBtb2dlbGlqayBtYWtlbi5cIixcblx0XHRsZWFybk1vcmVUZXh0OiBcIk1lZXIgaW5mb3JtYXRpZVwiLFxuXHRcdGF0TGVhc3RPbmVSYXN0ZXJJbnB1dDogXCJUZW4gbWluc3RlIMOpw6luIGludm9lcmxhYWcgbW9ldCBlZW4gcmFzdGVybGFhZyB6aWpuLlwiLFxuXHRcdGJyb3dzZUFuYWx5c2lzTGF5ZXJzOiBcIkJsYWRlciBkb29yIGxhZ2VuXCIsXG5cdFx0YWN0aXZlTWFwVmlld0V4dGVudDogXCJIdWlkaWdlIGV4dGVudCB2YW4gZGUga2FhcnQgZ2VicnVpa2VuXCIsXG5cdFx0Y2hvb3NlUmFzdGVyOiBcIlJhc3RlciBrbmlwcGVuIGtpZXplblwiLFxuXHRcdGNob29zZUdlb21ldHJ5OiBcIkdlb21ldHJpZSBiaWpzbmlqZGVuIGtpZXplblwiLFxuXHRcdHJlc3VsdFR5cGU6IFwiUmVzdWx0YWF0dHlwZVwiLFxuXHRcdHNhdmVJbkZvbGRlcjogXCJPcHNsYWFuIGluIG1hcFwiLFxuXHRcdG91dHB1dE5hbWU6IFwiVWl0dm9lcm5hYW1cIixcblx0XHRvdXRwdXRMYXllclR5cGU6IFwiVWl0dm9lciBrYWFydGxhYWd0eXBlXCIsXG5cdFx0ZHluYW1pY0ltYWdlcnlMYXllcjogXCJEeW5hbWlzY2hlIGltYWdlcnkgbGF5ZXJcIixcblx0XHR0aWxlZEltYWdlcnlMYXllcjogXCJUaWxlZCBpbWFnZXJ5IGxheWVyXCIsXG5cdFx0Y3VzdG9tOiBcIkFhbmdlcGFzdFwiLFxuXHRcdGxvYWRpbmc6IFwiQmV6aWcgbWV0IGxhZGVuLi4uXCIsXG5cdFx0bGF5ZXJNaXNzaW5nOiBcIkVlbiBvZiBtZWVyIGxhZ2VuIHZhbiBkZSBrYWFydCB3b3JkZW4gaGllciBuaWV0IHZlcm1lbGQgb21kYXQgZGFhcmluIGdlZW4gYW5hbHlzZSBpcyB0b2VnZXN0YWFuLiBNZWVyIGluZm9ybWF0aWUuXCIsXG5cdFx0YnJvd3NlQ29vcmRpbmF0ZVN5c3RlbXM6IFwiQ2/DtnJkaW5hdGVuc3lzdGVtZW4gZG9vcmJsYWRlcmVuXCIsXG5cdFx0dW5hYmxlVG9SZXBvcHVsYXRlT3V0U1I6IFwiS2FuIHVpdHZvZXJjb8O2cmRpbmF0ZW5zeXN0ZWVtIG5pZXQgaW52dWxsZW4uXCIsXG5cdFx0ZGVmYXVsdFRpdGxlOiBcIk1lZXIgYmVraWprZW5cIixcblx0XHRcIkFSQyAoZXF1YWwgYXJjLXNlY29uZClcIjogXCJBUkMgKGdlbGlqa2UgYm9vZ3NlY29uZGUpXCIsXG5cdFx0QWZyaWNhOiBcIkFmcmlrYVwiLFxuXHRcdEFudGFyY3RpY2E6IFwiQW50YXJjdGljYVwiLFxuXHRcdEFyZ2VudGluYTogXCJBcmdlbnRpbmnDq1wiLFxuXHRcdEFzaWE6IFwiQXppw6tcIixcblx0XHRcIkFzdGVyb2lkIEJlbHRcIjogXCJBc3Rlcm/Dr2RlbmdvcmRlbFwiLFxuXHRcdFwiQXRsYW50aWMgT2NlYW5cIjogXCJBdGxhbnRpc2NoZSBPY2VhYW5cIixcblx0XHRBdXN0cmFsaWE6IFwiQXVzdHJhbGnDq1wiLFxuXHRcdFwiQXVzdHJhbGlhIGFuZCBOZXcgWmVhbGFuZFwiOiBcIkF1c3RyYWxpw6sgZW4gTmlldXctWmVlbGFuZFwiLFxuXHRcdEF1c3RyaWE6IFwiT29zdGVucmlqa1wiLFxuXHRcdFwiQkxNIChVUyBGZWV0KVwiOiBcIkJMTSAoVVMgRmVldClcIixcblx0XHRCYW5nbGFkZXNoOiBcIkJhbmdsYWRlc2hcIixcblx0XHRcIkJlaWppbmcgMTk1NFwiOiBcIkJlaWppbmcgMTk1NFwiLFxuXHRcdEJodXRhbjogXCJCaHV0YW5cIixcblx0XHRDR0NTMjAwMDogXCJDR0NTMjAwMFwiLFxuXHRcdENhbmFkYTogXCJDYW5hZGFcIixcblx0XHRDYXJpYmJlYW46IFwiQ2FyaWJpc2NoIGdlYmllZFwiLFxuXHRcdFwiQ2FyaWJiZWFuIFNlYVwiOiBcIkNhcmliaXNjaGUgemVlXCIsXG5cdFx0XCJDZW50cmFsIEFtZXJpY2FcIjogXCJNaWRkZW4tQW1lcmlrYVwiLFxuXHRcdFwiQ2VudHJhbCBhbmQgTm9ydGggQW1lcmljYVwiOiBcIk1pZGRlbi0gZW4gTm9vcmQtQW1lcmlrYVwiLFxuXHRcdENvbG9tYmlhOiBcIkNvbG9tYmlhXCIsXG5cdFx0Q29udGluZW50YWw6IFwiQ29udGluZW50YWFsXCIsXG5cdFx0XCJDb3VudHkgU3lzdGVtc1wiOiBcIkNvdW50eSBTeXN0ZW1zXCIsXG5cdFx0XCJEZW1vY3JhdGljIFJlcHVibGljIG9mIHRoZSBDb25nb1wiOiBcIkRlbW9jcmF0aXNjaGUgUmVwdWJsaWVrIENvbmdvXCIsXG5cdFx0XCJFUFNHIEFyY3RpY1wiOiBcIkVQU0cgQXJjdGljXCIsXG5cdFx0RWFydGg6IFwiQWFyZGVcIixcblx0XHRcIkVsbGlwc29pZGFsLWJhc2VkXCI6IFwiRWxsaXBzb8OvZGFhbFwiLFxuXHRcdEV1cm9wZTogXCJFdXJvcGFcIixcblx0XHRGaW5sYW5kOiBcIkZpbmxhbmRcIixcblx0XHRGcmFuY2U6IFwiRnJhbmtyaWprXCIsXG5cdFx0XCJHU0sgMjAxMVwiOiBcIkdTSyAyMDExXCIsXG5cdFx0XCJHYXVzcyBLcnVnZXJcIjogXCJHYXVzcyBLcnVnZXJcIixcblx0XHRcIkdlb2dyYXBoaWMgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiR2VvZ3JhZmlzY2hlIGNvw7ZyZGluYXRlbnN5c3RlbWVuXCIsXG5cdFx0R2VybWFueTogXCJEdWl0c2xhbmRcIixcblx0XHRcIkdyYXZpdHktcmVsYXRlZFwiOiBcIlp3YWFydGVrcmFjaHRnZXJlbGF0ZWVyZGVcIixcblx0XHRcIkdyZWVud2ljaC1iYXNlZFwiOiBcIkdyZWVud2ljaC1nZWJhc2VlcmRcIixcblx0XHRcIkhpZ2h3YXlzIEVuZ2xhbmRcIjogXCJTbmVsd2VnZW4gRW5nZWxhbmRcIixcblx0XHRJbGxpbm9pczogXCJJbGxpbm9pc1wiLFxuXHRcdFwiSW5kaWFuIE9jZWFuXCI6IFwiSW5kaXNjaGUgT2NlYWFuXCIsXG5cdFx0XCJJbmRpYW4gU3ViY29udGluZW50XCI6IFwiSW5kaXNjaCBzdWJjb250aW5lbnRcIixcblx0XHRJbmRpYW5hOiBcIkluZGlhbmFcIixcblx0XHRJbmRvbmVzaWE6IFwiSW5kb25lc2nDq1wiLFxuXHRcdElvd2E6IFwiSW93YVwiLFxuXHRcdFwiSXJlbGFuZCBhbmQgVW5pdGVkIEtpbmdkb21cIjogXCJJZXJsYW5kIGVuIFZlcmVuaWdkIEtvbmlua3JpamtcIixcblx0XHRJdGFseTogXCJJdGFsacOrXCIsXG5cdFx0SmFwYW46IFwiSmFwYW5cIixcblx0XHRKdXBpdGVyOiBcIkp1cGl0ZXJcIixcblx0XHRLYW5zYXM6IFwiS2Fuc2FzXCIsXG5cdFx0XCJMYXMgVmVnYXNcIjogXCJMYXMgVmVnYXNcIixcblx0XHRMaWJ5YTogXCJMaWJpw6tcIixcblx0XHRNYWxheXNpYTogXCJNYWxlaXNpw6tcIixcblx0XHRcIk1hbGF5c2lhIGFuZCBTaW5nYXBvcmVcIjogXCJNYWxlaXNpw6sgZW4gU2luZ2Fwb3JlXCIsXG5cdFx0TWFyczogXCJNYXJzXCIsXG5cdFx0TWVyY3VyeTogXCJNZXJjdXJpdXNcIixcblx0XHRNaW5uZXNvdGE6IFwiTWlubmVzb3RhXCIsXG5cdFx0TW9udGFuYTogXCJNb250YW5hXCIsXG5cdFx0XCJOQUQgMTkyN1wiOiBcIk5BRCAxOTI3XCIsXG5cdFx0XCJOQUQgMTkyNyAoVVMgRmVldClcIjogXCJOQUQgMTkyNyAoVVMgRmVldClcIixcblx0XHRcIk5BRCAxOTgzXCI6IFwiTkFEIDE5ODNcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKVwiOiBcIk5BRCAxOTgzICgyMDExKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKDIwMTEpIChJbnRsIEZlZXQpXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSkgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoMjAxMSkgKE1ldGVycylcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoMjAxMSkgKFVTIEZlZXQpXCIsXG5cdFx0XCJOQUQgMTk4MyAoQ09SUzk2KSAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzIChDT1JTOTYpIChJbnRsIEZlZXQpXCIsXG5cdFx0XCJOQUQgMTk4MyAoQ09SUzk2KSAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIChDT1JTOTYpIChNZXRlcnMpXCIsXG5cdFx0XCJOQUQgMTk4MyAoQ09SUzk2KSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAoVVMgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKEludGwgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKE1ldGVycylcIixcblx0XHRcIk5BRCAxOTgzIChQQTExKSAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIChQQTExKSAoTWV0ZXJzKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChQQTExKSAoVVMgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChVUyBGZWV0KVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzIEhBUk4gKEludGwgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIEhBUk4gKE1ldGVycylcIjogXCJOQUQgMTk4MyBIQVJOIChNZXRlcnMpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIEhBUk4gKFVTIEZlZXQpXCIsXG5cdFx0XCJOQUQgMTk4MyBOU1JTMjAwNyAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzIE5TUlMyMDA3IChJbnRsIEZlZXQpXCIsXG5cdFx0XCJOQUQgMTk4MyBOU1JTMjAwNyAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIE5TUlMyMDA3IChNZXRlcnMpXCIsXG5cdFx0XCJOQUQgMTk4MyBOU1JTMjAwNyAoVVMgRmVldClcIjogXCJOQUQgMTk4MyBOU1JTMjAwNyAoVVMgRmVldClcIixcblx0XHRcIk5hdGlvbmFsIEdyaWRzXCI6IFwiTmF0aW9uYWwgR3JpZHNcIixcblx0XHROYXZham86IFwiTmF2YWpvXCIsXG5cdFx0TmVwdHVuZTogXCJOZXB0dW51c1wiLFxuXHRcdFwiTmV3IEJlaWppbmdcIjogXCJOZXcgQmVpamluZ1wiLFxuXHRcdFwiTmV3IFplYWxhbmRcIjogXCJOaWV1dy1aZWVsYW5kXCIsXG5cdFx0XCJOb3J0aCBBbWVyaWNhXCI6IFwiTm9vcmQtQW1lcmlrYVwiLFxuXHRcdFwiTm9ydGhlcm4gSGVtaXNwaGVyZVwiOiBcIk5vb3JkZWxpamsgaGFsZnJvbmRcIixcblx0XHROb3J3YXk6IFwiTm9vcndlZ2VuXCIsXG5cdFx0T2NlYW5zOiBcIk9jZWFuZW5cIixcblx0XHRPcmVnb246IFwiT3JlZ29uXCIsXG5cdFx0XCJPdGhlciBHQ1NcIjogXCJPdmVyaWcgR0NTXCIsXG5cdFx0XCJQYWNpZmljIE9jZWFuXCI6IFwiU3RpbGxlIE9jZWFhblwiLFxuXHRcdFBsdXRvOiBcIlBsdXRvXCIsXG5cdFx0UG9sYXI6IFwiUG9sYWlyXCIsXG5cdFx0UG9ydHVnYWw6IFwiUG9ydHVnYWxcIixcblx0XHRcIlByb2plY3RlZCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJHZXByb2plY3RlZXJkZSBjb8O2cmRpbmF0ZW5zeXN0ZW1lblwiLFxuXHRcdFwiUHVsa292byAxOTQyXCI6IFwiUHVsa292byAxOTQyXCIsXG5cdFx0XCJQdWxrb3ZvIDE5OTVcIjogXCJQdWxrb3ZvIDE5OTVcIixcblx0XHRSZXBsYWNlZDogXCJWZXJ2YW5nZW5cIixcblx0XHRcIlNBRCAxOTY5XCI6IFwiU0FEIDE5NjlcIixcblx0XHRTSVJHQVM6IFwiU0lSR0FTXCIsXG5cdFx0XCJTSVJHQVMgMjAwMFwiOiBcIlNJUkdBUyAyMDAwXCIsXG5cdFx0U2F0dXJuOiBcIlNhdHVybnVzXCIsXG5cdFx0XCJTb2xhciBTeXN0ZW1cIjogXCJab25uZXN0ZWxzZWxcIixcblx0XHRcIlNvdXRoIEFmcmljYVwiOiBcIlp1aWQtQWZyaWthXCIsXG5cdFx0XCJTb3V0aCBBbWVyaWNhXCI6IFwiWnVpZC1BbWVyaWthXCIsXG5cdFx0XCJTb3V0aCBLb3JlYVwiOiBcIlp1aWQtS29yZWFcIixcblx0XHRcIlNvdXRoZXJuIEhlbWlzcGhlcmVcIjogXCJadWlkZWxpamsgaGFsZnJvbmRcIixcblx0XHRcIlNwaGVyb2lkLWJhc2VkXCI6IFwiU2Zlcm/Dr2RhYWxcIixcblx0XHRcIlN0YXRlIFBsYW5lXCI6IFwiU3RhYXRzdmxha1wiLFxuXHRcdFwiU3RhdGUgU3lzdGVtc1wiOiBcIlN0YWF0c3N5c3RlbWVuXCIsXG5cdFx0U3dlZGVuOiBcIlp3ZWRlblwiLFxuXHRcdFwiU3dpdHplcmxhbmQgYW5kIExpZWNodGVuc3RlaW5cIjogXCJad2l0c2VybGFuZCBlbiBMaWVjaHRlbnN0ZWluXCIsXG5cdFx0VGV4YXM6IFwiVGV4YXNcIixcblx0XHRUcmliYWw6IFwiVHJpYmFsXCIsXG5cdFx0VHVya2V5OiBcIlR1cmtpamVcIixcblx0XHRcIlVTIEZlZXRcIjogXCJVUyBGZWV0XCIsXG5cdFx0XCJVU0EgYW5kIHRlcnJpdG9yaWVzXCI6IFwiVVNBIGVuIGdlYmllZGVuXCIsXG5cdFx0VVRNOiBcIlVUTVwiLFxuXHRcdFVrcmFpbmU6IFwiT2VrcmHDr25lXCIsXG5cdFx0XCJVbmtub3duIEhlaWdodCBTeXN0ZW1zXCI6IFwiT25iZWtlbmRlIGhvb2d0ZXN5c3RlbWVuXCIsXG5cdFx0VXJhbnVzOiBcIlVyYW51c1wiLFxuXHRcdFZlbnVzOiBcIlZlbnVzXCIsXG5cdFx0XCJWZXJ0aWNhbCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJWZXJ0aWNhbGUgY2/DtnJkaW5hdGVuc3lzdGVtZW5cIixcblx0XHRWaWV0bmFtOiBcIlZpZXRuYW1cIixcblx0XHRcIldHUyAxOTcyXCI6IFwiV0dTIDE5NzJcIixcblx0XHRcIldHUyAxOTg0XCI6IFwiV0dTIDE5ODRcIixcblx0XHRXaXNjb25zaW46IFwiV2lzY29uc2luXCIsXG5cdFx0XCJXaXNjb25zaW4gQ1JTXCI6IFwiV2lzY29uc2luIENSU1wiLFxuXHRcdFdvcmxkOiBcIldlcmVsZFwiLFxuXHRcdFwiV29ybGQgKFNwaGVyZS1iYXNlZClcIjogXCJXZXJlbGQgKG9wIGJvbGJhc2lzKVwiLFxuXHRcdFd5b21pbmc6IFwiV3lvbWluZ1wiLFxuXHRcdFwiWGlhbiAxOTgwXCI6IFwiWGlhbiAxOTgwXCIsXG5cdFx0ZG9uZTogXCJHZXJlZWRcIixcblx0XHRub1Jlc3VsdHM6IFwiS2FuIGdlZW4gcmVzdWx0YXRlbiB2aW5kZW5cIixcblx0XHRzZWFyY2hQbGFjZWhvbGRlcjogXCJOYWFtIG9mIFdLSURcIixcblx0XHRicm93c2VUZW1wbGF0ZTogXCJEb29yIHJhc3RlcmZ1bmN0aWVzamFibG9uZW4gYmxhZGVyZW5cIixcblx0XHRzYXZlVGVtcGxhdGU6IFwiUmFzdGVyZnVuY3RpZXNqYWJsb29uIG9wc2xhYW5cIixcblx0XHRwcmV2aWV3OiBcIlZvb3JiZWVsZFwiLFxuXHRcdHByZXZpZXdEZXNjcmlwdGlvbjogXCJHZWVmIGVlbiB2b29yYmVlbGQgd2VlciB2b29yZGF0IGRlIGFuYWx5c2Ugd29yZHQgdWl0Z2V2b2VyZC5cIixcblx0XHRzaG93UHJldmlldzogXCJWb29yYmVlbGQgd2VlcmdldmVuXCIsXG5cdFx0cHJldmlld0xheWVyOiBcIlZvb3JiZWVsZCBsYWFnICR7bnVtYmVyfVwiLFxuXHRcdG5ld1ByZXZpZXc6IFwiTmlldXcgdm9vcmJlZWxkXCIsXG5cdFx0cHJldmlld1BvcHVwOiBcIlNjaGFrZWwgaGV0IHZvb3JiZWVsZCB2YW4gZGUgYW5hbHlzZXJlc3VsdGF0ZW4gaW4gb3AgYmFzaXMgdmFuIGRlIGludm9lcnBhcmFtZXRlcnMuXCIsXG5cdFx0dXBkYXRlUHJldmlld0xheWVyOiBcIkdlc2VsZWN0ZWVyZGUgdm9vcmJlZWxkbGFhZyB1cGRhdGVuXCIsXG5cdFx0Y3JlYXRlUHJldmlld0xheWVyOiBcIk5pZXV3ZSB2b29yYmVlbGRsYWFnIG1ha2VuXCIsXG5cdFx0bWF4aW11bVByZXZpZXdBbGxvd2VkOiBcIk1heGltdW1hYW50YWwgdG9lZ2VzdGFuZSB2b29yYmVlbGRsYWdlbjogJHttYXhDb3VudH1cIixcblx0XHRwcmV2aWV3RmFpbHVyZTogXCJEZXplIHZvb3JiZWVsZGxhYWcgaXMgbmlldCBiZXNjaGlrYmFhci4gQ29udHJvbGVlciBkZSBpbnZvZXJwYXJhbWV0ZXJzIGVuIHdlcmsgZGUgdm9vcmJlZWxkbGFhZyBvcG5pZXV3IGJpai5cIixcblx0XHRoZWFkZXI6IFwiSXRlbSBzZWxlY3RlcmVuXCIsXG5cdFx0Y29udGVudDogXCJFciB6aWpuIG5pZXQtb3BnZXNsYWdlbiB3aWp6aWdpbmdlbiBpbiAke3JmdFRpdGxlfS4gQWxzIHUgb3BuaWV1dyBiZWdpbnQgbWV0IGVlbiBuaWV1d2Ugc2phYmxvb24sIGdhYW4gYWwgZGllIHdpanppZ2luZ2VuIHZlcmxvcmVuLlwiLFxuXHRcdGRvbnRTYXZlOiBcIk5pZXQgb3BzbGFhblwiLFxuXHRcdFwiY29udGludWVcIjogXCJEb29yZ2FhblwiLFxuXHRcdHN0cmV0Y2g6IFwiQWFucGFzc2VuIGFhbiB2ZW5zdGVyXCIsXG5cdFx0cGFuOiBcIlBhbm5lblwiLFxuXHRcdG5ld1RlbXBsYXRlOiBcIk5pZXV3ZSBzamFibG9vbiBtYWtlblwiLFxuXHRcdG9wZW5UZW1wbGF0ZTogXCJTamFibG9vbiBvcGVuZW5cIixcblx0XHRhZGRGdW5jdGlvbjogXCJSYXN0ZXJmdW5jdGllcyB0b2V2b2VnZW5cIixcblx0XHRhZGRDb25zdGFudDogXCJDb25zdGFudGUgdG9ldm9lZ2VuXCIsXG5cdFx0YWRkUmFzdGVyOiBcIlJhc3RlcnZhcmlhYmVsZSB0b2V2b2VnZW5cIixcblx0XHRtb3ZlOiBcIlZlcnBsYWF0c2VuXCIsXG5cdFx0em9vbTogXCJab29tZW5cIixcblx0XHRzYXZlQXM6IFwiT3BzbGFhbiBhbHNcIixcblx0XHRjbGVhcjogXCJXaXNzZW5cIixcblx0XHRhZGRSYXN0ZXJGdW5jdGlvblRpdGxlOiBcIlJhc3RlcmZ1bmN0aWVzIHRvZXZvZWdlblwiLFxuXHRcdHRlbXBsYXRlUHJvcGVydGllc1RpdGxlOiBcIkVpZ2Vuc2NoYXBwZW4gc2phYmxvb25cIixcblx0XHRicm93c2VSRlQ6IFwiRG9vciByYXN0ZXJmdW5jdGllc2phYmxvbmVuIGJsYWRlcmVuXCIsXG5cdFx0ZGVmYXVsdFRvb2xEZXNjcmlwdGlvbjogXCIke3Rvb2xUaXRsZX0gYW5hbHlzZXRvb2wuXCIsXG5cdFx0b3BlblRvb2xUZXh0OiBcIlRvb2wgb3BlbmVuXCIsXG5cdFx0dG9vbERyb3Bkb3duVGV4dDogXCJUb29sIHZlcnZvbGdrZXV6ZWxpanN0XCIsXG5cdFx0YWRkVG9NYXA6IFwiQmV2ZXN0aWdlbiBlbiBhYW4ga2FhcnQgdG9ldm9lZ2VuXCIsXG5cdFx0Y29uZmlybTogXCJCZXZlc3RpZ2VuXCIsXG5cdFx0c2VsZWN0OiBcIlNlbGVjdGVyZW5cIixcblx0XHRzZWxlY3RUYXNrOiBcIlRhYWsgc2VsZWN0ZXJlblwiLFxuXHRcdHVuc3VwcG9ydGVkTGF5ZXI6IFwiRGV6ZSBwYXJhbWV0ZXIgYmllZHQgZ2VlbiBvbmRlcnN0ZXVuaW5nIHZvb3IgZGUgdm9sZ2VuZGUga2FhcnRsYWdlbjogJHtsYXllck5hbWV9LlwiLFxuXHRcdHZpZXdEZXRhaWxzOiBcIlZvbGxlZGlnZSBpdGVtZGV0YWlscyBiZWtpamtlblwiLFxuXHRcdHJlbmFtZTogXCJOYWFtIHdpanppZ2VuXCIsXG5cdFx0ZHVwbGljYXRlOiBcIkR1cGxpY2VyZW5cIixcblx0XHRsYXVuY2g6IFwiT3BlbmVuIHZvb3IgdWl0dm9lcmluZ1wiLFxuXHRcdHRlbXBsYXRlRWRpdG9yOiBcIlNqYWJsb29uZWRpdG9yXCIsXG5cdFx0Y3JlYXRlSXRlbTogXCJSYXN0ZXJmdW5jdGllc2phYmxvb24gb3BzbGFhblwiLFxuXHRcdGFjdGlvbkxhYmVsOiBcIkZpbHRlcmVuXCIsXG5cdFx0ZmlsdGVyUG9wb3ZlckhlYWRpbmc6IFwiRGUgZnVuY3RpZXMgZmlsdGVyZW5cIixcblx0XHRkZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXI6IFwiT3AgbmFhbSB6b2VrZW5cIixcblx0XHRzZXR0aW5nczogXCJJbnN0ZWxsaW5nZW5cIixcblx0XHRzdW1tYXJ5OiBcIlNhbWVudmF0dGluZ1wiLFxuXHRcdGRlZmluaXRpb25RdWVyeTogXCJEZWZpbml0aWVxdWVyeVwiLFxuXHRcdG1hdGNoVmFyaWFibGVzOiBcIk92ZXJlZW5rb21zdHZhcmlhYmVsZW5cIixcblx0XHR1bmlvbkRpbWVuc2lvbjogXCJTYW1lbnZvZWdpbmdzYWZtZXRpbmdcIixcblx0XHRuYW1lRWRpdG9yUGxhY2Vob2xkZXI6IFwiVGl0ZWwgaW52b2VyZW5cIixcblx0XHRzdW1tYXJ5RWRpdG9yUGxhY2Vob2xkZXI6IFwiVm9lciBlZW4ga29ydGUgYmVzY2hyaWp2aW5nIGluLlwiLFxuXHRcdGRlZmluaXRpb25RdWVyeVBsYWNlaG9sZGVyOiBcIkludm9lcmVuLi4uXCIsXG5cdFx0dXBsb2FkOiBcIlVwbG9hZGVuXCIsXG5cdFx0Y2hvb3NlSW1hZ2U6IFwiS2xpayBvbSBlZW4gYmVzdGFuZCB0ZSBraWV6ZW5cIixcblx0XHR1cGRhdGU6IFwiQmlqd2Vya2VuXCIsXG5cdFx0dGh1bWJuYWlsRXJyb3JzOiB7XG5cdFx0XHR3cm9uZ0ltYWdlVHlwZTogXCJWZXJrZWVyZCBiZWVsZHR5cGUgZ2VzZWxlY3RlZXJkXCIsXG5cdFx0XHRub3RBdmFpbGFibGU6IFwiVGh1bWJuYWlsIGlzIG5pZXQgYmVzY2hpa2JhYXJcIixcblx0XHRcdGxvYWRFcnJvcjogXCJLYW4gYWZiZWVsZGluZyBuaWV0IGxhZGVuXCIsXG5cdFx0XHRjaG9vc2VGaWxlOiBcIktsaWsgb20gYmVzdGFuZCB0ZSBraWV6ZW5cIlxuXHRcdH1cblx0fVxufTtcbmNvbnN0IGNvcHkgPSBcIktvcGnDq3JlblwiO1xuY29uc3Qgc2F2ZSA9IFwiT3BzbGFhblwiO1xuY29uc3QgdGl0bGUgPSBcIlRpdGVsXCI7XG5jb25zdCBmb2xkZXIgPSBcIkZvbGRlclwiO1xuY29uc3QgdGFncyA9IFwiTGFiZWxzXCI7XG5jb25zdCBzYXZpbmdNZXNzYWdlID0gXCJJdGVtIG9wc2xhYW4gaW5cIjtcbmNvbnN0IHNoYXJlV2l0aCA9IFwiRGVsZW4gbWV0XCI7XG5jb25zdCBzaGFyZSA9IFwiRGVsZW5cIjtcbmNvbnN0IHNldFNoYXJpbmdMZXZlbCA9IFwiRGVlbG5pdmVhdSBpbnN0ZWxsZW5cIjtcbmNvbnN0IHNldEdyb3VwU2hhcmluZyA9IFwiR3JvZXAgZGVsZW4gaW5zdGVsbGVuXCI7XG5jb25zdCBvd25lciA9IFwiRWlnZW5hYXJcIjtcbmNvbnN0IG9yZ2FuaXphdGlvbiA9IFwiT3JnYW5pc2F0aWVcIjtcbmNvbnN0IGV2ZXJ5b25lID0gXCJJZWRlcmVlbiAob3BlbmJhYXIpXCI7XG5jb25zdCBncm91cHMgPSBcIkdyb2VwZW46XCI7XG5jb25zdCB0eXBlID0gXCJUeXBlXCI7XG5jb25zdCBtb3NhaWMgPSBcIk1vemHDr2VrXCI7XG5jb25zdCBpdGVtR3JvdXAgPSBcIkl0ZW1ncm9lcFwiO1xuY29uc3QgaXRlbSA9IFwiSXRlbVwiO1xuY29uc3QgZGVmaW5pdGlvblF1ZXJ5ID0gXCJEZWZpbml0aW9uIFF1ZXJ5XCI7XG5jb25zdCBncm91cEl0ZW1zQnkgPSBcIkl0ZW1zIGdyb2VwZXJlbiBvcFwiO1xuY29uc3QgZ3JvdXBGaWVsZE5hbWUgPSBcIlZlbGRuYWFtIGdyb2VwZXJlblwiO1xuY29uc3QgdGFnRmllbGROYW1lID0gXCJWZWxkbmFhbSB0YWdnZW5cIjtcbmNvbnN0IG5vVGl0bGVUYWdFcnJvck1zZyA9IFwiVSBtb2V0IGVlbiB0aXRlbCBlbiB0YWdzIG9wZ2V2ZW4gdm9vciB1dyBpdGVtIHpvZGF0IGVyIG5hYXIgdXcga2FhcnQga2FuIHdvcmRlbiBnZXpvY2h0LlwiO1xuY29uc3Qgbm9UaXRsZUVycm9yTXNnID0gXCJVIG1vZXQgZWVuIHRpdGVsIG9wZ2V2ZW4gdm9vciB1dyBpdGVtLlwiO1xuY29uc3Qgbm9UYWdFcnJvck1zZyA9IFwiVSBtb2V0IG1pbmltYWFsIMOpw6luIHRhZyBvcGdldmVuIHpvZGF0IHV3IGl0ZW0ga2FuIHdvcmRlbiBnZXZvbmRlbiB2aWEgem9la2FjdGllcy5cIjtcbmNvbnN0IGVycm9yID0gXCJGb3V0XCI7XG5jb25zdCB3YXJuaW5nID0gXCJXYWFyc2NodXdpbmdcIjtcbmNvbnN0IHN1Y2Nlc3MgPSBcIlN1Y2Nlc1wiO1xuY29uc3QgZGV0YWlscyA9IFwiRGV0YWlsczpcIjtcbmNvbnN0IHRyeUFnYWluID0gXCJPcG5pZXV3IHByb2JlcmVuXCI7XG5jb25zdCB0b29sTW9kZWxlciA9IHtcblx0c2F2ZTogXCJPcHNsYWFuXCIsXG5cdGVkaXRQcm9wZXJ0aWVzOiBcIkVpZ2Vuc2NoYXBwZW4gYmV3ZXJrZW5cIixcblx0c2F2ZUFzOiBcIk9wc2xhYW4gYWxzXCIsXG5cdHNhdmluZ05vdGlmaWNhdGlvbjogXCJXaWp6aWdpbmdlbiBpbiBpdGVtIG9wc2xhYW4gLi4uXCIsXG5cdHNhdmluZ1RpdGxlOiBcIk9wc2xhYW5cIixcblx0c2F2ZUZhaWxlZE1lc3NhZ2U6IFwid2lqemlnaW5nZW4gb3BzbGFhbiBtaXNsdWt0LlwiLFxuXHRzYXZlV2l0aEVycm9yc01lc3NhZ2U6IFwiV2lqemlnaW5nZW4gemlqbiBvcGdlc2xhZ2VuIG1ldCBkZSB2b2xnZW5kZSBmb3V0ZW4uXCIsXG5cdHZpZXdJdGVtTWVzc2FnZTogXCJCZWtpamsgaGV0IG9wZ2VzbGFnZW4gaXRlbVwiLFxuXHRoZXJlOiBcImhlcmUuXCIsXG5cdGl0ZW1DcmVhdGVkTWVzc2FnZTogXCJFciBpcyBlZW4gbmlldXcgaXRlbSBnZW1hYWt0LlwiLFxuXHRjbGlja1RvVmlld0l0ZW1NZXNzYWdlOiBcIktsaWsgb3AgT0sgb20gZGUgcGFnaW5hIG1ldCBpdGVtZGV0YWlscyB3ZWVyIHRlIGdldmVuOyBrbGlrIG9wIEFubnVsZXJlbiBvbSBkb29yIHRlIGdhYW4uXCIsXG5cdHJlYWRpbmdGYWlsZWQ6IFwiRGUgZ2VzZWxlY3RlZXJkZSByYXN0ZXJmdW5jdGlldGVtcGxhdGUga29uIG5pZXQgd29yZGVuIGdlbGFkZW4uXCIsXG5cdGZhaWxlZFRvTG9hZFhNTDogXCJEZSBnZXNlbGVjdGVlcmRlIHJhc3RlcmZ1bmN0aWV0ZW1wbGF0ZSBrb24gbmlldCB3b3JkZW4gZ2VsYWRlbiBpbiBYTUwtZm9ybWFhdC5cIixcblx0bGVhcm5Nb3JlOiBcIk1lZXIgaW5mb3JtYXRpZVwiLFxuXHRvdmVyd3JpdGVUaXRsZTogXCJPdmVyc2NocmlqdmVuIGJldmVzdGlnZW5cIixcblx0b3ZlcndyaXRlTWVzc2FnZTogXCJXaWx0IHUgaGV0IGJlc3RhYW5kZSBpdGVtIG92ZXJzY2hyaWp2ZW4/XCIsXG5cdG92ZXJ3cml0ZVN1Y2Nlc3NNZXNzYWdlOiBcIkhldCBpdGVtIGlzIGJpamdld2Vya3QuXCJcbn07XG5jb25zdCB0b29sRWRpdG9yID0ge1xuXHRydW46IFwiVWl0dm9lcmVuXCIsXG5cdHNhdmU6IFwiT3BzbGFhblwiLFxuXHRkZWxldGVTZWxlY3RlZDogXCJWZXJ3aWpkZXIgZ2VzZWxlY3RlZXJkZSBpdGVtc1wiLFxuXHRhZGRSYXN0ZXI6IFwiUmFzdGVyIHRvZXZvZWdlblwiLFxuXHRhZGRTY2FsYXI6IFwiU2NhbGFpciB0b2V2b2VnZW5cIixcblx0bGF5b3V0OiBcIkF1dG9tYXRpc2NoZSBsYXktb3V0XCIsXG5cdGVycm9yVGl0bGU6IFwiRm91dFwiLFxuXHRpbnZhbGlkVG9vbE1lc3NhZ2U6IFwiUmFzdGVyZnVuY3RpZXRlbXBsYXRlIGlzIG5pZXQgZ2VsZGlnLlwiLFxuXHRvdXQ6IFwiVWl0XCIsXG5cdHpvb21JbjogXCJab29tIEluXCIsXG5cdHpvb21PdXQ6IFwiWm9vbSBPdXRcIixcblx0em9vbVRvRml0OiBcIkFhbnBhc3NlbiBhYW4gdmVuc3RlclwiLFxuXHRwYW5PbjogXCJPbXNjaGFrZWxlbiBuYWFyIHBhbm1vZHVzXCIsXG5cdHBhbk9mZjogXCJQYW5tb2R1cyB1aXRzY2hha2VsZW5cIixcblx0ZGVmYXVsdE1vZGVsTmFtZTogXCJUb29sbW9kZWxcIixcblx0ZGVmYXVsdFJhc3Rlck5hbWU6IFwiUmFzdGVyXCJcbn07XG5jb25zdCB0b29sRGV0YWlsc0VkaXRvciA9IHtcblx0ZGVmYXVsdFRvb2xOYW1lOiBcIlRlbXBsYXRlIHJhc3RlcmZ1bmN0aWVcIixcblx0ZGVmYXVsdFRvb2xEZXNjcmlwdGlvbjogXCJWb2VnIGVlbiBrb3J0ZSBzYW1lbnZhdHRpbmcgb3ZlciBkZSByYXN0ZXJmdW5jdGllIHRvZS5cIixcblx0ZGVmYXVsdEhlbHBUZXh0OiBcIktsaWsgb3AgaGV0IEhlbHAtcGljdG9ncmFtIG9tIGRlIGhlbHB0ZWtzdCB0ZSBiZXdlcmtlbi5cIixcblx0ZWRpdEhlbHBUaXRsZTogXCJIZWxwIGJld2Vya2VuXCIsXG5cdHNhdmVMYWJlbDogXCJPcHNsYWFuXCIsXG5cdGNhbmNlbExhYmVsOiBcIkFmYnJla2VuXCIsXG5cdHRodW1ibmFpbDoge1xuXHRcdHdyb25nSW1hZ2VUeXBlOiBcIlZlcmtlZXJkIGJlZWxkdHlwZSBnZXNlbGVjdGVlcmRcIixcblx0XHRub3RBdmFpbGFibGU6IFwiVGh1bWJuYWlsIG5pZXQgYmVzY2hpa2JhYXJcIixcblx0XHRsb2FkRXJyb3I6IFwiS29uIGRlIGFmYmVlbGRpbmcgbmlldCBsYWRlblwiLFxuXHRcdGNob29zZUZpbGU6IFwiS2xpayBvbSBiZXN0YW5kIHRlIGtpZXplbi5cIlxuXHR9XG59O1xuY29uc3Qgc2F2ZVV0aWxzID0ge1xuXHR0aHVtYm5haWw6IFwiTWluaWF0dXVyXCIsXG5cdHNoYXJpbmc6IFwiRGVsZW5cIlxufTtcbmNvbnN0IGNsb3NlID0gXCJTbHVpdGVuXCI7XG5jb25zdCB1bnNhdmVkV2FybmluZ0V4aXN0aW5nID0gXCJXaWx0IHUgZGUgd2lqemlnaW5nZW4gaW4gaGV0IGl0ZW0gb3BzbGFhbiA8Yj4ke2l0ZW1UaXRsZX08L2I+ID9cIjtcbmNvbnN0IHVuc2F2ZWRXYXJuaW5nTmV3ID0gXCJXaWx0IHUgdXcgd2lqemlnaW5nZW4gb3BzbGFhbj9cIjtcbmNvbnN0IHNhdmVBcyA9IFwiT3BzbGFhbiBhbHNcIjtcbmNvbnN0IGRvbnRTYXZlID0gXCJOaWV0IG9wc2xhYW5cIjtcbmNvbnN0IHVuc2F2ZWRUaXRsZSA9IFwiTmlldC1vcGdlc2xhZ2VuIHdpanppZ2luZ2VuXCI7XG5jb25zdCBpbnZhbGlkUkZUTWVzc2FnZSA9IFwiRGUgZ2VtYWFrdGUgcmFzdGVyZnVuY3RpZXRlbXBsYXRlIGlzIG5pZXQgZ2VsZGlnLlwiO1xuY29uc3QgZXJyb3JUaXRsZSA9IFwiRm91dFwiO1xuY29uc3QgYnJlYWRjcnVtYiA9IFwiUmFzdGVyIEZ1bmN0aW9uIEVkaXRvclwiO1xuY29uc3QgYnJlYWRjcnVtYkVkaXRvciA9IFwiQ29udGVudCA+IFJhc3RlciBGdW5jdGlvbiBFZGl0b3JcIjtcbmNvbnN0IHZpZXdlck1vZGVUaXRsZSA9IFwiQWxsZWVuIGxlemVuXCI7XG5jb25zdCB2aWV3ZXJNb2RlTWVzc2FnZSA9IFwiUmFzdGVyZnVuY3RpZSB0ZW1wbGF0ZS1pdGVtIGlzIGFsbGVlbi1sZXplbi4gVmVyYW5kZXJpbmdlbiB6aWpuIG5pZXQgb3BnZXNsYWdlbi5cIjtcbmNvbnN0IHVzZXJTdGFydERpcmVjdGlvbiA9IFwiU2VsZWN0ZWVyIGVlbiBmdW5jdGllIG9tIGVlbiByYXN0ZXJmdW5jdGlldGVtcGxhdGUgdGUgbWFrZW4uXCI7XG5jb25zdCBzZWxlY3RGdW5jdGlvbiA9IFwiRnVuY3RpZSB0b2V2b2VnZW5cIjtcbmNvbnN0IGRlc2VsZWN0RnVuY3Rpb24gPSBcIkZ1bmN0aWUgdmVyd2lqZGVyZW5cIjtcbmNvbnN0IGRpYWxvZ1RpdGxlID0gXCJTeXN0ZWVtXCI7XG5jb25zdCBjYXRlZ29yeSA9IFwiQ2F0ZWdvcmllw6tuXCI7XG5jb25zdCBzZWFyY2ggPSBcIlJhc3RlcmZ1bmN0aWVzIHpvZWtlblwiO1xuY29uc3QgY2F0ZWdvcnlOYW1lcyA9IHtcblx0YW5hbHlzaXM6IFwiQW5hbHlzZVwiLFxuXHRhcHBlYXJhbmNlOiBcIldlZXJnYXZlXCIsXG5cdGNsYXNzaWZpY2F0aW9uOiBcIkNsYXNzaWZpY2F0aWVcIixcblx0Y29udmVyc2lvbjogXCJDb252ZXJzaWVcIixcblx0Y29ycmVjdGlvbjogXCJDb3JyZWN0aWVcIixcblx0ZGF0YU1hbmFnZW1lbnQ6IFwiRGF0YWJlaGVlclwiLFxuXHRkaXN0YW5jZTogXCJBZnN0YW5kXCIsXG5cdGRpc3RhbmNlTGVnYWN5OiBcIkFmc3RhbmQgKExlZ2FjeSlcIixcblx0aHlkcm9sb2d5OiBcIkh5ZHJvbG9naWVcIixcblx0bWF0aDogXCJCZXJla2VuaW5nZW5cIixcblx0bWF0aENvbmRpdGlvbmFsOiBcIlJla2Vua3VuZGlnOiBWb29yd2FhcmRlbGlqa1wiLFxuXHRtYXRoTG9naWNhbDogXCJSZWtlbmt1bmRpZzogbG9naXNjaFwiLFxuXHRtYXRoVHJpZ29ub21ldHJpYzogXCJSZWtlbmt1bmRpZzogdHJpZ29ub21ldHJpc2NoXCIsXG5cdHJlY2xhc3M6IFwiSGVyY2xhc3NpZmljZXJlblwiLFxuXHRzdGF0aXN0aWNhbDogXCJTdGF0aXN0aXNjaFwiLFxuXHRzdXJmYWNlOiBcIk9wcGVydmxha1wiXG59O1xuY29uc3QgY29tbW9uU3RyaW5nc19ubCA9IHtcblx0b2s6IG9rLFxuXHRjYW5jZWw6IGNhbmNlbCxcblx0ZW50ZXJVUkw6IGVudGVyVVJMLFxuXHRzZXJ2aWNlVVJMOiBzZXJ2aWNlVVJMLFxuXHRzZWxlY3RSYXN0ZXI6IHNlbGVjdFJhc3Rlcixcblx0ZmFpbGVkVG9Mb2FkTGF5ZXI6IGZhaWxlZFRvTG9hZExheWVyLFxuXHRsb2FkaW5nTGF5ZXI6IGxvYWRpbmdMYXllcixcblx0c2VsZWN0RmVhdHVyZTogc2VsZWN0RmVhdHVyZSxcblx0ZW50ZXJGVVJMOiBlbnRlckZVUkwsXG5cdGFkZFJhc3RlcjogYWRkUmFzdGVyLFxuXHRhZGRTY2FsYXI6IGFkZFNjYWxhcixcblx0cmFzdGVyOiByYXN0ZXIsXG5cdHNjYWxhcjogc2NhbGFyLFxuXHRkZWZhdWx0TW9kZWxOYW1lOiBkZWZhdWx0TW9kZWxOYW1lLFxuXHRnZW5lcmFsOiBnZW5lcmFsLFxuXHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuXHR2YXJpYWJsZXM6IHZhcmlhYmxlcyxcblx0bmFtZTogbmFtZSxcblx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuXHRwYXJhbWV0ZXI6IHBhcmFtZXRlcixcblx0aXNQdWJsaWM6IGlzUHVibGljLFxuXHRpc0RhdGFzZXQ6IGlzRGF0YXNldCxcblx0dW5rbm93blBpeGVsVHlwZTogdW5rbm93blBpeGVsVHlwZSxcblx0b3V0cHV0UGl4ZWxUeXBlOiBvdXRwdXRQaXhlbFR5cGUsXG5cdHU4UGl4ZWxUeXBlOiB1OFBpeGVsVHlwZSxcblx0czhQaXhlbFR5cGU6IHM4UGl4ZWxUeXBlLFxuXHR1MTZQaXhlbFR5cGU6IHUxNlBpeGVsVHlwZSxcblx0czE2UGl4ZWxUeXBlOiBzMTZQaXhlbFR5cGUsXG5cdHUzMlBpeGVsVHlwZTogdTMyUGl4ZWxUeXBlLFxuXHRzMzJQaXhlbFR5cGU6IHMzMlBpeGVsVHlwZSxcblx0ZjMyUGl4ZWxUeXBlOiBmMzJQaXhlbFR5cGUsXG5cdGY2NFBpeGVsVHlwZTogZjY0UGl4ZWxUeXBlLFxuXHRwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRtdWx0aWRpbWVuc2lvbmFsUnVsZXM6IG11bHRpZGltZW5zaW9uYWxSdWxlcyxcblx0bWF0Y2hWYXJpYWJsZXM6IG1hdGNoVmFyaWFibGVzLFxuXHR1bmlvbkRpbWVuc2lvbnM6IHVuaW9uRGltZW5zaW9ucyxcblx0cmFzdGVyRnVuY3Rpb25FZGl0b3I6IHJhc3RlckZ1bmN0aW9uRWRpdG9yLFxuXHRyZnhMaWNlbnNlSW5mbzogcmZ4TGljZW5zZUluZm8sXG5cdHJhc3RlckZ1bmN0aW9uczogcmFzdGVyRnVuY3Rpb25zLFxuXHRjb3B5OiBjb3B5LFxuXHRzYXZlOiBzYXZlLFxuXHR0aXRsZTogdGl0bGUsXG5cdGZvbGRlcjogZm9sZGVyLFxuXHR0YWdzOiB0YWdzLFxuXHRzYXZpbmdNZXNzYWdlOiBzYXZpbmdNZXNzYWdlLFxuXHRzaGFyZVdpdGg6IHNoYXJlV2l0aCxcblx0c2hhcmU6IHNoYXJlLFxuXHRzZXRTaGFyaW5nTGV2ZWw6IHNldFNoYXJpbmdMZXZlbCxcblx0c2V0R3JvdXBTaGFyaW5nOiBzZXRHcm91cFNoYXJpbmcsXG5cdG93bmVyOiBvd25lcixcblx0b3JnYW5pemF0aW9uOiBvcmdhbml6YXRpb24sXG5cdGV2ZXJ5b25lOiBldmVyeW9uZSxcblx0Z3JvdXBzOiBncm91cHMsXG5cdHR5cGU6IHR5cGUsXG5cdG1vc2FpYzogbW9zYWljLFxuXHRpdGVtR3JvdXA6IGl0ZW1Hcm91cCxcblx0aXRlbTogaXRlbSxcblx0ZGVmaW5pdGlvblF1ZXJ5OiBkZWZpbml0aW9uUXVlcnksXG5cdGdyb3VwSXRlbXNCeTogZ3JvdXBJdGVtc0J5LFxuXHRncm91cEZpZWxkTmFtZTogZ3JvdXBGaWVsZE5hbWUsXG5cdHRhZ0ZpZWxkTmFtZTogdGFnRmllbGROYW1lLFxuXHRub1RpdGxlVGFnRXJyb3JNc2c6IG5vVGl0bGVUYWdFcnJvck1zZyxcblx0bm9UaXRsZUVycm9yTXNnOiBub1RpdGxlRXJyb3JNc2csXG5cdG5vVGFnRXJyb3JNc2c6IG5vVGFnRXJyb3JNc2csXG5cdGVycm9yOiBlcnJvcixcblx0d2FybmluZzogd2FybmluZyxcblx0c3VjY2Vzczogc3VjY2Vzcyxcblx0ZGV0YWlsczogZGV0YWlscyxcblx0dHJ5QWdhaW46IHRyeUFnYWluLFxuXHR0b29sTW9kZWxlcjogdG9vbE1vZGVsZXIsXG5cdHRvb2xFZGl0b3I6IHRvb2xFZGl0b3IsXG5cdHRvb2xEZXRhaWxzRWRpdG9yOiB0b29sRGV0YWlsc0VkaXRvcixcblx0c2F2ZVV0aWxzOiBzYXZlVXRpbHMsXG5cdGNsb3NlOiBjbG9zZSxcblx0dW5zYXZlZFdhcm5pbmdFeGlzdGluZzogdW5zYXZlZFdhcm5pbmdFeGlzdGluZyxcblx0dW5zYXZlZFdhcm5pbmdOZXc6IHVuc2F2ZWRXYXJuaW5nTmV3LFxuXHRzYXZlQXM6IHNhdmVBcyxcblx0ZG9udFNhdmU6IGRvbnRTYXZlLFxuXHR1bnNhdmVkVGl0bGU6IHVuc2F2ZWRUaXRsZSxcblx0aW52YWxpZFJGVE1lc3NhZ2U6IGludmFsaWRSRlRNZXNzYWdlLFxuXHRlcnJvclRpdGxlOiBlcnJvclRpdGxlLFxuXHRicmVhZGNydW1iOiBicmVhZGNydW1iLFxuXHRicmVhZGNydW1iRWRpdG9yOiBicmVhZGNydW1iRWRpdG9yLFxuXHR2aWV3ZXJNb2RlVGl0bGU6IHZpZXdlck1vZGVUaXRsZSxcblx0dmlld2VyTW9kZU1lc3NhZ2U6IHZpZXdlck1vZGVNZXNzYWdlLFxuXHR1c2VyU3RhcnREaXJlY3Rpb246IHVzZXJTdGFydERpcmVjdGlvbixcblx0c2VsZWN0RnVuY3Rpb246IHNlbGVjdEZ1bmN0aW9uLFxuXHRkZXNlbGVjdEZ1bmN0aW9uOiBkZXNlbGVjdEZ1bmN0aW9uLFxuXHRkaWFsb2dUaXRsZTogZGlhbG9nVGl0bGUsXG5cdGNhdGVnb3J5OiBjYXRlZ29yeSxcblx0c2VhcmNoOiBzZWFyY2gsXG5cdGNhdGVnb3J5TmFtZXM6IGNhdGVnb3J5TmFtZXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbW1vblN0cmluZ3Nfbmw7XG5leHBvcnQgeyBhZGRSYXN0ZXIsIGFkZFNjYWxhciwgYnJlYWRjcnVtYiwgYnJlYWRjcnVtYkVkaXRvciwgY2FuY2VsLCBjYXRlZ29yeSwgY2F0ZWdvcnlOYW1lcywgY2xvc2UsIGNvcHksIGRlZmF1bHRNb2RlbE5hbWUsIGRlZmluaXRpb25RdWVyeSwgZGVzY3JpcHRpb24sIGRlc2VsZWN0RnVuY3Rpb24sIGRldGFpbHMsIGRpYWxvZ1RpdGxlLCBkb250U2F2ZSwgZW50ZXJGVVJMLCBlbnRlclVSTCwgZXJyb3IsIGVycm9yVGl0bGUsIGV2ZXJ5b25lLCBmMzJQaXhlbFR5cGUsIGY2NFBpeGVsVHlwZSwgZmFpbGVkVG9Mb2FkTGF5ZXIsIGZvbGRlciwgZ2VuZXJhbCwgZ3JvdXBGaWVsZE5hbWUsIGdyb3VwSXRlbXNCeSwgZ3JvdXBzLCBpbnZhbGlkUkZUTWVzc2FnZSwgaXNEYXRhc2V0LCBpc1B1YmxpYywgaXRlbSwgaXRlbUdyb3VwLCBsb2FkaW5nTGF5ZXIsIG1hdGNoVmFyaWFibGVzLCBtb3NhaWMsIG11bHRpZGltZW5zaW9uYWxSdWxlcywgbmFtZSwgbm9UYWdFcnJvck1zZywgbm9UaXRsZUVycm9yTXNnLCBub1RpdGxlVGFnRXJyb3JNc2csIG9rLCBvcmdhbml6YXRpb24sIG91dHB1dFBpeGVsVHlwZSwgb3duZXIsIHBhcmFtZXRlciwgcGFyYW1ldGVycywgcHJvcGVydGllcywgcmFzdGVyLCByYXN0ZXJGdW5jdGlvbkVkaXRvciwgcmFzdGVyRnVuY3Rpb25zLCByZnhMaWNlbnNlSW5mbywgczE2UGl4ZWxUeXBlLCBzMzJQaXhlbFR5cGUsIHM4UGl4ZWxUeXBlLCBzYXZlLCBzYXZlQXMsIHNhdmVVdGlscywgc2F2aW5nTWVzc2FnZSwgc2NhbGFyLCBzZWFyY2gsIHNlbGVjdEZlYXR1cmUsIHNlbGVjdEZ1bmN0aW9uLCBzZWxlY3RSYXN0ZXIsIHNlcnZpY2VVUkwsIHNldEdyb3VwU2hhcmluZywgc2V0U2hhcmluZ0xldmVsLCBzaGFyZSwgc2hhcmVXaXRoLCBzdWNjZXNzLCB0YWdGaWVsZE5hbWUsIHRhZ3MsIHRpdGxlLCB0b29sRGV0YWlsc0VkaXRvciwgdG9vbEVkaXRvciwgdG9vbE1vZGVsZXIsIHRyeUFnYWluLCB0eXBlLCB1MTZQaXhlbFR5cGUsIHUzMlBpeGVsVHlwZSwgdThQaXhlbFR5cGUsIHVuaW9uRGltZW5zaW9ucywgdW5rbm93blBpeGVsVHlwZSwgdW5zYXZlZFRpdGxlLCB1bnNhdmVkV2FybmluZ0V4aXN0aW5nLCB1bnNhdmVkV2FybmluZ05ldywgdXNlclN0YXJ0RGlyZWN0aW9uLCB2YXJpYWJsZXMsIHZpZXdlck1vZGVNZXNzYWdlLCB2aWV3ZXJNb2RlVGl0bGUsIHdhcm5pbmcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLXN0cmluZ3MubmwtYmI5OWMyZmMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9