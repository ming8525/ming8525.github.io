"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-177d7b"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-popup-color-button.entry.js":
/*!****************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-popup-color-button.entry.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_popup_color_button: () => (/* binding */ ArcgisPopupColorButton)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _popupStore_85381453_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./popupStore-85381453.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/popupStore-85381453.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */







const arcgisPopupColorButtonCss = ".color-selector{display:flex;padding:6px;justify-content:space-between;align-items:center;border-radius:0;cursor:pointer;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-1);border-color:var(--calcite-color-foreground-3);border-width:1px;border-style:solid;box-shadow:transparent 0px 0px 0px 1px inset}.color-selector:hover{box-shadow:inset 0 0 0 1px var(--calcite-color-foreground-3)}.color-selector:active{box-shadow:inset 0 0 0 2px var(--calcite-color-foreground-3)}.color-selector:focus{box-shadow:inset 0 0 0 2px var(--calcite-color-foreground-3);outline:2px solid var(--calcite-color-brand);outline-offset:2px}.color-selector.selected{box-shadow:inset 0 0 0 2px var(--calcite-color-foreground-3)}.color-icon-section{height:16px;display:inline-block}.color-icon{width:100%;height:16px;overflow:hidden;border-radius:0}.color-icon.transparent{height:15px;width:100%}.color-icon.transparent svg{height:15px;width:95%;stroke:#e0e0e0;stroke-width:1px}.color-edit-button{padding:1px;height:18px;width:18px;border:none;cursor:pointer;color:var(--calcite-ui-icon-color)}.color-edit-button:focus{outline:none}";

const MAX_RAMP_COLORS = 10;
const ArcgisPopupColorButton = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisPopupColorButtonChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisPopupColorButtonChange", 7);
        this.arcgisPopupColorButtonBeforeOpen = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisPopupColorButtonBeforeOpen", 7);
        this.resizeObserver = new ResizeObserver(() => {
            (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
        });
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.handleClick = async () => {
            const { popoverReferenceElement, popoverNode, buttonNode, colors, strings, esriColor, esriLang } = this;
            if (popoverNode) {
                this.onPopoverClose();
            }
            else if (colors.length === 1) {
                this.arcgisPopupColorButtonBeforeOpen.emit();
                this.selected = true;
                const popover = document.createElement("arcgis-popup-color-popover");
                popover.heading = strings.selectColor;
                popover.intlDone = strings.done;
                popover.label = strings.selectColor;
                popover.hexColor = colors[0].toHex();
                popover.popoverProps = {
                    placement: "leading-start",
                    offsetDistance: 1,
                    offsetSkidding: 52,
                    pointerDisabled: "true",
                    popoverWidth: 315,
                    //overlayPositioning: "fixed", -- buggy, offset issue
                    refElement: typeof popoverReferenceElement === "string"
                        ? document.getElementById(popoverReferenceElement)
                        : popoverReferenceElement
                };
                popover.addEventListener("arcgisPopupColorPopoverClose", () => {
                    this.popoverNode = null;
                });
                popover.addEventListener("arcgisPopupColorPopoverChange", ({ detail: hexColor }) => {
                    this.colors[0] = new esriColor(hexColor);
                    // once the user makes a change we save all colors
                    this.chartMediaInfo.value.colors = esriLang.clone(this.colors);
                    this.arcgisPopupColorButtonChange.emit(esriLang.clone(this.colors));
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                });
                document.body.appendChild(popover);
                popover.setOpen(true);
                this.popoverNode = popover;
            }
            else {
                this.arcgisPopupColorButtonBeforeOpen.emit();
                this.selected = true;
                const symbolStylerDiv = document.createElement("div");
                symbolStylerDiv.className = "symbol-styler-div";
                this.popoverNode = this.createSymbolStylerPopover({
                    referenceElement: typeof popoverReferenceElement === "string"
                        ? document.getElementById(popoverReferenceElement)
                        : popoverReferenceElement
                });
                this.popoverNode.addEventListener("arcgisPopupStylerPopoverClose", () => {
                    this.onPopoverClose();
                    // if we do this too early the enter key executes on the focused div
                    setTimeout(() => buttonNode.focus(), 300);
                });
                this.popoverNode.addEventListener("arcgisPopupStylerPopoverDisconnected", () => {
                    this.onPopoverClose();
                });
                this.symbolStylerWatchScaleHandle = await this.buildSymbolStylerForRamp({
                    popoverNode: this.popoverNode,
                    onChange: () => {
                        var _a;
                        // once the user makes a change we save all colors
                        ((_a = this.chartMediaInfo) === null || _a === void 0 ? void 0 : _a.value).colors = esriLang.clone(this.colors);
                        this.arcgisPopupColorButtonChange.emit(esriLang.clone(this.colors));
                    }
                });
            }
        };
        this.popoverReferenceElement = undefined;
        this.chartMediaInfo = undefined;
        this.colors = undefined;
        this.selected = false;
        this.symbolNodeWidth = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  public calls
    //
    //--------------------------------------------------------------------------
    async setFocus() {
        var _a;
        (_a = this.buttonNode) === null || _a === void 0 ? void 0 : _a.focus();
    }
    async closePopover() {
        this.onPopoverClose();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        this.layer = _popupStore_85381453_js__WEBPACK_IMPORTED_MODULE_1__.p.layer;
        this.mapView = _popupStore_85381453_js__WEBPACK_IMPORTED_MODULE_1__.p.mapView;
        this.strings = _popupStore_85381453_js__WEBPACK_IMPORTED_MODULE_1__.p.strings;
        this.portal = _popupStore_85381453_js__WEBPACK_IMPORTED_MODULE_1__.p.portal;
        this.popupTemplate = _popupStore_85381453_js__WEBPACK_IMPORTED_MODULE_1__.p.popupTemplate;
        const [esriLang, esriColor, pieChartSchemes, SimpleFillSymbol] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)([
            "esri/core/lang",
            "esri/Color",
            "esri/smartMapping/symbology/pieChart",
            "esri/symbols/SimpleFillSymbol"
        ]);
        this.esriLang = esriLang;
        this.esriColor = esriColor;
        this.pieChartSchemes = pieChartSchemes;
        this.SimpleFillSymbol = SimpleFillSymbol;
    }
    async componentDidLoad() {
        // for correct width
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
        this.resizeObserver.observe(this.buttonNode);
    }
    disconnectedCallback() {
        this.resizeObserver.unobserve(this.buttonNode);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { strings } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { id: "color-button-label", scale: "s" }, strings.color, this.renderButton())));
    }
    renderButton() {
        const { colors, selected } = this;
        let colorsIcon = (colors === null || colors === void 0 ? void 0 : colors.length)
            ? colors
                .filter((_, idx2) => idx2 < MAX_RAMP_COLORS)
                .map((color, idx) => {
                var _a;
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: `color-button-icon-${idx}`, class: "color-icon-section", style: {
                        width: `${95 / Math.min(10, Math.min(MAX_RAMP_COLORS, colors.length))}%`,
                        backgroundColor: `${(_a = color === null || color === void 0 ? void 0 : color.toHex()) !== null && _a !== void 0 ? _a : "#ffffff"}`
                    } }));
            })
            : null;
        const colorClasses = {
            "color-selector": true,
            selected
        };
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: colorClasses, onClick: this.handleClick, role: "button", tabIndex: 0, "aria-labelledby": "color-button-label", "aria-haspopup": "true", "aria-expanded": !!selected, ref: (node) => {
                this.buttonNode = node;
                node.addEventListener("keyup", (event) => {
                    if (event.key === " " || event.key === "Enter") {
                        this.handleClick();
                    }
                });
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "color-icon", "aria-hidden": "true" }, colorsIcon), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "color-edit-button" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "s", icon: "pencil" }))));
    }
    onPopoverClose() {
        var _a;
        if (this.colors.length === 1) {
            this.popoverNode && document.body.removeChild(this.popoverNode);
        }
        else {
            (_a = this.symbolStylerWatchScaleHandle) === null || _a === void 0 ? void 0 : _a.remove();
            this.popoverNode &&
                this.removeSymbolStylerPopover(this.popoverNode);
        }
        this.selected = false;
        this.popoverNode = undefined;
    }
    createSymbolStylerPopover(props) {
        const { referenceElement } = props;
        const popover = document.createElement("arcgis-popup-styler-popover");
        popover.referenceElement = referenceElement;
        document.body.appendChild(popover);
        popover.setOpen(true);
        popover.reposition();
        return popover;
    }
    removeSymbolStylerPopover(popover) {
        var _a;
        if (popover === null || popover === void 0 ? void 0 : popover.parentNode) {
            popover.open = false;
            (_a = popover.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(popover);
        }
    }
    async createSymbolStylerElement(popoverNode) {
        const symbolStyler = document.createElement("arcgis-symbol-styler");
        symbolStyler.style = "max-height: max(calc(100vh - 200px), 300px)"; // not the best, but easiest
        symbolStyler.popoverProps = {
            placement: "bottom-end",
            offsetDistance: 10,
            offsetSkidding: (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement) === "rtl" ? 3 : -3,
            pointerDisabled: "true",
            popoverWidth: 315,
            //overlayPositioning: "fixed", -- buggy, offset issue
            refElement: await popoverNode.getPopoverRefElement()
        };
        return symbolStyler;
    }
    async buildSymbolStylerForRamp(options) {
        const { mapView, portal, colors, strings, esriLang } = this;
        const { popoverNode } = options;
        const currentColors = this.esriLang.clone(colors.filter((_, idx2) => idx2 < MAX_RAMP_COLORS));
        const schemes = this.pieChartSchemes.getSchemes({
            basemap: mapView.map.basemap,
            geometryType: "polygon",
            numColors: Math.min(MAX_RAMP_COLORS, colors.length)
        });
        const colorRampsAndSchemes = this.getColorRampsWithSchemes(schemes);
        const colorRamps = colorRampsAndSchemes.map((obj) => {
            return {
                stops: obj.colors.reverse(),
                tags: obj.scheme.tags,
                name: obj.scheme.name
            };
        });
        const onStylerEdit = ({ detail: { 
        //symbol,
        info: { /* marker, stroke, */ fill } } }) => {
            var _a;
            const colors = esriLang.clone(fill.color).reverse();
            if (colors.length < this.colors.length) {
                // repeat
                const len = colors.length;
                for (let i = len; i < this.colors.length; i++) {
                    colors.push(this.esriLang.clone(colors[i % MAX_RAMP_COLORS]));
                }
            }
            ((_a = this.chartMediaInfo) === null || _a === void 0 ? void 0 : _a.value).colors = colors;
            this.colors = colors;
            (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            this.arcgisPopupColorButtonChange.emit(this.esriLang.clone(this.colors));
        };
        const symbolStyler = await this.createSymbolStylerElement(popoverNode);
        const edit = symbolStyler.edit(new this.SimpleFillSymbol(), {
            portal,
            sections: {
                marker: {
                    parts: {
                        preview: false,
                        rotation: false,
                        size: false
                    }
                },
                fill: {
                    type: "color-ramp",
                    style: "discrete",
                    open: true,
                    colorRampsOpen: true,
                    colorRamps,
                    parts: {
                        transparency: false // temp /arcgis-js-api/issues/27188
                    }
                }
            },
            fill: {
                color: currentColors.reverse()
            }
        });
        symbolStyler.stringOverrides = {
            fillColor: strings.color
        };
        symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEdit);
        popoverNode.addStyler(symbolStyler);
        await edit;
    }
    getColorRampsWithSchemes(schemes) {
        const allSchemes = [schemes.primaryScheme].concat(schemes.secondarySchemes), colorRampsAndSchemes = [];
        allSchemes.forEach((scheme) => {
            colorRampsAndSchemes.push({
                colors: scheme.colors,
                scheme
            });
        });
        return colorRampsAndSchemes;
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisPopupColorButton.style = arcgisPopupColorButtonCss;



//# sourceMappingURL=arcgis-popup-color-button.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};



//# sourceMappingURL=index-05956cab.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/popupStore-85381453.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/popupStore-85381453.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ clearPopupState),
/* harmony export */   p: () => (/* binding */ popupState)
/* harmony export */ });
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const popupStore = (0,_index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__.c)({
    layer: null,
    mapView: null,
    portal: null,
    config: null,
    strings: null,
    currentLanguage: null,
    currentLanguageIntl: null,
    serviceType: null,
    popupTemplate: null,
    layerHasAttachment: null,
    layerHasET: null,
    layerHasAttributes: null,
    layerHasCharts: null,
    layerHasImages: null,
    layerHasText: null,
    layerDisplayType: null,
    supportsArcade: null,
    layerHasRelatedRecords: false
});
// workaround for starting a panel with a clean state
function clearPopupState(popupState) {
    popupState.layer = null;
    popupState.mapView = null;
    popupState.portal = null;
    popupState.config = null;
    popupState.strings = null;
    popupState.currentLanguage = null;
    popupState.currentLanguageIntl = null;
    popupState.serviceType = null;
    popupState.popupTemplate = null;
    popupState.layerHasAttachment = null;
    popupState.layerHasET = null;
    popupState.layerHasAttributes = null;
    popupState.layerHasCharts = null;
    popupState.layerHasImages = null;
    popupState.layerHasText = null;
    popupState.layerDisplayType = null;
    popupState.supportsArcade = null;
    popupState.layerHasRelatedRecords = false;
}
const popupState = popupStore.state;



//# sourceMappingURL=popupStore-85381453.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTE3N2Q3Yi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDK0g7QUFDcEU7QUFDRTtBQUNHO0FBQ25DO0FBQ0Y7O0FBRTNCLG1EQUFtRCxhQUFhLFlBQVksOEJBQThCLG1CQUFtQixnQkFBZ0IsZUFBZSxtREFBbUQsa0NBQWtDLCtDQUErQyxpQkFBaUIsbUJBQW1CLDZDQUE2QyxzQkFBc0IsNkRBQTZELHVCQUF1Qiw2REFBNkQsc0JBQXNCLDZEQUE2RCw2Q0FBNkMsbUJBQW1CLHlCQUF5Qiw2REFBNkQsb0JBQW9CLFlBQVkscUJBQXFCLFlBQVksV0FBVyxZQUFZLGdCQUFnQixnQkFBZ0Isd0JBQXdCLFlBQVksV0FBVyw0QkFBNEIsWUFBWSxVQUFVLGVBQWUsaUJBQWlCLG1CQUFtQixZQUFZLFlBQVksV0FBVyxZQUFZLGVBQWUsbUNBQW1DLHlCQUF5QixhQUFhOztBQUVwcEM7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEIsNENBQTRDLHFEQUFXO0FBQ3ZELGdEQUFnRCxxREFBVztBQUMzRDtBQUNBLFlBQVkscURBQVc7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5RkFBeUY7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDZFQUE2RSxrQkFBa0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVc7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSw2Q0FBNkMsT0FBTyxNQUFNLE9BQU87QUFDakU7QUFDQTtBQUNBLHdDQUF3QyxPQUFPLE1BQU0sT0FBTztBQUM1RDs7QUFFeUg7O0FBRXpIOzs7Ozs7Ozs7Ozs7Ozs7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEOztBQUV2RCxtQkFBbUIscURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpRDs7QUFFakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtcG9wdXAtY29sb3ItYnV0dG9uLmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2luZGV4LTA1OTU2Y2FiLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9wb3B1cFN0b3JlLTg1MzgxNDUzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBmIGFzIGZvcmNlVXBkYXRlLCBoLCBIIGFzIEhvc3QsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgcCBhcyBwb3B1cFN0YXRlIH0gZnJvbSAnLi9wb3B1cFN0b3JlLTg1MzgxNDUzLmpzJztcbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0RWxlbWVudERpciB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCAnLi9pbmRleC0wNTk1NmNhYi5qcyc7XG5pbXBvcnQgJy4vZG9tLTRkMzY3Njc3LmpzJztcblxuY29uc3QgYXJjZ2lzUG9wdXBDb2xvckJ1dHRvbkNzcyA9IFwiLmNvbG9yLXNlbGVjdG9ye2Rpc3BsYXk6ZmxleDtwYWRkaW5nOjZweDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjthbGlnbi1pdGVtczpjZW50ZXI7Ym9yZGVyLXJhZGl1czowO2N1cnNvcjpwb2ludGVyO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci1mb3JlZ3JvdW5kLTEpO2NvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItdGV4dC0xKTtib3JkZXItY29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci1mb3JlZ3JvdW5kLTMpO2JvcmRlci13aWR0aDoxcHg7Ym9yZGVyLXN0eWxlOnNvbGlkO2JveC1zaGFkb3c6dHJhbnNwYXJlbnQgMHB4IDBweCAwcHggMXB4IGluc2V0fS5jb2xvci1zZWxlY3Rvcjpob3Zlcntib3gtc2hhZG93Omluc2V0IDAgMCAwIDFweCB2YXIoLS1jYWxjaXRlLWNvbG9yLWZvcmVncm91bmQtMyl9LmNvbG9yLXNlbGVjdG9yOmFjdGl2ZXtib3gtc2hhZG93Omluc2V0IDAgMCAwIDJweCB2YXIoLS1jYWxjaXRlLWNvbG9yLWZvcmVncm91bmQtMyl9LmNvbG9yLXNlbGVjdG9yOmZvY3Vze2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMnB4IHZhcigtLWNhbGNpdGUtY29sb3ItZm9yZWdyb3VuZC0zKTtvdXRsaW5lOjJweCBzb2xpZCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJyYW5kKTtvdXRsaW5lLW9mZnNldDoycHh9LmNvbG9yLXNlbGVjdG9yLnNlbGVjdGVke2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMnB4IHZhcigtLWNhbGNpdGUtY29sb3ItZm9yZWdyb3VuZC0zKX0uY29sb3ItaWNvbi1zZWN0aW9ue2hlaWdodDoxNnB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5jb2xvci1pY29ue3dpZHRoOjEwMCU7aGVpZ2h0OjE2cHg7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlci1yYWRpdXM6MH0uY29sb3ItaWNvbi50cmFuc3BhcmVudHtoZWlnaHQ6MTVweDt3aWR0aDoxMDAlfS5jb2xvci1pY29uLnRyYW5zcGFyZW50IHN2Z3toZWlnaHQ6MTVweDt3aWR0aDo5NSU7c3Ryb2tlOiNlMGUwZTA7c3Ryb2tlLXdpZHRoOjFweH0uY29sb3ItZWRpdC1idXR0b257cGFkZGluZzoxcHg7aGVpZ2h0OjE4cHg7d2lkdGg6MThweDtib3JkZXI6bm9uZTtjdXJzb3I6cG9pbnRlcjtjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWljb24tY29sb3IpfS5jb2xvci1lZGl0LWJ1dHRvbjpmb2N1c3tvdXRsaW5lOm5vbmV9XCI7XG5cbmNvbnN0IE1BWF9SQU1QX0NPTE9SUyA9IDEwO1xuY29uc3QgQXJjZ2lzUG9wdXBDb2xvckJ1dHRvbiA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzUG9wdXBDb2xvckJ1dHRvbkNoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzUG9wdXBDb2xvckJ1dHRvbkNoYW5nZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNQb3B1cENvbG9yQnV0dG9uQmVmb3JlT3BlbiA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzUG9wdXBDb2xvckJ1dHRvbkJlZm9yZU9wZW5cIiwgNyk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHBvcG92ZXJSZWZlcmVuY2VFbGVtZW50LCBwb3BvdmVyTm9kZSwgYnV0dG9uTm9kZSwgY29sb3JzLCBzdHJpbmdzLCBlc3JpQ29sb3IsIGVzcmlMYW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHBvcG92ZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblBvcG92ZXJDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzUG9wdXBDb2xvckJ1dHRvbkJlZm9yZU9wZW4uZW1pdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcG92ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXJjZ2lzLXBvcHVwLWNvbG9yLXBvcG92ZXJcIik7XG4gICAgICAgICAgICAgICAgcG9wb3Zlci5oZWFkaW5nID0gc3RyaW5ncy5zZWxlY3RDb2xvcjtcbiAgICAgICAgICAgICAgICBwb3BvdmVyLmludGxEb25lID0gc3RyaW5ncy5kb25lO1xuICAgICAgICAgICAgICAgIHBvcG92ZXIubGFiZWwgPSBzdHJpbmdzLnNlbGVjdENvbG9yO1xuICAgICAgICAgICAgICAgIHBvcG92ZXIuaGV4Q29sb3IgPSBjb2xvcnNbMF0udG9IZXgoKTtcbiAgICAgICAgICAgICAgICBwb3BvdmVyLnBvcG92ZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBcImxlYWRpbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0RGlzdGFuY2U6IDEsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFNraWRkaW5nOiA1MixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlckRpc2FibGVkOiBcInRydWVcIixcbiAgICAgICAgICAgICAgICAgICAgcG9wb3ZlcldpZHRoOiAzMTUsXG4gICAgICAgICAgICAgICAgICAgIC8vb3ZlcmxheVBvc2l0aW9uaW5nOiBcImZpeGVkXCIsIC0tIGJ1Z2d5LCBvZmZzZXQgaXNzdWVcbiAgICAgICAgICAgICAgICAgICAgcmVmRWxlbWVudDogdHlwZW9mIHBvcG92ZXJSZWZlcmVuY2VFbGVtZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBvcG92ZXJSZWZlcmVuY2VFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwb3BvdmVyUmVmZXJlbmNlRWxlbWVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9wb3Zlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzUG9wdXBDb2xvclBvcG92ZXJDbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wb3Zlck5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBvcG92ZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1BvcHVwQ29sb3JQb3BvdmVyQ2hhbmdlXCIsICh7IGRldGFpbDogaGV4Q29sb3IgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yc1swXSA9IG5ldyBlc3JpQ29sb3IoaGV4Q29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmNlIHRoZSB1c2VyIG1ha2VzIGEgY2hhbmdlIHdlIHNhdmUgYWxsIGNvbG9yc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0TWVkaWFJbmZvLnZhbHVlLmNvbG9ycyA9IGVzcmlMYW5nLmNsb25lKHRoaXMuY29sb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNQb3B1cENvbG9yQnV0dG9uQ2hhbmdlLmVtaXQoZXNyaUxhbmcuY2xvbmUodGhpcy5jb2xvcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3BvdmVyKTtcbiAgICAgICAgICAgICAgICBwb3BvdmVyLnNldE9wZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyTm9kZSA9IHBvcG92ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc1BvcHVwQ29sb3JCdXR0b25CZWZvcmVPcGVuLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xTdHlsZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlckRpdi5jbGFzc05hbWUgPSBcInN5bWJvbC1zdHlsZXItZGl2XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyTm9kZSA9IHRoaXMuY3JlYXRlU3ltYm9sU3R5bGVyUG9wb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQ6IHR5cGVvZiBwb3BvdmVyUmVmZXJlbmNlRWxlbWVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwb3BvdmVyUmVmZXJlbmNlRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcG9wb3ZlclJlZmVyZW5jZUVsZW1lbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcG92ZXJOb2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNQb3B1cFN0eWxlclBvcG92ZXJDbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Qb3BvdmVyQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG8gdGhpcyB0b28gZWFybHkgdGhlIGVudGVyIGtleSBleGVjdXRlcyBvbiB0aGUgZm9jdXNlZCBkaXZcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBidXR0b25Ob2RlLmZvY3VzKCksIDMwMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyTm9kZS5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzUG9wdXBTdHlsZXJQb3BvdmVyRGlzY29ubmVjdGVkXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblBvcG92ZXJDbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9sU3R5bGVyV2F0Y2hTY2FsZUhhbmRsZSA9IGF3YWl0IHRoaXMuYnVpbGRTeW1ib2xTdHlsZXJGb3JSYW1wKHtcbiAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck5vZGU6IHRoaXMucG9wb3Zlck5vZGUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmNlIHRoZSB1c2VyIG1ha2VzIGEgY2hhbmdlIHdlIHNhdmUgYWxsIGNvbG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgKChfYSA9IHRoaXMuY2hhcnRNZWRpYUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZSkuY29sb3JzID0gZXNyaUxhbmcuY2xvbmUodGhpcy5jb2xvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNQb3B1cENvbG9yQnV0dG9uQ2hhbmdlLmVtaXQoZXNyaUxhbmcuY2xvbmUodGhpcy5jb2xvcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBvcG92ZXJSZWZlcmVuY2VFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNoYXJ0TWVkaWFJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN5bWJvbE5vZGVXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIHB1YmxpYyBjYWxsc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIHNldEZvY3VzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuYnV0dG9uTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlUG9wb3ZlcigpIHtcbiAgICAgICAgdGhpcy5vblBvcG92ZXJDbG9zZSgpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgIHRoaXMubGF5ZXIgPSBwb3B1cFN0YXRlLmxheWVyO1xuICAgICAgICB0aGlzLm1hcFZpZXcgPSBwb3B1cFN0YXRlLm1hcFZpZXc7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHBvcHVwU3RhdGUuc3RyaW5ncztcbiAgICAgICAgdGhpcy5wb3J0YWwgPSBwb3B1cFN0YXRlLnBvcnRhbDtcbiAgICAgICAgdGhpcy5wb3B1cFRlbXBsYXRlID0gcG9wdXBTdGF0ZS5wb3B1cFRlbXBsYXRlO1xuICAgICAgICBjb25zdCBbZXNyaUxhbmcsIGVzcmlDb2xvciwgcGllQ2hhcnRTY2hlbWVzLCBTaW1wbGVGaWxsU3ltYm9sXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgICAgIFwiZXNyaS9jb3JlL2xhbmdcIixcbiAgICAgICAgICAgIFwiZXNyaS9Db2xvclwiLFxuICAgICAgICAgICAgXCJlc3JpL3NtYXJ0TWFwcGluZy9zeW1ib2xvZ3kvcGllQ2hhcnRcIixcbiAgICAgICAgICAgIFwiZXNyaS9zeW1ib2xzL1NpbXBsZUZpbGxTeW1ib2xcIlxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5lc3JpTGFuZyA9IGVzcmlMYW5nO1xuICAgICAgICB0aGlzLmVzcmlDb2xvciA9IGVzcmlDb2xvcjtcbiAgICAgICAgdGhpcy5waWVDaGFydFNjaGVtZXMgPSBwaWVDaGFydFNjaGVtZXM7XG4gICAgICAgIHRoaXMuU2ltcGxlRmlsbFN5bWJvbCA9IFNpbXBsZUZpbGxTeW1ib2w7XG4gICAgfVxuICAgIGFzeW5jIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIC8vIGZvciBjb3JyZWN0IHdpZHRoXG4gICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5idXR0b25Ob2RlKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuYnV0dG9uTm9kZSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgaWQ6IFwiY29sb3ItYnV0dG9uLWxhYmVsXCIsIHNjYWxlOiBcInNcIiB9LCBzdHJpbmdzLmNvbG9yLCB0aGlzLnJlbmRlckJ1dHRvbigpKSkpO1xuICAgIH1cbiAgICByZW5kZXJCdXR0b24oKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3JzLCBzZWxlY3RlZCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGNvbG9yc0ljb24gPSAoY29sb3JzID09PSBudWxsIHx8IGNvbG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sb3JzLmxlbmd0aClcbiAgICAgICAgICAgID8gY29sb3JzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoXywgaWR4MikgPT4gaWR4MiA8IE1BWF9SQU1QX0NPTE9SUylcbiAgICAgICAgICAgICAgICAubWFwKChjb2xvciwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGtleTogYGNvbG9yLWJ1dHRvbi1pY29uLSR7aWR4fWAsIGNsYXNzOiBcImNvbG9yLWljb24tc2VjdGlvblwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGAkezk1IC8gTWF0aC5taW4oMTAsIE1hdGgubWluKE1BWF9SQU1QX0NPTE9SUywgY29sb3JzLmxlbmd0aCkpfSVgLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBgJHsoX2EgPSBjb2xvciA9PT0gbnVsbCB8fCBjb2xvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sb3IudG9IZXgoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIjZmZmZmZmXCJ9YFxuICAgICAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IGNvbG9yQ2xhc3NlcyA9IHtcbiAgICAgICAgICAgIFwiY29sb3Itc2VsZWN0b3JcIjogdHJ1ZSxcbiAgICAgICAgICAgIHNlbGVjdGVkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBjb2xvckNsYXNzZXMsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssIHJvbGU6IFwiYnV0dG9uXCIsIHRhYkluZGV4OiAwLCBcImFyaWEtbGFiZWxsZWRieVwiOiBcImNvbG9yLWJ1dHRvbi1sYWJlbFwiLCBcImFyaWEtaGFzcG9wdXBcIjogXCJ0cnVlXCIsIFwiYXJpYS1leHBhbmRlZFwiOiAhIXNlbGVjdGVkLCByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25Ob2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCIgXCIgfHwgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiY29sb3ItaWNvblwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIGNvbG9yc0ljb24pLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiY29sb3ItZWRpdC1idXR0b25cIiB9LCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgc2NhbGU6IFwic1wiLCBpY29uOiBcInBlbmNpbFwiIH0pKSkpO1xuICAgIH1cbiAgICBvblBvcG92ZXJDbG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5jb2xvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXJOb2RlICYmIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5wb3BvdmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnN5bWJvbFN0eWxlcldhdGNoU2NhbGVIYW5kbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlck5vZGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVN5bWJvbFN0eWxlclBvcG92ZXIodGhpcy5wb3BvdmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvcG92ZXJOb2RlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjcmVhdGVTeW1ib2xTdHlsZXJQb3BvdmVyKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgcmVmZXJlbmNlRWxlbWVudCB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHBvcG92ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXJjZ2lzLXBvcHVwLXN0eWxlci1wb3BvdmVyXCIpO1xuICAgICAgICBwb3BvdmVyLnJlZmVyZW5jZUVsZW1lbnQgPSByZWZlcmVuY2VFbGVtZW50O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBvcG92ZXIpO1xuICAgICAgICBwb3BvdmVyLnNldE9wZW4odHJ1ZSk7XG4gICAgICAgIHBvcG92ZXIucmVwb3NpdGlvbigpO1xuICAgICAgICByZXR1cm4gcG9wb3ZlcjtcbiAgICB9XG4gICAgcmVtb3ZlU3ltYm9sU3R5bGVyUG9wb3Zlcihwb3BvdmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHBvcG92ZXIgPT09IG51bGwgfHwgcG9wb3ZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9wb3Zlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBwb3BvdmVyLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIChfYSA9IHBvcG92ZXIucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKHBvcG92ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpIHtcbiAgICAgICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1zeW1ib2wtc3R5bGVyXCIpO1xuICAgICAgICBzeW1ib2xTdHlsZXIuc3R5bGUgPSBcIm1heC1oZWlnaHQ6IG1heChjYWxjKDEwMHZoIC0gMjAwcHgpLCAzMDBweClcIjsgLy8gbm90IHRoZSBiZXN0LCBidXQgZWFzaWVzdFxuICAgICAgICBzeW1ib2xTdHlsZXIucG9wb3ZlclByb3BzID0ge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIixcbiAgICAgICAgICAgIG9mZnNldERpc3RhbmNlOiAxMCxcbiAgICAgICAgICAgIG9mZnNldFNraWRkaW5nOiBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiID8gMyA6IC0zLFxuICAgICAgICAgICAgcG9pbnRlckRpc2FibGVkOiBcInRydWVcIixcbiAgICAgICAgICAgIHBvcG92ZXJXaWR0aDogMzE1LFxuICAgICAgICAgICAgLy9vdmVybGF5UG9zaXRpb25pbmc6IFwiZml4ZWRcIiwgLS0gYnVnZ3ksIG9mZnNldCBpc3N1ZVxuICAgICAgICAgICAgcmVmRWxlbWVudDogYXdhaXQgcG9wb3Zlck5vZGUuZ2V0UG9wb3ZlclJlZkVsZW1lbnQoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3ltYm9sU3R5bGVyO1xuICAgIH1cbiAgICBhc3luYyBidWlsZFN5bWJvbFN0eWxlckZvclJhbXAob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG1hcFZpZXcsIHBvcnRhbCwgY29sb3JzLCBzdHJpbmdzLCBlc3JpTGFuZyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY3VycmVudENvbG9ycyA9IHRoaXMuZXNyaUxhbmcuY2xvbmUoY29sb3JzLmZpbHRlcigoXywgaWR4MikgPT4gaWR4MiA8IE1BWF9SQU1QX0NPTE9SUykpO1xuICAgICAgICBjb25zdCBzY2hlbWVzID0gdGhpcy5waWVDaGFydFNjaGVtZXMuZ2V0U2NoZW1lcyh7XG4gICAgICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwLFxuICAgICAgICAgICAgZ2VvbWV0cnlUeXBlOiBcInBvbHlnb25cIixcbiAgICAgICAgICAgIG51bUNvbG9yczogTWF0aC5taW4oTUFYX1JBTVBfQ09MT1JTLCBjb2xvcnMubGVuZ3RoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29sb3JSYW1wc0FuZFNjaGVtZXMgPSB0aGlzLmdldENvbG9yUmFtcHNXaXRoU2NoZW1lcyhzY2hlbWVzKTtcbiAgICAgICAgY29uc3QgY29sb3JSYW1wcyA9IGNvbG9yUmFtcHNBbmRTY2hlbWVzLm1hcCgob2JqKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0b3BzOiBvYmouY29sb3JzLnJldmVyc2UoKSxcbiAgICAgICAgICAgICAgICB0YWdzOiBvYmouc2NoZW1lLnRhZ3MsXG4gICAgICAgICAgICAgICAgbmFtZTogb2JqLnNjaGVtZS5uYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb25TdHlsZXJFZGl0ID0gKHsgZGV0YWlsOiB7IFxuICAgICAgICAvL3N5bWJvbCxcbiAgICAgICAgaW5mbzogeyAvKiBtYXJrZXIsIHN0cm9rZSwgKi8gZmlsbCB9IH0gfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgY29sb3JzID0gZXNyaUxhbmcuY2xvbmUoZmlsbC5jb2xvcikucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPCB0aGlzLmNvbG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBlYXRcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBjb2xvcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW47IGkgPCB0aGlzLmNvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMucHVzaCh0aGlzLmVzcmlMYW5nLmNsb25lKGNvbG9yc1tpICUgTUFYX1JBTVBfQ09MT1JTXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgoX2EgPSB0aGlzLmNoYXJ0TWVkaWFJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWUpLmNvbG9ycyA9IGNvbG9ycztcbiAgICAgICAgICAgIHRoaXMuY29sb3JzID0gY29sb3JzO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc1BvcHVwQ29sb3JCdXR0b25DaGFuZ2UuZW1pdCh0aGlzLmVzcmlMYW5nLmNsb25lKHRoaXMuY29sb3JzKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IHRoaXMuY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgICAgIGNvbnN0IGVkaXQgPSBzeW1ib2xTdHlsZXIuZWRpdChuZXcgdGhpcy5TaW1wbGVGaWxsU3ltYm9sKCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvci1yYW1wXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImRpc2NyZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUmFtcHNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvclJhbXBzLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbmN5OiBmYWxzZSAvLyB0ZW1wIC9hcmNnaXMtanMtYXBpL2lzc3Vlcy8yNzE4OFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY3VycmVudENvbG9ycy5yZXZlcnNlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN5bWJvbFN0eWxlci5zdHJpbmdPdmVycmlkZXMgPSB7XG4gICAgICAgICAgICBmaWxsQ29sb3I6IHN0cmluZ3MuY29sb3JcbiAgICAgICAgfTtcbiAgICAgICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJFZGl0XCIsIG9uU3R5bGVyRWRpdCk7XG4gICAgICAgIHBvcG92ZXJOb2RlLmFkZFN0eWxlcihzeW1ib2xTdHlsZXIpO1xuICAgICAgICBhd2FpdCBlZGl0O1xuICAgIH1cbiAgICBnZXRDb2xvclJhbXBzV2l0aFNjaGVtZXMoc2NoZW1lcykge1xuICAgICAgICBjb25zdCBhbGxTY2hlbWVzID0gW3NjaGVtZXMucHJpbWFyeVNjaGVtZV0uY29uY2F0KHNjaGVtZXMuc2Vjb25kYXJ5U2NoZW1lcyksIGNvbG9yUmFtcHNBbmRTY2hlbWVzID0gW107XG4gICAgICAgIGFsbFNjaGVtZXMuZm9yRWFjaCgoc2NoZW1lKSA9PiB7XG4gICAgICAgICAgICBjb2xvclJhbXBzQW5kU2NoZW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2xvcnM6IHNjaGVtZS5jb2xvcnMsXG4gICAgICAgICAgICAgICAgc2NoZW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2xvclJhbXBzQW5kU2NoZW1lcztcbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc1BvcHVwQ29sb3JCdXR0b24uc3R5bGUgPSBhcmNnaXNQb3B1cENvbG9yQnV0dG9uQ3NzO1xuXG5leHBvcnQgeyBBcmNnaXNQb3B1cENvbG9yQnV0dG9uIGFzIGFyY2dpc19wb3B1cF9jb2xvcl9idXR0b24gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJjZ2lzLXBvcHVwLWNvbG9yLWJ1dHRvbi5lbnRyeS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0UmVuZGVyaW5nUmVmLCBmIGFzIGZvcmNlVXBkYXRlIH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5cbmNvbnN0IGFwcGVuZFRvTWFwID0gKG1hcCwgcHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBtYXAuZ2V0KHByb3BOYW1lKTtcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgIG1hcC5zZXQocHJvcE5hbWUsIFt2YWx1ZV0pO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXRlbXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbn07XG5jb25zdCBkZWJvdW5jZSA9IChmbiwgbXMpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgfSwgbXMpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcG9zc2libGUgZWxlbWVudCBpc0Nvbm5lY3RlZC5cbiAqIFRoZSBwcm9wZXJ0eSBtaWdodCBub3QgYmUgdGhlcmUsIHNvIHdlIGNoZWNrIGZvciBpdC5cbiAqXG4gKiBXZSB3YW50IGl0IHRvIHJldHVybiB0cnVlIGlmIGlzQ29ubmVjdGVkIGlzIG5vdCBhIHByb3BlcnR5LFxuICogb3RoZXJ3aXNlIHdlIHdvdWxkIHJlbW92ZSB0aGVzZSBlbGVtZW50cyBhbmQgd291bGQgbm90IHVwZGF0ZS5cbiAqXG4gKiBCZXR0ZXIgbGVhayBpbiBFZGdlIHRoYW4gdG8gYmUgdXNlbGVzcy5cbiAqL1xuY29uc3QgaXNDb25uZWN0ZWQgPSAobWF5YmVFbGVtZW50KSA9PiAhKCdpc0Nvbm5lY3RlZCcgaW4gbWF5YmVFbGVtZW50KSB8fCBtYXliZUVsZW1lbnQuaXNDb25uZWN0ZWQ7XG5jb25zdCBjbGVhbnVwRWxlbWVudHMgPSBkZWJvdW5jZSgobWFwKSA9PiB7XG4gICAgZm9yIChsZXQga2V5IG9mIG1hcC5rZXlzKCkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcC5nZXQoa2V5KS5maWx0ZXIoaXNDb25uZWN0ZWQpKTtcbiAgICB9XG59LCAyMDAwKTtcbmNvbnN0IHN0ZW5jaWxTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnZXRSZW5kZXJpbmdSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBpbiBhIHN0ZW5jaWwgcHJvamVjdCwgd2UgZG8gbm90aGluZy5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IGV4cG9ydGVkIGJ5IEBzdGVuY2lsL2NvcmUuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZWxtc1RvVXBkYXRlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IGVsbXNUb1VwZGF0ZS5jbGVhcigpLFxuICAgICAgICBnZXQ6IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxtID0gZ2V0UmVuZGVyaW5nUmVmKCk7XG4gICAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kVG9NYXAoZWxtc1RvVXBkYXRlLCBwcm9wTmFtZSwgZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxtc1RvVXBkYXRlLmdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBlbG1zVG9VcGRhdGUuc2V0KHByb3BOYW1lLCBlbGVtZW50cy5maWx0ZXIoZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgZWxtc1RvVXBkYXRlLmZvckVhY2goKGVsbXMpID0+IGVsbXMuZm9yRWFjaChmb3JjZVVwZGF0ZSkpO1xuICAgICAgICAgICAgY2xlYW51cEVsZW1lbnRzKGVsbXNUb1VwZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IHVud3JhcCA9ICh2YWwpID0+ICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID8gdmFsKCkgOiB2YWwpO1xuY29uc3QgY3JlYXRlT2JzZXJ2YWJsZU1hcCA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSA9IChhLCBiKSA9PiBhICE9PSBiKSA9PiB7XG4gICAgY29uc3QgdW53cmFwcGVkU3RhdGUgPSB1bndyYXAoZGVmYXVsdFN0YXRlKTtcbiAgICBsZXQgc3RhdGVzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyh1bndyYXBwZWRTdGF0ZSAhPT0gbnVsbCAmJiB1bndyYXBwZWRTdGF0ZSAhPT0gdm9pZCAwID8gdW53cmFwcGVkU3RhdGUgOiB7fSkpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgICBkaXNwb3NlOiBbXSxcbiAgICAgICAgZ2V0OiBbXSxcbiAgICAgICAgc2V0OiBbXSxcbiAgICAgICAgcmVzZXQ6IFtdLFxuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gV2hlbiByZXNldHRpbmcgdGhlIHN0YXRlLCB0aGUgZGVmYXVsdCBzdGF0ZSBtYXkgYmUgYSBmdW5jdGlvbiAtIHVud3JhcCBpdCB0byBpbnZva2UgaXQuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIHN0YXRlIHdvbid0IGJlIHByb3Blcmx5IHJlc2V0XG4gICAgICAgIHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoKF9hID0gdW53cmFwKGRlZmF1bHRTdGF0ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KSk7XG4gICAgICAgIGhhbmRsZXJzLnJlc2V0LmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIENhbGwgZmlyc3QgZGlzcG9zZSBhcyByZXNldHRpbmcgdGhlIHN0YXRlIHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIGxlc3MgdXBkYXRlcyA7KVxuICAgICAgICBoYW5kbGVycy5kaXNwb3NlLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCA9IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICBoYW5kbGVycy5nZXQuZm9yRWFjaCgoY2IpID0+IGNiKHByb3BOYW1lKSk7XG4gICAgICAgIHJldHVybiBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldCA9IChwcm9wTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSh2YWx1ZSwgb2xkVmFsdWUsIHByb3BOYW1lKSkge1xuICAgICAgICAgICAgc3RhdGVzLnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSwgdmFsdWUsIG9sZFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN0YXRlID0gKHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB7fVxuICAgICAgICA6IG5ldyBQcm94eSh1bndyYXBwZWRTdGF0ZSwge1xuICAgICAgICAgICAgZ2V0KF8sIHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3duS2V5cyhfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGVzLmtleXMoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhcyhfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXMuaGFzKHByb3BOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoXywgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgY29uc3Qgb24gPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBoYW5kbGVyc1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGhhbmRsZXJzW2V2ZW50TmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKHByb3BOYW1lLCBjYikgPT4ge1xuICAgICAgICBjb25zdCB1blNldCA9IG9uKCdzZXQnLCAoa2V5LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVud3JhcCB0aGUgZGVmYXVsdFN0YXRlIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG1pZ2h0IG5vdCBiZSBzZW5kaW5nIHRoZSByaWdodCByZXNldCB2YWx1ZS5cbiAgICAgICAgY29uc3QgdW5SZXNldCA9IG9uKCdyZXNldCcsICgpID0+IGNiKHVud3JhcChkZWZhdWx0U3RhdGUpW3Byb3BOYW1lXSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdW5TZXQoKTtcbiAgICAgICAgICAgIHVuUmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZSA9ICguLi5zdWJzY3JpcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3VicyA9IHN1YnNjcmlwdGlvbnMucmVkdWNlKCh1bnN1YnMsIHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignc2V0Jywgc3Vic2NyaXB0aW9uLnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5nZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignZ2V0Jywgc3Vic2NyaXB0aW9uLmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5yZXNldCkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdyZXNldCcsIHN1YnNjcmlwdGlvbi5yZXNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5kaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2Rpc3Bvc2UnLCBzdWJzY3JpcHRpb24uZGlzcG9zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuc3VicztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5zdWJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHN0YXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihrZXksIG9sZFZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0LFxuICAgICAgICBvbixcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIHVzZSxcbiAgICAgICAgZGlzcG9zZSxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIGZvcmNlVXBkYXRlLFxuICAgIH07XG59O1xuY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gKGFycmF5LCBpdGVtKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBhcnJheS5sZW5ndGgtLTtcbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGNyZWF0ZU9ic2VydmFibGVNYXAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpO1xuICAgIG1hcC51c2Uoc3RlbmNpbFN1YnNjcmlwdGlvbigpKTtcbiAgICByZXR1cm4gbWFwO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUgYXMgYyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC0wNTk1NmNhYi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tNGQzNjc2NzcuanMnO1xuXG5jb25zdCBsYW5ndWFnZU1hcCA9IG5ldyBNYXAoW1xuICAgIFtcImFyXCIsIFwiYXJcIl0sXG4gICAgW1wiYmdcIiwgXCJiZ1wiXSxcbiAgICBbXCJic1wiLCBcImJzXCJdLFxuICAgIFtcImNhXCIsIFwiY2FcIl0sXG4gICAgW1wiY3NcIiwgXCJjc1wiXSxcbiAgICBbXCJkYVwiLCBcImRhXCJdLFxuICAgIFtcImRlXCIsIFwiZGVcIl0sXG4gICAgW1wiZWxcIiwgXCJlbFwiXSxcbiAgICBbXCJlblwiLCBcImVuXCJdLFxuICAgIFtcImVzXCIsIFwiZXNcIl0sXG4gICAgW1wiZXRcIiwgXCJldFwiXSxcbiAgICBbXCJmaVwiLCBcImZpXCJdLFxuICAgIFtcImZyXCIsIFwiZnJcIl0sXG4gICAgW1wiaGVcIiwgXCJoZVwiXSxcbiAgICBbXCJoclwiLCBcImhyXCJdLFxuICAgIFtcImh1XCIsIFwiaHVcIl0sXG4gICAgW1wiaWRcIiwgXCJpZFwiXSxcbiAgICBbXCJpdFwiLCBcIml0XCJdLFxuICAgIFtcImphXCIsIFwiamFcIl0sXG4gICAgW1wia29cIiwgXCJrb1wiXSxcbiAgICBbXCJsdFwiLCBcImx0XCJdLFxuICAgIFtcImx2XCIsIFwibHZcIl0sXG4gICAgW1wibmJcIiwgXCJuYlwiXSxcbiAgICBbXCJubFwiLCBcIm5sXCJdLFxuICAgIFtcInBsXCIsIFwicGxcIl0sXG4gICAgW1wicHQtYnJcIiwgXCJwdC1CUlwiXSxcbiAgICBbXCJwdC1wdFwiLCBcInB0LVBUXCJdLFxuICAgIFtcInJvXCIsIFwicm9cIl0sXG4gICAgW1wicnVcIiwgXCJydVwiXSxcbiAgICBbXCJza1wiLCBcInNrXCJdLFxuICAgIFtcInNsXCIsIFwic2xcIl0sXG4gICAgW1wic3JcIiwgXCJzclwiXSxcbiAgICBbXCJzdlwiLCBcInN2XCJdLFxuICAgIFtcInRoXCIsIFwidGhcIl0sXG4gICAgW1widHJcIiwgXCJ0clwiXSxcbiAgICBbXCJ1a1wiLCBcInVrXCJdLFxuICAgIFtcInZpXCIsIFwidmlcIl0sXG4gICAgW1wiemgtY25cIiwgXCJ6aC1DTlwiXSxcbiAgICBbXCJ6aC1oa1wiLCBcInpoLUhLXCJdLFxuICAgIFtcInpoLXR3XCIsIFwiemgtVFdcIl1cbl0pO1xuLy8gcnRsXG5mdW5jdGlvbiBnZXRFbGVtZW50RGlyKGVsKSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRQcm9wKGVsLCBcImRpclwiLCBcImx0clwiKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRQcm9wKGVsLCBwcm9wLCB2YWx1ZSkge1xuICAgIGNvbnN0IGNsb3Nlc3RXaXRoUHJvcCA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbCwgYFske3Byb3B9XWApO1xuICAgIHJldHVybiBjbG9zZXN0V2l0aFByb3AgPyBjbG9zZXN0V2l0aFByb3AuZ2V0QXR0cmlidXRlKHByb3ApIDogdmFsdWU7XG59XG4vLyBjc3NcbmNvbnN0IENTU19VVElMSVRZID0ge1xuICAgIHJ0bDogXCJhcmNnaXMtLXJ0bFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bWJlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXBpLCB0eXBlLCBwbGFjZXMgfSA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKGFwaSA9PT0gNCkge1xuICAgICAgICBjb25zdCBbaW50bF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2ludGxcIl0pO1xuICAgICAgICBjb25zdCBudW1iZXJGb3JtYXRJbnRsT3B0aW9ucyA9IGludGwuY29udmVydE51bWJlckZvcm1hdFRvSW50bE9wdGlvbnMoe1xuICAgICAgICAgICAgcGxhY2VzLFxuICAgICAgICAgICAgc3R5bGU6IHR5cGUsXG4gICAgICAgICAgICBkaWdpdFNlcGFyYXRvcjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGludGwuZm9ybWF0TnVtYmVyKG51bWJlciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBudW1iZXJGb3JtYXRJbnRsT3B0aW9ucyksIHsgc3R5bGU6IHR5cGUgfSkpO1xuICAgIH1cbiAgICBjb25zdCBbZG9qb051bWJlcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJkb2pvL251bWJlclwiXSk7XG4gICAgcmV0dXJuIGRvam9OdW1iZXIuZm9ybWF0KG51bWJlciwge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwbGFjZXMsXG4gICAgICAgIHBhdHRlcm46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXR0ZXJuXG4gICAgfSk7XG59XG5jb25zdCBjYWNoZSA9IHt9O1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gICAgY29uc3QgbGFuZyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nO1xuICAgIGNvbnN0IGRheVNob3J0TW9udGhZZWFyID0ge1xuICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgICAgbW9udGg6IFwic2hvcnRcIixcbiAgICAgICAgZGF5OiBcIm51bWVyaWNcIlxuICAgIH07XG4gICAgaWYgKCFjYWNoZVtsYW5nXSkge1xuICAgICAgICBjYWNoZVtsYW5nXSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nLCBkYXlTaG9ydE1vbnRoWWVhcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtsYW5nXS5mb3JtYXQoZGF0ZSk7XG59XG5mdW5jdGlvbiBmb3JtYXRQbHVyYWwobGFuZywgc3RyaW5nT2JqLCBudW1iZXIpIHtcbiAgICBjb25zdCBzaW5nbGVzID0gW1wiaWRcIiwgXCJqYVwiLCBcImtvXCIsIFwidGhcIiwgXCJ2aVwiLCBcInpoLWNuXCIsIFwiemgtaGtcIiwgXCJ6aC10d1wiXTtcbiAgICBjb25zdCBsaWtlRW5nbGlzaCA9IFtcbiAgICAgICAgXCJlblwiLFxuICAgICAgICBcImNhXCIsXG4gICAgICAgIFwiZGFcIixcbiAgICAgICAgXCJkZVwiLFxuICAgICAgICBcImVsXCIsXG4gICAgICAgIFwiZXNcIixcbiAgICAgICAgXCJldFwiLFxuICAgICAgICBcImZpXCIsXG4gICAgICAgIFwiaGlcIixcbiAgICAgICAgXCJodVwiLFxuICAgICAgICBcIml0XCIsXG4gICAgICAgIFwibmJcIixcbiAgICAgICAgXCJubFwiLFxuICAgICAgICBcInB0LXB0XCIsXG4gICAgICAgIFwic3ZcIixcbiAgICAgICAgXCJ0clwiXG4gICAgXTtcbiAgICBjb25zdCBsb2NhbGUgPSBsYW5nICE9PSBudWxsICYmIGxhbmcgIT09IHZvaWQgMCA/IGxhbmcgOiBcImVuXCI7XG4gICAgLy8gaWYgdGhlIG51bWJlciBpcyBvbmUsIG9yIGl0IGlzIGEgXCJzaW1wbGVcIiBsYW5ndWFnZSwgcmV0dXJuIHRoZSAxIHN0cmluZ1xuICAgIGlmIChudW1iZXIgPT09IDEgfHwgc2luZ2xlcy5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdPYmouc2luZ2xlLnJlcGxhY2UoXCIke251bWJlcn1cIiwgXCIxXCIpO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIG5vdCAxIGFuZCB0aGUgbGFuZ3VhZ2UgdXNlcyB0aGUgc2FtZSBwbHVyYWxpemF0aW9uIHN0cmF0ZWd5IGFzIGVuZ2xpc2gsXG4gICAgLy8gcmV0dXJuIHRoZSBtdWx0aXBsZSBzdHJpbmdcbiAgICBpZiAobnVtYmVyICE9PSAxICYmIGxpa2VFbmdsaXNoLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ09iai5tdWx0aXBsZS5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIGAke251bWJlcn1gKTtcbiAgICB9XG4gICAgLy8gaWYgbm9uZSBvZiB0aGUgYWJvdmUgd29ya2VkLCByZXR1cm4gdGhlIFwidW5rbm93blwiIHN0cmluZ1xuICAgIHJldHVybiBzdHJpbmdPYmoudW5rbm93bi5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIGAke251bWJlcn1gKTtcbn1cblxuZXhwb3J0IHsgQ1NTX1VUSUxJVFkgYXMgQywgZm9ybWF0RGF0ZSBhcyBhLCBmb3JtYXRQbHVyYWwgYXMgYiwgZm9ybWF0TnVtYmVyIGFzIGYsIGdldEVsZW1lbnREaXIgYXMgZywgbGFuZ3VhZ2VNYXAgYXMgbCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBjIGFzIGNyZWF0ZVN0b3JlIH0gZnJvbSAnLi9pbmRleC0wNTk1NmNhYi5qcyc7XG5cbmNvbnN0IHBvcHVwU3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgbGF5ZXI6IG51bGwsXG4gICAgbWFwVmlldzogbnVsbCxcbiAgICBwb3J0YWw6IG51bGwsXG4gICAgY29uZmlnOiBudWxsLFxuICAgIHN0cmluZ3M6IG51bGwsXG4gICAgY3VycmVudExhbmd1YWdlOiBudWxsLFxuICAgIGN1cnJlbnRMYW5ndWFnZUludGw6IG51bGwsXG4gICAgc2VydmljZVR5cGU6IG51bGwsXG4gICAgcG9wdXBUZW1wbGF0ZTogbnVsbCxcbiAgICBsYXllckhhc0F0dGFjaG1lbnQ6IG51bGwsXG4gICAgbGF5ZXJIYXNFVDogbnVsbCxcbiAgICBsYXllckhhc0F0dHJpYnV0ZXM6IG51bGwsXG4gICAgbGF5ZXJIYXNDaGFydHM6IG51bGwsXG4gICAgbGF5ZXJIYXNJbWFnZXM6IG51bGwsXG4gICAgbGF5ZXJIYXNUZXh0OiBudWxsLFxuICAgIGxheWVyRGlzcGxheVR5cGU6IG51bGwsXG4gICAgc3VwcG9ydHNBcmNhZGU6IG51bGwsXG4gICAgbGF5ZXJIYXNSZWxhdGVkUmVjb3JkczogZmFsc2Vcbn0pO1xuLy8gd29ya2Fyb3VuZCBmb3Igc3RhcnRpbmcgYSBwYW5lbCB3aXRoIGEgY2xlYW4gc3RhdGVcbmZ1bmN0aW9uIGNsZWFyUG9wdXBTdGF0ZShwb3B1cFN0YXRlKSB7XG4gICAgcG9wdXBTdGF0ZS5sYXllciA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5tYXBWaWV3ID0gbnVsbDtcbiAgICBwb3B1cFN0YXRlLnBvcnRhbCA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5jb25maWcgPSBudWxsO1xuICAgIHBvcHVwU3RhdGUuc3RyaW5ncyA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5jdXJyZW50TGFuZ3VhZ2UgPSBudWxsO1xuICAgIHBvcHVwU3RhdGUuY3VycmVudExhbmd1YWdlSW50bCA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5zZXJ2aWNlVHlwZSA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5wb3B1cFRlbXBsYXRlID0gbnVsbDtcbiAgICBwb3B1cFN0YXRlLmxheWVySGFzQXR0YWNobWVudCA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5sYXllckhhc0VUID0gbnVsbDtcbiAgICBwb3B1cFN0YXRlLmxheWVySGFzQXR0cmlidXRlcyA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5sYXllckhhc0NoYXJ0cyA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5sYXllckhhc0ltYWdlcyA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5sYXllckhhc1RleHQgPSBudWxsO1xuICAgIHBvcHVwU3RhdGUubGF5ZXJEaXNwbGF5VHlwZSA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5zdXBwb3J0c0FyY2FkZSA9IG51bGw7XG4gICAgcG9wdXBTdGF0ZS5sYXllckhhc1JlbGF0ZWRSZWNvcmRzID0gZmFsc2U7XG59XG5jb25zdCBwb3B1cFN0YXRlID0gcG9wdXBTdG9yZS5zdGF0ZTtcblxuZXhwb3J0IHsgY2xlYXJQb3B1cFN0YXRlIGFzIGMsIHBvcHVwU3RhdGUgYXMgcCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3B1cFN0b3JlLTg1MzgxNDUzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==