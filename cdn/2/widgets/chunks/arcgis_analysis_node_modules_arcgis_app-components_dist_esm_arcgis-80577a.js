"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-80577a"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-multidimensional.entry.js":
/*!*********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-multidimensional.entry.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_raster_multidimensional: () => (/* binding */ ArcgisRasterMultidimensional)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./multidimensional-69f3968f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-69f3968f.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */










const arcgisRasterMultidimensionalCss = ":host{display:flex;flex:1 1 auto;overflow:hidden}.variable-section-boarder{border:1px solid var(--arcgis-app-border)}.variable-select{display:flex;justify-content:center}.multidimensional-extent>div{margin:10px 0}.multidimensional-extent-compact{display:flex;width:100%}.multidimensional-extent-compact>div{width:50%}.multidimensional-extent-compact>div:first-child{margin:0 20px 0 0}.multidimensional-unsupported{margin:20px}.dimension-zone{padding:10px;border:1px solid var(--arcgis-app-border);margin:10px 0}.dimension-select-container{display:flex;width:100%;align-items:center}.dimension-select-container .dimension-select{flex-grow:1}.arcgis--rtl .extent-compact>div:first-child{margin:0 0 0 20px}";

const undefined_dimension_value = Number.MAX_VALUE - 1;
const ArcgisRasterMultidimensional = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisRasterMultidimensionalChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisRasterMultidimensionalChange", 7);
        this.arcgisRasterMultidimensionalSave = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisRasterMultidimensionalSave", 7);
        this.arcgisRasterMultidimensionalCancel = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisRasterMultidimensionalCancel", 7);
        this.valuePickers = {
            time: null,
            z: null
        };
        this.containerTop = 0;
        this.aoiIndex = 0;
        this.previousPickedListSize = -1;
        this.pauseLayerUpdate = false;
        this.apply = () => {
            var _a;
            if (!this.multidimensionalInfo) {
                return;
            }
            this.originalLayerSetting.definition = this.esriLang.clone(this.activeMultidimensionalDefinition);
            this.originalLayerSetting.subset = this.activeMultidimensionalSubset.clone();
            const { layer } = this;
            if (this.isImageryLayer(layer)) {
                this.originalLayerSetting.mosaicRule = (_a = layer.mosaicRule) === null || _a === void 0 ? void 0 : _a.clone();
            }
            if (!this.makeLiveLayerUpdate) {
                this.updateLayerMultidimensionalDefinition();
                this.updateLayerMultidimensionalSubset();
            }
            this.closePopover();
            this.arcgisRasterMultidimensionalSave.emit();
        };
        this.cancel = () => {
            if (!this.multidimensionalInfo) {
                return;
            }
            const { layer, originalLayerSetting } = this;
            const definition = this.esriLang.clone(originalLayerSetting.definition);
            const subset = this.esriLang.clone(originalLayerSetting.subset);
            if (this.updateStateWhenCancel) {
                this.pauseLayerUpdate = true;
                this.activeMultidimensionalSubset = subset !== null && subset !== void 0 ? subset : this.getDefaultMultidimensionalSubset();
                this.activeMultidimensionalDefinition = definition;
                this.pauseLayerUpdate = false;
            }
            if (this.isImageryLayer(layer)) {
                layer.mosaicRule = originalLayerSetting.mosaicRule;
            }
            else {
                layer.multidimensionalDefinition = definition;
            }
            layer.renderer = originalLayerSetting.renderer;
            layer.multidimensionalSubset = subset;
            this.closePopover();
            this.arcgisRasterMultidimensionalCancel.emit();
        };
        this.updateDefinitionDimensionValue = (selectedDimensionName, value, updateValuePicker = false) => {
            var _a, _b;
            const newDef = this.esriLang.clone(this.activeMultidimensionalDefinition);
            const selectedDef = newDef.find(({ dimensionName }) => dimensionName === selectedDimensionName);
            selectedDef.values = [value];
            this.activeMultidimensionalDefinition = newDef;
            if (!updateValuePicker) {
                return;
            }
            // find the matching value picker
            const { valuePickers } = this;
            const valuePicker = ((_a = valuePickers.time) === null || _a === void 0 ? void 0 : _a.dimensionName) === selectedDimensionName
                ? valuePickers.time
                : ((_b = valuePickers.z) === null || _b === void 0 ? void 0 : _b.dimensionName) === selectedDimensionName
                    ? valuePickers.z
                    : null;
            if (valuePicker) {
                const index = valuePicker.dimensionValues.findIndex((dimValue) => Array.isArray(value) && Array.isArray(dimValue)
                    ? value.join("-") === dimValue.join("-")
                    : value === dimValue);
                valuePicker.slider.values = this.getSelectedSliderValue(index, valuePicker.slider.component.reversed, valuePicker.dimensionValues.length);
            }
        };
        this.updateDefinitionVariableName = (variableName) => {
            // normalize empty variable name (3.x), * (rft result), default variable string UI
            if (this.isDefaultUnspecifiedVariable(variableName)) {
                variableName = "";
            }
            const newDef = this.getNewMultidimensionalDefinition(variableName);
            this.activeMultidimensionalDefinition = newDef;
        };
        this.updateExtentDimensionSubset = (selectedDimensionName, valueOrExtent, replaceBoth = "both") => {
            const { activeMultidimensionalSubset } = this;
            const dim = activeMultidimensionalSubset.dimensions.find((dimension) => dimension.name === selectedDimensionName);
            const dimExtent = [...dim.extent];
            if (replaceBoth === "both") {
                // avoid updating when existing value matches new value
                if (dimExtent[0] === valueOrExtent[0] && dimExtent[1] === valueOrExtent[1]) {
                    return;
                }
                [dimExtent[0], dimExtent[1]] = valueOrExtent;
            }
            else if (replaceBoth === "start") {
                let wasNotRange = dimExtent[1] === dimExtent[0];
                dimExtent[0] = Array.isArray(valueOrExtent) ? valueOrExtent[0] : valueOrExtent;
                if (wasNotRange) {
                    dimExtent[1] = dimExtent[0];
                }
            }
            else {
                if (valueOrExtent === undefined_dimension_value) {
                    dimExtent[1] = dimExtent[0];
                }
                else {
                    dimExtent[1] = Array.isArray(valueOrExtent)
                        ? valueOrExtent[valueOrExtent.length - 1]
                        : valueOrExtent;
                }
            }
            if (dimExtent[1] < dimExtent[0] || dimExtent[1] == null) {
                dimExtent[1] = dimExtent[0];
            }
            const newActiveSubset = activeMultidimensionalSubset.clone();
            const { subsetDefinitions } = newActiveSubset;
            subsetDefinitions.forEach((def) => {
                if (def.dimensionName === selectedDimensionName) {
                    def.values = [dimExtent[0], dimExtent[1]];
                }
            });
            this.activeMultidimensionalSubset = newActiveSubset;
            const { animatedDimensions } = this;
            const hasTimePicker = animatedDimensions.time === selectedDimensionName;
            const hasZPicker = animatedDimensions.z === selectedDimensionName;
            if (hasTimePicker || hasZPicker) {
                const variableInfo = this.getVariableInfo(this.activeMultidimensionalDefinition[0].variableName);
                const dimInfo = variableInfo === null || variableInfo === void 0 ? void 0 : variableInfo.dimensions.find(({ name }) => name === selectedDimensionName);
                this.createValuePicker(dimInfo);
                // when there's single or 0 (can it be 0?) slices, keep enabled state as it's clipped by extent
                if (hasTimePicker) {
                    animatedDimensions.time = selectedDimensionName;
                }
                else {
                    animatedDimensions.z = selectedDimensionName;
                }
            }
        };
        this.updateExtentVariables = (selectedVariables) => {
            let { activeMultidimensionalSubset } = this;
            if (selectedVariables.length &&
                activeMultidimensionalSubset.variables.length &&
                selectedVariables.join(",") === activeMultidimensionalSubset.variables.join(",")) {
                return;
            }
            this.previousPickedListSize = selectedVariables.length;
            if (selectedVariables.length === 0) {
                selectedVariables = this.allVariables.map(({ name }) => name);
            }
            // start wtih default dimensions, use existing definition when exist, remove dimensions that are no longer part of selected variables
            const selectedDefaultSubset = this.getDefaultMultidimensionalSubset(selectedVariables);
            const { subsetDefinitions } = selectedDefaultSubset.clone();
            subsetDefinitions.forEach((defaultDef) => {
                const matchingDefinition = activeMultidimensionalSubset.subsetDefinitions.find((def) => def.variableName === defaultDef.variableName &&
                    def.dimensionName === defaultDef.dimensionName);
                if (matchingDefinition) {
                    defaultDef.values = matchingDefinition.values;
                }
                else {
                    const matchingDimensionExtent = activeMultidimensionalSubset.dimensions.find((dimension) => dimension.name === defaultDef.dimensionName);
                    if (matchingDimensionExtent) {
                        defaultDef.values = [...matchingDimensionExtent.extent];
                    }
                }
            });
            const newAtiveMultidimensionalSubset = activeMultidimensionalSubset.clone();
            newAtiveMultidimensionalSubset.subsetDefinitions = subsetDefinitions;
            this.activeMultidimensionalSubset = newAtiveMultidimensionalSubset;
        };
        this.updateExtentAOI = (aoi) => {
            const newAtiveMultidimensionalSubset = this.activeMultidimensionalSubset.clone();
            newAtiveMultidimensionalSubset.areaOfInterest = aoi === null || aoi === void 0 ? void 0 : aoi.clone();
            this.activeMultidimensionalSubset = newAtiveMultidimensionalSubset;
        };
        this.updateExtentFromTime = (timeExtent) => {
            if (!this.multidimensionalInfo) {
                return;
            }
            const originalDef = this.esriLang.clone(this.originalLayerSetting.definition);
            // todo expose this a utilty function in API
            const { multidimensionalDefinition: newDef } = this.layer.normalizeRasterFetchOptions({
                multidimensionalDefinition: originalDef,
                timeExtent
            });
            if (newDef && this.isPropertyValueChanged(newDef, this.activeMultidimensionalDefinition)) {
                this.activeMultidimensionalDefinition = newDef;
            }
        };
        this.updateSorting = (dimensionName) => {
            // not initialized (undefined) will be changed to descending
            const sortDirections = Object.assign({}, this.sortDirections);
            sortDirections[dimensionName] =
                sortDirections[dimensionName] === "descending" ? "ascending" : "descending";
            this.sortDirections = sortDirections;
        };
        this.updateLayerMultidimensionalDefinition = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.d)(() => {
            var _a, _b, _c;
            const { activeMultidimensionalDefinition, layer } = this;
            const isDynamicImagery = this.isImageryLayer(layer);
            const isDefinitionChanged = isDynamicImagery
                ? this.isPropertyValueChanged(activeMultidimensionalDefinition, (_a = layer.mosaicRule) === null || _a === void 0 ? void 0 : _a.multidimensionalDefinition)
                : this.isPropertyValueChanged(activeMultidimensionalDefinition, layer.multidimensionalDefinition);
            if (!isDefinitionChanged) {
                return;
            }
            const oldDefinition = this.getMultidimensionalDefinition(layer);
            const isVariableChanged = !oldDefinition ||
                oldDefinition.length === 0 ||
                oldDefinition[0].variableName !== activeMultidimensionalDefinition[0].variableName;
            if (isDynamicImagery) {
                const mosaicRule = ((_b = layer.mosaicRule) !== null && _b !== void 0 ? _b : layer.defaultMosaicRule).clone();
                if (this.isDefaultUnspecifiedVariable(activeMultidimensionalDefinition[0].variableName)) {
                    const newDefinition = activeMultidimensionalDefinition.map((def) => {
                        const newDef = def.clone();
                        newDef.variableName = "";
                        return newDef;
                    });
                    mosaicRule.multidimensionalDefinition = newDefinition;
                }
                else {
                    mosaicRule.multidimensionalDefinition = activeMultidimensionalDefinition;
                }
                layer.mosaicRule = mosaicRule;
            }
            else {
                layer.multidimensionalDefinition = activeMultidimensionalDefinition;
            }
            if (isVariableChanged) {
                const variableInfo = this.getVariableInfo(activeMultidimensionalDefinition[0].variableName);
                const { renderer } = layer;
                if ((renderer === null || renderer === void 0 ? void 0 : renderer.type) === "raster-stretch" && ((_c = variableInfo.statistics) === null || _c === void 0 ? void 0 : _c.length)) {
                    const newRenderer = renderer.clone();
                    newRenderer.statistics = variableInfo.statistics.map((stats) => (Object.assign({}, stats)));
                    layer.renderer = newRenderer;
                }
            }
        }, 100);
        this.updateLayerMultidimensionalSubset = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.d)(() => {
            const { activeMultidimensionalSubset, layer } = this;
            const fullDimensionalSubset = this.getDefaultMultidimensionalSubset();
            // this is a simple comparison (to default) to optimize persisted layer's size
            // it does no harm if a custom layer contains definitions with altered variable order.
            const isSubsetDefinitionsSpecified = this.isPropertyValueChanged(activeMultidimensionalSubset.subsetDefinitions, fullDimensionalSubset.subsetDefinitions);
            const isAOISpecified = activeMultidimensionalSubset.areaOfInterest != null;
            if (!isSubsetDefinitionsSpecified && !isAOISpecified) {
                layer.multidimensionalSubset = null;
            }
            else {
                if (!isSubsetDefinitionsSpecified) {
                    const newSubset = activeMultidimensionalSubset.clone();
                    newSubset.subsetDefinitions = [];
                    layer.multidimensionalSubset = newSubset;
                }
                else {
                    layer.multidimensionalSubset = activeMultidimensionalSubset;
                }
            }
        }, 100);
        this.hidePanelHeading = false;
        this.panelHeading = undefined;
        this.dismissible = false;
        this.hideButtons = false;
        this.hideExtentSection = false;
        this.hideAOI = false;
        this.isDimensionListSortable = false;
        this.collapseExtentSection = false;
        this.useCompactExtentDropdowns = false;
        this.showVariableFilter = undefined;
        this.watchViewTime = false;
        this.watchRasterFunction = false;
        this.updateStateWhenCancel = true;
        this.makeLiveLayerUpdate = true;
        this.showAnimationControls = false;
        this.showAnimationOnStartUp = false;
        this.showAnimationTooltip = false;
        this.animationSetting = {
            playRate: 3000,
            timeClassName: "imagery-dimension-picker-t",
            zClassName: "imagery-dimension-picker-z",
            timeTooltipPlacement: "top",
            zTooltipPlacement: "auto"
        };
        this.layer = undefined;
        this.view = undefined;
        this.multidimensionalInfo = undefined;
        this.activeMultidimensionalDefinition = undefined;
        this.activeMultidimensionalSubset = undefined;
        this.sortDirections = {};
        this.animatedDimensions = { time: "", z: "" };
    }
    watchLayer(newValue, _oldValue) {
        var _a, _b;
        this.closePopover();
        this.multidimensionalInfo = null;
        (_a = this.watchHandleViewTime) === null || _a === void 0 ? void 0 : _a.remove();
        this.watchHandleLayer = null;
        (_b = this.watchHandleLayer) === null || _b === void 0 ? void 0 : _b.remove();
        this.watchHandleLayer = null;
        this.initLayer(newValue);
    }
    watchActiveMultidimensionalDefinition(newValue, oldValue) {
        // oldValue is null during initialization, newValue can't be null
        if (newValue == null || oldValue == null) {
            return;
        }
        this.sortDirections = {};
        if (!this.pauseLayerUpdate && this.makeLiveLayerUpdate) {
            this.updateLayerMultidimensionalDefinition();
        }
        this.arcgisRasterMultidimensionalChange.emit({
            multidimensionalDefinition: newValue
        });
        // destroy value picker when the corresponding dimension does not exist for the new variable
        const { animatedDimensions, showAnimationControls } = this;
        if (showAnimationControls &&
            (animatedDimensions.time || animatedDimensions.z) &&
            newValue[0].variableName !== oldValue[0].variableName) {
            const variableInfo = this.getVariableInfo(newValue[0].variableName);
            if (!variableInfo.dimensions.some(({ name }) => name === animatedDimensions.time)) {
                this.destroyValuePicker("time");
            }
            if (!variableInfo.dimensions.some(({ name }) => name === animatedDimensions.z)) {
                this.destroyValuePicker("z");
            }
        }
    }
    watchactiveMultidimensionalSubset(newValue, _oldValue) {
        var _a;
        // todo: API support
        if (!this.pauseLayerUpdate && this.makeLiveLayerUpdate) {
            this.updateLayerMultidimensionalSubset();
        }
        const { activeMultidimensionalDefinition } = this;
        if (((_a = newValue.variables) === null || _a === void 0 ? void 0 : _a.length) && (activeMultidimensionalDefinition === null || activeMultidimensionalDefinition === void 0 ? void 0 : activeMultidimensionalDefinition.length)) {
            // use original order
            const variableNames = this.allVariables
                .filter(({ name }) => newValue.variables.includes(name))
                .map(({ name }) => name);
            const activeVariableName = activeMultidimensionalDefinition[0].variableName;
            const newVariableName = activeVariableName === "" || newValue.variables.includes(activeVariableName)
                ? activeVariableName
                : variableNames[0];
            const newDef = this.getNewMultidimensionalDefinition(newVariableName);
            const isDefinitionChanged = this.isMultidimensionalDefinitionChanged(newDef);
            if (isDefinitionChanged) {
                this.activeMultidimensionalDefinition = newDef;
            }
        }
        const data = {
                multidimensionalSubset: newValue
            };
        this.arcgisRasterMultidimensionalChange.emit(data);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        [this.strings] = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement);
        [
            this.esriLang,
            this.intl,
            this.DimensionalDefinition,
            this.MultidimensionalSubset,
            this.ValuePicker
        ] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_3__.l)([
            "esri/core/lang",
            "esri/intl",
            "esri/layers/support/DimensionalDefinition",
            "esri/layers/support/MultidimensionalSubset",
            "esri/widgets/ValuePicker"
        ]);
        const { layer } = this;
        if (layer.loaded) {
            // load multidimensional info (may or may not involve actual async fetching)
            await this.initLayer(layer);
        }
        else {
            // load layer (show loading sign) and multidimensional info
            this.initLayer(layer);
        }
        this.containerTop = this.hostElement.getBoundingClientRect().top;
    }
    disconnectedCallback() {
        var _a, _b;
        this.closePopover();
        this.destroyValuePicker("both");
        (_a = this.watchHandleViewTime) === null || _a === void 0 ? void 0 : _a.remove();
        (_b = this.watchHandleLayer) === null || _b === void 0 ? void 0 : _b.remove();
    }
    // --------------------------------------------------------------------------
    //
    //  public methods
    //
    // --------------------------------------------------------------------------
    async setFocus(focusId) {
        var _a;
        if (focusId === "dismiss-button" || (!focusId && this.dismissible)) {
            (_a = this.refCloseButtonNode) === null || _a === void 0 ? void 0 : _a.setFocus();
        }
        else {
            this.refPanelNode.setFocus();
        }
    }
    async done() {
        this.apply();
    }
    // --------------------------------------------------------------------------
    //
    //  Renderer methods
    //
    // --------------------------------------------------------------------------
    render() {
        var _a;
        if (this.popOver) {
            this.updatePopoverProps();
        }
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_4__.g)(this.hostElement) === "rtl";
        const { hidePanelHeading, dismissible, hideButtons, panelHeading, hideExtentSection, strings: strings } = this;
        const loading = !((_a = this.layer) === null || _a === void 0 ? void 0 : _a.loaded);
        if (!this.multidimensionalInfo) {
            const unsupportedDiv = loading ? null : ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "multidimensional-unsupported" }, strings.general.unsupported));
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { loading: loading, heading: !hidePanelHeading ? panelHeading !== null && panelHeading !== void 0 ? panelHeading : strings.title : undefined, class: {
                    panel: true,
                    [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_4__.C.rtl]: rtl
                }, ref: (node) => (this.refPanelNode = node) }, dismissible && this.renderClose(), unsupportedDiv, !hideButtons && this.renderDoneButton(), !hideButtons && this.renderCancelButton()));
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { loading: false, heading: !hidePanelHeading ? panelHeading !== null && panelHeading !== void 0 ? panelHeading : strings.title : undefined, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_4__.C.rtl]: rtl
            }, ref: (node) => (this.refPanelNode = node) }, dismissible ? this.renderClose() : null, hideExtentSection ? null : this.renderExtent(), this.renderCurrentDisplay(), hideButtons ? null : this.renderDoneButton(), hideButtons ? null : this.renderCancelButton())));
    }
    renderCurrentDisplay() {
        var _a;
        const { activeMultidimensionalDefinition, strings } = this;
        const subsetVariables = this.activeMultidimensionalSubset.variables;
        const variables = this.allVariables.filter(({ name }) => !subsetVariables.length || subsetVariables.includes(name));
        const { layer } = this;
        const isDynamicImagery = this.isImageryLayer(layer);
        const hasStarOrNewVariable = isDynamicImagery &&
            (variables.some(({ name }) => name === "*") ||
                this.hasNewVariable(this.multidimensionalInfo));
        // since multidimensionalDefinition can only be used for selection, it cannot be used to
        // work with new variables after rasterFunction
        let activeVariableName = activeMultidimensionalDefinition[0].variableName;
        // handle special variable name from a server side rft.
        // for 10.9+ servers, an rft with query definition will result a * variable, which is equivalent of unspecified variable name
        if (isDynamicImagery) {
            const { rasterFunction, version } = layer;
            const hasRasterFunction = rasterFunction && ((_a = rasterFunction.functionName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== "none";
            if (hasRasterFunction) {
                if (version <= _multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.m) {
                    variables.unshift(Object.assign(Object.assign({}, variables[0]), { name: strings.display.defaultVariable, label: strings.display.defaultVariable }));
                }
                if (activeVariableName === "") {
                    activeVariableName = hasStarOrNewVariable
                        ? variables[0].name
                        : strings.display.defaultVariable;
                }
            }
        }
        const selectedIndex = variables.findIndex((variableInfo) => variableInfo.name === activeVariableName);
        const selectStrings = {
            clearFilter: strings.select.clearFilter,
            filterText: strings.select.filterText,
            filterLabel: strings.extent.searchVariables,
            selectLabel: strings.extent.selectVariables
        };
        const variableSelect = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.display.variable, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-lazy-loading-select", { selectedIndex: selectedIndex === -1 ? 0 : selectedIndex, list: variables.map((variableInfo) => (Object.assign(Object.assign({}, variableInfo), { value: variableInfo.name }))), strings: selectStrings, key: this.sourceKey, onArcgisLazyLoadingSelectChange: (evt) => {
                const selectedVariableName = evt.detail.selectedValue;
                this.updateDefinitionVariableName(selectedVariableName);
            }, containerTop: this.containerTop }))));
        // restore special activeVariableName. star variable is fine for the following variableInfo lookup
        if (activeVariableName === strings.display.defaultVariable) {
            activeVariableName = "";
        }
        const variableInfo = this.getVariableInfo(activeVariableName);
        const dimensionBlocks = variableInfo.dimensions.map((dimInfo) => {
            dimInfo = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.g)(dimInfo, this.activeMultidimensionalSubset);
            return this.renderDimension(dimInfo);
        });
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: strings.display.current, collapsible: true, open: true }, variableSelect, dimensionBlocks));
    }
    renderPickListPopover() {
        if (this.popOver) {
            return;
        }
        const popOver = document.createElement("arcgis-field-pick-list");
        const popoverWidth = this.refPanelNode.getBoundingClientRect().width;
        popOver.popoverProps = {
            refElement: this.refPanelNode,
            placement: "leading-end",
            offsetDistance: 1,
            offsetSkidding: 48,
            popoverWidth
        };
        popOver.heading = this.strings.extent.selectVariables;
        popOver.filterPlaceholderText = this.strings.extent.searchVariables;
        popOver.showFieldInfo = false;
        popOver.showFieldName = false;
        popOver.showDescription = true;
        popOver.showSelectionAll = true;
        popOver.showCancel = false;
        popOver.showSort = false;
        popOver.sortBy = _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_6__.L.default;
        popOver.multiple = true;
        this.popOver = popOver;
        this.previousPickedListSize = -1;
        this.updatePopoverProps();
        popOver.addEventListener("arcgisFieldPickListChange", (evt) => {
            let selectedVariables = evt.detail.selectedFields || [];
            this.updateExtentVariables(selectedVariables);
        });
        popOver.addEventListener("arcgisFieldPickListDismissed", (_evt) => {
            this.closePopover();
        });
        document.body.appendChild(popOver);
    }
    renderExtent() {
        const variableList = this.renderVariableList();
        const { extent: extentStrings } = this.strings;
        const variableSelectButton = this.allVariables.length > 1 && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "variable-select" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { scale: "s", appearance: "outline-fill", kind: "neutral", round: true, alignment: "center", iconStart: "plus", onClick: () => this.renderPickListPopover() }, extentStrings.variables)));
        const allDimensiosn = [];
        this.multidimensionalInfo.variables.forEach(({ dimensions }) => allDimensiosn.push(...dimensions));
        const extentBlocks = this.activeMultidimensionalSubset.dimensions.map(({ name, extent }) => {
            const dimInfo = allDimensiosn.find(({ name: dimName }) => dimName === name);
            return this.renderDimensionExtent(dimInfo, extent);
        });
        const aoiBlock = this.hideAOI ? undefined : this.renderAOI();
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: extentStrings.extent, collapsible: true, open: !this.collapseExtentSection, onCalciteBlockToggle: () => this.closePopover() }, variableList, variableSelectButton, extentBlocks, aoiBlock));
    }
    renderVariableList() {
        const subsetVariables = this.activeMultidimensionalSubset.variables;
        const variables = this.allVariables.filter(({ name }) => !subsetVariables.length || subsetVariables.includes(name));
        const { strings } = this;
        const hidden = this.allVariables.length === 1;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.extent.variables, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", { class: "variable-section-boarder" }, variables.map(({ name, label, description }) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list-item", { label: label, description: description, key: name }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: "x", scale: "s", text: strings.general.close, slot: "actions-end", hidden: hidden, onClick: () => this._removeVariable(name) }))))))));
    }
    renderAOI() {
        const { strings } = this;
        const aoiOptions = [
            { value: "default", label: strings.extent.default, selected: this.aoiIndex === 0 },
            { value: "map", label: strings.extent.mapExtent, selected: this.aoiIndex === 1 }
        ];
        const selectedIndex = aoiOptions.findIndex(({ selected }) => selected);
        const selectStrings = {
            clearFilter: this.strings.select.clearFilter,
            filterText: this.strings.select.filterText,
            filterLabel: this.strings.extent.searchAOI,
            selectLabel: this.strings.extent.selectAOI
        };
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.extent.aoi, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-lazy-loading-select", { selectedIndex: selectedIndex, list: aoiOptions, strings: selectStrings, onArcgisLazyLoadingSelectChange: (evt) => {
                var _a;
                const value = evt.detail.selectedValue;
                const aoi = value === "default" ? null : (_a = this.view) === null || _a === void 0 ? void 0 : _a.extent;
                this.aoiIndex = value === "default" ? 0 : 1;
                this.updateExtentAOI(aoi);
            }, containerTop: this.containerTop }))));
    }
    _removeVariable(variableName) {
        const newActiveMultidimensionalSubset = this.activeMultidimensionalSubset.clone();
        let subsetDefinitions = newActiveMultidimensionalSubset.subsetDefinitions.filter((def) => def.variableName !== variableName);
        if (subsetDefinitions.length === 0) {
            subsetDefinitions = this.getDefaultMultidimensionalSubset().subsetDefinitions;
        }
        newActiveMultidimensionalSubset.subsetDefinitions = subsetDefinitions;
        this.activeMultidimensionalSubset = newActiveMultidimensionalSubset;
    }
    renderDimensionList(dimensionInfo, options) {
        var _a;
        let { selectedValue, key } = options;
        const isStartOrEnd = (key === null || key === void 0 ? void 0 : key.includes("start")) || (key === null || key === void 0 ? void 0 : key.includes("end"));
        if (Array.isArray((_a = dimensionInfo.values) === null || _a === void 0 ? void 0 : _a[0]) && typeof selectedValue === "number") {
            const dimValues = dimensionInfo.values;
            if (isStartOrEnd) {
                selectedValue = dimValues.find((value) => key.includes("start") ? value[0] === selectedValue : value[1] === selectedValue);
            }
            else {
                // match start, then match end
                selectedValue = dimValues.find((value) => value[0] === selectedValue);
                if (selectedValue == null) {
                    selectedValue = dimValues.find((value) => value[1] === selectedValue);
                }
            }
        }
        const isUndefinedValue = selectedValue === undefined_dimension_value ||
            options.selectedValue === undefined_dimension_value;
        const activeDimensionLabel = isUndefinedValue
            ? "undefined"
            : (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.f)(selectedValue, dimensionInfo, {
                intl: this.intl,
                useRecurringTimeLabel: true
            });
        // number is not well supported by calcite-select
        // <option label="0" value="">0</option> (null/truthy check issue?)
        // start/end time column renders same (how is this related to number?)
        const separator = " - ";
        const isAscending = options.sortable
            ? this.sortDirections[dimensionInfo.name] !== "descending"
            : true;
        const dimensionValues = isAscending
            ? dimensionInfo.values
            : [...dimensionInfo.values].reverse();
        const values = dimensionValues.map((value) => {
            const label = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.f)(value, dimensionInfo, {
                intl: this.intl,
                useRecurringTimeLabel: true
            });
            const valueStr = Array.isArray(value) ? value.join(separator) : String(value);
            const selected = label === activeDimensionLabel;
            const key = `${options.key}-${valueStr}}`;
            return {
                key,
                value: valueStr,
                label,
                selected
            };
        });
        if (options.showEnd) {
            values.push({
                key: `${dimensionInfo.name}-end-undefined}`,
                value: String(undefined_dimension_value),
                label: this.strings.extent.endUndefined,
                selected: isUndefinedValue
            });
        }
        const onArcgisLazyLoadingSelectChange = (evt) => {
            var _a;
            const value = evt.detail.selectedValue.split(separator).map((val) => Number(val));
            (_a = options.onChange) === null || _a === void 0 ? void 0 : _a.call(options, value.length === 1 ? value[0] : value);
        };
        let sortIcon = null;
        if (options.sortable) {
            // icon is the what user want to change to
            const sortIconName = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.i)(dimensionInfo)
                ? isAscending
                    ? "clock-up"
                    : "clock-down"
                : isAscending
                    ? "sort-ascending-arrow"
                    : "sort-descending-arrow";
            sortIcon = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: sortIconName, scale: "s", text: this.strings.display.sort, slot: "actions-end", onClick: () => {
                    this.updateSorting(dimensionInfo.name);
                } }));
        }
        const selectedIndex = values.findIndex(({ selected }) => selected);
        const selectStrings = {
            clearFilter: this.strings.select.clearFilter,
            filterText: this.strings.select.filterText,
            filterLabel: this.strings.extent.searchDimensions,
            selectLabel: this.strings.extent.selectDimensions
        };
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "dimension-select-container" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-lazy-loading-select", { selectedIndex: selectedIndex === -1 ? 0 : selectedIndex, list: values, strings: selectStrings, onArcgisLazyLoadingSelectChange: onArcgisLazyLoadingSelectChange, containerTop: this.containerTop }), sortIcon));
    }
    renderDimension(dimensionInfo) {
        const { activeMultidimensionalDefinition } = this;
        const definition = activeMultidimensionalDefinition.find((def) => def.dimensionName === dimensionInfo.name);
        const onChange = (value) => this.updateDefinitionDimensionValue(dimensionInfo.name, value, true);
        const dimensionSelect = this.renderDimensionList(dimensionInfo, {
            selectedValue: definition.values[0],
            sortable: this.isDimensionListSortable,
            key: dimensionInfo.name,
            onChange
        });
        const { strings } = this;
        const dimensionLabel = dimensionInfo.name === "StdTime"
            ? strings.display.stdTimeDimension
            : dimensionInfo.name === "StdZ"
                ? strings.display.stdZDimension
                : strings.display.generalDimension.replace("${dimensionName}", dimensionInfo.name);
        const isTime = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.i)(dimensionInfo, true);
        const dimName = isTime ? "time" : "z";
        const clippedDimensionInfo = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.g)(dimensionInfo, this.activeMultidimensionalSubset);
        const isZeroOrSingleSlice = clippedDimensionInfo.values.length < 2;
        const { showAnimationControls } = this;
        const animationSwitch = showAnimationControls && !isZeroOrSingleSlice ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { scale: "s", checked: this.animatedDimensions[dimName] === dimensionInfo.name, label: strings.display.showDimensionSlider, onCalciteSwitchChange: (event) => {
                const node = event.target;
                if (node.checked) {
                    this.createValuePicker(dimensionInfo);
                }
                else {
                    this.destroyValuePicker(isTime ? "time" : "z");
                }
            } }), strings.display.showDimensionSlider)) : null;
        return showAnimationControls ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "dimension-zone" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, dimensionLabel), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.display.defaultPosition, dimensionSelect), animationSwitch)) : ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, dimensionLabel, dimensionSelect)));
    }
    renderDimensionExtent(dimensionInfo, extent) {
        var _a;
        const startValues = [];
        const endValues = [];
        dimensionInfo.values.forEach((value) => {
            if (Array.isArray(value)) {
                if (value[1] <= extent[1]) {
                    startValues.push(value);
                }
                if (value[0] >= extent[0]) {
                    endValues.push(value);
                }
            }
            else {
                if (value < extent[1]) {
                    startValues.push(value);
                }
                if (value > extent[0]) {
                    endValues.push(value);
                }
            }
        });
        const isSliceMode = extent[1] === extent[0] ||
            (Array.isArray(dimensionInfo.values[0]) &&
                dimensionInfo.values.some((val) => val[0] === extent[0] && val[1] === extent[1]));
        const startInfo = isSliceMode
            ? dimensionInfo
            : Object.assign(Object.assign({}, dimensionInfo), { values: startValues });
        const startList = this.renderDimensionList(startInfo, {
            selectedValue: extent[0],
            sortable: false,
            key: dimensionInfo.name + "-start",
            onChange: (value) => this.updateExtentDimensionSubset(dimensionInfo.name, value, "start")
        });
        const endInfo = Object.assign(Object.assign({}, dimensionInfo), { values: endValues });
        const endList = this.renderDimensionList(endInfo, {
            selectedValue: isSliceMode ? undefined_dimension_value : extent[1],
            sortable: false,
            key: dimensionInfo.name + "-end",
            showEnd: true,
            onChange: (value) => this.updateExtentDimensionSubset(dimensionInfo.name, value, "end")
        });
        const { strings } = this;
        const dimensionLabel = dimensionInfo.name === "StdTime"
            ? strings.extent.stdTimeExtent
            : dimensionInfo.name === "StdZ"
                ? strings.extent.stdZExtent
                : strings.extent.generalExtent.replace("${dimensionName}", dimensionInfo.name);
        const allValues = dimensionInfo.values;
        const sliceCount = allValues.length;
        // using closure here, there's one slider per dimension, doesn't need to keep track of them at the compoennt level
        let sliderTarget;
        const onSliderChange = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.d)(() => {
            var _a;
            // evt.target is not the slider itself in case of onCalciteSliderChange (onCalciteSliderInput is not fired when drag middle of two thumbs)
            let start, end;
            if (Array.isArray(sliderTarget.value)) {
                start = allValues[sliderTarget.value[0]];
                end = allValues[(_a = sliderTarget.value[1]) !== null && _a !== void 0 ? _a : sliderTarget.value[0]];
            }
            else {
                start = end = allValues[sliderTarget.value];
            }
            const startValue = Array.isArray(start) ? start[0] : start;
            const endValue = Array.isArray(end) ? end[1] : end;
            this.updateExtentDimensionSubset(dimensionInfo.name, [startValue, endValue]);
        }, 100);
        let minIndex = 0;
        let maxIndex = sliceCount - 1;
        const dimExtent = (_a = this.activeMultidimensionalSubset.dimensions.find(({ name }) => name === dimensionInfo.name)) === null || _a === void 0 ? void 0 : _a.extent;
        if (dimExtent) {
            minIndex = allValues.findIndex((val) => (Array.isArray(val) ? val[0] : val) === dimExtent[0]);
            if (minIndex === -1) {
                minIndex = 0;
            }
            maxIndex = allValues.findIndex((val) => (Array.isArray(val) ? val[1] : val) === dimExtent[1]);
            if (maxIndex === -1) {
                maxIndex = sliceCount - 1;
            }
        }
        const slider = extent[0] === extent[1] ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-slider", { disabled: false, min: 0, max: sliceCount - 1, value: minIndex, step: 1, snap: true, labelTicks: false, ticks: sliceCount, onCalciteSliderInput: onSliderChange, onCalciteSliderChange: onSliderChange, ref: (node) => (sliderTarget = node) })) : ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-slider", { disabled: false, min: 0, max: sliceCount - 1, "min-value": minIndex, "max-value": maxIndex, step: 1, snap: true, labelTicks: false, ticks: sliceCount, onCalciteSliderInput: onSliderChange, onCalciteSliderChange: onSliderChange, ref: (node) => (sliderTarget = node) }));
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "dimension-zone" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, dimensionLabel), slider, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: this.useCompactExtentDropdowns
                ? "multidimensional-extent-compact"
                : "multidimensional-extent" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.extent.start, startList)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.extent.end, endList)))));
    }
    renderClose() {
        const { strings } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: strings.general.close, icon: "x", slot: "header-actions-end", onClick: this.cancel, ref: (node) => {
                this.refCloseButtonNode = node;
            } }));
    }
    renderDoneButton() {
        const { strings } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.apply, appearance: "solid", width: "half", label: strings.general.done }, strings.general.done));
    }
    renderCancelButton() {
        const { strings } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.cancel, appearance: "outline-fill", width: "half", label: strings.general.cancel }, strings.general.cancel));
    }
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    async initLayer(layer) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!layer) {
            return;
        }
        if (!layer.loaded) {
            await layer.load();
        }
        this.rawMultidimensionalInfo = await (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.a)(layer, true);
        if (!this.rawMultidimensionalInfo) {
            return;
        }
        const isDynamicImagery = this.isImageryLayer(layer);
        let functionName = "none";
        if (isDynamicImagery) {
            const multidimensionalInfo = (_a = (await (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.a)(layer))) !== null && _a !== void 0 ? _a : this.rawMultidimensionalInfo;
            const hasMultipleNewVariables = ((_b = multidimensionalInfo.variables) === null || _b === void 0 ? void 0 : _b.length) > 1 && this.hasNewVariable(multidimensionalInfo);
            // todo: variable a/b/c to d/e/f is NOT supported since it requires extracting (not selecting) a variable, no test case as well.
            this.multidimensionalInfo = hasMultipleNewVariables
                ? this.rawMultidimensionalInfo
                : multidimensionalInfo;
            functionName = (_c = layer.rasterFunction) === null || _c === void 0 ? void 0 : _c.functionName;
        }
        else {
            this.multidimensionalInfo = this.rawMultidimensionalInfo;
        }
        this.sourceKey = `${layer.url}-${functionName}`;
        this.allVariables = this.multidimensionalInfo.variables.map(({ name, unit, description, dimensions, statistics }) => ({
            name,
            label: unit ? `${name} (${unit})` : name,
            description,
            dimensionNames: dimensions.map(({ name }) => name).join(", "),
            statisticsRange: statistics === null || statistics === void 0 ? void 0 : statistics.map(({ min, max }) => [min, max].join(", ")).join("; ")
        }));
        // keep original setting
        const definition = this.getMultidimensionalDefinition(layer);
        const mosaicRule = isDynamicImagery ? (_d = layer.mosaicRule) === null || _d === void 0 ? void 0 : _d.clone() : null;
        const renderer = (_e = layer.renderer) === null || _e === void 0 ? void 0 : _e.clone();
        const subset = (_f = layer.multidimensionalSubset) === null || _f === void 0 ? void 0 : _f.clone();
        this.originalLayerSetting = {
            subset,
            mosaicRule,
            definition,
            renderer
        };
        // active subset and definitions
        this.activeMultidimensionalDefinition = this.esriLang.clone(this.originalLayerSetting.definition);
        let activeMultidimensionalSubset = null;
        if ((_h = (_g = layer.multidimensionalSubset) === null || _g === void 0 ? void 0 : _g.subsetDefinitions) === null || _h === void 0 ? void 0 : _h.length) {
            activeMultidimensionalSubset = layer.multidimensionalSubset;
            if (activeMultidimensionalSubset.variables.some((variableName) => !this.multidimensionalInfo.variables.some((variablInfo) => variablInfo.name === variableName))) {
                layer.multidimensionalSubset = null;
                this.originalLayerSetting.subset = null;
                activeMultidimensionalSubset = this.getDefaultMultidimensionalSubset();
            }
        }
        else {
            activeMultidimensionalSubset = this.getDefaultMultidimensionalSubset();
        }
        this.activeMultidimensionalSubset = activeMultidimensionalSubset;
        this.showAnimationOnStartUp && this.launchDimensionalSliders();
        if (this.watchViewTime && this.view && !this.watchHandleViewTime) {
            this.watchHandleViewTime = this.view.watch("timeExtent", this.updateExtentFromTime);
        }
        if (this.watchRasterFunction && !this.watchHandleLayer && isDynamicImagery) {
            this.watchHandleLayer = layer.watch("rasterFunction", (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.d)(async (newValue, oldValue) => {
                if ((newValue === null || newValue === void 0 ? void 0 : newValue.functionName) === (oldValue === null || oldValue === void 0 ? void 0 : oldValue.functionName)) {
                    return;
                }
                const mdInfo = await (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.a)(layer);
                if (this.isPropertyValueChanged(mdInfo, this.multidimensionalInfo)) {
                    this.closePopover();
                    this.initLayer(layer);
                }
            }, 100));
        }
    }
    closePopover() {
        if (this.popOver) {
            document.body.removeChild(this.popOver);
            this.popOver = null;
        }
    }
    getMultidimensionalDefinition(layer) {
        const multidimensionalDefinition = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.c)(layer);
        if (multidimensionalDefinition === null || multidimensionalDefinition === void 0 ? void 0 : multidimensionalDefinition.length) {
            return multidimensionalDefinition;
        }
        return this.getNewMultidimensionalDefinition(this.allVariables[0].name);
    }
    getNewMultidimensionalDefinition(selectedVariableName) {
        var _a;
        const selectedVariableInfo = this.getVariableInfo(selectedVariableName);
        const dimensions = (_a = selectedVariableInfo.dimensions) !== null && _a !== void 0 ? _a : [];
        const selectedDimensionNames = dimensions.map((dimInfo) => dimInfo.name);
        const activeMultidimensionalDefinition = this.activeMultidimensionalDefinition || [];
        const newDef = this.esriLang.clone(activeMultidimensionalDefinition);
        const activeDimensionNames = activeMultidimensionalDefinition.map((def) => def.dimensionName);
        // handle special dimension-less case
        if (selectedDimensionNames.length === 0) {
            newDef.forEach((def) => {
                def.variableName = selectedVariableName;
                def.dimensionName = "";
                def.values = [];
                def.isSlice = true;
            });
            return newDef;
        }
        const isSameDimensionList = activeDimensionNames.length === selectedDimensionNames.length &&
            selectedDimensionNames.every((name) => activeDimensionNames.includes(name));
        if (isSameDimensionList) {
            newDef.forEach((def) => {
                def.variableName = selectedVariableName;
                const dimensionInfo = dimensions.find(({ name }) => name === def.dimensionName);
                (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.u)(def, dimensionInfo, this.activeMultidimensionalSubset);
            });
            return newDef;
        }
        newDef.length = 0;
        dimensions.forEach((dimensionInfo) => {
            var _a;
            let def = (_a = activeMultidimensionalDefinition
                .find((def) => def.dimensionName === dimensionInfo.name)) === null || _a === void 0 ? void 0 : _a.clone();
            if (def) {
                def.variableName = selectedVariableName;
            }
            else {
                const value = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.b)(dimensionInfo);
                def = new this.DimensionalDefinition({
                    variableName: selectedVariableName,
                    dimensionName: dimensionInfo.name,
                    values: [value],
                    isSlice: true
                });
            }
            (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.u)(def, dimensionInfo, this.activeMultidimensionalSubset);
            newDef.push(def);
        });
        return newDef;
    }
    isMultidimensionalDefinitionChanged(newDef) {
        return JSON.stringify(newDef) !== JSON.stringify(this.activeMultidimensionalDefinition);
    }
    launchDimensionalSliders() {
        var _a;
        this.destroyValuePicker("both");
        const { activeMultidimensionalDefinition, multidimensionalInfo } = this;
        const activeVariableName = activeMultidimensionalDefinition[0].variableName;
        const activeVariableInfo = (_a = multidimensionalInfo.variables.find(({ name }) => name === activeVariableName)) !== null && _a !== void 0 ? _a : multidimensionalInfo.variables[0];
        const timeDimension = activeVariableInfo.dimensions.find((dimensionInfo) => (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.i)(dimensionInfo, true));
        this.createValuePicker(timeDimension);
        const zDimension = activeVariableInfo.dimensions.find((dimensionInfo) => !(0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.i)(dimensionInfo, true));
        this.createValuePicker(zDimension);
    }
    destroyValuePicker(target) {
        var _a, _b, _c, _d;
        if (target === "time" || target === "both") {
            (_a = this.valuePickers.time) === null || _a === void 0 ? void 0 : _a.handle.remove();
            (_b = this.valuePickers.time) === null || _b === void 0 ? void 0 : _b.slider.destroy();
            this.valuePickers.time = null;
            this.animatedDimensions.time = "";
        }
        if (target === "z" || target === "both") {
            (_c = this.valuePickers.z) === null || _c === void 0 ? void 0 : _c.handle.remove();
            (_d = this.valuePickers.z) === null || _d === void 0 ? void 0 : _d.slider.destroy();
            this.valuePickers.z = null;
            this.animatedDimensions.z = "";
        }
    }
    createValueTicks(steps, count) {
        return Array.from({ length: count }, (_, i) => i === 0
            ? 0
            : i === count - 1
                ? steps.length - 1
                : Math.round((i * (steps.length - 1)) / (count - 1)));
    }
    createValuePicker(dimensionInfo) {
        var _a, _b, _c;
        if (!dimensionInfo || !this.showAnimationControls) {
            return;
        }
        // process dimensionInfo clipping
        if (this.activeMultidimensionalSubset) {
            dimensionInfo = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.g)(dimensionInfo, this.activeMultidimensionalSubset);
        }
        // only have a single instance of time or z value picker
        const isTime = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.i)(dimensionInfo, true);
        const isZeroOrSingleSlice = dimensionInfo.values.length < 2;
        let prevValuePickerConfig = isTime ? this.valuePickers.time : this.valuePickers.z;
        if (isZeroOrSingleSlice ||
            (prevValuePickerConfig && prevValuePickerConfig.dimensionName !== dimensionInfo.name)) {
            this.destroyValuePicker(isTime ? "time" : "z");
            prevValuePickerConfig = null;
        }
        if (isZeroOrSingleSlice) {
            return;
        }
        // get picker parameters
        const activeDimensionValue = (_a = this.activeMultidimensionalDefinition.find(({ dimensionName }) => dimensionName === dimensionInfo.name)) === null || _a === void 0 ? void 0 : _a.values;
        const activeIndex = activeDimensionValue
            ? dimensionInfo.values.findIndex((value) => Array.isArray(value) && Array.isArray(activeDimensionValue[0])
                ? value.join() === activeDimensionValue.join()
                : value === activeDimensionValue[0])
            : 0;
        const dimValues = [...dimensionInfo.values];
        let lastDimValue = dimValues[dimValues.length - 1];
        if (Array.isArray(lastDimValue)) {
            lastDimValue = lastDimValue[lastDimValue.length - 1];
        }
        // API's default z layout is rising up: suitable when z dimension presents above-ground information
        // for ocean data, we need to reverse multiple places to "dive into the ocean"
        const reversed = !isTime && lastDimValue <= 0;
        const steps = dimValues.map((_val, i) => i);
        const stepCount = steps.length;
        // limit major ticks to 4 and avoid crowded minor ticks.
        const majorTicksCount = stepCount <= 4 ? 2 : isTime || stepCount <= 10 ? 3 : 4;
        const majorTicks = this.createValueTicks(steps, majorTicksCount);
        // align major tick to middle using 19: (1 + 9 * 2) for time, (1 + 6 * 3) for z
        const minorTicksCount = Math.min(19, stepCount > 19 ? Math.floor(stepCount / 2) : stepCount);
        const minorTicks = this.createValueTicks(steps, minorTicksCount);
        const labels = [...majorTicks];
        const formatter = (value, valueType) => {
            const index = reversed ? dimValues.length - 1 - value : value;
            return valueType === "tick"
                ? (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.f)(dimValues[index], dimensionInfo, {
                    intl: this.intl,
                    useRecurringTimeLabel: true,
                    useFriendlyISOFormat: true,
                    useStartOrEndForRangedValue: true
                })
                : (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_5__.f)(dimValues[index], dimensionInfo, {
                    intl: this.intl,
                    useRecurringTimeLabel: true,
                    useFriendlyISOFormat: true,
                    format: "short-date-long-time"
                });
        };
        // create and add to view ui
        const valuePickerDiv = document.createElement("div");
        const { animationSetting } = this;
        valuePickerDiv.classList.add(isTime ? animationSetting.timeClassName : animationSetting.zClassName);
        document.body.appendChild(valuePickerDiv);
        // guard for 0 or negative playrate. tiled imagery can use a shorter interval
        const playRate = animationSetting.playRate <= 0
            ? this.isImageryLayer(this.layer)
                ? 3000
                : 2000
            : animationSetting.playRate;
        // update or create value picker
        const component = {
            type: "slider",
            min: 0,
            max: dimValues.length - 1,
            steps,
            minorTicks,
            majorTicks,
            labels,
            reversed,
            visibleElements: {
                thumbTooltip: this.showAnimationTooltip
            },
            labelFormatFunction: formatter
        };
        const values = this.getSelectedSliderValue(activeIndex, reversed, dimValues.length);
        if (prevValuePickerConfig) {
            prevValuePickerConfig.handle.remove();
            const valuePicker = prevValuePickerConfig.slider;
            valuePicker.component = component;
            valuePicker.values = values;
            prevValuePickerConfig.dimensionValues = dimValues;
            prevValuePickerConfig.handle = valuePicker.watch("values", (v) => {
                const index = reversed ? dimValues.length - 1 - v[0] : v[0];
                this.updateDefinitionDimensionValue(dimensionInfo.name, dimValues[index]);
            });
            return;
        }
        const valuePicker = new this.ValuePicker({
            caption: dimensionInfo.name,
            layout: isTime ? "horizontal" : "vertical",
            container: valuePickerDiv,
            label: dimensionInfo.name,
            playRate,
            component,
            values
        });
        this.view.ui.add(valuePicker, { position: "manual" });
        const handle = valuePicker.watch("values", (v) => {
            const index = reversed ? dimValues.length - 1 - v[0] : v[0];
            this.updateDefinitionDimensionValue(dimensionInfo.name, dimValues[index]);
        });
        // avoid obstruction for horizontal value picker with default top placement
        const tooltipPlacement = isTime
            ? (_b = this.animationSetting.timeTooltipPlacement) !== null && _b !== void 0 ? _b : "top"
            : (_c = this.animationSetting.zTooltipPlacement) !== null && _c !== void 0 ? _c : "auto";
        if (tooltipPlacement !== "auto") {
            setTimeout(() => (valuePickerDiv.getElementsByTagName("calcite-tooltip")[0].placement = tooltipPlacement), 1000);
        }
        const pickerConfig = {
            slider: valuePicker,
            dimensionName: dimensionInfo.name,
            dimensionValues: dimValues,
            handle
        };
        if (isTime) {
            this.valuePickers.time = pickerConfig;
            this.animatedDimensions.time = dimensionInfo.name;
        }
        else {
            this.valuePickers.z = pickerConfig;
            this.animatedDimensions.z = dimensionInfo.name;
        }
    }
    updatePopoverProps() {
        const subsetVariables = this.activeMultidimensionalSubset.variables;
        // special case: do not update popover when all unselected
        if (this.previousPickedListSize === 0 &&
            subsetVariables.length === this.multidimensionalInfo.variables.length) {
            return;
        }
        const { allVariables, popOver } = this;
        popOver.selectedFields = subsetVariables;
        popOver.fields = allVariables.map((variable) => ({
            name: variable.name,
            alias: variable.name,
            type: "String",
            description: variable.description
        }));
        const threshold = allVariables[0].description ? 5 : 10;
        popOver.showFilterLength =
            this.showVariableFilter == null
                ? threshold
                : this.showVariableFilter
                    ? 1
                    : allVariables.length + 1;
    }
    getDefaultMultidimensionalSubset(variableNames) {
        // subset definitions
        const { variables } = this.multidimensionalInfo;
        const subsetDefinitions = [];
        for (let i = 0; i < variables.length; i++) {
            const { name: variableName, dimensions } = variables[i];
            if ((variableNames === null || variableNames === void 0 ? void 0 : variableNames.length) && !variableNames.includes(variableName)) {
                continue;
            }
            if (dimensions.length === 0) {
                subsetDefinitions.push({ variableName, dimensionName: "", values: [], isSlice: false });
            }
            else {
                for (let j = 0; j < dimensions.length; j++) {
                    const dimensionName = dimensions[j].name;
                    const values = [...dimensions[j].extent];
                    subsetDefinitions.push({ variableName, dimensionName, values, isSlice: false });
                }
            }
        }
        return new this.MultidimensionalSubset({
            areaOfInterest: null,
            subsetDefinitions
        });
    }
    getVariableInfo(variableName) {
        var _a;
        const { variables } = this.multidimensionalInfo;
        return this.isDefaultUnspecifiedVariable(variableName)
            ? variables[0]
            : (_a = variables.find((info) => info.name === variableName)) !== null && _a !== void 0 ? _a : variables[0];
    }
    getSelectedSliderValue(dimIndex, reversed, count) {
        return [dimIndex === -1 ? 0 : reversed ? count - 1 - dimIndex : dimIndex];
    }
    isDefaultUnspecifiedVariable(variableName) {
        return ["", "*", this.strings.display.defaultVariable].includes(variableName);
    }
    isPropertyValueChanged(newValue, oldValue) {
        return JSON.stringify(newValue !== null && newValue !== void 0 ? newValue : undefined) !== JSON.stringify(oldValue !== null && oldValue !== void 0 ? oldValue : undefined);
    }
    hasNewVariable(multidimensionalInfo) {
        return multidimensionalInfo.variables.some((variableInfo) => !this.rawMultidimensionalInfo.variables.some((rawVariableInfo) => rawVariableInfo.name === variableInfo.name));
    }
    isImageryLayer(layer) {
        return layer.type === "imagery";
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "layer": ["watchLayer"],
        "activeMultidimensionalDefinition": ["watchActiveMultidimensionalDefinition"],
        "activeMultidimensionalSubset": ["watchactiveMultidimensionalSubset"]
    }; }
};
ArcgisRasterMultidimensional.style = arcgisRasterMultidimensionalCss;



//# sourceMappingURL=arcgis-raster-multidimensional.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-69f3968f.js":
/*!**********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-69f3968f.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getMultidimensionalInfo),
/* harmony export */   b: () => (/* binding */ getDefaultDimensionSliceValue),
/* harmony export */   c: () => (/* binding */ getMultidimensionalDefinition),
/* harmony export */   f: () => (/* binding */ formatDimensionValue),
/* harmony export */   g: () => (/* binding */ getClippedDimensionInfo),
/* harmony export */   i: () => (/* binding */ isTimeDimension),
/* harmony export */   m: () => (/* binding */ minVersionRFTMultidimensionalInfo),
/* harmony export */   u: () => (/* binding */ updateDimensionalDefinition)
/* harmony export */ });
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const minVersionRFTMultidimensionalInfo = 10.9;
function formatTime(value, options) {
    const date = new Date(value);
    const { useFriendlyISOFormat, intl, format } = options;
    if (useFriendlyISOFormat && intl) {
        return intl.formatDate(date, Object.assign(Object.assign({}, intl.convertDateFormatToIntlOptions(format !== null && format !== void 0 ? format : "short-date-long-time")), { timeZone: "UTC" }));
    }
    let isoTimeString = new Date(value).toISOString();
    isoTimeString = isoTimeString.slice(0, isoTimeString.indexOf(".")) + "Z";
    return isoTimeString;
}
function formatMonth(value_base1, intl, format = "long") {
    // using an arbitrary date (the day the code was written) to avoid side effects of setMonth near the end of the month
    // setMonth will move the date to the next month when new month doesn't have current date (e.g. 9/31, 2/30)
    // date = new Date(2002, 9, 31); date.setMonth(8); console.log(date.toLocaleDateString())
    const date = new Date(2022, 9, 10);
    date.setMonth(value_base1 - 1);
    return intl.formatDate(date, { month: format });
}
function formatQuarter(value_base1, intl) {
    const startMonth = formatMonth((value_base1 - 1) * 3 + 1, intl, "short");
    const endMonth = formatMonth(value_base1 * 3, intl, "short");
    return `${startMonth} - ${endMonth}`;
}
function formatDimensionValue(value, dimensionInfo, options = {}) {
    var _a, _b, _c, _d;
    if (value == null) {
        return "";
    }
    const { intl, useRecurringTimeLabel } = options;
    if (useRecurringTimeLabel && intl && !Array.isArray(value)) {
        const intervalUnit = (_a = dimensionInfo.intervalUnit) === null || _a === void 0 ? void 0 : _a.toLowerCase().trim();
        // weekly and daily are not supported yet
        const canUseRecurringTimeLabel = isRecurringTimeDimension(dimensionInfo) && (intervalUnit === "months" || intervalUnit === "quarters");
        if (canUseRecurringTimeLabel) {
            return intervalUnit === "months" ? formatMonth(value, intl) : formatQuarter(value, intl);
        }
    }
    // this is prefered when labeling a slider alike control
    const lastElement = (_b = dimensionInfo.values) === null || _b === void 0 ? void 0 : _b[dimensionInfo.values.length - 1];
    if (options.useStartOrEndForRangedValue && Array.isArray(value) && value.length === 2 && Array.isArray(lastElement)) {
        const isLastElement = value.join("-") === lastElement.join("-");
        value = isLastElement ? value[1] : value[0];
    }
    const isTime = isTimeDimension(dimensionInfo);
    if (!isTime) {
        return Array.isArray(value)
            ? value.map((element) => { var _a; return (_a = intl === null || intl === void 0 ? void 0 : intl.formatNumber(element)) !== null && _a !== void 0 ? _a : String(element); }).join(" - ")
            : (_c = intl === null || intl === void 0 ? void 0 : intl.formatNumber(value)) !== null && _c !== void 0 ? _c : String(value);
    }
    if (options.useFriendlyISOFormat && !options.format) {
        let resolution = (_d = dimensionInfo.intervalUnit) === null || _d === void 0 ? void 0 : _d.toLowerCase().trim();
        let { interval, extent } = dimensionInfo;
        if (resolution === "months") {
            if (interval > 11) {
                resolution = "year";
            }
        }
        else if (resolution === "days") {
            if (interval > 364) {
                resolution = "year";
            }
            else if (interval > 27) {
                resolution = "months";
            }
        }
        else if (resolution === "hours") {
            resolution = "days";
        }
        if (!["years", "months", "days"].includes(resolution) && (extent === null || extent === void 0 ? void 0 : extent.length)) {
            const interval = (extent[1] - extent[0]) / dimensionInfo.values.length;
            const day = 86400000;
            if (interval >= 365 * day) {
                resolution = "years";
            }
            else if (interval >= 28 * day) {
                resolution = "months";
            }
        }
        const format = resolution === "years" ? "year" : resolution === "months" ? "short-month-year" : "short-date";
        options = Object.assign({ format }, options);
    }
    return Array.isArray(value)
        ? value.map((element) => formatTime(element, options)).join(" - ")
        : formatTime(value, options);
}
function getClippedDimensionInfo(dimensionInfo, multidimensionalSubset) {
    var _a;
    const constraint = (_a = multidimensionalSubset === null || multidimensionalSubset === void 0 ? void 0 : multidimensionalSubset.dimensions) === null || _a === void 0 ? void 0 : _a.find(({ name }) => name === dimensionInfo.name);
    if (!(constraint === null || constraint === void 0 ? void 0 : constraint.extent)) {
        return dimensionInfo;
    }
    const extent = [...constraint.extent];
    const values = dimensionInfo.values.filter((value) => {
        // must be contained, intersection is not sufficient
        if (Array.isArray(value)) {
            if (!(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_0__.i)(extent[1]) || extent[0] === extent[1]) {
                return value[0] === extent[0];
            }
            return value[0] >= extent[0] && value[0] <= extent[1] && value[1] >= extent[0] && value[1] <= extent[1];
        }
        return value >= extent[0] && value <= extent[1];
    });
    // this is a special case, when last slice of a ranged dimension series is used
    if (values.length === 0) {
        const lastValue = dimensionInfo.values[dimensionInfo.values.length - 1];
        if (Array.isArray(lastValue) && lastValue[1] === extent[0]) {
            values.push(lastValue);
        }
    }
    return Object.assign(Object.assign({}, dimensionInfo), { extent, values });
}
function getDefaultDimensionSliceValue(dimensionInfo) {
    var _a;
    const { values, extent, name } = dimensionInfo;
    let value = (_a = values === null || values === void 0 ? void 0 : values[0]) !== null && _a !== void 0 ? _a : extent[0];
    if (name.toLowerCase() === "stdz" &&
        !dimensionInfo.hasRanges &&
        Math.abs(extent[1]) <= Math.abs(extent[0])) {
        if (values === null || values === void 0 ? void 0 : values.length) {
            value = values[values.length - 1];
        }
        else {
            value = extent[1];
        }
    }
    return value;
}
function getMultidimensionalDefinition(layer) {
    var _a, _b;
    return layer.type === "imagery-tile"
        ? layer.multidimensionalDefinition
        : (_b = ((_a = layer.mosaicRule) !== null && _a !== void 0 ? _a : layer._defaultServiceMosaicRule)) === null || _b === void 0 ? void 0 : _b.multidimensionalDefinition;
}
async function getMultidimensionalInfo(layer, useRawSourceInfo) {
    var _a, _b;
    if (layer.type === "imagery-tile") {
        return layer.rasterInfo.multidimensionalInfo;
    }
    const { rasterFunction, version } = layer;
    if (useRawSourceInfo ||
        version <= minVersionRFTMultidimensionalInfo ||
        !rasterFunction ||
        ((_a = rasterFunction.functionName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "none") {
        return layer.serviceRasterInfo.multidimensionalInfo;
    }
    const rasterInfo = (_b = (await layer.generateRasterInfo(layer.rasterFunction))) !== null && _b !== void 0 ? _b : layer.serviceRasterInfo;
    return rasterInfo.multidimensionalInfo;
}
function isTimeDimension(dimensionInfo, ignoreRecuring = false) {
    return dimensionInfo.name === "StdTime" && (ignoreRecuring || !dimensionInfo.recurring);
}
function isRecurringTimeDimension(dimensionInfo) {
    return dimensionInfo.name === "StdTime" && !!dimensionInfo.recurring;
}
function updateDimensionalDefinition(def, dimensionInfo, activeMultidimensionalSubset) {
    dimensionInfo = getClippedDimensionInfo(dimensionInfo, activeMultidimensionalSubset);
    const originalFormattedValue = formatDimensionValue(def.values[0], dimensionInfo);
    const hasOriginalFormattedValue = dimensionInfo.values.some((val) => originalFormattedValue === formatDimensionValue(val, dimensionInfo));
    if (!hasOriginalFormattedValue) {
        // get default slice value when def.values is invalid
        const value = getDefaultDimensionSliceValue(dimensionInfo);
        def.values = [value];
    }
}



//# sourceMappingURL=multidimensional-69f3968f.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTgwNTc3YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNkc7QUFDcEQ7QUFDYTtBQUNUO0FBQ3FCO0FBQzZOO0FBQ2xQO0FBQ2xDO0FBQ1k7O0FBRXZDLCtDQUErQyxhQUFhLGNBQWMsZ0JBQWdCLDBCQUEwQiwwQ0FBMEMsaUJBQWlCLGFBQWEsdUJBQXVCLDZCQUE2QixjQUFjLGlDQUFpQyxhQUFhLFdBQVcscUNBQXFDLFVBQVUsaURBQWlELGtCQUFrQiw4QkFBOEIsWUFBWSxnQkFBZ0IsYUFBYSwwQ0FBMEMsY0FBYyw0QkFBNEIsYUFBYSxXQUFXLG1CQUFtQiw4Q0FBOEMsWUFBWSw2Q0FBNkMsa0JBQWtCOztBQUV4dUI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEIsa0RBQWtELHFEQUFXO0FBQzdELGdEQUFnRCxxREFBVztBQUMzRCxrREFBa0QscURBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeVE7O0FBRXpRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLXJhc3Rlci1tdWx0aWRpbWVuc2lvbmFsLmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxlLTA1MGI2ZGI5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL211bHRpZGltZW5zaW9uYWwtNjlmMzk2OGYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIEggYXMgSG9zdCwgZCBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5pbXBvcnQgeyBkIGFzIGRlYm91bmNlIH0gZnJvbSAnLi9mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyB9IGZyb20gJy4vbG9jYWxlLTA1MGI2ZGI5LmpzJztcbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0RWxlbWVudERpciwgQyBhcyBDU1NfVVRJTElUWSB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCB7IG0gYXMgbWluVmVyc2lvblJGVE11bHRpZGltZW5zaW9uYWxJbmZvLCBnIGFzIGdldENsaXBwZWREaW1lbnNpb25JbmZvLCBmIGFzIGZvcm1hdERpbWVuc2lvblZhbHVlLCBhIGFzIGdldE11bHRpZGltZW5zaW9uYWxJbmZvLCB1IGFzIHVwZGF0ZURpbWVuc2lvbmFsRGVmaW5pdGlvbiwgYiBhcyBnZXREZWZhdWx0RGltZW5zaW9uU2xpY2VWYWx1ZSwgaSBhcyBpc1RpbWVEaW1lbnNpb24sIGMgYXMgZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gfSBmcm9tICcuL211bHRpZGltZW5zaW9uYWwtNjlmMzk2OGYuanMnO1xuaW1wb3J0IHsgTCBhcyBMYXN0U29ydHlCeSB9IGZyb20gJy4vY29tbW9uRW51bXMtZmNmMTM2NjEuanMnO1xuaW1wb3J0ICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgJy4vY29tbW9uRnVuY3Rpb25zLWIwODMwZTllLmpzJztcblxuY29uc3QgYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbENzcyA9IFwiOmhvc3R7ZGlzcGxheTpmbGV4O2ZsZXg6MSAxIGF1dG87b3ZlcmZsb3c6aGlkZGVufS52YXJpYWJsZS1zZWN0aW9uLWJvYXJkZXJ7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1hcmNnaXMtYXBwLWJvcmRlcil9LnZhcmlhYmxlLXNlbGVjdHtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcn0ubXVsdGlkaW1lbnNpb25hbC1leHRlbnQ+ZGl2e21hcmdpbjoxMHB4IDB9Lm11bHRpZGltZW5zaW9uYWwtZXh0ZW50LWNvbXBhY3R7ZGlzcGxheTpmbGV4O3dpZHRoOjEwMCV9Lm11bHRpZGltZW5zaW9uYWwtZXh0ZW50LWNvbXBhY3Q+ZGl2e3dpZHRoOjUwJX0ubXVsdGlkaW1lbnNpb25hbC1leHRlbnQtY29tcGFjdD5kaXY6Zmlyc3QtY2hpbGR7bWFyZ2luOjAgMjBweCAwIDB9Lm11bHRpZGltZW5zaW9uYWwtdW5zdXBwb3J0ZWR7bWFyZ2luOjIwcHh9LmRpbWVuc2lvbi16b25le3BhZGRpbmc6MTBweDtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWFyY2dpcy1hcHAtYm9yZGVyKTttYXJnaW46MTBweCAwfS5kaW1lbnNpb24tc2VsZWN0LWNvbnRhaW5lcntkaXNwbGF5OmZsZXg7d2lkdGg6MTAwJTthbGlnbi1pdGVtczpjZW50ZXJ9LmRpbWVuc2lvbi1zZWxlY3QtY29udGFpbmVyIC5kaW1lbnNpb24tc2VsZWN0e2ZsZXgtZ3JvdzoxfS5hcmNnaXMtLXJ0bCAuZXh0ZW50LWNvbXBhY3Q+ZGl2OmZpcnN0LWNoaWxke21hcmdpbjowIDAgMCAyMHB4fVwiO1xuXG5jb25zdCB1bmRlZmluZWRfZGltZW5zaW9uX3ZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRSAtIDE7XG5jb25zdCBBcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsQ2hhbmdlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc1Jhc3Rlck11bHRpZGltZW5zaW9uYWxTYXZlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsU2F2ZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsQ2FuY2VsID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsQ2FuY2VsXCIsIDcpO1xuICAgICAgICB0aGlzLnZhbHVlUGlja2VycyA9IHtcbiAgICAgICAgICAgIHRpbWU6IG51bGwsXG4gICAgICAgICAgICB6OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udGFpbmVyVG9wID0gMDtcbiAgICAgICAgdGhpcy5hb2lJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucHJldmlvdXNQaWNrZWRMaXN0U2l6ZSA9IC0xO1xuICAgICAgICB0aGlzLnBhdXNlTGF5ZXJVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcHBseSA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxMYXllclNldHRpbmcuZGVmaW5pdGlvbiA9IHRoaXMuZXNyaUxhbmcuY2xvbmUodGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbik7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsTGF5ZXJTZXR0aW5nLnN1YnNldCA9IHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3QgeyBsYXllciB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW1hZ2VyeUxheWVyKGxheWVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxMYXllclNldHRpbmcubW9zYWljUnVsZSA9IChfYSA9IGxheWVyLm1vc2FpY1J1bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm1ha2VMaXZlTGF5ZXJVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxheWVyTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxheWVyTXVsdGlkaW1lbnNpb25hbFN1YnNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbFNhdmUuZW1pdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbGF5ZXIsIG9yaWdpbmFsTGF5ZXJTZXR0aW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuZXNyaUxhbmcuY2xvbmUob3JpZ2luYWxMYXllclNldHRpbmcuZGVmaW5pdGlvbik7XG4gICAgICAgICAgICBjb25zdCBzdWJzZXQgPSB0aGlzLmVzcmlMYW5nLmNsb25lKG9yaWdpbmFsTGF5ZXJTZXR0aW5nLnN1YnNldCk7XG4gICAgICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZVdoZW5DYW5jZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlTGF5ZXJVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IHN1YnNldCAhPT0gbnVsbCAmJiBzdWJzZXQgIT09IHZvaWQgMCA/IHN1YnNldCA6IHRoaXMuZ2V0RGVmYXVsdE11bHRpZGltZW5zaW9uYWxTdWJzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlTGF5ZXJVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW1hZ2VyeUxheWVyKGxheWVyKSkge1xuICAgICAgICAgICAgICAgIGxheWVyLm1vc2FpY1J1bGUgPSBvcmlnaW5hbExheWVyU2V0dGluZy5tb3NhaWNSdWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIubXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXIucmVuZGVyZXIgPSBvcmlnaW5hbExheWVyU2V0dGluZy5yZW5kZXJlcjtcbiAgICAgICAgICAgIGxheWVyLm11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBzdWJzZXQ7XG4gICAgICAgICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsQ2FuY2VsLmVtaXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVEZWZpbml0aW9uRGltZW5zaW9uVmFsdWUgPSAoc2VsZWN0ZWREaW1lbnNpb25OYW1lLCB2YWx1ZSwgdXBkYXRlVmFsdWVQaWNrZXIgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RlZiA9IHRoaXMuZXNyaUxhbmcuY2xvbmUodGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbik7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZERlZiA9IG5ld0RlZi5maW5kKCh7IGRpbWVuc2lvbk5hbWUgfSkgPT4gZGltZW5zaW9uTmFtZSA9PT0gc2VsZWN0ZWREaW1lbnNpb25OYW1lKTtcbiAgICAgICAgICAgIHNlbGVjdGVkRGVmLnZhbHVlcyA9IFt2YWx1ZV07XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gbmV3RGVmO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGVWYWx1ZVBpY2tlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG1hdGNoaW5nIHZhbHVlIHBpY2tlclxuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZVBpY2tlcnMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVBpY2tlciA9ICgoX2EgPSB2YWx1ZVBpY2tlcnMudGltZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpbWVuc2lvbk5hbWUpID09PSBzZWxlY3RlZERpbWVuc2lvbk5hbWVcbiAgICAgICAgICAgICAgICA/IHZhbHVlUGlja2Vycy50aW1lXG4gICAgICAgICAgICAgICAgOiAoKF9iID0gdmFsdWVQaWNrZXJzLnopID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaW1lbnNpb25OYW1lKSA9PT0gc2VsZWN0ZWREaW1lbnNpb25OYW1lXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVQaWNrZXJzLnpcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHZhbHVlUGlja2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB2YWx1ZVBpY2tlci5kaW1lbnNpb25WYWx1ZXMuZmluZEluZGV4KChkaW1WYWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShkaW1WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZS5qb2luKFwiLVwiKSA9PT0gZGltVmFsdWUuam9pbihcIi1cIilcbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSA9PT0gZGltVmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlUGlja2VyLnNsaWRlci52YWx1ZXMgPSB0aGlzLmdldFNlbGVjdGVkU2xpZGVyVmFsdWUoaW5kZXgsIHZhbHVlUGlja2VyLnNsaWRlci5jb21wb25lbnQucmV2ZXJzZWQsIHZhbHVlUGlja2VyLmRpbWVuc2lvblZhbHVlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZURlZmluaXRpb25WYXJpYWJsZU5hbWUgPSAodmFyaWFibGVOYW1lKSA9PiB7XG4gICAgICAgICAgICAvLyBub3JtYWxpemUgZW1wdHkgdmFyaWFibGUgbmFtZSAoMy54KSwgKiAocmZ0IHJlc3VsdCksIGRlZmF1bHQgdmFyaWFibGUgc3RyaW5nIFVJXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RlZmF1bHRVbnNwZWNpZmllZFZhcmlhYmxlKHZhcmlhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZU5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3RGVmID0gdGhpcy5nZXROZXdNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbih2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IG5ld0RlZjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVFeHRlbnREaW1lbnNpb25TdWJzZXQgPSAoc2VsZWN0ZWREaW1lbnNpb25OYW1lLCB2YWx1ZU9yRXh0ZW50LCByZXBsYWNlQm90aCA9IFwiYm90aFwiKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBkaW0gPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmRpbWVuc2lvbnMuZmluZCgoZGltZW5zaW9uKSA9PiBkaW1lbnNpb24ubmFtZSA9PT0gc2VsZWN0ZWREaW1lbnNpb25OYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGRpbUV4dGVudCA9IFsuLi5kaW0uZXh0ZW50XTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlQm90aCA9PT0gXCJib3RoXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB1cGRhdGluZyB3aGVuIGV4aXN0aW5nIHZhbHVlIG1hdGNoZXMgbmV3IHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKGRpbUV4dGVudFswXSA9PT0gdmFsdWVPckV4dGVudFswXSAmJiBkaW1FeHRlbnRbMV0gPT09IHZhbHVlT3JFeHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBbZGltRXh0ZW50WzBdLCBkaW1FeHRlbnRbMV1dID0gdmFsdWVPckV4dGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VCb3RoID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgd2FzTm90UmFuZ2UgPSBkaW1FeHRlbnRbMV0gPT09IGRpbUV4dGVudFswXTtcbiAgICAgICAgICAgICAgICBkaW1FeHRlbnRbMF0gPSBBcnJheS5pc0FycmF5KHZhbHVlT3JFeHRlbnQpID8gdmFsdWVPckV4dGVudFswXSA6IHZhbHVlT3JFeHRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHdhc05vdFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpbUV4dGVudFsxXSA9IGRpbUV4dGVudFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVPckV4dGVudCA9PT0gdW5kZWZpbmVkX2RpbWVuc2lvbl92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBkaW1FeHRlbnRbMV0gPSBkaW1FeHRlbnRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaW1FeHRlbnRbMV0gPSBBcnJheS5pc0FycmF5KHZhbHVlT3JFeHRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlT3JFeHRlbnRbdmFsdWVPckV4dGVudC5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZU9yRXh0ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaW1FeHRlbnRbMV0gPCBkaW1FeHRlbnRbMF0gfHwgZGltRXh0ZW50WzFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkaW1FeHRlbnRbMV0gPSBkaW1FeHRlbnRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdBY3RpdmVTdWJzZXQgPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnNldERlZmluaXRpb25zIH0gPSBuZXdBY3RpdmVTdWJzZXQ7XG4gICAgICAgICAgICBzdWJzZXREZWZpbml0aW9ucy5mb3JFYWNoKChkZWYpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmRpbWVuc2lvbk5hbWUgPT09IHNlbGVjdGVkRGltZW5zaW9uTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWVzID0gW2RpbUV4dGVudFswXSwgZGltRXh0ZW50WzFdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IG5ld0FjdGl2ZVN1YnNldDtcbiAgICAgICAgICAgIGNvbnN0IHsgYW5pbWF0ZWREaW1lbnNpb25zIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaGFzVGltZVBpY2tlciA9IGFuaW1hdGVkRGltZW5zaW9ucy50aW1lID09PSBzZWxlY3RlZERpbWVuc2lvbk5hbWU7XG4gICAgICAgICAgICBjb25zdCBoYXNaUGlja2VyID0gYW5pbWF0ZWREaW1lbnNpb25zLnogPT09IHNlbGVjdGVkRGltZW5zaW9uTmFtZTtcbiAgICAgICAgICAgIGlmIChoYXNUaW1lUGlja2VyIHx8IGhhc1pQaWNrZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZUluZm8gPSB0aGlzLmdldFZhcmlhYmxlSW5mbyh0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uWzBdLnZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGltSW5mbyA9IHZhcmlhYmxlSW5mbyA9PT0gbnVsbCB8fCB2YXJpYWJsZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhcmlhYmxlSW5mby5kaW1lbnNpb25zLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBzZWxlY3RlZERpbWVuc2lvbk5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVmFsdWVQaWNrZXIoZGltSW5mbyk7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGVyZSdzIHNpbmdsZSBvciAwIChjYW4gaXQgYmUgMD8pIHNsaWNlcywga2VlcCBlbmFibGVkIHN0YXRlIGFzIGl0J3MgY2xpcHBlZCBieSBleHRlbnRcbiAgICAgICAgICAgICAgICBpZiAoaGFzVGltZVBpY2tlcikge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRlZERpbWVuc2lvbnMudGltZSA9IHNlbGVjdGVkRGltZW5zaW9uTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkRGltZW5zaW9ucy56ID0gc2VsZWN0ZWREaW1lbnNpb25OYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVFeHRlbnRWYXJpYWJsZXMgPSAoc2VsZWN0ZWRWYXJpYWJsZXMpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRWYXJpYWJsZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC52YXJpYWJsZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYWJsZXMuam9pbihcIixcIikgPT09IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQudmFyaWFibGVzLmpvaW4oXCIsXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1BpY2tlZExpc3RTaXplID0gc2VsZWN0ZWRWYXJpYWJsZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkVmFyaWFibGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFibGVzID0gdGhpcy5hbGxWYXJpYWJsZXMubWFwKCh7IG5hbWUgfSkgPT4gbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGFydCB3dGloIGRlZmF1bHQgZGltZW5zaW9ucywgdXNlIGV4aXN0aW5nIGRlZmluaXRpb24gd2hlbiBleGlzdCwgcmVtb3ZlIGRpbWVuc2lvbnMgdGhhdCBhcmUgbm8gbG9uZ2VyIHBhcnQgb2Ygc2VsZWN0ZWQgdmFyaWFibGVzXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZERlZmF1bHRTdWJzZXQgPSB0aGlzLmdldERlZmF1bHRNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KHNlbGVjdGVkVmFyaWFibGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc3Vic2V0RGVmaW5pdGlvbnMgfSA9IHNlbGVjdGVkRGVmYXVsdFN1YnNldC5jbG9uZSgpO1xuICAgICAgICAgICAgc3Vic2V0RGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmYXVsdERlZikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nRGVmaW5pdGlvbiA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQuc3Vic2V0RGVmaW5pdGlvbnMuZmluZCgoZGVmKSA9PiBkZWYudmFyaWFibGVOYW1lID09PSBkZWZhdWx0RGVmLnZhcmlhYmxlTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICBkZWYuZGltZW5zaW9uTmFtZSA9PT0gZGVmYXVsdERlZi5kaW1lbnNpb25OYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHREZWYudmFsdWVzID0gbWF0Y2hpbmdEZWZpbml0aW9uLnZhbHVlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nRGltZW5zaW9uRXh0ZW50ID0gYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5kaW1lbnNpb25zLmZpbmQoKGRpbWVuc2lvbikgPT4gZGltZW5zaW9uLm5hbWUgPT09IGRlZmF1bHREZWYuZGltZW5zaW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ0RpbWVuc2lvbkV4dGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdERlZi52YWx1ZXMgPSBbLi4ubWF0Y2hpbmdEaW1lbnNpb25FeHRlbnQuZXh0ZW50XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV3QXRpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5jbG9uZSgpO1xuICAgICAgICAgICAgbmV3QXRpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LnN1YnNldERlZmluaXRpb25zID0gc3Vic2V0RGVmaW5pdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBuZXdBdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZW50QU9JID0gKGFvaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3QXRpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmNsb25lKCk7XG4gICAgICAgICAgICBuZXdBdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQuYXJlYU9mSW50ZXJlc3QgPSBhb2kgPT09IG51bGwgfHwgYW9pID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhb2kuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IG5ld0F0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVFeHRlbnRGcm9tVGltZSA9ICh0aW1lRXh0ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbERlZiA9IHRoaXMuZXNyaUxhbmcuY2xvbmUodGhpcy5vcmlnaW5hbExheWVyU2V0dGluZy5kZWZpbml0aW9uKTtcbiAgICAgICAgICAgIC8vIHRvZG8gZXhwb3NlIHRoaXMgYSB1dGlsdHkgZnVuY3Rpb24gaW4gQVBJXG4gICAgICAgICAgICBjb25zdCB7IG11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uOiBuZXdEZWYgfSA9IHRoaXMubGF5ZXIubm9ybWFsaXplUmFzdGVyRmV0Y2hPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBtdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbjogb3JpZ2luYWxEZWYsXG4gICAgICAgICAgICAgICAgdGltZUV4dGVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobmV3RGVmICYmIHRoaXMuaXNQcm9wZXJ0eVZhbHVlQ2hhbmdlZChuZXdEZWYsIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IG5ld0RlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVTb3J0aW5nID0gKGRpbWVuc2lvbk5hbWUpID0+IHtcbiAgICAgICAgICAgIC8vIG5vdCBpbml0aWFsaXplZCAodW5kZWZpbmVkKSB3aWxsIGJlIGNoYW5nZWQgdG8gZGVzY2VuZGluZ1xuICAgICAgICAgICAgY29uc3Qgc29ydERpcmVjdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNvcnREaXJlY3Rpb25zKTtcbiAgICAgICAgICAgIHNvcnREaXJlY3Rpb25zW2RpbWVuc2lvbk5hbWVdID1cbiAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uc1tkaW1lbnNpb25OYW1lXSA9PT0gXCJkZXNjZW5kaW5nXCIgPyBcImFzY2VuZGluZ1wiIDogXCJkZXNjZW5kaW5nXCI7XG4gICAgICAgICAgICB0aGlzLnNvcnREaXJlY3Rpb25zID0gc29ydERpcmVjdGlvbnM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTGF5ZXJNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IGRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgeyBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiwgbGF5ZXIgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpc0R5bmFtaWNJbWFnZXJ5ID0gdGhpcy5pc0ltYWdlcnlMYXllcihsYXllcik7XG4gICAgICAgICAgICBjb25zdCBpc0RlZmluaXRpb25DaGFuZ2VkID0gaXNEeW5hbWljSW1hZ2VyeVxuICAgICAgICAgICAgICAgID8gdGhpcy5pc1Byb3BlcnR5VmFsdWVDaGFuZ2VkKGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uLCAoX2EgPSBsYXllci5tb3NhaWNSdWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24pXG4gICAgICAgICAgICAgICAgOiB0aGlzLmlzUHJvcGVydHlWYWx1ZUNoYW5nZWQoYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24sIGxheWVyLm11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKTtcbiAgICAgICAgICAgIGlmICghaXNEZWZpbml0aW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9sZERlZmluaXRpb24gPSB0aGlzLmdldE11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKGxheWVyKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFyaWFibGVDaGFuZ2VkID0gIW9sZERlZmluaXRpb24gfHxcbiAgICAgICAgICAgICAgICBvbGREZWZpbml0aW9uLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIG9sZERlZmluaXRpb25bMF0udmFyaWFibGVOYW1lICE9PSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvblswXS52YXJpYWJsZU5hbWU7XG4gICAgICAgICAgICBpZiAoaXNEeW5hbWljSW1hZ2VyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vc2FpY1J1bGUgPSAoKF9iID0gbGF5ZXIubW9zYWljUnVsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbGF5ZXIuZGVmYXVsdE1vc2FpY1J1bGUpLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEZWZhdWx0VW5zcGVjaWZpZWRWYXJpYWJsZShhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvblswXS52YXJpYWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RlZmluaXRpb24gPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbi5tYXAoKGRlZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RGVmID0gZGVmLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEZWYudmFyaWFibGVOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdEZWY7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtb3NhaWNSdWxlLm11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gbmV3RGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vc2FpY1J1bGUubXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGF5ZXIubW9zYWljUnVsZSA9IG1vc2FpY1J1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXllci5tdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFyaWFibGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVJbmZvID0gdGhpcy5nZXRWYXJpYWJsZUluZm8oYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25bMF0udmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlbmRlcmVyIH0gPSBsYXllcjtcbiAgICAgICAgICAgICAgICBpZiAoKHJlbmRlcmVyID09PSBudWxsIHx8IHJlbmRlcmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJlci50eXBlKSA9PT0gXCJyYXN0ZXItc3RyZXRjaFwiICYmICgoX2MgPSB2YXJpYWJsZUluZm8uc3RhdGlzdGljcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UmVuZGVyZXIgPSByZW5kZXJlci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdSZW5kZXJlci5zdGF0aXN0aWNzID0gdmFyaWFibGVJbmZvLnN0YXRpc3RpY3MubWFwKChzdGF0cykgPT4gKE9iamVjdC5hc3NpZ24oe30sIHN0YXRzKSkpO1xuICAgICAgICAgICAgICAgICAgICBsYXllci5yZW5kZXJlciA9IG5ld1JlbmRlcmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgdGhpcy51cGRhdGVMYXllck11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQsIGxheWVyIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgZnVsbERpbWVuc2lvbmFsU3Vic2V0ID0gdGhpcy5nZXREZWZhdWx0TXVsdGlkaW1lbnNpb25hbFN1YnNldCgpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNpbXBsZSBjb21wYXJpc29uICh0byBkZWZhdWx0KSB0byBvcHRpbWl6ZSBwZXJzaXN0ZWQgbGF5ZXIncyBzaXplXG4gICAgICAgICAgICAvLyBpdCBkb2VzIG5vIGhhcm0gaWYgYSBjdXN0b20gbGF5ZXIgY29udGFpbnMgZGVmaW5pdGlvbnMgd2l0aCBhbHRlcmVkIHZhcmlhYmxlIG9yZGVyLlxuICAgICAgICAgICAgY29uc3QgaXNTdWJzZXREZWZpbml0aW9uc1NwZWNpZmllZCA9IHRoaXMuaXNQcm9wZXJ0eVZhbHVlQ2hhbmdlZChhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LnN1YnNldERlZmluaXRpb25zLCBmdWxsRGltZW5zaW9uYWxTdWJzZXQuc3Vic2V0RGVmaW5pdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgaXNBT0lTcGVjaWZpZWQgPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmFyZWFPZkludGVyZXN0ICE9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWlzU3Vic2V0RGVmaW5pdGlvbnNTcGVjaWZpZWQgJiYgIWlzQU9JU3BlY2lmaWVkKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIubXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3Vic2V0RGVmaW5pdGlvbnNTcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U3Vic2V0ID0gYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWJzZXQuc3Vic2V0RGVmaW5pdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIubXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IG5ld1N1YnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLm11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgdGhpcy5oaWRlUGFuZWxIZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFuZWxIZWFkaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRpc21pc3NpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZUJ1dHRvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlRXh0ZW50U2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpZGVBT0kgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0RpbWVuc2lvbkxpc3RTb3J0YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbGxhcHNlRXh0ZW50U2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZUNvbXBhY3RFeHRlbnREcm9wZG93bnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93VmFyaWFibGVGaWx0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMud2F0Y2hWaWV3VGltZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLndhdGNoUmFzdGVyRnVuY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZVdoZW5DYW5jZWwgPSB0cnVlO1xuICAgICAgICB0aGlzLm1ha2VMaXZlTGF5ZXJVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNob3dBbmltYXRpb25Db250cm9scyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3dBbmltYXRpb25PblN0YXJ0VXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93QW5pbWF0aW9uVG9vbHRpcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblNldHRpbmcgPSB7XG4gICAgICAgICAgICBwbGF5UmF0ZTogMzAwMCxcbiAgICAgICAgICAgIHRpbWVDbGFzc05hbWU6IFwiaW1hZ2VyeS1kaW1lbnNpb24tcGlja2VyLXRcIixcbiAgICAgICAgICAgIHpDbGFzc05hbWU6IFwiaW1hZ2VyeS1kaW1lbnNpb24tcGlja2VyLXpcIixcbiAgICAgICAgICAgIHRpbWVUb29sdGlwUGxhY2VtZW50OiBcInRvcFwiLFxuICAgICAgICAgICAgelRvb2x0aXBQbGFjZW1lbnQ6IFwiYXV0b1wiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmlldyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNvcnREaXJlY3Rpb25zID0ge307XG4gICAgICAgIHRoaXMuYW5pbWF0ZWREaW1lbnNpb25zID0geyB0aW1lOiBcIlwiLCB6OiBcIlwiIH07XG4gICAgfVxuICAgIHdhdGNoTGF5ZXIobmV3VmFsdWUsIF9vbGRWYWx1ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgICAgICB0aGlzLm11bHRpZGltZW5zaW9uYWxJbmZvID0gbnVsbDtcbiAgICAgICAgKF9hID0gdGhpcy53YXRjaEhhbmRsZVZpZXdUaW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMud2F0Y2hIYW5kbGVMYXllciA9IG51bGw7XG4gICAgICAgIChfYiA9IHRoaXMud2F0Y2hIYW5kbGVMYXllcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLndhdGNoSGFuZGxlTGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRMYXllcihuZXdWYWx1ZSk7XG4gICAgfVxuICAgIHdhdGNoQWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIC8vIG9sZFZhbHVlIGlzIG51bGwgZHVyaW5nIGluaXRpYWxpemF0aW9uLCBuZXdWYWx1ZSBjYW4ndCBiZSBudWxsXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsIHx8IG9sZFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvcnREaXJlY3Rpb25zID0ge307XG4gICAgICAgIGlmICghdGhpcy5wYXVzZUxheWVyVXBkYXRlICYmIHRoaXMubWFrZUxpdmVMYXllclVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMYXllck11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgbXVsdGlkaW1lbnNpb25hbERlZmluaXRpb246IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBkZXN0cm95IHZhbHVlIHBpY2tlciB3aGVuIHRoZSBjb3JyZXNwb25kaW5nIGRpbWVuc2lvbiBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIG5ldyB2YXJpYWJsZVxuICAgICAgICBjb25zdCB7IGFuaW1hdGVkRGltZW5zaW9ucywgc2hvd0FuaW1hdGlvbkNvbnRyb2xzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc2hvd0FuaW1hdGlvbkNvbnRyb2xzICYmXG4gICAgICAgICAgICAoYW5pbWF0ZWREaW1lbnNpb25zLnRpbWUgfHwgYW5pbWF0ZWREaW1lbnNpb25zLnopICYmXG4gICAgICAgICAgICBuZXdWYWx1ZVswXS52YXJpYWJsZU5hbWUgIT09IG9sZFZhbHVlWzBdLnZhcmlhYmxlTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVJbmZvID0gdGhpcy5nZXRWYXJpYWJsZUluZm8obmV3VmFsdWVbMF0udmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgIGlmICghdmFyaWFibGVJbmZvLmRpbWVuc2lvbnMuc29tZSgoeyBuYW1lIH0pID0+IG5hbWUgPT09IGFuaW1hdGVkRGltZW5zaW9ucy50aW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveVZhbHVlUGlja2VyKFwidGltZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFyaWFibGVJbmZvLmRpbWVuc2lvbnMuc29tZSgoeyBuYW1lIH0pID0+IG5hbWUgPT09IGFuaW1hdGVkRGltZW5zaW9ucy56KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveVZhbHVlUGlja2VyKFwielwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB3YXRjaGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQobmV3VmFsdWUsIF9vbGRWYWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIHRvZG86IEFQSSBzdXBwb3J0XG4gICAgICAgIGlmICghdGhpcy5wYXVzZUxheWVyVXBkYXRlICYmIHRoaXMubWFrZUxpdmVMYXllclVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMYXllck11bHRpZGltZW5zaW9uYWxTdWJzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uIH0gPSB0aGlzO1xuICAgICAgICBpZiAoKChfYSA9IG5ld1ZhbHVlLnZhcmlhYmxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgJiYgKGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID09PSBudWxsIHx8IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbi5sZW5ndGgpKSB7XG4gICAgICAgICAgICAvLyB1c2Ugb3JpZ2luYWwgb3JkZXJcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZXMgPSB0aGlzLmFsbFZhcmlhYmxlc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsgbmFtZSB9KSA9PiBuZXdWYWx1ZS52YXJpYWJsZXMuaW5jbHVkZXMobmFtZSkpXG4gICAgICAgICAgICAgICAgLm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlVmFyaWFibGVOYW1lID0gYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25bMF0udmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFyaWFibGVOYW1lID0gYWN0aXZlVmFyaWFibGVOYW1lID09PSBcIlwiIHx8IG5ld1ZhbHVlLnZhcmlhYmxlcy5pbmNsdWRlcyhhY3RpdmVWYXJpYWJsZU5hbWUpXG4gICAgICAgICAgICAgICAgPyBhY3RpdmVWYXJpYWJsZU5hbWVcbiAgICAgICAgICAgICAgICA6IHZhcmlhYmxlTmFtZXNbMF07XG4gICAgICAgICAgICBjb25zdCBuZXdEZWYgPSB0aGlzLmdldE5ld011bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKG5ld1ZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBpc0RlZmluaXRpb25DaGFuZ2VkID0gdGhpcy5pc011bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uQ2hhbmdlZChuZXdEZWYpO1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5pdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gbmV3RGVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgbXVsdGlkaW1lbnNpb25hbFN1YnNldDogbmV3VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbENoYW5nZS5lbWl0KGRhdGEpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgIFt0aGlzLnN0cmluZ3NdID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgW1xuICAgICAgICAgICAgdGhpcy5lc3JpTGFuZyxcbiAgICAgICAgICAgIHRoaXMuaW50bCxcbiAgICAgICAgICAgIHRoaXMuRGltZW5zaW9uYWxEZWZpbml0aW9uLFxuICAgICAgICAgICAgdGhpcy5NdWx0aWRpbWVuc2lvbmFsU3Vic2V0LFxuICAgICAgICAgICAgdGhpcy5WYWx1ZVBpY2tlclxuICAgICAgICBdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgICAgICAgICAgXCJlc3JpL2NvcmUvbGFuZ1wiLFxuICAgICAgICAgICAgXCJlc3JpL2ludGxcIixcbiAgICAgICAgICAgIFwiZXNyaS9sYXllcnMvc3VwcG9ydC9EaW1lbnNpb25hbERlZmluaXRpb25cIixcbiAgICAgICAgICAgIFwiZXNyaS9sYXllcnMvc3VwcG9ydC9NdWx0aWRpbWVuc2lvbmFsU3Vic2V0XCIsXG4gICAgICAgICAgICBcImVzcmkvd2lkZ2V0cy9WYWx1ZVBpY2tlclwiXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCB7IGxheWVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAobGF5ZXIubG9hZGVkKSB7XG4gICAgICAgICAgICAvLyBsb2FkIG11bHRpZGltZW5zaW9uYWwgaW5mbyAobWF5IG9yIG1heSBub3QgaW52b2x2ZSBhY3R1YWwgYXN5bmMgZmV0Y2hpbmcpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRMYXllcihsYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBsb2FkIGxheWVyIChzaG93IGxvYWRpbmcgc2lnbikgYW5kIG11bHRpZGltZW5zaW9uYWwgaW5mb1xuICAgICAgICAgICAgdGhpcy5pbml0TGF5ZXIobGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyVG9wID0gdGhpcy5ob3N0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lWYWx1ZVBpY2tlcihcImJvdGhcIik7XG4gICAgICAgIChfYSA9IHRoaXMud2F0Y2hIYW5kbGVWaWV3VGltZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAoX2IgPSB0aGlzLndhdGNoSGFuZGxlTGF5ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdmUoKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBwdWJsaWMgbWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBzZXRGb2N1cyhmb2N1c0lkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGZvY3VzSWQgPT09IFwiZGlzbWlzcy1idXR0b25cIiB8fCAoIWZvY3VzSWQgJiYgdGhpcy5kaXNtaXNzaWJsZSkpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmVmQ2xvc2VCdXR0b25Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmUGFuZWxOb2RlLnNldEZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZG9uZSgpIHtcbiAgICAgICAgdGhpcy5hcHBseSgpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFJlbmRlcmVyIG1ldGhvZHNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnBvcE92ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9wb3ZlclByb3BzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgY29uc3QgeyBoaWRlUGFuZWxIZWFkaW5nLCBkaXNtaXNzaWJsZSwgaGlkZUJ1dHRvbnMsIHBhbmVsSGVhZGluZywgaGlkZUV4dGVudFNlY3Rpb24sIHN0cmluZ3M6IHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxvYWRpbmcgPSAhKChfYSA9IHRoaXMubGF5ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2FkZWQpO1xuICAgICAgICBpZiAoIXRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc3VwcG9ydGVkRGl2ID0gbG9hZGluZyA/IG51bGwgOiAoaChcImRpdlwiLCB7IGNsYXNzOiBcIm11bHRpZGltZW5zaW9uYWwtdW5zdXBwb3J0ZWRcIiB9LCBzdHJpbmdzLmdlbmVyYWwudW5zdXBwb3J0ZWQpKTtcbiAgICAgICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtcGFuZWxcIiwgeyBsb2FkaW5nOiBsb2FkaW5nLCBoZWFkaW5nOiAhaGlkZVBhbmVsSGVhZGluZyA/IHBhbmVsSGVhZGluZyAhPT0gbnVsbCAmJiBwYW5lbEhlYWRpbmcgIT09IHZvaWQgMCA/IHBhbmVsSGVhZGluZyA6IHN0cmluZ3MudGl0bGUgOiB1bmRlZmluZWQsIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICAgICAgICAgICAgfSwgcmVmOiAobm9kZSkgPT4gKHRoaXMucmVmUGFuZWxOb2RlID0gbm9kZSkgfSwgZGlzbWlzc2libGUgJiYgdGhpcy5yZW5kZXJDbG9zZSgpLCB1bnN1cHBvcnRlZERpdiwgIWhpZGVCdXR0b25zICYmIHRoaXMucmVuZGVyRG9uZUJ1dHRvbigpLCAhaGlkZUJ1dHRvbnMgJiYgdGhpcy5yZW5kZXJDYW5jZWxCdXR0b24oKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiY2FsY2l0ZS1wYW5lbFwiLCB7IGxvYWRpbmc6IGZhbHNlLCBoZWFkaW5nOiAhaGlkZVBhbmVsSGVhZGluZyA/IHBhbmVsSGVhZGluZyAhPT0gbnVsbCAmJiBwYW5lbEhlYWRpbmcgIT09IHZvaWQgMCA/IHBhbmVsSGVhZGluZyA6IHN0cmluZ3MudGl0bGUgOiB1bmRlZmluZWQsIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcGFuZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IHJ0bFxuICAgICAgICAgICAgfSwgcmVmOiAobm9kZSkgPT4gKHRoaXMucmVmUGFuZWxOb2RlID0gbm9kZSkgfSwgZGlzbWlzc2libGUgPyB0aGlzLnJlbmRlckNsb3NlKCkgOiBudWxsLCBoaWRlRXh0ZW50U2VjdGlvbiA/IG51bGwgOiB0aGlzLnJlbmRlckV4dGVudCgpLCB0aGlzLnJlbmRlckN1cnJlbnREaXNwbGF5KCksIGhpZGVCdXR0b25zID8gbnVsbCA6IHRoaXMucmVuZGVyRG9uZUJ1dHRvbigpLCBoaWRlQnV0dG9ucyA/IG51bGwgOiB0aGlzLnJlbmRlckNhbmNlbEJ1dHRvbigpKSkpO1xuICAgIH1cbiAgICByZW5kZXJDdXJyZW50RGlzcGxheSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uLCBzdHJpbmdzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzdWJzZXRWYXJpYWJsZXMgPSB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQudmFyaWFibGVzO1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSB0aGlzLmFsbFZhcmlhYmxlcy5maWx0ZXIoKHsgbmFtZSB9KSA9PiAhc3Vic2V0VmFyaWFibGVzLmxlbmd0aCB8fCBzdWJzZXRWYXJpYWJsZXMuaW5jbHVkZXMobmFtZSkpO1xuICAgICAgICBjb25zdCB7IGxheWVyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpc0R5bmFtaWNJbWFnZXJ5ID0gdGhpcy5pc0ltYWdlcnlMYXllcihsYXllcik7XG4gICAgICAgIGNvbnN0IGhhc1N0YXJPck5ld1ZhcmlhYmxlID0gaXNEeW5hbWljSW1hZ2VyeSAmJlxuICAgICAgICAgICAgKHZhcmlhYmxlcy5zb21lKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gXCIqXCIpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNOZXdWYXJpYWJsZSh0aGlzLm11bHRpZGltZW5zaW9uYWxJbmZvKSk7XG4gICAgICAgIC8vIHNpbmNlIG11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uIGNhbiBvbmx5IGJlIHVzZWQgZm9yIHNlbGVjdGlvbiwgaXQgY2Fubm90IGJlIHVzZWQgdG9cbiAgICAgICAgLy8gd29yayB3aXRoIG5ldyB2YXJpYWJsZXMgYWZ0ZXIgcmFzdGVyRnVuY3Rpb25cbiAgICAgICAgbGV0IGFjdGl2ZVZhcmlhYmxlTmFtZSA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uWzBdLnZhcmlhYmxlTmFtZTtcbiAgICAgICAgLy8gaGFuZGxlIHNwZWNpYWwgdmFyaWFibGUgbmFtZSBmcm9tIGEgc2VydmVyIHNpZGUgcmZ0LlxuICAgICAgICAvLyBmb3IgMTAuOSsgc2VydmVycywgYW4gcmZ0IHdpdGggcXVlcnkgZGVmaW5pdGlvbiB3aWxsIHJlc3VsdCBhICogdmFyaWFibGUsIHdoaWNoIGlzIGVxdWl2YWxlbnQgb2YgdW5zcGVjaWZpZWQgdmFyaWFibGUgbmFtZVxuICAgICAgICBpZiAoaXNEeW5hbWljSW1hZ2VyeSkge1xuICAgICAgICAgICAgY29uc3QgeyByYXN0ZXJGdW5jdGlvbiwgdmVyc2lvbiB9ID0gbGF5ZXI7XG4gICAgICAgICAgICBjb25zdCBoYXNSYXN0ZXJGdW5jdGlvbiA9IHJhc3RlckZ1bmN0aW9uICYmICgoX2EgPSByYXN0ZXJGdW5jdGlvbi5mdW5jdGlvbk5hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSAhPT0gXCJub25lXCI7XG4gICAgICAgICAgICBpZiAoaGFzUmFzdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiA8PSBtaW5WZXJzaW9uUkZUTXVsdGlkaW1lbnNpb25hbEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzLnVuc2hpZnQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YXJpYWJsZXNbMF0pLCB7IG5hbWU6IHN0cmluZ3MuZGlzcGxheS5kZWZhdWx0VmFyaWFibGUsIGxhYmVsOiBzdHJpbmdzLmRpc3BsYXkuZGVmYXVsdFZhcmlhYmxlIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVZhcmlhYmxlTmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVWYXJpYWJsZU5hbWUgPSBoYXNTdGFyT3JOZXdWYXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YXJpYWJsZXNbMF0ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzdHJpbmdzLmRpc3BsYXkuZGVmYXVsdFZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gdmFyaWFibGVzLmZpbmRJbmRleCgodmFyaWFibGVJbmZvKSA9PiB2YXJpYWJsZUluZm8ubmFtZSA9PT0gYWN0aXZlVmFyaWFibGVOYW1lKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0U3RyaW5ncyA9IHtcbiAgICAgICAgICAgIGNsZWFyRmlsdGVyOiBzdHJpbmdzLnNlbGVjdC5jbGVhckZpbHRlcixcbiAgICAgICAgICAgIGZpbHRlclRleHQ6IHN0cmluZ3Muc2VsZWN0LmZpbHRlclRleHQsXG4gICAgICAgICAgICBmaWx0ZXJMYWJlbDogc3RyaW5ncy5leHRlbnQuc2VhcmNoVmFyaWFibGVzLFxuICAgICAgICAgICAgc2VsZWN0TGFiZWw6IHN0cmluZ3MuZXh0ZW50LnNlbGVjdFZhcmlhYmxlc1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2YXJpYWJsZVNlbGVjdCA9IChoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHN0cmluZ3MuZGlzcGxheS52YXJpYWJsZSwgaChcImFyY2dpcy1sYXp5LWxvYWRpbmctc2VsZWN0XCIsIHsgc2VsZWN0ZWRJbmRleDogc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyAwIDogc2VsZWN0ZWRJbmRleCwgbGlzdDogdmFyaWFibGVzLm1hcCgodmFyaWFibGVJbmZvKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YXJpYWJsZUluZm8pLCB7IHZhbHVlOiB2YXJpYWJsZUluZm8ubmFtZSB9KSkpLCBzdHJpbmdzOiBzZWxlY3RTdHJpbmdzLCBrZXk6IHRoaXMuc291cmNlS2V5LCBvbkFyY2dpc0xhenlMb2FkaW5nU2VsZWN0Q2hhbmdlOiAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYXJpYWJsZU5hbWUgPSBldnQuZGV0YWlsLnNlbGVjdGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEZWZpbml0aW9uVmFyaWFibGVOYW1lKHNlbGVjdGVkVmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgIH0sIGNvbnRhaW5lclRvcDogdGhpcy5jb250YWluZXJUb3AgfSkpKSk7XG4gICAgICAgIC8vIHJlc3RvcmUgc3BlY2lhbCBhY3RpdmVWYXJpYWJsZU5hbWUuIHN0YXIgdmFyaWFibGUgaXMgZmluZSBmb3IgdGhlIGZvbGxvd2luZyB2YXJpYWJsZUluZm8gbG9va3VwXG4gICAgICAgIGlmIChhY3RpdmVWYXJpYWJsZU5hbWUgPT09IHN0cmluZ3MuZGlzcGxheS5kZWZhdWx0VmFyaWFibGUpIHtcbiAgICAgICAgICAgIGFjdGl2ZVZhcmlhYmxlTmFtZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFyaWFibGVJbmZvID0gdGhpcy5nZXRWYXJpYWJsZUluZm8oYWN0aXZlVmFyaWFibGVOYW1lKTtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uQmxvY2tzID0gdmFyaWFibGVJbmZvLmRpbWVuc2lvbnMubWFwKChkaW1JbmZvKSA9PiB7XG4gICAgICAgICAgICBkaW1JbmZvID0gZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8oZGltSW5mbywgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckRpbWVuc2lvbihkaW1JbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYmxvY2tcIiwgeyBoZWFkaW5nOiBzdHJpbmdzLmRpc3BsYXkuY3VycmVudCwgY29sbGFwc2libGU6IHRydWUsIG9wZW46IHRydWUgfSwgdmFyaWFibGVTZWxlY3QsIGRpbWVuc2lvbkJsb2NrcykpO1xuICAgIH1cbiAgICByZW5kZXJQaWNrTGlzdFBvcG92ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcE92ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3BPdmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1maWVsZC1waWNrLWxpc3RcIik7XG4gICAgICAgIGNvbnN0IHBvcG92ZXJXaWR0aCA9IHRoaXMucmVmUGFuZWxOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBwb3BPdmVyLnBvcG92ZXJQcm9wcyA9IHtcbiAgICAgICAgICAgIHJlZkVsZW1lbnQ6IHRoaXMucmVmUGFuZWxOb2RlLFxuICAgICAgICAgICAgcGxhY2VtZW50OiBcImxlYWRpbmctZW5kXCIsXG4gICAgICAgICAgICBvZmZzZXREaXN0YW5jZTogMSxcbiAgICAgICAgICAgIG9mZnNldFNraWRkaW5nOiA0OCxcbiAgICAgICAgICAgIHBvcG92ZXJXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBwb3BPdmVyLmhlYWRpbmcgPSB0aGlzLnN0cmluZ3MuZXh0ZW50LnNlbGVjdFZhcmlhYmxlcztcbiAgICAgICAgcG9wT3Zlci5maWx0ZXJQbGFjZWhvbGRlclRleHQgPSB0aGlzLnN0cmluZ3MuZXh0ZW50LnNlYXJjaFZhcmlhYmxlcztcbiAgICAgICAgcG9wT3Zlci5zaG93RmllbGRJbmZvID0gZmFsc2U7XG4gICAgICAgIHBvcE92ZXIuc2hvd0ZpZWxkTmFtZSA9IGZhbHNlO1xuICAgICAgICBwb3BPdmVyLnNob3dEZXNjcmlwdGlvbiA9IHRydWU7XG4gICAgICAgIHBvcE92ZXIuc2hvd1NlbGVjdGlvbkFsbCA9IHRydWU7XG4gICAgICAgIHBvcE92ZXIuc2hvd0NhbmNlbCA9IGZhbHNlO1xuICAgICAgICBwb3BPdmVyLnNob3dTb3J0ID0gZmFsc2U7XG4gICAgICAgIHBvcE92ZXIuc29ydEJ5ID0gTGFzdFNvcnR5QnkuZGVmYXVsdDtcbiAgICAgICAgcG9wT3Zlci5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIHRoaXMucG9wT3ZlciA9IHBvcE92ZXI7XG4gICAgICAgIHRoaXMucHJldmlvdXNQaWNrZWRMaXN0U2l6ZSA9IC0xO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvcG92ZXJQcm9wcygpO1xuICAgICAgICBwb3BPdmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNGaWVsZFBpY2tMaXN0Q2hhbmdlXCIsIChldnQpID0+IHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZFZhcmlhYmxlcyA9IGV2dC5kZXRhaWwuc2VsZWN0ZWRGaWVsZHMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudFZhcmlhYmxlcyhzZWxlY3RlZFZhcmlhYmxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwb3BPdmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNGaWVsZFBpY2tMaXN0RGlzbWlzc2VkXCIsIChfZXZ0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3BPdmVyKTtcbiAgICB9XG4gICAgcmVuZGVyRXh0ZW50KCkge1xuICAgICAgICBjb25zdCB2YXJpYWJsZUxpc3QgPSB0aGlzLnJlbmRlclZhcmlhYmxlTGlzdCgpO1xuICAgICAgICBjb25zdCB7IGV4dGVudDogZXh0ZW50U3RyaW5ncyB9ID0gdGhpcy5zdHJpbmdzO1xuICAgICAgICBjb25zdCB2YXJpYWJsZVNlbGVjdEJ1dHRvbiA9IHRoaXMuYWxsVmFyaWFibGVzLmxlbmd0aCA+IDEgJiYgKGgoXCJkaXZcIiwgeyBjbGFzczogXCJ2YXJpYWJsZS1zZWxlY3RcIiB9LCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBzY2FsZTogXCJzXCIsIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIGtpbmQ6IFwibmV1dHJhbFwiLCByb3VuZDogdHJ1ZSwgYWxpZ25tZW50OiBcImNlbnRlclwiLCBpY29uU3RhcnQ6IFwicGx1c1wiLCBvbkNsaWNrOiAoKSA9PiB0aGlzLnJlbmRlclBpY2tMaXN0UG9wb3ZlcigpIH0sIGV4dGVudFN0cmluZ3MudmFyaWFibGVzKSkpO1xuICAgICAgICBjb25zdCBhbGxEaW1lbnNpb3NuID0gW107XG4gICAgICAgIHRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8udmFyaWFibGVzLmZvckVhY2goKHsgZGltZW5zaW9ucyB9KSA9PiBhbGxEaW1lbnNpb3NuLnB1c2goLi4uZGltZW5zaW9ucykpO1xuICAgICAgICBjb25zdCBleHRlbnRCbG9ja3MgPSB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQuZGltZW5zaW9ucy5tYXAoKHsgbmFtZSwgZXh0ZW50IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpbUluZm8gPSBhbGxEaW1lbnNpb3NuLmZpbmQoKHsgbmFtZTogZGltTmFtZSB9KSA9PiBkaW1OYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckRpbWVuc2lvbkV4dGVudChkaW1JbmZvLCBleHRlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYW9pQmxvY2sgPSB0aGlzLmhpZGVBT0kgPyB1bmRlZmluZWQgOiB0aGlzLnJlbmRlckFPSSgpO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJsb2NrXCIsIHsgaGVhZGluZzogZXh0ZW50U3RyaW5ncy5leHRlbnQsIGNvbGxhcHNpYmxlOiB0cnVlLCBvcGVuOiAhdGhpcy5jb2xsYXBzZUV4dGVudFNlY3Rpb24sIG9uQ2FsY2l0ZUJsb2NrVG9nZ2xlOiAoKSA9PiB0aGlzLmNsb3NlUG9wb3ZlcigpIH0sIHZhcmlhYmxlTGlzdCwgdmFyaWFibGVTZWxlY3RCdXR0b24sIGV4dGVudEJsb2NrcywgYW9pQmxvY2spKTtcbiAgICB9XG4gICAgcmVuZGVyVmFyaWFibGVMaXN0KCkge1xuICAgICAgICBjb25zdCBzdWJzZXRWYXJpYWJsZXMgPSB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQudmFyaWFibGVzO1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSB0aGlzLmFsbFZhcmlhYmxlcy5maWx0ZXIoKHsgbmFtZSB9KSA9PiAhc3Vic2V0VmFyaWFibGVzLmxlbmd0aCB8fCBzdWJzZXRWYXJpYWJsZXMuaW5jbHVkZXMobmFtZSkpO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGhpZGRlbiA9IHRoaXMuYWxsVmFyaWFibGVzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHN0cmluZ3MuZXh0ZW50LnZhcmlhYmxlcywgaChcImNhbGNpdGUtbGlzdFwiLCB7IGNsYXNzOiBcInZhcmlhYmxlLXNlY3Rpb24tYm9hcmRlclwiIH0sIHZhcmlhYmxlcy5tYXAoKHsgbmFtZSwgbGFiZWwsIGRlc2NyaXB0aW9uIH0pID0+IChoKFwiY2FsY2l0ZS1saXN0LWl0ZW1cIiwgeyBsYWJlbDogbGFiZWwsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiwga2V5OiBuYW1lIH0sIGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IGljb246IFwieFwiLCBzY2FsZTogXCJzXCIsIHRleHQ6IHN0cmluZ3MuZ2VuZXJhbC5jbG9zZSwgc2xvdDogXCJhY3Rpb25zLWVuZFwiLCBoaWRkZW46IGhpZGRlbiwgb25DbGljazogKCkgPT4gdGhpcy5fcmVtb3ZlVmFyaWFibGUobmFtZSkgfSkpKSkpKSkpO1xuICAgIH1cbiAgICByZW5kZXJBT0koKSB7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYW9pT3B0aW9ucyA9IFtcbiAgICAgICAgICAgIHsgdmFsdWU6IFwiZGVmYXVsdFwiLCBsYWJlbDogc3RyaW5ncy5leHRlbnQuZGVmYXVsdCwgc2VsZWN0ZWQ6IHRoaXMuYW9pSW5kZXggPT09IDAgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6IFwibWFwXCIsIGxhYmVsOiBzdHJpbmdzLmV4dGVudC5tYXBFeHRlbnQsIHNlbGVjdGVkOiB0aGlzLmFvaUluZGV4ID09PSAxIH1cbiAgICAgICAgXTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IGFvaU9wdGlvbnMuZmluZEluZGV4KCh7IHNlbGVjdGVkIH0pID0+IHNlbGVjdGVkKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0U3RyaW5ncyA9IHtcbiAgICAgICAgICAgIGNsZWFyRmlsdGVyOiB0aGlzLnN0cmluZ3Muc2VsZWN0LmNsZWFyRmlsdGVyLFxuICAgICAgICAgICAgZmlsdGVyVGV4dDogdGhpcy5zdHJpbmdzLnNlbGVjdC5maWx0ZXJUZXh0LFxuICAgICAgICAgICAgZmlsdGVyTGFiZWw6IHRoaXMuc3RyaW5ncy5leHRlbnQuc2VhcmNoQU9JLFxuICAgICAgICAgICAgc2VsZWN0TGFiZWw6IHRoaXMuc3RyaW5ncy5leHRlbnQuc2VsZWN0QU9JXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCBudWxsLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBzdHJpbmdzLmV4dGVudC5hb2ksIGgoXCJhcmNnaXMtbGF6eS1sb2FkaW5nLXNlbGVjdFwiLCB7IHNlbGVjdGVkSW5kZXg6IHNlbGVjdGVkSW5kZXgsIGxpc3Q6IGFvaU9wdGlvbnMsIHN0cmluZ3M6IHNlbGVjdFN0cmluZ3MsIG9uQXJjZ2lzTGF6eUxvYWRpbmdTZWxlY3RDaGFuZ2U6IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldnQuZGV0YWlsLnNlbGVjdGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgYW9pID0gdmFsdWUgPT09IFwiZGVmYXVsdFwiID8gbnVsbCA6IChfYSA9IHRoaXMudmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4dGVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmFvaUluZGV4ID0gdmFsdWUgPT09IFwiZGVmYXVsdFwiID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRlbnRBT0koYW9pKTtcbiAgICAgICAgICAgIH0sIGNvbnRhaW5lclRvcDogdGhpcy5jb250YWluZXJUb3AgfSkpKSk7XG4gICAgfVxuICAgIF9yZW1vdmVWYXJpYWJsZSh2YXJpYWJsZU5hbWUpIHtcbiAgICAgICAgY29uc3QgbmV3QWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5jbG9uZSgpO1xuICAgICAgICBsZXQgc3Vic2V0RGVmaW5pdGlvbnMgPSBuZXdBY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LnN1YnNldERlZmluaXRpb25zLmZpbHRlcigoZGVmKSA9PiBkZWYudmFyaWFibGVOYW1lICE9PSB2YXJpYWJsZU5hbWUpO1xuICAgICAgICBpZiAoc3Vic2V0RGVmaW5pdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdWJzZXREZWZpbml0aW9ucyA9IHRoaXMuZ2V0RGVmYXVsdE11bHRpZGltZW5zaW9uYWxTdWJzZXQoKS5zdWJzZXREZWZpbml0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBuZXdBY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LnN1YnNldERlZmluaXRpb25zID0gc3Vic2V0RGVmaW5pdGlvbnM7XG4gICAgICAgIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IG5ld0FjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQ7XG4gICAgfVxuICAgIHJlbmRlckRpbWVuc2lvbkxpc3QoZGltZW5zaW9uSW5mbywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB7IHNlbGVjdGVkVmFsdWUsIGtleSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgaXNTdGFydE9yRW5kID0gKGtleSA9PT0gbnVsbCB8fCBrZXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGtleS5pbmNsdWRlcyhcInN0YXJ0XCIpKSB8fCAoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gdm9pZCAwID8gdm9pZCAwIDoga2V5LmluY2x1ZGVzKFwiZW5kXCIpKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoKF9hID0gZGltZW5zaW9uSW5mby52YWx1ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgJiYgdHlwZW9mIHNlbGVjdGVkVmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpbVZhbHVlcyA9IGRpbWVuc2lvbkluZm8udmFsdWVzO1xuICAgICAgICAgICAgaWYgKGlzU3RhcnRPckVuZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFsdWUgPSBkaW1WYWx1ZXMuZmluZCgodmFsdWUpID0+IGtleS5pbmNsdWRlcyhcInN0YXJ0XCIpID8gdmFsdWVbMF0gPT09IHNlbGVjdGVkVmFsdWUgOiB2YWx1ZVsxXSA9PT0gc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtYXRjaCBzdGFydCwgdGhlbiBtYXRjaCBlbmRcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFZhbHVlID0gZGltVmFsdWVzLmZpbmQoKHZhbHVlKSA9PiB2YWx1ZVswXSA9PT0gc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFZhbHVlID0gZGltVmFsdWVzLmZpbmQoKHZhbHVlKSA9PiB2YWx1ZVsxXSA9PT0gc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzVW5kZWZpbmVkVmFsdWUgPSBzZWxlY3RlZFZhbHVlID09PSB1bmRlZmluZWRfZGltZW5zaW9uX3ZhbHVlIHx8XG4gICAgICAgICAgICBvcHRpb25zLnNlbGVjdGVkVmFsdWUgPT09IHVuZGVmaW5lZF9kaW1lbnNpb25fdmFsdWU7XG4gICAgICAgIGNvbnN0IGFjdGl2ZURpbWVuc2lvbkxhYmVsID0gaXNVbmRlZmluZWRWYWx1ZVxuICAgICAgICAgICAgPyBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA6IGZvcm1hdERpbWVuc2lvblZhbHVlKHNlbGVjdGVkVmFsdWUsIGRpbWVuc2lvbkluZm8sIHtcbiAgICAgICAgICAgICAgICBpbnRsOiB0aGlzLmludGwsXG4gICAgICAgICAgICAgICAgdXNlUmVjdXJyaW5nVGltZUxhYmVsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgLy8gbnVtYmVyIGlzIG5vdCB3ZWxsIHN1cHBvcnRlZCBieSBjYWxjaXRlLXNlbGVjdFxuICAgICAgICAvLyA8b3B0aW9uIGxhYmVsPVwiMFwiIHZhbHVlPVwiXCI+MDwvb3B0aW9uPiAobnVsbC90cnV0aHkgY2hlY2sgaXNzdWU/KVxuICAgICAgICAvLyBzdGFydC9lbmQgdGltZSBjb2x1bW4gcmVuZGVycyBzYW1lIChob3cgaXMgdGhpcyByZWxhdGVkIHRvIG51bWJlcj8pXG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IFwiIC0gXCI7XG4gICAgICAgIGNvbnN0IGlzQXNjZW5kaW5nID0gb3B0aW9ucy5zb3J0YWJsZVxuICAgICAgICAgICAgPyB0aGlzLnNvcnREaXJlY3Rpb25zW2RpbWVuc2lvbkluZm8ubmFtZV0gIT09IFwiZGVzY2VuZGluZ1wiXG4gICAgICAgICAgICA6IHRydWU7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvblZhbHVlcyA9IGlzQXNjZW5kaW5nXG4gICAgICAgICAgICA/IGRpbWVuc2lvbkluZm8udmFsdWVzXG4gICAgICAgICAgICA6IFsuLi5kaW1lbnNpb25JbmZvLnZhbHVlc10ucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkaW1lbnNpb25WYWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBmb3JtYXREaW1lbnNpb25WYWx1ZSh2YWx1ZSwgZGltZW5zaW9uSW5mbywge1xuICAgICAgICAgICAgICAgIGludGw6IHRoaXMuaW50bCxcbiAgICAgICAgICAgICAgICB1c2VSZWN1cnJpbmdUaW1lTGFiZWw6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVTdHIgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oc2VwYXJhdG9yKSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IGxhYmVsID09PSBhY3RpdmVEaW1lbnNpb25MYWJlbDtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke29wdGlvbnMua2V5fS0ke3ZhbHVlU3RyfX1gO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlU3RyLFxuICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0VuZCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogYCR7ZGltZW5zaW9uSW5mby5uYW1lfS1lbmQtdW5kZWZpbmVkfWAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZyh1bmRlZmluZWRfZGltZW5zaW9uX3ZhbHVlKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5zdHJpbmdzLmV4dGVudC5lbmRVbmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGlzVW5kZWZpbmVkVmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uQXJjZ2lzTGF6eUxvYWRpbmdTZWxlY3RDaGFuZ2UgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2dC5kZXRhaWwuc2VsZWN0ZWRWYWx1ZS5zcGxpdChzZXBhcmF0b3IpLm1hcCgodmFsKSA9PiBOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICAoX2EgPSBvcHRpb25zLm9uQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCB2YWx1ZS5sZW5ndGggPT09IDEgPyB2YWx1ZVswXSA6IHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNvcnRJY29uID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuc29ydGFibGUpIHtcbiAgICAgICAgICAgIC8vIGljb24gaXMgdGhlIHdoYXQgdXNlciB3YW50IHRvIGNoYW5nZSB0b1xuICAgICAgICAgICAgY29uc3Qgc29ydEljb25OYW1lID0gaXNUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8pXG4gICAgICAgICAgICAgICAgPyBpc0FzY2VuZGluZ1xuICAgICAgICAgICAgICAgICAgICA/IFwiY2xvY2stdXBcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiY2xvY2stZG93blwiXG4gICAgICAgICAgICAgICAgOiBpc0FzY2VuZGluZ1xuICAgICAgICAgICAgICAgICAgICA/IFwic29ydC1hc2NlbmRpbmctYXJyb3dcIlxuICAgICAgICAgICAgICAgICAgICA6IFwic29ydC1kZXNjZW5kaW5nLWFycm93XCI7XG4gICAgICAgICAgICBzb3J0SWNvbiA9IChoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBpY29uOiBzb3J0SWNvbk5hbWUsIHNjYWxlOiBcInNcIiwgdGV4dDogdGhpcy5zdHJpbmdzLmRpc3BsYXkuc29ydCwgc2xvdDogXCJhY3Rpb25zLWVuZFwiLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU29ydGluZyhkaW1lbnNpb25JbmZvLm5hbWUpO1xuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSB2YWx1ZXMuZmluZEluZGV4KCh7IHNlbGVjdGVkIH0pID0+IHNlbGVjdGVkKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0U3RyaW5ncyA9IHtcbiAgICAgICAgICAgIGNsZWFyRmlsdGVyOiB0aGlzLnN0cmluZ3Muc2VsZWN0LmNsZWFyRmlsdGVyLFxuICAgICAgICAgICAgZmlsdGVyVGV4dDogdGhpcy5zdHJpbmdzLnNlbGVjdC5maWx0ZXJUZXh0LFxuICAgICAgICAgICAgZmlsdGVyTGFiZWw6IHRoaXMuc3RyaW5ncy5leHRlbnQuc2VhcmNoRGltZW5zaW9ucyxcbiAgICAgICAgICAgIHNlbGVjdExhYmVsOiB0aGlzLnN0cmluZ3MuZXh0ZW50LnNlbGVjdERpbWVuc2lvbnNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IFwiZGltZW5zaW9uLXNlbGVjdC1jb250YWluZXJcIiB9LCBoKFwiYXJjZ2lzLWxhenktbG9hZGluZy1zZWxlY3RcIiwgeyBzZWxlY3RlZEluZGV4OiBzZWxlY3RlZEluZGV4ID09PSAtMSA/IDAgOiBzZWxlY3RlZEluZGV4LCBsaXN0OiB2YWx1ZXMsIHN0cmluZ3M6IHNlbGVjdFN0cmluZ3MsIG9uQXJjZ2lzTGF6eUxvYWRpbmdTZWxlY3RDaGFuZ2U6IG9uQXJjZ2lzTGF6eUxvYWRpbmdTZWxlY3RDaGFuZ2UsIGNvbnRhaW5lclRvcDogdGhpcy5jb250YWluZXJUb3AgfSksIHNvcnRJY29uKSk7XG4gICAgfVxuICAgIHJlbmRlckRpbWVuc2lvbihkaW1lbnNpb25JbmZvKSB7XG4gICAgICAgIGNvbnN0IHsgYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbi5maW5kKChkZWYpID0+IGRlZi5kaW1lbnNpb25OYW1lID09PSBkaW1lbnNpb25JbmZvLm5hbWUpO1xuICAgICAgICBjb25zdCBvbkNoYW5nZSA9ICh2YWx1ZSkgPT4gdGhpcy51cGRhdGVEZWZpbml0aW9uRGltZW5zaW9uVmFsdWUoZGltZW5zaW9uSW5mby5uYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvblNlbGVjdCA9IHRoaXMucmVuZGVyRGltZW5zaW9uTGlzdChkaW1lbnNpb25JbmZvLCB7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlOiBkZWZpbml0aW9uLnZhbHVlc1swXSxcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLmlzRGltZW5zaW9uTGlzdFNvcnRhYmxlLFxuICAgICAgICAgICAga2V5OiBkaW1lbnNpb25JbmZvLm5hbWUsXG4gICAgICAgICAgICBvbkNoYW5nZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBkaW1lbnNpb25MYWJlbCA9IGRpbWVuc2lvbkluZm8ubmFtZSA9PT0gXCJTdGRUaW1lXCJcbiAgICAgICAgICAgID8gc3RyaW5ncy5kaXNwbGF5LnN0ZFRpbWVEaW1lbnNpb25cbiAgICAgICAgICAgIDogZGltZW5zaW9uSW5mby5uYW1lID09PSBcIlN0ZFpcIlxuICAgICAgICAgICAgICAgID8gc3RyaW5ncy5kaXNwbGF5LnN0ZFpEaW1lbnNpb25cbiAgICAgICAgICAgICAgICA6IHN0cmluZ3MuZGlzcGxheS5nZW5lcmFsRGltZW5zaW9uLnJlcGxhY2UoXCIke2RpbWVuc2lvbk5hbWV9XCIsIGRpbWVuc2lvbkluZm8ubmFtZSk7XG4gICAgICAgIGNvbnN0IGlzVGltZSA9IGlzVGltZURpbWVuc2lvbihkaW1lbnNpb25JbmZvLCB0cnVlKTtcbiAgICAgICAgY29uc3QgZGltTmFtZSA9IGlzVGltZSA/IFwidGltZVwiIDogXCJ6XCI7XG4gICAgICAgIGNvbnN0IGNsaXBwZWREaW1lbnNpb25JbmZvID0gZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8oZGltZW5zaW9uSW5mbywgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KTtcbiAgICAgICAgY29uc3QgaXNaZXJvT3JTaW5nbGVTbGljZSA9IGNsaXBwZWREaW1lbnNpb25JbmZvLnZhbHVlcy5sZW5ndGggPCAyO1xuICAgICAgICBjb25zdCB7IHNob3dBbmltYXRpb25Db250cm9scyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uU3dpdGNoID0gc2hvd0FuaW1hdGlvbkNvbnRyb2xzICYmICFpc1plcm9PclNpbmdsZVNsaWNlID8gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgbGF5b3V0OiBcImlubGluZVwiIH0sIGgoXCJjYWxjaXRlLXN3aXRjaFwiLCB7IHNjYWxlOiBcInNcIiwgY2hlY2tlZDogdGhpcy5hbmltYXRlZERpbWVuc2lvbnNbZGltTmFtZV0gPT09IGRpbWVuc2lvbkluZm8ubmFtZSwgbGFiZWw6IHN0cmluZ3MuZGlzcGxheS5zaG93RGltZW5zaW9uU2xpZGVyLCBvbkNhbGNpdGVTd2l0Y2hDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVZhbHVlUGlja2VyKGRpbWVuc2lvbkluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95VmFsdWVQaWNrZXIoaXNUaW1lID8gXCJ0aW1lXCIgOiBcInpcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB9KSwgc3RyaW5ncy5kaXNwbGF5LnNob3dEaW1lbnNpb25TbGlkZXIpKSA6IG51bGw7XG4gICAgICAgIHJldHVybiBzaG93QW5pbWF0aW9uQ29udHJvbHMgPyAoaChcImRpdlwiLCB7IGNsYXNzOiBcImRpbWVuc2lvbi16b25lXCIgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgZGltZW5zaW9uTGFiZWwpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBzdHJpbmdzLmRpc3BsYXkuZGVmYXVsdFBvc2l0aW9uLCBkaW1lbnNpb25TZWxlY3QpLCBhbmltYXRpb25Td2l0Y2gpKSA6IChoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIGRpbWVuc2lvbkxhYmVsLCBkaW1lbnNpb25TZWxlY3QpKSk7XG4gICAgfVxuICAgIHJlbmRlckRpbWVuc2lvbkV4dGVudChkaW1lbnNpb25JbmZvLCBleHRlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzdGFydFZhbHVlcyA9IFtdO1xuICAgICAgICBjb25zdCBlbmRWYWx1ZXMgPSBbXTtcbiAgICAgICAgZGltZW5zaW9uSW5mby52YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsxXSA8PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA+PSBleHRlbnRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IGV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gZXh0ZW50WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpc1NsaWNlTW9kZSA9IGV4dGVudFsxXSA9PT0gZXh0ZW50WzBdIHx8XG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShkaW1lbnNpb25JbmZvLnZhbHVlc1swXSkgJiZcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvLnZhbHVlcy5zb21lKCh2YWwpID0+IHZhbFswXSA9PT0gZXh0ZW50WzBdICYmIHZhbFsxXSA9PT0gZXh0ZW50WzFdKSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IGlzU2xpY2VNb2RlXG4gICAgICAgICAgICA/IGRpbWVuc2lvbkluZm9cbiAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkaW1lbnNpb25JbmZvKSwgeyB2YWx1ZXM6IHN0YXJ0VmFsdWVzIH0pO1xuICAgICAgICBjb25zdCBzdGFydExpc3QgPSB0aGlzLnJlbmRlckRpbWVuc2lvbkxpc3Qoc3RhcnRJbmZvLCB7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlOiBleHRlbnRbMF0sXG4gICAgICAgICAgICBzb3J0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBrZXk6IGRpbWVuc2lvbkluZm8ubmFtZSArIFwiLXN0YXJ0XCIsXG4gICAgICAgICAgICBvbkNoYW5nZTogKHZhbHVlKSA9PiB0aGlzLnVwZGF0ZUV4dGVudERpbWVuc2lvblN1YnNldChkaW1lbnNpb25JbmZvLm5hbWUsIHZhbHVlLCBcInN0YXJ0XCIpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkaW1lbnNpb25JbmZvKSwgeyB2YWx1ZXM6IGVuZFZhbHVlcyB9KTtcbiAgICAgICAgY29uc3QgZW5kTGlzdCA9IHRoaXMucmVuZGVyRGltZW5zaW9uTGlzdChlbmRJbmZvLCB7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlOiBpc1NsaWNlTW9kZSA/IHVuZGVmaW5lZF9kaW1lbnNpb25fdmFsdWUgOiBleHRlbnRbMV0sXG4gICAgICAgICAgICBzb3J0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBrZXk6IGRpbWVuc2lvbkluZm8ubmFtZSArIFwiLWVuZFwiLFxuICAgICAgICAgICAgc2hvd0VuZDogdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAodmFsdWUpID0+IHRoaXMudXBkYXRlRXh0ZW50RGltZW5zaW9uU3Vic2V0KGRpbWVuc2lvbkluZm8ubmFtZSwgdmFsdWUsIFwiZW5kXCIpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbkxhYmVsID0gZGltZW5zaW9uSW5mby5uYW1lID09PSBcIlN0ZFRpbWVcIlxuICAgICAgICAgICAgPyBzdHJpbmdzLmV4dGVudC5zdGRUaW1lRXh0ZW50XG4gICAgICAgICAgICA6IGRpbWVuc2lvbkluZm8ubmFtZSA9PT0gXCJTdGRaXCJcbiAgICAgICAgICAgICAgICA/IHN0cmluZ3MuZXh0ZW50LnN0ZFpFeHRlbnRcbiAgICAgICAgICAgICAgICA6IHN0cmluZ3MuZXh0ZW50LmdlbmVyYWxFeHRlbnQucmVwbGFjZShcIiR7ZGltZW5zaW9uTmFtZX1cIiwgZGltZW5zaW9uSW5mby5uYW1lKTtcbiAgICAgICAgY29uc3QgYWxsVmFsdWVzID0gZGltZW5zaW9uSW5mby52YWx1ZXM7XG4gICAgICAgIGNvbnN0IHNsaWNlQ291bnQgPSBhbGxWYWx1ZXMubGVuZ3RoO1xuICAgICAgICAvLyB1c2luZyBjbG9zdXJlIGhlcmUsIHRoZXJlJ3Mgb25lIHNsaWRlciBwZXIgZGltZW5zaW9uLCBkb2Vzbid0IG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGVtIGF0IHRoZSBjb21wb2VubnQgbGV2ZWxcbiAgICAgICAgbGV0IHNsaWRlclRhcmdldDtcbiAgICAgICAgY29uc3Qgb25TbGlkZXJDaGFuZ2UgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBldnQudGFyZ2V0IGlzIG5vdCB0aGUgc2xpZGVyIGl0c2VsZiBpbiBjYXNlIG9mIG9uQ2FsY2l0ZVNsaWRlckNoYW5nZSAob25DYWxjaXRlU2xpZGVySW5wdXQgaXMgbm90IGZpcmVkIHdoZW4gZHJhZyBtaWRkbGUgb2YgdHdvIHRodW1icylcbiAgICAgICAgICAgIGxldCBzdGFydCwgZW5kO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2xpZGVyVGFyZ2V0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gYWxsVmFsdWVzW3NsaWRlclRhcmdldC52YWx1ZVswXV07XG4gICAgICAgICAgICAgICAgZW5kID0gYWxsVmFsdWVzWyhfYSA9IHNsaWRlclRhcmdldC52YWx1ZVsxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2xpZGVyVGFyZ2V0LnZhbHVlWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kID0gYWxsVmFsdWVzW3NsaWRlclRhcmdldC52YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFydFZhbHVlID0gQXJyYXkuaXNBcnJheShzdGFydCkgPyBzdGFydFswXSA6IHN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgZW5kVmFsdWUgPSBBcnJheS5pc0FycmF5KGVuZCkgPyBlbmRbMV0gOiBlbmQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudERpbWVuc2lvblN1YnNldChkaW1lbnNpb25JbmZvLm5hbWUsIFtzdGFydFZhbHVlLCBlbmRWYWx1ZV0pO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgICBsZXQgbWluSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWF4SW5kZXggPSBzbGljZUNvdW50IC0gMTtcbiAgICAgICAgY29uc3QgZGltRXh0ZW50ID0gKF9hID0gdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmRpbWVuc2lvbnMuZmluZCgoeyBuYW1lIH0pID0+IG5hbWUgPT09IGRpbWVuc2lvbkluZm8ubmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leHRlbnQ7XG4gICAgICAgIGlmIChkaW1FeHRlbnQpIHtcbiAgICAgICAgICAgIG1pbkluZGV4ID0gYWxsVmFsdWVzLmZpbmRJbmRleCgodmFsKSA9PiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsWzBdIDogdmFsKSA9PT0gZGltRXh0ZW50WzBdKTtcbiAgICAgICAgICAgIGlmIChtaW5JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXhJbmRleCA9IGFsbFZhbHVlcy5maW5kSW5kZXgoKHZhbCkgPT4gKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbFsxXSA6IHZhbCkgPT09IGRpbUV4dGVudFsxXSk7XG4gICAgICAgICAgICBpZiAobWF4SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSBzbGljZUNvdW50IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbGlkZXIgPSBleHRlbnRbMF0gPT09IGV4dGVudFsxXSA/IChoKFwiY2FsY2l0ZS1zbGlkZXJcIiwgeyBkaXNhYmxlZDogZmFsc2UsIG1pbjogMCwgbWF4OiBzbGljZUNvdW50IC0gMSwgdmFsdWU6IG1pbkluZGV4LCBzdGVwOiAxLCBzbmFwOiB0cnVlLCBsYWJlbFRpY2tzOiBmYWxzZSwgdGlja3M6IHNsaWNlQ291bnQsIG9uQ2FsY2l0ZVNsaWRlcklucHV0OiBvblNsaWRlckNoYW5nZSwgb25DYWxjaXRlU2xpZGVyQ2hhbmdlOiBvblNsaWRlckNoYW5nZSwgcmVmOiAobm9kZSkgPT4gKHNsaWRlclRhcmdldCA9IG5vZGUpIH0pKSA6IChoKFwiY2FsY2l0ZS1zbGlkZXJcIiwgeyBkaXNhYmxlZDogZmFsc2UsIG1pbjogMCwgbWF4OiBzbGljZUNvdW50IC0gMSwgXCJtaW4tdmFsdWVcIjogbWluSW5kZXgsIFwibWF4LXZhbHVlXCI6IG1heEluZGV4LCBzdGVwOiAxLCBzbmFwOiB0cnVlLCBsYWJlbFRpY2tzOiBmYWxzZSwgdGlja3M6IHNsaWNlQ291bnQsIG9uQ2FsY2l0ZVNsaWRlcklucHV0OiBvblNsaWRlckNoYW5nZSwgb25DYWxjaXRlU2xpZGVyQ2hhbmdlOiBvblNsaWRlckNoYW5nZSwgcmVmOiAobm9kZSkgPT4gKHNsaWRlclRhcmdldCA9IG5vZGUpIH0pKTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IFwiZGltZW5zaW9uLXpvbmVcIiB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBkaW1lbnNpb25MYWJlbCksIHNsaWRlciwgaChcImRpdlwiLCB7IGNsYXNzOiB0aGlzLnVzZUNvbXBhY3RFeHRlbnREcm9wZG93bnNcbiAgICAgICAgICAgICAgICA/IFwibXVsdGlkaW1lbnNpb25hbC1leHRlbnQtY29tcGFjdFwiXG4gICAgICAgICAgICAgICAgOiBcIm11bHRpZGltZW5zaW9uYWwtZXh0ZW50XCIgfSwgaChcImRpdlwiLCBudWxsLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBzdHJpbmdzLmV4dGVudC5zdGFydCwgc3RhcnRMaXN0KSksIGgoXCJkaXZcIiwgbnVsbCwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgc3RyaW5ncy5leHRlbnQuZW5kLCBlbmRMaXN0KSkpKSk7XG4gICAgfVxuICAgIHJlbmRlckNsb3NlKCkge1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgdGV4dDogc3RyaW5ncy5nZW5lcmFsLmNsb3NlLCBpY29uOiBcInhcIiwgc2xvdDogXCJoZWFkZXItYWN0aW9ucy1lbmRcIiwgb25DbGljazogdGhpcy5jYW5jZWwsIHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZkNsb3NlQnV0dG9uTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB9IH0pKTtcbiAgICB9XG4gICAgcmVuZGVyRG9uZUJ1dHRvbigpIHtcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIG9uQ2xpY2s6IHRoaXMuYXBwbHksIGFwcGVhcmFuY2U6IFwic29saWRcIiwgd2lkdGg6IFwiaGFsZlwiLCBsYWJlbDogc3RyaW5ncy5nZW5lcmFsLmRvbmUgfSwgc3RyaW5ncy5nZW5lcmFsLmRvbmUpKTtcbiAgICB9XG4gICAgcmVuZGVyQ2FuY2VsQnV0dG9uKCkge1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgc2xvdDogXCJmb290ZXJcIiwgb25DbGljazogdGhpcy5jYW5jZWwsIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIHdpZHRoOiBcImhhbGZcIiwgbGFiZWw6IHN0cmluZ3MuZ2VuZXJhbC5jYW5jZWwgfSwgc3RyaW5ncy5nZW5lcmFsLmNhbmNlbCkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBpbml0TGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGF5ZXIubG9hZGVkKSB7XG4gICAgICAgICAgICBhd2FpdCBsYXllci5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXdNdWx0aWRpbWVuc2lvbmFsSW5mbyA9IGF3YWl0IGdldE11bHRpZGltZW5zaW9uYWxJbmZvKGxheWVyLCB0cnVlKTtcbiAgICAgICAgaWYgKCF0aGlzLnJhd011bHRpZGltZW5zaW9uYWxJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNEeW5hbWljSW1hZ2VyeSA9IHRoaXMuaXNJbWFnZXJ5TGF5ZXIobGF5ZXIpO1xuICAgICAgICBsZXQgZnVuY3Rpb25OYW1lID0gXCJub25lXCI7XG4gICAgICAgIGlmIChpc0R5bmFtaWNJbWFnZXJ5KSB7XG4gICAgICAgICAgICBjb25zdCBtdWx0aWRpbWVuc2lvbmFsSW5mbyA9IChfYSA9IChhd2FpdCBnZXRNdWx0aWRpbWVuc2lvbmFsSW5mbyhsYXllcikpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJhd011bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgICAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVOZXdWYXJpYWJsZXMgPSAoKF9iID0gbXVsdGlkaW1lbnNpb25hbEluZm8udmFyaWFibGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSA+IDEgJiYgdGhpcy5oYXNOZXdWYXJpYWJsZShtdWx0aWRpbWVuc2lvbmFsSW5mbyk7XG4gICAgICAgICAgICAvLyB0b2RvOiB2YXJpYWJsZSBhL2IvYyB0byBkL2UvZiBpcyBOT1Qgc3VwcG9ydGVkIHNpbmNlIGl0IHJlcXVpcmVzIGV4dHJhY3RpbmcgKG5vdCBzZWxlY3RpbmcpIGEgdmFyaWFibGUsIG5vIHRlc3QgY2FzZSBhcyB3ZWxsLlxuICAgICAgICAgICAgdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbyA9IGhhc011bHRpcGxlTmV3VmFyaWFibGVzXG4gICAgICAgICAgICAgICAgPyB0aGlzLnJhd011bHRpZGltZW5zaW9uYWxJbmZvXG4gICAgICAgICAgICAgICAgOiBtdWx0aWRpbWVuc2lvbmFsSW5mbztcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSA9IChfYyA9IGxheWVyLnJhc3RlckZ1bmN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZnVuY3Rpb25OYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbyA9IHRoaXMucmF3TXVsdGlkaW1lbnNpb25hbEluZm87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2VLZXkgPSBgJHtsYXllci51cmx9LSR7ZnVuY3Rpb25OYW1lfWA7XG4gICAgICAgIHRoaXMuYWxsVmFyaWFibGVzID0gdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mby52YXJpYWJsZXMubWFwKCh7IG5hbWUsIHVuaXQsIGRlc2NyaXB0aW9uLCBkaW1lbnNpb25zLCBzdGF0aXN0aWNzIH0pID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbGFiZWw6IHVuaXQgPyBgJHtuYW1lfSAoJHt1bml0fSlgIDogbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZGltZW5zaW9uTmFtZXM6IGRpbWVuc2lvbnMubWFwKCh7IG5hbWUgfSkgPT4gbmFtZSkuam9pbihcIiwgXCIpLFxuICAgICAgICAgICAgc3RhdGlzdGljc1JhbmdlOiBzdGF0aXN0aWNzID09PSBudWxsIHx8IHN0YXRpc3RpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXRpc3RpY3MubWFwKCh7IG1pbiwgbWF4IH0pID0+IFttaW4sIG1heF0uam9pbihcIiwgXCIpKS5qb2luKFwiOyBcIilcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBrZWVwIG9yaWdpbmFsIHNldHRpbmdcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24obGF5ZXIpO1xuICAgICAgICBjb25zdCBtb3NhaWNSdWxlID0gaXNEeW5hbWljSW1hZ2VyeSA/IChfZCA9IGxheWVyLm1vc2FpY1J1bGUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jbG9uZSgpIDogbnVsbDtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSAoX2UgPSBsYXllci5yZW5kZXJlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHN1YnNldCA9IChfZiA9IGxheWVyLm11bHRpZGltZW5zaW9uYWxTdWJzZXQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jbG9uZSgpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsTGF5ZXJTZXR0aW5nID0ge1xuICAgICAgICAgICAgc3Vic2V0LFxuICAgICAgICAgICAgbW9zYWljUnVsZSxcbiAgICAgICAgICAgIGRlZmluaXRpb24sXG4gICAgICAgICAgICByZW5kZXJlclxuICAgICAgICB9O1xuICAgICAgICAvLyBhY3RpdmUgc3Vic2V0IGFuZCBkZWZpbml0aW9uc1xuICAgICAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gdGhpcy5lc3JpTGFuZy5jbG9uZSh0aGlzLm9yaWdpbmFsTGF5ZXJTZXR0aW5nLmRlZmluaXRpb24pO1xuICAgICAgICBsZXQgYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IG51bGw7XG4gICAgICAgIGlmICgoX2ggPSAoX2cgPSBsYXllci5tdWx0aWRpbWVuc2lvbmFsU3Vic2V0KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuc3Vic2V0RGVmaW5pdGlvbnMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBsYXllci5tdWx0aWRpbWVuc2lvbmFsU3Vic2V0O1xuICAgICAgICAgICAgaWYgKGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQudmFyaWFibGVzLnNvbWUoKHZhcmlhYmxlTmFtZSkgPT4gIXRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8udmFyaWFibGVzLnNvbWUoKHZhcmlhYmxJbmZvKSA9PiB2YXJpYWJsSW5mby5uYW1lID09PSB2YXJpYWJsZU5hbWUpKSkge1xuICAgICAgICAgICAgICAgIGxheWVyLm11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxMYXllclNldHRpbmcuc3Vic2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gdGhpcy5nZXREZWZhdWx0TXVsdGlkaW1lbnNpb25hbFN1YnNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IHRoaXMuZ2V0RGVmYXVsdE11bHRpZGltZW5zaW9uYWxTdWJzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0O1xuICAgICAgICB0aGlzLnNob3dBbmltYXRpb25PblN0YXJ0VXAgJiYgdGhpcy5sYXVuY2hEaW1lbnNpb25hbFNsaWRlcnMoKTtcbiAgICAgICAgaWYgKHRoaXMud2F0Y2hWaWV3VGltZSAmJiB0aGlzLnZpZXcgJiYgIXRoaXMud2F0Y2hIYW5kbGVWaWV3VGltZSkge1xuICAgICAgICAgICAgdGhpcy53YXRjaEhhbmRsZVZpZXdUaW1lID0gdGhpcy52aWV3LndhdGNoKFwidGltZUV4dGVudFwiLCB0aGlzLnVwZGF0ZUV4dGVudEZyb21UaW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53YXRjaFJhc3RlckZ1bmN0aW9uICYmICF0aGlzLndhdGNoSGFuZGxlTGF5ZXIgJiYgaXNEeW5hbWljSW1hZ2VyeSkge1xuICAgICAgICAgICAgdGhpcy53YXRjaEhhbmRsZUxheWVyID0gbGF5ZXIud2F0Y2goXCJyYXN0ZXJGdW5jdGlvblwiLCBkZWJvdW5jZShhc3luYyAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXdWYWx1ZSA9PT0gbnVsbCB8fCBuZXdWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV3VmFsdWUuZnVuY3Rpb25OYW1lKSA9PT0gKG9sZFZhbHVlID09PSBudWxsIHx8IG9sZFZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRWYWx1ZS5mdW5jdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWRJbmZvID0gYXdhaXQgZ2V0TXVsdGlkaW1lbnNpb25hbEluZm8obGF5ZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJvcGVydHlWYWx1ZUNoYW5nZWQobWRJbmZvLCB0aGlzLm11bHRpZGltZW5zaW9uYWxJbmZvKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRMYXllcihsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2VQb3BvdmVyKCkge1xuICAgICAgICBpZiAodGhpcy5wb3BPdmVyKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMucG9wT3Zlcik7XG4gICAgICAgICAgICB0aGlzLnBvcE92ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKGxheWVyKSB7XG4gICAgICAgIGNvbnN0IG11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24obGF5ZXIpO1xuICAgICAgICBpZiAobXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gPT09IG51bGwgfHwgbXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5ld011bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKHRoaXMuYWxsVmFyaWFibGVzWzBdLm5hbWUpO1xuICAgIH1cbiAgICBnZXROZXdNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbihzZWxlY3RlZFZhcmlhYmxlTmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkVmFyaWFibGVJbmZvID0gdGhpcy5nZXRWYXJpYWJsZUluZm8oc2VsZWN0ZWRWYXJpYWJsZU5hbWUpO1xuICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gKF9hID0gc2VsZWN0ZWRWYXJpYWJsZUluZm8uZGltZW5zaW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRGltZW5zaW9uTmFtZXMgPSBkaW1lbnNpb25zLm1hcCgoZGltSW5mbykgPT4gZGltSW5mby5uYW1lKTtcbiAgICAgICAgY29uc3QgYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gPSB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uIHx8IFtdO1xuICAgICAgICBjb25zdCBuZXdEZWYgPSB0aGlzLmVzcmlMYW5nLmNsb25lKGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKTtcbiAgICAgICAgY29uc3QgYWN0aXZlRGltZW5zaW9uTmFtZXMgPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbi5tYXAoKGRlZikgPT4gZGVmLmRpbWVuc2lvbk5hbWUpO1xuICAgICAgICAvLyBoYW5kbGUgc3BlY2lhbCBkaW1lbnNpb24tbGVzcyBjYXNlXG4gICAgICAgIGlmIChzZWxlY3RlZERpbWVuc2lvbk5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbmV3RGVmLmZvckVhY2goKGRlZikgPT4ge1xuICAgICAgICAgICAgICAgIGRlZi52YXJpYWJsZU5hbWUgPSBzZWxlY3RlZFZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgICAgICBkZWYuZGltZW5zaW9uTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZGVmLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGRlZi5pc1NsaWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0RlZjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1NhbWVEaW1lbnNpb25MaXN0ID0gYWN0aXZlRGltZW5zaW9uTmFtZXMubGVuZ3RoID09PSBzZWxlY3RlZERpbWVuc2lvbk5hbWVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgc2VsZWN0ZWREaW1lbnNpb25OYW1lcy5ldmVyeSgobmFtZSkgPT4gYWN0aXZlRGltZW5zaW9uTmFtZXMuaW5jbHVkZXMobmFtZSkpO1xuICAgICAgICBpZiAoaXNTYW1lRGltZW5zaW9uTGlzdCkge1xuICAgICAgICAgICAgbmV3RGVmLmZvckVhY2goKGRlZikgPT4ge1xuICAgICAgICAgICAgICAgIGRlZi52YXJpYWJsZU5hbWUgPSBzZWxlY3RlZFZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25JbmZvID0gZGltZW5zaW9ucy5maW5kKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gZGVmLmRpbWVuc2lvbk5hbWUpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZURpbWVuc2lvbmFsRGVmaW5pdGlvbihkZWYsIGRpbWVuc2lvbkluZm8sIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdEZWY7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RGVmLmxlbmd0aCA9IDA7XG4gICAgICAgIGRpbWVuc2lvbnMuZm9yRWFjaCgoZGltZW5zaW9uSW5mbykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgbGV0IGRlZiA9IChfYSA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgLmZpbmQoKGRlZikgPT4gZGVmLmRpbWVuc2lvbk5hbWUgPT09IGRpbWVuc2lvbkluZm8ubmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9uZSgpO1xuICAgICAgICAgICAgaWYgKGRlZikge1xuICAgICAgICAgICAgICAgIGRlZi52YXJpYWJsZU5hbWUgPSBzZWxlY3RlZFZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0RGVmYXVsdERpbWVuc2lvblNsaWNlVmFsdWUoZGltZW5zaW9uSW5mbyk7XG4gICAgICAgICAgICAgICAgZGVmID0gbmV3IHRoaXMuRGltZW5zaW9uYWxEZWZpbml0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVOYW1lOiBzZWxlY3RlZFZhcmlhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uTmFtZTogZGltZW5zaW9uSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFt2YWx1ZV0sXG4gICAgICAgICAgICAgICAgICAgIGlzU2xpY2U6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZURpbWVuc2lvbmFsRGVmaW5pdGlvbihkZWYsIGRpbWVuc2lvbkluZm8sIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCk7XG4gICAgICAgICAgICBuZXdEZWYucHVzaChkZWYpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld0RlZjtcbiAgICB9XG4gICAgaXNNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbkNoYW5nZWQobmV3RGVmKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuZXdEZWYpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKTtcbiAgICB9XG4gICAgbGF1bmNoRGltZW5zaW9uYWxTbGlkZXJzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZGVzdHJveVZhbHVlUGlja2VyKFwiYm90aFwiKTtcbiAgICAgICAgY29uc3QgeyBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiwgbXVsdGlkaW1lbnNpb25hbEluZm8gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZhcmlhYmxlTmFtZSA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uWzBdLnZhcmlhYmxlTmFtZTtcbiAgICAgICAgY29uc3QgYWN0aXZlVmFyaWFibGVJbmZvID0gKF9hID0gbXVsdGlkaW1lbnNpb25hbEluZm8udmFyaWFibGVzLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBhY3RpdmVWYXJpYWJsZU5hbWUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBtdWx0aWRpbWVuc2lvbmFsSW5mby52YXJpYWJsZXNbMF07XG4gICAgICAgIGNvbnN0IHRpbWVEaW1lbnNpb24gPSBhY3RpdmVWYXJpYWJsZUluZm8uZGltZW5zaW9ucy5maW5kKChkaW1lbnNpb25JbmZvKSA9PiBpc1RpbWVEaW1lbnNpb24oZGltZW5zaW9uSW5mbywgdHJ1ZSkpO1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbHVlUGlja2VyKHRpbWVEaW1lbnNpb24pO1xuICAgICAgICBjb25zdCB6RGltZW5zaW9uID0gYWN0aXZlVmFyaWFibGVJbmZvLmRpbWVuc2lvbnMuZmluZCgoZGltZW5zaW9uSW5mbykgPT4gIWlzVGltZURpbWVuc2lvbihkaW1lbnNpb25JbmZvLCB0cnVlKSk7XG4gICAgICAgIHRoaXMuY3JlYXRlVmFsdWVQaWNrZXIoekRpbWVuc2lvbik7XG4gICAgfVxuICAgIGRlc3Ryb3lWYWx1ZVBpY2tlcih0YXJnZXQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBcInRpbWVcIiB8fCB0YXJnZXQgPT09IFwiYm90aFwiKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnZhbHVlUGlja2Vycy50aW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlLnJlbW92ZSgpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy52YWx1ZVBpY2tlcnMudGltZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlUGlja2Vycy50aW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZWREaW1lbnNpb25zLnRpbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgPT09IFwielwiIHx8IHRhcmdldCA9PT0gXCJib3RoXCIpIHtcbiAgICAgICAgICAgIChfYyA9IHRoaXMudmFsdWVQaWNrZXJzLnopID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5oYW5kbGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAoX2QgPSB0aGlzLnZhbHVlUGlja2Vycy56KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2xpZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVQaWNrZXJzLnogPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlZERpbWVuc2lvbnMueiA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlVmFsdWVUaWNrcyhzdGVwcywgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvdW50IH0sIChfLCBpKSA9PiBpID09PSAwXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogaSA9PT0gY291bnQgLSAxXG4gICAgICAgICAgICAgICAgPyBzdGVwcy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgOiBNYXRoLnJvdW5kKChpICogKHN0ZXBzLmxlbmd0aCAtIDEpKSAvIChjb3VudCAtIDEpKSk7XG4gICAgfVxuICAgIGNyZWF0ZVZhbHVlUGlja2VyKGRpbWVuc2lvbkluZm8pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICghZGltZW5zaW9uSW5mbyB8fCAhdGhpcy5zaG93QW5pbWF0aW9uQ29udHJvbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9jZXNzIGRpbWVuc2lvbkluZm8gY2xpcHBpbmdcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCkge1xuICAgICAgICAgICAgZGltZW5zaW9uSW5mbyA9IGdldENsaXBwZWREaW1lbnNpb25JbmZvKGRpbWVuc2lvbkluZm8sIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBoYXZlIGEgc2luZ2xlIGluc3RhbmNlIG9mIHRpbWUgb3IgeiB2YWx1ZSBwaWNrZXJcbiAgICAgICAgY29uc3QgaXNUaW1lID0gaXNUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8sIHRydWUpO1xuICAgICAgICBjb25zdCBpc1plcm9PclNpbmdsZVNsaWNlID0gZGltZW5zaW9uSW5mby52YWx1ZXMubGVuZ3RoIDwgMjtcbiAgICAgICAgbGV0IHByZXZWYWx1ZVBpY2tlckNvbmZpZyA9IGlzVGltZSA/IHRoaXMudmFsdWVQaWNrZXJzLnRpbWUgOiB0aGlzLnZhbHVlUGlja2Vycy56O1xuICAgICAgICBpZiAoaXNaZXJvT3JTaW5nbGVTbGljZSB8fFxuICAgICAgICAgICAgKHByZXZWYWx1ZVBpY2tlckNvbmZpZyAmJiBwcmV2VmFsdWVQaWNrZXJDb25maWcuZGltZW5zaW9uTmFtZSAhPT0gZGltZW5zaW9uSW5mby5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95VmFsdWVQaWNrZXIoaXNUaW1lID8gXCJ0aW1lXCIgOiBcInpcIik7XG4gICAgICAgICAgICBwcmV2VmFsdWVQaWNrZXJDb25maWcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1plcm9PclNpbmdsZVNsaWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IHBpY2tlciBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IGFjdGl2ZURpbWVuc2lvblZhbHVlID0gKF9hID0gdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbi5maW5kKCh7IGRpbWVuc2lvbk5hbWUgfSkgPT4gZGltZW5zaW9uTmFtZSA9PT0gZGltZW5zaW9uSW5mby5uYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlcztcbiAgICAgICAgY29uc3QgYWN0aXZlSW5kZXggPSBhY3RpdmVEaW1lbnNpb25WYWx1ZVxuICAgICAgICAgICAgPyBkaW1lbnNpb25JbmZvLnZhbHVlcy5maW5kSW5kZXgoKHZhbHVlKSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KGFjdGl2ZURpbWVuc2lvblZhbHVlWzBdKVxuICAgICAgICAgICAgICAgID8gdmFsdWUuam9pbigpID09PSBhY3RpdmVEaW1lbnNpb25WYWx1ZS5qb2luKClcbiAgICAgICAgICAgICAgICA6IHZhbHVlID09PSBhY3RpdmVEaW1lbnNpb25WYWx1ZVswXSlcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgY29uc3QgZGltVmFsdWVzID0gWy4uLmRpbWVuc2lvbkluZm8udmFsdWVzXTtcbiAgICAgICAgbGV0IGxhc3REaW1WYWx1ZSA9IGRpbVZhbHVlc1tkaW1WYWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxhc3REaW1WYWx1ZSkpIHtcbiAgICAgICAgICAgIGxhc3REaW1WYWx1ZSA9IGxhc3REaW1WYWx1ZVtsYXN0RGltVmFsdWUubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQVBJJ3MgZGVmYXVsdCB6IGxheW91dCBpcyByaXNpbmcgdXA6IHN1aXRhYmxlIHdoZW4geiBkaW1lbnNpb24gcHJlc2VudHMgYWJvdmUtZ3JvdW5kIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIGZvciBvY2VhbiBkYXRhLCB3ZSBuZWVkIHRvIHJldmVyc2UgbXVsdGlwbGUgcGxhY2VzIHRvIFwiZGl2ZSBpbnRvIHRoZSBvY2VhblwiXG4gICAgICAgIGNvbnN0IHJldmVyc2VkID0gIWlzVGltZSAmJiBsYXN0RGltVmFsdWUgPD0gMDtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBkaW1WYWx1ZXMubWFwKChfdmFsLCBpKSA9PiBpKTtcbiAgICAgICAgY29uc3Qgc3RlcENvdW50ID0gc3RlcHMubGVuZ3RoO1xuICAgICAgICAvLyBsaW1pdCBtYWpvciB0aWNrcyB0byA0IGFuZCBhdm9pZCBjcm93ZGVkIG1pbm9yIHRpY2tzLlxuICAgICAgICBjb25zdCBtYWpvclRpY2tzQ291bnQgPSBzdGVwQ291bnQgPD0gNCA/IDIgOiBpc1RpbWUgfHwgc3RlcENvdW50IDw9IDEwID8gMyA6IDQ7XG4gICAgICAgIGNvbnN0IG1ham9yVGlja3MgPSB0aGlzLmNyZWF0ZVZhbHVlVGlja3Moc3RlcHMsIG1ham9yVGlja3NDb3VudCk7XG4gICAgICAgIC8vIGFsaWduIG1ham9yIHRpY2sgdG8gbWlkZGxlIHVzaW5nIDE5OiAoMSArIDkgKiAyKSBmb3IgdGltZSwgKDEgKyA2ICogMykgZm9yIHpcbiAgICAgICAgY29uc3QgbWlub3JUaWNrc0NvdW50ID0gTWF0aC5taW4oMTksIHN0ZXBDb3VudCA+IDE5ID8gTWF0aC5mbG9vcihzdGVwQ291bnQgLyAyKSA6IHN0ZXBDb3VudCk7XG4gICAgICAgIGNvbnN0IG1pbm9yVGlja3MgPSB0aGlzLmNyZWF0ZVZhbHVlVGlja3Moc3RlcHMsIG1pbm9yVGlja3NDb3VudCk7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IFsuLi5tYWpvclRpY2tzXTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gKHZhbHVlLCB2YWx1ZVR5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmV2ZXJzZWQgPyBkaW1WYWx1ZXMubGVuZ3RoIC0gMSAtIHZhbHVlIDogdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVUeXBlID09PSBcInRpY2tcIlxuICAgICAgICAgICAgICAgID8gZm9ybWF0RGltZW5zaW9uVmFsdWUoZGltVmFsdWVzW2luZGV4XSwgZGltZW5zaW9uSW5mbywge1xuICAgICAgICAgICAgICAgICAgICBpbnRsOiB0aGlzLmludGwsXG4gICAgICAgICAgICAgICAgICAgIHVzZVJlY3VycmluZ1RpbWVMYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlRnJpZW5kbHlJU09Gb3JtYXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVzZVN0YXJ0T3JFbmRGb3JSYW5nZWRWYWx1ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBmb3JtYXREaW1lbnNpb25WYWx1ZShkaW1WYWx1ZXNbaW5kZXhdLCBkaW1lbnNpb25JbmZvLCB7XG4gICAgICAgICAgICAgICAgICAgIGludGw6IHRoaXMuaW50bCxcbiAgICAgICAgICAgICAgICAgICAgdXNlUmVjdXJyaW5nVGltZUxhYmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1c2VGcmllbmRseUlTT0Zvcm1hdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcInNob3J0LWRhdGUtbG9uZy10aW1lXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY3JlYXRlIGFuZCBhZGQgdG8gdmlldyB1aVxuICAgICAgICBjb25zdCB2YWx1ZVBpY2tlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uU2V0dGluZyB9ID0gdGhpcztcbiAgICAgICAgdmFsdWVQaWNrZXJEaXYuY2xhc3NMaXN0LmFkZChpc1RpbWUgPyBhbmltYXRpb25TZXR0aW5nLnRpbWVDbGFzc05hbWUgOiBhbmltYXRpb25TZXR0aW5nLnpDbGFzc05hbWUpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHZhbHVlUGlja2VyRGl2KTtcbiAgICAgICAgLy8gZ3VhcmQgZm9yIDAgb3IgbmVnYXRpdmUgcGxheXJhdGUuIHRpbGVkIGltYWdlcnkgY2FuIHVzZSBhIHNob3J0ZXIgaW50ZXJ2YWxcbiAgICAgICAgY29uc3QgcGxheVJhdGUgPSBhbmltYXRpb25TZXR0aW5nLnBsYXlSYXRlIDw9IDBcbiAgICAgICAgICAgID8gdGhpcy5pc0ltYWdlcnlMYXllcih0aGlzLmxheWVyKVxuICAgICAgICAgICAgICAgID8gMzAwMFxuICAgICAgICAgICAgICAgIDogMjAwMFxuICAgICAgICAgICAgOiBhbmltYXRpb25TZXR0aW5nLnBsYXlSYXRlO1xuICAgICAgICAvLyB1cGRhdGUgb3IgY3JlYXRlIHZhbHVlIHBpY2tlclxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBcInNsaWRlclwiLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiBkaW1WYWx1ZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHN0ZXBzLFxuICAgICAgICAgICAgbWlub3JUaWNrcyxcbiAgICAgICAgICAgIG1ham9yVGlja3MsXG4gICAgICAgICAgICBsYWJlbHMsXG4gICAgICAgICAgICByZXZlcnNlZCxcbiAgICAgICAgICAgIHZpc2libGVFbGVtZW50czoge1xuICAgICAgICAgICAgICAgIHRodW1iVG9vbHRpcDogdGhpcy5zaG93QW5pbWF0aW9uVG9vbHRpcFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsRm9ybWF0RnVuY3Rpb246IGZvcm1hdHRlclxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmdldFNlbGVjdGVkU2xpZGVyVmFsdWUoYWN0aXZlSW5kZXgsIHJldmVyc2VkLCBkaW1WYWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHByZXZWYWx1ZVBpY2tlckNvbmZpZykge1xuICAgICAgICAgICAgcHJldlZhbHVlUGlja2VyQ29uZmlnLmhhbmRsZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUGlja2VyID0gcHJldlZhbHVlUGlja2VyQ29uZmlnLnNsaWRlcjtcbiAgICAgICAgICAgIHZhbHVlUGlja2VyLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIHZhbHVlUGlja2VyLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgICAgIHByZXZWYWx1ZVBpY2tlckNvbmZpZy5kaW1lbnNpb25WYWx1ZXMgPSBkaW1WYWx1ZXM7XG4gICAgICAgICAgICBwcmV2VmFsdWVQaWNrZXJDb25maWcuaGFuZGxlID0gdmFsdWVQaWNrZXIud2F0Y2goXCJ2YWx1ZXNcIiwgKHYpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHJldmVyc2VkID8gZGltVmFsdWVzLmxlbmd0aCAtIDEgLSB2WzBdIDogdlswXTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURlZmluaXRpb25EaW1lbnNpb25WYWx1ZShkaW1lbnNpb25JbmZvLm5hbWUsIGRpbVZhbHVlc1tpbmRleF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVQaWNrZXIgPSBuZXcgdGhpcy5WYWx1ZVBpY2tlcih7XG4gICAgICAgICAgICBjYXB0aW9uOiBkaW1lbnNpb25JbmZvLm5hbWUsXG4gICAgICAgICAgICBsYXlvdXQ6IGlzVGltZSA/IFwiaG9yaXpvbnRhbFwiIDogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgICAgICAgY29udGFpbmVyOiB2YWx1ZVBpY2tlckRpdixcbiAgICAgICAgICAgIGxhYmVsOiBkaW1lbnNpb25JbmZvLm5hbWUsXG4gICAgICAgICAgICBwbGF5UmF0ZSxcbiAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgIHZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aWV3LnVpLmFkZCh2YWx1ZVBpY2tlciwgeyBwb3NpdGlvbjogXCJtYW51YWxcIiB9KTtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gdmFsdWVQaWNrZXIud2F0Y2goXCJ2YWx1ZXNcIiwgKHYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmV2ZXJzZWQgPyBkaW1WYWx1ZXMubGVuZ3RoIC0gMSAtIHZbMF0gOiB2WzBdO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVEZWZpbml0aW9uRGltZW5zaW9uVmFsdWUoZGltZW5zaW9uSW5mby5uYW1lLCBkaW1WYWx1ZXNbaW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGF2b2lkIG9ic3RydWN0aW9uIGZvciBob3Jpem9udGFsIHZhbHVlIHBpY2tlciB3aXRoIGRlZmF1bHQgdG9wIHBsYWNlbWVudFxuICAgICAgICBjb25zdCB0b29sdGlwUGxhY2VtZW50ID0gaXNUaW1lXG4gICAgICAgICAgICA/IChfYiA9IHRoaXMuYW5pbWF0aW9uU2V0dGluZy50aW1lVG9vbHRpcFBsYWNlbWVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJ0b3BcIlxuICAgICAgICAgICAgOiAoX2MgPSB0aGlzLmFuaW1hdGlvblNldHRpbmcuelRvb2x0aXBQbGFjZW1lbnQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiYXV0b1wiO1xuICAgICAgICBpZiAodG9vbHRpcFBsYWNlbWVudCAhPT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gKHZhbHVlUGlja2VyRGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2FsY2l0ZS10b29sdGlwXCIpWzBdLnBsYWNlbWVudCA9IHRvb2x0aXBQbGFjZW1lbnQpLCAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaWNrZXJDb25maWcgPSB7XG4gICAgICAgICAgICBzbGlkZXI6IHZhbHVlUGlja2VyLFxuICAgICAgICAgICAgZGltZW5zaW9uTmFtZTogZGltZW5zaW9uSW5mby5uYW1lLFxuICAgICAgICAgICAgZGltZW5zaW9uVmFsdWVzOiBkaW1WYWx1ZXMsXG4gICAgICAgICAgICBoYW5kbGVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzVGltZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVBpY2tlcnMudGltZSA9IHBpY2tlckNvbmZpZztcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZWREaW1lbnNpb25zLnRpbWUgPSBkaW1lbnNpb25JbmZvLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlUGlja2Vycy56ID0gcGlja2VyQ29uZmlnO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlZERpbWVuc2lvbnMueiA9IGRpbWVuc2lvbkluZm8ubmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVQb3BvdmVyUHJvcHMoKSB7XG4gICAgICAgIGNvbnN0IHN1YnNldFZhcmlhYmxlcyA9IHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC52YXJpYWJsZXM7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZTogZG8gbm90IHVwZGF0ZSBwb3BvdmVyIHdoZW4gYWxsIHVuc2VsZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXNQaWNrZWRMaXN0U2l6ZSA9PT0gMCAmJlxuICAgICAgICAgICAgc3Vic2V0VmFyaWFibGVzLmxlbmd0aCA9PT0gdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mby52YXJpYWJsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhbGxWYXJpYWJsZXMsIHBvcE92ZXIgfSA9IHRoaXM7XG4gICAgICAgIHBvcE92ZXIuc2VsZWN0ZWRGaWVsZHMgPSBzdWJzZXRWYXJpYWJsZXM7XG4gICAgICAgIHBvcE92ZXIuZmllbGRzID0gYWxsVmFyaWFibGVzLm1hcCgodmFyaWFibGUpID0+ICh7XG4gICAgICAgICAgICBuYW1lOiB2YXJpYWJsZS5uYW1lLFxuICAgICAgICAgICAgYWxpYXM6IHZhcmlhYmxlLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHZhcmlhYmxlLmRlc2NyaXB0aW9uXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gYWxsVmFyaWFibGVzWzBdLmRlc2NyaXB0aW9uID8gNSA6IDEwO1xuICAgICAgICBwb3BPdmVyLnNob3dGaWx0ZXJMZW5ndGggPVxuICAgICAgICAgICAgdGhpcy5zaG93VmFyaWFibGVGaWx0ZXIgPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gdGhyZXNob2xkXG4gICAgICAgICAgICAgICAgOiB0aGlzLnNob3dWYXJpYWJsZUZpbHRlclxuICAgICAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiBhbGxWYXJpYWJsZXMubGVuZ3RoICsgMTtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdE11bHRpZGltZW5zaW9uYWxTdWJzZXQodmFyaWFibGVOYW1lcykge1xuICAgICAgICAvLyBzdWJzZXQgZGVmaW5pdGlvbnNcbiAgICAgICAgY29uc3QgeyB2YXJpYWJsZXMgfSA9IHRoaXMubXVsdGlkaW1lbnNpb25hbEluZm87XG4gICAgICAgIGNvbnN0IHN1YnNldERlZmluaXRpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWU6IHZhcmlhYmxlTmFtZSwgZGltZW5zaW9ucyB9ID0gdmFyaWFibGVzW2ldO1xuICAgICAgICAgICAgaWYgKCh2YXJpYWJsZU5hbWVzID09PSBudWxsIHx8IHZhcmlhYmxlTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhcmlhYmxlTmFtZXMubGVuZ3RoKSAmJiAhdmFyaWFibGVOYW1lcy5pbmNsdWRlcyh2YXJpYWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdWJzZXREZWZpbml0aW9ucy5wdXNoKHsgdmFyaWFibGVOYW1lLCBkaW1lbnNpb25OYW1lOiBcIlwiLCB2YWx1ZXM6IFtdLCBpc1NsaWNlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltZW5zaW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25OYW1lID0gZGltZW5zaW9uc1tqXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbLi4uZGltZW5zaW9uc1tqXS5leHRlbnRdO1xuICAgICAgICAgICAgICAgICAgICBzdWJzZXREZWZpbml0aW9ucy5wdXNoKHsgdmFyaWFibGVOYW1lLCBkaW1lbnNpb25OYW1lLCB2YWx1ZXMsIGlzU2xpY2U6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuTXVsdGlkaW1lbnNpb25hbFN1YnNldCh7XG4gICAgICAgICAgICBhcmVhT2ZJbnRlcmVzdDogbnVsbCxcbiAgICAgICAgICAgIHN1YnNldERlZmluaXRpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRWYXJpYWJsZUluZm8odmFyaWFibGVOYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyB2YXJpYWJsZXMgfSA9IHRoaXMubXVsdGlkaW1lbnNpb25hbEluZm87XG4gICAgICAgIHJldHVybiB0aGlzLmlzRGVmYXVsdFVuc3BlY2lmaWVkVmFyaWFibGUodmFyaWFibGVOYW1lKVxuICAgICAgICAgICAgPyB2YXJpYWJsZXNbMF1cbiAgICAgICAgICAgIDogKF9hID0gdmFyaWFibGVzLmZpbmQoKGluZm8pID0+IGluZm8ubmFtZSA9PT0gdmFyaWFibGVOYW1lKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFyaWFibGVzWzBdO1xuICAgIH1cbiAgICBnZXRTZWxlY3RlZFNsaWRlclZhbHVlKGRpbUluZGV4LCByZXZlcnNlZCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIFtkaW1JbmRleCA9PT0gLTEgPyAwIDogcmV2ZXJzZWQgPyBjb3VudCAtIDEgLSBkaW1JbmRleCA6IGRpbUluZGV4XTtcbiAgICB9XG4gICAgaXNEZWZhdWx0VW5zcGVjaWZpZWRWYXJpYWJsZSh2YXJpYWJsZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFtcIlwiLCBcIipcIiwgdGhpcy5zdHJpbmdzLmRpc3BsYXkuZGVmYXVsdFZhcmlhYmxlXS5pbmNsdWRlcyh2YXJpYWJsZU5hbWUpO1xuICAgIH1cbiAgICBpc1Byb3BlcnR5VmFsdWVDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmV3VmFsdWUgIT09IG51bGwgJiYgbmV3VmFsdWUgIT09IHZvaWQgMCA/IG5ld1ZhbHVlIDogdW5kZWZpbmVkKSAhPT0gSlNPTi5zdHJpbmdpZnkob2xkVmFsdWUgIT09IG51bGwgJiYgb2xkVmFsdWUgIT09IHZvaWQgMCA/IG9sZFZhbHVlIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgaGFzTmV3VmFyaWFibGUobXVsdGlkaW1lbnNpb25hbEluZm8pIHtcbiAgICAgICAgcmV0dXJuIG11bHRpZGltZW5zaW9uYWxJbmZvLnZhcmlhYmxlcy5zb21lKCh2YXJpYWJsZUluZm8pID0+ICF0aGlzLnJhd011bHRpZGltZW5zaW9uYWxJbmZvLnZhcmlhYmxlcy5zb21lKChyYXdWYXJpYWJsZUluZm8pID0+IHJhd1ZhcmlhYmxlSW5mby5uYW1lID09PSB2YXJpYWJsZUluZm8ubmFtZSkpO1xuICAgIH1cbiAgICBpc0ltYWdlcnlMYXllcihsYXllcikge1xuICAgICAgICByZXR1cm4gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCI7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbiAgICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgICAgICBcImxheWVyXCI6IFtcIndhdGNoTGF5ZXJcIl0sXG4gICAgICAgIFwiYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25cIjogW1wid2F0Y2hBY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvblwiXSxcbiAgICAgICAgXCJhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0XCI6IFtcIndhdGNoYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldFwiXVxuICAgIH07IH1cbn07XG5BcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsLnN0eWxlID0gYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbENzcztcblxuZXhwb3J0IHsgQXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbCBhcyBhcmNnaXNfcmFzdGVyX211bHRpZGltZW5zaW9uYWwgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJjZ2lzLXJhc3Rlci1tdWx0aWRpbWVuc2lvbmFsLmVudHJ5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBuIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlYm91bmNlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIGxldCBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICBmdW5jdGlvbiBmbHVzaCguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiZmx1c2hlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZva2UoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImludm9rZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbiAgICBjb25zdCBkZWJvdW5jZWQgPSAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmbHVzaGVkXCI6XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludm9rZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FuY2VsbGVkXCI6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgIGRlYm91bmNlZC5pbnZva2UgPSBpbnZva2U7XG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICBkZWJvdW5jZWQuZ2V0U3RhdHVzID0gZ2V0U3RhdHVzO1xuICAgIHJldHVybiBkZWJvdW5jZWQ7XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBuIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWRcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCB0aHJvdHRsZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXG4gKiBTZXQgYSBtaW5pbXVtIHRpbWUgZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlICh1c2VmdWwgZm9yIHByZXZlbnRpbmcgZmxhc2ggb2YgbG9hZGVycylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWluRGVsYXkocHJvbWlzZSwgbWluRGVsYXkpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbcHJvbWlzZSwgdGltZW91dChtaW5EZWxheSldKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBpbmxpbmUgc2V0VGltZW91dCBhcyBhbiBhd2FpdCBpbiBhc3luYyBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gdGltZW91dChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuY29uc3QgYXJyYXlUb0xvb2t1cE1hcCA9IChkYXRhQXJyLCBnZXRLZXlBbmRJdGVtKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoKGRhdGFBcnIgfHwgW10pLm1hcCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IHsga2V5LCBkYXRhIH0gPSBnZXRLZXlBbmRJdGVtKGl0ZW0pO1xuICAgIHJldHVybiBba2V5LCBkYXRhXTtcbn0pKTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gKiBhbmQgd2hldGhlciB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgZWxlbWVudHNcbiAqIHJlZ2FyZGxlc3Mgb2Ygb3JkZXJcbiAqL1xuY29uc3QgYXJyYXlzQXJlRXF1aXZhbGVudCA9IChhcnIxLCBhcnIyKSA9PiBhcnIxLmxlbmd0aCA9PT0gYXJyMi5sZW5ndGggJiYgYXJyMS5yZWR1Y2UoKG1lbW8sIHN0cikgPT4gbWVtbyAmJiBhcnIyLmluZGV4T2Yoc3RyKSA+IC0xLCB0cnVlKTtcbmZ1bmN0aW9uIHVuaXF1ZUJ5KG15QXJyLCBnZXRJdGVtSWQpIHtcbiAgICBjb25zdCByZXN1bHRBcnIgPSBbXTtcbiAgICBjb25zdCBsb29rdXBNYXAgPSB7fTtcbiAgICBteUFyci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgICAgICBpZiAobG9va3VwTWFwW2lkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb29rdXBNYXBbaWRdID0gaXRlbTtcbiAgICAgICAgICAgIHJlc3VsdEFyci5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdEFycjtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShteUFycikge1xuICAgIGNvbnN0IHByaW1pdGl2ZXMgPSB7IGJvb2xlYW46IHt9LCBudW1iZXI6IHt9LCBzdHJpbmc6IHt9IH07XG4gICAgY29uc3Qgb2JqcyA9IFtdO1xuICAgIHJldHVybiBteUFyci5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgaWYgKHR5cGUgaW4gcHJpbWl0aXZlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZXNbdHlwZV0uaGFzT3duUHJvcGVydHkoaXRlbSkgPyBmYWxzZSA6IChwcmltaXRpdmVzW3R5cGVdW2l0ZW1dID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2Jqcy5pbmRleE9mKGl0ZW0pID49IDAgPyBmYWxzZSA6IG9ianMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgY2h1bmsgPSAoYXJyLCBzaXplKSA9PiBbLi4uQXJyYXkoTWF0aC5jZWlsKGFyci5sZW5ndGggLyBzaXplKSldLm1hcCgoXywgaSkgPT4gYXJyLnNsaWNlKHNpemUgKiBpLCBzaXplICsgc2l6ZSAqIGkpKTtcblxuZXhwb3J0IHsgYXJyYXlUb0xvb2t1cE1hcCBhcyBhLCB1bmlxdWUgYXMgYiwgdGhyb3R0bGUgYXMgYywgZGVib3VuY2UgYXMgZCwgZXNjYXBlUmVnRXhwIGFzIGUsIGFycmF5c0FyZUVxdWl2YWxlbnQgYXMgZiwgY2h1bmsgYXMgZywgaXNEZWZpbmVkIGFzIGksIG1pbkRlbGF5IGFzIG0sIHRpbWVvdXQgYXMgdCwgdW5pcXVlQnkgYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgeyBsIGFzIGxhbmd1YWdlTWFwIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL3N0ZW5jaWwtdHJpY2tzL2ltcGxlbWVudGluZy1pbnRlcm5hdGlvbmFsaXNhdGlvbi1pMThuLXdpdGgtc3RlbmNpbC01ZTY1NTk1NTQxMTdcbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gICAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgMiBsZXR0ZXIgY29kZWQgbGFuZ3VhZ2VcbiAgICAgICAgICAgIC8vIGUuZy4gaXQtQ0ggdnMgaXRcbiAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gICAgfSk7XG59XG5jb25zdCBzdHJpbmdDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICAgIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nQ2FjaGVbaWRdO1xufVxuLyoqXG4gKiBHZXQgc3RyaW5ncyBhbmQgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIDIgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGUgZmlyc3Qgb25lIHJldHVybnMgYSBjb2RlIHRoYXQncyBhbHNvIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlIGZpbGUuXG4gKiBUaGUgc2Vjb25kIG9uZSByZXR1cm5zIGEgY29kZSB3aGVyZSB0aGVyZSBpcyBzdXBwb3J0IGZvciB0aGUgZmlyc3QgMiBsZXR0ZXJzIG9mIHRoZSBjb2RlIGFzIHBhcnQgb2YgYSBsYW5ndWFnZSBmaWxlLFxuICogYnV0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCA0IGxldHRlciBjb2RlIGZyb20gdGhlIHBhZ2UuXG4gKiBFLmcuIEZvciBcIml0LWNoXCIgaXQgd2lsbCByZXR1cm4gXCJpdFwiIGFzIHRoZSBmaXJzdCBsYW5ndWFnZSBjb2RlIGFuZCBcIml0LWNoXCIgYXMgdGhlIHNlY29uZC5cbiAqIFRoZSBzZWNvbmQgb25lIGlzIHJlcXVpcmVkIGZvciBlc3JpLmludGwuc2V0TG9jYWxlKCkgdG8gZ2V0IHRoZSBjb3JyZWN0IGZvcm1hdHRpbmcuXG4gKlxuICogSWYgYSB0YWdOYW1lIGlzIHByb3ZpZGVkIGl0IHdpbGwgb3ZlcndpdGUgdGhlIGVsZW1lbnQncyB0YWdOYW1lXG4gKlxuICogIEByZXR1cm4gWyBzdHJpbmdzLCBmaXJzdCBsYW5ndWFnZSBjb2RlLCBzZWNvbmQgbGFuZ3VhZ2UgY29kZV1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyhlbGVtZW50LCB0YWdOYW1lKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2VJbnRsID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KTtcbiAgICBsZXQgc3RyaW5ncztcbiAgICB0cnkge1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyaW5ncywgY29tcG9uZW50TGFuZ3VhZ2UsIGNvbXBvbmVudExhbmd1YWdlSW50bF07XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSBhcyBhLCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxlLTA1MGI2ZGI5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgaSBhcyBpc0RlZmluZWQgfSBmcm9tICcuL2NvbW1vbkZ1bmN0aW9ucy1iMDgzMGU5ZS5qcyc7XG5cbmNvbnN0IG1pblZlcnNpb25SRlRNdWx0aWRpbWVuc2lvbmFsSW5mbyA9IDEwLjk7XG5mdW5jdGlvbiBmb3JtYXRUaW1lKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBjb25zdCB7IHVzZUZyaWVuZGx5SVNPRm9ybWF0LCBpbnRsLCBmb3JtYXQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHVzZUZyaWVuZGx5SVNPRm9ybWF0ICYmIGludGwpIHtcbiAgICAgICAgcmV0dXJuIGludGwuZm9ybWF0RGF0ZShkYXRlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGwuY29udmVydERhdGVGb3JtYXRUb0ludGxPcHRpb25zKGZvcm1hdCAhPT0gbnVsbCAmJiBmb3JtYXQgIT09IHZvaWQgMCA/IGZvcm1hdCA6IFwic2hvcnQtZGF0ZS1sb25nLXRpbWVcIikpLCB7IHRpbWVab25lOiBcIlVUQ1wiIH0pKTtcbiAgICB9XG4gICAgbGV0IGlzb1RpbWVTdHJpbmcgPSBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKTtcbiAgICBpc29UaW1lU3RyaW5nID0gaXNvVGltZVN0cmluZy5zbGljZSgwLCBpc29UaW1lU3RyaW5nLmluZGV4T2YoXCIuXCIpKSArIFwiWlwiO1xuICAgIHJldHVybiBpc29UaW1lU3RyaW5nO1xufVxuZnVuY3Rpb24gZm9ybWF0TW9udGgodmFsdWVfYmFzZTEsIGludGwsIGZvcm1hdCA9IFwibG9uZ1wiKSB7XG4gICAgLy8gdXNpbmcgYW4gYXJiaXRyYXJ5IGRhdGUgKHRoZSBkYXkgdGhlIGNvZGUgd2FzIHdyaXR0ZW4pIHRvIGF2b2lkIHNpZGUgZWZmZWN0cyBvZiBzZXRNb250aCBuZWFyIHRoZSBlbmQgb2YgdGhlIG1vbnRoXG4gICAgLy8gc2V0TW9udGggd2lsbCBtb3ZlIHRoZSBkYXRlIHRvIHRoZSBuZXh0IG1vbnRoIHdoZW4gbmV3IG1vbnRoIGRvZXNuJ3QgaGF2ZSBjdXJyZW50IGRhdGUgKGUuZy4gOS8zMSwgMi8zMClcbiAgICAvLyBkYXRlID0gbmV3IERhdGUoMjAwMiwgOSwgMzEpOyBkYXRlLnNldE1vbnRoKDgpOyBjb25zb2xlLmxvZyhkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpKVxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgyMDIyLCA5LCAxMCk7XG4gICAgZGF0ZS5zZXRNb250aCh2YWx1ZV9iYXNlMSAtIDEpO1xuICAgIHJldHVybiBpbnRsLmZvcm1hdERhdGUoZGF0ZSwgeyBtb250aDogZm9ybWF0IH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0UXVhcnRlcih2YWx1ZV9iYXNlMSwgaW50bCkge1xuICAgIGNvbnN0IHN0YXJ0TW9udGggPSBmb3JtYXRNb250aCgodmFsdWVfYmFzZTEgLSAxKSAqIDMgKyAxLCBpbnRsLCBcInNob3J0XCIpO1xuICAgIGNvbnN0IGVuZE1vbnRoID0gZm9ybWF0TW9udGgodmFsdWVfYmFzZTEgKiAzLCBpbnRsLCBcInNob3J0XCIpO1xuICAgIHJldHVybiBgJHtzdGFydE1vbnRofSAtICR7ZW5kTW9udGh9YDtcbn1cbmZ1bmN0aW9uIGZvcm1hdERpbWVuc2lvblZhbHVlKHZhbHVlLCBkaW1lbnNpb25JbmZvLCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHsgaW50bCwgdXNlUmVjdXJyaW5nVGltZUxhYmVsIH0gPSBvcHRpb25zO1xuICAgIGlmICh1c2VSZWN1cnJpbmdUaW1lTGFiZWwgJiYgaW50bCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxVbml0ID0gKF9hID0gZGltZW5zaW9uSW5mby5pbnRlcnZhbFVuaXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgLy8gd2Vla2x5IGFuZCBkYWlseSBhcmUgbm90IHN1cHBvcnRlZCB5ZXRcbiAgICAgICAgY29uc3QgY2FuVXNlUmVjdXJyaW5nVGltZUxhYmVsID0gaXNSZWN1cnJpbmdUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8pICYmIChpbnRlcnZhbFVuaXQgPT09IFwibW9udGhzXCIgfHwgaW50ZXJ2YWxVbml0ID09PSBcInF1YXJ0ZXJzXCIpO1xuICAgICAgICBpZiAoY2FuVXNlUmVjdXJyaW5nVGltZUxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWxVbml0ID09PSBcIm1vbnRoc1wiID8gZm9ybWF0TW9udGgodmFsdWUsIGludGwpIDogZm9ybWF0UXVhcnRlcih2YWx1ZSwgaW50bCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdGhpcyBpcyBwcmVmZXJlZCB3aGVuIGxhYmVsaW5nIGEgc2xpZGVyIGFsaWtlIGNvbnRyb2xcbiAgICBjb25zdCBsYXN0RWxlbWVudCA9IChfYiA9IGRpbWVuc2lvbkluZm8udmFsdWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbZGltZW5zaW9uSW5mby52YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKG9wdGlvbnMudXNlU3RhcnRPckVuZEZvclJhbmdlZFZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMiAmJiBBcnJheS5pc0FycmF5KGxhc3RFbGVtZW50KSkge1xuICAgICAgICBjb25zdCBpc0xhc3RFbGVtZW50ID0gdmFsdWUuam9pbihcIi1cIikgPT09IGxhc3RFbGVtZW50LmpvaW4oXCItXCIpO1xuICAgICAgICB2YWx1ZSA9IGlzTGFzdEVsZW1lbnQgPyB2YWx1ZVsxXSA6IHZhbHVlWzBdO1xuICAgIH1cbiAgICBjb25zdCBpc1RpbWUgPSBpc1RpbWVEaW1lbnNpb24oZGltZW5zaW9uSW5mbyk7XG4gICAgaWYgKCFpc1RpbWUpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlLm1hcCgoZWxlbWVudCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBpbnRsID09PSBudWxsIHx8IGludGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGwuZm9ybWF0TnVtYmVyKGVsZW1lbnQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBTdHJpbmcoZWxlbWVudCk7IH0pLmpvaW4oXCIgLSBcIilcbiAgICAgICAgICAgIDogKF9jID0gaW50bCA9PT0gbnVsbCB8fCBpbnRsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRsLmZvcm1hdE51bWJlcih2YWx1ZSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVzZUZyaWVuZGx5SVNPRm9ybWF0ICYmICFvcHRpb25zLmZvcm1hdCkge1xuICAgICAgICBsZXQgcmVzb2x1dGlvbiA9IChfZCA9IGRpbWVuc2lvbkluZm8uaW50ZXJ2YWxVbml0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIGxldCB7IGludGVydmFsLCBleHRlbnQgfSA9IGRpbWVuc2lvbkluZm87XG4gICAgICAgIGlmIChyZXNvbHV0aW9uID09PSBcIm1vbnRoc1wiKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gPSBcInllYXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvbHV0aW9uID09PSBcImRheXNcIikge1xuICAgICAgICAgICAgaWYgKGludGVydmFsID4gMzY0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbiA9IFwieWVhclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJ2YWwgPiAyNykge1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gPSBcIm1vbnRoc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc29sdXRpb24gPT09IFwiaG91cnNcIikge1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IFwiZGF5c1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLmluY2x1ZGVzKHJlc29sdXRpb24pICYmIChleHRlbnQgPT09IG51bGwgfHwgZXh0ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnQubGVuZ3RoKSkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSAoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKSAvIGRpbWVuc2lvbkluZm8udmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGRheSA9IDg2NDAwMDAwO1xuICAgICAgICAgICAgaWYgKGludGVydmFsID49IDM2NSAqIGRheSkge1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gPSBcInllYXJzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnRlcnZhbCA+PSAyOCAqIGRheSkge1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gPSBcIm1vbnRoc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHJlc29sdXRpb24gPT09IFwieWVhcnNcIiA/IFwieWVhclwiIDogcmVzb2x1dGlvbiA9PT0gXCJtb250aHNcIiA/IFwic2hvcnQtbW9udGgteWVhclwiIDogXCJzaG9ydC1kYXRlXCI7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZm9ybWF0IH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZS5tYXAoKGVsZW1lbnQpID0+IGZvcm1hdFRpbWUoZWxlbWVudCwgb3B0aW9ucykpLmpvaW4oXCIgLSBcIilcbiAgICAgICAgOiBmb3JtYXRUaW1lKHZhbHVlLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldENsaXBwZWREaW1lbnNpb25JbmZvKGRpbWVuc2lvbkluZm8sIG11bHRpZGltZW5zaW9uYWxTdWJzZXQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY29uc3RyYWludCA9IChfYSA9IG11bHRpZGltZW5zaW9uYWxTdWJzZXQgPT09IG51bGwgfHwgbXVsdGlkaW1lbnNpb25hbFN1YnNldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXVsdGlkaW1lbnNpb25hbFN1YnNldC5kaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoeyBuYW1lIH0pID0+IG5hbWUgPT09IGRpbWVuc2lvbkluZm8ubmFtZSk7XG4gICAgaWYgKCEoY29uc3RyYWludCA9PT0gbnVsbCB8fCBjb25zdHJhaW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25zdHJhaW50LmV4dGVudCkpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbkluZm87XG4gICAgfVxuICAgIGNvbnN0IGV4dGVudCA9IFsuLi5jb25zdHJhaW50LmV4dGVudF07XG4gICAgY29uc3QgdmFsdWVzID0gZGltZW5zaW9uSW5mby52YWx1ZXMuZmlsdGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBtdXN0IGJlIGNvbnRhaW5lZCwgaW50ZXJzZWN0aW9uIGlzIG5vdCBzdWZmaWNpZW50XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQoZXh0ZW50WzFdKSB8fCBleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVswXSA9PT0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlWzBdID49IGV4dGVudFswXSAmJiB2YWx1ZVswXSA8PSBleHRlbnRbMV0gJiYgdmFsdWVbMV0gPj0gZXh0ZW50WzBdICYmIHZhbHVlWzFdIDw9IGV4dGVudFsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgPj0gZXh0ZW50WzBdICYmIHZhbHVlIDw9IGV4dGVudFsxXTtcbiAgICB9KTtcbiAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlLCB3aGVuIGxhc3Qgc2xpY2Ugb2YgYSByYW5nZWQgZGltZW5zaW9uIHNlcmllcyBpcyB1c2VkXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gZGltZW5zaW9uSW5mby52YWx1ZXNbZGltZW5zaW9uSW5mby52YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxhc3RWYWx1ZSkgJiYgbGFzdFZhbHVlWzFdID09PSBleHRlbnRbMF0pIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGxhc3RWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGltZW5zaW9uSW5mbyksIHsgZXh0ZW50LCB2YWx1ZXMgfSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RGltZW5zaW9uU2xpY2VWYWx1ZShkaW1lbnNpb25JbmZvKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgdmFsdWVzLCBleHRlbnQsIG5hbWUgfSA9IGRpbWVuc2lvbkluZm87XG4gICAgbGV0IHZhbHVlID0gKF9hID0gdmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleHRlbnRbMF07XG4gICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdGR6XCIgJiZcbiAgICAgICAgIWRpbWVuc2lvbkluZm8uaGFzUmFuZ2VzICYmXG4gICAgICAgIE1hdGguYWJzKGV4dGVudFsxXSkgPD0gTWF0aC5hYnMoZXh0ZW50WzBdKSkge1xuICAgICAgICBpZiAodmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBleHRlbnRbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24obGF5ZXIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBsYXllci50eXBlID09PSBcImltYWdlcnktdGlsZVwiXG4gICAgICAgID8gbGF5ZXIubXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25cbiAgICAgICAgOiAoX2IgPSAoKF9hID0gbGF5ZXIubW9zYWljUnVsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGF5ZXIuX2RlZmF1bHRTZXJ2aWNlTW9zYWljUnVsZSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldE11bHRpZGltZW5zaW9uYWxJbmZvKGxheWVyLCB1c2VSYXdTb3VyY2VJbmZvKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5LXRpbGVcIikge1xuICAgICAgICByZXR1cm4gbGF5ZXIucmFzdGVySW5mby5tdWx0aWRpbWVuc2lvbmFsSW5mbztcbiAgICB9XG4gICAgY29uc3QgeyByYXN0ZXJGdW5jdGlvbiwgdmVyc2lvbiB9ID0gbGF5ZXI7XG4gICAgaWYgKHVzZVJhd1NvdXJjZUluZm8gfHxcbiAgICAgICAgdmVyc2lvbiA8PSBtaW5WZXJzaW9uUkZUTXVsdGlkaW1lbnNpb25hbEluZm8gfHxcbiAgICAgICAgIXJhc3RlckZ1bmN0aW9uIHx8XG4gICAgICAgICgoX2EgPSByYXN0ZXJGdW5jdGlvbi5mdW5jdGlvbk5hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyLnNlcnZpY2VSYXN0ZXJJbmZvLm11bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgIH1cbiAgICBjb25zdCByYXN0ZXJJbmZvID0gKF9iID0gKGF3YWl0IGxheWVyLmdlbmVyYXRlUmFzdGVySW5mbyhsYXllci5yYXN0ZXJGdW5jdGlvbikpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsYXllci5zZXJ2aWNlUmFzdGVySW5mbztcbiAgICByZXR1cm4gcmFzdGVySW5mby5tdWx0aWRpbWVuc2lvbmFsSW5mbztcbn1cbmZ1bmN0aW9uIGlzVGltZURpbWVuc2lvbihkaW1lbnNpb25JbmZvLCBpZ25vcmVSZWN1cmluZyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGRpbWVuc2lvbkluZm8ubmFtZSA9PT0gXCJTdGRUaW1lXCIgJiYgKGlnbm9yZVJlY3VyaW5nIHx8ICFkaW1lbnNpb25JbmZvLnJlY3VycmluZyk7XG59XG5mdW5jdGlvbiBpc1JlY3VycmluZ1RpbWVEaW1lbnNpb24oZGltZW5zaW9uSW5mbykge1xuICAgIHJldHVybiBkaW1lbnNpb25JbmZvLm5hbWUgPT09IFwiU3RkVGltZVwiICYmICEhZGltZW5zaW9uSW5mby5yZWN1cnJpbmc7XG59XG5mdW5jdGlvbiB1cGRhdGVEaW1lbnNpb25hbERlZmluaXRpb24oZGVmLCBkaW1lbnNpb25JbmZvLCBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KSB7XG4gICAgZGltZW5zaW9uSW5mbyA9IGdldENsaXBwZWREaW1lbnNpb25JbmZvKGRpbWVuc2lvbkluZm8sIGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQpO1xuICAgIGNvbnN0IG9yaWdpbmFsRm9ybWF0dGVkVmFsdWUgPSBmb3JtYXREaW1lbnNpb25WYWx1ZShkZWYudmFsdWVzWzBdLCBkaW1lbnNpb25JbmZvKTtcbiAgICBjb25zdCBoYXNPcmlnaW5hbEZvcm1hdHRlZFZhbHVlID0gZGltZW5zaW9uSW5mby52YWx1ZXMuc29tZSgodmFsKSA9PiBvcmlnaW5hbEZvcm1hdHRlZFZhbHVlID09PSBmb3JtYXREaW1lbnNpb25WYWx1ZSh2YWwsIGRpbWVuc2lvbkluZm8pKTtcbiAgICBpZiAoIWhhc09yaWdpbmFsRm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgLy8gZ2V0IGRlZmF1bHQgc2xpY2UgdmFsdWUgd2hlbiBkZWYudmFsdWVzIGlzIGludmFsaWRcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXREZWZhdWx0RGltZW5zaW9uU2xpY2VWYWx1ZShkaW1lbnNpb25JbmZvKTtcbiAgICAgICAgZGVmLnZhbHVlcyA9IFt2YWx1ZV07XG4gICAgfVxufVxuXG5leHBvcnQgeyBnZXRNdWx0aWRpbWVuc2lvbmFsSW5mbyBhcyBhLCBnZXREZWZhdWx0RGltZW5zaW9uU2xpY2VWYWx1ZSBhcyBiLCBnZXRNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiBhcyBjLCBmb3JtYXREaW1lbnNpb25WYWx1ZSBhcyBmLCBnZXRDbGlwcGVkRGltZW5zaW9uSW5mbyBhcyBnLCBpc1RpbWVEaW1lbnNpb24gYXMgaSwgbWluVmVyc2lvblJGVE11bHRpZGltZW5zaW9uYWxJbmZvIGFzIG0sIHVwZGF0ZURpbWVuc2lvbmFsRGVmaW5pdGlvbiBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpZGltZW5zaW9uYWwtNjlmMzk2OGYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9