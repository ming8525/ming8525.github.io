"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-xy-slid-b2fb4c"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-xy-slider.entry.js":
/*!*******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-xy-slider.entry.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_xy_slider: () => (/* binding */ ArcgisXySlider)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const arcgisXySliderCss = ":host{display:inline-flex}.container{position:relative;width:100px;height:100px}.grid{width:100px;height:100px}.thumb{position:absolute;background-color:var(--calcite-color-brand);width:12px;height:12px;display:inline-block;border-radius:50%;margin-left:-6px;margin-top:-6px;pointer-events:none}";

const ArcgisXySlider = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisXYSliderChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisXYSliderChange", 7);
        this.arcgisXYSliderInput = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisXYSliderInput", 7);
        this.snapKeyDown = false;
        this.dragging = false;
        this.width = 100;
        this.height = 100;
        this.gridMouseDownHandler = (event) => {
            const { offsetX, offsetY } = event;
            this.dragging = true;
            this.captureValue(offsetX, offsetY);
            // prevent text selection outside of color field & slider area
            event.preventDefault();
            document.addEventListener("pointermove", this.globalMouseMoveHandler);
            document.addEventListener("pointerup", this.globalMouseUpHandler, { once: true });
            this.activeGridRect = this.context.canvas.getBoundingClientRect();
            this.setFocus();
            this.drawGrid();
        };
        this.globalMouseMoveHandler = (event) => {
            const { el, activeGridRect } = this;
            if (!el.isConnected) {
                return;
            }
            let samplingX;
            let samplingY;
            const gridRect = activeGridRect;
            const { clientX, clientY } = event;
            if (this.gridHovered) {
                samplingX = clientX - gridRect.x;
                samplingY = clientY - gridRect.y;
            }
            else {
                const gridWidth = gridRect.width;
                const gridHeight = gridRect.height;
                if (clientX < gridRect.x + gridWidth && clientX > gridRect.x) {
                    samplingX = clientX - gridRect.x;
                }
                else if (clientX < gridRect.x) {
                    samplingX = 0;
                }
                else {
                    samplingX = gridWidth;
                }
                if (clientY < gridRect.y + gridHeight && clientY > gridRect.y) {
                    samplingY = clientY - gridRect.y;
                }
                else if (clientY < gridRect.y) {
                    samplingY = 0;
                }
                else {
                    samplingY = gridHeight;
                }
            }
            this.captureValue(samplingX, samplingY);
            this.drawGrid();
        };
        this.globalMouseUpHandler = () => {
            this.dragging = false;
            // TODO: need to compare w/ onclick x/y values before emitting
            this.arcgisXYSliderChange.emit();
            document.removeEventListener("mousemove", this.globalMouseMoveHandler);
            document.removeEventListener("pointermove", this.globalMouseMoveHandler);
        };
        this.gridMouseEnter = () => {
            this.gridHovered = true;
        };
        this.gridMouseLeave = () => {
            this.gridHovered = false;
        };
        this.handleThumbKeyDown = (event) => {
            let x;
            let y;
            const { key } = event;
            if (["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"].indexOf(key) > -1) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (key === "ArrowDown") {
                y = this.clamp(this.y + this.step, this.maxY, this.minY);
            }
            else if (key === "ArrowUp") {
                y = this.clamp(this.y - this.step, this.maxY, this.minY);
            }
            else {
                y = this.y;
            }
            if (key === "ArrowLeft") {
                x = this.clamp(this.x - this.step, this.maxX, this.minX);
            }
            else if (key === "ArrowRight") {
                x = this.clamp(this.x + this.step, this.maxX, this.minX);
            }
            else {
                x = this.x;
            }
            this.userSetXY(x, y);
            this.drawGrid();
        };
        this.handleKeyUp = ({ shiftKey }) => {
            this.snapKeyDown = shiftKey;
        };
        this.handleKeyDown = ({ shiftKey }) => {
            this.snapKeyDown = shiftKey;
        };
        this.initGrid = (canvas) => {
            this.context = canvas.getContext("2d");
            this.setCanvasContextSize(canvas, {
                width: this.width,
                height: this.height
            });
            this.drawGrid();
        };
        this.maxX = 10;
        this.minX = -10;
        this.maxY = 10;
        this.minY = -10;
        this.snappable = false;
        this.step = 1;
        this.x = 0;
        this.y = 0;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    disconnectedCallback() {
        document.removeEventListener("pointermove", this.globalMouseMoveHandler);
        document.removeEventListener("pointerup", this.globalMouseUpHandler);
    }
    handleXChange(x) {
        this.x = this.clampX(x);
        this.drawGrid();
    }
    handleYChange(y) {
        this.y = this.clampY(y);
        this.drawGrid();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    clamp(value, max, min) {
        return Math.min(max, Math.max(min, value));
    }
    clampX(x) {
        return this.clamp(x, this.maxX, this.minX);
    }
    clampY(y) {
        return this.clamp(y, this.maxY, this.minY);
    }
    userSetXY(x, y) {
        x = this.normalize(x);
        y = this.normalize(y);
        if (this.x === x && this.y === y) {
            return;
        }
        this.x = x;
        this.y = y;
        this.arcgisXYSliderInput.emit();
        if (!this.dragging) {
            this.arcgisXYSliderChange.emit();
        }
    }
    mapToRange(valueA, rangeAMin, rangeAMax, rangeBMin, rangeBMax) {
        return rangeBMin + ((valueA - rangeAMin) * (rangeBMax - rangeBMin)) / (rangeAMax - rangeAMin);
    }
    setCanvasContextSize(canvas, { height, width }) {
        const devicePixelRatio = window.devicePixelRatio || 1;
        canvas.width = width * devicePixelRatio;
        canvas.height = height * devicePixelRatio;
        canvas.style.height = `${height}px`;
        canvas.style.width = `${width}px`;
        const context = canvas.getContext("2d");
        context.scale(devicePixelRatio, devicePixelRatio);
    }
    normalize(value) {
        return this.snappable || this.snapKeyDown ? Math.floor(value / this.step) : value;
    }
    captureValue(x, y) {
        this.userSetXY(this.mapToRange(x, 0, this.width, this.minX, this.maxX), this.mapToRange(y, 0, this.height, this.minY, this.maxY));
    }
    drawGrid() {
        const { context, height, width } = this;
        // border and background
        context.fillStyle = "#ffffff";
        context.strokeStyle = "#d4d4d4";
        context.lineWidth = 2;
        context.setLineDash([2]);
        context.fillRect(0, 0, width, height);
        context.strokeRect(0, 0, width, height);
        // horizontal grid line
        context.beginPath();
        context.moveTo(0, height / 2);
        context.lineTo(width, height / 2);
        context.stroke();
        // vertical grid line
        context.beginPath();
        context.moveTo(width / 2, 0);
        context.lineTo(width / 2, height);
        context.stroke();
        // value-connecting line
        context.setLineDash([]);
        const x = this.mapToRange(this.x, this.minX, this.maxX, 0, this.width);
        const y = this.mapToRange(this.y, this.minY, this.maxY, 0, this.height);
        context.strokeStyle = "rgba(0, 97, 155, 0.4)";
        context.lineWidth = 2;
        context.beginPath();
        context.moveTo(width / 2, height / 2);
        context.lineTo(x, y);
        context.stroke();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Sets focus on the component.
     */
    async setFocus() {
        this.thumbEl.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Render
    //
    //--------------------------------------------------------------------------
    render() {
        const left = `${this.mapToRange(this.x, this.minX, this.maxX, 0, this.width)}%`;
        const top = `${this.mapToRange(this.y, this.minY, this.maxY, 0, this.height)}%`;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { onKeyUp: this.handleKeyUp, onKeyDown: this.handleKeyDown }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "container" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("canvas", { class: "grid", onPointerDown: this.gridMouseDownHandler, onPointerEnter: this.gridMouseEnter, onPointerLeave: this.gridMouseLeave, ref: this.initGrid }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "thumb", ref: (el) => (this.thumbEl = el), style: {
                left,
                top
            }, tabIndex: 0, onKeyDown: this.handleThumbKeyDown }))));
    }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "x": ["handleXChange"],
        "y": ["handleYChange"]
    }; }
};
ArcgisXySlider.style = arcgisXySliderCss;



//# sourceMappingURL=arcgis-xy-slider.entry.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLXh5LXNsaWQtYjJmYjRjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNkc7O0FBRTdHLGlDQUFpQyxvQkFBb0IsV0FBVyxrQkFBa0IsWUFBWSxhQUFhLE1BQU0sWUFBWSxhQUFhLE9BQU8sa0JBQWtCLDRDQUE0QyxXQUFXLFlBQVkscUJBQXFCLGtCQUFrQixpQkFBaUIsZ0JBQWdCLG9CQUFvQjs7QUFFbFU7QUFDQTtBQUNBLFFBQVEscURBQWdCO0FBQ3hCLG9DQUFvQyxxREFBVztBQUMvQyxtQ0FBbUMscURBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixZQUFZO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QyxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZEQUE2RDtBQUNyRix1QkFBdUIsOERBQThEO0FBQ3JGLGdCQUFnQixxREFBQyxDQUFDLGlEQUFJLElBQUksMERBQTBELEVBQUUscURBQUMsVUFBVSxvQkFBb0IsRUFBRSxxREFBQyxhQUFhLHVKQUF1SixHQUFHLHFEQUFDLFVBQVU7QUFDMVM7QUFDQTtBQUNBLGFBQWEsbURBQW1EO0FBQ2hFO0FBQ0EsZUFBZSxPQUFPLHFEQUFVO0FBQ2hDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4Qzs7QUFFOUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMteHktc2xpZGVyLmVudHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuXG5jb25zdCBhcmNnaXNYeVNsaWRlckNzcyA9IFwiOmhvc3R7ZGlzcGxheTppbmxpbmUtZmxleH0uY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMHB4O2hlaWdodDoxMDBweH0uZ3JpZHt3aWR0aDoxMDBweDtoZWlnaHQ6MTAwcHh9LnRodW1ie3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci1icmFuZCk7d2lkdGg6MTJweDtoZWlnaHQ6MTJweDtkaXNwbGF5OmlubGluZS1ibG9jaztib3JkZXItcmFkaXVzOjUwJTttYXJnaW4tbGVmdDotNnB4O21hcmdpbi10b3A6LTZweDtwb2ludGVyLWV2ZW50czpub25lfVwiO1xuXG5jb25zdCBBcmNnaXNYeVNsaWRlciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzWFlTbGlkZXJDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1hZU2xpZGVyQ2hhbmdlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc1hZU2xpZGVySW5wdXQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1hZU2xpZGVySW5wdXRcIiwgNyk7XG4gICAgICAgIHRoaXMuc25hcEtleURvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLndpZHRoID0gMTAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDEwMDtcbiAgICAgICAgdGhpcy5ncmlkTW91c2VEb3duSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlVmFsdWUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IHRleHQgc2VsZWN0aW9uIG91dHNpZGUgb2YgY29sb3IgZmllbGQgJiBzbGlkZXIgYXJlYVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLmdsb2JhbE1vdXNlTW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLmdsb2JhbE1vdXNlVXBIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUdyaWRSZWN0ID0gdGhpcy5jb250ZXh0LmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0dyaWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nbG9iYWxNb3VzZU1vdmVIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVsLCBhY3RpdmVHcmlkUmVjdCB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICghZWwuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2FtcGxpbmdYO1xuICAgICAgICAgICAgbGV0IHNhbXBsaW5nWTtcbiAgICAgICAgICAgIGNvbnN0IGdyaWRSZWN0ID0gYWN0aXZlR3JpZFJlY3Q7XG4gICAgICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZEhvdmVyZWQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGluZ1ggPSBjbGllbnRYIC0gZ3JpZFJlY3QueDtcbiAgICAgICAgICAgICAgICBzYW1wbGluZ1kgPSBjbGllbnRZIC0gZ3JpZFJlY3QueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyaWRXaWR0aCA9IGdyaWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyaWRIZWlnaHQgPSBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudFggPCBncmlkUmVjdC54ICsgZ3JpZFdpZHRoICYmIGNsaWVudFggPiBncmlkUmVjdC54KSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsaW5nWCA9IGNsaWVudFggLSBncmlkUmVjdC54O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbGllbnRYIDwgZ3JpZFJlY3QueCkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGluZ1ggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxpbmdYID0gZ3JpZFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50WSA8IGdyaWRSZWN0LnkgKyBncmlkSGVpZ2h0ICYmIGNsaWVudFkgPiBncmlkUmVjdC55KSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsaW5nWSA9IGNsaWVudFkgLSBncmlkUmVjdC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbGllbnRZIDwgZ3JpZFJlY3QueSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGluZ1kgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxpbmdZID0gZ3JpZEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVWYWx1ZShzYW1wbGluZ1gsIHNhbXBsaW5nWSk7XG4gICAgICAgICAgICB0aGlzLmRyYXdHcmlkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2xvYmFsTW91c2VVcEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIGNvbXBhcmUgdy8gb25jbGljayB4L3kgdmFsdWVzIGJlZm9yZSBlbWl0dGluZ1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNYWVNsaWRlckNoYW5nZS5lbWl0KCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuZ2xvYmFsTW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5nbG9iYWxNb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ncmlkTW91c2VFbnRlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZEhvdmVyZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdyaWRNb3VzZUxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ncmlkSG92ZXJlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRodW1iS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHg7XG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5IH0gPSBldmVudDtcbiAgICAgICAgICAgIGlmIChbXCJBcnJvd0Rvd25cIiwgXCJBcnJvd1VwXCIsIFwiQXJyb3dMZWZ0XCIsIFwiQXJyb3dSaWdodFwiXS5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkFycm93RG93blwiKSB7XG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuY2xhbXAodGhpcy55ICsgdGhpcy5zdGVwLCB0aGlzLm1heFksIHRoaXMubWluWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuY2xhbXAodGhpcy55IC0gdGhpcy5zdGVwLCB0aGlzLm1heFksIHRoaXMubWluWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJBcnJvd0xlZnRcIikge1xuICAgICAgICAgICAgICAgIHggPSB0aGlzLmNsYW1wKHRoaXMueCAtIHRoaXMuc3RlcCwgdGhpcy5tYXhYLCB0aGlzLm1pblgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIkFycm93UmlnaHRcIikge1xuICAgICAgICAgICAgICAgIHggPSB0aGlzLmNsYW1wKHRoaXMueCArIHRoaXMuc3RlcCwgdGhpcy5tYXhYLCB0aGlzLm1pblgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IHRoaXMueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXNlclNldFhZKHgsIHkpO1xuICAgICAgICAgICAgdGhpcy5kcmF3R3JpZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUtleVVwID0gKHsgc2hpZnRLZXkgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zbmFwS2V5RG93biA9IHNoaWZ0S2V5O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUtleURvd24gPSAoeyBzaGlmdEtleSB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNuYXBLZXlEb3duID0gc2hpZnRLZXk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdEdyaWQgPSAoY2FudmFzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRDYW52YXNDb250ZXh0U2l6ZShjYW52YXMsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0dyaWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYXhYID0gMTA7XG4gICAgICAgIHRoaXMubWluWCA9IC0xMDtcbiAgICAgICAgdGhpcy5tYXhZID0gMTA7XG4gICAgICAgIHRoaXMubWluWSA9IC0xMDtcbiAgICAgICAgdGhpcy5zbmFwcGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGVwID0gMTtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5nbG9iYWxNb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLmdsb2JhbE1vdXNlVXBIYW5kbGVyKTtcbiAgICB9XG4gICAgaGFuZGxlWENoYW5nZSh4KSB7XG4gICAgICAgIHRoaXMueCA9IHRoaXMuY2xhbXBYKHgpO1xuICAgICAgICB0aGlzLmRyYXdHcmlkKCk7XG4gICAgfVxuICAgIGhhbmRsZVlDaGFuZ2UoeSkge1xuICAgICAgICB0aGlzLnkgPSB0aGlzLmNsYW1wWSh5KTtcbiAgICAgICAgdGhpcy5kcmF3R3JpZCgpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2xhbXAodmFsdWUsIG1heCwgbWluKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdmFsdWUpKTtcbiAgICB9XG4gICAgY2xhbXBYKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoeCwgdGhpcy5tYXhYLCB0aGlzLm1pblgpO1xuICAgIH1cbiAgICBjbGFtcFkoeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFtcCh5LCB0aGlzLm1heFksIHRoaXMubWluWSk7XG4gICAgfVxuICAgIHVzZXJTZXRYWSh4LCB5KSB7XG4gICAgICAgIHggPSB0aGlzLm5vcm1hbGl6ZSh4KTtcbiAgICAgICAgeSA9IHRoaXMubm9ybWFsaXplKHkpO1xuICAgICAgICBpZiAodGhpcy54ID09PSB4ICYmIHRoaXMueSA9PT0geSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMuYXJjZ2lzWFlTbGlkZXJJbnB1dC5lbWl0KCk7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNYWVNsaWRlckNoYW5nZS5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFwVG9SYW5nZSh2YWx1ZUEsIHJhbmdlQU1pbiwgcmFuZ2VBTWF4LCByYW5nZUJNaW4sIHJhbmdlQk1heCkge1xuICAgICAgICByZXR1cm4gcmFuZ2VCTWluICsgKCh2YWx1ZUEgLSByYW5nZUFNaW4pICogKHJhbmdlQk1heCAtIHJhbmdlQk1pbikpIC8gKHJhbmdlQU1heCAtIHJhbmdlQU1pbik7XG4gICAgfVxuICAgIHNldENhbnZhc0NvbnRleHRTaXplKGNhbnZhcywgeyBoZWlnaHQsIHdpZHRoIH0pIHtcbiAgICAgICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBjb250ZXh0LnNjYWxlKGRldmljZVBpeGVsUmF0aW8sIGRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICBub3JtYWxpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc25hcHBhYmxlIHx8IHRoaXMuc25hcEtleURvd24gPyBNYXRoLmZsb29yKHZhbHVlIC8gdGhpcy5zdGVwKSA6IHZhbHVlO1xuICAgIH1cbiAgICBjYXB0dXJlVmFsdWUoeCwgeSkge1xuICAgICAgICB0aGlzLnVzZXJTZXRYWSh0aGlzLm1hcFRvUmFuZ2UoeCwgMCwgdGhpcy53aWR0aCwgdGhpcy5taW5YLCB0aGlzLm1heFgpLCB0aGlzLm1hcFRvUmFuZ2UoeSwgMCwgdGhpcy5oZWlnaHQsIHRoaXMubWluWSwgdGhpcy5tYXhZKSk7XG4gICAgfVxuICAgIGRyYXdHcmlkKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRleHQsIGhlaWdodCwgd2lkdGggfSA9IHRoaXM7XG4gICAgICAgIC8vIGJvcmRlciBhbmQgYmFja2dyb3VuZFxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI2ZmZmZmZlwiO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCIjZDRkNGQ0XCI7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMjtcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbMl0pO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIC8vIGhvcml6b250YWwgZ3JpZCBsaW5lXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKDAsIGhlaWdodCAvIDIpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIC8vIHZlcnRpY2FsIGdyaWQgbGluZVxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh3aWR0aCAvIDIsIDApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAvIDIsIGhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIC8vIHZhbHVlLWNvbm5lY3RpbmcgbGluZVxuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMubWFwVG9SYW5nZSh0aGlzLngsIHRoaXMubWluWCwgdGhpcy5tYXhYLCAwLCB0aGlzLndpZHRoKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMubWFwVG9SYW5nZSh0aGlzLnksIHRoaXMubWluWSwgdGhpcy5tYXhZLCAwLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwgOTcsIDE1NSwgMC40KVwiO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHVibGljIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKipcbiAgICAgKiBTZXRzIGZvY3VzIG9uIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgICAgIHRoaXMudGh1bWJFbC5mb2N1cygpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gYCR7dGhpcy5tYXBUb1JhbmdlKHRoaXMueCwgdGhpcy5taW5YLCB0aGlzLm1heFgsIDAsIHRoaXMud2lkdGgpfSVgO1xuICAgICAgICBjb25zdCB0b3AgPSBgJHt0aGlzLm1hcFRvUmFuZ2UodGhpcy55LCB0aGlzLm1pblksIHRoaXMubWF4WSwgMCwgdGhpcy5oZWlnaHQpfSVgO1xuICAgICAgICByZXR1cm4gKGgoSG9zdCwgeyBvbktleVVwOiB0aGlzLmhhbmRsZUtleVVwLCBvbktleURvd246IHRoaXMuaGFuZGxlS2V5RG93biB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiY29udGFpbmVyXCIgfSwgaChcImNhbnZhc1wiLCB7IGNsYXNzOiBcImdyaWRcIiwgb25Qb2ludGVyRG93bjogdGhpcy5ncmlkTW91c2VEb3duSGFuZGxlciwgb25Qb2ludGVyRW50ZXI6IHRoaXMuZ3JpZE1vdXNlRW50ZXIsIG9uUG9pbnRlckxlYXZlOiB0aGlzLmdyaWRNb3VzZUxlYXZlLCByZWY6IHRoaXMuaW5pdEdyaWQgfSksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJ0aHVtYlwiLCByZWY6IChlbCkgPT4gKHRoaXMudGh1bWJFbCA9IGVsKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgIHRvcFxuICAgICAgICAgICAgfSwgdGFiSW5kZXg6IDAsIG9uS2V5RG93bjogdGhpcy5oYW5kbGVUaHVtYktleURvd24gfSkpKSk7XG4gICAgfVxuICAgIGdldCBlbCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbiAgICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgICAgICBcInhcIjogW1wiaGFuZGxlWENoYW5nZVwiXSxcbiAgICAgICAgXCJ5XCI6IFtcImhhbmRsZVlDaGFuZ2VcIl1cbiAgICB9OyB9XG59O1xuQXJjZ2lzWHlTbGlkZXIuc3R5bGUgPSBhcmNnaXNYeVNsaWRlckNzcztcblxuZXhwb3J0IHsgQXJjZ2lzWHlTbGlkZXIgYXMgYXJjZ2lzX3h5X3NsaWRlciB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMteHktc2xpZGVyLmVudHJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==