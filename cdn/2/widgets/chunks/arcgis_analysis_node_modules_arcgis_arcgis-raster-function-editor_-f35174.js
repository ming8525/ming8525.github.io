"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-f35174"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.nb-5ec43a4b.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.nb-5ec43a4b.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "OK";
const cancel = "Avbryt";
const enterURL = "Angi URL for bildetjeneste";
const serviceURL = "Tjeneste-URL";
const selectRaster = "Velg raster";
const failedToLoadLayer = "Kan ikke laste inn lag";
const loadingLayer = "Laster inn lag";
const selectFeature = "Velg geoobjektlag";
const enterFURL = "Angi URL for geoobjekttjeneste.";
const addRaster = "Legg til rastervariabel";
const addScalar = "Legg til konstant";
const raster = "Raster";
const scalar = "Skalar";
const defaultModelName = "Rasterfunksjonsmal";
const general = "Generelt";
const parameters = "Parametere";
const variables = "Variabler";
const name = "Navn";
const description = "Beskrivelse";
const parameter = "Parameter";
const isPublic = "IsPublic";
const isDataset = "IsDataset";
const unknownPixelType = "Ukjent";
const outputPixelType = "Utdatapikseltype";
const u8PixelType = "8 bit usignert";
const s8PixelType = "8 bit signert";
const u16PixelType = "16 bit usignert";
const s16PixelType = "16 bit signert";
const u32PixelType = "32 bit usignert";
const s32PixelType = "32 bit signert";
const f32PixelType = "32 bit flytende";
const f64PixelType = "64 bit dobbelt";
const properties = "Egenskaper";
const multidimensionalRules = "Multidimensional Rules";
const matchVariables = "Match Variables";
const unionDimensions = "Union-dimensjoner";
const rasterFunctionEditor = {
	invalidRFTMessage: "Rasterfunksjonsmalen er ikke gyldig.",
	rfxArgsEditor: {
		outputRaster: "UtdataRaster",
		raster: "Raster",
		unsupportedDataTypeWarning: "Følgende argumenter vises ikke, ettersom de ikke støttes for øyeblikket.",
		unsupportedFunction: "Inneholder rasterfunksjon(er) som for tiden ikke støttes."
	},
	rfxRasterInput: {
		selectLayer: "Velg lag",
		browseLayers: "Bla gjennom lag",
		rfxVariable: "RasterFunctionVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Metode",
		bandLabel: "Bånd",
		combinationLabel: "Kombinasjon"
	},
	rfxRemapGrid: {
		minimum: "Minimum",
		maximum: "Maksimum",
		output: "Resultat",
		noData: "Nodata",
		remapValuesLabel: "Tilordne verdier på nytt"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Rastervariabler",
		deleteSelectedVars: "Fjern valgte variabler"
	},
	rfxClippingGeometry: {
		clippingLayer: "Klippelag",
		clippingRaster: "Klipperaster",
		clippingGeometry: "Geometri for utklipp",
		customExtent: "Egendefinert utstrekning",
		outputExtent: "Utdataomfang",
		currentExtent: "Gjeldende kartutstrekning",
		drawLabel: "Tegn"
	},
	rfxCustomExtent: {
		top: "Topp",
		right: "Høyre",
		bottom: "Bunn",
		left: "Venstre"
	},
	rfxRasterArrayEditor: {
		moveUp: "Flytt opp",
		moveDown: "Flytt ned",
		remove: "Fjern"
	},
	rfxStatisticsGrid: {
		stdDev: "Std. Dev",
		min: "Min",
		max: "Maks",
		mean: "Gjennomsnitt"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Vektet sum-tabell",
		id: "ID",
		layer: "Lag",
		field: "Felt",
		weight: "Vekt",
		value: "Verdi",
		selectLayer: "Velg lag"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Vektet overleggstabell",
		id: "ID",
		layer: "Lag",
		field: "Felt",
		influence: "Påvirkning",
		sumOfInfluence: "Sum av påvirkning",
		value: "Verdi",
		remapTable: "Tilordne tabell på nytt",
		scale: "Målestokk",
		scales: "Målestokker",
		selectRaster: "Velg raster"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Bla gjennom etter geoobjektlag",
		addPointLayer: "Bla gjennom etter punktlag"
	},
	rfxFieldSelect: {
		value: "Verdi",
		count: "Antall"
	},
	rfxAttributeTable: {
		tableType: "Tabelltype",
		manual: "Manuell",
		external: "Ekstern",
		minVal: "Minimumsverdi",
		maxVal: "Maksimumsverdi",
		baseClassName: "Klassebasenavn",
		colorScheme: "Fargevalg",
		defaultClassName: "Etikett_",
		generateTable: "Generer tabell",
		browseTable: "Se gjennom tabell",
		value: "Verdi",
		classname: "Klassenavn",
		color: "Farge"
	},
	rfxFieldNumberSwitchable: {
		number: "Numerisk",
		field: "Felt",
		string: "Streng",
		linearUnit: "Lineær enhet"
	},
	rfxPropertySet: {
		name: "Navn",
		value: "Verdi"
	},
	rfxConversionGrid: {
		size: "Størrelse"
	},
	rfxTransposeBit: {
		bitPattern: "Bitmønster",
		outputBit: "Utdatabit",
		inputBit: "Inndatabit"
	},
	rfxSpatialReference: {
		placeHolder: "Avgrens etter søkeord",
		coordinateSystem: "Koordinatsystem",
		gcs: "Geografisk koordinatsystem",
		pcs: "Projisert koordinatsystem",
		vcs: "Vertikalt koordinatsystem"
	}
};
const rfxLicenseInfo = "Denne rasterfunksjonsmalen kan brukes til å behandle bildene dine ved hjelp av ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "ACosH",
		aCosHSnip: "Beregner invers cosinus for cellene i et raster.",
		aCosHDesc: "Funksjonen beregner invers cosinus for pikslene i et raster.",
		aCosName: "ACos",
		aCosSnip: "Beregner invers cosinus for pikslene i et raster.",
		aCosDesc: "Denne rasterfunksjonen beregner invers cosinus for cellene i et raster. I matematikken har alle trigonometriske funksjoner et definert område med gyldige inndataverdier som kalles definisjonsområde. Utdataverdiene for hver funksjon har også et definisjonsområde. For dette verktøyet er definisjonsområdet [-1, 1] og omfanget [0, pi].",
		aSinHName: "ASinH",
		aSinHSnip: "Beregner invers hyperbolsk sinus for cellene i et raster.",
		aSinHDesc: "Funksjonen beregner invers hyperbolsk sinus for pikslene i et raster.",
		aSinName: "ASin",
		aSinSnip: "Beregner invers sinus for cellene i et raster.",
		aSinDesc: "Funksjonen beregner invers sinus for pikslene i et raster.",
		aTan2Name: "ATan2",
		aTan2Snip: "Beregner invers tangent (basert på x, y) for cellene i et raster.",
		aTan2Desc: "Funksjonen beregner invers tangent (basert på x, y) for pikslene i et raster.",
		aTanHName: "ATanH",
		aTanHSnip: "Beregner invers hyperbolsk tangent for cellene i et raster.",
		aTanHDesc: "Funksjonen beregner invers hyperbolsk tangent for pikslene i et raster.",
		aTanName: "ATan",
		aTanSnip: "Beregner invers tangent for cellene i et raster.",
		aTanDesc: "Funksjonen beregner invers tangent for pikslene i et raster.",
		absName: "Abs",
		absSnip: "Beregner absolutt verdi for cellene i et raster.",
		absDesc: "Abs-funksjonen beregner den absolutte verdien for pikslene i et raster.",
		reflectanceName: "Synlig reflektans",
		reflectanceSnip: "Konverterer råbilder til Top of Atmosphere-verdier ved å ta hensyn til sensoregenskaper, solens posisjon og innhentingstidspunktet.",
		reflectanceDesc: "Denne funksjonen justerer lysstyrkens digitale antall (DN) for enkelte satellittsensorer. Justeringene er basert på solhøyde, innhentingsdato og sensoregenskaper for å angi økning og avvik for hvert bånd. Denne funksjonen brukes til å justere refleksjon eller lysstyrke, verdier på enkelte satellittbilder basert på scenelys og sensorøkningsinnstillinger. Bildene justeres til en teoretisk felles lysbetingelse, så det bør være mindre variasjon mellom scenene fra forskjellige datoer og forskjellige sensorer. Dette kan være nyttig for bildeklassifisering, fargebalanse og mosaikkering. Denne funksjonen kan bare brukes med bestemte bilder. De aktuelle sensorene er Landsat MSS, Landsat TM, Landsat ETM +, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 og Pleiades.<div><br/>Funksjonen utfører to korreksjoner. Den første er basert på økningsinnstillingene. De opprinnelige lysstyrkeverdiene gjenopprettes fra bildeverdiene ved å reversere økningsligningene. Den andre korreksjonen har å gjøre med forskjeller i solvinkel og lysstyrke. De opprinnelige lysstyrkeverdiene justeres til et felles lysforhold ved å normalisere scener tatt under variable belysningsforhold. Generelt, mens bildets utdatatype er den samme som inndatatypen, er utdataverdiene lavere enn inndataverdiene, og klippes til det gyldige dataområdet.</div>",
		argStatisticsName: "ArgStatistics",
		argStatisticsSnip: "Beregner arg-statistikker, inkludert Arg Max, Arg Min, Argmedian og Duration.",
		argStatisticsDesc: "Funksjonen beregner arg-statistikk. Det er fire metoder i ArgStatistics-funksjonen: ArgMax, ArgMin, ArgMedian og Duration.",
		arithmeticName: "Aritmetisk",
		arithmeticSnip: "Utfører en aritmetisk operasjon mellom to raster eller et raster og en skalar.",
		arithmeticDesc: "Aritmetisk-funksjonen utfører en aritmetisk operasjon mellom to raster eller ett raster og en skalar og omvendt.",
		aspectSlopeName: "Aspect-Slope",
		aspectSlopeSnip: "Oppretter et raster som samtidig viser aspektet (retning) og helling (bratthet) av en kontinuerlig overflate, som representert i en digital høydemodell.",
		aspectSlopeDesc: "Aspect Slope-funksjonen oppretter et rasterlag som samtidig viser aspekt og helling på en overflate. Aspekt identifiserer helningsretning av maksimal endringsverdi fra hver piksel i forhold til naboene. Aspekt kan betraktes som helningsretning. Verdiene av resultatrasteret blir aspektets kompassretning, som representeres av en fargetone (farge). Hellingen representerer endringstakten for høyden for hver piksel i den digitale høydemodellen (DEM). Helling representerer brattheten på overflaten og er symbolisert i tre klasser, som vises ved hjelp av fargemetning (lysstyrke).<div><br/>Pikselverdiene i resultatraster av aspect-slope reflekterer en kombinasjon av aspekt og helling. Piksler med verdier under 20 betraktes som flate og vises i grått. Aspect-slope-verdier på 21 og over vil bli vist med forskjellig fargemetning som følger: 21 til 30—liten helling, 31 til 40—moderat helling, 41 og høyere—stor helling</div>",
		aspectName: "Helningsretning",
		aspectSnip: "Viser hvilken retning en piksel vender mot, hvor 0 er nordover og vinklene øker med klokken til 360.",
		aspectDesc: "Aspect-funksjonen identifiserer helningsretning av maksimal endringsverdi fra hver piksel i forhold til naboene. Aspekt kan betraktes som helningsretning. Verdiene av resultatrasteret blir aspektets kompassretning.<div><br/>Inndataene for denne funksjonen er inndataraster. Aspect-funksjonen blir ofte brukt på en digital høydemodell (DEM). Som standard vises aspektet som et gråtonebilde. Du kan legge til Colormap-funksjonen for å angi et bestemt fargevalg eller la personen som ser på mosaikken, endre symbolene med sitt egen fargevalg.</div>",
		tableName: "Attributtabell",
		tableSnip: "Bruker en tabell for å navngi og symbolisere verdiene i et datasett. Kolonnene for tabellen er kommaseparert: PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "Attributtabell-funksjonen lar deg definere en attributtabell for å symbolisere et enkeltbånd mosaikkdatasett eller rasterdatasett. <div><br/>Dette er nyttig når du vil presentere bilder som er blitt klassifisert til arealbruk, for eksempel skogmark, våtmarker, dyrket jord og urbane områder. Hvis tabellen i tillegg inneholder felt som er kalt \"red\", \"green\" og \"blue\", vil verdiene i disse feltene bli brukt som et fargekart når bildet blir tegnet opp.</div>",
		bandArithmeticName: "Båndaritmetikk",
		bandArithmeticSnip: "Beregner indekser ved hjelp av forhåndsdefinerte formler eller et brukerdefinert uttrykk.",
		bandArithmeticDesc: "Band Arithmetic-funskjonen utfører en aritmetisk operasjon på båndene i et rasterdatasett. Du kan velge forhåndsdefinerte algoritmer eller du kan skrive inn din egen enkeltlinjeformel. Operatorene som støttes er -, +, /, * og unary -.",
		thresholdName: "Binær terskelverdi",
		thresholdSnip: "Organiserer kontinuerlige data i forgrunn og bakgrunn ved å minimere kovariansen mellom de to klassene.",
		thresholdDesc: "Når et rasterdatasett har en bimodal distribusjon, oppretter denne funksjonen et nytt raster som deler dataene i to forskjellige klasser. Den skaper en klasse med lav verdi som vises med svarte piksler, og en klasse med høy verdi som vises med hvite piksler.",
		bitwiseAndName: "Bitwise And",
		bitwiseAndSnip: "Utfører en bitvis And-operasjon på de binære verdiene for to inndatarastere.",
		bitwiseAndDesc: "Bitvis And utfører en bitvis and-operasjon på de binære verdiene for to inndatarastere",
		bitwiseLeftShiftName: "Bitwise Left Shift",
		bitwiseLeftShiftSnip: "Utfører en Bitwise Left Shift-operasjon på de binære verdiene for to inndatarastere.",
		bitwiseLeftShiftDesc: "Bitwise Left Shift utfører en Bitwise Left Shift-operasjon på de binære verdiene for to inndatarastere",
		bitwiseNotName: "Bitwise Not",
		bitwiseNotSnip: "Utfører en Bitwise Not (complement)-operasjon på de binære verdiene for to inndatarastere.",
		bitwiseNotDesc: "Funksjonen utfører en Bitwise Not (complement)-operasjon på de binære verdiene for et inndataraster.",
		bitwiseOrName: "Bitwise Or",
		bitwiseOrSnip: "Utfører en Bitwise Or-operasjon på de binære verdiene for to inndatarastere.",
		bitwiseOrDesc: "Funksjonen utfører en Bitwise Or-operasjon på de binære verdiene for to inndatarastere. ",
		bitwiseRightShiftName: "Bitwise Right Shift",
		bitwiseRightShiftSnip: "Utfører en Bitwise Right Shift-operasjon på de binære verdiene for to inndatarastere.",
		bitwiseRightShiftDesc: "Funksjonen utfører en Bitwise Right Shift-operasjon på de binære verdiene for to inndatarastere.",
		bitwiseXorName: "Bitwise Xor",
		bitwiseXorSnip: "Utfører en Bitwise eXclusive Or-operasjon på de binære verdiene for to inndatarastere.",
		bitwiseXorDesc: "Funksjonen utfører en Bitwise eXclusive Or-operasjon på de binære verdiene for to inndatarastere",
		booleanAndName: "Boolsk And",
		booleanAndSnip: "Utfører en Boolsk And-operasjon på celleverdiene for to inndatarastere. Hvis begge inndataverdiene er sanne (ikke null), er utdataverdien 1. Hvis ett eller begge inndatasett er usann (null), er utdataverdien 0.",
		booleanAndDesc: "Funksjonen utfører en Boolsk And-operasjon på pikselverdiene for to inndatarastere. Hvis begge inndataverdiene er sanne (ikke null), er utdataverdien 1. Hvis en eller begge inndataverdiene er usann (null), er utdataverdien 0. ",
		booleanNotName: "Boolsk Not",
		booleanNotSnip: "Utfører en Boolsk Not (complement)-operasjon på celleverdiene for inndatarasteret. Hvis inndataverdiene er sanne (ikke null), er utdataverdien 0. Hvis inndataverdiene er usanne (null), er utdataverdien 1.",
		booleanNotDesc: "Funksjonen utfører en Boolsk Not (complement)-operasjon på pikselverdiene for inndatarasteret. Hvis inndataverdiene er sanne (ikke null), er utdataverdien 0. Hvis inndataverdiene er usanne (null), er utdataverdien 1.",
		booleanOrName: "Boolsk Or",
		booleanOrSnip: "Utfører en Boolsk Or-operasjon på celleverdiene for de to inndatarasterne. Hvis en begge inndataverdiene er sanne (ikke null), er utdataverdien 1. Hvis en eller begge inndataverdiene er usanne (null), er utdataverdien 0.",
		booleanOrDesc: "Funksjonen utfører en Boolsk Or-operasjon på celleverdiene for to inndatarastere. Hvis en begge inndataverdiene er sanne (ikke null), er utdataverdien 1. Hvis en eller begge inndataverdiene er usanne (null), er utdataverdien 0.",
		booleanXorName: "Boolsk Xor",
		booleanXorSnip: "Utfører en Boolsk eXclusive Or-operasjon på celleverdiene for to inndatarastere. Hvis en inndataverdi er sann (ikke null) og den andre verdien er usann (null), er utdataverdien 1. Hvis begge inndataverdiene er sanne eller begge er usanne, er utdataverdien 0.",
		booleanXorDesc: "Funksjonen utfører en Boolsk eXclusive Or-operasjon på celleverdiene for to inndatarastere. Hvis en inndataverdi er sann (ikke null) og den andre verdien er usann (null), er utdataverdien 1. Hvis begge inndataverdiene er sanne eller begge er usanne, er utdataverdien 0.",
		bufferedRasterName: "Bufret",
		bufferedRasterSnip: "Bufrer de(n) siste tilgjengelige pikselblokken(e).",
		bufferedRasterDesc: "Bufferfunksjonen brukes til å optimalisere ytelsen til komplekse funksjonskjeder. Den lagrer utdatene i minnet for den delen av funksjonskjeden som kommer før den. <div><br/>Sett inn denne funksjonen i funksjonsredigeringen der du ønsker å lagre utdataene.</div>",
		rasterCalculatorName: "Kalkulator",
		rasterCalculatorSnip: "Beregner et raster fra et rasterbasert matematisk uttrykk.",
		rasterCalculatorDesc: "Kalkulator-funksjonen lar deg opprette og kjøre uttrykk og inkorporere dem i funksjonskjeder.",
		cellStatisticsName: "Cellestatistikk",
		cellStatisticsSnip: "Beregner en per-cellestatistikk fra flere rastere. De tilgjengelige statistikktypene er Majoritet, Maksimum, Median, Minimum, Minoritet, Område, Standardavvik, Sum og Variasjon.",
		cellStatisticsDesc: "Denne funksjonen beregner statistikk fra flere raster, på piksel-etter-piksel basis. De tilgjengelige statistikktypene er Majoritet, Maksimum, Median, Minimum, Minoritet, Område, Standardavvik, Sum og Variasjon.",
		classifyName: "Klassifiser",
		classifySnip: "Tilordner hver piksel til en klasse. Innlemm tilleggsdata, f.eks. et segmentert bilde.",
		classifyDesc: "Denne raster-funksjonen klassifiserer et rasterdatasett basert på en Esri Classifier Definition (.ecd)-fil og rasterdata som inndata. .Ecd-filen som brukes i klassifiseringsfunksjonen, inneholder all informasjonen for et bestemt datasett og klassifiserer, og genereres av klassifikasjonslæreverktøyene, for eksempel Vector Machine eller Train Random Trees.",
		clipName: "Klipp ut",
		clipSnip: "Angir utstrekningen av et raster ved hjelp av koordinater eller et annet datasett.",
		clipDesc: "Denne funksjonen klipper et raster med en rektangulær form i henhold til de definerte utstrekningene, eller klipper et raster i henhold formen på en polygon-geoobjektklasse. Formen som definerer klippet, kan klippe utstrekningen av rasteret eller klippe ut et område i rasteret.",
		colorspaceConversionName: "Fargemodellkonvertering",
		colorspaceConversionSnip: "Konverterer et raster fra RGB til HSV og motsatt.",
		colorspaceConversionDesc: "Color Model Conversion-funksjonen konverterer bildes fargemodell fra tone, metning og valør (HSV) til rødt, grønt og blått (RGB), eller omvendt.<div><br/>Denne funksjonen kan brukes i et mosaikkdatasett.</div>",
		colormapToRGBName: "Fargekart til RGB",
		colormapToRGBSnip: "Konverterer et enkeltbåndraster med et fargekart til et raster med tre bånd (rød, grønn og blå).",
		colormapToRGBDesc: "Denne funksjonen konverterer et enkeltbåndraster med et fargekart til et raster med tre bånd (rød, grønn og blå).<div><br/>Denne funksjonen er nyttig når du har behov for å lage et raster med tre bånd fra et enkeltbåndraster med et tilknyttet fargekart. Verdiene i fargekartet brukes til å lage hvert røde, grønne og blå bånd. Denne funksjonen kan brukes i et mosaikkdatasett.</div>",
		colormapName: "Fargekart",
		colormapSnip: "Endrer pikselverdiene til å vise rasterdataene som enten et gråtonet eller et rødt, grønt og blått (RGB)-basert bilde på bakgrunn av et fargeskjema eller en fargepalett.",
		colormapDesc: "Colormap-funksjonen er en type rasterdataopptegner. Den forvandler pikselverdiene til å vise rasterdataene som enten et gråtonet eller et RGB-basert fargebilde på bakgrunn av et fargeskjema eller bestemte farger i en fargekartfil. Du kan bruke et fargekart til å representere analyserte data, for eksempel et klassifisert bilde eller når du viser et topografisk kart (eller et indeksfargeskannet bilde).<div><br/>Fargekart inneholder et sett med fargeverdier som brukes til å vise et enkeltbåndraster konsekvent med de samme fargene. Hver pikselverdi er knyttet til en farge, definert som et sett med RGB-verdier. Fargekart kan støtte alle slags bitdybder unntatt flytpunkt. De støtter også positive og negative verdier og kan inneholde manglende fargekartverdier. Når et datasett vises med et fargekart som inneholder manglende verdier, vises ikke pikslene med de manglende verdiene.</div>",
		complexName: "Kompleks",
		complexSnip: "Trekker ut størrelsen fra komplekse tall.",
		complexDesc: "Denne funksjonen beregner omfanget fra komplekse verdier.<div><br/>Denne funksjonen brukes vanligvis med RADAR-bilder som har en kompleks datatype. Den kan brukes i et mosaikkdatasett.</div>",
		compositeBandName: "Composite Bands",
		compositeBandSnip: "Kombinerer flere datasett i én raster med flere bånd.",
		compositeBandDesc: "Composite Bands-funksjonen lar deg kombinere raster for å danne et bilde med flere bånd.",
		conName: "Con",
		conSnip: "Utfører en betinget If, Then, Else-operasjon. Når en Con-operator brukes, må det vanligvis være to eller flere funksjoner som er sammenkjedet, hvor én funksjon angir kriteriene, og den andre funksjonen er Con-operatoren som bruker kriteriene og angir hva de sanne og usanne utdata skal være.",
		conDesc: "Con-funksjonen angir pikslene til utdatarasteret basert på en hvis\\eller-evaluering av hver inndatapiksel. Den returnerer pikselverdier fra True Raster hvis den betingede evalueringen er sann (1) eller returnerer pikselverdiene fra False Raster hvis den betingede evalueringen er usann (0). Disse kriteriene er spesifisert av utdata av en logisk matematikkfunksjon, som vil være inndatarasteret.",
		constantName: "Konstant",
		constantSnip: "Oppretter et virtuelt raster med en enkelt pikselverdi.",
		constantDesc: "Denne funksjonen oppretter et virtuelt raster med en enkelt pikselverdi som kan brukes i rasterfunksjonsmaler og til å behandle et mosaikkdatasett.<div><br/>Den konstante verdien brukes for hver pikselverdi i rasteret.</div>",
		contourName: "Contour",
		contourSnip: "Oppretter konturlinjer.",
		contourDesc: "Contour-funksjonen genererer konturlinjer ved å koble sammen punkter med samme høyde fra et rasterhøydedatasett. Konturene er isoliner som er laget som raster for visualisering. Følgende nøkkelegenskaper gjør denne funksjonen kraftig: konturer blir raskt og dynamisk generert på svært store datasett, for eksempel World Elevation; konturer kan glattes ut for å gi et mer kartografisk tiltalende utseende samtidig som konturenes nøyaktighet opprettholdes; dynamisk kontroll over konturintervallet tilbys; mulige resultater inkluderer konturlinjer, indekskonturer og fylte konturer.<div><br/>Muligheten til å opprette et konturlag som et rasterprodukt er nyttig i en rekke sammenhenger, siden konturene kan legges på et kart og gi informasjon om terrenget uten å skjule de underliggende dataene. De er nyttige i bruksområder som bygg og anlegg, landbruk og vannforvaltning.</div>",
		contrastBrightnessName: "Contrast and Brightness",
		contrastBrightnessSnip: "Justerer kontrasten og lysstyrken til et raster.",
		contrastBrightnessDesc: "Contrast And Brightness-funksjonen forbedrer utseendet til rasterdata ved å endre lysstyrken og kontrasten i bildet. Brightness øker den generelle lysstyrken i bildet— for eksempel, noe som gjør mørke farger lettere og lyse farger hvitere— mens Contrast justerer forskjellen mellom de mørkeste og lyseste fargene.<div><br/>Denne funksjonen endrer pikselverdiene. Den bør derfor brukes når du vil forbedre presentasjonen av dataene og ikke hvis du har tenkt å bruke dataene som en del av en analyse som krever rå pikselverdier. Denne funksjonen er nyttig når du publiserer dataene som en bildetjeneste som kan brukes i applikasjoner uten muligheten til å endre bildens kontrast og lysstyrke, eller for å sikre at dataene vises med dine foretrukne innstillinger.</div>",
		convolutionName: "Konvolvering",
		convolutionSnip: "Bruker et filter som skal gjøre skarpere, mer uklart, oppdage kanter, glatte ut eller lage en gradient over et raster.",
		convolutionDesc: "Convolution-funksjonen utfører filtrering på pikselverdiene i et bilde, som kan brukes til å gjøre et bilde skarpere, tilsløre et bilde, oppdage kanter innenfor et bilde eller andre kjernebaserte forbedringer. Filtre brukes til å forbedre kvaliteten på rasterbildet ved å eliminere falske data eller forbedre geoobjekter i dataene. Disse konvolveringsfiltrene blir brukt på en bevegelig, overlappende kjerne (vindu eller nabolag), slik som 3 ganger 3. Konvolveringsfiltrere fungerer ved å beregne pikselverdien basert på vekten til nabopikslene.",
		corridorName: "Corridor",
		corridorSnip: "Beregner summen av akkumulerte kostnader for to akkumulerte kostnadsrastere.",
		corridorDesc: "Corridor-funksjonen beregner summen av akkumulerte kostnader for to akkumulerte kostnadsrastere. Mens to hvilke som helst raster kan brukes til inndata, for å oppnå et meningsfylt resultat, bør de være uendrede akkumulerte kostnadsrastere. Rekkefølgen av de to inndatene er irrelevant.",
		cosHName: "CosH",
		cosHSnip: "Beregner hyperbolsk cosinus for cellene i et raster.",
		cosHDesc: "Funksjonen beregner hyperbolsk cosinus for pikslene i et raster.",
		cosName: "Cos",
		cosSnip: "Beregner cosinus av en celle i raster.",
		cosDesc: "Funksjonen beregner cosinus for pikslene i et raster.",
		costAllocationName: "Cost Allocation",
		costAllocationSnip: "Beregner, for hver celle, den minst kostnadskrevende kilde, basert på den laveste akkumulerte kostnaden over en kostnadsoverflate.",
		costAllocationDesc: "Cost Allocation-funksjonen beregner, for hver celle, den minst kostnadskrevende kilde, basert på den laveste akkumulerte kostnaden over en kostnadsoverflate.",
		costBackLinkName: "Cost Back Link",
		costBackLinkSnip: "Definerer naboen som er den neste cellen på den akkumulerte minste kostnadsruten, til kilden for den minste kostnadskilden.",
		costBackLinkDesc: "Cost Back Link-funksjonen definerer den neste nabocellen langs den akkumulerte minste kostnadsruten til den minste kostnadskilden.<div><br/>Back Link-rasteret inneholder verdier fra null til åtte. Verdiene definerer retningen eller identifiserer neste nabocelle (den etterfølgende cellen) langs ruten med lavest akkumulert kostnad fra en celle og frem til kilden for laveste kostnadsberegning. Hvis ruten skal gå til den riktige naboen, blir cellen tilordnet verdien 1, og 2 for den cellen nederst til høyre diagonalt, og fortsetter videre med urviseren. Verdien 0 er reservert for kildeceller.</div>",
		costDistanceName: "Cost Distance",
		costDistanceSnip: "Beregner den minste akkumulerte kostnadsavstanden for hver celle fra eller til den minst kostnadskrevende kilden, over en kostnadsoverflate.",
		costDistanceDesc: "Cost Distance-funksjonen beregner den minste akkumulerte kostnadsavstanden for hver celle fra eller til den minst kostnadskrevende kilden, over en kostnadsoverflate.",
		costPathName: "Cost Path",
		costPathSnip: "Beregner minste kostnadsruten fra en kilde til en destinasjon.",
		costPathDesc: "Den globale Cost Path-funksjonen beregner minste kostnadsrute fra en kilde til en destinasjon.<div><br/>Denne funksjonen produserer et utdataraster som finner ruten eller rutene med lavest kostnad fra utvalgte steder til nærmeste kildecelle som er definert innenfor den akkumulerte kostnadsoverflaten, i betydningen kostnadsavstand.</div>",
		curvatureName: "Curvature",
		curvatureSnip: "Beregner krumningen av en rasteroverflate, eventuelt også profil og plankrumning.",
		curvatureDesc: "Curvature-funksjonen viser formen eller krumningen av hellingen. En del av en overflate kan være konkav eller konveks; du kan se det ved å se krumningsverdien. Krumningen beregnes ved å regne ut det andre derivatet av overflaten.<div><br/>Utdataene fra Curvature-funksjonen kan brukes til å beskrive de fysiske egenskapene til et nedslagsfelt i et forsøk på å forstå erosjons- og avløpsprosesser. Krumningsverdien kan brukes til å finne jorderosjonsmønstre og fordeling av vann på land. Profilkurvaturen påvirker en strømings akselerasjon og retardasjon og påvirker derfor erosjon og avsetning. Planformkrumningen påvirker strømningens konvergens og divergens.</div>",
		divideName: "Dele på",
		divideSnip: "Deler verdiene til to raster på piksel for piksel-basis.",
		divideDesc: "Divide-funksjonen deler verdiene til to raster på piksel for piksel-basis.",
		elevationVoidFillName: "Elevation Void Fill",
		elevationVoidFillSnip: "Brukes til å opprette piksler der det finnes hull i høydedataene dine.",
		elevationVoidFillDesc: "Elevation Void Fill-funksjonen brukes til å opprette piksler der det finnes hull i din høyde.<div><br/>Det oppstår tomrom når det ikke er noen punkter samlet inn i området, representert av en piksel i det resulterende rasteret. Tomrom forårsakes ofte av vannlegemer, klassetypevalg eller utestenging. Fylling av tomrom brukes mest når man lager en bakkeoverflate.</div>",
		equalToName: "Er lik",
		equalToSnip: "Utfører en relasjonell equal-to-operasjon på to inndata på en celle for celle-basis. Returnerer 1 for celler der det første rasteret er lik det andre rasteret, og 0 for celler der de ikke er like.",
		equalToDesc: "Funksjonen utfører en tilsvarende operasjon på to raster på en piksel for piksel-basis. Den returnerer verdien 1 for piksler der det første rasteret er lik det andre rasteret, og verdien 0 for piksler der de ikke er like.",
		eucAllocationName: "Euclidean Allocation",
		eucAllocationSnip: "Beregner, for hver celle, nærmeste kilde basert på euklidisk avstand.",
		eucAllocationDesc: "Euclidean Allocation-funksjonen beregner, for hver celle, nærmeste kilde basert på euklidisk avstand.",
		eucDirectionName: "Euclidean Direction",
		eucDirectionSnip: "Beregner, for hver celle, retningen i grader til nærmeste kilde.",
		eucDirectionDesc: "Euclidean Direction-funksjonen beregner, for hver celle, retningen i grader til nærmeste kilde. <div><br/>Retningen beregnes fra hvert cellesenter til midten av kildecellen som er nærmest. Verdiområdet er fra 0 grader til 360 grader, med 0 reservert for kildecellene. Østlig retning (høyre) er 90 og verdiene øker med urviseren (180 er sør, 270 er vest og 360 er nord).</div>",
		eucDistanceName: "Euclidean Distance",
		eucDistanceSnip: "Beregner, for hver celle, den euklidske avstanden til den nærmeste kilden.",
		eucDistanceDesc: "Euclidean Distance-funksjonen beregner, for hver celle, den euklidske avstanden til den nærmeste kilden.",
		exp10Name: "Exp10",
		exp10Snip: "Beregner base 10-eksponenten for cellene i et raster.",
		exp10Desc: "Exp 10-funksjonen beregner base 10-eksponenten for pikslene i et raster.",
		exp2Name: "Exp2",
		exp2Snip: "Beregner base 2-eksponenten for cellene i et raster.",
		exp2Desc: "Dnne funksjonen beregner base 2-eksponenten for pikslene i et raster.",
		expName: "Exp",
		expSnip: "Beregner base e-eksponenten for cellene i et raster.",
		expDesc: "Dnne funksjonen beregner base e-eksponenten for pikslene i et raster.",
		extractBandName: "Extract Bands",
		extractBandSnip: "Angir hvilke bånd som det skal jobbes med når du bruker datasett med flere bånd.",
		extractBandDesc: " Extract Bands-funksjonen lar deg trekke ut et eller flere bånd fra, eller omorganisere båndene i, et rasterdatasett med flere bånd.<div><br/>Du kan bruke Extract Bands-funksjonen før andre funksjoner, for eksempel Arithmetic, for å kontrollere hvilke bånd som brukes som inndata i neste funksjon.</div>",
		fillName: "Fyll",
		fillSnip: "Fyller senkninger og topper i en høydeoverflateraster for å fjerne små feil i dataene.",
		fillDesc: "Global Fill-funksjonen lokaliserer og fyller senkninger og topper i en høydeoverflateraster for å fjerne små feil i dataene. Funksjonen fyller inn en iterativ prosess inntil alle senkninger fylles innenfor den angitte Z-grensen.<div><br/>Når en høydeoverflate opprettes med Ortho Mapping-verktøy eller på annen måte, er det ofte små, men vesentlige feil i form av senkninger og topper i dataene. I fotogrammetri blir senkninger og topper ofte kalt hull og spisser. Siden overflatedata ofte brukes i modellering, for eksempel hydrologisk modellering, er det viktig å korrigere disse senknings- og toppfeilene på en måte som er i samsvar med de omgivende dataene.</div>",
		floatName: "Flyt",
		floatSnip: "Konverterer hver pikselverdi i et raster til en representasjon med flytpunkter.",
		floatDesc: "Float-funksjonen konverterer hver pikselverdi i et raster til en representasjon med flytpunkter.",
		flowAccumulationName: "Strømningsakkumulering",
		flowAccumulationSnip: "Oppretter et raster med akkumulert flyt i hver celle. En vektfaktor kan eventuelt brukes.",
		flowAccumulationDesc: "Den globale funksjonen Flow Accumulation lager et raster av akkumulert strømning i hver piksel, som fastslås ved å samle vekten for alle piksler som strømmer inn i hver nedenforliggende piksel. Hvis ingen vektraster er oppgitt, blir en vekt på 1 brukt hver piksel, og verdien av piksler i utdatarastet er antallet piksler som strømmer inn i hver piksel.<div><br/>Utdatapiksler med høy akkumulert tilstrømming er områder med konsentrert strømning og kan brukes til å identifisere strømningskanaler. Utdatapiksler med akkumulert tilstrømming lik null er lokale, topografiske høyder, og kan brukes til å identifisere åsrygger.</div>",
		flowDirectionName: "Strømningsretning",
		flowDirectionSnip: "Oppretter et raster av strømningsretningen fra hver piksel til den bratteste nedenforliggende naboen.",
		flowDirectionDesc: "En av nøklene til å avlede hydrologiske karakteristikker på en overflate er evnen til å bestemme strømningsretningen fra hver piksel i rasteret. Flow Direction-rasterfunksjonen tar en overflate som inndata og oppretter et raster av strømningsretning fra hver piksel til den bratteste nedenforliggende naboen. Flow Direction-funksjonen støtter tre strømningsmodelleringsmetoder: D8 (åtte retninger), Multi-Flow Direction (MFD) og D-Infinity (DINF). ",
		flowDistanceName: "Flow Distance",
		flowDistanceSnip: "For hver piksel beregnes den laveste nedoverhellende horisontale eller vertikale avstanden til celler på en elv eller strøm som de strømmer inn i.",
		flowDistanceDesc: "For hver piksel beregner funksjonen den laveste nedoverhellende horisontale eller vertikale avstanden til piksel(er) på en elv eller strøm som de strømmer inn i. Hvis et valgfri strømningsretningsraster tilbys, vil retningen(e) for nedoverhellingen være begrenset til de som er definert av inndatastrømningsretningsrasteret. Utdataene er et strømningsavstandraster.",
		focalName: "Focal Statistics",
		focalSnip: "Beregner fokalstatistikk for hver piksel av et bilde basert på et definert fokalnabolag.",
		focalDesc: "Focal Statistics-funksjonen beregner fokalstatistikk for hver piksel av et bilde basert på et definert fokalnabolag.",
		geometricName: "Geometrisk",
		geometricSnip: "Øker posisjonsnøyaktigheten til et datasett ved å ta hensyn til høyden.",
		geometricDesc: "Geometric-funksjonen produserer et ortokorrigert bilde basert på en sensordefinisjon og en terrengmodell. Den øker posisjonsnøyaktigheten til et datasett ved å ta hensyn til høyden.",
		grayscaleName: "Grayscale",
		grayscaleSnip: "Konverterer et bilde med flere bånd til et gråskalabilde med ett bånd.",
		grayscaleDesc: "Denne funksjonen konverterer et bilde med flere bånd til et gråskalabilde med ett bånd.<div><br/>Denne funksjonen bruker spesifiserte vekter på hvert av inndatabåndene og normaliserer utdatabildet. Vektene blir ofte brukt fordi enkelte bånd har varierende betydning avhengig av bruksområdet. For eksempel inneholder det blå båndet ofte mer støy enn andre bånd.</div>",
		greaterThanEqualName: "Større enn eller lik",
		greaterThanEqualSnip: "Utfører en relasjonell større enn lik-operasjon på to inndata på en celle for celle-basis. Returnerer 1 for celler der det første rasteret er større enn eller lik det andre rasteret, og 0 den ikke er det.",
		greaterThanEqualDesc: "Funksjonen utfører en relasjonell større enn- eller lik-operasjon på to inndata på en celle for celle-basis. Den returnerer en verdi på 1 for piksler der det første rasteret er større enn eller lik det andre rasteret, og en verdi på 0 for piksler der det første rasteret ikke er større enn eller lik det andre rasteret.",
		greaterThanName: "Større enn",
		greaterThanSnip: "Utfører en relasjonell større enn-operasjon på to inndata på en celle for celle-basis. Returnerer 1 for celler der det første rasteret er større enn det andre rasteret, og 0 den ikke er det.",
		greaterThanDesc: "Funksjonen utfører en relasjonell større enn-operasjon på to inndata på en piksel etter piksel-basis. Returnerer en verdi på 1 for piksler der det første rasteret er større enn det andre rasteret, og en verdi på 0 for piksler der det første rasteret ikke er større enn det andre rasteret.",
		heatIndexName: "Varmeindeks",
		heatIndexSnip: "Kombinerer omgivelsestemperatur og relativ fuktighet for å returnere opplevd temperatur.",
		heatIndexDesc: "Denne funksjonen beregner opplevd temperatur basert på omgivelsestemperatur og relativ fuktighet. Den opplevde temperaturen beskrives ofte som hvor varmt det føles for menneskekroppen.<div><br/>Denne indeksen kan være nyttig for å beregne farer i forbindelse med medisinske problemer som muskelkramper, dehydrering, heteanfall eller mer alvorlige heteslag på varme og fuktige dager. Når relativ fuktighet er høy, blir det stadig vanskeligere for kroppens svette å fordampe, slik at folk ikke har noen naturlig måte å avkjøles på. Kart over varmeråd eller -advarsler er ofte et produkt av omklassifisering av varselindeksresultatet i klasser, der jo høyere indeksverdien er, desto mer sannsynlig er det at det blir en advarsel fremfor bare et råd.</div>",
		hillshadeName: "Hillshade",
		hillshadeSnip: "Lager en 3D-representasjon av overflaten, med solens relative posisjon tatt i betraktning for å skyggelegge bildet.",
		hillshadeDesc: "Hillshade-funksjonen produserer en gråtonet 3D-representasjon av terrengoverflaten, med solens relative posisjon tatt i betraktning for å skyggelegge bildet. <div><br/>Skyggemodellering er en teknikk for å visualisere terrenget i henhold til en lyskilde og skråningen og aspektet for høydeoverflaten. Det er en kvalitativ metode for visualisering av topografi og gir ikke absolutte høydeverdier. </div>",
		intName: "Int",
		intSnip: "Konverterer hver celleverdi i et raster til et heltall ved hjelp av trunkering.",
		intDesc: "Int-funksjonen konverterer hver pikselverdi i et raster til et heltall ved hjelp av trunkering.",
		interpolateIrregularDataName: "Interpolate Irregular Data",
		interpolateIrregularDataSnip: "Interpolerer fra punktskyer eller uregelmessige rutenett.",
		interpolateIrregularDataDesc: "Enkelte netCDF- eller HDF-datasett lagrer geolokasjoner som uregelmessig adskilte matriser av piksler eller punktdata. Når du legger til disse datasettene i et mosaikkdatasett, tar interpolert uregelmessige data-funksjonen uregelmessig rutenettdata og omfordeler dem slik at hver piksel er av lik størrelse og er firkantet.<div><br/>Når du legger til variabler fra netCDF eller HDF til et mosaikkdatasett, vil det automatisk verifisere om dataene er ordnet regelmessig. Hvis de ikke er det, kan interpoler uregelmessige data-funksjonen brukes til å konvertere de uregelmessige dataene til et regelmessig rutenettbasert raster. Du kan endre interpoleringsmetoden og cellestørrelsen som brukes i interpoler uregelmessige dataraster–funksjonen. For rasterdata med regelmessige mellomrom vil det ikke bli bruk noen interpolering, og dataene vil bli lest som det er.</div>",
		isNullName: "Is Null",
		isNullSnip: "Bestemmer hvilke verdier fra inndatarasteret som er NoData på en celle etter celle-basis. Returnerer en verdi på 1 hvis inndataverdien er NoData, og en verdi på 0 for celler som ikke er det.",
		isNullDesc: "Is Null-funksjonen bestemmer hvilke verdier fra inndatarasteret som er NoData på en piksel etter piksel-basis. Den returnerer en verdi på 1 hvis inndataverdien er NoData, og en verdi på 0 for piksler som ikke er NoData.",
		kernelDensityName: "Kernel Density",
		kernelDensitySnip: "Beregner størrelses per arealenhet fra punkt- eller linjegeoobjekter, ved hjelp av en kjernefunksjon for å tilpasses en jevn konisk overflate til hvert punkt eller linje.",
		kernelDensityDesc: "Denne funksjonen beregner størrelses per arealenhet fra punkt- eller linjegeoobjekter, ved hjelp av en kjernefunksjon for å tilpasses en jevn konisk overflate til hvert punkt eller linje.",
		keyMetadataName: "Key Metadata",
		keyMetadataSnip: "Overstyrer eller legger inn nøkkelmetadata til et raster i en funksjonskjede.",
		keyMetadataDesc: "Denne funksjonen lar deg sette inn eller overstyre et rasters nøkkelmetadata.<div><br/>Informasjonen i viktige metadata brukes til å hjelpe programmet med noe behandling og opptegning, inkludert å gi nyttige opplysninger som sensorens navn, båndets navn eller skydekket som er knyttet til bildene.</div>",
		shortestPathName: "Least Cost Path",
		shortestPathSnip: "Utfører en kostnad-avstandsanalyse med kilde- og destinasjon som inndata, som deretter brukes til å finne den minste kostnadsruten fra en kilde til en destinasjon.",
		shortestPathDesc: "Least Cost Path-funksjonen beregner minste kostnadskruten fra en kilde til en destinasjon. Den minste akkumulerte kostnadsavstanden beregnes for hver piksel over en kostnadsoverflate, til nærmeste kilde. Den produserer et utdataraster som registrerer minste kostnadsruten eller -rutene fra utvalgte steder til nærmeste kildepiksler som er definert innenfor den akkumulerte kostnadsoverflaten, i betydningen kostnadsavstand.<div><br/>Hver rute med lavest kostnad tildeles en verdi når den oppdages i skanneprosessen. Sluttpikselet i kilderaster for en kostnadsrute får verdi 1. Den første ruten får en verdi på 3, den andre 4, og så videre. Når flere ruter slås sammen og følger den gjenværende avstanden tilbake til en kilde på samme rute, blir segmentet hvor de to banene går sammen, tilordnet en verdi på 2. Den sammenslåtte delen av ruten kan ikke tilordnes verdien av en av banene, siden den sammenslåtte delen tilhører begge ruter.</div>",
		lessThanEqualName: "Mindre enn eller lik",
		lessThanEqualSnip: "Utfører en relasjonell mindre enn eller større enn-operasjon på to inndata på en celle for celle-basis. Returnerer 1 for celler der det første rasteret er mindre enn eller lik det andre rasteret, og 0 hvis den ikke er det.",
		lessThanEqualDesc: "Funksjonen utfører en relasjonell mindre enn- eller større enn-operasjon på to inndata på en piksel etter piksel-basis. Den returnerer en verdi på 1 for piksler der det første rasteret er mindre enn eller lik det andre rasteret, og en verdi på 0 der det ikke er mindre enn eller lik det andre rasteret.",
		lessThanName: "Mindre enn",
		lessThanSnip: "Utfører en relasjonell mindre enn-operasjon på to inndata på en celle for celle-basis. Returnerer 1 for celler der det første rasteret er mindre enn det andre rasteret, og 0 hvis det ikke er det.",
		lessThanDesc: "Funksjonen utfører en relasjonell mindre enn-operasjon på to inndata på en piksel etter piksel-basis. Den returnerer en verdi på 1 for piksler der det første rasteret er mindre enn det andre rasteret, og en verdi på 0 der den ikke er mindre enn det andre rasteret.",
		lnName: "Ln",
		lnSnip: "Beregner den naturlige logaritmen (base e) for cellene i et raster.",
		lnDesc: "Ln-funksjonen beregner den naturlige logaritmen (base e) av hver piksel i en raster.",
		log10Name: "Log10",
		log10Snip: "Beregner base 10-logaritmen for cellene i et raster.",
		log10Desc: "Log10-funksjonen beregner base 10-logaritmen for hver piksel i et raster.",
		log2Name: "Log2",
		log2Snip: "Beregner base 2-logaritmen for cellene i et raster.",
		log2Desc: "Log2-funksjonen beregner base 2-logaritmen for hver piksel i et raster.",
		lookupName: "Lookup",
		lookupSnip: "Oppretter et nytt raster ved å slå opp verdier som finnes i et annet felt i tabellen til inndatarasteret.",
		lookupDesc: "Funksjonen oppretter et nytt raster ved å slå opp verdier som finnes i et annet felt i tabellen til inndatarasteret.",
		mlClassifyName: "ML Classify",
		mlClassifySnip: "Klassifiserer bilder med en per piksel-tilnærming. Blandede piksler tilordnes geoobjektet med den høyeste prosentandelen i den pikselen.",
		mlClassifyDesc: "ML Classify-funksjonen lar deg utføre en overvåket klassifisering på et raster- eller mosaikkdatasett, ved hjelp av klassifiseringsalgoritmen for maksimal sannsynlighet. Denne funksjonen krever en klassifikasjonssignaturfil.",
		maskName: "Maske",
		maskSnip: "Angir verdier som du ikke vil vise.",
		maskDesc: "Denne rasterfunksjonen angir verdier som du ikke vil vise i rasteret ditt. Ved å bruke Mask-funksjonen vil du spesifisere en eller flere NoData-verdier eller en rekke gyldige pikselverdier. ",
		minusName: "Minus",
		minusSnip: "Subtraherer verdien av det andre inndatarasteret fra verdien av det første inndatarasteret på en celle for celle-basis.",
		minusDesc: "Minus-funksjonen subtraherer verdien av det andre inndatarasteret fra verdien av det første inndatarasteret på en piksel for piksel-basis.",
		modName: "Mod",
		modSnip: "Finner resten (modulo) av det første rasteret når den deles av det andre rasteret på celle for celle-basis.",
		modDesc: "Mod-funksjonen finner resten (modulo) av det første rasteret når den deles av det andre rasteret på piksel for piksel-basis. Rekkefølgen av de to inndatene er viktig og påvirker utdataresultatene.",
		mosaicRastersName: "Mosaic Rasters",
		mosaicRastersSnip: "Setter sammen et sett med rasterdatasett for å lage ett datasett.",
		mosaicRastersDesc: "Mosaic Rasters-funksjonen lager et mosaikkbilde ut fra flere bilder. Når det er overlapping mellom bildene, er det flere metoder du kan velge blant for å bestemme hvilke bilder som vises.",
		ndviColorizedName: "NDVI Colorized",
		ndviColorizedSnip: "Oppretter et datasett med flere bånd som representerer vegetasjonshelse, basert på forskjellen mellom de røde og nærliggende infrarøde båndene.",
		ndviColorizedDesc: "NDVI Colorized-funksjonen bruker NDVI-funksjonen på inndatabildet, og bruker deretter et fargekart eller en fargepalett til å vise resultatet.",
		ndviName: "NDVI",
		ndviSnip: "Beregner Normalized Difference Vegetation Index (NDVI).",
		ndviDesc: "NDVI-funksjonen oppretter et datasett med ett bånd som representerer vegetasjonshelse, basert på forskjellen mellom de røde og nærliggende infrarøde båndene.<div><br/>NDVI er en standardisert indeks som gjør at du kan generere et bilde som viser grønnhet, også kjent som relativ biomasse. Denne indeksen drar nytte av kontrasten fra karakteristikken av to bånd fra et multispektralt rasterdatasett. Klorofyllpigmentabsorpsjonene i det røde båndet og den høye refleksjonen av plantemateriale i det nær infrarøde (NIR) båndet. Ekstremt lave eller negative NDVI-verdier representerer områder uten vegetasjon i det hele tatt, for eksempel skyer, vann eller snø. Svært lave verdier representerer områder med liten eller ingen vegetasjon, som betong, stein eller ren jord. Moderate verdier representerer områder med busker og gressletter. Høye verdier representerer skogsområder og frodig vegetasjon.</div>",
		negateName: "Invertér",
		negateSnip: "Endrer tegnet (ganger med -1) av pikselverdiene til inndatarasteret på en celle for celle-basis.",
		negateDesc: "Negate-funksjonen endrer tegnet (ganger med -1) av pikselverdiene til inndatarasteret på en piksel ",
		nibbleName: "Nibble",
		nibbleSnip: "Erstatter cellene i et raster som svarer til en maske med verdiene til nærmeste naboer.",
		nibbleDesc: "Nibble-globalfunksjonen lar utvalgte områder på et rastet bli tildelt verdien av nærmeste nabo. Dette er nyttig for redigering av områder i et raster der dataene kan være feilaktige.",
		notEqualName: "Ikke lik",
		notEqualSnip: "Utfører en relasjonell ikke lik-operasjon på to inndata på en celle for celle-basis. Returnerer 1 for celler der det første rasteret ikke er lik det andre rasteret, og 0 hvis den er lik.",
		notEqualDesc: "Funksjonen utfører en relasjonell ikke lik-operasjon på to inndata på en piksel etter piksel-basis. Den returnerer en verdi på 1 for piksler der det første rasteret ikke er lik det andre rasteret, og en verdi på 0 der den er lik det andre rasteret.",
		pansharpeningName: "Pansharpen",
		pansharpeningSnip: "Forbedrer kunstig den geografiske oppløsningen til et bilde med flere bånd ved å føye det sammen med et pankromatisk bilde med høyere oppløsning.",
		pansharpeningDesc: "Pansharpening-funksjonen bruker et pankromatisk bilde eller rasterbånd med høyere oppløsning for å smelte sammen med et rasterdatasett med lavere oppløsning, og flerbåndraster-datasett for å øke den geografiske oppløsningen til flerbåndbildet.<div><br/>Formålet med Pansharpen er å skape et bilde med høyere kvalitet. Siden teknikkene forandrer radiometrien og de spektrale egenskaperne til bildet med flere bånd, må pankromatisk kjerpede bilder brukes med forsiktighet til fjernanalytiske formål.</div>",
		pathAllocationName: "Path Distance Allocation",
		pathAllocationSnip: "Beregner nærmeste kilde for hver celle basert på minst akkumulerte kostnad over en kostnadsoverflate, mens det tas hensyn til overflateavstand og horisontale og vertikale kostnadsfaktorer.",
		pathAllocationDesc: "Path Distance Allocation-funksjonen beregner nærmeste kilde for hver celle, basert på minst akkumulerte kostnad over en kostnadsoverflate, mens det tas hensyn til overflateavstand og horisontale og vertikale kostnadsfaktorer.",
		pathBackLinkName: "Path Distance Back Link",
		pathBackLinkSnip: "Definerer naboen som er den neste cellen på den akkumulerte minste kostnadsruten til den laveste kostnadskilden, mens det tas hensyn til overflateavstand i tillegg til horisontale og verdikale kostnadsfaktorer.",
		pathBackLinkDesc: "Path Distance Back Link-funksjonen identifiserer retningen til naboen som er den neste cellen på den akkumulerte minste kostnadsruten til nærmeste kilde, mens det tas hensyn til overflateavstand og horisontale og vertikale kostnadsfaktorer.",
		pathDistanceName: "Path Distance",
		pathDistanceSnip: "Beregner for hver celle den minst akkumulerte kostnaden over en kostnadsoverflate, mens det tas hensyn til overflateavstand og horisontale og vertikale kostnadsfaktorer.",
		pathDistanceDesc: "Funksjonen Path Distance beregner nærmeste kilde for hver celle basert på minst akkumulert kostnad over en kostnadsoverflate, mens det tas hensyn til overflateavstand og horisontale og vertikale kostnadsfaktorer.",
		plusName: "Plus",
		plusSnip: "Adderer (summerer) verdiene til to raster på piksel for piksel-basis.",
		plusDesc: "Plus-funksjonen adderer (summerer) verdiene til to raster på piksel for piksel-basis.",
		powerName: "Potens",
		powerSnip: "Øker celleverdiene i et raster til potensen av verdiene i et annet raster.",
		powerDesc: "Power-funksjonen øker pikselverdiene i et raster til potensen av verdiene i et annet raster.",
		radarCalibrationName: "Radar Calibration",
		radarCalibrationSnip: "Konverterer RADARSAT-2 backscatter.",
		radarCalibrationDesc: "Denne funksjonen kan brukes til å kalibrere RADARSAT-2-bilder i et mosaikkdatasett eller som et rasterprodukt. Kalibrering utføres på radarbilder slik at pikselverdiene er en ekte representasjon av radarbackscatteren.",
		rasterInfoName: "RasterInfo",
		rasterInfoSnip: "Endrer egenskapene til rasteret, for eksempel bitdybde, NoData-verdi, cellestørrelse og så videre.",
		rasterInfoDesc: "Raster Info åpner en dialog med rasterdatasettegenskaper, for eksempel antall kolonner og rader, antall bånd, pikseltype, utstrekning og romlig referanse. Du kan redigere disse egenskapene ved å velge et rasterdatasett som skal brukes som mal. ",
		rasterizeAttributesName: "Rasterize Attributes",
		rasterizeAttributesSnip: "Beriker et raster ved å legge til bånd som er utledet fra verdier på spesifiserte attributter, fra en ekstern tabell eller en geoobjekttjeneste.",
		rasterizeAttributesDesc: "Funksjonen Rasterize Attribute beriker et raster ved å legge til bånd som er utledet fra verdier på spesifiserte attributter, fra en ekstern tabell eller en geoobjekttjeneste. Du kan eventuelt angi et soneraster og tilhørende sone-ID-attributt for å aktivere regionbasert oppslag.",
		rasterizeFeatureClassName: "Rasterize Features",
		rasterizeFeatureClassSnip: "Konverterer geoobjekter til raster.",
		rasterizeFeatureClassDesc: "Denne funksjonen konverterer polygon-, polylinje- og punktgeoobjektklassedata til et rasterlag.<div><br/>Geoobjekter tilordnes pikselverdier på bakgrunn av geoobjektenes OBJECTID (standard). Pikselverdiene kan eventuelt baseres på et brukerdefinert verdifelt i inndatageoobjektets attributtabell.</div>",
		recastName: "Recast",
		recastSnip: "Endrer parametrene til en funksjonskjede i et mosaikkdatasett eller en bildetjeneste. Dette brukes ofte med LAS-datasett for å unngå å måtte opprette et eget mosaikkdatasett for ulike representasjoner av terreng.",
		recastDesc: "Funksjonen Recast brukes til dynamisk modifisering av funksjonsparameteren som brukes i et mosaikkdatasett eller bildetjeneste uten fysisk vedvarende endring.",
		regionGroupName: "Region Group",
		regionGroupSnip: "For hver celle i utdataene blir identiteten til den tilkoblede regionen som den cellen tilhører, registrert. Et unikt nummer tildeles hver region.",
		regionGroupDesc: "Globalfunksjonen Region Group registrerer identiteten til regionen som hver celle i utdataene tilhører. Et unikt nummer tildeles hver region.<div><br/>Den første regionen som skannes, får verdien én, den andre to og så videre til alle regioner er tildelt en verdi. Skanningen beveger seg fra venstre til høyre, topp til bunn. Verdiene som er tilordnet utdatasonene, er basert på når de oppdages i skanneprosessen.</div>",
		regionGrowName: "Region Grow",
		regionGrowSnip: "Vokser regioner fra utgangspunkter.",
		regionGrowDesc: "Region Grow-funksjonen grupperer nabopiksler i grupper avhengig av den angitte radiusen fra utgangspunktet. Pikselgruppen eller objektet tilordnes en spesifisert fyllingsverdi.",
		remapName: "Remap",
		remapSnip: "Endrer pikselverdier ved å tildele nye verdier til intervaller av pikselverdier eller ved hjelp av en ekstern tabell.",
		remapDesc: "Remap-funksjonen lar deg endre eller omklassifisere pikselverdiene til rasterdataene. Dette kan gjøres enten ved å spesifisere en rekke med pikselverdier for å kartlegge mot en utdatapikselverdi, eller bruke en tabell for å kartlegge pikselverdiene til utdataenes pikselverdi.",
		reprojectName: "Reproject",
		reprojectSnip: "Endrer projeksjonen av et rasterdatasett, mosaikkdatasett eller rasterelement i et mosaikkdatasett. Det kan også resample dataene til en ny cellestørrelse og definere et origo.",
		reprojectDesc: "Reproject-funksjonen endrer projeksjonen av et rasterdatasett, mosaikkdatasett eller rasterelement i et mosaikkdatasett. Det kan også resample dataene til en ny cellestørrelse og definere et origo.<div><br/>Reproject-funksjonen kan brukes når du lager en hurtigbuffer fra et raster- eller mosaikkdatasett som ikke har den nødvendige projeksjonen. Når du f.eks. oppretter en bufret bildetjeneste som kan integreres av programmer med andre bufrede tjenester, er det viktig at alle har samme projeksjon. Dette er ofte en Web Mercator-projeksjon. Siden mosaikkdatasettet ikke kan reprojiseres, kan du gjøre en av to ting— enten opprette et referert mosaikkdatasett fra mosaikkdatasettet i projeksjonen som trengs, eller legg til Reproject-funksjonen i mosaikkdatasettets funksjonskjede. Et annet eksempel bruker denne funksjonen på rasterlementet i et mosaikkdatasett. Når du bruker Cached Raster-funksjonen, vil du kanskje sette inn Reproject-funksjonen, slik at bufferen blir opprettet i den nye projeksjonen. Rasterelementer i et mosaikkdatasett kan bufres når behandlingen er intens, og du prøver å publisere en bildetjeneste som er rask, uten å bufre hele bildetjenesten.</div>",
		resampleName: "Resample",
		resampleSnip: "Endrer cellestørrelsen på et raster.",
		resampleDesc: "Resample-funksjonen endrer cellestørrelsen, resampling-typen eller begge deler.<div><br/>Resample-funksjonen bør bare brukes med spesifikke databehandlingskrav, for eksempel når du beregner vind- eller strømstyrken og -retningen som krever resampling fra kildeoppløsningen.</div>",
		roundDownName: "Avrund nedover",
		roundDownSnip: "Returnerer neste lavere heltall, representert som et flytpunkt, for hver celle i et raster.",
		roundDownDesc: "Round Down-funksjonen returnerer neste lavere heltall som en flytpunktverdi, for hver piksel i et raster.",
		roundUpName: "Avrund oppover",
		roundUpSnip: "Returnerer neste høyere heltall, representert som et flytpunkt, for hver celle i et raster.",
		roundUpDesc: "Round Up-funksjonen returnerer neste høyere heltall som en flytpunktverdi, for hver piksel i et raster.",
		segmentMeanShiftName: "Segment Mean Shift",
		segmentMeanShiftSnip: "Grupperer nabopiksler med lignende spektrale egenskaper sammen i segmenter.",
		segmentMeanShiftDesc: "Denne funksjonen identifiserer objekter, trekk eller segmenter i bildene dine ved å gruppere tilstøtende piksler sammen som har lignende spektrale og romlige egenskaper. Du kan kontrollere mengden romlig og spektral utjevning for å hjelpe til med å trekke ut geoobjekter av interesse.",
		s1RadiometricCalibrationName: "Sentinel-1 Radiometric Calibration",
		s1RadiometricCalibrationSnip: "Utfører forskjellige typer radiometrisk kalibrering på Sentinel-1 data.",
		s1RadiometricCalibrationDesc: "Denne rasterfunksjonen utfører tre forskjellige kalibreringer for Sentinel 1-datasett, inkludert beta null og gamma, og gir det kalibrerte datasettet. Målet med SAR-kalibrering er å tilby bilder hvor pikselverdiene kan være direkte relatert til radar-backscatteringen av scenen. Selv om ikke-kalibrerte SAR-bilder er tilstrekkelig for kvalitativ bruk, er kalibrerte SAR-bilder avgjørende for kvantitativ bruk av SAR-data.<div><br/>Typisk SAR-databehandling, som produserer nivå 1-bilder, omfatter ikke radiometriske korreksjoner og signifikante radiometriske skjevheter blir værende. Derfor er det nødvendig å bruke radiometrisk korreksjon til SAR-bilder, slik at bildenes pikselverdier virkelig representerer radar-backscatteren for den reflekterende overflaten. Radiometrisk korreksjon er også nødvendig for å sammenligne SAR-bilder som er innhentet med forskjellige sensorer eller hentet fra samme sensor på forskjellige tidspunkter, i forskjellige moduser, eller er behandlet av forskjellige prosessorer.</div>",
		s1ThermalNoiseRemovalName: "Sentinel-1 Thermal Noise Removal",
		s1ThermalNoiseRemovalSnip: "Fjerner termisk støy fra Sentinel-1 data.",
		s1ThermalNoiseRemovalDesc: "Termisk støykorrigering kan brukes på Sentinel-1 Level-1 Single Look Complex (SLC)-produkter samt GRD-produkter (Level 1 Ground Range Detection) som ikke allerede er korrigert. Operatoren kan også fjerne denne korreksjonen basert på produktannonteringene for å gjeninnføre støyen som ble fjernet for å produsere det opprinnelige produktet. Produktannoteringene vil bli oppdatert tilsvarende for å tillate bruk av korreksjonen på nytt. ",
		setNullName: "Angi null",
		setNullSnip: "Set Null angir identifiserte celleplasseringer til NoData basert på spesifiserte kriterier. Den returnerer NoData hvis en betinget evaluering er sann og returnerer verdien som er angitt av et annet raster hvis den er usann.",
		setNullDesc: "Set Null-funksjonen angir de identifiserte pikslene til NoData basert på de spesifikke kriteriene. Den returnerer NoData hvis en betinget vurdering er sann (1) og returnerer verdien som er angitt i False Raster hvis en betinget evaluering er usann (0). Disse kriteriene er spesifisert av utdata av en logisk matematikkfunksjon, som vil være inndatarasteret.",
		shadedReliefName: "Skyggelagt relieff",
		shadedReliefSnip: "Lager en flerbåndet, fargekodet 3D-representasjon av overflaten, med solens relative posisjon tatt i betraktning for å skyggelegge bildet.",
		shadedReliefDesc: "Shaded Relief-funksjonen skaper en farge-3D-representasjon av terrenget, og opprettes ved å slå sammen bildene fra høydekodede og terrengskyggemetoder. Denne funksjonen bruker høyde- og azimutegenskapene til å angi solens posisjon.<div><br/></div>",
		sinHName: "SinH",
		sinHSnip: "Beregner hyperbolsk sinus for cellene i et raster.",
		sinHDesc: "Funksjonen beregner hyperbolsk sinus for pikslene i et raster.",
		sinName: "Sin",
		sinSnip: "Beregner sinus for cellene i et raster.",
		sinDesc: "Funksjonen beregner sinus for pikslene i et raster.",
		slopeName: "Helning",
		slopeSnip: "Beregner endringstakten fra en pikselverdi til naboene.",
		slopeDesc: "Denne rasterfunksjonen beregner hellingen, som er endringstakten for høyden for hver celle i den digitale høydemodellen (DEM). Det er den første avledningen av en DEM.<div><br/>Denne funksjonen bruker en akselerert atan()-funksjon. Det er seks ganger raskere, og tilnærmelsesfeilen er alltid mindre enn 0,3 grader.</div>",
		speckleName: "Speckle",
		speckleSnip: "Tilbyr filtre for å fjerne støy fra datasett for syntetiske blenderåpninger.",
		speckleDesc: "Speckle er høyfrekvent støy på radardata. Bildene som er generert av SAR-systemer (synthetic aperture radar) er, som en følge av prosessering av spredte signaler og interferens av elektromagnetiske bølger spredt fra overflater eller gjenstander, svært utsatt for speckleffekter. Denne Speckle-funksjonen filtrerer støyen fra radardatasettet og jevner den ut, mens du beholder kantene eller de skarpe geoobjektene i bildet.",
		spectralConversionName: "Spectral Conversion",
		spectralConversionSnip: "Bruker en matrise på et bilde med flere bånd.",
		spectralConversionDesc: "Spectral Conversion-funksjonen bruker en matrise på et bilde med flere bånd for å påvirke fargeverdiene for utdataene.<div><br/>Enkelte sensorer henter ikke inn blå bånd på grunn av et lavt signal/støyforhold. Dette kan for eksempel brukes til å konvertere et falskt infrarødt bilde til et nesten naturlig fargebilde.</div>",
		squareRootName: "Kvadratrot",
		squareRootSnip: "Beregner kvadratroten av pikselverdiene i et raster.",
		squareRootDesc: "Square Root-funksjonen beregner kvadratroten av pikselverdiene i et raster.",
		squareName: "Kvadrat",
		squareSnip: "Beregner kvadratet av pikselverdiene i et raster.",
		squareDesc: "Square-funksjonen beregner kvadratet av pikselverdiene i et raster.",
		statisticsHistogramName: "Statistics og Histogram",
		statisticsHistogramSnip: "Definer eller knytt til statistikk og histogram.",
		statisticsHistogramDesc: "Statistics og Histogram-funksjonen brukes til å definere statistikken og histogrammet til et raster. Du kan sette inn denne funksjonen på slutten av funksjonskjeden for å beskrive statistikken og histogrammet til en rasterfunksjonsmal (RFT). Dette kan være nødvendig for å kontrollere standardvisningen av behandlingsresultatet, særlig når du definerer en funksjonskjede som inneholder mange funksjoner.<div><br/>Du kan definere statistikk ved å skrive inn verdiene eller importere fra et rasterdatasett eller en XML-fil. Histogrammer kan bare defineres ved å importere en fil.</div>",
		statisticsName: "Statistikk",
		statisticsSnip: "Beregner fokalstatistikk for hver piksel av et bilde basert på et definert fokalnabolag.",
		statisticsDesc: "Statistics-funksjonen beregner fokalstatistikk for hver piksel av et bilde basert på et definert fokalnabolag.<div><br/>Statistics-funksjonen kan brukes til å fylle manglende linjer i et bilde. Manglende linjer skyldes ofte problemer i sensoren, slik at data ikke samles inn. Dette har skjedd i sensorer som Landsat 7s Enhanced Thematic Mapper Plus (ETM+). Disse manglende dataene skaper problemer for analysen og også når du ser på bildene. Det er lite som kan gjøres når du bruker bildene til analyse, men hvis det var et overlappende bilde, kan det brukes i stedet for det manglende innholdet. Det samme kan gjøres hvis bildene brukes til visualisering. Det finnes imidlertid ikke alltid noe ekstra bilde for å fylle ut det manglende innholdet, så det må utledes fra eksisterende data.</div>",
		streamLinkName: "Stream Link",
		streamLinkSnip: "Tilordner unike verdier til deler av et linjært rasternettverk mellom krysningspunkter.",
		streamLinkDesc: "Den globale Stream Link-funksjonen tilordner unike verdier til deler av et linjært rasternettverk mellom krysningspunkter.<div><br/>Koblinger er seksjonene i en strømkanal som forbinder to påfølgende knutepunkter, et knutepunkt og utløpet, eller et knutepunkt og dreneringsdelingen. I hydrologi kalles disse strømsegmentene strekninger. Et knutepunkt er relatert til et utløpspunkt og bidrar til å avgrense et vannskille eller nedbørsfelt.</div>",
		stretchName: "Strekk",
		stretchSnip: "Forbedrer et bilde ved å justere rekkevidden av verdiene som vises. Dette endrer ikke de underliggende pikselverdiene. Hvis en piksel har en verdi utenfor det angitte området, vises det som minimums- eller maksimumsverdi.",
		stretchDesc: "Stretch-funksjonen forbedrer et bilde ved å endre egenskaper som lysstyrke, kontrast og gamma gjennom flere strekktyper. Denne funksjonen bruker statistikk fra rasterne i mosaikkdatasettet. Hvis du bruker denne funksjonen, må du derfor sørge for at statistikk er beregnet.<div><br/>Strekkingstypen definerer en histogramstrekking som vil bli brukt på rastrene for å forbedre visningen av dem. Strekking forbedrer utseendet på dataene ved å spre pikselverdiene langs et histogram fra minimums- og maksimumverdiene som er definert av bitdybden. </div>",
		swathName: "Swath",
		swathSnip: "Interpolerer fra uregelmessige rutenett eller swath-data.",
		swathDesc: "Enkelte netCDF- eller HDF-datasett lagrer geolokasjonen som uregelmessig adskilte matriser. Når du legger til disse datasettene i et mosaikkdatasett, tar swath-funksjonen uregelmessig rutenettdata og omfordeler dem slik at hver piksel er av lik størrelse og er firkantet.<div><br/>Når du legger til variabler fra netCDF eller HDF til et mosaikkdatasett, vil det automatisk verifisere om dataene er ordnet regelmessig. Hvis de ikke er det, brukes swath-funksjonen automatisk til å konvertere det uregelmessige rasteret til punkter og deretter til et regelmessig rutenettbasert raster. Du kan endre interpoleringsmetoden og cellestørrelsen som brukes i swath–funksjonen. For rasterdata med regelmessige mellomrom vil det ikke bli bruk noen interpolering, og dataene vil bli lest som det er.</div>",
		tanHName: "TanH",
		tanHSnip: "Beregner hyperbolsk tangent for cellene i et raster.",
		tanHDesc: "Funksjonen beregner hyperbolsk tangent for pikslene i et raster.",
		tanName: "Tan",
		tanSnip: "Beregner tangent for cellene i et raster.",
		tanDesc: "Funksjonen beregner tangent for pikslene i et raster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Beregner nivåer av vegetasjon, våthet og lysstyrke. Denne teknikken er avhengig av koeffisienter som må beregnes spesifikt for en sensor.",
		tasseledCapDesc: "Tasseled Cap (Kauth-Thomas)-transformasjonen er laget for å analysere og kartlegge vegetasjonsfenomenologi og byutviklingsendringer som oppdages av diverse satellittsensorsystemer. Den er kjent som Tasseled Cap-transformasjonen på grunn av formen på den grafiske fordelingen av data. Transformasjonen ga en begrunnelse for mønstrene man finner i Landsat MSS-data for landbruksfelt som en funksjon av avlingenes livssyklus. Etter hvert som avlinger vokser fra frø til moden plante, er det en netto økning i nærinfrarød og reduksjon i rød refleksjon basert på jordfarge.<div><br/>Anvendelsen av denne transformasjonen er utvidet fra overvåking av avlinger til analyse og kartlegging av vegetasjon for en rekke bruksområder som skogbruk, industriell vegetasjonsforvaltning, kartlegging og forvaltning av økosystem, registrere og overvåke karbonfangst og -lagring, byutvikling med mer. Den har også utvidet seg fra å støtte Landsat MSS til å inkludere andre populære satellittsystemer som Landsat TM, Landsat ETM +, Landsat 8, IKONOS, QuickBird, WorldView-2 og RapidEye multispectral-sensorer.</div>",
		timesName: "ganger",
		timesSnip: "Multipliserer verdiene til to raster på piksel for piksel-basis.",
		timesDesc: "Times-funksjonen multipliserer verdiene til to raster på piksel for piksel-basis.",
		transposeBitsName: "Transpose Bits",
		transposeBitsSnip: "Pakker ut bitene av inndataspikselet og kartlegger dem til spesifiserte biter i utdatapikselet. Formålet med denne funksjonen er å manipulere biter fra et par inndata, som for eksempel Landsat 8-kvalitetsbåndprodukter.",
		transposeBitsDesc: "Transpose Bit-funksjonen pakker ut bitene av inndataspikselet og tilordner dem til spesifiserte biter i utdatapikselet. Formålet med denne funksjonen er å manipulere biter fra et par inndata, som for eksempel Landsat 8-kvalitetsbåndprodukter.",
		unitConversionName: "Unit Conversion",
		unitConversionSnip: "Endrer verdier fra en måleenhet til en annen.",
		unitConversionDesc: "Denne funksjonen konverterer piksler fra en enhet til en annen. Den støtter konvertering av avstand, hastighet og temperatur.",
		vectorFieldName: "Vektorfelt",
		vectorFieldSnip: "Viser datasett med både omfang (u) og retning (v) som piler, der omfanget er representert av pilens størrelsen og retningen er representert ved pilens vinkel.",
		vectorFieldDesc: "Vector Field-funksjonen brukes til å sammensette og konvertere to raster til et tobåndsraster som enten er datatype Magnitude-Direction eller datatype U-V.<div><br/>U-verdien kalles noen ganger sonalhastighet, og V-verdien kalles noen ganger meridionalhastighet.</div>",
		viewshed2Name: "Synsfelt",
		viewshed2Snip: "Finner ved hjelp av geodetiske metoder hvilken del av rasteroverflaten som er synlig for et sett av observatører.",
		viewshed2Desc: "Viewshed-funksjonen finner ved hjelp av geodetiske metoder hvilken del av rasteroverflaten som er synlig for et sett av observatører.<div><br/>Synligheten for hvert pikselsenter bestemmes av en siktlinjetest mellom målet og hver observatør. Hvis en observatør kan se målet ved pikselsenteret, betraktes pikselet som synlig. Dette verktøyet vurderer alltid jordens krumning når synligheten bestemmes.</div>",
		watershedName: "Vannskille",
		watershedSnip: "Bestemmer tilførselsområdet over et sett med celler i et raster.",
		watershedDesc: "Den globale Watershed-funskjonen bestemmer tilførselsområdet over et sett med piksler i et raster. Vannskiller er avgrenset fra et strømningsretningraster som identifiserer strømningsretningen fra hver piksel.",
		weightedOverlayName: "Weighted Overlay",
		weightedOverlaySnip: "Legger over flere raster ved hjelp av en felles måleskala og vekt hver etter dens betydning.",
		weightedOverlayDesc: "Denne funksjonen lar deg legge flere raster med en felles måleskala oppå hverandre, og vekte hvert raster etter dets betydning.",
		weightedSumName: "Weighted Sum",
		weightedSumSnip: "Vekter og legger til en rekke med raster på en celle-til-celle basis.",
		weightedSumDesc: "Weighted Sum-funksjonen lar deg legge over flere raster, multiplisere hvert med sin oppgitte vekt og summere dem sammen.",
		windchillName: "Vindfaktor",
		windchillSnip: "Kombinerer omgivelsestemperatur og vindhastighet for å beregne vindfaktoren.",
		windchillDesc: "Wind Chill-funksjonen er nyttig for å identifisere farlige vinterforhold som, avhengig av eksponeringstiden for elementene, kan resultere i forfrysninger eller hypotermi. Vindfaktor er en måte å måle hvor kald en person føler seg når vinden tas i betraktning, ved allerede kalde temperaturer. Jo raskere vindhastigheten er, desto raskere vil kroppen miste varme og jo kaldere vil folk føle seg.",
		zonalRemapName: "Zonal Remap",
		zonalRemapSnip: "Omform piksler i et raster basert på soner som er definert i et annet raster og sonavhengig verditilordning som er definert i en tabell.",
		zonalRemapDesc: "Med denne funksjonen kan du omforme piksler i et raster basert på soner som er definert i et annen raster og sonavhengig verditilordning som er definert i en tabell.",
		zonalStatisticsName: "Zonal Statistics",
		zonalStatisticsSnip: "Beregner statistikk over verdier av et raster innenfor sonene til et annet datasett.",
		zonalStatisticsDesc: "Funksjonen beregner statistikk over verdier av et raster innenfor sonene til et annet datasett. En sone er definert som alle områder i inndataene som har samme verdi. Disse områdene behøver ikke være sammenhengende. Når sonen og verdi-inndatarasteret begge er raster med samme oppløsning, blir de brukt direkte. Hvis oppløsningene er forskjellige, brukes en intern resampling for å gjøre oppløsningene samsvarende før soneoperasjonen utføres.",
		flowLengthName: "Flow Length",
		flowLengthSnip: "Beregner oppstrøms- eller nedstrømsavstand eller vektet avstand langs strømningsbanen for hver celle.",
		flowLengthDesc: "Dette er en global rasterfunksjon. Denne funksjonen oppretter et rasterlag med oppstrøms- eller nedstrømsavstand eller vektet avstand langs strømningsbanen for hver celle.<div><br/>Flow Length-funksjonen brukes primært til å beregne lengden på lengste strømningsvei innenfor et gitt basseng. Målingen brukes ofte til å beregne konsentrasjonstiden for et basseng. Dette gjøres ved å bruke Oppstrøms-alternativet. Funksjonen kan også brukes til å opprette avstandsdiagrammer over hypotetisk nedbør og avrenningshendelser ved hjelp av vektrasteret som en impedans for nedadgående bevegelse.</div>",
		streamOrderName: "Strømrekkefølge",
		streamOrderSnip: "Tilordner en numerisk rekkefølge til segmenter i et raster som representerer forgreninger i et lineært nettverk.",
		streamOrderDesc: "Dette er en global rasterfunksjon. Denne funksjonen oppretter et rasterlag som tilordner en numerisk rekkefølge til segmenter i et raster som representerer forgreninger i et lineært nettverk.<div><br/>Utdataene fra Stream Order-funksjonen vil ha høyere kvalitet hvis inndatalaget for strømningsraster og inndatalaget for strømningsretningsraster er avledet fra samme overflate. Hvis strømrasteret er avledet av et rastrert strømdatasett, kan det hende utdataene ikke kan brukes fordi retningen celle for celler ikke samsvarer med plasseringen av strømcellene. Resultatene av funksjonen Strømningsakkumulering kan brukes til å lage et rasterstrømningnettverk ved å bruke en terskelverdi til å velge celler med høy akkumulert strømning. For eksempel brukes celler som har mer enn 100 celler som flyter inn i dem, til å definere strømnettverket. Bruk funksjonene Betinget eller Angi null til å opprette et strømningsnettverksraster der strømningsakkumuleringsverdier på 100 eller over går til et raster og resten sendes til bakgrunnen (NoData). Det resulterende strømnettverket kan brukes i funksjonen Strømrekkefølge. Funksjonen støtter bare et rasterlag med D8-strømretning som inndata. D8-strømningsretninger kan opprettes ved hjelp av funksjonen Strømningsretning og kjøres med standard strømningsretning D8.</div>",
		snapPourPointName: "Fest utløpspunkt",
		snapPourPointSnip: "Fester utløpspunkt til cellen med høyest strømningsakkumulering innenfor en gitt avstand",
		snapPourPointDesc: "Dette er en global rasterfunksjon. Denne funksjonen fester utløpspunkter til cellen med høyest strømningsakkumulering innenfor en angitt avstand.<div><br/>Funksjonen Fest utløpspunkt brukes til å sikre utvalget av punkt med høy akkumulert strømning ved avgrensing av nedslagsfelt ved hjelp av Vannskille-funksjonen. Fest utløpspunkt søker etter cellen med høyest strømningsakkumulering innenfor en snappavstand rundt de angitte utløpspunktene, og flytter utløpspunktet til denne lokasjonen. Utdata er et heltalls rasterlag når de opprinnelige utløpspunktlokasjonene er festet til lokasjonene for høyest akkumulert flyt.</div>",
		sinkName: "Forsenkning",
		sinkSnip: "Oppretter et raster som identifiserer alle forsenkninger eller områder med drenering",
		sinkDesc: "Dette er en global rasterfunksjon. Denne funksjonen oppretter et rasterlag som identifiserer alle forsenkninger eller områder med drenering. En forsenkning er en celle eller et sett med spatialt forbundne celler med en strømningsretning som ikke kan tilordnes en av de åtte verdiene i en strømningsretningsraster. Dette kan inntreffe når alle naboceller er høyere enn behandlingscellen, eller når to celler flyter inn i hverandre og danner en tocellers sløyfe.<div><br/>Forsenkning-funksjonen støtter kun et rasterlag med D8-strømningsretning som inndata. D8-strømningsretninger kan opprettes ved hjelp av funksjonen Strømningsretning og kjøres med standard strømningsretning D8. Utdataene for Forsenkning-funksjonen er et heltallsraster der hver forsenkning er tilordnet en unik verdi. Disse unike verdiene ligger i området fra én til totalt antall forsenkninger. Hvis for eksempel samlet antall forsenkninger er 1000, er de unike verdiene i området 1 til 1000.</div>",
		aggregateName: "Summer",
		aggregateSnip: "Genererer en versjon av et raster med redusert oppløsning.",
		aggregateDesc: "Aggregeringsfunksjonen sampler et inndataraster på nytt med en grovere oppløsning basert på en angitt aggregeringsstrategi. Hver utdatacelle inneholder sum, minimum, maksimum, gjennomsnitt eller median for utdatacellene som er innenfor utstrekningen av den cellen.<div><br/>Du kan angi faktoren som cellestørrelsen for inndatarasteret skal multipliseres med. For eksempel vil en cellefaktorverdi på tre resultere i en utdatacellestørrelse som er tre ganger større enn i inndatarasteret. Du kan definere hvordan utstrekningen for utdata skal håndteres hvis antall rader eller kolonner i inndataene ikke er en eksakt multippel av cellefaktoren. Som standard utvides øvre og høyre grense for å dekke en større romlig utstrekning enn den i inndatarasteret for å sikre at alle inndataceller behandles. Alternativt kan øvre og høyre grense minskes for å dekke en mindre romlig utstrekning slik at antallet rader og kolonner som behandles, er en eksakt multippel av cellefaktoren. Du kan definere hvordan NoData-celler skal håndteres i den aggregerte beregningen. Standardmekanismen er at NoData-inndataceller som faller innenfor den romlige utstrekningen av en større celle i utdatarasteret, ignoreres når verdien av utdatacellen bestemmes. Alternativt kan du spesifisere at hvis det bare er en enkelt NoData-inndatacelle innenfor den romlige utstrekningen for en utdatacelle, blir denne cellen en NoData-celle i utdatarasteret.</div>",
		ccdcName: "CCDC-analyse",
		ccdcSnip: "Bruker algoritmen for kontinuerlig endringsdeteksjon og klassifisering (CCDC) til å evaluerer endringer i pikselverdier over tid og generere modellresultater.",
		ccdcDesc: "CCDC-analysefunksjonen bruker algoritmen for kontinuerlig endringsdeteksjon og klassifisering (CCDC) til å evaluerer endringer i pikselverdier over tid og generere et flerdimensjonalt raster som inneholder modellresultatene. Dette støttes kun sammen med funksjonen Detect Change Using Change Analysis i en rasterfunksjonsmal. Du lager rasterutdata ved å koble CCDC Analysis-funksjonen til funksjonen Detect Change Using Change Analysis, lagre som en rasterfunksjonsmal og kjøre rasteranalyse med funksjonsmalen.<div><br/>Denne funksjonen bruker algoritmen for kontinuerlig endringsdeteksjon og klassifisering (CCDC) til å evaluere endringer i pikselverdier over tid for en stabel med bilder. I en tidsserie med optiske bilder eller bildederivater (for eksempel DNVI), kan pikselverdiene variere av flere grunner: 1. Årstidsendringer – Pikselverdiendringer reflekterer endringer i vegetasjon som skyldes årstidsvariasjoner i temperatur og nedbør. PÅ den nordlige halvkule forventer vi for eksempel å se høyere tetthet av grønn vegetasjon om sommeren sammenlignet med vinteren. 2. Gradvis endring – Pikselverdiendringer gjenspeiler tendenser i vegetasjon eller overflatevann som skyldes klimavariasjon eller langvarig arealforvaltningspraksis. For eksempel kan bar jord øke gradvis i areal som følge av langvarig reduksjon i nedbør. 3. Plutselig endring – Pikselverdiendringer gjenspeiler endringer i arealdekke som oppstår plutselig som følge av avskoging, byutvikling, naturkatastrofer og så videre. CCDC-algoritmen identifiserer alle disse tre endringstypene og hovedformålet er å identifisere plutselige endringer. Harmonisk regresjons- og trendmodeller tilpasses til dataene for å estimere årstidsbasert og gradvis endring, og plutselige avvik fra trendmodellene er indikasjoner på plutselig endring.<div><br/>CCDC-algoritmen ble opprinnelig utviklet for Landsat TM, Landsat ETM+ og Landsat OLI-data for overflatereflektans og stråletemperatur. Funksjonen Detect Change Using Change Analysis sammen med denne funksjonen vil imidlertid oppdage endring for bilder med flere bånd fra sensorer som støttes, samt bildederivater med ett bånd, som båndindekser. Du kan for eksempel utføre kontinuerlig endringsdeteksjon på et NDVI-raster (Normalize Difference Vegetation Index) fordi plutselige endringer i NDVI kan være en indikasjon på avskoging.</div>",
		computeChangeName: "Compute Change",
		computeChangeSnip: "Beregner differansen mellom to kategoriske eller kontinuerlige rasterdatasett.",
		computeChangeDesc: "Compute Change-funksjonen kan brukes til å spesifisere forskjellene mellom to klassifiserte rastre for analyse av endringer i arealdekke. Den kan også brukes til å undersøke endringer mellom to kontinuerlige enkeltbåndrastre, som høyde, temperatur, trekronedekning osv.",
		detectChangeName: "Detect Change Using Change Analysis",
		detectChangeSnip: "Genererer et rasterlag som inneholder informasjon om pikselendringer, ved å bruke det resulterende endringsanalyserasteret.",
		detectChangeDesc: "<div>Funksjonen Registrer endring ved hjelp av endringsanalyseraster genererer et rasterlag som inneholder informasjon om datoen for pikselendringer, ved å bruke endringsanalyserasteret. Endringsanalyserasteret må genereres av verktøyet Analyser endringer ved hjelp av CCDC eller verktøyet Analyser endringer ved hjelp av LandTrendr eller rasterfunksjonen CCDC-analyse eller rasterfunksjonen LandTrendr-analyse.</div><br><div>Denne rasterfunksjonen kan kombineres med rasterfunksjonen CCDC-analyse eller rasterfunksjonen LandTrendr-analyse i en rasterfunksjonsmal. For å produsere et permanent rasterresultat må CCDC-analyse- eller LandTrendr-analysefunksjonen kobles til funksjonen Registrer endring ved hjelp av endringsanalyseraster lagres som en rasterfunksjonsmal og kjøres som rasteranalyse med malen.</div><br><div>Parameteren <strong>Endringstype</strong> angir informasjonen som genereres. Informasjon trekkes ut fra endringsanalyserasteret. Når du kjører denne funksjonen på resultatet fra CCDC-funksjonen/verktøyet, kan du velge mellom følgende alternativer:</div><ul><li><strong>Tidspunkt for siste endring</strong> – Siste dato og klokkeslett da en piksel ble flagget som endret.</li><li><strong>Tidspunkt for tidligste endring</strong> –Tidligste dato og klokkeslett da en piksel ble flagget som endret.</li><li><strong>Tidspunkt for største endring</strong> – Dato og klokkeslett da den beregnede endringen hadde størst betydning for en piksel.</li><li> <strong>Antall endringer</strong> – Det totale antallet ganger pikselen ble endret.</li></ul><div>Når denne funksjonen kjøres på resultatet av LandTrendr-funksjonen/verktøyet, er følgende tilleggsalternativer tilgjengelige:</div><ul><li><strong>Tidspunkt for lengste endring</strong> – Datoen da en piksel ble flagget som endret, ved begynnelsen eller slutten av den lengste endringsperioden.</li><li><strong>Tidspunkt for korteste endring</strong> – Datoen da en piksel ble flagget som endret, ved begynnelsen eller slutten av den korteste endringsperioden.</li><li><strong>Tidspunkt for raskeste endring</strong> – Datoen da en piksel ble flagget som endret, ved begynnelsen eller slutten av den raskeste endringsperioden.</li><li><strong>Tidspunkt for langsomste endring</strong> – Datoen da en piksel ble flagget som endret, ved begynnelsen eller slutten av den langsomste endringsperioden.</li></ul><div>Det resulterende rasteret er et flerbåndsraster der hvert bånd inneholder endringsinformasjon som avhenger av hvilken endringstype som er valgt og det maksimale antallet endringer som er angitt. Hvis for eksempel <strong>Endringstype</strong> er satt til <strong>Tidspunkt for tidligste endring</strong> og <strong>Maksimalt antall endringer</strong> er satt til 2, beregner funksjonen de to tidligste datoene da endring fant sted i løpet av tidsserien for hver enkelt piksel. Resultatet er et raster der det første båndet inneholder datoene for tidligste endring per piksel, og det andre båndet inneholder datoene for nest tidligste endring per piksel.</div><br><div>Når denne funksjonen brukes på utdataene fra LandTrendr-verktøyene, kan du velge om du vil trekke ut datoen som markerer begynnelsen på en endring eller slutten på en endring, ved å bruke parameteren <strong>Segmentdato</strong>. Hvis du for eksempel vil forstå hvordan den nyligste endringen i tidsserien startet, kan du sette <strong>Endringstype</strong> til <strong>Tidspunkt for siste endring</strong> og <strong>Segmentdato</strong> til <strong>Segmentets begynnelse</strong>.</div><br><div>Bruk følgende filtreringsparametere for å trekke ut mer spesifikke endringsdatoer fra endringsanalyserasteret:</div><ul><li><strong>Filtrer etter år</strong> –Identifiser endringer som forekom i løpet av en bestemt tidsperiode, for eksempel hvis du ser etter endringer som har funnet sted i et landskap i løpet av fem år med tørke.</li><li><strong>Filtrer etter varighet</strong> – Identifiser endringer som har funnet sted i løpet av et gitt antall år, for eksempel hvis du bare ser etter plutselige endringer som har funnet sted i løpet av ett eller to år. Du kan beregne varigheten du er interessert i, ved å bruke formelen <strong>avslutningsår – startår +1</strong>. Opphold i tidsserien blir inkludert.</li><li><strong>Filtrer etter størrelse</strong> – Identifiser endringer av en viss størrelse, for eksempel hvis du bare ser etter store endringer i vegetasjonsindeksen NDVI (Normalized Difference Vegetation Index). Størrelse er en absolutt verdi, så minimums- og maksimumsverdier kan ikke være negative. Bruk parameteren <strong>Endringsretning</strong> hvis du vil angi retningsendringer.</li></ul>",
		distanceAccumulationName: "Distance Accumulation",
		distanceAccumulationSnip: "Beregner akkumulert avstand for hver celle til kildene og tillater rettlinjet avstand kostnadsavstand, reell overflateavstand samt vertikale og horisontale kostnadsfaktorer.",
		distanceAccumulationDesc: "Distance Accumulation beregner avstanden til hver lokasjon i studieområdet til nærmeste, eller rimeligste, kilde. Dersom kun kildene oppgis som inndata, så beregnes det en rettlinjet avstand til hver lokasjon i studieområdet. Hvis både kilder og hindringer brukes som inndata, beregner Distance Accumulation-funksjonen den rettlinjede avstanden forbi hindringer. For både kilderasteret og hindringsrasteret skal bakgrunnsverdien være NoData, mens kilder og hindringer representeres med gyldige celleverdier. Gyldige celleverdier omfatter null. <div><br/>Når et overflateraster brukes som inndata, beregnes den faktiske overflateavstanden mellom cellene. Hvis du vil utføre kostnadsanalyse ved hjelp av Distance Accumulation-funksjonen, må du ha en kostnadsoverflate. Hvis det er angitt en kostnadsoverflate, blir resultatet et raster med akkumulert kostnadsavstand. Når horisontale og vertikale faktorer er oppgitt, blir retning vurdert etter hvert som kostnad akkumuleres. Det er fire kildekarakteristikker som kan brukes. Karakteristikkene som kan være for kildene, eller de reisende fra kildene, styres av bestemte parametere: 1. Første akkumulering: angir den opprinnelige kostnaden før bevegelsen begynner. 2. Maksimal akkumulering: angir hvor stor kostnad en kilde kan akkumulere før den når grensen. 3. Multiplikator som skal brukes på kostnader: angir reisemåten eller størrelsen ved kilden. 4. Reiseretning: identifiserer om den reisende starter ved en kilde og beveger seg til ikke-kilde-lokasjoner, eller om den starter på ikke-kilde-lokasjoner og beveger seg tilbake til en kilde.<div><br/>Som standard er resultatet av Distance Accumulation-funksjonen et enkeltbånd, som er rasteret for avstandsakkumulering. Det kan også opprettes et bånd til, båndet for tilbakeretning. Dette båndet viser hvilken retning man må ta for å komme til kilden med lavest kostnad fra hver lokasjon i studieområdet. Begge båndene er nødvendige for å finne optimale ruter innenfor studieområdet. For å generere en rute bruker du først Extract Bands-funksjonen til å trekke ut rasteret for avstandsakkumulering og rasteret for tilbakeretning. Bruke disse lagene som inndata for Kostnadsrute-funksjonen. Med denne funksjonen bruker du rasteret for avstandsakkumulering som kostnad-/avstandsraster og rasteret for tilbakeretning som Cost Back Link-inndataraster.</div>",
		distanceAllocationName: "Distance Allocation",
		distanceAllocationSnip: "Beregner avstandstildeling for hver celle til de oppgitte kildene basert på rettlinjet avstand, kostnadsavstand, reell overflateavstand, samt vertikale og horisontale kostnadsfaktorer.",
		distanceAllocationDesc: "Distance Allocation beregner hvilken kilde hver lokasjon i studieområdet er tildelt til. Hvis kun kildene oppgis som inndata, blir lokasjonene tildelt ved hjelp av en rettlinjet avstand til den nærmeste kilden. Hvis både kilder og hindringer brukes som inndata, beregner Distance Allocation-funksjonen rettlinjet avstand rundt hindringer for å fastsette hvilken kilde en lokasjon blir tildelt til. For både kilderasteret og hindringsrasteret skal bakgrunnsverdien være NoData, mens kilder og hindringer representeres med gyldige celleverdier. Gyldige celleverdier omfatter null.<div><br/>Hvis du vil utføre kostnadsanalyse ved hjelp av Distance Allocation-funksjonen, må du ha en kostnadsoverflate. Hvis en kostnadsoverflate oppgis, blir resultatet et tildelingsraster basert på akkumulert kostnad og ikke på rettlinjet avstand. Når horisontale og vertikale faktorer er oppgitt, blir retning vurdert etter hvert som kostnad akkumuleres. Når et overflateraster brukes som inndata, blir den faktiske overflateavstanden som dekkes når man beveger seg mellom cellene, beregnet ved fastsettelse av tildeling. Det er fire kildekarakteristikker som kan brukes. Karakteristikkene som kan være for kildene, eller de reisende fra kildene, styres av bestemte parametere: 1. Første akkumulering: angir den opprinnelige kostnaden før bevegelsen begynner. 2. Maksimal akkumulering: angir hvor stor kostnad en kilde kan akkumulere før den når grensen. 3. Multiplikator som skal brukes på kostnader: angir reisemåten eller størrelsen ved kilden. 4. Reiseretning: identifiserer om den reisende starter ved en kilde og beveger seg til ikke-kilde-lokasjoner, eller om den starter på ikke-kilde-lokasjoner og beveger seg tilbake til en kilde.<div><br/>Som standard er resultatet av Distance Allocation-funksjonen et enkeltbånd, som er rasteret for avstandstildeling. Hvis det merkes av for det boolske alternativet Generer kilderad og -kolonne som ekstra bånd i utdata, gir det et flerbåndsraster som består av tre bånd. Det første båndet er båndet for avstandstildeling, det andre båndet inneholder en radindeks, og det tredje båndet inneholder en kolonneindeks. Disse indeksene identifiserer lokasjonen for kildecellen som er minste akkumulerte kostnadsavstand fra. Kilderadindeksen og kildekolonneindeksen kan brukes sammen til å kartlegge intensitet. Hvis du foretar spørring for en lokasjon i studieområdet på tvers av bånd to og tre, får du vite raden og kolonnen for kilden med lavest kostnad for denne lokasjonen.</div>",
		eucBackDirectionName: "Euclidean Back Direction",
		eucBackDirectionSnip: "Beregner retningen i grader for hver celle til nabocellen langs den korteste veien tilbake til nærmeste kilde og samtidig som hindringer unngås.",
		eucBackDirectionDesc: "Funksjonen Euclidean Back Direction resulterer i et kontinuerlig flytpunktraster som representerer retningen i grader tilbake til nærmeste kilde samtidig som hindringer unngås, hvis hindringer er oppgitt.<div><br/>Inndataene for funksjonen Euclidean Back Direction er kilden som retningen beregnes til. Et raster som representerer hindringer innenfor studieområdet, er valgfritt inndataalternativ. Bakgrunnsverdien skal være NoData for både kilderasteret og hindringrasteret, mens kildene og hindringene representeres med gyldige verdier. Gyldige celleverdier omfatter null. Som standard vil beregningen behandle til den kombinerte utstrekningen for kilder og hindringer, pluss to rader og kolonner. Hvis analyse kun er nødvendig innenfor en angitt avstand fra kildene, kan parameteren Maximum Distance brukes. Euclidean Back Direction støtter beregning med både en planmetode og en geodetisk metode. Med planmetoden foretas beregningen på et projisert flatt plan ved hjelp av et 2D kartesisk koordinatsystem. Med den geodetiske metoden foretas beregningen på ellipsoiden, noe som betyr at resultatene ikke endres uavhengig av inndata- eller utdataprojisering.<div><br/>Resultatet av funksjonen Euclidean Back Direction kan brukes sammen med resultatet fra funksjonen Euclidean Distance til å fastsette de korteste rutene fra lokasjoner innenfor studieområdet tilbake til kilden. Resultatene fra Euclidean Back Direction og Euclidean Distance brukes begge sammen med destinasjoner i Cost Path-funksjonen for å generere de korteste rutene.</div>",
		expandName: "Utvid",
		expandSnip: "Utvider valgte soner i et raster etter soner med et angitt antall celler.",
		expandDesc: "Med den globale funksjonen for utvidelse kan du generalisere, eller forenkle, rastrene ved å gjøre bestemte soner større. Du kan også bestemme omfanget av generaliseringen.<div><br/>Sonene du velger vil øke i størrelse ved at de utvides inn i andre soner. De valgte soneverdiene kan vises som soner i forgrunnen, mens de andre verdiene beholdes som soner i bakgrunnen. Sonene i forgrunnen kan utvides inn i sonene i bakgrunnen.<div><br/>Omfanget av generaliseringen kan styres med parameteren Antall celler. Denne verdien er som standard 1, noe som betyr at de valgte sonene utvides med mengden tilsvarende én celles størrelse. Du kan angi en større verdi for denne parameteren for å øke graden av generalisering. Dette blir som å kjøre verktøyet like mange ganger som angitt tall, med resultatene av forrige kjøring som inndata i etterfølgende gjentakelse.</div>",
		trendAnalysisName: "Generate Trend",
		trendAnalysisSnip: "Estimerer trenden for hver piksel langs en dimensjon for én eller flere variabler i et flerdimensjonalt raster.",
		trendAnalysisDesc: "<div>Denne funksjonen kan brukes til å plassere data langs en lineær, harmonisk eller polynom trendlinje, eller den kan brukes til å utføre trenddeteksjon ved hjelp av en Mann-Kendall- eller Seasonal Kendall-test.</div><br><div>Det resulterende trendrasteret som genereres med denne funksjonen, brukes som inndata til funksjonen <strong>Forutsi ved bruk av trend</strong>.</div><br><div>Mann-Kendall-og Seasonal-Kendall-testene brukes til å bestemme om det er en monoton trend i dataene. De er ikke-parametriske, det vil si at de ikke forutsetter en bestemt distribusjon av data. Mann-Kendall-testen vurderer ikke seriell korrelasjon eller årstidseffekter. Hvis dataene er årstidsbetingede, er Seasonal-Kendall-testen bedre egnet.</div><br><div>Hvis verktøyet brukes til å utføre enten en Mann-Kendall- eller en Seasonal-Kendall-test, blir resultatet et raster med fem bånd, som følger:</div><ul><li>Bånd 1 = Sens helling</li><li>Bånd 2 = P-verdi</li><li>Bånd 3 = Mann-Kendall-skår (S)</li><li>Bånd 4 = S-varians</li><li>Bånd 4 = S-varians</li><li>Bånd 5 = Z-skår</li></ul><div>Resultatene fra Mann-Kendall- eller Seasonal-Kendall-testen kan brukes til å bestemme hvilke piksler i den flerdimensjonale tidsserien som har en statistisk signifikant trend. Denne informasjonen kan du bruke sammen med den lineære, harmoniske eller polynome trendanalysen for å trekke ut signifikante trender i tidsserien. Du kan generere en maske som inkluderer piksler med signifikante p-verdier, bruke masken på det flerdimensjonale rasteret og bruke dette maskerte flerdimensjonale rasteret som inndata i verktøyet for å utføre lineær, harmonisk eller polynom trendanalyse.</div><br><div>Det er tre trendlinjealternativer for å tilpasse en trend til variabelverdiene langs en dimensjon: lineær, polynom og harmonisk.</div><br><div>For lineær trendanalyse er resultatet et raster med tre bånd, som følger:</div><ul><li>Bånd 1 = Helling</li><li>Bånd 2 = Avskjæring</li><li>Bånd 3 = Kvadratrot av gjennomsnitt (RMSE, Root Mean Square Error) eller feilen rundt linjen med best tilpasning</li></ul><div>For polynom trendanalyse avhenger det resulterende antallet bånd av polynomgraden. Tilpasning av andregradspolynomer produserer et raster med fire bånd, som følger:</div><ul><li>Bånd 1 = Polynom_2</li><li>Bånd 2 = Polynom_1</li><li>Bånd 3 = Polynom_0</li><li>Bånd 4 = RMSE</li></ul><div>Tilpasning av tredjegradspolynomer produserer et raster med fem bånd, som følger:</div><ul><li>Bånd 1 = Polynom_3</li><li>Bånd 2 = Polynom_2</li><li>Bånd 3 = Polynoml_1</li><li>Bånd 4 = Polynom_0</li><li>Bånd 5 = RMSE</li></ul><div>For harmonisk trendanalyse avhenger det resulterende antallet bånd av den harmoniske frekvensen. Når frekvensen er satt til 1, blir resultatet et raster med fem bånd, som følger:</div><ul><li>Bånd 1 = Helling</li><li>Bånd 2 = Avskjæring</li><li>Bånd 3 = Harmonisk_sin1</li><li>Bånd 4 = Harmonisk_cos1</li><li>Bånd 5 = RMSE</li></ul><div>Når frekvensen er satt til 2, blir resultatet et raster med sju bånd, som følger:</div><ul><li>Bånd 1 = Helling</li><li>Bånd 2 = Avskjæring</li><li>Bånd 3 = Harmonisk_sin1</li><li>Bånd 4 = Harmonisk_cos1</li><li>Bånd 5 = Harmonisk_sin2</li><li>Bånd 6 = Harmonisk_cos2</li><li>Bånd 7 = RMSE</li></ul><div>Parameteren <strong>Lengde på syklus</strong> for harmonisk trendanalyse brukes til å angi antall og lengde på sykluser du venter å se i dataene dine i løpet av en dag eller et år. Hvis du for eksempel venter at dataene skal gjennomgå to variasjonssykluser i løpet av et år, er lengden på syklusen 182,5 dager eller 0,5 år. Hvis du har temperaturdata som er innhentet hver tredje time, og det er én variasjonssyklus per dag, er lengden på syklusen én dag.</div><br><div>Parameteren <strong>Frekvens</strong> for harmonisk trendanalyse brukes til å beskrive den harmoniske modellen som skal tilpasses dataene. Hvis frekvensen settes til 1, brukes en kombinasjon av linær og førstegrads harmonisk kurve for å passe til modellen. Hvis frekvensen settes til 2, brukes en kombinasjon av linær, førstegrads harmonisk kurve og andregrads harmonisk kurve for å passe til modellen. Hvis frekvensen er 3, brukes ytterligere en tredjegrads harmonisk kurve for å modellere dataene, og så videre.</div><br><div>Statistikk som viser modellens godhet, kan genereres som valgfrie utdata. Kvadratrot av gjennomsnitt (RMSE), determinantkoeffisient og p-verdien for trendhelling kan beregnes og vises med symboler. Opprett symboler for det resulterende trendrasterlaget ved hjelp av <strong>RGB</strong>-symbologi og angi statistikken som røde, grønne og blå bånd.</div><br>",
		spectralUnmixingName: "Linear Spectral Unmixing",
		spectralUnmixingSnip: "Utfører subpikselklassifisering, og beregner andelen av ulike arealdekketyper for individuelle piksler.",
		spectralUnmixingDesc: "Funksjonen Linear Spectral Unmixing beregner andelen for individuelle piksler som inneholder flere arealdekketyper. Genererer et lag med flere bånd, der hvert lag tilsvarer andelen av hver enkelt arealdekkeklasse. Du kan for eksempel bruke den til å utføre klassifisering av arealdekke på et multispektralt bilde for å identifisere fotosyntetisk vegetasjon, bar jord og død eller ikke-fotosyntetisk vegetasjon.<div><br/>Rekkefølgen for utdatarasteret med flere bånd følger rekkefølgen for spektralprofilen som er inndata. Antall klasser kan ikke overstige antall bånd i inndatarasteret. Du kan for eksempel ikke trekke ut informasjon om flere enn åtte klasser fra et raster med åtte bånd.</div>",
		multidimensionalFilterName: "Flerdimensjonale filtre",
		interpolateRasterByDimensionFunctionName: "Interpoler raster etter størrelse",
		interpolateRasterByDimensionFunctionSnip: "Interpolerer en flerdimensjonal raster ved angitte dimensjonsverdier ved hjelp av tilstøtende stykker.",
		interpolateRasterByDimensionFunctionDesc: "<p>Med denne funksjonen kan du estimere bildepunktverdier for et udefinert dimensjonsstykke i en flerdimensjonal raster. Hvis du for eksempel har et datasett som inneholder havtemperatur på overflatenivå og 100 meter under havflaten, og du vil beregne temperaturen til 50 meter under havoverflaten, kan du bruke denne funksjonen til å få et estimat på denne dybden ved hjelp av dimensjonsdefinisjonen etter verdier.</p><p>Du kan også redusere oppløsningen for et månedlig datasett til et daglig datasett ved hjelp av dimensjonsdefinisjonen Etter intervall og angi parameterverdien Trinn som 1 og Enhetsparameterverdien som Dager.</p><p>Bruke dimensjonsdefinisjonen Etter målraster til å estimere verdien for målrasteret.</p>",
		multidimensionalFilterSnip: "Oppretter et rasterlag fra et flerdimensjonalt rasterdatasett eller et flerdimensjonalt rasterlag ved å dele inn data langs definerte variabler og dimensjoner.",
		multidimensionalFilterDesc: "Det flerdimensjonale filteret oppretter et flerdimensjonalt rasterlag ved å filtrere og trekke ut et delsett av variabler fra et flerdimensjonalt raster. La oss for eksempel si at at du har et flerdimensjonalt datasett som inneholder 30 år med månedlige nedbørsdata og du kun vil hente ut data for Januar hvert år for å se hvordan nedbøren har endret seg for denne måneden.<div><br/>Bruk parameteren Dimension Definition til å dele inn dimensjoner ved hjelp av et intervall, en verdi eller en serie med verdier. Hvis du for eksempel har 10 år med salinitetsdata for sjøvann som er samlet inn månedlig og i intervaller på 2 meter ned til 500 meters dybde, kan du bruke de ulike alternativene for dimensjonsdefinisjon til følgende scenarioer. Scenario 1: Trekk ut salinitetsdata for måneden Januar over en tiårsperiode. Velg By Values, angi StdTime for Dimension og velg January for Values. Scenario 2: Del inn salinitetsdata over et dybdeområde fra 0 til 150 meter. Velg By Ranges, angi StdZ for Dimension og velg -150 for Minimum Value og 0 for Maximum Value. Scenario 3: Trekk ut salinitetsdata for de første ti dagene i hver Januar måned over en tiårsperiode. Velg By Iteration, angi StdTime for Dimension, angi start og slutt for gjentakelsesperioden i Start of first iteration og End of first iteration, velg 1 for Step og Years for Unit.</div>",
		multidimensionalRasterName: "Multidimensional Raster",
		multidimensionalRasterSnip: "Legger til flerdimensjonale data som et flerdimensjonalt rasterlag i et kart.",
		multidimensionalRasterDesc: "Funksjonen Multidimensional Raster legger til flerdimensjonale data som et flerdimensjonalt rasterlag i et kart. Denne funksjonen er nyttig når du utfører arbeidsflyter for rasteranalyse ved hjelp av en funksjonskjede.<div><br/>Støttede flerdimensjonale rasterdatasett inkluderer netCDF, GRIB, HDF og Esris CRF. Det er også støtte for flerdimensjonale mosaikkdatasett.</div>",
		optimalPathAsRasterName: "Optimal Path As Raster",
		optimalPathAsRasterSnip: "Beregner minste kostnadsruten fra en kilde til en destinasjon.",
		optimalPathAsRasterDesc: "Denne globale funksjonen produserer et utdataraster som registrerer den optimale ruten eller rutene fra valgte lokasjoner til nærmeste kildecelle som er definert innenfor den akkumulerte kostnadsoverflaten, når det gjelder kostnadsavstand.<div><br/>Én eller flere av de vektede kostnadsfunksjonene (Distance Accumulation eller Distance Allocation) må vanligvis kjøres før funksjonen Optimal Path As Raster for å opprette inndatarastre for avstandsakkumulering og tilbakeretning. Disse er obligatoriske inndatarasterlag for Optimal Path-funksjonen. Verdiene på den resulterende optimale ruten representerer antallet ruter ved en gitt lokasjon. I mange tilfeller følger ruten samme vei fra en kilde og går så i forskjellige retninger til ulike destinasjoner. Verdien én indikerer for eksempel at det bare er én optimal rute ved en gitt lokasjon, mens verdien fem betyr at det ved denne lokasjonen er fem optimale ruter som går gjennom denne cellen i studieområdet.<div><br/>Destinasjonsinndataene må være et rasterlag. Settet med destinasjonsceller består av alle cellene med gyldige verdier i inndatarasteret. Celler med NoData-verdier inkluderes ikke i settet. Verdien null regnes som en gyldig destinasjon. Verktøyene for uttrekking kan brukes til å opprette et destinasjonsraster. Hvis du har destinasjons- eller kildegeoobjekter, kan du konvertere dem til raster ved hjelp av funksjonen Rasterize Features. Bruk rasteret for avstandsakkumulering eller tilbakeretning som inndataraster i funksjonen for rastrering. Dette sikrer at geoobjektet rastreres ved hjelp av samme cellestørrelse, utstrekning og romlige referanse som de andre rastrene som går inn i funksjonen Optimal Path As Raster. Funksjonen Optimal Path As Raster kan også brukes til å avlede ruten med minste motstand nedover i en digital høydemodell (DEM). I dette tilfellet bruker du DEM for inndatarasteret for avstandsakkumulering og Flow Direction-funksjonen for rasteret for tilbakeretning.</div>",
		trendName: "Predict Using Trend",
		trendSnip: "Beregner et prognosebasert flerdimensjonalt rasterlag ved hjelp av det resulterende trendrasteret fra Generate Trend-funksjonen eller geoprosesseringsverktøyet Generate Trend Raster.",
		trendDesc: "Funksjonen Predict Using Trend beregner et forventet flerdimensjonalt rasterlag ved hjelp av det resulterende trendrasteret fra Generate Trend-funksjonen eller geoprosesseringsverktøyet Generate Trend Raster.",
		rasterCollectionName: "Process Raster Collection",
		rasterCollectionSnip: "Behandler hver inndeling i et flerdimensjonalt raster eller hvert element i et mosaikkraster. Denne funksjonen kan også aggregere flere inndelinger til én enkelt inndeling.",
		rasterCollectionDesc: "Funksjonen Process Raster Collection behandler hver inndeling i et flerdimensjonalt raster eller hvert element i et mosaikkraster. Denne funksjonen kan også aggregere flere inndelinger til én enkelt inndeling.<div><br/>Denne funksjonen behandler hver inndeling i et flerdimensjonalt raster eller mosaikkraster ved hjelp av en rasterfunksjonsmal. Funksjonen støtter følgende alternativer: 1. Angi en rasterfunksjonsmal for elementfunksjonen. Hvis du for eksempel har et mosaikkdatasett som inneholder 20 år med Landsat-bilder, og du vil beregne NDVI for hver scene i tidsserien. Angi en rasterfunksjonsmal som inneholder NDVI-rasterfunksjonen, for elementfunksjonen. 2. Angi en rasterfunksjonsmal for aggregeringsfunksjonen. Hvis du for eksempel har et flerdimensjonalt raster som inneholder 10 år med daglige temperaturdata og du vil beregne maksimumstemperaturen for hvert år. I aggregeringsfunksjonen angir du en rasterfunksjonsmal som inneholder Cell Statistics-funksjonen og har Maximum angitt for Operation. Under Aggregation Definition velger du StdTime for Dimension, velger Interval Keyword for Type og velger Yearly for Keyword Interval. Vær oppmerksom på at hvis mosaikkdatasettet som er inndata ikke er flerdimensjonalt, vil ikke funksjonen for aggregering overholde aggregeringsdefinisjonen. Funksjonen for aggregering vil aggregere alle elementene eller hver gruppe til én hvis de er definert i malen for aggregeringsfunksjonen. Hvis du vil ha mer informasjon om bruk av grupper i mosaikkdatasett, se Bruke mosaikkdatasettelementer i rasterfunksjonsmaler. 3. Angi en rasterfunksjonsmal for behandlingsfunksjonen. Funksjonen eller funksjonskjeden i denne malen brukes til å vise det nye behandlede rasteret. Du kan for eksempel angi en rasterfunksjonsmal som inneholder Colormap-funksjonen, for å endre hvordan det behandlede rasterlaget vises. Vær oppmerksom på at hvis inndata er et flerdimensjonalt raster, brukes behandlingsfunksjonen på gjeldende inndeling som vises. Hvis inndataene er et mosaikklag eller mosaikkdatasett, brukes behandlingsfunksjonen på mosaikkrasteret ved hjelp av First-metoden for å løse overlappinger. 3. Spesifiser maler for en hvilken som helst kombinasjon av de tre funksjonene. Hvis du for eksempel har et mosaikkdatasett som inneholder tidsserie Landsat-bilder og du vil generere et sammensatt bilde av maksimum NDVI. For elementfunksjonen angir du en rasterfunksjonsmal som inneholder NDVI-rasterfunksjonen. For aggregeringsfunksjonen angir du en rasterfunksjonsmal som inneholder Cell Statistics-funksjonen og har Maximum angitt for Operation. For behandlingsfunksjonen angir du en rasterfunksjonsmal som inneholder Colormap-funksjonen. Legg merke til at rekkefølgen for funksjonsbehandling følger rekkefølgene i inndataparameterne. For eksempel behandles elementfunksjonen først.</div>",
		randomName: "Random",
		randomSnip: "Oppretter et raster med tilfeldige pikselverdier hentet fra en pseudotilfeldig fordeling. Det er støtte for flere fordelinger og generatorer for tilfeldige tall.",
		randomDesc: "Random-funksjonen oppretter et raster med tilfeldige pikselverdier som kan brukes i rasterfunksjonsmaler eller mosaikkdatasett.<div><br/>Mens mange funksjoner fungerer på ett eller flere inndataraster, krever ikke Random-funksjonen et inndataraster. Det betyr at den oppfører seg mer som et rasterdatasett enn en funksjon, og du må derfor være ekstra forsiktig når du legger den til eller fjerner den fra funksjonskjeden.</div>",
		shrinkName: "Shrink",
		shrinkSnip: "Minsker de valgte sonene med et angitt antall celler ved å erstatte dem med verdien for celle som forekommer oftest i nabolaget.",
		shrinkDesc: "Med den globale Shrink-funksjonen kan du generalisere, eller forenkle, rastrene ved å gjøre bestemte soner mindre. Du kan også bestemme omfanget av generaliseringen.<div><br/>Sonene du velger minskes, eller reduseres i størrelse, ved at celler fra omkringliggende soner utvides inn i dem. De valgte soneverdiene kan vises som soner i forgrunnen, mens de andre verdiene beholdes som soner i bakgrunnen. Cellene i sonene i forgrunnen kan erstattes av celler i sonene i bakgrunnen. Smale øyer inni en sone, som kan anses å dele grenser med sonen, kan også erstattes.<div><br/>Omfanget av generaliseringen kan styres med parameteren Antall celler. Denne verdien er som standard 1, noe som betyr at de valgte sonene reduseres med mengden tilsvarende én celles størrelse. Du kan angi en større verdi for denne parameteren for å øke graden av generalisering. Dette blir som å kjøre verktøyet like mange ganger som angitt tall, med resultatene av forrige kjøring som inndata i etterfølgende gjentakelse.</div>",
		trendToRGBName: "Trend To RGB",
		trendToRGBSnip: "Konverterer et trendraster til et raster med tre bånd (rød, grønn og blå).",
		trendToRGBDesc: "Funksjonen Trend To RGB konverterer et trendraster til et raster med tre bånd (rød, grønn og blå). Trendrasteret genereres fra Generate Trend Raster-funksjonen eller CCDC Analysis-rasterfunksjonen.<div><br/>Denne funksjonen er nyttig når du vil visualisere modellkoeffisientdata fra Generate Trend-funksjonen eller CCDC Analysis-funksjonen. Begge funksjonene estimerer trender i pikselverdier som endrer seg, men resultatene av funksjonen er vanskelige å tolke direkte.<div><br/>Som for mange rasterfunksjoner må du kanskje bruke Justering av dynamisk områder for å få en bedre visning av resultatet av denne funksjonen.</div>",
		landTrendrName: "LandTrendr-analyse",
		landTrendrSnip: "Evaluerer endringer i pikselverdier over tid ved hjelp av den Landsat-baserte metoden for registrering av trender i forstyrrelse og gjenoppretting (LandTrendr) og genererer et endringsanalyseraster som inneholder modellresultatene.",
		landTrendrDesc: "Denne rasterfunksjonen kan bare brukes som inndata for rasterfunksjonen Registrer endring ved hjelp av endringanalyse. For å generere rasterutdata må LandTrendr-analysefunksjonen kobles til Registrer endring ved hjelp av endringanalyse-funksjonen i en rasterfunksjonsmal og bruke malen som inndata i geoprosesseringsverktøyet Generer raster fra rasterfunksjon. Resultatet blir et raster som inneholder informasjon om tidspunktet for endring av pikselverdier.<div><br>Formålet med denne rasterfunksjonen er å påvise endringer i et observert geoobjekt, så det ideelle flerdimensjonelle bildematerialet som brukes som inndata, bør vise en konsekvent observasjon over tid og bør ikke inneholde atmosfærisk- eller sensorinterferens, skyer eller skyskygge. Beste praksis er å bruke data som er blitt normaliserte og kan maskeres ved hjelp av et kvalitetskontrollbånd, for eksempel Landsat Collection 1 Surface Reflectance-produkter med skymaske.<div><br>Funksjonen analyserer ett bilde per år, og antall årlige sektorer må være lik eller større enn verdien som er angitt i parameteren <strong>Minimumsantall observasjoner</strong>. Det anbefales å bruke data fra minst seks år.<div><br>Hvis du har månedlige, ukentlige eller daglige data, anbefaler vi at du velger flere bilder fra hvert år (helst fra samme årstid), fjerner skyer og skyskygge og slår bildene sammen slik at det genereres ett enkelt bilde som gjengir observasjonen på en god måte. Hvis månedlige, ukentlige eller daglige data benyttes som det flerdimensjonale inndatarasteret, identifiserer funksjonen én sektor for analyse basert på datoen nærmest den som er angitt i parameteren <strong>Festingsdato</strong>.<div><br>Et geoobjekt i et landskap trenger ofte tid for å gjenopprettes etter en ikke-permanent endring som en skogbrann eller et insektangrep. Angi parameteren Terskel for gjenoppretting for å styre gjenopprettingstakten som gjenkjennes av modellen. Et gitt segment kan ikke ha en gjenopprettingstakt som er raskere enn 1/gjenopprettingsterskel.<div><br>Gjenopprettingen etter endring av et landskap kan gå i positiv eller negativ retning. Når for eksempel et landskap opplever tap av skog, viser en tidsserie med indeksverdier for vegetasjon et fall i indeksverdiene, og gjenopprettingen viser en gradvis økning i vegetasjonens indeksverdier, eller en positiv gjenopprettingstrend. Angi retningen på gjenopprettingstrenden med parameteren <strong>Gjenoppretting har stigende trend</strong>.",
		aggregateMultidimensionalName: "Aggreger flerdimensjonalt",
		aggregateMultidimensionalSnip: "Kombinerer eksisterende flerdimensjonale rastervariabeldata langs en dimensjon.",
		aggregateMultidimensionalDesc: "Funksjonen Aggreger flerdimensjonalt oppretter et flerdimensjonalt rasterlag ved å slå sammen eksisterende flerdimensjonale rastervariabeldata langs en dimensjon.<div><br>Bruk parameteren <strong>Dimensjonsdefinisjon</strong> til først å filtrere inndataene du vil aggregere. Hvis du for eksempel har månedlige data for 30 år, men bare vil opprette et aggregert lag for de første 15 årene, kan du bruke parameteren <strong>Dimensjonsdefinisjon</strong> til å angi hvilke år som skal inkluderes i analysen.<div><br><ul><li>Ekstraher salinitetsdata for januar måned over en 10-årsperiode. Velg <strong>Etter verdier</strong>, sett <strong>Dimensjon</strong> til <strong>StdTime</strong>, og sett <strong>Verdier</strong> til <strong>januar</strong>.</li><li>Del inn salinitetsdataene i sektorer over et dybdeområde fra 0 til 150 meter. Velg <strong>Etter områder</strong>, sett <strong>Dimensjon</strong> til <strong>StdZ</strong>, og sett <strong>Minimumsverdi</strong> til <strong>-150</strong> og <strong>Maksimumsverdi</strong> til <strong>0</strong>.</li><li>Ekstraher salinitetsdata for de første 10 dagene i januar hvert år over en 10-årsperiode. Velg <strong>Etter gjentakelse</strong>, sett <strong>Dimensjon</strong> til <strong>StdTime</strong>, sett <strong>Start for første gjentakelse</strong> og <strong>Slutt for første gjentakelse</strong> til tilsvarende start og slutt på gjentakelsesperioden, sett <strong>Trinn</strong> til <strong>1</strong>, og sett <strong>Enhet</strong> til <strong>År</strong>.</li></ul><div><br>Bruk parameteren <strong>Aggregeringsdefinisjon</strong> til å velge dimensjonen som skal vurderes, og velg aggregeringsintervallet ved å bruke et nøkkelord, en verdi eller et verdiområde. Hvis du for eksempel har 30 år med data om havets overflatetemperatur, innhentet daglig og for hver 5. meter ned til 100 meters dyp, kan du bruke de forskjellie intervallalternativene på følgende scenarioer:<div><br><ul><li>Aggreger daglige temperaturdata og månedlige data, der resultatet blir et flerdimensjonalt raster med 12 tidssektorer, og hver sektor er aggregatet av hver måned over samtlige år. Velg <strong>Nøkkelordintervall</strong> og sett nøkkelordet til <strong>Gjentas hver måned</strong>.</li><li>Aggreger daglige temperaturdata til månedlige data, der resultatet blir et flerdimensjonalt raster med 360 sektorer, eller 12 tidssektorer per år (30 år x 12 måneder = 360 sektorer). Velg <strong>Nøkkelordintervall</strong>, og sett nøkkelordet til <strong>Månedlig</strong>.</li><li>Aggreger månedlige temperaturdata i 4-måneders intervaller. Velg <strong>Intervallverdi</strong>, sett <strong>Verdiintervall</strong> til 4, og sett <strong>Enhet</strong> til <strong>Måneder</strong>.</li><li>Aggreger temperaturdata fra 0 til 25 meter, så fra 25 til 50 meter og deretter fra 50 til 100 meter. Velg <strong>Intervallområder</strong>, og angi minimums- og maksimumsdybder som <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Slå sammen rastere",
		mergeRastersSnip: "Kombinerer flere rasterdatasett romlig, eller på tvers av variabler og dimensjoner.",
		mergeRastersDesc: "Denne funksjonen oppretter et sammenslått raster fra en liste over rastere. Hvis du for eksempel har et mosaikkdatasett som inneholder 30 års månedlige nedbørsdata, og et annet datasett med 10 års månedlige temperaturdata, kan du slå dem sammen til et flerdimensjonalt raster med begge variablene. <div><br>Hvis de flerdimenasjonale inndatarasterne inneholder forskjellige variabler, vil det resulterende flerdimensjonale rasteret inneholde samtlige variabler. <div><br>Hvis de flerdimenasjonale inndatarasterne inneholder forskjellige dimensjoner eller dimensjonsverdier, vil det resulterende flerdimensjonale rasteret inneholde samtlige dimensjoner og dimensjonsverdier. <div><br>Hvis de flerdimenasjonale inndatarasterne inneholder de samme dimensjonene og variablene, men har ulike romlige utstrekninger, vil det resulterende flerdimensjonale rasteret inneholde variablene og dimensjonene på tvers av de sammenslåtte romlige utstrekningene.<div><br>Denne funksjonen kan også brukes når du har flere rastere som du vil behandle som ett element, for eksempel for å beregne samme statistikk for alle, eller når du balanserer farger og vil slippe å balansere fargene i hvert bilde for seg. Dette er nyttig når du arbeider med bilder som er lagret som separate fliser på grunn av begrensninger på filstørrelse. Med denne metoden blir flisene behandlet som deler av det samme bildet.",
		boundaryCleanName: "Grenseutjevning",
		boundaryCleanSnip: "Jevner ut grensen mellom soner.",
		boundaryCleanDesc: "<p>Funksjonen generaliserer eller forenkler rastere ved å jevne ut grensene mellom soner. Funksjonen har alternativer for å styre hvordan cellene i sonene påvirker utjevningen og hvilken grad av utjevning som skal brukes. Hver enkelt inndatacelle evalueres ved å bruke de åtte nærmeste naboene.</p><p>Utjevningsprosessen sorterer først nabocellene etter en bestemt prioritet. Prioriteten bestemmer hvilken sone fra nabocellene som kan erstatte verdien av behandlingscellen i resultatet.</p><p>Prioriteten kan baseres på enten verdien av sonene eller størrelsen på sonene. Parameteren <strong>Sorteringstype</strong> bestemmer hvilken sorteringstype som skal brukes. </p><p>Standardinnstillingen <strong>Ikke sorter</strong> vurderer prioriteten ut fra verdien av sonene. Celler fra soner med høyere verdier vil ha en høyere prioritet for å utvides inn i soner med lavere verdier.</p><p>Sonenes størrelse eller totale areal kan brukes til å sortere prioriteten. Med innstillingen <strong>Synkende</strong> sorteres sonene etter størrelse i synkende rekkefølge. Soner med større totalt areal vil ha prioritet til å utvides inn i soner med mindre areal. Med innstillingen <strong>Stigende</strong> skjer det motsatte: Soner med mindre totalt areal vil ha prioritet til å utvides inn i soner med større totalt areal.</p><p>Graden av utjevning styres av parameteren <strong>Kjør utvidelse og krymping to ganger</strong>, som bestemmer antall ganger utvidelses- og krympeprosessen skal utføres.</p><p>Når innstillingen ikke er avmerket, utføres utvidelses- og krympeprosessen én gang. Når innstillingen er avmerket, utføres utvidelses- og krympeprosessen to ganger og resulterer i en ytterligere grad av utjevning av sonegrensene.</p><p>Hvis verdiene i alle de åtte nabocellene er de samme som i behandlingscellen, beholder den resulterende cellen verdien til inndatacellen.</p>",
		predictUsingRegressionName: "Forutsi bruk av regresjon",
		predictUsingRegressionSnip: "Beregner en forutsagt raster basert på rasterdatainndata og en regresjonsmodell. Regresjonsmodellen er utdata fra <strong>Train Random Trees-regresjonsmodellens</strong> rastergeobehandlingsverktøy.",
		predictUsingRegressionDesc: "<p>Regresjonsmodellen er definert i en Esri-regresjonsdefinisjonsfil (.ecd). Den inneholder all informasjon for et bestemt datasett eller et sett med datasett, og regresjonsmodellen, og genereres av <strong>Train Random Trees-regresjonsmodellens</strong> rastergeobehandlingsverktøy.</p><p>Inndataene kan være et enkelt bånd, et multibånd eller et flerdimensjonalt raster, eller en liste over disse typene. Typene inndatarastere må være samme type raster som er opplært av regresjonsmodellen.</p><ul><li>Når inndata er et multibåndraster, blir hvert bånd behandlet som en prediktorvariabel. Båndene må være i samme rekkefølge som multibåndsinndataene for regresjonsmodellens opplæringsverktøy.</li><li>Når inndata er et flerdimensjonalt raster, blir hver variabel behandlet som en prediktorvariabel, og variabelen må være enkeltbånd og ha en tidsdimensjon. Variabelrekkefølgen og -navnene må være de samme som inndataene når regresjonsmodellen ble lært opp. Utdataene er et flerdimensjonalt raster.</li><li>Inndataene kan være en liste med elementer. Antall elementer og rekkefølgen på elementene må samsvare med indataene når regresjonsmodellen ble lært opp.</li></ul>",
		dimensionalMovingStatisticsName: "Dimensjonal bevegelsesstatistikk",
		dimensionalMovingStatisticsSnip: "Beregner statistikk over et vindu i bevegelse på flerdimensjonale data langs en angitt dimensjon.",
		dimensionalMovingStatisticsDesc: "<p>Funksjonen Dimensjonsflyttingsstatistikk beregner ulike statistikker i et forhåndsdefinert vindu for alle dimensjonsverdier langs en dimensjon. Denne funksjonen tar et flerdimensjonalt rasterlag som inndata og oppretter et flerdimensjonalt rasterlag som utdata som har samme dimensjonale størrelse som inndatalaget.</p><p>Du kan angi en dimensjon som dimensjonsverdier vurderes for under beregningen. Som standard beregnes den langs den første ikke-romlige dimensjonen. Du kan også angi en vindusstørrelse ved å angi parameterne Bakovervindu og Fremovervindu.</p><p>Når statistikktypen er satt til persentil, blir parameterne persentilverdi og persentil interpoleringstype tilgjengelige. Du kan bruke disse parameterne til å angi persentilen som skal beregnes, og velge interpoleringstypen som skal brukes. Når statistikktypen er satt til sirkulært gjennomsnitt, blir parameteren sirkulær flytverdi tilgjengelig. Den sirkulære flytverdien brukes til å konvertere en lineær verdi til området for et gitt sirkulært gjennomsnitt.</p>",
		terrainFlattenFunctionName: "Utflating av terreng",
		terrainFlattenFunctionSnip: "Korrigerer inndata fra radar med syntetisk blenderåpning (SAR-data) for radiometriske fortegninger som skyldes topografi.",
		terrainFlattenFunctionDesc: "<p>Rasterfunksjonen Utflating av terreng korrigerer inndataene fra radarer med syntetisk blenderåpning (SAR-data) for radiometriske fortegninger som skyldes topgrafi.</p><p>Inndataene må først kalibreres til beta null. Verktøyet Bruk radiometrisk kalibrering brukes til å kalibrere radardata til beta null.</p><p>Hvis DEM-inndataene ikke omfatter hele SAR-datasettet, gir verktøyet følgende resultater: NoData-verdier for pikslene som ligger utenfor DEM-utstrekningen for gamma null, sigma null, spredningsområde og utdata for geometriske fortegninger. For maskeutdataene for geometrisk fortegning gir verktøyet som resultat ubestemte verdier for piksler utenfor DEM-utstrekningen.</p><p>Inndata-DEM må være i det geografiske koordinatsystemet WGS 1984 (EPSG:4326).</p>",
		createColorCompositeFunctionName: "Opprett fargekompositt",
		createColorCompositeFunctionSnip: "Oppretter et raster med tre bånd fra et flerbåndsrasterdatasett der hvert bånd kan bruke en algebraisk utregning basert på båndets algebra.",
		createColorCompositeFunctionDesc: "<p>Rasterfunksjonen Opprett fargekompositt oppretter et raster med tre bånd fra et flerbåndsrasterdatasett der hvert bånd kan bruke en algebraisk utregning basert på båndets algebra.</p><p>Når du definerer en båndaritmetisk algoritme, kan du angi en algebraisk formel på en enkelt linje for hvert uttrykk, for å skape et flerbåndsresultat. Operatorene som støttes, er enhetlige, pluss (+), minus (-), multiplikasjon (*), og divisjon (/).</p><p>Når en bånd-ID skal brukes i et uttrykk, må båndet identifiseres med prefikset B eller b ved båndnummeret.</p><p>En alminnelig båndkombinasjon som brukes for radar med syntetisk blenderåpning (SAR) i lineære enheter, er VV for rødt, VH for grønt og VV/VH for blått. Hvis inndataene er i desibel, skal båndkombinasjonen være VV for rødt, VH for grønt og VV-VH for blått.</p>",
		surfaceParametersName: "Overflateparametere",
		surfaceParametersSnip: "Fastsetter parametere for en rasteroverflate som hellingsretning, hellingsgrad og flere typer kurvatur ved hjelp av geodetiske metoder.",
		surfaceParametersDesc: "<p>Funksjonen Overflateparametre fastsetter parametere for en rasteroverflate som hellingsretning, hellingsgrad og flere typer kurvatur ved hjelp av geodetiske metoder.</p><p>Denne funksjonen kan brukes til følgende:</p><ul><li>Beregne hellingsretning og hellingsgrad ved hjelp av geodetiske metoder.</li><li>Beregne ulike typer kurvatur fra en innlagt overflateraster, for eksempel <strong>Tangenitell (normal kontur) kurvatur</strong> som karakteriserer topografisk konvergens og divergens av flyt over overflaten.</li></ul>",
		leastCostCorridorName: "Minst kostnad-korridor",
		leastCostCorridorSnip: "Beregner summen for to raster for kumulativ kostnadsavstand med mulighet til å bruke en terskel basert på prosent eller kumulativ kostnad.",
		leastCostCorridorDesc: "<p>Inndatarastrene skal være avstandsakkumulering og utdata for raster for motsatt retning fra funksjonen <strong>Avstandsakkumulering</strong> eller <strong>Avstandsallokering</strong> . Disse skal være basert på kostnadsavstand, og de samme parameterinnstillingene skal brukes til oppretting av lagene for hver kilde. Det skal ikke brukes parametere som er avhengige av retningsangivelse (horisontal faktor, vertikal faktor og reiseretning), til å opprette disse rasterene.</p><p>Verdiene i resulterende korridorraster er summen av den kumulative kostanden for å nå en gitt lokasjon med de samme enhetene som inndatarastrene med kumulativ kostnadsavstand.</p><p>Hvis en angitt <strong>terskel</strong>verdi er større enn maksimum kumulativ kostnad når de to rastrene for avstandsakkumulering er summert, vil resulterende korridorraster dekke det samme området som de kumulative inndatarastrene.</p><p>Hvis en angitt terskelverdi er mindre enn verdien i korridorrasteret, returneres en melding med en advarsel og utdatarasteret vil være tomt.</p><p>Resulterende korridorraster kan inneholde celler med litt større kumulative kostander enn terskelverdien. Dette er fra rastrene for motsatt retning som bruker celler tilordnet litt høyere kostnader enn terskelen for å knytte frakoblede celler til korridoren.</p>",
		geometricMedianName: "Geometrisk median",
		geometricMedianSnip: "Funksjonen Geometrisk median beregner den geometriske medianen på tvers av piksler i en tidsserie av flerbåndsbilder.",
		geometricMedianDesc: "<p>Funksjonen reduserer støy og avvik i tidsserier av bilder ved beregne en geometrisk medianpiksel for hver pikselmatrise på tvers av bildestakken. Algoritmen opprettholder de spektrale relasjonene mellom bånd i pikselspektrene slik at utdataene kan brukes i analyser, for eksempel vegetasjonsindekser.</p><p>Skyer og skygger skal maskeres ved hjelp av QA-bånd for datasettet før denne funksjonen brukes.</p><p>Hvis inndatabildet er flyttall, for eksempel overflaterefleks med verdier mellom 0 og 1, vil en epsilonverdi på 0,001 gi kvalitetsresultater.</p>"
	},
	rfxArgs: {
		rasterName: "Raster",
		colorSchemeTypeName: "Fargevalgtype",
		colormapName: "Fargekart",
		colormapNameName: "Navn på fargekart",
		colorRampName: "Fargepalett",
		contrastOffsetName: "Kontrastforskyvning",
		brightnessOffsetName: "Lysstyrkeforskyvning",
		methodName: "Metode",
		bandNamesName: "Båndnavn",
		bandWavelengthsName: "Båndbølgelengder",
		bandIdsName: "Bånd-ID-er",
		missingBandActionName: "Båndhandling mangler",
		conversionParametersName: "Konverteringsparametere",
		hillshadeTypeName: "Terrengskyggetype",
		azimuthName: "Asimut",
		altitudeName: "Høyde",
		slopeTypeName: "Skalering",
		zFactorName: "z-faktor",
		PSPowerName: "Pikselstørrelseseffekt",
		PSZFactorName: "Pikselstørrelsesfaktor",
		removeEdgeEffectName: "Deaktiver standard kantpikselinterpolasjon",
		fromUnitName: "Fra enhet",
		toUnitName: "Til enhet",
		rasterTypeName: "Type",
		minName: "Minimum for utdata",
		maxName: "Maksimum for utdata",
		minPercentName: "Minimum prosentklipp",
		maxPercentName: "Maksimum prosentklipp",
		numberOfStandardDeviationName: "Antall standardavvik",
		sigmoidStrengthLevelName: "Sigmoid-styrkenivå",
		estimateStatsHistogramName: "Beregn statistikk",
		DRAName: "Justering av dynamisk område",
		statisticsName: "Statistikk",
		histogramsName: "Histogrammer",
		statisticsHistogramName: "Definer statistikk og histogram",
		computeGammaName: "Automatisk gamma",
		useGammaName: "Bruk gamma",
		gammaName: "Gamma",
		inputNamesName: "Navn",
		expressionName: "Uttrykk",
		cellsizeTypeName: "Cellestørrelsestype",
		extentTypeName: "Utstrekningstype",
		classifierDefinitionFileName: "Angi definisjonsfil",
		raster1Name: "Raster1",
		raster2Name: "Raster2",
		raster3Name: "Raster3",
		trueRasterName: "Sant raster",
		falseRasterName: "Usant raster",
		noDataInterpretationName: "NoData-tolking",
		noDataValuesName: "NoData-verdier",
		includedRangesName: "Inkluderte områder",
		curvatureTypeName: "Kurvaturtype",
		rastersName: "Rastere",
		attributeTableName: "Tabell",
		attributeTableTypeName: "Tabelltype",
		rowsName: "Antall rader",
		columnsName: "Antall kolonner",
		kernelName: "Kjerne",
		mirrorEdgesName: "Speilkanter",
		influencesName: "Påvirkninger",
		fieldsName: "Felter",
		remapsName: "Tilordne tabell på nytt",
		evalFromName: "Evalueringsskala fra",
		evalToName: "Evalueringsskala til",
		weightsName: "Vekting",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "IDW-radius med kort rekkevidde",
		maxVoidWidthName: "Største hullstørrelse",
		sigmaGaussianName: "Adaptiv utjevning",
		contourTypeName: "Høydekurvetype",
		zBaseName: "z-base",
		numberOfContoursName: "Antall høydekurver",
		contourIntervalName: "Høydekurveintervall",
		nthContourLineInBoldName: "Nth ContourLine i fet",
		featureClassName: "Inndatageoobjekter",
		classIndexFieldName: "Felt",
		resolveOverlapMethodName: "Løs overlappingsmetode",
		resamplingTypeName: "Resamplingstype",
		inputCellsizeName: "Inndatacellestørrelse",
		outputCellsizeName: "Utdatacellestørrelse",
		pointFeatureClassName: "Seed-punkt",
		maxGrowthRadiusFieldName: "Felt for maks. vekstradius",
		similarityThresholdFieldName: "Likhet terskelfelt",
		fillValueFieldName: "Felt for utfyllingsverdi",
		spectralDetailName: "Spektraldetalj [1..20]",
		spatialDetailName: "Romlig detalj [1..20]",
		minNumPixelsPerSegmentName: "Minimum segmentstørrelse i piksler",
		boundariesOnlyName: "Kun segmentgrenser",
		statisticsTypeName: "Statistikktype",
		fillNoDataOnlyName: "Fyll bare NoData-piksler",
		inputDataTypeName: "Inndatatype",
		angleReferenceSystemName: "Vinkelreferansesystem",
		outputDataTypeName: "Utdatatype",
		inputSamplePointFeatureClassName: "Inndataeksempler",
		valueFieldName: "Verdifelt",
		rasterInfoName: "Rasterinfo",
		interpolationMethodName: "Interpoleringsmetode",
		radiusName: "Radius",
		radianceGainValuesName: "Strålingsforsterking",
		radianceBiasValuesName: "Strålingstillegg",
		reflectedGainValuesName: "Refleksjonsfaktorøkning",
		reflectedBiasValuesName: "Refleksjonsfaktoravvik",
		sunElevationName: "Solhøyde (grader)",
		albedoName: "Albedo",
		scaleFactorName: "Målestokkfaktor",
		offsetName: "Forskyvning",
		thresholdTypeName: "Terskeltype",
		thresholdsName: "Terskler",
		undefinedClassName: "Udefinert klasse",
		minValueName: "Min",
		maxValueName: "Maks",
		operationName: "Operasjon",
		clippingTypeName: "Klippemåte",
		clippingGeometryName: "Geometri/raster for utklipp",
		extentName: "Utdataomfang",
		useInputFeatureGeometryName: "Bruk inndatageoobjekter for klippegeometri",
		remapDefinitionTypeName: "Tilordne definisjonstype på nytt",
		inputRangeName: "Inndataområder",
		outputValuesName: "Utdataverdier",
		noDataRangeName: "NoData-områder",
		inputFieldName: "Inndatafelt",
		outputFieldName: "Utdatafelt",
		inputMaxFieldName: "Inndatamaksimumsfelt (valgfritt)",
		remapTableTypeName: "Tilordne tabelltype på nytt",
		allowUnmatchedName: "Tillat ikke-samsvarende pikselverdier",
		changeMissingValuesToNoDataName: "Endre manglende verdier til NoData",
		visibleBandIDName: "Synlig bånd-ID",
		infraredBandIDName: "Infrarød bånd-ID",
		scientificOutputName: "Vitenskapelige utdata",
		bandIndexesName: "Båndindekser",
		constantName: "Konstant",
		weightName: "Vekt",
		minimumName: "Minimum",
		maximumName: "Maksimum",
		sourceDataName: "Kilderaster",
		sourceFieldName: "Kildefelt",
		costRasterName: "Kostnadsraster",
		maxDistanceName: "Maksimumsavstand",
		valueRasterName: "Verdiraster",
		costMultiplierName: "Multiplikator som skal brukes på kostnader",
		startCostName: "Startkostnad",
		accumCostResistanceRateName: "Kumulativ kostnadsmotstandsgrad",
		capacityName: "Kapasitet",
		travelDirectionName: "Reiseretning",
		cellSizeName: "Cellestørrelse",
		populationFieldName: "Befolkningsfelt",
		areaUnitsName: "Arealenheter",
		outputValueTypeName: "Utdatacelleverdier",
		barriersName: "Inndatasperrer",
		destinationDataName: "Målraster",
		destinationFieldName: "Målfelt",
		pathTypeName: "Reiserutetype",
		observerFeaturesName: "Observasjonsgeoobjekter",
		analysisMethodName: "Analysemetode",
		analysisTypeName: "Analysetype",
		verticalErrorName: "Vertikal feil",
		refractivityCoefficientName: "Brytningskoeffisient",
		surfaceOffsetName: "Overflateforskyvning",
		observerElevationName: "Observatørhøyde",
		observerOffsetName: "Observatørforskyvning",
		innerRadiusName: "Indre radius",
		innerRadiusIs3DDistanceName: "Indre radius er 3D-avstand",
		outerRadiusName: "Ytre radius",
		outerRadiusIs3DDistanceName: "Ytre radius er 3D-avstand",
		horizontalStartAngleName: "Horisontal startvinkel",
		horizontalEndAngleName: "Horisontal sluttvinkel",
		verticalUpperAngleName: "Vertikal øvre vinkel",
		verticalLowerAngleName: "Vertikal nedre vinkel",
		zoneDataName: "Soneraster",
		zoneFieldName: "Sonefelt",
		ignoreNoDataName: "Ignorer NoData i beregninger",
		temperatureRasterName: "Temperaturraster",
		inTemperatureUnitsName: "Temperaturenheter",
		outHeatIndexTemperatureUnitsName: "Varmeindeksenheter",
		relativeHumidityRasterName: "Relativ fuktighetsraster",
		outWindChillTemperatureUnitsName: "Vindfaktorenheter",
		windSpeedRasterName: "Vindhastighetsraster",
		inWindSpeedUnitsName: "Vindhastighetenheter",
		valueName: "Verdi",
		propertyName: "Egenskapsnavn",
		jsonName: "Metadata JSON",
		zoneTableName: "Soneattributtabell",
		attributeFieldNames: "Attributtfeltnavn",
		backgroundName: "Bakgrunnsverdi",
		whereClauseName: "Where-setning",
		minimumValueFieldName: "Navn på minimumsverdifelt",
		maximumValueFieldName: "Navn på maksimumsverdifelt",
		outValueFieldName: "Navn på utdataverdifelt",
		defaultValueName: "Standard utdataverdi",
		conversionMatrixName: "Konverteringsmatrise",
		IsPseudoColorOutputName: "Er uekte fargeutdata",
		unmappedAsRandomColorName: "Tildel farger tilfeldig til piksler som ikke er tilordnet",
		distanceMethodName: "Avstandsmetode",
		flowDirRasterName: "Strømningsretningsraster",
		pourPointName: "Utløpspunktraster",
		pourPointFieldName: "Utløpspunktfelt",
		constantZName: "Konstant Z",
		zOffsetName: "Z-forskyvning",
		geoIdName: "Geoide",
		calibrationTypeName: "Kalibreringstype",
		filterTypeName: "Filtertype",
		filterSizeName: "Filterstørrelse",
		noiseModelName: "Støymodell",
		noiseVarianceName: "Støyvarians",
		additiveNoiseMeanName: "Middelverdi for additiv støy",
		multiplicativeNoiseMeanName: "Middelverdi for multiplikativ for støy",
		numberofLooksName: "Antall utseender",
		dampingFactorName: "Dempingsfaktor",
		maskRasterName: "Maskeraster",
		nibbleValuesName: "Bruk NoData-verdier hvis de er nærmeste nabo",
		nibbleNoDataName: "Nibble NoData-celler",
		zLimitName: "Z-grense",
		flowDirectionTypeName: "Type strømningsretning",
		weightRasterName: "Vektraster",
		forceEdgeName: "Tving alle kantceller til å strømme utover",
		streamRasterName: "Strømraster",
		surfaceRasterName: "Overflateraster",
		conversionType: "Konverteringstype",
		distanceRaster1: "Avstandraster 1",
		distanceRaster2: "Avstandraster 2",
		costDistanceRaster: "Kostnad/avstandsraster",
		costBacklinkRaster: "Tilbakekoblingsraster for kostnad",
		overridesName: "Overstyrer",
		fieldName: "Felt",
		signatureFileOrUrl: "Signaturfil eller URL",
		redName: "Rød",
		greenName: "Grønn",
		blueName: "Blå",
		infraredName: "Infrarød",
		panchromaticName: "Pankromatisk",
		multispectralName: "Multispektral",
		pansharpeningType: "Type pankromatisk oppskarping",
		sensorName: "Sensor",
		spatialReferenceName: "Romlig referanse",
		xCellsizeName: "X-cellestørrelse",
		yCellsizeName: "Y-cellestørrelse",
		xOriginName: "X-registreringspunkt",
		yOriginName: "Y-registreringspunkt",
		percentileName: "Persentilverdi",
		neighborhoodType: "Nabotype",
		widthName: "Bredde",
		heightName: "Høyde",
		startAngleName: "Startvinkel",
		endAngleName: "Sluttvinkel",
		neighborhoodValues: "Nabolagsverdier",
		horizontalRaster: "Horisontalt raster",
		horizontalFactor: "Horisontal faktor",
		verticalRaster: "Vertikalt raster",
		verticalFactor: "Vertikal faktor",
		streamRaster: "Strømraster",
		flowDirRaster: "Strømningsretningsraster",
		numberNeighborCells: "Antall naboceller",
		zoneConnectivity: "Sonetilkobling",
		addLinkBehavior: "Legg til kobling",
		excludedValue: "Utelatt verdi",
		constantFillCheck: "Generer fyllraster fra konstant",
		fillRaster: "Fyllraster",
		constantFillValue: "Konstant verdi",
		inputBitPositions: "Inndatabit",
		outputBitPositions: "Utdatabit",
		distanceTypeName: "Avstandstype",
		barrierDataName: "Rasterbarrierer",
		pourPointDataName: "Utløpspunktraster",
		accumulationRasterName: "Raster med akkumulert flyt",
		snapDistanceName: "Snappavstand",
		orderMethodName: "Ordremetode",
		directionMeasurementName: "Måleretning",
		processAsMultiband: "Behandle som flerbånd",
		processMultidimensional: "Behandle som flerdimensjonal",
		forceFlowDirectionConvention: "Tving strømningsretningskonvensjon for backlink-raster",
		initialAccumulation: "Første akkumulering",
		maximumAccumulation: "Maksimal akkumulering",
		sourceLocationBands: "Generer kilderad og -kolonne som ekstra bånd i utdata",
		backDirectionBand: "Generer tilbakeretning som ekstra bånd i utdata",
		numberOfCells: "Antall celler",
		zoneValues: "Soneverdier",
		shrinkMethod: "Forminsk metode",
		expandMethod: "Utvide metode",
		inputSpectralProfileType: "Spektralprofiltype",
		spectralProfileFileName: "Spektralprofil",
		trainingFeatureFileName: "Opplæringsfunksjon",
		nonNegative: "Ikke-negativ",
		sumToOne: "Summer til én",
		randomDistribution: "Distribusjon",
		meanName: "Gjennomsnitt",
		probabilityName: "Sannsynlighet",
		alphaName: "Alfa",
		betaName: "Beta",
		rName: "r",
		nName: "N",
		seed: "Utgangsverdi",
		randomNumberGenerator: "Generator for tilfeldige tall",
		cellFactor: "Cellefaktor",
		aggregationType: "Aggregeringsteknikk",
		extentHandling: "Utvid utstrekning hvis nødvendig",
		trendAnalysisDimensionName: "Dimensjonsnavn",
		trendAnalysisType: "Trendtype",
		harmonicFrequency: "Harmonisk frekvens",
		polynomialOrder: "Polynomgrad",
		cycleLengthName: "Length of Cycle",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R-Squared",
		trendAnalysisSlopePValue: "P-Value of Slope Coefficients",
		trendAnalysisSeasonalPeriod: "Årstid",
		cycleUnitName: "Cycle Unit",
		predictDimensionValues: "Verdier",
		dimensionDefinitionType: "Dimensjonsdefinisjon",
		predictDimensionStart: "Start",
		predictDimensionEnd: "Slutt",
		predictDimensionInterval: "Verdiintervall",
		dimensionUnit: "Enhet",
		interpolationCellsizeName: "Cellestørrelse for interpolering",
		variableName: "Variabler",
		dimensionlessName: "Dimensionless",
		mdimDefinition: "Dimension Definition",
		dimensionName: "Dimensjon",
		iterationStart: "Start of first iteration",
		iterationEnd: "End of first iteration",
		intervalStart: "Start på intervall",
		intervalEnd: "Slutt på intervall",
		stepName: "Trinn",
		rangesName: "Ranges",
		minValue: "Minimum Value",
		maxValue: "Maximum Value",
		changeAnalysisRasterName: "Endre analyseraster",
		changeTypeName: "Change Type",
		segmentDate: "Segmentdato",
		changeDirectionName: "Endre retning",
		maxNumChangesName: "Maximum Number of Changes",
		filterByYear: "Filtrer etter år",
		minimumYear: "Minimumsverdi",
		maximumYear: "Maksimumsverdi",
		filterByDuration: "Filtrer etter varighet",
		minimumDuration: "Minimumsvarighet",
		maximumDuration: "Maksimumsvarighet",
		filterByMagnitude: "Filtrer etter størrelse",
		minimumMagnitude: "Minimumsstørrelse",
		maximumMagnitude: "Maksimumsstørrelse",
		filterByStartValue: "Filtrer etter startverdi",
		minimumStartValue: "Minimum startverdi",
		maximumStartValue: "Maksimum startverdi",
		filterByEndValue: "Filtrer etter sluttverdi",
		minimumEndValue: "Minimum sluttverdi",
		maximumEndValue: "Maksimum sluttverdi",
		modelTypeName: "Modelltype",
		fromRasterName: "Fra-raster",
		toRasterName: "Til-raster",
		computeChangeMethod: "Compute Change Method",
		fromClassValues: "Fra-klasseverdier (f.eks.: 2 5)",
		toClassValues: "Til-klasseverdier (f.eks.: 2 5)",
		keepMethod: "Filtreringsmetode",
		useColorMethod: "Definer overgangsfarger",
		detectChangeBands: "Bånd for å oppdage endring (start på 0)",
		tmaskBands: "Bånd for temporær maskering (start på 0)",
		chiSquaredThreshold: "Chi-squared Threshold for Detect Change",
		minAnomaly: "Minimum Consecutive Anomaly Observations",
		updatingFrequency: "Updating Fitting Frequency (in years)",
		distanceAccumulationRasterName: "Raster for avstandsakkumulering",
		costBackdirectionRasterName: "Raster for tilbakeretning eller strømningsretning",
		rasterCollectionName: "Rastersamling",
		itemFunctionName: "Elementfunksjon",
		aggregationFunctionName: "Aggregeringsfunksjon",
		processingFunctionName: "Behandlingsfunksjon",
		aggregationDefinitionName: "Aggregeringsdefinisjon",
		queryGeometryName: "Spørringsgeometri",
		factorFunctionZeroFactor: "Nullfaktor",
		factorFunctionCutAngle: "Snittvinkel",
		factorFunctionSideFactor: "Sidefaktor",
		factorFunctionSlope: "Helling",
		factorFunctionLowCutAngle: "Lav snittvinkel",
		factorFunctionHighCutAngle: "Høy snittvinkel",
		factorFunctionCosPower: "Cosinus opphøyd",
		factorFunctionSecPower: "Sekant opphøyd",
		factorFunctionTablePath: "Tabellbane",
		processingBand: "Behandlingsbånd",
		processingBandName: "Behandler båndnavn",
		snappingDate: "Festingsdato",
		maxNumSegments: "Maksimalt antall segmenter",
		vertexCountOvershoot: "Overskytende antall knekkpunkter",
		spikeThreshold: "Spike-terskel",
		recoveryThreshold: "Terskel for gjenoppretting",
		minNumObs: "Minimumsantall observasjoner",
		pValueThreshold: "Terskel for p-verdi",
		bestModelProportion: "Beste modellproporsjon",
		preventOneYearRecovery: "Hindre ett års gjenoppretting",
		recoveryIncreaseTrend: "Gjenoppretting har stigende trend",
		outputOtherBands: "Andre bånd som utdata",
		sortType: "Sorteringstype",
		numberOfRuns: "Kjør utvidelse og krymping to ganger",
		percentileValue: "Persentilverdi",
		percentileInterpolationType: "Type interpolasjon av persentil",
		rasterInfoProperty: "Eiendom",
		rasterInfoValue: "Verdi",
		rasterInfoColumns: "Kolonner",
		rasterInfoRows: "Rader",
		rasterInfoBandCount: "Antall bånd",
		rasterInfoPixelSizeX: "Cellestørrelse X",
		rasterInfoPixelSizeY: "Cellestørrelse Y",
		rasterInfoPixelType: "Pikseltype",
		rasterExtentTop: "Topp",
		rasterExtentBottom: "Bunn",
		rasterExtentLeft: "Venstre",
		rasterExtentRight: "Høyre",
		rasterStatisticsNotCalculated: "Statistikk er ikke beregnet.",
		spatialReferenceProjection: "Projeksjon",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "Forrige WKID",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "Forrige VCSWKID",
		spatialReferenceAuthority: "Autoritet",
		spatialReferenceLinearUnit: "Lineær enhet",
		spatialReferenceAngularUnit: "Vinkelenhet",
		spatialReferenceFalseEasting: "Falsk øst-verdi",
		spatialReferenceFalseNorthing: "Falsk nord-verdi",
		spatialReferenceCentralMeridian: "Sentralmeridian",
		spatialReferencePrimeMeridian: "Nullmeridian",
		spatialReferenceStandardParallel1: "Standardparallell 1",
		spatialReferenceStandardParallel2: "Standardparallell 2",
		spatialReferenceLatitudeOfOrigin: "Breddegrad for utgangspunkt",
		spatialReferenceAuxiliarySphereType: "Auxiliary Sphere-type",
		spatialReferenceDatum: "Nullpunkt",
		spatialReferenceSpheroid: "Sfæroide",
		spatialReferenceSemimajorAxis: "Store halvakse",
		spatialReferenceSemiminorAxis: "Lille halvakse",
		spatialReferenceInverseFlattening: "Invers utflating",
		inputDefinitionFileName: "Angi definisjonsfil",
		deleteName: "Slett",
		addVariableName: "Legg til variabel",
		maxNumPixelsPerSegment: "Maksimum segmentstørrelse i piksler",
		forwardWindowName: "Forover vindu",
		backwardWindowName: "Bakover vindu",
		noDataHandlingName: "IngenData behandling",
		circularWrapValueName: "Sirkulær omslagsverdi",
		fromClassNameFieldName: "Feltnavn for klassenavn inn fra Raster",
		toClassNameFieldName: "Feltnavn for klassenavn inn til Raster",
		targetRasterName: "Målraster",
		circularWrapValue: "Sirkulær omslagsverdi",
		bandIndexesR: "Rødt uttrykk",
		bandIndexesG: "Grønt uttrykk",
		bandIndexesB: "Blått uttrykk",
		exampleName: "Eksempel",
		inputName: "Inndata",
		outputName: "Resultat",
		optionalName: "Valgfritt",
		browseDefinitionFile: "Bla gjennom definisjonsfil",
		selectDefinitionFile: "Velg inndatadefinisjonsfil",
		inputDefinitionURL: "URL for inndatadefinisjonsfil",
		enterDefinitionFileURL: "Angi URL for inndatadefinisjonsfil",
		browseXMLFile: "Bla gjennom XML-fil",
		selectStatsFile: "Velg statistikk- og histogramfil",
		enterXMLFileURL: "Angi URL for XML-fil",
		xmlFileURL: "URL for XML-fil",
		circularCalculation: "Beregn sirkelstatistikk",
		localSurfaceType: "Lokal overflatetype",
		surfaceParameterType: "Parametertype",
		neighborhoodDistance: "Nabolagsavstand",
		useAdaptiveNeighborhood: "Bruk adaptivt nabolag",
		outputSlopeType: "Utdata helningsmåling",
		projectAzimuths: "Projiser geodetiske asimuter",
		useEquatorialAspect: "Bruk ekvatorialaspekt",
		zUnit: "Z-enhet",
		analysisMask: "Analysemaske",
		stdDeviation: "Standardavvik",
		"true": "Sant",
		"false": "Usant",
		costDistanceRaster1: "Inndata for kostnad/avstandsraster 1",
		costDistanceRaster2: "Inndata for kostnad/avstandsraster 2",
		threshold: "Terskel",
		thresholdMethod: "Terskelmetode",
		directionRaster1: "Inndata for back direction-raster 1",
		directionRaster2: "Inndata for back direction-raster 2",
		maxIterations: "Maksimalt antall gjentakelser",
		epsilon: "Epsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manuell",
		attributeTableTypeExternal: "Ekstern",
		clrSchemeTypeColormap: "Fargekart",
		clrSchemeTypeColorRamp: "Fargepalett",
		colormapTypeElevation: "Høydedata",
		colormapTypeGray: "Grå",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Tilfeldig",
		none: "Ingen",
		slopeTypeAdjusted: "Justert",
		slopeTypeDegree: "Grad",
		slopeTypePercentRise: "Prosent stigning",
		slopeTypeScaled: "Skalert",
		stretchTypeMinMax: "MinMaks",
		stretchTypePercentMinMax: "ProsentMinMaks",
		stretchTypeSigmoid: "Sigmoid",
		stretchTypeStdDev: "StdDev",
		hillshadeTypeSimple: "Tradisjonell",
		hillshadeTypeMultidirectional: "Flere retninger",
		bandComboByNames: "Båndnavn",
		bandComboByWavelength: "Båndbølgelengder",
		bandComboByIDs: "Bånd-ID-er",
		missingBandActionBestMatch: "Beste treff",
		missingBandActionFail: "Feil",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Centimeter",
		unitTypeDecimeters: "Desimeter",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Fot",
		unitTypeFeetPerSec: "Fot per sekund (ft/s)",
		unitTypeInches: "Tommer",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Kilometer",
		unitTypeKmsPerHour: "Kilometer i timen (km/t)",
		unitTypeKnots: "Knop (kn)",
		unitTypeMeters: "Meter",
		unitTypeMetersPerSec: "Meter per sekund (m/s)",
		unitTypeMiles: "Miles",
		unitTypeMilesPerHour: "Miles i timen (mph)",
		unitTypeMillimeters: "Millimeter",
		unitTypeNauticalMiles: "Nautiske mil",
		unitTypeYards: "Yard",
		unitTypeDecimalDegrees: "Desimalgrader",
		unitTypePoints: "Punkter",
		unitTypeUnknown: "Ukjent",
		unitTypeSqMapUnits: "Kvadratkartenheter",
		unitTypeSqMiles: "Kvadratmiles",
		unitTypeSqKms: "Kvadratkilometer",
		unitTypeAcres: "Dekar",
		unitTypeHectares: "Hektar",
		unitTypeSqYards: "Kvadratyard",
		unitTypeSqFt: "Kvadratfot",
		unitTypeSqInches: "Kvadrattommer",
		unitTypeSqMts: "Kvadratmeter",
		unitTypeSqCms: "Kvadratcentimeter",
		unitTypeSqMms: "Kvadratmillimeter",
		cellsizeTypeFirst: "Først av",
		cellsizeTypeMin: "Min. av",
		cellsizeTypeMax: "Maks. av",
		cellsizeTypeMean: "Gjennomsnitt av",
		cellsizeTypeLast: "Sist av",
		extentTypeFirst: "Først av",
		extentTypeIntersection: "Skjæringspunkt av",
		extentTypeUnion: "Union av",
		extentTypeLast: "Sist av",
		noDataInterpretAny: "Finn noen",
		noDataInterpretAll: "Finn alle",
		curvatureTypeStandard: "Standard",
		curvatureTypeProfile: "Profil",
		curvatureTypePlanform: "Planform",
		filterTypeLineDetectionHorizontal: "Linjedeteksjon horisontal",
		filterTypeLineDetectionVertical: "Linjedeteksjon vertikal",
		filterTypeLineDetectionLeftDiagonal: "Linjedeteksjon venstre diagonal",
		filterTypeLineDetectionRightDiagonal: "Linjedeteksjon høyre diagonal",
		filterTypeGradientNorth: "Helning nord",
		filterTypeGradientWest: "Helning vest",
		filterTypeGradientEast: "Helning øst",
		filterTypeGradientSouth: "Helning sør",
		filterTypeGradientNorthEast: "Helning nordøst",
		filterTypeGradientNorthWest: "Helning nordvest",
		filterTypeSmoothArithmeticMean: "Jevn aritmetisk middelverdi",
		filterTypeSmoothing3x3: "Utjevner 3x3",
		filterTypeSmoothing5x5: "Utjevner 5x5",
		filterTypeSharpening3x3: "Skjerper 3x3",
		filterTypeSharpening5x5: "Skjerper 5x5",
		filterTypeLaplacian3x3: "Laplace-fordeling 3x3",
		filterTypeLaplacian5x5: "Laplace-fordeling 5x5",
		filterTypeSobelHorizontal: "Sobel horisontal",
		filterTypeSobelVertical: "Sobel vertikal",
		filterTypeSharpen: "Skjerp",
		filterTypeSharpen2: "Gjør enda skarpere",
		filterTypePointSpread: "Punktspredning",
		userDefined: "Brukerdefinert",
		ContourTypeLines: "Konturlinjer",
		ContourTypeFill: "Konturfylling",
		ContourTypeSmoothOnly: "Bare glatt overflate",
		rasterizeFirst: "Første",
		rasterizeLast: "Siste",
		rasterizeSmallest: "Minst",
		rasterizeLargest: "Størst",
		resamplingTypeNearest: "Nærmeste nabo",
		resamplingTypeBilinear: "Bilineær interpolasjon",
		resamplingTypeCubic: "Kubisk konvolusjon",
		resamplingTypeMajority: "Majoritet",
		resamplingTypeBilinearPlus: "Bilineær interpolasjon pluss",
		resamplingTypeGauss: "Gaussisk uskarphet",
		resamplingTypeGaussPlus: "Gaussisk uskarphet pluss",
		resamplingTypeAverage: "Gjennomsnitt",
		resamplingTypeMinimum: "Minimum",
		resamplingTypeMaximum: "Maksimum",
		resamplingTypeVectorAvg: "Vektorgjennomsnitt",
		minimum: "Minimum",
		maximum: "Maksimum",
		mean: "Gjennomsnitt",
		stdDeviation: "Standardavvik",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Størrelse-Retning",
		unknown: "Ukjent",
		angleRefSysGeographic: "Geografisk",
		angleRefSysArithmetic: "Aritmetisk",
		interpolateIrregularDataNearest: "Nærmeste nabo",
		interpolateIrregularDataBilinear: "Bilineær",
		interpolateIrregularDataTinningLinear: "Trianguler lineært",
		interpolateIrregularDataTinningNaturalNeighbor: "Naturlig nabo",
		interpolateIrregularDataTinningIDW: "Vektet invers avstand",
		esriRasterThresholdTypeConstant: "Konstant",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "Arg maks.",
		argStatsTypeMin: "Arg min.",
		argStatsTypeMedian: "Arg median",
		argStatsTypeDuration: "Varighet",
		arithmeticOpPlus: "Pluss",
		arithmeticOpMinus: "Minus",
		arithmeticOpMultiply: "Multipliser",
		arithmeticOpDivide: "Dele på",
		arithmeticOpPower: "Potens",
		arithmeticOpMode: "Modus",
		clipTypeOutside: "Klipp utenfor",
		clipTypeInside: "Klipp innenfor",
		yes: "Ja",
		no: "Nei",
		densities: "Tettheter",
		expectedCounts: "Forventet antall",
		planar: "Plant",
		geodesic: "Geodetisk",
		eachCell: "Hver celle",
		eachZone: "Hver sone",
		bestSingle: "Beste enkeltforekomst",
		allSightlines: "Alle siktelinjer",
		perimeterSightlines: "Perimetersiktelinjer",
		frequency: "Frekvens",
		observers: "Observatører",
		majority: "Majoritet",
		median: "Median",
		minority: "Minoritet",
		percentile: "Persentil",
		range: "Område",
		sum: "Sum",
		variety: "Variant",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "Transformert SAVI",
		bandArithmeticMethodMSAVI: "Endret SAVI",
		bandArithmeticMethodSultan: "Sultans formel",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Jernoksid",
		ferrousMinerals: "Jernholdige mineraler",
		clayMinerals: "Leirmineral",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Kvadratrot",
		localACos: "ACos",
		localASin: "ASin",
		localATan: "ATan",
		localATanH: "ATanH",
		localAbs: "Abs",
		localBitwiseNot: "Bitwise Not",
		localBooleanNot: "Boolsk Not",
		localCos: "Cos",
		localCosH: "CosH",
		localExp: "Exp",
		localExp10: "Exp10",
		localExp2: "Exp2",
		localInt: "Int",
		localIsNull: "Is Null",
		localFloat: "Float",
		localLn: "Ln",
		localLog10: "Log10",
		localLog2: "Log2",
		localNegate: "Invertér",
		localRoundDown: "Avrund nedover",
		localRoundUp: "Avrund oppover",
		localSin: "Sin",
		localSinH: "SinH",
		localTan: "Tan",
		localTanH: "TanH",
		localACosH: "ACosH",
		localASinH: "ASinH",
		localPlus: "Pluss",
		localMinus: "Minus",
		localTimes: "ganger",
		localPower: "Potens",
		localBitwiseAnd: "Bitwise And",
		localBitwiseLeftShift: "Bitwise Left Shift",
		localBitwiseOr: "Bitwise Or",
		localBitwiseRightShift: "Bitwise Right Shift",
		localBitwiseXor: "Bitwise Xor",
		localBooleanAnd: "Boolsk And",
		localBooleanOr: "Boolsk Or",
		localBooleanXor: "Boolsk Xor",
		localDivide: "Dele på",
		localEqualTo: "Er lik",
		localGreaterThan: "Større enn",
		localGreaterThanEqual: "Større enn eller lik",
		localLessThan: "Mindre enn",
		localLessThanEqual: "Mindre enn eller lik",
		localMod: "Mod",
		localNotEqual: "Ikke lik",
		localATan2: "ATan2",
		localSquare: "Kvadrat",
		localSetNull: "Angi null",
		remapDefTypeList: "Liste",
		remapDefTypeTable: "Tabell",
		remapTableTypeSimple: "Enkel",
		remapTableTypeDynamic: "Dynamisk",
		remapTableTypeReassignment: "Overføring",
		geomCorrectionByConstZ: "Bruk konstant Z",
		geomCorrectionByDEM: "Bruk DEM",
		radarCalibBetaNought: "Beta null",
		radarCalibSigmaNought: "Sigma null",
		radarCalibGammaNought: "Gamma null",
		speckleFilterTypeLee: "Lee-filter",
		speckleFilterTypeEnhancedLee: "Forbedret Lee-filter",
		speckleFilterTypeFrost: "Frost-filter",
		speckleFilterTypeKuan: "Juan-filter",
		speckleNoiseModelMul: "Multiplikativ støy",
		speckleNoiseModelAdd: "Additiv støy",
		speckleNoiseModelAddnMul: "Additiv og multiplikativ støy",
		mosaicOpTypeFirst: "Første",
		mosaicOpTypeLast: "Siste",
		mosaicOpTypeMin: "Min",
		mosaicOpTypeMax: "Maks",
		mosaicOpTypeMean: "Gjennomsnitt",
		mosaicOpTypeBlend: "Bland",
		mosaicOpTypeSum: "Sum",
		integer: "Heltall",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Loddrett",
		horizontal: "Vannrett",
		localCellStatisticsMajority: "Majoritet",
		localCellStatisticsMax: "Maksimum",
		localCellStatisticsMean: "Gjennomsnitt",
		localCellStatisticsMedian: "Median",
		localCellStatisticsMin: "Minimum",
		localCellStatisticsMinority: "Minoritet",
		localCellStatisticsRange: "Område",
		localCellStatisticsStdDev: "Standardavvik",
		localCellStatisticsSum: "Sum",
		localCellStatisticsVariety: "Variant",
		localCellStatisticsMajorityIgnoreND: "Majoritet (ignorer NoData)",
		localCellStatisticsMaxIgnoreND: "Maksimum (ignorer NoData)",
		localCellStatisticsMeanIgnoreND: "Middelverdi (ignorer NoData)",
		localCellStatisticsMedianIgnoreND: "Median (ignorer NoData)",
		localCellStatisticsMinIgnoreND: "Minimum (ignorer NoData)",
		localCellStatisticsMinorityIgnoreND: "Minoritet (ignorer NoData)",
		localCellStatisticsRangeIgnoreND: "Område (ignorer NoData)",
		localCellStatisticsStdDevIgnoreND: "Standardavvik (ignorere NoData)",
		localCellStatisticsSumIgnoreND: "Sum (ignorer NoData)",
		localCellStatisticsVarietyIgnoreND: "Variasjon (ignorer NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Persentil (Ignorer IngenData)",
		fromSource: "Fra kilde",
		toSource: "Til kilde",
		colorspaceConversionRgbToHsv: "RGB til HSV",
		colorspaceConversionHsvToRgb: "HSV til RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Gjennomsnitt",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Rektangel",
		circleNeighborhood: "Sirkel",
		annulusNeighborhood: "Ring",
		wedgeNeighborhood: "Kile",
		irregularNeighborhood: "Uregelmessig",
		weightNeighborhood: "Vekt",
		four: "Fire",
		eight: "Åtte",
		within: "Innenfor",
		cross: "Kryss",
		addLink: "Legg til kobling",
		noLink: "Ingen kobling",
		weightedMean: "Vektet snitt",
		ls8QCBitPatternCirrus: "Landsat 8 cirrius",
		ls8QCBitPatternCloud: "Landsat 8 sky",
		ls8QCBitPatternCloudShadow: "Landsat 8 skyskygge",
		ls8QCBitPatternDesignatedFill: "Landsat 8 designert fyll",
		ls8QCBitPatternDroppedFrame: "Landsat 8 utelatt ramme",
		ls8QCBitPatternSnowIce: "Landsat 8 snø/is",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 terrengokklusjon",
		ls8QCBitPatternVegetation: "Landsat 8 vegetasjon",
		ls8QCBitPatternWater: "Landsat 8 vann",
		downStream: "Nedstrøms",
		upStream: "Oppstrøms",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Nåværende inndeling",
		allSlices: "Alle inndelinger",
		expandDistance: "AVSTAND",
		expandMorphological: "MORFOLOGISK",
		spectralProfileFile: "Spektralprofil",
		trainingFeatureFile: "Opplæringsfunksjon",
		randomDistributionTypeUniform: "Uniform",
		randomDistributionTypeUniformInteger: "Heltall",
		randomDistributionTypeNormal: "Normal",
		randomDistributionTypeExponential: "Eksponentiell",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gamma",
		randomDistributionTypeBinomial: "Binomial",
		randomDistributionTypeGeometric: "Geometrisk",
		randomDistributionTypeNegativeBinomial: "Negativ binominal",
		randomGeneratorTypeStandardCRand: "Standard C Rand",
		randomGeneratorTypeAlgorithmACM599: "ACM-innsamlet algoritme 599",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Sum",
		medainName: "Median",
		trendLinear: "Lineær",
		trendHarmonic: "Harmonisk",
		trendPolynomial: "Polynom",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Sesong-Kendall",
		dimensionByValue: "Etter verdi",
		dimensionByInterval: "Etter intervall",
		mdimDefTypeAll: "Alt",
		mdimDefTypeByValues: "By Values",
		mdimDefTypeByRanges: "By Ranges",
		mdimDefTypeByIteration: "By Iteration",
		mdimDefTypeByInterval: "Etter intervall",
		mdimDefTypeByTargetRaster: "Etter målraster",
		esriTimeUnitsHours: "Timer",
		esriTimeUnitsDays: "Dager",
		esriTimeUnitsWeeks: "Uker",
		esriTimeUnitsMonths: "Måneder",
		esriTimeUnitsYears: "År",
		esriTimeIntervalKeywordHourly: "Hver time",
		esriTimeIntervalKeywordDaily: "Daglig",
		esriTimeIntervalKeywordWeekly: "Ukentlig",
		esriTimeIntervalKeywordDekadly: "Ti dager",
		esriTimeIntervalKeywordPentadly: "Fem dager",
		esriTimeIntervalKeywordMonthly: "Månedlig",
		esriTimeIntervalKeywordQuarterly: "Kvartalsvis",
		esriTimeIntervalKeywordYearly: "Hvert år",
		esriTimeIntervalKeywordRecurringDaily: "Gjentas daglig",
		esriTimeIntervalKeywordRecurringWeekly: "Gjentas ukentlig",
		esriTimeIntervalKeywordRecurringMonthly: "Gjentas hver måned",
		esriTimeIntervalKeywordRecurringQuarterly: "Gjentas hvert kvartal",
		aggDefTypeAll: "Alle",
		aggDefTypeIntervalKeyword: "Nøkkelord for intervall",
		aggDefTypeIntervalValue: "Intervallverdi",
		aggDefTypeIntervalRanges: "Intervallområder",
		latestChange: "Time of Latest Change",
		earliestChange: "Time of Earliest Change",
		largestChange: "Time of Largest Change",
		numberOfChanges: "Number of Changes",
		longestChange: "Tidspunkt for lengste endring",
		shortestChange: "Tidspunkt for korteste endring",
		fastestChange: "Tidspunkt for raskeste endring",
		slowestChange: "Tidspunkt for langsomste endring",
		allChanges: "Alle",
		increaseChanges: "Øke",
		decreaseChanges: "Redusere",
		segmentBeginning: "Segmentets begynnelse",
		segmentEnd: "Segmentets slutt",
		esriComputeChangeMethodDifference: "Difference",
		esriComputeChangeMethodRelativeDifference: "Relative Difference",
		esriComputeChangeMethodCategorical: "Kategorisk forskjell",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Spektral euklidsk avstand",
		esriComputeChangeMethodMultispectralAngularDifference: "Spektral vinkeldifferanse",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Bånd med størst endring",
		esriComputeChangeKeepAll: "Behold alle",
		esriComputeChangeKeepChangedOnly: "Behold bare endrede piksler",
		esriComputeChangeKeepUnchangedOnly: "Behold bare uendrede piksler",
		esriComputeChangeUseColorAverage: "Gjennomsnitt Fra- og Til-farger",
		esriComputeChangeUseColorFrom: "Bruk Fra-farger",
		esriComputeChangeUseColorTo: "Bruk Til-farger",
		factorFunctionBinary: "Binær",
		factorFunctionForward: "Fremover",
		factorFunctionLinear: "Lineær",
		factorFunctionInvLinear: "Invers lineær",
		factorFunctionTable: "Tabell",
		factorFunctionSymLinear: "Symmetrisk lineær",
		factorFunctionSymInvLinear: "Symmetrisk invers lineær",
		factorFunctionCos: "Cosinus",
		factorFunctionSec: "Sekant",
		factorFunctionCosSec: "Cosinus-sekant",
		factorFunctionSecCos: "Sekant-cosinus",
		noSort: "Ikke sorter",
		ascend: "Stigende",
		descend: "Synkende",
		autoDetect: "Auto-detekter",
		nearest: "Nærmeste",
		linear: "Lineær",
		esriMonthJanuary: "Januar",
		esriMonthFebruary: "Februar",
		esriMonthMarch: "Mars",
		esriMonthApril: "April",
		esriMonthMay: "Mai",
		esriMonthJune: "Juni",
		esriMonthJuly: "Juli",
		esriMonthAugust: "August",
		esriMonthSeptember: "September",
		esriMonthOctober: "Oktober",
		esriMonthNovember: "November",
		esriMonthDecember: "Desember",
		dimensionalMovingIgnoreNoData: "Data",
		dimensionalMovingPropagateNoData: "Nodata",
		dimensionalMovingFillOnlyNoData: "Fyll ut NoData",
		circularMean: "Sirkulært gjennomsnitt",
		circularName: "Sirkulær",
		arithmeticName: "Aritmetisk",
		slopeName: "Helling",
		aspectName: "Hellingsretning",
		meanCurvature: "Gjennomsnittlig kurvatur",
		profileCurvature: "Profil (normal hellingslinje) kurvatur",
		tangentialCurvature: "Tangentiell (normal kontur) kurvatur",
		planCurvature: "Plan (projisert kontur) kurvatur",
		contourGeodesicTorsion: "Kontur geodetisk torsjon",
		gaussianCurvature: "Gauss-kurvatur",
		casoratiCurvature: "Casorati-kurvatur",
		localSurfaceTypeQuadratic: "Kvadratisk",
		localSurfaceTypeBiquadratic: "Bikvadratisk",
		thresholdNoThreshold: "Ingen terskel",
		thresholdPercentLeastCost: "Prosent minst kostnad",
		thresholdAccumulativeCost: "Kumulativ kostnad",
		clrmapTypeHillshade: "Hillshade"
	},
	categoryLabels: {
		sourceCharacteristics: "Kildekarakteristikk",
		neighborhoodSettings: "Nabolagsinnstillinger",
		statistics: "Statistikk",
		gamma: "Gamma",
		viewshedParameters: "Synsfeltparametere",
		observerParameters: "Observatørparametere",
		irregularDataInterpolation: "Uregelmessig datainterpolering",
		modelStatistics: "Modellstatistikk",
		aggregationDef: "Aggregeringsdefinisjon",
		filterByAttributes: "Filtrer etter attributter",
		percentileName: "Persentil",
		rasterInfo: "Rasterinformasjon",
		extent: "Omfang",
		spatialReference: "Romlig referanse"
	},
	outputRasterHelpTexts: {
		outputName: "<p>Navnet på laget som opprettes og legges til kartet.</p>",
		resultType: "<p>Typen utdata som blir opprettet. Utdataene kan være flisinndelte bildelag eller dynamiske bildelag.</p>",
		saveResultIn: "<p>Navnet på mappen i <b>Mitt innhold</b> der resultatet blir lagret.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Miljøinnstillinger for analyse i Map Viewer. </p>",
		outSR: "<p>Angir koordinatsystemet for analyser og resultatlaget.</p>",
		extent: "<p>Angir området som skal brukes til analyse.</p>",
		snapRaster: "<p>Justerer utstrekningen for utdataene slik at den samsvarer med cellejusteringen i det angitte forankringsrasterlaget.</p>",
		cellSize: "<p>Angir cellestørrelsen eller oppløsningen som blir brukt til analyser og til å opprette utdatarasterlaget.</p>",
		mask: "<p>Angir et maskelag der bare cellene som er innenfor maskeområdet, brukes til analyse.</p>",
		resamplingMethod: "<p>Angir hvordan pikselverdier skal interpoleres når inndata- og utdatarasterene ikke er på linje.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Typen støttes ikke",
		currentlyUnsupported: " Et standardredigeringsprogram for ${missingType} er under arbeid og kommer snart. Midlertidig plassholdertekstboks for å angi strengbaserte inndata.",
		unsupportedOverrideWarning: "En overstyrende komponent for redigeringsprogrammet som gir bedre UX for å jobbe med følgende parameter(e) er under arbeid, og kommer snart:",
		overrideWidgetMissing: "Komponent for overstyrende redigeringsprogram mangler!",
		uiIncomplete: "Jobbinnsendingen mislyktes. Funksjonen kan ikke kjøres fordi noen av de påkrevde feltene er ufullstendige eller mangler fra UI-et.",
		count: "Antall",
		selectVariables: "Velg variabler",
		selectFeature: "Velg et geoobjektlag",
		greaterThanErrorMessage: "Det angitte tallet må være høyere enn ${min}",
		lesserThanErrorMessage: "Det angitte tallet må være lavere enn ${max}",
		greaterThanOrEqualErrorMessage: "Det angitte tallet må være større enn eller lik ${min}",
		lesserThanOrEqualErrorMessage: "Det angitte tallet må være lavere enn eller lik ${max}",
		allowScalar: "Velg et lag eller angi en konstant",
		selectField: "Velg felt",
		parameterRequired: "Denne parameteren kreves.",
		enterAValue: "Angi en verdi...",
		invalidInput: "Den angitte verdien er ugyldig.",
		itemNotFound: "Elementet eksisterer ikke eller er utilgjengelig.",
		itemPermissionDenied: "Du har ikke tillatelser til å bruke dette elementet.",
		layerNotAvailable: "Kan ikke laste inn laget ${layerName}.",
		multipleLayersNotAvailable: "Kan ikke laste inn laget ${layerName} og andre.",
		learnMoreLabel: "Få mer informasjon",
		fieldNotAvailable: "Kan ikke laste inn feltet.",
		allowAnalysis: "Analyse er ikke tillatt på bildetjenesten.",
		allowAnalysisReason: "Ett eller flere lag fra kartet vises ikke her fordi de ikke tillater analyse.",
		learnMoreText: "Mer informasjon",
		atLeastOneRasterInput: "Minst ett inndatalag må være et rasterlag.",
		browseAnalysisLayers: "Bla gjennom lag",
		activeMapViewExtent: "Bruk den gjeldende kartutstrekningen",
		chooseRaster: "Velg Klipperaster",
		chooseGeometry: "Velg Geometri for utklipp",
		resultType: "Resultattype",
		saveInFolder: "Lagre i mappe",
		outputName: "Navn på utdata",
		outputLayerType: "Utdatalagtype",
		dynamicImageryLayer: "Dynamisk bildelag",
		tiledImageryLayer: "Flisinndelt bildelag",
		custom: "Tilpasset",
		loading: "Laster inn...",
		layerMissing: "Ett eller flere lag fra kartet vises ikke her fordi de ikke tillater analyse. Lær mer.",
		browseCoordinateSystems: "Bla gjennom koordinatsystemer",
		unableToRepopulateOutSR: "Kan ikke fylle ut koordinatsystemet for utdata.",
		defaultTitle: "Vis mer",
		"ARC (equal arc-second)": "ARC (lik bue-sekund)",
		Africa: "Afrika",
		Antarctica: "Antarktis",
		Argentina: "Argentina",
		Asia: "Asia",
		"Asteroid Belt": "Asteroidebelte",
		"Atlantic Ocean": "Atlanterhavet",
		Australia: "Australia",
		"Australia and New Zealand": "Australia og New Zealand",
		Austria: "Østerrike",
		"BLM (US Feet)": "BLM (amerikanske fot)",
		Bangladesh: "Bangladesh",
		"Beijing 1954": "Beijing 1954",
		Bhutan: "Bhutan",
		CGCS2000: "CGCS2000",
		Canada: "Kanada",
		Caribbean: "Karibia",
		"Caribbean Sea": "Det karibiske hav",
		"Central America": "Sentral-Amerika",
		"Central and North America": "Sentral- og Nord-Amerika",
		Colombia: "Colombia",
		Continental: "Kontinental",
		"County Systems": "Fylkessystemer",
		"Democratic Republic of the Congo": "Den demokratiske republikken Kongo",
		"EPSG Arctic": "EPSG Arctic",
		Earth: "Jorden",
		"Ellipsoidal-based": "Ellipsoidebasert",
		Europe: "Europa",
		Finland: "Finland",
		France: "Frankrike",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss Kruger",
		"Geographic Coordinate Systems": "Geografiske koordinatsystemer",
		Germany: "Tyskland",
		"Gravity-related": "Gravitasjonsrelatert",
		"Greenwich-based": "Greenwich-basert",
		"Highways England": "Hovedveier England",
		Illinois: "Illinois",
		"Indian Ocean": "Det indiske hav",
		"Indian Subcontinent": "Det indiske subkontinent",
		Indiana: "Indiana",
		Indonesia: "Indonesia",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irland og Storbritannia",
		Italy: "Italia",
		Japan: "Japan",
		Jupiter: "Jupiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Libya",
		Malaysia: "Malaysia",
		"Malaysia and Singapore": "Malaysia og Singapore",
		Mars: "Mars",
		Mercury: "Merkur",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (amerikanske fot)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (internasjonale fot)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (meter)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (amerikanske fot)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (internasjonale fot)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (meter)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (amerikanske fot)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (internasjonale fot)",
		"NAD 1983 (Meters)": "NAD 1983 (meter)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (meter)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (amerikanske fot)",
		"NAD 1983 (US Feet)": "NAD 1983 (amerikanske fot)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (internasjonale fot)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (meter)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (amerikanske fot)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (internasjonale fot)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (meter)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (amerikanske fot)",
		"National Grids": "Nasjonale rutenett",
		Navajo: "Navajo",
		Neptune: "Neptun",
		"New Beijing": "New Beijing",
		"New Zealand": "New Zealand",
		"North America": "Nord-Amerika",
		"Northern Hemisphere": "Nordlige halvkule",
		Norway: "Norge",
		Oceans: "Hav",
		Oregon: "Oregon",
		"Other GCS": "Andre GCS",
		"Pacific Ocean": "Stillehavet",
		Pluto: "Pluto",
		Polar: "Polar",
		Portugal: "Portugal",
		"Projected Coordinate Systems": "Projiserte koordinatsystemer",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Erstattet",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturn",
		"Solar System": "Solsystem",
		"South Africa": "Sør-Afrika",
		"South America": "Sør-Amerika",
		"South Korea": "Sør-Korea",
		"Southern Hemisphere": "Sørlige halvkule",
		"Spheroid-based": "Sfæroidebasert",
		"State Plane": "Delstatplan",
		"State Systems": "Delstatsystemer",
		Sweden: "Sverige",
		"Switzerland and Liechtenstein": "Sveits og Liechtenstein",
		Texas: "Texas",
		Tribal: "Stamme",
		Turkey: "Tyrkia",
		"US Feet": "Amerikanske fot",
		"USA and territories": "USA med territorier",
		UTM: "UTM",
		Ukraine: "Ukraina",
		"Unknown Height Systems": "Ukjente høydesystemer",
		Uranus: "Uranus",
		Venus: "Venus",
		"Vertical Coordinate Systems": "Vertikale koordinatsystemer",
		Vietnam: "Vietnam",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Verden",
		"World (Sphere-based)": "Verden (sfærebasert)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Ferdig",
		noResults: "Finner ingen resultater",
		searchPlaceholder: "Navn eller WKID",
		browseTemplate: "Bla gjennom rasterfunksjonsmaler",
		saveTemplate: "Lagre rasterfunksjonsmal",
		preview: "Forhåndsvisning",
		previewDescription: "Forhåndsvis resultatene før du kjører analysen.",
		showPreview: "Vis forhåndsvisning",
		previewLayer: "Forhåndsvis laget ${number}",
		newPreview: "Ny forhåndsvisning",
		previewPopup: "Aktiver forhåndsvisning av analyseresultatene basert på inndataparameterne.",
		updatePreviewLayer: "Oppdater det valgte forhåndsvisningslaget",
		createPreviewLayer: "Opprett nytt forhåndsvisningslag",
		maximumPreviewAllowed: "Maks. antall tillatte forhåndsvisningslag: ${maxCount}",
		previewFailure: "Dette forhåndsvisningslaget er ikke tilgjengelig. Kontroller inndataparameterne, og oppdater dette forhåndsvisningslaget igjen.",
		header: "Velg element",
		content: "Du har endringer som ikke er lagret, i ${rftTitle}. Hvis du begynner på nytt med en ny mal, går disse endringene tapt.",
		dontSave: "Ikke lagre",
		"continue": "Fortsett",
		stretch: "Tilpass til vindu",
		pan: "Panorer",
		newTemplate: "Opprett ny mal",
		openTemplate: "Åpne mal",
		addFunction: "Legg til rasterfunksjoner",
		addConstant: "Legg til konstant",
		addRaster: "Legg til rastervariabel",
		move: "Flytt",
		zoom: "Zoom",
		saveAs: "Lagre som",
		clear: "Fjern",
		addRasterFunctionTitle: "Legg til rasterfunksjoner",
		templatePropertiesTitle: "Egenskaper for mal",
		browseRFT: "Bla gjennom rasterfunksjonsmaler",
		defaultToolDescription: "${toolTitle} analyseverktøy.",
		openToolText: "Åpne verktøy",
		toolDropdownText: "Rullegardinliste for verktøy",
		addToMap: "Bekreft og legg til kart",
		confirm: "Bekreft",
		select: "Velg",
		selectTask: "Velg oppgave",
		unsupportedLayer: "Denne parameteren støtter ikke følgende lag: ${layerName}.",
		viewDetails: "Vis fullstendige elementdetaljer",
		rename: "Gi nytt navn",
		duplicate: "Dupliser",
		launch: "Åpne for å kjøre",
		templateEditor: "Malredigering",
		createItem: "Lagre rasterfunksjonsmal",
		actionLabel: "Filter",
		filterPopoverHeading: "Filtrer funksjonene",
		defaultSearchPlaceholder: "Søk etter navn",
		settings: "Innstillinger",
		summary: "Sammendrag",
		definitionQuery: "Definisjonsspørring",
		matchVariables: "Match variabler",
		unionDimension: "Unionmål",
		nameEditorPlaceholder: "Angi tittel",
		summaryEditorPlaceholder: "Angi en kort beskrivelse.",
		definitionQueryPlaceholder: "Angi...",
		upload: "Opplasting",
		chooseImage: "Klikk for å velge en fil",
		update: "Oppdater",
		thumbnailErrors: {
			wrongImageType: "Feil bildetype valgt",
			notAvailable: "Miniatyrbilde ikke tilgjengelig",
			loadError: "Kan ikke laste inn bildet",
			chooseFile: "Klikk for å velge fil"
		}
	}
};
const copy = "Kopier";
const save = "Lagre";
const title = "Tittel";
const folder = "Mappe";
const tags = "Tagger";
const savingMessage = "Lagrer element til";
const shareWith = "Del med";
const share = "Dele";
const setSharingLevel = "Angi delingsnivå";
const setGroupSharing = "Angi gruppedeling";
const owner = "Eier";
const organization = "Organisasjon";
const everyone = "Alle (offentlig)";
const groups = "Grupper:";
const type = "Type";
const mosaic = "Mosaikk";
const itemGroup = "Elementgruppe";
const item = "Element";
const definitionQuery = "Definisjonsspørring";
const groupItemsBy = "Grupper elementer etter";
const groupFieldName = "Grupper feltnavn";
const tagFieldName = "Tagg feltnavn";
const noTitleTagErrorMsg = "Du må angi en tittel på elementet og tagger slik at det er mulig å finne kartet gjennom søk.";
const noTitleErrorMsg = "Du må oppgi en tittel for elementet ditt.";
const noTagErrorMsg = "Du må angi minst én tagg for at folk skal kunne finne element ditt gjennom søk.";
const error = "Feil";
const warning = "Advarsel";
const success = "Vellykket";
const details = "Detaljer:";
const tryAgain = "Prøv på nytt";
const toolModeler = {
	save: "Lagre",
	editProperties: "Rediger egenskaper",
	saveAs: "Lagre som",
	savingNotification: "Lagrer endringer til element...",
	savingTitle: "Lagrer",
	saveFailedMessage: "Endringene ble ikke lagret.",
	saveWithErrorsMessage: "Endringer ble lagret med følgende feil.",
	viewItemMessage: "Vis lagret element",
	here: "her.",
	itemCreatedMessage: "Et nytt element ble opprettet",
	clickToViewItemMessage: "Klikk på OK for å vise elementdetaljsiden, og klikk på Avbryt for å fortsette.",
	readingFailed: "Kan ikke laste inn valgt rasterfunksjonsmal.",
	failedToLoadXML: "Kan ikke laste inn valgt rasterfunksjonsmal i XML-format.",
	learnMore: "Mer informasjon",
	overwriteTitle: "Bekreft overskriving",
	overwriteMessage: "Vil du overskrive eksisterende element?",
	overwriteSuccessMessage: "Elementet ble oppdatert."
};
const toolEditor = {
	run: "Kjør",
	save: "Lagre",
	deleteSelected: "Slett valgte elementer",
	addRaster: "Legg til raster",
	addScalar: "Legg til skalar",
	layout: "Automatisk oppsett",
	errorTitle: "Feil",
	invalidToolMessage: "Rasterfunksjonsmal er ikke gyldig.",
	out: "Ut",
	zoomIn: "Zoom inn",
	zoomOut: "Zoom ut",
	zoomToFit: "Tilpass til vindu",
	panOn: "Bytt til panoreringsmodus",
	panOff: "Slå av panoreringsmodus",
	defaultModelName: "Vertøymodell",
	defaultRasterName: "Raster"
};
const toolDetailsEditor = {
	defaultToolName: "Rasterfunksjonsmal",
	defaultToolDescription: "Legg til et kort sammendrag for rasterfunksjonen.",
	defaultHelpText: "Klikk på Hjelp-ikonet for å redigere hjelpeteksten.",
	editHelpTitle: "Rediger hjelp",
	saveLabel: "Lagre",
	cancelLabel: "Avbryt",
	thumbnail: {
		wrongImageType: "Feil bildetype er valgt",
		notAvailable: "Miniatyrbilde ikke tilgjengelig",
		loadError: "Kan ikke laste inn bildet",
		chooseFile: "Klikk for å velge fil"
	}
};
const saveUtils = {
	thumbnail: "Miniatyrbilde",
	sharing: "Deling"
};
const close = "Lukk";
const unsavedWarningExisting = "Vil du lagre endringene til elementet <b>${itemTitle}</b> ?";
const unsavedWarningNew = "Vil du lagre endringene?";
const saveAs = "Lagre som";
const dontSave = "Ikke lagre";
const unsavedTitle = "Ulagrede endringer";
const invalidRFTMessage = "Den opprettede rasterfunksjonsmalen er ikke gyldig.";
const errorTitle = "Feil";
const breadcrumb = "Rasterfunksjonsredigering";
const breadcrumbEditor = "Innhold > Rasterfunksjonsredigering";
const viewerModeTitle = "Skrivebeskyttet";
const viewerModeMessage = "Rasterfunksjonsmalelementet er skrivebeskyttet. Endringer kan ikke lagres.";
const userStartDirection = "Velg en funksjon for å starte opprettingen av en rasterfunksjonsmal.";
const selectFunction = "Legg til funksjon";
const deselectFunction = "Fjern funksjon";
const dialogTitle = "System";
const category = "Kategorier";
const search = "Søk i rasterfunksjoner";
const categoryNames = {
	analysis: "Analyse",
	appearance: "Utseende",
	classification: "Klassifisering",
	conversion: "Konvertering",
	correction: "Korrigering",
	dataManagement: "Databehandling",
	distance: "Avstand",
	distanceLegacy: "Avstand (utfaset)",
	hydrology: "Hydrologi",
	math: "Matematikk",
	mathConditional: "Matematikk: Betingelse",
	mathLogical: "Matematikk: Logikk",
	mathTrigonometric: "Matematikk: Trigonometrisk",
	reclass: "Reklassifisering",
	statistical: "Statistikk",
	surface: "Overflate"
};
const commonStrings_nb = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_nb);


//# sourceMappingURL=common-strings.nb-5ec43a4b.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLWYzNTE3NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMlZBQTJWLDRIQUE0SCxpREFBaUQ7QUFDeGdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SUFBeUk7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHE1RkFBcTVGLE9BQU87QUFDNTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSw4REFBOEQsYUFBYTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsSUFBSTtBQUN4RSxtRUFBbUUsSUFBSTtBQUN2RSxxRkFBcUYsSUFBSTtBQUN6RixvRkFBb0YsSUFBSTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNELDBEQUEwRCxXQUFXO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsU0FBUztBQUNoRjtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsVUFBVTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsVUFBVTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGdCQUFnQixFQUFDO0FBQ2lvQzs7QUFFanFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vY29tbW9uLXN0cmluZ3MubmItNWVjNDNhNGIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb2sgPSBcIk9LXCI7XG5jb25zdCBjYW5jZWwgPSBcIkF2YnJ5dFwiO1xuY29uc3QgZW50ZXJVUkwgPSBcIkFuZ2kgVVJMIGZvciBiaWxkZXRqZW5lc3RlXCI7XG5jb25zdCBzZXJ2aWNlVVJMID0gXCJUamVuZXN0ZS1VUkxcIjtcbmNvbnN0IHNlbGVjdFJhc3RlciA9IFwiVmVsZyByYXN0ZXJcIjtcbmNvbnN0IGZhaWxlZFRvTG9hZExheWVyID0gXCJLYW4gaWtrZSBsYXN0ZSBpbm4gbGFnXCI7XG5jb25zdCBsb2FkaW5nTGF5ZXIgPSBcIkxhc3RlciBpbm4gbGFnXCI7XG5jb25zdCBzZWxlY3RGZWF0dXJlID0gXCJWZWxnIGdlb29iamVrdGxhZ1wiO1xuY29uc3QgZW50ZXJGVVJMID0gXCJBbmdpIFVSTCBmb3IgZ2Vvb2JqZWt0dGplbmVzdGUuXCI7XG5jb25zdCBhZGRSYXN0ZXIgPSBcIkxlZ2cgdGlsIHJhc3RlcnZhcmlhYmVsXCI7XG5jb25zdCBhZGRTY2FsYXIgPSBcIkxlZ2cgdGlsIGtvbnN0YW50XCI7XG5jb25zdCByYXN0ZXIgPSBcIlJhc3RlclwiO1xuY29uc3Qgc2NhbGFyID0gXCJTa2FsYXJcIjtcbmNvbnN0IGRlZmF1bHRNb2RlbE5hbWUgPSBcIlJhc3RlcmZ1bmtzam9uc21hbFwiO1xuY29uc3QgZ2VuZXJhbCA9IFwiR2VuZXJlbHRcIjtcbmNvbnN0IHBhcmFtZXRlcnMgPSBcIlBhcmFtZXRlcmVcIjtcbmNvbnN0IHZhcmlhYmxlcyA9IFwiVmFyaWFibGVyXCI7XG5jb25zdCBuYW1lID0gXCJOYXZuXCI7XG5jb25zdCBkZXNjcmlwdGlvbiA9IFwiQmVza3JpdmVsc2VcIjtcbmNvbnN0IHBhcmFtZXRlciA9IFwiUGFyYW1ldGVyXCI7XG5jb25zdCBpc1B1YmxpYyA9IFwiSXNQdWJsaWNcIjtcbmNvbnN0IGlzRGF0YXNldCA9IFwiSXNEYXRhc2V0XCI7XG5jb25zdCB1bmtub3duUGl4ZWxUeXBlID0gXCJVa2plbnRcIjtcbmNvbnN0IG91dHB1dFBpeGVsVHlwZSA9IFwiVXRkYXRhcGlrc2VsdHlwZVwiO1xuY29uc3QgdThQaXhlbFR5cGUgPSBcIjggYml0IHVzaWduZXJ0XCI7XG5jb25zdCBzOFBpeGVsVHlwZSA9IFwiOCBiaXQgc2lnbmVydFwiO1xuY29uc3QgdTE2UGl4ZWxUeXBlID0gXCIxNiBiaXQgdXNpZ25lcnRcIjtcbmNvbnN0IHMxNlBpeGVsVHlwZSA9IFwiMTYgYml0IHNpZ25lcnRcIjtcbmNvbnN0IHUzMlBpeGVsVHlwZSA9IFwiMzIgYml0IHVzaWduZXJ0XCI7XG5jb25zdCBzMzJQaXhlbFR5cGUgPSBcIjMyIGJpdCBzaWduZXJ0XCI7XG5jb25zdCBmMzJQaXhlbFR5cGUgPSBcIjMyIGJpdCBmbHl0ZW5kZVwiO1xuY29uc3QgZjY0UGl4ZWxUeXBlID0gXCI2NCBiaXQgZG9iYmVsdFwiO1xuY29uc3QgcHJvcGVydGllcyA9IFwiRWdlbnNrYXBlclwiO1xuY29uc3QgbXVsdGlkaW1lbnNpb25hbFJ1bGVzID0gXCJNdWx0aWRpbWVuc2lvbmFsIFJ1bGVzXCI7XG5jb25zdCBtYXRjaFZhcmlhYmxlcyA9IFwiTWF0Y2ggVmFyaWFibGVzXCI7XG5jb25zdCB1bmlvbkRpbWVuc2lvbnMgPSBcIlVuaW9uLWRpbWVuc2pvbmVyXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbkVkaXRvciA9IHtcblx0aW52YWxpZFJGVE1lc3NhZ2U6IFwiUmFzdGVyZnVua3Nqb25zbWFsZW4gZXIgaWtrZSBneWxkaWcuXCIsXG5cdHJmeEFyZ3NFZGl0b3I6IHtcblx0XHRvdXRwdXRSYXN0ZXI6IFwiVXRkYXRhUmFzdGVyXCIsXG5cdFx0cmFzdGVyOiBcIlJhc3RlclwiLFxuXHRcdHVuc3VwcG9ydGVkRGF0YVR5cGVXYXJuaW5nOiBcIkbDuGxnZW5kZSBhcmd1bWVudGVyIHZpc2VzIGlra2UsIGV0dGVyc29tIGRlIGlra2Ugc3TDuHR0ZXMgZm9yIMO4eWVibGlra2V0LlwiLFxuXHRcdHVuc3VwcG9ydGVkRnVuY3Rpb246IFwiSW5uZWhvbGRlciByYXN0ZXJmdW5rc2pvbihlcikgc29tIGZvciB0aWRlbiBpa2tlIHN0w7h0dGVzLlwiXG5cdH0sXG5cdHJmeFJhc3RlcklucHV0OiB7XG5cdFx0c2VsZWN0TGF5ZXI6IFwiVmVsZyBsYWdcIixcblx0XHRicm93c2VMYXllcnM6IFwiQmxhIGdqZW5ub20gbGFnXCIsXG5cdFx0cmZ4VmFyaWFibGU6IFwiUmFzdGVyRnVuY3Rpb25WYXJpYWJsZVwiXG5cdH0sXG5cdHJmeEJhbmRDb21iaW5hdGlvbkVkaXRvcjoge1xuXHRcdG1ldGhvZExhYmVsOiBcIk1ldG9kZVwiLFxuXHRcdGJhbmRMYWJlbDogXCJCw6VuZFwiLFxuXHRcdGNvbWJpbmF0aW9uTGFiZWw6IFwiS29tYmluYXNqb25cIlxuXHR9LFxuXHRyZnhSZW1hcEdyaWQ6IHtcblx0XHRtaW5pbXVtOiBcIk1pbmltdW1cIixcblx0XHRtYXhpbXVtOiBcIk1ha3NpbXVtXCIsXG5cdFx0b3V0cHV0OiBcIlJlc3VsdGF0XCIsXG5cdFx0bm9EYXRhOiBcIk5vZGF0YVwiLFxuXHRcdHJlbWFwVmFsdWVzTGFiZWw6IFwiVGlsb3JkbmUgdmVyZGllciBww6Ugbnl0dFwiXG5cdH0sXG5cdHJmeE5hbWVkUmFzdGVyRWRpdG9yOiB7XG5cdFx0cmFzdGVyVmFyaWFibGVzOiBcIlJhc3RlcnZhcmlhYmxlclwiLFxuXHRcdGRlbGV0ZVNlbGVjdGVkVmFyczogXCJGamVybiB2YWxndGUgdmFyaWFibGVyXCJcblx0fSxcblx0cmZ4Q2xpcHBpbmdHZW9tZXRyeToge1xuXHRcdGNsaXBwaW5nTGF5ZXI6IFwiS2xpcHBlbGFnXCIsXG5cdFx0Y2xpcHBpbmdSYXN0ZXI6IFwiS2xpcHBlcmFzdGVyXCIsXG5cdFx0Y2xpcHBpbmdHZW9tZXRyeTogXCJHZW9tZXRyaSBmb3IgdXRrbGlwcFwiLFxuXHRcdGN1c3RvbUV4dGVudDogXCJFZ2VuZGVmaW5lcnQgdXRzdHJla25pbmdcIixcblx0XHRvdXRwdXRFeHRlbnQ6IFwiVXRkYXRhb21mYW5nXCIsXG5cdFx0Y3VycmVudEV4dGVudDogXCJHamVsZGVuZGUga2FydHV0c3RyZWtuaW5nXCIsXG5cdFx0ZHJhd0xhYmVsOiBcIlRlZ25cIlxuXHR9LFxuXHRyZnhDdXN0b21FeHRlbnQ6IHtcblx0XHR0b3A6IFwiVG9wcFwiLFxuXHRcdHJpZ2h0OiBcIkjDuHlyZVwiLFxuXHRcdGJvdHRvbTogXCJCdW5uXCIsXG5cdFx0bGVmdDogXCJWZW5zdHJlXCJcblx0fSxcblx0cmZ4UmFzdGVyQXJyYXlFZGl0b3I6IHtcblx0XHRtb3ZlVXA6IFwiRmx5dHQgb3BwXCIsXG5cdFx0bW92ZURvd246IFwiRmx5dHQgbmVkXCIsXG5cdFx0cmVtb3ZlOiBcIkZqZXJuXCJcblx0fSxcblx0cmZ4U3RhdGlzdGljc0dyaWQ6IHtcblx0XHRzdGREZXY6IFwiU3RkLiBEZXZcIixcblx0XHRtaW46IFwiTWluXCIsXG5cdFx0bWF4OiBcIk1ha3NcIixcblx0XHRtZWFuOiBcIkdqZW5ub21zbml0dFwiXG5cdH0sXG5cdHJmeFdlaWdodGVkU3VtVGFibGVFZGl0b3I6IHtcblx0XHR3ZWlnaHRlZFN1bVRhYmxlOiBcIlZla3RldCBzdW0tdGFiZWxsXCIsXG5cdFx0aWQ6IFwiSURcIixcblx0XHRsYXllcjogXCJMYWdcIixcblx0XHRmaWVsZDogXCJGZWx0XCIsXG5cdFx0d2VpZ2h0OiBcIlZla3RcIixcblx0XHR2YWx1ZTogXCJWZXJkaVwiLFxuXHRcdHNlbGVjdExheWVyOiBcIlZlbGcgbGFnXCJcblx0fSxcblx0cmZ4V2VpZ2h0ZWRPdmVybGF5VGFibGVFZGl0b3I6IHtcblx0XHR3ZWlnaHRlZE92ZXJsYXlUYWJsZTogXCJWZWt0ZXQgb3ZlcmxlZ2dzdGFiZWxsXCIsXG5cdFx0aWQ6IFwiSURcIixcblx0XHRsYXllcjogXCJMYWdcIixcblx0XHRmaWVsZDogXCJGZWx0XCIsXG5cdFx0aW5mbHVlbmNlOiBcIlDDpXZpcmtuaW5nXCIsXG5cdFx0c3VtT2ZJbmZsdWVuY2U6IFwiU3VtIGF2IHDDpXZpcmtuaW5nXCIsXG5cdFx0dmFsdWU6IFwiVmVyZGlcIixcblx0XHRyZW1hcFRhYmxlOiBcIlRpbG9yZG5lIHRhYmVsbCBww6Ugbnl0dFwiLFxuXHRcdHNjYWxlOiBcIk3DpWxlc3Rva2tcIixcblx0XHRzY2FsZXM6IFwiTcOlbGVzdG9ra2VyXCIsXG5cdFx0c2VsZWN0UmFzdGVyOiBcIlZlbGcgcmFzdGVyXCJcblx0fSxcblx0cmZ4RmVhdHVyZVNlbGVjdDoge1xuXHRcdGFkZEZlYXR1cmVMYXllcjogXCJCbGEgZ2plbm5vbSBldHRlciBnZW9vYmpla3RsYWdcIixcblx0XHRhZGRQb2ludExheWVyOiBcIkJsYSBnamVubm9tIGV0dGVyIHB1bmt0bGFnXCJcblx0fSxcblx0cmZ4RmllbGRTZWxlY3Q6IHtcblx0XHR2YWx1ZTogXCJWZXJkaVwiLFxuXHRcdGNvdW50OiBcIkFudGFsbFwiXG5cdH0sXG5cdHJmeEF0dHJpYnV0ZVRhYmxlOiB7XG5cdFx0dGFibGVUeXBlOiBcIlRhYmVsbHR5cGVcIixcblx0XHRtYW51YWw6IFwiTWFudWVsbFwiLFxuXHRcdGV4dGVybmFsOiBcIkVrc3Rlcm5cIixcblx0XHRtaW5WYWw6IFwiTWluaW11bXN2ZXJkaVwiLFxuXHRcdG1heFZhbDogXCJNYWtzaW11bXN2ZXJkaVwiLFxuXHRcdGJhc2VDbGFzc05hbWU6IFwiS2xhc3NlYmFzZW5hdm5cIixcblx0XHRjb2xvclNjaGVtZTogXCJGYXJnZXZhbGdcIixcblx0XHRkZWZhdWx0Q2xhc3NOYW1lOiBcIkV0aWtldHRfXCIsXG5cdFx0Z2VuZXJhdGVUYWJsZTogXCJHZW5lcmVyIHRhYmVsbFwiLFxuXHRcdGJyb3dzZVRhYmxlOiBcIlNlIGdqZW5ub20gdGFiZWxsXCIsXG5cdFx0dmFsdWU6IFwiVmVyZGlcIixcblx0XHRjbGFzc25hbWU6IFwiS2xhc3NlbmF2blwiLFxuXHRcdGNvbG9yOiBcIkZhcmdlXCJcblx0fSxcblx0cmZ4RmllbGROdW1iZXJTd2l0Y2hhYmxlOiB7XG5cdFx0bnVtYmVyOiBcIk51bWVyaXNrXCIsXG5cdFx0ZmllbGQ6IFwiRmVsdFwiLFxuXHRcdHN0cmluZzogXCJTdHJlbmdcIixcblx0XHRsaW5lYXJVbml0OiBcIkxpbmXDpnIgZW5oZXRcIlxuXHR9LFxuXHRyZnhQcm9wZXJ0eVNldDoge1xuXHRcdG5hbWU6IFwiTmF2blwiLFxuXHRcdHZhbHVlOiBcIlZlcmRpXCJcblx0fSxcblx0cmZ4Q29udmVyc2lvbkdyaWQ6IHtcblx0XHRzaXplOiBcIlN0w7hycmVsc2VcIlxuXHR9LFxuXHRyZnhUcmFuc3Bvc2VCaXQ6IHtcblx0XHRiaXRQYXR0ZXJuOiBcIkJpdG3DuG5zdGVyXCIsXG5cdFx0b3V0cHV0Qml0OiBcIlV0ZGF0YWJpdFwiLFxuXHRcdGlucHV0Qml0OiBcIklubmRhdGFiaXRcIlxuXHR9LFxuXHRyZnhTcGF0aWFsUmVmZXJlbmNlOiB7XG5cdFx0cGxhY2VIb2xkZXI6IFwiQXZncmVucyBldHRlciBzw7hrZW9yZFwiLFxuXHRcdGNvb3JkaW5hdGVTeXN0ZW06IFwiS29vcmRpbmF0c3lzdGVtXCIsXG5cdFx0Z2NzOiBcIkdlb2dyYWZpc2sga29vcmRpbmF0c3lzdGVtXCIsXG5cdFx0cGNzOiBcIlByb2ppc2VydCBrb29yZGluYXRzeXN0ZW1cIixcblx0XHR2Y3M6IFwiVmVydGlrYWx0IGtvb3JkaW5hdHN5c3RlbVwiXG5cdH1cbn07XG5jb25zdCByZnhMaWNlbnNlSW5mbyA9IFwiRGVubmUgcmFzdGVyZnVua3Nqb25zbWFsZW4ga2FuIGJydWtlcyB0aWwgw6UgYmVoYW5kbGUgYmlsZGVuZSBkaW5lIHZlZCBoamVscCBhdiBBcmNHSVMgSW1hZ2UgU2VydmVyLlwiO1xuY29uc3QgcmFzdGVyRnVuY3Rpb25zID0ge1xuXHRyZng6IHtcblx0XHRhQ29zSE5hbWU6IFwiQUNvc0hcIixcblx0XHRhQ29zSFNuaXA6IFwiQmVyZWduZXIgaW52ZXJzIGNvc2ludXMgZm9yIGNlbGxlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0YUNvc0hEZXNjOiBcIkZ1bmtzam9uZW4gYmVyZWduZXIgaW52ZXJzIGNvc2ludXMgZm9yIHBpa3NsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGFDb3NOYW1lOiBcIkFDb3NcIixcblx0XHRhQ29zU25pcDogXCJCZXJlZ25lciBpbnZlcnMgY29zaW51cyBmb3IgcGlrc2xlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0YUNvc0Rlc2M6IFwiRGVubmUgcmFzdGVyZnVua3Nqb25lbiBiZXJlZ25lciBpbnZlcnMgY29zaW51cyBmb3IgY2VsbGVuZSBpIGV0IHJhc3Rlci4gSSBtYXRlbWF0aWtrZW4gaGFyIGFsbGUgdHJpZ29ub21ldHJpc2tlIGZ1bmtzam9uZXIgZXQgZGVmaW5lcnQgb21yw6VkZSBtZWQgZ3lsZGlnZSBpbm5kYXRhdmVyZGllciBzb20ga2FsbGVzIGRlZmluaXNqb25zb21yw6VkZS4gVXRkYXRhdmVyZGllbmUgZm9yIGh2ZXIgZnVua3Nqb24gaGFyIG9nc8OlIGV0IGRlZmluaXNqb25zb21yw6VkZS4gRm9yIGRldHRlIHZlcmt0w7h5ZXQgZXIgZGVmaW5pc2pvbnNvbXLDpWRldCBbLTEsIDFdIG9nIG9tZmFuZ2V0IFswLCBwaV0uXCIsXG5cdFx0YVNpbkhOYW1lOiBcIkFTaW5IXCIsXG5cdFx0YVNpbkhTbmlwOiBcIkJlcmVnbmVyIGludmVycyBoeXBlcmJvbHNrIHNpbnVzIGZvciBjZWxsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGFTaW5IRGVzYzogXCJGdW5rc2pvbmVuIGJlcmVnbmVyIGludmVycyBoeXBlcmJvbHNrIHNpbnVzIGZvciBwaWtzbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRhU2luTmFtZTogXCJBU2luXCIsXG5cdFx0YVNpblNuaXA6IFwiQmVyZWduZXIgaW52ZXJzIHNpbnVzIGZvciBjZWxsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGFTaW5EZXNjOiBcIkZ1bmtzam9uZW4gYmVyZWduZXIgaW52ZXJzIHNpbnVzIGZvciBwaWtzbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRhVGFuMk5hbWU6IFwiQVRhbjJcIixcblx0XHRhVGFuMlNuaXA6IFwiQmVyZWduZXIgaW52ZXJzIHRhbmdlbnQgKGJhc2VydCBww6UgeCwgeSkgZm9yIGNlbGxlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0YVRhbjJEZXNjOiBcIkZ1bmtzam9uZW4gYmVyZWduZXIgaW52ZXJzIHRhbmdlbnQgKGJhc2VydCBww6UgeCwgeSkgZm9yIHBpa3NsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGFUYW5ITmFtZTogXCJBVGFuSFwiLFxuXHRcdGFUYW5IU25pcDogXCJCZXJlZ25lciBpbnZlcnMgaHlwZXJib2xzayB0YW5nZW50IGZvciBjZWxsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGFUYW5IRGVzYzogXCJGdW5rc2pvbmVuIGJlcmVnbmVyIGludmVycyBoeXBlcmJvbHNrIHRhbmdlbnQgZm9yIHBpa3NsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGFUYW5OYW1lOiBcIkFUYW5cIixcblx0XHRhVGFuU25pcDogXCJCZXJlZ25lciBpbnZlcnMgdGFuZ2VudCBmb3IgY2VsbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRhVGFuRGVzYzogXCJGdW5rc2pvbmVuIGJlcmVnbmVyIGludmVycyB0YW5nZW50IGZvciBwaWtzbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRhYnNOYW1lOiBcIkFic1wiLFxuXHRcdGFic1NuaXA6IFwiQmVyZWduZXIgYWJzb2x1dHQgdmVyZGkgZm9yIGNlbGxlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0YWJzRGVzYzogXCJBYnMtZnVua3Nqb25lbiBiZXJlZ25lciBkZW4gYWJzb2x1dHRlIHZlcmRpZW4gZm9yIHBpa3NsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdHJlZmxlY3RhbmNlTmFtZTogXCJTeW5saWcgcmVmbGVrdGFuc1wiLFxuXHRcdHJlZmxlY3RhbmNlU25pcDogXCJLb252ZXJ0ZXJlciByw6ViaWxkZXIgdGlsIFRvcCBvZiBBdG1vc3BoZXJlLXZlcmRpZXIgdmVkIMOlIHRhIGhlbnN5biB0aWwgc2Vuc29yZWdlbnNrYXBlciwgc29sZW5zIHBvc2lzam9uIG9nIGlubmhlbnRpbmdzdGlkc3B1bmt0ZXQuXCIsXG5cdFx0cmVmbGVjdGFuY2VEZXNjOiBcIkRlbm5lIGZ1bmtzam9uZW4ganVzdGVyZXIgbHlzc3R5cmtlbnMgZGlnaXRhbGUgYW50YWxsIChETikgZm9yIGVua2VsdGUgc2F0ZWxsaXR0c2Vuc29yZXIuIEp1c3RlcmluZ2VuZSBlciBiYXNlcnQgcMOlIHNvbGjDuHlkZSwgaW5uaGVudGluZ3NkYXRvIG9nIHNlbnNvcmVnZW5za2FwZXIgZm9yIMOlIGFuZ2kgw7hrbmluZyBvZyBhdnZpayBmb3IgaHZlcnQgYsOlbmQuIERlbm5lIGZ1bmtzam9uZW4gYnJ1a2VzIHRpbCDDpSBqdXN0ZXJlIHJlZmxla3Nqb24gZWxsZXIgbHlzc3R5cmtlLCB2ZXJkaWVyIHDDpSBlbmtlbHRlIHNhdGVsbGl0dGJpbGRlciBiYXNlcnQgcMOlIHNjZW5lbHlzIG9nIHNlbnNvcsO4a25pbmdzaW5uc3RpbGxpbmdlci4gQmlsZGVuZSBqdXN0ZXJlcyB0aWwgZW4gdGVvcmV0aXNrIGZlbGxlcyBseXNiZXRpbmdlbHNlLCBzw6UgZGV0IGLDuHIgdsOmcmUgbWluZHJlIHZhcmlhc2pvbiBtZWxsb20gc2NlbmVuZSBmcmEgZm9yc2tqZWxsaWdlIGRhdG9lciBvZyBmb3Jza2plbGxpZ2Ugc2Vuc29yZXIuIERldHRlIGthbiB2w6ZyZSBueXR0aWcgZm9yIGJpbGRla2xhc3NpZmlzZXJpbmcsIGZhcmdlYmFsYW5zZSBvZyBtb3NhaWtrZXJpbmcuIERlbm5lIGZ1bmtzam9uZW4ga2FuIGJhcmUgYnJ1a2VzIG1lZCBiZXN0ZW10ZSBiaWxkZXIuIERlIGFrdHVlbGxlIHNlbnNvcmVuZSBlciBMYW5kc2F0IE1TUywgTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0gKywgTGFuZHNhdCA4LCBJS09OT1MsIFF1aWNrQmlyZCwgR2VvRXllLTEsIFJhcGlkRXllLCBETUNpaSwgV29ybGRWaWV3LTEsIFdvcmxkVmlldy0yLCBTUE9UIDYgb2cgUGxlaWFkZXMuPGRpdj48YnIvPkZ1bmtzam9uZW4gdXRmw7hyZXIgdG8ga29ycmVrc2pvbmVyLiBEZW4gZsO4cnN0ZSBlciBiYXNlcnQgcMOlIMO4a25pbmdzaW5uc3RpbGxpbmdlbmUuIERlIG9wcHJpbm5lbGlnZSBseXNzdHlya2V2ZXJkaWVuZSBnamVub3BwcmV0dGVzIGZyYSBiaWxkZXZlcmRpZW5lIHZlZCDDpSByZXZlcnNlcmUgw7hrbmluZ3NsaWduaW5nZW5lLiBEZW4gYW5kcmUga29ycmVrc2pvbmVuIGhhciDDpSBnasO4cmUgbWVkIGZvcnNramVsbGVyIGkgc29sdmlua2VsIG9nIGx5c3N0eXJrZS4gRGUgb3BwcmlubmVsaWdlIGx5c3N0eXJrZXZlcmRpZW5lIGp1c3RlcmVzIHRpbCBldCBmZWxsZXMgbHlzZm9yaG9sZCB2ZWQgw6Ugbm9ybWFsaXNlcmUgc2NlbmVyIHRhdHQgdW5kZXIgdmFyaWFibGUgYmVseXNuaW5nc2ZvcmhvbGQuIEdlbmVyZWx0LCBtZW5zIGJpbGRldHMgdXRkYXRhdHlwZSBlciBkZW4gc2FtbWUgc29tIGlubmRhdGF0eXBlbiwgZXIgdXRkYXRhdmVyZGllbmUgbGF2ZXJlIGVubiBpbm5kYXRhdmVyZGllbmUsIG9nIGtsaXBwZXMgdGlsIGRldCBneWxkaWdlIGRhdGFvbXLDpWRldC48L2Rpdj5cIixcblx0XHRhcmdTdGF0aXN0aWNzTmFtZTogXCJBcmdTdGF0aXN0aWNzXCIsXG5cdFx0YXJnU3RhdGlzdGljc1NuaXA6IFwiQmVyZWduZXIgYXJnLXN0YXRpc3Rpa2tlciwgaW5rbHVkZXJ0IEFyZyBNYXgsIEFyZyBNaW4sIEFyZ21lZGlhbiBvZyBEdXJhdGlvbi5cIixcblx0XHRhcmdTdGF0aXN0aWNzRGVzYzogXCJGdW5rc2pvbmVuIGJlcmVnbmVyIGFyZy1zdGF0aXN0aWtrLiBEZXQgZXIgZmlyZSBtZXRvZGVyIGkgQXJnU3RhdGlzdGljcy1mdW5rc2pvbmVuOiBBcmdNYXgsIEFyZ01pbiwgQXJnTWVkaWFuIG9nIER1cmF0aW9uLlwiLFxuXHRcdGFyaXRobWV0aWNOYW1lOiBcIkFyaXRtZXRpc2tcIixcblx0XHRhcml0aG1ldGljU25pcDogXCJVdGbDuHJlciBlbiBhcml0bWV0aXNrIG9wZXJhc2pvbiBtZWxsb20gdG8gcmFzdGVyIGVsbGVyIGV0IHJhc3RlciBvZyBlbiBza2FsYXIuXCIsXG5cdFx0YXJpdGhtZXRpY0Rlc2M6IFwiQXJpdG1ldGlzay1mdW5rc2pvbmVuIHV0ZsO4cmVyIGVuIGFyaXRtZXRpc2sgb3BlcmFzam9uIG1lbGxvbSB0byByYXN0ZXIgZWxsZXIgZXR0IHJhc3RlciBvZyBlbiBza2FsYXIgb2cgb212ZW5kdC5cIixcblx0XHRhc3BlY3RTbG9wZU5hbWU6IFwiQXNwZWN0LVNsb3BlXCIsXG5cdFx0YXNwZWN0U2xvcGVTbmlwOiBcIk9wcHJldHRlciBldCByYXN0ZXIgc29tIHNhbXRpZGlnIHZpc2VyIGFzcGVrdGV0IChyZXRuaW5nKSBvZyBoZWxsaW5nIChicmF0dGhldCkgYXYgZW4ga29udGludWVybGlnIG92ZXJmbGF0ZSwgc29tIHJlcHJlc2VudGVydCBpIGVuIGRpZ2l0YWwgaMO4eWRlbW9kZWxsLlwiLFxuXHRcdGFzcGVjdFNsb3BlRGVzYzogXCJBc3BlY3QgU2xvcGUtZnVua3Nqb25lbiBvcHByZXR0ZXIgZXQgcmFzdGVybGFnIHNvbSBzYW10aWRpZyB2aXNlciBhc3Bla3Qgb2cgaGVsbGluZyBww6UgZW4gb3ZlcmZsYXRlLiBBc3Bla3QgaWRlbnRpZmlzZXJlciBoZWxuaW5nc3JldG5pbmcgYXYgbWFrc2ltYWwgZW5kcmluZ3N2ZXJkaSBmcmEgaHZlciBwaWtzZWwgaSBmb3Job2xkIHRpbCBuYWJvZW5lLiBBc3Bla3Qga2FuIGJldHJha3RlcyBzb20gaGVsbmluZ3NyZXRuaW5nLiBWZXJkaWVuZSBhdiByZXN1bHRhdHJhc3RlcmV0IGJsaXIgYXNwZWt0ZXRzIGtvbXBhc3NyZXRuaW5nLCBzb20gcmVwcmVzZW50ZXJlcyBhdiBlbiBmYXJnZXRvbmUgKGZhcmdlKS4gSGVsbGluZ2VuIHJlcHJlc2VudGVyZXIgZW5kcmluZ3N0YWt0ZW4gZm9yIGjDuHlkZW4gZm9yIGh2ZXIgcGlrc2VsIGkgZGVuIGRpZ2l0YWxlIGjDuHlkZW1vZGVsbGVuIChERU0pLiBIZWxsaW5nIHJlcHJlc2VudGVyZXIgYnJhdHRoZXRlbiBww6Ugb3ZlcmZsYXRlbiBvZyBlciBzeW1ib2xpc2VydCBpIHRyZSBrbGFzc2VyLCBzb20gdmlzZXMgdmVkIGhqZWxwIGF2IGZhcmdlbWV0bmluZyAobHlzc3R5cmtlKS48ZGl2Pjxici8+UGlrc2VsdmVyZGllbmUgaSByZXN1bHRhdHJhc3RlciBhdiBhc3BlY3Qtc2xvcGUgcmVmbGVrdGVyZXIgZW4ga29tYmluYXNqb24gYXYgYXNwZWt0IG9nIGhlbGxpbmcuIFBpa3NsZXIgbWVkIHZlcmRpZXIgdW5kZXIgMjAgYmV0cmFrdGVzIHNvbSBmbGF0ZSBvZyB2aXNlcyBpIGdyw6V0dC4gQXNwZWN0LXNsb3BlLXZlcmRpZXIgcMOlIDIxIG9nIG92ZXIgdmlsIGJsaSB2aXN0IG1lZCBmb3Jza2plbGxpZyBmYXJnZW1ldG5pbmcgc29tIGbDuGxnZXI6IDIxIHRpbCAzMOKAlGxpdGVuIGhlbGxpbmcsIDMxIHRpbCA0MOKAlG1vZGVyYXQgaGVsbGluZywgNDEgb2cgaMO4eWVyZeKAlHN0b3IgaGVsbGluZzwvZGl2PlwiLFxuXHRcdGFzcGVjdE5hbWU6IFwiSGVsbmluZ3NyZXRuaW5nXCIsXG5cdFx0YXNwZWN0U25pcDogXCJWaXNlciBodmlsa2VuIHJldG5pbmcgZW4gcGlrc2VsIHZlbmRlciBtb3QsIGh2b3IgMCBlciBub3Jkb3ZlciBvZyB2aW5rbGVuZSDDuGtlciBtZWQga2xva2tlbiB0aWwgMzYwLlwiLFxuXHRcdGFzcGVjdERlc2M6IFwiQXNwZWN0LWZ1bmtzam9uZW4gaWRlbnRpZmlzZXJlciBoZWxuaW5nc3JldG5pbmcgYXYgbWFrc2ltYWwgZW5kcmluZ3N2ZXJkaSBmcmEgaHZlciBwaWtzZWwgaSBmb3Job2xkIHRpbCBuYWJvZW5lLiBBc3Bla3Qga2FuIGJldHJha3RlcyBzb20gaGVsbmluZ3NyZXRuaW5nLiBWZXJkaWVuZSBhdiByZXN1bHRhdHJhc3RlcmV0IGJsaXIgYXNwZWt0ZXRzIGtvbXBhc3NyZXRuaW5nLjxkaXY+PGJyLz5Jbm5kYXRhZW5lIGZvciBkZW5uZSBmdW5rc2pvbmVuIGVyIGlubmRhdGFyYXN0ZXIuIEFzcGVjdC1mdW5rc2pvbmVuIGJsaXIgb2Z0ZSBicnVrdCBww6UgZW4gZGlnaXRhbCBow7h5ZGVtb2RlbGwgKERFTSkuIFNvbSBzdGFuZGFyZCB2aXNlcyBhc3Bla3RldCBzb20gZXQgZ3LDpXRvbmViaWxkZS4gRHUga2FuIGxlZ2dlIHRpbCBDb2xvcm1hcC1mdW5rc2pvbmVuIGZvciDDpSBhbmdpIGV0IGJlc3RlbXQgZmFyZ2V2YWxnIGVsbGVyIGxhIHBlcnNvbmVuIHNvbSBzZXIgcMOlIG1vc2Fpa2tlbiwgZW5kcmUgc3ltYm9sZW5lIG1lZCBzaXR0IGVnZW4gZmFyZ2V2YWxnLjwvZGl2PlwiLFxuXHRcdHRhYmxlTmFtZTogXCJBdHRyaWJ1dHRhYmVsbFwiLFxuXHRcdHRhYmxlU25pcDogXCJCcnVrZXIgZW4gdGFiZWxsIGZvciDDpSBuYXZuZ2kgb2cgc3ltYm9saXNlcmUgdmVyZGllbmUgaSBldCBkYXRhc2V0dC4gS29sb25uZW5lIGZvciB0YWJlbGxlbiBlciBrb21tYXNlcGFyZXJ0OiBQaXhlbFZhbHVlLCBBdHRyaWJ1dGVOYW1lLCBSZWRWYWx1ZSwgR3JlZW5WYWx1ZSwgQmx1ZVZhbHVlLlwiLFxuXHRcdHRhYmxlRGVzYzogXCJBdHRyaWJ1dHRhYmVsbC1mdW5rc2pvbmVuIGxhciBkZWcgZGVmaW5lcmUgZW4gYXR0cmlidXR0YWJlbGwgZm9yIMOlIHN5bWJvbGlzZXJlIGV0IGVua2VsdGLDpW5kIG1vc2Fpa2tkYXRhc2V0dCBlbGxlciByYXN0ZXJkYXRhc2V0dC4gPGRpdj48YnIvPkRldHRlIGVyIG55dHRpZyBuw6VyIGR1IHZpbCBwcmVzZW50ZXJlIGJpbGRlciBzb20gZXIgYmxpdHQga2xhc3NpZmlzZXJ0IHRpbCBhcmVhbGJydWssIGZvciBla3NlbXBlbCBza29nbWFyaywgdsOldG1hcmtlciwgZHlya2V0IGpvcmQgb2cgdXJiYW5lIG9tcsOlZGVyLiBIdmlzIHRhYmVsbGVuIGkgdGlsbGVnZyBpbm5laG9sZGVyIGZlbHQgc29tIGVyIGthbHQgXFxcInJlZFxcXCIsIFxcXCJncmVlblxcXCIgb2cgXFxcImJsdWVcXFwiLCB2aWwgdmVyZGllbmUgaSBkaXNzZSBmZWx0ZW5lIGJsaSBicnVrdCBzb20gZXQgZmFyZ2VrYXJ0IG7DpXIgYmlsZGV0IGJsaXIgdGVnbmV0IG9wcC48L2Rpdj5cIixcblx0XHRiYW5kQXJpdGhtZXRpY05hbWU6IFwiQsOlbmRhcml0bWV0aWtrXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNTbmlwOiBcIkJlcmVnbmVyIGluZGVrc2VyIHZlZCBoamVscCBhdiBmb3Jow6VuZHNkZWZpbmVydGUgZm9ybWxlciBlbGxlciBldCBicnVrZXJkZWZpbmVydCB1dHRyeWtrLlwiLFxuXHRcdGJhbmRBcml0aG1ldGljRGVzYzogXCJCYW5kIEFyaXRobWV0aWMtZnVuc2tqb25lbiB1dGbDuHJlciBlbiBhcml0bWV0aXNrIG9wZXJhc2pvbiBww6UgYsOlbmRlbmUgaSBldCByYXN0ZXJkYXRhc2V0dC4gRHUga2FuIHZlbGdlIGZvcmjDpW5kc2RlZmluZXJ0ZSBhbGdvcml0bWVyIGVsbGVyIGR1IGthbiBza3JpdmUgaW5uIGRpbiBlZ2VuIGVua2VsdGxpbmplZm9ybWVsLiBPcGVyYXRvcmVuZSBzb20gc3TDuHR0ZXMgZXIgLSwgKywgLywgKiBvZyB1bmFyeSAtLlwiLFxuXHRcdHRocmVzaG9sZE5hbWU6IFwiQmluw6ZyIHRlcnNrZWx2ZXJkaVwiLFxuXHRcdHRocmVzaG9sZFNuaXA6IFwiT3JnYW5pc2VyZXIga29udGludWVybGlnZSBkYXRhIGkgZm9yZ3J1bm4gb2cgYmFrZ3J1bm4gdmVkIMOlIG1pbmltZXJlIGtvdmFyaWFuc2VuIG1lbGxvbSBkZSB0byBrbGFzc2VuZS5cIixcblx0XHR0aHJlc2hvbGREZXNjOiBcIk7DpXIgZXQgcmFzdGVyZGF0YXNldHQgaGFyIGVuIGJpbW9kYWwgZGlzdHJpYnVzam9uLCBvcHByZXR0ZXIgZGVubmUgZnVua3Nqb25lbiBldCBueXR0IHJhc3RlciBzb20gZGVsZXIgZGF0YWVuZSBpIHRvIGZvcnNramVsbGlnZSBrbGFzc2VyLiBEZW4gc2thcGVyIGVuIGtsYXNzZSBtZWQgbGF2IHZlcmRpIHNvbSB2aXNlcyBtZWQgc3ZhcnRlIHBpa3NsZXIsIG9nIGVuIGtsYXNzZSBtZWQgaMO4eSB2ZXJkaSBzb20gdmlzZXMgbWVkIGh2aXRlIHBpa3NsZXIuXCIsXG5cdFx0Yml0d2lzZUFuZE5hbWU6IFwiQml0d2lzZSBBbmRcIixcblx0XHRiaXR3aXNlQW5kU25pcDogXCJVdGbDuHJlciBlbiBiaXR2aXMgQW5kLW9wZXJhc2pvbiBww6UgZGUgYmluw6ZyZSB2ZXJkaWVuZSBmb3IgdG8gaW5uZGF0YXJhc3RlcmUuXCIsXG5cdFx0Yml0d2lzZUFuZERlc2M6IFwiQml0dmlzIEFuZCB1dGbDuHJlciBlbiBiaXR2aXMgYW5kLW9wZXJhc2pvbiBww6UgZGUgYmluw6ZyZSB2ZXJkaWVuZSBmb3IgdG8gaW5uZGF0YXJhc3RlcmVcIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0TmFtZTogXCJCaXR3aXNlIExlZnQgU2hpZnRcIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0U25pcDogXCJVdGbDuHJlciBlbiBCaXR3aXNlIExlZnQgU2hpZnQtb3BlcmFzam9uIHDDpSBkZSBiaW7DpnJlIHZlcmRpZW5lIGZvciB0byBpbm5kYXRhcmFzdGVyZS5cIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0RGVzYzogXCJCaXR3aXNlIExlZnQgU2hpZnQgdXRmw7hyZXIgZW4gQml0d2lzZSBMZWZ0IFNoaWZ0LW9wZXJhc2pvbiBww6UgZGUgYmluw6ZyZSB2ZXJkaWVuZSBmb3IgdG8gaW5uZGF0YXJhc3RlcmVcIixcblx0XHRiaXR3aXNlTm90TmFtZTogXCJCaXR3aXNlIE5vdFwiLFxuXHRcdGJpdHdpc2VOb3RTbmlwOiBcIlV0ZsO4cmVyIGVuIEJpdHdpc2UgTm90IChjb21wbGVtZW50KS1vcGVyYXNqb24gcMOlIGRlIGJpbsOmcmUgdmVyZGllbmUgZm9yIHRvIGlubmRhdGFyYXN0ZXJlLlwiLFxuXHRcdGJpdHdpc2VOb3REZXNjOiBcIkZ1bmtzam9uZW4gdXRmw7hyZXIgZW4gQml0d2lzZSBOb3QgKGNvbXBsZW1lbnQpLW9wZXJhc2pvbiBww6UgZGUgYmluw6ZyZSB2ZXJkaWVuZSBmb3IgZXQgaW5uZGF0YXJhc3Rlci5cIixcblx0XHRiaXR3aXNlT3JOYW1lOiBcIkJpdHdpc2UgT3JcIixcblx0XHRiaXR3aXNlT3JTbmlwOiBcIlV0ZsO4cmVyIGVuIEJpdHdpc2UgT3Itb3BlcmFzam9uIHDDpSBkZSBiaW7DpnJlIHZlcmRpZW5lIGZvciB0byBpbm5kYXRhcmFzdGVyZS5cIixcblx0XHRiaXR3aXNlT3JEZXNjOiBcIkZ1bmtzam9uZW4gdXRmw7hyZXIgZW4gQml0d2lzZSBPci1vcGVyYXNqb24gcMOlIGRlIGJpbsOmcmUgdmVyZGllbmUgZm9yIHRvIGlubmRhdGFyYXN0ZXJlLiBcIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdE5hbWU6IFwiQml0d2lzZSBSaWdodCBTaGlmdFwiLFxuXHRcdGJpdHdpc2VSaWdodFNoaWZ0U25pcDogXCJVdGbDuHJlciBlbiBCaXR3aXNlIFJpZ2h0IFNoaWZ0LW9wZXJhc2pvbiBww6UgZGUgYmluw6ZyZSB2ZXJkaWVuZSBmb3IgdG8gaW5uZGF0YXJhc3RlcmUuXCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnREZXNjOiBcIkZ1bmtzam9uZW4gdXRmw7hyZXIgZW4gQml0d2lzZSBSaWdodCBTaGlmdC1vcGVyYXNqb24gcMOlIGRlIGJpbsOmcmUgdmVyZGllbmUgZm9yIHRvIGlubmRhdGFyYXN0ZXJlLlwiLFxuXHRcdGJpdHdpc2VYb3JOYW1lOiBcIkJpdHdpc2UgWG9yXCIsXG5cdFx0Yml0d2lzZVhvclNuaXA6IFwiVXRmw7hyZXIgZW4gQml0d2lzZSBlWGNsdXNpdmUgT3Itb3BlcmFzam9uIHDDpSBkZSBiaW7DpnJlIHZlcmRpZW5lIGZvciB0byBpbm5kYXRhcmFzdGVyZS5cIixcblx0XHRiaXR3aXNlWG9yRGVzYzogXCJGdW5rc2pvbmVuIHV0ZsO4cmVyIGVuIEJpdHdpc2UgZVhjbHVzaXZlIE9yLW9wZXJhc2pvbiBww6UgZGUgYmluw6ZyZSB2ZXJkaWVuZSBmb3IgdG8gaW5uZGF0YXJhc3RlcmVcIixcblx0XHRib29sZWFuQW5kTmFtZTogXCJCb29sc2sgQW5kXCIsXG5cdFx0Ym9vbGVhbkFuZFNuaXA6IFwiVXRmw7hyZXIgZW4gQm9vbHNrIEFuZC1vcGVyYXNqb24gcMOlIGNlbGxldmVyZGllbmUgZm9yIHRvIGlubmRhdGFyYXN0ZXJlLiBIdmlzIGJlZ2dlIGlubmRhdGF2ZXJkaWVuZSBlciBzYW5uZSAoaWtrZSBudWxsKSwgZXIgdXRkYXRhdmVyZGllbiAxLiBIdmlzIGV0dCBlbGxlciBiZWdnZSBpbm5kYXRhc2V0dCBlciB1c2FubiAobnVsbCksIGVyIHV0ZGF0YXZlcmRpZW4gMC5cIixcblx0XHRib29sZWFuQW5kRGVzYzogXCJGdW5rc2pvbmVuIHV0ZsO4cmVyIGVuIEJvb2xzayBBbmQtb3BlcmFzam9uIHDDpSBwaWtzZWx2ZXJkaWVuZSBmb3IgdG8gaW5uZGF0YXJhc3RlcmUuIEh2aXMgYmVnZ2UgaW5uZGF0YXZlcmRpZW5lIGVyIHNhbm5lIChpa2tlIG51bGwpLCBlciB1dGRhdGF2ZXJkaWVuIDEuIEh2aXMgZW4gZWxsZXIgYmVnZ2UgaW5uZGF0YXZlcmRpZW5lIGVyIHVzYW5uIChudWxsKSwgZXIgdXRkYXRhdmVyZGllbiAwLiBcIixcblx0XHRib29sZWFuTm90TmFtZTogXCJCb29sc2sgTm90XCIsXG5cdFx0Ym9vbGVhbk5vdFNuaXA6IFwiVXRmw7hyZXIgZW4gQm9vbHNrIE5vdCAoY29tcGxlbWVudCktb3BlcmFzam9uIHDDpSBjZWxsZXZlcmRpZW5lIGZvciBpbm5kYXRhcmFzdGVyZXQuIEh2aXMgaW5uZGF0YXZlcmRpZW5lIGVyIHNhbm5lIChpa2tlIG51bGwpLCBlciB1dGRhdGF2ZXJkaWVuIDAuIEh2aXMgaW5uZGF0YXZlcmRpZW5lIGVyIHVzYW5uZSAobnVsbCksIGVyIHV0ZGF0YXZlcmRpZW4gMS5cIixcblx0XHRib29sZWFuTm90RGVzYzogXCJGdW5rc2pvbmVuIHV0ZsO4cmVyIGVuIEJvb2xzayBOb3QgKGNvbXBsZW1lbnQpLW9wZXJhc2pvbiBww6UgcGlrc2VsdmVyZGllbmUgZm9yIGlubmRhdGFyYXN0ZXJldC4gSHZpcyBpbm5kYXRhdmVyZGllbmUgZXIgc2FubmUgKGlra2UgbnVsbCksIGVyIHV0ZGF0YXZlcmRpZW4gMC4gSHZpcyBpbm5kYXRhdmVyZGllbmUgZXIgdXNhbm5lIChudWxsKSwgZXIgdXRkYXRhdmVyZGllbiAxLlwiLFxuXHRcdGJvb2xlYW5Pck5hbWU6IFwiQm9vbHNrIE9yXCIsXG5cdFx0Ym9vbGVhbk9yU25pcDogXCJVdGbDuHJlciBlbiBCb29sc2sgT3Itb3BlcmFzam9uIHDDpSBjZWxsZXZlcmRpZW5lIGZvciBkZSB0byBpbm5kYXRhcmFzdGVybmUuIEh2aXMgZW4gYmVnZ2UgaW5uZGF0YXZlcmRpZW5lIGVyIHNhbm5lIChpa2tlIG51bGwpLCBlciB1dGRhdGF2ZXJkaWVuIDEuIEh2aXMgZW4gZWxsZXIgYmVnZ2UgaW5uZGF0YXZlcmRpZW5lIGVyIHVzYW5uZSAobnVsbCksIGVyIHV0ZGF0YXZlcmRpZW4gMC5cIixcblx0XHRib29sZWFuT3JEZXNjOiBcIkZ1bmtzam9uZW4gdXRmw7hyZXIgZW4gQm9vbHNrIE9yLW9wZXJhc2pvbiBww6UgY2VsbGV2ZXJkaWVuZSBmb3IgdG8gaW5uZGF0YXJhc3RlcmUuIEh2aXMgZW4gYmVnZ2UgaW5uZGF0YXZlcmRpZW5lIGVyIHNhbm5lIChpa2tlIG51bGwpLCBlciB1dGRhdGF2ZXJkaWVuIDEuIEh2aXMgZW4gZWxsZXIgYmVnZ2UgaW5uZGF0YXZlcmRpZW5lIGVyIHVzYW5uZSAobnVsbCksIGVyIHV0ZGF0YXZlcmRpZW4gMC5cIixcblx0XHRib29sZWFuWG9yTmFtZTogXCJCb29sc2sgWG9yXCIsXG5cdFx0Ym9vbGVhblhvclNuaXA6IFwiVXRmw7hyZXIgZW4gQm9vbHNrIGVYY2x1c2l2ZSBPci1vcGVyYXNqb24gcMOlIGNlbGxldmVyZGllbmUgZm9yIHRvIGlubmRhdGFyYXN0ZXJlLiBIdmlzIGVuIGlubmRhdGF2ZXJkaSBlciBzYW5uIChpa2tlIG51bGwpIG9nIGRlbiBhbmRyZSB2ZXJkaWVuIGVyIHVzYW5uIChudWxsKSwgZXIgdXRkYXRhdmVyZGllbiAxLiBIdmlzIGJlZ2dlIGlubmRhdGF2ZXJkaWVuZSBlciBzYW5uZSBlbGxlciBiZWdnZSBlciB1c2FubmUsIGVyIHV0ZGF0YXZlcmRpZW4gMC5cIixcblx0XHRib29sZWFuWG9yRGVzYzogXCJGdW5rc2pvbmVuIHV0ZsO4cmVyIGVuIEJvb2xzayBlWGNsdXNpdmUgT3Itb3BlcmFzam9uIHDDpSBjZWxsZXZlcmRpZW5lIGZvciB0byBpbm5kYXRhcmFzdGVyZS4gSHZpcyBlbiBpbm5kYXRhdmVyZGkgZXIgc2FubiAoaWtrZSBudWxsKSBvZyBkZW4gYW5kcmUgdmVyZGllbiBlciB1c2FubiAobnVsbCksIGVyIHV0ZGF0YXZlcmRpZW4gMS4gSHZpcyBiZWdnZSBpbm5kYXRhdmVyZGllbmUgZXIgc2FubmUgZWxsZXIgYmVnZ2UgZXIgdXNhbm5lLCBlciB1dGRhdGF2ZXJkaWVuIDAuXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJOYW1lOiBcIkJ1ZnJldFwiLFxuXHRcdGJ1ZmZlcmVkUmFzdGVyU25pcDogXCJCdWZyZXIgZGUobikgc2lzdGUgdGlsZ2plbmdlbGlnZSBwaWtzZWxibG9ra2VuKGUpLlwiLFxuXHRcdGJ1ZmZlcmVkUmFzdGVyRGVzYzogXCJCdWZmZXJmdW5rc2pvbmVuIGJydWtlcyB0aWwgw6Ugb3B0aW1hbGlzZXJlIHl0ZWxzZW4gdGlsIGtvbXBsZWtzZSBmdW5rc2pvbnNramVkZXIuIERlbiBsYWdyZXIgdXRkYXRlbmUgaSBtaW5uZXQgZm9yIGRlbiBkZWxlbiBhdiBmdW5rc2pvbnNramVkZW4gc29tIGtvbW1lciBmw7hyIGRlbi4gPGRpdj48YnIvPlNldHQgaW5uIGRlbm5lIGZ1bmtzam9uZW4gaSBmdW5rc2pvbnNyZWRpZ2VyaW5nZW4gZGVyIGR1IMO4bnNrZXIgw6UgbGFncmUgdXRkYXRhZW5lLjwvZGl2PlwiLFxuXHRcdHJhc3RlckNhbGN1bGF0b3JOYW1lOiBcIkthbGt1bGF0b3JcIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yU25pcDogXCJCZXJlZ25lciBldCByYXN0ZXIgZnJhIGV0IHJhc3RlcmJhc2VydCBtYXRlbWF0aXNrIHV0dHJ5a2suXCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvckRlc2M6IFwiS2Fsa3VsYXRvci1mdW5rc2pvbmVuIGxhciBkZWcgb3BwcmV0dGUgb2cga2rDuHJlIHV0dHJ5a2sgb2cgaW5rb3Jwb3JlcmUgZGVtIGkgZnVua3Nqb25za2plZGVyLlwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzTmFtZTogXCJDZWxsZXN0YXRpc3Rpa2tcIixcblx0XHRjZWxsU3RhdGlzdGljc1NuaXA6IFwiQmVyZWduZXIgZW4gcGVyLWNlbGxlc3RhdGlzdGlrayBmcmEgZmxlcmUgcmFzdGVyZS4gRGUgdGlsZ2plbmdlbGlnZSBzdGF0aXN0aWtrdHlwZW5lIGVyIE1ham9yaXRldCwgTWFrc2ltdW0sIE1lZGlhbiwgTWluaW11bSwgTWlub3JpdGV0LCBPbXLDpWRlLCBTdGFuZGFyZGF2dmlrLCBTdW0gb2cgVmFyaWFzam9uLlwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzRGVzYzogXCJEZW5uZSBmdW5rc2pvbmVuIGJlcmVnbmVyIHN0YXRpc3Rpa2sgZnJhIGZsZXJlIHJhc3RlciwgcMOlIHBpa3NlbC1ldHRlci1waWtzZWwgYmFzaXMuIERlIHRpbGdqZW5nZWxpZ2Ugc3RhdGlzdGlra3R5cGVuZSBlciBNYWpvcml0ZXQsIE1ha3NpbXVtLCBNZWRpYW4sIE1pbmltdW0sIE1pbm9yaXRldCwgT21yw6VkZSwgU3RhbmRhcmRhdnZpaywgU3VtIG9nIFZhcmlhc2pvbi5cIixcblx0XHRjbGFzc2lmeU5hbWU6IFwiS2xhc3NpZmlzZXJcIixcblx0XHRjbGFzc2lmeVNuaXA6IFwiVGlsb3JkbmVyIGh2ZXIgcGlrc2VsIHRpbCBlbiBrbGFzc2UuIElubmxlbW0gdGlsbGVnZ3NkYXRhLCBmLmVrcy4gZXQgc2VnbWVudGVydCBiaWxkZS5cIixcblx0XHRjbGFzc2lmeURlc2M6IFwiRGVubmUgcmFzdGVyLWZ1bmtzam9uZW4ga2xhc3NpZmlzZXJlciBldCByYXN0ZXJkYXRhc2V0dCBiYXNlcnQgcMOlIGVuIEVzcmkgQ2xhc3NpZmllciBEZWZpbml0aW9uICguZWNkKS1maWwgb2cgcmFzdGVyZGF0YSBzb20gaW5uZGF0YS4gLkVjZC1maWxlbiBzb20gYnJ1a2VzIGkga2xhc3NpZmlzZXJpbmdzZnVua3Nqb25lbiwgaW5uZWhvbGRlciBhbGwgaW5mb3JtYXNqb25lbiBmb3IgZXQgYmVzdGVtdCBkYXRhc2V0dCBvZyBrbGFzc2lmaXNlcmVyLCBvZyBnZW5lcmVyZXMgYXYga2xhc3NpZmlrYXNqb25zbMOmcmV2ZXJrdMO4eWVuZSwgZm9yIGVrc2VtcGVsIFZlY3RvciBNYWNoaW5lIGVsbGVyIFRyYWluIFJhbmRvbSBUcmVlcy5cIixcblx0XHRjbGlwTmFtZTogXCJLbGlwcCB1dFwiLFxuXHRcdGNsaXBTbmlwOiBcIkFuZ2lyIHV0c3RyZWtuaW5nZW4gYXYgZXQgcmFzdGVyIHZlZCBoamVscCBhdiBrb29yZGluYXRlciBlbGxlciBldCBhbm5ldCBkYXRhc2V0dC5cIixcblx0XHRjbGlwRGVzYzogXCJEZW5uZSBmdW5rc2pvbmVuIGtsaXBwZXIgZXQgcmFzdGVyIG1lZCBlbiByZWt0YW5ndWzDpnIgZm9ybSBpIGhlbmhvbGQgdGlsIGRlIGRlZmluZXJ0ZSB1dHN0cmVrbmluZ2VuZSwgZWxsZXIga2xpcHBlciBldCByYXN0ZXIgaSBoZW5ob2xkIGZvcm1lbiBww6UgZW4gcG9seWdvbi1nZW9vYmpla3RrbGFzc2UuIEZvcm1lbiBzb20gZGVmaW5lcmVyIGtsaXBwZXQsIGthbiBrbGlwcGUgdXRzdHJla25pbmdlbiBhdiByYXN0ZXJldCBlbGxlciBrbGlwcGUgdXQgZXQgb21yw6VkZSBpIHJhc3RlcmV0LlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uTmFtZTogXCJGYXJnZW1vZGVsbGtvbnZlcnRlcmluZ1wiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uU25pcDogXCJLb252ZXJ0ZXJlciBldCByYXN0ZXIgZnJhIFJHQiB0aWwgSFNWIG9nIG1vdHNhdHQuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25EZXNjOiBcIkNvbG9yIE1vZGVsIENvbnZlcnNpb24tZnVua3Nqb25lbiBrb252ZXJ0ZXJlciBiaWxkZXMgZmFyZ2Vtb2RlbGwgZnJhIHRvbmUsIG1ldG5pbmcgb2cgdmFsw7hyIChIU1YpIHRpbCByw7hkdCwgZ3LDuG50IG9nIGJsw6V0dCAoUkdCKSwgZWxsZXIgb212ZW5kdC48ZGl2Pjxici8+RGVubmUgZnVua3Nqb25lbiBrYW4gYnJ1a2VzIGkgZXQgbW9zYWlra2RhdGFzZXR0LjwvZGl2PlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JOYW1lOiBcIkZhcmdla2FydCB0aWwgUkdCXCIsXG5cdFx0Y29sb3JtYXBUb1JHQlNuaXA6IFwiS29udmVydGVyZXIgZXQgZW5rZWx0YsOlbmRyYXN0ZXIgbWVkIGV0IGZhcmdla2FydCB0aWwgZXQgcmFzdGVyIG1lZCB0cmUgYsOlbmQgKHLDuGQsIGdyw7hubiBvZyBibMOlKS5cIixcblx0XHRjb2xvcm1hcFRvUkdCRGVzYzogXCJEZW5uZSBmdW5rc2pvbmVuIGtvbnZlcnRlcmVyIGV0IGVua2VsdGLDpW5kcmFzdGVyIG1lZCBldCBmYXJnZWthcnQgdGlsIGV0IHJhc3RlciBtZWQgdHJlIGLDpW5kIChyw7hkLCBncsO4bm4gb2cgYmzDpSkuPGRpdj48YnIvPkRlbm5lIGZ1bmtzam9uZW4gZXIgbnl0dGlnIG7DpXIgZHUgaGFyIGJlaG92IGZvciDDpSBsYWdlIGV0IHJhc3RlciBtZWQgdHJlIGLDpW5kIGZyYSBldCBlbmtlbHRiw6VuZHJhc3RlciBtZWQgZXQgdGlsa255dHRldCBmYXJnZWthcnQuIFZlcmRpZW5lIGkgZmFyZ2VrYXJ0ZXQgYnJ1a2VzIHRpbCDDpSBsYWdlIGh2ZXJ0IHLDuGRlLCBncsO4bm5lIG9nIGJsw6UgYsOlbmQuIERlbm5lIGZ1bmtzam9uZW4ga2FuIGJydWtlcyBpIGV0IG1vc2Fpa2tkYXRhc2V0dC48L2Rpdj5cIixcblx0XHRjb2xvcm1hcE5hbWU6IFwiRmFyZ2VrYXJ0XCIsXG5cdFx0Y29sb3JtYXBTbmlwOiBcIkVuZHJlciBwaWtzZWx2ZXJkaWVuZSB0aWwgw6UgdmlzZSByYXN0ZXJkYXRhZW5lIHNvbSBlbnRlbiBldCBncsOldG9uZXQgZWxsZXIgZXQgcsO4ZHQsIGdyw7hudCBvZyBibMOldHQgKFJHQiktYmFzZXJ0IGJpbGRlIHDDpSBiYWtncnVubiBhdiBldCBmYXJnZXNramVtYSBlbGxlciBlbiBmYXJnZXBhbGV0dC5cIixcblx0XHRjb2xvcm1hcERlc2M6IFwiQ29sb3JtYXAtZnVua3Nqb25lbiBlciBlbiB0eXBlIHJhc3RlcmRhdGFvcHB0ZWduZXIuIERlbiBmb3J2YW5kbGVyIHBpa3NlbHZlcmRpZW5lIHRpbCDDpSB2aXNlIHJhc3RlcmRhdGFlbmUgc29tIGVudGVuIGV0IGdyw6V0b25ldCBlbGxlciBldCBSR0ItYmFzZXJ0IGZhcmdlYmlsZGUgcMOlIGJha2dydW5uIGF2IGV0IGZhcmdlc2tqZW1hIGVsbGVyIGJlc3RlbXRlIGZhcmdlciBpIGVuIGZhcmdla2FydGZpbC4gRHUga2FuIGJydWtlIGV0IGZhcmdla2FydCB0aWwgw6UgcmVwcmVzZW50ZXJlIGFuYWx5c2VydGUgZGF0YSwgZm9yIGVrc2VtcGVsIGV0IGtsYXNzaWZpc2VydCBiaWxkZSBlbGxlciBuw6VyIGR1IHZpc2VyIGV0IHRvcG9ncmFmaXNrIGthcnQgKGVsbGVyIGV0IGluZGVrc2Zhcmdlc2thbm5ldCBiaWxkZSkuPGRpdj48YnIvPkZhcmdla2FydCBpbm5laG9sZGVyIGV0IHNldHQgbWVkIGZhcmdldmVyZGllciBzb20gYnJ1a2VzIHRpbCDDpSB2aXNlIGV0IGVua2VsdGLDpW5kcmFzdGVyIGtvbnNla3ZlbnQgbWVkIGRlIHNhbW1lIGZhcmdlbmUuIEh2ZXIgcGlrc2VsdmVyZGkgZXIga255dHRldCB0aWwgZW4gZmFyZ2UsIGRlZmluZXJ0IHNvbSBldCBzZXR0IG1lZCBSR0ItdmVyZGllci4gRmFyZ2VrYXJ0IGthbiBzdMO4dHRlIGFsbGUgc2xhZ3MgYml0ZHliZGVyIHVubnRhdHQgZmx5dHB1bmt0LiBEZSBzdMO4dHRlciBvZ3PDpSBwb3NpdGl2ZSBvZyBuZWdhdGl2ZSB2ZXJkaWVyIG9nIGthbiBpbm5laG9sZGUgbWFuZ2xlbmRlIGZhcmdla2FydHZlcmRpZXIuIE7DpXIgZXQgZGF0YXNldHQgdmlzZXMgbWVkIGV0IGZhcmdla2FydCBzb20gaW5uZWhvbGRlciBtYW5nbGVuZGUgdmVyZGllciwgdmlzZXMgaWtrZSBwaWtzbGVuZSBtZWQgZGUgbWFuZ2xlbmRlIHZlcmRpZW5lLjwvZGl2PlwiLFxuXHRcdGNvbXBsZXhOYW1lOiBcIktvbXBsZWtzXCIsXG5cdFx0Y29tcGxleFNuaXA6IFwiVHJla2tlciB1dCBzdMO4cnJlbHNlbiBmcmEga29tcGxla3NlIHRhbGwuXCIsXG5cdFx0Y29tcGxleERlc2M6IFwiRGVubmUgZnVua3Nqb25lbiBiZXJlZ25lciBvbWZhbmdldCBmcmEga29tcGxla3NlIHZlcmRpZXIuPGRpdj48YnIvPkRlbm5lIGZ1bmtzam9uZW4gYnJ1a2VzIHZhbmxpZ3ZpcyBtZWQgUkFEQVItYmlsZGVyIHNvbSBoYXIgZW4ga29tcGxla3MgZGF0YXR5cGUuIERlbiBrYW4gYnJ1a2VzIGkgZXQgbW9zYWlra2RhdGFzZXR0LjwvZGl2PlwiLFxuXHRcdGNvbXBvc2l0ZUJhbmROYW1lOiBcIkNvbXBvc2l0ZSBCYW5kc1wiLFxuXHRcdGNvbXBvc2l0ZUJhbmRTbmlwOiBcIktvbWJpbmVyZXIgZmxlcmUgZGF0YXNldHQgaSDDqW4gcmFzdGVyIG1lZCBmbGVyZSBiw6VuZC5cIixcblx0XHRjb21wb3NpdGVCYW5kRGVzYzogXCJDb21wb3NpdGUgQmFuZHMtZnVua3Nqb25lbiBsYXIgZGVnIGtvbWJpbmVyZSByYXN0ZXIgZm9yIMOlIGRhbm5lIGV0IGJpbGRlIG1lZCBmbGVyZSBiw6VuZC5cIixcblx0XHRjb25OYW1lOiBcIkNvblwiLFxuXHRcdGNvblNuaXA6IFwiVXRmw7hyZXIgZW4gYmV0aW5nZXQgSWYsIFRoZW4sIEVsc2Utb3BlcmFzam9uLiBOw6VyIGVuIENvbi1vcGVyYXRvciBicnVrZXMsIG3DpSBkZXQgdmFubGlndmlzIHbDpnJlIHRvIGVsbGVyIGZsZXJlIGZ1bmtzam9uZXIgc29tIGVyIHNhbW1lbmtqZWRldCwgaHZvciDDqW4gZnVua3Nqb24gYW5naXIga3JpdGVyaWVuZSwgb2cgZGVuIGFuZHJlIGZ1bmtzam9uZW4gZXIgQ29uLW9wZXJhdG9yZW4gc29tIGJydWtlciBrcml0ZXJpZW5lIG9nIGFuZ2lyIGh2YSBkZSBzYW5uZSBvZyB1c2FubmUgdXRkYXRhIHNrYWwgdsOmcmUuXCIsXG5cdFx0Y29uRGVzYzogXCJDb24tZnVua3Nqb25lbiBhbmdpciBwaWtzbGVuZSB0aWwgdXRkYXRhcmFzdGVyZXQgYmFzZXJ0IHDDpSBlbiBodmlzXFxcXGVsbGVyLWV2YWx1ZXJpbmcgYXYgaHZlciBpbm5kYXRhcGlrc2VsLiBEZW4gcmV0dXJuZXJlciBwaWtzZWx2ZXJkaWVyIGZyYSBUcnVlIFJhc3RlciBodmlzIGRlbiBiZXRpbmdlZGUgZXZhbHVlcmluZ2VuIGVyIHNhbm4gKDEpIGVsbGVyIHJldHVybmVyZXIgcGlrc2VsdmVyZGllbmUgZnJhIEZhbHNlIFJhc3RlciBodmlzIGRlbiBiZXRpbmdlZGUgZXZhbHVlcmluZ2VuIGVyIHVzYW5uICgwKS4gRGlzc2Uga3JpdGVyaWVuZSBlciBzcGVzaWZpc2VydCBhdiB1dGRhdGEgYXYgZW4gbG9naXNrIG1hdGVtYXRpa2tmdW5rc2pvbiwgc29tIHZpbCB2w6ZyZSBpbm5kYXRhcmFzdGVyZXQuXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIktvbnN0YW50XCIsXG5cdFx0Y29uc3RhbnRTbmlwOiBcIk9wcHJldHRlciBldCB2aXJ0dWVsdCByYXN0ZXIgbWVkIGVuIGVua2VsdCBwaWtzZWx2ZXJkaS5cIixcblx0XHRjb25zdGFudERlc2M6IFwiRGVubmUgZnVua3Nqb25lbiBvcHByZXR0ZXIgZXQgdmlydHVlbHQgcmFzdGVyIG1lZCBlbiBlbmtlbHQgcGlrc2VsdmVyZGkgc29tIGthbiBicnVrZXMgaSByYXN0ZXJmdW5rc2pvbnNtYWxlciBvZyB0aWwgw6UgYmVoYW5kbGUgZXQgbW9zYWlra2RhdGFzZXR0LjxkaXY+PGJyLz5EZW4ga29uc3RhbnRlIHZlcmRpZW4gYnJ1a2VzIGZvciBodmVyIHBpa3NlbHZlcmRpIGkgcmFzdGVyZXQuPC9kaXY+XCIsXG5cdFx0Y29udG91ck5hbWU6IFwiQ29udG91clwiLFxuXHRcdGNvbnRvdXJTbmlwOiBcIk9wcHJldHRlciBrb250dXJsaW5qZXIuXCIsXG5cdFx0Y29udG91ckRlc2M6IFwiQ29udG91ci1mdW5rc2pvbmVuIGdlbmVyZXJlciBrb250dXJsaW5qZXIgdmVkIMOlIGtvYmxlIHNhbW1lbiBwdW5rdGVyIG1lZCBzYW1tZSBow7h5ZGUgZnJhIGV0IHJhc3RlcmjDuHlkZWRhdGFzZXR0LiBLb250dXJlbmUgZXIgaXNvbGluZXIgc29tIGVyIGxhZ2V0IHNvbSByYXN0ZXIgZm9yIHZpc3VhbGlzZXJpbmcuIEbDuGxnZW5kZSBuw7hra2VsZWdlbnNrYXBlciBnasO4ciBkZW5uZSBmdW5rc2pvbmVuIGtyYWZ0aWc6IGtvbnR1cmVyIGJsaXIgcmFza3Qgb2cgZHluYW1pc2sgZ2VuZXJlcnQgcMOlIHN2w6ZydCBzdG9yZSBkYXRhc2V0dCwgZm9yIGVrc2VtcGVsIFdvcmxkIEVsZXZhdGlvbjsga29udHVyZXIga2FuIGdsYXR0ZXMgdXQgZm9yIMOlIGdpIGV0IG1lciBrYXJ0b2dyYWZpc2sgdGlsdGFsZW5kZSB1dHNlZW5kZSBzYW10aWRpZyBzb20ga29udHVyZW5lcyBuw7h5YWt0aWdoZXQgb3BwcmV0dGhvbGRlczsgZHluYW1pc2sga29udHJvbGwgb3ZlciBrb250dXJpbnRlcnZhbGxldCB0aWxieXM7IG11bGlnZSByZXN1bHRhdGVyIGlua2x1ZGVyZXIga29udHVybGluamVyLCBpbmRla3Nrb250dXJlciBvZyBmeWx0ZSBrb250dXJlci48ZGl2Pjxici8+TXVsaWdoZXRlbiB0aWwgw6Ugb3BwcmV0dGUgZXQga29udHVybGFnIHNvbSBldCByYXN0ZXJwcm9kdWt0IGVyIG55dHRpZyBpIGVuIHJla2tlIHNhbW1lbmhlbmdlciwgc2lkZW4ga29udHVyZW5lIGthbiBsZWdnZXMgcMOlIGV0IGthcnQgb2cgZ2kgaW5mb3JtYXNqb24gb20gdGVycmVuZ2V0IHV0ZW4gw6Ugc2tqdWxlIGRlIHVuZGVybGlnZ2VuZGUgZGF0YWVuZS4gRGUgZXIgbnl0dGlnZSBpIGJydWtzb21yw6VkZXIgc29tIGJ5Z2cgb2cgYW5sZWdnLCBsYW5kYnJ1ayBvZyB2YW5uZm9ydmFsdG5pbmcuPC9kaXY+XCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzTmFtZTogXCJDb250cmFzdCBhbmQgQnJpZ2h0bmVzc1wiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc1NuaXA6IFwiSnVzdGVyZXIga29udHJhc3RlbiBvZyBseXNzdHlya2VuIHRpbCBldCByYXN0ZXIuXCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzRGVzYzogXCJDb250cmFzdCBBbmQgQnJpZ2h0bmVzcy1mdW5rc2pvbmVuIGZvcmJlZHJlciB1dHNlZW5kZXQgdGlsIHJhc3RlcmRhdGEgdmVkIMOlIGVuZHJlIGx5c3N0eXJrZW4gb2cga29udHJhc3RlbiBpIGJpbGRldC4gQnJpZ2h0bmVzcyDDuGtlciBkZW4gZ2VuZXJlbGxlIGx5c3N0eXJrZW4gaSBiaWxkZXTigJQgZm9yIGVrc2VtcGVsLCBub2Ugc29tIGdqw7hyIG3DuHJrZSBmYXJnZXIgbGV0dGVyZSBvZyBseXNlIGZhcmdlciBodml0ZXJl4oCUIG1lbnMgQ29udHJhc3QganVzdGVyZXIgZm9yc2tqZWxsZW4gbWVsbG9tIGRlIG3DuHJrZXN0ZSBvZyBseXNlc3RlIGZhcmdlbmUuPGRpdj48YnIvPkRlbm5lIGZ1bmtzam9uZW4gZW5kcmVyIHBpa3NlbHZlcmRpZW5lLiBEZW4gYsO4ciBkZXJmb3IgYnJ1a2VzIG7DpXIgZHUgdmlsIGZvcmJlZHJlIHByZXNlbnRhc2pvbmVuIGF2IGRhdGFlbmUgb2cgaWtrZSBodmlzIGR1IGhhciB0ZW5rdCDDpSBicnVrZSBkYXRhZW5lIHNvbSBlbiBkZWwgYXYgZW4gYW5hbHlzZSBzb20ga3JldmVyIHLDpSBwaWtzZWx2ZXJkaWVyLiBEZW5uZSBmdW5rc2pvbmVuIGVyIG55dHRpZyBuw6VyIGR1IHB1Ymxpc2VyZXIgZGF0YWVuZSBzb20gZW4gYmlsZGV0amVuZXN0ZSBzb20ga2FuIGJydWtlcyBpIGFwcGxpa2Fzam9uZXIgdXRlbiBtdWxpZ2hldGVuIHRpbCDDpSBlbmRyZSBiaWxkZW5zIGtvbnRyYXN0IG9nIGx5c3N0eXJrZSwgZWxsZXIgZm9yIMOlIHNpa3JlIGF0IGRhdGFlbmUgdmlzZXMgbWVkIGRpbmUgZm9yZXRydWtuZSBpbm5zdGlsbGluZ2VyLjwvZGl2PlwiLFxuXHRcdGNvbnZvbHV0aW9uTmFtZTogXCJLb252b2x2ZXJpbmdcIixcblx0XHRjb252b2x1dGlvblNuaXA6IFwiQnJ1a2VyIGV0IGZpbHRlciBzb20gc2thbCBnasO4cmUgc2thcnBlcmUsIG1lciB1a2xhcnQsIG9wcGRhZ2Uga2FudGVyLCBnbGF0dGUgdXQgZWxsZXIgbGFnZSBlbiBncmFkaWVudCBvdmVyIGV0IHJhc3Rlci5cIixcblx0XHRjb252b2x1dGlvbkRlc2M6IFwiQ29udm9sdXRpb24tZnVua3Nqb25lbiB1dGbDuHJlciBmaWx0cmVyaW5nIHDDpSBwaWtzZWx2ZXJkaWVuZSBpIGV0IGJpbGRlLCBzb20ga2FuIGJydWtlcyB0aWwgw6UgZ2rDuHJlIGV0IGJpbGRlIHNrYXJwZXJlLCB0aWxzbMO4cmUgZXQgYmlsZGUsIG9wcGRhZ2Uga2FudGVyIGlubmVuZm9yIGV0IGJpbGRlIGVsbGVyIGFuZHJlIGtqZXJuZWJhc2VydGUgZm9yYmVkcmluZ2VyLiBGaWx0cmUgYnJ1a2VzIHRpbCDDpSBmb3JiZWRyZSBrdmFsaXRldGVuIHDDpSByYXN0ZXJiaWxkZXQgdmVkIMOlIGVsaW1pbmVyZSBmYWxza2UgZGF0YSBlbGxlciBmb3JiZWRyZSBnZW9vYmpla3RlciBpIGRhdGFlbmUuIERpc3NlIGtvbnZvbHZlcmluZ3NmaWx0cmVuZSBibGlyIGJydWt0IHDDpSBlbiBiZXZlZ2VsaWcsIG92ZXJsYXBwZW5kZSBramVybmUgKHZpbmR1IGVsbGVyIG5hYm9sYWcpLCBzbGlrIHNvbSAzIGdhbmdlciAzLiBLb252b2x2ZXJpbmdzZmlsdHJlcmUgZnVuZ2VyZXIgdmVkIMOlIGJlcmVnbmUgcGlrc2VsdmVyZGllbiBiYXNlcnQgcMOlIHZla3RlbiB0aWwgbmFib3Bpa3NsZW5lLlwiLFxuXHRcdGNvcnJpZG9yTmFtZTogXCJDb3JyaWRvclwiLFxuXHRcdGNvcnJpZG9yU25pcDogXCJCZXJlZ25lciBzdW1tZW4gYXYgYWtrdW11bGVydGUga29zdG5hZGVyIGZvciB0byBha2t1bXVsZXJ0ZSBrb3N0bmFkc3Jhc3RlcmUuXCIsXG5cdFx0Y29ycmlkb3JEZXNjOiBcIkNvcnJpZG9yLWZ1bmtzam9uZW4gYmVyZWduZXIgc3VtbWVuIGF2IGFra3VtdWxlcnRlIGtvc3RuYWRlciBmb3IgdG8gYWtrdW11bGVydGUga29zdG5hZHNyYXN0ZXJlLiBNZW5zIHRvIGh2aWxrZSBzb20gaGVsc3QgcmFzdGVyIGthbiBicnVrZXMgdGlsIGlubmRhdGEsIGZvciDDpSBvcHBuw6UgZXQgbWVuaW5nc2Z5bHQgcmVzdWx0YXQsIGLDuHIgZGUgdsOmcmUgdWVuZHJlZGUgYWtrdW11bGVydGUga29zdG5hZHNyYXN0ZXJlLiBSZWtrZWbDuGxnZW4gYXYgZGUgdG8gaW5uZGF0ZW5lIGVyIGlycmVsZXZhbnQuXCIsXG5cdFx0Y29zSE5hbWU6IFwiQ29zSFwiLFxuXHRcdGNvc0hTbmlwOiBcIkJlcmVnbmVyIGh5cGVyYm9sc2sgY29zaW51cyBmb3IgY2VsbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRjb3NIRGVzYzogXCJGdW5rc2pvbmVuIGJlcmVnbmVyIGh5cGVyYm9sc2sgY29zaW51cyBmb3IgcGlrc2xlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0Y29zTmFtZTogXCJDb3NcIixcblx0XHRjb3NTbmlwOiBcIkJlcmVnbmVyIGNvc2ludXMgYXYgZW4gY2VsbGUgaSByYXN0ZXIuXCIsXG5cdFx0Y29zRGVzYzogXCJGdW5rc2pvbmVuIGJlcmVnbmVyIGNvc2ludXMgZm9yIHBpa3NsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uTmFtZTogXCJDb3N0IEFsbG9jYXRpb25cIixcblx0XHRjb3N0QWxsb2NhdGlvblNuaXA6IFwiQmVyZWduZXIsIGZvciBodmVyIGNlbGxlLCBkZW4gbWluc3Qga29zdG5hZHNrcmV2ZW5kZSBraWxkZSwgYmFzZXJ0IHDDpSBkZW4gbGF2ZXN0ZSBha2t1bXVsZXJ0ZSBrb3N0bmFkZW4gb3ZlciBlbiBrb3N0bmFkc292ZXJmbGF0ZS5cIixcblx0XHRjb3N0QWxsb2NhdGlvbkRlc2M6IFwiQ29zdCBBbGxvY2F0aW9uLWZ1bmtzam9uZW4gYmVyZWduZXIsIGZvciBodmVyIGNlbGxlLCBkZW4gbWluc3Qga29zdG5hZHNrcmV2ZW5kZSBraWxkZSwgYmFzZXJ0IHDDpSBkZW4gbGF2ZXN0ZSBha2t1bXVsZXJ0ZSBrb3N0bmFkZW4gb3ZlciBlbiBrb3N0bmFkc292ZXJmbGF0ZS5cIixcblx0XHRjb3N0QmFja0xpbmtOYW1lOiBcIkNvc3QgQmFjayBMaW5rXCIsXG5cdFx0Y29zdEJhY2tMaW5rU25pcDogXCJEZWZpbmVyZXIgbmFib2VuIHNvbSBlciBkZW4gbmVzdGUgY2VsbGVuIHDDpSBkZW4gYWtrdW11bGVydGUgbWluc3RlIGtvc3RuYWRzcnV0ZW4sIHRpbCBraWxkZW4gZm9yIGRlbiBtaW5zdGUga29zdG5hZHNraWxkZW4uXCIsXG5cdFx0Y29zdEJhY2tMaW5rRGVzYzogXCJDb3N0IEJhY2sgTGluay1mdW5rc2pvbmVuIGRlZmluZXJlciBkZW4gbmVzdGUgbmFib2NlbGxlbiBsYW5ncyBkZW4gYWtrdW11bGVydGUgbWluc3RlIGtvc3RuYWRzcnV0ZW4gdGlsIGRlbiBtaW5zdGUga29zdG5hZHNraWxkZW4uPGRpdj48YnIvPkJhY2sgTGluay1yYXN0ZXJldCBpbm5laG9sZGVyIHZlcmRpZXIgZnJhIG51bGwgdGlsIMOldHRlLiBWZXJkaWVuZSBkZWZpbmVyZXIgcmV0bmluZ2VuIGVsbGVyIGlkZW50aWZpc2VyZXIgbmVzdGUgbmFib2NlbGxlIChkZW4gZXR0ZXJmw7hsZ2VuZGUgY2VsbGVuKSBsYW5ncyBydXRlbiBtZWQgbGF2ZXN0IGFra3VtdWxlcnQga29zdG5hZCBmcmEgZW4gY2VsbGUgb2cgZnJlbSB0aWwga2lsZGVuIGZvciBsYXZlc3RlIGtvc3RuYWRzYmVyZWduaW5nLiBIdmlzIHJ1dGVuIHNrYWwgZ8OlIHRpbCBkZW4gcmlrdGlnZSBuYWJvZW4sIGJsaXIgY2VsbGVuIHRpbG9yZG5ldCB2ZXJkaWVuIDEsIG9nIDIgZm9yIGRlbiBjZWxsZW4gbmVkZXJzdCB0aWwgaMO4eXJlIGRpYWdvbmFsdCwgb2cgZm9ydHNldHRlciB2aWRlcmUgbWVkIHVydmlzZXJlbi4gVmVyZGllbiAwIGVyIHJlc2VydmVydCBmb3Iga2lsZGVjZWxsZXIuPC9kaXY+XCIsXG5cdFx0Y29zdERpc3RhbmNlTmFtZTogXCJDb3N0IERpc3RhbmNlXCIsXG5cdFx0Y29zdERpc3RhbmNlU25pcDogXCJCZXJlZ25lciBkZW4gbWluc3RlIGFra3VtdWxlcnRlIGtvc3RuYWRzYXZzdGFuZGVuIGZvciBodmVyIGNlbGxlIGZyYSBlbGxlciB0aWwgZGVuIG1pbnN0IGtvc3RuYWRza3JldmVuZGUga2lsZGVuLCBvdmVyIGVuIGtvc3RuYWRzb3ZlcmZsYXRlLlwiLFxuXHRcdGNvc3REaXN0YW5jZURlc2M6IFwiQ29zdCBEaXN0YW5jZS1mdW5rc2pvbmVuIGJlcmVnbmVyIGRlbiBtaW5zdGUgYWtrdW11bGVydGUga29zdG5hZHNhdnN0YW5kZW4gZm9yIGh2ZXIgY2VsbGUgZnJhIGVsbGVyIHRpbCBkZW4gbWluc3Qga29zdG5hZHNrcmV2ZW5kZSBraWxkZW4sIG92ZXIgZW4ga29zdG5hZHNvdmVyZmxhdGUuXCIsXG5cdFx0Y29zdFBhdGhOYW1lOiBcIkNvc3QgUGF0aFwiLFxuXHRcdGNvc3RQYXRoU25pcDogXCJCZXJlZ25lciBtaW5zdGUga29zdG5hZHNydXRlbiBmcmEgZW4ga2lsZGUgdGlsIGVuIGRlc3RpbmFzam9uLlwiLFxuXHRcdGNvc3RQYXRoRGVzYzogXCJEZW4gZ2xvYmFsZSBDb3N0IFBhdGgtZnVua3Nqb25lbiBiZXJlZ25lciBtaW5zdGUga29zdG5hZHNydXRlIGZyYSBlbiBraWxkZSB0aWwgZW4gZGVzdGluYXNqb24uPGRpdj48YnIvPkRlbm5lIGZ1bmtzam9uZW4gcHJvZHVzZXJlciBldCB1dGRhdGFyYXN0ZXIgc29tIGZpbm5lciBydXRlbiBlbGxlciBydXRlbmUgbWVkIGxhdmVzdCBrb3N0bmFkIGZyYSB1dHZhbGd0ZSBzdGVkZXIgdGlsIG7DpnJtZXN0ZSBraWxkZWNlbGxlIHNvbSBlciBkZWZpbmVydCBpbm5lbmZvciBkZW4gYWtrdW11bGVydGUga29zdG5hZHNvdmVyZmxhdGVuLCBpIGJldHlkbmluZ2VuIGtvc3RuYWRzYXZzdGFuZC48L2Rpdj5cIixcblx0XHRjdXJ2YXR1cmVOYW1lOiBcIkN1cnZhdHVyZVwiLFxuXHRcdGN1cnZhdHVyZVNuaXA6IFwiQmVyZWduZXIga3J1bW5pbmdlbiBhdiBlbiByYXN0ZXJvdmVyZmxhdGUsIGV2ZW50dWVsdCBvZ3PDpSBwcm9maWwgb2cgcGxhbmtydW1uaW5nLlwiLFxuXHRcdGN1cnZhdHVyZURlc2M6IFwiQ3VydmF0dXJlLWZ1bmtzam9uZW4gdmlzZXIgZm9ybWVuIGVsbGVyIGtydW1uaW5nZW4gYXYgaGVsbGluZ2VuLiBFbiBkZWwgYXYgZW4gb3ZlcmZsYXRlIGthbiB2w6ZyZSBrb25rYXYgZWxsZXIga29udmVrczsgZHUga2FuIHNlIGRldCB2ZWQgw6Ugc2Uga3J1bW5pbmdzdmVyZGllbi4gS3J1bW5pbmdlbiBiZXJlZ25lcyB2ZWQgw6UgcmVnbmUgdXQgZGV0IGFuZHJlIGRlcml2YXRldCBhdiBvdmVyZmxhdGVuLjxkaXY+PGJyLz5VdGRhdGFlbmUgZnJhIEN1cnZhdHVyZS1mdW5rc2pvbmVuIGthbiBicnVrZXMgdGlsIMOlIGJlc2tyaXZlIGRlIGZ5c2lza2UgZWdlbnNrYXBlbmUgdGlsIGV0IG5lZHNsYWdzZmVsdCBpIGV0IGZvcnPDuGsgcMOlIMOlIGZvcnN0w6UgZXJvc2pvbnMtIG9nIGF2bMO4cHNwcm9zZXNzZXIuIEtydW1uaW5nc3ZlcmRpZW4ga2FuIGJydWtlcyB0aWwgw6UgZmlubmUgam9yZGVyb3Nqb25zbcO4bnN0cmUgb2cgZm9yZGVsaW5nIGF2IHZhbm4gcMOlIGxhbmQuIFByb2ZpbGt1cnZhdHVyZW4gcMOldmlya2VyIGVuIHN0csO4bWluZ3MgYWtzZWxlcmFzam9uIG9nIHJldGFyZGFzam9uIG9nIHDDpXZpcmtlciBkZXJmb3IgZXJvc2pvbiBvZyBhdnNldG5pbmcuIFBsYW5mb3Jta3J1bW5pbmdlbiBww6V2aXJrZXIgc3Ryw7htbmluZ2VucyBrb252ZXJnZW5zIG9nIGRpdmVyZ2Vucy48L2Rpdj5cIixcblx0XHRkaXZpZGVOYW1lOiBcIkRlbGUgcMOlXCIsXG5cdFx0ZGl2aWRlU25pcDogXCJEZWxlciB2ZXJkaWVuZSB0aWwgdG8gcmFzdGVyIHDDpSBwaWtzZWwgZm9yIHBpa3NlbC1iYXNpcy5cIixcblx0XHRkaXZpZGVEZXNjOiBcIkRpdmlkZS1mdW5rc2pvbmVuIGRlbGVyIHZlcmRpZW5lIHRpbCB0byByYXN0ZXIgcMOlIHBpa3NlbCBmb3IgcGlrc2VsLWJhc2lzLlwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsTmFtZTogXCJFbGV2YXRpb24gVm9pZCBGaWxsXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxTbmlwOiBcIkJydWtlcyB0aWwgw6Ugb3BwcmV0dGUgcGlrc2xlciBkZXIgZGV0IGZpbm5lcyBodWxsIGkgaMO4eWRlZGF0YWVuZSBkaW5lLlwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsRGVzYzogXCJFbGV2YXRpb24gVm9pZCBGaWxsLWZ1bmtzam9uZW4gYnJ1a2VzIHRpbCDDpSBvcHByZXR0ZSBwaWtzbGVyIGRlciBkZXQgZmlubmVzIGh1bGwgaSBkaW4gaMO4eWRlLjxkaXY+PGJyLz5EZXQgb3Bwc3TDpXIgdG9tcm9tIG7DpXIgZGV0IGlra2UgZXIgbm9lbiBwdW5rdGVyIHNhbWxldCBpbm4gaSBvbXLDpWRldCwgcmVwcmVzZW50ZXJ0IGF2IGVuIHBpa3NlbCBpIGRldCByZXN1bHRlcmVuZGUgcmFzdGVyZXQuIFRvbXJvbSBmb3LDpXJzYWtlcyBvZnRlIGF2IHZhbm5sZWdlbWVyLCBrbGFzc2V0eXBldmFsZyBlbGxlciB1dGVzdGVuZ2luZy4gRnlsbGluZyBhdiB0b21yb20gYnJ1a2VzIG1lc3QgbsOlciBtYW4gbGFnZXIgZW4gYmFra2VvdmVyZmxhdGUuPC9kaXY+XCIsXG5cdFx0ZXF1YWxUb05hbWU6IFwiRXIgbGlrXCIsXG5cdFx0ZXF1YWxUb1NuaXA6IFwiVXRmw7hyZXIgZW4gcmVsYXNqb25lbGwgZXF1YWwtdG8tb3BlcmFzam9uIHDDpSB0byBpbm5kYXRhIHDDpSBlbiBjZWxsZSBmb3IgY2VsbGUtYmFzaXMuIFJldHVybmVyZXIgMSBmb3IgY2VsbGVyIGRlciBkZXQgZsO4cnN0ZSByYXN0ZXJldCBlciBsaWsgZGV0IGFuZHJlIHJhc3RlcmV0LCBvZyAwIGZvciBjZWxsZXIgZGVyIGRlIGlra2UgZXIgbGlrZS5cIixcblx0XHRlcXVhbFRvRGVzYzogXCJGdW5rc2pvbmVuIHV0ZsO4cmVyIGVuIHRpbHN2YXJlbmRlIG9wZXJhc2pvbiBww6UgdG8gcmFzdGVyIHDDpSBlbiBwaWtzZWwgZm9yIHBpa3NlbC1iYXNpcy4gRGVuIHJldHVybmVyZXIgdmVyZGllbiAxIGZvciBwaWtzbGVyIGRlciBkZXQgZsO4cnN0ZSByYXN0ZXJldCBlciBsaWsgZGV0IGFuZHJlIHJhc3RlcmV0LCBvZyB2ZXJkaWVuIDAgZm9yIHBpa3NsZXIgZGVyIGRlIGlra2UgZXIgbGlrZS5cIixcblx0XHRldWNBbGxvY2F0aW9uTmFtZTogXCJFdWNsaWRlYW4gQWxsb2NhdGlvblwiLFxuXHRcdGV1Y0FsbG9jYXRpb25TbmlwOiBcIkJlcmVnbmVyLCBmb3IgaHZlciBjZWxsZSwgbsOmcm1lc3RlIGtpbGRlIGJhc2VydCBww6UgZXVrbGlkaXNrIGF2c3RhbmQuXCIsXG5cdFx0ZXVjQWxsb2NhdGlvbkRlc2M6IFwiRXVjbGlkZWFuIEFsbG9jYXRpb24tZnVua3Nqb25lbiBiZXJlZ25lciwgZm9yIGh2ZXIgY2VsbGUsIG7DpnJtZXN0ZSBraWxkZSBiYXNlcnQgcMOlIGV1a2xpZGlzayBhdnN0YW5kLlwiLFxuXHRcdGV1Y0RpcmVjdGlvbk5hbWU6IFwiRXVjbGlkZWFuIERpcmVjdGlvblwiLFxuXHRcdGV1Y0RpcmVjdGlvblNuaXA6IFwiQmVyZWduZXIsIGZvciBodmVyIGNlbGxlLCByZXRuaW5nZW4gaSBncmFkZXIgdGlsIG7DpnJtZXN0ZSBraWxkZS5cIixcblx0XHRldWNEaXJlY3Rpb25EZXNjOiBcIkV1Y2xpZGVhbiBEaXJlY3Rpb24tZnVua3Nqb25lbiBiZXJlZ25lciwgZm9yIGh2ZXIgY2VsbGUsIHJldG5pbmdlbiBpIGdyYWRlciB0aWwgbsOmcm1lc3RlIGtpbGRlLiA8ZGl2Pjxici8+UmV0bmluZ2VuIGJlcmVnbmVzIGZyYSBodmVydCBjZWxsZXNlbnRlciB0aWwgbWlkdGVuIGF2IGtpbGRlY2VsbGVuIHNvbSBlciBuw6ZybWVzdC4gVmVyZGlvbXLDpWRldCBlciBmcmEgMCBncmFkZXIgdGlsIDM2MCBncmFkZXIsIG1lZCAwIHJlc2VydmVydCBmb3Iga2lsZGVjZWxsZW5lLiDDmHN0bGlnIHJldG5pbmcgKGjDuHlyZSkgZXIgOTAgb2cgdmVyZGllbmUgw7hrZXIgbWVkIHVydmlzZXJlbiAoMTgwIGVyIHPDuHIsIDI3MCBlciB2ZXN0IG9nIDM2MCBlciBub3JkKS48L2Rpdj5cIixcblx0XHRldWNEaXN0YW5jZU5hbWU6IFwiRXVjbGlkZWFuIERpc3RhbmNlXCIsXG5cdFx0ZXVjRGlzdGFuY2VTbmlwOiBcIkJlcmVnbmVyLCBmb3IgaHZlciBjZWxsZSwgZGVuIGV1a2xpZHNrZSBhdnN0YW5kZW4gdGlsIGRlbiBuw6ZybWVzdGUga2lsZGVuLlwiLFxuXHRcdGV1Y0Rpc3RhbmNlRGVzYzogXCJFdWNsaWRlYW4gRGlzdGFuY2UtZnVua3Nqb25lbiBiZXJlZ25lciwgZm9yIGh2ZXIgY2VsbGUsIGRlbiBldWtsaWRza2UgYXZzdGFuZGVuIHRpbCBkZW4gbsOmcm1lc3RlIGtpbGRlbi5cIixcblx0XHRleHAxME5hbWU6IFwiRXhwMTBcIixcblx0XHRleHAxMFNuaXA6IFwiQmVyZWduZXIgYmFzZSAxMC1la3Nwb25lbnRlbiBmb3IgY2VsbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRleHAxMERlc2M6IFwiRXhwIDEwLWZ1bmtzam9uZW4gYmVyZWduZXIgYmFzZSAxMC1la3Nwb25lbnRlbiBmb3IgcGlrc2xlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0ZXhwMk5hbWU6IFwiRXhwMlwiLFxuXHRcdGV4cDJTbmlwOiBcIkJlcmVnbmVyIGJhc2UgMi1la3Nwb25lbnRlbiBmb3IgY2VsbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRleHAyRGVzYzogXCJEbm5lIGZ1bmtzam9uZW4gYmVyZWduZXIgYmFzZSAyLWVrc3BvbmVudGVuIGZvciBwaWtzbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRleHBOYW1lOiBcIkV4cFwiLFxuXHRcdGV4cFNuaXA6IFwiQmVyZWduZXIgYmFzZSBlLWVrc3BvbmVudGVuIGZvciBjZWxsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGV4cERlc2M6IFwiRG5uZSBmdW5rc2pvbmVuIGJlcmVnbmVyIGJhc2UgZS1la3Nwb25lbnRlbiBmb3IgcGlrc2xlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0ZXh0cmFjdEJhbmROYW1lOiBcIkV4dHJhY3QgQmFuZHNcIixcblx0XHRleHRyYWN0QmFuZFNuaXA6IFwiQW5naXIgaHZpbGtlIGLDpW5kIHNvbSBkZXQgc2thbCBqb2JiZXMgbWVkIG7DpXIgZHUgYnJ1a2VyIGRhdGFzZXR0IG1lZCBmbGVyZSBiw6VuZC5cIixcblx0XHRleHRyYWN0QmFuZERlc2M6IFwiIEV4dHJhY3QgQmFuZHMtZnVua3Nqb25lbiBsYXIgZGVnIHRyZWtrZSB1dCBldCBlbGxlciBmbGVyZSBiw6VuZCBmcmEsIGVsbGVyIG9tb3JnYW5pc2VyZSBiw6VuZGVuZSBpLCBldCByYXN0ZXJkYXRhc2V0dCBtZWQgZmxlcmUgYsOlbmQuPGRpdj48YnIvPkR1IGthbiBicnVrZSBFeHRyYWN0IEJhbmRzLWZ1bmtzam9uZW4gZsO4ciBhbmRyZSBmdW5rc2pvbmVyLCBmb3IgZWtzZW1wZWwgQXJpdGhtZXRpYywgZm9yIMOlIGtvbnRyb2xsZXJlIGh2aWxrZSBiw6VuZCBzb20gYnJ1a2VzIHNvbSBpbm5kYXRhIGkgbmVzdGUgZnVua3Nqb24uPC9kaXY+XCIsXG5cdFx0ZmlsbE5hbWU6IFwiRnlsbFwiLFxuXHRcdGZpbGxTbmlwOiBcIkZ5bGxlciBzZW5rbmluZ2VyIG9nIHRvcHBlciBpIGVuIGjDuHlkZW92ZXJmbGF0ZXJhc3RlciBmb3Igw6UgZmplcm5lIHNtw6UgZmVpbCBpIGRhdGFlbmUuXCIsXG5cdFx0ZmlsbERlc2M6IFwiR2xvYmFsIEZpbGwtZnVua3Nqb25lbiBsb2thbGlzZXJlciBvZyBmeWxsZXIgc2Vua25pbmdlciBvZyB0b3BwZXIgaSBlbiBow7h5ZGVvdmVyZmxhdGVyYXN0ZXIgZm9yIMOlIGZqZXJuZSBzbcOlIGZlaWwgaSBkYXRhZW5lLiBGdW5rc2pvbmVuIGZ5bGxlciBpbm4gZW4gaXRlcmF0aXYgcHJvc2VzcyBpbm50aWwgYWxsZSBzZW5rbmluZ2VyIGZ5bGxlcyBpbm5lbmZvciBkZW4gYW5naXR0ZSBaLWdyZW5zZW4uPGRpdj48YnIvPk7DpXIgZW4gaMO4eWRlb3ZlcmZsYXRlIG9wcHJldHRlcyBtZWQgT3J0aG8gTWFwcGluZy12ZXJrdMO4eSBlbGxlciBww6UgYW5uZW4gbcOldGUsIGVyIGRldCBvZnRlIHNtw6UsIG1lbiB2ZXNlbnRsaWdlIGZlaWwgaSBmb3JtIGF2IHNlbmtuaW5nZXIgb2cgdG9wcGVyIGkgZGF0YWVuZS4gSSBmb3RvZ3JhbW1ldHJpIGJsaXIgc2Vua25pbmdlciBvZyB0b3BwZXIgb2Z0ZSBrYWx0IGh1bGwgb2cgc3Bpc3Nlci4gU2lkZW4gb3ZlcmZsYXRlZGF0YSBvZnRlIGJydWtlcyBpIG1vZGVsbGVyaW5nLCBmb3IgZWtzZW1wZWwgaHlkcm9sb2dpc2sgbW9kZWxsZXJpbmcsIGVyIGRldCB2aWt0aWcgw6Uga29ycmlnZXJlIGRpc3NlIHNlbmtuaW5ncy0gb2cgdG9wcGZlaWxlbmUgcMOlIGVuIG3DpXRlIHNvbSBlciBpIHNhbXN2YXIgbWVkIGRlIG9tZ2l2ZW5kZSBkYXRhZW5lLjwvZGl2PlwiLFxuXHRcdGZsb2F0TmFtZTogXCJGbHl0XCIsXG5cdFx0ZmxvYXRTbmlwOiBcIktvbnZlcnRlcmVyIGh2ZXIgcGlrc2VsdmVyZGkgaSBldCByYXN0ZXIgdGlsIGVuIHJlcHJlc2VudGFzam9uIG1lZCBmbHl0cHVua3Rlci5cIixcblx0XHRmbG9hdERlc2M6IFwiRmxvYXQtZnVua3Nqb25lbiBrb252ZXJ0ZXJlciBodmVyIHBpa3NlbHZlcmRpIGkgZXQgcmFzdGVyIHRpbCBlbiByZXByZXNlbnRhc2pvbiBtZWQgZmx5dHB1bmt0ZXIuXCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvbk5hbWU6IFwiU3Ryw7htbmluZ3Nha2t1bXVsZXJpbmdcIixcblx0XHRmbG93QWNjdW11bGF0aW9uU25pcDogXCJPcHByZXR0ZXIgZXQgcmFzdGVyIG1lZCBha2t1bXVsZXJ0IGZseXQgaSBodmVyIGNlbGxlLiBFbiB2ZWt0ZmFrdG9yIGthbiBldmVudHVlbHQgYnJ1a2VzLlwiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25EZXNjOiBcIkRlbiBnbG9iYWxlIGZ1bmtzam9uZW4gRmxvdyBBY2N1bXVsYXRpb24gbGFnZXIgZXQgcmFzdGVyIGF2IGFra3VtdWxlcnQgc3Ryw7htbmluZyBpIGh2ZXIgcGlrc2VsLCBzb20gZmFzdHNsw6VzIHZlZCDDpSBzYW1sZSB2ZWt0ZW4gZm9yIGFsbGUgcGlrc2xlciBzb20gc3Ryw7htbWVyIGlubiBpIGh2ZXIgbmVkZW5mb3JsaWdnZW5kZSBwaWtzZWwuIEh2aXMgaW5nZW4gdmVrdHJhc3RlciBlciBvcHBnaXR0LCBibGlyIGVuIHZla3QgcMOlIDEgYnJ1a3QgaHZlciBwaWtzZWwsIG9nIHZlcmRpZW4gYXYgcGlrc2xlciBpIHV0ZGF0YXJhc3RldCBlciBhbnRhbGxldCBwaWtzbGVyIHNvbSBzdHLDuG1tZXIgaW5uIGkgaHZlciBwaWtzZWwuPGRpdj48YnIvPlV0ZGF0YXBpa3NsZXIgbWVkIGjDuHkgYWtrdW11bGVydCB0aWxzdHLDuG1taW5nIGVyIG9tcsOlZGVyIG1lZCBrb25zZW50cmVydCBzdHLDuG1uaW5nIG9nIGthbiBicnVrZXMgdGlsIMOlIGlkZW50aWZpc2VyZSBzdHLDuG1uaW5nc2thbmFsZXIuIFV0ZGF0YXBpa3NsZXIgbWVkIGFra3VtdWxlcnQgdGlsc3Ryw7htbWluZyBsaWsgbnVsbCBlciBsb2thbGUsIHRvcG9ncmFmaXNrZSBow7h5ZGVyLCBvZyBrYW4gYnJ1a2VzIHRpbCDDpSBpZGVudGlmaXNlcmUgw6VzcnlnZ2VyLjwvZGl2PlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25OYW1lOiBcIlN0csO4bW5pbmdzcmV0bmluZ1wiLFxuXHRcdGZsb3dEaXJlY3Rpb25TbmlwOiBcIk9wcHJldHRlciBldCByYXN0ZXIgYXYgc3Ryw7htbmluZ3NyZXRuaW5nZW4gZnJhIGh2ZXIgcGlrc2VsIHRpbCBkZW4gYnJhdHRlc3RlIG5lZGVuZm9ybGlnZ2VuZGUgbmFib2VuLlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25EZXNjOiBcIkVuIGF2IG7DuGtsZW5lIHRpbCDDpSBhdmxlZGUgaHlkcm9sb2dpc2tlIGthcmFrdGVyaXN0aWtrZXIgcMOlIGVuIG92ZXJmbGF0ZSBlciBldm5lbiB0aWwgw6UgYmVzdGVtbWUgc3Ryw7htbmluZ3NyZXRuaW5nZW4gZnJhIGh2ZXIgcGlrc2VsIGkgcmFzdGVyZXQuIEZsb3cgRGlyZWN0aW9uLXJhc3RlcmZ1bmtzam9uZW4gdGFyIGVuIG92ZXJmbGF0ZSBzb20gaW5uZGF0YSBvZyBvcHByZXR0ZXIgZXQgcmFzdGVyIGF2IHN0csO4bW5pbmdzcmV0bmluZyBmcmEgaHZlciBwaWtzZWwgdGlsIGRlbiBicmF0dGVzdGUgbmVkZW5mb3JsaWdnZW5kZSBuYWJvZW4uIEZsb3cgRGlyZWN0aW9uLWZ1bmtzam9uZW4gc3TDuHR0ZXIgdHJlIHN0csO4bW5pbmdzbW9kZWxsZXJpbmdzbWV0b2RlcjogRDggKMOldHRlIHJldG5pbmdlciksIE11bHRpLUZsb3cgRGlyZWN0aW9uIChNRkQpIG9nIEQtSW5maW5pdHkgKERJTkYpLiBcIixcblx0XHRmbG93RGlzdGFuY2VOYW1lOiBcIkZsb3cgRGlzdGFuY2VcIixcblx0XHRmbG93RGlzdGFuY2VTbmlwOiBcIkZvciBodmVyIHBpa3NlbCBiZXJlZ25lcyBkZW4gbGF2ZXN0ZSBuZWRvdmVyaGVsbGVuZGUgaG9yaXNvbnRhbGUgZWxsZXIgdmVydGlrYWxlIGF2c3RhbmRlbiB0aWwgY2VsbGVyIHDDpSBlbiBlbHYgZWxsZXIgc3Ryw7htIHNvbSBkZSBzdHLDuG1tZXIgaW5uIGkuXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlRGVzYzogXCJGb3IgaHZlciBwaWtzZWwgYmVyZWduZXIgZnVua3Nqb25lbiBkZW4gbGF2ZXN0ZSBuZWRvdmVyaGVsbGVuZGUgaG9yaXNvbnRhbGUgZWxsZXIgdmVydGlrYWxlIGF2c3RhbmRlbiB0aWwgcGlrc2VsKGVyKSBww6UgZW4gZWx2IGVsbGVyIHN0csO4bSBzb20gZGUgc3Ryw7htbWVyIGlubiBpLiBIdmlzIGV0IHZhbGdmcmkgc3Ryw7htbmluZ3NyZXRuaW5nc3Jhc3RlciB0aWxieXMsIHZpbCByZXRuaW5nZW4oZSkgZm9yIG5lZG92ZXJoZWxsaW5nZW4gdsOmcmUgYmVncmVuc2V0IHRpbCBkZSBzb20gZXIgZGVmaW5lcnQgYXYgaW5uZGF0YXN0csO4bW5pbmdzcmV0bmluZ3NyYXN0ZXJldC4gVXRkYXRhZW5lIGVyIGV0IHN0csO4bW5pbmdzYXZzdGFuZHJhc3Rlci5cIixcblx0XHRmb2NhbE5hbWU6IFwiRm9jYWwgU3RhdGlzdGljc1wiLFxuXHRcdGZvY2FsU25pcDogXCJCZXJlZ25lciBmb2thbHN0YXRpc3Rpa2sgZm9yIGh2ZXIgcGlrc2VsIGF2IGV0IGJpbGRlIGJhc2VydCBww6UgZXQgZGVmaW5lcnQgZm9rYWxuYWJvbGFnLlwiLFxuXHRcdGZvY2FsRGVzYzogXCJGb2NhbCBTdGF0aXN0aWNzLWZ1bmtzam9uZW4gYmVyZWduZXIgZm9rYWxzdGF0aXN0aWtrIGZvciBodmVyIHBpa3NlbCBhdiBldCBiaWxkZSBiYXNlcnQgcMOlIGV0IGRlZmluZXJ0IGZva2FsbmFib2xhZy5cIixcblx0XHRnZW9tZXRyaWNOYW1lOiBcIkdlb21ldHJpc2tcIixcblx0XHRnZW9tZXRyaWNTbmlwOiBcIsOYa2VyIHBvc2lzam9uc27DuHlha3RpZ2hldGVuIHRpbCBldCBkYXRhc2V0dCB2ZWQgw6UgdGEgaGVuc3luIHRpbCBow7h5ZGVuLlwiLFxuXHRcdGdlb21ldHJpY0Rlc2M6IFwiR2VvbWV0cmljLWZ1bmtzam9uZW4gcHJvZHVzZXJlciBldCBvcnRva29ycmlnZXJ0IGJpbGRlIGJhc2VydCBww6UgZW4gc2Vuc29yZGVmaW5pc2pvbiBvZyBlbiB0ZXJyZW5nbW9kZWxsLiBEZW4gw7hrZXIgcG9zaXNqb25zbsO4eWFrdGlnaGV0ZW4gdGlsIGV0IGRhdGFzZXR0IHZlZCDDpSB0YSBoZW5zeW4gdGlsIGjDuHlkZW4uXCIsXG5cdFx0Z3JheXNjYWxlTmFtZTogXCJHcmF5c2NhbGVcIixcblx0XHRncmF5c2NhbGVTbmlwOiBcIktvbnZlcnRlcmVyIGV0IGJpbGRlIG1lZCBmbGVyZSBiw6VuZCB0aWwgZXQgZ3LDpXNrYWxhYmlsZGUgbWVkIGV0dCBiw6VuZC5cIixcblx0XHRncmF5c2NhbGVEZXNjOiBcIkRlbm5lIGZ1bmtzam9uZW4ga29udmVydGVyZXIgZXQgYmlsZGUgbWVkIGZsZXJlIGLDpW5kIHRpbCBldCBncsOlc2thbGFiaWxkZSBtZWQgZXR0IGLDpW5kLjxkaXY+PGJyLz5EZW5uZSBmdW5rc2pvbmVuIGJydWtlciBzcGVzaWZpc2VydGUgdmVrdGVyIHDDpSBodmVydCBhdiBpbm5kYXRhYsOlbmRlbmUgb2cgbm9ybWFsaXNlcmVyIHV0ZGF0YWJpbGRldC4gVmVrdGVuZSBibGlyIG9mdGUgYnJ1a3QgZm9yZGkgZW5rZWx0ZSBiw6VuZCBoYXIgdmFyaWVyZW5kZSBiZXR5ZG5pbmcgYXZoZW5naWcgYXYgYnJ1a3NvbXLDpWRldC4gRm9yIGVrc2VtcGVsIGlubmVob2xkZXIgZGV0IGJsw6UgYsOlbmRldCBvZnRlIG1lciBzdMO4eSBlbm4gYW5kcmUgYsOlbmQuPC9kaXY+XCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbE5hbWU6IFwiU3TDuHJyZSBlbm4gZWxsZXIgbGlrXCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbFNuaXA6IFwiVXRmw7hyZXIgZW4gcmVsYXNqb25lbGwgc3TDuHJyZSBlbm4gbGlrLW9wZXJhc2pvbiBww6UgdG8gaW5uZGF0YSBww6UgZW4gY2VsbGUgZm9yIGNlbGxlLWJhc2lzLiBSZXR1cm5lcmVyIDEgZm9yIGNlbGxlciBkZXIgZGV0IGbDuHJzdGUgcmFzdGVyZXQgZXIgc3TDuHJyZSBlbm4gZWxsZXIgbGlrIGRldCBhbmRyZSByYXN0ZXJldCwgb2cgMCBkZW4gaWtrZSBlciBkZXQuXCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbERlc2M6IFwiRnVua3Nqb25lbiB1dGbDuHJlciBlbiByZWxhc2pvbmVsbCBzdMO4cnJlIGVubi0gZWxsZXIgbGlrLW9wZXJhc2pvbiBww6UgdG8gaW5uZGF0YSBww6UgZW4gY2VsbGUgZm9yIGNlbGxlLWJhc2lzLiBEZW4gcmV0dXJuZXJlciBlbiB2ZXJkaSBww6UgMSBmb3IgcGlrc2xlciBkZXIgZGV0IGbDuHJzdGUgcmFzdGVyZXQgZXIgc3TDuHJyZSBlbm4gZWxsZXIgbGlrIGRldCBhbmRyZSByYXN0ZXJldCwgb2cgZW4gdmVyZGkgcMOlIDAgZm9yIHBpa3NsZXIgZGVyIGRldCBmw7hyc3RlIHJhc3RlcmV0IGlra2UgZXIgc3TDuHJyZSBlbm4gZWxsZXIgbGlrIGRldCBhbmRyZSByYXN0ZXJldC5cIixcblx0XHRncmVhdGVyVGhhbk5hbWU6IFwiU3TDuHJyZSBlbm5cIixcblx0XHRncmVhdGVyVGhhblNuaXA6IFwiVXRmw7hyZXIgZW4gcmVsYXNqb25lbGwgc3TDuHJyZSBlbm4tb3BlcmFzam9uIHDDpSB0byBpbm5kYXRhIHDDpSBlbiBjZWxsZSBmb3IgY2VsbGUtYmFzaXMuIFJldHVybmVyZXIgMSBmb3IgY2VsbGVyIGRlciBkZXQgZsO4cnN0ZSByYXN0ZXJldCBlciBzdMO4cnJlIGVubiBkZXQgYW5kcmUgcmFzdGVyZXQsIG9nIDAgZGVuIGlra2UgZXIgZGV0LlwiLFxuXHRcdGdyZWF0ZXJUaGFuRGVzYzogXCJGdW5rc2pvbmVuIHV0ZsO4cmVyIGVuIHJlbGFzam9uZWxsIHN0w7hycmUgZW5uLW9wZXJhc2pvbiBww6UgdG8gaW5uZGF0YSBww6UgZW4gcGlrc2VsIGV0dGVyIHBpa3NlbC1iYXNpcy4gUmV0dXJuZXJlciBlbiB2ZXJkaSBww6UgMSBmb3IgcGlrc2xlciBkZXIgZGV0IGbDuHJzdGUgcmFzdGVyZXQgZXIgc3TDuHJyZSBlbm4gZGV0IGFuZHJlIHJhc3RlcmV0LCBvZyBlbiB2ZXJkaSBww6UgMCBmb3IgcGlrc2xlciBkZXIgZGV0IGbDuHJzdGUgcmFzdGVyZXQgaWtrZSBlciBzdMO4cnJlIGVubiBkZXQgYW5kcmUgcmFzdGVyZXQuXCIsXG5cdFx0aGVhdEluZGV4TmFtZTogXCJWYXJtZWluZGVrc1wiLFxuXHRcdGhlYXRJbmRleFNuaXA6IFwiS29tYmluZXJlciBvbWdpdmVsc2VzdGVtcGVyYXR1ciBvZyByZWxhdGl2IGZ1a3RpZ2hldCBmb3Igw6UgcmV0dXJuZXJlIG9wcGxldmQgdGVtcGVyYXR1ci5cIixcblx0XHRoZWF0SW5kZXhEZXNjOiBcIkRlbm5lIGZ1bmtzam9uZW4gYmVyZWduZXIgb3BwbGV2ZCB0ZW1wZXJhdHVyIGJhc2VydCBww6Ugb21naXZlbHNlc3RlbXBlcmF0dXIgb2cgcmVsYXRpdiBmdWt0aWdoZXQuIERlbiBvcHBsZXZkZSB0ZW1wZXJhdHVyZW4gYmVza3JpdmVzIG9mdGUgc29tIGh2b3IgdmFybXQgZGV0IGbDuGxlcyBmb3IgbWVubmVza2Vrcm9wcGVuLjxkaXY+PGJyLz5EZW5uZSBpbmRla3NlbiBrYW4gdsOmcmUgbnl0dGlnIGZvciDDpSBiZXJlZ25lIGZhcmVyIGkgZm9yYmluZGVsc2UgbWVkIG1lZGlzaW5za2UgcHJvYmxlbWVyIHNvbSBtdXNrZWxrcmFtcGVyLCBkZWh5ZHJlcmluZywgaGV0ZWFuZmFsbCBlbGxlciBtZXIgYWx2b3JsaWdlIGhldGVzbGFnIHDDpSB2YXJtZSBvZyBmdWt0aWdlIGRhZ2VyLiBOw6VyIHJlbGF0aXYgZnVrdGlnaGV0IGVyIGjDuHksIGJsaXIgZGV0IHN0YWRpZyB2YW5za2VsaWdlcmUgZm9yIGtyb3BwZW5zIHN2ZXR0ZSDDpSBmb3JkYW1wZSwgc2xpayBhdCBmb2xrIGlra2UgaGFyIG5vZW4gbmF0dXJsaWcgbcOldGUgw6UgYXZrasO4bGVzIHDDpS4gS2FydCBvdmVyIHZhcm1lcsOlZCBlbGxlciAtYWR2YXJzbGVyIGVyIG9mdGUgZXQgcHJvZHVrdCBhdiBvbWtsYXNzaWZpc2VyaW5nIGF2IHZhcnNlbGluZGVrc3Jlc3VsdGF0ZXQgaSBrbGFzc2VyLCBkZXIgam8gaMO4eWVyZSBpbmRla3N2ZXJkaWVuIGVyLCBkZXN0byBtZXIgc2FubnN5bmxpZyBlciBkZXQgYXQgZGV0IGJsaXIgZW4gYWR2YXJzZWwgZnJlbWZvciBiYXJlIGV0IHLDpWQuPC9kaXY+XCIsXG5cdFx0aGlsbHNoYWRlTmFtZTogXCJIaWxsc2hhZGVcIixcblx0XHRoaWxsc2hhZGVTbmlwOiBcIkxhZ2VyIGVuIDNELXJlcHJlc2VudGFzam9uIGF2IG92ZXJmbGF0ZW4sIG1lZCBzb2xlbnMgcmVsYXRpdmUgcG9zaXNqb24gdGF0dCBpIGJldHJha3RuaW5nIGZvciDDpSBza3lnZ2VsZWdnZSBiaWxkZXQuXCIsXG5cdFx0aGlsbHNoYWRlRGVzYzogXCJIaWxsc2hhZGUtZnVua3Nqb25lbiBwcm9kdXNlcmVyIGVuIGdyw6V0b25ldCAzRC1yZXByZXNlbnRhc2pvbiBhdiB0ZXJyZW5nb3ZlcmZsYXRlbiwgbWVkIHNvbGVucyByZWxhdGl2ZSBwb3Npc2pvbiB0YXR0IGkgYmV0cmFrdG5pbmcgZm9yIMOlIHNreWdnZWxlZ2dlIGJpbGRldC4gPGRpdj48YnIvPlNreWdnZW1vZGVsbGVyaW5nIGVyIGVuIHRla25pa2sgZm9yIMOlIHZpc3VhbGlzZXJlIHRlcnJlbmdldCBpIGhlbmhvbGQgdGlsIGVuIGx5c2tpbGRlIG9nIHNrcsOlbmluZ2VuIG9nIGFzcGVrdGV0IGZvciBow7h5ZGVvdmVyZmxhdGVuLiBEZXQgZXIgZW4ga3ZhbGl0YXRpdiBtZXRvZGUgZm9yIHZpc3VhbGlzZXJpbmcgYXYgdG9wb2dyYWZpIG9nIGdpciBpa2tlIGFic29sdXR0ZSBow7h5ZGV2ZXJkaWVyLiA8L2Rpdj5cIixcblx0XHRpbnROYW1lOiBcIkludFwiLFxuXHRcdGludFNuaXA6IFwiS29udmVydGVyZXIgaHZlciBjZWxsZXZlcmRpIGkgZXQgcmFzdGVyIHRpbCBldCBoZWx0YWxsIHZlZCBoamVscCBhdiB0cnVua2VyaW5nLlwiLFxuXHRcdGludERlc2M6IFwiSW50LWZ1bmtzam9uZW4ga29udmVydGVyZXIgaHZlciBwaWtzZWx2ZXJkaSBpIGV0IHJhc3RlciB0aWwgZXQgaGVsdGFsbCB2ZWQgaGplbHAgYXYgdHJ1bmtlcmluZy5cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFOYW1lOiBcIkludGVycG9sYXRlIElycmVndWxhciBEYXRhXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhU25pcDogXCJJbnRlcnBvbGVyZXIgZnJhIHB1bmt0c2t5ZXIgZWxsZXIgdXJlZ2VsbWVzc2lnZSBydXRlbmV0dC5cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFEZXNjOiBcIkVua2VsdGUgbmV0Q0RGLSBlbGxlciBIREYtZGF0YXNldHQgbGFncmVyIGdlb2xva2Fzam9uZXIgc29tIHVyZWdlbG1lc3NpZyBhZHNraWx0ZSBtYXRyaXNlciBhdiBwaWtzbGVyIGVsbGVyIHB1bmt0ZGF0YS4gTsOlciBkdSBsZWdnZXIgdGlsIGRpc3NlIGRhdGFzZXR0ZW5lIGkgZXQgbW9zYWlra2RhdGFzZXR0LCB0YXIgaW50ZXJwb2xlcnQgdXJlZ2VsbWVzc2lnZSBkYXRhLWZ1bmtzam9uZW4gdXJlZ2VsbWVzc2lnIHJ1dGVuZXR0ZGF0YSBvZyBvbWZvcmRlbGVyIGRlbSBzbGlrIGF0IGh2ZXIgcGlrc2VsIGVyIGF2IGxpayBzdMO4cnJlbHNlIG9nIGVyIGZpcmthbnRldC48ZGl2Pjxici8+TsOlciBkdSBsZWdnZXIgdGlsIHZhcmlhYmxlciBmcmEgbmV0Q0RGIGVsbGVyIEhERiB0aWwgZXQgbW9zYWlra2RhdGFzZXR0LCB2aWwgZGV0IGF1dG9tYXRpc2sgdmVyaWZpc2VyZSBvbSBkYXRhZW5lIGVyIG9yZG5ldCByZWdlbG1lc3NpZy4gSHZpcyBkZSBpa2tlIGVyIGRldCwga2FuIGludGVycG9sZXIgdXJlZ2VsbWVzc2lnZSBkYXRhLWZ1bmtzam9uZW4gYnJ1a2VzIHRpbCDDpSBrb252ZXJ0ZXJlIGRlIHVyZWdlbG1lc3NpZ2UgZGF0YWVuZSB0aWwgZXQgcmVnZWxtZXNzaWcgcnV0ZW5ldHRiYXNlcnQgcmFzdGVyLiBEdSBrYW4gZW5kcmUgaW50ZXJwb2xlcmluZ3NtZXRvZGVuIG9nIGNlbGxlc3TDuHJyZWxzZW4gc29tIGJydWtlcyBpIGludGVycG9sZXIgdXJlZ2VsbWVzc2lnZSBkYXRhcmFzdGVy4oCTZnVua3Nqb25lbi4gRm9yIHJhc3RlcmRhdGEgbWVkIHJlZ2VsbWVzc2lnZSBtZWxsb21yb20gdmlsIGRldCBpa2tlIGJsaSBicnVrIG5vZW4gaW50ZXJwb2xlcmluZywgb2cgZGF0YWVuZSB2aWwgYmxpIGxlc3Qgc29tIGRldCBlci48L2Rpdj5cIixcblx0XHRpc051bGxOYW1lOiBcIklzIE51bGxcIixcblx0XHRpc051bGxTbmlwOiBcIkJlc3RlbW1lciBodmlsa2UgdmVyZGllciBmcmEgaW5uZGF0YXJhc3RlcmV0IHNvbSBlciBOb0RhdGEgcMOlIGVuIGNlbGxlIGV0dGVyIGNlbGxlLWJhc2lzLiBSZXR1cm5lcmVyIGVuIHZlcmRpIHDDpSAxIGh2aXMgaW5uZGF0YXZlcmRpZW4gZXIgTm9EYXRhLCBvZyBlbiB2ZXJkaSBww6UgMCBmb3IgY2VsbGVyIHNvbSBpa2tlIGVyIGRldC5cIixcblx0XHRpc051bGxEZXNjOiBcIklzIE51bGwtZnVua3Nqb25lbiBiZXN0ZW1tZXIgaHZpbGtlIHZlcmRpZXIgZnJhIGlubmRhdGFyYXN0ZXJldCBzb20gZXIgTm9EYXRhIHDDpSBlbiBwaWtzZWwgZXR0ZXIgcGlrc2VsLWJhc2lzLiBEZW4gcmV0dXJuZXJlciBlbiB2ZXJkaSBww6UgMSBodmlzIGlubmRhdGF2ZXJkaWVuIGVyIE5vRGF0YSwgb2cgZW4gdmVyZGkgcMOlIDAgZm9yIHBpa3NsZXIgc29tIGlra2UgZXIgTm9EYXRhLlwiLFxuXHRcdGtlcm5lbERlbnNpdHlOYW1lOiBcIktlcm5lbCBEZW5zaXR5XCIsXG5cdFx0a2VybmVsRGVuc2l0eVNuaXA6IFwiQmVyZWduZXIgc3TDuHJyZWxzZXMgcGVyIGFyZWFsZW5oZXQgZnJhIHB1bmt0LSBlbGxlciBsaW5qZWdlb29iamVrdGVyLCB2ZWQgaGplbHAgYXYgZW4ga2plcm5lZnVua3Nqb24gZm9yIMOlIHRpbHBhc3NlcyBlbiBqZXZuIGtvbmlzayBvdmVyZmxhdGUgdGlsIGh2ZXJ0IHB1bmt0IGVsbGVyIGxpbmplLlwiLFxuXHRcdGtlcm5lbERlbnNpdHlEZXNjOiBcIkRlbm5lIGZ1bmtzam9uZW4gYmVyZWduZXIgc3TDuHJyZWxzZXMgcGVyIGFyZWFsZW5oZXQgZnJhIHB1bmt0LSBlbGxlciBsaW5qZWdlb29iamVrdGVyLCB2ZWQgaGplbHAgYXYgZW4ga2plcm5lZnVua3Nqb24gZm9yIMOlIHRpbHBhc3NlcyBlbiBqZXZuIGtvbmlzayBvdmVyZmxhdGUgdGlsIGh2ZXJ0IHB1bmt0IGVsbGVyIGxpbmplLlwiLFxuXHRcdGtleU1ldGFkYXRhTmFtZTogXCJLZXkgTWV0YWRhdGFcIixcblx0XHRrZXlNZXRhZGF0YVNuaXA6IFwiT3ZlcnN0eXJlciBlbGxlciBsZWdnZXIgaW5uIG7DuGtrZWxtZXRhZGF0YSB0aWwgZXQgcmFzdGVyIGkgZW4gZnVua3Nqb25za2plZGUuXCIsXG5cdFx0a2V5TWV0YWRhdGFEZXNjOiBcIkRlbm5lIGZ1bmtzam9uZW4gbGFyIGRlZyBzZXR0ZSBpbm4gZWxsZXIgb3ZlcnN0eXJlIGV0IHJhc3RlcnMgbsO4a2tlbG1ldGFkYXRhLjxkaXY+PGJyLz5JbmZvcm1hc2pvbmVuIGkgdmlrdGlnZSBtZXRhZGF0YSBicnVrZXMgdGlsIMOlIGhqZWxwZSBwcm9ncmFtbWV0IG1lZCBub2UgYmVoYW5kbGluZyBvZyBvcHB0ZWduaW5nLCBpbmtsdWRlcnQgw6UgZ2kgbnl0dGlnZSBvcHBseXNuaW5nZXIgc29tIHNlbnNvcmVucyBuYXZuLCBiw6VuZGV0cyBuYXZuIGVsbGVyIHNreWRla2tldCBzb20gZXIga255dHRldCB0aWwgYmlsZGVuZS48L2Rpdj5cIixcblx0XHRzaG9ydGVzdFBhdGhOYW1lOiBcIkxlYXN0IENvc3QgUGF0aFwiLFxuXHRcdHNob3J0ZXN0UGF0aFNuaXA6IFwiVXRmw7hyZXIgZW4ga29zdG5hZC1hdnN0YW5kc2FuYWx5c2UgbWVkIGtpbGRlLSBvZyBkZXN0aW5hc2pvbiBzb20gaW5uZGF0YSwgc29tIGRlcmV0dGVyIGJydWtlcyB0aWwgw6UgZmlubmUgZGVuIG1pbnN0ZSBrb3N0bmFkc3J1dGVuIGZyYSBlbiBraWxkZSB0aWwgZW4gZGVzdGluYXNqb24uXCIsXG5cdFx0c2hvcnRlc3RQYXRoRGVzYzogXCJMZWFzdCBDb3N0IFBhdGgtZnVua3Nqb25lbiBiZXJlZ25lciBtaW5zdGUga29zdG5hZHNrcnV0ZW4gZnJhIGVuIGtpbGRlIHRpbCBlbiBkZXN0aW5hc2pvbi4gRGVuIG1pbnN0ZSBha2t1bXVsZXJ0ZSBrb3N0bmFkc2F2c3RhbmRlbiBiZXJlZ25lcyBmb3IgaHZlciBwaWtzZWwgb3ZlciBlbiBrb3N0bmFkc292ZXJmbGF0ZSwgdGlsIG7DpnJtZXN0ZSBraWxkZS4gRGVuIHByb2R1c2VyZXIgZXQgdXRkYXRhcmFzdGVyIHNvbSByZWdpc3RyZXJlciBtaW5zdGUga29zdG5hZHNydXRlbiBlbGxlciAtcnV0ZW5lIGZyYSB1dHZhbGd0ZSBzdGVkZXIgdGlsIG7DpnJtZXN0ZSBraWxkZXBpa3NsZXIgc29tIGVyIGRlZmluZXJ0IGlubmVuZm9yIGRlbiBha2t1bXVsZXJ0ZSBrb3N0bmFkc292ZXJmbGF0ZW4sIGkgYmV0eWRuaW5nZW4ga29zdG5hZHNhdnN0YW5kLjxkaXY+PGJyLz5IdmVyIHJ1dGUgbWVkIGxhdmVzdCBrb3N0bmFkIHRpbGRlbGVzIGVuIHZlcmRpIG7DpXIgZGVuIG9wcGRhZ2VzIGkgc2thbm5lcHJvc2Vzc2VuLiBTbHV0dHBpa3NlbGV0IGkga2lsZGVyYXN0ZXIgZm9yIGVuIGtvc3RuYWRzcnV0ZSBmw6VyIHZlcmRpIDEuIERlbiBmw7hyc3RlIHJ1dGVuIGbDpXIgZW4gdmVyZGkgcMOlIDMsIGRlbiBhbmRyZSA0LCBvZyBzw6UgdmlkZXJlLiBOw6VyIGZsZXJlIHJ1dGVyIHNsw6VzIHNhbW1lbiBvZyBmw7hsZ2VyIGRlbiBnamVudsOmcmVuZGUgYXZzdGFuZGVuIHRpbGJha2UgdGlsIGVuIGtpbGRlIHDDpSBzYW1tZSBydXRlLCBibGlyIHNlZ21lbnRldCBodm9yIGRlIHRvIGJhbmVuZSBnw6VyIHNhbW1lbiwgdGlsb3JkbmV0IGVuIHZlcmRpIHDDpSAyLiBEZW4gc2FtbWVuc2zDpXR0ZSBkZWxlbiBhdiBydXRlbiBrYW4gaWtrZSB0aWxvcmRuZXMgdmVyZGllbiBhdiBlbiBhdiBiYW5lbmUsIHNpZGVuIGRlbiBzYW1tZW5zbMOldHRlIGRlbGVuIHRpbGjDuHJlciBiZWdnZSBydXRlci48L2Rpdj5cIixcblx0XHRsZXNzVGhhbkVxdWFsTmFtZTogXCJNaW5kcmUgZW5uIGVsbGVyIGxpa1wiLFxuXHRcdGxlc3NUaGFuRXF1YWxTbmlwOiBcIlV0ZsO4cmVyIGVuIHJlbGFzam9uZWxsIG1pbmRyZSBlbm4gZWxsZXIgc3TDuHJyZSBlbm4tb3BlcmFzam9uIHDDpSB0byBpbm5kYXRhIHDDpSBlbiBjZWxsZSBmb3IgY2VsbGUtYmFzaXMuIFJldHVybmVyZXIgMSBmb3IgY2VsbGVyIGRlciBkZXQgZsO4cnN0ZSByYXN0ZXJldCBlciBtaW5kcmUgZW5uIGVsbGVyIGxpayBkZXQgYW5kcmUgcmFzdGVyZXQsIG9nIDAgaHZpcyBkZW4gaWtrZSBlciBkZXQuXCIsXG5cdFx0bGVzc1RoYW5FcXVhbERlc2M6IFwiRnVua3Nqb25lbiB1dGbDuHJlciBlbiByZWxhc2pvbmVsbCBtaW5kcmUgZW5uLSBlbGxlciBzdMO4cnJlIGVubi1vcGVyYXNqb24gcMOlIHRvIGlubmRhdGEgcMOlIGVuIHBpa3NlbCBldHRlciBwaWtzZWwtYmFzaXMuIERlbiByZXR1cm5lcmVyIGVuIHZlcmRpIHDDpSAxIGZvciBwaWtzbGVyIGRlciBkZXQgZsO4cnN0ZSByYXN0ZXJldCBlciBtaW5kcmUgZW5uIGVsbGVyIGxpayBkZXQgYW5kcmUgcmFzdGVyZXQsIG9nIGVuIHZlcmRpIHDDpSAwIGRlciBkZXQgaWtrZSBlciBtaW5kcmUgZW5uIGVsbGVyIGxpayBkZXQgYW5kcmUgcmFzdGVyZXQuXCIsXG5cdFx0bGVzc1RoYW5OYW1lOiBcIk1pbmRyZSBlbm5cIixcblx0XHRsZXNzVGhhblNuaXA6IFwiVXRmw7hyZXIgZW4gcmVsYXNqb25lbGwgbWluZHJlIGVubi1vcGVyYXNqb24gcMOlIHRvIGlubmRhdGEgcMOlIGVuIGNlbGxlIGZvciBjZWxsZS1iYXNpcy4gUmV0dXJuZXJlciAxIGZvciBjZWxsZXIgZGVyIGRldCBmw7hyc3RlIHJhc3RlcmV0IGVyIG1pbmRyZSBlbm4gZGV0IGFuZHJlIHJhc3RlcmV0LCBvZyAwIGh2aXMgZGV0IGlra2UgZXIgZGV0LlwiLFxuXHRcdGxlc3NUaGFuRGVzYzogXCJGdW5rc2pvbmVuIHV0ZsO4cmVyIGVuIHJlbGFzam9uZWxsIG1pbmRyZSBlbm4tb3BlcmFzam9uIHDDpSB0byBpbm5kYXRhIHDDpSBlbiBwaWtzZWwgZXR0ZXIgcGlrc2VsLWJhc2lzLiBEZW4gcmV0dXJuZXJlciBlbiB2ZXJkaSBww6UgMSBmb3IgcGlrc2xlciBkZXIgZGV0IGbDuHJzdGUgcmFzdGVyZXQgZXIgbWluZHJlIGVubiBkZXQgYW5kcmUgcmFzdGVyZXQsIG9nIGVuIHZlcmRpIHDDpSAwIGRlciBkZW4gaWtrZSBlciBtaW5kcmUgZW5uIGRldCBhbmRyZSByYXN0ZXJldC5cIixcblx0XHRsbk5hbWU6IFwiTG5cIixcblx0XHRsblNuaXA6IFwiQmVyZWduZXIgZGVuIG5hdHVybGlnZSBsb2dhcml0bWVuIChiYXNlIGUpIGZvciBjZWxsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGxuRGVzYzogXCJMbi1mdW5rc2pvbmVuIGJlcmVnbmVyIGRlbiBuYXR1cmxpZ2UgbG9nYXJpdG1lbiAoYmFzZSBlKSBhdiBodmVyIHBpa3NlbCBpIGVuIHJhc3Rlci5cIixcblx0XHRsb2cxME5hbWU6IFwiTG9nMTBcIixcblx0XHRsb2cxMFNuaXA6IFwiQmVyZWduZXIgYmFzZSAxMC1sb2dhcml0bWVuIGZvciBjZWxsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGxvZzEwRGVzYzogXCJMb2cxMC1mdW5rc2pvbmVuIGJlcmVnbmVyIGJhc2UgMTAtbG9nYXJpdG1lbiBmb3IgaHZlciBwaWtzZWwgaSBldCByYXN0ZXIuXCIsXG5cdFx0bG9nMk5hbWU6IFwiTG9nMlwiLFxuXHRcdGxvZzJTbmlwOiBcIkJlcmVnbmVyIGJhc2UgMi1sb2dhcml0bWVuIGZvciBjZWxsZW5lIGkgZXQgcmFzdGVyLlwiLFxuXHRcdGxvZzJEZXNjOiBcIkxvZzItZnVua3Nqb25lbiBiZXJlZ25lciBiYXNlIDItbG9nYXJpdG1lbiBmb3IgaHZlciBwaWtzZWwgaSBldCByYXN0ZXIuXCIsXG5cdFx0bG9va3VwTmFtZTogXCJMb29rdXBcIixcblx0XHRsb29rdXBTbmlwOiBcIk9wcHJldHRlciBldCBueXR0IHJhc3RlciB2ZWQgw6Ugc2zDpSBvcHAgdmVyZGllciBzb20gZmlubmVzIGkgZXQgYW5uZXQgZmVsdCBpIHRhYmVsbGVuIHRpbCBpbm5kYXRhcmFzdGVyZXQuXCIsXG5cdFx0bG9va3VwRGVzYzogXCJGdW5rc2pvbmVuIG9wcHJldHRlciBldCBueXR0IHJhc3RlciB2ZWQgw6Ugc2zDpSBvcHAgdmVyZGllciBzb20gZmlubmVzIGkgZXQgYW5uZXQgZmVsdCBpIHRhYmVsbGVuIHRpbCBpbm5kYXRhcmFzdGVyZXQuXCIsXG5cdFx0bWxDbGFzc2lmeU5hbWU6IFwiTUwgQ2xhc3NpZnlcIixcblx0XHRtbENsYXNzaWZ5U25pcDogXCJLbGFzc2lmaXNlcmVyIGJpbGRlciBtZWQgZW4gcGVyIHBpa3NlbC10aWxuw6ZybWluZy4gQmxhbmRlZGUgcGlrc2xlciB0aWxvcmRuZXMgZ2Vvb2JqZWt0ZXQgbWVkIGRlbiBow7h5ZXN0ZSBwcm9zZW50YW5kZWxlbiBpIGRlbiBwaWtzZWxlbi5cIixcblx0XHRtbENsYXNzaWZ5RGVzYzogXCJNTCBDbGFzc2lmeS1mdW5rc2pvbmVuIGxhciBkZWcgdXRmw7hyZSBlbiBvdmVydsOla2V0IGtsYXNzaWZpc2VyaW5nIHDDpSBldCByYXN0ZXItIGVsbGVyIG1vc2Fpa2tkYXRhc2V0dCwgdmVkIGhqZWxwIGF2IGtsYXNzaWZpc2VyaW5nc2FsZ29yaXRtZW4gZm9yIG1ha3NpbWFsIHNhbm5zeW5saWdoZXQuIERlbm5lIGZ1bmtzam9uZW4ga3JldmVyIGVuIGtsYXNzaWZpa2Fzam9uc3NpZ25hdHVyZmlsLlwiLFxuXHRcdG1hc2tOYW1lOiBcIk1hc2tlXCIsXG5cdFx0bWFza1NuaXA6IFwiQW5naXIgdmVyZGllciBzb20gZHUgaWtrZSB2aWwgdmlzZS5cIixcblx0XHRtYXNrRGVzYzogXCJEZW5uZSByYXN0ZXJmdW5rc2pvbmVuIGFuZ2lyIHZlcmRpZXIgc29tIGR1IGlra2UgdmlsIHZpc2UgaSByYXN0ZXJldCBkaXR0LiBWZWQgw6UgYnJ1a2UgTWFzay1mdW5rc2pvbmVuIHZpbCBkdSBzcGVzaWZpc2VyZSBlbiBlbGxlciBmbGVyZSBOb0RhdGEtdmVyZGllciBlbGxlciBlbiByZWtrZSBneWxkaWdlIHBpa3NlbHZlcmRpZXIuIFwiLFxuXHRcdG1pbnVzTmFtZTogXCJNaW51c1wiLFxuXHRcdG1pbnVzU25pcDogXCJTdWJ0cmFoZXJlciB2ZXJkaWVuIGF2IGRldCBhbmRyZSBpbm5kYXRhcmFzdGVyZXQgZnJhIHZlcmRpZW4gYXYgZGV0IGbDuHJzdGUgaW5uZGF0YXJhc3RlcmV0IHDDpSBlbiBjZWxsZSBmb3IgY2VsbGUtYmFzaXMuXCIsXG5cdFx0bWludXNEZXNjOiBcIk1pbnVzLWZ1bmtzam9uZW4gc3VidHJhaGVyZXIgdmVyZGllbiBhdiBkZXQgYW5kcmUgaW5uZGF0YXJhc3RlcmV0IGZyYSB2ZXJkaWVuIGF2IGRldCBmw7hyc3RlIGlubmRhdGFyYXN0ZXJldCBww6UgZW4gcGlrc2VsIGZvciBwaWtzZWwtYmFzaXMuXCIsXG5cdFx0bW9kTmFtZTogXCJNb2RcIixcblx0XHRtb2RTbmlwOiBcIkZpbm5lciByZXN0ZW4gKG1vZHVsbykgYXYgZGV0IGbDuHJzdGUgcmFzdGVyZXQgbsOlciBkZW4gZGVsZXMgYXYgZGV0IGFuZHJlIHJhc3RlcmV0IHDDpSBjZWxsZSBmb3IgY2VsbGUtYmFzaXMuXCIsXG5cdFx0bW9kRGVzYzogXCJNb2QtZnVua3Nqb25lbiBmaW5uZXIgcmVzdGVuIChtb2R1bG8pIGF2IGRldCBmw7hyc3RlIHJhc3RlcmV0IG7DpXIgZGVuIGRlbGVzIGF2IGRldCBhbmRyZSByYXN0ZXJldCBww6UgcGlrc2VsIGZvciBwaWtzZWwtYmFzaXMuIFJla2tlZsO4bGdlbiBhdiBkZSB0byBpbm5kYXRlbmUgZXIgdmlrdGlnIG9nIHDDpXZpcmtlciB1dGRhdGFyZXN1bHRhdGVuZS5cIixcblx0XHRtb3NhaWNSYXN0ZXJzTmFtZTogXCJNb3NhaWMgUmFzdGVyc1wiLFxuXHRcdG1vc2FpY1Jhc3RlcnNTbmlwOiBcIlNldHRlciBzYW1tZW4gZXQgc2V0dCBtZWQgcmFzdGVyZGF0YXNldHQgZm9yIMOlIGxhZ2UgZXR0IGRhdGFzZXR0LlwiLFxuXHRcdG1vc2FpY1Jhc3RlcnNEZXNjOiBcIk1vc2FpYyBSYXN0ZXJzLWZ1bmtzam9uZW4gbGFnZXIgZXQgbW9zYWlra2JpbGRlIHV0IGZyYSBmbGVyZSBiaWxkZXIuIE7DpXIgZGV0IGVyIG92ZXJsYXBwaW5nIG1lbGxvbSBiaWxkZW5lLCBlciBkZXQgZmxlcmUgbWV0b2RlciBkdSBrYW4gdmVsZ2UgYmxhbnQgZm9yIMOlIGJlc3RlbW1lIGh2aWxrZSBiaWxkZXIgc29tIHZpc2VzLlwiLFxuXHRcdG5kdmlDb2xvcml6ZWROYW1lOiBcIk5EVkkgQ29sb3JpemVkXCIsXG5cdFx0bmR2aUNvbG9yaXplZFNuaXA6IFwiT3BwcmV0dGVyIGV0IGRhdGFzZXR0IG1lZCBmbGVyZSBiw6VuZCBzb20gcmVwcmVzZW50ZXJlciB2ZWdldGFzam9uc2hlbHNlLCBiYXNlcnQgcMOlIGZvcnNramVsbGVuIG1lbGxvbSBkZSByw7hkZSBvZyBuw6ZybGlnZ2VuZGUgaW5mcmFyw7hkZSBiw6VuZGVuZS5cIixcblx0XHRuZHZpQ29sb3JpemVkRGVzYzogXCJORFZJIENvbG9yaXplZC1mdW5rc2pvbmVuIGJydWtlciBORFZJLWZ1bmtzam9uZW4gcMOlIGlubmRhdGFiaWxkZXQsIG9nIGJydWtlciBkZXJldHRlciBldCBmYXJnZWthcnQgZWxsZXIgZW4gZmFyZ2VwYWxldHQgdGlsIMOlIHZpc2UgcmVzdWx0YXRldC5cIixcblx0XHRuZHZpTmFtZTogXCJORFZJXCIsXG5cdFx0bmR2aVNuaXA6IFwiQmVyZWduZXIgTm9ybWFsaXplZCBEaWZmZXJlbmNlIFZlZ2V0YXRpb24gSW5kZXggKE5EVkkpLlwiLFxuXHRcdG5kdmlEZXNjOiBcIk5EVkktZnVua3Nqb25lbiBvcHByZXR0ZXIgZXQgZGF0YXNldHQgbWVkIGV0dCBiw6VuZCBzb20gcmVwcmVzZW50ZXJlciB2ZWdldGFzam9uc2hlbHNlLCBiYXNlcnQgcMOlIGZvcnNramVsbGVuIG1lbGxvbSBkZSByw7hkZSBvZyBuw6ZybGlnZ2VuZGUgaW5mcmFyw7hkZSBiw6VuZGVuZS48ZGl2Pjxici8+TkRWSSBlciBlbiBzdGFuZGFyZGlzZXJ0IGluZGVrcyBzb20gZ2rDuHIgYXQgZHUga2FuIGdlbmVyZXJlIGV0IGJpbGRlIHNvbSB2aXNlciBncsO4bm5oZXQsIG9nc8OlIGtqZW50IHNvbSByZWxhdGl2IGJpb21hc3NlLiBEZW5uZSBpbmRla3NlbiBkcmFyIG55dHRlIGF2IGtvbnRyYXN0ZW4gZnJhIGthcmFrdGVyaXN0aWtrZW4gYXYgdG8gYsOlbmQgZnJhIGV0IG11bHRpc3Bla3RyYWx0IHJhc3RlcmRhdGFzZXR0LiBLbG9yb2Z5bGxwaWdtZW50YWJzb3Jwc2pvbmVuZSBpIGRldCByw7hkZSBiw6VuZGV0IG9nIGRlbiBow7h5ZSByZWZsZWtzam9uZW4gYXYgcGxhbnRlbWF0ZXJpYWxlIGkgZGV0IG7DpnIgaW5mcmFyw7hkZSAoTklSKSBiw6VuZGV0LiBFa3N0cmVtdCBsYXZlIGVsbGVyIG5lZ2F0aXZlIE5EVkktdmVyZGllciByZXByZXNlbnRlcmVyIG9tcsOlZGVyIHV0ZW4gdmVnZXRhc2pvbiBpIGRldCBoZWxlIHRhdHQsIGZvciBla3NlbXBlbCBza3llciwgdmFubiBlbGxlciBzbsO4LiBTdsOmcnQgbGF2ZSB2ZXJkaWVyIHJlcHJlc2VudGVyZXIgb21yw6VkZXIgbWVkIGxpdGVuIGVsbGVyIGluZ2VuIHZlZ2V0YXNqb24sIHNvbSBiZXRvbmcsIHN0ZWluIGVsbGVyIHJlbiBqb3JkLiBNb2RlcmF0ZSB2ZXJkaWVyIHJlcHJlc2VudGVyZXIgb21yw6VkZXIgbWVkIGJ1c2tlciBvZyBncmVzc2xldHRlci4gSMO4eWUgdmVyZGllciByZXByZXNlbnRlcmVyIHNrb2dzb21yw6VkZXIgb2cgZnJvZGlnIHZlZ2V0YXNqb24uPC9kaXY+XCIsXG5cdFx0bmVnYXRlTmFtZTogXCJJbnZlcnTDqXJcIixcblx0XHRuZWdhdGVTbmlwOiBcIkVuZHJlciB0ZWduZXQgKGdhbmdlciBtZWQgLTEpIGF2IHBpa3NlbHZlcmRpZW5lIHRpbCBpbm5kYXRhcmFzdGVyZXQgcMOlIGVuIGNlbGxlIGZvciBjZWxsZS1iYXNpcy5cIixcblx0XHRuZWdhdGVEZXNjOiBcIk5lZ2F0ZS1mdW5rc2pvbmVuIGVuZHJlciB0ZWduZXQgKGdhbmdlciBtZWQgLTEpIGF2IHBpa3NlbHZlcmRpZW5lIHRpbCBpbm5kYXRhcmFzdGVyZXQgcMOlIGVuIHBpa3NlbCBcIixcblx0XHRuaWJibGVOYW1lOiBcIk5pYmJsZVwiLFxuXHRcdG5pYmJsZVNuaXA6IFwiRXJzdGF0dGVyIGNlbGxlbmUgaSBldCByYXN0ZXIgc29tIHN2YXJlciB0aWwgZW4gbWFza2UgbWVkIHZlcmRpZW5lIHRpbCBuw6ZybWVzdGUgbmFib2VyLlwiLFxuXHRcdG5pYmJsZURlc2M6IFwiTmliYmxlLWdsb2JhbGZ1bmtzam9uZW4gbGFyIHV0dmFsZ3RlIG9tcsOlZGVyIHDDpSBldCByYXN0ZXQgYmxpIHRpbGRlbHQgdmVyZGllbiBhdiBuw6ZybWVzdGUgbmFiby4gRGV0dGUgZXIgbnl0dGlnIGZvciByZWRpZ2VyaW5nIGF2IG9tcsOlZGVyIGkgZXQgcmFzdGVyIGRlciBkYXRhZW5lIGthbiB2w6ZyZSBmZWlsYWt0aWdlLlwiLFxuXHRcdG5vdEVxdWFsTmFtZTogXCJJa2tlIGxpa1wiLFxuXHRcdG5vdEVxdWFsU25pcDogXCJVdGbDuHJlciBlbiByZWxhc2pvbmVsbCBpa2tlIGxpay1vcGVyYXNqb24gcMOlIHRvIGlubmRhdGEgcMOlIGVuIGNlbGxlIGZvciBjZWxsZS1iYXNpcy4gUmV0dXJuZXJlciAxIGZvciBjZWxsZXIgZGVyIGRldCBmw7hyc3RlIHJhc3RlcmV0IGlra2UgZXIgbGlrIGRldCBhbmRyZSByYXN0ZXJldCwgb2cgMCBodmlzIGRlbiBlciBsaWsuXCIsXG5cdFx0bm90RXF1YWxEZXNjOiBcIkZ1bmtzam9uZW4gdXRmw7hyZXIgZW4gcmVsYXNqb25lbGwgaWtrZSBsaWstb3BlcmFzam9uIHDDpSB0byBpbm5kYXRhIHDDpSBlbiBwaWtzZWwgZXR0ZXIgcGlrc2VsLWJhc2lzLiBEZW4gcmV0dXJuZXJlciBlbiB2ZXJkaSBww6UgMSBmb3IgcGlrc2xlciBkZXIgZGV0IGbDuHJzdGUgcmFzdGVyZXQgaWtrZSBlciBsaWsgZGV0IGFuZHJlIHJhc3RlcmV0LCBvZyBlbiB2ZXJkaSBww6UgMCBkZXIgZGVuIGVyIGxpayBkZXQgYW5kcmUgcmFzdGVyZXQuXCIsXG5cdFx0cGFuc2hhcnBlbmluZ05hbWU6IFwiUGFuc2hhcnBlblwiLFxuXHRcdHBhbnNoYXJwZW5pbmdTbmlwOiBcIkZvcmJlZHJlciBrdW5zdGlnIGRlbiBnZW9ncmFmaXNrZSBvcHBsw7hzbmluZ2VuIHRpbCBldCBiaWxkZSBtZWQgZmxlcmUgYsOlbmQgdmVkIMOlIGbDuHllIGRldCBzYW1tZW4gbWVkIGV0IHBhbmtyb21hdGlzayBiaWxkZSBtZWQgaMO4eWVyZSBvcHBsw7hzbmluZy5cIixcblx0XHRwYW5zaGFycGVuaW5nRGVzYzogXCJQYW5zaGFycGVuaW5nLWZ1bmtzam9uZW4gYnJ1a2VyIGV0IHBhbmtyb21hdGlzayBiaWxkZSBlbGxlciByYXN0ZXJiw6VuZCBtZWQgaMO4eWVyZSBvcHBsw7hzbmluZyBmb3Igw6Ugc21lbHRlIHNhbW1lbiBtZWQgZXQgcmFzdGVyZGF0YXNldHQgbWVkIGxhdmVyZSBvcHBsw7hzbmluZywgb2cgZmxlcmLDpW5kcmFzdGVyLWRhdGFzZXR0IGZvciDDpSDDuGtlIGRlbiBnZW9ncmFmaXNrZSBvcHBsw7hzbmluZ2VuIHRpbCBmbGVyYsOlbmRiaWxkZXQuPGRpdj48YnIvPkZvcm3DpWxldCBtZWQgUGFuc2hhcnBlbiBlciDDpSBza2FwZSBldCBiaWxkZSBtZWQgaMO4eWVyZSBrdmFsaXRldC4gU2lkZW4gdGVrbmlra2VuZSBmb3JhbmRyZXIgcmFkaW9tZXRyaWVuIG9nIGRlIHNwZWt0cmFsZSBlZ2Vuc2thcGVybmUgdGlsIGJpbGRldCBtZWQgZmxlcmUgYsOlbmQsIG3DpSBwYW5rcm9tYXRpc2sga2plcnBlZGUgYmlsZGVyIGJydWtlcyBtZWQgZm9yc2lrdGlnaGV0IHRpbCBmamVybmFuYWx5dGlza2UgZm9ybcOlbC48L2Rpdj5cIixcblx0XHRwYXRoQWxsb2NhdGlvbk5hbWU6IFwiUGF0aCBEaXN0YW5jZSBBbGxvY2F0aW9uXCIsXG5cdFx0cGF0aEFsbG9jYXRpb25TbmlwOiBcIkJlcmVnbmVyIG7DpnJtZXN0ZSBraWxkZSBmb3IgaHZlciBjZWxsZSBiYXNlcnQgcMOlIG1pbnN0IGFra3VtdWxlcnRlIGtvc3RuYWQgb3ZlciBlbiBrb3N0bmFkc292ZXJmbGF0ZSwgbWVucyBkZXQgdGFzIGhlbnN5biB0aWwgb3ZlcmZsYXRlYXZzdGFuZCBvZyBob3Jpc29udGFsZSBvZyB2ZXJ0aWthbGUga29zdG5hZHNmYWt0b3Jlci5cIixcblx0XHRwYXRoQWxsb2NhdGlvbkRlc2M6IFwiUGF0aCBEaXN0YW5jZSBBbGxvY2F0aW9uLWZ1bmtzam9uZW4gYmVyZWduZXIgbsOmcm1lc3RlIGtpbGRlIGZvciBodmVyIGNlbGxlLCBiYXNlcnQgcMOlIG1pbnN0IGFra3VtdWxlcnRlIGtvc3RuYWQgb3ZlciBlbiBrb3N0bmFkc292ZXJmbGF0ZSwgbWVucyBkZXQgdGFzIGhlbnN5biB0aWwgb3ZlcmZsYXRlYXZzdGFuZCBvZyBob3Jpc29udGFsZSBvZyB2ZXJ0aWthbGUga29zdG5hZHNmYWt0b3Jlci5cIixcblx0XHRwYXRoQmFja0xpbmtOYW1lOiBcIlBhdGggRGlzdGFuY2UgQmFjayBMaW5rXCIsXG5cdFx0cGF0aEJhY2tMaW5rU25pcDogXCJEZWZpbmVyZXIgbmFib2VuIHNvbSBlciBkZW4gbmVzdGUgY2VsbGVuIHDDpSBkZW4gYWtrdW11bGVydGUgbWluc3RlIGtvc3RuYWRzcnV0ZW4gdGlsIGRlbiBsYXZlc3RlIGtvc3RuYWRza2lsZGVuLCBtZW5zIGRldCB0YXMgaGVuc3luIHRpbCBvdmVyZmxhdGVhdnN0YW5kIGkgdGlsbGVnZyB0aWwgaG9yaXNvbnRhbGUgb2cgdmVyZGlrYWxlIGtvc3RuYWRzZmFrdG9yZXIuXCIsXG5cdFx0cGF0aEJhY2tMaW5rRGVzYzogXCJQYXRoIERpc3RhbmNlIEJhY2sgTGluay1mdW5rc2pvbmVuIGlkZW50aWZpc2VyZXIgcmV0bmluZ2VuIHRpbCBuYWJvZW4gc29tIGVyIGRlbiBuZXN0ZSBjZWxsZW4gcMOlIGRlbiBha2t1bXVsZXJ0ZSBtaW5zdGUga29zdG5hZHNydXRlbiB0aWwgbsOmcm1lc3RlIGtpbGRlLCBtZW5zIGRldCB0YXMgaGVuc3luIHRpbCBvdmVyZmxhdGVhdnN0YW5kIG9nIGhvcmlzb250YWxlIG9nIHZlcnRpa2FsZSBrb3N0bmFkc2Zha3RvcmVyLlwiLFxuXHRcdHBhdGhEaXN0YW5jZU5hbWU6IFwiUGF0aCBEaXN0YW5jZVwiLFxuXHRcdHBhdGhEaXN0YW5jZVNuaXA6IFwiQmVyZWduZXIgZm9yIGh2ZXIgY2VsbGUgZGVuIG1pbnN0IGFra3VtdWxlcnRlIGtvc3RuYWRlbiBvdmVyIGVuIGtvc3RuYWRzb3ZlcmZsYXRlLCBtZW5zIGRldCB0YXMgaGVuc3luIHRpbCBvdmVyZmxhdGVhdnN0YW5kIG9nIGhvcmlzb250YWxlIG9nIHZlcnRpa2FsZSBrb3N0bmFkc2Zha3RvcmVyLlwiLFxuXHRcdHBhdGhEaXN0YW5jZURlc2M6IFwiRnVua3Nqb25lbiBQYXRoIERpc3RhbmNlIGJlcmVnbmVyIG7DpnJtZXN0ZSBraWxkZSBmb3IgaHZlciBjZWxsZSBiYXNlcnQgcMOlIG1pbnN0IGFra3VtdWxlcnQga29zdG5hZCBvdmVyIGVuIGtvc3RuYWRzb3ZlcmZsYXRlLCBtZW5zIGRldCB0YXMgaGVuc3luIHRpbCBvdmVyZmxhdGVhdnN0YW5kIG9nIGhvcmlzb250YWxlIG9nIHZlcnRpa2FsZSBrb3N0bmFkc2Zha3RvcmVyLlwiLFxuXHRcdHBsdXNOYW1lOiBcIlBsdXNcIixcblx0XHRwbHVzU25pcDogXCJBZGRlcmVyIChzdW1tZXJlcikgdmVyZGllbmUgdGlsIHRvIHJhc3RlciBww6UgcGlrc2VsIGZvciBwaWtzZWwtYmFzaXMuXCIsXG5cdFx0cGx1c0Rlc2M6IFwiUGx1cy1mdW5rc2pvbmVuIGFkZGVyZXIgKHN1bW1lcmVyKSB2ZXJkaWVuZSB0aWwgdG8gcmFzdGVyIHDDpSBwaWtzZWwgZm9yIHBpa3NlbC1iYXNpcy5cIixcblx0XHRwb3dlck5hbWU6IFwiUG90ZW5zXCIsXG5cdFx0cG93ZXJTbmlwOiBcIsOYa2VyIGNlbGxldmVyZGllbmUgaSBldCByYXN0ZXIgdGlsIHBvdGVuc2VuIGF2IHZlcmRpZW5lIGkgZXQgYW5uZXQgcmFzdGVyLlwiLFxuXHRcdHBvd2VyRGVzYzogXCJQb3dlci1mdW5rc2pvbmVuIMO4a2VyIHBpa3NlbHZlcmRpZW5lIGkgZXQgcmFzdGVyIHRpbCBwb3RlbnNlbiBhdiB2ZXJkaWVuZSBpIGV0IGFubmV0IHJhc3Rlci5cIixcblx0XHRyYWRhckNhbGlicmF0aW9uTmFtZTogXCJSYWRhciBDYWxpYnJhdGlvblwiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25TbmlwOiBcIktvbnZlcnRlcmVyIFJBREFSU0FULTIgYmFja3NjYXR0ZXIuXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvbkRlc2M6IFwiRGVubmUgZnVua3Nqb25lbiBrYW4gYnJ1a2VzIHRpbCDDpSBrYWxpYnJlcmUgUkFEQVJTQVQtMi1iaWxkZXIgaSBldCBtb3NhaWtrZGF0YXNldHQgZWxsZXIgc29tIGV0IHJhc3RlcnByb2R1a3QuIEthbGlicmVyaW5nIHV0ZsO4cmVzIHDDpSByYWRhcmJpbGRlciBzbGlrIGF0IHBpa3NlbHZlcmRpZW5lIGVyIGVuIGVrdGUgcmVwcmVzZW50YXNqb24gYXYgcmFkYXJiYWNrc2NhdHRlcmVuLlwiLFxuXHRcdHJhc3RlckluZm9OYW1lOiBcIlJhc3RlckluZm9cIixcblx0XHRyYXN0ZXJJbmZvU25pcDogXCJFbmRyZXIgZWdlbnNrYXBlbmUgdGlsIHJhc3RlcmV0LCBmb3IgZWtzZW1wZWwgYml0ZHliZGUsIE5vRGF0YS12ZXJkaSwgY2VsbGVzdMO4cnJlbHNlIG9nIHPDpSB2aWRlcmUuXCIsXG5cdFx0cmFzdGVySW5mb0Rlc2M6IFwiUmFzdGVyIEluZm8gw6VwbmVyIGVuIGRpYWxvZyBtZWQgcmFzdGVyZGF0YXNldHRlZ2Vuc2thcGVyLCBmb3IgZWtzZW1wZWwgYW50YWxsIGtvbG9ubmVyIG9nIHJhZGVyLCBhbnRhbGwgYsOlbmQsIHBpa3NlbHR5cGUsIHV0c3RyZWtuaW5nIG9nIHJvbWxpZyByZWZlcmFuc2UuIER1IGthbiByZWRpZ2VyZSBkaXNzZSBlZ2Vuc2thcGVuZSB2ZWQgw6UgdmVsZ2UgZXQgcmFzdGVyZGF0YXNldHQgc29tIHNrYWwgYnJ1a2VzIHNvbSBtYWwuIFwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNOYW1lOiBcIlJhc3Rlcml6ZSBBdHRyaWJ1dGVzXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc1NuaXA6IFwiQmVyaWtlciBldCByYXN0ZXIgdmVkIMOlIGxlZ2dlIHRpbCBiw6VuZCBzb20gZXIgdXRsZWRldCBmcmEgdmVyZGllciBww6Ugc3Blc2lmaXNlcnRlIGF0dHJpYnV0dGVyLCBmcmEgZW4gZWtzdGVybiB0YWJlbGwgZWxsZXIgZW4gZ2Vvb2JqZWt0dGplbmVzdGUuXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc0Rlc2M6IFwiRnVua3Nqb25lbiBSYXN0ZXJpemUgQXR0cmlidXRlIGJlcmlrZXIgZXQgcmFzdGVyIHZlZCDDpSBsZWdnZSB0aWwgYsOlbmQgc29tIGVyIHV0bGVkZXQgZnJhIHZlcmRpZXIgcMOlIHNwZXNpZmlzZXJ0ZSBhdHRyaWJ1dHRlciwgZnJhIGVuIGVrc3Rlcm4gdGFiZWxsIGVsbGVyIGVuIGdlb29iamVrdHRqZW5lc3RlLiBEdSBrYW4gZXZlbnR1ZWx0IGFuZ2kgZXQgc29uZXJhc3RlciBvZyB0aWxow7hyZW5kZSBzb25lLUlELWF0dHJpYnV0dCBmb3Igw6UgYWt0aXZlcmUgcmVnaW9uYmFzZXJ0IG9wcHNsYWcuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzTmFtZTogXCJSYXN0ZXJpemUgRmVhdHVyZXNcIixcblx0XHRyYXN0ZXJpemVGZWF0dXJlQ2xhc3NTbmlwOiBcIktvbnZlcnRlcmVyIGdlb29iamVrdGVyIHRpbCByYXN0ZXIuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzRGVzYzogXCJEZW5uZSBmdW5rc2pvbmVuIGtvbnZlcnRlcmVyIHBvbHlnb24tLCBwb2x5bGluamUtIG9nIHB1bmt0Z2Vvb2JqZWt0a2xhc3NlZGF0YSB0aWwgZXQgcmFzdGVybGFnLjxkaXY+PGJyLz5HZW9vYmpla3RlciB0aWxvcmRuZXMgcGlrc2VsdmVyZGllciBww6UgYmFrZ3J1bm4gYXYgZ2Vvb2JqZWt0ZW5lcyBPQkpFQ1RJRCAoc3RhbmRhcmQpLiBQaWtzZWx2ZXJkaWVuZSBrYW4gZXZlbnR1ZWx0IGJhc2VyZXMgcMOlIGV0IGJydWtlcmRlZmluZXJ0IHZlcmRpZmVsdCBpIGlubmRhdGFnZW9vYmpla3RldHMgYXR0cmlidXR0YWJlbGwuPC9kaXY+XCIsXG5cdFx0cmVjYXN0TmFtZTogXCJSZWNhc3RcIixcblx0XHRyZWNhc3RTbmlwOiBcIkVuZHJlciBwYXJhbWV0cmVuZSB0aWwgZW4gZnVua3Nqb25za2plZGUgaSBldCBtb3NhaWtrZGF0YXNldHQgZWxsZXIgZW4gYmlsZGV0amVuZXN0ZS4gRGV0dGUgYnJ1a2VzIG9mdGUgbWVkIExBUy1kYXRhc2V0dCBmb3Igw6UgdW5uZ8OlIMOlIG3DpXR0ZSBvcHByZXR0ZSBldCBlZ2V0IG1vc2Fpa2tkYXRhc2V0dCBmb3IgdWxpa2UgcmVwcmVzZW50YXNqb25lciBhdiB0ZXJyZW5nLlwiLFxuXHRcdHJlY2FzdERlc2M6IFwiRnVua3Nqb25lbiBSZWNhc3QgYnJ1a2VzIHRpbCBkeW5hbWlzayBtb2RpZmlzZXJpbmcgYXYgZnVua3Nqb25zcGFyYW1ldGVyZW4gc29tIGJydWtlcyBpIGV0IG1vc2Fpa2tkYXRhc2V0dCBlbGxlciBiaWxkZXRqZW5lc3RlIHV0ZW4gZnlzaXNrIHZlZHZhcmVuZGUgZW5kcmluZy5cIixcblx0XHRyZWdpb25Hcm91cE5hbWU6IFwiUmVnaW9uIEdyb3VwXCIsXG5cdFx0cmVnaW9uR3JvdXBTbmlwOiBcIkZvciBodmVyIGNlbGxlIGkgdXRkYXRhZW5lIGJsaXIgaWRlbnRpdGV0ZW4gdGlsIGRlbiB0aWxrb2JsZWRlIHJlZ2lvbmVuIHNvbSBkZW4gY2VsbGVuIHRpbGjDuHJlciwgcmVnaXN0cmVydC4gRXQgdW5pa3QgbnVtbWVyIHRpbGRlbGVzIGh2ZXIgcmVnaW9uLlwiLFxuXHRcdHJlZ2lvbkdyb3VwRGVzYzogXCJHbG9iYWxmdW5rc2pvbmVuIFJlZ2lvbiBHcm91cCByZWdpc3RyZXJlciBpZGVudGl0ZXRlbiB0aWwgcmVnaW9uZW4gc29tIGh2ZXIgY2VsbGUgaSB1dGRhdGFlbmUgdGlsaMO4cmVyLiBFdCB1bmlrdCBudW1tZXIgdGlsZGVsZXMgaHZlciByZWdpb24uPGRpdj48YnIvPkRlbiBmw7hyc3RlIHJlZ2lvbmVuIHNvbSBza2FubmVzLCBmw6VyIHZlcmRpZW4gw6luLCBkZW4gYW5kcmUgdG8gb2cgc8OlIHZpZGVyZSB0aWwgYWxsZSByZWdpb25lciBlciB0aWxkZWx0IGVuIHZlcmRpLiBTa2FubmluZ2VuIGJldmVnZXIgc2VnIGZyYSB2ZW5zdHJlIHRpbCBow7h5cmUsIHRvcHAgdGlsIGJ1bm4uIFZlcmRpZW5lIHNvbSBlciB0aWxvcmRuZXQgdXRkYXRhc29uZW5lLCBlciBiYXNlcnQgcMOlIG7DpXIgZGUgb3BwZGFnZXMgaSBza2FubmVwcm9zZXNzZW4uPC9kaXY+XCIsXG5cdFx0cmVnaW9uR3Jvd05hbWU6IFwiUmVnaW9uIEdyb3dcIixcblx0XHRyZWdpb25Hcm93U25pcDogXCJWb2tzZXIgcmVnaW9uZXIgZnJhIHV0Z2FuZ3NwdW5rdGVyLlwiLFxuXHRcdHJlZ2lvbkdyb3dEZXNjOiBcIlJlZ2lvbiBHcm93LWZ1bmtzam9uZW4gZ3J1cHBlcmVyIG5hYm9waWtzbGVyIGkgZ3J1cHBlciBhdmhlbmdpZyBhdiBkZW4gYW5naXR0ZSByYWRpdXNlbiBmcmEgdXRnYW5nc3B1bmt0ZXQuIFBpa3NlbGdydXBwZW4gZWxsZXIgb2JqZWt0ZXQgdGlsb3JkbmVzIGVuIHNwZXNpZmlzZXJ0IGZ5bGxpbmdzdmVyZGkuXCIsXG5cdFx0cmVtYXBOYW1lOiBcIlJlbWFwXCIsXG5cdFx0cmVtYXBTbmlwOiBcIkVuZHJlciBwaWtzZWx2ZXJkaWVyIHZlZCDDpSB0aWxkZWxlIG55ZSB2ZXJkaWVyIHRpbCBpbnRlcnZhbGxlciBhdiBwaWtzZWx2ZXJkaWVyIGVsbGVyIHZlZCBoamVscCBhdiBlbiBla3N0ZXJuIHRhYmVsbC5cIixcblx0XHRyZW1hcERlc2M6IFwiUmVtYXAtZnVua3Nqb25lbiBsYXIgZGVnIGVuZHJlIGVsbGVyIG9ta2xhc3NpZmlzZXJlIHBpa3NlbHZlcmRpZW5lIHRpbCByYXN0ZXJkYXRhZW5lLiBEZXR0ZSBrYW4gZ2rDuHJlcyBlbnRlbiB2ZWQgw6Ugc3Blc2lmaXNlcmUgZW4gcmVra2UgbWVkIHBpa3NlbHZlcmRpZXIgZm9yIMOlIGthcnRsZWdnZSBtb3QgZW4gdXRkYXRhcGlrc2VsdmVyZGksIGVsbGVyIGJydWtlIGVuIHRhYmVsbCBmb3Igw6Uga2FydGxlZ2dlIHBpa3NlbHZlcmRpZW5lIHRpbCB1dGRhdGFlbmVzIHBpa3NlbHZlcmRpLlwiLFxuXHRcdHJlcHJvamVjdE5hbWU6IFwiUmVwcm9qZWN0XCIsXG5cdFx0cmVwcm9qZWN0U25pcDogXCJFbmRyZXIgcHJvamVrc2pvbmVuIGF2IGV0IHJhc3RlcmRhdGFzZXR0LCBtb3NhaWtrZGF0YXNldHQgZWxsZXIgcmFzdGVyZWxlbWVudCBpIGV0IG1vc2Fpa2tkYXRhc2V0dC4gRGV0IGthbiBvZ3PDpSByZXNhbXBsZSBkYXRhZW5lIHRpbCBlbiBueSBjZWxsZXN0w7hycmVsc2Ugb2cgZGVmaW5lcmUgZXQgb3JpZ28uXCIsXG5cdFx0cmVwcm9qZWN0RGVzYzogXCJSZXByb2plY3QtZnVua3Nqb25lbiBlbmRyZXIgcHJvamVrc2pvbmVuIGF2IGV0IHJhc3RlcmRhdGFzZXR0LCBtb3NhaWtrZGF0YXNldHQgZWxsZXIgcmFzdGVyZWxlbWVudCBpIGV0IG1vc2Fpa2tkYXRhc2V0dC4gRGV0IGthbiBvZ3PDpSByZXNhbXBsZSBkYXRhZW5lIHRpbCBlbiBueSBjZWxsZXN0w7hycmVsc2Ugb2cgZGVmaW5lcmUgZXQgb3JpZ28uPGRpdj48YnIvPlJlcHJvamVjdC1mdW5rc2pvbmVuIGthbiBicnVrZXMgbsOlciBkdSBsYWdlciBlbiBodXJ0aWdidWZmZXIgZnJhIGV0IHJhc3Rlci0gZWxsZXIgbW9zYWlra2RhdGFzZXR0IHNvbSBpa2tlIGhhciBkZW4gbsO4ZHZlbmRpZ2UgcHJvamVrc2pvbmVuLiBOw6VyIGR1IGYuZWtzLiBvcHByZXR0ZXIgZW4gYnVmcmV0IGJpbGRldGplbmVzdGUgc29tIGthbiBpbnRlZ3JlcmVzIGF2IHByb2dyYW1tZXIgbWVkIGFuZHJlIGJ1ZnJlZGUgdGplbmVzdGVyLCBlciBkZXQgdmlrdGlnIGF0IGFsbGUgaGFyIHNhbW1lIHByb2pla3Nqb24uIERldHRlIGVyIG9mdGUgZW4gV2ViIE1lcmNhdG9yLXByb2pla3Nqb24uIFNpZGVuIG1vc2Fpa2tkYXRhc2V0dGV0IGlra2Uga2FuIHJlcHJvamlzZXJlcywga2FuIGR1IGdqw7hyZSBlbiBhdiB0byB0aW5n4oCUIGVudGVuIG9wcHJldHRlIGV0IHJlZmVyZXJ0IG1vc2Fpa2tkYXRhc2V0dCBmcmEgbW9zYWlra2RhdGFzZXR0ZXQgaSBwcm9qZWtzam9uZW4gc29tIHRyZW5ncywgZWxsZXIgbGVnZyB0aWwgUmVwcm9qZWN0LWZ1bmtzam9uZW4gaSBtb3NhaWtrZGF0YXNldHRldHMgZnVua3Nqb25za2plZGUuIEV0IGFubmV0IGVrc2VtcGVsIGJydWtlciBkZW5uZSBmdW5rc2pvbmVuIHDDpSByYXN0ZXJsZW1lbnRldCBpIGV0IG1vc2Fpa2tkYXRhc2V0dC4gTsOlciBkdSBicnVrZXIgQ2FjaGVkIFJhc3Rlci1mdW5rc2pvbmVuLCB2aWwgZHUga2Fuc2tqZSBzZXR0ZSBpbm4gUmVwcm9qZWN0LWZ1bmtzam9uZW4sIHNsaWsgYXQgYnVmZmVyZW4gYmxpciBvcHByZXR0ZXQgaSBkZW4gbnllIHByb2pla3Nqb25lbi4gUmFzdGVyZWxlbWVudGVyIGkgZXQgbW9zYWlra2RhdGFzZXR0IGthbiBidWZyZXMgbsOlciBiZWhhbmRsaW5nZW4gZXIgaW50ZW5zLCBvZyBkdSBwcsO4dmVyIMOlIHB1Ymxpc2VyZSBlbiBiaWxkZXRqZW5lc3RlIHNvbSBlciByYXNrLCB1dGVuIMOlIGJ1ZnJlIGhlbGUgYmlsZGV0amVuZXN0ZW4uPC9kaXY+XCIsXG5cdFx0cmVzYW1wbGVOYW1lOiBcIlJlc2FtcGxlXCIsXG5cdFx0cmVzYW1wbGVTbmlwOiBcIkVuZHJlciBjZWxsZXN0w7hycmVsc2VuIHDDpSBldCByYXN0ZXIuXCIsXG5cdFx0cmVzYW1wbGVEZXNjOiBcIlJlc2FtcGxlLWZ1bmtzam9uZW4gZW5kcmVyIGNlbGxlc3TDuHJyZWxzZW4sIHJlc2FtcGxpbmctdHlwZW4gZWxsZXIgYmVnZ2UgZGVsZXIuPGRpdj48YnIvPlJlc2FtcGxlLWZ1bmtzam9uZW4gYsO4ciBiYXJlIGJydWtlcyBtZWQgc3Blc2lmaWtrZSBkYXRhYmVoYW5kbGluZ3NrcmF2LCBmb3IgZWtzZW1wZWwgbsOlciBkdSBiZXJlZ25lciB2aW5kLSBlbGxlciBzdHLDuG1zdHlya2VuIG9nIC1yZXRuaW5nZW4gc29tIGtyZXZlciByZXNhbXBsaW5nIGZyYSBraWxkZW9wcGzDuHNuaW5nZW4uPC9kaXY+XCIsXG5cdFx0cm91bmREb3duTmFtZTogXCJBdnJ1bmQgbmVkb3ZlclwiLFxuXHRcdHJvdW5kRG93blNuaXA6IFwiUmV0dXJuZXJlciBuZXN0ZSBsYXZlcmUgaGVsdGFsbCwgcmVwcmVzZW50ZXJ0IHNvbSBldCBmbHl0cHVua3QsIGZvciBodmVyIGNlbGxlIGkgZXQgcmFzdGVyLlwiLFxuXHRcdHJvdW5kRG93bkRlc2M6IFwiUm91bmQgRG93bi1mdW5rc2pvbmVuIHJldHVybmVyZXIgbmVzdGUgbGF2ZXJlIGhlbHRhbGwgc29tIGVuIGZseXRwdW5rdHZlcmRpLCBmb3IgaHZlciBwaWtzZWwgaSBldCByYXN0ZXIuXCIsXG5cdFx0cm91bmRVcE5hbWU6IFwiQXZydW5kIG9wcG92ZXJcIixcblx0XHRyb3VuZFVwU25pcDogXCJSZXR1cm5lcmVyIG5lc3RlIGjDuHllcmUgaGVsdGFsbCwgcmVwcmVzZW50ZXJ0IHNvbSBldCBmbHl0cHVua3QsIGZvciBodmVyIGNlbGxlIGkgZXQgcmFzdGVyLlwiLFxuXHRcdHJvdW5kVXBEZXNjOiBcIlJvdW5kIFVwLWZ1bmtzam9uZW4gcmV0dXJuZXJlciBuZXN0ZSBow7h5ZXJlIGhlbHRhbGwgc29tIGVuIGZseXRwdW5rdHZlcmRpLCBmb3IgaHZlciBwaWtzZWwgaSBldCByYXN0ZXIuXCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdE5hbWU6IFwiU2VnbWVudCBNZWFuIFNoaWZ0XCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdFNuaXA6IFwiR3J1cHBlcmVyIG5hYm9waWtzbGVyIG1lZCBsaWduZW5kZSBzcGVrdHJhbGUgZWdlbnNrYXBlciBzYW1tZW4gaSBzZWdtZW50ZXIuXCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdERlc2M6IFwiRGVubmUgZnVua3Nqb25lbiBpZGVudGlmaXNlcmVyIG9iamVrdGVyLCB0cmVrayBlbGxlciBzZWdtZW50ZXIgaSBiaWxkZW5lIGRpbmUgdmVkIMOlIGdydXBwZXJlIHRpbHN0w7h0ZW5kZSBwaWtzbGVyIHNhbW1lbiBzb20gaGFyIGxpZ25lbmRlIHNwZWt0cmFsZSBvZyByb21saWdlIGVnZW5za2FwZXIuIER1IGthbiBrb250cm9sbGVyZSBtZW5nZGVuIHJvbWxpZyBvZyBzcGVrdHJhbCB1dGpldm5pbmcgZm9yIMOlIGhqZWxwZSB0aWwgbWVkIMOlIHRyZWtrZSB1dCBnZW9vYmpla3RlciBhdiBpbnRlcmVzc2UuXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uTmFtZTogXCJTZW50aW5lbC0xIFJhZGlvbWV0cmljIENhbGlicmF0aW9uXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uU25pcDogXCJVdGbDuHJlciBmb3Jza2plbGxpZ2UgdHlwZXIgcmFkaW9tZXRyaXNrIGthbGlicmVyaW5nIHDDpSBTZW50aW5lbC0xIGRhdGEuXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uRGVzYzogXCJEZW5uZSByYXN0ZXJmdW5rc2pvbmVuIHV0ZsO4cmVyIHRyZSBmb3Jza2plbGxpZ2Uga2FsaWJyZXJpbmdlciBmb3IgU2VudGluZWwgMS1kYXRhc2V0dCwgaW5rbHVkZXJ0IGJldGEgbnVsbCBvZyBnYW1tYSwgb2cgZ2lyIGRldCBrYWxpYnJlcnRlIGRhdGFzZXR0ZXQuIE3DpWxldCBtZWQgU0FSLWthbGlicmVyaW5nIGVyIMOlIHRpbGJ5IGJpbGRlciBodm9yIHBpa3NlbHZlcmRpZW5lIGthbiB2w6ZyZSBkaXJla3RlIHJlbGF0ZXJ0IHRpbCByYWRhci1iYWNrc2NhdHRlcmluZ2VuIGF2IHNjZW5lbi4gU2VsdiBvbSBpa2tlLWthbGlicmVydGUgU0FSLWJpbGRlciBlciB0aWxzdHJla2tlbGlnIGZvciBrdmFsaXRhdGl2IGJydWssIGVyIGthbGlicmVydGUgU0FSLWJpbGRlciBhdmdqw7hyZW5kZSBmb3Iga3ZhbnRpdGF0aXYgYnJ1ayBhdiBTQVItZGF0YS48ZGl2Pjxici8+VHlwaXNrIFNBUi1kYXRhYmVoYW5kbGluZywgc29tIHByb2R1c2VyZXIgbml2w6UgMS1iaWxkZXIsIG9tZmF0dGVyIGlra2UgcmFkaW9tZXRyaXNrZSBrb3JyZWtzam9uZXIgb2cgc2lnbmlmaWthbnRlIHJhZGlvbWV0cmlza2Ugc2tqZXZoZXRlciBibGlyIHbDpnJlbmRlLiBEZXJmb3IgZXIgZGV0IG7DuGR2ZW5kaWcgw6UgYnJ1a2UgcmFkaW9tZXRyaXNrIGtvcnJla3Nqb24gdGlsIFNBUi1iaWxkZXIsIHNsaWsgYXQgYmlsZGVuZXMgcGlrc2VsdmVyZGllciB2aXJrZWxpZyByZXByZXNlbnRlcmVyIHJhZGFyLWJhY2tzY2F0dGVyZW4gZm9yIGRlbiByZWZsZWt0ZXJlbmRlIG92ZXJmbGF0ZW4uIFJhZGlvbWV0cmlzayBrb3JyZWtzam9uIGVyIG9nc8OlIG7DuGR2ZW5kaWcgZm9yIMOlIHNhbW1lbmxpZ25lIFNBUi1iaWxkZXIgc29tIGVyIGlubmhlbnRldCBtZWQgZm9yc2tqZWxsaWdlIHNlbnNvcmVyIGVsbGVyIGhlbnRldCBmcmEgc2FtbWUgc2Vuc29yIHDDpSBmb3Jza2plbGxpZ2UgdGlkc3B1bmt0ZXIsIGkgZm9yc2tqZWxsaWdlIG1vZHVzZXIsIGVsbGVyIGVyIGJlaGFuZGxldCBhdiBmb3Jza2plbGxpZ2UgcHJvc2Vzc29yZXIuPC9kaXY+XCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsTmFtZTogXCJTZW50aW5lbC0xIFRoZXJtYWwgTm9pc2UgUmVtb3ZhbFwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbFNuaXA6IFwiRmplcm5lciB0ZXJtaXNrIHN0w7h5IGZyYSBTZW50aW5lbC0xIGRhdGEuXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsRGVzYzogXCJUZXJtaXNrIHN0w7h5a29ycmlnZXJpbmcga2FuIGJydWtlcyBww6UgU2VudGluZWwtMSBMZXZlbC0xIFNpbmdsZSBMb29rIENvbXBsZXggKFNMQyktcHJvZHVrdGVyIHNhbXQgR1JELXByb2R1a3RlciAoTGV2ZWwgMSBHcm91bmQgUmFuZ2UgRGV0ZWN0aW9uKSBzb20gaWtrZSBhbGxlcmVkZSBlciBrb3JyaWdlcnQuIE9wZXJhdG9yZW4ga2FuIG9nc8OlIGZqZXJuZSBkZW5uZSBrb3JyZWtzam9uZW4gYmFzZXJ0IHDDpSBwcm9kdWt0YW5ub250ZXJpbmdlbmUgZm9yIMOlIGdqZW5pbm5mw7hyZSBzdMO4eWVuIHNvbSBibGUgZmplcm5ldCBmb3Igw6UgcHJvZHVzZXJlIGRldCBvcHByaW5uZWxpZ2UgcHJvZHVrdGV0LiBQcm9kdWt0YW5ub3RlcmluZ2VuZSB2aWwgYmxpIG9wcGRhdGVydCB0aWxzdmFyZW5kZSBmb3Igw6UgdGlsbGF0ZSBicnVrIGF2IGtvcnJla3Nqb25lbiBww6Ugbnl0dC4gXCIsXG5cdFx0c2V0TnVsbE5hbWU6IFwiQW5naSBudWxsXCIsXG5cdFx0c2V0TnVsbFNuaXA6IFwiU2V0IE51bGwgYW5naXIgaWRlbnRpZmlzZXJ0ZSBjZWxsZXBsYXNzZXJpbmdlciB0aWwgTm9EYXRhIGJhc2VydCBww6Ugc3Blc2lmaXNlcnRlIGtyaXRlcmllci4gRGVuIHJldHVybmVyZXIgTm9EYXRhIGh2aXMgZW4gYmV0aW5nZXQgZXZhbHVlcmluZyBlciBzYW5uIG9nIHJldHVybmVyZXIgdmVyZGllbiBzb20gZXIgYW5naXR0IGF2IGV0IGFubmV0IHJhc3RlciBodmlzIGRlbiBlciB1c2Fubi5cIixcblx0XHRzZXROdWxsRGVzYzogXCJTZXQgTnVsbC1mdW5rc2pvbmVuIGFuZ2lyIGRlIGlkZW50aWZpc2VydGUgcGlrc2xlbmUgdGlsIE5vRGF0YSBiYXNlcnQgcMOlIGRlIHNwZXNpZmlra2Uga3JpdGVyaWVuZS4gRGVuIHJldHVybmVyZXIgTm9EYXRhIGh2aXMgZW4gYmV0aW5nZXQgdnVyZGVyaW5nIGVyIHNhbm4gKDEpIG9nIHJldHVybmVyZXIgdmVyZGllbiBzb20gZXIgYW5naXR0IGkgRmFsc2UgUmFzdGVyIGh2aXMgZW4gYmV0aW5nZXQgZXZhbHVlcmluZyBlciB1c2FubiAoMCkuIERpc3NlIGtyaXRlcmllbmUgZXIgc3Blc2lmaXNlcnQgYXYgdXRkYXRhIGF2IGVuIGxvZ2lzayBtYXRlbWF0aWtrZnVua3Nqb24sIHNvbSB2aWwgdsOmcmUgaW5uZGF0YXJhc3RlcmV0LlwiLFxuXHRcdHNoYWRlZFJlbGllZk5hbWU6IFwiU2t5Z2dlbGFndCByZWxpZWZmXCIsXG5cdFx0c2hhZGVkUmVsaWVmU25pcDogXCJMYWdlciBlbiBmbGVyYsOlbmRldCwgZmFyZ2Vrb2RldCAzRC1yZXByZXNlbnRhc2pvbiBhdiBvdmVyZmxhdGVuLCBtZWQgc29sZW5zIHJlbGF0aXZlIHBvc2lzam9uIHRhdHQgaSBiZXRyYWt0bmluZyBmb3Igw6Ugc2t5Z2dlbGVnZ2UgYmlsZGV0LlwiLFxuXHRcdHNoYWRlZFJlbGllZkRlc2M6IFwiU2hhZGVkIFJlbGllZi1mdW5rc2pvbmVuIHNrYXBlciBlbiBmYXJnZS0zRC1yZXByZXNlbnRhc2pvbiBhdiB0ZXJyZW5nZXQsIG9nIG9wcHJldHRlcyB2ZWQgw6Ugc2zDpSBzYW1tZW4gYmlsZGVuZSBmcmEgaMO4eWRla29kZWRlIG9nIHRlcnJlbmdza3lnZ2VtZXRvZGVyLiBEZW5uZSBmdW5rc2pvbmVuIGJydWtlciBow7h5ZGUtIG9nIGF6aW11dGVnZW5za2FwZW5lIHRpbCDDpSBhbmdpIHNvbGVucyBwb3Npc2pvbi48ZGl2Pjxici8+PC9kaXY+XCIsXG5cdFx0c2luSE5hbWU6IFwiU2luSFwiLFxuXHRcdHNpbkhTbmlwOiBcIkJlcmVnbmVyIGh5cGVyYm9sc2sgc2ludXMgZm9yIGNlbGxlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0c2luSERlc2M6IFwiRnVua3Nqb25lbiBiZXJlZ25lciBoeXBlcmJvbHNrIHNpbnVzIGZvciBwaWtzbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRzaW5OYW1lOiBcIlNpblwiLFxuXHRcdHNpblNuaXA6IFwiQmVyZWduZXIgc2ludXMgZm9yIGNlbGxlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0c2luRGVzYzogXCJGdW5rc2pvbmVuIGJlcmVnbmVyIHNpbnVzIGZvciBwaWtzbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRzbG9wZU5hbWU6IFwiSGVsbmluZ1wiLFxuXHRcdHNsb3BlU25pcDogXCJCZXJlZ25lciBlbmRyaW5nc3Rha3RlbiBmcmEgZW4gcGlrc2VsdmVyZGkgdGlsIG5hYm9lbmUuXCIsXG5cdFx0c2xvcGVEZXNjOiBcIkRlbm5lIHJhc3RlcmZ1bmtzam9uZW4gYmVyZWduZXIgaGVsbGluZ2VuLCBzb20gZXIgZW5kcmluZ3N0YWt0ZW4gZm9yIGjDuHlkZW4gZm9yIGh2ZXIgY2VsbGUgaSBkZW4gZGlnaXRhbGUgaMO4eWRlbW9kZWxsZW4gKERFTSkuIERldCBlciBkZW4gZsO4cnN0ZSBhdmxlZG5pbmdlbiBhdiBlbiBERU0uPGRpdj48YnIvPkRlbm5lIGZ1bmtzam9uZW4gYnJ1a2VyIGVuIGFrc2VsZXJlcnQgYXRhbigpLWZ1bmtzam9uLiBEZXQgZXIgc2VrcyBnYW5nZXIgcmFza2VyZSwgb2cgdGlsbsOmcm1lbHNlc2ZlaWxlbiBlciBhbGx0aWQgbWluZHJlIGVubiAwLDMgZ3JhZGVyLjwvZGl2PlwiLFxuXHRcdHNwZWNrbGVOYW1lOiBcIlNwZWNrbGVcIixcblx0XHRzcGVja2xlU25pcDogXCJUaWxieXIgZmlsdHJlIGZvciDDpSBmamVybmUgc3TDuHkgZnJhIGRhdGFzZXR0IGZvciBzeW50ZXRpc2tlIGJsZW5kZXLDpXBuaW5nZXIuXCIsXG5cdFx0c3BlY2tsZURlc2M6IFwiU3BlY2tsZSBlciBow7h5ZnJla3ZlbnQgc3TDuHkgcMOlIHJhZGFyZGF0YS4gQmlsZGVuZSBzb20gZXIgZ2VuZXJlcnQgYXYgU0FSLXN5c3RlbWVyIChzeW50aGV0aWMgYXBlcnR1cmUgcmFkYXIpIGVyLCBzb20gZW4gZsO4bGdlIGF2IHByb3Nlc3NlcmluZyBhdiBzcHJlZHRlIHNpZ25hbGVyIG9nIGludGVyZmVyZW5zIGF2IGVsZWt0cm9tYWduZXRpc2tlIGLDuGxnZXIgc3ByZWR0IGZyYSBvdmVyZmxhdGVyIGVsbGVyIGdqZW5zdGFuZGVyLCBzdsOmcnQgdXRzYXR0IGZvciBzcGVja2xlZmZla3Rlci4gRGVubmUgU3BlY2tsZS1mdW5rc2pvbmVuIGZpbHRyZXJlciBzdMO4eWVuIGZyYSByYWRhcmRhdGFzZXR0ZXQgb2cgamV2bmVyIGRlbiB1dCwgbWVucyBkdSBiZWhvbGRlciBrYW50ZW5lIGVsbGVyIGRlIHNrYXJwZSBnZW9vYmpla3RlbmUgaSBiaWxkZXQuXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uTmFtZTogXCJTcGVjdHJhbCBDb252ZXJzaW9uXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uU25pcDogXCJCcnVrZXIgZW4gbWF0cmlzZSBww6UgZXQgYmlsZGUgbWVkIGZsZXJlIGLDpW5kLlwiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvbkRlc2M6IFwiU3BlY3RyYWwgQ29udmVyc2lvbi1mdW5rc2pvbmVuIGJydWtlciBlbiBtYXRyaXNlIHDDpSBldCBiaWxkZSBtZWQgZmxlcmUgYsOlbmQgZm9yIMOlIHDDpXZpcmtlIGZhcmdldmVyZGllbmUgZm9yIHV0ZGF0YWVuZS48ZGl2Pjxici8+RW5rZWx0ZSBzZW5zb3JlciBoZW50ZXIgaWtrZSBpbm4gYmzDpSBiw6VuZCBww6UgZ3J1bm4gYXYgZXQgbGF2dCBzaWduYWwvc3TDuHlmb3Job2xkLiBEZXR0ZSBrYW4gZm9yIGVrc2VtcGVsIGJydWtlcyB0aWwgw6Uga29udmVydGVyZSBldCBmYWxza3QgaW5mcmFyw7hkdCBiaWxkZSB0aWwgZXQgbmVzdGVuIG5hdHVybGlnIGZhcmdlYmlsZGUuPC9kaXY+XCIsXG5cdFx0c3F1YXJlUm9vdE5hbWU6IFwiS3ZhZHJhdHJvdFwiLFxuXHRcdHNxdWFyZVJvb3RTbmlwOiBcIkJlcmVnbmVyIGt2YWRyYXRyb3RlbiBhdiBwaWtzZWx2ZXJkaWVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRzcXVhcmVSb290RGVzYzogXCJTcXVhcmUgUm9vdC1mdW5rc2pvbmVuIGJlcmVnbmVyIGt2YWRyYXRyb3RlbiBhdiBwaWtzZWx2ZXJkaWVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRzcXVhcmVOYW1lOiBcIkt2YWRyYXRcIixcblx0XHRzcXVhcmVTbmlwOiBcIkJlcmVnbmVyIGt2YWRyYXRldCBhdiBwaWtzZWx2ZXJkaWVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRzcXVhcmVEZXNjOiBcIlNxdWFyZS1mdW5rc2pvbmVuIGJlcmVnbmVyIGt2YWRyYXRldCBhdiBwaWtzZWx2ZXJkaWVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtTmFtZTogXCJTdGF0aXN0aWNzIG9nIEhpc3RvZ3JhbVwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1TbmlwOiBcIkRlZmluZXIgZWxsZXIga255dHQgdGlsIHN0YXRpc3Rpa2sgb2cgaGlzdG9ncmFtLlwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1EZXNjOiBcIlN0YXRpc3RpY3Mgb2cgSGlzdG9ncmFtLWZ1bmtzam9uZW4gYnJ1a2VzIHRpbCDDpSBkZWZpbmVyZSBzdGF0aXN0aWtrZW4gb2cgaGlzdG9ncmFtbWV0IHRpbCBldCByYXN0ZXIuIER1IGthbiBzZXR0ZSBpbm4gZGVubmUgZnVua3Nqb25lbiBww6Ugc2x1dHRlbiBhdiBmdW5rc2pvbnNramVkZW4gZm9yIMOlIGJlc2tyaXZlIHN0YXRpc3Rpa2tlbiBvZyBoaXN0b2dyYW1tZXQgdGlsIGVuIHJhc3RlcmZ1bmtzam9uc21hbCAoUkZUKS4gRGV0dGUga2FuIHbDpnJlIG7DuGR2ZW5kaWcgZm9yIMOlIGtvbnRyb2xsZXJlIHN0YW5kYXJkdmlzbmluZ2VuIGF2IGJlaGFuZGxpbmdzcmVzdWx0YXRldCwgc8OmcmxpZyBuw6VyIGR1IGRlZmluZXJlciBlbiBmdW5rc2pvbnNramVkZSBzb20gaW5uZWhvbGRlciBtYW5nZSBmdW5rc2pvbmVyLjxkaXY+PGJyLz5EdSBrYW4gZGVmaW5lcmUgc3RhdGlzdGlrayB2ZWQgw6Ugc2tyaXZlIGlubiB2ZXJkaWVuZSBlbGxlciBpbXBvcnRlcmUgZnJhIGV0IHJhc3RlcmRhdGFzZXR0IGVsbGVyIGVuIFhNTC1maWwuIEhpc3RvZ3JhbW1lciBrYW4gYmFyZSBkZWZpbmVyZXMgdmVkIMOlIGltcG9ydGVyZSBlbiBmaWwuPC9kaXY+XCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGlra1wiLFxuXHRcdHN0YXRpc3RpY3NTbmlwOiBcIkJlcmVnbmVyIGZva2Fsc3RhdGlzdGlrayBmb3IgaHZlciBwaWtzZWwgYXYgZXQgYmlsZGUgYmFzZXJ0IHDDpSBldCBkZWZpbmVydCBmb2thbG5hYm9sYWcuXCIsXG5cdFx0c3RhdGlzdGljc0Rlc2M6IFwiU3RhdGlzdGljcy1mdW5rc2pvbmVuIGJlcmVnbmVyIGZva2Fsc3RhdGlzdGlrayBmb3IgaHZlciBwaWtzZWwgYXYgZXQgYmlsZGUgYmFzZXJ0IHDDpSBldCBkZWZpbmVydCBmb2thbG5hYm9sYWcuPGRpdj48YnIvPlN0YXRpc3RpY3MtZnVua3Nqb25lbiBrYW4gYnJ1a2VzIHRpbCDDpSBmeWxsZSBtYW5nbGVuZGUgbGluamVyIGkgZXQgYmlsZGUuIE1hbmdsZW5kZSBsaW5qZXIgc2t5bGRlcyBvZnRlIHByb2JsZW1lciBpIHNlbnNvcmVuLCBzbGlrIGF0IGRhdGEgaWtrZSBzYW1sZXMgaW5uLiBEZXR0ZSBoYXIgc2tqZWRkIGkgc2Vuc29yZXIgc29tIExhbmRzYXQgN3MgRW5oYW5jZWQgVGhlbWF0aWMgTWFwcGVyIFBsdXMgKEVUTSspLiBEaXNzZSBtYW5nbGVuZGUgZGF0YWVuZSBza2FwZXIgcHJvYmxlbWVyIGZvciBhbmFseXNlbiBvZyBvZ3PDpSBuw6VyIGR1IHNlciBww6UgYmlsZGVuZS4gRGV0IGVyIGxpdGUgc29tIGthbiBnasO4cmVzIG7DpXIgZHUgYnJ1a2VyIGJpbGRlbmUgdGlsIGFuYWx5c2UsIG1lbiBodmlzIGRldCB2YXIgZXQgb3ZlcmxhcHBlbmRlIGJpbGRlLCBrYW4gZGV0IGJydWtlcyBpIHN0ZWRldCBmb3IgZGV0IG1hbmdsZW5kZSBpbm5ob2xkZXQuIERldCBzYW1tZSBrYW4gZ2rDuHJlcyBodmlzIGJpbGRlbmUgYnJ1a2VzIHRpbCB2aXN1YWxpc2VyaW5nLiBEZXQgZmlubmVzIGltaWRsZXJ0aWQgaWtrZSBhbGx0aWQgbm9lIGVrc3RyYSBiaWxkZSBmb3Igw6UgZnlsbGUgdXQgZGV0IG1hbmdsZW5kZSBpbm5ob2xkZXQsIHPDpSBkZXQgbcOlIHV0bGVkZXMgZnJhIGVrc2lzdGVyZW5kZSBkYXRhLjwvZGl2PlwiLFxuXHRcdHN0cmVhbUxpbmtOYW1lOiBcIlN0cmVhbSBMaW5rXCIsXG5cdFx0c3RyZWFtTGlua1NuaXA6IFwiVGlsb3JkbmVyIHVuaWtlIHZlcmRpZXIgdGlsIGRlbGVyIGF2IGV0IGxpbmrDpnJ0IHJhc3Rlcm5ldHR2ZXJrIG1lbGxvbSBrcnlzbmluZ3NwdW5rdGVyLlwiLFxuXHRcdHN0cmVhbUxpbmtEZXNjOiBcIkRlbiBnbG9iYWxlIFN0cmVhbSBMaW5rLWZ1bmtzam9uZW4gdGlsb3JkbmVyIHVuaWtlIHZlcmRpZXIgdGlsIGRlbGVyIGF2IGV0IGxpbmrDpnJ0IHJhc3Rlcm5ldHR2ZXJrIG1lbGxvbSBrcnlzbmluZ3NwdW5rdGVyLjxkaXY+PGJyLz5Lb2JsaW5nZXIgZXIgc2Vrc2pvbmVuZSBpIGVuIHN0csO4bWthbmFsIHNvbSBmb3JiaW5kZXIgdG8gcMOlZsO4bGdlbmRlIGtudXRlcHVua3RlciwgZXQga251dGVwdW5rdCBvZyB1dGzDuHBldCwgZWxsZXIgZXQga251dGVwdW5rdCBvZyBkcmVuZXJpbmdzZGVsaW5nZW4uIEkgaHlkcm9sb2dpIGthbGxlcyBkaXNzZSBzdHLDuG1zZWdtZW50ZW5lIHN0cmVrbmluZ2VyLiBFdCBrbnV0ZXB1bmt0IGVyIHJlbGF0ZXJ0IHRpbCBldCB1dGzDuHBzcHVua3Qgb2cgYmlkcmFyIHRpbCDDpSBhdmdyZW5zZSBldCB2YW5uc2tpbGxlIGVsbGVyIG5lZGLDuHJzZmVsdC48L2Rpdj5cIixcblx0XHRzdHJldGNoTmFtZTogXCJTdHJla2tcIixcblx0XHRzdHJldGNoU25pcDogXCJGb3JiZWRyZXIgZXQgYmlsZGUgdmVkIMOlIGp1c3RlcmUgcmVra2V2aWRkZW4gYXYgdmVyZGllbmUgc29tIHZpc2VzLiBEZXR0ZSBlbmRyZXIgaWtrZSBkZSB1bmRlcmxpZ2dlbmRlIHBpa3NlbHZlcmRpZW5lLiBIdmlzIGVuIHBpa3NlbCBoYXIgZW4gdmVyZGkgdXRlbmZvciBkZXQgYW5naXR0ZSBvbXLDpWRldCwgdmlzZXMgZGV0IHNvbSBtaW5pbXVtcy0gZWxsZXIgbWFrc2ltdW1zdmVyZGkuXCIsXG5cdFx0c3RyZXRjaERlc2M6IFwiU3RyZXRjaC1mdW5rc2pvbmVuIGZvcmJlZHJlciBldCBiaWxkZSB2ZWQgw6UgZW5kcmUgZWdlbnNrYXBlciBzb20gbHlzc3R5cmtlLCBrb250cmFzdCBvZyBnYW1tYSBnamVubm9tIGZsZXJlIHN0cmVra3R5cGVyLiBEZW5uZSBmdW5rc2pvbmVuIGJydWtlciBzdGF0aXN0aWtrIGZyYSByYXN0ZXJuZSBpIG1vc2Fpa2tkYXRhc2V0dGV0LiBIdmlzIGR1IGJydWtlciBkZW5uZSBmdW5rc2pvbmVuLCBtw6UgZHUgZGVyZm9yIHPDuHJnZSBmb3IgYXQgc3RhdGlzdGlrayBlciBiZXJlZ25ldC48ZGl2Pjxici8+U3RyZWtraW5nc3R5cGVuIGRlZmluZXJlciBlbiBoaXN0b2dyYW1zdHJla2tpbmcgc29tIHZpbCBibGkgYnJ1a3QgcMOlIHJhc3RyZW5lIGZvciDDpSBmb3JiZWRyZSB2aXNuaW5nZW4gYXYgZGVtLiBTdHJla2tpbmcgZm9yYmVkcmVyIHV0c2VlbmRldCBww6UgZGF0YWVuZSB2ZWQgw6Ugc3ByZSBwaWtzZWx2ZXJkaWVuZSBsYW5ncyBldCBoaXN0b2dyYW0gZnJhIG1pbmltdW1zLSBvZyBtYWtzaW11bXZlcmRpZW5lIHNvbSBlciBkZWZpbmVydCBhdiBiaXRkeWJkZW4uIDwvZGl2PlwiLFxuXHRcdHN3YXRoTmFtZTogXCJTd2F0aFwiLFxuXHRcdHN3YXRoU25pcDogXCJJbnRlcnBvbGVyZXIgZnJhIHVyZWdlbG1lc3NpZ2UgcnV0ZW5ldHQgZWxsZXIgc3dhdGgtZGF0YS5cIixcblx0XHRzd2F0aERlc2M6IFwiRW5rZWx0ZSBuZXRDREYtIGVsbGVyIEhERi1kYXRhc2V0dCBsYWdyZXIgZ2VvbG9rYXNqb25lbiBzb20gdXJlZ2VsbWVzc2lnIGFkc2tpbHRlIG1hdHJpc2VyLiBOw6VyIGR1IGxlZ2dlciB0aWwgZGlzc2UgZGF0YXNldHRlbmUgaSBldCBtb3NhaWtrZGF0YXNldHQsIHRhciBzd2F0aC1mdW5rc2pvbmVuIHVyZWdlbG1lc3NpZyBydXRlbmV0dGRhdGEgb2cgb21mb3JkZWxlciBkZW0gc2xpayBhdCBodmVyIHBpa3NlbCBlciBhdiBsaWsgc3TDuHJyZWxzZSBvZyBlciBmaXJrYW50ZXQuPGRpdj48YnIvPk7DpXIgZHUgbGVnZ2VyIHRpbCB2YXJpYWJsZXIgZnJhIG5ldENERiBlbGxlciBIREYgdGlsIGV0IG1vc2Fpa2tkYXRhc2V0dCwgdmlsIGRldCBhdXRvbWF0aXNrIHZlcmlmaXNlcmUgb20gZGF0YWVuZSBlciBvcmRuZXQgcmVnZWxtZXNzaWcuIEh2aXMgZGUgaWtrZSBlciBkZXQsIGJydWtlcyBzd2F0aC1mdW5rc2pvbmVuIGF1dG9tYXRpc2sgdGlsIMOlIGtvbnZlcnRlcmUgZGV0IHVyZWdlbG1lc3NpZ2UgcmFzdGVyZXQgdGlsIHB1bmt0ZXIgb2cgZGVyZXR0ZXIgdGlsIGV0IHJlZ2VsbWVzc2lnIHJ1dGVuZXR0YmFzZXJ0IHJhc3Rlci4gRHUga2FuIGVuZHJlIGludGVycG9sZXJpbmdzbWV0b2RlbiBvZyBjZWxsZXN0w7hycmVsc2VuIHNvbSBicnVrZXMgaSBzd2F0aOKAk2Z1bmtzam9uZW4uIEZvciByYXN0ZXJkYXRhIG1lZCByZWdlbG1lc3NpZ2UgbWVsbG9tcm9tIHZpbCBkZXQgaWtrZSBibGkgYnJ1ayBub2VuIGludGVycG9sZXJpbmcsIG9nIGRhdGFlbmUgdmlsIGJsaSBsZXN0IHNvbSBkZXQgZXIuPC9kaXY+XCIsXG5cdFx0dGFuSE5hbWU6IFwiVGFuSFwiLFxuXHRcdHRhbkhTbmlwOiBcIkJlcmVnbmVyIGh5cGVyYm9sc2sgdGFuZ2VudCBmb3IgY2VsbGVuZSBpIGV0IHJhc3Rlci5cIixcblx0XHR0YW5IRGVzYzogXCJGdW5rc2pvbmVuIGJlcmVnbmVyIGh5cGVyYm9sc2sgdGFuZ2VudCBmb3IgcGlrc2xlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0dGFuTmFtZTogXCJUYW5cIixcblx0XHR0YW5TbmlwOiBcIkJlcmVnbmVyIHRhbmdlbnQgZm9yIGNlbGxlbmUgaSBldCByYXN0ZXIuXCIsXG5cdFx0dGFuRGVzYzogXCJGdW5rc2pvbmVuIGJlcmVnbmVyIHRhbmdlbnQgZm9yIHBpa3NsZW5lIGkgZXQgcmFzdGVyLiBcIixcblx0XHR0YXNzZWxlZENhcE5hbWU6IFwiVGFzc2VsZWQgQ2FwIChLYXV0aC1UaG9tYXMpXCIsXG5cdFx0dGFzc2VsZWRDYXBTbmlwOiBcIkJlcmVnbmVyIG5pdsOlZXIgYXYgdmVnZXRhc2pvbiwgdsOldGhldCBvZyBseXNzdHlya2UuIERlbm5lIHRla25pa2tlbiBlciBhdmhlbmdpZyBhdiBrb2VmZmlzaWVudGVyIHNvbSBtw6UgYmVyZWduZXMgc3Blc2lmaWt0IGZvciBlbiBzZW5zb3IuXCIsXG5cdFx0dGFzc2VsZWRDYXBEZXNjOiBcIlRhc3NlbGVkIENhcCAoS2F1dGgtVGhvbWFzKS10cmFuc2Zvcm1hc2pvbmVuIGVyIGxhZ2V0IGZvciDDpSBhbmFseXNlcmUgb2cga2FydGxlZ2dlIHZlZ2V0YXNqb25zZmVub21lbm9sb2dpIG9nIGJ5dXR2aWtsaW5nc2VuZHJpbmdlciBzb20gb3BwZGFnZXMgYXYgZGl2ZXJzZSBzYXRlbGxpdHRzZW5zb3JzeXN0ZW1lci4gRGVuIGVyIGtqZW50IHNvbSBUYXNzZWxlZCBDYXAtdHJhbnNmb3JtYXNqb25lbiBww6UgZ3J1bm4gYXYgZm9ybWVuIHDDpSBkZW4gZ3JhZmlza2UgZm9yZGVsaW5nZW4gYXYgZGF0YS4gVHJhbnNmb3JtYXNqb25lbiBnYSBlbiBiZWdydW5uZWxzZSBmb3IgbcO4bnN0cmVuZSBtYW4gZmlubmVyIGkgTGFuZHNhdCBNU1MtZGF0YSBmb3IgbGFuZGJydWtzZmVsdCBzb20gZW4gZnVua3Nqb24gYXYgYXZsaW5nZW5lcyBsaXZzc3lrbHVzLiBFdHRlciBodmVydCBzb20gYXZsaW5nZXIgdm9rc2VyIGZyYSBmcsO4IHRpbCBtb2RlbiBwbGFudGUsIGVyIGRldCBlbiBuZXR0byDDuGtuaW5nIGkgbsOmcmluZnJhcsO4ZCBvZyByZWR1a3Nqb24gaSByw7hkIHJlZmxla3Nqb24gYmFzZXJ0IHDDpSBqb3JkZmFyZ2UuPGRpdj48YnIvPkFudmVuZGVsc2VuIGF2IGRlbm5lIHRyYW5zZm9ybWFzam9uZW4gZXIgdXR2aWRldCBmcmEgb3ZlcnbDpWtpbmcgYXYgYXZsaW5nZXIgdGlsIGFuYWx5c2Ugb2cga2FydGxlZ2dpbmcgYXYgdmVnZXRhc2pvbiBmb3IgZW4gcmVra2UgYnJ1a3NvbXLDpWRlciBzb20gc2tvZ2JydWssIGluZHVzdHJpZWxsIHZlZ2V0YXNqb25zZm9ydmFsdG5pbmcsIGthcnRsZWdnaW5nIG9nIGZvcnZhbHRuaW5nIGF2IMO4a29zeXN0ZW0sIHJlZ2lzdHJlcmUgb2cgb3ZlcnbDpWtlIGthcmJvbmZhbmdzdCBvZyAtbGFncmluZywgYnl1dHZpa2xpbmcgbWVkIG1lci4gRGVuIGhhciBvZ3PDpSB1dHZpZGV0IHNlZyBmcmEgw6Ugc3TDuHR0ZSBMYW5kc2F0IE1TUyB0aWwgw6UgaW5rbHVkZXJlIGFuZHJlIHBvcHVsw6ZyZSBzYXRlbGxpdHRzeXN0ZW1lciBzb20gTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0gKywgTGFuZHNhdCA4LCBJS09OT1MsIFF1aWNrQmlyZCwgV29ybGRWaWV3LTIgb2cgUmFwaWRFeWUgbXVsdGlzcGVjdHJhbC1zZW5zb3Jlci48L2Rpdj5cIixcblx0XHR0aW1lc05hbWU6IFwiZ2FuZ2VyXCIsXG5cdFx0dGltZXNTbmlwOiBcIk11bHRpcGxpc2VyZXIgdmVyZGllbmUgdGlsIHRvIHJhc3RlciBww6UgcGlrc2VsIGZvciBwaWtzZWwtYmFzaXMuXCIsXG5cdFx0dGltZXNEZXNjOiBcIlRpbWVzLWZ1bmtzam9uZW4gbXVsdGlwbGlzZXJlciB2ZXJkaWVuZSB0aWwgdG8gcmFzdGVyIHDDpSBwaWtzZWwgZm9yIHBpa3NlbC1iYXNpcy5cIixcblx0XHR0cmFuc3Bvc2VCaXRzTmFtZTogXCJUcmFuc3Bvc2UgQml0c1wiLFxuXHRcdHRyYW5zcG9zZUJpdHNTbmlwOiBcIlBha2tlciB1dCBiaXRlbmUgYXYgaW5uZGF0YXNwaWtzZWxldCBvZyBrYXJ0bGVnZ2VyIGRlbSB0aWwgc3Blc2lmaXNlcnRlIGJpdGVyIGkgdXRkYXRhcGlrc2VsZXQuIEZvcm3DpWxldCBtZWQgZGVubmUgZnVua3Nqb25lbiBlciDDpSBtYW5pcHVsZXJlIGJpdGVyIGZyYSBldCBwYXIgaW5uZGF0YSwgc29tIGZvciBla3NlbXBlbCBMYW5kc2F0IDgta3ZhbGl0ZXRzYsOlbmRwcm9kdWt0ZXIuXCIsXG5cdFx0dHJhbnNwb3NlQml0c0Rlc2M6IFwiVHJhbnNwb3NlIEJpdC1mdW5rc2pvbmVuIHBha2tlciB1dCBiaXRlbmUgYXYgaW5uZGF0YXNwaWtzZWxldCBvZyB0aWxvcmRuZXIgZGVtIHRpbCBzcGVzaWZpc2VydGUgYml0ZXIgaSB1dGRhdGFwaWtzZWxldC4gRm9ybcOlbGV0IG1lZCBkZW5uZSBmdW5rc2pvbmVuIGVyIMOlIG1hbmlwdWxlcmUgYml0ZXIgZnJhIGV0IHBhciBpbm5kYXRhLCBzb20gZm9yIGVrc2VtcGVsIExhbmRzYXQgOC1rdmFsaXRldHNiw6VuZHByb2R1a3Rlci5cIixcblx0XHR1bml0Q29udmVyc2lvbk5hbWU6IFwiVW5pdCBDb252ZXJzaW9uXCIsXG5cdFx0dW5pdENvbnZlcnNpb25TbmlwOiBcIkVuZHJlciB2ZXJkaWVyIGZyYSBlbiBtw6VsZWVuaGV0IHRpbCBlbiBhbm5lbi5cIixcblx0XHR1bml0Q29udmVyc2lvbkRlc2M6IFwiRGVubmUgZnVua3Nqb25lbiBrb252ZXJ0ZXJlciBwaWtzbGVyIGZyYSBlbiBlbmhldCB0aWwgZW4gYW5uZW4uIERlbiBzdMO4dHRlciBrb252ZXJ0ZXJpbmcgYXYgYXZzdGFuZCwgaGFzdGlnaGV0IG9nIHRlbXBlcmF0dXIuXCIsXG5cdFx0dmVjdG9yRmllbGROYW1lOiBcIlZla3RvcmZlbHRcIixcblx0XHR2ZWN0b3JGaWVsZFNuaXA6IFwiVmlzZXIgZGF0YXNldHQgbWVkIGLDpWRlIG9tZmFuZyAodSkgb2cgcmV0bmluZyAodikgc29tIHBpbGVyLCBkZXIgb21mYW5nZXQgZXIgcmVwcmVzZW50ZXJ0IGF2IHBpbGVucyBzdMO4cnJlbHNlbiBvZyByZXRuaW5nZW4gZXIgcmVwcmVzZW50ZXJ0IHZlZCBwaWxlbnMgdmlua2VsLlwiLFxuXHRcdHZlY3RvckZpZWxkRGVzYzogXCJWZWN0b3IgRmllbGQtZnVua3Nqb25lbiBicnVrZXMgdGlsIMOlIHNhbW1lbnNldHRlIG9nIGtvbnZlcnRlcmUgdG8gcmFzdGVyIHRpbCBldCB0b2LDpW5kc3Jhc3RlciBzb20gZW50ZW4gZXIgZGF0YXR5cGUgTWFnbml0dWRlLURpcmVjdGlvbiBlbGxlciBkYXRhdHlwZSBVLVYuPGRpdj48YnIvPlUtdmVyZGllbiBrYWxsZXMgbm9lbiBnYW5nZXIgc29uYWxoYXN0aWdoZXQsIG9nIFYtdmVyZGllbiBrYWxsZXMgbm9lbiBnYW5nZXIgbWVyaWRpb25hbGhhc3RpZ2hldC48L2Rpdj5cIixcblx0XHR2aWV3c2hlZDJOYW1lOiBcIlN5bnNmZWx0XCIsXG5cdFx0dmlld3NoZWQyU25pcDogXCJGaW5uZXIgdmVkIGhqZWxwIGF2IGdlb2RldGlza2UgbWV0b2RlciBodmlsa2VuIGRlbCBhdiByYXN0ZXJvdmVyZmxhdGVuIHNvbSBlciBzeW5saWcgZm9yIGV0IHNldHQgYXYgb2JzZXJ2YXTDuHJlci5cIixcblx0XHR2aWV3c2hlZDJEZXNjOiBcIlZpZXdzaGVkLWZ1bmtzam9uZW4gZmlubmVyIHZlZCBoamVscCBhdiBnZW9kZXRpc2tlIG1ldG9kZXIgaHZpbGtlbiBkZWwgYXYgcmFzdGVyb3ZlcmZsYXRlbiBzb20gZXIgc3lubGlnIGZvciBldCBzZXR0IGF2IG9ic2VydmF0w7hyZXIuPGRpdj48YnIvPlN5bmxpZ2hldGVuIGZvciBodmVydCBwaWtzZWxzZW50ZXIgYmVzdGVtbWVzIGF2IGVuIHNpa3RsaW5qZXRlc3QgbWVsbG9tIG3DpWxldCBvZyBodmVyIG9ic2VydmF0w7hyLiBIdmlzIGVuIG9ic2VydmF0w7hyIGthbiBzZSBtw6VsZXQgdmVkIHBpa3NlbHNlbnRlcmV0LCBiZXRyYWt0ZXMgcGlrc2VsZXQgc29tIHN5bmxpZy4gRGV0dGUgdmVya3TDuHlldCB2dXJkZXJlciBhbGx0aWQgam9yZGVucyBrcnVtbmluZyBuw6VyIHN5bmxpZ2hldGVuIGJlc3RlbW1lcy48L2Rpdj5cIixcblx0XHR3YXRlcnNoZWROYW1lOiBcIlZhbm5za2lsbGVcIixcblx0XHR3YXRlcnNoZWRTbmlwOiBcIkJlc3RlbW1lciB0aWxmw7hyc2Vsc29tcsOlZGV0IG92ZXIgZXQgc2V0dCBtZWQgY2VsbGVyIGkgZXQgcmFzdGVyLlwiLFxuXHRcdHdhdGVyc2hlZERlc2M6IFwiRGVuIGdsb2JhbGUgV2F0ZXJzaGVkLWZ1bnNram9uZW4gYmVzdGVtbWVyIHRpbGbDuHJzZWxzb21yw6VkZXQgb3ZlciBldCBzZXR0IG1lZCBwaWtzbGVyIGkgZXQgcmFzdGVyLiBWYW5uc2tpbGxlciBlciBhdmdyZW5zZXQgZnJhIGV0IHN0csO4bW5pbmdzcmV0bmluZ3Jhc3RlciBzb20gaWRlbnRpZmlzZXJlciBzdHLDuG1uaW5nc3JldG5pbmdlbiBmcmEgaHZlciBwaWtzZWwuXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5TmFtZTogXCJXZWlnaHRlZCBPdmVybGF5XCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5U25pcDogXCJMZWdnZXIgb3ZlciBmbGVyZSByYXN0ZXIgdmVkIGhqZWxwIGF2IGVuIGZlbGxlcyBtw6VsZXNrYWxhIG9nIHZla3QgaHZlciBldHRlciBkZW5zIGJldHlkbmluZy5cIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlEZXNjOiBcIkRlbm5lIGZ1bmtzam9uZW4gbGFyIGRlZyBsZWdnZSBmbGVyZSByYXN0ZXIgbWVkIGVuIGZlbGxlcyBtw6VsZXNrYWxhIG9wcMOlIGh2ZXJhbmRyZSwgb2cgdmVrdGUgaHZlcnQgcmFzdGVyIGV0dGVyIGRldHMgYmV0eWRuaW5nLlwiLFxuXHRcdHdlaWdodGVkU3VtTmFtZTogXCJXZWlnaHRlZCBTdW1cIixcblx0XHR3ZWlnaHRlZFN1bVNuaXA6IFwiVmVrdGVyIG9nIGxlZ2dlciB0aWwgZW4gcmVra2UgbWVkIHJhc3RlciBww6UgZW4gY2VsbGUtdGlsLWNlbGxlIGJhc2lzLlwiLFxuXHRcdHdlaWdodGVkU3VtRGVzYzogXCJXZWlnaHRlZCBTdW0tZnVua3Nqb25lbiBsYXIgZGVnIGxlZ2dlIG92ZXIgZmxlcmUgcmFzdGVyLCBtdWx0aXBsaXNlcmUgaHZlcnQgbWVkIHNpbiBvcHBnaXR0ZSB2ZWt0IG9nIHN1bW1lcmUgZGVtIHNhbW1lbi5cIixcblx0XHR3aW5kY2hpbGxOYW1lOiBcIlZpbmRmYWt0b3JcIixcblx0XHR3aW5kY2hpbGxTbmlwOiBcIktvbWJpbmVyZXIgb21naXZlbHNlc3RlbXBlcmF0dXIgb2cgdmluZGhhc3RpZ2hldCBmb3Igw6UgYmVyZWduZSB2aW5kZmFrdG9yZW4uXCIsXG5cdFx0d2luZGNoaWxsRGVzYzogXCJXaW5kIENoaWxsLWZ1bmtzam9uZW4gZXIgbnl0dGlnIGZvciDDpSBpZGVudGlmaXNlcmUgZmFybGlnZSB2aW50ZXJmb3Job2xkIHNvbSwgYXZoZW5naWcgYXYgZWtzcG9uZXJpbmdzdGlkZW4gZm9yIGVsZW1lbnRlbmUsIGthbiByZXN1bHRlcmUgaSBmb3JmcnlzbmluZ2VyIGVsbGVyIGh5cG90ZXJtaS4gVmluZGZha3RvciBlciBlbiBtw6V0ZSDDpSBtw6VsZSBodm9yIGthbGQgZW4gcGVyc29uIGbDuGxlciBzZWcgbsOlciB2aW5kZW4gdGFzIGkgYmV0cmFrdG5pbmcsIHZlZCBhbGxlcmVkZSBrYWxkZSB0ZW1wZXJhdHVyZXIuIEpvIHJhc2tlcmUgdmluZGhhc3RpZ2hldGVuIGVyLCBkZXN0byByYXNrZXJlIHZpbCBrcm9wcGVuIG1pc3RlIHZhcm1lIG9nIGpvIGthbGRlcmUgdmlsIGZvbGsgZsO4bGUgc2VnLlwiLFxuXHRcdHpvbmFsUmVtYXBOYW1lOiBcIlpvbmFsIFJlbWFwXCIsXG5cdFx0em9uYWxSZW1hcFNuaXA6IFwiT21mb3JtIHBpa3NsZXIgaSBldCByYXN0ZXIgYmFzZXJ0IHDDpSBzb25lciBzb20gZXIgZGVmaW5lcnQgaSBldCBhbm5ldCByYXN0ZXIgb2cgc29uYXZoZW5naWcgdmVyZGl0aWxvcmRuaW5nIHNvbSBlciBkZWZpbmVydCBpIGVuIHRhYmVsbC5cIixcblx0XHR6b25hbFJlbWFwRGVzYzogXCJNZWQgZGVubmUgZnVua3Nqb25lbiBrYW4gZHUgb21mb3JtZSBwaWtzbGVyIGkgZXQgcmFzdGVyIGJhc2VydCBww6Ugc29uZXIgc29tIGVyIGRlZmluZXJ0IGkgZXQgYW5uZW4gcmFzdGVyIG9nIHNvbmF2aGVuZ2lnIHZlcmRpdGlsb3JkbmluZyBzb20gZXIgZGVmaW5lcnQgaSBlbiB0YWJlbGwuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzTmFtZTogXCJab25hbCBTdGF0aXN0aWNzXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzU25pcDogXCJCZXJlZ25lciBzdGF0aXN0aWtrIG92ZXIgdmVyZGllciBhdiBldCByYXN0ZXIgaW5uZW5mb3Igc29uZW5lIHRpbCBldCBhbm5ldCBkYXRhc2V0dC5cIixcblx0XHR6b25hbFN0YXRpc3RpY3NEZXNjOiBcIkZ1bmtzam9uZW4gYmVyZWduZXIgc3RhdGlzdGlrayBvdmVyIHZlcmRpZXIgYXYgZXQgcmFzdGVyIGlubmVuZm9yIHNvbmVuZSB0aWwgZXQgYW5uZXQgZGF0YXNldHQuIEVuIHNvbmUgZXIgZGVmaW5lcnQgc29tIGFsbGUgb21yw6VkZXIgaSBpbm5kYXRhZW5lIHNvbSBoYXIgc2FtbWUgdmVyZGkuIERpc3NlIG9tcsOlZGVuZSBiZWjDuHZlciBpa2tlIHbDpnJlIHNhbW1lbmhlbmdlbmRlLiBOw6VyIHNvbmVuIG9nIHZlcmRpLWlubmRhdGFyYXN0ZXJldCBiZWdnZSBlciByYXN0ZXIgbWVkIHNhbW1lIG9wcGzDuHNuaW5nLCBibGlyIGRlIGJydWt0IGRpcmVrdGUuIEh2aXMgb3BwbMO4c25pbmdlbmUgZXIgZm9yc2tqZWxsaWdlLCBicnVrZXMgZW4gaW50ZXJuIHJlc2FtcGxpbmcgZm9yIMOlIGdqw7hyZSBvcHBsw7hzbmluZ2VuZSBzYW1zdmFyZW5kZSBmw7hyIHNvbmVvcGVyYXNqb25lbiB1dGbDuHJlcy5cIixcblx0XHRmbG93TGVuZ3RoTmFtZTogXCJGbG93IExlbmd0aFwiLFxuXHRcdGZsb3dMZW5ndGhTbmlwOiBcIkJlcmVnbmVyIG9wcHN0csO4bXMtIGVsbGVyIG5lZHN0csO4bXNhdnN0YW5kIGVsbGVyIHZla3RldCBhdnN0YW5kIGxhbmdzIHN0csO4bW5pbmdzYmFuZW4gZm9yIGh2ZXIgY2VsbGUuXCIsXG5cdFx0Zmxvd0xlbmd0aERlc2M6IFwiRGV0dGUgZXIgZW4gZ2xvYmFsIHJhc3RlcmZ1bmtzam9uLiBEZW5uZSBmdW5rc2pvbmVuIG9wcHJldHRlciBldCByYXN0ZXJsYWcgbWVkIG9wcHN0csO4bXMtIGVsbGVyIG5lZHN0csO4bXNhdnN0YW5kIGVsbGVyIHZla3RldCBhdnN0YW5kIGxhbmdzIHN0csO4bW5pbmdzYmFuZW4gZm9yIGh2ZXIgY2VsbGUuPGRpdj48YnIvPkZsb3cgTGVuZ3RoLWZ1bmtzam9uZW4gYnJ1a2VzIHByaW3DpnJ0IHRpbCDDpSBiZXJlZ25lIGxlbmdkZW4gcMOlIGxlbmdzdGUgc3Ryw7htbmluZ3N2ZWkgaW5uZW5mb3IgZXQgZ2l0dCBiYXNzZW5nLiBNw6VsaW5nZW4gYnJ1a2VzIG9mdGUgdGlsIMOlIGJlcmVnbmUga29uc2VudHJhc2pvbnN0aWRlbiBmb3IgZXQgYmFzc2VuZy4gRGV0dGUgZ2rDuHJlcyB2ZWQgw6UgYnJ1a2UgT3Bwc3Ryw7htcy1hbHRlcm5hdGl2ZXQuIEZ1bmtzam9uZW4ga2FuIG9nc8OlIGJydWtlcyB0aWwgw6Ugb3BwcmV0dGUgYXZzdGFuZHNkaWFncmFtbWVyIG92ZXIgaHlwb3RldGlzayBuZWRiw7hyIG9nIGF2cmVubmluZ3NoZW5kZWxzZXIgdmVkIGhqZWxwIGF2IHZla3RyYXN0ZXJldCBzb20gZW4gaW1wZWRhbnMgZm9yIG5lZGFkZ8OlZW5kZSBiZXZlZ2Vsc2UuPC9kaXY+XCIsXG5cdFx0c3RyZWFtT3JkZXJOYW1lOiBcIlN0csO4bXJla2tlZsO4bGdlXCIsXG5cdFx0c3RyZWFtT3JkZXJTbmlwOiBcIlRpbG9yZG5lciBlbiBudW1lcmlzayByZWtrZWbDuGxnZSB0aWwgc2VnbWVudGVyIGkgZXQgcmFzdGVyIHNvbSByZXByZXNlbnRlcmVyIGZvcmdyZW5pbmdlciBpIGV0IGxpbmXDpnJ0IG5ldHR2ZXJrLlwiLFxuXHRcdHN0cmVhbU9yZGVyRGVzYzogXCJEZXR0ZSBlciBlbiBnbG9iYWwgcmFzdGVyZnVua3Nqb24uIERlbm5lIGZ1bmtzam9uZW4gb3BwcmV0dGVyIGV0IHJhc3RlcmxhZyBzb20gdGlsb3JkbmVyIGVuIG51bWVyaXNrIHJla2tlZsO4bGdlIHRpbCBzZWdtZW50ZXIgaSBldCByYXN0ZXIgc29tIHJlcHJlc2VudGVyZXIgZm9yZ3JlbmluZ2VyIGkgZXQgbGluZcOmcnQgbmV0dHZlcmsuPGRpdj48YnIvPlV0ZGF0YWVuZSBmcmEgU3RyZWFtIE9yZGVyLWZ1bmtzam9uZW4gdmlsIGhhIGjDuHllcmUga3ZhbGl0ZXQgaHZpcyBpbm5kYXRhbGFnZXQgZm9yIHN0csO4bW5pbmdzcmFzdGVyIG9nIGlubmRhdGFsYWdldCBmb3Igc3Ryw7htbmluZ3NyZXRuaW5nc3Jhc3RlciBlciBhdmxlZGV0IGZyYSBzYW1tZSBvdmVyZmxhdGUuIEh2aXMgc3Ryw7htcmFzdGVyZXQgZXIgYXZsZWRldCBhdiBldCByYXN0cmVydCBzdHLDuG1kYXRhc2V0dCwga2FuIGRldCBoZW5kZSB1dGRhdGFlbmUgaWtrZSBrYW4gYnJ1a2VzIGZvcmRpIHJldG5pbmdlbiBjZWxsZSBmb3IgY2VsbGVyIGlra2Ugc2Ftc3ZhcmVyIG1lZCBwbGFzc2VyaW5nZW4gYXYgc3Ryw7htY2VsbGVuZS4gUmVzdWx0YXRlbmUgYXYgZnVua3Nqb25lbiBTdHLDuG1uaW5nc2Fra3VtdWxlcmluZyBrYW4gYnJ1a2VzIHRpbCDDpSBsYWdlIGV0IHJhc3RlcnN0csO4bW5pbmduZXR0dmVyayB2ZWQgw6UgYnJ1a2UgZW4gdGVyc2tlbHZlcmRpIHRpbCDDpSB2ZWxnZSBjZWxsZXIgbWVkIGjDuHkgYWtrdW11bGVydCBzdHLDuG1uaW5nLiBGb3IgZWtzZW1wZWwgYnJ1a2VzIGNlbGxlciBzb20gaGFyIG1lciBlbm4gMTAwIGNlbGxlciBzb20gZmx5dGVyIGlubiBpIGRlbSwgdGlsIMOlIGRlZmluZXJlIHN0csO4bW5ldHR2ZXJrZXQuIEJydWsgZnVua3Nqb25lbmUgQmV0aW5nZXQgZWxsZXIgQW5naSBudWxsIHRpbCDDpSBvcHByZXR0ZSBldCBzdHLDuG1uaW5nc25ldHR2ZXJrc3Jhc3RlciBkZXIgc3Ryw7htbmluZ3Nha2t1bXVsZXJpbmdzdmVyZGllciBww6UgMTAwIGVsbGVyIG92ZXIgZ8OlciB0aWwgZXQgcmFzdGVyIG9nIHJlc3RlbiBzZW5kZXMgdGlsIGJha2dydW5uZW4gKE5vRGF0YSkuIERldCByZXN1bHRlcmVuZGUgc3Ryw7htbmV0dHZlcmtldCBrYW4gYnJ1a2VzIGkgZnVua3Nqb25lbiBTdHLDuG1yZWtrZWbDuGxnZS4gRnVua3Nqb25lbiBzdMO4dHRlciBiYXJlIGV0IHJhc3RlcmxhZyBtZWQgRDgtc3Ryw7htcmV0bmluZyBzb20gaW5uZGF0YS4gRDgtc3Ryw7htbmluZ3NyZXRuaW5nZXIga2FuIG9wcHJldHRlcyB2ZWQgaGplbHAgYXYgZnVua3Nqb25lbiBTdHLDuG1uaW5nc3JldG5pbmcgb2cga2rDuHJlcyBtZWQgc3RhbmRhcmQgc3Ryw7htbmluZ3NyZXRuaW5nIEQ4LjwvZGl2PlwiLFxuXHRcdHNuYXBQb3VyUG9pbnROYW1lOiBcIkZlc3QgdXRsw7hwc3B1bmt0XCIsXG5cdFx0c25hcFBvdXJQb2ludFNuaXA6IFwiRmVzdGVyIHV0bMO4cHNwdW5rdCB0aWwgY2VsbGVuIG1lZCBow7h5ZXN0IHN0csO4bW5pbmdzYWtrdW11bGVyaW5nIGlubmVuZm9yIGVuIGdpdHQgYXZzdGFuZFwiLFxuXHRcdHNuYXBQb3VyUG9pbnREZXNjOiBcIkRldHRlIGVyIGVuIGdsb2JhbCByYXN0ZXJmdW5rc2pvbi4gRGVubmUgZnVua3Nqb25lbiBmZXN0ZXIgdXRsw7hwc3B1bmt0ZXIgdGlsIGNlbGxlbiBtZWQgaMO4eWVzdCBzdHLDuG1uaW5nc2Fra3VtdWxlcmluZyBpbm5lbmZvciBlbiBhbmdpdHQgYXZzdGFuZC48ZGl2Pjxici8+RnVua3Nqb25lbiBGZXN0IHV0bMO4cHNwdW5rdCBicnVrZXMgdGlsIMOlIHNpa3JlIHV0dmFsZ2V0IGF2IHB1bmt0IG1lZCBow7h5IGFra3VtdWxlcnQgc3Ryw7htbmluZyB2ZWQgYXZncmVuc2luZyBhdiBuZWRzbGFnc2ZlbHQgdmVkIGhqZWxwIGF2IFZhbm5za2lsbGUtZnVua3Nqb25lbi4gRmVzdCB1dGzDuHBzcHVua3Qgc8O4a2VyIGV0dGVyIGNlbGxlbiBtZWQgaMO4eWVzdCBzdHLDuG1uaW5nc2Fra3VtdWxlcmluZyBpbm5lbmZvciBlbiBzbmFwcGF2c3RhbmQgcnVuZHQgZGUgYW5naXR0ZSB1dGzDuHBzcHVua3RlbmUsIG9nIGZseXR0ZXIgdXRsw7hwc3B1bmt0ZXQgdGlsIGRlbm5lIGxva2Fzam9uZW4uIFV0ZGF0YSBlciBldCBoZWx0YWxscyByYXN0ZXJsYWcgbsOlciBkZSBvcHByaW5uZWxpZ2UgdXRsw7hwc3B1bmt0bG9rYXNqb25lbmUgZXIgZmVzdGV0IHRpbCBsb2thc2pvbmVuZSBmb3IgaMO4eWVzdCBha2t1bXVsZXJ0IGZseXQuPC9kaXY+XCIsXG5cdFx0c2lua05hbWU6IFwiRm9yc2Vua25pbmdcIixcblx0XHRzaW5rU25pcDogXCJPcHByZXR0ZXIgZXQgcmFzdGVyIHNvbSBpZGVudGlmaXNlcmVyIGFsbGUgZm9yc2Vua25pbmdlciBlbGxlciBvbXLDpWRlciBtZWQgZHJlbmVyaW5nXCIsXG5cdFx0c2lua0Rlc2M6IFwiRGV0dGUgZXIgZW4gZ2xvYmFsIHJhc3RlcmZ1bmtzam9uLiBEZW5uZSBmdW5rc2pvbmVuIG9wcHJldHRlciBldCByYXN0ZXJsYWcgc29tIGlkZW50aWZpc2VyZXIgYWxsZSBmb3JzZW5rbmluZ2VyIGVsbGVyIG9tcsOlZGVyIG1lZCBkcmVuZXJpbmcuIEVuIGZvcnNlbmtuaW5nIGVyIGVuIGNlbGxlIGVsbGVyIGV0IHNldHQgbWVkIHNwYXRpYWx0IGZvcmJ1bmRuZSBjZWxsZXIgbWVkIGVuIHN0csO4bW5pbmdzcmV0bmluZyBzb20gaWtrZSBrYW4gdGlsb3JkbmVzIGVuIGF2IGRlIMOldHRlIHZlcmRpZW5lIGkgZW4gc3Ryw7htbmluZ3NyZXRuaW5nc3Jhc3Rlci4gRGV0dGUga2FuIGlubnRyZWZmZSBuw6VyIGFsbGUgbmFib2NlbGxlciBlciBow7h5ZXJlIGVubiBiZWhhbmRsaW5nc2NlbGxlbiwgZWxsZXIgbsOlciB0byBjZWxsZXIgZmx5dGVyIGlubiBpIGh2ZXJhbmRyZSBvZyBkYW5uZXIgZW4gdG9jZWxsZXJzIHNsw7h5ZmUuPGRpdj48YnIvPkZvcnNlbmtuaW5nLWZ1bmtzam9uZW4gc3TDuHR0ZXIga3VuIGV0IHJhc3RlcmxhZyBtZWQgRDgtc3Ryw7htbmluZ3NyZXRuaW5nIHNvbSBpbm5kYXRhLiBEOC1zdHLDuG1uaW5nc3JldG5pbmdlciBrYW4gb3BwcmV0dGVzIHZlZCBoamVscCBhdiBmdW5rc2pvbmVuIFN0csO4bW5pbmdzcmV0bmluZyBvZyBrasO4cmVzIG1lZCBzdGFuZGFyZCBzdHLDuG1uaW5nc3JldG5pbmcgRDguIFV0ZGF0YWVuZSBmb3IgRm9yc2Vua25pbmctZnVua3Nqb25lbiBlciBldCBoZWx0YWxsc3Jhc3RlciBkZXIgaHZlciBmb3JzZW5rbmluZyBlciB0aWxvcmRuZXQgZW4gdW5payB2ZXJkaS4gRGlzc2UgdW5pa2UgdmVyZGllbmUgbGlnZ2VyIGkgb21yw6VkZXQgZnJhIMOpbiB0aWwgdG90YWx0IGFudGFsbCBmb3JzZW5rbmluZ2VyLiBIdmlzIGZvciBla3NlbXBlbCBzYW1sZXQgYW50YWxsIGZvcnNlbmtuaW5nZXIgZXIgMTAwMCwgZXIgZGUgdW5pa2UgdmVyZGllbmUgaSBvbXLDpWRldCAxIHRpbCAxMDAwLjwvZGl2PlwiLFxuXHRcdGFnZ3JlZ2F0ZU5hbWU6IFwiU3VtbWVyXCIsXG5cdFx0YWdncmVnYXRlU25pcDogXCJHZW5lcmVyZXIgZW4gdmVyc2pvbiBhdiBldCByYXN0ZXIgbWVkIHJlZHVzZXJ0IG9wcGzDuHNuaW5nLlwiLFxuXHRcdGFnZ3JlZ2F0ZURlc2M6IFwiQWdncmVnZXJpbmdzZnVua3Nqb25lbiBzYW1wbGVyIGV0IGlubmRhdGFyYXN0ZXIgcMOlIG55dHQgbWVkIGVuIGdyb3ZlcmUgb3BwbMO4c25pbmcgYmFzZXJ0IHDDpSBlbiBhbmdpdHQgYWdncmVnZXJpbmdzc3RyYXRlZ2kuIEh2ZXIgdXRkYXRhY2VsbGUgaW5uZWhvbGRlciBzdW0sIG1pbmltdW0sIG1ha3NpbXVtLCBnamVubm9tc25pdHQgZWxsZXIgbWVkaWFuIGZvciB1dGRhdGFjZWxsZW5lIHNvbSBlciBpbm5lbmZvciB1dHN0cmVrbmluZ2VuIGF2IGRlbiBjZWxsZW4uPGRpdj48YnIvPkR1IGthbiBhbmdpIGZha3RvcmVuIHNvbSBjZWxsZXN0w7hycmVsc2VuIGZvciBpbm5kYXRhcmFzdGVyZXQgc2thbCBtdWx0aXBsaXNlcmVzIG1lZC4gRm9yIGVrc2VtcGVsIHZpbCBlbiBjZWxsZWZha3RvcnZlcmRpIHDDpSB0cmUgcmVzdWx0ZXJlIGkgZW4gdXRkYXRhY2VsbGVzdMO4cnJlbHNlIHNvbSBlciB0cmUgZ2FuZ2VyIHN0w7hycmUgZW5uIGkgaW5uZGF0YXJhc3RlcmV0LiBEdSBrYW4gZGVmaW5lcmUgaHZvcmRhbiB1dHN0cmVrbmluZ2VuIGZvciB1dGRhdGEgc2thbCBow6VuZHRlcmVzIGh2aXMgYW50YWxsIHJhZGVyIGVsbGVyIGtvbG9ubmVyIGkgaW5uZGF0YWVuZSBpa2tlIGVyIGVuIGVrc2FrdCBtdWx0aXBwZWwgYXYgY2VsbGVmYWt0b3Jlbi4gU29tIHN0YW5kYXJkIHV0dmlkZXMgw7h2cmUgb2cgaMO4eXJlIGdyZW5zZSBmb3Igw6UgZGVra2UgZW4gc3TDuHJyZSByb21saWcgdXRzdHJla25pbmcgZW5uIGRlbiBpIGlubmRhdGFyYXN0ZXJldCBmb3Igw6Ugc2lrcmUgYXQgYWxsZSBpbm5kYXRhY2VsbGVyIGJlaGFuZGxlcy4gQWx0ZXJuYXRpdnQga2FuIMO4dnJlIG9nIGjDuHlyZSBncmVuc2UgbWluc2tlcyBmb3Igw6UgZGVra2UgZW4gbWluZHJlIHJvbWxpZyB1dHN0cmVrbmluZyBzbGlrIGF0IGFudGFsbGV0IHJhZGVyIG9nIGtvbG9ubmVyIHNvbSBiZWhhbmRsZXMsIGVyIGVuIGVrc2FrdCBtdWx0aXBwZWwgYXYgY2VsbGVmYWt0b3Jlbi4gRHUga2FuIGRlZmluZXJlIGh2b3JkYW4gTm9EYXRhLWNlbGxlciBza2FsIGjDpW5kdGVyZXMgaSBkZW4gYWdncmVnZXJ0ZSBiZXJlZ25pbmdlbi4gU3RhbmRhcmRtZWthbmlzbWVuIGVyIGF0IE5vRGF0YS1pbm5kYXRhY2VsbGVyIHNvbSBmYWxsZXIgaW5uZW5mb3IgZGVuIHJvbWxpZ2UgdXRzdHJla25pbmdlbiBhdiBlbiBzdMO4cnJlIGNlbGxlIGkgdXRkYXRhcmFzdGVyZXQsIGlnbm9yZXJlcyBuw6VyIHZlcmRpZW4gYXYgdXRkYXRhY2VsbGVuIGJlc3RlbW1lcy4gQWx0ZXJuYXRpdnQga2FuIGR1IHNwZXNpZmlzZXJlIGF0IGh2aXMgZGV0IGJhcmUgZXIgZW4gZW5rZWx0IE5vRGF0YS1pbm5kYXRhY2VsbGUgaW5uZW5mb3IgZGVuIHJvbWxpZ2UgdXRzdHJla25pbmdlbiBmb3IgZW4gdXRkYXRhY2VsbGUsIGJsaXIgZGVubmUgY2VsbGVuIGVuIE5vRGF0YS1jZWxsZSBpIHV0ZGF0YXJhc3RlcmV0LjwvZGl2PlwiLFxuXHRcdGNjZGNOYW1lOiBcIkNDREMtYW5hbHlzZVwiLFxuXHRcdGNjZGNTbmlwOiBcIkJydWtlciBhbGdvcml0bWVuIGZvciBrb250aW51ZXJsaWcgZW5kcmluZ3NkZXRla3Nqb24gb2cga2xhc3NpZmlzZXJpbmcgKENDREMpIHRpbCDDpSBldmFsdWVyZXIgZW5kcmluZ2VyIGkgcGlrc2VsdmVyZGllciBvdmVyIHRpZCBvZyBnZW5lcmVyZSBtb2RlbGxyZXN1bHRhdGVyLlwiLFxuXHRcdGNjZGNEZXNjOiBcIkNDREMtYW5hbHlzZWZ1bmtzam9uZW4gYnJ1a2VyIGFsZ29yaXRtZW4gZm9yIGtvbnRpbnVlcmxpZyBlbmRyaW5nc2RldGVrc2pvbiBvZyBrbGFzc2lmaXNlcmluZyAoQ0NEQykgdGlsIMOlIGV2YWx1ZXJlciBlbmRyaW5nZXIgaSBwaWtzZWx2ZXJkaWVyIG92ZXIgdGlkIG9nIGdlbmVyZXJlIGV0IGZsZXJkaW1lbnNqb25hbHQgcmFzdGVyIHNvbSBpbm5laG9sZGVyIG1vZGVsbHJlc3VsdGF0ZW5lLiBEZXR0ZSBzdMO4dHRlcyBrdW4gc2FtbWVuIG1lZCBmdW5rc2pvbmVuIERldGVjdCBDaGFuZ2UgVXNpbmcgQ2hhbmdlIEFuYWx5c2lzIGkgZW4gcmFzdGVyZnVua3Nqb25zbWFsLiBEdSBsYWdlciByYXN0ZXJ1dGRhdGEgdmVkIMOlIGtvYmxlIENDREMgQW5hbHlzaXMtZnVua3Nqb25lbiB0aWwgZnVua3Nqb25lbiBEZXRlY3QgQ2hhbmdlIFVzaW5nIENoYW5nZSBBbmFseXNpcywgbGFncmUgc29tIGVuIHJhc3RlcmZ1bmtzam9uc21hbCBvZyBrasO4cmUgcmFzdGVyYW5hbHlzZSBtZWQgZnVua3Nqb25zbWFsZW4uPGRpdj48YnIvPkRlbm5lIGZ1bmtzam9uZW4gYnJ1a2VyIGFsZ29yaXRtZW4gZm9yIGtvbnRpbnVlcmxpZyBlbmRyaW5nc2RldGVrc2pvbiBvZyBrbGFzc2lmaXNlcmluZyAoQ0NEQykgdGlsIMOlIGV2YWx1ZXJlIGVuZHJpbmdlciBpIHBpa3NlbHZlcmRpZXIgb3ZlciB0aWQgZm9yIGVuIHN0YWJlbCBtZWQgYmlsZGVyLiBJIGVuIHRpZHNzZXJpZSBtZWQgb3B0aXNrZSBiaWxkZXIgZWxsZXIgYmlsZGVkZXJpdmF0ZXIgKGZvciBla3NlbXBlbCBETlZJKSwga2FuIHBpa3NlbHZlcmRpZW5lIHZhcmllcmUgYXYgZmxlcmUgZ3J1bm5lcjogMS4gw4Vyc3RpZHNlbmRyaW5nZXIg4oCTIFBpa3NlbHZlcmRpZW5kcmluZ2VyIHJlZmxla3RlcmVyIGVuZHJpbmdlciBpIHZlZ2V0YXNqb24gc29tIHNreWxkZXMgw6Vyc3RpZHN2YXJpYXNqb25lciBpIHRlbXBlcmF0dXIgb2cgbmVkYsO4ci4gUMOFIGRlbiBub3JkbGlnZSBoYWx2a3VsZSBmb3J2ZW50ZXIgdmkgZm9yIGVrc2VtcGVsIMOlIHNlIGjDuHllcmUgdGV0dGhldCBhdiBncsO4bm4gdmVnZXRhc2pvbiBvbSBzb21tZXJlbiBzYW1tZW5saWduZXQgbWVkIHZpbnRlcmVuLiAyLiBHcmFkdmlzIGVuZHJpbmcg4oCTIFBpa3NlbHZlcmRpZW5kcmluZ2VyIGdqZW5zcGVpbGVyIHRlbmRlbnNlciBpIHZlZ2V0YXNqb24gZWxsZXIgb3ZlcmZsYXRldmFubiBzb20gc2t5bGRlcyBrbGltYXZhcmlhc2pvbiBlbGxlciBsYW5ndmFyaWcgYXJlYWxmb3J2YWx0bmluZ3NwcmFrc2lzLiBGb3IgZWtzZW1wZWwga2FuIGJhciBqb3JkIMO4a2UgZ3JhZHZpcyBpIGFyZWFsIHNvbSBmw7hsZ2UgYXYgbGFuZ3ZhcmlnIHJlZHVrc2pvbiBpIG5lZGLDuHIuIDMuIFBsdXRzZWxpZyBlbmRyaW5nIOKAkyBQaWtzZWx2ZXJkaWVuZHJpbmdlciBnamVuc3BlaWxlciBlbmRyaW5nZXIgaSBhcmVhbGRla2tlIHNvbSBvcHBzdMOlciBwbHV0c2VsaWcgc29tIGbDuGxnZSBhdiBhdnNrb2dpbmcsIGJ5dXR2aWtsaW5nLCBuYXR1cmthdGFzdHJvZmVyIG9nIHPDpSB2aWRlcmUuIENDREMtYWxnb3JpdG1lbiBpZGVudGlmaXNlcmVyIGFsbGUgZGlzc2UgdHJlIGVuZHJpbmdzdHlwZW5lIG9nIGhvdmVkZm9ybcOlbGV0IGVyIMOlIGlkZW50aWZpc2VyZSBwbHV0c2VsaWdlIGVuZHJpbmdlci4gSGFybW9uaXNrIHJlZ3Jlc2pvbnMtIG9nIHRyZW5kbW9kZWxsZXIgdGlscGFzc2VzIHRpbCBkYXRhZW5lIGZvciDDpSBlc3RpbWVyZSDDpXJzdGlkc2Jhc2VydCBvZyBncmFkdmlzIGVuZHJpbmcsIG9nIHBsdXRzZWxpZ2UgYXZ2aWsgZnJhIHRyZW5kbW9kZWxsZW5lIGVyIGluZGlrYXNqb25lciBww6UgcGx1dHNlbGlnIGVuZHJpbmcuPGRpdj48YnIvPkNDREMtYWxnb3JpdG1lbiBibGUgb3BwcmlubmVsaWcgdXR2aWtsZXQgZm9yIExhbmRzYXQgVE0sIExhbmRzYXQgRVRNKyBvZyBMYW5kc2F0IE9MSS1kYXRhIGZvciBvdmVyZmxhdGVyZWZsZWt0YW5zIG9nIHN0csOlbGV0ZW1wZXJhdHVyLiBGdW5rc2pvbmVuIERldGVjdCBDaGFuZ2UgVXNpbmcgQ2hhbmdlIEFuYWx5c2lzIHNhbW1lbiBtZWQgZGVubmUgZnVua3Nqb25lbiB2aWwgaW1pZGxlcnRpZCBvcHBkYWdlIGVuZHJpbmcgZm9yIGJpbGRlciBtZWQgZmxlcmUgYsOlbmQgZnJhIHNlbnNvcmVyIHNvbSBzdMO4dHRlcywgc2FtdCBiaWxkZWRlcml2YXRlciBtZWQgZXR0IGLDpW5kLCBzb20gYsOlbmRpbmRla3Nlci4gRHUga2FuIGZvciBla3NlbXBlbCB1dGbDuHJlIGtvbnRpbnVlcmxpZyBlbmRyaW5nc2RldGVrc2pvbiBww6UgZXQgTkRWSS1yYXN0ZXIgKE5vcm1hbGl6ZSBEaWZmZXJlbmNlIFZlZ2V0YXRpb24gSW5kZXgpIGZvcmRpIHBsdXRzZWxpZ2UgZW5kcmluZ2VyIGkgTkRWSSBrYW4gdsOmcmUgZW4gaW5kaWthc2pvbiBww6UgYXZza29naW5nLjwvZGl2PlwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VOYW1lOiBcIkNvbXB1dGUgQ2hhbmdlXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZVNuaXA6IFwiQmVyZWduZXIgZGlmZmVyYW5zZW4gbWVsbG9tIHRvIGthdGVnb3Jpc2tlIGVsbGVyIGtvbnRpbnVlcmxpZ2UgcmFzdGVyZGF0YXNldHQuXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZURlc2M6IFwiQ29tcHV0ZSBDaGFuZ2UtZnVua3Nqb25lbiBrYW4gYnJ1a2VzIHRpbCDDpSBzcGVzaWZpc2VyZSBmb3Jza2plbGxlbmUgbWVsbG9tIHRvIGtsYXNzaWZpc2VydGUgcmFzdHJlIGZvciBhbmFseXNlIGF2IGVuZHJpbmdlciBpIGFyZWFsZGVra2UuIERlbiBrYW4gb2dzw6UgYnJ1a2VzIHRpbCDDpSB1bmRlcnPDuGtlIGVuZHJpbmdlciBtZWxsb20gdG8ga29udGludWVybGlnZSBlbmtlbHRiw6VuZHJhc3RyZSwgc29tIGjDuHlkZSwgdGVtcGVyYXR1ciwgdHJla3JvbmVkZWtuaW5nIG9zdi5cIixcblx0XHRkZXRlY3RDaGFuZ2VOYW1lOiBcIkRldGVjdCBDaGFuZ2UgVXNpbmcgQ2hhbmdlIEFuYWx5c2lzXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlU25pcDogXCJHZW5lcmVyZXIgZXQgcmFzdGVybGFnIHNvbSBpbm5laG9sZGVyIGluZm9ybWFzam9uIG9tIHBpa3NlbGVuZHJpbmdlciwgdmVkIMOlIGJydWtlIGRldCByZXN1bHRlcmVuZGUgZW5kcmluZ3NhbmFseXNlcmFzdGVyZXQuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlRGVzYzogXCI8ZGl2PkZ1bmtzam9uZW4gUmVnaXN0cmVyIGVuZHJpbmcgdmVkIGhqZWxwIGF2IGVuZHJpbmdzYW5hbHlzZXJhc3RlciBnZW5lcmVyZXIgZXQgcmFzdGVybGFnIHNvbSBpbm5laG9sZGVyIGluZm9ybWFzam9uIG9tIGRhdG9lbiBmb3IgcGlrc2VsZW5kcmluZ2VyLCB2ZWQgw6UgYnJ1a2UgZW5kcmluZ3NhbmFseXNlcmFzdGVyZXQuIEVuZHJpbmdzYW5hbHlzZXJhc3RlcmV0IG3DpSBnZW5lcmVyZXMgYXYgdmVya3TDuHlldCBBbmFseXNlciBlbmRyaW5nZXIgdmVkIGhqZWxwIGF2IENDREMgZWxsZXIgdmVya3TDuHlldCBBbmFseXNlciBlbmRyaW5nZXIgdmVkIGhqZWxwIGF2IExhbmRUcmVuZHIgZWxsZXIgcmFzdGVyZnVua3Nqb25lbiBDQ0RDLWFuYWx5c2UgZWxsZXIgcmFzdGVyZnVua3Nqb25lbiBMYW5kVHJlbmRyLWFuYWx5c2UuPC9kaXY+PGJyPjxkaXY+RGVubmUgcmFzdGVyZnVua3Nqb25lbiBrYW4ga29tYmluZXJlcyBtZWQgcmFzdGVyZnVua3Nqb25lbiBDQ0RDLWFuYWx5c2UgZWxsZXIgcmFzdGVyZnVua3Nqb25lbiBMYW5kVHJlbmRyLWFuYWx5c2UgaSBlbiByYXN0ZXJmdW5rc2pvbnNtYWwuIEZvciDDpSBwcm9kdXNlcmUgZXQgcGVybWFuZW50IHJhc3RlcnJlc3VsdGF0IG3DpSBDQ0RDLWFuYWx5c2UtIGVsbGVyIExhbmRUcmVuZHItYW5hbHlzZWZ1bmtzam9uZW4ga29ibGVzIHRpbCBmdW5rc2pvbmVuIFJlZ2lzdHJlciBlbmRyaW5nIHZlZCBoamVscCBhdiBlbmRyaW5nc2FuYWx5c2VyYXN0ZXIgbGFncmVzIHNvbSBlbiByYXN0ZXJmdW5rc2pvbnNtYWwgb2cga2rDuHJlcyBzb20gcmFzdGVyYW5hbHlzZSBtZWQgbWFsZW4uPC9kaXY+PGJyPjxkaXY+UGFyYW1ldGVyZW4gPHN0cm9uZz5FbmRyaW5nc3R5cGU8L3N0cm9uZz4gYW5naXIgaW5mb3JtYXNqb25lbiBzb20gZ2VuZXJlcmVzLiBJbmZvcm1hc2pvbiB0cmVra2VzIHV0IGZyYSBlbmRyaW5nc2FuYWx5c2VyYXN0ZXJldC4gTsOlciBkdSBrasO4cmVyIGRlbm5lIGZ1bmtzam9uZW4gcMOlIHJlc3VsdGF0ZXQgZnJhIENDREMtZnVua3Nqb25lbi92ZXJrdMO4eWV0LCBrYW4gZHUgdmVsZ2UgbWVsbG9tIGbDuGxnZW5kZSBhbHRlcm5hdGl2ZXI6PC9kaXY+PHVsPjxsaT48c3Ryb25nPlRpZHNwdW5rdCBmb3Igc2lzdGUgZW5kcmluZzwvc3Ryb25nPiDigJPCoFNpc3RlIGRhdG8gb2cga2xva2tlc2xldHQgZGEgZW4gcGlrc2VsIGJsZSBmbGFnZ2V0IHNvbSBlbmRyZXQuPC9saT48bGk+PHN0cm9uZz5UaWRzcHVua3QgZm9yIHRpZGxpZ3N0ZSBlbmRyaW5nPC9zdHJvbmc+IOKAk1RpZGxpZ3N0ZSBkYXRvIG9nIGtsb2trZXNsZXR0IGRhIGVuIHBpa3NlbCBibGUgZmxhZ2dldCBzb20gZW5kcmV0LjwvbGk+PGxpPjxzdHJvbmc+VGlkc3B1bmt0IGZvciBzdMO4cnN0ZSBlbmRyaW5nPC9zdHJvbmc+IOKAkyBEYXRvIG9nIGtsb2trZXNsZXR0IGRhIGRlbiBiZXJlZ25lZGUgZW5kcmluZ2VuIGhhZGRlIHN0w7hyc3QgYmV0eWRuaW5nIGZvciBlbiBwaWtzZWwuPC9saT48bGk+IDxzdHJvbmc+QW50YWxsIGVuZHJpbmdlcjwvc3Ryb25nPiDigJMgRGV0IHRvdGFsZSBhbnRhbGxldCBnYW5nZXIgcGlrc2VsZW4gYmxlIGVuZHJldC48L2xpPjwvdWw+PGRpdj5Ow6VyIGRlbm5lIGZ1bmtzam9uZW4ga2rDuHJlcyBww6UgcmVzdWx0YXRldCBhdiBMYW5kVHJlbmRyLWZ1bmtzam9uZW4vdmVya3TDuHlldCwgZXIgZsO4bGdlbmRlIHRpbGxlZ2dzYWx0ZXJuYXRpdmVyIHRpbGdqZW5nZWxpZ2U6PC9kaXY+PHVsPjxsaT48c3Ryb25nPlRpZHNwdW5rdCBmb3IgbGVuZ3N0ZSBlbmRyaW5nPC9zdHJvbmc+IOKAkyBEYXRvZW4gZGEgZW4gcGlrc2VsIGJsZSBmbGFnZ2V0IHNvbSBlbmRyZXQsIHZlZCBiZWd5bm5lbHNlbiBlbGxlciBzbHV0dGVuIGF2IGRlbiBsZW5nc3RlIGVuZHJpbmdzcGVyaW9kZW4uPC9saT48bGk+PHN0cm9uZz5UaWRzcHVua3QgZm9yIGtvcnRlc3RlIGVuZHJpbmc8L3N0cm9uZz4g4oCTIERhdG9lbiBkYSBlbiBwaWtzZWwgYmxlIGZsYWdnZXQgc29tIGVuZHJldCwgdmVkIGJlZ3lubmVsc2VuIGVsbGVyIHNsdXR0ZW4gYXYgZGVuIGtvcnRlc3RlIGVuZHJpbmdzcGVyaW9kZW4uPC9saT48bGk+PHN0cm9uZz5UaWRzcHVua3QgZm9yIHJhc2tlc3RlIGVuZHJpbmc8L3N0cm9uZz4g4oCTIERhdG9lbiBkYSBlbiBwaWtzZWwgYmxlIGZsYWdnZXQgc29tIGVuZHJldCwgdmVkIGJlZ3lubmVsc2VuIGVsbGVyIHNsdXR0ZW4gYXYgZGVuIHJhc2tlc3RlIGVuZHJpbmdzcGVyaW9kZW4uPC9saT48bGk+PHN0cm9uZz5UaWRzcHVua3QgZm9yIGxhbmdzb21zdGUgZW5kcmluZzwvc3Ryb25nPiDigJMgRGF0b2VuIGRhIGVuIHBpa3NlbCBibGUgZmxhZ2dldCBzb20gZW5kcmV0LCB2ZWQgYmVneW5uZWxzZW4gZWxsZXIgc2x1dHRlbiBhdiBkZW4gbGFuZ3NvbXN0ZSBlbmRyaW5nc3BlcmlvZGVuLjwvbGk+PC91bD48ZGl2PkRldCByZXN1bHRlcmVuZGUgcmFzdGVyZXQgZXIgZXQgZmxlcmLDpW5kc3Jhc3RlciBkZXIgaHZlcnQgYsOlbmQgaW5uZWhvbGRlciBlbmRyaW5nc2luZm9ybWFzam9uIHNvbSBhdmhlbmdlciBhdiBodmlsa2VuIGVuZHJpbmdzdHlwZSBzb20gZXIgdmFsZ3Qgb2cgZGV0IG1ha3NpbWFsZSBhbnRhbGxldCBlbmRyaW5nZXIgc29tIGVyIGFuZ2l0dC4gSHZpcyBmb3IgZWtzZW1wZWwgPHN0cm9uZz5FbmRyaW5nc3R5cGU8L3N0cm9uZz4gZXIgc2F0dCB0aWwgPHN0cm9uZz5UaWRzcHVua3QgZm9yIHRpZGxpZ3N0ZSBlbmRyaW5nPC9zdHJvbmc+IG9nIDxzdHJvbmc+TWFrc2ltYWx0IGFudGFsbCBlbmRyaW5nZXI8L3N0cm9uZz4gZXIgc2F0dCB0aWwgMiwgYmVyZWduZXIgZnVua3Nqb25lbiBkZSB0byB0aWRsaWdzdGUgZGF0b2VuZSBkYSBlbmRyaW5nIGZhbnQgc3RlZCBpIGzDuHBldCBhdiB0aWRzc2VyaWVuIGZvciBodmVyIGVua2VsdCBwaWtzZWwuIFJlc3VsdGF0ZXQgZXIgZXQgcmFzdGVyIGRlciBkZXQgZsO4cnN0ZSBiw6VuZGV0IGlubmVob2xkZXIgZGF0b2VuZSBmb3IgdGlkbGlnc3RlIGVuZHJpbmcgcGVyIHBpa3NlbCwgb2cgZGV0IGFuZHJlIGLDpW5kZXQgaW5uZWhvbGRlciBkYXRvZW5lIGZvciBuZXN0IHRpZGxpZ3N0ZSBlbmRyaW5nIHBlciBwaWtzZWwuPC9kaXY+PGJyPjxkaXY+TsOlciBkZW5uZSBmdW5rc2pvbmVuIGJydWtlcyBww6UgdXRkYXRhZW5lIGZyYSBMYW5kVHJlbmRyLXZlcmt0w7h5ZW5lLCBrYW4gZHUgdmVsZ2Ugb20gZHUgdmlsIHRyZWtrZSB1dCBkYXRvZW4gc29tIG1hcmtlcmVyIGJlZ3lubmVsc2VuIHDDpSBlbiBlbmRyaW5nIGVsbGVyIHNsdXR0ZW4gcMOlIGVuIGVuZHJpbmcsIHZlZCDDpSBicnVrZSBwYXJhbWV0ZXJlbiA8c3Ryb25nPlNlZ21lbnRkYXRvPC9zdHJvbmc+LiBIdmlzIGR1IGZvciBla3NlbXBlbCB2aWwgZm9yc3TDpSBodm9yZGFuIGRlbiBueWxpZ3N0ZSBlbmRyaW5nZW4gaSB0aWRzc2VyaWVuIHN0YXJ0ZXQsIGthbiBkdSBzZXR0ZSA8c3Ryb25nPkVuZHJpbmdzdHlwZTwvc3Ryb25nPiB0aWwgPHN0cm9uZz5UaWRzcHVua3QgZm9yIHNpc3RlIGVuZHJpbmc8L3N0cm9uZz4gb2cgPHN0cm9uZz5TZWdtZW50ZGF0bzwvc3Ryb25nPiB0aWwgPHN0cm9uZz5TZWdtZW50ZXRzIGJlZ3lubmVsc2U8L3N0cm9uZz4uPC9kaXY+PGJyPjxkaXY+QnJ1ayBmw7hsZ2VuZGUgZmlsdHJlcmluZ3NwYXJhbWV0ZXJlIGZvciDDpSB0cmVra2UgdXQgbWVyIHNwZXNpZmlra2UgZW5kcmluZ3NkYXRvZXIgZnJhIGVuZHJpbmdzYW5hbHlzZXJhc3RlcmV0OjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5GaWx0cmVyIGV0dGVyIMOlcjwvc3Ryb25nPiDigJNJZGVudGlmaXNlciBlbmRyaW5nZXIgc29tIGZvcmVrb20gaSBsw7hwZXQgYXYgZW4gYmVzdGVtdCB0aWRzcGVyaW9kZSwgZm9yIGVrc2VtcGVsIGh2aXMgZHUgc2VyIGV0dGVyIGVuZHJpbmdlciBzb20gaGFyIGZ1bm5ldCBzdGVkIGkgZXQgbGFuZHNrYXAgaSBsw7hwZXQgYXYgZmVtIMOlciBtZWQgdMO4cmtlLjwvbGk+PGxpPjxzdHJvbmc+RmlsdHJlciBldHRlciB2YXJpZ2hldDwvc3Ryb25nPiDigJMgSWRlbnRpZmlzZXIgZW5kcmluZ2VyIHNvbSBoYXIgZnVubmV0IHN0ZWQgaSBsw7hwZXQgYXYgZXQgZ2l0dCBhbnRhbGwgw6VyLCBmb3IgZWtzZW1wZWwgaHZpcyBkdSBiYXJlIHNlciBldHRlciBwbHV0c2VsaWdlIGVuZHJpbmdlciBzb20gaGFyIGZ1bm5ldCBzdGVkIGkgbMO4cGV0IGF2IGV0dCBlbGxlciB0byDDpXIuIER1IGthbiBiZXJlZ25lIHZhcmlnaGV0ZW4gZHUgZXIgaW50ZXJlc3NlcnQgaSwgdmVkIMOlIGJydWtlIGZvcm1lbGVuIDxzdHJvbmc+YXZzbHV0bmluZ3PDpXIg4oCTIHN0YXJ0w6VyICsxPC9zdHJvbmc+LiBPcHBob2xkIGkgdGlkc3NlcmllbiBibGlyIGlua2x1ZGVydC48L2xpPjxsaT48c3Ryb25nPkZpbHRyZXIgZXR0ZXIgc3TDuHJyZWxzZTwvc3Ryb25nPiDigJMgSWRlbnRpZmlzZXIgZW5kcmluZ2VyIGF2IGVuIHZpc3Mgc3TDuHJyZWxzZSwgZm9yIGVrc2VtcGVsIGh2aXMgZHUgYmFyZSBzZXIgZXR0ZXIgc3RvcmUgZW5kcmluZ2VyIGkgdmVnZXRhc2pvbnNpbmRla3NlbiBORFZJIChOb3JtYWxpemVkIERpZmZlcmVuY2UgVmVnZXRhdGlvbiBJbmRleCkuIFN0w7hycmVsc2UgZXIgZW4gYWJzb2x1dHQgdmVyZGksIHPDpSBtaW5pbXVtcy0gb2cgbWFrc2ltdW1zdmVyZGllciBrYW4gaWtrZSB2w6ZyZSBuZWdhdGl2ZS4gQnJ1ayBwYXJhbWV0ZXJlbiA8c3Ryb25nPkVuZHJpbmdzcmV0bmluZzwvc3Ryb25nPiBodmlzIGR1IHZpbCBhbmdpIHJldG5pbmdzZW5kcmluZ2VyLjwvbGk+PC91bD5cIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvbk5hbWU6IFwiRGlzdGFuY2UgQWNjdW11bGF0aW9uXCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25TbmlwOiBcIkJlcmVnbmVyIGFra3VtdWxlcnQgYXZzdGFuZCBmb3IgaHZlciBjZWxsZSB0aWwga2lsZGVuZSBvZyB0aWxsYXRlciByZXR0bGluamV0IGF2c3RhbmQga29zdG5hZHNhdnN0YW5kLCByZWVsbCBvdmVyZmxhdGVhdnN0YW5kIHNhbXQgdmVydGlrYWxlIG9nIGhvcmlzb250YWxlIGtvc3RuYWRzZmFrdG9yZXIuXCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25EZXNjOiBcIkRpc3RhbmNlIEFjY3VtdWxhdGlvbiBiZXJlZ25lciBhdnN0YW5kZW4gdGlsIGh2ZXIgbG9rYXNqb24gaSBzdHVkaWVvbXLDpWRldCB0aWwgbsOmcm1lc3RlLCBlbGxlciByaW1lbGlnc3RlLCBraWxkZS4gRGVyc29tIGt1biBraWxkZW5lIG9wcGdpcyBzb20gaW5uZGF0YSwgc8OlIGJlcmVnbmVzIGRldCBlbiByZXR0bGluamV0IGF2c3RhbmQgdGlsIGh2ZXIgbG9rYXNqb24gaSBzdHVkaWVvbXLDpWRldC4gSHZpcyBiw6VkZSBraWxkZXIgb2cgaGluZHJpbmdlciBicnVrZXMgc29tIGlubmRhdGEsIGJlcmVnbmVyIERpc3RhbmNlIEFjY3VtdWxhdGlvbi1mdW5rc2pvbmVuIGRlbiByZXR0bGluamVkZSBhdnN0YW5kZW4gZm9yYmkgaGluZHJpbmdlci4gRm9yIGLDpWRlIGtpbGRlcmFzdGVyZXQgb2cgaGluZHJpbmdzcmFzdGVyZXQgc2thbCBiYWtncnVubnN2ZXJkaWVuIHbDpnJlIE5vRGF0YSwgbWVucyBraWxkZXIgb2cgaGluZHJpbmdlciByZXByZXNlbnRlcmVzIG1lZCBneWxkaWdlIGNlbGxldmVyZGllci4gR3lsZGlnZSBjZWxsZXZlcmRpZXIgb21mYXR0ZXIgbnVsbC4gPGRpdj48YnIvPk7DpXIgZXQgb3ZlcmZsYXRlcmFzdGVyIGJydWtlcyBzb20gaW5uZGF0YSwgYmVyZWduZXMgZGVuIGZha3Rpc2tlIG92ZXJmbGF0ZWF2c3RhbmRlbiBtZWxsb20gY2VsbGVuZS4gSHZpcyBkdSB2aWwgdXRmw7hyZSBrb3N0bmFkc2FuYWx5c2UgdmVkIGhqZWxwIGF2IERpc3RhbmNlIEFjY3VtdWxhdGlvbi1mdW5rc2pvbmVuLCBtw6UgZHUgaGEgZW4ga29zdG5hZHNvdmVyZmxhdGUuIEh2aXMgZGV0IGVyIGFuZ2l0dCBlbiBrb3N0bmFkc292ZXJmbGF0ZSwgYmxpciByZXN1bHRhdGV0IGV0IHJhc3RlciBtZWQgYWtrdW11bGVydCBrb3N0bmFkc2F2c3RhbmQuIE7DpXIgaG9yaXNvbnRhbGUgb2cgdmVydGlrYWxlIGZha3RvcmVyIGVyIG9wcGdpdHQsIGJsaXIgcmV0bmluZyB2dXJkZXJ0IGV0dGVyIGh2ZXJ0IHNvbSBrb3N0bmFkIGFra3VtdWxlcmVzLiBEZXQgZXIgZmlyZSBraWxkZWthcmFrdGVyaXN0aWtrZXIgc29tIGthbiBicnVrZXMuIEthcmFrdGVyaXN0aWtrZW5lIHNvbSBrYW4gdsOmcmUgZm9yIGtpbGRlbmUsIGVsbGVyIGRlIHJlaXNlbmRlIGZyYSBraWxkZW5lLCBzdHlyZXMgYXYgYmVzdGVtdGUgcGFyYW1ldGVyZTogMS4gRsO4cnN0ZSBha2t1bXVsZXJpbmc64oCvYW5naXIgZGVuIG9wcHJpbm5lbGlnZSBrb3N0bmFkZW4gZsO4ciBiZXZlZ2Vsc2VuIGJlZ3lubmVyLiAyLiBNYWtzaW1hbCBha2t1bXVsZXJpbmc64oCvYW5naXIgaHZvciBzdG9yIGtvc3RuYWQgZW4ga2lsZGUga2FuIGFra3VtdWxlcmUgZsO4ciBkZW4gbsOlciBncmVuc2VuLiAzLiBNdWx0aXBsaWthdG9yIHNvbSBza2FsIGJydWtlcyBww6Uga29zdG5hZGVyOuKAr2FuZ2lyIHJlaXNlbcOldGVuIGVsbGVyIHN0w7hycmVsc2VuIHZlZCBraWxkZW4uIDQuIFJlaXNlcmV0bmluZzrigK9pZGVudGlmaXNlcmVyIG9tIGRlbiByZWlzZW5kZSBzdGFydGVyIHZlZCBlbiBraWxkZSBvZyBiZXZlZ2VyIHNlZyB0aWwgaWtrZS1raWxkZS1sb2thc2pvbmVyLCBlbGxlciBvbSBkZW4gc3RhcnRlciBww6UgaWtrZS1raWxkZS1sb2thc2pvbmVyIG9nIGJldmVnZXIgc2VnIHRpbGJha2UgdGlsIGVuIGtpbGRlLjxkaXY+PGJyLz5Tb20gc3RhbmRhcmQgZXIgcmVzdWx0YXRldCBhdiBEaXN0YW5jZSBBY2N1bXVsYXRpb24tZnVua3Nqb25lbiBldCBlbmtlbHRiw6VuZCwgc29tIGVyIHJhc3RlcmV0IGZvciBhdnN0YW5kc2Fra3VtdWxlcmluZy4gRGV0IGthbiBvZ3PDpSBvcHByZXR0ZXMgZXQgYsOlbmQgdGlsLCBiw6VuZGV0IGZvciB0aWxiYWtlcmV0bmluZy4gRGV0dGUgYsOlbmRldCB2aXNlciBodmlsa2VuIHJldG5pbmcgbWFuIG3DpSB0YSBmb3Igw6Uga29tbWUgdGlsIGtpbGRlbiBtZWQgbGF2ZXN0IGtvc3RuYWQgZnJhIGh2ZXIgbG9rYXNqb24gaSBzdHVkaWVvbXLDpWRldC4gQmVnZ2UgYsOlbmRlbmUgZXIgbsO4ZHZlbmRpZ2UgZm9yIMOlIGZpbm5lIG9wdGltYWxlIHJ1dGVyIGlubmVuZm9yIHN0dWRpZW9tcsOlZGV0LiBGb3Igw6UgZ2VuZXJlcmUgZW4gcnV0ZSBicnVrZXIgZHUgZsO4cnN0IEV4dHJhY3QgQmFuZHMtZnVua3Nqb25lbiB0aWwgw6UgdHJla2tlIHV0IHJhc3RlcmV0IGZvciBhdnN0YW5kc2Fra3VtdWxlcmluZyBvZyByYXN0ZXJldCBmb3IgdGlsYmFrZXJldG5pbmcuIEJydWtlIGRpc3NlIGxhZ2VuZSBzb20gaW5uZGF0YSBmb3IgS29zdG5hZHNydXRlLWZ1bmtzam9uZW4uIE1lZCBkZW5uZSBmdW5rc2pvbmVuIGJydWtlciBkdSByYXN0ZXJldCBmb3IgYXZzdGFuZHNha2t1bXVsZXJpbmcgc29tIGtvc3RuYWQtL2F2c3RhbmRzcmFzdGVyIG9nIHJhc3RlcmV0IGZvciB0aWxiYWtlcmV0bmluZyBzb20gQ29zdCBCYWNrIExpbmstaW5uZGF0YXJhc3Rlci48L2Rpdj5cIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25OYW1lOiBcIkRpc3RhbmNlIEFsbG9jYXRpb25cIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25TbmlwOiBcIkJlcmVnbmVyIGF2c3RhbmRzdGlsZGVsaW5nIGZvciBodmVyIGNlbGxlIHRpbCBkZSBvcHBnaXR0ZSBraWxkZW5lIGJhc2VydCBww6UgcmV0dGxpbmpldCBhdnN0YW5kLCBrb3N0bmFkc2F2c3RhbmQsIHJlZWxsIG92ZXJmbGF0ZWF2c3RhbmQsIHNhbXQgdmVydGlrYWxlIG9nIGhvcmlzb250YWxlIGtvc3RuYWRzZmFrdG9yZXIuXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uRGVzYzogXCJEaXN0YW5jZSBBbGxvY2F0aW9uIGJlcmVnbmVyIGh2aWxrZW4ga2lsZGUgaHZlciBsb2thc2pvbiBpIHN0dWRpZW9tcsOlZGV0IGVyIHRpbGRlbHQgdGlsLiBIdmlzIGt1biBraWxkZW5lIG9wcGdpcyBzb20gaW5uZGF0YSwgYmxpciBsb2thc2pvbmVuZSB0aWxkZWx0IHZlZCBoamVscCBhdiBlbiByZXR0bGluamV0IGF2c3RhbmQgdGlsIGRlbiBuw6ZybWVzdGUga2lsZGVuLiBIdmlzIGLDpWRlIGtpbGRlciBvZyBoaW5kcmluZ2VyIGJydWtlcyBzb20gaW5uZGF0YSwgYmVyZWduZXIgRGlzdGFuY2UgQWxsb2NhdGlvbi1mdW5rc2pvbmVuIHJldHRsaW5qZXQgYXZzdGFuZCBydW5kdCBoaW5kcmluZ2VyIGZvciDDpSBmYXN0c2V0dGUgaHZpbGtlbiBraWxkZSBlbiBsb2thc2pvbiBibGlyIHRpbGRlbHQgdGlsLiBGb3IgYsOlZGUga2lsZGVyYXN0ZXJldCBvZyBoaW5kcmluZ3NyYXN0ZXJldCBza2FsIGJha2dydW5uc3ZlcmRpZW4gdsOmcmUgTm9EYXRhLCBtZW5zIGtpbGRlciBvZyBoaW5kcmluZ2VyIHJlcHJlc2VudGVyZXMgbWVkIGd5bGRpZ2UgY2VsbGV2ZXJkaWVyLiBHeWxkaWdlIGNlbGxldmVyZGllciBvbWZhdHRlciBudWxsLjxkaXY+PGJyLz5IdmlzIGR1IHZpbCB1dGbDuHJlIGtvc3RuYWRzYW5hbHlzZSB2ZWQgaGplbHAgYXYgRGlzdGFuY2UgQWxsb2NhdGlvbi1mdW5rc2pvbmVuLCBtw6UgZHUgaGEgZW4ga29zdG5hZHNvdmVyZmxhdGUuIEh2aXMgZW4ga29zdG5hZHNvdmVyZmxhdGUgb3BwZ2lzLCBibGlyIHJlc3VsdGF0ZXQgZXQgdGlsZGVsaW5nc3Jhc3RlciBiYXNlcnQgcMOlIGFra3VtdWxlcnQga29zdG5hZCBvZyBpa2tlIHDDpSByZXR0bGluamV0IGF2c3RhbmQuIE7DpXIgaG9yaXNvbnRhbGUgb2cgdmVydGlrYWxlIGZha3RvcmVyIGVyIG9wcGdpdHQsIGJsaXIgcmV0bmluZyB2dXJkZXJ0IGV0dGVyIGh2ZXJ0IHNvbSBrb3N0bmFkIGFra3VtdWxlcmVzLiBOw6VyIGV0IG92ZXJmbGF0ZXJhc3RlciBicnVrZXMgc29tIGlubmRhdGEsIGJsaXIgZGVuIGZha3Rpc2tlIG92ZXJmbGF0ZWF2c3RhbmRlbiBzb20gZGVra2VzIG7DpXIgbWFuIGJldmVnZXIgc2VnIG1lbGxvbSBjZWxsZW5lLCBiZXJlZ25ldCB2ZWQgZmFzdHNldHRlbHNlIGF2IHRpbGRlbGluZy4gRGV0IGVyIGZpcmUga2lsZGVrYXJha3RlcmlzdGlra2VyIHNvbSBrYW4gYnJ1a2VzLiBLYXJha3RlcmlzdGlra2VuZSBzb20ga2FuIHbDpnJlIGZvciBraWxkZW5lLCBlbGxlciBkZSByZWlzZW5kZSBmcmEga2lsZGVuZSwgc3R5cmVzIGF2IGJlc3RlbXRlIHBhcmFtZXRlcmU6IDEuIEbDuHJzdGUgYWtrdW11bGVyaW5nOuKAr2FuZ2lyIGRlbiBvcHByaW5uZWxpZ2Uga29zdG5hZGVuIGbDuHIgYmV2ZWdlbHNlbiBiZWd5bm5lci4gMi4gTWFrc2ltYWwgYWtrdW11bGVyaW5nOuKAr2FuZ2lyIGh2b3Igc3RvciBrb3N0bmFkIGVuIGtpbGRlIGthbiBha2t1bXVsZXJlIGbDuHIgZGVuIG7DpXIgZ3JlbnNlbi4gMy4gTXVsdGlwbGlrYXRvciBzb20gc2thbCBicnVrZXMgcMOlIGtvc3RuYWRlcjrigK9hbmdpciByZWlzZW3DpXRlbiBlbGxlciBzdMO4cnJlbHNlbiB2ZWQga2lsZGVuLiA0LiBSZWlzZXJldG5pbmc64oCvaWRlbnRpZmlzZXJlciBvbSBkZW4gcmVpc2VuZGUgc3RhcnRlciB2ZWQgZW4ga2lsZGUgb2cgYmV2ZWdlciBzZWcgdGlsIGlra2Uta2lsZGUtbG9rYXNqb25lciwgZWxsZXIgb20gZGVuIHN0YXJ0ZXIgcMOlIGlra2Uta2lsZGUtbG9rYXNqb25lciBvZyBiZXZlZ2VyIHNlZyB0aWxiYWtlIHRpbCBlbiBraWxkZS48ZGl2Pjxici8+U29tIHN0YW5kYXJkIGVyIHJlc3VsdGF0ZXQgYXYgRGlzdGFuY2UgQWxsb2NhdGlvbi1mdW5rc2pvbmVuIGV0IGVua2VsdGLDpW5kLCBzb20gZXIgcmFzdGVyZXQgZm9yIGF2c3RhbmRzdGlsZGVsaW5nLiBIdmlzIGRldCBtZXJrZXMgYXYgZm9yIGRldCBib29sc2tlIGFsdGVybmF0aXZldCBHZW5lcmVyIGtpbGRlcmFkIG9nIC1rb2xvbm5lIHNvbSBla3N0cmEgYsOlbmQgaSB1dGRhdGEsIGdpciBkZXQgZXQgZmxlcmLDpW5kc3Jhc3RlciBzb20gYmVzdMOlciBhdiB0cmUgYsOlbmQuIERldCBmw7hyc3RlIGLDpW5kZXQgZXIgYsOlbmRldCBmb3IgYXZzdGFuZHN0aWxkZWxpbmcsIGRldCBhbmRyZSBiw6VuZGV0IGlubmVob2xkZXIgZW4gcmFkaW5kZWtzLCBvZyBkZXQgdHJlZGplIGLDpW5kZXQgaW5uZWhvbGRlciBlbiBrb2xvbm5laW5kZWtzLiBEaXNzZSBpbmRla3NlbmUgaWRlbnRpZmlzZXJlciBsb2thc2pvbmVuIGZvciBraWxkZWNlbGxlbiBzb20gZXIgbWluc3RlIGFra3VtdWxlcnRlIGtvc3RuYWRzYXZzdGFuZCBmcmEuIEtpbGRlcmFkaW5kZWtzZW4gb2cga2lsZGVrb2xvbm5laW5kZWtzZW4ga2FuIGJydWtlcyBzYW1tZW4gdGlsIMOlIGthcnRsZWdnZSBpbnRlbnNpdGV0LiBIdmlzIGR1IGZvcmV0YXIgc3DDuHJyaW5nIGZvciBlbiBsb2thc2pvbiBpIHN0dWRpZW9tcsOlZGV0IHDDpSB0dmVycyBhdiBiw6VuZCB0byBvZyB0cmUsIGbDpXIgZHUgdml0ZSByYWRlbiBvZyBrb2xvbm5lbiBmb3Iga2lsZGVuIG1lZCBsYXZlc3Qga29zdG5hZCBmb3IgZGVubmUgbG9rYXNqb25lbi48L2Rpdj5cIixcblx0XHRldWNCYWNrRGlyZWN0aW9uTmFtZTogXCJFdWNsaWRlYW4gQmFjayBEaXJlY3Rpb25cIixcblx0XHRldWNCYWNrRGlyZWN0aW9uU25pcDogXCJCZXJlZ25lciByZXRuaW5nZW4gaSBncmFkZXIgZm9yIGh2ZXIgY2VsbGUgdGlsIG5hYm9jZWxsZW4gbGFuZ3MgZGVuIGtvcnRlc3RlIHZlaWVuIHRpbGJha2UgdGlsIG7DpnJtZXN0ZSBraWxkZSBvZyBzYW10aWRpZyBzb20gaGluZHJpbmdlciB1bm5nw6VzLlwiLFxuXHRcdGV1Y0JhY2tEaXJlY3Rpb25EZXNjOiBcIkZ1bmtzam9uZW4gRXVjbGlkZWFuIEJhY2sgRGlyZWN0aW9uIHJlc3VsdGVyZXIgaSBldCBrb250aW51ZXJsaWcgZmx5dHB1bmt0cmFzdGVyIHNvbSByZXByZXNlbnRlcmVyIHJldG5pbmdlbiBpIGdyYWRlciB0aWxiYWtlIHRpbCBuw6ZybWVzdGUga2lsZGUgc2FtdGlkaWcgc29tIGhpbmRyaW5nZXIgdW5uZ8OlcywgaHZpcyBoaW5kcmluZ2VyIGVyIG9wcGdpdHQuPGRpdj48YnIvPklubmRhdGFlbmUgZm9yIGZ1bmtzam9uZW4gRXVjbGlkZWFuIEJhY2sgRGlyZWN0aW9uIGVyIGtpbGRlbiBzb20gcmV0bmluZ2VuIGJlcmVnbmVzIHRpbC4gRXQgcmFzdGVyIHNvbSByZXByZXNlbnRlcmVyIGhpbmRyaW5nZXIgaW5uZW5mb3Igc3R1ZGllb21yw6VkZXQsIGVyIHZhbGdmcml0dCBpbm5kYXRhYWx0ZXJuYXRpdi4gQmFrZ3J1bm5zdmVyZGllbiBza2FsIHbDpnJlIE5vRGF0YSBmb3IgYsOlZGUga2lsZGVyYXN0ZXJldCBvZyBoaW5kcmluZ3Jhc3RlcmV0LCBtZW5zIGtpbGRlbmUgb2cgaGluZHJpbmdlbmUgcmVwcmVzZW50ZXJlcyBtZWQgZ3lsZGlnZSB2ZXJkaWVyLiBHeWxkaWdlIGNlbGxldmVyZGllciBvbWZhdHRlciBudWxsLiBTb20gc3RhbmRhcmQgdmlsIGJlcmVnbmluZ2VuIGJlaGFuZGxlIHRpbCBkZW4ga29tYmluZXJ0ZSB1dHN0cmVrbmluZ2VuIGZvciBraWxkZXIgb2cgaGluZHJpbmdlciwgcGx1c3MgdG8gcmFkZXIgb2cga29sb25uZXIuIEh2aXMgYW5hbHlzZSBrdW4gZXIgbsO4ZHZlbmRpZyBpbm5lbmZvciBlbiBhbmdpdHQgYXZzdGFuZCBmcmEga2lsZGVuZSwga2FuIHBhcmFtZXRlcmVuIE1heGltdW0gRGlzdGFuY2UgYnJ1a2VzLiBFdWNsaWRlYW4gQmFjayBEaXJlY3Rpb24gc3TDuHR0ZXIgYmVyZWduaW5nIG1lZCBiw6VkZSBlbiBwbGFubWV0b2RlIG9nIGVuIGdlb2RldGlzayBtZXRvZGUuIE1lZCBwbGFubWV0b2RlbiBmb3JldGFzIGJlcmVnbmluZ2VuIHDDpSBldCBwcm9qaXNlcnQgZmxhdHQgcGxhbiB2ZWQgaGplbHAgYXYgZXQgMkQga2FydGVzaXNrIGtvb3JkaW5hdHN5c3RlbS4gTWVkIGRlbiBnZW9kZXRpc2tlIG1ldG9kZW4gZm9yZXRhcyBiZXJlZ25pbmdlbiBww6UgZWxsaXBzb2lkZW4sIG5vZSBzb20gYmV0eXIgYXQgcmVzdWx0YXRlbmUgaWtrZSBlbmRyZXMgdWF2aGVuZ2lnIGF2IGlubmRhdGEtIGVsbGVyIHV0ZGF0YXByb2ppc2VyaW5nLjxkaXY+PGJyLz5SZXN1bHRhdGV0IGF2IGZ1bmtzam9uZW4gRXVjbGlkZWFuIEJhY2sgRGlyZWN0aW9uIGthbiBicnVrZXMgc2FtbWVuIG1lZCByZXN1bHRhdGV0IGZyYSBmdW5rc2pvbmVuIEV1Y2xpZGVhbiBEaXN0YW5jZSB0aWwgw6UgZmFzdHNldHRlIGRlIGtvcnRlc3RlIHJ1dGVuZSBmcmEgbG9rYXNqb25lciBpbm5lbmZvciBzdHVkaWVvbXLDpWRldCB0aWxiYWtlIHRpbCBraWxkZW4uIFJlc3VsdGF0ZW5lIGZyYSBFdWNsaWRlYW4gQmFjayBEaXJlY3Rpb24gb2cgRXVjbGlkZWFuIERpc3RhbmNlIGJydWtlcyBiZWdnZSBzYW1tZW4gbWVkIGRlc3RpbmFzam9uZXIgaSBDb3N0IFBhdGgtZnVua3Nqb25lbiBmb3Igw6UgZ2VuZXJlcmUgZGUga29ydGVzdGUgcnV0ZW5lLjwvZGl2PlwiLFxuXHRcdGV4cGFuZE5hbWU6IFwiVXR2aWRcIixcblx0XHRleHBhbmRTbmlwOiBcIlV0dmlkZXIgdmFsZ3RlIHNvbmVyIGkgZXQgcmFzdGVyIGV0dGVyIHNvbmVyIG1lZCBldCBhbmdpdHQgYW50YWxsIGNlbGxlci5cIixcblx0XHRleHBhbmREZXNjOiBcIk1lZCBkZW4gZ2xvYmFsZSBmdW5rc2pvbmVuIGZvciB1dHZpZGVsc2Uga2FuIGR1IGdlbmVyYWxpc2VyZSwgZWxsZXIgZm9yZW5rbGUsIHJhc3RyZW5lIHZlZCDDpSBnasO4cmUgYmVzdGVtdGUgc29uZXIgc3TDuHJyZS4gRHUga2FuIG9nc8OlIGJlc3RlbW1lIG9tZmFuZ2V0IGF2IGdlbmVyYWxpc2VyaW5nZW4uPGRpdj48YnIvPlNvbmVuZSBkdSB2ZWxnZXIgdmlsIMO4a2UgaSBzdMO4cnJlbHNlIHZlZCBhdCBkZSB1dHZpZGVzIGlubiBpIGFuZHJlIHNvbmVyLiBEZSB2YWxndGUgc29uZXZlcmRpZW5lIGthbiB2aXNlcyBzb20gc29uZXIgaSBmb3JncnVubmVuLCBtZW5zIGRlIGFuZHJlIHZlcmRpZW5lIGJlaG9sZGVzIHNvbSBzb25lciBpIGJha2dydW5uZW4uIFNvbmVuZSBpIGZvcmdydW5uZW4ga2FuIHV0dmlkZXMgaW5uIGkgc29uZW5lIGkgYmFrZ3J1bm5lbi48ZGl2Pjxici8+T21mYW5nZXQgYXYgZ2VuZXJhbGlzZXJpbmdlbiBrYW4gc3R5cmVzIG1lZCBwYXJhbWV0ZXJlbiBBbnRhbGwgY2VsbGVyLiBEZW5uZSB2ZXJkaWVuIGVyIHNvbSBzdGFuZGFyZCAxLCBub2Ugc29tIGJldHlyIGF0IGRlIHZhbGd0ZSBzb25lbmUgdXR2aWRlcyBtZWQgbWVuZ2RlbiB0aWxzdmFyZW5kZSDDqW4gY2VsbGVzIHN0w7hycmVsc2UuIER1IGthbiBhbmdpIGVuIHN0w7hycmUgdmVyZGkgZm9yIGRlbm5lIHBhcmFtZXRlcmVuIGZvciDDpSDDuGtlIGdyYWRlbiBhdiBnZW5lcmFsaXNlcmluZy4gRGV0dGUgYmxpciBzb20gw6Uga2rDuHJlIHZlcmt0w7h5ZXQgbGlrZSBtYW5nZSBnYW5nZXIgc29tIGFuZ2l0dCB0YWxsLCBtZWQgcmVzdWx0YXRlbmUgYXYgZm9ycmlnZSBrasO4cmluZyBzb20gaW5uZGF0YSBpIGV0dGVyZsO4bGdlbmRlIGdqZW50YWtlbHNlLjwvZGl2PlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNOYW1lOiBcIkdlbmVyYXRlIFRyZW5kXCIsXG5cdFx0dHJlbmRBbmFseXNpc1NuaXA6IFwiRXN0aW1lcmVyIHRyZW5kZW4gZm9yIGh2ZXIgcGlrc2VsIGxhbmdzIGVuIGRpbWVuc2pvbiBmb3Igw6luIGVsbGVyIGZsZXJlIHZhcmlhYmxlciBpIGV0IGZsZXJkaW1lbnNqb25hbHQgcmFzdGVyLlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNEZXNjOiBcIjxkaXY+RGVubmUgZnVua3Nqb25lbiBrYW4gYnJ1a2VzIHRpbCDDpSBwbGFzc2VyZSBkYXRhIGxhbmdzIGVuIGxpbmXDpnIsIGhhcm1vbmlzayBlbGxlciBwb2x5bm9tIHRyZW5kbGluamUsIGVsbGVyIGRlbiBrYW4gYnJ1a2VzIHRpbCDDpSB1dGbDuHJlIHRyZW5kZGV0ZWtzam9uIHZlZCBoamVscCBhdiBlbiBNYW5uLUtlbmRhbGwtIGVsbGVyIFNlYXNvbmFsIEtlbmRhbGwtdGVzdC48L2Rpdj48YnI+PGRpdj5EZXQgcmVzdWx0ZXJlbmRlIHRyZW5kcmFzdGVyZXQgc29tIGdlbmVyZXJlcyBtZWQgZGVubmUgZnVua3Nqb25lbiwgYnJ1a2VzIHNvbSBpbm5kYXRhIHRpbCBmdW5rc2pvbmVuIDxzdHJvbmc+Rm9ydXRzaSB2ZWQgYnJ1ayBhdiB0cmVuZDwvc3Ryb25nPi48L2Rpdj48YnI+PGRpdj5NYW5uLUtlbmRhbGwtb2cgU2Vhc29uYWwtS2VuZGFsbC10ZXN0ZW5lIGJydWtlcyB0aWwgw6UgYmVzdGVtbWUgb20gZGV0IGVyIGVuIG1vbm90b24gdHJlbmQgaSBkYXRhZW5lLiBEZSBlciBpa2tlLXBhcmFtZXRyaXNrZSwgZGV0IHZpbCBzaSBhdCBkZSBpa2tlIGZvcnV0c2V0dGVyIGVuIGJlc3RlbXQgZGlzdHJpYnVzam9uIGF2IGRhdGEuIE1hbm4tS2VuZGFsbC10ZXN0ZW4gdnVyZGVyZXIgaWtrZSBzZXJpZWxsIGtvcnJlbGFzam9uIGVsbGVyIMOlcnN0aWRzZWZmZWt0ZXIuIEh2aXMgZGF0YWVuZSBlciDDpXJzdGlkc2JldGluZ2VkZSwgZXIgU2Vhc29uYWwtS2VuZGFsbC10ZXN0ZW4gYmVkcmUgZWduZXQuPC9kaXY+PGJyPjxkaXY+SHZpcyB2ZXJrdMO4eWV0IGJydWtlcyB0aWwgw6UgdXRmw7hyZSBlbnRlbiBlbiBNYW5uLUtlbmRhbGwtIGVsbGVyIGVuIFNlYXNvbmFsLUtlbmRhbGwtdGVzdCwgYmxpciByZXN1bHRhdGV0IGV0IHJhc3RlciBtZWQgZmVtIGLDpW5kLCBzb20gZsO4bGdlcjo8L2Rpdj48dWw+PGxpPkLDpW5kIDEgPSBTZW5zIGhlbGxpbmc8L2xpPjxsaT5Cw6VuZCAyID0gUC12ZXJkaTwvbGk+PGxpPkLDpW5kIDMgPSBNYW5uLUtlbmRhbGwtc2vDpXIgKFMpPC9saT48bGk+QsOlbmQgNCA9IFMtdmFyaWFuczwvbGk+PGxpPkLDpW5kIDQgPSBTLXZhcmlhbnM8L2xpPjxsaT5Cw6VuZCA1ID0gWi1za8OlcjwvbGk+PC91bD48ZGl2PlJlc3VsdGF0ZW5lIGZyYSBNYW5uLUtlbmRhbGwtIGVsbGVyIFNlYXNvbmFsLUtlbmRhbGwtdGVzdGVuIGthbiBicnVrZXMgdGlsIMOlIGJlc3RlbW1lIGh2aWxrZSBwaWtzbGVyIGkgZGVuIGZsZXJkaW1lbnNqb25hbGUgdGlkc3NlcmllbiBzb20gaGFyIGVuIHN0YXRpc3Rpc2sgc2lnbmlmaWthbnQgdHJlbmQuIERlbm5lIGluZm9ybWFzam9uZW4ga2FuIGR1IGJydWtlIHNhbW1lbiBtZWQgZGVuIGxpbmXDpnJlLCBoYXJtb25pc2tlIGVsbGVyIHBvbHlub21lIHRyZW5kYW5hbHlzZW4gZm9yIMOlIHRyZWtrZSB1dCBzaWduaWZpa2FudGUgdHJlbmRlciBpIHRpZHNzZXJpZW4uIER1IGthbiBnZW5lcmVyZSBlbiBtYXNrZSBzb20gaW5rbHVkZXJlciBwaWtzbGVyIG1lZCBzaWduaWZpa2FudGUgcC12ZXJkaWVyLCBicnVrZSBtYXNrZW4gcMOlIGRldCBmbGVyZGltZW5zam9uYWxlIHJhc3RlcmV0IG9nIGJydWtlIGRldHRlIG1hc2tlcnRlIGZsZXJkaW1lbnNqb25hbGUgcmFzdGVyZXQgc29tIGlubmRhdGEgaSB2ZXJrdMO4eWV0IGZvciDDpSB1dGbDuHJlIGxpbmXDpnIsIGhhcm1vbmlzayBlbGxlciBwb2x5bm9tIHRyZW5kYW5hbHlzZS48L2Rpdj48YnI+PGRpdj5EZXQgZXIgdHJlIHRyZW5kbGluamVhbHRlcm5hdGl2ZXIgZm9yIMOlIHRpbHBhc3NlIGVuIHRyZW5kIHRpbCB2YXJpYWJlbHZlcmRpZW5lIGxhbmdzIGVuIGRpbWVuc2pvbjogbGluZcOmciwgcG9seW5vbSBvZyBoYXJtb25pc2suPC9kaXY+PGJyPjxkaXY+Rm9yIGxpbmXDpnIgdHJlbmRhbmFseXNlIGVyIHJlc3VsdGF0ZXQgZXQgcmFzdGVyIG1lZCB0cmUgYsOlbmQsIHNvbSBmw7hsZ2VyOjwvZGl2Pjx1bD48bGk+QsOlbmQgMSA9IEhlbGxpbmc8L2xpPjxsaT5Cw6VuZCAyID0gQXZza2rDpnJpbmc8L2xpPjxsaT5Cw6VuZCAzID0gS3ZhZHJhdHJvdCBhdiBnamVubm9tc25pdHQgKFJNU0UsIFJvb3QgTWVhbiBTcXVhcmUgRXJyb3IpIGVsbGVyIGZlaWxlbiBydW5kdCBsaW5qZW4gbWVkIGJlc3QgdGlscGFzbmluZzwvbGk+PC91bD48ZGl2PkZvciBwb2x5bm9tIHRyZW5kYW5hbHlzZSBhdmhlbmdlciBkZXQgcmVzdWx0ZXJlbmRlIGFudGFsbGV0IGLDpW5kIGF2IHBvbHlub21ncmFkZW4uIFRpbHBhc25pbmcgYXYgYW5kcmVncmFkc3BvbHlub21lciBwcm9kdXNlcmVyIGV0IHJhc3RlciBtZWQgZmlyZSBiw6VuZCwgc29tIGbDuGxnZXI6PC9kaXY+PHVsPjxsaT5Cw6VuZCAxID0gUG9seW5vbV8yPC9saT48bGk+QsOlbmQgMiA9IFBvbHlub21fMTwvbGk+PGxpPkLDpW5kIDMgPSBQb2x5bm9tXzA8L2xpPjxsaT5Cw6VuZCA0ID0gUk1TRTwvbGk+PC91bD48ZGl2PlRpbHBhc25pbmcgYXYgdHJlZGplZ3JhZHNwb2x5bm9tZXIgcHJvZHVzZXJlciBldCByYXN0ZXIgbWVkIGZlbSBiw6VuZCwgc29tIGbDuGxnZXI6PC9kaXY+PHVsPjxsaT5Cw6VuZCAxID0gUG9seW5vbV8zPC9saT48bGk+QsOlbmQgMiA9IFBvbHlub21fMjwvbGk+PGxpPkLDpW5kIDMgPSBQb2x5bm9tbF8xPC9saT48bGk+QsOlbmQgNCA9IFBvbHlub21fMDwvbGk+PGxpPkLDpW5kIDUgPSBSTVNFPC9saT48L3VsPjxkaXY+Rm9yIGhhcm1vbmlzayB0cmVuZGFuYWx5c2UgYXZoZW5nZXIgZGV0IHJlc3VsdGVyZW5kZSBhbnRhbGxldCBiw6VuZCBhdiBkZW4gaGFybW9uaXNrZSBmcmVrdmVuc2VuLiBOw6VyIGZyZWt2ZW5zZW4gZXIgc2F0dCB0aWwgMSwgYmxpciByZXN1bHRhdGV0IGV0IHJhc3RlciBtZWQgZmVtIGLDpW5kLCBzb20gZsO4bGdlcjo8L2Rpdj48dWw+PGxpPkLDpW5kIDEgPSBIZWxsaW5nPC9saT48bGk+QsOlbmQgMiA9IEF2c2tqw6ZyaW5nPC9saT48bGk+QsOlbmQgMyA9IEhhcm1vbmlza19zaW4xPC9saT48bGk+QsOlbmQgNCA9IEhhcm1vbmlza19jb3MxPC9saT48bGk+QsOlbmQgNSA9IFJNU0U8L2xpPjwvdWw+PGRpdj5Ow6VyIGZyZWt2ZW5zZW4gZXIgc2F0dCB0aWwgMiwgYmxpciByZXN1bHRhdGV0IGV0IHJhc3RlciBtZWQgc2p1IGLDpW5kLCBzb20gZsO4bGdlcjo8L2Rpdj48dWw+PGxpPkLDpW5kIDEgPSBIZWxsaW5nPC9saT48bGk+QsOlbmQgMiA9IEF2c2tqw6ZyaW5nPC9saT48bGk+QsOlbmQgMyA9IEhhcm1vbmlza19zaW4xPC9saT48bGk+QsOlbmQgNCA9IEhhcm1vbmlza19jb3MxPC9saT48bGk+QsOlbmQgNSA9IEhhcm1vbmlza19zaW4yPC9saT48bGk+QsOlbmQgNiA9IEhhcm1vbmlza19jb3MyPC9saT48bGk+QsOlbmQgNyA9IFJNU0U8L2xpPjwvdWw+PGRpdj5QYXJhbWV0ZXJlbiA8c3Ryb25nPkxlbmdkZSBww6Ugc3lrbHVzPC9zdHJvbmc+IGZvciBoYXJtb25pc2sgdHJlbmRhbmFseXNlIGJydWtlcyB0aWwgw6UgYW5naSBhbnRhbGwgb2cgbGVuZ2RlIHDDpSBzeWtsdXNlciBkdSB2ZW50ZXIgw6Ugc2UgaSBkYXRhZW5lIGRpbmUgaSBsw7hwZXQgYXYgZW4gZGFnIGVsbGVyIGV0IMOlci4gSHZpcyBkdSBmb3IgZWtzZW1wZWwgdmVudGVyIGF0IGRhdGFlbmUgc2thbCBnamVubm9tZ8OlIHRvIHZhcmlhc2pvbnNzeWtsdXNlciBpIGzDuHBldCBhdiBldCDDpXIsIGVyIGxlbmdkZW4gcMOlIHN5a2x1c2VuIDE4Miw1IGRhZ2VyIGVsbGVyIDAsNSDDpXIuIEh2aXMgZHUgaGFyIHRlbXBlcmF0dXJkYXRhIHNvbSBlciBpbm5oZW50ZXQgaHZlciB0cmVkamUgdGltZSwgb2cgZGV0IGVyIMOpbiB2YXJpYXNqb25zc3lrbHVzIHBlciBkYWcsIGVyIGxlbmdkZW4gcMOlIHN5a2x1c2VuIMOpbiBkYWcuPC9kaXY+PGJyPjxkaXY+UGFyYW1ldGVyZW4gPHN0cm9uZz5GcmVrdmVuczwvc3Ryb25nPiBmb3IgaGFybW9uaXNrIHRyZW5kYW5hbHlzZSBicnVrZXMgdGlsIMOlIGJlc2tyaXZlIGRlbiBoYXJtb25pc2tlIG1vZGVsbGVuIHNvbSBza2FsIHRpbHBhc3NlcyBkYXRhZW5lLiBIdmlzIGZyZWt2ZW5zZW4gc2V0dGVzIHRpbCAxLCBicnVrZXMgZW4ga29tYmluYXNqb24gYXYgbGluw6ZyIG9nIGbDuHJzdGVncmFkcyBoYXJtb25pc2sga3VydmUgZm9yIMOlIHBhc3NlIHRpbCBtb2RlbGxlbi4gSHZpcyBmcmVrdmVuc2VuIHNldHRlcyB0aWwgMiwgYnJ1a2VzIGVuIGtvbWJpbmFzam9uIGF2IGxpbsOmciwgZsO4cnN0ZWdyYWRzIGhhcm1vbmlzayBrdXJ2ZSBvZyBhbmRyZWdyYWRzIGhhcm1vbmlzayBrdXJ2ZSBmb3Igw6UgcGFzc2UgdGlsIG1vZGVsbGVuLiBIdmlzIGZyZWt2ZW5zZW4gZXIgMywgYnJ1a2VzIHl0dGVybGlnZXJlIGVuIHRyZWRqZWdyYWRzIGhhcm1vbmlzayBrdXJ2ZSBmb3Igw6UgbW9kZWxsZXJlIGRhdGFlbmUsIG9nIHPDpSB2aWRlcmUuPC9kaXY+PGJyPjxkaXY+U3RhdGlzdGlrayBzb20gdmlzZXIgbW9kZWxsZW5zIGdvZGhldCwga2FuIGdlbmVyZXJlcyBzb20gdmFsZ2ZyaWUgdXRkYXRhLiBLdmFkcmF0cm90IGF2IGdqZW5ub21zbml0dCAoUk1TRSksIGRldGVybWluYW50a29lZmZpc2llbnQgb2cgcC12ZXJkaWVuIGZvciB0cmVuZGhlbGxpbmcga2FuIGJlcmVnbmVzIG9nIHZpc2VzIG1lZCBzeW1ib2xlci4gT3BwcmV0dCBzeW1ib2xlciBmb3IgZGV0IHJlc3VsdGVyZW5kZSB0cmVuZHJhc3RlcmxhZ2V0IHZlZCBoamVscCBhdiA8c3Ryb25nPlJHQjwvc3Ryb25nPi1zeW1ib2xvZ2kgb2cgYW5naSBzdGF0aXN0aWtrZW4gc29tIHLDuGRlLCBncsO4bm5lIG9nIGJsw6UgYsOlbmQuPC9kaXY+PGJyPlwiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdOYW1lOiBcIkxpbmVhciBTcGVjdHJhbCBVbm1peGluZ1wiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdTbmlwOiBcIlV0ZsO4cmVyIHN1YnBpa3NlbGtsYXNzaWZpc2VyaW5nLCBvZyBiZXJlZ25lciBhbmRlbGVuIGF2IHVsaWtlIGFyZWFsZGVra2V0eXBlciBmb3IgaW5kaXZpZHVlbGxlIHBpa3NsZXIuXCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ0Rlc2M6IFwiRnVua3Nqb25lbiBMaW5lYXIgU3BlY3RyYWwgVW5taXhpbmcgYmVyZWduZXIgYW5kZWxlbiBmb3IgaW5kaXZpZHVlbGxlIHBpa3NsZXIgc29tIGlubmVob2xkZXIgZmxlcmUgYXJlYWxkZWtrZXR5cGVyLiBHZW5lcmVyZXIgZXQgbGFnIG1lZCBmbGVyZSBiw6VuZCwgZGVyIGh2ZXJ0IGxhZyB0aWxzdmFyZXIgYW5kZWxlbiBhdiBodmVyIGVua2VsdCBhcmVhbGRla2tla2xhc3NlLiBEdSBrYW4gZm9yIGVrc2VtcGVsIGJydWtlIGRlbiB0aWwgw6UgdXRmw7hyZSBrbGFzc2lmaXNlcmluZyBhdiBhcmVhbGRla2tlIHDDpSBldCBtdWx0aXNwZWt0cmFsdCBiaWxkZSBmb3Igw6UgaWRlbnRpZmlzZXJlIGZvdG9zeW50ZXRpc2sgdmVnZXRhc2pvbiwgYmFyIGpvcmQgb2cgZMO4ZCBlbGxlciBpa2tlLWZvdG9zeW50ZXRpc2sgdmVnZXRhc2pvbi48ZGl2Pjxici8+UmVra2Vmw7hsZ2VuIGZvciB1dGRhdGFyYXN0ZXJldCBtZWQgZmxlcmUgYsOlbmQgZsO4bGdlciByZWtrZWbDuGxnZW4gZm9yIHNwZWt0cmFscHJvZmlsZW4gc29tIGVyIGlubmRhdGEuIEFudGFsbCBrbGFzc2VyIGthbiBpa2tlIG92ZXJzdGlnZSBhbnRhbGwgYsOlbmQgaSBpbm5kYXRhcmFzdGVyZXQuIER1IGthbiBmb3IgZWtzZW1wZWwgaWtrZSB0cmVra2UgdXQgaW5mb3JtYXNqb24gb20gZmxlcmUgZW5uIMOldHRlIGtsYXNzZXIgZnJhIGV0IHJhc3RlciBtZWQgw6V0dGUgYsOlbmQuPC9kaXY+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlck5hbWU6IFwiRmxlcmRpbWVuc2pvbmFsZSBmaWx0cmVcIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25OYW1lOiBcIkludGVycG9sZXIgcmFzdGVyIGV0dGVyIHN0w7hycmVsc2VcIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25TbmlwOiBcIkludGVycG9sZXJlciBlbiBmbGVyZGltZW5zam9uYWwgcmFzdGVyIHZlZCBhbmdpdHRlIGRpbWVuc2pvbnN2ZXJkaWVyIHZlZCBoamVscCBhdiB0aWxzdMO4dGVuZGUgc3R5a2tlci5cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25EZXNjOiBcIjxwPk1lZCBkZW5uZSBmdW5rc2pvbmVuIGthbiBkdSBlc3RpbWVyZSBiaWxkZXB1bmt0dmVyZGllciBmb3IgZXQgdWRlZmluZXJ0IGRpbWVuc2pvbnNzdHlra2UgaSBlbiBmbGVyZGltZW5zam9uYWwgcmFzdGVyLiBIdmlzIGR1IGZvciBla3NlbXBlbCBoYXIgZXQgZGF0YXNldHQgc29tIGlubmVob2xkZXIgaGF2dGVtcGVyYXR1ciBww6Ugb3ZlcmZsYXRlbml2w6Ugb2cgMTAwIG1ldGVyIHVuZGVyIGhhdmZsYXRlbiwgb2cgZHUgdmlsIGJlcmVnbmUgdGVtcGVyYXR1cmVuIHRpbCA1MCBtZXRlciB1bmRlciBoYXZvdmVyZmxhdGVuLCBrYW4gZHUgYnJ1a2UgZGVubmUgZnVua3Nqb25lbiB0aWwgw6UgZsOlIGV0IGVzdGltYXQgcMOlIGRlbm5lIGR5YmRlbiB2ZWQgaGplbHAgYXYgZGltZW5zam9uc2RlZmluaXNqb25lbiBldHRlciB2ZXJkaWVyLjwvcD48cD5EdSBrYW4gb2dzw6UgcmVkdXNlcmUgb3BwbMO4c25pbmdlbiBmb3IgZXQgbcOlbmVkbGlnIGRhdGFzZXR0IHRpbCBldCBkYWdsaWcgZGF0YXNldHQgdmVkIGhqZWxwIGF2IGRpbWVuc2pvbnNkZWZpbmlzam9uZW4gRXR0ZXIgaW50ZXJ2YWxsIG9nIGFuZ2kgcGFyYW1ldGVydmVyZGllbiBUcmlubiBzb20gMSBvZyBFbmhldHNwYXJhbWV0ZXJ2ZXJkaWVuIHNvbSBEYWdlci48L3A+PHA+QnJ1a2UgZGltZW5zam9uc2RlZmluaXNqb25lbiBFdHRlciBtw6VscmFzdGVyIHRpbCDDpSBlc3RpbWVyZSB2ZXJkaWVuIGZvciBtw6VscmFzdGVyZXQuPC9wPlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJTbmlwOiBcIk9wcHJldHRlciBldCByYXN0ZXJsYWcgZnJhIGV0IGZsZXJkaW1lbnNqb25hbHQgcmFzdGVyZGF0YXNldHQgZWxsZXIgZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXJsYWcgdmVkIMOlIGRlbGUgaW5uIGRhdGEgbGFuZ3MgZGVmaW5lcnRlIHZhcmlhYmxlciBvZyBkaW1lbnNqb25lci5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsRmlsdGVyRGVzYzogXCJEZXQgZmxlcmRpbWVuc2pvbmFsZSBmaWx0ZXJldCBvcHByZXR0ZXIgZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXJsYWcgdmVkIMOlIGZpbHRyZXJlIG9nIHRyZWtrZSB1dCBldCBkZWxzZXR0IGF2IHZhcmlhYmxlciBmcmEgZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXIuIExhIG9zcyBmb3IgZWtzZW1wZWwgc2kgYXQgYXQgZHUgaGFyIGV0IGZsZXJkaW1lbnNqb25hbHQgZGF0YXNldHQgc29tIGlubmVob2xkZXIgMzAgw6VyIG1lZCBtw6VuZWRsaWdlIG5lZGLDuHJzZGF0YSBvZyBkdSBrdW4gdmlsIGhlbnRlIHV0IGRhdGEgZm9yIEphbnVhciBodmVydCDDpXIgZm9yIMOlIHNlIGh2b3JkYW4gbmVkYsO4cmVuIGhhciBlbmRyZXQgc2VnIGZvciBkZW5uZSBtw6VuZWRlbi48ZGl2Pjxici8+QnJ1ayBwYXJhbWV0ZXJlbiBEaW1lbnNpb24gRGVmaW5pdGlvbiB0aWwgw6UgZGVsZSBpbm4gZGltZW5zam9uZXIgdmVkIGhqZWxwIGF2IGV0IGludGVydmFsbCwgZW4gdmVyZGkgZWxsZXIgZW4gc2VyaWUgbWVkIHZlcmRpZXIuIEh2aXMgZHUgZm9yIGVrc2VtcGVsIGhhciAxMCDDpXIgbWVkIHNhbGluaXRldHNkYXRhIGZvciBzasO4dmFubiBzb20gZXIgc2FtbGV0IGlubiBtw6VuZWRsaWcgb2cgaSBpbnRlcnZhbGxlciBww6UgMiBtZXRlciBuZWQgdGlsIDUwMCBtZXRlcnMgZHliZGUsIGthbiBkdSBicnVrZSBkZSB1bGlrZSBhbHRlcm5hdGl2ZW5lIGZvciBkaW1lbnNqb25zZGVmaW5pc2pvbiB0aWwgZsO4bGdlbmRlIHNjZW5hcmlvZXIuIFNjZW5hcmlvIDE6IFRyZWtrIHV0IHNhbGluaXRldHNkYXRhIGZvciBtw6VuZWRlbiBKYW51YXIgb3ZlciBlbiB0acOlcnNwZXJpb2RlLiBWZWxnIEJ5IFZhbHVlcywgYW5naSBTdGRUaW1lIGZvciBEaW1lbnNpb24gb2cgdmVsZyBKYW51YXJ5IGZvciBWYWx1ZXMuIFNjZW5hcmlvIDI6IERlbCBpbm4gc2FsaW5pdGV0c2RhdGEgb3ZlciBldCBkeWJkZW9tcsOlZGUgZnJhIDAgdGlsIDE1MCBtZXRlci4gVmVsZyBCeSBSYW5nZXMsIGFuZ2kgU3RkWiBmb3IgRGltZW5zaW9uIG9nIHZlbGcgLTE1MCBmb3IgTWluaW11bSBWYWx1ZSBvZyAwIGZvciBNYXhpbXVtIFZhbHVlLiBTY2VuYXJpbyAzOiBUcmVrayB1dCBzYWxpbml0ZXRzZGF0YSBmb3IgZGUgZsO4cnN0ZSB0aSBkYWdlbmUgaSBodmVyIEphbnVhciBtw6VuZWQgb3ZlciBlbiB0acOlcnNwZXJpb2RlLiBWZWxnIEJ5IEl0ZXJhdGlvbiwgYW5naSBTdGRUaW1lIGZvciBEaW1lbnNpb24sIGFuZ2kgc3RhcnQgb2cgc2x1dHQgZm9yIGdqZW50YWtlbHNlc3BlcmlvZGVuIGkgU3RhcnQgb2YgZmlyc3QgaXRlcmF0aW9uIG9nIEVuZCBvZiBmaXJzdCBpdGVyYXRpb24sIHZlbGcgMSBmb3IgU3RlcCBvZyBZZWFycyBmb3IgVW5pdC48L2Rpdj5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyTmFtZTogXCJNdWx0aWRpbWVuc2lvbmFsIFJhc3RlclwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxSYXN0ZXJTbmlwOiBcIkxlZ2dlciB0aWwgZmxlcmRpbWVuc2pvbmFsZSBkYXRhIHNvbSBldCBmbGVyZGltZW5zam9uYWx0IHJhc3RlcmxhZyBpIGV0IGthcnQuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlckRlc2M6IFwiRnVua3Nqb25lbiBNdWx0aWRpbWVuc2lvbmFsIFJhc3RlciBsZWdnZXIgdGlsIGZsZXJkaW1lbnNqb25hbGUgZGF0YSBzb20gZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXJsYWcgaSBldCBrYXJ0LiBEZW5uZSBmdW5rc2pvbmVuIGVyIG55dHRpZyBuw6VyIGR1IHV0ZsO4cmVyIGFyYmVpZHNmbHl0ZXIgZm9yIHJhc3RlcmFuYWx5c2UgdmVkIGhqZWxwIGF2IGVuIGZ1bmtzam9uc2tqZWRlLjxkaXY+PGJyLz5TdMO4dHRlZGUgZmxlcmRpbWVuc2pvbmFsZSByYXN0ZXJkYXRhc2V0dCBpbmtsdWRlcmVyIG5ldENERiwgR1JJQiwgSERGIG9nIEVzcmlzIENSRi4gRGV0IGVyIG9nc8OlIHN0w7h0dGUgZm9yIGZsZXJkaW1lbnNqb25hbGUgbW9zYWlra2RhdGFzZXR0LjwvZGl2PlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJOYW1lOiBcIk9wdGltYWwgUGF0aCBBcyBSYXN0ZXJcIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyU25pcDogXCJCZXJlZ25lciBtaW5zdGUga29zdG5hZHNydXRlbiBmcmEgZW4ga2lsZGUgdGlsIGVuIGRlc3RpbmFzam9uLlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJEZXNjOiBcIkRlbm5lIGdsb2JhbGUgZnVua3Nqb25lbiBwcm9kdXNlcmVyIGV0IHV0ZGF0YXJhc3RlciBzb20gcmVnaXN0cmVyZXIgZGVuIG9wdGltYWxlIHJ1dGVuIGVsbGVyIHJ1dGVuZSBmcmEgdmFsZ3RlIGxva2Fzam9uZXIgdGlsIG7DpnJtZXN0ZSBraWxkZWNlbGxlIHNvbSBlciBkZWZpbmVydCBpbm5lbmZvciBkZW4gYWtrdW11bGVydGUga29zdG5hZHNvdmVyZmxhdGVuLCBuw6VyIGRldCBnamVsZGVyIGtvc3RuYWRzYXZzdGFuZC48ZGl2Pjxici8+w4luIGVsbGVyIGZsZXJlIGF2IGRlIHZla3RlZGUga29zdG5hZHNmdW5rc2pvbmVuZSAoRGlzdGFuY2UgQWNjdW11bGF0aW9uIGVsbGVyIERpc3RhbmNlIEFsbG9jYXRpb24pIG3DpSB2YW5saWd2aXMga2rDuHJlcyBmw7hyIGZ1bmtzam9uZW4gT3B0aW1hbCBQYXRoIEFzIFJhc3RlciBmb3Igw6Ugb3BwcmV0dGUgaW5uZGF0YXJhc3RyZSBmb3IgYXZzdGFuZHNha2t1bXVsZXJpbmcgb2cgdGlsYmFrZXJldG5pbmcuIERpc3NlIGVyIG9ibGlnYXRvcmlza2UgaW5uZGF0YXJhc3RlcmxhZyBmb3IgT3B0aW1hbCBQYXRoLWZ1bmtzam9uZW4uIFZlcmRpZW5lIHDDpSBkZW4gcmVzdWx0ZXJlbmRlIG9wdGltYWxlIHJ1dGVuIHJlcHJlc2VudGVyZXIgYW50YWxsZXQgcnV0ZXIgdmVkIGVuIGdpdHQgbG9rYXNqb24uIEkgbWFuZ2UgdGlsZmVsbGVyIGbDuGxnZXIgcnV0ZW4gc2FtbWUgdmVpIGZyYSBlbiBraWxkZSBvZyBnw6VyIHPDpSBpIGZvcnNramVsbGlnZSByZXRuaW5nZXIgdGlsIHVsaWtlIGRlc3RpbmFzam9uZXIuIFZlcmRpZW4gw6luIGluZGlrZXJlciBmb3IgZWtzZW1wZWwgYXQgZGV0IGJhcmUgZXIgw6luIG9wdGltYWwgcnV0ZSB2ZWQgZW4gZ2l0dCBsb2thc2pvbiwgbWVucyB2ZXJkaWVuIGZlbSBiZXR5ciBhdCBkZXQgdmVkIGRlbm5lIGxva2Fzam9uZW4gZXIgZmVtIG9wdGltYWxlIHJ1dGVyIHNvbSBnw6VyIGdqZW5ub20gZGVubmUgY2VsbGVuIGkgc3R1ZGllb21yw6VkZXQuPGRpdj48YnIvPkRlc3RpbmFzam9uc2lubmRhdGFlbmUgbcOlIHbDpnJlIGV0IHJhc3RlcmxhZy4gU2V0dGV0IG1lZCBkZXN0aW5hc2pvbnNjZWxsZXIgYmVzdMOlciBhdiBhbGxlIGNlbGxlbmUgbWVkIGd5bGRpZ2UgdmVyZGllciBpIGlubmRhdGFyYXN0ZXJldC4gQ2VsbGVyIG1lZCBOb0RhdGEtdmVyZGllciBpbmtsdWRlcmVzIGlra2UgaSBzZXR0ZXQuIFZlcmRpZW4gbnVsbCByZWduZXMgc29tIGVuIGd5bGRpZyBkZXN0aW5hc2pvbi4gVmVya3TDuHllbmUgZm9yIHV0dHJla2tpbmcga2FuIGJydWtlcyB0aWwgw6Ugb3BwcmV0dGUgZXQgZGVzdGluYXNqb25zcmFzdGVyLiBIdmlzIGR1IGhhciBkZXN0aW5hc2pvbnMtIGVsbGVyIGtpbGRlZ2Vvb2JqZWt0ZXIsIGthbiBkdSBrb252ZXJ0ZXJlIGRlbSB0aWwgcmFzdGVyIHZlZCBoamVscCBhdiBmdW5rc2pvbmVuIFJhc3Rlcml6ZSBGZWF0dXJlcy4gQnJ1ayByYXN0ZXJldCBmb3IgYXZzdGFuZHNha2t1bXVsZXJpbmcgZWxsZXIgdGlsYmFrZXJldG5pbmcgc29tIGlubmRhdGFyYXN0ZXIgaSBmdW5rc2pvbmVuIGZvciByYXN0cmVyaW5nLiBEZXR0ZSBzaWtyZXIgYXQgZ2Vvb2JqZWt0ZXQgcmFzdHJlcmVzIHZlZCBoamVscCBhdiBzYW1tZSBjZWxsZXN0w7hycmVsc2UsIHV0c3RyZWtuaW5nIG9nIHJvbWxpZ2UgcmVmZXJhbnNlIHNvbSBkZSBhbmRyZSByYXN0cmVuZSBzb20gZ8OlciBpbm4gaSBmdW5rc2pvbmVuIE9wdGltYWwgUGF0aCBBcyBSYXN0ZXIuIEZ1bmtzam9uZW4gT3B0aW1hbCBQYXRoIEFzIFJhc3RlciBrYW4gb2dzw6UgYnJ1a2VzIHRpbCDDpSBhdmxlZGUgcnV0ZW4gbWVkIG1pbnN0ZSBtb3RzdGFuZCBuZWRvdmVyIGkgZW4gZGlnaXRhbCBow7h5ZGVtb2RlbGwgKERFTSkuIEkgZGV0dGUgdGlsZmVsbGV0IGJydWtlciBkdSBERU0gZm9yIGlubmRhdGFyYXN0ZXJldCBmb3IgYXZzdGFuZHNha2t1bXVsZXJpbmcgb2cgRmxvdyBEaXJlY3Rpb24tZnVua3Nqb25lbiBmb3IgcmFzdGVyZXQgZm9yIHRpbGJha2VyZXRuaW5nLjwvZGl2PlwiLFxuXHRcdHRyZW5kTmFtZTogXCJQcmVkaWN0IFVzaW5nIFRyZW5kXCIsXG5cdFx0dHJlbmRTbmlwOiBcIkJlcmVnbmVyIGV0IHByb2dub3NlYmFzZXJ0IGZsZXJkaW1lbnNqb25hbHQgcmFzdGVybGFnIHZlZCBoamVscCBhdiBkZXQgcmVzdWx0ZXJlbmRlIHRyZW5kcmFzdGVyZXQgZnJhIEdlbmVyYXRlIFRyZW5kLWZ1bmtzam9uZW4gZWxsZXIgZ2VvcHJvc2Vzc2VyaW5nc3Zlcmt0w7h5ZXQgR2VuZXJhdGUgVHJlbmQgUmFzdGVyLlwiLFxuXHRcdHRyZW5kRGVzYzogXCJGdW5rc2pvbmVuIFByZWRpY3QgVXNpbmcgVHJlbmQgYmVyZWduZXIgZXQgZm9ydmVudGV0IGZsZXJkaW1lbnNqb25hbHQgcmFzdGVybGFnIHZlZCBoamVscCBhdiBkZXQgcmVzdWx0ZXJlbmRlIHRyZW5kcmFzdGVyZXQgZnJhIEdlbmVyYXRlIFRyZW5kLWZ1bmtzam9uZW4gZWxsZXIgZ2VvcHJvc2Vzc2VyaW5nc3Zlcmt0w7h5ZXQgR2VuZXJhdGUgVHJlbmQgUmFzdGVyLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25OYW1lOiBcIlByb2Nlc3MgUmFzdGVyIENvbGxlY3Rpb25cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uU25pcDogXCJCZWhhbmRsZXIgaHZlciBpbm5kZWxpbmcgaSBldCBmbGVyZGltZW5zam9uYWx0IHJhc3RlciBlbGxlciBodmVydCBlbGVtZW50IGkgZXQgbW9zYWlra3Jhc3Rlci4gRGVubmUgZnVua3Nqb25lbiBrYW4gb2dzw6UgYWdncmVnZXJlIGZsZXJlIGlubmRlbGluZ2VyIHRpbCDDqW4gZW5rZWx0IGlubmRlbGluZy5cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uRGVzYzogXCJGdW5rc2pvbmVuIFByb2Nlc3MgUmFzdGVyIENvbGxlY3Rpb24gYmVoYW5kbGVyIGh2ZXIgaW5uZGVsaW5nIGkgZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXIgZWxsZXIgaHZlcnQgZWxlbWVudCBpIGV0IG1vc2Fpa2tyYXN0ZXIuIERlbm5lIGZ1bmtzam9uZW4ga2FuIG9nc8OlIGFnZ3JlZ2VyZSBmbGVyZSBpbm5kZWxpbmdlciB0aWwgw6luIGVua2VsdCBpbm5kZWxpbmcuPGRpdj48YnIvPkRlbm5lIGZ1bmtzam9uZW4gYmVoYW5kbGVyIGh2ZXIgaW5uZGVsaW5nIGkgZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXIgZWxsZXIgbW9zYWlra3Jhc3RlciB2ZWQgaGplbHAgYXYgZW4gcmFzdGVyZnVua3Nqb25zbWFsLiBGdW5rc2pvbmVuIHN0w7h0dGVyIGbDuGxnZW5kZSBhbHRlcm5hdGl2ZXI6IDEuIEFuZ2kgZW4gcmFzdGVyZnVua3Nqb25zbWFsIGZvciBlbGVtZW50ZnVua3Nqb25lbi4gSHZpcyBkdSBmb3IgZWtzZW1wZWwgaGFyIGV0IG1vc2Fpa2tkYXRhc2V0dCBzb20gaW5uZWhvbGRlciAyMCDDpXIgbWVkIExhbmRzYXQtYmlsZGVyLCBvZyBkdSB2aWwgYmVyZWduZSBORFZJIGZvciBodmVyIHNjZW5lIGkgdGlkc3Nlcmllbi4gQW5naSBlbiByYXN0ZXJmdW5rc2pvbnNtYWwgc29tIGlubmVob2xkZXIgTkRWSS1yYXN0ZXJmdW5rc2pvbmVuLCBmb3IgZWxlbWVudGZ1bmtzam9uZW4uIDIuIEFuZ2kgZW4gcmFzdGVyZnVua3Nqb25zbWFsIGZvciBhZ2dyZWdlcmluZ3NmdW5rc2pvbmVuLiBIdmlzIGR1IGZvciBla3NlbXBlbCBoYXIgZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXIgc29tIGlubmVob2xkZXIgMTAgw6VyIG1lZCBkYWdsaWdlIHRlbXBlcmF0dXJkYXRhIG9nIGR1IHZpbCBiZXJlZ25lIG1ha3NpbXVtc3RlbXBlcmF0dXJlbiBmb3IgaHZlcnQgw6VyLiBJIGFnZ3JlZ2VyaW5nc2Z1bmtzam9uZW4gYW5naXIgZHUgZW4gcmFzdGVyZnVua3Nqb25zbWFsIHNvbSBpbm5laG9sZGVyIENlbGwgU3RhdGlzdGljcy1mdW5rc2pvbmVuIG9nIGhhciBNYXhpbXVtIGFuZ2l0dCBmb3IgT3BlcmF0aW9uLiBVbmRlciBBZ2dyZWdhdGlvbiBEZWZpbml0aW9uIHZlbGdlciBkdSBTdGRUaW1lIGZvciBEaW1lbnNpb24sIHZlbGdlciBJbnRlcnZhbCBLZXl3b3JkIGZvciBUeXBlIG9nIHZlbGdlciBZZWFybHkgZm9yIEtleXdvcmQgSW50ZXJ2YWwuIFbDpnIgb3BwbWVya3NvbSBww6UgYXQgaHZpcyBtb3NhaWtrZGF0YXNldHRldCBzb20gZXIgaW5uZGF0YSBpa2tlIGVyIGZsZXJkaW1lbnNqb25hbHQsIHZpbCBpa2tlIGZ1bmtzam9uZW4gZm9yIGFnZ3JlZ2VyaW5nIG92ZXJob2xkZSBhZ2dyZWdlcmluZ3NkZWZpbmlzam9uZW4uIEZ1bmtzam9uZW4gZm9yIGFnZ3JlZ2VyaW5nIHZpbCBhZ2dyZWdlcmUgYWxsZSBlbGVtZW50ZW5lIGVsbGVyIGh2ZXIgZ3J1cHBlIHRpbCDDqW4gaHZpcyBkZSBlciBkZWZpbmVydCBpIG1hbGVuIGZvciBhZ2dyZWdlcmluZ3NmdW5rc2pvbmVuLiBIdmlzIGR1IHZpbCBoYSBtZXIgaW5mb3JtYXNqb24gb20gYnJ1ayBhdiBncnVwcGVyIGkgbW9zYWlra2RhdGFzZXR0LCBzZSBCcnVrZSBtb3NhaWtrZGF0YXNldHRlbGVtZW50ZXIgaSByYXN0ZXJmdW5rc2pvbnNtYWxlci4gMy4gQW5naSBlbiByYXN0ZXJmdW5rc2pvbnNtYWwgZm9yIGJlaGFuZGxpbmdzZnVua3Nqb25lbi4gRnVua3Nqb25lbiBlbGxlciBmdW5rc2pvbnNramVkZW4gaSBkZW5uZSBtYWxlbiBicnVrZXMgdGlsIMOlIHZpc2UgZGV0IG55ZSBiZWhhbmRsZWRlIHJhc3RlcmV0LiBEdSBrYW4gZm9yIGVrc2VtcGVsIGFuZ2kgZW4gcmFzdGVyZnVua3Nqb25zbWFsIHNvbSBpbm5laG9sZGVyIENvbG9ybWFwLWZ1bmtzam9uZW4sIGZvciDDpSBlbmRyZSBodm9yZGFuIGRldCBiZWhhbmRsZWRlIHJhc3RlcmxhZ2V0IHZpc2VzLiBWw6ZyIG9wcG1lcmtzb20gcMOlIGF0IGh2aXMgaW5uZGF0YSBlciBldCBmbGVyZGltZW5zam9uYWx0IHJhc3RlciwgYnJ1a2VzIGJlaGFuZGxpbmdzZnVua3Nqb25lbiBww6UgZ2plbGRlbmRlIGlubmRlbGluZyBzb20gdmlzZXMuIEh2aXMgaW5uZGF0YWVuZSBlciBldCBtb3NhaWtrbGFnIGVsbGVyIG1vc2Fpa2tkYXRhc2V0dCwgYnJ1a2VzIGJlaGFuZGxpbmdzZnVua3Nqb25lbiBww6UgbW9zYWlra3Jhc3RlcmV0IHZlZCBoamVscCBhdiBGaXJzdC1tZXRvZGVuIGZvciDDpSBsw7hzZSBvdmVybGFwcGluZ2VyLiAzLiBTcGVzaWZpc2VyIG1hbGVyIGZvciBlbiBodmlsa2VuIHNvbSBoZWxzdCBrb21iaW5hc2pvbiBhdiBkZSB0cmUgZnVua3Nqb25lbmUuIEh2aXMgZHUgZm9yIGVrc2VtcGVsIGhhciBldCBtb3NhaWtrZGF0YXNldHQgc29tIGlubmVob2xkZXIgdGlkc3NlcmllIExhbmRzYXQtYmlsZGVyIG9nIGR1IHZpbCBnZW5lcmVyZSBldCBzYW1tZW5zYXR0IGJpbGRlIGF2IG1ha3NpbXVtIE5EVkkuIEZvciBlbGVtZW50ZnVua3Nqb25lbiBhbmdpciBkdSBlbiByYXN0ZXJmdW5rc2pvbnNtYWwgc29tIGlubmVob2xkZXIgTkRWSS1yYXN0ZXJmdW5rc2pvbmVuLiBGb3IgYWdncmVnZXJpbmdzZnVua3Nqb25lbiBhbmdpciBkdSBlbiByYXN0ZXJmdW5rc2pvbnNtYWwgc29tIGlubmVob2xkZXIgQ2VsbCBTdGF0aXN0aWNzLWZ1bmtzam9uZW4gb2cgaGFyIE1heGltdW0gYW5naXR0IGZvciBPcGVyYXRpb24uIEZvciBiZWhhbmRsaW5nc2Z1bmtzam9uZW4gYW5naXIgZHUgZW4gcmFzdGVyZnVua3Nqb25zbWFsIHNvbSBpbm5laG9sZGVyIENvbG9ybWFwLWZ1bmtzam9uZW4uIExlZ2cgbWVya2UgdGlsIGF0IHJla2tlZsO4bGdlbiBmb3IgZnVua3Nqb25zYmVoYW5kbGluZyBmw7hsZ2VyIHJla2tlZsO4bGdlbmUgaSBpbm5kYXRhcGFyYW1ldGVybmUuIEZvciBla3NlbXBlbCBiZWhhbmRsZXMgZWxlbWVudGZ1bmtzam9uZW4gZsO4cnN0LjwvZGl2PlwiLFxuXHRcdHJhbmRvbU5hbWU6IFwiUmFuZG9tXCIsXG5cdFx0cmFuZG9tU25pcDogXCJPcHByZXR0ZXIgZXQgcmFzdGVyIG1lZCB0aWxmZWxkaWdlIHBpa3NlbHZlcmRpZXIgaGVudGV0IGZyYSBlbiBwc2V1ZG90aWxmZWxkaWcgZm9yZGVsaW5nLiBEZXQgZXIgc3TDuHR0ZSBmb3IgZmxlcmUgZm9yZGVsaW5nZXIgb2cgZ2VuZXJhdG9yZXIgZm9yIHRpbGZlbGRpZ2UgdGFsbC5cIixcblx0XHRyYW5kb21EZXNjOiBcIlJhbmRvbS1mdW5rc2pvbmVuIG9wcHJldHRlciBldCByYXN0ZXIgbWVkIHRpbGZlbGRpZ2UgcGlrc2VsdmVyZGllciBzb20ga2FuIGJydWtlcyBpIHJhc3RlcmZ1bmtzam9uc21hbGVyIGVsbGVyIG1vc2Fpa2tkYXRhc2V0dC48ZGl2Pjxici8+TWVucyBtYW5nZSBmdW5rc2pvbmVyIGZ1bmdlcmVyIHDDpSBldHQgZWxsZXIgZmxlcmUgaW5uZGF0YXJhc3Rlciwga3JldmVyIGlra2UgUmFuZG9tLWZ1bmtzam9uZW4gZXQgaW5uZGF0YXJhc3Rlci4gRGV0IGJldHlyIGF0IGRlbiBvcHBmw7hyZXIgc2VnIG1lciBzb20gZXQgcmFzdGVyZGF0YXNldHQgZW5uIGVuIGZ1bmtzam9uLCBvZyBkdSBtw6UgZGVyZm9yIHbDpnJlIGVrc3RyYSBmb3JzaWt0aWcgbsOlciBkdSBsZWdnZXIgZGVuIHRpbCBlbGxlciBmamVybmVyIGRlbiBmcmEgZnVua3Nqb25za2plZGVuLjwvZGl2PlwiLFxuXHRcdHNocmlua05hbWU6IFwiU2hyaW5rXCIsXG5cdFx0c2hyaW5rU25pcDogXCJNaW5za2VyIGRlIHZhbGd0ZSBzb25lbmUgbWVkIGV0IGFuZ2l0dCBhbnRhbGwgY2VsbGVyIHZlZCDDpSBlcnN0YXR0ZSBkZW0gbWVkIHZlcmRpZW4gZm9yIGNlbGxlIHNvbSBmb3Jla29tbWVyIG9mdGVzdCBpIG5hYm9sYWdldC5cIixcblx0XHRzaHJpbmtEZXNjOiBcIk1lZCBkZW4gZ2xvYmFsZSBTaHJpbmstZnVua3Nqb25lbiBrYW4gZHUgZ2VuZXJhbGlzZXJlLCBlbGxlciBmb3JlbmtsZSwgcmFzdHJlbmUgdmVkIMOlIGdqw7hyZSBiZXN0ZW10ZSBzb25lciBtaW5kcmUuIER1IGthbiBvZ3PDpSBiZXN0ZW1tZSBvbWZhbmdldCBhdiBnZW5lcmFsaXNlcmluZ2VuLjxkaXY+PGJyLz5Tb25lbmUgZHUgdmVsZ2VyIG1pbnNrZXMsIGVsbGVyIHJlZHVzZXJlcyBpIHN0w7hycmVsc2UsIHZlZCBhdCBjZWxsZXIgZnJhIG9ta3JpbmdsaWdnZW5kZSBzb25lciB1dHZpZGVzIGlubiBpIGRlbS4gRGUgdmFsZ3RlIHNvbmV2ZXJkaWVuZSBrYW4gdmlzZXMgc29tIHNvbmVyIGkgZm9yZ3J1bm5lbiwgbWVucyBkZSBhbmRyZSB2ZXJkaWVuZSBiZWhvbGRlcyBzb20gc29uZXIgaSBiYWtncnVubmVuLiBDZWxsZW5lIGkgc29uZW5lIGkgZm9yZ3J1bm5lbiBrYW4gZXJzdGF0dGVzIGF2IGNlbGxlciBpIHNvbmVuZSBpIGJha2dydW5uZW4uIFNtYWxlIMO4eWVyIGlubmkgZW4gc29uZSwgc29tIGthbiBhbnNlcyDDpSBkZWxlIGdyZW5zZXIgbWVkIHNvbmVuLCBrYW4gb2dzw6UgZXJzdGF0dGVzLjxkaXY+PGJyLz5PbWZhbmdldCBhdiBnZW5lcmFsaXNlcmluZ2VuIGthbiBzdHlyZXMgbWVkIHBhcmFtZXRlcmVuIEFudGFsbCBjZWxsZXIuIERlbm5lIHZlcmRpZW4gZXIgc29tIHN0YW5kYXJkIDEsIG5vZSBzb20gYmV0eXIgYXQgZGUgdmFsZ3RlIHNvbmVuZSByZWR1c2VyZXMgbWVkIG1lbmdkZW4gdGlsc3ZhcmVuZGUgw6luIGNlbGxlcyBzdMO4cnJlbHNlLiBEdSBrYW4gYW5naSBlbiBzdMO4cnJlIHZlcmRpIGZvciBkZW5uZSBwYXJhbWV0ZXJlbiBmb3Igw6Ugw7hrZSBncmFkZW4gYXYgZ2VuZXJhbGlzZXJpbmcuIERldHRlIGJsaXIgc29tIMOlIGtqw7hyZSB2ZXJrdMO4eWV0IGxpa2UgbWFuZ2UgZ2FuZ2VyIHNvbSBhbmdpdHQgdGFsbCwgbWVkIHJlc3VsdGF0ZW5lIGF2IGZvcnJpZ2Uga2rDuHJpbmcgc29tIGlubmRhdGEgaSBldHRlcmbDuGxnZW5kZSBnamVudGFrZWxzZS48L2Rpdj5cIixcblx0XHR0cmVuZFRvUkdCTmFtZTogXCJUcmVuZCBUbyBSR0JcIixcblx0XHR0cmVuZFRvUkdCU25pcDogXCJLb252ZXJ0ZXJlciBldCB0cmVuZHJhc3RlciB0aWwgZXQgcmFzdGVyIG1lZCB0cmUgYsOlbmQgKHLDuGQsIGdyw7hubiBvZyBibMOlKS5cIixcblx0XHR0cmVuZFRvUkdCRGVzYzogXCJGdW5rc2pvbmVuIFRyZW5kIFRvIFJHQiBrb252ZXJ0ZXJlciBldCB0cmVuZHJhc3RlciB0aWwgZXQgcmFzdGVyIG1lZCB0cmUgYsOlbmQgKHLDuGQsIGdyw7hubiBvZyBibMOlKS4gVHJlbmRyYXN0ZXJldCBnZW5lcmVyZXMgZnJhIEdlbmVyYXRlIFRyZW5kIFJhc3Rlci1mdW5rc2pvbmVuIGVsbGVyIENDREMgQW5hbHlzaXMtcmFzdGVyZnVua3Nqb25lbi48ZGl2Pjxici8+RGVubmUgZnVua3Nqb25lbiBlciBueXR0aWcgbsOlciBkdSB2aWwgdmlzdWFsaXNlcmUgbW9kZWxsa29lZmZpc2llbnRkYXRhIGZyYSBHZW5lcmF0ZSBUcmVuZC1mdW5rc2pvbmVuIGVsbGVyIENDREMgQW5hbHlzaXMtZnVua3Nqb25lbi4gQmVnZ2UgZnVua3Nqb25lbmUgZXN0aW1lcmVyIHRyZW5kZXIgaSBwaWtzZWx2ZXJkaWVyIHNvbSBlbmRyZXIgc2VnLCBtZW4gcmVzdWx0YXRlbmUgYXYgZnVua3Nqb25lbiBlciB2YW5za2VsaWdlIMOlIHRvbGtlIGRpcmVrdGUuPGRpdj48YnIvPlNvbSBmb3IgbWFuZ2UgcmFzdGVyZnVua3Nqb25lciBtw6UgZHUga2Fuc2tqZSBicnVrZSBKdXN0ZXJpbmcgYXYgZHluYW1pc2sgb21yw6VkZXIgZm9yIMOlIGbDpSBlbiBiZWRyZSB2aXNuaW5nIGF2IHJlc3VsdGF0ZXQgYXYgZGVubmUgZnVua3Nqb25lbi48L2Rpdj5cIixcblx0XHRsYW5kVHJlbmRyTmFtZTogXCJMYW5kVHJlbmRyLWFuYWx5c2VcIixcblx0XHRsYW5kVHJlbmRyU25pcDogXCJFdmFsdWVyZXIgZW5kcmluZ2VyIGkgcGlrc2VsdmVyZGllciBvdmVyIHRpZCB2ZWQgaGplbHAgYXYgZGVuIExhbmRzYXQtYmFzZXJ0ZSBtZXRvZGVuIGZvciByZWdpc3RyZXJpbmcgYXYgdHJlbmRlciBpIGZvcnN0eXJyZWxzZSBvZyBnamVub3BwcmV0dGluZyAoTGFuZFRyZW5kcikgb2cgZ2VuZXJlcmVyIGV0IGVuZHJpbmdzYW5hbHlzZXJhc3RlciBzb20gaW5uZWhvbGRlciBtb2RlbGxyZXN1bHRhdGVuZS5cIixcblx0XHRsYW5kVHJlbmRyRGVzYzogXCJEZW5uZSByYXN0ZXJmdW5rc2pvbmVuIGthbiBiYXJlIGJydWtlcyBzb20gaW5uZGF0YSBmb3IgcmFzdGVyZnVua3Nqb25lbiBSZWdpc3RyZXIgZW5kcmluZyB2ZWQgaGplbHAgYXYgZW5kcmluZ2FuYWx5c2UuIEZvciDDpSBnZW5lcmVyZSByYXN0ZXJ1dGRhdGEgbcOlIExhbmRUcmVuZHItYW5hbHlzZWZ1bmtzam9uZW4ga29ibGVzIHRpbCBSZWdpc3RyZXIgZW5kcmluZyB2ZWQgaGplbHAgYXYgZW5kcmluZ2FuYWx5c2UtZnVua3Nqb25lbiBpIGVuIHJhc3RlcmZ1bmtzam9uc21hbCBvZyBicnVrZSBtYWxlbiBzb20gaW5uZGF0YSBpIGdlb3Byb3Nlc3NlcmluZ3N2ZXJrdMO4eWV0IEdlbmVyZXIgcmFzdGVyIGZyYSByYXN0ZXJmdW5rc2pvbi4gUmVzdWx0YXRldCBibGlyIGV0IHJhc3RlciBzb20gaW5uZWhvbGRlciBpbmZvcm1hc2pvbiBvbSB0aWRzcHVua3RldCBmb3IgZW5kcmluZyBhdiBwaWtzZWx2ZXJkaWVyLjxkaXY+PGJyPkZvcm3DpWxldCBtZWQgZGVubmUgcmFzdGVyZnVua3Nqb25lbiBlciDDpSBww6V2aXNlIGVuZHJpbmdlciBpIGV0IG9ic2VydmVydCBnZW9vYmpla3QsIHPDpSBkZXQgaWRlZWxsZSBmbGVyZGltZW5zam9uZWxsZSBiaWxkZW1hdGVyaWFsZXQgc29tIGJydWtlcyBzb20gaW5uZGF0YSwgYsO4ciB2aXNlIGVuIGtvbnNla3ZlbnQgb2JzZXJ2YXNqb24gb3ZlciB0aWQgb2cgYsO4ciBpa2tlIGlubmVob2xkZSBhdG1vc2bDpnJpc2stIGVsbGVyIHNlbnNvcmludGVyZmVyZW5zLCBza3llciBlbGxlciBza3lza3lnZ2UuIEJlc3RlIHByYWtzaXMgZXIgw6UgYnJ1a2UgZGF0YSBzb20gZXIgYmxpdHQgbm9ybWFsaXNlcnRlIG9nIGthbiBtYXNrZXJlcyB2ZWQgaGplbHAgYXYgZXQga3ZhbGl0ZXRza29udHJvbGxiw6VuZCwgZm9yIGVrc2VtcGVsIExhbmRzYXQgQ29sbGVjdGlvbiAxIFN1cmZhY2UgUmVmbGVjdGFuY2UtcHJvZHVrdGVyIG1lZCBza3ltYXNrZS48ZGl2Pjxicj5GdW5rc2pvbmVuIGFuYWx5c2VyZXIgZXR0IGJpbGRlIHBlciDDpXIsIG9nIGFudGFsbCDDpXJsaWdlIHNla3RvcmVyIG3DpSB2w6ZyZSBsaWsgZWxsZXIgc3TDuHJyZSBlbm4gdmVyZGllbiBzb20gZXIgYW5naXR0IGkgcGFyYW1ldGVyZW4gPHN0cm9uZz5NaW5pbXVtc2FudGFsbCBvYnNlcnZhc2pvbmVyPC9zdHJvbmc+LiBEZXQgYW5iZWZhbGVzIMOlIGJydWtlIGRhdGEgZnJhIG1pbnN0IHNla3Mgw6VyLjxkaXY+PGJyPkh2aXMgZHUgaGFyIG3DpW5lZGxpZ2UsIHVrZW50bGlnZSBlbGxlciBkYWdsaWdlIGRhdGEsIGFuYmVmYWxlciB2aSBhdCBkdSB2ZWxnZXIgZmxlcmUgYmlsZGVyIGZyYSBodmVydCDDpXIgKGhlbHN0IGZyYSBzYW1tZSDDpXJzdGlkKSwgZmplcm5lciBza3llciBvZyBza3lza3lnZ2Ugb2cgc2zDpXIgYmlsZGVuZSBzYW1tZW4gc2xpayBhdCBkZXQgZ2VuZXJlcmVzIGV0dCBlbmtlbHQgYmlsZGUgc29tIGdqZW5naXIgb2JzZXJ2YXNqb25lbiBww6UgZW4gZ29kIG3DpXRlLiBIdmlzIG3DpW5lZGxpZ2UsIHVrZW50bGlnZSBlbGxlciBkYWdsaWdlIGRhdGEgYmVueXR0ZXMgc29tIGRldCBmbGVyZGltZW5zam9uYWxlIGlubmRhdGFyYXN0ZXJldCwgaWRlbnRpZmlzZXJlciBmdW5rc2pvbmVuIMOpbiBzZWt0b3IgZm9yIGFuYWx5c2UgYmFzZXJ0IHDDpSBkYXRvZW4gbsOmcm1lc3QgZGVuIHNvbSBlciBhbmdpdHQgaSBwYXJhbWV0ZXJlbiA8c3Ryb25nPkZlc3RpbmdzZGF0bzwvc3Ryb25nPi48ZGl2Pjxicj5FdCBnZW9vYmpla3QgaSBldCBsYW5kc2thcCB0cmVuZ2VyIG9mdGUgdGlkIGZvciDDpSBnamVub3BwcmV0dGVzIGV0dGVyIGVuIGlra2UtcGVybWFuZW50IGVuZHJpbmcgc29tIGVuIHNrb2dicmFubiBlbGxlciBldCBpbnNla3RhbmdyZXAuIEFuZ2kgcGFyYW1ldGVyZW4gVGVyc2tlbCBmb3IgZ2plbm9wcHJldHRpbmcgZm9yIMOlIHN0eXJlIGdqZW5vcHByZXR0aW5nc3Rha3RlbiBzb20gZ2plbmtqZW5uZXMgYXYgbW9kZWxsZW4uIEV0IGdpdHQgc2VnbWVudCBrYW4gaWtrZSBoYSBlbiBnamVub3BwcmV0dGluZ3N0YWt0IHNvbSBlciByYXNrZXJlIGVubiAxL2dqZW5vcHByZXR0aW5nc3RlcnNrZWwuPGRpdj48YnI+R2plbm9wcHJldHRpbmdlbiBldHRlciBlbmRyaW5nIGF2IGV0IGxhbmRza2FwIGthbiBnw6UgaSBwb3NpdGl2IGVsbGVyIG5lZ2F0aXYgcmV0bmluZy4gTsOlciBmb3IgZWtzZW1wZWwgZXQgbGFuZHNrYXAgb3BwbGV2ZXIgdGFwIGF2IHNrb2csIHZpc2VyIGVuIHRpZHNzZXJpZSBtZWQgaW5kZWtzdmVyZGllciBmb3IgdmVnZXRhc2pvbiBldCBmYWxsIGkgaW5kZWtzdmVyZGllbmUsIG9nIGdqZW5vcHByZXR0aW5nZW4gdmlzZXIgZW4gZ3JhZHZpcyDDuGtuaW5nIGkgdmVnZXRhc2pvbmVucyBpbmRla3N2ZXJkaWVyLCBlbGxlciBlbiBwb3NpdGl2IGdqZW5vcHByZXR0aW5nc3RyZW5kLiBBbmdpIHJldG5pbmdlbiBww6UgZ2plbm9wcHJldHRpbmdzdHJlbmRlbiBtZWQgcGFyYW1ldGVyZW4gPHN0cm9uZz5HamVub3BwcmV0dGluZyBoYXIgc3RpZ2VuZGUgdHJlbmQ8L3N0cm9uZz4uXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbE5hbWU6IFwiQWdncmVnZXIgZmxlcmRpbWVuc2pvbmFsdFwiLFxuXHRcdGFnZ3JlZ2F0ZU11bHRpZGltZW5zaW9uYWxTbmlwOiBcIktvbWJpbmVyZXIgZWtzaXN0ZXJlbmRlIGZsZXJkaW1lbnNqb25hbGUgcmFzdGVydmFyaWFiZWxkYXRhIGxhbmdzIGVuIGRpbWVuc2pvbi5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsRGVzYzogXCJGdW5rc2pvbmVuIEFnZ3JlZ2VyIGZsZXJkaW1lbnNqb25hbHQgb3BwcmV0dGVyIGV0IGZsZXJkaW1lbnNqb25hbHQgcmFzdGVybGFnIHZlZCDDpSBzbMOlIHNhbW1lbiBla3Npc3RlcmVuZGUgZmxlcmRpbWVuc2pvbmFsZSByYXN0ZXJ2YXJpYWJlbGRhdGEgbGFuZ3MgZW4gZGltZW5zam9uLjxkaXY+PGJyPkJydWsgcGFyYW1ldGVyZW4gPHN0cm9uZz5EaW1lbnNqb25zZGVmaW5pc2pvbjwvc3Ryb25nPiB0aWwgZsO4cnN0IMOlIGZpbHRyZXJlIGlubmRhdGFlbmUgZHUgdmlsIGFnZ3JlZ2VyZS4gSHZpcyBkdSBmb3IgZWtzZW1wZWwgaGFyIG3DpW5lZGxpZ2UgZGF0YSBmb3IgMzAgw6VyLCBtZW4gYmFyZSB2aWwgb3BwcmV0dGUgZXQgYWdncmVnZXJ0IGxhZyBmb3IgZGUgZsO4cnN0ZSAxNSDDpXJlbmUsIGthbiBkdSBicnVrZSBwYXJhbWV0ZXJlbiA8c3Ryb25nPkRpbWVuc2pvbnNkZWZpbmlzam9uPC9zdHJvbmc+wqB0aWwgw6UgYW5naSBodmlsa2Ugw6VyIHNvbSBza2FsIGlua2x1ZGVyZXMgaSBhbmFseXNlbi48ZGl2Pjxicj48dWw+PGxpPkVrc3RyYWhlciBzYWxpbml0ZXRzZGF0YSBmb3IgamFudWFyIG3DpW5lZCBvdmVyIGVuIDEwLcOlcnNwZXJpb2RlLiBWZWxnIDxzdHJvbmc+RXR0ZXIgdmVyZGllcjwvc3Ryb25nPiwgc2V0dCA8c3Ryb25nPkRpbWVuc2pvbjwvc3Ryb25nPsKgdGlsIDxzdHJvbmc+U3RkVGltZTwvc3Ryb25nPiwgb2cgc2V0dCA8c3Ryb25nPlZlcmRpZXI8L3N0cm9uZz4gdGlsIDxzdHJvbmc+amFudWFyPC9zdHJvbmc+LjwvbGk+PGxpPkRlbCBpbm4gc2FsaW5pdGV0c2RhdGFlbmUgaSBzZWt0b3JlciBvdmVyIGV0IGR5YmRlb21yw6VkZSBmcmEgMCB0aWwgMTUwIG1ldGVyLiBWZWxnIDxzdHJvbmc+RXR0ZXIgb21yw6VkZXI8L3N0cm9uZz4sIHNldHQgPHN0cm9uZz5EaW1lbnNqb248L3N0cm9uZz4gdGlsIDxzdHJvbmc+U3RkWjwvc3Ryb25nPiwgb2cgc2V0dCA8c3Ryb25nPk1pbmltdW1zdmVyZGk8L3N0cm9uZz4gdGlsIDxzdHJvbmc+LTE1MDwvc3Ryb25nPiBvZyA8c3Ryb25nPk1ha3NpbXVtc3ZlcmRpPC9zdHJvbmc+IHRpbCA8c3Ryb25nPjA8L3N0cm9uZz4uPC9saT48bGk+RWtzdHJhaGVyIHNhbGluaXRldHNkYXRhIGZvciBkZSBmw7hyc3RlIDEwIGRhZ2VuZSBpIGphbnVhciBodmVydCDDpXIgb3ZlciBlbiAxMC3DpXJzcGVyaW9kZS4gVmVsZyA8c3Ryb25nPkV0dGVyIGdqZW50YWtlbHNlPC9zdHJvbmc+LCBzZXR0IDxzdHJvbmc+RGltZW5zam9uPC9zdHJvbmc+wqB0aWwgPHN0cm9uZz5TdGRUaW1lPC9zdHJvbmc+LCBzZXR0IDxzdHJvbmc+U3RhcnQgZm9yIGbDuHJzdGUgZ2plbnRha2Vsc2U8L3N0cm9uZz4gb2cgPHN0cm9uZz5TbHV0dCBmb3IgZsO4cnN0ZSBnamVudGFrZWxzZTwvc3Ryb25nPiB0aWwgdGlsc3ZhcmVuZGUgc3RhcnQgb2cgc2x1dHQgcMOlIGdqZW50YWtlbHNlc3BlcmlvZGVuLCBzZXR0IDxzdHJvbmc+VHJpbm48L3N0cm9uZz4gdGlsIDxzdHJvbmc+MTwvc3Ryb25nPiwgb2cgc2V0dCA8c3Ryb25nPkVuaGV0PC9zdHJvbmc+wqB0aWwgPHN0cm9uZz7DhXI8L3N0cm9uZz4uPC9saT48L3VsPjxkaXY+PGJyPkJydWvCoHBhcmFtZXRlcmVuIDxzdHJvbmc+QWdncmVnZXJpbmdzZGVmaW5pc2pvbjwvc3Ryb25nPiB0aWwgw6UgdmVsZ2UgZGltZW5zam9uZW4gc29tIHNrYWwgdnVyZGVyZXMsIG9nIHZlbGcgYWdncmVnZXJpbmdzaW50ZXJ2YWxsZXQgdmVkIMOlIGJydWtlIGV0IG7DuGtrZWxvcmQsIGVuIHZlcmRpIGVsbGVyIGV0IHZlcmRpb21yw6VkZS4gSHZpcyBkdSBmb3IgZWtzZW1wZWwgaGFyIDMwIMOlciBtZWQgZGF0YSBvbSBoYXZldHMgb3ZlcmZsYXRldGVtcGVyYXR1ciwgaW5uaGVudGV0IGRhZ2xpZyBvZyBmb3IgaHZlciA1LiBtZXRlciBuZWQgdGlsIDEwMCBtZXRlcnMgZHlwLCBrYW4gZHUgYnJ1a2UgZGUgZm9yc2tqZWxsaWUgaW50ZXJ2YWxsYWx0ZXJuYXRpdmVuZSBww6UgZsO4bGdlbmRlIHNjZW5hcmlvZXI6PGRpdj48YnI+PHVsPjxsaT5BZ2dyZWdlciBkYWdsaWdlIHRlbXBlcmF0dXJkYXRhIG9nIG3DpW5lZGxpZ2UgZGF0YSwgZGVyIHJlc3VsdGF0ZXQgYmxpciBldCBmbGVyZGltZW5zam9uYWx0IHJhc3RlciBtZWQgMTIgdGlkc3Nla3RvcmVyLCBvZyBodmVyIHNla3RvciBlciBhZ2dyZWdhdGV0IGF2IGh2ZXIgbcOlbmVkIG92ZXIgc2FtdGxpZ2Ugw6VyLiBWZWxnIDxzdHJvbmc+TsO4a2tlbG9yZGludGVydmFsbDwvc3Ryb25nPsKgb2cgc2V0dCBuw7hra2Vsb3JkZXQgdGlsIDxzdHJvbmc+R2plbnRhcyBodmVyIG3DpW5lZDwvc3Ryb25nPi48L2xpPjxsaT5BZ2dyZWdlciBkYWdsaWdlIHRlbXBlcmF0dXJkYXRhIHRpbCBtw6VuZWRsaWdlIGRhdGEsIGRlciByZXN1bHRhdGV0IGJsaXIgZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXIgbWVkIDM2MCBzZWt0b3JlciwgZWxsZXIgMTIgdGlkc3Nla3RvcmVyIHBlciDDpXIgKDMwIMOlciB4IDEyIG3DpW5lZGVyID0gMzYwIHNla3RvcmVyKS4gVmVsZyA8c3Ryb25nPk7DuGtrZWxvcmRpbnRlcnZhbGw8L3N0cm9uZz4swqBvZyBzZXR0IG7DuGtrZWxvcmRldCB0aWwgPHN0cm9uZz5Nw6VuZWRsaWc8L3N0cm9uZz4uPC9saT48bGk+QWdncmVnZXIgbcOlbmVkbGlnZSB0ZW1wZXJhdHVyZGF0YSBpIDQtbcOlbmVkZXJzIGludGVydmFsbGVyLiBWZWxnIDxzdHJvbmc+SW50ZXJ2YWxsdmVyZGk8L3N0cm9uZz4sIHNldHQgPHN0cm9uZz5WZXJkaWludGVydmFsbDwvc3Ryb25nPsKgdGlsIDQsIG9nIHNldHQgPHN0cm9uZz5FbmhldDwvc3Ryb25nPiB0aWwgPHN0cm9uZz5Nw6VuZWRlcjwvc3Ryb25nPi48L2xpPjxsaT5BZ2dyZWdlciB0ZW1wZXJhdHVyZGF0YSBmcmEgMCB0aWwgMjUgbWV0ZXIsIHPDpSBmcmEgMjUgdGlsIDUwIG1ldGVyIG9nIGRlcmV0dGVyIGZyYSA1MCB0aWwgMTAwIG1ldGVyLiBWZWxnIDxzdHJvbmc+SW50ZXJ2YWxsb21yw6VkZXI8L3N0cm9uZz4swqBvZyBhbmdpIG1pbmltdW1zLSBvZyBtYWtzaW11bXNkeWJkZXIgc29tIDxzdHJvbmc+MCAyNTsgMjUgNTA7IDUwIDEwMDwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0bWVyZ2VSYXN0ZXJzTmFtZTogXCJTbMOlIHNhbW1lbiByYXN0ZXJlXCIsXG5cdFx0bWVyZ2VSYXN0ZXJzU25pcDogXCJLb21iaW5lcmVyIGZsZXJlIHJhc3RlcmRhdGFzZXR0IHJvbWxpZywgZWxsZXIgcMOlIHR2ZXJzIGF2IHZhcmlhYmxlciBvZyBkaW1lbnNqb25lci5cIixcblx0XHRtZXJnZVJhc3RlcnNEZXNjOiBcIkRlbm5lIGZ1bmtzam9uZW4gb3BwcmV0dGVyIGV0IHNhbW1lbnNsw6V0dCByYXN0ZXIgZnJhIGVuIGxpc3RlIG92ZXIgcmFzdGVyZS4gSHZpcyBkdSBmb3IgZWtzZW1wZWwgaGFyIGV0IG1vc2Fpa2tkYXRhc2V0dCBzb20gaW5uZWhvbGRlciAzMCDDpXJzIG3DpW5lZGxpZ2UgbmVkYsO4cnNkYXRhLCBvZyBldCBhbm5ldCBkYXRhc2V0dCBtZWQgMTAgw6VycyBtw6VuZWRsaWdlIHRlbXBlcmF0dXJkYXRhLCBrYW4gZHUgc2zDpSBkZW0gc2FtbWVuIHRpbCBldCBmbGVyZGltZW5zam9uYWx0IHJhc3RlciBtZWQgYmVnZ2UgdmFyaWFibGVuZS4gPGRpdj48YnI+SHZpcyBkZSBmbGVyZGltZW5hc2pvbmFsZSBpbm5kYXRhcmFzdGVybmUgaW5uZWhvbGRlciBmb3Jza2plbGxpZ2UgdmFyaWFibGVyLCB2aWwgZGV0IHJlc3VsdGVyZW5kZSBmbGVyZGltZW5zam9uYWxlIHJhc3RlcmV0IGlubmVob2xkZSBzYW10bGlnZSB2YXJpYWJsZXIuIDxkaXY+PGJyPkh2aXMgZGUgZmxlcmRpbWVuYXNqb25hbGUgaW5uZGF0YXJhc3Rlcm5lIGlubmVob2xkZXIgZm9yc2tqZWxsaWdlIGRpbWVuc2pvbmVyIGVsbGVyIGRpbWVuc2pvbnN2ZXJkaWVyLCB2aWwgZGV0IHJlc3VsdGVyZW5kZSBmbGVyZGltZW5zam9uYWxlIHJhc3RlcmV0IGlubmVob2xkZSBzYW10bGlnZSBkaW1lbnNqb25lciBvZyBkaW1lbnNqb25zdmVyZGllci4gPGRpdj48YnI+SHZpcyBkZSBmbGVyZGltZW5hc2pvbmFsZSBpbm5kYXRhcmFzdGVybmUgaW5uZWhvbGRlciBkZSBzYW1tZSBkaW1lbnNqb25lbmUgb2cgdmFyaWFibGVuZSwgbWVuIGhhciB1bGlrZSByb21saWdlIHV0c3RyZWtuaW5nZXIsIHZpbCBkZXQgcmVzdWx0ZXJlbmRlIGZsZXJkaW1lbnNqb25hbGUgcmFzdGVyZXQgaW5uZWhvbGRlIHZhcmlhYmxlbmUgb2cgZGltZW5zam9uZW5lIHDDpSB0dmVycyBhdiBkZSBzYW1tZW5zbMOldHRlIHJvbWxpZ2UgdXRzdHJla25pbmdlbmUuPGRpdj48YnI+RGVubmUgZnVua3Nqb25lbiBrYW4gb2dzw6UgYnJ1a2VzIG7DpXIgZHUgaGFyIGZsZXJlIHJhc3RlcmUgc29tIGR1IHZpbCBiZWhhbmRsZSBzb20gZXR0IGVsZW1lbnQsIGZvciBla3NlbXBlbCBmb3Igw6UgYmVyZWduZSBzYW1tZSBzdGF0aXN0aWtrIGZvciBhbGxlLCBlbGxlciBuw6VyIGR1IGJhbGFuc2VyZXIgZmFyZ2VyIG9nIHZpbCBzbGlwcGUgw6UgYmFsYW5zZXJlIGZhcmdlbmUgaSBodmVydCBiaWxkZSBmb3Igc2VnLiBEZXR0ZSBlciBueXR0aWcgbsOlciBkdSBhcmJlaWRlciBtZWQgYmlsZGVyIHNvbSBlciBsYWdyZXQgc29tIHNlcGFyYXRlIGZsaXNlciBww6UgZ3J1bm4gYXYgYmVncmVuc25pbmdlciBww6UgZmlsc3TDuHJyZWxzZS4gTWVkIGRlbm5lIG1ldG9kZW4gYmxpciBmbGlzZW5lIGJlaGFuZGxldCBzb20gZGVsZXIgYXYgZGV0IHNhbW1lIGJpbGRldC5cIixcblx0XHRib3VuZGFyeUNsZWFuTmFtZTogXCJHcmVuc2V1dGpldm5pbmdcIixcblx0XHRib3VuZGFyeUNsZWFuU25pcDogXCJKZXZuZXIgdXQgZ3JlbnNlbiBtZWxsb20gc29uZXIuXCIsXG5cdFx0Ym91bmRhcnlDbGVhbkRlc2M6IFwiPHA+RnVua3Nqb25lbiBnZW5lcmFsaXNlcmVyIGVsbGVyIGZvcmVua2xlciByYXN0ZXJlIHZlZCDDpSBqZXZuZSB1dCBncmVuc2VuZSBtZWxsb20gc29uZXIuIEZ1bmtzam9uZW4gaGFyIGFsdGVybmF0aXZlciBmb3Igw6Ugc3R5cmUgaHZvcmRhbiBjZWxsZW5lIGkgc29uZW5lIHDDpXZpcmtlciB1dGpldm5pbmdlbiBvZyBodmlsa2VuIGdyYWQgYXYgdXRqZXZuaW5nIHNvbSBza2FsIGJydWtlcy4gSHZlciBlbmtlbHQgaW5uZGF0YWNlbGxlIGV2YWx1ZXJlcyB2ZWQgw6UgYnJ1a2UgZGUgw6V0dGUgbsOmcm1lc3RlIG5hYm9lbmUuPC9wPjxwPlV0amV2bmluZ3Nwcm9zZXNzZW4gc29ydGVyZXIgZsO4cnN0IG5hYm9jZWxsZW5lIGV0dGVyIGVuIGJlc3RlbXQgcHJpb3JpdGV0LiBQcmlvcml0ZXRlbiBiZXN0ZW1tZXIgaHZpbGtlbiBzb25lIGZyYSBuYWJvY2VsbGVuZSBzb20ga2FuIGVyc3RhdHRlIHZlcmRpZW4gYXYgYmVoYW5kbGluZ3NjZWxsZW4gaSByZXN1bHRhdGV0LjwvcD48cD5Qcmlvcml0ZXRlbiBrYW4gYmFzZXJlcyBww6UgZW50ZW4gdmVyZGllbiBhdiBzb25lbmUgZWxsZXIgc3TDuHJyZWxzZW4gcMOlIHNvbmVuZS4gUGFyYW1ldGVyZW4gPHN0cm9uZz5Tb3J0ZXJpbmdzdHlwZTwvc3Ryb25nPiBiZXN0ZW1tZXIgaHZpbGtlbiBzb3J0ZXJpbmdzdHlwZSBzb20gc2thbCBicnVrZXMuIDwvcD48cD5TdGFuZGFyZGlubnN0aWxsaW5nZW4gPHN0cm9uZz5Ja2tlIHNvcnRlcjwvc3Ryb25nPiB2dXJkZXJlciBwcmlvcml0ZXRlbiB1dCBmcmEgdmVyZGllbiBhdiBzb25lbmUuIENlbGxlciBmcmEgc29uZXIgbWVkIGjDuHllcmUgdmVyZGllciB2aWwgaGEgZW4gaMO4eWVyZSBwcmlvcml0ZXQgZm9yIMOlIHV0dmlkZXMgaW5uIGkgc29uZXIgbWVkIGxhdmVyZSB2ZXJkaWVyLjwvcD48cD5Tb25lbmVzIHN0w7hycmVsc2UgZWxsZXIgdG90YWxlIGFyZWFsIGthbiBicnVrZXMgdGlsIMOlIHNvcnRlcmUgcHJpb3JpdGV0ZW4uIE1lZCBpbm5zdGlsbGluZ2VuIDxzdHJvbmc+U3lua2VuZGU8L3N0cm9uZz4gc29ydGVyZXMgc29uZW5lIGV0dGVyIHN0w7hycmVsc2UgaSBzeW5rZW5kZSByZWtrZWbDuGxnZS4gU29uZXIgbWVkIHN0w7hycmUgdG90YWx0IGFyZWFsIHZpbCBoYSBwcmlvcml0ZXQgdGlsIMOlIHV0dmlkZXMgaW5uIGkgc29uZXIgbWVkIG1pbmRyZSBhcmVhbC4gTWVkIGlubnN0aWxsaW5nZW4gPHN0cm9uZz5TdGlnZW5kZTwvc3Ryb25nPiBza2plciBkZXQgbW90c2F0dGU6IFNvbmVyIG1lZCBtaW5kcmUgdG90YWx0IGFyZWFsIHZpbCBoYSBwcmlvcml0ZXQgdGlsIMOlIHV0dmlkZXMgaW5uIGkgc29uZXIgbWVkIHN0w7hycmUgdG90YWx0IGFyZWFsLjwvcD48cD5HcmFkZW4gYXYgdXRqZXZuaW5nIHN0eXJlcyBhdiBwYXJhbWV0ZXJlbiA8c3Ryb25nPktqw7hyIHV0dmlkZWxzZSBvZyBrcnltcGluZyB0byBnYW5nZXI8L3N0cm9uZz4sIHNvbSBiZXN0ZW1tZXIgYW50YWxsIGdhbmdlciB1dHZpZGVsc2VzLSBvZyBrcnltcGVwcm9zZXNzZW4gc2thbCB1dGbDuHJlcy48L3A+PHA+TsOlciBpbm5zdGlsbGluZ2VuIGlra2UgZXIgYXZtZXJrZXQsIHV0ZsO4cmVzIHV0dmlkZWxzZXMtIG9nIGtyeW1wZXByb3Nlc3NlbiDDqW4gZ2FuZy4gTsOlciBpbm5zdGlsbGluZ2VuIGVyIGF2bWVya2V0LCB1dGbDuHJlcyB1dHZpZGVsc2VzLSBvZyBrcnltcGVwcm9zZXNzZW4gdG8gZ2FuZ2VyIG9nIHJlc3VsdGVyZXIgaSBlbiB5dHRlcmxpZ2VyZSBncmFkIGF2IHV0amV2bmluZyBhdiBzb25lZ3JlbnNlbmUuPC9wPjxwPkh2aXMgdmVyZGllbmUgaSBhbGxlIGRlIMOldHRlIG5hYm9jZWxsZW5lIGVyIGRlIHNhbW1lIHNvbSBpIGJlaGFuZGxpbmdzY2VsbGVuLCBiZWhvbGRlciBkZW4gcmVzdWx0ZXJlbmRlIGNlbGxlbiB2ZXJkaWVuIHRpbCBpbm5kYXRhY2VsbGVuLjwvcD5cIixcblx0XHRwcmVkaWN0VXNpbmdSZWdyZXNzaW9uTmFtZTogXCJGb3J1dHNpIGJydWsgYXYgcmVncmVzam9uXCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvblNuaXA6IFwiQmVyZWduZXIgZW4gZm9ydXRzYWd0IHJhc3RlciBiYXNlcnQgcMOlIHJhc3RlcmRhdGFpbm5kYXRhIG9nIGVuIHJlZ3Jlc2pvbnNtb2RlbGwuIFJlZ3Jlc2pvbnNtb2RlbGxlbiBlciB1dGRhdGEgZnJhIDxzdHJvbmc+VHJhaW4gUmFuZG9tIFRyZWVzLXJlZ3Jlc2pvbnNtb2RlbGxlbnM8L3N0cm9uZz4gcmFzdGVyZ2VvYmVoYW5kbGluZ3N2ZXJrdMO4eS5cIixcblx0XHRwcmVkaWN0VXNpbmdSZWdyZXNzaW9uRGVzYzogXCI8cD5SZWdyZXNqb25zbW9kZWxsZW4gZXIgZGVmaW5lcnQgaSBlbiBFc3JpLXJlZ3Jlc2pvbnNkZWZpbmlzam9uc2ZpbCAoLmVjZCkuIERlbiBpbm5laG9sZGVyIGFsbCBpbmZvcm1hc2pvbiBmb3IgZXQgYmVzdGVtdCBkYXRhc2V0dCBlbGxlciBldCBzZXR0IG1lZCBkYXRhc2V0dCwgb2cgcmVncmVzam9uc21vZGVsbGVuLCBvZyBnZW5lcmVyZXMgYXYgPHN0cm9uZz5UcmFpbiBSYW5kb20gVHJlZXMtcmVncmVzam9uc21vZGVsbGVuczwvc3Ryb25nPiByYXN0ZXJnZW9iZWhhbmRsaW5nc3Zlcmt0w7h5LjwvcD48cD5Jbm5kYXRhZW5lIGthbiB2w6ZyZSBldCBlbmtlbHQgYsOlbmQsIGV0IG11bHRpYsOlbmQgZWxsZXIgZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXIsIGVsbGVyIGVuIGxpc3RlIG92ZXIgZGlzc2UgdHlwZW5lLiBUeXBlbmUgaW5uZGF0YXJhc3RlcmUgbcOlIHbDpnJlIHNhbW1lIHR5cGUgcmFzdGVyIHNvbSBlciBvcHBsw6ZydCBhdiByZWdyZXNqb25zbW9kZWxsZW4uPC9wPjx1bD48bGk+TsOlciBpbm5kYXRhIGVyIGV0IG11bHRpYsOlbmRyYXN0ZXIsIGJsaXIgaHZlcnQgYsOlbmQgYmVoYW5kbGV0IHNvbSBlbiBwcmVkaWt0b3J2YXJpYWJlbC4gQsOlbmRlbmUgbcOlIHbDpnJlIGkgc2FtbWUgcmVra2Vmw7hsZ2Ugc29tIG11bHRpYsOlbmRzaW5uZGF0YWVuZSBmb3IgcmVncmVzam9uc21vZGVsbGVucyBvcHBsw6ZyaW5nc3Zlcmt0w7h5LjwvbGk+PGxpPk7DpXIgaW5uZGF0YSBlciBldCBmbGVyZGltZW5zam9uYWx0IHJhc3RlciwgYmxpciBodmVyIHZhcmlhYmVsIGJlaGFuZGxldCBzb20gZW4gcHJlZGlrdG9ydmFyaWFiZWwsIG9nIHZhcmlhYmVsZW4gbcOlIHbDpnJlIGVua2VsdGLDpW5kIG9nIGhhIGVuIHRpZHNkaW1lbnNqb24uIFZhcmlhYmVscmVra2Vmw7hsZ2VuIG9nIC1uYXZuZW5lIG3DpSB2w6ZyZSBkZSBzYW1tZSBzb20gaW5uZGF0YWVuZSBuw6VyIHJlZ3Jlc2pvbnNtb2RlbGxlbiBibGUgbMOmcnQgb3BwLiBVdGRhdGFlbmUgZXIgZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXIuPC9saT48bGk+SW5uZGF0YWVuZSBrYW4gdsOmcmUgZW4gbGlzdGUgbWVkIGVsZW1lbnRlci4gQW50YWxsIGVsZW1lbnRlciBvZyByZWtrZWbDuGxnZW4gcMOlIGVsZW1lbnRlbmUgbcOlIHNhbXN2YXJlIG1lZCBpbmRhdGFlbmUgbsOlciByZWdyZXNqb25zbW9kZWxsZW4gYmxlIGzDpnJ0IG9wcC48L2xpPjwvdWw+XCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdTdGF0aXN0aWNzTmFtZTogXCJEaW1lbnNqb25hbCBiZXZlZ2Vsc2Vzc3RhdGlzdGlra1wiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc1NuaXA6IFwiQmVyZWduZXIgc3RhdGlzdGlrayBvdmVyIGV0IHZpbmR1IGkgYmV2ZWdlbHNlIHDDpSBmbGVyZGltZW5zam9uYWxlIGRhdGEgbGFuZ3MgZW4gYW5naXR0IGRpbWVuc2pvbi5cIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NEZXNjOiBcIjxwPkZ1bmtzam9uZW4gRGltZW5zam9uc2ZseXR0aW5nc3N0YXRpc3Rpa2sgYmVyZWduZXIgdWxpa2Ugc3RhdGlzdGlra2VyIGkgZXQgZm9yaMOlbmRzZGVmaW5lcnQgdmluZHUgZm9yIGFsbGUgZGltZW5zam9uc3ZlcmRpZXIgbGFuZ3MgZW4gZGltZW5zam9uLiBEZW5uZSBmdW5rc2pvbmVuIHRhciBldCBmbGVyZGltZW5zam9uYWx0IHJhc3RlcmxhZyBzb20gaW5uZGF0YSBvZyBvcHByZXR0ZXIgZXQgZmxlcmRpbWVuc2pvbmFsdCByYXN0ZXJsYWcgc29tIHV0ZGF0YSBzb20gaGFyIHNhbW1lIGRpbWVuc2pvbmFsZSBzdMO4cnJlbHNlIHNvbSBpbm5kYXRhbGFnZXQuPC9wPjxwPkR1IGthbiBhbmdpIGVuIGRpbWVuc2pvbiBzb20gZGltZW5zam9uc3ZlcmRpZXIgdnVyZGVyZXMgZm9yIHVuZGVyIGJlcmVnbmluZ2VuLiBTb20gc3RhbmRhcmQgYmVyZWduZXMgZGVuIGxhbmdzIGRlbiBmw7hyc3RlIGlra2Utcm9tbGlnZSBkaW1lbnNqb25lbi4gRHUga2FuIG9nc8OlIGFuZ2kgZW4gdmluZHVzc3TDuHJyZWxzZSB2ZWQgw6UgYW5naSBwYXJhbWV0ZXJuZSBCYWtvdmVydmluZHUgb2cgRnJlbW92ZXJ2aW5kdS48L3A+PHA+TsOlciBzdGF0aXN0aWtrdHlwZW4gZXIgc2F0dCB0aWwgcGVyc2VudGlsLCBibGlyIHBhcmFtZXRlcm5lIHBlcnNlbnRpbHZlcmRpIG9nIHBlcnNlbnRpbCBpbnRlcnBvbGVyaW5nc3R5cGUgdGlsZ2plbmdlbGlnZS4gRHUga2FuIGJydWtlIGRpc3NlIHBhcmFtZXRlcm5lIHRpbCDDpSBhbmdpIHBlcnNlbnRpbGVuIHNvbSBza2FsIGJlcmVnbmVzLCBvZyB2ZWxnZSBpbnRlcnBvbGVyaW5nc3R5cGVuIHNvbSBza2FsIGJydWtlcy4gTsOlciBzdGF0aXN0aWtrdHlwZW4gZXIgc2F0dCB0aWwgc2lya3Vsw6ZydCBnamVubm9tc25pdHQsIGJsaXIgcGFyYW1ldGVyZW4gc2lya3Vsw6ZyIGZseXR2ZXJkaSB0aWxnamVuZ2VsaWcuIERlbiBzaXJrdWzDpnJlIGZseXR2ZXJkaWVuIGJydWtlcyB0aWwgw6Uga29udmVydGVyZSBlbiBsaW5lw6ZyIHZlcmRpIHRpbCBvbXLDpWRldCBmb3IgZXQgZ2l0dCBzaXJrdWzDpnJ0IGdqZW5ub21zbml0dC48L3A+XCIsXG5cdFx0dGVycmFpbkZsYXR0ZW5GdW5jdGlvbk5hbWU6IFwiVXRmbGF0aW5nIGF2IHRlcnJlbmdcIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uU25pcDogXCJLb3JyaWdlcmVyIGlubmRhdGEgZnJhIHJhZGFyIG1lZCBzeW50ZXRpc2sgYmxlbmRlcsOlcG5pbmcgKFNBUi1kYXRhKSBmb3IgcmFkaW9tZXRyaXNrZSBmb3J0ZWduaW5nZXIgc29tIHNreWxkZXMgdG9wb2dyYWZpLlwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25EZXNjOiBcIjxwPlJhc3RlcmZ1bmtzam9uZW4gVXRmbGF0aW5nIGF2IHRlcnJlbmcga29ycmlnZXJlciBpbm5kYXRhZW5lIGZyYSByYWRhcmVyIG1lZCBzeW50ZXRpc2sgYmxlbmRlcsOlcG5pbmcgKFNBUi1kYXRhKSBmb3IgcmFkaW9tZXRyaXNrZSBmb3J0ZWduaW5nZXIgc29tIHNreWxkZXMgdG9wZ3JhZmkuPC9wPjxwPklubmRhdGFlbmUgbcOlIGbDuHJzdCBrYWxpYnJlcmVzIHRpbCBiZXRhIG51bGwuIFZlcmt0w7h5ZXQgQnJ1ayByYWRpb21ldHJpc2sga2FsaWJyZXJpbmcgYnJ1a2VzIHRpbCDDpSBrYWxpYnJlcmUgcmFkYXJkYXRhIHRpbCBiZXRhIG51bGwuPC9wPjxwPkh2aXMgREVNLWlubmRhdGFlbmUgaWtrZSBvbWZhdHRlciBoZWxlIFNBUi1kYXRhc2V0dGV0LCBnaXIgdmVya3TDuHlldCBmw7hsZ2VuZGUgcmVzdWx0YXRlcjogTm9EYXRhLXZlcmRpZXIgZm9yIHBpa3NsZW5lIHNvbSBsaWdnZXIgdXRlbmZvciBERU0tdXRzdHJla25pbmdlbiBmb3IgZ2FtbWEgbnVsbCwgc2lnbWEgbnVsbCwgc3ByZWRuaW5nc29tcsOlZGUgb2cgdXRkYXRhIGZvciBnZW9tZXRyaXNrZSBmb3J0ZWduaW5nZXIuIEZvciBtYXNrZXV0ZGF0YWVuZSBmb3IgZ2VvbWV0cmlzayBmb3J0ZWduaW5nIGdpciB2ZXJrdMO4eWV0IHNvbSByZXN1bHRhdCB1YmVzdGVtdGUgdmVyZGllciBmb3IgcGlrc2xlciB1dGVuZm9yIERFTS11dHN0cmVrbmluZ2VuLjwvcD48cD5Jbm5kYXRhLURFTSBtw6UgdsOmcmUgaSBkZXQgZ2VvZ3JhZmlza2Uga29vcmRpbmF0c3lzdGVtZXQgV0dTIDE5ODQgKEVQU0c6NDMyNikuPC9wPlwiLFxuXHRcdGNyZWF0ZUNvbG9yQ29tcG9zaXRlRnVuY3Rpb25OYW1lOiBcIk9wcHJldHQgZmFyZ2Vrb21wb3NpdHRcIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uU25pcDogXCJPcHByZXR0ZXIgZXQgcmFzdGVyIG1lZCB0cmUgYsOlbmQgZnJhIGV0IGZsZXJiw6VuZHNyYXN0ZXJkYXRhc2V0dCBkZXIgaHZlcnQgYsOlbmQga2FuIGJydWtlIGVuIGFsZ2VicmFpc2sgdXRyZWduaW5nIGJhc2VydCBww6UgYsOlbmRldHMgYWxnZWJyYS5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uRGVzYzogXCI8cD5SYXN0ZXJmdW5rc2pvbmVuIE9wcHJldHQgZmFyZ2Vrb21wb3NpdHQgb3BwcmV0dGVyIGV0IHJhc3RlciBtZWQgdHJlIGLDpW5kIGZyYSBldCBmbGVyYsOlbmRzcmFzdGVyZGF0YXNldHQgZGVyIGh2ZXJ0IGLDpW5kIGthbiBicnVrZSBlbiBhbGdlYnJhaXNrIHV0cmVnbmluZyBiYXNlcnQgcMOlIGLDpW5kZXRzIGFsZ2VicmEuPC9wPjxwPk7DpXIgZHUgZGVmaW5lcmVyIGVuIGLDpW5kYXJpdG1ldGlzayBhbGdvcml0bWUsIGthbiBkdSBhbmdpIGVuIGFsZ2VicmFpc2sgZm9ybWVsIHDDpSBlbiBlbmtlbHQgbGluamUgZm9yIGh2ZXJ0IHV0dHJ5a2ssIGZvciDDpSBza2FwZSBldCBmbGVyYsOlbmRzcmVzdWx0YXQuIE9wZXJhdG9yZW5lIHNvbSBzdMO4dHRlcywgZXIgZW5oZXRsaWdlLCBwbHVzcyAoKyksIG1pbnVzICgtKSwgbXVsdGlwbGlrYXNqb24gKCopLCBvZyBkaXZpc2pvbiAoLykuPC9wPjxwPk7DpXIgZW4gYsOlbmQtSUQgc2thbCBicnVrZXMgaSBldCB1dHRyeWtrLCBtw6UgYsOlbmRldCBpZGVudGlmaXNlcmVzIG1lZCBwcmVmaWtzZXQgQiBlbGxlciBiIHZlZCBiw6VuZG51bW1lcmV0LjwvcD48cD5FbiBhbG1pbm5lbGlnIGLDpW5ka29tYmluYXNqb24gc29tIGJydWtlcyBmb3IgcmFkYXIgbWVkIHN5bnRldGlzayBibGVuZGVyw6VwbmluZyAoU0FSKSBpIGxpbmXDpnJlIGVuaGV0ZXIsIGVyIFZWIGZvciByw7hkdCwgVkggZm9yIGdyw7hudCBvZyBWVi9WSCBmb3IgYmzDpXR0LiBIdmlzIGlubmRhdGFlbmUgZXIgaSBkZXNpYmVsLCBza2FsIGLDpW5ka29tYmluYXNqb25lbiB2w6ZyZSBWViBmb3IgcsO4ZHQsIFZIIGZvciBncsO4bnQgb2cgVlYtVkggZm9yIGJsw6V0dC48L3A+XCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNOYW1lOiBcIk92ZXJmbGF0ZXBhcmFtZXRlcmVcIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc1NuaXA6IFwiRmFzdHNldHRlciBwYXJhbWV0ZXJlIGZvciBlbiByYXN0ZXJvdmVyZmxhdGUgc29tIGhlbGxpbmdzcmV0bmluZywgaGVsbGluZ3NncmFkIG9nIGZsZXJlIHR5cGVyIGt1cnZhdHVyIHZlZCBoamVscCBhdiBnZW9kZXRpc2tlIG1ldG9kZXIuXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNEZXNjOiBcIjxwPkZ1bmtzam9uZW4gT3ZlcmZsYXRlcGFyYW1ldHJlIGZhc3RzZXR0ZXIgcGFyYW1ldGVyZSBmb3IgZW4gcmFzdGVyb3ZlcmZsYXRlIHNvbSBoZWxsaW5nc3JldG5pbmcsIGhlbGxpbmdzZ3JhZCBvZyBmbGVyZSB0eXBlciBrdXJ2YXR1ciB2ZWQgaGplbHAgYXYgZ2VvZGV0aXNrZSBtZXRvZGVyLjwvcD48cD5EZW5uZSBmdW5rc2pvbmVuIGthbiBicnVrZXMgdGlsIGbDuGxnZW5kZTo8L3A+PHVsPjxsaT5CZXJlZ25lIGhlbGxpbmdzcmV0bmluZyBvZyBoZWxsaW5nc2dyYWQgdmVkIGhqZWxwIGF2IGdlb2RldGlza2UgbWV0b2Rlci48L2xpPjxsaT5CZXJlZ25lIHVsaWtlIHR5cGVyIGt1cnZhdHVyIGZyYSBlbiBpbm5sYWd0IG92ZXJmbGF0ZXJhc3RlciwgZm9yIGVrc2VtcGVsIDxzdHJvbmc+VGFuZ2VuaXRlbGwgKG5vcm1hbCBrb250dXIpIGt1cnZhdHVyPC9zdHJvbmc+IHNvbSBrYXJha3RlcmlzZXJlciB0b3BvZ3JhZmlzayBrb252ZXJnZW5zIG9nIGRpdmVyZ2VucyBhdiBmbHl0IG92ZXIgb3ZlcmZsYXRlbi48L2xpPjwvdWw+XCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JOYW1lOiBcIk1pbnN0IGtvc3RuYWQta29ycmlkb3JcIixcblx0XHRsZWFzdENvc3RDb3JyaWRvclNuaXA6IFwiQmVyZWduZXIgc3VtbWVuIGZvciB0byByYXN0ZXIgZm9yIGt1bXVsYXRpdiBrb3N0bmFkc2F2c3RhbmQgbWVkIG11bGlnaGV0IHRpbCDDpSBicnVrZSBlbiB0ZXJza2VsIGJhc2VydCBww6UgcHJvc2VudCBlbGxlciBrdW11bGF0aXYga29zdG5hZC5cIixcblx0XHRsZWFzdENvc3RDb3JyaWRvckRlc2M6IFwiPHA+SW5uZGF0YXJhc3RyZW5lIHNrYWwgdsOmcmUgYXZzdGFuZHNha2t1bXVsZXJpbmcgb2cgdXRkYXRhIGZvciByYXN0ZXIgZm9yIG1vdHNhdHQgcmV0bmluZyBmcmEgZnVua3Nqb25lbiA8c3Ryb25nPkF2c3RhbmRzYWtrdW11bGVyaW5nPC9zdHJvbmc+IGVsbGVyIDxzdHJvbmc+QXZzdGFuZHNhbGxva2VyaW5nPC9zdHJvbmc+IC4gRGlzc2Ugc2thbCB2w6ZyZSBiYXNlcnQgcMOlIGtvc3RuYWRzYXZzdGFuZCwgb2cgZGUgc2FtbWUgcGFyYW1ldGVyaW5uc3RpbGxpbmdlbmUgc2thbCBicnVrZXMgdGlsIG9wcHJldHRpbmcgYXYgbGFnZW5lIGZvciBodmVyIGtpbGRlLiBEZXQgc2thbCBpa2tlIGJydWtlcyBwYXJhbWV0ZXJlIHNvbSBlciBhdmhlbmdpZ2UgYXYgcmV0bmluZ3NhbmdpdmVsc2UgKGhvcmlzb250YWwgZmFrdG9yLCB2ZXJ0aWthbCBmYWt0b3Igb2cgcmVpc2VyZXRuaW5nKSwgdGlsIMOlIG9wcHJldHRlIGRpc3NlIHJhc3RlcmVuZS48L3A+PHA+VmVyZGllbmUgaSByZXN1bHRlcmVuZGUga29ycmlkb3JyYXN0ZXIgZXIgc3VtbWVuIGF2IGRlbiBrdW11bGF0aXZlIGtvc3RhbmRlbiBmb3Igw6UgbsOlIGVuIGdpdHQgbG9rYXNqb24gbWVkIGRlIHNhbW1lIGVuaGV0ZW5lIHNvbSBpbm5kYXRhcmFzdHJlbmUgbWVkIGt1bXVsYXRpdiBrb3N0bmFkc2F2c3RhbmQuPC9wPjxwPkh2aXMgZW4gYW5naXR0IDxzdHJvbmc+dGVyc2tlbDwvc3Ryb25nPnZlcmRpIGVyIHN0w7hycmUgZW5uIG1ha3NpbXVtIGt1bXVsYXRpdiBrb3N0bmFkIG7DpXIgZGUgdG8gcmFzdHJlbmUgZm9yIGF2c3RhbmRzYWtrdW11bGVyaW5nIGVyIHN1bW1lcnQsIHZpbCByZXN1bHRlcmVuZGUga29ycmlkb3JyYXN0ZXIgZGVra2UgZGV0IHNhbW1lIG9tcsOlZGV0IHNvbSBkZSBrdW11bGF0aXZlIGlubmRhdGFyYXN0cmVuZS48L3A+PHA+SHZpcyBlbiBhbmdpdHQgdGVyc2tlbHZlcmRpIGVyIG1pbmRyZSBlbm4gdmVyZGllbiBpIGtvcnJpZG9ycmFzdGVyZXQsIHJldHVybmVyZXMgZW4gbWVsZGluZyBtZWQgZW4gYWR2YXJzZWwgb2cgdXRkYXRhcmFzdGVyZXQgdmlsIHbDpnJlIHRvbXQuPC9wPjxwPlJlc3VsdGVyZW5kZSBrb3JyaWRvcnJhc3RlciBrYW4gaW5uZWhvbGRlIGNlbGxlciBtZWQgbGl0dCBzdMO4cnJlIGt1bXVsYXRpdmUga29zdGFuZGVyIGVubiB0ZXJza2VsdmVyZGllbi4gRGV0dGUgZXIgZnJhIHJhc3RyZW5lIGZvciBtb3RzYXR0IHJldG5pbmcgc29tIGJydWtlciBjZWxsZXIgdGlsb3JkbmV0IGxpdHQgaMO4eWVyZSBrb3N0bmFkZXIgZW5uIHRlcnNrZWxlbiBmb3Igw6Uga255dHRlIGZyYWtvYmxlZGUgY2VsbGVyIHRpbCBrb3JyaWRvcmVuLjwvcD5cIixcblx0XHRnZW9tZXRyaWNNZWRpYW5OYW1lOiBcIkdlb21ldHJpc2sgbWVkaWFuXCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuU25pcDogXCJGdW5rc2pvbmVuIEdlb21ldHJpc2sgbWVkaWFuIGJlcmVnbmVyIGRlbiBnZW9tZXRyaXNrZSBtZWRpYW5lbiBww6UgdHZlcnMgYXYgcGlrc2xlciBpIGVuIHRpZHNzZXJpZSBhdiBmbGVyYsOlbmRzYmlsZGVyLlwiLFxuXHRcdGdlb21ldHJpY01lZGlhbkRlc2M6IFwiPHA+RnVua3Nqb25lbiByZWR1c2VyZXIgc3TDuHkgb2cgYXZ2aWsgaSB0aWRzc2VyaWVyIGF2IGJpbGRlciB2ZWQgYmVyZWduZSBlbiBnZW9tZXRyaXNrIG1lZGlhbnBpa3NlbCBmb3IgaHZlciBwaWtzZWxtYXRyaXNlIHDDpSB0dmVycyBhdiBiaWxkZXN0YWtrZW4uIEFsZ29yaXRtZW4gb3BwcmV0dGhvbGRlciBkZSBzcGVrdHJhbGUgcmVsYXNqb25lbmUgbWVsbG9tIGLDpW5kIGkgcGlrc2Vsc3Bla3RyZW5lIHNsaWsgYXQgdXRkYXRhZW5lIGthbiBicnVrZXMgaSBhbmFseXNlciwgZm9yIGVrc2VtcGVsIHZlZ2V0YXNqb25zaW5kZWtzZXIuPC9wPjxwPlNreWVyIG9nIHNreWdnZXIgc2thbCBtYXNrZXJlcyB2ZWQgaGplbHAgYXYgUUEtYsOlbmQgZm9yIGRhdGFzZXR0ZXQgZsO4ciBkZW5uZSBmdW5rc2pvbmVuIGJydWtlcy48L3A+PHA+SHZpcyBpbm5kYXRhYmlsZGV0IGVyIGZseXR0YWxsLCBmb3IgZWtzZW1wZWwgb3ZlcmZsYXRlcmVmbGVrcyBtZWQgdmVyZGllciBtZWxsb20gMCBvZyAxLCB2aWwgZW4gZXBzaWxvbnZlcmRpIHDDpSAwLDAwMSBnaSBrdmFsaXRldHNyZXN1bHRhdGVyLjwvcD5cIlxuXHR9LFxuXHRyZnhBcmdzOiB7XG5cdFx0cmFzdGVyTmFtZTogXCJSYXN0ZXJcIixcblx0XHRjb2xvclNjaGVtZVR5cGVOYW1lOiBcIkZhcmdldmFsZ3R5cGVcIixcblx0XHRjb2xvcm1hcE5hbWU6IFwiRmFyZ2VrYXJ0XCIsXG5cdFx0Y29sb3JtYXBOYW1lTmFtZTogXCJOYXZuIHDDpSBmYXJnZWthcnRcIixcblx0XHRjb2xvclJhbXBOYW1lOiBcIkZhcmdlcGFsZXR0XCIsXG5cdFx0Y29udHJhc3RPZmZzZXROYW1lOiBcIktvbnRyYXN0Zm9yc2t5dm5pbmdcIixcblx0XHRicmlnaHRuZXNzT2Zmc2V0TmFtZTogXCJMeXNzdHlya2Vmb3Jza3l2bmluZ1wiLFxuXHRcdG1ldGhvZE5hbWU6IFwiTWV0b2RlXCIsXG5cdFx0YmFuZE5hbWVzTmFtZTogXCJCw6VuZG5hdm5cIixcblx0XHRiYW5kV2F2ZWxlbmd0aHNOYW1lOiBcIkLDpW5kYsO4bGdlbGVuZ2RlclwiLFxuXHRcdGJhbmRJZHNOYW1lOiBcIkLDpW5kLUlELWVyXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25OYW1lOiBcIkLDpW5kaGFuZGxpbmcgbWFuZ2xlclwiLFxuXHRcdGNvbnZlcnNpb25QYXJhbWV0ZXJzTmFtZTogXCJLb252ZXJ0ZXJpbmdzcGFyYW1ldGVyZVwiLFxuXHRcdGhpbGxzaGFkZVR5cGVOYW1lOiBcIlRlcnJlbmdza3lnZ2V0eXBlXCIsXG5cdFx0YXppbXV0aE5hbWU6IFwiQXNpbXV0XCIsXG5cdFx0YWx0aXR1ZGVOYW1lOiBcIkjDuHlkZVwiLFxuXHRcdHNsb3BlVHlwZU5hbWU6IFwiU2thbGVyaW5nXCIsXG5cdFx0ekZhY3Rvck5hbWU6IFwiei1mYWt0b3JcIixcblx0XHRQU1Bvd2VyTmFtZTogXCJQaWtzZWxzdMO4cnJlbHNlc2VmZmVrdFwiLFxuXHRcdFBTWkZhY3Rvck5hbWU6IFwiUGlrc2Vsc3TDuHJyZWxzZXNmYWt0b3JcIixcblx0XHRyZW1vdmVFZGdlRWZmZWN0TmFtZTogXCJEZWFrdGl2ZXIgc3RhbmRhcmQga2FudHBpa3NlbGludGVycG9sYXNqb25cIixcblx0XHRmcm9tVW5pdE5hbWU6IFwiRnJhIGVuaGV0XCIsXG5cdFx0dG9Vbml0TmFtZTogXCJUaWwgZW5oZXRcIixcblx0XHRyYXN0ZXJUeXBlTmFtZTogXCJUeXBlXCIsXG5cdFx0bWluTmFtZTogXCJNaW5pbXVtIGZvciB1dGRhdGFcIixcblx0XHRtYXhOYW1lOiBcIk1ha3NpbXVtIGZvciB1dGRhdGFcIixcblx0XHRtaW5QZXJjZW50TmFtZTogXCJNaW5pbXVtIHByb3NlbnRrbGlwcFwiLFxuXHRcdG1heFBlcmNlbnROYW1lOiBcIk1ha3NpbXVtIHByb3NlbnRrbGlwcFwiLFxuXHRcdG51bWJlck9mU3RhbmRhcmREZXZpYXRpb25OYW1lOiBcIkFudGFsbCBzdGFuZGFyZGF2dmlrXCIsXG5cdFx0c2lnbW9pZFN0cmVuZ3RoTGV2ZWxOYW1lOiBcIlNpZ21vaWQtc3R5cmtlbml2w6VcIixcblx0XHRlc3RpbWF0ZVN0YXRzSGlzdG9ncmFtTmFtZTogXCJCZXJlZ24gc3RhdGlzdGlra1wiLFxuXHRcdERSQU5hbWU6IFwiSnVzdGVyaW5nIGF2IGR5bmFtaXNrIG9tcsOlZGVcIixcblx0XHRzdGF0aXN0aWNzTmFtZTogXCJTdGF0aXN0aWtrXCIsXG5cdFx0aGlzdG9ncmFtc05hbWU6IFwiSGlzdG9ncmFtbWVyXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbU5hbWU6IFwiRGVmaW5lciBzdGF0aXN0aWtrIG9nIGhpc3RvZ3JhbVwiLFxuXHRcdGNvbXB1dGVHYW1tYU5hbWU6IFwiQXV0b21hdGlzayBnYW1tYVwiLFxuXHRcdHVzZUdhbW1hTmFtZTogXCJCcnVrIGdhbW1hXCIsXG5cdFx0Z2FtbWFOYW1lOiBcIkdhbW1hXCIsXG5cdFx0aW5wdXROYW1lc05hbWU6IFwiTmF2blwiLFxuXHRcdGV4cHJlc3Npb25OYW1lOiBcIlV0dHJ5a2tcIixcblx0XHRjZWxsc2l6ZVR5cGVOYW1lOiBcIkNlbGxlc3TDuHJyZWxzZXN0eXBlXCIsXG5cdFx0ZXh0ZW50VHlwZU5hbWU6IFwiVXRzdHJla25pbmdzdHlwZVwiLFxuXHRcdGNsYXNzaWZpZXJEZWZpbml0aW9uRmlsZU5hbWU6IFwiQW5naSBkZWZpbmlzam9uc2ZpbFwiLFxuXHRcdHJhc3RlcjFOYW1lOiBcIlJhc3RlcjFcIixcblx0XHRyYXN0ZXIyTmFtZTogXCJSYXN0ZXIyXCIsXG5cdFx0cmFzdGVyM05hbWU6IFwiUmFzdGVyM1wiLFxuXHRcdHRydWVSYXN0ZXJOYW1lOiBcIlNhbnQgcmFzdGVyXCIsXG5cdFx0ZmFsc2VSYXN0ZXJOYW1lOiBcIlVzYW50IHJhc3RlclwiLFxuXHRcdG5vRGF0YUludGVycHJldGF0aW9uTmFtZTogXCJOb0RhdGEtdG9sa2luZ1wiLFxuXHRcdG5vRGF0YVZhbHVlc05hbWU6IFwiTm9EYXRhLXZlcmRpZXJcIixcblx0XHRpbmNsdWRlZFJhbmdlc05hbWU6IFwiSW5rbHVkZXJ0ZSBvbXLDpWRlclwiLFxuXHRcdGN1cnZhdHVyZVR5cGVOYW1lOiBcIkt1cnZhdHVydHlwZVwiLFxuXHRcdHJhc3RlcnNOYW1lOiBcIlJhc3RlcmVcIixcblx0XHRhdHRyaWJ1dGVUYWJsZU5hbWU6IFwiVGFiZWxsXCIsXG5cdFx0YXR0cmlidXRlVGFibGVUeXBlTmFtZTogXCJUYWJlbGx0eXBlXCIsXG5cdFx0cm93c05hbWU6IFwiQW50YWxsIHJhZGVyXCIsXG5cdFx0Y29sdW1uc05hbWU6IFwiQW50YWxsIGtvbG9ubmVyXCIsXG5cdFx0a2VybmVsTmFtZTogXCJLamVybmVcIixcblx0XHRtaXJyb3JFZGdlc05hbWU6IFwiU3BlaWxrYW50ZXJcIixcblx0XHRpbmZsdWVuY2VzTmFtZTogXCJQw6V2aXJrbmluZ2VyXCIsXG5cdFx0ZmllbGRzTmFtZTogXCJGZWx0ZXJcIixcblx0XHRyZW1hcHNOYW1lOiBcIlRpbG9yZG5lIHRhYmVsbCBww6Ugbnl0dFwiLFxuXHRcdGV2YWxGcm9tTmFtZTogXCJFdmFsdWVyaW5nc3NrYWxhIGZyYVwiLFxuXHRcdGV2YWxUb05hbWU6IFwiRXZhbHVlcmluZ3Nza2FsYSB0aWxcIixcblx0XHR3ZWlnaHRzTmFtZTogXCJWZWt0aW5nXCIsXG5cdFx0REVNTmFtZTogXCJERU1cIixcblx0XHRzaG9ydFJhbmdlSURXUmFkaXVzTmFtZTogXCJJRFctcmFkaXVzIG1lZCBrb3J0IHJla2tldmlkZGVcIixcblx0XHRtYXhWb2lkV2lkdGhOYW1lOiBcIlN0w7hyc3RlIGh1bGxzdMO4cnJlbHNlXCIsXG5cdFx0c2lnbWFHYXVzc2lhbk5hbWU6IFwiQWRhcHRpdiB1dGpldm5pbmdcIixcblx0XHRjb250b3VyVHlwZU5hbWU6IFwiSMO4eWRla3VydmV0eXBlXCIsXG5cdFx0ekJhc2VOYW1lOiBcInotYmFzZVwiLFxuXHRcdG51bWJlck9mQ29udG91cnNOYW1lOiBcIkFudGFsbCBow7h5ZGVrdXJ2ZXJcIixcblx0XHRjb250b3VySW50ZXJ2YWxOYW1lOiBcIkjDuHlkZWt1cnZlaW50ZXJ2YWxsXCIsXG5cdFx0bnRoQ29udG91ckxpbmVJbkJvbGROYW1lOiBcIk50aCBDb250b3VyTGluZSBpIGZldFwiLFxuXHRcdGZlYXR1cmVDbGFzc05hbWU6IFwiSW5uZGF0YWdlb29iamVrdGVyXCIsXG5cdFx0Y2xhc3NJbmRleEZpZWxkTmFtZTogXCJGZWx0XCIsXG5cdFx0cmVzb2x2ZU92ZXJsYXBNZXRob2ROYW1lOiBcIkzDuHMgb3ZlcmxhcHBpbmdzbWV0b2RlXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVOYW1lOiBcIlJlc2FtcGxpbmdzdHlwZVwiLFxuXHRcdGlucHV0Q2VsbHNpemVOYW1lOiBcIklubmRhdGFjZWxsZXN0w7hycmVsc2VcIixcblx0XHRvdXRwdXRDZWxsc2l6ZU5hbWU6IFwiVXRkYXRhY2VsbGVzdMO4cnJlbHNlXCIsXG5cdFx0cG9pbnRGZWF0dXJlQ2xhc3NOYW1lOiBcIlNlZWQtcHVua3RcIixcblx0XHRtYXhHcm93dGhSYWRpdXNGaWVsZE5hbWU6IFwiRmVsdCBmb3IgbWFrcy4gdmVrc3RyYWRpdXNcIixcblx0XHRzaW1pbGFyaXR5VGhyZXNob2xkRmllbGROYW1lOiBcIkxpa2hldCB0ZXJza2VsZmVsdFwiLFxuXHRcdGZpbGxWYWx1ZUZpZWxkTmFtZTogXCJGZWx0IGZvciB1dGZ5bGxpbmdzdmVyZGlcIixcblx0XHRzcGVjdHJhbERldGFpbE5hbWU6IFwiU3Bla3RyYWxkZXRhbGogWzEuLjIwXVwiLFxuXHRcdHNwYXRpYWxEZXRhaWxOYW1lOiBcIlJvbWxpZyBkZXRhbGogWzEuLjIwXVwiLFxuXHRcdG1pbk51bVBpeGVsc1BlclNlZ21lbnROYW1lOiBcIk1pbmltdW0gc2VnbWVudHN0w7hycmVsc2UgaSBwaWtzbGVyXCIsXG5cdFx0Ym91bmRhcmllc09ubHlOYW1lOiBcIkt1biBzZWdtZW50Z3JlbnNlclwiLFxuXHRcdHN0YXRpc3RpY3NUeXBlTmFtZTogXCJTdGF0aXN0aWtrdHlwZVwiLFxuXHRcdGZpbGxOb0RhdGFPbmx5TmFtZTogXCJGeWxsIGJhcmUgTm9EYXRhLXBpa3NsZXJcIixcblx0XHRpbnB1dERhdGFUeXBlTmFtZTogXCJJbm5kYXRhdHlwZVwiLFxuXHRcdGFuZ2xlUmVmZXJlbmNlU3lzdGVtTmFtZTogXCJWaW5rZWxyZWZlcmFuc2VzeXN0ZW1cIixcblx0XHRvdXRwdXREYXRhVHlwZU5hbWU6IFwiVXRkYXRhdHlwZVwiLFxuXHRcdGlucHV0U2FtcGxlUG9pbnRGZWF0dXJlQ2xhc3NOYW1lOiBcIklubmRhdGFla3NlbXBsZXJcIixcblx0XHR2YWx1ZUZpZWxkTmFtZTogXCJWZXJkaWZlbHRcIixcblx0XHRyYXN0ZXJJbmZvTmFtZTogXCJSYXN0ZXJpbmZvXCIsXG5cdFx0aW50ZXJwb2xhdGlvbk1ldGhvZE5hbWU6IFwiSW50ZXJwb2xlcmluZ3NtZXRvZGVcIixcblx0XHRyYWRpdXNOYW1lOiBcIlJhZGl1c1wiLFxuXHRcdHJhZGlhbmNlR2FpblZhbHVlc05hbWU6IFwiU3Ryw6VsaW5nc2ZvcnN0ZXJraW5nXCIsXG5cdFx0cmFkaWFuY2VCaWFzVmFsdWVzTmFtZTogXCJTdHLDpWxpbmdzdGlsbGVnZ1wiLFxuXHRcdHJlZmxlY3RlZEdhaW5WYWx1ZXNOYW1lOiBcIlJlZmxla3Nqb25zZmFrdG9yw7hrbmluZ1wiLFxuXHRcdHJlZmxlY3RlZEJpYXNWYWx1ZXNOYW1lOiBcIlJlZmxla3Nqb25zZmFrdG9yYXZ2aWtcIixcblx0XHRzdW5FbGV2YXRpb25OYW1lOiBcIlNvbGjDuHlkZSAoZ3JhZGVyKVwiLFxuXHRcdGFsYmVkb05hbWU6IFwiQWxiZWRvXCIsXG5cdFx0c2NhbGVGYWN0b3JOYW1lOiBcIk3DpWxlc3Rva2tmYWt0b3JcIixcblx0XHRvZmZzZXROYW1lOiBcIkZvcnNreXZuaW5nXCIsXG5cdFx0dGhyZXNob2xkVHlwZU5hbWU6IFwiVGVyc2tlbHR5cGVcIixcblx0XHR0aHJlc2hvbGRzTmFtZTogXCJUZXJza2xlclwiLFxuXHRcdHVuZGVmaW5lZENsYXNzTmFtZTogXCJVZGVmaW5lcnQga2xhc3NlXCIsXG5cdFx0bWluVmFsdWVOYW1lOiBcIk1pblwiLFxuXHRcdG1heFZhbHVlTmFtZTogXCJNYWtzXCIsXG5cdFx0b3BlcmF0aW9uTmFtZTogXCJPcGVyYXNqb25cIixcblx0XHRjbGlwcGluZ1R5cGVOYW1lOiBcIktsaXBwZW3DpXRlXCIsXG5cdFx0Y2xpcHBpbmdHZW9tZXRyeU5hbWU6IFwiR2VvbWV0cmkvcmFzdGVyIGZvciB1dGtsaXBwXCIsXG5cdFx0ZXh0ZW50TmFtZTogXCJVdGRhdGFvbWZhbmdcIixcblx0XHR1c2VJbnB1dEZlYXR1cmVHZW9tZXRyeU5hbWU6IFwiQnJ1ayBpbm5kYXRhZ2Vvb2JqZWt0ZXIgZm9yIGtsaXBwZWdlb21ldHJpXCIsXG5cdFx0cmVtYXBEZWZpbml0aW9uVHlwZU5hbWU6IFwiVGlsb3JkbmUgZGVmaW5pc2pvbnN0eXBlIHDDpSBueXR0XCIsXG5cdFx0aW5wdXRSYW5nZU5hbWU6IFwiSW5uZGF0YW9tcsOlZGVyXCIsXG5cdFx0b3V0cHV0VmFsdWVzTmFtZTogXCJVdGRhdGF2ZXJkaWVyXCIsXG5cdFx0bm9EYXRhUmFuZ2VOYW1lOiBcIk5vRGF0YS1vbXLDpWRlclwiLFxuXHRcdGlucHV0RmllbGROYW1lOiBcIklubmRhdGFmZWx0XCIsXG5cdFx0b3V0cHV0RmllbGROYW1lOiBcIlV0ZGF0YWZlbHRcIixcblx0XHRpbnB1dE1heEZpZWxkTmFtZTogXCJJbm5kYXRhbWFrc2ltdW1zZmVsdCAodmFsZ2ZyaXR0KVwiLFxuXHRcdHJlbWFwVGFibGVUeXBlTmFtZTogXCJUaWxvcmRuZSB0YWJlbGx0eXBlIHDDpSBueXR0XCIsXG5cdFx0YWxsb3dVbm1hdGNoZWROYW1lOiBcIlRpbGxhdCBpa2tlLXNhbXN2YXJlbmRlIHBpa3NlbHZlcmRpZXJcIixcblx0XHRjaGFuZ2VNaXNzaW5nVmFsdWVzVG9Ob0RhdGFOYW1lOiBcIkVuZHJlIG1hbmdsZW5kZSB2ZXJkaWVyIHRpbCBOb0RhdGFcIixcblx0XHR2aXNpYmxlQmFuZElETmFtZTogXCJTeW5saWcgYsOlbmQtSURcIixcblx0XHRpbmZyYXJlZEJhbmRJRE5hbWU6IFwiSW5mcmFyw7hkIGLDpW5kLUlEXCIsXG5cdFx0c2NpZW50aWZpY091dHB1dE5hbWU6IFwiVml0ZW5za2FwZWxpZ2UgdXRkYXRhXCIsXG5cdFx0YmFuZEluZGV4ZXNOYW1lOiBcIkLDpW5kaW5kZWtzZXJcIixcblx0XHRjb25zdGFudE5hbWU6IFwiS29uc3RhbnRcIixcblx0XHR3ZWlnaHROYW1lOiBcIlZla3RcIixcblx0XHRtaW5pbXVtTmFtZTogXCJNaW5pbXVtXCIsXG5cdFx0bWF4aW11bU5hbWU6IFwiTWFrc2ltdW1cIixcblx0XHRzb3VyY2VEYXRhTmFtZTogXCJLaWxkZXJhc3RlclwiLFxuXHRcdHNvdXJjZUZpZWxkTmFtZTogXCJLaWxkZWZlbHRcIixcblx0XHRjb3N0UmFzdGVyTmFtZTogXCJLb3N0bmFkc3Jhc3RlclwiLFxuXHRcdG1heERpc3RhbmNlTmFtZTogXCJNYWtzaW11bXNhdnN0YW5kXCIsXG5cdFx0dmFsdWVSYXN0ZXJOYW1lOiBcIlZlcmRpcmFzdGVyXCIsXG5cdFx0Y29zdE11bHRpcGxpZXJOYW1lOiBcIk11bHRpcGxpa2F0b3Igc29tIHNrYWwgYnJ1a2VzIHDDpSBrb3N0bmFkZXJcIixcblx0XHRzdGFydENvc3ROYW1lOiBcIlN0YXJ0a29zdG5hZFwiLFxuXHRcdGFjY3VtQ29zdFJlc2lzdGFuY2VSYXRlTmFtZTogXCJLdW11bGF0aXYga29zdG5hZHNtb3RzdGFuZHNncmFkXCIsXG5cdFx0Y2FwYWNpdHlOYW1lOiBcIkthcGFzaXRldFwiLFxuXHRcdHRyYXZlbERpcmVjdGlvbk5hbWU6IFwiUmVpc2VyZXRuaW5nXCIsXG5cdFx0Y2VsbFNpemVOYW1lOiBcIkNlbGxlc3TDuHJyZWxzZVwiLFxuXHRcdHBvcHVsYXRpb25GaWVsZE5hbWU6IFwiQmVmb2xrbmluZ3NmZWx0XCIsXG5cdFx0YXJlYVVuaXRzTmFtZTogXCJBcmVhbGVuaGV0ZXJcIixcblx0XHRvdXRwdXRWYWx1ZVR5cGVOYW1lOiBcIlV0ZGF0YWNlbGxldmVyZGllclwiLFxuXHRcdGJhcnJpZXJzTmFtZTogXCJJbm5kYXRhc3BlcnJlclwiLFxuXHRcdGRlc3RpbmF0aW9uRGF0YU5hbWU6IFwiTcOlbHJhc3RlclwiLFxuXHRcdGRlc3RpbmF0aW9uRmllbGROYW1lOiBcIk3DpWxmZWx0XCIsXG5cdFx0cGF0aFR5cGVOYW1lOiBcIlJlaXNlcnV0ZXR5cGVcIixcblx0XHRvYnNlcnZlckZlYXR1cmVzTmFtZTogXCJPYnNlcnZhc2pvbnNnZW9vYmpla3RlclwiLFxuXHRcdGFuYWx5c2lzTWV0aG9kTmFtZTogXCJBbmFseXNlbWV0b2RlXCIsXG5cdFx0YW5hbHlzaXNUeXBlTmFtZTogXCJBbmFseXNldHlwZVwiLFxuXHRcdHZlcnRpY2FsRXJyb3JOYW1lOiBcIlZlcnRpa2FsIGZlaWxcIixcblx0XHRyZWZyYWN0aXZpdHlDb2VmZmljaWVudE5hbWU6IFwiQnJ5dG5pbmdza29lZmZpc2llbnRcIixcblx0XHRzdXJmYWNlT2Zmc2V0TmFtZTogXCJPdmVyZmxhdGVmb3Jza3l2bmluZ1wiLFxuXHRcdG9ic2VydmVyRWxldmF0aW9uTmFtZTogXCJPYnNlcnZhdMO4cmjDuHlkZVwiLFxuXHRcdG9ic2VydmVyT2Zmc2V0TmFtZTogXCJPYnNlcnZhdMO4cmZvcnNreXZuaW5nXCIsXG5cdFx0aW5uZXJSYWRpdXNOYW1lOiBcIkluZHJlIHJhZGl1c1wiLFxuXHRcdGlubmVyUmFkaXVzSXMzRERpc3RhbmNlTmFtZTogXCJJbmRyZSByYWRpdXMgZXIgM0QtYXZzdGFuZFwiLFxuXHRcdG91dGVyUmFkaXVzTmFtZTogXCJZdHJlIHJhZGl1c1wiLFxuXHRcdG91dGVyUmFkaXVzSXMzRERpc3RhbmNlTmFtZTogXCJZdHJlIHJhZGl1cyBlciAzRC1hdnN0YW5kXCIsXG5cdFx0aG9yaXpvbnRhbFN0YXJ0QW5nbGVOYW1lOiBcIkhvcmlzb250YWwgc3RhcnR2aW5rZWxcIixcblx0XHRob3Jpem9udGFsRW5kQW5nbGVOYW1lOiBcIkhvcmlzb250YWwgc2x1dHR2aW5rZWxcIixcblx0XHR2ZXJ0aWNhbFVwcGVyQW5nbGVOYW1lOiBcIlZlcnRpa2FsIMO4dnJlIHZpbmtlbFwiLFxuXHRcdHZlcnRpY2FsTG93ZXJBbmdsZU5hbWU6IFwiVmVydGlrYWwgbmVkcmUgdmlua2VsXCIsXG5cdFx0em9uZURhdGFOYW1lOiBcIlNvbmVyYXN0ZXJcIixcblx0XHR6b25lRmllbGROYW1lOiBcIlNvbmVmZWx0XCIsXG5cdFx0aWdub3JlTm9EYXRhTmFtZTogXCJJZ25vcmVyIE5vRGF0YSBpIGJlcmVnbmluZ2VyXCIsXG5cdFx0dGVtcGVyYXR1cmVSYXN0ZXJOYW1lOiBcIlRlbXBlcmF0dXJyYXN0ZXJcIixcblx0XHRpblRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlRlbXBlcmF0dXJlbmhldGVyXCIsXG5cdFx0b3V0SGVhdEluZGV4VGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVmFybWVpbmRla3NlbmhldGVyXCIsXG5cdFx0cmVsYXRpdmVIdW1pZGl0eVJhc3Rlck5hbWU6IFwiUmVsYXRpdiBmdWt0aWdoZXRzcmFzdGVyXCIsXG5cdFx0b3V0V2luZENoaWxsVGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVmluZGZha3RvcmVuaGV0ZXJcIixcblx0XHR3aW5kU3BlZWRSYXN0ZXJOYW1lOiBcIlZpbmRoYXN0aWdoZXRzcmFzdGVyXCIsXG5cdFx0aW5XaW5kU3BlZWRVbml0c05hbWU6IFwiVmluZGhhc3RpZ2hldGVuaGV0ZXJcIixcblx0XHR2YWx1ZU5hbWU6IFwiVmVyZGlcIixcblx0XHRwcm9wZXJ0eU5hbWU6IFwiRWdlbnNrYXBzbmF2blwiLFxuXHRcdGpzb25OYW1lOiBcIk1ldGFkYXRhIEpTT05cIixcblx0XHR6b25lVGFibGVOYW1lOiBcIlNvbmVhdHRyaWJ1dHRhYmVsbFwiLFxuXHRcdGF0dHJpYnV0ZUZpZWxkTmFtZXM6IFwiQXR0cmlidXR0ZmVsdG5hdm5cIixcblx0XHRiYWNrZ3JvdW5kTmFtZTogXCJCYWtncnVubnN2ZXJkaVwiLFxuXHRcdHdoZXJlQ2xhdXNlTmFtZTogXCJXaGVyZS1zZXRuaW5nXCIsXG5cdFx0bWluaW11bVZhbHVlRmllbGROYW1lOiBcIk5hdm4gcMOlIG1pbmltdW1zdmVyZGlmZWx0XCIsXG5cdFx0bWF4aW11bVZhbHVlRmllbGROYW1lOiBcIk5hdm4gcMOlIG1ha3NpbXVtc3ZlcmRpZmVsdFwiLFxuXHRcdG91dFZhbHVlRmllbGROYW1lOiBcIk5hdm4gcMOlIHV0ZGF0YXZlcmRpZmVsdFwiLFxuXHRcdGRlZmF1bHRWYWx1ZU5hbWU6IFwiU3RhbmRhcmQgdXRkYXRhdmVyZGlcIixcblx0XHRjb252ZXJzaW9uTWF0cml4TmFtZTogXCJLb252ZXJ0ZXJpbmdzbWF0cmlzZVwiLFxuXHRcdElzUHNldWRvQ29sb3JPdXRwdXROYW1lOiBcIkVyIHVla3RlIGZhcmdldXRkYXRhXCIsXG5cdFx0dW5tYXBwZWRBc1JhbmRvbUNvbG9yTmFtZTogXCJUaWxkZWwgZmFyZ2VyIHRpbGZlbGRpZyB0aWwgcGlrc2xlciBzb20gaWtrZSBlciB0aWxvcmRuZXRcIixcblx0XHRkaXN0YW5jZU1ldGhvZE5hbWU6IFwiQXZzdGFuZHNtZXRvZGVcIixcblx0XHRmbG93RGlyUmFzdGVyTmFtZTogXCJTdHLDuG1uaW5nc3JldG5pbmdzcmFzdGVyXCIsXG5cdFx0cG91clBvaW50TmFtZTogXCJVdGzDuHBzcHVua3RyYXN0ZXJcIixcblx0XHRwb3VyUG9pbnRGaWVsZE5hbWU6IFwiVXRsw7hwc3B1bmt0ZmVsdFwiLFxuXHRcdGNvbnN0YW50Wk5hbWU6IFwiS29uc3RhbnQgWlwiLFxuXHRcdHpPZmZzZXROYW1lOiBcIlotZm9yc2t5dm5pbmdcIixcblx0XHRnZW9JZE5hbWU6IFwiR2VvaWRlXCIsXG5cdFx0Y2FsaWJyYXRpb25UeXBlTmFtZTogXCJLYWxpYnJlcmluZ3N0eXBlXCIsXG5cdFx0ZmlsdGVyVHlwZU5hbWU6IFwiRmlsdGVydHlwZVwiLFxuXHRcdGZpbHRlclNpemVOYW1lOiBcIkZpbHRlcnN0w7hycmVsc2VcIixcblx0XHRub2lzZU1vZGVsTmFtZTogXCJTdMO4eW1vZGVsbFwiLFxuXHRcdG5vaXNlVmFyaWFuY2VOYW1lOiBcIlN0w7h5dmFyaWFuc1wiLFxuXHRcdGFkZGl0aXZlTm9pc2VNZWFuTmFtZTogXCJNaWRkZWx2ZXJkaSBmb3IgYWRkaXRpdiBzdMO4eVwiLFxuXHRcdG11bHRpcGxpY2F0aXZlTm9pc2VNZWFuTmFtZTogXCJNaWRkZWx2ZXJkaSBmb3IgbXVsdGlwbGlrYXRpdiBmb3Igc3TDuHlcIixcblx0XHRudW1iZXJvZkxvb2tzTmFtZTogXCJBbnRhbGwgdXRzZWVuZGVyXCIsXG5cdFx0ZGFtcGluZ0ZhY3Rvck5hbWU6IFwiRGVtcGluZ3NmYWt0b3JcIixcblx0XHRtYXNrUmFzdGVyTmFtZTogXCJNYXNrZXJhc3RlclwiLFxuXHRcdG5pYmJsZVZhbHVlc05hbWU6IFwiQnJ1ayBOb0RhdGEtdmVyZGllciBodmlzIGRlIGVyIG7DpnJtZXN0ZSBuYWJvXCIsXG5cdFx0bmliYmxlTm9EYXRhTmFtZTogXCJOaWJibGUgTm9EYXRhLWNlbGxlclwiLFxuXHRcdHpMaW1pdE5hbWU6IFwiWi1ncmVuc2VcIixcblx0XHRmbG93RGlyZWN0aW9uVHlwZU5hbWU6IFwiVHlwZSBzdHLDuG1uaW5nc3JldG5pbmdcIixcblx0XHR3ZWlnaHRSYXN0ZXJOYW1lOiBcIlZla3RyYXN0ZXJcIixcblx0XHRmb3JjZUVkZ2VOYW1lOiBcIlR2aW5nIGFsbGUga2FudGNlbGxlciB0aWwgw6Ugc3Ryw7htbWUgdXRvdmVyXCIsXG5cdFx0c3RyZWFtUmFzdGVyTmFtZTogXCJTdHLDuG1yYXN0ZXJcIixcblx0XHRzdXJmYWNlUmFzdGVyTmFtZTogXCJPdmVyZmxhdGVyYXN0ZXJcIixcblx0XHRjb252ZXJzaW9uVHlwZTogXCJLb252ZXJ0ZXJpbmdzdHlwZVwiLFxuXHRcdGRpc3RhbmNlUmFzdGVyMTogXCJBdnN0YW5kcmFzdGVyIDFcIixcblx0XHRkaXN0YW5jZVJhc3RlcjI6IFwiQXZzdGFuZHJhc3RlciAyXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyOiBcIktvc3RuYWQvYXZzdGFuZHNyYXN0ZXJcIixcblx0XHRjb3N0QmFja2xpbmtSYXN0ZXI6IFwiVGlsYmFrZWtvYmxpbmdzcmFzdGVyIGZvciBrb3N0bmFkXCIsXG5cdFx0b3ZlcnJpZGVzTmFtZTogXCJPdmVyc3R5cmVyXCIsXG5cdFx0ZmllbGROYW1lOiBcIkZlbHRcIixcblx0XHRzaWduYXR1cmVGaWxlT3JVcmw6IFwiU2lnbmF0dXJmaWwgZWxsZXIgVVJMXCIsXG5cdFx0cmVkTmFtZTogXCJSw7hkXCIsXG5cdFx0Z3JlZW5OYW1lOiBcIkdyw7hublwiLFxuXHRcdGJsdWVOYW1lOiBcIkJsw6VcIixcblx0XHRpbmZyYXJlZE5hbWU6IFwiSW5mcmFyw7hkXCIsXG5cdFx0cGFuY2hyb21hdGljTmFtZTogXCJQYW5rcm9tYXRpc2tcIixcblx0XHRtdWx0aXNwZWN0cmFsTmFtZTogXCJNdWx0aXNwZWt0cmFsXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1R5cGU6IFwiVHlwZSBwYW5rcm9tYXRpc2sgb3Bwc2thcnBpbmdcIixcblx0XHRzZW5zb3JOYW1lOiBcIlNlbnNvclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VOYW1lOiBcIlJvbWxpZyByZWZlcmFuc2VcIixcblx0XHR4Q2VsbHNpemVOYW1lOiBcIlgtY2VsbGVzdMO4cnJlbHNlXCIsXG5cdFx0eUNlbGxzaXplTmFtZTogXCJZLWNlbGxlc3TDuHJyZWxzZVwiLFxuXHRcdHhPcmlnaW5OYW1lOiBcIlgtcmVnaXN0cmVyaW5nc3B1bmt0XCIsXG5cdFx0eU9yaWdpbk5hbWU6IFwiWS1yZWdpc3RyZXJpbmdzcHVua3RcIixcblx0XHRwZXJjZW50aWxlTmFtZTogXCJQZXJzZW50aWx2ZXJkaVwiLFxuXHRcdG5laWdoYm9yaG9vZFR5cGU6IFwiTmFib3R5cGVcIixcblx0XHR3aWR0aE5hbWU6IFwiQnJlZGRlXCIsXG5cdFx0aGVpZ2h0TmFtZTogXCJIw7h5ZGVcIixcblx0XHRzdGFydEFuZ2xlTmFtZTogXCJTdGFydHZpbmtlbFwiLFxuXHRcdGVuZEFuZ2xlTmFtZTogXCJTbHV0dHZpbmtlbFwiLFxuXHRcdG5laWdoYm9yaG9vZFZhbHVlczogXCJOYWJvbGFnc3ZlcmRpZXJcIixcblx0XHRob3Jpem9udGFsUmFzdGVyOiBcIkhvcmlzb250YWx0IHJhc3RlclwiLFxuXHRcdGhvcml6b250YWxGYWN0b3I6IFwiSG9yaXNvbnRhbCBmYWt0b3JcIixcblx0XHR2ZXJ0aWNhbFJhc3RlcjogXCJWZXJ0aWthbHQgcmFzdGVyXCIsXG5cdFx0dmVydGljYWxGYWN0b3I6IFwiVmVydGlrYWwgZmFrdG9yXCIsXG5cdFx0c3RyZWFtUmFzdGVyOiBcIlN0csO4bXJhc3RlclwiLFxuXHRcdGZsb3dEaXJSYXN0ZXI6IFwiU3Ryw7htbmluZ3NyZXRuaW5nc3Jhc3RlclwiLFxuXHRcdG51bWJlck5laWdoYm9yQ2VsbHM6IFwiQW50YWxsIG5hYm9jZWxsZXJcIixcblx0XHR6b25lQ29ubmVjdGl2aXR5OiBcIlNvbmV0aWxrb2JsaW5nXCIsXG5cdFx0YWRkTGlua0JlaGF2aW9yOiBcIkxlZ2cgdGlsIGtvYmxpbmdcIixcblx0XHRleGNsdWRlZFZhbHVlOiBcIlV0ZWxhdHQgdmVyZGlcIixcblx0XHRjb25zdGFudEZpbGxDaGVjazogXCJHZW5lcmVyIGZ5bGxyYXN0ZXIgZnJhIGtvbnN0YW50XCIsXG5cdFx0ZmlsbFJhc3RlcjogXCJGeWxscmFzdGVyXCIsXG5cdFx0Y29uc3RhbnRGaWxsVmFsdWU6IFwiS29uc3RhbnQgdmVyZGlcIixcblx0XHRpbnB1dEJpdFBvc2l0aW9uczogXCJJbm5kYXRhYml0XCIsXG5cdFx0b3V0cHV0Qml0UG9zaXRpb25zOiBcIlV0ZGF0YWJpdFwiLFxuXHRcdGRpc3RhbmNlVHlwZU5hbWU6IFwiQXZzdGFuZHN0eXBlXCIsXG5cdFx0YmFycmllckRhdGFOYW1lOiBcIlJhc3RlcmJhcnJpZXJlclwiLFxuXHRcdHBvdXJQb2ludERhdGFOYW1lOiBcIlV0bMO4cHNwdW5rdHJhc3RlclwiLFxuXHRcdGFjY3VtdWxhdGlvblJhc3Rlck5hbWU6IFwiUmFzdGVyIG1lZCBha2t1bXVsZXJ0IGZseXRcIixcblx0XHRzbmFwRGlzdGFuY2VOYW1lOiBcIlNuYXBwYXZzdGFuZFwiLFxuXHRcdG9yZGVyTWV0aG9kTmFtZTogXCJPcmRyZW1ldG9kZVwiLFxuXHRcdGRpcmVjdGlvbk1lYXN1cmVtZW50TmFtZTogXCJNw6VsZXJldG5pbmdcIixcblx0XHRwcm9jZXNzQXNNdWx0aWJhbmQ6IFwiQmVoYW5kbGUgc29tIGZsZXJiw6VuZFwiLFxuXHRcdHByb2Nlc3NNdWx0aWRpbWVuc2lvbmFsOiBcIkJlaGFuZGxlIHNvbSBmbGVyZGltZW5zam9uYWxcIixcblx0XHRmb3JjZUZsb3dEaXJlY3Rpb25Db252ZW50aW9uOiBcIlR2aW5nIHN0csO4bW5pbmdzcmV0bmluZ3Nrb252ZW5zam9uIGZvciBiYWNrbGluay1yYXN0ZXJcIixcblx0XHRpbml0aWFsQWNjdW11bGF0aW9uOiBcIkbDuHJzdGUgYWtrdW11bGVyaW5nXCIsXG5cdFx0bWF4aW11bUFjY3VtdWxhdGlvbjogXCJNYWtzaW1hbCBha2t1bXVsZXJpbmdcIixcblx0XHRzb3VyY2VMb2NhdGlvbkJhbmRzOiBcIkdlbmVyZXIga2lsZGVyYWQgb2cgLWtvbG9ubmUgc29tIGVrc3RyYSBiw6VuZCBpIHV0ZGF0YVwiLFxuXHRcdGJhY2tEaXJlY3Rpb25CYW5kOiBcIkdlbmVyZXIgdGlsYmFrZXJldG5pbmcgc29tIGVrc3RyYSBiw6VuZCBpIHV0ZGF0YVwiLFxuXHRcdG51bWJlck9mQ2VsbHM6IFwiQW50YWxsIGNlbGxlclwiLFxuXHRcdHpvbmVWYWx1ZXM6IFwiU29uZXZlcmRpZXJcIixcblx0XHRzaHJpbmtNZXRob2Q6IFwiRm9ybWluc2sgbWV0b2RlXCIsXG5cdFx0ZXhwYW5kTWV0aG9kOiBcIlV0dmlkZSBtZXRvZGVcIixcblx0XHRpbnB1dFNwZWN0cmFsUHJvZmlsZVR5cGU6IFwiU3Bla3RyYWxwcm9maWx0eXBlXCIsXG5cdFx0c3BlY3RyYWxQcm9maWxlRmlsZU5hbWU6IFwiU3Bla3RyYWxwcm9maWxcIixcblx0XHR0cmFpbmluZ0ZlYXR1cmVGaWxlTmFtZTogXCJPcHBsw6ZyaW5nc2Z1bmtzam9uXCIsXG5cdFx0bm9uTmVnYXRpdmU6IFwiSWtrZS1uZWdhdGl2XCIsXG5cdFx0c3VtVG9PbmU6IFwiU3VtbWVyIHRpbCDDqW5cIixcblx0XHRyYW5kb21EaXN0cmlidXRpb246IFwiRGlzdHJpYnVzam9uXCIsXG5cdFx0bWVhbk5hbWU6IFwiR2plbm5vbXNuaXR0XCIsXG5cdFx0cHJvYmFiaWxpdHlOYW1lOiBcIlNhbm5zeW5saWdoZXRcIixcblx0XHRhbHBoYU5hbWU6IFwiQWxmYVwiLFxuXHRcdGJldGFOYW1lOiBcIkJldGFcIixcblx0XHRyTmFtZTogXCJyXCIsXG5cdFx0bk5hbWU6IFwiTlwiLFxuXHRcdHNlZWQ6IFwiVXRnYW5nc3ZlcmRpXCIsXG5cdFx0cmFuZG9tTnVtYmVyR2VuZXJhdG9yOiBcIkdlbmVyYXRvciBmb3IgdGlsZmVsZGlnZSB0YWxsXCIsXG5cdFx0Y2VsbEZhY3RvcjogXCJDZWxsZWZha3RvclwiLFxuXHRcdGFnZ3JlZ2F0aW9uVHlwZTogXCJBZ2dyZWdlcmluZ3N0ZWtuaWtrXCIsXG5cdFx0ZXh0ZW50SGFuZGxpbmc6IFwiVXR2aWQgdXRzdHJla25pbmcgaHZpcyBuw7hkdmVuZGlnXCIsXG5cdFx0dHJlbmRBbmFseXNpc0RpbWVuc2lvbk5hbWU6IFwiRGltZW5zam9uc25hdm5cIixcblx0XHR0cmVuZEFuYWx5c2lzVHlwZTogXCJUcmVuZHR5cGVcIixcblx0XHRoYXJtb25pY0ZyZXF1ZW5jeTogXCJIYXJtb25pc2sgZnJla3ZlbnNcIixcblx0XHRwb2x5bm9taWFsT3JkZXI6IFwiUG9seW5vbWdyYWRcIixcblx0XHRjeWNsZUxlbmd0aE5hbWU6IFwiTGVuZ3RoIG9mIEN5Y2xlXCIsXG5cdFx0dHJlbmRBbmFseXNpc1JNU0U6IFwiUk1TRVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNSMjogXCJSLVNxdWFyZWRcIixcblx0XHR0cmVuZEFuYWx5c2lzU2xvcGVQVmFsdWU6IFwiUC1WYWx1ZSBvZiBTbG9wZSBDb2VmZmljaWVudHNcIixcblx0XHR0cmVuZEFuYWx5c2lzU2Vhc29uYWxQZXJpb2Q6IFwiw4Vyc3RpZFwiLFxuXHRcdGN5Y2xlVW5pdE5hbWU6IFwiQ3ljbGUgVW5pdFwiLFxuXHRcdHByZWRpY3REaW1lbnNpb25WYWx1ZXM6IFwiVmVyZGllclwiLFxuXHRcdGRpbWVuc2lvbkRlZmluaXRpb25UeXBlOiBcIkRpbWVuc2pvbnNkZWZpbmlzam9uXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvblN0YXJ0OiBcIlN0YXJ0XCIsXG5cdFx0cHJlZGljdERpbWVuc2lvbkVuZDogXCJTbHV0dFwiLFxuXHRcdHByZWRpY3REaW1lbnNpb25JbnRlcnZhbDogXCJWZXJkaWludGVydmFsbFwiLFxuXHRcdGRpbWVuc2lvblVuaXQ6IFwiRW5oZXRcIixcblx0XHRpbnRlcnBvbGF0aW9uQ2VsbHNpemVOYW1lOiBcIkNlbGxlc3TDuHJyZWxzZSBmb3IgaW50ZXJwb2xlcmluZ1wiLFxuXHRcdHZhcmlhYmxlTmFtZTogXCJWYXJpYWJsZXJcIixcblx0XHRkaW1lbnNpb25sZXNzTmFtZTogXCJEaW1lbnNpb25sZXNzXCIsXG5cdFx0bWRpbURlZmluaXRpb246IFwiRGltZW5zaW9uIERlZmluaXRpb25cIixcblx0XHRkaW1lbnNpb25OYW1lOiBcIkRpbWVuc2pvblwiLFxuXHRcdGl0ZXJhdGlvblN0YXJ0OiBcIlN0YXJ0IG9mIGZpcnN0IGl0ZXJhdGlvblwiLFxuXHRcdGl0ZXJhdGlvbkVuZDogXCJFbmQgb2YgZmlyc3QgaXRlcmF0aW9uXCIsXG5cdFx0aW50ZXJ2YWxTdGFydDogXCJTdGFydCBww6UgaW50ZXJ2YWxsXCIsXG5cdFx0aW50ZXJ2YWxFbmQ6IFwiU2x1dHQgcMOlIGludGVydmFsbFwiLFxuXHRcdHN0ZXBOYW1lOiBcIlRyaW5uXCIsXG5cdFx0cmFuZ2VzTmFtZTogXCJSYW5nZXNcIixcblx0XHRtaW5WYWx1ZTogXCJNaW5pbXVtIFZhbHVlXCIsXG5cdFx0bWF4VmFsdWU6IFwiTWF4aW11bSBWYWx1ZVwiLFxuXHRcdGNoYW5nZUFuYWx5c2lzUmFzdGVyTmFtZTogXCJFbmRyZSBhbmFseXNlcmFzdGVyXCIsXG5cdFx0Y2hhbmdlVHlwZU5hbWU6IFwiQ2hhbmdlIFR5cGVcIixcblx0XHRzZWdtZW50RGF0ZTogXCJTZWdtZW50ZGF0b1wiLFxuXHRcdGNoYW5nZURpcmVjdGlvbk5hbWU6IFwiRW5kcmUgcmV0bmluZ1wiLFxuXHRcdG1heE51bUNoYW5nZXNOYW1lOiBcIk1heGltdW0gTnVtYmVyIG9mIENoYW5nZXNcIixcblx0XHRmaWx0ZXJCeVllYXI6IFwiRmlsdHJlciBldHRlciDDpXJcIixcblx0XHRtaW5pbXVtWWVhcjogXCJNaW5pbXVtc3ZlcmRpXCIsXG5cdFx0bWF4aW11bVllYXI6IFwiTWFrc2ltdW1zdmVyZGlcIixcblx0XHRmaWx0ZXJCeUR1cmF0aW9uOiBcIkZpbHRyZXIgZXR0ZXIgdmFyaWdoZXRcIixcblx0XHRtaW5pbXVtRHVyYXRpb246IFwiTWluaW11bXN2YXJpZ2hldFwiLFxuXHRcdG1heGltdW1EdXJhdGlvbjogXCJNYWtzaW11bXN2YXJpZ2hldFwiLFxuXHRcdGZpbHRlckJ5TWFnbml0dWRlOiBcIkZpbHRyZXIgZXR0ZXIgc3TDuHJyZWxzZVwiLFxuXHRcdG1pbmltdW1NYWduaXR1ZGU6IFwiTWluaW11bXNzdMO4cnJlbHNlXCIsXG5cdFx0bWF4aW11bU1hZ25pdHVkZTogXCJNYWtzaW11bXNzdMO4cnJlbHNlXCIsXG5cdFx0ZmlsdGVyQnlTdGFydFZhbHVlOiBcIkZpbHRyZXIgZXR0ZXIgc3RhcnR2ZXJkaVwiLFxuXHRcdG1pbmltdW1TdGFydFZhbHVlOiBcIk1pbmltdW0gc3RhcnR2ZXJkaVwiLFxuXHRcdG1heGltdW1TdGFydFZhbHVlOiBcIk1ha3NpbXVtIHN0YXJ0dmVyZGlcIixcblx0XHRmaWx0ZXJCeUVuZFZhbHVlOiBcIkZpbHRyZXIgZXR0ZXIgc2x1dHR2ZXJkaVwiLFxuXHRcdG1pbmltdW1FbmRWYWx1ZTogXCJNaW5pbXVtIHNsdXR0dmVyZGlcIixcblx0XHRtYXhpbXVtRW5kVmFsdWU6IFwiTWFrc2ltdW0gc2x1dHR2ZXJkaVwiLFxuXHRcdG1vZGVsVHlwZU5hbWU6IFwiTW9kZWxsdHlwZVwiLFxuXHRcdGZyb21SYXN0ZXJOYW1lOiBcIkZyYS1yYXN0ZXJcIixcblx0XHR0b1Jhc3Rlck5hbWU6IFwiVGlsLXJhc3RlclwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VNZXRob2Q6IFwiQ29tcHV0ZSBDaGFuZ2UgTWV0aG9kXCIsXG5cdFx0ZnJvbUNsYXNzVmFsdWVzOiBcIkZyYS1rbGFzc2V2ZXJkaWVyIChmLmVrcy46IDIgNSlcIixcblx0XHR0b0NsYXNzVmFsdWVzOiBcIlRpbC1rbGFzc2V2ZXJkaWVyIChmLmVrcy46IDIgNSlcIixcblx0XHRrZWVwTWV0aG9kOiBcIkZpbHRyZXJpbmdzbWV0b2RlXCIsXG5cdFx0dXNlQ29sb3JNZXRob2Q6IFwiRGVmaW5lciBvdmVyZ2FuZ3NmYXJnZXJcIixcblx0XHRkZXRlY3RDaGFuZ2VCYW5kczogXCJCw6VuZCBmb3Igw6Ugb3BwZGFnZSBlbmRyaW5nIChzdGFydCBww6UgMClcIixcblx0XHR0bWFza0JhbmRzOiBcIkLDpW5kIGZvciB0ZW1wb3LDpnIgbWFza2VyaW5nIChzdGFydCBww6UgMClcIixcblx0XHRjaGlTcXVhcmVkVGhyZXNob2xkOiBcIkNoaS1zcXVhcmVkIFRocmVzaG9sZCBmb3IgRGV0ZWN0IENoYW5nZVwiLFxuXHRcdG1pbkFub21hbHk6IFwiTWluaW11bSBDb25zZWN1dGl2ZSBBbm9tYWx5IE9ic2VydmF0aW9uc1wiLFxuXHRcdHVwZGF0aW5nRnJlcXVlbmN5OiBcIlVwZGF0aW5nIEZpdHRpbmcgRnJlcXVlbmN5IChpbiB5ZWFycylcIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvblJhc3Rlck5hbWU6IFwiUmFzdGVyIGZvciBhdnN0YW5kc2Fra3VtdWxlcmluZ1wiLFxuXHRcdGNvc3RCYWNrZGlyZWN0aW9uUmFzdGVyTmFtZTogXCJSYXN0ZXIgZm9yIHRpbGJha2VyZXRuaW5nIGVsbGVyIHN0csO4bW5pbmdzcmV0bmluZ1wiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25OYW1lOiBcIlJhc3RlcnNhbWxpbmdcIixcblx0XHRpdGVtRnVuY3Rpb25OYW1lOiBcIkVsZW1lbnRmdW5rc2pvblwiLFxuXHRcdGFnZ3JlZ2F0aW9uRnVuY3Rpb25OYW1lOiBcIkFnZ3JlZ2VyaW5nc2Z1bmtzam9uXCIsXG5cdFx0cHJvY2Vzc2luZ0Z1bmN0aW9uTmFtZTogXCJCZWhhbmRsaW5nc2Z1bmtzam9uXCIsXG5cdFx0YWdncmVnYXRpb25EZWZpbml0aW9uTmFtZTogXCJBZ2dyZWdlcmluZ3NkZWZpbmlzam9uXCIsXG5cdFx0cXVlcnlHZW9tZXRyeU5hbWU6IFwiU3DDuHJyaW5nc2dlb21ldHJpXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25aZXJvRmFjdG9yOiBcIk51bGxmYWt0b3JcIixcblx0XHRmYWN0b3JGdW5jdGlvbkN1dEFuZ2xlOiBcIlNuaXR0dmlua2VsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TaWRlRmFjdG9yOiBcIlNpZGVmYWt0b3JcIixcblx0XHRmYWN0b3JGdW5jdGlvblNsb3BlOiBcIkhlbGxpbmdcIixcblx0XHRmYWN0b3JGdW5jdGlvbkxvd0N1dEFuZ2xlOiBcIkxhdiBzbml0dHZpbmtlbFwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSGlnaEN1dEFuZ2xlOiBcIkjDuHkgc25pdHR2aW5rZWxcIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvc1Bvd2VyOiBcIkNvc2ludXMgb3BwaMO4eWRcIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY1Bvd2VyOiBcIlNla2FudCBvcHBow7h5ZFwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uVGFibGVQYXRoOiBcIlRhYmVsbGJhbmVcIixcblx0XHRwcm9jZXNzaW5nQmFuZDogXCJCZWhhbmRsaW5nc2LDpW5kXCIsXG5cdFx0cHJvY2Vzc2luZ0JhbmROYW1lOiBcIkJlaGFuZGxlciBiw6VuZG5hdm5cIixcblx0XHRzbmFwcGluZ0RhdGU6IFwiRmVzdGluZ3NkYXRvXCIsXG5cdFx0bWF4TnVtU2VnbWVudHM6IFwiTWFrc2ltYWx0IGFudGFsbCBzZWdtZW50ZXJcIixcblx0XHR2ZXJ0ZXhDb3VudE92ZXJzaG9vdDogXCJPdmVyc2t5dGVuZGUgYW50YWxsIGtuZWtrcHVua3RlclwiLFxuXHRcdHNwaWtlVGhyZXNob2xkOiBcIlNwaWtlLXRlcnNrZWxcIixcblx0XHRyZWNvdmVyeVRocmVzaG9sZDogXCJUZXJza2VsIGZvciBnamVub3BwcmV0dGluZ1wiLFxuXHRcdG1pbk51bU9iczogXCJNaW5pbXVtc2FudGFsbCBvYnNlcnZhc2pvbmVyXCIsXG5cdFx0cFZhbHVlVGhyZXNob2xkOiBcIlRlcnNrZWwgZm9yIHAtdmVyZGlcIixcblx0XHRiZXN0TW9kZWxQcm9wb3J0aW9uOiBcIkJlc3RlIG1vZGVsbHByb3BvcnNqb25cIixcblx0XHRwcmV2ZW50T25lWWVhclJlY292ZXJ5OiBcIkhpbmRyZSBldHQgw6VycyBnamVub3BwcmV0dGluZ1wiLFxuXHRcdHJlY292ZXJ5SW5jcmVhc2VUcmVuZDogXCJHamVub3BwcmV0dGluZyBoYXIgc3RpZ2VuZGUgdHJlbmRcIixcblx0XHRvdXRwdXRPdGhlckJhbmRzOiBcIkFuZHJlIGLDpW5kIHNvbSB1dGRhdGFcIixcblx0XHRzb3J0VHlwZTogXCJTb3J0ZXJpbmdzdHlwZVwiLFxuXHRcdG51bWJlck9mUnVuczogXCJLasO4ciB1dHZpZGVsc2Ugb2cga3J5bXBpbmcgdG8gZ2FuZ2VyXCIsXG5cdFx0cGVyY2VudGlsZVZhbHVlOiBcIlBlcnNlbnRpbHZlcmRpXCIsXG5cdFx0cGVyY2VudGlsZUludGVycG9sYXRpb25UeXBlOiBcIlR5cGUgaW50ZXJwb2xhc2pvbiBhdiBwZXJzZW50aWxcIixcblx0XHRyYXN0ZXJJbmZvUHJvcGVydHk6IFwiRWllbmRvbVwiLFxuXHRcdHJhc3RlckluZm9WYWx1ZTogXCJWZXJkaVwiLFxuXHRcdHJhc3RlckluZm9Db2x1bW5zOiBcIktvbG9ubmVyXCIsXG5cdFx0cmFzdGVySW5mb1Jvd3M6IFwiUmFkZXJcIixcblx0XHRyYXN0ZXJJbmZvQmFuZENvdW50OiBcIkFudGFsbCBiw6VuZFwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFNpemVYOiBcIkNlbGxlc3TDuHJyZWxzZcKgWFwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFNpemVZOiBcIkNlbGxlc3TDuHJyZWxzZcKgWVwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFR5cGU6IFwiUGlrc2VsdHlwZVwiLFxuXHRcdHJhc3RlckV4dGVudFRvcDogXCJUb3BwXCIsXG5cdFx0cmFzdGVyRXh0ZW50Qm90dG9tOiBcIkJ1bm5cIixcblx0XHRyYXN0ZXJFeHRlbnRMZWZ0OiBcIlZlbnN0cmVcIixcblx0XHRyYXN0ZXJFeHRlbnRSaWdodDogXCJIw7h5cmVcIixcblx0XHRyYXN0ZXJTdGF0aXN0aWNzTm90Q2FsY3VsYXRlZDogXCJTdGF0aXN0aWtrIGVyIGlra2UgYmVyZWduZXQuXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVByb2plY3Rpb246IFwiUHJvamVrc2pvblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa2lkOiBcIldLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0V2tpZDogXCJGb3JyaWdlIFdLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlV2t0OiBcIldLVFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VWY3NXa2lkOiBcIlZDU1dLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0VmNzV2tpZDogXCJGb3JyaWdlIFZDU1dLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQXV0aG9yaXR5OiBcIkF1dG9yaXRldFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMaW5lYXJVbml0OiBcIkxpbmXDpnIgZW5oZXRcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQW5ndWxhclVuaXQ6IFwiVmlua2VsZW5oZXRcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VFYXN0aW5nOiBcIkZhbHNrIMO4c3QtdmVyZGlcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VOb3J0aGluZzogXCJGYWxzayBub3JkLXZlcmRpXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUNlbnRyYWxNZXJpZGlhbjogXCJTZW50cmFsbWVyaWRpYW5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlUHJpbWVNZXJpZGlhbjogXCJOdWxsbWVyaWRpYW5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3RhbmRhcmRQYXJhbGxlbDE6IFwiU3RhbmRhcmRwYXJhbGxlbGzCoDFcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3RhbmRhcmRQYXJhbGxlbDI6IFwiU3RhbmRhcmRwYXJhbGxlbGzCoDJcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0aXR1ZGVPZk9yaWdpbjogXCJCcmVkZGVncmFkIGZvciB1dGdhbmdzcHVua3RcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQXV4aWxpYXJ5U3BoZXJlVHlwZTogXCJBdXhpbGlhcnkgU3BoZXJlLXR5cGVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRGF0dW06IFwiTnVsbHB1bmt0XCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNwaGVyb2lkOiBcIlNmw6Zyb2lkZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTZW1pbWFqb3JBeGlzOiBcIlN0b3JlIGhhbHZha3NlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNlbWltaW5vckF4aXM6IFwiTGlsbGUgaGFsdmFrc2VcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlSW52ZXJzZUZsYXR0ZW5pbmc6IFwiSW52ZXJzIHV0ZmxhdGluZ1wiLFxuXHRcdGlucHV0RGVmaW5pdGlvbkZpbGVOYW1lOiBcIkFuZ2kgZGVmaW5pc2pvbnNmaWxcIixcblx0XHRkZWxldGVOYW1lOiBcIlNsZXR0XCIsXG5cdFx0YWRkVmFyaWFibGVOYW1lOiBcIkxlZ2cgdGlsIHZhcmlhYmVsXCIsXG5cdFx0bWF4TnVtUGl4ZWxzUGVyU2VnbWVudDogXCJNYWtzaW11bSBzZWdtZW50c3TDuHJyZWxzZSBpIHBpa3NsZXJcIixcblx0XHRmb3J3YXJkV2luZG93TmFtZTogXCJGb3JvdmVyIHZpbmR1XCIsXG5cdFx0YmFja3dhcmRXaW5kb3dOYW1lOiBcIkJha292ZXIgdmluZHVcIixcblx0XHRub0RhdGFIYW5kbGluZ05hbWU6IFwiSW5nZW5EYXRhIGJlaGFuZGxpbmdcIixcblx0XHRjaXJjdWxhcldyYXBWYWx1ZU5hbWU6IFwiU2lya3Vsw6ZyIG9tc2xhZ3N2ZXJkaVwiLFxuXHRcdGZyb21DbGFzc05hbWVGaWVsZE5hbWU6IFwiRmVsdG5hdm4gZm9yIGtsYXNzZW5hdm4gaW5uIGZyYSBSYXN0ZXJcIixcblx0XHR0b0NsYXNzTmFtZUZpZWxkTmFtZTogXCJGZWx0bmF2biBmb3Iga2xhc3NlbmF2biBpbm4gdGlsIFJhc3RlclwiLFxuXHRcdHRhcmdldFJhc3Rlck5hbWU6IFwiTcOlbHJhc3RlclwiLFxuXHRcdGNpcmN1bGFyV3JhcFZhbHVlOiBcIlNpcmt1bMOmciBvbXNsYWdzdmVyZGlcIixcblx0XHRiYW5kSW5kZXhlc1I6IFwiUsO4ZHQgdXR0cnlra1wiLFxuXHRcdGJhbmRJbmRleGVzRzogXCJHcsO4bnQgdXR0cnlra1wiLFxuXHRcdGJhbmRJbmRleGVzQjogXCJCbMOldHQgdXR0cnlra1wiLFxuXHRcdGV4YW1wbGVOYW1lOiBcIkVrc2VtcGVsXCIsXG5cdFx0aW5wdXROYW1lOiBcIklubmRhdGFcIixcblx0XHRvdXRwdXROYW1lOiBcIlJlc3VsdGF0XCIsXG5cdFx0b3B0aW9uYWxOYW1lOiBcIlZhbGdmcml0dFwiLFxuXHRcdGJyb3dzZURlZmluaXRpb25GaWxlOiBcIkJsYSBnamVubm9tIGRlZmluaXNqb25zZmlsXCIsXG5cdFx0c2VsZWN0RGVmaW5pdGlvbkZpbGU6IFwiVmVsZyBpbm5kYXRhZGVmaW5pc2pvbnNmaWxcIixcblx0XHRpbnB1dERlZmluaXRpb25VUkw6IFwiVVJMIGZvciBpbm5kYXRhZGVmaW5pc2pvbnNmaWxcIixcblx0XHRlbnRlckRlZmluaXRpb25GaWxlVVJMOiBcIkFuZ2kgVVJMIGZvciBpbm5kYXRhZGVmaW5pc2pvbnNmaWxcIixcblx0XHRicm93c2VYTUxGaWxlOiBcIkJsYSBnamVubm9tIFhNTC1maWxcIixcblx0XHRzZWxlY3RTdGF0c0ZpbGU6IFwiVmVsZyBzdGF0aXN0aWtrLSBvZyBoaXN0b2dyYW1maWxcIixcblx0XHRlbnRlclhNTEZpbGVVUkw6IFwiQW5naSBVUkwgZm9yIFhNTC1maWxcIixcblx0XHR4bWxGaWxlVVJMOiBcIlVSTCBmb3IgWE1MLWZpbFwiLFxuXHRcdGNpcmN1bGFyQ2FsY3VsYXRpb246IFwiQmVyZWduIHNpcmtlbHN0YXRpc3Rpa2tcIixcblx0XHRsb2NhbFN1cmZhY2VUeXBlOiBcIkxva2FsIG92ZXJmbGF0ZXR5cGVcIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyVHlwZTogXCJQYXJhbWV0ZXJ0eXBlXCIsXG5cdFx0bmVpZ2hib3Job29kRGlzdGFuY2U6IFwiTmFib2xhZ3NhdnN0YW5kXCIsXG5cdFx0dXNlQWRhcHRpdmVOZWlnaGJvcmhvb2Q6IFwiQnJ1ayBhZGFwdGl2dCBuYWJvbGFnXCIsXG5cdFx0b3V0cHV0U2xvcGVUeXBlOiBcIlV0ZGF0YSBoZWxuaW5nc23DpWxpbmdcIixcblx0XHRwcm9qZWN0QXppbXV0aHM6IFwiUHJvamlzZXIgZ2VvZGV0aXNrZSBhc2ltdXRlclwiLFxuXHRcdHVzZUVxdWF0b3JpYWxBc3BlY3Q6IFwiQnJ1ayBla3ZhdG9yaWFsYXNwZWt0XCIsXG5cdFx0elVuaXQ6IFwiWi1lbmhldFwiLFxuXHRcdGFuYWx5c2lzTWFzazogXCJBbmFseXNlbWFza2VcIixcblx0XHRzdGREZXZpYXRpb246IFwiU3RhbmRhcmRhdnZpa1wiLFxuXHRcdFwidHJ1ZVwiOiBcIlNhbnRcIixcblx0XHRcImZhbHNlXCI6IFwiVXNhbnRcIixcblx0XHRjb3N0RGlzdGFuY2VSYXN0ZXIxOiBcIklubmRhdGEgZm9yIGtvc3RuYWQvYXZzdGFuZHNyYXN0ZXIgMVwiLFxuXHRcdGNvc3REaXN0YW5jZVJhc3RlcjI6IFwiSW5uZGF0YSBmb3Iga29zdG5hZC9hdnN0YW5kc3Jhc3RlciAyXCIsXG5cdFx0dGhyZXNob2xkOiBcIlRlcnNrZWxcIixcblx0XHR0aHJlc2hvbGRNZXRob2Q6IFwiVGVyc2tlbG1ldG9kZVwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjE6IFwiSW5uZGF0YSBmb3IgYmFjayBkaXJlY3Rpb24tcmFzdGVyIDFcIixcblx0XHRkaXJlY3Rpb25SYXN0ZXIyOiBcIklubmRhdGEgZm9yIGJhY2sgZGlyZWN0aW9uLXJhc3RlciAyXCIsXG5cdFx0bWF4SXRlcmF0aW9uczogXCJNYWtzaW1hbHQgYW50YWxsIGdqZW50YWtlbHNlclwiLFxuXHRcdGVwc2lsb246IFwiRXBzaWxvblwiXG5cdH0sXG5cdGVudW1MYWJlbHM6IHtcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVNYW51YWw6IFwiTWFudWVsbFwiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZUV4dGVybmFsOiBcIkVrc3Rlcm5cIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JtYXA6IFwiRmFyZ2VrYXJ0XCIsXG5cdFx0Y2xyU2NoZW1lVHlwZUNvbG9yUmFtcDogXCJGYXJnZXBhbGV0dFwiLFxuXHRcdGNvbG9ybWFwVHlwZUVsZXZhdGlvbjogXCJIw7h5ZGVkYXRhXCIsXG5cdFx0Y29sb3JtYXBUeXBlR3JheTogXCJHcsOlXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTogXCJORFZJXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTI6IFwiTkRWSTJcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJMzogXCJORFZJM1wiLFxuXHRcdGNvbG9ybWFwVHlwZVJhbmRvbTogXCJUaWxmZWxkaWdcIixcblx0XHRub25lOiBcIkluZ2VuXCIsXG5cdFx0c2xvcGVUeXBlQWRqdXN0ZWQ6IFwiSnVzdGVydFwiLFxuXHRcdHNsb3BlVHlwZURlZ3JlZTogXCJHcmFkXCIsXG5cdFx0c2xvcGVUeXBlUGVyY2VudFJpc2U6IFwiUHJvc2VudCBzdGlnbmluZ1wiLFxuXHRcdHNsb3BlVHlwZVNjYWxlZDogXCJTa2FsZXJ0XCIsXG5cdFx0c3RyZXRjaFR5cGVNaW5NYXg6IFwiTWluTWFrc1wiLFxuXHRcdHN0cmV0Y2hUeXBlUGVyY2VudE1pbk1heDogXCJQcm9zZW50TWluTWFrc1wiLFxuXHRcdHN0cmV0Y2hUeXBlU2lnbW9pZDogXCJTaWdtb2lkXCIsXG5cdFx0c3RyZXRjaFR5cGVTdGREZXY6IFwiU3RkRGV2XCIsXG5cdFx0aGlsbHNoYWRlVHlwZVNpbXBsZTogXCJUcmFkaXNqb25lbGxcIixcblx0XHRoaWxsc2hhZGVUeXBlTXVsdGlkaXJlY3Rpb25hbDogXCJGbGVyZSByZXRuaW5nZXJcIixcblx0XHRiYW5kQ29tYm9CeU5hbWVzOiBcIkLDpW5kbmF2blwiLFxuXHRcdGJhbmRDb21ib0J5V2F2ZWxlbmd0aDogXCJCw6VuZGLDuGxnZWxlbmdkZXJcIixcblx0XHRiYW5kQ29tYm9CeUlEczogXCJCw6VuZC1JRC1lclwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uQmVzdE1hdGNoOiBcIkJlc3RlIHRyZWZmXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25GYWlsOiBcIkZlaWxcIixcblx0XHR1bml0VHlwZUNlbHNpdXM6IFwiQ2Vsc2l1c1wiLFxuXHRcdHVuaXRUeXBlQ2VudGltZXRlcnM6IFwiQ2VudGltZXRlclwiLFxuXHRcdHVuaXRUeXBlRGVjaW1ldGVyczogXCJEZXNpbWV0ZXJcIixcblx0XHR1bml0VHlwZUZhaHJlbmhlaXQ6IFwiRmFocmVuaGVpdFwiLFxuXHRcdHVuaXRUeXBlRmVldDogXCJGb3RcIixcblx0XHR1bml0VHlwZUZlZXRQZXJTZWM6IFwiRm90IHBlciBzZWt1bmQgKGZ0L3MpXCIsXG5cdFx0dW5pdFR5cGVJbmNoZXM6IFwiVG9tbWVyXCIsXG5cdFx0dW5pdFR5cGVLZWx2aW46IFwiS2VsdmluXCIsXG5cdFx0dW5pdFR5cGVLaWxvbWV0ZXJzOiBcIktpbG9tZXRlclwiLFxuXHRcdHVuaXRUeXBlS21zUGVySG91cjogXCJLaWxvbWV0ZXIgaSB0aW1lbiAoa20vdClcIixcblx0XHR1bml0VHlwZUtub3RzOiBcIktub3AgKGtuKVwiLFxuXHRcdHVuaXRUeXBlTWV0ZXJzOiBcIk1ldGVyXCIsXG5cdFx0dW5pdFR5cGVNZXRlcnNQZXJTZWM6IFwiTWV0ZXIgcGVyIHNla3VuZCAobS9zKVwiLFxuXHRcdHVuaXRUeXBlTWlsZXM6IFwiTWlsZXNcIixcblx0XHR1bml0VHlwZU1pbGVzUGVySG91cjogXCJNaWxlcyBpIHRpbWVuIChtcGgpXCIsXG5cdFx0dW5pdFR5cGVNaWxsaW1ldGVyczogXCJNaWxsaW1ldGVyXCIsXG5cdFx0dW5pdFR5cGVOYXV0aWNhbE1pbGVzOiBcIk5hdXRpc2tlIG1pbFwiLFxuXHRcdHVuaXRUeXBlWWFyZHM6IFwiWWFyZFwiLFxuXHRcdHVuaXRUeXBlRGVjaW1hbERlZ3JlZXM6IFwiRGVzaW1hbGdyYWRlclwiLFxuXHRcdHVuaXRUeXBlUG9pbnRzOiBcIlB1bmt0ZXJcIixcblx0XHR1bml0VHlwZVVua25vd246IFwiVWtqZW50XCIsXG5cdFx0dW5pdFR5cGVTcU1hcFVuaXRzOiBcIkt2YWRyYXRrYXJ0ZW5oZXRlclwiLFxuXHRcdHVuaXRUeXBlU3FNaWxlczogXCJLdmFkcmF0bWlsZXNcIixcblx0XHR1bml0VHlwZVNxS21zOiBcIkt2YWRyYXRraWxvbWV0ZXJcIixcblx0XHR1bml0VHlwZUFjcmVzOiBcIkRla2FyXCIsXG5cdFx0dW5pdFR5cGVIZWN0YXJlczogXCJIZWt0YXJcIixcblx0XHR1bml0VHlwZVNxWWFyZHM6IFwiS3ZhZHJhdHlhcmRcIixcblx0XHR1bml0VHlwZVNxRnQ6IFwiS3ZhZHJhdGZvdFwiLFxuXHRcdHVuaXRUeXBlU3FJbmNoZXM6IFwiS3ZhZHJhdHRvbW1lclwiLFxuXHRcdHVuaXRUeXBlU3FNdHM6IFwiS3ZhZHJhdG1ldGVyXCIsXG5cdFx0dW5pdFR5cGVTcUNtczogXCJLdmFkcmF0Y2VudGltZXRlclwiLFxuXHRcdHVuaXRUeXBlU3FNbXM6IFwiS3ZhZHJhdG1pbGxpbWV0ZXJcIixcblx0XHRjZWxsc2l6ZVR5cGVGaXJzdDogXCJGw7hyc3QgYXZcIixcblx0XHRjZWxsc2l6ZVR5cGVNaW46IFwiTWluLiBhdlwiLFxuXHRcdGNlbGxzaXplVHlwZU1heDogXCJNYWtzLiBhdlwiLFxuXHRcdGNlbGxzaXplVHlwZU1lYW46IFwiR2plbm5vbXNuaXR0IGF2XCIsXG5cdFx0Y2VsbHNpemVUeXBlTGFzdDogXCJTaXN0IGF2XCIsXG5cdFx0ZXh0ZW50VHlwZUZpcnN0OiBcIkbDuHJzdCBhdlwiLFxuXHRcdGV4dGVudFR5cGVJbnRlcnNlY3Rpb246IFwiU2tqw6ZyaW5nc3B1bmt0IGF2XCIsXG5cdFx0ZXh0ZW50VHlwZVVuaW9uOiBcIlVuaW9uIGF2XCIsXG5cdFx0ZXh0ZW50VHlwZUxhc3Q6IFwiU2lzdCBhdlwiLFxuXHRcdG5vRGF0YUludGVycHJldEFueTogXCJGaW5uIG5vZW5cIixcblx0XHRub0RhdGFJbnRlcnByZXRBbGw6IFwiRmlubiBhbGxlXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVN0YW5kYXJkOiBcIlN0YW5kYXJkXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVByb2ZpbGU6IFwiUHJvZmlsXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVBsYW5mb3JtOiBcIlBsYW5mb3JtXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25Ib3Jpem9udGFsOiBcIkxpbmplZGV0ZWtzam9uIGhvcmlzb250YWxcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvblZlcnRpY2FsOiBcIkxpbmplZGV0ZWtzam9uIHZlcnRpa2FsXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25MZWZ0RGlhZ29uYWw6IFwiTGluamVkZXRla3Nqb24gdmVuc3RyZSBkaWFnb25hbFwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uUmlnaHREaWFnb25hbDogXCJMaW5qZWRldGVrc2pvbiBow7h5cmUgZGlhZ29uYWxcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aDogXCJIZWxuaW5nIG5vcmRcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRXZXN0OiBcIkhlbG5pbmcgdmVzdFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudEVhc3Q6IFwiSGVsbmluZyDDuHN0XCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50U291dGg6IFwiSGVsbmluZyBzw7hyXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50Tm9ydGhFYXN0OiBcIkhlbG5pbmcgbm9yZMO4c3RcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aFdlc3Q6IFwiSGVsbmluZyBub3JkdmVzdFwiLFxuXHRcdGZpbHRlclR5cGVTbW9vdGhBcml0aG1ldGljTWVhbjogXCJKZXZuIGFyaXRtZXRpc2sgbWlkZGVsdmVyZGlcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoaW5nM3gzOiBcIlV0amV2bmVyIDN4M1wiLFxuXHRcdGZpbHRlclR5cGVTbW9vdGhpbmc1eDU6IFwiVXRqZXZuZXIgNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW5pbmczeDM6IFwiU2tqZXJwZXIgM3gzXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW5pbmc1eDU6IFwiU2tqZXJwZXIgNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZUxhcGxhY2lhbjN4MzogXCJMYXBsYWNlLWZvcmRlbGluZyAzeDNcIixcblx0XHRmaWx0ZXJUeXBlTGFwbGFjaWFuNXg1OiBcIkxhcGxhY2UtZm9yZGVsaW5nIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbEhvcml6b250YWw6IFwiU29iZWwgaG9yaXNvbnRhbFwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbFZlcnRpY2FsOiBcIlNvYmVsIHZlcnRpa2FsXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW46IFwiU2tqZXJwXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW4yOiBcIkdqw7hyIGVuZGEgc2thcnBlcmVcIixcblx0XHRmaWx0ZXJUeXBlUG9pbnRTcHJlYWQ6IFwiUHVua3RzcHJlZG5pbmdcIixcblx0XHR1c2VyRGVmaW5lZDogXCJCcnVrZXJkZWZpbmVydFwiLFxuXHRcdENvbnRvdXJUeXBlTGluZXM6IFwiS29udHVybGluamVyXCIsXG5cdFx0Q29udG91clR5cGVGaWxsOiBcIktvbnR1cmZ5bGxpbmdcIixcblx0XHRDb250b3VyVHlwZVNtb290aE9ubHk6IFwiQmFyZSBnbGF0dCBvdmVyZmxhdGVcIixcblx0XHRyYXN0ZXJpemVGaXJzdDogXCJGw7hyc3RlXCIsXG5cdFx0cmFzdGVyaXplTGFzdDogXCJTaXN0ZVwiLFxuXHRcdHJhc3Rlcml6ZVNtYWxsZXN0OiBcIk1pbnN0XCIsXG5cdFx0cmFzdGVyaXplTGFyZ2VzdDogXCJTdMO4cnN0XCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVOZWFyZXN0OiBcIk7DpnJtZXN0ZSBuYWJvXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhcjogXCJCaWxpbmXDpnIgaW50ZXJwb2xhc2pvblwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQ3ViaWM6IFwiS3ViaXNrIGtvbnZvbHVzam9uXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNYWpvcml0eTogXCJNYWpvcml0ZXRcIixcblx0XHRyZXNhbXBsaW5nVHlwZUJpbGluZWFyUGx1czogXCJCaWxpbmXDpnIgaW50ZXJwb2xhc2pvbiBwbHVzc1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlR2F1c3M6IFwiR2F1c3Npc2sgdXNrYXJwaGV0XCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVHYXVzc1BsdXM6IFwiR2F1c3Npc2sgdXNrYXJwaGV0IHBsdXNzXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVBdmVyYWdlOiBcIkdqZW5ub21zbml0dFwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWluaW11bTogXCJNaW5pbXVtXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNYXhpbXVtOiBcIk1ha3NpbXVtXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVWZWN0b3JBdmc6IFwiVmVrdG9yZ2plbm5vbXNuaXR0XCIsXG5cdFx0bWluaW11bTogXCJNaW5pbXVtXCIsXG5cdFx0bWF4aW11bTogXCJNYWtzaW11bVwiLFxuXHRcdG1lYW46IFwiR2plbm5vbXNuaXR0XCIsXG5cdFx0c3RkRGV2aWF0aW9uOiBcIlN0YW5kYXJkYXZ2aWtcIixcblx0XHR1dk1hZ0RpclR5cGVVVjogXCJVLVZcIixcblx0XHR1dk1hZ0RpclR5cGVNYWdEaXI6IFwiU3TDuHJyZWxzZS1SZXRuaW5nXCIsXG5cdFx0dW5rbm93bjogXCJVa2plbnRcIixcblx0XHRhbmdsZVJlZlN5c0dlb2dyYXBoaWM6IFwiR2VvZ3JhZmlza1wiLFxuXHRcdGFuZ2xlUmVmU3lzQXJpdGhtZXRpYzogXCJBcml0bWV0aXNrXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmVhcmVzdDogXCJOw6ZybWVzdGUgbmFib1wiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YUJpbGluZWFyOiBcIkJpbGluZcOmclwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdMaW5lYXI6IFwiVHJpYW5ndWxlciBsaW5lw6ZydFwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdOYXR1cmFsTmVpZ2hib3I6IFwiTmF0dXJsaWcgbmFib1wiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdJRFc6IFwiVmVrdGV0IGludmVycyBhdnN0YW5kXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVDb25zdGFudDogXCJLb25zdGFudFwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlT3RzdTogXCJPdHN1XCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVUc2FpOiBcIlRzYWlcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZUthcHVyOiBcIkthcHVyXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVLaXR0bGVyOiBcIktpdHRsZXJcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZVJvc2luOiBcIlJvc2luXCIsXG5cdFx0YXJnU3RhdHNUeXBlTWF4OiBcIkFyZyBtYWtzLlwiLFxuXHRcdGFyZ1N0YXRzVHlwZU1pbjogXCJBcmcgbWluLlwiLFxuXHRcdGFyZ1N0YXRzVHlwZU1lZGlhbjogXCJBcmcgbWVkaWFuXCIsXG5cdFx0YXJnU3RhdHNUeXBlRHVyYXRpb246IFwiVmFyaWdoZXRcIixcblx0XHRhcml0aG1ldGljT3BQbHVzOiBcIlBsdXNzXCIsXG5cdFx0YXJpdGhtZXRpY09wTWludXM6IFwiTWludXNcIixcblx0XHRhcml0aG1ldGljT3BNdWx0aXBseTogXCJNdWx0aXBsaXNlclwiLFxuXHRcdGFyaXRobWV0aWNPcERpdmlkZTogXCJEZWxlIHDDpVwiLFxuXHRcdGFyaXRobWV0aWNPcFBvd2VyOiBcIlBvdGVuc1wiLFxuXHRcdGFyaXRobWV0aWNPcE1vZGU6IFwiTW9kdXNcIixcblx0XHRjbGlwVHlwZU91dHNpZGU6IFwiS2xpcHAgdXRlbmZvclwiLFxuXHRcdGNsaXBUeXBlSW5zaWRlOiBcIktsaXBwIGlubmVuZm9yXCIsXG5cdFx0eWVzOiBcIkphXCIsXG5cdFx0bm86IFwiTmVpXCIsXG5cdFx0ZGVuc2l0aWVzOiBcIlRldHRoZXRlclwiLFxuXHRcdGV4cGVjdGVkQ291bnRzOiBcIkZvcnZlbnRldCBhbnRhbGxcIixcblx0XHRwbGFuYXI6IFwiUGxhbnRcIixcblx0XHRnZW9kZXNpYzogXCJHZW9kZXRpc2tcIixcblx0XHRlYWNoQ2VsbDogXCJIdmVyIGNlbGxlXCIsXG5cdFx0ZWFjaFpvbmU6IFwiSHZlciBzb25lXCIsXG5cdFx0YmVzdFNpbmdsZTogXCJCZXN0ZSBlbmtlbHRmb3Jla29tc3RcIixcblx0XHRhbGxTaWdodGxpbmVzOiBcIkFsbGUgc2lrdGVsaW5qZXJcIixcblx0XHRwZXJpbWV0ZXJTaWdodGxpbmVzOiBcIlBlcmltZXRlcnNpa3RlbGluamVyXCIsXG5cdFx0ZnJlcXVlbmN5OiBcIkZyZWt2ZW5zXCIsXG5cdFx0b2JzZXJ2ZXJzOiBcIk9ic2VydmF0w7hyZXJcIixcblx0XHRtYWpvcml0eTogXCJNYWpvcml0ZXRcIixcblx0XHRtZWRpYW46IFwiTWVkaWFuXCIsXG5cdFx0bWlub3JpdHk6IFwiTWlub3JpdGV0XCIsXG5cdFx0cGVyY2VudGlsZTogXCJQZXJzZW50aWxcIixcblx0XHRyYW5nZTogXCJPbXLDpWRlXCIsXG5cdFx0c3VtOiBcIlN1bVwiLFxuXHRcdHZhcmlldHk6IFwiVmFyaWFudFwiLFxuXHRcdG5kdmk6IFwiTkRWSVwiLFxuXHRcdHNhdmk6IFwiU0FWSVwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kVFNBVkk6IFwiVHJhbnNmb3JtZXJ0IFNBVklcIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZE1TQVZJOiBcIkVuZHJldCBTQVZJXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNNZXRob2RTdWx0YW46IFwiU3VsdGFucyBmb3JtZWxcIixcblx0XHRnZW1pOiBcIkdFTUlcIixcblx0XHRwdmk6IFwiUFZJXCIsXG5cdFx0Z3ZpOiBcIkdWSSAoTGFuZHNhdCBUTSlcIixcblx0XHR2YXJpOiBcIlZBUklcIixcblx0XHRzcjogXCJTUlwiLFxuXHRcdGduZHZpOiBcIkdORFZJXCIsXG5cdFx0bmR2aXJlOiBcIk5EVklyZVwiLFxuXHRcdHNycmU6IFwiU1JyZVwiLFxuXHRcdG10dmkyOiBcIk1UVkkyXCIsXG5cdFx0cnR2aUNvcmU6IFwiUlRWSUNvcmVcIixcblx0XHRjaXJlOiBcIkNJcmVcIixcblx0XHRjaWc6IFwiQ0lnXCIsXG5cdFx0bmR3aTogXCJORFdJXCIsXG5cdFx0ZXZpOiBcIkVWSVwiLFxuXHRcdGlyb25PeGlkZTogXCJKZXJub2tzaWRcIixcblx0XHRmZXJyb3VzTWluZXJhbHM6IFwiSmVybmhvbGRpZ2UgbWluZXJhbGVyXCIsXG5cdFx0Y2xheU1pbmVyYWxzOiBcIkxlaXJtaW5lcmFsXCIsXG5cdFx0d25kd2k6IFwiV05EV0lcIixcblx0XHRiYWk6IFwiQkFJXCIsXG5cdFx0bW5kd2k6IFwiTU5EV0lcIixcblx0XHRuYnI6IFwiTkJSXCIsXG5cdFx0bmRiaTogXCJOREJJXCIsXG5cdFx0bmRtaTogXCJORE1JXCIsXG5cdFx0bmRzaTogXCJORFNJXCIsXG5cdFx0bG9jYWxTcXVhcmVSb290OiBcIkt2YWRyYXRyb3RcIixcblx0XHRsb2NhbEFDb3M6IFwiQUNvc1wiLFxuXHRcdGxvY2FsQVNpbjogXCJBU2luXCIsXG5cdFx0bG9jYWxBVGFuOiBcIkFUYW5cIixcblx0XHRsb2NhbEFUYW5IOiBcIkFUYW5IXCIsXG5cdFx0bG9jYWxBYnM6IFwiQWJzXCIsXG5cdFx0bG9jYWxCaXR3aXNlTm90OiBcIkJpdHdpc2UgTm90XCIsXG5cdFx0bG9jYWxCb29sZWFuTm90OiBcIkJvb2xzayBOb3RcIixcblx0XHRsb2NhbENvczogXCJDb3NcIixcblx0XHRsb2NhbENvc0g6IFwiQ29zSFwiLFxuXHRcdGxvY2FsRXhwOiBcIkV4cFwiLFxuXHRcdGxvY2FsRXhwMTA6IFwiRXhwMTBcIixcblx0XHRsb2NhbEV4cDI6IFwiRXhwMlwiLFxuXHRcdGxvY2FsSW50OiBcIkludFwiLFxuXHRcdGxvY2FsSXNOdWxsOiBcIklzIE51bGxcIixcblx0XHRsb2NhbEZsb2F0OiBcIkZsb2F0XCIsXG5cdFx0bG9jYWxMbjogXCJMblwiLFxuXHRcdGxvY2FsTG9nMTA6IFwiTG9nMTBcIixcblx0XHRsb2NhbExvZzI6IFwiTG9nMlwiLFxuXHRcdGxvY2FsTmVnYXRlOiBcIkludmVydMOpclwiLFxuXHRcdGxvY2FsUm91bmREb3duOiBcIkF2cnVuZCBuZWRvdmVyXCIsXG5cdFx0bG9jYWxSb3VuZFVwOiBcIkF2cnVuZCBvcHBvdmVyXCIsXG5cdFx0bG9jYWxTaW46IFwiU2luXCIsXG5cdFx0bG9jYWxTaW5IOiBcIlNpbkhcIixcblx0XHRsb2NhbFRhbjogXCJUYW5cIixcblx0XHRsb2NhbFRhbkg6IFwiVGFuSFwiLFxuXHRcdGxvY2FsQUNvc0g6IFwiQUNvc0hcIixcblx0XHRsb2NhbEFTaW5IOiBcIkFTaW5IXCIsXG5cdFx0bG9jYWxQbHVzOiBcIlBsdXNzXCIsXG5cdFx0bG9jYWxNaW51czogXCJNaW51c1wiLFxuXHRcdGxvY2FsVGltZXM6IFwiZ2FuZ2VyXCIsXG5cdFx0bG9jYWxQb3dlcjogXCJQb3RlbnNcIixcblx0XHRsb2NhbEJpdHdpc2VBbmQ6IFwiQml0d2lzZSBBbmRcIixcblx0XHRsb2NhbEJpdHdpc2VMZWZ0U2hpZnQ6IFwiQml0d2lzZSBMZWZ0IFNoaWZ0XCIsXG5cdFx0bG9jYWxCaXR3aXNlT3I6IFwiQml0d2lzZSBPclwiLFxuXHRcdGxvY2FsQml0d2lzZVJpZ2h0U2hpZnQ6IFwiQml0d2lzZSBSaWdodCBTaGlmdFwiLFxuXHRcdGxvY2FsQml0d2lzZVhvcjogXCJCaXR3aXNlIFhvclwiLFxuXHRcdGxvY2FsQm9vbGVhbkFuZDogXCJCb29sc2sgQW5kXCIsXG5cdFx0bG9jYWxCb29sZWFuT3I6IFwiQm9vbHNrIE9yXCIsXG5cdFx0bG9jYWxCb29sZWFuWG9yOiBcIkJvb2xzayBYb3JcIixcblx0XHRsb2NhbERpdmlkZTogXCJEZWxlIHDDpVwiLFxuXHRcdGxvY2FsRXF1YWxUbzogXCJFciBsaWtcIixcblx0XHRsb2NhbEdyZWF0ZXJUaGFuOiBcIlN0w7hycmUgZW5uXCIsXG5cdFx0bG9jYWxHcmVhdGVyVGhhbkVxdWFsOiBcIlN0w7hycmUgZW5uIGVsbGVyIGxpa1wiLFxuXHRcdGxvY2FsTGVzc1RoYW46IFwiTWluZHJlIGVublwiLFxuXHRcdGxvY2FsTGVzc1RoYW5FcXVhbDogXCJNaW5kcmUgZW5uIGVsbGVyIGxpa1wiLFxuXHRcdGxvY2FsTW9kOiBcIk1vZFwiLFxuXHRcdGxvY2FsTm90RXF1YWw6IFwiSWtrZSBsaWtcIixcblx0XHRsb2NhbEFUYW4yOiBcIkFUYW4yXCIsXG5cdFx0bG9jYWxTcXVhcmU6IFwiS3ZhZHJhdFwiLFxuXHRcdGxvY2FsU2V0TnVsbDogXCJBbmdpIG51bGxcIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkxpc3RlXCIsXG5cdFx0cmVtYXBEZWZUeXBlVGFibGU6IFwiVGFiZWxsXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVTaW1wbGU6IFwiRW5rZWxcIixcblx0XHRyZW1hcFRhYmxlVHlwZUR5bmFtaWM6IFwiRHluYW1pc2tcIixcblx0XHRyZW1hcFRhYmxlVHlwZVJlYXNzaWdubWVudDogXCJPdmVyZsO4cmluZ1wiLFxuXHRcdGdlb21Db3JyZWN0aW9uQnlDb25zdFo6IFwiQnJ1ayBrb25zdGFudCBaXCIsXG5cdFx0Z2VvbUNvcnJlY3Rpb25CeURFTTogXCJCcnVrIERFTVwiLFxuXHRcdHJhZGFyQ2FsaWJCZXRhTm91Z2h0OiBcIkJldGEgbnVsbFwiLFxuXHRcdHJhZGFyQ2FsaWJTaWdtYU5vdWdodDogXCJTaWdtYSBudWxsXCIsXG5cdFx0cmFkYXJDYWxpYkdhbW1hTm91Z2h0OiBcIkdhbW1hIG51bGxcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUxlZTogXCJMZWUtZmlsdGVyXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVFbmhhbmNlZExlZTogXCJGb3JiZWRyZXQgTGVlLWZpbHRlclwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlRnJvc3Q6IFwiRnJvc3QtZmlsdGVyXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVLdWFuOiBcIkp1YW4tZmlsdGVyXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxNdWw6IFwiTXVsdGlwbGlrYXRpdiBzdMO4eVwiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsQWRkOiBcIkFkZGl0aXYgc3TDuHlcIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbEFkZG5NdWw6IFwiQWRkaXRpdiBvZyBtdWx0aXBsaWthdGl2IHN0w7h5XCIsXG5cdFx0bW9zYWljT3BUeXBlRmlyc3Q6IFwiRsO4cnN0ZVwiLFxuXHRcdG1vc2FpY09wVHlwZUxhc3Q6IFwiU2lzdGVcIixcblx0XHRtb3NhaWNPcFR5cGVNaW46IFwiTWluXCIsXG5cdFx0bW9zYWljT3BUeXBlTWF4OiBcIk1ha3NcIixcblx0XHRtb3NhaWNPcFR5cGVNZWFuOiBcIkdqZW5ub21zbml0dFwiLFxuXHRcdG1vc2FpY09wVHlwZUJsZW5kOiBcIkJsYW5kXCIsXG5cdFx0bW9zYWljT3BUeXBlU3VtOiBcIlN1bVwiLFxuXHRcdGludGVnZXI6IFwiSGVsdGFsbFwiLFxuXHRcdHJmeEQ4OiBcIkQ4XCIsXG5cdFx0cmZ4TUZEOiBcIk1GRFwiLFxuXHRcdGRpbmY6IFwiRGluZlwiLFxuXHRcdHZlcnRpY2FsOiBcIkxvZGRyZXR0XCIsXG5cdFx0aG9yaXpvbnRhbDogXCJWYW5ucmV0dFwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eTogXCJNYWpvcml0ZXRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWF4OiBcIk1ha3NpbXVtXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW46IFwiR2plbm5vbXNuaXR0XCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbjogXCJNZWRpYW5cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWluOiBcIk1pbmltdW1cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHk6IFwiTWlub3JpdGV0XCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1JhbmdlOiBcIk9tcsOlZGVcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3RkRGV2OiBcIlN0YW5kYXJkYXZ2aWtcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtOiBcIlN1bVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NWYXJpZXR5OiBcIlZhcmlhbnRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWFqb3JpdHlJZ25vcmVORDogXCJNYWpvcml0ZXQgKGlnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYXhJZ25vcmVORDogXCJNYWtzaW11bSAoaWdub3JlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW5JZ25vcmVORDogXCJNaWRkZWx2ZXJkaSAoaWdub3JlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbklnbm9yZU5EOiBcIk1lZGlhbiAoaWdub3JlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbklnbm9yZU5EOiBcIk1pbmltdW0gKGlnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5vcml0eUlnbm9yZU5EOiBcIk1pbm9yaXRldCAoaWdub3JlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1JhbmdlSWdub3JlTkQ6IFwiT21yw6VkZSAoaWdub3JlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N0ZERldklnbm9yZU5EOiBcIlN0YW5kYXJkYXZ2aWsgKGlnbm9yZXJlIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtSWdub3JlTkQ6IFwiU3VtIChpZ25vcmVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVmFyaWV0eUlnbm9yZU5EOiBcIlZhcmlhc2pvbiAoaWdub3JlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1R5cGVQZXJjZW50aWxlSWdub3JlTkQ6IFwiUGVyc2VudGlsIChJZ25vcmVyIEluZ2VuRGF0YSlcIixcblx0XHRmcm9tU291cmNlOiBcIkZyYSBraWxkZVwiLFxuXHRcdHRvU291cmNlOiBcIlRpbCBraWxkZVwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uUmdiVG9Ic3Y6IFwiUkdCIHRpbCBIU1ZcIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvbkhzdlRvUmdiOiBcIkhTViB0aWwgUkdCXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVJSFM6IFwiSUhTXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVCcm92ZXk6IFwiQnJvdmV5XCIsXG5cdFx0cGFuc2hhcnBlblR5cGVFc3JpOiBcIkVzcmlcIixcblx0XHRwYW5zaGFycGVuVHlwZU1lYW46IFwiR2plbm5vbXNuaXR0XCIsXG5cdFx0cGFuc2hhcnBlblR5cGVHcmFtU2NobWlkdDogXCJHcmFtLVNjaG1pZHRcIixcblx0XHRyZWN0YW5nbGVOZWlnaGJvcmhvb2Q6IFwiUmVrdGFuZ2VsXCIsXG5cdFx0Y2lyY2xlTmVpZ2hib3Job29kOiBcIlNpcmtlbFwiLFxuXHRcdGFubnVsdXNOZWlnaGJvcmhvb2Q6IFwiUmluZ1wiLFxuXHRcdHdlZGdlTmVpZ2hib3Job29kOiBcIktpbGVcIixcblx0XHRpcnJlZ3VsYXJOZWlnaGJvcmhvb2Q6IFwiVXJlZ2VsbWVzc2lnXCIsXG5cdFx0d2VpZ2h0TmVpZ2hib3Job29kOiBcIlZla3RcIixcblx0XHRmb3VyOiBcIkZpcmVcIixcblx0XHRlaWdodDogXCLDhXR0ZVwiLFxuXHRcdHdpdGhpbjogXCJJbm5lbmZvclwiLFxuXHRcdGNyb3NzOiBcIktyeXNzXCIsXG5cdFx0YWRkTGluazogXCJMZWdnIHRpbCBrb2JsaW5nXCIsXG5cdFx0bm9MaW5rOiBcIkluZ2VuIGtvYmxpbmdcIixcblx0XHR3ZWlnaHRlZE1lYW46IFwiVmVrdGV0IHNuaXR0XCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2lycnVzOiBcIkxhbmRzYXQgOCBjaXJyaXVzXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWQ6IFwiTGFuZHNhdCA4IHNreVwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNsb3VkU2hhZG93OiBcIkxhbmRzYXQgOCBza3lza3lnZ2VcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5EZXNpZ25hdGVkRmlsbDogXCJMYW5kc2F0IDggZGVzaWduZXJ0IGZ5bGxcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Ecm9wcGVkRnJhbWU6IFwiTGFuZHNhdCA4IHV0ZWxhdHQgcmFtbWVcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Tbm93SWNlOiBcIkxhbmRzYXQgOCBzbsO4L2lzXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVGVycmFpbk9jY2x1c2lvbjogXCJMYW5kc2F0IDggdGVycmVuZ29ra2x1c2pvblwiLFxuXHRcdGxzOFFDQml0UGF0dGVyblZlZ2V0YXRpb246IFwiTGFuZHNhdCA4IHZlZ2V0YXNqb25cIixcblx0XHRsczhRQ0JpdFBhdHRlcm5XYXRlcjogXCJMYW5kc2F0IDggdmFublwiLFxuXHRcdGRvd25TdHJlYW06IFwiTmVkc3Ryw7htc1wiLFxuXHRcdHVwU3RyZWFtOiBcIk9wcHN0csO4bXNcIixcblx0XHRzdHJhaGxlcjogXCJTVFJBSExFUlwiLFxuXHRcdHNocmV2ZTogXCJTSFJFVkVcIixcblx0XHRjdXJyZW50U2xpY2U6IFwiTsOldsOmcmVuZGUgaW5uZGVsaW5nXCIsXG5cdFx0YWxsU2xpY2VzOiBcIkFsbGUgaW5uZGVsaW5nZXJcIixcblx0XHRleHBhbmREaXN0YW5jZTogXCJBVlNUQU5EXCIsXG5cdFx0ZXhwYW5kTW9ycGhvbG9naWNhbDogXCJNT1JGT0xPR0lTS1wiLFxuXHRcdHNwZWN0cmFsUHJvZmlsZUZpbGU6IFwiU3Bla3RyYWxwcm9maWxcIixcblx0XHR0cmFpbmluZ0ZlYXR1cmVGaWxlOiBcIk9wcGzDpnJpbmdzZnVua3Nqb25cIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlVW5pZm9ybTogXCJVbmlmb3JtXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVVuaWZvcm1JbnRlZ2VyOiBcIkhlbHRhbGxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlTm9ybWFsOiBcIk5vcm1hbFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVFeHBvbmVudGlhbDogXCJFa3Nwb25lbnRpZWxsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVBvaXNzb246IFwiUG9pc3NvblwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVHYW1tYTogXCJHYW1tYVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVCaW5vbWlhbDogXCJCaW5vbWlhbFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVHZW9tZXRyaWM6IFwiR2VvbWV0cmlza1wiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVOZWdhdGl2ZUJpbm9taWFsOiBcIk5lZ2F0aXYgYmlub21pbmFsXCIsXG5cdFx0cmFuZG9tR2VuZXJhdG9yVHlwZVN0YW5kYXJkQ1JhbmQ6IFwiU3RhbmRhcmQgQyBSYW5kXCIsXG5cdFx0cmFuZG9tR2VuZXJhdG9yVHlwZUFsZ29yaXRobUFDTTU5OTogXCJBQ00taW5uc2FtbGV0IGFsZ29yaXRtZSA1OTlcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlTWVyc2VubmVUd2lzdGVyOiBcIk1lcnNlbm5lIFR3aXN0ZXJcIixcblx0XHRzdW1OYW1lOiBcIlN1bVwiLFxuXHRcdG1lZGFpbk5hbWU6IFwiTWVkaWFuXCIsXG5cdFx0dHJlbmRMaW5lYXI6IFwiTGluZcOmclwiLFxuXHRcdHRyZW5kSGFybW9uaWM6IFwiSGFybW9uaXNrXCIsXG5cdFx0dHJlbmRQb2x5bm9taWFsOiBcIlBvbHlub21cIixcblx0XHR0cmVuZE1hbm5LZW5kYWxsOiBcIk1hbm4tS2VuZGFsbFwiLFxuXHRcdHRyZW5kU2Vhc29uYWxLZW5kYWxsOiBcIlNlc29uZy1LZW5kYWxsXCIsXG5cdFx0ZGltZW5zaW9uQnlWYWx1ZTogXCJFdHRlciB2ZXJkaVwiLFxuXHRcdGRpbWVuc2lvbkJ5SW50ZXJ2YWw6IFwiRXR0ZXIgaW50ZXJ2YWxsXCIsXG5cdFx0bWRpbURlZlR5cGVBbGw6IFwiQWx0XCIsXG5cdFx0bWRpbURlZlR5cGVCeVZhbHVlczogXCJCeSBWYWx1ZXNcIixcblx0XHRtZGltRGVmVHlwZUJ5UmFuZ2VzOiBcIkJ5IFJhbmdlc1wiLFxuXHRcdG1kaW1EZWZUeXBlQnlJdGVyYXRpb246IFwiQnkgSXRlcmF0aW9uXCIsXG5cdFx0bWRpbURlZlR5cGVCeUludGVydmFsOiBcIkV0dGVyIGludGVydmFsbFwiLFxuXHRcdG1kaW1EZWZUeXBlQnlUYXJnZXRSYXN0ZXI6IFwiRXR0ZXIgbcOlbHJhc3RlclwiLFxuXHRcdGVzcmlUaW1lVW5pdHNIb3VyczogXCJUaW1lclwiLFxuXHRcdGVzcmlUaW1lVW5pdHNEYXlzOiBcIkRhZ2VyXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1dlZWtzOiBcIlVrZXJcIixcblx0XHRlc3JpVGltZVVuaXRzTW9udGhzOiBcIk3DpW5lZGVyXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1llYXJzOiBcIsOFclwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkSG91cmx5OiBcIkh2ZXIgdGltZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkRGFpbHk6IFwiRGFnbGlnXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRXZWVrbHk6IFwiVWtlbnRsaWdcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZERla2FkbHk6IFwiVGkgZGFnZXJcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFBlbnRhZGx5OiBcIkZlbSBkYWdlclwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkTW9udGhseTogXCJNw6VuZWRsaWdcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFF1YXJ0ZXJseTogXCJLdmFydGFsc3Zpc1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkWWVhcmx5OiBcIkh2ZXJ0IMOlclwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nRGFpbHk6IFwiR2plbnRhcyBkYWdsaWdcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1dlZWtseTogXCJHamVudGFzIHVrZW50bGlnXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdNb250aGx5OiBcIkdqZW50YXMgaHZlciBtw6VuZWRcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1F1YXJ0ZXJseTogXCJHamVudGFzIGh2ZXJ0IGt2YXJ0YWxcIixcblx0XHRhZ2dEZWZUeXBlQWxsOiBcIkFsbGVcIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxLZXl3b3JkOiBcIk7DuGtrZWxvcmQgZm9yIGludGVydmFsbFwiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFZhbHVlOiBcIkludGVydmFsbHZlcmRpXCIsXG5cdFx0YWdnRGVmVHlwZUludGVydmFsUmFuZ2VzOiBcIkludGVydmFsbG9tcsOlZGVyXCIsXG5cdFx0bGF0ZXN0Q2hhbmdlOiBcIlRpbWUgb2YgTGF0ZXN0IENoYW5nZVwiLFxuXHRcdGVhcmxpZXN0Q2hhbmdlOiBcIlRpbWUgb2YgRWFybGllc3QgQ2hhbmdlXCIsXG5cdFx0bGFyZ2VzdENoYW5nZTogXCJUaW1lIG9mIExhcmdlc3QgQ2hhbmdlXCIsXG5cdFx0bnVtYmVyT2ZDaGFuZ2VzOiBcIk51bWJlciBvZiBDaGFuZ2VzXCIsXG5cdFx0bG9uZ2VzdENoYW5nZTogXCJUaWRzcHVua3QgZm9yIGxlbmdzdGUgZW5kcmluZ1wiLFxuXHRcdHNob3J0ZXN0Q2hhbmdlOiBcIlRpZHNwdW5rdCBmb3Iga29ydGVzdGUgZW5kcmluZ1wiLFxuXHRcdGZhc3Rlc3RDaGFuZ2U6IFwiVGlkc3B1bmt0IGZvciByYXNrZXN0ZSBlbmRyaW5nXCIsXG5cdFx0c2xvd2VzdENoYW5nZTogXCJUaWRzcHVua3QgZm9yIGxhbmdzb21zdGUgZW5kcmluZ1wiLFxuXHRcdGFsbENoYW5nZXM6IFwiQWxsZVwiLFxuXHRcdGluY3JlYXNlQ2hhbmdlczogXCLDmGtlXCIsXG5cdFx0ZGVjcmVhc2VDaGFuZ2VzOiBcIlJlZHVzZXJlXCIsXG5cdFx0c2VnbWVudEJlZ2lubmluZzogXCJTZWdtZW50ZXRzIGJlZ3lubmVsc2VcIixcblx0XHRzZWdtZW50RW5kOiBcIlNlZ21lbnRldHMgc2x1dHRcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZERpZmZlcmVuY2U6IFwiRGlmZmVyZW5jZVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kUmVsYXRpdmVEaWZmZXJlbmNlOiBcIlJlbGF0aXZlIERpZmZlcmVuY2VcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZENhdGVnb3JpY2FsOiBcIkthdGVnb3Jpc2sgZm9yc2tqZWxsXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RNdWx0aXNwZWN0cmFsRXVjbGlkZWFuRGlzdGFuY2U6IFwiU3Bla3RyYWwgZXVrbGlkc2sgYXZzdGFuZFwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEFuZ3VsYXJEaWZmZXJlbmNlOiBcIlNwZWt0cmFsIHZpbmtlbGRpZmZlcmFuc2VcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBeGlzV2l0aEJpZ2dlc3RDaGFuZ2U6IFwiQsOlbmQgbWVkIHN0w7hyc3QgZW5kcmluZ1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcEFsbDogXCJCZWhvbGQgYWxsZVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcENoYW5nZWRPbmx5OiBcIkJlaG9sZCBiYXJlIGVuZHJlZGUgcGlrc2xlclwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcFVuY2hhbmdlZE9ubHk6IFwiQmVob2xkIGJhcmUgdWVuZHJlZGUgcGlrc2xlclwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JBdmVyYWdlOiBcIkdqZW5ub21zbml0dCBGcmEtIG9nIFRpbC1mYXJnZXJcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yRnJvbTogXCJCcnVrIEZyYS1mYXJnZXJcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yVG86IFwiQnJ1ayBUaWwtZmFyZ2VyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25CaW5hcnk6IFwiQmluw6ZyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Gb3J3YXJkOiBcIkZyZW1vdmVyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25MaW5lYXI6IFwiTGluZcOmclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSW52TGluZWFyOiBcIkludmVycyBsaW5lw6ZyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZTogXCJUYWJlbGxcIixcblx0XHRmYWN0b3JGdW5jdGlvblN5bUxpbmVhcjogXCJTeW1tZXRyaXNrIGxpbmXDpnJcIixcblx0XHRmYWN0b3JGdW5jdGlvblN5bUludkxpbmVhcjogXCJTeW1tZXRyaXNrIGludmVycyBsaW5lw6ZyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3M6IFwiQ29zaW51c1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2VjOiBcIlNla2FudFwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zU2VjOiBcIkNvc2ludXMtc2VrYW50XCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWNDb3M6IFwiU2VrYW50LWNvc2ludXNcIixcblx0XHRub1NvcnQ6IFwiSWtrZSBzb3J0ZXJcIixcblx0XHRhc2NlbmQ6IFwiU3RpZ2VuZGVcIixcblx0XHRkZXNjZW5kOiBcIlN5bmtlbmRlXCIsXG5cdFx0YXV0b0RldGVjdDogXCJBdXRvLWRldGVrdGVyXCIsXG5cdFx0bmVhcmVzdDogXCJOw6ZybWVzdGVcIixcblx0XHRsaW5lYXI6IFwiTGluZcOmclwiLFxuXHRcdGVzcmlNb250aEphbnVhcnk6IFwiSmFudWFyXCIsXG5cdFx0ZXNyaU1vbnRoRmVicnVhcnk6IFwiRmVicnVhclwiLFxuXHRcdGVzcmlNb250aE1hcmNoOiBcIk1hcnNcIixcblx0XHRlc3JpTW9udGhBcHJpbDogXCJBcHJpbFwiLFxuXHRcdGVzcmlNb250aE1heTogXCJNYWlcIixcblx0XHRlc3JpTW9udGhKdW5lOiBcIkp1bmlcIixcblx0XHRlc3JpTW9udGhKdWx5OiBcIkp1bGlcIixcblx0XHRlc3JpTW9udGhBdWd1c3Q6IFwiQXVndXN0XCIsXG5cdFx0ZXNyaU1vbnRoU2VwdGVtYmVyOiBcIlNlcHRlbWJlclwiLFxuXHRcdGVzcmlNb250aE9jdG9iZXI6IFwiT2t0b2JlclwiLFxuXHRcdGVzcmlNb250aE5vdmVtYmVyOiBcIk5vdmVtYmVyXCIsXG5cdFx0ZXNyaU1vbnRoRGVjZW1iZXI6IFwiRGVzZW1iZXJcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ0lnbm9yZU5vRGF0YTogXCJEYXRhXCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdQcm9wYWdhdGVOb0RhdGE6IFwiTm9kYXRhXCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdGaWxsT25seU5vRGF0YTogXCJGeWxsIHV0IE5vRGF0YVwiLFxuXHRcdGNpcmN1bGFyTWVhbjogXCJTaXJrdWzDpnJ0IGdqZW5ub21zbml0dFwiLFxuXHRcdGNpcmN1bGFyTmFtZTogXCJTaXJrdWzDpnJcIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0bWV0aXNrXCIsXG5cdFx0c2xvcGVOYW1lOiBcIkhlbGxpbmdcIixcblx0XHRhc3BlY3ROYW1lOiBcIkhlbGxpbmdzcmV0bmluZ1wiLFxuXHRcdG1lYW5DdXJ2YXR1cmU6IFwiR2plbm5vbXNuaXR0bGlnIGt1cnZhdHVyXCIsXG5cdFx0cHJvZmlsZUN1cnZhdHVyZTogXCJQcm9maWwgKG5vcm1hbCBoZWxsaW5nc2xpbmplKSBrdXJ2YXR1clwiLFxuXHRcdHRhbmdlbnRpYWxDdXJ2YXR1cmU6IFwiVGFuZ2VudGllbGwgKG5vcm1hbCBrb250dXIpIGt1cnZhdHVyXCIsXG5cdFx0cGxhbkN1cnZhdHVyZTogXCJQbGFuIChwcm9qaXNlcnQga29udHVyKSBrdXJ2YXR1clwiLFxuXHRcdGNvbnRvdXJHZW9kZXNpY1RvcnNpb246IFwiS29udHVyIGdlb2RldGlzayB0b3Jzam9uXCIsXG5cdFx0Z2F1c3NpYW5DdXJ2YXR1cmU6IFwiR2F1c3Mta3VydmF0dXJcIixcblx0XHRjYXNvcmF0aUN1cnZhdHVyZTogXCJDYXNvcmF0aS1rdXJ2YXR1clwiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGVRdWFkcmF0aWM6IFwiS3ZhZHJhdGlza1wiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGVCaXF1YWRyYXRpYzogXCJCaWt2YWRyYXRpc2tcIixcblx0XHR0aHJlc2hvbGROb1RocmVzaG9sZDogXCJJbmdlbiB0ZXJza2VsXCIsXG5cdFx0dGhyZXNob2xkUGVyY2VudExlYXN0Q29zdDogXCJQcm9zZW50IG1pbnN0IGtvc3RuYWRcIixcblx0XHR0aHJlc2hvbGRBY2N1bXVsYXRpdmVDb3N0OiBcIkt1bXVsYXRpdiBrb3N0bmFkXCIsXG5cdFx0Y2xybWFwVHlwZUhpbGxzaGFkZTogXCJIaWxsc2hhZGVcIlxuXHR9LFxuXHRjYXRlZ29yeUxhYmVsczoge1xuXHRcdHNvdXJjZUNoYXJhY3RlcmlzdGljczogXCJLaWxkZWthcmFrdGVyaXN0aWtrXCIsXG5cdFx0bmVpZ2hib3Job29kU2V0dGluZ3M6IFwiTmFib2xhZ3Npbm5zdGlsbGluZ2VyXCIsXG5cdFx0c3RhdGlzdGljczogXCJTdGF0aXN0aWtrXCIsXG5cdFx0Z2FtbWE6IFwiR2FtbWFcIixcblx0XHR2aWV3c2hlZFBhcmFtZXRlcnM6IFwiU3luc2ZlbHRwYXJhbWV0ZXJlXCIsXG5cdFx0b2JzZXJ2ZXJQYXJhbWV0ZXJzOiBcIk9ic2VydmF0w7hycGFyYW1ldGVyZVwiLFxuXHRcdGlycmVndWxhckRhdGFJbnRlcnBvbGF0aW9uOiBcIlVyZWdlbG1lc3NpZyBkYXRhaW50ZXJwb2xlcmluZ1wiLFxuXHRcdG1vZGVsU3RhdGlzdGljczogXCJNb2RlbGxzdGF0aXN0aWtrXCIsXG5cdFx0YWdncmVnYXRpb25EZWY6IFwiQWdncmVnZXJpbmdzZGVmaW5pc2pvblwiLFxuXHRcdGZpbHRlckJ5QXR0cmlidXRlczogXCJGaWx0cmVyIGV0dGVyIGF0dHJpYnV0dGVyXCIsXG5cdFx0cGVyY2VudGlsZU5hbWU6IFwiUGVyc2VudGlsXCIsXG5cdFx0cmFzdGVySW5mbzogXCJSYXN0ZXJpbmZvcm1hc2pvblwiLFxuXHRcdGV4dGVudDogXCJPbWZhbmdcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlOiBcIlJvbWxpZyByZWZlcmFuc2VcIlxuXHR9LFxuXHRvdXRwdXRSYXN0ZXJIZWxwVGV4dHM6IHtcblx0XHRvdXRwdXROYW1lOiBcIjxwPk5hdm5ldCBww6UgbGFnZXQgc29tIG9wcHJldHRlcyBvZyBsZWdnZXMgdGlsIGthcnRldC48L3A+XCIsXG5cdFx0cmVzdWx0VHlwZTogXCI8cD5UeXBlbiB1dGRhdGEgc29tIGJsaXIgb3BwcmV0dGV0LiBVdGRhdGFlbmUga2FuIHbDpnJlIGZsaXNpbm5kZWx0ZSBiaWxkZWxhZyBlbGxlciBkeW5hbWlza2UgYmlsZGVsYWcuPC9wPlwiLFxuXHRcdHNhdmVSZXN1bHRJbjogXCI8cD5OYXZuZXQgcMOlIG1hcHBlbiBpIDxiPk1pdHQgaW5uaG9sZDwvYj4gZGVyIHJlc3VsdGF0ZXQgYmxpciBsYWdyZXQuPC9wPlwiXG5cdH0sXG5cdGFuYWx5c2lzRW52aXJvbm1lbnRzSGVscFRleHRzOiB7XG5cdFx0ZGVzY3JpcHRpb246IFwiPHA+TWlsasO4aW5uc3RpbGxpbmdlciBmb3IgYW5hbHlzZSBpIE1hcCBWaWV3ZXIuIDwvcD5cIixcblx0XHRvdXRTUjogXCI8cD5BbmdpciBrb29yZGluYXRzeXN0ZW1ldCBmb3IgYW5hbHlzZXIgb2cgcmVzdWx0YXRsYWdldC48L3A+XCIsXG5cdFx0ZXh0ZW50OiBcIjxwPkFuZ2lyIG9tcsOlZGV0IHNvbSBza2FsIGJydWtlcyB0aWwgYW5hbHlzZS48L3A+XCIsXG5cdFx0c25hcFJhc3RlcjogXCI8cD5KdXN0ZXJlciB1dHN0cmVrbmluZ2VuIGZvciB1dGRhdGFlbmUgc2xpayBhdCBkZW4gc2Ftc3ZhcmVyIG1lZCBjZWxsZWp1c3RlcmluZ2VuIGkgZGV0IGFuZ2l0dGUgZm9yYW5rcmluZ3NyYXN0ZXJsYWdldC48L3A+XCIsXG5cdFx0Y2VsbFNpemU6IFwiPHA+QW5naXIgY2VsbGVzdMO4cnJlbHNlbiBlbGxlciBvcHBsw7hzbmluZ2VuIHNvbSBibGlyIGJydWt0IHRpbCBhbmFseXNlciBvZyB0aWwgw6Ugb3BwcmV0dGUgdXRkYXRhcmFzdGVybGFnZXQuPC9wPlwiLFxuXHRcdG1hc2s6IFwiPHA+QW5naXIgZXQgbWFza2VsYWcgZGVyIGJhcmUgY2VsbGVuZSBzb20gZXIgaW5uZW5mb3IgbWFza2VvbXLDpWRldCwgYnJ1a2VzIHRpbCBhbmFseXNlLjwvcD5cIixcblx0XHRyZXNhbXBsaW5nTWV0aG9kOiBcIjxwPkFuZ2lyIGh2b3JkYW4gcGlrc2VsdmVyZGllciBza2FsIGludGVycG9sZXJlcyBuw6VyIGlubmRhdGEtIG9nIHV0ZGF0YXJhc3RlcmVuZSBpa2tlIGVyIHDDpSBsaW5qZS48L3A+XCJcblx0fSxcblx0bWFpbkdlblN0cmluZ3M6IHtcblx0XHR1bnN1cHBvcnRlZERhdGFUeXBlOiBcIlR5cGVuIHN0w7h0dGVzIGlra2VcIixcblx0XHRjdXJyZW50bHlVbnN1cHBvcnRlZDogXCIgRXQgc3RhbmRhcmRyZWRpZ2VyaW5nc3Byb2dyYW0gZm9yICR7bWlzc2luZ1R5cGV9IGVyIHVuZGVyIGFyYmVpZCBvZyBrb21tZXIgc25hcnQuIE1pZGxlcnRpZGlnIHBsYXNzaG9sZGVydGVrc3Rib2tzIGZvciDDpSBhbmdpIHN0cmVuZ2Jhc2VydGUgaW5uZGF0YS5cIixcblx0XHR1bnN1cHBvcnRlZE92ZXJyaWRlV2FybmluZzogXCJFbiBvdmVyc3R5cmVuZGUga29tcG9uZW50IGZvciByZWRpZ2VyaW5nc3Byb2dyYW1tZXQgc29tIGdpciBiZWRyZSBVWCBmb3Igw6Ugam9iYmUgbWVkIGbDuGxnZW5kZSBwYXJhbWV0ZXIoZSkgZXIgdW5kZXIgYXJiZWlkLCBvZyBrb21tZXIgc25hcnQ6XCIsXG5cdFx0b3ZlcnJpZGVXaWRnZXRNaXNzaW5nOiBcIktvbXBvbmVudCBmb3Igb3ZlcnN0eXJlbmRlIHJlZGlnZXJpbmdzcHJvZ3JhbSBtYW5nbGVyIVwiLFxuXHRcdHVpSW5jb21wbGV0ZTogXCJKb2JiaW5uc2VuZGluZ2VuIG1pc2x5a3Rlcy4gRnVua3Nqb25lbiBrYW4gaWtrZSBrasO4cmVzIGZvcmRpIG5vZW4gYXYgZGUgcMOla3JldmRlIGZlbHRlbmUgZXIgdWZ1bGxzdGVuZGlnZSBlbGxlciBtYW5nbGVyIGZyYSBVSS1ldC5cIixcblx0XHRjb3VudDogXCJBbnRhbGxcIixcblx0XHRzZWxlY3RWYXJpYWJsZXM6IFwiVmVsZyB2YXJpYWJsZXJcIixcblx0XHRzZWxlY3RGZWF0dXJlOiBcIlZlbGcgZXQgZ2Vvb2JqZWt0bGFnXCIsXG5cdFx0Z3JlYXRlclRoYW5FcnJvck1lc3NhZ2U6IFwiRGV0IGFuZ2l0dGUgdGFsbGV0IG3DpSB2w6ZyZSBow7h5ZXJlIGVubiAke21pbn1cIixcblx0XHRsZXNzZXJUaGFuRXJyb3JNZXNzYWdlOiBcIkRldCBhbmdpdHRlIHRhbGxldCBtw6UgdsOmcmUgbGF2ZXJlIGVubiAke21heH1cIixcblx0XHRncmVhdGVyVGhhbk9yRXF1YWxFcnJvck1lc3NhZ2U6IFwiRGV0IGFuZ2l0dGUgdGFsbGV0IG3DpSB2w6ZyZSBzdMO4cnJlIGVubiBlbGxlciBsaWsgJHttaW59XCIsXG5cdFx0bGVzc2VyVGhhbk9yRXF1YWxFcnJvck1lc3NhZ2U6IFwiRGV0IGFuZ2l0dGUgdGFsbGV0IG3DpSB2w6ZyZSBsYXZlcmUgZW5uIGVsbGVyIGxpayAke21heH1cIixcblx0XHRhbGxvd1NjYWxhcjogXCJWZWxnIGV0IGxhZyBlbGxlciBhbmdpIGVuIGtvbnN0YW50XCIsXG5cdFx0c2VsZWN0RmllbGQ6IFwiVmVsZyBmZWx0XCIsXG5cdFx0cGFyYW1ldGVyUmVxdWlyZWQ6IFwiRGVubmUgcGFyYW1ldGVyZW4ga3JldmVzLlwiLFxuXHRcdGVudGVyQVZhbHVlOiBcIkFuZ2kgZW4gdmVyZGkuLi5cIixcblx0XHRpbnZhbGlkSW5wdXQ6IFwiRGVuIGFuZ2l0dGUgdmVyZGllbiBlciB1Z3lsZGlnLlwiLFxuXHRcdGl0ZW1Ob3RGb3VuZDogXCJFbGVtZW50ZXQgZWtzaXN0ZXJlciBpa2tlIGVsbGVyIGVyIHV0aWxnamVuZ2VsaWcuXCIsXG5cdFx0aXRlbVBlcm1pc3Npb25EZW5pZWQ6IFwiRHUgaGFyIGlra2UgdGlsbGF0ZWxzZXIgdGlsIMOlIGJydWtlIGRldHRlIGVsZW1lbnRldC5cIixcblx0XHRsYXllck5vdEF2YWlsYWJsZTogXCJLYW4gaWtrZSBsYXN0ZSBpbm4gbGFnZXQgJHtsYXllck5hbWV9LlwiLFxuXHRcdG11bHRpcGxlTGF5ZXJzTm90QXZhaWxhYmxlOiBcIkthbiBpa2tlIGxhc3RlIGlubiBsYWdldCAke2xheWVyTmFtZX0gb2cgYW5kcmUuXCIsXG5cdFx0bGVhcm5Nb3JlTGFiZWw6IFwiRsOlIG1lciBpbmZvcm1hc2pvblwiLFxuXHRcdGZpZWxkTm90QXZhaWxhYmxlOiBcIkthbiBpa2tlIGxhc3RlIGlubiBmZWx0ZXQuXCIsXG5cdFx0YWxsb3dBbmFseXNpczogXCJBbmFseXNlIGVyIGlra2UgdGlsbGF0dCBww6UgYmlsZGV0amVuZXN0ZW4uXCIsXG5cdFx0YWxsb3dBbmFseXNpc1JlYXNvbjogXCJFdHQgZWxsZXIgZmxlcmUgbGFnIGZyYSBrYXJ0ZXQgdmlzZXMgaWtrZSBoZXIgZm9yZGkgZGUgaWtrZSB0aWxsYXRlciBhbmFseXNlLlwiLFxuXHRcdGxlYXJuTW9yZVRleHQ6IFwiTWVyIGluZm9ybWFzam9uXCIsXG5cdFx0YXRMZWFzdE9uZVJhc3RlcklucHV0OiBcIk1pbnN0IGV0dCBpbm5kYXRhbGFnIG3DpSB2w6ZyZSBldCByYXN0ZXJsYWcuXCIsXG5cdFx0YnJvd3NlQW5hbHlzaXNMYXllcnM6IFwiQmxhIGdqZW5ub20gbGFnXCIsXG5cdFx0YWN0aXZlTWFwVmlld0V4dGVudDogXCJCcnVrIGRlbiBnamVsZGVuZGUga2FydHV0c3RyZWtuaW5nZW5cIixcblx0XHRjaG9vc2VSYXN0ZXI6IFwiVmVsZyBLbGlwcGVyYXN0ZXJcIixcblx0XHRjaG9vc2VHZW9tZXRyeTogXCJWZWxnIEdlb21ldHJpIGZvciB1dGtsaXBwXCIsXG5cdFx0cmVzdWx0VHlwZTogXCJSZXN1bHRhdHR5cGVcIixcblx0XHRzYXZlSW5Gb2xkZXI6IFwiTGFncmUgaSBtYXBwZVwiLFxuXHRcdG91dHB1dE5hbWU6IFwiTmF2biBww6UgdXRkYXRhXCIsXG5cdFx0b3V0cHV0TGF5ZXJUeXBlOiBcIlV0ZGF0YWxhZ3R5cGVcIixcblx0XHRkeW5hbWljSW1hZ2VyeUxheWVyOiBcIkR5bmFtaXNrIGJpbGRlbGFnXCIsXG5cdFx0dGlsZWRJbWFnZXJ5TGF5ZXI6IFwiRmxpc2lubmRlbHQgYmlsZGVsYWdcIixcblx0XHRjdXN0b206IFwiVGlscGFzc2V0XCIsXG5cdFx0bG9hZGluZzogXCJMYXN0ZXIgaW5uLi4uXCIsXG5cdFx0bGF5ZXJNaXNzaW5nOiBcIkV0dCBlbGxlciBmbGVyZSBsYWcgZnJhIGthcnRldCB2aXNlcyBpa2tlIGhlciBmb3JkaSBkZSBpa2tlIHRpbGxhdGVyIGFuYWx5c2UuIEzDpnIgbWVyLlwiLFxuXHRcdGJyb3dzZUNvb3JkaW5hdGVTeXN0ZW1zOiBcIkJsYSBnamVubm9tIGtvb3JkaW5hdHN5c3RlbWVyXCIsXG5cdFx0dW5hYmxlVG9SZXBvcHVsYXRlT3V0U1I6IFwiS2FuIGlra2UgZnlsbGUgdXQga29vcmRpbmF0c3lzdGVtZXQgZm9yIHV0ZGF0YS5cIixcblx0XHRkZWZhdWx0VGl0bGU6IFwiVmlzIG1lclwiLFxuXHRcdFwiQVJDIChlcXVhbCBhcmMtc2Vjb25kKVwiOiBcIkFSQyAobGlrIGJ1ZS1zZWt1bmQpXCIsXG5cdFx0QWZyaWNhOiBcIkFmcmlrYVwiLFxuXHRcdEFudGFyY3RpY2E6IFwiQW50YXJrdGlzXCIsXG5cdFx0QXJnZW50aW5hOiBcIkFyZ2VudGluYVwiLFxuXHRcdEFzaWE6IFwiQXNpYVwiLFxuXHRcdFwiQXN0ZXJvaWQgQmVsdFwiOiBcIkFzdGVyb2lkZWJlbHRlXCIsXG5cdFx0XCJBdGxhbnRpYyBPY2VhblwiOiBcIkF0bGFudGVyaGF2ZXRcIixcblx0XHRBdXN0cmFsaWE6IFwiQXVzdHJhbGlhXCIsXG5cdFx0XCJBdXN0cmFsaWEgYW5kIE5ldyBaZWFsYW5kXCI6IFwiQXVzdHJhbGlhIG9nIE5ldyBaZWFsYW5kXCIsXG5cdFx0QXVzdHJpYTogXCLDmHN0ZXJyaWtlXCIsXG5cdFx0XCJCTE0gKFVTIEZlZXQpXCI6IFwiQkxNIChhbWVyaWthbnNrZSBmb3QpXCIsXG5cdFx0QmFuZ2xhZGVzaDogXCJCYW5nbGFkZXNoXCIsXG5cdFx0XCJCZWlqaW5nIDE5NTRcIjogXCJCZWlqaW5nIDE5NTRcIixcblx0XHRCaHV0YW46IFwiQmh1dGFuXCIsXG5cdFx0Q0dDUzIwMDA6IFwiQ0dDUzIwMDBcIixcblx0XHRDYW5hZGE6IFwiS2FuYWRhXCIsXG5cdFx0Q2FyaWJiZWFuOiBcIkthcmliaWFcIixcblx0XHRcIkNhcmliYmVhbiBTZWFcIjogXCJEZXQga2FyaWJpc2tlIGhhdlwiLFxuXHRcdFwiQ2VudHJhbCBBbWVyaWNhXCI6IFwiU2VudHJhbC1BbWVyaWthXCIsXG5cdFx0XCJDZW50cmFsIGFuZCBOb3J0aCBBbWVyaWNhXCI6IFwiU2VudHJhbC0gb2cgTm9yZC1BbWVyaWthXCIsXG5cdFx0Q29sb21iaWE6IFwiQ29sb21iaWFcIixcblx0XHRDb250aW5lbnRhbDogXCJLb250aW5lbnRhbFwiLFxuXHRcdFwiQ291bnR5IFN5c3RlbXNcIjogXCJGeWxrZXNzeXN0ZW1lclwiLFxuXHRcdFwiRGVtb2NyYXRpYyBSZXB1YmxpYyBvZiB0aGUgQ29uZ29cIjogXCJEZW4gZGVtb2tyYXRpc2tlIHJlcHVibGlra2VuIEtvbmdvXCIsXG5cdFx0XCJFUFNHIEFyY3RpY1wiOiBcIkVQU0cgQXJjdGljXCIsXG5cdFx0RWFydGg6IFwiSm9yZGVuXCIsXG5cdFx0XCJFbGxpcHNvaWRhbC1iYXNlZFwiOiBcIkVsbGlwc29pZGViYXNlcnRcIixcblx0XHRFdXJvcGU6IFwiRXVyb3BhXCIsXG5cdFx0RmlubGFuZDogXCJGaW5sYW5kXCIsXG5cdFx0RnJhbmNlOiBcIkZyYW5rcmlrZVwiLFxuXHRcdFwiR1NLIDIwMTFcIjogXCJHU0sgMjAxMVwiLFxuXHRcdFwiR2F1c3MgS3J1Z2VyXCI6IFwiR2F1c3MgS3J1Z2VyXCIsXG5cdFx0XCJHZW9ncmFwaGljIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIkdlb2dyYWZpc2tlIGtvb3JkaW5hdHN5c3RlbWVyXCIsXG5cdFx0R2VybWFueTogXCJUeXNrbGFuZFwiLFxuXHRcdFwiR3Jhdml0eS1yZWxhdGVkXCI6IFwiR3Jhdml0YXNqb25zcmVsYXRlcnRcIixcblx0XHRcIkdyZWVud2ljaC1iYXNlZFwiOiBcIkdyZWVud2ljaC1iYXNlcnRcIixcblx0XHRcIkhpZ2h3YXlzIEVuZ2xhbmRcIjogXCJIb3ZlZHZlaWVyIEVuZ2xhbmRcIixcblx0XHRJbGxpbm9pczogXCJJbGxpbm9pc1wiLFxuXHRcdFwiSW5kaWFuIE9jZWFuXCI6IFwiRGV0IGluZGlza2UgaGF2XCIsXG5cdFx0XCJJbmRpYW4gU3ViY29udGluZW50XCI6IFwiRGV0IGluZGlza2Ugc3Via29udGluZW50XCIsXG5cdFx0SW5kaWFuYTogXCJJbmRpYW5hXCIsXG5cdFx0SW5kb25lc2lhOiBcIkluZG9uZXNpYVwiLFxuXHRcdElvd2E6IFwiSW93YVwiLFxuXHRcdFwiSXJlbGFuZCBhbmQgVW5pdGVkIEtpbmdkb21cIjogXCJJcmxhbmQgb2cgU3RvcmJyaXRhbm5pYVwiLFxuXHRcdEl0YWx5OiBcIkl0YWxpYVwiLFxuXHRcdEphcGFuOiBcIkphcGFuXCIsXG5cdFx0SnVwaXRlcjogXCJKdXBpdGVyXCIsXG5cdFx0S2Fuc2FzOiBcIkthbnNhc1wiLFxuXHRcdFwiTGFzIFZlZ2FzXCI6IFwiTGFzIFZlZ2FzXCIsXG5cdFx0TGlieWE6IFwiTGlieWFcIixcblx0XHRNYWxheXNpYTogXCJNYWxheXNpYVwiLFxuXHRcdFwiTWFsYXlzaWEgYW5kIFNpbmdhcG9yZVwiOiBcIk1hbGF5c2lhIG9nIFNpbmdhcG9yZVwiLFxuXHRcdE1hcnM6IFwiTWFyc1wiLFxuXHRcdE1lcmN1cnk6IFwiTWVya3VyXCIsXG5cdFx0TWlubmVzb3RhOiBcIk1pbm5lc290YVwiLFxuXHRcdE1vbnRhbmE6IFwiTW9udGFuYVwiLFxuXHRcdFwiTkFEIDE5MjdcIjogXCJOQUQgMTkyN1wiLFxuXHRcdFwiTkFEIDE5MjcgKFVTIEZlZXQpXCI6IFwiTkFEIDE5MjcgKGFtZXJpa2Fuc2tlIGZvdClcIixcblx0XHRcIk5BRCAxOTgzXCI6IFwiTkFEIDE5ODNcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKVwiOiBcIk5BRCAxOTgzICgyMDExKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKDIwMTEpIChpbnRlcm5hc2pvbmFsZSBmb3QpXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSkgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoMjAxMSkgKG1ldGVyKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzICgyMDExKSAoYW1lcmlrYW5za2UgZm90KVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAoaW50ZXJuYXNqb25hbGUgZm90KVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAobWV0ZXIpXCIsXG5cdFx0XCJOQUQgMTk4MyAoQ09SUzk2KSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAoYW1lcmlrYW5za2UgZm90KVwiLFxuXHRcdFwiTkFEIDE5ODMgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoaW50ZXJuYXNqb25hbGUgZm90KVwiLFxuXHRcdFwiTkFEIDE5ODMgKE1ldGVycylcIjogXCJOQUQgMTk4MyAobWV0ZXIpXCIsXG5cdFx0XCJOQUQgMTk4MyAoUEExMSkgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoUEExMSkgKG1ldGVyKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChQQTExKSAoYW1lcmlrYW5za2UgZm90KVwiLFxuXHRcdFwiTkFEIDE5ODMgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgKGFtZXJpa2Fuc2tlIGZvdClcIixcblx0XHRcIk5BRCAxOTgzIEhBUk4gKEludGwgRmVldClcIjogXCJOQUQgMTk4MyBIQVJOIChpbnRlcm5hc2pvbmFsZSBmb3QpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgSEFSTiAobWV0ZXIpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIEhBUk4gKGFtZXJpa2Fuc2tlIGZvdClcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKGludGVybmFzam9uYWxlIGZvdClcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKG1ldGVyKVwiLFxuXHRcdFwiTkFEIDE5ODMgTlNSUzIwMDcgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKGFtZXJpa2Fuc2tlIGZvdClcIixcblx0XHRcIk5hdGlvbmFsIEdyaWRzXCI6IFwiTmFzam9uYWxlIHJ1dGVuZXR0XCIsXG5cdFx0TmF2YWpvOiBcIk5hdmFqb1wiLFxuXHRcdE5lcHR1bmU6IFwiTmVwdHVuXCIsXG5cdFx0XCJOZXcgQmVpamluZ1wiOiBcIk5ldyBCZWlqaW5nXCIsXG5cdFx0XCJOZXcgWmVhbGFuZFwiOiBcIk5ldyBaZWFsYW5kXCIsXG5cdFx0XCJOb3J0aCBBbWVyaWNhXCI6IFwiTm9yZC1BbWVyaWthXCIsXG5cdFx0XCJOb3J0aGVybiBIZW1pc3BoZXJlXCI6IFwiTm9yZGxpZ2UgaGFsdmt1bGVcIixcblx0XHROb3J3YXk6IFwiTm9yZ2VcIixcblx0XHRPY2VhbnM6IFwiSGF2XCIsXG5cdFx0T3JlZ29uOiBcIk9yZWdvblwiLFxuXHRcdFwiT3RoZXIgR0NTXCI6IFwiQW5kcmUgR0NTXCIsXG5cdFx0XCJQYWNpZmljIE9jZWFuXCI6IFwiU3RpbGxlaGF2ZXRcIixcblx0XHRQbHV0bzogXCJQbHV0b1wiLFxuXHRcdFBvbGFyOiBcIlBvbGFyXCIsXG5cdFx0UG9ydHVnYWw6IFwiUG9ydHVnYWxcIixcblx0XHRcIlByb2plY3RlZCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJQcm9qaXNlcnRlIGtvb3JkaW5hdHN5c3RlbWVyXCIsXG5cdFx0XCJQdWxrb3ZvIDE5NDJcIjogXCJQdWxrb3ZvIDE5NDJcIixcblx0XHRcIlB1bGtvdm8gMTk5NVwiOiBcIlB1bGtvdm8gMTk5NVwiLFxuXHRcdFJlcGxhY2VkOiBcIkVyc3RhdHRldFwiLFxuXHRcdFwiU0FEIDE5NjlcIjogXCJTQUQgMTk2OVwiLFxuXHRcdFNJUkdBUzogXCJTSVJHQVNcIixcblx0XHRcIlNJUkdBUyAyMDAwXCI6IFwiU0lSR0FTIDIwMDBcIixcblx0XHRTYXR1cm46IFwiU2F0dXJuXCIsXG5cdFx0XCJTb2xhciBTeXN0ZW1cIjogXCJTb2xzeXN0ZW1cIixcblx0XHRcIlNvdXRoIEFmcmljYVwiOiBcIlPDuHItQWZyaWthXCIsXG5cdFx0XCJTb3V0aCBBbWVyaWNhXCI6IFwiU8O4ci1BbWVyaWthXCIsXG5cdFx0XCJTb3V0aCBLb3JlYVwiOiBcIlPDuHItS29yZWFcIixcblx0XHRcIlNvdXRoZXJuIEhlbWlzcGhlcmVcIjogXCJTw7hybGlnZSBoYWx2a3VsZVwiLFxuXHRcdFwiU3BoZXJvaWQtYmFzZWRcIjogXCJTZsOmcm9pZGViYXNlcnRcIixcblx0XHRcIlN0YXRlIFBsYW5lXCI6IFwiRGVsc3RhdHBsYW5cIixcblx0XHRcIlN0YXRlIFN5c3RlbXNcIjogXCJEZWxzdGF0c3lzdGVtZXJcIixcblx0XHRTd2VkZW46IFwiU3ZlcmlnZVwiLFxuXHRcdFwiU3dpdHplcmxhbmQgYW5kIExpZWNodGVuc3RlaW5cIjogXCJTdmVpdHMgb2cgTGllY2h0ZW5zdGVpblwiLFxuXHRcdFRleGFzOiBcIlRleGFzXCIsXG5cdFx0VHJpYmFsOiBcIlN0YW1tZVwiLFxuXHRcdFR1cmtleTogXCJUeXJraWFcIixcblx0XHRcIlVTIEZlZXRcIjogXCJBbWVyaWthbnNrZSBmb3RcIixcblx0XHRcIlVTQSBhbmQgdGVycml0b3JpZXNcIjogXCJVU0EgbWVkIHRlcnJpdG9yaWVyXCIsXG5cdFx0VVRNOiBcIlVUTVwiLFxuXHRcdFVrcmFpbmU6IFwiVWtyYWluYVwiLFxuXHRcdFwiVW5rbm93biBIZWlnaHQgU3lzdGVtc1wiOiBcIlVramVudGUgaMO4eWRlc3lzdGVtZXJcIixcblx0XHRVcmFudXM6IFwiVXJhbnVzXCIsXG5cdFx0VmVudXM6IFwiVmVudXNcIixcblx0XHRcIlZlcnRpY2FsIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIlZlcnRpa2FsZSBrb29yZGluYXRzeXN0ZW1lclwiLFxuXHRcdFZpZXRuYW06IFwiVmlldG5hbVwiLFxuXHRcdFwiV0dTIDE5NzJcIjogXCJXR1MgMTk3MlwiLFxuXHRcdFwiV0dTIDE5ODRcIjogXCJXR1MgMTk4NFwiLFxuXHRcdFdpc2NvbnNpbjogXCJXaXNjb25zaW5cIixcblx0XHRcIldpc2NvbnNpbiBDUlNcIjogXCJXaXNjb25zaW4gQ1JTXCIsXG5cdFx0V29ybGQ6IFwiVmVyZGVuXCIsXG5cdFx0XCJXb3JsZCAoU3BoZXJlLWJhc2VkKVwiOiBcIlZlcmRlbiAoc2bDpnJlYmFzZXJ0KVwiLFxuXHRcdFd5b21pbmc6IFwiV3lvbWluZ1wiLFxuXHRcdFwiWGlhbiAxOTgwXCI6IFwiWGlhbiAxOTgwXCIsXG5cdFx0ZG9uZTogXCJGZXJkaWdcIixcblx0XHRub1Jlc3VsdHM6IFwiRmlubmVyIGluZ2VuIHJlc3VsdGF0ZXJcIixcblx0XHRzZWFyY2hQbGFjZWhvbGRlcjogXCJOYXZuIGVsbGVyIFdLSURcIixcblx0XHRicm93c2VUZW1wbGF0ZTogXCJCbGEgZ2plbm5vbSByYXN0ZXJmdW5rc2pvbnNtYWxlclwiLFxuXHRcdHNhdmVUZW1wbGF0ZTogXCJMYWdyZSByYXN0ZXJmdW5rc2pvbnNtYWxcIixcblx0XHRwcmV2aWV3OiBcIkZvcmjDpW5kc3Zpc25pbmdcIixcblx0XHRwcmV2aWV3RGVzY3JpcHRpb246IFwiRm9yaMOlbmRzdmlzIHJlc3VsdGF0ZW5lIGbDuHIgZHUga2rDuHJlciBhbmFseXNlbi5cIixcblx0XHRzaG93UHJldmlldzogXCJWaXMgZm9yaMOlbmRzdmlzbmluZ1wiLFxuXHRcdHByZXZpZXdMYXllcjogXCJGb3Jow6VuZHN2aXMgbGFnZXQgJHtudW1iZXJ9XCIsXG5cdFx0bmV3UHJldmlldzogXCJOeSBmb3Jow6VuZHN2aXNuaW5nXCIsXG5cdFx0cHJldmlld1BvcHVwOiBcIkFrdGl2ZXIgZm9yaMOlbmRzdmlzbmluZyBhdiBhbmFseXNlcmVzdWx0YXRlbmUgYmFzZXJ0IHDDpSBpbm5kYXRhcGFyYW1ldGVybmUuXCIsXG5cdFx0dXBkYXRlUHJldmlld0xheWVyOiBcIk9wcGRhdGVyIGRldCB2YWxndGUgZm9yaMOlbmRzdmlzbmluZ3NsYWdldFwiLFxuXHRcdGNyZWF0ZVByZXZpZXdMYXllcjogXCJPcHByZXR0IG55dHQgZm9yaMOlbmRzdmlzbmluZ3NsYWdcIixcblx0XHRtYXhpbXVtUHJldmlld0FsbG93ZWQ6IFwiTWFrcy4gYW50YWxsIHRpbGxhdHRlIGZvcmjDpW5kc3Zpc25pbmdzbGFnOiAke21heENvdW50fVwiLFxuXHRcdHByZXZpZXdGYWlsdXJlOiBcIkRldHRlIGZvcmjDpW5kc3Zpc25pbmdzbGFnZXQgZXIgaWtrZSB0aWxnamVuZ2VsaWcuIEtvbnRyb2xsZXIgaW5uZGF0YXBhcmFtZXRlcm5lLCBvZyBvcHBkYXRlciBkZXR0ZSBmb3Jow6VuZHN2aXNuaW5nc2xhZ2V0IGlnamVuLlwiLFxuXHRcdGhlYWRlcjogXCJWZWxnIGVsZW1lbnRcIixcblx0XHRjb250ZW50OiBcIkR1IGhhciBlbmRyaW5nZXIgc29tIGlra2UgZXIgbGFncmV0LCBpICR7cmZ0VGl0bGV9LiBIdmlzIGR1IGJlZ3lubmVyIHDDpSBueXR0IG1lZCBlbiBueSBtYWwsIGfDpXIgZGlzc2UgZW5kcmluZ2VuZSB0YXB0LlwiLFxuXHRcdGRvbnRTYXZlOiBcIklra2UgbGFncmVcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiRm9ydHNldHRcIixcblx0XHRzdHJldGNoOiBcIlRpbHBhc3MgdGlsIHZpbmR1XCIsXG5cdFx0cGFuOiBcIlBhbm9yZXJcIixcblx0XHRuZXdUZW1wbGF0ZTogXCJPcHByZXR0IG55IG1hbFwiLFxuXHRcdG9wZW5UZW1wbGF0ZTogXCLDhXBuZSBtYWxcIixcblx0XHRhZGRGdW5jdGlvbjogXCJMZWdnIHRpbCByYXN0ZXJmdW5rc2pvbmVyXCIsXG5cdFx0YWRkQ29uc3RhbnQ6IFwiTGVnZyB0aWwga29uc3RhbnRcIixcblx0XHRhZGRSYXN0ZXI6IFwiTGVnZyB0aWwgcmFzdGVydmFyaWFiZWxcIixcblx0XHRtb3ZlOiBcIkZseXR0XCIsXG5cdFx0em9vbTogXCJab29tXCIsXG5cdFx0c2F2ZUFzOiBcIkxhZ3JlIHNvbVwiLFxuXHRcdGNsZWFyOiBcIkZqZXJuXCIsXG5cdFx0YWRkUmFzdGVyRnVuY3Rpb25UaXRsZTogXCJMZWdnIHRpbCByYXN0ZXJmdW5rc2pvbmVyXCIsXG5cdFx0dGVtcGxhdGVQcm9wZXJ0aWVzVGl0bGU6IFwiRWdlbnNrYXBlciBmb3IgbWFsXCIsXG5cdFx0YnJvd3NlUkZUOiBcIkJsYSBnamVubm9tIHJhc3RlcmZ1bmtzam9uc21hbGVyXCIsXG5cdFx0ZGVmYXVsdFRvb2xEZXNjcmlwdGlvbjogXCIke3Rvb2xUaXRsZX0gYW5hbHlzZXZlcmt0w7h5LlwiLFxuXHRcdG9wZW5Ub29sVGV4dDogXCLDhXBuZSB2ZXJrdMO4eVwiLFxuXHRcdHRvb2xEcm9wZG93blRleHQ6IFwiUnVsbGVnYXJkaW5saXN0ZSBmb3IgdmVya3TDuHlcIixcblx0XHRhZGRUb01hcDogXCJCZWtyZWZ0IG9nIGxlZ2cgdGlsIGthcnRcIixcblx0XHRjb25maXJtOiBcIkJla3JlZnRcIixcblx0XHRzZWxlY3Q6IFwiVmVsZ1wiLFxuXHRcdHNlbGVjdFRhc2s6IFwiVmVsZyBvcHBnYXZlXCIsXG5cdFx0dW5zdXBwb3J0ZWRMYXllcjogXCJEZW5uZSBwYXJhbWV0ZXJlbiBzdMO4dHRlciBpa2tlIGbDuGxnZW5kZSBsYWc6ICR7bGF5ZXJOYW1lfS5cIixcblx0XHR2aWV3RGV0YWlsczogXCJWaXMgZnVsbHN0ZW5kaWdlIGVsZW1lbnRkZXRhbGplclwiLFxuXHRcdHJlbmFtZTogXCJHaSBueXR0IG5hdm5cIixcblx0XHRkdXBsaWNhdGU6IFwiRHVwbGlzZXJcIixcblx0XHRsYXVuY2g6IFwiw4VwbmUgZm9yIMOlIGtqw7hyZVwiLFxuXHRcdHRlbXBsYXRlRWRpdG9yOiBcIk1hbHJlZGlnZXJpbmdcIixcblx0XHRjcmVhdGVJdGVtOiBcIkxhZ3JlIHJhc3RlcmZ1bmtzam9uc21hbFwiLFxuXHRcdGFjdGlvbkxhYmVsOiBcIkZpbHRlclwiLFxuXHRcdGZpbHRlclBvcG92ZXJIZWFkaW5nOiBcIkZpbHRyZXIgZnVua3Nqb25lbmVcIixcblx0XHRkZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXI6IFwiU8O4ayBldHRlciBuYXZuXCIsXG5cdFx0c2V0dGluZ3M6IFwiSW5uc3RpbGxpbmdlclwiLFxuXHRcdHN1bW1hcnk6IFwiU2FtbWVuZHJhZ1wiLFxuXHRcdGRlZmluaXRpb25RdWVyeTogXCJEZWZpbmlzam9uc3Nww7hycmluZ1wiLFxuXHRcdG1hdGNoVmFyaWFibGVzOiBcIk1hdGNoIHZhcmlhYmxlclwiLFxuXHRcdHVuaW9uRGltZW5zaW9uOiBcIlVuaW9ubcOlbFwiLFxuXHRcdG5hbWVFZGl0b3JQbGFjZWhvbGRlcjogXCJBbmdpIHRpdHRlbFwiLFxuXHRcdHN1bW1hcnlFZGl0b3JQbGFjZWhvbGRlcjogXCJBbmdpIGVuIGtvcnQgYmVza3JpdmVsc2UuXCIsXG5cdFx0ZGVmaW5pdGlvblF1ZXJ5UGxhY2Vob2xkZXI6IFwiQW5naS4uLlwiLFxuXHRcdHVwbG9hZDogXCJPcHBsYXN0aW5nXCIsXG5cdFx0Y2hvb3NlSW1hZ2U6IFwiS2xpa2sgZm9yIMOlIHZlbGdlIGVuIGZpbFwiLFxuXHRcdHVwZGF0ZTogXCJPcHBkYXRlclwiLFxuXHRcdHRodW1ibmFpbEVycm9yczoge1xuXHRcdFx0d3JvbmdJbWFnZVR5cGU6IFwiRmVpbCBiaWxkZXR5cGUgdmFsZ3RcIixcblx0XHRcdG5vdEF2YWlsYWJsZTogXCJNaW5pYXR5cmJpbGRlIGlra2UgdGlsZ2plbmdlbGlnXCIsXG5cdFx0XHRsb2FkRXJyb3I6IFwiS2FuIGlra2UgbGFzdGUgaW5uIGJpbGRldFwiLFxuXHRcdFx0Y2hvb3NlRmlsZTogXCJLbGlrayBmb3Igw6UgdmVsZ2UgZmlsXCJcblx0XHR9XG5cdH1cbn07XG5jb25zdCBjb3B5ID0gXCJLb3BpZXJcIjtcbmNvbnN0IHNhdmUgPSBcIkxhZ3JlXCI7XG5jb25zdCB0aXRsZSA9IFwiVGl0dGVsXCI7XG5jb25zdCBmb2xkZXIgPSBcIk1hcHBlXCI7XG5jb25zdCB0YWdzID0gXCJUYWdnZXJcIjtcbmNvbnN0IHNhdmluZ01lc3NhZ2UgPSBcIkxhZ3JlciBlbGVtZW50IHRpbFwiO1xuY29uc3Qgc2hhcmVXaXRoID0gXCJEZWwgbWVkXCI7XG5jb25zdCBzaGFyZSA9IFwiRGVsZVwiO1xuY29uc3Qgc2V0U2hhcmluZ0xldmVsID0gXCJBbmdpIGRlbGluZ3NuaXbDpVwiO1xuY29uc3Qgc2V0R3JvdXBTaGFyaW5nID0gXCJBbmdpIGdydXBwZWRlbGluZ1wiO1xuY29uc3Qgb3duZXIgPSBcIkVpZXJcIjtcbmNvbnN0IG9yZ2FuaXphdGlvbiA9IFwiT3JnYW5pc2Fzam9uXCI7XG5jb25zdCBldmVyeW9uZSA9IFwiQWxsZSAob2ZmZW50bGlnKVwiO1xuY29uc3QgZ3JvdXBzID0gXCJHcnVwcGVyOlwiO1xuY29uc3QgdHlwZSA9IFwiVHlwZVwiO1xuY29uc3QgbW9zYWljID0gXCJNb3NhaWtrXCI7XG5jb25zdCBpdGVtR3JvdXAgPSBcIkVsZW1lbnRncnVwcGVcIjtcbmNvbnN0IGl0ZW0gPSBcIkVsZW1lbnRcIjtcbmNvbnN0IGRlZmluaXRpb25RdWVyeSA9IFwiRGVmaW5pc2pvbnNzcMO4cnJpbmdcIjtcbmNvbnN0IGdyb3VwSXRlbXNCeSA9IFwiR3J1cHBlciBlbGVtZW50ZXIgZXR0ZXJcIjtcbmNvbnN0IGdyb3VwRmllbGROYW1lID0gXCJHcnVwcGVyIGZlbHRuYXZuXCI7XG5jb25zdCB0YWdGaWVsZE5hbWUgPSBcIlRhZ2cgZmVsdG5hdm5cIjtcbmNvbnN0IG5vVGl0bGVUYWdFcnJvck1zZyA9IFwiRHUgbcOlIGFuZ2kgZW4gdGl0dGVsIHDDpSBlbGVtZW50ZXQgb2cgdGFnZ2VyIHNsaWsgYXQgZGV0IGVyIG11bGlnIMOlIGZpbm5lIGthcnRldCBnamVubm9tIHPDuGsuXCI7XG5jb25zdCBub1RpdGxlRXJyb3JNc2cgPSBcIkR1IG3DpSBvcHBnaSBlbiB0aXR0ZWwgZm9yIGVsZW1lbnRldCBkaXR0LlwiO1xuY29uc3Qgbm9UYWdFcnJvck1zZyA9IFwiRHUgbcOlIGFuZ2kgbWluc3Qgw6luIHRhZ2cgZm9yIGF0IGZvbGsgc2thbCBrdW5uZSBmaW5uZSBlbGVtZW50IGRpdHQgZ2plbm5vbSBzw7hrLlwiO1xuY29uc3QgZXJyb3IgPSBcIkZlaWxcIjtcbmNvbnN0IHdhcm5pbmcgPSBcIkFkdmFyc2VsXCI7XG5jb25zdCBzdWNjZXNzID0gXCJWZWxseWtrZXRcIjtcbmNvbnN0IGRldGFpbHMgPSBcIkRldGFsamVyOlwiO1xuY29uc3QgdHJ5QWdhaW4gPSBcIlByw7h2IHDDpSBueXR0XCI7XG5jb25zdCB0b29sTW9kZWxlciA9IHtcblx0c2F2ZTogXCJMYWdyZVwiLFxuXHRlZGl0UHJvcGVydGllczogXCJSZWRpZ2VyIGVnZW5za2FwZXJcIixcblx0c2F2ZUFzOiBcIkxhZ3JlIHNvbVwiLFxuXHRzYXZpbmdOb3RpZmljYXRpb246IFwiTGFncmVyIGVuZHJpbmdlciB0aWwgZWxlbWVudC4uLlwiLFxuXHRzYXZpbmdUaXRsZTogXCJMYWdyZXJcIixcblx0c2F2ZUZhaWxlZE1lc3NhZ2U6IFwiRW5kcmluZ2VuZSBibGUgaWtrZSBsYWdyZXQuXCIsXG5cdHNhdmVXaXRoRXJyb3JzTWVzc2FnZTogXCJFbmRyaW5nZXIgYmxlIGxhZ3JldCBtZWQgZsO4bGdlbmRlIGZlaWwuXCIsXG5cdHZpZXdJdGVtTWVzc2FnZTogXCJWaXMgbGFncmV0IGVsZW1lbnRcIixcblx0aGVyZTogXCJoZXIuXCIsXG5cdGl0ZW1DcmVhdGVkTWVzc2FnZTogXCJFdCBueXR0IGVsZW1lbnQgYmxlIG9wcHJldHRldFwiLFxuXHRjbGlja1RvVmlld0l0ZW1NZXNzYWdlOiBcIktsaWtrIHDDpSBPSyBmb3Igw6UgdmlzZSBlbGVtZW50ZGV0YWxqc2lkZW4sIG9nIGtsaWtrIHDDpSBBdmJyeXQgZm9yIMOlIGZvcnRzZXR0ZS5cIixcblx0cmVhZGluZ0ZhaWxlZDogXCJLYW4gaWtrZSBsYXN0ZSBpbm4gdmFsZ3QgcmFzdGVyZnVua3Nqb25zbWFsLlwiLFxuXHRmYWlsZWRUb0xvYWRYTUw6IFwiS2FuIGlra2UgbGFzdGUgaW5uIHZhbGd0IHJhc3RlcmZ1bmtzam9uc21hbCBpIFhNTC1mb3JtYXQuXCIsXG5cdGxlYXJuTW9yZTogXCJNZXIgaW5mb3JtYXNqb25cIixcblx0b3ZlcndyaXRlVGl0bGU6IFwiQmVrcmVmdCBvdmVyc2tyaXZpbmdcIixcblx0b3ZlcndyaXRlTWVzc2FnZTogXCJWaWwgZHUgb3ZlcnNrcml2ZSBla3Npc3RlcmVuZGUgZWxlbWVudD9cIixcblx0b3ZlcndyaXRlU3VjY2Vzc01lc3NhZ2U6IFwiRWxlbWVudGV0IGJsZSBvcHBkYXRlcnQuXCJcbn07XG5jb25zdCB0b29sRWRpdG9yID0ge1xuXHRydW46IFwiS2rDuHJcIixcblx0c2F2ZTogXCJMYWdyZVwiLFxuXHRkZWxldGVTZWxlY3RlZDogXCJTbGV0dCB2YWxndGUgZWxlbWVudGVyXCIsXG5cdGFkZFJhc3RlcjogXCJMZWdnIHRpbCByYXN0ZXJcIixcblx0YWRkU2NhbGFyOiBcIkxlZ2cgdGlsIHNrYWxhclwiLFxuXHRsYXlvdXQ6IFwiQXV0b21hdGlzayBvcHBzZXR0XCIsXG5cdGVycm9yVGl0bGU6IFwiRmVpbFwiLFxuXHRpbnZhbGlkVG9vbE1lc3NhZ2U6IFwiUmFzdGVyZnVua3Nqb25zbWFsIGVyIGlra2UgZ3lsZGlnLlwiLFxuXHRvdXQ6IFwiVXRcIixcblx0em9vbUluOiBcIlpvb20gaW5uXCIsXG5cdHpvb21PdXQ6IFwiWm9vbSB1dFwiLFxuXHR6b29tVG9GaXQ6IFwiVGlscGFzcyB0aWwgdmluZHVcIixcblx0cGFuT246IFwiQnl0dCB0aWwgcGFub3JlcmluZ3Ntb2R1c1wiLFxuXHRwYW5PZmY6IFwiU2zDpSBhdiBwYW5vcmVyaW5nc21vZHVzXCIsXG5cdGRlZmF1bHRNb2RlbE5hbWU6IFwiVmVydMO4eW1vZGVsbFwiLFxuXHRkZWZhdWx0UmFzdGVyTmFtZTogXCJSYXN0ZXJcIlxufTtcbmNvbnN0IHRvb2xEZXRhaWxzRWRpdG9yID0ge1xuXHRkZWZhdWx0VG9vbE5hbWU6IFwiUmFzdGVyZnVua3Nqb25zbWFsXCIsXG5cdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiTGVnZyB0aWwgZXQga29ydCBzYW1tZW5kcmFnIGZvciByYXN0ZXJmdW5rc2pvbmVuLlwiLFxuXHRkZWZhdWx0SGVscFRleHQ6IFwiS2xpa2sgcMOlIEhqZWxwLWlrb25ldCBmb3Igw6UgcmVkaWdlcmUgaGplbHBldGVrc3Rlbi5cIixcblx0ZWRpdEhlbHBUaXRsZTogXCJSZWRpZ2VyIGhqZWxwXCIsXG5cdHNhdmVMYWJlbDogXCJMYWdyZVwiLFxuXHRjYW5jZWxMYWJlbDogXCJBdmJyeXRcIixcblx0dGh1bWJuYWlsOiB7XG5cdFx0d3JvbmdJbWFnZVR5cGU6IFwiRmVpbCBiaWxkZXR5cGUgZXIgdmFsZ3RcIixcblx0XHRub3RBdmFpbGFibGU6IFwiTWluaWF0eXJiaWxkZSBpa2tlIHRpbGdqZW5nZWxpZ1wiLFxuXHRcdGxvYWRFcnJvcjogXCJLYW4gaWtrZSBsYXN0ZSBpbm4gYmlsZGV0XCIsXG5cdFx0Y2hvb3NlRmlsZTogXCJLbGlrayBmb3Igw6UgdmVsZ2UgZmlsXCJcblx0fVxufTtcbmNvbnN0IHNhdmVVdGlscyA9IHtcblx0dGh1bWJuYWlsOiBcIk1pbmlhdHlyYmlsZGVcIixcblx0c2hhcmluZzogXCJEZWxpbmdcIlxufTtcbmNvbnN0IGNsb3NlID0gXCJMdWtrXCI7XG5jb25zdCB1bnNhdmVkV2FybmluZ0V4aXN0aW5nID0gXCJWaWwgZHUgbGFncmUgZW5kcmluZ2VuZSB0aWwgZWxlbWVudGV0IDxiPiR7aXRlbVRpdGxlfTwvYj4gP1wiO1xuY29uc3QgdW5zYXZlZFdhcm5pbmdOZXcgPSBcIlZpbCBkdSBsYWdyZSBlbmRyaW5nZW5lP1wiO1xuY29uc3Qgc2F2ZUFzID0gXCJMYWdyZSBzb21cIjtcbmNvbnN0IGRvbnRTYXZlID0gXCJJa2tlIGxhZ3JlXCI7XG5jb25zdCB1bnNhdmVkVGl0bGUgPSBcIlVsYWdyZWRlIGVuZHJpbmdlclwiO1xuY29uc3QgaW52YWxpZFJGVE1lc3NhZ2UgPSBcIkRlbiBvcHByZXR0ZWRlIHJhc3RlcmZ1bmtzam9uc21hbGVuIGVyIGlra2UgZ3lsZGlnLlwiO1xuY29uc3QgZXJyb3JUaXRsZSA9IFwiRmVpbFwiO1xuY29uc3QgYnJlYWRjcnVtYiA9IFwiUmFzdGVyZnVua3Nqb25zcmVkaWdlcmluZ1wiO1xuY29uc3QgYnJlYWRjcnVtYkVkaXRvciA9IFwiSW5uaG9sZCA+IFJhc3RlcmZ1bmtzam9uc3JlZGlnZXJpbmdcIjtcbmNvbnN0IHZpZXdlck1vZGVUaXRsZSA9IFwiU2tyaXZlYmVza3l0dGV0XCI7XG5jb25zdCB2aWV3ZXJNb2RlTWVzc2FnZSA9IFwiUmFzdGVyZnVua3Nqb25zbWFsZWxlbWVudGV0IGVyIHNrcml2ZWJlc2t5dHRldC4gRW5kcmluZ2VyIGthbiBpa2tlIGxhZ3Jlcy5cIjtcbmNvbnN0IHVzZXJTdGFydERpcmVjdGlvbiA9IFwiVmVsZyBlbiBmdW5rc2pvbiBmb3Igw6Ugc3RhcnRlIG9wcHJldHRpbmdlbiBhdiBlbiByYXN0ZXJmdW5rc2pvbnNtYWwuXCI7XG5jb25zdCBzZWxlY3RGdW5jdGlvbiA9IFwiTGVnZyB0aWwgZnVua3Nqb25cIjtcbmNvbnN0IGRlc2VsZWN0RnVuY3Rpb24gPSBcIkZqZXJuIGZ1bmtzam9uXCI7XG5jb25zdCBkaWFsb2dUaXRsZSA9IFwiU3lzdGVtXCI7XG5jb25zdCBjYXRlZ29yeSA9IFwiS2F0ZWdvcmllclwiO1xuY29uc3Qgc2VhcmNoID0gXCJTw7hrIGkgcmFzdGVyZnVua3Nqb25lclwiO1xuY29uc3QgY2F0ZWdvcnlOYW1lcyA9IHtcblx0YW5hbHlzaXM6IFwiQW5hbHlzZVwiLFxuXHRhcHBlYXJhbmNlOiBcIlV0c2VlbmRlXCIsXG5cdGNsYXNzaWZpY2F0aW9uOiBcIktsYXNzaWZpc2VyaW5nXCIsXG5cdGNvbnZlcnNpb246IFwiS29udmVydGVyaW5nXCIsXG5cdGNvcnJlY3Rpb246IFwiS29ycmlnZXJpbmdcIixcblx0ZGF0YU1hbmFnZW1lbnQ6IFwiRGF0YWJlaGFuZGxpbmdcIixcblx0ZGlzdGFuY2U6IFwiQXZzdGFuZFwiLFxuXHRkaXN0YW5jZUxlZ2FjeTogXCJBdnN0YW5kICh1dGZhc2V0KVwiLFxuXHRoeWRyb2xvZ3k6IFwiSHlkcm9sb2dpXCIsXG5cdG1hdGg6IFwiTWF0ZW1hdGlra1wiLFxuXHRtYXRoQ29uZGl0aW9uYWw6IFwiTWF0ZW1hdGlrazogQmV0aW5nZWxzZVwiLFxuXHRtYXRoTG9naWNhbDogXCJNYXRlbWF0aWtrOiBMb2dpa2tcIixcblx0bWF0aFRyaWdvbm9tZXRyaWM6IFwiTWF0ZW1hdGlrazogVHJpZ29ub21ldHJpc2tcIixcblx0cmVjbGFzczogXCJSZWtsYXNzaWZpc2VyaW5nXCIsXG5cdHN0YXRpc3RpY2FsOiBcIlN0YXRpc3Rpa2tcIixcblx0c3VyZmFjZTogXCJPdmVyZmxhdGVcIlxufTtcbmNvbnN0IGNvbW1vblN0cmluZ3NfbmIgPSB7XG5cdG9rOiBvayxcblx0Y2FuY2VsOiBjYW5jZWwsXG5cdGVudGVyVVJMOiBlbnRlclVSTCxcblx0c2VydmljZVVSTDogc2VydmljZVVSTCxcblx0c2VsZWN0UmFzdGVyOiBzZWxlY3RSYXN0ZXIsXG5cdGZhaWxlZFRvTG9hZExheWVyOiBmYWlsZWRUb0xvYWRMYXllcixcblx0bG9hZGluZ0xheWVyOiBsb2FkaW5nTGF5ZXIsXG5cdHNlbGVjdEZlYXR1cmU6IHNlbGVjdEZlYXR1cmUsXG5cdGVudGVyRlVSTDogZW50ZXJGVVJMLFxuXHRhZGRSYXN0ZXI6IGFkZFJhc3Rlcixcblx0YWRkU2NhbGFyOiBhZGRTY2FsYXIsXG5cdHJhc3RlcjogcmFzdGVyLFxuXHRzY2FsYXI6IHNjYWxhcixcblx0ZGVmYXVsdE1vZGVsTmFtZTogZGVmYXVsdE1vZGVsTmFtZSxcblx0Z2VuZXJhbDogZ2VuZXJhbCxcblx0cGFyYW1ldGVyczogcGFyYW1ldGVycyxcblx0dmFyaWFibGVzOiB2YXJpYWJsZXMsXG5cdG5hbWU6IG5hbWUsXG5cdGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcblx0cGFyYW1ldGVyOiBwYXJhbWV0ZXIsXG5cdGlzUHVibGljOiBpc1B1YmxpYyxcblx0aXNEYXRhc2V0OiBpc0RhdGFzZXQsXG5cdHVua25vd25QaXhlbFR5cGU6IHVua25vd25QaXhlbFR5cGUsXG5cdG91dHB1dFBpeGVsVHlwZTogb3V0cHV0UGl4ZWxUeXBlLFxuXHR1OFBpeGVsVHlwZTogdThQaXhlbFR5cGUsXG5cdHM4UGl4ZWxUeXBlOiBzOFBpeGVsVHlwZSxcblx0dTE2UGl4ZWxUeXBlOiB1MTZQaXhlbFR5cGUsXG5cdHMxNlBpeGVsVHlwZTogczE2UGl4ZWxUeXBlLFxuXHR1MzJQaXhlbFR5cGU6IHUzMlBpeGVsVHlwZSxcblx0czMyUGl4ZWxUeXBlOiBzMzJQaXhlbFR5cGUsXG5cdGYzMlBpeGVsVHlwZTogZjMyUGl4ZWxUeXBlLFxuXHRmNjRQaXhlbFR5cGU6IGY2NFBpeGVsVHlwZSxcblx0cHJvcGVydGllczogcHJvcGVydGllcyxcblx0bXVsdGlkaW1lbnNpb25hbFJ1bGVzOiBtdWx0aWRpbWVuc2lvbmFsUnVsZXMsXG5cdG1hdGNoVmFyaWFibGVzOiBtYXRjaFZhcmlhYmxlcyxcblx0dW5pb25EaW1lbnNpb25zOiB1bmlvbkRpbWVuc2lvbnMsXG5cdHJhc3RlckZ1bmN0aW9uRWRpdG9yOiByYXN0ZXJGdW5jdGlvbkVkaXRvcixcblx0cmZ4TGljZW5zZUluZm86IHJmeExpY2Vuc2VJbmZvLFxuXHRyYXN0ZXJGdW5jdGlvbnM6IHJhc3RlckZ1bmN0aW9ucyxcblx0Y29weTogY29weSxcblx0c2F2ZTogc2F2ZSxcblx0dGl0bGU6IHRpdGxlLFxuXHRmb2xkZXI6IGZvbGRlcixcblx0dGFnczogdGFncyxcblx0c2F2aW5nTWVzc2FnZTogc2F2aW5nTWVzc2FnZSxcblx0c2hhcmVXaXRoOiBzaGFyZVdpdGgsXG5cdHNoYXJlOiBzaGFyZSxcblx0c2V0U2hhcmluZ0xldmVsOiBzZXRTaGFyaW5nTGV2ZWwsXG5cdHNldEdyb3VwU2hhcmluZzogc2V0R3JvdXBTaGFyaW5nLFxuXHRvd25lcjogb3duZXIsXG5cdG9yZ2FuaXphdGlvbjogb3JnYW5pemF0aW9uLFxuXHRldmVyeW9uZTogZXZlcnlvbmUsXG5cdGdyb3VwczogZ3JvdXBzLFxuXHR0eXBlOiB0eXBlLFxuXHRtb3NhaWM6IG1vc2FpYyxcblx0aXRlbUdyb3VwOiBpdGVtR3JvdXAsXG5cdGl0ZW06IGl0ZW0sXG5cdGRlZmluaXRpb25RdWVyeTogZGVmaW5pdGlvblF1ZXJ5LFxuXHRncm91cEl0ZW1zQnk6IGdyb3VwSXRlbXNCeSxcblx0Z3JvdXBGaWVsZE5hbWU6IGdyb3VwRmllbGROYW1lLFxuXHR0YWdGaWVsZE5hbWU6IHRhZ0ZpZWxkTmFtZSxcblx0bm9UaXRsZVRhZ0Vycm9yTXNnOiBub1RpdGxlVGFnRXJyb3JNc2csXG5cdG5vVGl0bGVFcnJvck1zZzogbm9UaXRsZUVycm9yTXNnLFxuXHRub1RhZ0Vycm9yTXNnOiBub1RhZ0Vycm9yTXNnLFxuXHRlcnJvcjogZXJyb3IsXG5cdHdhcm5pbmc6IHdhcm5pbmcsXG5cdHN1Y2Nlc3M6IHN1Y2Nlc3MsXG5cdGRldGFpbHM6IGRldGFpbHMsXG5cdHRyeUFnYWluOiB0cnlBZ2Fpbixcblx0dG9vbE1vZGVsZXI6IHRvb2xNb2RlbGVyLFxuXHR0b29sRWRpdG9yOiB0b29sRWRpdG9yLFxuXHR0b29sRGV0YWlsc0VkaXRvcjogdG9vbERldGFpbHNFZGl0b3IsXG5cdHNhdmVVdGlsczogc2F2ZVV0aWxzLFxuXHRjbG9zZTogY2xvc2UsXG5cdHVuc2F2ZWRXYXJuaW5nRXhpc3Rpbmc6IHVuc2F2ZWRXYXJuaW5nRXhpc3RpbmcsXG5cdHVuc2F2ZWRXYXJuaW5nTmV3OiB1bnNhdmVkV2FybmluZ05ldyxcblx0c2F2ZUFzOiBzYXZlQXMsXG5cdGRvbnRTYXZlOiBkb250U2F2ZSxcblx0dW5zYXZlZFRpdGxlOiB1bnNhdmVkVGl0bGUsXG5cdGludmFsaWRSRlRNZXNzYWdlOiBpbnZhbGlkUkZUTWVzc2FnZSxcblx0ZXJyb3JUaXRsZTogZXJyb3JUaXRsZSxcblx0YnJlYWRjcnVtYjogYnJlYWRjcnVtYixcblx0YnJlYWRjcnVtYkVkaXRvcjogYnJlYWRjcnVtYkVkaXRvcixcblx0dmlld2VyTW9kZVRpdGxlOiB2aWV3ZXJNb2RlVGl0bGUsXG5cdHZpZXdlck1vZGVNZXNzYWdlOiB2aWV3ZXJNb2RlTWVzc2FnZSxcblx0dXNlclN0YXJ0RGlyZWN0aW9uOiB1c2VyU3RhcnREaXJlY3Rpb24sXG5cdHNlbGVjdEZ1bmN0aW9uOiBzZWxlY3RGdW5jdGlvbixcblx0ZGVzZWxlY3RGdW5jdGlvbjogZGVzZWxlY3RGdW5jdGlvbixcblx0ZGlhbG9nVGl0bGU6IGRpYWxvZ1RpdGxlLFxuXHRjYXRlZ29yeTogY2F0ZWdvcnksXG5cdHNlYXJjaDogc2VhcmNoLFxuXHRjYXRlZ29yeU5hbWVzOiBjYXRlZ29yeU5hbWVzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb21tb25TdHJpbmdzX25iO1xuZXhwb3J0IHsgYWRkUmFzdGVyLCBhZGRTY2FsYXIsIGJyZWFkY3J1bWIsIGJyZWFkY3J1bWJFZGl0b3IsIGNhbmNlbCwgY2F0ZWdvcnksIGNhdGVnb3J5TmFtZXMsIGNsb3NlLCBjb3B5LCBkZWZhdWx0TW9kZWxOYW1lLCBkZWZpbml0aW9uUXVlcnksIGRlc2NyaXB0aW9uLCBkZXNlbGVjdEZ1bmN0aW9uLCBkZXRhaWxzLCBkaWFsb2dUaXRsZSwgZG9udFNhdmUsIGVudGVyRlVSTCwgZW50ZXJVUkwsIGVycm9yLCBlcnJvclRpdGxlLCBldmVyeW9uZSwgZjMyUGl4ZWxUeXBlLCBmNjRQaXhlbFR5cGUsIGZhaWxlZFRvTG9hZExheWVyLCBmb2xkZXIsIGdlbmVyYWwsIGdyb3VwRmllbGROYW1lLCBncm91cEl0ZW1zQnksIGdyb3VwcywgaW52YWxpZFJGVE1lc3NhZ2UsIGlzRGF0YXNldCwgaXNQdWJsaWMsIGl0ZW0sIGl0ZW1Hcm91cCwgbG9hZGluZ0xheWVyLCBtYXRjaFZhcmlhYmxlcywgbW9zYWljLCBtdWx0aWRpbWVuc2lvbmFsUnVsZXMsIG5hbWUsIG5vVGFnRXJyb3JNc2csIG5vVGl0bGVFcnJvck1zZywgbm9UaXRsZVRhZ0Vycm9yTXNnLCBvaywgb3JnYW5pemF0aW9uLCBvdXRwdXRQaXhlbFR5cGUsIG93bmVyLCBwYXJhbWV0ZXIsIHBhcmFtZXRlcnMsIHByb3BlcnRpZXMsIHJhc3RlciwgcmFzdGVyRnVuY3Rpb25FZGl0b3IsIHJhc3RlckZ1bmN0aW9ucywgcmZ4TGljZW5zZUluZm8sIHMxNlBpeGVsVHlwZSwgczMyUGl4ZWxUeXBlLCBzOFBpeGVsVHlwZSwgc2F2ZSwgc2F2ZUFzLCBzYXZlVXRpbHMsIHNhdmluZ01lc3NhZ2UsIHNjYWxhciwgc2VhcmNoLCBzZWxlY3RGZWF0dXJlLCBzZWxlY3RGdW5jdGlvbiwgc2VsZWN0UmFzdGVyLCBzZXJ2aWNlVVJMLCBzZXRHcm91cFNoYXJpbmcsIHNldFNoYXJpbmdMZXZlbCwgc2hhcmUsIHNoYXJlV2l0aCwgc3VjY2VzcywgdGFnRmllbGROYW1lLCB0YWdzLCB0aXRsZSwgdG9vbERldGFpbHNFZGl0b3IsIHRvb2xFZGl0b3IsIHRvb2xNb2RlbGVyLCB0cnlBZ2FpbiwgdHlwZSwgdTE2UGl4ZWxUeXBlLCB1MzJQaXhlbFR5cGUsIHU4UGl4ZWxUeXBlLCB1bmlvbkRpbWVuc2lvbnMsIHVua25vd25QaXhlbFR5cGUsIHVuc2F2ZWRUaXRsZSwgdW5zYXZlZFdhcm5pbmdFeGlzdGluZywgdW5zYXZlZFdhcm5pbmdOZXcsIHVzZXJTdGFydERpcmVjdGlvbiwgdmFyaWFibGVzLCB2aWV3ZXJNb2RlTWVzc2FnZSwgdmlld2VyTW9kZVRpdGxlLCB3YXJuaW5nIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi1zdHJpbmdzLm5iLTVlYzQzYTRiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==