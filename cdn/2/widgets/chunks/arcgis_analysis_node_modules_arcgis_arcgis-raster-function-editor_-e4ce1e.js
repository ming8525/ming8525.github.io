"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-e4ce1e"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.sv-9d23d938.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.sv-9d23d938.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "OK";
const cancel = "Avbryt";
const enterURL = "Ange URL till bildtjänst";
const serviceURL = "Tjänste-URL";
const selectRaster = "Välj raster";
const failedToLoadLayer = "Det gick inte att läsa in lagret";
const loadingLayer = "Läser in lager";
const selectFeature = "Välj geoobjektlager";
const enterFURL = "Ange URL till geoobjekttjänst";
const addRaster = "Lägg till rastervariabel";
const addScalar = "Lägg till konstant";
const raster = "Raster";
const scalar = "Skalär";
const defaultModelName = "Mall för rasterfunktion";
const general = "Allmänt";
const parameters = "Parametrar";
const variables = "Variabler";
const name = "Namn";
const description = "Beskrivning";
const parameter = "Parameter";
const isPublic = "IsPublic";
const isDataset = "IsDataset";
const unknownPixelType = "Okänt";
const outputPixelType = "Pixeltyp för utdata";
const u8PixelType = "8-bitars osignerad";
const s8PixelType = "8-bitars signerad";
const u16PixelType = "16-bitars osignerad";
const s16PixelType = "16-bitars signerade";
const u32PixelType = "32-bitars osignerade";
const s32PixelType = "32-bitars signerad";
const f32PixelType = "32-bitars flyttal";
const f64PixelType = "64-bitars dubbel";
const properties = "Egenskaper";
const multidimensionalRules = "Flerdimensionella regler";
const matchVariables = "Matcha variabler";
const unionDimensions = "Unionsdimensioner";
const rasterFunctionEditor = {
	invalidRFTMessage: "Rasterfunktionsmallen är inte giltig.",
	rfxArgsEditor: {
		outputRaster: "OutputRaster",
		raster: "Raster",
		unsupportedDataTypeWarning: "Följande argument visas inte eftersom de för närvarande inte stöds.",
		unsupportedFunction: "Innehåller rasterfunktion(er) som för närvarande inte stöds."
	},
	rfxRasterInput: {
		selectLayer: "Välj lager",
		browseLayers: "Bläddra bland lager",
		rfxVariable: "RasterFunctionVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Metod",
		bandLabel: "Band",
		combinationLabel: "Kombination"
	},
	rfxRemapGrid: {
		minimum: "Minimum",
		maximum: "Maximalt",
		output: "Utdata",
		noData: "NoData",
		remapValuesLabel: "Mappa om värden"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Rastervariabler",
		deleteSelectedVars: "Ta bort valda variabler"
	},
	rfxClippingGeometry: {
		clippingLayer: "Beskärningslager",
		clippingRaster: "Klipper raster",
		clippingGeometry: "Klippningsgeometri",
		customExtent: "Anpassad utbredning",
		outputExtent: "Utdatautbredning",
		currentExtent: "Aktuell kartutbredning",
		drawLabel: "Rita"
	},
	rfxCustomExtent: {
		top: "Övre",
		right: "Höger",
		bottom: "Längst ned",
		left: "Vänster"
	},
	rfxRasterArrayEditor: {
		moveUp: "Flytta uppåt",
		moveDown: "Flytta nedåt",
		remove: "Ta bort"
	},
	rfxStatisticsGrid: {
		stdDev: "Std. av.",
		min: "Min.",
		max: "Max",
		mean: "Medelvärde"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Viktad summeringstabell",
		id: "ID",
		layer: "Lager",
		field: "Fält",
		weight: "Vikt",
		value: "Värde",
		selectLayer: "Välj lager"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Viktad överlagringstabell",
		id: "ID",
		layer: "Lager",
		field: "Fält",
		influence: "Inflytande",
		sumOfInfluence: "Summa av inflytande",
		value: "Värde",
		remapTable: "Ommappningstabell",
		scale: "Skala",
		scales: "Skalor",
		selectRaster: "Välj raster"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Bläddra efter ett geoobjektlager",
		addPointLayer: "Bläddra efter ett punktlager"
	},
	rfxFieldSelect: {
		value: "Värde",
		count: "Antal"
	},
	rfxAttributeTable: {
		tableType: "Tabelltyp",
		manual: "Manuell",
		external: "Extern",
		minVal: "Minsta värde",
		maxVal: "Maximalt värde",
		baseClassName: "Klassbasnamn",
		colorScheme: "Färgschema",
		defaultClassName: "Label_",
		generateTable: "Skapa tabell",
		browseTable: "Bläddra i tabell",
		value: "Värde",
		classname: "ClassName",
		color: "Färg"
	},
	rfxFieldNumberSwitchable: {
		number: "Numerisk",
		field: "Fält",
		string: "Sträng",
		linearUnit: "Linjär enhet"
	},
	rfxPropertySet: {
		name: "Namn",
		value: "Värde"
	},
	rfxConversionGrid: {
		size: "Storlek"
	},
	rfxTransposeBit: {
		bitPattern: "Bitmönster",
		outputBit: "Utdatabit",
		inputBit: "Indatabit"
	},
	rfxSpatialReference: {
		placeHolder: "Förfina genom nyckelord",
		coordinateSystem: "Koordinatsystem",
		gcs: "Geografiskt koordinatsystem",
		pcs: "Projicerat koordinatsystem",
		vcs: "Vertikalt koordinatsystem"
	}
};
const rfxLicenseInfo = "Denna mall för rasterfunktion kan användas till att bearbeta dina bilder med ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "ACosH",
		aCosHSnip: "Beräknar omvänd hyperbolisk cosinus för celler i ett raster.",
		aCosHDesc: "Funktionen beräknar omvänd hyperbolisk cosinus för pixlarna i ett raster.",
		aCosName: "ACos",
		aCosSnip: "Beräknar omvänd cosinus för pixlarna i ett raster.",
		aCosDesc: "Denna rasterfunktion beräknar omvänd cosinus för celler i ett raster. Inom matematiken har alla trigonometriska funktioner ett definierat omfång av giltiga ingångsvärden som kallas domän. Resultatvärdena från varje funktion har också ett omfång för resultatvärden. För det här verktyget är domänen [-1, 1] och omfånget [0, pi].",
		aSinHName: "ASinH",
		aSinHSnip: "Beräknar omvänd hyperbolisk sinus för celler i ett raster.",
		aSinHDesc: "Funktionen beräknar omvänd hyperbolisk sinus för pixlarna i ett raster.",
		aSinName: "ASin",
		aSinSnip: "Beräknar omvänd sinus för celler i ett raster.",
		aSinDesc: "Funktionen beräknar omvänd sinus för pixlarna i ett raster.",
		aTan2Name: "ATan2",
		aTan2Snip: "Beräknar omvänd tangent (baserad på x,y) för celler i ett raster.",
		aTan2Desc: "Funktionen beräknar omvänd tangent (baserat på x,y) för pixlarna i ett raster.",
		aTanHName: "ATanH",
		aTanHSnip: "Beräknar omvänd hyperbolisk tangent för celler i ett raster.",
		aTanHDesc: "Funktionen beräknar omvänd hyperbolisk tangent för pixlarna i ett raster.",
		aTanName: "ATan",
		aTanSnip: "Beräknar omvänd tangent för celler i ett raster.",
		aTanDesc: "Funktionen beräknar omvänd tangent för pixlarna i ett raster.",
		absName: "Abs",
		absSnip: "Beräknar absolut värde för cellerna i ett raster.",
		absDesc: "Abs-funktionen beräknar absolut värde för pixlarna i ett raster.",
		reflectanceName: "Skenbar reflektans",
		reflectanceSnip: "Konverterar obearbetade bilder till Top of Atmosphere-värden genom att ta hänsyn till sensoregenskaper, solens position och vilken tid bilden togs.",
		reflectanceDesc: "Den här funktionen justerar det digitala siffervärdet för bildens ljusstyrka (DN) för några satellitsensorer. Justeringarna baseras på solhöjd, anskaffningsdatum och sensoregenskaper för att ställa in förstärkning och snedvridning för varje band. Den här funktionen används för att justera värden för reflektans, eller ljusstyrka, för några satellitbilder baserat på scenbelysning och inställningar för sensorförstärkning. Bilderna justeras efter en belysning som är vanlig i teorin, så att scenerna från olika datum och sensorer inte ska skilja sig så mycket. Detta kan vara användbart för bildklassificering, färgbalansering och mosaikbearbetning. Den här funktionen kan endast användas med specifika bilder. Sensorerna som går att använda är Landsat MSS, Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 och Pleiades.<div><br/>Funktionen utför två korrigeringar. Den första är baserad på förstärkningsinställningarna. De ursprungliga värdena för ljusstyrka återskapas från bildvärdena genom att vända på förstärkningsekvationerna. Den andra korrigeringen avser skillnader i solvinkel och ljusstyrka. De ursprungliga värdena för ljusstyrka justeras till ett vanligt ljusförhållande genom att normalisera scener som fångats under varierande belysning. Medan utdata för bilder i regel är av samma typ som indata för bilder, är värdena för utdata lägre än värdena för indata och klipps till giltigt dataintervall.</div>",
		argStatisticsName: "ArgStatistics",
		argStatisticsSnip: "Beräknar arg-statistik, inklusive Arg Max, Arg Min, Arg Median och Varaktighet.",
		argStatisticsDesc: "Funktionen beräknar arg-statistik. Det finns fyra metoder i ArgStatistics-funktionen: ArgMax, ArgMin, ArgMedian och Duration.",
		arithmeticName: "Aritmetiskt",
		arithmeticSnip: "Utför en aritmetisk åtgärd mellan två raster eller ett raster och en skalär.",
		arithmeticDesc: "Den aritmetiska funktionen utför en aritmetisk åtgärd mellan två raster eller ett raster och en skalär och vice versa.",
		aspectSlopeName: "Riktning–lutning",
		aspectSlopeSnip: "Skapar ett raster som samtidigt visar riktning och lutning för en kontinuerlig yta, enligt representationen i en digital höjdmodell.",
		aspectSlopeDesc: "Riktning–lutning-funktionen skapar ett rasterlager som samtidigt visar aspekten och lutningen för en yta. Aspekten identifierar lutningsriktningen nedåt för den största värdeskillnaden från en pixel till anslutande pixlar. Du kan tänka dig aspekten som lutningsriktningen. Värdena i utdatarastret är aspektens kompassriktning som visas genom en nyans (färg). Lutningen representerar ändringsfrekvensen för höjd för varje pixel i den digitala höjdmodellen (DEM). Lutningen representerar ytans lutning och symboliseras av tre klasser som visas genom färgmättnad (ljusstyrka).<div><br/>Pixelvärdena i utdatarastret för riktning–lutning visar en kombination aspekt och lutning. Pixlar med värden under 20 räknas som plana och visas i grått. Riktning–lutning-värden på 21 och över visas med olika färgmättnad med följande indelning: 21 till 30 —Färgmättnad för liten lutning, 31 till 40—Färgmättnad för måttlig lutning, 41 och över—Färgmättnad för hög lutning</div>",
		aspectName: "Lutningsriktning",
		aspectSnip: "Visar åt vilket håll en pixel är vänd, där 0 är rakt norrut och vinklarna ökas medurs till 360.",
		aspectDesc: "Aspektfunktionen identifierar lutningens riktning för den högsta graden av skillnad i värden från en cell till anslutande celler. Du kan tänka dig aspekten som lutningsriktningen. Värdena i utdatarastret är aspektens kompassriktning.<div><br/>Indata för den här funktionen är indatarastret. Aspektfunktionen används ofta på en digital höjdmodell (DEM). Som standard visas aspekten som en bild i gråskala. Du kan lägga till funktionen färgschema för att ange ett särskilt färgschema eller låta personen som visar mosaiken ändra symbologin med sitt eget färgschema.</div>",
		tableName: "Attributtabell",
		tableSnip: "Använder en tabell för att namnge och symbolisera värdena i ett dataset. Kolumner för tabellen avgränsas med kommatecken: PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "Funktionen attributtabell gör att du kan definiera en attributtabell för att symbolisera ett mosaikdataset eller rasterdataset med ett band. <div><br/>Detta är användbart när du vill presentera bilder som har klassificerats för markanvändning, till exempel skogsmark, våtmark, åkermark och stadsmark. Om din tabell innehåller fält som namnges som röda, gröna och blå kommer dessutom värden inom de fälten att användas som en färgkarta när bilden renderas.</div>",
		bandArithmeticName: "Band aritmetiskt",
		bandArithmeticSnip: "Beräknar index med hjälp av fördefinierade formler eller ett användardefinierat uttryck.",
		bandArithmeticDesc: "Funktionen Band aritmetiskt utför en aritmetisk åtgärd på banden för ett rasterdataset. Du kan välja fördefinierade algoritmer eller ange din egen enradiga formel. Operatorerna som stöds är -,+,/,*, och enställig -.",
		thresholdName: "Binärt tröskelvärde",
		thresholdSnip: "Ordnar kontinuerliga data i förgrund och bakgrund genom att minimera kovariansen mellan de båda klasserna.",
		thresholdDesc: "När ett rasterdataset har en bimodal fördelning, skapar den här funktionen ett nytt raster som delar in data i två distinkta klasser. Den skapar en klass med låga värden med svarta pixlar, och en klass med höga värden som visas med vita pixlar.",
		bitwiseAndName: "Bitvist And",
		bitwiseAndSnip: "Utför en bitvis And-åtgärd på de binära värdena i två indataraster.",
		bitwiseAndDesc: "Bitvis And utför en bitvis And-åtgärd på de binära värdena i två indataraster",
		bitwiseLeftShiftName: "Bitvist vänsterskift",
		bitwiseLeftShiftSnip: "Utför en bitvis vänsterskiftsåtgärd på de binära värdena i två indataraster.",
		bitwiseLeftShiftDesc: "Bitvis vänsterskift utför en bitvis vänsterskiftsåtgärd på de binära värdena i två indataraster.",
		bitwiseNotName: "Bitvist Not",
		bitwiseNotSnip: "Utför en bitvis Not-åtgärd (komplement) på det binära värdet i två indataraster.",
		bitwiseNotDesc: "Funktionen utför en bitvis Not-åtgärd (komplement) på det binära värdet i ett indataraster.",
		bitwiseOrName: "Bitvist Or",
		bitwiseOrSnip: "Utför en bitvis Or-åtgärd på de binära värdena i två indataraster.",
		bitwiseOrDesc: "Funktionen utför en bitvis Or-åtgärd på de binära värdena i två indataraster. ",
		bitwiseRightShiftName: "Bitvist högerskift",
		bitwiseRightShiftSnip: "Utför en bitvis högerskiftsåtgärd på de binära värdena i två indataraster.",
		bitwiseRightShiftDesc: "Funktionen utför en bitvis högerskiftsåtgärd på de binära värdena i två indataraster.",
		bitwiseXorName: "Bitvist Xor",
		bitwiseXorSnip: "Utför en bitvis eXclusive Or-åtgärd på de binära värdena i två indataraster.",
		bitwiseXorDesc: "Funktionen utför en bitvis eXclusive Ir-åtgärd på de binära värdena i två indataraster",
		booleanAndName: "Booleskt And",
		booleanAndSnip: "Utför en boolesk And-åtgärd på cellvärdena i två indataraster. Om båda indatavärdena är sanna (ej noll), är utdatavärdet 1. Om det ena eller båda indata är falska (noll), är utdatavärdet 0.",
		booleanAndDesc: "Funktionen utför en boolesk And-åtgärd på de pixelvärdena i två indataraster. Om båda indatavärdena är sanna (ej noll), är utdatavärdet 1. Om det ena eller båda indatavärdena är falska (noll), är utdatavärdet 0. ",
		booleanNotName: "Booleskt Not",
		booleanNotSnip: "Utför en boolesk Not-åtgärd (komplement) på cellvärdena i indatarastret. Om indatavärdena är sanna (ej noll), är utdatavärdet 0. Om indatavärdena är falska (noll), är utdatavärdet 1.",
		booleanNotDesc: "Funktionen utför en boolesk Not-åtgärd (komplement) på pixelvärdena i indatarastret. Om indatavärdena är sanna (ej noll), är utdatavärdet 0. Om indatavärdena är falska (noll), är utdatavärdet 1.",
		booleanOrName: "Booleskt Or",
		booleanOrSnip: "Utför en boolesk Or-åtgärd på cellvärdena i de två indatarastren. Om det ena eller båda indatavärdena är sanna (ej noll), är utdatavärdet 1. Om båda indatavärdena är falska (noll), är utdatavärdet 0.",
		booleanOrDesc: "Funktionen utför en boolesk Or-åtgärd på cellvärdena i två indataraster. Om det ena eller båda indatavärdena är sanna (ej noll), är utdatavärdet 1. Om båda indatavärdena är falska (noll), är utdatavärdet 0.",
		booleanXorName: "Booleskt Xor",
		booleanXorSnip: "Utför en boolesk eXclusive Or-åtgärd på cellvärdena i två indataraster. Om ett indatavärde är sant (ej noll) och det andra falskt (noll), är utdatavärdet 1. Om båda indatavärdena är sanna eller båda är falska, är utdatavärdet 0.",
		booleanXorDesc: "Funktionen utför en boolesk eXclusive Or-åtgärd på cellvärdena i två indataraster. Om ett indatavärde är sant (ej noll) och det andra värdet är falskt (noll), är utdatavärdet 1. Om båda indatavärdena är sanna eller båda är falska, är utdatavärdet 0.",
		bufferedRasterName: "Buffrad",
		bufferedRasterSnip: "Buffrar senast använda pixelblock.",
		bufferedRasterDesc: "Den buffrade funktionen används för att optimera prestanda hos komplexa funktionskedjor. Den lagrar utdata i minnet för den del av funktionskedjan som kommer före. <div><br/>Infoga den här funktionen i funktionsredigeraren där du vill lagra utdata.</div>",
		rasterCalculatorName: "Miniräknare",
		rasterCalculatorSnip: "Beräknar ett raster från ett rasterbaserat matematiskt uttryck.",
		rasterCalculatorDesc: "Kalkylatorfunktionen gör att du kan skapa och köra uttryck och ha med dem i funktionskedjor.",
		cellStatisticsName: "Cellstatistik",
		cellStatisticsSnip: "Beräknar statistik per cell från flera raster. De tillgängliga statistiska kategorierna är Majoritet, Maximum, Medel, Median, Minimum, Minoritet, Procentsats, Intervall, Standardavvikelse, Summa och Variation.",
		cellStatisticsDesc: "Den här funktionen beräknar statistik från flera raster, pixel för pixel. De tillgängliga statistiska kategorierna är Majoritet, Maximum, Medel, Median, Minimum, Minoritet, Intervall, Standardavvikelse, Summa och Variation.",
		classifyName: "Klassificera",
		classifySnip: "Tilldelar varje pixel till en klass. Lägg till underordnade data, t.ex. en segmenterad bild.",
		classifyDesc: "Den här rasterfunktionen klassificerar ett rasterdataset baserat på en definitionsfil för Esri-klassificerare (.ecd) och indata från rasterdataset. Den .ecd-fil som används i klassificeringsfunktionen innehåller all information för ett specifikt dataset och en specifik klassificerare, och genereras av utbildningsverktygen för klassificering, som Tågets stödvektormaskin och Tågets slumpmässiga träd.",
		clipName: "Klipp",
		clipSnip: "Anger ett rasters utbredning med koordinater eller ett annat dataset.",
		clipDesc: "Den här funktionen klipper ett raster med en rektangulär form i enlighet med den definierade utbredningen, eller klipper ett raster till formen av en polygongeoobjektsklass för indata. Formen som definierar klippet kan klippa rastrets utbredning eller klippa ut ett område inom rastret.",
		colorspaceConversionName: "Färgmodellkonvertering",
		colorspaceConversionSnip: "Konverterar ett raster från RGB till HSV och vice versa.",
		colorspaceConversionDesc: "Funktionen Färgmodellkonvertering konverterar en bilds färgmodell från färgområdet nyans, mättnad och värde (HSV) till rött, grönt och blått (RGB), eller vice versa.<div><br/>Den här funktionen kan användas i ett mosiakdataset.</div>",
		colormapToRGBName: "Färgschema till RGB",
		colormapToRGBSnip: "Konverterar ett raster med ett band med ett färgschema, till ett raster med tre band (rött, grönt och blått).",
		colormapToRGBDesc: "Den här funktionen konverterar raster med ett band med ett färgschema till ett raster med tre band (rött, grönt och blått).<div><br/>Den här funktionen är användbar när du behöver skapa ett raster med tre band från ett raster med ett band med tillhörande färgkarta. Värdena i färgkartan används för att skapa varje rött, grönt och blått band. Den här funktionen kan användas i ett mosiakdataset.</div>",
		colormapName: "Färgschema",
		colormapSnip: "Ändrar pixelvärdena så att rasterdata visas antingen som gråskala eller som en RGB-bild (rött, grönt, blått), baserat på ett färgschema eller en färgramp.",
		colormapDesc: "Funktionen Färgschema är en typ av renderare av rasterdata. Den omvandlar pixelvärdena så att de visar rasterdata antingen som en gråskala eller en RGB-färgbild baserad på ett färgschema eller specifika färger i en fil med färgschema. Ett färgschema kan användas till att representera analyserade data, till exempel en klassificerad bild, eller när en topografisk karta visas (eller en indexfärgskannad bild).<div><br/>Färgscheman innehåller en uppsättning värden som är kopplade till färger som används för att konsekvent visa samma färger för ett raster med ett band. Varje pixelvärde är kopplat till en färg, definierad som en uppsättning RGB-värden. Färgscheman kan stödja alla bitdjup utom flyttal. De stödjer också positiva och negativa värden och kan innehålla färgschemavärden som saknas. När ett dataset med ett färgschema som innehåller saknade värden visas, visas inte pixlarna med de saknade värdena.</div>",
		complexName: "Komplex",
		complexSnip: "Extraherar magnituden från komplexa tal.",
		complexDesc: "Den här funktionen beräknar magnitud från komplexa värden.<div><br/>Den här funktionen används vanligtvis med RADAR-bilder som har en komplex datatyp. Den kan användas i ett mosaikdataset.</div>",
		compositeBandName: "Sammansatta band",
		compositeBandSnip: "Kombinerar flera dataset till ett flerbandsraster.",
		compositeBandDesc: "Funktionen Sammansatta band gör att du kan kombinera raster för att forma en flerbandsbild.",
		conName: "Con",
		conSnip: "Utför en villkorlig If, Then, Else-åtgärd. När en Con-operator används måste det vanligtvis finnas två eller flera funktioner sammankopplade, där en funktion anger villkoren och den andra funktionen är Con-operatorn som använder villkoren och anger vad sanna och falska utdata ska vara.",
		conDesc: "Con-funktionen ställer in pixlarna för utdatarastret baserat på en if\\else-utvärdering av varje indatapixel. Den returnerar pixelvärden från Sant raster om den villkorliga utvärderingen är sann (1) och returnerar pixelvärdena från Falskt raster om den villkorliga utvärderingen är falsk (0). Detta kriterium specificeras av utdata från en logisk matematikfunktion som blir indatarastret.",
		constantName: "Konstant",
		constantSnip: "Skapar ett virtuellt raster med ett enda pixelvärde.",
		constantDesc: "Den här funktionen skapar ett virtuellt raster med ett enda pixelvärde som kan användas i mallar för rasterfunktion och för att behandla ett mosaikdataset.<div><br/>Det konstanta värdet används för varje pixelvärde i rastret.</div>",
		contourName: "Höjdkurva",
		contourSnip: "Skapar höjdkurvelinjer.",
		contourDesc: "Höjdkurvfunktionen genererar höjdkurvelinjer genom att förena punkter med samma höjd från ett rasterhöjddataset. Höjdkurvorna är isolinjer skapade som raster för visualisering. Följande nyckelfunktioner gör den här funktionen kraftfull: höjdkurvor genereras snabbt och dynamiskt på mycket stora dataset, som World Elevation; höjdkurvor kan jämnas ut för att få ett mer tilltalande kartografiskt utseende samtidigt som höjdkurvorna fortsätter att vara korrekta; dynamisk kontroll över höjdkurveintervallet; utdataalternativ omfattar höjdkurvelinjer, indexhöjdkurvor och ifyllda höjdkurvor.<div><br/>Skapandet av ett höjdkurvelager som en rasterprodukt är värdefullt för ett stort antal tillämpningar eftersom höjdkurvorna kan läggas över på en karta och ge information om terrängen utan att skymma underliggande data. De är användbara för tillämpningar som teknik, jordbruk och vattenförsörjning.</div>",
		contrastBrightnessName: "Kontrast och ljusstyrka",
		contrastBrightnessSnip: "Justerar kontrast och ljusstyrka för ett raster.",
		contrastBrightnessDesc: "Funktionen Kontrast och ljusstyrka förbättrar utseendet hos rasterdata genom att modifiera ljusstyrka och kontrast inom bilden. Ljusstyrka gör hela bilden ljusare—till exempel, mörka färger blir ljusare och ljusa färger vitare—medan kontrast justerar skillnaden mellan de mörkaste och de ljusaste färgerna.<div><br/>När den här funktionen används ändras pixelvärdena; därför bör funktionen användas när du vill förbättra utseendet hos data och inte om du ska använda data som en del av en analys som kräver obearbetade pixelvärden. Den här funktionen är användbar när data publiceras som en bildtjänst som kan användas i tillämpningar utan möjlighet att ändra kontrasten och ljusstyrkan hos bilden, eller för att säkerställa att den visas med dina önskade inställningar.</div>",
		convolutionName: "Convolution",
		convolutionSnip: "Använder ett filter för skärpa, oskärpa, gränsidentifiering, utjämning eller toning över ett raster.",
		convolutionDesc: "Convolutionsfunktionen utför filtrering på pixelvärdena i en bild, vilket kan användas för att göra en bild skarpare, suddigare, hitta gränser i bilden eller andra kärnbaserade förbättringar. Filter används för att förbättra rasterbildens kvalitet genom att ta bort oäkta data eller förbättra funktionerna i data. Dessa convolutionsfilter tillämpas på en rörlig, överlappande kärna (fönster eller grannskap), som 3 av 3. Convolutionsfilter fungerar genom att beräkna pixelvärdet baserat på grannarnas vikter.",
		corridorName: "Korridor",
		corridorSnip: "Beräknar summan av de ackumulerade kostnaderna för två raster med ackumulerade indata.",
		corridorDesc: "Korridorfunktionen beräknar summan av de ackumulerade kostnaderna för två kostnadsraster med ackumulerade indata. Även om vilka två raster som helst kan användas för indata, bör det vara oförändrade, ackumulerade kostnadsraster med utdata om resultatet ska bli meningsfullt. Ordningen på de två indatavärdena är irrelevant.",
		cosHName: "CosH",
		cosHSnip: "Beräknar hyperbolisk cosinus för celler i ett raster.",
		cosHDesc: "Funktionen beräknar hyperbolisk cosinus för pixlarna i ett raster.",
		cosName: "Cos",
		cosSnip: "Beräknar cosinus för en cell i ett raster.",
		cosDesc: "Funktionen beräknar cosinus för pixlarna i ett raster.",
		costAllocationName: "Kostnadsallokering",
		costAllocationSnip: "Beräknar för varje cell dess billigaste källa baserat på lägsta ackumulerade kostnad över en kostnadsyta.",
		costAllocationDesc: "Funktionen Kostnadsallokering beräknar för varje cell dess billigaste källa baserat på lägsta ackumulerade kostnad över en kostnadsyta.",
		costBackLinkName: "Bakåtlänk för kostnad",
		costBackLinkSnip: "Definierar grannen som är nästa cell på rutten för lägsta ackumulerade kostnad till den billigaste rutten.",
		costBackLinkDesc: "Funktionen Bakåtlänk för kostnad definierar grannen som är nästa cell på rutten för lägsta ackumulerade kostnad till den billigaste källan.<div><br/>Bakåtlänkrastret innehåller värden från noll till åtta, vilka definierar riktningen eller identifierar nästa granncell (följande cell) längs rutten för lägsta ackumulerade kostnad från en cell till den billigaste källan. Om rutten går igenom den högra grannen, tilldelas cellen värdet 1, 2 för den nedre högra diagonala cellen och fortsätter medurs. Värdet 0 är reserverat för ursprungsceller.</div>",
		costDistanceName: "Kostnad för avstånd",
		costDistanceSnip: "Beräknar den lägsta ackumulerade kostnaden för avståndet för varje cell från eller till den billigaste källan över en kostnadsyta.",
		costDistanceDesc: "Funktionen Kostnad för avstånd beräknar den lägsta ackumulerade kostnaden för avståndet för varje cell från eller till den billigaste källan över en kostnadsyta.",
		costPathName: "Ruttkostnad",
		costPathSnip: "Beräknar den billigaste rutten från en källa till en destination.",
		costPathDesc: "Den globala funktionen Ruttkostnad beräknar den billigaste rutten från en källa till en destination.<div><br/>Den här funktionen producerar ett utdataraster som registrerar den billigaste rutten eller rutter från valda platser till den närmaste ursprungscellen som definierats inom den ackumulerade kostnadsytan, med avseende på kostnad för avstånd.</div>",
		curvatureName: "Kurvatur",
		curvatureSnip: "Beräknar kurvaturen hos en rasteryta, med alternativen profil- och plankurvatur.",
		curvatureDesc: "Kurvaturfunktionen visar formen eller kurvaturen för lutningen. En del av ytan kan vara konkav eller konvex; detta ser du på kurvaturvärdet. Kurvaturen beräknas genom att kalkylera ytans andraderivata.<div><br/>Kurvaturfunktionens utdata kan användas för att beskriva de fysiska egenskaperna hos ett avrinningsområde som ett sätt att förstå erosions- och avrinningsprocesser. Kurvaturvärdet kan användas för att hitta mönster för både jorderosion och vattendistributionen på land. Profilkurvaturen påverkar accelerationen och retardationen av flödet och därmed även erosion och avlagring. Planformskurvaturen påverkar flödets konvergens och divergens.</div>",
		divideName: "Fördela",
		divideSnip: "Dividerar värdena för två raster cell för cell.",
		divideDesc: "Funktionen Fördela dividerar värdena för två raster pixel för pixel.",
		elevationVoidFillName: "Fyllning av tomrum för höjd",
		elevationVoidFillSnip: "Skapar pixlar där det finns hål i höjddata.",
		elevationVoidFillDesc: "Funktionen Fyllning av tomrum för höjd används för att skapa pixlar där det finns hål i upphöjningen.<div><br/>Tomrum uppstår när det inte finns några samlade punkter inom området som representeras av en pixel i det resulterande rastret. Tomrum orsakas ofta av vattenförekomst, urval av geoobjektklass eller uteslutning. Fyllning av tomrum används oftast när en markyta genereras.</div>",
		equalToName: "Lika med",
		equalToSnip: "Utför en relationell lika med-åtgärd på två utdata, cell för cell. Returnerar 1 för celler där det första rastret är lika med det andra rastret och 0 för celler där de inte är lika stora.",
		equalToDesc: "Funktionen utför en lika med-åtgärd på två raster, cell för cell. Den returnerar värdet 1 för pixlar där det första rastret är lika med det andra rastret och värdet 0 för pixlar där de inte är lika stora.",
		eucAllocationName: "Euklidisk fördelning",
		eucAllocationSnip: "Beräknar den närmaste källan för varje cell baserat på de euklidiska avståndet.",
		eucAllocationDesc: "Funktionen Euklidisk riktning beräknar, för varje cell, riktningen, i grader, till närmaste källa.",
		eucDirectionName: "Euklidisk riktning",
		eucDirectionSnip: "Beräknar, för varje cell, riktningen, i grader, till närmaste källa.",
		eucDirectionDesc: "Funktionen Euklidisk fördelning beräknar, för varje cell, riktningen, i grader, till närmaste källa. <div><br/>Riktningen beräknas från varje cellcenter till center för närmaste ursprungscell. Värdeintervallet är från 0 till 360 grader, med 0 reserverat för ursprungsceller. Östlig riktning (höger) är 90 och värdena ökar medurs (180 är söder, 270 är väster och 360 är norr).</div>",
		eucDistanceName: "Euklidiskt avstånd",
		eucDistanceSnip: "Beräknar för varje cell det euklidiska avståndet till närmaste källa.",
		eucDistanceDesc: "Funktionen Euklidiskt avstånd beräknar, för varje cell, det euklidiska avståndet till närmaste källa.",
		exp10Name: "Exp10",
		exp10Snip: "Beräknar bas 10-exponentialfunktionen för cellerna i ett raster.",
		exp10Desc: "Funktionen Exp 10 beräknar bas 10-exponentialfunktionen för pixlarna i ett raster.",
		exp2Name: "Exp2",
		exp2Snip: "Beräknar bas 2-exponentialfunktionen för cellerna i ett raster.",
		exp2Desc: "Den här funktionen beräknar bas 2-exponentialfunktionen för pixlarna i ett raster.",
		expName: "Går ut",
		expSnip: "Beräknar bas e-exponentialfunktionen för cellerna i ett raster.",
		expDesc: "Den här funktionen beräknar bas e-exponentialfunktionen för pixlarna i ett raster.",
		extractBandName: "Extrahera band",
		extractBandSnip: "Anger vilka band du ska arbeta med när du använder flerbandsdataset.",
		extractBandDesc: " Funktionen Extrahera band gör att du kan extrahera ett eller flera band från ett flerbandsrasterdataset, eller ändrar ordningen på banden i datasetet.<div><br/>Du kan använda funktionen Extrahera band före andra funktioner, till exempel Aritmetisk, för att kontrollera vilka band som används som indata i nästa funktion.</div>",
		fillName: "Fyllning",
		fillSnip: "Fyller sänkor i ett ytraster för att ta bort små bristfälligheter i data.",
		fillDesc: "Den globala funktionen Fyllning lokaliserar och fyller ut sänkor och toppar i ett raster för höjdyta för att ta bort små bristfälligheter i data. Funktionen fyller i en iterativ process tills alla sänkor och toppar har fyllts inom den specificerade Z-begränsningen.<div><br/>När en höjdyta skapas med ortokarteringsverktyg eller på annat sätt, finns det ofta små men signifikanta fel i form av sänkor och toppar i data. I fotogrammetri kallas sänkor och toppar ofta för hål och toppar. Eftersom ytdata ofta används vid modellering, till exempel hydrologisk modellering, är det viktigt att korrigera dessa fel med sänkor och toppar på ett sätt som stämmer överens med omgivande data.</div>",
		floatName: "Flytande",
		floatSnip: "Konverterar varje cellvärde i ett raster till en flyttalsrepresentation.",
		floatDesc: "Funktionen Flyttal konverterar varje pixelvärde i ett raster till en flyttalsrepresentation.",
		flowAccumulationName: "Flödesackumulering",
		flowAccumulationSnip: "Skapar ett raster av ackumulerat flöde till varje cell. En viktfaktor kan också tillämpas.",
		flowAccumulationDesc: "Den globala funktionen Flödesackumulering skapar ett raster av ackumulerat flöde till varje pixel, som bestäms genom att vikten av alla pixlar som flyter till varje nedåtlutande pixel ackumuleras. Om inget viktraster tillhandahålls tilldelas varje pixel vikten 1 och värdet för pixlar i utdatarastret är antalet pixlar som flyter till varje pixel.<div><br/>Utdatapixlar med hög flödesackumulering är områden med koncentrerat flöde och kan användas för att identifiera strömkanaler. Utdatapixlar med flödesackumuleringen noll är lokala topografiska toppar och kan användas för att identifiera bergskammar (ryggar).</div>",
		flowDirectionName: "Flödesriktning",
		flowDirectionSnip: "Skapar ett raster av flödesriktning från varje cell till den brantaste grannen i fallande lutning.",
		flowDirectionDesc: "En nyckel till att härleda hydrologiska egenskaper hos en yta är möjligheten att bestämma flödesriktningen från varje pixel i rastret. Rasterfunktionen Flödesriktning tar en yta som indata och skapar ett raster av flödesriktningen från varje pixel till grannen med brantast lutning. Funktionen Flödesriktning stödjer tre flödesmodellerande metoder: D8 (åtta riktningar), Multi-Flow Direction (MFD) och D-Infinity (DINF). ",
		flowDistanceName: "Flödesavstånd",
		flowDistanceSnip: "///Beräknar det minsta horisontella eller vertikala avståndet nedför sluttningar för varje cell till celler i en ström eller flod som de mynnar i.",
		flowDistanceDesc: "För varje pixel beräknar funktionen det minsta horisontella eller vertikala avståndet nedför sluttningar till pixlar på en flod eller ström mot vilken de flyter. Om det finns ytterligare raster för flödesriktning, begränsas riktningarna i fallande lutning till dem som definieras av flödesriktningsrastret för indata. Utdata är ett raster för flödesavstånd.",
		focalName: "Fokal statistik",
		focalSnip: "Beräknar fokal statistik för varje pixel i en bild utifrån definierat fokalt grannskap.",
		focalDesc: "Funktionen Fokal statistik beräknar fokal statistik för varje pixel i en bild utifrån definierat fokalt grannskap.",
		geometricName: "Geometriskt",
		geometricSnip: "Ökar positionsnoggrannheten för ett dataset genom att ta hänsyn till höjd.",
		geometricDesc: "Funktionen Geometriskt producerar en ortorektifierad bild utifrån sensordefinition och en terrängmodell. Den ökar positionsnoggrannheten för ett dataset genom att ta hänsyn till höjd.",
		grayscaleName: "Gråskala",
		grayscaleSnip: "Konverterar en flerbandbild till en bild i gråskala med ett band.",
		grayscaleDesc: "Den här funktionen konverterar en flerbandbild till en bild i gråskala med ett band.<div><br/>Den här funktionen tillämpar specificerade vikter på varje indataband och normaliserar utdatabilden. Vikterna tillämpas ofta för att några band har olika betydelse beroende på applikation. Till exempel innehåller det blå bandet ofta mer brus än andra band.</div>",
		greaterThanEqualName: "Större än eller lika med",
		greaterThanEqualSnip: "Utför en relationell större än/lika med-åtgärd på två indata, cell för cell. Returnerar 1 för celler där det första rastret är större än eller lika med det andra rastret och 0 om det inte är det.",
		greaterThanEqualDesc: "Funktionen utför en relationell större än/lika med-åtgärd på två indata, pixel för pixel. Den returnerar värdet 1 för pixlar där det första rastret är större än eller lika med det andra rastret och värdet 0 för pixlar där det första rastret inte är större än eller lika med det andra rastret.",
		greaterThanName: "Större än",
		greaterThanSnip: "Utför en relationell större än-åtgärd på två indata, cell för cell. Returnerar 1 för celler där det första rastret är större än det andra rastret och 0 för celler där det inte är det.",
		greaterThanDesc: "Funktionen utför en relationell större än-åtgärd på två indata, pixel för pixel. Returnerar värdet 1 för pixlar där det första rastret är större än det andra rastret och värdet 0 för pixlar där det första rastret inte är större än det andra rastret.",
		heatIndexName: "Värmeindex",
		heatIndexSnip: "Kombinerar omgivningens lufttemperatur och relativ luftfuktighet samt returnerar den upplevda temperaturen.",
		heatIndexDesc: "Den här funktionen beräknar upplevd temperatur utifrån omgivningens temperatur och relativa fuktighet. Den upplevda temperaturen beskrivs ofta som hur varmt det känns för den mänskliga kroppen.<div><br/>Detta index kan vara användbart för att beräkna risker med koppling till medicinska problem som muskelkramper, uttorkning och solsting, eller mer allvarligt värmeslag under varma och fuktiga dagar. När den relativa fuktigheten är hög blir det allt svårare för kroppens svett att avdunsta, vilket gör att individen saknar ett effektivt naturligt sätt att kylas ned. Kartor med värmeråd eller värmevarningar är ofta resultatet av att värmeindex omklassificeras till klasser, där sannolikheten för att det ska bli en varning snarare än ett råd ökar ju högre indexvärdet är.</div>",
		hillshadeName: "Terrängskuggning",
		hillshadeSnip: "Skapar en 3D-representation av ytan med hänsyn tagen till solens relativa position för att skugga bilden.",
		hillshadeDesc: "Funktionen Terrängskuggning skapar en 3D-representation av terrrängytan med hänsyn tagen till solens relativa position för att skugga bilden. <div><br/>Terrängskuggning är en teknik för att visualisera terräng som bestäms av en ljuskälla samt lutningen och aspekten för höjdytan. Det är en kvalitativ metod för att visualisera topografi och den ger inga absoluta höjdvärden. </div>",
		intName: "Int",
		intSnip: "Konverterar varje cellvärde i ett raster till ett heltal via trunkering.",
		intDesc: "Funktionen Int konverterar varje pixelvärde i ett raster till ett heltal via trunkering.",
		interpolateIrregularDataName: "Interpolera oregelbundna data",
		interpolateIrregularDataSnip: "Interpolerar från punktmoln eller oregelbundna rutnät.",
		interpolateIrregularDataDesc: "Vissa netCDF- eller HDF-dataset lagrar sin geolokalisering som oregelbundet utspridda pixlar eller punktdata. När dessa dataset läggs till i ett mosaikdataset, tar den interpolerade oregelbundna datafunktionen det oregelbundna rutnätet av data och omsamplar det så att alla pixlar har samma storlek och är kvadratiska.<div><br/>När variabler från netCDF eller HDF läggs till i ett mosaikdataset, verifierar det automatiskt om data är jämnt utspridda. Om de inte är det kan den interpolerade oregelbundna datafunktionen användas för att konvertera oregelbundna data till ett regelbundet rutnätsraster. Du kan ändra interpoleringsmetoden och cellstorleken som används i den interpolerade oregelbundna datarasterfunktionen. För regelbundet utspridda rasterdata används ingen interpolering och data läses som de är.</div>",
		isNullName: "Är noll",
		isNullSnip: "Bestämmer vilka värden från indataraster som är NoData, cell för cell. Returnerar värdet 1 om indatavärdena är NoData och 0 för celler som inte är det.",
		isNullDesc: "Funktionen Är null bestämmer vilka värden från indatarastret som är NoData, pixel för pixel. Den returnerar värdet 1 om indatavärdet är NoData och värdet 0 för pixlar som inte är NoData.",
		kernelDensityName: "Kärndensitet",
		kernelDensitySnip: "Beräknar ett storlek-per-enhet-område från punkt- eller polylinjegeoobjekt med en kärnfunktion för att passa in en jämnt avsmalnande yta till varje punkt eller polylinje.",
		kernelDensityDesc: "Den här funktionen beräknar ett storlek-per-enhet-område från punkt- eller polylinjegeoobjekt med en kärnfunktion för att passa in en jämnt avsmalnande yta till varje punkt eller polylinje.",
		keyMetadataName: "Viktiga metadata",
		keyMetadataSnip: "Åsidosätter eller infogar viktiga metadata för ett raster i en funktionskedja.",
		keyMetadataDesc: "Den här funktionen gör att du kan infoga eller åsidosätta viktiga metadata för ett raster.<div><br/>Informationen i viktiga metadata används för att hjälpa applikationen med bearbetning och rendering, inklusive att tillhandahålla användbar information som sensornamn, bandnamn eller molntäcke kopplat till bilderna.</div>",
		shortestPathName: "Billigaste rutt",
		shortestPathSnip: "Utför en kostnadsavståndsanalys med käll- och målindata som sedan används för att fastställa den billigaste rutten från en källa till ett mål.",
		shortestPathDesc: "Funktionen Billigaste rutten beräknar den billigaste rutten från en källa till en destination. Den lägsta ackumulerade kostnaden beräknas för avståndet för varje pixel över en kostnadsyta till närmaste källa. Detta producerar ett utdataraster som registrerar den billigaste rutten, eller rutterna, från valda platser till den närmaste ursprungscellen som definierats inom den ackumulerade kostnadsytan, med avseende på kostnad för avstånd.<div><br/>Den billigaste rutten tilldelas alltid ett värde när den påträffas under skanningsprocessen. Den avslutande pixeln på källrastret för en kostnadsrutt får värdet 1. Den första rutten får värdet 3, nästa 4 o.s.v. När flera rutter sammanfogas och följer samma rutt tillbaka till en källa, tilldelas segmentet där de två rutterna reser tillsammans värdet 2. Den sammanfogade delen av rutten kan inte tilldelas värdet för en av rutterna, eftersom den sammanfogade delen tillhör båda rutterna.</div>",
		lessThanEqualName: "Mindre än eller lika med",
		lessThanEqualSnip: "Utför en relationell mindre än/lika med-åtgärd på två indatavärden, cell för cell. Returnerar 1 för celler där det första rastret är mindre än eller lika med det andra rastret och 0 om det inte är det.",
		lessThanEqualDesc: "Funktionen utför en relationell mindre än/lika med-åtgärd på två indata, pixel för pixel. Den returnerar värdet 1 för pixlar där det första rastret är mindre än eller lika med det andra rastret och värdet 0 för pixlar där det inte är mindre än eller lika med det andra rastret.",
		lessThanName: "Mindre än",
		lessThanSnip: "Utför en relationell mindre än-åtgärd på två indatavärden, cell för cell. Returnerar 1 för celler där det första rastret är mindre än det andra rastret och 0 om det inte är det.",
		lessThanDesc: "Funktionen utför en relationell mindre än-åtgärd på två indata, pixel för pixel. Den returnerar värdet 1 för pixlar där det första rastret är mindre än det andra rastret och värdet 0 om det inte är mindre än det andra rastret.",
		lnName: "Ln",
		lnSnip: "Beräknar den naturliga logaritmen (bas e) för cellerna i ett raster.",
		lnDesc: "Funktionen Ln beräknar den naturliga logaritmen (bas e) för varje pixel i ett raster.",
		log10Name: "Log10",
		log10Snip: "Beräknar bas 10-logaritmen för cellerna i ett raster.",
		log10Desc: "Funktionen Log10 beräknar bas 10-logaritmen för varje pixel i ett raster.",
		log2Name: "Log2",
		log2Snip: "Beräknar bas 2-logaritmen för cellerna i ett raster.",
		log2Desc: "Funktionen Log2 beräknar bas 2-logaritmen för varje pixel i ett raster.",
		lookupName: "Sök",
		lookupSnip: "Skapar ett nytt raster genom att söka värden som finns i ett annat fält i indatarastrets tabell.",
		lookupDesc: "Funktionen skapar ett nytt raster genom att söka värden som finns i ett annat fält i indatarastrets tabell.",
		mlClassifyName: "ML-klassificera",
		mlClassifySnip: "Klassificerar bilder per pixel. Blandade pixlar tilldelas geoobjektet med det högsta procentvärdet i den pixeln.",
		mlClassifyDesc: "Funktionen ML-klassificera gör att du kan utföra en övervakad klassificering genom att använda algoritmen klassificering med maximal sannolikhet på ett rasterdataset eller mosaikdataset. Den här funktionen kräver en klassificeringssignaturfil.",
		maskName: "Maska",
		maskSnip: "Anger värden du inte vill visa.",
		maskDesc: "Den här rasterfunktionen anger värden som du inte vill visa i ditt raster. När du använder funktionen Maskning anger du en eller flera NoData-värden eller ett intervall med giltiga pixelvärden. ",
		minusName: "Minus",
		minusSnip: "Subtraherar värdet för det andra indatarastret från värdet för det första indatarastret på cell-för-cell-bas.",
		minusDesc: "Minusfunktionen subtraherar värdet för det andra indatarastret från värdet för det första indatarastret pixel för pixel.",
		modName: "Mod",
		modSnip: "Hittar resten (modulo) av det första rastret när det divideras med det andra rastret på cell-för-cell-bas.",
		modDesc: "Funktionen Mod hittar resten (modulo) av det första rastret när det divideras med det andra rastret pixel för pixel. Ordningen på indata är viktig och påverkar utdataresultatet.",
		mosaicRastersName: "Mosaikraster",
		mosaicRastersSnip: "Sammanfogar en uppsättning rasterdataset för att skapa ett dataset.",
		mosaicRastersDesc: "Funktionen Mosaikraster skapar en mosaikbild av flera bilder. När det finns en överlappning mellan bilderna finns det flera metoder som du kan välja mellan för att avgöra vilka bilder som visas.",
		ndviColorizedName: "NDVI-färglagd",
		ndviColorizedSnip: "Skapar ett flerbandsdataset som visar vegetationens frodighet baserat på skillnaden mellan de röda och nära infraröda banden.",
		ndviColorizedDesc: "Funktionen NDVI-färglagd tillämpar NDVI-funktionen på indatabilden och använder sedan en färgkarta eller en färgramp för att visa resultatet.",
		ndviName: "NDVI",
		ndviSnip: "Beräknar Normalized Difference Vegetation Index (NDVI).",
		ndviDesc: "NDVI-funktionen skapar ett dataset med ett band som visar vegetationens frodighet baserat på skillnaden mellan de röda och infraröttnära banden.<div><br/>NDVI är ett standardiserat index som låter dig generera en bild som visar grönhet, som också kallas relativ biomassa. Det här indexet drar nytta av kontrasten mellan egenskaperna hos två band i ett multispektralt rasterdataset: klorofyllpigmentabsorptionen i det röda bandet och den höga reflektiviteten hos växtmaterial i det nära infraröda (NIR) bandet. Extremt låga eller negativa NDVI-värden representerar områden utan växtlighet, t.ex. moln, vatten eller snö. Mycket låga värden representerar områden med liten eller ingen växtlighet, som betong, klippor eller naken jord. Medelhöga värden representerar områden med buskar och gräsmarker. Höga värden representerar skogsområden och grönskande växtlighet.</div>",
		negateName: "Negera",
		negateSnip: "Ändrar tecknet (multiplicerar med -1) för cellvärdena i indatarastret på cell-för-cell-bas.",
		negateDesc: "Funktionen Negera ändrar tecknet (multiplicerar med -1) för pixelvärdena i indatarastret på en pixel. ",
		nibbleName: "Nagga",
		nibbleSnip: "Ersätter celler i ett raster enligt en mask med värdena för de närmaste grannarna.",
		nibbleDesc: "Den globala funktionen Nagga möjliggör att markerade områden i ett raster kan tilldelas samma värde som deras närmaste granne. Detta är praktiskt för att redigera områden i ett raster där data kan vara felaktiga.",
		notEqualName: "Inte lika med",
		notEqualSnip: "Utför en relationell inte lika med-åtgärd på två indatavärden cell för cell. Returnerar 1 för celler där det första rastret inte är lika med det andra rastret och 0 om de är lika.",
		notEqualDesc: "Funktionen utför en relationell inte lika med-åtgärd på två indatavärden pixel för pixel. Den returnerar ett värde på 1 för pixlar där det första rastret inte är lika med det andra rastret och ett värde på 0 för pixlar där det är lika med det andra rastret.",
		pansharpeningName: "Panoreringsskärpning",
		pansharpeningSnip: "Förbättrar den geografiska upplösningen i en bild med flera band på konstgjord väg genom att smälta samman den med en pankromatisk bild med högre upplösning.",
		pansharpeningDesc: "Funktionen Panoreringsskärpning använder en pankromatisk bild med högre upplösning eller ett rasterband för att smälta samman den med ett lågupplöst rasterdataset med flera band i syfte att öka flerbandsbildens geografiska upplösning.<div><br/>Syftet med panoreringsskärpning är att skapa en visuell bild med högre kvalitet. Eftersom teknikerna ändrar flerbandsbildernas radiometri och spektrala egenskaper måste panoreringsskärpta bilder användas med försiktighet vid fjärranalys.</div>",
		pathAllocationName: "Ruttavståndsallokering",
		pathAllocationSnip: "Beräknar källan med lägst kostnad för varje cell baserat på den lägsta ackumulerade kostnaden över en kostnadsyta, samtidigt som hänsyn tas till ytavståndet samt horisontella och vertikala kostnadsfaktorer.",
		pathAllocationDesc: "Ruttavståndsallokeringen beräknar den närmaste källan för varje cell baserat på den lägsta ackumulerade kostnaden över en kostnadsyta, samtidigt som hänsyn tas till ytavståndet samt horisontella och vertikala kostnadsfaktorer.",
		pathBackLinkName: "Bakåtlänk för ruttavstånd",
		pathBackLinkSnip: "Definierar grannen som är nästa cell på rutten för lägsta ackumulerad kostnad till den billigaste källan, samtidigt som hänsyn tas till ytavståndet samt horisontella och vertikala kostnadsfaktorer.",
		pathBackLinkDesc: "Bakåtlänk för ruttavstånd identifierar inriktningen för grannen som är nästa cell på rutten för lägsta ackumulerad kostnad till den närmaste källan, samtidigt som hänsyn tas till ytavståndet samt horisontella och vertikala kostnadsfaktorer.",
		pathDistanceName: "Ruttavstånd",
		pathDistanceSnip: "Beräknar för varje cell lägsta ackumulerad kostnad för avståndet från eller till den billigaste källan, samtidigt som hänsyn tas till ytavståndet samt horisontella och vertikala kostnadsfaktorer.",
		pathDistanceDesc: "Funktionen Ruttavstånd beräknar för varje cell lägsta ackumulerad kostnad för avståndet till den närmaste källan, samtidigt som hänsyn tas till ytavståndet samt horisontella och vertikala kostnadsfaktorer.",
		plusName: "Plus",
		plusSnip: "Adderar (summerar) värdena för två raster cell för cell.",
		plusDesc: "Funktionen Plus adderar (summerar) värdena för två raster pixel för pixel.",
		powerName: "Potens",
		powerSnip: "Upphöjer cellvärdena i ett raster till värden från ett annat raster.",
		powerDesc: "Funktionen Potens upphöjer pixelvärdena i ett raster till värden från ett annat raster.",
		radarCalibrationName: "Radarkalibrering",
		radarCalibrationSnip: "Konverterar RADARSAT-2-bakåtstrålning.",
		radarCalibrationDesc: "Den här funktionen kan användas till att kalibrera RADARSAT-2-bilder i ett mosaikdataset eller som en rasterprodukt. Kalibreringen utförs på radarbilder så att pixelvärdena är en verklig representation av radarbakåtstrålningen.",
		rasterInfoName: "RasterInfo",
		rasterInfoSnip: "Ändrar egenskaper för rastret, t.ex. bitdjup, NoData-värde, cellstorlek o.s.v.",
		rasterInfoDesc: "RasterInfo öppnar en dialogruta med egenskaper för rasterdataset, t.ex. antalet kolumner och rader, antalet band, pixeltypen, utbredningen och den geografiska referensen. Du kan redigera dessa egenskaper genom att välja ett rasterdataset som ska användas som mall. ",
		rasterizeAttributesName: "Rastrera attribut",
		rasterizeAttributesSnip: "Berikar ett raster genom ytterligare band som härrör från värden för angivna attribut från en extern tabell eller en geoobjekttjänst.",
		rasterizeAttributesDesc: "Funktionen Rastrera attribut berikar ett raster genom att lägga till band som härrör från värden för angivna attribut från en extern tabell eller en geoobjekttjänst. Om du vill kan du ange ett zonraster och det tillhörande zon-ID-attributet för att aktivera regionbaserad sökning.",
		rasterizeFeatureClassName: "Rastrera geoobjekt",
		rasterizeFeatureClassSnip: "Konverterar geoobjekt till raster.",
		rasterizeFeatureClassDesc: "Den här funktionen konverterar polygon-, polylinje- och punktgeoobjektklassdata till ett rasterlager.<div><br/>Geoobjekt tilldelas pixelvärden baserat på geoobjektens OBJECTID (standard). Pixelvärdena kan också baseras på ett användardefinierat värdefält i indatageoobjektets attributtabell.</div>",
		recastName: "Gör om",
		recastSnip: "Ändrar parametrarna hos en funktionskedja i ett mosaikdataset eller en bildtjänst. Det används ofta med LAS-dataset så att du inte behöver skapa ett separat mosaikdataset för olika representationer av terräng.",
		recastDesc: "Funktionen Gör om används för att dynamiskt modifiera den funktionsparameter som användas i ett mosaikdataset eller en bildtjänst utan att fysiskt bevara ändringarna.",
		regionGroupName: "Regiongrupp",
		regionGroupSnip: "För varje cell i utdata registreras identiteten för den anslutna region som cellen tillhör. Ett unikt nummer tilldelas varje region.",
		regionGroupDesc: "Den globala funktionen Regiongrupp registrerar för varje cell i utdata identiteten för den anslutna region som den cellen tillhör. Ett unikt nummer tilldelas varje region.<div><br/>Den första regionen som skannas erhåller värdet ett, den andra två och så vidare tills alla regioner har tilldelats ett värde. Skanningen sker från vänster till höger, uppifrån och nedåt. De värden som tilldelas till utdatazonerna baseras på när de påträffas i skanningsprocessen.</div>",
		regionGrowName: "Få regioner att växa",
		regionGrowSnip: "Utveckla regioner från seedpunkter.",
		regionGrowDesc: "Funktionen Få regioner att växa bildar grupper av närliggande pixlar efter angiven radie från seedpunkten. Gruppen av pixlar eller objekt tilldelas ett angivet fyllningsvärde.",
		remapName: "Ommappning",
		remapSnip: "Ändrar pixelvärden genom att tilldela nya värden till intervall av pixelvärden eller använda en extern tabell.",
		remapDesc: "Med funktionen Ommappning kan du ändra eller klassificera om pixelvärdena för rasterdata. Detta kan göras antingen genom att ange ett intervall med pixelvärden som ska mappas till ett utdatapixelvärde eller genom att använda en tabell till att mappa pixelvärdena till ett utdatapixelvärde.",
		reprojectName: "Projicera om",
		reprojectSnip: "Ändrar projektionen för ett rasterdataset, mosaikdataset eller rasterobjekt i ett mosaikdataset. Den kan också omsampla data till en ny cellstorlek och definiera ett ursprung.",
		reprojectDesc: "Funktionen Projicera om ändrar projektionen för ett rasterdataset, mosaikdataset eller rasterobjekt i ett mosaikdataset. Den kan också omsampla data till en ny cellstorlek och definiera ett ursprung.<div><br/>Funktionen Projicera om kan användas när en cache skapas från ett raster eller ett mosaikdataset som inte finns i den nödvändiga projektionen. När t.ex. en cachad bildtjänst skapas som kan integreras med andra cachade tjänster via applikationer är det viktigt att de alla är i samma projektion. Detta är ofta en Web Mercator-projektion. Eftersom mosaikdataset inte kan projiceras om kan du göra en av två saker—antingen skapa ett refererat mosaikdataset från ditt mosaikdataset i den projektion som behövs eller lägga till funktionen Projicera om i mosaikdatasetets funktionskedja. Ett annat exempel använder den här funktionen på rasterobjektet i ett mosaikdataset. När du använder funktionen Cachelagrat raster kan du infoga funktionen Projicera om så att cachen skapas i den nya projektionen. Rasterobjekt i ett mosaikdataset kan cachelagras när bearbetningen är intensiv och du försöker publicera en bildtjänst som är snabb utan att cachelagra hela bildtjänsten.</div>",
		resampleName: "Omsampla",
		resampleSnip: "Ändrar cellstorleken för ett raster.",
		resampleDesc: "Funktionen Omsampla ändrar cellstorleken, omsamplingstypen eller både och.<div><br/>Funktionen Omsampla ska enbart användas med specifika beräkningskrav, t.ex. när du beräknar vinden eller aktuell magnitud-riktning som kräver omsampling från källupplösningen.</div>",
		roundDownName: "Avrunda nedåt",
		roundDownSnip: "Returnerar nästa lägre heltalsvärde, endast representerat som flyttal, för varje cell i ett raster.",
		roundDownDesc: "Funktionen Avrunda nedåt returnerar nästa lägre heltalsvärde som ett flyttalsvärde för varje pixel i ett raster.",
		roundUpName: "Avrunda uppåt",
		roundUpSnip: "Returnerar nästa högre heltalsvärde, endast representerat som flyttal, för varje cell i ett raster.",
		roundUpDesc: "Funktionen Avrunda uppåt returnerar nästa högre heltalsvärde som ett flyttalsvärde för varje pixel i ett raster.",
		segmentMeanShiftName: "Flyttning av segmentmedelvärde",
		segmentMeanShiftSnip: "Grupperar angränsande pixlar med liknande spektrala egenskaper tillsammans till segment.",
		segmentMeanShiftDesc: "Den här funktionen identifierar objekt, geoobjekt eller segment i dina bilder genom att bilda grupper av intilliggande pixlar med liknande spektrala och geografiska egenskaper. Du kan kontrollera mängden geografisk och spektral utjämning för att få fram intressanta geoobjekt.",
		s1RadiometricCalibrationName: "Radiometrisk kalibrering för Sentinel-1",
		s1RadiometricCalibrationSnip: "Utför olika typer av radiometrisk kalibrering av Sentinel-1-data.",
		s1RadiometricCalibrationDesc: "Denna rasterfunktion utför tre olika kalibreringar för Sentinel-1-dataset, inklusive beta-noll och gamma, och ger det kalibrerade datasetet som utdata. Målet med SAR-kalibrering är att tillhandahålla bilder i vilka pixelvärdena direkt kan relateras till scenens radarbakåtstrålning. Okalibrerade SAR-bilder räcker till för kvalitativ användning, men för kvantitativ användning av SAR-data är kalibrerade SAR-bilder nödvändiga.<div><br/>Typisk SAR-databearbetning, som producerar nivå 1-bilder, saknar radiometriska korrigeringar och betydande radiometrisk snedvridning finns kvar. Det är därför nödvändigt att tillämpa radiometrisk korrigering på SAR-bilder så att bildernas pixelvärden verkligen representerar den reflekterande ytans radarbakåtstrålning. Radiometrisk korrigering är också nödvändig för att kunna jämföra SAR-bilder som inhämtats med olika sensorer, eller som inhämtats av samma sensor vid olika tidpunkter eller i olika lägen eller som bearbetats av olika processorer.</div>",
		s1ThermalNoiseRemovalName: "Borttagning av termiskt brus från Sentinel-1",
		s1ThermalNoiseRemovalSnip: "Tar bort termiskt brus från Sentinel-1-data.",
		s1ThermalNoiseRemovalDesc: "Termisk bruskorrigering kan tillämpas på Sentinel-1 Nivå-1 SLC-produkter (Single Look Complex) liksom Nivå-1 GRD-produkter (Ground Range Detection) som inte redan har korrigerats. Operatören kan också ta bort den här korrigeringen baserat på produkttexterna för att återintroducera den brussignal som togs bort för att ta fram den ursprungliga produkten. Produkttexter uppdateras därmed för att möjliggöra återtillämpning av korrigeringen. ",
		setNullName: "Sätt noll",
		setNullSnip: "Sätt noll anger identifierade cellplatser till NoData baserat på angivna kriterier. Den returnerar NoData om en villkorlig utvärdering är sann och returnerar det värde som angetts i ett annat raster om den är falsk.",
		setNullDesc: "Funktionen Sätt noll anger de identifierade pixlarna till NoData, baserat på de specifika kriterierna. Den returnerar NoData om en villkorlig utvärdering är sann (1) och returnerar det värde som angetts i Falskt raster om en villkorlig utvärdering är falsk (0). Detta kriterium specificeras av utdata från en logisk matematikfunktion som blir indatarastret.",
		shadedReliefName: "Skuggad relief",
		shadedReliefSnip: "Skapar en flerbands, färgkodad 3D-representation av ytan med hänsyn tagen till solens relativa position för att skugga bilden.",
		shadedReliefDesc: "Funktionen Skuggad relief skapar en 3D-representation i färg av terrängen. Den skapas genom att sammanfoga bilderna från metoderna höjdkodning och terrängskuggning. Funktionen anger solens position med höjd- och azimutegenskaper.<div><br/></div>",
		sinHName: "SinH",
		sinHSnip: "Beräknar hyperbolisk sinus för celler i ett raster.",
		sinHDesc: "Funktionen beräknar hyperbolisk sinus för pixlarna i ett raster.",
		sinName: "Sin",
		sinSnip: "Beräknar sinus för celler i ett raster.",
		sinDesc: "Funktionen beräknar sinus för pixlarna i ett raster.",
		slopeName: "Lutning",
		slopeSnip: "Beräknar ändringsfrekvensen från ett pixelvärde till dess grannar.",
		slopeDesc: "Denna rasterfunktion beräknar lutning, som är takten på höjdförändringen för varje cell i den digitala höjdmodellen (DEM). Det är den första härledningen från en DEM.<div><br/>Denna funktion använder en accelererad atan()-funktion. Den är sex gånger snabbare och approximationsfelet är alltid mindre än 0,3 grader.</div>",
		speckleName: "Fläck",
		speckleSnip: "Tillhandahåller filter för att reducera brus från dataset tagna med syntetisk aperturradar.",
		speckleDesc: "Fläck är högfrekvensbrus på radardata. Bilder som är genererade med syntetiska aperturradarsystem (SAR) är mycket utsatta för fläckeffekter på grund av bearbetning av spridda signaler och interferens från elektromagnetiska vågor som spridits från ytor eller föremål. Denna Fläckfunktion filtrerar fläckade radardataset och jämnar ut brus samtidigt som kanter eller skarpa geoobjekt bibehålls i bilden.",
		spectralConversionName: "Spektral konvertering",
		spectralConversionSnip: "Tillämpar en matris på en flerbandsbild.",
		spectralConversionDesc: "Funktionen spektral konvertering tillämpar en matris på en flerbandsbild, vilket påverkar färgvärden i utdata.<div><br/>Vissa sensorer samlar inte in blå band på grund av ett lågt signal-till-brus-förhållande. Detta kan t.ex. användas till att konvertera en infraröd bild i falska färger till en bild med pseudonaturliga färger.</div>",
		squareRootName: "Kvadratrot",
		squareRootSnip: "Beräknar kvadratroten av cellvärdena i ett raster.",
		squareRootDesc: "Funktionen Kvadratrot beräknar kvadratroten av pixelvärdena i ett raster.",
		squareName: "Kvadrat",
		squareSnip: "Beräknar kvadraten av cellvärdena i ett raster.",
		squareDesc: "Kvadrat beräknar kvadraten på pixelvärdena i ett raster.",
		statisticsHistogramName: "Statistik och histogram",
		statisticsHistogramSnip: "Definiera eller koppla statistik och histogram.",
		statisticsHistogramDesc: "Funktionen Statistik och histogram används för att definiera statistik och histogram för ett raster. Du kan infoga denna funktion i slutet av funktionskedjan för att beskriva statistik och histogram för en mall för rasterfunktion (RFT). Detta kan vara nödvändigt för att styra standardvisningen av bearbetningsresultatet, särskilt när en funktionskedja definieras som innehåller många funktioner.<div><br/>Du kan definiera statistik genom att skriva värdena eller importera dem från ett rasterdataset eller en XML-fil. Histogram kan endast definieras genom att importera en fil.</div>",
		statisticsName: "Statistik",
		statisticsSnip: "Beräknar fokal statistik för varje pixel i en bild utifrån definierat fokalt grannskap.",
		statisticsDesc: "Funktionen Statistik beräknar fokal statistik för varje pixel i en bild utifrån ett definierat fokalt grannskap.<div><br/>Statistikfunktionen kan användas till att fylla i saknade linjer i en bild. Saknade linjer orsakas ofta av problem i sensorn då data inte samlas in. Detta har inträffat med sensorer som Landsat 7:s Enhanced Thematic Mapper Plus (ETM+). Dessa saknade data skapar problem för analysen och även när man tittar på bilderna. Det finns inte mycket som kan göras när bilderna används för analys, men om det finns en överlappande bild kan den användas istället för det innehåll som saknas. Detta kan också göras om bilderna används för visualisering. Det finns emellertid inte alltid en extra bild för att fylla i saknat innehåll, så det måste härledas från befintliga data.</div>",
		streamLinkName: "Strömningslänk",
		streamLinkSnip: "Tilldelar unika värden till sektioner av ett linjärt rasternät mellan korsningar.",
		streamLinkDesc: "Den globala funktionen Strömningslänk tilldelar unika värden till sektioner av ett linjärt rasternät mellan korsningar.<div><br/>Länkar är de sektioner av ett vattendrag som går mellan två flodmöten i rad, ett flodmöte och utloppet eller ett flodmöte och vattendelaren. Inom hydrologin kallas dessa segment av vattendrag för sträcka. Ett flodmöte är relaterat till hällpunkt och hjälper till att avgränsa ett avrinningsområde eller gränsen för ett delavrinngsområde.</div>",
		stretchName: "Sträck",
		stretchSnip: "Förstärker en bild genom att justera intervallet för visade värden. Det ändrar inte de underliggande pixelvärdena. Om en pixel har ett värde utanför det angivna intervallet visas den som antingen det minimala eller maximala värdet.",
		stretchDesc: "Funktionen Sträck förbättrar en bild genom att ändra dess egenskaper som exempelvis ljusstyrka, kontrast och gamma genom att använda flera sträckningstyper. Denna funktion använder statistiken från rastren i mosaikdatasetet. Om du använder denna funktion måste du därför se till att statistiken har beräknats.<div><br/>Sträcktypen definierar en histogramsträckning som kommer att tillämpas på rastren för att förbättra deras utseende. Sträckning förbättrar utseendet för data genom att sprida pixelvärdena längs ett histogram från min- och maxvärdena definierat av deras bitdjup. </div>",
		swathName: "Stråk",
		swathSnip: "Interpolerar från oregelbundna rutnät eller stråkdata.",
		swathDesc: "Vissa netCDF- eller HDF-dataset lagrar sin geolokalisering som vektorer med oregelbundna avstånd. När dessa dataset läggs till i ett mosaikdataset tar stråkfunktionen oregelbundna rutnätdata och omsamplar dem så att varje pixel får en enhetlig storlek och blir fyrkantig.<div><br/>När variabler från netCDF eller HDF läggs till i ett mosaikdataset, verifierar det automatiskt om data är jämnt utspridda. Om inte tillämpas stråkfunktionen automatiskt så att det oregelbundna rastret konverteras till punkter och sedan till ett regelbundet rutnätsraster. Du kan ändra den interpoleringsmetod och den cellstorlek som används i stråkrasterfunktionen. För rasterdata med regelbundna avstånd tillämpas ingen interpolering, data läses i befintligt skick.</div>",
		tanHName: "TanH",
		tanHSnip: "Beräknar hyperbolisk tangent för celler i ett raster.",
		tanHDesc: "Funktionen beräknar hyperbolisk tangent för pixlarna i ett raster.",
		tanName: "Tan",
		tanSnip: "Beräknar tangent för celler i ett raster.",
		tanDesc: "Funktionen beräknar tangent för pixlarna i ett raster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Beräknar nivåer för vegetation, fuktighet och ljusstyrka. Tekniken förlitar sig på koefficienter som måste beräknas specifikt för en sensor.",
		tasseledCapDesc: "Tasseled Cap-transformationen (Kauth-Thomas) är konstruerad för att analysera och mappa växtlighetsfenomen och stadsbyggnadsförändringar som upptäckts av olika satellitsensorsystem. Den kallas Tasseled Cap-transformation på grund av formen på den grafiska distributionen av data. Transformationen gav en förklaring till de mönster som fanns i Landsat MSS-data för jordbruksfält som en funktion av grödans livscykel. Kortfattat sker det en nettoökning i den nära infraröda och en minskning i den röda reflektionen baserat på färgen på jorden.<div><br/>Användningsområdet för den här transformationen har vidgats från övervakning av grödor till skogsbruk, industriell växthantering, mappning och hantering av ekosystem, inventering och övervakning för koldioxidlagring och utsläppsrätter, stadsbyggnad och annat. Den har också utökats från att stödja Landsat MSS till att inkludera andra populära satellitsystem som Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, WorldView-2 och RapidEye.</div>",
		timesName: "Gånger",
		timesSnip: "Multiplicerar värdena för två raster cell för cell.",
		timesDesc: "Funktionen Gånger multiplicerar värdena för två raster pixel för pixel.",
		transposeBitsName: "Gör om bitar",
		transposeBitsSnip: "Packar upp bitarna hos indatapixeln och mappar dem till angivna bitar i utdatapixeln. Funktionens syfte är att modifiera bitar från ett par indata, t.ex. Landsat 8-kvalitetsbandsprodukter.",
		transposeBitsDesc: "Funktionen Gör om bitar packar upp bitarna hos indatapixeln och mappar dem till angivna bitar i utdatapixeln. Funktionens syfte är att modifiera bitar från ett par indata, t.ex. Landsat 8-kvalitetsbandsprodukter.",
		unitConversionName: "Enhetskonvertering",
		unitConversionSnip: "Konverterar värden från en mätenhet till en annan.",
		unitConversionDesc: "Denna funktion konverterar pixlar från en enhet till en annan. Den har stöd för konvertering av sträcka, hastighet och temperatur.",
		vectorFieldName: "Vektorfält",
		vectorFieldSnip: "Visar dataset med både magnitud (u) och riktning (v) som pilar, där magnituden visas av pilens storlek och riktningen av dess vinkel.",
		vectorFieldDesc: "Funktionen Vektorfält används för att sätta samman och konvertera två raster till ett raster med två band som är antingen av datatypen magnitud-riktning eller datatypen U-V.<div><br/>U-värdet kallas ibland zonhastighet och V-värdet kallas ibland meridional hastighet.</div>",
		viewshed2Name: "Synfält",
		viewshed2Snip: "Bestämmer vilka platser på rasterytan som är synliga för en uppsättning observatörsgeoobjekt, med geodetiska metoder.",
		viewshed2Desc: "Funktionen Synfält bestämmer vilka platser på rasterytan som är synliga för en uppsättning observatörsgeoobjekt, med geodetiska metoder.<div><br/>Synligheten för varje pixelmittpunkt fastställs med ett siktlinjetest mellan målet och varje observatör. Om en observatör kan se målet i pixelns mittpunkt anses pixeln vara synlig. Detta verktyg tar alltid hänsyn till jordens kurvatur när synligheten fastställs.</div>",
		watershedName: "Avrinningsområde",
		watershedSnip: "Fastställer ackumuleringsområdet ovanför en uppsättning celler i ett raster.",
		watershedDesc: "Den globala funktionen Avrinningsområde fastställer ackumuleringsområdet ovanför en uppsättning pixlar i ett raster. Avrinningsområden avgränsas av ett flödesriktningsraster som identifierar flödesriktningen från varje pixel.",
		weightedOverlayName: "Viktad överlagring",
		weightedOverlaySnip: "Överlagrar flera raster med en gemensam mätskala och viktar vart och ett efter dess betydelse.",
		weightedOverlayDesc: "Med denna funktion kan du överlagra flera raster med en gemensam mätskala och vikta vart och ett efter dess betydelse.",
		weightedSumName: "Viktad summa",
		weightedSumSnip: "Viktar och lägger till ett antal raster på cell efter cell.",
		weightedSumDesc: "Funktionen Viktad summa låter dig överlagra flera raster och multiplicera vart och ett med deras givna vikt och summera dem.",
		windchillName: "Vindavkylning",
		windchillSnip: "Kombinerar omgivningslufttemperatur och vindhastighet och beräknar vindavkylningen.",
		windchillDesc: "Funktionen Vindavkylning är användbar för att identifiera farliga vinterförhållanden som, beroende på exponeringstiden, kan leda till förfrysning eller till och med hypotermi. Vindavkylning är ett sätt att mäta hur kall en person känner sig när hänsyn tas till vinden vid redan låga temperaturer. Ju högre vindhastighet desto snabbare förlorar kroppen värme och desto kallare känner sig personen.",
		zonalRemapName: "Zonbaserad omkartering",
		zonalRemapSnip: "Kartera om pixlar i ett raster baserat på zoner definierade i ett annat raster och en zonberoende värdemappning som definieras i en tabell.",
		zonalRemapDesc: "Med denna funktion kan du kartera om pixlar i ett raster baserat på zoner definierade i ett annat raster och en zonberoende värdemappning som definieras i en tabell.",
		zonalStatisticsName: "Zonbaserad statistik",
		zonalStatisticsSnip: "Beräknar statistik för värden från ett raster inom zonerna för ett annat dataset.",
		zonalStatisticsDesc: "Funktionen beräknar statistik för värden från ett raster inom zonerna för ett annat dataset. En zon definieras som alla områden i indata som har samma värde. Områdena behöver inte vara sammanhängande. När zon- och värdeindata båda är raster med samma upplösning kommer de att användas direkt. Om upplösningarna är olika tillämpas en intern omsampling som ser till att upplösningarna matchar innan zonåtgärden genomförs.",
		flowLengthName: "Flödeslängd",
		flowLengthSnip: "Beräknar avståndet uppströms eller nedströms eller det viktade avståndet längs varje cells flödesväg.",
		flowLengthDesc: "Det här är en global rasterfunktion. Funktionen skapar ett rasterlager med avstånd uppströms eller nedströms, eller ett viktat avstånd, längs flödesvägen för varje cell.<div><br/>Ett primärt användningsområde för funktionen Flödeslängd är att beräkna längden på den längsta flödesvägen inom en viss given damm. Den här åtgärden används ofta för att beräkna koncentrationstiden för en damm. Detta görs med alternativet Uppströms. Funktionen kan också användas för att skapa diagram med avstånd-yta för hypotetiskt regn och avrinning med viktrastret som impedans för rörelser i lutning.</div>",
		streamOrderName: "Strömordning",
		streamOrderSnip: "Tilldelar ett numeriskt värde till segment i ett raster som representerar grenar i ett linjärt nätverk",
		streamOrderDesc: "Det här är en global rasterfunktion. Den här funktionen skapar ett rasterlager som tilldelar ett numeriskt värde till segment i ett raster som representerar grenar i ett linjärt nätverk.<div><br/>Utdata för funktionen Strömordning blir av högre kvalitet om indataströmrasterlagret och indataflödesriktningsrasterlagret härleds från samma yta. Om strömrastret härleds från ett rasteriserat strömdataset, kanske inte utdata går att använda eftersom riktningen cell för cell inte motsvarar platserna för strömcellerna. Resultatet av funktionen Flödesackumulering kan användas för att skapa ett rasterströmnätverk genom att tillämpa ett tröskelvärde som väljer ut celler med högt ackumulerat flöde. Celler som till exempel har fler än 100 celler som flödar till dem används för att definiera strömnätverket. Använd funktionen Con eller Sätt noll för att skapa ett strömnätverksraster där flödesackumuleringsvärden på 100 eller större går till ett, och resten placeras i bakgrunden (NoData). Det resulterande strömnätverket kan användas i funktionen Strömordning. Den här funktionen har endast stöd för ett D8-indataflödesriktningsrasterlager. D8-flödesriktningar kan skapas med funktionen Flödesriktning och köras med standardflödesriktningstypen D8.</div>",
		snapPourPointName: "Snappa hällpunkt",
		snapPourPointSnip: "Snappar hällpunkter till cellen med den högsta flödesackumuleringen inom ett angivet avstånd",
		snapPourPointDesc: "Det här är en global rasterfunktion. Den här funktionen snappar hällpunkter till cellen med den högsta flödesackumuleringen inom ett angivet avstånd.<div><br/>Funktionen Snappa hällpunkt används för att säkerställa val av punkter med högt ackumulerat flöde vid avgränsning av avrinningsområden med funktionen Avrinningsområde. Snappa hällpunkt söker inom ett snappningsavstånd runt de angivna hällpunkterna för cellen med högst ackumulerat flöde och flyttar hällpunkten till den platsen. Utdata är ett heltalsrasterlager när de ursprungliga platserna för hällpunkterna har snappats till platser med högre ackumulerat flöde.</div>",
		sinkName: "Sänka",
		sinkSnip: "Skapar ett raster som identifierar alla sänkor eller områden för intern dränering",
		sinkDesc: "Det här är en global rasterfunktion. Den här funktionen skapar ett raster som identifierar alla sänkor eller områden för intern dränering. En sänka är en cell eller en uppsättning geografiskt anslutna celler med en flödesriktning som inte går att tilldela något av de åtta giltiga värdena i ett flödesriktningsraster. Det här kan inträffa när alla intilliggande celler är högre än den bearbetande cellen eller när två celler flödar in i varandra och skapar en slinga med två celler.<div><br/>Funktionen Sänka stöder endast ett D8-indataflödesriktningsrasterlager. D8-flödesriktningar kan skapas med funktionen Flödesriktning och köras med standardflödesriktningstypen D8. Utdata för funktionen Sänka är ett heltalsraster där varje sänka tilldelas ett unikt värde. Dessa unika värden har ett intervall som ligger mellan ett och det totala antalet sänkor. Om det totala antalet sänkor till exempel var 1 000, sträcker sig det unika värdeintervallet från 1 till 1 000.</div>",
		aggregateName: "Aggregera",
		aggregateSnip: "Genererar en version av ett raster med minskad upplösning.",
		aggregateDesc: "Funktionen Aggregera omsamplar ett indataraster till en grövre upplösning baserat på en angiven aggregeringsstrategi. Varje utdatacell innehåller Summa, Minimum, Maximum, Medel eller Median för de indatacellerna som omfattas av den cellens utbredning.<div><br/>Du kan specificera faktorn med vilken cellstorleken av indatarastret ska multipliceras. Till exempel skulle ett cellfaktorvärde på 3 resultera i utdata där cellstorleken är tre gånger större än indatarastret. Du kan definiera hur utdatas utbredning ska hanteras om antalet rader eller kolumner inte är en exakt multipel av cellfaktorn. Som standard expanderas de övre eller högra gränserna för att täcka en större geografisk utbredning än indatarastrets, för att säkerställa att alla indataceller bearbetas. Alternativt kan de övre eller högra gränserna minskas för att täcka en mindre utbredning, så att det antal rader och kolumner som bearbetas är en exakt multipel av cellfaktorn. Du kan definiera hur NoData-celler ska hanteras av aggregeringsberäkningen. Standardmekanismen är att NoData-indataceller som faller inom den geografiska utbredningen för en större cell i utdatarastret ignoreras när värdet av den utdatacellen avgörs. Alternativt kan du ange att om det finns även en enstaka NoData-indatacell inom den geografiska utbredningen för en utdatacell, blir den cellen NoData i utdatarastret.</div>",
		ccdcName: "CCDC-analys",
		ccdcSnip: "Utvärderar ändringar i pixelvärden över tid med CCDC-algoritmen (Continuous Change Detection and Classification) och genererar modellresultat.",
		ccdcDesc: "CCDC-analysfunktionen utvärderar ändringar i pixelvärden över tid med CCDC-algoritmen (Continuous Change Detection and Classification) och genererar ett flerdimensionellt raster som innehåller modellresultaten. Den stöds bara i kombination med funktionen Identifiera ändring med hjälp av ändringsanalys i en rasterfunktionsmall. För att skapa rasterutdata måste du koppla CCDC-analysfunktionen till funktionen Identifiera ändring med hjälp av ändringsanalys, spara som en rasterfunktionsmall och köra Rasteranalys med funktionsmallen.<div><br/>Den här funktionen använder CCDC-algoritmen (Continuous Change Detection and Classification) för att utvärdera ändringar i pixelvärden över tid för en stapel bilder. I en tidsserie av optiska bilder eller bildhärledningar (t.ex. NDVI) kan pixelvärden fluktuera av flera anledningar: 1. Säsongsskiften – Ändrade pixelvärden motsvarar förändringar i vegetationen på grund av säsongsbetonade variationer i temperatur och nederbörd. På norra halvklotet väntar vi oss t.ex. att se högre täthet av grön vegetation på sommaren än på vintern; 2. Gradvis förändring – Ändrade pixelvärden återspeglar trender i växtlighet eller ytvatten på grund av klimatvariationer eller långsiktig markförvaltningspraxis. Till exempel kan bar mark gradvis öka i yta på grund av en långsiktig minskning av nederbörden, och 3. Abrupta ändringar – Ändrade pixelvärden återspeglar förändringar i marktäckning som uppkommer plötsligt på grund av skogsavverkning, stadsbyggnad, naturkatastrofer osv. CCDC-algoritmen identifierar alla tre typerna av förändring i det huvudsakliga syftet att identifiera abrupta förändringar. Harmonisk regression och trendmodeller anpassas till data för att beräkna säsongsbetonade och gradvisa förändringar, och plötsliga avvikelser från trendmodellerna är indikationer på abrupta förändringar.<div><br/>CCDC-algoritmen utformades ursprungligen för Landsat TM-, Landsat ETM+- och Landsat OLI-data ytreflektans- eller ljusstyrketemperaturdata. Funktionen Identifiera ändring med hjälp av ändringsanalys i kombination med denna funktion identifierar dock förändringar för flerbandsbilder från alla sensorer som stöds, samt ettbandsbildderivat som bandindex. Du kan till exempel utföra kontinuerlig identifiering av förändringar på ett NDVI-raster (Normalized Difference Vegetation Index), eftersom abrupta ändringar i NDVI kan indikera skogsavverkning.</div>",
		computeChangeName: "Beräkna förändring",
		computeChangeSnip: "Beräknar skillnaden mellan två kategoriska eller kontinuerliga rasterdataset.",
		computeChangeDesc: "Funktionen Beräkna förändring kan användas för att förteckna skillnaderna mellan två klassificerade raster för analys av marktäckningsförändring, eller så kan den användas för att undersöka förändringar mellan två kontinuerliga ettbandsraster som höjd över havet, temperatur, trädkroneteckning osv.",
		detectChangeName: "Identifiera ändring med hjälp av ändringsanalys",
		detectChangeSnip: "Genererar ett rasterlager som innehåller information om pixelförändringar med rastret för utdataförändringsanalys.",
		detectChangeDesc: "<div>Funktionen Identifiera ändring med hjälp av ändringsanalys genererar ett rasterlager som innehåller information om pixelförändringsdatum med förändringsanalysrastret. Förändringsanalysrastret måste genereras av verktyget Analysera förändring med CCDC eller Analysera ändringar med LandTrendr, eller rasterfunktionen CCDC-analys eller rasterfunktionen LandTrendr-analys.</div><br><div>Den här rasterfunktionen kan kombineras med rasterfunktionen CCDC-analys eller rasterfunktionen LandTrendr-analys i en rasterfunktionsmall. Om du vill skapa permanenta rasterutdata ansluter du CCDC-analysfunktionen eller LandTrendr-analysfunktionen till funktionen Identifiera ändring med hjälp av ändringsanalys, sparar som en mall för rasterfunktion och kör Rasteranalys med mallen. </div><br><div>Parametern <strong>Ändringstyp</strong> indikerar den information som genereras. Informationen extraheras från ändringsanalysrastret. När du kör den här funktionen på utdata från CCDC-funktionen/-verktyget kan du välja mellan följande alternativ:</div><ul><li><strong>Tid för senaste förändring</strong> – Det senaste datumet och tiden då en pixel flaggades som ändrad.</li><li><strong>Tid för tidigaste förändring</strong> – Det tidigaste datumet och tiden då en pixel flaggades som ändrad.</li><li><strong>Tid för största förändring</strong> – Datum och tid då den beräknade ändringen var den mest signifikanta för en pixel.</li><li> <strong>Antal förändringar</strong> – Det sammanlagda antalet gånger pixeln har ändrats.</li></ul><div>När funktionen körs på utdata från LandTrendr-funktionen/-verktyget finns följande ytterligare alternativ:</div><ul><li><strong>Tid för längsta förändring</strong> – Det datum då en pixel flaggades som ändrad, i början eller slutet av den längsta perioden för förändring.</li><li><strong>Tid för kortaste förändring</strong> – Det datum då en pixel flaggades som ändrad, i början eller slutet av den kortaste perioden för förändring.</li><li><strong>Tiden för snabbaste förändring</strong> – Det datum då en pixel flaggades som ändrad, i början eller slutet av den snabbaste perioden för förändring.</li><li><strong>Tid för långsammaste förändring</strong> – Det datum då en pixel flaggades som ändrad, i början eller slutet av den långsammaste perioden för förändring.</li></ul><div>Utdatarastret är ett flerbandsraster där varje band innehåller information om den valda ändringstypen och det maximala antalet angivna ändringar. Om till exempel <strong>Ändra typ</strong> är inställt till <strong>Tid för tidigaste förändring</strong> och <strong>Maximalt antal förändringar</strong> är inställt till 2, beräknar funktionen de två tidigaste datumen när en förändring inträffade genom tidsserien för varje pixel. Resultatet är ett raster där det första bandet innehåller datumen för den tidigaste förändringen per pixel, och det andra bandet innehåller datumen för den näst tidigaste förändringen per pixel.</div><br><div>När funktionen tillämpas på utdata från LandTrendr-verktygen, kan du välja om du vill extrahera det datum som markerar början av en förändring eller slutet av en förändring med parametern <strong>Segmentdatum</strong>. För att till exempel förstå hur den senaste ändringen i tidsserien startades, anger du <strong>Ändringstyp</strong> till <strong>Tid för senaste förändring</strong> och <strong>Segmentdatum</strong> till <strong>Början av segment</strong>.</div><br><div>Använd följande filtreringsparametrar om du vill extrahera mer specifika datum för förändring från ändringsanalysrastret:</div><ul><li><strong>Filtrera efter år</strong> – Identifiera förändringar som inträffade inom en viss tidsperiod, om du till exempel letar efter förändringar som har inträffat i ett landskap under fem år av torka.</li><li><strong>Filtrera efter varaktighet </strong> – Identifiera förändringar som inträffade under ett visst antal år, till exempel om du bara letar efter abrupta förändringar som ägde rum över 1 eller 2 år. Du kan beräkna den varaktighet du är intresserad av använda med hjälp av formeln <strong>slutår - startår +1</strong>. Mellanrum i tidsserien tas med.</li><li><strong>Filtrera efter magnitud</strong> – Identifiera ändringar av en viss magnitud, till exempel om du bara letar efter stora förändringar i vegetationsindexet NDVI. Magnitud är ett absolut värde, så minimi- och maximivärdena får inte vara negativa. Ange riktningsändring med parametern <strong>Ändra riktning</strong>.</li></ul>",
		distanceAccumulationName: "Avståndsackumulering",
		distanceAccumulationSnip: "Beräknar ackumulerat avstånd för varje cell till källor, med hänsyn till rak linje-avstånd, kostnadsavstånd, verkligt ytavstånd, samt vertikala och horisontella kostnadsfaktorer.",
		distanceAccumulationDesc: "Avståndsackumulering beräknar avståndet till varje plats i undersökningsområdet till den närmaste, eller billigaste, källan. Om bara källorna anges för indata, beräknas ett rak linje-avstånd till varje plats i undersökningsområdet. Om både källor och hinder används som indata, beräknar Avståndsackumulering rak linje-avståndet runt hinder. För både källrastret och hinderrastret bör bakgrundsvärdet vara NoData, medan källor och hinder representeras med giltiga cellvärden. Giltiga värden innefattar noll. <div><br/>När ett ytraster anges som indata, beräknas det faktiska ytavståndet mellan celler. För att utföra kostnadsanalys med Avståndsackumulering, behövs en kostnadsyta. Om en kostnadsyta anges, blir resultatet ett ackumulerat raster för avståndskostnad. När horisontal- och vertikalfaktorer tillhandahålls, beaktas riktning när kostnaden ackumuleras. Det finns fyra källgrunddrag som kan användas. Dessa grunddrag, som antingen kan vara för källan eller aktörerna från källan, styrs av specifika parametrar: 1. Inledande ackumulering: anger den inledande kostnaden innan rörelsen börjar. 2. Maximal ackumulering: anger hur mycket en källa kan ackumulera innan den når sin gräns. 3. Multiplikator att använda på kostnader: specificerar färdläget eller magnituden vid källan. 4. Reseriktning: identifierar om aktören startar vid en källa och rör sig till andra platser än källan, eller startar vid platser som inte tillhör källan och rör sig tillbaka till en källa.<div><br/>Som standard är resultatet från Avståndsackumulering ett enda band, som är avståndsackumuleringsrastret. Det går dock även att skapa ett andra band, tillbakariktningsbandet.  Det bandet visar i vilken riktning man ska resa från varje plats i undersökningsområdet för att komma till den billigaste källan. Båda banden behövs för att fastställa optimala rutter inom undersökningsområdet. För att generera en rutt ska först funktionen Extrahera band användas för att extrahera avståndsackumuleringsrastret och tillbakariktningsrastret. Använd dessa lager som indata för funktionen Kostnadsrutt. I funktionen använder du avståndsackumuleringsrastret som indata för Raster för avståndsackumuleringsraster, och tillbakariktningsrastret som indata för Raster för bakåtlänkskostnad.</div>",
		distanceAllocationName: "Avståndsallokering",
		distanceAllocationSnip: "Beräknar avståndsallokering för varje cell till de angivna källorna baserat på rak linje-avstånd, kostnadsavstånd, verkligt ytavstånd, samt vertikala och horisontella kostnadsfaktorer.",
		distanceAllocationDesc: "Avståndsallokering beräknar till vilken källa varje plats i undersökningsområdet är allokerad. Om endast källorna anges som indata, allokeras platserna efter ett rak linje-avstånd till den närmaste källan. Om både källor och hinder används som indata, beräknar Avståndsallokering rak linje-avståndet runt hinder för att avgöra vilken källa en plats allokeras till. För både källrastret och hinderrastret bör bakgrundsvärdet vara NoData, medan källor och hinder representeras med giltiga cellvärden. Giltiga värden innefattar noll.<div><br/>För att utföra kostnadsanalys med Avståndsallokering, behövs en kostnadsyta. Om en kostnadsyta anges är resultatet ett tilldelningsraster baserat på ackumulativ kostnad, inte på rak linje-avstånd. När horisontal- och vertikalfaktorer tillhandahålls, beaktas riktning när kostnaden ackumuleras. När ett ytraster anges som indata, beräknas det faktiska ytavståndet som täcks vid passage mellan celler när allokering avgörs. Det finns fyra källgrunddrag som kan användas. Dessa grunddrag, som antingen kan vara för källan eller aktörerna från källan, styrs av specifika parametrar: 1. Inledande ackumulering: anger den inledande kostnaden innan rörelsen börjar. 2. Maximal ackumulering: anger hur mycket en källa kan ackumulera innan den når sin gräns. 3. Multiplikator att använda på kostnader: specificerar färdläget eller magnituden vid källan. 4. Reseriktning: identifierar om aktören startar vid en källa och rör sig till andra platser än källan, eller startar vid platser som inte tillhör källan och rör sig tillbaka till en källa.<div><br/>Som standard är resultatet från Avståndsallokering ett enda band, som är avståndsallokeringsrastret. Om du markerar det booleska alternativet Generera källrad och kolumn som ytterligare band i utdata resulterar det i ett flerbandsraster som består av tre band. Det första bandet är avståndsallokeringsbandet, det andra bandet innehåller ett radindex och det tredje bandet innehåller ett kolumnindex. Dessa index identifierar platsen för källcellen som är den lägsta ackumulerade avståndskostnaden bort. Källradindexet och källkolumnindexet kan användas tillsammans för att skapa intensitetskartor. Om du söker efter någon plats i undersökningsområdet över band två och tre, vet du raden och kolumnen för den billigaste källan för den platsen.</div>",
		eucBackDirectionName: "Euklidisk tillbakafördelning",
		eucBackDirectionSnip: "Beräknar riktningen i grader för varje cell mot en angränsande cell längs den kortaste vägen tillbaka till den närmaste källan samtidigt som det undviker hinder.",
		eucBackDirectionDesc: "Funktionen Euklidisk tillbakafördelning resulterar i ett kontinuerligt flyttalsraster som representerar riktningen i grader tillbaka till den närmaste källan samtidigt som det undviker eventuella hinder.<div><br/>Indata till Euklidisk tillbakafördelning är den källa som riktningen beräknas till. Valfria indata är ett raster som representerar hinder inom undersökningsområdet. För både källrastret och hinderrastret bör bakgrundsvärdet vara NoData, medan källor och hinder representeras med giltiga värden. Giltiga värden innefattar noll. Som standard bearbetar beräkningen till den kombinerade utbredningen av källorna och hindren, plus 2 rader och kolumner. Om analysen bara behövs inom ett angivet avstånd från källorna, kan parametern Maximalt avstånd användas. Euklidisk tillbakafördelning har stöd för både en plan metod och en geodetisk metod i beräkningen. Beräkningen med plan metod utförs på ett projicerat platt plan med ett tvådimensionellt kartesiskt koordinatsystem. Beräkningen med geodetisk metod utförs på ellipsoiden, vilket innebär att resultatet inte förändras beroende av indata- eller utdataprojektion.<div><br/>Resultatet från funktionen Euklidisk tillbakafördelning kan användas i kombination med resultatet från funktionen Euklidiskt avstånd för att avgöra de kortaste rutterna från platser inom undersökningsområdet tillbaka till källan. Både resultatet för Euklidisk tillbakafördelning och resultatet för Euklidiskt avstånd används i funktionen Kostnadsrutt tillsammans med mål för att generera de kortaste rutterna.</div>",
		expandName: "Expandera",
		expandSnip: "Expanderar valda zoner i ett raster efter zoner med ett visst antal celler.",
		expandDesc: "Med den globala Expandera-funktionen kan du generalisera eller förenkla raster genom att göra vissa zoner större. Du kan också styra mängden generalisering som ska förekomma.<div><br/>De zoner du väljer ökar i storlek genom att expandera till andra zoner. Konceptuellt kan de valda zonvärdena ses som förgrundszoner, medan de andra värdena förblir bakgrundszoner. Förgrundszonerna kan expandera till bakgrundszonerna.<div><br/>Mängden generalisering kan styras med parametern Antal celler. Som standard är detta värde 1, vilket innebär att de valda zonerna expanderar med den mängd som motsvarar en cells storlek. För att öka graden av generalisering kan du ange ett större värde för den här parametern. Konceptuellt är det som att köra verktyget lika många gånger som det angivna antalet, där resultaten av föregående körning är indata till nästa iteration.</div>",
		trendAnalysisName: "Generera trend",
		trendAnalysisSnip: "Uppskattar trenden för varje pixel längs en dimension för en eller flera variabler i ett flerdimensionellt raster.",
		trendAnalysisDesc: "<div>Den här funktionen kan användas för att passa data längs en linjär, harmonisk eller polynom trendlinje, eller så kan den användas för att utföra trendidentifiering med Mann-Kendall- eller Seasonal-Kendall-testet.</div><br><div>Utdatatrendrastret som genereras med den här funktionen används som indata till funktionen <strong>Förutsäg med trend</strong>.</div><br><div>Mann-Kendall- och Seasonal-Kendall-testerna används för att avgöra om det finns en monotonisk trend i data. De är icke-parametriska, vilket innebär att de inte förutsätter någon specifik datafördelning. Mann-Kendall-testet tar inte hänsyn till serieeffekter för korrelationer eller årstider. Om data är årstidsberoende är Seasonal-Kendall-testet mer lämpligt.</div><br><div>Om verktyget används för att utföra antingen Mann-Kendall- eller Seasonal-Kendall-testet, är utdata ett raster med fem band enligt följande:</div><ul><li>Band 1 = Sens sluttning</li><li>2 = p-värde</li><li>Band 3 = Mann-Kendall-poäng (S)</li><li>Band 4 = S-varians</li><li>Band 4 = S-varians</li><li>Band 5 = Z-poäng</li></ul><div>Resultaten från Mann-Kendall-testet eller Seasonal-Kendall-testet kan användas för att fastställa vilka pixlar i flerdimensionella tidsserier som har en statistiskt signifikant trend. Den här informationen kan du använda i samband med linjära, harmoniska eller polynoma trendanalyser för att extrahera signifikanta trender i din tidsserie. Du kan generera en mask som innehåller pixlar med signifikanta p-värden, tillämpa masken på det flerdimensionella rastret och använda det maskerade flerdimensionsrastret som indata för verktyget för att utföra linjära analyser av p-värden eller polynomtrender.</div><br><div>Det finns tre trendlinjealternativ för att anpassa en trend till variabelvärdena längs en dimension: linjär, polynom och harmonisk.</div><br><div>För linjära trendanalyser är utdata ett trebandsraster enligt följande:</div><ul><li>Band 1 = Lutning</li><li>Band 2 = Intercept</li><li>Band 3 = Medelkvadratrotsfel (RMSE) eller felet runt linjen för bästa passning</li></ul><div>För polynom trendanalys beror antalet band i utdata på polynomordningen. Andra ordningens polynompassning skapar ett fyrabandsraster enligt följande:</div><ul><li>Band 1 = Polynom_2</li><li>Band 2 = Polynom_1</li><li>Band 3 = Polynom_0</li><li>Band 4 = Medelkvadratrotsfel</li></ul><div>Tredje ordningens polynompassning skapar ett fembandsraster enligt följande:</div><ul><li>Band 1 = Polynom_3</li><li>Band 2 = Polynom_2</li><li>Band 3 = Polynom_1</li><li>Band 4 = Polynom_0</li><li>Band 5 = Medelkvadratrotsfel</li></ul><div>För harmonisk trendanalys beror antalet band i utdata på den harmoniska frekvensen. När frekvensen är inställd till 1 är utdata ett fembandsraster enligt följande:</div><ul><li>Band 1 = Lutning</li><li>Band 2 = Intercept</li><li>Band 3 = Harmonisk_sin1</li><li>Band 4 = Harmonisk_cos1</li><li>Band 5 = Medelkvadratrotsfel</li></ul><div>När frekvensen är inställd på 2 är utdata ett raster på sju band enligt följande:</div><ul><li>Band 1 = Lutning</li><li>Band 2 = Intercept</li><li>Band 3 = Harmonisk_sin1</li><li>Band 4 = Harmonisk_cos1</li><li>Band 5 = Harmonisk_sin2</li><li>Band 6 = Harmonisk_cos2</li><li>Band 7 = Medelkvadratrotsfel</li></ul><div>Parametern <strong>Cykellängd</strong> för harmonisk trendanalys används för att visa antalet och längder för cykler som du väntar dig att se i dina data under en dag eller ett år. Om du till exempel väntar dig att dina data går igenom två variationscykler under ett år, är cykellängden 182,5 dagar eller 0,5 år. Om du har temperaturdata som samlats in var tredje timme och det finns en variationscykel per dag, är cykellängden en dag.</div><br><div>Parametern <strong>Frekvens</strong> för harmonisk trendanalys används för att beskriva den harmoniska modellen att passa till informationen. Om frekvensen är inställd till 1, används en kombination av linjär och första ordningens harmoniska kurva för att anpassa modellen. Om frekvensen är 2, används en kombination av linjära och första och andra ordningens harmoniska kurvor för att anpassa data. Om frekvensen är 3 används en ytterligare tredje ordningens harmonisk kurva för att modellera data, och så vidare.</div><br><div>Statistiken för modellens goodness-of-fit kan genereras som valfria utdata. Medelkvadratrotsfelet (RMSE), R-kvadrat och p-värdet för trendens lutning kan beräknas och symboliseras. Symbolisera utdatatrendens rasterlager med <strong>RGB</strong>-symbologi och ange statistiken som de röda, gröna och blå banden.</div><br>",
		spectralUnmixingName: "Linjär spektral oblandning",
		spectralUnmixingSnip: "Utför klassificering av underpixlar och beräknar bråkandelen av olika marktäckningstyper för enskilda pixlar.",
		spectralUnmixingDesc: "Funktionen Linjär spektral oblandning beräknar bråktäckningen för enskilda pixlar som innehåller flera marktäckningstyper. Den genererar ett flerbandslager, där varje band motsvarar bråkandelen av varje marktäckningsklass. Du kan t.ex. använda den för att utföra klassificering av marktäckning på en multispektral bild för att identifiera fotosyntetisk vegetation, bar mark och död eller icke-fotosyntetisk vegetation.<div><br/>Ordningen för utdataflerbandsrastret följer ordningen i den spektrala indataprofilen. Antalet klasser får inte överstiga antalet band i indatarastret. Du kan till exempel inte extrahera information om fler än 8 klasser från ett 8-bandsraster.</div>",
		multidimensionalFilterName: "Flerdimensionellt filter",
		interpolateRasterByDimensionFunctionName: "Interpolera raster efter dimension",
		interpolateRasterByDimensionFunctionSnip: "Interpolerar ett flerdimensionellt raster vid angivna dimensionsvärden med intilliggande sektorer.",
		interpolateRasterByDimensionFunctionDesc: "<p>Med den här funktionen kan du beräkna pixelvärden för en odefinierad dimensionssektor i ett flerdimensionellt raster. Om du till exempel har ett dataset som innehåller havstemperatur vid ytnivå och vid 100 meter under havsnivån och du vill beräkna temperaturen vid 50 meter under havsnivån, kan du använda den här funktionen för att få en uppskattning på det djupet med dimensionsdefinitionen Efter värden.</p><p>Du kan även nedsampla ett månatligt dataset till ett dagligt dataset med dimensionsdefinitionen Efter intervall och ange stegparametervärdet som 1 och enhetsparametervärdet som dagar.</p><p>Använd dimensionsdefinitionen Efter målraster för att beräkna värdet för målrastret.</p>",
		multidimensionalFilterSnip: "Skapar ett rasterlager från ett flerdimensionellt rasterdataset eller ett flerdimensionellt rasterlager genom att dela upp data enligt definierade variabler och dimensioner.",
		multidimensionalFilterDesc: "Det flerdimensionella filtret skapar ett flerdimensionellt rasterlager genom att filtrera och extrahera en delmängd variabler från ett flerdimensionellt raster. Till exempel kan du ha ett flerdimensionellt dataset som innehåller 30 års data om månadsnederbörd, och du vill bara extrahera data för varje januari för att se hur nederbörden har förändrats för den månaden.<div><br/>Använd parametern Dimensionsdefinition för att dela upp dimensioner efter ett intervall, ett värde eller ett intervall av värden. Om du t.ex. har 10 års data över salthalt för havet, insamlade varje månad och på varannan meters djup upp till 500 meter, kan du använda de olika alternativen för dimensionsdefinition för följande scenarion. Scenario 1: Extrahera salthaltsdata för januari månad över 10-årsperioden. Välj Efter värde, ställ in Dimension till StdTid och ställ in Värden till januari. Scenario 2: Dela upp salthaltsdata över ett djupintervall från 0 till 150 meter. Välj Efter intervall, ställ in Dimension till StdZ och ställ in Minimivärde till -150 och Maximumvärde till 0. Scenario 3: Extrahera salthaltsdata för de första 10 dagarna i januari över en 10-årsperiod. Välj Efter iteration, ställ in Dimension till StdTid, ställ in Början av första iterationen och Slutet av första iterationen till motsvarande början och slut av iterationsperioden, ställ in Steg till 1 och ställ in Enhet till År.</div>",
		multidimensionalRasterName: "Flerdimensionellt raster",
		multidimensionalRasterSnip: "Lägger till flerdimensionella data på en karta som ett flerdimensionellt rasterlager.",
		multidimensionalRasterDesc: "Funktionen Flerdimensionellt raster lägger till flerdimensionella data på en karta som ett flerdimensionellt rasterlager. Den här funktionen är användbar när du utför rasteranalysarbetsflöden med en funktionskedja.<div><br/>Flerdimensionella rasterdataset som stöds innefattar netCDF, GRIB, HDF och Esris CRF. Flerdimensionella mosaikdataset stöds också.</div>",
		optimalPathAsRasterName: "Optimal väg som raster",
		optimalPathAsRasterSnip: "Beräknar den billigaste rutten från en källa till en destination.",
		optimalPathAsRasterDesc: "Den här globala funktionen producerar ett utdataraster som registrerar den optimala rutten eller rutter från valda platser till den närmaste ursprungscellen som definierats inom den ackumulerade kostnadsytan, med avseende på kostnad för avstånd.<div><br/>En eller flera av funktionerna för vägda kostnader (Avståndsackumulering eller Avståndsallokering) måste i allmänhet köras innan funktionen Optimal väg som raster körs för att skapa indatarastren för avståndsackumulering och tillbakariktning. De är obligatoriska indatarasterlager för funktionen Optimal väg. Värdet för den utmatade optimala vägen motsvarar antalet vägar på en given plats. I många fall följer vägar samma rutt, lämnar en källa och delar sig sedan för att gå till olika destinationer. Till exempel visar värdet ett att det bara finns en optimal väg på en given plats, medan värdet fem betyder att det på den platsen finns fem optimala vägar som går genom den cellen i undersökningsområdet.<div><br/>Indestinationsdata måste vara ett rasterlager. Uppsättningen destinationsceller består av alla celler i indatarastret som har giltiga värden. Celler som har NoData-värden ingår inte i setet. Värdet noll ses som ett legitimt mål. Ett destinationsraster kan skapas med extraheringsverktygen. Om du har destinations- eller källgeoobjekt, kan du konvertera dem till raster med funktionen Rastrera geoobjekt. Använd rastret avståndsackumulering eller tillbakariktning som rasterindata för rastreringsfunktionen. Detta säkerställer att geoobjektet rastreras med samma cellstorlek, utbredning och geografiska referens som de andra rastren som går in i funktionen Optimal väg som raster. Funktionen Optimal väg som raster kan också användas för att härleda vägen med lägst motstånd nedför en digital höjdmodell. Använd i så fall den digitala höjdmodellen för indataavståndsackumuleringsrastret och utdata från funktionen Flödesriktning för tillbakariktningsrastret.</div>",
		trendName: "Förutsäg med trend",
		trendSnip: "Beräknar ett prognostiserat flerdimensionellt rasterlager med utdatatrendrastret från funktionen Generera trend eller geobearbetningsverktyget Generera trendraster.",
		trendDesc: "Funktionen Förutsäg med trend beräknar ett prognostiserat flerdimensionellt rasterlager med utdatatrendrastret från funktionen Generera trend eller geobearbetningsverktyget Generera trendraster.",
		rasterCollectionName: "Bearbeta rastersamling",
		rasterCollectionSnip: "Bearbetar varje sektor i ett flerdimensionellt raster eller varje objekt i ett mosaikraster. Funktionen kan också aggregera flera sektorer till en enda sektor.",
		rasterCollectionDesc: "Funktionen Bearbeta rastersamling bearbetar varje sektor i ett flerdimensionellt raster eller varje objekt i ett mosaikraster. Funktionen kan också aggregera flera sektorer till en enda sektor.<div><br/>Den här funktionen bearbetar varje sektor i ett flerdimensionellt raster eller mosaikraster med en rasterfunktionsmall. Funktionen har stöd för följande alternativ: 1. Ange en rasterfunktionsmall för Objektfunktion. Du har till exempel ett mosaikdataset som innehåller 20 års Landsat-bilder och du vill beräkna NDVI för varje scen i tidsserien. För Objektfunktion anger du en rasterfunktionsmall som innehåller NDVI-rasterfunktionen. 2. Ange en rasterfunktionsmall för Aggregeringsfunktionen. Du har till exempel ett flerdimensionellt raster som innehåller 10 års dagliga temperaturdata och du vill beräkna den maximala temperaturen för varje år. I Aggregeringsfunktionen anger du en rasterfunktionsmall som innehåller funktionen Cellstatistik, med operationen inställd på Maximum. Under Aggregeringsdefinition ställer du in Dimension till StdTid, ställer in Typ till Intervallnyckelord och ställer in Nyckelordsintervall till Årligen. Observera att om indatamosaikdatasetet inte är flerdimensionellt, tar aggregeringsfunktionen inte hänsyn till aggregeringsdefinitionen. Aggregeringsfunktionen aggregerar alla objekt eller varje grupp till en om de är definierade i aggregeringsfunktionsmallen. Mer information om att använda grupper i ett mosaikdataset finns i Använda mosaikdatasetobjekt i Rasterfunktionsmallar. 3. Ange en rasterfunktionsmall för Bearbetningsfunktionen. Funktionen eller funktionskedjan i den här mallen används för att visa det nya bearbetade rastret. Ange till exempel en rasterfunktionsmall som innehåller funktionen Färgkarta för att ändra hur det bearbetade rasterlagret ska visas. Observera att om indata är ett flerdimensionellt raster, tillämpas bearbetningsfunktionen på den aktuella visningssektorn. Om indata är ett mosaiklager eller mosaikdataset, tillämpas bearbetningsfunktionen på mosaikrastret med metoden Först för att lösa överlappningar. 3. Ange mallar för någon kombination av de tre funktionerna. Du har till exempel ett mosaikdataset som innehåller Landsat-bilder med tidsserier och du vill generera en sammansatt bild av maximal NDVI. För Objektfunktion anger du en rasterfunktionsmall som innehåller NDVI-rasterfunktionen. För Aggregeringsfunktionen anger du en rasterfunktionsmall som innehåller funktionen Cellstatistik, med operationen inställd på Maximum. För Bearbetningsfunktion anger du en rasterfunktionsmall som innehåller funktionen Färgkarta. Observera att ordningen för funktionsbearbetning följer indataparametrarnas ordning. Till exempel bearbetas Objektfunktionen först.</div>",
		randomName: "Slumpmässig",
		randomSnip: "Skapar ett raster med slumpmässiga pixelvärden som hämtats från en pseudoslumpmässig distribution. Det finns stöd för flera distributioner och slumptalgeneratorer.",
		randomDesc: "Funktionen Slumpmässig skapar ett raster med slumpmässiga pixelvärden som kan användas i rasterfunktionsmallar eller mosaikdataset.<div><br/>Även om många funktioner fungerar på ett eller flera indataraster, kräver funktionen Slumpmässig inget indataraster. Det innebär att den beter sig mer som ett rasterdataset än en funktion, så särskild försiktighet krävs när du lägger till den i eller tar bort den från funktionskedjan.</div>",
		shrinkName: "Krymp",
		shrinkSnip: "Krymper de valda zonerna med ett angivet antal celler genom att ersätta dem med värdet av den mest frekventa cellen i dess närområde.",
		shrinkDesc: "Med den globala Krymp-funktionen kan du generalisera eller förenkla raster genom att göra vissa zoner mindre. Du kan också styra mängden generalisering som ska förekomma.<div><br/>De zoner du väljer krymper, eller reduceras i storlek, genom att celler från omgivande zoner expanderar in i dem. Konceptuellt kan de valda zonvärdena ses som förgrundszoner, medan de andra värdena förblir bakgrundszoner. Cellerna i förgrundszonerna kan ersättas av celler i bakgrundszonerna. Tunna öar inuti en zon, som kan ses som att de delar gränser med zonen, kan också ersättas.<div><br/>Mängden generalisering kan styras med parametern Antal celler. Som standard är detta värde 1, vilket innebär att de valda zonerna krymper med den mängd som motsvarar en cells storlek. För att öka graden av generalisering kan du ange ett större värde för den här parametern. Konceptuellt är det som att köra verktyget lika många gånger som det angivna antalet, där resultaten av föregående körning är indata till nästa iteration.</div>",
		trendToRGBName: "Trend till RGB",
		trendToRGBSnip: "Konverterar ett trendraster till ett raster med tre band (rött, grönt och blått).",
		trendToRGBDesc: "Funktionen Trend till RGB konverterar ett trendraster till ett raster med tre band (rött, grönt och blått). Trendrastret genereras från rasterfunktionen Generera trend eller CCDC-analys.<div><br/>Den här funktionen är användbar för att visualisera modellkoefficientdata från funktionen Generera trend eller funktionen CCDC-analys. Båda funktionerna uppskattar trender i ändrade pixelvärden, men resultaten av funktionerna är svåra att tolka direkt.<div><br/>Som många rasterfunktioner kan du behöva använda dynamisk intervalljustering för att visa resultaten från funktionen.</div>",
		landTrendrName: "LandTrendr-analys",
		landTrendrSnip: "Utvärderar ändringar i pixelvärden över tid med Landsat-baserad upptäckt av trender inom metoder för störning och återhämtning (LandTrendr) och genererar ett ändringsanalysraster som innehåller modellresultaten.",
		landTrendrDesc: "Denna rasterfunktion kan bara användas som indata till rasterfunktionen Identifiera ändring med hjälp av ändringsanalys. För att skapa rasterutdata måste du koppla LandTrendr-analysfunktionen till funktionen Identifiera ändring med hjälp av ändringsanalys i en rasterfunktionsmall och använda mallen som indata i geobearbetningsverktyget Generera raster från rasterfunktion. Resultatet är ett raster som innehåller information om tidpunkten då pixelvärdena ändrades.<div><br>Syftet med denna rasterfunktion är att extrahera ändringarna i ett observerat geoobjekt, så idealiska flerdimensionella indata bör samla in en konsekvent observation över tid och bör inte inkludera atmosfärisk interferens eller sensorinterferens, moln eller molnskugga. Bästa praxis är att använda data som har normaliserats och kan maskeras med ett QA-band, till exempel Landsat Collection 1 Ytreflektans-produkter med en molnmask.<div><br>Funktionen utför analys på en bild per år och antalet årsdelar måste vara lika med eller större än värdet som anges i parametern <strong>Lägsta antal observationer</strong>. Vi rekommenderar att du har minst sex års data.<div><br>Om du har månatliga, veckovisa eller dagliga data rekommenderar vi att du väljer flera bilder från varje år (helst från samma årstid), tar bort moln och molnskugga och kombinerar bilderna för att generera en enskild bild som fångar observationen väl. Om månatliga, veckovisa eller dagliga data tillhandahålls som flerdimensionellt raster som indata, identifierar funktionen en del för analys baserat på de data som är närmast de som anges i parametern <strong>Snappningsdatum</strong>.<div><br>En funktion i landskapet tar ofta tid att återställa från en icke-permanent ändring som en skogsbrand eller ett insektsangrepp. Du kan styra återhämtningstakten för modellen genom att ange parametern Tröskelvärde för återhämtning. Ett distinkt segment kan inte ha en återhämtningstakt som är snabbare än tröskelvärdet för återhämtning 1/.<div><br>Återhämtningen från en landskapsförändring kan ske i positiv eller negativ riktning. Till exempel: när en skogsförlust uppstår i ett landskap så uppvisar en tidsserie med värden för vegetationsindex en sänkning av indexvärden. Återhämtningen visar en gradvis ökning av vegetationens indexvärden, eller en positiv återhämtningstrend. Ange riktningen för återhämtningstrenden med parametern <strong>Återställningen har en ökande trend</strong>.",
		aggregateMultidimensionalName: "Aggregera flerdimensionellt",
		aggregateMultidimensionalSnip: "Kombinerar befintliga flerdimensionella rastervariabeldata längs en dimension.",
		aggregateMultidimensionalDesc: "Funktionen Aggregera flerdimensionellt skapar ett flerdimensionellt rasterlager genom att kombinera befintliga flerdimensionella rastervariabeldata längs en dimension.<div><br>Använd parametern <strong>Dimensionsdefinition</strong> för att först filtrera de indata du vill aggregera. Om du till exempel har 30 år med månadsdata men bara vill skapa ett aggregerat lager för de första 15 åren, kan du använda parametern <strong>Dimensionsdefinition</strong> för att ange vilka år som ska ingå i analysen.<div><br><ul><li>Extrahera salthaltsdata för januari månad under 10-årsperioden. Välj <strong>Efter värden</strong>, ställ in <strong>Dimension</strong> till <strong>StdTid</strong> och ställ in <strong>Värden</strong> till <strong>Januari</strong>.</li><li>Dela upp salthaltsdata över ett djupintervall från 0 till 150 meter. Välj <strong>Efter intervall</strong>, ställ in <strong>Dimension</strong> till <strong>StdZ</strong> och ställ in <strong>Minimivärde</strong> till <strong>-150</strong> och <strong>Maximumvärde</strong> till <strong>0</strong>.</li><li> Extrahera salthaltsdata för de första 10 dagarna i januari över en 10-årsperiod. Välj <strong>Efter iteration</strong>, ställ in <strong>Dimension</strong> till <strong>StdTid</strong>, ställ in <strong>Början av första iterationen</strong> och <strong>Slutet av första iterationen</strong> till motsvarande början och slut av iterationsperioden, ställ in <strong>Steg</strong> till <strong>1</strong> och ställ in <strong>Enhet</strong> till <strong>År</strong>.</li></ul><div><br>Använd parametrarna <strong>Aggregeringsdefinition</strong> för att välja dimension att utvärdera och aggregeringsintervallet med nyckelord, ett värde eller ett värdeintervall. Om du till exempel har 30 års data över havsytans temperatur, insamlad varje dag och på var femte meters djup ända ned till 100 meter, kan du använda de olika intervallalternativen för följande scenarion:<div><br><ul><li>Aggregera dagstemperaturdata till månadsdata, där resultatet är ett flerdimensionellt raster med 12 tidsdelar, och varje del är en aggregering av varje månad under alla åren. Välj <strong>Intervallnyckelord</strong> och ställ in nyckelordet till <strong>Återkommer månadsvis</strong>.</li><li>Aggregera dagliga temperaturdata till månadsdata, där resultatet är ett flerdimensionellt raster med 360 delar eller 12 tidsdelar per år (30 år × 12 månader = 360 bitar). Välj <strong>Intervallnyckelord</strong> och ställ in nyckelordet till <strong>Månadsvis</strong>.</li><li>Aggregera månadstemperaturdata till fyramånadersintervall. Välj <strong>Intervallvärde</strong>, ställ in <strong>Värdeintervall</strong> till 4, och ställ in <strong>Enhet</strong> till <strong>Månader</strong>.</li><li>Aggregera temperaturdata från 0 till 25 meter, sedan från 25 till 50 meter, därefter från 50 till 100 meter. Välj <strong>Intervallområden</strong> och ange minsta och största djup som <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Sammanfoga raster",
		mergeRastersSnip: "Kombinerar flera rasterdataset geografiskt eller över variabler och dimensioner.",
		mergeRastersDesc: "Funktionen skapar ett sammanfogat raster från en lista med raster. Om du till exempel har ett mosaikdataset som innehåller 30 års data om månadsnederbörd, och ett annat dataset med 10 års data om månadstemperatur, så kan du kombinera dem till ett flerdimensionellt raster med båda variablerna. <div><br>Om flerdimensionella raster som indata innehåller olika variabler kommer flerdimensionella raster som utdata att innehålla alla de variablerna. <div><br>Om flerdimensionella raster som indata innehåller olika dimensioner eller dimensionsvärden, kommer flerdimensionella raster som utdata att innehålla alla dessa dimensioner och dimensionsvärden. <div><br>Om flerdimensionella raster som indata innehåller samma dimensioner och variabler men olika geografisk utbredning, kommer flerdimensionella raster som utdata att innehålla dessa variabler och dimensioner över de sammanfogade geografiska utbredningarna.<div><br>Denna funktion kan också användas när du har många raster som du vill behandla som ett enskilt objekt, som att beräkna samma statistik för alla, eller när färgbalansering tillämpas så att du inte behöver färgbalansera varje bild separat. Det här är användbart när du arbetar med bilder som lagrats som separata tiles på grund av filstorleksbegränsningar, för på det sättet behandlas alla tiles som en del av samma bild.",
		boundaryCleanName: "Gränsrensning",
		boundaryCleanSnip: "Jämnar ut gränsen mellan zoner.",
		boundaryCleanDesc: "<p>Funktionen generaliserar eller förenklar raster genom att jämna ut gränserna mellan zoner. Funktionen innehåller alternativ för att styra hur cellerna i zonerna i indata påverkar utjämningen och mängden utjämning som ska tillämpas. Varje indatacell utvärderas med hjälp av sina åtta närmaste grannar.</p><p>Utjämningsprocessen sorterar först granncellerna med en viss prioritet. Prioriteten avgör vilken zon från de närliggande cellerna som kan ersätta värdet av bearbetningscellen i utdata.</p><p>Prioriteten kan baseras på antingen värdet i zonerna eller storleken på zonerna. Parametern <strong>Sorteringstyp</strong> avgör vilken sorteringstyp som ska användas. </p><p> Standardinställningen <strong>Sortera inte</strong> utvärderar prioriteten baserat på värdet för zonerna. Celler från zoner med större värden kommer att ha högre prioritet för att expandera till zoner med mindre värden.</p><p>Zonernas storlek eller totala yta kan användas för att sortera prioriteten. Med inställningen <strong>Fallande</strong> sorteras zonerna efter storlek i fallande ordning. Zonerna med större totala ytor kommer att ha prioriteten att expandera till zoner med mindre ytor. Med inställningen <strong>Stigande</strong> gäller motsatsen: zoner med mindre totala ytor kommer att ha prioriteten att expandera till zoner med större totala ytor.</p><p>Mängden utjämning styrs av parametern <strong>Kör expansion och krympning två gånger</strong>, som avgör hur många gånger processen för expansion och krympning ska utföras.</p><p>När inställningen är avmarkerad utförs processen för expansion och krympning en gång. När inställningen är markerad utförs processen för expansion och krympning två gånger, vilket resulterar i en extra grad av utjämning av zongränserna.</p><p>Om värdena i alla åtta närliggande celler är samma som bearbetningscellen behåller utdatacellen värdet hos indatacellen.</p>",
		predictUsingRegressionName: "Förutsäg med regression",
		predictUsingRegressionSnip: "Beräknat ett förutsagt raster från rasterindata och en regressionsmodell. Regressionsmodellen är utdatan från geobearbetningsverktyget för raster, <strong>Regressionsmodell för träning av slumpmässiga träd</strong>.",
		predictUsingRegressionDesc: "<p>Regressionsmodellen definieras i Esris regressionsdefinitionsfil (.ecd). Den innehåller all information för ett specifikt dataset eller en uppsättning med dataset, samt regressionsmodellen, och genereras av geobearbetningsverktyget för raster, <strong>Regressionsmodell för träning av slumpmässiga träd</strong>.</p><p>Indata kan vara ett enskilt band, flerband, ett flerdimensionellt raster eller en lista över dessa typer. Typerna för indataraster måste vara av samma rastertyp som tränas av regressionsmodellen.</p><ul><li>När indata är ett flerbandsraster behandlas varje band som en prediktorvariabel. Banden måste vara i samma ordning som flerbandsindatan för träningsverktyget för regressionsmodellen.</li><li>När indata är ett flerdimensionellt raster behandlas varje variabel som en prediktorvariabel, och variabeln måste vara ett enskilt band och ha en tidsdimension. Variabelordningen och namnen måste vara samma som indata från när regressionsmodellen tränades. Utdata är ett flerdimensionellt raster.</li><li>Indata kan vara en lista med objekt. Antalet objekt och ordningen för objekten måste matcha indata från när regressionsmodellen tränades.</li></ul>",
		dimensionalMovingStatisticsName: "Dimensionell glidande statistik",
		dimensionalMovingStatisticsSnip: "Beräknar statistik från ett rörligt fönster med flerdimensionella data längs en angiven dimension.",
		dimensionalMovingStatisticsDesc: "<p>Funktionen Dimensionell glidande statistik beräknar olika statistik inom ett fördefinierat fönster för alla dimensionsvärden längs en dimension. Funkionen tar ett flerdimensionellt rasterlager som indata och skapar ett flerdimensionellt rasterlager som utdata som har samma dimensionella storlek som indatalagret.</p><p>Du kan ange en dimension för vilken dimensionsvärden beaktas vid beräkning. Som standard sker beräkningen längs den första icke-spatiala dimensionen. Du kan även ange en fönsterstorlek genom att ange parametrarna Fönster bakåt och Fönster framåt.</p><p>När statistiktypen är inställd på percentil blir parametrarna Percentilvärde och Interpoleringstyp för percentil tillgängliga. Du kan använda dessa parametrar för att ange percentilen för att beräkna och välja vilken interpoleringstyp som ska användas. När statistiktypen är inställd på Cirkulärt medelvärde blir parametern Cirkulärt radbrytningsvärde tillgänglig. Det cirkulära radbrytningsvärdet används för att konvertera ett linjärt värde till intervallet för ett angivet cirkulärt medelvärde.</p>",
		terrainFlattenFunctionName: "Terrängavplattning",
		terrainFlattenFunctionSnip: "Korrigerar indata för syntetisk aperturradardata (SAR) för radiometriska förvrängningar på grund av topografi.",
		terrainFlattenFunctionDesc: "<p>Funktionen Terrängavplattning korrigerar indata för syntetisk aperturradardata (SAR) för radiometriska förvrängningar på grund av topografi.</p><p>Radarindata måste först kalibreras till beta-noll. Använd verktyget Tillämpa radiometrisk kalibrering för att kalibrera radardata till beta-noll.</p><p>Om DEM som indata inte omfattar hela SAR-datasetet matar verktyget ut NoData-värden för pixlarna utanför DEM-utbredningen för gamma-noll, sigma-noll, spridningsområde och geometriska förvrängningsutdata. För den geometriska förvrängningsmaskens utdata matar verktyget ut obestämda värden för pixlar utanför DEM-utbredningen.</p><p>DEM som indata måste vara i det geografiska koordinatsystemet WGS 1984 (EPSG:4326).</p>",
		createColorCompositeFunctionName: "Skapa färgkombination",
		createColorCompositeFunctionSnip: "Skapar ett trebandsraster från ett flerbandsrasterdataset i vilket varje band kan använda en algebraisk beräkning baserat på bandalgebra.",
		createColorCompositeFunctionDesc: "<p>Rasterfunktionen Skapa färgkombination skapar ett trebandsraster från ett flerbandsrasterdataset i vilket varje band kan använda en algebraisk beräkning baserat på bandalgebra.</p><p>När en bandaritmetisk algoritm definieras kan du ange en algebraisk formel med en rad för varje uttryck för att skapa flerbandsutdata. Operatorerna som stöds är enställig, plus (+), minus (-), gånger (*) och delat med (/).</p><p>Identifiera bandet genom att ange prefixet B eller b för bandnumret när du använder ett band-ID i ett uttryck.</p><p>En vanlig bandkombination som används för syntetisk aperturradar (SAR) i linjära enheter är VV för rött, VH för grönt och VV/VH för blått. Om indata är i decibel ska bandkombinationen vara VV för rött, VH för grönt och VV-VH för blått.</p>",
		surfaceParametersName: "Ytparametrar",
		surfaceParametersSnip: "Bestämmer parametrar för ett ytraster, till exempel lutningsriktning, lutning och flera typer av kurvatur med geodetiska metoder.",
		surfaceParametersDesc: "<p>Funktionen Ytparametrar bestämmer parametrar för ett ytraster, till exempel lutningsriktning, lutning och flera typer av kurvatur med geodetiska metoder.</p><p>Denna funktion kan användas för följande applikationer:</p><ul><li>Beräkna lutningsriktning och lutning med geodetiska metoder.</li><li>Beräkna olika typer av kurvaturer från ett indataraster, till exempel <strong>Tangentialkurvatur (normal kontur)</strong> som karaktäriserar flödets topografiska konvergens och divergens över ytan.</li></ul>",
		leastCostCorridorName: "Billigaste korridor",
		leastCostCorridorSnip: "Beräknar summan av två ackumulerade raster för avståndskostnad med alternativet att tillämpa en tröskel baserat på procentsats eller ackumulerad kostnad.",
		leastCostCorridorDesc: "<p>Indatarastren ska vara avståndsackumulering och utdata för tillbakariktningsraster från funktionen <strong>Avståndsackumulering</strong> eller <strong>Avståndsallokering</strong>. Dessa ska baseras på kostnadsavstånd och samma parameterinställningar ska användas när lager skapas för varje källa. Inga parametrar som beror på inriktning (horisontalfaktor, vertikalfaktor och reseriktning) ska användas när dessa raster skapas.</p><p>Värdena i utdatarastret för korridoren är summan av den ackumulerade kostnaden för att nå en angiven plats med samma enheter som indatarastren för ackumulerad avståndskostnad.</p><p>Om ett angivet<strong>Tröskel</strong>-värde är större än maximal ackumulerad kostnad när de två rastren för avståndsackumulering summeras, kommer utdatarastret för korridoren att täcka samma område som rastren med ackumulerade indata.</p><p>Om ett angivet tröskelvärde är mindre än det minsta värdet i korridorrastret returneras ett varningsmeddelande och utdatarastret är tomt.</p><p>Utdatarastret för korridoren kan innehålla celler med något större ackumulerade kostnader än tröskelvärdet. Det beror på att rastren för tillbakariktning använder celler som är tilldelade något högre kostnader än tröskeln för att koppla frånkopplade celler till korridoren.</p>",
		geometricMedianName: "Geometrisk median",
		geometricMedianSnip: "Funktionen Geometrisk median beräknar den geometriska medianen för pixlar i en tidsserie av multibandsbilder.",
		geometricMedianDesc: "<p>Den här funktionen minskar brus och avvikelser i tidsseriebilder genom att beräkna den geometriska medianpixeln för varje pixelvektor i bildstacken. Algoritmen behåller de spektrala relationerna mellan band i pixelspektrumet, så att utdata kan användas i analys, som vegetationsindex.</p><p>Moln och skuggor bör maskeras med hjälp av datasetets QA-band innan den här funktionen tillämpas.</p><p>Om indatabilden är flyttal, som ytreflektans med värden mellan 0 och 1, bör ett epsilonvärde på 0,001 leda till kvalitetsresultat.</p>"
	},
	rfxArgs: {
		rasterName: "Raster",
		colorSchemeTypeName: "Typ av färgschema",
		colormapName: "Färgschema",
		colormapNameName: "Namn på färgschema",
		colorRampName: "Färgramp",
		contrastOffsetName: "Kontrastförskjutning",
		brightnessOffsetName: "Ljusstyrkeförskjutning",
		methodName: "Metod",
		bandNamesName: "Bandnamn",
		bandWavelengthsName: "Bandvåglängder",
		bandIdsName: "Bandidentifierare",
		missingBandActionName: "Saknad bandåtgärd",
		conversionParametersName: "Konverteringsparametrar",
		hillshadeTypeName: "Terrängskuggningstyp",
		azimuthName: "Azimut",
		altitudeName: "Höjd",
		slopeTypeName: "Skalning",
		zFactorName: "Z-faktor",
		PSPowerName: "Pixelstorlekspotens",
		PSZFactorName: "Pixelstorleksfaktor",
		removeEdgeEffectName: "Inaktivera standardinterpolering av kantpixlar",
		fromUnitName: "Från enhet",
		toUnitName: "Till enhet",
		rasterTypeName: "Typ",
		minName: "Minimum för utdata",
		maxName: "Maximum för utdata",
		minPercentName: "Procentklippning minimum",
		maxPercentName: "Procentklippning maximum",
		numberOfStandardDeviationName: "Antal standardavvikelser",
		sigmoidStrengthLevelName: "Sigmoidstyrkenivå",
		estimateStatsHistogramName: "Beräkna statistik",
		DRAName: "Dynamisk intervalljustering",
		statisticsName: "Statistik",
		histogramsName: "Histogram",
		statisticsHistogramName: "Definiera statistik och histogram",
		computeGammaName: "Autogamma",
		useGammaName: "Använd gamma",
		gammaName: "Gamma",
		inputNamesName: "Namn",
		expressionName: "Uttryck",
		cellsizeTypeName: "Cellstorlekstyp",
		extentTypeName: "Utbredningstyp",
		classifierDefinitionFileName: "Indatadefinitionsfil",
		raster1Name: "Raster1",
		raster2Name: "Raster2",
		raster3Name: "Raster3",
		trueRasterName: "Sant raster",
		falseRasterName: "Falskt raster",
		noDataInterpretationName: "NoData-tolkning",
		noDataValuesName: "NoData-värden",
		includedRangesName: "Inkluderade intervall",
		curvatureTypeName: "Kurvaturtyp",
		rastersName: "Raster",
		attributeTableName: "Tabell",
		attributeTableTypeName: "Tabelltyp",
		rowsName: "Antal rader",
		columnsName: "Antal kolumner",
		kernelName: "Kärna",
		mirrorEdgesName: "Spegelkanter",
		influencesName: "Inflytanden",
		fieldsName: "Fält",
		remapsName: "Ommappningstabell",
		evalFromName: "Utvärderingsskala från",
		evalToName: "Utvärderingsskala till",
		weightsName: "Vikter",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "IDW-radie med kort avstånd",
		maxVoidWidthName: "Maxbredd för tomrum",
		sigmaGaussianName: "Adaptiv utjämning",
		contourTypeName: "Höjdkurvetyp",
		zBaseName: "Z-bas",
		numberOfContoursName: "Antal höjdkurvor",
		contourIntervalName: "Höjdkurveintervall",
		nthContourLineInBoldName: "N:e höjdkurvelinjen i fetstil",
		featureClassName: "Indatageoobjekt",
		classIndexFieldName: "Fält",
		resolveOverlapMethodName: "Metod för att lösa överlappning",
		resamplingTypeName: "Omsamplingstyp",
		inputCellsizeName: "Indatacellstorlek",
		outputCellsizeName: "Utdatacellstorlek",
		pointFeatureClassName: "Seedpunkter",
		maxGrowthRadiusFieldName: "Fält för max tillväxtradie",
		similarityThresholdFieldName: "Fält för likhetsgränsvärde",
		fillValueFieldName: "Fält för fyllningsvärde",
		spectralDetailName: "Spektral detalj [1..20]",
		spatialDetailName: "Geografisk detalj [1..20]",
		minNumPixelsPerSegmentName: "Minsta segmentstorlek i pixlar",
		boundariesOnlyName: "Endast segmentgränser",
		statisticsTypeName: "Statistiktyp",
		fillNoDataOnlyName: "Fyll endast i NoData-pixlar",
		inputDataTypeName: "Datatyp för indata",
		angleReferenceSystemName: "Vinkelreferenssystem",
		outputDataTypeName: "Datatyp för utdata",
		inputSamplePointFeatureClassName: "Indataprov",
		valueFieldName: "Värdefält",
		rasterInfoName: "Rasterinfo",
		interpolationMethodName: "Interpoleringsmetod",
		radiusName: "Radie",
		radianceGainValuesName: "Strålningsförstärkning",
		radianceBiasValuesName: "Snedvridning av strålning",
		reflectedGainValuesName: "Ökning av reflexionsfaktor",
		reflectedBiasValuesName: "Snedvridning av reflektans",
		sunElevationName: "Solhöjd (grader)",
		albedoName: "Albedo",
		scaleFactorName: "Skalfaktor",
		offsetName: "Förskjutning",
		thresholdTypeName: "Tröskelvärdestyp",
		thresholdsName: "Tröskelvärden",
		undefinedClassName: "Odefinierad klass",
		minValueName: "Min.",
		maxValueName: "Max",
		operationName: "Åtgärd",
		clippingTypeName: "Klippningstyp",
		clippingGeometryName: "Klipper geometri/raster",
		extentName: "Utdatautbredning",
		useInputFeatureGeometryName: "Använd indatageoobjekt för geometriklippning",
		remapDefinitionTypeName: "Ommappningsdefinitionstyp",
		inputRangeName: "Indataintervaller",
		outputValuesName: "Utdatavärden",
		noDataRangeName: "NoData-intervaller",
		inputFieldName: "Indatafält",
		outputFieldName: "Utdatafält",
		inputMaxFieldName: "Indatamaxfält (valfritt)",
		remapTableTypeName: "Ommappningstabelltyp",
		allowUnmatchedName: "Tillåt omatchade pixelvärden",
		changeMissingValuesToNoDataName: "Ändra saknade värden till NoData",
		visibleBandIDName: "ID för synligt band",
		infraredBandIDName: "ID för infrarött band",
		scientificOutputName: "Avancerade utdata",
		bandIndexesName: "Bandindex",
		constantName: "Konstant",
		weightName: "Vikt",
		minimumName: "Minimum",
		maximumName: "Maximalt",
		sourceDataName: "Källraster",
		sourceFieldName: "Källfält",
		costRasterName: "Kostnadsraster",
		maxDistanceName: "Maximalt avstånd",
		valueRasterName: "Värderaster",
		costMultiplierName: "Multiplikator att använda på kostnader",
		startCostName: "Startkostnad",
		accumCostResistanceRateName: "Ackumulerad nivå av motståndskostnad",
		capacityName: "Kapacitet",
		travelDirectionName: "Reseriktning",
		cellSizeName: "Cellstorlek",
		populationFieldName: "Befolkningsfält",
		areaUnitsName: "Areaenheter",
		outputValueTypeName: "Utdatacellvärden",
		barriersName: "Indatahinder",
		destinationDataName: "Destinationsraster",
		destinationFieldName: "Destinationsfält",
		pathTypeName: "Vägtyp",
		observerFeaturesName: "Observatörsgeoobjekt",
		analysisMethodName: "Analysmetod",
		analysisTypeName: "Analystyp",
		verticalErrorName: "Vertikalt fel",
		refractivityCoefficientName: "Refraktivitetskoefficient",
		surfaceOffsetName: "Ytförskjutning",
		observerElevationName: "Observatörshöjd",
		observerOffsetName: "Observatörsförskjutning",
		innerRadiusName: "Inre radie",
		innerRadiusIs3DDistanceName: "Innerradien är 3D-avståndet",
		outerRadiusName: "Yttre radie",
		outerRadiusIs3DDistanceName: "Ytterradien är 3D-avståndet",
		horizontalStartAngleName: "Horisontell startvinkel",
		horizontalEndAngleName: "Horisontell slutvinkel",
		verticalUpperAngleName: "Vertikal övre vinkel",
		verticalLowerAngleName: "Vertikal nedre vinkel",
		zoneDataName: "Zonraster",
		zoneFieldName: "Zonfält",
		ignoreNoDataName: "Ignorera NoData i beräkningar",
		temperatureRasterName: "Temperaturraster",
		inTemperatureUnitsName: "Temperaturenheter",
		outHeatIndexTemperatureUnitsName: "Värmeindexenheter",
		relativeHumidityRasterName: "Raster för relativ luftfuktighet",
		outWindChillTemperatureUnitsName: "Vindavkylningsenheter",
		windSpeedRasterName: "Vindhastighetsraster",
		inWindSpeedUnitsName: "Vindhastighetsenheter",
		valueName: "Värde",
		propertyName: "Egenskapsnamn",
		jsonName: "Metadata-JSON",
		zoneTableName: "Zonbaserad attributtabell",
		attributeFieldNames: "Attributfältnamn",
		backgroundName: "Bakgrundsvärde",
		whereClauseName: "Where-sats",
		minimumValueFieldName: "Fältnamn för minimivärde",
		maximumValueFieldName: "Fältnamn för maximivärde",
		outValueFieldName: "Fältnamn för utdatavärde",
		defaultValueName: "Standardutdatavärde",
		conversionMatrixName: "Konverteringsmatris",
		IsPseudoColorOutputName: "Är en pseudofärgutskrift",
		unmappedAsRandomColorName: "Tilldela färg slumpvis till ofyllda pixlar",
		distanceMethodName: "Avståndsmetod",
		flowDirRasterName: "Flödesriktningsraster",
		pourPointName: "Hällpunktsraster",
		pourPointFieldName: "Hällpunktsfält",
		constantZName: "Konstant Z",
		zOffsetName: "Z-offset",
		geoIdName: "Geoid",
		calibrationTypeName: "Kalibreringstyp",
		filterTypeName: "Filtertyp",
		filterSizeName: "Filterstorlek",
		noiseModelName: "Brusmodell",
		noiseVarianceName: "Brusvarians",
		additiveNoiseMeanName: "Additivt brusmedel",
		multiplicativeNoiseMeanName: "Multiplikativt brusmedel",
		numberofLooksName: "Antal granskningar",
		dampingFactorName: "Dämpningsfaktor",
		maskRasterName: "Maskraster",
		nibbleValuesName: "Använd NoData-värden om de är den närmaste grannen",
		nibbleNoDataName: "Nagga NoData-celler",
		zLimitName: "Z-begränsning",
		flowDirectionTypeName: "Flödesriktningstyp",
		weightRasterName: "Viktraster",
		forceEdgeName: "Tvinga alla kantceller att flöda utåt",
		streamRasterName: "Strömningsraster",
		surfaceRasterName: "Ytraster",
		conversionType: "Konverteringstyp",
		distanceRaster1: "Avståndsraster 1",
		distanceRaster2: "Avståndsraster 2",
		costDistanceRaster: "Raster för avståndskostnad",
		costBacklinkRaster: "Raster för bakåtlänkskostnad",
		overridesName: "Åsidosätter",
		fieldName: "Fält",
		signatureFileOrUrl: "Signaturfil eller URL",
		redName: "Rött",
		greenName: "Grönt",
		blueName: "Blått",
		infraredName: "Infrarött",
		panchromaticName: "Pankromatisk",
		multispectralName: "Multispektral",
		pansharpeningType: "Typ av panoreringsskärpning",
		sensorName: "Sensor",
		spatialReferenceName: "Geografisk referens",
		xCellsizeName: "X-cellstorlek",
		yCellsizeName: "Y-cellstorlek",
		xOriginName: "X-registreringspunkt",
		yOriginName: "Y-registreringspunkt",
		percentileName: "Percentilvärde",
		neighborhoodType: "Grannskapstyp",
		widthName: "Bredd",
		heightName: "Höjd över marken",
		startAngleName: "Startvinkel",
		endAngleName: "Slutvinkel",
		neighborhoodValues: "Grannskapsvärden",
		horizontalRaster: "Horisontellt raster",
		horizontalFactor: "Horisontalfaktor",
		verticalRaster: "Vertikalt raster",
		verticalFactor: "Vertikalfaktor",
		streamRaster: "Strömningsraster",
		flowDirRaster: "Flödesriktningsraster",
		numberNeighborCells: "Antal grannceller",
		zoneConnectivity: "Zonanslutning",
		addLinkBehavior: "Lägg till länk",
		excludedValue: "Uteslutet värde",
		constantFillCheck: "Generera fyllningsraster från konstant",
		fillRaster: "Fyllningsraster",
		constantFillValue: "Konstant värde",
		inputBitPositions: "Indatabit",
		outputBitPositions: "Utdatabit",
		distanceTypeName: "Avståndstyp",
		barrierDataName: "Rasterhinder",
		pourPointDataName: "Hällpunktsraster",
		accumulationRasterName: "Flödesackumuleringsraster",
		snapDistanceName: "Snappningsavstånd",
		orderMethodName: "Ordningsmetod",
		directionMeasurementName: "Mätningens riktning",
		processAsMultiband: "Bearbeta som multiband",
		processMultidimensional: "Bearbeta flerdimensionellt",
		forceFlowDirectionConvention: "Tvinga fram flödesriktningskonvention för bakåtlänkraster",
		initialAccumulation: "Inledande ackumulering",
		maximumAccumulation: "Maximal ackumulering",
		sourceLocationBands: "Generera källrad och kolumn som ytterligare band i utdata",
		backDirectionBand: "Generera tillbakariktning som extra band i utdata",
		numberOfCells: "Antal celler",
		zoneValues: "Zonvärden",
		shrinkMethod: "Krympmetod",
		expandMethod: "Expanderingsmetod",
		inputSpectralProfileType: "Spektral profiltyp",
		spectralProfileFileName: "Spektral profil",
		trainingFeatureFileName: "Träningsgeoobjekt",
		nonNegative: "Icke-negativt",
		sumToOne: "Summa till en",
		randomDistribution: "Distribution",
		meanName: "Medelvärde",
		probabilityName: "sannolikhet",
		alphaName: "Alfa",
		betaName: "Betaversion",
		rName: "r",
		nName: "N",
		seed: "Seed",
		randomNumberGenerator: "Slumptalsgenerator",
		cellFactor: "Cellfaktor",
		aggregationType: "Aggregeringsteknik",
		extentHandling: "Utöka utbredningen vid behov",
		trendAnalysisDimensionName: "Dimensionsnamn",
		trendAnalysisType: "Trendtyp",
		harmonicFrequency: "Harmonisk frekvens",
		polynomialOrder: "Polynomordning",
		cycleLengthName: "Cykellängd",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R-kvadrat",
		trendAnalysisSlopePValue: "P-värde för lutningskoefficient",
		trendAnalysisSeasonalPeriod: "Årstidsperiod",
		cycleUnitName: "Cykelenhet",
		predictDimensionValues: "Värden",
		dimensionDefinitionType: "Dimensionsdefinition",
		predictDimensionStart: "Start",
		predictDimensionEnd: "Stopp",
		predictDimensionInterval: "Värdeintervall",
		dimensionUnit: "Enhet",
		interpolationCellsizeName: "Interpolationscellstorlek",
		variableName: "Variabler",
		dimensionlessName: "Utan mått",
		mdimDefinition: "Dimensionsdefinition",
		dimensionName: "Mått",
		iterationStart: "Början av första iterationen",
		iterationEnd: "Slutet av första iterationen",
		intervalStart: "Start på intervall",
		intervalEnd: "Slut på intervall",
		stepName: "Steg",
		rangesName: "Intervall",
		minValue: "Minsta värde",
		maxValue: "Maximalt värde",
		changeAnalysisRasterName: "Ändra analysraster",
		changeTypeName: "Ändra typ",
		segmentDate: "Segmentdatum",
		changeDirectionName: "Ändra riktning",
		maxNumChangesName: "Maximalt antal förändringar",
		filterByYear: "Filtrera efter år",
		minimumYear: "Minsta värde",
		maximumYear: "Maximalt värde",
		filterByDuration: "Filtrera efter varaktighet",
		minimumDuration: "Lägsta varaktighet",
		maximumDuration: "Maximal varaktighet",
		filterByMagnitude: "Filtrera efter magnitud",
		minimumMagnitude: "Lägsta magnitud",
		maximumMagnitude: "Maximal magnitud",
		filterByStartValue: "Filtrera efter startvärde",
		minimumStartValue: "Minimalt startvärde",
		maximumStartValue: "Maximalt startvärde",
		filterByEndValue: "Filtrera efter slutvärde",
		minimumEndValue: "Minimalt slutvärde",
		maximumEndValue: "Maximalt slutvärde",
		modelTypeName: "Modelltyp",
		fromRasterName: "Från raster",
		toRasterName: "Till raster",
		computeChangeMethod: "Metod för Beräkna förändring",
		fromClassValues: "Från klassvärden (exempel: 2 5)",
		toClassValues: "Till klassvärden (exempel: 2 5)",
		keepMethod: "Filtermetod",
		useColorMethod: "Definiera övergångsfärger",
		detectChangeBands: "Band för att identifiera ändring (med början från 0)",
		tmaskBands: "Band för tidsbestämd maskning (med början från 0)",
		chiSquaredThreshold: "Chikvadrattröskel för Identifiera förändringar",
		minAnomaly: "Lägsta antal sammanhängande anomaliobservationer",
		updatingFrequency: "Frekvens för updateringsinpassning (i år)",
		distanceAccumulationRasterName: "Avståndsackumuleringsraster",
		costBackdirectionRasterName: "Tillbakariktnings- eller flödesriktningsraster",
		rasterCollectionName: "Rastersamling",
		itemFunctionName: "Objektfunktion",
		aggregationFunctionName: "Aggregeringsfunktion",
		processingFunctionName: "Bearbetar funktion",
		aggregationDefinitionName: "Aggregeringsdefinition",
		queryGeometryName: "Frågegeometri",
		factorFunctionZeroFactor: "Nollfaktor",
		factorFunctionCutAngle: "Klippvinkel",
		factorFunctionSideFactor: "Sidofaktor",
		factorFunctionSlope: "Lutning",
		factorFunctionLowCutAngle: "Låg klippvinkel",
		factorFunctionHighCutAngle: "Hög klippvinkel",
		factorFunctionCosPower: "Cosinus-faktor",
		factorFunctionSecPower: "Sekant-faktor",
		factorFunctionTablePath: "Tabellsökväg",
		processingBand: "Bearbetar band",
		processingBandName: "Bearbetar bandnamn",
		snappingDate: "Snappningsdatum",
		maxNumSegments: "Maximalt antal segment",
		vertexCountOvershoot: "Översläng för antalet brytpunkter",
		spikeThreshold: "Tröskelvärde för avvikelser",
		recoveryThreshold: "Tröskelvärde för återhämtning",
		minNumObs: "Lägsta antal observationer",
		pValueThreshold: "Tröskelvärde för P-värde",
		bestModelProportion: "Bästa modellproportion",
		preventOneYearRecovery: "Förhindra ett års återställning",
		recoveryIncreaseTrend: "Återställningen har en ökande trend",
		outputOtherBands: "Mata ut andra band",
		sortType: "Sorteringstyp",
		numberOfRuns: "Kör expansion och krympning två gånger",
		percentileValue: "Percentilvärde",
		percentileInterpolationType: "Interpoleringstyp för percentil",
		rasterInfoProperty: "Egenskap",
		rasterInfoValue: "Värde",
		rasterInfoColumns: "Kolumner",
		rasterInfoRows: "Rader",
		rasterInfoBandCount: "Antal band",
		rasterInfoPixelSizeX: "Cellstorlek X",
		rasterInfoPixelSizeY: "Cellstorlek Y",
		rasterInfoPixelType: "Pixeltyp",
		rasterExtentTop: "Övre",
		rasterExtentBottom: "Längst ned",
		rasterExtentLeft: "Vänster",
		rasterExtentRight: "Höger",
		rasterStatisticsNotCalculated: "Statistiken har inte beräknats.",
		spatialReferenceProjection: "Projektion",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "Föregående WKID",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "Föregående VCSWKID",
		spatialReferenceAuthority: "Utfärdare",
		spatialReferenceLinearUnit: "Linjär enhet",
		spatialReferenceAngularUnit: "Vinkelenhet",
		spatialReferenceFalseEasting: "Falsk ostlig kurs",
		spatialReferenceFalseNorthing: "Falsk nordlig kurs",
		spatialReferenceCentralMeridian: "Centralmeredian",
		spatialReferencePrimeMeridian: "Nollmeridian",
		spatialReferenceStandardParallel1: "Standardparallell 1",
		spatialReferenceStandardParallel2: "Standardparallell 2",
		spatialReferenceLatitudeOfOrigin: "Ursprungslatitud",
		spatialReferenceAuxiliarySphereType: "Typ av tilläggssfär",
		spatialReferenceDatum: "Datum",
		spatialReferenceSpheroid: "Rotationsellipsoid",
		spatialReferenceSemimajorAxis: "Halv storaxel",
		spatialReferenceSemiminorAxis: "Halv lillaxel",
		spatialReferenceInverseFlattening: "Inverterad avplattning",
		inputDefinitionFileName: "Indatadefinitionsfil",
		deleteName: "Ta bort",
		addVariableName: "Lägg till variabel",
		maxNumPixelsPerSegment: "Maximal segmentstorlek i pixlar",
		forwardWindowName: "Fönster framåt",
		backwardWindowName: "Fönster bakåt",
		noDataHandlingName: "NoData-hantering",
		circularWrapValueName: "Cirkulärt radbrytningsvärde",
		fromClassNameFieldName: "Fältnamn för klassnamn i Från raster",
		toClassNameFieldName: "Fältnamn för klassnamn i Till raster",
		targetRasterName: "Målraster",
		circularWrapValue: "Cirkulärt radbrytningsvärde",
		bandIndexesR: "Rött uttryck",
		bandIndexesG: "Grönt uttryck",
		bandIndexesB: "Blått uttryck",
		exampleName: "Exempel",
		inputName: "Indata",
		outputName: "Utdata",
		optionalName: "Valfritt",
		browseDefinitionFile: "Bläddra efter definitionsfil",
		selectDefinitionFile: "Välj indatadefinitionsfil",
		inputDefinitionURL: "Indatadefinitionsfil-URL",
		enterDefinitionFileURL: "Ange destinationsfil-URL",
		browseXMLFile: "Bläddra efter XML-fil",
		selectStatsFile: "Välj statistik- och histogramfil",
		enterXMLFileURL: "Ange XML-fil-URL",
		xmlFileURL: "XML-fil-URL",
		circularCalculation: "Beräkna cirkulär statistik",
		localSurfaceType: "Lokal yttyp",
		surfaceParameterType: "Parametertyp",
		neighborhoodDistance: "Avstånd närområde",
		useAdaptiveNeighborhood: "Använd adaptivt närområde",
		outputSlopeType: "Utdatalutningsmätning",
		projectAzimuths: "Geodetiska azimuter för projekt",
		useEquatorialAspect: "Använd ekvatoriell aspekt",
		zUnit: "Z-enhet",
		analysisMask: "Analysmask",
		stdDeviation: "Standardavvikelse",
		"true": "Sant",
		"false": "Falskt",
		costDistanceRaster1: "Indataraster för ackumulerad avståndskostnad 1",
		costDistanceRaster2: "Indataraster för ackumulerad avståndskostnad 2",
		threshold: "Tröskel",
		thresholdMethod: "Tröskelmetod",
		directionRaster1: "Indatatillbakafördelningsraster 1",
		directionRaster2: "Indatatillbakafördelningsraster 2",
		maxIterations: "Maximalt antal upprepningar",
		epsilon: "Epsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manuell",
		attributeTableTypeExternal: "Extern",
		clrSchemeTypeColormap: "Färgschema",
		clrSchemeTypeColorRamp: "Färgramp",
		colormapTypeElevation: "Höjd över havet",
		colormapTypeGray: "Grå",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Slumpmässig",
		none: "Inga",
		slopeTypeAdjusted: "Justerad",
		slopeTypeDegree: "Grad",
		slopeTypePercentRise: "Procentökning",
		slopeTypeScaled: "Skalad",
		stretchTypeMinMax: "MinMax",
		stretchTypePercentMinMax: "PercentMinMax",
		stretchTypeSigmoid: "Sigmoid",
		stretchTypeStdDev: "StdDev",
		hillshadeTypeSimple: "Traditionell",
		hillshadeTypeMultidirectional: "Flerriktad",
		bandComboByNames: "Bandnamn",
		bandComboByWavelength: "Bandvåglängder",
		bandComboByIDs: "Bandidentifierare",
		missingBandActionBestMatch: "Bästa matchning",
		missingBandActionFail: "Misslyckad",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Centimeter",
		unitTypeDecimeters: "Decimeter",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Fot",
		unitTypeFeetPerSec: "Fot per sekund (ft/s)",
		unitTypeInches: "Tum",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Kilometer",
		unitTypeKmsPerHour: "Kilometer i timmen (km/h)",
		unitTypeKnots: "Knop (kn)",
		unitTypeMeters: "Meter",
		unitTypeMetersPerSec: "Meter per sekund (m/s)",
		unitTypeMiles: "Mile",
		unitTypeMilesPerHour: "Miles i timmen (mph)",
		unitTypeMillimeters: "Millimetrar",
		unitTypeNauticalMiles: "Nautiska mil",
		unitTypeYards: "Yard",
		unitTypeDecimalDegrees: "Decimalgrader",
		unitTypePoints: "Punkter",
		unitTypeUnknown: "Okänt",
		unitTypeSqMapUnits: "Kartans kvadratenheter",
		unitTypeSqMiles: "Kvadratmil (engelska)",
		unitTypeSqKms: "Kvadratkilometer",
		unitTypeAcres: "Tunnland",
		unitTypeHectares: "Hektar",
		unitTypeSqYards: "Square Yards",
		unitTypeSqFt: "Kvadratfot",
		unitTypeSqInches: "Kvadrattum",
		unitTypeSqMts: "Kvadratmeter",
		unitTypeSqCms: "Kvadratcentimeter",
		unitTypeSqMms: "Kvadratmillimeter",
		cellsizeTypeFirst: "Första av",
		cellsizeTypeMin: "Min av",
		cellsizeTypeMax: "Max av",
		cellsizeTypeMean: "Medelvärde av",
		cellsizeTypeLast: "Sista av",
		extentTypeFirst: "Första av",
		extentTypeIntersection: "Skärning av",
		extentTypeUnion: "Union av",
		extentTypeLast: "Sista av",
		noDataInterpretAny: "Matcha något",
		noDataInterpretAll: "Matcha alla",
		curvatureTypeStandard: "Standard",
		curvatureTypeProfile: "Profil",
		curvatureTypePlanform: "Planform",
		filterTypeLineDetectionHorizontal: "Linjeidentifiering horisontell",
		filterTypeLineDetectionVertical: "Linjeidentifiering vertikal",
		filterTypeLineDetectionLeftDiagonal: "Linjeidentifiering vänster diagonal",
		filterTypeLineDetectionRightDiagonal: "Linjeidentifiering höger diagonal",
		filterTypeGradientNorth: "Toning nord",
		filterTypeGradientWest: "Toning väst",
		filterTypeGradientEast: "Toning ost",
		filterTypeGradientSouth: "Toning syd",
		filterTypeGradientNorthEast: "Toning nordost",
		filterTypeGradientNorthWest: "Toning nordväst",
		filterTypeSmoothArithmeticMean: "Jämnt aritmetiskt medelvärde",
		filterTypeSmoothing3x3: "Utjämning 3x3",
		filterTypeSmoothing5x5: "Utjämning 5x5",
		filterTypeSharpening3x3: "Skärpning 3x3",
		filterTypeSharpening5x5: "Skärpning 5x5",
		filterTypeLaplacian3x3: "Laplace 3x3",
		filterTypeLaplacian5x5: "Laplace 5x5",
		filterTypeSobelHorizontal: "Sobel horisontell",
		filterTypeSobelVertical: "Sobel vertikal",
		filterTypeSharpen: "Gör skarpare",
		filterTypeSharpen2: "Skärp mer",
		filterTypePointSpread: "Punktspridning",
		userDefined: "Användardefinierad",
		ContourTypeLines: "Höjdkurvelinjer",
		ContourTypeFill: "Höjdkurvefyllning",
		ContourTypeSmoothOnly: "Endast jämn yta",
		rasterizeFirst: "Första",
		rasterizeLast: "Sista",
		rasterizeSmallest: "Minsta",
		rasterizeLargest: "Största",
		resamplingTypeNearest: "Närmsta granne",
		resamplingTypeBilinear: "Bilinjär interpolering",
		resamplingTypeCubic: "Kubisk interpolation",
		resamplingTypeMajority: "Majoritet",
		resamplingTypeBilinearPlus: "Bilinjär interpolering plus",
		resamplingTypeGauss: "Gaussisk oskärpa",
		resamplingTypeGaussPlus: "Gaussisk oskärpa plus",
		resamplingTypeAverage: "Genomsnitt",
		resamplingTypeMinimum: "Minimum",
		resamplingTypeMaximum: "Maximalt",
		resamplingTypeVectorAvg: "Vektorgenomsnitt",
		minimum: "Minimum",
		maximum: "Maximalt",
		mean: "Medelvärde",
		stdDeviation: "Standardavvikelse",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Magnitud-riktning",
		unknown: "Okänt",
		angleRefSysGeographic: "Geografiska",
		angleRefSysArithmetic: "Aritmetiskt",
		interpolateIrregularDataNearest: "Närmsta granne",
		interpolateIrregularDataBilinear: "Bilinjär",
		interpolateIrregularDataTinningLinear: "Linjär tinning",
		interpolateIrregularDataTinningNaturalNeighbor: "Naturlig granne",
		interpolateIrregularDataTinningIDW: "Inverterat viktat avstånd",
		esriRasterThresholdTypeConstant: "Konstant",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "Arg max",
		argStatsTypeMin: "Arg min",
		argStatsTypeMedian: "Arg median",
		argStatsTypeDuration: "Varaktighet",
		arithmeticOpPlus: "Plus",
		arithmeticOpMinus: "Minus",
		arithmeticOpMultiply: "Multiplicera",
		arithmeticOpDivide: "Fördela",
		arithmeticOpPower: "Potens",
		arithmeticOpMode: "Läge",
		clipTypeOutside: "Klipp utanför",
		clipTypeInside: "Klipp innanför",
		yes: "Ja",
		no: "Nej",
		densities: "Densiteter",
		expectedCounts: "Förväntade antal",
		planar: "Plan",
		geodesic: "Geodetisk",
		eachCell: "Varje cell",
		eachZone: "Varje zon",
		bestSingle: "Bästa enskilda",
		allSightlines: "Alla siktlinjer",
		perimeterSightlines: "Siktlinjer för omkrets",
		frequency: "Frekvens",
		observers: "Observatörer",
		majority: "Majoritet",
		median: "Median",
		minority: "Minoritet",
		percentile: "Percentil",
		range: "Intervall",
		sum: "Summa",
		variety: "Variation",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "Transformerad SAVI",
		bandArithmeticMethodMSAVI: "Modifierad SAVI",
		bandArithmeticMethodSultan: "Sultans formel",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVIcore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Järnoxid",
		ferrousMinerals: "Järnhaltiga mineraler",
		clayMinerals: "Lermineraler",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Kvadratrot",
		localACos: "ACos",
		localASin: "ASin",
		localATan: "ATan",
		localATanH: "ATanH",
		localAbs: "Abs",
		localBitwiseNot: "Bitvist Not",
		localBooleanNot: "Booleskt Not",
		localCos: "Cos",
		localCosH: "CosH",
		localExp: "Går ut",
		localExp10: "Exp10",
		localExp2: "Exp2",
		localInt: "Int",
		localIsNull: "Är noll",
		localFloat: "Flytande",
		localLn: "Ln",
		localLog10: "Log10",
		localLog2: "Log2",
		localNegate: "Negera",
		localRoundDown: "Avrunda nedåt",
		localRoundUp: "Avrunda uppåt",
		localSin: "Sin",
		localSinH: "SinH",
		localTan: "Tan",
		localTanH: "TanH",
		localACosH: "ACosH",
		localASinH: "ASinH",
		localPlus: "Plus",
		localMinus: "Minus",
		localTimes: "Gånger",
		localPower: "Potens",
		localBitwiseAnd: "Bitvist And",
		localBitwiseLeftShift: "Bitvist vänsterskift",
		localBitwiseOr: "Bitvist Or",
		localBitwiseRightShift: "Bitvist högerskift",
		localBitwiseXor: "Bitvist Xor",
		localBooleanAnd: "Booleskt And",
		localBooleanOr: "Booleskt Or",
		localBooleanXor: "Booleskt Xor",
		localDivide: "Fördela",
		localEqualTo: "Lika med",
		localGreaterThan: "Större än",
		localGreaterThanEqual: "Större än eller lika med",
		localLessThan: "Mindre än",
		localLessThanEqual: "Mindre än eller lika med",
		localMod: "Mod",
		localNotEqual: "Inte lika med",
		localATan2: "ATan2",
		localSquare: "Fyrkant",
		localSetNull: "Sätt noll",
		remapDefTypeList: "Lista",
		remapDefTypeTable: "Tabell",
		remapTableTypeSimple: "Enkel",
		remapTableTypeDynamic: "Dynamisk",
		remapTableTypeReassignment: "Omtilldelning",
		geomCorrectionByConstZ: "Använd konstant Z",
		geomCorrectionByDEM: "Använd DEM",
		radarCalibBetaNought: "Beta-noll",
		radarCalibSigmaNought: "Sigma-noll",
		radarCalibGammaNought: "Gamma-noll",
		speckleFilterTypeLee: "Lee-filter",
		speckleFilterTypeEnhancedLee: "Förstärkt Lee-filter",
		speckleFilterTypeFrost: "Frostfilter",
		speckleFilterTypeKuan: "Kuan-filter",
		speckleNoiseModelMul: "Multiplikativt brus",
		speckleNoiseModelAdd: "Additivt brus",
		speckleNoiseModelAddnMul: "Additivt och multiplikativt brus",
		mosaicOpTypeFirst: "Första",
		mosaicOpTypeLast: "Sista",
		mosaicOpTypeMin: "Min.",
		mosaicOpTypeMax: "Max",
		mosaicOpTypeMean: "Medelvärde",
		mosaicOpTypeBlend: "Blandning",
		mosaicOpTypeSum: "Summa",
		integer: "Heltal",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Vertikal",
		horizontal: "Horisontell",
		localCellStatisticsMajority: "Majoritet",
		localCellStatisticsMax: "Maximalt",
		localCellStatisticsMean: "Medelvärde",
		localCellStatisticsMedian: "Median",
		localCellStatisticsMin: "Minimum",
		localCellStatisticsMinority: "Minoritet",
		localCellStatisticsRange: "Intervall",
		localCellStatisticsStdDev: "Standardavvikelse",
		localCellStatisticsSum: "Summa",
		localCellStatisticsVariety: "Variation",
		localCellStatisticsMajorityIgnoreND: "Majoritet (ignorera NoData)",
		localCellStatisticsMaxIgnoreND: "Maximum (ignorera NoData)",
		localCellStatisticsMeanIgnoreND: "Medel (ignorera NoData)",
		localCellStatisticsMedianIgnoreND: "Median (ignorera NoData)",
		localCellStatisticsMinIgnoreND: "Minimum (ignorera NoData)",
		localCellStatisticsMinorityIgnoreND: "Minoritet (ignorera NoData)",
		localCellStatisticsRangeIgnoreND: "Intervall (ignorera NoData)",
		localCellStatisticsStdDevIgnoreND: "Standardavvikelse (ignorera NoData)",
		localCellStatisticsSumIgnoreND: "Summa (ignorera NoData)",
		localCellStatisticsVarietyIgnoreND: "Variation (ignorera NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Percentil (ignorera NoData)",
		fromSource: "Från källa",
		toSource: "Till källa",
		colorspaceConversionRgbToHsv: "RGB till HSV",
		colorspaceConversionHsvToRgb: "HSV till RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Medelvärde",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Rektangel",
		circleNeighborhood: "Cirkel",
		annulusNeighborhood: "Ring",
		wedgeNeighborhood: "Kil",
		irregularNeighborhood: "Oregelbunden",
		weightNeighborhood: "Vikt",
		four: "Fyra",
		eight: "Åtta",
		within: "Inom",
		cross: "Kors",
		addLink: "Lägg till länk",
		noLink: "Ingen länk",
		weightedMean: "Viktat medelvärde",
		ls8QCBitPatternCirrus: "Landsat 8 – cirrus",
		ls8QCBitPatternCloud: "Landsat 8 – moln",
		ls8QCBitPatternCloudShadow: "Landsat 8 – molnskugga",
		ls8QCBitPatternDesignatedFill: "Landsat 8 – avsedd fyllning",
		ls8QCBitPatternDroppedFrame: "Landsat 8 – utelämnad ram",
		ls8QCBitPatternSnowIce: "Landsat 8 – snö/is",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 – terrängocklusion",
		ls8QCBitPatternVegetation: "Landsat 8 – växtlighet",
		ls8QCBitPatternWater: "Landsat 8 – vatten",
		downStream: "Nedströms",
		upStream: "Uppströms",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Aktuell sektor",
		allSlices: "Alla sektorer",
		expandDistance: "AVSTÅND",
		expandMorphological: "MORFOLOGISKT",
		spectralProfileFile: "Spektral profil",
		trainingFeatureFile: "Träningsgeoobjekt",
		randomDistributionTypeUniform: "Enhetlig",
		randomDistributionTypeUniformInteger: "Heltal",
		randomDistributionTypeNormal: "Normal",
		randomDistributionTypeExponential: "Exponentiell",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gamma",
		randomDistributionTypeBinomial: "Binomial",
		randomDistributionTypeGeometric: "Geometriskt",
		randomDistributionTypeNegativeBinomial: "Negativ binomial",
		randomGeneratorTypeStandardCRand: "Standard C Rand",
		randomGeneratorTypeAlgorithmACM599: "ACM samlad algoritm 599",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Summa",
		medainName: "Median",
		trendLinear: "Linjär",
		trendHarmonic: "Harmonisk",
		trendPolynomial: "Polynom",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Säsongsberoende Kendall",
		dimensionByValue: "Efter värde",
		dimensionByInterval: "Efter intervall",
		mdimDefTypeAll: "Alla",
		mdimDefTypeByValues: "Efter värden",
		mdimDefTypeByRanges: "Efter intervall",
		mdimDefTypeByIteration: "Efter iteration",
		mdimDefTypeByInterval: "Efter intervall",
		mdimDefTypeByTargetRaster: "Efter målraster",
		esriTimeUnitsHours: "Timmar",
		esriTimeUnitsDays: "Dagar",
		esriTimeUnitsWeeks: "Veckor",
		esriTimeUnitsMonths: "Månader",
		esriTimeUnitsYears: "År",
		esriTimeIntervalKeywordHourly: "Varje timma",
		esriTimeIntervalKeywordDaily: "Dagligen",
		esriTimeIntervalKeywordWeekly: "Veckovis",
		esriTimeIntervalKeywordDekadly: "Vart tionde år",
		esriTimeIntervalKeywordPentadly: "Vart femte år",
		esriTimeIntervalKeywordMonthly: "Månadsvis",
		esriTimeIntervalKeywordQuarterly: "Varje kvartal",
		esriTimeIntervalKeywordYearly: "Årligen",
		esriTimeIntervalKeywordRecurringDaily: "Återkommer dagligen",
		esriTimeIntervalKeywordRecurringWeekly: "Återkommer veckovis",
		esriTimeIntervalKeywordRecurringMonthly: "Återkommer månadsvis",
		esriTimeIntervalKeywordRecurringQuarterly: "Återkommer kvartalsvis",
		aggDefTypeAll: "Alla",
		aggDefTypeIntervalKeyword: "Intervallnyckelord",
		aggDefTypeIntervalValue: "Intervallvärde",
		aggDefTypeIntervalRanges: "Intervallområden",
		latestChange: "Tid för senaste förändring",
		earliestChange: "Tid för tidigaste förändring",
		largestChange: "Tid för största förändring",
		numberOfChanges: "Antal förändringar",
		longestChange: "Tidpunkt för längsta ändring",
		shortestChange: "Tidpunkt för kortaste ändring",
		fastestChange: "Tidpunkt för snabbaste ändring",
		slowestChange: "Tidpunkt för långsammaste ändring",
		allChanges: "Alla",
		increaseChanges: "Öka",
		decreaseChanges: "Minska",
		segmentBeginning: "Början på segmentet",
		segmentEnd: "Slut på segmentet",
		esriComputeChangeMethodDifference: "Skillnad",
		esriComputeChangeMethodRelativeDifference: "Relativ skillnad",
		esriComputeChangeMethodCategorical: "Kategorisk skillnad",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Spektralt euklidiskt avstånd",
		esriComputeChangeMethodMultispectralAngularDifference: "Spektral vinkelskillnad",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Band med störst förändring",
		esriComputeChangeKeepAll: "Behåll samtliga",
		esriComputeChangeKeepChangedOnly: "Behåll endast ändrade pixlar",
		esriComputeChangeKeepUnchangedOnly: "Behåll endast oförändrade pixlar",
		esriComputeChangeUseColorAverage: "Genomsnittliga från- och till-färger",
		esriComputeChangeUseColorFrom: "Använd från-färger",
		esriComputeChangeUseColorTo: "Använd till-färger",
		factorFunctionBinary: "Binär",
		factorFunctionForward: "Framåt",
		factorFunctionLinear: "Linjär",
		factorFunctionInvLinear: "Omvänd linjär",
		factorFunctionTable: "Tabell",
		factorFunctionSymLinear: "Symmetrisk linjär",
		factorFunctionSymInvLinear: "Symmetrisk omvänd linjär",
		factorFunctionCos: "Cosinus",
		factorFunctionSec: "Sekant",
		factorFunctionCosSec: "Cosinus sekant",
		factorFunctionSecCos: "Sekant cosinus",
		noSort: "Sortera inte",
		ascend: "Stigande",
		descend: "Fallande",
		autoDetect: "Autoidentifiering",
		nearest: "Närmaste",
		linear: "Linjär",
		esriMonthJanuary: "Januari",
		esriMonthFebruary: "Februari",
		esriMonthMarch: "Mars",
		esriMonthApril: "April",
		esriMonthMay: "Maj",
		esriMonthJune: "Juni",
		esriMonthJuly: "Juli",
		esriMonthAugust: "Augusti",
		esriMonthSeptember: "September",
		esriMonthOctober: "Oktober",
		esriMonthNovember: "November",
		esriMonthDecember: "December",
		dimensionalMovingIgnoreNoData: "Data",
		dimensionalMovingPropagateNoData: "NoData",
		dimensionalMovingFillOnlyNoData: "Fyll i NoData",
		circularMean: "Cirkulärt medelvärde",
		circularName: "Cirkulär",
		arithmeticName: "Aritmetiskt",
		slopeName: "Lutning",
		aspectName: "Lutningsriktning",
		meanCurvature: "Medelkurvatur",
		profileCurvature: "Profilkurvatur (normal lutningslinje)",
		tangentialCurvature: "Tangentialkurvatur (normal kontur)",
		planCurvature: "Plankurvatur (projicerad kontur)",
		contourGeodesicTorsion: "Konturgeodetisk torsion",
		gaussianCurvature: "Gaussisk kurvatur",
		casoratiCurvature: "Casorati-kurvatur",
		localSurfaceTypeQuadratic: "Kvadratisk",
		localSurfaceTypeBiquadratic: "Bikvadratisk",
		thresholdNoThreshold: "Ingen tröskel",
		thresholdPercentLeastCost: "Procent av lägsta kostnad",
		thresholdAccumulativeCost: "Ackumulerad kostnad",
		clrmapTypeHillshade: "Terrängskuggning"
	},
	categoryLabels: {
		sourceCharacteristics: "Källgrunddrag",
		neighborhoodSettings: "Grannskapsinställningar",
		statistics: "Statistik",
		gamma: "Gamma",
		viewshedParameters: "Parametrar för siktområde",
		observerParameters: "Observatörsparametrar",
		irregularDataInterpolation: "Oregelbunden datainterpolation",
		modelStatistics: "Modellstatistik",
		aggregationDef: "Aggregeringsdefinition",
		filterByAttributes: "Filtrera efter attribut",
		percentileName: "Percentil",
		rasterInfo: "Rasterinformation",
		extent: "Utbredning",
		spatialReference: "Geografisk referens"
	},
	outputRasterHelpTexts: {
		outputName: "<p>Namnet på lagret som skapas och läggs till i kartan.</p>",
		resultType: "<p>Typ av utdata som skapas. Utdata kan vara bildlager i tileform eller dynamiska bildlager.</p>",
		saveResultIn: "<p>Namnet på mappen i <b>Mitt innehåll</b> där resultatet ska sparas.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Miljöinställningar för analys i Map Viewer. </p>",
		outSR: "<p>Anger koordinatsystem för analysen och resultatlagret.</p>",
		extent: "<p>Anger det område som ska användas för analys.</p>",
		snapRaster: "<p>Justerar utbredningen för utdata så att den matchar celljusteringen för det angivna snapprasterlagret.</p>",
		cellSize: "<p>Anger cellstorlek eller upplösning som ska användas för analys och för att skapa utdatarasterlagret.</p>",
		mask: "<p>Anger ett masklager i vilket endast de celler som ligger inom maskområdet kommer att användas för analys.</p>",
		resamplingMethod: "<p>Anger hur pixelvärden ska interpoleras när indata- och utdatalager inte ordnas korrekt.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Typen stöds inte",
		currentlyUnsupported: " En standardredigerare för ${missingType} är väntande men kommer snart. Temporär platshållartextruta för att ange strängbaserade indata.",
		unsupportedOverrideWarning: "En komponent för åsidosättningsredigerare som ger en bättre användarupplevelse för arbete med följande parameter/parametrar är väntande men kommer snart:",
		overrideWidgetMissing: "Komponent för åsidosättningsredigerare saknas!",
		uiIncomplete: "Jobbinlämningen misslyckades. Funktionen kan inte köras eftersom vissa av de obligatoriska fälten är ofullständiga eller saknas i gränssnittet.",
		count: "Antal",
		selectVariables: "Välj variabler",
		selectFeature: "Välj ett geoobjektlager",
		greaterThanErrorMessage: "Indataantalet måste vara större än ${min}",
		lesserThanErrorMessage: "Indataantalet måste vara lägre än ${max}",
		greaterThanOrEqualErrorMessage: "Indataantalet måste vara större än eller lika med ${min}",
		lesserThanOrEqualErrorMessage: "Indataantalet måste vara lägre än eller lika med ${max}",
		allowScalar: "Välj ett lager eller ange en konstant",
		selectField: "Välj fält",
		parameterRequired: "Denna parameter är obligatorisk.",
		enterAValue: "Ange ett värde...",
		invalidInput: "Det angivna värdet är ogiltigt.",
		itemNotFound: "Objektet finns inte eller är inte tillgängligt.",
		itemPermissionDenied: "Du har inte åtkomstbehörighet till det här objektet.",
		layerNotAvailable: "Det gick inte att läsa in lagret ${layerName}.",
		multipleLayersNotAvailable: "Det gick inte att läsa in lagret ${layerName} och andra.",
		learnMoreLabel: "Läs mer",
		fieldNotAvailable: "Det gick inte att läsa in fältet.",
		allowAnalysis: "Analys är inte tillåtet i bildtjänsten.",
		allowAnalysisReason: "Ett eller flera lager från kartan listas inte här eftersom de inte tillåter analys.",
		learnMoreText: "Läs mer",
		atLeastOneRasterInput: "Minst ett indatalager ska vara ett rasterlager.",
		browseAnalysisLayers: "Bläddra bland lager",
		activeMapViewExtent: "Använd aktuell kartutbredning",
		chooseRaster: "Välj Klipper raster",
		chooseGeometry: "Välj Klippningsgeometri",
		resultType: "Resultattyp",
		saveInFolder: "Spara i mapp",
		outputName: "Utdatanamn",
		outputLayerType: "Lagertyp för utdata",
		dynamicImageryLayer: "Dynamiskt bildlager",
		tiledImageryLayer: "Bildlager i tileform",
		custom: "Anpassat",
		loading: "Läser in...",
		layerMissing: "Ett eller flera lager från kartan listas inte här eftersom de inte tillåter analys. Lär dig mer.",
		browseCoordinateSystems: "Bläddra i koordinatsystem",
		unableToRepopulateOutSR: "Det går inte att fylla i utdatakoordinatsystem.",
		defaultTitle: "Se mer",
		"ARC (equal arc-second)": "ARC (lika med båge-sekund)",
		Africa: "Afrika",
		Antarctica: "Antarktis",
		Argentina: "Argentina",
		Asia: "Asien",
		"Asteroid Belt": "Asteroidbältet",
		"Atlantic Ocean": "Atlanten",
		Australia: "Australien",
		"Australia and New Zealand": "Australien och Nya Zeeland",
		Austria: "Österrike",
		"BLM (US Feet)": "BLM (US-fot)",
		Bangladesh: "Bangladesh",
		"Beijing 1954": "Peking 1954",
		Bhutan: "Bhutan",
		CGCS2000: "CGCS2000",
		Canada: "Kanada",
		Caribbean: "Karibien",
		"Caribbean Sea": "Karibiska havet",
		"Central America": "Centralamerica",
		"Central and North America": "Centalamerika och Nordamerika",
		Colombia: "Colombia",
		Continental: "Kontinental",
		"County Systems": "Länsystem",
		"Democratic Republic of the Congo": "Demokratiska republiken Kongo",
		"EPSG Arctic": "EPSG Arktis",
		Earth: "Jorden",
		"Ellipsoidal-based": "Ellipsoidbaserat",
		Europe: "Europa",
		Finland: "Finland",
		France: "Frankrike",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss Kruger",
		"Geographic Coordinate Systems": "Geografiska koordinatsystem",
		Germany: "Tyskland",
		"Gravity-related": "Gravitationsrelaterat",
		"Greenwich-based": "Greenwich-baserad",
		"Highways England": "Motorvägar England",
		Illinois: "Illinois",
		"Indian Ocean": "Indiska oceanen",
		"Indian Subcontinent": "Indiska subkontinenten",
		Indiana: "Indiana",
		Indonesia: "Indonesien",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irland och Storbritannien",
		Italy: "Italien",
		Japan: "Japan",
		Jupiter: "Jupiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Libyen",
		Malaysia: "Malaysia",
		"Malaysia and Singapore": "Malaysia och Singapore",
		Mars: "Mars",
		Mercury: "Merkurius",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (US-fot)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (int. fot)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (meter)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (US-fot)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (int. fot)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (meter)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (US-fot)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (int. fot)",
		"NAD 1983 (Meters)": "NAD 1983 (meter)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (meter)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (US-fot)",
		"NAD 1983 (US Feet)": "NAD 1983 (US-fot)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (int. fot)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (meter)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (US-fot)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (int. fot)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (meter)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (US-fot)",
		"National Grids": "Nationella rutnät",
		Navajo: "Navajo",
		Neptune: "Neptunus",
		"New Beijing": "Nya Peking",
		"New Zealand": "Nya Zeeland",
		"North America": "Nordamerika",
		"Northern Hemisphere": "Norra halvklotet",
		Norway: "Norge",
		Oceans: "Hav",
		Oregon: "Oregon",
		"Other GCS": "Annan GCS",
		"Pacific Ocean": "Stilla havet",
		Pluto: "Pluto",
		Polar: "Polar",
		Portugal: "Portugal",
		"Projected Coordinate Systems": "Projicerade koordinatsystem",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Ersatt",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturnus",
		"Solar System": "Solsystem",
		"South Africa": "Sydafrika",
		"South America": "Sydamerika",
		"South Korea": "Sydkorea",
		"Southern Hemisphere": "Södra halvklotet",
		"Spheroid-based": "Rotationsellipsoidsbaserad",
		"State Plane": "Delstatsplan",
		"State Systems": "Delstatssystem",
		Sweden: "Sverige",
		"Switzerland and Liechtenstein": "Schweiz och Liechtenstein",
		Texas: "Texas",
		Tribal: "Stam",
		Turkey: "Turkiet",
		"US Feet": "US-fot",
		"USA and territories": "USA och territorierna",
		UTM: "UTM",
		Ukraine: "Ukraina",
		"Unknown Height Systems": "Okända höjdsystem",
		Uranus: "Uranus",
		Venus: "Venus",
		"Vertical Coordinate Systems": "Vertikala koordinatsystem",
		Vietnam: "Vietnam",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Världen",
		"World (Sphere-based)": "Världen (sfärbaserad)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Klar",
		noResults: "Inga resultat hittades",
		searchPlaceholder: "Namn eller WKID",
		browseTemplate: "Bläddra bland mallar för rasterfunktion",
		saveTemplate: "Spara mall för rasterfunktion",
		preview: "Förhandsgranska",
		previewDescription: "Förhandsgranska resultatet innan du kör analysen.",
		showPreview: "Visa förhandsgranskning",
		previewLayer: "Förhandsgranska lager ${number}",
		newPreview: "Ny förhandsgranskning",
		previewPopup: "Aktivera förhandsgranskningen av analysresultaten baserat på indataparametrarna.",
		updatePreviewLayer: "Uppdatera valt förhandsvisningslager",
		createPreviewLayer: "Skapa nytt förhandsvisningslager",
		maximumPreviewAllowed: "Högsta antal tillåtna förhandsvisningslager: ${maxCount}",
		previewFailure: "Detta förhandsvisningslager är ej tillgängligt. Kontrollera indataparametrarna och uppdatera det här förhandsvisningslagret igen.",
		header: "Välj objekt",
		content: "Du har osparade ändringar i ${rftTitle}. Om du börjar om med en ny mall går dessa ändringar förlorade.",
		dontSave: "Spara inte",
		"continue": "Fortsätt",
		stretch: "Anpassa till fönster",
		pan: "Panorera",
		newTemplate: "Skapa ny mall",
		openTemplate: "Öppna mall",
		addFunction: "Lägg till rasterfunktioner",
		addConstant: "Lägg till konstant",
		addRaster: "Lägg till rastervariabel",
		move: "Flytta",
		zoom: "Zooma",
		saveAs: "Spara som",
		clear: "Radera",
		addRasterFunctionTitle: "Lägg till rasterfunktioner",
		templatePropertiesTitle: "Mallegenskaper",
		browseRFT: "Bläddra bland mallar för rasterfunktion",
		defaultToolDescription: "${toolTitle} analysverktyg.",
		openToolText: "Öppna verktyg",
		toolDropdownText: "Verktygslistmeny",
		addToMap: "Bekräfta och lägg till på karta",
		confirm: "Bekräfta",
		select: "Välj",
		selectTask: "Välj uppgift",
		unsupportedLayer: "Den här parametern stöder inte följande lager: ${layerName}.",
		viewDetails: "Visa fullständig objektinformation",
		rename: "Byt namn",
		duplicate: "Duplicera",
		launch: "Öppna för att köra",
		templateEditor: "Mallredigerare",
		createItem: "Spara mall för rasterfunktion",
		actionLabel: "Filter",
		filterPopoverHeading: "Filtrera funktioner",
		defaultSearchPlaceholder: "Sök efter namn",
		settings: "Inställningar",
		summary: "Sammanfattning",
		definitionQuery: "Definitionsfråga",
		matchVariables: "Matcha variabler",
		unionDimension: "Unionsdimension",
		nameEditorPlaceholder: "Ange titel",
		summaryEditorPlaceholder: "Ange en kort beskrivning.",
		definitionQueryPlaceholder: "Ange...",
		upload: "Överför",
		chooseImage: "Klicka för att välja en fil",
		update: "Uppdatera",
		thumbnailErrors: {
			wrongImageType: "Fel bildtyp är vald",
			notAvailable: "Ingen miniatyrbild finns tillgänglig",
			loadError: "Det gick inte att ladda bilden",
			chooseFile: "Klicka för att välja fil"
		}
	}
};
const copy = "Kopiera";
const save = "Spara";
const title = "Titel";
const folder = "Mapp";
const tags = "Taggar";
const savingMessage = "Sparar objekt till";
const shareWith = "Dela med";
const share = "Dela";
const setSharingLevel = "Ställ in delningsnivå";
const setGroupSharing = "Ställ in gruppdelning";
const owner = "Ägare";
const organization = "Organisation";
const everyone = "Alla (publik)";
const groups = "Grupper:";
const type = "Typ";
const mosaic = "Mosaik";
const itemGroup = "Objektgrupp";
const item = "Objekt";
const definitionQuery = "Definitionsfråga";
const groupItemsBy = "Gruppera objekt efter";
const groupFieldName = "Gruppera fältnamn";
const tagFieldName = "Taggfältnamn";
const noTitleTagErrorMsg = "Du måste ange en titel för objektet och taggar som gör att kartan går att hitta genom sökningar.";
const noTitleErrorMsg = "Du måste ange en titel för objektet.";
const noTagErrorMsg = "Du måste ange minst en tagg för att hjälpa andra att hitta objektet i sökningar.";
const error = "Fel";
const warning = "Varning";
const success = "Lyckades";
const details = "Information:";
const tryAgain = "Prova igen";
const toolModeler = {
	save: "Spara",
	editProperties: "Redigera egenskaper",
	saveAs: "Spara som",
	savingNotification: "Sparar ändringar av objekt ...",
	savingTitle: "Sparar",
	saveFailedMessage: "Det gick inte att spara ändringarna.",
	saveWithErrorsMessage: "Ändringar sparades med följande fel.",
	viewItemMessage: "Visa det sparade objektet",
	here: "här.",
	itemCreatedMessage: "Nytt objekt har skapats.",
	clickToViewItemMessage: "Klicka på OK för att visa objektinformationssidan; klicka på Avbryt för att fortsätta.",
	readingFailed: "Det går inte att läsa in den valda rasterfunktionsmallen.",
	failedToLoadXML: "Det går inte att läsa in den valda rasterfunktionsmallen i XML-format.",
	learnMore: "Läs mer",
	overwriteTitle: "Bekräfta att du vill skriva över",
	overwriteMessage: "Vill du skriva över ett befintligt objekt?",
	overwriteSuccessMessage: "Objektet har uppdaterats."
};
const toolEditor = {
	run: "Kör",
	save: "Spara",
	deleteSelected: "Ta bort markerade objekt",
	addRaster: "Lägg till raster",
	addScalar: "Lägg till skalär",
	layout: "Automatisk layout",
	errorTitle: "Fel",
	invalidToolMessage: "Rasterfunktionsmallen är inte giltig.",
	out: "Ut",
	zoomIn: "Zooma in",
	zoomOut: "Zooma ut",
	zoomToFit: "Anpassa till fönster",
	panOn: "Växla till panoreringsläge",
	panOff: "Stäng av panoreringsläge",
	defaultModelName: "Verktygsmodell",
	defaultRasterName: "Raster"
};
const toolDetailsEditor = {
	defaultToolName: "Mall för rasterfunktion",
	defaultToolDescription: "Lägg till en kort sammanfattning av rasterfunktionen.",
	defaultHelpText: "Klicka på hjälpikonen om du vill redigera hjälptexten.",
	editHelpTitle: "Redigera hjälp",
	saveLabel: "Spara",
	cancelLabel: "Avbryt",
	thumbnail: {
		wrongImageType: "Fel bildtyp är vald",
		notAvailable: "Ingen miniatyrbild finns tillgänglig",
		loadError: "Det gick inte att ladda bilden",
		chooseFile: "Klicka för att välja fil"
	}
};
const saveUtils = {
	thumbnail: "Miniatyrbild",
	sharing: "Delning"
};
const close = "Stäng";
const unsavedWarningExisting = "Vill du spara ändringarna av objektet <b>${itemTitle}</b>?";
const unsavedWarningNew = "Vill du spara dina ändringar?";
const saveAs = "Spara som";
const dontSave = "Spara inte";
const unsavedTitle = "Osparade ändringar";
const invalidRFTMessage = "Rasterfunktionsmallen som skapats är inte giltig.";
const errorTitle = "Fel";
const breadcrumb = "Rasterfunktionsredigerare";
const breadcrumbEditor = "Innehåll > rasterfunktionsredigerare";
const viewerModeTitle = "Skrivskyddad";
const viewerModeMessage = "Rasterfunktionsmallobjektet är skrivskyddat. Ändringarna kan inte sparas.";
const userStartDirection = "Välj en funktion för att börja skapa en rasterfunktionsmall.";
const selectFunction = "Lägg till funktion";
const deselectFunction = "Ta bort funktion";
const dialogTitle = "System";
const category = "Kategorier";
const search = "Sök rasterfunktioner";
const categoryNames = {
	analysis: "Analys",
	appearance: "Utseende",
	classification: "Klassificering",
	conversion: "Konvertering",
	correction: "Korrigering",
	dataManagement: "Datahantering",
	distance: "Avstånd",
	distanceLegacy: "Avstånd (äldre)",
	hydrology: "Hydrologi",
	math: "Matematik",
	mathConditional: "Matematik: villkorlig",
	mathLogical: "Matematik: logisk",
	mathTrigonometric: "Matematik: trigonometrisk",
	reclass: "Omklassning",
	statistical: "Statistisk",
	surface: "Yta"
};
const commonStrings_sv = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_sv);


//# sourceMappingURL=common-strings.sv-9d23d938.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLWU0Y2UxZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscVZBQXFWLHdJQUF3SSw2Q0FBNkM7QUFDMWdCO0FBQ0E7QUFDQSwyWUFBMlk7QUFDM1k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb2tDQUFva0M7QUFDcGtDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2NUZBQTY1RixPQUFPO0FBQ3A2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0Esc0RBQXNELGFBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLElBQUk7QUFDckUsK0RBQStELElBQUk7QUFDbkUsdUZBQXVGLElBQUk7QUFDM0YscUZBQXFGLElBQUk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVTtBQUNuRSxrRUFBa0UsV0FBVztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFNBQVM7QUFDbEY7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsVUFBVTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGdCQUFnQixFQUFDO0FBQ2lvQzs7QUFFanFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vY29tbW9uLXN0cmluZ3Muc3YtOWQyM2Q5MzguanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb2sgPSBcIk9LXCI7XG5jb25zdCBjYW5jZWwgPSBcIkF2YnJ5dFwiO1xuY29uc3QgZW50ZXJVUkwgPSBcIkFuZ2UgVVJMIHRpbGwgYmlsZHRqw6Ruc3RcIjtcbmNvbnN0IHNlcnZpY2VVUkwgPSBcIlRqw6Ruc3RlLVVSTFwiO1xuY29uc3Qgc2VsZWN0UmFzdGVyID0gXCJWw6RsaiByYXN0ZXJcIjtcbmNvbnN0IGZhaWxlZFRvTG9hZExheWVyID0gXCJEZXQgZ2ljayBpbnRlIGF0dCBsw6RzYSBpbiBsYWdyZXRcIjtcbmNvbnN0IGxvYWRpbmdMYXllciA9IFwiTMOkc2VyIGluIGxhZ2VyXCI7XG5jb25zdCBzZWxlY3RGZWF0dXJlID0gXCJWw6RsaiBnZW9vYmpla3RsYWdlclwiO1xuY29uc3QgZW50ZXJGVVJMID0gXCJBbmdlIFVSTCB0aWxsIGdlb29iamVrdHRqw6Ruc3RcIjtcbmNvbnN0IGFkZFJhc3RlciA9IFwiTMOkZ2cgdGlsbCByYXN0ZXJ2YXJpYWJlbFwiO1xuY29uc3QgYWRkU2NhbGFyID0gXCJMw6RnZyB0aWxsIGtvbnN0YW50XCI7XG5jb25zdCByYXN0ZXIgPSBcIlJhc3RlclwiO1xuY29uc3Qgc2NhbGFyID0gXCJTa2Fsw6RyXCI7XG5jb25zdCBkZWZhdWx0TW9kZWxOYW1lID0gXCJNYWxsIGbDtnIgcmFzdGVyZnVua3Rpb25cIjtcbmNvbnN0IGdlbmVyYWwgPSBcIkFsbG3DpG50XCI7XG5jb25zdCBwYXJhbWV0ZXJzID0gXCJQYXJhbWV0cmFyXCI7XG5jb25zdCB2YXJpYWJsZXMgPSBcIlZhcmlhYmxlclwiO1xuY29uc3QgbmFtZSA9IFwiTmFtblwiO1xuY29uc3QgZGVzY3JpcHRpb24gPSBcIkJlc2tyaXZuaW5nXCI7XG5jb25zdCBwYXJhbWV0ZXIgPSBcIlBhcmFtZXRlclwiO1xuY29uc3QgaXNQdWJsaWMgPSBcIklzUHVibGljXCI7XG5jb25zdCBpc0RhdGFzZXQgPSBcIklzRGF0YXNldFwiO1xuY29uc3QgdW5rbm93blBpeGVsVHlwZSA9IFwiT2vDpG50XCI7XG5jb25zdCBvdXRwdXRQaXhlbFR5cGUgPSBcIlBpeGVsdHlwIGbDtnIgdXRkYXRhXCI7XG5jb25zdCB1OFBpeGVsVHlwZSA9IFwiOC1iaXRhcnMgb3NpZ25lcmFkXCI7XG5jb25zdCBzOFBpeGVsVHlwZSA9IFwiOC1iaXRhcnMgc2lnbmVyYWRcIjtcbmNvbnN0IHUxNlBpeGVsVHlwZSA9IFwiMTYtYml0YXJzIG9zaWduZXJhZFwiO1xuY29uc3QgczE2UGl4ZWxUeXBlID0gXCIxNi1iaXRhcnMgc2lnbmVyYWRlXCI7XG5jb25zdCB1MzJQaXhlbFR5cGUgPSBcIjMyLWJpdGFycyBvc2lnbmVyYWRlXCI7XG5jb25zdCBzMzJQaXhlbFR5cGUgPSBcIjMyLWJpdGFycyBzaWduZXJhZFwiO1xuY29uc3QgZjMyUGl4ZWxUeXBlID0gXCIzMi1iaXRhcnMgZmx5dHRhbFwiO1xuY29uc3QgZjY0UGl4ZWxUeXBlID0gXCI2NC1iaXRhcnMgZHViYmVsXCI7XG5jb25zdCBwcm9wZXJ0aWVzID0gXCJFZ2Vuc2thcGVyXCI7XG5jb25zdCBtdWx0aWRpbWVuc2lvbmFsUnVsZXMgPSBcIkZsZXJkaW1lbnNpb25lbGxhIHJlZ2xlclwiO1xuY29uc3QgbWF0Y2hWYXJpYWJsZXMgPSBcIk1hdGNoYSB2YXJpYWJsZXJcIjtcbmNvbnN0IHVuaW9uRGltZW5zaW9ucyA9IFwiVW5pb25zZGltZW5zaW9uZXJcIjtcbmNvbnN0IHJhc3RlckZ1bmN0aW9uRWRpdG9yID0ge1xuXHRpbnZhbGlkUkZUTWVzc2FnZTogXCJSYXN0ZXJmdW5rdGlvbnNtYWxsZW4gw6RyIGludGUgZ2lsdGlnLlwiLFxuXHRyZnhBcmdzRWRpdG9yOiB7XG5cdFx0b3V0cHV0UmFzdGVyOiBcIk91dHB1dFJhc3RlclwiLFxuXHRcdHJhc3RlcjogXCJSYXN0ZXJcIixcblx0XHR1bnN1cHBvcnRlZERhdGFUeXBlV2FybmluZzogXCJGw7ZsamFuZGUgYXJndW1lbnQgdmlzYXMgaW50ZSBlZnRlcnNvbSBkZSBmw7ZyIG7DpHJ2YXJhbmRlIGludGUgc3TDtmRzLlwiLFxuXHRcdHVuc3VwcG9ydGVkRnVuY3Rpb246IFwiSW5uZWjDpWxsZXIgcmFzdGVyZnVua3Rpb24oZXIpIHNvbSBmw7ZyIG7DpHJ2YXJhbmRlIGludGUgc3TDtmRzLlwiXG5cdH0sXG5cdHJmeFJhc3RlcklucHV0OiB7XG5cdFx0c2VsZWN0TGF5ZXI6IFwiVsOkbGogbGFnZXJcIixcblx0XHRicm93c2VMYXllcnM6IFwiQmzDpGRkcmEgYmxhbmQgbGFnZXJcIixcblx0XHRyZnhWYXJpYWJsZTogXCJSYXN0ZXJGdW5jdGlvblZhcmlhYmxlXCJcblx0fSxcblx0cmZ4QmFuZENvbWJpbmF0aW9uRWRpdG9yOiB7XG5cdFx0bWV0aG9kTGFiZWw6IFwiTWV0b2RcIixcblx0XHRiYW5kTGFiZWw6IFwiQmFuZFwiLFxuXHRcdGNvbWJpbmF0aW9uTGFiZWw6IFwiS29tYmluYXRpb25cIlxuXHR9LFxuXHRyZnhSZW1hcEdyaWQ6IHtcblx0XHRtaW5pbXVtOiBcIk1pbmltdW1cIixcblx0XHRtYXhpbXVtOiBcIk1heGltYWx0XCIsXG5cdFx0b3V0cHV0OiBcIlV0ZGF0YVwiLFxuXHRcdG5vRGF0YTogXCJOb0RhdGFcIixcblx0XHRyZW1hcFZhbHVlc0xhYmVsOiBcIk1hcHBhIG9tIHbDpHJkZW5cIlxuXHR9LFxuXHRyZnhOYW1lZFJhc3RlckVkaXRvcjoge1xuXHRcdHJhc3RlclZhcmlhYmxlczogXCJSYXN0ZXJ2YXJpYWJsZXJcIixcblx0XHRkZWxldGVTZWxlY3RlZFZhcnM6IFwiVGEgYm9ydCB2YWxkYSB2YXJpYWJsZXJcIlxuXHR9LFxuXHRyZnhDbGlwcGluZ0dlb21ldHJ5OiB7XG5cdFx0Y2xpcHBpbmdMYXllcjogXCJCZXNrw6RybmluZ3NsYWdlclwiLFxuXHRcdGNsaXBwaW5nUmFzdGVyOiBcIktsaXBwZXIgcmFzdGVyXCIsXG5cdFx0Y2xpcHBpbmdHZW9tZXRyeTogXCJLbGlwcG5pbmdzZ2VvbWV0cmlcIixcblx0XHRjdXN0b21FeHRlbnQ6IFwiQW5wYXNzYWQgdXRicmVkbmluZ1wiLFxuXHRcdG91dHB1dEV4dGVudDogXCJVdGRhdGF1dGJyZWRuaW5nXCIsXG5cdFx0Y3VycmVudEV4dGVudDogXCJBa3R1ZWxsIGthcnR1dGJyZWRuaW5nXCIsXG5cdFx0ZHJhd0xhYmVsOiBcIlJpdGFcIlxuXHR9LFxuXHRyZnhDdXN0b21FeHRlbnQ6IHtcblx0XHR0b3A6IFwiw5Z2cmVcIixcblx0XHRyaWdodDogXCJIw7ZnZXJcIixcblx0XHRib3R0b206IFwiTMOkbmdzdCBuZWRcIixcblx0XHRsZWZ0OiBcIlbDpG5zdGVyXCJcblx0fSxcblx0cmZ4UmFzdGVyQXJyYXlFZGl0b3I6IHtcblx0XHRtb3ZlVXA6IFwiRmx5dHRhIHVwcMOldFwiLFxuXHRcdG1vdmVEb3duOiBcIkZseXR0YSBuZWTDpXRcIixcblx0XHRyZW1vdmU6IFwiVGEgYm9ydFwiXG5cdH0sXG5cdHJmeFN0YXRpc3RpY3NHcmlkOiB7XG5cdFx0c3RkRGV2OiBcIlN0ZC4gYXYuXCIsXG5cdFx0bWluOiBcIk1pbi5cIixcblx0XHRtYXg6IFwiTWF4XCIsXG5cdFx0bWVhbjogXCJNZWRlbHbDpHJkZVwiXG5cdH0sXG5cdHJmeFdlaWdodGVkU3VtVGFibGVFZGl0b3I6IHtcblx0XHR3ZWlnaHRlZFN1bVRhYmxlOiBcIlZpa3RhZCBzdW1tZXJpbmdzdGFiZWxsXCIsXG5cdFx0aWQ6IFwiSURcIixcblx0XHRsYXllcjogXCJMYWdlclwiLFxuXHRcdGZpZWxkOiBcIkbDpGx0XCIsXG5cdFx0d2VpZ2h0OiBcIlZpa3RcIixcblx0XHR2YWx1ZTogXCJWw6RyZGVcIixcblx0XHRzZWxlY3RMYXllcjogXCJWw6RsaiBsYWdlclwiXG5cdH0sXG5cdHJmeFdlaWdodGVkT3ZlcmxheVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRPdmVybGF5VGFibGU6IFwiVmlrdGFkIMO2dmVybGFncmluZ3N0YWJlbGxcIixcblx0XHRpZDogXCJJRFwiLFxuXHRcdGxheWVyOiBcIkxhZ2VyXCIsXG5cdFx0ZmllbGQ6IFwiRsOkbHRcIixcblx0XHRpbmZsdWVuY2U6IFwiSW5mbHl0YW5kZVwiLFxuXHRcdHN1bU9mSW5mbHVlbmNlOiBcIlN1bW1hIGF2IGluZmx5dGFuZGVcIixcblx0XHR2YWx1ZTogXCJWw6RyZGVcIixcblx0XHRyZW1hcFRhYmxlOiBcIk9tbWFwcG5pbmdzdGFiZWxsXCIsXG5cdFx0c2NhbGU6IFwiU2thbGFcIixcblx0XHRzY2FsZXM6IFwiU2thbG9yXCIsXG5cdFx0c2VsZWN0UmFzdGVyOiBcIlbDpGxqIHJhc3RlclwiXG5cdH0sXG5cdHJmeEZlYXR1cmVTZWxlY3Q6IHtcblx0XHRhZGRGZWF0dXJlTGF5ZXI6IFwiQmzDpGRkcmEgZWZ0ZXIgZXR0IGdlb29iamVrdGxhZ2VyXCIsXG5cdFx0YWRkUG9pbnRMYXllcjogXCJCbMOkZGRyYSBlZnRlciBldHQgcHVua3RsYWdlclwiXG5cdH0sXG5cdHJmeEZpZWxkU2VsZWN0OiB7XG5cdFx0dmFsdWU6IFwiVsOkcmRlXCIsXG5cdFx0Y291bnQ6IFwiQW50YWxcIlxuXHR9LFxuXHRyZnhBdHRyaWJ1dGVUYWJsZToge1xuXHRcdHRhYmxlVHlwZTogXCJUYWJlbGx0eXBcIixcblx0XHRtYW51YWw6IFwiTWFudWVsbFwiLFxuXHRcdGV4dGVybmFsOiBcIkV4dGVyblwiLFxuXHRcdG1pblZhbDogXCJNaW5zdGEgdsOkcmRlXCIsXG5cdFx0bWF4VmFsOiBcIk1heGltYWx0IHbDpHJkZVwiLFxuXHRcdGJhc2VDbGFzc05hbWU6IFwiS2xhc3NiYXNuYW1uXCIsXG5cdFx0Y29sb3JTY2hlbWU6IFwiRsOkcmdzY2hlbWFcIixcblx0XHRkZWZhdWx0Q2xhc3NOYW1lOiBcIkxhYmVsX1wiLFxuXHRcdGdlbmVyYXRlVGFibGU6IFwiU2thcGEgdGFiZWxsXCIsXG5cdFx0YnJvd3NlVGFibGU6IFwiQmzDpGRkcmEgaSB0YWJlbGxcIixcblx0XHR2YWx1ZTogXCJWw6RyZGVcIixcblx0XHRjbGFzc25hbWU6IFwiQ2xhc3NOYW1lXCIsXG5cdFx0Y29sb3I6IFwiRsOkcmdcIlxuXHR9LFxuXHRyZnhGaWVsZE51bWJlclN3aXRjaGFibGU6IHtcblx0XHRudW1iZXI6IFwiTnVtZXJpc2tcIixcblx0XHRmaWVsZDogXCJGw6RsdFwiLFxuXHRcdHN0cmluZzogXCJTdHLDpG5nXCIsXG5cdFx0bGluZWFyVW5pdDogXCJMaW5qw6RyIGVuaGV0XCJcblx0fSxcblx0cmZ4UHJvcGVydHlTZXQ6IHtcblx0XHRuYW1lOiBcIk5hbW5cIixcblx0XHR2YWx1ZTogXCJWw6RyZGVcIlxuXHR9LFxuXHRyZnhDb252ZXJzaW9uR3JpZDoge1xuXHRcdHNpemU6IFwiU3Rvcmxla1wiXG5cdH0sXG5cdHJmeFRyYW5zcG9zZUJpdDoge1xuXHRcdGJpdFBhdHRlcm46IFwiQml0bcO2bnN0ZXJcIixcblx0XHRvdXRwdXRCaXQ6IFwiVXRkYXRhYml0XCIsXG5cdFx0aW5wdXRCaXQ6IFwiSW5kYXRhYml0XCJcblx0fSxcblx0cmZ4U3BhdGlhbFJlZmVyZW5jZToge1xuXHRcdHBsYWNlSG9sZGVyOiBcIkbDtnJmaW5hIGdlbm9tIG55Y2tlbG9yZFwiLFxuXHRcdGNvb3JkaW5hdGVTeXN0ZW06IFwiS29vcmRpbmF0c3lzdGVtXCIsXG5cdFx0Z2NzOiBcIkdlb2dyYWZpc2t0IGtvb3JkaW5hdHN5c3RlbVwiLFxuXHRcdHBjczogXCJQcm9qaWNlcmF0IGtvb3JkaW5hdHN5c3RlbVwiLFxuXHRcdHZjczogXCJWZXJ0aWthbHQga29vcmRpbmF0c3lzdGVtXCJcblx0fVxufTtcbmNvbnN0IHJmeExpY2Vuc2VJbmZvID0gXCJEZW5uYSBtYWxsIGbDtnIgcmFzdGVyZnVua3Rpb24ga2FuIGFudsOkbmRhcyB0aWxsIGF0dCBiZWFyYmV0YSBkaW5hIGJpbGRlciBtZWQgQXJjR0lTIEltYWdlIFNlcnZlci5cIjtcbmNvbnN0IHJhc3RlckZ1bmN0aW9ucyA9IHtcblx0cmZ4OiB7XG5cdFx0YUNvc0hOYW1lOiBcIkFDb3NIXCIsXG5cdFx0YUNvc0hTbmlwOiBcIkJlcsOka25hciBvbXbDpG5kIGh5cGVyYm9saXNrIGNvc2ludXMgZsO2ciBjZWxsZXIgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGFDb3NIRGVzYzogXCJGdW5rdGlvbmVuIGJlcsOka25hciBvbXbDpG5kIGh5cGVyYm9saXNrIGNvc2ludXMgZsO2ciBwaXhsYXJuYSBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0YUNvc05hbWU6IFwiQUNvc1wiLFxuXHRcdGFDb3NTbmlwOiBcIkJlcsOka25hciBvbXbDpG5kIGNvc2ludXMgZsO2ciBwaXhsYXJuYSBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0YUNvc0Rlc2M6IFwiRGVubmEgcmFzdGVyZnVua3Rpb24gYmVyw6RrbmFyIG9tdsOkbmQgY29zaW51cyBmw7ZyIGNlbGxlciBpIGV0dCByYXN0ZXIuIElub20gbWF0ZW1hdGlrZW4gaGFyIGFsbGEgdHJpZ29ub21ldHJpc2thIGZ1bmt0aW9uZXIgZXR0IGRlZmluaWVyYXQgb21mw6VuZyBhdiBnaWx0aWdhIGluZ8OlbmdzdsOkcmRlbiBzb20ga2FsbGFzIGRvbcOkbi4gUmVzdWx0YXR2w6RyZGVuYSBmcsOlbiB2YXJqZSBmdW5rdGlvbiBoYXIgb2Nrc8OlIGV0dCBvbWbDpW5nIGbDtnIgcmVzdWx0YXR2w6RyZGVuLiBGw7ZyIGRldCBow6RyIHZlcmt0eWdldCDDpHIgZG9tw6RuZW4gWy0xLCAxXSBvY2ggb21mw6VuZ2V0IFswLCBwaV0uXCIsXG5cdFx0YVNpbkhOYW1lOiBcIkFTaW5IXCIsXG5cdFx0YVNpbkhTbmlwOiBcIkJlcsOka25hciBvbXbDpG5kIGh5cGVyYm9saXNrIHNpbnVzIGbDtnIgY2VsbGVyIGkgZXR0IHJhc3Rlci5cIixcblx0XHRhU2luSERlc2M6IFwiRnVua3Rpb25lbiBiZXLDpGtuYXIgb212w6RuZCBoeXBlcmJvbGlzayBzaW51cyBmw7ZyIHBpeGxhcm5hIGkgZXR0IHJhc3Rlci5cIixcblx0XHRhU2luTmFtZTogXCJBU2luXCIsXG5cdFx0YVNpblNuaXA6IFwiQmVyw6RrbmFyIG9tdsOkbmQgc2ludXMgZsO2ciBjZWxsZXIgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGFTaW5EZXNjOiBcIkZ1bmt0aW9uZW4gYmVyw6RrbmFyIG9tdsOkbmQgc2ludXMgZsO2ciBwaXhsYXJuYSBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0YVRhbjJOYW1lOiBcIkFUYW4yXCIsXG5cdFx0YVRhbjJTbmlwOiBcIkJlcsOka25hciBvbXbDpG5kIHRhbmdlbnQgKGJhc2VyYWQgcMOlIHgseSkgZsO2ciBjZWxsZXIgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGFUYW4yRGVzYzogXCJGdW5rdGlvbmVuIGJlcsOka25hciBvbXbDpG5kIHRhbmdlbnQgKGJhc2VyYXQgcMOlIHgseSkgZsO2ciBwaXhsYXJuYSBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0YVRhbkhOYW1lOiBcIkFUYW5IXCIsXG5cdFx0YVRhbkhTbmlwOiBcIkJlcsOka25hciBvbXbDpG5kIGh5cGVyYm9saXNrIHRhbmdlbnQgZsO2ciBjZWxsZXIgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGFUYW5IRGVzYzogXCJGdW5rdGlvbmVuIGJlcsOka25hciBvbXbDpG5kIGh5cGVyYm9saXNrIHRhbmdlbnQgZsO2ciBwaXhsYXJuYSBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0YVRhbk5hbWU6IFwiQVRhblwiLFxuXHRcdGFUYW5TbmlwOiBcIkJlcsOka25hciBvbXbDpG5kIHRhbmdlbnQgZsO2ciBjZWxsZXIgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGFUYW5EZXNjOiBcIkZ1bmt0aW9uZW4gYmVyw6RrbmFyIG9tdsOkbmQgdGFuZ2VudCBmw7ZyIHBpeGxhcm5hIGkgZXR0IHJhc3Rlci5cIixcblx0XHRhYnNOYW1lOiBcIkFic1wiLFxuXHRcdGFic1NuaXA6IFwiQmVyw6RrbmFyIGFic29sdXQgdsOkcmRlIGbDtnIgY2VsbGVybmEgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGFic0Rlc2M6IFwiQWJzLWZ1bmt0aW9uZW4gYmVyw6RrbmFyIGFic29sdXQgdsOkcmRlIGbDtnIgcGl4bGFybmEgaSBldHQgcmFzdGVyLlwiLFxuXHRcdHJlZmxlY3RhbmNlTmFtZTogXCJTa2VuYmFyIHJlZmxla3RhbnNcIixcblx0XHRyZWZsZWN0YW5jZVNuaXA6IFwiS29udmVydGVyYXIgb2JlYXJiZXRhZGUgYmlsZGVyIHRpbGwgVG9wIG9mIEF0bW9zcGhlcmUtdsOkcmRlbiBnZW5vbSBhdHQgdGEgaMOkbnN5biB0aWxsIHNlbnNvcmVnZW5za2FwZXIsIHNvbGVucyBwb3NpdGlvbiBvY2ggdmlsa2VuIHRpZCBiaWxkZW4gdG9ncy5cIixcblx0XHRyZWZsZWN0YW5jZURlc2M6IFwiRGVuIGjDpHIgZnVua3Rpb25lbiBqdXN0ZXJhciBkZXQgZGlnaXRhbGEgc2lmZmVydsOkcmRldCBmw7ZyIGJpbGRlbnMgbGp1c3N0eXJrYSAoRE4pIGbDtnIgbsOlZ3JhIHNhdGVsbGl0c2Vuc29yZXIuIEp1c3RlcmluZ2FybmEgYmFzZXJhcyBww6Ugc29saMO2amQsIGFuc2thZmZuaW5nc2RhdHVtIG9jaCBzZW5zb3JlZ2Vuc2thcGVyIGbDtnIgYXR0IHN0w6RsbGEgaW4gZsO2cnN0w6Rya25pbmcgb2NoIHNuZWR2cmlkbmluZyBmw7ZyIHZhcmplIGJhbmQuIERlbiBow6RyIGZ1bmt0aW9uZW4gYW52w6RuZHMgZsO2ciBhdHQganVzdGVyYSB2w6RyZGVuIGbDtnIgcmVmbGVrdGFucywgZWxsZXIgbGp1c3N0eXJrYSwgZsO2ciBuw6VncmEgc2F0ZWxsaXRiaWxkZXIgYmFzZXJhdCBww6Ugc2NlbmJlbHlzbmluZyBvY2ggaW5zdMOkbGxuaW5nYXIgZsO2ciBzZW5zb3Jmw7Zyc3TDpHJrbmluZy4gQmlsZGVybmEganVzdGVyYXMgZWZ0ZXIgZW4gYmVseXNuaW5nIHNvbSDDpHIgdmFubGlnIGkgdGVvcmluLCBzw6UgYXR0IHNjZW5lcm5hIGZyw6VuIG9saWthIGRhdHVtIG9jaCBzZW5zb3JlciBpbnRlIHNrYSBza2lsamEgc2lnIHPDpSBteWNrZXQuIERldHRhIGthbiB2YXJhIGFudsOkbmRiYXJ0IGbDtnIgYmlsZGtsYXNzaWZpY2VyaW5nLCBmw6RyZ2JhbGFuc2VyaW5nIG9jaCBtb3NhaWtiZWFyYmV0bmluZy4gRGVuIGjDpHIgZnVua3Rpb25lbiBrYW4gZW5kYXN0IGFudsOkbmRhcyBtZWQgc3BlY2lmaWthIGJpbGRlci4gU2Vuc29yZXJuYSBzb20gZ8OlciBhdHQgYW52w6RuZGEgw6RyIExhbmRzYXQgTVNTLCBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIEdlb0V5ZS0xLCBSYXBpZEV5ZSwgRE1DaWksIFdvcmxkVmlldy0xLCBXb3JsZFZpZXctMiwgU1BPVCA2IG9jaCBQbGVpYWRlcy48ZGl2Pjxici8+RnVua3Rpb25lbiB1dGbDtnIgdHbDpSBrb3JyaWdlcmluZ2FyLiBEZW4gZsO2cnN0YSDDpHIgYmFzZXJhZCBww6UgZsO2cnN0w6Rya25pbmdzaW5zdMOkbGxuaW5nYXJuYS4gRGUgdXJzcHJ1bmdsaWdhIHbDpHJkZW5hIGbDtnIgbGp1c3N0eXJrYSDDpXRlcnNrYXBhcyBmcsOlbiBiaWxkdsOkcmRlbmEgZ2Vub20gYXR0IHbDpG5kYSBww6UgZsO2cnN0w6Rya25pbmdzZWt2YXRpb25lcm5hLiBEZW4gYW5kcmEga29ycmlnZXJpbmdlbiBhdnNlciBza2lsbG5hZGVyIGkgc29sdmlua2VsIG9jaCBsanVzc3R5cmthLiBEZSB1cnNwcnVuZ2xpZ2EgdsOkcmRlbmEgZsO2ciBsanVzc3R5cmthIGp1c3RlcmFzIHRpbGwgZXR0IHZhbmxpZ3QgbGp1c2bDtnJow6VsbGFuZGUgZ2Vub20gYXR0IG5vcm1hbGlzZXJhIHNjZW5lciBzb20gZsOlbmdhdHMgdW5kZXIgdmFyaWVyYW5kZSBiZWx5c25pbmcuIE1lZGFuIHV0ZGF0YSBmw7ZyIGJpbGRlciBpIHJlZ2VsIMOkciBhdiBzYW1tYSB0eXAgc29tIGluZGF0YSBmw7ZyIGJpbGRlciwgw6RyIHbDpHJkZW5hIGbDtnIgdXRkYXRhIGzDpGdyZSDDpG4gdsOkcmRlbmEgZsO2ciBpbmRhdGEgb2NoIGtsaXBwcyB0aWxsIGdpbHRpZ3QgZGF0YWludGVydmFsbC48L2Rpdj5cIixcblx0XHRhcmdTdGF0aXN0aWNzTmFtZTogXCJBcmdTdGF0aXN0aWNzXCIsXG5cdFx0YXJnU3RhdGlzdGljc1NuaXA6IFwiQmVyw6RrbmFyIGFyZy1zdGF0aXN0aWssIGlua2x1c2l2ZSBBcmcgTWF4LCBBcmcgTWluLCBBcmcgTWVkaWFuIG9jaCBWYXJha3RpZ2hldC5cIixcblx0XHRhcmdTdGF0aXN0aWNzRGVzYzogXCJGdW5rdGlvbmVuIGJlcsOka25hciBhcmctc3RhdGlzdGlrLiBEZXQgZmlubnMgZnlyYSBtZXRvZGVyIGkgQXJnU3RhdGlzdGljcy1mdW5rdGlvbmVuOiBBcmdNYXgsIEFyZ01pbiwgQXJnTWVkaWFuIG9jaCBEdXJhdGlvbi5cIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0bWV0aXNrdFwiLFxuXHRcdGFyaXRobWV0aWNTbmlwOiBcIlV0ZsO2ciBlbiBhcml0bWV0aXNrIMOldGfDpHJkIG1lbGxhbiB0dsOlIHJhc3RlciBlbGxlciBldHQgcmFzdGVyIG9jaCBlbiBza2Fsw6RyLlwiLFxuXHRcdGFyaXRobWV0aWNEZXNjOiBcIkRlbiBhcml0bWV0aXNrYSBmdW5rdGlvbmVuIHV0ZsO2ciBlbiBhcml0bWV0aXNrIMOldGfDpHJkIG1lbGxhbiB0dsOlIHJhc3RlciBlbGxlciBldHQgcmFzdGVyIG9jaCBlbiBza2Fsw6RyIG9jaCB2aWNlIHZlcnNhLlwiLFxuXHRcdGFzcGVjdFNsb3BlTmFtZTogXCJSaWt0bmluZ+KAk2x1dG5pbmdcIixcblx0XHRhc3BlY3RTbG9wZVNuaXA6IFwiU2thcGFyIGV0dCByYXN0ZXIgc29tIHNhbXRpZGlndCB2aXNhciByaWt0bmluZyBvY2ggbHV0bmluZyBmw7ZyIGVuIGtvbnRpbnVlcmxpZyB5dGEsIGVubGlndCByZXByZXNlbnRhdGlvbmVuIGkgZW4gZGlnaXRhbCBow7ZqZG1vZGVsbC5cIixcblx0XHRhc3BlY3RTbG9wZURlc2M6IFwiUmlrdG5pbmfigJNsdXRuaW5nLWZ1bmt0aW9uZW4gc2thcGFyIGV0dCByYXN0ZXJsYWdlciBzb20gc2FtdGlkaWd0IHZpc2FyIGFzcGVrdGVuIG9jaCBsdXRuaW5nZW4gZsO2ciBlbiB5dGEuIEFzcGVrdGVuIGlkZW50aWZpZXJhciBsdXRuaW5nc3Jpa3RuaW5nZW4gbmVkw6V0IGbDtnIgZGVuIHN0w7Zyc3RhIHbDpHJkZXNraWxsbmFkZW4gZnLDpW4gZW4gcGl4ZWwgdGlsbCBhbnNsdXRhbmRlIHBpeGxhci4gRHUga2FuIHTDpG5rYSBkaWcgYXNwZWt0ZW4gc29tIGx1dG5pbmdzcmlrdG5pbmdlbi4gVsOkcmRlbmEgaSB1dGRhdGFyYXN0cmV0IMOkciBhc3Bla3RlbnMga29tcGFzc3Jpa3RuaW5nIHNvbSB2aXNhcyBnZW5vbSBlbiBueWFucyAoZsOkcmcpLiBMdXRuaW5nZW4gcmVwcmVzZW50ZXJhciDDpG5kcmluZ3NmcmVrdmVuc2VuIGbDtnIgaMO2amQgZsO2ciB2YXJqZSBwaXhlbCBpIGRlbiBkaWdpdGFsYSBow7ZqZG1vZGVsbGVuIChERU0pLiBMdXRuaW5nZW4gcmVwcmVzZW50ZXJhciB5dGFucyBsdXRuaW5nIG9jaCBzeW1ib2xpc2VyYXMgYXYgdHJlIGtsYXNzZXIgc29tIHZpc2FzIGdlbm9tIGbDpHJnbcOkdHRuYWQgKGxqdXNzdHlya2EpLjxkaXY+PGJyLz5QaXhlbHbDpHJkZW5hIGkgdXRkYXRhcmFzdHJldCBmw7ZyIHJpa3RuaW5n4oCTbHV0bmluZyB2aXNhciBlbiBrb21iaW5hdGlvbiBhc3Bla3Qgb2NoIGx1dG5pbmcuIFBpeGxhciBtZWQgdsOkcmRlbiB1bmRlciAyMCByw6RrbmFzIHNvbSBwbGFuYSBvY2ggdmlzYXMgaSBncsOldHQuIFJpa3RuaW5n4oCTbHV0bmluZy12w6RyZGVuIHDDpSAyMSBvY2ggw7Z2ZXIgdmlzYXMgbWVkIG9saWthIGbDpHJnbcOkdHRuYWQgbWVkIGbDtmxqYW5kZSBpbmRlbG5pbmc6IDIxIHRpbGwgMzAg4oCURsOkcmdtw6R0dG5hZCBmw7ZyIGxpdGVuIGx1dG5pbmcsIDMxIHRpbGwgNDDigJRGw6RyZ23DpHR0bmFkIGbDtnIgbcOldHRsaWcgbHV0bmluZywgNDEgb2NoIMO2dmVy4oCURsOkcmdtw6R0dG5hZCBmw7ZyIGjDtmcgbHV0bmluZzwvZGl2PlwiLFxuXHRcdGFzcGVjdE5hbWU6IFwiTHV0bmluZ3NyaWt0bmluZ1wiLFxuXHRcdGFzcGVjdFNuaXA6IFwiVmlzYXIgw6V0IHZpbGtldCBow6VsbCBlbiBwaXhlbCDDpHIgdsOkbmQsIGTDpHIgMCDDpHIgcmFrdCBub3JydXQgb2NoIHZpbmtsYXJuYSDDtmthcyBtZWR1cnMgdGlsbCAzNjAuXCIsXG5cdFx0YXNwZWN0RGVzYzogXCJBc3Bla3RmdW5rdGlvbmVuIGlkZW50aWZpZXJhciBsdXRuaW5nZW5zIHJpa3RuaW5nIGbDtnIgZGVuIGjDtmdzdGEgZ3JhZGVuIGF2IHNraWxsbmFkIGkgdsOkcmRlbiBmcsOlbiBlbiBjZWxsIHRpbGwgYW5zbHV0YW5kZSBjZWxsZXIuIER1IGthbiB0w6Rua2EgZGlnIGFzcGVrdGVuIHNvbSBsdXRuaW5nc3Jpa3RuaW5nZW4uIFbDpHJkZW5hIGkgdXRkYXRhcmFzdHJldCDDpHIgYXNwZWt0ZW5zIGtvbXBhc3NyaWt0bmluZy48ZGl2Pjxici8+SW5kYXRhIGbDtnIgZGVuIGjDpHIgZnVua3Rpb25lbiDDpHIgaW5kYXRhcmFzdHJldC4gQXNwZWt0ZnVua3Rpb25lbiBhbnbDpG5kcyBvZnRhIHDDpSBlbiBkaWdpdGFsIGjDtmpkbW9kZWxsIChERU0pLiBTb20gc3RhbmRhcmQgdmlzYXMgYXNwZWt0ZW4gc29tIGVuIGJpbGQgaSBncsOlc2thbGEuIER1IGthbiBsw6RnZ2EgdGlsbCBmdW5rdGlvbmVuIGbDpHJnc2NoZW1hIGbDtnIgYXR0IGFuZ2UgZXR0IHPDpHJza2lsdCBmw6RyZ3NjaGVtYSBlbGxlciBsw6V0YSBwZXJzb25lbiBzb20gdmlzYXIgbW9zYWlrZW4gw6RuZHJhIHN5bWJvbG9naW4gbWVkIHNpdHQgZWdldCBmw6RyZ3NjaGVtYS48L2Rpdj5cIixcblx0XHR0YWJsZU5hbWU6IFwiQXR0cmlidXR0YWJlbGxcIixcblx0XHR0YWJsZVNuaXA6IFwiQW52w6RuZGVyIGVuIHRhYmVsbCBmw7ZyIGF0dCBuYW1uZ2Ugb2NoIHN5bWJvbGlzZXJhIHbDpHJkZW5hIGkgZXR0IGRhdGFzZXQuIEtvbHVtbmVyIGbDtnIgdGFiZWxsZW4gYXZncsOkbnNhcyBtZWQga29tbWF0ZWNrZW46IFBpeGVsVmFsdWUsIEF0dHJpYnV0ZU5hbWUsIFJlZFZhbHVlLCBHcmVlblZhbHVlLCBCbHVlVmFsdWUuXCIsXG5cdFx0dGFibGVEZXNjOiBcIkZ1bmt0aW9uZW4gYXR0cmlidXR0YWJlbGwgZ8O2ciBhdHQgZHUga2FuIGRlZmluaWVyYSBlbiBhdHRyaWJ1dHRhYmVsbCBmw7ZyIGF0dCBzeW1ib2xpc2VyYSBldHQgbW9zYWlrZGF0YXNldCBlbGxlciByYXN0ZXJkYXRhc2V0IG1lZCBldHQgYmFuZC4gPGRpdj48YnIvPkRldHRhIMOkciBhbnbDpG5kYmFydCBuw6RyIGR1IHZpbGwgcHJlc2VudGVyYSBiaWxkZXIgc29tIGhhciBrbGFzc2lmaWNlcmF0cyBmw7ZyIG1hcmthbnbDpG5kbmluZywgdGlsbCBleGVtcGVsIHNrb2dzbWFyaywgdsOldG1hcmssIMOla2VybWFyayBvY2ggc3RhZHNtYXJrLiBPbSBkaW4gdGFiZWxsIGlubmVow6VsbGVyIGbDpGx0IHNvbSBuYW1uZ2VzIHNvbSByw7ZkYSwgZ3LDtm5hIG9jaCBibMOlIGtvbW1lciBkZXNzdXRvbSB2w6RyZGVuIGlub20gZGUgZsOkbHRlbiBhdHQgYW52w6RuZGFzIHNvbSBlbiBmw6RyZ2thcnRhIG7DpHIgYmlsZGVuIHJlbmRlcmFzLjwvZGl2PlwiLFxuXHRcdGJhbmRBcml0aG1ldGljTmFtZTogXCJCYW5kIGFyaXRtZXRpc2t0XCIsXG5cdFx0YmFuZEFyaXRobWV0aWNTbmlwOiBcIkJlcsOka25hciBpbmRleCBtZWQgaGrDpGxwIGF2IGbDtnJkZWZpbmllcmFkZSBmb3JtbGVyIGVsbGVyIGV0dCBhbnbDpG5kYXJkZWZpbmllcmF0IHV0dHJ5Y2suXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNEZXNjOiBcIkZ1bmt0aW9uZW4gQmFuZCBhcml0bWV0aXNrdCB1dGbDtnIgZW4gYXJpdG1ldGlzayDDpXRnw6RyZCBww6UgYmFuZGVuIGbDtnIgZXR0IHJhc3RlcmRhdGFzZXQuIER1IGthbiB2w6RsamEgZsO2cmRlZmluaWVyYWRlIGFsZ29yaXRtZXIgZWxsZXIgYW5nZSBkaW4gZWdlbiBlbnJhZGlnYSBmb3JtZWwuIE9wZXJhdG9yZXJuYSBzb20gc3TDtmRzIMOkciAtLCssLywqLCBvY2ggZW5zdMOkbGxpZyAtLlwiLFxuXHRcdHRocmVzaG9sZE5hbWU6IFwiQmluw6RydCB0csO2c2tlbHbDpHJkZVwiLFxuXHRcdHRocmVzaG9sZFNuaXA6IFwiT3JkbmFyIGtvbnRpbnVlcmxpZ2EgZGF0YSBpIGbDtnJncnVuZCBvY2ggYmFrZ3J1bmQgZ2Vub20gYXR0IG1pbmltZXJhIGtvdmFyaWFuc2VuIG1lbGxhbiBkZSBiw6VkYSBrbGFzc2VybmEuXCIsXG5cdFx0dGhyZXNob2xkRGVzYzogXCJOw6RyIGV0dCByYXN0ZXJkYXRhc2V0IGhhciBlbiBiaW1vZGFsIGbDtnJkZWxuaW5nLCBza2FwYXIgZGVuIGjDpHIgZnVua3Rpb25lbiBldHQgbnl0dCByYXN0ZXIgc29tIGRlbGFyIGluIGRhdGEgaSB0dsOlIGRpc3Rpbmt0YSBrbGFzc2VyLiBEZW4gc2thcGFyIGVuIGtsYXNzIG1lZCBsw6VnYSB2w6RyZGVuIG1lZCBzdmFydGEgcGl4bGFyLCBvY2ggZW4ga2xhc3MgbWVkIGjDtmdhIHbDpHJkZW4gc29tIHZpc2FzIG1lZCB2aXRhIHBpeGxhci5cIixcblx0XHRiaXR3aXNlQW5kTmFtZTogXCJCaXR2aXN0IEFuZFwiLFxuXHRcdGJpdHdpc2VBbmRTbmlwOiBcIlV0ZsO2ciBlbiBiaXR2aXMgQW5kLcOldGfDpHJkIHDDpSBkZSBiaW7DpHJhIHbDpHJkZW5hIGkgdHbDpSBpbmRhdGFyYXN0ZXIuXCIsXG5cdFx0Yml0d2lzZUFuZERlc2M6IFwiQml0dmlzIEFuZCB1dGbDtnIgZW4gYml0dmlzIEFuZC3DpXRnw6RyZCBww6UgZGUgYmluw6RyYSB2w6RyZGVuYSBpIHR2w6UgaW5kYXRhcmFzdGVyXCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdE5hbWU6IFwiQml0dmlzdCB2w6Ruc3RlcnNraWZ0XCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdFNuaXA6IFwiVXRmw7ZyIGVuIGJpdHZpcyB2w6Ruc3RlcnNraWZ0c8OldGfDpHJkIHDDpSBkZSBiaW7DpHJhIHbDpHJkZW5hIGkgdHbDpSBpbmRhdGFyYXN0ZXIuXCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdERlc2M6IFwiQml0dmlzIHbDpG5zdGVyc2tpZnQgdXRmw7ZyIGVuIGJpdHZpcyB2w6Ruc3RlcnNraWZ0c8OldGfDpHJkIHDDpSBkZSBiaW7DpHJhIHbDpHJkZW5hIGkgdHbDpSBpbmRhdGFyYXN0ZXIuXCIsXG5cdFx0Yml0d2lzZU5vdE5hbWU6IFwiQml0dmlzdCBOb3RcIixcblx0XHRiaXR3aXNlTm90U25pcDogXCJVdGbDtnIgZW4gYml0dmlzIE5vdC3DpXRnw6RyZCAoa29tcGxlbWVudCkgcMOlIGRldCBiaW7DpHJhIHbDpHJkZXQgaSB0dsOlIGluZGF0YXJhc3Rlci5cIixcblx0XHRiaXR3aXNlTm90RGVzYzogXCJGdW5rdGlvbmVuIHV0ZsO2ciBlbiBiaXR2aXMgTm90LcOldGfDpHJkIChrb21wbGVtZW50KSBww6UgZGV0IGJpbsOkcmEgdsOkcmRldCBpIGV0dCBpbmRhdGFyYXN0ZXIuXCIsXG5cdFx0Yml0d2lzZU9yTmFtZTogXCJCaXR2aXN0IE9yXCIsXG5cdFx0Yml0d2lzZU9yU25pcDogXCJVdGbDtnIgZW4gYml0dmlzIE9yLcOldGfDpHJkIHDDpSBkZSBiaW7DpHJhIHbDpHJkZW5hIGkgdHbDpSBpbmRhdGFyYXN0ZXIuXCIsXG5cdFx0Yml0d2lzZU9yRGVzYzogXCJGdW5rdGlvbmVuIHV0ZsO2ciBlbiBiaXR2aXMgT3Itw6V0Z8OkcmQgcMOlIGRlIGJpbsOkcmEgdsOkcmRlbmEgaSB0dsOlIGluZGF0YXJhc3Rlci4gXCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnROYW1lOiBcIkJpdHZpc3QgaMO2Z2Vyc2tpZnRcIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdFNuaXA6IFwiVXRmw7ZyIGVuIGJpdHZpcyBow7ZnZXJza2lmdHPDpXRnw6RyZCBww6UgZGUgYmluw6RyYSB2w6RyZGVuYSBpIHR2w6UgaW5kYXRhcmFzdGVyLlwiLFxuXHRcdGJpdHdpc2VSaWdodFNoaWZ0RGVzYzogXCJGdW5rdGlvbmVuIHV0ZsO2ciBlbiBiaXR2aXMgaMO2Z2Vyc2tpZnRzw6V0Z8OkcmQgcMOlIGRlIGJpbsOkcmEgdsOkcmRlbmEgaSB0dsOlIGluZGF0YXJhc3Rlci5cIixcblx0XHRiaXR3aXNlWG9yTmFtZTogXCJCaXR2aXN0IFhvclwiLFxuXHRcdGJpdHdpc2VYb3JTbmlwOiBcIlV0ZsO2ciBlbiBiaXR2aXMgZVhjbHVzaXZlIE9yLcOldGfDpHJkIHDDpSBkZSBiaW7DpHJhIHbDpHJkZW5hIGkgdHbDpSBpbmRhdGFyYXN0ZXIuXCIsXG5cdFx0Yml0d2lzZVhvckRlc2M6IFwiRnVua3Rpb25lbiB1dGbDtnIgZW4gYml0dmlzIGVYY2x1c2l2ZSBJci3DpXRnw6RyZCBww6UgZGUgYmluw6RyYSB2w6RyZGVuYSBpIHR2w6UgaW5kYXRhcmFzdGVyXCIsXG5cdFx0Ym9vbGVhbkFuZE5hbWU6IFwiQm9vbGVza3QgQW5kXCIsXG5cdFx0Ym9vbGVhbkFuZFNuaXA6IFwiVXRmw7ZyIGVuIGJvb2xlc2sgQW5kLcOldGfDpHJkIHDDpSBjZWxsdsOkcmRlbmEgaSB0dsOlIGluZGF0YXJhc3Rlci4gT20gYsOlZGEgaW5kYXRhdsOkcmRlbmEgw6RyIHNhbm5hIChlaiBub2xsKSwgw6RyIHV0ZGF0YXbDpHJkZXQgMS4gT20gZGV0IGVuYSBlbGxlciBiw6VkYSBpbmRhdGEgw6RyIGZhbHNrYSAobm9sbCksIMOkciB1dGRhdGF2w6RyZGV0IDAuXCIsXG5cdFx0Ym9vbGVhbkFuZERlc2M6IFwiRnVua3Rpb25lbiB1dGbDtnIgZW4gYm9vbGVzayBBbmQtw6V0Z8OkcmQgcMOlIGRlIHBpeGVsdsOkcmRlbmEgaSB0dsOlIGluZGF0YXJhc3Rlci4gT20gYsOlZGEgaW5kYXRhdsOkcmRlbmEgw6RyIHNhbm5hIChlaiBub2xsKSwgw6RyIHV0ZGF0YXbDpHJkZXQgMS4gT20gZGV0IGVuYSBlbGxlciBiw6VkYSBpbmRhdGF2w6RyZGVuYSDDpHIgZmFsc2thIChub2xsKSwgw6RyIHV0ZGF0YXbDpHJkZXQgMC4gXCIsXG5cdFx0Ym9vbGVhbk5vdE5hbWU6IFwiQm9vbGVza3QgTm90XCIsXG5cdFx0Ym9vbGVhbk5vdFNuaXA6IFwiVXRmw7ZyIGVuIGJvb2xlc2sgTm90LcOldGfDpHJkIChrb21wbGVtZW50KSBww6UgY2VsbHbDpHJkZW5hIGkgaW5kYXRhcmFzdHJldC4gT20gaW5kYXRhdsOkcmRlbmEgw6RyIHNhbm5hIChlaiBub2xsKSwgw6RyIHV0ZGF0YXbDpHJkZXQgMC4gT20gaW5kYXRhdsOkcmRlbmEgw6RyIGZhbHNrYSAobm9sbCksIMOkciB1dGRhdGF2w6RyZGV0IDEuXCIsXG5cdFx0Ym9vbGVhbk5vdERlc2M6IFwiRnVua3Rpb25lbiB1dGbDtnIgZW4gYm9vbGVzayBOb3Qtw6V0Z8OkcmQgKGtvbXBsZW1lbnQpIHDDpSBwaXhlbHbDpHJkZW5hIGkgaW5kYXRhcmFzdHJldC4gT20gaW5kYXRhdsOkcmRlbmEgw6RyIHNhbm5hIChlaiBub2xsKSwgw6RyIHV0ZGF0YXbDpHJkZXQgMC4gT20gaW5kYXRhdsOkcmRlbmEgw6RyIGZhbHNrYSAobm9sbCksIMOkciB1dGRhdGF2w6RyZGV0IDEuXCIsXG5cdFx0Ym9vbGVhbk9yTmFtZTogXCJCb29sZXNrdCBPclwiLFxuXHRcdGJvb2xlYW5PclNuaXA6IFwiVXRmw7ZyIGVuIGJvb2xlc2sgT3Itw6V0Z8OkcmQgcMOlIGNlbGx2w6RyZGVuYSBpIGRlIHR2w6UgaW5kYXRhcmFzdHJlbi4gT20gZGV0IGVuYSBlbGxlciBiw6VkYSBpbmRhdGF2w6RyZGVuYSDDpHIgc2FubmEgKGVqIG5vbGwpLCDDpHIgdXRkYXRhdsOkcmRldCAxLiBPbSBiw6VkYSBpbmRhdGF2w6RyZGVuYSDDpHIgZmFsc2thIChub2xsKSwgw6RyIHV0ZGF0YXbDpHJkZXQgMC5cIixcblx0XHRib29sZWFuT3JEZXNjOiBcIkZ1bmt0aW9uZW4gdXRmw7ZyIGVuIGJvb2xlc2sgT3Itw6V0Z8OkcmQgcMOlIGNlbGx2w6RyZGVuYSBpIHR2w6UgaW5kYXRhcmFzdGVyLiBPbSBkZXQgZW5hIGVsbGVyIGLDpWRhIGluZGF0YXbDpHJkZW5hIMOkciBzYW5uYSAoZWogbm9sbCksIMOkciB1dGRhdGF2w6RyZGV0IDEuIE9tIGLDpWRhIGluZGF0YXbDpHJkZW5hIMOkciBmYWxza2EgKG5vbGwpLCDDpHIgdXRkYXRhdsOkcmRldCAwLlwiLFxuXHRcdGJvb2xlYW5Yb3JOYW1lOiBcIkJvb2xlc2t0IFhvclwiLFxuXHRcdGJvb2xlYW5Yb3JTbmlwOiBcIlV0ZsO2ciBlbiBib29sZXNrIGVYY2x1c2l2ZSBPci3DpXRnw6RyZCBww6UgY2VsbHbDpHJkZW5hIGkgdHbDpSBpbmRhdGFyYXN0ZXIuIE9tIGV0dCBpbmRhdGF2w6RyZGUgw6RyIHNhbnQgKGVqIG5vbGwpIG9jaCBkZXQgYW5kcmEgZmFsc2t0IChub2xsKSwgw6RyIHV0ZGF0YXbDpHJkZXQgMS4gT20gYsOlZGEgaW5kYXRhdsOkcmRlbmEgw6RyIHNhbm5hIGVsbGVyIGLDpWRhIMOkciBmYWxza2EsIMOkciB1dGRhdGF2w6RyZGV0IDAuXCIsXG5cdFx0Ym9vbGVhblhvckRlc2M6IFwiRnVua3Rpb25lbiB1dGbDtnIgZW4gYm9vbGVzayBlWGNsdXNpdmUgT3Itw6V0Z8OkcmQgcMOlIGNlbGx2w6RyZGVuYSBpIHR2w6UgaW5kYXRhcmFzdGVyLiBPbSBldHQgaW5kYXRhdsOkcmRlIMOkciBzYW50IChlaiBub2xsKSBvY2ggZGV0IGFuZHJhIHbDpHJkZXQgw6RyIGZhbHNrdCAobm9sbCksIMOkciB1dGRhdGF2w6RyZGV0IDEuIE9tIGLDpWRhIGluZGF0YXbDpHJkZW5hIMOkciBzYW5uYSBlbGxlciBiw6VkYSDDpHIgZmFsc2thLCDDpHIgdXRkYXRhdsOkcmRldCAwLlwiLFxuXHRcdGJ1ZmZlcmVkUmFzdGVyTmFtZTogXCJCdWZmcmFkXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJTbmlwOiBcIkJ1ZmZyYXIgc2VuYXN0IGFudsOkbmRhIHBpeGVsYmxvY2suXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJEZXNjOiBcIkRlbiBidWZmcmFkZSBmdW5rdGlvbmVuIGFudsOkbmRzIGbDtnIgYXR0IG9wdGltZXJhIHByZXN0YW5kYSBob3Mga29tcGxleGEgZnVua3Rpb25za2Vkam9yLiBEZW4gbGFncmFyIHV0ZGF0YSBpIG1pbm5ldCBmw7ZyIGRlbiBkZWwgYXYgZnVua3Rpb25za2VkamFuIHNvbSBrb21tZXIgZsO2cmUuIDxkaXY+PGJyLz5JbmZvZ2EgZGVuIGjDpHIgZnVua3Rpb25lbiBpIGZ1bmt0aW9uc3JlZGlnZXJhcmVuIGTDpHIgZHUgdmlsbCBsYWdyYSB1dGRhdGEuPC9kaXY+XCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvck5hbWU6IFwiTWluaXLDpGtuYXJlXCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvclNuaXA6IFwiQmVyw6RrbmFyIGV0dCByYXN0ZXIgZnLDpW4gZXR0IHJhc3RlcmJhc2VyYXQgbWF0ZW1hdGlza3QgdXR0cnljay5cIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yRGVzYzogXCJLYWxreWxhdG9yZnVua3Rpb25lbiBnw7ZyIGF0dCBkdSBrYW4gc2thcGEgb2NoIGvDtnJhIHV0dHJ5Y2sgb2NoIGhhIG1lZCBkZW0gaSBmdW5rdGlvbnNrZWRqb3IuXCIsXG5cdFx0Y2VsbFN0YXRpc3RpY3NOYW1lOiBcIkNlbGxzdGF0aXN0aWtcIixcblx0XHRjZWxsU3RhdGlzdGljc1NuaXA6IFwiQmVyw6RrbmFyIHN0YXRpc3RpayBwZXIgY2VsbCBmcsOlbiBmbGVyYSByYXN0ZXIuIERlIHRpbGxnw6RuZ2xpZ2Egc3RhdGlzdGlza2Ega2F0ZWdvcmllcm5hIMOkciBNYWpvcml0ZXQsIE1heGltdW0sIE1lZGVsLCBNZWRpYW4sIE1pbmltdW0sIE1pbm9yaXRldCwgUHJvY2VudHNhdHMsIEludGVydmFsbCwgU3RhbmRhcmRhdnZpa2Vsc2UsIFN1bW1hIG9jaCBWYXJpYXRpb24uXCIsXG5cdFx0Y2VsbFN0YXRpc3RpY3NEZXNjOiBcIkRlbiBow6RyIGZ1bmt0aW9uZW4gYmVyw6RrbmFyIHN0YXRpc3RpayBmcsOlbiBmbGVyYSByYXN0ZXIsIHBpeGVsIGbDtnIgcGl4ZWwuIERlIHRpbGxnw6RuZ2xpZ2Egc3RhdGlzdGlza2Ega2F0ZWdvcmllcm5hIMOkciBNYWpvcml0ZXQsIE1heGltdW0sIE1lZGVsLCBNZWRpYW4sIE1pbmltdW0sIE1pbm9yaXRldCwgSW50ZXJ2YWxsLCBTdGFuZGFyZGF2dmlrZWxzZSwgU3VtbWEgb2NoIFZhcmlhdGlvbi5cIixcblx0XHRjbGFzc2lmeU5hbWU6IFwiS2xhc3NpZmljZXJhXCIsXG5cdFx0Y2xhc3NpZnlTbmlwOiBcIlRpbGxkZWxhciB2YXJqZSBwaXhlbCB0aWxsIGVuIGtsYXNzLiBMw6RnZyB0aWxsIHVuZGVyb3JkbmFkZSBkYXRhLCB0LmV4LiBlbiBzZWdtZW50ZXJhZCBiaWxkLlwiLFxuXHRcdGNsYXNzaWZ5RGVzYzogXCJEZW4gaMOkciByYXN0ZXJmdW5rdGlvbmVuIGtsYXNzaWZpY2VyYXIgZXR0IHJhc3RlcmRhdGFzZXQgYmFzZXJhdCBww6UgZW4gZGVmaW5pdGlvbnNmaWwgZsO2ciBFc3JpLWtsYXNzaWZpY2VyYXJlICguZWNkKSBvY2ggaW5kYXRhIGZyw6VuIHJhc3RlcmRhdGFzZXQuIERlbiAuZWNkLWZpbCBzb20gYW52w6RuZHMgaSBrbGFzc2lmaWNlcmluZ3NmdW5rdGlvbmVuIGlubmVow6VsbGVyIGFsbCBpbmZvcm1hdGlvbiBmw7ZyIGV0dCBzcGVjaWZpa3QgZGF0YXNldCBvY2ggZW4gc3BlY2lmaWsga2xhc3NpZmljZXJhcmUsIG9jaCBnZW5lcmVyYXMgYXYgdXRiaWxkbmluZ3N2ZXJrdHlnZW4gZsO2ciBrbGFzc2lmaWNlcmluZywgc29tIFTDpWdldHMgc3TDtmR2ZWt0b3JtYXNraW4gb2NoIFTDpWdldHMgc2x1bXBtw6Rzc2lnYSB0csOkZC5cIixcblx0XHRjbGlwTmFtZTogXCJLbGlwcFwiLFxuXHRcdGNsaXBTbmlwOiBcIkFuZ2VyIGV0dCByYXN0ZXJzIHV0YnJlZG5pbmcgbWVkIGtvb3JkaW5hdGVyIGVsbGVyIGV0dCBhbm5hdCBkYXRhc2V0LlwiLFxuXHRcdGNsaXBEZXNjOiBcIkRlbiBow6RyIGZ1bmt0aW9uZW4ga2xpcHBlciBldHQgcmFzdGVyIG1lZCBlbiByZWt0YW5ndWzDpHIgZm9ybSBpIGVubGlnaGV0IG1lZCBkZW4gZGVmaW5pZXJhZGUgdXRicmVkbmluZ2VuLCBlbGxlciBrbGlwcGVyIGV0dCByYXN0ZXIgdGlsbCBmb3JtZW4gYXYgZW4gcG9seWdvbmdlb29iamVrdHNrbGFzcyBmw7ZyIGluZGF0YS4gRm9ybWVuIHNvbSBkZWZpbmllcmFyIGtsaXBwZXQga2FuIGtsaXBwYSByYXN0cmV0cyB1dGJyZWRuaW5nIGVsbGVyIGtsaXBwYSB1dCBldHQgb21yw6VkZSBpbm9tIHJhc3RyZXQuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25OYW1lOiBcIkbDpHJnbW9kZWxsa29udmVydGVyaW5nXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25TbmlwOiBcIktvbnZlcnRlcmFyIGV0dCByYXN0ZXIgZnLDpW4gUkdCIHRpbGwgSFNWIG9jaCB2aWNlIHZlcnNhLlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uRGVzYzogXCJGdW5rdGlvbmVuIEbDpHJnbW9kZWxsa29udmVydGVyaW5nIGtvbnZlcnRlcmFyIGVuIGJpbGRzIGbDpHJnbW9kZWxsIGZyw6VuIGbDpHJnb21yw6VkZXQgbnlhbnMsIG3DpHR0bmFkIG9jaCB2w6RyZGUgKEhTVikgdGlsbCByw7Z0dCwgZ3LDtm50IG9jaCBibMOldHQgKFJHQiksIGVsbGVyIHZpY2UgdmVyc2EuPGRpdj48YnIvPkRlbiBow6RyIGZ1bmt0aW9uZW4ga2FuIGFudsOkbmRhcyBpIGV0dCBtb3NpYWtkYXRhc2V0LjwvZGl2PlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JOYW1lOiBcIkbDpHJnc2NoZW1hIHRpbGwgUkdCXCIsXG5cdFx0Y29sb3JtYXBUb1JHQlNuaXA6IFwiS29udmVydGVyYXIgZXR0IHJhc3RlciBtZWQgZXR0IGJhbmQgbWVkIGV0dCBmw6RyZ3NjaGVtYSwgdGlsbCBldHQgcmFzdGVyIG1lZCB0cmUgYmFuZCAocsO2dHQsIGdyw7ZudCBvY2ggYmzDpXR0KS5cIixcblx0XHRjb2xvcm1hcFRvUkdCRGVzYzogXCJEZW4gaMOkciBmdW5rdGlvbmVuIGtvbnZlcnRlcmFyIHJhc3RlciBtZWQgZXR0IGJhbmQgbWVkIGV0dCBmw6RyZ3NjaGVtYSB0aWxsIGV0dCByYXN0ZXIgbWVkIHRyZSBiYW5kIChyw7Z0dCwgZ3LDtm50IG9jaCBibMOldHQpLjxkaXY+PGJyLz5EZW4gaMOkciBmdW5rdGlvbmVuIMOkciBhbnbDpG5kYmFyIG7DpHIgZHUgYmVow7Z2ZXIgc2thcGEgZXR0IHJhc3RlciBtZWQgdHJlIGJhbmQgZnLDpW4gZXR0IHJhc3RlciBtZWQgZXR0IGJhbmQgbWVkIHRpbGxow7ZyYW5kZSBmw6RyZ2thcnRhLiBWw6RyZGVuYSBpIGbDpHJna2FydGFuIGFudsOkbmRzIGbDtnIgYXR0IHNrYXBhIHZhcmplIHLDtnR0LCBncsO2bnQgb2NoIGJsw6V0dCBiYW5kLiBEZW4gaMOkciBmdW5rdGlvbmVuIGthbiBhbnbDpG5kYXMgaSBldHQgbW9zaWFrZGF0YXNldC48L2Rpdj5cIixcblx0XHRjb2xvcm1hcE5hbWU6IFwiRsOkcmdzY2hlbWFcIixcblx0XHRjb2xvcm1hcFNuaXA6IFwiw4RuZHJhciBwaXhlbHbDpHJkZW5hIHPDpSBhdHQgcmFzdGVyZGF0YSB2aXNhcyBhbnRpbmdlbiBzb20gZ3LDpXNrYWxhIGVsbGVyIHNvbSBlbiBSR0ItYmlsZCAocsO2dHQsIGdyw7ZudCwgYmzDpXR0KSwgYmFzZXJhdCBww6UgZXR0IGbDpHJnc2NoZW1hIGVsbGVyIGVuIGbDpHJncmFtcC5cIixcblx0XHRjb2xvcm1hcERlc2M6IFwiRnVua3Rpb25lbiBGw6RyZ3NjaGVtYSDDpHIgZW4gdHlwIGF2IHJlbmRlcmFyZSBhdiByYXN0ZXJkYXRhLiBEZW4gb212YW5kbGFyIHBpeGVsdsOkcmRlbmEgc8OlIGF0dCBkZSB2aXNhciByYXN0ZXJkYXRhIGFudGluZ2VuIHNvbSBlbiBncsOlc2thbGEgZWxsZXIgZW4gUkdCLWbDpHJnYmlsZCBiYXNlcmFkIHDDpSBldHQgZsOkcmdzY2hlbWEgZWxsZXIgc3BlY2lmaWthIGbDpHJnZXIgaSBlbiBmaWwgbWVkIGbDpHJnc2NoZW1hLiBFdHQgZsOkcmdzY2hlbWEga2FuIGFudsOkbmRhcyB0aWxsIGF0dCByZXByZXNlbnRlcmEgYW5hbHlzZXJhZGUgZGF0YSwgdGlsbCBleGVtcGVsIGVuIGtsYXNzaWZpY2VyYWQgYmlsZCwgZWxsZXIgbsOkciBlbiB0b3BvZ3JhZmlzayBrYXJ0YSB2aXNhcyAoZWxsZXIgZW4gaW5kZXhmw6RyZ3NrYW5uYWQgYmlsZCkuPGRpdj48YnIvPkbDpHJnc2NoZW1hbiBpbm5laMOlbGxlciBlbiB1cHBzw6R0dG5pbmcgdsOkcmRlbiBzb20gw6RyIGtvcHBsYWRlIHRpbGwgZsOkcmdlciBzb20gYW52w6RuZHMgZsO2ciBhdHQga29uc2VrdmVudCB2aXNhIHNhbW1hIGbDpHJnZXIgZsO2ciBldHQgcmFzdGVyIG1lZCBldHQgYmFuZC4gVmFyamUgcGl4ZWx2w6RyZGUgw6RyIGtvcHBsYXQgdGlsbCBlbiBmw6RyZywgZGVmaW5pZXJhZCBzb20gZW4gdXBwc8OkdHRuaW5nIFJHQi12w6RyZGVuLiBGw6RyZ3NjaGVtYW4ga2FuIHN0w7ZkamEgYWxsYSBiaXRkanVwIHV0b20gZmx5dHRhbC4gRGUgc3TDtmRqZXIgb2Nrc8OlIHBvc2l0aXZhIG9jaCBuZWdhdGl2YSB2w6RyZGVuIG9jaCBrYW4gaW5uZWjDpWxsYSBmw6RyZ3NjaGVtYXbDpHJkZW4gc29tIHNha25hcy4gTsOkciBldHQgZGF0YXNldCBtZWQgZXR0IGbDpHJnc2NoZW1hIHNvbSBpbm5laMOlbGxlciBzYWtuYWRlIHbDpHJkZW4gdmlzYXMsIHZpc2FzIGludGUgcGl4bGFybmEgbWVkIGRlIHNha25hZGUgdsOkcmRlbmEuPC9kaXY+XCIsXG5cdFx0Y29tcGxleE5hbWU6IFwiS29tcGxleFwiLFxuXHRcdGNvbXBsZXhTbmlwOiBcIkV4dHJhaGVyYXIgbWFnbml0dWRlbiBmcsOlbiBrb21wbGV4YSB0YWwuXCIsXG5cdFx0Y29tcGxleERlc2M6IFwiRGVuIGjDpHIgZnVua3Rpb25lbiBiZXLDpGtuYXIgbWFnbml0dWQgZnLDpW4ga29tcGxleGEgdsOkcmRlbi48ZGl2Pjxici8+RGVuIGjDpHIgZnVua3Rpb25lbiBhbnbDpG5kcyB2YW5saWd0dmlzIG1lZCBSQURBUi1iaWxkZXIgc29tIGhhciBlbiBrb21wbGV4IGRhdGF0eXAuIERlbiBrYW4gYW52w6RuZGFzIGkgZXR0IG1vc2Fpa2RhdGFzZXQuPC9kaXY+XCIsXG5cdFx0Y29tcG9zaXRlQmFuZE5hbWU6IFwiU2FtbWFuc2F0dGEgYmFuZFwiLFxuXHRcdGNvbXBvc2l0ZUJhbmRTbmlwOiBcIktvbWJpbmVyYXIgZmxlcmEgZGF0YXNldCB0aWxsIGV0dCBmbGVyYmFuZHNyYXN0ZXIuXCIsXG5cdFx0Y29tcG9zaXRlQmFuZERlc2M6IFwiRnVua3Rpb25lbiBTYW1tYW5zYXR0YSBiYW5kIGfDtnIgYXR0IGR1IGthbiBrb21iaW5lcmEgcmFzdGVyIGbDtnIgYXR0IGZvcm1hIGVuIGZsZXJiYW5kc2JpbGQuXCIsXG5cdFx0Y29uTmFtZTogXCJDb25cIixcblx0XHRjb25TbmlwOiBcIlV0ZsO2ciBlbiB2aWxsa29ybGlnIElmLCBUaGVuLCBFbHNlLcOldGfDpHJkLiBOw6RyIGVuIENvbi1vcGVyYXRvciBhbnbDpG5kcyBtw6VzdGUgZGV0IHZhbmxpZ3R2aXMgZmlubmFzIHR2w6UgZWxsZXIgZmxlcmEgZnVua3Rpb25lciBzYW1tYW5rb3BwbGFkZSwgZMOkciBlbiBmdW5rdGlvbiBhbmdlciB2aWxsa29yZW4gb2NoIGRlbiBhbmRyYSBmdW5rdGlvbmVuIMOkciBDb24tb3BlcmF0b3JuIHNvbSBhbnbDpG5kZXIgdmlsbGtvcmVuIG9jaCBhbmdlciB2YWQgc2FubmEgb2NoIGZhbHNrYSB1dGRhdGEgc2thIHZhcmEuXCIsXG5cdFx0Y29uRGVzYzogXCJDb24tZnVua3Rpb25lbiBzdMOkbGxlciBpbiBwaXhsYXJuYSBmw7ZyIHV0ZGF0YXJhc3RyZXQgYmFzZXJhdCBww6UgZW4gaWZcXFxcZWxzZS11dHbDpHJkZXJpbmcgYXYgdmFyamUgaW5kYXRhcGl4ZWwuIERlbiByZXR1cm5lcmFyIHBpeGVsdsOkcmRlbiBmcsOlbiBTYW50IHJhc3RlciBvbSBkZW4gdmlsbGtvcmxpZ2EgdXR2w6RyZGVyaW5nZW4gw6RyIHNhbm4gKDEpIG9jaCByZXR1cm5lcmFyIHBpeGVsdsOkcmRlbmEgZnLDpW4gRmFsc2t0IHJhc3RlciBvbSBkZW4gdmlsbGtvcmxpZ2EgdXR2w6RyZGVyaW5nZW4gw6RyIGZhbHNrICgwKS4gRGV0dGEga3JpdGVyaXVtIHNwZWNpZmljZXJhcyBhdiB1dGRhdGEgZnLDpW4gZW4gbG9naXNrIG1hdGVtYXRpa2Z1bmt0aW9uIHNvbSBibGlyIGluZGF0YXJhc3RyZXQuXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIktvbnN0YW50XCIsXG5cdFx0Y29uc3RhbnRTbmlwOiBcIlNrYXBhciBldHQgdmlydHVlbGx0IHJhc3RlciBtZWQgZXR0IGVuZGEgcGl4ZWx2w6RyZGUuXCIsXG5cdFx0Y29uc3RhbnREZXNjOiBcIkRlbiBow6RyIGZ1bmt0aW9uZW4gc2thcGFyIGV0dCB2aXJ0dWVsbHQgcmFzdGVyIG1lZCBldHQgZW5kYSBwaXhlbHbDpHJkZSBzb20ga2FuIGFudsOkbmRhcyBpIG1hbGxhciBmw7ZyIHJhc3RlcmZ1bmt0aW9uIG9jaCBmw7ZyIGF0dCBiZWhhbmRsYSBldHQgbW9zYWlrZGF0YXNldC48ZGl2Pjxici8+RGV0IGtvbnN0YW50YSB2w6RyZGV0IGFudsOkbmRzIGbDtnIgdmFyamUgcGl4ZWx2w6RyZGUgaSByYXN0cmV0LjwvZGl2PlwiLFxuXHRcdGNvbnRvdXJOYW1lOiBcIkjDtmpka3VydmFcIixcblx0XHRjb250b3VyU25pcDogXCJTa2FwYXIgaMO2amRrdXJ2ZWxpbmplci5cIixcblx0XHRjb250b3VyRGVzYzogXCJIw7ZqZGt1cnZmdW5rdGlvbmVuIGdlbmVyZXJhciBow7ZqZGt1cnZlbGluamVyIGdlbm9tIGF0dCBmw7ZyZW5hIHB1bmt0ZXIgbWVkIHNhbW1hIGjDtmpkIGZyw6VuIGV0dCByYXN0ZXJow7ZqZGRhdGFzZXQuIEjDtmpka3Vydm9ybmEgw6RyIGlzb2xpbmplciBza2FwYWRlIHNvbSByYXN0ZXIgZsO2ciB2aXN1YWxpc2VyaW5nLiBGw7ZsamFuZGUgbnlja2VsZnVua3Rpb25lciBnw7ZyIGRlbiBow6RyIGZ1bmt0aW9uZW4ga3JhZnRmdWxsOiBow7ZqZGt1cnZvciBnZW5lcmVyYXMgc25hYmJ0IG9jaCBkeW5hbWlza3QgcMOlIG15Y2tldCBzdG9yYSBkYXRhc2V0LCBzb20gV29ybGQgRWxldmF0aW9uOyBow7ZqZGt1cnZvciBrYW4gasOkbW5hcyB1dCBmw7ZyIGF0dCBmw6UgZXR0IG1lciB0aWxsdGFsYW5kZSBrYXJ0b2dyYWZpc2t0IHV0c2VlbmRlIHNhbXRpZGlndCBzb20gaMO2amRrdXJ2b3JuYSBmb3J0c8OkdHRlciBhdHQgdmFyYSBrb3JyZWt0YTsgZHluYW1pc2sga29udHJvbGwgw7Z2ZXIgaMO2amRrdXJ2ZWludGVydmFsbGV0OyB1dGRhdGFhbHRlcm5hdGl2IG9tZmF0dGFyIGjDtmpka3VydmVsaW5qZXIsIGluZGV4aMO2amRrdXJ2b3Igb2NoIGlmeWxsZGEgaMO2amRrdXJ2b3IuPGRpdj48YnIvPlNrYXBhbmRldCBhdiBldHQgaMO2amRrdXJ2ZWxhZ2VyIHNvbSBlbiByYXN0ZXJwcm9kdWt0IMOkciB2w6RyZGVmdWxsdCBmw7ZyIGV0dCBzdG9ydCBhbnRhbCB0aWxsw6RtcG5pbmdhciBlZnRlcnNvbSBow7ZqZGt1cnZvcm5hIGthbiBsw6RnZ2FzIMO2dmVyIHDDpSBlbiBrYXJ0YSBvY2ggZ2UgaW5mb3JtYXRpb24gb20gdGVycsOkbmdlbiB1dGFuIGF0dCBza3ltbWEgdW5kZXJsaWdnYW5kZSBkYXRhLiBEZSDDpHIgYW52w6RuZGJhcmEgZsO2ciB0aWxsw6RtcG5pbmdhciBzb20gdGVrbmlrLCBqb3JkYnJ1ayBvY2ggdmF0dGVuZsO2cnPDtnJqbmluZy48L2Rpdj5cIixcblx0XHRjb250cmFzdEJyaWdodG5lc3NOYW1lOiBcIktvbnRyYXN0IG9jaCBsanVzc3R5cmthXCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzU25pcDogXCJKdXN0ZXJhciBrb250cmFzdCBvY2ggbGp1c3N0eXJrYSBmw7ZyIGV0dCByYXN0ZXIuXCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzRGVzYzogXCJGdW5rdGlvbmVuIEtvbnRyYXN0IG9jaCBsanVzc3R5cmthIGbDtnJiw6R0dHJhciB1dHNlZW5kZXQgaG9zIHJhc3RlcmRhdGEgZ2Vub20gYXR0IG1vZGlmaWVyYSBsanVzc3R5cmthIG9jaCBrb250cmFzdCBpbm9tIGJpbGRlbi4gTGp1c3N0eXJrYSBnw7ZyIGhlbGEgYmlsZGVuIGxqdXNhcmXigJR0aWxsIGV4ZW1wZWwsIG3DtnJrYSBmw6RyZ2VyIGJsaXIgbGp1c2FyZSBvY2ggbGp1c2EgZsOkcmdlciB2aXRhcmXigJRtZWRhbiBrb250cmFzdCBqdXN0ZXJhciBza2lsbG5hZGVuIG1lbGxhbiBkZSBtw7Zya2FzdGUgb2NoIGRlIGxqdXNhc3RlIGbDpHJnZXJuYS48ZGl2Pjxici8+TsOkciBkZW4gaMOkciBmdW5rdGlvbmVuIGFudsOkbmRzIMOkbmRyYXMgcGl4ZWx2w6RyZGVuYTsgZMOkcmbDtnIgYsO2ciBmdW5rdGlvbmVuIGFudsOkbmRhcyBuw6RyIGR1IHZpbGwgZsO2cmLDpHR0cmEgdXRzZWVuZGV0IGhvcyBkYXRhIG9jaCBpbnRlIG9tIGR1IHNrYSBhbnbDpG5kYSBkYXRhIHNvbSBlbiBkZWwgYXYgZW4gYW5hbHlzIHNvbSBrcsOkdmVyIG9iZWFyYmV0YWRlIHBpeGVsdsOkcmRlbi4gRGVuIGjDpHIgZnVua3Rpb25lbiDDpHIgYW52w6RuZGJhciBuw6RyIGRhdGEgcHVibGljZXJhcyBzb20gZW4gYmlsZHRqw6Ruc3Qgc29tIGthbiBhbnbDpG5kYXMgaSB0aWxsw6RtcG5pbmdhciB1dGFuIG3DtmpsaWdoZXQgYXR0IMOkbmRyYSBrb250cmFzdGVuIG9jaCBsanVzc3R5cmthbiBob3MgYmlsZGVuLCBlbGxlciBmw7ZyIGF0dCBzw6RrZXJzdMOkbGxhIGF0dCBkZW4gdmlzYXMgbWVkIGRpbmEgw7Zuc2thZGUgaW5zdMOkbGxuaW5nYXIuPC9kaXY+XCIsXG5cdFx0Y29udm9sdXRpb25OYW1lOiBcIkNvbnZvbHV0aW9uXCIsXG5cdFx0Y29udm9sdXRpb25TbmlwOiBcIkFudsOkbmRlciBldHQgZmlsdGVyIGbDtnIgc2vDpHJwYSwgb3Nrw6RycGEsIGdyw6Ruc2lkZW50aWZpZXJpbmcsIHV0asOkbW5pbmcgZWxsZXIgdG9uaW5nIMO2dmVyIGV0dCByYXN0ZXIuXCIsXG5cdFx0Y29udm9sdXRpb25EZXNjOiBcIkNvbnZvbHV0aW9uc2Z1bmt0aW9uZW4gdXRmw7ZyIGZpbHRyZXJpbmcgcMOlIHBpeGVsdsOkcmRlbmEgaSBlbiBiaWxkLCB2aWxrZXQga2FuIGFudsOkbmRhcyBmw7ZyIGF0dCBnw7ZyYSBlbiBiaWxkIHNrYXJwYXJlLCBzdWRkaWdhcmUsIGhpdHRhIGdyw6Ruc2VyIGkgYmlsZGVuIGVsbGVyIGFuZHJhIGvDpHJuYmFzZXJhZGUgZsO2cmLDpHR0cmluZ2FyLiBGaWx0ZXIgYW52w6RuZHMgZsO2ciBhdHQgZsO2cmLDpHR0cmEgcmFzdGVyYmlsZGVucyBrdmFsaXRldCBnZW5vbSBhdHQgdGEgYm9ydCBvw6RrdGEgZGF0YSBlbGxlciBmw7ZyYsOkdHRyYSBmdW5rdGlvbmVybmEgaSBkYXRhLiBEZXNzYSBjb252b2x1dGlvbnNmaWx0ZXIgdGlsbMOkbXBhcyBww6UgZW4gcsO2cmxpZywgw7Z2ZXJsYXBwYW5kZSBrw6RybmEgKGbDtm5zdGVyIGVsbGVyIGdyYW5uc2thcCksIHNvbSAzIGF2IDMuIENvbnZvbHV0aW9uc2ZpbHRlciBmdW5nZXJhciBnZW5vbSBhdHQgYmVyw6RrbmEgcGl4ZWx2w6RyZGV0IGJhc2VyYXQgcMOlIGdyYW5uYXJuYXMgdmlrdGVyLlwiLFxuXHRcdGNvcnJpZG9yTmFtZTogXCJLb3JyaWRvclwiLFxuXHRcdGNvcnJpZG9yU25pcDogXCJCZXLDpGtuYXIgc3VtbWFuIGF2IGRlIGFja3VtdWxlcmFkZSBrb3N0bmFkZXJuYSBmw7ZyIHR2w6UgcmFzdGVyIG1lZCBhY2t1bXVsZXJhZGUgaW5kYXRhLlwiLFxuXHRcdGNvcnJpZG9yRGVzYzogXCJLb3JyaWRvcmZ1bmt0aW9uZW4gYmVyw6RrbmFyIHN1bW1hbiBhdiBkZSBhY2t1bXVsZXJhZGUga29zdG5hZGVybmEgZsO2ciB0dsOlIGtvc3RuYWRzcmFzdGVyIG1lZCBhY2t1bXVsZXJhZGUgaW5kYXRhLiDDhHZlbiBvbSB2aWxrYSB0dsOlIHJhc3RlciBzb20gaGVsc3Qga2FuIGFudsOkbmRhcyBmw7ZyIGluZGF0YSwgYsO2ciBkZXQgdmFyYSBvZsO2csOkbmRyYWRlLCBhY2t1bXVsZXJhZGUga29zdG5hZHNyYXN0ZXIgbWVkIHV0ZGF0YSBvbSByZXN1bHRhdGV0IHNrYSBibGkgbWVuaW5nc2Z1bGx0LiBPcmRuaW5nZW4gcMOlIGRlIHR2w6UgaW5kYXRhdsOkcmRlbmEgw6RyIGlycmVsZXZhbnQuXCIsXG5cdFx0Y29zSE5hbWU6IFwiQ29zSFwiLFxuXHRcdGNvc0hTbmlwOiBcIkJlcsOka25hciBoeXBlcmJvbGlzayBjb3NpbnVzIGbDtnIgY2VsbGVyIGkgZXR0IHJhc3Rlci5cIixcblx0XHRjb3NIRGVzYzogXCJGdW5rdGlvbmVuIGJlcsOka25hciBoeXBlcmJvbGlzayBjb3NpbnVzIGbDtnIgcGl4bGFybmEgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGNvc05hbWU6IFwiQ29zXCIsXG5cdFx0Y29zU25pcDogXCJCZXLDpGtuYXIgY29zaW51cyBmw7ZyIGVuIGNlbGwgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGNvc0Rlc2M6IFwiRnVua3Rpb25lbiBiZXLDpGtuYXIgY29zaW51cyBmw7ZyIHBpeGxhcm5hIGkgZXR0IHJhc3Rlci5cIixcblx0XHRjb3N0QWxsb2NhdGlvbk5hbWU6IFwiS29zdG5hZHNhbGxva2VyaW5nXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25TbmlwOiBcIkJlcsOka25hciBmw7ZyIHZhcmplIGNlbGwgZGVzcyBiaWxsaWdhc3RlIGvDpGxsYSBiYXNlcmF0IHDDpSBsw6Rnc3RhIGFja3VtdWxlcmFkZSBrb3N0bmFkIMO2dmVyIGVuIGtvc3RuYWRzeXRhLlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uRGVzYzogXCJGdW5rdGlvbmVuIEtvc3RuYWRzYWxsb2tlcmluZyBiZXLDpGtuYXIgZsO2ciB2YXJqZSBjZWxsIGRlc3MgYmlsbGlnYXN0ZSBrw6RsbGEgYmFzZXJhdCBww6UgbMOkZ3N0YSBhY2t1bXVsZXJhZGUga29zdG5hZCDDtnZlciBlbiBrb3N0bmFkc3l0YS5cIixcblx0XHRjb3N0QmFja0xpbmtOYW1lOiBcIkJha8OldGzDpG5rIGbDtnIga29zdG5hZFwiLFxuXHRcdGNvc3RCYWNrTGlua1NuaXA6IFwiRGVmaW5pZXJhciBncmFubmVuIHNvbSDDpHIgbsOkc3RhIGNlbGwgcMOlIHJ1dHRlbiBmw7ZyIGzDpGdzdGEgYWNrdW11bGVyYWRlIGtvc3RuYWQgdGlsbCBkZW4gYmlsbGlnYXN0ZSBydXR0ZW4uXCIsXG5cdFx0Y29zdEJhY2tMaW5rRGVzYzogXCJGdW5rdGlvbmVuIEJha8OldGzDpG5rIGbDtnIga29zdG5hZCBkZWZpbmllcmFyIGdyYW5uZW4gc29tIMOkciBuw6RzdGEgY2VsbCBww6UgcnV0dGVuIGbDtnIgbMOkZ3N0YSBhY2t1bXVsZXJhZGUga29zdG5hZCB0aWxsIGRlbiBiaWxsaWdhc3RlIGvDpGxsYW4uPGRpdj48YnIvPkJha8OldGzDpG5rcmFzdHJldCBpbm5laMOlbGxlciB2w6RyZGVuIGZyw6VuIG5vbGwgdGlsbCDDpXR0YSwgdmlsa2EgZGVmaW5pZXJhciByaWt0bmluZ2VuIGVsbGVyIGlkZW50aWZpZXJhciBuw6RzdGEgZ3Jhbm5jZWxsIChmw7ZsamFuZGUgY2VsbCkgbMOkbmdzIHJ1dHRlbiBmw7ZyIGzDpGdzdGEgYWNrdW11bGVyYWRlIGtvc3RuYWQgZnLDpW4gZW4gY2VsbCB0aWxsIGRlbiBiaWxsaWdhc3RlIGvDpGxsYW4uIE9tIHJ1dHRlbiBnw6VyIGlnZW5vbSBkZW4gaMO2Z3JhIGdyYW5uZW4sIHRpbGxkZWxhcyBjZWxsZW4gdsOkcmRldCAxLCAyIGbDtnIgZGVuIG5lZHJlIGjDtmdyYSBkaWFnb25hbGEgY2VsbGVuIG9jaCBmb3J0c8OkdHRlciBtZWR1cnMuIFbDpHJkZXQgMCDDpHIgcmVzZXJ2ZXJhdCBmw7ZyIHVyc3BydW5nc2NlbGxlci48L2Rpdj5cIixcblx0XHRjb3N0RGlzdGFuY2VOYW1lOiBcIktvc3RuYWQgZsO2ciBhdnN0w6VuZFwiLFxuXHRcdGNvc3REaXN0YW5jZVNuaXA6IFwiQmVyw6RrbmFyIGRlbiBsw6Rnc3RhIGFja3VtdWxlcmFkZSBrb3N0bmFkZW4gZsO2ciBhdnN0w6VuZGV0IGbDtnIgdmFyamUgY2VsbCBmcsOlbiBlbGxlciB0aWxsIGRlbiBiaWxsaWdhc3RlIGvDpGxsYW4gw7Z2ZXIgZW4ga29zdG5hZHN5dGEuXCIsXG5cdFx0Y29zdERpc3RhbmNlRGVzYzogXCJGdW5rdGlvbmVuIEtvc3RuYWQgZsO2ciBhdnN0w6VuZCBiZXLDpGtuYXIgZGVuIGzDpGdzdGEgYWNrdW11bGVyYWRlIGtvc3RuYWRlbiBmw7ZyIGF2c3TDpW5kZXQgZsO2ciB2YXJqZSBjZWxsIGZyw6VuIGVsbGVyIHRpbGwgZGVuIGJpbGxpZ2FzdGUga8OkbGxhbiDDtnZlciBlbiBrb3N0bmFkc3l0YS5cIixcblx0XHRjb3N0UGF0aE5hbWU6IFwiUnV0dGtvc3RuYWRcIixcblx0XHRjb3N0UGF0aFNuaXA6IFwiQmVyw6RrbmFyIGRlbiBiaWxsaWdhc3RlIHJ1dHRlbiBmcsOlbiBlbiBrw6RsbGEgdGlsbCBlbiBkZXN0aW5hdGlvbi5cIixcblx0XHRjb3N0UGF0aERlc2M6IFwiRGVuIGdsb2JhbGEgZnVua3Rpb25lbiBSdXR0a29zdG5hZCBiZXLDpGtuYXIgZGVuIGJpbGxpZ2FzdGUgcnV0dGVuIGZyw6VuIGVuIGvDpGxsYSB0aWxsIGVuIGRlc3RpbmF0aW9uLjxkaXY+PGJyLz5EZW4gaMOkciBmdW5rdGlvbmVuIHByb2R1Y2VyYXIgZXR0IHV0ZGF0YXJhc3RlciBzb20gcmVnaXN0cmVyYXIgZGVuIGJpbGxpZ2FzdGUgcnV0dGVuIGVsbGVyIHJ1dHRlciBmcsOlbiB2YWxkYSBwbGF0c2VyIHRpbGwgZGVuIG7DpHJtYXN0ZSB1cnNwcnVuZ3NjZWxsZW4gc29tIGRlZmluaWVyYXRzIGlub20gZGVuIGFja3VtdWxlcmFkZSBrb3N0bmFkc3l0YW4sIG1lZCBhdnNlZW5kZSBww6Uga29zdG5hZCBmw7ZyIGF2c3TDpW5kLjwvZGl2PlwiLFxuXHRcdGN1cnZhdHVyZU5hbWU6IFwiS3VydmF0dXJcIixcblx0XHRjdXJ2YXR1cmVTbmlwOiBcIkJlcsOka25hciBrdXJ2YXR1cmVuIGhvcyBlbiByYXN0ZXJ5dGEsIG1lZCBhbHRlcm5hdGl2ZW4gcHJvZmlsLSBvY2ggcGxhbmt1cnZhdHVyLlwiLFxuXHRcdGN1cnZhdHVyZURlc2M6IFwiS3VydmF0dXJmdW5rdGlvbmVuIHZpc2FyIGZvcm1lbiBlbGxlciBrdXJ2YXR1cmVuIGbDtnIgbHV0bmluZ2VuLiBFbiBkZWwgYXYgeXRhbiBrYW4gdmFyYSBrb25rYXYgZWxsZXIga29udmV4OyBkZXR0YSBzZXIgZHUgcMOlIGt1cnZhdHVydsOkcmRldC4gS3VydmF0dXJlbiBiZXLDpGtuYXMgZ2Vub20gYXR0IGthbGt5bGVyYSB5dGFucyBhbmRyYWRlcml2YXRhLjxkaXY+PGJyLz5LdXJ2YXR1cmZ1bmt0aW9uZW5zIHV0ZGF0YSBrYW4gYW52w6RuZGFzIGbDtnIgYXR0IGJlc2tyaXZhIGRlIGZ5c2lza2EgZWdlbnNrYXBlcm5hIGhvcyBldHQgYXZyaW5uaW5nc29tcsOlZGUgc29tIGV0dCBzw6R0dCBhdHQgZsO2cnN0w6UgZXJvc2lvbnMtIG9jaCBhdnJpbm5pbmdzcHJvY2Vzc2VyLiBLdXJ2YXR1cnbDpHJkZXQga2FuIGFudsOkbmRhcyBmw7ZyIGF0dCBoaXR0YSBtw7Zuc3RlciBmw7ZyIGLDpWRlIGpvcmRlcm9zaW9uIG9jaCB2YXR0ZW5kaXN0cmlidXRpb25lbiBww6UgbGFuZC4gUHJvZmlsa3VydmF0dXJlbiBww6V2ZXJrYXIgYWNjZWxlcmF0aW9uZW4gb2NoIHJldGFyZGF0aW9uZW4gYXYgZmzDtmRldCBvY2ggZMOkcm1lZCDDpHZlbiBlcm9zaW9uIG9jaCBhdmxhZ3JpbmcuIFBsYW5mb3Jtc2t1cnZhdHVyZW4gcMOldmVya2FyIGZsw7ZkZXRzIGtvbnZlcmdlbnMgb2NoIGRpdmVyZ2Vucy48L2Rpdj5cIixcblx0XHRkaXZpZGVOYW1lOiBcIkbDtnJkZWxhXCIsXG5cdFx0ZGl2aWRlU25pcDogXCJEaXZpZGVyYXIgdsOkcmRlbmEgZsO2ciB0dsOlIHJhc3RlciBjZWxsIGbDtnIgY2VsbC5cIixcblx0XHRkaXZpZGVEZXNjOiBcIkZ1bmt0aW9uZW4gRsO2cmRlbGEgZGl2aWRlcmFyIHbDpHJkZW5hIGbDtnIgdHbDpSByYXN0ZXIgcGl4ZWwgZsO2ciBwaXhlbC5cIixcblx0XHRlbGV2YXRpb25Wb2lkRmlsbE5hbWU6IFwiRnlsbG5pbmcgYXYgdG9tcnVtIGbDtnIgaMO2amRcIixcblx0XHRlbGV2YXRpb25Wb2lkRmlsbFNuaXA6IFwiU2thcGFyIHBpeGxhciBkw6RyIGRldCBmaW5ucyBow6VsIGkgaMO2amRkYXRhLlwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsRGVzYzogXCJGdW5rdGlvbmVuIEZ5bGxuaW5nIGF2IHRvbXJ1bSBmw7ZyIGjDtmpkIGFudsOkbmRzIGbDtnIgYXR0IHNrYXBhIHBpeGxhciBkw6RyIGRldCBmaW5ucyBow6VsIGkgdXBwaMO2am5pbmdlbi48ZGl2Pjxici8+VG9tcnVtIHVwcHN0w6VyIG7DpHIgZGV0IGludGUgZmlubnMgbsOlZ3JhIHNhbWxhZGUgcHVua3RlciBpbm9tIG9tcsOlZGV0IHNvbSByZXByZXNlbnRlcmFzIGF2IGVuIHBpeGVsIGkgZGV0IHJlc3VsdGVyYW5kZSByYXN0cmV0LiBUb21ydW0gb3JzYWthcyBvZnRhIGF2IHZhdHRlbmbDtnJla29tc3QsIHVydmFsIGF2IGdlb29iamVrdGtsYXNzIGVsbGVyIHV0ZXNsdXRuaW5nLiBGeWxsbmluZyBhdiB0b21ydW0gYW52w6RuZHMgb2Z0YXN0IG7DpHIgZW4gbWFya3l0YSBnZW5lcmVyYXMuPC9kaXY+XCIsXG5cdFx0ZXF1YWxUb05hbWU6IFwiTGlrYSBtZWRcIixcblx0XHRlcXVhbFRvU25pcDogXCJVdGbDtnIgZW4gcmVsYXRpb25lbGwgbGlrYSBtZWQtw6V0Z8OkcmQgcMOlIHR2w6UgdXRkYXRhLCBjZWxsIGbDtnIgY2VsbC4gUmV0dXJuZXJhciAxIGbDtnIgY2VsbGVyIGTDpHIgZGV0IGbDtnJzdGEgcmFzdHJldCDDpHIgbGlrYSBtZWQgZGV0IGFuZHJhIHJhc3RyZXQgb2NoIDAgZsO2ciBjZWxsZXIgZMOkciBkZSBpbnRlIMOkciBsaWthIHN0b3JhLlwiLFxuXHRcdGVxdWFsVG9EZXNjOiBcIkZ1bmt0aW9uZW4gdXRmw7ZyIGVuIGxpa2EgbWVkLcOldGfDpHJkIHDDpSB0dsOlIHJhc3RlciwgY2VsbCBmw7ZyIGNlbGwuIERlbiByZXR1cm5lcmFyIHbDpHJkZXQgMSBmw7ZyIHBpeGxhciBkw6RyIGRldCBmw7Zyc3RhIHJhc3RyZXQgw6RyIGxpa2EgbWVkIGRldCBhbmRyYSByYXN0cmV0IG9jaCB2w6RyZGV0IDAgZsO2ciBwaXhsYXIgZMOkciBkZSBpbnRlIMOkciBsaWthIHN0b3JhLlwiLFxuXHRcdGV1Y0FsbG9jYXRpb25OYW1lOiBcIkV1a2xpZGlzayBmw7ZyZGVsbmluZ1wiLFxuXHRcdGV1Y0FsbG9jYXRpb25TbmlwOiBcIkJlcsOka25hciBkZW4gbsOkcm1hc3RlIGvDpGxsYW4gZsO2ciB2YXJqZSBjZWxsIGJhc2VyYXQgcMOlIGRlIGV1a2xpZGlza2EgYXZzdMOlbmRldC5cIixcblx0XHRldWNBbGxvY2F0aW9uRGVzYzogXCJGdW5rdGlvbmVuIEV1a2xpZGlzayByaWt0bmluZyBiZXLDpGtuYXIsIGbDtnIgdmFyamUgY2VsbCwgcmlrdG5pbmdlbiwgaSBncmFkZXIsIHRpbGwgbsOkcm1hc3RlIGvDpGxsYS5cIixcblx0XHRldWNEaXJlY3Rpb25OYW1lOiBcIkV1a2xpZGlzayByaWt0bmluZ1wiLFxuXHRcdGV1Y0RpcmVjdGlvblNuaXA6IFwiQmVyw6RrbmFyLCBmw7ZyIHZhcmplIGNlbGwsIHJpa3RuaW5nZW4sIGkgZ3JhZGVyLCB0aWxsIG7DpHJtYXN0ZSBrw6RsbGEuXCIsXG5cdFx0ZXVjRGlyZWN0aW9uRGVzYzogXCJGdW5rdGlvbmVuIEV1a2xpZGlzayBmw7ZyZGVsbmluZyBiZXLDpGtuYXIsIGbDtnIgdmFyamUgY2VsbCwgcmlrdG5pbmdlbiwgaSBncmFkZXIsIHRpbGwgbsOkcm1hc3RlIGvDpGxsYS4gPGRpdj48YnIvPlJpa3RuaW5nZW4gYmVyw6RrbmFzIGZyw6VuIHZhcmplIGNlbGxjZW50ZXIgdGlsbCBjZW50ZXIgZsO2ciBuw6RybWFzdGUgdXJzcHJ1bmdzY2VsbC4gVsOkcmRlaW50ZXJ2YWxsZXQgw6RyIGZyw6VuIDAgdGlsbCAzNjAgZ3JhZGVyLCBtZWQgMCByZXNlcnZlcmF0IGbDtnIgdXJzcHJ1bmdzY2VsbGVyLiDDlnN0bGlnIHJpa3RuaW5nIChow7ZnZXIpIMOkciA5MCBvY2ggdsOkcmRlbmEgw7ZrYXIgbWVkdXJzICgxODAgw6RyIHPDtmRlciwgMjcwIMOkciB2w6RzdGVyIG9jaCAzNjAgw6RyIG5vcnIpLjwvZGl2PlwiLFxuXHRcdGV1Y0Rpc3RhbmNlTmFtZTogXCJFdWtsaWRpc2t0IGF2c3TDpW5kXCIsXG5cdFx0ZXVjRGlzdGFuY2VTbmlwOiBcIkJlcsOka25hciBmw7ZyIHZhcmplIGNlbGwgZGV0IGV1a2xpZGlza2EgYXZzdMOlbmRldCB0aWxsIG7DpHJtYXN0ZSBrw6RsbGEuXCIsXG5cdFx0ZXVjRGlzdGFuY2VEZXNjOiBcIkZ1bmt0aW9uZW4gRXVrbGlkaXNrdCBhdnN0w6VuZCBiZXLDpGtuYXIsIGbDtnIgdmFyamUgY2VsbCwgZGV0IGV1a2xpZGlza2EgYXZzdMOlbmRldCB0aWxsIG7DpHJtYXN0ZSBrw6RsbGEuXCIsXG5cdFx0ZXhwMTBOYW1lOiBcIkV4cDEwXCIsXG5cdFx0ZXhwMTBTbmlwOiBcIkJlcsOka25hciBiYXMgMTAtZXhwb25lbnRpYWxmdW5rdGlvbmVuIGbDtnIgY2VsbGVybmEgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGV4cDEwRGVzYzogXCJGdW5rdGlvbmVuIEV4cCAxMCBiZXLDpGtuYXIgYmFzIDEwLWV4cG9uZW50aWFsZnVua3Rpb25lbiBmw7ZyIHBpeGxhcm5hIGkgZXR0IHJhc3Rlci5cIixcblx0XHRleHAyTmFtZTogXCJFeHAyXCIsXG5cdFx0ZXhwMlNuaXA6IFwiQmVyw6RrbmFyIGJhcyAyLWV4cG9uZW50aWFsZnVua3Rpb25lbiBmw7ZyIGNlbGxlcm5hIGkgZXR0IHJhc3Rlci5cIixcblx0XHRleHAyRGVzYzogXCJEZW4gaMOkciBmdW5rdGlvbmVuIGJlcsOka25hciBiYXMgMi1leHBvbmVudGlhbGZ1bmt0aW9uZW4gZsO2ciBwaXhsYXJuYSBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0ZXhwTmFtZTogXCJHw6VyIHV0XCIsXG5cdFx0ZXhwU25pcDogXCJCZXLDpGtuYXIgYmFzIGUtZXhwb25lbnRpYWxmdW5rdGlvbmVuIGbDtnIgY2VsbGVybmEgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGV4cERlc2M6IFwiRGVuIGjDpHIgZnVua3Rpb25lbiBiZXLDpGtuYXIgYmFzIGUtZXhwb25lbnRpYWxmdW5rdGlvbmVuIGbDtnIgcGl4bGFybmEgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGV4dHJhY3RCYW5kTmFtZTogXCJFeHRyYWhlcmEgYmFuZFwiLFxuXHRcdGV4dHJhY3RCYW5kU25pcDogXCJBbmdlciB2aWxrYSBiYW5kIGR1IHNrYSBhcmJldGEgbWVkIG7DpHIgZHUgYW52w6RuZGVyIGZsZXJiYW5kc2RhdGFzZXQuXCIsXG5cdFx0ZXh0cmFjdEJhbmREZXNjOiBcIiBGdW5rdGlvbmVuIEV4dHJhaGVyYSBiYW5kIGfDtnIgYXR0IGR1IGthbiBleHRyYWhlcmEgZXR0IGVsbGVyIGZsZXJhIGJhbmQgZnLDpW4gZXR0IGZsZXJiYW5kc3Jhc3RlcmRhdGFzZXQsIGVsbGVyIMOkbmRyYXIgb3JkbmluZ2VuIHDDpSBiYW5kZW4gaSBkYXRhc2V0ZXQuPGRpdj48YnIvPkR1IGthbiBhbnbDpG5kYSBmdW5rdGlvbmVuIEV4dHJhaGVyYSBiYW5kIGbDtnJlIGFuZHJhIGZ1bmt0aW9uZXIsIHRpbGwgZXhlbXBlbCBBcml0bWV0aXNrLCBmw7ZyIGF0dCBrb250cm9sbGVyYSB2aWxrYSBiYW5kIHNvbSBhbnbDpG5kcyBzb20gaW5kYXRhIGkgbsOkc3RhIGZ1bmt0aW9uLjwvZGl2PlwiLFxuXHRcdGZpbGxOYW1lOiBcIkZ5bGxuaW5nXCIsXG5cdFx0ZmlsbFNuaXA6IFwiRnlsbGVyIHPDpG5rb3IgaSBldHQgeXRyYXN0ZXIgZsO2ciBhdHQgdGEgYm9ydCBzbcOlIGJyaXN0ZsOkbGxpZ2hldGVyIGkgZGF0YS5cIixcblx0XHRmaWxsRGVzYzogXCJEZW4gZ2xvYmFsYSBmdW5rdGlvbmVuIEZ5bGxuaW5nIGxva2FsaXNlcmFyIG9jaCBmeWxsZXIgdXQgc8OkbmtvciBvY2ggdG9wcGFyIGkgZXR0IHJhc3RlciBmw7ZyIGjDtmpkeXRhIGbDtnIgYXR0IHRhIGJvcnQgc23DpSBicmlzdGbDpGxsaWdoZXRlciBpIGRhdGEuIEZ1bmt0aW9uZW4gZnlsbGVyIGkgZW4gaXRlcmF0aXYgcHJvY2VzcyB0aWxscyBhbGxhIHPDpG5rb3Igb2NoIHRvcHBhciBoYXIgZnlsbHRzIGlub20gZGVuIHNwZWNpZmljZXJhZGUgWi1iZWdyw6Ruc25pbmdlbi48ZGl2Pjxici8+TsOkciBlbiBow7ZqZHl0YSBza2FwYXMgbWVkIG9ydG9rYXJ0ZXJpbmdzdmVya3R5ZyBlbGxlciBww6UgYW5uYXQgc8OkdHQsIGZpbm5zIGRldCBvZnRhIHNtw6UgbWVuIHNpZ25pZmlrYW50YSBmZWwgaSBmb3JtIGF2IHPDpG5rb3Igb2NoIHRvcHBhciBpIGRhdGEuIEkgZm90b2dyYW1tZXRyaSBrYWxsYXMgc8OkbmtvciBvY2ggdG9wcGFyIG9mdGEgZsO2ciBow6VsIG9jaCB0b3BwYXIuIEVmdGVyc29tIHl0ZGF0YSBvZnRhIGFudsOkbmRzIHZpZCBtb2RlbGxlcmluZywgdGlsbCBleGVtcGVsIGh5ZHJvbG9naXNrIG1vZGVsbGVyaW5nLCDDpHIgZGV0IHZpa3RpZ3QgYXR0IGtvcnJpZ2VyYSBkZXNzYSBmZWwgbWVkIHPDpG5rb3Igb2NoIHRvcHBhciBww6UgZXR0IHPDpHR0IHNvbSBzdMOkbW1lciDDtnZlcmVucyBtZWQgb21naXZhbmRlIGRhdGEuPC9kaXY+XCIsXG5cdFx0ZmxvYXROYW1lOiBcIkZseXRhbmRlXCIsXG5cdFx0ZmxvYXRTbmlwOiBcIktvbnZlcnRlcmFyIHZhcmplIGNlbGx2w6RyZGUgaSBldHQgcmFzdGVyIHRpbGwgZW4gZmx5dHRhbHNyZXByZXNlbnRhdGlvbi5cIixcblx0XHRmbG9hdERlc2M6IFwiRnVua3Rpb25lbiBGbHl0dGFsIGtvbnZlcnRlcmFyIHZhcmplIHBpeGVsdsOkcmRlIGkgZXR0IHJhc3RlciB0aWxsIGVuIGZseXR0YWxzcmVwcmVzZW50YXRpb24uXCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvbk5hbWU6IFwiRmzDtmRlc2Fja3VtdWxlcmluZ1wiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25TbmlwOiBcIlNrYXBhciBldHQgcmFzdGVyIGF2IGFja3VtdWxlcmF0IGZsw7ZkZSB0aWxsIHZhcmplIGNlbGwuIEVuIHZpa3RmYWt0b3Iga2FuIG9ja3PDpSB0aWxsw6RtcGFzLlwiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25EZXNjOiBcIkRlbiBnbG9iYWxhIGZ1bmt0aW9uZW4gRmzDtmRlc2Fja3VtdWxlcmluZyBza2FwYXIgZXR0IHJhc3RlciBhdiBhY2t1bXVsZXJhdCBmbMO2ZGUgdGlsbCB2YXJqZSBwaXhlbCwgc29tIGJlc3TDpG1zIGdlbm9tIGF0dCB2aWt0ZW4gYXYgYWxsYSBwaXhsYXIgc29tIGZseXRlciB0aWxsIHZhcmplIG5lZMOldGx1dGFuZGUgcGl4ZWwgYWNrdW11bGVyYXMuIE9tIGluZ2V0IHZpa3RyYXN0ZXIgdGlsbGhhbmRhaMOlbGxzIHRpbGxkZWxhcyB2YXJqZSBwaXhlbCB2aWt0ZW4gMSBvY2ggdsOkcmRldCBmw7ZyIHBpeGxhciBpIHV0ZGF0YXJhc3RyZXQgw6RyIGFudGFsZXQgcGl4bGFyIHNvbSBmbHl0ZXIgdGlsbCB2YXJqZSBwaXhlbC48ZGl2Pjxici8+VXRkYXRhcGl4bGFyIG1lZCBow7ZnIGZsw7ZkZXNhY2t1bXVsZXJpbmcgw6RyIG9tcsOlZGVuIG1lZCBrb25jZW50cmVyYXQgZmzDtmRlIG9jaCBrYW4gYW52w6RuZGFzIGbDtnIgYXR0IGlkZW50aWZpZXJhIHN0csO2bWthbmFsZXIuIFV0ZGF0YXBpeGxhciBtZWQgZmzDtmRlc2Fja3VtdWxlcmluZ2VuIG5vbGwgw6RyIGxva2FsYSB0b3BvZ3JhZmlza2EgdG9wcGFyIG9jaCBrYW4gYW52w6RuZGFzIGbDtnIgYXR0IGlkZW50aWZpZXJhIGJlcmdza2FtbWFyIChyeWdnYXIpLjwvZGl2PlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25OYW1lOiBcIkZsw7ZkZXNyaWt0bmluZ1wiLFxuXHRcdGZsb3dEaXJlY3Rpb25TbmlwOiBcIlNrYXBhciBldHQgcmFzdGVyIGF2IGZsw7ZkZXNyaWt0bmluZyBmcsOlbiB2YXJqZSBjZWxsIHRpbGwgZGVuIGJyYW50YXN0ZSBncmFubmVuIGkgZmFsbGFuZGUgbHV0bmluZy5cIixcblx0XHRmbG93RGlyZWN0aW9uRGVzYzogXCJFbiBueWNrZWwgdGlsbCBhdHQgaMOkcmxlZGEgaHlkcm9sb2dpc2thIGVnZW5za2FwZXIgaG9zIGVuIHl0YSDDpHIgbcO2amxpZ2hldGVuIGF0dCBiZXN0w6RtbWEgZmzDtmRlc3Jpa3RuaW5nZW4gZnLDpW4gdmFyamUgcGl4ZWwgaSByYXN0cmV0LiBSYXN0ZXJmdW5rdGlvbmVuIEZsw7ZkZXNyaWt0bmluZyB0YXIgZW4geXRhIHNvbSBpbmRhdGEgb2NoIHNrYXBhciBldHQgcmFzdGVyIGF2IGZsw7ZkZXNyaWt0bmluZ2VuIGZyw6VuIHZhcmplIHBpeGVsIHRpbGwgZ3Jhbm5lbiBtZWQgYnJhbnRhc3QgbHV0bmluZy4gRnVua3Rpb25lbiBGbMO2ZGVzcmlrdG5pbmcgc3TDtmRqZXIgdHJlIGZsw7ZkZXNtb2RlbGxlcmFuZGUgbWV0b2RlcjogRDggKMOldHRhIHJpa3RuaW5nYXIpLCBNdWx0aS1GbG93IERpcmVjdGlvbiAoTUZEKSBvY2ggRC1JbmZpbml0eSAoRElORikuIFwiLFxuXHRcdGZsb3dEaXN0YW5jZU5hbWU6IFwiRmzDtmRlc2F2c3TDpW5kXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlU25pcDogXCIvLy9CZXLDpGtuYXIgZGV0IG1pbnN0YSBob3Jpc29udGVsbGEgZWxsZXIgdmVydGlrYWxhIGF2c3TDpW5kZXQgbmVkZsO2ciBzbHV0dG5pbmdhciBmw7ZyIHZhcmplIGNlbGwgdGlsbCBjZWxsZXIgaSBlbiBzdHLDtm0gZWxsZXIgZmxvZCBzb20gZGUgbXlubmFyIGkuXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlRGVzYzogXCJGw7ZyIHZhcmplIHBpeGVsIGJlcsOka25hciBmdW5rdGlvbmVuIGRldCBtaW5zdGEgaG9yaXNvbnRlbGxhIGVsbGVyIHZlcnRpa2FsYSBhdnN0w6VuZGV0IG5lZGbDtnIgc2x1dHRuaW5nYXIgdGlsbCBwaXhsYXIgcMOlIGVuIGZsb2QgZWxsZXIgc3Ryw7ZtIG1vdCB2aWxrZW4gZGUgZmx5dGVyLiBPbSBkZXQgZmlubnMgeXR0ZXJsaWdhcmUgcmFzdGVyIGbDtnIgZmzDtmRlc3Jpa3RuaW5nLCBiZWdyw6Ruc2FzIHJpa3RuaW5nYXJuYSBpIGZhbGxhbmRlIGx1dG5pbmcgdGlsbCBkZW0gc29tIGRlZmluaWVyYXMgYXYgZmzDtmRlc3Jpa3RuaW5nc3Jhc3RyZXQgZsO2ciBpbmRhdGEuIFV0ZGF0YSDDpHIgZXR0IHJhc3RlciBmw7ZyIGZsw7ZkZXNhdnN0w6VuZC5cIixcblx0XHRmb2NhbE5hbWU6IFwiRm9rYWwgc3RhdGlzdGlrXCIsXG5cdFx0Zm9jYWxTbmlwOiBcIkJlcsOka25hciBmb2thbCBzdGF0aXN0aWsgZsO2ciB2YXJqZSBwaXhlbCBpIGVuIGJpbGQgdXRpZnLDpW4gZGVmaW5pZXJhdCBmb2thbHQgZ3Jhbm5za2FwLlwiLFxuXHRcdGZvY2FsRGVzYzogXCJGdW5rdGlvbmVuIEZva2FsIHN0YXRpc3RpayBiZXLDpGtuYXIgZm9rYWwgc3RhdGlzdGlrIGbDtnIgdmFyamUgcGl4ZWwgaSBlbiBiaWxkIHV0aWZyw6VuIGRlZmluaWVyYXQgZm9rYWx0IGdyYW5uc2thcC5cIixcblx0XHRnZW9tZXRyaWNOYW1lOiBcIkdlb21ldHJpc2t0XCIsXG5cdFx0Z2VvbWV0cmljU25pcDogXCLDlmthciBwb3NpdGlvbnNub2dncmFubmhldGVuIGbDtnIgZXR0IGRhdGFzZXQgZ2Vub20gYXR0IHRhIGjDpG5zeW4gdGlsbCBow7ZqZC5cIixcblx0XHRnZW9tZXRyaWNEZXNjOiBcIkZ1bmt0aW9uZW4gR2VvbWV0cmlza3QgcHJvZHVjZXJhciBlbiBvcnRvcmVrdGlmaWVyYWQgYmlsZCB1dGlmcsOlbiBzZW5zb3JkZWZpbml0aW9uIG9jaCBlbiB0ZXJyw6RuZ21vZGVsbC4gRGVuIMO2a2FyIHBvc2l0aW9uc25vZ2dyYW5uaGV0ZW4gZsO2ciBldHQgZGF0YXNldCBnZW5vbSBhdHQgdGEgaMOkbnN5biB0aWxsIGjDtmpkLlwiLFxuXHRcdGdyYXlzY2FsZU5hbWU6IFwiR3LDpXNrYWxhXCIsXG5cdFx0Z3JheXNjYWxlU25pcDogXCJLb252ZXJ0ZXJhciBlbiBmbGVyYmFuZGJpbGQgdGlsbCBlbiBiaWxkIGkgZ3LDpXNrYWxhIG1lZCBldHQgYmFuZC5cIixcblx0XHRncmF5c2NhbGVEZXNjOiBcIkRlbiBow6RyIGZ1bmt0aW9uZW4ga29udmVydGVyYXIgZW4gZmxlcmJhbmRiaWxkIHRpbGwgZW4gYmlsZCBpIGdyw6Vza2FsYSBtZWQgZXR0IGJhbmQuPGRpdj48YnIvPkRlbiBow6RyIGZ1bmt0aW9uZW4gdGlsbMOkbXBhciBzcGVjaWZpY2VyYWRlIHZpa3RlciBww6UgdmFyamUgaW5kYXRhYmFuZCBvY2ggbm9ybWFsaXNlcmFyIHV0ZGF0YWJpbGRlbi4gVmlrdGVybmEgdGlsbMOkbXBhcyBvZnRhIGbDtnIgYXR0IG7DpWdyYSBiYW5kIGhhciBvbGlrYSBiZXR5ZGVsc2UgYmVyb2VuZGUgcMOlIGFwcGxpa2F0aW9uLiBUaWxsIGV4ZW1wZWwgaW5uZWjDpWxsZXIgZGV0IGJsw6UgYmFuZGV0IG9mdGEgbWVyIGJydXMgw6RuIGFuZHJhIGJhbmQuPC9kaXY+XCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbE5hbWU6IFwiU3TDtnJyZSDDpG4gZWxsZXIgbGlrYSBtZWRcIixcblx0XHRncmVhdGVyVGhhbkVxdWFsU25pcDogXCJVdGbDtnIgZW4gcmVsYXRpb25lbGwgc3TDtnJyZSDDpG4vbGlrYSBtZWQtw6V0Z8OkcmQgcMOlIHR2w6UgaW5kYXRhLCBjZWxsIGbDtnIgY2VsbC4gUmV0dXJuZXJhciAxIGbDtnIgY2VsbGVyIGTDpHIgZGV0IGbDtnJzdGEgcmFzdHJldCDDpHIgc3TDtnJyZSDDpG4gZWxsZXIgbGlrYSBtZWQgZGV0IGFuZHJhIHJhc3RyZXQgb2NoIDAgb20gZGV0IGludGUgw6RyIGRldC5cIixcblx0XHRncmVhdGVyVGhhbkVxdWFsRGVzYzogXCJGdW5rdGlvbmVuIHV0ZsO2ciBlbiByZWxhdGlvbmVsbCBzdMO2cnJlIMOkbi9saWthIG1lZC3DpXRnw6RyZCBww6UgdHbDpSBpbmRhdGEsIHBpeGVsIGbDtnIgcGl4ZWwuIERlbiByZXR1cm5lcmFyIHbDpHJkZXQgMSBmw7ZyIHBpeGxhciBkw6RyIGRldCBmw7Zyc3RhIHJhc3RyZXQgw6RyIHN0w7ZycmUgw6RuIGVsbGVyIGxpa2EgbWVkIGRldCBhbmRyYSByYXN0cmV0IG9jaCB2w6RyZGV0IDAgZsO2ciBwaXhsYXIgZMOkciBkZXQgZsO2cnN0YSByYXN0cmV0IGludGUgw6RyIHN0w7ZycmUgw6RuIGVsbGVyIGxpa2EgbWVkIGRldCBhbmRyYSByYXN0cmV0LlwiLFxuXHRcdGdyZWF0ZXJUaGFuTmFtZTogXCJTdMO2cnJlIMOkblwiLFxuXHRcdGdyZWF0ZXJUaGFuU25pcDogXCJVdGbDtnIgZW4gcmVsYXRpb25lbGwgc3TDtnJyZSDDpG4tw6V0Z8OkcmQgcMOlIHR2w6UgaW5kYXRhLCBjZWxsIGbDtnIgY2VsbC4gUmV0dXJuZXJhciAxIGbDtnIgY2VsbGVyIGTDpHIgZGV0IGbDtnJzdGEgcmFzdHJldCDDpHIgc3TDtnJyZSDDpG4gZGV0IGFuZHJhIHJhc3RyZXQgb2NoIDAgZsO2ciBjZWxsZXIgZMOkciBkZXQgaW50ZSDDpHIgZGV0LlwiLFxuXHRcdGdyZWF0ZXJUaGFuRGVzYzogXCJGdW5rdGlvbmVuIHV0ZsO2ciBlbiByZWxhdGlvbmVsbCBzdMO2cnJlIMOkbi3DpXRnw6RyZCBww6UgdHbDpSBpbmRhdGEsIHBpeGVsIGbDtnIgcGl4ZWwuIFJldHVybmVyYXIgdsOkcmRldCAxIGbDtnIgcGl4bGFyIGTDpHIgZGV0IGbDtnJzdGEgcmFzdHJldCDDpHIgc3TDtnJyZSDDpG4gZGV0IGFuZHJhIHJhc3RyZXQgb2NoIHbDpHJkZXQgMCBmw7ZyIHBpeGxhciBkw6RyIGRldCBmw7Zyc3RhIHJhc3RyZXQgaW50ZSDDpHIgc3TDtnJyZSDDpG4gZGV0IGFuZHJhIHJhc3RyZXQuXCIsXG5cdFx0aGVhdEluZGV4TmFtZTogXCJWw6RybWVpbmRleFwiLFxuXHRcdGhlYXRJbmRleFNuaXA6IFwiS29tYmluZXJhciBvbWdpdm5pbmdlbnMgbHVmdHRlbXBlcmF0dXIgb2NoIHJlbGF0aXYgbHVmdGZ1a3RpZ2hldCBzYW10IHJldHVybmVyYXIgZGVuIHVwcGxldmRhIHRlbXBlcmF0dXJlbi5cIixcblx0XHRoZWF0SW5kZXhEZXNjOiBcIkRlbiBow6RyIGZ1bmt0aW9uZW4gYmVyw6RrbmFyIHVwcGxldmQgdGVtcGVyYXR1ciB1dGlmcsOlbiBvbWdpdm5pbmdlbnMgdGVtcGVyYXR1ciBvY2ggcmVsYXRpdmEgZnVrdGlnaGV0LiBEZW4gdXBwbGV2ZGEgdGVtcGVyYXR1cmVuIGJlc2tyaXZzIG9mdGEgc29tIGh1ciB2YXJtdCBkZXQga8Okbm5zIGbDtnIgZGVuIG3DpG5za2xpZ2Ega3JvcHBlbi48ZGl2Pjxici8+RGV0dGEgaW5kZXgga2FuIHZhcmEgYW52w6RuZGJhcnQgZsO2ciBhdHQgYmVyw6RrbmEgcmlza2VyIG1lZCBrb3BwbGluZyB0aWxsIG1lZGljaW5za2EgcHJvYmxlbSBzb20gbXVza2Vsa3JhbXBlciwgdXR0b3JrbmluZyBvY2ggc29sc3RpbmcsIGVsbGVyIG1lciBhbGx2YXJsaWd0IHbDpHJtZXNsYWcgdW5kZXIgdmFybWEgb2NoIGZ1a3RpZ2EgZGFnYXIuIE7DpHIgZGVuIHJlbGF0aXZhIGZ1a3RpZ2hldGVuIMOkciBow7ZnIGJsaXIgZGV0IGFsbHQgc3bDpXJhcmUgZsO2ciBrcm9wcGVucyBzdmV0dCBhdHQgYXZkdW5zdGEsIHZpbGtldCBnw7ZyIGF0dCBpbmRpdmlkZW4gc2FrbmFyIGV0dCBlZmZla3RpdnQgbmF0dXJsaWd0IHPDpHR0IGF0dCBreWxhcyBuZWQuIEthcnRvciBtZWQgdsOkcm1lcsOlZCBlbGxlciB2w6RybWV2YXJuaW5nYXIgw6RyIG9mdGEgcmVzdWx0YXRldCBhdiBhdHQgdsOkcm1laW5kZXggb21rbGFzc2lmaWNlcmFzIHRpbGwga2xhc3NlciwgZMOkciBzYW5ub2xpa2hldGVuIGbDtnIgYXR0IGRldCBza2EgYmxpIGVuIHZhcm5pbmcgc25hcmFyZSDDpG4gZXR0IHLDpWQgw7ZrYXIganUgaMO2Z3JlIGluZGV4dsOkcmRldCDDpHIuPC9kaXY+XCIsXG5cdFx0aGlsbHNoYWRlTmFtZTogXCJUZXJyw6RuZ3NrdWdnbmluZ1wiLFxuXHRcdGhpbGxzaGFkZVNuaXA6IFwiU2thcGFyIGVuIDNELXJlcHJlc2VudGF0aW9uIGF2IHl0YW4gbWVkIGjDpG5zeW4gdGFnZW4gdGlsbCBzb2xlbnMgcmVsYXRpdmEgcG9zaXRpb24gZsO2ciBhdHQgc2t1Z2dhIGJpbGRlbi5cIixcblx0XHRoaWxsc2hhZGVEZXNjOiBcIkZ1bmt0aW9uZW4gVGVycsOkbmdza3VnZ25pbmcgc2thcGFyIGVuIDNELXJlcHJlc2VudGF0aW9uIGF2IHRlcnJyw6RuZ3l0YW4gbWVkIGjDpG5zeW4gdGFnZW4gdGlsbCBzb2xlbnMgcmVsYXRpdmEgcG9zaXRpb24gZsO2ciBhdHQgc2t1Z2dhIGJpbGRlbi4gPGRpdj48YnIvPlRlcnLDpG5nc2t1Z2duaW5nIMOkciBlbiB0ZWtuaWsgZsO2ciBhdHQgdmlzdWFsaXNlcmEgdGVycsOkbmcgc29tIGJlc3TDpG1zIGF2IGVuIGxqdXNrw6RsbGEgc2FtdCBsdXRuaW5nZW4gb2NoIGFzcGVrdGVuIGbDtnIgaMO2amR5dGFuLiBEZXQgw6RyIGVuIGt2YWxpdGF0aXYgbWV0b2QgZsO2ciBhdHQgdmlzdWFsaXNlcmEgdG9wb2dyYWZpIG9jaCBkZW4gZ2VyIGluZ2EgYWJzb2x1dGEgaMO2amR2w6RyZGVuLiA8L2Rpdj5cIixcblx0XHRpbnROYW1lOiBcIkludFwiLFxuXHRcdGludFNuaXA6IFwiS29udmVydGVyYXIgdmFyamUgY2VsbHbDpHJkZSBpIGV0dCByYXN0ZXIgdGlsbCBldHQgaGVsdGFsIHZpYSB0cnVua2VyaW5nLlwiLFxuXHRcdGludERlc2M6IFwiRnVua3Rpb25lbiBJbnQga29udmVydGVyYXIgdmFyamUgcGl4ZWx2w6RyZGUgaSBldHQgcmFzdGVyIHRpbGwgZXR0IGhlbHRhbCB2aWEgdHJ1bmtlcmluZy5cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFOYW1lOiBcIkludGVycG9sZXJhIG9yZWdlbGJ1bmRuYSBkYXRhXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhU25pcDogXCJJbnRlcnBvbGVyYXIgZnLDpW4gcHVua3Rtb2xuIGVsbGVyIG9yZWdlbGJ1bmRuYSBydXRuw6R0LlwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YURlc2M6IFwiVmlzc2EgbmV0Q0RGLSBlbGxlciBIREYtZGF0YXNldCBsYWdyYXIgc2luIGdlb2xva2FsaXNlcmluZyBzb20gb3JlZ2VsYnVuZGV0IHV0c3ByaWRkYSBwaXhsYXIgZWxsZXIgcHVua3RkYXRhLiBOw6RyIGRlc3NhIGRhdGFzZXQgbMOkZ2dzIHRpbGwgaSBldHQgbW9zYWlrZGF0YXNldCwgdGFyIGRlbiBpbnRlcnBvbGVyYWRlIG9yZWdlbGJ1bmRuYSBkYXRhZnVua3Rpb25lbiBkZXQgb3JlZ2VsYnVuZG5hIHJ1dG7DpHRldCBhdiBkYXRhIG9jaCBvbXNhbXBsYXIgZGV0IHPDpSBhdHQgYWxsYSBwaXhsYXIgaGFyIHNhbW1hIHN0b3JsZWsgb2NoIMOkciBrdmFkcmF0aXNrYS48ZGl2Pjxici8+TsOkciB2YXJpYWJsZXIgZnLDpW4gbmV0Q0RGIGVsbGVyIEhERiBsw6RnZ3MgdGlsbCBpIGV0dCBtb3NhaWtkYXRhc2V0LCB2ZXJpZmllcmFyIGRldCBhdXRvbWF0aXNrdCBvbSBkYXRhIMOkciBqw6RtbnQgdXRzcHJpZGRhLiBPbSBkZSBpbnRlIMOkciBkZXQga2FuIGRlbiBpbnRlcnBvbGVyYWRlIG9yZWdlbGJ1bmRuYSBkYXRhZnVua3Rpb25lbiBhbnbDpG5kYXMgZsO2ciBhdHQga29udmVydGVyYSBvcmVnZWxidW5kbmEgZGF0YSB0aWxsIGV0dCByZWdlbGJ1bmRldCBydXRuw6R0c3Jhc3Rlci4gRHUga2FuIMOkbmRyYSBpbnRlcnBvbGVyaW5nc21ldG9kZW4gb2NoIGNlbGxzdG9ybGVrZW4gc29tIGFudsOkbmRzIGkgZGVuIGludGVycG9sZXJhZGUgb3JlZ2VsYnVuZG5hIGRhdGFyYXN0ZXJmdW5rdGlvbmVuLiBGw7ZyIHJlZ2VsYnVuZGV0IHV0c3ByaWRkYSByYXN0ZXJkYXRhIGFudsOkbmRzIGluZ2VuIGludGVycG9sZXJpbmcgb2NoIGRhdGEgbMOkc2VzIHNvbSBkZSDDpHIuPC9kaXY+XCIsXG5cdFx0aXNOdWxsTmFtZTogXCLDhHIgbm9sbFwiLFxuXHRcdGlzTnVsbFNuaXA6IFwiQmVzdMOkbW1lciB2aWxrYSB2w6RyZGVuIGZyw6VuIGluZGF0YXJhc3RlciBzb20gw6RyIE5vRGF0YSwgY2VsbCBmw7ZyIGNlbGwuIFJldHVybmVyYXIgdsOkcmRldCAxIG9tIGluZGF0YXbDpHJkZW5hIMOkciBOb0RhdGEgb2NoIDAgZsO2ciBjZWxsZXIgc29tIGludGUgw6RyIGRldC5cIixcblx0XHRpc051bGxEZXNjOiBcIkZ1bmt0aW9uZW4gw4RyIG51bGwgYmVzdMOkbW1lciB2aWxrYSB2w6RyZGVuIGZyw6VuIGluZGF0YXJhc3RyZXQgc29tIMOkciBOb0RhdGEsIHBpeGVsIGbDtnIgcGl4ZWwuIERlbiByZXR1cm5lcmFyIHbDpHJkZXQgMSBvbSBpbmRhdGF2w6RyZGV0IMOkciBOb0RhdGEgb2NoIHbDpHJkZXQgMCBmw7ZyIHBpeGxhciBzb20gaW50ZSDDpHIgTm9EYXRhLlwiLFxuXHRcdGtlcm5lbERlbnNpdHlOYW1lOiBcIkvDpHJuZGVuc2l0ZXRcIixcblx0XHRrZXJuZWxEZW5zaXR5U25pcDogXCJCZXLDpGtuYXIgZXR0IHN0b3JsZWstcGVyLWVuaGV0LW9tcsOlZGUgZnLDpW4gcHVua3QtIGVsbGVyIHBvbHlsaW5qZWdlb29iamVrdCBtZWQgZW4ga8Okcm5mdW5rdGlvbiBmw7ZyIGF0dCBwYXNzYSBpbiBlbiBqw6RtbnQgYXZzbWFsbmFuZGUgeXRhIHRpbGwgdmFyamUgcHVua3QgZWxsZXIgcG9seWxpbmplLlwiLFxuXHRcdGtlcm5lbERlbnNpdHlEZXNjOiBcIkRlbiBow6RyIGZ1bmt0aW9uZW4gYmVyw6RrbmFyIGV0dCBzdG9ybGVrLXBlci1lbmhldC1vbXLDpWRlIGZyw6VuIHB1bmt0LSBlbGxlciBwb2x5bGluamVnZW9vYmpla3QgbWVkIGVuIGvDpHJuZnVua3Rpb24gZsO2ciBhdHQgcGFzc2EgaW4gZW4gasOkbW50IGF2c21hbG5hbmRlIHl0YSB0aWxsIHZhcmplIHB1bmt0IGVsbGVyIHBvbHlsaW5qZS5cIixcblx0XHRrZXlNZXRhZGF0YU5hbWU6IFwiVmlrdGlnYSBtZXRhZGF0YVwiLFxuXHRcdGtleU1ldGFkYXRhU25pcDogXCLDhXNpZG9zw6R0dGVyIGVsbGVyIGluZm9nYXIgdmlrdGlnYSBtZXRhZGF0YSBmw7ZyIGV0dCByYXN0ZXIgaSBlbiBmdW5rdGlvbnNrZWRqYS5cIixcblx0XHRrZXlNZXRhZGF0YURlc2M6IFwiRGVuIGjDpHIgZnVua3Rpb25lbiBnw7ZyIGF0dCBkdSBrYW4gaW5mb2dhIGVsbGVyIMOlc2lkb3PDpHR0YSB2aWt0aWdhIG1ldGFkYXRhIGbDtnIgZXR0IHJhc3Rlci48ZGl2Pjxici8+SW5mb3JtYXRpb25lbiBpIHZpa3RpZ2EgbWV0YWRhdGEgYW52w6RuZHMgZsO2ciBhdHQgaGrDpGxwYSBhcHBsaWthdGlvbmVuIG1lZCBiZWFyYmV0bmluZyBvY2ggcmVuZGVyaW5nLCBpbmtsdXNpdmUgYXR0IHRpbGxoYW5kYWjDpWxsYSBhbnbDpG5kYmFyIGluZm9ybWF0aW9uIHNvbSBzZW5zb3JuYW1uLCBiYW5kbmFtbiBlbGxlciBtb2xudMOkY2tlIGtvcHBsYXQgdGlsbCBiaWxkZXJuYS48L2Rpdj5cIixcblx0XHRzaG9ydGVzdFBhdGhOYW1lOiBcIkJpbGxpZ2FzdGUgcnV0dFwiLFxuXHRcdHNob3J0ZXN0UGF0aFNuaXA6IFwiVXRmw7ZyIGVuIGtvc3RuYWRzYXZzdMOlbmRzYW5hbHlzIG1lZCBrw6RsbC0gb2NoIG3DpWxpbmRhdGEgc29tIHNlZGFuIGFudsOkbmRzIGbDtnIgYXR0IGZhc3RzdMOkbGxhIGRlbiBiaWxsaWdhc3RlIHJ1dHRlbiBmcsOlbiBlbiBrw6RsbGEgdGlsbCBldHQgbcOlbC5cIixcblx0XHRzaG9ydGVzdFBhdGhEZXNjOiBcIkZ1bmt0aW9uZW4gQmlsbGlnYXN0ZSBydXR0ZW4gYmVyw6RrbmFyIGRlbiBiaWxsaWdhc3RlIHJ1dHRlbiBmcsOlbiBlbiBrw6RsbGEgdGlsbCBlbiBkZXN0aW5hdGlvbi4gRGVuIGzDpGdzdGEgYWNrdW11bGVyYWRlIGtvc3RuYWRlbiBiZXLDpGtuYXMgZsO2ciBhdnN0w6VuZGV0IGbDtnIgdmFyamUgcGl4ZWwgw7Z2ZXIgZW4ga29zdG5hZHN5dGEgdGlsbCBuw6RybWFzdGUga8OkbGxhLiBEZXR0YSBwcm9kdWNlcmFyIGV0dCB1dGRhdGFyYXN0ZXIgc29tIHJlZ2lzdHJlcmFyIGRlbiBiaWxsaWdhc3RlIHJ1dHRlbiwgZWxsZXIgcnV0dGVybmEsIGZyw6VuIHZhbGRhIHBsYXRzZXIgdGlsbCBkZW4gbsOkcm1hc3RlIHVyc3BydW5nc2NlbGxlbiBzb20gZGVmaW5pZXJhdHMgaW5vbSBkZW4gYWNrdW11bGVyYWRlIGtvc3RuYWRzeXRhbiwgbWVkIGF2c2VlbmRlIHDDpSBrb3N0bmFkIGbDtnIgYXZzdMOlbmQuPGRpdj48YnIvPkRlbiBiaWxsaWdhc3RlIHJ1dHRlbiB0aWxsZGVsYXMgYWxsdGlkIGV0dCB2w6RyZGUgbsOkciBkZW4gcMOldHLDpGZmYXMgdW5kZXIgc2thbm5pbmdzcHJvY2Vzc2VuLiBEZW4gYXZzbHV0YW5kZSBwaXhlbG4gcMOlIGvDpGxscmFzdHJldCBmw7ZyIGVuIGtvc3RuYWRzcnV0dCBmw6VyIHbDpHJkZXQgMS4gRGVuIGbDtnJzdGEgcnV0dGVuIGbDpXIgdsOkcmRldCAzLCBuw6RzdGEgNCBvLnMudi4gTsOkciBmbGVyYSBydXR0ZXIgc2FtbWFuZm9nYXMgb2NoIGbDtmxqZXIgc2FtbWEgcnV0dCB0aWxsYmFrYSB0aWxsIGVuIGvDpGxsYSwgdGlsbGRlbGFzIHNlZ21lbnRldCBkw6RyIGRlIHR2w6UgcnV0dGVybmEgcmVzZXIgdGlsbHNhbW1hbnMgdsOkcmRldCAyLiBEZW4gc2FtbWFuZm9nYWRlIGRlbGVuIGF2IHJ1dHRlbiBrYW4gaW50ZSB0aWxsZGVsYXMgdsOkcmRldCBmw7ZyIGVuIGF2IHJ1dHRlcm5hLCBlZnRlcnNvbSBkZW4gc2FtbWFuZm9nYWRlIGRlbGVuIHRpbGxow7ZyIGLDpWRhIHJ1dHRlcm5hLjwvZGl2PlwiLFxuXHRcdGxlc3NUaGFuRXF1YWxOYW1lOiBcIk1pbmRyZSDDpG4gZWxsZXIgbGlrYSBtZWRcIixcblx0XHRsZXNzVGhhbkVxdWFsU25pcDogXCJVdGbDtnIgZW4gcmVsYXRpb25lbGwgbWluZHJlIMOkbi9saWthIG1lZC3DpXRnw6RyZCBww6UgdHbDpSBpbmRhdGF2w6RyZGVuLCBjZWxsIGbDtnIgY2VsbC4gUmV0dXJuZXJhciAxIGbDtnIgY2VsbGVyIGTDpHIgZGV0IGbDtnJzdGEgcmFzdHJldCDDpHIgbWluZHJlIMOkbiBlbGxlciBsaWthIG1lZCBkZXQgYW5kcmEgcmFzdHJldCBvY2ggMCBvbSBkZXQgaW50ZSDDpHIgZGV0LlwiLFxuXHRcdGxlc3NUaGFuRXF1YWxEZXNjOiBcIkZ1bmt0aW9uZW4gdXRmw7ZyIGVuIHJlbGF0aW9uZWxsIG1pbmRyZSDDpG4vbGlrYSBtZWQtw6V0Z8OkcmQgcMOlIHR2w6UgaW5kYXRhLCBwaXhlbCBmw7ZyIHBpeGVsLiBEZW4gcmV0dXJuZXJhciB2w6RyZGV0IDEgZsO2ciBwaXhsYXIgZMOkciBkZXQgZsO2cnN0YSByYXN0cmV0IMOkciBtaW5kcmUgw6RuIGVsbGVyIGxpa2EgbWVkIGRldCBhbmRyYSByYXN0cmV0IG9jaCB2w6RyZGV0IDAgZsO2ciBwaXhsYXIgZMOkciBkZXQgaW50ZSDDpHIgbWluZHJlIMOkbiBlbGxlciBsaWthIG1lZCBkZXQgYW5kcmEgcmFzdHJldC5cIixcblx0XHRsZXNzVGhhbk5hbWU6IFwiTWluZHJlIMOkblwiLFxuXHRcdGxlc3NUaGFuU25pcDogXCJVdGbDtnIgZW4gcmVsYXRpb25lbGwgbWluZHJlIMOkbi3DpXRnw6RyZCBww6UgdHbDpSBpbmRhdGF2w6RyZGVuLCBjZWxsIGbDtnIgY2VsbC4gUmV0dXJuZXJhciAxIGbDtnIgY2VsbGVyIGTDpHIgZGV0IGbDtnJzdGEgcmFzdHJldCDDpHIgbWluZHJlIMOkbiBkZXQgYW5kcmEgcmFzdHJldCBvY2ggMCBvbSBkZXQgaW50ZSDDpHIgZGV0LlwiLFxuXHRcdGxlc3NUaGFuRGVzYzogXCJGdW5rdGlvbmVuIHV0ZsO2ciBlbiByZWxhdGlvbmVsbCBtaW5kcmUgw6RuLcOldGfDpHJkIHDDpSB0dsOlIGluZGF0YSwgcGl4ZWwgZsO2ciBwaXhlbC4gRGVuIHJldHVybmVyYXIgdsOkcmRldCAxIGbDtnIgcGl4bGFyIGTDpHIgZGV0IGbDtnJzdGEgcmFzdHJldCDDpHIgbWluZHJlIMOkbiBkZXQgYW5kcmEgcmFzdHJldCBvY2ggdsOkcmRldCAwIG9tIGRldCBpbnRlIMOkciBtaW5kcmUgw6RuIGRldCBhbmRyYSByYXN0cmV0LlwiLFxuXHRcdGxuTmFtZTogXCJMblwiLFxuXHRcdGxuU25pcDogXCJCZXLDpGtuYXIgZGVuIG5hdHVybGlnYSBsb2dhcml0bWVuIChiYXMgZSkgZsO2ciBjZWxsZXJuYSBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0bG5EZXNjOiBcIkZ1bmt0aW9uZW4gTG4gYmVyw6RrbmFyIGRlbiBuYXR1cmxpZ2EgbG9nYXJpdG1lbiAoYmFzIGUpIGbDtnIgdmFyamUgcGl4ZWwgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGxvZzEwTmFtZTogXCJMb2cxMFwiLFxuXHRcdGxvZzEwU25pcDogXCJCZXLDpGtuYXIgYmFzIDEwLWxvZ2FyaXRtZW4gZsO2ciBjZWxsZXJuYSBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0bG9nMTBEZXNjOiBcIkZ1bmt0aW9uZW4gTG9nMTAgYmVyw6RrbmFyIGJhcyAxMC1sb2dhcml0bWVuIGbDtnIgdmFyamUgcGl4ZWwgaSBldHQgcmFzdGVyLlwiLFxuXHRcdGxvZzJOYW1lOiBcIkxvZzJcIixcblx0XHRsb2cyU25pcDogXCJCZXLDpGtuYXIgYmFzIDItbG9nYXJpdG1lbiBmw7ZyIGNlbGxlcm5hIGkgZXR0IHJhc3Rlci5cIixcblx0XHRsb2cyRGVzYzogXCJGdW5rdGlvbmVuIExvZzIgYmVyw6RrbmFyIGJhcyAyLWxvZ2FyaXRtZW4gZsO2ciB2YXJqZSBwaXhlbCBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0bG9va3VwTmFtZTogXCJTw7ZrXCIsXG5cdFx0bG9va3VwU25pcDogXCJTa2FwYXIgZXR0IG55dHQgcmFzdGVyIGdlbm9tIGF0dCBzw7ZrYSB2w6RyZGVuIHNvbSBmaW5ucyBpIGV0dCBhbm5hdCBmw6RsdCBpIGluZGF0YXJhc3RyZXRzIHRhYmVsbC5cIixcblx0XHRsb29rdXBEZXNjOiBcIkZ1bmt0aW9uZW4gc2thcGFyIGV0dCBueXR0IHJhc3RlciBnZW5vbSBhdHQgc8O2a2EgdsOkcmRlbiBzb20gZmlubnMgaSBldHQgYW5uYXQgZsOkbHQgaSBpbmRhdGFyYXN0cmV0cyB0YWJlbGwuXCIsXG5cdFx0bWxDbGFzc2lmeU5hbWU6IFwiTUwta2xhc3NpZmljZXJhXCIsXG5cdFx0bWxDbGFzc2lmeVNuaXA6IFwiS2xhc3NpZmljZXJhciBiaWxkZXIgcGVyIHBpeGVsLiBCbGFuZGFkZSBwaXhsYXIgdGlsbGRlbGFzIGdlb29iamVrdGV0IG1lZCBkZXQgaMO2Z3N0YSBwcm9jZW50dsOkcmRldCBpIGRlbiBwaXhlbG4uXCIsXG5cdFx0bWxDbGFzc2lmeURlc2M6IFwiRnVua3Rpb25lbiBNTC1rbGFzc2lmaWNlcmEgZ8O2ciBhdHQgZHUga2FuIHV0ZsO2cmEgZW4gw7Z2ZXJ2YWthZCBrbGFzc2lmaWNlcmluZyBnZW5vbSBhdHQgYW52w6RuZGEgYWxnb3JpdG1lbiBrbGFzc2lmaWNlcmluZyBtZWQgbWF4aW1hbCBzYW5ub2xpa2hldCBww6UgZXR0IHJhc3RlcmRhdGFzZXQgZWxsZXIgbW9zYWlrZGF0YXNldC4gRGVuIGjDpHIgZnVua3Rpb25lbiBrcsOkdmVyIGVuIGtsYXNzaWZpY2VyaW5nc3NpZ25hdHVyZmlsLlwiLFxuXHRcdG1hc2tOYW1lOiBcIk1hc2thXCIsXG5cdFx0bWFza1NuaXA6IFwiQW5nZXIgdsOkcmRlbiBkdSBpbnRlIHZpbGwgdmlzYS5cIixcblx0XHRtYXNrRGVzYzogXCJEZW4gaMOkciByYXN0ZXJmdW5rdGlvbmVuIGFuZ2VyIHbDpHJkZW4gc29tIGR1IGludGUgdmlsbCB2aXNhIGkgZGl0dCByYXN0ZXIuIE7DpHIgZHUgYW52w6RuZGVyIGZ1bmt0aW9uZW4gTWFza25pbmcgYW5nZXIgZHUgZW4gZWxsZXIgZmxlcmEgTm9EYXRhLXbDpHJkZW4gZWxsZXIgZXR0IGludGVydmFsbCBtZWQgZ2lsdGlnYSBwaXhlbHbDpHJkZW4uIFwiLFxuXHRcdG1pbnVzTmFtZTogXCJNaW51c1wiLFxuXHRcdG1pbnVzU25pcDogXCJTdWJ0cmFoZXJhciB2w6RyZGV0IGbDtnIgZGV0IGFuZHJhIGluZGF0YXJhc3RyZXQgZnLDpW4gdsOkcmRldCBmw7ZyIGRldCBmw7Zyc3RhIGluZGF0YXJhc3RyZXQgcMOlIGNlbGwtZsO2ci1jZWxsLWJhcy5cIixcblx0XHRtaW51c0Rlc2M6IFwiTWludXNmdW5rdGlvbmVuIHN1YnRyYWhlcmFyIHbDpHJkZXQgZsO2ciBkZXQgYW5kcmEgaW5kYXRhcmFzdHJldCBmcsOlbiB2w6RyZGV0IGbDtnIgZGV0IGbDtnJzdGEgaW5kYXRhcmFzdHJldCBwaXhlbCBmw7ZyIHBpeGVsLlwiLFxuXHRcdG1vZE5hbWU6IFwiTW9kXCIsXG5cdFx0bW9kU25pcDogXCJIaXR0YXIgcmVzdGVuIChtb2R1bG8pIGF2IGRldCBmw7Zyc3RhIHJhc3RyZXQgbsOkciBkZXQgZGl2aWRlcmFzIG1lZCBkZXQgYW5kcmEgcmFzdHJldCBww6UgY2VsbC1mw7ZyLWNlbGwtYmFzLlwiLFxuXHRcdG1vZERlc2M6IFwiRnVua3Rpb25lbiBNb2QgaGl0dGFyIHJlc3RlbiAobW9kdWxvKSBhdiBkZXQgZsO2cnN0YSByYXN0cmV0IG7DpHIgZGV0IGRpdmlkZXJhcyBtZWQgZGV0IGFuZHJhIHJhc3RyZXQgcGl4ZWwgZsO2ciBwaXhlbC4gT3JkbmluZ2VuIHDDpSBpbmRhdGEgw6RyIHZpa3RpZyBvY2ggcMOldmVya2FyIHV0ZGF0YXJlc3VsdGF0ZXQuXCIsXG5cdFx0bW9zYWljUmFzdGVyc05hbWU6IFwiTW9zYWlrcmFzdGVyXCIsXG5cdFx0bW9zYWljUmFzdGVyc1NuaXA6IFwiU2FtbWFuZm9nYXIgZW4gdXBwc8OkdHRuaW5nIHJhc3RlcmRhdGFzZXQgZsO2ciBhdHQgc2thcGEgZXR0IGRhdGFzZXQuXCIsXG5cdFx0bW9zYWljUmFzdGVyc0Rlc2M6IFwiRnVua3Rpb25lbiBNb3NhaWtyYXN0ZXIgc2thcGFyIGVuIG1vc2Fpa2JpbGQgYXYgZmxlcmEgYmlsZGVyLiBOw6RyIGRldCBmaW5ucyBlbiDDtnZlcmxhcHBuaW5nIG1lbGxhbiBiaWxkZXJuYSBmaW5ucyBkZXQgZmxlcmEgbWV0b2RlciBzb20gZHUga2FuIHbDpGxqYSBtZWxsYW4gZsO2ciBhdHQgYXZnw7ZyYSB2aWxrYSBiaWxkZXIgc29tIHZpc2FzLlwiLFxuXHRcdG5kdmlDb2xvcml6ZWROYW1lOiBcIk5EVkktZsOkcmdsYWdkXCIsXG5cdFx0bmR2aUNvbG9yaXplZFNuaXA6IFwiU2thcGFyIGV0dCBmbGVyYmFuZHNkYXRhc2V0IHNvbSB2aXNhciB2ZWdldGF0aW9uZW5zIGZyb2RpZ2hldCBiYXNlcmF0IHDDpSBza2lsbG5hZGVuIG1lbGxhbiBkZSByw7ZkYSBvY2ggbsOkcmEgaW5mcmFyw7ZkYSBiYW5kZW4uXCIsXG5cdFx0bmR2aUNvbG9yaXplZERlc2M6IFwiRnVua3Rpb25lbiBORFZJLWbDpHJnbGFnZCB0aWxsw6RtcGFyIE5EVkktZnVua3Rpb25lbiBww6UgaW5kYXRhYmlsZGVuIG9jaCBhbnbDpG5kZXIgc2VkYW4gZW4gZsOkcmdrYXJ0YSBlbGxlciBlbiBmw6RyZ3JhbXAgZsO2ciBhdHQgdmlzYSByZXN1bHRhdGV0LlwiLFxuXHRcdG5kdmlOYW1lOiBcIk5EVklcIixcblx0XHRuZHZpU25pcDogXCJCZXLDpGtuYXIgTm9ybWFsaXplZCBEaWZmZXJlbmNlIFZlZ2V0YXRpb24gSW5kZXggKE5EVkkpLlwiLFxuXHRcdG5kdmlEZXNjOiBcIk5EVkktZnVua3Rpb25lbiBza2FwYXIgZXR0IGRhdGFzZXQgbWVkIGV0dCBiYW5kIHNvbSB2aXNhciB2ZWdldGF0aW9uZW5zIGZyb2RpZ2hldCBiYXNlcmF0IHDDpSBza2lsbG5hZGVuIG1lbGxhbiBkZSByw7ZkYSBvY2ggaW5mcmFyw7Z0dG7DpHJhIGJhbmRlbi48ZGl2Pjxici8+TkRWSSDDpHIgZXR0IHN0YW5kYXJkaXNlcmF0IGluZGV4IHNvbSBsw6V0ZXIgZGlnIGdlbmVyZXJhIGVuIGJpbGQgc29tIHZpc2FyIGdyw7ZuaGV0LCBzb20gb2Nrc8OlIGthbGxhcyByZWxhdGl2IGJpb21hc3NhLiBEZXQgaMOkciBpbmRleGV0IGRyYXIgbnl0dGEgYXYga29udHJhc3RlbiBtZWxsYW4gZWdlbnNrYXBlcm5hIGhvcyB0dsOlIGJhbmQgaSBldHQgbXVsdGlzcGVrdHJhbHQgcmFzdGVyZGF0YXNldDoga2xvcm9meWxscGlnbWVudGFic29ycHRpb25lbiBpIGRldCByw7ZkYSBiYW5kZXQgb2NoIGRlbiBow7ZnYSByZWZsZWt0aXZpdGV0ZW4gaG9zIHbDpHh0bWF0ZXJpYWwgaSBkZXQgbsOkcmEgaW5mcmFyw7ZkYSAoTklSKSBiYW5kZXQuIEV4dHJlbXQgbMOlZ2EgZWxsZXIgbmVnYXRpdmEgTkRWSS12w6RyZGVuIHJlcHJlc2VudGVyYXIgb21yw6VkZW4gdXRhbiB2w6R4dGxpZ2hldCwgdC5leC4gbW9sbiwgdmF0dGVuIGVsbGVyIHNuw7YuIE15Y2tldCBsw6VnYSB2w6RyZGVuIHJlcHJlc2VudGVyYXIgb21yw6VkZW4gbWVkIGxpdGVuIGVsbGVyIGluZ2VuIHbDpHh0bGlnaGV0LCBzb20gYmV0b25nLCBrbGlwcG9yIGVsbGVyIG5ha2VuIGpvcmQuIE1lZGVsaMO2Z2EgdsOkcmRlbiByZXByZXNlbnRlcmFyIG9tcsOlZGVuIG1lZCBidXNrYXIgb2NoIGdyw6RzbWFya2VyLiBIw7ZnYSB2w6RyZGVuIHJlcHJlc2VudGVyYXIgc2tvZ3NvbXLDpWRlbiBvY2ggZ3LDtm5za2FuZGUgdsOkeHRsaWdoZXQuPC9kaXY+XCIsXG5cdFx0bmVnYXRlTmFtZTogXCJOZWdlcmFcIixcblx0XHRuZWdhdGVTbmlwOiBcIsOEbmRyYXIgdGVja25ldCAobXVsdGlwbGljZXJhciBtZWQgLTEpIGbDtnIgY2VsbHbDpHJkZW5hIGkgaW5kYXRhcmFzdHJldCBww6UgY2VsbC1mw7ZyLWNlbGwtYmFzLlwiLFxuXHRcdG5lZ2F0ZURlc2M6IFwiRnVua3Rpb25lbiBOZWdlcmEgw6RuZHJhciB0ZWNrbmV0IChtdWx0aXBsaWNlcmFyIG1lZCAtMSkgZsO2ciBwaXhlbHbDpHJkZW5hIGkgaW5kYXRhcmFzdHJldCBww6UgZW4gcGl4ZWwuIFwiLFxuXHRcdG5pYmJsZU5hbWU6IFwiTmFnZ2FcIixcblx0XHRuaWJibGVTbmlwOiBcIkVyc8OkdHRlciBjZWxsZXIgaSBldHQgcmFzdGVyIGVubGlndCBlbiBtYXNrIG1lZCB2w6RyZGVuYSBmw7ZyIGRlIG7DpHJtYXN0ZSBncmFubmFybmEuXCIsXG5cdFx0bmliYmxlRGVzYzogXCJEZW4gZ2xvYmFsYSBmdW5rdGlvbmVuIE5hZ2dhIG3DtmpsaWdnw7ZyIGF0dCBtYXJrZXJhZGUgb21yw6VkZW4gaSBldHQgcmFzdGVyIGthbiB0aWxsZGVsYXMgc2FtbWEgdsOkcmRlIHNvbSBkZXJhcyBuw6RybWFzdGUgZ3Jhbm5lLiBEZXR0YSDDpHIgcHJha3Rpc2t0IGbDtnIgYXR0IHJlZGlnZXJhIG9tcsOlZGVuIGkgZXR0IHJhc3RlciBkw6RyIGRhdGEga2FuIHZhcmEgZmVsYWt0aWdhLlwiLFxuXHRcdG5vdEVxdWFsTmFtZTogXCJJbnRlIGxpa2EgbWVkXCIsXG5cdFx0bm90RXF1YWxTbmlwOiBcIlV0ZsO2ciBlbiByZWxhdGlvbmVsbCBpbnRlIGxpa2EgbWVkLcOldGfDpHJkIHDDpSB0dsOlIGluZGF0YXbDpHJkZW4gY2VsbCBmw7ZyIGNlbGwuIFJldHVybmVyYXIgMSBmw7ZyIGNlbGxlciBkw6RyIGRldCBmw7Zyc3RhIHJhc3RyZXQgaW50ZSDDpHIgbGlrYSBtZWQgZGV0IGFuZHJhIHJhc3RyZXQgb2NoIDAgb20gZGUgw6RyIGxpa2EuXCIsXG5cdFx0bm90RXF1YWxEZXNjOiBcIkZ1bmt0aW9uZW4gdXRmw7ZyIGVuIHJlbGF0aW9uZWxsIGludGUgbGlrYSBtZWQtw6V0Z8OkcmQgcMOlIHR2w6UgaW5kYXRhdsOkcmRlbiBwaXhlbCBmw7ZyIHBpeGVsLiBEZW4gcmV0dXJuZXJhciBldHQgdsOkcmRlIHDDpSAxIGbDtnIgcGl4bGFyIGTDpHIgZGV0IGbDtnJzdGEgcmFzdHJldCBpbnRlIMOkciBsaWthIG1lZCBkZXQgYW5kcmEgcmFzdHJldCBvY2ggZXR0IHbDpHJkZSBww6UgMCBmw7ZyIHBpeGxhciBkw6RyIGRldCDDpHIgbGlrYSBtZWQgZGV0IGFuZHJhIHJhc3RyZXQuXCIsXG5cdFx0cGFuc2hhcnBlbmluZ05hbWU6IFwiUGFub3JlcmluZ3Nza8OkcnBuaW5nXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1NuaXA6IFwiRsO2cmLDpHR0cmFyIGRlbiBnZW9ncmFmaXNrYSB1cHBsw7ZzbmluZ2VuIGkgZW4gYmlsZCBtZWQgZmxlcmEgYmFuZCBww6Uga29uc3Rnam9yZCB2w6RnIGdlbm9tIGF0dCBzbcOkbHRhIHNhbW1hbiBkZW4gbWVkIGVuIHBhbmtyb21hdGlzayBiaWxkIG1lZCBow7ZncmUgdXBwbMO2c25pbmcuXCIsXG5cdFx0cGFuc2hhcnBlbmluZ0Rlc2M6IFwiRnVua3Rpb25lbiBQYW5vcmVyaW5nc3Nrw6RycG5pbmcgYW52w6RuZGVyIGVuIHBhbmtyb21hdGlzayBiaWxkIG1lZCBow7ZncmUgdXBwbMO2c25pbmcgZWxsZXIgZXR0IHJhc3RlcmJhbmQgZsO2ciBhdHQgc23DpGx0YSBzYW1tYW4gZGVuIG1lZCBldHQgbMOlZ3VwcGzDtnN0IHJhc3RlcmRhdGFzZXQgbWVkIGZsZXJhIGJhbmQgaSBzeWZ0ZSBhdHQgw7ZrYSBmbGVyYmFuZHNiaWxkZW5zIGdlb2dyYWZpc2thIHVwcGzDtnNuaW5nLjxkaXY+PGJyLz5TeWZ0ZXQgbWVkIHBhbm9yZXJpbmdzc2vDpHJwbmluZyDDpHIgYXR0IHNrYXBhIGVuIHZpc3VlbGwgYmlsZCBtZWQgaMO2Z3JlIGt2YWxpdGV0LiBFZnRlcnNvbSB0ZWtuaWtlcm5hIMOkbmRyYXIgZmxlcmJhbmRzYmlsZGVybmFzIHJhZGlvbWV0cmkgb2NoIHNwZWt0cmFsYSBlZ2Vuc2thcGVyIG3DpXN0ZSBwYW5vcmVyaW5nc3Nrw6RycHRhIGJpbGRlciBhbnbDpG5kYXMgbWVkIGbDtnJzaWt0aWdoZXQgdmlkIGZqw6RycmFuYWx5cy48L2Rpdj5cIixcblx0XHRwYXRoQWxsb2NhdGlvbk5hbWU6IFwiUnV0dGF2c3TDpW5kc2FsbG9rZXJpbmdcIixcblx0XHRwYXRoQWxsb2NhdGlvblNuaXA6IFwiQmVyw6RrbmFyIGvDpGxsYW4gbWVkIGzDpGdzdCBrb3N0bmFkIGbDtnIgdmFyamUgY2VsbCBiYXNlcmF0IHDDpSBkZW4gbMOkZ3N0YSBhY2t1bXVsZXJhZGUga29zdG5hZGVuIMO2dmVyIGVuIGtvc3RuYWRzeXRhLCBzYW10aWRpZ3Qgc29tIGjDpG5zeW4gdGFzIHRpbGwgeXRhdnN0w6VuZGV0IHNhbXQgaG9yaXNvbnRlbGxhIG9jaCB2ZXJ0aWthbGEga29zdG5hZHNmYWt0b3Jlci5cIixcblx0XHRwYXRoQWxsb2NhdGlvbkRlc2M6IFwiUnV0dGF2c3TDpW5kc2FsbG9rZXJpbmdlbiBiZXLDpGtuYXIgZGVuIG7DpHJtYXN0ZSBrw6RsbGFuIGbDtnIgdmFyamUgY2VsbCBiYXNlcmF0IHDDpSBkZW4gbMOkZ3N0YSBhY2t1bXVsZXJhZGUga29zdG5hZGVuIMO2dmVyIGVuIGtvc3RuYWRzeXRhLCBzYW10aWRpZ3Qgc29tIGjDpG5zeW4gdGFzIHRpbGwgeXRhdnN0w6VuZGV0IHNhbXQgaG9yaXNvbnRlbGxhIG9jaCB2ZXJ0aWthbGEga29zdG5hZHNmYWt0b3Jlci5cIixcblx0XHRwYXRoQmFja0xpbmtOYW1lOiBcIkJha8OldGzDpG5rIGbDtnIgcnV0dGF2c3TDpW5kXCIsXG5cdFx0cGF0aEJhY2tMaW5rU25pcDogXCJEZWZpbmllcmFyIGdyYW5uZW4gc29tIMOkciBuw6RzdGEgY2VsbCBww6UgcnV0dGVuIGbDtnIgbMOkZ3N0YSBhY2t1bXVsZXJhZCBrb3N0bmFkIHRpbGwgZGVuIGJpbGxpZ2FzdGUga8OkbGxhbiwgc2FtdGlkaWd0IHNvbSBow6Ruc3luIHRhcyB0aWxsIHl0YXZzdMOlbmRldCBzYW10IGhvcmlzb250ZWxsYSBvY2ggdmVydGlrYWxhIGtvc3RuYWRzZmFrdG9yZXIuXCIsXG5cdFx0cGF0aEJhY2tMaW5rRGVzYzogXCJCYWvDpXRsw6RuayBmw7ZyIHJ1dHRhdnN0w6VuZCBpZGVudGlmaWVyYXIgaW5yaWt0bmluZ2VuIGbDtnIgZ3Jhbm5lbiBzb20gw6RyIG7DpHN0YSBjZWxsIHDDpSBydXR0ZW4gZsO2ciBsw6Rnc3RhIGFja3VtdWxlcmFkIGtvc3RuYWQgdGlsbCBkZW4gbsOkcm1hc3RlIGvDpGxsYW4sIHNhbXRpZGlndCBzb20gaMOkbnN5biB0YXMgdGlsbCB5dGF2c3TDpW5kZXQgc2FtdCBob3Jpc29udGVsbGEgb2NoIHZlcnRpa2FsYSBrb3N0bmFkc2Zha3RvcmVyLlwiLFxuXHRcdHBhdGhEaXN0YW5jZU5hbWU6IFwiUnV0dGF2c3TDpW5kXCIsXG5cdFx0cGF0aERpc3RhbmNlU25pcDogXCJCZXLDpGtuYXIgZsO2ciB2YXJqZSBjZWxsIGzDpGdzdGEgYWNrdW11bGVyYWQga29zdG5hZCBmw7ZyIGF2c3TDpW5kZXQgZnLDpW4gZWxsZXIgdGlsbCBkZW4gYmlsbGlnYXN0ZSBrw6RsbGFuLCBzYW10aWRpZ3Qgc29tIGjDpG5zeW4gdGFzIHRpbGwgeXRhdnN0w6VuZGV0IHNhbXQgaG9yaXNvbnRlbGxhIG9jaCB2ZXJ0aWthbGEga29zdG5hZHNmYWt0b3Jlci5cIixcblx0XHRwYXRoRGlzdGFuY2VEZXNjOiBcIkZ1bmt0aW9uZW4gUnV0dGF2c3TDpW5kIGJlcsOka25hciBmw7ZyIHZhcmplIGNlbGwgbMOkZ3N0YSBhY2t1bXVsZXJhZCBrb3N0bmFkIGbDtnIgYXZzdMOlbmRldCB0aWxsIGRlbiBuw6RybWFzdGUga8OkbGxhbiwgc2FtdGlkaWd0IHNvbSBow6Ruc3luIHRhcyB0aWxsIHl0YXZzdMOlbmRldCBzYW10IGhvcmlzb250ZWxsYSBvY2ggdmVydGlrYWxhIGtvc3RuYWRzZmFrdG9yZXIuXCIsXG5cdFx0cGx1c05hbWU6IFwiUGx1c1wiLFxuXHRcdHBsdXNTbmlwOiBcIkFkZGVyYXIgKHN1bW1lcmFyKSB2w6RyZGVuYSBmw7ZyIHR2w6UgcmFzdGVyIGNlbGwgZsO2ciBjZWxsLlwiLFxuXHRcdHBsdXNEZXNjOiBcIkZ1bmt0aW9uZW4gUGx1cyBhZGRlcmFyIChzdW1tZXJhcikgdsOkcmRlbmEgZsO2ciB0dsOlIHJhc3RlciBwaXhlbCBmw7ZyIHBpeGVsLlwiLFxuXHRcdHBvd2VyTmFtZTogXCJQb3RlbnNcIixcblx0XHRwb3dlclNuaXA6IFwiVXBwaMO2amVyIGNlbGx2w6RyZGVuYSBpIGV0dCByYXN0ZXIgdGlsbCB2w6RyZGVuIGZyw6VuIGV0dCBhbm5hdCByYXN0ZXIuXCIsXG5cdFx0cG93ZXJEZXNjOiBcIkZ1bmt0aW9uZW4gUG90ZW5zIHVwcGjDtmplciBwaXhlbHbDpHJkZW5hIGkgZXR0IHJhc3RlciB0aWxsIHbDpHJkZW4gZnLDpW4gZXR0IGFubmF0IHJhc3Rlci5cIixcblx0XHRyYWRhckNhbGlicmF0aW9uTmFtZTogXCJSYWRhcmthbGlicmVyaW5nXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvblNuaXA6IFwiS29udmVydGVyYXIgUkFEQVJTQVQtMi1iYWvDpXRzdHLDpWxuaW5nLlwiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25EZXNjOiBcIkRlbiBow6RyIGZ1bmt0aW9uZW4ga2FuIGFudsOkbmRhcyB0aWxsIGF0dCBrYWxpYnJlcmEgUkFEQVJTQVQtMi1iaWxkZXIgaSBldHQgbW9zYWlrZGF0YXNldCBlbGxlciBzb20gZW4gcmFzdGVycHJvZHVrdC4gS2FsaWJyZXJpbmdlbiB1dGbDtnJzIHDDpSByYWRhcmJpbGRlciBzw6UgYXR0IHBpeGVsdsOkcmRlbmEgw6RyIGVuIHZlcmtsaWcgcmVwcmVzZW50YXRpb24gYXYgcmFkYXJiYWvDpXRzdHLDpWxuaW5nZW4uXCIsXG5cdFx0cmFzdGVySW5mb05hbWU6IFwiUmFzdGVySW5mb1wiLFxuXHRcdHJhc3RlckluZm9TbmlwOiBcIsOEbmRyYXIgZWdlbnNrYXBlciBmw7ZyIHJhc3RyZXQsIHQuZXguIGJpdGRqdXAsIE5vRGF0YS12w6RyZGUsIGNlbGxzdG9ybGVrIG8ucy52LlwiLFxuXHRcdHJhc3RlckluZm9EZXNjOiBcIlJhc3RlckluZm8gw7ZwcG5hciBlbiBkaWFsb2dydXRhIG1lZCBlZ2Vuc2thcGVyIGbDtnIgcmFzdGVyZGF0YXNldCwgdC5leC4gYW50YWxldCBrb2x1bW5lciBvY2ggcmFkZXIsIGFudGFsZXQgYmFuZCwgcGl4ZWx0eXBlbiwgdXRicmVkbmluZ2VuIG9jaCBkZW4gZ2VvZ3JhZmlza2EgcmVmZXJlbnNlbi4gRHUga2FuIHJlZGlnZXJhIGRlc3NhIGVnZW5za2FwZXIgZ2Vub20gYXR0IHbDpGxqYSBldHQgcmFzdGVyZGF0YXNldCBzb20gc2thIGFudsOkbmRhcyBzb20gbWFsbC4gXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc05hbWU6IFwiUmFzdHJlcmEgYXR0cmlidXRcIixcblx0XHRyYXN0ZXJpemVBdHRyaWJ1dGVzU25pcDogXCJCZXJpa2FyIGV0dCByYXN0ZXIgZ2Vub20geXR0ZXJsaWdhcmUgYmFuZCBzb20gaMOkcnLDtnIgZnLDpW4gdsOkcmRlbiBmw7ZyIGFuZ2l2bmEgYXR0cmlidXQgZnLDpW4gZW4gZXh0ZXJuIHRhYmVsbCBlbGxlciBlbiBnZW9vYmpla3R0asOkbnN0LlwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNEZXNjOiBcIkZ1bmt0aW9uZW4gUmFzdHJlcmEgYXR0cmlidXQgYmVyaWthciBldHQgcmFzdGVyIGdlbm9tIGF0dCBsw6RnZ2EgdGlsbCBiYW5kIHNvbSBow6RycsO2ciBmcsOlbiB2w6RyZGVuIGbDtnIgYW5naXZuYSBhdHRyaWJ1dCBmcsOlbiBlbiBleHRlcm4gdGFiZWxsIGVsbGVyIGVuIGdlb29iamVrdHRqw6Ruc3QuIE9tIGR1IHZpbGwga2FuIGR1IGFuZ2UgZXR0IHpvbnJhc3RlciBvY2ggZGV0IHRpbGxow7ZyYW5kZSB6b24tSUQtYXR0cmlidXRldCBmw7ZyIGF0dCBha3RpdmVyYSByZWdpb25iYXNlcmFkIHPDtmtuaW5nLlwiLFxuXHRcdHJhc3Rlcml6ZUZlYXR1cmVDbGFzc05hbWU6IFwiUmFzdHJlcmEgZ2Vvb2JqZWt0XCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzU25pcDogXCJLb252ZXJ0ZXJhciBnZW9vYmpla3QgdGlsbCByYXN0ZXIuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzRGVzYzogXCJEZW4gaMOkciBmdW5rdGlvbmVuIGtvbnZlcnRlcmFyIHBvbHlnb24tLCBwb2x5bGluamUtIG9jaCBwdW5rdGdlb29iamVrdGtsYXNzZGF0YSB0aWxsIGV0dCByYXN0ZXJsYWdlci48ZGl2Pjxici8+R2Vvb2JqZWt0IHRpbGxkZWxhcyBwaXhlbHbDpHJkZW4gYmFzZXJhdCBww6UgZ2Vvb2JqZWt0ZW5zIE9CSkVDVElEIChzdGFuZGFyZCkuIFBpeGVsdsOkcmRlbmEga2FuIG9ja3PDpSBiYXNlcmFzIHDDpSBldHQgYW52w6RuZGFyZGVmaW5pZXJhdCB2w6RyZGVmw6RsdCBpIGluZGF0YWdlb29iamVrdGV0cyBhdHRyaWJ1dHRhYmVsbC48L2Rpdj5cIixcblx0XHRyZWNhc3ROYW1lOiBcIkfDtnIgb21cIixcblx0XHRyZWNhc3RTbmlwOiBcIsOEbmRyYXIgcGFyYW1ldHJhcm5hIGhvcyBlbiBmdW5rdGlvbnNrZWRqYSBpIGV0dCBtb3NhaWtkYXRhc2V0IGVsbGVyIGVuIGJpbGR0asOkbnN0LiBEZXQgYW52w6RuZHMgb2Z0YSBtZWQgTEFTLWRhdGFzZXQgc8OlIGF0dCBkdSBpbnRlIGJlaMO2dmVyIHNrYXBhIGV0dCBzZXBhcmF0IG1vc2Fpa2RhdGFzZXQgZsO2ciBvbGlrYSByZXByZXNlbnRhdGlvbmVyIGF2IHRlcnLDpG5nLlwiLFxuXHRcdHJlY2FzdERlc2M6IFwiRnVua3Rpb25lbiBHw7ZyIG9tIGFudsOkbmRzIGbDtnIgYXR0IGR5bmFtaXNrdCBtb2RpZmllcmEgZGVuIGZ1bmt0aW9uc3BhcmFtZXRlciBzb20gYW52w6RuZGFzIGkgZXR0IG1vc2Fpa2RhdGFzZXQgZWxsZXIgZW4gYmlsZHRqw6Ruc3QgdXRhbiBhdHQgZnlzaXNrdCBiZXZhcmEgw6RuZHJpbmdhcm5hLlwiLFxuXHRcdHJlZ2lvbkdyb3VwTmFtZTogXCJSZWdpb25ncnVwcFwiLFxuXHRcdHJlZ2lvbkdyb3VwU25pcDogXCJGw7ZyIHZhcmplIGNlbGwgaSB1dGRhdGEgcmVnaXN0cmVyYXMgaWRlbnRpdGV0ZW4gZsO2ciBkZW4gYW5zbHV0bmEgcmVnaW9uIHNvbSBjZWxsZW4gdGlsbGjDtnIuIEV0dCB1bmlrdCBudW1tZXIgdGlsbGRlbGFzIHZhcmplIHJlZ2lvbi5cIixcblx0XHRyZWdpb25Hcm91cERlc2M6IFwiRGVuIGdsb2JhbGEgZnVua3Rpb25lbiBSZWdpb25ncnVwcCByZWdpc3RyZXJhciBmw7ZyIHZhcmplIGNlbGwgaSB1dGRhdGEgaWRlbnRpdGV0ZW4gZsO2ciBkZW4gYW5zbHV0bmEgcmVnaW9uIHNvbSBkZW4gY2VsbGVuIHRpbGxow7ZyLiBFdHQgdW5pa3QgbnVtbWVyIHRpbGxkZWxhcyB2YXJqZSByZWdpb24uPGRpdj48YnIvPkRlbiBmw7Zyc3RhIHJlZ2lvbmVuIHNvbSBza2FubmFzIGVyaMOlbGxlciB2w6RyZGV0IGV0dCwgZGVuIGFuZHJhIHR2w6Ugb2NoIHPDpSB2aWRhcmUgdGlsbHMgYWxsYSByZWdpb25lciBoYXIgdGlsbGRlbGF0cyBldHQgdsOkcmRlLiBTa2FubmluZ2VuIHNrZXIgZnLDpW4gdsOkbnN0ZXIgdGlsbCBow7ZnZXIsIHVwcGlmcsOlbiBvY2ggbmVkw6V0LiBEZSB2w6RyZGVuIHNvbSB0aWxsZGVsYXMgdGlsbCB1dGRhdGF6b25lcm5hIGJhc2VyYXMgcMOlIG7DpHIgZGUgcMOldHLDpGZmYXMgaSBza2FubmluZ3Nwcm9jZXNzZW4uPC9kaXY+XCIsXG5cdFx0cmVnaW9uR3Jvd05hbWU6IFwiRsOlIHJlZ2lvbmVyIGF0dCB2w6R4YVwiLFxuXHRcdHJlZ2lvbkdyb3dTbmlwOiBcIlV0dmVja2xhIHJlZ2lvbmVyIGZyw6VuIHNlZWRwdW5rdGVyLlwiLFxuXHRcdHJlZ2lvbkdyb3dEZXNjOiBcIkZ1bmt0aW9uZW4gRsOlIHJlZ2lvbmVyIGF0dCB2w6R4YSBiaWxkYXIgZ3J1cHBlciBhdiBuw6RybGlnZ2FuZGUgcGl4bGFyIGVmdGVyIGFuZ2l2ZW4gcmFkaWUgZnLDpW4gc2VlZHB1bmt0ZW4uIEdydXBwZW4gYXYgcGl4bGFyIGVsbGVyIG9iamVrdCB0aWxsZGVsYXMgZXR0IGFuZ2l2ZXQgZnlsbG5pbmdzdsOkcmRlLlwiLFxuXHRcdHJlbWFwTmFtZTogXCJPbW1hcHBuaW5nXCIsXG5cdFx0cmVtYXBTbmlwOiBcIsOEbmRyYXIgcGl4ZWx2w6RyZGVuIGdlbm9tIGF0dCB0aWxsZGVsYSBueWEgdsOkcmRlbiB0aWxsIGludGVydmFsbCBhdiBwaXhlbHbDpHJkZW4gZWxsZXIgYW52w6RuZGEgZW4gZXh0ZXJuIHRhYmVsbC5cIixcblx0XHRyZW1hcERlc2M6IFwiTWVkIGZ1bmt0aW9uZW4gT21tYXBwbmluZyBrYW4gZHUgw6RuZHJhIGVsbGVyIGtsYXNzaWZpY2VyYSBvbSBwaXhlbHbDpHJkZW5hIGbDtnIgcmFzdGVyZGF0YS4gRGV0dGEga2FuIGfDtnJhcyBhbnRpbmdlbiBnZW5vbSBhdHQgYW5nZSBldHQgaW50ZXJ2YWxsIG1lZCBwaXhlbHbDpHJkZW4gc29tIHNrYSBtYXBwYXMgdGlsbCBldHQgdXRkYXRhcGl4ZWx2w6RyZGUgZWxsZXIgZ2Vub20gYXR0IGFudsOkbmRhIGVuIHRhYmVsbCB0aWxsIGF0dCBtYXBwYSBwaXhlbHbDpHJkZW5hIHRpbGwgZXR0IHV0ZGF0YXBpeGVsdsOkcmRlLlwiLFxuXHRcdHJlcHJvamVjdE5hbWU6IFwiUHJvamljZXJhIG9tXCIsXG5cdFx0cmVwcm9qZWN0U25pcDogXCLDhG5kcmFyIHByb2pla3Rpb25lbiBmw7ZyIGV0dCByYXN0ZXJkYXRhc2V0LCBtb3NhaWtkYXRhc2V0IGVsbGVyIHJhc3Rlcm9iamVrdCBpIGV0dCBtb3NhaWtkYXRhc2V0LiBEZW4ga2FuIG9ja3PDpSBvbXNhbXBsYSBkYXRhIHRpbGwgZW4gbnkgY2VsbHN0b3JsZWsgb2NoIGRlZmluaWVyYSBldHQgdXJzcHJ1bmcuXCIsXG5cdFx0cmVwcm9qZWN0RGVzYzogXCJGdW5rdGlvbmVuIFByb2ppY2VyYSBvbSDDpG5kcmFyIHByb2pla3Rpb25lbiBmw7ZyIGV0dCByYXN0ZXJkYXRhc2V0LCBtb3NhaWtkYXRhc2V0IGVsbGVyIHJhc3Rlcm9iamVrdCBpIGV0dCBtb3NhaWtkYXRhc2V0LiBEZW4ga2FuIG9ja3PDpSBvbXNhbXBsYSBkYXRhIHRpbGwgZW4gbnkgY2VsbHN0b3JsZWsgb2NoIGRlZmluaWVyYSBldHQgdXJzcHJ1bmcuPGRpdj48YnIvPkZ1bmt0aW9uZW4gUHJvamljZXJhIG9tIGthbiBhbnbDpG5kYXMgbsOkciBlbiBjYWNoZSBza2FwYXMgZnLDpW4gZXR0IHJhc3RlciBlbGxlciBldHQgbW9zYWlrZGF0YXNldCBzb20gaW50ZSBmaW5ucyBpIGRlbiBuw7ZkdsOkbmRpZ2EgcHJvamVrdGlvbmVuLiBOw6RyIHQuZXguIGVuIGNhY2hhZCBiaWxkdGrDpG5zdCBza2FwYXMgc29tIGthbiBpbnRlZ3JlcmFzIG1lZCBhbmRyYSBjYWNoYWRlIHRqw6Ruc3RlciB2aWEgYXBwbGlrYXRpb25lciDDpHIgZGV0IHZpa3RpZ3QgYXR0IGRlIGFsbGEgw6RyIGkgc2FtbWEgcHJvamVrdGlvbi4gRGV0dGEgw6RyIG9mdGEgZW4gV2ViIE1lcmNhdG9yLXByb2pla3Rpb24uIEVmdGVyc29tIG1vc2Fpa2RhdGFzZXQgaW50ZSBrYW4gcHJvamljZXJhcyBvbSBrYW4gZHUgZ8O2cmEgZW4gYXYgdHbDpSBzYWtlcuKAlGFudGluZ2VuIHNrYXBhIGV0dCByZWZlcmVyYXQgbW9zYWlrZGF0YXNldCBmcsOlbiBkaXR0IG1vc2Fpa2RhdGFzZXQgaSBkZW4gcHJvamVrdGlvbiBzb20gYmVow7Z2cyBlbGxlciBsw6RnZ2EgdGlsbCBmdW5rdGlvbmVuIFByb2ppY2VyYSBvbSBpIG1vc2Fpa2RhdGFzZXRldHMgZnVua3Rpb25za2VkamEuIEV0dCBhbm5hdCBleGVtcGVsIGFudsOkbmRlciBkZW4gaMOkciBmdW5rdGlvbmVuIHDDpSByYXN0ZXJvYmpla3RldCBpIGV0dCBtb3NhaWtkYXRhc2V0LiBOw6RyIGR1IGFudsOkbmRlciBmdW5rdGlvbmVuIENhY2hlbGFncmF0IHJhc3RlciBrYW4gZHUgaW5mb2dhIGZ1bmt0aW9uZW4gUHJvamljZXJhIG9tIHPDpSBhdHQgY2FjaGVuIHNrYXBhcyBpIGRlbiBueWEgcHJvamVrdGlvbmVuLiBSYXN0ZXJvYmpla3QgaSBldHQgbW9zYWlrZGF0YXNldCBrYW4gY2FjaGVsYWdyYXMgbsOkciBiZWFyYmV0bmluZ2VuIMOkciBpbnRlbnNpdiBvY2ggZHUgZsO2cnPDtmtlciBwdWJsaWNlcmEgZW4gYmlsZHRqw6Ruc3Qgc29tIMOkciBzbmFiYiB1dGFuIGF0dCBjYWNoZWxhZ3JhIGhlbGEgYmlsZHRqw6Ruc3Rlbi48L2Rpdj5cIixcblx0XHRyZXNhbXBsZU5hbWU6IFwiT21zYW1wbGFcIixcblx0XHRyZXNhbXBsZVNuaXA6IFwiw4RuZHJhciBjZWxsc3Rvcmxla2VuIGbDtnIgZXR0IHJhc3Rlci5cIixcblx0XHRyZXNhbXBsZURlc2M6IFwiRnVua3Rpb25lbiBPbXNhbXBsYSDDpG5kcmFyIGNlbGxzdG9ybGVrZW4sIG9tc2FtcGxpbmdzdHlwZW4gZWxsZXIgYsOlZGUgb2NoLjxkaXY+PGJyLz5GdW5rdGlvbmVuIE9tc2FtcGxhIHNrYSBlbmJhcnQgYW52w6RuZGFzIG1lZCBzcGVjaWZpa2EgYmVyw6RrbmluZ3NrcmF2LCB0LmV4LiBuw6RyIGR1IGJlcsOka25hciB2aW5kZW4gZWxsZXIgYWt0dWVsbCBtYWduaXR1ZC1yaWt0bmluZyBzb20ga3LDpHZlciBvbXNhbXBsaW5nIGZyw6VuIGvDpGxsdXBwbMO2c25pbmdlbi48L2Rpdj5cIixcblx0XHRyb3VuZERvd25OYW1lOiBcIkF2cnVuZGEgbmVkw6V0XCIsXG5cdFx0cm91bmREb3duU25pcDogXCJSZXR1cm5lcmFyIG7DpHN0YSBsw6RncmUgaGVsdGFsc3bDpHJkZSwgZW5kYXN0IHJlcHJlc2VudGVyYXQgc29tIGZseXR0YWwsIGbDtnIgdmFyamUgY2VsbCBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0cm91bmREb3duRGVzYzogXCJGdW5rdGlvbmVuIEF2cnVuZGEgbmVkw6V0IHJldHVybmVyYXIgbsOkc3RhIGzDpGdyZSBoZWx0YWxzdsOkcmRlIHNvbSBldHQgZmx5dHRhbHN2w6RyZGUgZsO2ciB2YXJqZSBwaXhlbCBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0cm91bmRVcE5hbWU6IFwiQXZydW5kYSB1cHDDpXRcIixcblx0XHRyb3VuZFVwU25pcDogXCJSZXR1cm5lcmFyIG7DpHN0YSBow7ZncmUgaGVsdGFsc3bDpHJkZSwgZW5kYXN0IHJlcHJlc2VudGVyYXQgc29tIGZseXR0YWwsIGbDtnIgdmFyamUgY2VsbCBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0cm91bmRVcERlc2M6IFwiRnVua3Rpb25lbiBBdnJ1bmRhIHVwcMOldCByZXR1cm5lcmFyIG7DpHN0YSBow7ZncmUgaGVsdGFsc3bDpHJkZSBzb20gZXR0IGZseXR0YWxzdsOkcmRlIGbDtnIgdmFyamUgcGl4ZWwgaSBldHQgcmFzdGVyLlwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnROYW1lOiBcIkZseXR0bmluZyBhdiBzZWdtZW50bWVkZWx2w6RyZGVcIixcblx0XHRzZWdtZW50TWVhblNoaWZ0U25pcDogXCJHcnVwcGVyYXIgYW5ncsOkbnNhbmRlIHBpeGxhciBtZWQgbGlrbmFuZGUgc3Bla3RyYWxhIGVnZW5za2FwZXIgdGlsbHNhbW1hbnMgdGlsbCBzZWdtZW50LlwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnREZXNjOiBcIkRlbiBow6RyIGZ1bmt0aW9uZW4gaWRlbnRpZmllcmFyIG9iamVrdCwgZ2Vvb2JqZWt0IGVsbGVyIHNlZ21lbnQgaSBkaW5hIGJpbGRlciBnZW5vbSBhdHQgYmlsZGEgZ3J1cHBlciBhdiBpbnRpbGxpZ2dhbmRlIHBpeGxhciBtZWQgbGlrbmFuZGUgc3Bla3RyYWxhIG9jaCBnZW9ncmFmaXNrYSBlZ2Vuc2thcGVyLiBEdSBrYW4ga29udHJvbGxlcmEgbcOkbmdkZW4gZ2VvZ3JhZmlzayBvY2ggc3Bla3RyYWwgdXRqw6RtbmluZyBmw7ZyIGF0dCBmw6UgZnJhbSBpbnRyZXNzYW50YSBnZW9vYmpla3QuXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uTmFtZTogXCJSYWRpb21ldHJpc2sga2FsaWJyZXJpbmcgZsO2ciBTZW50aW5lbC0xXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uU25pcDogXCJVdGbDtnIgb2xpa2EgdHlwZXIgYXYgcmFkaW9tZXRyaXNrIGthbGlicmVyaW5nIGF2IFNlbnRpbmVsLTEtZGF0YS5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25EZXNjOiBcIkRlbm5hIHJhc3RlcmZ1bmt0aW9uIHV0ZsO2ciB0cmUgb2xpa2Ega2FsaWJyZXJpbmdhciBmw7ZyIFNlbnRpbmVsLTEtZGF0YXNldCwgaW5rbHVzaXZlIGJldGEtbm9sbCBvY2ggZ2FtbWEsIG9jaCBnZXIgZGV0IGthbGlicmVyYWRlIGRhdGFzZXRldCBzb20gdXRkYXRhLiBNw6VsZXQgbWVkIFNBUi1rYWxpYnJlcmluZyDDpHIgYXR0IHRpbGxoYW5kYWjDpWxsYSBiaWxkZXIgaSB2aWxrYSBwaXhlbHbDpHJkZW5hIGRpcmVrdCBrYW4gcmVsYXRlcmFzIHRpbGwgc2NlbmVucyByYWRhcmJha8OldHN0csOlbG5pbmcuIE9rYWxpYnJlcmFkZSBTQVItYmlsZGVyIHLDpGNrZXIgdGlsbCBmw7ZyIGt2YWxpdGF0aXYgYW52w6RuZG5pbmcsIG1lbiBmw7ZyIGt2YW50aXRhdGl2IGFudsOkbmRuaW5nIGF2IFNBUi1kYXRhIMOkciBrYWxpYnJlcmFkZSBTQVItYmlsZGVyIG7DtmR2w6RuZGlnYS48ZGl2Pjxici8+VHlwaXNrIFNBUi1kYXRhYmVhcmJldG5pbmcsIHNvbSBwcm9kdWNlcmFyIG5pdsOlIDEtYmlsZGVyLCBzYWtuYXIgcmFkaW9tZXRyaXNrYSBrb3JyaWdlcmluZ2FyIG9jaCBiZXR5ZGFuZGUgcmFkaW9tZXRyaXNrIHNuZWR2cmlkbmluZyBmaW5ucyBrdmFyLiBEZXQgw6RyIGTDpHJmw7ZyIG7DtmR2w6RuZGlndCBhdHQgdGlsbMOkbXBhIHJhZGlvbWV0cmlzayBrb3JyaWdlcmluZyBww6UgU0FSLWJpbGRlciBzw6UgYXR0IGJpbGRlcm5hcyBwaXhlbHbDpHJkZW4gdmVya2xpZ2VuIHJlcHJlc2VudGVyYXIgZGVuIHJlZmxla3RlcmFuZGUgeXRhbnMgcmFkYXJiYWvDpXRzdHLDpWxuaW5nLiBSYWRpb21ldHJpc2sga29ycmlnZXJpbmcgw6RyIG9ja3PDpSBuw7ZkdsOkbmRpZyBmw7ZyIGF0dCBrdW5uYSBqw6RtZsO2cmEgU0FSLWJpbGRlciBzb20gaW5ow6RtdGF0cyBtZWQgb2xpa2Egc2Vuc29yZXIsIGVsbGVyIHNvbSBpbmjDpG10YXRzIGF2IHNhbW1hIHNlbnNvciB2aWQgb2xpa2EgdGlkcHVua3RlciBlbGxlciBpIG9saWthIGzDpGdlbiBlbGxlciBzb20gYmVhcmJldGF0cyBhdiBvbGlrYSBwcm9jZXNzb3Jlci48L2Rpdj5cIixcblx0XHRzMVRoZXJtYWxOb2lzZVJlbW92YWxOYW1lOiBcIkJvcnR0YWduaW5nIGF2IHRlcm1pc2t0IGJydXMgZnLDpW4gU2VudGluZWwtMVwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbFNuaXA6IFwiVGFyIGJvcnQgdGVybWlza3QgYnJ1cyBmcsOlbiBTZW50aW5lbC0xLWRhdGEuXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsRGVzYzogXCJUZXJtaXNrIGJydXNrb3JyaWdlcmluZyBrYW4gdGlsbMOkbXBhcyBww6UgU2VudGluZWwtMSBOaXbDpS0xIFNMQy1wcm9kdWt0ZXIgKFNpbmdsZSBMb29rIENvbXBsZXgpIGxpa3NvbSBOaXbDpS0xIEdSRC1wcm9kdWt0ZXIgKEdyb3VuZCBSYW5nZSBEZXRlY3Rpb24pIHNvbSBpbnRlIHJlZGFuIGhhciBrb3JyaWdlcmF0cy4gT3BlcmF0w7ZyZW4ga2FuIG9ja3PDpSB0YSBib3J0IGRlbiBow6RyIGtvcnJpZ2VyaW5nZW4gYmFzZXJhdCBww6UgcHJvZHVrdHRleHRlcm5hIGbDtnIgYXR0IMOldGVyaW50cm9kdWNlcmEgZGVuIGJydXNzaWduYWwgc29tIHRvZ3MgYm9ydCBmw7ZyIGF0dCB0YSBmcmFtIGRlbiB1cnNwcnVuZ2xpZ2EgcHJvZHVrdGVuLiBQcm9kdWt0dGV4dGVyIHVwcGRhdGVyYXMgZMOkcm1lZCBmw7ZyIGF0dCBtw7ZqbGlnZ8O2cmEgw6V0ZXJ0aWxsw6RtcG5pbmcgYXYga29ycmlnZXJpbmdlbi4gXCIsXG5cdFx0c2V0TnVsbE5hbWU6IFwiU8OkdHQgbm9sbFwiLFxuXHRcdHNldE51bGxTbmlwOiBcIlPDpHR0IG5vbGwgYW5nZXIgaWRlbnRpZmllcmFkZSBjZWxscGxhdHNlciB0aWxsIE5vRGF0YSBiYXNlcmF0IHDDpSBhbmdpdm5hIGtyaXRlcmllci4gRGVuIHJldHVybmVyYXIgTm9EYXRhIG9tIGVuIHZpbGxrb3JsaWcgdXR2w6RyZGVyaW5nIMOkciBzYW5uIG9jaCByZXR1cm5lcmFyIGRldCB2w6RyZGUgc29tIGFuZ2V0dHMgaSBldHQgYW5uYXQgcmFzdGVyIG9tIGRlbiDDpHIgZmFsc2suXCIsXG5cdFx0c2V0TnVsbERlc2M6IFwiRnVua3Rpb25lbiBTw6R0dCBub2xsIGFuZ2VyIGRlIGlkZW50aWZpZXJhZGUgcGl4bGFybmEgdGlsbCBOb0RhdGEsIGJhc2VyYXQgcMOlIGRlIHNwZWNpZmlrYSBrcml0ZXJpZXJuYS4gRGVuIHJldHVybmVyYXIgTm9EYXRhIG9tIGVuIHZpbGxrb3JsaWcgdXR2w6RyZGVyaW5nIMOkciBzYW5uICgxKSBvY2ggcmV0dXJuZXJhciBkZXQgdsOkcmRlIHNvbSBhbmdldHRzIGkgRmFsc2t0IHJhc3RlciBvbSBlbiB2aWxsa29ybGlnIHV0dsOkcmRlcmluZyDDpHIgZmFsc2sgKDApLiBEZXR0YSBrcml0ZXJpdW0gc3BlY2lmaWNlcmFzIGF2IHV0ZGF0YSBmcsOlbiBlbiBsb2dpc2sgbWF0ZW1hdGlrZnVua3Rpb24gc29tIGJsaXIgaW5kYXRhcmFzdHJldC5cIixcblx0XHRzaGFkZWRSZWxpZWZOYW1lOiBcIlNrdWdnYWQgcmVsaWVmXCIsXG5cdFx0c2hhZGVkUmVsaWVmU25pcDogXCJTa2FwYXIgZW4gZmxlcmJhbmRzLCBmw6RyZ2tvZGFkIDNELXJlcHJlc2VudGF0aW9uIGF2IHl0YW4gbWVkIGjDpG5zeW4gdGFnZW4gdGlsbCBzb2xlbnMgcmVsYXRpdmEgcG9zaXRpb24gZsO2ciBhdHQgc2t1Z2dhIGJpbGRlbi5cIixcblx0XHRzaGFkZWRSZWxpZWZEZXNjOiBcIkZ1bmt0aW9uZW4gU2t1Z2dhZCByZWxpZWYgc2thcGFyIGVuIDNELXJlcHJlc2VudGF0aW9uIGkgZsOkcmcgYXYgdGVycsOkbmdlbi4gRGVuIHNrYXBhcyBnZW5vbSBhdHQgc2FtbWFuZm9nYSBiaWxkZXJuYSBmcsOlbiBtZXRvZGVybmEgaMO2amRrb2RuaW5nIG9jaCB0ZXJyw6RuZ3NrdWdnbmluZy4gRnVua3Rpb25lbiBhbmdlciBzb2xlbnMgcG9zaXRpb24gbWVkIGjDtmpkLSBvY2ggYXppbXV0ZWdlbnNrYXBlci48ZGl2Pjxici8+PC9kaXY+XCIsXG5cdFx0c2luSE5hbWU6IFwiU2luSFwiLFxuXHRcdHNpbkhTbmlwOiBcIkJlcsOka25hciBoeXBlcmJvbGlzayBzaW51cyBmw7ZyIGNlbGxlciBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0c2luSERlc2M6IFwiRnVua3Rpb25lbiBiZXLDpGtuYXIgaHlwZXJib2xpc2sgc2ludXMgZsO2ciBwaXhsYXJuYSBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0c2luTmFtZTogXCJTaW5cIixcblx0XHRzaW5TbmlwOiBcIkJlcsOka25hciBzaW51cyBmw7ZyIGNlbGxlciBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0c2luRGVzYzogXCJGdW5rdGlvbmVuIGJlcsOka25hciBzaW51cyBmw7ZyIHBpeGxhcm5hIGkgZXR0IHJhc3Rlci5cIixcblx0XHRzbG9wZU5hbWU6IFwiTHV0bmluZ1wiLFxuXHRcdHNsb3BlU25pcDogXCJCZXLDpGtuYXIgw6RuZHJpbmdzZnJla3ZlbnNlbiBmcsOlbiBldHQgcGl4ZWx2w6RyZGUgdGlsbCBkZXNzIGdyYW5uYXIuXCIsXG5cdFx0c2xvcGVEZXNjOiBcIkRlbm5hIHJhc3RlcmZ1bmt0aW9uIGJlcsOka25hciBsdXRuaW5nLCBzb20gw6RyIHRha3RlbiBww6UgaMO2amRmw7Zyw6RuZHJpbmdlbiBmw7ZyIHZhcmplIGNlbGwgaSBkZW4gZGlnaXRhbGEgaMO2amRtb2RlbGxlbiAoREVNKS4gRGV0IMOkciBkZW4gZsO2cnN0YSBow6RybGVkbmluZ2VuIGZyw6VuIGVuIERFTS48ZGl2Pjxici8+RGVubmEgZnVua3Rpb24gYW52w6RuZGVyIGVuIGFjY2VsZXJlcmFkIGF0YW4oKS1mdW5rdGlvbi4gRGVuIMOkciBzZXggZ8OlbmdlciBzbmFiYmFyZSBvY2ggYXBwcm94aW1hdGlvbnNmZWxldCDDpHIgYWxsdGlkIG1pbmRyZSDDpG4gMCwzIGdyYWRlci48L2Rpdj5cIixcblx0XHRzcGVja2xlTmFtZTogXCJGbMOkY2tcIixcblx0XHRzcGVja2xlU25pcDogXCJUaWxsaGFuZGFow6VsbGVyIGZpbHRlciBmw7ZyIGF0dCByZWR1Y2VyYSBicnVzIGZyw6VuIGRhdGFzZXQgdGFnbmEgbWVkIHN5bnRldGlzayBhcGVydHVycmFkYXIuXCIsXG5cdFx0c3BlY2tsZURlc2M6IFwiRmzDpGNrIMOkciBow7ZnZnJla3ZlbnNicnVzIHDDpSByYWRhcmRhdGEuIEJpbGRlciBzb20gw6RyIGdlbmVyZXJhZGUgbWVkIHN5bnRldGlza2EgYXBlcnR1cnJhZGFyc3lzdGVtIChTQVIpIMOkciBteWNrZXQgdXRzYXR0YSBmw7ZyIGZsw6Rja2VmZmVrdGVyIHDDpSBncnVuZCBhdiBiZWFyYmV0bmluZyBhdiBzcHJpZGRhIHNpZ25hbGVyIG9jaCBpbnRlcmZlcmVucyBmcsOlbiBlbGVrdHJvbWFnbmV0aXNrYSB2w6Vnb3Igc29tIHNwcmlkaXRzIGZyw6VuIHl0b3IgZWxsZXIgZsO2cmVtw6VsLiBEZW5uYSBGbMOkY2tmdW5rdGlvbiBmaWx0cmVyYXIgZmzDpGNrYWRlIHJhZGFyZGF0YXNldCBvY2ggasOkbW5hciB1dCBicnVzIHNhbXRpZGlndCBzb20ga2FudGVyIGVsbGVyIHNrYXJwYSBnZW9vYmpla3QgYmliZWjDpWxscyBpIGJpbGRlbi5cIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25OYW1lOiBcIlNwZWt0cmFsIGtvbnZlcnRlcmluZ1wiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvblNuaXA6IFwiVGlsbMOkbXBhciBlbiBtYXRyaXMgcMOlIGVuIGZsZXJiYW5kc2JpbGQuXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uRGVzYzogXCJGdW5rdGlvbmVuIHNwZWt0cmFsIGtvbnZlcnRlcmluZyB0aWxsw6RtcGFyIGVuIG1hdHJpcyBww6UgZW4gZmxlcmJhbmRzYmlsZCwgdmlsa2V0IHDDpXZlcmthciBmw6RyZ3bDpHJkZW4gaSB1dGRhdGEuPGRpdj48YnIvPlZpc3NhIHNlbnNvcmVyIHNhbWxhciBpbnRlIGluIGJsw6UgYmFuZCBww6UgZ3J1bmQgYXYgZXR0IGzDpWd0IHNpZ25hbC10aWxsLWJydXMtZsO2cmjDpWxsYW5kZS4gRGV0dGEga2FuIHQuZXguIGFudsOkbmRhcyB0aWxsIGF0dCBrb252ZXJ0ZXJhIGVuIGluZnJhcsO2ZCBiaWxkIGkgZmFsc2thIGbDpHJnZXIgdGlsbCBlbiBiaWxkIG1lZCBwc2V1ZG9uYXR1cmxpZ2EgZsOkcmdlci48L2Rpdj5cIixcblx0XHRzcXVhcmVSb290TmFtZTogXCJLdmFkcmF0cm90XCIsXG5cdFx0c3F1YXJlUm9vdFNuaXA6IFwiQmVyw6RrbmFyIGt2YWRyYXRyb3RlbiBhdiBjZWxsdsOkcmRlbmEgaSBldHQgcmFzdGVyLlwiLFxuXHRcdHNxdWFyZVJvb3REZXNjOiBcIkZ1bmt0aW9uZW4gS3ZhZHJhdHJvdCBiZXLDpGtuYXIga3ZhZHJhdHJvdGVuIGF2IHBpeGVsdsOkcmRlbmEgaSBldHQgcmFzdGVyLlwiLFxuXHRcdHNxdWFyZU5hbWU6IFwiS3ZhZHJhdFwiLFxuXHRcdHNxdWFyZVNuaXA6IFwiQmVyw6RrbmFyIGt2YWRyYXRlbiBhdiBjZWxsdsOkcmRlbmEgaSBldHQgcmFzdGVyLlwiLFxuXHRcdHNxdWFyZURlc2M6IFwiS3ZhZHJhdCBiZXLDpGtuYXIga3ZhZHJhdGVuIHDDpSBwaXhlbHbDpHJkZW5hIGkgZXR0IHJhc3Rlci5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtTmFtZTogXCJTdGF0aXN0aWsgb2NoIGhpc3RvZ3JhbVwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1TbmlwOiBcIkRlZmluaWVyYSBlbGxlciBrb3BwbGEgc3RhdGlzdGlrIG9jaCBoaXN0b2dyYW0uXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbURlc2M6IFwiRnVua3Rpb25lbiBTdGF0aXN0aWsgb2NoIGhpc3RvZ3JhbSBhbnbDpG5kcyBmw7ZyIGF0dCBkZWZpbmllcmEgc3RhdGlzdGlrIG9jaCBoaXN0b2dyYW0gZsO2ciBldHQgcmFzdGVyLiBEdSBrYW4gaW5mb2dhIGRlbm5hIGZ1bmt0aW9uIGkgc2x1dGV0IGF2IGZ1bmt0aW9uc2tlZGphbiBmw7ZyIGF0dCBiZXNrcml2YSBzdGF0aXN0aWsgb2NoIGhpc3RvZ3JhbSBmw7ZyIGVuIG1hbGwgZsO2ciByYXN0ZXJmdW5rdGlvbiAoUkZUKS4gRGV0dGEga2FuIHZhcmEgbsO2ZHbDpG5kaWd0IGbDtnIgYXR0IHN0eXJhIHN0YW5kYXJkdmlzbmluZ2VuIGF2IGJlYXJiZXRuaW5nc3Jlc3VsdGF0ZXQsIHPDpHJza2lsdCBuw6RyIGVuIGZ1bmt0aW9uc2tlZGphIGRlZmluaWVyYXMgc29tIGlubmVow6VsbGVyIG3DpW5nYSBmdW5rdGlvbmVyLjxkaXY+PGJyLz5EdSBrYW4gZGVmaW5pZXJhIHN0YXRpc3RpayBnZW5vbSBhdHQgc2tyaXZhIHbDpHJkZW5hIGVsbGVyIGltcG9ydGVyYSBkZW0gZnLDpW4gZXR0IHJhc3RlcmRhdGFzZXQgZWxsZXIgZW4gWE1MLWZpbC4gSGlzdG9ncmFtIGthbiBlbmRhc3QgZGVmaW5pZXJhcyBnZW5vbSBhdHQgaW1wb3J0ZXJhIGVuIGZpbC48L2Rpdj5cIixcblx0XHRzdGF0aXN0aWNzTmFtZTogXCJTdGF0aXN0aWtcIixcblx0XHRzdGF0aXN0aWNzU25pcDogXCJCZXLDpGtuYXIgZm9rYWwgc3RhdGlzdGlrIGbDtnIgdmFyamUgcGl4ZWwgaSBlbiBiaWxkIHV0aWZyw6VuIGRlZmluaWVyYXQgZm9rYWx0IGdyYW5uc2thcC5cIixcblx0XHRzdGF0aXN0aWNzRGVzYzogXCJGdW5rdGlvbmVuIFN0YXRpc3RpayBiZXLDpGtuYXIgZm9rYWwgc3RhdGlzdGlrIGbDtnIgdmFyamUgcGl4ZWwgaSBlbiBiaWxkIHV0aWZyw6VuIGV0dCBkZWZpbmllcmF0IGZva2FsdCBncmFubnNrYXAuPGRpdj48YnIvPlN0YXRpc3Rpa2Z1bmt0aW9uZW4ga2FuIGFudsOkbmRhcyB0aWxsIGF0dCBmeWxsYSBpIHNha25hZGUgbGluamVyIGkgZW4gYmlsZC4gU2FrbmFkZSBsaW5qZXIgb3JzYWthcyBvZnRhIGF2IHByb2JsZW0gaSBzZW5zb3JuIGTDpSBkYXRhIGludGUgc2FtbGFzIGluLiBEZXR0YSBoYXIgaW50csOkZmZhdCBtZWQgc2Vuc29yZXIgc29tIExhbmRzYXQgNzpzIEVuaGFuY2VkIFRoZW1hdGljIE1hcHBlciBQbHVzIChFVE0rKS4gRGVzc2Egc2FrbmFkZSBkYXRhIHNrYXBhciBwcm9ibGVtIGbDtnIgYW5hbHlzZW4gb2NoIMOkdmVuIG7DpHIgbWFuIHRpdHRhciBww6UgYmlsZGVybmEuIERldCBmaW5ucyBpbnRlIG15Y2tldCBzb20ga2FuIGfDtnJhcyBuw6RyIGJpbGRlcm5hIGFudsOkbmRzIGbDtnIgYW5hbHlzLCBtZW4gb20gZGV0IGZpbm5zIGVuIMO2dmVybGFwcGFuZGUgYmlsZCBrYW4gZGVuIGFudsOkbmRhcyBpc3TDpGxsZXQgZsO2ciBkZXQgaW5uZWjDpWxsIHNvbSBzYWtuYXMuIERldHRhIGthbiBvY2tzw6UgZ8O2cmFzIG9tIGJpbGRlcm5hIGFudsOkbmRzIGbDtnIgdmlzdWFsaXNlcmluZy4gRGV0IGZpbm5zIGVtZWxsZXJ0aWQgaW50ZSBhbGx0aWQgZW4gZXh0cmEgYmlsZCBmw7ZyIGF0dCBmeWxsYSBpIHNha25hdCBpbm5laMOlbGwsIHPDpSBkZXQgbcOlc3RlIGjDpHJsZWRhcyBmcsOlbiBiZWZpbnRsaWdhIGRhdGEuPC9kaXY+XCIsXG5cdFx0c3RyZWFtTGlua05hbWU6IFwiU3Ryw7ZtbmluZ3Nsw6Rua1wiLFxuXHRcdHN0cmVhbUxpbmtTbmlwOiBcIlRpbGxkZWxhciB1bmlrYSB2w6RyZGVuIHRpbGwgc2VrdGlvbmVyIGF2IGV0dCBsaW5qw6RydCByYXN0ZXJuw6R0IG1lbGxhbiBrb3JzbmluZ2FyLlwiLFxuXHRcdHN0cmVhbUxpbmtEZXNjOiBcIkRlbiBnbG9iYWxhIGZ1bmt0aW9uZW4gU3Ryw7ZtbmluZ3Nsw6RuayB0aWxsZGVsYXIgdW5pa2EgdsOkcmRlbiB0aWxsIHNla3Rpb25lciBhdiBldHQgbGluasOkcnQgcmFzdGVybsOkdCBtZWxsYW4ga29yc25pbmdhci48ZGl2Pjxici8+TMOkbmthciDDpHIgZGUgc2VrdGlvbmVyIGF2IGV0dCB2YXR0ZW5kcmFnIHNvbSBnw6VyIG1lbGxhbiB0dsOlIGZsb2Rtw7Z0ZW4gaSByYWQsIGV0dCBmbG9kbcO2dGUgb2NoIHV0bG9wcGV0IGVsbGVyIGV0dCBmbG9kbcO2dGUgb2NoIHZhdHRlbmRlbGFyZW4uIElub20gaHlkcm9sb2dpbiBrYWxsYXMgZGVzc2Egc2VnbWVudCBhdiB2YXR0ZW5kcmFnIGbDtnIgc3Ryw6Rja2EuIEV0dCBmbG9kbcO2dGUgw6RyIHJlbGF0ZXJhdCB0aWxsIGjDpGxscHVua3Qgb2NoIGhqw6RscGVyIHRpbGwgYXR0IGF2Z3LDpG5zYSBldHQgYXZyaW5uaW5nc29tcsOlZGUgZWxsZXIgZ3LDpG5zZW4gZsO2ciBldHQgZGVsYXZyaW5uZ3NvbXLDpWRlLjwvZGl2PlwiLFxuXHRcdHN0cmV0Y2hOYW1lOiBcIlN0csOkY2tcIixcblx0XHRzdHJldGNoU25pcDogXCJGw7Zyc3TDpHJrZXIgZW4gYmlsZCBnZW5vbSBhdHQganVzdGVyYSBpbnRlcnZhbGxldCBmw7ZyIHZpc2FkZSB2w6RyZGVuLiBEZXQgw6RuZHJhciBpbnRlIGRlIHVuZGVybGlnZ2FuZGUgcGl4ZWx2w6RyZGVuYS4gT20gZW4gcGl4ZWwgaGFyIGV0dCB2w6RyZGUgdXRhbmbDtnIgZGV0IGFuZ2l2bmEgaW50ZXJ2YWxsZXQgdmlzYXMgZGVuIHNvbSBhbnRpbmdlbiBkZXQgbWluaW1hbGEgZWxsZXIgbWF4aW1hbGEgdsOkcmRldC5cIixcblx0XHRzdHJldGNoRGVzYzogXCJGdW5rdGlvbmVuIFN0csOkY2sgZsO2cmLDpHR0cmFyIGVuIGJpbGQgZ2Vub20gYXR0IMOkbmRyYSBkZXNzIGVnZW5za2FwZXIgc29tIGV4ZW1wZWx2aXMgbGp1c3N0eXJrYSwga29udHJhc3Qgb2NoIGdhbW1hIGdlbm9tIGF0dCBhbnbDpG5kYSBmbGVyYSBzdHLDpGNrbmluZ3N0eXBlci4gRGVubmEgZnVua3Rpb24gYW52w6RuZGVyIHN0YXRpc3Rpa2VuIGZyw6VuIHJhc3RyZW4gaSBtb3NhaWtkYXRhc2V0ZXQuIE9tIGR1IGFudsOkbmRlciBkZW5uYSBmdW5rdGlvbiBtw6VzdGUgZHUgZMOkcmbDtnIgc2UgdGlsbCBhdHQgc3RhdGlzdGlrZW4gaGFyIGJlcsOka25hdHMuPGRpdj48YnIvPlN0csOkY2t0eXBlbiBkZWZpbmllcmFyIGVuIGhpc3RvZ3JhbXN0csOkY2tuaW5nIHNvbSBrb21tZXIgYXR0IHRpbGzDpG1wYXMgcMOlIHJhc3RyZW4gZsO2ciBhdHQgZsO2cmLDpHR0cmEgZGVyYXMgdXRzZWVuZGUuIFN0csOkY2tuaW5nIGbDtnJiw6R0dHJhciB1dHNlZW5kZXQgZsO2ciBkYXRhIGdlbm9tIGF0dCBzcHJpZGEgcGl4ZWx2w6RyZGVuYSBsw6RuZ3MgZXR0IGhpc3RvZ3JhbSBmcsOlbiBtaW4tIG9jaCBtYXh2w6RyZGVuYSBkZWZpbmllcmF0IGF2IGRlcmFzIGJpdGRqdXAuIDwvZGl2PlwiLFxuXHRcdHN3YXRoTmFtZTogXCJTdHLDpWtcIixcblx0XHRzd2F0aFNuaXA6IFwiSW50ZXJwb2xlcmFyIGZyw6VuIG9yZWdlbGJ1bmRuYSBydXRuw6R0IGVsbGVyIHN0csOla2RhdGEuXCIsXG5cdFx0c3dhdGhEZXNjOiBcIlZpc3NhIG5ldENERi0gZWxsZXIgSERGLWRhdGFzZXQgbGFncmFyIHNpbiBnZW9sb2thbGlzZXJpbmcgc29tIHZla3RvcmVyIG1lZCBvcmVnZWxidW5kbmEgYXZzdMOlbmQuIE7DpHIgZGVzc2EgZGF0YXNldCBsw6RnZ3MgdGlsbCBpIGV0dCBtb3NhaWtkYXRhc2V0IHRhciBzdHLDpWtmdW5rdGlvbmVuIG9yZWdlbGJ1bmRuYSBydXRuw6R0ZGF0YSBvY2ggb21zYW1wbGFyIGRlbSBzw6UgYXR0IHZhcmplIHBpeGVsIGbDpXIgZW4gZW5oZXRsaWcgc3RvcmxlayBvY2ggYmxpciBmeXJrYW50aWcuPGRpdj48YnIvPk7DpHIgdmFyaWFibGVyIGZyw6VuIG5ldENERiBlbGxlciBIREYgbMOkZ2dzIHRpbGwgaSBldHQgbW9zYWlrZGF0YXNldCwgdmVyaWZpZXJhciBkZXQgYXV0b21hdGlza3Qgb20gZGF0YSDDpHIgasOkbW50IHV0c3ByaWRkYS4gT20gaW50ZSB0aWxsw6RtcGFzIHN0csOla2Z1bmt0aW9uZW4gYXV0b21hdGlza3Qgc8OlIGF0dCBkZXQgb3JlZ2VsYnVuZG5hIHJhc3RyZXQga29udmVydGVyYXMgdGlsbCBwdW5rdGVyIG9jaCBzZWRhbiB0aWxsIGV0dCByZWdlbGJ1bmRldCBydXRuw6R0c3Jhc3Rlci4gRHUga2FuIMOkbmRyYSBkZW4gaW50ZXJwb2xlcmluZ3NtZXRvZCBvY2ggZGVuIGNlbGxzdG9ybGVrIHNvbSBhbnbDpG5kcyBpIHN0csOla3Jhc3RlcmZ1bmt0aW9uZW4uIEbDtnIgcmFzdGVyZGF0YSBtZWQgcmVnZWxidW5kbmEgYXZzdMOlbmQgdGlsbMOkbXBhcyBpbmdlbiBpbnRlcnBvbGVyaW5nLCBkYXRhIGzDpHNlcyBpIGJlZmludGxpZ3Qgc2tpY2suPC9kaXY+XCIsXG5cdFx0dGFuSE5hbWU6IFwiVGFuSFwiLFxuXHRcdHRhbkhTbmlwOiBcIkJlcsOka25hciBoeXBlcmJvbGlzayB0YW5nZW50IGbDtnIgY2VsbGVyIGkgZXR0IHJhc3Rlci5cIixcblx0XHR0YW5IRGVzYzogXCJGdW5rdGlvbmVuIGJlcsOka25hciBoeXBlcmJvbGlzayB0YW5nZW50IGbDtnIgcGl4bGFybmEgaSBldHQgcmFzdGVyLlwiLFxuXHRcdHRhbk5hbWU6IFwiVGFuXCIsXG5cdFx0dGFuU25pcDogXCJCZXLDpGtuYXIgdGFuZ2VudCBmw7ZyIGNlbGxlciBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0dGFuRGVzYzogXCJGdW5rdGlvbmVuIGJlcsOka25hciB0YW5nZW50IGbDtnIgcGl4bGFybmEgaSBldHQgcmFzdGVyLiBcIixcblx0XHR0YXNzZWxlZENhcE5hbWU6IFwiVGFzc2VsZWQgQ2FwIChLYXV0aC1UaG9tYXMpXCIsXG5cdFx0dGFzc2VsZWRDYXBTbmlwOiBcIkJlcsOka25hciBuaXbDpWVyIGbDtnIgdmVnZXRhdGlvbiwgZnVrdGlnaGV0IG9jaCBsanVzc3R5cmthLiBUZWtuaWtlbiBmw7ZybGl0YXIgc2lnIHDDpSBrb2VmZmljaWVudGVyIHNvbSBtw6VzdGUgYmVyw6RrbmFzIHNwZWNpZmlrdCBmw7ZyIGVuIHNlbnNvci5cIixcblx0XHR0YXNzZWxlZENhcERlc2M6IFwiVGFzc2VsZWQgQ2FwLXRyYW5zZm9ybWF0aW9uZW4gKEthdXRoLVRob21hcykgw6RyIGtvbnN0cnVlcmFkIGbDtnIgYXR0IGFuYWx5c2VyYSBvY2ggbWFwcGEgdsOkeHRsaWdoZXRzZmVub21lbiBvY2ggc3RhZHNieWdnbmFkc2bDtnLDpG5kcmluZ2FyIHNvbSB1cHB0w6Rja3RzIGF2IG9saWthIHNhdGVsbGl0c2Vuc29yc3lzdGVtLiBEZW4ga2FsbGFzIFRhc3NlbGVkIENhcC10cmFuc2Zvcm1hdGlvbiBww6UgZ3J1bmQgYXYgZm9ybWVuIHDDpSBkZW4gZ3JhZmlza2EgZGlzdHJpYnV0aW9uZW4gYXYgZGF0YS4gVHJhbnNmb3JtYXRpb25lbiBnYXYgZW4gZsO2cmtsYXJpbmcgdGlsbCBkZSBtw7Zuc3RlciBzb20gZmFubnMgaSBMYW5kc2F0IE1TUy1kYXRhIGbDtnIgam9yZGJydWtzZsOkbHQgc29tIGVuIGZ1bmt0aW9uIGF2IGdyw7ZkYW5zIGxpdnNjeWtlbC4gS29ydGZhdHRhdCBza2VyIGRldCBlbiBuZXR0b8O2a25pbmcgaSBkZW4gbsOkcmEgaW5mcmFyw7ZkYSBvY2ggZW4gbWluc2tuaW5nIGkgZGVuIHLDtmRhIHJlZmxla3Rpb25lbiBiYXNlcmF0IHDDpSBmw6RyZ2VuIHDDpSBqb3JkZW4uPGRpdj48YnIvPkFudsOkbmRuaW5nc29tcsOlZGV0IGbDtnIgZGVuIGjDpHIgdHJhbnNmb3JtYXRpb25lbiBoYXIgdmlkZ2F0cyBmcsOlbiDDtnZlcnZha25pbmcgYXYgZ3LDtmRvciB0aWxsIHNrb2dzYnJ1aywgaW5kdXN0cmllbGwgdsOkeHRoYW50ZXJpbmcsIG1hcHBuaW5nIG9jaCBoYW50ZXJpbmcgYXYgZWtvc3lzdGVtLCBpbnZlbnRlcmluZyBvY2ggw7Z2ZXJ2YWtuaW5nIGbDtnIga29sZGlveGlkbGFncmluZyBvY2ggdXRzbMOkcHBzcsOkdHRlciwgc3RhZHNieWdnbmFkIG9jaCBhbm5hdC4gRGVuIGhhciBvY2tzw6UgdXTDtmthdHMgZnLDpW4gYXR0IHN0w7ZkamEgTGFuZHNhdCBNU1MgdGlsbCBhdHQgaW5rbHVkZXJhIGFuZHJhIHBvcHVsw6RyYSBzYXRlbGxpdHN5c3RlbSBzb20gTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rLCBMYW5kc2F0IDgsIElLT05PUywgUXVpY2tCaXJkLCBXb3JsZFZpZXctMiBvY2ggUmFwaWRFeWUuPC9kaXY+XCIsXG5cdFx0dGltZXNOYW1lOiBcIkfDpW5nZXJcIixcblx0XHR0aW1lc1NuaXA6IFwiTXVsdGlwbGljZXJhciB2w6RyZGVuYSBmw7ZyIHR2w6UgcmFzdGVyIGNlbGwgZsO2ciBjZWxsLlwiLFxuXHRcdHRpbWVzRGVzYzogXCJGdW5rdGlvbmVuIEfDpW5nZXIgbXVsdGlwbGljZXJhciB2w6RyZGVuYSBmw7ZyIHR2w6UgcmFzdGVyIHBpeGVsIGbDtnIgcGl4ZWwuXCIsXG5cdFx0dHJhbnNwb3NlQml0c05hbWU6IFwiR8O2ciBvbSBiaXRhclwiLFxuXHRcdHRyYW5zcG9zZUJpdHNTbmlwOiBcIlBhY2thciB1cHAgYml0YXJuYSBob3MgaW5kYXRhcGl4ZWxuIG9jaCBtYXBwYXIgZGVtIHRpbGwgYW5naXZuYSBiaXRhciBpIHV0ZGF0YXBpeGVsbi4gRnVua3Rpb25lbnMgc3lmdGUgw6RyIGF0dCBtb2RpZmllcmEgYml0YXIgZnLDpW4gZXR0IHBhciBpbmRhdGEsIHQuZXguIExhbmRzYXQgOC1rdmFsaXRldHNiYW5kc3Byb2R1a3Rlci5cIixcblx0XHR0cmFuc3Bvc2VCaXRzRGVzYzogXCJGdW5rdGlvbmVuIEfDtnIgb20gYml0YXIgcGFja2FyIHVwcCBiaXRhcm5hIGhvcyBpbmRhdGFwaXhlbG4gb2NoIG1hcHBhciBkZW0gdGlsbCBhbmdpdm5hIGJpdGFyIGkgdXRkYXRhcGl4ZWxuLiBGdW5rdGlvbmVucyBzeWZ0ZSDDpHIgYXR0IG1vZGlmaWVyYSBiaXRhciBmcsOlbiBldHQgcGFyIGluZGF0YSwgdC5leC4gTGFuZHNhdCA4LWt2YWxpdGV0c2JhbmRzcHJvZHVrdGVyLlwiLFxuXHRcdHVuaXRDb252ZXJzaW9uTmFtZTogXCJFbmhldHNrb252ZXJ0ZXJpbmdcIixcblx0XHR1bml0Q29udmVyc2lvblNuaXA6IFwiS29udmVydGVyYXIgdsOkcmRlbiBmcsOlbiBlbiBtw6R0ZW5oZXQgdGlsbCBlbiBhbm5hbi5cIixcblx0XHR1bml0Q29udmVyc2lvbkRlc2M6IFwiRGVubmEgZnVua3Rpb24ga29udmVydGVyYXIgcGl4bGFyIGZyw6VuIGVuIGVuaGV0IHRpbGwgZW4gYW5uYW4uIERlbiBoYXIgc3TDtmQgZsO2ciBrb252ZXJ0ZXJpbmcgYXYgc3Ryw6Rja2EsIGhhc3RpZ2hldCBvY2ggdGVtcGVyYXR1ci5cIixcblx0XHR2ZWN0b3JGaWVsZE5hbWU6IFwiVmVrdG9yZsOkbHRcIixcblx0XHR2ZWN0b3JGaWVsZFNuaXA6IFwiVmlzYXIgZGF0YXNldCBtZWQgYsOlZGUgbWFnbml0dWQgKHUpIG9jaCByaWt0bmluZyAodikgc29tIHBpbGFyLCBkw6RyIG1hZ25pdHVkZW4gdmlzYXMgYXYgcGlsZW5zIHN0b3JsZWsgb2NoIHJpa3RuaW5nZW4gYXYgZGVzcyB2aW5rZWwuXCIsXG5cdFx0dmVjdG9yRmllbGREZXNjOiBcIkZ1bmt0aW9uZW4gVmVrdG9yZsOkbHQgYW52w6RuZHMgZsO2ciBhdHQgc8OkdHRhIHNhbW1hbiBvY2gga29udmVydGVyYSB0dsOlIHJhc3RlciB0aWxsIGV0dCByYXN0ZXIgbWVkIHR2w6UgYmFuZCBzb20gw6RyIGFudGluZ2VuIGF2IGRhdGF0eXBlbiBtYWduaXR1ZC1yaWt0bmluZyBlbGxlciBkYXRhdHlwZW4gVS1WLjxkaXY+PGJyLz5VLXbDpHJkZXQga2FsbGFzIGlibGFuZCB6b25oYXN0aWdoZXQgb2NoIFYtdsOkcmRldCBrYWxsYXMgaWJsYW5kIG1lcmlkaW9uYWwgaGFzdGlnaGV0LjwvZGl2PlwiLFxuXHRcdHZpZXdzaGVkMk5hbWU6IFwiU3luZsOkbHRcIixcblx0XHR2aWV3c2hlZDJTbmlwOiBcIkJlc3TDpG1tZXIgdmlsa2EgcGxhdHNlciBww6UgcmFzdGVyeXRhbiBzb20gw6RyIHN5bmxpZ2EgZsO2ciBlbiB1cHBzw6R0dG5pbmcgb2JzZXJ2YXTDtnJzZ2Vvb2JqZWt0LCBtZWQgZ2VvZGV0aXNrYSBtZXRvZGVyLlwiLFxuXHRcdHZpZXdzaGVkMkRlc2M6IFwiRnVua3Rpb25lbiBTeW5mw6RsdCBiZXN0w6RtbWVyIHZpbGthIHBsYXRzZXIgcMOlIHJhc3Rlcnl0YW4gc29tIMOkciBzeW5saWdhIGbDtnIgZW4gdXBwc8OkdHRuaW5nIG9ic2VydmF0w7Zyc2dlb29iamVrdCwgbWVkIGdlb2RldGlza2EgbWV0b2Rlci48ZGl2Pjxici8+U3lubGlnaGV0ZW4gZsO2ciB2YXJqZSBwaXhlbG1pdHRwdW5rdCBmYXN0c3TDpGxscyBtZWQgZXR0IHNpa3RsaW5qZXRlc3QgbWVsbGFuIG3DpWxldCBvY2ggdmFyamUgb2JzZXJ2YXTDtnIuIE9tIGVuIG9ic2VydmF0w7ZyIGthbiBzZSBtw6VsZXQgaSBwaXhlbG5zIG1pdHRwdW5rdCBhbnNlcyBwaXhlbG4gdmFyYSBzeW5saWcuIERldHRhIHZlcmt0eWcgdGFyIGFsbHRpZCBow6Ruc3luIHRpbGwgam9yZGVucyBrdXJ2YXR1ciBuw6RyIHN5bmxpZ2hldGVuIGZhc3RzdMOkbGxzLjwvZGl2PlwiLFxuXHRcdHdhdGVyc2hlZE5hbWU6IFwiQXZyaW5uaW5nc29tcsOlZGVcIixcblx0XHR3YXRlcnNoZWRTbmlwOiBcIkZhc3RzdMOkbGxlciBhY2t1bXVsZXJpbmdzb21yw6VkZXQgb3ZhbmbDtnIgZW4gdXBwc8OkdHRuaW5nIGNlbGxlciBpIGV0dCByYXN0ZXIuXCIsXG5cdFx0d2F0ZXJzaGVkRGVzYzogXCJEZW4gZ2xvYmFsYSBmdW5rdGlvbmVuIEF2cmlubmluZ3NvbXLDpWRlIGZhc3RzdMOkbGxlciBhY2t1bXVsZXJpbmdzb21yw6VkZXQgb3ZhbmbDtnIgZW4gdXBwc8OkdHRuaW5nIHBpeGxhciBpIGV0dCByYXN0ZXIuIEF2cmlubmluZ3NvbXLDpWRlbiBhdmdyw6Ruc2FzIGF2IGV0dCBmbMO2ZGVzcmlrdG5pbmdzcmFzdGVyIHNvbSBpZGVudGlmaWVyYXIgZmzDtmRlc3Jpa3RuaW5nZW4gZnLDpW4gdmFyamUgcGl4ZWwuXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5TmFtZTogXCJWaWt0YWQgw7Z2ZXJsYWdyaW5nXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5U25pcDogXCLDlnZlcmxhZ3JhciBmbGVyYSByYXN0ZXIgbWVkIGVuIGdlbWVuc2FtIG3DpHRza2FsYSBvY2ggdmlrdGFyIHZhcnQgb2NoIGV0dCBlZnRlciBkZXNzIGJldHlkZWxzZS5cIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlEZXNjOiBcIk1lZCBkZW5uYSBmdW5rdGlvbiBrYW4gZHUgw7Z2ZXJsYWdyYSBmbGVyYSByYXN0ZXIgbWVkIGVuIGdlbWVuc2FtIG3DpHRza2FsYSBvY2ggdmlrdGEgdmFydCBvY2ggZXR0IGVmdGVyIGRlc3MgYmV0eWRlbHNlLlwiLFxuXHRcdHdlaWdodGVkU3VtTmFtZTogXCJWaWt0YWQgc3VtbWFcIixcblx0XHR3ZWlnaHRlZFN1bVNuaXA6IFwiVmlrdGFyIG9jaCBsw6RnZ2VyIHRpbGwgZXR0IGFudGFsIHJhc3RlciBww6UgY2VsbCBlZnRlciBjZWxsLlwiLFxuXHRcdHdlaWdodGVkU3VtRGVzYzogXCJGdW5rdGlvbmVuIFZpa3RhZCBzdW1tYSBsw6V0ZXIgZGlnIMO2dmVybGFncmEgZmxlcmEgcmFzdGVyIG9jaCBtdWx0aXBsaWNlcmEgdmFydCBvY2ggZXR0IG1lZCBkZXJhcyBnaXZuYSB2aWt0IG9jaCBzdW1tZXJhIGRlbS5cIixcblx0XHR3aW5kY2hpbGxOYW1lOiBcIlZpbmRhdmt5bG5pbmdcIixcblx0XHR3aW5kY2hpbGxTbmlwOiBcIktvbWJpbmVyYXIgb21naXZuaW5nc2x1ZnR0ZW1wZXJhdHVyIG9jaCB2aW5kaGFzdGlnaGV0IG9jaCBiZXLDpGtuYXIgdmluZGF2a3lsbmluZ2VuLlwiLFxuXHRcdHdpbmRjaGlsbERlc2M6IFwiRnVua3Rpb25lbiBWaW5kYXZreWxuaW5nIMOkciBhbnbDpG5kYmFyIGbDtnIgYXR0IGlkZW50aWZpZXJhIGZhcmxpZ2EgdmludGVyZsO2cmjDpWxsYW5kZW4gc29tLCBiZXJvZW5kZSBww6UgZXhwb25lcmluZ3N0aWRlbiwga2FuIGxlZGEgdGlsbCBmw7ZyZnJ5c25pbmcgZWxsZXIgdGlsbCBvY2ggbWVkIGh5cG90ZXJtaS4gVmluZGF2a3lsbmluZyDDpHIgZXR0IHPDpHR0IGF0dCBtw6R0YSBodXIga2FsbCBlbiBwZXJzb24ga8Okbm5lciBzaWcgbsOkciBow6Ruc3luIHRhcyB0aWxsIHZpbmRlbiB2aWQgcmVkYW4gbMOlZ2EgdGVtcGVyYXR1cmVyLiBKdSBow7ZncmUgdmluZGhhc3RpZ2hldCBkZXN0byBzbmFiYmFyZSBmw7ZybG9yYXIga3JvcHBlbiB2w6RybWUgb2NoIGRlc3RvIGthbGxhcmUga8Okbm5lciBzaWcgcGVyc29uZW4uXCIsXG5cdFx0em9uYWxSZW1hcE5hbWU6IFwiWm9uYmFzZXJhZCBvbWthcnRlcmluZ1wiLFxuXHRcdHpvbmFsUmVtYXBTbmlwOiBcIkthcnRlcmEgb20gcGl4bGFyIGkgZXR0IHJhc3RlciBiYXNlcmF0IHDDpSB6b25lciBkZWZpbmllcmFkZSBpIGV0dCBhbm5hdCByYXN0ZXIgb2NoIGVuIHpvbmJlcm9lbmRlIHbDpHJkZW1hcHBuaW5nIHNvbSBkZWZpbmllcmFzIGkgZW4gdGFiZWxsLlwiLFxuXHRcdHpvbmFsUmVtYXBEZXNjOiBcIk1lZCBkZW5uYSBmdW5rdGlvbiBrYW4gZHUga2FydGVyYSBvbSBwaXhsYXIgaSBldHQgcmFzdGVyIGJhc2VyYXQgcMOlIHpvbmVyIGRlZmluaWVyYWRlIGkgZXR0IGFubmF0IHJhc3RlciBvY2ggZW4gem9uYmVyb2VuZGUgdsOkcmRlbWFwcG5pbmcgc29tIGRlZmluaWVyYXMgaSBlbiB0YWJlbGwuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzTmFtZTogXCJab25iYXNlcmFkIHN0YXRpc3Rpa1wiLFxuXHRcdHpvbmFsU3RhdGlzdGljc1NuaXA6IFwiQmVyw6RrbmFyIHN0YXRpc3RpayBmw7ZyIHbDpHJkZW4gZnLDpW4gZXR0IHJhc3RlciBpbm9tIHpvbmVybmEgZsO2ciBldHQgYW5uYXQgZGF0YXNldC5cIixcblx0XHR6b25hbFN0YXRpc3RpY3NEZXNjOiBcIkZ1bmt0aW9uZW4gYmVyw6RrbmFyIHN0YXRpc3RpayBmw7ZyIHbDpHJkZW4gZnLDpW4gZXR0IHJhc3RlciBpbm9tIHpvbmVybmEgZsO2ciBldHQgYW5uYXQgZGF0YXNldC4gRW4gem9uIGRlZmluaWVyYXMgc29tIGFsbGEgb21yw6VkZW4gaSBpbmRhdGEgc29tIGhhciBzYW1tYSB2w6RyZGUuIE9tcsOlZGVuYSBiZWjDtnZlciBpbnRlIHZhcmEgc2FtbWFuaMOkbmdhbmRlLiBOw6RyIHpvbi0gb2NoIHbDpHJkZWluZGF0YSBiw6VkYSDDpHIgcmFzdGVyIG1lZCBzYW1tYSB1cHBsw7ZzbmluZyBrb21tZXIgZGUgYXR0IGFudsOkbmRhcyBkaXJla3QuIE9tIHVwcGzDtnNuaW5nYXJuYSDDpHIgb2xpa2EgdGlsbMOkbXBhcyBlbiBpbnRlcm4gb21zYW1wbGluZyBzb20gc2VyIHRpbGwgYXR0IHVwcGzDtnNuaW5nYXJuYSBtYXRjaGFyIGlubmFuIHpvbsOldGfDpHJkZW4gZ2Vub21mw7Zycy5cIixcblx0XHRmbG93TGVuZ3RoTmFtZTogXCJGbMO2ZGVzbMOkbmdkXCIsXG5cdFx0Zmxvd0xlbmd0aFNuaXA6IFwiQmVyw6RrbmFyIGF2c3TDpW5kZXQgdXBwc3Ryw7ZtcyBlbGxlciBuZWRzdHLDtm1zIGVsbGVyIGRldCB2aWt0YWRlIGF2c3TDpW5kZXQgbMOkbmdzIHZhcmplIGNlbGxzIGZsw7ZkZXN2w6RnLlwiLFxuXHRcdGZsb3dMZW5ndGhEZXNjOiBcIkRldCBow6RyIMOkciBlbiBnbG9iYWwgcmFzdGVyZnVua3Rpb24uIEZ1bmt0aW9uZW4gc2thcGFyIGV0dCByYXN0ZXJsYWdlciBtZWQgYXZzdMOlbmQgdXBwc3Ryw7ZtcyBlbGxlciBuZWRzdHLDtm1zLCBlbGxlciBldHQgdmlrdGF0IGF2c3TDpW5kLCBsw6RuZ3MgZmzDtmRlc3bDpGdlbiBmw7ZyIHZhcmplIGNlbGwuPGRpdj48YnIvPkV0dCBwcmltw6RydCBhbnbDpG5kbmluZ3NvbXLDpWRlIGbDtnIgZnVua3Rpb25lbiBGbMO2ZGVzbMOkbmdkIMOkciBhdHQgYmVyw6RrbmEgbMOkbmdkZW4gcMOlIGRlbiBsw6RuZ3N0YSBmbMO2ZGVzdsOkZ2VuIGlub20gZW4gdmlzcyBnaXZlbiBkYW1tLiBEZW4gaMOkciDDpXRnw6RyZGVuIGFudsOkbmRzIG9mdGEgZsO2ciBhdHQgYmVyw6RrbmEga29uY2VudHJhdGlvbnN0aWRlbiBmw7ZyIGVuIGRhbW0uIERldHRhIGfDtnJzIG1lZCBhbHRlcm5hdGl2ZXQgVXBwc3Ryw7Ztcy4gRnVua3Rpb25lbiBrYW4gb2Nrc8OlIGFudsOkbmRhcyBmw7ZyIGF0dCBza2FwYSBkaWFncmFtIG1lZCBhdnN0w6VuZC15dGEgZsO2ciBoeXBvdGV0aXNrdCByZWduIG9jaCBhdnJpbm5pbmcgbWVkIHZpa3RyYXN0cmV0IHNvbSBpbXBlZGFucyBmw7ZyIHLDtnJlbHNlciBpIGx1dG5pbmcuPC9kaXY+XCIsXG5cdFx0c3RyZWFtT3JkZXJOYW1lOiBcIlN0csO2bW9yZG5pbmdcIixcblx0XHRzdHJlYW1PcmRlclNuaXA6IFwiVGlsbGRlbGFyIGV0dCBudW1lcmlza3QgdsOkcmRlIHRpbGwgc2VnbWVudCBpIGV0dCByYXN0ZXIgc29tIHJlcHJlc2VudGVyYXIgZ3JlbmFyIGkgZXR0IGxpbmrDpHJ0IG7DpHR2ZXJrXCIsXG5cdFx0c3RyZWFtT3JkZXJEZXNjOiBcIkRldCBow6RyIMOkciBlbiBnbG9iYWwgcmFzdGVyZnVua3Rpb24uIERlbiBow6RyIGZ1bmt0aW9uZW4gc2thcGFyIGV0dCByYXN0ZXJsYWdlciBzb20gdGlsbGRlbGFyIGV0dCBudW1lcmlza3QgdsOkcmRlIHRpbGwgc2VnbWVudCBpIGV0dCByYXN0ZXIgc29tIHJlcHJlc2VudGVyYXIgZ3JlbmFyIGkgZXR0IGxpbmrDpHJ0IG7DpHR2ZXJrLjxkaXY+PGJyLz5VdGRhdGEgZsO2ciBmdW5rdGlvbmVuIFN0csO2bW9yZG5pbmcgYmxpciBhdiBow7ZncmUga3ZhbGl0ZXQgb20gaW5kYXRhc3Ryw7ZtcmFzdGVybGFncmV0IG9jaCBpbmRhdGFmbMO2ZGVzcmlrdG5pbmdzcmFzdGVybGFncmV0IGjDpHJsZWRzIGZyw6VuIHNhbW1hIHl0YS4gT20gc3Ryw7ZtcmFzdHJldCBow6RybGVkcyBmcsOlbiBldHQgcmFzdGVyaXNlcmF0IHN0csO2bWRhdGFzZXQsIGthbnNrZSBpbnRlIHV0ZGF0YSBnw6VyIGF0dCBhbnbDpG5kYSBlZnRlcnNvbSByaWt0bmluZ2VuIGNlbGwgZsO2ciBjZWxsIGludGUgbW90c3ZhcmFyIHBsYXRzZXJuYSBmw7ZyIHN0csO2bWNlbGxlcm5hLiBSZXN1bHRhdGV0IGF2IGZ1bmt0aW9uZW4gRmzDtmRlc2Fja3VtdWxlcmluZyBrYW4gYW52w6RuZGFzIGbDtnIgYXR0IHNrYXBhIGV0dCByYXN0ZXJzdHLDtm1uw6R0dmVyayBnZW5vbSBhdHQgdGlsbMOkbXBhIGV0dCB0csO2c2tlbHbDpHJkZSBzb20gdsOkbGplciB1dCBjZWxsZXIgbWVkIGjDtmd0IGFja3VtdWxlcmF0IGZsw7ZkZS4gQ2VsbGVyIHNvbSB0aWxsIGV4ZW1wZWwgaGFyIGZsZXIgw6RuIDEwMCBjZWxsZXIgc29tIGZsw7ZkYXIgdGlsbCBkZW0gYW52w6RuZHMgZsO2ciBhdHQgZGVmaW5pZXJhIHN0csO2bW7DpHR2ZXJrZXQuIEFudsOkbmQgZnVua3Rpb25lbiBDb24gZWxsZXIgU8OkdHQgbm9sbCBmw7ZyIGF0dCBza2FwYSBldHQgc3Ryw7ZtbsOkdHZlcmtzcmFzdGVyIGTDpHIgZmzDtmRlc2Fja3VtdWxlcmluZ3N2w6RyZGVuIHDDpSAxMDAgZWxsZXIgc3TDtnJyZSBnw6VyIHRpbGwgZXR0LCBvY2ggcmVzdGVuIHBsYWNlcmFzIGkgYmFrZ3J1bmRlbiAoTm9EYXRhKS4gRGV0IHJlc3VsdGVyYW5kZSBzdHLDtm1uw6R0dmVya2V0IGthbiBhbnbDpG5kYXMgaSBmdW5rdGlvbmVuIFN0csO2bW9yZG5pbmcuIERlbiBow6RyIGZ1bmt0aW9uZW4gaGFyIGVuZGFzdCBzdMO2ZCBmw7ZyIGV0dCBEOC1pbmRhdGFmbMO2ZGVzcmlrdG5pbmdzcmFzdGVybGFnZXIuIEQ4LWZsw7ZkZXNyaWt0bmluZ2FyIGthbiBza2FwYXMgbWVkIGZ1bmt0aW9uZW4gRmzDtmRlc3Jpa3RuaW5nIG9jaCBrw7ZyYXMgbWVkIHN0YW5kYXJkZmzDtmRlc3Jpa3RuaW5nc3R5cGVuIEQ4LjwvZGl2PlwiLFxuXHRcdHNuYXBQb3VyUG9pbnROYW1lOiBcIlNuYXBwYSBow6RsbHB1bmt0XCIsXG5cdFx0c25hcFBvdXJQb2ludFNuaXA6IFwiU25hcHBhciBow6RsbHB1bmt0ZXIgdGlsbCBjZWxsZW4gbWVkIGRlbiBow7Znc3RhIGZsw7ZkZXNhY2t1bXVsZXJpbmdlbiBpbm9tIGV0dCBhbmdpdmV0IGF2c3TDpW5kXCIsXG5cdFx0c25hcFBvdXJQb2ludERlc2M6IFwiRGV0IGjDpHIgw6RyIGVuIGdsb2JhbCByYXN0ZXJmdW5rdGlvbi4gRGVuIGjDpHIgZnVua3Rpb25lbiBzbmFwcGFyIGjDpGxscHVua3RlciB0aWxsIGNlbGxlbiBtZWQgZGVuIGjDtmdzdGEgZmzDtmRlc2Fja3VtdWxlcmluZ2VuIGlub20gZXR0IGFuZ2l2ZXQgYXZzdMOlbmQuPGRpdj48YnIvPkZ1bmt0aW9uZW4gU25hcHBhIGjDpGxscHVua3QgYW52w6RuZHMgZsO2ciBhdHQgc8Oka2Vyc3TDpGxsYSB2YWwgYXYgcHVua3RlciBtZWQgaMO2Z3QgYWNrdW11bGVyYXQgZmzDtmRlIHZpZCBhdmdyw6Ruc25pbmcgYXYgYXZyaW5uaW5nc29tcsOlZGVuIG1lZCBmdW5rdGlvbmVuIEF2cmlubmluZ3NvbXLDpWRlLiBTbmFwcGEgaMOkbGxwdW5rdCBzw7ZrZXIgaW5vbSBldHQgc25hcHBuaW5nc2F2c3TDpW5kIHJ1bnQgZGUgYW5naXZuYSBow6RsbHB1bmt0ZXJuYSBmw7ZyIGNlbGxlbiBtZWQgaMO2Z3N0IGFja3VtdWxlcmF0IGZsw7ZkZSBvY2ggZmx5dHRhciBow6RsbHB1bmt0ZW4gdGlsbCBkZW4gcGxhdHNlbi4gVXRkYXRhIMOkciBldHQgaGVsdGFsc3Jhc3RlcmxhZ2VyIG7DpHIgZGUgdXJzcHJ1bmdsaWdhIHBsYXRzZXJuYSBmw7ZyIGjDpGxscHVua3Rlcm5hIGhhciBzbmFwcGF0cyB0aWxsIHBsYXRzZXIgbWVkIGjDtmdyZSBhY2t1bXVsZXJhdCBmbMO2ZGUuPC9kaXY+XCIsXG5cdFx0c2lua05hbWU6IFwiU8OkbmthXCIsXG5cdFx0c2lua1NuaXA6IFwiU2thcGFyIGV0dCByYXN0ZXIgc29tIGlkZW50aWZpZXJhciBhbGxhIHPDpG5rb3IgZWxsZXIgb21yw6VkZW4gZsO2ciBpbnRlcm4gZHLDpG5lcmluZ1wiLFxuXHRcdHNpbmtEZXNjOiBcIkRldCBow6RyIMOkciBlbiBnbG9iYWwgcmFzdGVyZnVua3Rpb24uIERlbiBow6RyIGZ1bmt0aW9uZW4gc2thcGFyIGV0dCByYXN0ZXIgc29tIGlkZW50aWZpZXJhciBhbGxhIHPDpG5rb3IgZWxsZXIgb21yw6VkZW4gZsO2ciBpbnRlcm4gZHLDpG5lcmluZy4gRW4gc8OkbmthIMOkciBlbiBjZWxsIGVsbGVyIGVuIHVwcHPDpHR0bmluZyBnZW9ncmFmaXNrdCBhbnNsdXRuYSBjZWxsZXIgbWVkIGVuIGZsw7ZkZXNyaWt0bmluZyBzb20gaW50ZSBnw6VyIGF0dCB0aWxsZGVsYSBuw6Vnb3QgYXYgZGUgw6V0dGEgZ2lsdGlnYSB2w6RyZGVuYSBpIGV0dCBmbMO2ZGVzcmlrdG5pbmdzcmFzdGVyLiBEZXQgaMOkciBrYW4gaW50csOkZmZhIG7DpHIgYWxsYSBpbnRpbGxpZ2dhbmRlIGNlbGxlciDDpHIgaMO2Z3JlIMOkbiBkZW4gYmVhcmJldGFuZGUgY2VsbGVuIGVsbGVyIG7DpHIgdHbDpSBjZWxsZXIgZmzDtmRhciBpbiBpIHZhcmFuZHJhIG9jaCBza2FwYXIgZW4gc2xpbmdhIG1lZCB0dsOlIGNlbGxlci48ZGl2Pjxici8+RnVua3Rpb25lbiBTw6Rua2Egc3TDtmRlciBlbmRhc3QgZXR0IEQ4LWluZGF0YWZsw7ZkZXNyaWt0bmluZ3NyYXN0ZXJsYWdlci4gRDgtZmzDtmRlc3Jpa3RuaW5nYXIga2FuIHNrYXBhcyBtZWQgZnVua3Rpb25lbiBGbMO2ZGVzcmlrdG5pbmcgb2NoIGvDtnJhcyBtZWQgc3RhbmRhcmRmbMO2ZGVzcmlrdG5pbmdzdHlwZW4gRDguIFV0ZGF0YSBmw7ZyIGZ1bmt0aW9uZW4gU8OkbmthIMOkciBldHQgaGVsdGFsc3Jhc3RlciBkw6RyIHZhcmplIHPDpG5rYSB0aWxsZGVsYXMgZXR0IHVuaWt0IHbDpHJkZS4gRGVzc2EgdW5pa2EgdsOkcmRlbiBoYXIgZXR0IGludGVydmFsbCBzb20gbGlnZ2VyIG1lbGxhbiBldHQgb2NoIGRldCB0b3RhbGEgYW50YWxldCBzw6Rua29yLiBPbSBkZXQgdG90YWxhIGFudGFsZXQgc8OkbmtvciB0aWxsIGV4ZW1wZWwgdmFyIDEgMDAwLCBzdHLDpGNrZXIgc2lnIGRldCB1bmlrYSB2w6RyZGVpbnRlcnZhbGxldCBmcsOlbiAxIHRpbGwgMSAwMDAuPC9kaXY+XCIsXG5cdFx0YWdncmVnYXRlTmFtZTogXCJBZ2dyZWdlcmFcIixcblx0XHRhZ2dyZWdhdGVTbmlwOiBcIkdlbmVyZXJhciBlbiB2ZXJzaW9uIGF2IGV0dCByYXN0ZXIgbWVkIG1pbnNrYWQgdXBwbMO2c25pbmcuXCIsXG5cdFx0YWdncmVnYXRlRGVzYzogXCJGdW5rdGlvbmVuIEFnZ3JlZ2VyYSBvbXNhbXBsYXIgZXR0IGluZGF0YXJhc3RlciB0aWxsIGVuIGdyw7Z2cmUgdXBwbMO2c25pbmcgYmFzZXJhdCBww6UgZW4gYW5naXZlbiBhZ2dyZWdlcmluZ3NzdHJhdGVnaS4gVmFyamUgdXRkYXRhY2VsbCBpbm5laMOlbGxlciBTdW1tYSwgTWluaW11bSwgTWF4aW11bSwgTWVkZWwgZWxsZXIgTWVkaWFuIGbDtnIgZGUgaW5kYXRhY2VsbGVybmEgc29tIG9tZmF0dGFzIGF2IGRlbiBjZWxsZW5zIHV0YnJlZG5pbmcuPGRpdj48YnIvPkR1IGthbiBzcGVjaWZpY2VyYSBmYWt0b3JuIG1lZCB2aWxrZW4gY2VsbHN0b3JsZWtlbiBhdiBpbmRhdGFyYXN0cmV0IHNrYSBtdWx0aXBsaWNlcmFzLiBUaWxsIGV4ZW1wZWwgc2t1bGxlIGV0dCBjZWxsZmFrdG9ydsOkcmRlIHDDpSAzIHJlc3VsdGVyYSBpIHV0ZGF0YSBkw6RyIGNlbGxzdG9ybGVrZW4gw6RyIHRyZSBnw6VuZ2VyIHN0w7ZycmUgw6RuIGluZGF0YXJhc3RyZXQuIER1IGthbiBkZWZpbmllcmEgaHVyIHV0ZGF0YXMgdXRicmVkbmluZyBza2EgaGFudGVyYXMgb20gYW50YWxldCByYWRlciBlbGxlciBrb2x1bW5lciBpbnRlIMOkciBlbiBleGFrdCBtdWx0aXBlbCBhdiBjZWxsZmFrdG9ybi4gU29tIHN0YW5kYXJkIGV4cGFuZGVyYXMgZGUgw7Z2cmUgZWxsZXIgaMO2Z3JhIGdyw6Ruc2VybmEgZsO2ciBhdHQgdMOkY2thIGVuIHN0w7ZycmUgZ2VvZ3JhZmlzayB1dGJyZWRuaW5nIMOkbiBpbmRhdGFyYXN0cmV0cywgZsO2ciBhdHQgc8Oka2Vyc3TDpGxsYSBhdHQgYWxsYSBpbmRhdGFjZWxsZXIgYmVhcmJldGFzLiBBbHRlcm5hdGl2dCBrYW4gZGUgw7Z2cmUgZWxsZXIgaMO2Z3JhIGdyw6Ruc2VybmEgbWluc2thcyBmw7ZyIGF0dCB0w6Rja2EgZW4gbWluZHJlIHV0YnJlZG5pbmcsIHPDpSBhdHQgZGV0IGFudGFsIHJhZGVyIG9jaCBrb2x1bW5lciBzb20gYmVhcmJldGFzIMOkciBlbiBleGFrdCBtdWx0aXBlbCBhdiBjZWxsZmFrdG9ybi4gRHUga2FuIGRlZmluaWVyYSBodXIgTm9EYXRhLWNlbGxlciBza2EgaGFudGVyYXMgYXYgYWdncmVnZXJpbmdzYmVyw6RrbmluZ2VuLiBTdGFuZGFyZG1la2FuaXNtZW4gw6RyIGF0dCBOb0RhdGEtaW5kYXRhY2VsbGVyIHNvbSBmYWxsZXIgaW5vbSBkZW4gZ2VvZ3JhZmlza2EgdXRicmVkbmluZ2VuIGbDtnIgZW4gc3TDtnJyZSBjZWxsIGkgdXRkYXRhcmFzdHJldCBpZ25vcmVyYXMgbsOkciB2w6RyZGV0IGF2IGRlbiB1dGRhdGFjZWxsZW4gYXZnw7Zycy4gQWx0ZXJuYXRpdnQga2FuIGR1IGFuZ2UgYXR0IG9tIGRldCBmaW5ucyDDpHZlbiBlbiBlbnN0YWthIE5vRGF0YS1pbmRhdGFjZWxsIGlub20gZGVuIGdlb2dyYWZpc2thIHV0YnJlZG5pbmdlbiBmw7ZyIGVuIHV0ZGF0YWNlbGwsIGJsaXIgZGVuIGNlbGxlbiBOb0RhdGEgaSB1dGRhdGFyYXN0cmV0LjwvZGl2PlwiLFxuXHRcdGNjZGNOYW1lOiBcIkNDREMtYW5hbHlzXCIsXG5cdFx0Y2NkY1NuaXA6IFwiVXR2w6RyZGVyYXIgw6RuZHJpbmdhciBpIHBpeGVsdsOkcmRlbiDDtnZlciB0aWQgbWVkIENDREMtYWxnb3JpdG1lbiAoQ29udGludW91cyBDaGFuZ2UgRGV0ZWN0aW9uIGFuZCBDbGFzc2lmaWNhdGlvbikgb2NoIGdlbmVyZXJhciBtb2RlbGxyZXN1bHRhdC5cIixcblx0XHRjY2RjRGVzYzogXCJDQ0RDLWFuYWx5c2Z1bmt0aW9uZW4gdXR2w6RyZGVyYXIgw6RuZHJpbmdhciBpIHBpeGVsdsOkcmRlbiDDtnZlciB0aWQgbWVkIENDREMtYWxnb3JpdG1lbiAoQ29udGludW91cyBDaGFuZ2UgRGV0ZWN0aW9uIGFuZCBDbGFzc2lmaWNhdGlvbikgb2NoIGdlbmVyZXJhciBldHQgZmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVyIHNvbSBpbm5laMOlbGxlciBtb2RlbGxyZXN1bHRhdGVuLiBEZW4gc3TDtmRzIGJhcmEgaSBrb21iaW5hdGlvbiBtZWQgZnVua3Rpb25lbiBJZGVudGlmaWVyYSDDpG5kcmluZyBtZWQgaGrDpGxwIGF2IMOkbmRyaW5nc2FuYWx5cyBpIGVuIHJhc3RlcmZ1bmt0aW9uc21hbGwuIEbDtnIgYXR0IHNrYXBhIHJhc3RlcnV0ZGF0YSBtw6VzdGUgZHUga29wcGxhIENDREMtYW5hbHlzZnVua3Rpb25lbiB0aWxsIGZ1bmt0aW9uZW4gSWRlbnRpZmllcmEgw6RuZHJpbmcgbWVkIGhqw6RscCBhdiDDpG5kcmluZ3NhbmFseXMsIHNwYXJhIHNvbSBlbiByYXN0ZXJmdW5rdGlvbnNtYWxsIG9jaCBrw7ZyYSBSYXN0ZXJhbmFseXMgbWVkIGZ1bmt0aW9uc21hbGxlbi48ZGl2Pjxici8+RGVuIGjDpHIgZnVua3Rpb25lbiBhbnbDpG5kZXIgQ0NEQy1hbGdvcml0bWVuIChDb250aW51b3VzIENoYW5nZSBEZXRlY3Rpb24gYW5kIENsYXNzaWZpY2F0aW9uKSBmw7ZyIGF0dCB1dHbDpHJkZXJhIMOkbmRyaW5nYXIgaSBwaXhlbHbDpHJkZW4gw7Z2ZXIgdGlkIGbDtnIgZW4gc3RhcGVsIGJpbGRlci4gSSBlbiB0aWRzc2VyaWUgYXYgb3B0aXNrYSBiaWxkZXIgZWxsZXIgYmlsZGjDpHJsZWRuaW5nYXIgKHQuZXguIE5EVkkpIGthbiBwaXhlbHbDpHJkZW4gZmx1a3R1ZXJhIGF2IGZsZXJhIGFubGVkbmluZ2FyOiAxLiBTw6Rzb25nc3NraWZ0ZW4g4oCTIMOEbmRyYWRlIHBpeGVsdsOkcmRlbiBtb3RzdmFyYXIgZsO2csOkbmRyaW5nYXIgaSB2ZWdldGF0aW9uZW4gcMOlIGdydW5kIGF2IHPDpHNvbmdzYmV0b25hZGUgdmFyaWF0aW9uZXIgaSB0ZW1wZXJhdHVyIG9jaCBuZWRlcmLDtnJkLiBQw6Ugbm9ycmEgaGFsdmtsb3RldCB2w6RudGFyIHZpIG9zcyB0LmV4LiBhdHQgc2UgaMO2Z3JlIHTDpHRoZXQgYXYgZ3LDtm4gdmVnZXRhdGlvbiBww6Ugc29tbWFyZW4gw6RuIHDDpSB2aW50ZXJuOyAyLiBHcmFkdmlzIGbDtnLDpG5kcmluZyDigJMgw4RuZHJhZGUgcGl4ZWx2w6RyZGVuIMOldGVyc3BlZ2xhciB0cmVuZGVyIGkgdsOkeHRsaWdoZXQgZWxsZXIgeXR2YXR0ZW4gcMOlIGdydW5kIGF2IGtsaW1hdHZhcmlhdGlvbmVyIGVsbGVyIGzDpW5nc2lrdGlnIG1hcmtmw7ZydmFsdG5pbmdzcHJheGlzLiBUaWxsIGV4ZW1wZWwga2FuIGJhciBtYXJrIGdyYWR2aXMgw7ZrYSBpIHl0YSBww6UgZ3J1bmQgYXYgZW4gbMOlbmdzaWt0aWcgbWluc2tuaW5nIGF2IG5lZGVyYsO2cmRlbiwgb2NoIDMuIEFicnVwdGEgw6RuZHJpbmdhciDigJMgw4RuZHJhZGUgcGl4ZWx2w6RyZGVuIMOldGVyc3BlZ2xhciBmw7Zyw6RuZHJpbmdhciBpIG1hcmt0w6Rja25pbmcgc29tIHVwcGtvbW1lciBwbMO2dHNsaWd0IHDDpSBncnVuZCBhdiBza29nc2F2dmVya25pbmcsIHN0YWRzYnlnZ25hZCwgbmF0dXJrYXRhc3Ryb2ZlciBvc3YuIENDREMtYWxnb3JpdG1lbiBpZGVudGlmaWVyYXIgYWxsYSB0cmUgdHlwZXJuYSBhdiBmw7Zyw6RuZHJpbmcgaSBkZXQgaHV2dWRzYWtsaWdhIHN5ZnRldCBhdHQgaWRlbnRpZmllcmEgYWJydXB0YSBmw7Zyw6RuZHJpbmdhci4gSGFybW9uaXNrIHJlZ3Jlc3Npb24gb2NoIHRyZW5kbW9kZWxsZXIgYW5wYXNzYXMgdGlsbCBkYXRhIGbDtnIgYXR0IGJlcsOka25hIHPDpHNvbmdzYmV0b25hZGUgb2NoIGdyYWR2aXNhIGbDtnLDpG5kcmluZ2FyLCBvY2ggcGzDtnRzbGlnYSBhdnZpa2Vsc2VyIGZyw6VuIHRyZW5kbW9kZWxsZXJuYSDDpHIgaW5kaWthdGlvbmVyIHDDpSBhYnJ1cHRhIGbDtnLDpG5kcmluZ2FyLjxkaXY+PGJyLz5DQ0RDLWFsZ29yaXRtZW4gdXRmb3JtYWRlcyB1cnNwcnVuZ2xpZ2VuIGbDtnIgTGFuZHNhdCBUTS0sIExhbmRzYXQgRVRNKy0gb2NoIExhbmRzYXQgT0xJLWRhdGEgeXRyZWZsZWt0YW5zLSBlbGxlciBsanVzc3R5cmtldGVtcGVyYXR1cmRhdGEuIEZ1bmt0aW9uZW4gSWRlbnRpZmllcmEgw6RuZHJpbmcgbWVkIGhqw6RscCBhdiDDpG5kcmluZ3NhbmFseXMgaSBrb21iaW5hdGlvbiBtZWQgZGVubmEgZnVua3Rpb24gaWRlbnRpZmllcmFyIGRvY2sgZsO2csOkbmRyaW5nYXIgZsO2ciBmbGVyYmFuZHNiaWxkZXIgZnLDpW4gYWxsYSBzZW5zb3JlciBzb20gc3TDtmRzLCBzYW10IGV0dGJhbmRzYmlsZGRlcml2YXQgc29tIGJhbmRpbmRleC4gRHUga2FuIHRpbGwgZXhlbXBlbCB1dGbDtnJhIGtvbnRpbnVlcmxpZyBpZGVudGlmaWVyaW5nIGF2IGbDtnLDpG5kcmluZ2FyIHDDpSBldHQgTkRWSS1yYXN0ZXIgKE5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBWZWdldGF0aW9uIEluZGV4KSwgZWZ0ZXJzb20gYWJydXB0YSDDpG5kcmluZ2FyIGkgTkRWSSBrYW4gaW5kaWtlcmEgc2tvZ3NhdnZlcmtuaW5nLjwvZGl2PlwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VOYW1lOiBcIkJlcsOka25hIGbDtnLDpG5kcmluZ1wiLFxuXHRcdGNvbXB1dGVDaGFuZ2VTbmlwOiBcIkJlcsOka25hciBza2lsbG5hZGVuIG1lbGxhbiB0dsOlIGthdGVnb3Jpc2thIGVsbGVyIGtvbnRpbnVlcmxpZ2EgcmFzdGVyZGF0YXNldC5cIixcblx0XHRjb21wdXRlQ2hhbmdlRGVzYzogXCJGdW5rdGlvbmVuIEJlcsOka25hIGbDtnLDpG5kcmluZyBrYW4gYW52w6RuZGFzIGbDtnIgYXR0IGbDtnJ0ZWNrbmEgc2tpbGxuYWRlcm5hIG1lbGxhbiB0dsOlIGtsYXNzaWZpY2VyYWRlIHJhc3RlciBmw7ZyIGFuYWx5cyBhdiBtYXJrdMOkY2tuaW5nc2bDtnLDpG5kcmluZywgZWxsZXIgc8OlIGthbiBkZW4gYW52w6RuZGFzIGbDtnIgYXR0IHVuZGVyc8O2a2EgZsO2csOkbmRyaW5nYXIgbWVsbGFuIHR2w6Uga29udGludWVybGlnYSBldHRiYW5kc3Jhc3RlciBzb20gaMO2amQgw7Z2ZXIgaGF2ZXQsIHRlbXBlcmF0dXIsIHRyw6Rka3JvbmV0ZWNrbmluZyBvc3YuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlTmFtZTogXCJJZGVudGlmaWVyYSDDpG5kcmluZyBtZWQgaGrDpGxwIGF2IMOkbmRyaW5nc2FuYWx5c1wiLFxuXHRcdGRldGVjdENoYW5nZVNuaXA6IFwiR2VuZXJlcmFyIGV0dCByYXN0ZXJsYWdlciBzb20gaW5uZWjDpWxsZXIgaW5mb3JtYXRpb24gb20gcGl4ZWxmw7Zyw6RuZHJpbmdhciBtZWQgcmFzdHJldCBmw7ZyIHV0ZGF0YWbDtnLDpG5kcmluZ3NhbmFseXMuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlRGVzYzogXCI8ZGl2PkZ1bmt0aW9uZW4gSWRlbnRpZmllcmEgw6RuZHJpbmcgbWVkIGhqw6RscCBhdiDDpG5kcmluZ3NhbmFseXMgZ2VuZXJlcmFyIGV0dCByYXN0ZXJsYWdlciBzb20gaW5uZWjDpWxsZXIgaW5mb3JtYXRpb24gb20gcGl4ZWxmw7Zyw6RuZHJpbmdzZGF0dW0gbWVkIGbDtnLDpG5kcmluZ3NhbmFseXNyYXN0cmV0LiBGw7Zyw6RuZHJpbmdzYW5hbHlzcmFzdHJldCBtw6VzdGUgZ2VuZXJlcmFzIGF2IHZlcmt0eWdldCBBbmFseXNlcmEgZsO2csOkbmRyaW5nIG1lZCBDQ0RDIGVsbGVyIEFuYWx5c2VyYSDDpG5kcmluZ2FyIG1lZCBMYW5kVHJlbmRyLCBlbGxlciByYXN0ZXJmdW5rdGlvbmVuIENDREMtYW5hbHlzIGVsbGVyIHJhc3RlcmZ1bmt0aW9uZW4gTGFuZFRyZW5kci1hbmFseXMuPC9kaXY+PGJyPjxkaXY+RGVuIGjDpHIgcmFzdGVyZnVua3Rpb25lbiBrYW4ga29tYmluZXJhcyBtZWQgcmFzdGVyZnVua3Rpb25lbiBDQ0RDLWFuYWx5cyBlbGxlciByYXN0ZXJmdW5rdGlvbmVuIExhbmRUcmVuZHItYW5hbHlzIGkgZW4gcmFzdGVyZnVua3Rpb25zbWFsbC4gT20gZHUgdmlsbCBza2FwYSBwZXJtYW5lbnRhIHJhc3RlcnV0ZGF0YSBhbnNsdXRlciBkdSBDQ0RDLWFuYWx5c2Z1bmt0aW9uZW4gZWxsZXIgTGFuZFRyZW5kci1hbmFseXNmdW5rdGlvbmVuIHRpbGwgZnVua3Rpb25lbiBJZGVudGlmaWVyYSDDpG5kcmluZyBtZWQgaGrDpGxwIGF2IMOkbmRyaW5nc2FuYWx5cywgc3BhcmFyIHNvbSBlbiBtYWxsIGbDtnIgcmFzdGVyZnVua3Rpb24gb2NoIGvDtnIgUmFzdGVyYW5hbHlzIG1lZCBtYWxsZW4uIDwvZGl2Pjxicj48ZGl2PlBhcmFtZXRlcm4gPHN0cm9uZz7DhG5kcmluZ3N0eXA8L3N0cm9uZz4gaW5kaWtlcmFyIGRlbiBpbmZvcm1hdGlvbiBzb20gZ2VuZXJlcmFzLiBJbmZvcm1hdGlvbmVuIGV4dHJhaGVyYXMgZnLDpW4gw6RuZHJpbmdzYW5hbHlzcmFzdHJldC4gTsOkciBkdSBrw7ZyIGRlbiBow6RyIGZ1bmt0aW9uZW4gcMOlIHV0ZGF0YSBmcsOlbiBDQ0RDLWZ1bmt0aW9uZW4vLXZlcmt0eWdldCBrYW4gZHUgdsOkbGphIG1lbGxhbiBmw7ZsamFuZGUgYWx0ZXJuYXRpdjo8L2Rpdj48dWw+PGxpPjxzdHJvbmc+VGlkIGbDtnIgc2VuYXN0ZSBmw7Zyw6RuZHJpbmc8L3N0cm9uZz4g4oCTIERldCBzZW5hc3RlIGRhdHVtZXQgb2NoIHRpZGVuIGTDpSBlbiBwaXhlbCBmbGFnZ2FkZXMgc29tIMOkbmRyYWQuPC9saT48bGk+PHN0cm9uZz5UaWQgZsO2ciB0aWRpZ2FzdGUgZsO2csOkbmRyaW5nPC9zdHJvbmc+IOKAkyBEZXQgdGlkaWdhc3RlIGRhdHVtZXQgb2NoIHRpZGVuIGTDpSBlbiBwaXhlbCBmbGFnZ2FkZXMgc29tIMOkbmRyYWQuPC9saT48bGk+PHN0cm9uZz5UaWQgZsO2ciBzdMO2cnN0YSBmw7Zyw6RuZHJpbmc8L3N0cm9uZz4g4oCTIERhdHVtIG9jaCB0aWQgZMOlIGRlbiBiZXLDpGtuYWRlIMOkbmRyaW5nZW4gdmFyIGRlbiBtZXN0IHNpZ25pZmlrYW50YSBmw7ZyIGVuIHBpeGVsLjwvbGk+PGxpPiA8c3Ryb25nPkFudGFsIGbDtnLDpG5kcmluZ2FyPC9zdHJvbmc+IOKAkyBEZXQgc2FtbWFubGFnZGEgYW50YWxldCBnw6VuZ2VyIHBpeGVsbiBoYXIgw6RuZHJhdHMuPC9saT48L3VsPjxkaXY+TsOkciBmdW5rdGlvbmVuIGvDtnJzIHDDpSB1dGRhdGEgZnLDpW4gTGFuZFRyZW5kci1mdW5rdGlvbmVuLy12ZXJrdHlnZXQgZmlubnMgZsO2bGphbmRlIHl0dGVybGlnYXJlIGFsdGVybmF0aXY6PC9kaXY+PHVsPjxsaT48c3Ryb25nPlRpZCBmw7ZyIGzDpG5nc3RhIGbDtnLDpG5kcmluZzwvc3Ryb25nPiDigJMgRGV0IGRhdHVtIGTDpSBlbiBwaXhlbCBmbGFnZ2FkZXMgc29tIMOkbmRyYWQsIGkgYsO2cmphbiBlbGxlciBzbHV0ZXQgYXYgZGVuIGzDpG5nc3RhIHBlcmlvZGVuIGbDtnIgZsO2csOkbmRyaW5nLjwvbGk+PGxpPjxzdHJvbmc+VGlkIGbDtnIga29ydGFzdGUgZsO2csOkbmRyaW5nPC9zdHJvbmc+IOKAkyBEZXQgZGF0dW0gZMOlIGVuIHBpeGVsIGZsYWdnYWRlcyBzb20gw6RuZHJhZCwgaSBiw7ZyamFuIGVsbGVyIHNsdXRldCBhdiBkZW4ga29ydGFzdGUgcGVyaW9kZW4gZsO2ciBmw7Zyw6RuZHJpbmcuPC9saT48bGk+PHN0cm9uZz5UaWRlbiBmw7ZyIHNuYWJiYXN0ZSBmw7Zyw6RuZHJpbmc8L3N0cm9uZz4g4oCTIERldCBkYXR1bSBkw6UgZW4gcGl4ZWwgZmxhZ2dhZGVzIHNvbSDDpG5kcmFkLCBpIGLDtnJqYW4gZWxsZXIgc2x1dGV0IGF2IGRlbiBzbmFiYmFzdGUgcGVyaW9kZW4gZsO2ciBmw7Zyw6RuZHJpbmcuPC9saT48bGk+PHN0cm9uZz5UaWQgZsO2ciBsw6VuZ3NhbW1hc3RlIGbDtnLDpG5kcmluZzwvc3Ryb25nPiDigJMgRGV0IGRhdHVtIGTDpSBlbiBwaXhlbCBmbGFnZ2FkZXMgc29tIMOkbmRyYWQsIGkgYsO2cmphbiBlbGxlciBzbHV0ZXQgYXYgZGVuIGzDpW5nc2FtbWFzdGUgcGVyaW9kZW4gZsO2ciBmw7Zyw6RuZHJpbmcuPC9saT48L3VsPjxkaXY+VXRkYXRhcmFzdHJldCDDpHIgZXR0IGZsZXJiYW5kc3Jhc3RlciBkw6RyIHZhcmplIGJhbmQgaW5uZWjDpWxsZXIgaW5mb3JtYXRpb24gb20gZGVuIHZhbGRhIMOkbmRyaW5nc3R5cGVuIG9jaCBkZXQgbWF4aW1hbGEgYW50YWxldCBhbmdpdm5hIMOkbmRyaW5nYXIuIE9tIHRpbGwgZXhlbXBlbCA8c3Ryb25nPsOEbmRyYSB0eXA8L3N0cm9uZz4gw6RyIGluc3TDpGxsdCB0aWxsIDxzdHJvbmc+VGlkIGbDtnIgdGlkaWdhc3RlIGbDtnLDpG5kcmluZzwvc3Ryb25nPiBvY2ggPHN0cm9uZz5NYXhpbWFsdCBhbnRhbCBmw7Zyw6RuZHJpbmdhcjwvc3Ryb25nPiDDpHIgaW5zdMOkbGx0IHRpbGwgMiwgYmVyw6RrbmFyIGZ1bmt0aW9uZW4gZGUgdHbDpSB0aWRpZ2FzdGUgZGF0dW1lbiBuw6RyIGVuIGbDtnLDpG5kcmluZyBpbnRyw6RmZmFkZSBnZW5vbSB0aWRzc2VyaWVuIGbDtnIgdmFyamUgcGl4ZWwuIFJlc3VsdGF0ZXQgw6RyIGV0dCByYXN0ZXIgZMOkciBkZXQgZsO2cnN0YSBiYW5kZXQgaW5uZWjDpWxsZXIgZGF0dW1lbiBmw7ZyIGRlbiB0aWRpZ2FzdGUgZsO2csOkbmRyaW5nZW4gcGVyIHBpeGVsLCBvY2ggZGV0IGFuZHJhIGJhbmRldCBpbm5laMOlbGxlciBkYXR1bWVuIGbDtnIgZGVuIG7DpHN0IHRpZGlnYXN0ZSBmw7Zyw6RuZHJpbmdlbiBwZXIgcGl4ZWwuPC9kaXY+PGJyPjxkaXY+TsOkciBmdW5rdGlvbmVuIHRpbGzDpG1wYXMgcMOlIHV0ZGF0YSBmcsOlbiBMYW5kVHJlbmRyLXZlcmt0eWdlbiwga2FuIGR1IHbDpGxqYSBvbSBkdSB2aWxsIGV4dHJhaGVyYSBkZXQgZGF0dW0gc29tIG1hcmtlcmFyIGLDtnJqYW4gYXYgZW4gZsO2csOkbmRyaW5nIGVsbGVyIHNsdXRldCBhdiBlbiBmw7Zyw6RuZHJpbmcgbWVkIHBhcmFtZXRlcm4gPHN0cm9uZz5TZWdtZW50ZGF0dW08L3N0cm9uZz4uIEbDtnIgYXR0IHRpbGwgZXhlbXBlbCBmw7Zyc3TDpSBodXIgZGVuIHNlbmFzdGUgw6RuZHJpbmdlbiBpIHRpZHNzZXJpZW4gc3RhcnRhZGVzLCBhbmdlciBkdSA8c3Ryb25nPsOEbmRyaW5nc3R5cDwvc3Ryb25nPiB0aWxsIDxzdHJvbmc+VGlkIGbDtnIgc2VuYXN0ZSBmw7Zyw6RuZHJpbmc8L3N0cm9uZz4gb2NoIDxzdHJvbmc+U2VnbWVudGRhdHVtPC9zdHJvbmc+IHRpbGwgPHN0cm9uZz5Cw7ZyamFuIGF2IHNlZ21lbnQ8L3N0cm9uZz4uPC9kaXY+PGJyPjxkaXY+QW52w6RuZCBmw7ZsamFuZGUgZmlsdHJlcmluZ3NwYXJhbWV0cmFyIG9tIGR1IHZpbGwgZXh0cmFoZXJhIG1lciBzcGVjaWZpa2EgZGF0dW0gZsO2ciBmw7Zyw6RuZHJpbmcgZnLDpW4gw6RuZHJpbmdzYW5hbHlzcmFzdHJldDo8L2Rpdj48dWw+PGxpPjxzdHJvbmc+RmlsdHJlcmEgZWZ0ZXIgw6VyPC9zdHJvbmc+IOKAkyBJZGVudGlmaWVyYSBmw7Zyw6RuZHJpbmdhciBzb20gaW50csOkZmZhZGUgaW5vbSBlbiB2aXNzIHRpZHNwZXJpb2QsIG9tIGR1IHRpbGwgZXhlbXBlbCBsZXRhciBlZnRlciBmw7Zyw6RuZHJpbmdhciBzb20gaGFyIGludHLDpGZmYXQgaSBldHQgbGFuZHNrYXAgdW5kZXIgZmVtIMOlciBhdiB0b3JrYS48L2xpPjxsaT48c3Ryb25nPkZpbHRyZXJhIGVmdGVyIHZhcmFrdGlnaGV0IDwvc3Ryb25nPiDigJMgSWRlbnRpZmllcmEgZsO2csOkbmRyaW5nYXIgc29tIGludHLDpGZmYWRlIHVuZGVyIGV0dCB2aXNzdCBhbnRhbCDDpXIsIHRpbGwgZXhlbXBlbCBvbSBkdSBiYXJhIGxldGFyIGVmdGVyIGFicnVwdGEgZsO2csOkbmRyaW5nYXIgc29tIMOkZ2RlIHJ1bSDDtnZlciAxIGVsbGVyIDIgw6VyLiBEdSBrYW4gYmVyw6RrbmEgZGVuIHZhcmFrdGlnaGV0IGR1IMOkciBpbnRyZXNzZXJhZCBhdiBhbnbDpG5kYSBtZWQgaGrDpGxwIGF2IGZvcm1lbG4gPHN0cm9uZz5zbHV0w6VyIC0gc3RhcnTDpXIgKzE8L3N0cm9uZz4uIE1lbGxhbnJ1bSBpIHRpZHNzZXJpZW4gdGFzIG1lZC48L2xpPjxsaT48c3Ryb25nPkZpbHRyZXJhIGVmdGVyIG1hZ25pdHVkPC9zdHJvbmc+IOKAkyBJZGVudGlmaWVyYSDDpG5kcmluZ2FyIGF2IGVuIHZpc3MgbWFnbml0dWQsIHRpbGwgZXhlbXBlbCBvbSBkdSBiYXJhIGxldGFyIGVmdGVyIHN0b3JhIGbDtnLDpG5kcmluZ2FyIGkgdmVnZXRhdGlvbnNpbmRleGV0IE5EVkkuIE1hZ25pdHVkIMOkciBldHQgYWJzb2x1dCB2w6RyZGUsIHPDpSBtaW5pbWktIG9jaCBtYXhpbWl2w6RyZGVuYSBmw6VyIGludGUgdmFyYSBuZWdhdGl2YS4gQW5nZSByaWt0bmluZ3PDpG5kcmluZyBtZWQgcGFyYW1ldGVybiA8c3Ryb25nPsOEbmRyYSByaWt0bmluZzwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25OYW1lOiBcIkF2c3TDpW5kc2Fja3VtdWxlcmluZ1wiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uU25pcDogXCJCZXLDpGtuYXIgYWNrdW11bGVyYXQgYXZzdMOlbmQgZsO2ciB2YXJqZSBjZWxsIHRpbGwga8OkbGxvciwgbWVkIGjDpG5zeW4gdGlsbCByYWsgbGluamUtYXZzdMOlbmQsIGtvc3RuYWRzYXZzdMOlbmQsIHZlcmtsaWd0IHl0YXZzdMOlbmQsIHNhbXQgdmVydGlrYWxhIG9jaCBob3Jpc29udGVsbGEga29zdG5hZHNmYWt0b3Jlci5cIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvbkRlc2M6IFwiQXZzdMOlbmRzYWNrdW11bGVyaW5nIGJlcsOka25hciBhdnN0w6VuZGV0IHRpbGwgdmFyamUgcGxhdHMgaSB1bmRlcnPDtmtuaW5nc29tcsOlZGV0IHRpbGwgZGVuIG7DpHJtYXN0ZSwgZWxsZXIgYmlsbGlnYXN0ZSwga8OkbGxhbi4gT20gYmFyYSBrw6RsbG9ybmEgYW5nZXMgZsO2ciBpbmRhdGEsIGJlcsOka25hcyBldHQgcmFrIGxpbmplLWF2c3TDpW5kIHRpbGwgdmFyamUgcGxhdHMgaSB1bmRlcnPDtmtuaW5nc29tcsOlZGV0LiBPbSBiw6VkZSBrw6RsbG9yIG9jaCBoaW5kZXIgYW52w6RuZHMgc29tIGluZGF0YSwgYmVyw6RrbmFyIEF2c3TDpW5kc2Fja3VtdWxlcmluZyByYWsgbGluamUtYXZzdMOlbmRldCBydW50IGhpbmRlci4gRsO2ciBiw6VkZSBrw6RsbHJhc3RyZXQgb2NoIGhpbmRlcnJhc3RyZXQgYsO2ciBiYWtncnVuZHN2w6RyZGV0IHZhcmEgTm9EYXRhLCBtZWRhbiBrw6RsbG9yIG9jaCBoaW5kZXIgcmVwcmVzZW50ZXJhcyBtZWQgZ2lsdGlnYSBjZWxsdsOkcmRlbi4gR2lsdGlnYSB2w6RyZGVuIGlubmVmYXR0YXIgbm9sbC4gPGRpdj48YnIvPk7DpHIgZXR0IHl0cmFzdGVyIGFuZ2VzIHNvbSBpbmRhdGEsIGJlcsOka25hcyBkZXQgZmFrdGlza2EgeXRhdnN0w6VuZGV0IG1lbGxhbiBjZWxsZXIuIEbDtnIgYXR0IHV0ZsO2cmEga29zdG5hZHNhbmFseXMgbWVkIEF2c3TDpW5kc2Fja3VtdWxlcmluZywgYmVow7Z2cyBlbiBrb3N0bmFkc3l0YS4gT20gZW4ga29zdG5hZHN5dGEgYW5nZXMsIGJsaXIgcmVzdWx0YXRldCBldHQgYWNrdW11bGVyYXQgcmFzdGVyIGbDtnIgYXZzdMOlbmRza29zdG5hZC4gTsOkciBob3Jpc29udGFsLSBvY2ggdmVydGlrYWxmYWt0b3JlciB0aWxsaGFuZGFow6VsbHMsIGJlYWt0YXMgcmlrdG5pbmcgbsOkciBrb3N0bmFkZW4gYWNrdW11bGVyYXMuIERldCBmaW5ucyBmeXJhIGvDpGxsZ3J1bmRkcmFnIHNvbSBrYW4gYW52w6RuZGFzLiBEZXNzYSBncnVuZGRyYWcsIHNvbSBhbnRpbmdlbiBrYW4gdmFyYSBmw7ZyIGvDpGxsYW4gZWxsZXIgYWt0w7ZyZXJuYSBmcsOlbiBrw6RsbGFuLCBzdHlycyBhdiBzcGVjaWZpa2EgcGFyYW1ldHJhcjogMS4gSW5sZWRhbmRlIGFja3VtdWxlcmluZzrigK9hbmdlciBkZW4gaW5sZWRhbmRlIGtvc3RuYWRlbiBpbm5hbiByw7ZyZWxzZW4gYsO2cmphci4gMi4gTWF4aW1hbCBhY2t1bXVsZXJpbmc64oCvYW5nZXIgaHVyIG15Y2tldCBlbiBrw6RsbGEga2FuIGFja3VtdWxlcmEgaW5uYW4gZGVuIG7DpXIgc2luIGdyw6Rucy4gMy4gTXVsdGlwbGlrYXRvciBhdHQgYW52w6RuZGEgcMOlIGtvc3RuYWRlcjrigK9zcGVjaWZpY2VyYXIgZsOkcmRsw6RnZXQgZWxsZXIgbWFnbml0dWRlbiB2aWQga8OkbGxhbi4gNC4gUmVzZXJpa3RuaW5nOuKAr2lkZW50aWZpZXJhciBvbSBha3TDtnJlbiBzdGFydGFyIHZpZCBlbiBrw6RsbGEgb2NoIHLDtnIgc2lnIHRpbGwgYW5kcmEgcGxhdHNlciDDpG4ga8OkbGxhbiwgZWxsZXIgc3RhcnRhciB2aWQgcGxhdHNlciBzb20gaW50ZSB0aWxsaMO2ciBrw6RsbGFuIG9jaCByw7ZyIHNpZyB0aWxsYmFrYSB0aWxsIGVuIGvDpGxsYS48ZGl2Pjxici8+U29tIHN0YW5kYXJkIMOkciByZXN1bHRhdGV0IGZyw6VuIEF2c3TDpW5kc2Fja3VtdWxlcmluZyBldHQgZW5kYSBiYW5kLCBzb20gw6RyIGF2c3TDpW5kc2Fja3VtdWxlcmluZ3NyYXN0cmV0LiBEZXQgZ8OlciBkb2NrIMOkdmVuIGF0dCBza2FwYSBldHQgYW5kcmEgYmFuZCwgdGlsbGJha2FyaWt0bmluZ3NiYW5kZXQuICBEZXQgYmFuZGV0IHZpc2FyIGkgdmlsa2VuIHJpa3RuaW5nIG1hbiBza2EgcmVzYSBmcsOlbiB2YXJqZSBwbGF0cyBpIHVuZGVyc8O2a25pbmdzb21yw6VkZXQgZsO2ciBhdHQga29tbWEgdGlsbCBkZW4gYmlsbGlnYXN0ZSBrw6RsbGFuLiBCw6VkYSBiYW5kZW4gYmVow7Z2cyBmw7ZyIGF0dCBmYXN0c3TDpGxsYSBvcHRpbWFsYSBydXR0ZXIgaW5vbSB1bmRlcnPDtmtuaW5nc29tcsOlZGV0LiBGw7ZyIGF0dCBnZW5lcmVyYSBlbiBydXR0IHNrYSBmw7Zyc3QgZnVua3Rpb25lbiBFeHRyYWhlcmEgYmFuZCBhbnbDpG5kYXMgZsO2ciBhdHQgZXh0cmFoZXJhIGF2c3TDpW5kc2Fja3VtdWxlcmluZ3NyYXN0cmV0IG9jaCB0aWxsYmFrYXJpa3RuaW5nc3Jhc3RyZXQuIEFudsOkbmQgZGVzc2EgbGFnZXIgc29tIGluZGF0YSBmw7ZyIGZ1bmt0aW9uZW4gS29zdG5hZHNydXR0LiBJIGZ1bmt0aW9uZW4gYW52w6RuZGVyIGR1IGF2c3TDpW5kc2Fja3VtdWxlcmluZ3NyYXN0cmV0IHNvbSBpbmRhdGEgZsO2ciBSYXN0ZXIgZsO2ciBhdnN0w6VuZHNhY2t1bXVsZXJpbmdzcmFzdGVyLCBvY2ggdGlsbGJha2FyaWt0bmluZ3NyYXN0cmV0IHNvbSBpbmRhdGEgZsO2ciBSYXN0ZXIgZsO2ciBiYWvDpXRsw6Rua3Nrb3N0bmFkLjwvZGl2PlwiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvbk5hbWU6IFwiQXZzdMOlbmRzYWxsb2tlcmluZ1wiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvblNuaXA6IFwiQmVyw6RrbmFyIGF2c3TDpW5kc2FsbG9rZXJpbmcgZsO2ciB2YXJqZSBjZWxsIHRpbGwgZGUgYW5naXZuYSBrw6RsbG9ybmEgYmFzZXJhdCBww6UgcmFrIGxpbmplLWF2c3TDpW5kLCBrb3N0bmFkc2F2c3TDpW5kLCB2ZXJrbGlndCB5dGF2c3TDpW5kLCBzYW10IHZlcnRpa2FsYSBvY2ggaG9yaXNvbnRlbGxhIGtvc3RuYWRzZmFrdG9yZXIuXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uRGVzYzogXCJBdnN0w6VuZHNhbGxva2VyaW5nIGJlcsOka25hciB0aWxsIHZpbGtlbiBrw6RsbGEgdmFyamUgcGxhdHMgaSB1bmRlcnPDtmtuaW5nc29tcsOlZGV0IMOkciBhbGxva2VyYWQuIE9tIGVuZGFzdCBrw6RsbG9ybmEgYW5nZXMgc29tIGluZGF0YSwgYWxsb2tlcmFzIHBsYXRzZXJuYSBlZnRlciBldHQgcmFrIGxpbmplLWF2c3TDpW5kIHRpbGwgZGVuIG7DpHJtYXN0ZSBrw6RsbGFuLiBPbSBiw6VkZSBrw6RsbG9yIG9jaCBoaW5kZXIgYW52w6RuZHMgc29tIGluZGF0YSwgYmVyw6RrbmFyIEF2c3TDpW5kc2FsbG9rZXJpbmcgcmFrIGxpbmplLWF2c3TDpW5kZXQgcnVudCBoaW5kZXIgZsO2ciBhdHQgYXZnw7ZyYSB2aWxrZW4ga8OkbGxhIGVuIHBsYXRzIGFsbG9rZXJhcyB0aWxsLiBGw7ZyIGLDpWRlIGvDpGxscmFzdHJldCBvY2ggaGluZGVycmFzdHJldCBiw7ZyIGJha2dydW5kc3bDpHJkZXQgdmFyYSBOb0RhdGEsIG1lZGFuIGvDpGxsb3Igb2NoIGhpbmRlciByZXByZXNlbnRlcmFzIG1lZCBnaWx0aWdhIGNlbGx2w6RyZGVuLiBHaWx0aWdhIHbDpHJkZW4gaW5uZWZhdHRhciBub2xsLjxkaXY+PGJyLz5Gw7ZyIGF0dCB1dGbDtnJhIGtvc3RuYWRzYW5hbHlzIG1lZCBBdnN0w6VuZHNhbGxva2VyaW5nLCBiZWjDtnZzIGVuIGtvc3RuYWRzeXRhLiBPbSBlbiBrb3N0bmFkc3l0YSBhbmdlcyDDpHIgcmVzdWx0YXRldCBldHQgdGlsbGRlbG5pbmdzcmFzdGVyIGJhc2VyYXQgcMOlIGFja3VtdWxhdGl2IGtvc3RuYWQsIGludGUgcMOlIHJhayBsaW5qZS1hdnN0w6VuZC4gTsOkciBob3Jpc29udGFsLSBvY2ggdmVydGlrYWxmYWt0b3JlciB0aWxsaGFuZGFow6VsbHMsIGJlYWt0YXMgcmlrdG5pbmcgbsOkciBrb3N0bmFkZW4gYWNrdW11bGVyYXMuIE7DpHIgZXR0IHl0cmFzdGVyIGFuZ2VzIHNvbSBpbmRhdGEsIGJlcsOka25hcyBkZXQgZmFrdGlza2EgeXRhdnN0w6VuZGV0IHNvbSB0w6Rja3MgdmlkIHBhc3NhZ2UgbWVsbGFuIGNlbGxlciBuw6RyIGFsbG9rZXJpbmcgYXZnw7Zycy4gRGV0IGZpbm5zIGZ5cmEga8OkbGxncnVuZGRyYWcgc29tIGthbiBhbnbDpG5kYXMuIERlc3NhIGdydW5kZHJhZywgc29tIGFudGluZ2VuIGthbiB2YXJhIGbDtnIga8OkbGxhbiBlbGxlciBha3TDtnJlcm5hIGZyw6VuIGvDpGxsYW4sIHN0eXJzIGF2IHNwZWNpZmlrYSBwYXJhbWV0cmFyOiAxLiBJbmxlZGFuZGUgYWNrdW11bGVyaW5nOuKAr2FuZ2VyIGRlbiBpbmxlZGFuZGUga29zdG5hZGVuIGlubmFuIHLDtnJlbHNlbiBiw7ZyamFyLiAyLiBNYXhpbWFsIGFja3VtdWxlcmluZzrigK9hbmdlciBodXIgbXlja2V0IGVuIGvDpGxsYSBrYW4gYWNrdW11bGVyYSBpbm5hbiBkZW4gbsOlciBzaW4gZ3LDpG5zLiAzLiBNdWx0aXBsaWthdG9yIGF0dCBhbnbDpG5kYSBww6Uga29zdG5hZGVyOuKAr3NwZWNpZmljZXJhciBmw6RyZGzDpGdldCBlbGxlciBtYWduaXR1ZGVuIHZpZCBrw6RsbGFuLiA0LiBSZXNlcmlrdG5pbmc64oCvaWRlbnRpZmllcmFyIG9tIGFrdMO2cmVuIHN0YXJ0YXIgdmlkIGVuIGvDpGxsYSBvY2ggcsO2ciBzaWcgdGlsbCBhbmRyYSBwbGF0c2VyIMOkbiBrw6RsbGFuLCBlbGxlciBzdGFydGFyIHZpZCBwbGF0c2VyIHNvbSBpbnRlIHRpbGxow7ZyIGvDpGxsYW4gb2NoIHLDtnIgc2lnIHRpbGxiYWthIHRpbGwgZW4ga8OkbGxhLjxkaXY+PGJyLz5Tb20gc3RhbmRhcmQgw6RyIHJlc3VsdGF0ZXQgZnLDpW4gQXZzdMOlbmRzYWxsb2tlcmluZyBldHQgZW5kYSBiYW5kLCBzb20gw6RyIGF2c3TDpW5kc2FsbG9rZXJpbmdzcmFzdHJldC4gT20gZHUgbWFya2VyYXIgZGV0IGJvb2xlc2thIGFsdGVybmF0aXZldCBHZW5lcmVyYSBrw6RsbHJhZCBvY2gga29sdW1uIHNvbSB5dHRlcmxpZ2FyZSBiYW5kIGkgdXRkYXRhIHJlc3VsdGVyYXIgZGV0IGkgZXR0IGZsZXJiYW5kc3Jhc3RlciBzb20gYmVzdMOlciBhdiB0cmUgYmFuZC4gRGV0IGbDtnJzdGEgYmFuZGV0IMOkciBhdnN0w6VuZHNhbGxva2VyaW5nc2JhbmRldCwgZGV0IGFuZHJhIGJhbmRldCBpbm5laMOlbGxlciBldHQgcmFkaW5kZXggb2NoIGRldCB0cmVkamUgYmFuZGV0IGlubmVow6VsbGVyIGV0dCBrb2x1bW5pbmRleC4gRGVzc2EgaW5kZXggaWRlbnRpZmllcmFyIHBsYXRzZW4gZsO2ciBrw6RsbGNlbGxlbiBzb20gw6RyIGRlbiBsw6Rnc3RhIGFja3VtdWxlcmFkZSBhdnN0w6VuZHNrb3N0bmFkZW4gYm9ydC4gS8OkbGxyYWRpbmRleGV0IG9jaCBrw6RsbGtvbHVtbmluZGV4ZXQga2FuIGFudsOkbmRhcyB0aWxsc2FtbWFucyBmw7ZyIGF0dCBza2FwYSBpbnRlbnNpdGV0c2thcnRvci4gT20gZHUgc8O2a2VyIGVmdGVyIG7DpWdvbiBwbGF0cyBpIHVuZGVyc8O2a25pbmdzb21yw6VkZXQgw7Z2ZXIgYmFuZCB0dsOlIG9jaCB0cmUsIHZldCBkdSByYWRlbiBvY2gga29sdW1uZW4gZsO2ciBkZW4gYmlsbGlnYXN0ZSBrw6RsbGFuIGbDtnIgZGVuIHBsYXRzZW4uPC9kaXY+XCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvbk5hbWU6IFwiRXVrbGlkaXNrIHRpbGxiYWthZsO2cmRlbG5pbmdcIixcblx0XHRldWNCYWNrRGlyZWN0aW9uU25pcDogXCJCZXLDpGtuYXIgcmlrdG5pbmdlbiBpIGdyYWRlciBmw7ZyIHZhcmplIGNlbGwgbW90IGVuIGFuZ3LDpG5zYW5kZSBjZWxsIGzDpG5ncyBkZW4ga29ydGFzdGUgdsOkZ2VuIHRpbGxiYWthIHRpbGwgZGVuIG7DpHJtYXN0ZSBrw6RsbGFuIHNhbXRpZGlndCBzb20gZGV0IHVuZHZpa2VyIGhpbmRlci5cIixcblx0XHRldWNCYWNrRGlyZWN0aW9uRGVzYzogXCJGdW5rdGlvbmVuIEV1a2xpZGlzayB0aWxsYmFrYWbDtnJkZWxuaW5nIHJlc3VsdGVyYXIgaSBldHQga29udGludWVybGlndCBmbHl0dGFsc3Jhc3RlciBzb20gcmVwcmVzZW50ZXJhciByaWt0bmluZ2VuIGkgZ3JhZGVyIHRpbGxiYWthIHRpbGwgZGVuIG7DpHJtYXN0ZSBrw6RsbGFuIHNhbXRpZGlndCBzb20gZGV0IHVuZHZpa2VyIGV2ZW50dWVsbGEgaGluZGVyLjxkaXY+PGJyLz5JbmRhdGEgdGlsbCBFdWtsaWRpc2sgdGlsbGJha2Fmw7ZyZGVsbmluZyDDpHIgZGVuIGvDpGxsYSBzb20gcmlrdG5pbmdlbiBiZXLDpGtuYXMgdGlsbC4gVmFsZnJpYSBpbmRhdGEgw6RyIGV0dCByYXN0ZXIgc29tIHJlcHJlc2VudGVyYXIgaGluZGVyIGlub20gdW5kZXJzw7ZrbmluZ3NvbXLDpWRldC4gRsO2ciBiw6VkZSBrw6RsbHJhc3RyZXQgb2NoIGhpbmRlcnJhc3RyZXQgYsO2ciBiYWtncnVuZHN2w6RyZGV0IHZhcmEgTm9EYXRhLCBtZWRhbiBrw6RsbG9yIG9jaCBoaW5kZXIgcmVwcmVzZW50ZXJhcyBtZWQgZ2lsdGlnYSB2w6RyZGVuLiBHaWx0aWdhIHbDpHJkZW4gaW5uZWZhdHRhciBub2xsLiBTb20gc3RhbmRhcmQgYmVhcmJldGFyIGJlcsOka25pbmdlbiB0aWxsIGRlbiBrb21iaW5lcmFkZSB1dGJyZWRuaW5nZW4gYXYga8OkbGxvcm5hIG9jaCBoaW5kcmVuLCBwbHVzIDIgcmFkZXIgb2NoIGtvbHVtbmVyLiBPbSBhbmFseXNlbiBiYXJhIGJlaMO2dnMgaW5vbSBldHQgYW5naXZldCBhdnN0w6VuZCBmcsOlbiBrw6RsbG9ybmEsIGthbiBwYXJhbWV0ZXJuIE1heGltYWx0IGF2c3TDpW5kIGFudsOkbmRhcy4gRXVrbGlkaXNrIHRpbGxiYWthZsO2cmRlbG5pbmcgaGFyIHN0w7ZkIGbDtnIgYsOlZGUgZW4gcGxhbiBtZXRvZCBvY2ggZW4gZ2VvZGV0aXNrIG1ldG9kIGkgYmVyw6RrbmluZ2VuLiBCZXLDpGtuaW5nZW4gbWVkIHBsYW4gbWV0b2QgdXRmw7ZycyBww6UgZXR0IHByb2ppY2VyYXQgcGxhdHQgcGxhbiBtZWQgZXR0IHR2w6VkaW1lbnNpb25lbGx0IGthcnRlc2lza3Qga29vcmRpbmF0c3lzdGVtLiBCZXLDpGtuaW5nZW4gbWVkIGdlb2RldGlzayBtZXRvZCB1dGbDtnJzIHDDpSBlbGxpcHNvaWRlbiwgdmlsa2V0IGlubmViw6RyIGF0dCByZXN1bHRhdGV0IGludGUgZsO2csOkbmRyYXMgYmVyb2VuZGUgYXYgaW5kYXRhLSBlbGxlciB1dGRhdGFwcm9qZWt0aW9uLjxkaXY+PGJyLz5SZXN1bHRhdGV0IGZyw6VuIGZ1bmt0aW9uZW4gRXVrbGlkaXNrIHRpbGxiYWthZsO2cmRlbG5pbmcga2FuIGFudsOkbmRhcyBpIGtvbWJpbmF0aW9uIG1lZCByZXN1bHRhdGV0IGZyw6VuIGZ1bmt0aW9uZW4gRXVrbGlkaXNrdCBhdnN0w6VuZCBmw7ZyIGF0dCBhdmfDtnJhIGRlIGtvcnRhc3RlIHJ1dHRlcm5hIGZyw6VuIHBsYXRzZXIgaW5vbSB1bmRlcnPDtmtuaW5nc29tcsOlZGV0IHRpbGxiYWthIHRpbGwga8OkbGxhbi4gQsOlZGUgcmVzdWx0YXRldCBmw7ZyIEV1a2xpZGlzayB0aWxsYmFrYWbDtnJkZWxuaW5nIG9jaCByZXN1bHRhdGV0IGbDtnIgRXVrbGlkaXNrdCBhdnN0w6VuZCBhbnbDpG5kcyBpIGZ1bmt0aW9uZW4gS29zdG5hZHNydXR0IHRpbGxzYW1tYW5zIG1lZCBtw6VsIGbDtnIgYXR0IGdlbmVyZXJhIGRlIGtvcnRhc3RlIHJ1dHRlcm5hLjwvZGl2PlwiLFxuXHRcdGV4cGFuZE5hbWU6IFwiRXhwYW5kZXJhXCIsXG5cdFx0ZXhwYW5kU25pcDogXCJFeHBhbmRlcmFyIHZhbGRhIHpvbmVyIGkgZXR0IHJhc3RlciBlZnRlciB6b25lciBtZWQgZXR0IHZpc3N0IGFudGFsIGNlbGxlci5cIixcblx0XHRleHBhbmREZXNjOiBcIk1lZCBkZW4gZ2xvYmFsYSBFeHBhbmRlcmEtZnVua3Rpb25lbiBrYW4gZHUgZ2VuZXJhbGlzZXJhIGVsbGVyIGbDtnJlbmtsYSByYXN0ZXIgZ2Vub20gYXR0IGfDtnJhIHZpc3NhIHpvbmVyIHN0w7ZycmUuIER1IGthbiBvY2tzw6Ugc3R5cmEgbcOkbmdkZW4gZ2VuZXJhbGlzZXJpbmcgc29tIHNrYSBmw7ZyZWtvbW1hLjxkaXY+PGJyLz5EZSB6b25lciBkdSB2w6RsamVyIMO2a2FyIGkgc3RvcmxlayBnZW5vbSBhdHQgZXhwYW5kZXJhIHRpbGwgYW5kcmEgem9uZXIuIEtvbmNlcHR1ZWxsdCBrYW4gZGUgdmFsZGEgem9udsOkcmRlbmEgc2VzIHNvbSBmw7ZyZ3J1bmRzem9uZXIsIG1lZGFuIGRlIGFuZHJhIHbDpHJkZW5hIGbDtnJibGlyIGJha2dydW5kc3pvbmVyLiBGw7ZyZ3J1bmRzem9uZXJuYSBrYW4gZXhwYW5kZXJhIHRpbGwgYmFrZ3J1bmRzem9uZXJuYS48ZGl2Pjxici8+TcOkbmdkZW4gZ2VuZXJhbGlzZXJpbmcga2FuIHN0eXJhcyBtZWQgcGFyYW1ldGVybiBBbnRhbCBjZWxsZXIuIFNvbSBzdGFuZGFyZCDDpHIgZGV0dGEgdsOkcmRlIDEsIHZpbGtldCBpbm5lYsOkciBhdHQgZGUgdmFsZGEgem9uZXJuYSBleHBhbmRlcmFyIG1lZCBkZW4gbcOkbmdkIHNvbSBtb3RzdmFyYXIgZW4gY2VsbHMgc3Rvcmxlay4gRsO2ciBhdHQgw7ZrYSBncmFkZW4gYXYgZ2VuZXJhbGlzZXJpbmcga2FuIGR1IGFuZ2UgZXR0IHN0w7ZycmUgdsOkcmRlIGbDtnIgZGVuIGjDpHIgcGFyYW1ldGVybi4gS29uY2VwdHVlbGx0IMOkciBkZXQgc29tIGF0dCBrw7ZyYSB2ZXJrdHlnZXQgbGlrYSBtw6VuZ2EgZ8OlbmdlciBzb20gZGV0IGFuZ2l2bmEgYW50YWxldCwgZMOkciByZXN1bHRhdGVuIGF2IGbDtnJlZ8OlZW5kZSBrw7ZybmluZyDDpHIgaW5kYXRhIHRpbGwgbsOkc3RhIGl0ZXJhdGlvbi48L2Rpdj5cIixcblx0XHR0cmVuZEFuYWx5c2lzTmFtZTogXCJHZW5lcmVyYSB0cmVuZFwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTbmlwOiBcIlVwcHNrYXR0YXIgdHJlbmRlbiBmw7ZyIHZhcmplIHBpeGVsIGzDpG5ncyBlbiBkaW1lbnNpb24gZsO2ciBlbiBlbGxlciBmbGVyYSB2YXJpYWJsZXIgaSBldHQgZmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVyLlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNEZXNjOiBcIjxkaXY+RGVuIGjDpHIgZnVua3Rpb25lbiBrYW4gYW52w6RuZGFzIGbDtnIgYXR0IHBhc3NhIGRhdGEgbMOkbmdzIGVuIGxpbmrDpHIsIGhhcm1vbmlzayBlbGxlciBwb2x5bm9tIHRyZW5kbGluamUsIGVsbGVyIHPDpSBrYW4gZGVuIGFudsOkbmRhcyBmw7ZyIGF0dCB1dGbDtnJhIHRyZW5kaWRlbnRpZmllcmluZyBtZWQgTWFubi1LZW5kYWxsLSBlbGxlciBTZWFzb25hbC1LZW5kYWxsLXRlc3RldC48L2Rpdj48YnI+PGRpdj5VdGRhdGF0cmVuZHJhc3RyZXQgc29tIGdlbmVyZXJhcyBtZWQgZGVuIGjDpHIgZnVua3Rpb25lbiBhbnbDpG5kcyBzb20gaW5kYXRhIHRpbGwgZnVua3Rpb25lbiA8c3Ryb25nPkbDtnJ1dHPDpGcgbWVkIHRyZW5kPC9zdHJvbmc+LjwvZGl2Pjxicj48ZGl2Pk1hbm4tS2VuZGFsbC0gb2NoIFNlYXNvbmFsLUtlbmRhbGwtdGVzdGVybmEgYW52w6RuZHMgZsO2ciBhdHQgYXZnw7ZyYSBvbSBkZXQgZmlubnMgZW4gbW9ub3RvbmlzayB0cmVuZCBpIGRhdGEuIERlIMOkciBpY2tlLXBhcmFtZXRyaXNrYSwgdmlsa2V0IGlubmViw6RyIGF0dCBkZSBpbnRlIGbDtnJ1dHPDpHR0ZXIgbsOlZ29uIHNwZWNpZmlrIGRhdGFmw7ZyZGVsbmluZy4gTWFubi1LZW5kYWxsLXRlc3RldCB0YXIgaW50ZSBow6Ruc3luIHRpbGwgc2VyaWVlZmZla3RlciBmw7ZyIGtvcnJlbGF0aW9uZXIgZWxsZXIgw6Vyc3RpZGVyLiBPbSBkYXRhIMOkciDDpXJzdGlkc2Jlcm9lbmRlIMOkciBTZWFzb25hbC1LZW5kYWxsLXRlc3RldCBtZXIgbMOkbXBsaWd0LjwvZGl2Pjxicj48ZGl2Pk9tIHZlcmt0eWdldCBhbnbDpG5kcyBmw7ZyIGF0dCB1dGbDtnJhIGFudGluZ2VuIE1hbm4tS2VuZGFsbC0gZWxsZXIgU2Vhc29uYWwtS2VuZGFsbC10ZXN0ZXQsIMOkciB1dGRhdGEgZXR0IHJhc3RlciBtZWQgZmVtIGJhbmQgZW5saWd0IGbDtmxqYW5kZTo8L2Rpdj48dWw+PGxpPkJhbmQgMSA9IFNlbnMgc2x1dHRuaW5nPC9saT48bGk+MiA9IHAtdsOkcmRlPC9saT48bGk+QmFuZCAzID0gTWFubi1LZW5kYWxsLXBvw6RuZyAoUyk8L2xpPjxsaT5CYW5kIDQgPSBTLXZhcmlhbnM8L2xpPjxsaT5CYW5kIDQgPSBTLXZhcmlhbnM8L2xpPjxsaT5CYW5kIDUgPSBaLXBvw6RuZzwvbGk+PC91bD48ZGl2PlJlc3VsdGF0ZW4gZnLDpW4gTWFubi1LZW5kYWxsLXRlc3RldCBlbGxlciBTZWFzb25hbC1LZW5kYWxsLXRlc3RldCBrYW4gYW52w6RuZGFzIGbDtnIgYXR0IGZhc3RzdMOkbGxhIHZpbGthIHBpeGxhciBpIGZsZXJkaW1lbnNpb25lbGxhIHRpZHNzZXJpZXIgc29tIGhhciBlbiBzdGF0aXN0aXNrdCBzaWduaWZpa2FudCB0cmVuZC4gRGVuIGjDpHIgaW5mb3JtYXRpb25lbiBrYW4gZHUgYW52w6RuZGEgaSBzYW1iYW5kIG1lZCBsaW5qw6RyYSwgaGFybW9uaXNrYSBlbGxlciBwb2x5bm9tYSB0cmVuZGFuYWx5c2VyIGbDtnIgYXR0IGV4dHJhaGVyYSBzaWduaWZpa2FudGEgdHJlbmRlciBpIGRpbiB0aWRzc2VyaWUuIER1IGthbiBnZW5lcmVyYSBlbiBtYXNrIHNvbSBpbm5laMOlbGxlciBwaXhsYXIgbWVkIHNpZ25pZmlrYW50YSBwLXbDpHJkZW4sIHRpbGzDpG1wYSBtYXNrZW4gcMOlIGRldCBmbGVyZGltZW5zaW9uZWxsYSByYXN0cmV0IG9jaCBhbnbDpG5kYSBkZXQgbWFza2VyYWRlIGZsZXJkaW1lbnNpb25zcmFzdHJldCBzb20gaW5kYXRhIGbDtnIgdmVya3R5Z2V0IGbDtnIgYXR0IHV0ZsO2cmEgbGluasOkcmEgYW5hbHlzZXIgYXYgcC12w6RyZGVuIGVsbGVyIHBvbHlub210cmVuZGVyLjwvZGl2Pjxicj48ZGl2PkRldCBmaW5ucyB0cmUgdHJlbmRsaW5qZWFsdGVybmF0aXYgZsO2ciBhdHQgYW5wYXNzYSBlbiB0cmVuZCB0aWxsIHZhcmlhYmVsdsOkcmRlbmEgbMOkbmdzIGVuIGRpbWVuc2lvbjogbGluasOkciwgcG9seW5vbSBvY2ggaGFybW9uaXNrLjwvZGl2Pjxicj48ZGl2PkbDtnIgbGluasOkcmEgdHJlbmRhbmFseXNlciDDpHIgdXRkYXRhIGV0dCB0cmViYW5kc3Jhc3RlciBlbmxpZ3QgZsO2bGphbmRlOjwvZGl2Pjx1bD48bGk+QmFuZCAxID0gTHV0bmluZzwvbGk+PGxpPkJhbmQgMiA9IEludGVyY2VwdDwvbGk+PGxpPkJhbmQgMyA9IE1lZGVsa3ZhZHJhdHJvdHNmZWwgKFJNU0UpIGVsbGVyIGZlbGV0IHJ1bnQgbGluamVuIGbDtnIgYsOkc3RhIHBhc3NuaW5nPC9saT48L3VsPjxkaXY+RsO2ciBwb2x5bm9tIHRyZW5kYW5hbHlzIGJlcm9yIGFudGFsZXQgYmFuZCBpIHV0ZGF0YSBww6UgcG9seW5vbW9yZG5pbmdlbi4gQW5kcmEgb3JkbmluZ2VucyBwb2x5bm9tcGFzc25pbmcgc2thcGFyIGV0dCBmeXJhYmFuZHNyYXN0ZXIgZW5saWd0IGbDtmxqYW5kZTo8L2Rpdj48dWw+PGxpPkJhbmQgMSA9IFBvbHlub21fMjwvbGk+PGxpPkJhbmQgMiA9IFBvbHlub21fMTwvbGk+PGxpPkJhbmQgMyA9IFBvbHlub21fMDwvbGk+PGxpPkJhbmQgNCA9IE1lZGVsa3ZhZHJhdHJvdHNmZWw8L2xpPjwvdWw+PGRpdj5UcmVkamUgb3JkbmluZ2VucyBwb2x5bm9tcGFzc25pbmcgc2thcGFyIGV0dCBmZW1iYW5kc3Jhc3RlciBlbmxpZ3QgZsO2bGphbmRlOjwvZGl2Pjx1bD48bGk+QmFuZCAxID0gUG9seW5vbV8zPC9saT48bGk+QmFuZCAyID0gUG9seW5vbV8yPC9saT48bGk+QmFuZCAzID0gUG9seW5vbV8xPC9saT48bGk+QmFuZCA0ID0gUG9seW5vbV8wPC9saT48bGk+QmFuZCA1ID0gTWVkZWxrdmFkcmF0cm90c2ZlbDwvbGk+PC91bD48ZGl2PkbDtnIgaGFybW9uaXNrIHRyZW5kYW5hbHlzIGJlcm9yIGFudGFsZXQgYmFuZCBpIHV0ZGF0YSBww6UgZGVuIGhhcm1vbmlza2EgZnJla3ZlbnNlbi4gTsOkciBmcmVrdmVuc2VuIMOkciBpbnN0w6RsbGQgdGlsbCAxIMOkciB1dGRhdGEgZXR0IGZlbWJhbmRzcmFzdGVyIGVubGlndCBmw7ZsamFuZGU6PC9kaXY+PHVsPjxsaT5CYW5kIDEgPSBMdXRuaW5nPC9saT48bGk+QmFuZCAyID0gSW50ZXJjZXB0PC9saT48bGk+QmFuZCAzID0gSGFybW9uaXNrX3NpbjE8L2xpPjxsaT5CYW5kIDQgPSBIYXJtb25pc2tfY29zMTwvbGk+PGxpPkJhbmQgNSA9IE1lZGVsa3ZhZHJhdHJvdHNmZWw8L2xpPjwvdWw+PGRpdj5Ow6RyIGZyZWt2ZW5zZW4gw6RyIGluc3TDpGxsZCBww6UgMiDDpHIgdXRkYXRhIGV0dCByYXN0ZXIgcMOlIHNqdSBiYW5kIGVubGlndCBmw7ZsamFuZGU6PC9kaXY+PHVsPjxsaT5CYW5kIDEgPSBMdXRuaW5nPC9saT48bGk+QmFuZCAyID0gSW50ZXJjZXB0PC9saT48bGk+QmFuZCAzID0gSGFybW9uaXNrX3NpbjE8L2xpPjxsaT5CYW5kIDQgPSBIYXJtb25pc2tfY29zMTwvbGk+PGxpPkJhbmQgNSA9IEhhcm1vbmlza19zaW4yPC9saT48bGk+QmFuZCA2ID0gSGFybW9uaXNrX2NvczI8L2xpPjxsaT5CYW5kIDcgPSBNZWRlbGt2YWRyYXRyb3RzZmVsPC9saT48L3VsPjxkaXY+UGFyYW1ldGVybiA8c3Ryb25nPkN5a2VsbMOkbmdkPC9zdHJvbmc+IGbDtnIgaGFybW9uaXNrIHRyZW5kYW5hbHlzIGFudsOkbmRzIGbDtnIgYXR0IHZpc2EgYW50YWxldCBvY2ggbMOkbmdkZXIgZsO2ciBjeWtsZXIgc29tIGR1IHbDpG50YXIgZGlnIGF0dCBzZSBpIGRpbmEgZGF0YSB1bmRlciBlbiBkYWcgZWxsZXIgZXR0IMOlci4gT20gZHUgdGlsbCBleGVtcGVsIHbDpG50YXIgZGlnIGF0dCBkaW5hIGRhdGEgZ8OlciBpZ2Vub20gdHbDpSB2YXJpYXRpb25zY3lrbGVyIHVuZGVyIGV0dCDDpXIsIMOkciBjeWtlbGzDpG5nZGVuIDE4Miw1IGRhZ2FyIGVsbGVyIDAsNSDDpXIuIE9tIGR1IGhhciB0ZW1wZXJhdHVyZGF0YSBzb20gc2FtbGF0cyBpbiB2YXIgdHJlZGplIHRpbW1lIG9jaCBkZXQgZmlubnMgZW4gdmFyaWF0aW9uc2N5a2VsIHBlciBkYWcsIMOkciBjeWtlbGzDpG5nZGVuIGVuIGRhZy48L2Rpdj48YnI+PGRpdj5QYXJhbWV0ZXJuIDxzdHJvbmc+RnJla3ZlbnM8L3N0cm9uZz4gZsO2ciBoYXJtb25pc2sgdHJlbmRhbmFseXMgYW52w6RuZHMgZsO2ciBhdHQgYmVza3JpdmEgZGVuIGhhcm1vbmlza2EgbW9kZWxsZW4gYXR0IHBhc3NhIHRpbGwgaW5mb3JtYXRpb25lbi4gT20gZnJla3ZlbnNlbiDDpHIgaW5zdMOkbGxkIHRpbGwgMSwgYW52w6RuZHMgZW4ga29tYmluYXRpb24gYXYgbGluasOkciBvY2ggZsO2cnN0YSBvcmRuaW5nZW5zIGhhcm1vbmlza2Ega3VydmEgZsO2ciBhdHQgYW5wYXNzYSBtb2RlbGxlbi4gT20gZnJla3ZlbnNlbiDDpHIgMiwgYW52w6RuZHMgZW4ga29tYmluYXRpb24gYXYgbGluasOkcmEgb2NoIGbDtnJzdGEgb2NoIGFuZHJhIG9yZG5pbmdlbnMgaGFybW9uaXNrYSBrdXJ2b3IgZsO2ciBhdHQgYW5wYXNzYSBkYXRhLiBPbSBmcmVrdmVuc2VuIMOkciAzIGFudsOkbmRzIGVuIHl0dGVybGlnYXJlIHRyZWRqZSBvcmRuaW5nZW5zIGhhcm1vbmlzayBrdXJ2YSBmw7ZyIGF0dCBtb2RlbGxlcmEgZGF0YSwgb2NoIHPDpSB2aWRhcmUuPC9kaXY+PGJyPjxkaXY+U3RhdGlzdGlrZW4gZsO2ciBtb2RlbGxlbnMgZ29vZG5lc3Mtb2YtZml0IGthbiBnZW5lcmVyYXMgc29tIHZhbGZyaWEgdXRkYXRhLiBNZWRlbGt2YWRyYXRyb3RzZmVsZXQgKFJNU0UpLCBSLWt2YWRyYXQgb2NoIHAtdsOkcmRldCBmw7ZyIHRyZW5kZW5zIGx1dG5pbmcga2FuIGJlcsOka25hcyBvY2ggc3ltYm9saXNlcmFzLiBTeW1ib2xpc2VyYSB1dGRhdGF0cmVuZGVucyByYXN0ZXJsYWdlciBtZWQgPHN0cm9uZz5SR0I8L3N0cm9uZz4tc3ltYm9sb2dpIG9jaCBhbmdlIHN0YXRpc3Rpa2VuIHNvbSBkZSByw7ZkYSwgZ3LDtm5hIG9jaCBibMOlIGJhbmRlbi48L2Rpdj48YnI+XCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ05hbWU6IFwiTGluasOkciBzcGVrdHJhbCBvYmxhbmRuaW5nXCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ1NuaXA6IFwiVXRmw7ZyIGtsYXNzaWZpY2VyaW5nIGF2IHVuZGVycGl4bGFyIG9jaCBiZXLDpGtuYXIgYnLDpWthbmRlbGVuIGF2IG9saWthIG1hcmt0w6Rja25pbmdzdHlwZXIgZsO2ciBlbnNraWxkYSBwaXhsYXIuXCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ0Rlc2M6IFwiRnVua3Rpb25lbiBMaW5qw6RyIHNwZWt0cmFsIG9ibGFuZG5pbmcgYmVyw6RrbmFyIGJyw6VrdMOkY2tuaW5nZW4gZsO2ciBlbnNraWxkYSBwaXhsYXIgc29tIGlubmVow6VsbGVyIGZsZXJhIG1hcmt0w6Rja25pbmdzdHlwZXIuIERlbiBnZW5lcmVyYXIgZXR0IGZsZXJiYW5kc2xhZ2VyLCBkw6RyIHZhcmplIGJhbmQgbW90c3ZhcmFyIGJyw6VrYW5kZWxlbiBhdiB2YXJqZSBtYXJrdMOkY2tuaW5nc2tsYXNzLiBEdSBrYW4gdC5leC4gYW52w6RuZGEgZGVuIGbDtnIgYXR0IHV0ZsO2cmEga2xhc3NpZmljZXJpbmcgYXYgbWFya3TDpGNrbmluZyBww6UgZW4gbXVsdGlzcGVrdHJhbCBiaWxkIGbDtnIgYXR0IGlkZW50aWZpZXJhIGZvdG9zeW50ZXRpc2sgdmVnZXRhdGlvbiwgYmFyIG1hcmsgb2NoIGTDtmQgZWxsZXIgaWNrZS1mb3Rvc3ludGV0aXNrIHZlZ2V0YXRpb24uPGRpdj48YnIvPk9yZG5pbmdlbiBmw7ZyIHV0ZGF0YWZsZXJiYW5kc3Jhc3RyZXQgZsO2bGplciBvcmRuaW5nZW4gaSBkZW4gc3Bla3RyYWxhIGluZGF0YXByb2ZpbGVuLiBBbnRhbGV0IGtsYXNzZXIgZsOlciBpbnRlIMO2dmVyc3RpZ2EgYW50YWxldCBiYW5kIGkgaW5kYXRhcmFzdHJldC4gRHUga2FuIHRpbGwgZXhlbXBlbCBpbnRlIGV4dHJhaGVyYSBpbmZvcm1hdGlvbiBvbSBmbGVyIMOkbiA4IGtsYXNzZXIgZnLDpW4gZXR0IDgtYmFuZHNyYXN0ZXIuPC9kaXY+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlck5hbWU6IFwiRmxlcmRpbWVuc2lvbmVsbHQgZmlsdGVyXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uTmFtZTogXCJJbnRlcnBvbGVyYSByYXN0ZXIgZWZ0ZXIgZGltZW5zaW9uXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uU25pcDogXCJJbnRlcnBvbGVyYXIgZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlciB2aWQgYW5naXZuYSBkaW1lbnNpb25zdsOkcmRlbiBtZWQgaW50aWxsaWdnYW5kZSBzZWt0b3Jlci5cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25EZXNjOiBcIjxwPk1lZCBkZW4gaMOkciBmdW5rdGlvbmVuIGthbiBkdSBiZXLDpGtuYSBwaXhlbHbDpHJkZW4gZsO2ciBlbiBvZGVmaW5pZXJhZCBkaW1lbnNpb25zc2VrdG9yIGkgZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3Rlci4gT20gZHUgdGlsbCBleGVtcGVsIGhhciBldHQgZGF0YXNldCBzb20gaW5uZWjDpWxsZXIgaGF2c3RlbXBlcmF0dXIgdmlkIHl0bml2w6Ugb2NoIHZpZCAxMDAgbWV0ZXIgdW5kZXIgaGF2c25pdsOlbiBvY2ggZHUgdmlsbCBiZXLDpGtuYSB0ZW1wZXJhdHVyZW4gdmlkIDUwIG1ldGVyIHVuZGVyIGhhdnNuaXbDpW4sIGthbiBkdSBhbnbDpG5kYSBkZW4gaMOkciBmdW5rdGlvbmVuIGbDtnIgYXR0IGbDpSBlbiB1cHBza2F0dG5pbmcgcMOlIGRldCBkanVwZXQgbWVkIGRpbWVuc2lvbnNkZWZpbml0aW9uZW4gRWZ0ZXIgdsOkcmRlbi48L3A+PHA+RHUga2FuIMOkdmVuIG5lZHNhbXBsYSBldHQgbcOlbmF0bGlndCBkYXRhc2V0IHRpbGwgZXR0IGRhZ2xpZ3QgZGF0YXNldCBtZWQgZGltZW5zaW9uc2RlZmluaXRpb25lbiBFZnRlciBpbnRlcnZhbGwgb2NoIGFuZ2Ugc3RlZ3BhcmFtZXRlcnbDpHJkZXQgc29tIDEgb2NoIGVuaGV0c3BhcmFtZXRlcnbDpHJkZXQgc29tIGRhZ2FyLjwvcD48cD5BbnbDpG5kIGRpbWVuc2lvbnNkZWZpbml0aW9uZW4gRWZ0ZXIgbcOlbHJhc3RlciBmw7ZyIGF0dCBiZXLDpGtuYSB2w6RyZGV0IGbDtnIgbcOlbHJhc3RyZXQuPC9wPlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJTbmlwOiBcIlNrYXBhciBldHQgcmFzdGVybGFnZXIgZnLDpW4gZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlcmRhdGFzZXQgZWxsZXIgZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlcmxhZ2VyIGdlbm9tIGF0dCBkZWxhIHVwcCBkYXRhIGVubGlndCBkZWZpbmllcmFkZSB2YXJpYWJsZXIgb2NoIGRpbWVuc2lvbmVyLlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJEZXNjOiBcIkRldCBmbGVyZGltZW5zaW9uZWxsYSBmaWx0cmV0IHNrYXBhciBldHQgZmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVybGFnZXIgZ2Vub20gYXR0IGZpbHRyZXJhIG9jaCBleHRyYWhlcmEgZW4gZGVsbcOkbmdkIHZhcmlhYmxlciBmcsOlbiBldHQgZmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVyLiBUaWxsIGV4ZW1wZWwga2FuIGR1IGhhIGV0dCBmbGVyZGltZW5zaW9uZWxsdCBkYXRhc2V0IHNvbSBpbm5laMOlbGxlciAzMCDDpXJzIGRhdGEgb20gbcOlbmFkc25lZGVyYsO2cmQsIG9jaCBkdSB2aWxsIGJhcmEgZXh0cmFoZXJhIGRhdGEgZsO2ciB2YXJqZSBqYW51YXJpIGbDtnIgYXR0IHNlIGh1ciBuZWRlcmLDtnJkZW4gaGFyIGbDtnLDpG5kcmF0cyBmw7ZyIGRlbiBtw6VuYWRlbi48ZGl2Pjxici8+QW52w6RuZCBwYXJhbWV0ZXJuIERpbWVuc2lvbnNkZWZpbml0aW9uIGbDtnIgYXR0IGRlbGEgdXBwIGRpbWVuc2lvbmVyIGVmdGVyIGV0dCBpbnRlcnZhbGwsIGV0dCB2w6RyZGUgZWxsZXIgZXR0IGludGVydmFsbCBhdiB2w6RyZGVuLiBPbSBkdSB0LmV4LiBoYXIgMTAgw6VycyBkYXRhIMO2dmVyIHNhbHRoYWx0IGbDtnIgaGF2ZXQsIGluc2FtbGFkZSB2YXJqZSBtw6VuYWQgb2NoIHDDpSB2YXJhbm5hbiBtZXRlcnMgZGp1cCB1cHAgdGlsbCA1MDAgbWV0ZXIsIGthbiBkdSBhbnbDpG5kYSBkZSBvbGlrYSBhbHRlcm5hdGl2ZW4gZsO2ciBkaW1lbnNpb25zZGVmaW5pdGlvbiBmw7ZyIGbDtmxqYW5kZSBzY2VuYXJpb24uIFNjZW5hcmlvIDE6IEV4dHJhaGVyYSBzYWx0aGFsdHNkYXRhIGbDtnIgamFudWFyaSBtw6VuYWQgw7Z2ZXIgMTAtw6Vyc3BlcmlvZGVuLiBWw6RsaiBFZnRlciB2w6RyZGUsIHN0w6RsbCBpbiBEaW1lbnNpb24gdGlsbCBTdGRUaWQgb2NoIHN0w6RsbCBpbiBWw6RyZGVuIHRpbGwgamFudWFyaS4gU2NlbmFyaW8gMjogRGVsYSB1cHAgc2FsdGhhbHRzZGF0YSDDtnZlciBldHQgZGp1cGludGVydmFsbCBmcsOlbiAwIHRpbGwgMTUwIG1ldGVyLiBWw6RsaiBFZnRlciBpbnRlcnZhbGwsIHN0w6RsbCBpbiBEaW1lbnNpb24gdGlsbCBTdGRaIG9jaCBzdMOkbGwgaW4gTWluaW1pdsOkcmRlIHRpbGwgLTE1MCBvY2ggTWF4aW11bXbDpHJkZSB0aWxsIDAuIFNjZW5hcmlvIDM6IEV4dHJhaGVyYSBzYWx0aGFsdHNkYXRhIGbDtnIgZGUgZsO2cnN0YSAxMCBkYWdhcm5hIGkgamFudWFyaSDDtnZlciBlbiAxMC3DpXJzcGVyaW9kLiBWw6RsaiBFZnRlciBpdGVyYXRpb24sIHN0w6RsbCBpbiBEaW1lbnNpb24gdGlsbCBTdGRUaWQsIHN0w6RsbCBpbiBCw7ZyamFuIGF2IGbDtnJzdGEgaXRlcmF0aW9uZW4gb2NoIFNsdXRldCBhdiBmw7Zyc3RhIGl0ZXJhdGlvbmVuIHRpbGwgbW90c3ZhcmFuZGUgYsO2cmphbiBvY2ggc2x1dCBhdiBpdGVyYXRpb25zcGVyaW9kZW4sIHN0w6RsbCBpbiBTdGVnIHRpbGwgMSBvY2ggc3TDpGxsIGluIEVuaGV0IHRpbGwgw4VyLjwvZGl2PlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxSYXN0ZXJOYW1lOiBcIkZsZXJkaW1lbnNpb25lbGx0IHJhc3RlclwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxSYXN0ZXJTbmlwOiBcIkzDpGdnZXIgdGlsbCBmbGVyZGltZW5zaW9uZWxsYSBkYXRhIHDDpSBlbiBrYXJ0YSBzb20gZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlcmxhZ2VyLlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxSYXN0ZXJEZXNjOiBcIkZ1bmt0aW9uZW4gRmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVyIGzDpGdnZXIgdGlsbCBmbGVyZGltZW5zaW9uZWxsYSBkYXRhIHDDpSBlbiBrYXJ0YSBzb20gZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlcmxhZ2VyLiBEZW4gaMOkciBmdW5rdGlvbmVuIMOkciBhbnbDpG5kYmFyIG7DpHIgZHUgdXRmw7ZyIHJhc3RlcmFuYWx5c2FyYmV0c2Zsw7ZkZW4gbWVkIGVuIGZ1bmt0aW9uc2tlZGphLjxkaXY+PGJyLz5GbGVyZGltZW5zaW9uZWxsYSByYXN0ZXJkYXRhc2V0IHNvbSBzdMO2ZHMgaW5uZWZhdHRhciBuZXRDREYsIEdSSUIsIEhERiBvY2ggRXNyaXMgQ1JGLiBGbGVyZGltZW5zaW9uZWxsYSBtb3NhaWtkYXRhc2V0IHN0w7ZkcyBvY2tzw6UuPC9kaXY+XCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3Rlck5hbWU6IFwiT3B0aW1hbCB2w6RnIHNvbSByYXN0ZXJcIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyU25pcDogXCJCZXLDpGtuYXIgZGVuIGJpbGxpZ2FzdGUgcnV0dGVuIGZyw6VuIGVuIGvDpGxsYSB0aWxsIGVuIGRlc3RpbmF0aW9uLlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJEZXNjOiBcIkRlbiBow6RyIGdsb2JhbGEgZnVua3Rpb25lbiBwcm9kdWNlcmFyIGV0dCB1dGRhdGFyYXN0ZXIgc29tIHJlZ2lzdHJlcmFyIGRlbiBvcHRpbWFsYSBydXR0ZW4gZWxsZXIgcnV0dGVyIGZyw6VuIHZhbGRhIHBsYXRzZXIgdGlsbCBkZW4gbsOkcm1hc3RlIHVyc3BydW5nc2NlbGxlbiBzb20gZGVmaW5pZXJhdHMgaW5vbSBkZW4gYWNrdW11bGVyYWRlIGtvc3RuYWRzeXRhbiwgbWVkIGF2c2VlbmRlIHDDpSBrb3N0bmFkIGbDtnIgYXZzdMOlbmQuPGRpdj48YnIvPkVuIGVsbGVyIGZsZXJhIGF2IGZ1bmt0aW9uZXJuYSBmw7ZyIHbDpGdkYSBrb3N0bmFkZXIgKEF2c3TDpW5kc2Fja3VtdWxlcmluZyBlbGxlciBBdnN0w6VuZHNhbGxva2VyaW5nKSBtw6VzdGUgaSBhbGxtw6RuaGV0IGvDtnJhcyBpbm5hbiBmdW5rdGlvbmVuIE9wdGltYWwgdsOkZyBzb20gcmFzdGVyIGvDtnJzIGbDtnIgYXR0IHNrYXBhIGluZGF0YXJhc3RyZW4gZsO2ciBhdnN0w6VuZHNhY2t1bXVsZXJpbmcgb2NoIHRpbGxiYWthcmlrdG5pbmcuIERlIMOkciBvYmxpZ2F0b3Jpc2thIGluZGF0YXJhc3RlcmxhZ2VyIGbDtnIgZnVua3Rpb25lbiBPcHRpbWFsIHbDpGcuIFbDpHJkZXQgZsO2ciBkZW4gdXRtYXRhZGUgb3B0aW1hbGEgdsOkZ2VuIG1vdHN2YXJhciBhbnRhbGV0IHbDpGdhciBww6UgZW4gZ2l2ZW4gcGxhdHMuIEkgbcOlbmdhIGZhbGwgZsO2bGplciB2w6RnYXIgc2FtbWEgcnV0dCwgbMOkbW5hciBlbiBrw6RsbGEgb2NoIGRlbGFyIHNpZyBzZWRhbiBmw7ZyIGF0dCBnw6UgdGlsbCBvbGlrYSBkZXN0aW5hdGlvbmVyLiBUaWxsIGV4ZW1wZWwgdmlzYXIgdsOkcmRldCBldHQgYXR0IGRldCBiYXJhIGZpbm5zIGVuIG9wdGltYWwgdsOkZyBww6UgZW4gZ2l2ZW4gcGxhdHMsIG1lZGFuIHbDpHJkZXQgZmVtIGJldHlkZXIgYXR0IGRldCBww6UgZGVuIHBsYXRzZW4gZmlubnMgZmVtIG9wdGltYWxhIHbDpGdhciBzb20gZ8OlciBnZW5vbSBkZW4gY2VsbGVuIGkgdW5kZXJzw7ZrbmluZ3NvbXLDpWRldC48ZGl2Pjxici8+SW5kZXN0aW5hdGlvbnNkYXRhIG3DpXN0ZSB2YXJhIGV0dCByYXN0ZXJsYWdlci4gVXBwc8OkdHRuaW5nZW4gZGVzdGluYXRpb25zY2VsbGVyIGJlc3TDpXIgYXYgYWxsYSBjZWxsZXIgaSBpbmRhdGFyYXN0cmV0IHNvbSBoYXIgZ2lsdGlnYSB2w6RyZGVuLiBDZWxsZXIgc29tIGhhciBOb0RhdGEtdsOkcmRlbiBpbmfDpXIgaW50ZSBpIHNldGV0LiBWw6RyZGV0IG5vbGwgc2VzIHNvbSBldHQgbGVnaXRpbXQgbcOlbC4gRXR0IGRlc3RpbmF0aW9uc3Jhc3RlciBrYW4gc2thcGFzIG1lZCBleHRyYWhlcmluZ3N2ZXJrdHlnZW4uIE9tIGR1IGhhciBkZXN0aW5hdGlvbnMtIGVsbGVyIGvDpGxsZ2Vvb2JqZWt0LCBrYW4gZHUga29udmVydGVyYSBkZW0gdGlsbCByYXN0ZXIgbWVkIGZ1bmt0aW9uZW4gUmFzdHJlcmEgZ2Vvb2JqZWt0LiBBbnbDpG5kIHJhc3RyZXQgYXZzdMOlbmRzYWNrdW11bGVyaW5nIGVsbGVyIHRpbGxiYWthcmlrdG5pbmcgc29tIHJhc3RlcmluZGF0YSBmw7ZyIHJhc3RyZXJpbmdzZnVua3Rpb25lbi4gRGV0dGEgc8Oka2Vyc3TDpGxsZXIgYXR0IGdlb29iamVrdGV0IHJhc3RyZXJhcyBtZWQgc2FtbWEgY2VsbHN0b3JsZWssIHV0YnJlZG5pbmcgb2NoIGdlb2dyYWZpc2thIHJlZmVyZW5zIHNvbSBkZSBhbmRyYSByYXN0cmVuIHNvbSBnw6VyIGluIGkgZnVua3Rpb25lbiBPcHRpbWFsIHbDpGcgc29tIHJhc3Rlci4gRnVua3Rpb25lbiBPcHRpbWFsIHbDpGcgc29tIHJhc3RlciBrYW4gb2Nrc8OlIGFudsOkbmRhcyBmw7ZyIGF0dCBow6RybGVkYSB2w6RnZW4gbWVkIGzDpGdzdCBtb3RzdMOlbmQgbmVkZsO2ciBlbiBkaWdpdGFsIGjDtmpkbW9kZWxsLiBBbnbDpG5kIGkgc8OlIGZhbGwgZGVuIGRpZ2l0YWxhIGjDtmpkbW9kZWxsZW4gZsO2ciBpbmRhdGFhdnN0w6VuZHNhY2t1bXVsZXJpbmdzcmFzdHJldCBvY2ggdXRkYXRhIGZyw6VuIGZ1bmt0aW9uZW4gRmzDtmRlc3Jpa3RuaW5nIGbDtnIgdGlsbGJha2FyaWt0bmluZ3NyYXN0cmV0LjwvZGl2PlwiLFxuXHRcdHRyZW5kTmFtZTogXCJGw7ZydXRzw6RnIG1lZCB0cmVuZFwiLFxuXHRcdHRyZW5kU25pcDogXCJCZXLDpGtuYXIgZXR0IHByb2dub3N0aXNlcmF0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlcmxhZ2VyIG1lZCB1dGRhdGF0cmVuZHJhc3RyZXQgZnLDpW4gZnVua3Rpb25lbiBHZW5lcmVyYSB0cmVuZCBlbGxlciBnZW9iZWFyYmV0bmluZ3N2ZXJrdHlnZXQgR2VuZXJlcmEgdHJlbmRyYXN0ZXIuXCIsXG5cdFx0dHJlbmREZXNjOiBcIkZ1bmt0aW9uZW4gRsO2cnV0c8OkZyBtZWQgdHJlbmQgYmVyw6RrbmFyIGV0dCBwcm9nbm9zdGlzZXJhdCBmbGVyZGltZW5zaW9uZWxsdCByYXN0ZXJsYWdlciBtZWQgdXRkYXRhdHJlbmRyYXN0cmV0IGZyw6VuIGZ1bmt0aW9uZW4gR2VuZXJlcmEgdHJlbmQgZWxsZXIgZ2VvYmVhcmJldG5pbmdzdmVya3R5Z2V0IEdlbmVyZXJhIHRyZW5kcmFzdGVyLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25OYW1lOiBcIkJlYXJiZXRhIHJhc3RlcnNhbWxpbmdcIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uU25pcDogXCJCZWFyYmV0YXIgdmFyamUgc2VrdG9yIGkgZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlciBlbGxlciB2YXJqZSBvYmpla3QgaSBldHQgbW9zYWlrcmFzdGVyLiBGdW5rdGlvbmVuIGthbiBvY2tzw6UgYWdncmVnZXJhIGZsZXJhIHNla3RvcmVyIHRpbGwgZW4gZW5kYSBzZWt0b3IuXCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvbkRlc2M6IFwiRnVua3Rpb25lbiBCZWFyYmV0YSByYXN0ZXJzYW1saW5nIGJlYXJiZXRhciB2YXJqZSBzZWt0b3IgaSBldHQgZmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVyIGVsbGVyIHZhcmplIG9iamVrdCBpIGV0dCBtb3NhaWtyYXN0ZXIuIEZ1bmt0aW9uZW4ga2FuIG9ja3PDpSBhZ2dyZWdlcmEgZmxlcmEgc2VrdG9yZXIgdGlsbCBlbiBlbmRhIHNla3Rvci48ZGl2Pjxici8+RGVuIGjDpHIgZnVua3Rpb25lbiBiZWFyYmV0YXIgdmFyamUgc2VrdG9yIGkgZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlciBlbGxlciBtb3NhaWtyYXN0ZXIgbWVkIGVuIHJhc3RlcmZ1bmt0aW9uc21hbGwuIEZ1bmt0aW9uZW4gaGFyIHN0w7ZkIGbDtnIgZsO2bGphbmRlIGFsdGVybmF0aXY6IDEuIEFuZ2UgZW4gcmFzdGVyZnVua3Rpb25zbWFsbCBmw7ZyIE9iamVrdGZ1bmt0aW9uLiBEdSBoYXIgdGlsbCBleGVtcGVsIGV0dCBtb3NhaWtkYXRhc2V0IHNvbSBpbm5laMOlbGxlciAyMCDDpXJzIExhbmRzYXQtYmlsZGVyIG9jaCBkdSB2aWxsIGJlcsOka25hIE5EVkkgZsO2ciB2YXJqZSBzY2VuIGkgdGlkc3Nlcmllbi4gRsO2ciBPYmpla3RmdW5rdGlvbiBhbmdlciBkdSBlbiByYXN0ZXJmdW5rdGlvbnNtYWxsIHNvbSBpbm5laMOlbGxlciBORFZJLXJhc3RlcmZ1bmt0aW9uZW4uIDIuIEFuZ2UgZW4gcmFzdGVyZnVua3Rpb25zbWFsbCBmw7ZyIEFnZ3JlZ2VyaW5nc2Z1bmt0aW9uZW4uIER1IGhhciB0aWxsIGV4ZW1wZWwgZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlciBzb20gaW5uZWjDpWxsZXIgMTAgw6VycyBkYWdsaWdhIHRlbXBlcmF0dXJkYXRhIG9jaCBkdSB2aWxsIGJlcsOka25hIGRlbiBtYXhpbWFsYSB0ZW1wZXJhdHVyZW4gZsO2ciB2YXJqZSDDpXIuIEkgQWdncmVnZXJpbmdzZnVua3Rpb25lbiBhbmdlciBkdSBlbiByYXN0ZXJmdW5rdGlvbnNtYWxsIHNvbSBpbm5laMOlbGxlciBmdW5rdGlvbmVuIENlbGxzdGF0aXN0aWssIG1lZCBvcGVyYXRpb25lbiBpbnN0w6RsbGQgcMOlIE1heGltdW0uIFVuZGVyIEFnZ3JlZ2VyaW5nc2RlZmluaXRpb24gc3TDpGxsZXIgZHUgaW4gRGltZW5zaW9uIHRpbGwgU3RkVGlkLCBzdMOkbGxlciBpbiBUeXAgdGlsbCBJbnRlcnZhbGxueWNrZWxvcmQgb2NoIHN0w6RsbGVyIGluIE55Y2tlbG9yZHNpbnRlcnZhbGwgdGlsbCDDhXJsaWdlbi4gT2JzZXJ2ZXJhIGF0dCBvbSBpbmRhdGFtb3NhaWtkYXRhc2V0ZXQgaW50ZSDDpHIgZmxlcmRpbWVuc2lvbmVsbHQsIHRhciBhZ2dyZWdlcmluZ3NmdW5rdGlvbmVuIGludGUgaMOkbnN5biB0aWxsIGFnZ3JlZ2VyaW5nc2RlZmluaXRpb25lbi4gQWdncmVnZXJpbmdzZnVua3Rpb25lbiBhZ2dyZWdlcmFyIGFsbGEgb2JqZWt0IGVsbGVyIHZhcmplIGdydXBwIHRpbGwgZW4gb20gZGUgw6RyIGRlZmluaWVyYWRlIGkgYWdncmVnZXJpbmdzZnVua3Rpb25zbWFsbGVuLiBNZXIgaW5mb3JtYXRpb24gb20gYXR0IGFudsOkbmRhIGdydXBwZXIgaSBldHQgbW9zYWlrZGF0YXNldCBmaW5ucyBpIEFudsOkbmRhIG1vc2Fpa2RhdGFzZXRvYmpla3QgaSBSYXN0ZXJmdW5rdGlvbnNtYWxsYXIuIDMuIEFuZ2UgZW4gcmFzdGVyZnVua3Rpb25zbWFsbCBmw7ZyIEJlYXJiZXRuaW5nc2Z1bmt0aW9uZW4uIEZ1bmt0aW9uZW4gZWxsZXIgZnVua3Rpb25za2VkamFuIGkgZGVuIGjDpHIgbWFsbGVuIGFudsOkbmRzIGbDtnIgYXR0IHZpc2EgZGV0IG55YSBiZWFyYmV0YWRlIHJhc3RyZXQuIEFuZ2UgdGlsbCBleGVtcGVsIGVuIHJhc3RlcmZ1bmt0aW9uc21hbGwgc29tIGlubmVow6VsbGVyIGZ1bmt0aW9uZW4gRsOkcmdrYXJ0YSBmw7ZyIGF0dCDDpG5kcmEgaHVyIGRldCBiZWFyYmV0YWRlIHJhc3RlcmxhZ3JldCBza2EgdmlzYXMuIE9ic2VydmVyYSBhdHQgb20gaW5kYXRhIMOkciBldHQgZmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVyLCB0aWxsw6RtcGFzIGJlYXJiZXRuaW5nc2Z1bmt0aW9uZW4gcMOlIGRlbiBha3R1ZWxsYSB2aXNuaW5nc3Nla3Rvcm4uIE9tIGluZGF0YSDDpHIgZXR0IG1vc2Fpa2xhZ2VyIGVsbGVyIG1vc2Fpa2RhdGFzZXQsIHRpbGzDpG1wYXMgYmVhcmJldG5pbmdzZnVua3Rpb25lbiBww6UgbW9zYWlrcmFzdHJldCBtZWQgbWV0b2RlbiBGw7Zyc3QgZsO2ciBhdHQgbMO2c2Egw7Z2ZXJsYXBwbmluZ2FyLiAzLiBBbmdlIG1hbGxhciBmw7ZyIG7DpWdvbiBrb21iaW5hdGlvbiBhdiBkZSB0cmUgZnVua3Rpb25lcm5hLiBEdSBoYXIgdGlsbCBleGVtcGVsIGV0dCBtb3NhaWtkYXRhc2V0IHNvbSBpbm5laMOlbGxlciBMYW5kc2F0LWJpbGRlciBtZWQgdGlkc3NlcmllciBvY2ggZHUgdmlsbCBnZW5lcmVyYSBlbiBzYW1tYW5zYXR0IGJpbGQgYXYgbWF4aW1hbCBORFZJLiBGw7ZyIE9iamVrdGZ1bmt0aW9uIGFuZ2VyIGR1IGVuIHJhc3RlcmZ1bmt0aW9uc21hbGwgc29tIGlubmVow6VsbGVyIE5EVkktcmFzdGVyZnVua3Rpb25lbi4gRsO2ciBBZ2dyZWdlcmluZ3NmdW5rdGlvbmVuIGFuZ2VyIGR1IGVuIHJhc3RlcmZ1bmt0aW9uc21hbGwgc29tIGlubmVow6VsbGVyIGZ1bmt0aW9uZW4gQ2VsbHN0YXRpc3RpaywgbWVkIG9wZXJhdGlvbmVuIGluc3TDpGxsZCBww6UgTWF4aW11bS4gRsO2ciBCZWFyYmV0bmluZ3NmdW5rdGlvbiBhbmdlciBkdSBlbiByYXN0ZXJmdW5rdGlvbnNtYWxsIHNvbSBpbm5laMOlbGxlciBmdW5rdGlvbmVuIEbDpHJna2FydGEuIE9ic2VydmVyYSBhdHQgb3JkbmluZ2VuIGbDtnIgZnVua3Rpb25zYmVhcmJldG5pbmcgZsO2bGplciBpbmRhdGFwYXJhbWV0cmFybmFzIG9yZG5pbmcuIFRpbGwgZXhlbXBlbCBiZWFyYmV0YXMgT2JqZWt0ZnVua3Rpb25lbiBmw7Zyc3QuPC9kaXY+XCIsXG5cdFx0cmFuZG9tTmFtZTogXCJTbHVtcG3DpHNzaWdcIixcblx0XHRyYW5kb21TbmlwOiBcIlNrYXBhciBldHQgcmFzdGVyIG1lZCBzbHVtcG3DpHNzaWdhIHBpeGVsdsOkcmRlbiBzb20gaMOkbXRhdHMgZnLDpW4gZW4gcHNldWRvc2x1bXBtw6Rzc2lnIGRpc3RyaWJ1dGlvbi4gRGV0IGZpbm5zIHN0w7ZkIGbDtnIgZmxlcmEgZGlzdHJpYnV0aW9uZXIgb2NoIHNsdW1wdGFsZ2VuZXJhdG9yZXIuXCIsXG5cdFx0cmFuZG9tRGVzYzogXCJGdW5rdGlvbmVuIFNsdW1wbcOkc3NpZyBza2FwYXIgZXR0IHJhc3RlciBtZWQgc2x1bXBtw6Rzc2lnYSBwaXhlbHbDpHJkZW4gc29tIGthbiBhbnbDpG5kYXMgaSByYXN0ZXJmdW5rdGlvbnNtYWxsYXIgZWxsZXIgbW9zYWlrZGF0YXNldC48ZGl2Pjxici8+w4R2ZW4gb20gbcOlbmdhIGZ1bmt0aW9uZXIgZnVuZ2VyYXIgcMOlIGV0dCBlbGxlciBmbGVyYSBpbmRhdGFyYXN0ZXIsIGtyw6R2ZXIgZnVua3Rpb25lbiBTbHVtcG3DpHNzaWcgaW5nZXQgaW5kYXRhcmFzdGVyLiBEZXQgaW5uZWLDpHIgYXR0IGRlbiBiZXRlciBzaWcgbWVyIHNvbSBldHQgcmFzdGVyZGF0YXNldCDDpG4gZW4gZnVua3Rpb24sIHPDpSBzw6Ryc2tpbGQgZsO2cnNpa3RpZ2hldCBrcsOkdnMgbsOkciBkdSBsw6RnZ2VyIHRpbGwgZGVuIGkgZWxsZXIgdGFyIGJvcnQgZGVuIGZyw6VuIGZ1bmt0aW9uc2tlZGphbi48L2Rpdj5cIixcblx0XHRzaHJpbmtOYW1lOiBcIktyeW1wXCIsXG5cdFx0c2hyaW5rU25pcDogXCJLcnltcGVyIGRlIHZhbGRhIHpvbmVybmEgbWVkIGV0dCBhbmdpdmV0IGFudGFsIGNlbGxlciBnZW5vbSBhdHQgZXJzw6R0dGEgZGVtIG1lZCB2w6RyZGV0IGF2IGRlbiBtZXN0IGZyZWt2ZW50YSBjZWxsZW4gaSBkZXNzIG7DpHJvbXLDpWRlLlwiLFxuXHRcdHNocmlua0Rlc2M6IFwiTWVkIGRlbiBnbG9iYWxhIEtyeW1wLWZ1bmt0aW9uZW4ga2FuIGR1IGdlbmVyYWxpc2VyYSBlbGxlciBmw7ZyZW5rbGEgcmFzdGVyIGdlbm9tIGF0dCBnw7ZyYSB2aXNzYSB6b25lciBtaW5kcmUuIER1IGthbiBvY2tzw6Ugc3R5cmEgbcOkbmdkZW4gZ2VuZXJhbGlzZXJpbmcgc29tIHNrYSBmw7ZyZWtvbW1hLjxkaXY+PGJyLz5EZSB6b25lciBkdSB2w6RsamVyIGtyeW1wZXIsIGVsbGVyIHJlZHVjZXJhcyBpIHN0b3JsZWssIGdlbm9tIGF0dCBjZWxsZXIgZnLDpW4gb21naXZhbmRlIHpvbmVyIGV4cGFuZGVyYXIgaW4gaSBkZW0uIEtvbmNlcHR1ZWxsdCBrYW4gZGUgdmFsZGEgem9udsOkcmRlbmEgc2VzIHNvbSBmw7ZyZ3J1bmRzem9uZXIsIG1lZGFuIGRlIGFuZHJhIHbDpHJkZW5hIGbDtnJibGlyIGJha2dydW5kc3pvbmVyLiBDZWxsZXJuYSBpIGbDtnJncnVuZHN6b25lcm5hIGthbiBlcnPDpHR0YXMgYXYgY2VsbGVyIGkgYmFrZ3J1bmRzem9uZXJuYS4gVHVubmEgw7ZhciBpbnV0aSBlbiB6b24sIHNvbSBrYW4gc2VzIHNvbSBhdHQgZGUgZGVsYXIgZ3LDpG5zZXIgbWVkIHpvbmVuLCBrYW4gb2Nrc8OlIGVyc8OkdHRhcy48ZGl2Pjxici8+TcOkbmdkZW4gZ2VuZXJhbGlzZXJpbmcga2FuIHN0eXJhcyBtZWQgcGFyYW1ldGVybiBBbnRhbCBjZWxsZXIuIFNvbSBzdGFuZGFyZCDDpHIgZGV0dGEgdsOkcmRlIDEsIHZpbGtldCBpbm5lYsOkciBhdHQgZGUgdmFsZGEgem9uZXJuYSBrcnltcGVyIG1lZCBkZW4gbcOkbmdkIHNvbSBtb3RzdmFyYXIgZW4gY2VsbHMgc3Rvcmxlay4gRsO2ciBhdHQgw7ZrYSBncmFkZW4gYXYgZ2VuZXJhbGlzZXJpbmcga2FuIGR1IGFuZ2UgZXR0IHN0w7ZycmUgdsOkcmRlIGbDtnIgZGVuIGjDpHIgcGFyYW1ldGVybi4gS29uY2VwdHVlbGx0IMOkciBkZXQgc29tIGF0dCBrw7ZyYSB2ZXJrdHlnZXQgbGlrYSBtw6VuZ2EgZ8OlbmdlciBzb20gZGV0IGFuZ2l2bmEgYW50YWxldCwgZMOkciByZXN1bHRhdGVuIGF2IGbDtnJlZ8OlZW5kZSBrw7ZybmluZyDDpHIgaW5kYXRhIHRpbGwgbsOkc3RhIGl0ZXJhdGlvbi48L2Rpdj5cIixcblx0XHR0cmVuZFRvUkdCTmFtZTogXCJUcmVuZCB0aWxsIFJHQlwiLFxuXHRcdHRyZW5kVG9SR0JTbmlwOiBcIktvbnZlcnRlcmFyIGV0dCB0cmVuZHJhc3RlciB0aWxsIGV0dCByYXN0ZXIgbWVkIHRyZSBiYW5kIChyw7Z0dCwgZ3LDtm50IG9jaCBibMOldHQpLlwiLFxuXHRcdHRyZW5kVG9SR0JEZXNjOiBcIkZ1bmt0aW9uZW4gVHJlbmQgdGlsbCBSR0Iga29udmVydGVyYXIgZXR0IHRyZW5kcmFzdGVyIHRpbGwgZXR0IHJhc3RlciBtZWQgdHJlIGJhbmQgKHLDtnR0LCBncsO2bnQgb2NoIGJsw6V0dCkuIFRyZW5kcmFzdHJldCBnZW5lcmVyYXMgZnLDpW4gcmFzdGVyZnVua3Rpb25lbiBHZW5lcmVyYSB0cmVuZCBlbGxlciBDQ0RDLWFuYWx5cy48ZGl2Pjxici8+RGVuIGjDpHIgZnVua3Rpb25lbiDDpHIgYW52w6RuZGJhciBmw7ZyIGF0dCB2aXN1YWxpc2VyYSBtb2RlbGxrb2VmZmljaWVudGRhdGEgZnLDpW4gZnVua3Rpb25lbiBHZW5lcmVyYSB0cmVuZCBlbGxlciBmdW5rdGlvbmVuIENDREMtYW5hbHlzLiBCw6VkYSBmdW5rdGlvbmVybmEgdXBwc2thdHRhciB0cmVuZGVyIGkgw6RuZHJhZGUgcGl4ZWx2w6RyZGVuLCBtZW4gcmVzdWx0YXRlbiBhdiBmdW5rdGlvbmVybmEgw6RyIHN2w6VyYSBhdHQgdG9sa2EgZGlyZWt0LjxkaXY+PGJyLz5Tb20gbcOlbmdhIHJhc3RlcmZ1bmt0aW9uZXIga2FuIGR1IGJlaMO2dmEgYW52w6RuZGEgZHluYW1pc2sgaW50ZXJ2YWxsanVzdGVyaW5nIGbDtnIgYXR0IHZpc2EgcmVzdWx0YXRlbiBmcsOlbiBmdW5rdGlvbmVuLjwvZGl2PlwiLFxuXHRcdGxhbmRUcmVuZHJOYW1lOiBcIkxhbmRUcmVuZHItYW5hbHlzXCIsXG5cdFx0bGFuZFRyZW5kclNuaXA6IFwiVXR2w6RyZGVyYXIgw6RuZHJpbmdhciBpIHBpeGVsdsOkcmRlbiDDtnZlciB0aWQgbWVkIExhbmRzYXQtYmFzZXJhZCB1cHB0w6Rja3QgYXYgdHJlbmRlciBpbm9tIG1ldG9kZXIgZsO2ciBzdMO2cm5pbmcgb2NoIMOldGVyaMOkbXRuaW5nIChMYW5kVHJlbmRyKSBvY2ggZ2VuZXJlcmFyIGV0dCDDpG5kcmluZ3NhbmFseXNyYXN0ZXIgc29tIGlubmVow6VsbGVyIG1vZGVsbHJlc3VsdGF0ZW4uXCIsXG5cdFx0bGFuZFRyZW5kckRlc2M6IFwiRGVubmEgcmFzdGVyZnVua3Rpb24ga2FuIGJhcmEgYW52w6RuZGFzIHNvbSBpbmRhdGEgdGlsbCByYXN0ZXJmdW5rdGlvbmVuIElkZW50aWZpZXJhIMOkbmRyaW5nIG1lZCBoasOkbHAgYXYgw6RuZHJpbmdzYW5hbHlzLiBGw7ZyIGF0dCBza2FwYSByYXN0ZXJ1dGRhdGEgbcOlc3RlIGR1IGtvcHBsYSBMYW5kVHJlbmRyLWFuYWx5c2Z1bmt0aW9uZW4gdGlsbCBmdW5rdGlvbmVuIElkZW50aWZpZXJhIMOkbmRyaW5nIG1lZCBoasOkbHAgYXYgw6RuZHJpbmdzYW5hbHlzIGkgZW4gcmFzdGVyZnVua3Rpb25zbWFsbCBvY2ggYW52w6RuZGEgbWFsbGVuIHNvbSBpbmRhdGEgaSBnZW9iZWFyYmV0bmluZ3N2ZXJrdHlnZXQgR2VuZXJlcmEgcmFzdGVyIGZyw6VuIHJhc3RlcmZ1bmt0aW9uLiBSZXN1bHRhdGV0IMOkciBldHQgcmFzdGVyIHNvbSBpbm5laMOlbGxlciBpbmZvcm1hdGlvbiBvbSB0aWRwdW5rdGVuIGTDpSBwaXhlbHbDpHJkZW5hIMOkbmRyYWRlcy48ZGl2Pjxicj5TeWZ0ZXQgbWVkIGRlbm5hIHJhc3RlcmZ1bmt0aW9uIMOkciBhdHQgZXh0cmFoZXJhIMOkbmRyaW5nYXJuYSBpIGV0dCBvYnNlcnZlcmF0IGdlb29iamVrdCwgc8OlIGlkZWFsaXNrYSBmbGVyZGltZW5zaW9uZWxsYSBpbmRhdGEgYsO2ciBzYW1sYSBpbiBlbiBrb25zZWt2ZW50IG9ic2VydmF0aW9uIMO2dmVyIHRpZCBvY2ggYsO2ciBpbnRlIGlua2x1ZGVyYSBhdG1vc2bDpHJpc2sgaW50ZXJmZXJlbnMgZWxsZXIgc2Vuc29yaW50ZXJmZXJlbnMsIG1vbG4gZWxsZXIgbW9sbnNrdWdnYS4gQsOkc3RhIHByYXhpcyDDpHIgYXR0IGFudsOkbmRhIGRhdGEgc29tIGhhciBub3JtYWxpc2VyYXRzIG9jaCBrYW4gbWFza2VyYXMgbWVkIGV0dCBRQS1iYW5kLCB0aWxsIGV4ZW1wZWwgTGFuZHNhdCBDb2xsZWN0aW9uIDEgWXRyZWZsZWt0YW5zLXByb2R1a3RlciBtZWQgZW4gbW9sbm1hc2suPGRpdj48YnI+RnVua3Rpb25lbiB1dGbDtnIgYW5hbHlzIHDDpSBlbiBiaWxkIHBlciDDpXIgb2NoIGFudGFsZXQgw6Vyc2RlbGFyIG3DpXN0ZSB2YXJhIGxpa2EgbWVkIGVsbGVyIHN0w7ZycmUgw6RuIHbDpHJkZXQgc29tIGFuZ2VzIGkgcGFyYW1ldGVybiA8c3Ryb25nPkzDpGdzdGEgYW50YWwgb2JzZXJ2YXRpb25lcjwvc3Ryb25nPi4gVmkgcmVrb21tZW5kZXJhciBhdHQgZHUgaGFyIG1pbnN0IHNleCDDpXJzIGRhdGEuPGRpdj48YnI+T20gZHUgaGFyIG3DpW5hdGxpZ2EsIHZlY2tvdmlzYSBlbGxlciBkYWdsaWdhIGRhdGEgcmVrb21tZW5kZXJhciB2aSBhdHQgZHUgdsOkbGplciBmbGVyYSBiaWxkZXIgZnLDpW4gdmFyamUgw6VyIChoZWxzdCBmcsOlbiBzYW1tYSDDpXJzdGlkKSwgdGFyIGJvcnQgbW9sbiBvY2ggbW9sbnNrdWdnYSBvY2gga29tYmluZXJhciBiaWxkZXJuYSBmw7ZyIGF0dCBnZW5lcmVyYSBlbiBlbnNraWxkIGJpbGQgc29tIGbDpW5nYXIgb2JzZXJ2YXRpb25lbiB2w6RsLiBPbSBtw6VuYXRsaWdhLCB2ZWNrb3Zpc2EgZWxsZXIgZGFnbGlnYSBkYXRhIHRpbGxoYW5kYWjDpWxscyBzb20gZmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVyIHNvbSBpbmRhdGEsIGlkZW50aWZpZXJhciBmdW5rdGlvbmVuIGVuIGRlbCBmw7ZyIGFuYWx5cyBiYXNlcmF0IHDDpSBkZSBkYXRhIHNvbSDDpHIgbsOkcm1hc3QgZGUgc29tIGFuZ2VzIGkgcGFyYW1ldGVybiA8c3Ryb25nPlNuYXBwbmluZ3NkYXR1bTwvc3Ryb25nPi48ZGl2Pjxicj5FbiBmdW5rdGlvbiBpIGxhbmRza2FwZXQgdGFyIG9mdGEgdGlkIGF0dCDDpXRlcnN0w6RsbGEgZnLDpW4gZW4gaWNrZS1wZXJtYW5lbnQgw6RuZHJpbmcgc29tIGVuIHNrb2dzYnJhbmQgZWxsZXIgZXR0IGluc2VrdHNhbmdyZXBwLiBEdSBrYW4gc3R5cmEgw6V0ZXJow6RtdG5pbmdzdGFrdGVuIGbDtnIgbW9kZWxsZW4gZ2Vub20gYXR0IGFuZ2UgcGFyYW1ldGVybiBUcsO2c2tlbHbDpHJkZSBmw7ZyIMOldGVyaMOkbXRuaW5nLiBFdHQgZGlzdGlua3Qgc2VnbWVudCBrYW4gaW50ZSBoYSBlbiDDpXRlcmjDpG10bmluZ3N0YWt0IHNvbSDDpHIgc25hYmJhcmUgw6RuIHRyw7Zza2VsdsOkcmRldCBmw7ZyIMOldGVyaMOkbXRuaW5nIDEvLjxkaXY+PGJyPsOFdGVyaMOkbXRuaW5nZW4gZnLDpW4gZW4gbGFuZHNrYXBzZsO2csOkbmRyaW5nIGthbiBza2UgaSBwb3NpdGl2IGVsbGVyIG5lZ2F0aXYgcmlrdG5pbmcuIFRpbGwgZXhlbXBlbDogbsOkciBlbiBza29nc2bDtnJsdXN0IHVwcHN0w6VyIGkgZXR0IGxhbmRza2FwIHPDpSB1cHB2aXNhciBlbiB0aWRzc2VyaWUgbWVkIHbDpHJkZW4gZsO2ciB2ZWdldGF0aW9uc2luZGV4IGVuIHPDpG5rbmluZyBhdiBpbmRleHbDpHJkZW4uIMOFdGVyaMOkbXRuaW5nZW4gdmlzYXIgZW4gZ3JhZHZpcyDDtmtuaW5nIGF2IHZlZ2V0YXRpb25lbnMgaW5kZXh2w6RyZGVuLCBlbGxlciBlbiBwb3NpdGl2IMOldGVyaMOkbXRuaW5nc3RyZW5kLiBBbmdlIHJpa3RuaW5nZW4gZsO2ciDDpXRlcmjDpG10bmluZ3N0cmVuZGVuIG1lZCBwYXJhbWV0ZXJuIDxzdHJvbmc+w4V0ZXJzdMOkbGxuaW5nZW4gaGFyIGVuIMO2a2FuZGUgdHJlbmQ8L3N0cm9uZz4uXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbE5hbWU6IFwiQWdncmVnZXJhIGZsZXJkaW1lbnNpb25lbGx0XCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbFNuaXA6IFwiS29tYmluZXJhciBiZWZpbnRsaWdhIGZsZXJkaW1lbnNpb25lbGxhIHJhc3RlcnZhcmlhYmVsZGF0YSBsw6RuZ3MgZW4gZGltZW5zaW9uLlwiLFxuXHRcdGFnZ3JlZ2F0ZU11bHRpZGltZW5zaW9uYWxEZXNjOiBcIkZ1bmt0aW9uZW4gQWdncmVnZXJhIGZsZXJkaW1lbnNpb25lbGx0IHNrYXBhciBldHQgZmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVybGFnZXIgZ2Vub20gYXR0IGtvbWJpbmVyYSBiZWZpbnRsaWdhIGZsZXJkaW1lbnNpb25lbGxhIHJhc3RlcnZhcmlhYmVsZGF0YSBsw6RuZ3MgZW4gZGltZW5zaW9uLjxkaXY+PGJyPkFudsOkbmQgcGFyYW1ldGVybsKgPHN0cm9uZz5EaW1lbnNpb25zZGVmaW5pdGlvbjwvc3Ryb25nPsKgZsO2ciBhdHQgZsO2cnN0IGZpbHRyZXJhIGRlIGluZGF0YSBkdSB2aWxsIGFnZ3JlZ2VyYS4gT20gZHUgdGlsbCBleGVtcGVsIGhhciAzMCDDpXIgbWVkIG3DpW5hZHNkYXRhIG1lbiBiYXJhIHZpbGwgc2thcGEgZXR0IGFnZ3JlZ2VyYXQgbGFnZXIgZsO2ciBkZSBmw7Zyc3RhIDE1IMOlcmVuLCBrYW4gZHUgYW52w6RuZGEgcGFyYW1ldGVybsKgPHN0cm9uZz5EaW1lbnNpb25zZGVmaW5pdGlvbjwvc3Ryb25nPsKgZsO2ciBhdHQgYW5nZSB2aWxrYSDDpXIgc29tIHNrYSBpbmfDpSBpIGFuYWx5c2VuLjxkaXY+PGJyPjx1bD48bGk+RXh0cmFoZXJhIHNhbHRoYWx0c2RhdGEgZsO2ciBqYW51YXJpIG3DpW5hZCB1bmRlciAxMC3DpXJzcGVyaW9kZW4uIFbDpGxqwqA8c3Ryb25nPkVmdGVyIHbDpHJkZW48L3N0cm9uZz4sIHN0w6RsbCBpbsKgPHN0cm9uZz5EaW1lbnNpb248L3N0cm9uZz7CoHRpbGzCoDxzdHJvbmc+U3RkVGlkPC9zdHJvbmc+IG9jaCBzdMOkbGwgaW7CoDxzdHJvbmc+VsOkcmRlbjwvc3Ryb25nPsKgdGlsbMKgPHN0cm9uZz5KYW51YXJpPC9zdHJvbmc+LjwvbGk+PGxpPkRlbGEgdXBwIHNhbHRoYWx0c2RhdGEgw7Z2ZXIgZXR0IGRqdXBpbnRlcnZhbGwgZnLDpW4gMCB0aWxsIDE1MCBtZXRlci4gVsOkbGogPHN0cm9uZz5FZnRlciBpbnRlcnZhbGw8L3N0cm9uZz4sIHN0w6RsbCBpbiA8c3Ryb25nPkRpbWVuc2lvbjwvc3Ryb25nPiB0aWxsIDxzdHJvbmc+U3RkWjwvc3Ryb25nPiBvY2ggc3TDpGxsIGluIDxzdHJvbmc+TWluaW1pdsOkcmRlPC9zdHJvbmc+IHRpbGwgPHN0cm9uZz4tMTUwPC9zdHJvbmc+IG9jaCA8c3Ryb25nPk1heGltdW12w6RyZGU8L3N0cm9uZz4gdGlsbCA8c3Ryb25nPjA8L3N0cm9uZz4uPC9saT48bGk+IEV4dHJhaGVyYSBzYWx0aGFsdHNkYXRhIGbDtnIgZGUgZsO2cnN0YSAxMCBkYWdhcm5hIGkgamFudWFyaSDDtnZlciBlbiAxMC3DpXJzcGVyaW9kLiBWw6RsaiA8c3Ryb25nPkVmdGVyIGl0ZXJhdGlvbjwvc3Ryb25nPiwgc3TDpGxsIGluIDxzdHJvbmc+RGltZW5zaW9uPC9zdHJvbmc+IHRpbGwgPHN0cm9uZz5TdGRUaWQ8L3N0cm9uZz4sIHN0w6RsbCBpbiA8c3Ryb25nPkLDtnJqYW4gYXYgZsO2cnN0YSBpdGVyYXRpb25lbjwvc3Ryb25nPiBvY2ggPHN0cm9uZz5TbHV0ZXQgYXYgZsO2cnN0YSBpdGVyYXRpb25lbjwvc3Ryb25nPiB0aWxsIG1vdHN2YXJhbmRlIGLDtnJqYW4gb2NoIHNsdXQgYXYgaXRlcmF0aW9uc3BlcmlvZGVuLCBzdMOkbGwgaW4gPHN0cm9uZz5TdGVnPC9zdHJvbmc+IHRpbGwgPHN0cm9uZz4xPC9zdHJvbmc+IG9jaCBzdMOkbGwgaW4gPHN0cm9uZz5FbmhldDwvc3Ryb25nPiB0aWxsIDxzdHJvbmc+w4VyPC9zdHJvbmc+LjwvbGk+PC91bD48ZGl2Pjxicj5BbnbDpG5kIHBhcmFtZXRyYXJuYcKgPHN0cm9uZz5BZ2dyZWdlcmluZ3NkZWZpbml0aW9uPC9zdHJvbmc+wqBmw7ZyIGF0dCB2w6RsamEgZGltZW5zaW9uIGF0dCB1dHbDpHJkZXJhIG9jaCBhZ2dyZWdlcmluZ3NpbnRlcnZhbGxldCBtZWQgbnlja2Vsb3JkLCBldHQgdsOkcmRlIGVsbGVyIGV0dCB2w6RyZGVpbnRlcnZhbGwuIE9tIGR1IHRpbGwgZXhlbXBlbCBoYXIgMzAgw6VycyBkYXRhIMO2dmVyIGhhdnN5dGFucyB0ZW1wZXJhdHVyLCBpbnNhbWxhZCB2YXJqZSBkYWcgb2NoIHDDpSB2YXIgZmVtdGUgbWV0ZXJzIGRqdXAgw6RuZGEgbmVkIHRpbGwgMTAwIG1ldGVyLCBrYW4gZHUgYW52w6RuZGEgZGUgb2xpa2EgaW50ZXJ2YWxsYWx0ZXJuYXRpdmVuIGbDtnIgZsO2bGphbmRlIHNjZW5hcmlvbjo8ZGl2Pjxicj48dWw+PGxpPkFnZ3JlZ2VyYSBkYWdzdGVtcGVyYXR1cmRhdGEgdGlsbCBtw6VuYWRzZGF0YSwgZMOkciByZXN1bHRhdGV0IMOkciBldHQgZmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVyIG1lZCAxMiB0aWRzZGVsYXIsIG9jaCB2YXJqZSBkZWwgw6RyIGVuIGFnZ3JlZ2VyaW5nIGF2IHZhcmplIG3DpW5hZCB1bmRlciBhbGxhIMOlcmVuLiBWw6RsasKgPHN0cm9uZz5JbnRlcnZhbGxueWNrZWxvcmQ8L3N0cm9uZz7CoG9jaCBzdMOkbGwgaW4gbnlja2Vsb3JkZXQgdGlsbMKgPHN0cm9uZz7DhXRlcmtvbW1lciBtw6VuYWRzdmlzPC9zdHJvbmc+LjwvbGk+PGxpPkFnZ3JlZ2VyYSBkYWdsaWdhIHRlbXBlcmF0dXJkYXRhIHRpbGwgbcOlbmFkc2RhdGEsIGTDpHIgcmVzdWx0YXRldCDDpHIgZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlciBtZWQgMzYwIGRlbGFyIGVsbGVyIDEyIHRpZHNkZWxhciBwZXIgw6VyICgzMCDDpXIgw5cgMTIgbcOlbmFkZXIgPSAzNjAgYml0YXIpLiBWw6RsasKgPHN0cm9uZz5JbnRlcnZhbGxueWNrZWxvcmQ8L3N0cm9uZz7CoG9jaCBzdMOkbGwgaW4gbnlja2Vsb3JkZXQgdGlsbMKgPHN0cm9uZz5Nw6VuYWRzdmlzPC9zdHJvbmc+LjwvbGk+PGxpPkFnZ3JlZ2VyYSBtw6VuYWRzdGVtcGVyYXR1cmRhdGEgdGlsbCBmeXJhbcOlbmFkZXJzaW50ZXJ2YWxsLiBWw6RsasKgPHN0cm9uZz5JbnRlcnZhbGx2w6RyZGU8L3N0cm9uZz4sIHN0w6RsbCBpbsKgPHN0cm9uZz5Ww6RyZGVpbnRlcnZhbGw8L3N0cm9uZz7CoHRpbGwgNCwgb2NoIHN0w6RsbCBpbsKgPHN0cm9uZz5FbmhldDwvc3Ryb25nPsKgdGlsbMKgPHN0cm9uZz5Nw6VuYWRlcjwvc3Ryb25nPi48L2xpPjxsaT5BZ2dyZWdlcmEgdGVtcGVyYXR1cmRhdGEgZnLDpW4gMCB0aWxsIDI1IG1ldGVyLCBzZWRhbiBmcsOlbiAyNSB0aWxsIDUwIG1ldGVyLCBkw6RyZWZ0ZXIgZnLDpW4gNTAgdGlsbCAxMDAgbWV0ZXIuIFbDpGxqwqA8c3Ryb25nPkludGVydmFsbG9tcsOlZGVuPC9zdHJvbmc+wqBvY2ggYW5nZSBtaW5zdGEgb2NoIHN0w7Zyc3RhIGRqdXAgc29twqA8c3Ryb25nPjAgMjU7IDI1IDUwOyA1MCAxMDA8L3N0cm9uZz4uPC9saT48L3VsPlwiLFxuXHRcdG1lcmdlUmFzdGVyc05hbWU6IFwiU2FtbWFuZm9nYSByYXN0ZXJcIixcblx0XHRtZXJnZVJhc3RlcnNTbmlwOiBcIktvbWJpbmVyYXIgZmxlcmEgcmFzdGVyZGF0YXNldCBnZW9ncmFmaXNrdCBlbGxlciDDtnZlciB2YXJpYWJsZXIgb2NoIGRpbWVuc2lvbmVyLlwiLFxuXHRcdG1lcmdlUmFzdGVyc0Rlc2M6IFwiRnVua3Rpb25lbiBza2FwYXIgZXR0IHNhbW1hbmZvZ2F0IHJhc3RlciBmcsOlbiBlbiBsaXN0YSBtZWQgcmFzdGVyLiBPbSBkdSB0aWxsIGV4ZW1wZWwgaGFyIGV0dCBtb3NhaWtkYXRhc2V0IHNvbSBpbm5laMOlbGxlciAzMCDDpXJzIGRhdGEgb20gbcOlbmFkc25lZGVyYsO2cmQsIG9jaCBldHQgYW5uYXQgZGF0YXNldCBtZWQgMTAgw6VycyBkYXRhIG9tIG3DpW5hZHN0ZW1wZXJhdHVyLCBzw6Uga2FuIGR1IGtvbWJpbmVyYSBkZW0gdGlsbCBldHQgZmxlcmRpbWVuc2lvbmVsbHQgcmFzdGVyIG1lZCBiw6VkYSB2YXJpYWJsZXJuYS4gPGRpdj48YnI+T20gZmxlcmRpbWVuc2lvbmVsbGEgcmFzdGVyIHNvbSBpbmRhdGEgaW5uZWjDpWxsZXIgb2xpa2EgdmFyaWFibGVyIGtvbW1lciBmbGVyZGltZW5zaW9uZWxsYSByYXN0ZXIgc29tIHV0ZGF0YSBhdHQgaW5uZWjDpWxsYSBhbGxhIGRlIHZhcmlhYmxlcm5hLiA8ZGl2Pjxicj5PbSBmbGVyZGltZW5zaW9uZWxsYSByYXN0ZXIgc29tIGluZGF0YSBpbm5laMOlbGxlciBvbGlrYSBkaW1lbnNpb25lciBlbGxlciBkaW1lbnNpb25zdsOkcmRlbiwga29tbWVyIGZsZXJkaW1lbnNpb25lbGxhIHJhc3RlciBzb20gdXRkYXRhIGF0dCBpbm5laMOlbGxhIGFsbGEgZGVzc2EgZGltZW5zaW9uZXIgb2NoIGRpbWVuc2lvbnN2w6RyZGVuLiA8ZGl2Pjxicj5PbSBmbGVyZGltZW5zaW9uZWxsYSByYXN0ZXIgc29tIGluZGF0YSBpbm5laMOlbGxlciBzYW1tYSBkaW1lbnNpb25lciBvY2ggdmFyaWFibGVyIG1lbiBvbGlrYSBnZW9ncmFmaXNrIHV0YnJlZG5pbmcsIGtvbW1lciBmbGVyZGltZW5zaW9uZWxsYSByYXN0ZXIgc29tIHV0ZGF0YSBhdHQgaW5uZWjDpWxsYSBkZXNzYSB2YXJpYWJsZXIgb2NoIGRpbWVuc2lvbmVyIMO2dmVyIGRlIHNhbW1hbmZvZ2FkZSBnZW9ncmFmaXNrYSB1dGJyZWRuaW5nYXJuYS48ZGl2Pjxicj5EZW5uYSBmdW5rdGlvbiBrYW4gb2Nrc8OlIGFudsOkbmRhcyBuw6RyIGR1IGhhciBtw6VuZ2EgcmFzdGVyIHNvbSBkdSB2aWxsIGJlaGFuZGxhIHNvbSBldHQgZW5za2lsdCBvYmpla3QsIHNvbSBhdHQgYmVyw6RrbmEgc2FtbWEgc3RhdGlzdGlrIGbDtnIgYWxsYSwgZWxsZXIgbsOkciBmw6RyZ2JhbGFuc2VyaW5nIHRpbGzDpG1wYXMgc8OlIGF0dCBkdSBpbnRlIGJlaMO2dmVyIGbDpHJnYmFsYW5zZXJhIHZhcmplIGJpbGQgc2VwYXJhdC4gRGV0IGjDpHIgw6RyIGFudsOkbmRiYXJ0IG7DpHIgZHUgYXJiZXRhciBtZWQgYmlsZGVyIHNvbSBsYWdyYXRzIHNvbSBzZXBhcmF0YSB0aWxlcyBww6UgZ3J1bmQgYXYgZmlsc3Rvcmxla3NiZWdyw6Ruc25pbmdhciwgZsO2ciBww6UgZGV0IHPDpHR0ZXQgYmVoYW5kbGFzIGFsbGEgdGlsZXMgc29tIGVuIGRlbCBhdiBzYW1tYSBiaWxkLlwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5OYW1lOiBcIkdyw6Ruc3JlbnNuaW5nXCIsXG5cdFx0Ym91bmRhcnlDbGVhblNuaXA6IFwiSsOkbW5hciB1dCBncsOkbnNlbiBtZWxsYW4gem9uZXIuXCIsXG5cdFx0Ym91bmRhcnlDbGVhbkRlc2M6IFwiPHA+RnVua3Rpb25lbiBnZW5lcmFsaXNlcmFyIGVsbGVyIGbDtnJlbmtsYXIgcmFzdGVyIGdlbm9tIGF0dCBqw6RtbmEgdXQgZ3LDpG5zZXJuYSBtZWxsYW4gem9uZXIuIEZ1bmt0aW9uZW4gaW5uZWjDpWxsZXIgYWx0ZXJuYXRpdiBmw7ZyIGF0dCBzdHlyYSBodXIgY2VsbGVybmEgaSB6b25lcm5hIGkgaW5kYXRhIHDDpXZlcmthciB1dGrDpG1uaW5nZW4gb2NoIG3DpG5nZGVuIHV0asOkbW5pbmcgc29tIHNrYSB0aWxsw6RtcGFzLiBWYXJqZSBpbmRhdGFjZWxsIHV0dsOkcmRlcmFzIG1lZCBoasOkbHAgYXYgc2luYSDDpXR0YSBuw6RybWFzdGUgZ3Jhbm5hci48L3A+PHA+VXRqw6RtbmluZ3Nwcm9jZXNzZW4gc29ydGVyYXIgZsO2cnN0IGdyYW5uY2VsbGVybmEgbWVkIGVuIHZpc3MgcHJpb3JpdGV0LiBQcmlvcml0ZXRlbiBhdmfDtnIgdmlsa2VuIHpvbiBmcsOlbiBkZSBuw6RybGlnZ2FuZGUgY2VsbGVybmEgc29tIGthbiBlcnPDpHR0YSB2w6RyZGV0IGF2IGJlYXJiZXRuaW5nc2NlbGxlbiBpIHV0ZGF0YS48L3A+PHA+UHJpb3JpdGV0ZW4ga2FuIGJhc2VyYXMgcMOlIGFudGluZ2VuIHbDpHJkZXQgaSB6b25lcm5hIGVsbGVyIHN0b3JsZWtlbiBww6Ugem9uZXJuYS4gUGFyYW1ldGVybiA8c3Ryb25nPlNvcnRlcmluZ3N0eXA8L3N0cm9uZz4gYXZnw7ZyIHZpbGtlbiBzb3J0ZXJpbmdzdHlwIHNvbSBza2EgYW52w6RuZGFzLiA8L3A+PHA+IFN0YW5kYXJkaW5zdMOkbGxuaW5nZW4gPHN0cm9uZz5Tb3J0ZXJhIGludGU8L3N0cm9uZz4gdXR2w6RyZGVyYXIgcHJpb3JpdGV0ZW4gYmFzZXJhdCBww6UgdsOkcmRldCBmw7ZyIHpvbmVybmEuIENlbGxlciBmcsOlbiB6b25lciBtZWQgc3TDtnJyZSB2w6RyZGVuIGtvbW1lciBhdHQgaGEgaMO2Z3JlIHByaW9yaXRldCBmw7ZyIGF0dCBleHBhbmRlcmEgdGlsbCB6b25lciBtZWQgbWluZHJlIHbDpHJkZW4uPC9wPjxwPlpvbmVybmFzIHN0b3JsZWsgZWxsZXIgdG90YWxhIHl0YSBrYW4gYW52w6RuZGFzIGbDtnIgYXR0IHNvcnRlcmEgcHJpb3JpdGV0ZW4uIE1lZCBpbnN0w6RsbG5pbmdlbiA8c3Ryb25nPkZhbGxhbmRlPC9zdHJvbmc+IHNvcnRlcmFzIHpvbmVybmEgZWZ0ZXIgc3RvcmxlayBpIGZhbGxhbmRlIG9yZG5pbmcuIFpvbmVybmEgbWVkIHN0w7ZycmUgdG90YWxhIHl0b3Iga29tbWVyIGF0dCBoYSBwcmlvcml0ZXRlbiBhdHQgZXhwYW5kZXJhIHRpbGwgem9uZXIgbWVkIG1pbmRyZSB5dG9yLiBNZWQgaW5zdMOkbGxuaW5nZW4gPHN0cm9uZz5TdGlnYW5kZTwvc3Ryb25nPiBnw6RsbGVyIG1vdHNhdHNlbjogem9uZXIgbWVkIG1pbmRyZSB0b3RhbGEgeXRvciBrb21tZXIgYXR0IGhhIHByaW9yaXRldGVuIGF0dCBleHBhbmRlcmEgdGlsbCB6b25lciBtZWQgc3TDtnJyZSB0b3RhbGEgeXRvci48L3A+PHA+TcOkbmdkZW4gdXRqw6RtbmluZyBzdHlycyBhdiBwYXJhbWV0ZXJuIDxzdHJvbmc+S8O2ciBleHBhbnNpb24gb2NoIGtyeW1wbmluZyB0dsOlIGfDpW5nZXI8L3N0cm9uZz4sIHNvbSBhdmfDtnIgaHVyIG3DpW5nYSBnw6VuZ2VyIHByb2Nlc3NlbiBmw7ZyIGV4cGFuc2lvbiBvY2gga3J5bXBuaW5nIHNrYSB1dGbDtnJhcy48L3A+PHA+TsOkciBpbnN0w6RsbG5pbmdlbiDDpHIgYXZtYXJrZXJhZCB1dGbDtnJzIHByb2Nlc3NlbiBmw7ZyIGV4cGFuc2lvbiBvY2gga3J5bXBuaW5nIGVuIGfDpW5nLiBOw6RyIGluc3TDpGxsbmluZ2VuIMOkciBtYXJrZXJhZCB1dGbDtnJzIHByb2Nlc3NlbiBmw7ZyIGV4cGFuc2lvbiBvY2gga3J5bXBuaW5nIHR2w6UgZ8Olbmdlciwgdmlsa2V0IHJlc3VsdGVyYXIgaSBlbiBleHRyYSBncmFkIGF2IHV0asOkbW5pbmcgYXYgem9uZ3LDpG5zZXJuYS48L3A+PHA+T20gdsOkcmRlbmEgaSBhbGxhIMOldHRhIG7DpHJsaWdnYW5kZSBjZWxsZXIgw6RyIHNhbW1hIHNvbSBiZWFyYmV0bmluZ3NjZWxsZW4gYmVow6VsbGVyIHV0ZGF0YWNlbGxlbiB2w6RyZGV0IGhvcyBpbmRhdGFjZWxsZW4uPC9wPlwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25OYW1lOiBcIkbDtnJ1dHPDpGcgbWVkIHJlZ3Jlc3Npb25cIixcblx0XHRwcmVkaWN0VXNpbmdSZWdyZXNzaW9uU25pcDogXCJCZXLDpGtuYXQgZXR0IGbDtnJ1dHNhZ3QgcmFzdGVyIGZyw6VuIHJhc3RlcmluZGF0YSBvY2ggZW4gcmVncmVzc2lvbnNtb2RlbGwuIFJlZ3Jlc3Npb25zbW9kZWxsZW4gw6RyIHV0ZGF0YW4gZnLDpW4gZ2VvYmVhcmJldG5pbmdzdmVya3R5Z2V0IGbDtnIgcmFzdGVyLCA8c3Ryb25nPlJlZ3Jlc3Npb25zbW9kZWxsIGbDtnIgdHLDpG5pbmcgYXYgc2x1bXBtw6Rzc2lnYSB0csOkZDwvc3Ryb25nPi5cIixcblx0XHRwcmVkaWN0VXNpbmdSZWdyZXNzaW9uRGVzYzogXCI8cD5SZWdyZXNzaW9uc21vZGVsbGVuIGRlZmluaWVyYXMgaSBFc3JpcyByZWdyZXNzaW9uc2RlZmluaXRpb25zZmlsICguZWNkKS4gRGVuIGlubmVow6VsbGVyIGFsbCBpbmZvcm1hdGlvbiBmw7ZyIGV0dCBzcGVjaWZpa3QgZGF0YXNldCBlbGxlciBlbiB1cHBzw6R0dG5pbmcgbWVkIGRhdGFzZXQsIHNhbXQgcmVncmVzc2lvbnNtb2RlbGxlbiwgb2NoIGdlbmVyZXJhcyBhdiBnZW9iZWFyYmV0bmluZ3N2ZXJrdHlnZXQgZsO2ciByYXN0ZXIsIDxzdHJvbmc+UmVncmVzc2lvbnNtb2RlbGwgZsO2ciB0csOkbmluZyBhdiBzbHVtcG3DpHNzaWdhIHRyw6RkPC9zdHJvbmc+LjwvcD48cD5JbmRhdGEga2FuIHZhcmEgZXR0IGVuc2tpbHQgYmFuZCwgZmxlcmJhbmQsIGV0dCBmbGVyZGltZW5zaW9uZWxsdCByYXN0ZXIgZWxsZXIgZW4gbGlzdGEgw7Z2ZXIgZGVzc2EgdHlwZXIuIFR5cGVybmEgZsO2ciBpbmRhdGFyYXN0ZXIgbcOlc3RlIHZhcmEgYXYgc2FtbWEgcmFzdGVydHlwIHNvbSB0csOkbmFzIGF2IHJlZ3Jlc3Npb25zbW9kZWxsZW4uPC9wPjx1bD48bGk+TsOkciBpbmRhdGEgw6RyIGV0dCBmbGVyYmFuZHNyYXN0ZXIgYmVoYW5kbGFzIHZhcmplIGJhbmQgc29tIGVuIHByZWRpa3RvcnZhcmlhYmVsLiBCYW5kZW4gbcOlc3RlIHZhcmEgaSBzYW1tYSBvcmRuaW5nIHNvbSBmbGVyYmFuZHNpbmRhdGFuIGbDtnIgdHLDpG5pbmdzdmVya3R5Z2V0IGbDtnIgcmVncmVzc2lvbnNtb2RlbGxlbi48L2xpPjxsaT5Ow6RyIGluZGF0YSDDpHIgZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlciBiZWhhbmRsYXMgdmFyamUgdmFyaWFiZWwgc29tIGVuIHByZWRpa3RvcnZhcmlhYmVsLCBvY2ggdmFyaWFiZWxuIG3DpXN0ZSB2YXJhIGV0dCBlbnNraWx0IGJhbmQgb2NoIGhhIGVuIHRpZHNkaW1lbnNpb24uIFZhcmlhYmVsb3JkbmluZ2VuIG9jaCBuYW1uZW4gbcOlc3RlIHZhcmEgc2FtbWEgc29tIGluZGF0YSBmcsOlbiBuw6RyIHJlZ3Jlc3Npb25zbW9kZWxsZW4gdHLDpG5hZGVzLiBVdGRhdGEgw6RyIGV0dCBmbGVyZGltZW5zaW9uZWxsdCByYXN0ZXIuPC9saT48bGk+SW5kYXRhIGthbiB2YXJhIGVuIGxpc3RhIG1lZCBvYmpla3QuIEFudGFsZXQgb2JqZWt0IG9jaCBvcmRuaW5nZW4gZsO2ciBvYmpla3RlbiBtw6VzdGUgbWF0Y2hhIGluZGF0YSBmcsOlbiBuw6RyIHJlZ3Jlc3Npb25zbW9kZWxsZW4gdHLDpG5hZGVzLjwvbGk+PC91bD5cIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NOYW1lOiBcIkRpbWVuc2lvbmVsbCBnbGlkYW5kZSBzdGF0aXN0aWtcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NTbmlwOiBcIkJlcsOka25hciBzdGF0aXN0aWsgZnLDpW4gZXR0IHLDtnJsaWd0IGbDtm5zdGVyIG1lZCBmbGVyZGltZW5zaW9uZWxsYSBkYXRhIGzDpG5ncyBlbiBhbmdpdmVuIGRpbWVuc2lvbi5cIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NEZXNjOiBcIjxwPkZ1bmt0aW9uZW4gRGltZW5zaW9uZWxsIGdsaWRhbmRlIHN0YXRpc3RpayBiZXLDpGtuYXIgb2xpa2Egc3RhdGlzdGlrIGlub20gZXR0IGbDtnJkZWZpbmllcmF0IGbDtm5zdGVyIGbDtnIgYWxsYSBkaW1lbnNpb25zdsOkcmRlbiBsw6RuZ3MgZW4gZGltZW5zaW9uLiBGdW5raW9uZW4gdGFyIGV0dCBmbGVyZGltZW5zaW9uZWxsdCByYXN0ZXJsYWdlciBzb20gaW5kYXRhIG9jaCBza2FwYXIgZXR0IGZsZXJkaW1lbnNpb25lbGx0IHJhc3RlcmxhZ2VyIHNvbSB1dGRhdGEgc29tIGhhciBzYW1tYSBkaW1lbnNpb25lbGxhIHN0b3JsZWsgc29tIGluZGF0YWxhZ3JldC48L3A+PHA+RHUga2FuIGFuZ2UgZW4gZGltZW5zaW9uIGbDtnIgdmlsa2VuIGRpbWVuc2lvbnN2w6RyZGVuIGJlYWt0YXMgdmlkIGJlcsOka25pbmcuIFNvbSBzdGFuZGFyZCBza2VyIGJlcsOka25pbmdlbiBsw6RuZ3MgZGVuIGbDtnJzdGEgaWNrZS1zcGF0aWFsYSBkaW1lbnNpb25lbi4gRHUga2FuIMOkdmVuIGFuZ2UgZW4gZsO2bnN0ZXJzdG9ybGVrIGdlbm9tIGF0dCBhbmdlIHBhcmFtZXRyYXJuYSBGw7Zuc3RlciBiYWvDpXQgb2NoIEbDtm5zdGVyIGZyYW3DpXQuPC9wPjxwPk7DpHIgc3RhdGlzdGlrdHlwZW4gw6RyIGluc3TDpGxsZCBww6UgcGVyY2VudGlsIGJsaXIgcGFyYW1ldHJhcm5hIFBlcmNlbnRpbHbDpHJkZSBvY2ggSW50ZXJwb2xlcmluZ3N0eXAgZsO2ciBwZXJjZW50aWwgdGlsbGfDpG5nbGlnYS4gRHUga2FuIGFudsOkbmRhIGRlc3NhIHBhcmFtZXRyYXIgZsO2ciBhdHQgYW5nZSBwZXJjZW50aWxlbiBmw7ZyIGF0dCBiZXLDpGtuYSBvY2ggdsOkbGphIHZpbGtlbiBpbnRlcnBvbGVyaW5nc3R5cCBzb20gc2thIGFudsOkbmRhcy4gTsOkciBzdGF0aXN0aWt0eXBlbiDDpHIgaW5zdMOkbGxkIHDDpSBDaXJrdWzDpHJ0IG1lZGVsdsOkcmRlIGJsaXIgcGFyYW1ldGVybiBDaXJrdWzDpHJ0IHJhZGJyeXRuaW5nc3bDpHJkZSB0aWxsZ8OkbmdsaWcuIERldCBjaXJrdWzDpHJhIHJhZGJyeXRuaW5nc3bDpHJkZXQgYW52w6RuZHMgZsO2ciBhdHQga29udmVydGVyYSBldHQgbGluasOkcnQgdsOkcmRlIHRpbGwgaW50ZXJ2YWxsZXQgZsO2ciBldHQgYW5naXZldCBjaXJrdWzDpHJ0IG1lZGVsdsOkcmRlLjwvcD5cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uTmFtZTogXCJUZXJyw6RuZ2F2cGxhdHRuaW5nXCIsXG5cdFx0dGVycmFpbkZsYXR0ZW5GdW5jdGlvblNuaXA6IFwiS29ycmlnZXJhciBpbmRhdGEgZsO2ciBzeW50ZXRpc2sgYXBlcnR1cnJhZGFyZGF0YSAoU0FSKSBmw7ZyIHJhZGlvbWV0cmlza2EgZsO2cnZyw6RuZ25pbmdhciBww6UgZ3J1bmQgYXYgdG9wb2dyYWZpLlwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25EZXNjOiBcIjxwPkZ1bmt0aW9uZW4gVGVycsOkbmdhdnBsYXR0bmluZyBrb3JyaWdlcmFyIGluZGF0YSBmw7ZyIHN5bnRldGlzayBhcGVydHVycmFkYXJkYXRhIChTQVIpIGbDtnIgcmFkaW9tZXRyaXNrYSBmw7ZydnLDpG5nbmluZ2FyIHDDpSBncnVuZCBhdiB0b3BvZ3JhZmkuPC9wPjxwPlJhZGFyaW5kYXRhIG3DpXN0ZSBmw7Zyc3Qga2FsaWJyZXJhcyB0aWxsIGJldGEtbm9sbC4gQW52w6RuZCB2ZXJrdHlnZXQgVGlsbMOkbXBhIHJhZGlvbWV0cmlzayBrYWxpYnJlcmluZyBmw7ZyIGF0dCBrYWxpYnJlcmEgcmFkYXJkYXRhIHRpbGwgYmV0YS1ub2xsLjwvcD48cD5PbSBERU0gc29tIGluZGF0YSBpbnRlIG9tZmF0dGFyIGhlbGEgU0FSLWRhdGFzZXRldCBtYXRhciB2ZXJrdHlnZXQgdXQgTm9EYXRhLXbDpHJkZW4gZsO2ciBwaXhsYXJuYSB1dGFuZsO2ciBERU0tdXRicmVkbmluZ2VuIGbDtnIgZ2FtbWEtbm9sbCwgc2lnbWEtbm9sbCwgc3ByaWRuaW5nc29tcsOlZGUgb2NoIGdlb21ldHJpc2thIGbDtnJ2csOkbmduaW5nc3V0ZGF0YS4gRsO2ciBkZW4gZ2VvbWV0cmlza2EgZsO2cnZyw6RuZ25pbmdzbWFza2VucyB1dGRhdGEgbWF0YXIgdmVya3R5Z2V0IHV0IG9iZXN0w6RtZGEgdsOkcmRlbiBmw7ZyIHBpeGxhciB1dGFuZsO2ciBERU0tdXRicmVkbmluZ2VuLjwvcD48cD5ERU0gc29tIGluZGF0YSBtw6VzdGUgdmFyYSBpIGRldCBnZW9ncmFmaXNrYSBrb29yZGluYXRzeXN0ZW1ldCBXR1MgMTk4NCAoRVBTRzo0MzI2KS48L3A+XCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvbk5hbWU6IFwiU2thcGEgZsOkcmdrb21iaW5hdGlvblwiLFxuXHRcdGNyZWF0ZUNvbG9yQ29tcG9zaXRlRnVuY3Rpb25TbmlwOiBcIlNrYXBhciBldHQgdHJlYmFuZHNyYXN0ZXIgZnLDpW4gZXR0IGZsZXJiYW5kc3Jhc3RlcmRhdGFzZXQgaSB2aWxrZXQgdmFyamUgYmFuZCBrYW4gYW52w6RuZGEgZW4gYWxnZWJyYWlzayBiZXLDpGtuaW5nIGJhc2VyYXQgcMOlIGJhbmRhbGdlYnJhLlwiLFxuXHRcdGNyZWF0ZUNvbG9yQ29tcG9zaXRlRnVuY3Rpb25EZXNjOiBcIjxwPlJhc3RlcmZ1bmt0aW9uZW4gU2thcGEgZsOkcmdrb21iaW5hdGlvbiBza2FwYXIgZXR0IHRyZWJhbmRzcmFzdGVyIGZyw6VuIGV0dCBmbGVyYmFuZHNyYXN0ZXJkYXRhc2V0IGkgdmlsa2V0IHZhcmplIGJhbmQga2FuIGFudsOkbmRhIGVuIGFsZ2VicmFpc2sgYmVyw6RrbmluZyBiYXNlcmF0IHDDpSBiYW5kYWxnZWJyYS48L3A+PHA+TsOkciBlbiBiYW5kYXJpdG1ldGlzayBhbGdvcml0bSBkZWZpbmllcmFzIGthbiBkdSBhbmdlIGVuIGFsZ2VicmFpc2sgZm9ybWVsIG1lZCBlbiByYWQgZsO2ciB2YXJqZSB1dHRyeWNrIGbDtnIgYXR0IHNrYXBhIGZsZXJiYW5kc3V0ZGF0YS4gT3BlcmF0b3Jlcm5hIHNvbSBzdMO2ZHMgw6RyIGVuc3TDpGxsaWcsIHBsdXMgKCspLCBtaW51cyAoLSksIGfDpW5nZXIgKCopIG9jaCBkZWxhdCBtZWQgKC8pLjwvcD48cD5JZGVudGlmaWVyYSBiYW5kZXQgZ2Vub20gYXR0IGFuZ2UgcHJlZml4ZXQgQiBlbGxlciBiIGbDtnIgYmFuZG51bXJldCBuw6RyIGR1IGFudsOkbmRlciBldHQgYmFuZC1JRCBpIGV0dCB1dHRyeWNrLjwvcD48cD5FbiB2YW5saWcgYmFuZGtvbWJpbmF0aW9uIHNvbSBhbnbDpG5kcyBmw7ZyIHN5bnRldGlzayBhcGVydHVycmFkYXIgKFNBUikgaSBsaW5qw6RyYSBlbmhldGVyIMOkciBWViBmw7ZyIHLDtnR0LCBWSCBmw7ZyIGdyw7ZudCBvY2ggVlYvVkggZsO2ciBibMOldHQuIE9tIGluZGF0YSDDpHIgaSBkZWNpYmVsIHNrYSBiYW5ka29tYmluYXRpb25lbiB2YXJhIFZWIGbDtnIgcsO2dHQsIFZIIGbDtnIgZ3LDtm50IG9jaCBWVi1WSCBmw7ZyIGJsw6V0dC48L3A+XCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNOYW1lOiBcIll0cGFyYW1ldHJhclwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzU25pcDogXCJCZXN0w6RtbWVyIHBhcmFtZXRyYXIgZsO2ciBldHQgeXRyYXN0ZXIsIHRpbGwgZXhlbXBlbCBsdXRuaW5nc3Jpa3RuaW5nLCBsdXRuaW5nIG9jaCBmbGVyYSB0eXBlciBhdiBrdXJ2YXR1ciBtZWQgZ2VvZGV0aXNrYSBtZXRvZGVyLlwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzRGVzYzogXCI8cD5GdW5rdGlvbmVuIFl0cGFyYW1ldHJhciBiZXN0w6RtbWVyIHBhcmFtZXRyYXIgZsO2ciBldHQgeXRyYXN0ZXIsIHRpbGwgZXhlbXBlbCBsdXRuaW5nc3Jpa3RuaW5nLCBsdXRuaW5nIG9jaCBmbGVyYSB0eXBlciBhdiBrdXJ2YXR1ciBtZWQgZ2VvZGV0aXNrYSBtZXRvZGVyLjwvcD48cD5EZW5uYSBmdW5rdGlvbiBrYW4gYW52w6RuZGFzIGbDtnIgZsO2bGphbmRlIGFwcGxpa2F0aW9uZXI6PC9wPjx1bD48bGk+QmVyw6RrbmEgbHV0bmluZ3NyaWt0bmluZyBvY2ggbHV0bmluZyBtZWQgZ2VvZGV0aXNrYSBtZXRvZGVyLjwvbGk+PGxpPkJlcsOka25hIG9saWthIHR5cGVyIGF2IGt1cnZhdHVyZXIgZnLDpW4gZXR0IGluZGF0YXJhc3RlciwgdGlsbCBleGVtcGVsIDxzdHJvbmc+VGFuZ2VudGlhbGt1cnZhdHVyIChub3JtYWwga29udHVyKTwvc3Ryb25nPiBzb20ga2FyYWt0w6RyaXNlcmFyIGZsw7ZkZXRzIHRvcG9ncmFmaXNrYSBrb252ZXJnZW5zIG9jaCBkaXZlcmdlbnMgw7Z2ZXIgeXRhbi48L2xpPjwvdWw+XCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JOYW1lOiBcIkJpbGxpZ2FzdGUga29ycmlkb3JcIixcblx0XHRsZWFzdENvc3RDb3JyaWRvclNuaXA6IFwiQmVyw6RrbmFyIHN1bW1hbiBhdiB0dsOlIGFja3VtdWxlcmFkZSByYXN0ZXIgZsO2ciBhdnN0w6VuZHNrb3N0bmFkIG1lZCBhbHRlcm5hdGl2ZXQgYXR0IHRpbGzDpG1wYSBlbiB0csO2c2tlbCBiYXNlcmF0IHDDpSBwcm9jZW50c2F0cyBlbGxlciBhY2t1bXVsZXJhZCBrb3N0bmFkLlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yRGVzYzogXCI8cD5JbmRhdGFyYXN0cmVuIHNrYSB2YXJhIGF2c3TDpW5kc2Fja3VtdWxlcmluZyBvY2ggdXRkYXRhIGbDtnIgdGlsbGJha2FyaWt0bmluZ3NyYXN0ZXIgZnLDpW4gZnVua3Rpb25lbiA8c3Ryb25nPkF2c3TDpW5kc2Fja3VtdWxlcmluZzwvc3Ryb25nPiBlbGxlciA8c3Ryb25nPkF2c3TDpW5kc2FsbG9rZXJpbmc8L3N0cm9uZz4uIERlc3NhIHNrYSBiYXNlcmFzIHDDpSBrb3N0bmFkc2F2c3TDpW5kIG9jaCBzYW1tYSBwYXJhbWV0ZXJpbnN0w6RsbG5pbmdhciBza2EgYW52w6RuZGFzIG7DpHIgbGFnZXIgc2thcGFzIGbDtnIgdmFyamUga8OkbGxhLiBJbmdhIHBhcmFtZXRyYXIgc29tIGJlcm9yIHDDpSBpbnJpa3RuaW5nIChob3Jpc29udGFsZmFrdG9yLCB2ZXJ0aWthbGZha3RvciBvY2ggcmVzZXJpa3RuaW5nKSBza2EgYW52w6RuZGFzIG7DpHIgZGVzc2EgcmFzdGVyIHNrYXBhcy48L3A+PHA+VsOkcmRlbmEgaSB1dGRhdGFyYXN0cmV0IGbDtnIga29ycmlkb3JlbiDDpHIgc3VtbWFuIGF2IGRlbiBhY2t1bXVsZXJhZGUga29zdG5hZGVuIGbDtnIgYXR0IG7DpSBlbiBhbmdpdmVuIHBsYXRzIG1lZCBzYW1tYSBlbmhldGVyIHNvbSBpbmRhdGFyYXN0cmVuIGbDtnIgYWNrdW11bGVyYWQgYXZzdMOlbmRza29zdG5hZC48L3A+PHA+T20gZXR0IGFuZ2l2ZXQ8c3Ryb25nPlRyw7Zza2VsPC9zdHJvbmc+LXbDpHJkZSDDpHIgc3TDtnJyZSDDpG4gbWF4aW1hbCBhY2t1bXVsZXJhZCBrb3N0bmFkIG7DpHIgZGUgdHbDpSByYXN0cmVuIGbDtnIgYXZzdMOlbmRzYWNrdW11bGVyaW5nIHN1bW1lcmFzLCBrb21tZXIgdXRkYXRhcmFzdHJldCBmw7ZyIGtvcnJpZG9yZW4gYXR0IHTDpGNrYSBzYW1tYSBvbXLDpWRlIHNvbSByYXN0cmVuIG1lZCBhY2t1bXVsZXJhZGUgaW5kYXRhLjwvcD48cD5PbSBldHQgYW5naXZldCB0csO2c2tlbHbDpHJkZSDDpHIgbWluZHJlIMOkbiBkZXQgbWluc3RhIHbDpHJkZXQgaSBrb3JyaWRvcnJhc3RyZXQgcmV0dXJuZXJhcyBldHQgdmFybmluZ3NtZWRkZWxhbmRlIG9jaCB1dGRhdGFyYXN0cmV0IMOkciB0b210LjwvcD48cD5VdGRhdGFyYXN0cmV0IGbDtnIga29ycmlkb3JlbiBrYW4gaW5uZWjDpWxsYSBjZWxsZXIgbWVkIG7DpWdvdCBzdMO2cnJlIGFja3VtdWxlcmFkZSBrb3N0bmFkZXIgw6RuIHRyw7Zza2VsdsOkcmRldC4gRGV0IGJlcm9yIHDDpSBhdHQgcmFzdHJlbiBmw7ZyIHRpbGxiYWthcmlrdG5pbmcgYW52w6RuZGVyIGNlbGxlciBzb20gw6RyIHRpbGxkZWxhZGUgbsOlZ290IGjDtmdyZSBrb3N0bmFkZXIgw6RuIHRyw7Zza2VsbiBmw7ZyIGF0dCBrb3BwbGEgZnLDpW5rb3BwbGFkZSBjZWxsZXIgdGlsbCBrb3JyaWRvcmVuLjwvcD5cIixcblx0XHRnZW9tZXRyaWNNZWRpYW5OYW1lOiBcIkdlb21ldHJpc2sgbWVkaWFuXCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuU25pcDogXCJGdW5rdGlvbmVuIEdlb21ldHJpc2sgbWVkaWFuIGJlcsOka25hciBkZW4gZ2VvbWV0cmlza2EgbWVkaWFuZW4gZsO2ciBwaXhsYXIgaSBlbiB0aWRzc2VyaWUgYXYgbXVsdGliYW5kc2JpbGRlci5cIixcblx0XHRnZW9tZXRyaWNNZWRpYW5EZXNjOiBcIjxwPkRlbiBow6RyIGZ1bmt0aW9uZW4gbWluc2thciBicnVzIG9jaCBhdnZpa2Vsc2VyIGkgdGlkc3NlcmllYmlsZGVyIGdlbm9tIGF0dCBiZXLDpGtuYSBkZW4gZ2VvbWV0cmlza2EgbWVkaWFucGl4ZWxuIGbDtnIgdmFyamUgcGl4ZWx2ZWt0b3IgaSBiaWxkc3RhY2tlbi4gQWxnb3JpdG1lbiBiZWjDpWxsZXIgZGUgc3Bla3RyYWxhIHJlbGF0aW9uZXJuYSBtZWxsYW4gYmFuZCBpIHBpeGVsc3Bla3RydW1ldCwgc8OlIGF0dCB1dGRhdGEga2FuIGFudsOkbmRhcyBpIGFuYWx5cywgc29tIHZlZ2V0YXRpb25zaW5kZXguPC9wPjxwPk1vbG4gb2NoIHNrdWdnb3IgYsO2ciBtYXNrZXJhcyBtZWQgaGrDpGxwIGF2IGRhdGFzZXRldHMgUUEtYmFuZCBpbm5hbiBkZW4gaMOkciBmdW5rdGlvbmVuIHRpbGzDpG1wYXMuPC9wPjxwPk9tIGluZGF0YWJpbGRlbiDDpHIgZmx5dHRhbCwgc29tIHl0cmVmbGVrdGFucyBtZWQgdsOkcmRlbiBtZWxsYW4gMCBvY2ggMSwgYsO2ciBldHQgZXBzaWxvbnbDpHJkZSBww6UgMCwwMDEgbGVkYSB0aWxsIGt2YWxpdGV0c3Jlc3VsdGF0LjwvcD5cIlxuXHR9LFxuXHRyZnhBcmdzOiB7XG5cdFx0cmFzdGVyTmFtZTogXCJSYXN0ZXJcIixcblx0XHRjb2xvclNjaGVtZVR5cGVOYW1lOiBcIlR5cCBhdiBmw6RyZ3NjaGVtYVwiLFxuXHRcdGNvbG9ybWFwTmFtZTogXCJGw6RyZ3NjaGVtYVwiLFxuXHRcdGNvbG9ybWFwTmFtZU5hbWU6IFwiTmFtbiBww6UgZsOkcmdzY2hlbWFcIixcblx0XHRjb2xvclJhbXBOYW1lOiBcIkbDpHJncmFtcFwiLFxuXHRcdGNvbnRyYXN0T2Zmc2V0TmFtZTogXCJLb250cmFzdGbDtnJza2p1dG5pbmdcIixcblx0XHRicmlnaHRuZXNzT2Zmc2V0TmFtZTogXCJManVzc3R5cmtlZsO2cnNranV0bmluZ1wiLFxuXHRcdG1ldGhvZE5hbWU6IFwiTWV0b2RcIixcblx0XHRiYW5kTmFtZXNOYW1lOiBcIkJhbmRuYW1uXCIsXG5cdFx0YmFuZFdhdmVsZW5ndGhzTmFtZTogXCJCYW5kdsOlZ2zDpG5nZGVyXCIsXG5cdFx0YmFuZElkc05hbWU6IFwiQmFuZGlkZW50aWZpZXJhcmVcIixcblx0XHRtaXNzaW5nQmFuZEFjdGlvbk5hbWU6IFwiU2FrbmFkIGJhbmTDpXRnw6RyZFwiLFxuXHRcdGNvbnZlcnNpb25QYXJhbWV0ZXJzTmFtZTogXCJLb252ZXJ0ZXJpbmdzcGFyYW1ldHJhclwiLFxuXHRcdGhpbGxzaGFkZVR5cGVOYW1lOiBcIlRlcnLDpG5nc2t1Z2duaW5nc3R5cFwiLFxuXHRcdGF6aW11dGhOYW1lOiBcIkF6aW11dFwiLFxuXHRcdGFsdGl0dWRlTmFtZTogXCJIw7ZqZFwiLFxuXHRcdHNsb3BlVHlwZU5hbWU6IFwiU2thbG5pbmdcIixcblx0XHR6RmFjdG9yTmFtZTogXCJaLWZha3RvclwiLFxuXHRcdFBTUG93ZXJOYW1lOiBcIlBpeGVsc3Rvcmxla3Nwb3RlbnNcIixcblx0XHRQU1pGYWN0b3JOYW1lOiBcIlBpeGVsc3Rvcmxla3NmYWt0b3JcIixcblx0XHRyZW1vdmVFZGdlRWZmZWN0TmFtZTogXCJJbmFrdGl2ZXJhIHN0YW5kYXJkaW50ZXJwb2xlcmluZyBhdiBrYW50cGl4bGFyXCIsXG5cdFx0ZnJvbVVuaXROYW1lOiBcIkZyw6VuIGVuaGV0XCIsXG5cdFx0dG9Vbml0TmFtZTogXCJUaWxsIGVuaGV0XCIsXG5cdFx0cmFzdGVyVHlwZU5hbWU6IFwiVHlwXCIsXG5cdFx0bWluTmFtZTogXCJNaW5pbXVtIGbDtnIgdXRkYXRhXCIsXG5cdFx0bWF4TmFtZTogXCJNYXhpbXVtIGbDtnIgdXRkYXRhXCIsXG5cdFx0bWluUGVyY2VudE5hbWU6IFwiUHJvY2VudGtsaXBwbmluZyBtaW5pbXVtXCIsXG5cdFx0bWF4UGVyY2VudE5hbWU6IFwiUHJvY2VudGtsaXBwbmluZyBtYXhpbXVtXCIsXG5cdFx0bnVtYmVyT2ZTdGFuZGFyZERldmlhdGlvbk5hbWU6IFwiQW50YWwgc3RhbmRhcmRhdnZpa2Vsc2VyXCIsXG5cdFx0c2lnbW9pZFN0cmVuZ3RoTGV2ZWxOYW1lOiBcIlNpZ21vaWRzdHlya2VuaXbDpVwiLFxuXHRcdGVzdGltYXRlU3RhdHNIaXN0b2dyYW1OYW1lOiBcIkJlcsOka25hIHN0YXRpc3Rpa1wiLFxuXHRcdERSQU5hbWU6IFwiRHluYW1pc2sgaW50ZXJ2YWxsanVzdGVyaW5nXCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGlrXCIsXG5cdFx0aGlzdG9ncmFtc05hbWU6IFwiSGlzdG9ncmFtXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbU5hbWU6IFwiRGVmaW5pZXJhIHN0YXRpc3RpayBvY2ggaGlzdG9ncmFtXCIsXG5cdFx0Y29tcHV0ZUdhbW1hTmFtZTogXCJBdXRvZ2FtbWFcIixcblx0XHR1c2VHYW1tYU5hbWU6IFwiQW52w6RuZCBnYW1tYVwiLFxuXHRcdGdhbW1hTmFtZTogXCJHYW1tYVwiLFxuXHRcdGlucHV0TmFtZXNOYW1lOiBcIk5hbW5cIixcblx0XHRleHByZXNzaW9uTmFtZTogXCJVdHRyeWNrXCIsXG5cdFx0Y2VsbHNpemVUeXBlTmFtZTogXCJDZWxsc3Rvcmxla3N0eXBcIixcblx0XHRleHRlbnRUeXBlTmFtZTogXCJVdGJyZWRuaW5nc3R5cFwiLFxuXHRcdGNsYXNzaWZpZXJEZWZpbml0aW9uRmlsZU5hbWU6IFwiSW5kYXRhZGVmaW5pdGlvbnNmaWxcIixcblx0XHRyYXN0ZXIxTmFtZTogXCJSYXN0ZXIxXCIsXG5cdFx0cmFzdGVyMk5hbWU6IFwiUmFzdGVyMlwiLFxuXHRcdHJhc3RlcjNOYW1lOiBcIlJhc3RlcjNcIixcblx0XHR0cnVlUmFzdGVyTmFtZTogXCJTYW50IHJhc3RlclwiLFxuXHRcdGZhbHNlUmFzdGVyTmFtZTogXCJGYWxza3QgcmFzdGVyXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0YXRpb25OYW1lOiBcIk5vRGF0YS10b2xrbmluZ1wiLFxuXHRcdG5vRGF0YVZhbHVlc05hbWU6IFwiTm9EYXRhLXbDpHJkZW5cIixcblx0XHRpbmNsdWRlZFJhbmdlc05hbWU6IFwiSW5rbHVkZXJhZGUgaW50ZXJ2YWxsXCIsXG5cdFx0Y3VydmF0dXJlVHlwZU5hbWU6IFwiS3VydmF0dXJ0eXBcIixcblx0XHRyYXN0ZXJzTmFtZTogXCJSYXN0ZXJcIixcblx0XHRhdHRyaWJ1dGVUYWJsZU5hbWU6IFwiVGFiZWxsXCIsXG5cdFx0YXR0cmlidXRlVGFibGVUeXBlTmFtZTogXCJUYWJlbGx0eXBcIixcblx0XHRyb3dzTmFtZTogXCJBbnRhbCByYWRlclwiLFxuXHRcdGNvbHVtbnNOYW1lOiBcIkFudGFsIGtvbHVtbmVyXCIsXG5cdFx0a2VybmVsTmFtZTogXCJLw6RybmFcIixcblx0XHRtaXJyb3JFZGdlc05hbWU6IFwiU3BlZ2Vsa2FudGVyXCIsXG5cdFx0aW5mbHVlbmNlc05hbWU6IFwiSW5mbHl0YW5kZW5cIixcblx0XHRmaWVsZHNOYW1lOiBcIkbDpGx0XCIsXG5cdFx0cmVtYXBzTmFtZTogXCJPbW1hcHBuaW5nc3RhYmVsbFwiLFxuXHRcdGV2YWxGcm9tTmFtZTogXCJVdHbDpHJkZXJpbmdzc2thbGEgZnLDpW5cIixcblx0XHRldmFsVG9OYW1lOiBcIlV0dsOkcmRlcmluZ3Nza2FsYSB0aWxsXCIsXG5cdFx0d2VpZ2h0c05hbWU6IFwiVmlrdGVyXCIsXG5cdFx0REVNTmFtZTogXCJERU1cIixcblx0XHRzaG9ydFJhbmdlSURXUmFkaXVzTmFtZTogXCJJRFctcmFkaWUgbWVkIGtvcnQgYXZzdMOlbmRcIixcblx0XHRtYXhWb2lkV2lkdGhOYW1lOiBcIk1heGJyZWRkIGbDtnIgdG9tcnVtXCIsXG5cdFx0c2lnbWFHYXVzc2lhbk5hbWU6IFwiQWRhcHRpdiB1dGrDpG1uaW5nXCIsXG5cdFx0Y29udG91clR5cGVOYW1lOiBcIkjDtmpka3VydmV0eXBcIixcblx0XHR6QmFzZU5hbWU6IFwiWi1iYXNcIixcblx0XHRudW1iZXJPZkNvbnRvdXJzTmFtZTogXCJBbnRhbCBow7ZqZGt1cnZvclwiLFxuXHRcdGNvbnRvdXJJbnRlcnZhbE5hbWU6IFwiSMO2amRrdXJ2ZWludGVydmFsbFwiLFxuXHRcdG50aENvbnRvdXJMaW5lSW5Cb2xkTmFtZTogXCJOOmUgaMO2amRrdXJ2ZWxpbmplbiBpIGZldHN0aWxcIixcblx0XHRmZWF0dXJlQ2xhc3NOYW1lOiBcIkluZGF0YWdlb29iamVrdFwiLFxuXHRcdGNsYXNzSW5kZXhGaWVsZE5hbWU6IFwiRsOkbHRcIixcblx0XHRyZXNvbHZlT3ZlcmxhcE1ldGhvZE5hbWU6IFwiTWV0b2QgZsO2ciBhdHQgbMO2c2Egw7Z2ZXJsYXBwbmluZ1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmFtZTogXCJPbXNhbXBsaW5nc3R5cFwiLFxuXHRcdGlucHV0Q2VsbHNpemVOYW1lOiBcIkluZGF0YWNlbGxzdG9ybGVrXCIsXG5cdFx0b3V0cHV0Q2VsbHNpemVOYW1lOiBcIlV0ZGF0YWNlbGxzdG9ybGVrXCIsXG5cdFx0cG9pbnRGZWF0dXJlQ2xhc3NOYW1lOiBcIlNlZWRwdW5rdGVyXCIsXG5cdFx0bWF4R3Jvd3RoUmFkaXVzRmllbGROYW1lOiBcIkbDpGx0IGbDtnIgbWF4IHRpbGx2w6R4dHJhZGllXCIsXG5cdFx0c2ltaWxhcml0eVRocmVzaG9sZEZpZWxkTmFtZTogXCJGw6RsdCBmw7ZyIGxpa2hldHNncsOkbnN2w6RyZGVcIixcblx0XHRmaWxsVmFsdWVGaWVsZE5hbWU6IFwiRsOkbHQgZsO2ciBmeWxsbmluZ3N2w6RyZGVcIixcblx0XHRzcGVjdHJhbERldGFpbE5hbWU6IFwiU3Bla3RyYWwgZGV0YWxqIFsxLi4yMF1cIixcblx0XHRzcGF0aWFsRGV0YWlsTmFtZTogXCJHZW9ncmFmaXNrIGRldGFsaiBbMS4uMjBdXCIsXG5cdFx0bWluTnVtUGl4ZWxzUGVyU2VnbWVudE5hbWU6IFwiTWluc3RhIHNlZ21lbnRzdG9ybGVrIGkgcGl4bGFyXCIsXG5cdFx0Ym91bmRhcmllc09ubHlOYW1lOiBcIkVuZGFzdCBzZWdtZW50Z3LDpG5zZXJcIixcblx0XHRzdGF0aXN0aWNzVHlwZU5hbWU6IFwiU3RhdGlzdGlrdHlwXCIsXG5cdFx0ZmlsbE5vRGF0YU9ubHlOYW1lOiBcIkZ5bGwgZW5kYXN0IGkgTm9EYXRhLXBpeGxhclwiLFxuXHRcdGlucHV0RGF0YVR5cGVOYW1lOiBcIkRhdGF0eXAgZsO2ciBpbmRhdGFcIixcblx0XHRhbmdsZVJlZmVyZW5jZVN5c3RlbU5hbWU6IFwiVmlua2VscmVmZXJlbnNzeXN0ZW1cIixcblx0XHRvdXRwdXREYXRhVHlwZU5hbWU6IFwiRGF0YXR5cCBmw7ZyIHV0ZGF0YVwiLFxuXHRcdGlucHV0U2FtcGxlUG9pbnRGZWF0dXJlQ2xhc3NOYW1lOiBcIkluZGF0YXByb3ZcIixcblx0XHR2YWx1ZUZpZWxkTmFtZTogXCJWw6RyZGVmw6RsdFwiLFxuXHRcdHJhc3RlckluZm9OYW1lOiBcIlJhc3RlcmluZm9cIixcblx0XHRpbnRlcnBvbGF0aW9uTWV0aG9kTmFtZTogXCJJbnRlcnBvbGVyaW5nc21ldG9kXCIsXG5cdFx0cmFkaXVzTmFtZTogXCJSYWRpZVwiLFxuXHRcdHJhZGlhbmNlR2FpblZhbHVlc05hbWU6IFwiU3Ryw6VsbmluZ3Nmw7Zyc3TDpHJrbmluZ1wiLFxuXHRcdHJhZGlhbmNlQmlhc1ZhbHVlc05hbWU6IFwiU25lZHZyaWRuaW5nIGF2IHN0csOlbG5pbmdcIixcblx0XHRyZWZsZWN0ZWRHYWluVmFsdWVzTmFtZTogXCLDlmtuaW5nIGF2IHJlZmxleGlvbnNmYWt0b3JcIixcblx0XHRyZWZsZWN0ZWRCaWFzVmFsdWVzTmFtZTogXCJTbmVkdnJpZG5pbmcgYXYgcmVmbGVrdGFuc1wiLFxuXHRcdHN1bkVsZXZhdGlvbk5hbWU6IFwiU29saMO2amQgKGdyYWRlcilcIixcblx0XHRhbGJlZG9OYW1lOiBcIkFsYmVkb1wiLFxuXHRcdHNjYWxlRmFjdG9yTmFtZTogXCJTa2FsZmFrdG9yXCIsXG5cdFx0b2Zmc2V0TmFtZTogXCJGw7Zyc2tqdXRuaW5nXCIsXG5cdFx0dGhyZXNob2xkVHlwZU5hbWU6IFwiVHLDtnNrZWx2w6RyZGVzdHlwXCIsXG5cdFx0dGhyZXNob2xkc05hbWU6IFwiVHLDtnNrZWx2w6RyZGVuXCIsXG5cdFx0dW5kZWZpbmVkQ2xhc3NOYW1lOiBcIk9kZWZpbmllcmFkIGtsYXNzXCIsXG5cdFx0bWluVmFsdWVOYW1lOiBcIk1pbi5cIixcblx0XHRtYXhWYWx1ZU5hbWU6IFwiTWF4XCIsXG5cdFx0b3BlcmF0aW9uTmFtZTogXCLDhXRnw6RyZFwiLFxuXHRcdGNsaXBwaW5nVHlwZU5hbWU6IFwiS2xpcHBuaW5nc3R5cFwiLFxuXHRcdGNsaXBwaW5nR2VvbWV0cnlOYW1lOiBcIktsaXBwZXIgZ2VvbWV0cmkvcmFzdGVyXCIsXG5cdFx0ZXh0ZW50TmFtZTogXCJVdGRhdGF1dGJyZWRuaW5nXCIsXG5cdFx0dXNlSW5wdXRGZWF0dXJlR2VvbWV0cnlOYW1lOiBcIkFudsOkbmQgaW5kYXRhZ2Vvb2JqZWt0IGbDtnIgZ2VvbWV0cmlrbGlwcG5pbmdcIixcblx0XHRyZW1hcERlZmluaXRpb25UeXBlTmFtZTogXCJPbW1hcHBuaW5nc2RlZmluaXRpb25zdHlwXCIsXG5cdFx0aW5wdXRSYW5nZU5hbWU6IFwiSW5kYXRhaW50ZXJ2YWxsZXJcIixcblx0XHRvdXRwdXRWYWx1ZXNOYW1lOiBcIlV0ZGF0YXbDpHJkZW5cIixcblx0XHRub0RhdGFSYW5nZU5hbWU6IFwiTm9EYXRhLWludGVydmFsbGVyXCIsXG5cdFx0aW5wdXRGaWVsZE5hbWU6IFwiSW5kYXRhZsOkbHRcIixcblx0XHRvdXRwdXRGaWVsZE5hbWU6IFwiVXRkYXRhZsOkbHRcIixcblx0XHRpbnB1dE1heEZpZWxkTmFtZTogXCJJbmRhdGFtYXhmw6RsdCAodmFsZnJpdHQpXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVOYW1lOiBcIk9tbWFwcG5pbmdzdGFiZWxsdHlwXCIsXG5cdFx0YWxsb3dVbm1hdGNoZWROYW1lOiBcIlRpbGzDpXQgb21hdGNoYWRlIHBpeGVsdsOkcmRlblwiLFxuXHRcdGNoYW5nZU1pc3NpbmdWYWx1ZXNUb05vRGF0YU5hbWU6IFwiw4RuZHJhIHNha25hZGUgdsOkcmRlbiB0aWxsIE5vRGF0YVwiLFxuXHRcdHZpc2libGVCYW5kSUROYW1lOiBcIklEIGbDtnIgc3lubGlndCBiYW5kXCIsXG5cdFx0aW5mcmFyZWRCYW5kSUROYW1lOiBcIklEIGbDtnIgaW5mcmFyw7Z0dCBiYW5kXCIsXG5cdFx0c2NpZW50aWZpY091dHB1dE5hbWU6IFwiQXZhbmNlcmFkZSB1dGRhdGFcIixcblx0XHRiYW5kSW5kZXhlc05hbWU6IFwiQmFuZGluZGV4XCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIktvbnN0YW50XCIsXG5cdFx0d2VpZ2h0TmFtZTogXCJWaWt0XCIsXG5cdFx0bWluaW11bU5hbWU6IFwiTWluaW11bVwiLFxuXHRcdG1heGltdW1OYW1lOiBcIk1heGltYWx0XCIsXG5cdFx0c291cmNlRGF0YU5hbWU6IFwiS8OkbGxyYXN0ZXJcIixcblx0XHRzb3VyY2VGaWVsZE5hbWU6IFwiS8OkbGxmw6RsdFwiLFxuXHRcdGNvc3RSYXN0ZXJOYW1lOiBcIktvc3RuYWRzcmFzdGVyXCIsXG5cdFx0bWF4RGlzdGFuY2VOYW1lOiBcIk1heGltYWx0IGF2c3TDpW5kXCIsXG5cdFx0dmFsdWVSYXN0ZXJOYW1lOiBcIlbDpHJkZXJhc3RlclwiLFxuXHRcdGNvc3RNdWx0aXBsaWVyTmFtZTogXCJNdWx0aXBsaWthdG9yIGF0dCBhbnbDpG5kYSBww6Uga29zdG5hZGVyXCIsXG5cdFx0c3RhcnRDb3N0TmFtZTogXCJTdGFydGtvc3RuYWRcIixcblx0XHRhY2N1bUNvc3RSZXNpc3RhbmNlUmF0ZU5hbWU6IFwiQWNrdW11bGVyYWQgbml2w6UgYXYgbW90c3TDpW5kc2tvc3RuYWRcIixcblx0XHRjYXBhY2l0eU5hbWU6IFwiS2FwYWNpdGV0XCIsXG5cdFx0dHJhdmVsRGlyZWN0aW9uTmFtZTogXCJSZXNlcmlrdG5pbmdcIixcblx0XHRjZWxsU2l6ZU5hbWU6IFwiQ2VsbHN0b3JsZWtcIixcblx0XHRwb3B1bGF0aW9uRmllbGROYW1lOiBcIkJlZm9sa25pbmdzZsOkbHRcIixcblx0XHRhcmVhVW5pdHNOYW1lOiBcIkFyZWFlbmhldGVyXCIsXG5cdFx0b3V0cHV0VmFsdWVUeXBlTmFtZTogXCJVdGRhdGFjZWxsdsOkcmRlblwiLFxuXHRcdGJhcnJpZXJzTmFtZTogXCJJbmRhdGFoaW5kZXJcIixcblx0XHRkZXN0aW5hdGlvbkRhdGFOYW1lOiBcIkRlc3RpbmF0aW9uc3Jhc3RlclwiLFxuXHRcdGRlc3RpbmF0aW9uRmllbGROYW1lOiBcIkRlc3RpbmF0aW9uc2bDpGx0XCIsXG5cdFx0cGF0aFR5cGVOYW1lOiBcIlbDpGd0eXBcIixcblx0XHRvYnNlcnZlckZlYXR1cmVzTmFtZTogXCJPYnNlcnZhdMO2cnNnZW9vYmpla3RcIixcblx0XHRhbmFseXNpc01ldGhvZE5hbWU6IFwiQW5hbHlzbWV0b2RcIixcblx0XHRhbmFseXNpc1R5cGVOYW1lOiBcIkFuYWx5c3R5cFwiLFxuXHRcdHZlcnRpY2FsRXJyb3JOYW1lOiBcIlZlcnRpa2FsdCBmZWxcIixcblx0XHRyZWZyYWN0aXZpdHlDb2VmZmljaWVudE5hbWU6IFwiUmVmcmFrdGl2aXRldHNrb2VmZmljaWVudFwiLFxuXHRcdHN1cmZhY2VPZmZzZXROYW1lOiBcIll0ZsO2cnNranV0bmluZ1wiLFxuXHRcdG9ic2VydmVyRWxldmF0aW9uTmFtZTogXCJPYnNlcnZhdMO2cnNow7ZqZFwiLFxuXHRcdG9ic2VydmVyT2Zmc2V0TmFtZTogXCJPYnNlcnZhdMO2cnNmw7Zyc2tqdXRuaW5nXCIsXG5cdFx0aW5uZXJSYWRpdXNOYW1lOiBcIklucmUgcmFkaWVcIixcblx0XHRpbm5lclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiSW5uZXJyYWRpZW4gw6RyIDNELWF2c3TDpW5kZXRcIixcblx0XHRvdXRlclJhZGl1c05hbWU6IFwiWXR0cmUgcmFkaWVcIixcblx0XHRvdXRlclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiWXR0ZXJyYWRpZW4gw6RyIDNELWF2c3TDpW5kZXRcIixcblx0XHRob3Jpem9udGFsU3RhcnRBbmdsZU5hbWU6IFwiSG9yaXNvbnRlbGwgc3RhcnR2aW5rZWxcIixcblx0XHRob3Jpem9udGFsRW5kQW5nbGVOYW1lOiBcIkhvcmlzb250ZWxsIHNsdXR2aW5rZWxcIixcblx0XHR2ZXJ0aWNhbFVwcGVyQW5nbGVOYW1lOiBcIlZlcnRpa2FsIMO2dnJlIHZpbmtlbFwiLFxuXHRcdHZlcnRpY2FsTG93ZXJBbmdsZU5hbWU6IFwiVmVydGlrYWwgbmVkcmUgdmlua2VsXCIsXG5cdFx0em9uZURhdGFOYW1lOiBcIlpvbnJhc3RlclwiLFxuXHRcdHpvbmVGaWVsZE5hbWU6IFwiWm9uZsOkbHRcIixcblx0XHRpZ25vcmVOb0RhdGFOYW1lOiBcIklnbm9yZXJhIE5vRGF0YSBpIGJlcsOka25pbmdhclwiLFxuXHRcdHRlbXBlcmF0dXJlUmFzdGVyTmFtZTogXCJUZW1wZXJhdHVycmFzdGVyXCIsXG5cdFx0aW5UZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJUZW1wZXJhdHVyZW5oZXRlclwiLFxuXHRcdG91dEhlYXRJbmRleFRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlbDpHJtZWluZGV4ZW5oZXRlclwiLFxuXHRcdHJlbGF0aXZlSHVtaWRpdHlSYXN0ZXJOYW1lOiBcIlJhc3RlciBmw7ZyIHJlbGF0aXYgbHVmdGZ1a3RpZ2hldFwiLFxuXHRcdG91dFdpbmRDaGlsbFRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlZpbmRhdmt5bG5pbmdzZW5oZXRlclwiLFxuXHRcdHdpbmRTcGVlZFJhc3Rlck5hbWU6IFwiVmluZGhhc3RpZ2hldHNyYXN0ZXJcIixcblx0XHRpbldpbmRTcGVlZFVuaXRzTmFtZTogXCJWaW5kaGFzdGlnaGV0c2VuaGV0ZXJcIixcblx0XHR2YWx1ZU5hbWU6IFwiVsOkcmRlXCIsXG5cdFx0cHJvcGVydHlOYW1lOiBcIkVnZW5za2Fwc25hbW5cIixcblx0XHRqc29uTmFtZTogXCJNZXRhZGF0YS1KU09OXCIsXG5cdFx0em9uZVRhYmxlTmFtZTogXCJab25iYXNlcmFkIGF0dHJpYnV0dGFiZWxsXCIsXG5cdFx0YXR0cmlidXRlRmllbGROYW1lczogXCJBdHRyaWJ1dGbDpGx0bmFtblwiLFxuXHRcdGJhY2tncm91bmROYW1lOiBcIkJha2dydW5kc3bDpHJkZVwiLFxuXHRcdHdoZXJlQ2xhdXNlTmFtZTogXCJXaGVyZS1zYXRzXCIsXG5cdFx0bWluaW11bVZhbHVlRmllbGROYW1lOiBcIkbDpGx0bmFtbiBmw7ZyIG1pbmltaXbDpHJkZVwiLFxuXHRcdG1heGltdW1WYWx1ZUZpZWxkTmFtZTogXCJGw6RsdG5hbW4gZsO2ciBtYXhpbWl2w6RyZGVcIixcblx0XHRvdXRWYWx1ZUZpZWxkTmFtZTogXCJGw6RsdG5hbW4gZsO2ciB1dGRhdGF2w6RyZGVcIixcblx0XHRkZWZhdWx0VmFsdWVOYW1lOiBcIlN0YW5kYXJkdXRkYXRhdsOkcmRlXCIsXG5cdFx0Y29udmVyc2lvbk1hdHJpeE5hbWU6IFwiS29udmVydGVyaW5nc21hdHJpc1wiLFxuXHRcdElzUHNldWRvQ29sb3JPdXRwdXROYW1lOiBcIsOEciBlbiBwc2V1ZG9mw6RyZ3V0c2tyaWZ0XCIsXG5cdFx0dW5tYXBwZWRBc1JhbmRvbUNvbG9yTmFtZTogXCJUaWxsZGVsYSBmw6RyZyBzbHVtcHZpcyB0aWxsIG9meWxsZGEgcGl4bGFyXCIsXG5cdFx0ZGlzdGFuY2VNZXRob2ROYW1lOiBcIkF2c3TDpW5kc21ldG9kXCIsXG5cdFx0Zmxvd0RpclJhc3Rlck5hbWU6IFwiRmzDtmRlc3Jpa3RuaW5nc3Jhc3RlclwiLFxuXHRcdHBvdXJQb2ludE5hbWU6IFwiSMOkbGxwdW5rdHNyYXN0ZXJcIixcblx0XHRwb3VyUG9pbnRGaWVsZE5hbWU6IFwiSMOkbGxwdW5rdHNmw6RsdFwiLFxuXHRcdGNvbnN0YW50Wk5hbWU6IFwiS29uc3RhbnQgWlwiLFxuXHRcdHpPZmZzZXROYW1lOiBcIlotb2Zmc2V0XCIsXG5cdFx0Z2VvSWROYW1lOiBcIkdlb2lkXCIsXG5cdFx0Y2FsaWJyYXRpb25UeXBlTmFtZTogXCJLYWxpYnJlcmluZ3N0eXBcIixcblx0XHRmaWx0ZXJUeXBlTmFtZTogXCJGaWx0ZXJ0eXBcIixcblx0XHRmaWx0ZXJTaXplTmFtZTogXCJGaWx0ZXJzdG9ybGVrXCIsXG5cdFx0bm9pc2VNb2RlbE5hbWU6IFwiQnJ1c21vZGVsbFwiLFxuXHRcdG5vaXNlVmFyaWFuY2VOYW1lOiBcIkJydXN2YXJpYW5zXCIsXG5cdFx0YWRkaXRpdmVOb2lzZU1lYW5OYW1lOiBcIkFkZGl0aXZ0IGJydXNtZWRlbFwiLFxuXHRcdG11bHRpcGxpY2F0aXZlTm9pc2VNZWFuTmFtZTogXCJNdWx0aXBsaWthdGl2dCBicnVzbWVkZWxcIixcblx0XHRudW1iZXJvZkxvb2tzTmFtZTogXCJBbnRhbCBncmFuc2tuaW5nYXJcIixcblx0XHRkYW1waW5nRmFjdG9yTmFtZTogXCJEw6RtcG5pbmdzZmFrdG9yXCIsXG5cdFx0bWFza1Jhc3Rlck5hbWU6IFwiTWFza3Jhc3RlclwiLFxuXHRcdG5pYmJsZVZhbHVlc05hbWU6IFwiQW52w6RuZCBOb0RhdGEtdsOkcmRlbiBvbSBkZSDDpHIgZGVuIG7DpHJtYXN0ZSBncmFubmVuXCIsXG5cdFx0bmliYmxlTm9EYXRhTmFtZTogXCJOYWdnYSBOb0RhdGEtY2VsbGVyXCIsXG5cdFx0ekxpbWl0TmFtZTogXCJaLWJlZ3LDpG5zbmluZ1wiLFxuXHRcdGZsb3dEaXJlY3Rpb25UeXBlTmFtZTogXCJGbMO2ZGVzcmlrdG5pbmdzdHlwXCIsXG5cdFx0d2VpZ2h0UmFzdGVyTmFtZTogXCJWaWt0cmFzdGVyXCIsXG5cdFx0Zm9yY2VFZGdlTmFtZTogXCJUdmluZ2EgYWxsYSBrYW50Y2VsbGVyIGF0dCBmbMO2ZGEgdXTDpXRcIixcblx0XHRzdHJlYW1SYXN0ZXJOYW1lOiBcIlN0csO2bW5pbmdzcmFzdGVyXCIsXG5cdFx0c3VyZmFjZVJhc3Rlck5hbWU6IFwiWXRyYXN0ZXJcIixcblx0XHRjb252ZXJzaW9uVHlwZTogXCJLb252ZXJ0ZXJpbmdzdHlwXCIsXG5cdFx0ZGlzdGFuY2VSYXN0ZXIxOiBcIkF2c3TDpW5kc3Jhc3RlciAxXCIsXG5cdFx0ZGlzdGFuY2VSYXN0ZXIyOiBcIkF2c3TDpW5kc3Jhc3RlciAyXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyOiBcIlJhc3RlciBmw7ZyIGF2c3TDpW5kc2tvc3RuYWRcIixcblx0XHRjb3N0QmFja2xpbmtSYXN0ZXI6IFwiUmFzdGVyIGbDtnIgYmFrw6V0bMOkbmtza29zdG5hZFwiLFxuXHRcdG92ZXJyaWRlc05hbWU6IFwiw4VzaWRvc8OkdHRlclwiLFxuXHRcdGZpZWxkTmFtZTogXCJGw6RsdFwiLFxuXHRcdHNpZ25hdHVyZUZpbGVPclVybDogXCJTaWduYXR1cmZpbCBlbGxlciBVUkxcIixcblx0XHRyZWROYW1lOiBcIlLDtnR0XCIsXG5cdFx0Z3JlZW5OYW1lOiBcIkdyw7ZudFwiLFxuXHRcdGJsdWVOYW1lOiBcIkJsw6V0dFwiLFxuXHRcdGluZnJhcmVkTmFtZTogXCJJbmZyYXLDtnR0XCIsXG5cdFx0cGFuY2hyb21hdGljTmFtZTogXCJQYW5rcm9tYXRpc2tcIixcblx0XHRtdWx0aXNwZWN0cmFsTmFtZTogXCJNdWx0aXNwZWt0cmFsXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1R5cGU6IFwiVHlwIGF2IHBhbm9yZXJpbmdzc2vDpHJwbmluZ1wiLFxuXHRcdHNlbnNvck5hbWU6IFwiU2Vuc29yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZU5hbWU6IFwiR2VvZ3JhZmlzayByZWZlcmVuc1wiLFxuXHRcdHhDZWxsc2l6ZU5hbWU6IFwiWC1jZWxsc3Rvcmxla1wiLFxuXHRcdHlDZWxsc2l6ZU5hbWU6IFwiWS1jZWxsc3Rvcmxla1wiLFxuXHRcdHhPcmlnaW5OYW1lOiBcIlgtcmVnaXN0cmVyaW5nc3B1bmt0XCIsXG5cdFx0eU9yaWdpbk5hbWU6IFwiWS1yZWdpc3RyZXJpbmdzcHVua3RcIixcblx0XHRwZXJjZW50aWxlTmFtZTogXCJQZXJjZW50aWx2w6RyZGVcIixcblx0XHRuZWlnaGJvcmhvb2RUeXBlOiBcIkdyYW5uc2thcHN0eXBcIixcblx0XHR3aWR0aE5hbWU6IFwiQnJlZGRcIixcblx0XHRoZWlnaHROYW1lOiBcIkjDtmpkIMO2dmVyIG1hcmtlblwiLFxuXHRcdHN0YXJ0QW5nbGVOYW1lOiBcIlN0YXJ0dmlua2VsXCIsXG5cdFx0ZW5kQW5nbGVOYW1lOiBcIlNsdXR2aW5rZWxcIixcblx0XHRuZWlnaGJvcmhvb2RWYWx1ZXM6IFwiR3Jhbm5za2Fwc3bDpHJkZW5cIixcblx0XHRob3Jpem9udGFsUmFzdGVyOiBcIkhvcmlzb250ZWxsdCByYXN0ZXJcIixcblx0XHRob3Jpem9udGFsRmFjdG9yOiBcIkhvcmlzb250YWxmYWt0b3JcIixcblx0XHR2ZXJ0aWNhbFJhc3RlcjogXCJWZXJ0aWthbHQgcmFzdGVyXCIsXG5cdFx0dmVydGljYWxGYWN0b3I6IFwiVmVydGlrYWxmYWt0b3JcIixcblx0XHRzdHJlYW1SYXN0ZXI6IFwiU3Ryw7ZtbmluZ3NyYXN0ZXJcIixcblx0XHRmbG93RGlyUmFzdGVyOiBcIkZsw7ZkZXNyaWt0bmluZ3NyYXN0ZXJcIixcblx0XHRudW1iZXJOZWlnaGJvckNlbGxzOiBcIkFudGFsIGdyYW5uY2VsbGVyXCIsXG5cdFx0em9uZUNvbm5lY3Rpdml0eTogXCJab25hbnNsdXRuaW5nXCIsXG5cdFx0YWRkTGlua0JlaGF2aW9yOiBcIkzDpGdnIHRpbGwgbMOkbmtcIixcblx0XHRleGNsdWRlZFZhbHVlOiBcIlV0ZXNsdXRldCB2w6RyZGVcIixcblx0XHRjb25zdGFudEZpbGxDaGVjazogXCJHZW5lcmVyYSBmeWxsbmluZ3NyYXN0ZXIgZnLDpW4ga29uc3RhbnRcIixcblx0XHRmaWxsUmFzdGVyOiBcIkZ5bGxuaW5nc3Jhc3RlclwiLFxuXHRcdGNvbnN0YW50RmlsbFZhbHVlOiBcIktvbnN0YW50IHbDpHJkZVwiLFxuXHRcdGlucHV0Qml0UG9zaXRpb25zOiBcIkluZGF0YWJpdFwiLFxuXHRcdG91dHB1dEJpdFBvc2l0aW9uczogXCJVdGRhdGFiaXRcIixcblx0XHRkaXN0YW5jZVR5cGVOYW1lOiBcIkF2c3TDpW5kc3R5cFwiLFxuXHRcdGJhcnJpZXJEYXRhTmFtZTogXCJSYXN0ZXJoaW5kZXJcIixcblx0XHRwb3VyUG9pbnREYXRhTmFtZTogXCJIw6RsbHB1bmt0c3Jhc3RlclwiLFxuXHRcdGFjY3VtdWxhdGlvblJhc3Rlck5hbWU6IFwiRmzDtmRlc2Fja3VtdWxlcmluZ3NyYXN0ZXJcIixcblx0XHRzbmFwRGlzdGFuY2VOYW1lOiBcIlNuYXBwbmluZ3NhdnN0w6VuZFwiLFxuXHRcdG9yZGVyTWV0aG9kTmFtZTogXCJPcmRuaW5nc21ldG9kXCIsXG5cdFx0ZGlyZWN0aW9uTWVhc3VyZW1lbnROYW1lOiBcIk3DpHRuaW5nZW5zIHJpa3RuaW5nXCIsXG5cdFx0cHJvY2Vzc0FzTXVsdGliYW5kOiBcIkJlYXJiZXRhIHNvbSBtdWx0aWJhbmRcIixcblx0XHRwcm9jZXNzTXVsdGlkaW1lbnNpb25hbDogXCJCZWFyYmV0YSBmbGVyZGltZW5zaW9uZWxsdFwiLFxuXHRcdGZvcmNlRmxvd0RpcmVjdGlvbkNvbnZlbnRpb246IFwiVHZpbmdhIGZyYW0gZmzDtmRlc3Jpa3RuaW5nc2tvbnZlbnRpb24gZsO2ciBiYWvDpXRsw6Rua3Jhc3RlclwiLFxuXHRcdGluaXRpYWxBY2N1bXVsYXRpb246IFwiSW5sZWRhbmRlIGFja3VtdWxlcmluZ1wiLFxuXHRcdG1heGltdW1BY2N1bXVsYXRpb246IFwiTWF4aW1hbCBhY2t1bXVsZXJpbmdcIixcblx0XHRzb3VyY2VMb2NhdGlvbkJhbmRzOiBcIkdlbmVyZXJhIGvDpGxscmFkIG9jaCBrb2x1bW4gc29tIHl0dGVybGlnYXJlIGJhbmQgaSB1dGRhdGFcIixcblx0XHRiYWNrRGlyZWN0aW9uQmFuZDogXCJHZW5lcmVyYSB0aWxsYmFrYXJpa3RuaW5nIHNvbSBleHRyYSBiYW5kIGkgdXRkYXRhXCIsXG5cdFx0bnVtYmVyT2ZDZWxsczogXCJBbnRhbCBjZWxsZXJcIixcblx0XHR6b25lVmFsdWVzOiBcIlpvbnbDpHJkZW5cIixcblx0XHRzaHJpbmtNZXRob2Q6IFwiS3J5bXBtZXRvZFwiLFxuXHRcdGV4cGFuZE1ldGhvZDogXCJFeHBhbmRlcmluZ3NtZXRvZFwiLFxuXHRcdGlucHV0U3BlY3RyYWxQcm9maWxlVHlwZTogXCJTcGVrdHJhbCBwcm9maWx0eXBcIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlTmFtZTogXCJTcGVrdHJhbCBwcm9maWxcIixcblx0XHR0cmFpbmluZ0ZlYXR1cmVGaWxlTmFtZTogXCJUcsOkbmluZ3NnZW9vYmpla3RcIixcblx0XHRub25OZWdhdGl2ZTogXCJJY2tlLW5lZ2F0aXZ0XCIsXG5cdFx0c3VtVG9PbmU6IFwiU3VtbWEgdGlsbCBlblwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvbjogXCJEaXN0cmlidXRpb25cIixcblx0XHRtZWFuTmFtZTogXCJNZWRlbHbDpHJkZVwiLFxuXHRcdHByb2JhYmlsaXR5TmFtZTogXCJzYW5ub2xpa2hldFwiLFxuXHRcdGFscGhhTmFtZTogXCJBbGZhXCIsXG5cdFx0YmV0YU5hbWU6IFwiQmV0YXZlcnNpb25cIixcblx0XHRyTmFtZTogXCJyXCIsXG5cdFx0bk5hbWU6IFwiTlwiLFxuXHRcdHNlZWQ6IFwiU2VlZFwiLFxuXHRcdHJhbmRvbU51bWJlckdlbmVyYXRvcjogXCJTbHVtcHRhbHNnZW5lcmF0b3JcIixcblx0XHRjZWxsRmFjdG9yOiBcIkNlbGxmYWt0b3JcIixcblx0XHRhZ2dyZWdhdGlvblR5cGU6IFwiQWdncmVnZXJpbmdzdGVrbmlrXCIsXG5cdFx0ZXh0ZW50SGFuZGxpbmc6IFwiVXTDtmthIHV0YnJlZG5pbmdlbiB2aWQgYmVob3ZcIixcblx0XHR0cmVuZEFuYWx5c2lzRGltZW5zaW9uTmFtZTogXCJEaW1lbnNpb25zbmFtblwiLFxuXHRcdHRyZW5kQW5hbHlzaXNUeXBlOiBcIlRyZW5kdHlwXCIsXG5cdFx0aGFybW9uaWNGcmVxdWVuY3k6IFwiSGFybW9uaXNrIGZyZWt2ZW5zXCIsXG5cdFx0cG9seW5vbWlhbE9yZGVyOiBcIlBvbHlub21vcmRuaW5nXCIsXG5cdFx0Y3ljbGVMZW5ndGhOYW1lOiBcIkN5a2VsbMOkbmdkXCIsXG5cdFx0dHJlbmRBbmFseXNpc1JNU0U6IFwiUk1TRVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNSMjogXCJSLWt2YWRyYXRcIixcblx0XHR0cmVuZEFuYWx5c2lzU2xvcGVQVmFsdWU6IFwiUC12w6RyZGUgZsO2ciBsdXRuaW5nc2tvZWZmaWNpZW50XCIsXG5cdFx0dHJlbmRBbmFseXNpc1NlYXNvbmFsUGVyaW9kOiBcIsOFcnN0aWRzcGVyaW9kXCIsXG5cdFx0Y3ljbGVVbml0TmFtZTogXCJDeWtlbGVuaGV0XCIsXG5cdFx0cHJlZGljdERpbWVuc2lvblZhbHVlczogXCJWw6RyZGVuXCIsXG5cdFx0ZGltZW5zaW9uRGVmaW5pdGlvblR5cGU6IFwiRGltZW5zaW9uc2RlZmluaXRpb25cIixcblx0XHRwcmVkaWN0RGltZW5zaW9uU3RhcnQ6IFwiU3RhcnRcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uRW5kOiBcIlN0b3BwXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvbkludGVydmFsOiBcIlbDpHJkZWludGVydmFsbFwiLFxuXHRcdGRpbWVuc2lvblVuaXQ6IFwiRW5oZXRcIixcblx0XHRpbnRlcnBvbGF0aW9uQ2VsbHNpemVOYW1lOiBcIkludGVycG9sYXRpb25zY2VsbHN0b3JsZWtcIixcblx0XHR2YXJpYWJsZU5hbWU6IFwiVmFyaWFibGVyXCIsXG5cdFx0ZGltZW5zaW9ubGVzc05hbWU6IFwiVXRhbiBtw6V0dFwiLFxuXHRcdG1kaW1EZWZpbml0aW9uOiBcIkRpbWVuc2lvbnNkZWZpbml0aW9uXCIsXG5cdFx0ZGltZW5zaW9uTmFtZTogXCJNw6V0dFwiLFxuXHRcdGl0ZXJhdGlvblN0YXJ0OiBcIkLDtnJqYW4gYXYgZsO2cnN0YSBpdGVyYXRpb25lblwiLFxuXHRcdGl0ZXJhdGlvbkVuZDogXCJTbHV0ZXQgYXYgZsO2cnN0YSBpdGVyYXRpb25lblwiLFxuXHRcdGludGVydmFsU3RhcnQ6IFwiU3RhcnQgcMOlIGludGVydmFsbFwiLFxuXHRcdGludGVydmFsRW5kOiBcIlNsdXQgcMOlIGludGVydmFsbFwiLFxuXHRcdHN0ZXBOYW1lOiBcIlN0ZWdcIixcblx0XHRyYW5nZXNOYW1lOiBcIkludGVydmFsbFwiLFxuXHRcdG1pblZhbHVlOiBcIk1pbnN0YSB2w6RyZGVcIixcblx0XHRtYXhWYWx1ZTogXCJNYXhpbWFsdCB2w6RyZGVcIixcblx0XHRjaGFuZ2VBbmFseXNpc1Jhc3Rlck5hbWU6IFwiw4RuZHJhIGFuYWx5c3Jhc3RlclwiLFxuXHRcdGNoYW5nZVR5cGVOYW1lOiBcIsOEbmRyYSB0eXBcIixcblx0XHRzZWdtZW50RGF0ZTogXCJTZWdtZW50ZGF0dW1cIixcblx0XHRjaGFuZ2VEaXJlY3Rpb25OYW1lOiBcIsOEbmRyYSByaWt0bmluZ1wiLFxuXHRcdG1heE51bUNoYW5nZXNOYW1lOiBcIk1heGltYWx0IGFudGFsIGbDtnLDpG5kcmluZ2FyXCIsXG5cdFx0ZmlsdGVyQnlZZWFyOiBcIkZpbHRyZXJhIGVmdGVyIMOlclwiLFxuXHRcdG1pbmltdW1ZZWFyOiBcIk1pbnN0YSB2w6RyZGVcIixcblx0XHRtYXhpbXVtWWVhcjogXCJNYXhpbWFsdCB2w6RyZGVcIixcblx0XHRmaWx0ZXJCeUR1cmF0aW9uOiBcIkZpbHRyZXJhIGVmdGVyIHZhcmFrdGlnaGV0XCIsXG5cdFx0bWluaW11bUR1cmF0aW9uOiBcIkzDpGdzdGEgdmFyYWt0aWdoZXRcIixcblx0XHRtYXhpbXVtRHVyYXRpb246IFwiTWF4aW1hbCB2YXJha3RpZ2hldFwiLFxuXHRcdGZpbHRlckJ5TWFnbml0dWRlOiBcIkZpbHRyZXJhIGVmdGVyIG1hZ25pdHVkXCIsXG5cdFx0bWluaW11bU1hZ25pdHVkZTogXCJMw6Rnc3RhIG1hZ25pdHVkXCIsXG5cdFx0bWF4aW11bU1hZ25pdHVkZTogXCJNYXhpbWFsIG1hZ25pdHVkXCIsXG5cdFx0ZmlsdGVyQnlTdGFydFZhbHVlOiBcIkZpbHRyZXJhIGVmdGVyIHN0YXJ0dsOkcmRlXCIsXG5cdFx0bWluaW11bVN0YXJ0VmFsdWU6IFwiTWluaW1hbHQgc3RhcnR2w6RyZGVcIixcblx0XHRtYXhpbXVtU3RhcnRWYWx1ZTogXCJNYXhpbWFsdCBzdGFydHbDpHJkZVwiLFxuXHRcdGZpbHRlckJ5RW5kVmFsdWU6IFwiRmlsdHJlcmEgZWZ0ZXIgc2x1dHbDpHJkZVwiLFxuXHRcdG1pbmltdW1FbmRWYWx1ZTogXCJNaW5pbWFsdCBzbHV0dsOkcmRlXCIsXG5cdFx0bWF4aW11bUVuZFZhbHVlOiBcIk1heGltYWx0IHNsdXR2w6RyZGVcIixcblx0XHRtb2RlbFR5cGVOYW1lOiBcIk1vZGVsbHR5cFwiLFxuXHRcdGZyb21SYXN0ZXJOYW1lOiBcIkZyw6VuIHJhc3RlclwiLFxuXHRcdHRvUmFzdGVyTmFtZTogXCJUaWxsIHJhc3RlclwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VNZXRob2Q6IFwiTWV0b2QgZsO2ciBCZXLDpGtuYSBmw7Zyw6RuZHJpbmdcIixcblx0XHRmcm9tQ2xhc3NWYWx1ZXM6IFwiRnLDpW4ga2xhc3N2w6RyZGVuIChleGVtcGVsOiAyIDUpXCIsXG5cdFx0dG9DbGFzc1ZhbHVlczogXCJUaWxsIGtsYXNzdsOkcmRlbiAoZXhlbXBlbDogMiA1KVwiLFxuXHRcdGtlZXBNZXRob2Q6IFwiRmlsdGVybWV0b2RcIixcblx0XHR1c2VDb2xvck1ldGhvZDogXCJEZWZpbmllcmEgw7Z2ZXJnw6VuZ3Nmw6RyZ2VyXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlQmFuZHM6IFwiQmFuZCBmw7ZyIGF0dCBpZGVudGlmaWVyYSDDpG5kcmluZyAobWVkIGLDtnJqYW4gZnLDpW4gMClcIixcblx0XHR0bWFza0JhbmRzOiBcIkJhbmQgZsO2ciB0aWRzYmVzdMOkbWQgbWFza25pbmcgKG1lZCBiw7ZyamFuIGZyw6VuIDApXCIsXG5cdFx0Y2hpU3F1YXJlZFRocmVzaG9sZDogXCJDaGlrdmFkcmF0dHLDtnNrZWwgZsO2ciBJZGVudGlmaWVyYSBmw7Zyw6RuZHJpbmdhclwiLFxuXHRcdG1pbkFub21hbHk6IFwiTMOkZ3N0YSBhbnRhbCBzYW1tYW5ow6RuZ2FuZGUgYW5vbWFsaW9ic2VydmF0aW9uZXJcIixcblx0XHR1cGRhdGluZ0ZyZXF1ZW5jeTogXCJGcmVrdmVucyBmw7ZyIHVwZGF0ZXJpbmdzaW5wYXNzbmluZyAoaSDDpXIpXCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25SYXN0ZXJOYW1lOiBcIkF2c3TDpW5kc2Fja3VtdWxlcmluZ3NyYXN0ZXJcIixcblx0XHRjb3N0QmFja2RpcmVjdGlvblJhc3Rlck5hbWU6IFwiVGlsbGJha2FyaWt0bmluZ3MtIGVsbGVyIGZsw7ZkZXNyaWt0bmluZ3NyYXN0ZXJcIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uTmFtZTogXCJSYXN0ZXJzYW1saW5nXCIsXG5cdFx0aXRlbUZ1bmN0aW9uTmFtZTogXCJPYmpla3RmdW5rdGlvblwiLFxuXHRcdGFnZ3JlZ2F0aW9uRnVuY3Rpb25OYW1lOiBcIkFnZ3JlZ2VyaW5nc2Z1bmt0aW9uXCIsXG5cdFx0cHJvY2Vzc2luZ0Z1bmN0aW9uTmFtZTogXCJCZWFyYmV0YXIgZnVua3Rpb25cIixcblx0XHRhZ2dyZWdhdGlvbkRlZmluaXRpb25OYW1lOiBcIkFnZ3JlZ2VyaW5nc2RlZmluaXRpb25cIixcblx0XHRxdWVyeUdlb21ldHJ5TmFtZTogXCJGcsOlZ2VnZW9tZXRyaVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uWmVyb0ZhY3RvcjogXCJOb2xsZmFrdG9yXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25DdXRBbmdsZTogXCJLbGlwcHZpbmtlbFwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2lkZUZhY3RvcjogXCJTaWRvZmFrdG9yXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TbG9wZTogXCJMdXRuaW5nXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Mb3dDdXRBbmdsZTogXCJMw6VnIGtsaXBwdmlua2VsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25IaWdoQ3V0QW5nbGU6IFwiSMO2ZyBrbGlwcHZpbmtlbFwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zUG93ZXI6IFwiQ29zaW51cy1mYWt0b3JcIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY1Bvd2VyOiBcIlNla2FudC1mYWt0b3JcIixcblx0XHRmYWN0b3JGdW5jdGlvblRhYmxlUGF0aDogXCJUYWJlbGxzw7ZrdsOkZ1wiLFxuXHRcdHByb2Nlc3NpbmdCYW5kOiBcIkJlYXJiZXRhciBiYW5kXCIsXG5cdFx0cHJvY2Vzc2luZ0JhbmROYW1lOiBcIkJlYXJiZXRhciBiYW5kbmFtblwiLFxuXHRcdHNuYXBwaW5nRGF0ZTogXCJTbmFwcG5pbmdzZGF0dW1cIixcblx0XHRtYXhOdW1TZWdtZW50czogXCJNYXhpbWFsdCBhbnRhbCBzZWdtZW50XCIsXG5cdFx0dmVydGV4Q291bnRPdmVyc2hvb3Q6IFwiw5Z2ZXJzbMOkbmcgZsO2ciBhbnRhbGV0IGJyeXRwdW5rdGVyXCIsXG5cdFx0c3Bpa2VUaHJlc2hvbGQ6IFwiVHLDtnNrZWx2w6RyZGUgZsO2ciBhdnZpa2Vsc2VyXCIsXG5cdFx0cmVjb3ZlcnlUaHJlc2hvbGQ6IFwiVHLDtnNrZWx2w6RyZGUgZsO2ciDDpXRlcmjDpG10bmluZ1wiLFxuXHRcdG1pbk51bU9iczogXCJMw6Rnc3RhIGFudGFsIG9ic2VydmF0aW9uZXJcIixcblx0XHRwVmFsdWVUaHJlc2hvbGQ6IFwiVHLDtnNrZWx2w6RyZGUgZsO2ciBQLXbDpHJkZVwiLFxuXHRcdGJlc3RNb2RlbFByb3BvcnRpb246IFwiQsOkc3RhIG1vZGVsbHByb3BvcnRpb25cIixcblx0XHRwcmV2ZW50T25lWWVhclJlY292ZXJ5OiBcIkbDtnJoaW5kcmEgZXR0IMOlcnMgw6V0ZXJzdMOkbGxuaW5nXCIsXG5cdFx0cmVjb3ZlcnlJbmNyZWFzZVRyZW5kOiBcIsOFdGVyc3TDpGxsbmluZ2VuIGhhciBlbiDDtmthbmRlIHRyZW5kXCIsXG5cdFx0b3V0cHV0T3RoZXJCYW5kczogXCJNYXRhIHV0IGFuZHJhIGJhbmRcIixcblx0XHRzb3J0VHlwZTogXCJTb3J0ZXJpbmdzdHlwXCIsXG5cdFx0bnVtYmVyT2ZSdW5zOiBcIkvDtnIgZXhwYW5zaW9uIG9jaCBrcnltcG5pbmcgdHbDpSBnw6VuZ2VyXCIsXG5cdFx0cGVyY2VudGlsZVZhbHVlOiBcIlBlcmNlbnRpbHbDpHJkZVwiLFxuXHRcdHBlcmNlbnRpbGVJbnRlcnBvbGF0aW9uVHlwZTogXCJJbnRlcnBvbGVyaW5nc3R5cCBmw7ZyIHBlcmNlbnRpbFwiLFxuXHRcdHJhc3RlckluZm9Qcm9wZXJ0eTogXCJFZ2Vuc2thcFwiLFxuXHRcdHJhc3RlckluZm9WYWx1ZTogXCJWw6RyZGVcIixcblx0XHRyYXN0ZXJJbmZvQ29sdW1uczogXCJLb2x1bW5lclwiLFxuXHRcdHJhc3RlckluZm9Sb3dzOiBcIlJhZGVyXCIsXG5cdFx0cmFzdGVySW5mb0JhbmRDb3VudDogXCJBbnRhbCBiYW5kXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsU2l6ZVg6IFwiQ2VsbHN0b3JsZWsgWFwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFNpemVZOiBcIkNlbGxzdG9ybGVrIFlcIixcblx0XHRyYXN0ZXJJbmZvUGl4ZWxUeXBlOiBcIlBpeGVsdHlwXCIsXG5cdFx0cmFzdGVyRXh0ZW50VG9wOiBcIsOWdnJlXCIsXG5cdFx0cmFzdGVyRXh0ZW50Qm90dG9tOiBcIkzDpG5nc3QgbmVkXCIsXG5cdFx0cmFzdGVyRXh0ZW50TGVmdDogXCJWw6Ruc3RlclwiLFxuXHRcdHJhc3RlckV4dGVudFJpZ2h0OiBcIkjDtmdlclwiLFxuXHRcdHJhc3RlclN0YXRpc3RpY3NOb3RDYWxjdWxhdGVkOiBcIlN0YXRpc3Rpa2VuIGhhciBpbnRlIGJlcsOka25hdHMuXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVByb2plY3Rpb246IFwiUHJvamVrdGlvblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa2lkOiBcIldLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0V2tpZDogXCJGw7ZyZWfDpWVuZGUgV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa3Q6IFwiV0tUXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVZjc1draWQ6IFwiVkNTV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRlc3RWY3NXa2lkOiBcIkbDtnJlZ8OlZW5kZSBWQ1NXS0lEXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUF1dGhvcml0eTogXCJVdGbDpHJkYXJlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxpbmVhclVuaXQ6IFwiTGluasOkciBlbmhldFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBbmd1bGFyVW5pdDogXCJWaW5rZWxlbmhldFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VGYWxzZUVhc3Rpbmc6IFwiRmFsc2sgb3N0bGlnIGt1cnNcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VOb3J0aGluZzogXCJGYWxzayBub3JkbGlnIGt1cnNcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQ2VudHJhbE1lcmlkaWFuOiBcIkNlbnRyYWxtZXJlZGlhblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VQcmltZU1lcmlkaWFuOiBcIk5vbGxtZXJpZGlhblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTdGFuZGFyZFBhcmFsbGVsMTogXCJTdGFuZGFyZHBhcmFsbGVsbCAxXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVN0YW5kYXJkUGFyYWxsZWwyOiBcIlN0YW5kYXJkcGFyYWxsZWxsIDJcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0aXR1ZGVPZk9yaWdpbjogXCJVcnNwcnVuZ3NsYXRpdHVkXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUF1eGlsaWFyeVNwaGVyZVR5cGU6IFwiVHlwIGF2IHRpbGzDpGdnc3Nmw6RyXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZURhdHVtOiBcIkRhdHVtXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNwaGVyb2lkOiBcIlJvdGF0aW9uc2VsbGlwc29pZFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTZW1pbWFqb3JBeGlzOiBcIkhhbHYgc3RvcmF4ZWxcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU2VtaW1pbm9yQXhpczogXCJIYWx2IGxpbGxheGVsXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUludmVyc2VGbGF0dGVuaW5nOiBcIkludmVydGVyYWQgYXZwbGF0dG5pbmdcIixcblx0XHRpbnB1dERlZmluaXRpb25GaWxlTmFtZTogXCJJbmRhdGFkZWZpbml0aW9uc2ZpbFwiLFxuXHRcdGRlbGV0ZU5hbWU6IFwiVGEgYm9ydFwiLFxuXHRcdGFkZFZhcmlhYmxlTmFtZTogXCJMw6RnZyB0aWxsIHZhcmlhYmVsXCIsXG5cdFx0bWF4TnVtUGl4ZWxzUGVyU2VnbWVudDogXCJNYXhpbWFsIHNlZ21lbnRzdG9ybGVrIGkgcGl4bGFyXCIsXG5cdFx0Zm9yd2FyZFdpbmRvd05hbWU6IFwiRsO2bnN0ZXIgZnJhbcOldFwiLFxuXHRcdGJhY2t3YXJkV2luZG93TmFtZTogXCJGw7Zuc3RlciBiYWvDpXRcIixcblx0XHRub0RhdGFIYW5kbGluZ05hbWU6IFwiTm9EYXRhLWhhbnRlcmluZ1wiLFxuXHRcdGNpcmN1bGFyV3JhcFZhbHVlTmFtZTogXCJDaXJrdWzDpHJ0IHJhZGJyeXRuaW5nc3bDpHJkZVwiLFxuXHRcdGZyb21DbGFzc05hbWVGaWVsZE5hbWU6IFwiRsOkbHRuYW1uIGbDtnIga2xhc3NuYW1uIGkgRnLDpW4gcmFzdGVyXCIsXG5cdFx0dG9DbGFzc05hbWVGaWVsZE5hbWU6IFwiRsOkbHRuYW1uIGbDtnIga2xhc3NuYW1uIGkgVGlsbCByYXN0ZXJcIixcblx0XHR0YXJnZXRSYXN0ZXJOYW1lOiBcIk3DpWxyYXN0ZXJcIixcblx0XHRjaXJjdWxhcldyYXBWYWx1ZTogXCJDaXJrdWzDpHJ0IHJhZGJyeXRuaW5nc3bDpHJkZVwiLFxuXHRcdGJhbmRJbmRleGVzUjogXCJSw7Z0dCB1dHRyeWNrXCIsXG5cdFx0YmFuZEluZGV4ZXNHOiBcIkdyw7ZudCB1dHRyeWNrXCIsXG5cdFx0YmFuZEluZGV4ZXNCOiBcIkJsw6V0dCB1dHRyeWNrXCIsXG5cdFx0ZXhhbXBsZU5hbWU6IFwiRXhlbXBlbFwiLFxuXHRcdGlucHV0TmFtZTogXCJJbmRhdGFcIixcblx0XHRvdXRwdXROYW1lOiBcIlV0ZGF0YVwiLFxuXHRcdG9wdGlvbmFsTmFtZTogXCJWYWxmcml0dFwiLFxuXHRcdGJyb3dzZURlZmluaXRpb25GaWxlOiBcIkJsw6RkZHJhIGVmdGVyIGRlZmluaXRpb25zZmlsXCIsXG5cdFx0c2VsZWN0RGVmaW5pdGlvbkZpbGU6IFwiVsOkbGogaW5kYXRhZGVmaW5pdGlvbnNmaWxcIixcblx0XHRpbnB1dERlZmluaXRpb25VUkw6IFwiSW5kYXRhZGVmaW5pdGlvbnNmaWwtVVJMXCIsXG5cdFx0ZW50ZXJEZWZpbml0aW9uRmlsZVVSTDogXCJBbmdlIGRlc3RpbmF0aW9uc2ZpbC1VUkxcIixcblx0XHRicm93c2VYTUxGaWxlOiBcIkJsw6RkZHJhIGVmdGVyIFhNTC1maWxcIixcblx0XHRzZWxlY3RTdGF0c0ZpbGU6IFwiVsOkbGogc3RhdGlzdGlrLSBvY2ggaGlzdG9ncmFtZmlsXCIsXG5cdFx0ZW50ZXJYTUxGaWxlVVJMOiBcIkFuZ2UgWE1MLWZpbC1VUkxcIixcblx0XHR4bWxGaWxlVVJMOiBcIlhNTC1maWwtVVJMXCIsXG5cdFx0Y2lyY3VsYXJDYWxjdWxhdGlvbjogXCJCZXLDpGtuYSBjaXJrdWzDpHIgc3RhdGlzdGlrXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZTogXCJMb2thbCB5dHR5cFwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJUeXBlOiBcIlBhcmFtZXRlcnR5cFwiLFxuXHRcdG5laWdoYm9yaG9vZERpc3RhbmNlOiBcIkF2c3TDpW5kIG7DpHJvbXLDpWRlXCIsXG5cdFx0dXNlQWRhcHRpdmVOZWlnaGJvcmhvb2Q6IFwiQW52w6RuZCBhZGFwdGl2dCBuw6Ryb21yw6VkZVwiLFxuXHRcdG91dHB1dFNsb3BlVHlwZTogXCJVdGRhdGFsdXRuaW5nc23DpHRuaW5nXCIsXG5cdFx0cHJvamVjdEF6aW11dGhzOiBcIkdlb2RldGlza2EgYXppbXV0ZXIgZsO2ciBwcm9qZWt0XCIsXG5cdFx0dXNlRXF1YXRvcmlhbEFzcGVjdDogXCJBbnbDpG5kIGVrdmF0b3JpZWxsIGFzcGVrdFwiLFxuXHRcdHpVbml0OiBcIlotZW5oZXRcIixcblx0XHRhbmFseXNpc01hc2s6IFwiQW5hbHlzbWFza1wiLFxuXHRcdHN0ZERldmlhdGlvbjogXCJTdGFuZGFyZGF2dmlrZWxzZVwiLFxuXHRcdFwidHJ1ZVwiOiBcIlNhbnRcIixcblx0XHRcImZhbHNlXCI6IFwiRmFsc2t0XCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMTogXCJJbmRhdGFyYXN0ZXIgZsO2ciBhY2t1bXVsZXJhZCBhdnN0w6VuZHNrb3N0bmFkIDFcIixcblx0XHRjb3N0RGlzdGFuY2VSYXN0ZXIyOiBcIkluZGF0YXJhc3RlciBmw7ZyIGFja3VtdWxlcmFkIGF2c3TDpW5kc2tvc3RuYWQgMlwiLFxuXHRcdHRocmVzaG9sZDogXCJUcsO2c2tlbFwiLFxuXHRcdHRocmVzaG9sZE1ldGhvZDogXCJUcsO2c2tlbG1ldG9kXCIsXG5cdFx0ZGlyZWN0aW9uUmFzdGVyMTogXCJJbmRhdGF0aWxsYmFrYWbDtnJkZWxuaW5nc3Jhc3RlciAxXCIsXG5cdFx0ZGlyZWN0aW9uUmFzdGVyMjogXCJJbmRhdGF0aWxsYmFrYWbDtnJkZWxuaW5nc3Jhc3RlciAyXCIsXG5cdFx0bWF4SXRlcmF0aW9uczogXCJNYXhpbWFsdCBhbnRhbCB1cHByZXBuaW5nYXJcIixcblx0XHRlcHNpbG9uOiBcIkVwc2lsb25cIlxuXHR9LFxuXHRlbnVtTGFiZWxzOiB7XG5cdFx0YXR0cmlidXRlVGFibGVUeXBlTWFudWFsOiBcIk1hbnVlbGxcIixcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVFeHRlcm5hbDogXCJFeHRlcm5cIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JtYXA6IFwiRsOkcmdzY2hlbWFcIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JSYW1wOiBcIkbDpHJncmFtcFwiLFxuXHRcdGNvbG9ybWFwVHlwZUVsZXZhdGlvbjogXCJIw7ZqZCDDtnZlciBoYXZldFwiLFxuXHRcdGNvbG9ybWFwVHlwZUdyYXk6IFwiR3LDpVwiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkk6IFwiTkRWSVwiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkkyOiBcIk5EVkkyXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTM6IFwiTkRWSTNcIixcblx0XHRjb2xvcm1hcFR5cGVSYW5kb206IFwiU2x1bXBtw6Rzc2lnXCIsXG5cdFx0bm9uZTogXCJJbmdhXCIsXG5cdFx0c2xvcGVUeXBlQWRqdXN0ZWQ6IFwiSnVzdGVyYWRcIixcblx0XHRzbG9wZVR5cGVEZWdyZWU6IFwiR3JhZFwiLFxuXHRcdHNsb3BlVHlwZVBlcmNlbnRSaXNlOiBcIlByb2NlbnTDtmtuaW5nXCIsXG5cdFx0c2xvcGVUeXBlU2NhbGVkOiBcIlNrYWxhZFwiLFxuXHRcdHN0cmV0Y2hUeXBlTWluTWF4OiBcIk1pbk1heFwiLFxuXHRcdHN0cmV0Y2hUeXBlUGVyY2VudE1pbk1heDogXCJQZXJjZW50TWluTWF4XCIsXG5cdFx0c3RyZXRjaFR5cGVTaWdtb2lkOiBcIlNpZ21vaWRcIixcblx0XHRzdHJldGNoVHlwZVN0ZERldjogXCJTdGREZXZcIixcblx0XHRoaWxsc2hhZGVUeXBlU2ltcGxlOiBcIlRyYWRpdGlvbmVsbFwiLFxuXHRcdGhpbGxzaGFkZVR5cGVNdWx0aWRpcmVjdGlvbmFsOiBcIkZsZXJyaWt0YWRcIixcblx0XHRiYW5kQ29tYm9CeU5hbWVzOiBcIkJhbmRuYW1uXCIsXG5cdFx0YmFuZENvbWJvQnlXYXZlbGVuZ3RoOiBcIkJhbmR2w6VnbMOkbmdkZXJcIixcblx0XHRiYW5kQ29tYm9CeUlEczogXCJCYW5kaWRlbnRpZmllcmFyZVwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uQmVzdE1hdGNoOiBcIkLDpHN0YSBtYXRjaG5pbmdcIixcblx0XHRtaXNzaW5nQmFuZEFjdGlvbkZhaWw6IFwiTWlzc2x5Y2thZFwiLFxuXHRcdHVuaXRUeXBlQ2Vsc2l1czogXCJDZWxzaXVzXCIsXG5cdFx0dW5pdFR5cGVDZW50aW1ldGVyczogXCJDZW50aW1ldGVyXCIsXG5cdFx0dW5pdFR5cGVEZWNpbWV0ZXJzOiBcIkRlY2ltZXRlclwiLFxuXHRcdHVuaXRUeXBlRmFocmVuaGVpdDogXCJGYWhyZW5oZWl0XCIsXG5cdFx0dW5pdFR5cGVGZWV0OiBcIkZvdFwiLFxuXHRcdHVuaXRUeXBlRmVldFBlclNlYzogXCJGb3QgcGVyIHNla3VuZCAoZnQvcylcIixcblx0XHR1bml0VHlwZUluY2hlczogXCJUdW1cIixcblx0XHR1bml0VHlwZUtlbHZpbjogXCJLZWx2aW5cIixcblx0XHR1bml0VHlwZUtpbG9tZXRlcnM6IFwiS2lsb21ldGVyXCIsXG5cdFx0dW5pdFR5cGVLbXNQZXJIb3VyOiBcIktpbG9tZXRlciBpIHRpbW1lbiAoa20vaClcIixcblx0XHR1bml0VHlwZUtub3RzOiBcIktub3AgKGtuKVwiLFxuXHRcdHVuaXRUeXBlTWV0ZXJzOiBcIk1ldGVyXCIsXG5cdFx0dW5pdFR5cGVNZXRlcnNQZXJTZWM6IFwiTWV0ZXIgcGVyIHNla3VuZCAobS9zKVwiLFxuXHRcdHVuaXRUeXBlTWlsZXM6IFwiTWlsZVwiLFxuXHRcdHVuaXRUeXBlTWlsZXNQZXJIb3VyOiBcIk1pbGVzIGkgdGltbWVuIChtcGgpXCIsXG5cdFx0dW5pdFR5cGVNaWxsaW1ldGVyczogXCJNaWxsaW1ldHJhclwiLFxuXHRcdHVuaXRUeXBlTmF1dGljYWxNaWxlczogXCJOYXV0aXNrYSBtaWxcIixcblx0XHR1bml0VHlwZVlhcmRzOiBcIllhcmRcIixcblx0XHR1bml0VHlwZURlY2ltYWxEZWdyZWVzOiBcIkRlY2ltYWxncmFkZXJcIixcblx0XHR1bml0VHlwZVBvaW50czogXCJQdW5rdGVyXCIsXG5cdFx0dW5pdFR5cGVVbmtub3duOiBcIk9rw6RudFwiLFxuXHRcdHVuaXRUeXBlU3FNYXBVbml0czogXCJLYXJ0YW5zIGt2YWRyYXRlbmhldGVyXCIsXG5cdFx0dW5pdFR5cGVTcU1pbGVzOiBcIkt2YWRyYXRtaWwgKGVuZ2Vsc2thKVwiLFxuXHRcdHVuaXRUeXBlU3FLbXM6IFwiS3ZhZHJhdGtpbG9tZXRlclwiLFxuXHRcdHVuaXRUeXBlQWNyZXM6IFwiVHVubmxhbmRcIixcblx0XHR1bml0VHlwZUhlY3RhcmVzOiBcIkhla3RhclwiLFxuXHRcdHVuaXRUeXBlU3FZYXJkczogXCJTcXVhcmUgWWFyZHNcIixcblx0XHR1bml0VHlwZVNxRnQ6IFwiS3ZhZHJhdGZvdFwiLFxuXHRcdHVuaXRUeXBlU3FJbmNoZXM6IFwiS3ZhZHJhdHR1bVwiLFxuXHRcdHVuaXRUeXBlU3FNdHM6IFwiS3ZhZHJhdG1ldGVyXCIsXG5cdFx0dW5pdFR5cGVTcUNtczogXCJLdmFkcmF0Y2VudGltZXRlclwiLFxuXHRcdHVuaXRUeXBlU3FNbXM6IFwiS3ZhZHJhdG1pbGxpbWV0ZXJcIixcblx0XHRjZWxsc2l6ZVR5cGVGaXJzdDogXCJGw7Zyc3RhIGF2XCIsXG5cdFx0Y2VsbHNpemVUeXBlTWluOiBcIk1pbiBhdlwiLFxuXHRcdGNlbGxzaXplVHlwZU1heDogXCJNYXggYXZcIixcblx0XHRjZWxsc2l6ZVR5cGVNZWFuOiBcIk1lZGVsdsOkcmRlIGF2XCIsXG5cdFx0Y2VsbHNpemVUeXBlTGFzdDogXCJTaXN0YSBhdlwiLFxuXHRcdGV4dGVudFR5cGVGaXJzdDogXCJGw7Zyc3RhIGF2XCIsXG5cdFx0ZXh0ZW50VHlwZUludGVyc2VjdGlvbjogXCJTa8Okcm5pbmcgYXZcIixcblx0XHRleHRlbnRUeXBlVW5pb246IFwiVW5pb24gYXZcIixcblx0XHRleHRlbnRUeXBlTGFzdDogXCJTaXN0YSBhdlwiLFxuXHRcdG5vRGF0YUludGVycHJldEFueTogXCJNYXRjaGEgbsOlZ290XCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QWxsOiBcIk1hdGNoYSBhbGxhXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVN0YW5kYXJkOiBcIlN0YW5kYXJkXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVByb2ZpbGU6IFwiUHJvZmlsXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVBsYW5mb3JtOiBcIlBsYW5mb3JtXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25Ib3Jpem9udGFsOiBcIkxpbmplaWRlbnRpZmllcmluZyBob3Jpc29udGVsbFwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uVmVydGljYWw6IFwiTGluamVpZGVudGlmaWVyaW5nIHZlcnRpa2FsXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25MZWZ0RGlhZ29uYWw6IFwiTGluamVpZGVudGlmaWVyaW5nIHbDpG5zdGVyIGRpYWdvbmFsXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25SaWdodERpYWdvbmFsOiBcIkxpbmplaWRlbnRpZmllcmluZyBow7ZnZXIgZGlhZ29uYWxcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aDogXCJUb25pbmcgbm9yZFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudFdlc3Q6IFwiVG9uaW5nIHbDpHN0XCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50RWFzdDogXCJUb25pbmcgb3N0XCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50U291dGg6IFwiVG9uaW5nIHN5ZFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudE5vcnRoRWFzdDogXCJUb25pbmcgbm9yZG9zdFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudE5vcnRoV2VzdDogXCJUb25pbmcgbm9yZHbDpHN0XCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aEFyaXRobWV0aWNNZWFuOiBcIkrDpG1udCBhcml0bWV0aXNrdCBtZWRlbHbDpHJkZVwiLFxuXHRcdGZpbHRlclR5cGVTbW9vdGhpbmczeDM6IFwiVXRqw6RtbmluZyAzeDNcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoaW5nNXg1OiBcIlV0asOkbW5pbmcgNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW5pbmczeDM6IFwiU2vDpHJwbmluZyAzeDNcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbmluZzV4NTogXCJTa8OkcnBuaW5nIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVMYXBsYWNpYW4zeDM6IFwiTGFwbGFjZSAzeDNcIixcblx0XHRmaWx0ZXJUeXBlTGFwbGFjaWFuNXg1OiBcIkxhcGxhY2UgNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZVNvYmVsSG9yaXpvbnRhbDogXCJTb2JlbCBob3Jpc29udGVsbFwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbFZlcnRpY2FsOiBcIlNvYmVsIHZlcnRpa2FsXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW46IFwiR8O2ciBza2FycGFyZVwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuMjogXCJTa8OkcnAgbWVyXCIsXG5cdFx0ZmlsdGVyVHlwZVBvaW50U3ByZWFkOiBcIlB1bmt0c3ByaWRuaW5nXCIsXG5cdFx0dXNlckRlZmluZWQ6IFwiQW52w6RuZGFyZGVmaW5pZXJhZFwiLFxuXHRcdENvbnRvdXJUeXBlTGluZXM6IFwiSMO2amRrdXJ2ZWxpbmplclwiLFxuXHRcdENvbnRvdXJUeXBlRmlsbDogXCJIw7ZqZGt1cnZlZnlsbG5pbmdcIixcblx0XHRDb250b3VyVHlwZVNtb290aE9ubHk6IFwiRW5kYXN0IGrDpG1uIHl0YVwiLFxuXHRcdHJhc3Rlcml6ZUZpcnN0OiBcIkbDtnJzdGFcIixcblx0XHRyYXN0ZXJpemVMYXN0OiBcIlNpc3RhXCIsXG5cdFx0cmFzdGVyaXplU21hbGxlc3Q6IFwiTWluc3RhXCIsXG5cdFx0cmFzdGVyaXplTGFyZ2VzdDogXCJTdMO2cnN0YVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmVhcmVzdDogXCJOw6RybXN0YSBncmFubmVcIixcblx0XHRyZXNhbXBsaW5nVHlwZUJpbGluZWFyOiBcIkJpbGluasOkciBpbnRlcnBvbGVyaW5nXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVDdWJpYzogXCJLdWJpc2sgaW50ZXJwb2xhdGlvblwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWFqb3JpdHk6IFwiTWFqb3JpdGV0XCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhclBsdXM6IFwiQmlsaW5qw6RyIGludGVycG9sZXJpbmcgcGx1c1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlR2F1c3M6IFwiR2F1c3Npc2sgb3Nrw6RycGFcIixcblx0XHRyZXNhbXBsaW5nVHlwZUdhdXNzUGx1czogXCJHYXVzc2lzayBvc2vDpHJwYSBwbHVzXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVBdmVyYWdlOiBcIkdlbm9tc25pdHRcIixcblx0XHRyZXNhbXBsaW5nVHlwZU1pbmltdW06IFwiTWluaW11bVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWF4aW11bTogXCJNYXhpbWFsdFwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlVmVjdG9yQXZnOiBcIlZla3Rvcmdlbm9tc25pdHRcIixcblx0XHRtaW5pbXVtOiBcIk1pbmltdW1cIixcblx0XHRtYXhpbXVtOiBcIk1heGltYWx0XCIsXG5cdFx0bWVhbjogXCJNZWRlbHbDpHJkZVwiLFxuXHRcdHN0ZERldmlhdGlvbjogXCJTdGFuZGFyZGF2dmlrZWxzZVwiLFxuXHRcdHV2TWFnRGlyVHlwZVVWOiBcIlUtVlwiLFxuXHRcdHV2TWFnRGlyVHlwZU1hZ0RpcjogXCJNYWduaXR1ZC1yaWt0bmluZ1wiLFxuXHRcdHVua25vd246IFwiT2vDpG50XCIsXG5cdFx0YW5nbGVSZWZTeXNHZW9ncmFwaGljOiBcIkdlb2dyYWZpc2thXCIsXG5cdFx0YW5nbGVSZWZTeXNBcml0aG1ldGljOiBcIkFyaXRtZXRpc2t0XCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmVhcmVzdDogXCJOw6RybXN0YSBncmFubmVcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFCaWxpbmVhcjogXCJCaWxpbmrDpHJcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFUaW5uaW5nTGluZWFyOiBcIkxpbmrDpHIgdGlubmluZ1wiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdOYXR1cmFsTmVpZ2hib3I6IFwiTmF0dXJsaWcgZ3Jhbm5lXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhVGlubmluZ0lEVzogXCJJbnZlcnRlcmF0IHZpa3RhdCBhdnN0w6VuZFwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlQ29uc3RhbnQ6IFwiS29uc3RhbnRcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZU90c3U6IFwiT3RzdVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlVHNhaTogXCJUc2FpXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVLYXB1cjogXCJLYXB1clwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlS2l0dGxlcjogXCJLaXR0bGVyXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVSb3NpbjogXCJSb3NpblwiLFxuXHRcdGFyZ1N0YXRzVHlwZU1heDogXCJBcmcgbWF4XCIsXG5cdFx0YXJnU3RhdHNUeXBlTWluOiBcIkFyZyBtaW5cIixcblx0XHRhcmdTdGF0c1R5cGVNZWRpYW46IFwiQXJnIG1lZGlhblwiLFxuXHRcdGFyZ1N0YXRzVHlwZUR1cmF0aW9uOiBcIlZhcmFrdGlnaGV0XCIsXG5cdFx0YXJpdGhtZXRpY09wUGx1czogXCJQbHVzXCIsXG5cdFx0YXJpdGhtZXRpY09wTWludXM6IFwiTWludXNcIixcblx0XHRhcml0aG1ldGljT3BNdWx0aXBseTogXCJNdWx0aXBsaWNlcmFcIixcblx0XHRhcml0aG1ldGljT3BEaXZpZGU6IFwiRsO2cmRlbGFcIixcblx0XHRhcml0aG1ldGljT3BQb3dlcjogXCJQb3RlbnNcIixcblx0XHRhcml0aG1ldGljT3BNb2RlOiBcIkzDpGdlXCIsXG5cdFx0Y2xpcFR5cGVPdXRzaWRlOiBcIktsaXBwIHV0YW5mw7ZyXCIsXG5cdFx0Y2xpcFR5cGVJbnNpZGU6IFwiS2xpcHAgaW5uYW5mw7ZyXCIsXG5cdFx0eWVzOiBcIkphXCIsXG5cdFx0bm86IFwiTmVqXCIsXG5cdFx0ZGVuc2l0aWVzOiBcIkRlbnNpdGV0ZXJcIixcblx0XHRleHBlY3RlZENvdW50czogXCJGw7ZydsOkbnRhZGUgYW50YWxcIixcblx0XHRwbGFuYXI6IFwiUGxhblwiLFxuXHRcdGdlb2Rlc2ljOiBcIkdlb2RldGlza1wiLFxuXHRcdGVhY2hDZWxsOiBcIlZhcmplIGNlbGxcIixcblx0XHRlYWNoWm9uZTogXCJWYXJqZSB6b25cIixcblx0XHRiZXN0U2luZ2xlOiBcIkLDpHN0YSBlbnNraWxkYVwiLFxuXHRcdGFsbFNpZ2h0bGluZXM6IFwiQWxsYSBzaWt0bGluamVyXCIsXG5cdFx0cGVyaW1ldGVyU2lnaHRsaW5lczogXCJTaWt0bGluamVyIGbDtnIgb21rcmV0c1wiLFxuXHRcdGZyZXF1ZW5jeTogXCJGcmVrdmVuc1wiLFxuXHRcdG9ic2VydmVyczogXCJPYnNlcnZhdMO2cmVyXCIsXG5cdFx0bWFqb3JpdHk6IFwiTWFqb3JpdGV0XCIsXG5cdFx0bWVkaWFuOiBcIk1lZGlhblwiLFxuXHRcdG1pbm9yaXR5OiBcIk1pbm9yaXRldFwiLFxuXHRcdHBlcmNlbnRpbGU6IFwiUGVyY2VudGlsXCIsXG5cdFx0cmFuZ2U6IFwiSW50ZXJ2YWxsXCIsXG5cdFx0c3VtOiBcIlN1bW1hXCIsXG5cdFx0dmFyaWV0eTogXCJWYXJpYXRpb25cIixcblx0XHRuZHZpOiBcIk5EVklcIixcblx0XHRzYXZpOiBcIlNBVklcIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZFRTQVZJOiBcIlRyYW5zZm9ybWVyYWQgU0FWSVwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kTVNBVkk6IFwiTW9kaWZpZXJhZCBTQVZJXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNNZXRob2RTdWx0YW46IFwiU3VsdGFucyBmb3JtZWxcIixcblx0XHRnZW1pOiBcIkdFTUlcIixcblx0XHRwdmk6IFwiUFZJXCIsXG5cdFx0Z3ZpOiBcIkdWSSAoTGFuZHNhdCBUTSlcIixcblx0XHR2YXJpOiBcIlZBUklcIixcblx0XHRzcjogXCJTUlwiLFxuXHRcdGduZHZpOiBcIkdORFZJXCIsXG5cdFx0bmR2aXJlOiBcIk5EVklyZVwiLFxuXHRcdHNycmU6IFwiU1JyZVwiLFxuXHRcdG10dmkyOiBcIk1UVkkyXCIsXG5cdFx0cnR2aUNvcmU6IFwiUlRWSWNvcmVcIixcblx0XHRjaXJlOiBcIkNJcmVcIixcblx0XHRjaWc6IFwiQ0lnXCIsXG5cdFx0bmR3aTogXCJORFdJXCIsXG5cdFx0ZXZpOiBcIkVWSVwiLFxuXHRcdGlyb25PeGlkZTogXCJKw6Rybm94aWRcIixcblx0XHRmZXJyb3VzTWluZXJhbHM6IFwiSsOkcm5oYWx0aWdhIG1pbmVyYWxlclwiLFxuXHRcdGNsYXlNaW5lcmFsczogXCJMZXJtaW5lcmFsZXJcIixcblx0XHR3bmR3aTogXCJXTkRXSVwiLFxuXHRcdGJhaTogXCJCQUlcIixcblx0XHRtbmR3aTogXCJNTkRXSVwiLFxuXHRcdG5icjogXCJOQlJcIixcblx0XHRuZGJpOiBcIk5EQklcIixcblx0XHRuZG1pOiBcIk5ETUlcIixcblx0XHRuZHNpOiBcIk5EU0lcIixcblx0XHRsb2NhbFNxdWFyZVJvb3Q6IFwiS3ZhZHJhdHJvdFwiLFxuXHRcdGxvY2FsQUNvczogXCJBQ29zXCIsXG5cdFx0bG9jYWxBU2luOiBcIkFTaW5cIixcblx0XHRsb2NhbEFUYW46IFwiQVRhblwiLFxuXHRcdGxvY2FsQVRhbkg6IFwiQVRhbkhcIixcblx0XHRsb2NhbEFiczogXCJBYnNcIixcblx0XHRsb2NhbEJpdHdpc2VOb3Q6IFwiQml0dmlzdCBOb3RcIixcblx0XHRsb2NhbEJvb2xlYW5Ob3Q6IFwiQm9vbGVza3QgTm90XCIsXG5cdFx0bG9jYWxDb3M6IFwiQ29zXCIsXG5cdFx0bG9jYWxDb3NIOiBcIkNvc0hcIixcblx0XHRsb2NhbEV4cDogXCJHw6VyIHV0XCIsXG5cdFx0bG9jYWxFeHAxMDogXCJFeHAxMFwiLFxuXHRcdGxvY2FsRXhwMjogXCJFeHAyXCIsXG5cdFx0bG9jYWxJbnQ6IFwiSW50XCIsXG5cdFx0bG9jYWxJc051bGw6IFwiw4RyIG5vbGxcIixcblx0XHRsb2NhbEZsb2F0OiBcIkZseXRhbmRlXCIsXG5cdFx0bG9jYWxMbjogXCJMblwiLFxuXHRcdGxvY2FsTG9nMTA6IFwiTG9nMTBcIixcblx0XHRsb2NhbExvZzI6IFwiTG9nMlwiLFxuXHRcdGxvY2FsTmVnYXRlOiBcIk5lZ2VyYVwiLFxuXHRcdGxvY2FsUm91bmREb3duOiBcIkF2cnVuZGEgbmVkw6V0XCIsXG5cdFx0bG9jYWxSb3VuZFVwOiBcIkF2cnVuZGEgdXBww6V0XCIsXG5cdFx0bG9jYWxTaW46IFwiU2luXCIsXG5cdFx0bG9jYWxTaW5IOiBcIlNpbkhcIixcblx0XHRsb2NhbFRhbjogXCJUYW5cIixcblx0XHRsb2NhbFRhbkg6IFwiVGFuSFwiLFxuXHRcdGxvY2FsQUNvc0g6IFwiQUNvc0hcIixcblx0XHRsb2NhbEFTaW5IOiBcIkFTaW5IXCIsXG5cdFx0bG9jYWxQbHVzOiBcIlBsdXNcIixcblx0XHRsb2NhbE1pbnVzOiBcIk1pbnVzXCIsXG5cdFx0bG9jYWxUaW1lczogXCJHw6VuZ2VyXCIsXG5cdFx0bG9jYWxQb3dlcjogXCJQb3RlbnNcIixcblx0XHRsb2NhbEJpdHdpc2VBbmQ6IFwiQml0dmlzdCBBbmRcIixcblx0XHRsb2NhbEJpdHdpc2VMZWZ0U2hpZnQ6IFwiQml0dmlzdCB2w6Ruc3RlcnNraWZ0XCIsXG5cdFx0bG9jYWxCaXR3aXNlT3I6IFwiQml0dmlzdCBPclwiLFxuXHRcdGxvY2FsQml0d2lzZVJpZ2h0U2hpZnQ6IFwiQml0dmlzdCBow7ZnZXJza2lmdFwiLFxuXHRcdGxvY2FsQml0d2lzZVhvcjogXCJCaXR2aXN0IFhvclwiLFxuXHRcdGxvY2FsQm9vbGVhbkFuZDogXCJCb29sZXNrdCBBbmRcIixcblx0XHRsb2NhbEJvb2xlYW5PcjogXCJCb29sZXNrdCBPclwiLFxuXHRcdGxvY2FsQm9vbGVhblhvcjogXCJCb29sZXNrdCBYb3JcIixcblx0XHRsb2NhbERpdmlkZTogXCJGw7ZyZGVsYVwiLFxuXHRcdGxvY2FsRXF1YWxUbzogXCJMaWthIG1lZFwiLFxuXHRcdGxvY2FsR3JlYXRlclRoYW46IFwiU3TDtnJyZSDDpG5cIixcblx0XHRsb2NhbEdyZWF0ZXJUaGFuRXF1YWw6IFwiU3TDtnJyZSDDpG4gZWxsZXIgbGlrYSBtZWRcIixcblx0XHRsb2NhbExlc3NUaGFuOiBcIk1pbmRyZSDDpG5cIixcblx0XHRsb2NhbExlc3NUaGFuRXF1YWw6IFwiTWluZHJlIMOkbiBlbGxlciBsaWthIG1lZFwiLFxuXHRcdGxvY2FsTW9kOiBcIk1vZFwiLFxuXHRcdGxvY2FsTm90RXF1YWw6IFwiSW50ZSBsaWthIG1lZFwiLFxuXHRcdGxvY2FsQVRhbjI6IFwiQVRhbjJcIixcblx0XHRsb2NhbFNxdWFyZTogXCJGeXJrYW50XCIsXG5cdFx0bG9jYWxTZXROdWxsOiBcIlPDpHR0IG5vbGxcIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkxpc3RhXCIsXG5cdFx0cmVtYXBEZWZUeXBlVGFibGU6IFwiVGFiZWxsXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVTaW1wbGU6IFwiRW5rZWxcIixcblx0XHRyZW1hcFRhYmxlVHlwZUR5bmFtaWM6IFwiRHluYW1pc2tcIixcblx0XHRyZW1hcFRhYmxlVHlwZVJlYXNzaWdubWVudDogXCJPbXRpbGxkZWxuaW5nXCIsXG5cdFx0Z2VvbUNvcnJlY3Rpb25CeUNvbnN0WjogXCJBbnbDpG5kIGtvbnN0YW50IFpcIixcblx0XHRnZW9tQ29ycmVjdGlvbkJ5REVNOiBcIkFudsOkbmQgREVNXCIsXG5cdFx0cmFkYXJDYWxpYkJldGFOb3VnaHQ6IFwiQmV0YS1ub2xsXCIsXG5cdFx0cmFkYXJDYWxpYlNpZ21hTm91Z2h0OiBcIlNpZ21hLW5vbGxcIixcblx0XHRyYWRhckNhbGliR2FtbWFOb3VnaHQ6IFwiR2FtbWEtbm9sbFwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlTGVlOiBcIkxlZS1maWx0ZXJcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUVuaGFuY2VkTGVlOiBcIkbDtnJzdMOkcmt0IExlZS1maWx0ZXJcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUZyb3N0OiBcIkZyb3N0ZmlsdGVyXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVLdWFuOiBcIkt1YW4tZmlsdGVyXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxNdWw6IFwiTXVsdGlwbGlrYXRpdnQgYnJ1c1wiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsQWRkOiBcIkFkZGl0aXZ0IGJydXNcIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbEFkZG5NdWw6IFwiQWRkaXRpdnQgb2NoIG11bHRpcGxpa2F0aXZ0IGJydXNcIixcblx0XHRtb3NhaWNPcFR5cGVGaXJzdDogXCJGw7Zyc3RhXCIsXG5cdFx0bW9zYWljT3BUeXBlTGFzdDogXCJTaXN0YVwiLFxuXHRcdG1vc2FpY09wVHlwZU1pbjogXCJNaW4uXCIsXG5cdFx0bW9zYWljT3BUeXBlTWF4OiBcIk1heFwiLFxuXHRcdG1vc2FpY09wVHlwZU1lYW46IFwiTWVkZWx2w6RyZGVcIixcblx0XHRtb3NhaWNPcFR5cGVCbGVuZDogXCJCbGFuZG5pbmdcIixcblx0XHRtb3NhaWNPcFR5cGVTdW06IFwiU3VtbWFcIixcblx0XHRpbnRlZ2VyOiBcIkhlbHRhbFwiLFxuXHRcdHJmeEQ4OiBcIkQ4XCIsXG5cdFx0cmZ4TUZEOiBcIk1GRFwiLFxuXHRcdGRpbmY6IFwiRGluZlwiLFxuXHRcdHZlcnRpY2FsOiBcIlZlcnRpa2FsXCIsXG5cdFx0aG9yaXpvbnRhbDogXCJIb3Jpc29udGVsbFwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eTogXCJNYWpvcml0ZXRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWF4OiBcIk1heGltYWx0XCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW46IFwiTWVkZWx2w6RyZGVcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVkaWFuOiBcIk1lZGlhblwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW46IFwiTWluaW11bVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5vcml0eTogXCJNaW5vcml0ZXRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzUmFuZ2U6IFwiSW50ZXJ2YWxsXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N0ZERldjogXCJTdGFuZGFyZGF2dmlrZWxzZVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdW06IFwiU3VtbWFcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVmFyaWV0eTogXCJWYXJpYXRpb25cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWFqb3JpdHlJZ25vcmVORDogXCJNYWpvcml0ZXQgKGlnbm9yZXJhIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWF4SWdub3JlTkQ6IFwiTWF4aW11bSAoaWdub3JlcmEgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWFuSWdub3JlTkQ6IFwiTWVkZWwgKGlnbm9yZXJhIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVkaWFuSWdub3JlTkQ6IFwiTWVkaWFuIChpZ25vcmVyYSBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbklnbm9yZU5EOiBcIk1pbmltdW0gKGlnbm9yZXJhIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHlJZ25vcmVORDogXCJNaW5vcml0ZXQgKGlnbm9yZXJhIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzUmFuZ2VJZ25vcmVORDogXCJJbnRlcnZhbGwgKGlnbm9yZXJhIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3RkRGV2SWdub3JlTkQ6IFwiU3RhbmRhcmRhdnZpa2Vsc2UgKGlnbm9yZXJhIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtSWdub3JlTkQ6IFwiU3VtbWEgKGlnbm9yZXJhIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVmFyaWV0eUlnbm9yZU5EOiBcIlZhcmlhdGlvbiAoaWdub3JlcmEgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NUeXBlUGVyY2VudGlsZUlnbm9yZU5EOiBcIlBlcmNlbnRpbCAoaWdub3JlcmEgTm9EYXRhKVwiLFxuXHRcdGZyb21Tb3VyY2U6IFwiRnLDpW4ga8OkbGxhXCIsXG5cdFx0dG9Tb3VyY2U6IFwiVGlsbCBrw6RsbGFcIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvblJnYlRvSHN2OiBcIlJHQiB0aWxsIEhTVlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uSHN2VG9SZ2I6IFwiSFNWIHRpbGwgUkdCXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVJSFM6IFwiSUhTXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVCcm92ZXk6IFwiQnJvdmV5XCIsXG5cdFx0cGFuc2hhcnBlblR5cGVFc3JpOiBcIkVzcmlcIixcblx0XHRwYW5zaGFycGVuVHlwZU1lYW46IFwiTWVkZWx2w6RyZGVcIixcblx0XHRwYW5zaGFycGVuVHlwZUdyYW1TY2htaWR0OiBcIkdyYW0tU2NobWlkdFwiLFxuXHRcdHJlY3RhbmdsZU5laWdoYm9yaG9vZDogXCJSZWt0YW5nZWxcIixcblx0XHRjaXJjbGVOZWlnaGJvcmhvb2Q6IFwiQ2lya2VsXCIsXG5cdFx0YW5udWx1c05laWdoYm9yaG9vZDogXCJSaW5nXCIsXG5cdFx0d2VkZ2VOZWlnaGJvcmhvb2Q6IFwiS2lsXCIsXG5cdFx0aXJyZWd1bGFyTmVpZ2hib3Job29kOiBcIk9yZWdlbGJ1bmRlblwiLFxuXHRcdHdlaWdodE5laWdoYm9yaG9vZDogXCJWaWt0XCIsXG5cdFx0Zm91cjogXCJGeXJhXCIsXG5cdFx0ZWlnaHQ6IFwiw4V0dGFcIixcblx0XHR3aXRoaW46IFwiSW5vbVwiLFxuXHRcdGNyb3NzOiBcIktvcnNcIixcblx0XHRhZGRMaW5rOiBcIkzDpGdnIHRpbGwgbMOkbmtcIixcblx0XHRub0xpbms6IFwiSW5nZW4gbMOkbmtcIixcblx0XHR3ZWlnaHRlZE1lYW46IFwiVmlrdGF0IG1lZGVsdsOkcmRlXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2lycnVzOiBcIkxhbmRzYXQgOCDigJMgY2lycnVzXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWQ6IFwiTGFuZHNhdCA4IOKAkyBtb2xuXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWRTaGFkb3c6IFwiTGFuZHNhdCA4IOKAkyBtb2xuc2t1Z2dhXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuRGVzaWduYXRlZEZpbGw6IFwiTGFuZHNhdCA4IOKAkyBhdnNlZGQgZnlsbG5pbmdcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Ecm9wcGVkRnJhbWU6IFwiTGFuZHNhdCA4IOKAkyB1dGVsw6RtbmFkIHJhbVwiLFxuXHRcdGxzOFFDQml0UGF0dGVyblNub3dJY2U6IFwiTGFuZHNhdCA4IOKAkyBzbsO2L2lzXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVGVycmFpbk9jY2x1c2lvbjogXCJMYW5kc2F0IDgg4oCTIHRlcnLDpG5nb2NrbHVzaW9uXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVmVnZXRhdGlvbjogXCJMYW5kc2F0IDgg4oCTIHbDpHh0bGlnaGV0XCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuV2F0ZXI6IFwiTGFuZHNhdCA4IOKAkyB2YXR0ZW5cIixcblx0XHRkb3duU3RyZWFtOiBcIk5lZHN0csO2bXNcIixcblx0XHR1cFN0cmVhbTogXCJVcHBzdHLDtm1zXCIsXG5cdFx0c3RyYWhsZXI6IFwiU1RSQUhMRVJcIixcblx0XHRzaHJldmU6IFwiU0hSRVZFXCIsXG5cdFx0Y3VycmVudFNsaWNlOiBcIkFrdHVlbGwgc2VrdG9yXCIsXG5cdFx0YWxsU2xpY2VzOiBcIkFsbGEgc2VrdG9yZXJcIixcblx0XHRleHBhbmREaXN0YW5jZTogXCJBVlNUw4VORFwiLFxuXHRcdGV4cGFuZE1vcnBob2xvZ2ljYWw6IFwiTU9SRk9MT0dJU0tUXCIsXG5cdFx0c3BlY3RyYWxQcm9maWxlRmlsZTogXCJTcGVrdHJhbCBwcm9maWxcIixcblx0XHR0cmFpbmluZ0ZlYXR1cmVGaWxlOiBcIlRyw6RuaW5nc2dlb29iamVrdFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVVbmlmb3JtOiBcIkVuaGV0bGlnXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVVuaWZvcm1JbnRlZ2VyOiBcIkhlbHRhbFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVOb3JtYWw6IFwiTm9ybWFsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUV4cG9uZW50aWFsOiBcIkV4cG9uZW50aWVsbFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVQb2lzc29uOiBcIlBvaXNzb25cIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlR2FtbWE6IFwiR2FtbWFcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlQmlub21pYWw6IFwiQmlub21pYWxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlR2VvbWV0cmljOiBcIkdlb21ldHJpc2t0XCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZU5lZ2F0aXZlQmlub21pYWw6IFwiTmVnYXRpdiBiaW5vbWlhbFwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVTdGFuZGFyZENSYW5kOiBcIlN0YW5kYXJkIEMgUmFuZFwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVBbGdvcml0aG1BQ001OTk6IFwiQUNNIHNhbWxhZCBhbGdvcml0bSA1OTlcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlTWVyc2VubmVUd2lzdGVyOiBcIk1lcnNlbm5lIFR3aXN0ZXJcIixcblx0XHRzdW1OYW1lOiBcIlN1bW1hXCIsXG5cdFx0bWVkYWluTmFtZTogXCJNZWRpYW5cIixcblx0XHR0cmVuZExpbmVhcjogXCJMaW5qw6RyXCIsXG5cdFx0dHJlbmRIYXJtb25pYzogXCJIYXJtb25pc2tcIixcblx0XHR0cmVuZFBvbHlub21pYWw6IFwiUG9seW5vbVwiLFxuXHRcdHRyZW5kTWFubktlbmRhbGw6IFwiTWFubi1LZW5kYWxsXCIsXG5cdFx0dHJlbmRTZWFzb25hbEtlbmRhbGw6IFwiU8Okc29uZ3NiZXJvZW5kZSBLZW5kYWxsXCIsXG5cdFx0ZGltZW5zaW9uQnlWYWx1ZTogXCJFZnRlciB2w6RyZGVcIixcblx0XHRkaW1lbnNpb25CeUludGVydmFsOiBcIkVmdGVyIGludGVydmFsbFwiLFxuXHRcdG1kaW1EZWZUeXBlQWxsOiBcIkFsbGFcIixcblx0XHRtZGltRGVmVHlwZUJ5VmFsdWVzOiBcIkVmdGVyIHbDpHJkZW5cIixcblx0XHRtZGltRGVmVHlwZUJ5UmFuZ2VzOiBcIkVmdGVyIGludGVydmFsbFwiLFxuXHRcdG1kaW1EZWZUeXBlQnlJdGVyYXRpb246IFwiRWZ0ZXIgaXRlcmF0aW9uXCIsXG5cdFx0bWRpbURlZlR5cGVCeUludGVydmFsOiBcIkVmdGVyIGludGVydmFsbFwiLFxuXHRcdG1kaW1EZWZUeXBlQnlUYXJnZXRSYXN0ZXI6IFwiRWZ0ZXIgbcOlbHJhc3RlclwiLFxuXHRcdGVzcmlUaW1lVW5pdHNIb3VyczogXCJUaW1tYXJcIixcblx0XHRlc3JpVGltZVVuaXRzRGF5czogXCJEYWdhclwiLFxuXHRcdGVzcmlUaW1lVW5pdHNXZWVrczogXCJWZWNrb3JcIixcblx0XHRlc3JpVGltZVVuaXRzTW9udGhzOiBcIk3DpW5hZGVyXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1llYXJzOiBcIsOFclwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkSG91cmx5OiBcIlZhcmplIHRpbW1hXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmREYWlseTogXCJEYWdsaWdlblwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkV2Vla2x5OiBcIlZlY2tvdmlzXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmREZWthZGx5OiBcIlZhcnQgdGlvbmRlIMOlclwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUGVudGFkbHk6IFwiVmFydCBmZW10ZSDDpXJcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZE1vbnRobHk6IFwiTcOlbmFkc3Zpc1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUXVhcnRlcmx5OiBcIlZhcmplIGt2YXJ0YWxcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFllYXJseTogXCLDhXJsaWdlblwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nRGFpbHk6IFwiw4V0ZXJrb21tZXIgZGFnbGlnZW5cIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1dlZWtseTogXCLDhXRlcmtvbW1lciB2ZWNrb3Zpc1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nTW9udGhseTogXCLDhXRlcmtvbW1lciBtw6VuYWRzdmlzXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdRdWFydGVybHk6IFwiw4V0ZXJrb21tZXIga3ZhcnRhbHN2aXNcIixcblx0XHRhZ2dEZWZUeXBlQWxsOiBcIkFsbGFcIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxLZXl3b3JkOiBcIkludGVydmFsbG55Y2tlbG9yZFwiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFZhbHVlOiBcIkludGVydmFsbHbDpHJkZVwiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFJhbmdlczogXCJJbnRlcnZhbGxvbXLDpWRlblwiLFxuXHRcdGxhdGVzdENoYW5nZTogXCJUaWQgZsO2ciBzZW5hc3RlIGbDtnLDpG5kcmluZ1wiLFxuXHRcdGVhcmxpZXN0Q2hhbmdlOiBcIlRpZCBmw7ZyIHRpZGlnYXN0ZSBmw7Zyw6RuZHJpbmdcIixcblx0XHRsYXJnZXN0Q2hhbmdlOiBcIlRpZCBmw7ZyIHN0w7Zyc3RhIGbDtnLDpG5kcmluZ1wiLFxuXHRcdG51bWJlck9mQ2hhbmdlczogXCJBbnRhbCBmw7Zyw6RuZHJpbmdhclwiLFxuXHRcdGxvbmdlc3RDaGFuZ2U6IFwiVGlkcHVua3QgZsO2ciBsw6RuZ3N0YSDDpG5kcmluZ1wiLFxuXHRcdHNob3J0ZXN0Q2hhbmdlOiBcIlRpZHB1bmt0IGbDtnIga29ydGFzdGUgw6RuZHJpbmdcIixcblx0XHRmYXN0ZXN0Q2hhbmdlOiBcIlRpZHB1bmt0IGbDtnIgc25hYmJhc3RlIMOkbmRyaW5nXCIsXG5cdFx0c2xvd2VzdENoYW5nZTogXCJUaWRwdW5rdCBmw7ZyIGzDpW5nc2FtbWFzdGUgw6RuZHJpbmdcIixcblx0XHRhbGxDaGFuZ2VzOiBcIkFsbGFcIixcblx0XHRpbmNyZWFzZUNoYW5nZXM6IFwiw5ZrYVwiLFxuXHRcdGRlY3JlYXNlQ2hhbmdlczogXCJNaW5za2FcIixcblx0XHRzZWdtZW50QmVnaW5uaW5nOiBcIkLDtnJqYW4gcMOlIHNlZ21lbnRldFwiLFxuXHRcdHNlZ21lbnRFbmQ6IFwiU2x1dCBww6Ugc2VnbWVudGV0XCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2REaWZmZXJlbmNlOiBcIlNraWxsbmFkXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RSZWxhdGl2ZURpZmZlcmVuY2U6IFwiUmVsYXRpdiBza2lsbG5hZFwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kQ2F0ZWdvcmljYWw6IFwiS2F0ZWdvcmlzayBza2lsbG5hZFwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEV1Y2xpZGVhbkRpc3RhbmNlOiBcIlNwZWt0cmFsdCBldWtsaWRpc2t0IGF2c3TDpW5kXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RNdWx0aXNwZWN0cmFsQW5ndWxhckRpZmZlcmVuY2U6IFwiU3Bla3RyYWwgdmlua2Vsc2tpbGxuYWRcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBeGlzV2l0aEJpZ2dlc3RDaGFuZ2U6IFwiQmFuZCBtZWQgc3TDtnJzdCBmw7Zyw6RuZHJpbmdcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBBbGw6IFwiQmVow6VsbCBzYW10bGlnYVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcENoYW5nZWRPbmx5OiBcIkJlaMOlbGwgZW5kYXN0IMOkbmRyYWRlIHBpeGxhclwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcFVuY2hhbmdlZE9ubHk6IFwiQmVow6VsbCBlbmRhc3Qgb2bDtnLDpG5kcmFkZSBwaXhsYXJcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yQXZlcmFnZTogXCJHZW5vbXNuaXR0bGlnYSBmcsOlbi0gb2NoIHRpbGwtZsOkcmdlclwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JGcm9tOiBcIkFudsOkbmQgZnLDpW4tZsOkcmdlclwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JUbzogXCJBbnbDpG5kIHRpbGwtZsOkcmdlclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQmluYXJ5OiBcIkJpbsOkclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uRm9yd2FyZDogXCJGcmFtw6V0XCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25MaW5lYXI6IFwiTGluasOkclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSW52TGluZWFyOiBcIk9tdsOkbmQgbGluasOkclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uVGFibGU6IFwiVGFiZWxsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1MaW5lYXI6IFwiU3ltbWV0cmlzayBsaW5qw6RyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1JbnZMaW5lYXI6IFwiU3ltbWV0cmlzayBvbXbDpG5kIGxpbmrDpHJcIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvczogXCJDb3NpbnVzXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWM6IFwiU2VrYW50XCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3NTZWM6IFwiQ29zaW51cyBzZWthbnRcIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY0NvczogXCJTZWthbnQgY29zaW51c1wiLFxuXHRcdG5vU29ydDogXCJTb3J0ZXJhIGludGVcIixcblx0XHRhc2NlbmQ6IFwiU3RpZ2FuZGVcIixcblx0XHRkZXNjZW5kOiBcIkZhbGxhbmRlXCIsXG5cdFx0YXV0b0RldGVjdDogXCJBdXRvaWRlbnRpZmllcmluZ1wiLFxuXHRcdG5lYXJlc3Q6IFwiTsOkcm1hc3RlXCIsXG5cdFx0bGluZWFyOiBcIkxpbmrDpHJcIixcblx0XHRlc3JpTW9udGhKYW51YXJ5OiBcIkphbnVhcmlcIixcblx0XHRlc3JpTW9udGhGZWJydWFyeTogXCJGZWJydWFyaVwiLFxuXHRcdGVzcmlNb250aE1hcmNoOiBcIk1hcnNcIixcblx0XHRlc3JpTW9udGhBcHJpbDogXCJBcHJpbFwiLFxuXHRcdGVzcmlNb250aE1heTogXCJNYWpcIixcblx0XHRlc3JpTW9udGhKdW5lOiBcIkp1bmlcIixcblx0XHRlc3JpTW9udGhKdWx5OiBcIkp1bGlcIixcblx0XHRlc3JpTW9udGhBdWd1c3Q6IFwiQXVndXN0aVwiLFxuXHRcdGVzcmlNb250aFNlcHRlbWJlcjogXCJTZXB0ZW1iZXJcIixcblx0XHRlc3JpTW9udGhPY3RvYmVyOiBcIk9rdG9iZXJcIixcblx0XHRlc3JpTW9udGhOb3ZlbWJlcjogXCJOb3ZlbWJlclwiLFxuXHRcdGVzcmlNb250aERlY2VtYmVyOiBcIkRlY2VtYmVyXCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdJZ25vcmVOb0RhdGE6IFwiRGF0YVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nUHJvcGFnYXRlTm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nRmlsbE9ubHlOb0RhdGE6IFwiRnlsbCBpIE5vRGF0YVwiLFxuXHRcdGNpcmN1bGFyTWVhbjogXCJDaXJrdWzDpHJ0IG1lZGVsdsOkcmRlXCIsXG5cdFx0Y2lyY3VsYXJOYW1lOiBcIkNpcmt1bMOkclwiLFxuXHRcdGFyaXRobWV0aWNOYW1lOiBcIkFyaXRtZXRpc2t0XCIsXG5cdFx0c2xvcGVOYW1lOiBcIkx1dG5pbmdcIixcblx0XHRhc3BlY3ROYW1lOiBcIkx1dG5pbmdzcmlrdG5pbmdcIixcblx0XHRtZWFuQ3VydmF0dXJlOiBcIk1lZGVsa3VydmF0dXJcIixcblx0XHRwcm9maWxlQ3VydmF0dXJlOiBcIlByb2ZpbGt1cnZhdHVyIChub3JtYWwgbHV0bmluZ3NsaW5qZSlcIixcblx0XHR0YW5nZW50aWFsQ3VydmF0dXJlOiBcIlRhbmdlbnRpYWxrdXJ2YXR1ciAobm9ybWFsIGtvbnR1cilcIixcblx0XHRwbGFuQ3VydmF0dXJlOiBcIlBsYW5rdXJ2YXR1ciAocHJvamljZXJhZCBrb250dXIpXCIsXG5cdFx0Y29udG91ckdlb2Rlc2ljVG9yc2lvbjogXCJLb250dXJnZW9kZXRpc2sgdG9yc2lvblwiLFxuXHRcdGdhdXNzaWFuQ3VydmF0dXJlOiBcIkdhdXNzaXNrIGt1cnZhdHVyXCIsXG5cdFx0Y2Fzb3JhdGlDdXJ2YXR1cmU6IFwiQ2Fzb3JhdGkta3VydmF0dXJcIixcblx0XHRsb2NhbFN1cmZhY2VUeXBlUXVhZHJhdGljOiBcIkt2YWRyYXRpc2tcIixcblx0XHRsb2NhbFN1cmZhY2VUeXBlQmlxdWFkcmF0aWM6IFwiQmlrdmFkcmF0aXNrXCIsXG5cdFx0dGhyZXNob2xkTm9UaHJlc2hvbGQ6IFwiSW5nZW4gdHLDtnNrZWxcIixcblx0XHR0aHJlc2hvbGRQZXJjZW50TGVhc3RDb3N0OiBcIlByb2NlbnQgYXYgbMOkZ3N0YSBrb3N0bmFkXCIsXG5cdFx0dGhyZXNob2xkQWNjdW11bGF0aXZlQ29zdDogXCJBY2t1bXVsZXJhZCBrb3N0bmFkXCIsXG5cdFx0Y2xybWFwVHlwZUhpbGxzaGFkZTogXCJUZXJyw6RuZ3NrdWdnbmluZ1wiXG5cdH0sXG5cdGNhdGVnb3J5TGFiZWxzOiB7XG5cdFx0c291cmNlQ2hhcmFjdGVyaXN0aWNzOiBcIkvDpGxsZ3J1bmRkcmFnXCIsXG5cdFx0bmVpZ2hib3Job29kU2V0dGluZ3M6IFwiR3Jhbm5za2Fwc2luc3TDpGxsbmluZ2FyXCIsXG5cdFx0c3RhdGlzdGljczogXCJTdGF0aXN0aWtcIixcblx0XHRnYW1tYTogXCJHYW1tYVwiLFxuXHRcdHZpZXdzaGVkUGFyYW1ldGVyczogXCJQYXJhbWV0cmFyIGbDtnIgc2lrdG9tcsOlZGVcIixcblx0XHRvYnNlcnZlclBhcmFtZXRlcnM6IFwiT2JzZXJ2YXTDtnJzcGFyYW1ldHJhclwiLFxuXHRcdGlycmVndWxhckRhdGFJbnRlcnBvbGF0aW9uOiBcIk9yZWdlbGJ1bmRlbiBkYXRhaW50ZXJwb2xhdGlvblwiLFxuXHRcdG1vZGVsU3RhdGlzdGljczogXCJNb2RlbGxzdGF0aXN0aWtcIixcblx0XHRhZ2dyZWdhdGlvbkRlZjogXCJBZ2dyZWdlcmluZ3NkZWZpbml0aW9uXCIsXG5cdFx0ZmlsdGVyQnlBdHRyaWJ1dGVzOiBcIkZpbHRyZXJhIGVmdGVyIGF0dHJpYnV0XCIsXG5cdFx0cGVyY2VudGlsZU5hbWU6IFwiUGVyY2VudGlsXCIsXG5cdFx0cmFzdGVySW5mbzogXCJSYXN0ZXJpbmZvcm1hdGlvblwiLFxuXHRcdGV4dGVudDogXCJVdGJyZWRuaW5nXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZTogXCJHZW9ncmFmaXNrIHJlZmVyZW5zXCJcblx0fSxcblx0b3V0cHV0UmFzdGVySGVscFRleHRzOiB7XG5cdFx0b3V0cHV0TmFtZTogXCI8cD5OYW1uZXQgcMOlIGxhZ3JldCBzb20gc2thcGFzIG9jaCBsw6RnZ3MgdGlsbCBpIGthcnRhbi48L3A+XCIsXG5cdFx0cmVzdWx0VHlwZTogXCI8cD5UeXAgYXYgdXRkYXRhIHNvbSBza2FwYXMuIFV0ZGF0YSBrYW4gdmFyYSBiaWxkbGFnZXIgaSB0aWxlZm9ybSBlbGxlciBkeW5hbWlza2EgYmlsZGxhZ2VyLjwvcD5cIixcblx0XHRzYXZlUmVzdWx0SW46IFwiPHA+TmFtbmV0IHDDpSBtYXBwZW4gaSA8Yj5NaXR0IGlubmVow6VsbDwvYj4gZMOkciByZXN1bHRhdGV0IHNrYSBzcGFyYXMuPC9wPlwiXG5cdH0sXG5cdGFuYWx5c2lzRW52aXJvbm1lbnRzSGVscFRleHRzOiB7XG5cdFx0ZGVzY3JpcHRpb246IFwiPHA+TWlsasO2aW5zdMOkbGxuaW5nYXIgZsO2ciBhbmFseXMgaSBNYXAgVmlld2VyLiA8L3A+XCIsXG5cdFx0b3V0U1I6IFwiPHA+QW5nZXIga29vcmRpbmF0c3lzdGVtIGbDtnIgYW5hbHlzZW4gb2NoIHJlc3VsdGF0bGFncmV0LjwvcD5cIixcblx0XHRleHRlbnQ6IFwiPHA+QW5nZXIgZGV0IG9tcsOlZGUgc29tIHNrYSBhbnbDpG5kYXMgZsO2ciBhbmFseXMuPC9wPlwiLFxuXHRcdHNuYXBSYXN0ZXI6IFwiPHA+SnVzdGVyYXIgdXRicmVkbmluZ2VuIGbDtnIgdXRkYXRhIHPDpSBhdHQgZGVuIG1hdGNoYXIgY2VsbGp1c3RlcmluZ2VuIGbDtnIgZGV0IGFuZ2l2bmEgc25hcHByYXN0ZXJsYWdyZXQuPC9wPlwiLFxuXHRcdGNlbGxTaXplOiBcIjxwPkFuZ2VyIGNlbGxzdG9ybGVrIGVsbGVyIHVwcGzDtnNuaW5nIHNvbSBza2EgYW52w6RuZGFzIGbDtnIgYW5hbHlzIG9jaCBmw7ZyIGF0dCBza2FwYSB1dGRhdGFyYXN0ZXJsYWdyZXQuPC9wPlwiLFxuXHRcdG1hc2s6IFwiPHA+QW5nZXIgZXR0IG1hc2tsYWdlciBpIHZpbGtldCBlbmRhc3QgZGUgY2VsbGVyIHNvbSBsaWdnZXIgaW5vbSBtYXNrb21yw6VkZXQga29tbWVyIGF0dCBhbnbDpG5kYXMgZsO2ciBhbmFseXMuPC9wPlwiLFxuXHRcdHJlc2FtcGxpbmdNZXRob2Q6IFwiPHA+QW5nZXIgaHVyIHBpeGVsdsOkcmRlbiBza2EgaW50ZXJwb2xlcmFzIG7DpHIgaW5kYXRhLSBvY2ggdXRkYXRhbGFnZXIgaW50ZSBvcmRuYXMga29ycmVrdC48L3A+XCJcblx0fSxcblx0bWFpbkdlblN0cmluZ3M6IHtcblx0XHR1bnN1cHBvcnRlZERhdGFUeXBlOiBcIlR5cGVuIHN0w7ZkcyBpbnRlXCIsXG5cdFx0Y3VycmVudGx5VW5zdXBwb3J0ZWQ6IFwiIEVuIHN0YW5kYXJkcmVkaWdlcmFyZSBmw7ZyICR7bWlzc2luZ1R5cGV9IMOkciB2w6RudGFuZGUgbWVuIGtvbW1lciBzbmFydC4gVGVtcG9yw6RyIHBsYXRzaMOlbGxhcnRleHRydXRhIGbDtnIgYXR0IGFuZ2Ugc3Ryw6RuZ2Jhc2VyYWRlIGluZGF0YS5cIixcblx0XHR1bnN1cHBvcnRlZE92ZXJyaWRlV2FybmluZzogXCJFbiBrb21wb25lbnQgZsO2ciDDpXNpZG9zw6R0dG5pbmdzcmVkaWdlcmFyZSBzb20gZ2VyIGVuIGLDpHR0cmUgYW52w6RuZGFydXBwbGV2ZWxzZSBmw7ZyIGFyYmV0ZSBtZWQgZsO2bGphbmRlIHBhcmFtZXRlci9wYXJhbWV0cmFyIMOkciB2w6RudGFuZGUgbWVuIGtvbW1lciBzbmFydDpcIixcblx0XHRvdmVycmlkZVdpZGdldE1pc3Npbmc6IFwiS29tcG9uZW50IGbDtnIgw6VzaWRvc8OkdHRuaW5nc3JlZGlnZXJhcmUgc2FrbmFzIVwiLFxuXHRcdHVpSW5jb21wbGV0ZTogXCJKb2JiaW5sw6RtbmluZ2VuIG1pc3NseWNrYWRlcy4gRnVua3Rpb25lbiBrYW4gaW50ZSBrw7ZyYXMgZWZ0ZXJzb20gdmlzc2EgYXYgZGUgb2JsaWdhdG9yaXNrYSBmw6RsdGVuIMOkciBvZnVsbHN0w6RuZGlnYSBlbGxlciBzYWtuYXMgaSBncsOkbnNzbml0dGV0LlwiLFxuXHRcdGNvdW50OiBcIkFudGFsXCIsXG5cdFx0c2VsZWN0VmFyaWFibGVzOiBcIlbDpGxqIHZhcmlhYmxlclwiLFxuXHRcdHNlbGVjdEZlYXR1cmU6IFwiVsOkbGogZXR0IGdlb29iamVrdGxhZ2VyXCIsXG5cdFx0Z3JlYXRlclRoYW5FcnJvck1lc3NhZ2U6IFwiSW5kYXRhYW50YWxldCBtw6VzdGUgdmFyYSBzdMO2cnJlIMOkbiAke21pbn1cIixcblx0XHRsZXNzZXJUaGFuRXJyb3JNZXNzYWdlOiBcIkluZGF0YWFudGFsZXQgbcOlc3RlIHZhcmEgbMOkZ3JlIMOkbiAke21heH1cIixcblx0XHRncmVhdGVyVGhhbk9yRXF1YWxFcnJvck1lc3NhZ2U6IFwiSW5kYXRhYW50YWxldCBtw6VzdGUgdmFyYSBzdMO2cnJlIMOkbiBlbGxlciBsaWthIG1lZCAke21pbn1cIixcblx0XHRsZXNzZXJUaGFuT3JFcXVhbEVycm9yTWVzc2FnZTogXCJJbmRhdGFhbnRhbGV0IG3DpXN0ZSB2YXJhIGzDpGdyZSDDpG4gZWxsZXIgbGlrYSBtZWQgJHttYXh9XCIsXG5cdFx0YWxsb3dTY2FsYXI6IFwiVsOkbGogZXR0IGxhZ2VyIGVsbGVyIGFuZ2UgZW4ga29uc3RhbnRcIixcblx0XHRzZWxlY3RGaWVsZDogXCJWw6RsaiBmw6RsdFwiLFxuXHRcdHBhcmFtZXRlclJlcXVpcmVkOiBcIkRlbm5hIHBhcmFtZXRlciDDpHIgb2JsaWdhdG9yaXNrLlwiLFxuXHRcdGVudGVyQVZhbHVlOiBcIkFuZ2UgZXR0IHbDpHJkZS4uLlwiLFxuXHRcdGludmFsaWRJbnB1dDogXCJEZXQgYW5naXZuYSB2w6RyZGV0IMOkciBvZ2lsdGlndC5cIixcblx0XHRpdGVtTm90Rm91bmQ6IFwiT2JqZWt0ZXQgZmlubnMgaW50ZSBlbGxlciDDpHIgaW50ZSB0aWxsZ8OkbmdsaWd0LlwiLFxuXHRcdGl0ZW1QZXJtaXNzaW9uRGVuaWVkOiBcIkR1IGhhciBpbnRlIMOldGtvbXN0YmVow7ZyaWdoZXQgdGlsbCBkZXQgaMOkciBvYmpla3RldC5cIixcblx0XHRsYXllck5vdEF2YWlsYWJsZTogXCJEZXQgZ2ljayBpbnRlIGF0dCBsw6RzYSBpbiBsYWdyZXQgJHtsYXllck5hbWV9LlwiLFxuXHRcdG11bHRpcGxlTGF5ZXJzTm90QXZhaWxhYmxlOiBcIkRldCBnaWNrIGludGUgYXR0IGzDpHNhIGluIGxhZ3JldCAke2xheWVyTmFtZX0gb2NoIGFuZHJhLlwiLFxuXHRcdGxlYXJuTW9yZUxhYmVsOiBcIkzDpHMgbWVyXCIsXG5cdFx0ZmllbGROb3RBdmFpbGFibGU6IFwiRGV0IGdpY2sgaW50ZSBhdHQgbMOkc2EgaW4gZsOkbHRldC5cIixcblx0XHRhbGxvd0FuYWx5c2lzOiBcIkFuYWx5cyDDpHIgaW50ZSB0aWxsw6V0ZXQgaSBiaWxkdGrDpG5zdGVuLlwiLFxuXHRcdGFsbG93QW5hbHlzaXNSZWFzb246IFwiRXR0IGVsbGVyIGZsZXJhIGxhZ2VyIGZyw6VuIGthcnRhbiBsaXN0YXMgaW50ZSBow6RyIGVmdGVyc29tIGRlIGludGUgdGlsbMOldGVyIGFuYWx5cy5cIixcblx0XHRsZWFybk1vcmVUZXh0OiBcIkzDpHMgbWVyXCIsXG5cdFx0YXRMZWFzdE9uZVJhc3RlcklucHV0OiBcIk1pbnN0IGV0dCBpbmRhdGFsYWdlciBza2EgdmFyYSBldHQgcmFzdGVybGFnZXIuXCIsXG5cdFx0YnJvd3NlQW5hbHlzaXNMYXllcnM6IFwiQmzDpGRkcmEgYmxhbmQgbGFnZXJcIixcblx0XHRhY3RpdmVNYXBWaWV3RXh0ZW50OiBcIkFudsOkbmQgYWt0dWVsbCBrYXJ0dXRicmVkbmluZ1wiLFxuXHRcdGNob29zZVJhc3RlcjogXCJWw6RsaiBLbGlwcGVyIHJhc3RlclwiLFxuXHRcdGNob29zZUdlb21ldHJ5OiBcIlbDpGxqIEtsaXBwbmluZ3NnZW9tZXRyaVwiLFxuXHRcdHJlc3VsdFR5cGU6IFwiUmVzdWx0YXR0eXBcIixcblx0XHRzYXZlSW5Gb2xkZXI6IFwiU3BhcmEgaSBtYXBwXCIsXG5cdFx0b3V0cHV0TmFtZTogXCJVdGRhdGFuYW1uXCIsXG5cdFx0b3V0cHV0TGF5ZXJUeXBlOiBcIkxhZ2VydHlwIGbDtnIgdXRkYXRhXCIsXG5cdFx0ZHluYW1pY0ltYWdlcnlMYXllcjogXCJEeW5hbWlza3QgYmlsZGxhZ2VyXCIsXG5cdFx0dGlsZWRJbWFnZXJ5TGF5ZXI6IFwiQmlsZGxhZ2VyIGkgdGlsZWZvcm1cIixcblx0XHRjdXN0b206IFwiQW5wYXNzYXRcIixcblx0XHRsb2FkaW5nOiBcIkzDpHNlciBpbi4uLlwiLFxuXHRcdGxheWVyTWlzc2luZzogXCJFdHQgZWxsZXIgZmxlcmEgbGFnZXIgZnLDpW4ga2FydGFuIGxpc3RhcyBpbnRlIGjDpHIgZWZ0ZXJzb20gZGUgaW50ZSB0aWxsw6V0ZXIgYW5hbHlzLiBMw6RyIGRpZyBtZXIuXCIsXG5cdFx0YnJvd3NlQ29vcmRpbmF0ZVN5c3RlbXM6IFwiQmzDpGRkcmEgaSBrb29yZGluYXRzeXN0ZW1cIixcblx0XHR1bmFibGVUb1JlcG9wdWxhdGVPdXRTUjogXCJEZXQgZ8OlciBpbnRlIGF0dCBmeWxsYSBpIHV0ZGF0YWtvb3JkaW5hdHN5c3RlbS5cIixcblx0XHRkZWZhdWx0VGl0bGU6IFwiU2UgbWVyXCIsXG5cdFx0XCJBUkMgKGVxdWFsIGFyYy1zZWNvbmQpXCI6IFwiQVJDIChsaWthIG1lZCBiw6VnZS1zZWt1bmQpXCIsXG5cdFx0QWZyaWNhOiBcIkFmcmlrYVwiLFxuXHRcdEFudGFyY3RpY2E6IFwiQW50YXJrdGlzXCIsXG5cdFx0QXJnZW50aW5hOiBcIkFyZ2VudGluYVwiLFxuXHRcdEFzaWE6IFwiQXNpZW5cIixcblx0XHRcIkFzdGVyb2lkIEJlbHRcIjogXCJBc3Rlcm9pZGLDpGx0ZXRcIixcblx0XHRcIkF0bGFudGljIE9jZWFuXCI6IFwiQXRsYW50ZW5cIixcblx0XHRBdXN0cmFsaWE6IFwiQXVzdHJhbGllblwiLFxuXHRcdFwiQXVzdHJhbGlhIGFuZCBOZXcgWmVhbGFuZFwiOiBcIkF1c3RyYWxpZW4gb2NoIE55YSBaZWVsYW5kXCIsXG5cdFx0QXVzdHJpYTogXCLDlnN0ZXJyaWtlXCIsXG5cdFx0XCJCTE0gKFVTIEZlZXQpXCI6IFwiQkxNIChVUy1mb3QpXCIsXG5cdFx0QmFuZ2xhZGVzaDogXCJCYW5nbGFkZXNoXCIsXG5cdFx0XCJCZWlqaW5nIDE5NTRcIjogXCJQZWtpbmcgMTk1NFwiLFxuXHRcdEJodXRhbjogXCJCaHV0YW5cIixcblx0XHRDR0NTMjAwMDogXCJDR0NTMjAwMFwiLFxuXHRcdENhbmFkYTogXCJLYW5hZGFcIixcblx0XHRDYXJpYmJlYW46IFwiS2FyaWJpZW5cIixcblx0XHRcIkNhcmliYmVhbiBTZWFcIjogXCJLYXJpYmlza2EgaGF2ZXRcIixcblx0XHRcIkNlbnRyYWwgQW1lcmljYVwiOiBcIkNlbnRyYWxhbWVyaWNhXCIsXG5cdFx0XCJDZW50cmFsIGFuZCBOb3J0aCBBbWVyaWNhXCI6IFwiQ2VudGFsYW1lcmlrYSBvY2ggTm9yZGFtZXJpa2FcIixcblx0XHRDb2xvbWJpYTogXCJDb2xvbWJpYVwiLFxuXHRcdENvbnRpbmVudGFsOiBcIktvbnRpbmVudGFsXCIsXG5cdFx0XCJDb3VudHkgU3lzdGVtc1wiOiBcIkzDpG5zeXN0ZW1cIixcblx0XHRcIkRlbW9jcmF0aWMgUmVwdWJsaWMgb2YgdGhlIENvbmdvXCI6IFwiRGVtb2tyYXRpc2thIHJlcHVibGlrZW4gS29uZ29cIixcblx0XHRcIkVQU0cgQXJjdGljXCI6IFwiRVBTRyBBcmt0aXNcIixcblx0XHRFYXJ0aDogXCJKb3JkZW5cIixcblx0XHRcIkVsbGlwc29pZGFsLWJhc2VkXCI6IFwiRWxsaXBzb2lkYmFzZXJhdFwiLFxuXHRcdEV1cm9wZTogXCJFdXJvcGFcIixcblx0XHRGaW5sYW5kOiBcIkZpbmxhbmRcIixcblx0XHRGcmFuY2U6IFwiRnJhbmtyaWtlXCIsXG5cdFx0XCJHU0sgMjAxMVwiOiBcIkdTSyAyMDExXCIsXG5cdFx0XCJHYXVzcyBLcnVnZXJcIjogXCJHYXVzcyBLcnVnZXJcIixcblx0XHRcIkdlb2dyYXBoaWMgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiR2VvZ3JhZmlza2Ega29vcmRpbmF0c3lzdGVtXCIsXG5cdFx0R2VybWFueTogXCJUeXNrbGFuZFwiLFxuXHRcdFwiR3Jhdml0eS1yZWxhdGVkXCI6IFwiR3Jhdml0YXRpb25zcmVsYXRlcmF0XCIsXG5cdFx0XCJHcmVlbndpY2gtYmFzZWRcIjogXCJHcmVlbndpY2gtYmFzZXJhZFwiLFxuXHRcdFwiSGlnaHdheXMgRW5nbGFuZFwiOiBcIk1vdG9ydsOkZ2FyIEVuZ2xhbmRcIixcblx0XHRJbGxpbm9pczogXCJJbGxpbm9pc1wiLFxuXHRcdFwiSW5kaWFuIE9jZWFuXCI6IFwiSW5kaXNrYSBvY2VhbmVuXCIsXG5cdFx0XCJJbmRpYW4gU3ViY29udGluZW50XCI6IFwiSW5kaXNrYSBzdWJrb250aW5lbnRlblwiLFxuXHRcdEluZGlhbmE6IFwiSW5kaWFuYVwiLFxuXHRcdEluZG9uZXNpYTogXCJJbmRvbmVzaWVuXCIsXG5cdFx0SW93YTogXCJJb3dhXCIsXG5cdFx0XCJJcmVsYW5kIGFuZCBVbml0ZWQgS2luZ2RvbVwiOiBcIklybGFuZCBvY2ggU3RvcmJyaXRhbm5pZW5cIixcblx0XHRJdGFseTogXCJJdGFsaWVuXCIsXG5cdFx0SmFwYW46IFwiSmFwYW5cIixcblx0XHRKdXBpdGVyOiBcIkp1cGl0ZXJcIixcblx0XHRLYW5zYXM6IFwiS2Fuc2FzXCIsXG5cdFx0XCJMYXMgVmVnYXNcIjogXCJMYXMgVmVnYXNcIixcblx0XHRMaWJ5YTogXCJMaWJ5ZW5cIixcblx0XHRNYWxheXNpYTogXCJNYWxheXNpYVwiLFxuXHRcdFwiTWFsYXlzaWEgYW5kIFNpbmdhcG9yZVwiOiBcIk1hbGF5c2lhIG9jaCBTaW5nYXBvcmVcIixcblx0XHRNYXJzOiBcIk1hcnNcIixcblx0XHRNZXJjdXJ5OiBcIk1lcmt1cml1c1wiLFxuXHRcdE1pbm5lc290YTogXCJNaW5uZXNvdGFcIixcblx0XHRNb250YW5hOiBcIk1vbnRhbmFcIixcblx0XHRcIk5BRCAxOTI3XCI6IFwiTkFEIDE5MjdcIixcblx0XHRcIk5BRCAxOTI3IChVUyBGZWV0KVwiOiBcIk5BRCAxOTI3IChVUy1mb3QpXCIsXG5cdFx0XCJOQUQgMTk4M1wiOiBcIk5BRCAxOTgzXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSlcIjogXCJOQUQgMTk4MyAoMjAxMSlcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzICgyMDExKSAoaW50LiBmb3QpXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSkgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoMjAxMSkgKG1ldGVyKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzICgyMDExKSAoVVMtZm90KVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAoaW50LiBmb3QpXCIsXG5cdFx0XCJOQUQgMTk4MyAoQ09SUzk2KSAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIChDT1JTOTYpIChtZXRlcilcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChDT1JTOTYpIChVUy1mb3QpXCIsXG5cdFx0XCJOQUQgMTk4MyAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzIChpbnQuIGZvdClcIixcblx0XHRcIk5BRCAxOTgzIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKG1ldGVyKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKFBBMTEpIChtZXRlcilcIixcblx0XHRcIk5BRCAxOTgzIChQQTExKSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoUEExMSkgKFVTLWZvdClcIixcblx0XHRcIk5BRCAxOTgzIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChVUy1mb3QpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgSEFSTiAoaW50LiBmb3QpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgSEFSTiAobWV0ZXIpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIEhBUk4gKFVTLWZvdClcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKGludC4gZm90KVwiLFxuXHRcdFwiTkFEIDE5ODMgTlNSUzIwMDcgKE1ldGVycylcIjogXCJOQUQgMTk4MyBOU1JTMjAwNyAobWV0ZXIpXCIsXG5cdFx0XCJOQUQgMTk4MyBOU1JTMjAwNyAoVVMgRmVldClcIjogXCJOQUQgMTk4MyBOU1JTMjAwNyAoVVMtZm90KVwiLFxuXHRcdFwiTmF0aW9uYWwgR3JpZHNcIjogXCJOYXRpb25lbGxhIHJ1dG7DpHRcIixcblx0XHROYXZham86IFwiTmF2YWpvXCIsXG5cdFx0TmVwdHVuZTogXCJOZXB0dW51c1wiLFxuXHRcdFwiTmV3IEJlaWppbmdcIjogXCJOeWEgUGVraW5nXCIsXG5cdFx0XCJOZXcgWmVhbGFuZFwiOiBcIk55YSBaZWVsYW5kXCIsXG5cdFx0XCJOb3J0aCBBbWVyaWNhXCI6IFwiTm9yZGFtZXJpa2FcIixcblx0XHRcIk5vcnRoZXJuIEhlbWlzcGhlcmVcIjogXCJOb3JyYSBoYWx2a2xvdGV0XCIsXG5cdFx0Tm9yd2F5OiBcIk5vcmdlXCIsXG5cdFx0T2NlYW5zOiBcIkhhdlwiLFxuXHRcdE9yZWdvbjogXCJPcmVnb25cIixcblx0XHRcIk90aGVyIEdDU1wiOiBcIkFubmFuIEdDU1wiLFxuXHRcdFwiUGFjaWZpYyBPY2VhblwiOiBcIlN0aWxsYSBoYXZldFwiLFxuXHRcdFBsdXRvOiBcIlBsdXRvXCIsXG5cdFx0UG9sYXI6IFwiUG9sYXJcIixcblx0XHRQb3J0dWdhbDogXCJQb3J0dWdhbFwiLFxuXHRcdFwiUHJvamVjdGVkIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIlByb2ppY2VyYWRlIGtvb3JkaW5hdHN5c3RlbVwiLFxuXHRcdFwiUHVsa292byAxOTQyXCI6IFwiUHVsa292byAxOTQyXCIsXG5cdFx0XCJQdWxrb3ZvIDE5OTVcIjogXCJQdWxrb3ZvIDE5OTVcIixcblx0XHRSZXBsYWNlZDogXCJFcnNhdHRcIixcblx0XHRcIlNBRCAxOTY5XCI6IFwiU0FEIDE5NjlcIixcblx0XHRTSVJHQVM6IFwiU0lSR0FTXCIsXG5cdFx0XCJTSVJHQVMgMjAwMFwiOiBcIlNJUkdBUyAyMDAwXCIsXG5cdFx0U2F0dXJuOiBcIlNhdHVybnVzXCIsXG5cdFx0XCJTb2xhciBTeXN0ZW1cIjogXCJTb2xzeXN0ZW1cIixcblx0XHRcIlNvdXRoIEFmcmljYVwiOiBcIlN5ZGFmcmlrYVwiLFxuXHRcdFwiU291dGggQW1lcmljYVwiOiBcIlN5ZGFtZXJpa2FcIixcblx0XHRcIlNvdXRoIEtvcmVhXCI6IFwiU3lka29yZWFcIixcblx0XHRcIlNvdXRoZXJuIEhlbWlzcGhlcmVcIjogXCJTw7ZkcmEgaGFsdmtsb3RldFwiLFxuXHRcdFwiU3BoZXJvaWQtYmFzZWRcIjogXCJSb3RhdGlvbnNlbGxpcHNvaWRzYmFzZXJhZFwiLFxuXHRcdFwiU3RhdGUgUGxhbmVcIjogXCJEZWxzdGF0c3BsYW5cIixcblx0XHRcIlN0YXRlIFN5c3RlbXNcIjogXCJEZWxzdGF0c3N5c3RlbVwiLFxuXHRcdFN3ZWRlbjogXCJTdmVyaWdlXCIsXG5cdFx0XCJTd2l0emVybGFuZCBhbmQgTGllY2h0ZW5zdGVpblwiOiBcIlNjaHdlaXogb2NoIExpZWNodGVuc3RlaW5cIixcblx0XHRUZXhhczogXCJUZXhhc1wiLFxuXHRcdFRyaWJhbDogXCJTdGFtXCIsXG5cdFx0VHVya2V5OiBcIlR1cmtpZXRcIixcblx0XHRcIlVTIEZlZXRcIjogXCJVUy1mb3RcIixcblx0XHRcIlVTQSBhbmQgdGVycml0b3JpZXNcIjogXCJVU0Egb2NoIHRlcnJpdG9yaWVybmFcIixcblx0XHRVVE06IFwiVVRNXCIsXG5cdFx0VWtyYWluZTogXCJVa3JhaW5hXCIsXG5cdFx0XCJVbmtub3duIEhlaWdodCBTeXN0ZW1zXCI6IFwiT2vDpG5kYSBow7ZqZHN5c3RlbVwiLFxuXHRcdFVyYW51czogXCJVcmFudXNcIixcblx0XHRWZW51czogXCJWZW51c1wiLFxuXHRcdFwiVmVydGljYWwgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiVmVydGlrYWxhIGtvb3JkaW5hdHN5c3RlbVwiLFxuXHRcdFZpZXRuYW06IFwiVmlldG5hbVwiLFxuXHRcdFwiV0dTIDE5NzJcIjogXCJXR1MgMTk3MlwiLFxuXHRcdFwiV0dTIDE5ODRcIjogXCJXR1MgMTk4NFwiLFxuXHRcdFdpc2NvbnNpbjogXCJXaXNjb25zaW5cIixcblx0XHRcIldpc2NvbnNpbiBDUlNcIjogXCJXaXNjb25zaW4gQ1JTXCIsXG5cdFx0V29ybGQ6IFwiVsOkcmxkZW5cIixcblx0XHRcIldvcmxkIChTcGhlcmUtYmFzZWQpXCI6IFwiVsOkcmxkZW4gKHNmw6RyYmFzZXJhZClcIixcblx0XHRXeW9taW5nOiBcIld5b21pbmdcIixcblx0XHRcIlhpYW4gMTk4MFwiOiBcIlhpYW4gMTk4MFwiLFxuXHRcdGRvbmU6IFwiS2xhclwiLFxuXHRcdG5vUmVzdWx0czogXCJJbmdhIHJlc3VsdGF0IGhpdHRhZGVzXCIsXG5cdFx0c2VhcmNoUGxhY2Vob2xkZXI6IFwiTmFtbiBlbGxlciBXS0lEXCIsXG5cdFx0YnJvd3NlVGVtcGxhdGU6IFwiQmzDpGRkcmEgYmxhbmQgbWFsbGFyIGbDtnIgcmFzdGVyZnVua3Rpb25cIixcblx0XHRzYXZlVGVtcGxhdGU6IFwiU3BhcmEgbWFsbCBmw7ZyIHJhc3RlcmZ1bmt0aW9uXCIsXG5cdFx0cHJldmlldzogXCJGw7ZyaGFuZHNncmFuc2thXCIsXG5cdFx0cHJldmlld0Rlc2NyaXB0aW9uOiBcIkbDtnJoYW5kc2dyYW5za2EgcmVzdWx0YXRldCBpbm5hbiBkdSBrw7ZyIGFuYWx5c2VuLlwiLFxuXHRcdHNob3dQcmV2aWV3OiBcIlZpc2EgZsO2cmhhbmRzZ3JhbnNrbmluZ1wiLFxuXHRcdHByZXZpZXdMYXllcjogXCJGw7ZyaGFuZHNncmFuc2thIGxhZ2VyICR7bnVtYmVyfVwiLFxuXHRcdG5ld1ByZXZpZXc6IFwiTnkgZsO2cmhhbmRzZ3JhbnNrbmluZ1wiLFxuXHRcdHByZXZpZXdQb3B1cDogXCJBa3RpdmVyYSBmw7ZyaGFuZHNncmFuc2tuaW5nZW4gYXYgYW5hbHlzcmVzdWx0YXRlbiBiYXNlcmF0IHDDpSBpbmRhdGFwYXJhbWV0cmFybmEuXCIsXG5cdFx0dXBkYXRlUHJldmlld0xheWVyOiBcIlVwcGRhdGVyYSB2YWx0IGbDtnJoYW5kc3Zpc25pbmdzbGFnZXJcIixcblx0XHRjcmVhdGVQcmV2aWV3TGF5ZXI6IFwiU2thcGEgbnl0dCBmw7ZyaGFuZHN2aXNuaW5nc2xhZ2VyXCIsXG5cdFx0bWF4aW11bVByZXZpZXdBbGxvd2VkOiBcIkjDtmdzdGEgYW50YWwgdGlsbMOldG5hIGbDtnJoYW5kc3Zpc25pbmdzbGFnZXI6ICR7bWF4Q291bnR9XCIsXG5cdFx0cHJldmlld0ZhaWx1cmU6IFwiRGV0dGEgZsO2cmhhbmRzdmlzbmluZ3NsYWdlciDDpHIgZWogdGlsbGfDpG5nbGlndC4gS29udHJvbGxlcmEgaW5kYXRhcGFyYW1ldHJhcm5hIG9jaCB1cHBkYXRlcmEgZGV0IGjDpHIgZsO2cmhhbmRzdmlzbmluZ3NsYWdyZXQgaWdlbi5cIixcblx0XHRoZWFkZXI6IFwiVsOkbGogb2JqZWt0XCIsXG5cdFx0Y29udGVudDogXCJEdSBoYXIgb3NwYXJhZGUgw6RuZHJpbmdhciBpICR7cmZ0VGl0bGV9LiBPbSBkdSBiw7ZyamFyIG9tIG1lZCBlbiBueSBtYWxsIGfDpXIgZGVzc2Egw6RuZHJpbmdhciBmw7ZybG9yYWRlLlwiLFxuXHRcdGRvbnRTYXZlOiBcIlNwYXJhIGludGVcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiRm9ydHPDpHR0XCIsXG5cdFx0c3RyZXRjaDogXCJBbnBhc3NhIHRpbGwgZsO2bnN0ZXJcIixcblx0XHRwYW46IFwiUGFub3JlcmFcIixcblx0XHRuZXdUZW1wbGF0ZTogXCJTa2FwYSBueSBtYWxsXCIsXG5cdFx0b3BlblRlbXBsYXRlOiBcIsOWcHBuYSBtYWxsXCIsXG5cdFx0YWRkRnVuY3Rpb246IFwiTMOkZ2cgdGlsbCByYXN0ZXJmdW5rdGlvbmVyXCIsXG5cdFx0YWRkQ29uc3RhbnQ6IFwiTMOkZ2cgdGlsbCBrb25zdGFudFwiLFxuXHRcdGFkZFJhc3RlcjogXCJMw6RnZyB0aWxsIHJhc3RlcnZhcmlhYmVsXCIsXG5cdFx0bW92ZTogXCJGbHl0dGFcIixcblx0XHR6b29tOiBcIlpvb21hXCIsXG5cdFx0c2F2ZUFzOiBcIlNwYXJhIHNvbVwiLFxuXHRcdGNsZWFyOiBcIlJhZGVyYVwiLFxuXHRcdGFkZFJhc3RlckZ1bmN0aW9uVGl0bGU6IFwiTMOkZ2cgdGlsbCByYXN0ZXJmdW5rdGlvbmVyXCIsXG5cdFx0dGVtcGxhdGVQcm9wZXJ0aWVzVGl0bGU6IFwiTWFsbGVnZW5za2FwZXJcIixcblx0XHRicm93c2VSRlQ6IFwiQmzDpGRkcmEgYmxhbmQgbWFsbGFyIGbDtnIgcmFzdGVyZnVua3Rpb25cIixcblx0XHRkZWZhdWx0VG9vbERlc2NyaXB0aW9uOiBcIiR7dG9vbFRpdGxlfSBhbmFseXN2ZXJrdHlnLlwiLFxuXHRcdG9wZW5Ub29sVGV4dDogXCLDlnBwbmEgdmVya3R5Z1wiLFxuXHRcdHRvb2xEcm9wZG93blRleHQ6IFwiVmVya3R5Z3NsaXN0bWVueVwiLFxuXHRcdGFkZFRvTWFwOiBcIkJla3LDpGZ0YSBvY2ggbMOkZ2cgdGlsbCBww6Uga2FydGFcIixcblx0XHRjb25maXJtOiBcIkJla3LDpGZ0YVwiLFxuXHRcdHNlbGVjdDogXCJWw6RsalwiLFxuXHRcdHNlbGVjdFRhc2s6IFwiVsOkbGogdXBwZ2lmdFwiLFxuXHRcdHVuc3VwcG9ydGVkTGF5ZXI6IFwiRGVuIGjDpHIgcGFyYW1ldGVybiBzdMO2ZGVyIGludGUgZsO2bGphbmRlIGxhZ2VyOiAke2xheWVyTmFtZX0uXCIsXG5cdFx0dmlld0RldGFpbHM6IFwiVmlzYSBmdWxsc3TDpG5kaWcgb2JqZWt0aW5mb3JtYXRpb25cIixcblx0XHRyZW5hbWU6IFwiQnl0IG5hbW5cIixcblx0XHRkdXBsaWNhdGU6IFwiRHVwbGljZXJhXCIsXG5cdFx0bGF1bmNoOiBcIsOWcHBuYSBmw7ZyIGF0dCBrw7ZyYVwiLFxuXHRcdHRlbXBsYXRlRWRpdG9yOiBcIk1hbGxyZWRpZ2VyYXJlXCIsXG5cdFx0Y3JlYXRlSXRlbTogXCJTcGFyYSBtYWxsIGbDtnIgcmFzdGVyZnVua3Rpb25cIixcblx0XHRhY3Rpb25MYWJlbDogXCJGaWx0ZXJcIixcblx0XHRmaWx0ZXJQb3BvdmVySGVhZGluZzogXCJGaWx0cmVyYSBmdW5rdGlvbmVyXCIsXG5cdFx0ZGVmYXVsdFNlYXJjaFBsYWNlaG9sZGVyOiBcIlPDtmsgZWZ0ZXIgbmFtblwiLFxuXHRcdHNldHRpbmdzOiBcIkluc3TDpGxsbmluZ2FyXCIsXG5cdFx0c3VtbWFyeTogXCJTYW1tYW5mYXR0bmluZ1wiLFxuXHRcdGRlZmluaXRpb25RdWVyeTogXCJEZWZpbml0aW9uc2Zyw6VnYVwiLFxuXHRcdG1hdGNoVmFyaWFibGVzOiBcIk1hdGNoYSB2YXJpYWJsZXJcIixcblx0XHR1bmlvbkRpbWVuc2lvbjogXCJVbmlvbnNkaW1lbnNpb25cIixcblx0XHRuYW1lRWRpdG9yUGxhY2Vob2xkZXI6IFwiQW5nZSB0aXRlbFwiLFxuXHRcdHN1bW1hcnlFZGl0b3JQbGFjZWhvbGRlcjogXCJBbmdlIGVuIGtvcnQgYmVza3Jpdm5pbmcuXCIsXG5cdFx0ZGVmaW5pdGlvblF1ZXJ5UGxhY2Vob2xkZXI6IFwiQW5nZS4uLlwiLFxuXHRcdHVwbG9hZDogXCLDlnZlcmbDtnJcIixcblx0XHRjaG9vc2VJbWFnZTogXCJLbGlja2EgZsO2ciBhdHQgdsOkbGphIGVuIGZpbFwiLFxuXHRcdHVwZGF0ZTogXCJVcHBkYXRlcmFcIixcblx0XHR0aHVtYm5haWxFcnJvcnM6IHtcblx0XHRcdHdyb25nSW1hZ2VUeXBlOiBcIkZlbCBiaWxkdHlwIMOkciB2YWxkXCIsXG5cdFx0XHRub3RBdmFpbGFibGU6IFwiSW5nZW4gbWluaWF0eXJiaWxkIGZpbm5zIHRpbGxnw6RuZ2xpZ1wiLFxuXHRcdFx0bG9hZEVycm9yOiBcIkRldCBnaWNrIGludGUgYXR0IGxhZGRhIGJpbGRlblwiLFxuXHRcdFx0Y2hvb3NlRmlsZTogXCJLbGlja2EgZsO2ciBhdHQgdsOkbGphIGZpbFwiXG5cdFx0fVxuXHR9XG59O1xuY29uc3QgY29weSA9IFwiS29waWVyYVwiO1xuY29uc3Qgc2F2ZSA9IFwiU3BhcmFcIjtcbmNvbnN0IHRpdGxlID0gXCJUaXRlbFwiO1xuY29uc3QgZm9sZGVyID0gXCJNYXBwXCI7XG5jb25zdCB0YWdzID0gXCJUYWdnYXJcIjtcbmNvbnN0IHNhdmluZ01lc3NhZ2UgPSBcIlNwYXJhciBvYmpla3QgdGlsbFwiO1xuY29uc3Qgc2hhcmVXaXRoID0gXCJEZWxhIG1lZFwiO1xuY29uc3Qgc2hhcmUgPSBcIkRlbGFcIjtcbmNvbnN0IHNldFNoYXJpbmdMZXZlbCA9IFwiU3TDpGxsIGluIGRlbG5pbmdzbml2w6VcIjtcbmNvbnN0IHNldEdyb3VwU2hhcmluZyA9IFwiU3TDpGxsIGluIGdydXBwZGVsbmluZ1wiO1xuY29uc3Qgb3duZXIgPSBcIsOEZ2FyZVwiO1xuY29uc3Qgb3JnYW5pemF0aW9uID0gXCJPcmdhbmlzYXRpb25cIjtcbmNvbnN0IGV2ZXJ5b25lID0gXCJBbGxhIChwdWJsaWspXCI7XG5jb25zdCBncm91cHMgPSBcIkdydXBwZXI6XCI7XG5jb25zdCB0eXBlID0gXCJUeXBcIjtcbmNvbnN0IG1vc2FpYyA9IFwiTW9zYWlrXCI7XG5jb25zdCBpdGVtR3JvdXAgPSBcIk9iamVrdGdydXBwXCI7XG5jb25zdCBpdGVtID0gXCJPYmpla3RcIjtcbmNvbnN0IGRlZmluaXRpb25RdWVyeSA9IFwiRGVmaW5pdGlvbnNmcsOlZ2FcIjtcbmNvbnN0IGdyb3VwSXRlbXNCeSA9IFwiR3J1cHBlcmEgb2JqZWt0IGVmdGVyXCI7XG5jb25zdCBncm91cEZpZWxkTmFtZSA9IFwiR3J1cHBlcmEgZsOkbHRuYW1uXCI7XG5jb25zdCB0YWdGaWVsZE5hbWUgPSBcIlRhZ2dmw6RsdG5hbW5cIjtcbmNvbnN0IG5vVGl0bGVUYWdFcnJvck1zZyA9IFwiRHUgbcOlc3RlIGFuZ2UgZW4gdGl0ZWwgZsO2ciBvYmpla3RldCBvY2ggdGFnZ2FyIHNvbSBnw7ZyIGF0dCBrYXJ0YW4gZ8OlciBhdHQgaGl0dGEgZ2Vub20gc8O2a25pbmdhci5cIjtcbmNvbnN0IG5vVGl0bGVFcnJvck1zZyA9IFwiRHUgbcOlc3RlIGFuZ2UgZW4gdGl0ZWwgZsO2ciBvYmpla3RldC5cIjtcbmNvbnN0IG5vVGFnRXJyb3JNc2cgPSBcIkR1IG3DpXN0ZSBhbmdlIG1pbnN0IGVuIHRhZ2cgZsO2ciBhdHQgaGrDpGxwYSBhbmRyYSBhdHQgaGl0dGEgb2JqZWt0ZXQgaSBzw7ZrbmluZ2FyLlwiO1xuY29uc3QgZXJyb3IgPSBcIkZlbFwiO1xuY29uc3Qgd2FybmluZyA9IFwiVmFybmluZ1wiO1xuY29uc3Qgc3VjY2VzcyA9IFwiTHlja2FkZXNcIjtcbmNvbnN0IGRldGFpbHMgPSBcIkluZm9ybWF0aW9uOlwiO1xuY29uc3QgdHJ5QWdhaW4gPSBcIlByb3ZhIGlnZW5cIjtcbmNvbnN0IHRvb2xNb2RlbGVyID0ge1xuXHRzYXZlOiBcIlNwYXJhXCIsXG5cdGVkaXRQcm9wZXJ0aWVzOiBcIlJlZGlnZXJhIGVnZW5za2FwZXJcIixcblx0c2F2ZUFzOiBcIlNwYXJhIHNvbVwiLFxuXHRzYXZpbmdOb3RpZmljYXRpb246IFwiU3BhcmFyIMOkbmRyaW5nYXIgYXYgb2JqZWt0IC4uLlwiLFxuXHRzYXZpbmdUaXRsZTogXCJTcGFyYXJcIixcblx0c2F2ZUZhaWxlZE1lc3NhZ2U6IFwiRGV0IGdpY2sgaW50ZSBhdHQgc3BhcmEgw6RuZHJpbmdhcm5hLlwiLFxuXHRzYXZlV2l0aEVycm9yc01lc3NhZ2U6IFwiw4RuZHJpbmdhciBzcGFyYWRlcyBtZWQgZsO2bGphbmRlIGZlbC5cIixcblx0dmlld0l0ZW1NZXNzYWdlOiBcIlZpc2EgZGV0IHNwYXJhZGUgb2JqZWt0ZXRcIixcblx0aGVyZTogXCJow6RyLlwiLFxuXHRpdGVtQ3JlYXRlZE1lc3NhZ2U6IFwiTnl0dCBvYmpla3QgaGFyIHNrYXBhdHMuXCIsXG5cdGNsaWNrVG9WaWV3SXRlbU1lc3NhZ2U6IFwiS2xpY2thIHDDpSBPSyBmw7ZyIGF0dCB2aXNhIG9iamVrdGluZm9ybWF0aW9uc3NpZGFuOyBrbGlja2EgcMOlIEF2YnJ5dCBmw7ZyIGF0dCBmb3J0c8OkdHRhLlwiLFxuXHRyZWFkaW5nRmFpbGVkOiBcIkRldCBnw6VyIGludGUgYXR0IGzDpHNhIGluIGRlbiB2YWxkYSByYXN0ZXJmdW5rdGlvbnNtYWxsZW4uXCIsXG5cdGZhaWxlZFRvTG9hZFhNTDogXCJEZXQgZ8OlciBpbnRlIGF0dCBsw6RzYSBpbiBkZW4gdmFsZGEgcmFzdGVyZnVua3Rpb25zbWFsbGVuIGkgWE1MLWZvcm1hdC5cIixcblx0bGVhcm5Nb3JlOiBcIkzDpHMgbWVyXCIsXG5cdG92ZXJ3cml0ZVRpdGxlOiBcIkJla3LDpGZ0YSBhdHQgZHUgdmlsbCBza3JpdmEgw7Z2ZXJcIixcblx0b3ZlcndyaXRlTWVzc2FnZTogXCJWaWxsIGR1IHNrcml2YSDDtnZlciBldHQgYmVmaW50bGlndCBvYmpla3Q/XCIsXG5cdG92ZXJ3cml0ZVN1Y2Nlc3NNZXNzYWdlOiBcIk9iamVrdGV0IGhhciB1cHBkYXRlcmF0cy5cIlxufTtcbmNvbnN0IHRvb2xFZGl0b3IgPSB7XG5cdHJ1bjogXCJLw7ZyXCIsXG5cdHNhdmU6IFwiU3BhcmFcIixcblx0ZGVsZXRlU2VsZWN0ZWQ6IFwiVGEgYm9ydCBtYXJrZXJhZGUgb2JqZWt0XCIsXG5cdGFkZFJhc3RlcjogXCJMw6RnZyB0aWxsIHJhc3RlclwiLFxuXHRhZGRTY2FsYXI6IFwiTMOkZ2cgdGlsbCBza2Fsw6RyXCIsXG5cdGxheW91dDogXCJBdXRvbWF0aXNrIGxheW91dFwiLFxuXHRlcnJvclRpdGxlOiBcIkZlbFwiLFxuXHRpbnZhbGlkVG9vbE1lc3NhZ2U6IFwiUmFzdGVyZnVua3Rpb25zbWFsbGVuIMOkciBpbnRlIGdpbHRpZy5cIixcblx0b3V0OiBcIlV0XCIsXG5cdHpvb21JbjogXCJab29tYSBpblwiLFxuXHR6b29tT3V0OiBcIlpvb21hIHV0XCIsXG5cdHpvb21Ub0ZpdDogXCJBbnBhc3NhIHRpbGwgZsO2bnN0ZXJcIixcblx0cGFuT246IFwiVsOkeGxhIHRpbGwgcGFub3JlcmluZ3Nsw6RnZVwiLFxuXHRwYW5PZmY6IFwiU3TDpG5nIGF2IHBhbm9yZXJpbmdzbMOkZ2VcIixcblx0ZGVmYXVsdE1vZGVsTmFtZTogXCJWZXJrdHlnc21vZGVsbFwiLFxuXHRkZWZhdWx0UmFzdGVyTmFtZTogXCJSYXN0ZXJcIlxufTtcbmNvbnN0IHRvb2xEZXRhaWxzRWRpdG9yID0ge1xuXHRkZWZhdWx0VG9vbE5hbWU6IFwiTWFsbCBmw7ZyIHJhc3RlcmZ1bmt0aW9uXCIsXG5cdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiTMOkZ2cgdGlsbCBlbiBrb3J0IHNhbW1hbmZhdHRuaW5nIGF2IHJhc3RlcmZ1bmt0aW9uZW4uXCIsXG5cdGRlZmF1bHRIZWxwVGV4dDogXCJLbGlja2EgcMOlIGhqw6RscGlrb25lbiBvbSBkdSB2aWxsIHJlZGlnZXJhIGhqw6RscHRleHRlbi5cIixcblx0ZWRpdEhlbHBUaXRsZTogXCJSZWRpZ2VyYSBoasOkbHBcIixcblx0c2F2ZUxhYmVsOiBcIlNwYXJhXCIsXG5cdGNhbmNlbExhYmVsOiBcIkF2YnJ5dFwiLFxuXHR0aHVtYm5haWw6IHtcblx0XHR3cm9uZ0ltYWdlVHlwZTogXCJGZWwgYmlsZHR5cCDDpHIgdmFsZFwiLFxuXHRcdG5vdEF2YWlsYWJsZTogXCJJbmdlbiBtaW5pYXR5cmJpbGQgZmlubnMgdGlsbGfDpG5nbGlnXCIsXG5cdFx0bG9hZEVycm9yOiBcIkRldCBnaWNrIGludGUgYXR0IGxhZGRhIGJpbGRlblwiLFxuXHRcdGNob29zZUZpbGU6IFwiS2xpY2thIGbDtnIgYXR0IHbDpGxqYSBmaWxcIlxuXHR9XG59O1xuY29uc3Qgc2F2ZVV0aWxzID0ge1xuXHR0aHVtYm5haWw6IFwiTWluaWF0eXJiaWxkXCIsXG5cdHNoYXJpbmc6IFwiRGVsbmluZ1wiXG59O1xuY29uc3QgY2xvc2UgPSBcIlN0w6RuZ1wiO1xuY29uc3QgdW5zYXZlZFdhcm5pbmdFeGlzdGluZyA9IFwiVmlsbCBkdSBzcGFyYSDDpG5kcmluZ2FybmEgYXYgb2JqZWt0ZXQgPGI+JHtpdGVtVGl0bGV9PC9iPj9cIjtcbmNvbnN0IHVuc2F2ZWRXYXJuaW5nTmV3ID0gXCJWaWxsIGR1IHNwYXJhIGRpbmEgw6RuZHJpbmdhcj9cIjtcbmNvbnN0IHNhdmVBcyA9IFwiU3BhcmEgc29tXCI7XG5jb25zdCBkb250U2F2ZSA9IFwiU3BhcmEgaW50ZVwiO1xuY29uc3QgdW5zYXZlZFRpdGxlID0gXCJPc3BhcmFkZSDDpG5kcmluZ2FyXCI7XG5jb25zdCBpbnZhbGlkUkZUTWVzc2FnZSA9IFwiUmFzdGVyZnVua3Rpb25zbWFsbGVuIHNvbSBza2FwYXRzIMOkciBpbnRlIGdpbHRpZy5cIjtcbmNvbnN0IGVycm9yVGl0bGUgPSBcIkZlbFwiO1xuY29uc3QgYnJlYWRjcnVtYiA9IFwiUmFzdGVyZnVua3Rpb25zcmVkaWdlcmFyZVwiO1xuY29uc3QgYnJlYWRjcnVtYkVkaXRvciA9IFwiSW5uZWjDpWxsID4gcmFzdGVyZnVua3Rpb25zcmVkaWdlcmFyZVwiO1xuY29uc3Qgdmlld2VyTW9kZVRpdGxlID0gXCJTa3JpdnNreWRkYWRcIjtcbmNvbnN0IHZpZXdlck1vZGVNZXNzYWdlID0gXCJSYXN0ZXJmdW5rdGlvbnNtYWxsb2JqZWt0ZXQgw6RyIHNrcml2c2t5ZGRhdC4gw4RuZHJpbmdhcm5hIGthbiBpbnRlIHNwYXJhcy5cIjtcbmNvbnN0IHVzZXJTdGFydERpcmVjdGlvbiA9IFwiVsOkbGogZW4gZnVua3Rpb24gZsO2ciBhdHQgYsO2cmphIHNrYXBhIGVuIHJhc3RlcmZ1bmt0aW9uc21hbGwuXCI7XG5jb25zdCBzZWxlY3RGdW5jdGlvbiA9IFwiTMOkZ2cgdGlsbCBmdW5rdGlvblwiO1xuY29uc3QgZGVzZWxlY3RGdW5jdGlvbiA9IFwiVGEgYm9ydCBmdW5rdGlvblwiO1xuY29uc3QgZGlhbG9nVGl0bGUgPSBcIlN5c3RlbVwiO1xuY29uc3QgY2F0ZWdvcnkgPSBcIkthdGVnb3JpZXJcIjtcbmNvbnN0IHNlYXJjaCA9IFwiU8O2ayByYXN0ZXJmdW5rdGlvbmVyXCI7XG5jb25zdCBjYXRlZ29yeU5hbWVzID0ge1xuXHRhbmFseXNpczogXCJBbmFseXNcIixcblx0YXBwZWFyYW5jZTogXCJVdHNlZW5kZVwiLFxuXHRjbGFzc2lmaWNhdGlvbjogXCJLbGFzc2lmaWNlcmluZ1wiLFxuXHRjb252ZXJzaW9uOiBcIktvbnZlcnRlcmluZ1wiLFxuXHRjb3JyZWN0aW9uOiBcIktvcnJpZ2VyaW5nXCIsXG5cdGRhdGFNYW5hZ2VtZW50OiBcIkRhdGFoYW50ZXJpbmdcIixcblx0ZGlzdGFuY2U6IFwiQXZzdMOlbmRcIixcblx0ZGlzdGFuY2VMZWdhY3k6IFwiQXZzdMOlbmQgKMOkbGRyZSlcIixcblx0aHlkcm9sb2d5OiBcIkh5ZHJvbG9naVwiLFxuXHRtYXRoOiBcIk1hdGVtYXRpa1wiLFxuXHRtYXRoQ29uZGl0aW9uYWw6IFwiTWF0ZW1hdGlrOiB2aWxsa29ybGlnXCIsXG5cdG1hdGhMb2dpY2FsOiBcIk1hdGVtYXRpazogbG9naXNrXCIsXG5cdG1hdGhUcmlnb25vbWV0cmljOiBcIk1hdGVtYXRpazogdHJpZ29ub21ldHJpc2tcIixcblx0cmVjbGFzczogXCJPbWtsYXNzbmluZ1wiLFxuXHRzdGF0aXN0aWNhbDogXCJTdGF0aXN0aXNrXCIsXG5cdHN1cmZhY2U6IFwiWXRhXCJcbn07XG5jb25zdCBjb21tb25TdHJpbmdzX3N2ID0ge1xuXHRvazogb2ssXG5cdGNhbmNlbDogY2FuY2VsLFxuXHRlbnRlclVSTDogZW50ZXJVUkwsXG5cdHNlcnZpY2VVUkw6IHNlcnZpY2VVUkwsXG5cdHNlbGVjdFJhc3Rlcjogc2VsZWN0UmFzdGVyLFxuXHRmYWlsZWRUb0xvYWRMYXllcjogZmFpbGVkVG9Mb2FkTGF5ZXIsXG5cdGxvYWRpbmdMYXllcjogbG9hZGluZ0xheWVyLFxuXHRzZWxlY3RGZWF0dXJlOiBzZWxlY3RGZWF0dXJlLFxuXHRlbnRlckZVUkw6IGVudGVyRlVSTCxcblx0YWRkUmFzdGVyOiBhZGRSYXN0ZXIsXG5cdGFkZFNjYWxhcjogYWRkU2NhbGFyLFxuXHRyYXN0ZXI6IHJhc3Rlcixcblx0c2NhbGFyOiBzY2FsYXIsXG5cdGRlZmF1bHRNb2RlbE5hbWU6IGRlZmF1bHRNb2RlbE5hbWUsXG5cdGdlbmVyYWw6IGdlbmVyYWwsXG5cdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG5cdHZhcmlhYmxlczogdmFyaWFibGVzLFxuXHRuYW1lOiBuYW1lLFxuXHRkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG5cdHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuXHRpc1B1YmxpYzogaXNQdWJsaWMsXG5cdGlzRGF0YXNldDogaXNEYXRhc2V0LFxuXHR1bmtub3duUGl4ZWxUeXBlOiB1bmtub3duUGl4ZWxUeXBlLFxuXHRvdXRwdXRQaXhlbFR5cGU6IG91dHB1dFBpeGVsVHlwZSxcblx0dThQaXhlbFR5cGU6IHU4UGl4ZWxUeXBlLFxuXHRzOFBpeGVsVHlwZTogczhQaXhlbFR5cGUsXG5cdHUxNlBpeGVsVHlwZTogdTE2UGl4ZWxUeXBlLFxuXHRzMTZQaXhlbFR5cGU6IHMxNlBpeGVsVHlwZSxcblx0dTMyUGl4ZWxUeXBlOiB1MzJQaXhlbFR5cGUsXG5cdHMzMlBpeGVsVHlwZTogczMyUGl4ZWxUeXBlLFxuXHRmMzJQaXhlbFR5cGU6IGYzMlBpeGVsVHlwZSxcblx0ZjY0UGl4ZWxUeXBlOiBmNjRQaXhlbFR5cGUsXG5cdHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdG11bHRpZGltZW5zaW9uYWxSdWxlczogbXVsdGlkaW1lbnNpb25hbFJ1bGVzLFxuXHRtYXRjaFZhcmlhYmxlczogbWF0Y2hWYXJpYWJsZXMsXG5cdHVuaW9uRGltZW5zaW9uczogdW5pb25EaW1lbnNpb25zLFxuXHRyYXN0ZXJGdW5jdGlvbkVkaXRvcjogcmFzdGVyRnVuY3Rpb25FZGl0b3IsXG5cdHJmeExpY2Vuc2VJbmZvOiByZnhMaWNlbnNlSW5mbyxcblx0cmFzdGVyRnVuY3Rpb25zOiByYXN0ZXJGdW5jdGlvbnMsXG5cdGNvcHk6IGNvcHksXG5cdHNhdmU6IHNhdmUsXG5cdHRpdGxlOiB0aXRsZSxcblx0Zm9sZGVyOiBmb2xkZXIsXG5cdHRhZ3M6IHRhZ3MsXG5cdHNhdmluZ01lc3NhZ2U6IHNhdmluZ01lc3NhZ2UsXG5cdHNoYXJlV2l0aDogc2hhcmVXaXRoLFxuXHRzaGFyZTogc2hhcmUsXG5cdHNldFNoYXJpbmdMZXZlbDogc2V0U2hhcmluZ0xldmVsLFxuXHRzZXRHcm91cFNoYXJpbmc6IHNldEdyb3VwU2hhcmluZyxcblx0b3duZXI6IG93bmVyLFxuXHRvcmdhbml6YXRpb246IG9yZ2FuaXphdGlvbixcblx0ZXZlcnlvbmU6IGV2ZXJ5b25lLFxuXHRncm91cHM6IGdyb3Vwcyxcblx0dHlwZTogdHlwZSxcblx0bW9zYWljOiBtb3NhaWMsXG5cdGl0ZW1Hcm91cDogaXRlbUdyb3VwLFxuXHRpdGVtOiBpdGVtLFxuXHRkZWZpbml0aW9uUXVlcnk6IGRlZmluaXRpb25RdWVyeSxcblx0Z3JvdXBJdGVtc0J5OiBncm91cEl0ZW1zQnksXG5cdGdyb3VwRmllbGROYW1lOiBncm91cEZpZWxkTmFtZSxcblx0dGFnRmllbGROYW1lOiB0YWdGaWVsZE5hbWUsXG5cdG5vVGl0bGVUYWdFcnJvck1zZzogbm9UaXRsZVRhZ0Vycm9yTXNnLFxuXHRub1RpdGxlRXJyb3JNc2c6IG5vVGl0bGVFcnJvck1zZyxcblx0bm9UYWdFcnJvck1zZzogbm9UYWdFcnJvck1zZyxcblx0ZXJyb3I6IGVycm9yLFxuXHR3YXJuaW5nOiB3YXJuaW5nLFxuXHRzdWNjZXNzOiBzdWNjZXNzLFxuXHRkZXRhaWxzOiBkZXRhaWxzLFxuXHR0cnlBZ2FpbjogdHJ5QWdhaW4sXG5cdHRvb2xNb2RlbGVyOiB0b29sTW9kZWxlcixcblx0dG9vbEVkaXRvcjogdG9vbEVkaXRvcixcblx0dG9vbERldGFpbHNFZGl0b3I6IHRvb2xEZXRhaWxzRWRpdG9yLFxuXHRzYXZlVXRpbHM6IHNhdmVVdGlscyxcblx0Y2xvc2U6IGNsb3NlLFxuXHR1bnNhdmVkV2FybmluZ0V4aXN0aW5nOiB1bnNhdmVkV2FybmluZ0V4aXN0aW5nLFxuXHR1bnNhdmVkV2FybmluZ05ldzogdW5zYXZlZFdhcm5pbmdOZXcsXG5cdHNhdmVBczogc2F2ZUFzLFxuXHRkb250U2F2ZTogZG9udFNhdmUsXG5cdHVuc2F2ZWRUaXRsZTogdW5zYXZlZFRpdGxlLFxuXHRpbnZhbGlkUkZUTWVzc2FnZTogaW52YWxpZFJGVE1lc3NhZ2UsXG5cdGVycm9yVGl0bGU6IGVycm9yVGl0bGUsXG5cdGJyZWFkY3J1bWI6IGJyZWFkY3J1bWIsXG5cdGJyZWFkY3J1bWJFZGl0b3I6IGJyZWFkY3J1bWJFZGl0b3IsXG5cdHZpZXdlck1vZGVUaXRsZTogdmlld2VyTW9kZVRpdGxlLFxuXHR2aWV3ZXJNb2RlTWVzc2FnZTogdmlld2VyTW9kZU1lc3NhZ2UsXG5cdHVzZXJTdGFydERpcmVjdGlvbjogdXNlclN0YXJ0RGlyZWN0aW9uLFxuXHRzZWxlY3RGdW5jdGlvbjogc2VsZWN0RnVuY3Rpb24sXG5cdGRlc2VsZWN0RnVuY3Rpb246IGRlc2VsZWN0RnVuY3Rpb24sXG5cdGRpYWxvZ1RpdGxlOiBkaWFsb2dUaXRsZSxcblx0Y2F0ZWdvcnk6IGNhdGVnb3J5LFxuXHRzZWFyY2g6IHNlYXJjaCxcblx0Y2F0ZWdvcnlOYW1lczogY2F0ZWdvcnlOYW1lc1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29tbW9uU3RyaW5nc19zdjtcbmV4cG9ydCB7IGFkZFJhc3RlciwgYWRkU2NhbGFyLCBicmVhZGNydW1iLCBicmVhZGNydW1iRWRpdG9yLCBjYW5jZWwsIGNhdGVnb3J5LCBjYXRlZ29yeU5hbWVzLCBjbG9zZSwgY29weSwgZGVmYXVsdE1vZGVsTmFtZSwgZGVmaW5pdGlvblF1ZXJ5LCBkZXNjcmlwdGlvbiwgZGVzZWxlY3RGdW5jdGlvbiwgZGV0YWlscywgZGlhbG9nVGl0bGUsIGRvbnRTYXZlLCBlbnRlckZVUkwsIGVudGVyVVJMLCBlcnJvciwgZXJyb3JUaXRsZSwgZXZlcnlvbmUsIGYzMlBpeGVsVHlwZSwgZjY0UGl4ZWxUeXBlLCBmYWlsZWRUb0xvYWRMYXllciwgZm9sZGVyLCBnZW5lcmFsLCBncm91cEZpZWxkTmFtZSwgZ3JvdXBJdGVtc0J5LCBncm91cHMsIGludmFsaWRSRlRNZXNzYWdlLCBpc0RhdGFzZXQsIGlzUHVibGljLCBpdGVtLCBpdGVtR3JvdXAsIGxvYWRpbmdMYXllciwgbWF0Y2hWYXJpYWJsZXMsIG1vc2FpYywgbXVsdGlkaW1lbnNpb25hbFJ1bGVzLCBuYW1lLCBub1RhZ0Vycm9yTXNnLCBub1RpdGxlRXJyb3JNc2csIG5vVGl0bGVUYWdFcnJvck1zZywgb2ssIG9yZ2FuaXphdGlvbiwgb3V0cHV0UGl4ZWxUeXBlLCBvd25lciwgcGFyYW1ldGVyLCBwYXJhbWV0ZXJzLCBwcm9wZXJ0aWVzLCByYXN0ZXIsIHJhc3RlckZ1bmN0aW9uRWRpdG9yLCByYXN0ZXJGdW5jdGlvbnMsIHJmeExpY2Vuc2VJbmZvLCBzMTZQaXhlbFR5cGUsIHMzMlBpeGVsVHlwZSwgczhQaXhlbFR5cGUsIHNhdmUsIHNhdmVBcywgc2F2ZVV0aWxzLCBzYXZpbmdNZXNzYWdlLCBzY2FsYXIsIHNlYXJjaCwgc2VsZWN0RmVhdHVyZSwgc2VsZWN0RnVuY3Rpb24sIHNlbGVjdFJhc3Rlciwgc2VydmljZVVSTCwgc2V0R3JvdXBTaGFyaW5nLCBzZXRTaGFyaW5nTGV2ZWwsIHNoYXJlLCBzaGFyZVdpdGgsIHN1Y2Nlc3MsIHRhZ0ZpZWxkTmFtZSwgdGFncywgdGl0bGUsIHRvb2xEZXRhaWxzRWRpdG9yLCB0b29sRWRpdG9yLCB0b29sTW9kZWxlciwgdHJ5QWdhaW4sIHR5cGUsIHUxNlBpeGVsVHlwZSwgdTMyUGl4ZWxUeXBlLCB1OFBpeGVsVHlwZSwgdW5pb25EaW1lbnNpb25zLCB1bmtub3duUGl4ZWxUeXBlLCB1bnNhdmVkVGl0bGUsIHVuc2F2ZWRXYXJuaW5nRXhpc3RpbmcsIHVuc2F2ZWRXYXJuaW5nTmV3LCB1c2VyU3RhcnREaXJlY3Rpb24sIHZhcmlhYmxlcywgdmlld2VyTW9kZU1lc3NhZ2UsIHZpZXdlck1vZGVUaXRsZSwgd2FybmluZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24tc3RyaW5ncy5zdi05ZDIzZDkzOC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=