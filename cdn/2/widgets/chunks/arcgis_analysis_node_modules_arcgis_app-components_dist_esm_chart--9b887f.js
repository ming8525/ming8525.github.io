"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_chart--9b887f"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/chart-097ec280.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/chart-097ec280.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ createChartRendererFromExisting),
/* harmony export */   c: () => (/* binding */ createChartRenderer)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




/**
 * Updates the layer with a Chart renderer with default settings
 * @param options: options
 */
function createChartRenderer(options) {
    var _a;
    const { layer: smLayer, mapView, selectedFields, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer));
    const includeSizeVariable = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.includeSizeVariable) ? options.includeSizeVariable : false;
    return modules.PieChartCreator.createRenderer({
        layer,
        view: mapView,
        attributes: getChartAttributes(options.fieldInfos),
        pieChartScheme: options.pieChartScheme || (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.Z)(),
        includeSizeVariable,
        outlineOptimizationEnabled: (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.outlineOptimizationEnabled)
            ? options.outlineOptimizationEnabled
            : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer) && includeSizeVariable
                ? true
                : false,
        sizeOptimizationEnabled: (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled) ? options.sizeOptimizationEnabled : true,
        legendOptions: options.legendOptions,
        forBinning: ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
    }).then((result) => {
        //console.log("createChartRenderer result", result.renderer.toJSON());
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer, { notOpacity: true });
        const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
        if (["chart", "chart-size"].indexOf(rendererType) > -1) {
            // current renderer was chart too
            const rendererFields = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.f)(layer);
            const selNames = selectedFields.map((selField) => selField.field);
            const renNames = rendererFields.map((renField) => renField.field);
            const sameFields = selNames.toString() === renNames.toString();
            const selNamesSorted = modules.esriLang.clone(selNames);
            const renNamesSorted = modules.esriLang.clone(renNames);
            selNamesSorted.sort();
            renNamesSorted.sort();
            const sameFieldsSorted = selNamesSorted.toString() === renNamesSorted.toString();
            if (sameFieldsSorted) {
                // keep colors and labels
                result.renderer.attributes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).attributes;
                if (!sameFields) {
                    // order of fields is not the same, re-order
                    result.renderer.attributes.sort((a, b) => {
                        return selNames.indexOf(a.field) - selNames.indexOf(b.field);
                    });
                }
                result.renderer.othersCategory = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).othersCategory;
                // keep donut
                result.renderer.holePercentage = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).holePercentage;
            }
        }
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
/**
 * Creates a Chart renderer with settings from current renderer
 * @param options: only contains properties that need to be overwritten
 */
function createChartRendererFromExisting(options) {
    var _a, _b;
    const { layer: smLayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size");
    const authSizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)(renderer, "size");
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)(renderer);
    let fieldInfos = options.fieldInfos
        ? options.fieldInfos
        : renderer.attributes.map((attribute) => {
            return {
                field: attribute.field,
                simpleFieldType: _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.NUMBER
            };
        });
    let isSameFields = true;
    let lastFieldsOrder;
    if (options.fieldInfos) {
        // compare
        renderer.attributes.forEach((attribute, idx) => {
            if (attribute.field !== options.fieldInfos[idx].field) {
                isSameFields = false;
            }
        });
        if (isSameFields) {
            // no changes to fields
            delete options.fieldInfos;
            if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.R)(options)) {
                // nothing really changes
                const newRender = renderer.clone();
                return Promise.resolve({ renderer: newRender });
            }
        }
    }
    if (isSameFields) {
        // keep the order of fields
        lastFieldsOrder = renderer.attributes.map((attribute) => attribute.field);
    }
    const pcRenderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const color = ((_a = pcRenderer.attributes) === null || _a === void 0 ? void 0 : _a.length) ? pcRenderer.attributes[0].color : null;
    const backgroundFillSymbol = renderer.backgroundFillSymbol;
    let isInverted = false;
    if (sizeVisVar) {
        if (sizeVisVar.minSize.stops) {
            isInverted = sizeVisVar.minSize.stops[0].size > sizeVisVar.maxSize.stops[0].size;
        }
        else {
            isInverted = sizeVisVar.minSize > sizeVisVar.maxSize;
        }
    }
    const temp = fieldInfos[0];
    fieldInfos[0] = fieldInfos[1];
    fieldInfos[1] = temp;
    return modules.PieChartCreator.createRenderer({
        layer,
        view: mapView,
        attributes: getChartAttributes(fieldInfos),
        pieChartScheme: options.pieChartScheme || (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.Z)(),
        includeSizeVariable: (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.includeSizeVariable) ? options.includeSizeVariable : !!sizeVisVar,
        outlineOptimizationEnabled: (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.outlineOptimizationEnabled)
            ? options.outlineOptimizationEnabled
            : !!extras.sizeOutlineVisVar,
        sizeOptimizationEnabled: (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled)
            ? options.sizeOptimizationEnabled
            : !!extras.sizeAutoVisVar,
        legendOptions: undefined,
        forBinning: ((_b = layer.featureReduction) === null || _b === void 0 ? void 0 : _b.type) === "binning"
    }).then((result) => {
        //console.log("createRenderer", result);
        var _a;
        // keep slider values
        if (!options.fieldInfos && sizeVisVar) {
            const newSizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "size");
            newSizeVisVar.minDataValue = sizeVisVar.minDataValue;
            newSizeVisVar.maxDataValue = sizeVisVar.maxDataValue;
            if (authSizeVisVar) {
                const newAuthSizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)(result.renderer, "size");
                newAuthSizeVisVar.minSliderValue = authSizeVisVar.minSliderValue;
                newAuthSizeVisVar.maxSliderValue = authSizeVisVar.maxSliderValue;
            }
        }
        if (isSameFields && extras.opacityVisVar && extras.authOpacityVisVar) {
            // keep the one we had
            result.renderer.visualVariables = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.n)(result.renderer, "opacity");
            result.renderer.authoringInfo.visualVariables = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.o)(result.renderer, "opacity");
            result.renderer.visualVariables.push(extras.opacityVisVar);
            result.renderer.authoringInfo.visualVariables = result.renderer.authoringInfo.visualVariables || [];
            result.renderer.authoringInfo.visualVariables.push(extras.authOpacityVisVar);
        }
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer, { notOpacity: true });
        if (lastFieldsOrder) {
            // keep order of fields
            result.renderer.attributes.sort((attributeA, attributeB) => {
                const indexA = lastFieldsOrder.indexOf(attributeA.field);
                const indexB = lastFieldsOrder.indexOf(attributeB.field);
                return indexA > -1 && indexB > -1 && indexA < indexB
                    ? -1
                    : indexA > -1 && indexB > -1 && indexA > indexB
                        ? 1
                        : indexA > -1
                            ? -1
                            : indexB > -1
                                ? 1
                                : 0;
            });
        }
        if (isSameFields) {
            // keep labels
            result.renderer.attributes.forEach((attribute, idx) => {
                attribute.label = renderer.attributes[idx].label;
            });
        }
        // holePercentage, size, othersCategory
        result.renderer.size = renderer.size;
        result.renderer.holePercentage = renderer.holePercentage;
        result.renderer.othersCategory = renderer.othersCategory;
        if (color && ((_a = result.renderer.attributes) === null || _a === void 0 ? void 0 : _a.length)) {
            result.renderer.attributes.map((attribute, idx) => {
                if (isSameFields) {
                    // keep the color from previous renderer
                    attribute.color = renderer.attributes[idx].color;
                }
            });
        }
        if (backgroundFillSymbol) {
            result.renderer.backgroundFillSymbol = backgroundFillSymbol;
        }
        if (isInverted) {
            const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "size");
            const tmp = sizeVisVar.minSize;
            sizeVisVar.minSize = sizeVisVar.maxSize;
            sizeVisVar.maxSize = tmp;
        }
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
function getChartAttributes(fieldInfos) {
    return fieldInfos.map((fieldInfo) => {
        return {
            field: fieldInfo.field,
            label: getFieldLabel(fieldInfo.field)
        };
    });
}
function getFieldLabel(fieldName) {
    const galleryFields = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s.fields.filter((field) => field.layerField.name === fieldName);
    if (galleryFields.length) {
        return galleryFields[0].label;
    }
    return "";
}



//# sourceMappingURL=chart-097ec280.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fY2hhcnQtLTliODg3Zi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NXO0FBQ25VO0FBQzRCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFtRCxFQUFFLCtEQUFpQjtBQUNsRjtBQUNBO0FBQ0EsbUJBQW1CLG1FQUFnQixDQUFDLG1FQUFXO0FBQy9DLGdDQUFnQywrREFBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtRUFBa0I7QUFDcEU7QUFDQSxvQ0FBb0MsK0RBQVM7QUFDN0M7QUFDQSxjQUFjLG1FQUFhO0FBQzNCO0FBQ0E7QUFDQSxpQ0FBaUMsK0RBQVM7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFFBQVEsbUVBQWlCLDRCQUE0QixrQkFBa0I7QUFDdkUsNkJBQTZCLG1FQUFlO0FBQzVDO0FBQ0E7QUFDQSxtQ0FBbUMsbUVBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1FQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaURBQWlELG1FQUFXO0FBQzVEO0FBQ0EsaURBQWlELG1FQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DLEVBQUUsK0RBQWlCO0FBQ2xFO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQVc7QUFDaEMsdUJBQXVCLG1FQUFTO0FBQ2hDLDJCQUEyQixtRUFBYTtBQUN4QyxtQkFBbUIsbUVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0RBQWdCO0FBQ2pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1FQUFPO0FBQ3ZCO0FBQ0E7QUFDQSx5Q0FBeUMscUJBQXFCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1FQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtRUFBa0I7QUFDcEUsNkJBQTZCLCtEQUFTO0FBQ3RDLG9DQUFvQywrREFBUztBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLCtEQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1FQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtRUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUVBQWdCO0FBQzlELDREQUE0RCxtRUFBb0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFpQiw0QkFBNEIsa0JBQWtCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUVBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLCtEQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwRTs7QUFFMUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9jaGFydC0wOTdlYzI4MC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGggYXMgZ2V0UmVuZGVyZXIsIGEgYXMgZ2V0VmlzVmFyLCBwIGFzIGdldEF1dGhWaXNWYXIsIG0gYXMgc2F2ZUV4dHJhVmlzVmFycywgdyBhcyBzaW1wbGVGaWVsZFR5cGVzLCBSIGFzIGlzRW1wdHksIFogYXMgZmluZFBpZUNoYXJ0U2NoZW1lLCBuIGFzIGdldFZpc1ZhcnNFeGNlcHQsIG8gYXMgZ2V0QXV0aFZpc1ZhcnNFeGNlcHQsIGwgYXMgYXBwbHlFeHRyYVZpc1ZhcnMsIHMgYXMgc21hcnRNYXBwaW5nU3RhdGUsIHEgYXMgaXNQb2x5Z29uVHlwZSwgZyBhcyBnZXRSZW5kZXJlclR5cGUsIGYgYXMgZ2V0UmVuZGVyZXJGaWVsZEluZm9zIH0gZnJvbSAnLi9yYXN0ZXItdW5pcXVlLXZhbHVlLTA5NzZlYzdmLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzRGVmaW5lZCB9IGZyb20gJy4vY29tbW9uRnVuY3Rpb25zLWIwODMwZTllLmpzJztcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBsYXllciB3aXRoIGEgQ2hhcnQgcmVuZGVyZXIgd2l0aCBkZWZhdWx0IHNldHRpbmdzXG4gKiBAcGFyYW0gb3B0aW9uczogb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFydFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwVmlldywgc2VsZWN0ZWRGaWVsZHMsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBleHRyYXMgPSBzYXZlRXh0cmFWaXNWYXJzKGdldFJlbmRlcmVyKGxheWVyKSk7XG4gICAgY29uc3QgaW5jbHVkZVNpemVWYXJpYWJsZSA9IGlzRGVmaW5lZChvcHRpb25zLmluY2x1ZGVTaXplVmFyaWFibGUpID8gb3B0aW9ucy5pbmNsdWRlU2l6ZVZhcmlhYmxlIDogZmFsc2U7XG4gICAgcmV0dXJuIG1vZHVsZXMuUGllQ2hhcnRDcmVhdG9yLmNyZWF0ZVJlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXc6IG1hcFZpZXcsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGdldENoYXJ0QXR0cmlidXRlcyhvcHRpb25zLmZpZWxkSW5mb3MpLFxuICAgICAgICBwaWVDaGFydFNjaGVtZTogb3B0aW9ucy5waWVDaGFydFNjaGVtZSB8fCBmaW5kUGllQ2hhcnRTY2hlbWUoKSxcbiAgICAgICAgaW5jbHVkZVNpemVWYXJpYWJsZSxcbiAgICAgICAgb3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWQ6IGlzRGVmaW5lZChvcHRpb25zLm91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkKVxuICAgICAgICAgICAgPyBvcHRpb25zLm91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkXG4gICAgICAgICAgICA6IGlzUG9seWdvblR5cGUobGF5ZXIpICYmIGluY2x1ZGVTaXplVmFyaWFibGVcbiAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBzaXplT3B0aW1pemF0aW9uRW5hYmxlZDogaXNEZWZpbmVkKG9wdGlvbnMuc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQpID8gb3B0aW9ucy5zaXplT3B0aW1pemF0aW9uRW5hYmxlZCA6IHRydWUsXG4gICAgICAgIGxlZ2VuZE9wdGlvbnM6IG9wdGlvbnMubGVnZW5kT3B0aW9ucyxcbiAgICAgICAgZm9yQmlubmluZzogKChfYSA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJiaW5uaW5nXCJcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNyZWF0ZUNoYXJ0UmVuZGVyZXIgcmVzdWx0XCIsIHJlc3VsdC5yZW5kZXJlci50b0pTT04oKSk7XG4gICAgICAgIGFwcGx5RXh0cmFWaXNWYXJzKGV4dHJhcywgcmVzdWx0LnJlbmRlcmVyLCB7IG5vdE9wYWNpdHk6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IGdldFJlbmRlcmVyVHlwZSgpO1xuICAgICAgICBpZiAoW1wiY2hhcnRcIiwgXCJjaGFydC1zaXplXCJdLmluZGV4T2YocmVuZGVyZXJUeXBlKSA+IC0xKSB7XG4gICAgICAgICAgICAvLyBjdXJyZW50IHJlbmRlcmVyIHdhcyBjaGFydCB0b29cbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyRmllbGRzID0gZ2V0UmVuZGVyZXJGaWVsZEluZm9zKGxheWVyKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbE5hbWVzID0gc2VsZWN0ZWRGaWVsZHMubWFwKChzZWxGaWVsZCkgPT4gc2VsRmllbGQuZmllbGQpO1xuICAgICAgICAgICAgY29uc3QgcmVuTmFtZXMgPSByZW5kZXJlckZpZWxkcy5tYXAoKHJlbkZpZWxkKSA9PiByZW5GaWVsZC5maWVsZCk7XG4gICAgICAgICAgICBjb25zdCBzYW1lRmllbGRzID0gc2VsTmFtZXMudG9TdHJpbmcoKSA9PT0gcmVuTmFtZXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbE5hbWVzU29ydGVkID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzZWxOYW1lcyk7XG4gICAgICAgICAgICBjb25zdCByZW5OYW1lc1NvcnRlZCA9IG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUocmVuTmFtZXMpO1xuICAgICAgICAgICAgc2VsTmFtZXNTb3J0ZWQuc29ydCgpO1xuICAgICAgICAgICAgcmVuTmFtZXNTb3J0ZWQuc29ydCgpO1xuICAgICAgICAgICAgY29uc3Qgc2FtZUZpZWxkc1NvcnRlZCA9IHNlbE5hbWVzU29ydGVkLnRvU3RyaW5nKCkgPT09IHJlbk5hbWVzU29ydGVkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoc2FtZUZpZWxkc1NvcnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgY29sb3JzIGFuZCBsYWJlbHNcbiAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuYXR0cmlidXRlcyA9IGdldFJlbmRlcmVyKGxheWVyKS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIGlmICghc2FtZUZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBvcmRlciBvZiBmaWVsZHMgaXMgbm90IHRoZSBzYW1lLCByZS1vcmRlclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuYXR0cmlidXRlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsTmFtZXMuaW5kZXhPZihhLmZpZWxkKSAtIHNlbE5hbWVzLmluZGV4T2YoYi5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIub3RoZXJzQ2F0ZWdvcnkgPSBnZXRSZW5kZXJlcihsYXllcikub3RoZXJzQ2F0ZWdvcnk7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBkb251dFxuICAgICAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5ob2xlUGVyY2VudGFnZSA9IGdldFJlbmRlcmVyKGxheWVyKS5ob2xlUGVyY2VudGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgQ2hhcnQgcmVuZGVyZXIgd2l0aCBzZXR0aW5ncyBmcm9tIGN1cnJlbnQgcmVuZGVyZXJcbiAqIEBwYXJhbSBvcHRpb25zOiBvbmx5IGNvbnRhaW5zIHByb3BlcnRpZXMgdGhhdCBuZWVkIHRvIGJlIG92ZXJ3cml0dGVuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYXJ0UmVuZGVyZXJGcm9tRXhpc3Rpbmcob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IHNpemVWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICBjb25zdCBhdXRoU2l6ZVZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICBjb25zdCBleHRyYXMgPSBzYXZlRXh0cmFWaXNWYXJzKHJlbmRlcmVyKTtcbiAgICBsZXQgZmllbGRJbmZvcyA9IG9wdGlvbnMuZmllbGRJbmZvc1xuICAgICAgICA/IG9wdGlvbnMuZmllbGRJbmZvc1xuICAgICAgICA6IHJlbmRlcmVyLmF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IGF0dHJpYnV0ZS5maWVsZCxcbiAgICAgICAgICAgICAgICBzaW1wbGVGaWVsZFR5cGU6IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICBsZXQgaXNTYW1lRmllbGRzID0gdHJ1ZTtcbiAgICBsZXQgbGFzdEZpZWxkc09yZGVyO1xuICAgIGlmIChvcHRpb25zLmZpZWxkSW5mb3MpIHtcbiAgICAgICAgLy8gY29tcGFyZVxuICAgICAgICByZW5kZXJlci5hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLmZpZWxkICE9PSBvcHRpb25zLmZpZWxkSW5mb3NbaWR4XS5maWVsZCkge1xuICAgICAgICAgICAgICAgIGlzU2FtZUZpZWxkcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzU2FtZUZpZWxkcykge1xuICAgICAgICAgICAgLy8gbm8gY2hhbmdlcyB0byBmaWVsZHNcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmZpZWxkSW5mb3M7XG4gICAgICAgICAgICBpZiAoaXNFbXB0eShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgcmVhbGx5IGNoYW5nZXNcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdSZW5kZXIgPSByZW5kZXJlci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyByZW5kZXJlcjogbmV3UmVuZGVyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1NhbWVGaWVsZHMpIHtcbiAgICAgICAgLy8ga2VlcCB0aGUgb3JkZXIgb2YgZmllbGRzXG4gICAgICAgIGxhc3RGaWVsZHNPcmRlciA9IHJlbmRlcmVyLmF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS5maWVsZCk7XG4gICAgfVxuICAgIGNvbnN0IHBjUmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3QgY29sb3IgPSAoKF9hID0gcGNSZW5kZXJlci5hdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA/IHBjUmVuZGVyZXIuYXR0cmlidXRlc1swXS5jb2xvciA6IG51bGw7XG4gICAgY29uc3QgYmFja2dyb3VuZEZpbGxTeW1ib2wgPSByZW5kZXJlci5iYWNrZ3JvdW5kRmlsbFN5bWJvbDtcbiAgICBsZXQgaXNJbnZlcnRlZCA9IGZhbHNlO1xuICAgIGlmIChzaXplVmlzVmFyKSB7XG4gICAgICAgIGlmIChzaXplVmlzVmFyLm1pblNpemUuc3RvcHMpIHtcbiAgICAgICAgICAgIGlzSW52ZXJ0ZWQgPSBzaXplVmlzVmFyLm1pblNpemUuc3RvcHNbMF0uc2l6ZSA+IHNpemVWaXNWYXIubWF4U2l6ZS5zdG9wc1swXS5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXNJbnZlcnRlZCA9IHNpemVWaXNWYXIubWluU2l6ZSA+IHNpemVWaXNWYXIubWF4U2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wID0gZmllbGRJbmZvc1swXTtcbiAgICBmaWVsZEluZm9zWzBdID0gZmllbGRJbmZvc1sxXTtcbiAgICBmaWVsZEluZm9zWzFdID0gdGVtcDtcbiAgICByZXR1cm4gbW9kdWxlcy5QaWVDaGFydENyZWF0b3IuY3JlYXRlUmVuZGVyZXIoe1xuICAgICAgICBsYXllcixcbiAgICAgICAgdmlldzogbWFwVmlldyxcbiAgICAgICAgYXR0cmlidXRlczogZ2V0Q2hhcnRBdHRyaWJ1dGVzKGZpZWxkSW5mb3MpLFxuICAgICAgICBwaWVDaGFydFNjaGVtZTogb3B0aW9ucy5waWVDaGFydFNjaGVtZSB8fCBmaW5kUGllQ2hhcnRTY2hlbWUoKSxcbiAgICAgICAgaW5jbHVkZVNpemVWYXJpYWJsZTogaXNEZWZpbmVkKG9wdGlvbnMuaW5jbHVkZVNpemVWYXJpYWJsZSkgPyBvcHRpb25zLmluY2x1ZGVTaXplVmFyaWFibGUgOiAhIXNpemVWaXNWYXIsXG4gICAgICAgIG91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkOiBpc0RlZmluZWQob3B0aW9ucy5vdXRsaW5lT3B0aW1pemF0aW9uRW5hYmxlZClcbiAgICAgICAgICAgID8gb3B0aW9ucy5vdXRsaW5lT3B0aW1pemF0aW9uRW5hYmxlZFxuICAgICAgICAgICAgOiAhIWV4dHJhcy5zaXplT3V0bGluZVZpc1ZhcixcbiAgICAgICAgc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQ6IGlzRGVmaW5lZChvcHRpb25zLnNpemVPcHRpbWl6YXRpb25FbmFibGVkKVxuICAgICAgICAgICAgPyBvcHRpb25zLnNpemVPcHRpbWl6YXRpb25FbmFibGVkXG4gICAgICAgICAgICA6ICEhZXh0cmFzLnNpemVBdXRvVmlzVmFyLFxuICAgICAgICBsZWdlbmRPcHRpb25zOiB1bmRlZmluZWQsXG4gICAgICAgIGZvckJpbm5pbmc6ICgoX2IgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHlwZSkgPT09IFwiYmlubmluZ1wiXG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJjcmVhdGVSZW5kZXJlclwiLCByZXN1bHQpO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGtlZXAgc2xpZGVyIHZhbHVlc1xuICAgICAgICBpZiAoIW9wdGlvbnMuZmllbGRJbmZvcyAmJiBzaXplVmlzVmFyKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTaXplVmlzVmFyID0gZ2V0VmlzVmFyKHJlc3VsdC5yZW5kZXJlciwgXCJzaXplXCIpO1xuICAgICAgICAgICAgbmV3U2l6ZVZpc1Zhci5taW5EYXRhVmFsdWUgPSBzaXplVmlzVmFyLm1pbkRhdGFWYWx1ZTtcbiAgICAgICAgICAgIG5ld1NpemVWaXNWYXIubWF4RGF0YVZhbHVlID0gc2l6ZVZpc1Zhci5tYXhEYXRhVmFsdWU7XG4gICAgICAgICAgICBpZiAoYXV0aFNpemVWaXNWYXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdBdXRoU2l6ZVZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVzdWx0LnJlbmRlcmVyLCBcInNpemVcIik7XG4gICAgICAgICAgICAgICAgbmV3QXV0aFNpemVWaXNWYXIubWluU2xpZGVyVmFsdWUgPSBhdXRoU2l6ZVZpc1Zhci5taW5TbGlkZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICBuZXdBdXRoU2l6ZVZpc1Zhci5tYXhTbGlkZXJWYWx1ZSA9IGF1dGhTaXplVmlzVmFyLm1heFNsaWRlclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NhbWVGaWVsZHMgJiYgZXh0cmFzLm9wYWNpdHlWaXNWYXIgJiYgZXh0cmFzLmF1dGhPcGFjaXR5VmlzVmFyKSB7XG4gICAgICAgICAgICAvLyBrZWVwIHRoZSBvbmUgd2UgaGFkXG4gICAgICAgICAgICByZXN1bHQucmVuZGVyZXIudmlzdWFsVmFyaWFibGVzID0gZ2V0VmlzVmFyc0V4Y2VwdChyZXN1bHQucmVuZGVyZXIsIFwib3BhY2l0eVwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5hdXRob3JpbmdJbmZvLnZpc3VhbFZhcmlhYmxlcyA9IGdldEF1dGhWaXNWYXJzRXhjZXB0KHJlc3VsdC5yZW5kZXJlciwgXCJvcGFjaXR5XCIpO1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcy5wdXNoKGV4dHJhcy5vcGFjaXR5VmlzVmFyKTtcbiAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5hdXRob3JpbmdJbmZvLnZpc3VhbFZhcmlhYmxlcyA9IHJlc3VsdC5yZW5kZXJlci5hdXRob3JpbmdJbmZvLnZpc3VhbFZhcmlhYmxlcyB8fCBbXTtcbiAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5hdXRob3JpbmdJbmZvLnZpc3VhbFZhcmlhYmxlcy5wdXNoKGV4dHJhcy5hdXRoT3BhY2l0eVZpc1Zhcik7XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlFeHRyYVZpc1ZhcnMoZXh0cmFzLCByZXN1bHQucmVuZGVyZXIsIHsgbm90T3BhY2l0eTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGxhc3RGaWVsZHNPcmRlcikge1xuICAgICAgICAgICAgLy8ga2VlcCBvcmRlciBvZiBmaWVsZHNcbiAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5hdHRyaWJ1dGVzLnNvcnQoKGF0dHJpYnV0ZUEsIGF0dHJpYnV0ZUIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEEgPSBsYXN0RmllbGRzT3JkZXIuaW5kZXhPZihhdHRyaWJ1dGVBLmZpZWxkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEIgPSBsYXN0RmllbGRzT3JkZXIuaW5kZXhPZihhdHRyaWJ1dGVCLmZpZWxkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhBID4gLTEgJiYgaW5kZXhCID4gLTEgJiYgaW5kZXhBIDwgaW5kZXhCXG4gICAgICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICAgICAgOiBpbmRleEEgPiAtMSAmJiBpbmRleEIgPiAtMSAmJiBpbmRleEEgPiBpbmRleEJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbmRleEEgPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGluZGV4QiA+IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTYW1lRmllbGRzKSB7XG4gICAgICAgICAgICAvLyBrZWVwIGxhYmVsc1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cmlidXRlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubGFiZWwgPSByZW5kZXJlci5hdHRyaWJ1dGVzW2lkeF0ubGFiZWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBob2xlUGVyY2VudGFnZSwgc2l6ZSwgb3RoZXJzQ2F0ZWdvcnlcbiAgICAgICAgcmVzdWx0LnJlbmRlcmVyLnNpemUgPSByZW5kZXJlci5zaXplO1xuICAgICAgICByZXN1bHQucmVuZGVyZXIuaG9sZVBlcmNlbnRhZ2UgPSByZW5kZXJlci5ob2xlUGVyY2VudGFnZTtcbiAgICAgICAgcmVzdWx0LnJlbmRlcmVyLm90aGVyc0NhdGVnb3J5ID0gcmVuZGVyZXIub3RoZXJzQ2F0ZWdvcnk7XG4gICAgICAgIGlmIChjb2xvciAmJiAoKF9hID0gcmVzdWx0LnJlbmRlcmVyLmF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuYXR0cmlidXRlcy5tYXAoKGF0dHJpYnV0ZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2FtZUZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIHRoZSBjb2xvciBmcm9tIHByZXZpb3VzIHJlbmRlcmVyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5jb2xvciA9IHJlbmRlcmVyLmF0dHJpYnV0ZXNbaWR4XS5jb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFja2dyb3VuZEZpbGxTeW1ib2wpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5iYWNrZ3JvdW5kRmlsbFN5bWJvbCA9IGJhY2tncm91bmRGaWxsU3ltYm9sO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ludmVydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplVmlzVmFyID0gZ2V0VmlzVmFyKHJlc3VsdC5yZW5kZXJlciwgXCJzaXplXCIpO1xuICAgICAgICAgICAgY29uc3QgdG1wID0gc2l6ZVZpc1Zhci5taW5TaXplO1xuICAgICAgICAgICAgc2l6ZVZpc1Zhci5taW5TaXplID0gc2l6ZVZpc1Zhci5tYXhTaXplO1xuICAgICAgICAgICAgc2l6ZVZpc1Zhci5tYXhTaXplID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG5mdW5jdGlvbiBnZXRDaGFydEF0dHJpYnV0ZXMoZmllbGRJbmZvcykge1xuICAgIHJldHVybiBmaWVsZEluZm9zLm1hcCgoZmllbGRJbmZvKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRJbmZvLmZpZWxkLFxuICAgICAgICAgICAgbGFiZWw6IGdldEZpZWxkTGFiZWwoZmllbGRJbmZvLmZpZWxkKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RmllbGRMYWJlbChmaWVsZE5hbWUpIHtcbiAgICBjb25zdCBnYWxsZXJ5RmllbGRzID0gc21hcnRNYXBwaW5nU3RhdGUuZmllbGRzLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lKTtcbiAgICBpZiAoZ2FsbGVyeUZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGdhbGxlcnlGaWVsZHNbMF0ubGFiZWw7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xufVxuXG5leHBvcnQgeyBjcmVhdGVDaGFydFJlbmRlcmVyRnJvbUV4aXN0aW5nIGFzIGEsIGNyZWF0ZUNoYXJ0UmVuZGVyZXIgYXMgYyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFydC0wOTdlYzI4MC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=