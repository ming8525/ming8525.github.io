"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-categor-c041ab"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-category-tree.entry.js":
/*!***********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-category-tree.entry.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_category_tree: () => (/* binding */ ArcgisCategoryTree)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./categories-ca134005.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const arcgisCategoryTreeCss = ".category-container{background-color:var(--calcite-color-foreground-1);width:-moz-fit-content;width:fit-content;padding:1rem}.category-row{list-style-type:none}.category-row:not(:last-child){margin-bottom:0.25rem}.subcategory-container{list-style-type:none;padding-inline-start:1rem;padding-top:0.5rem;margin-top:0px;margin-bottom:0px;margin-inline-start:0.375rem;border-left:1px solid var(--calcite-color-border-2)}.subcategory-container--root{margin-left:0px;margin-right:0px;padding-left:0px;padding-right:0px;padding-top:0px;border-width:0px}.category{display:flex;align-items:center;--calcite-label-margin-bottom:0}";

const ArcgisCategoryTree = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisCategorizeCategorySelected = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisCategorizeCategorySelected", 7);
        this.renderCategory = (category, parentPath) => {
            const { categorySelectionState, rootCategoryPath } = this;
            const { title, categories } = category;
            const isRoot = parentPath === rootCategoryPath;
            const fullPath = (0,_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_1__.a)(parentPath, category, false);
            const selectionState = categorySelectionState[fullPath] || "none";
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("li", { class: "category-row", key: fullPath }, !isRoot && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { class: "category", layout: "inline" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { checked: selectionState !== "none", indeterminate: selectionState === "some", scale: "m", onCalciteCheckboxChange: () => this.arcgisCategorizeCategorySelected.emit(selectionState === "none"
                    ? { paths: [fullPath], selected: true }
                    : {
                        // This means we'll deselect the current path and also the children paths
                        paths: Object.keys(categorySelectionState).filter((path) => path.startsWith(fullPath)),
                        selected: false
                    }) }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { value: title }, title))), (categories === null || categories === void 0 ? void 0 : categories.length) > 0 && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("ul", { class: {
                    "subcategory-container": true,
                    "subcategory-container--root": isRoot
                } }, categories.map((curCategory) => this.renderCategory(curCategory, fullPath))))));
        };
        this.categorySchema = undefined;
        this.categorySelectionCountMap = undefined;
        this.total = undefined;
        this.rootCategoryPath = _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_1__.U;
        this.categorySelectionState = {};
    }
    handleCountMapChange() {
        const { categorySelectionCountMap } = this;
        const categorySelectionState = {};
        Object.keys(categorySelectionCountMap)
            .filter((path) => categorySelectionCountMap[path].length)
            .forEach((path) => {
            var _a;
            const numSelected = ((_a = categorySelectionCountMap[path]) === null || _a === void 0 ? void 0 : _a.length) || 0;
            const newSelectionState = !numSelected
                ? "none"
                : numSelected === this.total
                    ? "all"
                    : "some";
            categorySelectionState[path] = newSelectionState;
            // Also traverse up the path and set the parent to "some" if any of the children are selected
            let curPath = "";
            path
                // Split by part will leave the first element as an empty string, so filter it out
                .split("/")
                .filter(Boolean)
                .forEach((part) => {
                curPath = `${curPath}/${part}`;
                if (newSelectionState === "none") {
                    return;
                }
                const curState = categorySelectionState[curPath];
                categorySelectionState[curPath] = curState === "all" ? "all" : newSelectionState;
            });
        });
        this.categorySelectionState = categorySelectionState;
    }
    componentWillLoad() {
        this.handleCountMapChange();
    }
    render() {
        const { renderCategory, categorySchema, rootCategoryPath } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "category-container", slot: "filters" }, renderCategory({ title: "", categories: categorySchema }, rootCategoryPath)));
    }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "categorySelectionCountMap": ["handleCountMapChange"]
    }; }
};
ArcgisCategoryTree.style = arcgisCategoryTreeCss;



//# sourceMappingURL=arcgis-category-tree.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CATEGORY_BASE_PATH),
/* harmony export */   U: () => (/* binding */ UPPER_CATEGORY_BASE_PATH),
/* harmony export */   a: () => (/* binding */ getCategoryUIPath),
/* harmony export */   g: () => (/* binding */ getRootCategoryPath)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
const CATEGORY_BASE_PATH = "/categories";
const UPPER_CATEGORY_BASE_PATH = "/Categories";

// TODO: add unit tests
/**
 * Construct the path of the category based on the parent path and the category title
 */
const getCategoryUIPath = (parentPath, category, lowerCase = true) => {
    const basePath = parentPath !== null && parentPath !== void 0 ? parentPath : "";
    return `${basePath}${basePath.endsWith("/") ? "" : "/"}${lowerCase ? category.title.toLocaleLowerCase() : category.title}`;
};
/**
 * Find the root node title to use for categories
 */
function getRootCategoryPath(categories) {
    var _a;
    let categoryTitle = (_a = categories === null || categories === void 0 ? void 0 : categories[0]) === null || _a === void 0 ? void 0 : _a.title;
    if (categoryTitle && categoryTitle.charAt(0) !== "/") {
        categoryTitle = `/${categoryTitle}`;
    }
    return categoryTitle || UPPER_CATEGORY_BASE_PATH;
}



//# sourceMappingURL=categories-ca134005.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWNhdGVnb3ItYzA0MWFiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tHO0FBQ0Q7O0FBRWpHLG1EQUFtRCxtREFBbUQsdUJBQXVCLGtCQUFrQixhQUFhLGNBQWMscUJBQXFCLCtCQUErQixzQkFBc0IsdUJBQXVCLHFCQUFxQiwwQkFBMEIsbUJBQW1CLGVBQWUsa0JBQWtCLDZCQUE2QixvREFBb0QsNkJBQTZCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGtCQUFrQixnQkFBZ0IsaUJBQWlCLFVBQVUsYUFBYSxtQkFBbUIsZ0NBQWdDOztBQUUzb0I7QUFDQTtBQUNBLFFBQVEscURBQWdCO0FBQ3hCLGdEQUFnRCxxREFBVztBQUMzRDtBQUNBLG9CQUFvQiwyQ0FBMkM7QUFDL0Qsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBLDZCQUE2QiwwREFBaUI7QUFDOUM7QUFDQSxvQkFBb0IscURBQUMsU0FBUyxzQ0FBc0MsY0FBYyxxREFBQyxvQkFBb0IscUNBQXFDLEVBQUUscURBQUMsdUJBQXVCO0FBQ3RLLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixHQUFHLEdBQUcscURBQUMsbUJBQW1CLGNBQWMsZ0dBQWdHLHFEQUFDLFNBQVM7QUFDdks7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRLEdBQUcsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQW1EO0FBQ25FLGdCQUFnQixxREFBQyxVQUFVLDhDQUE4QyxtQkFBbUIsdUNBQXVDO0FBQ25JO0FBQ0EsZUFBZSxPQUFPLHFEQUFVO0FBQ2hDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFc0Q7O0FBRXREOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLEVBQUUsa0NBQWtDLEVBQUUsZ0VBQWdFO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7O0FBRW9IOztBQUVwSCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1jYXRlZ29yeS10cmVlLmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2NhdGVnb3JpZXMtY2ExMzQwMDUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRDYXRlZ29yeVVJUGF0aCwgVSBhcyBVUFBFUl9DQVRFR09SWV9CQVNFX1BBVEggfSBmcm9tICcuL2NhdGVnb3JpZXMtY2ExMzQwMDUuanMnO1xuXG5jb25zdCBhcmNnaXNDYXRlZ29yeVRyZWVDc3MgPSBcIi5jYXRlZ29yeS1jb250YWluZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLWNvbG9yLWZvcmVncm91bmQtMSk7d2lkdGg6LW1vei1maXQtY29udGVudDt3aWR0aDpmaXQtY29udGVudDtwYWRkaW5nOjFyZW19LmNhdGVnb3J5LXJvd3tsaXN0LXN0eWxlLXR5cGU6bm9uZX0uY2F0ZWdvcnktcm93Om5vdCg6bGFzdC1jaGlsZCl7bWFyZ2luLWJvdHRvbTowLjI1cmVtfS5zdWJjYXRlZ29yeS1jb250YWluZXJ7bGlzdC1zdHlsZS10eXBlOm5vbmU7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MXJlbTtwYWRkaW5nLXRvcDowLjVyZW07bWFyZ2luLXRvcDowcHg7bWFyZ2luLWJvdHRvbTowcHg7bWFyZ2luLWlubGluZS1zdGFydDowLjM3NXJlbTtib3JkZXItbGVmdDoxcHggc29saWQgdmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItMil9LnN1YmNhdGVnb3J5LWNvbnRhaW5lci0tcm9vdHttYXJnaW4tbGVmdDowcHg7bWFyZ2luLXJpZ2h0OjBweDtwYWRkaW5nLWxlZnQ6MHB4O3BhZGRpbmctcmlnaHQ6MHB4O3BhZGRpbmctdG9wOjBweDtib3JkZXItd2lkdGg6MHB4fS5jYXRlZ29yeXtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyOy0tY2FsY2l0ZS1sYWJlbC1tYXJnaW4tYm90dG9tOjB9XCI7XG5cbmNvbnN0IEFyY2dpc0NhdGVnb3J5VHJlZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzQ2F0ZWdvcml6ZUNhdGVnb3J5U2VsZWN0ZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0NhdGVnb3JpemVDYXRlZ29yeVNlbGVjdGVkXCIsIDcpO1xuICAgICAgICB0aGlzLnJlbmRlckNhdGVnb3J5ID0gKGNhdGVnb3J5LCBwYXJlbnRQYXRoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNhdGVnb3J5U2VsZWN0aW9uU3RhdGUsIHJvb3RDYXRlZ29yeVBhdGggfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHRpdGxlLCBjYXRlZ29yaWVzIH0gPSBjYXRlZ29yeTtcbiAgICAgICAgICAgIGNvbnN0IGlzUm9vdCA9IHBhcmVudFBhdGggPT09IHJvb3RDYXRlZ29yeVBhdGg7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IGdldENhdGVnb3J5VUlQYXRoKHBhcmVudFBhdGgsIGNhdGVnb3J5LCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGF0ZSA9IGNhdGVnb3J5U2VsZWN0aW9uU3RhdGVbZnVsbFBhdGhdIHx8IFwibm9uZVwiO1xuICAgICAgICAgICAgcmV0dXJuIChoKFwibGlcIiwgeyBjbGFzczogXCJjYXRlZ29yeS1yb3dcIiwga2V5OiBmdWxsUGF0aCB9LCAhaXNSb290ICYmIChoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGNsYXNzOiBcImNhdGVnb3J5XCIsIGxheW91dDogXCJpbmxpbmVcIiB9LCBoKFwiY2FsY2l0ZS1jaGVja2JveFwiLCB7IGNoZWNrZWQ6IHNlbGVjdGlvblN0YXRlICE9PSBcIm5vbmVcIiwgaW5kZXRlcm1pbmF0ZTogc2VsZWN0aW9uU3RhdGUgPT09IFwic29tZVwiLCBzY2FsZTogXCJtXCIsIG9uQ2FsY2l0ZUNoZWNrYm94Q2hhbmdlOiAoKSA9PiB0aGlzLmFyY2dpc0NhdGVnb3JpemVDYXRlZ29yeVNlbGVjdGVkLmVtaXQoc2VsZWN0aW9uU3RhdGUgPT09IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgID8geyBwYXRoczogW2Z1bGxQYXRoXSwgc2VsZWN0ZWQ6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgd2UnbGwgZGVzZWxlY3QgdGhlIGN1cnJlbnQgcGF0aCBhbmQgYWxzbyB0aGUgY2hpbGRyZW4gcGF0aHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhzOiBPYmplY3Qua2V5cyhjYXRlZ29yeVNlbGVjdGlvblN0YXRlKS5maWx0ZXIoKHBhdGgpID0+IHBhdGguc3RhcnRzV2l0aChmdWxsUGF0aCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pIH0pLCBoKFwiY2FsY2l0ZS1jaGlwXCIsIHsgdmFsdWU6IHRpdGxlIH0sIHRpdGxlKSkpLCAoY2F0ZWdvcmllcyA9PT0gbnVsbCB8fCBjYXRlZ29yaWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXRlZ29yaWVzLmxlbmd0aCkgPiAwICYmIChoKFwidWxcIiwgeyBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICBcInN1YmNhdGVnb3J5LWNvbnRhaW5lclwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInN1YmNhdGVnb3J5LWNvbnRhaW5lci0tcm9vdFwiOiBpc1Jvb3RcbiAgICAgICAgICAgICAgICB9IH0sIGNhdGVnb3JpZXMubWFwKChjdXJDYXRlZ29yeSkgPT4gdGhpcy5yZW5kZXJDYXRlZ29yeShjdXJDYXRlZ29yeSwgZnVsbFBhdGgpKSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2F0ZWdvcnlTY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnlTZWxlY3Rpb25Db3VudE1hcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50b3RhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yb290Q2F0ZWdvcnlQYXRoID0gVVBQRVJfQ0FURUdPUllfQkFTRV9QQVRIO1xuICAgICAgICB0aGlzLmNhdGVnb3J5U2VsZWN0aW9uU3RhdGUgPSB7fTtcbiAgICB9XG4gICAgaGFuZGxlQ291bnRNYXBDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IHsgY2F0ZWdvcnlTZWxlY3Rpb25Db3VudE1hcCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlTZWxlY3Rpb25TdGF0ZSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhjYXRlZ29yeVNlbGVjdGlvbkNvdW50TWFwKVxuICAgICAgICAgICAgLmZpbHRlcigocGF0aCkgPT4gY2F0ZWdvcnlTZWxlY3Rpb25Db3VudE1hcFtwYXRoXS5sZW5ndGgpXG4gICAgICAgICAgICAuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgbnVtU2VsZWN0ZWQgPSAoKF9hID0gY2F0ZWdvcnlTZWxlY3Rpb25Db3VudE1hcFtwYXRoXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvblN0YXRlID0gIW51bVNlbGVjdGVkXG4gICAgICAgICAgICAgICAgPyBcIm5vbmVcIlxuICAgICAgICAgICAgICAgIDogbnVtU2VsZWN0ZWQgPT09IHRoaXMudG90YWxcbiAgICAgICAgICAgICAgICAgICAgPyBcImFsbFwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJzb21lXCI7XG4gICAgICAgICAgICBjYXRlZ29yeVNlbGVjdGlvblN0YXRlW3BhdGhdID0gbmV3U2VsZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICAvLyBBbHNvIHRyYXZlcnNlIHVwIHRoZSBwYXRoIGFuZCBzZXQgdGhlIHBhcmVudCB0byBcInNvbWVcIiBpZiBhbnkgb2YgdGhlIGNoaWxkcmVuIGFyZSBzZWxlY3RlZFxuICAgICAgICAgICAgbGV0IGN1clBhdGggPSBcIlwiO1xuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGJ5IHBhcnQgd2lsbCBsZWF2ZSB0aGUgZmlyc3QgZWxlbWVudCBhcyBhbiBlbXB0eSBzdHJpbmcsIHNvIGZpbHRlciBpdCBvdXRcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCIvXCIpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgY3VyUGF0aCA9IGAke2N1clBhdGh9LyR7cGFydH1gO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTZWxlY3Rpb25TdGF0ZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJTdGF0ZSA9IGNhdGVnb3J5U2VsZWN0aW9uU3RhdGVbY3VyUGF0aF07XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlTZWxlY3Rpb25TdGF0ZVtjdXJQYXRoXSA9IGN1clN0YXRlID09PSBcImFsbFwiID8gXCJhbGxcIiA6IG5ld1NlbGVjdGlvblN0YXRlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhdGVnb3J5U2VsZWN0aW9uU3RhdGUgPSBjYXRlZ29yeVNlbGVjdGlvblN0YXRlO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDb3VudE1hcENoYW5nZSgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVuZGVyQ2F0ZWdvcnksIGNhdGVnb3J5U2NoZW1hLCByb290Q2F0ZWdvcnlQYXRoIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogXCJjYXRlZ29yeS1jb250YWluZXJcIiwgc2xvdDogXCJmaWx0ZXJzXCIgfSwgcmVuZGVyQ2F0ZWdvcnkoeyB0aXRsZTogXCJcIiwgY2F0ZWdvcmllczogY2F0ZWdvcnlTY2hlbWEgfSwgcm9vdENhdGVnb3J5UGF0aCkpKTtcbiAgICB9XG4gICAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICAgIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgICAgIFwiY2F0ZWdvcnlTZWxlY3Rpb25Db3VudE1hcFwiOiBbXCJoYW5kbGVDb3VudE1hcENoYW5nZVwiXVxuICAgIH07IH1cbn07XG5BcmNnaXNDYXRlZ29yeVRyZWUuc3R5bGUgPSBhcmNnaXNDYXRlZ29yeVRyZWVDc3M7XG5cbmV4cG9ydCB7IEFyY2dpc0NhdGVnb3J5VHJlZSBhcyBhcmNnaXNfY2F0ZWdvcnlfdHJlZSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtY2F0ZWdvcnktdHJlZS5lbnRyeS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmNvbnN0IENBVEVHT1JZX0JBU0VfUEFUSCA9IFwiL2NhdGVnb3JpZXNcIjtcbmNvbnN0IFVQUEVSX0NBVEVHT1JZX0JBU0VfUEFUSCA9IFwiL0NhdGVnb3JpZXNcIjtcblxuLy8gVE9ETzogYWRkIHVuaXQgdGVzdHNcbi8qKlxuICogQ29uc3RydWN0IHRoZSBwYXRoIG9mIHRoZSBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgcGFyZW50IHBhdGggYW5kIHRoZSBjYXRlZ29yeSB0aXRsZVxuICovXG5jb25zdCBnZXRDYXRlZ29yeVVJUGF0aCA9IChwYXJlbnRQYXRoLCBjYXRlZ29yeSwgbG93ZXJDYXNlID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IGJhc2VQYXRoID0gcGFyZW50UGF0aCAhPT0gbnVsbCAmJiBwYXJlbnRQYXRoICE9PSB2b2lkIDAgPyBwYXJlbnRQYXRoIDogXCJcIjtcbiAgICByZXR1cm4gYCR7YmFzZVBhdGh9JHtiYXNlUGF0aC5lbmRzV2l0aChcIi9cIikgPyBcIlwiIDogXCIvXCJ9JHtsb3dlckNhc2UgPyBjYXRlZ29yeS50aXRsZS50b0xvY2FsZUxvd2VyQ2FzZSgpIDogY2F0ZWdvcnkudGl0bGV9YDtcbn07XG4vKipcbiAqIEZpbmQgdGhlIHJvb3Qgbm9kZSB0aXRsZSB0byB1c2UgZm9yIGNhdGVnb3JpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdENhdGVnb3J5UGF0aChjYXRlZ29yaWVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBjYXRlZ29yeVRpdGxlID0gKF9hID0gY2F0ZWdvcmllcyA9PT0gbnVsbCB8fCBjYXRlZ29yaWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXRlZ29yaWVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGl0bGU7XG4gICAgaWYgKGNhdGVnb3J5VGl0bGUgJiYgY2F0ZWdvcnlUaXRsZS5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIGNhdGVnb3J5VGl0bGUgPSBgLyR7Y2F0ZWdvcnlUaXRsZX1gO1xuICAgIH1cbiAgICByZXR1cm4gY2F0ZWdvcnlUaXRsZSB8fCBVUFBFUl9DQVRFR09SWV9CQVNFX1BBVEg7XG59XG5cbmV4cG9ydCB7IENBVEVHT1JZX0JBU0VfUEFUSCBhcyBDLCBVUFBFUl9DQVRFR09SWV9CQVNFX1BBVEggYXMgVSwgZ2V0Q2F0ZWdvcnlVSVBhdGggYXMgYSwgZ2V0Um9vdENhdGVnb3J5UGF0aCBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGVnb3JpZXMtY2ExMzQwMDUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9