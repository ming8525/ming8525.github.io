"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-f0ca08"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-processing-template.entry.js":
/*!************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-processing-template.entry.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_raster_processing_template: () => (/* binding */ ArcgisRasterProcessingTemplate)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */






var ApiStatusType;
(function (ApiStatusType) {
    ApiStatusType[ApiStatusType["Idle"] = 0] = "Idle";
    ApiStatusType[ApiStatusType["Pending"] = 1] = "Pending";
    ApiStatusType[ApiStatusType["Resolved"] = 2] = "Resolved";
    ApiStatusType[ApiStatusType["Rejected"] = 3] = "Rejected";
})(ApiStatusType || (ApiStatusType = {}));

const defaultApiDataState = { status: ApiStatusType.Idle, data: null, error: null };

const addRasterFunctionNameURLParam = (baseURL, rasterFunctionName) => {
    const rasterFunctionNameURIComponent = `{"rasterFunction":"${rasterFunctionName}" }`;
    const renderingRuleURLParam = `renderingRule=${encodeURIComponent(rasterFunctionNameURIComponent)}`;
    return `${baseURL}&${renderingRuleURLParam}`;
};
function getPortalBaseUrl(portal) {
    const { customBaseUrl, portalHostname, urlKey } = portal;
    const { protocol } = window.location;
    const url = urlKey ? `${urlKey}.${customBaseUrl}` : portalHostname;
    return `${protocol}//${url}`;
}

const arcgisRasterProcessingTemplateCss = ":host{display:flex;height:100%}.beta-notice,.warning-notice{max-width:100%;text-align:center;padding:var(--arcgis-app-cap-spacing-half) var(--arcgis-app-side-spacing-half)}.raster-function-thumbnail{height:100px;width:100px;padding:0 8px}.rft-item-loader{display:inline-flex;align-items:center;justify-content:center;width:100%}.loader-text{margin:0 --arcgis-app-side-spacing}";

const ArcgisRasterProcessingTemplate = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisRasterProcessingTemplateClose = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisRasterProcessingTemplateClose", 7);
        this.originalRasterFunction = null;
        this.rasterFunctionInfos = [];
        this.dataURLRegex = /^\s*data:([a-z]+\/[a-z]+(;[a-z\-]+\=[a-z\-]+)?)?(;base64)?,[a-z0-9\!\$\&\'\,\(\)\*\+\,\;\=\-\.\_\~\:\@\/\?\%\s]*\s*$/i;
        // user click handers
        this.handleImportTemplate = () => {
            this.updateShowItemBrowser(true);
        };
        this.handleCustomRFTAdd = (item) => {
            this.fetchRFTItem(item);
        };
        this.handleDone = () => {
            this.arcgisRasterProcessingTemplateClose.emit("save");
        };
        this.handleCancel = () => {
            var _a;
            this.layer.rasterFunction = this.originalRasterFunction;
            this.activeRasterFunctionName = (_a = this.originalRasterFunction) === null || _a === void 0 ? void 0 : _a.functionName;
            this.arcgisRasterProcessingTemplateClose.emit("cancel");
        };
        // state update functions
        this.updateActiveRasterFunctionName = (updatedRasterFunctionName) => {
            this.activeRasterFunctionName = updatedRasterFunctionName;
        };
        this.updateLayerRasterFunction = (updatedRasterFunctionName) => {
            var _a, _b;
            const { layer, customRasterFunction } = this;
            let updatedLayerRasterFunction = {
                functionName: updatedRasterFunctionName
            };
            if (updatedRasterFunctionName === (customRasterFunction === null || customRasterFunction === void 0 ? void 0 : customRasterFunction.name)) {
                updatedLayerRasterFunction = customRasterFunction === null || customRasterFunction === void 0 ? void 0 : customRasterFunction.function;
            }
            if (layer.type === "imagery-tile") {
                layer.rasterFunction =
                    (updatedRasterFunctionName === null || updatedRasterFunctionName === void 0 ? void 0 : updatedRasterFunctionName.toLowerCase()) === "none" ? null : updatedLayerRasterFunction;
            }
            else {
                layer.rasterFunction = updatedLayerRasterFunction;
                if (((_a = layer === null || layer === void 0 ? void 0 : layer.mosaicRule) === null || _a === void 0 ? void 0 : _a.multidimensionalDefinition) &&
                    ((_b = layer.mosaicRule.multidimensionalDefinition[0]) === null || _b === void 0 ? void 0 : _b.variableName) !== updatedRasterFunctionName) {
                    const mdDefinition = layer.mosaicRule.multidimensionalDefinition.map((def) => {
                        def.variableName = "";
                        return def;
                    });
                    layer.mosaicRule.multidimensionalDefinition = mdDefinition;
                }
            }
            this.activeRasterFunctionName = updatedRasterFunctionName;
            layer.renderer = null;
            layer.bandIds = null;
            layer.multidimensionalSubset = null;
        };
        this.updateShowItemBrowser = (updatedShowItemBrowser) => {
            this.showRFTItemBrowser = updatedShowItemBrowser;
        };
        // async calls
        this.fetchRFTItem = async (item) => {
            this.updateRFTItemApiData({ status: ApiStatusType.Pending, data: null, error: null });
            if (!(item === null || item === void 0 ? void 0 : item.id)) {
                this.updateRFTItemApiData({
                    status: ApiStatusType.Rejected,
                    data: null,
                    error: this.strings.errorRetrievingRFTItem
                });
                return;
            }
            try {
                const portalRFTItem = new this.PortalItem({
                    id: item.id,
                    portal: this.portal
                });
                let fetchedRFTData;
                const itemName = item === null || item === void 0 ? void 0 : item.name;
                const itemFormat = itemName === null || itemName === void 0 ? void 0 : itemName.slice(-8);
                const isXMLFormat = (itemFormat === null || itemFormat === void 0 ? void 0 : itemFormat.toLowerCase()) === ".rft.xml";
                if (isXMLFormat) {
                    fetchedRFTData = await this.convertRFTFormat(item.id, "json");
                }
                else {
                    fetchedRFTData = await portalRFTItem.fetchData("json");
                }
                const rftData = this.RasterFunction.fromJSON({
                    rasterFunctionDefinition: fetchedRFTData
                });
                await this.validateRFT(rftData);
                this.updateRFTItemApiData({
                    status: ApiStatusType.Resolved,
                    data: rftData,
                    error: null
                });
                this.updateCustomRasterFunction(rftData);
            }
            catch (error) {
                this.updateRFTItemApiData({
                    status: ApiStatusType.Rejected,
                    data: null,
                    error: error.message
                });
            }
            this.updateShowItemBrowser(false);
        };
        this.validateRFT = async (rft) => {
            var _a, _b;
            try {
                const { layer, esriRequest, strings } = this;
                const rftJson = rft.toJSON();
                const validationData = layer.type === "imagery-tile"
                    ? await esriRequest(layer.url, {
                        query: {
                            f: "json",
                            renderingRule: JSON.stringify((_a = rftJson === null || rftJson === void 0 ? void 0 : rftJson.rasterFunctionDefinition) !== null && _a !== void 0 ? _a : rftJson)
                        }
                    })
                    : await layer.generateRasterInfo(rft);
                if (!validationData) {
                    throw new Error(strings.rftValidationFailed);
                }
            }
            catch (error) {
                const { strings: { rftValidationFailed, unsupportedFunction } } = this;
                const index = (_b = error.message) === null || _b === void 0 ? void 0 : _b.toLowerCase().indexOf("unsupported raster function:");
                const isUnsupportedRasterFunction = index > -1;
                let errorMessage = rftValidationFailed;
                if (isUnsupportedRasterFunction) {
                    errorMessage = `${rftValidationFailed} ${unsupportedFunction.replace("${rasterFunction}", error.message.slice(index + 28).trim())}`;
                }
                throw new Error(errorMessage);
            }
        };
        this.convertRFTFormat = async (rftItemId, format) => {
            const rasterUtilitiesServer = this.portal.helperServices.rasterUtilities;
            if (!rasterUtilitiesServer) {
                throw new Error(this.strings.rasterutilitySeverMissing);
            }
            const url = `${rasterUtilitiesServer.url}/ConvertRasterFunctionTemplate`;
            const params = {
                inputRasterFunction: JSON.stringify({ itemId: rftItemId }),
                format
            };
            const geoProcessorJob = await this.geoprocessor.submitJob(url, params);
            const geoProcessorJobWaitOptions = {
                interval: 1500
            };
            await geoProcessorJob.waitForJobCompletion(geoProcessorJobWaitOptions);
            const response = await geoProcessorJob.fetchResultData("outputRasterFunction");
            const convertedRFTUrl = response === null || response === void 0 ? void 0 : response.value;
            if (!convertedRFTUrl) {
                throw new Error(this.strings.unsupportedFunction);
            }
            const convertedRFTData = await this.esriRequest(convertedRFTUrl);
            return convertedRFTData.data;
        };
        // utilities
        this.createCustomRasterFunction = (rasterFunction) => {
            var _a;
            const { strings: { custom }, layer } = this;
            const rftJson = (_a = rasterFunction === null || rasterFunction === void 0 ? void 0 : rasterFunction.rasterFunctionDefinition) !== null && _a !== void 0 ? _a : rasterFunction;
            const { functionName } = rasterFunction;
            const { description, thumbnailEx: thumbnail, help } = rftJson;
            const customRFT = {
                name: `${custom}- ${functionName}`,
                function: rasterFunction,
                description,
                thumbnail,
                help,
                functionType: 0
            };
            if (!thumbnail && !this.dataURLRegex.test(thumbnail)) {
                const isImageryTileLayer = layer.type === "imagery-tile";
                if (isImageryTileLayer) {
                    customRFT.thumbnail = `${this.portal.staticImagesUrl}/rasterfunctiontemplate.png`;
                }
                else {
                    const exportImageBaseURL = this.getExportImageBaseURL();
                    const renderingRuleStr = `renderingRule=${encodeURIComponent(JSON.stringify(rftJson))}`; // @TODO Dev functino generalize utils.js
                    customRFT.thumbnail = `${exportImageBaseURL}&${renderingRuleStr}`;
                }
            }
            return customRFT;
        };
        this.getRasterFunctionInfos = () => {
            const { type } = this.layer;
            if (type === "imagery-tile") {
                return [
                    {
                        name: "None",
                        description: this.strings.noneRasterFunctionDescription,
                        help: "",
                        functionType: 0,
                        thumbnail: `${this.portal.staticImagesUrl}/rasterfunctiontemplate.png`
                    }
                ];
            }
            const rasterFunctionInfos = this.fixImageryRasterFunctionsThumbnail(this.layer.rasterFunctionInfos);
            return rasterFunctionInfos;
        };
        this.fixImageryRasterFunctionsThumbnail = (rasterFunctionInfos) => {
            const { dataURLRegex, layer, strings } = this;
            if (layer.type !== "imagery") {
                return rasterFunctionInfos;
            }
            const exportImageBaseURL = this.getExportImageBaseURL();
            return rasterFunctionInfos.map((rasterFunctionInfo) => {
                var _a;
                const isNoneFunction = rasterFunctionInfo.name.toLowerCase() === "none";
                const thumbnailURL = addRasterFunctionNameURLParam(exportImageBaseURL, rasterFunctionInfo.name);
                if (isNoneFunction) {
                    const noneFunctionDescription = strings.noneRasterFunctionDescription;
                    let thumbnail = thumbnailURL;
                    const bandIds = layer.bandIds;
                    if ((bandIds === null || bandIds === void 0 ? void 0 : bandIds.length) >= 3) {
                        thumbnail = `${thumbnailURL}+&bandIds=${bandIds[0]},${bandIds[1]},${bandIds[2]}`;
                    }
                    const noneFunctionThumbnail = thumbnail;
                    return Object.assign(Object.assign({}, rasterFunctionInfo), { description: noneFunctionDescription, thumbnail: noneFunctionThumbnail });
                }
                const functionDescription = (_a = rasterFunctionInfo.description) !== null && _a !== void 0 ? _a : "";
                let functionalThumbnail = rasterFunctionInfo.thumbnail;
                if (!rasterFunctionInfo.thumbnail || !dataURLRegex.test(rasterFunctionInfo.thumbnail)) {
                    functionalThumbnail = thumbnailURL;
                }
                return Object.assign(Object.assign({}, rasterFunctionInfo), { description: functionDescription, thumbnail: functionalThumbnail });
            });
        };
        this.getExportImageBaseURL = () => {
            var _a;
            const { layer, IdentityManager } = this;
            if (layer === null || layer.fullExtent === null) {
                return;
            }
            const layerExtent = layer.fullExtent.clone();
            const width = layer.fullExtent.width;
            const height = layer.fullExtent.height;
            if (width / height >= 2.0 || height / width >= 2.0) {
                // Fix for non-square services...
                const sideLength = Math.min(width, height) / 2.0;
                const center = layer.fullExtent.center;
                layerExtent.xmin = center.x - sideLength;
                layerExtent.ymin = center.y - sideLength;
                layerExtent.xmax = center.x + sideLength;
                layerExtent.ymax = center.y + sideLength;
            }
            const layerExtentStr = layerExtent.xmin + "," + layerExtent.ymin + "," + layerExtent.xmax + "," + layerExtent.ymax;
            const credential = IdentityManager.findCredential(layer.url);
            const token = credential === null || credential === void 0 ? void 0 : credential.token;
            const params = new URLSearchParams(Object.assign(Object.assign({ bbox: layerExtentStr, token, imageSize: "400,400" }, layer.customParameters), { f: "image" }));
            if (!token) {
                params.delete("token");
            }
            const serviceInfo = layer.sourceJSON;
            if (serviceInfo.bandCount === 2 && ((_a = serviceInfo.serviceDataType) === null || _a === void 0 ? void 0 : _a.includes("Vector"))) {
                params.append("renderingRule", JSON.stringify({
                    rasterFunction: "VectorFieldRenderer",
                    rasterFunctionArguments: {
                        MagnitudeBandID: 0,
                        DirectionBandID: 1,
                        IsUVComponents: serviceInfo.serviceDataType === "esriImageServiceDataTypeVector-UV",
                        // 1: arithmetic, 2: angular
                        ReferenceSystem: 1,
                        // 0: from, 1: to
                        MassFlowAngleRepresentation: 0,
                        // default is 50. we use small thumbnail (e.g. 200 x 133) so need more to better represent
                        SymbolTileSize: 30,
                        SymbolTileSizeUnits: 100,
                        CalculationMethod: "Vector Average",
                        SymbologyName: "Single Arrow",
                        MinimumMagnitude: 1,
                        MaximumMagnitude: -1,
                        MinimumSymbolSize: 40,
                        MaximumSymbolSize: 80
                    },
                    outputPixelType: "U8",
                    variableName: "Raster"
                }));
            }
            return `${layer.url}/exportImage?${params.toString()}`;
        };
        this.layer = undefined;
        this.portal = undefined;
        this.dismissible = false;
        this.showRendererWarning = false;
        this.activeRasterFunctionName = null;
        this.customRasterFunction = null;
        this.showRFTItemBrowser = false;
        this.items = undefined;
        this.pagination = undefined;
        this.rftItemData = defaultApiDataState;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const [IdentityManager, PortalItem, RasterFunction, geoprocessor, esriRequest] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__.l)([
            "esri/identity/IdentityManager",
            "esri/portal/PortalItem",
            "esri/layers/support/RasterFunction",
            "esri/rest/geoprocessor",
            "esri/request"
        ]);
        this.IdentityManager = IdentityManager;
        this.PortalItem = PortalItem;
        this.RasterFunction = RasterFunction;
        this.geoprocessor = geoprocessor;
        this.esriRequest = esriRequest;
        const [strings] = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement);
        this.strings = strings;
        await this.init();
    }
    // --------------------------------------------------------------------------
    //
    //  Renderer methods
    //
    // --------------------------------------------------------------------------
    render() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow", null, this.showRFTItemBrowser ? this.renderRFTBrowsePanel() : this.renderTemplatePanel())));
    }
    renderRFTBrowsePanel() {
        const { layer, rftItemData, strings } = this;
        const isRFTItemLoading = rftItemData.status === ApiStatusType.Pending;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { heading: strings.chooseRasterFunctionTemplate, loading: !layer }, this.renderBack(), isRFTItemLoading && this.renderRFTItemLoader(), this.renderRFTItemBrowser()));
    }
    renderRFTItemBrowser() {
        const { portal, strings, pagination } = this;
        const query = `type:"Raster function template"`;
        const baseUrl = `${getPortalBaseUrl(portal)}/home/`;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser", { api: 4, portal: portal, config: { baseUrl }, q: query, user: portal.user, view: "list", onArcgisItemBrowserUpdate: (event) => {
                const { results, num, start, total } = event.detail;
                this.items = results;
                this.pagination = { start, num, total };
            }, onArcgisItemBrowserLoading: () => (this.items = []) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-top-bar", { slot: "top-bar" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-bucket-select", { slot: "bucket" }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-search", { slot: "search", placeholder: strings.itemBrowserPlaceholder, term: "" })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-sort", { slot: "sort" }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-filters", { slot: "filters" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-filter-extent", null), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-filter-folder", null), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-filter-categories", null), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-filter-date", { property: "modified" }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-filter-date", { property: "created" }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-filter-tags", null), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-filter-sharing", null), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-filter-content-status", null)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-content", { slot: "content" }, (this.items || []).map((item) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-card", { key: item.id, baseUrl: baseUrl, item: item, portal: portal, preview: "top", showDateUpdated: true, showItemType: false, showOwner: true, showThumbnail: true, user: portal.user }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "actions-end", appearance: "transparent", iconStart: "plus-circle", kind: "neutral", scale: "s", onClick: () => this.handleCustomRFTAdd(item) }))))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-browser-pagination", { slot: "pagination", total: pagination === null || pagination === void 0 ? void 0 : pagination.total, start: pagination === null || pagination === void 0 ? void 0 : pagination.start, num: pagination === null || pagination === void 0 ? void 0 : pagination.num })));
    }
    renderRFTItemLoader() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "rft-item-loader" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-loader", { inline: true, label: "rftItemLoader", type: "indeterminate" }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "loader-text" }, this.strings.rftItemLoaderText)));
    }
    renderTemplatePanel() {
        const { layer, rftItemData, strings, showRendererWarning, dismissible } = this;
        const shouldRenderBetaNotice = layer.type === "imagery-tile";
        const hasCustomRFTValidationError = rftItemData.status === ApiStatusType.Rejected;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { loading: !layer, heading: strings.processingTemplates }, dismissible && this.renderClose(), shouldRenderBetaNotice && this.renderBetaNotice(), showRendererWarning && this.renderWarningNotice(), this.renderImportTemplateButton(), hasCustomRFTValidationError && this.renderValidationError(rftItemData.error), this.renderServerRasterFunctionsInfo(), this.renderFooterActions()));
    }
    renderBetaNotice() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "beta-notice" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { closable: true, icon: true, open: true, scale: "s" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, this.strings.betaNotice))));
    }
    renderWarningNotice() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "warning-notice" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { closable: true, icon: true, kind: "warning", open: true, scale: "s" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, this.strings.warningNotice))));
    }
    renderImportTemplateButton() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", "icon-start": "plus", onClick: this.handleImportTemplate }, this.strings.importUserTemplate));
    }
    renderValidationError(errorMessage) {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-alert", { kind: "danger", label: errorMessage, open: true }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "title" }, this.strings.validationErrorTitle), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, errorMessage)));
    }
    renderServerRasterFunctionsInfo() {
        const { customRasterFunction, rasterFunctionInfos, strings } = this;
        if ((rasterFunctionInfos === null || rasterFunctionInfos === void 0 ? void 0 : rasterFunctionInfos.length) === 0) {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list-item", { description: strings.noRasterFunctions })));
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", { selectionMode: "single-persist" }, customRasterFunction
            ? this.renderRasterFunctionInfo(customRasterFunction, rasterFunctionInfos.length)
            : null, rasterFunctionInfos.map((rasterFunctionInfo, index) => this.renderRasterFunctionInfo(rasterFunctionInfo, index))));
    }
    renderRasterFunctionInfo(rasterFunctionInfo, id) {
        var _a, _b;
        const { name, description, thumbnail } = rasterFunctionInfo;
        const isDescriptionLengthy = (description === null || description === void 0 ? void 0 : description.length) > 100;
        const showTooltip = isDescriptionLengthy;
        const itemDescription = isDescriptionLengthy ? `${description.slice(0, 100)}...` : description;
        const listItemNodeId = `${name}_raster_function_info_${id}`;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: id }, showTooltip && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tooltip", { "reference-element": listItemNodeId }, description)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list-item", { id: listItemNodeId, description: itemDescription, label: name, value: name, key: name, selected: name === ((_a = this.activeRasterFunctionName) !== null && _a !== void 0 ? _a : (_b = this.rasterFunctionInfos[0]) === null || _b === void 0 ? void 0 : _b.name), onCalciteListItemSelect: () => this.updateLayerRasterFunction(name) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { slot: "actions-start", compact: true, scale: "s", text: name, onClick: () => this.updateLayerRasterFunction(name) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("img", { src: thumbnail, class: "raster-function-thumbnail" })))));
    }
    renderBack() {
        const backActionId = "raster-processing-template-back-action";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { id: backActionId, text: this.strings.back, scale: "s", slot: "header-actions-start", onClick: () => this.updateShowItemBrowser(false) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "s", icon: "chevron-left" }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tooltip", { "reference-element": backActionId, slot: "tooltip" }, this.strings.back)));
    }
    renderClose() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: this.strings.close, scale: "s", slot: "header-actions-end", onClick: this.handleCancel }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "m", icon: "x" })));
    }
    renderFooterActions() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, this.renderDoneButton(), this.renderCancelButton()));
    }
    renderDoneButton() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", color: "blue", width: "half", onClick: this.handleDone }, this.strings.done));
    }
    renderCancelButton() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", appearance: "outline-fill", width: "half", onClick: this.handleCancel }, this.strings.cancel));
    }
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    async init() {
        var _a, _b;
        await this.layer.load();
        this.originalRasterFunction = this.layer.rasterFunction;
        const originalRasterFunctionName = (_b = (_a = this.originalRasterFunction) === null || _a === void 0 ? void 0 : _a.functionName) !== null && _b !== void 0 ? _b : null;
        this.updateActiveRasterFunctionName(originalRasterFunctionName);
        this.rasterFunctionInfos = this.getRasterFunctionInfos();
        const isActiveRasterFunctionCustom = this.activeRasterFunctionName &&
            !this.rasterFunctionInfos.some(({ name }) => name === this.activeRasterFunctionName);
        if (isActiveRasterFunctionCustom) {
            this.customRasterFunction = this.createCustomRasterFunction(this.originalRasterFunction);
        }
    }
    updateCustomRasterFunction(updatedCustomRasterFunction) {
        var _a;
        const updatedCustomRFT = this.createCustomRasterFunction(updatedCustomRasterFunction);
        if (((_a = this.customRasterFunction) === null || _a === void 0 ? void 0 : _a.name) !== updatedCustomRFT.name) {
            this.customRasterFunction = updatedCustomRFT;
            this.updateActiveRasterFunctionName(updatedCustomRFT.name);
            this.updateLayerRasterFunction(updatedCustomRFT.name);
        }
    }
    updateRFTItemApiData(updatedRFTItemApiData) {
        this.rftItemData = updatedRFTItemApiData;
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisRasterProcessingTemplate.style = arcgisRasterProcessingTemplateCss;



//# sourceMappingURL=arcgis-raster-processing-template.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWYwY2EwOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM0SDtBQUMvRDtBQUNTO0FBQzNDO0FBQ1M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUV2Qyw4QkFBOEI7O0FBRTlCO0FBQ0EsNkNBQTZDLG9CQUFvQixtQkFBbUIsR0FBRztBQUN2RixtREFBbUQsbURBQW1EO0FBQ3RHLGNBQWMsUUFBUSxHQUFHLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0EsWUFBWSx3Q0FBd0M7QUFDcEQsWUFBWSxXQUFXO0FBQ3ZCLDRCQUE0QixPQUFPLEdBQUcsY0FBYztBQUNwRCxjQUFjLFNBQVMsSUFBSSxJQUFJO0FBQy9COztBQUVBLGlEQUFpRCxhQUFhLFlBQVksNkJBQTZCLGVBQWUsa0JBQWtCLCtFQUErRSwyQkFBMkIsYUFBYSxZQUFZLGNBQWMsaUJBQWlCLG9CQUFvQixtQkFBbUIsdUJBQXVCLFdBQVcsYUFBYSxtQ0FBbUM7O0FBRW5hO0FBQ0E7QUFDQSxRQUFRLHFEQUFnQjtBQUN4QixtREFBbUQscURBQVc7QUFDOUQ7QUFDQTtBQUNBLHVEQUF1RCx3QkFBd0Isc0NBQXNDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtcmFzdGVyLXByb2Nlc3NpbmctdGVtcGxhdGUuZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsZS0wNTBiNmRiOS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgSCBhcyBIb3N0LCBGIGFzIEZyYWdtZW50LCBkIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyB9IGZyb20gJy4vbG9jYWxlLTA1MGI2ZGI5LmpzJztcbmltcG9ydCAnLi9kb20tNGQzNjc2NzcuanMnO1xuaW1wb3J0ICcuL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyc7XG5cbnZhciBBcGlTdGF0dXNUeXBlO1xuKGZ1bmN0aW9uIChBcGlTdGF0dXNUeXBlKSB7XG4gICAgQXBpU3RhdHVzVHlwZVtBcGlTdGF0dXNUeXBlW1wiSWRsZVwiXSA9IDBdID0gXCJJZGxlXCI7XG4gICAgQXBpU3RhdHVzVHlwZVtBcGlTdGF0dXNUeXBlW1wiUGVuZGluZ1wiXSA9IDFdID0gXCJQZW5kaW5nXCI7XG4gICAgQXBpU3RhdHVzVHlwZVtBcGlTdGF0dXNUeXBlW1wiUmVzb2x2ZWRcIl0gPSAyXSA9IFwiUmVzb2x2ZWRcIjtcbiAgICBBcGlTdGF0dXNUeXBlW0FwaVN0YXR1c1R5cGVbXCJSZWplY3RlZFwiXSA9IDNdID0gXCJSZWplY3RlZFwiO1xufSkoQXBpU3RhdHVzVHlwZSB8fCAoQXBpU3RhdHVzVHlwZSA9IHt9KSk7XG5cbmNvbnN0IGRlZmF1bHRBcGlEYXRhU3RhdGUgPSB7IHN0YXR1czogQXBpU3RhdHVzVHlwZS5JZGxlLCBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9O1xuXG5jb25zdCBhZGRSYXN0ZXJGdW5jdGlvbk5hbWVVUkxQYXJhbSA9IChiYXNlVVJMLCByYXN0ZXJGdW5jdGlvbk5hbWUpID0+IHtcbiAgICBjb25zdCByYXN0ZXJGdW5jdGlvbk5hbWVVUklDb21wb25lbnQgPSBge1wicmFzdGVyRnVuY3Rpb25cIjpcIiR7cmFzdGVyRnVuY3Rpb25OYW1lfVwiIH1gO1xuICAgIGNvbnN0IHJlbmRlcmluZ1J1bGVVUkxQYXJhbSA9IGByZW5kZXJpbmdSdWxlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHJhc3RlckZ1bmN0aW9uTmFtZVVSSUNvbXBvbmVudCl9YDtcbiAgICByZXR1cm4gYCR7YmFzZVVSTH0mJHtyZW5kZXJpbmdSdWxlVVJMUGFyYW19YDtcbn07XG5mdW5jdGlvbiBnZXRQb3J0YWxCYXNlVXJsKHBvcnRhbCkge1xuICAgIGNvbnN0IHsgY3VzdG9tQmFzZVVybCwgcG9ydGFsSG9zdG5hbWUsIHVybEtleSB9ID0gcG9ydGFsO1xuICAgIGNvbnN0IHsgcHJvdG9jb2wgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBjb25zdCB1cmwgPSB1cmxLZXkgPyBgJHt1cmxLZXl9LiR7Y3VzdG9tQmFzZVVybH1gIDogcG9ydGFsSG9zdG5hbWU7XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHt1cmx9YDtcbn1cblxuY29uc3QgYXJjZ2lzUmFzdGVyUHJvY2Vzc2luZ1RlbXBsYXRlQ3NzID0gXCI6aG9zdHtkaXNwbGF5OmZsZXg7aGVpZ2h0OjEwMCV9LmJldGEtbm90aWNlLC53YXJuaW5nLW5vdGljZXttYXgtd2lkdGg6MTAwJTt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOnZhcigtLWFyY2dpcy1hcHAtY2FwLXNwYWNpbmctaGFsZikgdmFyKC0tYXJjZ2lzLWFwcC1zaWRlLXNwYWNpbmctaGFsZil9LnJhc3Rlci1mdW5jdGlvbi10aHVtYm5haWx7aGVpZ2h0OjEwMHB4O3dpZHRoOjEwMHB4O3BhZGRpbmc6MCA4cHh9LnJmdC1pdGVtLWxvYWRlcntkaXNwbGF5OmlubGluZS1mbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEwMCV9LmxvYWRlci10ZXh0e21hcmdpbjowIC0tYXJjZ2lzLWFwcC1zaWRlLXNwYWNpbmd9XCI7XG5cbmNvbnN0IEFyY2dpc1Jhc3RlclByb2Nlc3NpbmdUZW1wbGF0ZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzUmFzdGVyUHJvY2Vzc2luZ1RlbXBsYXRlQ2xvc2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1Jhc3RlclByb2Nlc3NpbmdUZW1wbGF0ZUNsb3NlXCIsIDcpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsUmFzdGVyRnVuY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnJhc3RlckZ1bmN0aW9uSW5mb3MgPSBbXTtcbiAgICAgICAgdGhpcy5kYXRhVVJMUmVnZXggPSAvXlxccypkYXRhOihbYS16XStcXC9bYS16XSsoO1thLXpcXC1dK1xcPVthLXpcXC1dKyk/KT8oO2Jhc2U2NCk/LFthLXowLTlcXCFcXCRcXCZcXCdcXCxcXChcXClcXCpcXCtcXCxcXDtcXD1cXC1cXC5cXF9cXH5cXDpcXEBcXC9cXD9cXCVcXHNdKlxccyokL2k7XG4gICAgICAgIC8vIHVzZXIgY2xpY2sgaGFuZGVyc1xuICAgICAgICB0aGlzLmhhbmRsZUltcG9ydFRlbXBsYXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTaG93SXRlbUJyb3dzZXIodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VzdG9tUkZUQWRkID0gKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hSRlRJdGVtKGl0ZW0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc1Jhc3RlclByb2Nlc3NpbmdUZW1wbGF0ZUNsb3NlLmVtaXQoXCJzYXZlXCIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRoaXMubGF5ZXIucmFzdGVyRnVuY3Rpb24gPSB0aGlzLm9yaWdpbmFsUmFzdGVyRnVuY3Rpb247XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVJhc3RlckZ1bmN0aW9uTmFtZSA9IChfYSA9IHRoaXMub3JpZ2luYWxSYXN0ZXJGdW5jdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZ1bmN0aW9uTmFtZTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzUmFzdGVyUHJvY2Vzc2luZ1RlbXBsYXRlQ2xvc2UuZW1pdChcImNhbmNlbFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc3RhdGUgdXBkYXRlIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZVJhc3RlckZ1bmN0aW9uTmFtZSA9ICh1cGRhdGVkUmFzdGVyRnVuY3Rpb25OYW1lKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVJhc3RlckZ1bmN0aW9uTmFtZSA9IHVwZGF0ZWRSYXN0ZXJGdW5jdGlvbk5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTGF5ZXJSYXN0ZXJGdW5jdGlvbiA9ICh1cGRhdGVkUmFzdGVyRnVuY3Rpb25OYW1lKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgeyBsYXllciwgY3VzdG9tUmFzdGVyRnVuY3Rpb24gfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgdXBkYXRlZExheWVyUmFzdGVyRnVuY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiB1cGRhdGVkUmFzdGVyRnVuY3Rpb25OYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZWRSYXN0ZXJGdW5jdGlvbk5hbWUgPT09IChjdXN0b21SYXN0ZXJGdW5jdGlvbiA9PT0gbnVsbCB8fCBjdXN0b21SYXN0ZXJGdW5jdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VzdG9tUmFzdGVyRnVuY3Rpb24ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkTGF5ZXJSYXN0ZXJGdW5jdGlvbiA9IGN1c3RvbVJhc3RlckZ1bmN0aW9uID09PSBudWxsIHx8IGN1c3RvbVJhc3RlckZ1bmN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21SYXN0ZXJGdW5jdGlvbi5mdW5jdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXllci50eXBlID09PSBcImltYWdlcnktdGlsZVwiKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIucmFzdGVyRnVuY3Rpb24gPVxuICAgICAgICAgICAgICAgICAgICAodXBkYXRlZFJhc3RlckZ1bmN0aW9uTmFtZSA9PT0gbnVsbCB8fCB1cGRhdGVkUmFzdGVyRnVuY3Rpb25OYW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1cGRhdGVkUmFzdGVyRnVuY3Rpb25OYW1lLnRvTG93ZXJDYXNlKCkpID09PSBcIm5vbmVcIiA/IG51bGwgOiB1cGRhdGVkTGF5ZXJSYXN0ZXJGdW5jdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxheWVyLnJhc3RlckZ1bmN0aW9uID0gdXBkYXRlZExheWVyUmFzdGVyRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIubW9zYWljUnVsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9iID0gbGF5ZXIubW9zYWljUnVsZS5tdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvblswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZhcmlhYmxlTmFtZSkgIT09IHVwZGF0ZWRSYXN0ZXJGdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWREZWZpbml0aW9uID0gbGF5ZXIubW9zYWljUnVsZS5tdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbi5tYXAoKGRlZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhcmlhYmxlTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIubW9zYWljUnVsZS5tdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IG1kRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVJhc3RlckZ1bmN0aW9uTmFtZSA9IHVwZGF0ZWRSYXN0ZXJGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICBsYXllci5yZW5kZXJlciA9IG51bGw7XG4gICAgICAgICAgICBsYXllci5iYW5kSWRzID0gbnVsbDtcbiAgICAgICAgICAgIGxheWVyLm11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZVNob3dJdGVtQnJvd3NlciA9ICh1cGRhdGVkU2hvd0l0ZW1Ccm93c2VyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNob3dSRlRJdGVtQnJvd3NlciA9IHVwZGF0ZWRTaG93SXRlbUJyb3dzZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGFzeW5jIGNhbGxzXG4gICAgICAgIHRoaXMuZmV0Y2hSRlRJdGVtID0gYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUkZUSXRlbUFwaURhdGEoeyBzdGF0dXM6IEFwaVN0YXR1c1R5cGUuUGVuZGluZywgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgICAgICBpZiAoIShpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW0uaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSRlRJdGVtQXBpRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogQXBpU3RhdHVzVHlwZS5SZWplY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRoaXMuc3RyaW5ncy5lcnJvclJldHJpZXZpbmdSRlRJdGVtXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0YWxSRlRJdGVtID0gbmV3IHRoaXMuUG9ydGFsSXRlbSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICBwb3J0YWw6IHRoaXMucG9ydGFsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGZldGNoZWRSRlREYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1OYW1lID0gaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUZvcm1hdCA9IGl0ZW1OYW1lID09PSBudWxsIHx8IGl0ZW1OYW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtTmFtZS5zbGljZSgtOCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNYTUxGb3JtYXQgPSAoaXRlbUZvcm1hdCA9PT0gbnVsbCB8fCBpdGVtRm9ybWF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtRm9ybWF0LnRvTG93ZXJDYXNlKCkpID09PSBcIi5yZnQueG1sXCI7XG4gICAgICAgICAgICAgICAgaWYgKGlzWE1MRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZWRSRlREYXRhID0gYXdhaXQgdGhpcy5jb252ZXJ0UkZURm9ybWF0KGl0ZW0uaWQsIFwianNvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZWRSRlREYXRhID0gYXdhaXQgcG9ydGFsUkZUSXRlbS5mZXRjaERhdGEoXCJqc29uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZnREYXRhID0gdGhpcy5SYXN0ZXJGdW5jdGlvbi5mcm9tSlNPTih7XG4gICAgICAgICAgICAgICAgICAgIHJhc3RlckZ1bmN0aW9uRGVmaW5pdGlvbjogZmV0Y2hlZFJGVERhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlUkZUKHJmdERhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUkZUSXRlbUFwaURhdGEoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IEFwaVN0YXR1c1R5cGUuUmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHJmdERhdGEsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXN0b21SYXN0ZXJGdW5jdGlvbihyZnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUkZUSXRlbUFwaURhdGEoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IEFwaVN0YXR1c1R5cGUuUmVqZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNob3dJdGVtQnJvd3NlcihmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmFsaWRhdGVSRlQgPSBhc3luYyAocmZ0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxheWVyLCBlc3JpUmVxdWVzdCwgc3RyaW5ncyB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCByZnRKc29uID0gcmZ0LnRvSlNPTigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25EYXRhID0gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5LXRpbGVcIlxuICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IGVzcmlSZXF1ZXN0KGxheWVyLnVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJpbmdSdWxlOiBKU09OLnN0cmluZ2lmeSgoX2EgPSByZnRKc29uID09PSBudWxsIHx8IHJmdEpzb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJmdEpzb24ucmFzdGVyRnVuY3Rpb25EZWZpbml0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZnRKc29uKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IGF3YWl0IGxheWVyLmdlbmVyYXRlUmFzdGVySW5mbyhyZnQpO1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ3MucmZ0VmFsaWRhdGlvbkZhaWxlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdHJpbmdzOiB7IHJmdFZhbGlkYXRpb25GYWlsZWQsIHVuc3VwcG9ydGVkRnVuY3Rpb24gfSB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IChfYiA9IGVycm9yLm1lc3NhZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ1bnN1cHBvcnRlZCByYXN0ZXIgZnVuY3Rpb246XCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVW5zdXBwb3J0ZWRSYXN0ZXJGdW5jdGlvbiA9IGluZGV4ID4gLTE7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IHJmdFZhbGlkYXRpb25GYWlsZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5zdXBwb3J0ZWRSYXN0ZXJGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgJHtyZnRWYWxpZGF0aW9uRmFpbGVkfSAke3Vuc3VwcG9ydGVkRnVuY3Rpb24ucmVwbGFjZShcIiR7cmFzdGVyRnVuY3Rpb259XCIsIGVycm9yLm1lc3NhZ2Uuc2xpY2UoaW5kZXggKyAyOCkudHJpbSgpKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb252ZXJ0UkZURm9ybWF0ID0gYXN5bmMgKHJmdEl0ZW1JZCwgZm9ybWF0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYXN0ZXJVdGlsaXRpZXNTZXJ2ZXIgPSB0aGlzLnBvcnRhbC5oZWxwZXJTZXJ2aWNlcy5yYXN0ZXJVdGlsaXRpZXM7XG4gICAgICAgICAgICBpZiAoIXJhc3RlclV0aWxpdGllc1NlcnZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnN0cmluZ3MucmFzdGVydXRpbGl0eVNldmVyTWlzc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHtyYXN0ZXJVdGlsaXRpZXNTZXJ2ZXIudXJsfS9Db252ZXJ0UmFzdGVyRnVuY3Rpb25UZW1wbGF0ZWA7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaW5wdXRSYXN0ZXJGdW5jdGlvbjogSlNPTi5zdHJpbmdpZnkoeyBpdGVtSWQ6IHJmdEl0ZW1JZCB9KSxcbiAgICAgICAgICAgICAgICBmb3JtYXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBnZW9Qcm9jZXNzb3JKb2IgPSBhd2FpdCB0aGlzLmdlb3Byb2Nlc3Nvci5zdWJtaXRKb2IodXJsLCBwYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgZ2VvUHJvY2Vzc29ySm9iV2FpdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IDE1MDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCBnZW9Qcm9jZXNzb3JKb2Iud2FpdEZvckpvYkNvbXBsZXRpb24oZ2VvUHJvY2Vzc29ySm9iV2FpdE9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZW9Qcm9jZXNzb3JKb2IuZmV0Y2hSZXN1bHREYXRhKFwib3V0cHV0UmFzdGVyRnVuY3Rpb25cIik7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRSRlRVcmwgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UudmFsdWU7XG4gICAgICAgICAgICBpZiAoIWNvbnZlcnRlZFJGVFVybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnN0cmluZ3MudW5zdXBwb3J0ZWRGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRSRlREYXRhID0gYXdhaXQgdGhpcy5lc3JpUmVxdWVzdChjb252ZXJ0ZWRSRlRVcmwpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRlZFJGVERhdGEuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdXRpbGl0aWVzXG4gICAgICAgIHRoaXMuY3JlYXRlQ3VzdG9tUmFzdGVyRnVuY3Rpb24gPSAocmFzdGVyRnVuY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RyaW5nczogeyBjdXN0b20gfSwgbGF5ZXIgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCByZnRKc29uID0gKF9hID0gcmFzdGVyRnVuY3Rpb24gPT09IG51bGwgfHwgcmFzdGVyRnVuY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhc3RlckZ1bmN0aW9uLnJhc3RlckZ1bmN0aW9uRGVmaW5pdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmFzdGVyRnVuY3Rpb247XG4gICAgICAgICAgICBjb25zdCB7IGZ1bmN0aW9uTmFtZSB9ID0gcmFzdGVyRnVuY3Rpb247XG4gICAgICAgICAgICBjb25zdCB7IGRlc2NyaXB0aW9uLCB0aHVtYm5haWxFeDogdGh1bWJuYWlsLCBoZWxwIH0gPSByZnRKc29uO1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tUkZUID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGAke2N1c3RvbX0tICR7ZnVuY3Rpb25OYW1lfWAsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IHJhc3RlckZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHRodW1ibmFpbCxcbiAgICAgICAgICAgICAgICBoZWxwLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uVHlwZTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdGh1bWJuYWlsICYmICF0aGlzLmRhdGFVUkxSZWdleC50ZXN0KHRodW1ibmFpbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ltYWdlcnlUaWxlTGF5ZXIgPSBsYXllci50eXBlID09PSBcImltYWdlcnktdGlsZVwiO1xuICAgICAgICAgICAgICAgIGlmIChpc0ltYWdlcnlUaWxlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tUkZULnRodW1ibmFpbCA9IGAke3RoaXMucG9ydGFsLnN0YXRpY0ltYWdlc1VybH0vcmFzdGVyZnVuY3Rpb250ZW1wbGF0ZS5wbmdgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwb3J0SW1hZ2VCYXNlVVJMID0gdGhpcy5nZXRFeHBvcnRJbWFnZUJhc2VVUkwoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyaW5nUnVsZVN0ciA9IGByZW5kZXJpbmdSdWxlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHJmdEpzb24pKX1gOyAvLyBAVE9ETyBEZXYgZnVuY3Rpbm8gZ2VuZXJhbGl6ZSB1dGlscy5qc1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21SRlQudGh1bWJuYWlsID0gYCR7ZXhwb3J0SW1hZ2VCYXNlVVJMfSYke3JlbmRlcmluZ1J1bGVTdHJ9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tUkZUO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJhc3RlckZ1bmN0aW9uSW5mb3MgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHRoaXMubGF5ZXI7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJpbWFnZXJ5LXRpbGVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiTm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuc3RyaW5ncy5ub25lUmFzdGVyRnVuY3Rpb25EZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblR5cGU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWw6IGAke3RoaXMucG9ydGFsLnN0YXRpY0ltYWdlc1VybH0vcmFzdGVyZnVuY3Rpb250ZW1wbGF0ZS5wbmdgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmFzdGVyRnVuY3Rpb25JbmZvcyA9IHRoaXMuZml4SW1hZ2VyeVJhc3RlckZ1bmN0aW9uc1RodW1ibmFpbCh0aGlzLmxheWVyLnJhc3RlckZ1bmN0aW9uSW5mb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHJhc3RlckZ1bmN0aW9uSW5mb3M7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZml4SW1hZ2VyeVJhc3RlckZ1bmN0aW9uc1RodW1ibmFpbCA9IChyYXN0ZXJGdW5jdGlvbkluZm9zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFVUkxSZWdleCwgbGF5ZXIsIHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAobGF5ZXIudHlwZSAhPT0gXCJpbWFnZXJ5XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFzdGVyRnVuY3Rpb25JbmZvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydEltYWdlQmFzZVVSTCA9IHRoaXMuZ2V0RXhwb3J0SW1hZ2VCYXNlVVJMKCk7XG4gICAgICAgICAgICByZXR1cm4gcmFzdGVyRnVuY3Rpb25JbmZvcy5tYXAoKHJhc3RlckZ1bmN0aW9uSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc05vbmVGdW5jdGlvbiA9IHJhc3RlckZ1bmN0aW9uSW5mby5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRodW1ibmFpbFVSTCA9IGFkZFJhc3RlckZ1bmN0aW9uTmFtZVVSTFBhcmFtKGV4cG9ydEltYWdlQmFzZVVSTCwgcmFzdGVyRnVuY3Rpb25JbmZvLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc05vbmVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub25lRnVuY3Rpb25EZXNjcmlwdGlvbiA9IHN0cmluZ3Mubm9uZVJhc3RlckZ1bmN0aW9uRGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGxldCB0aHVtYm5haWwgPSB0aHVtYm5haWxVUkw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbmRJZHMgPSBsYXllci5iYW5kSWRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJhbmRJZHMgPT09IG51bGwgfHwgYmFuZElkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFuZElkcy5sZW5ndGgpID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbCA9IGAke3RodW1ibmFpbFVSTH0rJmJhbmRJZHM9JHtiYW5kSWRzWzBdfSwke2JhbmRJZHNbMV19LCR7YmFuZElkc1syXX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vbmVGdW5jdGlvblRodW1ibmFpbCA9IHRodW1ibmFpbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmFzdGVyRnVuY3Rpb25JbmZvKSwgeyBkZXNjcmlwdGlvbjogbm9uZUZ1bmN0aW9uRGVzY3JpcHRpb24sIHRodW1ibmFpbDogbm9uZUZ1bmN0aW9uVGh1bWJuYWlsIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvbkRlc2NyaXB0aW9uID0gKF9hID0gcmFzdGVyRnVuY3Rpb25JbmZvLmRlc2NyaXB0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGxldCBmdW5jdGlvbmFsVGh1bWJuYWlsID0gcmFzdGVyRnVuY3Rpb25JbmZvLnRodW1ibmFpbDtcbiAgICAgICAgICAgICAgICBpZiAoIXJhc3RlckZ1bmN0aW9uSW5mby50aHVtYm5haWwgfHwgIWRhdGFVUkxSZWdleC50ZXN0KHJhc3RlckZ1bmN0aW9uSW5mby50aHVtYm5haWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxUaHVtYm5haWwgPSB0aHVtYm5haWxVUkw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhc3RlckZ1bmN0aW9uSW5mbyksIHsgZGVzY3JpcHRpb246IGZ1bmN0aW9uRGVzY3JpcHRpb24sIHRodW1ibmFpbDogZnVuY3Rpb25hbFRodW1ibmFpbCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEV4cG9ydEltYWdlQmFzZVVSTCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5ZXIsIElkZW50aXR5TWFuYWdlciB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmIChsYXllciA9PT0gbnVsbCB8fCBsYXllci5mdWxsRXh0ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGF5ZXJFeHRlbnQgPSBsYXllci5mdWxsRXh0ZW50LmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGxheWVyLmZ1bGxFeHRlbnQud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBsYXllci5mdWxsRXh0ZW50LmhlaWdodDtcbiAgICAgICAgICAgIGlmICh3aWR0aCAvIGhlaWdodCA+PSAyLjAgfHwgaGVpZ2h0IC8gd2lkdGggPj0gMi4wKSB7XG4gICAgICAgICAgICAgICAgLy8gRml4IGZvciBub24tc3F1YXJlIHNlcnZpY2VzLi4uXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lkZUxlbmd0aCA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMi4wO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IGxheWVyLmZ1bGxFeHRlbnQuY2VudGVyO1xuICAgICAgICAgICAgICAgIGxheWVyRXh0ZW50LnhtaW4gPSBjZW50ZXIueCAtIHNpZGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgbGF5ZXJFeHRlbnQueW1pbiA9IGNlbnRlci55IC0gc2lkZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBsYXllckV4dGVudC54bWF4ID0gY2VudGVyLnggKyBzaWRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxheWVyRXh0ZW50LnltYXggPSBjZW50ZXIueSArIHNpZGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYXllckV4dGVudFN0ciA9IGxheWVyRXh0ZW50LnhtaW4gKyBcIixcIiArIGxheWVyRXh0ZW50LnltaW4gKyBcIixcIiArIGxheWVyRXh0ZW50LnhtYXggKyBcIixcIiArIGxheWVyRXh0ZW50LnltYXg7XG4gICAgICAgICAgICBjb25zdCBjcmVkZW50aWFsID0gSWRlbnRpdHlNYW5hZ2VyLmZpbmRDcmVkZW50aWFsKGxheWVyLnVybCk7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwgPT09IG51bGwgfHwgY3JlZGVudGlhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlZGVudGlhbC50b2tlbjtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgYmJveDogbGF5ZXJFeHRlbnRTdHIsIHRva2VuLCBpbWFnZVNpemU6IFwiNDAwLDQwMFwiIH0sIGxheWVyLmN1c3RvbVBhcmFtZXRlcnMpLCB7IGY6IFwiaW1hZ2VcIiB9KSk7XG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmRlbGV0ZShcInRva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VydmljZUluZm8gPSBsYXllci5zb3VyY2VKU09OO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VJbmZvLmJhbmRDb3VudCA9PT0gMiAmJiAoKF9hID0gc2VydmljZUluZm8uc2VydmljZURhdGFUeXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoXCJWZWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlbmRlcmluZ1J1bGVcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICByYXN0ZXJGdW5jdGlvbjogXCJWZWN0b3JGaWVsZFJlbmRlcmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIHJhc3RlckZ1bmN0aW9uQXJndW1lbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNYWduaXR1ZGVCYW5kSUQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBEaXJlY3Rpb25CYW5kSUQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBJc1VWQ29tcG9uZW50czogc2VydmljZUluZm8uc2VydmljZURhdGFUeXBlID09PSBcImVzcmlJbWFnZVNlcnZpY2VEYXRhVHlwZVZlY3Rvci1VVlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTogYXJpdGhtZXRpYywgMjogYW5ndWxhclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVmZXJlbmNlU3lzdGVtOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMDogZnJvbSwgMTogdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hc3NGbG93QW5nbGVSZXByZXNlbnRhdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgNTAuIHdlIHVzZSBzbWFsbCB0aHVtYm5haWwgKGUuZy4gMjAwIHggMTMzKSBzbyBuZWVkIG1vcmUgdG8gYmV0dGVyIHJlcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgU3ltYm9sVGlsZVNpemU6IDMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgU3ltYm9sVGlsZVNpemVVbml0czogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgQ2FsY3VsYXRpb25NZXRob2Q6IFwiVmVjdG9yIEF2ZXJhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFN5bWJvbG9neU5hbWU6IFwiU2luZ2xlIEFycm93XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBNaW5pbXVtTWFnbml0dWRlOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF4aW11bU1hZ25pdHVkZTogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBNaW5pbXVtU3ltYm9sU2l6ZTogNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXhpbXVtU3ltYm9sU2l6ZTogODBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0UGl4ZWxUeXBlOiBcIlU4XCIsXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlTmFtZTogXCJSYXN0ZXJcIlxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgJHtsYXllci51cmx9L2V4cG9ydEltYWdlPyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sYXllciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wb3J0YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGlzbWlzc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93UmVuZGVyZXJXYXJuaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlUmFzdGVyRnVuY3Rpb25OYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXN0b21SYXN0ZXJGdW5jdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hvd1JGVEl0ZW1Ccm93c2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGFnaW5hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZnRJdGVtRGF0YSA9IGRlZmF1bHRBcGlEYXRhU3RhdGU7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgY29uc3QgW0lkZW50aXR5TWFuYWdlciwgUG9ydGFsSXRlbSwgUmFzdGVyRnVuY3Rpb24sIGdlb3Byb2Nlc3NvciwgZXNyaVJlcXVlc3RdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgICAgICAgICAgXCJlc3JpL2lkZW50aXR5L0lkZW50aXR5TWFuYWdlclwiLFxuICAgICAgICAgICAgXCJlc3JpL3BvcnRhbC9Qb3J0YWxJdGVtXCIsXG4gICAgICAgICAgICBcImVzcmkvbGF5ZXJzL3N1cHBvcnQvUmFzdGVyRnVuY3Rpb25cIixcbiAgICAgICAgICAgIFwiZXNyaS9yZXN0L2dlb3Byb2Nlc3NvclwiLFxuICAgICAgICAgICAgXCJlc3JpL3JlcXVlc3RcIlxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5JZGVudGl0eU1hbmFnZXIgPSBJZGVudGl0eU1hbmFnZXI7XG4gICAgICAgIHRoaXMuUG9ydGFsSXRlbSA9IFBvcnRhbEl0ZW07XG4gICAgICAgIHRoaXMuUmFzdGVyRnVuY3Rpb24gPSBSYXN0ZXJGdW5jdGlvbjtcbiAgICAgICAgdGhpcy5nZW9wcm9jZXNzb3IgPSBnZW9wcm9jZXNzb3I7XG4gICAgICAgIHRoaXMuZXNyaVJlcXVlc3QgPSBlc3JpUmVxdWVzdDtcbiAgICAgICAgY29uc3QgW3N0cmluZ3NdID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyZXIgbWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiBcImNhbGNpdGUtbWF0Y2gtaGVpZ2h0XCIgfSwgaChcImNhbGNpdGUtZmxvd1wiLCBudWxsLCB0aGlzLnNob3dSRlRJdGVtQnJvd3NlciA/IHRoaXMucmVuZGVyUkZUQnJvd3NlUGFuZWwoKSA6IHRoaXMucmVuZGVyVGVtcGxhdGVQYW5lbCgpKSkpO1xuICAgIH1cbiAgICByZW5kZXJSRlRCcm93c2VQYW5lbCgpIHtcbiAgICAgICAgY29uc3QgeyBsYXllciwgcmZ0SXRlbURhdGEsIHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzUkZUSXRlbUxvYWRpbmcgPSByZnRJdGVtRGF0YS5zdGF0dXMgPT09IEFwaVN0YXR1c1R5cGUuUGVuZGluZztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBoZWFkaW5nOiBzdHJpbmdzLmNob29zZVJhc3RlckZ1bmN0aW9uVGVtcGxhdGUsIGxvYWRpbmc6ICFsYXllciB9LCB0aGlzLnJlbmRlckJhY2soKSwgaXNSRlRJdGVtTG9hZGluZyAmJiB0aGlzLnJlbmRlclJGVEl0ZW1Mb2FkZXIoKSwgdGhpcy5yZW5kZXJSRlRJdGVtQnJvd3NlcigpKSk7XG4gICAgfVxuICAgIHJlbmRlclJGVEl0ZW1Ccm93c2VyKCkge1xuICAgICAgICBjb25zdCB7IHBvcnRhbCwgc3RyaW5ncywgcGFnaW5hdGlvbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcXVlcnkgPSBgdHlwZTpcIlJhc3RlciBmdW5jdGlvbiB0ZW1wbGF0ZVwiYDtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGAke2dldFBvcnRhbEJhc2VVcmwocG9ydGFsKX0vaG9tZS9gO1xuICAgICAgICByZXR1cm4gKGgoXCJhcmNnaXMtaXRlbS1icm93c2VyXCIsIHsgYXBpOiA0LCBwb3J0YWw6IHBvcnRhbCwgY29uZmlnOiB7IGJhc2VVcmwgfSwgcTogcXVlcnksIHVzZXI6IHBvcnRhbC51c2VyLCB2aWV3OiBcImxpc3RcIiwgb25BcmNnaXNJdGVtQnJvd3NlclVwZGF0ZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHRzLCBudW0sIHN0YXJ0LCB0b3RhbCB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMgPSByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHRoaXMucGFnaW5hdGlvbiA9IHsgc3RhcnQsIG51bSwgdG90YWwgfTtcbiAgICAgICAgICAgIH0sIG9uQXJjZ2lzSXRlbUJyb3dzZXJMb2FkaW5nOiAoKSA9PiAodGhpcy5pdGVtcyA9IFtdKSB9LCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci10b3AtYmFyXCIsIHsgc2xvdDogXCJ0b3AtYmFyXCIgfSwgaChcImFyY2dpcy1pdGVtLWJyb3dzZXItYnVja2V0LXNlbGVjdFwiLCB7IHNsb3Q6IFwiYnVja2V0XCIgfSksIGgoXCJhcmNnaXMtaXRlbS1icm93c2VyLXNlYXJjaFwiLCB7IHNsb3Q6IFwic2VhcmNoXCIsIHBsYWNlaG9sZGVyOiBzdHJpbmdzLml0ZW1Ccm93c2VyUGxhY2Vob2xkZXIsIHRlcm06IFwiXCIgfSkpLCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1zb3J0XCIsIHsgc2xvdDogXCJzb3J0XCIgfSksIGgoXCJhcmNnaXMtaXRlbS1icm93c2VyLWZpbHRlcnNcIiwgeyBzbG90OiBcImZpbHRlcnNcIiB9LCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1maWx0ZXItZXh0ZW50XCIsIG51bGwpLCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1maWx0ZXItZm9sZGVyXCIsIG51bGwpLCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1maWx0ZXItY2F0ZWdvcmllc1wiLCBudWxsKSwgaChcImFyY2dpcy1pdGVtLWJyb3dzZXItZmlsdGVyLWRhdGVcIiwgeyBwcm9wZXJ0eTogXCJtb2RpZmllZFwiIH0pLCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1maWx0ZXItZGF0ZVwiLCB7IHByb3BlcnR5OiBcImNyZWF0ZWRcIiB9KSwgaChcImFyY2dpcy1pdGVtLWJyb3dzZXItZmlsdGVyLXRhZ3NcIiwgbnVsbCksIGgoXCJhcmNnaXMtaXRlbS1icm93c2VyLWZpbHRlci1zaGFyaW5nXCIsIG51bGwpLCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1maWx0ZXItY29udGVudC1zdGF0dXNcIiwgbnVsbCkpLCBoKFwiYXJjZ2lzLWl0ZW0tYnJvd3Nlci1jb250ZW50XCIsIHsgc2xvdDogXCJjb250ZW50XCIgfSwgKHRoaXMuaXRlbXMgfHwgW10pLm1hcCgoaXRlbSkgPT4gKGgoXCJhcmNnaXMtaXRlbS1icm93c2VyLWNhcmRcIiwgeyBrZXk6IGl0ZW0uaWQsIGJhc2VVcmw6IGJhc2VVcmwsIGl0ZW06IGl0ZW0sIHBvcnRhbDogcG9ydGFsLCBwcmV2aWV3OiBcInRvcFwiLCBzaG93RGF0ZVVwZGF0ZWQ6IHRydWUsIHNob3dJdGVtVHlwZTogZmFsc2UsIHNob3dPd25lcjogdHJ1ZSwgc2hvd1RodW1ibmFpbDogdHJ1ZSwgdXNlcjogcG9ydGFsLnVzZXIgfSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgc2xvdDogXCJhY3Rpb25zLWVuZFwiLCBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIGljb25TdGFydDogXCJwbHVzLWNpcmNsZVwiLCBraW5kOiBcIm5ldXRyYWxcIiwgc2NhbGU6IFwic1wiLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmhhbmRsZUN1c3RvbVJGVEFkZChpdGVtKSB9KSkpKSksIGgoXCJhcmNnaXMtaXRlbS1icm93c2VyLXBhZ2luYXRpb25cIiwgeyBzbG90OiBcInBhZ2luYXRpb25cIiwgdG90YWw6IHBhZ2luYXRpb24gPT09IG51bGwgfHwgcGFnaW5hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFnaW5hdGlvbi50b3RhbCwgc3RhcnQ6IHBhZ2luYXRpb24gPT09IG51bGwgfHwgcGFnaW5hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFnaW5hdGlvbi5zdGFydCwgbnVtOiBwYWdpbmF0aW9uID09PSBudWxsIHx8IHBhZ2luYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhZ2luYXRpb24ubnVtIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlclJGVEl0ZW1Mb2FkZXIoKSB7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBcInJmdC1pdGVtLWxvYWRlclwiIH0sIGgoXCJjYWxjaXRlLWxvYWRlclwiLCB7IGlubGluZTogdHJ1ZSwgbGFiZWw6IFwicmZ0SXRlbUxvYWRlclwiLCB0eXBlOiBcImluZGV0ZXJtaW5hdGVcIiB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiBcImxvYWRlci10ZXh0XCIgfSwgdGhpcy5zdHJpbmdzLnJmdEl0ZW1Mb2FkZXJUZXh0KSkpO1xuICAgIH1cbiAgICByZW5kZXJUZW1wbGF0ZVBhbmVsKCkge1xuICAgICAgICBjb25zdCB7IGxheWVyLCByZnRJdGVtRGF0YSwgc3RyaW5ncywgc2hvd1JlbmRlcmVyV2FybmluZywgZGlzbWlzc2libGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlbmRlckJldGFOb3RpY2UgPSBsYXllci50eXBlID09PSBcImltYWdlcnktdGlsZVwiO1xuICAgICAgICBjb25zdCBoYXNDdXN0b21SRlRWYWxpZGF0aW9uRXJyb3IgPSByZnRJdGVtRGF0YS5zdGF0dXMgPT09IEFwaVN0YXR1c1R5cGUuUmVqZWN0ZWQ7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtZmxvdy1pdGVtXCIsIHsgbG9hZGluZzogIWxheWVyLCBoZWFkaW5nOiBzdHJpbmdzLnByb2Nlc3NpbmdUZW1wbGF0ZXMgfSwgZGlzbWlzc2libGUgJiYgdGhpcy5yZW5kZXJDbG9zZSgpLCBzaG91bGRSZW5kZXJCZXRhTm90aWNlICYmIHRoaXMucmVuZGVyQmV0YU5vdGljZSgpLCBzaG93UmVuZGVyZXJXYXJuaW5nICYmIHRoaXMucmVuZGVyV2FybmluZ05vdGljZSgpLCB0aGlzLnJlbmRlckltcG9ydFRlbXBsYXRlQnV0dG9uKCksIGhhc0N1c3RvbVJGVFZhbGlkYXRpb25FcnJvciAmJiB0aGlzLnJlbmRlclZhbGlkYXRpb25FcnJvcihyZnRJdGVtRGF0YS5lcnJvciksIHRoaXMucmVuZGVyU2VydmVyUmFzdGVyRnVuY3Rpb25zSW5mbygpLCB0aGlzLnJlbmRlckZvb3RlckFjdGlvbnMoKSkpO1xuICAgIH1cbiAgICByZW5kZXJCZXRhTm90aWNlKCkge1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogXCJiZXRhLW5vdGljZVwiIH0sIGgoXCJjYWxjaXRlLW5vdGljZVwiLCB7IGNsb3NhYmxlOiB0cnVlLCBpY29uOiB0cnVlLCBvcGVuOiB0cnVlLCBzY2FsZTogXCJzXCIgfSwgaChcImRpdlwiLCB7IHNsb3Q6IFwibWVzc2FnZVwiIH0sIHRoaXMuc3RyaW5ncy5iZXRhTm90aWNlKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyV2FybmluZ05vdGljZSgpIHtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IFwid2FybmluZy1ub3RpY2VcIiB9LCBoKFwiY2FsY2l0ZS1ub3RpY2VcIiwgeyBjbG9zYWJsZTogdHJ1ZSwgaWNvbjogdHJ1ZSwga2luZDogXCJ3YXJuaW5nXCIsIG9wZW46IHRydWUsIHNjYWxlOiBcInNcIiB9LCBoKFwiZGl2XCIsIHsgc2xvdDogXCJtZXNzYWdlXCIgfSwgdGhpcy5zdHJpbmdzLndhcm5pbmdOb3RpY2UpKSkpO1xuICAgIH1cbiAgICByZW5kZXJJbXBvcnRUZW1wbGF0ZUJ1dHRvbigpIHtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIFwiaWNvbi1zdGFydFwiOiBcInBsdXNcIiwgb25DbGljazogdGhpcy5oYW5kbGVJbXBvcnRUZW1wbGF0ZSB9LCB0aGlzLnN0cmluZ3MuaW1wb3J0VXNlclRlbXBsYXRlKSk7XG4gICAgfVxuICAgIHJlbmRlclZhbGlkYXRpb25FcnJvcihlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1hbGVydFwiLCB7IGtpbmQ6IFwiZGFuZ2VyXCIsIGxhYmVsOiBlcnJvck1lc3NhZ2UsIG9wZW46IHRydWUgfSwgaChcImRpdlwiLCB7IHNsb3Q6IFwidGl0bGVcIiB9LCB0aGlzLnN0cmluZ3MudmFsaWRhdGlvbkVycm9yVGl0bGUpLCBoKFwiZGl2XCIsIHsgc2xvdDogXCJtZXNzYWdlXCIgfSwgZXJyb3JNZXNzYWdlKSkpO1xuICAgIH1cbiAgICByZW5kZXJTZXJ2ZXJSYXN0ZXJGdW5jdGlvbnNJbmZvKCkge1xuICAgICAgICBjb25zdCB7IGN1c3RvbVJhc3RlckZ1bmN0aW9uLCByYXN0ZXJGdW5jdGlvbkluZm9zLCBzdHJpbmdzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoKHJhc3RlckZ1bmN0aW9uSW5mb3MgPT09IG51bGwgfHwgcmFzdGVyRnVuY3Rpb25JbmZvcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFzdGVyRnVuY3Rpb25JbmZvcy5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxpc3RcIiwgbnVsbCwgaChcImNhbGNpdGUtbGlzdC1pdGVtXCIsIHsgZGVzY3JpcHRpb246IHN0cmluZ3Mubm9SYXN0ZXJGdW5jdGlvbnMgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxpc3RcIiwgeyBzZWxlY3Rpb25Nb2RlOiBcInNpbmdsZS1wZXJzaXN0XCIgfSwgY3VzdG9tUmFzdGVyRnVuY3Rpb25cbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJSYXN0ZXJGdW5jdGlvbkluZm8oY3VzdG9tUmFzdGVyRnVuY3Rpb24sIHJhc3RlckZ1bmN0aW9uSW5mb3MubGVuZ3RoKVxuICAgICAgICAgICAgOiBudWxsLCByYXN0ZXJGdW5jdGlvbkluZm9zLm1hcCgocmFzdGVyRnVuY3Rpb25JbmZvLCBpbmRleCkgPT4gdGhpcy5yZW5kZXJSYXN0ZXJGdW5jdGlvbkluZm8ocmFzdGVyRnVuY3Rpb25JbmZvLCBpbmRleCkpKSk7XG4gICAgfVxuICAgIHJlbmRlclJhc3RlckZ1bmN0aW9uSW5mbyhyYXN0ZXJGdW5jdGlvbkluZm8sIGlkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZGVzY3JpcHRpb24sIHRodW1ibmFpbCB9ID0gcmFzdGVyRnVuY3Rpb25JbmZvO1xuICAgICAgICBjb25zdCBpc0Rlc2NyaXB0aW9uTGVuZ3RoeSA9IChkZXNjcmlwdGlvbiA9PT0gbnVsbCB8fCBkZXNjcmlwdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVzY3JpcHRpb24ubGVuZ3RoKSA+IDEwMDtcbiAgICAgICAgY29uc3Qgc2hvd1Rvb2x0aXAgPSBpc0Rlc2NyaXB0aW9uTGVuZ3RoeTtcbiAgICAgICAgY29uc3QgaXRlbURlc2NyaXB0aW9uID0gaXNEZXNjcmlwdGlvbkxlbmd0aHkgPyBgJHtkZXNjcmlwdGlvbi5zbGljZSgwLCAxMDApfS4uLmAgOiBkZXNjcmlwdGlvbjtcbiAgICAgICAgY29uc3QgbGlzdEl0ZW1Ob2RlSWQgPSBgJHtuYW1lfV9yYXN0ZXJfZnVuY3Rpb25faW5mb18ke2lkfWA7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGtleTogaWQgfSwgc2hvd1Rvb2x0aXAgJiYgKGgoXCJjYWxjaXRlLXRvb2x0aXBcIiwgeyBcInJlZmVyZW5jZS1lbGVtZW50XCI6IGxpc3RJdGVtTm9kZUlkIH0sIGRlc2NyaXB0aW9uKSksIGgoXCJjYWxjaXRlLWxpc3QtaXRlbVwiLCB7IGlkOiBsaXN0SXRlbU5vZGVJZCwgZGVzY3JpcHRpb246IGl0ZW1EZXNjcmlwdGlvbiwgbGFiZWw6IG5hbWUsIHZhbHVlOiBuYW1lLCBrZXk6IG5hbWUsIHNlbGVjdGVkOiBuYW1lID09PSAoKF9hID0gdGhpcy5hY3RpdmVSYXN0ZXJGdW5jdGlvbk5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHRoaXMucmFzdGVyRnVuY3Rpb25JbmZvc1swXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpLCBvbkNhbGNpdGVMaXN0SXRlbVNlbGVjdDogKCkgPT4gdGhpcy51cGRhdGVMYXllclJhc3RlckZ1bmN0aW9uKG5hbWUpIH0sIGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IHNsb3Q6IFwiYWN0aW9ucy1zdGFydFwiLCBjb21wYWN0OiB0cnVlLCBzY2FsZTogXCJzXCIsIHRleHQ6IG5hbWUsIG9uQ2xpY2s6ICgpID0+IHRoaXMudXBkYXRlTGF5ZXJSYXN0ZXJGdW5jdGlvbihuYW1lKSB9LCBoKFwiaW1nXCIsIHsgc3JjOiB0aHVtYm5haWwsIGNsYXNzOiBcInJhc3Rlci1mdW5jdGlvbi10aHVtYm5haWxcIiB9KSkpKSk7XG4gICAgfVxuICAgIHJlbmRlckJhY2soKSB7XG4gICAgICAgIGNvbnN0IGJhY2tBY3Rpb25JZCA9IFwicmFzdGVyLXByb2Nlc3NpbmctdGVtcGxhdGUtYmFjay1hY3Rpb25cIjtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBpZDogYmFja0FjdGlvbklkLCB0ZXh0OiB0aGlzLnN0cmluZ3MuYmFjaywgc2NhbGU6IFwic1wiLCBzbG90OiBcImhlYWRlci1hY3Rpb25zLXN0YXJ0XCIsIG9uQ2xpY2s6ICgpID0+IHRoaXMudXBkYXRlU2hvd0l0ZW1Ccm93c2VyKGZhbHNlKSB9LCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgc2NhbGU6IFwic1wiLCBpY29uOiBcImNoZXZyb24tbGVmdFwiIH0pLCBoKFwiY2FsY2l0ZS10b29sdGlwXCIsIHsgXCJyZWZlcmVuY2UtZWxlbWVudFwiOiBiYWNrQWN0aW9uSWQsIHNsb3Q6IFwidG9vbHRpcFwiIH0sIHRoaXMuc3RyaW5ncy5iYWNrKSkpO1xuICAgIH1cbiAgICByZW5kZXJDbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyB0ZXh0OiB0aGlzLnN0cmluZ3MuY2xvc2UsIHNjYWxlOiBcInNcIiwgc2xvdDogXCJoZWFkZXItYWN0aW9ucy1lbmRcIiwgb25DbGljazogdGhpcy5oYW5kbGVDYW5jZWwgfSwgaChcImNhbGNpdGUtaWNvblwiLCB7IHNjYWxlOiBcIm1cIiwgaWNvbjogXCJ4XCIgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRm9vdGVyQWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIChoKEZyYWdtZW50LCBudWxsLCB0aGlzLnJlbmRlckRvbmVCdXR0b24oKSwgdGhpcy5yZW5kZXJDYW5jZWxCdXR0b24oKSkpO1xuICAgIH1cbiAgICByZW5kZXJEb25lQnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIGNvbG9yOiBcImJsdWVcIiwgd2lkdGg6IFwiaGFsZlwiLCBvbkNsaWNrOiB0aGlzLmhhbmRsZURvbmUgfSwgdGhpcy5zdHJpbmdzLmRvbmUpKTtcbiAgICB9XG4gICAgcmVuZGVyQ2FuY2VsQnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIHdpZHRoOiBcImhhbGZcIiwgb25DbGljazogdGhpcy5oYW5kbGVDYW5jZWwgfSwgdGhpcy5zdHJpbmdzLmNhbmNlbCkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBpbml0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBhd2FpdCB0aGlzLmxheWVyLmxvYWQoKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFJhc3RlckZ1bmN0aW9uID0gdGhpcy5sYXllci5yYXN0ZXJGdW5jdGlvbjtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxSYXN0ZXJGdW5jdGlvbk5hbWUgPSAoX2IgPSAoX2EgPSB0aGlzLm9yaWdpbmFsUmFzdGVyRnVuY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mdW5jdGlvbk5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgICAgIHRoaXMudXBkYXRlQWN0aXZlUmFzdGVyRnVuY3Rpb25OYW1lKG9yaWdpbmFsUmFzdGVyRnVuY3Rpb25OYW1lKTtcbiAgICAgICAgdGhpcy5yYXN0ZXJGdW5jdGlvbkluZm9zID0gdGhpcy5nZXRSYXN0ZXJGdW5jdGlvbkluZm9zKCk7XG4gICAgICAgIGNvbnN0IGlzQWN0aXZlUmFzdGVyRnVuY3Rpb25DdXN0b20gPSB0aGlzLmFjdGl2ZVJhc3RlckZ1bmN0aW9uTmFtZSAmJlxuICAgICAgICAgICAgIXRoaXMucmFzdGVyRnVuY3Rpb25JbmZvcy5zb21lKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gdGhpcy5hY3RpdmVSYXN0ZXJGdW5jdGlvbk5hbWUpO1xuICAgICAgICBpZiAoaXNBY3RpdmVSYXN0ZXJGdW5jdGlvbkN1c3RvbSkge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21SYXN0ZXJGdW5jdGlvbiA9IHRoaXMuY3JlYXRlQ3VzdG9tUmFzdGVyRnVuY3Rpb24odGhpcy5vcmlnaW5hbFJhc3RlckZ1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDdXN0b21SYXN0ZXJGdW5jdGlvbih1cGRhdGVkQ3VzdG9tUmFzdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB1cGRhdGVkQ3VzdG9tUkZUID0gdGhpcy5jcmVhdGVDdXN0b21SYXN0ZXJGdW5jdGlvbih1cGRhdGVkQ3VzdG9tUmFzdGVyRnVuY3Rpb24pO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuY3VzdG9tUmFzdGVyRnVuY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSAhPT0gdXBkYXRlZEN1c3RvbVJGVC5uYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVJhc3RlckZ1bmN0aW9uID0gdXBkYXRlZEN1c3RvbVJGVDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZlUmFzdGVyRnVuY3Rpb25OYW1lKHVwZGF0ZWRDdXN0b21SRlQubmFtZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxheWVyUmFzdGVyRnVuY3Rpb24odXBkYXRlZEN1c3RvbVJGVC5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVSRlRJdGVtQXBpRGF0YSh1cGRhdGVkUkZUSXRlbUFwaURhdGEpIHtcbiAgICAgICAgdGhpcy5yZnRJdGVtRGF0YSA9IHVwZGF0ZWRSRlRJdGVtQXBpRGF0YTtcbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc1Jhc3RlclByb2Nlc3NpbmdUZW1wbGF0ZS5zdHlsZSA9IGFyY2dpc1Jhc3RlclByb2Nlc3NpbmdUZW1wbGF0ZUNzcztcblxuZXhwb3J0IHsgQXJjZ2lzUmFzdGVyUHJvY2Vzc2luZ1RlbXBsYXRlIGFzIGFyY2dpc19yYXN0ZXJfcHJvY2Vzc2luZ190ZW1wbGF0ZSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtcmFzdGVyLXByb2Nlc3NpbmctdGVtcGxhdGUuZW50cnkuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTRkMzY3Njc3LmpzJztcblxuY29uc3QgbGFuZ3VhZ2VNYXAgPSBuZXcgTWFwKFtcbiAgICBbXCJhclwiLCBcImFyXCJdLFxuICAgIFtcImJnXCIsIFwiYmdcIl0sXG4gICAgW1wiYnNcIiwgXCJic1wiXSxcbiAgICBbXCJjYVwiLCBcImNhXCJdLFxuICAgIFtcImNzXCIsIFwiY3NcIl0sXG4gICAgW1wiZGFcIiwgXCJkYVwiXSxcbiAgICBbXCJkZVwiLCBcImRlXCJdLFxuICAgIFtcImVsXCIsIFwiZWxcIl0sXG4gICAgW1wiZW5cIiwgXCJlblwiXSxcbiAgICBbXCJlc1wiLCBcImVzXCJdLFxuICAgIFtcImV0XCIsIFwiZXRcIl0sXG4gICAgW1wiZmlcIiwgXCJmaVwiXSxcbiAgICBbXCJmclwiLCBcImZyXCJdLFxuICAgIFtcImhlXCIsIFwiaGVcIl0sXG4gICAgW1wiaHJcIiwgXCJoclwiXSxcbiAgICBbXCJodVwiLCBcImh1XCJdLFxuICAgIFtcImlkXCIsIFwiaWRcIl0sXG4gICAgW1wiaXRcIiwgXCJpdFwiXSxcbiAgICBbXCJqYVwiLCBcImphXCJdLFxuICAgIFtcImtvXCIsIFwia29cIl0sXG4gICAgW1wibHRcIiwgXCJsdFwiXSxcbiAgICBbXCJsdlwiLCBcImx2XCJdLFxuICAgIFtcIm5iXCIsIFwibmJcIl0sXG4gICAgW1wibmxcIiwgXCJubFwiXSxcbiAgICBbXCJwbFwiLCBcInBsXCJdLFxuICAgIFtcInB0LWJyXCIsIFwicHQtQlJcIl0sXG4gICAgW1wicHQtcHRcIiwgXCJwdC1QVFwiXSxcbiAgICBbXCJyb1wiLCBcInJvXCJdLFxuICAgIFtcInJ1XCIsIFwicnVcIl0sXG4gICAgW1wic2tcIiwgXCJza1wiXSxcbiAgICBbXCJzbFwiLCBcInNsXCJdLFxuICAgIFtcInNyXCIsIFwic3JcIl0sXG4gICAgW1wic3ZcIiwgXCJzdlwiXSxcbiAgICBbXCJ0aFwiLCBcInRoXCJdLFxuICAgIFtcInRyXCIsIFwidHJcIl0sXG4gICAgW1widWtcIiwgXCJ1a1wiXSxcbiAgICBbXCJ2aVwiLCBcInZpXCJdLFxuICAgIFtcInpoLWNuXCIsIFwiemgtQ05cIl0sXG4gICAgW1wiemgtaGtcIiwgXCJ6aC1IS1wiXSxcbiAgICBbXCJ6aC10d1wiLCBcInpoLVRXXCJdXG5dKTtcbi8vIHJ0bFxuZnVuY3Rpb24gZ2V0RWxlbWVudERpcihlbCkge1xuICAgIHJldHVybiBnZXRFbGVtZW50UHJvcChlbCwgXCJkaXJcIiwgXCJsdHJcIik7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UHJvcChlbCwgcHJvcCwgdmFsdWUpIHtcbiAgICBjb25zdCBjbG9zZXN0V2l0aFByb3AgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWwsIGBbJHtwcm9wfV1gKTtcbiAgICByZXR1cm4gY2xvc2VzdFdpdGhQcm9wID8gY2xvc2VzdFdpdGhQcm9wLmdldEF0dHJpYnV0ZShwcm9wKSA6IHZhbHVlO1xufVxuLy8gY3NzXG5jb25zdCBDU1NfVVRJTElUWSA9IHtcbiAgICBydGw6IFwiYXJjZ2lzLS1ydGxcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFwaSwgdHlwZSwgcGxhY2VzIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChhcGkgPT09IDQpIHtcbiAgICAgICAgY29uc3QgW2ludGxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9pbnRsXCJdKTtcbiAgICAgICAgY29uc3QgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMgPSBpbnRsLmNvbnZlcnROdW1iZXJGb3JtYXRUb0ludGxPcHRpb25zKHtcbiAgICAgICAgICAgIHBsYWNlcyxcbiAgICAgICAgICAgIHN0eWxlOiB0eXBlLFxuICAgICAgICAgICAgZGlnaXRTZXBhcmF0b3I6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnRsLmZvcm1hdE51bWJlcihudW1iZXIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMpLCB7IHN0eWxlOiB0eXBlIH0pKTtcbiAgICB9XG4gICAgY29uc3QgW2Rvam9OdW1iZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZG9qby9udW1iZXJcIl0pO1xuICAgIHJldHVybiBkb2pvTnVtYmVyLmZvcm1hdChudW1iZXIsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGxhY2VzLFxuICAgICAgICBwYXR0ZXJuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGF0dGVyblxuICAgIH0pO1xufVxuY29uc3QgY2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICAgIGNvbnN0IGxhbmcgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZztcbiAgICBjb25zdCBkYXlTaG9ydE1vbnRoWWVhciA9IHtcbiAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICB9O1xuICAgIGlmICghY2FjaGVbbGFuZ10pIHtcbiAgICAgICAgY2FjaGVbbGFuZ10gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZywgZGF5U2hvcnRNb250aFllYXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbbGFuZ10uZm9ybWF0KGRhdGUpO1xufVxuZnVuY3Rpb24gZm9ybWF0UGx1cmFsKGxhbmcsIHN0cmluZ09iaiwgbnVtYmVyKSB7XG4gICAgY29uc3Qgc2luZ2xlcyA9IFtcImlkXCIsIFwiamFcIiwgXCJrb1wiLCBcInRoXCIsIFwidmlcIiwgXCJ6aC1jblwiLCBcInpoLWhrXCIsIFwiemgtdHdcIl07XG4gICAgY29uc3QgbGlrZUVuZ2xpc2ggPSBbXG4gICAgICAgIFwiZW5cIixcbiAgICAgICAgXCJjYVwiLFxuICAgICAgICBcImRhXCIsXG4gICAgICAgIFwiZGVcIixcbiAgICAgICAgXCJlbFwiLFxuICAgICAgICBcImVzXCIsXG4gICAgICAgIFwiZXRcIixcbiAgICAgICAgXCJmaVwiLFxuICAgICAgICBcImhpXCIsXG4gICAgICAgIFwiaHVcIixcbiAgICAgICAgXCJpdFwiLFxuICAgICAgICBcIm5iXCIsXG4gICAgICAgIFwibmxcIixcbiAgICAgICAgXCJwdC1wdFwiLFxuICAgICAgICBcInN2XCIsXG4gICAgICAgIFwidHJcIlxuICAgIF07XG4gICAgY29uc3QgbG9jYWxlID0gbGFuZyAhPT0gbnVsbCAmJiBsYW5nICE9PSB2b2lkIDAgPyBsYW5nIDogXCJlblwiO1xuICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgb25lLCBvciBpdCBpcyBhIFwic2ltcGxlXCIgbGFuZ3VhZ2UsIHJldHVybiB0aGUgMSBzdHJpbmdcbiAgICBpZiAobnVtYmVyID09PSAxIHx8IHNpbmdsZXMuaW5jbHVkZXMobG9jYWxlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nT2JqLnNpbmdsZS5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIFwiMVwiKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIG51bWJlciBpcyBub3QgMSBhbmQgdGhlIGxhbmd1YWdlIHVzZXMgdGhlIHNhbWUgcGx1cmFsaXphdGlvbiBzdHJhdGVneSBhcyBlbmdsaXNoLFxuICAgIC8vIHJldHVybiB0aGUgbXVsdGlwbGUgc3RyaW5nXG4gICAgaWYgKG51bWJlciAhPT0gMSAmJiBsaWtlRW5nbGlzaC5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdPYmoubXVsdGlwbGUucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBgJHtudW1iZXJ9YCk7XG4gICAgfVxuICAgIC8vIGlmIG5vbmUgb2YgdGhlIGFib3ZlIHdvcmtlZCwgcmV0dXJuIHRoZSBcInVua25vd25cIiBzdHJpbmdcbiAgICByZXR1cm4gc3RyaW5nT2JqLnVua25vd24ucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBgJHtudW1iZXJ9YCk7XG59XG5cbmV4cG9ydCB7IENTU19VVElMSVRZIGFzIEMsIGZvcm1hdERhdGUgYXMgYSwgZm9ybWF0UGx1cmFsIGFzIGIsIGZvcm1hdE51bWJlciBhcyBmLCBnZXRFbGVtZW50RGlyIGFzIGcsIGxhbmd1YWdlTWFwIGFzIGwgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgeyBsIGFzIGxhbmd1YWdlTWFwIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL3N0ZW5jaWwtdHJpY2tzL2ltcGxlbWVudGluZy1pbnRlcm5hdGlvbmFsaXNhdGlvbi1pMThuLXdpdGgtc3RlbmNpbC01ZTY1NTk1NTQxMTdcbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gICAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgMiBsZXR0ZXIgY29kZWQgbGFuZ3VhZ2VcbiAgICAgICAgICAgIC8vIGUuZy4gaXQtQ0ggdnMgaXRcbiAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gICAgfSk7XG59XG5jb25zdCBzdHJpbmdDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICAgIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nQ2FjaGVbaWRdO1xufVxuLyoqXG4gKiBHZXQgc3RyaW5ncyBhbmQgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIDIgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGUgZmlyc3Qgb25lIHJldHVybnMgYSBjb2RlIHRoYXQncyBhbHNvIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlIGZpbGUuXG4gKiBUaGUgc2Vjb25kIG9uZSByZXR1cm5zIGEgY29kZSB3aGVyZSB0aGVyZSBpcyBzdXBwb3J0IGZvciB0aGUgZmlyc3QgMiBsZXR0ZXJzIG9mIHRoZSBjb2RlIGFzIHBhcnQgb2YgYSBsYW5ndWFnZSBmaWxlLFxuICogYnV0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCA0IGxldHRlciBjb2RlIGZyb20gdGhlIHBhZ2UuXG4gKiBFLmcuIEZvciBcIml0LWNoXCIgaXQgd2lsbCByZXR1cm4gXCJpdFwiIGFzIHRoZSBmaXJzdCBsYW5ndWFnZSBjb2RlIGFuZCBcIml0LWNoXCIgYXMgdGhlIHNlY29uZC5cbiAqIFRoZSBzZWNvbmQgb25lIGlzIHJlcXVpcmVkIGZvciBlc3JpLmludGwuc2V0TG9jYWxlKCkgdG8gZ2V0IHRoZSBjb3JyZWN0IGZvcm1hdHRpbmcuXG4gKlxuICogSWYgYSB0YWdOYW1lIGlzIHByb3ZpZGVkIGl0IHdpbGwgb3ZlcndpdGUgdGhlIGVsZW1lbnQncyB0YWdOYW1lXG4gKlxuICogIEByZXR1cm4gWyBzdHJpbmdzLCBmaXJzdCBsYW5ndWFnZSBjb2RlLCBzZWNvbmQgbGFuZ3VhZ2UgY29kZV1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyhlbGVtZW50LCB0YWdOYW1lKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2VJbnRsID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KTtcbiAgICBsZXQgc3RyaW5ncztcbiAgICB0cnkge1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyaW5ncywgY29tcG9uZW50TGFuZ3VhZ2UsIGNvbXBvbmVudExhbmd1YWdlSW50bF07XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSBhcyBhLCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxlLTA1MGI2ZGI5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==