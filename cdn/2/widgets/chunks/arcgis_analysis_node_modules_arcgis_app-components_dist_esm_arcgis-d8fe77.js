"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-d8fe77"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-filter_4.entry.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-filter_4.entry.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_filter: () => (/* binding */ ArcgisFilter),
/* harmony export */   arcgis_filter_condition: () => (/* binding */ ArcgisFilterCondition),
/* harmony export */   arcgis_filter_expression: () => (/* binding */ ArcgisFilterExpression),
/* harmony export */   arcgis_filter_unique_list: () => (/* binding */ ArcgisFilterUniqueList)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */









const CSS$3 = {
    panel: "panel",
    hook: "hook",
    removeFilter: "remove-filter",
    matchExpressionMsg: "match-expression-msg",
    matchExpressionDropdown: "match-expression-dropdown",
    logicalOperator: "match-type"
};

var logicalOperators;
(function (logicalOperators) {
    logicalOperators["AND"] = "and";
    logicalOperators["OR"] = "or";
})(logicalOperators || (logicalOperators = {}));
var simpleFieldTypes;
(function (simpleFieldTypes) {
    simpleFieldTypes["NUMBER"] = "number";
    simpleFieldTypes["STRING"] = "string";
    simpleFieldTypes["DATE"] = "date";
    simpleFieldTypes["DATE_ONLY"] = "date-only";
    simpleFieldTypes["OID"] = "oid";
    simpleFieldTypes["GUID"] = "guid";
    simpleFieldTypes["DOMAIN"] = "domain";
})(simpleFieldTypes || (simpleFieldTypes = {}));
var status;
(function (status) {
    status["MISSING"] = "missing";
    status["IN_PROGRESS"] = "inProgress";
    status["SUCCESS"] = "success";
    status["FAILED"] = "failed";
})(status || (status = {}));
var timeUnits;
(function (timeUnits) {
    timeUnits["MINUTE"] = "minute";
    timeUnits["HOUR"] = "hour";
    timeUnits["DAY"] = "day";
    timeUnits["WEEK"] = "week";
    timeUnits["MONTH"] = "month";
    timeUnits["YEAR"] = "year";
})(timeUnits || (timeUnits = {}));
var timeRange;
(function (timeRange) {
    timeRange[timeRange["MINUTE"] = 60000] = "MINUTE";
    timeRange[timeRange["HOUR"] = 3600000] = "HOUR";
    timeRange[timeRange["DAY"] = 86400000] = "DAY";
    timeRange[timeRange["WEEK"] = 604800000] = "WEEK";
    timeRange[timeRange["MONTH"] = 2592000000] = "MONTH";
    timeRange[timeRange["YEAR"] = 31104000000] = "YEAR";
})(timeRange || (timeRange = {}));
var scales;
(function (scales) {
    scales["SMALL"] = "s";
    scales["MEDIUM"] = "m";
    scales["LARGE"] = "l";
})(scales || (scales = {}));
/**
 * Returns true if the value is defined
 * @param value - value to check
 */
function isDefined(value) {
    return value !== undefined && value !== null;
}
function isEffectEmpty(featureEffect) {
    if (!featureEffect || !featureEffect.filter) {
        return true;
    }
    const checkProps = ["geometry", "objectIds", "timeExtent", "where"];
    return !checkProps.some((prop) => featureEffect.filter.hasOwnProperty(prop) && !!featureEffect.filter[prop]);
}
function checkConfig(props) {
    var _a, _b;
    const { layer, mapImageSublayer } = props;
    const url = layer.url;
    props.supportsStandardizedQuery =
        "version" in layer && layer.version >= 10.2 && !!((_b = (_a = layer.capabilities) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.supportsStandardizedQueriesOnly);
    props.supportedSqlParserVersion =
        layer.type === "feature" &&
            props.supportsStandardizedQuery &&
            layer.sourceJSON.sqlParserVersion &&
            layer.sourceJSON.sqlParserVersion !== "ES_10.6.1";
    if (!url || mapImageSublayer) {
        props.isHosted = false;
        return;
    }
    // hosted feature service: http://services.arcgis.com/f7ee40282cbc40998572834591021976/arcgis/rest/services/StateCapitals/FeatureServer
    // new amazon hosted feature service: http://features.arcgis.com/e2ea3c31dd80478689ce70c4fb3380c5/arcgis/rest/services/santaclara_fs/FeatureServer
    // hosted tiled service: https://tilesdevext.arcgis.com/tiles/fa019fbbfbb845d08cc9f0acde6dd8af/arcgis/rest/services/States/MapServer
    // uploaded KML service: http://www.arcgis.com/sharing/content/items/ecddddaf6b174d7ca94816ac397d9b48/data
    // secure service: http://www.arcgis.com/sharing/rest/services/aee2a3d9d15f406cb21576d92ea1316e/MapServer
    const arcgis = ".arcgis.com/", services = "//services", tiles = "//tiles", features = "//features", locationservices = "//locationservices", velocityUs = "//us-iot", velocityEu = "//eu-iot";
    //sharing = (new dojo._Url(esriGeowConfig.restBaseUrl)).authority,
    //isSingleTenant = false; //(false === esriGeowConfig.isMultiTenant);
    // CR #238,732 - only consider locally hosted if the restBaseUrl is on same domain as url
    // and esriGeowConfig.self.supportsHostedServices flag is enabled
    const isAGOL = url.indexOf(arcgis) !== -1, isHostedServer = url.indexOf(services) !== -1 ||
        url.indexOf(tiles) !== -1 ||
        url.indexOf(features) !== -1 ||
        url.indexOf(locationservices) !== -1 ||
        url.indexOf(velocityUs) !== -1 ||
        url.indexOf(velocityEu) !== -1, isLocallyHosted = false; //((isDefined(esriGeowConfig.self) && esriGeowConfig.self.supportsHostedServices) && (url.indexOf(sharing) !== -1 && !isSingleTenant));
    //isProxyService = !isHostedServer && arcgis; // if the service requires non-AGOL credentials
    props.isHosted = (isAGOL && isHostedServer) || (!isAGOL && isLocallyHosted);
}
function fixUIDs(expressions) {
    if (!expressions || !expressions.length) {
        return expressions;
    }
    return expressions.map((expression, idx) => {
        if (expression.uid === `expression-${idx}`) {
            // no change to uid
            return Object.assign(Object.assign({}, expression), { conditions: expression.conditions.map((condition, idx2) => {
                    const newUid = `condition-${idx}-${idx2}`;
                    if (condition.uid === newUid) {
                        return condition;
                    }
                    else {
                        return Object.assign(Object.assign({}, condition), { uid: newUid });
                    }
                }) });
        }
        else {
            return Object.assign(Object.assign({}, expression), { uid: `expression-${idx}`, expressionIndex: idx, conditions: expression.conditions.map((condition, idx2) => {
                    const newUid = `condition-${idx}-${idx2}`;
                    if (condition.uid === newUid) {
                        return condition;
                    }
                    else {
                        return Object.assign(Object.assign({}, condition), { uid: newUid });
                    }
                }) });
        }
    });
}

function utcToDatePicker(value, timeZone) {
    // date is in UTC
    // we need a map timezone
    let str;
    if (!timeZone || timeZone === "system") {
        const diff = new Date().getTimezoneOffset();
        str = new Date(value - diff * 60000).toISOString();
    }
    else if (timeZone === "unknown") {
        str = new Date(value).toISOString();
    }
    else {
        const diff = new Date().getTimezoneOffset();
        const mapDateStr = new Date(value).toLocaleString("en-US", { timeZone });
        str = new Date(new Date(mapDateStr).getTime() - diff * 60000).toISOString();
    }
    //console.log("utcToDatePicker", value, " - ", new Date(value).toISOString(), " -> ", str);
    return str;
}
function datePickerToUTC(date, timeZone) {
    // date is in map timezone
    // we need a UTC UNIX timestamp
    let value;
    if (!timeZone || timeZone === "system") {
        // add difference between local time and UTC
        value = date.getTime() + date.getTimezoneOffset() * 60000;
    }
    else if (timeZone === "unknown") {
        // take what you get
        value = date.getTime();
    }
    else {
        // add difference between map time and UTC
        const diff = new Date(date.toLocaleString("en-US", { timeZone: "utc" })).getTime() -
            new Date(date.toLocaleString("en-US", { timeZone })).getTime();
        value = date.getTime() + diff;
    }
    //console.log("datePickerToUTC", date.toISOString(), " -> ", new Date(value).toISOString());
    return value;
}
function mapTZToUTC(value, timeZone) {
    if (!value) {
        return value;
    }
    // value is in map timezone
    // we need a UTC timestamp
    let newValue;
    if (!timeZone || timeZone === "system") {
        // add difference between local time and UTC
        const date = new Date();
        newValue = value + date.getTimezoneOffset() * 60000;
    }
    else if (timeZone === "unknown") {
        // take what you get
        newValue = value;
    }
    else {
        // add difference between map time and UTC
        const date = new Date();
        const diff = new Date(date.toLocaleString("en-US", { timeZone: "utc" })).getTime() -
            new Date(date.toLocaleString("en-US", { timeZone })).getTime();
        newValue = value + diff;
    }
    //console.log("mapTZToUTC", value, " - ", new Date(value).toISOString(), " - ", new Date(newValue).toISOString());
    return newValue;
}
function getDateDisplayString(value, timeZone, intl, dateFormat) {
    let str;
    if (timeZone === "unknown") {
        str = intl.formatDate(value, Object.assign(Object.assign({}, intl.convertDateFormatToIntlOptions(dateFormat || "short-date-short-time")), { timeZone: "utc", timeZoneName: "shortOffset" }));
    }
    else {
        // known issues with formatting it-CH
        str = intl.formatDate(value, Object.assign(Object.assign({}, intl.convertDateFormatToIntlOptions(dateFormat || "short-date-short-time")), { timeZone }));
    }
    //console.log("getDateDisplayString", value, " - ", new Date(value).toISOString(), " -> ", str);
    return str;
}

//import Domain from "esri/layers/support/Domain";
async function collectFieldDomains(props) {
    // we do not support subTypes ...
    const { layer, fields } = props;
    if (layer.type !== "feature") {
        return;
    }
    const typeIdField = layer.typeIdField;
    const types = layer.types;
    fields.forEach(async (featureField) => {
        const fieldName = featureField.layerField.name;
        const fieldDomain = featureField.layerField.domain;
        const filterField = getFieldInfo(fieldName, props);
        if (!filterField) {
            // maybe geometry field
            return;
        }
        if (typeIdField && types) {
            // layer has types
            if (typeIdField === fieldName) {
                // this is the field with the types
                filterField.fieldDomains = types.map((type) => {
                    // fake coded Values
                    return {
                        code: type.id,
                        name: type.name
                    };
                });
                getSimpleFieldType(props, filterField);
            }
            else {
                // field does not have types; look farther inside the types
                filterField.fieldDomains = [];
                types.forEach((type) => {
                    var _a, _b;
                    if (!type.domains || !type.domains[fieldName] || type.domains[fieldName].type === "inherited") {
                        const domain /*Domain*/ = fieldDomain;
                        if (domain === null || domain === void 0 ? void 0 : domain.codedValues) {
                            domain.codedValues.forEach(async (codedValue) => {
                                let found = false;
                                filterField.fieldDomains.forEach((codedVal) => {
                                    if (codedVal.code === codedValue.code) {
                                        found = true;
                                        if (`, ${codedVal.name},`.indexOf(`, ${codedValue.name},`) === -1) {
                                            codedVal.name += `, ${codedValue.name}`;
                                        }
                                    }
                                });
                                if (!found) {
                                    const [esriLang] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/core/lang"]);
                                    filterField.fieldDomains.push(esriLang.clone(codedValue));
                                }
                            });
                        }
                    }
                    else if ((_b = (_a = type.domains) === null || _a === void 0 ? void 0 : _a[fieldName]) === null || _b === void 0 ? void 0 : _b.codedValues) {
                        type.domains[fieldName].codedValues.forEach(async (codedValue) => {
                            let found = false;
                            filterField.fieldDomains.forEach((codedVal) => {
                                if (codedVal.code === codedValue.code) {
                                    found = true;
                                    if (`, ${codedVal.name},`.indexOf(`, ${codedValue.name},`) === -1) {
                                        codedVal.name += `, ${codedValue.name}`;
                                    }
                                }
                            });
                            if (!found) {
                                const [esriLang] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/core/lang"]);
                                filterField.fieldDomains.push(esriLang.clone(codedValue));
                            }
                        });
                        //filterField.fieldDomains = filterField.fieldDomains.concat(type.domains[field.name].codedValues);
                        //} else {
                        /* ... wrong, it's not the typeIdField ...
                          // fake coded values
                          filterField.fieldDomains.push({
                            code: type.id,
                            name: type.name
                          });
                        */
                        // field has no domains
                        // delete filterField.fieldDomains;
                    }
                });
            }
            if (!hasFieldDomains(filterField) && (fieldDomain === null || fieldDomain === void 0 ? void 0 : fieldDomain.codedValues)) {
                const [esriLang] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/core/lang"]);
                filterField.fieldDomains = esriLang.clone(fieldDomain.codedValues);
            }
        }
        else if (fieldDomain === null || fieldDomain === void 0 ? void 0 : fieldDomain.codedValues) {
            // domains directly on the layer field
            filterField.fieldDomains = fieldDomain.codedValues;
        }
        // update in case it has changed
        getSimpleFieldType(props, filterField);
    });
}
function getDecodedValue(value, filterField) {
    const codedValues = filterField.fieldDomains;
    if (codedValues) {
        let label = "";
        for (let i = 0; i < codedValues.length; i++) {
            const codedValue = codedValues[i];
            if (codedValue.code == value) {
                label += (label.length ? " | " : "") + codedValue.name;
            }
        }
        return label;
    }
    // did not find it
    return value;
}
function hasFieldDomains(filterField) {
    var _a;
    return (_a = filterField.fieldDomains) === null || _a === void 0 ? void 0 : _a.length;
}

async function buildFilterFields(props) {
    const { layer, mapImageSublayer, featureReduction } = props;
    if (!layer) {
        return;
    }
    if (featureReduction) {
        return buildFeatureReductionFields(props);
    }
    let layerFields = layer.fields;
    // https://demographics9dev.arcgis.com/arcgis/rest/services/USA_Demographics_and_Boundaries_2019/MapServer
    if (mapImageSublayer &&
        mapImageSublayer.layer.portalItem &&
        mapImageSublayer.layer.url.indexOf("https://demographics") > -1 &&
        mapImageSublayer.layer.url.indexOf(".arcgis.com") > -1) {
        const portalItem = mapImageSublayer.layer.portalItem;
        try {
            const response = await portalItem.fetchData();
            if (response === null || response === void 0 ? void 0 : response.thematicGroup) {
                const fieldNames = response.thematicGroup.fieldNames;
                if (fieldNames) {
                    layerFields = layerFields.filter((layerField) => fieldNames.indexOf(layerField.name) > -1);
                }
            }
            return buildFeatureFilterFieldsAfterThematicGroupCheck(props, layerFields);
        }
        catch (error) {
            // assume there is none
            return buildFeatureFilterFieldsAfterThematicGroupCheck(props, layerFields);
        }
    }
    else {
        return buildFeatureFilterFieldsAfterThematicGroupCheck(props, layerFields);
    }
}
function buildFeatureFilterFieldsAfterThematicGroupCheck(props, layerFields) {
    if (!props.fields || !props.fields.length) {
        props.fields = [];
        props.stringFieldsCount = 0;
        props.dateFieldsCount = 0;
        props.numberFieldsCount = 0;
        if (!props.supportsStandardizedQuery) {
            // NOTE: client side filter effect only supports sql92 and needs the timestamp in the query
            // therfore we disable data fields for services without standardizedQuery support
            layerFields = layerFields.filter((layerField) => ["date", "date-only"].indexOf(layerField.type) === -1);
        }
        let fieldInfos = [];
        if (props.layer.type !== "subtype-group") {
            const { popupTemplate } = props.layer;
            fieldInfos = popupTemplate ? popupTemplate.fieldInfos : [];
        }
        layerFields.forEach((layerField) => {
            const list = fieldInfos
                ? fieldInfos.filter((fieldInfo) => fieldInfo.fieldName === layerField.name)
                : null;
            const label = (list === null || list === void 0 ? void 0 : list.length) ? list[0].label : null;
            const filterField = {
                layerField: layerField,
                statisticsStatus: status.MISSING,
                histogramStatus: status.MISSING,
                uniqueValuesStatus: status.MISSING,
                partialUniqueValues: false,
                label: label || layerField.alias || layerField.name
            };
            getSimpleFieldType(props, filterField);
            if (filterField.simpleFieldType) {
                props.fields.push(filterField);
            } // else can't use field for filter
        });
        collectFieldDomains(props);
    }
}
async function buildFeatureReductionFields(props) {
    var _a;
    const { layer, view } = props;
    if (layer.type === "imagery" || layer.type === "subtype-group") {
        return;
    }
    if (!((_a = props.fields) === null || _a === void 0 ? void 0 : _a.length)) {
        props.fields = [];
        props.stringFieldsCount = 0;
        props.dateFieldsCount = 0;
        props.numberFieldsCount = 1;
        let count = 5000;
        let avg = 10;
        let featureCount = 0;
        try {
            featureCount = await (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_4__.g)(layer, view);
            count = featureCount ? Math.min(Math.max(10, Math.ceil(featureCount / 4)), 5000) : 5000;
            avg = featureCount && featureCount >= 1000 ? 100 : 10;
        }
        catch (_b) { }
        const [Field] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/layers/support/Field"]);
        const featureReduction = layer.featureReduction;
        props.fields = [];
        featureReduction.fields.forEach((aggregateField) => {
            const isCount = aggregateField.statisticType === "count";
            const layerField = aggregateField.onStatisticField &&
                layer.fields.find((field) => field.name === aggregateField.onStatisticField);
            if ((!aggregateField.onStatisticField && isCount) || layerField) {
                const filterField = {
                    layerField: new Field({
                        name: aggregateField.name,
                        alias: aggregateField.alias || aggregateField.name,
                        type: (layerField === null || layerField === void 0 ? void 0 : layerField.type) || "integer"
                    }),
                    statisticsStatus: isCount ? status.SUCCESS : status.MISSING,
                    statistics: isCount ? { min: 1, max: count, avg } : undefined,
                    histogramStatus: isCount ? status.FAILED : status.MISSING,
                    uniqueValuesStatus: status.MISSING,
                    partialUniqueValues: false,
                    label: aggregateField.alias || aggregateField.name
                    //simpleFieldType: ...
                };
                getSimpleFieldType(props, filterField);
                props.fields.push(filterField);
            }
        });
    }
}
function getFieldInfo(fieldName, props) {
    const { fields } = props;
    for (let i = 0; i < fields.length; i++) {
        const filterField = fields[i];
        if (filterField.layerField.name === fieldName) {
            return filterField;
        }
    }
    return undefined;
}
function getDefaultField(props) {
    const { fields, defaultFieldName } = props;
    if (defaultFieldName) {
        const defaultField = fields.find((field) => field.layerField.name === defaultFieldName);
        if (defaultField) {
            return defaultField;
        }
    }
    let firstNumberField;
    for (let i = 0; i < fields.length; i++) {
        const field = fields[i];
        if (field.simpleFieldType &&
            [simpleFieldTypes.OID, simpleFieldTypes.GUID, simpleFieldTypes.DATE].indexOf(field.simpleFieldType) === -1) {
            if (field.simpleFieldType === simpleFieldTypes.NUMBER && !firstNumberField) {
                firstNumberField = field;
            }
            else {
                // string field
                return field;
            }
        }
    }
    // we didn't find a string field
    if (firstNumberField) {
        return firstNumberField;
    }
    return fields[0];
}
function getDefaultValues(props, filterField, operator) {
    var _a;
    const { strings } = props;
    const result = {};
    const statistics = filterField.statistics;
    if (!statistics) {
        if (filterField.simpleFieldType === simpleFieldTypes.STRING &&
            filterField.uniqueValuesStatus === status.SUCCESS &&
            ((_a = filterField.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length) &&
            [strings.operators.stringOperatorIs, strings.operators.stringOperatorIsNot].indexOf(operator) > -1) {
            result.value = filterField.uniqueValueInfos[0].value;
        }
        return result;
    }
    if (isInTheLastOperator(props, operator)) {
        const now = new Date().getTime();
        const range = Math.abs(now - statistics.avg);
        if (range > 2 * timeRange.YEAR) {
            result.value = Math.round(range / timeRange.YEAR);
            result.unit = timeUnits.YEAR;
        }
        else {
            if (range > 2 * timeRange.MONTH) {
                result.value = Math.round(range / timeRange.MONTH);
                result.unit = timeUnits.MONTH;
            }
            else {
                if (range > 2 * timeRange.WEEK) {
                    result.value = Math.round(range / timeRange.WEEK);
                    result.unit = timeUnits.WEEK;
                }
                else {
                    if (range > 2 * timeRange.DAY) {
                        result.value = Math.round(range / timeRange.DAY);
                        result.unit = timeUnits.DAY;
                    }
                    else {
                        if (range > 2 * timeRange.HOUR) {
                            result.value = Math.round(range / timeRange.HOUR);
                            result.unit = timeUnits.HOUR;
                        }
                        else {
                            result.value = Math.round(range / timeRange.MINUTE);
                            result.unit = timeUnits.MINUTE;
                        }
                    }
                }
            }
        }
    }
    else if (isBetweenOperator(props, operator)) {
        result.value = fieldTypeRound(statistics.avg, props, filterField);
        result.value2 = fieldTypeRound(statistics.max, props, filterField);
    }
    else {
        result.value = fieldTypeRound(statistics.avg, props, filterField);
    }
    return result;
}
function getSignificantDigits(props, filterField) {
    const { layer } = props;
    let significantDigits = 2;
    const popupTemplate = layer.type !== "subtype-group" && layer.popupTemplate;
    if (popupTemplate) {
        const popFieldInfos = popupTemplate.fieldInfos.filter((fieldInfo) => fieldInfo.fieldName === filterField.layerField.name);
        if (popFieldInfos === null || popFieldInfos === void 0 ? void 0 : popFieldInfos.length) {
            const popFieldInfo = popFieldInfos[0];
            if (popFieldInfo.format && isDefined(popFieldInfo.format.places)) {
                significantDigits = popFieldInfo.format.places;
            }
        }
    }
    return significantDigits;
}
function roundToSignificantDigits(value, props, filterField) {
    const significantDigits = getSignificantDigits(props, filterField);
    const factor = Math.pow(10, significantDigits);
    return isDefined(value) && Math.round(value * factor) / factor;
}
function fieldTypeRound(value, props, filterField) {
    return (isDefined(value) &&
        (isIntegerType(filterField) ? Math.round(value) : roundToSignificantDigits(value, props, filterField)));
}
function getSimpleFieldType(props, featureFilterField) {
    switch (featureFilterField.layerField.type) {
        case "string":
            featureFilterField.simpleFieldType = simpleFieldTypes.STRING;
            props.stringFieldsCount++;
            break;
        case "date":
            if (hasFieldDomains(featureFilterField)) {
                featureFilterField.simpleFieldType = simpleFieldTypes.STRING;
                props.stringFieldsCount++;
            }
            else {
                featureFilterField.simpleFieldType = simpleFieldTypes.DATE;
                props.dateFieldsCount++;
            }
            break;
        case "date-only":
            featureFilterField.simpleFieldType = simpleFieldTypes.DATE_ONLY;
            break;
        case "oid":
            featureFilterField.simpleFieldType = simpleFieldTypes.OID;
            break;
        case "guid":
            featureFilterField.simpleFieldType = simpleFieldTypes.GUID;
            break;
        case "small-integer":
        case "big-integer":
        case "integer":
        case "single":
        case "double":
        case "long":
            if (hasFieldDomains(featureFilterField)) {
                featureFilterField.simpleFieldType = simpleFieldTypes.STRING;
                props.stringFieldsCount++;
            }
            else {
                featureFilterField.simpleFieldType = simpleFieldTypes.NUMBER;
                props.numberFieldsCount++;
            }
            break;
    }
}
function isNumberType(featureFilterField) {
    return (["small-integer", "big-integer", "integer", "single", "double", "long"].indexOf(featureFilterField.layerField.type) > -1);
}
function isIntegerType(featureFilterField) {
    return ["small-integer", "big-integer", "integer", "long"].indexOf(featureFilterField.layerField.type) > -1;
}
function isFloatType(featureFilterField) {
    return ["single", "double"].indexOf(featureFilterField.layerField.type) > -1;
}
function isDateType(featureFilterField) {
    return ["date"].indexOf(featureFilterField.layerField.type) > -1;
}
function isDateOnlyType(featureFilterField) {
    return ["date-only"].indexOf(featureFilterField.layerField.type) > -1;
}
function supportsHistogram(fieldName, operator, props) {
    const { strings } = props;
    const filterField = getFieldInfo(fieldName, props);
    // TODO - also check field value type ?
    if (filterField &&
        filterField.simpleFieldType &&
        filterField.statisticsStatus !== "failed" &&
        (([simpleFieldTypes.NUMBER, simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) > -1 &&
            [
                strings.operators.numberOperatorIs,
                strings.operators.dateOperatorIsOn,
                // don't remember the reason we hid isNotOn for date fields in the past, so enabling it again
                strings.operators.dateOperatorIsNotOn,
                strings.operators.numberOperatorIsNot,
                strings.operators.numberOperatorIsLessThan,
                strings.operators.dateOperatorIsBefore,
                strings.operators.numberOperatorIsGreaterThan,
                strings.operators.dateOperatorIsAfter,
                strings.operators.numberOperatorIsAtMost,
                strings.operators.numberOperatorIsAtLeast,
                strings.operators.numberOperatorIsBetween,
                strings.operators.dateOperatorIsBetween,
                strings.operators.numberOperatorIsNotBetween,
                strings.operators.dateOperatorIsNotBetween
            ].indexOf(operator) > -1))) {
        return true;
    }
    return false;
}
function createIndexes(props) {
    const { layer, expressions, strings } = props;
    if (layer.type !== "feature") {
        return;
    }
    const { portalItem, sourceJSON } = layer;
    if (!portalItem) {
        return;
    }
    const { typeKeywords, itemControl, portal } = portalItem;
    const isPortal = portal.isPortal;
    const isHosted = (typeKeywords === null || typeKeywords === void 0 ? void 0 : typeKeywords.indexOf("Hosted Service")) > -1;
    const isOnlineLocationTrackingService = !isPortal && (typeKeywords === null || typeKeywords === void 0 ? void 0 : typeKeywords.indexOf("Location Tracking Service")) > -1;
    if (!isHosted || isOnlineLocationTrackingService) {
        return;
    }
    if (portal.user && itemControl && ["admin", "update"].indexOf(itemControl) > -1) {
        const i18nOps = strings.operators;
        const invalidOperators = [
            i18nOps.stringOperatorEndsWith,
            i18nOps.stringOperatorContains,
            i18nOps.stringOperatorDoesNotContain
        ];
        const fieldNames = [];
        const addFieldToList = (condition) => {
            const fieldName = condition.fieldName;
            if (!fieldName) {
                return;
            }
            const filterField = getFieldInfo(fieldName, props);
            const isValidField = !(((filterField === null || filterField === void 0 ? void 0 : filterField.simpleFieldType) === simpleFieldTypes.STRING ||
                (filterField === null || filterField === void 0 ? void 0 : filterField.simpleFieldType) === simpleFieldTypes.GUID) &&
                (filterField.layerField.length > 4000 || invalidOperators.indexOf(condition.operator) > -1));
            if (isValidField && fieldNames.indexOf(fieldName) === -1) {
                fieldNames.push(fieldName);
            }
        };
        expressions === null || expressions === void 0 ? void 0 : expressions.forEach((expression) => expression.conditions.forEach((condition) => addFieldToList(condition)));
        const json = {
            indexes: []
        };
        sourceJSON.indexes = sourceJSON.indexes || [];
        fieldNames.forEach((fieldName) => {
            if (!sourceJSON.indexes.some((index) => index.fields === fieldName)) {
                // index doesn't exist yet
                json.indexes.push({
                    name: `${fieldName}_Index`,
                    fields: fieldName,
                    isUnique: false,
                    isAscending: true,
                    description: `${fieldName}_Index`
                });
            }
        });
        if (json.indexes.length) {
            executeCreateIndexes(json, props);
        }
    }
}
async function executeCreateIndexes(json, props) {
    var _a, _b;
    const { layer, parentServiceUrl } = props;
    if (layer.type !== "feature") {
        return;
    }
    const { portalItem, sourceJSON } = layer;
    const { typeKeywords, portal } = portalItem;
    const isView = typeKeywords.includes("View Service");
    const [IdentityManager, esriRequest] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/identity/IdentityManager", "esri/request"]);
    if (isView && !parentServiceUrl) {
        // need to use the original service url
        var relatedUrl = `${portal.restUrl}/content/items/${portalItem.id}/relatedItems?relationshipType=Service2Service&direction=reverse`;
        const credential = await IdentityManager.getCredential(portal.restUrl, { prompt: false });
        const result = await esriRequest(relatedUrl, { query: { f: "json", token: credential.token } });
        if ((_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.total) {
            result.data.relatedItems
                .filter((item) => item.typeKeywords.includes("Hosted Service"))
                .forEach((item) => {
                props.parentServiceUrl = item.url;
                executeCreateIndexes(json, props);
            });
        }
        return;
    }
    const adminUrl = (parentServiceUrl || layer.url).replace("/rest/services", "/rest/admin/services");
    const url = `${adminUrl}/${layer.layerId}/addToDefinition`;
    const credential = await IdentityManager.getCredential(layer.url, { prompt: false });
    const content = {
        f: "json",
        addToDefinition: JSON.stringify(json),
        async: !portal.isPortal,
        token: credential.token
    };
    const result = await esriRequest(url, {
        query: content,
        method: "post"
    });
    if (portal.isPortal) {
        sourceJSON.indexes = sourceJSON.indexes || [];
        sourceJSON.indexes = sourceJSON.indexes.concat(json.indexes);
    }
    else {
        try {
            await pollForStatus((_b = result === null || result === void 0 ? void 0 : result.data) === null || _b === void 0 ? void 0 : _b.statusURL, {
                f: "json",
                token: credential.token
            }, esriRequest);
            sourceJSON.indexes = sourceJSON.indexes || [];
            sourceJSON.indexes = sourceJSON.indexes.concat(json.indexes);
        }
        catch (e) {
            // not a big problem if it didn't work
        }
    }
}
const pollForStatus = async (url, params, esriRequest) => {
    var _a;
    if (!url) {
        throw new Error("pollForStatus: no status URL");
    }
    const pendingStatuses = ["processing", "partial", "Pending", "InProgress"];
    const successStatuses = ["completed", "Completed"];
    // Keep polling status until either completed or failed
    try {
        // Do failures report as success (status 200)? May need to manually throw error on status check failure
        const statusResponse = await esriRequest(url, { query: params });
        const status = (_a = statusResponse === null || statusResponse === void 0 ? void 0 : statusResponse.data) === null || _a === void 0 ? void 0 : _a.status;
        if (pendingStatuses.includes(status)) {
            await (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_5__.t)(500);
            return pollForStatus(url, params, esriRequest);
        }
        else if (successStatuses.includes(status)) {
            return statusResponse;
        }
        else {
            throw statusResponse;
        }
    }
    catch (e) {
        console.error(e);
        throw e;
    }
};

function buildOperatorsList(props) {
    const { layer, featureReduction, strings } = props;
    const isStreamLayer = layer.declaredClass === "esri.layers.StreamLayer";
    const isImageryLayer = layer.declaredClass === "esri.layers.ImageryLayer";
    if (!props.operators) {
        props.operators = {};
        props.operators[simpleFieldTypes.STRING] = [];
        props.operators[simpleFieldTypes.STRING].push({
            name: strings.operators.stringOperatorIs
        });
        props.operators[simpleFieldTypes.STRING].push({
            name: strings.operators.stringOperatorIsNot
        });
        if (!isStreamLayer && !isImageryLayer) {
            props.operators[simpleFieldTypes.STRING].push({
                name: strings.operators.stringOperatorIncludes
            });
            props.operators[simpleFieldTypes.STRING].push({
                name: strings.operators.stringOperatorExcludes
            });
        }
        props.operators[simpleFieldTypes.STRING].push({
            name: strings.operators.stringOperatorStartsWith
        });
        props.operators[simpleFieldTypes.STRING].push({
            name: strings.operators.stringOperatorEndsWith
        });
        props.operators[simpleFieldTypes.STRING].push({
            name: strings.operators.stringOperatorContains
        });
        props.operators[simpleFieldTypes.STRING].push({
            name: strings.operators.stringOperatorDoesNotContain
        });
        props.operators[simpleFieldTypes.STRING].push({
            name: strings.operators.stringOperatorIsBlank
        });
        props.operators[simpleFieldTypes.STRING].push({
            name: strings.operators.stringOperatorIsNotBlank
        });
        props.operators[simpleFieldTypes.STRING].push({
            name: strings.operators.stringOperatorIsEmpty
        });
        props.operators[simpleFieldTypes.STRING].push({
            name: strings.operators.stringOperatorIsNotEmpty
        });
        props.operators[simpleFieldTypes.DATE] = [];
        props.operators[simpleFieldTypes.DATE].push({
            name: strings.operators.dateOperatorIsOn
        });
        props.operators[simpleFieldTypes.DATE].push({
            name: strings.operators.dateOperatorIsNotOn
        });
        /* if (!isStreamLayer) {
          props.operators[simpleFieldTypes.DATE].push({
            name: strings.operators.numberOperatorIncludes
          });
          props.operators[simpleFieldTypes.DATE].push({
            name: strings.operators.numberOperatorExcludes
          });
        } */
        props.operators[simpleFieldTypes.DATE].push({
            name: strings.operators.dateOperatorIsBefore
        });
        props.operators[simpleFieldTypes.DATE].push({
            name: strings.operators.dateOperatorIsAfter
        });
        if (props.isHosted || props.supportedSqlParserVersion) {
            // || layer.version >= 10.21) {
            // We don't know if CURRENT_TIMESTAMP is in UTC for other databases.
            props.operators[simpleFieldTypes.DATE].push({
                name: strings.operators.dateOperatorInTheLast
            });
            props.operators[simpleFieldTypes.DATE].push({
                name: strings.operators.dateOperatorNotInTheLast
            });
        }
        props.operators[simpleFieldTypes.DATE].push({
            name: strings.operators.dateOperatorIsBetween
        });
        props.operators[simpleFieldTypes.DATE].push({
            name: strings.operators.dateOperatorIsNotBetween
        });
        props.operators[simpleFieldTypes.DATE].push({
            name: strings.operators.dateOperatorIsBlank
        });
        props.operators[simpleFieldTypes.DATE].push({
            name: strings.operators.dateOperatorIsNotBlank
        });
        props.operators[simpleFieldTypes.DATE_ONLY] = [];
        props.operators[simpleFieldTypes.DATE_ONLY].push({
            name: strings.operators.dateOperatorIsOn
        });
        props.operators[simpleFieldTypes.DATE_ONLY].push({
            name: strings.operators.dateOperatorIsNotOn
        });
        /* if (!isStreamLayer) {
          props.operators[simpleFieldTypes.DATE_ONLY].push({
            name: strings.operators.dateOperatorIncludes
          });
          props.operators[simpleFieldTypes.DATE_ONLY].push({
            name: strings.operators.dateOperatorExcludes
          });
        } */
        props.operators[simpleFieldTypes.DATE_ONLY].push({
            name: strings.operators.dateOperatorIsBefore
        });
        props.operators[simpleFieldTypes.DATE_ONLY].push({
            name: strings.operators.dateOperatorIsAfter
        });
        props.operators[simpleFieldTypes.DATE_ONLY].push({
            name: strings.operators.dateOperatorIsBetween
        });
        props.operators[simpleFieldTypes.DATE_ONLY].push({
            name: strings.operators.dateOperatorIsNotBetween
        });
        props.operators[simpleFieldTypes.DATE_ONLY].push({
            name: strings.operators.dateOperatorIsBlank
        });
        props.operators[simpleFieldTypes.DATE_ONLY].push({
            name: strings.operators.dateOperatorIsNotBlank
        });
        props.operators[simpleFieldTypes.NUMBER] = [];
        props.operators[simpleFieldTypes.NUMBER].push({
            name: strings.operators.numberOperatorIs
        });
        props.operators[simpleFieldTypes.NUMBER].push({
            name: strings.operators.numberOperatorIsNot
        });
        if (!featureReduction && !isStreamLayer && !isImageryLayer) {
            props.operators[simpleFieldTypes.NUMBER].push({
                name: strings.operators.numberOperatorIncludes
            });
            props.operators[simpleFieldTypes.NUMBER].push({
                name: strings.operators.numberOperatorExcludes
            });
        }
        props.operators[simpleFieldTypes.NUMBER].push({
            name: strings.operators.numberOperatorIsAtLeast
        });
        props.operators[simpleFieldTypes.NUMBER].push({
            name: strings.operators.numberOperatorIsLessThan
        });
        props.operators[simpleFieldTypes.NUMBER].push({
            name: strings.operators.numberOperatorIsAtMost
        });
        props.operators[simpleFieldTypes.NUMBER].push({
            name: strings.operators.numberOperatorIsGreaterThan
        });
        props.operators[simpleFieldTypes.NUMBER].push({
            name: strings.operators.numberOperatorIsBetween
        });
        props.operators[simpleFieldTypes.NUMBER].push({
            name: strings.operators.numberOperatorIsNotBetween
        });
        if (!featureReduction) {
            props.operators[simpleFieldTypes.NUMBER].push({
                name: strings.operators.numberOperatorIsBlank
            });
            props.operators[simpleFieldTypes.NUMBER].push({
                name: strings.operators.numberOperatorIsNotBlank
            });
        }
        props.operators[simpleFieldTypes.DOMAIN] = [];
        props.operators[simpleFieldTypes.DOMAIN].push({
            name: strings.operators.stringOperatorIs
        });
        props.operators[simpleFieldTypes.DOMAIN].push({
            name: strings.operators.stringOperatorIsNot
        });
        if (!isStreamLayer && !isImageryLayer && !isImageryLayer) {
            props.operators[simpleFieldTypes.DOMAIN].push({
                name: strings.operators.stringOperatorIncludes
            });
            props.operators[simpleFieldTypes.DOMAIN].push({
                name: strings.operators.stringOperatorExcludes
            });
        }
        props.operators[simpleFieldTypes.DOMAIN].push({
            name: strings.operators.stringOperatorIsBlank
        });
        props.operators[simpleFieldTypes.DOMAIN].push({
            name: strings.operators.stringOperatorIsNotBlank
        });
        props.operators[simpleFieldTypes.DOMAIN].push({
            name: strings.operators.stringOperatorIsEmpty
        });
        props.operators[simpleFieldTypes.DOMAIN].push({
            name: strings.operators.stringOperatorIsNotEmpty
        });
    }
}
function getDefaultOperator(props, featureFilterField) {
    const { strings, defaultOperator } = props;
    if (featureFilterField.layerField.name === "cluster_count") {
        return strings.operators.numberOperatorIsGreaterThan;
    }
    switch (featureFilterField.layerField.type) {
        case "string":
            return strings.operators.stringOperatorIs;
        case "date":
        case "date-only":
            if (hasFieldDomains(featureFilterField)) {
                return strings.operators.stringOperatorIs;
            }
            else if (defaultOperator) {
                switch (defaultOperator) {
                    case ">":
                    case ">=":
                        return strings.operators.dateOperatorIsAfter;
                    case "<":
                    case "<=":
                        return strings.operators.dateOperatorIsBefore;
                    default:
                        return strings.operators.dateOperatorIsOn;
                }
            }
            else {
                return strings.operators.dateOperatorIsBefore;
            }
        case "oid":
            return strings.operators.numberOperatorIs;
        case "guid":
            return strings.operators.numberOperatorIs;
        case "small-integer":
        case "big-integer":
        case "integer":
        case "single":
            if (hasFieldDomains(featureFilterField)) {
                return strings.operators.stringOperatorIs;
            }
            else if (defaultOperator) {
                switch (defaultOperator) {
                    case ">":
                        return strings.operators.numberOperatorIsGreaterThan;
                    case ">=":
                        return strings.operators.numberOperatorIsAtLeast;
                    case "<":
                        return strings.operators.numberOperatorIsLessThan;
                    case "<=":
                        return strings.operators.numberOperatorIsAtMost;
                    default:
                        return strings.operators.numberOperatorIs;
                }
            }
            else {
                return strings.operators.numberOperatorIs;
            }
        case "double":
        case "long":
            if (hasFieldDomains(featureFilterField)) {
                return strings.operators.stringOperatorIs;
            }
            else if (defaultOperator) {
                switch (defaultOperator) {
                    case ">":
                        return strings.operators.numberOperatorIsGreaterThan;
                    case ">=":
                        return strings.operators.numberOperatorIsAtLeast;
                    case "<":
                        return strings.operators.numberOperatorIsLessThan;
                    case "<=":
                        return strings.operators.numberOperatorIsAtMost;
                    default:
                        return strings.operators.numberOperatorIs;
                }
            }
            else {
                return strings.operators.numberOperatorIsAtLeast;
            }
        default:
            return strings.operators.stringOperatorIs;
    }
}
function isBetweenOperator(props, operator) {
    const { strings } = props;
    if (operator &&
        [
            strings.operators.numberOperatorIsBetween,
            strings.operators.numberOperatorIsNotBetween,
            strings.operators.dateOperatorIsBetween,
            strings.operators.dateOperatorIsNotBetween
        ].indexOf(operator) > -1) {
        return true;
    }
    return false;
}
function isBlankOperator(props, operator) {
    const { strings } = props;
    if (operator &&
        [
            strings.operators.stringOperatorIsBlank,
            strings.operators.stringOperatorIsNotBlank,
            strings.operators.numberOperatorIsBlank,
            strings.operators.numberOperatorIsNotBlank,
            strings.operators.dateOperatorIsBlank,
            strings.operators.dateOperatorIsNotBlank
        ].indexOf(operator) > -1) {
        return true;
    }
    return false;
}
function isEmptyOperator(props, operator) {
    const { strings } = props;
    if (operator &&
        [strings.operators.stringOperatorIsEmpty, strings.operators.stringOperatorIsNotEmpty].indexOf(operator) > -1) {
        return true;
    }
    return false;
}
function isListOperator(props, operator) {
    const { strings } = props;
    if (operator &&
        [
            strings.operators.stringOperatorIncludes,
            strings.operators.stringOperatorExcludes,
            strings.operators.numberOperatorIncludes,
            strings.operators.numberOperatorExcludes
        ].indexOf(operator) > -1) {
        return true;
    }
    return false;
}
function isIncludesOperator(props, operator) {
    const { strings } = props;
    if (operator &&
        [strings.operators.stringOperatorIncludes, strings.operators.numberOperatorIncludes].indexOf(operator) > -1) {
        return true;
    }
    return false;
}
function isExcludesOperator(props, operator) {
    const { strings } = props;
    if (operator &&
        [strings.operators.stringOperatorExcludes, strings.operators.numberOperatorExcludes].indexOf(operator) > -1) {
        return true;
    }
    return false;
}
function isInTheLastOperator(props, operator) {
    const { strings } = props;
    if (operator &&
        [strings.operators.dateOperatorInTheLast, strings.operators.dateOperatorNotInTheLast].indexOf(operator) > -1) {
        return true;
    }
    return false;
}
function getIncludesOperator(props, filterField) {
    const { strings } = props;
    switch (filterField.simpleFieldType) {
        case "string":
        case "domain":
            return strings.operators.stringOperatorIncludes;
        case "number":
        case "oid":
        case "guid":
            return strings.operators.numberOperatorIncludes;
        default:
            return strings.operators.stringOperatorIncludes;
    }
}
function getExcludesOperator(props, filterField) {
    const { strings } = props;
    switch (filterField.simpleFieldType) {
        case "string":
            return strings.operators.stringOperatorExcludes;
        case "number":
        case "oid":
        case "guid":
            return strings.operators.numberOperatorExcludes;
        //case "date":
        //case "date-only":
        //  return strings.operators.dateOperatorExcludes;
        default:
            return strings.operators.stringOperatorExcludes;
    }
}
function getOperator$1(props, oldFilterField, newFilterField, oldOperator) {
    if (oldFilterField.simpleFieldType !== newFilterField.simpleFieldType) {
        if (isIncludesOperator(props, oldOperator) && newFilterField.simpleFieldType !== simpleFieldTypes.DATE) {
            return getIncludesOperator(props, newFilterField);
        }
        else if (isExcludesOperator(props, oldOperator)) {
            return getExcludesOperator(props, newFilterField);
        }
        else {
            return getDefaultOperator(props, newFilterField);
        }
    }
    return oldOperator;
}

//import * as number from "dojo/number";
//import * as locale from "dojo/date/locale";
const dayInMS = 24 * 60 * 60 * 1000 - 1000;
function createWhereClause(props) {
    let whereClause = "";
    if (!props.expressions || !props.expressions.length) {
        return null;
    }
    let join = "";
    let successfulExpressions = 0;
    for (let i = 0; i < props.expressions.length; i++) {
        const expr = props.expressions[i];
        const str = createExpressionWhereClause(expr, props);
        if (str.length) {
            if (successfulExpressions === 0) {
                whereClause = str;
            }
            else if (successfulExpressions === 1) {
                join = ` ${props.logicalOperatorForExpressions === logicalOperators.OR ? "OR" : "AND"} `;
                whereClause = `(${whereClause})${join}(${str})`;
            }
            else {
                whereClause += `${join}(${str})`;
            }
            successfulExpressions++;
        }
    }
    return whereClause.length ? whereClause : null;
}
function createExpressionWhereClause(expression, props) {
    let exprWhereClause = "";
    if (expression.conditions.length === 1) {
        exprWhereClause = createConditionWhereClause(expression.conditions[0], props);
    }
    else {
        let join = "";
        for (let i = 0; i < expression.conditions.length; i++) {
            const cond = expression.conditions[i];
            const condWhereClause = createConditionWhereClause(cond, props);
            if (condWhereClause.length) {
                exprWhereClause += join + condWhereClause;
                join = ` ${expression.logicalOperatorForConditions === logicalOperators.OR ? "OR" : "AND"} `;
            }
        }
    }
    return exprWhereClause;
}
function createConditionWhereClause(condition, props) {
    const { strings } = props;
    const fieldName = condition.fieldName;
    const operator = condition.operator;
    let value = condition.value;
    let value2 = condition.value2;
    let values = condition.values || [];
    const unit = condition.unit;
    const fieldObject = getFieldInfo(fieldName, props);
    if (!fieldObject) {
        return "";
    }
    if (isBetweenOperator(props, operator) && !isDefined(value2)) {
        return "";
    }
    else if (isListOperator(props, operator) && !values.length) {
        return "";
    }
    else if (isInTheLastOperator(props, operator) && !isDefined(value)) {
        return "";
    }
    else if (!isDefined(value) &&
        !values.length &&
        !isBlankOperator(props, operator) &&
        !isEmptyOperator(props, operator)) {
        return "";
    }
    /* if (isListOperator(operator) && fieldObject.simpleFieldType === simpleFieldTypes.DATE) {
      // max one value; we can't support IN
      value = values?.[0];
    } */
    let whereClause = "";
    if (fieldObject.simpleFieldType === simpleFieldTypes.STRING ||
        fieldObject.simpleFieldType === simpleFieldTypes.GUID) {
        let prefix = "";
        if (isDefined(value) && props.isHosted) {
            if (containsNonLatinCharacter(value)) {
                prefix = "N";
            }
        }
        // e.g. coded value domains
        const isNumber = isNumberType(fieldObject);
        const str = value === null || value === void 0 ? void 0 : value.toString().replace(/\'/g, "''");
        switch (condition.operator) {
            case strings.operators.stringOperatorIs: {
                const pStr = `${prefix}'${str}'`;
                whereClause = `${fieldName} = ${isNumber ? value : pStr}`;
                break;
            }
            case strings.operators.stringOperatorIsNot: {
                const pStr = `${prefix}'${str}'`;
                whereClause = `${fieldName} <> ${isNumber ? value : pStr}`;
                break;
            }
            case strings.operators.stringOperatorStartsWith:
                whereClause = `${fieldName} LIKE ${prefix}'${str}%'`;
                break;
            case strings.operators.stringOperatorEndsWith:
                whereClause = `${fieldName} LIKE ${prefix}'%${str}'`;
                break;
            case strings.operators.stringOperatorContains:
                whereClause = `${fieldName} LIKE ${prefix}'%${str}%'`;
                break;
            case strings.operators.stringOperatorDoesNotContain:
                whereClause = `${fieldName} NOT LIKE ${prefix}'%${str}%'`;
                break;
            case strings.operators.stringOperatorIncludes: {
                whereClause = `${fieldName} IN (${values
                    .map((value) => isNumber
                    ? value
                    : `${containsNonLatinCharacter(value) ? "N" : ""}'${value === null || value === void 0 ? void 0 : value.toString().replace(/\'/g, "''")}'`)
                    .toString()})`;
                break;
            }
            case strings.operators.stringOperatorExcludes: {
                whereClause = `${fieldName} NOT IN (${values
                    .map((value) => isNumber
                    ? value
                    : `${containsNonLatinCharacter(value) ? "N" : ""}'${value === null || value === void 0 ? void 0 : value.toString().replace(/\'/g, "''")}'`)
                    .toString()})`;
                break;
            }
            case strings.operators.stringOperatorIsBlank:
                whereClause = `${fieldName} IS NULL`;
                break;
            case strings.operators.stringOperatorIsNotBlank:
                whereClause = `${fieldName} IS NOT NULL`;
                break;
            case strings.operators.stringOperatorIsEmpty:
                whereClause = `${fieldName} = ''`;
                break;
            case strings.operators.stringOperatorIsNotEmpty:
                //whereClause = `${fieldName} <> '' OR ${fieldName} IS NULL`;
                whereClause = `${fieldName} <> ''`; // not returning NULL values
                break;
        }
    }
    else if (fieldObject.simpleFieldType === simpleFieldTypes.NUMBER ||
        fieldObject.simpleFieldType === simpleFieldTypes.OID) {
        switch (operator) {
            case strings.operators.numberOperatorIs:
                whereClause = `${fieldName} = ${value}`;
                break;
            case strings.operators.numberOperatorIsNot:
                whereClause = `${fieldName} <> ${value}`;
                break;
            case strings.operators.numberOperatorIsAtLeast:
                whereClause = `${fieldName} >= ${value}`;
                break;
            case strings.operators.numberOperatorIsLessThan:
                whereClause = `${fieldName} < ${value}`;
                break;
            case strings.operators.numberOperatorIsAtMost:
                whereClause = `${fieldName} <= ${value}`;
                break;
            case strings.operators.numberOperatorIsGreaterThan:
                whereClause = `${fieldName} > ${value}`;
                break;
            case strings.operators.numberOperatorIsBetween:
                whereClause = `${fieldName} BETWEEN ${value} AND ${value2}`;
                break;
            case strings.operators.numberOperatorIsNotBetween:
                whereClause = `${fieldName} NOT BETWEEN ${value} AND ${value2}`;
                break;
            case strings.operators.numberOperatorIncludes:
                whereClause = `${fieldName} IN (${values.toString()})`;
                break;
            case strings.operators.numberOperatorExcludes:
                whereClause = `${fieldName} NOT IN (${values.toString()})`;
                break;
            case strings.operators.numberOperatorIsBlank:
                whereClause = `${fieldName} IS NULL`;
                break;
            case strings.operators.numberOperatorIsNotBlank:
                whereClause = `${fieldName} IS NOT NULL`;
                break;
        }
    }
    else if (fieldObject.simpleFieldType === simpleFieldTypes.DATE_ONLY) {
        // date
        // NOTE: client side filter effect only supports sql92 and needs the date in the query
        // therfore we disable data fields for services without standardizedQuery support
        const datestmp = !props.supportsStandardizedQuery ? "" : "DATE ";
        if (typeof value === "number") {
            const date = new Date(value);
            value = `${date.getFullYear()}-${date.getMonth() < 9 ? "0" : ""}${date.getMonth() + 1}-${date.getDate() < 10 ? "0" : ""}${date.getDate()}`;
        }
        if (isDefined(value2) && typeof value2 === "number") {
            const date = new Date(value2);
            value2 = `${date.getFullYear()}-${date.getMonth() < 9 ? "0" : ""}${date.getMonth() + 1}-${date.getDate() < 10 ? "0" : ""}${date.getDate()}`;
        }
        switch (operator) {
            case strings.operators.dateOperatorIsOn:
            case strings.operators.numberOperatorIncludes:
                whereClause = `${fieldName} = ${datestmp}'${value}'`;
                break;
            case strings.operators.dateOperatorIsNotOn:
            case strings.operators.numberOperatorExcludes:
                whereClause = `${fieldName} <> ${datestmp}'${value}'`;
                break;
            case strings.operators.dateOperatorIsBefore:
                whereClause = `${fieldName} < ${datestmp}'${value}'`;
                break;
            case strings.operators.dateOperatorIsAfter:
                whereClause = `${fieldName} > ${datestmp}'${value}'`;
                break;
            case strings.operators.dateOperatorIsBetween:
                whereClause = `${fieldName} BETWEEN ${datestmp}'${value}' AND ${datestmp}'${value2}'`;
                break;
            case strings.operators.dateOperatorIsNotBetween:
                whereClause = `${fieldName} NOT BETWEEN ${datestmp}'${value}' AND ${datestmp}'${value2}'`;
                break;
            /* case strings.operators.numberOperatorIncludes:
            case strings.operators.numberOperatorExcludes:
              let dateValuesString = "";
              let comma = "";
              dateValues.forEach((dateValue: string) => {
                dateValuesString += `${comma}${datestmp}'${dateValue}'`;
                comma = ",";
              });
              if (operator === strings.operators.numberOperatorIncludes) {
                whereClause = `${fieldName} IN (${dateValuesString})`;
              } else {
                whereClause = `${fieldName} NOT IN (${dateValuesString})`;
              }
              break; */
            case strings.operators.dateOperatorIsBlank:
                whereClause = `${fieldName} IS NULL`;
                break;
            case strings.operators.dateOperatorIsNotBlank:
                whereClause = `${fieldName} IS NOT NULL`;
                break;
        }
    }
    else {
        // date
        // NOTE: client side filter effect only supports sql92 and needs the timestamp in the query
        // therfore we disable data fields for services without standardizedQuery support
        let dateValue = getDateObject(value);
        let dateValue2 = getDateObject(value2);
        /* const dateValues =
          values &&
          values.map((value: string | number | Date) => {
            return formatDate(getDateObject(value));
          }); */
        const tmstmp = !props.supportsStandardizedQuery ? "" : "timestamp ";
        const dateStr = formatDate(dateValue);
        const datePlusOneStr = formatDate(addDay(dateValue));
        const date2PlusOneStr = formatDate(addDay(dateValue2));
        switch (operator) {
            case strings.operators.dateOperatorIsOn:
                whereClause = `${fieldName} BETWEEN ${tmstmp}'${dateStr}' AND ${tmstmp}'${datePlusOneStr}'`;
                break;
            case strings.operators.dateOperatorIsNotOn:
                whereClause = `${fieldName} NOT BETWEEN ${tmstmp}'${dateStr}' AND ${tmstmp}'${datePlusOneStr}'`;
                break;
            case strings.operators.dateOperatorIsBefore:
                whereClause = `${fieldName} < ${tmstmp}'${dateStr}'`;
                break;
            case strings.operators.dateOperatorIsAfter:
                whereClause = `${fieldName} > ${tmstmp}'${datePlusOneStr}'`;
                break;
            case strings.operators.dateOperatorInTheLast:
                whereClause = `${fieldName} BETWEEN ${createInTheLastQueryPart(props, value, unit)}`;
                break;
            case strings.operators.dateOperatorNotInTheLast:
                whereClause = `${fieldName} NOT BETWEEN ${createInTheLastQueryPart(props, value, unit)}`;
                break;
            case strings.operators.dateOperatorIsBetween:
                whereClause = `${fieldName} BETWEEN ${tmstmp}'${dateStr}' AND ${tmstmp}'${date2PlusOneStr}'`;
                break;
            case strings.operators.dateOperatorIsNotBetween:
                whereClause = `${fieldName} NOT BETWEEN ${tmstmp}'${dateStr}' AND ${tmstmp}'${date2PlusOneStr}'`;
                break;
            /* case strings.operators.dateOperatorIncludes:
            case strings.operators.dateOperatorExcludes:
              let dateValuesString = "";
              let comma = "";
              dateValues.forEach((dateValue: string) => {
                dateValuesString += `${comma}${tmstmp}'${dateValue}'`;
                comma = ",";
              });
              if (operator === strings.operators.dateOperatorIncludes) {
                whereClause = `${fieldName} IN (${dateValuesString})`;
              } else {
                whereClause = `${fieldName} NOT IN (${dateValuesString})`;
              }
              break; */
            case strings.operators.dateOperatorIsBlank:
                whereClause = `${fieldName} IS NULL`;
                break;
            case strings.operators.dateOperatorIsNotBlank:
                whereClause = `${fieldName} IS NOT NULL`;
                break;
        }
    }
    return whereClause;
}
function getDateObject(value) {
    if (typeof value === "number") {
        // value is a UTC timestamp; returns a date object in local time
        return new Date(value);
    }
    else if (typeof value === "string") {
        // from date picker...
        // e.g. "7/7/2010 12:00:00 AM" returned by generateRenderer
        // in DE value is "02.03.12" for March second; new Date(value) then returns Feb 3rd
        //        value = new Date(value);
        return parseFriendlyDate(value);
    }
    else if (value) {
        // Date object; in local time
        return value;
    }
}
function formatDate(date) {
    // service needs UTC time, but the user looks at local time in the UI
    // date is in local time
    // returns the string in UTC time
    // e.g. 2017-07-07 09:05:19
    if (!date) {
        return "";
    }
    const yearStr = `${date.getUTCFullYear()}`;
    let monthStr = `${date.getUTCMonth() + 1}`;
    if (monthStr.length === 1) {
        monthStr = `0${monthStr}`;
    }
    let dateStr = `${date.getUTCDate()}`;
    if (dateStr.length === 1) {
        dateStr = `0${dateStr}`;
    }
    let hoursStr = `${date.getUTCHours()}`;
    if (hoursStr.length === 1) {
        hoursStr = `0${hoursStr}`;
    }
    let minStr = `${date.getUTCMinutes()}`;
    if (minStr.length === 1) {
        minStr = `0${minStr}`;
    }
    let secStr = `${date.getSeconds()}`;
    if (secStr.length === 1) {
        secStr = `0${secStr}`;
    }
    return `${yearStr}-${monthStr}-${dateStr} ${hoursStr}:${minStr}:${secStr}`;
}
function createInTheLastQueryPart(props, value, unit) {
    if (props.supportedSqlParserVersion) {
        let days = 0;
        if (unit === "year") {
            // not accurate ...
            days = value * 365;
            return `CURRENT_TIMESTAMP - INTERVAL '${days}' DAY AND CURRENT_TIMESTAMP`;
        }
        else if (unit === "month") {
            // not accurate ...
            days = value * 30;
            return `CURRENT_TIMESTAMP - INTERVAL '${days}' DAY AND CURRENT_TIMESTAMP`;
        }
        else if (unit === "week") {
            days = value * 7;
            return `CURRENT_TIMESTAMP - INTERVAL '${days}' DAY AND CURRENT_TIMESTAMP`;
        }
        else if (unit === "day") {
            days = value;
            return `CURRENT_TIMESTAMP - INTERVAL '${days}' DAY AND CURRENT_TIMESTAMP`;
        }
        else if (unit === "hour") {
            return `CURRENT_TIMESTAMP - INTERVAL '${value}' HOUR AND CURRENT_TIMESTAMP`;
        }
        else {
            // minutes
            return `CURRENT_TIMESTAMP - INTERVAL '${value}' MINUTE AND CURRENT_TIMESTAMP`;
        }
    }
    else {
        let days = 0;
        if (unit === "year") {
            // not accurate ...
            days = value * 365;
        }
        else if (unit === "month") {
            // not accurate ...
            days = value * 30;
        }
        else if (unit === "week") {
            days = value * 7;
        }
        else if (unit === "day") {
            days = value;
        }
        else if (unit === "hour") {
            days = value / 24;
        }
        else {
            // minute
            days = value / (24 * 60);
        }
        return `CURRENT_TIMESTAMP - ${days} AND CURRENT_TIMESTAMP`;
    }
}
function parseFriendlyDate(value) {
    // en: 3/2/15 de: 02.03.15 - for march second
    /* return locale.parse(value, {
      formatLength: "short",
      selector: "date"
    }); */
    return new Date(value);
}
function parseDate(strValue) {
    // strValue is in UTC time, but the user looks at local time in the UI
    // we know strValue looks like this 'yyyy-MM-dd HH:mm:ss' (e.g. '2013-03-01 00:00:00')
    /*
    var date = new Date();
    date.setUTCFullYear(Number(strValue.substring(0, 4)));
    date.setUTCMonth(parseInt(strValue.substring(5, 7)) - 1);
    date.setUTCDate(Number(strValue.substring(8, 10)));
    date.setUTCHours(Number(strValue.substring(11, 13)));
    date.setUTCMinutes(Number(strValue.substring(14, 16)));
    date.setSeconds(Number(strValue.substring(17, 19)));
    return date;
    */
    let date = new Date(strValue);
    let utcDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
    //console.log("parseDate", strValue, " - ", utcDate);
    return utcDate;
}
function addDay(date) {
    if (date) {
        return new Date(date.getTime() + dayInMS);
    }
}
function subtractDay(date) {
    return new Date(date.getTime() - dayInMS);
}
function containsNonLatinCharacter(value) {
    if (typeof value === "number") {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        if (value.charCodeAt(i) > 255) {
            return true;
        }
    }
    return false;
}

//import * as WhereClause from "esri/core/sql/WhereClause";
//const dayInMS: number = 24 * 60 * 60 * 1000 - 1000; // 1 sec less than 1 day
async function parseWhereClause(whereClause, props) {
    const { layer } = props;
    // does not call reject()
    if (!whereClause || !whereClause.length) {
        /* const defaultField = getDefaultField(state);
        state.expressions = [
          {
            conditions: [
              {
                fieldName: defaultField.layerField.name,
                operator: getDefaultOperator(defaultField),
                value: null
              }
            ]
          }
        ];
        state.expressions = fixUIDs(state.expressions); */
        return true;
    }
    else {
        const [esriSQL] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/core/sql"]);
        // ImageryLayer has fieldsIndex too, it's not documented yet. Casting as any for now.
        return esriSQL.parseWhereClause(whereClause, layer.fieldsIndex).then((clause /* WhereClause */) => {
            if (!clause.isStandardized) {
                // uses some non standard functions. invalid
                return false;
            }
            props.expressions = [
                {
                    conditions: []
                }
            ];
            const success = parseClause(clause.parseTree, props);
            props.expressions = fixUIDs(props.expressions);
            /*
              console.log(
                "SQLParser:",
                success,
                whereClause,
                clause,
                props.logicalOperatorForExpressions,
                props.expressions
              );
            */
            return success;
        }, (error) => {
            console.error("SQLParser - error:", error);
            return false;
        });
    }
}
function parseClause(parseTree, props) {
    if (!props.expressions) {
        return false;
    }
    if (isCondition(parseTree)) {
        return parseBinaryExpr(parseTree, props.expressions[0].conditions, props);
    }
    else {
        props.logicalOperatorForExpressions = getLogicalOperator(parseTree);
        return parseBinaryExpr(parseTree, props.expressions[0], props);
    }
}
function parseBinaryExpr(obj, stateObj, props) {
    var _a;
    const { strings } = props;
    // left, operator, right, type
    if (isCondition(obj)) {
        // stateObj is list of conditions
        if (obj.left.type === "column-reference") {
            const fieldObject = getFieldInfo(obj.left.column, props);
            const operator = fieldObject ? getOperator(props, obj.operator, fieldObject, obj.right) : undefined;
            if (fieldObject && operator) {
                let condition;
                if (obj.right.type === "null") {
                    // IS NULL / IS NOT NULL
                    condition = {
                        fieldName: fieldObject.layerField.name,
                        operator: operator
                    };
                }
                else if (obj.right.type === "column-reference") {
                    // we no longer support field to field filters
                    // -> error
                    return false;
                }
                else if (obj.right.type === "expression-list" && isListOperator(props, operator)) {
                    // IN, NOT IN
                    condition = {
                        fieldName: fieldObject.layerField.name,
                        operator,
                        values: obj.right.value.map((val) => val.value)
                    };
                }
                else if (obj.right.type === "expression-list" && isInTheLastOperator(props, operator)) {
                    // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - <days> AND CURRENT_TIMESTAMP";
                    // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <days> DAY AND CURRENT_TIMESTAMP";
                    // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <hours> HOUR AND CURRENT_TIMESTAMP";
                    // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <minutes> MINUTE AND CURRENT_TIMESTAMP";
                    const result = parseInTheLast(obj);
                    if (!result) {
                        return false;
                    }
                    condition = {
                        fieldName: fieldObject.layerField.name,
                        operator,
                        value: result.value,
                        unit: result.unit
                    };
                }
                else if (obj.right.type === "expression-list" && isBetweenOperator(props, operator)) {
                    // BETWEEN, NOT BETWEEN
                    if (isDateType(fieldObject)) {
                        // value: "2000-09-14 06:26:36"
                        const date1 = parseDate(obj.right.value[0].value);
                        const date2 = parseDate(obj.right.value[1].value);
                        const date2Sub = subtractDay(date2);
                        if (Math.abs(date2Sub.getTime() - date1.getTime()) < 1000) {
                            // within 1 day
                            condition = {
                                fieldName: fieldObject.layerField.name,
                                operator: operator === strings.operators.dateOperatorIsBetween
                                    ? strings.operators.dateOperatorIsOn
                                    : strings.operators.dateOperatorIsNotOn,
                                value: date1.getTime()
                            };
                        }
                        else {
                            condition = {
                                fieldName: fieldObject.layerField.name,
                                operator,
                                value: date1.getTime(),
                                value2: date2.getTime()
                            };
                        }
                    }
                    else if (isDateOnlyType(fieldObject)) {
                        // value: "2000-09-14"
                        const date1 = parseDate(obj.right.value[0].value);
                        const date2 = parseDate(obj.right.value[1].value);
                        const offset = date1.getTimezoneOffset() * 60000;
                        condition = {
                            fieldName: fieldObject.layerField.name,
                            operator,
                            // the parser already substracts the offset to local time
                            value: date1.getTime() + 2 * offset,
                            value2: date2.getTime() + 2 * offset
                        };
                    }
                    else {
                        condition = {
                            fieldName: fieldObject.layerField.name,
                            operator,
                            value: obj.right.value[0].value,
                            value2: obj.right.value[1].value
                        };
                    }
                }
                else if (obj.right.type === "timestamp") {
                    condition = {
                        fieldName: fieldObject.layerField.name,
                        operator,
                        value: parseDate(obj.right.value).getTime()
                    };
                }
                else if (obj.right.type === "date") {
                    if (fieldObject.simpleFieldType === simpleFieldTypes.DATE_ONLY) {
                        // convert date string to UNIX timestamp (without timestamp offset shift)
                        const date = parseDate(obj.right.value);
                        const offset = date.getTimezoneOffset() * 60000;
                        condition = {
                            fieldName: fieldObject.layerField.name,
                            operator,
                            // the parser already substracts the offset to local time
                            value: date.getTime() + 2 * offset
                        };
                    }
                    else {
                        condition = {
                            fieldName: fieldObject.layerField.name,
                            operator,
                            value: parseDate(obj.right.value).getTime()
                        };
                    }
                }
                else {
                    // type: "string" | "number" |...
                    condition = {
                        fieldName: fieldObject.layerField.name,
                        operator,
                        value: obj.right.value
                    };
                }
                stateObj.push(condition);
            }
            else {
                // field or operator not found
                // -> error
                return false;
            }
            return true;
        }
        else {
            return false;
        }
    }
    else {
        // stateObj is expression
        props.expressions = props.expressions || [];
        let success;
        if (isCondition(obj.left) && isCondition(obj.right)) {
            stateObj.logicalOperatorForConditions = getLogicalOperator(obj);
            success = parseBinaryExpr(obj.left, stateObj.conditions, props);
            success = success && parseBinaryExpr(obj.right, stateObj.conditions, props);
        }
        else if (isCondition(obj.left)) {
            if (obj.operator === obj.right.operator && isCondition(obj.right.left) && isCondition(obj.right.right)) {
                // same expression
                stateObj.logicalOperatorForConditions = getLogicalOperator(obj);
                success = parseBinaryExpr(obj.left, stateObj.conditions, props);
                success = success && parseBinaryExpr(obj.right, stateObj, props);
            }
            else {
                // start a new expression
                success = parseBinaryExpr(obj.left, stateObj.conditions, props);
                const expression = {
                    conditions: []
                };
                props.expressions.push(expression);
                success = success && parseBinaryExpr(obj.right, expression, props);
            }
        }
        else if (isCondition(obj.right)) {
            if (obj.operator === obj.left.operator &&
                isCondition(obj.left.right) &&
                (isCondition(obj.left.left) || obj.left.operator === ((_a = obj.left.left) === null || _a === void 0 ? void 0 : _a.operator))) {
                // same expression
                stateObj.logicalOperatorForConditions = getLogicalOperator(obj);
                success = parseBinaryExpr(obj.left, stateObj, props);
                success = success && parseBinaryExpr(obj.right, stateObj.conditions, props);
            }
            else {
                // start a new expression
                success = parseBinaryExpr(obj.left, stateObj, props);
                const expression = {
                    conditions: []
                };
                props.expressions.push(expression);
                success = success && parseBinaryExpr(obj.right, expression.conditions, props);
            }
        }
        else {
            // no 'leaf'
            if (obj.operator === obj.right.operator && obj.operator === obj.left.operator) {
                // same expression
                stateObj.logicalOperatorForConditions = getLogicalOperator(obj);
                success = parseBinaryExpr(obj.left, stateObj, props);
                success = success && parseBinaryExpr(obj.right, stateObj, props);
            }
            else {
                // start new expressions; first one is still empty...
                success = parseBinaryExpr(obj.left, stateObj, props);
                const expression = {
                    conditions: []
                };
                props.expressions.push(expression);
                success = success && parseBinaryExpr(obj.right, expression, props);
            }
        }
        return success;
    }
}
function isCondition(obj) {
    if (obj.type === "binary-expression" && (obj.operator === "OR" || obj.operator === "AND")) {
        return false;
    }
    return true;
}
function getLogicalOperator(obj) {
    return obj.operator.toUpperCase() === "OR" ? logicalOperators.OR : logicalOperators.AND;
}
function getOperator(props, operator, fieldObject, objRight) {
    var _a, _b, _c, _d;
    const { strings } = props;
    if (!fieldObject) {
        return "";
    }
    if (fieldObject.simpleFieldType === simpleFieldTypes.STRING) {
        switch (operator) {
            case "=":
                if (objRight.value === "") {
                    return strings.operators.stringOperatorIsEmpty;
                }
                else {
                    return strings.operators.stringOperatorIs;
                }
            case "<>": {
                if (objRight.value === "") {
                    return strings.operators.stringOperatorIsNotEmpty;
                }
                else {
                    return strings.operators.stringOperatorIsNot;
                }
            }
            case "LIKE":
                if (objRight.value.startsWith("%") && objRight.value.endsWith("%")) {
                    objRight.value = objRight.value.substring(1, objRight.value.length - 1);
                    return strings.operators.stringOperatorContains;
                }
                else if (objRight.value.endsWith("%")) {
                    objRight.value = objRight.value.substring(0, objRight.value.length - 1);
                    return strings.operators.stringOperatorStartsWith;
                }
                else if (objRight.value.startsWith("%")) {
                    objRight.value = objRight.value.substring(1);
                    return strings.operators.stringOperatorEndsWith;
                }
                else {
                    return strings.operators.stringOperatorIs;
                }
            case "NOT LIKE":
                if (objRight.value.startsWith("%") && objRight.value.endsWith("%")) {
                    objRight.value = objRight.value.substring(1, objRight.value.length - 1);
                }
                else if (objRight.value.endsWith("%")) {
                    objRight.value = objRight.value.substring(0, objRight.value.length - 1);
                }
                else if (objRight.value.startsWith("%")) {
                    objRight.value = objRight.value.substring(1);
                }
                return strings.operators.stringOperatorDoesNotContain;
            case "IS":
                if (objRight.type === "null") {
                    return strings.operators.stringOperatorIsBlank;
                }
                return strings.operators.stringOperatorIs;
            case "ISNOT":
            case "IS NOT":
                if (objRight.type === "null") {
                    return strings.operators.stringOperatorIsNotBlank;
                }
                return strings.operators.stringOperatorIs;
            case "IN":
                return strings.operators.stringOperatorIncludes;
            case "NOT IN":
            case "NOTIN":
                return strings.operators.stringOperatorExcludes;
        }
    }
    else if (fieldObject.simpleFieldType === "number" || fieldObject.simpleFieldType === "oid") {
        switch (operator) {
            case "=":
                return strings.operators.numberOperatorIs;
            case "<>":
                return strings.operators.numberOperatorIsNot;
            case ">=":
                return strings.operators.numberOperatorIsAtLeast;
            case "<":
                return strings.operators.numberOperatorIsLessThan;
            case "<=":
                return strings.operators.numberOperatorIsAtMost;
            case ">":
                return strings.operators.numberOperatorIsGreaterThan;
            case "BETWEEN":
                return strings.operators.numberOperatorIsBetween;
            case "NOT BETWEEN":
            case "NOTBETWEEN":
                return strings.operators.numberOperatorIsNotBetween;
            case "IS":
                if (objRight.type === "null") {
                    return strings.operators.numberOperatorIsBlank;
                }
                return strings.operators.numberOperatorIs;
            case "ISNOT":
            case "IS NOT":
                if (objRight.type === "null") {
                    return strings.operators.numberOperatorIsNotBlank;
                }
                return strings.operators.numberOperatorIs;
            case "IN":
                return strings.operators.numberOperatorIncludes;
            case "NOT IN":
            case "NOTIN":
                return strings.operators.numberOperatorExcludes;
        }
    }
    else {
        // date
        switch (operator) {
            case "=":
                // we don't really create this where clause
                return strings.operators.dateOperatorIsOn;
            case "<>":
                return strings.operators.dateOperatorIsNotOn;
            case "<":
                return strings.operators.dateOperatorIsBefore;
            case ">":
                return strings.operators.dateOperatorIsAfter;
            case "BETWEEN":
                if (((_b = (_a = objRight.value[0]) === null || _a === void 0 ? void 0 : _a.left) === null || _b === void 0 ? void 0 : _b.type) === "current-time") {
                    // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - <days> AND CURRENT_TIMESTAMP";
                    // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <days> DAY AND CURRENT_TIMESTAMP";
                    // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <hours> HOUR AND CURRENT_TIMESTAMP";
                    // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <minutes> MINUTE AND CURRENT_TIMESTAMP";
                    return strings.operators.dateOperatorInTheLast;
                }
                else {
                    return strings.operators.dateOperatorIsBetween;
                }
            case "NOT BETWEEN":
            case "NOTBETWEEN":
                if (((_d = (_c = objRight.value[0]) === null || _c === void 0 ? void 0 : _c.left) === null || _d === void 0 ? void 0 : _d.type) === "current-time") {
                    // whereClause = "<fieldName> NOT BETWEEN CURRENT_TIMESTAMP - <days> AND CURRENT_TIMESTAMP";
                    return strings.operators.dateOperatorNotInTheLast;
                }
                else {
                    return strings.operators.dateOperatorIsNotBetween;
                }
            case "IS":
                if (objRight.type === "null") {
                    return strings.operators.dateOperatorIsBlank;
                } // else not supported
            case "ISNOT":
            case "IS NOT":
                if (objRight.type === "null") {
                    return strings.operators.dateOperatorIsNotBlank;
                } // else not supported
        }
    }
    return "";
}
function parseInTheLast(obj) {
    const right = obj.right.value[0].right;
    let count = right.value;
    if (right.type === "interval") {
        //whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <days> DAY AND CURRENT_TIMESTAMP";
        //whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <hours> HOUR AND CURRENT_TIMESTAMP";
        //whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <minutes> MINUTE AND CURRENT_TIMESTAMP";
        count = right.value.type === "string" ? parseFloat(right.value.value) : right.value.value;
        if (right.qualifier.period === "day") {
            if (count % 365 === 0) {
                return { value: count / 365, unit: "year" };
            }
            else if (count % 30 === 0) {
                return { value: count / 30, unit: "month" };
            }
            else if (count % 7 === 0) {
                return { value: count / 7, unit: "week" };
            }
            else if (count % 1 === 0) {
                return { value: count, unit: "day" };
            }
        }
        else if (right.qualifier.period === "hour") {
            return { value: count, unit: "hour" };
        }
        else if (right.qualifier.period === "minute") {
            return { value: count, unit: "minute" };
        }
    }
    else if (!isNaN(count)) {
        //whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - <days> AND CURRENT_TIMESTAMP"
        if (count % 365 === 0) {
            return { value: count / 365, unit: "year" };
        }
        else if (count % 30 === 0) {
            return { value: count / 30, unit: "month" };
        }
        else if (count % 7 === 0) {
            return { value: count / 7, unit: "week" };
        }
        else if (count % 1 === 0) {
            return { value: count, unit: "day" };
        }
        else {
            const minutes = Math.round(count * 24 * 60);
            if (minutes % 60 === 0) {
                return { value: Math.round(count * 24), unit: "hour" };
            }
            else {
                return { value: minutes, unit: "minute" };
            }
        }
    }
    else {
        return null;
    }
}

const arcgisFilterCss = ".sc-arcgis-filter-h{display:flex;flex:1 1 auto;overflow:hidden}.fab-padding.sc-arcgis-filter{padding-bottom:1rem}.hook.sc-arcgis-filter{width:100%;height:1px}.remove-filter.sc-arcgis-filter{margin-bottom:5px;background-color:white;padding-left:15px}.match-expression-dropdown.sc-arcgis-filter{width:100%}.match-expression-msg.sc-arcgis-filter{padding:12px;background-color:white}.match-type.sc-arcgis-filter{display:flex;justify-content:center;margin:6px 0}.arcgis--rtl.sc-arcgis-filter .remove-filter.sc-arcgis-filter{padding-left:0;padding-right:15px}.no-space.sc-arcgis-filter{--calcite-label-margin-bottom:0}";

const ArcgisFilter = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisFilterWhereChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterWhereChange", 7);
        this.arcgisFilterSave = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterSave", 7);
        this.arcgisFilterCancel = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterCancel", 7);
        this.arcgisFilterDismissedChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterDismissedChange", 7);
        this.arcgisFilterDone = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterDone", 7);
        this.arcgisFilterPanelBackClick = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterPanelBackClick", 7);
        this.closeFilterPopovers = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "closeFilterPopovers", 7);
        this.arcgisFilterExpressionChanged = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterExpressionChanged", 7);
        this.layerViewWaitHandler = null;
        this.layerHasFeatureEffect = false;
        this.properClose = false;
        this.applyFilter = () => {
            const { props, mode } = this;
            const { layerView, layer, labelClassIdx, labelClass, originalLayer } = props;
            this.closeFilterPopovers.emit();
            if (isDefined(labelClassIdx) || isDefined(labelClass)) {
                // we passed the where clause when it changed
                this.arcgisFilterSave.emit();
            }
            else if (mode === "layer-view") {
                const whereClause = createWhereClause(props);
                // keep effect on layerView to avoid flickering
                this.arcgisFilterSave.emit(whereClause);
            }
            else if (mode === "effects") ;
            else if (layer) {
                const whereClause = createWhereClause(props);
                (originalLayer || layer).definitionExpression = whereClause;
                //console.log("definitionExpression:", whereClause);
                if (this.isAllowedFeatureEffect()) {
                    layer.featureEffect = null;
                }
                else {
                    if (layerView && "filter" in layerView) {
                        layerView.filter = null;
                    }
                }
                createIndexes(props);
                this.properClose = true;
                this.arcgisFilterSave.emit();
                // switched to definitionExpression from effect/layerView.filter
                this.componentStateInvalid = true;
            }
        };
        this.cancelFilter = () => {
            this.revertFilter();
            this.closeFilterPopovers.emit();
            this.properClose = true;
            this.arcgisFilterCancel.emit();
        };
        this.closeFilter = () => {
            // save on close
            this.applyFilter();
            this.closeFilterPopovers.emit();
            this.properClose = true;
            this.arcgisFilterDismissedChange.emit();
        };
        this.onAddExpression = () => {
            const { props } = this;
            const { expressions } = props;
            const defaultField = getDefaultField(props);
            if (!defaultField) {
                // not ready yet
                return;
            }
            const defaultOperator = getDefaultOperator(props, defaultField);
            const defaultValues = getDefaultValues(props, defaultField, defaultOperator);
            const newExpression = {
                conditions: [
                    Object.assign(Object.assign({ fieldName: defaultField.layerField.name, operator: defaultOperator }, defaultValues), { hasFocus: true })
                ]
            };
            props.expressions = expressions
                ? fixUIDs([
                    ...expressions.map((expression) => {
                        return Object.assign(Object.assign({}, expression), { conditions: expression.conditions.map((cond) => {
                                return Object.assign(Object.assign({}, cond), { hasFocus: false });
                            }) });
                    }),
                    newExpression
                ])
                : fixUIDs([newExpression]);
            if (isDefined(defaultValues.value)) {
                this.arcgisFilterExpressionChanged.emit({ type: "replace", expression: newExpression });
            }
            this.reRender = !this.reRender;
        };
        this.onMatchSelect = (event) => {
            const { props } = this;
            const select = event.target;
            props.logicalOperatorForExpressions = select.selectedOption.value;
            this.reRender = !this.reRender;
            this.applyFilterToLayer();
        };
        this.onRemoveFilter = () => {
            const { props } = this;
            props.invalidFilter = false;
            props.expressions = undefined;
            this.reRender = !this.reRender;
            this.applyFilterToLayer();
        };
        this.focusByClass = () => {
            // set focus back for keyboard users
            const node = this.hostElement.querySelector("arcgis-filter .autofocus");
            if (node) {
                if (node.nodeName.startsWith("CALCITE-")) {
                    node.setFocus();
                }
                else {
                    node.focus();
                }
            }
        };
        this.view = undefined;
        this.layer = undefined;
        this.labelClassIdx = undefined;
        this.labelClass = undefined;
        this.mode = undefined;
        this.viewFilter = undefined;
        this.featureReduction = undefined;
        this.hideLayerTitle = false;
        this.panelHeading = undefined;
        this.tipHeading = undefined;
        this.tipMsg = undefined;
        this.invalidHeading = undefined;
        this.invalidMsg = undefined;
        this.newButtonLabel = undefined;
        this.clearText = undefined;
        this.defaultFieldName = undefined;
        this.defaultOperator = undefined;
        this.defaultExpression = false;
        this.hideButtons = false;
        this.panelMaxHeight = undefined;
        this.dismissible = false;
        this.props = undefined;
        this.reRender = false;
        this.componentStateInvalid = false;
    }
    arcgisFilterExpressionChangeHandler(event) {
        var _a;
        const { props } = this;
        const { expressions } = props;
        const { detail } = event;
        if (detail.type === "copy") {
            // replace + copy expression
            const expr = event.detail.expression;
            props.expressions = props.expressions.map((expression) => (expression.uid === expr.uid ? expr : expression) //{ ...expression }
            );
            let copyExpression;
            props.expressions = expressions.map((expression) => {
                return Object.assign(Object.assign({}, expression), { conditions: expression.conditions.map((cond) => {
                        return Object.assign(Object.assign({}, cond), { hasFocus: false });
                    }) });
            });
            props.expressions.forEach((expr) => {
                if (expr.uid === detail.uid) {
                    copyExpression = this.esriLang.clone(Object.assign({}, expr));
                    copyExpression.conditions[0].hasFocus = true;
                }
            });
            props.expressions = fixUIDs([...props.expressions, copyExpression]);
            this.reRender = !this.reRender;
        }
        else if (detail.type === "delete") {
            // delete expression
            let removedIdx = 0;
            expressions.forEach((expression, idx) => {
                if (expression.uid === detail.uid) {
                    removedIdx = idx;
                }
                else {
                    expression.conditions.forEach((cond) => (cond.hasFocus = false));
                }
            });
            props.expressions = expressions.filter((expression) => expression.uid !== detail.uid);
            if ((_a = props.expressions) === null || _a === void 0 ? void 0 : _a.length) {
                props.expressions[Math.max(0, removedIdx - 1)].conditions[0].hasFocus = true;
                props.expressions = fixUIDs([...props.expressions]);
                // wait until rendering is done
                setTimeout(() => this.focusByClass(), 500);
            }
            else {
                // wait until rendering is done
                setTimeout(() => this.fabNode.setFocus(), 500);
            }
            this.reRender = !this.reRender;
        }
        else {
            // type="replace"
            // replace expression
            const replaceExpr = event.detail.expression;
            props.expressions = props.expressions.map((expression) => expression.uid === replaceExpr.uid ? Object.assign({}, replaceExpr) : expression);
        }
        this.applyFilterToLayer();
    }
    disableFilterPanelHandler(event) {
        this.panelNode.disabled = event.detail;
    }
    //--------------------------------------------------------------------------
    //
    //  public calls
    //
    //--------------------------------------------------------------------------
    async setFocus() {
        this.panelNode.setFocus();
    }
    async done() {
        if (!this.componentStateInvalid) {
            // save on done
            this.applyFilter();
            this.closeFilterPopovers.emit();
            this.properClose = true;
            this.arcgisFilterDone.emit();
        }
    }
    async closePopovers() {
        this.closeFilterPopovers.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const [strings, currentLanguage, currentLanguageIntl] = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.hostElement);
        // build FilterProps
        this.props = {
            expressions: undefined,
            logicalOperatorForExpressions: "and",
            fields: [],
            operators: undefined,
            invalidFilter: false,
            stringFieldsCount: 0,
            dateFieldsCount: 0,
            numberFieldsCount: 0,
            isHosted: false,
            supportsStandardizedQuery: false,
            supportedSqlParserVersion: false,
            layer: {},
            view: this.view,
            labelClassIdx: this.labelClassIdx,
            labelClass: this.labelClass,
            featureReduction: this.featureReduction,
            strings,
            locale: currentLanguage,
            localeIntl: currentLanguageIntl,
            inputDefinitionExpression: null,
            backgroundTheme: "light",
            lastWhere: undefined,
            defaultFieldName: this.defaultFieldName,
            defaultOperator: this.defaultOperator
        };
        const [reactiveUtils, colorUtils, ImageryLayer, FeatureLayer, FeatureEffect, esriLang] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)([
            "esri/core/reactiveUtils",
            "esri/views/support/colorUtils",
            "esri/layers/ImageryLayer",
            "esri/layers/FeatureLayer",
            "esri/layers/support/FeatureEffect",
            "esri/core/lang"
        ]);
        this.reactiveUtils = reactiveUtils;
        this.colorUtils = colorUtils;
        this.ImageryLayer = ImageryLayer;
        this.FeatureLayer = FeatureLayer;
        this.FeatureEffect = FeatureEffect;
        this.esriLang = esriLang;
        const { view, layer } = this;
        let { props } = this;
        const propLayer = layer; // issue with type prop
        if (propLayer.declaredClass === "esri.layers.support.Sublayer") {
            // need to create a FeatureLayer
            const mapImageSublayer = propLayer;
            //delete this.layer;
            view && (await this.reactiveUtils.whenOnce(() => !view.updating));
            const sublayerFL = await mapImageSublayer.createFeatureLayer();
            await sublayerFL.load();
            this.props = Object.assign(Object.assign({}, props), { layer: sublayerFL, mapImageSublayer });
        }
        else if (propLayer.type === "imagery" || propLayer.type === "subtype-group") {
            this.props = Object.assign(Object.assign({}, props), { layer: propLayer });
        }
        else if (!view || (propLayer.type === "feature" && propLayer.isTable)) {
            // we need a layer without a filter for statistics, histogram, and uniqueValues
            let nonFilteredLayer;
            nonFilteredLayer = new this.FeatureLayer({
                url: propLayer.url,
                layerId: propLayer.layerId,
                popupTemplate: propLayer.popupTemplate
            });
            await nonFilteredLayer.load();
            this.props = Object.assign(Object.assign({}, props), { layer: nonFilteredLayer, originalLayer: propLayer });
        }
        else {
            this.props = Object.assign(Object.assign({}, props), { layer: propLayer });
        }
        const { labelClassIdx, labelClass, featureReduction } = this.props;
        const labelingInfo = featureReduction
            ? layer.featureReduction.labelingInfo
            : layer.labelingInfo;
        if ((isDefined(labelClassIdx) && (!labelingInfo || !labelingInfo[labelClassIdx])) ||
            (isDefined(labelClass) && (!labelingInfo || !labelingInfo.length))) {
            // error
            console.log("can't find labelClass");
            return;
        }
        this.processLayer();
    }
    componentDidLoad() {
        var _a;
        const { props, defaultExpression } = this;
        if (!((_a = props.expressions) === null || _a === void 0 ? void 0 : _a.length) && defaultExpression) {
            this.onAddExpression();
        }
        requestAnimationFrame(() => this.panelNode.setFocus());
    }
    disconnectedCallback() {
        if (this.properClose) {
            // user left the panel via Save, Cancel, or Close
            // just close popovers
            this.closeFilterPopovers.emit();
        }
        else {
            // user left the panel without clicking on Save, Cancel, or Close
            // e.g. also panel back button
            this.applyFilter();
            if (this.mode === "layer-view") {
                createIndexes(this.props);
            }
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { props, hideLayerTitle, mode, panelHeading, componentStateInvalid, dismissible, hostElement, panelMaxHeight } = this;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.g)(hostElement) === "rtl";
        const { layer, mapImageSublayer, invalidFilter, strings } = props;
        const title = mapImageSublayer ? mapImageSublayer.title : layer.title;
        if (componentStateInvalid) {
            // we removed the effect and created a definitionExpression
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null)));
        }
        if (!layer) {
            return this.renderLoading();
        }
        if (invalidFilter) {
            return this.renderInvalidFilter();
        }
        if (hostElement.parentElement.tagName === "CALCITE-FLOW" ||
            hostElement.parentElement.parentElement.tagName === "CALCITE-FLOW") {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { id: "filter-panel", loading: false, heading: panelHeading || strings.title, description: !hideLayerTitle ? title : undefined, class: {
                    [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: rtl
                }, style: panelMaxHeight && { maxHeight: panelMaxHeight }, closable: dismissible, ref: (node) => (this.panelNode = node), onCalciteFlowItemBack: () => {
                    if (mode === "layer-view") {
                        const whereClause = createWhereClause(props);
                        this.arcgisFilterPanelBackClick.emit(whereClause);
                        // create indexes on disconnect call
                    }
                    else {
                        this.arcgisFilterPanelBackClick.emit();
                    }
                }, onCalciteFlowItemClose: () => this.closeFilter() }, this.renderContent())));
        }
        else {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { id: "filter-panel", loading: false, heading: panelHeading || strings.title, description: !hideLayerTitle ? title : undefined, class: {
                    [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: rtl
                }, style: panelMaxHeight && { maxHeight: panelMaxHeight }, closable: dismissible, ref: (node) => (this.panelNode = node), onCalcitePanelClose: () => this.closeFilter() }, this.renderContent())));
        }
    }
    renderContent() {
        const { props, mode, hideButtons } = this;
        const { labelClassIdx, labelClass } = props;
        const isLabelFilter = isDefined(labelClassIdx) || isDefined(labelClass);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, !isLabelFilter && mode !== "layer-view" && !hideButtons ? this.renderSaveButton() : null, !isLabelFilter && mode !== "layer-view" && !hideButtons ? this.renderCancelButton() : null, this.renderPopoverHook(), this.renderRemoveFilter(), this.renderMatchExpressionMsg(), this.renderExpressions(), this.renderAddExpression(), this.renderTip()));
    }
    renderSaveButton() {
        const { props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.applyFilter, appearance: "solid", width: "half", label: strings.save }, strings.save));
    }
    renderCancelButton() {
        const { props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.cancelFilter, appearance: "outline-fill", width: "half", label: strings.cancel }, strings.cancel));
    }
    renderPopoverHook() {
        return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { id: "arcgis-filter-hook", class: CSS$3.hook });
    }
    renderRemoveFilter() {
        const { props, clearText } = this;
        const { strings, expressions } = props;
        if (!expressions || !expressions.length) {
            return null;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.removeFilter }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { class: "no-space", layout: "inline-space-between", scale: "m" }, clearText || strings.removeFilter, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: clearText || strings.removeFilter, scale: "m", onClick: this.onRemoveFilter }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "s", icon: "trash" })))));
    }
    renderLoading() {
        const { props, hideLayerTitle, panelHeading } = this;
        const { layer, mapImageSublayer, strings } = props;
        const title = mapImageSublayer ? mapImageSublayer.title : layer.title;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { id: "filter-panel", heading: panelHeading || strings.title, description: !hideLayerTitle ? title : undefined, loading: true, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: rtl
            } })));
    }
    renderInvalidFilter() {
        const { props, hideLayerTitle, dismissible, mode, hideButtons, panelHeading } = this;
        const { layer, mapImageSublayer, labelClassIdx, labelClass, strings } = props;
        const title = mapImageSublayer ? mapImageSublayer.title : layer.title;
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement) === "rtl";
        const isLabelFilter = isDefined(labelClassIdx) || isDefined(labelClass);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { id: "filter-panel", heading: panelHeading || strings.title, description: !hideLayerTitle ? title : undefined, loading: false, closable: dismissible, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: rtl
            }, ref: this.focusByClass, onCalcitePanelClose: () => this.closeFilter() }, !isLabelFilter && mode !== "layer-view" && !hideButtons ? this.renderSaveButton() : null, !isLabelFilter && mode !== "layer-view" && !hideButtons
            ? this.renderCancelButton()
            : null, this.renderInvalidFilterMsg(), this.renderCreateNewFilter())));
    }
    renderInvalidFilterMsg() {
        // helpId = 120001736 for LearnMore
        const { invalidHeading, invalidMsg, props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tip", { heading: invalidHeading || strings.errors.problemDisplayingFilter, closeDisabled: true }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, invalidMsg || strings.errors.problemDisplayingFilterMsg)));
    }
    renderCreateNewFilter() {
        const { props, newButtonLabel, hideButtons } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-fab", { class: {
                autofocus: true,
                "fab-padding": hideButtons
            }, slot: "fab", appearance: "outline-fill", kind: "neutral", scale: "m", textEnabled: true, label: newButtonLabel || strings.createNewFilter, text: newButtonLabel || strings.createNewFilter, onClick: this.onRemoveFilter }));
    }
    renderMatchExpressionMsg() {
        const { props } = this;
        const { expressions, logicalOperatorForExpressions, strings } = props;
        if (!expressions || !expressions.length) {
            return null;
        }
        const isAnd = logicalOperatorForExpressions === logicalOperators.AND;
        return expressions.length === 1 ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.matchExpressionMsg }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "m", class: "no-space" }, strings.oneExpressionMsg))) : ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.matchExpressionMsg }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { class: "no-space", scale: "m" }, strings.manyExpressionsMsg, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { width: "full", scale: "m", label: strings.accessibility.matchExpressions, class: CSS$3.matchExpressionDropdown, onCalciteSelectChange: this.onMatchSelect }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: logicalOperators.AND, label: strings.matchAllExpressions, selected: isAnd }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: logicalOperators.OR, label: strings.matchAtLeastOneExpression, selected: !isAnd })))));
    }
    renderExpressions() {
        const { props } = this;
        const { expressions } = props;
        if (!expressions || !expressions.length) {
            return null;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, expressions.map((expressionProps, idx) => this.renderExpression(expressionProps, idx))));
    }
    renderExpression(expressionProps, expressionIndex) {
        const { props } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, this.renderLogicalOperatorExpression(expressionIndex), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-filter-expression", Object.assign({ props: props, ref: this.focusByClass }, expressionProps))));
    }
    renderLogicalOperatorExpression(expressionIndex) {
        const { props } = this;
        const { logicalOperatorForExpressions, strings } = props;
        if (expressionIndex === 0) {
            return null;
        }
        else {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.logicalOperator }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, logicalOperatorForExpressions === logicalOperators.OR ? strings.or : strings.and)));
        }
    }
    renderAddExpression() {
        const { props, hideButtons } = this;
        const { expressions, strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-fab", { class: {
                autofocus: !expressions || !expressions.length,
                "fab-padding": hideButtons
            }, slot: "fab", appearance: "outline-fill", kind: "neutral", scale: "m", icon: "plus", textEnabled: true, text: strings.addExpression, onClick: this.onAddExpression, ref: (node) => (this.fabNode = node) }));
    }
    renderTip() {
        const { props, mode, tipHeading, tipMsg } = this;
        const { mapImageSublayer, expressions, labelClassIdx, labelClass, strings } = props;
        if (expressions === null || expressions === void 0 ? void 0 : expressions.length) {
            return null;
        }
        const forLabels = isDefined(labelClassIdx) || isDefined(labelClass);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tip", { heading: tipHeading || strings.tips.emptyMsgTitle, closeDisabled: true }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, tipMsg ||
            (forLabels
                ? strings.tips.emptyMsgLabels
                : mapImageSublayer || mode === "layer-view"
                    ? strings.tips.emptyMsgMS
                    : strings.tips.emptyMsg))));
    }
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    async processLayer() {
        var _a;
        const { props, mode, viewFilter, hideButtons } = this;
        const { layer, mapImageSublayer, originalLayer, view, labelClassIdx, labelClass, featureReduction } = props;
        const labelingInfo = layer.type === "feature" &&
            (featureReduction
                ? layer.featureReduction.labelingInfo
                : layer.labelingInfo);
        if (view &&
            !mapImageSublayer &&
            layer.type !== "imagery" &&
            layer.type !== "subtype-group" &&
            !(layer.type === "feature" && layer.isTable)) {
            props.layerView = (await view.whenLayerView(layer));
        }
        checkConfig(props);
        await buildFilterFields(props);
        buildOperatorsList(props);
        props.backgroundTheme = view && (await this.colorUtils.getBackgroundColorTheme(view));
        this.layerHasFeatureEffect = layer.featureEffect;
        if (isDefined(labelClassIdx) && labelingInfo[labelClassIdx].where) {
            props.inputDefinitionExpression = labelingInfo[labelClassIdx].where;
            const success = await parseWhereClause(props.inputDefinitionExpression, props);
            props.invalidFilter = !success;
            this.reRender = !this.reRender;
        }
        else if (isDefined(labelClass) && labelClass.where) {
            props.inputDefinitionExpression = labelClass.where;
            props.lastWhere = props.inputDefinitionExpression;
            const success = await parseWhereClause(props.inputDefinitionExpression, this.props);
            props.invalidFilter = !success;
            this.reRender = !this.reRender;
        }
        else if (mode === "layer-view") {
            // keep definitionExpression on FL, the new filter is an add-on
            if (viewFilter) {
                const success = await parseWhereClause(viewFilter, props);
                props.invalidFilter = !success;
                if (success) {
                    this.applyFilterToLayer(true);
                }
                this.reRender = !this.reRender;
            }
        }
        else if (mode === "effects") {
            props.invalidFilter = false;
            if (layer.featureEffect) {
                props.inputDefinitionExpression = (_a = layer.featureEffect.filter) === null || _a === void 0 ? void 0 : _a.where;
                props.lastWhere = props.inputDefinitionExpression;
                const success = await parseWhereClause(props.inputDefinitionExpression, props);
                props.invalidFilter = !success;
                this.reRender = !this.reRender;
            }
        }
        else if (!isDefined(labelClassIdx) &&
            !isDefined(labelClass) &&
            (isDefined(layer.definitionExpression) || isDefined(originalLayer === null || originalLayer === void 0 ? void 0 : originalLayer.definitionExpression))) {
            props.inputDefinitionExpression = (originalLayer || layer).definitionExpression;
            // apply FeatureFilter to layer
            const success = await parseWhereClause(props.inputDefinitionExpression, props);
            props.invalidFilter = !success;
            if (success) {
                this.applyFilterToLayer(true);
            }
            this.reRender = !this.reRender;
            if (view &&
                layer.type !== "imagery" &&
                layer.type !== "subtype-group" &&
                !(layer.type === "feature" && layer.isTable) &&
                !(mode === "effects" && this.layerHasFeatureEffect)) {
                // remove definitionExpression from layer
                // we use effect instead
                layer.definitionExpression = null;
            }
        }
        else if (hideButtons) {
            props.inputDefinitionExpression = layer.definitionExpression;
            props.lastWhere = props.inputDefinitionExpression;
            const success = await parseWhereClause(props.inputDefinitionExpression, this.props);
            props.invalidFilter = !success;
            this.reRender = !this.reRender;
        }
        else {
            props.invalidFilter = false;
        }
    }
    revertFilter() {
        var _a, _b, _c, _d;
        const { props, mode, viewFilter } = this;
        const { layer, layerView, featureReduction, labelClassIdx, labelClass, inputDefinitionExpression, mapImageSublayer, originalLayer, backgroundTheme } = props;
        const index = this.getLabelClassIndex();
        // apply original expression
        if (layer.type !== "imagery" && layer.type !== "subtype-group" && isDefined(labelClassIdx)) {
            const labelingInfo = featureReduction
                ? layer.featureReduction.labelingInfo
                : layer.labelingInfo;
            labelingInfo[labelClassIdx].where = inputDefinitionExpression;
            // refresh layer
            if (featureReduction) {
                layer.featureReduction = this.esriLang.clone(layer.featureReduction);
                props.labelClass = layer.featureReduction.labelingInfo[index];
            }
            else {
                layer.labelingInfo = layer.labelingInfo;
            }
            if (mapImageSublayer) {
                mapImageSublayer.labelingInfo = layer.labelingInfo;
            }
        }
        else if (layer.type !== "imagery" &&
            layer.type !== "subtype-group" &&
            isDefined(labelClass)) {
            labelClass.where = inputDefinitionExpression;
            // refresh layer
            if (featureReduction) {
                layer.featureReduction = this.esriLang.clone(layer.featureReduction);
                props.labelClass = layer.featureReduction.labelingInfo[index];
            }
            else {
                layer.labelingInfo = layer.labelingInfo;
            }
            if (mapImageSublayer) {
                mapImageSublayer.labelingInfo = layer.labelingInfo;
            }
        }
        else if (mode === "layer-view") {
            // set back to passed in viewFilter
            if (layer.type === "feature") {
                if (viewFilter) {
                    if (!isEffectEmpty(layer.featureEffect)) {
                        layer.featureEffect.filter.where = viewFilter;
                    }
                    else {
                        const brightness = backgroundTheme === "light" ? 100 : 65;
                        layer.featureEffect = new this.FeatureEffect({
                            filter: {
                                where: viewFilter
                            },
                            excludedEffect: `grayscale(100%) opacity(30%) brightness(${brightness}%)`
                        });
                    }
                }
                else {
                    if ((_b = (_a = layer.featureEffect) === null || _a === void 0 ? void 0 : _a.filter) === null || _b === void 0 ? void 0 : _b.where) {
                        layer.featureEffect.filter.where = null;
                        if (isEffectEmpty(layer.featureEffect)) {
                            layer.featureEffect = null;
                        }
                    }
                    else {
                        layer.featureEffect = null;
                    }
                }
            }
        }
        else if (mode === "effects") ;
        else if (layer) {
            if (mapImageSublayer) {
                mapImageSublayer.definitionExpression = inputDefinitionExpression;
            }
            else {
                (originalLayer || layer).definitionExpression = inputDefinitionExpression;
            }
            if (this.isAllowedFeatureEffect()) {
                const anyLayer = layer;
                if ((_d = (_c = anyLayer.featureEffect) === null || _c === void 0 ? void 0 : _c.filter) === null || _d === void 0 ? void 0 : _d.where) {
                    anyLayer.featureEffect.filter.where = null;
                    if (isEffectEmpty(anyLayer.featureEffect)) {
                        anyLayer.featureEffect = null;
                    }
                }
            }
            else {
                if (layerView && "filter" in layerView) {
                    layerView.filter = null;
                }
            }
            // switched to definitionExpression from effect/layerView.filter
            this.componentStateInvalid = true;
        }
    }
    applyFilterToLayer(isInit) {
        var _a, _b;
        const { props, layerViewWaitHandler, hideButtons } = this;
        const { backgroundTheme, labelClass, layer, labelClassIdx, view, layerView, mapImageSublayer, originalLayer, featureReduction, lastWhere } = props;
        const where = createWhereClause(props) || undefined;
        if (!isInit && where !== lastWhere) {
            this.arcgisFilterWhereChange.emit(where);
        }
        props.lastWhere = where;
        if (layer.type === "feature" && isDefined(labelClassIdx)) {
            const index = this.getLabelClassIndex();
            const labelingInfo = featureReduction
                ? layer.featureReduction.labelingInfo
                : layer.labelingInfo;
            labelingInfo[labelClassIdx].where = where;
            // refresh layer
            if (featureReduction) {
                layer.featureReduction = this.esriLang.clone(layer.featureReduction);
                props.labelClass = layer.featureReduction.labelingInfo[index];
            }
            else {
                layer.labelingInfo = layer.labelingInfo;
            }
            if (mapImageSublayer) {
                mapImageSublayer.labelingInfo = layer.labelingInfo;
            }
            //console.log("apply", where, layer.labelingInfo);
            return;
        }
        else if (isDefined(labelClass)) {
            // we don't update the layer at all
            return;
        }
        else if (layer.type === "imagery" || layer.type === "subtype-group") {
            layer.definitionExpression = where;
            return;
        }
        else if (hideButtons) {
            // we don't update the layer at all
            return;
        }
        if (mapImageSublayer) {
            mapImageSublayer.definitionExpression = where;
            return;
        }
        else if (!view || (layer.type === "feature" && layer.isTable)) {
            originalLayer.definitionExpression = createWhereClause(props);
            return;
        }
        // use effect
        if (layerViewWaitHandler) {
            clearTimeout(layerViewWaitHandler);
            this.layerViewWaitHandler = undefined;
        }
        if (!layerView) {
            // we need to wait and try later
            this.layerViewWaitHandler = setTimeout(() => {
                this.applyFilterToLayer();
            }, 500);
            return;
        }
        //console.log("FeatureEffect.filter:", whereClause);
        if (where === null || where === void 0 ? void 0 : where.length) {
            if (this.isAllowedFeatureEffect()) {
                if (!isEffectEmpty(layer.featureEffect)) {
                    layer.featureEffect.filter = layer.featureEffect.filter || {};
                    layer.featureEffect.filter.where = where;
                }
                else {
                    const brightness = backgroundTheme === "light" ? 100 : 65;
                    layer.featureEffect = new this.FeatureEffect({
                        filter: {
                            where
                        },
                        excludedEffect: `grayscale(100%) opacity(30%) brightness(${brightness}%)`
                    });
                }
            }
            else if ("filter" in layerView) {
                layerView.filter = {
                    where
                };
            }
        }
        else {
            if (this.isAllowedFeatureEffect()) {
                if ((_b = (_a = layer.featureEffect) === null || _a === void 0 ? void 0 : _a.filter) === null || _b === void 0 ? void 0 : _b.where) {
                    layer.featureEffect.filter.where = null;
                    if (isEffectEmpty(layer.featureEffect)) {
                        layer.featureEffect = null;
                    }
                }
            }
            else if ("filter" in layerView) {
                layerView.filter = null;
            }
        }
    }
    isAllowedFeatureEffect() {
        // Ideally we want to filter out features via layer.featureEffect
        // so that filtered out features show dimmed.
        // But if this is not possible use layerView.filter
        // so filtered out features are hidden.
        // Layer.definitionExpression affects the server queries
        // so only apply this when leaving the component
        const { props, layerHasFeatureEffect, mode } = this;
        const { layer } = props;
        return (["feature", "geojson", "ogc-feature", "wfs", "csv", "stream"].indexOf(layer.type) > -1 &&
            !layer.featureReduction &&
            mode !== "effects" &&
            (!layerHasFeatureEffect || mode === "layer-view"));
    }
    getLabelClassIndex() {
        const { props } = this;
        const { layer, labelClass, featureReduction } = props;
        let index = -1;
        const labelingInfo = layer.type === "feature" &&
            (featureReduction
                ? layer.featureReduction.labelingInfo
                : layer.labelingInfo);
        if (labelClass) {
            labelingInfo.forEach((lClass, idx) => {
                if (JSON.stringify(lClass.toJSON()) === JSON.stringify(labelClass.toJSON())) {
                    index = idx;
                }
            });
        }
        return index;
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisFilter.style = arcgisFilterCss;

const CSS$2 = {
    condition: "filter-condition",
    operatorDropdown: "operator-dropdown",
    inputPlusUnique: "input-plus-unique",
    input: "input",
    blankButton: "blank-button",
    selectUniqueButton: "select-unique-button",
    betweenValuesInput: "between-values-input",
    selectValues: "select-values",
    pickList: "pick-list",
    uniqueValuesContentListMsg: "unique-values-content-list-msg",
    inTheLast: "in-the-last",
    inTheLastCount: "in-the-last-count",
    inTheLastUnit: "in-the-last-unit",
    datePicker: "date-picker",
    histogramContent: "histogram-content",
    histogramContentSlim: "histogram-content-slim",
    smallLoader: "small-loader"
};

const arcgisFilterConditionCss = ".filter-condition.sc-arcgis-filter-condition{padding:0 6px}.operator-dropdown.sc-arcgis-filter-condition{width:100%;margin:5px 0}.input-plus-unique.sc-arcgis-filter-condition{display:flex;flex-direction:row;width:100%}.input.sc-arcgis-filter-condition{width:100%}.blank-button.sc-arcgis-filter-condition{height:22px;border:var(--calcite-color-border-input) 1px solid}.blank-button.active.sc-arcgis-filter-condition{cursor:pointer}.blank-button.inactive.sc-arcgis-filter-condition:focus{outline:none}.select-unique-button.sc-arcgis-filter-condition{height:32px;border-top:var(--calcite-color-border-input) 1px solid;border-bottom:var(--calcite-color-border-input) 1px solid;border-right:var(--calcite-color-border-input) 1px solid}.arcgis--rtl.sc-arcgis-filter-condition .select-unique-button.sc-arcgis-filter-condition{border-right:none;border-left:var(--calcite-color-border-input) 1px solid}.between-values-input.first.sc-arcgis-filter-condition{margin-bottom:5px}.select-values.sc-arcgis-filter-condition{margin-bottom:4px}.pick-list.sc-arcgis-filter-condition{max-height:200px;overflow-y:auto}.unique-values-content-list-msg.sc-arcgis-filter-condition{font-size:90%;margin-top:5px;margin-bottom:5px}.in-the-last.sc-arcgis-filter-condition{display:flex}.in-the-last-count.sc-arcgis-filter-condition{width:50%}.in-the-last-unit.sc-arcgis-filter-condition{width:50%}.date-picker.sc-arcgis-filter-condition{width:100%}.date-picker.first.sc-arcgis-filter-condition{margin-bottom:5px}.histogram-content.sc-arcgis-filter-condition{height:120px;margin-top:5px}.histogram-content-slim.sc-arcgis-filter-condition{height:40px;margin-top:5px}.small-loader.sc-arcgis-filter-condition{margin-left:calc((100% - 16px) / 2);margin-top:10px}html[dir=rtl].sc-arcgis-filter-condition .small-loader.sc-arcgis-filter-condition{margin-left:auto;margin-right:8px}";

const ArcgisFilterCondition = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisFilterConditionChanged = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterConditionChanged", 7);
        this.disableFilterPanel = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "disableFilterPanel", 7);
        this.arcgisFilterUniqueValuesReturned = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterUniqueValuesReturned", 7);
        this.histogramSlider = undefined;
        this.afterCreateSliderDiv = (element) => {
            const { fieldName, props, histogramSlider } = this;
            if (!element) {
                // not sure why that happens
                return;
            }
            setTimeout(() => {
                if (!histogramSlider) {
                    // should not happen
                    return;
                }
                const divNode = document.createElement("div");
                element.appendChild(divNode);
                if (!histogramSlider.container) {
                    histogramSlider.container = divNode;
                }
                else {
                    // need to recreate the slider
                    const filterField = getFieldInfo(fieldName, props);
                    if (!filterField) {
                        return;
                    }
                    const { bins, average, min, max, values, precision, rangeType } = histogramSlider;
                    const config = {
                        container: divNode,
                        bins,
                        average,
                        //standardDeviation,
                        min,
                        max,
                        values,
                        precision,
                        rangeType
                    };
                    if ([simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) >
                        -1) {
                        config.hasTimeData = true;
                        this.addDateFormatFunctions(config);
                    }
                    //console.log("re-create HistogramRangeSlider", config);
                    histogramSlider.destroy();
                    this.histogramSlider = new this.HistogramRangeSlider(config);
                    this.createSliderChangeEvents(filterField);
                }
            }, 1);
        };
        this.onFieldSelect = () => {
            this.hasFocus = true;
            this.openFieldPickList();
        };
        this.onOperatorSelect = (event) => {
            var _a, _b, _c, _d;
            const { props, fieldName, operator, value, value2 } = this;
            const select = event.target;
            const newOperator = select.selectedOption.value;
            const filterField = getFieldInfo(fieldName, props);
            const oldInTheLast = isInTheLastOperator(props, operator);
            const newInTheLast = isInTheLastOperator(props, newOperator);
            const oneInTheLast = oldInTheLast || newInTheLast;
            const bothInTheLast = oldInTheLast && newInTheLast;
            const oldBetween = isBetweenOperator(props, operator);
            const newBetween = isBetweenOperator(props, newOperator);
            const bothBetween = oldBetween && newBetween;
            //const oldInExclude = isIncludesOperator(props, operator) || isExcludesOperator(props, operator);
            //const newInExclude =
            //  isIncludesOperator(props, newOperator) || isExcludesOperator(props, newOperator);
            //const bothInExclude = oldInExclude && newInExclude;
            const old = {
                value,
                value2,
                operator
            };
            this.value =
                oneInTheLast && !bothInTheLast
                    ? null
                    : filterField.statistics && !isDefined(value)
                        ? filterField.statistics.avg
                        : value;
            this.value2 = newBetween
                ? value2 !== null && value2 !== void 0 ? value2 : (isIntegerType(filterField)
                    ? Math.round((_a = filterField.statistics) === null || _a === void 0 ? void 0 : _a.max)
                    : (_b = filterField.statistics) === null || _b === void 0 ? void 0 : _b.max)
                : oneInTheLast || !bothBetween
                    ? null
                    : value2;
            this.operator = newOperator;
            const defaultValues = this.checkDefaultValues(filterField);
            const updates = {
                value: (_c = this.value) !== null && _c !== void 0 ? _c : defaultValues.value,
                value2: (_d = this.value2) !== null && _d !== void 0 ? _d : (newBetween ? defaultValues.value2 : null),
                operator: this.operator
            };
            // set it back - TODO, need to find a better way after 9.1
            // if I modify local props the component won't re-render with emitChangeEvent()
            this.value = old.value;
            this.value2 = old.value2;
            this.operator = old.operator;
            this.emitChangeEvent(updates);
        };
        this.onValueChangeMaybe = (event) => {
            const { props, operator, value2 } = this;
            const newValue = this.getNewValue(event);
            if (isDefined(newValue) && isBetweenOperator(props, operator) && newValue >= value2) {
                // we assume the user is in the middle of typing
                return;
            }
            this.onValueChange(event, newValue);
        };
        this.onValueChange = (event, newValue) => {
            const { props, fieldName, operator, value, value2 } = this;
            const { view } = props;
            const timeZone = (view === null || view === void 0 ? void 0 : view.timeZone) || "system";
            const filterField = getFieldInfo(fieldName, props);
            const node = event === null || event === void 0 ? void 0 : event.target;
            newValue = event ? this.getNewValue(event) : newValue;
            if (!isDefined(newValue)) {
                // we need to have a value
                // fall back to default values
                const defaultValues = getDefaultValues(props, filterField, operator);
                newValue = defaultValues.value;
                if (node) {
                    if (filterField.simpleFieldType === simpleFieldTypes.DATE) {
                        node.value = utcToDatePicker(newValue, timeZone);
                    }
                    else {
                        node.value = newValue;
                    }
                }
            }
            if (value === newValue) {
                return;
            }
            if (isDefined(newValue) && isBetweenOperator(props, operator) && newValue >= value2) {
                // user finished typing, let's fix the values
                if (node) {
                    if (filterField.simpleFieldType === simpleFieldTypes.DATE) {
                        newValue = value2 - 1;
                        node.value = utcToDatePicker(newValue, timeZone);
                    }
                    else if (filterField.simpleFieldType === simpleFieldTypes.DATE_ONLY) {
                        const prevDay = new Date(new Date(value2).getTime() - 86400000 + new Date().getTimezoneOffset() * 60000);
                        newValue = `${prevDay.getFullYear()}-${prevDay.getMonth() < 9 ? "0" : ""}${prevDay.getMonth() + 1}-${prevDay.getDate() < 10 ? "0" : ""}${prevDay.getDate()}`;
                        node.value = newValue;
                    }
                    else {
                        newValue = value2 - 1;
                        node.value = newValue;
                    }
                }
            }
            if ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-INPUT-DATE-PICKER" ||
                ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-INPUT" && (node === null || node === void 0 ? void 0 : node.type) === "number")) {
                this.adjustHistogramMinMax(newValue);
            }
            this.changeValues(newValue, value2);
        };
        this.onValue2ChangeMaybe = (event) => {
            const { props, operator, value } = this;
            const newValue = this.getNewValue(event);
            if (isDefined(newValue) && isBetweenOperator(props, operator) && newValue <= value) {
                // we assume the user is in the middle of typing
                return;
            }
            this.onValue2Change(event, newValue);
        };
        this.onValue2Change = (event, newValue) => {
            const { value, props, fieldName, operator } = this;
            const { view } = props;
            const timeZone = (view === null || view === void 0 ? void 0 : view.timeZone) || "system";
            const filterField = getFieldInfo(fieldName, props);
            const node = event.target;
            newValue = newValue !== null && newValue !== void 0 ? newValue : this.getNewValue(event);
            if (!isDefined(newValue)) {
                // we need to have a value
                // fall back to default values
                const defaultValues = getDefaultValues(props, filterField, operator);
                newValue = defaultValues.value2;
                if (filterField.simpleFieldType === simpleFieldTypes.DATE) {
                    node.value = utcToDatePicker(newValue, timeZone);
                }
                else {
                    node.value = newValue;
                }
            }
            // we're using between operator
            if (newValue <= value) {
                // user finished typing, let's fix the values
                if (filterField.simpleFieldType === simpleFieldTypes.DATE) {
                    newValue = value + 1;
                    node.value = utcToDatePicker(newValue, timeZone);
                }
                else if (filterField.simpleFieldType === simpleFieldTypes.DATE_ONLY) {
                    const nextDay = new Date(new Date(value).getTime() + 86400000 + new Date().getTimezoneOffset() * 60000);
                    newValue = `${nextDay.getFullYear()}-${nextDay.getMonth() < 9 ? "0" : ""}${nextDay.getMonth() + 1}-${nextDay.getDate() < 10 ? "0" : ""}${nextDay.getDate()}`;
                    node.value = newValue;
                }
                else {
                    newValue = value + 1;
                    node.value = newValue;
                }
            }
            if (node.tagName === "CALCITE-INPUT-DATE-PICKER" ||
                (node.tagName === "CALCITE-INPUT" && node.type === "number")) {
                this.adjustHistogramMinMax(newValue);
            }
            this.changeValues(value, newValue);
        };
        this.onUnitSelect = (event) => {
            const select = event.target;
            //this.unit = select.selectedOption.value as timeUnits;
            this.emitChangeEvent({ unit: select.selectedOption.value });
        };
        this.onSelectUniqueValue = () => {
            this.onSelectUnique(false);
        };
        this.onSelectUniqueValues = () => {
            const { props, fieldName, operator } = this;
            const filterField = getFieldInfo(fieldName, props);
            const fieldDomains = hasFieldDomains(filterField);
            const listOperator = isListOperator(props, operator);
            const isDomainSingle = fieldDomains && !listOperator;
            this.onSelectUnique(!isDomainSingle);
        };
        this.onDocumentClick = (event) => {
            const target = event.target;
            const isTargetInsidePopover = target.closest(`#arcgis-filter-unique-popover_${this.uid}`);
            if (!isTargetInsidePopover) {
                this.removeUniquePopover();
            }
        };
        this.onRemoveSelectedValue = (value) => {
            const { values, esriLang } = this;
            const idx = values.indexOf(value);
            values.splice(idx, 1);
            //this.values = values.length ? esriLang.clone(values) : undefined;
            this.emitChangeEvent({ values: values.length ? esriLang.clone(values) : null });
        };
        this.afterCreateList = (element) => {
            if (!element) {
                return;
            }
            this.scrollExprIntoView(element);
        };
        this.onHistogramBlockToggle = (event) => {
            if (event.currentTarget.open) {
                this.onHistogramOpen();
            }
            else {
                this.onHistogramClose();
            }
        };
        this.fieldPickListChanges = (event) => {
            var _a, _b;
            event.stopPropagation();
            const selectedField = (_b = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.selectedFields) === null || _b === void 0 ? void 0 : _b[0];
            this.removeFieldsPickList();
            if (selectedField) {
                this.afterFieldSelect(selectedField);
            } // else user hit cancel or close
        };
        this.props = undefined;
        this.uid = undefined;
        this.fieldName = undefined;
        this.operator = undefined;
        this.uniqueValuesSortBy = undefined;
        this.value = undefined;
        this.value2 = undefined;
        this.values = undefined;
        this.unit = undefined;
        this.histogramOpen = undefined;
        this.hasFocus = undefined;
        this.invalidValue = undefined;
        this.reRender = false;
    }
    arcgisFilterUniqueValuesReturnedHandler(event) {
        const fieldName = event.detail;
        if (this.fieldName === fieldName) {
            this.checkDefaultValues(getFieldInfo(fieldName, this.props));
            this.reRender = !this.reRender;
        }
    }
    arcgisFilterUniqueListChangedHandler(event) {
        var _a;
        const { detail } = event;
        const uid = detail.uid;
        if (uid === this.uid) {
            const selectedValues = detail.selectedValues;
            if (!detail.multiple) {
                this.uniqueValuesSortBy = detail.sortBy;
                this.onValueChange(null, (selectedValues === null || selectedValues === void 0 ? void 0 : selectedValues.length) ? selectedValues[0] : undefined);
                this.removeUniquePopover();
                (_a = this.uniqueActionNode) === null || _a === void 0 ? void 0 : _a.setFocus();
            }
            else {
                this.emitChangeEvent({ values: selectedValues, uniqueValuesSortBy: detail.sortBy });
            }
        }
    }
    arcgisFilterUniqueListSortByChanged(event) {
        const { detail } = event;
        const uid = detail.uid;
        if (uid === this.uid) {
            this.uniqueValuesSortBy = detail.sortBy;
        }
    }
    arcgisFilterUniqueListDoneHandler(event) {
        var _a;
        const { detail } = event;
        if (detail === this.uid) {
            this.removeUniquePopover();
            (_a = this.uniqueActionNode) === null || _a === void 0 ? void 0 : _a.setFocus();
        }
    }
    calcitePopoverCloseHandler() {
        var _a;
        if (this.uniquePopoverNode) {
            this.removeUniquePopover();
            (_a = this.uniqueActionNode) === null || _a === void 0 ? void 0 : _a.setFocus();
        } // else something else removed the popover
    }
    closeFilterPopoversHandler() {
        this.removeFieldsPickList();
        this.removeUniquePopover();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const defaultField = getDefaultField({
            fields: this.props.fields
        });
        this.fieldName = this.fieldName || defaultField.layerField.name;
        this.operator = this.operator || getDefaultOperator(this.props, defaultField);
        this.hasFocus = !!this.hasFocus;
        const [esriLang, intl, 
        //smartMappingUtils,
        summaryStatistics, histogram, uniqueValues, HistogramRangeSlider] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)([
            "esri/core/lang",
            "esri/intl",
            //"esri/widgets/smartMapping/support/utils",
            "esri/smartMapping/statistics/summaryStatistics",
            "esri/smartMapping/statistics/histogram",
            "esri/smartMapping/statistics/uniqueValues",
            "esri/widgets/HistogramRangeSlider"
        ]);
        this.esriLang = esriLang;
        this.intl = intl;
        //this.smartMappingUtils = smartMappingUtils;
        this.summaryStatistics = summaryStatistics;
        this.histogram = histogram;
        this.uniqueValues = uniqueValues;
        this.HistogramRangeSlider = HistogramRangeSlider;
        this.onDocumentClickBind = this.onDocumentClick.bind(this);
    }
    componentDidLoad() {
        this.setFocus();
    }
    disconnectedCallback() {
        this.removeFieldsPickList();
        this.removeUniquePopover();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { fieldName, props } = this;
        const filterField = getFieldInfo(fieldName, props);
        /* console.log(
          "** render condition **",
          "uid",
          this.uid,
          "fieldName",
          this.fieldName,
          "operator",
          this.operator,
          "uniqueValuesSortBy",
          this.uniqueValuesSortBy,
          "value",
          this.value,
          "value2",
          this.value2,
          "values",
          this.values,
          "unit",
          this.unit,
          "histogramOpen",
          this.histogramOpen,
          "hasFocus",
          this.hasFocus,
          "histogramStatus",
          filterField.histogramStatus,
          "uniqueValuesStatus",
          filterField.uniqueValuesStatus,
          "reRender",
          this.reRender
        ); */
        if (!filterField || !filterField.simpleFieldType) {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null)));
        }
        const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { dir: dir }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: {
                [CSS$2.condition]: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: dir === "rtl"
            } }, this.renderFieldSelection(), this.renderOperatorSelection(filterField), this.renderValueInput(filterField), this.renderHistogram(filterField))));
    }
    renderFieldSelection() {
        const { hasFocus, fieldName, props } = this;
        const { fields } = props;
        const field = getFieldInfo(fieldName, props);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "outline-fill", kind: "neutral", width: "full", scale: "m", alignment: "icon-end-space-between", disabled: fields.length <= 1, iconEnd: "chevron-down", class: `${hasFocus ? "autofocus" : ""}`, onClick: fields.length > 1 ? this.onFieldSelect : null, ref: (node) => (this.fieldNode = node) }, (field === null || field === void 0 ? void 0 : field.label) || ""));
    }
    renderOperatorSelection(filterField) {
        const { props } = this;
        const { operators, strings } = props;
        // TODO - also check field value type ?
        let type = filterField.simpleFieldType;
        if (!type) {
            return null;
        }
        if (type === simpleFieldTypes.GUID) {
            type = simpleFieldTypes.STRING;
        }
        if (type === simpleFieldTypes.OID) {
            type = simpleFieldTypes.NUMBER;
        }
        if (hasFieldDomains(filterField)) {
            type = simpleFieldTypes.DOMAIN;
        }
        const optionNodes = operators[type].map((operator) => this.renderOperatorOption(operator.name));
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { width: "full", scale: "m", label: strings.accessibility.operator, class: CSS$2.operatorDropdown, onCalciteSelectChange: this.onOperatorSelect }, optionNodes));
    }
    renderOperatorOption(rendererOperator) {
        const { operator } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: rendererOperator, label: rendererOperator, selected: rendererOperator === operator }));
    }
    renderValueInput(filterField) {
        const { props, operator, invalidValue } = this;
        const status = invalidValue ? "invalid" : undefined;
        let contentNode = null;
        if (isBlankOperator(props, operator) || isEmptyOperator(props, operator)) {
            contentNode = null;
        }
        else if (isListOperator(props, operator)) {
            contentNode = this.renderUniqueValues(filterField);
        }
        else if (isInTheLastOperator(props, operator)) {
            contentNode = this.renderInTheLast();
        }
        else if (filterField.simpleFieldType === simpleFieldTypes.STRING ||
            filterField.simpleFieldType === simpleFieldTypes.GUID ||
            hasFieldDomains(filterField)) {
            contentNode = this.renderValueInputString(filterField, { status });
        }
        else if (filterField.simpleFieldType === simpleFieldTypes.NUMBER) {
            contentNode = this.renderValueInputNumber(filterField, { status });
        }
        else if ([simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) > -1) {
            contentNode = this.renderValueInputDate(filterField);
        }
        else if (filterField.simpleFieldType === simpleFieldTypes.OID) {
            contentNode = this.renderValueInputOid(filterField, { status });
        }
        return invalidValue ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, contentNode, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-message", { icon: true, status: status }, invalidValue))) : (contentNode);
    }
    renderUniqueButton(supportsUnique, disabled, loading) {
        const { props } = this;
        const { layer, strings } = props;
        if (!supportsUnique || layer.type === "imagery" || layer.type === "subtype-group") {
            return null;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { class: CSS$2.selectUniqueButton, disabled: disabled, loading: !!loading, text: strings.chooseFromUnique, scale: "s", icon: "chevron-down", onClick: !disabled ? this.onSelectUniqueValue : null, ref: (node) => {
                if (node) {
                    this.uniqueActionNode = node;
                } // else no idea why this happens - TODO (set of 3 + 1 expr)
            } }));
    }
    renderValueInputString(filterField, inputOptions) {
        const { props, value, operator } = this;
        const { strings } = props;
        const uvStatus = filterField.uniqueValuesStatus;
        const uniqueValues = filterField.uniqueValueInfos;
        const supportsUnique = [strings.operators.stringOperatorIs, strings.operators.stringOperatorIsNot].indexOf(operator) > -1;
        const disabledUnique = supportsUnique &&
            (uvStatus === status.FAILED || (uvStatus === status.SUCCESS && !(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length)));
        const hasDomains = hasFieldDomains(filterField);
        const val = hasDomains ? getDecodedValue(value, filterField) : value;
        const loadingUnique = uvStatus === status.MISSING || uvStatus === status.IN_PROGRESS;
        if (uvStatus === status.MISSING) {
            this.onDisplayUniqueValues(filterField.layerField.name);
        }
        return hasDomains ? (isDefined(val) ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-string" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { key: val, appearance: "outline-fill", kind: "neutral", width: "full", scale: "m", alignment: "icon-end-space-between", iconEnd: loadingUnique ? "spinner" : disabledUnique ? undefined : "chevron-down", disabled: disabledUnique, onClick: !disabledUnique ? this.onSelectUniqueValue : undefined, ref: (node) => {
                if (node) {
                    this.uniqueActionNode = node;
                } // else no idea why this happens - TODO (set of 3 + 1 expr)
            } }, val ? `${val}` : ``))) : (
        // calcite-button must have text or icon, otherwise width is too small,
        // so use a div instead
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-string", class: CSS$2.inputPlusUnique }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-string-button", class: `${CSS$2.input} ${CSS$2.blankButton} ${uvStatus === status.SUCCESS ? `active` : `inactive`}`, tabIndex: -1, onClick: uvStatus === status.SUCCESS ? this.onSelectUniqueValue : undefined }), this.renderUniqueButton(supportsUnique, disabledUnique, loadingUnique)))) : ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-string", class: CSS$2.inputPlusUnique }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ type: "text", value: val ? `${val}` : ``, class: CSS$2.input, scale: "m", label: strings.accessibility.value, onCalciteInputInput: this.onValueChange }, inputOptions)), this.renderUniqueButton(supportsUnique, disabledUnique, loadingUnique)));
    }
    renderValueInputNumber(filterField, inputOptions) {
        var _a;
        const { props, value, value2, operator } = this;
        const { strings } = props;
        const isFloat = isFloatType(filterField);
        if ([
            strings.operators.numberOperatorIsBetween,
            strings.operators.numberOperatorIsNotBetween
        ].indexOf(operator) > -1) {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ type: "number", value: isDefined(value) ? `${value}` : ``, scale: "m", step: isFloat ? "any" : 1, label: strings.accessibility.fromValue, onCalciteInputInput: (event) => this.waitOnUser(event, this.onValueChangeMaybe) }, inputOptions)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `${CSS$2.betweenValuesInput} first` }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ type: "number", value: isDefined(value2) ? `${value2}` : ``, scale: "m", step: isFloat ? "any" : 1, class: CSS$2.betweenValuesInput, label: strings.accessibility.toValue, onCalciteInputInput: (event) => this.waitOnUser(event, this.onValue2ChangeMaybe) }, inputOptions))));
        }
        else {
            const uvStatus = filterField.uniqueValuesStatus;
            const uniqueValues = filterField.uniqueValueInfos;
            const supportsUnique = [
                strings.operators.numberOperatorIs,
                strings.operators.numberOperatorIsNot,
                strings.operators.numberOperatorIsAtLeast,
                strings.operators.numberOperatorIsAtMost,
                strings.operators.numberOperatorIsGreaterThan,
                strings.operators.numberOperatorIsLessThan
            ].indexOf(operator) > -1;
            const inputNode = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ class: CSS$2.input, type: "number", value: isDefined(value) ? `${value}` : ``, scale: "m", step: isFloat ? "any" : 1, label: strings.accessibility.value, onCalciteInputInput: (event) => this.waitOnUser(event, this.onValueChange) }, inputOptions)));
            if (uvStatus === status.FAILED ||
                (uvStatus === status.SUCCESS && !(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length)) ||
                !supportsUnique) {
                return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-number" }, inputNode);
            }
            else if (uvStatus === status.MISSING || uvStatus === status.IN_PROGRESS) {
                if (uvStatus === status.MISSING) {
                    this.onDisplayUniqueValues(filterField.layerField.name);
                }
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-number", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, true, true)));
            }
            else {
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-number", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, !((_a = filterField.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length))));
            }
        }
    }
    renderValueInputDate(filterField) {
        var _a;
        const { props, value, value2, operator } = this;
        const { view, strings } = props;
        const timeZone = (view === null || view === void 0 ? void 0 : view.timeZone) || "system";
        const dateString = typeof value === "number" ? utcToDatePicker(value, timeZone) : value;
        if ([strings.operators.dateOperatorIsBetween, strings.operators.dateOperatorIsNotBetween].indexOf(operator) > -1) {
            const dateString2 = typeof value2 === "number" ? utcToDatePicker(value2, timeZone) : value2;
            // not using range option, because there is no equivalent for number fields
            // and 'not in between' might be weird if the between area is highlighted in the calendar
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-date-picker", { class: `${CSS$2.datePicker} first`, scale: "m", value: dateString, overlayPositioning: "fixed", onCalciteInputDatePickerChange: this.onValueChange }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-date-picker", { class: CSS$2.datePicker, scale: "m", value: dateString2, overlayPositioning: "fixed", onCalciteInputDatePickerChange: this.onValue2Change })));
        }
        else {
            const uvStatus = filterField.uniqueValuesStatus;
            const uniqueValues = filterField.uniqueValueInfos;
            const supportsUnique = [
                strings.operators.dateOperatorIsOn,
                strings.operators.dateOperatorIsNotOn,
                strings.operators.dateOperatorIsAfter,
                strings.operators.dateOperatorIsBefore
            ].indexOf(operator) > -1;
            const inputNode = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-date-picker", { class: `${CSS$2.datePicker} ${CSS$2.input}`, scale: "m", value: dateString, overlayPositioning: "fixed", onCalciteInputDatePickerChange: this.onValueChange }));
            if (uvStatus === status.FAILED ||
                (uvStatus === status.SUCCESS && !(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length)) ||
                !supportsUnique) {
                return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-date" }, inputNode);
            }
            else if (uvStatus === status.MISSING || uvStatus === status.IN_PROGRESS) {
                if (uvStatus === status.MISSING) {
                    this.onDisplayUniqueValues(filterField.layerField.name);
                }
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-date", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, true, true)));
            }
            else {
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-date", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, !((_a = filterField.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length))));
            }
        }
    }
    renderValueInputOid(filterField, inputOptions) {
        var _a;
        const { props, value, value2, operator } = this;
        const { strings } = props;
        if (filterField.simpleFieldType === simpleFieldTypes.OID) {
            // we don't allow decimals
            if (isDefined(value) && isDefined(value2)) {
                const roundedVal = Math.round(value);
                const roundedVal2 = Math.round(value2);
                if (roundedVal !== value || roundedVal2 !== value2) {
                    this.changeValues(roundedVal, roundedVal2);
                }
            }
            else if (isDefined(value)) {
                const roundedVal = Math.round(value);
                if (roundedVal !== value) {
                    this.changeValues(roundedVal, value2);
                }
            }
            else if (isDefined(value2)) {
                const roundedVal = Math.round(value2);
                if (roundedVal !== value2) {
                    this.changeValues(value, roundedVal);
                }
            }
        }
        if ([
            strings.operators.numberOperatorIsBetween,
            strings.operators.numberOperatorIsNotBetween
        ].indexOf(operator) > -1) {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ type: "number", value: isDefined(value) ? `${value}` : ``, scale: "m", min: 0, step: 1, label: strings.accessibility.fromValue, onCalciteInputInput: this.onValueChangeMaybe }, inputOptions)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `${CSS$2.betweenValuesInput} first` }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ type: "number", value: isDefined(value2) ? `${value2}` : ``, scale: "m", min: 0, step: 1, class: CSS$2.betweenValuesInput, label: strings.accessibility.toValue, onCalciteInputInput: this.onValue2ChangeMaybe }, inputOptions))));
        }
        else {
            const uvStatus = filterField.uniqueValuesStatus;
            const uniqueValues = filterField.uniqueValueInfos;
            const supportsUnique = [
                strings.operators.numberOperatorIs,
                strings.operators.numberOperatorIsNot,
                strings.operators.numberOperatorIsAtLeast,
                strings.operators.numberOperatorIsAtMost,
                strings.operators.numberOperatorIsGreaterThan,
                strings.operators.numberOperatorIsLessThan
            ].indexOf(operator) > -1;
            const inputNode = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ class: CSS$2.input, type: "number", value: isDefined(value) ? `${value}` : ``, scale: "m", min: 0, step: 1, label: strings.accessibility.value, onCalciteInputInput: this.onValueChange }, inputOptions)));
            if (uvStatus === status.FAILED ||
                (uvStatus === status.SUCCESS && !(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length)) ||
                !supportsUnique) {
                return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-oid" }, inputNode);
            }
            else if (uvStatus === status.MISSING || uvStatus === status.IN_PROGRESS) {
                if (uvStatus === status.MISSING) {
                    this.onDisplayUniqueValues(filterField.layerField.name);
                }
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-oid", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, true, true)));
            }
            else {
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-oid", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, !((_a = filterField.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length))));
            }
        }
    }
    renderUniqueValues(filterField) {
        const { props, values, fieldName } = this;
        const { strings } = props;
        const uvStatus = filterField.uniqueValuesStatus;
        const uniqueValues = filterField.uniqueValueInfos;
        if (uvStatus === status.MISSING || uvStatus === status.IN_PROGRESS) {
            if (uvStatus === status.MISSING) {
                this.onDisplayUniqueValues(filterField.layerField.name);
            }
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-loader", { class: CSS$2.smallLoader, inline: true, label: "" })));
        }
        else if (uvStatus === status.FAILED) {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.uniqueValuesContentListMsg }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", width: "full", scale: "m", alignment: "center", class: CSS$2.selectValues, disabled: true, label: strings.selectValues }, strings.selectValues), strings.errors.errorUniqueValues));
        }
        else {
            const msg1Node = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.uniqueValuesContentListMsg }, !(values === null || values === void 0 ? void 0 : values.length) && (uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length) ? strings.selectOneValue : ""));
            let msg2Node;
            if (!(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length)) {
                msg2Node = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.uniqueValuesContentListMsg }, strings.errors.noUniqueValues));
            }
            const list = values === null || values === void 0 ? void 0 : values.map((value) => this.renderSelectedUniqueValue(value, filterField));
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, msg1Node, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", width: "full", scale: "m", alignment: "center", class: CSS$2.selectValues, disabled: !(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length), onClick: (uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length) > 0 ? this.onSelectUniqueValues : null, ref: (node) => (this.uniqueSelectNode = node), label: strings.selectValues }, strings.selectValues), msg2Node, (values === null || values === void 0 ? void 0 : values.length) ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list", { key: `unique-values-value-list-${fieldName}`, class: CSS$2.pickList, ref: this.afterCreateList }, list)) : null));
        }
    }
    renderSelectedUniqueValue(value, filterField) {
        const { intl, props } = this;
        const { view, strings } = props;
        const timeZone = (view === null || view === void 0 ? void 0 : view.timeZone) || "system";
        const val = hasFieldDomains(filterField)
            ? getDecodedValue(value, filterField)
            : isDateType(filterField)
                ? getDateDisplayString(value, timeZone, intl) //intl.formatDate(new Date(value), intl.convertDateFormatToIntlOptions("short-date"))
                : isDateOnlyType(filterField)
                    ? intl.formatDateOnly(value, intl.convertDateFormatToIntlOptions("short-date"))
                    : isNumberType(filterField)
                        ? intl.formatNumber(value)
                        : value;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list-item", { label: `${val}`, value: `${value}` }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { slot: "actions-end", text: strings.remove, icon: "x", onClick: this.onRemoveSelectedValue.bind(this, value) })));
    }
    renderInTheLast() {
        const { props, value, unit } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.inTheLast }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { type: "number", min: 1, step: 1, value: isDefined(value) ? `${value}` : ``, scale: "m", class: CSS$2.inTheLastCount, label: strings.accessibility.value, onCalciteInputInput: this.onValueChange }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { width: "full", scale: "m", label: strings.accessibility.units, class: CSS$2.inTheLastUnit, onCalciteSelectChange: this.onUnitSelect }, this.renderInTheLastOption(timeUnits.MINUTE, unit === timeUnits.MINUTE), this.renderInTheLastOption(timeUnits.HOUR, unit === timeUnits.HOUR), this.renderInTheLastOption(timeUnits.DAY, unit === timeUnits.DAY), this.renderInTheLastOption(timeUnits.WEEK, unit === timeUnits.WEEK), this.renderInTheLastOption(timeUnits.MONTH, unit === timeUnits.MONTH), this.renderInTheLastOption(timeUnits.YEAR, unit === timeUnits.YEAR))));
    }
    renderInTheLastOption(unit, isSelected) {
        const { props } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: unit, label: strings.units[unit], selected: isSelected }));
    }
    renderHistogram(filterField) {
        const { props, histogramOpen, operator, fieldName } = this;
        const { layer, strings } = props;
        if (layer.type === "imagery" || layer.type === "subtype-group") {
            return null;
        }
        if (!filterField || !filterField.simpleFieldType) {
            return null;
        }
        if (filterField.statisticsStatus === status.FAILED) {
            return null;
        }
        if (!supportsHistogram(fieldName, operator, props)) {
            return null;
        }
        if (histogramOpen === undefined ||
            (histogramOpen && filterField.histogramStatus === status.MISSING)) {
            // open histogram block by default; or get info we need
            this.onHistogramOpen();
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block-section", { open: histogramOpen !== false, text: filterField.histogramStatus === status.FAILED ? strings.valueRange : strings.histogram, onCalciteBlockSectionToggle: this.onHistogramBlockToggle }, this.renderHistogramContent(filterField)));
    }
    renderHistogramContent(filterField) {
        const { histogramOpen } = this;
        const fieldName = filterField.layerField.name;
        if (histogramOpen === false) {
            return null;
        }
        if (!filterField.statistics || filterField.histogramStatus === status.IN_PROGRESS) {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: `histogram-content-${fieldName}-${filterField.statistics}`, class: filterField.histogram ? CSS$2.histogramContent : CSS$2.histogramContentSlim }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-loader", { class: CSS$2.smallLoader, inline: true, label: "" })));
        }
        else {
            const ok = this.prepareSlider(filterField);
            if (ok) {
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: `histogram-content-${fieldName}-${filterField.statistics}`, class: `${filterField.histogram ? CSS$2.histogramContent : CSS$2.histogramContentSlim}`, ref: this.afterCreateSliderDiv }));
            }
            else {
                // don't have a slider yet, need to wait a little longer
                return null;
            }
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    setFocus() {
        setTimeout(() => {
            const node = this.hostElement.querySelector(".autofocus");
            if (node) {
                node.setFocus();
            }
        }, 500);
    }
    onSelectUnique(multiple) {
        var _a;
        const { props, value, values, fieldName, uid, uniqueValuesSortBy, esriLang } = this;
        const { strings, localeIntl } = props;
        const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement);
        if (this.uniquePopoverNode) {
            this.closeFilterPopoversHandler();
            // just close the popover
            return;
        }
        this.closeFilterPopoversHandler();
        const filterField = getFieldInfo(fieldName, props);
        if (!filterField) {
            return;
        }
        const nodeWidth = (_a = this.fieldNode) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().width;
        const width = nodeWidth ? nodeWidth + 2 : 204;
        // we can't use a panel because we don't want a header
        const panelNode = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_4__.q)(this.hostElement, "calcite-panel");
        const nodeHeight = panelNode === null || panelNode === void 0 ? void 0 : panelNode.clientHeight;
        const maxHeight = nodeHeight ? Math.max(Math.min(nodeHeight / 3, 400), 240) : 400;
        const popoverUnique = document.createElement("calcite-popover");
        popoverUnique.id = `arcgis-filter-unique-popover_${uid}`;
        popoverUnique.placement = dir === "rtl" ? "bottom-start" : "bottom-end";
        popoverUnique.offsetDistance = 0;
        popoverUnique.offsetSkidding = 0;
        popoverUnique.pointerDisabled = true;
        popoverUnique.style = `width: ${width}px;`;
        popoverUnique.referenceElement = multiple ? this.uniqueSelectNode : this.uniqueActionNode;
        const uniqueList = document.createElement("arcgis-filter-unique-list");
        uniqueList.uid = uid;
        uniqueList.props = props;
        uniqueList.uniqueValues = esriLang.clone(filterField.uniqueValueInfos);
        uniqueList.selectedValues = multiple ? values : value ? [value] : [];
        uniqueList.fieldDomains = filterField.fieldDomains;
        uniqueList.layerFieldType = filterField.layerField.type;
        uniqueList.isDate =
            [simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) > -1;
        uniqueList.multiple = multiple;
        uniqueList.sortBy = uniqueValuesSortBy;
        uniqueList.partialUniqueValues = filterField.partialUniqueValues;
        uniqueList.maxHeight = maxHeight;
        uniqueList.strings = strings;
        uniqueList.locale = localeIntl;
        // otherwise there's an issue with the width of the list...
        uniqueList.style = `min-width: ${width}px`;
        popoverUnique.appendChild(uniqueList);
        document.body.appendChild(popoverUnique);
        popoverUnique.open = true;
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(uniqueList);
        uniqueList.setFocus();
        popoverUnique.reposition();
        this.uniquePopoverNode = popoverUnique;
        setTimeout(() => {
            document.addEventListener("click", this.onDocumentClickBind);
        }, 50);
    }
    scrollExprIntoView(node) {
        setTimeout(() => {
            if (node) {
                node = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_4__.q)(node, ".filter-expression");
                node === null || node === void 0 ? void 0 : node.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "start"
                });
            }
        }, 100);
    }
    removeUniquePopover() {
        var _a;
        document.removeEventListener("click", this.onDocumentClickBind);
        if (this.uniquePopoverNode) {
            /* const popover = this.uniquePopoverNode?.childNodes?.[0] as HTMLCalcitePopoverElement;
            if (popover) {
              popover.open = false;
            } */
            this.uniquePopoverNode.open = false;
            // need the ? here...
            (_a = this.uniquePopoverNode) === null || _a === void 0 ? void 0 : _a.parentElement.removeChild(this.uniquePopoverNode);
            this.uniquePopoverNode = undefined;
        }
    }
    async onDisplayUniqueValues(fieldName) {
        var _a;
        const { props, uniqueValues } = this;
        const { layer, view, featureReduction } = props;
        const filterField = getFieldInfo(fieldName, props);
        if (!filterField || layer.type === "imagery" || layer.type === "subtype-group") {
            return;
        }
        if (filterField.uniqueValuesStatus === status.MISSING && layer) {
            filterField.uniqueValuesStatus = status.IN_PROGRESS;
            try {
                const uniqueValuesResult = await uniqueValues({
                    layer,
                    view,
                    field: fieldName,
                    forBinning: featureReduction && ["binning", "cluster"].indexOf((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) > -1
                });
                // uniqueValueInfos: [{value, count},...]
                //console.log("success-uniqueValues", uniqueValuesResult);
                // e.g. coded value domains
                const isNumber = isNumberType(filterField);
                const uniqueValueInfos = uniqueValuesResult.uniqueValueInfos.filter((info) => {
                    // value is always a string, because we read it from the renderer
                    if (!isDefined(info.value)) {
                        return false;
                    }
                    else if ((filterField.simpleFieldType === "string" && !isNumber) ||
                        filterField.simpleFieldType === "guid") {
                        return info.value !== "<Null>" && `${info.value}`.trim() !== ""; // we don't allow empty strings
                    }
                    else if (filterField.simpleFieldType === "number" ||
                        filterField.simpleFieldType === "oid" ||
                        isNumber) {
                        return info.value !== "<Null>" && info.value !== "";
                    }
                    else {
                        // "date"
                        return info.value !== "<Null>" && info.value !== "";
                    }
                });
                // sort by count
                uniqueValueInfos.sort((a, b) => a.count > b.count ? -1 : a.count < b.count ? 1 : 0);
                if (hasFieldDomains(filterField)) {
                    // add domains that are not used in any feature
                    filterField.fieldDomains.forEach((fieldDomain) => {
                        if (!uniqueValueInfos.find((obj) => obj.value === fieldDomain.code)) {
                            uniqueValueInfos.push({
                                value: fieldDomain.code,
                                count: 0
                            });
                        }
                    });
                }
                // TODO partialData
                const partialUniqueValues = uniqueValuesResult.uniqueValueInfos.length === 2000;
                props.fields = props.fields.map((field) => field.layerField.name === fieldName
                    ? Object.assign(Object.assign({}, field), { uniqueValueInfos, uniqueValuesStatus: status.SUCCESS, partialUniqueValues }) : field);
                this.arcgisFilterUniqueValuesReturned.emit(filterField.layerField.name);
            }
            catch (error) {
                console.error("error-uniqueValues", error);
                if (hasFieldDomains(filterField)) {
                    // use domains from layer
                    const uniqueValueInfos = [];
                    filterField.fieldDomains.forEach((fieldDomain) => {
                        if (!uniqueValueInfos.find((obj) => obj.value === fieldDomain.code)) {
                            uniqueValueInfos.push({
                                value: fieldDomain.code,
                                count: undefined
                            });
                        }
                    });
                    props.fields = props.fields.map((field) => field.layerField.name === fieldName
                        ? Object.assign(Object.assign({}, field), { uniqueValueInfos, uniqueValuesStatus: status.SUCCESS, partialUniqueValues: false }) : field);
                }
                else {
                    props.fields = props.fields.map((field) => field.layerField.name === fieldName
                        ? Object.assign(Object.assign({}, field), { uniqueValuesStatus: status.FAILED }) : field);
                }
                this.reRender = !this.reRender;
            }
        }
    }
    async onHistogramOpen() {
        var _a, _b;
        const { props, fieldName, summaryStatistics, histogram } = this;
        const { layer, view, featureReduction } = props;
        const filterField = getFieldInfo(fieldName, props);
        if (!layer || layer.type === "imagery" || layer.type === "subtype-group" || !filterField) {
            return;
        }
        if (filterField.statistics) {
            this.checkDefaultValues(filterField);
            this.histogramOpen = true;
        }
        else if (!filterField.statistics) {
            props.fields = props.fields.map((field) => field.layerField.name === fieldName
                ? Object.assign(Object.assign({}, field), { statisticsStatus: status.IN_PROGRESS }) : field);
            try {
                const statistics = await summaryStatistics({
                    layer,
                    view,
                    field: fieldName,
                    forBinning: featureReduction && ["binning", "cluster"].indexOf((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) > -1
                });
                //console.log("success-statistics", fieldName, statistics);
                if (!isDefined(statistics.avg) ||
                    !isDefined(statistics.min) ||
                    !isDefined(statistics.max)) {
                    // field has maybe no values; statistics is unusable
                    props.fields = props.fields.map((field) => field.layerField.name === fieldName
                        ? Object.assign(Object.assign({}, field), { statisticsStatus: status.FAILED }) : field);
                    this.histogramOpen = false;
                    return;
                }
                if (statistics.min === statistics.max) {
                    if (statistics.min > 0) {
                        statistics.min = statistics.min - 0.1 * statistics.min;
                        statistics.max = statistics.max + 0.1 * statistics.max;
                    }
                    else if (statistics.min < 0) {
                        statistics.min = statistics.min + 0.1 * statistics.min;
                        statistics.max = statistics.max - 0.1 * statistics.max;
                    }
                    else {
                        statistics.min = -1;
                        statistics.max = 1;
                    }
                }
                props.fields = props.fields.map((field) => field.layerField.name === fieldName
                    ? Object.assign(Object.assign({}, field), { statistics, statisticsStatus: status.SUCCESS }) : field);
                this.checkDefaultValues(filterField);
                try {
                    const result = await histogram({
                        layer,
                        view,
                        field: fieldName,
                        numBins: 30,
                        minValue: statistics.min,
                        maxValue: statistics.max,
                        forBinning: featureReduction && ["binning", "cluster"].indexOf((_b = layer.featureReduction) === null || _b === void 0 ? void 0 : _b.type) > -1
                    });
                    //console.log("success-histogram", fieldName, result);
                    props.fields = props.fields.map((field) => field.layerField.name === fieldName
                        ? Object.assign(Object.assign({}, field), { histogram: result, histogramStatus: status.SUCCESS }) : field);
                    this.reRender = !this.reRender;
                }
                catch (error) {
                    console.error("error-histogram", error);
                    props.fields = props.fields.map((field) => field.layerField.name === fieldName
                        ? Object.assign(Object.assign({}, field), { histogramStatus: status.FAILED }) : field);
                    this.reRender = !this.reRender;
                }
            }
            catch (error) {
                console.error("error-summaryStatistics", error);
                props.fields = props.fields.map((field) => field.layerField.name === fieldName
                    ? Object.assign(Object.assign({}, field), { statisticsStatus: status.FAILED, histogramStatus: status.FAILED }) : field);
                this.histogramOpen = false;
                this.reRender = !this.reRender;
            }
        }
    }
    onHistogramClose() {
        this.histogramOpen = false;
    }
    async onMinMaxChange(min, max, fieldName) {
        var _a;
        const { props, value, value2, histogram } = this;
        const { layer, view, featureReduction } = props;
        const filterField = getFieldInfo(fieldName, props);
        if (!filterField || layer.type === "imagery" || layer.type === "subtype-group") {
            return;
        }
        this.value = Math.min(Math.max(value, min), max);
        if (isDefined(value2)) {
            this.value2 = Math.min(Math.max(value2, min), max);
        }
        this.histogramOpen = true;
        props.fields = props.fields.map((field) => field.layerField.name === fieldName
            ? Object.assign(Object.assign({}, field), { histogramStatus: status.IN_PROGRESS }) : field);
        try {
            const result = await histogram({
                layer,
                view,
                field: filterField.layerField.name,
                numBins: 30,
                minValue: min,
                maxValue: max,
                forBinning: featureReduction && ["binning", "cluster"].indexOf((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) > -1
            });
            //console.log("success-histogram", result);
            props.fields = props.fields.map((field) => field.layerField.name === fieldName
                ? Object.assign(Object.assign({}, field), { histogram: result, histogramStatus: status.SUCCESS }) : field);
            this.reRender = !this.reRender;
        }
        catch (error) {
            console.error("error-histogram", error);
            props.fields = props.fields.map((field) => field.layerField.name === fieldName
                ? Object.assign(Object.assign({}, field), { histogramStatus: status.FAILED }) : field);
        }
    }
    adjustHistogramMinMax(value) {
        const { histogramSlider } = this;
        if (histogramSlider) {
            if (histogramSlider.min > value) {
                histogramSlider.set({ min: value });
            }
            if (histogramSlider.max < value) {
                histogramSlider.set({ max: value });
            }
        }
    }
    prepareSlider(filterField) {
        var _a, _b;
        const { histogramSliderFieldName: sliderFieldName } = this;
        let { value, value2, histogramSlider: slider } = this;
        const statistics = filterField.statistics;
        if (filterField.histogramStatus === status.IN_PROGRESS) {
            // no updates to the slider
            //console.log("no slider updates");
            return false;
        }
        // string values are wrong here
        if (isDefined(value) && typeof value !== "number") {
            value = undefined;
        }
        if (isDefined(value2) && typeof value2 !== "number") {
            value2 = undefined;
        }
        this.checkDefaultValues(filterField);
        // refresh
        value = this.value;
        value2 = this.value2;
        // make sure we have the correct number of values
        const values = [];
        values.push(value);
        if (isDefined(value2)) {
            values.push(value2);
        }
        if (isIntegerType(filterField)) {
            if (isDefined(values[0])) {
                const roundedVal = Math.round(values[0]);
                if (roundedVal !== values[0]) {
                    this.changeValues(roundedVal, value2);
                }
                values[0] = roundedVal;
            }
            if (isDefined(values[1])) {
                const roundedVal = Math.round(values[1]);
                if (roundedVal !== values[1]) {
                    this.changeValues(value, roundedVal);
                }
                values[1] = roundedVal;
            }
        }
        // adjust the slider if values are outside of range
        let min = filterField.histogram ? filterField.histogram.minValue : statistics.min;
        let max = filterField.histogram ? filterField.histogram.maxValue : statistics.max;
        if (isDefined(values[0]) && isDefined(values[1])) {
            min = Math.min(min, values[0]);
            max = Math.max(max, values[1]);
        }
        else if (isDefined(values[0])) {
            min = Math.min(min, values[0]);
            max = Math.max(max, values[0]);
        }
        if (slider && sliderFieldName !== filterField.layerField.name) {
            // change maybe because of a deleted expression or condition
            slider.destroy();
            slider = undefined;
        }
        if (!slider) {
            // new histogram
            const config = {
                bins: (_a = filterField.histogram) === null || _a === void 0 ? void 0 : _a.bins,
                average: Math.round(statistics.avg * 10) / 10,
                //standardDeviation: filterField.statistics.stddev,
                min: min,
                max: max,
                values: (values === null || values === void 0 ? void 0 : values[0]) === undefined ? undefined : values,
                rangeType: this.getSliderRangeType(),
                precision: isIntegerType(filterField) ? 0 : 4
            };
            if ([simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) >
                -1) {
                config.hasTimeData = true;
                this.addDateFormatFunctions(config);
            }
            this.histogramSliderFieldName = filterField.layerField.name;
            this.histogramSlider = new this.HistogramRangeSlider(config);
            //console.log("new HistogramRangeSlider", config);
            this.createSliderChangeEvents(filterField);
        }
        else {
            // update histogram slider
            const config = {
                bins: (_b = filterField.histogram) === null || _b === void 0 ? void 0 : _b.bins,
                average: Math.round(statistics.avg * 10) / 10,
                min: min,
                max: max,
                values: (values === null || values === void 0 ? void 0 : values[0]) === undefined ? undefined : values,
                rangeType: this.getSliderRangeType()
            };
            //console.log("update HistogramRangeSlider", config, values);
            slider.set(config);
        }
        return true;
    }
    createSliderChangeEvents(filterField) {
        const { histogramSlider } = this;
        if (!histogramSlider) {
            return;
        }
        histogramSlider.on("min-change", (event /*ValueChangeEvent*/) => {
            const slider = histogramSlider;
            this.onMinMaxChange(event.value, slider.max, filterField.layerField.name);
        });
        histogramSlider.on("max-change", (event /*ValueChangeEvent*/) => {
            const slider = histogramSlider;
            this.onMinMaxChange(slider.min, event.value, filterField.layerField.name);
        });
        histogramSlider.watch("values", ( /* values: number[] */) => {
            var _a, _b;
            const slider = histogramSlider;
            let value = (_a = slider.values) === null || _a === void 0 ? void 0 : _a[0];
            let value2 = (_b = slider.values) === null || _b === void 0 ? void 0 : _b[1];
            if ([simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) >
                -1) {
                value = Math.round(value);
            }
            if (isIntegerType(filterField)) {
                if (value2 || value === 0) {
                    value = Math.floor(value);
                    value2 = Math.ceil(value2);
                }
                else {
                    value = Math.round(value);
                }
            }
            this.changeValues(value, value2);
        });
        histogramSlider.on("segment-drag", ( /*event: any SegmentDragEvent*/) => {
            const slider = histogramSlider;
            let value = slider.values[0];
            let value2 = slider.values[1];
            if (isIntegerType(filterField)) {
                if (value2 || value === 0) {
                    value = Math.floor(value);
                    value2 = Math.ceil(value2);
                }
                else {
                    value = Math.round(value);
                }
            }
            this.changeValues(value, value2);
        });
    }
    getSliderRangeType() {
        const { props, operator } = this;
        const { strings } = props;
        switch (operator) {
            case strings.operators.numberOperatorIs:
            case strings.operators.dateOperatorIsOn:
                return "equal";
            case strings.operators.numberOperatorIsNot:
            case strings.operators.dateOperatorIsNotOn:
                return "not-equal";
            case strings.operators.numberOperatorIsLessThan:
            case strings.operators.dateOperatorIsBefore:
                return "less-than";
            case strings.operators.numberOperatorIsGreaterThan:
            case strings.operators.dateOperatorIsAfter:
                return "greater-than";
            case strings.operators.numberOperatorIsAtMost:
                return "at-most";
            case strings.operators.numberOperatorIsAtLeast:
                return "at-least";
            case strings.operators.numberOperatorIsBetween:
            case strings.operators.dateOperatorIsBetween:
                return "between";
            case strings.operators.numberOperatorIsNotBetween:
            case strings.operators.dateOperatorIsNotBetween:
                return "not-between";
            default:
                return "";
        }
    }
    getNewValue(event) {
        const { view } = this.props;
        const timeZone = (view === null || view === void 0 ? void 0 : view.timeZone) || "system";
        const node = event === null || event === void 0 ? void 0 : event.target;
        let newValue;
        if ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-INPUT-DATE-PICKER") {
            newValue = node.value; //valueAsDate; -> valueAsDate seems to have a time offset
            if (!newValue) {
                return;
            }
            newValue = datePickerToUTC(new Date(newValue), timeZone);
        }
        else if ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-INPUT" && node.type === "number") {
            newValue = node.value;
            if (!newValue) {
                return;
            }
            newValue = parseFloat(newValue);
        }
        else if ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-INPUT") {
            // text
            newValue = node.value;
            if (!(newValue === null || newValue === void 0 ? void 0 : newValue.length)) {
                newValue = undefined;
            }
        }
        return newValue;
    }
    addDateFormatFunctions(config) {
        const { intl, props } = this;
        const { view } = props;
        const timeZone = (view === null || view === void 0 ? void 0 : view.timeZone) || "system";
        config.labelFormatFunction = (value) => {
            //return this.smartMappingUtils.formatDateLabel(utcToMapTZ(value, timeZone));
            return getDateDisplayString(value, timeZone, intl, "short-date");
        };
        config.inputFormatFunction = (value) => {
            //return this.smartMappingUtils.formatDateLabel(utcToMapTZ(value, timeZone));
            return getDateDisplayString(value, timeZone, intl, "short-date");
        };
        config.inputParseFunction = (value /* , type: string, index: number */) => {
            return mapTZToUTC(Date.parse(value), timeZone);
        };
    }
    changeValues(value, value2) {
        const { props, fieldName } = this;
        const filterField = getFieldInfo(fieldName, props);
        const newValue = filterField.simpleFieldType &&
            [simpleFieldTypes.NUMBER, simpleFieldTypes.DATE, simpleFieldTypes.OID].indexOf(filterField.simpleFieldType) > -1
            ? isNaN(value)
                ? null
                : value
            : value;
        const newValue2 = filterField.simpleFieldType &&
            [simpleFieldTypes.NUMBER, simpleFieldTypes.DATE, simpleFieldTypes.OID].indexOf(filterField.simpleFieldType) > -1
            ? isNaN(value2)
                ? null
                : value2
            : value2;
        if (this.value !== newValue || this.value2 !== newValue2) {
            //this.value = newValue;
            //this.value2 = newValue2;
            this.emitChangeEvent({
                value: newValue !== null && newValue !== void 0 ? newValue : null,
                value2: newValue2 !== null && newValue2 !== void 0 ? newValue2 : null
            });
        }
    }
    checkDefaultValues(filterField) {
        const { props, operator, value, value2, histogramSlider: slider } = this;
        const statistics = filterField.statistics;
        const defaultValues = getDefaultValues(props, filterField, operator);
        if (isInTheLastOperator(props, operator)) {
            if (!isDefined(value)) {
                const now = new Date().getTime();
                const range = Math.abs(now - statistics.avg);
                let value, unit;
                if (range > 2 * timeRange.YEAR) {
                    value = Math.round(range / timeRange.YEAR);
                    unit = timeUnits.YEAR;
                }
                else {
                    if (range > 2 * timeRange.MONTH) {
                        value = Math.round(range / timeRange.MONTH);
                        unit = timeUnits.MONTH;
                    }
                    else {
                        if (range > 2 * timeRange.WEEK) {
                            value = Math.round(range / timeRange.WEEK);
                            unit = timeUnits.WEEK;
                        }
                        else {
                            if (range > 2 * timeRange.DAY) {
                                value = Math.round(range / timeRange.DAY);
                                unit = timeUnits.DAY;
                            }
                            else {
                                if (range > 2 * timeRange.HOUR) {
                                    value = Math.round(range / timeRange.HOUR);
                                    unit = timeUnits.HOUR;
                                }
                                else {
                                    value = Math.round(range / timeRange.MINUTE);
                                    unit = timeUnits.MINUTE;
                                }
                            }
                        }
                    }
                }
                //this.value = value;
                //this.unit = unit;
                this.emitChangeEvent({ value, unit });
            }
        }
        else if (isBetweenOperator(props, operator)) {
            if (isDefined(value)) {
                if (isDefined(value2)) {
                    if (value2 < value) {
                        // let's correct the one that was changed last
                        if (slider && slider.values[0] === value) {
                            this.changeValues(value, value);
                        }
                        else {
                            this.changeValues(value2, value2);
                        }
                    }
                }
                else {
                    // need a second value
                    const val = isIntegerType(filterField) ? Math.round(statistics.max) : statistics.max;
                    this.changeValues(value, val);
                }
            }
            else {
                // need values
                if (isDefined(value2)) {
                    const val = fieldTypeRound(statistics === null || statistics === void 0 ? void 0 : statistics.avg, props, filterField);
                    this.changeValues(val, value2);
                }
                else {
                    this.changeValues(defaultValues.value, defaultValues.value2);
                }
            }
        }
        else {
            if (!isDefined(value)) {
                this.changeValues(defaultValues.value, defaultValues.value2);
            }
        }
        // most of the times don't need this return
        return defaultValues;
    }
    openFieldPickList() {
        const { props, fieldName, fieldPickListSortBy } = this;
        const { layer, view, featureReduction } = props;
        const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement);
        this.closeFilterPopoversHandler();
        const panelNode = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_4__.q)(this.hostElement, "#filter-panel");
        const closeNode = panelNode.querySelector("#arcgis-filter-close");
        const nodeWidth = panelNode === null || panelNode === void 0 ? void 0 : panelNode.getBoundingClientRect().width;
        this.arcgisFieldPickList = document.createElement("arcgis-field-pick-list");
        this.arcgisFieldPickList.popoverProps = closeNode
            ? {
                placement: dir === "rtl" ? "bottom-start" : "bottom-end",
                offsetDistance: 20,
                offsetSkidding: 15,
                pointerDisabled: true,
                popoverWidth: nodeWidth ? nodeWidth + 30 : 280,
                refElement: closeNode
            }
            : {
                placement: "auto",
                // we don't have an action bar in layer view where it is used without a close button
                offsetDistance: -1 * (nodeWidth ? nodeWidth - 5 : 215),
                offsetSkidding: 0,
                pointerDisabled: true,
                popoverWidth: nodeWidth ? nodeWidth + 30 : 280,
                refElement: panelNode
            };
        this.arcgisFieldPickList.fields = this.createPickListFields();
        this.arcgisFieldPickList.layer = layer;
        this.arcgisFieldPickList.mapView = view;
        this.arcgisFieldPickList.showFieldInfo = true;
        this.arcgisFieldPickList.showFieldName = false;
        this.arcgisFieldPickList.selectedFields = [fieldName];
        this.arcgisFieldPickList.sortBy = fieldPickListSortBy;
        this.arcgisFieldPickList.showFieldInfo = !featureReduction;
        this.arcgisFieldPickList.addEventListener("arcgisFieldPickListDismissed", this.fieldPickListChanges);
        this.arcgisFieldPickList.addEventListener("arcgisFieldPickListSortByChange", (event) => (this.fieldPickListSortBy = event.detail));
        document.body.appendChild(this.arcgisFieldPickList);
        this.disableFilterPanel.emit(true);
    }
    createPickListFields() {
        const { props } = this;
        const { fields } = props;
        return fields.map((field) => {
            return {
                name: field.layerField.name,
                alias: field.label,
                type: field.simpleFieldType
            };
        });
    }
    removeFieldsPickList() {
        this.disableFilterPanel.emit(false);
        if (this.arcgisFieldPickList) {
            document.body.removeChild(this.arcgisFieldPickList);
            this.arcgisFieldPickList = null;
            setTimeout(() => {
                this.fieldNode.setFocus();
            }, 1);
        }
    }
    afterFieldSelect(newFieldName) {
        var _a;
        const { props, fieldName, operator, histogramOpen } = this;
        const { strings } = props;
        const oldFilterField = getFieldInfo(fieldName, props);
        const newFilterField = getFieldInfo(newFieldName, props);
        /* this.hasFocus = true;
        this.fieldName = newFieldName;
        this.operator = getOperator(props, oldFilterField!, newFilterField!, operator!);
        this.value = undefined;
        this.value2 = undefined;
        this.values = undefined;
        this.uniqueValuesSortBy = undefined;
        this.histogramOpen =
          (newFilterField!.simpleFieldType &&
            [simpleFieldTypes.NUMBER, simpleFieldTypes.DATE].indexOf(
              newFilterField!.simpleFieldType
            ) === -1) ||
          newFilterField!.statisticsStatus === status.FAILED
            ? undefined
            : histogramOpen === false && oldFilterField!.statisticsStatus !== status.FAILED
            ? false
            : undefined; // when undefined then open by default
        */
        let value = null;
        const newOperator = getOperator$1(props, oldFilterField, newFilterField, operator);
        const filterField = getFieldInfo(newFieldName, props);
        if (filterField.simpleFieldType === simpleFieldTypes.STRING &&
            filterField.uniqueValuesStatus === status.SUCCESS &&
            ((_a = filterField.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length) &&
            [strings.operators.stringOperatorIs, strings.operators.stringOperatorIsNot].indexOf(newOperator) > -1) {
            // default value
            value = filterField.uniqueValueInfos[0].value;
        }
        this.emitChangeEvent({
            hasFocus: true,
            fieldName: newFieldName,
            operator: newOperator,
            value,
            value2: null,
            values: null,
            uniqueValuesSortBy: null,
            histogramOpen: (newFilterField.simpleFieldType &&
                [simpleFieldTypes.NUMBER, simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(newFilterField.simpleFieldType) === -1) ||
                newFilterField.statisticsStatus === status.FAILED
                ? null
                : histogramOpen === false && oldFilterField.statisticsStatus !== status.FAILED
                    ? false
                    : null // when undefined then open by default
        });
    }
    emitChangeEvent(overwrites) {
        var _a, _b;
        const { uid, fieldName, operator, uniqueValuesSortBy, value, value2, values, unit, histogramOpen, hasFocus } = this;
        const newCondition = {
            uid,
            fieldName: overwrites.fieldName || fieldName,
            operator: overwrites.operator || operator,
            uniqueValuesSortBy: overwrites.uniqueValuesSortBy === null
                ? undefined
                : overwrites.uniqueValuesSortBy || uniqueValuesSortBy,
            value: overwrites.value === null ? undefined : (_a = overwrites.value) !== null && _a !== void 0 ? _a : value,
            value2: overwrites.value2 === null ? undefined : (_b = overwrites.value2) !== null && _b !== void 0 ? _b : value2,
            values: overwrites.values === null ? undefined : overwrites.values || values,
            unit: overwrites.unit || unit,
            histogramOpen: overwrites.histogramOpen === null ? undefined : overwrites.histogramOpen || histogramOpen,
            hasFocus: overwrites.hasFocus || hasFocus
        };
        this.arcgisFilterConditionChanged.emit(newCondition);
    }
    waitOnUser(event, doChange) {
        // for number fields we don't want to allow an empty value
        // but the user might shortly use an empty input box
        // while typing a new value
        if (this.typingHndl) {
            clearTimeout(this.typingHndl);
            this.typingHndl = undefined;
        }
        const node = event.target;
        const val = node.value;
        const parsedVal = parseFloat(val);
        if (!val) {
            // undefined or empty string
            // user might be in the middle of typing
            // give the user 2 seconds to fill in empty entry
            // otherwise go back to default value
            this.typingHndl = setTimeout(() => {
                this.typingHndl = undefined;
                doChange(event);
            }, 2000);
        }
        else if (val[0] !== "-" || (parsedVal !== 0 && !isNaN(parsedVal))) {
            // not '-', '-0', '-0.', '-0.0', ...
            doChange(event);
        } // else don't update anything; it's still keeping last value
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisFilterCondition.style = arcgisFilterConditionCss;

const CSS$1 = {
    addConditionButton: "add-condition-button",
    content: "content",
    conditionHeader: "condition-header",
    matchTypeText: "match-type-text",
    matchCondition: "match-condition",
    matchConditionDropdown: "match-condition-dropdown"
};

const arcgisFilterExpressionCss = ".content.sc-arcgis-filter-expression{padding-bottom:6px}.condition-header.sc-arcgis-filter-expression{display:flex;justify-content:flex-end;align-items:center;margin:0 6px}.match-type-text.sc-arcgis-filter-expression{margin:0 auto}.match-condition.sc-arcgis-filter-expression{margin:0 6px}.match-condition-dropdown.sc-arcgis-filter-expression{width:100%}.add-condition-button.sc-arcgis-filter-expression{display:flex}";

const ArcgisFilterExpression = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisFilterExpressionChanged = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterExpressionChanged", 7);
        // --------------------------------------------------------------------------
        //
        //  Private methods
        //
        // --------------------------------------------------------------------------
        this.onAddCondition = () => {
            const { props, conditions } = this;
            const defaultField = getDefaultField(props);
            const defaultOperator = getDefaultOperator(props, defaultField);
            const defaultValues = getDefaultValues(props, defaultField, defaultOperator);
            const newCondition = Object.assign(Object.assign({ fieldName: defaultField.layerField.name, operator: getDefaultOperator(props, defaultField) }, defaultValues), { hasFocus: true });
            conditions.forEach((cond) => (cond.hasFocus = false));
            this.conditions = [...conditions, newCondition];
            props.expressions = props.expressions.map((expression) => expression.uid === this.uid
                ? Object.assign(Object.assign({}, expression), { conditions: this.conditions }) : Object.assign({}, expression));
            this.fixUIDsForExpression();
            this.menuNode.open = false;
            this.emitChangeEvent();
        };
        this.onRemoveCondition = (event) => {
            const { props, conditions } = this;
            const action = event.target;
            const conditionIdx = parseInt(action.getAttribute("data-value"));
            conditions.forEach((cond) => (cond.hasFocus = false));
            let removedIdx = 0;
            this.conditions = conditions.filter((cond, idx2) => {
                if (cond && idx2 === conditionIdx) {
                    removedIdx = idx2;
                    return false;
                }
                return true;
            });
            this.conditions[Math.max(0, removedIdx - 1)].hasFocus = true;
            props.expressions = props.expressions.map((expression) => expression.uid === this.uid
                ? Object.assign(Object.assign({}, expression), { conditions: this.conditions }) : Object.assign({}, expression));
            this.fixUIDsForExpression();
            this.emitChangeEvent();
        };
        this.onMatchSelect = (event) => {
            const select = event.target;
            const newMatch = select.selectedOption.value;
            this.logicalOperatorForConditions = newMatch;
            this.emitChangeEvent();
        };
        this.onCopyExpression = () => {
            const { uid, conditions, logicalOperatorForConditions } = this;
            const currentExpression = {
                uid,
                conditions,
                logicalOperatorForConditions
            };
            this.menuNode.open = false;
            this.arcgisFilterExpressionChanged.emit({
                type: "copy",
                uid: this.uid,
                expression: currentExpression
            });
        };
        this.onRemoveExpression = () => {
            this.arcgisFilterExpressionChanged.emit({ type: "delete", uid: this.uid });
        };
        this.props = undefined;
        this.uid = undefined;
        this.conditions = undefined;
        this.logicalOperatorForConditions = undefined;
        this.canRemove = true;
        this.canDuplicate = true;
        this.showAddConditionButton = false;
    }
    arcgisFilterConditionChangeHandler(event) {
        const { conditions } = this;
        const { detail: newCondition } = event;
        this.conditions = conditions.map((condition) => condition.uid === newCondition.uid ? newCondition : condition //{ ...condition }
        );
        this.emitChangeEvent();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        this.conditions = this.conditions || [];
        const [esriLang] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/core/lang"]);
        this.esriLang = esriLang;
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { props, conditions } = this;
        const { strings } = props;
        const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: {
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: dir === "rtl"
            }, dir: dir }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: conditions.length === 1 ? strings.expression : strings.expressionSet, open: true }, this.renderMenu(), this.renderMatchCondition(), this.renderConditions(), this.renderAddConditionButton())));
    }
    renderMenu() {
        const { props, canDuplicate, canRemove, conditions } = this;
        const { strings } = props;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action-menu", { slot: "control", placement: "bottom-end", overlayPositioning: "fixed", label: strings.accessibility.moreOptions, ref: (node) => (this.menuNode = node) }, canRemove && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: conditions.length === 1 ? strings.deleteExpression : strings.deleteSet, textEnabled: true, "data-value": "remove", onClick: this.onRemoveExpression })), canDuplicate && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: strings.duplicate, textEnabled: true, "data-value": "copy", onClick: this.onCopyExpression })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: strings.addCondition, textEnabled: true, "data-value": "add", onClick: this.onAddCondition })));
    }
    renderMatchCondition() {
        const { conditions, logicalOperatorForConditions, props } = this;
        const { strings } = props;
        if (!conditions || !conditions.length || conditions.length === 1) {
            return null;
        }
        const isAnd = logicalOperatorForConditions !== logicalOperators.OR;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.matchCondition }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { width: "full", scale: "m", label: strings.accessibility.matchConditions, class: CSS$1.matchConditionDropdown, onCalciteSelectChange: this.onMatchSelect }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: logicalOperators.AND, label: strings.matchAllConditions, selected: isAnd }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: logicalOperators.OR, label: strings.matchAtLeastOneCondition, selected: !isAnd }))));
    }
    renderConditions() {
        const { conditions } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.content }, conditions.map((conditionProps, idx) => this.renderCondition(conditionProps, idx))));
    }
    renderCondition(conditionProps, conditionIndex) {
        const { props } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, this.renderConditionHeader(conditionIndex), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-filter-condition", Object.assign({ props: props }, conditionProps))));
    }
    renderAddConditionButton() {
        return (this.showAddConditionButton && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { alignment: "center", appearance: "transparent", class: CSS$1.addConditionButton, "icon-start": "plus", scale: "s", onClick: this.onAddCondition }, this.props.strings.addCondition)));
    }
    renderConditionHeader(conditionIndex) {
        const { props, logicalOperatorForConditions, conditions } = this;
        const { strings } = props;
        if (conditions.length < 2) {
            return null;
        }
        const isAnd = logicalOperatorForConditions !== logicalOperators.OR;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.conditionHeader }, conditionIndex > 0 ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: CSS$1.matchTypeText }, isAnd ? strings.and : strings.or)) : null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { label: strings.remove, text: "", icon: "x", compact: true, "data-value": `${conditionIndex}`, onClick: this.onRemoveCondition })));
    }
    fixUIDsForExpression() {
        const { props } = this;
        props.expressions = fixUIDs(props.expressions);
        this.conditions = props.expressions.filter((expression) => expression.uid === this.uid)[0].conditions;
    }
    emitChangeEvent() {
        const { uid, conditions, logicalOperatorForConditions } = this;
        const newExpression = {
            uid,
            conditions,
            logicalOperatorForConditions
        };
        this.arcgisFilterExpressionChanged.emit({ type: "replace", expression: newExpression });
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisFilterExpression.style = arcgisFilterExpressionCss;

const CSS = {
    container: "container",
    pickList: "popover-unique-pick-list",
    uniqueValuesContentListMsg: "unique-values-content-list-msg",
    count: "count",
    uniqueValuesDone: "unique-values-done"
};

const arcgisFilterUniqueListCss = ".sc-arcgis-filter-unique-list-h{width:100%}.container.sc-arcgis-filter-unique-list{min-height:30px}.popover-unique-pick-list.sc-arcgis-filter-unique-list{width:100%;overflow-y:auto}.unique-values-content-list-msg.sc-arcgis-filter-unique-list{font-size:75%;margin:5px}.count.sc-arcgis-filter-unique-list{padding:12px 6px}.unique-values-done.sc-arcgis-filter-unique-list{padding:0.5rem}";

const ArcgisFilterUniqueList = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisFilterUniqueListDone = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterUniqueListDone", 7);
        this.arcgisFilterUniqueListChanged = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterUniqueListChanged", 7);
        this.arcgisFilterUniqueListSortByChanged = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterUniqueListSortByChanged", 7);
        this.onSortMenuSelect = (event) => {
            var _a;
            const dropdown = event.currentTarget;
            const type = (_a = dropdown.selectedItems) === null || _a === void 0 ? void 0 : _a[0].getAttribute("data-value");
            this.sortBy = type;
            this.arcgisFilterUniqueListSortByChanged.emit({ uid: this.uid, sortBy: type });
        };
        this.done = () => {
            this.arcgisFilterUniqueListDone.emit(this.uid);
        };
        this.uid = undefined;
        this.props = undefined;
        this.uniqueValues = undefined;
        this.selectedValues = undefined;
        this.fieldDomains = undefined;
        this.layerFieldType = undefined;
        this.isDate = undefined;
        this.sortBy = undefined;
        this.multiple = undefined;
        this.partialUniqueValues = undefined;
        this.maxHeight = undefined;
        this.strings = undefined;
        this.locale = undefined;
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    async setFocus() {
        var _a;
        (_a = this.pickListNode) === null || _a === void 0 ? void 0 : _a.setFocus();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/intl"]);
        this.intl = intl;
        this.intl.setLocale(this.locale);
    }
    componentDidLoad() {
        //this.setFocus();
    }
    disconnectedCallback() {
        //this.removeFieldsPickList();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { uid, uniqueValues, selectedValues, layerFieldType, fieldDomains, sortBy, multiple, partialUniqueValues, maxHeight, strings } = this;
        const sortByCount = (list) => {
            list.sort((a, b) => {
                return a.count <= b.count ? 1 : -1;
            });
        };
        const sortAlphabetically = (list) => {
            const hasDomains = fieldDomains === null || fieldDomains === void 0 ? void 0 : fieldDomains.length;
            list.sort((a, b) => {
                const valueA = hasDomains ? this.getDecodedValue(a.value) : a.value;
                const valueB = hasDomains ? this.getDecodedValue(b.value) : b.value;
                return `${valueA}`.charAt(0) === "_"
                    ? 1
                    : `${valueB}`.charAt(0) === "_"
                        ? -1
                        : `${valueA}`.localeCompare(`${valueB}`);
            });
        };
        const sortSelected = (list, values) => {
            list.sort((a, b) => {
                var _a, _b;
                const posA = (_a = values === null || values === void 0 ? void 0 : values.indexOf(a.value)) !== null && _a !== void 0 ? _a : -1;
                const posB = (_b = values === null || values === void 0 ? void 0 : values.indexOf(b.value)) !== null && _b !== void 0 ? _b : -1;
                return posA === posB || (posA > -1 && posB > -1) ? 0 : posA > posB ? -1 : 1;
            });
        };
        sortAlphabetically(uniqueValues);
        if (!sortBy || sortBy === "count") {
            sortByCount(uniqueValues);
        }
        else if (sortBy === "selected") {
            sortSelected(uniqueValues, selectedValues);
        }
        const list = uniqueValues.map((info) => this.renderUniqueValue(info));
        let msgNode;
        if (partialUniqueValues) {
            msgNode = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.uniqueValuesContentListMsg }, strings.errors.tooManyUniqueValues));
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.container }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list", { class: CSS.pickList, filterEnabled: uniqueValues.length > 10, multiple: multiple, "filter-placeholder": strings.searchValues, onCalciteListChange: async (event) => {
                const node = event.target;
                let selectedValues = [...(await node.getSelectedItems()).keys()];
                if (layerFieldType === "date-only") {
                    selectedValues = selectedValues === null || selectedValues === void 0 ? void 0 : selectedValues.map((value) => {
                        // convert date string to UNIX timestamp (without timestamp offset shift)
                        const date = new Date(value);
                        const offset = date.getTimezoneOffset() * 60000;
                        return date.getTime() + offset;
                    });
                }
                else if (["date", "oid", "guid", "small-integer", "big-integer", "integer", "long"].indexOf(layerFieldType) > -1) {
                    selectedValues = selectedValues === null || selectedValues === void 0 ? void 0 : selectedValues.map((value) => parseInt(value));
                }
                else if (["single", "double"].indexOf(layerFieldType) > -1) {
                    selectedValues = selectedValues === null || selectedValues === void 0 ? void 0 : selectedValues.map((value) => parseFloat(value));
                }
                this.selectedValues = selectedValues;
                this.arcgisFilterUniqueListChanged.emit({
                    uid,
                    multiple,
                    selectedValues,
                    sortBy
                });
            }, ref: (node) => {
                this.pickListNode = node;
                if (maxHeight) {
                    node.setAttribute("style", `max-height: ${maxHeight || 400}px`);
                }
            } }, uniqueValues.length > 10 ? this.renderSort() : null, list), msgNode, this.renderDone())));
    }
    renderSort() {
        const { sortBy, strings } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown", { slot: "menu-actions", placement: "bottom-end", overlayPositioning: "fixed", widthScale: "s", onCalciteDropdownSelect: this.onSortMenuSelect }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { slot: "trigger", label: strings.sortValues, text: "" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "s", icon: "sortDescending" })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-group", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-item", { selected: sortBy === "count" || !isDefined(sortBy), "data-value": "count" }, strings.sortByCount), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-item", { selected: sortBy === "name", "data-value": "name" }, strings.sortAlphabetical), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-item", { selected: sortBy === "selected", "data-value": "selected" }, strings.sortSelected))));
    }
    renderUniqueValue(info) {
        const { selectedValues, fieldDomains, layerFieldType, isDate, intl, props } = this;
        const { view } = props;
        const timeZone = (view === null || view === void 0 ? void 0 : view.timeZone) || "system";
        const value = (fieldDomains === null || fieldDomains === void 0 ? void 0 : fieldDomains.length)
            ? this.getDecodedValue(info.value)
            : isDate
                ? layerFieldType === "date-only"
                    ? this.getDateOnlyString(info.value)
                    : getDateDisplayString(info.value, timeZone, intl)
                : typeof info.value === "number"
                    ? intl.formatNumber(info.value)
                    : info.value;
        const isSelected = selectedValues ? selectedValues.indexOf(info.value) > -1 : false;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list-item", { key: `pick-list-item_${info.value}`, label: `${value}`, value: `${info.value}`, selected: isSelected }, isDefined(info.count) ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.count, slot: "actions-end" }, `${info.count}`)) : null));
    }
    renderDone() {
        const { multiple, strings } = this;
        if (!multiple) {
            return null;
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.uniqueValuesDone }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "outline-fill", width: "full", onClick: this.done, label: strings.done }, strings.done)));
    }
    getDecodedValue(value) {
        const { fieldDomains } = this;
        const codedValues = fieldDomains;
        if (codedValues) {
            let label = "";
            for (let i = 0; i < codedValues.length; i++) {
                const codedValue = codedValues[i];
                if (codedValue.code == value) {
                    label += (label.length ? " | " : "") + codedValue.name;
                }
            }
            return label;
        }
        // did not find it
        return value;
    }
    getDateOnlyString(value) {
        const { intl } = this;
        return value ? intl.formatDateOnly(value) : "";
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisFilterUniqueList.style = arcgisFilterUniqueListCss;



//# sourceMappingURL=arcgis-filter_4.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWQ4ZmU3Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM4STtBQUN4RTtBQUNUO0FBQ3FCO0FBQ1k7QUFDdEM7QUFDckI7QUFDUjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7QUFDQSxpREFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQSxpREFBaUQsMkRBQVc7QUFDNUQ7QUFDQTtBQUNBLDRCQUE0QixlQUFlLGlCQUFpQixjQUFjO0FBQzFFLGlGQUFpRixlQUFlO0FBQ2hHLHVEQUF1RCxTQUFTLHNDQUFzQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxHQUFHLGNBQWM7QUFDN0Msd0VBQXdFLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtB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QjtBQUNBO0FBQ0EsWUFBWSx3REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBWSw4QkFBOEIsY0FBYyxRQUFRLE9BQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLEVBQUUsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZSxHQUFHLGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEU7O0FBRTVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLWZpbHRlcl80LmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxlLTA1MGI2ZGI5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIEYgYXMgRnJhZ21lbnQsIGQgYXMgZ2V0RWxlbWVudCwgZiBhcyBmb3JjZVVwZGF0ZSB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIH0gZnJvbSAnLi9sb2NhbGUtMDUwYjZkYjkuanMnO1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRFbGVtZW50RGlyLCBDIGFzIENTU19VVElMSVRZIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRGZWF0dXJlQ291bnQsIHEgYXMgcXVlcnlQYXJlbnRFbGVtZW50IH0gZnJvbSAnLi9jb21tb25GdW5jdGlvbnMtYjA4MzBlOWUuanMnO1xuaW1wb3J0IHsgdCBhcyB0aW1lb3V0IH0gZnJvbSAnLi9mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzJztcbmltcG9ydCAnLi9jb21tb25FbnVtcy1mY2YxMzY2MS5qcyc7XG5pbXBvcnQgJy4vZG9tLTRkMzY3Njc3LmpzJztcblxuY29uc3QgQ1NTJDMgPSB7XG4gICAgcGFuZWw6IFwicGFuZWxcIixcbiAgICBob29rOiBcImhvb2tcIixcbiAgICByZW1vdmVGaWx0ZXI6IFwicmVtb3ZlLWZpbHRlclwiLFxuICAgIG1hdGNoRXhwcmVzc2lvbk1zZzogXCJtYXRjaC1leHByZXNzaW9uLW1zZ1wiLFxuICAgIG1hdGNoRXhwcmVzc2lvbkRyb3Bkb3duOiBcIm1hdGNoLWV4cHJlc3Npb24tZHJvcGRvd25cIixcbiAgICBsb2dpY2FsT3BlcmF0b3I6IFwibWF0Y2gtdHlwZVwiXG59O1xuXG52YXIgbG9naWNhbE9wZXJhdG9ycztcbihmdW5jdGlvbiAobG9naWNhbE9wZXJhdG9ycykge1xuICAgIGxvZ2ljYWxPcGVyYXRvcnNbXCJBTkRcIl0gPSBcImFuZFwiO1xuICAgIGxvZ2ljYWxPcGVyYXRvcnNbXCJPUlwiXSA9IFwib3JcIjtcbn0pKGxvZ2ljYWxPcGVyYXRvcnMgfHwgKGxvZ2ljYWxPcGVyYXRvcnMgPSB7fSkpO1xudmFyIHNpbXBsZUZpZWxkVHlwZXM7XG4oZnVuY3Rpb24gKHNpbXBsZUZpZWxkVHlwZXMpIHtcbiAgICBzaW1wbGVGaWVsZFR5cGVzW1wiTlVNQkVSXCJdID0gXCJudW1iZXJcIjtcbiAgICBzaW1wbGVGaWVsZFR5cGVzW1wiU1RSSU5HXCJdID0gXCJzdHJpbmdcIjtcbiAgICBzaW1wbGVGaWVsZFR5cGVzW1wiREFURVwiXSA9IFwiZGF0ZVwiO1xuICAgIHNpbXBsZUZpZWxkVHlwZXNbXCJEQVRFX09OTFlcIl0gPSBcImRhdGUtb25seVwiO1xuICAgIHNpbXBsZUZpZWxkVHlwZXNbXCJPSURcIl0gPSBcIm9pZFwiO1xuICAgIHNpbXBsZUZpZWxkVHlwZXNbXCJHVUlEXCJdID0gXCJndWlkXCI7XG4gICAgc2ltcGxlRmllbGRUeXBlc1tcIkRPTUFJTlwiXSA9IFwiZG9tYWluXCI7XG59KShzaW1wbGVGaWVsZFR5cGVzIHx8IChzaW1wbGVGaWVsZFR5cGVzID0ge30pKTtcbnZhciBzdGF0dXM7XG4oZnVuY3Rpb24gKHN0YXR1cykge1xuICAgIHN0YXR1c1tcIk1JU1NJTkdcIl0gPSBcIm1pc3NpbmdcIjtcbiAgICBzdGF0dXNbXCJJTl9QUk9HUkVTU1wiXSA9IFwiaW5Qcm9ncmVzc1wiO1xuICAgIHN0YXR1c1tcIlNVQ0NFU1NcIl0gPSBcInN1Y2Nlc3NcIjtcbiAgICBzdGF0dXNbXCJGQUlMRURcIl0gPSBcImZhaWxlZFwiO1xufSkoc3RhdHVzIHx8IChzdGF0dXMgPSB7fSkpO1xudmFyIHRpbWVVbml0cztcbihmdW5jdGlvbiAodGltZVVuaXRzKSB7XG4gICAgdGltZVVuaXRzW1wiTUlOVVRFXCJdID0gXCJtaW51dGVcIjtcbiAgICB0aW1lVW5pdHNbXCJIT1VSXCJdID0gXCJob3VyXCI7XG4gICAgdGltZVVuaXRzW1wiREFZXCJdID0gXCJkYXlcIjtcbiAgICB0aW1lVW5pdHNbXCJXRUVLXCJdID0gXCJ3ZWVrXCI7XG4gICAgdGltZVVuaXRzW1wiTU9OVEhcIl0gPSBcIm1vbnRoXCI7XG4gICAgdGltZVVuaXRzW1wiWUVBUlwiXSA9IFwieWVhclwiO1xufSkodGltZVVuaXRzIHx8ICh0aW1lVW5pdHMgPSB7fSkpO1xudmFyIHRpbWVSYW5nZTtcbihmdW5jdGlvbiAodGltZVJhbmdlKSB7XG4gICAgdGltZVJhbmdlW3RpbWVSYW5nZVtcIk1JTlVURVwiXSA9IDYwMDAwXSA9IFwiTUlOVVRFXCI7XG4gICAgdGltZVJhbmdlW3RpbWVSYW5nZVtcIkhPVVJcIl0gPSAzNjAwMDAwXSA9IFwiSE9VUlwiO1xuICAgIHRpbWVSYW5nZVt0aW1lUmFuZ2VbXCJEQVlcIl0gPSA4NjQwMDAwMF0gPSBcIkRBWVwiO1xuICAgIHRpbWVSYW5nZVt0aW1lUmFuZ2VbXCJXRUVLXCJdID0gNjA0ODAwMDAwXSA9IFwiV0VFS1wiO1xuICAgIHRpbWVSYW5nZVt0aW1lUmFuZ2VbXCJNT05USFwiXSA9IDI1OTIwMDAwMDBdID0gXCJNT05USFwiO1xuICAgIHRpbWVSYW5nZVt0aW1lUmFuZ2VbXCJZRUFSXCJdID0gMzExMDQwMDAwMDBdID0gXCJZRUFSXCI7XG59KSh0aW1lUmFuZ2UgfHwgKHRpbWVSYW5nZSA9IHt9KSk7XG52YXIgc2NhbGVzO1xuKGZ1bmN0aW9uIChzY2FsZXMpIHtcbiAgICBzY2FsZXNbXCJTTUFMTFwiXSA9IFwic1wiO1xuICAgIHNjYWxlc1tcIk1FRElVTVwiXSA9IFwibVwiO1xuICAgIHNjYWxlc1tcIkxBUkdFXCJdID0gXCJsXCI7XG59KShzY2FsZXMgfHwgKHNjYWxlcyA9IHt9KSk7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZFxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBpc0VmZmVjdEVtcHR5KGZlYXR1cmVFZmZlY3QpIHtcbiAgICBpZiAoIWZlYXR1cmVFZmZlY3QgfHwgIWZlYXR1cmVFZmZlY3QuZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBjaGVja1Byb3BzID0gW1wiZ2VvbWV0cnlcIiwgXCJvYmplY3RJZHNcIiwgXCJ0aW1lRXh0ZW50XCIsIFwid2hlcmVcIl07XG4gICAgcmV0dXJuICFjaGVja1Byb3BzLnNvbWUoKHByb3ApID0+IGZlYXR1cmVFZmZlY3QuZmlsdGVyLmhhc093blByb3BlcnR5KHByb3ApICYmICEhZmVhdHVyZUVmZmVjdC5maWx0ZXJbcHJvcF0pO1xufVxuZnVuY3Rpb24gY2hlY2tDb25maWcocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIgfSA9IHByb3BzO1xuICAgIGNvbnN0IHVybCA9IGxheWVyLnVybDtcbiAgICBwcm9wcy5zdXBwb3J0c1N0YW5kYXJkaXplZFF1ZXJ5ID1cbiAgICAgICAgXCJ2ZXJzaW9uXCIgaW4gbGF5ZXIgJiYgbGF5ZXIudmVyc2lvbiA+PSAxMC4yICYmICEhKChfYiA9IChfYSA9IGxheWVyLmNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3VwcG9ydHNTdGFuZGFyZGl6ZWRRdWVyaWVzT25seSk7XG4gICAgcHJvcHMuc3VwcG9ydGVkU3FsUGFyc2VyVmVyc2lvbiA9XG4gICAgICAgIGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmXG4gICAgICAgICAgICBwcm9wcy5zdXBwb3J0c1N0YW5kYXJkaXplZFF1ZXJ5ICYmXG4gICAgICAgICAgICBsYXllci5zb3VyY2VKU09OLnNxbFBhcnNlclZlcnNpb24gJiZcbiAgICAgICAgICAgIGxheWVyLnNvdXJjZUpTT04uc3FsUGFyc2VyVmVyc2lvbiAhPT0gXCJFU18xMC42LjFcIjtcbiAgICBpZiAoIXVybCB8fCBtYXBJbWFnZVN1YmxheWVyKSB7XG4gICAgICAgIHByb3BzLmlzSG9zdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaG9zdGVkIGZlYXR1cmUgc2VydmljZTogaHR0cDovL3NlcnZpY2VzLmFyY2dpcy5jb20vZjdlZTQwMjgyY2JjNDA5OTg1NzI4MzQ1OTEwMjE5NzYvYXJjZ2lzL3Jlc3Qvc2VydmljZXMvU3RhdGVDYXBpdGFscy9GZWF0dXJlU2VydmVyXG4gICAgLy8gbmV3IGFtYXpvbiBob3N0ZWQgZmVhdHVyZSBzZXJ2aWNlOiBodHRwOi8vZmVhdHVyZXMuYXJjZ2lzLmNvbS9lMmVhM2MzMWRkODA0Nzg2ODljZTcwYzRmYjMzODBjNS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9zYW50YWNsYXJhX2ZzL0ZlYXR1cmVTZXJ2ZXJcbiAgICAvLyBob3N0ZWQgdGlsZWQgc2VydmljZTogaHR0cHM6Ly90aWxlc2RldmV4dC5hcmNnaXMuY29tL3RpbGVzL2ZhMDE5ZmJiZmJiODQ1ZDA4Y2M5ZjBhY2RlNmRkOGFmL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1N0YXRlcy9NYXBTZXJ2ZXJcbiAgICAvLyB1cGxvYWRlZCBLTUwgc2VydmljZTogaHR0cDovL3d3dy5hcmNnaXMuY29tL3NoYXJpbmcvY29udGVudC9pdGVtcy9lY2RkZGRhZjZiMTc0ZDdjYTk0ODE2YWMzOTdkOWI0OC9kYXRhXG4gICAgLy8gc2VjdXJlIHNlcnZpY2U6IGh0dHA6Ly93d3cuYXJjZ2lzLmNvbS9zaGFyaW5nL3Jlc3Qvc2VydmljZXMvYWVlMmEzZDlkMTVmNDA2Y2IyMTU3NmQ5MmVhMTMxNmUvTWFwU2VydmVyXG4gICAgY29uc3QgYXJjZ2lzID0gXCIuYXJjZ2lzLmNvbS9cIiwgc2VydmljZXMgPSBcIi8vc2VydmljZXNcIiwgdGlsZXMgPSBcIi8vdGlsZXNcIiwgZmVhdHVyZXMgPSBcIi8vZmVhdHVyZXNcIiwgbG9jYXRpb25zZXJ2aWNlcyA9IFwiLy9sb2NhdGlvbnNlcnZpY2VzXCIsIHZlbG9jaXR5VXMgPSBcIi8vdXMtaW90XCIsIHZlbG9jaXR5RXUgPSBcIi8vZXUtaW90XCI7XG4gICAgLy9zaGFyaW5nID0gKG5ldyBkb2pvLl9VcmwoZXNyaUdlb3dDb25maWcucmVzdEJhc2VVcmwpKS5hdXRob3JpdHksXG4gICAgLy9pc1NpbmdsZVRlbmFudCA9IGZhbHNlOyAvLyhmYWxzZSA9PT0gZXNyaUdlb3dDb25maWcuaXNNdWx0aVRlbmFudCk7XG4gICAgLy8gQ1IgIzIzOCw3MzIgLSBvbmx5IGNvbnNpZGVyIGxvY2FsbHkgaG9zdGVkIGlmIHRoZSByZXN0QmFzZVVybCBpcyBvbiBzYW1lIGRvbWFpbiBhcyB1cmxcbiAgICAvLyBhbmQgZXNyaUdlb3dDb25maWcuc2VsZi5zdXBwb3J0c0hvc3RlZFNlcnZpY2VzIGZsYWcgaXMgZW5hYmxlZFxuICAgIGNvbnN0IGlzQUdPTCA9IHVybC5pbmRleE9mKGFyY2dpcykgIT09IC0xLCBpc0hvc3RlZFNlcnZlciA9IHVybC5pbmRleE9mKHNlcnZpY2VzKSAhPT0gLTEgfHxcbiAgICAgICAgdXJsLmluZGV4T2YodGlsZXMpICE9PSAtMSB8fFxuICAgICAgICB1cmwuaW5kZXhPZihmZWF0dXJlcykgIT09IC0xIHx8XG4gICAgICAgIHVybC5pbmRleE9mKGxvY2F0aW9uc2VydmljZXMpICE9PSAtMSB8fFxuICAgICAgICB1cmwuaW5kZXhPZih2ZWxvY2l0eVVzKSAhPT0gLTEgfHxcbiAgICAgICAgdXJsLmluZGV4T2YodmVsb2NpdHlFdSkgIT09IC0xLCBpc0xvY2FsbHlIb3N0ZWQgPSBmYWxzZTsgLy8oKGlzRGVmaW5lZChlc3JpR2Vvd0NvbmZpZy5zZWxmKSAmJiBlc3JpR2Vvd0NvbmZpZy5zZWxmLnN1cHBvcnRzSG9zdGVkU2VydmljZXMpICYmICh1cmwuaW5kZXhPZihzaGFyaW5nKSAhPT0gLTEgJiYgIWlzU2luZ2xlVGVuYW50KSk7XG4gICAgLy9pc1Byb3h5U2VydmljZSA9ICFpc0hvc3RlZFNlcnZlciAmJiBhcmNnaXM7IC8vIGlmIHRoZSBzZXJ2aWNlIHJlcXVpcmVzIG5vbi1BR09MIGNyZWRlbnRpYWxzXG4gICAgcHJvcHMuaXNIb3N0ZWQgPSAoaXNBR09MICYmIGlzSG9zdGVkU2VydmVyKSB8fCAoIWlzQUdPTCAmJiBpc0xvY2FsbHlIb3N0ZWQpO1xufVxuZnVuY3Rpb24gZml4VUlEcyhleHByZXNzaW9ucykge1xuICAgIGlmICghZXhwcmVzc2lvbnMgfHwgIWV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9ucy5tYXAoKGV4cHJlc3Npb24sIGlkeCkgPT4ge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi51aWQgPT09IGBleHByZXNzaW9uLSR7aWR4fWApIHtcbiAgICAgICAgICAgIC8vIG5vIGNoYW5nZSB0byB1aWRcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4cHJlc3Npb24pLCB7IGNvbmRpdGlvbnM6IGV4cHJlc3Npb24uY29uZGl0aW9ucy5tYXAoKGNvbmRpdGlvbiwgaWR4MikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdVaWQgPSBgY29uZGl0aW9uLSR7aWR4fS0ke2lkeDJ9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbi51aWQgPT09IG5ld1VpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmRpdGlvbiksIHsgdWlkOiBuZXdVaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4cHJlc3Npb24pLCB7IHVpZDogYGV4cHJlc3Npb24tJHtpZHh9YCwgZXhwcmVzc2lvbkluZGV4OiBpZHgsIGNvbmRpdGlvbnM6IGV4cHJlc3Npb24uY29uZGl0aW9ucy5tYXAoKGNvbmRpdGlvbiwgaWR4MikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdVaWQgPSBgY29uZGl0aW9uLSR7aWR4fS0ke2lkeDJ9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbi51aWQgPT09IG5ld1VpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmRpdGlvbiksIHsgdWlkOiBuZXdVaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB1dGNUb0RhdGVQaWNrZXIodmFsdWUsIHRpbWVab25lKSB7XG4gICAgLy8gZGF0ZSBpcyBpbiBVVENcbiAgICAvLyB3ZSBuZWVkIGEgbWFwIHRpbWV6b25lXG4gICAgbGV0IHN0cjtcbiAgICBpZiAoIXRpbWVab25lIHx8IHRpbWVab25lID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIHN0ciA9IG5ldyBEYXRlKHZhbHVlIC0gZGlmZiAqIDYwMDAwKS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aW1lWm9uZSA9PT0gXCJ1bmtub3duXCIpIHtcbiAgICAgICAgc3RyID0gbmV3IERhdGUodmFsdWUpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkaWZmID0gbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICBjb25zdCBtYXBEYXRlU3RyID0gbmV3IERhdGUodmFsdWUpLnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIiwgeyB0aW1lWm9uZSB9KTtcbiAgICAgICAgc3RyID0gbmV3IERhdGUobmV3IERhdGUobWFwRGF0ZVN0cikuZ2V0VGltZSgpIC0gZGlmZiAqIDYwMDAwKS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwidXRjVG9EYXRlUGlja2VyXCIsIHZhbHVlLCBcIiAtIFwiLCBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKSwgXCIgLT4gXCIsIHN0cik7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGRhdGVQaWNrZXJUb1VUQyhkYXRlLCB0aW1lWm9uZSkge1xuICAgIC8vIGRhdGUgaXMgaW4gbWFwIHRpbWV6b25lXG4gICAgLy8gd2UgbmVlZCBhIFVUQyBVTklYIHRpbWVzdGFtcFxuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAoIXRpbWVab25lIHx8IHRpbWVab25lID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgIC8vIGFkZCBkaWZmZXJlbmNlIGJldHdlZW4gbG9jYWwgdGltZSBhbmQgVVRDXG4gICAgICAgIHZhbHVlID0gZGF0ZS5nZXRUaW1lKCkgKyBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGltZVpvbmUgPT09IFwidW5rbm93blwiKSB7XG4gICAgICAgIC8vIHRha2Ugd2hhdCB5b3UgZ2V0XG4gICAgICAgIHZhbHVlID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhZGQgZGlmZmVyZW5jZSBiZXR3ZWVuIG1hcCB0aW1lIGFuZCBVVENcbiAgICAgICAgY29uc3QgZGlmZiA9IG5ldyBEYXRlKGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lOiBcInV0Y1wiIH0pKS5nZXRUaW1lKCkgLVxuICAgICAgICAgICAgbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHsgdGltZVpvbmUgfSkpLmdldFRpbWUoKTtcbiAgICAgICAgdmFsdWUgPSBkYXRlLmdldFRpbWUoKSArIGRpZmY7XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coXCJkYXRlUGlja2VyVG9VVENcIiwgZGF0ZS50b0lTT1N0cmluZygpLCBcIiAtPiBcIiwgbmV3IERhdGUodmFsdWUpLnRvSVNPU3RyaW5nKCkpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG1hcFRaVG9VVEModmFsdWUsIHRpbWVab25lKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vIHZhbHVlIGlzIGluIG1hcCB0aW1lem9uZVxuICAgIC8vIHdlIG5lZWQgYSBVVEMgdGltZXN0YW1wXG4gICAgbGV0IG5ld1ZhbHVlO1xuICAgIGlmICghdGltZVpvbmUgfHwgdGltZVpvbmUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgLy8gYWRkIGRpZmZlcmVuY2UgYmV0d2VlbiBsb2NhbCB0aW1lIGFuZCBVVENcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWUgKyBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGltZVpvbmUgPT09IFwidW5rbm93blwiKSB7XG4gICAgICAgIC8vIHRha2Ugd2hhdCB5b3UgZ2V0XG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhZGQgZGlmZmVyZW5jZSBiZXR3ZWVuIG1hcCB0aW1lIGFuZCBVVENcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXcgRGF0ZShkYXRlLnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIiwgeyB0aW1lWm9uZTogXCJ1dGNcIiB9KSkuZ2V0VGltZSgpIC1cbiAgICAgICAgICAgIG5ldyBEYXRlKGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lIH0pKS5nZXRUaW1lKCk7XG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWUgKyBkaWZmO1xuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwibWFwVFpUb1VUQ1wiLCB2YWx1ZSwgXCIgLSBcIiwgbmV3IERhdGUodmFsdWUpLnRvSVNPU3RyaW5nKCksIFwiIC0gXCIsIG5ldyBEYXRlKG5ld1ZhbHVlKS50b0lTT1N0cmluZygpKTtcbiAgICByZXR1cm4gbmV3VmFsdWU7XG59XG5mdW5jdGlvbiBnZXREYXRlRGlzcGxheVN0cmluZyh2YWx1ZSwgdGltZVpvbmUsIGludGwsIGRhdGVGb3JtYXQpIHtcbiAgICBsZXQgc3RyO1xuICAgIGlmICh0aW1lWm9uZSA9PT0gXCJ1bmtub3duXCIpIHtcbiAgICAgICAgc3RyID0gaW50bC5mb3JtYXREYXRlKHZhbHVlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGwuY29udmVydERhdGVGb3JtYXRUb0ludGxPcHRpb25zKGRhdGVGb3JtYXQgfHwgXCJzaG9ydC1kYXRlLXNob3J0LXRpbWVcIikpLCB7IHRpbWVab25lOiBcInV0Y1wiLCB0aW1lWm9uZU5hbWU6IFwic2hvcnRPZmZzZXRcIiB9KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBrbm93biBpc3N1ZXMgd2l0aCBmb3JtYXR0aW5nIGl0LUNIXG4gICAgICAgIHN0ciA9IGludGwuZm9ybWF0RGF0ZSh2YWx1ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRsLmNvbnZlcnREYXRlRm9ybWF0VG9JbnRsT3B0aW9ucyhkYXRlRm9ybWF0IHx8IFwic2hvcnQtZGF0ZS1zaG9ydC10aW1lXCIpKSwgeyB0aW1lWm9uZSB9KSk7XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coXCJnZXREYXRlRGlzcGxheVN0cmluZ1wiLCB2YWx1ZSwgXCIgLSBcIiwgbmV3IERhdGUodmFsdWUpLnRvSVNPU3RyaW5nKCksIFwiIC0+IFwiLCBzdHIpO1xuICAgIHJldHVybiBzdHI7XG59XG5cbi8vaW1wb3J0IERvbWFpbiBmcm9tIFwiZXNyaS9sYXllcnMvc3VwcG9ydC9Eb21haW5cIjtcbmFzeW5jIGZ1bmN0aW9uIGNvbGxlY3RGaWVsZERvbWFpbnMocHJvcHMpIHtcbiAgICAvLyB3ZSBkbyBub3Qgc3VwcG9ydCBzdWJUeXBlcyAuLi5cbiAgICBjb25zdCB7IGxheWVyLCBmaWVsZHMgfSA9IHByb3BzO1xuICAgIGlmIChsYXllci50eXBlICE9PSBcImZlYXR1cmVcIikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR5cGVJZEZpZWxkID0gbGF5ZXIudHlwZUlkRmllbGQ7XG4gICAgY29uc3QgdHlwZXMgPSBsYXllci50eXBlcztcbiAgICBmaWVsZHMuZm9yRWFjaChhc3luYyAoZmVhdHVyZUZpZWxkKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGZlYXR1cmVGaWVsZC5sYXllckZpZWxkLm5hbWU7XG4gICAgICAgIGNvbnN0IGZpZWxkRG9tYWluID0gZmVhdHVyZUZpZWxkLmxheWVyRmllbGQuZG9tYWluO1xuICAgICAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICAgICAgaWYgKCFmaWx0ZXJGaWVsZCkge1xuICAgICAgICAgICAgLy8gbWF5YmUgZ2VvbWV0cnkgZmllbGRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZUlkRmllbGQgJiYgdHlwZXMpIHtcbiAgICAgICAgICAgIC8vIGxheWVyIGhhcyB0eXBlc1xuICAgICAgICAgICAgaWYgKHR5cGVJZEZpZWxkID09PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBmaWVsZCB3aXRoIHRoZSB0eXBlc1xuICAgICAgICAgICAgICAgIGZpbHRlckZpZWxkLmZpZWxkRG9tYWlucyA9IHR5cGVzLm1hcCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWtlIGNvZGVkIFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogdHlwZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHR5cGUubmFtZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdldFNpbXBsZUZpZWxkVHlwZShwcm9wcywgZmlsdGVyRmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZmllbGQgZG9lcyBub3QgaGF2ZSB0eXBlczsgbG9vayBmYXJ0aGVyIGluc2lkZSB0aGUgdHlwZXNcbiAgICAgICAgICAgICAgICBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0eXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZS5kb21haW5zIHx8ICF0eXBlLmRvbWFpbnNbZmllbGROYW1lXSB8fCB0eXBlLmRvbWFpbnNbZmllbGROYW1lXS50eXBlID09PSBcImluaGVyaXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gLypEb21haW4qLyA9IGZpZWxkRG9tYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiA9PT0gbnVsbCB8fCBkb21haW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvbWFpbi5jb2RlZFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbi5jb2RlZFZhbHVlcy5mb3JFYWNoKGFzeW5jIChjb2RlZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMuZm9yRWFjaCgoY29kZWRWYWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlZFZhbC5jb2RlID09PSBjb2RlZFZhbHVlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGAsICR7Y29kZWRWYWwubmFtZX0sYC5pbmRleE9mKGAsICR7Y29kZWRWYWx1ZS5uYW1lfSxgKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWRWYWwubmFtZSArPSBgLCAke2NvZGVkVmFsdWUubmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtlc3JpTGFuZ10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2NvcmUvbGFuZ1wiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMucHVzaChlc3JpTGFuZy5jbG9uZShjb2RlZFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoX2IgPSAoX2EgPSB0eXBlLmRvbWFpbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtmaWVsZE5hbWVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29kZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUuZG9tYWluc1tmaWVsZE5hbWVdLmNvZGVkVmFsdWVzLmZvckVhY2goYXN5bmMgKGNvZGVkVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMuZm9yRWFjaCgoY29kZWRWYWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVkVmFsLmNvZGUgPT09IGNvZGVkVmFsdWUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGAsICR7Y29kZWRWYWwubmFtZX0sYC5pbmRleE9mKGAsICR7Y29kZWRWYWx1ZS5uYW1lfSxgKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlZFZhbC5uYW1lICs9IGAsICR7Y29kZWRWYWx1ZS5uYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtlc3JpTGFuZ10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2NvcmUvbGFuZ1wiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckZpZWxkLmZpZWxkRG9tYWlucy5wdXNoKGVzcmlMYW5nLmNsb25lKGNvZGVkVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlsdGVyRmllbGQuZmllbGREb21haW5zID0gZmlsdGVyRmllbGQuZmllbGREb21haW5zLmNvbmNhdCh0eXBlLmRvbWFpbnNbZmllbGQubmFtZV0uY29kZWRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy99IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogLi4uIHdyb25nLCBpdCdzIG5vdCB0aGUgdHlwZUlkRmllbGQgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZha2UgY29kZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckZpZWxkLmZpZWxkRG9tYWlucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiB0eXBlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHR5cGUubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZCBoYXMgbm8gZG9tYWluc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIGZpbHRlckZpZWxkLmZpZWxkRG9tYWlucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNGaWVsZERvbWFpbnMoZmlsdGVyRmllbGQpICYmIChmaWVsZERvbWFpbiA9PT0gbnVsbCB8fCBmaWVsZERvbWFpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGREb21haW4uY29kZWRWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2VzcmlMYW5nXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvY29yZS9sYW5nXCJdKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMgPSBlc3JpTGFuZy5jbG9uZShmaWVsZERvbWFpbi5jb2RlZFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGREb21haW4gPT09IG51bGwgfHwgZmllbGREb21haW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkRG9tYWluLmNvZGVkVmFsdWVzKSB7XG4gICAgICAgICAgICAvLyBkb21haW5zIGRpcmVjdGx5IG9uIHRoZSBsYXllciBmaWVsZFxuICAgICAgICAgICAgZmlsdGVyRmllbGQuZmllbGREb21haW5zID0gZmllbGREb21haW4uY29kZWRWYWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGluIGNhc2UgaXQgaGFzIGNoYW5nZWRcbiAgICAgICAgZ2V0U2ltcGxlRmllbGRUeXBlKHByb3BzLCBmaWx0ZXJGaWVsZCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXREZWNvZGVkVmFsdWUodmFsdWUsIGZpbHRlckZpZWxkKSB7XG4gICAgY29uc3QgY29kZWRWYWx1ZXMgPSBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnM7XG4gICAgaWYgKGNvZGVkVmFsdWVzKSB7XG4gICAgICAgIGxldCBsYWJlbCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVkVmFsdWUgPSBjb2RlZFZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmIChjb2RlZFZhbHVlLmNvZGUgPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCArPSAobGFiZWwubGVuZ3RoID8gXCIgfCBcIiA6IFwiXCIpICsgY29kZWRWYWx1ZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9XG4gICAgLy8gZGlkIG5vdCBmaW5kIGl0XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaGFzRmllbGREb21haW5zKGZpbHRlckZpZWxkKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGg7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkRmlsdGVyRmllbGRzKHByb3BzKSB7XG4gICAgY29uc3QgeyBsYXllciwgbWFwSW1hZ2VTdWJsYXllciwgZmVhdHVyZVJlZHVjdGlvbiB9ID0gcHJvcHM7XG4gICAgaWYgKCFsYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmZWF0dXJlUmVkdWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBidWlsZEZlYXR1cmVSZWR1Y3Rpb25GaWVsZHMocHJvcHMpO1xuICAgIH1cbiAgICBsZXQgbGF5ZXJGaWVsZHMgPSBsYXllci5maWVsZHM7XG4gICAgLy8gaHR0cHM6Ly9kZW1vZ3JhcGhpY3M5ZGV2LmFyY2dpcy5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvVVNBX0RlbW9ncmFwaGljc19hbmRfQm91bmRhcmllc18yMDE5L01hcFNlcnZlclxuICAgIGlmIChtYXBJbWFnZVN1YmxheWVyICYmXG4gICAgICAgIG1hcEltYWdlU3VibGF5ZXIubGF5ZXIucG9ydGFsSXRlbSAmJlxuICAgICAgICBtYXBJbWFnZVN1YmxheWVyLmxheWVyLnVybC5pbmRleE9mKFwiaHR0cHM6Ly9kZW1vZ3JhcGhpY3NcIikgPiAtMSAmJlxuICAgICAgICBtYXBJbWFnZVN1YmxheWVyLmxheWVyLnVybC5pbmRleE9mKFwiLmFyY2dpcy5jb21cIikgPiAtMSkge1xuICAgICAgICBjb25zdCBwb3J0YWxJdGVtID0gbWFwSW1hZ2VTdWJsYXllci5sYXllci5wb3J0YWxJdGVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3J0YWxJdGVtLmZldGNoRGF0YSgpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS50aGVtYXRpY0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IHJlc3BvbnNlLnRoZW1hdGljR3JvdXAuZmllbGROYW1lcztcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBsYXllckZpZWxkcyA9IGxheWVyRmllbGRzLmZpbHRlcigobGF5ZXJGaWVsZCkgPT4gZmllbGROYW1lcy5pbmRleE9mKGxheWVyRmllbGQubmFtZSkgPiAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkRmVhdHVyZUZpbHRlckZpZWxkc0FmdGVyVGhlbWF0aWNHcm91cENoZWNrKHByb3BzLCBsYXllckZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBhc3N1bWUgdGhlcmUgaXMgbm9uZVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkRmVhdHVyZUZpbHRlckZpZWxkc0FmdGVyVGhlbWF0aWNHcm91cENoZWNrKHByb3BzLCBsYXllckZpZWxkcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBidWlsZEZlYXR1cmVGaWx0ZXJGaWVsZHNBZnRlclRoZW1hdGljR3JvdXBDaGVjayhwcm9wcywgbGF5ZXJGaWVsZHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRmVhdHVyZUZpbHRlckZpZWxkc0FmdGVyVGhlbWF0aWNHcm91cENoZWNrKHByb3BzLCBsYXllckZpZWxkcykge1xuICAgIGlmICghcHJvcHMuZmllbGRzIHx8ICFwcm9wcy5maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgIHByb3BzLmZpZWxkcyA9IFtdO1xuICAgICAgICBwcm9wcy5zdHJpbmdGaWVsZHNDb3VudCA9IDA7XG4gICAgICAgIHByb3BzLmRhdGVGaWVsZHNDb3VudCA9IDA7XG4gICAgICAgIHByb3BzLm51bWJlckZpZWxkc0NvdW50ID0gMDtcbiAgICAgICAgaWYgKCFwcm9wcy5zdXBwb3J0c1N0YW5kYXJkaXplZFF1ZXJ5KSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBjbGllbnQgc2lkZSBmaWx0ZXIgZWZmZWN0IG9ubHkgc3VwcG9ydHMgc3FsOTIgYW5kIG5lZWRzIHRoZSB0aW1lc3RhbXAgaW4gdGhlIHF1ZXJ5XG4gICAgICAgICAgICAvLyB0aGVyZm9yZSB3ZSBkaXNhYmxlIGRhdGEgZmllbGRzIGZvciBzZXJ2aWNlcyB3aXRob3V0IHN0YW5kYXJkaXplZFF1ZXJ5IHN1cHBvcnRcbiAgICAgICAgICAgIGxheWVyRmllbGRzID0gbGF5ZXJGaWVsZHMuZmlsdGVyKChsYXllckZpZWxkKSA9PiBbXCJkYXRlXCIsIFwiZGF0ZS1vbmx5XCJdLmluZGV4T2YobGF5ZXJGaWVsZC50eXBlKSA9PT0gLTEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZEluZm9zID0gW107XG4gICAgICAgIGlmIChwcm9wcy5sYXllci50eXBlICE9PSBcInN1YnR5cGUtZ3JvdXBcIikge1xuICAgICAgICAgICAgY29uc3QgeyBwb3B1cFRlbXBsYXRlIH0gPSBwcm9wcy5sYXllcjtcbiAgICAgICAgICAgIGZpZWxkSW5mb3MgPSBwb3B1cFRlbXBsYXRlID8gcG9wdXBUZW1wbGF0ZS5maWVsZEluZm9zIDogW107XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXJGaWVsZHMuZm9yRWFjaCgobGF5ZXJGaWVsZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IGZpZWxkSW5mb3NcbiAgICAgICAgICAgICAgICA/IGZpZWxkSW5mb3MuZmlsdGVyKChmaWVsZEluZm8pID0+IGZpZWxkSW5mby5maWVsZE5hbWUgPT09IGxheWVyRmllbGQubmFtZSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IChsaXN0ID09PSBudWxsIHx8IGxpc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3QubGVuZ3RoKSA/IGxpc3RbMF0ubGFiZWwgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJGaWVsZDogbGF5ZXJGaWVsZCxcbiAgICAgICAgICAgICAgICBzdGF0aXN0aWNzU3RhdHVzOiBzdGF0dXMuTUlTU0lORyxcbiAgICAgICAgICAgICAgICBoaXN0b2dyYW1TdGF0dXM6IHN0YXR1cy5NSVNTSU5HLFxuICAgICAgICAgICAgICAgIHVuaXF1ZVZhbHVlc1N0YXR1czogc3RhdHVzLk1JU1NJTkcsXG4gICAgICAgICAgICAgICAgcGFydGlhbFVuaXF1ZVZhbHVlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsIHx8IGxheWVyRmllbGQuYWxpYXMgfHwgbGF5ZXJGaWVsZC5uYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2V0U2ltcGxlRmllbGRUeXBlKHByb3BzLCBmaWx0ZXJGaWVsZCk7XG4gICAgICAgICAgICBpZiAoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuZmllbGRzLnB1c2goZmlsdGVyRmllbGQpO1xuICAgICAgICAgICAgfSAvLyBlbHNlIGNhbid0IHVzZSBmaWVsZCBmb3IgZmlsdGVyXG4gICAgICAgIH0pO1xuICAgICAgICBjb2xsZWN0RmllbGREb21haW5zKHByb3BzKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBidWlsZEZlYXR1cmVSZWR1Y3Rpb25GaWVsZHMocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllciwgdmlldyB9ID0gcHJvcHM7XG4gICAgaWYgKGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeVwiIHx8IGxheWVyLnR5cGUgPT09IFwic3VidHlwZS1ncm91cFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoKF9hID0gcHJvcHMuZmllbGRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICBwcm9wcy5maWVsZHMgPSBbXTtcbiAgICAgICAgcHJvcHMuc3RyaW5nRmllbGRzQ291bnQgPSAwO1xuICAgICAgICBwcm9wcy5kYXRlRmllbGRzQ291bnQgPSAwO1xuICAgICAgICBwcm9wcy5udW1iZXJGaWVsZHNDb3VudCA9IDE7XG4gICAgICAgIGxldCBjb3VudCA9IDUwMDA7XG4gICAgICAgIGxldCBhdmcgPSAxMDtcbiAgICAgICAgbGV0IGZlYXR1cmVDb3VudCA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmZWF0dXJlQ291bnQgPSBhd2FpdCBnZXRGZWF0dXJlQ291bnQobGF5ZXIsIHZpZXcpO1xuICAgICAgICAgICAgY291bnQgPSBmZWF0dXJlQ291bnQgPyBNYXRoLm1pbihNYXRoLm1heCgxMCwgTWF0aC5jZWlsKGZlYXR1cmVDb3VudCAvIDQpKSwgNTAwMCkgOiA1MDAwO1xuICAgICAgICAgICAgYXZnID0gZmVhdHVyZUNvdW50ICYmIGZlYXR1cmVDb3VudCA+PSAxMDAwID8gMTAwIDogMTA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9iKSB7IH1cbiAgICAgICAgY29uc3QgW0ZpZWxkXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvbGF5ZXJzL3N1cHBvcnQvRmllbGRcIl0pO1xuICAgICAgICBjb25zdCBmZWF0dXJlUmVkdWN0aW9uID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbjtcbiAgICAgICAgcHJvcHMuZmllbGRzID0gW107XG4gICAgICAgIGZlYXR1cmVSZWR1Y3Rpb24uZmllbGRzLmZvckVhY2goKGFnZ3JlZ2F0ZUZpZWxkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0NvdW50ID0gYWdncmVnYXRlRmllbGQuc3RhdGlzdGljVHlwZSA9PT0gXCJjb3VudFwiO1xuICAgICAgICAgICAgY29uc3QgbGF5ZXJGaWVsZCA9IGFnZ3JlZ2F0ZUZpZWxkLm9uU3RhdGlzdGljRmllbGQgJiZcbiAgICAgICAgICAgICAgICBsYXllci5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IGFnZ3JlZ2F0ZUZpZWxkLm9uU3RhdGlzdGljRmllbGQpO1xuICAgICAgICAgICAgaWYgKCghYWdncmVnYXRlRmllbGQub25TdGF0aXN0aWNGaWVsZCAmJiBpc0NvdW50KSB8fCBsYXllckZpZWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyRmllbGQ6IG5ldyBGaWVsZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhZ2dyZWdhdGVGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IGFnZ3JlZ2F0ZUZpZWxkLmFsaWFzIHx8IGFnZ3JlZ2F0ZUZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAobGF5ZXJGaWVsZCA9PT0gbnVsbCB8fCBsYXllckZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllckZpZWxkLnR5cGUpIHx8IFwiaW50ZWdlclwiXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzdGF0aXN0aWNzU3RhdHVzOiBpc0NvdW50ID8gc3RhdHVzLlNVQ0NFU1MgOiBzdGF0dXMuTUlTU0lORyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGlzdGljczogaXNDb3VudCA/IHsgbWluOiAxLCBtYXg6IGNvdW50LCBhdmcgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9ncmFtU3RhdHVzOiBpc0NvdW50ID8gc3RhdHVzLkZBSUxFRCA6IHN0YXR1cy5NSVNTSU5HLFxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVWYWx1ZXNTdGF0dXM6IHN0YXR1cy5NSVNTSU5HLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsVW5pcXVlVmFsdWVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGFnZ3JlZ2F0ZUZpZWxkLmFsaWFzIHx8IGFnZ3JlZ2F0ZUZpZWxkLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgLy9zaW1wbGVGaWVsZFR5cGU6IC4uLlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZ2V0U2ltcGxlRmllbGRUeXBlKHByb3BzLCBmaWx0ZXJGaWVsZCk7XG4gICAgICAgICAgICAgICAgcHJvcHMuZmllbGRzLnB1c2goZmlsdGVyRmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcykge1xuICAgIGNvbnN0IHsgZmllbGRzIH0gPSBwcm9wcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgaWYgKGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyRmllbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRGaWVsZChwcm9wcykge1xuICAgIGNvbnN0IHsgZmllbGRzLCBkZWZhdWx0RmllbGROYW1lIH0gPSBwcm9wcztcbiAgICBpZiAoZGVmYXVsdEZpZWxkTmFtZSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0RmllbGQgPSBmaWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZGVmYXVsdEZpZWxkTmFtZSk7XG4gICAgICAgIGlmIChkZWZhdWx0RmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RmllbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZpcnN0TnVtYmVyRmllbGQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIGlmIChmaWVsZC5zaW1wbGVGaWVsZFR5cGUgJiZcbiAgICAgICAgICAgIFtzaW1wbGVGaWVsZFR5cGVzLk9JRCwgc2ltcGxlRmllbGRUeXBlcy5HVUlELCBzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLmluZGV4T2YoZmllbGQuc2ltcGxlRmllbGRUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSICYmICFmaXJzdE51bWJlckZpZWxkKSB7XG4gICAgICAgICAgICAgICAgZmlyc3ROdW1iZXJGaWVsZCA9IGZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nIGZpZWxkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdlIGRpZG4ndCBmaW5kIGEgc3RyaW5nIGZpZWxkXG4gICAgaWYgKGZpcnN0TnVtYmVyRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0TnVtYmVyRmllbGQ7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHNbMF07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0VmFsdWVzKHByb3BzLCBmaWx0ZXJGaWVsZCwgb3BlcmF0b3IpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCBzdGF0aXN0aWNzID0gZmlsdGVyRmllbGQuc3RhdGlzdGljcztcbiAgICBpZiAoIXN0YXRpc3RpY3MpIHtcbiAgICAgICAgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkcgJiZcbiAgICAgICAgICAgIGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlc1N0YXR1cyA9PT0gc3RhdHVzLlNVQ0NFU1MgJiZcbiAgICAgICAgICAgICgoX2EgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZUluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAmJlxuICAgICAgICAgICAgW3N0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXMsIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RdLmluZGV4T2Yob3BlcmF0b3IpID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlSW5mb3NbMF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGlzSW5UaGVMYXN0T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSkge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBNYXRoLmFicyhub3cgLSBzdGF0aXN0aWNzLmF2Zyk7XG4gICAgICAgIGlmIChyYW5nZSA+IDIgKiB0aW1lUmFuZ2UuWUVBUikge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gTWF0aC5yb3VuZChyYW5nZSAvIHRpbWVSYW5nZS5ZRUFSKTtcbiAgICAgICAgICAgIHJlc3VsdC51bml0ID0gdGltZVVuaXRzLllFQVI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmFuZ2UgPiAyICogdGltZVJhbmdlLk1PTlRIKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gTWF0aC5yb3VuZChyYW5nZSAvIHRpbWVSYW5nZS5NT05USCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVuaXQgPSB0aW1lVW5pdHMuTU9OVEg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPiAyICogdGltZVJhbmdlLldFRUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gTWF0aC5yb3VuZChyYW5nZSAvIHRpbWVSYW5nZS5XRUVLKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVuaXQgPSB0aW1lVW5pdHMuV0VFSztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZSA+IDIgKiB0aW1lUmFuZ2UuREFZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBNYXRoLnJvdW5kKHJhbmdlIC8gdGltZVJhbmdlLkRBWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudW5pdCA9IHRpbWVVbml0cy5EQVk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPiAyICogdGltZVJhbmdlLkhPVVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBNYXRoLnJvdW5kKHJhbmdlIC8gdGltZVJhbmdlLkhPVVIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC51bml0ID0gdGltZVVuaXRzLkhPVVI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBNYXRoLnJvdW5kKHJhbmdlIC8gdGltZVJhbmdlLk1JTlVURSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVuaXQgPSB0aW1lVW5pdHMuTUlOVVRFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQmV0d2Vlbk9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gZmllbGRUeXBlUm91bmQoc3RhdGlzdGljcy5hdmcsIHByb3BzLCBmaWx0ZXJGaWVsZCk7XG4gICAgICAgIHJlc3VsdC52YWx1ZTIgPSBmaWVsZFR5cGVSb3VuZChzdGF0aXN0aWNzLm1heCwgcHJvcHMsIGZpbHRlckZpZWxkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IGZpZWxkVHlwZVJvdW5kKHN0YXRpc3RpY3MuYXZnLCBwcm9wcywgZmlsdGVyRmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0U2lnbmlmaWNhbnREaWdpdHMocHJvcHMsIGZpbHRlckZpZWxkKSB7XG4gICAgY29uc3QgeyBsYXllciB9ID0gcHJvcHM7XG4gICAgbGV0IHNpZ25pZmljYW50RGlnaXRzID0gMjtcbiAgICBjb25zdCBwb3B1cFRlbXBsYXRlID0gbGF5ZXIudHlwZSAhPT0gXCJzdWJ0eXBlLWdyb3VwXCIgJiYgbGF5ZXIucG9wdXBUZW1wbGF0ZTtcbiAgICBpZiAocG9wdXBUZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBwb3BGaWVsZEluZm9zID0gcG9wdXBUZW1wbGF0ZS5maWVsZEluZm9zLmZpbHRlcigoZmllbGRJbmZvKSA9PiBmaWVsZEluZm8uZmllbGROYW1lID09PSBmaWx0ZXJGaWVsZC5sYXllckZpZWxkLm5hbWUpO1xuICAgICAgICBpZiAocG9wRmllbGRJbmZvcyA9PT0gbnVsbCB8fCBwb3BGaWVsZEluZm9zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3BGaWVsZEluZm9zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcG9wRmllbGRJbmZvID0gcG9wRmllbGRJbmZvc1swXTtcbiAgICAgICAgICAgIGlmIChwb3BGaWVsZEluZm8uZm9ybWF0ICYmIGlzRGVmaW5lZChwb3BGaWVsZEluZm8uZm9ybWF0LnBsYWNlcykpIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FudERpZ2l0cyA9IHBvcEZpZWxkSW5mby5mb3JtYXQucGxhY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaWduaWZpY2FudERpZ2l0cztcbn1cbmZ1bmN0aW9uIHJvdW5kVG9TaWduaWZpY2FudERpZ2l0cyh2YWx1ZSwgcHJvcHMsIGZpbHRlckZpZWxkKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnREaWdpdHMgPSBnZXRTaWduaWZpY2FudERpZ2l0cyhwcm9wcywgZmlsdGVyRmllbGQpO1xuICAgIGNvbnN0IGZhY3RvciA9IE1hdGgucG93KDEwLCBzaWduaWZpY2FudERpZ2l0cyk7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2YWx1ZSkgJiYgTWF0aC5yb3VuZCh2YWx1ZSAqIGZhY3RvcikgLyBmYWN0b3I7XG59XG5mdW5jdGlvbiBmaWVsZFR5cGVSb3VuZCh2YWx1ZSwgcHJvcHMsIGZpbHRlckZpZWxkKSB7XG4gICAgcmV0dXJuIChpc0RlZmluZWQodmFsdWUpICYmXG4gICAgICAgIChpc0ludGVnZXJUeXBlKGZpbHRlckZpZWxkKSA/IE1hdGgucm91bmQodmFsdWUpIDogcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKHZhbHVlLCBwcm9wcywgZmlsdGVyRmllbGQpKSk7XG59XG5mdW5jdGlvbiBnZXRTaW1wbGVGaWVsZFR5cGUocHJvcHMsIGZlYXR1cmVGaWx0ZXJGaWVsZCkge1xuICAgIHN3aXRjaCAoZmVhdHVyZUZpbHRlckZpZWxkLmxheWVyRmllbGQudHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBmZWF0dXJlRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkc7XG4gICAgICAgICAgICBwcm9wcy5zdHJpbmdGaWVsZHNDb3VudCsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICBpZiAoaGFzRmllbGREb21haW5zKGZlYXR1cmVGaWx0ZXJGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkc7XG4gICAgICAgICAgICAgICAgcHJvcHMuc3RyaW5nRmllbGRzQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVGaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPSBzaW1wbGVGaWVsZFR5cGVzLkRBVEU7XG4gICAgICAgICAgICAgICAgcHJvcHMuZGF0ZUZpZWxkc0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGUtb25seVwiOlxuICAgICAgICAgICAgZmVhdHVyZUZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9IHNpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvaWRcIjpcbiAgICAgICAgICAgIGZlYXR1cmVGaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPSBzaW1wbGVGaWVsZFR5cGVzLk9JRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ3VpZFwiOlxuICAgICAgICAgICAgZmVhdHVyZUZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9IHNpbXBsZUZpZWxkVHlwZXMuR1VJRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic21hbGwtaW50ZWdlclwiOlxuICAgICAgICBjYXNlIFwiYmlnLWludGVnZXJcIjpcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgY2FzZSBcInNpbmdsZVwiOlxuICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICAgICAgICBpZiAoaGFzRmllbGREb21haW5zKGZlYXR1cmVGaWx0ZXJGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkc7XG4gICAgICAgICAgICAgICAgcHJvcHMuc3RyaW5nRmllbGRzQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVGaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPSBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUjtcbiAgICAgICAgICAgICAgICBwcm9wcy5udW1iZXJGaWVsZHNDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNOdW1iZXJUeXBlKGZlYXR1cmVGaWx0ZXJGaWVsZCkge1xuICAgIHJldHVybiAoW1wic21hbGwtaW50ZWdlclwiLCBcImJpZy1pbnRlZ2VyXCIsIFwiaW50ZWdlclwiLCBcInNpbmdsZVwiLCBcImRvdWJsZVwiLCBcImxvbmdcIl0uaW5kZXhPZihmZWF0dXJlRmlsdGVyRmllbGQubGF5ZXJGaWVsZC50eXBlKSA+IC0xKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZWdlclR5cGUoZmVhdHVyZUZpbHRlckZpZWxkKSB7XG4gICAgcmV0dXJuIFtcInNtYWxsLWludGVnZXJcIiwgXCJiaWctaW50ZWdlclwiLCBcImludGVnZXJcIiwgXCJsb25nXCJdLmluZGV4T2YoZmVhdHVyZUZpbHRlckZpZWxkLmxheWVyRmllbGQudHlwZSkgPiAtMTtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRUeXBlKGZlYXR1cmVGaWx0ZXJGaWVsZCkge1xuICAgIHJldHVybiBbXCJzaW5nbGVcIiwgXCJkb3VibGVcIl0uaW5kZXhPZihmZWF0dXJlRmlsdGVyRmllbGQubGF5ZXJGaWVsZC50eXBlKSA+IC0xO1xufVxuZnVuY3Rpb24gaXNEYXRlVHlwZShmZWF0dXJlRmlsdGVyRmllbGQpIHtcbiAgICByZXR1cm4gW1wiZGF0ZVwiXS5pbmRleE9mKGZlYXR1cmVGaWx0ZXJGaWVsZC5sYXllckZpZWxkLnR5cGUpID4gLTE7XG59XG5mdW5jdGlvbiBpc0RhdGVPbmx5VHlwZShmZWF0dXJlRmlsdGVyRmllbGQpIHtcbiAgICByZXR1cm4gW1wiZGF0ZS1vbmx5XCJdLmluZGV4T2YoZmVhdHVyZUZpbHRlckZpZWxkLmxheWVyRmllbGQudHlwZSkgPiAtMTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9ncmFtKGZpZWxkTmFtZSwgb3BlcmF0b3IsIHByb3BzKSB7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICAvLyBUT0RPIC0gYWxzbyBjaGVjayBmaWVsZCB2YWx1ZSB0eXBlID9cbiAgICBpZiAoZmlsdGVyRmllbGQgJiZcbiAgICAgICAgZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlICYmXG4gICAgICAgIGZpbHRlckZpZWxkLnN0YXRpc3RpY3NTdGF0dXMgIT09IFwiZmFpbGVkXCIgJiZcbiAgICAgICAgKChbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVIsIHNpbXBsZUZpZWxkVHlwZXMuREFURSwgc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLmluZGV4T2YoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSA+IC0xICYmXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJcyxcbiAgICAgICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc09uLFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IHJlbWVtYmVyIHRoZSByZWFzb24gd2UgaGlkIGlzTm90T24gZm9yIGRhdGUgZmllbGRzIGluIHRoZSBwYXN0LCBzbyBlbmFibGluZyBpdCBhZ2FpblxuICAgICAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90T24sXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdCxcbiAgICAgICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTGVzc1RoYW4sXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCZWZvcmUsXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0dyZWF0ZXJUaGFuLFxuICAgICAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQWZ0ZXIsXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TW9zdCxcbiAgICAgICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRMZWFzdCxcbiAgICAgICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQmV0d2VlbixcbiAgICAgICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JldHdlZW4sXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdEJldHdlZW4sXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RCZXR3ZWVuXG4gICAgICAgICAgICBdLmluZGV4T2Yob3BlcmF0b3IpID4gLTEpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhwcm9wcykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIGV4cHJlc3Npb25zLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBpZiAobGF5ZXIudHlwZSAhPT0gXCJmZWF0dXJlXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHBvcnRhbEl0ZW0sIHNvdXJjZUpTT04gfSA9IGxheWVyO1xuICAgIGlmICghcG9ydGFsSXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZUtleXdvcmRzLCBpdGVtQ29udHJvbCwgcG9ydGFsIH0gPSBwb3J0YWxJdGVtO1xuICAgIGNvbnN0IGlzUG9ydGFsID0gcG9ydGFsLmlzUG9ydGFsO1xuICAgIGNvbnN0IGlzSG9zdGVkID0gKHR5cGVLZXl3b3JkcyA9PT0gbnVsbCB8fCB0eXBlS2V5d29yZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR5cGVLZXl3b3Jkcy5pbmRleE9mKFwiSG9zdGVkIFNlcnZpY2VcIikpID4gLTE7XG4gICAgY29uc3QgaXNPbmxpbmVMb2NhdGlvblRyYWNraW5nU2VydmljZSA9ICFpc1BvcnRhbCAmJiAodHlwZUtleXdvcmRzID09PSBudWxsIHx8IHR5cGVLZXl3b3JkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHlwZUtleXdvcmRzLmluZGV4T2YoXCJMb2NhdGlvbiBUcmFja2luZyBTZXJ2aWNlXCIpKSA+IC0xO1xuICAgIGlmICghaXNIb3N0ZWQgfHwgaXNPbmxpbmVMb2NhdGlvblRyYWNraW5nU2VydmljZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwb3J0YWwudXNlciAmJiBpdGVtQ29udHJvbCAmJiBbXCJhZG1pblwiLCBcInVwZGF0ZVwiXS5pbmRleE9mKGl0ZW1Db250cm9sKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IGkxOG5PcHMgPSBzdHJpbmdzLm9wZXJhdG9ycztcbiAgICAgICAgY29uc3QgaW52YWxpZE9wZXJhdG9ycyA9IFtcbiAgICAgICAgICAgIGkxOG5PcHMuc3RyaW5nT3BlcmF0b3JFbmRzV2l0aCxcbiAgICAgICAgICAgIGkxOG5PcHMuc3RyaW5nT3BlcmF0b3JDb250YWlucyxcbiAgICAgICAgICAgIGkxOG5PcHMuc3RyaW5nT3BlcmF0b3JEb2VzTm90Q29udGFpblxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gW107XG4gICAgICAgIGNvbnN0IGFkZEZpZWxkVG9MaXN0ID0gKGNvbmRpdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gY29uZGl0aW9uLmZpZWxkTmFtZTtcbiAgICAgICAgICAgIGlmICghZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkRmllbGQgPSAhKCgoZmlsdGVyRmllbGQgPT09IG51bGwgfHwgZmlsdGVyRmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkgPT09IHNpbXBsZUZpZWxkVHlwZXMuU1RSSU5HIHx8XG4gICAgICAgICAgICAgICAgKGZpbHRlckZpZWxkID09PSBudWxsIHx8IGZpbHRlckZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUpID09PSBzaW1wbGVGaWVsZFR5cGVzLkdVSUQpICYmXG4gICAgICAgICAgICAgICAgKGZpbHRlckZpZWxkLmxheWVyRmllbGQubGVuZ3RoID4gNDAwMCB8fCBpbnZhbGlkT3BlcmF0b3JzLmluZGV4T2YoY29uZGl0aW9uLm9wZXJhdG9yKSA+IC0xKSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEZpZWxkICYmIGZpZWxkTmFtZXMuaW5kZXhPZihmaWVsZE5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGZpZWxkTmFtZXMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBleHByZXNzaW9ucyA9PT0gbnVsbCB8fCBleHByZXNzaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhwcmVzc2lvbnMuZm9yRWFjaCgoZXhwcmVzc2lvbikgPT4gZXhwcmVzc2lvbi5jb25kaXRpb25zLmZvckVhY2goKGNvbmRpdGlvbikgPT4gYWRkRmllbGRUb0xpc3QoY29uZGl0aW9uKSkpO1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgaW5kZXhlczogW11cbiAgICAgICAgfTtcbiAgICAgICAgc291cmNlSlNPTi5pbmRleGVzID0gc291cmNlSlNPTi5pbmRleGVzIHx8IFtdO1xuICAgICAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2VKU09OLmluZGV4ZXMuc29tZSgoaW5kZXgpID0+IGluZGV4LmZpZWxkcyA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIGluZGV4IGRvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICAgICAgICAgICAganNvbi5pbmRleGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHtmaWVsZE5hbWV9X0luZGV4YCxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlzVW5pcXVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNBc2NlbmRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtmaWVsZE5hbWV9X0luZGV4YFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGpzb24uaW5kZXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGV4ZWN1dGVDcmVhdGVJbmRleGVzKGpzb24sIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVDcmVhdGVJbmRleGVzKGpzb24sIHByb3BzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGxheWVyLCBwYXJlbnRTZXJ2aWNlVXJsIH0gPSBwcm9wcztcbiAgICBpZiAobGF5ZXIudHlwZSAhPT0gXCJmZWF0dXJlXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHBvcnRhbEl0ZW0sIHNvdXJjZUpTT04gfSA9IGxheWVyO1xuICAgIGNvbnN0IHsgdHlwZUtleXdvcmRzLCBwb3J0YWwgfSA9IHBvcnRhbEl0ZW07XG4gICAgY29uc3QgaXNWaWV3ID0gdHlwZUtleXdvcmRzLmluY2x1ZGVzKFwiVmlldyBTZXJ2aWNlXCIpO1xuICAgIGNvbnN0IFtJZGVudGl0eU1hbmFnZXIsIGVzcmlSZXF1ZXN0XSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvaWRlbnRpdHkvSWRlbnRpdHlNYW5hZ2VyXCIsIFwiZXNyaS9yZXF1ZXN0XCJdKTtcbiAgICBpZiAoaXNWaWV3ICYmICFwYXJlbnRTZXJ2aWNlVXJsKSB7XG4gICAgICAgIC8vIG5lZWQgdG8gdXNlIHRoZSBvcmlnaW5hbCBzZXJ2aWNlIHVybFxuICAgICAgICB2YXIgcmVsYXRlZFVybCA9IGAke3BvcnRhbC5yZXN0VXJsfS9jb250ZW50L2l0ZW1zLyR7cG9ydGFsSXRlbS5pZH0vcmVsYXRlZEl0ZW1zP3JlbGF0aW9uc2hpcFR5cGU9U2VydmljZTJTZXJ2aWNlJmRpcmVjdGlvbj1yZXZlcnNlYDtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IElkZW50aXR5TWFuYWdlci5nZXRDcmVkZW50aWFsKHBvcnRhbC5yZXN0VXJsLCB7IHByb21wdDogZmFsc2UgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVzcmlSZXF1ZXN0KHJlbGF0ZWRVcmwsIHsgcXVlcnk6IHsgZjogXCJqc29uXCIsIHRva2VuOiBjcmVkZW50aWFsLnRva2VuIH0gfSk7XG4gICAgICAgIGlmICgoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvdGFsKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YS5yZWxhdGVkSXRlbXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnR5cGVLZXl3b3Jkcy5pbmNsdWRlcyhcIkhvc3RlZCBTZXJ2aWNlXCIpKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvcHMucGFyZW50U2VydmljZVVybCA9IGl0ZW0udXJsO1xuICAgICAgICAgICAgICAgIGV4ZWN1dGVDcmVhdGVJbmRleGVzKGpzb24sIHByb3BzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWRtaW5VcmwgPSAocGFyZW50U2VydmljZVVybCB8fCBsYXllci51cmwpLnJlcGxhY2UoXCIvcmVzdC9zZXJ2aWNlc1wiLCBcIi9yZXN0L2FkbWluL3NlcnZpY2VzXCIpO1xuICAgIGNvbnN0IHVybCA9IGAke2FkbWluVXJsfS8ke2xheWVyLmxheWVySWR9L2FkZFRvRGVmaW5pdGlvbmA7XG4gICAgY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IElkZW50aXR5TWFuYWdlci5nZXRDcmVkZW50aWFsKGxheWVyLnVybCwgeyBwcm9tcHQ6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgICAgIGY6IFwianNvblwiLFxuICAgICAgICBhZGRUb0RlZmluaXRpb246IEpTT04uc3RyaW5naWZ5KGpzb24pLFxuICAgICAgICBhc3luYzogIXBvcnRhbC5pc1BvcnRhbCxcbiAgICAgICAgdG9rZW46IGNyZWRlbnRpYWwudG9rZW5cbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVzcmlSZXF1ZXN0KHVybCwge1xuICAgICAgICBxdWVyeTogY29udGVudCxcbiAgICAgICAgbWV0aG9kOiBcInBvc3RcIlxuICAgIH0pO1xuICAgIGlmIChwb3J0YWwuaXNQb3J0YWwpIHtcbiAgICAgICAgc291cmNlSlNPTi5pbmRleGVzID0gc291cmNlSlNPTi5pbmRleGVzIHx8IFtdO1xuICAgICAgICBzb3VyY2VKU09OLmluZGV4ZXMgPSBzb3VyY2VKU09OLmluZGV4ZXMuY29uY2F0KGpzb24uaW5kZXhlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcG9sbEZvclN0YXR1cygoX2IgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXR1c1VSTCwge1xuICAgICAgICAgICAgICAgIGY6IFwianNvblwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBjcmVkZW50aWFsLnRva2VuXG4gICAgICAgICAgICB9LCBlc3JpUmVxdWVzdCk7XG4gICAgICAgICAgICBzb3VyY2VKU09OLmluZGV4ZXMgPSBzb3VyY2VKU09OLmluZGV4ZXMgfHwgW107XG4gICAgICAgICAgICBzb3VyY2VKU09OLmluZGV4ZXMgPSBzb3VyY2VKU09OLmluZGV4ZXMuY29uY2F0KGpzb24uaW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhIGJpZyBwcm9ibGVtIGlmIGl0IGRpZG4ndCB3b3JrXG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBwb2xsRm9yU3RhdHVzID0gYXN5bmMgKHVybCwgcGFyYW1zLCBlc3JpUmVxdWVzdCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb2xsRm9yU3RhdHVzOiBubyBzdGF0dXMgVVJMXCIpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nU3RhdHVzZXMgPSBbXCJwcm9jZXNzaW5nXCIsIFwicGFydGlhbFwiLCBcIlBlbmRpbmdcIiwgXCJJblByb2dyZXNzXCJdO1xuICAgIGNvbnN0IHN1Y2Nlc3NTdGF0dXNlcyA9IFtcImNvbXBsZXRlZFwiLCBcIkNvbXBsZXRlZFwiXTtcbiAgICAvLyBLZWVwIHBvbGxpbmcgc3RhdHVzIHVudGlsIGVpdGhlciBjb21wbGV0ZWQgb3IgZmFpbGVkXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRG8gZmFpbHVyZXMgcmVwb3J0IGFzIHN1Y2Nlc3MgKHN0YXR1cyAyMDApPyBNYXkgbmVlZCB0byBtYW51YWxseSB0aHJvdyBlcnJvciBvbiBzdGF0dXMgY2hlY2sgZmFpbHVyZVxuICAgICAgICBjb25zdCBzdGF0dXNSZXNwb25zZSA9IGF3YWl0IGVzcmlSZXF1ZXN0KHVybCwgeyBxdWVyeTogcGFyYW1zIH0pO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSAoX2EgPSBzdGF0dXNSZXNwb25zZSA9PT0gbnVsbCB8fCBzdGF0dXNSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdHVzUmVzcG9uc2UuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1cztcbiAgICAgICAgaWYgKHBlbmRpbmdTdGF0dXNlcy5pbmNsdWRlcyhzdGF0dXMpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aW1lb3V0KDUwMCk7XG4gICAgICAgICAgICByZXR1cm4gcG9sbEZvclN0YXR1cyh1cmwsIHBhcmFtcywgZXNyaVJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN1Y2Nlc3NTdGF0dXNlcy5pbmNsdWRlcyhzdGF0dXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBzdGF0dXNSZXNwb25zZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGJ1aWxkT3BlcmF0b3JzTGlzdChwcm9wcykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIGZlYXR1cmVSZWR1Y3Rpb24sIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGNvbnN0IGlzU3RyZWFtTGF5ZXIgPSBsYXllci5kZWNsYXJlZENsYXNzID09PSBcImVzcmkubGF5ZXJzLlN0cmVhbUxheWVyXCI7XG4gICAgY29uc3QgaXNJbWFnZXJ5TGF5ZXIgPSBsYXllci5kZWNsYXJlZENsYXNzID09PSBcImVzcmkubGF5ZXJzLkltYWdlcnlMYXllclwiO1xuICAgIGlmICghcHJvcHMub3BlcmF0b3JzKSB7XG4gICAgICAgIHByb3BzLm9wZXJhdG9ycyA9IHt9O1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5TVFJJTkddID0gW107XG4gICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLlNUUklOR10ucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5TVFJJTkddLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpc1N0cmVhbUxheWVyICYmICFpc0ltYWdlcnlMYXllcikge1xuICAgICAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckluY2x1ZGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLlNUUklOR10ucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JFeGNsdWRlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yU3RhcnRzV2l0aFxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yRW5kc1dpdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLlNUUklOR10ucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckNvbnRhaW5zXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5TVFJJTkddLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JEb2VzTm90Q29udGFpblxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNCbGFua1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RCbGFua1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNFbXB0eVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RFbXB0eVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV0gPSBbXTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV0ucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc09uXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90T25cbiAgICAgICAgfSk7XG4gICAgICAgIC8qIGlmICghaXNTdHJlYW1MYXllcikge1xuICAgICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJbmNsdWRlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JFeGNsdWRlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9ICovXG4gICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCZWZvcmVcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNBZnRlclxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb3BzLmlzSG9zdGVkIHx8IHByb3BzLnN1cHBvcnRlZFNxbFBhcnNlclZlcnNpb24pIHtcbiAgICAgICAgICAgIC8vIHx8IGxheWVyLnZlcnNpb24gPj0gMTAuMjEpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGtub3cgaWYgQ1VSUkVOVF9USU1FU1RBTVAgaXMgaW4gVVRDIGZvciBvdGhlciBkYXRhYmFzZXMuXG4gICAgICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJblRoZUxhc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9yTm90SW5UaGVMYXN0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmV0d2VlblxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV0ucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJldHdlZW5cbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCbGFua1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV0ucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJsYW5rXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldID0gW107XG4gICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0ucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc09uXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RPblxuICAgICAgICB9KTtcbiAgICAgICAgLyogaWYgKCFpc1N0cmVhbUxheWVyKSB7XG4gICAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvckluY2x1ZGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvckV4Y2x1ZGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gKi9cbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmVmb3JlXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNBZnRlclxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmV0d2VlblxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90QmV0d2VlblxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmxhbmtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0ucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJsYW5rXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJdID0gW107XG4gICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUl0ucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJdLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmZWF0dXJlUmVkdWN0aW9uICYmICFpc1N0cmVhbUxheWVyICYmICFpc0ltYWdlcnlMYXllcikge1xuICAgICAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckluY2x1ZGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUl0ucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JFeGNsdWRlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNBdExlYXN0XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJdLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0xlc3NUaGFuXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJdLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TW9zdFxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNHcmVhdGVyVGhhblxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNCZXR3ZWVuXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJdLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdEJldHdlZW5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZmVhdHVyZVJlZHVjdGlvbikge1xuICAgICAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQmxhbmtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTm90QmxhbmtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRPTUFJTl0gPSBbXTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRPTUFJTl0ucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzTm90XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzU3RyZWFtTGF5ZXIgJiYgIWlzSW1hZ2VyeUxheWVyICYmICFpc0ltYWdlcnlMYXllcikge1xuICAgICAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckluY2x1ZGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRPTUFJTl0ucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JFeGNsdWRlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNCbGFua1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RCbGFua1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNFbXB0eVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RFbXB0eVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0T3BlcmF0b3IocHJvcHMsIGZlYXR1cmVGaWx0ZXJGaWVsZCkge1xuICAgIGNvbnN0IHsgc3RyaW5ncywgZGVmYXVsdE9wZXJhdG9yIH0gPSBwcm9wcztcbiAgICBpZiAoZmVhdHVyZUZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gXCJjbHVzdGVyX2NvdW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNHcmVhdGVyVGhhbjtcbiAgICB9XG4gICAgc3dpdGNoIChmZWF0dXJlRmlsdGVyRmllbGQubGF5ZXJGaWVsZC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICBjYXNlIFwiZGF0ZS1vbmx5XCI6XG4gICAgICAgICAgICBpZiAoaGFzRmllbGREb21haW5zKGZlYXR1cmVGaWx0ZXJGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZmF1bHRPcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGVmYXVsdE9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzT247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmVmb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwib2lkXCI6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJcztcbiAgICAgICAgY2FzZSBcImd1aWRcIjpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzO1xuICAgICAgICBjYXNlIFwic21hbGwtaW50ZWdlclwiOlxuICAgICAgICBjYXNlIFwiYmlnLWludGVnZXJcIjpcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgY2FzZSBcInNpbmdsZVwiOlxuICAgICAgICAgICAgaWYgKGhhc0ZpZWxkRG9tYWlucyhmZWF0dXJlRmlsdGVyRmllbGQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWZhdWx0T3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRlZmF1bHRPcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNHcmVhdGVyVGhhbjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TGVhc3Q7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0xlc3NUaGFuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRNb3N0O1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgY2FzZSBcImxvbmdcIjpcbiAgICAgICAgICAgIGlmIChoYXNGaWVsZERvbWFpbnMoZmVhdHVyZUZpbHRlckZpZWxkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmYXVsdE9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkZWZhdWx0T3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzR3JlYXRlclRoYW47XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNBdExlYXN0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNMZXNzVGhhbjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TW9zdDtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRMZWFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQmV0d2Vlbk9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikge1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgaWYgKG9wZXJhdG9yICYmXG4gICAgICAgIFtcbiAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNCZXR3ZWVuLFxuICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdEJldHdlZW4sXG4gICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JldHdlZW4sXG4gICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJldHdlZW5cbiAgICAgICAgXS5pbmRleE9mKG9wZXJhdG9yKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0JsYW5rT3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSB7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBpZiAob3BlcmF0b3IgJiZcbiAgICAgICAgW1xuICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc0JsYW5rLFxuICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdEJsYW5rLFxuICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JsYW5rLFxuICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdEJsYW5rLFxuICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCbGFuayxcbiAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90QmxhbmtcbiAgICAgICAgXS5pbmRleE9mKG9wZXJhdG9yKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0VtcHR5T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSB7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBpZiAob3BlcmF0b3IgJiZcbiAgICAgICAgW3N0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNFbXB0eSwgc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdEVtcHR5XS5pbmRleE9mKG9wZXJhdG9yKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0xpc3RPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpIHtcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGlmIChvcGVyYXRvciAmJlxuICAgICAgICBbXG4gICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckluY2x1ZGVzLFxuICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JFeGNsdWRlcyxcbiAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySW5jbHVkZXMsXG4gICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckV4Y2x1ZGVzXG4gICAgICAgIF0uaW5kZXhPZihvcGVyYXRvcikgPiAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJbmNsdWRlc09wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikge1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgaWYgKG9wZXJhdG9yICYmXG4gICAgICAgIFtzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckluY2x1ZGVzLCBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckluY2x1ZGVzXS5pbmRleE9mKG9wZXJhdG9yKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0V4Y2x1ZGVzT3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSB7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBpZiAob3BlcmF0b3IgJiZcbiAgICAgICAgW3N0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yRXhjbHVkZXMsIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9yRXhjbHVkZXNdLmluZGV4T2Yob3BlcmF0b3IpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSW5UaGVMYXN0T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSB7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBpZiAob3BlcmF0b3IgJiZcbiAgICAgICAgW3N0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvckluVGhlTGFzdCwgc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9yTm90SW5UaGVMYXN0XS5pbmRleE9mKG9wZXJhdG9yKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRJbmNsdWRlc09wZXJhdG9yKHByb3BzLCBmaWx0ZXJGaWVsZCkge1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgc3dpdGNoIChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiZG9tYWluXCI6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJbmNsdWRlcztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwib2lkXCI6XG4gICAgICAgIGNhc2UgXCJndWlkXCI6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJbmNsdWRlcztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckluY2x1ZGVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEV4Y2x1ZGVzT3BlcmF0b3IocHJvcHMsIGZpbHRlckZpZWxkKSB7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBzd2l0Y2ggKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JFeGNsdWRlcztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwib2lkXCI6XG4gICAgICAgIGNhc2UgXCJndWlkXCI6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JFeGNsdWRlcztcbiAgICAgICAgLy9jYXNlIFwiZGF0ZVwiOlxuICAgICAgICAvL2Nhc2UgXCJkYXRlLW9ubHlcIjpcbiAgICAgICAgLy8gIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JFeGNsdWRlcztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckV4Y2x1ZGVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE9wZXJhdG9yJDEocHJvcHMsIG9sZEZpbHRlckZpZWxkLCBuZXdGaWx0ZXJGaWVsZCwgb2xkT3BlcmF0b3IpIHtcbiAgICBpZiAob2xkRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlICE9PSBuZXdGaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUpIHtcbiAgICAgICAgaWYgKGlzSW5jbHVkZXNPcGVyYXRvcihwcm9wcywgb2xkT3BlcmF0b3IpICYmIG5ld0ZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSAhPT0gc2ltcGxlRmllbGRUeXBlcy5EQVRFKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0SW5jbHVkZXNPcGVyYXRvcihwcm9wcywgbmV3RmlsdGVyRmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXhjbHVkZXNPcGVyYXRvcihwcm9wcywgb2xkT3BlcmF0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXhjbHVkZXNPcGVyYXRvcihwcm9wcywgbmV3RmlsdGVyRmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldERlZmF1bHRPcGVyYXRvcihwcm9wcywgbmV3RmlsdGVyRmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvbGRPcGVyYXRvcjtcbn1cblxuLy9pbXBvcnQgKiBhcyBudW1iZXIgZnJvbSBcImRvam8vbnVtYmVyXCI7XG4vL2ltcG9ydCAqIGFzIGxvY2FsZSBmcm9tIFwiZG9qby9kYXRlL2xvY2FsZVwiO1xuY29uc3QgZGF5SW5NUyA9IDI0ICogNjAgKiA2MCAqIDEwMDAgLSAxMDAwO1xuZnVuY3Rpb24gY3JlYXRlV2hlcmVDbGF1c2UocHJvcHMpIHtcbiAgICBsZXQgd2hlcmVDbGF1c2UgPSBcIlwiO1xuICAgIGlmICghcHJvcHMuZXhwcmVzc2lvbnMgfHwgIXByb3BzLmV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IGpvaW4gPSBcIlwiO1xuICAgIGxldCBzdWNjZXNzZnVsRXhwcmVzc2lvbnMgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMuZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZXhwciA9IHByb3BzLmV4cHJlc3Npb25zW2ldO1xuICAgICAgICBjb25zdCBzdHIgPSBjcmVhdGVFeHByZXNzaW9uV2hlcmVDbGF1c2UoZXhwciwgcHJvcHMpO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NmdWxFeHByZXNzaW9ucyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3VjY2Vzc2Z1bEV4cHJlc3Npb25zID09PSAxKSB7XG4gICAgICAgICAgICAgICAgam9pbiA9IGAgJHtwcm9wcy5sb2dpY2FsT3BlcmF0b3JGb3JFeHByZXNzaW9ucyA9PT0gbG9naWNhbE9wZXJhdG9ycy5PUiA/IFwiT1JcIiA6IFwiQU5EXCJ9IGA7XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgKCR7d2hlcmVDbGF1c2V9KSR7am9pbn0oJHtzdHJ9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSArPSBgJHtqb2lufSgke3N0cn0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxFeHByZXNzaW9ucysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3aGVyZUNsYXVzZS5sZW5ndGggPyB3aGVyZUNsYXVzZSA6IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVFeHByZXNzaW9uV2hlcmVDbGF1c2UoZXhwcmVzc2lvbiwgcHJvcHMpIHtcbiAgICBsZXQgZXhwcldoZXJlQ2xhdXNlID0gXCJcIjtcbiAgICBpZiAoZXhwcmVzc2lvbi5jb25kaXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBleHByV2hlcmVDbGF1c2UgPSBjcmVhdGVDb25kaXRpb25XaGVyZUNsYXVzZShleHByZXNzaW9uLmNvbmRpdGlvbnNbMF0sIHByb3BzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBqb2luID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByZXNzaW9uLmNvbmRpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmQgPSBleHByZXNzaW9uLmNvbmRpdGlvbnNbaV07XG4gICAgICAgICAgICBjb25zdCBjb25kV2hlcmVDbGF1c2UgPSBjcmVhdGVDb25kaXRpb25XaGVyZUNsYXVzZShjb25kLCBwcm9wcyk7XG4gICAgICAgICAgICBpZiAoY29uZFdoZXJlQ2xhdXNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGV4cHJXaGVyZUNsYXVzZSArPSBqb2luICsgY29uZFdoZXJlQ2xhdXNlO1xuICAgICAgICAgICAgICAgIGpvaW4gPSBgICR7ZXhwcmVzc2lvbi5sb2dpY2FsT3BlcmF0b3JGb3JDb25kaXRpb25zID09PSBsb2dpY2FsT3BlcmF0b3JzLk9SID8gXCJPUlwiIDogXCJBTkRcIn0gYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwcldoZXJlQ2xhdXNlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29uZGl0aW9uV2hlcmVDbGF1c2UoY29uZGl0aW9uLCBwcm9wcykge1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgY29uc3QgZmllbGROYW1lID0gY29uZGl0aW9uLmZpZWxkTmFtZTtcbiAgICBjb25zdCBvcGVyYXRvciA9IGNvbmRpdGlvbi5vcGVyYXRvcjtcbiAgICBsZXQgdmFsdWUgPSBjb25kaXRpb24udmFsdWU7XG4gICAgbGV0IHZhbHVlMiA9IGNvbmRpdGlvbi52YWx1ZTI7XG4gICAgbGV0IHZhbHVlcyA9IGNvbmRpdGlvbi52YWx1ZXMgfHwgW107XG4gICAgY29uc3QgdW5pdCA9IGNvbmRpdGlvbi51bml0O1xuICAgIGNvbnN0IGZpZWxkT2JqZWN0ID0gZ2V0RmllbGRJbmZvKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgIGlmICghZmllbGRPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGlmIChpc0JldHdlZW5PcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpICYmICFpc0RlZmluZWQodmFsdWUyKSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNMaXN0T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSAmJiAhdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNJblRoZUxhc3RPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpICYmICFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNEZWZpbmVkKHZhbHVlKSAmJlxuICAgICAgICAhdmFsdWVzLmxlbmd0aCAmJlxuICAgICAgICAhaXNCbGFua09wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikgJiZcbiAgICAgICAgIWlzRW1wdHlPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKiBpZiAoaXNMaXN0T3BlcmF0b3Iob3BlcmF0b3IpICYmIGZpZWxkT2JqZWN0LnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5EQVRFKSB7XG4gICAgICAvLyBtYXggb25lIHZhbHVlOyB3ZSBjYW4ndCBzdXBwb3J0IElOXG4gICAgICB2YWx1ZSA9IHZhbHVlcz8uWzBdO1xuICAgIH0gKi9cbiAgICBsZXQgd2hlcmVDbGF1c2UgPSBcIlwiO1xuICAgIGlmIChmaWVsZE9iamVjdC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuU1RSSU5HIHx8XG4gICAgICAgIGZpZWxkT2JqZWN0LnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5HVUlEKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBcIlwiO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSAmJiBwcm9wcy5pc0hvc3RlZCkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zTm9uTGF0aW5DaGFyYWN0ZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gXCJOXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZS5nLiBjb2RlZCB2YWx1ZSBkb21haW5zXG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gaXNOdW1iZXJUeXBlKGZpZWxkT2JqZWN0KTtcbiAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgvXFwnL2csIFwiJydcIik7XG4gICAgICAgIHN3aXRjaCAoY29uZGl0aW9uLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXM6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwU3RyID0gYCR7cHJlZml4fScke3N0cn0nYDtcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gPSAke2lzTnVtYmVyID8gdmFsdWUgOiBwU3RyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3Q6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwU3RyID0gYCR7cHJlZml4fScke3N0cn0nYDtcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gPD4gJHtpc051bWJlciA/IHZhbHVlIDogcFN0cn1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvclN0YXJ0c1dpdGg6XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IExJS0UgJHtwcmVmaXh9JyR7c3RyfSUnYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JFbmRzV2l0aDpcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gTElLRSAke3ByZWZpeH0nJSR7c3RyfSdgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckNvbnRhaW5zOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBMSUtFICR7cHJlZml4fSclJHtzdHJ9JSdgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckRvZXNOb3RDb250YWluOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBOT1QgTElLRSAke3ByZWZpeH0nJSR7c3RyfSUnYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJbmNsdWRlczoge1xuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBJTiAoJHt2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgodmFsdWUpID0+IGlzTnVtYmVyXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtjb250YWluc05vbkxhdGluQ2hhcmFjdGVyKHZhbHVlKSA/IFwiTlwiIDogXCJcIn0nJHt2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKC9cXCcvZywgXCInJ1wiKX0nYClcbiAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKCl9KWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yRXhjbHVkZXM6IHtcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gTk9UIElOICgke3ZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4gaXNOdW1iZXJcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGAke2NvbnRhaW5zTm9uTGF0aW5DaGFyYWN0ZXIodmFsdWUpID8gXCJOXCIgOiBcIlwifScke3ZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoL1xcJy9nLCBcIicnXCIpfSdgKVxuICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKX0pYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc0JsYW5rOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBJUyBOVUxMYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdEJsYW5rOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBJUyBOT1QgTlVMTGA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNFbXB0eTpcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gPSAnJ2A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RFbXB0eTpcbiAgICAgICAgICAgICAgICAvL3doZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA8PiAnJyBPUiAke2ZpZWxkTmFtZX0gSVMgTlVMTGA7XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IDw+ICcnYDsgLy8gbm90IHJldHVybmluZyBOVUxMIHZhbHVlc1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpZWxkT2JqZWN0LnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5OVU1CRVIgfHxcbiAgICAgICAgZmllbGRPYmplY3Quc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLk9JRCkge1xuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM6XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9ID0gJHt2YWx1ZX1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTm90OlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA8PiAke3ZhbHVlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNBdExlYXN0OlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA+PSAke3ZhbHVlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNMZXNzVGhhbjpcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gPCAke3ZhbHVlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNBdE1vc3Q6XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IDw9ICR7dmFsdWV9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0dyZWF0ZXJUaGFuOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA+ICR7dmFsdWV9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JldHdlZW46XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IEJFVFdFRU4gJHt2YWx1ZX0gQU5EICR7dmFsdWUyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3RCZXR3ZWVuOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBOT1QgQkVUV0VFTiAke3ZhbHVlfSBBTkQgJHt2YWx1ZTJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJbmNsdWRlczpcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gSU4gKCR7dmFsdWVzLnRvU3RyaW5nKCl9KWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9yRXhjbHVkZXM6XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IE5PVCBJTiAoJHt2YWx1ZXMudG9TdHJpbmcoKX0pYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JsYW5rOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBJUyBOVUxMYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdEJsYW5rOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBJUyBOT1QgTlVMTGA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZmllbGRPYmplY3Quc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWSkge1xuICAgICAgICAvLyBkYXRlXG4gICAgICAgIC8vIE5PVEU6IGNsaWVudCBzaWRlIGZpbHRlciBlZmZlY3Qgb25seSBzdXBwb3J0cyBzcWw5MiBhbmQgbmVlZHMgdGhlIGRhdGUgaW4gdGhlIHF1ZXJ5XG4gICAgICAgIC8vIHRoZXJmb3JlIHdlIGRpc2FibGUgZGF0YSBmaWVsZHMgZm9yIHNlcnZpY2VzIHdpdGhvdXQgc3RhbmRhcmRpemVkUXVlcnkgc3VwcG9ydFxuICAgICAgICBjb25zdCBkYXRlc3RtcCA9ICFwcm9wcy5zdXBwb3J0c1N0YW5kYXJkaXplZFF1ZXJ5ID8gXCJcIiA6IFwiREFURSBcIjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7ZGF0ZS5nZXRGdWxsWWVhcigpfS0ke2RhdGUuZ2V0TW9udGgoKSA8IDkgPyBcIjBcIiA6IFwiXCJ9JHtkYXRlLmdldE1vbnRoKCkgKyAxfS0ke2RhdGUuZ2V0RGF0ZSgpIDwgMTAgPyBcIjBcIiA6IFwiXCJ9JHtkYXRlLmdldERhdGUoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZmluZWQodmFsdWUyKSAmJiB0eXBlb2YgdmFsdWUyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUyKTtcbiAgICAgICAgICAgIHZhbHVlMiA9IGAke2RhdGUuZ2V0RnVsbFllYXIoKX0tJHtkYXRlLmdldE1vbnRoKCkgPCA5ID8gXCIwXCIgOiBcIlwifSR7ZGF0ZS5nZXRNb250aCgpICsgMX0tJHtkYXRlLmdldERhdGUoKSA8IDEwID8gXCIwXCIgOiBcIlwifSR7ZGF0ZS5nZXREYXRlKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzT246XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySW5jbHVkZXM6XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9ID0gJHtkYXRlc3RtcH0nJHt2YWx1ZX0nYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RPbjpcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JFeGNsdWRlczpcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gPD4gJHtkYXRlc3RtcH0nJHt2YWx1ZX0nYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCZWZvcmU6XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IDwgJHtkYXRlc3RtcH0nJHt2YWx1ZX0nYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNBZnRlcjpcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gPiAke2RhdGVzdG1wfScke3ZhbHVlfSdgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JldHdlZW46XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IEJFVFdFRU4gJHtkYXRlc3RtcH0nJHt2YWx1ZX0nIEFORCAke2RhdGVzdG1wfScke3ZhbHVlMn0nYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RCZXR3ZWVuOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBOT1QgQkVUV0VFTiAke2RhdGVzdG1wfScke3ZhbHVlfScgQU5EICR7ZGF0ZXN0bXB9JyR7dmFsdWUyfSdgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckluY2x1ZGVzOlxuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckV4Y2x1ZGVzOlxuICAgICAgICAgICAgICBsZXQgZGF0ZVZhbHVlc1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICAgIGxldCBjb21tYSA9IFwiXCI7XG4gICAgICAgICAgICAgIGRhdGVWYWx1ZXMuZm9yRWFjaCgoZGF0ZVZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBkYXRlVmFsdWVzU3RyaW5nICs9IGAke2NvbW1hfSR7ZGF0ZXN0bXB9JyR7ZGF0ZVZhbHVlfSdgO1xuICAgICAgICAgICAgICAgIGNvbW1hID0gXCIsXCI7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgPT09IHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySW5jbHVkZXMpIHtcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gSU4gKCR7ZGF0ZVZhbHVlc1N0cmluZ30pYDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gTk9UIElOICgke2RhdGVWYWx1ZXNTdHJpbmd9KWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7ICovXG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmxhbms6XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IElTIE5VTExgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJsYW5rOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBJUyBOT1QgTlVMTGA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGRhdGVcbiAgICAgICAgLy8gTk9URTogY2xpZW50IHNpZGUgZmlsdGVyIGVmZmVjdCBvbmx5IHN1cHBvcnRzIHNxbDkyIGFuZCBuZWVkcyB0aGUgdGltZXN0YW1wIGluIHRoZSBxdWVyeVxuICAgICAgICAvLyB0aGVyZm9yZSB3ZSBkaXNhYmxlIGRhdGEgZmllbGRzIGZvciBzZXJ2aWNlcyB3aXRob3V0IHN0YW5kYXJkaXplZFF1ZXJ5IHN1cHBvcnRcbiAgICAgICAgbGV0IGRhdGVWYWx1ZSA9IGdldERhdGVPYmplY3QodmFsdWUpO1xuICAgICAgICBsZXQgZGF0ZVZhbHVlMiA9IGdldERhdGVPYmplY3QodmFsdWUyKTtcbiAgICAgICAgLyogY29uc3QgZGF0ZVZhbHVlcyA9XG4gICAgICAgICAgdmFsdWVzICYmXG4gICAgICAgICAgdmFsdWVzLm1hcCgodmFsdWU6IHN0cmluZyB8IG51bWJlciB8IERhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXREYXRlKGdldERhdGVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgICB9KTsgKi9cbiAgICAgICAgY29uc3QgdG1zdG1wID0gIXByb3BzLnN1cHBvcnRzU3RhbmRhcmRpemVkUXVlcnkgPyBcIlwiIDogXCJ0aW1lc3RhbXAgXCI7XG4gICAgICAgIGNvbnN0IGRhdGVTdHIgPSBmb3JtYXREYXRlKGRhdGVWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGRhdGVQbHVzT25lU3RyID0gZm9ybWF0RGF0ZShhZGREYXkoZGF0ZVZhbHVlKSk7XG4gICAgICAgIGNvbnN0IGRhdGUyUGx1c09uZVN0ciA9IGZvcm1hdERhdGUoYWRkRGF5KGRhdGVWYWx1ZTIpKTtcbiAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc09uOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBCRVRXRUVOICR7dG1zdG1wfScke2RhdGVTdHJ9JyBBTkQgJHt0bXN0bXB9JyR7ZGF0ZVBsdXNPbmVTdHJ9J2A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90T246XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IE5PVCBCRVRXRUVOICR7dG1zdG1wfScke2RhdGVTdHJ9JyBBTkQgJHt0bXN0bXB9JyR7ZGF0ZVBsdXNPbmVTdHJ9J2A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmVmb3JlOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA8ICR7dG1zdG1wfScke2RhdGVTdHJ9J2A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQWZ0ZXI6XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9ID4gJHt0bXN0bXB9JyR7ZGF0ZVBsdXNPbmVTdHJ9J2A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvckluVGhlTGFzdDpcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gQkVUV0VFTiAke2NyZWF0ZUluVGhlTGFzdFF1ZXJ5UGFydChwcm9wcywgdmFsdWUsIHVuaXQpfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvck5vdEluVGhlTGFzdDpcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gTk9UIEJFVFdFRU4gJHtjcmVhdGVJblRoZUxhc3RRdWVyeVBhcnQocHJvcHMsIHZhbHVlLCB1bml0KX1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JldHdlZW46XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IEJFVFdFRU4gJHt0bXN0bXB9JyR7ZGF0ZVN0cn0nIEFORCAke3Rtc3RtcH0nJHtkYXRlMlBsdXNPbmVTdHJ9J2A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90QmV0d2VlbjpcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gTk9UIEJFVFdFRU4gJHt0bXN0bXB9JyR7ZGF0ZVN0cn0nIEFORCAke3Rtc3RtcH0nJHtkYXRlMlBsdXNPbmVTdHJ9J2A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvckluY2x1ZGVzOlxuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JFeGNsdWRlczpcbiAgICAgICAgICAgICAgbGV0IGRhdGVWYWx1ZXNTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICBsZXQgY29tbWEgPSBcIlwiO1xuICAgICAgICAgICAgICBkYXRlVmFsdWVzLmZvckVhY2goKGRhdGVWYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgZGF0ZVZhbHVlc1N0cmluZyArPSBgJHtjb21tYX0ke3Rtc3RtcH0nJHtkYXRlVmFsdWV9J2A7XG4gICAgICAgICAgICAgICAgY29tbWEgPSBcIixcIjtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySW5jbHVkZXMpIHtcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gSU4gKCR7ZGF0ZVZhbHVlc1N0cmluZ30pYDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gTk9UIElOICgke2RhdGVWYWx1ZXNTdHJpbmd9KWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7ICovXG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmxhbms6XG4gICAgICAgICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IElTIE5VTExgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJsYW5rOlxuICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBJUyBOT1QgTlVMTGA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdoZXJlQ2xhdXNlO1xufVxuZnVuY3Rpb24gZ2V0RGF0ZU9iamVjdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLy8gdmFsdWUgaXMgYSBVVEMgdGltZXN0YW1wOyByZXR1cm5zIGEgZGF0ZSBvYmplY3QgaW4gbG9jYWwgdGltZVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gZnJvbSBkYXRlIHBpY2tlci4uLlxuICAgICAgICAvLyBlLmcuIFwiNy83LzIwMTAgMTI6MDA6MDAgQU1cIiByZXR1cm5lZCBieSBnZW5lcmF0ZVJlbmRlcmVyXG4gICAgICAgIC8vIGluIERFIHZhbHVlIGlzIFwiMDIuMDMuMTJcIiBmb3IgTWFyY2ggc2Vjb25kOyBuZXcgRGF0ZSh2YWx1ZSkgdGhlbiByZXR1cm5zIEZlYiAzcmRcbiAgICAgICAgLy8gICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gcGFyc2VGcmllbmRseURhdGUodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAvLyBEYXRlIG9iamVjdDsgaW4gbG9jYWwgdGltZVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gICAgLy8gc2VydmljZSBuZWVkcyBVVEMgdGltZSwgYnV0IHRoZSB1c2VyIGxvb2tzIGF0IGxvY2FsIHRpbWUgaW4gdGhlIFVJXG4gICAgLy8gZGF0ZSBpcyBpbiBsb2NhbCB0aW1lXG4gICAgLy8gcmV0dXJucyB0aGUgc3RyaW5nIGluIFVUQyB0aW1lXG4gICAgLy8gZS5nLiAyMDE3LTA3LTA3IDA5OjA1OjE5XG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCB5ZWFyU3RyID0gYCR7ZGF0ZS5nZXRVVENGdWxsWWVhcigpfWA7XG4gICAgbGV0IG1vbnRoU3RyID0gYCR7ZGF0ZS5nZXRVVENNb250aCgpICsgMX1gO1xuICAgIGlmIChtb250aFN0ci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbW9udGhTdHIgPSBgMCR7bW9udGhTdHJ9YDtcbiAgICB9XG4gICAgbGV0IGRhdGVTdHIgPSBgJHtkYXRlLmdldFVUQ0RhdGUoKX1gO1xuICAgIGlmIChkYXRlU3RyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBkYXRlU3RyID0gYDAke2RhdGVTdHJ9YDtcbiAgICB9XG4gICAgbGV0IGhvdXJzU3RyID0gYCR7ZGF0ZS5nZXRVVENIb3VycygpfWA7XG4gICAgaWYgKGhvdXJzU3RyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBob3Vyc1N0ciA9IGAwJHtob3Vyc1N0cn1gO1xuICAgIH1cbiAgICBsZXQgbWluU3RyID0gYCR7ZGF0ZS5nZXRVVENNaW51dGVzKCl9YDtcbiAgICBpZiAobWluU3RyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBtaW5TdHIgPSBgMCR7bWluU3RyfWA7XG4gICAgfVxuICAgIGxldCBzZWNTdHIgPSBgJHtkYXRlLmdldFNlY29uZHMoKX1gO1xuICAgIGlmIChzZWNTdHIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHNlY1N0ciA9IGAwJHtzZWNTdHJ9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3llYXJTdHJ9LSR7bW9udGhTdHJ9LSR7ZGF0ZVN0cn0gJHtob3Vyc1N0cn06JHttaW5TdHJ9OiR7c2VjU3RyfWA7XG59XG5mdW5jdGlvbiBjcmVhdGVJblRoZUxhc3RRdWVyeVBhcnQocHJvcHMsIHZhbHVlLCB1bml0KSB7XG4gICAgaWYgKHByb3BzLnN1cHBvcnRlZFNxbFBhcnNlclZlcnNpb24pIHtcbiAgICAgICAgbGV0IGRheXMgPSAwO1xuICAgICAgICBpZiAodW5pdCA9PT0gXCJ5ZWFyXCIpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhY2N1cmF0ZSAuLi5cbiAgICAgICAgICAgIGRheXMgPSB2YWx1ZSAqIDM2NTtcbiAgICAgICAgICAgIHJldHVybiBgQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCAnJHtkYXlzfScgREFZIEFORCBDVVJSRU5UX1RJTUVTVEFNUGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pdCA9PT0gXCJtb250aFwiKSB7XG4gICAgICAgICAgICAvLyBub3QgYWNjdXJhdGUgLi4uXG4gICAgICAgICAgICBkYXlzID0gdmFsdWUgKiAzMDtcbiAgICAgICAgICAgIHJldHVybiBgQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCAnJHtkYXlzfScgREFZIEFORCBDVVJSRU5UX1RJTUVTVEFNUGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pdCA9PT0gXCJ3ZWVrXCIpIHtcbiAgICAgICAgICAgIGRheXMgPSB2YWx1ZSAqIDc7XG4gICAgICAgICAgICByZXR1cm4gYENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgJyR7ZGF5c30nIERBWSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaXQgPT09IFwiZGF5XCIpIHtcbiAgICAgICAgICAgIGRheXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBgQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCAnJHtkYXlzfScgREFZIEFORCBDVVJSRU5UX1RJTUVTVEFNUGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pdCA9PT0gXCJob3VyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCAnJHt2YWx1ZX0nIEhPVVIgQU5EIENVUlJFTlRfVElNRVNUQU1QYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIHJldHVybiBgQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCAnJHt2YWx1ZX0nIE1JTlVURSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgZGF5cyA9IDA7XG4gICAgICAgIGlmICh1bml0ID09PSBcInllYXJcIikge1xuICAgICAgICAgICAgLy8gbm90IGFjY3VyYXRlIC4uLlxuICAgICAgICAgICAgZGF5cyA9IHZhbHVlICogMzY1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaXQgPT09IFwibW9udGhcIikge1xuICAgICAgICAgICAgLy8gbm90IGFjY3VyYXRlIC4uLlxuICAgICAgICAgICAgZGF5cyA9IHZhbHVlICogMzA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pdCA9PT0gXCJ3ZWVrXCIpIHtcbiAgICAgICAgICAgIGRheXMgPSB2YWx1ZSAqIDc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pdCA9PT0gXCJkYXlcIikge1xuICAgICAgICAgICAgZGF5cyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaXQgPT09IFwiaG91clwiKSB7XG4gICAgICAgICAgICBkYXlzID0gdmFsdWUgLyAyNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1pbnV0ZVxuICAgICAgICAgICAgZGF5cyA9IHZhbHVlIC8gKDI0ICogNjApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgQ1VSUkVOVF9USU1FU1RBTVAgLSAke2RheXN9IEFORCBDVVJSRU5UX1RJTUVTVEFNUGA7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VGcmllbmRseURhdGUodmFsdWUpIHtcbiAgICAvLyBlbjogMy8yLzE1IGRlOiAwMi4wMy4xNSAtIGZvciBtYXJjaCBzZWNvbmRcbiAgICAvKiByZXR1cm4gbG9jYWxlLnBhcnNlKHZhbHVlLCB7XG4gICAgICBmb3JtYXRMZW5ndGg6IFwic2hvcnRcIixcbiAgICAgIHNlbGVjdG9yOiBcImRhdGVcIlxuICAgIH0pOyAqL1xuICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwYXJzZURhdGUoc3RyVmFsdWUpIHtcbiAgICAvLyBzdHJWYWx1ZSBpcyBpbiBVVEMgdGltZSwgYnV0IHRoZSB1c2VyIGxvb2tzIGF0IGxvY2FsIHRpbWUgaW4gdGhlIFVJXG4gICAgLy8gd2Uga25vdyBzdHJWYWx1ZSBsb29rcyBsaWtlIHRoaXMgJ3l5eXktTU0tZGQgSEg6bW06c3MnIChlLmcuICcyMDEzLTAzLTAxIDAwOjAwOjAwJylcbiAgICAvKlxuICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKE51bWJlcihzdHJWYWx1ZS5zdWJzdHJpbmcoMCwgNCkpKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKHBhcnNlSW50KHN0clZhbHVlLnN1YnN0cmluZyg1LCA3KSkgLSAxKTtcbiAgICBkYXRlLnNldFVUQ0RhdGUoTnVtYmVyKHN0clZhbHVlLnN1YnN0cmluZyg4LCAxMCkpKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKE51bWJlcihzdHJWYWx1ZS5zdWJzdHJpbmcoMTEsIDEzKSkpO1xuICAgIGRhdGUuc2V0VVRDTWludXRlcyhOdW1iZXIoc3RyVmFsdWUuc3Vic3RyaW5nKDE0LCAxNikpKTtcbiAgICBkYXRlLnNldFNlY29uZHMoTnVtYmVyKHN0clZhbHVlLnN1YnN0cmluZygxNywgMTkpKSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gICAgKi9cbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHN0clZhbHVlKTtcbiAgICBsZXQgdXRjRGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpIC0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApO1xuICAgIC8vY29uc29sZS5sb2coXCJwYXJzZURhdGVcIiwgc3RyVmFsdWUsIFwiIC0gXCIsIHV0Y0RhdGUpO1xuICAgIHJldHVybiB1dGNEYXRlO1xufVxuZnVuY3Rpb24gYWRkRGF5KGRhdGUpIHtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgKyBkYXlJbk1TKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJ0cmFjdERheShkYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpIC0gZGF5SW5NUyk7XG59XG5mdW5jdGlvbiBjb250YWluc05vbkxhdGluQ2hhcmFjdGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlLmNoYXJDb2RlQXQoaSkgPiAyNTUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy9pbXBvcnQgKiBhcyBXaGVyZUNsYXVzZSBmcm9tIFwiZXNyaS9jb3JlL3NxbC9XaGVyZUNsYXVzZVwiO1xuLy9jb25zdCBkYXlJbk1TOiBudW1iZXIgPSAyNCAqIDYwICogNjAgKiAxMDAwIC0gMTAwMDsgLy8gMSBzZWMgbGVzcyB0aGFuIDEgZGF5XG5hc3luYyBmdW5jdGlvbiBwYXJzZVdoZXJlQ2xhdXNlKHdoZXJlQ2xhdXNlLCBwcm9wcykge1xuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHByb3BzO1xuICAgIC8vIGRvZXMgbm90IGNhbGwgcmVqZWN0KClcbiAgICBpZiAoIXdoZXJlQ2xhdXNlIHx8ICF3aGVyZUNsYXVzZS5sZW5ndGgpIHtcbiAgICAgICAgLyogY29uc3QgZGVmYXVsdEZpZWxkID0gZ2V0RGVmYXVsdEZpZWxkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuZXhwcmVzc2lvbnMgPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uZGl0aW9uczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmllbGROYW1lOiBkZWZhdWx0RmllbGQubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBnZXREZWZhdWx0T3BlcmF0b3IoZGVmYXVsdEZpZWxkKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgICBzdGF0ZS5leHByZXNzaW9ucyA9IGZpeFVJRHMoc3RhdGUuZXhwcmVzc2lvbnMpOyAqL1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IFtlc3JpU1FMXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvY29yZS9zcWxcIl0pO1xuICAgICAgICAvLyBJbWFnZXJ5TGF5ZXIgaGFzIGZpZWxkc0luZGV4IHRvbywgaXQncyBub3QgZG9jdW1lbnRlZCB5ZXQuIENhc3RpbmcgYXMgYW55IGZvciBub3cuXG4gICAgICAgIHJldHVybiBlc3JpU1FMLnBhcnNlV2hlcmVDbGF1c2Uod2hlcmVDbGF1c2UsIGxheWVyLmZpZWxkc0luZGV4KS50aGVuKChjbGF1c2UgLyogV2hlcmVDbGF1c2UgKi8pID0+IHtcbiAgICAgICAgICAgIGlmICghY2xhdXNlLmlzU3RhbmRhcmRpemVkKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlcyBzb21lIG5vbiBzdGFuZGFyZCBmdW5jdGlvbnMuIGludmFsaWRcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5leHByZXNzaW9ucyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnM6IFtdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBwYXJzZUNsYXVzZShjbGF1c2UucGFyc2VUcmVlLCBwcm9wcyk7XG4gICAgICAgICAgICBwcm9wcy5leHByZXNzaW9ucyA9IGZpeFVJRHMocHJvcHMuZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgXCJTUUxQYXJzZXI6XCIsXG4gICAgICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgICAgICB3aGVyZUNsYXVzZSxcbiAgICAgICAgICAgICAgICBjbGF1c2UsXG4gICAgICAgICAgICAgICAgcHJvcHMubG9naWNhbE9wZXJhdG9yRm9yRXhwcmVzc2lvbnMsXG4gICAgICAgICAgICAgICAgcHJvcHMuZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU1FMUGFyc2VyIC0gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VDbGF1c2UocGFyc2VUcmVlLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNDb25kaXRpb24ocGFyc2VUcmVlKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VCaW5hcnlFeHByKHBhcnNlVHJlZSwgcHJvcHMuZXhwcmVzc2lvbnNbMF0uY29uZGl0aW9ucywgcHJvcHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvcHMubG9naWNhbE9wZXJhdG9yRm9yRXhwcmVzc2lvbnMgPSBnZXRMb2dpY2FsT3BlcmF0b3IocGFyc2VUcmVlKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlQmluYXJ5RXhwcihwYXJzZVRyZWUsIHByb3BzLmV4cHJlc3Npb25zWzBdLCBwcm9wcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VCaW5hcnlFeHByKG9iaiwgc3RhdGVPYmosIHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgLy8gbGVmdCwgb3BlcmF0b3IsIHJpZ2h0LCB0eXBlXG4gICAgaWYgKGlzQ29uZGl0aW9uKG9iaikpIHtcbiAgICAgICAgLy8gc3RhdGVPYmogaXMgbGlzdCBvZiBjb25kaXRpb25zXG4gICAgICAgIGlmIChvYmoubGVmdC50eXBlID09PSBcImNvbHVtbi1yZWZlcmVuY2VcIikge1xuICAgICAgICAgICAgY29uc3QgZmllbGRPYmplY3QgPSBnZXRGaWVsZEluZm8ob2JqLmxlZnQuY29sdW1uLCBwcm9wcyk7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IGZpZWxkT2JqZWN0ID8gZ2V0T3BlcmF0b3IocHJvcHMsIG9iai5vcGVyYXRvciwgZmllbGRPYmplY3QsIG9iai5yaWdodCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZmllbGRPYmplY3QgJiYgb3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChvYmoucmlnaHQudHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSVMgTlVMTCAvIElTIE5PVCBOVUxMXG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGRPYmplY3QubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iai5yaWdodC50eXBlID09PSBcImNvbHVtbi1yZWZlcmVuY2VcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBubyBsb25nZXIgc3VwcG9ydCBmaWVsZCB0byBmaWVsZCBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIC0+IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqLnJpZ2h0LnR5cGUgPT09IFwiZXhwcmVzc2lvbi1saXN0XCIgJiYgaXNMaXN0T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJTiwgTk9UIElOXG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGRPYmplY3QubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IG9iai5yaWdodC52YWx1ZS5tYXAoKHZhbCkgPT4gdmFsLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmoucmlnaHQudHlwZSA9PT0gXCJleHByZXNzaW9uLWxpc3RcIiAmJiBpc0luVGhlTGFzdE9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlcmVDbGF1c2UgPSBcIjxmaWVsZE5hbWU+IEJFVFdFRU4gQ1VSUkVOVF9USU1FU1RBTVAgLSA8ZGF5cz4gQU5EIENVUlJFTlRfVElNRVNUQU1QXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBCRVRXRUVOIENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgPGRheXM+IERBWSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBcIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlcmVDbGF1c2UgPSBcIjxmaWVsZE5hbWU+IEJFVFdFRU4gQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCA8aG91cnM+IEhPVVIgQU5EIENVUlJFTlRfVElNRVNUQU1QXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBCRVRXRUVOIENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgPG1pbnV0ZXM+IE1JTlVURSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBcIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VJblRoZUxhc3Qob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkT2JqZWN0LmxheWVyRmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXQ6IHJlc3VsdC51bml0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iai5yaWdodC50eXBlID09PSBcImV4cHJlc3Npb24tbGlzdFwiICYmIGlzQmV0d2Vlbk9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQkVUV0VFTiwgTk9UIEJFVFdFRU5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGF0ZVR5cGUoZmllbGRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZTogXCIyMDAwLTA5LTE0IDA2OjI2OjM2XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUxID0gcGFyc2VEYXRlKG9iai5yaWdodC52YWx1ZVswXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlMiA9IHBhcnNlRGF0ZShvYmoucmlnaHQudmFsdWVbMV0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZTJTdWIgPSBzdWJ0cmFjdERheShkYXRlMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGF0ZTJTdWIuZ2V0VGltZSgpIC0gZGF0ZTEuZ2V0VGltZSgpKSA8IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoaW4gMSBkYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGRPYmplY3QubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IgPT09IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc09uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90T24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRlMS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkT2JqZWN0LmxheWVyRmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRlMS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMjogZGF0ZTIuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RhdGVPbmx5VHlwZShmaWVsZE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlOiBcIjIwMDAtMDktMTRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZTEgPSBwYXJzZURhdGUob2JqLnJpZ2h0LnZhbHVlWzBdLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUyID0gcGFyc2VEYXRlKG9iai5yaWdodC52YWx1ZVsxXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBkYXRlMS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE9iamVjdC5sYXllckZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhcnNlciBhbHJlYWR5IHN1YnN0cmFjdHMgdGhlIG9mZnNldCB0byBsb2NhbCB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGUxLmdldFRpbWUoKSArIDIgKiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiBkYXRlMi5nZXRUaW1lKCkgKyAyICogb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGRPYmplY3QubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvYmoucmlnaHQudmFsdWVbMF0udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiBvYmoucmlnaHQudmFsdWVbMV0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqLnJpZ2h0LnR5cGUgPT09IFwidGltZXN0YW1wXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE9iamVjdC5sYXllckZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZURhdGUob2JqLnJpZ2h0LnZhbHVlKS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqLnJpZ2h0LnR5cGUgPT09IFwiZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZE9iamVjdC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGRhdGUgc3RyaW5nIHRvIFVOSVggdGltZXN0YW1wICh3aXRob3V0IHRpbWVzdGFtcCBvZmZzZXQgc2hpZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gcGFyc2VEYXRlKG9iai5yaWdodC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkT2JqZWN0LmxheWVyRmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGFyc2VyIGFscmVhZHkgc3Vic3RyYWN0cyB0aGUgb2Zmc2V0IHRvIGxvY2FsIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGF0ZS5nZXRUaW1lKCkgKyAyICogb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGRPYmplY3QubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZURhdGUob2JqLnJpZ2h0LnZhbHVlKS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGU6IFwic3RyaW5nXCIgfCBcIm51bWJlclwiIHwuLi5cbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE9iamVjdC5sYXllckZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvYmoucmlnaHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGVPYmoucHVzaChjb25kaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZmllbGQgb3Igb3BlcmF0b3Igbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgLy8gLT4gZXJyb3JcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc3RhdGVPYmogaXMgZXhwcmVzc2lvblxuICAgICAgICBwcm9wcy5leHByZXNzaW9ucyA9IHByb3BzLmV4cHJlc3Npb25zIHx8IFtdO1xuICAgICAgICBsZXQgc3VjY2VzcztcbiAgICAgICAgaWYgKGlzQ29uZGl0aW9uKG9iai5sZWZ0KSAmJiBpc0NvbmRpdGlvbihvYmoucmlnaHQpKSB7XG4gICAgICAgICAgICBzdGF0ZU9iai5sb2dpY2FsT3BlcmF0b3JGb3JDb25kaXRpb25zID0gZ2V0TG9naWNhbE9wZXJhdG9yKG9iaik7XG4gICAgICAgICAgICBzdWNjZXNzID0gcGFyc2VCaW5hcnlFeHByKG9iai5sZWZ0LCBzdGF0ZU9iai5jb25kaXRpb25zLCBwcm9wcyk7XG4gICAgICAgICAgICBzdWNjZXNzID0gc3VjY2VzcyAmJiBwYXJzZUJpbmFyeUV4cHIob2JqLnJpZ2h0LCBzdGF0ZU9iai5jb25kaXRpb25zLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb25kaXRpb24ob2JqLmxlZnQpKSB7XG4gICAgICAgICAgICBpZiAob2JqLm9wZXJhdG9yID09PSBvYmoucmlnaHQub3BlcmF0b3IgJiYgaXNDb25kaXRpb24ob2JqLnJpZ2h0LmxlZnQpICYmIGlzQ29uZGl0aW9uKG9iai5yaWdodC5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBzdGF0ZU9iai5sb2dpY2FsT3BlcmF0b3JGb3JDb25kaXRpb25zID0gZ2V0TG9naWNhbE9wZXJhdG9yKG9iaik7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHBhcnNlQmluYXJ5RXhwcihvYmoubGVmdCwgc3RhdGVPYmouY29uZGl0aW9ucywgcHJvcHMpO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzICYmIHBhcnNlQmluYXJ5RXhwcihvYmoucmlnaHQsIHN0YXRlT2JqLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhIG5ldyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHBhcnNlQmluYXJ5RXhwcihvYmoubGVmdCwgc3RhdGVPYmouY29uZGl0aW9ucywgcHJvcHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwcm9wcy5leHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzICYmIHBhcnNlQmluYXJ5RXhwcihvYmoucmlnaHQsIGV4cHJlc3Npb24sIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NvbmRpdGlvbihvYmoucmlnaHQpKSB7XG4gICAgICAgICAgICBpZiAob2JqLm9wZXJhdG9yID09PSBvYmoubGVmdC5vcGVyYXRvciAmJlxuICAgICAgICAgICAgICAgIGlzQ29uZGl0aW9uKG9iai5sZWZ0LnJpZ2h0KSAmJlxuICAgICAgICAgICAgICAgIChpc0NvbmRpdGlvbihvYmoubGVmdC5sZWZ0KSB8fCBvYmoubGVmdC5vcGVyYXRvciA9PT0gKChfYSA9IG9iai5sZWZ0LmxlZnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVyYXRvcikpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2FtZSBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgc3RhdGVPYmoubG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucyA9IGdldExvZ2ljYWxPcGVyYXRvcihvYmopO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBwYXJzZUJpbmFyeUV4cHIob2JqLmxlZnQsIHN0YXRlT2JqLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHN1Y2Nlc3MgJiYgcGFyc2VCaW5hcnlFeHByKG9iai5yaWdodCwgc3RhdGVPYmouY29uZGl0aW9ucywgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYSBuZXcgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBwYXJzZUJpbmFyeUV4cHIob2JqLmxlZnQsIHN0YXRlT2JqLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHByb3BzLmV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHN1Y2Nlc3MgJiYgcGFyc2VCaW5hcnlFeHByKG9iai5yaWdodCwgZXhwcmVzc2lvbi5jb25kaXRpb25zLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyAnbGVhZidcbiAgICAgICAgICAgIGlmIChvYmoub3BlcmF0b3IgPT09IG9iai5yaWdodC5vcGVyYXRvciAmJiBvYmoub3BlcmF0b3IgPT09IG9iai5sZWZ0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gc2FtZSBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgc3RhdGVPYmoubG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucyA9IGdldExvZ2ljYWxPcGVyYXRvcihvYmopO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBwYXJzZUJpbmFyeUV4cHIob2JqLmxlZnQsIHN0YXRlT2JqLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHN1Y2Nlc3MgJiYgcGFyc2VCaW5hcnlFeHByKG9iai5yaWdodCwgc3RhdGVPYmosIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG5ldyBleHByZXNzaW9uczsgZmlyc3Qgb25lIGlzIHN0aWxsIGVtcHR5Li4uXG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHBhcnNlQmluYXJ5RXhwcihvYmoubGVmdCwgc3RhdGVPYmosIHByb3BzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25zOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcHJvcHMuZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gc3VjY2VzcyAmJiBwYXJzZUJpbmFyeUV4cHIob2JqLnJpZ2h0LCBleHByZXNzaW9uLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDb25kaXRpb24ob2JqKSB7XG4gICAgaWYgKG9iai50eXBlID09PSBcImJpbmFyeS1leHByZXNzaW9uXCIgJiYgKG9iai5vcGVyYXRvciA9PT0gXCJPUlwiIHx8IG9iai5vcGVyYXRvciA9PT0gXCJBTkRcIikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldExvZ2ljYWxPcGVyYXRvcihvYmopIHtcbiAgICByZXR1cm4gb2JqLm9wZXJhdG9yLnRvVXBwZXJDYXNlKCkgPT09IFwiT1JcIiA/IGxvZ2ljYWxPcGVyYXRvcnMuT1IgOiBsb2dpY2FsT3BlcmF0b3JzLkFORDtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdG9yKHByb3BzLCBvcGVyYXRvciwgZmllbGRPYmplY3QsIG9ialJpZ2h0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgaWYgKCFmaWVsZE9iamVjdCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgaWYgKGZpZWxkT2JqZWN0LnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkcpIHtcbiAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICBpZiAob2JqUmlnaHQudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNFbXB0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCI8PlwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKG9ialJpZ2h0LnZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzTm90RW1wdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiTElLRVwiOlxuICAgICAgICAgICAgICAgIGlmIChvYmpSaWdodC52YWx1ZS5zdGFydHNXaXRoKFwiJVwiKSAmJiBvYmpSaWdodC52YWx1ZS5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqUmlnaHQudmFsdWUgPSBvYmpSaWdodC52YWx1ZS5zdWJzdHJpbmcoMSwgb2JqUmlnaHQudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckNvbnRhaW5zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmpSaWdodC52YWx1ZS5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqUmlnaHQudmFsdWUgPSBvYmpSaWdodC52YWx1ZS5zdWJzdHJpbmcoMCwgb2JqUmlnaHQudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvclN0YXJ0c1dpdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9ialJpZ2h0LnZhbHVlLnN0YXJ0c1dpdGgoXCIlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialJpZ2h0LnZhbHVlID0gb2JqUmlnaHQudmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JFbmRzV2l0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJOT1QgTElLRVwiOlxuICAgICAgICAgICAgICAgIGlmIChvYmpSaWdodC52YWx1ZS5zdGFydHNXaXRoKFwiJVwiKSAmJiBvYmpSaWdodC52YWx1ZS5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqUmlnaHQudmFsdWUgPSBvYmpSaWdodC52YWx1ZS5zdWJzdHJpbmcoMSwgb2JqUmlnaHQudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9ialJpZ2h0LnZhbHVlLmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpSaWdodC52YWx1ZSA9IG9ialJpZ2h0LnZhbHVlLnN1YnN0cmluZygwLCBvYmpSaWdodC52YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqUmlnaHQudmFsdWUuc3RhcnRzV2l0aChcIiVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqUmlnaHQudmFsdWUgPSBvYmpSaWdodC52YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckRvZXNOb3RDb250YWluO1xuICAgICAgICAgICAgY2FzZSBcIklTXCI6XG4gICAgICAgICAgICAgICAgaWYgKG9ialJpZ2h0LnR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzQmxhbms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgICAgICAgICAgY2FzZSBcIklTTk9UXCI6XG4gICAgICAgICAgICBjYXNlIFwiSVMgTk9UXCI6XG4gICAgICAgICAgICAgICAgaWYgKG9ialJpZ2h0LnR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzTm90Qmxhbms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgICAgICAgICAgY2FzZSBcIklOXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySW5jbHVkZXM7XG4gICAgICAgICAgICBjYXNlIFwiTk9UIElOXCI6XG4gICAgICAgICAgICBjYXNlIFwiTk9USU5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JFeGNsdWRlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChmaWVsZE9iamVjdC5zaW1wbGVGaWVsZFR5cGUgPT09IFwibnVtYmVyXCIgfHwgZmllbGRPYmplY3Quc2ltcGxlRmllbGRUeXBlID09PSBcIm9pZFwiKSB7XG4gICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM7XG4gICAgICAgICAgICBjYXNlIFwiPD5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdDtcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRMZWFzdDtcbiAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNMZXNzVGhhbjtcbiAgICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRNb3N0O1xuICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0dyZWF0ZXJUaGFuO1xuICAgICAgICAgICAgY2FzZSBcIkJFVFdFRU5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JldHdlZW47XG4gICAgICAgICAgICBjYXNlIFwiTk9UIEJFVFdFRU5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJOT1RCRVRXRUVOXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3RCZXR3ZWVuO1xuICAgICAgICAgICAgY2FzZSBcIklTXCI6XG4gICAgICAgICAgICAgICAgaWYgKG9ialJpZ2h0LnR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQmxhbms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzO1xuICAgICAgICAgICAgY2FzZSBcIklTTk9UXCI6XG4gICAgICAgICAgICBjYXNlIFwiSVMgTk9UXCI6XG4gICAgICAgICAgICAgICAgaWYgKG9ialJpZ2h0LnR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTm90Qmxhbms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzO1xuICAgICAgICAgICAgY2FzZSBcIklOXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySW5jbHVkZXM7XG4gICAgICAgICAgICBjYXNlIFwiTk9UIElOXCI6XG4gICAgICAgICAgICBjYXNlIFwiTk9USU5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JFeGNsdWRlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZGF0ZVxuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjcmVhdGUgdGhpcyB3aGVyZSBjbGF1c2VcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNPbjtcbiAgICAgICAgICAgIGNhc2UgXCI8PlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdE9uO1xuICAgICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCZWZvcmU7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0FmdGVyO1xuICAgICAgICAgICAgY2FzZSBcIkJFVFdFRU5cIjpcbiAgICAgICAgICAgICAgICBpZiAoKChfYiA9IChfYSA9IG9ialJpZ2h0LnZhbHVlWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVmdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID09PSBcImN1cnJlbnQtdGltZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBCRVRXRUVOIENVUlJFTlRfVElNRVNUQU1QIC0gPGRheXM+IEFORCBDVVJSRU5UX1RJTUVTVEFNUFwiO1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZUNsYXVzZSA9IFwiPGZpZWxkTmFtZT4gQkVUV0VFTiBDVVJSRU5UX1RJTUVTVEFNUCAtIElOVEVSVkFMIDxkYXlzPiBEQVkgQU5EIENVUlJFTlRfVElNRVNUQU1QXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBCRVRXRUVOIENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgPGhvdXJzPiBIT1VSIEFORCBDVVJSRU5UX1RJTUVTVEFNUFwiO1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZUNsYXVzZSA9IFwiPGZpZWxkTmFtZT4gQkVUV0VFTiBDVVJSRU5UX1RJTUVTVEFNUCAtIElOVEVSVkFMIDxtaW51dGVzPiBNSU5VVEUgQU5EIENVUlJFTlRfVElNRVNUQU1QXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJblRoZUxhc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCZXR3ZWVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJOT1QgQkVUV0VFTlwiOlxuICAgICAgICAgICAgY2FzZSBcIk5PVEJFVFdFRU5cIjpcbiAgICAgICAgICAgICAgICBpZiAoKChfZCA9IChfYyA9IG9ialJpZ2h0LnZhbHVlWzBdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVmdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnR5cGUpID09PSBcImN1cnJlbnQtdGltZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBOT1QgQkVUV0VFTiBDVVJSRU5UX1RJTUVTVEFNUCAtIDxkYXlzPiBBTkQgQ1VSUkVOVF9USU1FU1RBTVBcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvck5vdEluVGhlTGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJldHdlZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIklTXCI6XG4gICAgICAgICAgICAgICAgaWYgKG9ialJpZ2h0LnR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JsYW5rO1xuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICBjYXNlIFwiSVNOT1RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJJUyBOT1RcIjpcbiAgICAgICAgICAgICAgICBpZiAob2JqUmlnaHQudHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90Qmxhbms7XG4gICAgICAgICAgICAgICAgfSAvLyBlbHNlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5UaGVMYXN0KG9iaikge1xuICAgIGNvbnN0IHJpZ2h0ID0gb2JqLnJpZ2h0LnZhbHVlWzBdLnJpZ2h0O1xuICAgIGxldCBjb3VudCA9IHJpZ2h0LnZhbHVlO1xuICAgIGlmIChyaWdodC50eXBlID09PSBcImludGVydmFsXCIpIHtcbiAgICAgICAgLy93aGVyZUNsYXVzZSA9IFwiPGZpZWxkTmFtZT4gQkVUV0VFTiBDVVJSRU5UX1RJTUVTVEFNUCAtIElOVEVSVkFMIDxkYXlzPiBEQVkgQU5EIENVUlJFTlRfVElNRVNUQU1QXCI7XG4gICAgICAgIC8vd2hlcmVDbGF1c2UgPSBcIjxmaWVsZE5hbWU+IEJFVFdFRU4gQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCA8aG91cnM+IEhPVVIgQU5EIENVUlJFTlRfVElNRVNUQU1QXCI7XG4gICAgICAgIC8vd2hlcmVDbGF1c2UgPSBcIjxmaWVsZE5hbWU+IEJFVFdFRU4gQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCA8bWludXRlcz4gTUlOVVRFIEFORCBDVVJSRU5UX1RJTUVTVEFNUFwiO1xuICAgICAgICBjb3VudCA9IHJpZ2h0LnZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIgPyBwYXJzZUZsb2F0KHJpZ2h0LnZhbHVlLnZhbHVlKSA6IHJpZ2h0LnZhbHVlLnZhbHVlO1xuICAgICAgICBpZiAocmlnaHQucXVhbGlmaWVyLnBlcmlvZCA9PT0gXCJkYXlcIikge1xuICAgICAgICAgICAgaWYgKGNvdW50ICUgMzY1ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNvdW50IC8gMzY1LCB1bml0OiBcInllYXJcIiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgJSAzMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjb3VudCAvIDMwLCB1bml0OiBcIm1vbnRoXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjb3VudCAvIDcsIHVuaXQ6IFwid2Vla1wiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3VudCAlIDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogY291bnQsIHVuaXQ6IFwiZGF5XCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyaWdodC5xdWFsaWZpZXIucGVyaW9kID09PSBcImhvdXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNvdW50LCB1bml0OiBcImhvdXJcIiB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJpZ2h0LnF1YWxpZmllci5wZXJpb2QgPT09IFwibWludXRlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjb3VudCwgdW5pdDogXCJtaW51dGVcIiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc05hTihjb3VudCkpIHtcbiAgICAgICAgLy93aGVyZUNsYXVzZSA9IFwiPGZpZWxkTmFtZT4gQkVUV0VFTiBDVVJSRU5UX1RJTUVTVEFNUCAtIDxkYXlzPiBBTkQgQ1VSUkVOVF9USU1FU1RBTVBcIlxuICAgICAgICBpZiAoY291bnQgJSAzNjUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjb3VudCAvIDM2NSwgdW5pdDogXCJ5ZWFyXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3VudCAlIDMwID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogY291bnQgLyAzMCwgdW5pdDogXCJtb250aFwiIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY291bnQgJSA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogY291bnQgLyA3LCB1bml0OiBcIndlZWtcIiB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvdW50ICUgMSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNvdW50LCB1bml0OiBcImRheVwiIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtaW51dGVzID0gTWF0aC5yb3VuZChjb3VudCAqIDI0ICogNjApO1xuICAgICAgICAgICAgaWYgKG1pbnV0ZXMgJSA2MCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBNYXRoLnJvdW5kKGNvdW50ICogMjQpLCB1bml0OiBcImhvdXJcIiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG1pbnV0ZXMsIHVuaXQ6IFwibWludXRlXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5jb25zdCBhcmNnaXNGaWx0ZXJDc3MgPSBcIi5zYy1hcmNnaXMtZmlsdGVyLWh7ZGlzcGxheTpmbGV4O2ZsZXg6MSAxIGF1dG87b3ZlcmZsb3c6aGlkZGVufS5mYWItcGFkZGluZy5zYy1hcmNnaXMtZmlsdGVye3BhZGRpbmctYm90dG9tOjFyZW19Lmhvb2suc2MtYXJjZ2lzLWZpbHRlcnt3aWR0aDoxMDAlO2hlaWdodDoxcHh9LnJlbW92ZS1maWx0ZXIuc2MtYXJjZ2lzLWZpbHRlcnttYXJnaW4tYm90dG9tOjVweDtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO3BhZGRpbmctbGVmdDoxNXB4fS5tYXRjaC1leHByZXNzaW9uLWRyb3Bkb3duLnNjLWFyY2dpcy1maWx0ZXJ7d2lkdGg6MTAwJX0ubWF0Y2gtZXhwcmVzc2lvbi1tc2cuc2MtYXJjZ2lzLWZpbHRlcntwYWRkaW5nOjEycHg7YmFja2dyb3VuZC1jb2xvcjp3aGl0ZX0ubWF0Y2gtdHlwZS5zYy1hcmNnaXMtZmlsdGVye2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbjo2cHggMH0uYXJjZ2lzLS1ydGwuc2MtYXJjZ2lzLWZpbHRlciAucmVtb3ZlLWZpbHRlci5zYy1hcmNnaXMtZmlsdGVye3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MTVweH0ubm8tc3BhY2Uuc2MtYXJjZ2lzLWZpbHRlcnstLWNhbGNpdGUtbGFiZWwtbWFyZ2luLWJvdHRvbTowfVwiO1xuXG5jb25zdCBBcmNnaXNGaWx0ZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlcldoZXJlQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNGaWx0ZXJXaGVyZUNoYW5nZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJTYXZlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNGaWx0ZXJTYXZlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlckNhbmNlbCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRmlsdGVyQ2FuY2VsXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlckRpc21pc3NlZENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRmlsdGVyRGlzbWlzc2VkQ2hhbmdlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlckRvbmUgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlckRvbmVcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyUGFuZWxCYWNrQ2xpY2sgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlclBhbmVsQmFja0NsaWNrXCIsIDcpO1xuICAgICAgICB0aGlzLmNsb3NlRmlsdGVyUG9wb3ZlcnMgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNsb3NlRmlsdGVyUG9wb3ZlcnNcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyRXhwcmVzc2lvbkNoYW5nZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlckV4cHJlc3Npb25DaGFuZ2VkXCIsIDcpO1xuICAgICAgICB0aGlzLmxheWVyVmlld1dhaXRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXllckhhc0ZlYXR1cmVFZmZlY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9wZXJDbG9zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgbW9kZSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5ZXJWaWV3LCBsYXllciwgbGFiZWxDbGFzc0lkeCwgbGFiZWxDbGFzcywgb3JpZ2luYWxMYXllciB9ID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLmNsb3NlRmlsdGVyUG9wb3ZlcnMuZW1pdCgpO1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsYWJlbENsYXNzSWR4KSB8fCBpc0RlZmluZWQobGFiZWxDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBwYXNzZWQgdGhlIHdoZXJlIGNsYXVzZSB3aGVuIGl0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlclNhdmUuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gXCJsYXllci12aWV3XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aGVyZUNsYXVzZSA9IGNyZWF0ZVdoZXJlQ2xhdXNlKHByb3BzKTtcbiAgICAgICAgICAgICAgICAvLyBrZWVwIGVmZmVjdCBvbiBsYXllclZpZXcgdG8gYXZvaWQgZmxpY2tlcmluZ1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyU2F2ZS5lbWl0KHdoZXJlQ2xhdXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IFwiZWZmZWN0c1wiKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdoZXJlQ2xhdXNlID0gY3JlYXRlV2hlcmVDbGF1c2UocHJvcHMpO1xuICAgICAgICAgICAgICAgIChvcmlnaW5hbExheWVyIHx8IGxheWVyKS5kZWZpbml0aW9uRXhwcmVzc2lvbiA9IHdoZXJlQ2xhdXNlO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJkZWZpbml0aW9uRXhwcmVzc2lvbjpcIiwgd2hlcmVDbGF1c2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWxsb3dlZEZlYXR1cmVFZmZlY3QoKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllclZpZXcgJiYgXCJmaWx0ZXJcIiBpbiBsYXllclZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyVmlldy5maWx0ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNyZWF0ZUluZGV4ZXMocHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVyQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyU2F2ZS5lbWl0KCk7XG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoZWQgdG8gZGVmaW5pdGlvbkV4cHJlc3Npb24gZnJvbSBlZmZlY3QvbGF5ZXJWaWV3LmZpbHRlclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50U3RhdGVJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW5jZWxGaWx0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJldmVydEZpbHRlcigpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZUZpbHRlclBvcG92ZXJzLmVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVyQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJDYW5jZWwuZW1pdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsb3NlRmlsdGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gc2F2ZSBvbiBjbG9zZVxuICAgICAgICAgICAgdGhpcy5hcHBseUZpbHRlcigpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZUZpbHRlclBvcG92ZXJzLmVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVyQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJEaXNtaXNzZWRDaGFuZ2UuZW1pdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQWRkRXhwcmVzc2lvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGV4cHJlc3Npb25zIH0gPSBwcm9wcztcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRGaWVsZCA9IGdldERlZmF1bHRGaWVsZChwcm9wcyk7XG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRGaWVsZCkge1xuICAgICAgICAgICAgICAgIC8vIG5vdCByZWFkeSB5ZXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0T3BlcmF0b3IgPSBnZXREZWZhdWx0T3BlcmF0b3IocHJvcHMsIGRlZmF1bHRGaWVsZCk7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVzID0gZ2V0RGVmYXVsdFZhbHVlcyhwcm9wcywgZGVmYXVsdEZpZWxkLCBkZWZhdWx0T3BlcmF0b3IpO1xuICAgICAgICAgICAgY29uc3QgbmV3RXhwcmVzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGZpZWxkTmFtZTogZGVmYXVsdEZpZWxkLmxheWVyRmllbGQubmFtZSwgb3BlcmF0b3I6IGRlZmF1bHRPcGVyYXRvciB9LCBkZWZhdWx0VmFsdWVzKSwgeyBoYXNGb2N1czogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcm9wcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgPyBmaXhVSURzKFtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXhwcmVzc2lvbnMubWFwKChleHByZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHByZXNzaW9uKSwgeyBjb25kaXRpb25zOiBleHByZXNzaW9uLmNvbmRpdGlvbnMubWFwKChjb25kKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmQpLCB7IGhhc0ZvY3VzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG5ld0V4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIDogZml4VUlEcyhbbmV3RXhwcmVzc2lvbl0pO1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChkZWZhdWx0VmFsdWVzLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyRXhwcmVzc2lvbkNoYW5nZWQuZW1pdCh7IHR5cGU6IFwicmVwbGFjZVwiLCBleHByZXNzaW9uOiBuZXdFeHByZXNzaW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uTWF0Y2hTZWxlY3QgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBwcm9wcy5sb2dpY2FsT3BlcmF0b3JGb3JFeHByZXNzaW9ucyA9IHNlbGVjdC5zZWxlY3RlZE9wdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlGaWx0ZXJUb0xheWVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25SZW1vdmVGaWx0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICAgICAgcHJvcHMuaW52YWxpZEZpbHRlciA9IGZhbHNlO1xuICAgICAgICAgICAgcHJvcHMuZXhwcmVzc2lvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RmlsdGVyVG9MYXllcigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZvY3VzQnlDbGFzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHNldCBmb2N1cyBiYWNrIGZvciBrZXlib2FyZCB1c2Vyc1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuaG9zdEVsZW1lbnQucXVlcnlTZWxlY3RvcihcImFyY2dpcy1maWx0ZXIgLmF1dG9mb2N1c1wiKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUuc3RhcnRzV2l0aChcIkNBTENJVEUtXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmlldyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXllciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYWJlbENsYXNzSWR4ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxhYmVsQ2xhc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubW9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy52aWV3RmlsdGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZlYXR1cmVSZWR1Y3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGlkZUxheWVyVGl0bGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYW5lbEhlYWRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudGlwSGVhZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50aXBNc2cgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW52YWxpZEhlYWRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW52YWxpZE1zZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5uZXdCdXR0b25MYWJlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGVhclRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGVmYXVsdEZpZWxkTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kZWZhdWx0T3BlcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGVmYXVsdEV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlQnV0dG9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhbmVsTWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRpc21pc3NpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRTdGF0ZUludmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXJjZ2lzRmlsdGVyRXhwcmVzc2lvbkNoYW5nZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGV4cHJlc3Npb25zIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgeyBkZXRhaWwgfSA9IGV2ZW50O1xuICAgICAgICBpZiAoZGV0YWlsLnR5cGUgPT09IFwiY29weVwiKSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlICsgY29weSBleHByZXNzaW9uXG4gICAgICAgICAgICBjb25zdCBleHByID0gZXZlbnQuZGV0YWlsLmV4cHJlc3Npb247XG4gICAgICAgICAgICBwcm9wcy5leHByZXNzaW9ucyA9IHByb3BzLmV4cHJlc3Npb25zLm1hcCgoZXhwcmVzc2lvbikgPT4gKGV4cHJlc3Npb24udWlkID09PSBleHByLnVpZCA/IGV4cHIgOiBleHByZXNzaW9uKSAvL3sgLi4uZXhwcmVzc2lvbiB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IGNvcHlFeHByZXNzaW9uO1xuICAgICAgICAgICAgcHJvcHMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucy5tYXAoKGV4cHJlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHByZXNzaW9uKSwgeyBjb25kaXRpb25zOiBleHByZXNzaW9uLmNvbmRpdGlvbnMubWFwKChjb25kKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25kKSwgeyBoYXNGb2N1czogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9wcy5leHByZXNzaW9ucy5mb3JFYWNoKChleHByKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIudWlkID09PSBkZXRhaWwudWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlFeHByZXNzaW9uID0gdGhpcy5lc3JpTGFuZy5jbG9uZShPYmplY3QuYXNzaWduKHt9LCBleHByKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlFeHByZXNzaW9uLmNvbmRpdGlvbnNbMF0uaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvcHMuZXhwcmVzc2lvbnMgPSBmaXhVSURzKFsuLi5wcm9wcy5leHByZXNzaW9ucywgY29weUV4cHJlc3Npb25dKTtcbiAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXRhaWwudHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgLy8gZGVsZXRlIGV4cHJlc3Npb25cbiAgICAgICAgICAgIGxldCByZW1vdmVkSWR4ID0gMDtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLmZvckVhY2goKGV4cHJlc3Npb24sIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLnVpZCA9PT0gZGV0YWlsLnVpZCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkSWR4ID0gaWR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5jb25kaXRpb25zLmZvckVhY2goKGNvbmQpID0+IChjb25kLmhhc0ZvY3VzID0gZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3BzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMuZmlsdGVyKChleHByZXNzaW9uKSA9PiBleHByZXNzaW9uLnVpZCAhPT0gZGV0YWlsLnVpZCk7XG4gICAgICAgICAgICBpZiAoKF9hID0gcHJvcHMuZXhwcmVzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5leHByZXNzaW9uc1tNYXRoLm1heCgwLCByZW1vdmVkSWR4IC0gMSldLmNvbmRpdGlvbnNbMF0uaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BzLmV4cHJlc3Npb25zID0gZml4VUlEcyhbLi4ucHJvcHMuZXhwcmVzc2lvbnNdKTtcbiAgICAgICAgICAgICAgICAvLyB3YWl0IHVudGlsIHJlbmRlcmluZyBpcyBkb25lXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZvY3VzQnlDbGFzcygpLCA1MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCByZW5kZXJpbmcgaXMgZG9uZVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mYWJOb2RlLnNldEZvY3VzKCksIDUwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0eXBlPVwicmVwbGFjZVwiXG4gICAgICAgICAgICAvLyByZXBsYWNlIGV4cHJlc3Npb25cbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VFeHByID0gZXZlbnQuZGV0YWlsLmV4cHJlc3Npb247XG4gICAgICAgICAgICBwcm9wcy5leHByZXNzaW9ucyA9IHByb3BzLmV4cHJlc3Npb25zLm1hcCgoZXhwcmVzc2lvbikgPT4gZXhwcmVzc2lvbi51aWQgPT09IHJlcGxhY2VFeHByLnVpZCA/IE9iamVjdC5hc3NpZ24oe30sIHJlcGxhY2VFeHByKSA6IGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXJUb0xheWVyKCk7XG4gICAgfVxuICAgIGRpc2FibGVGaWx0ZXJQYW5lbEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wYW5lbE5vZGUuZGlzYWJsZWQgPSBldmVudC5kZXRhaWw7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBwdWJsaWMgY2FsbHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBzZXRGb2N1cygpIHtcbiAgICAgICAgdGhpcy5wYW5lbE5vZGUuc2V0Rm9jdXMoKTtcbiAgICB9XG4gICAgYXN5bmMgZG9uZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudFN0YXRlSW52YWxpZCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBvbiBkb25lXG4gICAgICAgICAgICB0aGlzLmFwcGx5RmlsdGVyKCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlRmlsdGVyUG9wb3ZlcnMuZW1pdCgpO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJDbG9zZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlckRvbmUuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlUG9wb3ZlcnMoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VGaWx0ZXJQb3BvdmVycy5lbWl0KCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgY29uc3QgW3N0cmluZ3MsIGN1cnJlbnRMYW5ndWFnZSwgY3VycmVudExhbmd1YWdlSW50bF0gPSBhd2FpdCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICAvLyBidWlsZCBGaWx0ZXJQcm9wc1xuICAgICAgICB0aGlzLnByb3BzID0ge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvZ2ljYWxPcGVyYXRvckZvckV4cHJlc3Npb25zOiBcImFuZFwiLFxuICAgICAgICAgICAgZmllbGRzOiBbXSxcbiAgICAgICAgICAgIG9wZXJhdG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW52YWxpZEZpbHRlcjogZmFsc2UsXG4gICAgICAgICAgICBzdHJpbmdGaWVsZHNDb3VudDogMCxcbiAgICAgICAgICAgIGRhdGVGaWVsZHNDb3VudDogMCxcbiAgICAgICAgICAgIG51bWJlckZpZWxkc0NvdW50OiAwLFxuICAgICAgICAgICAgaXNIb3N0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3VwcG9ydHNTdGFuZGFyZGl6ZWRRdWVyeTogZmFsc2UsXG4gICAgICAgICAgICBzdXBwb3J0ZWRTcWxQYXJzZXJWZXJzaW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGxheWVyOiB7fSxcbiAgICAgICAgICAgIHZpZXc6IHRoaXMudmlldyxcbiAgICAgICAgICAgIGxhYmVsQ2xhc3NJZHg6IHRoaXMubGFiZWxDbGFzc0lkeCxcbiAgICAgICAgICAgIGxhYmVsQ2xhc3M6IHRoaXMubGFiZWxDbGFzcyxcbiAgICAgICAgICAgIGZlYXR1cmVSZWR1Y3Rpb246IHRoaXMuZmVhdHVyZVJlZHVjdGlvbixcbiAgICAgICAgICAgIHN0cmluZ3MsXG4gICAgICAgICAgICBsb2NhbGU6IGN1cnJlbnRMYW5ndWFnZSxcbiAgICAgICAgICAgIGxvY2FsZUludGw6IGN1cnJlbnRMYW5ndWFnZUludGwsXG4gICAgICAgICAgICBpbnB1dERlZmluaXRpb25FeHByZXNzaW9uOiBudWxsLFxuICAgICAgICAgICAgYmFja2dyb3VuZFRoZW1lOiBcImxpZ2h0XCIsXG4gICAgICAgICAgICBsYXN0V2hlcmU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRlZmF1bHRGaWVsZE5hbWU6IHRoaXMuZGVmYXVsdEZpZWxkTmFtZSxcbiAgICAgICAgICAgIGRlZmF1bHRPcGVyYXRvcjogdGhpcy5kZWZhdWx0T3BlcmF0b3JcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgW3JlYWN0aXZlVXRpbHMsIGNvbG9yVXRpbHMsIEltYWdlcnlMYXllciwgRmVhdHVyZUxheWVyLCBGZWF0dXJlRWZmZWN0LCBlc3JpTGFuZ10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICAgICAgICBcImVzcmkvY29yZS9yZWFjdGl2ZVV0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvdmlld3Mvc3VwcG9ydC9jb2xvclV0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvbGF5ZXJzL0ltYWdlcnlMYXllclwiLFxuICAgICAgICAgICAgXCJlc3JpL2xheWVycy9GZWF0dXJlTGF5ZXJcIixcbiAgICAgICAgICAgIFwiZXNyaS9sYXllcnMvc3VwcG9ydC9GZWF0dXJlRWZmZWN0XCIsXG4gICAgICAgICAgICBcImVzcmkvY29yZS9sYW5nXCJcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMucmVhY3RpdmVVdGlscyA9IHJlYWN0aXZlVXRpbHM7XG4gICAgICAgIHRoaXMuY29sb3JVdGlscyA9IGNvbG9yVXRpbHM7XG4gICAgICAgIHRoaXMuSW1hZ2VyeUxheWVyID0gSW1hZ2VyeUxheWVyO1xuICAgICAgICB0aGlzLkZlYXR1cmVMYXllciA9IEZlYXR1cmVMYXllcjtcbiAgICAgICAgdGhpcy5GZWF0dXJlRWZmZWN0ID0gRmVhdHVyZUVmZmVjdDtcbiAgICAgICAgdGhpcy5lc3JpTGFuZyA9IGVzcmlMYW5nO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGxheWVyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcHJvcExheWVyID0gbGF5ZXI7IC8vIGlzc3VlIHdpdGggdHlwZSBwcm9wXG4gICAgICAgIGlmIChwcm9wTGF5ZXIuZGVjbGFyZWRDbGFzcyA9PT0gXCJlc3JpLmxheWVycy5zdXBwb3J0LlN1YmxheWVyXCIpIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gY3JlYXRlIGEgRmVhdHVyZUxheWVyXG4gICAgICAgICAgICBjb25zdCBtYXBJbWFnZVN1YmxheWVyID0gcHJvcExheWVyO1xuICAgICAgICAgICAgLy9kZWxldGUgdGhpcy5sYXllcjtcbiAgICAgICAgICAgIHZpZXcgJiYgKGF3YWl0IHRoaXMucmVhY3RpdmVVdGlscy53aGVuT25jZSgoKSA9PiAhdmlldy51cGRhdGluZykpO1xuICAgICAgICAgICAgY29uc3Qgc3VibGF5ZXJGTCA9IGF3YWl0IG1hcEltYWdlU3VibGF5ZXIuY3JlYXRlRmVhdHVyZUxheWVyKCk7XG4gICAgICAgICAgICBhd2FpdCBzdWJsYXllckZMLmxvYWQoKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBsYXllcjogc3VibGF5ZXJGTCwgbWFwSW1hZ2VTdWJsYXllciB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9wTGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgfHwgcHJvcExheWVyLnR5cGUgPT09IFwic3VidHlwZS1ncm91cFwiKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHsgbGF5ZXI6IHByb3BMYXllciB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdmlldyB8fCAocHJvcExheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmIHByb3BMYXllci5pc1RhYmxlKSkge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCBhIGxheWVyIHdpdGhvdXQgYSBmaWx0ZXIgZm9yIHN0YXRpc3RpY3MsIGhpc3RvZ3JhbSwgYW5kIHVuaXF1ZVZhbHVlc1xuICAgICAgICAgICAgbGV0IG5vbkZpbHRlcmVkTGF5ZXI7XG4gICAgICAgICAgICBub25GaWx0ZXJlZExheWVyID0gbmV3IHRoaXMuRmVhdHVyZUxheWVyKHtcbiAgICAgICAgICAgICAgICB1cmw6IHByb3BMYXllci51cmwsXG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogcHJvcExheWVyLmxheWVySWQsXG4gICAgICAgICAgICAgICAgcG9wdXBUZW1wbGF0ZTogcHJvcExheWVyLnBvcHVwVGVtcGxhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgbm9uRmlsdGVyZWRMYXllci5sb2FkKCk7XG4gICAgICAgICAgICB0aGlzLnByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHsgbGF5ZXI6IG5vbkZpbHRlcmVkTGF5ZXIsIG9yaWdpbmFsTGF5ZXI6IHByb3BMYXllciB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBsYXllcjogcHJvcExheWVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbGFiZWxDbGFzc0lkeCwgbGFiZWxDbGFzcywgZmVhdHVyZVJlZHVjdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgbGFiZWxpbmdJbmZvID0gZmVhdHVyZVJlZHVjdGlvblxuICAgICAgICAgICAgPyBsYXllci5mZWF0dXJlUmVkdWN0aW9uLmxhYmVsaW5nSW5mb1xuICAgICAgICAgICAgOiBsYXllci5sYWJlbGluZ0luZm87XG4gICAgICAgIGlmICgoaXNEZWZpbmVkKGxhYmVsQ2xhc3NJZHgpICYmICghbGFiZWxpbmdJbmZvIHx8ICFsYWJlbGluZ0luZm9bbGFiZWxDbGFzc0lkeF0pKSB8fFxuICAgICAgICAgICAgKGlzRGVmaW5lZChsYWJlbENsYXNzKSAmJiAoIWxhYmVsaW5nSW5mbyB8fCAhbGFiZWxpbmdJbmZvLmxlbmd0aCkpKSB7XG4gICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYW4ndCBmaW5kIGxhYmVsQ2xhc3NcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzTGF5ZXIoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBkZWZhdWx0RXhwcmVzc2lvbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCEoKF9hID0gcHJvcHMuZXhwcmVzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICYmIGRlZmF1bHRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLm9uQWRkRXhwcmVzc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnBhbmVsTm9kZS5zZXRGb2N1cygpKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BlckNsb3NlKSB7XG4gICAgICAgICAgICAvLyB1c2VyIGxlZnQgdGhlIHBhbmVsIHZpYSBTYXZlLCBDYW5jZWwsIG9yIENsb3NlXG4gICAgICAgICAgICAvLyBqdXN0IGNsb3NlIHBvcG92ZXJzXG4gICAgICAgICAgICB0aGlzLmNsb3NlRmlsdGVyUG9wb3ZlcnMuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlciBsZWZ0IHRoZSBwYW5lbCB3aXRob3V0IGNsaWNraW5nIG9uIFNhdmUsIENhbmNlbCwgb3IgQ2xvc2VcbiAgICAgICAgICAgIC8vIGUuZy4gYWxzbyBwYW5lbCBiYWNrIGJ1dHRvblxuICAgICAgICAgICAgdGhpcy5hcHBseUZpbHRlcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJsYXllci12aWV3XCIpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVJbmRleGVzKHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGhpZGVMYXllclRpdGxlLCBtb2RlLCBwYW5lbEhlYWRpbmcsIGNvbXBvbmVudFN0YXRlSW52YWxpZCwgZGlzbWlzc2libGUsIGhvc3RFbGVtZW50LCBwYW5lbE1heEhlaWdodCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcihob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIGludmFsaWRGaWx0ZXIsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB0aXRsZSA9IG1hcEltYWdlU3VibGF5ZXIgPyBtYXBJbWFnZVN1YmxheWVyLnRpdGxlIDogbGF5ZXIudGl0bGU7XG4gICAgICAgIGlmIChjb21wb25lbnRTdGF0ZUludmFsaWQpIHtcbiAgICAgICAgICAgIC8vIHdlIHJlbW92ZWQgdGhlIGVmZmVjdCBhbmQgY3JlYXRlZCBhIGRlZmluaXRpb25FeHByZXNzaW9uXG4gICAgICAgICAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImRpdlwiLCBudWxsKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckxvYWRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52YWxpZEZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW52YWxpZEZpbHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0RWxlbWVudC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09IFwiQ0FMQ0lURS1GTE9XXCIgfHxcbiAgICAgICAgICAgIGhvc3RFbGVtZW50LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC50YWdOYW1lID09PSBcIkNBTENJVEUtRkxPV1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImNhbGNpdGUtZmxvdy1pdGVtXCIsIHsgaWQ6IFwiZmlsdGVyLXBhbmVsXCIsIGxvYWRpbmc6IGZhbHNlLCBoZWFkaW5nOiBwYW5lbEhlYWRpbmcgfHwgc3RyaW5ncy50aXRsZSwgZGVzY3JpcHRpb246ICFoaWRlTGF5ZXJUaXRsZSA/IHRpdGxlIDogdW5kZWZpbmVkLCBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICAgICAgICAgICAgfSwgc3R5bGU6IHBhbmVsTWF4SGVpZ2h0ICYmIHsgbWF4SGVpZ2h0OiBwYW5lbE1heEhlaWdodCB9LCBjbG9zYWJsZTogZGlzbWlzc2libGUsIHJlZjogKG5vZGUpID0+ICh0aGlzLnBhbmVsTm9kZSA9IG5vZGUpLCBvbkNhbGNpdGVGbG93SXRlbUJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwibGF5ZXItdmlld1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGVyZUNsYXVzZSA9IGNyZWF0ZVdoZXJlQ2xhdXNlKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyUGFuZWxCYWNrQ2xpY2suZW1pdCh3aGVyZUNsYXVzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgaW5kZXhlcyBvbiBkaXNjb25uZWN0IGNhbGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyUGFuZWxCYWNrQ2xpY2suZW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgb25DYWxjaXRlRmxvd0l0ZW1DbG9zZTogKCkgPT4gdGhpcy5jbG9zZUZpbHRlcigpIH0sIHRoaXMucmVuZGVyQ29udGVudCgpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJjYWxjaXRlLXBhbmVsXCIsIHsgaWQ6IFwiZmlsdGVyLXBhbmVsXCIsIGxvYWRpbmc6IGZhbHNlLCBoZWFkaW5nOiBwYW5lbEhlYWRpbmcgfHwgc3RyaW5ncy50aXRsZSwgZGVzY3JpcHRpb246ICFoaWRlTGF5ZXJUaXRsZSA/IHRpdGxlIDogdW5kZWZpbmVkLCBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICAgICAgICAgICAgfSwgc3R5bGU6IHBhbmVsTWF4SGVpZ2h0ICYmIHsgbWF4SGVpZ2h0OiBwYW5lbE1heEhlaWdodCB9LCBjbG9zYWJsZTogZGlzbWlzc2libGUsIHJlZjogKG5vZGUpID0+ICh0aGlzLnBhbmVsTm9kZSA9IG5vZGUpLCBvbkNhbGNpdGVQYW5lbENsb3NlOiAoKSA9PiB0aGlzLmNsb3NlRmlsdGVyKCkgfSwgdGhpcy5yZW5kZXJDb250ZW50KCkpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyQ29udGVudCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgbW9kZSwgaGlkZUJ1dHRvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGFiZWxDbGFzc0lkeCwgbGFiZWxDbGFzcyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxGaWx0ZXIgPSBpc0RlZmluZWQobGFiZWxDbGFzc0lkeCkgfHwgaXNEZWZpbmVkKGxhYmVsQ2xhc3MpO1xuICAgICAgICByZXR1cm4gKGgoRnJhZ21lbnQsIG51bGwsICFpc0xhYmVsRmlsdGVyICYmIG1vZGUgIT09IFwibGF5ZXItdmlld1wiICYmICFoaWRlQnV0dG9ucyA/IHRoaXMucmVuZGVyU2F2ZUJ1dHRvbigpIDogbnVsbCwgIWlzTGFiZWxGaWx0ZXIgJiYgbW9kZSAhPT0gXCJsYXllci12aWV3XCIgJiYgIWhpZGVCdXR0b25zID8gdGhpcy5yZW5kZXJDYW5jZWxCdXR0b24oKSA6IG51bGwsIHRoaXMucmVuZGVyUG9wb3Zlckhvb2soKSwgdGhpcy5yZW5kZXJSZW1vdmVGaWx0ZXIoKSwgdGhpcy5yZW5kZXJNYXRjaEV4cHJlc3Npb25Nc2coKSwgdGhpcy5yZW5kZXJFeHByZXNzaW9ucygpLCB0aGlzLnJlbmRlckFkZEV4cHJlc3Npb24oKSwgdGhpcy5yZW5kZXJUaXAoKSkpO1xuICAgIH1cbiAgICByZW5kZXJTYXZlQnV0dG9uKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIG9uQ2xpY2s6IHRoaXMuYXBwbHlGaWx0ZXIsIGFwcGVhcmFuY2U6IFwic29saWRcIiwgd2lkdGg6IFwiaGFsZlwiLCBsYWJlbDogc3RyaW5ncy5zYXZlIH0sIHN0cmluZ3Muc2F2ZSkpO1xuICAgIH1cbiAgICByZW5kZXJDYW5jZWxCdXR0b24oKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgc2xvdDogXCJmb290ZXJcIiwgb25DbGljazogdGhpcy5jYW5jZWxGaWx0ZXIsIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIHdpZHRoOiBcImhhbGZcIiwgbGFiZWw6IHN0cmluZ3MuY2FuY2VsIH0sIHN0cmluZ3MuY2FuY2VsKSk7XG4gICAgfVxuICAgIHJlbmRlclBvcG92ZXJIb29rKCkge1xuICAgICAgICByZXR1cm4gaChcImRpdlwiLCB7IGlkOiBcImFyY2dpcy1maWx0ZXItaG9va1wiLCBjbGFzczogQ1NTJDMuaG9vayB9KTtcbiAgICB9XG4gICAgcmVuZGVyUmVtb3ZlRmlsdGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjbGVhclRleHQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncywgZXhwcmVzc2lvbnMgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIWV4cHJlc3Npb25zIHx8ICFleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMy5yZW1vdmVGaWx0ZXIgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBjbGFzczogXCJuby1zcGFjZVwiLCBsYXlvdXQ6IFwiaW5saW5lLXNwYWNlLWJldHdlZW5cIiwgc2NhbGU6IFwibVwiIH0sIGNsZWFyVGV4dCB8fCBzdHJpbmdzLnJlbW92ZUZpbHRlciwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgdGV4dDogY2xlYXJUZXh0IHx8IHN0cmluZ3MucmVtb3ZlRmlsdGVyLCBzY2FsZTogXCJtXCIsIG9uQ2xpY2s6IHRoaXMub25SZW1vdmVGaWx0ZXIgfSwgaChcImNhbGNpdGUtaWNvblwiLCB7IHNjYWxlOiBcInNcIiwgaWNvbjogXCJ0cmFzaFwiIH0pKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyTG9hZGluZygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgaGlkZUxheWVyVGl0bGUsIHBhbmVsSGVhZGluZyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgbWFwSW1hZ2VTdWJsYXllciwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gbWFwSW1hZ2VTdWJsYXllciA/IG1hcEltYWdlU3VibGF5ZXIudGl0bGUgOiBsYXllci50aXRsZTtcbiAgICAgICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJjYWxjaXRlLXBhbmVsXCIsIHsgaWQ6IFwiZmlsdGVyLXBhbmVsXCIsIGhlYWRpbmc6IHBhbmVsSGVhZGluZyB8fCBzdHJpbmdzLnRpdGxlLCBkZXNjcmlwdGlvbjogIWhpZGVMYXllclRpdGxlID8gdGl0bGUgOiB1bmRlZmluZWQsIGxvYWRpbmc6IHRydWUsIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcGFuZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IHJ0bFxuICAgICAgICAgICAgfSB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJJbnZhbGlkRmlsdGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBoaWRlTGF5ZXJUaXRsZSwgZGlzbWlzc2libGUsIG1vZGUsIGhpZGVCdXR0b25zLCBwYW5lbEhlYWRpbmcgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIGxhYmVsQ2xhc3NJZHgsIGxhYmVsQ2xhc3MsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB0aXRsZSA9IG1hcEltYWdlU3VibGF5ZXIgPyBtYXBJbWFnZVN1YmxheWVyLnRpdGxlIDogbGF5ZXIudGl0bGU7XG4gICAgICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxGaWx0ZXIgPSBpc0RlZmluZWQobGFiZWxDbGFzc0lkeCkgfHwgaXNEZWZpbmVkKGxhYmVsQ2xhc3MpO1xuICAgICAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImNhbGNpdGUtcGFuZWxcIiwgeyBpZDogXCJmaWx0ZXItcGFuZWxcIiwgaGVhZGluZzogcGFuZWxIZWFkaW5nIHx8IHN0cmluZ3MudGl0bGUsIGRlc2NyaXB0aW9uOiAhaGlkZUxheWVyVGl0bGUgPyB0aXRsZSA6IHVuZGVmaW5lZCwgbG9hZGluZzogZmFsc2UsIGNsb3NhYmxlOiBkaXNtaXNzaWJsZSwgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICBwYW5lbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICAgICAgICB9LCByZWY6IHRoaXMuZm9jdXNCeUNsYXNzLCBvbkNhbGNpdGVQYW5lbENsb3NlOiAoKSA9PiB0aGlzLmNsb3NlRmlsdGVyKCkgfSwgIWlzTGFiZWxGaWx0ZXIgJiYgbW9kZSAhPT0gXCJsYXllci12aWV3XCIgJiYgIWhpZGVCdXR0b25zID8gdGhpcy5yZW5kZXJTYXZlQnV0dG9uKCkgOiBudWxsLCAhaXNMYWJlbEZpbHRlciAmJiBtb2RlICE9PSBcImxheWVyLXZpZXdcIiAmJiAhaGlkZUJ1dHRvbnNcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJDYW5jZWxCdXR0b24oKVxuICAgICAgICAgICAgOiBudWxsLCB0aGlzLnJlbmRlckludmFsaWRGaWx0ZXJNc2coKSwgdGhpcy5yZW5kZXJDcmVhdGVOZXdGaWx0ZXIoKSkpKTtcbiAgICB9XG4gICAgcmVuZGVySW52YWxpZEZpbHRlck1zZygpIHtcbiAgICAgICAgLy8gaGVscElkID0gMTIwMDAxNzM2IGZvciBMZWFybk1vcmVcbiAgICAgICAgY29uc3QgeyBpbnZhbGlkSGVhZGluZywgaW52YWxpZE1zZywgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtdGlwXCIsIHsgaGVhZGluZzogaW52YWxpZEhlYWRpbmcgfHwgc3RyaW5ncy5lcnJvcnMucHJvYmxlbURpc3BsYXlpbmdGaWx0ZXIsIGNsb3NlRGlzYWJsZWQ6IHRydWUgfSwgaChcImRpdlwiLCBudWxsLCBpbnZhbGlkTXNnIHx8IHN0cmluZ3MuZXJyb3JzLnByb2JsZW1EaXNwbGF5aW5nRmlsdGVyTXNnKSkpO1xuICAgIH1cbiAgICByZW5kZXJDcmVhdGVOZXdGaWx0ZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIG5ld0J1dHRvbkxhYmVsLCBoaWRlQnV0dG9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1mYWJcIiwgeyBjbGFzczoge1xuICAgICAgICAgICAgICAgIGF1dG9mb2N1czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImZhYi1wYWRkaW5nXCI6IGhpZGVCdXR0b25zXG4gICAgICAgICAgICB9LCBzbG90OiBcImZhYlwiLCBhcHBlYXJhbmNlOiBcIm91dGxpbmUtZmlsbFwiLCBraW5kOiBcIm5ldXRyYWxcIiwgc2NhbGU6IFwibVwiLCB0ZXh0RW5hYmxlZDogdHJ1ZSwgbGFiZWw6IG5ld0J1dHRvbkxhYmVsIHx8IHN0cmluZ3MuY3JlYXRlTmV3RmlsdGVyLCB0ZXh0OiBuZXdCdXR0b25MYWJlbCB8fCBzdHJpbmdzLmNyZWF0ZU5ld0ZpbHRlciwgb25DbGljazogdGhpcy5vblJlbW92ZUZpbHRlciB9KSk7XG4gICAgfVxuICAgIHJlbmRlck1hdGNoRXhwcmVzc2lvbk1zZygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBleHByZXNzaW9ucywgbG9naWNhbE9wZXJhdG9yRm9yRXhwcmVzc2lvbnMsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIWV4cHJlc3Npb25zIHx8ICFleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQW5kID0gbG9naWNhbE9wZXJhdG9yRm9yRXhwcmVzc2lvbnMgPT09IGxvZ2ljYWxPcGVyYXRvcnMuQU5EO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxID8gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDMubWF0Y2hFeHByZXNzaW9uTXNnIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwibVwiLCBjbGFzczogXCJuby1zcGFjZVwiIH0sIHN0cmluZ3Mub25lRXhwcmVzc2lvbk1zZykpKSA6IChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQzLm1hdGNoRXhwcmVzc2lvbk1zZyB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGNsYXNzOiBcIm5vLXNwYWNlXCIsIHNjYWxlOiBcIm1cIiB9LCBzdHJpbmdzLm1hbnlFeHByZXNzaW9uc01zZywgaChcImNhbGNpdGUtc2VsZWN0XCIsIHsgd2lkdGg6IFwiZnVsbFwiLCBzY2FsZTogXCJtXCIsIGxhYmVsOiBzdHJpbmdzLmFjY2Vzc2liaWxpdHkubWF0Y2hFeHByZXNzaW9ucywgY2xhc3M6IENTUyQzLm1hdGNoRXhwcmVzc2lvbkRyb3Bkb3duLCBvbkNhbGNpdGVTZWxlY3RDaGFuZ2U6IHRoaXMub25NYXRjaFNlbGVjdCB9LCBoKFwiY2FsY2l0ZS1vcHRpb25cIiwgeyB2YWx1ZTogbG9naWNhbE9wZXJhdG9ycy5BTkQsIGxhYmVsOiBzdHJpbmdzLm1hdGNoQWxsRXhwcmVzc2lvbnMsIHNlbGVjdGVkOiBpc0FuZCB9KSwgaChcImNhbGNpdGUtb3B0aW9uXCIsIHsgdmFsdWU6IGxvZ2ljYWxPcGVyYXRvcnMuT1IsIGxhYmVsOiBzdHJpbmdzLm1hdGNoQXRMZWFzdE9uZUV4cHJlc3Npb24sIHNlbGVjdGVkOiAhaXNBbmQgfSkpKSkpO1xuICAgIH1cbiAgICByZW5kZXJFeHByZXNzaW9ucygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBleHByZXNzaW9ucyB9ID0gcHJvcHM7XG4gICAgICAgIGlmICghZXhwcmVzc2lvbnMgfHwgIWV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIGV4cHJlc3Npb25zLm1hcCgoZXhwcmVzc2lvblByb3BzLCBpZHgpID0+IHRoaXMucmVuZGVyRXhwcmVzc2lvbihleHByZXNzaW9uUHJvcHMsIGlkeCkpKSk7XG4gICAgfVxuICAgIHJlbmRlckV4cHJlc3Npb24oZXhwcmVzc2lvblByb3BzLCBleHByZXNzaW9uSW5kZXgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIHRoaXMucmVuZGVyTG9naWNhbE9wZXJhdG9yRXhwcmVzc2lvbihleHByZXNzaW9uSW5kZXgpLCBoKFwiYXJjZ2lzLWZpbHRlci1leHByZXNzaW9uXCIsIE9iamVjdC5hc3NpZ24oeyBwcm9wczogcHJvcHMsIHJlZjogdGhpcy5mb2N1c0J5Q2xhc3MgfSwgZXhwcmVzc2lvblByb3BzKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyTG9naWNhbE9wZXJhdG9yRXhwcmVzc2lvbihleHByZXNzaW9uSW5kZXgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsb2dpY2FsT3BlcmF0b3JGb3JFeHByZXNzaW9ucywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGlmIChleHByZXNzaW9uSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQzLmxvZ2ljYWxPcGVyYXRvciB9LCBoKFwic3BhblwiLCBudWxsLCBsb2dpY2FsT3BlcmF0b3JGb3JFeHByZXNzaW9ucyA9PT0gbG9naWNhbE9wZXJhdG9ycy5PUiA/IHN0cmluZ3Mub3IgOiBzdHJpbmdzLmFuZCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJBZGRFeHByZXNzaW9uKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBoaWRlQnV0dG9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBleHByZXNzaW9ucywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtZmFiXCIsIHsgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICBhdXRvZm9jdXM6ICFleHByZXNzaW9ucyB8fCAhZXhwcmVzc2lvbnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIFwiZmFiLXBhZGRpbmdcIjogaGlkZUJ1dHRvbnNcbiAgICAgICAgICAgIH0sIHNsb3Q6IFwiZmFiXCIsIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIGtpbmQ6IFwibmV1dHJhbFwiLCBzY2FsZTogXCJtXCIsIGljb246IFwicGx1c1wiLCB0ZXh0RW5hYmxlZDogdHJ1ZSwgdGV4dDogc3RyaW5ncy5hZGRFeHByZXNzaW9uLCBvbkNsaWNrOiB0aGlzLm9uQWRkRXhwcmVzc2lvbiwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZmFiTm9kZSA9IG5vZGUpIH0pKTtcbiAgICB9XG4gICAgcmVuZGVyVGlwKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBtb2RlLCB0aXBIZWFkaW5nLCB0aXBNc2cgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbWFwSW1hZ2VTdWJsYXllciwgZXhwcmVzc2lvbnMsIGxhYmVsQ2xhc3NJZHgsIGxhYmVsQ2xhc3MsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMgPT09IG51bGwgfHwgZXhwcmVzc2lvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9yTGFiZWxzID0gaXNEZWZpbmVkKGxhYmVsQ2xhc3NJZHgpIHx8IGlzRGVmaW5lZChsYWJlbENsYXNzKTtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS10aXBcIiwgeyBoZWFkaW5nOiB0aXBIZWFkaW5nIHx8IHN0cmluZ3MudGlwcy5lbXB0eU1zZ1RpdGxlLCBjbG9zZURpc2FibGVkOiB0cnVlIH0sIGgoXCJkaXZcIiwgbnVsbCwgdGlwTXNnIHx8XG4gICAgICAgICAgICAoZm9yTGFiZWxzXG4gICAgICAgICAgICAgICAgPyBzdHJpbmdzLnRpcHMuZW1wdHlNc2dMYWJlbHNcbiAgICAgICAgICAgICAgICA6IG1hcEltYWdlU3VibGF5ZXIgfHwgbW9kZSA9PT0gXCJsYXllci12aWV3XCJcbiAgICAgICAgICAgICAgICAgICAgPyBzdHJpbmdzLnRpcHMuZW1wdHlNc2dNU1xuICAgICAgICAgICAgICAgICAgICA6IHN0cmluZ3MudGlwcy5lbXB0eU1zZykpKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIHByb2Nlc3NMYXllcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBtb2RlLCB2aWV3RmlsdGVyLCBoaWRlQnV0dG9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgbWFwSW1hZ2VTdWJsYXllciwgb3JpZ2luYWxMYXllciwgdmlldywgbGFiZWxDbGFzc0lkeCwgbGFiZWxDbGFzcywgZmVhdHVyZVJlZHVjdGlvbiB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGxhYmVsaW5nSW5mbyA9IGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmXG4gICAgICAgICAgICAoZmVhdHVyZVJlZHVjdGlvblxuICAgICAgICAgICAgICAgID8gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbi5sYWJlbGluZ0luZm9cbiAgICAgICAgICAgICAgICA6IGxheWVyLmxhYmVsaW5nSW5mbyk7XG4gICAgICAgIGlmICh2aWV3ICYmXG4gICAgICAgICAgICAhbWFwSW1hZ2VTdWJsYXllciAmJlxuICAgICAgICAgICAgbGF5ZXIudHlwZSAhPT0gXCJpbWFnZXJ5XCIgJiZcbiAgICAgICAgICAgIGxheWVyLnR5cGUgIT09IFwic3VidHlwZS1ncm91cFwiICYmXG4gICAgICAgICAgICAhKGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmIGxheWVyLmlzVGFibGUpKSB7XG4gICAgICAgICAgICBwcm9wcy5sYXllclZpZXcgPSAoYXdhaXQgdmlldy53aGVuTGF5ZXJWaWV3KGxheWVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDb25maWcocHJvcHMpO1xuICAgICAgICBhd2FpdCBidWlsZEZpbHRlckZpZWxkcyhwcm9wcyk7XG4gICAgICAgIGJ1aWxkT3BlcmF0b3JzTGlzdChwcm9wcyk7XG4gICAgICAgIHByb3BzLmJhY2tncm91bmRUaGVtZSA9IHZpZXcgJiYgKGF3YWl0IHRoaXMuY29sb3JVdGlscy5nZXRCYWNrZ3JvdW5kQ29sb3JUaGVtZSh2aWV3KSk7XG4gICAgICAgIHRoaXMubGF5ZXJIYXNGZWF0dXJlRWZmZWN0ID0gbGF5ZXIuZmVhdHVyZUVmZmVjdDtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChsYWJlbENsYXNzSWR4KSAmJiBsYWJlbGluZ0luZm9bbGFiZWxDbGFzc0lkeF0ud2hlcmUpIHtcbiAgICAgICAgICAgIHByb3BzLmlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb24gPSBsYWJlbGluZ0luZm9bbGFiZWxDbGFzc0lkeF0ud2hlcmU7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgcGFyc2VXaGVyZUNsYXVzZShwcm9wcy5pbnB1dERlZmluaXRpb25FeHByZXNzaW9uLCBwcm9wcyk7XG4gICAgICAgICAgICBwcm9wcy5pbnZhbGlkRmlsdGVyID0gIXN1Y2Nlc3M7XG4gICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEZWZpbmVkKGxhYmVsQ2xhc3MpICYmIGxhYmVsQ2xhc3Mud2hlcmUpIHtcbiAgICAgICAgICAgIHByb3BzLmlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb24gPSBsYWJlbENsYXNzLndoZXJlO1xuICAgICAgICAgICAgcHJvcHMubGFzdFdoZXJlID0gcHJvcHMuaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBwYXJzZVdoZXJlQ2xhdXNlKHByb3BzLmlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb24sIHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHMuaW52YWxpZEZpbHRlciA9ICFzdWNjZXNzO1xuICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IFwibGF5ZXItdmlld1wiKSB7XG4gICAgICAgICAgICAvLyBrZWVwIGRlZmluaXRpb25FeHByZXNzaW9uIG9uIEZMLCB0aGUgbmV3IGZpbHRlciBpcyBhbiBhZGQtb25cbiAgICAgICAgICAgIGlmICh2aWV3RmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHBhcnNlV2hlcmVDbGF1c2Uodmlld0ZpbHRlciwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIHByb3BzLmludmFsaWRGaWx0ZXIgPSAhc3VjY2VzcztcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RmlsdGVyVG9MYXllcih0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IFwiZWZmZWN0c1wiKSB7XG4gICAgICAgICAgICBwcm9wcy5pbnZhbGlkRmlsdGVyID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobGF5ZXIuZmVhdHVyZUVmZmVjdCkge1xuICAgICAgICAgICAgICAgIHByb3BzLmlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb24gPSAoX2EgPSBsYXllci5mZWF0dXJlRWZmZWN0LmZpbHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndoZXJlO1xuICAgICAgICAgICAgICAgIHByb3BzLmxhc3RXaGVyZSA9IHByb3BzLmlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHBhcnNlV2hlcmVDbGF1c2UocHJvcHMuaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbiwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIHByb3BzLmludmFsaWRGaWx0ZXIgPSAhc3VjY2VzcztcbiAgICAgICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzRGVmaW5lZChsYWJlbENsYXNzSWR4KSAmJlxuICAgICAgICAgICAgIWlzRGVmaW5lZChsYWJlbENsYXNzKSAmJlxuICAgICAgICAgICAgKGlzRGVmaW5lZChsYXllci5kZWZpbml0aW9uRXhwcmVzc2lvbikgfHwgaXNEZWZpbmVkKG9yaWdpbmFsTGF5ZXIgPT09IG51bGwgfHwgb3JpZ2luYWxMYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWxMYXllci5kZWZpbml0aW9uRXhwcmVzc2lvbikpKSB7XG4gICAgICAgICAgICBwcm9wcy5pbnB1dERlZmluaXRpb25FeHByZXNzaW9uID0gKG9yaWdpbmFsTGF5ZXIgfHwgbGF5ZXIpLmRlZmluaXRpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgLy8gYXBwbHkgRmVhdHVyZUZpbHRlciB0byBsYXllclxuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHBhcnNlV2hlcmVDbGF1c2UocHJvcHMuaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbiwgcHJvcHMpO1xuICAgICAgICAgICAgcHJvcHMuaW52YWxpZEZpbHRlciA9ICFzdWNjZXNzO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RmlsdGVyVG9MYXllcih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgICAgIGlmICh2aWV3ICYmXG4gICAgICAgICAgICAgICAgbGF5ZXIudHlwZSAhPT0gXCJpbWFnZXJ5XCIgJiZcbiAgICAgICAgICAgICAgICBsYXllci50eXBlICE9PSBcInN1YnR5cGUtZ3JvdXBcIiAmJlxuICAgICAgICAgICAgICAgICEobGF5ZXIudHlwZSA9PT0gXCJmZWF0dXJlXCIgJiYgbGF5ZXIuaXNUYWJsZSkgJiZcbiAgICAgICAgICAgICAgICAhKG1vZGUgPT09IFwiZWZmZWN0c1wiICYmIHRoaXMubGF5ZXJIYXNGZWF0dXJlRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBkZWZpbml0aW9uRXhwcmVzc2lvbiBmcm9tIGxheWVyXG4gICAgICAgICAgICAgICAgLy8gd2UgdXNlIGVmZmVjdCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgbGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhpZGVCdXR0b25zKSB7XG4gICAgICAgICAgICBwcm9wcy5pbnB1dERlZmluaXRpb25FeHByZXNzaW9uID0gbGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICBwcm9wcy5sYXN0V2hlcmUgPSBwcm9wcy5pbnB1dERlZmluaXRpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHBhcnNlV2hlcmVDbGF1c2UocHJvcHMuaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbiwgdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wcy5pbnZhbGlkRmlsdGVyID0gIXN1Y2Nlc3M7XG4gICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wcy5pbnZhbGlkRmlsdGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV2ZXJ0RmlsdGVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIG1vZGUsIHZpZXdGaWx0ZXIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIGxheWVyVmlldywgZmVhdHVyZVJlZHVjdGlvbiwgbGFiZWxDbGFzc0lkeCwgbGFiZWxDbGFzcywgaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbiwgbWFwSW1hZ2VTdWJsYXllciwgb3JpZ2luYWxMYXllciwgYmFja2dyb3VuZFRoZW1lIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldExhYmVsQ2xhc3NJbmRleCgpO1xuICAgICAgICAvLyBhcHBseSBvcmlnaW5hbCBleHByZXNzaW9uXG4gICAgICAgIGlmIChsYXllci50eXBlICE9PSBcImltYWdlcnlcIiAmJiBsYXllci50eXBlICE9PSBcInN1YnR5cGUtZ3JvdXBcIiAmJiBpc0RlZmluZWQobGFiZWxDbGFzc0lkeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsaW5nSW5mbyA9IGZlYXR1cmVSZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICA/IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24ubGFiZWxpbmdJbmZvXG4gICAgICAgICAgICAgICAgOiBsYXllci5sYWJlbGluZ0luZm87XG4gICAgICAgICAgICBsYWJlbGluZ0luZm9bbGFiZWxDbGFzc0lkeF0ud2hlcmUgPSBpbnB1dERlZmluaXRpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgLy8gcmVmcmVzaCBsYXllclxuICAgICAgICAgICAgaWYgKGZlYXR1cmVSZWR1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsYXllci5mZWF0dXJlUmVkdWN0aW9uID0gdGhpcy5lc3JpTGFuZy5jbG9uZShsYXllci5mZWF0dXJlUmVkdWN0aW9uKTtcbiAgICAgICAgICAgICAgICBwcm9wcy5sYWJlbENsYXNzID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbi5sYWJlbGluZ0luZm9baW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIubGFiZWxpbmdJbmZvID0gbGF5ZXIubGFiZWxpbmdJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcEltYWdlU3VibGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBtYXBJbWFnZVN1YmxheWVyLmxhYmVsaW5nSW5mbyA9IGxheWVyLmxhYmVsaW5nSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXllci50eXBlICE9PSBcImltYWdlcnlcIiAmJlxuICAgICAgICAgICAgbGF5ZXIudHlwZSAhPT0gXCJzdWJ0eXBlLWdyb3VwXCIgJiZcbiAgICAgICAgICAgIGlzRGVmaW5lZChsYWJlbENsYXNzKSkge1xuICAgICAgICAgICAgbGFiZWxDbGFzcy53aGVyZSA9IGlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICAvLyByZWZyZXNoIGxheWVyXG4gICAgICAgICAgICBpZiAoZmVhdHVyZVJlZHVjdGlvbikge1xuICAgICAgICAgICAgICAgIGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24gPSB0aGlzLmVzcmlMYW5nLmNsb25lKGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pO1xuICAgICAgICAgICAgICAgIHByb3BzLmxhYmVsQ2xhc3MgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uLmxhYmVsaW5nSW5mb1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXllci5sYWJlbGluZ0luZm8gPSBsYXllci5sYWJlbGluZ0luZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFwSW1hZ2VTdWJsYXllcikge1xuICAgICAgICAgICAgICAgIG1hcEltYWdlU3VibGF5ZXIubGFiZWxpbmdJbmZvID0gbGF5ZXIubGFiZWxpbmdJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IFwibGF5ZXItdmlld1wiKSB7XG4gICAgICAgICAgICAvLyBzZXQgYmFjayB0byBwYXNzZWQgaW4gdmlld0ZpbHRlclxuICAgICAgICAgICAgaWYgKGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VmZmVjdEVtcHR5KGxheWVyLmZlYXR1cmVFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0LmZpbHRlci53aGVyZSA9IHZpZXdGaWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBicmlnaHRuZXNzID0gYmFja2dyb3VuZFRoZW1lID09PSBcImxpZ2h0XCIgPyAxMDAgOiA2NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBuZXcgdGhpcy5GZWF0dXJlRWZmZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHZpZXdGaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVkRWZmZWN0OiBgZ3JheXNjYWxlKDEwMCUpIG9wYWNpdHkoMzAlKSBicmlnaHRuZXNzKCR7YnJpZ2h0bmVzc30lKWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9iID0gKF9hID0gbGF5ZXIuZmVhdHVyZUVmZmVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndoZXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0LmZpbHRlci53aGVyZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFZmZlY3RFbXB0eShsYXllci5mZWF0dXJlRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZmVhdHVyZUVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gXCJlZmZlY3RzXCIpIDtcbiAgICAgICAgZWxzZSBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChtYXBJbWFnZVN1YmxheWVyKSB7XG4gICAgICAgICAgICAgICAgbWFwSW1hZ2VTdWJsYXllci5kZWZpbml0aW9uRXhwcmVzc2lvbiA9IGlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAob3JpZ2luYWxMYXllciB8fCBsYXllcikuZGVmaW5pdGlvbkV4cHJlc3Npb24gPSBpbnB1dERlZmluaXRpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBbGxvd2VkRmVhdHVyZUVmZmVjdCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW55TGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICAgICAgICBpZiAoKF9kID0gKF9jID0gYW55TGF5ZXIuZmVhdHVyZUVmZmVjdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpbHRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLndoZXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFueUxheWVyLmZlYXR1cmVFZmZlY3QuZmlsdGVyLndoZXJlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRWZmZWN0RW1wdHkoYW55TGF5ZXIuZmVhdHVyZUVmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFueUxheWVyLmZlYXR1cmVFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyVmlldyAmJiBcImZpbHRlclwiIGluIGxheWVyVmlldykge1xuICAgICAgICAgICAgICAgICAgICBsYXllclZpZXcuZmlsdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzd2l0Y2hlZCB0byBkZWZpbml0aW9uRXhwcmVzc2lvbiBmcm9tIGVmZmVjdC9sYXllclZpZXcuZmlsdGVyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFN0YXRlSW52YWxpZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlGaWx0ZXJUb0xheWVyKGlzSW5pdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBsYXllclZpZXdXYWl0SGFuZGxlciwgaGlkZUJ1dHRvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgYmFja2dyb3VuZFRoZW1lLCBsYWJlbENsYXNzLCBsYXllciwgbGFiZWxDbGFzc0lkeCwgdmlldywgbGF5ZXJWaWV3LCBtYXBJbWFnZVN1YmxheWVyLCBvcmlnaW5hbExheWVyLCBmZWF0dXJlUmVkdWN0aW9uLCBsYXN0V2hlcmUgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB3aGVyZSA9IGNyZWF0ZVdoZXJlQ2xhdXNlKHByb3BzKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghaXNJbml0ICYmIHdoZXJlICE9PSBsYXN0V2hlcmUpIHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyV2hlcmVDaGFuZ2UuZW1pdCh3aGVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMubGFzdFdoZXJlID0gd2hlcmU7XG4gICAgICAgIGlmIChsYXllci50eXBlID09PSBcImZlYXR1cmVcIiAmJiBpc0RlZmluZWQobGFiZWxDbGFzc0lkeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRMYWJlbENsYXNzSW5kZXgoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsaW5nSW5mbyA9IGZlYXR1cmVSZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICA/IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24ubGFiZWxpbmdJbmZvXG4gICAgICAgICAgICAgICAgOiBsYXllci5sYWJlbGluZ0luZm87XG4gICAgICAgICAgICBsYWJlbGluZ0luZm9bbGFiZWxDbGFzc0lkeF0ud2hlcmUgPSB3aGVyZTtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggbGF5ZXJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlUmVkdWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbiA9IHRoaXMuZXNyaUxhbmcuY2xvbmUobGF5ZXIuZmVhdHVyZVJlZHVjdGlvbik7XG4gICAgICAgICAgICAgICAgcHJvcHMubGFiZWxDbGFzcyA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24ubGFiZWxpbmdJbmZvW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxheWVyLmxhYmVsaW5nSW5mbyA9IGxheWVyLmxhYmVsaW5nSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXBJbWFnZVN1YmxheWVyKSB7XG4gICAgICAgICAgICAgICAgbWFwSW1hZ2VTdWJsYXllci5sYWJlbGluZ0luZm8gPSBsYXllci5sYWJlbGluZ0luZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYXBwbHlcIiwgd2hlcmUsIGxheWVyLmxhYmVsaW5nSW5mbyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEZWZpbmVkKGxhYmVsQ2xhc3MpKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB1cGRhdGUgdGhlIGxheWVyIGF0IGFsbFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeVwiIHx8IGxheWVyLnR5cGUgPT09IFwic3VidHlwZS1ncm91cFwiKSB7XG4gICAgICAgICAgICBsYXllci5kZWZpbml0aW9uRXhwcmVzc2lvbiA9IHdoZXJlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhpZGVCdXR0b25zKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB1cGRhdGUgdGhlIGxheWVyIGF0IGFsbFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXBJbWFnZVN1YmxheWVyKSB7XG4gICAgICAgICAgICBtYXBJbWFnZVN1YmxheWVyLmRlZmluaXRpb25FeHByZXNzaW9uID0gd2hlcmU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXZpZXcgfHwgKGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmIGxheWVyLmlzVGFibGUpKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExheWVyLmRlZmluaXRpb25FeHByZXNzaW9uID0gY3JlYXRlV2hlcmVDbGF1c2UocHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVzZSBlZmZlY3RcbiAgICAgICAgaWYgKGxheWVyVmlld1dhaXRIYW5kbGVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobGF5ZXJWaWV3V2FpdEhhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5sYXllclZpZXdXYWl0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxheWVyVmlldykge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGFuZCB0cnkgbGF0ZXJcbiAgICAgICAgICAgIHRoaXMubGF5ZXJWaWV3V2FpdEhhbmRsZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RmlsdGVyVG9MYXllcigpO1xuICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiRmVhdHVyZUVmZmVjdC5maWx0ZXI6XCIsIHdoZXJlQ2xhdXNlKTtcbiAgICAgICAgaWYgKHdoZXJlID09PSBudWxsIHx8IHdoZXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aGVyZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWxsb3dlZEZlYXR1cmVFZmZlY3QoKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNFZmZlY3RFbXB0eShsYXllci5mZWF0dXJlRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0LmZpbHRlciA9IGxheWVyLmZlYXR1cmVFZmZlY3QuZmlsdGVyIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0LmZpbHRlci53aGVyZSA9IHdoZXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnJpZ2h0bmVzcyA9IGJhY2tncm91bmRUaGVtZSA9PT0gXCJsaWdodFwiID8gMTAwIDogNjU7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBuZXcgdGhpcy5GZWF0dXJlRWZmZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZWRFZmZlY3Q6IGBncmF5c2NhbGUoMTAwJSkgb3BhY2l0eSgzMCUpIGJyaWdodG5lc3MoJHticmlnaHRuZXNzfSUpYFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcImZpbHRlclwiIGluIGxheWVyVmlldykge1xuICAgICAgICAgICAgICAgIGxheWVyVmlldy5maWx0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdoZXJlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWxsb3dlZEZlYXR1cmVFZmZlY3QoKSkge1xuICAgICAgICAgICAgICAgIGlmICgoX2IgPSAoX2EgPSBsYXllci5mZWF0dXJlRWZmZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud2hlcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZmVhdHVyZUVmZmVjdC5maWx0ZXIud2hlcmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFZmZlY3RFbXB0eShsYXllci5mZWF0dXJlRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZmVhdHVyZUVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcImZpbHRlclwiIGluIGxheWVyVmlldykge1xuICAgICAgICAgICAgICAgIGxheWVyVmlldy5maWx0ZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlzQWxsb3dlZEZlYXR1cmVFZmZlY3QoKSB7XG4gICAgICAgIC8vIElkZWFsbHkgd2Ugd2FudCB0byBmaWx0ZXIgb3V0IGZlYXR1cmVzIHZpYSBsYXllci5mZWF0dXJlRWZmZWN0XG4gICAgICAgIC8vIHNvIHRoYXQgZmlsdGVyZWQgb3V0IGZlYXR1cmVzIHNob3cgZGltbWVkLlxuICAgICAgICAvLyBCdXQgaWYgdGhpcyBpcyBub3QgcG9zc2libGUgdXNlIGxheWVyVmlldy5maWx0ZXJcbiAgICAgICAgLy8gc28gZmlsdGVyZWQgb3V0IGZlYXR1cmVzIGFyZSBoaWRkZW4uXG4gICAgICAgIC8vIExheWVyLmRlZmluaXRpb25FeHByZXNzaW9uIGFmZmVjdHMgdGhlIHNlcnZlciBxdWVyaWVzXG4gICAgICAgIC8vIHNvIG9ubHkgYXBwbHkgdGhpcyB3aGVuIGxlYXZpbmcgdGhlIGNvbXBvbmVudFxuICAgICAgICBjb25zdCB7IHByb3BzLCBsYXllckhhc0ZlYXR1cmVFZmZlY3QsIG1vZGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKFtcImZlYXR1cmVcIiwgXCJnZW9qc29uXCIsIFwib2djLWZlYXR1cmVcIiwgXCJ3ZnNcIiwgXCJjc3ZcIiwgXCJzdHJlYW1cIl0uaW5kZXhPZihsYXllci50eXBlKSA+IC0xICYmXG4gICAgICAgICAgICAhbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbiAmJlxuICAgICAgICAgICAgbW9kZSAhPT0gXCJlZmZlY3RzXCIgJiZcbiAgICAgICAgICAgICghbGF5ZXJIYXNGZWF0dXJlRWZmZWN0IHx8IG1vZGUgPT09IFwibGF5ZXItdmlld1wiKSk7XG4gICAgfVxuICAgIGdldExhYmVsQ2xhc3NJbmRleCgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgbGFiZWxDbGFzcywgZmVhdHVyZVJlZHVjdGlvbiB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICBjb25zdCBsYWJlbGluZ0luZm8gPSBsYXllci50eXBlID09PSBcImZlYXR1cmVcIiAmJlxuICAgICAgICAgICAgKGZlYXR1cmVSZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICA/IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24ubGFiZWxpbmdJbmZvXG4gICAgICAgICAgICAgICAgOiBsYXllci5sYWJlbGluZ0luZm8pO1xuICAgICAgICBpZiAobGFiZWxDbGFzcykge1xuICAgICAgICAgICAgbGFiZWxpbmdJbmZvLmZvckVhY2goKGxDbGFzcywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGxDbGFzcy50b0pTT04oKSkgPT09IEpTT04uc3RyaW5naWZ5KGxhYmVsQ2xhc3MudG9KU09OKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaWR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc0ZpbHRlci5zdHlsZSA9IGFyY2dpc0ZpbHRlckNzcztcblxuY29uc3QgQ1NTJDIgPSB7XG4gICAgY29uZGl0aW9uOiBcImZpbHRlci1jb25kaXRpb25cIixcbiAgICBvcGVyYXRvckRyb3Bkb3duOiBcIm9wZXJhdG9yLWRyb3Bkb3duXCIsXG4gICAgaW5wdXRQbHVzVW5pcXVlOiBcImlucHV0LXBsdXMtdW5pcXVlXCIsXG4gICAgaW5wdXQ6IFwiaW5wdXRcIixcbiAgICBibGFua0J1dHRvbjogXCJibGFuay1idXR0b25cIixcbiAgICBzZWxlY3RVbmlxdWVCdXR0b246IFwic2VsZWN0LXVuaXF1ZS1idXR0b25cIixcbiAgICBiZXR3ZWVuVmFsdWVzSW5wdXQ6IFwiYmV0d2Vlbi12YWx1ZXMtaW5wdXRcIixcbiAgICBzZWxlY3RWYWx1ZXM6IFwic2VsZWN0LXZhbHVlc1wiLFxuICAgIHBpY2tMaXN0OiBcInBpY2stbGlzdFwiLFxuICAgIHVuaXF1ZVZhbHVlc0NvbnRlbnRMaXN0TXNnOiBcInVuaXF1ZS12YWx1ZXMtY29udGVudC1saXN0LW1zZ1wiLFxuICAgIGluVGhlTGFzdDogXCJpbi10aGUtbGFzdFwiLFxuICAgIGluVGhlTGFzdENvdW50OiBcImluLXRoZS1sYXN0LWNvdW50XCIsXG4gICAgaW5UaGVMYXN0VW5pdDogXCJpbi10aGUtbGFzdC11bml0XCIsXG4gICAgZGF0ZVBpY2tlcjogXCJkYXRlLXBpY2tlclwiLFxuICAgIGhpc3RvZ3JhbUNvbnRlbnQ6IFwiaGlzdG9ncmFtLWNvbnRlbnRcIixcbiAgICBoaXN0b2dyYW1Db250ZW50U2xpbTogXCJoaXN0b2dyYW0tY29udGVudC1zbGltXCIsXG4gICAgc21hbGxMb2FkZXI6IFwic21hbGwtbG9hZGVyXCJcbn07XG5cbmNvbnN0IGFyY2dpc0ZpbHRlckNvbmRpdGlvbkNzcyA9IFwiLmZpbHRlci1jb25kaXRpb24uc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257cGFkZGluZzowIDZweH0ub3BlcmF0b3ItZHJvcGRvd24uc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257d2lkdGg6MTAwJTttYXJnaW46NXB4IDB9LmlucHV0LXBsdXMtdW5pcXVlLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7d2lkdGg6MTAwJX0uaW5wdXQuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257d2lkdGg6MTAwJX0uYmxhbmstYnV0dG9uLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2hlaWdodDoyMnB4O2JvcmRlcjp2YXIoLS1jYWxjaXRlLWNvbG9yLWJvcmRlci1pbnB1dCkgMXB4IHNvbGlkfS5ibGFuay1idXR0b24uYWN0aXZlLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2N1cnNvcjpwb2ludGVyfS5ibGFuay1idXR0b24uaW5hY3RpdmUuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb246Zm9jdXN7b3V0bGluZTpub25lfS5zZWxlY3QtdW5pcXVlLWJ1dHRvbi5zYy1hcmNnaXMtZmlsdGVyLWNvbmRpdGlvbntoZWlnaHQ6MzJweDtib3JkZXItdG9wOnZhcigtLWNhbGNpdGUtY29sb3ItYm9yZGVyLWlucHV0KSAxcHggc29saWQ7Ym9yZGVyLWJvdHRvbTp2YXIoLS1jYWxjaXRlLWNvbG9yLWJvcmRlci1pbnB1dCkgMXB4IHNvbGlkO2JvcmRlci1yaWdodDp2YXIoLS1jYWxjaXRlLWNvbG9yLWJvcmRlci1pbnB1dCkgMXB4IHNvbGlkfS5hcmNnaXMtLXJ0bC5zYy1hcmNnaXMtZmlsdGVyLWNvbmRpdGlvbiAuc2VsZWN0LXVuaXF1ZS1idXR0b24uc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257Ym9yZGVyLXJpZ2h0Om5vbmU7Ym9yZGVyLWxlZnQ6dmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItaW5wdXQpIDFweCBzb2xpZH0uYmV0d2Vlbi12YWx1ZXMtaW5wdXQuZmlyc3Quc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257bWFyZ2luLWJvdHRvbTo1cHh9LnNlbGVjdC12YWx1ZXMuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257bWFyZ2luLWJvdHRvbTo0cHh9LnBpY2stbGlzdC5zYy1hcmNnaXMtZmlsdGVyLWNvbmRpdGlvbnttYXgtaGVpZ2h0OjIwMHB4O292ZXJmbG93LXk6YXV0b30udW5pcXVlLXZhbHVlcy1jb250ZW50LWxpc3QtbXNnLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2ZvbnQtc2l6ZTo5MCU7bWFyZ2luLXRvcDo1cHg7bWFyZ2luLWJvdHRvbTo1cHh9LmluLXRoZS1sYXN0LnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2Rpc3BsYXk6ZmxleH0uaW4tdGhlLWxhc3QtY291bnQuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257d2lkdGg6NTAlfS5pbi10aGUtbGFzdC11bml0LnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue3dpZHRoOjUwJX0uZGF0ZS1waWNrZXIuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257d2lkdGg6MTAwJX0uZGF0ZS1waWNrZXIuZmlyc3Quc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257bWFyZ2luLWJvdHRvbTo1cHh9Lmhpc3RvZ3JhbS1jb250ZW50LnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2hlaWdodDoxMjBweDttYXJnaW4tdG9wOjVweH0uaGlzdG9ncmFtLWNvbnRlbnQtc2xpbS5zYy1hcmNnaXMtZmlsdGVyLWNvbmRpdGlvbntoZWlnaHQ6NDBweDttYXJnaW4tdG9wOjVweH0uc21hbGwtbG9hZGVyLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue21hcmdpbi1sZWZ0OmNhbGMoKDEwMCUgLSAxNnB4KSAvIDIpO21hcmdpbi10b3A6MTBweH1odG1sW2Rpcj1ydGxdLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9uIC5zbWFsbC1sb2FkZXIuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6OHB4fVwiO1xuXG5jb25zdCBBcmNnaXNGaWx0ZXJDb25kaXRpb24gPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlckNvbmRpdGlvbkNoYW5nZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlckNvbmRpdGlvbkNoYW5nZWRcIiwgNyk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUZpbHRlclBhbmVsID0gY3JlYXRlRXZlbnQodGhpcywgXCJkaXNhYmxlRmlsdGVyUGFuZWxcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyVW5pcXVlVmFsdWVzUmV0dXJuZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlclVuaXF1ZVZhbHVlc1JldHVybmVkXCIsIDcpO1xuICAgICAgICB0aGlzLmhpc3RvZ3JhbVNsaWRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hZnRlckNyZWF0ZVNsaWRlckRpdiA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGZpZWxkTmFtZSwgcHJvcHMsIGhpc3RvZ3JhbVNsaWRlciB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBzdXJlIHdoeSB0aGF0IGhhcHBlbnNcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWhpc3RvZ3JhbVNsaWRlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpdk5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZGl2Tm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoaXN0b2dyYW1TbGlkZXIuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpc3RvZ3JhbVNsaWRlci5jb250YWluZXIgPSBkaXZOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZWNyZWF0ZSB0aGUgc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckZpZWxkID0gZ2V0RmllbGRJbmZvKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlckZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBiaW5zLCBhdmVyYWdlLCBtaW4sIG1heCwgdmFsdWVzLCBwcmVjaXNpb24sIHJhbmdlVHlwZSB9ID0gaGlzdG9ncmFtU2xpZGVyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGRpdk5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXZlcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RhbmRhcmREZXZpYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFtzaW1wbGVGaWVsZFR5cGVzLkRBVEUsIHNpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5pbmRleE9mKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkgPlxuICAgICAgICAgICAgICAgICAgICAgICAgLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5oYXNUaW1lRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERhdGVGb3JtYXRGdW5jdGlvbnMoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicmUtY3JlYXRlIEhpc3RvZ3JhbVJhbmdlU2xpZGVyXCIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIGhpc3RvZ3JhbVNsaWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9ncmFtU2xpZGVyID0gbmV3IHRoaXMuSGlzdG9ncmFtUmFuZ2VTbGlkZXIoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTbGlkZXJDaGFuZ2VFdmVudHMoZmlsdGVyRmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRmllbGRTZWxlY3QgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub3BlbkZpZWxkUGlja0xpc3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbk9wZXJhdG9yU2VsZWN0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBmaWVsZE5hbWUsIG9wZXJhdG9yLCB2YWx1ZSwgdmFsdWUyIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgbmV3T3BlcmF0b3IgPSBzZWxlY3Quc2VsZWN0ZWRPcHRpb24udmFsdWU7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZEluVGhlTGFzdCA9IGlzSW5UaGVMYXN0T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luVGhlTGFzdCA9IGlzSW5UaGVMYXN0T3BlcmF0b3IocHJvcHMsIG5ld09wZXJhdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG9uZUluVGhlTGFzdCA9IG9sZEluVGhlTGFzdCB8fCBuZXdJblRoZUxhc3Q7XG4gICAgICAgICAgICBjb25zdCBib3RoSW5UaGVMYXN0ID0gb2xkSW5UaGVMYXN0ICYmIG5ld0luVGhlTGFzdDtcbiAgICAgICAgICAgIGNvbnN0IG9sZEJldHdlZW4gPSBpc0JldHdlZW5PcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpO1xuICAgICAgICAgICAgY29uc3QgbmV3QmV0d2VlbiA9IGlzQmV0d2Vlbk9wZXJhdG9yKHByb3BzLCBuZXdPcGVyYXRvcik7XG4gICAgICAgICAgICBjb25zdCBib3RoQmV0d2VlbiA9IG9sZEJldHdlZW4gJiYgbmV3QmV0d2VlbjtcbiAgICAgICAgICAgIC8vY29uc3Qgb2xkSW5FeGNsdWRlID0gaXNJbmNsdWRlc09wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikgfHwgaXNFeGNsdWRlc09wZXJhdG9yKHByb3BzLCBvcGVyYXRvcik7XG4gICAgICAgICAgICAvL2NvbnN0IG5ld0luRXhjbHVkZSA9XG4gICAgICAgICAgICAvLyAgaXNJbmNsdWRlc09wZXJhdG9yKHByb3BzLCBuZXdPcGVyYXRvcikgfHwgaXNFeGNsdWRlc09wZXJhdG9yKHByb3BzLCBuZXdPcGVyYXRvcik7XG4gICAgICAgICAgICAvL2NvbnN0IGJvdGhJbkV4Y2x1ZGUgPSBvbGRJbkV4Y2x1ZGUgJiYgbmV3SW5FeGNsdWRlO1xuICAgICAgICAgICAgY29uc3Qgb2xkID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICBvcGVyYXRvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPVxuICAgICAgICAgICAgICAgIG9uZUluVGhlTGFzdCAmJiAhYm90aEluVGhlTGFzdFxuICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiBmaWx0ZXJGaWVsZC5zdGF0aXN0aWNzICYmICFpc0RlZmluZWQodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGZpbHRlckZpZWxkLnN0YXRpc3RpY3MuYXZnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZTIgPSBuZXdCZXR3ZWVuXG4gICAgICAgICAgICAgICAgPyB2YWx1ZTIgIT09IG51bGwgJiYgdmFsdWUyICE9PSB2b2lkIDAgPyB2YWx1ZTIgOiAoaXNJbnRlZ2VyVHlwZShmaWx0ZXJGaWVsZClcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLnJvdW5kKChfYSA9IGZpbHRlckZpZWxkLnN0YXRpc3RpY3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXgpXG4gICAgICAgICAgICAgICAgICAgIDogKF9iID0gZmlsdGVyRmllbGQuc3RhdGlzdGljcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heClcbiAgICAgICAgICAgICAgICA6IG9uZUluVGhlTGFzdCB8fCAhYm90aEJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdmFsdWUyO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG5ld09wZXJhdG9yO1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IHRoaXMuY2hlY2tEZWZhdWx0VmFsdWVzKGZpbHRlckZpZWxkKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IChfYyA9IHRoaXMudmFsdWUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRWYWx1ZXMudmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWUyOiAoX2QgPSB0aGlzLnZhbHVlMikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKG5ld0JldHdlZW4gPyBkZWZhdWx0VmFsdWVzLnZhbHVlMiA6IG51bGwpLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB0aGlzLm9wZXJhdG9yXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gc2V0IGl0IGJhY2sgLSBUT0RPLCBuZWVkIHRvIGZpbmQgYSBiZXR0ZXIgd2F5IGFmdGVyIDkuMVxuICAgICAgICAgICAgLy8gaWYgSSBtb2RpZnkgbG9jYWwgcHJvcHMgdGhlIGNvbXBvbmVudCB3b24ndCByZS1yZW5kZXIgd2l0aCBlbWl0Q2hhbmdlRXZlbnQoKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9sZC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUyID0gb2xkLnZhbHVlMjtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvbGQub3BlcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmVtaXRDaGFuZ2VFdmVudCh1cGRhdGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlTWF5YmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIG9wZXJhdG9yLCB2YWx1ZTIgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuZ2V0TmV3VmFsdWUoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChuZXdWYWx1ZSkgJiYgaXNCZXR3ZWVuT3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSAmJiBuZXdWYWx1ZSA+PSB2YWx1ZTIpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhc3N1bWUgdGhlIHVzZXIgaXMgaW4gdGhlIG1pZGRsZSBvZiB0eXBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UoZXZlbnQsIG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlID0gKGV2ZW50LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgZmllbGROYW1lLCBvcGVyYXRvciwgdmFsdWUsIHZhbHVlMiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgdmlldyB9ID0gcHJvcHM7XG4gICAgICAgICAgICBjb25zdCB0aW1lWm9uZSA9ICh2aWV3ID09PSBudWxsIHx8IHZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXcudGltZVpvbmUpIHx8IFwic3lzdGVtXCI7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBldmVudCA/IHRoaXMuZ2V0TmV3VmFsdWUoZXZlbnQpIDogbmV3VmFsdWU7XG4gICAgICAgICAgICBpZiAoIWlzRGVmaW5lZChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGhhdmUgYSB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBkZWZhdWx0IHZhbHVlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSBnZXREZWZhdWx0VmFsdWVzKHByb3BzLCBmaWx0ZXJGaWVsZCwgb3BlcmF0b3IpO1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gZGVmYXVsdFZhbHVlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLkRBVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSB1dGNUb0RhdGVQaWNrZXIobmV3VmFsdWUsIHRpbWVab25lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKG5ld1ZhbHVlKSAmJiBpc0JldHdlZW5PcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpICYmIG5ld1ZhbHVlID49IHZhbHVlMikge1xuICAgICAgICAgICAgICAgIC8vIHVzZXIgZmluaXNoZWQgdHlwaW5nLCBsZXQncyBmaXggdGhlIHZhbHVlc1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuREFURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHV0Y1RvRGF0ZVBpY2tlcihuZXdWYWx1ZSwgdGltZVpvbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZEYXkgPSBuZXcgRGF0ZShuZXcgRGF0ZSh2YWx1ZTIpLmdldFRpbWUoKSAtIDg2NDAwMDAwICsgbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBgJHtwcmV2RGF5LmdldEZ1bGxZZWFyKCl9LSR7cHJldkRheS5nZXRNb250aCgpIDwgOSA/IFwiMFwiIDogXCJcIn0ke3ByZXZEYXkuZ2V0TW9udGgoKSArIDF9LSR7cHJldkRheS5nZXREYXRlKCkgPCAxMCA/IFwiMFwiIDogXCJcIn0ke3ByZXZEYXkuZ2V0RGF0ZSgpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlMiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50YWdOYW1lKSA9PT0gXCJDQUxDSVRFLUlOUFVULURBVEUtUElDS0VSXCIgfHxcbiAgICAgICAgICAgICAgICAoKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50YWdOYW1lKSA9PT0gXCJDQUxDSVRFLUlOUFVUXCIgJiYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50eXBlKSA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdEhpc3RvZ3JhbU1pbk1heChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyhuZXdWYWx1ZSwgdmFsdWUyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblZhbHVlMkNoYW5nZU1heWJlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBvcGVyYXRvciwgdmFsdWUgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuZ2V0TmV3VmFsdWUoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChuZXdWYWx1ZSkgJiYgaXNCZXR3ZWVuT3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSAmJiBuZXdWYWx1ZSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFzc3VtZSB0aGUgdXNlciBpcyBpbiB0aGUgbWlkZGxlIG9mIHR5cGluZ1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25WYWx1ZTJDaGFuZ2UoZXZlbnQsIG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblZhbHVlMkNoYW5nZSA9IChldmVudCwgbmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIHByb3BzLCBmaWVsZE5hbWUsIG9wZXJhdG9yIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyB2aWV3IH0gPSBwcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHRpbWVab25lID0gKHZpZXcgPT09IG51bGwgfHwgdmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlldy50aW1lWm9uZSkgfHwgXCJzeXN0ZW1cIjtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckZpZWxkID0gZ2V0RmllbGRJbmZvKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUgIT09IG51bGwgJiYgbmV3VmFsdWUgIT09IHZvaWQgMCA/IG5ld1ZhbHVlIDogdGhpcy5nZXROZXdWYWx1ZShldmVudCk7XG4gICAgICAgICAgICBpZiAoIWlzRGVmaW5lZChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGhhdmUgYSB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBkZWZhdWx0IHZhbHVlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSBnZXREZWZhdWx0VmFsdWVzKHByb3BzLCBmaWx0ZXJGaWVsZCwgb3BlcmF0b3IpO1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gZGVmYXVsdFZhbHVlcy52YWx1ZTI7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5EQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSB1dGNUb0RhdGVQaWNrZXIobmV3VmFsdWUsIHRpbWVab25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSdyZSB1c2luZyBiZXR3ZWVuIG9wZXJhdG9yXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPD0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2VyIGZpbmlzaGVkIHR5cGluZywgbGV0J3MgZml4IHRoZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLkRBVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSB1dGNUb0RhdGVQaWNrZXIobmV3VmFsdWUsIHRpbWVab25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF5ID0gbmV3IERhdGUobmV3IERhdGUodmFsdWUpLmdldFRpbWUoKSArIDg2NDAwMDAwICsgbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApO1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGAke25leHREYXkuZ2V0RnVsbFllYXIoKX0tJHtuZXh0RGF5LmdldE1vbnRoKCkgPCA5ID8gXCIwXCIgOiBcIlwifSR7bmV4dERheS5nZXRNb250aCgpICsgMX0tJHtuZXh0RGF5LmdldERhdGUoKSA8IDEwID8gXCIwXCIgOiBcIlwifSR7bmV4dERheS5nZXREYXRlKCl9YDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSBcIkNBTENJVEUtSU5QVVQtREFURS1QSUNLRVJcIiB8fFxuICAgICAgICAgICAgICAgIChub2RlLnRhZ05hbWUgPT09IFwiQ0FMQ0lURS1JTlBVVFwiICYmIG5vZGUudHlwZSA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdEhpc3RvZ3JhbU1pbk1heChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyh2YWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uVW5pdFNlbGVjdCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgLy90aGlzLnVuaXQgPSBzZWxlY3Quc2VsZWN0ZWRPcHRpb24udmFsdWUgYXMgdGltZVVuaXRzO1xuICAgICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoeyB1bml0OiBzZWxlY3Quc2VsZWN0ZWRPcHRpb24udmFsdWUgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25TZWxlY3RVbmlxdWVWYWx1ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3RVbmlxdWUoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2VsZWN0VW5pcXVlVmFsdWVzID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgZmllbGROYW1lLCBvcGVyYXRvciB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckZpZWxkID0gZ2V0RmllbGRJbmZvKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgZmllbGREb21haW5zID0gaGFzRmllbGREb21haW5zKGZpbHRlckZpZWxkKTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RPcGVyYXRvciA9IGlzTGlzdE9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcik7XG4gICAgICAgICAgICBjb25zdCBpc0RvbWFpblNpbmdsZSA9IGZpZWxkRG9tYWlucyAmJiAhbGlzdE9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5vblNlbGVjdFVuaXF1ZSghaXNEb21haW5TaW5nbGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRG9jdW1lbnRDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgaXNUYXJnZXRJbnNpZGVQb3BvdmVyID0gdGFyZ2V0LmNsb3Nlc3QoYCNhcmNnaXMtZmlsdGVyLXVuaXF1ZS1wb3BvdmVyXyR7dGhpcy51aWR9YCk7XG4gICAgICAgICAgICBpZiAoIWlzVGFyZ2V0SW5zaWRlUG9wb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVW5pcXVlUG9wb3ZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUmVtb3ZlU2VsZWN0ZWRWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZXMsIGVzcmlMYW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gdmFsdWVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgdmFsdWVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgLy90aGlzLnZhbHVlcyA9IHZhbHVlcy5sZW5ndGggPyBlc3JpTGFuZy5jbG9uZSh2YWx1ZXMpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoeyB2YWx1ZXM6IHZhbHVlcy5sZW5ndGggPyBlc3JpTGFuZy5jbG9uZSh2YWx1ZXMpIDogbnVsbCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZnRlckNyZWF0ZUxpc3QgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxFeHBySW50b1ZpZXcoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25IaXN0b2dyYW1CbG9ja1RvZ2dsZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQub3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMub25IaXN0b2dyYW1PcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGlzdG9ncmFtQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maWVsZFBpY2tMaXN0Q2hhbmdlcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRGaWVsZCA9IChfYiA9IChfYSA9IGV2ZW50LmRldGFpbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbGVjdGVkRmllbGRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF07XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZpZWxkc1BpY2tMaXN0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRGaWVsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJGaWVsZFNlbGVjdChzZWxlY3RlZEZpZWxkKTtcbiAgICAgICAgICAgIH0gLy8gZWxzZSB1c2VyIGhpdCBjYW5jZWwgb3IgY2xvc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy51aWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZmllbGROYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnVuaXF1ZVZhbHVlc1NvcnRCeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy52YWx1ZTIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnVuaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGlzdG9ncmFtT3BlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oYXNGb2N1cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbnZhbGlkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVSZW5kZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgYXJjZ2lzRmlsdGVyVW5pcXVlVmFsdWVzUmV0dXJuZWRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgaWYgKHRoaXMuZmllbGROYW1lID09PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEZWZhdWx0VmFsdWVzKGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHRoaXMucHJvcHMpKTtcbiAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcmNnaXNGaWx0ZXJVbmlxdWVMaXN0Q2hhbmdlZEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IHVpZCA9IGRldGFpbC51aWQ7XG4gICAgICAgIGlmICh1aWQgPT09IHRoaXMudWlkKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFZhbHVlcyA9IGRldGFpbC5zZWxlY3RlZFZhbHVlcztcbiAgICAgICAgICAgIGlmICghZGV0YWlsLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlxdWVWYWx1ZXNTb3J0QnkgPSBkZXRhaWwuc29ydEJ5O1xuICAgICAgICAgICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZShudWxsLCAoc2VsZWN0ZWRWYWx1ZXMgPT09IG51bGwgfHwgc2VsZWN0ZWRWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGVkVmFsdWVzLmxlbmd0aCkgPyBzZWxlY3RlZFZhbHVlc1swXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVVbmlxdWVQb3BvdmVyKCk7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy51bmlxdWVBY3Rpb25Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdENoYW5nZUV2ZW50KHsgdmFsdWVzOiBzZWxlY3RlZFZhbHVlcywgdW5pcXVlVmFsdWVzU29ydEJ5OiBkZXRhaWwuc29ydEJ5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFyY2dpc0ZpbHRlclVuaXF1ZUxpc3RTb3J0QnlDaGFuZ2VkKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICAgICAgY29uc3QgdWlkID0gZGV0YWlsLnVpZDtcbiAgICAgICAgaWYgKHVpZCA9PT0gdGhpcy51aWQpIHtcbiAgICAgICAgICAgIHRoaXMudW5pcXVlVmFsdWVzU29ydEJ5ID0gZGV0YWlsLnNvcnRCeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcmNnaXNGaWx0ZXJVbmlxdWVMaXN0RG9uZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgICAgIGlmIChkZXRhaWwgPT09IHRoaXMudWlkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVVuaXF1ZVBvcG92ZXIoKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudW5pcXVlQWN0aW9uTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsY2l0ZVBvcG92ZXJDbG9zZUhhbmRsZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMudW5pcXVlUG9wb3Zlck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVW5pcXVlUG9wb3ZlcigpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy51bmlxdWVBY3Rpb25Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTtcbiAgICAgICAgfSAvLyBlbHNlIHNvbWV0aGluZyBlbHNlIHJlbW92ZWQgdGhlIHBvcG92ZXJcbiAgICB9XG4gICAgY2xvc2VGaWx0ZXJQb3BvdmVyc0hhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRmllbGRzUGlja0xpc3QoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVVbmlxdWVQb3BvdmVyKCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEZpZWxkID0gZ2V0RGVmYXVsdEZpZWxkKHtcbiAgICAgICAgICAgIGZpZWxkczogdGhpcy5wcm9wcy5maWVsZHNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmllbGROYW1lID0gdGhpcy5maWVsZE5hbWUgfHwgZGVmYXVsdEZpZWxkLmxheWVyRmllbGQubmFtZTtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IHRoaXMub3BlcmF0b3IgfHwgZ2V0RGVmYXVsdE9wZXJhdG9yKHRoaXMucHJvcHMsIGRlZmF1bHRGaWVsZCk7XG4gICAgICAgIHRoaXMuaGFzRm9jdXMgPSAhIXRoaXMuaGFzRm9jdXM7XG4gICAgICAgIGNvbnN0IFtlc3JpTGFuZywgaW50bCwgXG4gICAgICAgIC8vc21hcnRNYXBwaW5nVXRpbHMsXG4gICAgICAgIHN1bW1hcnlTdGF0aXN0aWNzLCBoaXN0b2dyYW0sIHVuaXF1ZVZhbHVlcywgSGlzdG9ncmFtUmFuZ2VTbGlkZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgICAgICAgICAgXCJlc3JpL2NvcmUvbGFuZ1wiLFxuICAgICAgICAgICAgXCJlc3JpL2ludGxcIixcbiAgICAgICAgICAgIC8vXCJlc3JpL3dpZGdldHMvc21hcnRNYXBwaW5nL3N1cHBvcnQvdXRpbHNcIixcbiAgICAgICAgICAgIFwiZXNyaS9zbWFydE1hcHBpbmcvc3RhdGlzdGljcy9zdW1tYXJ5U3RhdGlzdGljc1wiLFxuICAgICAgICAgICAgXCJlc3JpL3NtYXJ0TWFwcGluZy9zdGF0aXN0aWNzL2hpc3RvZ3JhbVwiLFxuICAgICAgICAgICAgXCJlc3JpL3NtYXJ0TWFwcGluZy9zdGF0aXN0aWNzL3VuaXF1ZVZhbHVlc1wiLFxuICAgICAgICAgICAgXCJlc3JpL3dpZGdldHMvSGlzdG9ncmFtUmFuZ2VTbGlkZXJcIlxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5lc3JpTGFuZyA9IGVzcmlMYW5nO1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICAvL3RoaXMuc21hcnRNYXBwaW5nVXRpbHMgPSBzbWFydE1hcHBpbmdVdGlscztcbiAgICAgICAgdGhpcy5zdW1tYXJ5U3RhdGlzdGljcyA9IHN1bW1hcnlTdGF0aXN0aWNzO1xuICAgICAgICB0aGlzLmhpc3RvZ3JhbSA9IGhpc3RvZ3JhbTtcbiAgICAgICAgdGhpcy51bmlxdWVWYWx1ZXMgPSB1bmlxdWVWYWx1ZXM7XG4gICAgICAgIHRoaXMuSGlzdG9ncmFtUmFuZ2VTbGlkZXIgPSBIaXN0b2dyYW1SYW5nZVNsaWRlcjtcbiAgICAgICAgdGhpcy5vbkRvY3VtZW50Q2xpY2tCaW5kID0gdGhpcy5vbkRvY3VtZW50Q2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgdGhpcy5zZXRGb2N1cygpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGaWVsZHNQaWNrTGlzdCgpO1xuICAgICAgICB0aGlzLnJlbW92ZVVuaXF1ZVBvcG92ZXIoKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBSZW5kZXIgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICAgICAgLyogY29uc29sZS5sb2coXG4gICAgICAgICAgXCIqKiByZW5kZXIgY29uZGl0aW9uICoqXCIsXG4gICAgICAgICAgXCJ1aWRcIixcbiAgICAgICAgICB0aGlzLnVpZCxcbiAgICAgICAgICBcImZpZWxkTmFtZVwiLFxuICAgICAgICAgIHRoaXMuZmllbGROYW1lLFxuICAgICAgICAgIFwib3BlcmF0b3JcIixcbiAgICAgICAgICB0aGlzLm9wZXJhdG9yLFxuICAgICAgICAgIFwidW5pcXVlVmFsdWVzU29ydEJ5XCIsXG4gICAgICAgICAgdGhpcy51bmlxdWVWYWx1ZXNTb3J0QnksXG4gICAgICAgICAgXCJ2YWx1ZVwiLFxuICAgICAgICAgIHRoaXMudmFsdWUsXG4gICAgICAgICAgXCJ2YWx1ZTJcIixcbiAgICAgICAgICB0aGlzLnZhbHVlMixcbiAgICAgICAgICBcInZhbHVlc1wiLFxuICAgICAgICAgIHRoaXMudmFsdWVzLFxuICAgICAgICAgIFwidW5pdFwiLFxuICAgICAgICAgIHRoaXMudW5pdCxcbiAgICAgICAgICBcImhpc3RvZ3JhbU9wZW5cIixcbiAgICAgICAgICB0aGlzLmhpc3RvZ3JhbU9wZW4sXG4gICAgICAgICAgXCJoYXNGb2N1c1wiLFxuICAgICAgICAgIHRoaXMuaGFzRm9jdXMsXG4gICAgICAgICAgXCJoaXN0b2dyYW1TdGF0dXNcIixcbiAgICAgICAgICBmaWx0ZXJGaWVsZC5oaXN0b2dyYW1TdGF0dXMsXG4gICAgICAgICAgXCJ1bmlxdWVWYWx1ZXNTdGF0dXNcIixcbiAgICAgICAgICBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZXNTdGF0dXMsXG4gICAgICAgICAgXCJyZVJlbmRlclwiLFxuICAgICAgICAgIHRoaXMucmVSZW5kZXJcbiAgICAgICAgKTsgKi9cbiAgICAgICAgaWYgKCFmaWx0ZXJGaWVsZCB8fCAhZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImRpdlwiLCBudWxsKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCB7IGRpcjogZGlyIH0sIGgoXCJkaXZcIiwgeyBjbGFzczoge1xuICAgICAgICAgICAgICAgIFtDU1MkMi5jb25kaXRpb25dOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBkaXIgPT09IFwicnRsXCJcbiAgICAgICAgICAgIH0gfSwgdGhpcy5yZW5kZXJGaWVsZFNlbGVjdGlvbigpLCB0aGlzLnJlbmRlck9wZXJhdG9yU2VsZWN0aW9uKGZpbHRlckZpZWxkKSwgdGhpcy5yZW5kZXJWYWx1ZUlucHV0KGZpbHRlckZpZWxkKSwgdGhpcy5yZW5kZXJIaXN0b2dyYW0oZmlsdGVyRmllbGQpKSkpO1xuICAgIH1cbiAgICByZW5kZXJGaWVsZFNlbGVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBoYXNGb2N1cywgZmllbGROYW1lLCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBmaWVsZHMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcIm91dGxpbmUtZmlsbFwiLCBraW5kOiBcIm5ldXRyYWxcIiwgd2lkdGg6IFwiZnVsbFwiLCBzY2FsZTogXCJtXCIsIGFsaWdubWVudDogXCJpY29uLWVuZC1zcGFjZS1iZXR3ZWVuXCIsIGRpc2FibGVkOiBmaWVsZHMubGVuZ3RoIDw9IDEsIGljb25FbmQ6IFwiY2hldnJvbi1kb3duXCIsIGNsYXNzOiBgJHtoYXNGb2N1cyA/IFwiYXV0b2ZvY3VzXCIgOiBcIlwifWAsIG9uQ2xpY2s6IGZpZWxkcy5sZW5ndGggPiAxID8gdGhpcy5vbkZpZWxkU2VsZWN0IDogbnVsbCwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZmllbGROb2RlID0gbm9kZSkgfSwgKGZpZWxkID09PSBudWxsIHx8IGZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZC5sYWJlbCkgfHwgXCJcIikpO1xuICAgIH1cbiAgICByZW5kZXJPcGVyYXRvclNlbGVjdGlvbihmaWx0ZXJGaWVsZCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG9wZXJhdG9ycywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIC8vIFRPRE8gLSBhbHNvIGNoZWNrIGZpZWxkIHZhbHVlIHR5cGUgP1xuICAgICAgICBsZXQgdHlwZSA9IGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5HVUlEKSB7XG4gICAgICAgICAgICB0eXBlID0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuT0lEKSB7XG4gICAgICAgICAgICB0eXBlID0gc2ltcGxlRmllbGRUeXBlcy5OVU1CRVI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0ZpZWxkRG9tYWlucyhmaWx0ZXJGaWVsZCkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBzaW1wbGVGaWVsZFR5cGVzLkRPTUFJTjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25Ob2RlcyA9IG9wZXJhdG9yc1t0eXBlXS5tYXAoKG9wZXJhdG9yKSA9PiB0aGlzLnJlbmRlck9wZXJhdG9yT3B0aW9uKG9wZXJhdG9yLm5hbWUpKTtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1zZWxlY3RcIiwgeyB3aWR0aDogXCJmdWxsXCIsIHNjYWxlOiBcIm1cIiwgbGFiZWw6IHN0cmluZ3MuYWNjZXNzaWJpbGl0eS5vcGVyYXRvciwgY2xhc3M6IENTUyQyLm9wZXJhdG9yRHJvcGRvd24sIG9uQ2FsY2l0ZVNlbGVjdENoYW5nZTogdGhpcy5vbk9wZXJhdG9yU2VsZWN0IH0sIG9wdGlvbk5vZGVzKSk7XG4gICAgfVxuICAgIHJlbmRlck9wZXJhdG9yT3B0aW9uKHJlbmRlcmVyT3BlcmF0b3IpIHtcbiAgICAgICAgY29uc3QgeyBvcGVyYXRvciB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1vcHRpb25cIiwgeyB2YWx1ZTogcmVuZGVyZXJPcGVyYXRvciwgbGFiZWw6IHJlbmRlcmVyT3BlcmF0b3IsIHNlbGVjdGVkOiByZW5kZXJlck9wZXJhdG9yID09PSBvcGVyYXRvciB9KSk7XG4gICAgfVxuICAgIHJlbmRlclZhbHVlSW5wdXQoZmlsdGVyRmllbGQpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgb3BlcmF0b3IsIGludmFsaWRWYWx1ZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gaW52YWxpZFZhbHVlID8gXCJpbnZhbGlkXCIgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb250ZW50Tm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChpc0JsYW5rT3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSB8fCBpc0VtcHR5T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgY29udGVudE5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTGlzdE9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgIGNvbnRlbnROb2RlID0gdGhpcy5yZW5kZXJVbmlxdWVWYWx1ZXMoZmlsdGVyRmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSW5UaGVMYXN0T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgY29udGVudE5vZGUgPSB0aGlzLnJlbmRlckluVGhlTGFzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkcgfHxcbiAgICAgICAgICAgIGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5HVUlEIHx8XG4gICAgICAgICAgICBoYXNGaWVsZERvbWFpbnMoZmlsdGVyRmllbGQpKSB7XG4gICAgICAgICAgICBjb250ZW50Tm9kZSA9IHRoaXMucmVuZGVyVmFsdWVJbnB1dFN0cmluZyhmaWx0ZXJGaWVsZCwgeyBzdGF0dXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUikge1xuICAgICAgICAgICAgY29udGVudE5vZGUgPSB0aGlzLnJlbmRlclZhbHVlSW5wdXROdW1iZXIoZmlsdGVyRmllbGQsIHsgc3RhdHVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFtzaW1wbGVGaWVsZFR5cGVzLkRBVEUsIHNpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5pbmRleE9mKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgY29udGVudE5vZGUgPSB0aGlzLnJlbmRlclZhbHVlSW5wdXREYXRlKGZpbHRlckZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuT0lEKSB7XG4gICAgICAgICAgICBjb250ZW50Tm9kZSA9IHRoaXMucmVuZGVyVmFsdWVJbnB1dE9pZChmaWx0ZXJGaWVsZCwgeyBzdGF0dXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludmFsaWRWYWx1ZSA/IChoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBjb250ZW50Tm9kZSwgaChcImNhbGNpdGUtaW5wdXQtbWVzc2FnZVwiLCB7IGljb246IHRydWUsIHN0YXR1czogc3RhdHVzIH0sIGludmFsaWRWYWx1ZSkpKSA6IChjb250ZW50Tm9kZSk7XG4gICAgfVxuICAgIHJlbmRlclVuaXF1ZUJ1dHRvbihzdXBwb3J0c1VuaXF1ZSwgZGlzYWJsZWQsIGxvYWRpbmcpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGlmICghc3VwcG9ydHNVbmlxdWUgfHwgbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgfHwgbGF5ZXIudHlwZSA9PT0gXCJzdWJ0eXBlLWdyb3VwXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgY2xhc3M6IENTUyQyLnNlbGVjdFVuaXF1ZUJ1dHRvbiwgZGlzYWJsZWQ6IGRpc2FibGVkLCBsb2FkaW5nOiAhIWxvYWRpbmcsIHRleHQ6IHN0cmluZ3MuY2hvb3NlRnJvbVVuaXF1ZSwgc2NhbGU6IFwic1wiLCBpY29uOiBcImNoZXZyb24tZG93blwiLCBvbkNsaWNrOiAhZGlzYWJsZWQgPyB0aGlzLm9uU2VsZWN0VW5pcXVlVmFsdWUgOiBudWxsLCByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmlxdWVBY3Rpb25Ob2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IC8vIGVsc2Ugbm8gaWRlYSB3aHkgdGhpcyBoYXBwZW5zIC0gVE9ETyAoc2V0IG9mIDMgKyAxIGV4cHIpXG4gICAgICAgICAgICB9IH0pKTtcbiAgICB9XG4gICAgcmVuZGVyVmFsdWVJbnB1dFN0cmluZyhmaWx0ZXJGaWVsZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHZhbHVlLCBvcGVyYXRvciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgdXZTdGF0dXMgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZXNTdGF0dXM7XG4gICAgICAgIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlSW5mb3M7XG4gICAgICAgIGNvbnN0IHN1cHBvcnRzVW5pcXVlID0gW3N0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXMsIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RdLmluZGV4T2Yob3BlcmF0b3IpID4gLTE7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkVW5pcXVlID0gc3VwcG9ydHNVbmlxdWUgJiZcbiAgICAgICAgICAgICh1dlN0YXR1cyA9PT0gc3RhdHVzLkZBSUxFRCB8fCAodXZTdGF0dXMgPT09IHN0YXR1cy5TVUNDRVNTICYmICEodW5pcXVlVmFsdWVzID09PSBudWxsIHx8IHVuaXF1ZVZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5pcXVlVmFsdWVzLmxlbmd0aCkpKTtcbiAgICAgICAgY29uc3QgaGFzRG9tYWlucyA9IGhhc0ZpZWxkRG9tYWlucyhmaWx0ZXJGaWVsZCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IGhhc0RvbWFpbnMgPyBnZXREZWNvZGVkVmFsdWUodmFsdWUsIGZpbHRlckZpZWxkKSA6IHZhbHVlO1xuICAgICAgICBjb25zdCBsb2FkaW5nVW5pcXVlID0gdXZTdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HIHx8IHV2U3RhdHVzID09PSBzdGF0dXMuSU5fUFJPR1JFU1M7XG4gICAgICAgIGlmICh1dlN0YXR1cyA9PT0gc3RhdHVzLk1JU1NJTkcpIHtcbiAgICAgICAgICAgIHRoaXMub25EaXNwbGF5VW5pcXVlVmFsdWVzKGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc0RvbWFpbnMgPyAoaXNEZWZpbmVkKHZhbCkgPyAoaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1zdHJpbmdcIiB9LCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBrZXk6IHZhbCwgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwga2luZDogXCJuZXV0cmFsXCIsIHdpZHRoOiBcImZ1bGxcIiwgc2NhbGU6IFwibVwiLCBhbGlnbm1lbnQ6IFwiaWNvbi1lbmQtc3BhY2UtYmV0d2VlblwiLCBpY29uRW5kOiBsb2FkaW5nVW5pcXVlID8gXCJzcGlubmVyXCIgOiBkaXNhYmxlZFVuaXF1ZSA/IHVuZGVmaW5lZCA6IFwiY2hldnJvbi1kb3duXCIsIGRpc2FibGVkOiBkaXNhYmxlZFVuaXF1ZSwgb25DbGljazogIWRpc2FibGVkVW5pcXVlID8gdGhpcy5vblNlbGVjdFVuaXF1ZVZhbHVlIDogdW5kZWZpbmVkLCByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmlxdWVBY3Rpb25Ob2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IC8vIGVsc2Ugbm8gaWRlYSB3aHkgdGhpcyBoYXBwZW5zIC0gVE9ETyAoc2V0IG9mIDMgKyAxIGV4cHIpXG4gICAgICAgICAgICB9IH0sIHZhbCA/IGAke3ZhbH1gIDogYGApKSkgOiAoXG4gICAgICAgIC8vIGNhbGNpdGUtYnV0dG9uIG11c3QgaGF2ZSB0ZXh0IG9yIGljb24sIG90aGVyd2lzZSB3aWR0aCBpcyB0b28gc21hbGwsXG4gICAgICAgIC8vIHNvIHVzZSBhIGRpdiBpbnN0ZWFkXG4gICAgICAgIGgoXCJkaXZcIiwgeyBrZXk6IFwidmFsdWUtaW5wdXQtc3RyaW5nXCIsIGNsYXNzOiBDU1MkMi5pbnB1dFBsdXNVbmlxdWUgfSwgaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1zdHJpbmctYnV0dG9uXCIsIGNsYXNzOiBgJHtDU1MkMi5pbnB1dH0gJHtDU1MkMi5ibGFua0J1dHRvbn0gJHt1dlN0YXR1cyA9PT0gc3RhdHVzLlNVQ0NFU1MgPyBgYWN0aXZlYCA6IGBpbmFjdGl2ZWB9YCwgdGFiSW5kZXg6IC0xLCBvbkNsaWNrOiB1dlN0YXR1cyA9PT0gc3RhdHVzLlNVQ0NFU1MgPyB0aGlzLm9uU2VsZWN0VW5pcXVlVmFsdWUgOiB1bmRlZmluZWQgfSksIHRoaXMucmVuZGVyVW5pcXVlQnV0dG9uKHN1cHBvcnRzVW5pcXVlLCBkaXNhYmxlZFVuaXF1ZSwgbG9hZGluZ1VuaXF1ZSkpKSkgOiAoaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1zdHJpbmdcIiwgY2xhc3M6IENTUyQyLmlucHV0UGx1c1VuaXF1ZSB9LCBoKFwiY2FsY2l0ZS1pbnB1dFwiLCBPYmplY3QuYXNzaWduKHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiB2YWwgPyBgJHt2YWx9YCA6IGBgLCBjbGFzczogQ1NTJDIuaW5wdXQsIHNjYWxlOiBcIm1cIiwgbGFiZWw6IHN0cmluZ3MuYWNjZXNzaWJpbGl0eS52YWx1ZSwgb25DYWxjaXRlSW5wdXRJbnB1dDogdGhpcy5vblZhbHVlQ2hhbmdlIH0sIGlucHV0T3B0aW9ucykpLCB0aGlzLnJlbmRlclVuaXF1ZUJ1dHRvbihzdXBwb3J0c1VuaXF1ZSwgZGlzYWJsZWRVbmlxdWUsIGxvYWRpbmdVbmlxdWUpKSk7XG4gICAgfVxuICAgIHJlbmRlclZhbHVlSW5wdXROdW1iZXIoZmlsdGVyRmllbGQsIGlucHV0T3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHZhbHVlLCB2YWx1ZTIsIG9wZXJhdG9yIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBpc0Zsb2F0ID0gaXNGbG9hdFR5cGUoZmlsdGVyRmllbGQpO1xuICAgICAgICBpZiAoW1xuICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JldHdlZW4sXG4gICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTm90QmV0d2VlblxuICAgICAgICBdLmluZGV4T2Yob3BlcmF0b3IpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCBudWxsLCBoKFwiY2FsY2l0ZS1pbnB1dFwiLCBPYmplY3QuYXNzaWduKHsgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IGlzRGVmaW5lZCh2YWx1ZSkgPyBgJHt2YWx1ZX1gIDogYGAsIHNjYWxlOiBcIm1cIiwgc3RlcDogaXNGbG9hdCA/IFwiYW55XCIgOiAxLCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5LmZyb21WYWx1ZSwgb25DYWxjaXRlSW5wdXRJbnB1dDogKGV2ZW50KSA9PiB0aGlzLndhaXRPblVzZXIoZXZlbnQsIHRoaXMub25WYWx1ZUNoYW5nZU1heWJlKSB9LCBpbnB1dE9wdGlvbnMpKSwgaChcImRpdlwiLCB7IGNsYXNzOiBgJHtDU1MkMi5iZXR3ZWVuVmFsdWVzSW5wdXR9IGZpcnN0YCB9KSwgaChcImNhbGNpdGUtaW5wdXRcIiwgT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiBpc0RlZmluZWQodmFsdWUyKSA/IGAke3ZhbHVlMn1gIDogYGAsIHNjYWxlOiBcIm1cIiwgc3RlcDogaXNGbG9hdCA/IFwiYW55XCIgOiAxLCBjbGFzczogQ1NTJDIuYmV0d2VlblZhbHVlc0lucHV0LCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5LnRvVmFsdWUsIG9uQ2FsY2l0ZUlucHV0SW5wdXQ6IChldmVudCkgPT4gdGhpcy53YWl0T25Vc2VyKGV2ZW50LCB0aGlzLm9uVmFsdWUyQ2hhbmdlTWF5YmUpIH0sIGlucHV0T3B0aW9ucykpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1dlN0YXR1cyA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlc1N0YXR1cztcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlSW5mb3M7XG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0c1VuaXF1ZSA9IFtcbiAgICAgICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzLFxuICAgICAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3QsXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TGVhc3QsXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TW9zdCxcbiAgICAgICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzR3JlYXRlclRoYW4sXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0xlc3NUaGFuXG4gICAgICAgICAgICBdLmluZGV4T2Yob3BlcmF0b3IpID4gLTE7XG4gICAgICAgICAgICBjb25zdCBpbnB1dE5vZGUgPSAoaChcImNhbGNpdGUtaW5wdXRcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzOiBDU1MkMi5pbnB1dCwgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IGlzRGVmaW5lZCh2YWx1ZSkgPyBgJHt2YWx1ZX1gIDogYGAsIHNjYWxlOiBcIm1cIiwgc3RlcDogaXNGbG9hdCA/IFwiYW55XCIgOiAxLCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5LnZhbHVlLCBvbkNhbGNpdGVJbnB1dElucHV0OiAoZXZlbnQpID0+IHRoaXMud2FpdE9uVXNlcihldmVudCwgdGhpcy5vblZhbHVlQ2hhbmdlKSB9LCBpbnB1dE9wdGlvbnMpKSk7XG4gICAgICAgICAgICBpZiAodXZTdGF0dXMgPT09IHN0YXR1cy5GQUlMRUQgfHxcbiAgICAgICAgICAgICAgICAodXZTdGF0dXMgPT09IHN0YXR1cy5TVUNDRVNTICYmICEodW5pcXVlVmFsdWVzID09PSBudWxsIHx8IHVuaXF1ZVZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5pcXVlVmFsdWVzLmxlbmd0aCkpIHx8XG4gICAgICAgICAgICAgICAgIXN1cHBvcnRzVW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGgoXCJkaXZcIiwgeyBrZXk6IFwidmFsdWUtaW5wdXQtbnVtYmVyXCIgfSwgaW5wdXROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV2U3RhdHVzID09PSBzdGF0dXMuTUlTU0lORyB8fCB1dlN0YXR1cyA9PT0gc3RhdHVzLklOX1BST0dSRVNTKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV2U3RhdHVzID09PSBzdGF0dXMuTUlTU0lORykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGlzcGxheVVuaXF1ZVZhbHVlcyhmaWx0ZXJGaWVsZC5sYXllckZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBrZXk6IFwidmFsdWUtaW5wdXQtbnVtYmVyXCIsIGNsYXNzOiBDU1MkMi5pbnB1dFBsdXNVbmlxdWUgfSwgaW5wdXROb2RlLCB0aGlzLnJlbmRlclVuaXF1ZUJ1dHRvbihzdXBwb3J0c1VuaXF1ZSwgdHJ1ZSwgdHJ1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1udW1iZXJcIiwgY2xhc3M6IENTUyQyLmlucHV0UGx1c1VuaXF1ZSB9LCBpbnB1dE5vZGUsIHRoaXMucmVuZGVyVW5pcXVlQnV0dG9uKHN1cHBvcnRzVW5pcXVlLCAhKChfYSA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlSW5mb3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlclZhbHVlSW5wdXREYXRlKGZpbHRlckZpZWxkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgdmFsdWUsIHZhbHVlMiwgb3BlcmF0b3IgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlldywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHRpbWVab25lID0gKHZpZXcgPT09IG51bGwgfHwgdmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlldy50aW1lWm9uZSkgfHwgXCJzeXN0ZW1cIjtcbiAgICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHV0Y1RvRGF0ZVBpY2tlcih2YWx1ZSwgdGltZVpvbmUpIDogdmFsdWU7XG4gICAgICAgIGlmIChbc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCZXR3ZWVuLCBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJldHdlZW5dLmluZGV4T2Yob3BlcmF0b3IpID4gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVTdHJpbmcyID0gdHlwZW9mIHZhbHVlMiA9PT0gXCJudW1iZXJcIiA/IHV0Y1RvRGF0ZVBpY2tlcih2YWx1ZTIsIHRpbWVab25lKSA6IHZhbHVlMjtcbiAgICAgICAgICAgIC8vIG5vdCB1c2luZyByYW5nZSBvcHRpb24sIGJlY2F1c2UgdGhlcmUgaXMgbm8gZXF1aXZhbGVudCBmb3IgbnVtYmVyIGZpZWxkc1xuICAgICAgICAgICAgLy8gYW5kICdub3QgaW4gYmV0d2VlbicgbWlnaHQgYmUgd2VpcmQgaWYgdGhlIGJldHdlZW4gYXJlYSBpcyBoaWdobGlnaHRlZCBpbiB0aGUgY2FsZW5kYXJcbiAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCBudWxsLCBoKFwiY2FsY2l0ZS1pbnB1dC1kYXRlLXBpY2tlclwiLCB7IGNsYXNzOiBgJHtDU1MkMi5kYXRlUGlja2VyfSBmaXJzdGAsIHNjYWxlOiBcIm1cIiwgdmFsdWU6IGRhdGVTdHJpbmcsIG92ZXJsYXlQb3NpdGlvbmluZzogXCJmaXhlZFwiLCBvbkNhbGNpdGVJbnB1dERhdGVQaWNrZXJDaGFuZ2U6IHRoaXMub25WYWx1ZUNoYW5nZSB9KSwgaChcImNhbGNpdGUtaW5wdXQtZGF0ZS1waWNrZXJcIiwgeyBjbGFzczogQ1NTJDIuZGF0ZVBpY2tlciwgc2NhbGU6IFwibVwiLCB2YWx1ZTogZGF0ZVN0cmluZzIsIG92ZXJsYXlQb3NpdGlvbmluZzogXCJmaXhlZFwiLCBvbkNhbGNpdGVJbnB1dERhdGVQaWNrZXJDaGFuZ2U6IHRoaXMub25WYWx1ZTJDaGFuZ2UgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHV2U3RhdHVzID0gZmlsdGVyRmllbGQudW5pcXVlVmFsdWVzU3RhdHVzO1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlVmFsdWVzID0gZmlsdGVyRmllbGQudW5pcXVlVmFsdWVJbmZvcztcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRzVW5pcXVlID0gW1xuICAgICAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzT24sXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RPbixcbiAgICAgICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0FmdGVyLFxuICAgICAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmVmb3JlXG4gICAgICAgICAgICBdLmluZGV4T2Yob3BlcmF0b3IpID4gLTE7XG4gICAgICAgICAgICBjb25zdCBpbnB1dE5vZGUgPSAoaChcImNhbGNpdGUtaW5wdXQtZGF0ZS1waWNrZXJcIiwgeyBjbGFzczogYCR7Q1NTJDIuZGF0ZVBpY2tlcn0gJHtDU1MkMi5pbnB1dH1gLCBzY2FsZTogXCJtXCIsIHZhbHVlOiBkYXRlU3RyaW5nLCBvdmVybGF5UG9zaXRpb25pbmc6IFwiZml4ZWRcIiwgb25DYWxjaXRlSW5wdXREYXRlUGlja2VyQ2hhbmdlOiB0aGlzLm9uVmFsdWVDaGFuZ2UgfSkpO1xuICAgICAgICAgICAgaWYgKHV2U3RhdHVzID09PSBzdGF0dXMuRkFJTEVEIHx8XG4gICAgICAgICAgICAgICAgKHV2U3RhdHVzID09PSBzdGF0dXMuU1VDQ0VTUyAmJiAhKHVuaXF1ZVZhbHVlcyA9PT0gbnVsbCB8fCB1bmlxdWVWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuaXF1ZVZhbHVlcy5sZW5ndGgpKSB8fFxuICAgICAgICAgICAgICAgICFzdXBwb3J0c1VuaXF1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoKFwiZGl2XCIsIHsga2V5OiBcInZhbHVlLWlucHV0LWRhdGVcIiB9LCBpbnB1dE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXZTdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HIHx8IHV2U3RhdHVzID09PSBzdGF0dXMuSU5fUFJPR1JFU1MpIHtcbiAgICAgICAgICAgICAgICBpZiAodXZTdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EaXNwbGF5VW5pcXVlVmFsdWVzKGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1kYXRlXCIsIGNsYXNzOiBDU1MkMi5pbnB1dFBsdXNVbmlxdWUgfSwgaW5wdXROb2RlLCB0aGlzLnJlbmRlclVuaXF1ZUJ1dHRvbihzdXBwb3J0c1VuaXF1ZSwgdHJ1ZSwgdHJ1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1kYXRlXCIsIGNsYXNzOiBDU1MkMi5pbnB1dFBsdXNVbmlxdWUgfSwgaW5wdXROb2RlLCB0aGlzLnJlbmRlclVuaXF1ZUJ1dHRvbihzdXBwb3J0c1VuaXF1ZSwgISgoX2EgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZUluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJWYWx1ZUlucHV0T2lkKGZpbHRlckZpZWxkLCBpbnB1dE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCB2YWx1ZSwgdmFsdWUyLCBvcGVyYXRvciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5PSUQpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGFsbG93IGRlY2ltYWxzXG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSAmJiBpc0RlZmluZWQodmFsdWUyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdW5kZWRWYWwgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3VuZGVkVmFsMiA9IE1hdGgucm91bmQodmFsdWUyKTtcbiAgICAgICAgICAgICAgICBpZiAocm91bmRlZFZhbCAhPT0gdmFsdWUgfHwgcm91bmRlZFZhbDIgIT09IHZhbHVlMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyhyb3VuZGVkVmFsLCByb3VuZGVkVmFsMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdW5kZWRWYWwgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocm91bmRlZFZhbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZXMocm91bmRlZFZhbCwgdmFsdWUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZmluZWQodmFsdWUyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdW5kZWRWYWwgPSBNYXRoLnJvdW5kKHZhbHVlMik7XG4gICAgICAgICAgICAgICAgaWYgKHJvdW5kZWRWYWwgIT09IHZhbHVlMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyh2YWx1ZSwgcm91bmRlZFZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChbXG4gICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQmV0d2VlbixcbiAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3RCZXR3ZWVuXG4gICAgICAgIF0uaW5kZXhPZihvcGVyYXRvcikgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWlucHV0XCIsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogaXNEZWZpbmVkKHZhbHVlKSA/IGAke3ZhbHVlfWAgOiBgYCwgc2NhbGU6IFwibVwiLCBtaW46IDAsIHN0ZXA6IDEsIGxhYmVsOiBzdHJpbmdzLmFjY2Vzc2liaWxpdHkuZnJvbVZhbHVlLCBvbkNhbGNpdGVJbnB1dElucHV0OiB0aGlzLm9uVmFsdWVDaGFuZ2VNYXliZSB9LCBpbnB1dE9wdGlvbnMpKSwgaChcImRpdlwiLCB7IGNsYXNzOiBgJHtDU1MkMi5iZXR3ZWVuVmFsdWVzSW5wdXR9IGZpcnN0YCB9KSwgaChcImNhbGNpdGUtaW5wdXRcIiwgT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiBpc0RlZmluZWQodmFsdWUyKSA/IGAke3ZhbHVlMn1gIDogYGAsIHNjYWxlOiBcIm1cIiwgbWluOiAwLCBzdGVwOiAxLCBjbGFzczogQ1NTJDIuYmV0d2VlblZhbHVlc0lucHV0LCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5LnRvVmFsdWUsIG9uQ2FsY2l0ZUlucHV0SW5wdXQ6IHRoaXMub25WYWx1ZTJDaGFuZ2VNYXliZSB9LCBpbnB1dE9wdGlvbnMpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdXZTdGF0dXMgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZXNTdGF0dXM7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZUluZm9zO1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydHNVbmlxdWUgPSBbXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJcyxcbiAgICAgICAgICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTm90LFxuICAgICAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNBdExlYXN0LFxuICAgICAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNBdE1vc3QsXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0dyZWF0ZXJUaGFuLFxuICAgICAgICAgICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNMZXNzVGhhblxuICAgICAgICAgICAgXS5pbmRleE9mKG9wZXJhdG9yKSA+IC0xO1xuICAgICAgICAgICAgY29uc3QgaW5wdXROb2RlID0gKGgoXCJjYWxjaXRlLWlucHV0XCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzczogQ1NTJDIuaW5wdXQsIHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiBpc0RlZmluZWQodmFsdWUpID8gYCR7dmFsdWV9YCA6IGBgLCBzY2FsZTogXCJtXCIsIG1pbjogMCwgc3RlcDogMSwgbGFiZWw6IHN0cmluZ3MuYWNjZXNzaWJpbGl0eS52YWx1ZSwgb25DYWxjaXRlSW5wdXRJbnB1dDogdGhpcy5vblZhbHVlQ2hhbmdlIH0sIGlucHV0T3B0aW9ucykpKTtcbiAgICAgICAgICAgIGlmICh1dlN0YXR1cyA9PT0gc3RhdHVzLkZBSUxFRCB8fFxuICAgICAgICAgICAgICAgICh1dlN0YXR1cyA9PT0gc3RhdHVzLlNVQ0NFU1MgJiYgISh1bmlxdWVWYWx1ZXMgPT09IG51bGwgfHwgdW5pcXVlVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmlxdWVWYWx1ZXMubGVuZ3RoKSkgfHxcbiAgICAgICAgICAgICAgICAhc3VwcG9ydHNVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1vaWRcIiB9LCBpbnB1dE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXZTdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HIHx8IHV2U3RhdHVzID09PSBzdGF0dXMuSU5fUFJPR1JFU1MpIHtcbiAgICAgICAgICAgICAgICBpZiAodXZTdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EaXNwbGF5VW5pcXVlVmFsdWVzKGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1vaWRcIiwgY2xhc3M6IENTUyQyLmlucHV0UGx1c1VuaXF1ZSB9LCBpbnB1dE5vZGUsIHRoaXMucmVuZGVyVW5pcXVlQnV0dG9uKHN1cHBvcnRzVW5pcXVlLCB0cnVlLCB0cnVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsga2V5OiBcInZhbHVlLWlucHV0LW9pZFwiLCBjbGFzczogQ1NTJDIuaW5wdXRQbHVzVW5pcXVlIH0sIGlucHV0Tm9kZSwgdGhpcy5yZW5kZXJVbmlxdWVCdXR0b24oc3VwcG9ydHNVbmlxdWUsICEoKF9hID0gZmlsdGVyRmllbGQudW5pcXVlVmFsdWVJbmZvcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyVW5pcXVlVmFsdWVzKGZpbHRlckZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHZhbHVlcywgZmllbGROYW1lIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB1dlN0YXR1cyA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlc1N0YXR1cztcbiAgICAgICAgY29uc3QgdW5pcXVlVmFsdWVzID0gZmlsdGVyRmllbGQudW5pcXVlVmFsdWVJbmZvcztcbiAgICAgICAgaWYgKHV2U3RhdHVzID09PSBzdGF0dXMuTUlTU0lORyB8fCB1dlN0YXR1cyA9PT0gc3RhdHVzLklOX1BST0dSRVNTKSB7XG4gICAgICAgICAgICBpZiAodXZTdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc3BsYXlVbmlxdWVWYWx1ZXMoZmlsdGVyRmllbGQubGF5ZXJGaWVsZC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCBudWxsLCBoKFwiY2FsY2l0ZS1sb2FkZXJcIiwgeyBjbGFzczogQ1NTJDIuc21hbGxMb2FkZXIsIGlubGluZTogdHJ1ZSwgbGFiZWw6IFwiXCIgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1dlN0YXR1cyA9PT0gc3RhdHVzLkZBSUxFRCkge1xuICAgICAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQyLnVuaXF1ZVZhbHVlc0NvbnRlbnRMaXN0TXNnIH0sIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgd2lkdGg6IFwiZnVsbFwiLCBzY2FsZTogXCJtXCIsIGFsaWdubWVudDogXCJjZW50ZXJcIiwgY2xhc3M6IENTUyQyLnNlbGVjdFZhbHVlcywgZGlzYWJsZWQ6IHRydWUsIGxhYmVsOiBzdHJpbmdzLnNlbGVjdFZhbHVlcyB9LCBzdHJpbmdzLnNlbGVjdFZhbHVlcyksIHN0cmluZ3MuZXJyb3JzLmVycm9yVW5pcXVlVmFsdWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtc2cxTm9kZSA9IChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQyLnVuaXF1ZVZhbHVlc0NvbnRlbnRMaXN0TXNnIH0sICEodmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLmxlbmd0aCkgJiYgKHVuaXF1ZVZhbHVlcyA9PT0gbnVsbCB8fCB1bmlxdWVWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuaXF1ZVZhbHVlcy5sZW5ndGgpID8gc3RyaW5ncy5zZWxlY3RPbmVWYWx1ZSA6IFwiXCIpKTtcbiAgICAgICAgICAgIGxldCBtc2cyTm9kZTtcbiAgICAgICAgICAgIGlmICghKHVuaXF1ZVZhbHVlcyA9PT0gbnVsbCB8fCB1bmlxdWVWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuaXF1ZVZhbHVlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbXNnMk5vZGUgPSAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMi51bmlxdWVWYWx1ZXNDb250ZW50TGlzdE1zZyB9LCBzdHJpbmdzLmVycm9ycy5ub1VuaXF1ZVZhbHVlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiB0aGlzLnJlbmRlclNlbGVjdGVkVW5pcXVlVmFsdWUodmFsdWUsIGZpbHRlckZpZWxkKSk7XG4gICAgICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgbnVsbCwgbXNnMU5vZGUsIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgd2lkdGg6IFwiZnVsbFwiLCBzY2FsZTogXCJtXCIsIGFsaWdubWVudDogXCJjZW50ZXJcIiwgY2xhc3M6IENTUyQyLnNlbGVjdFZhbHVlcywgZGlzYWJsZWQ6ICEodW5pcXVlVmFsdWVzID09PSBudWxsIHx8IHVuaXF1ZVZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5pcXVlVmFsdWVzLmxlbmd0aCksIG9uQ2xpY2s6ICh1bmlxdWVWYWx1ZXMgPT09IG51bGwgfHwgdW5pcXVlVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmlxdWVWYWx1ZXMubGVuZ3RoKSA+IDAgPyB0aGlzLm9uU2VsZWN0VW5pcXVlVmFsdWVzIDogbnVsbCwgcmVmOiAobm9kZSkgPT4gKHRoaXMudW5pcXVlU2VsZWN0Tm9kZSA9IG5vZGUpLCBsYWJlbDogc3RyaW5ncy5zZWxlY3RWYWx1ZXMgfSwgc3RyaW5ncy5zZWxlY3RWYWx1ZXMpLCBtc2cyTm9kZSwgKHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlcy5sZW5ndGgpID8gKGgoXCJjYWxjaXRlLXZhbHVlLWxpc3RcIiwgeyBrZXk6IGB1bmlxdWUtdmFsdWVzLXZhbHVlLWxpc3QtJHtmaWVsZE5hbWV9YCwgY2xhc3M6IENTUyQyLnBpY2tMaXN0LCByZWY6IHRoaXMuYWZ0ZXJDcmVhdGVMaXN0IH0sIGxpc3QpKSA6IG51bGwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJTZWxlY3RlZFVuaXF1ZVZhbHVlKHZhbHVlLCBmaWx0ZXJGaWVsZCkge1xuICAgICAgICBjb25zdCB7IGludGwsIHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXcsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9ICh2aWV3ID09PSBudWxsIHx8IHZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXcudGltZVpvbmUpIHx8IFwic3lzdGVtXCI7XG4gICAgICAgIGNvbnN0IHZhbCA9IGhhc0ZpZWxkRG9tYWlucyhmaWx0ZXJGaWVsZClcbiAgICAgICAgICAgID8gZ2V0RGVjb2RlZFZhbHVlKHZhbHVlLCBmaWx0ZXJGaWVsZClcbiAgICAgICAgICAgIDogaXNEYXRlVHlwZShmaWx0ZXJGaWVsZClcbiAgICAgICAgICAgICAgICA/IGdldERhdGVEaXNwbGF5U3RyaW5nKHZhbHVlLCB0aW1lWm9uZSwgaW50bCkgLy9pbnRsLmZvcm1hdERhdGUobmV3IERhdGUodmFsdWUpLCBpbnRsLmNvbnZlcnREYXRlRm9ybWF0VG9JbnRsT3B0aW9ucyhcInNob3J0LWRhdGVcIikpXG4gICAgICAgICAgICAgICAgOiBpc0RhdGVPbmx5VHlwZShmaWx0ZXJGaWVsZClcbiAgICAgICAgICAgICAgICAgICAgPyBpbnRsLmZvcm1hdERhdGVPbmx5KHZhbHVlLCBpbnRsLmNvbnZlcnREYXRlRm9ybWF0VG9JbnRsT3B0aW9ucyhcInNob3J0LWRhdGVcIikpXG4gICAgICAgICAgICAgICAgICAgIDogaXNOdW1iZXJUeXBlKGZpbHRlckZpZWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnRsLmZvcm1hdE51bWJlcih2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIsIHsgbGFiZWw6IGAke3ZhbH1gLCB2YWx1ZTogYCR7dmFsdWV9YCB9LCBoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBzbG90OiBcImFjdGlvbnMtZW5kXCIsIHRleHQ6IHN0cmluZ3MucmVtb3ZlLCBpY29uOiBcInhcIiwgb25DbGljazogdGhpcy5vblJlbW92ZVNlbGVjdGVkVmFsdWUuYmluZCh0aGlzLCB2YWx1ZSkgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVySW5UaGVMYXN0KCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCB2YWx1ZSwgdW5pdCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQyLmluVGhlTGFzdCB9LCBoKFwiY2FsY2l0ZS1pbnB1dFwiLCB7IHR5cGU6IFwibnVtYmVyXCIsIG1pbjogMSwgc3RlcDogMSwgdmFsdWU6IGlzRGVmaW5lZCh2YWx1ZSkgPyBgJHt2YWx1ZX1gIDogYGAsIHNjYWxlOiBcIm1cIiwgY2xhc3M6IENTUyQyLmluVGhlTGFzdENvdW50LCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5LnZhbHVlLCBvbkNhbGNpdGVJbnB1dElucHV0OiB0aGlzLm9uVmFsdWVDaGFuZ2UgfSksIGgoXCJjYWxjaXRlLXNlbGVjdFwiLCB7IHdpZHRoOiBcImZ1bGxcIiwgc2NhbGU6IFwibVwiLCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5LnVuaXRzLCBjbGFzczogQ1NTJDIuaW5UaGVMYXN0VW5pdCwgb25DYWxjaXRlU2VsZWN0Q2hhbmdlOiB0aGlzLm9uVW5pdFNlbGVjdCB9LCB0aGlzLnJlbmRlckluVGhlTGFzdE9wdGlvbih0aW1lVW5pdHMuTUlOVVRFLCB1bml0ID09PSB0aW1lVW5pdHMuTUlOVVRFKSwgdGhpcy5yZW5kZXJJblRoZUxhc3RPcHRpb24odGltZVVuaXRzLkhPVVIsIHVuaXQgPT09IHRpbWVVbml0cy5IT1VSKSwgdGhpcy5yZW5kZXJJblRoZUxhc3RPcHRpb24odGltZVVuaXRzLkRBWSwgdW5pdCA9PT0gdGltZVVuaXRzLkRBWSksIHRoaXMucmVuZGVySW5UaGVMYXN0T3B0aW9uKHRpbWVVbml0cy5XRUVLLCB1bml0ID09PSB0aW1lVW5pdHMuV0VFSyksIHRoaXMucmVuZGVySW5UaGVMYXN0T3B0aW9uKHRpbWVVbml0cy5NT05USCwgdW5pdCA9PT0gdGltZVVuaXRzLk1PTlRIKSwgdGhpcy5yZW5kZXJJblRoZUxhc3RPcHRpb24odGltZVVuaXRzLllFQVIsIHVuaXQgPT09IHRpbWVVbml0cy5ZRUFSKSkpKTtcbiAgICB9XG4gICAgcmVuZGVySW5UaGVMYXN0T3B0aW9uKHVuaXQsIGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1vcHRpb25cIiwgeyB2YWx1ZTogdW5pdCwgbGFiZWw6IHN0cmluZ3MudW5pdHNbdW5pdF0sIHNlbGVjdGVkOiBpc1NlbGVjdGVkIH0pKTtcbiAgICB9XG4gICAgcmVuZGVySGlzdG9ncmFtKGZpbHRlckZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGhpc3RvZ3JhbU9wZW4sIG9wZXJhdG9yLCBmaWVsZE5hbWUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgfHwgbGF5ZXIudHlwZSA9PT0gXCJzdWJ0eXBlLWdyb3VwXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmlsdGVyRmllbGQgfHwgIWZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlckZpZWxkLnN0YXRpc3RpY3NTdGF0dXMgPT09IHN0YXR1cy5GQUlMRUQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VwcG9ydHNIaXN0b2dyYW0oZmllbGROYW1lLCBvcGVyYXRvciwgcHJvcHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlzdG9ncmFtT3BlbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoaGlzdG9ncmFtT3BlbiAmJiBmaWx0ZXJGaWVsZC5oaXN0b2dyYW1TdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HKSkge1xuICAgICAgICAgICAgLy8gb3BlbiBoaXN0b2dyYW0gYmxvY2sgYnkgZGVmYXVsdDsgb3IgZ2V0IGluZm8gd2UgbmVlZFxuICAgICAgICAgICAgdGhpcy5vbkhpc3RvZ3JhbU9wZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJsb2NrLXNlY3Rpb25cIiwgeyBvcGVuOiBoaXN0b2dyYW1PcGVuICE9PSBmYWxzZSwgdGV4dDogZmlsdGVyRmllbGQuaGlzdG9ncmFtU3RhdHVzID09PSBzdGF0dXMuRkFJTEVEID8gc3RyaW5ncy52YWx1ZVJhbmdlIDogc3RyaW5ncy5oaXN0b2dyYW0sIG9uQ2FsY2l0ZUJsb2NrU2VjdGlvblRvZ2dsZTogdGhpcy5vbkhpc3RvZ3JhbUJsb2NrVG9nZ2xlIH0sIHRoaXMucmVuZGVySGlzdG9ncmFtQ29udGVudChmaWx0ZXJGaWVsZCkpKTtcbiAgICB9XG4gICAgcmVuZGVySGlzdG9ncmFtQ29udGVudChmaWx0ZXJGaWVsZCkge1xuICAgICAgICBjb25zdCB7IGhpc3RvZ3JhbU9wZW4gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZTtcbiAgICAgICAgaWYgKGhpc3RvZ3JhbU9wZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpbHRlckZpZWxkLnN0YXRpc3RpY3MgfHwgZmlsdGVyRmllbGQuaGlzdG9ncmFtU3RhdHVzID09PSBzdGF0dXMuSU5fUFJPR1JFU1MpIHtcbiAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGtleTogYGhpc3RvZ3JhbS1jb250ZW50LSR7ZmllbGROYW1lfS0ke2ZpbHRlckZpZWxkLnN0YXRpc3RpY3N9YCwgY2xhc3M6IGZpbHRlckZpZWxkLmhpc3RvZ3JhbSA/IENTUyQyLmhpc3RvZ3JhbUNvbnRlbnQgOiBDU1MkMi5oaXN0b2dyYW1Db250ZW50U2xpbSB9LCBoKFwiY2FsY2l0ZS1sb2FkZXJcIiwgeyBjbGFzczogQ1NTJDIuc21hbGxMb2FkZXIsIGlubGluZTogdHJ1ZSwgbGFiZWw6IFwiXCIgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9rID0gdGhpcy5wcmVwYXJlU2xpZGVyKGZpbHRlckZpZWxkKTtcbiAgICAgICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGtleTogYGhpc3RvZ3JhbS1jb250ZW50LSR7ZmllbGROYW1lfS0ke2ZpbHRlckZpZWxkLnN0YXRpc3RpY3N9YCwgY2xhc3M6IGAke2ZpbHRlckZpZWxkLmhpc3RvZ3JhbSA/IENTUyQyLmhpc3RvZ3JhbUNvbnRlbnQgOiBDU1MkMi5oaXN0b2dyYW1Db250ZW50U2xpbX1gLCByZWY6IHRoaXMuYWZ0ZXJDcmVhdGVTbGlkZXJEaXYgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgaGF2ZSBhIHNsaWRlciB5ZXQsIG5lZWQgdG8gd2FpdCBhIGxpdHRsZSBsb25nZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzZXRGb2N1cygpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ob3N0RWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLmF1dG9mb2N1c1wiKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXRGb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgIH1cbiAgICBvblNlbGVjdFVuaXF1ZShtdWx0aXBsZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHZhbHVlLCB2YWx1ZXMsIGZpZWxkTmFtZSwgdWlkLCB1bmlxdWVWYWx1ZXNTb3J0QnksIGVzcmlMYW5nIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MsIGxvY2FsZUludGwgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBkaXIgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICBpZiAodGhpcy51bmlxdWVQb3BvdmVyTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUZpbHRlclBvcG92ZXJzSGFuZGxlcigpO1xuICAgICAgICAgICAgLy8ganVzdCBjbG9zZSB0aGUgcG9wb3ZlclxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VGaWx0ZXJQb3BvdmVyc0hhbmRsZXIoKTtcbiAgICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gICAgICAgIGlmICghZmlsdGVyRmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlV2lkdGggPSAoX2EgPSB0aGlzLmZpZWxkTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjb25zdCB3aWR0aCA9IG5vZGVXaWR0aCA/IG5vZGVXaWR0aCArIDIgOiAyMDQ7XG4gICAgICAgIC8vIHdlIGNhbid0IHVzZSBhIHBhbmVsIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhIGhlYWRlclxuICAgICAgICBjb25zdCBwYW5lbE5vZGUgPSBxdWVyeVBhcmVudEVsZW1lbnQodGhpcy5ob3N0RWxlbWVudCwgXCJjYWxjaXRlLXBhbmVsXCIpO1xuICAgICAgICBjb25zdCBub2RlSGVpZ2h0ID0gcGFuZWxOb2RlID09PSBudWxsIHx8IHBhbmVsTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFuZWxOb2RlLmNsaWVudEhlaWdodDtcbiAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gbm9kZUhlaWdodCA/IE1hdGgubWF4KE1hdGgubWluKG5vZGVIZWlnaHQgLyAzLCA0MDApLCAyNDApIDogNDAwO1xuICAgICAgICBjb25zdCBwb3BvdmVyVW5pcXVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbGNpdGUtcG9wb3ZlclwiKTtcbiAgICAgICAgcG9wb3ZlclVuaXF1ZS5pZCA9IGBhcmNnaXMtZmlsdGVyLXVuaXF1ZS1wb3BvdmVyXyR7dWlkfWA7XG4gICAgICAgIHBvcG92ZXJVbmlxdWUucGxhY2VtZW50ID0gZGlyID09PSBcInJ0bFwiID8gXCJib3R0b20tc3RhcnRcIiA6IFwiYm90dG9tLWVuZFwiO1xuICAgICAgICBwb3BvdmVyVW5pcXVlLm9mZnNldERpc3RhbmNlID0gMDtcbiAgICAgICAgcG9wb3ZlclVuaXF1ZS5vZmZzZXRTa2lkZGluZyA9IDA7XG4gICAgICAgIHBvcG92ZXJVbmlxdWUucG9pbnRlckRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgcG9wb3ZlclVuaXF1ZS5zdHlsZSA9IGB3aWR0aDogJHt3aWR0aH1weDtgO1xuICAgICAgICBwb3BvdmVyVW5pcXVlLnJlZmVyZW5jZUVsZW1lbnQgPSBtdWx0aXBsZSA/IHRoaXMudW5pcXVlU2VsZWN0Tm9kZSA6IHRoaXMudW5pcXVlQWN0aW9uTm9kZTtcbiAgICAgICAgY29uc3QgdW5pcXVlTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtZmlsdGVyLXVuaXF1ZS1saXN0XCIpO1xuICAgICAgICB1bmlxdWVMaXN0LnVpZCA9IHVpZDtcbiAgICAgICAgdW5pcXVlTGlzdC5wcm9wcyA9IHByb3BzO1xuICAgICAgICB1bmlxdWVMaXN0LnVuaXF1ZVZhbHVlcyA9IGVzcmlMYW5nLmNsb25lKGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlSW5mb3MpO1xuICAgICAgICB1bmlxdWVMaXN0LnNlbGVjdGVkVmFsdWVzID0gbXVsdGlwbGUgPyB2YWx1ZXMgOiB2YWx1ZSA/IFt2YWx1ZV0gOiBbXTtcbiAgICAgICAgdW5pcXVlTGlzdC5maWVsZERvbWFpbnMgPSBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnM7XG4gICAgICAgIHVuaXF1ZUxpc3QubGF5ZXJGaWVsZFR5cGUgPSBmaWx0ZXJGaWVsZC5sYXllckZpZWxkLnR5cGU7XG4gICAgICAgIHVuaXF1ZUxpc3QuaXNEYXRlID1cbiAgICAgICAgICAgIFtzaW1wbGVGaWVsZFR5cGVzLkRBVEUsIHNpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5pbmRleE9mKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkgPiAtMTtcbiAgICAgICAgdW5pcXVlTGlzdC5tdWx0aXBsZSA9IG11bHRpcGxlO1xuICAgICAgICB1bmlxdWVMaXN0LnNvcnRCeSA9IHVuaXF1ZVZhbHVlc1NvcnRCeTtcbiAgICAgICAgdW5pcXVlTGlzdC5wYXJ0aWFsVW5pcXVlVmFsdWVzID0gZmlsdGVyRmllbGQucGFydGlhbFVuaXF1ZVZhbHVlcztcbiAgICAgICAgdW5pcXVlTGlzdC5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgICAgIHVuaXF1ZUxpc3Quc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHVuaXF1ZUxpc3QubG9jYWxlID0gbG9jYWxlSW50bDtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZXJlJ3MgYW4gaXNzdWUgd2l0aCB0aGUgd2lkdGggb2YgdGhlIGxpc3QuLi5cbiAgICAgICAgdW5pcXVlTGlzdC5zdHlsZSA9IGBtaW4td2lkdGg6ICR7d2lkdGh9cHhgO1xuICAgICAgICBwb3BvdmVyVW5pcXVlLmFwcGVuZENoaWxkKHVuaXF1ZUxpc3QpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBvcG92ZXJVbmlxdWUpO1xuICAgICAgICBwb3BvdmVyVW5pcXVlLm9wZW4gPSB0cnVlO1xuICAgICAgICBmb3JjZVVwZGF0ZSh1bmlxdWVMaXN0KTtcbiAgICAgICAgdW5pcXVlTGlzdC5zZXRGb2N1cygpO1xuICAgICAgICBwb3BvdmVyVW5pcXVlLnJlcG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy51bmlxdWVQb3BvdmVyTm9kZSA9IHBvcG92ZXJVbmlxdWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25Eb2N1bWVudENsaWNrQmluZCk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgc2Nyb2xsRXhwckludG9WaWV3KG5vZGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBxdWVyeVBhcmVudEVsZW1lbnQobm9kZSwgXCIuZmlsdGVyLWV4cHJlc3Npb25cIik7XG4gICAgICAgICAgICAgICAgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgYmVoYXZpb3I6IFwic21vb3RoXCIsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lOiBcInN0YXJ0XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG4gICAgcmVtb3ZlVW5pcXVlUG9wb3ZlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5vbkRvY3VtZW50Q2xpY2tCaW5kKTtcbiAgICAgICAgaWYgKHRoaXMudW5pcXVlUG9wb3Zlck5vZGUpIHtcbiAgICAgICAgICAgIC8qIGNvbnN0IHBvcG92ZXIgPSB0aGlzLnVuaXF1ZVBvcG92ZXJOb2RlPy5jaGlsZE5vZGVzPy5bMF0gYXMgSFRNTENhbGNpdGVQb3BvdmVyRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChwb3BvdmVyKSB7XG4gICAgICAgICAgICAgIHBvcG92ZXIub3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSAqL1xuICAgICAgICAgICAgdGhpcy51bmlxdWVQb3BvdmVyTm9kZS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBuZWVkIHRoZSA/IGhlcmUuLi5cbiAgICAgICAgICAgIChfYSA9IHRoaXMudW5pcXVlUG9wb3Zlck5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMudW5pcXVlUG9wb3Zlck5vZGUpO1xuICAgICAgICAgICAgdGhpcy51bmlxdWVQb3BvdmVyTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkRpc3BsYXlVbmlxdWVWYWx1ZXMoZmllbGROYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgdW5pcXVlVmFsdWVzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGxheWVyLCB2aWV3LCBmZWF0dXJlUmVkdWN0aW9uIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gICAgICAgIGlmICghZmlsdGVyRmllbGQgfHwgbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgfHwgbGF5ZXIudHlwZSA9PT0gXCJzdWJ0eXBlLWdyb3VwXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyRmllbGQudW5pcXVlVmFsdWVzU3RhdHVzID09PSBzdGF0dXMuTUlTU0lORyAmJiBsYXllcikge1xuICAgICAgICAgICAgZmlsdGVyRmllbGQudW5pcXVlVmFsdWVzU3RhdHVzID0gc3RhdHVzLklOX1BST0dSRVNTO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVWYWx1ZXNSZXN1bHQgPSBhd2FpdCB1bmlxdWVWYWx1ZXMoe1xuICAgICAgICAgICAgICAgICAgICBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZm9yQmlubmluZzogZmVhdHVyZVJlZHVjdGlvbiAmJiBbXCJiaW5uaW5nXCIsIFwiY2x1c3RlclwiXS5pbmRleE9mKChfYSA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA+IC0xXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gdW5pcXVlVmFsdWVJbmZvczogW3t2YWx1ZSwgY291bnR9LC4uLl1cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic3VjY2Vzcy11bmlxdWVWYWx1ZXNcIiwgdW5pcXVlVmFsdWVzUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAvLyBlLmcuIGNvZGVkIHZhbHVlIGRvbWFpbnNcbiAgICAgICAgICAgICAgICBjb25zdCBpc051bWJlciA9IGlzTnVtYmVyVHlwZShmaWx0ZXJGaWVsZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlVmFsdWVJbmZvcyA9IHVuaXF1ZVZhbHVlc1Jlc3VsdC51bmlxdWVWYWx1ZUluZm9zLmZpbHRlcigoaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpcyBhbHdheXMgYSBzdHJpbmcsIGJlY2F1c2Ugd2UgcmVhZCBpdCBmcm9tIHRoZSByZW5kZXJlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGVmaW5lZChpbmZvLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IFwic3RyaW5nXCIgJiYgIWlzTnVtYmVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID09PSBcImd1aWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZm8udmFsdWUgIT09IFwiPE51bGw+XCIgJiYgYCR7aW5mby52YWx1ZX1gLnRyaW0oKSAhPT0gXCJcIjsgLy8gd2UgZG9uJ3QgYWxsb3cgZW1wdHkgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID09PSBcIm9pZFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpc051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZm8udmFsdWUgIT09IFwiPE51bGw+XCIgJiYgaW5mby52YWx1ZSAhPT0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiZGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5mby52YWx1ZSAhPT0gXCI8TnVsbD5cIiAmJiBpbmZvLnZhbHVlICE9PSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gc29ydCBieSBjb3VudFxuICAgICAgICAgICAgICAgIHVuaXF1ZVZhbHVlSW5mb3Muc29ydCgoYSwgYikgPT4gYS5jb3VudCA+IGIuY291bnQgPyAtMSA6IGEuY291bnQgPCBiLmNvdW50ID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGlmIChoYXNGaWVsZERvbWFpbnMoZmlsdGVyRmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBkb21haW5zIHRoYXQgYXJlIG5vdCB1c2VkIGluIGFueSBmZWF0dXJlXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZpZWxkLmZpZWxkRG9tYWlucy5mb3JFYWNoKChmaWVsZERvbWFpbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVWYWx1ZUluZm9zLmZpbmQoKG9iaikgPT4gb2JqLnZhbHVlID09PSBmaWVsZERvbWFpbi5jb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZVZhbHVlSW5mb3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmaWVsZERvbWFpbi5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBwYXJ0aWFsRGF0YVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxVbmlxdWVWYWx1ZXMgPSB1bmlxdWVWYWx1ZXNSZXN1bHQudW5pcXVlVmFsdWVJbmZvcy5sZW5ndGggPT09IDIwMDA7XG4gICAgICAgICAgICAgICAgcHJvcHMuZmllbGRzID0gcHJvcHMuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZCksIHsgdW5pcXVlVmFsdWVJbmZvcywgdW5pcXVlVmFsdWVzU3RhdHVzOiBzdGF0dXMuU1VDQ0VTUywgcGFydGlhbFVuaXF1ZVZhbHVlcyB9KSA6IGZpZWxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlclVuaXF1ZVZhbHVlc1JldHVybmVkLmVtaXQoZmlsdGVyRmllbGQubGF5ZXJGaWVsZC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvci11bmlxdWVWYWx1ZXNcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNGaWVsZERvbWFpbnMoZmlsdGVyRmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBkb21haW5zIGZyb20gbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlVmFsdWVJbmZvcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMuZm9yRWFjaCgoZmllbGREb21haW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdW5pcXVlVmFsdWVJbmZvcy5maW5kKChvYmopID0+IG9iai52YWx1ZSA9PT0gZmllbGREb21haW4uY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVWYWx1ZUluZm9zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmllbGREb21haW4uY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZmllbGRzID0gcHJvcHMuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGQpLCB7IHVuaXF1ZVZhbHVlSW5mb3MsIHVuaXF1ZVZhbHVlc1N0YXR1czogc3RhdHVzLlNVQ0NFU1MsIHBhcnRpYWxVbmlxdWVWYWx1ZXM6IGZhbHNlIH0pIDogZmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZmllbGRzID0gcHJvcHMuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGQpLCB7IHVuaXF1ZVZhbHVlc1N0YXR1czogc3RhdHVzLkZBSUxFRCB9KSA6IGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uSGlzdG9ncmFtT3BlbigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgZmllbGROYW1lLCBzdW1tYXJ5U3RhdGlzdGljcywgaGlzdG9ncmFtIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGxheWVyLCB2aWV3LCBmZWF0dXJlUmVkdWN0aW9uIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gICAgICAgIGlmICghbGF5ZXIgfHwgbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgfHwgbGF5ZXIudHlwZSA9PT0gXCJzdWJ0eXBlLWdyb3VwXCIgfHwgIWZpbHRlckZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlckZpZWxkLnN0YXRpc3RpY3MpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEZWZhdWx0VmFsdWVzKGZpbHRlckZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9ncmFtT3BlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWZpbHRlckZpZWxkLnN0YXRpc3RpY3MpIHtcbiAgICAgICAgICAgIHByb3BzLmZpZWxkcyA9IHByb3BzLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZVxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZCksIHsgc3RhdGlzdGljc1N0YXR1czogc3RhdHVzLklOX1BST0dSRVNTIH0pIDogZmllbGQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0aXN0aWNzID0gYXdhaXQgc3VtbWFyeVN0YXRpc3RpY3Moe1xuICAgICAgICAgICAgICAgICAgICBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZm9yQmlubmluZzogZmVhdHVyZVJlZHVjdGlvbiAmJiBbXCJiaW5uaW5nXCIsIFwiY2x1c3RlclwiXS5pbmRleE9mKChfYSA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA+IC0xXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN1Y2Nlc3Mtc3RhdGlzdGljc1wiLCBmaWVsZE5hbWUsIHN0YXRpc3RpY3MpO1xuICAgICAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKHN0YXRpc3RpY3MuYXZnKSB8fFxuICAgICAgICAgICAgICAgICAgICAhaXNEZWZpbmVkKHN0YXRpc3RpY3MubWluKSB8fFxuICAgICAgICAgICAgICAgICAgICAhaXNEZWZpbmVkKHN0YXRpc3RpY3MubWF4KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZCBoYXMgbWF5YmUgbm8gdmFsdWVzOyBzdGF0aXN0aWNzIGlzIHVudXNhYmxlXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmZpZWxkcyA9IHByb3BzLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyBzdGF0aXN0aWNzU3RhdHVzOiBzdGF0dXMuRkFJTEVEIH0pIDogZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3RvZ3JhbU9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGlzdGljcy5taW4gPT09IHN0YXRpc3RpY3MubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0aXN0aWNzLm1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpc3RpY3MubWluID0gc3RhdGlzdGljcy5taW4gLSAwLjEgKiBzdGF0aXN0aWNzLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpc3RpY3MubWF4ID0gc3RhdGlzdGljcy5tYXggKyAwLjEgKiBzdGF0aXN0aWNzLm1heDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0aXN0aWNzLm1pbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpc3RpY3MubWluID0gc3RhdGlzdGljcy5taW4gKyAwLjEgKiBzdGF0aXN0aWNzLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpc3RpY3MubWF4ID0gc3RhdGlzdGljcy5tYXggLSAwLjEgKiBzdGF0aXN0aWNzLm1heDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpc3RpY3MubWluID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aXN0aWNzLm1heCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcHMuZmllbGRzID0gcHJvcHMuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZCksIHsgc3RhdGlzdGljcywgc3RhdGlzdGljc1N0YXR1czogc3RhdHVzLlNVQ0NFU1MgfSkgOiBmaWVsZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0RlZmF1bHRWYWx1ZXMoZmlsdGVyRmllbGQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvZ3JhbSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtQmluczogMzAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5WYWx1ZTogc3RhdGlzdGljcy5taW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZTogc3RhdGlzdGljcy5tYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JCaW5uaW5nOiBmZWF0dXJlUmVkdWN0aW9uICYmIFtcImJpbm5pbmdcIiwgXCJjbHVzdGVyXCJdLmluZGV4T2YoKF9iID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID4gLTFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJzdWNjZXNzLWhpc3RvZ3JhbVwiLCBmaWVsZE5hbWUsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmZpZWxkcyA9IHByb3BzLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyBoaXN0b2dyYW06IHJlc3VsdCwgaGlzdG9ncmFtU3RhdHVzOiBzdGF0dXMuU1VDQ0VTUyB9KSA6IGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImVycm9yLWhpc3RvZ3JhbVwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmZpZWxkcyA9IHByb3BzLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyBoaXN0b2dyYW1TdGF0dXM6IHN0YXR1cy5GQUlMRUQgfSkgOiBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZXJyb3Itc3VtbWFyeVN0YXRpc3RpY3NcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHByb3BzLmZpZWxkcyA9IHByb3BzLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGQpLCB7IHN0YXRpc3RpY3NTdGF0dXM6IHN0YXR1cy5GQUlMRUQsIGhpc3RvZ3JhbVN0YXR1czogc3RhdHVzLkZBSUxFRCB9KSA6IGZpZWxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvZ3JhbU9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25IaXN0b2dyYW1DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5oaXN0b2dyYW1PcGVuID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIG9uTWluTWF4Q2hhbmdlKG1pbiwgbWF4LCBmaWVsZE5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCB2YWx1ZSwgdmFsdWUyLCBoaXN0b2dyYW0gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIHZpZXcsIGZlYXR1cmVSZWR1Y3Rpb24gfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICAgICAgaWYgKCFmaWx0ZXJGaWVsZCB8fCBsYXllci50eXBlID09PSBcImltYWdlcnlcIiB8fCBsYXllci50eXBlID09PSBcInN1YnR5cGUtZ3JvdXBcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZTIpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlMiA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlMiwgbWluKSwgbWF4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvZ3JhbU9wZW4gPSB0cnVlO1xuICAgICAgICBwcm9wcy5maWVsZHMgPSBwcm9wcy5maWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQubGF5ZXJGaWVsZC5uYW1lID09PSBmaWVsZE5hbWVcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZCksIHsgaGlzdG9ncmFtU3RhdHVzOiBzdGF0dXMuSU5fUFJPR1JFU1MgfSkgOiBmaWVsZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoaXN0b2dyYW0oe1xuICAgICAgICAgICAgICAgIGxheWVyLFxuICAgICAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICBudW1CaW5zOiAzMCxcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZTogbWluLFxuICAgICAgICAgICAgICAgIG1heFZhbHVlOiBtYXgsXG4gICAgICAgICAgICAgICAgZm9yQmlubmluZzogZmVhdHVyZVJlZHVjdGlvbiAmJiBbXCJiaW5uaW5nXCIsIFwiY2x1c3RlclwiXS5pbmRleE9mKChfYSA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA+IC0xXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJzdWNjZXNzLWhpc3RvZ3JhbVwiLCByZXN1bHQpO1xuICAgICAgICAgICAgcHJvcHMuZmllbGRzID0gcHJvcHMuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyBoaXN0b2dyYW06IHJlc3VsdCwgaGlzdG9ncmFtU3RhdHVzOiBzdGF0dXMuU1VDQ0VTUyB9KSA6IGZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvci1oaXN0b2dyYW1cIiwgZXJyb3IpO1xuICAgICAgICAgICAgcHJvcHMuZmllbGRzID0gcHJvcHMuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyBoaXN0b2dyYW1TdGF0dXM6IHN0YXR1cy5GQUlMRUQgfSkgOiBmaWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRqdXN0SGlzdG9ncmFtTWluTWF4KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgaGlzdG9ncmFtU2xpZGVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaGlzdG9ncmFtU2xpZGVyKSB7XG4gICAgICAgICAgICBpZiAoaGlzdG9ncmFtU2xpZGVyLm1pbiA+IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaGlzdG9ncmFtU2xpZGVyLnNldCh7IG1pbjogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGlzdG9ncmFtU2xpZGVyLm1heCA8IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaGlzdG9ncmFtU2xpZGVyLnNldCh7IG1heDogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZVNsaWRlcihmaWx0ZXJGaWVsZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IGhpc3RvZ3JhbVNsaWRlckZpZWxkTmFtZTogc2xpZGVyRmllbGROYW1lIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyB2YWx1ZSwgdmFsdWUyLCBoaXN0b2dyYW1TbGlkZXI6IHNsaWRlciB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3RhdGlzdGljcyA9IGZpbHRlckZpZWxkLnN0YXRpc3RpY3M7XG4gICAgICAgIGlmIChmaWx0ZXJGaWVsZC5oaXN0b2dyYW1TdGF0dXMgPT09IHN0YXR1cy5JTl9QUk9HUkVTUykge1xuICAgICAgICAgICAgLy8gbm8gdXBkYXRlcyB0byB0aGUgc2xpZGVyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibm8gc2xpZGVyIHVwZGF0ZXNcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyaW5nIHZhbHVlcyBhcmUgd3JvbmcgaGVyZVxuICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZmluZWQodmFsdWUyKSAmJiB0eXBlb2YgdmFsdWUyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB2YWx1ZTIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0RlZmF1bHRWYWx1ZXMoZmlsdGVyRmllbGQpO1xuICAgICAgICAvLyByZWZyZXNoXG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFsdWUyID0gdGhpcy52YWx1ZTI7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiB2YWx1ZXNcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZTIpKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ludGVnZXJUeXBlKGZpbHRlckZpZWxkKSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91bmRlZFZhbCA9IE1hdGgucm91bmQodmFsdWVzWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAocm91bmRlZFZhbCAhPT0gdmFsdWVzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWVzKHJvdW5kZWRWYWwsIHZhbHVlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlc1swXSA9IHJvdW5kZWRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlc1sxXSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3VuZGVkVmFsID0gTWF0aC5yb3VuZCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgICAgIGlmIChyb3VuZGVkVmFsICE9PSB2YWx1ZXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZXModmFsdWUsIHJvdW5kZWRWYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZXNbMV0gPSByb3VuZGVkVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkanVzdCB0aGUgc2xpZGVyIGlmIHZhbHVlcyBhcmUgb3V0c2lkZSBvZiByYW5nZVxuICAgICAgICBsZXQgbWluID0gZmlsdGVyRmllbGQuaGlzdG9ncmFtID8gZmlsdGVyRmllbGQuaGlzdG9ncmFtLm1pblZhbHVlIDogc3RhdGlzdGljcy5taW47XG4gICAgICAgIGxldCBtYXggPSBmaWx0ZXJGaWVsZC5oaXN0b2dyYW0gPyBmaWx0ZXJGaWVsZC5oaXN0b2dyYW0ubWF4VmFsdWUgOiBzdGF0aXN0aWNzLm1heDtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZXNbMF0pICYmIGlzRGVmaW5lZCh2YWx1ZXNbMV0pKSB7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHZhbHVlc1swXSk7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHZhbHVlc1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEZWZpbmVkKHZhbHVlc1swXSkpIHtcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgdmFsdWVzWzBdKTtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmFsdWVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xpZGVyICYmIHNsaWRlckZpZWxkTmFtZSAhPT0gZmlsdGVyRmllbGQubGF5ZXJGaWVsZC5uYW1lKSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgbWF5YmUgYmVjYXVzZSBvZiBhIGRlbGV0ZWQgZXhwcmVzc2lvbiBvciBjb25kaXRpb25cbiAgICAgICAgICAgIHNsaWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICBzbGlkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzbGlkZXIpIHtcbiAgICAgICAgICAgIC8vIG5ldyBoaXN0b2dyYW1cbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBiaW5zOiAoX2EgPSBmaWx0ZXJGaWVsZC5oaXN0b2dyYW0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5zLFxuICAgICAgICAgICAgICAgIGF2ZXJhZ2U6IE1hdGgucm91bmQoc3RhdGlzdGljcy5hdmcgKiAxMCkgLyAxMCxcbiAgICAgICAgICAgICAgICAvL3N0YW5kYXJkRGV2aWF0aW9uOiBmaWx0ZXJGaWVsZC5zdGF0aXN0aWNzLnN0ZGRldixcbiAgICAgICAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6ICh2YWx1ZXMgPT09IG51bGwgfHwgdmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZXNbMF0pID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgcmFuZ2VUeXBlOiB0aGlzLmdldFNsaWRlclJhbmdlVHlwZSgpLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogaXNJbnRlZ2VyVHlwZShmaWx0ZXJGaWVsZCkgPyAwIDogNFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChbc2ltcGxlRmllbGRUeXBlcy5EQVRFLCBzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0uaW5kZXhPZihmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUpID5cbiAgICAgICAgICAgICAgICAtMSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5oYXNUaW1lRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGREYXRlRm9ybWF0RnVuY3Rpb25zKGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhpc3RvZ3JhbVNsaWRlckZpZWxkTmFtZSA9IGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9ncmFtU2xpZGVyID0gbmV3IHRoaXMuSGlzdG9ncmFtUmFuZ2VTbGlkZXIoY29uZmlnKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJuZXcgSGlzdG9ncmFtUmFuZ2VTbGlkZXJcIiwgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2xpZGVyQ2hhbmdlRXZlbnRzKGZpbHRlckZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBoaXN0b2dyYW0gc2xpZGVyXG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYmluczogKF9iID0gZmlsdGVyRmllbGQuaGlzdG9ncmFtKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmlucyxcbiAgICAgICAgICAgICAgICBhdmVyYWdlOiBNYXRoLnJvdW5kKHN0YXRpc3RpY3MuYXZnICogMTApIC8gMTAsXG4gICAgICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiAodmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzWzBdKSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdmFsdWVzLFxuICAgICAgICAgICAgICAgIHJhbmdlVHlwZTogdGhpcy5nZXRTbGlkZXJSYW5nZVR5cGUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJ1cGRhdGUgSGlzdG9ncmFtUmFuZ2VTbGlkZXJcIiwgY29uZmlnLCB2YWx1ZXMpO1xuICAgICAgICAgICAgc2xpZGVyLnNldChjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjcmVhdGVTbGlkZXJDaGFuZ2VFdmVudHMoZmlsdGVyRmllbGQpIHtcbiAgICAgICAgY29uc3QgeyBoaXN0b2dyYW1TbGlkZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmICghaGlzdG9ncmFtU2xpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGlzdG9ncmFtU2xpZGVyLm9uKFwibWluLWNoYW5nZVwiLCAoZXZlbnQgLypWYWx1ZUNoYW5nZUV2ZW50Ki8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlciA9IGhpc3RvZ3JhbVNsaWRlcjtcbiAgICAgICAgICAgIHRoaXMub25NaW5NYXhDaGFuZ2UoZXZlbnQudmFsdWUsIHNsaWRlci5tYXgsIGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBoaXN0b2dyYW1TbGlkZXIub24oXCJtYXgtY2hhbmdlXCIsIChldmVudCAvKlZhbHVlQ2hhbmdlRXZlbnQqLykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVyID0gaGlzdG9ncmFtU2xpZGVyO1xuICAgICAgICAgICAgdGhpcy5vbk1pbk1heENoYW5nZShzbGlkZXIubWluLCBldmVudC52YWx1ZSwgZmlsdGVyRmllbGQubGF5ZXJGaWVsZC5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhpc3RvZ3JhbVNsaWRlci53YXRjaChcInZhbHVlc1wiLCAoIC8qIHZhbHVlczogbnVtYmVyW10gKi8pID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBzbGlkZXIgPSBoaXN0b2dyYW1TbGlkZXI7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoX2EgPSBzbGlkZXIudmFsdWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG4gICAgICAgICAgICBsZXQgdmFsdWUyID0gKF9iID0gc2xpZGVyLnZhbHVlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzFdO1xuICAgICAgICAgICAgaWYgKFtzaW1wbGVGaWVsZFR5cGVzLkRBVEUsIHNpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5pbmRleE9mKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkgPlxuICAgICAgICAgICAgICAgIC0xKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ludGVnZXJUeXBlKGZpbHRlckZpZWxkKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZTIgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUyID0gTWF0aC5jZWlsKHZhbHVlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWVzKHZhbHVlLCB2YWx1ZTIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaGlzdG9ncmFtU2xpZGVyLm9uKFwic2VnbWVudC1kcmFnXCIsICggLypldmVudDogYW55IFNlZ21lbnREcmFnRXZlbnQqLykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVyID0gaGlzdG9ncmFtU2xpZGVyO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gc2xpZGVyLnZhbHVlc1swXTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTIgPSBzbGlkZXIudmFsdWVzWzFdO1xuICAgICAgICAgICAgaWYgKGlzSW50ZWdlclR5cGUoZmlsdGVyRmllbGQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlMiB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTIgPSBNYXRoLmNlaWwodmFsdWUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZXModmFsdWUsIHZhbHVlMik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRTbGlkZXJSYW5nZVR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIG9wZXJhdG9yIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM6XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzT246XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZXF1YWxcIjtcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdDpcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RPbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJub3QtZXF1YWxcIjtcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0xlc3NUaGFuOlxuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JlZm9yZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJsZXNzLXRoYW5cIjtcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0dyZWF0ZXJUaGFuOlxuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0FmdGVyOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImdyZWF0ZXItdGhhblwiO1xuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRNb3N0OlxuICAgICAgICAgICAgICAgIHJldHVybiBcImF0LW1vc3RcIjtcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TGVhc3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYXQtbGVhc3RcIjtcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JldHdlZW46XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmV0d2VlbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJiZXR3ZWVuXCI7XG4gICAgICAgICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3RCZXR3ZWVuOlxuICAgICAgICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJldHdlZW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibm90LWJldHdlZW5cIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TmV3VmFsdWUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyB2aWV3IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9ICh2aWV3ID09PSBudWxsIHx8IHZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXcudGltZVpvbmUpIHx8IFwic3lzdGVtXCI7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQudGFyZ2V0O1xuICAgICAgICBsZXQgbmV3VmFsdWU7XG4gICAgICAgIGlmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnRhZ05hbWUpID09PSBcIkNBTENJVEUtSU5QVVQtREFURS1QSUNLRVJcIikge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBub2RlLnZhbHVlOyAvL3ZhbHVlQXNEYXRlOyAtPiB2YWx1ZUFzRGF0ZSBzZWVtcyB0byBoYXZlIGEgdGltZSBvZmZzZXRcbiAgICAgICAgICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGRhdGVQaWNrZXJUb1VUQyhuZXcgRGF0ZShuZXdWYWx1ZSksIHRpbWVab25lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnRhZ05hbWUpID09PSBcIkNBTENJVEUtSU5QVVRcIiAmJiBub2RlLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHBhcnNlRmxvYXQobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUudGFnTmFtZSkgPT09IFwiQ0FMQ0lURS1JTlBVVFwiKSB7XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICBpZiAoIShuZXdWYWx1ZSA9PT0gbnVsbCB8fCBuZXdWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV3VmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9XG4gICAgYWRkRGF0ZUZvcm1hdEZ1bmN0aW9ucyhjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyBpbnRsLCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3IH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgdGltZVpvbmUgPSAodmlldyA9PT0gbnVsbCB8fCB2aWV3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3LnRpbWVab25lKSB8fCBcInN5c3RlbVwiO1xuICAgICAgICBjb25maWcubGFiZWxGb3JtYXRGdW5jdGlvbiA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgLy9yZXR1cm4gdGhpcy5zbWFydE1hcHBpbmdVdGlscy5mb3JtYXREYXRlTGFiZWwodXRjVG9NYXBUWih2YWx1ZSwgdGltZVpvbmUpKTtcbiAgICAgICAgICAgIHJldHVybiBnZXREYXRlRGlzcGxheVN0cmluZyh2YWx1ZSwgdGltZVpvbmUsIGludGwsIFwic2hvcnQtZGF0ZVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uZmlnLmlucHV0Rm9ybWF0RnVuY3Rpb24gPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIC8vcmV0dXJuIHRoaXMuc21hcnRNYXBwaW5nVXRpbHMuZm9ybWF0RGF0ZUxhYmVsKHV0Y1RvTWFwVFoodmFsdWUsIHRpbWVab25lKSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RGF0ZURpc3BsYXlTdHJpbmcodmFsdWUsIHRpbWVab25lLCBpbnRsLCBcInNob3J0LWRhdGVcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmZpZy5pbnB1dFBhcnNlRnVuY3Rpb24gPSAodmFsdWUgLyogLCB0eXBlOiBzdHJpbmcsIGluZGV4OiBudW1iZXIgKi8pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtYXBUWlRvVVRDKERhdGUucGFyc2UodmFsdWUpLCB0aW1lWm9uZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoYW5nZVZhbHVlcyh2YWx1ZSwgdmFsdWUyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGZpZWxkTmFtZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlICYmXG4gICAgICAgICAgICBbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVIsIHNpbXBsZUZpZWxkVHlwZXMuREFURSwgc2ltcGxlRmllbGRUeXBlcy5PSURdLmluZGV4T2YoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSA+IC0xXG4gICAgICAgICAgICA/IGlzTmFOKHZhbHVlKVxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlMiA9IGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSAmJlxuICAgICAgICAgICAgW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSLCBzaW1wbGVGaWVsZFR5cGVzLkRBVEUsIHNpbXBsZUZpZWxkVHlwZXMuT0lEXS5pbmRleE9mKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkgPiAtMVxuICAgICAgICAgICAgPyBpc05hTih2YWx1ZTIpXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiB2YWx1ZTJcbiAgICAgICAgICAgIDogdmFsdWUyO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gbmV3VmFsdWUgfHwgdGhpcy52YWx1ZTIgIT09IG5ld1ZhbHVlMikge1xuICAgICAgICAgICAgLy90aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAvL3RoaXMudmFsdWUyID0gbmV3VmFsdWUyO1xuICAgICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSAhPT0gbnVsbCAmJiBuZXdWYWx1ZSAhPT0gdm9pZCAwID8gbmV3VmFsdWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlMjogbmV3VmFsdWUyICE9PSBudWxsICYmIG5ld1ZhbHVlMiAhPT0gdm9pZCAwID8gbmV3VmFsdWUyIDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tEZWZhdWx0VmFsdWVzKGZpbHRlckZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIG9wZXJhdG9yLCB2YWx1ZSwgdmFsdWUyLCBoaXN0b2dyYW1TbGlkZXI6IHNsaWRlciB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3RhdGlzdGljcyA9IGZpbHRlckZpZWxkLnN0YXRpc3RpY3M7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSBnZXREZWZhdWx0VmFsdWVzKHByb3BzLCBmaWx0ZXJGaWVsZCwgb3BlcmF0b3IpO1xuICAgICAgICBpZiAoaXNJblRoZUxhc3RPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IE1hdGguYWJzKG5vdyAtIHN0YXRpc3RpY3MuYXZnKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUsIHVuaXQ7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID4gMiAqIHRpbWVSYW5nZS5ZRUFSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZChyYW5nZSAvIHRpbWVSYW5nZS5ZRUFSKTtcbiAgICAgICAgICAgICAgICAgICAgdW5pdCA9IHRpbWVVbml0cy5ZRUFSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlID4gMiAqIHRpbWVSYW5nZS5NT05USCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHJhbmdlIC8gdGltZVJhbmdlLk1PTlRIKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXQgPSB0aW1lVW5pdHMuTU9OVEg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPiAyICogdGltZVJhbmdlLldFRUspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQocmFuZ2UgLyB0aW1lUmFuZ2UuV0VFSyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdCA9IHRpbWVVbml0cy5XRUVLO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlID4gMiAqIHRpbWVSYW5nZS5EQVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHJhbmdlIC8gdGltZVJhbmdlLkRBWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXQgPSB0aW1lVW5pdHMuREFZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlID4gMiAqIHRpbWVSYW5nZS5IT1VSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQocmFuZ2UgLyB0aW1lUmFuZ2UuSE9VUik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0ID0gdGltZVVuaXRzLkhPVVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQocmFuZ2UgLyB0aW1lUmFuZ2UuTUlOVVRFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXQgPSB0aW1lVW5pdHMuTUlOVVRFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vdGhpcy51bml0ID0gdW5pdDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDaGFuZ2VFdmVudCh7IHZhbHVlLCB1bml0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmV0d2Vlbk9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZTIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZTIgPCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgY29ycmVjdCB0aGUgb25lIHRoYXQgd2FzIGNoYW5nZWQgbGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWRlciAmJiBzbGlkZXIudmFsdWVzWzBdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWVzKHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyh2YWx1ZTIsIHZhbHVlMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgYSBzZWNvbmQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gaXNJbnRlZ2VyVHlwZShmaWx0ZXJGaWVsZCkgPyBNYXRoLnJvdW5kKHN0YXRpc3RpY3MubWF4KSA6IHN0YXRpc3RpY3MubWF4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyh2YWx1ZSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHZhbHVlc1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQodmFsdWUyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBmaWVsZFR5cGVSb3VuZChzdGF0aXN0aWNzID09PSBudWxsIHx8IHN0YXRpc3RpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXRpc3RpY3MuYXZnLCBwcm9wcywgZmlsdGVyRmllbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyh2YWwsIHZhbHVlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyhkZWZhdWx0VmFsdWVzLnZhbHVlLCBkZWZhdWx0VmFsdWVzLnZhbHVlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZXMoZGVmYXVsdFZhbHVlcy52YWx1ZSwgZGVmYXVsdFZhbHVlcy52YWx1ZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1vc3Qgb2YgdGhlIHRpbWVzIGRvbid0IG5lZWQgdGhpcyByZXR1cm5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XG4gICAgfVxuICAgIG9wZW5GaWVsZFBpY2tMaXN0KCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBmaWVsZE5hbWUsIGZpZWxkUGlja0xpc3RTb3J0QnkgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIHZpZXcsIGZlYXR1cmVSZWR1Y3Rpb24gfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBkaXIgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICB0aGlzLmNsb3NlRmlsdGVyUG9wb3ZlcnNIYW5kbGVyKCk7XG4gICAgICAgIGNvbnN0IHBhbmVsTm9kZSA9IHF1ZXJ5UGFyZW50RWxlbWVudCh0aGlzLmhvc3RFbGVtZW50LCBcIiNmaWx0ZXItcGFuZWxcIik7XG4gICAgICAgIGNvbnN0IGNsb3NlTm9kZSA9IHBhbmVsTm9kZS5xdWVyeVNlbGVjdG9yKFwiI2FyY2dpcy1maWx0ZXItY2xvc2VcIik7XG4gICAgICAgIGNvbnN0IG5vZGVXaWR0aCA9IHBhbmVsTm9kZSA9PT0gbnVsbCB8fCBwYW5lbE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhbmVsTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1maWVsZC1waWNrLWxpc3RcIik7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5wb3BvdmVyUHJvcHMgPSBjbG9zZU5vZGVcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogZGlyID09PSBcInJ0bFwiID8gXCJib3R0b20tc3RhcnRcIiA6IFwiYm90dG9tLWVuZFwiLFxuICAgICAgICAgICAgICAgIG9mZnNldERpc3RhbmNlOiAyMCxcbiAgICAgICAgICAgICAgICBvZmZzZXRTa2lkZGluZzogMTUsXG4gICAgICAgICAgICAgICAgcG9pbnRlckRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBvcG92ZXJXaWR0aDogbm9kZVdpZHRoID8gbm9kZVdpZHRoICsgMzAgOiAyODAsXG4gICAgICAgICAgICAgICAgcmVmRWxlbWVudDogY2xvc2VOb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhdmUgYW4gYWN0aW9uIGJhciBpbiBsYXllciB2aWV3IHdoZXJlIGl0IGlzIHVzZWQgd2l0aG91dCBhIGNsb3NlIGJ1dHRvblxuICAgICAgICAgICAgICAgIG9mZnNldERpc3RhbmNlOiAtMSAqIChub2RlV2lkdGggPyBub2RlV2lkdGggLSA1IDogMjE1KSxcbiAgICAgICAgICAgICAgICBvZmZzZXRTa2lkZGluZzogMCxcbiAgICAgICAgICAgICAgICBwb2ludGVyRGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgcG9wb3ZlcldpZHRoOiBub2RlV2lkdGggPyBub2RlV2lkdGggKyAzMCA6IDI4MCxcbiAgICAgICAgICAgICAgICByZWZFbGVtZW50OiBwYW5lbE5vZGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5maWVsZHMgPSB0aGlzLmNyZWF0ZVBpY2tMaXN0RmllbGRzKCk7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3QubWFwVmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5zaG93RmllbGRJbmZvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0LnNob3dGaWVsZE5hbWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0LnNlbGVjdGVkRmllbGRzID0gW2ZpZWxkTmFtZV07XG4gICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5zb3J0QnkgPSBmaWVsZFBpY2tMaXN0U29ydEJ5O1xuICAgICAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3Quc2hvd0ZpZWxkSW5mbyA9ICFmZWF0dXJlUmVkdWN0aW9uO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3QuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc0ZpZWxkUGlja0xpc3REaXNtaXNzZWRcIiwgdGhpcy5maWVsZFBpY2tMaXN0Q2hhbmdlcyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzRmllbGRQaWNrTGlzdFNvcnRCeUNoYW5nZVwiLCAoZXZlbnQpID0+ICh0aGlzLmZpZWxkUGlja0xpc3RTb3J0QnkgPSBldmVudC5kZXRhaWwpKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3QpO1xuICAgICAgICB0aGlzLmRpc2FibGVGaWx0ZXJQYW5lbC5lbWl0KHRydWUpO1xuICAgIH1cbiAgICBjcmVhdGVQaWNrTGlzdEZpZWxkcygpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBmaWVsZHMgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gZmllbGRzLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGQubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICAgIGFsaWFzOiBmaWVsZC5sYWJlbCxcbiAgICAgICAgICAgICAgICB0eXBlOiBmaWVsZC5zaW1wbGVGaWVsZFR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVGaWVsZHNQaWNrTGlzdCgpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlRmlsdGVyUGFuZWwuZW1pdChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3QpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0KTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdCA9IG51bGw7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpZWxkTm9kZS5zZXRGb2N1cygpO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWZ0ZXJGaWVsZFNlbGVjdChuZXdGaWVsZE5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBmaWVsZE5hbWUsIG9wZXJhdG9yLCBoaXN0b2dyYW1PcGVuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBvbGRGaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICAgICAgY29uc3QgbmV3RmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8obmV3RmllbGROYW1lLCBwcm9wcyk7XG4gICAgICAgIC8qIHRoaXMuaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpZWxkTmFtZSA9IG5ld0ZpZWxkTmFtZTtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IGdldE9wZXJhdG9yKHByb3BzLCBvbGRGaWx0ZXJGaWVsZCEsIG5ld0ZpbHRlckZpZWxkISwgb3BlcmF0b3IhKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy52YWx1ZTIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnVuaXF1ZVZhbHVlc1NvcnRCeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oaXN0b2dyYW1PcGVuID1cbiAgICAgICAgICAobmV3RmlsdGVyRmllbGQhLnNpbXBsZUZpZWxkVHlwZSAmJlxuICAgICAgICAgICAgW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSLCBzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLmluZGV4T2YoXG4gICAgICAgICAgICAgIG5ld0ZpbHRlckZpZWxkIS5zaW1wbGVGaWVsZFR5cGVcbiAgICAgICAgICAgICkgPT09IC0xKSB8fFxuICAgICAgICAgIG5ld0ZpbHRlckZpZWxkIS5zdGF0aXN0aWNzU3RhdHVzID09PSBzdGF0dXMuRkFJTEVEXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBoaXN0b2dyYW1PcGVuID09PSBmYWxzZSAmJiBvbGRGaWx0ZXJGaWVsZCEuc3RhdGlzdGljc1N0YXR1cyAhPT0gc3RhdHVzLkZBSUxFRFxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7IC8vIHdoZW4gdW5kZWZpbmVkIHRoZW4gb3BlbiBieSBkZWZhdWx0XG4gICAgICAgICovXG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IG5ld09wZXJhdG9yID0gZ2V0T3BlcmF0b3IkMShwcm9wcywgb2xkRmlsdGVyRmllbGQsIG5ld0ZpbHRlckZpZWxkLCBvcGVyYXRvcik7XG4gICAgICAgIGNvbnN0IGZpbHRlckZpZWxkID0gZ2V0RmllbGRJbmZvKG5ld0ZpZWxkTmFtZSwgcHJvcHMpO1xuICAgICAgICBpZiAoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLlNUUklORyAmJlxuICAgICAgICAgICAgZmlsdGVyRmllbGQudW5pcXVlVmFsdWVzU3RhdHVzID09PSBzdGF0dXMuU1VDQ0VTUyAmJlxuICAgICAgICAgICAgKChfYSA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlSW5mb3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICYmXG4gICAgICAgICAgICBbc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJcywgc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdF0uaW5kZXhPZihuZXdPcGVyYXRvcikgPiAtMSkge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgICAgdmFsdWUgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZUluZm9zWzBdLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZUV2ZW50KHtcbiAgICAgICAgICAgIGhhc0ZvY3VzOiB0cnVlLFxuICAgICAgICAgICAgZmllbGROYW1lOiBuZXdGaWVsZE5hbWUsXG4gICAgICAgICAgICBvcGVyYXRvcjogbmV3T3BlcmF0b3IsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlMjogbnVsbCxcbiAgICAgICAgICAgIHZhbHVlczogbnVsbCxcbiAgICAgICAgICAgIHVuaXF1ZVZhbHVlc1NvcnRCeTogbnVsbCxcbiAgICAgICAgICAgIGhpc3RvZ3JhbU9wZW46IChuZXdGaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgJiZcbiAgICAgICAgICAgICAgICBbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVIsIHNpbXBsZUZpZWxkVHlwZXMuREFURSwgc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLmluZGV4T2YobmV3RmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSA9PT0gLTEpIHx8XG4gICAgICAgICAgICAgICAgbmV3RmlsdGVyRmllbGQuc3RhdGlzdGljc1N0YXR1cyA9PT0gc3RhdHVzLkZBSUxFRFxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogaGlzdG9ncmFtT3BlbiA9PT0gZmFsc2UgJiYgb2xkRmlsdGVyRmllbGQuc3RhdGlzdGljc1N0YXR1cyAhPT0gc3RhdHVzLkZBSUxFRFxuICAgICAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCAvLyB3aGVuIHVuZGVmaW5lZCB0aGVuIG9wZW4gYnkgZGVmYXVsdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1pdENoYW5nZUV2ZW50KG92ZXJ3cml0ZXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyB1aWQsIGZpZWxkTmFtZSwgb3BlcmF0b3IsIHVuaXF1ZVZhbHVlc1NvcnRCeSwgdmFsdWUsIHZhbHVlMiwgdmFsdWVzLCB1bml0LCBoaXN0b2dyYW1PcGVuLCBoYXNGb2N1cyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbmV3Q29uZGl0aW9uID0ge1xuICAgICAgICAgICAgdWlkLFxuICAgICAgICAgICAgZmllbGROYW1lOiBvdmVyd3JpdGVzLmZpZWxkTmFtZSB8fCBmaWVsZE5hbWUsXG4gICAgICAgICAgICBvcGVyYXRvcjogb3ZlcndyaXRlcy5vcGVyYXRvciB8fCBvcGVyYXRvcixcbiAgICAgICAgICAgIHVuaXF1ZVZhbHVlc1NvcnRCeTogb3ZlcndyaXRlcy51bmlxdWVWYWx1ZXNTb3J0QnkgPT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogb3ZlcndyaXRlcy51bmlxdWVWYWx1ZXNTb3J0QnkgfHwgdW5pcXVlVmFsdWVzU29ydEJ5LFxuICAgICAgICAgICAgdmFsdWU6IG92ZXJ3cml0ZXMudmFsdWUgPT09IG51bGwgPyB1bmRlZmluZWQgOiAoX2EgPSBvdmVyd3JpdGVzLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlMjogb3ZlcndyaXRlcy52YWx1ZTIgPT09IG51bGwgPyB1bmRlZmluZWQgOiAoX2IgPSBvdmVyd3JpdGVzLnZhbHVlMikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdmFsdWUyLFxuICAgICAgICAgICAgdmFsdWVzOiBvdmVyd3JpdGVzLnZhbHVlcyA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IG92ZXJ3cml0ZXMudmFsdWVzIHx8IHZhbHVlcyxcbiAgICAgICAgICAgIHVuaXQ6IG92ZXJ3cml0ZXMudW5pdCB8fCB1bml0LFxuICAgICAgICAgICAgaGlzdG9ncmFtT3Blbjogb3ZlcndyaXRlcy5oaXN0b2dyYW1PcGVuID09PSBudWxsID8gdW5kZWZpbmVkIDogb3ZlcndyaXRlcy5oaXN0b2dyYW1PcGVuIHx8IGhpc3RvZ3JhbU9wZW4sXG4gICAgICAgICAgICBoYXNGb2N1czogb3ZlcndyaXRlcy5oYXNGb2N1cyB8fCBoYXNGb2N1c1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlckNvbmRpdGlvbkNoYW5nZWQuZW1pdChuZXdDb25kaXRpb24pO1xuICAgIH1cbiAgICB3YWl0T25Vc2VyKGV2ZW50LCBkb0NoYW5nZSkge1xuICAgICAgICAvLyBmb3IgbnVtYmVyIGZpZWxkcyB3ZSBkb24ndCB3YW50IHRvIGFsbG93IGFuIGVtcHR5IHZhbHVlXG4gICAgICAgIC8vIGJ1dCB0aGUgdXNlciBtaWdodCBzaG9ydGx5IHVzZSBhbiBlbXB0eSBpbnB1dCBib3hcbiAgICAgICAgLy8gd2hpbGUgdHlwaW5nIGEgbmV3IHZhbHVlXG4gICAgICAgIGlmICh0aGlzLnR5cGluZ0huZGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnR5cGluZ0huZGwpO1xuICAgICAgICAgICAgdGhpcy50eXBpbmdIbmRsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGNvbnN0IHZhbCA9IG5vZGUudmFsdWU7XG4gICAgICAgIGNvbnN0IHBhcnNlZFZhbCA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvciBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIC8vIHVzZXIgbWlnaHQgYmUgaW4gdGhlIG1pZGRsZSBvZiB0eXBpbmdcbiAgICAgICAgICAgIC8vIGdpdmUgdGhlIHVzZXIgMiBzZWNvbmRzIHRvIGZpbGwgaW4gZW1wdHkgZW50cnlcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBnbyBiYWNrIHRvIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICAgIHRoaXMudHlwaW5nSG5kbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwaW5nSG5kbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBkb0NoYW5nZShldmVudCk7XG4gICAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWxbMF0gIT09IFwiLVwiIHx8IChwYXJzZWRWYWwgIT09IDAgJiYgIWlzTmFOKHBhcnNlZFZhbCkpKSB7XG4gICAgICAgICAgICAvLyBub3QgJy0nLCAnLTAnLCAnLTAuJywgJy0wLjAnLCAuLi5cbiAgICAgICAgICAgIGRvQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgfSAvLyBlbHNlIGRvbid0IHVwZGF0ZSBhbnl0aGluZzsgaXQncyBzdGlsbCBrZWVwaW5nIGxhc3QgdmFsdWVcbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc0ZpbHRlckNvbmRpdGlvbi5zdHlsZSA9IGFyY2dpc0ZpbHRlckNvbmRpdGlvbkNzcztcblxuY29uc3QgQ1NTJDEgPSB7XG4gICAgYWRkQ29uZGl0aW9uQnV0dG9uOiBcImFkZC1jb25kaXRpb24tYnV0dG9uXCIsXG4gICAgY29udGVudDogXCJjb250ZW50XCIsXG4gICAgY29uZGl0aW9uSGVhZGVyOiBcImNvbmRpdGlvbi1oZWFkZXJcIixcbiAgICBtYXRjaFR5cGVUZXh0OiBcIm1hdGNoLXR5cGUtdGV4dFwiLFxuICAgIG1hdGNoQ29uZGl0aW9uOiBcIm1hdGNoLWNvbmRpdGlvblwiLFxuICAgIG1hdGNoQ29uZGl0aW9uRHJvcGRvd246IFwibWF0Y2gtY29uZGl0aW9uLWRyb3Bkb3duXCJcbn07XG5cbmNvbnN0IGFyY2dpc0ZpbHRlckV4cHJlc3Npb25Dc3MgPSBcIi5jb250ZW50LnNjLWFyY2dpcy1maWx0ZXItZXhwcmVzc2lvbntwYWRkaW5nLWJvdHRvbTo2cHh9LmNvbmRpdGlvbi1oZWFkZXIuc2MtYXJjZ2lzLWZpbHRlci1leHByZXNzaW9ue2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7YWxpZ24taXRlbXM6Y2VudGVyO21hcmdpbjowIDZweH0ubWF0Y2gtdHlwZS10ZXh0LnNjLWFyY2dpcy1maWx0ZXItZXhwcmVzc2lvbnttYXJnaW46MCBhdXRvfS5tYXRjaC1jb25kaXRpb24uc2MtYXJjZ2lzLWZpbHRlci1leHByZXNzaW9ue21hcmdpbjowIDZweH0ubWF0Y2gtY29uZGl0aW9uLWRyb3Bkb3duLnNjLWFyY2dpcy1maWx0ZXItZXhwcmVzc2lvbnt3aWR0aDoxMDAlfS5hZGQtY29uZGl0aW9uLWJ1dHRvbi5zYy1hcmNnaXMtZmlsdGVyLWV4cHJlc3Npb257ZGlzcGxheTpmbGV4fVwiO1xuXG5jb25zdCBBcmNnaXNGaWx0ZXJFeHByZXNzaW9uID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJFeHByZXNzaW9uQ2hhbmdlZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRmlsdGVyRXhwcmVzc2lvbkNoYW5nZWRcIiwgNyk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vXG4gICAgICAgIC8vICBQcml2YXRlIG1ldGhvZHNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5vbkFkZENvbmRpdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGNvbmRpdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0RmllbGQgPSBnZXREZWZhdWx0RmllbGQocHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdE9wZXJhdG9yID0gZ2V0RGVmYXVsdE9wZXJhdG9yKHByb3BzLCBkZWZhdWx0RmllbGQpO1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IGdldERlZmF1bHRWYWx1ZXMocHJvcHMsIGRlZmF1bHRGaWVsZCwgZGVmYXVsdE9wZXJhdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbmRpdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGZpZWxkTmFtZTogZGVmYXVsdEZpZWxkLmxheWVyRmllbGQubmFtZSwgb3BlcmF0b3I6IGdldERlZmF1bHRPcGVyYXRvcihwcm9wcywgZGVmYXVsdEZpZWxkKSB9LCBkZWZhdWx0VmFsdWVzKSwgeyBoYXNGb2N1czogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbmRpdGlvbnMuZm9yRWFjaCgoY29uZCkgPT4gKGNvbmQuaGFzRm9jdXMgPSBmYWxzZSkpO1xuICAgICAgICAgICAgdGhpcy5jb25kaXRpb25zID0gWy4uLmNvbmRpdGlvbnMsIG5ld0NvbmRpdGlvbl07XG4gICAgICAgICAgICBwcm9wcy5leHByZXNzaW9ucyA9IHByb3BzLmV4cHJlc3Npb25zLm1hcCgoZXhwcmVzc2lvbikgPT4gZXhwcmVzc2lvbi51aWQgPT09IHRoaXMudWlkXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4cHJlc3Npb24pLCB7IGNvbmRpdGlvbnM6IHRoaXMuY29uZGl0aW9ucyB9KSA6IE9iamVjdC5hc3NpZ24oe30sIGV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgIHRoaXMuZml4VUlEc0ZvckV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIHRoaXMubWVudU5vZGUub3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblJlbW92ZUNvbmRpdGlvbiA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgY29uZGl0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbklkeCA9IHBhcnNlSW50KGFjdGlvbi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpKTtcbiAgICAgICAgICAgIGNvbmRpdGlvbnMuZm9yRWFjaCgoY29uZCkgPT4gKGNvbmQuaGFzRm9jdXMgPSBmYWxzZSkpO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWRJZHggPSAwO1xuICAgICAgICAgICAgdGhpcy5jb25kaXRpb25zID0gY29uZGl0aW9ucy5maWx0ZXIoKGNvbmQsIGlkeDIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZCAmJiBpZHgyID09PSBjb25kaXRpb25JZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZElkeCA9IGlkeDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uc1tNYXRoLm1heCgwLCByZW1vdmVkSWR4IC0gMSldLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHByb3BzLmV4cHJlc3Npb25zID0gcHJvcHMuZXhwcmVzc2lvbnMubWFwKChleHByZXNzaW9uKSA9PiBleHByZXNzaW9uLnVpZCA9PT0gdGhpcy51aWRcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwcmVzc2lvbiksIHsgY29uZGl0aW9uczogdGhpcy5jb25kaXRpb25zIH0pIDogT2JqZWN0LmFzc2lnbih7fSwgZXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgdGhpcy5maXhVSURzRm9yRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbk1hdGNoU2VsZWN0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBuZXdNYXRjaCA9IHNlbGVjdC5zZWxlY3RlZE9wdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucyA9IG5ld01hdGNoO1xuICAgICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkNvcHlFeHByZXNzaW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB1aWQsIGNvbmRpdGlvbnMsIGxvZ2ljYWxPcGVyYXRvckZvckNvbmRpdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RXhwcmVzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICB1aWQsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICBsb2dpY2FsT3BlcmF0b3JGb3JDb25kaXRpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5tZW51Tm9kZS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlckV4cHJlc3Npb25DaGFuZ2VkLmVtaXQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29weVwiLFxuICAgICAgICAgICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogY3VycmVudEV4cHJlc3Npb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUmVtb3ZlRXhwcmVzc2lvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyRXhwcmVzc2lvbkNoYW5nZWQuZW1pdCh7IHR5cGU6IFwiZGVsZXRlXCIsIHVpZDogdGhpcy51aWQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudWlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYW5SZW1vdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbkR1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hvd0FkZENvbmRpdGlvbkJ1dHRvbiA9IGZhbHNlO1xuICAgIH1cbiAgICBhcmNnaXNGaWx0ZXJDb25kaXRpb25DaGFuZ2VIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgY29uZGl0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZXRhaWw6IG5ld0NvbmRpdGlvbiB9ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuY29uZGl0aW9ucyA9IGNvbmRpdGlvbnMubWFwKChjb25kaXRpb24pID0+IGNvbmRpdGlvbi51aWQgPT09IG5ld0NvbmRpdGlvbi51aWQgPyBuZXdDb25kaXRpb24gOiBjb25kaXRpb24gLy97IC4uLmNvbmRpdGlvbiB9XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25zID0gdGhpcy5jb25kaXRpb25zIHx8IFtdO1xuICAgICAgICBjb25zdCBbZXNyaUxhbmddID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9jb3JlL2xhbmdcIl0pO1xuICAgICAgICB0aGlzLmVzcmlMYW5nID0gZXNyaUxhbmc7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGNvbmRpdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IGRpciA9PT0gXCJydGxcIlxuICAgICAgICAgICAgfSwgZGlyOiBkaXIgfSwgaChcImNhbGNpdGUtYmxvY2tcIiwgeyBoZWFkaW5nOiBjb25kaXRpb25zLmxlbmd0aCA9PT0gMSA/IHN0cmluZ3MuZXhwcmVzc2lvbiA6IHN0cmluZ3MuZXhwcmVzc2lvblNldCwgb3BlbjogdHJ1ZSB9LCB0aGlzLnJlbmRlck1lbnUoKSwgdGhpcy5yZW5kZXJNYXRjaENvbmRpdGlvbigpLCB0aGlzLnJlbmRlckNvbmRpdGlvbnMoKSwgdGhpcy5yZW5kZXJBZGRDb25kaXRpb25CdXR0b24oKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyTWVudSgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgY2FuRHVwbGljYXRlLCBjYW5SZW1vdmUsIGNvbmRpdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYWN0aW9uLW1lbnVcIiwgeyBzbG90OiBcImNvbnRyb2xcIiwgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIiwgb3ZlcmxheVBvc2l0aW9uaW5nOiBcImZpeGVkXCIsIGxhYmVsOiBzdHJpbmdzLmFjY2Vzc2liaWxpdHkubW9yZU9wdGlvbnMsIHJlZjogKG5vZGUpID0+ICh0aGlzLm1lbnVOb2RlID0gbm9kZSkgfSwgY2FuUmVtb3ZlICYmIChoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyB0ZXh0OiBjb25kaXRpb25zLmxlbmd0aCA9PT0gMSA/IHN0cmluZ3MuZGVsZXRlRXhwcmVzc2lvbiA6IHN0cmluZ3MuZGVsZXRlU2V0LCB0ZXh0RW5hYmxlZDogdHJ1ZSwgXCJkYXRhLXZhbHVlXCI6IFwicmVtb3ZlXCIsIG9uQ2xpY2s6IHRoaXMub25SZW1vdmVFeHByZXNzaW9uIH0pKSwgY2FuRHVwbGljYXRlICYmIChoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyB0ZXh0OiBzdHJpbmdzLmR1cGxpY2F0ZSwgdGV4dEVuYWJsZWQ6IHRydWUsIFwiZGF0YS12YWx1ZVwiOiBcImNvcHlcIiwgb25DbGljazogdGhpcy5vbkNvcHlFeHByZXNzaW9uIH0pKSwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgdGV4dDogc3RyaW5ncy5hZGRDb25kaXRpb24sIHRleHRFbmFibGVkOiB0cnVlLCBcImRhdGEtdmFsdWVcIjogXCJhZGRcIiwgb25DbGljazogdGhpcy5vbkFkZENvbmRpdGlvbiB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJNYXRjaENvbmRpdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBjb25kaXRpb25zLCBsb2dpY2FsT3BlcmF0b3JGb3JDb25kaXRpb25zLCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFjb25kaXRpb25zIHx8ICFjb25kaXRpb25zLmxlbmd0aCB8fCBjb25kaXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBbmQgPSBsb2dpY2FsT3BlcmF0b3JGb3JDb25kaXRpb25zICE9PSBsb2dpY2FsT3BlcmF0b3JzLk9SO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEubWF0Y2hDb25kaXRpb24gfSwgaChcImNhbGNpdGUtc2VsZWN0XCIsIHsgd2lkdGg6IFwiZnVsbFwiLCBzY2FsZTogXCJtXCIsIGxhYmVsOiBzdHJpbmdzLmFjY2Vzc2liaWxpdHkubWF0Y2hDb25kaXRpb25zLCBjbGFzczogQ1NTJDEubWF0Y2hDb25kaXRpb25Ecm9wZG93biwgb25DYWxjaXRlU2VsZWN0Q2hhbmdlOiB0aGlzLm9uTWF0Y2hTZWxlY3QgfSwgaChcImNhbGNpdGUtb3B0aW9uXCIsIHsgdmFsdWU6IGxvZ2ljYWxPcGVyYXRvcnMuQU5ELCBsYWJlbDogc3RyaW5ncy5tYXRjaEFsbENvbmRpdGlvbnMsIHNlbGVjdGVkOiBpc0FuZCB9KSwgaChcImNhbGNpdGUtb3B0aW9uXCIsIHsgdmFsdWU6IGxvZ2ljYWxPcGVyYXRvcnMuT1IsIGxhYmVsOiBzdHJpbmdzLm1hdGNoQXRMZWFzdE9uZUNvbmRpdGlvbiwgc2VsZWN0ZWQ6ICFpc0FuZCB9KSkpKTtcbiAgICB9XG4gICAgcmVuZGVyQ29uZGl0aW9ucygpIHtcbiAgICAgICAgY29uc3QgeyBjb25kaXRpb25zIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEuY29udGVudCB9LCBjb25kaXRpb25zLm1hcCgoY29uZGl0aW9uUHJvcHMsIGlkeCkgPT4gdGhpcy5yZW5kZXJDb25kaXRpb24oY29uZGl0aW9uUHJvcHMsIGlkeCkpKSk7XG4gICAgfVxuICAgIHJlbmRlckNvbmRpdGlvbihjb25kaXRpb25Qcm9wcywgY29uZGl0aW9uSW5kZXgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIHRoaXMucmVuZGVyQ29uZGl0aW9uSGVhZGVyKGNvbmRpdGlvbkluZGV4KSwgaChcImFyY2dpcy1maWx0ZXItY29uZGl0aW9uXCIsIE9iamVjdC5hc3NpZ24oeyBwcm9wczogcHJvcHMgfSwgY29uZGl0aW9uUHJvcHMpKSkpO1xuICAgIH1cbiAgICByZW5kZXJBZGRDb25kaXRpb25CdXR0b24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zaG93QWRkQ29uZGl0aW9uQnV0dG9uICYmIChoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhbGlnbm1lbnQ6IFwiY2VudGVyXCIsIGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgY2xhc3M6IENTUyQxLmFkZENvbmRpdGlvbkJ1dHRvbiwgXCJpY29uLXN0YXJ0XCI6IFwicGx1c1wiLCBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IHRoaXMub25BZGRDb25kaXRpb24gfSwgdGhpcy5wcm9wcy5zdHJpbmdzLmFkZENvbmRpdGlvbikpKTtcbiAgICB9XG4gICAgcmVuZGVyQ29uZGl0aW9uSGVhZGVyKGNvbmRpdGlvbkluZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGxvZ2ljYWxPcGVyYXRvckZvckNvbmRpdGlvbnMsIGNvbmRpdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgICAgIGlmIChjb25kaXRpb25zLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQW5kID0gbG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucyAhPT0gbG9naWNhbE9wZXJhdG9ycy5PUjtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQxLmNvbmRpdGlvbkhlYWRlciB9LCBjb25kaXRpb25JbmRleCA+IDAgPyAoaChcInNwYW5cIiwgeyBjbGFzczogQ1NTJDEubWF0Y2hUeXBlVGV4dCB9LCBpc0FuZCA/IHN0cmluZ3MuYW5kIDogc3RyaW5ncy5vcikpIDogbnVsbCwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgbGFiZWw6IHN0cmluZ3MucmVtb3ZlLCB0ZXh0OiBcIlwiLCBpY29uOiBcInhcIiwgY29tcGFjdDogdHJ1ZSwgXCJkYXRhLXZhbHVlXCI6IGAke2NvbmRpdGlvbkluZGV4fWAsIG9uQ2xpY2s6IHRoaXMub25SZW1vdmVDb25kaXRpb24gfSkpKTtcbiAgICB9XG4gICAgZml4VUlEc0ZvckV4cHJlc3Npb24oKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHByb3BzLmV4cHJlc3Npb25zID0gZml4VUlEcyhwcm9wcy5leHByZXNzaW9ucyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9ucyA9IHByb3BzLmV4cHJlc3Npb25zLmZpbHRlcigoZXhwcmVzc2lvbikgPT4gZXhwcmVzc2lvbi51aWQgPT09IHRoaXMudWlkKVswXS5jb25kaXRpb25zO1xuICAgIH1cbiAgICBlbWl0Q2hhbmdlRXZlbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgdWlkLCBjb25kaXRpb25zLCBsb2dpY2FsT3BlcmF0b3JGb3JDb25kaXRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBuZXdFeHByZXNzaW9uID0ge1xuICAgICAgICAgICAgdWlkLFxuICAgICAgICAgICAgY29uZGl0aW9ucyxcbiAgICAgICAgICAgIGxvZ2ljYWxPcGVyYXRvckZvckNvbmRpdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJFeHByZXNzaW9uQ2hhbmdlZC5lbWl0KHsgdHlwZTogXCJyZXBsYWNlXCIsIGV4cHJlc3Npb246IG5ld0V4cHJlc3Npb24gfSk7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNGaWx0ZXJFeHByZXNzaW9uLnN0eWxlID0gYXJjZ2lzRmlsdGVyRXhwcmVzc2lvbkNzcztcblxuY29uc3QgQ1NTID0ge1xuICAgIGNvbnRhaW5lcjogXCJjb250YWluZXJcIixcbiAgICBwaWNrTGlzdDogXCJwb3BvdmVyLXVuaXF1ZS1waWNrLWxpc3RcIixcbiAgICB1bmlxdWVWYWx1ZXNDb250ZW50TGlzdE1zZzogXCJ1bmlxdWUtdmFsdWVzLWNvbnRlbnQtbGlzdC1tc2dcIixcbiAgICBjb3VudDogXCJjb3VudFwiLFxuICAgIHVuaXF1ZVZhbHVlc0RvbmU6IFwidW5pcXVlLXZhbHVlcy1kb25lXCJcbn07XG5cbmNvbnN0IGFyY2dpc0ZpbHRlclVuaXF1ZUxpc3RDc3MgPSBcIi5zYy1hcmNnaXMtZmlsdGVyLXVuaXF1ZS1saXN0LWh7d2lkdGg6MTAwJX0uY29udGFpbmVyLnNjLWFyY2dpcy1maWx0ZXItdW5pcXVlLWxpc3R7bWluLWhlaWdodDozMHB4fS5wb3BvdmVyLXVuaXF1ZS1waWNrLWxpc3Quc2MtYXJjZ2lzLWZpbHRlci11bmlxdWUtbGlzdHt3aWR0aDoxMDAlO292ZXJmbG93LXk6YXV0b30udW5pcXVlLXZhbHVlcy1jb250ZW50LWxpc3QtbXNnLnNjLWFyY2dpcy1maWx0ZXItdW5pcXVlLWxpc3R7Zm9udC1zaXplOjc1JTttYXJnaW46NXB4fS5jb3VudC5zYy1hcmNnaXMtZmlsdGVyLXVuaXF1ZS1saXN0e3BhZGRpbmc6MTJweCA2cHh9LnVuaXF1ZS12YWx1ZXMtZG9uZS5zYy1hcmNnaXMtZmlsdGVyLXVuaXF1ZS1saXN0e3BhZGRpbmc6MC41cmVtfVwiO1xuXG5jb25zdCBBcmNnaXNGaWx0ZXJVbmlxdWVMaXN0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJVbmlxdWVMaXN0RG9uZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRmlsdGVyVW5pcXVlTGlzdERvbmVcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyVW5pcXVlTGlzdENoYW5nZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlclVuaXF1ZUxpc3RDaGFuZ2VkXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlclVuaXF1ZUxpc3RTb3J0QnlDaGFuZ2VkID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNGaWx0ZXJVbmlxdWVMaXN0U29ydEJ5Q2hhbmdlZFwiLCA3KTtcbiAgICAgICAgdGhpcy5vblNvcnRNZW51U2VsZWN0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBkcm9wZG93biA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gKF9hID0gZHJvcGRvd24uc2VsZWN0ZWRJdGVtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIik7XG4gICAgICAgICAgICB0aGlzLnNvcnRCeSA9IHR5cGU7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlclVuaXF1ZUxpc3RTb3J0QnlDaGFuZ2VkLmVtaXQoeyB1aWQ6IHRoaXMudWlkLCBzb3J0Qnk6IHR5cGUgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyVW5pcXVlTGlzdERvbmUuZW1pdCh0aGlzLnVpZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudWlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnByb3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnVuaXF1ZVZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5maWVsZERvbWFpbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGF5ZXJGaWVsZFR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNEYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNvcnRCeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tdWx0aXBsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYXJ0aWFsVW5pcXVlVmFsdWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQdWJsaWMgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBzZXRGb2N1cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnBpY2tMaXN0Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgY29uc3QgW2ludGxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9pbnRsXCJdKTtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5pbnRsLnNldExvY2FsZSh0aGlzLmxvY2FsZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIC8vdGhpcy5zZXRGb2N1cygpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgLy90aGlzLnJlbW92ZUZpZWxkc1BpY2tMaXN0KCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgdWlkLCB1bmlxdWVWYWx1ZXMsIHNlbGVjdGVkVmFsdWVzLCBsYXllckZpZWxkVHlwZSwgZmllbGREb21haW5zLCBzb3J0QnksIG11bHRpcGxlLCBwYXJ0aWFsVW5pcXVlVmFsdWVzLCBtYXhIZWlnaHQsIHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNvcnRCeUNvdW50ID0gKGxpc3QpID0+IHtcbiAgICAgICAgICAgIGxpc3Quc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmNvdW50IDw9IGIuY291bnQgPyAxIDogLTE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc29ydEFscGhhYmV0aWNhbGx5ID0gKGxpc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc0RvbWFpbnMgPSBmaWVsZERvbWFpbnMgPT09IG51bGwgfHwgZmllbGREb21haW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZERvbWFpbnMubGVuZ3RoO1xuICAgICAgICAgICAgbGlzdC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVBID0gaGFzRG9tYWlucyA/IHRoaXMuZ2V0RGVjb2RlZFZhbHVlKGEudmFsdWUpIDogYS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUIgPSBoYXNEb21haW5zID8gdGhpcy5nZXREZWNvZGVkVmFsdWUoYi52YWx1ZSkgOiBiLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt2YWx1ZUF9YC5jaGFyQXQoMCkgPT09IFwiX1wiXG4gICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICA6IGAke3ZhbHVlQn1gLmNoYXJBdCgwKSA9PT0gXCJfXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYCR7dmFsdWVBfWAubG9jYWxlQ29tcGFyZShgJHt2YWx1ZUJ9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc29ydFNlbGVjdGVkID0gKGxpc3QsIHZhbHVlcykgPT4ge1xuICAgICAgICAgICAgbGlzdC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NBID0gKF9hID0gdmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLmluZGV4T2YoYS52YWx1ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc0IgPSAoX2IgPSB2YWx1ZXMgPT09IG51bGwgfHwgdmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZXMuaW5kZXhPZihiLnZhbHVlKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogLTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc0EgPT09IHBvc0IgfHwgKHBvc0EgPiAtMSAmJiBwb3NCID4gLTEpID8gMCA6IHBvc0EgPiBwb3NCID8gLTEgOiAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHNvcnRBbHBoYWJldGljYWxseSh1bmlxdWVWYWx1ZXMpO1xuICAgICAgICBpZiAoIXNvcnRCeSB8fCBzb3J0QnkgPT09IFwiY291bnRcIikge1xuICAgICAgICAgICAgc29ydEJ5Q291bnQodW5pcXVlVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3J0QnkgPT09IFwic2VsZWN0ZWRcIikge1xuICAgICAgICAgICAgc29ydFNlbGVjdGVkKHVuaXF1ZVZhbHVlcywgc2VsZWN0ZWRWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpc3QgPSB1bmlxdWVWYWx1ZXMubWFwKChpbmZvKSA9PiB0aGlzLnJlbmRlclVuaXF1ZVZhbHVlKGluZm8pKTtcbiAgICAgICAgbGV0IG1zZ05vZGU7XG4gICAgICAgIGlmIChwYXJ0aWFsVW5pcXVlVmFsdWVzKSB7XG4gICAgICAgICAgICBtc2dOb2RlID0gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLnVuaXF1ZVZhbHVlc0NvbnRlbnRMaXN0TXNnIH0sIHN0cmluZ3MuZXJyb3JzLnRvb01hbnlVbmlxdWVWYWx1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGFpbmVyIH0sIGgoXCJjYWxjaXRlLXBpY2stbGlzdFwiLCB7IGNsYXNzOiBDU1MucGlja0xpc3QsIGZpbHRlckVuYWJsZWQ6IHVuaXF1ZVZhbHVlcy5sZW5ndGggPiAxMCwgbXVsdGlwbGU6IG11bHRpcGxlLCBcImZpbHRlci1wbGFjZWhvbGRlclwiOiBzdHJpbmdzLnNlYXJjaFZhbHVlcywgb25DYWxjaXRlTGlzdENoYW5nZTogYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWRWYWx1ZXMgPSBbLi4uKGF3YWl0IG5vZGUuZ2V0U2VsZWN0ZWRJdGVtcygpKS5rZXlzKCldO1xuICAgICAgICAgICAgICAgIGlmIChsYXllckZpZWxkVHlwZSA9PT0gXCJkYXRlLW9ubHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IHNlbGVjdGVkVmFsdWVzID09PSBudWxsIHx8IHNlbGVjdGVkVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZFZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGRhdGUgc3RyaW5nIHRvIFVOSVggdGltZXN0YW1wICh3aXRob3V0IHRpbWVzdGFtcCBvZmZzZXQgc2hpZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChbXCJkYXRlXCIsIFwib2lkXCIsIFwiZ3VpZFwiLCBcInNtYWxsLWludGVnZXJcIiwgXCJiaWctaW50ZWdlclwiLCBcImludGVnZXJcIiwgXCJsb25nXCJdLmluZGV4T2YobGF5ZXJGaWVsZFR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBzZWxlY3RlZFZhbHVlcyA9PT0gbnVsbCB8fCBzZWxlY3RlZFZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWRWYWx1ZXMubWFwKCh2YWx1ZSkgPT4gcGFyc2VJbnQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoW1wic2luZ2xlXCIsIFwiZG91YmxlXCJdLmluZGV4T2YobGF5ZXJGaWVsZFR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBzZWxlY3RlZFZhbHVlcyA9PT0gbnVsbCB8fCBzZWxlY3RlZFZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWRWYWx1ZXMubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWVzID0gc2VsZWN0ZWRWYWx1ZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJVbmlxdWVMaXN0Q2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgdWlkLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNvcnRCeVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGlja0xpc3ROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYG1heC1oZWlnaHQ6ICR7bWF4SGVpZ2h0IHx8IDQwMH1weGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gfSwgdW5pcXVlVmFsdWVzLmxlbmd0aCA+IDEwID8gdGhpcy5yZW5kZXJTb3J0KCkgOiBudWxsLCBsaXN0KSwgbXNnTm9kZSwgdGhpcy5yZW5kZXJEb25lKCkpKSk7XG4gICAgfVxuICAgIHJlbmRlclNvcnQoKSB7XG4gICAgICAgIGNvbnN0IHsgc29ydEJ5LCBzdHJpbmdzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWRyb3Bkb3duXCIsIHsgc2xvdDogXCJtZW51LWFjdGlvbnNcIiwgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIiwgb3ZlcmxheVBvc2l0aW9uaW5nOiBcImZpeGVkXCIsIHdpZHRoU2NhbGU6IFwic1wiLCBvbkNhbGNpdGVEcm9wZG93blNlbGVjdDogdGhpcy5vblNvcnRNZW51U2VsZWN0IH0sIGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IHNsb3Q6IFwidHJpZ2dlclwiLCBsYWJlbDogc3RyaW5ncy5zb3J0VmFsdWVzLCB0ZXh0OiBcIlwiIH0sIGgoXCJjYWxjaXRlLWljb25cIiwgeyBzY2FsZTogXCJzXCIsIGljb246IFwic29ydERlc2NlbmRpbmdcIiB9KSksIGgoXCJjYWxjaXRlLWRyb3Bkb3duLWdyb3VwXCIsIG51bGwsIGgoXCJjYWxjaXRlLWRyb3Bkb3duLWl0ZW1cIiwgeyBzZWxlY3RlZDogc29ydEJ5ID09PSBcImNvdW50XCIgfHwgIWlzRGVmaW5lZChzb3J0QnkpLCBcImRhdGEtdmFsdWVcIjogXCJjb3VudFwiIH0sIHN0cmluZ3Muc29ydEJ5Q291bnQpLCBoKFwiY2FsY2l0ZS1kcm9wZG93bi1pdGVtXCIsIHsgc2VsZWN0ZWQ6IHNvcnRCeSA9PT0gXCJuYW1lXCIsIFwiZGF0YS12YWx1ZVwiOiBcIm5hbWVcIiB9LCBzdHJpbmdzLnNvcnRBbHBoYWJldGljYWwpLCBoKFwiY2FsY2l0ZS1kcm9wZG93bi1pdGVtXCIsIHsgc2VsZWN0ZWQ6IHNvcnRCeSA9PT0gXCJzZWxlY3RlZFwiLCBcImRhdGEtdmFsdWVcIjogXCJzZWxlY3RlZFwiIH0sIHN0cmluZ3Muc29ydFNlbGVjdGVkKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyVW5pcXVlVmFsdWUoaW5mbykge1xuICAgICAgICBjb25zdCB7IHNlbGVjdGVkVmFsdWVzLCBmaWVsZERvbWFpbnMsIGxheWVyRmllbGRUeXBlLCBpc0RhdGUsIGludGwsIHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB0aW1lWm9uZSA9ICh2aWV3ID09PSBudWxsIHx8IHZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXcudGltZVpvbmUpIHx8IFwic3lzdGVtXCI7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKGZpZWxkRG9tYWlucyA9PT0gbnVsbCB8fCBmaWVsZERvbWFpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkRG9tYWlucy5sZW5ndGgpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0RGVjb2RlZFZhbHVlKGluZm8udmFsdWUpXG4gICAgICAgICAgICA6IGlzRGF0ZVxuICAgICAgICAgICAgICAgID8gbGF5ZXJGaWVsZFR5cGUgPT09IFwiZGF0ZS1vbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmdldERhdGVPbmx5U3RyaW5nKGluZm8udmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0RGF0ZURpc3BsYXlTdHJpbmcoaW5mby52YWx1ZSwgdGltZVpvbmUsIGludGwpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgaW5mby52YWx1ZSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICA/IGludGwuZm9ybWF0TnVtYmVyKGluZm8udmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaW5mby52YWx1ZTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWVzID8gc2VsZWN0ZWRWYWx1ZXMuaW5kZXhPZihpbmZvLnZhbHVlKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtcGljay1saXN0LWl0ZW1cIiwgeyBrZXk6IGBwaWNrLWxpc3QtaXRlbV8ke2luZm8udmFsdWV9YCwgbGFiZWw6IGAke3ZhbHVlfWAsIHZhbHVlOiBgJHtpbmZvLnZhbHVlfWAsIHNlbGVjdGVkOiBpc1NlbGVjdGVkIH0sIGlzRGVmaW5lZChpbmZvLmNvdW50KSA/IChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb3VudCwgc2xvdDogXCJhY3Rpb25zLWVuZFwiIH0sIGAke2luZm8uY291bnR9YCkpIDogbnVsbCkpO1xuICAgIH1cbiAgICByZW5kZXJEb25lKCkge1xuICAgICAgICBjb25zdCB7IG11bHRpcGxlLCBzdHJpbmdzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLnVuaXF1ZVZhbHVlc0RvbmUgfSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwgd2lkdGg6IFwiZnVsbFwiLCBvbkNsaWNrOiB0aGlzLmRvbmUsIGxhYmVsOiBzdHJpbmdzLmRvbmUgfSwgc3RyaW5ncy5kb25lKSkpO1xuICAgIH1cbiAgICBnZXREZWNvZGVkVmFsdWUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBmaWVsZERvbWFpbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNvZGVkVmFsdWVzID0gZmllbGREb21haW5zO1xuICAgICAgICBpZiAoY29kZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbCA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZWRWYWx1ZSA9IGNvZGVkVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlZFZhbHVlLmNvZGUgPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgKz0gKGxhYmVsLmxlbmd0aCA/IFwiIHwgXCIgOiBcIlwiKSArIGNvZGVkVmFsdWUubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlkIG5vdCBmaW5kIGl0XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0RGF0ZU9ubHlTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBpbnRsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBpbnRsLmZvcm1hdERhdGVPbmx5KHZhbHVlKSA6IFwiXCI7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNGaWx0ZXJVbmlxdWVMaXN0LnN0eWxlID0gYXJjZ2lzRmlsdGVyVW5pcXVlTGlzdENzcztcblxuZXhwb3J0IHsgQXJjZ2lzRmlsdGVyIGFzIGFyY2dpc19maWx0ZXIsIEFyY2dpc0ZpbHRlckNvbmRpdGlvbiBhcyBhcmNnaXNfZmlsdGVyX2NvbmRpdGlvbiwgQXJjZ2lzRmlsdGVyRXhwcmVzc2lvbiBhcyBhcmNnaXNfZmlsdGVyX2V4cHJlc3Npb24sIEFyY2dpc0ZpbHRlclVuaXF1ZUxpc3QgYXMgYXJjZ2lzX2ZpbHRlcl91bmlxdWVfbGlzdCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtZmlsdGVyXzQuZW50cnkuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIG4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgIGZ1bmN0aW9uIGZsdXNoKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZsdXNoZWRcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW52b2tlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgZGVib3VuY2VkLmludm9rZSA9IGludm9rZTtcbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgIGRlYm91bmNlZC5nZXRTdGF0dXMgPSBnZXRTdGF0dXM7XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIG4gbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtwcm9taXNlLCB0aW1lb3V0KG1pbkRlbGF5KV0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGlubGluZSBzZXRUaW1lb3V0IGFzIGFuIGF3YWl0IGluIGFzeW5jIGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gICAgY29uc3QgeyBrZXksIGRhdGEgfSA9IGdldEtleUFuZEl0ZW0oaXRlbSk7XG4gICAgcmV0dXJuIFtrZXksIGRhdGFdO1xufSkpO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcbiAqIGFuZCB3aGV0aGVyIHRoZXkgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50c1xuICogcmVnYXJkbGVzcyBvZiBvcmRlclxuICovXG5jb25zdCBhcnJheXNBcmVFcXVpdmFsZW50ID0gKGFycjEsIGFycjIpID0+IGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLnJlZHVjZSgobWVtbywgc3RyKSA9PiBtZW1vICYmIGFycjIuaW5kZXhPZihzdHIpID4gLTEsIHRydWUpO1xuZnVuY3Rpb24gdW5pcXVlQnkobXlBcnIsIGdldEl0ZW1JZCkge1xuICAgIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICAgIGNvbnN0IGxvb2t1cE1hcCA9IHt9O1xuICAgIG15QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZXRJdGVtSWQoaXRlbSk7XG4gICAgICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyO1xufVxuZnVuY3Rpb24gdW5pcXVlKG15QXJyKSB7XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IHsgYm9vbGVhbjoge30sIG51bWJlcjoge30sIHN0cmluZzoge30gfTtcbiAgICBjb25zdCBvYmpzID0gW107XG4gICAgcmV0dXJuIG15QXJyLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgICAgICBpZiAodHlwZSBpbiBwcmltaXRpdmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlc1t0eXBlXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSA/IGZhbHNlIDogKHByaW1pdGl2ZXNbdHlwZV1baXRlbV0gPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uYWwtNDRkZThmY2YuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTRkMzY3Njc3LmpzJztcbmltcG9ydCB7IGwgYXMgbGFuZ3VhZ2VNYXAgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyc7XG5pbXBvcnQgeyBhIGFzIGdldEFzc2V0UGF0aCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuXG4vLyBodHRwczovL21lZGl1bS5jb20vc3RlbmNpbC10cmlja3MvaW1wbGVtZW50aW5nLWludGVybmF0aW9uYWxpc2F0aW9uLWkxOG4td2l0aC1zdGVuY2lsLTVlNjU1OTU1NDExN1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFwicnUtUlVcIiBtYXBzIHRvIFwicnVcIiB1c2UgY2FzZVxuICAgICAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcuc2xpY2UoMCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIC8vIGl0J3MgT0sgaWYgd2UgZG9uJ3QgaGF2ZSB0aGUgNCBsZXR0ZXIgbGFuZ3VhZ2UgZmlsZSBmb3IgaXRcbiAgICAvLyA0IGxldHRlciBsYW5ndWFnZSBjb2RlIG5lZWRlZCBmb3IgZm9ybWF0dGluZyBudW1iZXJzXG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAgICAgICAvLyB3ZSBzdXBwb3J0IHRoZSAyIGxldHRlciBjb2RlZCBsYW5ndWFnZVxuICAgICAgICAgICAgLy8gZS5nLiBpdC1DSCB2cyBpdFxuICAgICAgICAgICAgcmV0dXJuIGxhbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlblwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZldGNoKGdldEFzc2V0UGF0aChgLi4vYXJjZ2lzLWFwcC1hc3NldHMvaTE4bi8ke2NvbXBvbmVudE5hbWV9LmkxOG4uJHtsb2NhbGV9Lmpzb25gKSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm9rKVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0Lmpzb24oKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0sICgpID0+IHJlamVjdCgpKTtcbiAgICB9KTtcbn1cbmNvbnN0IHN0cmluZ0NhY2hlID0ge307XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gICAgY29uc3QgaWQgPSBgJHtjb21wb25lbnROYW1lfSR7bG9jYWxlfWA7XG4gICAgaWYgKCFzdHJpbmdDYWNoZVtpZF0pIHtcbiAgICAgICAgc3RyaW5nQ2FjaGVbaWRdID0gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdDYWNoZVtpZF07XG59XG4vKipcbiAqIEdldCBzdHJpbmdzIGFuZCBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgMiBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoZSBmaXJzdCBvbmUgcmV0dXJucyBhIGNvZGUgdGhhdCdzIGFsc28gc3VwcG9ydGVkIGFzIGEgbGFuZ3VhZ2UgZmlsZS5cbiAqIFRoZSBzZWNvbmQgb25lIHJldHVybnMgYSBjb2RlIHdoZXJlIHRoZXJlIGlzIHN1cHBvcnQgZm9yIHRoZSBmaXJzdCAyIGxldHRlcnMgb2YgdGhlIGNvZGUgYXMgcGFydCBvZiBhIGxhbmd1YWdlIGZpbGUsXG4gKiBidXQgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIDQgbGV0dGVyIGNvZGUgZnJvbSB0aGUgcGFnZS5cbiAqIEUuZy4gRm9yIFwiaXQtY2hcIiBpdCB3aWxsIHJldHVybiBcIml0XCIgYXMgdGhlIGZpcnN0IGxhbmd1YWdlIGNvZGUgYW5kIFwiaXQtY2hcIiBhcyB0aGUgc2Vjb25kLlxuICogVGhlIHNlY29uZCBvbmUgaXMgcmVxdWlyZWQgZm9yIGVzcmkuaW50bC5zZXRMb2NhbGUoKSB0byBnZXQgdGhlIGNvcnJlY3QgZm9ybWF0dGluZy5cbiAqXG4gKiBJZiBhIHRhZ05hbWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBvdmVyd2l0ZSB0aGUgZWxlbWVudCdzIHRhZ05hbWVcbiAqXG4gKiAgQHJldHVybiBbIHN0cmluZ3MsIGZpcnN0IGxhbmd1YWdlIGNvZGUsIHNlY29uZCBsYW5ndWFnZSBjb2RlXVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKGVsZW1lbnQsIHRhZ05hbWUpIHtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gdGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjb21wb25lbnRMYW5ndWFnZSA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KTtcbiAgICBjb25zdCBjb21wb25lbnRMYW5ndWFnZUludGwgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpO1xuICAgIGxldCBzdHJpbmdzO1xuICAgIHRyeSB7XG4gICAgICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgY29tcG9uZW50TGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYG5vIGxvY2FsZSBmb3IgJHtjb21wb25lbnROYW1lfSAoJHtjb21wb25lbnRMYW5ndWFnZX0pIGxvYWRpbmcgZGVmYXVsdCBsb2NhbGUgZW4uYCk7XG4gICAgICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgXCJlblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHJpbmdzLCBjb21wb25lbnRMYW5ndWFnZSwgY29tcG9uZW50TGFuZ3VhZ2VJbnRsXTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlIGFzIGEsIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgYXMgZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGUtMDUwYjZkYjkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9