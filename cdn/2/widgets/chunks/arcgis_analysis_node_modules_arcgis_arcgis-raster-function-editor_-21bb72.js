"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-21bb72"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/help-texts.it-5c9f24f9.js":
/*!**********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/help-texts.it-5c9f24f9.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rfxArgsHelpTexts: () => (/* binding */ rfxArgsHelpTexts)
/* harmony export */ });
const rfxArgsHelpTexts = {
	"@@Abs_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Abs_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Abs_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Abs_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Abs_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Abs_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Abs_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Abs_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Abs_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Abs_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Abs_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Abs_Raster_tag0@@": "Il raster di input per il quale calcolare i valori assoluti.",
	"@@ACos_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@ACos_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@ACos_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@ACos_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@ACos_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@ACos_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@ACos_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@ACos_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@ACos_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@ACos_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@ACos_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@ACos_Raster_tag0@@": "L'input per il quale calcolare i valori di coseno inverso.",
	"@@ACosH_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@ACosH_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@ACosH_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@ACosH_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@ACosH_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@ACosH_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@ACosH_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@ACosH_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@ACosH_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@ACosH_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@ACosH_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@ACosH_Raster_tag0@@": "L'input per il quale calcolare i valori di coseno inverso iperbolico.",
	"@@Apparent-Reflectance_Albedo_tag0@@": "I risultati della funzione Riflettanza apparente può anche essere espressa come albedo, che è la percentuale di energia disponibile riflessa dalla superficie del pianeta. I dati vengono utilizzati da utenti scientifici per applicazioni complesse di modellazione e telerilevamento tecnico.",
	"@@Apparent-Reflectance_Albedo_tag1@@": "Non selezionato: la funzione torna ai valori di riflettanza apparente. Questa è l'impostazione predefinita.",
	"@@Apparent-Reflectance_Albedo_tag2@@": "Selezionato: la funzione torna a valori 32 bit a virgola mobile, che rientrano più comunemente nell'intervallo 0,0 - 1,0. Se è selezionata questa opzione non si esegue alcun taglio dei dati.",
	"@@Apparent-Reflectance_Albedo_tag3@@": "Dal momento che il tipo di dati di output per albedo è la virgola mobile, è necessario impostare esplicitamente il <strong>Tipo di pixel di output</strong> preferito su 32 bit float o 64 bit doppio. Il parametro di <strong>Tipo di pixel di output</strong> si trova nella scheda <strong>Generale</strong> della funzione raster <strong>Riflettanza apparente</strong>. Se il <strong>Tipo di pixel di output</strong> non è impostato correttamente per l'opzione <strong>Albedo</strong>, i valori risultanti saranno invalidi e assumeranno il valore 0.",
	"@@Apparent-Reflectance_Offset_tag0@@": "Il valore albedo scalato può avere facoltativamente un valore di offset:",
	"@@Apparent-Reflectance_Offset_tag1@@": "Per i tipi di dati senza segno a 16 bit, l'offset di scala predefinito è 5.000.",
	"@@Apparent-Reflectance_Offset_tag2@@": "Per i tipi di dati senza segno a 8 bit, l'offset di scala predefinito è 0.",
	"@@Apparent-Reflectance_Offset_tag3@@": "Non si applica nessun fattore di scala quando l'output è albedo.",
	"@@Apparent-Reflectance_Radiance-Gains-and-Bias-Values-per-Band_tag0@@": "È possibile impostare o modificare manualmente questo valore per ogni banda. Le informazioni appropriate possono essere lette dai metadati del prodotto del raster di input.",
	"@@Apparent-Reflectance_Raster_tag0@@": "Il prodotto raster sul quale sarà applicata la riflettanza apparente.",
	"@@Apparent-Reflectance_Scale-Factor_tag0@@": "Il valore di output della riflettanza apparente può essere espresso come un numero intero. Il fattore di scala viene moltiplicato dall'albedo per convertire tutti i valori a virgola mobile in valori interi.",
	"@@Apparent-Reflectance_Scale-Factor_tag1@@": "Se il fattore di scala è ${0} o non specificato, si applicherà la scala predefinita a seconda del tipo di pixel dei dati di input:",
	"@@Apparent-Reflectance_Scale-Factor_tag2@@": "Per i tipi di dati senza segno a 16 bit, il fattore di scala predefinito è 50.000.",
	"@@Apparent-Reflectance_Scale-Factor_tag3@@": "Per i tipi di dati senza segno a 8 bit, il fattore di scala predefinito è 255.",
	"@@Apparent-Reflectance_Scale-Factor_tag4@@": "Il fattore di scala si applica sempre quando l'output è una riflettanza apparente. Non si applica nessun fattore di scala quando l'output è albedo.",
	"@@Apparent-Reflectance_Sun-Elevation_tag0@@": "Questo è il valore di elevazione del sole, espresso in gradi. Sarà popolato dal sistema se è possibile leggere le informazioni idonee dai metadati. È possibile impostare o modificare manualmente questo valore.",
	"@@ArgStatistics_Max_tag0@@": "Il valore massimo impostato è il valore più alto uguale o minore della fine della durata.",
	"@@ArgStatistics_Max_tag1@@": "Questo input è applicabile solo se il metodo è Durata.",
	"@@ArgStatistics_Method_tag0@@": "Selezionare il metodo statistico per il calcolo:",
	"@@ArgStatistics_Method_tag1@@": "Arg Max: l'argomento del massimo, che restituisce il ${Band index} per il quale il pixel dato raggiunge il suo valore massimo da tutte le bande. A tutte le bande raster da ogni raster di input viene assegnato un indice di banda incrementale su base 0, che è il primo ad essere ordinato dall'indice raster di input e quindi dall'ordine di banda relativo all'interno di ciascun raster di input.",
	"@@ArgStatistics_Method_tag2@@": "Arg Median: l'argomento del mediano, che restituisce il ${Band index} per il quale il pixel dato raggiunge il suo valore mediano dei valori di tutte le bande.",
	"@@ArgStatistics_Method_tag3@@": "Arg Min: l'argomento del minimo, che restituisce il ${Band index} per il quale il pixel dato raggiunge il suo valore minimo da tutte le bande.",
	"@@ArgStatistics_Method_tag4@@": "Durata: trova gli elementi consecutivi più lunghi nell'array, laddove ogni elemento ha un valore superiore o uguale a <strong>Min</strong> e inferiore o uguale a <strong>Max</strong>, quindi restituisce la sua lunghezza.",
	"@@ArgStatistics_Min_tag0@@": "Il valore minimo impostato è il valore più piccolo uguale o maggiore dell'inizio della durata.",
	"@@ArgStatistics_Min_tag1@@": "Questo input è applicabile solo se il metodo è Durata.",
	"@@ArgStatistics_Rasters_tag0@@": "Il raster di input su cui verranno eseguiti i vari metodi statistici.",
	"@@ArgStatistics_Undefined-Class_tag0@@": "Un input costante che viene restituito quando non si può ottenere nessun massimo, minimo o mediano definitivo. Lo scenario più comune è il verificarsi del valore massimo o minimo per più di una volta tra i valori di tutte le bande. Il valore predefinito per la costante non definita è 100.",
	"@@ArgStatistics_Undefined-Class_tag1@@": "La classe non definita si può applicare solo quando il metodo è <strong>ArgMax</strong>, <strong>ArgMin</strong> o <strong>ArgMedian</strong>.",
	"@@ArgStatistics_ignorenodata_tag0@@": "Indica se i valori NoData vengono ignorati nel calcolo statistico.",
	"@@ArgStatistics_ignorenodata_tag1@@": "Selezionata: l'analisi includerà tutti i pixel validi nei raster di input e ignorerà tutti i pixel NoData.",
	"@@ArgStatistics_ignorenodata_tag2@@": "Non selezionata: l'analisi produrrà NoData se sono presenti valori NoData per i pixel nei raster di input. Si tratta dell'impostazione predefinita.",
	"@@Arithmetic_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Arithmetic_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Arithmetic_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Arithmetic_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Arithmetic_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Arithmetic_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Arithmetic_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Arithmetic_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Arithmetic_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Arithmetic_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Arithmetic_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Arithmetic_Operation_tag0@@": "L'operazione aritmetica da eseguire tra due raster di input.",
	"@@Arithmetic_Operation_tag1@@": "Le opzioni sono le seguenti:",
	"@@Arithmetic_Operation_tag2@@": "<strong>Dividi</strong>: restituisce il risultato divisibile tra i relativi valori pixel per ciascun raster.",
	"@@Arithmetic_Operation_tag4@@": "<strong>Sottrai</strong>: restituisce la differenza tra i relativi valori pixel per ciascun raster. Può essere usata per calcolare il rilevamento delle modifiche.",
	"@@Arithmetic_Operation_tag6@@": "<strong>Moda</strong>: restituisce il valore pixel di tutti i pixel sovrapposti che si verificano più di frequente. Ad esempio: se ci sono sei bande in un raster, ci saranno sei pixel sovrapposti. Per i valori 4, 5, 6, 4, 7, 9, il valore della modalità è 4.",
	"@@Arithmetic_Operation_tag8@@": "<strong>Moltiplica</strong>: restituisce il prodotto dei relativi valori pixel per ciascun raster. Può essere usata per eseguire alcune funzioni di costo.",
	"@@Arithmetic_Operation_tag10@@": "<strong>Somma</strong>: restituisce la somma di tutti i relativi valori pixel per ciascun raster.",
	"@@Arithmetic_Operation_tag12@@": "<strong>Potenza</strong>: restituisce il prodotto dei relativi valori pixel elevati alla potenza del raster di input o scalare.",
	"@@Arithmetic_Raster_tag0@@": "Il primo dataset raster di input.",
	"@@Arithmetic_Raster2_tag0@@": "Il secondo dataset raster di input.",
	"@@ASin_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@ASin_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@ASin_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@ASin_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@ASin_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@ASin_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@ASin_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@ASin_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@ASin_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@ASin_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@ASin_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@ASin_Raster_tag0@@": "L'input per il quale calcolare i valori di seno inverso.",
	"@@ASinH_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@ASinH_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@ASinH_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@ASinH_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@ASinH_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@ASinH_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@ASinH_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@ASinH_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@ASinH_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@ASinH_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@ASinH_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@ASinH_Raster_tag0@@": "L'input per il quale calcolare i valori di seno inverso iperbolico.",
	"@@Aspect_Raster_tag0@@": "Il DEM di input utilizzato per derivare il dataset di aspetto.",
	"@@Aspect-Slope_Raster_tag0@@": "Il DEM di input.",
	"@@Aspect-Slope_Z-Factor_tag0@@": "Un fattore di scala utilizzato per convertire i valori di elevazione per i seguenti due motivi:",
	"@@Aspect-Slope_Z-Factor_tag1@@": "Convertire le unità di elevazione (ad esempio, metri o piedi) in unità di coordinate orizzontali del dataset, che possono essere piedi, metri o gradi.",
	"@@Aspect-Slope_Z-Factor_tag2@@": "Aggiungere il fattore di esagerazione verticale per ottenere un effetto visivo.",
	"@@ATan_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@ATan_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@ATan_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@ATan_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@ATan_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@ATan_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@ATan_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@ATan_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@ATan_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@ATan_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@ATan_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@ATan_Raster_tag0@@": "L'input per il quale calcolare i valori di tangente inversa.",
	"@@ATan2_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@ATan2_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@ATan2_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@ATan2_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@ATan2_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@ATan2_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@ATan2_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@ATan2_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@ATan2_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@ATan2_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@ATan2_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@ATan2_Raster_tag0@@": "L'input che specifica il numeratore, o il valore y da utilizzare durante il calcolo della tangente inversa.",
	"@@ATan2_Raster2_tag0@@": "L'input che specifica il denominatore, o il valore x da utilizzare durante il calcolo della tangente inversa.",
	"@@ATanH_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@ATanH_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@ATanH_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@ATanH_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@ATanH_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@ATanH_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@ATanH_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@ATanH_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@ATanH_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@ATanH_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@ATanH_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@ATanH_Raster_tag0@@": "L'input per il quale calcolare i valori di tangente inversa iperbolica.",
	"@@Attribute-Table_Raster_tag0@@": "Il raster di input.",
	"@@Attribute-Table_Table-Type_tag0@@": "La tabella di attributi di input che può essere inserita utilizzando il tipo <strong>Manuale</strong> nel quale si assegna un nome classe e un colore a ogni valore, o si può fare riferimento a una tabella esistente che proviene da un file ${.dbf}.",
	"@@Band-Arithmetic_Band-Indexes_tag0@@": "Definire la formula aritmetica banda se si seleziona <strong>Definito</strong> dall'utente per <strong>Metodo</strong>.",
	"@@Band-Arithmetic_Band-Indexes_tag5@@": "Se si sceglie un indice predefinito per <strong>Metodo</strong>, definire le bande corrette per il dataset raster di input corrispondente all'indice.",
	"@@Band-Arithmetic_Method_tag0@@": "Il tipo di algoritmo Aritmetica Banda che si desidera eseguire. È possibile definire l'algoritmo personalizzato o scegliere un indice predefinito.",
	"@@Band-Arithmetic_Method_tag1@@": "<strong>BAI</strong>--Indice di area bruciata (Burn Area Index)",
	"@@Band-Arithmetic_Method_tag2@@": "<strong>CIg</strong>--Indice di clorofilla - Verde (Chlorophyll Index - Green)",
	"@@Band-Arithmetic_Method_tag3@@": "<strong>CIre</strong>--Indice di clorofilla - Bordo rosso (Chlorophyll Index - Red Edge)",
	"@@Band-Arithmetic_Method_tag4@@": "<strong>Clay Minerals</strong>--Rapporto minerali argilla (Clay Minerals Ratio)",
	"@@Band-Arithmetic_Method_tag5@@": "<strong>EVI</strong>--Indice di vegetazione migliorato (Enhanced Vegetation Index)",
	"@@Band-Arithmetic_Method_tag6@@": "<strong>Ferrous Minerals</strong>--Rapporto di minerali ferrosi (Ferrous Minerals Ratio)",
	"@@Band-Arithmetic_Method_tag7@@": "<strong>GEMI</strong>--Indice di monitoraggio ambientale globale (Global Environmental Monitoring Index)",
	"@@Band-Arithmetic_Method_tag8@@": "<strong>GNDVI</strong>--Indice di vegetazione a differenza verde normalizzato (Green Normalized Difference Vegetation Index)",
	"@@Band-Arithmetic_Method_tag9@@": "<strong>GVI (Landsat TM)</strong>--Indice di vegetazione verde Landsat TM (Green Vegetation Index Landsat TM)",
	"@@Band-Arithmetic_Method_tag10@@": "<strong>Iron Oxide</strong>--Rapporto ossido di ferro (Iron Oxide Ratio)",
	"@@Band-Arithmetic_Method_tag11@@": "<strong>MNDWI</strong>--Indice idrico di differenza normalizzato modificato (Modified Normalized Difference Water Index)",
	"@@Band-Arithmetic_Method_tag12@@": "<strong>MTVI2</strong>--Indice di vegetazione triangolato modificato (seconda iterazione) (Modified Triangulated Vegetation Index (second iteration))",
	"@@Band-Arithmetic_Method_tag13@@": "<strong>Modified SAVI</strong>--Indice di vegetazione aggiustato al suolo modificato (Modified Soil Adjusted Vegetation Index)",
	"@@Band-Arithmetic_Method_tag14@@": "<strong>NBR</strong>--Indice del rapporto di combustione normalizzato (Normalized Burn Ratio Index)",
	"@@Band-Arithmetic_Method_tag15@@": "<strong>NDBI</strong>--Indice di accumulo di differenza normalizzato (Normalized Difference Built-up Index)",
	"@@Band-Arithmetic_Method_tag16@@": "<strong>NDMI</strong>--Indice di umidità differenziale normalizzato (Normalized Difference Moisture Index)",
	"@@Band-Arithmetic_Method_tag17@@": "<strong>NDSI</strong>--Indice di differenza di neve normalizzato (Normalized Difference Snow Index)",
	"@@Band-Arithmetic_Method_tag18@@": "<strong>NDVI</strong>--Indice di vegetazione a differenza normalizzata (Normalized Difference Vegetation Index)",
	"@@Band-Arithmetic_Method_tag19@@": "<strong>NDVIre</strong>--Indice di vegetazione a differenza normalizzata di Red-Edge (Red-Edge Normalized Difference Vegetation Index)",
	"@@Band-Arithmetic_Method_tag20@@": "<strong>NDWI</strong>--Indice di differenza dell'acqua normalizzato (Normalized Difference Water Index)",
	"@@Band-Arithmetic_Method_tag21@@": "<strong>PVI</strong>--Indice di vegetazione perpendicolare (Perpendicular Vegetation Index)",
	"@@Band-Arithmetic_Method_tag22@@": "<strong>RTVICore</strong>--Indice di vegetazione triangolato a bordi rossi (Red-Edge Triangulated Vegetation Index)",
	"@@Band-Arithmetic_Method_tag23@@": "<strong>SAVI</strong>--Indice di vegetazione corretto per il suolo (Soil Adjusted Vegetation Index)",
	"@@Band-Arithmetic_Method_tag24@@": "<strong>SR</strong>--Rapporto semplice (Simple Ratio)",
	"@@Band-Arithmetic_Method_tag25@@": "<strong>SRre</strong>--Rapporto semplice bordo rosso (Red-Edge Simple Ratio)",
	"@@Band-Arithmetic_Method_tag26@@": "<strong>Sultan's Formula</strong>--Formula di Sultan (Sultan's Formula)",
	"@@Band-Arithmetic_Method_tag27@@": "<strong>Transformed SAVI</strong>--Indice di vegetazione trasformato aggiustato per il suolo (Transformed Soil Adjusted Vegetation Index)",
	"@@Band-Arithmetic_Method_tag28@@": "<strong>User Defined</strong>--Permette di definire un'espressione aritmetica di banda personalizzata (Allows you to define your custom band arithmetic expression)",
	"@@Band-Arithmetic_Method_tag29@@": "<strong>VARI</strong>--Indice di resistenza atmosferica visibile (Visible Atmospherically Resistant Index)",
	"@@Band-Arithmetic_Method_tag30@@": "<strong>WNDWI</strong>--Differenza ponderata normalizzata dell'indice d'acqua (Weighted Normalized Difference Water Index)",
	"@@Band-Arithmetic_Raster_tag0@@": "Il raster di input.",
	"@@Binary-Thresholding_Raster_tag0@@": "Il raster di input.",
	"@@Bitwise-And_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Bitwise-And_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Bitwise-And_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Bitwise-And_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Bitwise-And_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Bitwise-And_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Bitwise-And_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Bitwise-And_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-And_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Bitwise-And_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-And_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Bitwise-And_Raster_tag0@@": "Il primo input da usare in questa operazione bitwise.",
	"@@Bitwise-And_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Bitwise-And_Raster2_tag0@@": "Il secondo input da usare in questa operazione bitwise.",
	"@@Bitwise-And_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Bitwise-Left-Shift_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Bitwise-Left-Shift_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-Left-Shift_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Bitwise-Left-Shift_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-Left-Shift_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Bitwise-Left-Shift_Raster_tag0@@": "L'input sul quale eseguire lo spostamento.",
	"@@Bitwise-Left-Shift_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Bitwise-Left-Shift_Raster2_tag0@@": "L'input che definisce il numero di posizioni delle quali spostare i bit.",
	"@@Bitwise-Left-Shift_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Bitwise-Not_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Bitwise-Not_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Bitwise-Not_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Bitwise-Not_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Bitwise-Not_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Bitwise-Not_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Bitwise-Not_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Bitwise-Not_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-Not_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Bitwise-Not_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-Not_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Bitwise-Not_Raster_tag0@@": "Il raster di input sul quale eseguire l'operazione Bitwise Not (supplemento)",
	"@@Bitwise-Or_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Bitwise-Or_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Bitwise-Or_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Bitwise-Or_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Bitwise-Or_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Bitwise-Or_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Bitwise-Or_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Bitwise-Or_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-Or_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Bitwise-Or_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-Or_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Bitwise-Or_Raster_tag0@@": "Il primo input da usare in questa operazione bitwise.",
	"@@Bitwise-Or_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Bitwise-Or_Raster2_tag0@@": "Il secondo input da usare in questa operazione bitwise.",
	"@@Bitwise-Or_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Bitwise-Right-Shift_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Bitwise-Right-Shift_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-Right-Shift_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Bitwise-Right-Shift_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-Right-Shift_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Bitwise-Right-Shift_Raster_tag0@@": "L'input sul quale eseguire lo spostamento.",
	"@@Bitwise-Right-Shift_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Bitwise-Right-Shift_Raster2_tag0@@": "L'input che definisce il numero di posizioni delle quali spostare i bit.",
	"@@Bitwise-Right-Shift_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Bitwise-Xor_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Bitwise-Xor_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Bitwise-Xor_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Bitwise-Xor_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Bitwise-Xor_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Bitwise-Xor_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Bitwise-Xor_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Bitwise-Xor_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-Xor_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Bitwise-Xor_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Bitwise-Xor_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Bitwise-Xor_Raster_tag0@@": "Il primo input da usare in questa operazione bitwise.",
	"@@Bitwise-Xor_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Bitwise-Xor_Raster2_tag0@@": "Il secondo input da usare in questa operazione bitwise.",
	"@@Bitwise-Xor_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Boolean-and_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Boolean-and_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Boolean-and_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Boolean-and_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Boolean-and_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Boolean-and_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Boolean-and_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Boolean-and_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Boolean-and_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Boolean-and_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Boolean-and_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Boolean-and_Raster_tag0@@": "Il primo input da usare in questa operazione booleana.",
	"@@Boolean-and_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Boolean-and_Raster2_tag0@@": "Il secondo input da usare in questa operazione booleana.",
	"@@Boolean-and_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Boolean-Not_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Boolean-Not_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Boolean-Not_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Boolean-Not_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Boolean-Not_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Boolean-Not_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Boolean-Not_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Boolean-Not_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Boolean-Not_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Boolean-Not_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Boolean-Not_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Boolean-Not_Raster_tag0@@": "Il primo input da usare in questa operazione booleana.",
	"@@Boolean-Or_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Boolean-Or_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Boolean-Or_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Boolean-Or_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Boolean-Or_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Boolean-Or_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Boolean-Or_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Boolean-Or_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Boolean-Or_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Boolean-Or_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Boolean-Or_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Boolean-Or_Raster_tag0@@": "Il primo input da usare in questa operazione booleana.",
	"@@Boolean-Or_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Boolean-Or_Raster2_tag0@@": "Il secondo input da usare in questa operazione booleana.",
	"@@Boolean-Or_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Boolean-Xor_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Boolean-Xor_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Boolean-Xor_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Boolean-Xor_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Boolean-Xor_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Boolean-Xor_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Boolean-Xor_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Boolean-Xor_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Boolean-Xor_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Boolean-Xor_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Boolean-Xor_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Boolean-Xor_Raster_tag0@@": "Il primo input da usare in questa operazione booleana.",
	"@@Boolean-Xor_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Boolean-Xor_Raster2_tag0@@": "Il secondo input da usare in questa operazione booleana.",
	"@@Boolean-Xor_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Buffered_Raster_tag0@@": "Il raster di input da memorizzare.",
	"@@Calculator_Cellsize-Type_tag0@@": "La dimensione della cella utilizzata per creare il raster di output.",
	"@@Calculator_Cellsize-Type_tag1@@": "È possibile scegliere la dimensione della cella di output dalle seguenti opzioni nell'elenco a discesa:",
	"@@Calculator_Cellsize-Type_tag2@@": "<strong>Primo di</strong>: la dimensione della cella della prima variabile raster.",
	"@@Calculator_Cellsize-Type_tag4@@": "<strong>Min di</strong>: la dimensione della cella minima dei raster di input.",
	"@@Calculator_Cellsize-Type_tag6@@": "<strong>Max di</strong>: la dimensione della cella massima dei raster di input.",
	"@@Calculator_Cellsize-Type_tag8@@": "<strong>Media di</strong>: la dimensione della cella media dei raster di input.",
	"@@Calculator_Cellsize-Type_tag10@@": "<strong>Ultimo di</strong>: la dimensione della cella dell'ultima variabile raster.",
	"@@Calculator_Cellsize-Type_tag12@@": "La selezione predefinita è <strong>Max di</strong>.",
	"@@Calculator_Expression_tag0@@": "Creare un'espressione algebrica per eseguire analisi spaziali sui raster di input.",
	"@@Calculator_Expression_tag1@@": "Tutte le funzioni matematiche esistenti da richiamare per creare l'espressione. Gli operatori disponibili sono elencati di seguito.",
	"@@Calculator_Expression_tag2@@": "Operazioni aritmetiche",
	"@@Calculator_Expression_tag3@@": "Addizione: +",
	"@@Calculator_Expression_tag4@@": "Divisione: /",
	"@@Calculator_Expression_tag5@@": "Modulo: %",
	"@@Calculator_Expression_tag6@@": "Moltiplicazione: *",
	"@@Calculator_Expression_tag7@@": "Potenza: **",
	"@@Calculator_Expression_tag8@@": "Sottrazione: -",
	"@@Calculator_Expression_tag9@@": "Operazioni booleane",
	"@@Calculator_Expression_tag10@@": "And booleano: &&",
	"@@Calculator_Expression_tag11@@": "Or booleano: ||",
	"@@Calculator_Expression_tag12@@": "Operazioni di relazione",
	"@@Calculator_Expression_tag13@@": "Uguale a: ==",
	"@@Calculator_Expression_tag14@@": "Maggiore di: >",
	"@@Calculator_Expression_tag15@@": "Maggiore di o uguale a: >=",
	"@@Calculator_Expression_tag16@@": "Minore di: <",
	"@@Calculator_Expression_tag17@@": "Minore di o uguale a: <=",
	"@@Calculator_Expression_tag18@@": "Diverso da: !=",
	"@@Calculator_Expression_tag19@@": "Operazioni aggiuntive",
	"@@Calculator_Expression_tag20@@": "Un minimo di due raster su una base per pixel: min(a,b)",
	"@@Calculator_Expression_tag21@@": "Un massimo di due raster su una base per pixel: max(a,b)",
	"@@Calculator_Expression_tag22@@": "Ecco alcuni esempi di espressioni:",
	"@@Calculator_Expression_tag23@@": "Istruzione condizionale semplice: in un raster (identificato da T) trovare valori di elevazione superiori ai 4.000 piedi e dare a tali aree un valore di 1 e a tutte le altre aree un valore di 0.",
	"@@Calculator_Expression_tag24@@": "Con (T > 4000, 1, 0)",
	"@@Calculator_Expression_tag25@@": "Istruzione condizionale nidificata: trovare le aree nelle quali la pendenza (identificata da b1) è inferiore ai 10 gradi e NDVI (identificato da b2) è superiore a 0,5 e dare a tali aree un valore di 1. Per tutte le altre aree, assegnare un valore di 2 se la pendenza è superiore ai 10 gradi e se l'elevazione (identificata da b3) è superiore ai 2.500 piedi. A tutte le altre aree viene assegnato un valore di 3.",
	"@@Calculator_Expression_tag26@@": "Con((b1 < 10 && b2 > .5, 1, Con(b1 > 10 && b3 > 2500, 2, 3)))",
	"@@Calculator_extenttype_tag0@@": "<p>Scegli quale estensione utilizzare nel raster di output:</p><ul><li><p>Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.</p></li><li>Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione di default.</li><li>Unione di: usare l'estensione di tutti i raster per determinare l'estensione di elaborazione.</li><li>Ultimo di: usare l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.</li></ul>",
	"@@Calculator_Raster-Variables_tag0@@": "Il nome della variabile definita dall'utente e il raster di input.",
	"@@Classify_Input-Definition-File_tag0@@": "Il file di definizione del metodo di classificazione di Esri (${.ecd}) che contiene le statistiche e altre informazioni di classificazione per lo specifico dataset, classificatore e per gli attributi scelti.",
	"@@Classify_Raster_tag0@@": "Il raster dataset che si desidera classificare.",
	"@@Classify_Raster2_tag0@@": "Un dataset raster ausiliario opzionale da incorporare nel classificatore, come un'immagine segmentata, un'immagine multispettrale o dati di elevazione, utilizzato per generare una definizione della classificazione più solida per il dataset. Il dataset raster per questo parametro deve corrispondere a quello utilizzato per creare il file di definizione del metodo di classificazione di Esri di input.",
	"@@Clip_Clipping-Geometry-or-Raster_tag0@@": "Quanto segue può essere utilizzato per specificare l'estensione di taglio:",
	"@@Clip_Clipping-Geometry-or-Raster_tag1@@": "<strong>Raster di taglio</strong>: estensione del raster di taglio",
	"@@Clip_Clipping-Geometry-or-Raster_tag3@@": "<strong>Estensione personalizzata</strong>: coordinate x e y minime e massime",
	"@@Clip_Clipping-Geometry-or-Raster_tag5@@": "<strong>Estensione mappa corrente</strong>: estensione di visualizzazione della mappa corrente",
	"@@Clip_Clipping-Raster_tag0@@": "Il layer raster utilizzato per tagliare.",
	"@@Clip_Clipping-Type_tag0@@": "Specificare se si vuole mantenere l'area all'interno o all'esterno della geometria ritagliata.",
	"@@Clip_Clipping-Type_tag1@@": "<strong>Taglia all'interno</strong>: le immagini all'interno dell'estensione del ritaglio verranno rimosse.",
	"@@Clip_Clipping-Type_tag3@@": "<strong>Taglia all'esterno</strong>: le immagini all'esterno dell'estensione del ritaglio verranno rimosse.",
	"@@Clip_Custom-Extent_tag0@@": "Specificare le quattro coordinate che definiscono l'estensione del rettangolo di selezione utilizzato per tagliare il raster.",
	"@@Clip_Output-Extent_tag0@@": "Le coordinate x e y dell'estensione di ritaglio corrente.",
	"@@Clip_Output-Extent_tag1@@": "Il pulsante <strong>Cattura estensione mappa corrente</strong> utilizza l'estensione di visualizzazione per la mappa attiva.",
	"@@Clip_Raster_tag0@@": "Il raster layer di input.",
	"@@Clip_Use-Input-Features-for-Clipping-Geometry_tag0@@": "Quando vengono selezionati, i dati vengono ritagliati secondo la geometria della feature class specificata.",
	"@@Clip_Use-Input-Features-for-Clipping-Geometry_tag1@@": "Non selezionato: questa funzione utilizza la geometria di ritaglio specificata da <strong>Rettangolo</strong>. Questa è l'impostazione predefinita.",
	"@@Clip_Use-Input-Features-for-Clipping-Geometry_tag4@@": "Selezionato: questa funzione utilizza la geometria di ritaglio definita da una feature class.",
	"@@Color-Model-Conversion_Conversion-Type_tag0@@": "Tipo di conversione del colore da eseguire:",
	"@@Color-Model-Conversion_Conversion-Type_tag1@@": "Da HSV a RGB",
	"@@Color-Model-Conversion_Conversion-Type_tag2@@": "Da RGB a HSV",
	"@@Color-Model-Conversion_Raster_tag0@@": "Il raster di input.",
	"@@Colormap_Color-Ramp_tag0@@": "Scegliere una scala cromatica preesistente.",
	"@@Colormap_Color-Scheme-Type_tag0@@": "Scegliere il tipo di schema di colori per eseguire il render del raster di input.",
	"@@Colormap_Color-Scheme-Type_tag1@@": "Scala cromatica: utilizzare una scala cromatica.",
	"@@Colormap_Color-Scheme-Type_tag2@@": "Mappa colore: utilizzare una mappa colore preesistente.",
	"@@Colormap_Colormap_tag0@@": "Le seguenti mappe colore predefinite sono disponibili dall'elenco a discesa:",
	"@@Colormap_Colormap_tag1@@": "Elevazione: una mappa colore che cambia gradualmente dal ciano al viola al nero.",
	"@@Colormap_Colormap_tag2@@": "Grigio: una mappa colore che cambia gradualmente dal nero al bianco.",
	"@@Colormap_Colormap_tag7@@": "Rilievo ombreggiato: una mappa di colore per visualizzare una rappresentazione in 3D della superficie del terreno, con posizione relativa del sole considerata per l'ombreggiatura dell'immagine.",
	"@@Colormap_Colormap_tag3@@": "NDVI: una mappa colore per visualizzare la vegetazione. I valori vicino allo zero sono blu. I valori inferiori sono marroni. Quindi i colori cambiano gradualmente dal rosso, all'arancione, al giallo, al verde e al nero mentre l'indice di vegetazione va dal basso verso l'alto.",
	"@@Colormap_Colormap_tag4@@": "NDVI2: una mappa colore per visualizzare la vegetazione. I valori inferiori vanno dal bianco al verde. Quindi i colori spaziano dal grigio, al viola, al blu scuro e al nero mentre l'indice di vegetazione va dal basso verso l'alto.",
	"@@Colormap_Colormap_tag5@@": "NDVI3: una mappa colore per visualizzare la vegetazione. I valori vicino allo zero sono blu. Quindi i colori cambiano gradualmente dal rosso, all'arancione, e al verde mentre l'indice di vegetazione va dal basso verso l'alto.",
	"@@Colormap_Colormap_tag6@@": "Casuale: una mappa colore casuale.",
	"@@Colormap_Raster_tag0@@": "Il raster di input.",
	"@@Colormap-To-RGB_Raster_tag0@@": "Raster colormap di input.",
	"@@Complex_Raster_tag0@@": "Il raster di input.",
	"@@Composite-Bands_Rasters_tag0@@": "Utilizzare l'elenco a discesa o il pulsante <strong>Sfoglia</strong> per scegliere gli input raster.",
	"@@Composite-Bands_cellsizetype_tag0@@": "<p>Scegli la dimensione cella da utilizzare nel raster di output. Se le dimensioni delle celle di input sono identiche, tutte le opzioni produrranno gli stessi risultati.</p><ul><li>Primo di: utilizza la dimensione della prima cella dei raster di input.</li><li>Minimo di: utilizza la dimensione della cella più piccola di tutti i raster di input.</li><li>Massimo di: utilizza la dimensione della cella più grande di tutti i raster di input. Questa è l'impostazione di default.</li><li>Media di: utilizza la grandezza di cella media di tutti i raster di input.</li><li>Ultimo di: utilizza l'ultima grandezza di cella di raster di input.</li></ul>",
	"@@Con-function_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Con-function_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Con-function_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Con-function_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Con-function_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Con-function_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Con_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Con_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Con_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Con_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Con_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Con_False-Raster_tag0@@": "L'input i cui valori saranno usati come valori pixel di output se la condizione è false. Può essere un numero intero, un raster a virgola mobile o un valore costante.",
	"@@Con_Raster_tag0@@": "Il raster di input che rappresenta il risultato booleano di una Raster Function matematica logica. I valori saranno 1 (per true) o 0 (per false). Può essere un numero intero o un raster a virgola mobile.",
	"@@Con_True-Raster_tag0@@": "L'input i cui valori saranno usati come valori pixel di output se la condizione è vero. Può essere un numero intero, un raster a virgola mobile o un valore costante.",
	"@@Constant_Constant_tag0@@": "Il valore della costante da aggiungere al raster virtuale.",
	"@@Constant_Raster-Info_tag0@@": "Usare il pulsante <strong>Carica raster del modello</strong> per caricare un modello da una directory o portale.",
	"@@Contour_Adaptive-Smoothing_tag0@@": "La quantità di ammorbidimento da applicare alla linea di contorno. Il valore predefinito è 2,5.",
	"@@Contour_Adaptive-Smoothing_tag1@@": "Un valore inferiore produce una linea di contorno più granulare e meno ammorbidita, mentre un valore superiore produce una linea di contorno più ammorbidita che appare meno frastagliata.",
	"@@Contour_Contour-Interval_tag0@@": "La differenza di altitudine tra le linee di contorno.",
	"@@Contour_Contour-Interval_tag1@@": "Nelle aree relativamente piane si usa un intervallo di contorno piccolo, mentre su un suolo variabile o montagnoso si usano intervalli di contorno più grandi.",
	"@@Contour_Contour-Type_tag0@@": "Il tipo di contorno da creare:",
	"@@Contour_Contour-Type_tag1@@": "<strong>Riempimento del contour</strong>: riempie l'area tra ogni linea di contorno con il valore di elevazione quantizzato.",
	"@@Contour_Contour-Type_tag3@@": "<strong>Linee di contorno</strong>: unisce i punti della stessa elevazione per creare una linea che rappresenti un'elevazione costante.",
	"@@Contour_Contour-Type_tag5@@": "<strong>Solo superficie ammorbidita</strong>: sfuma il layer di elevazione di input ma non produce Contour.",
	"@@Contour_Nth-Contour-Line-In-Bold_tag0@@": "Il contorno dell'indice, rappresentato come una linea in grassetto.",
	"@@Contour_Nth-Contour-Line-In-Bold_tag1@@": "Il valore predefinito è 5; quindi, ogni 5ª linea di contorno è in grassetto.",
	"@@Contour_Number-Of-Contours_tag0@@": "Il numero di Contour da generare nella visualizzazione.  Regola dinamicamente l'intervallo dei Contours per adattare il suolo nella visualizzazione mantenendo allo stesso tempo intervalli standardizzati come 1, 5, 10 e così via.",
	"@@Contour_Raster_tag0@@": "Un dataset di elevazione raster a banda singola.",
	"@@Contour_Z-Base_tag0@@": "Il valore di contorno di base. I Contour vengono generati al di sopra e al di sotto di questo valore a seconda di ciò che sia necessario per coprire l'intera gamma di valori del raster di input. L'impostazione predefinita è 0.",
	"@@Contour_Z-Base_tag1@@": "Un valore 0 spesso rappresenta il livello medio del mare, a seconda del dataset di elevazione di origine.",
	"@@Contour_Z-Factor_tag0@@": "Il fattore di conversione dell'unità usato quando si generano Contour. Il valore predefinito è 1.",
	"@@Contour_Z-Factor_tag1@@": "Le linee di contorno sono generate in base ai valori z nel raster di input, spesso misurati in metri o piedi. Con il valore predefinito di 1, i Contour saranno nelle stesse unità dei valori z del raster di input. Per creare Contour in un'unità diversa da quella dei valori z, impostare un valore adeguato per il fattore z. Per questo strumento, non è necessario che le unità x,y di terra e le unità z di superficie siano omogenee.",
	"@@Contour_Z-Factor_tag2@@": "Ad esempio, se i valori di elevazione nel raster di input sono espressi in piedi ma si desidera che i contorni siano generati in metri, impostare il fattore z su 0,3048 (dal momento che 1 piede = 0,3048 metri).",
	"@@Contrast-and-Brightness_Brightness-Offset_tag0@@": "Regolare la luminosità del raster layer.",
	"@@Contrast-and-Brightness_Brightness-Offset_tag1@@": "È possibile utilizzare il cursore per modificare l'offset luminosità o è possibile digitare un valore.",
	"@@Contrast-and-Brightness_Contrast-Offset_tag0@@": "Regolare il contrasto del raster layer.",
	"@@Contrast-and-Brightness_Contrast-Offset_tag1@@": "È possibile utilizzare il cursore per modificare l'offset contrasto o è possibile digitare un valore.",
	"@@Contrast-and-Brightness_Raster_tag0@@": "Il raster di input sul quale modificare la luminosità e il contrasto.",
	"@@Convolution_kernel_tag0@@": "<p>Questa tabella mostra come ogni pixel verrà ponderato nel processo di filtraggio. Questa tabella può essere modificata se si sceglie <strong>Definito dall'utent</strong>e come <strong>Tipo</strong>.</p>",
	"@@Convolution_Raster_tag0@@": "Il dataset raster di input.",
	"@@Convolution_Type_tag0@@": "Selezionare il tipo di filtro che si vuole eseguire. Vi sono opzioni di nitidezza, sfocatura e rilevamento margini, o è possibile definire il proprio filtro basato su kernel",
	"@@Corridor_Distance-Raster-1_tag0@@": "Il primo raster di distanza di input. Deve essere un output di distanza di costo cumulativo dalla Distanza di costo o dalla Distanza di percorso.",
	"@@Corridor_Distance-Raster-2_tag0@@": "Il secondo raster di distanza di input. Deve essere un output di distanza di costo cumulativo dalla Distanza di costo o dalla Distanza di percorso.",
	"@@Cos_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Cos_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Cos_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Cos_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Cos_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Cos_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Cos_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Cos_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Cos_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Cos_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Cos_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Cos_Raster_tag0@@": "L'input per il quale calcolare i valori di coseno.",
	"@@CosH_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@CosH_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@CosH_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@CosH_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@CosH_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@CosH_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@CosH_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@CosH_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@CosH_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@CosH_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@CosH_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@CosH_Raster_tag0@@": "L'input per il quale calcolare i valori di coseno iperbolico.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag0@@": "Questo parametro simula l'aumento dello sforzo per superare i costi man mano che il costo cumulativo aumenta. Viene usato per modellare l'affaticamento del viaggiatore. Il costo cumulativo crescente per raggiungere una cella viene moltiplicato per il tasso di resistenza e aggiunto al costo per lo spostamento nella cella consecutiva.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag1@@": "Si tratta di una versione modificata di una formula composta di tasso di interesse che viene utilizzata per calcolare il costo apparente di spostamento attraverso una cella. Con l'aumentare del valore del tasso di resistenza, aumenta anche il costo delle celle visitate in seguito. Quanto maggiore è il tasso di resistenza, tanto più alto sarà il costo per raggiungere la cella successiva, che è resistente a ogni movimento consecutivo. Dal momento che il tasso di resistenza è simile a un tasso composto e generalmente i valori di costo cumulativo sono molto grandi, si consigliano tassi di resistenza piccoli, come 0,005 o anche meno, a seconda dei valori di costo cumulativi.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag2@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag3@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Cost-Allocation_Capacity_tag0@@": "Definisce la capacità di costo per il viaggiatore relativa a un'origine. I calcoli del costo continuano per ogni origine finché non si raggiunge la capacità specificata.",
	"@@Cost-Allocation_Capacity_tag1@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Cost-Allocation_Capacity_tag2@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Cost-Allocation_Cost-Raster_tag0@@": "Un raster di input obbligatorio che definisce il costo o l'impedenza dello spostamento planimetrico attraverso ciascuna cella. Il valore a ogni posizione della cella rappresenta la distanza di costo per unità per l'attraversamento della stessa. Ogni valore di posizione di una cella viene moltiplicato per la risoluzione della cella e compensa inoltre il movimento diagonale per ottenere il costo totale dell'attraversamento della stessa.",
	"@@Cost-Allocation_Cost-Raster_tag1@@": "I valori del <strong>Raster di costo</strong> possono essere a numero intero o a virgola mobile, ma non possono essere negativi o zero.",
	"@@Cost-Allocation_Maximum-Distance_tag0@@": "La soglia che i valori di costo cumulativi non possono superare. Se una distanza di costo cumulativo supera questo valore, il valore di output per la posizione della cella sarà ${NoData}. La distanza massima definisce l'estensione per la quale si calcolano le distanze di costo cumulative. La distanza predefinita è fino all'estensione del raster di output.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag0@@": "Un moltiplicatore da applicare ai valori di costo.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag1@@": "Questo parametro consente il controllo della modalità di spostamento o della grandezza all'origine. Maggiore è il moltiplicatore, maggiore è il costo per lo spostamento attraverso ogni cella.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag2@@": "I valori devono essere maggiori di zero. L'impostazione predefinita è 1.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag3@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Cost-Allocation_Source-Field_tag0@@": "Il campo usato per assegnare valori alle posizioni di origine. Deve essere di tipo numero intero. Se il <strong>Raster valore</strong> è stato impostato, i valori di quell'input avranno priorità su qualunque impostazione di <strong>Campo di origine</strong>.",
	"@@Cost-Allocation_Source-Raster_tag0@@": "Il raster di input obbligatorio per le posizioni di origine.",
	"@@Cost-Allocation_Source-Raster_tag1@@": "È un raster che identifica le celle o le posizioni dalle quali si calcola la distanza di costo minima cumulativa per ogni posizione di cella di output.",
	"@@Cost-Allocation_Source-Raster_tag2@@": "Se il <strong>Raster origine</strong> di input è a virgola mobile, è necessario impostare il <strong>Raster valore</strong> e deve essere un numero intero. Il <strong>Raster valore</strong> avrà priorità su qualunque impostazione del <strong>Campo di origine</strong>.",
	"@@Cost-Allocation_Start-Cost_tag0@@": "Il costo di inizio con il quale avviare i calcoli del costo. Questo parametro consente di specificare il costo fisso associato ad un'origine. Invece di iniziare con un costo 0, l'algoritmo del costo inizierà con il valore specificato.",
	"@@Cost-Allocation_Start-Cost_tag1@@": "Il valore deve essere pari o superiore a zero. L'impostazione predefinita è 0.",
	"@@Cost-Allocation_Travel-Direction_tag0@@": "Definisce la direzione del viaggiatore quando si applica il tasso di resistenza dell'origine e il costo iniziale dell'origine.",
	"@@Cost-Allocation_Travel-Direction_tag1@@": "<strong>Dall'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire dall'origine di input e poi spostandosi alle celle non-origine. Questa è l'impostazione predefinita.",
	"@@Cost-Allocation_Travel-Direction_tag3@@": "<strong>Verso l'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire da ciascuna cella non-origine e poi tornando indietro all'origine di input.",
	"@@Cost-Allocation_Travel-Direction_tag5@@": "Specificare la parola chiave <strong>Dall'origine</strong> o <strong>Verso l'origine</strong>, che sarà applicata a tutte le origini, oppure specificare un campo nel <strong>Raster di origine</strong> che contiene le parole chiave per identificare la direzione di viaggio per ogni origine. Quel campo deve contenere la stringa ${FROM_SOURCE} o ${TO_SOURCE}.",
	"@@Cost-Allocation_Value-Raster_tag0@@": "Il raster di input a numero intero che identifica i valori di zona da usare per ogni posizione di origine di input. Per ogni cella di posizione di origine, il valore definito dal <strong>Raster di valori</strong> sarà assegnato a tutte le celle assegnate alla posizione di origine per il calcolo. Il <strong>Raster di valori</strong> avrà priorità su qualunque impostazione per il <strong>Campo di origine</strong>.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag0@@": "Questo parametro simula l'aumento dello sforzo per superare i costi man mano che il costo cumulativo aumenta. Viene usato per modellare l'affaticamento del viaggiatore. Il costo cumulativo crescente per raggiungere una cella viene moltiplicato per il tasso di resistenza e aggiunto al costo per lo spostamento nella cella consecutiva.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag1@@": "Si tratta di una versione modificata di una formula composta di tasso di interesse che viene utilizzata per calcolare il costo apparente di spostamento attraverso una cella. Con l'aumentare del valore del tasso di resistenza, aumenta anche il costo delle celle visitate in seguito. Quanto maggiore è il tasso di resistenza, tanto più alto sarà il costo per raggiungere la cella successiva, che è resistente a ogni movimento consecutivo. Dal momento che il tasso di resistenza è simile a un tasso composto e generalmente i valori di costo cumulativo sono molto grandi, si consigliano tassi di resistenza piccoli, come 0,005 o anche meno, a seconda dei valori di costo cumulativi.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag2@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag3@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Cost-Back-Link_Capacity_tag0@@": "Definisce la capacità di costo per il viaggiatore relativa a un'origine. I calcoli del costo continuano per ogni origine finché non si raggiunge la capacità specificata.",
	"@@Cost-Back-Link_Capacity_tag1@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Cost-Back-Link_Capacity_tag2@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Cost-Back-Link_Cost-Raster_tag0@@": "Un raster di input obbligatorio che definisce il costo o l'impedenza dello spostamento planimetrico attraverso ciascuna cella. Il valore a ogni posizione della cella rappresenta la distanza di costo per unità per l'attraversamento della stessa. Ogni valore di posizione di una cella viene moltiplicato per la risoluzione della cella e compensa inoltre il movimento diagonale per ottenere il costo totale dell'attraversamento della stessa.",
	"@@Cost-Back-Link_Cost-Raster_tag1@@": "I valori del <strong>Raster di costo</strong> possono essere a numero intero o a virgola mobile, ma non possono essere negativi o zero.",
	"@@Cost-Back-Link_Maximum-Distance_tag0@@": "La soglia che i valori di costo cumulativi non possono superare. Se una distanza di costo cumulativo supera questo valore, il valore di output per la posizione della cella sarà NoData. La distanza massima definisce l'estensione per la quale si calcolano le distanze di costo cumulative. La distanza predefinita è fino all'estensione del raster di output.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag0@@": "Un moltiplicatore da applicare ai valori di costo.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag1@@": "Questo parametro consente il controllo della modalità di spostamento o della grandezza all'origine. Maggiore è il moltiplicatore, maggiore è il costo per lo spostamento attraverso ogni cella.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag2@@": "I valori devono essere maggiori di zero. L'impostazione predefinita è 1.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag3@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Cost-Back-Link_Source-Raster_tag0@@": "Il raster di input obbligatorio per le posizioni di origine.",
	"@@Cost-Back-Link_Source-Raster_tag1@@": "È un raster che identifica le celle o le posizioni dalle quali si calcola la distanza di costo minima cumulativa per ogni posizione di cella di output.",
	"@@Cost-Back-Link_Start-Cost_tag0@@": "Il costo di inizio con il quale avviare i calcoli del costo. Questo parametro consente di specificare il costo fisso associato ad un'origine. Invece di iniziare con un costo 0, l'algoritmo del costo inizierà con il valore specificato.",
	"@@Cost-Back-Link_Start-Cost_tag1@@": "Il valore deve essere pari o superiore a zero. L'impostazione predefinita è 0.",
	"@@Cost-Back-Link_Travel-Direction_tag0@@": "Definisce la direzione del viaggiatore quando si applica il tasso di resistenza dell'origine e il costo iniziale dell'origine.",
	"@@Cost-Back-Link_Travel-Direction_tag1@@": "<strong>Dall'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire dall'origine di input e poi spostandosi alle celle non-origine. Questa è l'impostazione predefinita.",
	"@@Cost-Back-Link_Travel-Direction_tag3@@": "<strong>Verso l'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire da ciascuna cella non-origine e poi tornando indietro all'origine di input.",
	"@@Cost-Back-Link_Travel-Direction_tag5@@": "Specificare la parola chiave <strong>Dall'origine</strong> o <strong>Verso l'origine</strong>, che sarà applicata a tutte le origini, oppure specificare un campo nel <strong>Raster di origine</strong> che contiene le parole chiave per identificare la direzione di viaggio per ogni origine. Quel campo deve contenere la stringa ${FROM_SOURCE} o ${TO_SOURCE}.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag0@@": "Questo parametro simula l'aumento dello sforzo per superare i costi man mano che il costo cumulativo aumenta. Viene usato per modellare l'affaticamento del viaggiatore. Il costo cumulativo crescente per raggiungere una cella viene moltiplicato per il tasso di resistenza e aggiunto al costo per lo spostamento nella cella consecutiva.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag1@@": "Si tratta di una versione modificata di una formula composta di tasso di interesse che viene utilizzata per calcolare il costo apparente di spostamento attraverso una cella. Con l'aumentare del valore del tasso di resistenza, aumenta anche il costo delle celle visitate in seguito. Quanto maggiore è il tasso di resistenza, tanto più alto sarà il costo per raggiungere la cella successiva, che è resistente a ogni movimento consecutivo. Dal momento che il tasso di resistenza è simile a un tasso composto e generalmente i valori di costo cumulativo sono molto grandi, si consigliano tassi di resistenza piccoli, come 0,005 o anche meno, a seconda dei valori di costo cumulativi.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag2@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag3@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Cost-Distance_Capacity_tag0@@": "Definisce la capacità di costo per il viaggiatore relativa a un'origine. I calcoli del costo continuano per ogni origine finché non si raggiunge la capacità specificata.",
	"@@Cost-Distance_Capacity_tag1@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Cost-Distance_Capacity_tag2@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Cost-Distance_Cost-Raster_tag0@@": "Un raster di input obbligatorio che definisce il costo o l'impedenza dello spostamento planimetrico attraverso ciascuna cella. Il valore a ogni posizione della cella rappresenta la distanza di costo per unità per l'attraversamento della stessa. Ogni valore di posizione di una cella viene moltiplicato per la risoluzione della cella e compensa inoltre il movimento diagonale per ottenere il costo totale dell'attraversamento della stessa.",
	"@@Cost-Distance_Cost-Raster_tag1@@": "I valori del <strong>Raster di costo</strong> possono essere a numero intero o a virgola mobile, ma non possono essere negativi o zero.",
	"@@Cost-Distance_Maximum-Distance_tag0@@": "La soglia che i valori di costo cumulativi non possono superare. Se una distanza di costo cumulativo supera questo valore, il valore di output per la posizione della cella sarà NoData. La distanza massima definisce l'estensione per la quale si calcolano le distanze di costo cumulative. La distanza predefinita è fino all'estensione del raster di output.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag0@@": "Un moltiplicatore da applicare ai valori di costo.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag1@@": "Questo parametro consente il controllo della modalità di spostamento o della grandezza all'origine. Maggiore è il moltiplicatore, maggiore è il costo per lo spostamento attraverso ogni cella.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag2@@": "I valori devono essere maggiori di zero. L'impostazione predefinita è 1.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag3@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Cost-Distance_Source-Raster_tag0@@": "Il raster di input obbligatorio per le posizioni di origine.",
	"@@Cost-Distance_Source-Raster_tag1@@": "È un raster che identifica le celle o le posizioni dalle quali si calcola la distanza di costo minima cumulativa per ogni posizione di cella di output.",
	"@@Cost-Distance_Start-Cost_tag0@@": "Il costo di inizio con il quale avviare i calcoli del costo. Questo parametro consente di specificare il costo fisso associato ad un'origine. Invece di iniziare con un costo 0, l'algoritmo del costo inizierà con il valore specificato.",
	"@@Cost-Distance_Start-Cost_tag1@@": "Il valore deve essere pari o superiore a zero. L'impostazione predefinita è 0.",
	"@@Cost-Distance_Travel-Direction_tag0@@": "Definisce la direzione del viaggiatore quando si applica il tasso di resistenza dell'origine e il costo iniziale dell'origine.",
	"@@Cost-Distance_Travel-Direction_tag1@@": "<strong>Dall'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire dall'origine di input e poi spostandosi alle celle non-origine. Questa è l'impostazione predefinita.",
	"@@Cost-Distance_Travel-Direction_tag3@@": "<strong>Verso l'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire da ciascuna cella non-origine e poi tornando indietro all'origine di input.",
	"@@Cost-Distance_Travel-Direction_tag5@@": "Specificare la parola chiave <strong>Dall'origine</strong> o <strong>Verso l'origine</strong>, che sarà applicata a tutte le origini, oppure specificare un campo nel <strong>Raster di origine</strong> che contiene le parole chiave per identificare la direzione di viaggio per ogni origine. Quel campo deve contenere la stringa ${FROM_SOURCE} o ${TO_SOURCE}.",
	"@@Curvature_Curvature-Type_tag0@@": "Il tipo di curvatura accentua diversi aspetti della pendenza. Esistono tre opzioni di curvatura:",
	"@@Curvature_Curvature-Type_tag1@@": "Superficie alare: è perpendicolare alla direzione della pendenza massima. Influenza la convergenza e la divergenza dei flussi su una superficie.",
	"@@Curvature_Curvature-Type_tag2@@": "Profilo: è parallelo alla pendenza e indica la direzione della pendenza massima. Influenza l'accelerazione e la decelerazione dei flussi sulla superficie.",
	"@@Curvature_Curvature-Type_tag3@@": "Standard: combina le curvature di <strong>Profilo</strong> e di <strong>Planform</strong>.",
	"@@Curvature_DEM_tag0@@": "Un raster del modello di elevazione digitale (DEM).",
	"@@Curvature_Z-Factor_tag0@@": "Il fattore z regola le unità di misura per le unità z quando differiscono dalle unità x,y delle superficie di input. Se le unità x,y e le unità z sono rappresentate con la stessa unità di misura, il fattore z dovrebbe essere impostato come 1. I valori z della superficie di input vengono moltiplicati per il fattore z quando si calcola la superficie finale di output. Ad esempio, se le unità z sono espresse in piedi e le unità x,y sono espresse in metri, si userà un fattore z di 0,3048 per convertire le unità z da piedi a metri, dal momento che 1 piede = 0,3048 metri.",
	"@@Divide_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Divide_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Divide_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Divide_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Divide_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Divide_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Divide_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Divide_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Divide_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Divide_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Divide_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Divide_Raster_tag0@@": "L'input il cui valore verrà diviso per il secondo input.",
	"@@Divide_Raster_tag1@@": "È possibile usare un numero come input per questo parametro, purché sia specificato un raster per ${Raster2}.",
	"@@Divide_Raster2_tag0@@": "L'input il cui valore verrà diviso per il primo input.",
	"@@Divide_Raster2_tag1@@": "È possibile usare un numero come input per questo parametro, purché sia specificato un raster per ${Raster}.",
	"@@Elevation-Void-Fill_DEM_tag0@@": "Il DEM di input.",
	"@@Elevation-Void-Fill_Max-Void-Width_tag0@@": "Il valore di larghezza massima del vuoto viene usato per specificare la dimensione più grande di un vuoto che si desidera riempire. Se la larghezza o l'altezza della casella di contorno intorno al vuoto è più grande del valore di larghezza massima del vuoto, il vuoto non viene riempito. Le unità di questo parametro sono le stesse di quelle usate nel sistema di riferimento spaziale dei dati.",
	"@@Elevation-Void-Fill_Max-Void-Width_tag1@@": "Se questo parametro è vuoto o ha un valore di ${0}, non si userà nessuna larghezza massima e si riempiranno tutti i vuoti. Un valore di ${-1} implica che non si riempirà nessun vuoto.",
	"@@Elevation-Void-Fill_Short-Range-IDW-Radius_tag0@@": "Il raggio massimo di ricerca che sarà usato per riempire il vuoto. Un vuoto oltre questo valore di soglia, a partire da qualunque pixel valido, resterà come vuoto. Le unità di questo parametro sono le stesse di quelle usate nel sistema di riferimento spaziale dei dati.",
	"@@Elevation-Void-Fill_Short-Range-IDW-Radius_tag1@@": "Se il valore di questo parametro è vuoto, ${0} o ${-1} questo parametro non sarà usato.",
	"@@Equal-to_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Equal-to_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Equal-to_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Equal-to_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Equal-to_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Equal-to_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Equal-to_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Equal-to_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Equal-to_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Equal-to_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Equal-to_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Equal-to_Raster_tag0@@": "L'input che verrà usato per comparare l'uguaglianza con il secondo input.",
	"@@Equal-to_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Equal-to_Raster2_tag0@@": "L'input che verrà usato per comparare l'uguaglianza con il primo input.",
	"@@Equal-to_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Euclidean-Allocation_Cellsize_tag0@@": "La dimensione della cella alla quale si creerà il raster di output.",
	"@@Euclidean-Allocation_Cellsize_tag1@@": "Se la dimensione della cella è stata esplicitamente impostata in <strong>Ambienti di analisi</strong>, quella sarà la dimensione della cella predefinita. Se non è stata impostata, la dimensione della cella di output sarà la stessa del <strong>Raster di origine</strong>.",
	"@@Euclidean-Allocation_Distance-Method_tag0@@": "Determina se calcolare la distanza con un metodo planare (terra piatta) o geodetico (ellissoide).",
	"@@Euclidean-Allocation_Distance-Method_tag1@@": "Geodetica: la linea più breve tra due punti sulla superficie terrestre su uno sferoide (ellissoide). Pertanto, indipendentemente dalla proiezione di input o output, i risultati non cambiano. La linea geodetica può essere usata se si desidera determinare la distanza più breve tra due città per la traiettoria di un aereo. Questo metodo è conosciuto anche come linea del cerchio massimo se basato su una sfera piuttosto che su un ellissoide.",
	"@@Euclidean-Allocation_Distance-Method_tag2@@": "Planare: la misurazione planare utilizza la matematica cartesiana 2D per calcolare area e lunghezza. Questa opzione è disponibile solo quando si misura in un sistema di coordinate proiettato e il piano 2D di tale sistema di coordinate viene utilizzato come base per le misurazioni.",
	"@@Euclidean-Allocation_Maximum-Distance_tag0@@": "Definisce la distanza limite entro la quale viene determinata l'origine più vicina. Se la distanza fino all'origine più vicina supera questo valore, l'output di quella cella sarà ${NoData}.",
	"@@Euclidean-Allocation_Maximum-Distance_tag1@@": "La distanza predefinita è fino all'estensione del raster di output.",
	"@@Euclidean-Allocation_Raster-Barriers_tag0@@": "Il raster che definisce le barriere.",
	"@@Euclidean-Allocation_Raster-Barriers_tag1@@": "Il dataset deve contenere ${NoData} laddove non ci sono barriere. Le barriere sono rappresentate da valori validi, incluso lo zero.",
	"@@Euclidean-Allocation_Raster-Barriers_tag2@@": "Le barriere possono essere definite da un numero intero o da un raster a virgola mobile.",
	"@@Euclidean-Allocation_Source-Field_tag0@@": "Il campo usato per assegnare valori alle posizioni di origine. Deve essere di tipo numero intero. Se il <strong>Raster valore</strong> è stato impostato, i valori di quell'input avranno priorità su qualunque impostazione di <strong>Campo di origine</strong>.",
	"@@Euclidean-Allocation_Source-Raster_tag0@@": "Un raster di input obbligatorio che identifica le posizioni di origine. Basandosi sulla distanza euclidea, l'origine più vicina verrà determinata per ogni cella presente nell'output",
	"@@Euclidean-Allocation_Source-Raster_tag1@@": "Il tipo di input può essere un numero intero o un valore a virgola mobile.",
	"@@Euclidean-Allocation_Value-Raster_tag0@@": "Il raster di input a numero intero che identifica i valori di zona da usare per ogni posizione di origine di input. Per ogni cella di posizione di origine, il valore definito dal <strong>Raster di valori</strong> sarà assegnato a tutte le celle assegnate alla posizione di origine per il calcolo. Il <strong>Raster di valori</strong> avrà priorità su qualunque impostazione per il <strong>Campo di origine</strong>.",
	"@@Euclidean-Direction_Cellsize_tag0@@": "La dimensione della cella alla quale si creerà il raster di output.",
	"@@Euclidean-Direction_Cellsize_tag1@@": "Se la dimensione della cella è stata esplicitamente impostata in <strong>Ambienti di analisi</strong>, quella sarà la dimensione della cella predefinita. Se non è stata impostata, la dimensione della cella di output sarà la stessa del <strong>Raster di origine</strong>.",
	"@@Euclidean-Direction_Distance-Method_tag0@@": "Determina se calcolare la distanza con un metodo planare (terra piatta) o geodetico (ellissoide).",
	"@@Euclidean-Direction_Distance-Method_tag1@@": "Geodetica: la linea più breve tra due punti sulla superficie terrestre su uno sferoide (ellissoide). Pertanto, indipendentemente dalla proiezione di input o output, i risultati non cambiano. La linea geodetica può essere usata se si desidera determinare la distanza più breve tra due città per la traiettoria di un aereo. Questo metodo è conosciuto anche come linea del cerchio massimo se basato su una sfera piuttosto che su un ellissoide.",
	"@@Euclidean-Direction_Distance-Method_tag2@@": "Planare: la misurazione planare utilizza la matematica cartesiana 2D per calcolare area e lunghezza. Questa opzione è disponibile solo quando si misura in un sistema di coordinate proiettato e il piano 2D di tale sistema di coordinate viene utilizzato come base per le misurazioni.",
	"@@Euclidean-Direction_Maximum-Distance_tag0@@": "Definisce la distanza limite entro la quale viene calcolata la direzione verso l'origine più vicina. Se la distanza fino all'origine più vicina supera questo valore, l'output di quella cella sarà ${NoData}.",
	"@@Euclidean-Direction_Maximum-Distance_tag1@@": "La distanza predefinita è fino all'estensione del raster di output.",
	"@@Euclidean-Direction_Raster-Barriers_tag0@@": "Il raster che definisce le barriere.",
	"@@Euclidean-Direction_Raster-Barriers_tag1@@": "Il dataset deve contenere NoData laddove non ci sono barriere. Le barriere sono rappresentate da valori validi, incluso lo zero.",
	"@@Euclidean-Direction_Raster-Barriers_tag2@@": "Le barriere possono essere definite da un numero intero o da un raster a virgola mobile.",
	"@@Euclidean-Direction_Source-Raster_tag0@@": "Un raster di input obbligatorio che identifica le celle o le posizioni sulle quali si calcola la direzione euclidea per ogni posizione della cella di output.",
	"@@Euclidean-Direction_Source-Raster_tag1@@": "Il tipo di input può essere un numero intero o un valore a virgola mobile.",
	"@@Euclidean-Distance_Cellsize_tag0@@": "La dimensione della cella alla quale si creerà il raster di output.",
	"@@Euclidean-Distance_Cellsize_tag1@@": "Se la dimensione della cella è stata esplicitamente impostata in <strong>Ambienti di analisi</strong>, quella sarà la dimensione della cella predefinita. Se non è stata impostata, la dimensione della cella di output sarà la stessa del <strong>Raster di origine</strong>.",
	"@@Euclidean-Distance_Distance-Method_tag0@@": "Determina se calcolare la distanza con un metodo planare (terra piatta) o geodetico (ellissoide).",
	"@@Euclidean-Distance_Distance-Method_tag1@@": "Geodetica: la linea più breve tra due punti sulla superficie terrestre su uno sferoide (ellissoide). Pertanto, indipendentemente dalla proiezione di input o output, i risultati non cambiano. La linea geodetica può essere usata se si desidera determinare la distanza più breve tra due città per la traiettoria di un aereo. Questo metodo è conosciuto anche come linea del cerchio massimo se basato su una sfera piuttosto che su un ellissoide.",
	"@@Euclidean-Distance_Distance-Method_tag2@@": "Planare: la misurazione planare utilizza la matematica cartesiana 2D per calcolare area e lunghezza. Questa opzione è disponibile solo quando si misura in un sistema di coordinate proiettato e il piano 2D di tale sistema di coordinate viene utilizzato come base per le misurazioni.",
	"@@Euclidean-Distance_Maximum-Distance_tag0@@": "La soglia che i valori di distanza cumulativi non possono superare. Se una distanza euclidea cumulativa supera questo valore, il valore di output per la posizione della cella sarà NoData.",
	"@@Euclidean-Distance_Maximum-Distance_tag1@@": "La distanza predefinita è fino all'estensione del raster di output.",
	"@@Euclidean-Distance_Raster-Barriers_tag0@@": "Il raster che definisce le barriere.",
	"@@Euclidean-Distance_Raster-Barriers_tag1@@": "Il dataset deve contenere ${NoData} laddove non ci sono barriere. Le barriere sono rappresentate da valori validi, incluso lo zero.",
	"@@Euclidean-Distance_Raster-Barriers_tag2@@": "Le barriere possono essere definite da un numero intero o da un raster a virgola mobile.",
	"@@Euclidean-Distance_Source-Raster_tag0@@": "Il raster di input obbligatorio che identifica le celle o le posizioni sulle quali si calcola la distanza euclidea per ogni posizione della cella di output.",
	"@@Euclidean-Distance_Source-Raster_tag1@@": "Il tipo di input può essere un numero intero o un valore a virgola mobile.",
	"@@Exp_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Exp_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Exp_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Exp_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Exp_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Exp_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Exp_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Exp_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Exp_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Exp_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Exp_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Exp_Raster_tag0@@": "I valori di input per i quali è necessario trovare la base e l'esponente.",
	"@@Exp10_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Exp10_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Exp10_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Exp10_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Exp10_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Exp10_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Exp10_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Exp10_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Exp10_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Exp10_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Exp10_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Exp10_Raster_tag0@@": "I valori di input per i quali è necessario trovare la base 10 dell'esponente.",
	"@@Exp2_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Exp2_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Exp2_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Exp2_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Exp2_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Exp2_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Exp2_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Exp2_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Exp2_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Exp2_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Exp2_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Exp2_Raster_tag0@@": "I valori di input per i quali è necessario trovare la base 2 dell'esponente.",
	"@@Extract-Bands_Band_tag0@@": "Selezionare le bande da estrarre da un elenco in base all'opzione di parametro <strong>Metodo</strong> utilizzata.",
	"@@Extract-Bands_Combination_tag0@@": "La combinazione di banda o l'ordine di banda. L'elenco di selezione dipende dall'opzione <strong>Metodo</strong> specificata. Ad esempio, se <strong>Metodo</strong> è <strong>Nomi di bande</strong>, è possibile selezionare una combinazione Blu, Verde e Rosso per estrarre un'immagine dal colore naturale.",
	"@@Extract-Bands_Method_tag0@@": "Selezionare uno dei seguenti metodi per l'estrazione delle bande:",
	"@@Extract-Bands_Method_tag1@@": "<strong>ID banda</strong>: la designazione o il numero delle bande, che è un valore univoco per ogni sensore. Questi possono essere identici ai <strong>Nomi banda</strong>.",
	"@@Extract-Bands_Method_tag4@@": "<strong>Nomi banda</strong>: utilizza il nome della banda che rappresenta l'intervallo di lunghezza d'onda sullo spettro elettromagnetico (Rosso, Infrarosso vicino, Infrarosso termico, ad esempio). Questo può inoltre essere identificato come numero ID della banda.",
	"@@Extract-Bands_Method_tag6@@": "<strong>Lunghezze d'onda bande</strong>: la lunghezza d'onda sullo spettro elettromagnetico.",
	"@@Extract-Bands_Missing-Band-Action_tag0@@": "Specificare l'azione che si verificherà nel caso in cui una banda all'interno dell'elenco delle bande estratte non dovesse essere disponibile.",
	"@@Extract-Bands_Missing-Band-Action_tag1@@": "<strong>Corrispondenza migliore</strong>: trova le migliori bande disponibili da utilizzare al posto delle bande mancanti basate sulla lunghezza d'onda, affinché la funzione non riporti un errore",
	"@@Extract-Bands_Missing-Band-Action_tag3@@": "<strong>Errore</strong>: se nel dataset di input manca una banda specificata nel parametro <strong>Banda</strong>, la funzione darà errore.",
	"@@Extract-Bands_Raster_tag0@@": "Il prodotto del raster dal quale verranno estratte una o più bande.",
	"@@Fill_Raster_tag0@@": "Un raster di elevazione a banda singola.",
	"@@Fill_Z-Limit_tag0@@": "La differenza di elevazione massima tra un pozzo e il punto di versamento da riempire.",
	"@@Fill_Z-Limit_tag1@@": "A meno che non venga specificato un valore per questo parametro, verranno riempiti tutti i pozzi, indipendentemente dalla loro profondità.",
	"@@Fill_Z-Limit_tag2@@": "Il valore di <strong>Limite Z</strong> deve essere maggiore di zero.",
	"@@Float_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Float_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Float_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Float_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Float_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Float_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Float_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Float_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Float_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Float_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Float_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Float_Raster_tag0@@": "Il raster di input da convertire in virgola mobile.",
	"@@Flow-Accumulation_Flow-Direction-Raster_tag0@@": "Il raster di input che mostra la direzione del flusso fuori da ogni cella.",
	"@@Flow-Accumulation_Flow-Direction-Raster_tag1@@": "Il raster di direzione del flusso può essere creato eseguendo la funzione <strong>Direzione flusso</strong>.",
	"@@Flow-Accumulation_Flow-Direction-Type_tag0@@": "Definisce il tipo di raster di direzione di flusso di input.",
	"@@Flow-Accumulation_Flow-Direction-Type_tag1@@": "<strong>D8</strong>: il raster di direzione di flusso di input è del tipo D8. Questa è l'impostazione predefinita.",
	"@@Flow-Accumulation_Flow-Direction-Type_tag3@@": "<strong>DINF</strong>: il raster di direzione di flusso di input è del tipo D-Infinity (DINF).",
	"@@Flow-Accumulation_Flow-Direction-Type_tag5@@": "<strong>MFD</strong>: il raster di direzione di flusso di input è del tipo Direzione multi flusso (MFD).",
	"@@Flow-Accumulation_Output-Data-Type_tag0@@": "Il raster di accumulo di output può essere del tipo intero o del tipo valore a virgola mobile.",
	"@@Flow-Accumulation_Output-Data-Type_tag1@@": "<strong>Float</strong>: il raster di output sarà del tipo valore a virgola mobile. Questa è l'impostazione predefinita.",
	"@@Flow-Accumulation_Output-Data-Type_tag3@@": "<strong>Numero intero</strong>: il raster di output sarà del tipo intero.",
	"@@Flow-Accumulation_Weight-Raster_tag0@@": "Un raster di input opzionale per l'applicazione della ponderazione a ogni pixel.",
	"@@Flow-Accumulation_Weight-Raster_tag1@@": "Se non è stato specificato nessun raster di ponderazione, verrà applicata una ponderazione di 1 a ogni pixel.",
	"@@Flow-Direction_Flow-Direction-Type_tag0@@": "Definisce il tipo di raster di direzione di flusso di input.",
	"@@Flow-Direction_Flow-Direction-Type_tag1@@": "<strong>D8</strong>: il raster di direzione di flusso di input è del tipo D8. Questa è l'impostazione predefinita.",
	"@@Flow-Direction_Flow-Direction-Type_tag3@@": "<strong>DINF</strong>: il raster di direzione di flusso di input è del tipo D-Infinity (DINF).",
	"@@Flow-Direction_Flow-Direction-Type_tag5@@": "<strong>MFD</strong>: il raster di direzione di flusso di input è del tipo Direzione multi flusso (MFD).",
	"@@Flow-Direction_Force-all-edge-cells-to-flow-outward_tag0@@": "Specifica se i pixel margine fluiranno sempre verso l'esterno o seguiranno le normali regole di flusso.",
	"@@Flow-Direction_Force-all-edge-cells-to-flow-outward_tag1@@": "<strong>No</strong>: se il rilascio massimo nella parte interna di un pixel margine è maggiore di zero, la direzione di flusso verrà determinata come sempre; in caso contrario, la direzione di flusso sarà rivolta verso il margine. I pixel che dovrebbero fluire dal margine del raster di superficie verso la parte interna, lo faranno. Questa è l'impostazione predefinita.",
	"@@Flow-Direction_Force-all-edge-cells-to-flow-outward_tag3@@": "<strong>Sì</strong>: tutti i pixel al margine del raster di superficie fluiranno verso la parte esterna a partire dal raster di superficie.",
	"@@Flow-Direction_Raster_tag0@@": "Il raster di input che rappresenta una superficie di elevazione continua.",
	"@@Flow-Distance_Distance-Type_tag0@@": "Determina se il componente verticale o orizzontale della distanza di flusso viene calcolato.",
	"@@Flow-Distance_Distance-Type_tag1@@": "<strong>Orizzontale</strong>: i calcoli della distanza di flusso rappresentano il componente orizzontale della distanza di flusso a partire da ogni pixel nel dominio al pixel nel flusso dentro il quale fluiscono.",
	"@@Flow-Distance_Distance-Type_tag3@@": "<strong>Verticale</strong>: i calcoli della distanza di flusso rappresentano il componente verticale della distanza di flusso a partire da ogni pixel nel dominio al pixel nel flusso dentro il quale fluiscono. Questa è l'impostazione predefinita.",
	"@@Flow-Distance_Flow-Direction-Raster_tag0@@": "Il raster di input che mostra la direzione del flusso fuori da ogni pixel.",
	"@@Flow-Distance_Flow-Direction-Raster_tag1@@": "Se viene fornito un raster di direzione di flusso, le direzioni di pendenza verso il basso saranno limitate a quelle definite dalla direzione del flusso di input.",
	"@@Flow-Distance_Flow-Direction-Raster_tag2@@": "Il raster di direzione del flusso può essere creato utilizzando la funzione Direzione flusso.",
	"@@Flow-Distance_Flow-Direction-Type_tag0@@": "Definisce il tipo di raster di direzione di flusso di input.",
	"@@Flow-Distance_Flow-Direction-Type_tag1@@": "<strong>D8</strong>: il raster di direzione di flusso di input è del tipo D8. Questa è l'impostazione predefinita.",
	"@@Flow-Distance_Flow-Direction-Type_tag3@@": "<strong>DINF</strong>: il raster di direzione di flusso di input è del tipo D-Infinity (DINF).",
	"@@Flow-Distance_Flow-Direction-Type_tag5@@": "<strong>MFD</strong>: il raster di direzione di flusso di input è del tipo Direzione multi flusso (MFD).",
	"@@Flow-Distance_Statistics-Type_tag0@@": "Determina il tipo di statistiche utilizzato per calcolare la distanza di flusso in vari percorsi di flusso. Se vi è solo un percorso di flusso da ogni cella a una cella nel flusso, tutti i tipi di statistiche produrranno lo stesso risultato.",
	"@@Flow-Distance_Statistics-Type_tag1@@": "<strong>Minimo</strong>: se esistono vari percorsi di flusso, viene calcolata la distanza di flusso minima. Questa è l'impostazione predefinita.",
	"@@Flow-Distance_Statistics-Type_tag3@@": "<strong>Media ponderata</strong>: se esistono vari percorsi di flusso, viene calcolata la media ponderata della distanza di flusso. La proporzione di flusso da una cella alle sue celle vicine a valle viene utilizzata come ponderazione per il calcolo della media ponderata.",
	"@@Flow-Distance_Statistics-Type_tag5@@": "<strong>Massimo</strong>: se esistono vari percorsi di flusso, viene calcolata la distanza di flusso massima.",
	"@@Flow-Distance_Stream-Raster_tag0@@": "Un raster di flusso di input che rappresenta una rete di flusso lineare.",
	"@@Flow-Distance_Surface-Raster_tag0@@": "Il raster di input che rappresenta una superficie di elevazione continua.",
	"@@Flow-Length_Direction-of-Measurement_tag0@@": "La direzione di misura lungo il percorso di flusso.",
	"@@Flow-Length_Direction-of-Measurement_tag1@@": "<strong>A valle</strong>: calcola la distanza della pendenza verso il basso lungo il percorso di flusso, da ogni cella a un pozzo o uscita sul margine del raster.",
	"@@Flow-Length_Direction-of-Measurement_tag3@@": "<strong>A monte</strong>: calcola la distanza della pendenza verso l'alto più lunga nel percorso di flusso, da ogni cella fino alla parte superiore dello spartiacque di drenaggio.",
	"@@Flow-Length_Flow-Direction-Raster_tag0@@": "Il raster di input che mostra la direzione del flusso fuori da ogni cella.",
	"@@Flow-Length_Flow-Direction-Raster_tag1@@": "Il raster di direzione del flusso può essere creato eseguendo la funzione <strong>Direzione flusso</strong>.",
	"@@Flow-Length_Weight-Raster_tag0@@": "Un raster di input opzionale per l'applicazione della ponderazione a ogni cella.",
	"@@Flow-Length_Weight-Raster_tag1@@": "Se non è stato specificato nessun raster ponderato, verrà applicata una ponderazione di 1 a ogni cella.",
	"@@Focal-Statistics_Ignore-NoData-in-calculations_tag0@@": "Identifica se i valori ${NoData} vengono ignorati dai calcoli statistici.",
	"@@Focal-Statistics_Ignore-NoData-in-calculations_tag1@@": "<strong>Selezionato</strong>: specifica che se esiste un valore ${NoData} all'interno di un quartiere, il valore ${NoData} verrà ignorato. Solo le celle all'interno del quartiere che hanno valori di dati verranno utilizzati per determinare il valore di output. Questa è l'impostazione predefinita.",
	"@@Focal-Statistics_Ignore-NoData-in-calculations_tag3@@": "<strong>Deselezionato</strong>: specifica che se qualsiasi cella in un quartiere ha un valore di ${NoData}, l'output per la cella di elaborazione sarà ${NoData}.",
	"@@Focal-Statistics_Neighborhood_tag0@@": "La forma dell'area intorno a ciascuna cella utilizzata per calcolare le statistiche.",
	"@@Focal-Statistics_Neighborhood_tag1@@": "Ogni quartiere ha dei parametri aggiuntivi con i quali è possibile definire la forma.",
	"@@Focal-Statistics_Neighborhood_tag2@@": "Corona circolare, raggio interno, raggio esterno",
	"@@Focal-Statistics_Neighborhood_tag3@@": "Cerchio, raggio",
	"@@Focal-Statistics_Neighborhood_tag4@@": "Valori di quartiere: irregolare, larghezza, altezza",
	"@@Focal-Statistics_Neighborhood_tag5@@": "Rettangolo, larghezza, altezza",
	"@@Focal-Statistics_Neighborhood_tag6@@": "Spicchio, raggio, angolo iniziale, angolo finale",
	"@@Focal-Statistics_Neighborhood_tag7@@": "Valori di quartiere: ponderazione, larghezza, altezza",
	"@@Focal-Statistics_Neighborhood_tag8@@": "Il quartiere irregolare consente di specificare un quartiere con una forma irregolare intorno alla cella di elaborazione. Utilizzare la tabella dei valori di quartiere per definire la forma del kernel del quartiere. Un valore di 0 per una posizione di cella indica che la cella non fa parte del quartiere e che non verrà utilizzata per l'elaborazione. Un valore di 1 indica che la sua cella corrispondente (e valore) fa parte del quartiere.",
	"@@Focal-Statistics_Neighborhood_tag9@@": "Il quartiere di ponderazione è simile al tipo di quartiere irregolare, poiché consente di definire un quartiere irregolare intorno alla cella di elaborazione, ma inoltre consente di applicare delle ponderazioni ai valori di input. I valori nei kernel ponderati specificano quali sono le posizioni delle celle da includere nel quartiere e quali sono le ponderazioni per le quali dovrebbero essere moltiplicate. Utilizzare un valore di 0 per escludere una cella dall'elaborazione. I valori positivi, negativi e decimali rappresentano opzioni valide da usare come ponderazioni. Per il tipo di quartiere ponderato, sono supportate solo le statistiche Media, Deviazione standard e Somma.",
	"@@Focal-Statistics_Percentile-Value_tag0@@": "Denota quale percentile calcolare quando si seleziona <strong>Percentile</strong> come tipo di statistica. Il valore predefinito è 90 per il 90esimo percentile.",
	"@@Focal-Statistics_Percentile-Value_tag3@@": "I valori spaziano da 0 a 100. Il percentile numero 0 è essenzialmente l'equivalente della statistica minima, e il percentile numero 100 è l'equivalente della statistica massima, fatta eccezione per il fatto che il risultato sarà una virgola mobile. Un valore di 50 produrrà essenzialmente lo stesso risultato di una statistica media.",
	"@@Focal-Statistics_Raster_tag0@@": "Il raster di input obbligatorio.",
	"@@Focal-Statistics_Statistics-Type_tag0@@": "Il tipo di statistica da calcolare.",
	"@@Focal-Statistics_Statistics-Type_tag1@@": "<strong>Maggioranza</strong>: calcola la maggioranza (il valore che si verifica più spesso) delle celle nel quartiere.",
	"@@Focal-Statistics_Statistics-Type_tag3@@": "<strong>Massimo</strong>: calcola il massimo (valore più grande) delle celle nel quartiere.",
	"@@Focal-Statistics_Statistics-Type_tag5@@": "<strong>Media</strong>: calcola la media (valore medio) delle celle nel quartiere.",
	"@@Focal-Statistics_Statistics-Type_tag7@@": "<strong>Mediana</strong>: calcola la mediana delle celle nel quartiere.",
	"@@Focal-Statistics_Statistics-Type_tag9@@": "<strong>Minimo</strong>: calcola il minimo (il valore più piccolo) delle celle nel quartiere.",
	"@@Focal-Statistics_Statistics-Type_tag11@@": "<strong>Minoranza</strong>: calcola la minoranza (il valore che si verifica meno spesso) delle celle nel quartiere.",
	"@@Focal-Statistics_Statistics-Type_tag13@@": "<strong>Percentile</strong>: calcola un percentile delle celle nel quartiere. È possibile stabilire quale percentile calcolare con il parametro <strong>Valore percentile</strong>.",
	"@@Focal-Statistics_Statistics-Type_tag17@@": "<strong>Intervallo</strong>: calcola l'intervallo (differenza tra il valore più grande e il più piccolo) delle celle nel quartiere.",
	"@@Focal-Statistics_Statistics-Type_tag19@@": "<strong>Deviazione standard</strong>: calcola la deviazione standard delle celle nel quartiere.",
	"@@Focal-Statistics_Statistics-Type_tag21@@": "<strong>Somma</strong>: calcola la somma (il totale di tutti i valori) delle celle nel quartiere.",
	"@@Focal-Statistics_Statistics-Type_tag23@@": "<strong>Varietà</strong>: calcola la varietà (il numero di valori univoci) delle celle del quartiere.",
	"@@Focal-Statistics_Statistics-Type_tag25@@": "Se il raster di input è una virgola mobile, sono disponibili solo i tipi statistici Medio, Massimo, Mediano, Minimo, Percentile, Intervallo, Deviazione Standard e Somma.",
	"@@Focal-Statistics_Statistics-Type_tag26@@": "Per Medio, Mediano, Percentile e Deviazione Standard, l'output sarà sempre una virgola mobile.",
	"@@Focal-Statistics_Statistics-Type_tag27@@": "Il tipo di statistica predefinito è Medio.",
	"@@Geometric_Constant-Z_tag0@@": "Specificare un'elevazione costante da utilizzare per la funzione geometrica.",
	"@@Geometric_DEM_tag0@@": "Specificare il DEM da utilizzare per la funzione geometrica. È possibile utilizzare un DEM contenuto nel mosaic dataset come dataset raster o come mosaic dataset il cui output è un DEM.",
	"@@Geometric_Geoid_tag0@@": "La maggior parte dei dataset di elevazione, come USGS NED o Elevazione mondiale di ArcGIS Online, sono altezze ortometriche, quindi è necessario selezionare la correzione del geoide per compatibilità con gli RPC satellitari, che richiedono altezze ellissoidali. Selezionare la casella di controllo <strong>Geoid</strong> per applicare la correzione del geoide (EGM96) ai valori z, a meno che il DEM non abbia già riferimenti alle altezze ellissoidali.",
	"@@Geometric_Method_tag0@@": "Scegliere il metodo di elevazione per la funzione geometrica:",
	"@@Geometric_Method_tag1@@": "Utilizzare la costante Z: specificare un'elevazione costante per eseguire la funzione geometrica.",
	"@@Geometric_Method_tag2@@": "Utilizzare DEM: specificare un DEM per eseguire la funzione geometrica.",
	"@@Geometric_Raster_tag0@@": "Il raster di input.",
	"@@Geometric_Z-Factor_tag0@@": "I Coefficienti Polinomiali Razionali satellitari (RPC) sono scalati per i dataset di elevazione con unità verticali espresse in metri. Se l'elevazione usa altre unità verticali, immettere un <strong>Fattore Z</strong> per riscalare in metri. Ad esempio, se le unità di elevazione sono espresse in piedi, si userà un valore di 0,3048 per convertire le unità di elevazione da piedi a metri.",
	"@@Geometric_Z-Offset_tag0@@": "Il valore di base da aggiungere al valore di elevazione nel DEM. Lo si potrebbe usare per deviare i valori di elevazione che non iniziano al livello del mare.",
	"@@Geometric_Tolerance_tag0@@": "Specificare l'errore massimo tollerabile nella funzione geometrica, espresso in numero di pixel. Il valore predefinito per il tipo raster NITF (NCDRD) è due.",
	"@@Grayscale_Raster_tag0@@": "Il raster di input.",
	"@@Grayscale_Conversion-Parameters_tag0@@": "Le ponderazioni per ogni banda che comprendono il raster di input.",
	"@@Greater-Than_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Greater-Than_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Greater-Than_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Greater-Than_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Greater-Than_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Greater-Than_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Greater-Than_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Greater-Than_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Greater-Than_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Greater-Than_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Greater-Than_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Greater-Than_Raster_tag0@@": "L'input da esaminare per determinare se è più grande del secondo input.",
	"@@Greater-Than_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Greater-Than_Raster2_tag0@@": "L'input con il quale viene messo a confronto il primo input per determinare se quest'ultimo è più grande.",
	"@@Greater-Than_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Greater-Than-Equal_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Greater-Than-Equal_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Greater-Than-Equal_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Greater-Than-Equal_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Greater-Than-Equal_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Greater-Than-Equal_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Greater-Than-Equal_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Greater-Than-Equal_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Greater-Than-Equal_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Greater-Than-Equal_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Greater-Than-Equal_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Greater-Than-Equal_Raster_tag0@@": "L'input da esaminare per determinare se è più grande o uguale al secondo input.",
	"@@Greater-Than-Equal_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Greater-Than-Equal_Raster2_tag0@@": "L'input con il quale viene messo a confronto il primo input per determinare se quest'ultimo è più grande o uguale.",
	"@@Greater-Than-Equal_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Heat-Index_Heat-Index-Units_tag0@@": "L'unità di misura associata con il raster di output. Le unità di output disponibili sono Celsius, Fahrenheit e Kelvin.",
	"@@Heat-Index_Relative-Humidity-Raster_tag0@@": "Un raster a banda singola in cui i valori di pixel rappresentano l'umidità relativa come valore percentuale tra 0 e 100.",
	"@@Heat-Index_Temperature-Raster_tag0@@": "Un raster a banda singola in cui i valori di pixel rappresentano la temperatura dell'aria di ambiente.",
	"@@Heat-Index_Temperature-Units_tag0@@": "L'unità di misura associata al raster di temperatura di input. Le unità di input disponibili sono Celsius, Fahrenheit e Kelvin.",
	"@@Hillshade_Altitude_tag0@@": "L'altitudine è l'angolo di elevazione del sole sull'orizzonte e spazia da 0 a 90 gradi. Un valore di 0 gradi indica che il sole è all'orizzonte, ovvero sullo stesso piano orizzontale della cornice di riferimento. Un valore di 90 gradi indica che il sole è direttamente sopra di noi.",
	"@@Hillshade_Altitude_tag1@@": "Questo parametro è valido solo quando <strong>Tipo rilievo ombreggiato</strong> è <strong>Tradizionale</strong>. Il valore predefinito è di 45 gradi sopra l'orizzonte.",
	"@@Hillshade_Azimuth_tag0@@": "L'azimut è la posizione relativa del sole lungo l'orizzonte (in grandi). Questa posizione è indicata dall'angolo del sole misurato in senso orario rispetto al nord. Un azimut di 0 gradi indica il nord, l'est è 90 gradi, il sud è 180 gradi e l'ovest è 270 gradi.",
	"@@Hillshade_Azimuth_tag1@@": "Questo parametro è valido solo quando <strong>Tipo rilievo ombreggiato</strong> è <strong>Tradizionale</strong>. Il valore predefinito è 315 gradi, a partire da Nord-Ovest.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag0@@": "Se si usa questa opzione si eviteranno gli artefatti di ricampionamento che si possono verificare lungo i margini di un raster. I pixel di output lungo il margine di un raster o accanto ai pixel NoData verranno popolati con NoData; per questa ragione, si consiglia di utilizzare il parametro solo con mosaic dataset di elevazione con sovrapposizione. Quando sono disponibili pixel sovrapposti, le aree NoData visualizzeranno i valori di pixel sovrapposti invece di pixel vuoti.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag1@@": "Non selezionato: si applicherà un ricampionamento bilineare uniforme per ricampionare l'hillshade. Utilizzare questa opzione quando il mosaic dataset che contiene i dati del raster di elevazione è unito da ceppi. Questa è l'impostazione predefinita.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag2@@": "Selezionato: si utilizzerà un ricampionamento bilineare all'interno dell'hillshade tranne lungo i margini dei raster o accanto ai pixel di NoData. Questi pixel saranno popolati con NoData e mostreranno i valori di pixel sovrapposti, quindi ridurranno eventuali effetti di margini netti che altrimenti si verificherebbero. Utilizzare questa opzione quando il mosaic dataset che contiene i dati del raster di elevazione consiste di elementi o tile sovrapposti.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag3@@": "I risultati provenienti dalla funzione possono essere dipendenti dai dati. Osservando gli artefatti dei tile boundary nell'output, è importante selezionare le condizioni alternative della casella di selezione.",
	"@@Hillshade_Hillshade-Type_tag0@@": "Controlla la fonte di illuminazione per l'hillshade:",
	"@@Hillshade_Hillshade-Type_tag1@@": "Tradizionale: calcola l'hillshade da un'unica direzione di illuminazione. Si tratta dell'impostazione predefinita. È possibile impostare <strong>Azimut</strong> e <strong>Altitudine</strong> per controllare la posizione della fonte di luce.",
	"@@Hillshade_Hillshade-Type_tag6@@": "Multidirezionale: combina la luce da fonti multiple per rappresentare una visualizzazione migliorata del terreno.",
	"@@Hillshade_Pixel-Size-Factor_tag0@@": "Fattore dimensione pixel si riferisce alle variazioni nella scala ingrandendo e riducendo l'immagine con lo zoom sulla visualizzazione della mappa. Controlla il tasso al quale cambia il <strong>Fattore Z</strong>.",
	"@@Hillshade_Pixel-Size-Factor_tag3@@": "Questo parametro è valido solo quando il tipo di <strong>Scala</strong> è <strong>Regolato</strong>. Il valore predefinito è 0,024.",
	"@@Hillshade_Pixel-Size-Power_tag0@@": "Potenza dimensione pixel si riferisce alle variazioni di altitudine (o scala) ingrandendo e riducendo l'immagine con lo zoom sulla visualizzazione della mappa. È l'esponente applicato al termine dimensione di pixel nell'equazione che controlla il tasso al quale il <strong>Fattore Z</strong> cambia per evitare una perdita significativa di rilievo.",
	"@@Hillshade_Pixel-Size-Power_tag3@@": "Questo parametro è valido solo quando il tipo di <strong>Scala</strong> è <strong>Regolato</strong>. Il valore predefinito è 0,664.",
	"@@Hillshade_Raster_tag0@@": "Il dataset di elevazione di input.",
	"@@Hillshade_Scaling_tag0@@": "Il risultato ombreggiato è scalato dinamicamente regolando il fattore z usando una delle due opzioni seguenti:",
	"@@Hillshade_Scaling_tag1@@": "Regolata: Questa si applica a una regolazione non lineare usando i valori predefiniti di <strong>Potenza dimensione pixel</strong> e <strong>Fattore dimensione pixel</strong>, che comprende un'ampia gamma di variazioni di altitudine (scala) ingrandendo e riducendo l'immagine con lo zoom. Il parametro <strong>Regolata</strong> è consigliato quando si utilizza un dataset mondiale.",
	"@@Hillshade_Scaling_tag8@@": "Nessuna: non si applica nessuna scala. È l'opzione ideale per raster dataset singoli relativi ad un'area locale. Non è un'opzione consigliata per i dataset mondiali con grandi variazioni in termini di elevazione o con mappe multiscala poiché verrebbe prodotto un rilievo del terreno con piccole variazioni e piccole scale.",
	"@@Hillshade_Z-Factor_tag0@@": "Il fattore Z è un fattore di scala utilizzato per convertire i valori di elevazione per due motivi:",
	"@@Hillshade_Z-Factor_tag1@@": "Convertire le unità di elevazione (ad esempio, metri o piedi) in unità di coordinate orizzontali del dataset, che possono essere piedi, metri o gradi.",
	"@@Hillshade_Z-Factor_tag2@@": "Aggiungere il fattore di esagerazione verticale per ottenere un effetto visivo.",
	"@@Int_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Int_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Int_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Int_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Int_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Int_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Int_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Int_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Int_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Int_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Int_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Int_Raster_tag0@@": "Il raster di input da convertire in intero.",
	"@@Interpolate-Irregular-Data_Cellsize_tag0@@": "La dimensione delle celle per il raster di output sarà automaticamente rilevata; tuttavia, è possibile cambiarla. È possibile cambiare la dimensione delle celle, ma l'estensione del raster dataset rimarrà la stessa.",
	"@@Interpolate-Irregular-Data_Input-Samples_tag0@@": "I dati dei punti di input.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag0@@": "Ci sono quattro metodi di ricampionamento per questa funzione:",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag1@@": "<strong>Inverso della distanza pesata</strong>: determina i valori delle celle usando una combinazione linearmente ponderata di un insieme di punti campione o celle. Il peso è una funzione dell'inverso della distanza da punti o celle conosciute.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag3@@": "<strong>Rivestimento lineare</strong>: usa una rete irregolare triangolare dai punti centrali di ogni cella del raster irregolare per interpolare una superficie che viene quindi convertita in un raster regolare.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag5@@": "<strong>Vicino naturale</strong>: trova il sottoinsieme di campioni di input più vicino a un punto di riferimento e applica su di loro i pesi in base alle aree proporzionate per interpolare un valore.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag7@@": "<strong>Vicino più prossimo</strong>: calcola il valore dei pixel usando il pixel più vicino. Se non esiste nessun pixel di origine, non è possibile creare nessun pixel nuovo nell'output. Questa è l'impostazione predefinita.",
	"@@Interpolate-Irregular-Data_Search-Radius_tag0@@": "Identifica il numero di pixel da includere per il metodo selezionato di ricampionamento. Il valore predefinito è ${3} pixel.",
	"@@Interpolate-Irregular-Data_Value-Field_tag0@@": "Se si seleziona una feature class puntuale come input, sarà necessario identificare il campo nella tabella attributi con il valore dei punti",
	"@@Is-Null_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Is-Null_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Is-Null_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Is-Null_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Is-Null_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Is-Null_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Is-Null_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Is-Null_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Is-Null_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Is-Null_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Is-Null_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Is-Null_Raster_tag0@@": "Il raster di input da esaminare per identificare le celle che sono ${NoData} (null).",
	"@@Is-Null_Raster_tag1@@": "L'input può essere un numero intero o un valore a virgola mobile.",
	"@@Key-Metadata_Band-Names_tag0@@": "Questa operazione viene utilizzata per sovrascrivere i nomi delle bande di un raster. È una stringa di valori separati da virgole che rappresenta i nomi di bande aggiornati.",
	"@@Key-Metadata_Band-Names_tag1@@": "Questo parametro è opzionale.",
	"@@Key-Metadata_Metadata-JSON_tag0@@": "I metadati principali da inserire nel raster in uscita descritti come una stringa JSON rappresentano una raccolta di coppie di valori principali. Quanto segue è un esempio di una stringa JSON che può essere utilizzata come input per questa funzione. Tutti gli input per questo parametro devono seguire lo stesso formato.",
	"@@Key-Metadata_Metadata-JSON_tag1@@": "La stringa JSON che rappresenta i metadati principali",
	"@@Key-Metadata_Metadata-JSON_tag2@@": "{ \"CloudCover\": 4, \"BandProperties\":[ { \"BandName\": \"Blue\", \"WavelengthMin\": 445, \"WavelengthMax\": 516 }, { \"BandName\": \"Green\", \"WavelengthMin\": 506, \"WavelengthMax\": 595 }, ]}",
	"@@Key-Metadata_Property-Name_tag0@@": "Il nome della proprietà principale a livello del dataset da sovrascrivere.",
	"@@Key-Metadata_Raster_tag0@@": "Il raster o il mosaic dataset che contiene metadati principali che si vuole inserire o sovrascrivere.",
	"@@Key-Metadata_Value_tag0@@": "Il valore di sovrascrizione della proprietà principale a livello del dataset che si vuole impostare.",
	"@@Least-Cost-Path_Accumulative-Cost-Resistance-Rate_tag0@@": "Questo parametro simula l'aumento dello sforzo per superare i costi man mano che il costo cumulativo aumenta. Viene usato per modellare l'affaticamento del viaggiatore. Il costo cumulativo crescente per raggiungere una cella viene moltiplicato per il tasso di resistenza e aggiunto al costo per lo spostamento nella cella consecutiva.",
	"@@Least-Cost-Path_Accumulative-Cost-Resistance-Rate_tag1@@": "Si tratta di una versione modificata di una formula composta di tasso di interesse che viene utilizzata per calcolare il costo apparente di spostamento attraverso una cella. Con l'aumentare del valore del tasso di resistenza, aumenta anche il costo delle celle visitate in seguito. Quanto maggiore è il tasso di resistenza, tanto più alto sarà il costo per raggiungere la cella successiva, che è resistente a ogni movimento consecutivo. Dal momento che il tasso di resistenza è simile a un tasso composto e generalmente i valori di costo cumulativo sono molto grandi, si consigliano tassi di resistenza piccoli, come 0,005 o anche meno, a seconda dei valori di costo cumulativi.",
	"@@Least-Cost-Path_Accumulative-Cost-Resistance-Rate_tag2@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Least-Cost-Path_Capacity_tag0@@": "Definisce la capacità di costo per il viaggiatore relativa a un'origine. I calcoli del costo continuano per ogni origine finché non si raggiunge la capacità specificata.",
	"@@Least-Cost-Path_Capacity_tag1@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Least-Cost-Path_Cost-Raster_tag0@@": "Un raster di input obbligatorio che definisce il costo o l'impedenza dello spostamento planimetrico attraverso ciascuna cella. Il valore a ogni posizione della cella rappresenta la distanza di costo per unità per l'attraversamento della stessa. Ogni valore di posizione di una cella viene moltiplicato per la risoluzione della cella e compensa inoltre il movimento diagonale per ottenere il costo totale dell'attraversamento della stessa.",
	"@@Least-Cost-Path_Cost-Raster_tag1@@": "I valori del <strong>Raster di costo</strong> possono essere a numero intero o a virgola mobile, ma non possono essere negativi o zero.",
	"@@Least-Cost-Path_Destination-Field_tag0@@": "Il campo usato per ottenere i valori per le posizioni di destinazione.",
	"@@Least-Cost-Path_Destination-Raster_tag0@@": "Un raster di input obbligatorio che identifica i pixel da cui viene determinato il percorso di costo minimo verso l'origine meno costosa. Questo input è formato da pixel che hanno valori validi e i pixel restanti devono essere ${NoData}. I valori di 0 sono validi.",
	"@@Least-Cost-Path_Maximum-Distance_tag0@@": "La soglia che i valori di costo cumulativi non possono superare. Se una distanza di costo cumulativo supera questo valore, il valore di output per la posizione della cella sarà ${NoData}. La distanza massima definisce l'estensione per la quale si calcolano le distanze di costo cumulative. La distanza predefinita è fino all'estensione del raster di output.",
	"@@Least-Cost-Path_Multiplier-to-Apply-to-Costs_tag0@@": "Questo parametro consente il controllo della modalità di spostamento o della grandezza all'origine. Maggiore è il moltiplicatore, maggiore è il costo per lo spostamento attraverso ogni cella.",
	"@@Least-Cost-Path_Multiplier-to-Apply-to-Costs_tag1@@": "I valori devono essere maggiori di zero. L'impostazione predefinita è 1.",
	"@@Least-Cost-Path_Path-Type_tag0@@": "Una parola chiave che definisce il modo in cui i valori e le zone nei dati di destinazione di input vengono interpretati nei calcoli del percorso di costo:",
	"@@Least-Cost-Path_Path-Type_tag1@@": "<strong>Singolo migliore</strong>: per tutte i pixel nei dati di destinazione di input, il percorso di costo minimo viene ricavato dal pixel con il minimo dei percorsi di costo minimo verso le celle di origine.",
	"@@Least-Cost-Path_Path-Type_tag3@@": "<strong>Ogni cella</strong>: un percorso di costo minimo è determinato per ogni pixel con valori validi nei dati di destinazione di input, e salvato nel raster di output. Ogni cella dei dati di destinazione di input viene trattata separatamente e viene determinato un percorso di costo minimo per ciascuna cella.",
	"@@Least-Cost-Path_Path-Type_tag5@@": "<strong>Ogni zona</strong>: un percorso di costo minimo è determinato per ogni zona nei dati di destinazione di input, e salvato nel raster di output. Il percorso di costo minimo per ogni zona inizia nel pixel con la ponderazione distanza di costo più bassa nella zona.",
	"@@Least-Cost-Path_Source-Raster_tag0@@": "È un raster di input obbligatorio che identifica le celle o le posizioni dalle quali si calcola la distanza di costo minima cumulativa per ogni posizione di cella di output.",
	"@@Least-Cost-Path_Start-Cost_tag0@@": "Il costo di inizio con il quale avviare i calcoli del costo. Questo parametro consente di specificare il costo fisso associato ad un'origine. Invece di iniziare con un costo 0, l'algoritmo del costo inizierà con il valore specificato.",
	"@@Least-Cost-Path_Start-Cost_tag1@@": "Il valore deve essere pari o superiore a zero. L'impostazione predefinita è 0.",
	"@@Least-Cost-Path_Travel-Direction_tag0@@": "Definisce la direzione del viaggiatore quando si applica il tasso di resistenza dell'origine e il costo iniziale dell'origine.",
	"@@Least-Cost-Path_Travel-Direction_tag1@@": "<strong>Dall'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire dall'origine di input e poi spostandosi alle celle non-origine. Questa è l'impostazione predefinita.",
	"@@Least-Cost-Path_Travel-Direction_tag3@@": "<strong>Verso l'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire da ciascuna cella non-origine e poi tornando indietro all'origine di input.",
	"@@Least-Cost-Path_Travel-Direction_tag5@@": "Specificare la parola chiave <strong>Dall'origine</strong> o <strong>Verso l'origine</strong>, che sarà applicata a tutte le origini, oppure specificare un campo nel <strong>Raster di origine</strong> che contiene le parole chiave per identificare la direzione di viaggio per ogni origine. Quel campo deve contenere la stringa ${FROM_SOURCE} o ${TO_SOURCE}.",
	"@@Less-Than_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Less-Than_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Less-Than_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Less-Than_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Less-Than_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Less-Than_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Less-Than_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Less-Than_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Less-Than_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Less-Than_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Less-Than_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Less-Than_Raster_tag0@@": "L'input da esaminare per determinare se è più piccolo del secondo input.",
	"@@Less-Than_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Less-Than_Raster2_tag0@@": "L'input con il quale viene messo a confronto il primo input per determinare se quest'ultimo è più piccolo.",
	"@@Less-Than_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Less-Than-Equal_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Less-Than-Equal_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Less-Than-Equal_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Less-Than-Equal_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Less-Than-Equal_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Less-Than-Equal_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Less-Than-Equal_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Less-Than-Equal_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Less-Than-Equal_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Less-Than-Equal_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Less-Than-Equal_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Less-Than-Equal_Raster_tag0@@": "L'input da esaminare per determinare se è più piccolo o uguale al secondo input.",
	"@@Less-Than-Equal_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Less-Than-Equal_Raster2_tag0@@": "L'input con il quale viene messo a confronto il primo input per determinare se quest'ultimo è più piccolo o uguale.",
	"@@Less-Than-Equal_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Ln_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Ln_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Ln_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Ln_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Ln_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Ln_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Ln_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Ln_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Ln_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Ln_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Ln_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Ln_Raster_tag0@@": "I valori di input per i quali è necessario trovare il logaritmo naturale (Ln).",
	"@@Log10_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Log10_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Log10_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Log10_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Log10_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Log10_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Log10_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Log10_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Log10_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Log10_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Log10_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Log10_Raster_tag0@@": "I valori di input per i quali è necessario trovare la base 10 del logaritmo.",
	"@@Log2_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Log2_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Log2_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Log2_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Log2_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Log2_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Log2_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Log2_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Log2_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Log2_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Log2_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Log2_Raster_tag0@@": "I valori di input per i quali è necessario trovare la base 2 del logaritmo.",
	"@@Lookup_Field_tag0@@": "Il campo che contiene i valori desiderati per il nuovo raster.",
	"@@Lookup_Field_tag1@@": "Deve essere di tipo numerico.",
	"@@Lookup_Raster_tag0@@": "Il raster di input che contiene un campo dal quale creare un nuovo raster.",
	"@@Lookup_Raster_tag1@@": "Può essere un tipo intero o a virgola mobile.",
	"@@Mask_Included-Ranges_tag0@@": "Per ciascuna banda, è possibile specificare gli intervalli inclusi inserendo un valore minimo e massimo; qualsiasi valore al di fuori dell'intervallo sarà restituito come ${NoData}. Un pixel è incluso se il valore di pixel rientra in uno qualsiasi degli intervalli specificati. Pertanto, se la banda 1 ha un intervallo di 5-10 e la banda 2 ha un intervallo di 15-20 e il valore di pixel per la banda 1 è 8, questo pixel non verrà mascherato.",
	"@@Mask_NoData-Interpretation_tag0@@": "Fa riferimento a come i <strong>Valori ${NoData}</strong> influenzeranno l'immagine di output.",
	"@@Mask_NoData-Interpretation_tag3@@": "È possibile selezionare una delle due seguenti opzioni:",
	"@@Mask_NoData-Interpretation_tag4@@": "<strong>Corrispondenza con tutti</strong>: i valori ${NoData} specificati per ciascuna banda devono essere presenti nello stesso pixel affinché l'immagine di output contenga il pixel ${NoData}.",
	"@@Mask_NoData-Interpretation_tag6@@": "<strong>Corrispondenza con qualsiasi</strong>: se il valore ${NoData} specificato è presente per un pixel in una banda specifica, quel pixel nell'immagine di output sarà ${NoData}. Questa è l'impostazione predefinita.",
	"@@Mask_NoData-Values_tag0@@": "Per ciascuna banda, è possibile specificare i Valori NoData. È possibile specificare più di un valore inserendo un elenco separato da spazi.",
	"@@Mask_Raster_tag0@@": "Il raster di input.",
	"@@Minus_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Minus_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Minus_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Minus_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Minus_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Minus_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Minus_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Minus_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Minus_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Minus_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Minus_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Minus_Raster_tag0@@": "L'input dal quale sottrarre i valori del secondo input.",
	"@@Minus_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Minus_Raster2_tag0@@": "I valori di input da sottrarre dai valori del primo input.",
	"@@Minus_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@ML-Classify_Raster_tag0@@": "Il raster di input da classificare utilizzando l'algoritmo di classificazione per massima probabilità.",
	"@@ML-Classify_Signature-File-or-URL_tag0@@": "Il file di firma ${.gsg}.",
	"@@Mod_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Mod_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Mod_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Mod_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Mod_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Mod_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Mod_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Mod_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Mod_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Mod_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Mod_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Mod_Raster_tag0@@": "L'input numeratore.",
	"@@Mod_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Mod_Raster2_tag0@@": "L'input denominatore.",
	"@@Mod_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Mosaic-Rasters_Operation_tag0@@": "Risolvere i conflitti quando si hanno parti di due o più immagini che si sovrappongono. Le opzioni includono quanto segue:",
	"@@Mosaic-Rasters_Operation_tag1@@": "<strong>Fusione</strong>: calcolare e visualizzare una media dei pixel sovrapposti ponderando di più i pixel più vicini alle immagini di quartiere affinché l'output sia un'immagine più smussata. Questa è l'impostazione predefinita.",
	"@@Mosaic-Rasters_Operation_tag3@@": "<strong>Primo</strong>: visualizzare i pixel dalla prima immagine nell'elenco delle immagini sovrapposte in un'area determinata.",
	"@@Mosaic-Rasters_Operation_tag5@@": "<strong>Ultimo</strong>: visualizzare i pixel dall'ultima immagine nell'elenco delle immagini sovrapposte in un'area determinata.",
	"@@Mosaic-Rasters_Operation_tag7@@": "<strong>Max</strong>: visualizzare il pixel con il valore massimo rispetto a tutti i layer sovrapposti. Con questa opzione non si ha nessuna garanzia di visualizzazione dei pixel di una sola immagine nell'area sovrapposta, piuttosto si ha una combinazione di tutti i layer potenziali.",
	"@@Mosaic-Rasters_Operation_tag9@@": "<strong>Media</strong>: calcolare e visualizzare una media dei pixel sovrapposti.",
	"@@Mosaic-Rasters_Operation_tag11@@": "<strong>Min</strong>: visualizzare il pixel con il valore minimo rispetto a tutti i layer sovrapposti. Con questa opzione non si ha nessuna garanzia di visualizzazione dei pixel di una sola immagine nell'area sovrapposta, piuttosto si ha una combinazione di tutti i layer potenziali.",
	"@@Mosaic-Rasters_Rasters_tag0@@": "Selezionare i raster a partire dai quali si vuole creare un mosaico per formare un'immagine.",
	"@@NDVI_Infrared-Band-ID_tag0@@": "Specifica l'ID di banda che rappresenta la parte dell'infrarosso vicino dello spettro elettromagnetico.",
	"@@NDVI_Raster_tag0@@": "Il raster multispettrale di input.",
	"@@NDVI_Scientific-Output_tag0@@": "I valori di output spaziano da -1,0 a 1,0, un intervallo usato in molte applicazioni scientifiche.",
	"@@NDVI_Visible-Band-ID_tag0@@": "Specifica l'ID di banda che rappresenta la parte rossa dello spettro elettromagnetico.",
	"@@NDVI-Colorized_Color-Ramp_tag0@@": "Scegliere uno schema di colori predefinito dall'elenco a discesa.",
	"@@NDVI-Colorized_Color-Scheme-Type_tag0@@": "Scegliere quale tipo di schema di colori utilizzare per colorare l'output NDVI:",
	"@@NDVI-Colorized_Color-Scheme-Type_tag1@@": "Mappa colore: scegliere una mappa colore predefinita dall'elenco a discesa. In alternativa, è possibile sfogliare un file di mappa colore preesistente.",
	"@@NDVI-Colorized_Color-Scheme-Type_tag2@@": "Scala cromatica: scegliere uno schema di colori predefinito dall'elenco a discesa.",
	"@@NDVI-Colorized_Colormap_tag0@@": "Scegliere una mappa colore predefinita dall'elenco a discesa. In alternativa, è possibile sfogliare un file di mappa colore esistente.",
	"@@NDVI-Colorized_Infrared-Band-ID_tag0@@": "Specifica l'ID di banda che rappresenta la parte dell'infrarosso vicino dello spettro elettromagnetico.",
	"@@NDVI-Colorized_Raster_tag0@@": "Il raster multispettrale di input.",
	"@@NDVI-Colorized_Scientific-Output_tag0@@": "I valori di output spaziano da -1,0 a 1,0, un intervallo usato in molte applicazioni scientifiche.",
	"@@NDVI-Colorized_Visible-Band-ID_tag0@@": "Specifica l'ID di banda che rappresenta la parte rossa dello spettro elettromagnetico.",
	"@@Negate_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Negate_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Negate_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Negate_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Negate_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Negate_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Negate_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Negate_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Negate_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Negate_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Negate_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Negate_Raster_tag0@@": "Il raster di input da negare (moltiplicato per -1).",
	"@@Nibble_Mask-Raster_tag0@@": "Il raster di input obbligatorio utilizzato come maschera.",
	"@@Nibble_Mask-Raster_tag1@@": "Le celle con NoData come valore verranno ridotte nel <strong>Raster</strong> di input.",
	"@@Nibble_Mask-Raster_tag4@@": "The mask raster can be  an integer or a floating-point type.",
	"@@Nibble_Nibble-NoData-cells_tag0@@": "Definisce se le celle NoData nel raster di input rimarranno NoData nel raster di output.",
	"@@Nibble_Nibble-NoData-cells_tag1@@": "<strong>No</strong>: specifica che le celle NoData nel raster di input rimarranno NoData nell'output. Questa è l'impostazione predefinita.",
	"@@Nibble_Nibble-NoData-cells_tag3@@": "<strong>Sì</strong>: specifica che le celle NoData nel raster di input e all'interno della maschera possono essere ridotte in valori di cella di output validi.",
	"@@Nibble_Raster_tag0@@": "Il raster di input obbligatorio che verrà ridotto.",
	"@@Nibble_Raster_tag1@@": "Il raster di input può essere un numero intero o un valore a virgola mobile.",
	"@@Nibble_Use-NoData-values-if-they-are-the-nearest-neighbor_tag0@@": "Definisce se i valori ${NoData} nel raster di input possono essere ridotti nell'area definita dal raster della maschera.",
	"@@Nibble_Use-NoData-values-if-they-are-the-nearest-neighbor_tag1@@": "<strong>Sì</strong>: specifica che il valore del vicino più prossimo verrà utilizzato che sia ${NoData} o un altro valore di dati nel raster di input. I valori ${NoData} nel raster di input possono essere ridotti in aree definite dalla maschera se sono il vicino più prossimo. Questa è l'impostazione predefinita.",
	"@@Nibble_Use-NoData-values-if-they-are-the-nearest-neighbor_tag3@@": "<strong>No</strong>: specifica che solo i valori di dati possono essere ridotti in aree definite dal raster della maschera. I valori ${NoData} nel raster di input non possono essere ridotti in aree definite dal raster della maschera anche se sono il vicino più prossimo.",
	"@@Nibble_Zone-Raster_tag0@@": "Il raster di zona di input.",
	"@@Nibble_Zone-Raster_tag1@@": "Una zona è rappresentata da tutte le celle in un raster con lo stesso valore, che esse siano contigue o meno. Il layer della zona di input definisce la forma, i valori e le posizioni delle zone. Il raster della zona può essere un numero intero o un valore a virgola mobile.",
	"@@Not-Equal_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Not-Equal_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Not-Equal_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Not-Equal_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Not-Equal_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Not-Equal_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Not-Equal_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Not-Equal_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Not-Equal_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Not-Equal_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Not-Equal_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Not-Equal_Raster_tag0@@": "L'input che verrà usato per confrontare la disuguaglianza con il secondo input.",
	"@@Not-Equal_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Not-Equal_Raster2_tag0@@": "L'input che verrà confrontato con il primo input per la disuguaglianza.",
	"@@Not-Equal_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Pansharpening_Multispectral_tag0@@": "Il raster multispettrale di cui si desidera aumentare la nitidezza usando la banda pancromatica.",
	"@@Pansharpening_Panchromatic_tag0@@": "Il raster dataset a banda singola e ad alta risoluzione che si userà per il pansharpening del raster multispettrale a minore risoluzione.",
	"@@Pansharpening_Pansharpening-Type_tag0@@": "Scegliere l'algoritmo pansharpening che si desidera usare.",
	"@@Pansharpening_Pansharpening-Type_tag1@@": "Brovey: usa l'algoritmo Brovey in base a modellazioni spettrali per fusione di dati.",
	"@@Pansharpening_Pansharpening-Type_tag2@@": "Esri: usa l'algoritmo Esri in base a modellazioni spettrali per fusione di dati.",
	"@@Pansharpening_Pansharpening-Type_tag3@@": "Gram-Schmidt: usa l'algoritmo di nitidezza spettrale Gram-Schmidt per rendere nitidi i dati multispettrali.",
	"@@Pansharpening_Pansharpening-Type_tag4@@": "IHS: usa intensità, tonalità e saturazione del colore per la fusione di dati.",
	"@@Pansharpening_Pansharpening-Type_tag5@@": "Medio: usa il valore medio tra i valori di rosso, verde e blu e il valore di pixel pancromatico.",
	"@@Pansharpening_Weights_tag0@@": "Specificare le ponderazioni per le bande rosse, verdi blu e infrarosse. Tutti i valori devono essere compresi nell'intervallo tra 0 e 1.",
	"@@Path-Distance_Accumulative-Cost-Resistance-Rate_tag0@@": "Questo parametro simula l'aumento dello sforzo per superare i costi man mano che il costo cumulativo aumenta. Viene usato per modellare l'affaticamento del viaggiatore. Il costo cumulativo crescente per raggiungere una cella viene moltiplicato per il tasso di resistenza e aggiunto al costo per lo spostamento nella cella consecutiva.",
	"@@Path-Distance_Accumulative-Cost-Resistance-Rate_tag1@@": "Si tratta di una versione modificata di una formula composta di tasso di interesse che viene utilizzata per calcolare il costo apparente di spostamento attraverso una cella. Con l'aumentare del valore del tasso di resistenza, aumenta anche il costo delle celle visitate in seguito. Quanto maggiore è il tasso di resistenza, tanto più alto sarà il costo per raggiungere la cella successiva, che è resistente a ogni movimento consecutivo. Dal momento che il tasso di resistenza è simile a un tasso composto e generalmente i valori di costo cumulativo sono molto grandi, si consigliano tassi di resistenza piccoli, come 0,005 o anche meno, a seconda dei valori di costo cumulativi.",
	"@@Path-Distance_Accumulative-Cost-Resistance-Rate_tag2@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Path-Distance_Capacity_tag0@@": "Definisce la capacità di costo per il viaggiatore relativa a un'origine. I calcoli del costo continuano per ogni origine finché non si raggiunge la capacità specificata.",
	"@@Path-Distance_Capacity_tag1@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Path-Distance_Cost-Raster_tag0@@": "Un raster di input obbligatorio che definisce il costo o l'impedenza dello spostamento planimetrico attraverso ciascuna cella. Il valore a ogni posizione della cella rappresenta la distanza di costo per unità per l'attraversamento della stessa. Ogni valore di posizione di una cella viene moltiplicato per la risoluzione della cella e compensa inoltre il movimento diagonale per ottenere il costo totale dell'attraversamento della stessa.",
	"@@Path-Distance_Cost-Raster_tag1@@": "I valori del <strong>Raster di costo</strong> possono essere a numero intero o a virgola mobile, ma non possono essere negativi o zero.",
	"@@Path-Distance_horizontalfactor_tag0@@": "<p>Definisce la relazione tra il fattore di costo orizzontale e l'angolo mobile relativo orizzontale (HRMA).</p><p>Ci sono diversi fattori con modificatori che identificano un grafico del fattore verticale definito. Inoltre, è possibile utilizzare una tabella per creare un grafico personalizzato. I grafici sono utilizzati per identificare il fattore verticale utilizzato nel calcolo del costo totale dello spostamento in una cella vicina.</p><p>Nelle spiegazioni che seguono, vengono utilizzati due acronimi: HF e HRMA. HF stands for horizontal factor, which defines the horizontal difficulty encountered when moving from one cell to the next. HRMA sta per horizontal relative moving angle, che identifica l'angolo tra la direzione orizzontale da una cella e la direzione di movimento. I tipi di </p><p><strong>fattori orizzontali</strong> includono i seguenti: </p><ul><li><strong>Binario</strong>-- Indica che se l'HRMA è inferiore all'angolo di taglio, l'HF è impostato al valore associato al fattore zero; altrimenti, è infinito.</li><li><strong>Avanti</strong> -- Stabilisce che è permesso solo il movimento in avanti. L'HRMA deve essere maggiore o uguale a 0 e inferiore a 90 gradi (0 &lt;= HRMA &lt;90). Se l'HRMA è superiore a 0 e inferiore a 45 gradi, l'HF per la cella viene impostato sul valore associato al fattore zero. Se l'HRMA è superiore o pari a 45 gradi, viene utilizzato il valore del modificatore del valore laterale. L'HF per qualsiasi valore HRMA uguale o superiore a 90 gradi è impostato su infinito.</li><li><strong>Lineare</strong>--Specifica che l'HF è una funzione lineare dell'HRMA.</li><li><strong>Lineare inversa</strong>--Specifica che l'HF è una funzione lineare inversa dell'HRMA.</li><li><strong>Tabella</strong>- Identifica che un file tabella sarà usato per definire il grafico dei fattori orizzontali usato per determinare gli HF.</li></ul><p>I modificatori dei fattori orizzontali includono quanto segue: </p><ul><li><strong>Fattore zero</strong>-- Il fattore orizzontale da usare quando l'HRMA è zero. Questo fattore posiziona l'intercetta y per qualsiasi funzione fattore orizzontale.</li><li><strong>Angolo di taglio</strong>--Definisce l'angolo HRMA oltre il quale l'HF sarà impostato su infinito.</li><li><strong>Pendenza</strong>-- Stabilisce la pendenza della linea retta usata con le parole chiave fattore orizzontale <strong>Lineare</strong> e <strong>Lineare inversa</strong>. La pendenza è specificata come una frazione di salita su corsa (per esempio, la pendenza del 45% è 1/45, che viene immessa come 0,02222).</li><li><strong>Side value</strong>-- Stabilisce l'HF quando l'HRMA è maggiore o uguale a 45 gradi e minore di 90 gradi quando viene specificata la parola chiave Fattore orizzontale <strong>avanti</strong>.</li><li><strong>Nome della tabella</strong> - Identifica il nome della tabella che definisce l'HF.</li></ul>",
	"@@Path-Distance_Horizontal-Raster_tag0@@": "Un raster che definisce la direzione orizzontale su ogni cella.",
	"@@Path-Distance_Horizontal-Raster_tag1@@": "I valori sul raster devono essere numeri interi compresi tra 0 e 360 con 0 gradi che indica il nord o verso la parte superiore dello schermo e con aumento in senso orario. Alle aree piane deve essere fornito un valore di -1. I valori in ogni posizione vengono utilizzati insieme a <strong>Fattore orizzontale</strong> per determinare i costi orizzontali durante lo spostamento da una cella a quelle vicine.",
	"@@Path-Distance_Maximum-Distance_tag0@@": "La soglia che i valori di costo cumulativi non possono superare. Se una distanza di costo cumulativo supera questo valore, il valore di output per la posizione della cella sarà NoData. La distanza massima definisce l'estensione per la quale si calcolano le distanze di costo cumulative. La distanza predefinita è fino all'estensione del raster di output.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag0@@": "Un moltiplicatore da applicare ai valori di costo.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag1@@": "Questo parametro consente il controllo della modalità di spostamento o della grandezza all'origine. Maggiore è il moltiplicatore, maggiore è il costo per lo spostamento attraverso ogni cella.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag2@@": "I valori devono essere maggiori di zero. L'impostazione predefinita è 1.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag3@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Path-Distance_Source-Raster_tag0@@": "Il raster di input obbligatorio per le posizioni di origine.",
	"@@Path-Distance_Source-Raster_tag1@@": "È un raster che identifica le celle o le posizioni dalle quali si calcola la distanza di costo minima cumulativa per ogni posizione di cella di output.",
	"@@Path-Distance_Source-Raster_tag2@@": "Può essere un numero intero o un valore a virgola mobile.",
	"@@Path-Distance_Start-Cost_tag0@@": "Il costo di inizio con il quale avviare i calcoli del costo. Questo parametro consente di specificare il costo fisso associato ad un'origine. Invece di iniziare con un costo 0, l'algoritmo del costo inizierà con il valore specificato.",
	"@@Path-Distance_Start-Cost_tag1@@": "Il valore deve essere pari o superiore a zero. L'impostazione predefinita è 0.",
	"@@Path-Distance_Surface-Raster_tag0@@": "Un raster che definisce i valori di elevazione su ogni posizione della cella.",
	"@@Path-Distance_Surface-Raster_tag1@@": "I valori vengono utilizzati per calcolare l’effettiva distanza della superficie percorsa durante il passaggio tra celle.",
	"@@Path-Distance_Travel-Direction_tag0@@": "Definisce la direzione del viaggiatore quando si applica il tasso di resistenza dell'origine e il costo iniziale dell'origine.",
	"@@Path-Distance_Travel-Direction_tag1@@": "<strong>Dall'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire dall'origine di input e poi spostandosi alle celle non-origine. Questa è l'impostazione predefinita.",
	"@@Path-Distance_Travel-Direction_tag3@@": "<strong>Verso l'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire da ciascuna cella non-origine e poi tornando indietro all'origine di input.",
	"@@Path-Distance_Travel-Direction_tag5@@": "Specificare la parola chiave <strong>Dall'origine</strong> o <strong>Verso l'origine</strong>, che sarà applicata a tutte le origini, oppure specificare un campo nel <strong>Raster di origine</strong> che contiene le parole chiave per identificare la direzione di viaggio per ogni origine. Quel campo deve contenere la stringa ${FROM_SOURCE} o ${TO_SOURCE}.",
	"@@Path-Distance_verticalfactor_tag0@@": "<p>Definisce la relazione tra il fattore di costo verticale e l'angolo mobile relativo verticale (VRMA).</p><p>Ci sono diversi fattori con modificatori che identificano un grafico di fattore verticale definito. Inoltre, è possibile utilizzare una tabella per creare un grafico personalizzato. I grafici sono utilizzati per identificare il fattore verticale utilizzato nel calcolo del costo totale dello spostamento in una cella vicina.</p><p>Nelle spiegazioni che seguono, vengono utilizzati due acronimi: VF e VRMA. VF stands for vertical factor, which defines the vertical difficulty encountered in moving from one cell to the next. VRMA sta per angolo mobile relativo verticale, che identifica l'angolo di pendenza tra la cella FROM, o di elaborazione, e la cella TO.</p><p><strong>I fattori verticali</strong> includono i seguenti:</p><ul><li><strong>Binario</strong>-- Specifica che se il VRMA è maggiore dell'angolo di taglio basso e minore dell'angolo di taglio alto, il VF è impostato al valore associato al fattore zero; altrimenti, è infinito.</li><li><strong>Lineare</strong> - Indica che la VF è una funzione lineare della VRMA.</li><li><strong>Lineare simmetrica</strong>-- Specifica che la VF è una funzione lineare della VRMA nel lato negativo o positivo della VRMA, rispettivamente, e le due funzioni lineari sono simmetriche rispetto all'asse VF (y).</li><li><strong>Lineare inversa</strong> - Indica che la VF è una funzione lineare inversa del VRMA.</li><li><strong>Lineare inversa simmetrica</strong>-- Indica che la VF è una funzione lineare inversa del VRMA nel lato negativo o positivo del VRMA, rispettivamente, e le due funzioni lineari sono simmetriche rispetto all'asse VF (y).</li><li><strong>Cos</strong>--Identifica la VF come funzione basata sul coseno del VRMA.</li><li><strong>Sec</strong>--Identifica la VF come funzione basata sulla secante del VRMA.</li><li><strong>Cos-Sec</strong>--Specifica che la VF è la funzione basata sul coseno del VRMA quando il VRMA è negativo e la funzione basata sulla secante del VRMA quando il VRMA non è negativo.</li><li><strong>Sec-Cos</strong>--Specifica che la VF è la funzione basata sulla secante del VRMA quando il VRMA è negativo e la funzione basata sul coseno del VRMA quando il VRMA non è negativo. </li><li><strong>Tabella</strong>--Identifica che verrà utilizzato un file tabella per definire il grafico del fattore verticale che viene utilizzato per determinare le VF.</li></ul><p>I modificatori delle parole chiave verticali includono quanto segue: </p><ul><li><strong>Fattore zero</strong>-- Stabilisce il fattore verticale usato quando il VRMA è zero. Questo fattore posiziona l’intercettazione y della funzione specificata. Per definizione, il fattore zero non è applicabile ad alcuna funzione verticale trigonometrica (COS, SEC, COS-SEC o SEC-COS). L'intercetta y è definita da queste funzioni.</li><li><strong>Angolo di taglio basso </strong>- Definisce l'angolo VRMA al di sotto del quale la VF sarà impostata su infinito.</li><li><strong>Angolo di taglio alto</strong> - Definisce l'angolo VRMA al di sopra del quale la VF sarà impostata su infinito. </li><li><strong>Pendenza</strong> - Stabilisce la pendenza della linea retta usata con le parole chiave <strong>Lineare</strong> e <strong>Lineare Inversa</strong>-fattore verticale. La pendenza è specificata come una frazione di salita su corsa (per esempio, la pendenza del 45 per cento è 1/45, che viene immessa come 0,02222).</li><li><strong>Nome tabella</strong>--</li>Identifica il nome della tabella che definisce la VF.</ul>",
	"@@Path-Distance_Vertical-Raster_tag0@@": "Definisce la relazione tra il fattore di costo verticale e l'angolo di movimento relativo verticale (VRMA).",
	"@@Path-Distance_Vertical-Raster_tag1@@": "I valori vengono utilizzati per calcolare la pendenza usata per identificare il fattore verticale quando si passa da una cella all'altra.",
	"@@Path-Distance-Allocation_Accumulative-Cost-Resistance-Rate_tag0@@": "Questo parametro simula l'aumento dello sforzo per superare i costi man mano che il costo cumulativo aumenta. Viene usato per modellare l'affaticamento del viaggiatore. Il costo cumulativo crescente per raggiungere una cella viene moltiplicato per il tasso di resistenza e aggiunto al costo per lo spostamento nella cella consecutiva.",
	"@@Path-Distance-Allocation_Accumulative-Cost-Resistance-Rate_tag1@@": "Si tratta di una versione modificata di una formula composta di tasso di interesse che viene utilizzata per calcolare il costo apparente di spostamento attraverso una cella. Con l'aumentare del valore del tasso di resistenza, aumenta anche il costo delle celle visitate in seguito. Quanto maggiore è il tasso di resistenza, tanto più alto sarà il costo per raggiungere la cella successiva, che è resistente a ogni movimento consecutivo. Dal momento che il tasso di resistenza è simile a un tasso composto e generalmente i valori di costo cumulativo sono molto grandi, si consigliano tassi di resistenza piccoli, come 0,005 o anche meno, a seconda dei valori di costo cumulativi.",
	"@@Path-Distance-Allocation_Accumulative-Cost-Resistance-Rate_tag2@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Path-Distance-Allocation_Capacity_tag0@@": "Definisce la capacità di costo per il viaggiatore relativa a un'origine. I calcoli del costo continuano per ogni origine finché non si raggiunge la capacità specificata.",
	"@@Path-Distance-Allocation_Capacity_tag1@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Path-Distance-Allocation_Cost-Raster_tag0@@": "Un raster di input obbligatorio che definisce il costo o l'impedenza dello spostamento planimetrico attraverso ciascuna cella. Il valore a ogni posizione della cella rappresenta la distanza di costo per unità per l'attraversamento della stessa. Ogni valore di posizione di una cella viene moltiplicato per la risoluzione della cella e compensa inoltre il movimento diagonale per ottenere il costo totale dell'attraversamento della stessa.",
	"@@Path-Distance-Allocation_Cost-Raster_tag1@@": "I valori del <strong>Raster di costo</strong> possono essere a numero intero o a virgola mobile, ma non possono essere negativi o zero.",
	"@@Path-Distance-Allocation_horizontalfactor_tag0@@": "<p>Definisce la relazione tra il fattore di costo orizzontale e l'angolo mobile relativo orizzontale (HRMA).</p><p>Ci sono diversi fattori con modificatori che identificano un grafico del fattore verticale definito. Inoltre, è possibile utilizzare una tabella per creare un grafico personalizzato. I grafici sono utilizzati per identificare il fattore verticale utilizzato nel calcolo del costo totale dello spostamento in una cella vicina.</p><p>Nelle spiegazioni che seguono, vengono utilizzati due acronimi: HF e HRMA. HF stands for horizontal factor, which defines the horizontal difficulty encountered when moving from one cell to the next. HRMA sta per horizontal relative moving angle, che identifica l'angolo tra la direzione orizzontale da una cella e la direzione di movimento. I tipi di </p><p><strong>fattori orizzontali</strong> includono i seguenti: </p><ul><li><strong>Binario</strong>-- Indica che se l'HRMA è inferiore all'angolo di taglio, l'HF è impostato al valore associato al fattore zero; altrimenti, è infinito.</li><li><strong>Avanti</strong> -- Stabilisce che è permesso solo il movimento in avanti. L'HRMA deve essere maggiore o uguale a 0 e inferiore a 90 gradi (0 &lt;= HRMA &lt;90). Se l'HRMA è superiore a 0 e inferiore a 45 gradi, l'HF per la cella viene impostato sul valore associato al fattore zero. Se l'HRMA è superiore o pari a 45 gradi, viene utilizzato il valore del modificatore del valore laterale. L'HF per qualsiasi valore HRMA uguale o superiore a 90 gradi è impostato su infinito.</li><li><strong>Lineare</strong>--Specifica che l'HF è una funzione lineare dell'HRMA.</li><li><strong>Lineare inversa</strong>--Specifica che l'HF è una funzione lineare inversa dell'HRMA.</li><li><strong>Tabella</strong>- Identifica che un file tabella sarà usato per definire il grafico dei fattori orizzontali usato per determinare gli HF.</li></ul><p>I modificatori dei fattori orizzontali includono quanto segue: </p><ul><li><strong>Fattore zero</strong>-- Il fattore orizzontale da usare quando l'HRMA è zero. Questo fattore posiziona l'intercetta y per qualsiasi funzione fattore orizzontale.</li><li><strong>Angolo di taglio</strong>--Definisce l'angolo HRMA oltre il quale l'HF sarà impostato su infinito.</li><li><strong>Pendenza</strong>-- Stabilisce la pendenza della linea retta usata con le parole chiave fattore orizzontale <strong>Lineare</strong> e <strong>Lineare inversa</strong>. La pendenza è specificata come una frazione di salita su corsa (per esempio, la pendenza del 45% è 1/45, che viene immessa come 0,02222).</li><li><strong>Side value</strong>-- Stabilisce l'HF quando l'HRMA è maggiore o uguale a 45 gradi e minore di 90 gradi quando viene specificata la parola chiave Fattore orizzontale <strong>avanti</strong>.</li><li><strong>Nome della tabella</strong> - Identifica il nome della tabella che definisce l'HF.</li></ul>",
	"@@Path-Distance-Allocation_Horizontal-Raster_tag0@@": "Un raster che definisce la direzione orizzontale su ogni cella.",
	"@@Path-Distance-Allocation_Horizontal-Raster_tag1@@": "I valori sul raster devono essere numeri interi compresi tra 0 e 360 con 0 gradi che indica il nord o verso la parte superiore dello schermo e con aumento in senso orario. Alle aree piane deve essere fornito un valore di -1. I valori in ogni posizione vengono utilizzati insieme a <strong>Fattore orizzontale</strong> per determinare i costi orizzontali durante lo spostamento da una cella a quelle vicine.",
	"@@Path-Distance-Allocation_Maximum-Distance_tag0@@": "La soglia che i valori di costo cumulativi non possono superare. Se una distanza di costo cumulativo supera questo valore, il valore di output per la posizione della cella sarà NoData. La distanza massima definisce l'estensione per la quale si calcolano le distanze di costo cumulative. La distanza predefinita è fino all'estensione del raster di output.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag0@@": "Un moltiplicatore da applicare ai valori di costo.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag1@@": "Questo parametro consente il controllo della modalità di spostamento o della grandezza all'origine. Maggiore è il moltiplicatore, maggiore è il costo per lo spostamento attraverso ogni cella.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag2@@": "I valori devono essere maggiori di zero. L'impostazione predefinita è 1.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag3@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Path-Distance-Allocation_Source-Field_tag0@@": "Il campo usato per assegnare valori alle posizioni di origine. Deve essere di tipo numero intero. Se il <strong>Raster valore</strong> è stato impostato, i valori di quell'input avranno priorità su qualunque impostazione di <strong>Campo di origine</strong>.",
	"@@Path-Distance-Allocation_Source-Raster_tag0@@": "Il raster di input obbligatorio per le posizioni di origine.",
	"@@Path-Distance-Allocation_Source-Raster_tag1@@": "È un raster che identifica le celle o le posizioni dalle quali si calcola la distanza di costo minima cumulativa per ogni posizione di cella di output.",
	"@@Path-Distance-Allocation_Source-Raster_tag2@@": "Può essere un numero intero o un valore a virgola mobile.",
	"@@Path-Distance-Allocation_Start-Cost_tag0@@": "Il costo di inizio con il quale avviare i calcoli del costo. Questo parametro consente di specificare il costo fisso associato ad un'origine. Invece di iniziare con un costo 0, l'algoritmo del costo inizierà con il valore specificato.",
	"@@Path-Distance-Allocation_Start-Cost_tag1@@": "Il valore deve essere pari o superiore a zero. L'impostazione predefinita è 0.",
	"@@Path-Distance-Allocation_Surface-Raster_tag0@@": "Un raster che definisce i valori di elevazione su ogni posizione della cella.",
	"@@Path-Distance-Allocation_Surface-Raster_tag1@@": "I valori vengono utilizzati per calcolare l’effettiva distanza della superficie percorsa durante il passaggio tra celle.",
	"@@Path-Distance-Allocation_Travel-Direction_tag0@@": "Definisce la direzione del viaggiatore quando si applica il tasso di resistenza dell'origine e il costo iniziale dell'origine.",
	"@@Path-Distance-Allocation_Travel-Direction_tag1@@": "<strong>Dall'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire dall'origine di input e poi spostandosi alle celle non-origine. Questa è l'impostazione predefinita.",
	"@@Path-Distance-Allocation_Travel-Direction_tag3@@": "<strong>Verso l'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire da ciascuna cella non-origine e poi tornando indietro all'origine di input.",
	"@@Path-Distance-Allocation_Travel-Direction_tag5@@": "Specificare la parola chiave <strong>Dall'origine</strong> o <strong>Verso l'origine</strong>, che sarà applicata a tutte le origini, oppure specificare un campo nel <strong>Raster di origine</strong> che contiene le parole chiave per identificare la direzione di viaggio per ogni origine. Quel campo deve contenere la stringa ${FROM_SOURCE} o ${TO_SOURCE}.",
	"@@Path-Distance-Allocation_Value-Raster_tag0@@": "Il raster di input a numero intero che identifica i valori di zona da usare per ogni posizione di origine di input. Per ogni cella di posizione di origine, il valore definito dal <strong>Raster di valori</strong> sarà assegnato a tutte le celle assegnate alla posizione di origine per il calcolo. Il <strong>Raster di valori</strong> avrà priorità su qualunque impostazione per il <strong>Campo di origine</strong>.",
	"@@Path-Distance-Allocation_verticalfactor_tag0@@": "<p>Definisce la relazione tra il fattore di costo verticale e l'angolo mobile relativo verticale (VRMA).</p><p>Ci sono diversi fattori con modificatori che identificano un grafico di fattore verticale definito. Inoltre, è possibile utilizzare una tabella per creare un grafico personalizzato. I grafici sono utilizzati per identificare il fattore verticale utilizzato nel calcolo del costo totale dello spostamento in una cella vicina.</p><p>Nelle spiegazioni che seguono, vengono utilizzati due acronimi: VF e VRMA. VF stands for vertical factor, which defines the vertical difficulty encountered in moving from one cell to the next. VRMA sta per angolo mobile relativo verticale, che identifica l'angolo di pendenza tra la cella FROM, o di elaborazione, e la cella TO.</p><p><strong>I fattori verticali</strong> includono i seguenti:</p><ul><li><strong>Binario</strong>-- Specifica che se il VRMA è maggiore dell'angolo di taglio basso e minore dell'angolo di taglio alto, il VF è impostato al valore associato al fattore zero; altrimenti, è infinito.</li><li><strong>Lineare</strong> - Indica che la VF è una funzione lineare della VRMA.</li><li><strong>Lineare simmetrica</strong>-- Specifica che la VF è una funzione lineare della VRMA nel lato negativo o positivo della VRMA, rispettivamente, e le due funzioni lineari sono simmetriche rispetto all'asse VF (y).</li><li><strong>Lineare inversa</strong> - Indica che la VF è una funzione lineare inversa del VRMA.</li><li><strong>Lineare inversa simmetrica</strong>-- Indica che la VF è una funzione lineare inversa del VRMA nel lato negativo o positivo del VRMA, rispettivamente, e le due funzioni lineari sono simmetriche rispetto all'asse VF (y).</li><li><strong>Cos</strong>--Identifica la VF come funzione basata sul coseno del VRMA.</li><li><strong>Sec</strong>--Identifica la VF come funzione basata sulla secante del VRMA.</li><li><strong>Cos-Sec</strong>--Specifica che la VF è la funzione basata sul coseno del VRMA quando il VRMA è negativo e la funzione basata sulla secante del VRMA quando il VRMA non è negativo.</li><li><strong>Sec-Cos</strong>--Specifica che la VF è la funzione basata sulla secante del VRMA quando il VRMA è negativo e la funzione basata sul coseno del VRMA quando il VRMA non è negativo. </li><li><strong>Tabella</strong>--Identifica che verrà utilizzato un file tabella per definire il grafico del fattore verticale che viene utilizzato per determinare le VF.</li></ul><p>I modificatori delle parole chiave verticali includono quanto segue: </p><ul><li><strong>Fattore zero</strong>-- Stabilisce il fattore verticale usato quando il VRMA è zero. Questo fattore posiziona l’intercettazione y della funzione specificata. Per definizione, il fattore zero non è applicabile ad alcuna funzione verticale trigonometrica (COS, SEC, COS-SEC o SEC-COS). L'intercetta y è definita da queste funzioni.</li><li><strong>Angolo di taglio basso </strong>- Definisce l'angolo VRMA al di sotto del quale la VF sarà impostata su infinito.</li><li><strong>Angolo di taglio alto</strong> - Definisce l'angolo VRMA al di sopra del quale la VF sarà impostata su infinito. </li><li><strong>Pendenza</strong> - Stabilisce la pendenza della linea retta usata con le parole chiave <strong>Lineare</strong> e <strong>Lineare Inversa</strong>-fattore verticale. La pendenza è specificata come una frazione di salita su corsa (per esempio, la pendenza del 45 per cento è 1/45, che viene immessa come 0,02222).</li><li><strong>Nome tabella</strong>--</li>Identifica il nome della tabella che definisce la VF.</ul>",
	"@@Path-Distance-Allocation_Vertical-Raster_tag0@@": "Definisce la relazione tra il fattore di costo verticale e l'angolo di movimento relativo verticale (VRMA).",
	"@@Path-Distance-Allocation_Vertical-Raster_tag1@@": "I valori vengono utilizzati per calcolare la pendenza usata per identificare il fattore verticale quando si passa da una cella all'altra.",
	"@@Path-Distance-Back-Link_Accumulative-Cost-Resistance-Rate_tag0@@": "Questo parametro simula l'aumento dello sforzo per superare i costi man mano che il costo cumulativo aumenta. Viene usato per modellare l'affaticamento del viaggiatore. Il costo cumulativo crescente per raggiungere una cella viene moltiplicato per il tasso di resistenza e aggiunto al costo per lo spostamento nella cella consecutiva.",
	"@@Path-Distance-Back-Link_Accumulative-Cost-Resistance-Rate_tag1@@": "Si tratta di una versione modificata di una formula composta di tasso di interesse che viene utilizzata per calcolare il costo apparente di spostamento attraverso una cella. Con l'aumentare del valore del tasso di resistenza, aumenta anche il costo delle celle visitate in seguito. Quanto maggiore è il tasso di resistenza, tanto più alto sarà il costo per raggiungere la cella successiva, che è resistente a ogni movimento consecutivo. Dal momento che il tasso di resistenza è simile a un tasso composto e generalmente i valori di costo cumulativo sono molto grandi, si consigliano tassi di resistenza piccoli, come 0,005 o anche meno, a seconda dei valori di costo cumulativi.",
	"@@Path-Distance-Back-Link_Accumulative-Cost-Resistance-Rate_tag2@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Path-Distance-Back-Link_Capacity_tag0@@": "Definisce la capacità di costo per il viaggiatore relativa a un'origine. I calcoli del costo continuano per ogni origine finché non si raggiunge la capacità specificata.",
	"@@Path-Distance-Back-Link_Capacity_tag1@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Path-Distance-Back-Link_Cost-Raster_tag0@@": "Un raster di input obbligatorio che definisce il costo o l'impedenza dello spostamento planimetrico attraverso ciascuna cella. Il valore a ogni posizione della cella rappresenta la distanza di costo per unità per l'attraversamento della stessa. Ogni valore di posizione di una cella viene moltiplicato per la risoluzione della cella e compensa inoltre il movimento diagonale per ottenere il costo totale dell'attraversamento della stessa.",
	"@@Path-Distance-Back-Link_Cost-Raster_tag1@@": "I valori del <strong>Raster di costo</strong> possono essere a numero intero o a virgola mobile, ma non possono essere negativi o zero.",
	"@@Path-Distance-Back-Link_horizontalfactor_tag0@@": "<p>Definisce la relazione tra il fattore di costo orizzontale e l'angolo mobile relativo orizzontale (HRMA).</p><p>Ci sono diversi fattori con modificatori che identificano un grafico del fattore verticale definito. Inoltre, è possibile utilizzare una tabella per creare un grafico personalizzato. I grafici sono utilizzati per identificare il fattore verticale utilizzato nel calcolo del costo totale dello spostamento in una cella vicina.</p><p>Nelle spiegazioni che seguono, vengono utilizzati due acronimi: HF e HRMA. HF stands for horizontal factor, which defines the horizontal difficulty encountered when moving from one cell to the next. HRMA sta per horizontal relative moving angle, che identifica l'angolo tra la direzione orizzontale da una cella e la direzione di movimento. I tipi di </p><p><strong>fattori orizzontali</strong> includono i seguenti: </p><ul><li><strong>Binario</strong>-- Indica che se l'HRMA è inferiore all'angolo di taglio, l'HF è impostato al valore associato al fattore zero; altrimenti, è infinito.</li><li><strong>Avanti</strong> -- Stabilisce che è permesso solo il movimento in avanti. L'HRMA deve essere maggiore o uguale a 0 e inferiore a 90 gradi (0 &lt;= HRMA &lt;90). Se l'HRMA è superiore a 0 e inferiore a 45 gradi, l'HF per la cella viene impostato sul valore associato al fattore zero. Se l'HRMA è superiore o pari a 45 gradi, viene utilizzato il valore del modificatore del valore laterale. L'HF per qualsiasi valore HRMA uguale o superiore a 90 gradi è impostato su infinito.</li><li><strong>Lineare</strong>--Specifica che l'HF è una funzione lineare dell'HRMA.</li><li><strong>Lineare inversa</strong>--Specifica che l'HF è una funzione lineare inversa dell'HRMA.</li><li><strong>Tabella</strong>- Identifica che un file tabella sarà usato per definire il grafico dei fattori orizzontali usato per determinare gli HF.</li></ul><p>I modificatori dei fattori orizzontali includono quanto segue: </p><ul><li><strong>Fattore zero</strong>-- Il fattore orizzontale da usare quando l'HRMA è zero. Questo fattore posiziona l'intercetta y per qualsiasi funzione fattore orizzontale.</li><li><strong>Angolo di taglio</strong>--Definisce l'angolo HRMA oltre il quale l'HF sarà impostato su infinito.</li><li><strong>Pendenza</strong>-- Stabilisce la pendenza della linea retta usata con le parole chiave fattore orizzontale <strong>Lineare</strong> e <strong>Lineare inversa</strong>. La pendenza è specificata come una frazione di salita su corsa (per esempio, la pendenza del 45% è 1/45, che viene immessa come 0,02222).</li><li><strong>Side value</strong>-- Stabilisce l'HF quando l'HRMA è maggiore o uguale a 45 gradi e minore di 90 gradi quando viene specificata la parola chiave Fattore orizzontale <strong>avanti</strong>.</li><li><strong>Nome della tabella</strong> - Identifica il nome della tabella che definisce l'HF.</li></ul>",
	"@@Path-Distance-Back-Link_Horizontal-Raster_tag0@@": "Un raster che definisce la direzione orizzontale su ogni cella.",
	"@@Path-Distance-Back-Link_Horizontal-Raster_tag1@@": "I valori sul raster devono essere numeri interi compresi tra 0 e 360 con 0 gradi che indica il nord o verso la parte superiore dello schermo e con aumento in senso orario. Alle aree piane deve essere fornito un valore di -1. I valori in ogni posizione vengono utilizzati insieme a <strong>Fattore orizzontale</strong> per determinare i costi orizzontali durante lo spostamento da una cella a quelle vicine.",
	"@@Path-Distance-Back-Link_Maximum-Distance_tag0@@": "La soglia che i valori di costo cumulativi non possono superare. Se una distanza di costo cumulativo supera questo valore, il valore di output per la posizione della cella sarà NoData. La distanza massima definisce l'estensione per la quale si calcolano le distanze di costo cumulative. La distanza predefinita è fino all'estensione del raster di output.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag0@@": "Un moltiplicatore da applicare ai valori di costo.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag1@@": "Questo parametro consente il controllo della modalità di spostamento o della grandezza all'origine. Maggiore è il moltiplicatore, maggiore è il costo per lo spostamento attraverso ogni cella.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag2@@": "I valori devono essere maggiori di zero. L'impostazione predefinita è 1.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag3@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Path-Distance-Back-Link_Source-Raster_tag0@@": "Il raster di input obbligatorio per le posizioni di origine.",
	"@@Path-Distance-Back-Link_Source-Raster_tag1@@": "È un raster che identifica le celle o le posizioni dalle quali si calcola la distanza di costo minima cumulativa per ogni posizione di cella di output.",
	"@@Path-Distance-Back-Link_Source-Raster_tag2@@": "Può essere un numero intero o un valore a virgola mobile.",
	"@@Path-Distance-Back-Link_Start-Cost_tag0@@": "Il costo di inizio con il quale avviare i calcoli del costo. Questo parametro consente di specificare il costo fisso associato ad un'origine. Invece di iniziare con un costo 0, l'algoritmo del costo inizierà con il valore specificato.",
	"@@Path-Distance-Back-Link_Start-Cost_tag1@@": "Il valore deve essere pari o superiore a zero. L'impostazione predefinita è 0.",
	"@@Path-Distance-Back-Link_Surface-Raster_tag0@@": "Un raster che definisce i valori di elevazione su ogni posizione della cella.",
	"@@Path-Distance-Back-Link_Surface-Raster_tag1@@": "I valori vengono utilizzati per calcolare l’effettiva distanza della superficie percorsa durante il passaggio tra celle.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag0@@": "Definisce la direzione del viaggiatore quando si applica il tasso di resistenza dell'origine e il costo iniziale dell'origine.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag1@@": "<strong>Dall'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire dall'origine di input e poi spostandosi alle celle non-origine. Questa è l'impostazione predefinita.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag3@@": "<strong>Verso l'origine</strong>: Il tasso di resistenza di origine e il costo iniziale dell'origine saranno applicati a partire da ciascuna cella non-origine e poi tornando indietro all'origine di input.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag5@@": "Specificare la parola chiave <strong>Dall'origine</strong> o <strong>Verso l'origine</strong>, che sarà applicata a tutte le origini, oppure specificare un campo nel <strong>Raster di origine</strong> che contiene le parole chiave per identificare la direzione di viaggio per ogni origine. Quel campo deve contenere la stringa ${FROM_SOURCE} o ${TO_SOURCE}.",
	"@@Path-Distance-Back-Link_verticalfactor_tag0@@": "<p>Definisce la relazione tra il fattore di costo verticale e l'angolo mobile relativo verticale (VRMA).</p><p>Ci sono diversi fattori con modificatori che identificano un grafico di fattore verticale definito. Inoltre, è possibile utilizzare una tabella per creare un grafico personalizzato. I grafici sono utilizzati per identificare il fattore verticale utilizzato nel calcolo del costo totale dello spostamento in una cella vicina.</p><p>Nelle spiegazioni che seguono, vengono utilizzati due acronimi: VF e VRMA. VF stands for vertical factor, which defines the vertical difficulty encountered in moving from one cell to the next. VRMA sta per angolo mobile relativo verticale, che identifica l'angolo di pendenza tra la cella FROM, o di elaborazione, e la cella TO.</p><p><strong>I fattori verticali</strong> includono i seguenti:</p><ul><li><strong>Binario</strong>-- Specifica che se il VRMA è maggiore dell'angolo di taglio basso e minore dell'angolo di taglio alto, il VF è impostato al valore associato al fattore zero; altrimenti, è infinito.</li><li><strong>Lineare</strong> - Indica che la VF è una funzione lineare della VRMA.</li><li><strong>Lineare simmetrica</strong>-- Specifica che la VF è una funzione lineare della VRMA nel lato negativo o positivo della VRMA, rispettivamente, e le due funzioni lineari sono simmetriche rispetto all'asse VF (y).</li><li><strong>Lineare inversa</strong> - Indica che la VF è una funzione lineare inversa del VRMA.</li><li><strong>Lineare inversa simmetrica</strong>-- Indica che la VF è una funzione lineare inversa del VRMA nel lato negativo o positivo del VRMA, rispettivamente, e le due funzioni lineari sono simmetriche rispetto all'asse VF (y).</li><li><strong>Cos</strong>--Identifica la VF come funzione basata sul coseno del VRMA.</li><li><strong>Sec</strong>--Identifica la VF come funzione basata sulla secante del VRMA.</li><li><strong>Cos-Sec</strong>--Specifica che la VF è la funzione basata sul coseno del VRMA quando il VRMA è negativo e la funzione basata sulla secante del VRMA quando il VRMA non è negativo.</li><li><strong>Sec-Cos</strong>--Specifica che la VF è la funzione basata sulla secante del VRMA quando il VRMA è negativo e la funzione basata sul coseno del VRMA quando il VRMA non è negativo. </li><li><strong>Tabella</strong>--Identifica che verrà utilizzato un file tabella per definire il grafico del fattore verticale che viene utilizzato per determinare le VF.</li></ul><p>I modificatori delle parole chiave verticali includono quanto segue: </p><ul><li><strong>Fattore zero</strong>-- Stabilisce il fattore verticale usato quando il VRMA è zero. Questo fattore posiziona l’intercettazione y della funzione specificata. Per definizione, il fattore zero non è applicabile ad alcuna funzione verticale trigonometrica (COS, SEC, COS-SEC o SEC-COS). L'intercetta y è definita da queste funzioni.</li><li><strong>Angolo di taglio basso </strong>- Definisce l'angolo VRMA al di sotto del quale la VF sarà impostata su infinito.</li><li><strong>Angolo di taglio alto</strong> - Definisce l'angolo VRMA al di sopra del quale la VF sarà impostata su infinito. </li><li><strong>Pendenza</strong> - Stabilisce la pendenza della linea retta usata con le parole chiave <strong>Lineare</strong> e <strong>Lineare Inversa</strong>-fattore verticale. La pendenza è specificata come una frazione di salita su corsa (per esempio, la pendenza del 45 per cento è 1/45, che viene immessa come 0,02222).</li><li><strong>Nome tabella</strong>--</li>Identifica il nome della tabella che definisce la VF.</ul>",
	"@@Path-Distance-Back-Link_Vertical-Raster_tag0@@": "Definisce la relazione tra il fattore di costo verticale e l'angolo di movimento relativo verticale (VRMA).",
	"@@Path-Distance-Back-Link_Vertical-Raster_tag1@@": "I valori vengono utilizzati per calcolare la pendenza usata per identificare il fattore verticale quando si passa da una cella all'altra.",
	"@@Plus_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Plus_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Plus_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Plus_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Plus_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Plus_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Plus_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Plus_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Plus_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Plus_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Plus_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Plus_Raster_tag0@@": "L'input al quale verranno aggiunti i suoi valori.",
	"@@Plus_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Plus_Raster2_tag0@@": "L'input i cui valori verranno aggiunti al primo input.",
	"@@Plus_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Local_Cellsize-Type_tag0@@": "Scegliere quale grandezza di cella utilizzare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Local_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Local_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Local_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Si tratta dell'impostazione predefinita.",
	"@@Local_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Local_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Local_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Local_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Local_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Si tratta dell'impostazione predefinita.",
	"@@Local_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Local_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Local_Raster_tag0@@": "L'input al quale verranno aggiunti i suoi valori.",
	"@@Local_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Local_Raster2_tag0@@": "L'input i cui valori verranno aggiunti al primo input.",
	"@@Local_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Local_False-Raster_tag0@@": "L'input i cui valori saranno usati come valori pixel di output se la condizione è false. Può essere un numero intero, un raster a virgola mobile o un valore costante.",
	"@@Local_True-Raster_tag0@@": "L'input i cui valori saranno usati come valori pixel di output se la condizione è vero. Può essere un numero intero, un raster a virgola mobile o un valore costante.",
	"@@Power_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Power_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Power_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Power_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Power_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Power_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Power_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Power_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Power_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Power_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Power_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Power_Raster_tag0@@": "I valori di input da elevare alla potenza definiti da <strong>Raster2</strong>.",
	"@@Power_Raster_tag3@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Power_Raster2_tag0@@": "L'input che determina la potenza alla quale i valori di <strong>Raster</strong> saranno elevati.",
	"@@Power_Raster2_tag3@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Radar-Calibration_Calibration-Type_tag0@@": "Il tipo di calibrazione da eseguire.",
	"@@Radar-Calibration_Calibration-Type_tag1@@": "Beta-zero: la funzione restituisce la riflettanza del radar per area dell'unità nell'intervallo inclinato. Questo è il tipo calibrazione predefinito.",
	"@@Radar-Calibration_Calibration-Type_tag2@@": "Sigma-zero: la funzione restituisce la riflettanza del radar per area dell'unità nell'intervallo del terreno. I risultati sono valori a 32 bit a virgola mobile che rientrano comunemente nell'intervallo da 0,0 a 1,0. Se è selezionata questa opzione non si esegue alcun taglio dei dati.",
	"@@Radar-Calibration_Calibration-Type_tag3@@": "Gamma: la funzione restituisce la riflettanza del radar per area dell'unità nel piano perpendicolare alla direzione di misura.",
	"@@Radar-Calibration_Calibration-Type_tag4@@": "Nessuna",
	"@@Radar-Calibration_Raster_tag0@@": "Il raster di input.",
	"@@RasterInfo_Raster-Info_tag0@@": "Selezionare un dataset raster da usare come modello",
	"@@RasterInfo_Raster_tag0@@": "Il raster di input.",
	"@@Rasterize-Attributes_Attribute-Field-Names_tag0@@": "Elenco di campi nella <strong>Tabella attributi zonali</strong>, in cui ogni campo è separato da una virgola. I valori di ogni campo saranno rappresentati da una banda nel raster di output.",
	"@@Rasterize-Attributes_Background-Value_tag0@@": "Il valore di pixel iniziale delle bande di output in un raster, prima della nuova mappatura.",
	"@@Rasterize-Attributes_Background-Value_tag1@@": "Se un pixel non rientra in una zona, rimarrà come valore di sfondo.",
	"@@Rasterize-Attributes_Value-Raster_tag0@@": "Il raster di input obbligatorio.",
	"@@Rasterize-Attributes_Value-Raster_tag1@@": "L'input deve essere un raster a banda singola. Se si usa un raster multibanda, verrà usata solo la prima banda.",
	"@@Rasterize-Attributes_Where-Clause_tag0@@": "Un'interrogazione aggiuntiva opzionale applicata nella <strong>Tabella attributi zonali</strong>.",
	"@@Rasterize-Attributes_Where-Clause_tag3@@": "Se si è usata la tabella precedente come esempio, l'interrogazione sarebbe ${Variable1 = 'bare earth'}.",
	"@@Rasterize-Attributes_Zonal-Attributes-Table_tag0@@": "Gli attributi zonali specificati come un percorso ad una feature class locale, il percorso per una tabella, l'URL per un layer feature service o una stringa JSON.",
	"@@Rasterize-Attributes_Zonal-Attributes-Table_tag1@@": "In JSON, è descritta come una raccolta di mappature da ID zona a un array di numeri interi. ${{ zoneId:[f1,f2,...,fn], ... } }",
	"@@Rasterize-Attributes_Zone-Field_tag0@@": "Il nome del campo contenente i valori ID zona.",
	"@@Rasterize-Attributes_Zone-Raster_tag0@@": "Un raster a banda singola opzionale in cui ogni pixel contiene l'ID zona associato con la posizione. L'ID zona viene usato per la ricerca di righe nella tabella attributi zonali per ingestioni specifiche per zona.",
	"@@Rasterize-Attributes_Zone-Raster_tag1@@": "Lasciare questo parametro non specificato se si desidera solo importare l'attributo.",
	"@@Rasterize-Features_Field_tag0@@": "Seleziona il campo da usare per identificare ogni feature.",
	"@@Rasterize-Features_Input-Features_tag0@@": "Seleziona la feature class da convertire in formato raster.",
	"@@Rasterize-Features_Raster_tag0@@": "Selezionare un raster per definire la dimensione della cella e l'estensione per la conversione della feature.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag0@@": "Determina come gestire le feature che si sovrappongono:",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag1@@": "<strong>Primo</strong>: alle aree sovrapposte si assegnerà il valore del primo dataset della lista.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag3@@": "<strong>Ultimo</strong>: alle aree sovrapposte si assegnerà il valore dell'ultimo dataset della lista.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag5@@": "<strong>Più piccolo</strong>: alle aree sovrapposte si assegnerà il valore della feature più piccola.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag7@@": "<strong>Più grande</strong>: alle aree sovrapposte si assegnerà il valore della feature più grande.",
	"@@Recast_Overrides_tag0@@": "Una tabella di nomi variabili e valori definiti dall'utente utilizzata per modificare il mosaic dataset.",
	"@@Recast_Raster_tag0@@": "Il prodotto raster al quale verrà applicata la funzione Recast.",
	"@@Region-Group_Add-Link_tag0@@": "Specifica se viene aggiunto un campo collegamento alla tabella dell'output.",
	"@@Region-Group_Add-Link_tag1@@": "<strong>Aggiungi collegamento</strong>: un elemento ${LINK} verrà aggiunto alla tabella del raster di output.",
	"@@Region-Group_Add-Link_tag3@@": "<strong>Nessun collegamento</strong>: la tabella di output del raster di output conterrà solo elementi ${Value} e ${Count}.",
	"@@Region-Group_Excluded-Value_tag0@@": "Identifica un valore tale che se la posizione di una cella contiene il valore, non verrà valutata nessuna connessione spaziale indipendentemente dal numero di vicini specificati (QUATTRO o OTTO).",
	"@@Region-Group_Excluded-Value_tag1@@": "Le celle con il valore escluso verranno trattate come NoData ed eliminate dai calcoli. Le posizioni delle celle che contengono il valore escluso riceveranno 0 nel raster di output.",
	"@@Region-Group_Excluded-Value_tag2@@": "Il valore escluso è simile al concetto di un valore di sfondo, o di una maschera applicata. È necessario specificare un valore per questo parametro se il parametro <strong>${CROSS}</strong> è specificato.",
	"@@Region-Group_Number-of-Neighbor-Cells_tag0@@": "Il numero di celle vicine da utilizzare nella valutazione della connessione tra celle.",
	"@@Region-Group_Number-of-Neighbor-Cells_tag1@@": "<strong>QUATTRO</strong>: definisce la connessione tra celle con lo stesso valore solo se le celle sono esattamente a sinistra, destra, sopra o sotto ognuna delle quattro celle più vicine. Questa è l'impostazione predefinita.",
	"@@Region-Group_Number-of-Neighbor-Cells_tag3@@": "<strong>OTTO</strong>: definisce la connessione tra celle con lo stesso valore se sono nel quartiere di otto celle adiacente a ognuna. Include l'essere posizionate a destra, a sinistra, sopra o in diagonale una dall'altra.",
	"@@Region-Group_Zone-Connectivity_tag0@@": "Definisce i valori di cella da considerare durante il test di connettività.",
	"@@Region-Group_Zone-Connectivity_tag1@@": "<strong>ENTRO</strong>: verifica la connessione tra valori di input uguali all'interno della stessa zona. Questa è l'impostazione predefinita.",
	"@@Region-Group_Zone-Connectivity_tag3@@": "Le uniche celle che possono essere raggruppate sono celle della stessa zona (valore) che soddisfano i requisiti spaziali di connettività specificati dal parametro <strong>Numero di vicini</strong> (a quattro uscite o a otto uscite).",
	"@@Region-Group_Zone-Connectivity_tag6@@": "<strong>INCROCIO</strong>: verifica la connessione tramite i requisiti spaziali specificati dal numero del parametro di vicini tra celle con qualsiasi valore, fatta eccezione per il valore da escludere dal parametro del valore escluso.",
	"@@Region-Group_Zone-Connectivity_tag8@@": "Quando si utilizza questa opzione, è necessario specificare un valore per il parametro <strong>Valore escluso</strong>.",
	"@@Region-Group_Zone-Raster_tag0@@": "Il raster di input obbligatorio le cui regioni connesse univoche verranno identificate.",
	"@@Region-Group_Zone-Raster_tag1@@": "Deve essere di tipo numero intero.",
	"@@Region-Grow_Fill-Value-Field_tag0@@": "Il campo nella tabella degli attributi che definisce il valore di riempimento per i gruppi di pixel. In un’immagine multibanda, a tutte le bande viene assegnato questo valore.",
	"@@Region-Grow_Max-Growth-Radius-Field_tag0@@": "Il campo nella tabella degli attributi che definisce il raggio di crescita massima nelle unità di riferimento spaziale dell’immagine.",
	"@@Region-Grow_Raster_tag0@@": "Il raster su cui eseguire questa funzione.",
	"@@Region-Grow_Seed-Points_tag0@@": "Una Feature Class puntuale che funge da seed iniziali per l’algoritmo. Ogni punto di seed corrisponde ad una voce nella tabella degli attributi, che contiene il raggio di crescita massima, la soglia di somiglianza e le informazioni sul valore di riempimento.",
	"@@Region-Grow_Similarity-Threshold-Field_tag0@@": "Il campo nella tabella degli attributi che definisce la soglia di somiglianza, come distanza euclidea nello spazio spettrale.",
	"@@Remap_Allow-Unmatched-Pixel-Values_tag0@@": "I valori mancanti nella tabella di riclassificazione possono mantenere il loro valore o essere rimappati come NoData.",
	"@@Remap_Allow-Unmatched-Pixel-Values_tag1@@": "Deselezionato - Ogni pixel del raster di input che non viene riclassificato in una tabella di remap manterrà il suo valore e sarà scritto per la sua posizione nel raster di output. Si tratta dell'impostazione predefinita.",
	"@@Remap_Allow-Unmatched-Pixel-Values_tag2@@": "Selezionato: il valore di ciascun pixel del raster di input non riclassificato in una tabella di rimappatura sarà rimappato come NoData per il suo posizionamento nel raster di output.",
	"@@Remap_Input-Field_tag0@@": "Consente di scegliere il campo che specifica il valore di pixel di input che sarà rimappato.",
	"@@Remap_Input-Field_tag1@@": "Se la tabella ha un intervallo di valori, questo sarà il campo del valore minimo e occorrerà specificare anche il parametro <strong>Campo max di input</strong>.",
	"@@Remap_Input-Max-Field_tag0@@": "Consente di scegliere il campo del valore massimo laddove nella tabella sia specificato un intervallo di valori.",
	"@@Remap_List_tag0@@": "Consente di specificare i valori della mappa, l'intervallo di valori minimo e massimo e i nuovi valori di rimappatura. Inoltre, l'intervallo di valori può essere impostato come pixel NoData.",
	"@@Remap_Output-Field_tag0@@": "Consente di scegliere il campo che sarà usato come valore di output rimappato.",
	"@@Remap_Raster_tag0@@": "Il raster di input.",
	"@@Remap_Remap-Definition-Type_tag0@@": "Selezionare l'opzione che si desidera impiegare per impostare i valori di rimappatura:",
	"@@Remap_Remap-Definition-Type_tag1@@": "Elenco: specificando un intervallo di valore di pixel da mappare in un valore di pixel di output",
	"@@Remap_Remap-Table-Type_tag0@@": "Consente di scegliere il tipo di tabella da usare per rimappare il raster di input:",
	"@@Remap_Remap-Table-Type_tag1@@": "Semplice: usa l'input della <strong>Tabella di rimappatura</strong> per rimappare i valori di pixel del <strong>Campo di input</strong> nei valori corrispondenti del parametro <strong>Campo di output</strong>. Questo metodo memorizza nella cache la tabella di rimappatura in modo che possa essere eseguita più rapidamente.",
	"@@Remap_Remap-Table-Type_tag8@@": "Dinamico: questo metodo non memorizza nella cache la tabella di rimappatura, pertanto esegue un'interrogazione ogni volta che viene effettuata una richiesta (pan, zoom o aggiorna). Se la tabella cambia, la richiesta successiva rimapperà dinamicamente i valori di conseguenza.",
	"@@Remap_Remap-Table-Type_tag9@@": "Riassegnazione: per il processo di riclassificazione viene usata una tabella specifica, in cui ogni riga sarà rimappata soltanto in base a ciascun confine di feature.",
	"@@Remap_Remap-Table_tag0@@": "Consente di navigare all'interno della tabella che imposta i valori di rimappatura.",
	"@@Reproject_Raster_tag0@@": "Il dataset raster da riproiettare o ricampionare.",
	"@@Reproject_Spatial-Reference_tag0@@": "Il sistema di coordinate usato per riproiettare i dati.",
	"@@Reproject_X-Cellsize_tag0@@": "La dimensione x alla quale si dovrebbero ricampionare i dati. Facoltativa. Se il valore è 0 o meno, l'envelope dell'output (estensione e dimensioni cella) viene calcolata dal raster di input.",
	"@@Reproject_X-Registration-Point_tag0@@": "La coordinata x usata per definire l'angolo in alto a sinistra del dataset. Questa coordinata deve essere definita nelle unità del nuovo riferimento spaziale. Se sia il parametro <strong>Dimensione cella X</strong> e <strong>Dimensione cella Y</strong> sono maggiori di 0, vengono usati insieme ai parametri <strong>Punto di registrazione X</strong> e <strong>Punto di registrazione Y</strong> per definire l'envelope dell'output.",
	"@@Reproject_Y-Cellsize_tag0@@": "La dimensione Y alla quale si dovrebbero ricampionare i dati. Facoltativa. Se il valore è 0 o meno, l'envelope dell'output (estensione e dimensioni cella) viene calcolata dal raster di input.",
	"@@Reproject_Y-Registration-Point_tag0@@": "La coordinata Y usata per definire l'angolo in alto a sinistra del dataset. Questa coordinata deve essere definita nelle unità del nuovo riferimento spaziale. Se sia il parametro <strong>Dimensione cella X</strong> e <strong>Dimensione cella Y</strong> sono maggiori di 0, vengono usati insieme ai parametri <strong>Punto di registrazione X</strong> e <strong>Punto di registrazione Y</strong> per definire l'envelope dell'output.",
	"@@Resample_Input-Cellsize_tag0@@": "La dimensione della cella del pixel del raster di input.",
	"@@Resample_Output-Cellsize_tag0@@": "La dimensione della cella del pixel del raster di output. È possibile cambiare la dimensione delle celle, ma l'estensione del raster dataset rimarrà lo stesso. Il ricampionamento eseguito da una dimensione della cella definita dall'utente può essere molto più lento rispetto a quello predefinito del sistema, poiché il ricampionamento predefinito del sistema elabora la quantità minima di dati dalla risoluzione più vicina possibile.",
	"@@Resample_Raster_tag0@@": "Il raster di input da ricampionare.",
	"@@Resample_Resampling-Type_tag0@@": "<strong>Vicino più prossimo</strong>: calcola il valore del pixel di output usando il pixel di input più vicino. I pixel NoData rimarranno invariati nel dataset raster di output. Questa è l'impostazione predefinita.",
	"@@Resample_Resampling-Type_tag2@@": "<strong>Interpolazione bilineare</strong>: calcola il valore di pixel usando il valore verificato a distanza dei quattro pixel più vicini. Questo è un metodo di calcolo efficiente da elaborare.",
	"@@Resample_Resampling-Type_tag4@@": "<strong>Convoluzione cubica</strong>: determina il nuovo valore di un pixel basandosi sull'adattamento di una curva smussata attraverso i 16 centri dei pixel di input più vicini.",
	"@@Resample_Resampling-Type_tag6@@": "<strong>Maggioranza</strong>: calcola il valore di pixel usando il valore di pixel di maggioranza nei 16 pixel più vicini. I pixel NoData rimarranno invariati nel dataset raster di output.",
	"@@Resample_Resampling-Type_tag8@@": "<strong>Interpolazione bilineare Plus</strong>: utilizza <strong>Interpolazione bilineare</strong>, fatta eccezione per i pixel lungo i margini, definiti come NoData e che non sono replicati o considerati nei calcoli. Utilizzare <strong>Interpolazione bilineare Plus</strong> per i dati di tile poiché i margini mostreranno corrispondenze migliori.",
	"@@Resample_Resampling-Type_tag14@@": "<strong>Sfocatura gaussiana</strong>: applica una convoluzione gaussiana al raster di origine e calcola i valori di pixel utilizzando il valore verificato di distanza dei quattro pixel più vicini provenienti dal raster sfocato. È appropriato per la rimozione di rumore dai dati ricampionati e per il ricampionamento verso il basso per ottenere una dimensione di pixel maggiore.",
	"@@Resample_Resampling-Type_tag16@@": "<strong>Sfocatura gaussiana Plus</strong>: utilizza lo stesso metodo di <strong>Sfocatura gaussiana</strong>, fatta eccezione per i pixel lungo i margini, definiti come NoData e che non sono replicati o considerati nei calcoli. Utilizzare <strong>Sfocatura gaussiana Plus</strong> per i dati di tile poiché i margini mostreranno corrispondenze migliori.",
	"@@Resample_Resampling-Type_tag22@@": "<strong>Media</strong>: calcola i valori di pixel utilizzando il valore medio di tutti i pixel di sovrapposizione, per ogni pixel target.",
	"@@Resample_Resampling-Type_tag24@@": "<strong>Minimo</strong>: calcola il valore di pixel utilizzando il valore minimo di tutti i pixel di sovrapposizione. I pixel NoData rimarranno invariati nel dataset raster di output.",
	"@@Resample_Resampling-Type_tag26@@": "<strong>Massimo</strong>: idoneo per i dati continui, produce un'immagine di output più morbida rispetto al metodo di ricampionamento Vicino più prossimo.",
	"@@Resample_Resampling-Type_tag28@@": "<strong>Media vettoriale</strong>: calcola la media vettoriale della magnitudo-direzione utilizzando tutti i pixel coinvolti. Questo metodo è applicabile solo per due raster di banda che rappresentano magnitudo e direzione. Converte prima di tutto la magnitudo-direzione in U-V, quindi prende la media aritmetica di tutti i pixel coinvolti per ottenere l'U-V del pixel target e lo converte nuovamente in magnitudo-direzione.",
	"@@Round-Down_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Round-Down_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Round-Down_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Round-Down_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Round-Down_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Round-Down_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Round-Down_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Round-Down_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Round-Down_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Round-Down_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Round-Down_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Round-Down_Raster_tag0@@": "I valori di input da arrotondare per difetto.",
	"@@Round-Up_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Round-Up_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Round-Up_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Round-Up_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Round-Up_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Round-Up_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Round-Up_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Round-Up_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Round-Up_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Round-Up_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Round-Up_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Round-Up_Raster_tag0@@": "I valori di input da arrotondare per eccesso.",
	"@@Segment-Mean-Shift_Minimum-Segment-Size-in-Pixels_tag0@@": "Dimensione minima del segmento, misurata in pixel. Questo valore è correlato all'unità di mappatura minima, e filtrerà i blocchi di pixel più piccoli. Tutti i segmenti più piccoli del valore specificato uniranno i segmenti più piccoli con il segmento vicino più adeguato.",
	"@@Segment-Mean-Shift_Raster_tag0@@": "Il raster di input da segmentare.",
	"@@Segment-Mean-Shift_Segment-boundaries-only_tag0@@": "I confini del segmento disegnati come una linea di contorno nera intorno a ogni segmento. Questo è d'aiuto poiché consente di distinguere i segmenti adiacenti che hanno colori simili.",
	"@@Segment-Mean-Shift_Segment-boundaries-only_tag1@@": "Non selezionato: i confini del segmento non vengono visualizzati. Questa è l'impostazione predefinita.",
	"@@Segment-Mean-Shift_Segment-boundaries-only_tag2@@": "Selezionato: i confini del segmento vengono visualizzati con linee di contorno nere intorno a ogni segmento.",
	"@@Segment-Mean-Shift_Spatial-Detail_tag0@@": "L'importanza relativa della separazione degli oggetti basandosi sulle caratteristiche spaziali.",
	"@@Segment-Mean-Shift_Spatial-Detail_tag1@@": "I valori interi validi sono compresi tra 1 e 20. I valori più piccoli producono classi più ampie e più smussatura. Un valore più alto è appropriato per distinguere le feature che sono spazialmente piccole e raggruppate. Ad esempio, in una scena urbana, si potrebbero classificare le feature generali di superficie impervia utilizzando un valore di dettaglio spaziale più piccolo, o si potrebbero classificare edifici e strade come classi separate utilizzando un valore di dettaglio spaziale più alto.",
	"@@Segment-Mean-Shift_Spectral-Detail_tag0@@": "L'importanza relativa della separazione degli oggetti basandosi sulle caratteristiche cromatiche.",
	"@@Segment-Mean-Shift_Spectral-Detail_tag1@@": "I valori a virgola mobile validi sono compresi tra 1,0 e 20,0. I valori più piccoli producono classi più ampie e più smussatura. Un valore più alto è appropriato quando si vuole differenziare le feature che hanno in qualche modo delle caratteristiche spettrali simili. Ad esempio, utilizzando un valore di dettaglio spettrale maggiore in una scena forestale, avremo la possibilità di distinguere meglio le diverse specie di alberi.",
	"@@Segment-Mean-Shift_maximumsegmentsizeinpixels_tag0@@": "<p>La dimensione massima di un segmento. I segmenti che sono più grandi della dimensione specificata saranno divisi. Usa questo parametro per evitare artefatti nel livello di uscita derivanti da segmenti di grandi dimensioni. Il valore predefinito è -1.</p>",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag0@@": "Selezionare uno dei quattro tipi di calibrazione:",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag1@@": "<strong>Beta-zero</strong>: produce un output che contiene il coefficiente di luminosità del radar.",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag3@@": "<strong>Sigma-zero</strong>: la retrodiffusione restituita all'antenna da un'area di unità sul terreno, correlata all'intervallo del terreno.",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag5@@": "<strong>Gamma</strong>: misurazione dell'energia emessa e restituita, utile per la determinazione dei modelli dell'antenna.",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag7@@": "<strong>Nessuno</strong>: non applica una correzione. Questa è l'impostazione predefinita.",
	"@@Sentinel-1-Radiometric-Calibration_Raster_tag0@@": "Il raster di input Sentinel-1 Level-1 GRD o SLC che si vuole elaborare.",
	"@@Sentinel-1-Radiometric-Calibration_Raster_tag1@@": "La funzione utilizzerà il file LUT o per applicare la correzione termica o per rimuoverla, a seconda dei contenuti del file LUT.",
	"@@Sentinel-1-Thermal-Noise-Removal_Raster_tag0@@": "Il raster di input Sentinel-1 che si vuole elaborare.",
	"@@Sentinel-1-Thermal-Noise-Removal_Raster_tag1@@": "La funzione utilizzerà il file LUT o per applicare la correzione termica o per rimuoverla a seconda dei contenuti del file LUT.",
	"@@Set-Null_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Set-Null_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Set-Null_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Set-Null_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Set-Null_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Set-Null_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Set-Null_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Set-Null_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Set-Null_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Set-Null_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Set-Null_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Set-Null_False-Raster_tag0@@": "L'input i cui valori saranno usati come valori pixel di output se la condizione è false. Può essere un numero intero, un raster a virgola mobile o un valore costante.",
	"@@Set-Null_Raster_tag0@@": "Il raster di input che rappresenta il risultato booleano di una Raster Function matematica logica. I valori saranno 1 (per true) o 0 (per false). Può essere un numero intero o un raster a virgola mobile.",
	"@@Shaded-Relief_Altitude_tag0@@": "L'altitudine è l'angolo di elevazione del sole sull'orizzonte e spazia da 0 a 90 gradi. Un valore di 0 gradi indica che il sole è all'orizzonte, ovvero sullo stesso piano orizzontale della cornice di riferimento. Un valore di 90 gradi indica che il sole è direttamente sopra di noi. Il valore predefinito è di 45 gradi sopra l'orizzonte.",
	"@@Shaded-Relief_Azimuth_tag0@@": "L'azimut è la posizione relativa del sole lungo l'orizzonte (in grandi). Questa posizione è indicata dall'angolo del sole misurato in senso orario rispetto al nord. Un azimut di 0 gradi indica il nord, l'est è 90 gradi, il sud è 180 gradi e l'ovest è 270 gradi.",
	"@@Shaded-Relief_Color-Scheme-Type_tag0@@": "Specificare se verrà utilizzata una scala cromatica o una mappa colore per visualizzare il rilievo ombreggiato.",
	"@@Shaded-Relief_Color-Scheme-Type_tag1@@": "<strong>Scala cromatica</strong>: quando si sceglie una <strong>Scala cromatica</strong>, verrà richiesto di selezionare una scala cromatica appropriata.",
	"@@Shaded-Relief_Color-Scheme-Type_tag5@@": "<strong>Mappa colore</strong>: quando si sceglie <strong>Mappa colore</strong>, verrà richiesto di specificare il file mappa di colore da utilizzare.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag0@@": "Specificare se l'interpolazione del pixel bordo predefinita deve essere disabilitata o meno.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag1@@": "Non selezionato: si applicherà un ricampionamento bilineare uniforme per ricampionare il rilievo ombreggiato. Questa è l'impostazione predefinita.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag2@@": "Selezionato: si userà un ricampionamento bilineare all'interno del rilievo ombreggiato, tranne lungo i margini dei raster o accanto a pixel di NoData. Questi pixel saranno popolati con valore NoData, che ridurrà eventuali effetti di margini netti.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag3@@": "Se si usa questa opzione si eviteranno ricampionamenti che si possono verificare lungo i margini di un raster. I pixel di output lungo il margine di un raster o accanto a pixel senza un valore saranno popolati con NoData; quindi, si consiglia di usare questa opzione solo quando ci sono altri raster con pixel sovrapposti disponibili. Quando sono disponibili pixel sovrapposti, queste aree di NoData non saranno vuote, ma visualizzeranno i valori pixel sovrapposti.",
	"@@Shaded-Relief_Raster_tag0@@": "Il raster di elevazione di input.",
	"@@Shaded-Relief_Scaling_tag0@@": "Il risultato ombreggiato è scalato dinamicamente regolando il fattore z usando una delle due opzioni seguenti:",
	"@@Shaded-Relief_Scaling_tag1@@": "<strong>Nessuno</strong>: non si applica nessuna scala. È l'opzione ideale per raster dataset singoli relativi ad un'area locale. Non è un'opzione consigliata per i dataset mondiali con grandi variazioni in termini di elevazione o con mappe multiscala, poiché verrebbe prodotto un rilievo del terreno con piccole variazioni e piccole scale.",
	"@@Shaded-Relief_Scaling_tag3@@": "<strong>Regolata</strong>: si applica una regolazione non lineare usando i valori predefiniti di <strong>Potenza dimensione pixel</strong> e <strong>Fattore dimensione pixel</strong>, che comprende un'ampia gamma di variazioni di altitudine (scala) ingrandendo e riducendo l'immagine con lo zoom. L'opzione <strong>Regolata</strong> è consigliata quando si utilizza un dataset mondiale.",
	"@@Shaded-Relief_Z-Factor_tag0@@": "Il fattore Z è un fattore di scala utilizzato per convertire i valori di elevazione per due motivi:",
	"@@Shaded-Relief_Z-Factor_tag1@@": "Per convertire le unità di elevazione (ad esempio, metri o piedi) in unità di coordinate orizzontali del dataset, che possono essere piedi, metri o gradi",
	"@@Shaded-Relief_Z-Factor_tag2@@": "Per aggiungere il fattore di moltiplicazione verticale per ottenere un effetto visivo",
	"@@Shaded-Relief_Z-Factor_tag3@@": "Il risultato ombreggiato è scalato dinamicamente regolando il fattore z usando una delle due opzioni seguenti:",
	"@@Shaded-Relief_Z-Factor_tag4@@": "<strong>Nessuno</strong>: non si applica nessuna scala. È l'opzione ideale per raster dataset singoli relativi ad un'area locale. Non è un'opzione consigliata per i dataset mondiali con grandi variazioni in termini di elevazione o con mappe multiscala, poiché verrebbe prodotto un rilievo del terreno con piccole variazioni e piccole scale.",
	"@@Shaded-Relief_Z-Factor_tag6@@": "<strong>Regolata</strong>: si applica una regolazione non lineare usando i valori predefiniti di <strong>Potenza dimensione pixel</strong> e <strong>Fattore dimensione pixel</strong>, che comprende un'ampia gamma di variazioni di altitudine (scala) ingrandendo e riducendo l'immagine con lo zoom. L'opzione <strong>Regolata</strong> è consigliata quando si utilizza un dataset mondiale.",
	"@@Shaded-Relief_hillshadetype_tag0@@": "Controlla la fonte di illuminazione per l'hillshade.",
	"@@Shaded-Relief_hillshadetype_tag1@@": "<strong>Tradizionale</strong>: calcola l'hillshade da un'unica direzione di illuminazione. È possibile impostare le opzioni <strong>Azimut</strong> e <strong>Altitudine</strong> per controllare la posizione della fonte di luce. Questa è l'impostazione predefinita.",
	"@@Shaded-Relief_hillshadetype_tag2@@": "<strong>Multidirezionale</strong>: combina la luce da fonti multiple per rappresentare una visualizzazione migliorata del terreno.",
	"@@Shaded-Relief_PSPower_tag0@@": "<strong>Potenza dimensioni in pixel</strong> si riferisce alle variazioni di altitudine (o scala) ingrandendo e riducendo l'immagine con lo zoom del Viewer sulla visualizzazione mappa. È l'esponente applicato al termine dimensioni in pixel nell'equazione che controlla la percentuale alla quale il <strong>Fattore Z</strong> cambia per evitare una perdita significativa di rilievo.",
	"@@Shaded-Relief_PSPower_tag1@@": "Questo parametro è valido solo quando il tipo di <strong>Scala</strong> è <strong>Regolato</strong>. Il valore predefinito è 0,664.",
	"@@Shaded-Relief_PSZFactor_tag0@@": "<strong>Fattore dimensioni in pixel</strong> si riferisce alle variazioni nella scala ingrandendo e riducendo l'immagine con lo zoom del Viewer sulla visualizzazione della mappa. Controlla la percentuale alla quale cambia il <strong>Fattore Z</strong>.",
	"@@Shaded-Relief_PSZFactor_tag1@@": "Questo parametro è valido solo quando il tipo di <strong>Scala</strong> è <strong>Regolato</strong>. Il valore predefinito è 0,024.",
	"@@Sin_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Sin_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Sin_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Sin_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Sin_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Sin_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Sin_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Sin_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Sin_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Sin_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Sin_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Sin_Raster_tag0@@": "L'input per il quale calcolare i valori di seno.",
	"@@SinH_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@SinH_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@SinH_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@SinH_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@SinH_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@SinH_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@SinH_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@SinH_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@SinH_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@SinH_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@SinH_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@SinH_Raster_tag0@@": "L'input per il quale calcolare i valori di seno iperbolico.",
	"@@Sink_Flow-Direction-Raster_tag0@@": "Il raster di input che mostra la direzione del flusso fuori da ogni cella.",
	"@@Sink_Flow-Direction-Raster_tag1@@": "Il raster di direzione del flusso può essere creato eseguendo la funzione <strong>Direzione flusso</strong>.",
	"@@Slope_DEM_tag0@@": "Il raster di elevazione di input.",
	"@@Slope_Disable-default-edge-pixel-interpolation_tag0@@": "Se si usa questa opzione si eviteranno ricampionamenti che si possono verificare lungo i margini di un raster. I pixel di output lungo il margine di un raster o accanto a pixel senza un valore saranno popolati con NoData; quindi, si consiglia di usare questa opzione solo quando ci sono altri raster con pixel sovrapposti disponibili. Quando sono disponibili pixel sovrapposti, queste aree di NoData non saranno vuote, ma visualizzeranno i valori pixel sovrapposti.",
	"@@Slope_Disable-default-edge-pixel-interpolation_tag1@@": "Non selezionato: si applicherà un ricampionamento bilineare uniforme per ricampionare la pendenza. Questa è l'impostazione predefinita.",
	"@@Slope_Disable-default-edge-pixel-interpolation_tag2@@": "Selezionato: si userà un ricampionamento bilineare all'interno della pendenza, tranne lungo i margini dei raster o accanto a pixel di NoData. Questi pixel saranno popolati con valore NoData, che ridurrà eventuali effetti di margini netti.",
	"@@Slope_Scaling_tag0@@": "L'inclinazione della pendenza può essere emessa come un valore in gradi o un aumento percentuale. Esistono tre opzioni per la <strong>Scala</strong>:",
	"@@Slope_Scaling_tag3@@": "<strong>Grado</strong>: l'inclinazione della pendenza è calcolata in gradi. Questi valori spaziano da 0 a 90.",
	"@@Slope_Scaling_tag5@@": "<strong>Aumento_percentuale</strong>: l'inclinazione della pendenza è calcolata come valori percentuali. Questi valori spaziano da 0 a infinito. Una superficie piatta è un aumento percentuale dello 0%, mentre una superficie di 45 gradi è 100%. Quanto più la superficie diventa verticale, tanto più alto diventa l'aumento percentuale.",
	"@@Slope_Scaling_tag7@@": "<strong>In scala</strong>: l'inclinazione della pendenza è calcolata come GRADO, ma il fattore z è regolato per la scala. Usa i valori di <strong>Potenza dimensione pixel</strong> e <strong>Fattore dimensione pixel</strong>, che comprendono variazioni di risoluzione (scala) ingrandendo e rimpicciolendo l'immagine con lo zoom. È consigliata quando si usano dataset mondiali, soprattutto quando si usa la pendenza come superficie di visualizzazione.",
	"@@Slope_Scaling_tag13@@": "Il fattore z è regolato usando la seguente equazione:",
	"@@Slope_Scaling_tag14@@": "Fattore Z regolato = (Fattore Z) + (Dimensione pixel)",
	"@@Slope_Scaling_tag15@@": "× (Fattore di Misura Pixel)",
	"@@Slope_Scaling_tag16@@": "Potenza dimensione pixel",
	"@@Slope_Z-Factor_tag0@@": "Il <strong>fattore Z</strong> è un fattore di scala utilizzato per convertire i valori di elevazione per due motivi:",
	"@@Slope_Z-Factor_tag3@@": "Per convertire le unità di elevazione (ad esempio, metri o piedi) in unità di coordinate orizzontali del dataset, che possono essere piedi, metri o gradi",
	"@@Slope_Z-Factor_tag4@@": "Per aggiungere il fattore di moltiplicazione verticale per ottenere un effetto visivo",
	"@@Slope_PSPower_tag0@@": "<strong>Potenza dimensioni in pixel</strong> si riferisce alle variazioni di altitudine (o scala) ingrandendo e riducendo l'immagine con lo zoom del Viewer sulla visualizzazione mappa. È l'esponente applicato al termine dimensioni in pixel nell'equazione che controlla la percentuale alla quale il <strong>Fattore Z</strong> cambia per evitare una perdita significativa di rilievo.",
	"@@Slope_PSPower_tag1@@": "Questo parametro è valido solo quando il tipo di <strong>scala </strong> è <strong>Scalato</strong>. Il valore predefinito è 0,664.",
	"@@Slope_PSZFactor_tag0@@": "<strong>Fattore dimensioni in pixel</strong> si riferisce alle variazioni nella scala ingrandendo e riducendo l'immagine con lo zoom del Viewer sulla visualizzazione mappa. Controlla la percentuale alla quale cambia il <strong>Fattore Z</strong>.",
	"@@Slope_PSZFactor_tag1@@": "Questo parametro è valido solo quando il tipo di <strong>scala</strong> è <strong>Scalato</strong>. Il valore predefinito è 0,024.",
	"@@Snap-Pour-Point_Flow-Accumulation-Raster_tag0@@": "Il raster layer di accumulo di flusso di input.",
	"@@Snap-Pour-Point_Flow-Accumulation-Raster_tag1@@": "Può essere creato con la funzione <strong>Accumulo di flusso</strong>.",
	"@@Snap-Pour-Point_Pour-Point-Field_tag0@@": "Il campo usato per assegnare valori alle posizioni del punto di versamento.",
	"@@Snap-Pour-Point_Pour-Point-Raster_tag0@@": "Le posizioni del punto di versamento di input da agganciare.",
	"@@Snap-Pour-Point_Pour-Point-Raster_tag1@@": "Per un raster layer di input, tutte le celle che non sono NoData (cioè, hanno un valore) verranno considerate punti di versamento e verranno agganciate.",
	"@@Snap-Pour-Point_Snap-Distance_tag0@@": "La distanza massima nelle unità della mappa da ricercare per una cella di flusso accumulato maggiore.",
	"@@Speckle_Additive-Noise-Mean_tag0@@": "Specifica il valore medio del rumore additivo. Un valore medio del rumore maggiore produrrà meno smussamento, mentre i risultati di valore minori produrranno più smussamento.",
	"@@Speckle_Additive-Noise-Mean_tag1@@": "Questo parametro è valido solo quando il <strong>Tipo di filtro</strong> è <strong>Filtro Lee</strong> e il <strong>Modello di rumore</strong> è <strong>Rumore additivo</strong> o <strong>Rumore additivo e moltiplicativo</strong>. Il valore predefinito è 0.",
	"@@Speckle_Damping-Factor_tag0@@": "Specifica l'estensione dell'effetto smorzamento esponenziale nel filtraggio. Un valore di smorzamento maggiore conserva meglio i margini ma smussa di meno, mentre un valore minore produce più smussamento. Un valore di 0 produce lo stesso output di un filtro passa basso.",
	"@@Speckle_Damping-Factor_tag1@@": "Questo parametro è valido solo quando il <strong>Tipo di filtro</strong> è <strong>Filtro Lee migliorato</strong> o <strong>Filtro Frost</strong>. Il valore predefinito è 1.",
	"@@Speckle_Filter-Size_tag0@@": "Specifica la dimensione della finestra di pixel utilizzata per filtrare il rumore:",
	"@@Speckle_Filter-Size_tag1@@": "3x3",
	"@@Speckle_Filter-Size_tag2@@": "5x5",
	"@@Speckle_Filter-Size_tag3@@": "7x7",
	"@@Speckle_Filter-Size_tag4@@": "9x9",
	"@@Speckle_Filter-Size_tag5@@": "11x11",
	"@@Speckle_Filter-Type_tag0@@": "Specifica il tipo di filtro da utilizzare nell'algoritmo di smussamento per rimuovere il rumore moltiplicativo:",
	"@@Speckle_Filter-Type_tag1@@": "<strong>Filtro Lee</strong>: riduce il rumore moltiplicativo applicando un filtro spaziale a ogni pixel in un'immagine, il che filtra i dati in base alle statistiche locali calcolate all'interno di una finestra quadrata. Questo filtro è utile quando si vuole smussare i dati del rumore moltiplicativo che hanno componenti additivi o moltiplicativi. Questa è l'impostazione predefinita.",
	"@@Speckle_Filter-Type_tag3@@": "<strong>Filtro Lee migliorato</strong>: una versione adattata del filtro il Lee che include <strong>Fattore di smorzamento</strong> e <strong>Numero di ricerche</strong>. Questo filtro è utile quando si vuole ridurre il rumore moltiplicativo conservando le informazioni della struttura.",
	"@@Speckle_Filter-Type_tag9@@": "<strong>Filtro Frost</strong>: riduce il rumore moltiplicativo con un filtro simmetrico circolare smorzato esponenzialmente che utilizza le statistiche locali all'interno delle finestre di filtro individuali. Questo filtro è utile quando si vuole ridurre il rumore moltiplicativo conservando i margini nelle immagini radar.",
	"@@Speckle_Filter-Type_tag11@@": "<strong>Filtro Kuan</strong>: paragonabile al filtro Lee, questo filtro applica un filtro spaziale a ogni pixel in un'immagine e filtra i dati in base alle statistiche locali calcolate all'interno di una finestra quadrata. Questo filtro è utile quando si vuole ridurre il rumore moltiplicativo conservando i margini nelle immagini radar.",
	"@@Speckle_Multiplicative-Noise-Mean_tag0@@": "Specifica il valore medio del rumore moltiplicativo. Un valore medio del rumore maggiore produrrà meno smussamento, mentre i risultati di valore minori produrranno più smussamento.",
	"@@Speckle_Multiplicative-Noise-Mean_tag1@@": "Questo parametro è valido solo quando il <strong>Tipo di filtro</strong> è <strong>Filtro Lee</strong> e il <strong>Modello di rumore</strong> è <strong>Rumore additivo</strong> o <strong>Rumore additivo e moltiplicativo</strong>. Il valore predefinito è 1.",
	"@@Speckle_Noise-Model_tag0@@": "Specifica il tipo di rumore responsabile della riduzione della qualità delle immagini radar:",
	"@@Speckle_Noise-Model_tag1@@": "<strong>Rumore moltiplicativo</strong>: rumore di segnale casuale che si moltiplica nel segnale rilevante durante l'acquisizione o la trasmissione",
	"@@Speckle_Noise-Model_tag3@@": "<strong>Rumore additivo</strong>: rumore di segnale casuale che si aggiunge al segnale rilevante durante l'acquisizione o la trasmissione",
	"@@Speckle_Noise-Model_tag5@@": "<strong>Rumore additivo e moltiplicativo</strong>: entrambi i modelli di rumore",
	"@@Speckle_Noise-Variance_tag0@@": "Specifica la varianza di rumore nell'immagine radar.",
	"@@Speckle_Noise-Variance_tag1@@": "Questo parametro è valido solo quando il <strong>Tipo di filtro</strong> è <strong>Filtro Lee</strong> e il <strong>Modello di rumore</strong> è <strong>Rumore additivo</strong> o <strong>Rumore additivo e moltiplicativo</strong>. Il valore predefinito è 0,25.",
	"@@Speckle_Number-of-Looks_tag0@@": "Specifica il numero di ricerche dell'immagine, il che verifica lo smussamento dell'immagine e stima la varianza del rumore. Un valore più piccolo produce più smussatura, mentre un valore più grande conserva più feature dell'immagine.",
	"@@Speckle_Number-of-Looks_tag1@@": "Questo parametro è valido solo quando il <strong>Tipo di filtro</strong> è <strong>Filtro Lee</strong> e il <strong>Modello di rumore</strong> è <strong>Rumore moltiplicativo</strong> o quando il <strong>Tipo di filtro</strong> è <strong>Filtro Kuan</strong>. Il valore predefinito è 1.",
	"@@Speckle_Raster_tag0@@": "Il raster di input.",
	"@@Spectral-Conversion_Conversion-Matrix_tag0@@": "La matrice utilizzata per convertire il raster di input.",
	"@@Spectral-Conversion_Conversion-Matrix_tag1@@": "L'equazione usata per eseguire questa conversione è:",
	"@@Spectral-Conversion_Conversion-Matrix_tag2@@": "Banda di output_R = Ponderazione_P * Banda_C",
	"@@Spectral-Conversion_Conversion-Matrix_tag3@@": "dove:",
	"@@Spectral-Conversion_Conversion-Matrix_tag4@@": "Band_R è una banda di output, in cui R è un numero da 1 al numero di bande di output.",
	"@@Spectral-Conversion_Conversion-Matrix_tag5@@": "Weight_P è un elenco di pesi delimitato da virgole, 1 per ogni banda di input. La somma dei pesi per ogni banda dovrebbe essere uguale a 1.",
	"@@Spectral-Conversion_Conversion-Matrix_tag6@@": "Band_C è l'immagine di input, in cui C è un numero da 1 al numero di bande dell'immagine di input.",
	"@@Spectral-Conversion_Raster_tag0@@": "Il raster di input.",
	"@@Spectral-Conversion_Raster_tag1@@": "Può essere un raster dataset, un mosaic dataset o un image service.",
	"@@Spectral-Conversion_Size_tag0@@": "Il numero di righe e colonne in <strong>Matrice di conversione</strong>.",
	"@@Square_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Square_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Square_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Square_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Square_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Square_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Square_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Square_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Square_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Square_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Square_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Square_Raster_tag0@@": "I valori di input da elevare al quadrato.",
	"@@Square-Root_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Square-Root_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Square-Root_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Square-Root_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Square-Root_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Square-Root_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Square-Root_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Square-Root_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Square-Root_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Square-Root_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Square-Root_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Square-Root_Raster_tag0@@": "I valori di input utilizzati per trovare la radice quadrata.",
	"@@Statistics-and-Histogram_Define-Statistics-and-Histogram_tag0@@": "Impostare i valori statistici per ogni banda.",
	"@@Statistics-and-Histogram_Define-Statistics-and-Histogram_tag1@@": "La colonna ${Histogram} è un campo di sola lettura che può essere popolato utilizzando il parametro <strong>Importa</strong>. Se si importa un file di istogramma, la colonna ${Histogram} viene contrassegnata come <strong>Definito</strong>.",
	"@@Statistics-and-Histogram_Import_tag0@@": "Importare informazioni su statistiche e istogramma da un raster o un file XML esistente.",
	"@@Statistics-and-Histogram_Raster_tag0@@": "Il raster di input che richiede l’impostazione di statistiche e istogramma.",
	"@@Statistics-and-Histogram_Statistics_tag0@@": "Impostare i valori statistici per ogni banda.",
	"@@Stream-Link_Flow-Direction-Raster_tag0@@": "Il raster di input che mostra la direzione del flusso fuori da ogni cella.",
	"@@Stream-Link_Flow-Direction-Raster_tag1@@": "Il raster di direzione del flusso può essere creato eseguendo la funzione <strong>Direzione flusso</strong>.",
	"@@Stream-Link_Stream-Raster_tag0@@": "Il raster di input che rappresenta una rete di flusso lineare.",
	"@@Stream-Order_Flow-Direction-Raster_tag0@@": "Il raster di input che mostra la direzione del flusso fuori da ogni cella.",
	"@@Stream-Order_Flow-Direction-Raster_tag1@@": "Il raster di direzione del flusso può essere creato eseguendo la funzione <strong>Direzione flusso</strong>.",
	"@@Stream-Order_Order-Method_tag0@@": "Il metodo utilizzato per assegnare l'ordine di flusso.",
	"@@Stream-Order_Order-Method_tag1@@": "<strong>STRAHLER</strong>: il metodo di ordinamento di flusso proposto da Strahler nel 1952. L'ordine di flusso aumenta solo quando si intersecano flussi dello stesso ordine. L'intersezione di un collegamento di prim'ordine e di second'ordine produrrà un collegamento di second'ordine, piuttosto che un collegamento di terz'ordine. Questa è l'impostazione predefinita.",
	"@@Stream-Order_Order-Method_tag3@@": "<strong>SHREVE</strong>: il metodo di ordinamento di flusso per magnitudo proposto da Shreve nel 1967. A tutti i collegamenti senza affluenti viene assegnata una magnitudo (ordine) di uno. Le magnitudo sono pendenze verso il basso additive. Quando si intersecano due collegamenti, le loro magnitudo vengono aggiunte e assegnate al link della pendenza verso il basso.",
	"@@Stream-Order_Stream-Raster_tag0@@": "Un raster di flusso di input che rappresenta una rete di flusso lineare.",
	"@@Stretch_Auto-Gamma_tag0@@": "Utilizzare <strong>Gamma automatica</strong> per calcolare la gamma dalle statistiche e dall'istogramma del dataset. Le statistiche possono essere le statistiche stimate dalla funzione stessa, o le statistiche possono essere stimate dal software se si sceglie un layer.",
	"@@Stretch_Dynamic-Range-Adjustment_tag0@@": "Selezionare la casella di controllo <strong>Regolazione gamma dinamica</strong> se si vuole calcolare le statistiche solo dai pixel visualizzati sullo schermo. Questa opzione viene generalmente applicata quando l'immagine verrà pubblicata e utilizzata in un'applicazione Web che non può eseguire questo tipo di estensione.",
	"@@Stretch_Estimate-Statistics_tag0@@": "Selezionare la casella di controllo <strong>Stima statistiche</strong> se si desidera eseguire una stima delle statistiche. Le statistiche stimate sono calcolate da un campionamento di 1000 in 1000 dal centro del raster e sono utilizzate dall'estensione.",
	"@@Stretch_Estimate-Statistics_tag3@@": "Se questo è selezionato e il raster include statistiche o se si sono immessi valori nella tabella <strong>Statistiche</strong>, si utilizzeranno tali dati al posto di eseguire la stima, a meno che l'estensione non richieda un istogramma. Se l'estensione richiede un istogramma che non esiste, verrà stimata.",
	"@@Stretch_Gamma_tag0@@": "Utilizzare la barra del cursore per impostare manualmente il valore <strong>Gamma</strong>.",
	"@@Stretch_Number-Of-Standard-Deviations_tag0@@": "Specificare il valore n per il numero di deviazioni standard da usare. Questo metodo viene utilizzato per mettere in evidenza quanto variano i valori delle feature dal valore medio; è meglio quando viene utilizzato sui dati distribuiti normalmente.",
	"@@Stretch_Output-Maximum_tag0@@": "Impostare il valore di pixel più alto per l'istogramma.",
	"@@Stretch_Output-Maximum_tag1@@": "L'<strong>Output minimo</strong> e l'<strong>Output massimo</strong> imposteranno l'intervallo di valori che sarà esteso linearmente in contrasto.",
	"@@Stretch_Output-Minimum_tag0@@": "Impostare il valore di pixel più basso per l'istogramma.",
	"@@Stretch_Output-Minimum_tag1@@": "L'<strong>Output minimo</strong> e l'<strong>Output massimo</strong> imposteranno l'intervallo di valori che sarà esteso linearmente in contrasto.",
	"@@Stretch_Percent-Clip-Maximum_tag0@@": "Specificare la percentuale di valori alti da escludere dall'estensione.",
	"@@Stretch_Percent-Clip-Maximum_tag1@@": "I valori validi sono compresi tra 0 e 99.",
	"@@Stretch_Percent-Clip-Minimum_tag0@@": "Specificare la percentuale dei valori bassi da escludere dall'estensione.",
	"@@Stretch_Percent-Clip-Minimum_tag1@@": "I valori validi sono compresi tra 0 e 99.",
	"@@Stretch_Raster_tag0@@": "Il raster di input da estendere in contrasto.",
	"@@Stretch_Sigmoid-Strength-Level_tag0@@": "Il <strong>Livello di forza</strong> determina quanta funzione sigmoidale verrà utilizzata nell'estensione. Un valore basso come 1 utilizzerà solo la porzione media della curva, e ciò produrrà colori tenui e spenti. Un valore alto come 6 utilizzerà l'intera curva, e ciò produrrà colori nitidi e vivaci.",
	"@@Stretch_Statistics_tag0@@": "È possibile inserire le proprie statistiche nella finestra di dialogo. Per impostazione predefinita, le statistiche provengono dai dati; tuttavia, qualsiasi valore inserito in questo parametro verrà utilizzato al loro posto.",
	"@@Stretch_Type_tag0@@": "Scegliere il metodo del tipo di estensione:",
	"@@Stretch_Type_tag1@@": "Nessuno: nessuna estensione di contrasto",
	"@@Stretch_Type_tag2@@": "StdDev: estensione di contrasto standard",
	"@@Stretch_Type_tag3@@": "MinMax: estensione minima-massima",
	"@@Stretch_Type_tag4@@": "PercentMinMax: estensione taglio percentuale",
	"@@Stretch_Type_tag5@@": "Sigmoid: estensione sigmoidale",
	"@@Stretch_Use-Gamma_tag0@@": "Selezionare la casella di controllo <strong>Usa gamma</strong> se si desidera applicare un'estensione gamma.",
	"@@Swath_Cellsize_tag0@@": "La dimensione delle celle per il raster di output sarà automaticamente rilevata; tuttavia, è possibile cambiarla se lo si desidera. È possibile cambiare la dimensione delle celle, ma l'estensione del raster dataset rimarrà lo stesso.",
	"@@Swath_Interpolation-Method_tag0@@": "Ci sono quattro metodi di ricampionamento per questa funzione:",
	"@@Swath_Interpolation-Method_tag1@@": "<strong>Vicino più prossimo</strong>: calcola il valore dei pixel usando il pixel più vicino. Se non esiste nessun pixel di origine, non è possibile creare nessun pixel nuovo nell'output.",
	"@@Swath_Interpolation-Method_tag3@@": "<strong>Bilineare</strong>: calcola il valore di pixel usando il valore verificato a distanza dei quattro pixel più vicini.",
	"@@Swath_Interpolation-Method_tag5@@": "<strong>Rivestimento lineare</strong>: usa una rete irregolare triangolata dai punti centrali di ogni cella del raster irregolare per interpolare una superficie che viene quindi convertita in un raster regolare.",
	"@@Swath_Interpolation-Method_tag7@@": "<strong>Vicino naturale</strong>: esegue un'assegnazione del vicino più prossimo, è il più veloce dei metodi di interpolazione. Viene utilizzato principalmente per dati discreti, ad esempio una classificazione di utilizzo del suolo, poiché non cambia i valori delle celle. L'errore spaziale massimo sarà metà della dimensione della cella.",
	"@@Swath_Raster_tag0@@": "Il raster con griglia irregolare da ricampionare.",
	"@@Tan_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Tan_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Tan_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Tan_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Tan_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Tan_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Tan_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Tan_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Tan_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Tan_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Tan_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Tan_Raster_tag0@@": "L'input per il quale calcolare i valori di tangente.",
	"@@TanH_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@TanH_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@TanH_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@TanH_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@TanH_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@TanH_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@TanH_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@TanH_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@TanH_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@TanH_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@TanH_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@TanH_Raster_tag0@@": "L'input per il quale calcolare i valori di tangente iperbolica.",
	"@@Tasseled-Cap_Raster_tag0@@": "Raster di input su cui eseguire la trasformazione Tasseled Cap.",
	"@@Times_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Times_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Times_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Times_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Times_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Times_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Times_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Times_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Times_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Times_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Times_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Times_Raster_tag0@@": "L'input che contiene i valori da moltiplicare.",
	"@@Times_Raster_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Times_Raster2_tag0@@": "L'input che contiene i valori per i quali verrà moltiplicato il primo input.",
	"@@Times_Raster2_tag1@@": "È possibile usare un valore costante come input per questo parametro, purché sia specificato un raster per l'altro parametro.",
	"@@Transpose-Bits_Bit-Pattern_tag0@@": "Scegliere il tipo di trasposizione da eseguire o specificare una trasposizione personalizzata:",
	"@@Transpose-Bits_Bit-Pattern_tag1@@": "Landsat 8 - Cirro",
	"@@Transpose-Bits_Bit-Pattern_tag2@@": "Landsat 8 - Nuvola",
	"@@Transpose-Bits_Bit-Pattern_tag3@@": "Landsat 8 - Ombra nuvola",
	"@@Transpose-Bits_Bit-Pattern_tag4@@": "Landsat 8 - Riempimento designato",
	"@@Transpose-Bits_Bit-Pattern_tag5@@": "Landsat 8 - Fotogramma eliminato",
	"@@Transpose-Bits_Bit-Pattern_tag6@@": "Landsat 8 - Neve/Ghiaccio",
	"@@Transpose-Bits_Bit-Pattern_tag7@@": "Landsat 8 - Occlusione terreno",
	"@@Transpose-Bits_Bit-Pattern_tag8@@": "Landsat 8 - Vegetazione",
	"@@Transpose-Bits_Bit-Pattern_tag9@@": "Landsat 8 - Acqua",
	"@@Transpose-Bits_Bit-Pattern_tag10@@": "Definito dall'utente",
	"@@Transpose-Bits_Constant-Value_tag0@@": "Un valore opzionale che verrà utilizzato per riempire tutti i vuoti non inclusi nella trasposizione. Questo parametro è esposto quando il parametro <strong>Genera raster di riempimento da costante</strong> è impostato su <strong>Sì</strong>.",
	"@@Transpose-Bits_Fill-Raster_tag0@@": "Specificare un dataset raster che verrà utilizzato per riempire tutti i vuoti non inclusi nella trasposizione. Questo parametro è esposto quando il parametro <strong>Genera raster di riempimento da costante</strong> è impostato su <strong>No</strong>.",
	"@@Transpose-Bits_Generate-Fill-Raster-from-Constant_tag0@@": "Generare un raster di riempimento utilizzando un valore costante:",
	"@@Transpose-Bits_Generate-Fill-Raster-from-Constant_tag1@@": "<strong>Sì</strong>: verrà generato un raster utilizzando un valore costante per riempire i vuoti non coinvolti nella trasposizione. Questa è l'impostazione predefinita.",
	"@@Transpose-Bits_Generate-Fill-Raster-from-Constant_tag3@@": "<strong>No</strong>: verrà generato un raster utilizzando i valori di pixel provenienti da un dataset raster esistente per riempire i vuoti non coinvolti nella trasposizione.",
	"@@Transpose-Bits_Output-Bit-and-Input-Bit_tag0@@": "Una tabella di sola lettura che mostra i vuoti di output e gli input che li sostituiranno.",
	"@@Transpose-Bits_Raster_tag0@@": "Il raster di input da spacchettare e rimappare.",
	"@@Unit-Conversion_From-Unit_tag0@@": "Il tipo di unità originale dei pixel.",
	"@@Unit-Conversion_Raster_tag0@@": "Il raster di input che conterrà le unità convertite.",
	"@@Unit-Conversion_To-Unit_tag0@@": "Il tipo di unità convertite dei pixel.",
	"@@Vector-Field_Angle-Reference-System_tag0@@": "Specifica com'è stato misurato il componente della direzione.",
	"@@Vector-Field_Angle-Reference-System_tag1@@": "Geografico: 0° punti a Nord e 90° punti a Est",
	"@@Vector-Field_Angle-Reference-System_tag2@@": "Aritmetico: 0° punti a Est e 90° punti a Nord",
	"@@Vector-Field_Input-Data-Type_tag0@@": "Il tipo di campo vettoriale rappresentato dagli input.",
	"@@Vector-Field_Input-Data-Type_tag1@@": "Sconosciuto: è sconosciuto se gli input rappresentano U-V o Magnitudo-Direzione.",
	"@@Vector-Field_Input-Data-Type_tag2@@": "U-V: i dati di input rappresentano i componenti U e V.",
	"@@Vector-Field_Input-Data-Type_tag3@@": "Magnitudo-Direzione: i dati di input rappresentano la magnitudo e la direzione.",
	"@@Vector-Field_Output-Data-Type_tag0@@": "Specifica il tipo di campo vettoriale rappresentato dall'output.",
	"@@Vector-Field_Output-Data-Type_tag1@@": "Magnitudo-Direzione: i dati di output rappresentano la magnitudo e la direzione.",
	"@@Vector-Field_Output-Data-Type_tag2@@": "U-V: i dati di output rappresentano i componenti U e V.",
	"@@Vector-Field_Raster1_tag0@@": "Il primo raster di input.",
	"@@Vector-Field_Raster1_tag1@@": "Sarà il valore U o la magnitudo.",
	"@@Vector-Field_Raster2_tag0@@": "Il secondo raster di input.",
	"@@Vector-Field_Raster2_tag1@@": "Sarà il valore V o la direzione.",
	"@@Viewshed_Analysis-Method_tag0@@": "Scegliere il metodo secondo il quale verrà calcolata la visibilità. Questa opzione consente di ottenere precisione per una performance aumentata.",
	"@@Viewshed_Analysis-Method_tag1@@": "Tutte le linee di vista: una linea di vista viene eseguita su ogni pixel nel raster per stabilire le aree visibili. Questo è il metodo predefinito.",
	"@@Viewshed_Analysis-Method_tag2@@": "Linee di vista perimetrali: le linee di vista vengono eseguite solo sui pixel del perimetro delle aree visibili per stabilire le aree visibili. Questo metodo presenta delle prestazioni migliori rispetto al metodo <strong>Tutte le linee di vista</strong> perché ci sono meno linee di vista nel calcolo.",
	"@@Viewshed_Analysis-Type_tag0@@": "Scegliere quale tipo di analisi di visibilità si vuole eseguire, determinando quanto è visibile una cella per i punti di osservazione o identificando per ogni posizione di superficie quali sono gli osservatori visibili.",
	"@@Viewshed_Analysis-Type_tag1@@": "Frequenza: il numero di volte che ogni posizione di pixel nel raster di superficie di input può essere visto dalle posizioni di punti di osservazione di input (come punti o come vertici per le feature di punti di osservazione polilineare). Questa è l'impostazione predefinita.",
	"@@Viewshed_Analysis-Type_tag2@@": "Punti di osservazione: l'input identifica esattamente quali sono i punti di osservazione visibili da ogni posizione di superficie raster. Con questo tipo di analisi il numero massimo consentito di punti di osservazione di input è 32.",
	"@@Viewshed_Horizontal-End-Angle_tag0@@": "Questo valore definisce l'angolo finale dell'intervallo di scansione orizzontale. Il valore dovrebbe essere specificato in gradi da 0 a 360,0, in cui lo 0 è orientato a Nord. Il valore predefinito è 360,0.",
	"@@Viewshed_Horizontal-End-Angle_tag1@@": "Può essere un campo nel dataset <strong>Feature osservatori</strong> di input o un valore numerico. Se questo parametro è impostato su un valore, quel valore sarà applicato a tutti gli osservatori. Per specificare valori diversi per ogni osservatore, impostare questo parametro su un campo nel dataset <strong>Feature osservatori</strong>.",
	"@@Viewshed_Horizontal-Start-Angle_tag0@@": "Questo valore definisce l'angolo iniziale dell'intervallo di scansione orizzontale. Il valore dovrebbe essere specificato in gradi da 0 a 360,0, in cui lo 0 è orientato a Nord. Il valore predefinito è 0.",
	"@@Viewshed_Horizontal-Start-Angle_tag1@@": "Può essere un campo nel dataset <strong>Feature osservatori</strong> di input o un valore numerico. Se questo parametro è impostato su un valore, quel valore sarà applicato a tutti gli osservatori. Per specificare valori diversi per ogni osservatore, impostare questo parametro su un campo nel dataset <strong>Feature osservatori</strong>.",
	"@@Viewshed_Inner-Radius-is-3D-Distance_tag0@@": "Il tipo di distanza per il parametro del raggio interno.",
	"@@Viewshed_Inner-Radius-is-3D-Distance_tag1@@": "Non selezionato: <strong>Raggio interno</strong> deve essere interpretato come una distanza 2D. Questa è l'impostazione predefinita.",
	"@@Viewshed_Inner-Radius-is-3D-Distance_tag4@@": "Selezionato: <strong>Raggio interno</strong> deve essere interpretato come una distanza 3D.",
	"@@Viewshed_Inner-Radius_tag0@@": "Questo valore definisce la distanza iniziale (minima) da cui viene determinata la visibilità. I pixel più vicini a questa distanza sono considerati non visibili nell'output ma possono comunque bloccare la visibilità dei pixel tra <strong>Raggio interno</strong> e <strong>Raggio esterno</strong>. Il valore predefinito è 0.",
	"@@Viewshed_Inner-Radius_tag5@@": "Può essere un campo nel dataset <strong>Feature osservatori</strong> di input o un valore numerico. Se questo parametro è impostato su un valore, quel valore sarà applicato a tutti gli osservatori. Per specificare valori diversi per ogni osservatore, impostare questo parametro su un campo nel dataset <strong>Feature osservatori</strong>.",
	"@@Viewshed_Observer-Elevation_tag0@@": "Questo valore viene utilizzato per definire le elevazioni della superficie dei punti o dei vertici dell'osservatore.",
	"@@Viewshed_Observer-Elevation_tag1@@": "Può essere un campo nel dataset <strong>Feature osservatori</strong> di input o un valore numerico. Se questo parametro non è specificato, l'elevazione del punto di osservazione sarà ottenuta dal raster di superficie utilizzando un'interpolazione bilineare. Se questo parametro è impostato su un valore, quel valore sarà applicato a tutti i punti di osservazione. Per specificare valori diversi per ogni osservatore, impostare questo parametro su un campo nel dataset <strong>Feature osservatori</strong>.",
	"@@Viewshed_Observer-Features_tag0@@": "La feature class di input obbligatoria che identifica le posizioni del punto di osservazione. Si può trattare di feature puntuali, multipuntuali o polilineari.",
	"@@Viewshed_Observer-Features_tag1@@": "La feature class di input viene trasformata in un sistema di coordinate geocentrico 3D durante il calcolo della visibilità. I punti di osservazione all'esterno dell'estensione del raster di superficie o posizionati nelle celle NoData verranno ignorati nel calcolo.",
	"@@Viewshed_Observer-Offset_tag0@@": "Questo valore indica una distanza verticale (nelle unità di superficie) da aggiungere all'elevazione del punto di osservazione. Deve essere un numero intero positivo o un valore a virgola mobile.",
	"@@Viewshed_Observer-Offset_tag1@@": "Può essere un campo nel dataset <strong>Feature osservatori</strong> di input o un valore numerico. Se questo parametro è impostato su un valore, quel valore sarà applicato a tutti gli osservatori. Per specificare valori diversi per ogni osservatore, impostare questo parametro su un campo nel dataset <strong>Feature osservatori</strong>.",
	"@@Viewshed_Outer-Radius-is-3D-Distance_tag0@@": "Il tipo di distanza per il parametro del raggio esterno.",
	"@@Viewshed_Outer-Radius-is-3D-Distance_tag1@@": "Non selezionato: <strong>Raggio esterno</strong> deve essere interpretato come una distanza 2D. Questa è l'impostazione predefinita.",
	"@@Viewshed_Outer-Radius-is-3D-Distance_tag4@@": "Selezionato: <strong>Raggio esterno</strong> deve essere interpretato come una distanza 3D.",
	"@@Viewshed_Outer-Radius_tag0@@": "Questo valore definisce la distanza massima da cui viene determinata la visibilità. I pixel oltre questa distanza vengono esclusi dall'analisi.",
	"@@Viewshed_Outer-Radius_tag1@@": "Può essere un campo nel dataset <strong>Feature osservatori</strong> di input o un valore numerico. Se questo parametro è impostato su un valore, quel valore sarà applicato a tutti gli osservatori. Per specificare valori diversi per ogni osservatore, impostare questo parametro su un campo nel dataset <strong>Feature osservatori</strong>.",
	"@@Viewshed_Raster_tag0@@": "Il raster di superficie di input obbligatorio. Può essere un numero intero o un raster a virgola mobile.",
	"@@Viewshed_Raster_tag1@@": "L'input viene trasformato in un sistema di coordinate geocentrico 3D durante il calcolo della visibilità. Le celle NoData del raster di input non bloccano la determinazione della visibilità.",
	"@@Viewshed_Refractive-Coefficient_tag0@@": "Coefficiente di refrattività della luce visibile nell'aria.",
	"@@Viewshed_Refractive-Coefficient_tag1@@": "Il valore predefinito è 0,13.",
	"@@Viewshed_Surface-Offset_tag0@@": "Questo valore indica una distanza verticale (nelle unità di superficie) da aggiungere al valore z di ogni pixel di target così come è considerata per la visibilità. Deve essere un numero intero positivo o un valore a virgola mobile.",
	"@@Viewshed_Surface-Offset_tag1@@": "Può essere un campo nel dataset <strong>Feature osservatori</strong> di input o un valore numerico. Se questo parametro è impostato su un valore, quel valore sarà applicato a tutti gli osservatori. Per specificare valori diversi per ogni osservatore, impostare questo parametro su un campo nel dataset <strong>Feature osservatori</strong>.",
	"@@Viewshed_Vertical-Error_tag0@@": "La quantità di incertezza, misurata tramite l'errore quadrato media radice (RMSE), nei valori di elevazione della superficie. Si tratta di un valore a virgola mobile che rappresenta l'errore previsto dei valori di elevazione di input. Quando a questo parametro viene assegnato un valore maggiore di 0, il raster di visibilità di output sarà una virgola mobile. In tal caso, ogni valore di pixel nel raster di visibilità di output rappresenta la somma delle probabilità che quella cella sia visibile a qualsiasi dei punti di osservazione.",
	"@@Viewshed_Vertical-Error_tag1@@": "Quando il <strong>Tipo di analisi</strong> è <strong>Osservatori</strong> o il <strong>Metodo di analisi</strong> è <strong>Linee di vista perimetrali</strong>, questo parametro è disabilitato.",
	"@@Viewshed_Vertical-Lower-Angle_tag0@@": "Questo valore definisce il limite dell'angolo verticale inferiore della scansione sotto un piano orizzontale. Il valore deve essere specificato in gradi da -90,0 a 0, come numero intero o a virgola mobile. Il valore predefinito è -90,0.",
	"@@Viewshed_Vertical-Lower-Angle_tag1@@": "Può essere un campo nel dataset <strong>Feature osservatori</strong> di input o un valore numerico. Se questo parametro è impostato su un valore, quel valore sarà applicato a tutti gli osservatori. Per specificare valori diversi per ogni osservatore, impostare questo parametro su un campo nel dataset <strong>Feature osservatori</strong>.",
	"@@Viewshed_Vertical-Upper-Angle_tag0@@": "Questo valore definisce il limite dell'angolo verticale superiore della scansione sopra un piano orizzontale. Il valore deve essere specificato in gradi da 0 a 90,0, come numero intero o a virgola mobile. Il valore predefinito è 90,0.",
	"@@Viewshed_Vertical-Upper-Angle_tag1@@": "Può essere un campo nel dataset <strong>Feature osservatori</strong> di input o un valore numerico. Se questo parametro è impostato su un valore, quel valore sarà applicato a tutti gli osservatori. Per specificare valori diversi per ogni osservatore, impostare questo parametro su un campo nel dataset <strong>Feature osservatori</strong>.",
	"@@Watershed_Flow-Direction-Raster_tag0@@": "Il raster di input che mostra la direzione del flusso fuori da ogni cella.",
	"@@Watershed_Flow-Direction-Raster_tag1@@": "Il raster di direzione del flusso può essere creato eseguendo la funzione <strong>Direzione flusso</strong>.",
	"@@Watershed_Pour-Point(s)-Raster_tag0@@": "Le posizioni del punto di versamento di input.",
	"@@Watershed_Pour-Point(s)-Raster_tag1@@": "Questo raster rappresenta le celle oltre le quali verranno determinate l'area o il bacino pluviale di contribuzione. Tutte le celle che non sono NoData verranno utilizzate come celle di origine.",
	"@@Watershed_Pour-Point-Field_tag0@@": "Il campo usato per assegnare valori alle posizioni del punto di versamento.",
	"@@Watershed_Pour-Point-Field_tag1@@": "Per un dataset di punti di versamento raster, ${Value} viene utilizzato come valore predefinito.",
	"@@Weighted-Overlay_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Weighted-Overlay_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Weighted-Overlay_Cellsize-Type_tag2@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Weighted-Overlay_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Weighted-Overlay_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Weighted-Overlay_Cellsize-Type_tag5@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Weighted-Overlay_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Weighted-Overlay_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Weighted-Overlay_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Weighted-Overlay_Extent-Type_tag3@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Weighted-Overlay_Extent-Type_tag4@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Weighted-Overlay_Scales_tag0@@": "L'intervallo per i nuovi valori secondo i quali rimappare i valori precedenti.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag0@@": "La tabella di overlay ponderata è formata da quattro parti:",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag1@@": "Layer: tutti i raster di input devono essere di tipo intero.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag2@@": "Influenza: ogni raster di input viene ponderato secondo la sua importanza, o la sua influenza, come percentuale relativa. La somma delle ponderazioni di influenza in percentuale deve essere uguale a 100, e ogni ponderazione deve essere specificata da valori interi.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag3@@": "Campo: un campo intero o stringa nel raster di input utilizzato per la ponderazione.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag4@@": "Tabella di rimappatura: a ogni valore di un raster di input viene assegnato un nuovo valore di scala basato sulla tabella di rimappatura. Il valore di scala può essere un valore valido o un valore NoData.",
	"@@Weighted-Sum_Cellsize-Type_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Weighted-Sum_Cellsize-Type_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Weighted-Sum_Cellsize-Type_tag2@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Weighted-Sum_Cellsize-Type_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Weighted-Sum_Cellsize-Type_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Weighted-Sum_Cellsize-Type_tag5@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Weighted-Sum_Extent-Type_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Weighted-Sum_Extent-Type_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Weighted-Sum_Extent-Type_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Weighted-Sum_Extent-Type_tag3@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Weighted-Sum_Extent-Type_tag4@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Weighted-Sum_Weighted-Sum-Table_tag0@@": "La tabella di somme ponderate è definita da tre proprietà:",
	"@@Weighted-Sum_Weighted-Sum-Table_tag1@@": "Layer: il raster da ponderare.",
	"@@Weighted-Sum_Weighted-Sum-Table_tag2@@": "Campo: il campo del raster da usare per la ponderazione.",
	"@@Weighted-Sum_Weighted-Sum-Table_tag3@@": "Ponderazione: il valore di ponderazione per il quale moltiplicare il raster. Può essere un valore decimale positivo o negativo.",
	"@@Wind-Chill_Temperature-Raster_tag0@@": "Un raster a banda singola in cui i valori di pixel rappresentano la temperatura dell'aria di ambiente.",
	"@@Wind-Chill_Temperature-Units_tag0@@": "L'unità di misura associata al raster di temperatura di input. Le unità di input disponibili sono Celsius, Fahrenheit e Kelvin.",
	"@@Wind-Chill_Wind-Chill-Units_tag0@@": "L'unità di misura associata con il raster di output. Le unità di output disponibili sono Celsius, Fahrenheit e Kelvin.",
	"@@Wind-Chill_Wind-Speed-Raster_tag0@@": "Un raster a banda singola in cui i valori di pixel rappresentano la velocità del vento.",
	"@@Wind-Chill_Wind-Speed-Units_tag0@@": "Definisce l'unità di misura per il raster velocità del vento:",
	"@@Wind-Chill_Wind-Speed-Units_tag1@@": "Miglia all'ora (mph)",
	"@@Wind-Chill_Wind-Speed-Units_tag2@@": "Chilometri all'ora (km/h)",
	"@@Wind-Chill_Wind-Speed-Units_tag3@@": "Metri al secondo (m/s)",
	"@@Wind-Chill_Wind-Speed-Units_tag4@@": "Piedi al secondo (ft/s)",
	"@@Wind-Chill_Wind-Speed-Units_tag5@@": "Nodi (kn)",
	"@@Zonal-Remap_Background-Value_tag0@@": "Il valore iniziale di pixel del raster di output, prima del ricalcolo dei pixel di input.",
	"@@Zonal-Remap_Default-Output-Value_tag0@@": "Il valore che sarà assegnato a un pixel che non soddisfa nessuna delle condizioni impostate nella <strong>Tabella attributi zonali</strong>.",
	"@@Zonal-Remap_Default-Output-Value_tag3@@": "Questo sarà anche il valore del pixel di output se il parametro <strong>Nome campo valore di output</strong> non viene specificato o se il valore di output della soglia zonale corrispondente non viene specificato nella <strong>Tabella attributi zonali</strong>.",
	"@@Zonal-Remap_Maximum-Value-Field-Name_tag0@@": "Il nome del campo contenente il valore massimo al di sotto del quale un pixel di input viene rimappato.",
	"@@Zonal-Remap_Maximum-Value-Field-Name_tag1@@": "Se non è specificato, o se il valore del campo è nullo, i valori pixel non vengono testati per il massimo.",
	"@@Zonal-Remap_Minimum-Value-Field-Name_tag0@@": "Il nome del campo contenente il valore minimo al di sopra del quale un pixel di input viene rimappato.",
	"@@Zonal-Remap_Minimum-Value-Field-Name_tag1@@": "Se non è specificato, o se il valore del campo è nullo, i valori pixel non vengono testati per il minimo.",
	"@@Zonal-Remap_Output-Value-Field-Name_tag0@@": "Il nome del campo contenente il valore target in base al quale un pixel di input viene rimappato.",
	"@@Zonal-Remap_Output-Value-Field-Name_tag1@@": "Se non è specificato, o se il valore del campo è nullo, i valori di pixel rimappati vengono impostati con il <strong>Valore di output predefinito</strong>.",
	"@@Zonal-Remap_Value-Raster_tag0@@": "Un raster a banda singola obbligatorio di input contenente i valori di pixel da rimappare.",
	"@@Zonal-Remap_Where-Clause_tag0@@": "Un'interrogazione opzionale applicata nella <strong>Tabella attributi zonali</strong>.",
	"@@Zonal-Remap_Where-Clause_tag3@@": "Se si è usata la tabella precedente come esempio, l'interrogazione sarebbe ${Variable1 = 'bare earth' AND Variable2 = 'California'}.",
	"@@Zonal-Remap_Zonal-Attributes-Table_tag0@@": "Una tabella di input obbligatoria contenente almeno tre campi. Deve presentare un valore di soglia minimo, un valore di soglia massimo e un valore target. Il valore target è il campo che contiene il valore ricalcolato.",
	"@@Zonal-Remap_Zonal-Attributes-Table_tag1@@": "Il formato del file può essere una feature class, un feature service o qualunque tipo di tabella supportato da ArcGIS.",
	"@@Zonal-Remap_Zone-Field_tag0@@": "Il nome del campo all'interno della <strong>Tabella attributi zonali</strong> che contiene i valori ID di zona.",
	"@@Zonal-Remap_Zone-Field_tag3@@": "I valori ID di zona direttamente legati agli ID di zona nel raster di zone. Forniscono un altro livello di filtraggio durante il ricalcolo. Se non c'è nessun ID di zona associato ad un record specifico nella tabella, questo non interverrà nel ricalcolo.",
	"@@Zonal-Remap_Zone-Raster_tag0@@": "Un raster a banda singola in cui ogni pixel definisce zone associate ad una posizione specifica. Una zona viene definita come tutte le aree nell'input che hanno lo stesso valore. Le aree non devono essere contigue.",
	"@@Predict-Using-Trend_dimensiondefinition_tag0@@": "Specifica il metodo utilizzato per fornire valori di dimensione sulle previsioni.",
	"@@Predict-Using-Trend_dimensiondefinition_tag1@@": "<strong>Per valore</strong>: la previsione sarà calcolata per un singolo valore di dimensione. Ad esempio, si desidera prevedere la precipitazione annuale per gli anni 2050, 2100 e 2150. Questa è l'impostazione predefinita.",
	"@@Predict-Using-Trend_dimensiondefinition_tag2@@": "<strong>Per intervallo</strong>: la previsione sarà calcolata per un intervallo della dimensione definita da un valore di inizio e uno di fine. Ad esempio, si desidera prevedere la precipitazione annuale per ogni anno compreso tra il 2050 e il 2150.",
	"@@Predict-Using-Trend_end_tag0@@": "La data, l'altezza o la profondità finale dell'intervallo della dimensione da usare nella previsione.",
	"@@Predict-Using-Trend_end_tag1@@": "Questo parametro è richiesto quando il parametro <strong>Definizione dimensione</strong> è impostato su <strong>Per intervallo</strong>.",
	"@@Predict-Using-Trend_raster_tag0@@": "Il raster di tendenza multidimensionale di input dalla funzione <strong>Genera tendenza</strong>.",
	"@@Predict-Using-Trend_start_tag0@@": "La data, l'altezza o la profondità iniziale dell'intervallo della dimensione da usare nella previsione.",
	"@@Predict-Using-Trend_start_tag1@@": "Questo parametro è richiesto quando il parametro <strong>Definizione dimensione</strong> è impostato su <strong>Per intervallo</strong>.",
	"@@Predict-Using-Trend_unit_tag0@@": "L'unità che verrà utilizzata per l'intervallo dei valori. Questo parametro si applica solo quando la dimensione dell'analisi è una dimensione temporale.",
	"@@Predict-Using-Trend_unit_tag1@@": "<strong>Ore</strong>: la previsione sarà calcolata per ciascuna ora all'interno dell'intervallo di tempo descritto dai parametri <strong>Inizio</strong>, <strong>Fine</strong> e <strong>Intervallo di valori</strong>.",
	"@@Predict-Using-Trend_unit_tag2@@": "<strong>Giorni</strong>: la previsione sarà calcolata per ciascun giorno all'interno dell'intervallo di tempo descritto dai parametri <strong>Inizio</strong>, <strong>Fine</strong> e <strong>Intervallo di valori</strong>.",
	"@@Predict-Using-Trend_unit_tag3@@": "<strong>Settimane</strong>: la previsione sarà calcolata per ciascuna settimana all'interno dell'intervallo di tempo descritto dai parametri <strong>Inizio</strong>, <strong>Fine</strong> e <strong>Intervallo di valori</strong>.",
	"@@Predict-Using-Trend_unit_tag4@@": "<strong>Mesi</strong>: la previsione sarà calcolata per ciascun mese all'interno dell'intervallo di tempo descritto dai parametri <strong>Inizio</strong>, <strong>Fine</strong> e <strong>Intervallo di valori</strong>.",
	"@@Predict-Using-Trend_unit_tag5@@": "<strong>Anni</strong>: la previsione sarà calcolata per ciascun anno all'interno dell'intervallo di tempo descritto dai parametri <strong>Inizio</strong>, <strong>Fine</strong> e <strong>Intervallo di valori</strong>.",
	"@@Predict-Using-Trend_valueinterval_tag0@@": "Il numero di passaggi tra due valori di dimensione da includere nella previsione. Il valore predefinito è 1.",
	"@@Predict-Using-Trend_valueinterval_tag1@@": "Questo parametro è richiesto quando il parametro <strong>Definizione dimensione</strong> è impostato su <strong>Per intervallo</strong>.",
	"@@Predict-Using-Trend_values_tag0@@": "Il valore o i valori di dimensione da utilizzare nella previsione.",
	"@@Predict-Using-Trend_values_tag1@@": "Il formato dei valori di tempo, profondità e altezza deve corrispondere al formato dei valori di dimensione utilizzati per generare il raster di tendenza. Se il raster di tendenza è stato generato per la dimensione StdTime, il formato deve essere AAAA-MM-GGTHH:MM:SS, es. 2050-01-01T00:00:00. Più valori sono separati con un punto e virgola.",
	"@@Process-Raster-Collection_aggregationfunction_tag0@@": "Specificare il modello di funzione raster utilizzato per aggregare più sezioni in un numero inferiore di sezioni o in un'unica sezione.",
	"@@Process-Raster-Collection_dimension_tag0@@": "Dimensione di aggregazione. Questa è la dimensione lungo la quale verranno aggregate le variabili.",
	"@@Process-Raster-Collection_itemfunction_tag0@@": "Specificare il modello di funzione raster utilizzato per elaborare ciascuna sezione o elemento nella raccolta raster di input.",
	"@@Process-Raster-Collection_keywordinterval_tag0@@": "Specifica l'intervallo di parole chiave che verrà utilizzato durante l'aggregazione lungo la dimensione. Questo parametro è obbligatorio quando <strong>Tipo</strong> è impostato su <strong>Parola chiave di intervallo</strong> e l'aggregazione deve essere nel tempo.",
	"@@Process-Raster-Collection_keywordinterval_tag1@@": "<strong>Ogni ora</strong>: i valori dei dati verranno aggregati in intervalli temporali orari e il risultato includerà ogni ora nelle serie temporali.",
	"@@Process-Raster-Collection_keywordinterval_tag2@@": "<strong>Ogni giorno</strong>: i valori dei dati verranno aggregati in intervalli temporali giornalieri e il risultato includerà ogni giorno nelle serie temporali.",
	"@@Process-Raster-Collection_keywordinterval_tag3@@": "<strong>Ogni settimana</strong>: i valori dei dati verranno aggregati in intervalli temporali settimanali e il risultato includerà ogni settimana nelle serie temporali.",
	"@@Process-Raster-Collection_keywordinterval_tag4@@": "<strong>Ogni dieci giorni</strong>: i valori dei dati verranno aggregati in 3 periodi di 10 giorni ciascuno. L'ultimo periodo potrebbe contenere più o meno di 10 giorni. L'output includerà 3 periodi per ogni mese.",
	"@@Process-Raster-Collection_keywordinterval_tag5@@": "<strong>Ogni cinque giorni</strong>: i valori dei dati verranno aggregati in 6 periodi di 5 giorni ciascuno. L'ultimo periodo potrebbe contenere più o meno di 5 giorni. L'output includerà 6 periodi per ogni mese.",
	"@@Process-Raster-Collection_keywordinterval_tag6@@": "<strong>Ogni mese</strong>: i valori dei dati verranno aggregati in intervalli temporali mensili e il risultato includerà ogni mese nelle serie temporali.",
	"@@Process-Raster-Collection_keywordinterval_tag7@@": "<strong>Ogni trimestre</strong>: i valori dei dati verranno aggregati in intervalli temporali trimestrali e il risultato includerà ogni trimestre nelle serie temporali.",
	"@@Process-Raster-Collection_keywordinterval_tag8@@": "<strong>Ogni anno</strong>: i valori dei dati verranno aggregati in intervalli temporali annuali e il risultato includerà ogni anno nelle serie temporali.",
	"@@Process-Raster-Collection_keywordinterval_tag9@@": "<strong>Ricorrenza giornaliera</strong>: i valori dei dati verranno aggregati in intervalli temporali giornalieri e il risultato includerà un valore aggregato per giorno giuliano. L'output includerà al massimo 366 periodi di tempo giornalieri.",
	"@@Process-Raster-Collection_keywordinterval_tag10@@": "<strong>Ricorrenza settimanale</strong>: i valori dei dati verranno aggregati in intervalli temporali settimanali e il risultato includerà un valore aggregato per settimana. L'output includerà al massimo 53 periodi di tempo settimanali.",
	"@@Process-Raster-Collection_keywordinterval_tag11@@": "<strong>Ricorrenza mensile</strong>: i valori dei dati verranno aggregati in intervalli temporali mensili e il risultato includerà un valore aggregato per mese. L'output includerà al massimo 12 periodi di tempo mensili.",
	"@@Process-Raster-Collection_keywordinterval_tag12@@": "<strong>Ricorrenza trimestrale</strong>: i valori dei dati verranno aggregati in intervalli temporali trimestrali e il risultato includerà un valore aggregato per trimestre. L'output includerà al massimo 4 periodi di tempo trimestrali.",
	"@@Process-Raster-Collection_maximumvalue_tag0@@": "Il valore massimo per un intervallo.",
	"@@Process-Raster-Collection_maximumvalue_tag1@@": "Questo parametro è richiesto quando il parametro <strong>Tipo</strong> è impostato su <strong>Gamme di intervalli</strong>.",
	"@@Process-Raster-Collection_minimumvalue_tag0@@": "Il valore minimo per un intervallo.",
	"@@Process-Raster-Collection_minimumvalue_tag1@@": "Questo parametro è richiesto quando il parametro <strong>Tipo</strong> è impostato su <strong>Gamme di intervalli</strong>.",
	"@@Process-Raster-Collection_processingfunction_tag0@@": "Specificare il modello di funzione raster utilizzato per visualizzare il layer raster elaborato.",
	"@@Process-Raster-Collection_rastercollection_tag0@@": "Il raster multidimensionale di input, il layer mosaico o il dataset mosaico.",
	"@@Process-Raster-Collection_type_tag0@@": "Specifica l'intervallo di dimensione per il quale verranno aggregati i dati.",
	"@@Process-Raster-Collection_type_tag1@@": "<strong>Tutti</strong>: i valori dei dati verranno aggregati su tutte le sezioni. Questa è l'impostazione predefinita.",
	"@@Process-Raster-Collection_type_tag2@@": "<strong>Parola chiave di intervallo</strong>: i dati variabili verranno aggregati utilizzando un intervallo comunemente noto.",
	"@@Process-Raster-Collection_type_tag3@@": "<strong>Gamme di intervalli</strong>: i dati variabili verranno aggregati tra coppie specificate di valori o date.",
	"@@Process-Raster-Collection_type_tag4@@": "<strong>Valori di intervalli</strong>: i dati variabili verranno aggregati utilizzando un intervallo e un'unità specificati dall'utente.",
	"@@Process-Raster-Collection_unit_tag0@@": "L'unità che verrà utilizzata per il valore dell'intervallo. Questo parametro è obbligatorio quando la <strong>Dimensione</strong> è un campo temporale e quando il parametro <strong>Tipo</strong> è impostato su <strong>Valore di intervalli</strong>.",
	"@@Process-Raster-Collection_unit_tag1@@": "Se si aggrega qualcosa di diverso dal tempo, questa opzione non sarà disponibile e l'unità per il valore di intervallo corrisponderà all'unità variabile dei dati raster multidimensionali di input.",
	"@@Process-Raster-Collection_unit_tag2@@": "<strong>Ore</strong>: i valori dei dati verranno aggregati in periodi di tempo orari all'intervallo fornito.",
	"@@Process-Raster-Collection_unit_tag3@@": "<strong>Giorni</strong>: i valori dei dati verranno aggregati in periodi di tempo giornalieri all'intervallo fornito.",
	"@@Process-Raster-Collection_unit_tag4@@": "<strong>Settimane</strong>: i valori dei dati verranno aggregati in periodi di tempo settimanali all'intervallo fornito.",
	"@@Process-Raster-Collection_unit_tag5@@": "<strong>Mesi</strong>: i valori dei dati verranno aggregati in periodi di tempo mensili all'intervallo fornito.",
	"@@Process-Raster-Collection_unit_tag6@@": "<strong>Anni</strong>: i valori dei dati verranno aggregati in periodi di tempo annuali all'intervallo fornito.",
	"@@Process-Raster-Collection_valueinterval_tag0@@": "Dimensione dell'intervallo che verrà utilizzato per l'aggregazione. Questo parametro è richiesto quando il parametro <strong>Tipo</strong> è impostato su <strong>Valori di intervalli</strong>.",
	"@@Process-Raster-Collection_valueinterval_tag1@@": "Ad esempio, per aggregare 30 anni di dati mensili sulla temperatura in incrementi di 5 anni, immettere 5 come <strong>Intervallo di valori</strong> e specificare <strong>Unità</strong> come <strong>Anni</strong>.",
	"@@Linear-Spectral-Unmixing_non-negative_tag0@@": "Specifica le opzioni per definire i valori pixel di output.",
	"@@Linear-Spectral-Unmixing_non-negative_tag1@@": "Selezionato: non ci saranno valori di output negativi.",
	"@@Linear-Spectral-Unmixing_non-negative_tag2@@": "Non selezionato: possono esserci valori negativi della copertura del terreno frazionale.",
	"@@Linear-Spectral-Unmixing_raster_tag0@@": "Il raster di input.",
	"@@Linear-Spectral-Unmixing_spectralprofile_tag0@@": "Il file del profilo spettrale di input.",
	"@@Linear-Spectral-Unmixing_spectralprofiletype_tag0@@": "Le informazioni spettrali per le diverse classi di copertura del terreno.",
	"@@Linear-Spectral-Unmixing_spectralprofiletype_tag1@@": "<strong>Profilo spettrale</strong>: un file di definizione classificatore (${.ecd}), generato dallo strumento <strong><strong>Addestramento Classificazione di Probabilità Massima</strong></strong> o un file di notazione oggetto JavaScript (${.json}) che contiene i profili spettrali di classe.",
	"@@Linear-Spectral-Unmixing_spectralprofiletype_tag2@@": "<strong>Feature di formazione</strong>: feature poligonali o una feature class esempio di formazione, generata da <strong>Gestione Esempi di formazione</strong>.",
	"@@Linear-Spectral-Unmixing_sumtoone_tag0@@": "Specifica le opzioni per definire i valori pixel di output.",
	"@@Linear-Spectral-Unmixing_sumtoone_tag1@@": "Selezionato: i valori delle classi per ciascun pixel vengono forniti in formato decimale con la somma di tutte le classi uguale a 1. Ad esempio, Class1 = 0,16; Class2 = 0,24; Class3 = 0,60.",
	"@@Linear-Spectral-Unmixing_sumtoone_tag2@@": "Non selezionato: la somma di tutte le classi in un pixel può superare 1.",
	"@@Linear-Spectral-Unmixing_trainingfeature_tag0@@": "Il file della feature di formazione di input.",
	"@@Aggregate_aggregationtechnique_tag0@@": "Il metodo utilizzato per l'aggregazione. I valori delle celle di input racchiuse dalle celle di output più approssimative vengono aggregati da una delle seguenti statistiche:",
	"@@Aggregate_aggregationtechnique_tag1@@": "<strong>Somma</strong>: il totale delle celle di input. Questa è l'impostazione predefinita.",
	"@@Aggregate_aggregationtechnique_tag2@@": "<strong>Massimo</strong>: il valore più grande delle celle di input.",
	"@@Aggregate_aggregationtechnique_tag3@@": "<strong>Media</strong>: il valore medio delle celle di input.",
	"@@Aggregate_aggregationtechnique_tag4@@": "<strong>Mediana</strong>: il valore mediano delle celle di input.",
	"@@Aggregate_aggregationtechnique_tag5@@": "<strong>Minimo</strong>: il valore più piccolo delle celle di input.",
	"@@Aggregate_cellfactor_tag0@@": "Il fattore per il quale moltiplicare la dimensione cella del raster di input.",
	"@@Aggregate_cellfactor_tag1@@": "Ad esempio, un valore fattore cella di tre risulterebbe in una dimensione cella di output di tre volte superiore rispetto a quella del raster di input.",
	"@@Aggregate_expandextentifneeded_tag0@@": "Definisce come gestire i confini del raster di input quando le sue righe o le sue colonne non sono un multiplo del fattore di cella.",
	"@@Aggregate_expandextentifneeded_tag1@@": "Selezionato: espande i confini superiori o a destra del raster di input in modo che il numero totale di celle in una riga o colonna sia un multiplo del fattore di cella. Con questa opzione, il raster di output può coprire un'estensione spaziale più grande del raster di input. Questa è l'impostazione predefinita.",
	"@@Aggregate_expandextentifneeded_tag2@@": "Non selezionato: riduce il numero di righe o colonne nel raster di output. Questo tronca le celle rimanenti sui confini superiori o a destra del raster di input, rendendo il numero di righe o colonne nel raster di input un multiplo del fattore di cella. Con questa opzione, il raster di output può coprire un'estensione spaziale più piccola del raster di input.",
	"@@Aggregate_ignorenodataincalculations_tag0@@": "Identifica se i valori ${NoData} vengono ignorati dai calcoli di aggregazione.",
	"@@Aggregate_ignorenodataincalculations_tag1@@": "Selezionato: indica che se esistono valori ${NoData} per una qualunque delle celle che ricadono all'interno dell'estensione spaziale di una cella più grande sul raster di output, i valori ${NoData} saranno ignorati quando si stabilisce il valore per le posizioni delle celle di output. Solo le celle di input all'interno dell'estensione della cella di output che hanno valori di dati verranno utilizzati per determinare il valore della cella di output. Questa è l'impostazione predefinita.",
	"@@Aggregate_ignorenodataincalculations_tag2@@": "Non selezionato: indica che se una cella che ricade all'interno dell'estensione spaziale di una cella più grande sul raster di output presenta un valore ${NoData}, il valore per la posizione di quella cella di output sarà ${NoData}. L'utilizzo di questa opzione implica che quando le celle all'interno dell'aggregazione contengono il valore ${NoData}, non ci sono informazioni sufficienti per eseguire i calcoli specificati necessari per determinare il valore di output.",
	"@@Aggregate_raster_tag0@@": "Il raster di input da aggregare.",
	"@@Expand_numberofcells_tag0@@": "Il numero di celle per l'espansione.",
	"@@Expand_numberofcells_tag1@@": "Il valore deve essere un numero intero e può essere maggiore o uguale a 1.",
	"@@Expand_raster_tag0@@": "Il raster di input per il quale espandere le zone identificate.",
	"@@Expand_raster_tag1@@": "Deve essere di tipo numero intero.",
	"@@Expand_zonevalues_tag0@@": "L'elenco di zone da espandere.",
	"@@Expand_zonevalues_tag1@@": "I valori zona devono essere un numero intero e si possono trovare in qualunque ordine.",
	"@@Expand_zonevalues_tag2@@": "Per specificare più zone, utilizzare uno spazio per separare i valori di zona.",
	"@@Multidimensional-Filter_dimension_tag0@@": "La dimensione da cui estrarre le variabili.",
	"@@Multidimensional-Filter_dimensiondefinition_tag0@@": "Specifica il metodo che verrà utilizzato per sezionare la dimensione.",
	"@@Multidimensional-Filter_dimensiondefinition_tag1@@": "<strong>Tutti</strong>: si utilizzerà l'intervallo completo per ciascuna dimensione. Questa è l'impostazione predefinita.",
	"@@Multidimensional-Filter_dimensiondefinition_tag2@@": "<strong>Per valori</strong>: si sezionerà la dimensione utilizzando un valore della dimensione o un elenco di valori.",
	"@@Multidimensional-Filter_dimensiondefinition_tag3@@": "<strong>Per intervalli</strong>: si sezionerà la dimensione utilizzando un intervallo o un elenco di intervalli.",
	"@@Multidimensional-Filter_dimensiondefinition_tag4@@": "<strong>Per iterazione</strong>: si sezionerà la dimensione sulla dimensione di un intervallo specificato.",
	"@@Multidimensional-Filter_endoffirstiteration_tag0@@": "La fine del primo intervallo. Questo intervallo viene utilizzato per l'iterazione attraverso un dataset. Questo parametro è richiesto quando il parametro <strong>Definizione dimensione</strong> è impostato su <strong>Per iterazione</strong>.",
	"@@Multidimensional-Filter_maximumvalue_tag0@@": "Il valore massimo per l'intervallo. Questo parametro è richiesto quando il parametro <strong>Definizione dimensione</strong> è impostato su <strong>Per intervalli</strong>.",
	"@@Multidimensional-Filter_minimumvalue_tag0@@": "Il valore minimo per l'intervallo. Questo parametro è richiesto quando il parametro <strong>Definizione dimensione</strong> è impostato su <strong>Per intervalli</strong>.",
	"@@Multidimensional-Filter_raster_tag0@@": "Il raster multidimensionale di input.",
	"@@Multidimensional-Filter_ranges_tag0@@": "<p>Le ampiezze intervallo specificate nella tabella verranno utilizzate per aggregare gruppi di valori. I valori minimo e massimo specificano l'intervallo da includere.</p><p>Questo parametro è richiesto quando il parametro<strong>Tipo</strong>è impostato su <strong>Ampiezze intervallo</strong>.</p>",
	"@@Multidimensional-Filter_startoffirstiteration_tag0@@": "L'inizio del primo intervallo. Questo intervallo viene utilizzato per l'iterazione attraverso un dataset. Questo parametro è richiesto quando il parametro <strong>Definizione dimensione</strong> è impostato su <strong>Per iterazione</strong>.",
	"@@Multidimensional-Filter_step_tag0@@": "La frequenza di sezionamento dei dati. Questo parametro è richiesto quando il parametro <strong>Definizione dimensione</strong> è impostato su <strong>Per iterazione</strong>. L'impostazione predefinita è 3.",
	"@@Multidimensional-Filter_unit_tag0@@": "Specifica l'unità di iterazione. Questo parametro è obbligatorio quando il parametro <strong>Definizione dimensione</strong> è impostato su <strong>Per iterazione</strong> e il parametro <strong>Dimensione</strong> è impostato su <strong>StdTime</strong>.",
	"@@Multidimensional-Filter_value_tag0@@": "Il valore per la dimensione specificata. Questo parametro è richiesto quando il parametro <strong>Definizione dimensione</strong> è impostato su <strong>Per valori</strong>.",
	"@@Multidimensional-Filter_variables_tag0@@": "Le variabili che saranno incluse nel layer raster multidimensionale di output. Se non si specifica nessuna variabile, si userà la prima variabile.",
	"@@Multidimensional-Filter_dimensionless_tag0@@": "Specifica se il layer avrà valori di dimensione. Questa opzione è disponibile solo se è selezionata un'unica sezione per creare un layer.",
	"@@Multidimensional-Filter_dimensionless_tag1@@": "Selezionato: il layer non avrà valori di dimensione.",
	"@@Multidimensional-Filter_dimensionless_tag2@@": "Non selezionato: il layer avrà un valore di dimensione.​Questa è l'impostazione predefinita.",
	"@@Multidimensional-Raster_interpolationcellsize_tag0@@": "La dimensione della cella del raster interpolato. Il valore predefinito è ${1}.",
	"@@Multidimensional-Raster_interpolationmethod_tag0@@": "Il metodo di ricampionamento usato per interpolare dati irregolari.",
	"@@Multidimensional-Raster_interpolationmethod_tag1@@": "<strong>Vicino più prossimo</strong>: calcola il valore del pixel di output usando il pixel di input più vicino. Se non esiste nessun pixel di origine, non è possibile creare nessun pixel nuovo nell'output. Questa è l'impostazione predefinita.",
	"@@Multidimensional-Raster_interpolationmethod_tag2@@": "<strong>Rivestimento lineare</strong>: usa una rete irregolare triangolata dal punto centrale di ogni pixel del raster irregolare per interpolare una superficie che viene quindi convertita in un raster regolare.",
	"@@Multidimensional-Raster_interpolationmethod_tag3@@": "<strong>Vicino naturale</strong>: trova il sottoinsieme di campioni di input più vicino a un punto di riferimento e applica su di loro i pesi, in base alle aree proporzionate, per interpolare un valore.",
	"@@Multidimensional-Raster_interpolationmethod_tag4@@": "<strong>Ponderazione distanza inversa</strong>: determina i valori pixel usando una combinazione linearmente ponderata di un insieme di punti campione o pixel. Il peso è una funzione dell'inverso della distanza da punti o pixel conosciuti.",
	"@@Multidimensional-Raster_raster_tag0@@": "Il raster multidimensionale di input.",
	"@@Multidimensional-Raster_variables_tag0@@": "La variabile o le variabili che saranno incluse nel layer raster multidimensionale.",
	"@@Random_distribution_tag0@@": "Specifica il metodo di distribuzione valore casuale da utilizzare.",
	"@@Random_distribution_tag1@@": "<strong>Uniforme</strong> (Minimo, Massimo): una distribuzione uniforme con un intervallo definito. I valori predefiniti sono 0 per Minimo e 1 per Massimo. Questa è l'impostazione predefinita.",
	"@@Random_distribution_tag2@@": "<strong>Numero intero</strong> (Minimo, Massimo): una distribuzione numeri interi con un intervallo definito. I valori predefiniti sono 1 per Minimo e 10 per Massimo.",
	"@@Random_distribution_tag3@@": "<strong>Normale</strong> (Media, Deviazione standard): una distribuzione normale con una media e una deviazione standard definite. I valori predefiniti sono 0 per Media e 1 per Deviazione standard.",
	"@@Random_distribution_tag4@@": "<strong>Esponenziale</strong> (Media): una distribuzione esponenziale con una media definita. Il valore predefinito è 1.",
	"@@Random_distribution_tag5@@": "<strong>Poisson</strong> (Media): una distribuzione Poisson con una media definita. Il valore predefinito è 1.",
	"@@Random_distribution_tag6@@": "<strong>Gamma</strong> (Alfa, Beta): una distribuzione di gamma con alfa e beta definiti. I valori predefiniti sono 1 per Alfa e 1 per Beta.",
	"@@Random_distribution_tag7@@": "<strong>Binomiale</strong> (N, Probabilità): una distribuzione binomiale con N e probabilità definiti. I valori predefiniti sono 10 per N e 0,5 per Probabilità.",
	"@@Random_distribution_tag8@@": "<strong>Geometrico</strong> (Probabilità): una distribuzione geometrica con una probabilità definita. Il valore predefinito è 0,5.",
	"@@Random_distribution_tag9@@": "<strong>Binomiale negativo</strong> (r, Probabilità): una distribuzione Pascal con r e probabilità definiti. I valori predefiniti sono 10,0 per r e 0,5 per Probabilità.",
	"@@Random_randomnumbergenerator_tag0@@": "Specificare l'algoritmo generatore casuale che utilizza il seed e la distribuzione per produrre una sequenza di numeri casuali. Le opzioni disponibili sono le seguenti:",
	"@@Random_randomnumbergenerator_tag1@@": "C Rand standard",
	"@@Random_randomnumbergenerator_tag2@@": "Algoritmo 599 raccolto da ACM",
	"@@Random_randomnumbergenerator_tag3@@": "Mersenne Twister",
	"@@Random_randomnumbergenerator_tag4@@": "Il valore predefinito è Mersenne Twister.",
	"@@Random_rasterinfo_tag0@@": "Usare il pulsante <strong>Carica raster del modello</strong> per caricare un modello da una directory o portale.",
	"@@Random_seed_tag0@@": "Il valore iniziale è un valore intero che viene utilizzato per avviare il generatore di numeri casuali. Il valore predefinito è 1.",
	"@@Shrink_numberofcells_tag0@@": "Il numero di celle per il quale ridurre ciascuna zona specificata.",
	"@@Shrink_numberofcells_tag1@@": "Il valore deve essere un numero intero e può essere maggiore o uguale a 1.",
	"@@Shrink_raster_tag0@@": "Il raster di input per il quale ridurre le zone identificate.",
	"@@Shrink_raster_tag1@@": "Deve essere di tipo numero intero.",
	"@@Shrink_zonevalues_tag0@@": "L'elenco di zone da ridurre.",
	"@@Shrink_zonevalues_tag1@@": "I valori zona devono essere un numero intero e si possono trovare in qualunque ordine.",
	"@@Shrink_zonevalues_tag2@@": "Per specificare più zone, utilizzare uno spazio per separare i valori di zona.",
	"@@Distance-Accumulation_costraster_tag0@@": "Un raster che definisce il costo o l'impedenza dello spostamento planimetrico attraverso ciascuna cella. Il valore a ogni posizione della cella rappresenta la distanza di costo per unità per l'attraversamento della stessa. Ogni valore di posizione di una cella viene moltiplicato per la risoluzione della cella e compensa inoltre il movimento diagonale per ottenere il costo totale dell'attraversamento della stessa.",
	"@@Distance-Accumulation_costraster_tag1@@": "I valori del <strong>Raster di costo</strong> possono essere a numero intero o a virgola mobile, ma non possono essere negativi o zero.",
	"@@Distance-Accumulation_distancemethod_tag0@@": "Determina se calcolare la distanza con un metodo planare (terra piatta) o geodetico (ellissoide).",
	"@@Distance-Accumulation_distancemethod_tag1@@": "Planare: la misurazione planare utilizza la matematica cartesiana 2D per calcolare area e lunghezza. Questa opzione è disponibile solo quando si misura in un sistema di coordinate proiettato e il piano 2D di tale sistema di coordinate viene utilizzato come base per le misurazioni.",
	"@@Distance-Accumulation_distancemethod_tag2@@": "Geodetica: la linea più breve tra due punti sulla superficie terrestre su uno sferoide (ellissoide). Pertanto, indipendentemente dalla proiezione di input o output, i risultati non cambiano.",
	"@@Distance-Accumulation_distancemethod_tag3@@": "<strong>Nota</strong>: la linea geodetica può essere usata se si desidera determinare la distanza più breve tra due città per la traiettoria di un aereo. Questo metodo è conosciuto anche come linea del cerchio massimo se basato su una sfera piuttosto che su un ellissoide.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag0@@": "Stabilisce se si crea solo un raster di accumulo della distanza o un raster multibanda composto sia dal raster di accumulo della distanza sia dal raster di direzione contraria.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag1@@": "Non selezionato: il risultato è il raster di accumulo della distanza. Si tratta di un risultato a banda singola. Questa è l'impostazione predefinita.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag2@@": "Selezionato: si crea un risultato multibanda. La prima banda è il raster di accumulo della distanza e la seconda banda è il raster di direzione contraria.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag3@@": "Il raster di direzione contraria calcola per ogni cella, la direzione in gradi fino alla cella vicina seguendo il percorso più breve fino alla fonte più vicina evitando barriere.",
	"@@Distance-Accumulation_horizontalfactor_tag0@@": "<p>Definisce la relazione tra il fattore di costo orizzontale e l'angolo mobile relativo orizzontale (HRMA).</p><p>Ci sono diversi fattori con modificatori che identificano un grafico del fattore verticale definito. Inoltre, è possibile utilizzare una tabella per creare un grafico personalizzato. I grafici sono utilizzati per identificare il fattore verticale utilizzato nel calcolo del costo totale dello spostamento in una cella vicina.</p><p>Nelle spiegazioni che seguono, vengono utilizzati due acronimi: HF e HRMA. HF stands for horizontal factor, which defines the horizontal difficulty encountered when moving from one cell to the next. HRMA sta per horizontal relative moving angle, che identifica l'angolo tra la direzione orizzontale da una cella e la direzione di movimento. I tipi di </p><p><strong>fattori orizzontali</strong> includono i seguenti: </p><ul><li><strong>Binario</strong>-- Indica che se l'HRMA è inferiore all'angolo di taglio, l'HF è impostato al valore associato al fattore zero; altrimenti, è infinito.</li><li><strong>Avanti</strong> -- Stabilisce che è permesso solo il movimento in avanti. L'HRMA deve essere maggiore o uguale a 0 e inferiore a 90 gradi (0 &lt;= HRMA &lt;90). Se l'HRMA è superiore a 0 e inferiore a 45 gradi, l'HF per la cella viene impostato sul valore associato al fattore zero. Se l'HRMA è superiore o pari a 45 gradi, viene utilizzato il valore del modificatore del valore laterale. L'HF per qualsiasi valore HRMA uguale o superiore a 90 gradi è impostato su infinito.</li><li><strong>Lineare</strong>--Specifica che l'HF è una funzione lineare dell'HRMA.</li><li><strong>Lineare inversa</strong>--Specifica che l'HF è una funzione lineare inversa dell'HRMA.</li><li><strong>Tabella</strong>- Identifica che un file tabella sarà usato per definire il grafico dei fattori orizzontali usato per determinare gli HF.</li></ul><p>I modificatori dei fattori orizzontali includono quanto segue: </p><ul><li><strong>Fattore zero</strong>-- Il fattore orizzontale da usare quando l'HRMA è zero. Questo fattore posiziona l'intercetta y per qualsiasi funzione fattore orizzontale.</li><li><strong>Angolo di taglio</strong>--Definisce l'angolo HRMA oltre il quale l'HF sarà impostato su infinito.</li><li><strong>Pendenza</strong>-- Stabilisce la pendenza della linea retta usata con le parole chiave fattore orizzontale <strong>Lineare</strong> e <strong>Lineare inversa</strong>. La pendenza è specificata come una frazione di salita su corsa (per esempio, la pendenza del 45% è 1/45, che viene immessa come 0,02222).</li><li><strong>Side value</strong>-- Stabilisce l'HF quando l'HRMA è maggiore o uguale a 45 gradi e minore di 90 gradi quando viene specificata la parola chiave Fattore orizzontale <strong>avanti</strong>.</li><li><strong>Nome della tabella</strong> - Identifica il nome della tabella che definisce l'HF.</li></ul>",
	"@@Distance-Accumulation_horizontalraster_tag0@@": "Un raster che definisce la direzione orizzontale su ogni cella.",
	"@@Distance-Accumulation_horizontalraster_tag1@@": "I valori sul raster devono essere numeri interi compresi tra 0 e 360 con 0 gradi che indica il nord o verso la parte superiore dello schermo e con aumento in senso orario. Alle aree piane deve essere fornito un valore di -1. I valori in ogni posizione vengono utilizzati insieme a <strong>Fattore orizzontale</strong> per determinare i costi orizzontali durante lo spostamento da una cella a quelle vicine.",
	"@@Distance-Accumulation_initialaccumulation_tag0@@": "Il costo cumulativo iniziale per avviare il calcolo del costo. Questo parametro consente di specificare il costo fisso associato ad un'origine. Invece di iniziare con un costo 0, l'algoritmo del costo inizierà con il valore specificato.",
	"@@Distance-Accumulation_initialaccumulation_tag1@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Distance-Accumulation_initialaccumulation_tag2@@": "Il valore deve essere pari o superiore a zero. L'impostazione predefinita è 0.",
	"@@Distance-Accumulation_maximumaccumulation_tag0@@": "Definisce il costo cumulativo massimo per il viaggiatore relativo a un'origine. I calcoli del costo continuano per ogni origine finché non si raggiunge la capacità specificata.",
	"@@Distance-Accumulation_maximumaccumulation_tag1@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Distance-Accumulation_maximumaccumulation_tag2@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag0@@": "Un moltiplicatore da applicare ai valori di costo.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag1@@": "Questo parametro consente il controllo della modalità di spostamento o della grandezza all'origine. Maggiore è il moltiplicatore, maggiore è il costo per lo spostamento attraverso ogni cella.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag2@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag3@@": "I valori devono essere maggiori di zero. L'impostazione predefinita è 1.",
	"@@Distance-Accumulation_rasterbarriers_tag0@@": "Il raster che definisce le barriere.",
	"@@Distance-Accumulation_rasterbarriers_tag1@@": "Il dataset deve contenere NoData laddove non ci sono barriere. Le barriere sono rappresentate da valori validi, incluso lo zero.",
	"@@Distance-Accumulation_rasterbarriers_tag2@@": "Le barriere possono essere definite da un numero intero o da un raster a virgola mobile.",
	"@@Distance-Accumulation_sourceraster_tag0@@": "Posizioni dell’origine di input.",
	"@@Distance-Accumulation_sourceraster_tag1@@": "È un dataset raster che identifica le celle o le posizioni dalle quali si calcola la distanza di costo minima cumulativa per ogni posizione di cella di output.",
	"@@Distance-Accumulation_sourceraster_tag2@@": "Può essere un numero intero o un valore a virgola mobile.",
	"@@Distance-Accumulation_surfaceraster_tag0@@": "Un raster che definisce i valori di elevazione su ogni posizione della cella.",
	"@@Distance-Accumulation_surfaceraster_tag1@@": "I valori vengono utilizzati per calcolare l’effettiva distanza della superficie percorsa durante il passaggio tra celle.",
	"@@Distance-Accumulation_traveldirection_tag0@@": "Definisce la direzione del viaggiatore quando si applica il fattore verticale, il fattore orizzontale e il tasso di resistenza dell'origine.",
	"@@Distance-Accumulation_traveldirection_tag1@@": "<strong>Dall'origine</strong>: il fattore verticale, il fattore orizzontale e il tasso di resistenza dell'origine saranno applicati a partire dall'origine di input e spostandosi verso le celle di non-origine. Questa è l'impostazione predefinita.",
	"@@Distance-Accumulation_traveldirection_tag2@@": "<strong>Verso l'origine</strong>: il fattore verticale, il fattore orizzontale e il tasso di resistenza dell'origine saranno applicati a partire da ciascuna cella di non-origine e tornando indietro all'origine di input.",
	"@@Distance-Accumulation_traveldirection_tag3@@": "Specificare la parola chiave <strong>Dall'origine</strong> o <strong>Verso l'origine</strong>, che sarà applicata a tutte le origini, oppure specificare un campo nel <strong>Raster di origine</strong> che contiene le parole chiave per identificare la direzione di viaggio per ogni origine. Quel campo deve contenere la stringa ${FROM_SOURCE} o ${TO_SOURCE}.",
	"@@Distance-Accumulation_verticalfactor_tag0@@": "<p>Definisce la relazione tra il fattore di costo verticale e l'angolo mobile relativo verticale (VRMA).</p><p>Ci sono diversi fattori con modificatori che identificano un grafico di fattore verticale definito. Inoltre, è possibile utilizzare una tabella per creare un grafico personalizzato. I grafici sono utilizzati per identificare il fattore verticale utilizzato nel calcolo del costo totale dello spostamento in una cella vicina.</p><p>Nelle spiegazioni che seguono, vengono utilizzati due acronimi: VF e VRMA. VF stands for vertical factor, which defines the vertical difficulty encountered in moving from one cell to the next. VRMA sta per angolo mobile relativo verticale, che identifica l'angolo di pendenza tra la cella FROM, o di elaborazione, e la cella TO.</p><p><strong>I fattori verticali</strong> includono i seguenti:</p><ul><li><strong>Binario</strong>-- Specifica che se il VRMA è maggiore dell'angolo di taglio basso e minore dell'angolo di taglio alto, il VF è impostato al valore associato al fattore zero; altrimenti, è infinito.</li><li><strong>Lineare</strong> - Indica che la VF è una funzione lineare della VRMA.</li><li><strong>Lineare simmetrica</strong>-- Specifica che la VF è una funzione lineare della VRMA nel lato negativo o positivo della VRMA, rispettivamente, e le due funzioni lineari sono simmetriche rispetto all'asse VF (y).</li><li><strong>Lineare inversa</strong> - Indica che la VF è una funzione lineare inversa del VRMA.</li><li><strong>Lineare inversa simmetrica</strong>-- Indica che la VF è una funzione lineare inversa del VRMA nel lato negativo o positivo del VRMA, rispettivamente, e le due funzioni lineari sono simmetriche rispetto all'asse VF (y).</li><li><strong>Cos</strong>--Identifica la VF come funzione basata sul coseno del VRMA.</li><li><strong>Sec</strong>--Identifica la VF come funzione basata sulla secante del VRMA.</li><li><strong>Cos-Sec</strong>--Specifica che la VF è la funzione basata sul coseno del VRMA quando il VRMA è negativo e la funzione basata sulla secante del VRMA quando il VRMA non è negativo.</li><li><strong>Sec-Cos</strong>--Specifica che la VF è la funzione basata sulla secante del VRMA quando il VRMA è negativo e la funzione basata sul coseno del VRMA quando il VRMA non è negativo. </li><li><strong>Tabella</strong>--Identifica che verrà utilizzato un file tabella per definire il grafico del fattore verticale che viene utilizzato per determinare le VF.</li></ul><p>I modificatori delle parole chiave verticali includono quanto segue: </p><ul><li><strong>Fattore zero</strong>-- Stabilisce il fattore verticale usato quando il VRMA è zero. Questo fattore posiziona l’intercettazione y della funzione specificata. Per definizione, il fattore zero non è applicabile ad alcuna funzione verticale trigonometrica (COS, SEC, COS-SEC o SEC-COS). L'intercetta y è definita da queste funzioni.</li><li><strong>Angolo di taglio basso </strong>- Definisce l'angolo VRMA al di sotto del quale la VF sarà impostata su infinito.</li><li><strong>Angolo di taglio alto</strong> - Definisce l'angolo VRMA al di sopra del quale la VF sarà impostata su infinito. </li><li><strong>Pendenza</strong> - Stabilisce la pendenza della linea retta usata con le parole chiave <strong>Lineare</strong> e <strong>Lineare Inversa</strong>-fattore verticale. La pendenza è specificata come una frazione di salita su corsa (per esempio, la pendenza del 45 per cento è 1/45, che viene immessa come 0,02222).</li><li><strong>Nome tabella</strong>--</li>Identifica il nome della tabella che definisce la VF.</ul>",
	"@@Distance-Accumulation_verticalraster_tag0@@": "Definisce la relazione tra il fattore di costo verticale e l'angolo di movimento relativo verticale (VRMA).",
	"@@Distance-Accumulation_verticalraster_tag1@@": "I valori vengono utilizzati per calcolare la pendenza usata per identificare il fattore verticale quando si passa da una cella all'altra.",
	"@@Distance-Allocation_costraster_tag0@@": "Un raster che definisce il costo o l'impedenza dello spostamento planimetrico attraverso ciascuna cella. Il valore a ogni posizione della cella rappresenta la distanza di costo per unità per l'attraversamento della stessa. Ogni valore di posizione di una cella viene moltiplicato per la risoluzione della cella e compensa inoltre il movimento diagonale per ottenere il costo totale dell'attraversamento della stessa.",
	"@@Distance-Allocation_costraster_tag1@@": "I valori del <strong>Raster di costo</strong> possono essere a numero intero o a virgola mobile, ma non possono essere negativi o zero.",
	"@@Distance-Allocation_distancemethod_tag0@@": "Determina se calcolare la distanza con un metodo planare (terra piatta) o geodetico (ellissoide).",
	"@@Distance-Allocation_distancemethod_tag1@@": "Planare: la misurazione planare utilizza la matematica cartesiana 2D per calcolare area e lunghezza. Questa opzione è disponibile solo quando si misura in un sistema di coordinate proiettato e il piano 2D di tale sistema di coordinate viene utilizzato come base per le misurazioni.",
	"@@Distance-Allocation_distancemethod_tag2@@": "Geodetica: la linea più breve tra due punti sulla superficie terrestre su uno sferoide (ellissoide). Pertanto, indipendentemente dalla proiezione di input o output, i risultati non cambiano.",
	"@@Distance-Allocation_distancemethod_tag3@@": "<strong>Nota</strong>: la linea geodetica può essere usata se si desidera determinare la distanza più breve tra due città per la traiettoria di un aereo. Questo metodo è conosciuto anche come linea del cerchio massimo se basato su una sfera piuttosto che su un ellissoide.",
	"@@Distance-Allocation_horizontalfactor_tag0@@": "<p>Definisce la relazione tra il fattore di costo orizzontale e l'angolo mobile relativo orizzontale (HRMA).</p><p>Ci sono diversi fattori con modificatori che identificano un grafico del fattore verticale definito. Inoltre, è possibile utilizzare una tabella per creare un grafico personalizzato. I grafici sono utilizzati per identificare il fattore verticale utilizzato nel calcolo del costo totale dello spostamento in una cella vicina.</p><p>Nelle spiegazioni che seguono, vengono utilizzati due acronimi: HF e HRMA. HF stands for horizontal factor, which defines the horizontal difficulty encountered when moving from one cell to the next. HRMA sta per horizontal relative moving angle, che identifica l'angolo tra la direzione orizzontale da una cella e la direzione di movimento. I tipi di </p><p><strong>fattori orizzontali</strong> includono i seguenti: </p><ul><li><strong>Binario</strong>-- Indica che se l'HRMA è inferiore all'angolo di taglio, l'HF è impostato al valore associato al fattore zero; altrimenti, è infinito.</li><li><strong>Avanti</strong> -- Stabilisce che è permesso solo il movimento in avanti. L'HRMA deve essere maggiore o uguale a 0 e inferiore a 90 gradi (0 &lt;= HRMA &lt;90). Se l'HRMA è superiore a 0 e inferiore a 45 gradi, l'HF per la cella viene impostato sul valore associato al fattore zero. Se l'HRMA è superiore o pari a 45 gradi, viene utilizzato il valore del modificatore del valore laterale. L'HF per qualsiasi valore HRMA uguale o superiore a 90 gradi è impostato su infinito.</li><li><strong>Lineare</strong>--Specifica che l'HF è una funzione lineare dell'HRMA.</li><li><strong>Lineare inversa</strong>--Specifica che l'HF è una funzione lineare inversa dell'HRMA.</li><li><strong>Tabella</strong>- Identifica che un file tabella sarà usato per definire il grafico dei fattori orizzontali usato per determinare gli HF.</li></ul><p>I modificatori dei fattori orizzontali includono quanto segue: </p><ul><li><strong>Fattore zero</strong>-- Il fattore orizzontale da usare quando l'HRMA è zero. Questo fattore posiziona l'intercetta y per qualsiasi funzione fattore orizzontale.</li><li><strong>Angolo di taglio</strong>--Definisce l'angolo HRMA oltre il quale l'HF sarà impostato su infinito.</li><li><strong>Pendenza</strong>-- Stabilisce la pendenza della linea retta usata con le parole chiave fattore orizzontale <strong>Lineare</strong> e <strong>Lineare inversa</strong>. La pendenza è specificata come una frazione di salita su corsa (per esempio, la pendenza del 45% è 1/45, che viene immessa come 0,02222).</li><li><strong>Side value</strong>-- Stabilisce l'HF quando l'HRMA è maggiore o uguale a 45 gradi e minore di 90 gradi quando viene specificata la parola chiave Fattore orizzontale <strong>avanti</strong>.</li><li><strong>Nome della tabella</strong> - Identifica il nome della tabella che definisce l'HF.</li></ul>",
	"@@Distance-Allocation_horizontalraster_tag0@@": "Un raster che definisce la direzione orizzontale su ogni cella.",
	"@@Distance-Allocation_horizontalraster_tag1@@": "I valori sul raster devono essere numeri interi compresi tra 0 e 360 con 0 gradi che indica il nord o verso la parte superiore dello schermo e con aumento in senso orario. Alle aree piane deve essere fornito un valore di -1. I valori in ogni posizione vengono utilizzati insieme a <strong>Fattore orizzontale</strong> per determinare i costi orizzontali durante lo spostamento da una cella a quelle vicine.",
	"@@Distance-Allocation_initialaccumulation_tag0@@": "Il costo cumulativo iniziale per avviare il calcolo del costo. Questo parametro consente di specificare il costo fisso associato ad un'origine. Invece di iniziare con un costo 0, l'algoritmo del costo inizierà con il valore specificato.",
	"@@Distance-Allocation_initialaccumulation_tag1@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Distance-Allocation_initialaccumulation_tag2@@": "Il valore deve essere pari o superiore a zero. L'impostazione predefinita è 0.",
	"@@Distance-Allocation_maximumaccumulation_tag0@@": "Definisce il costo cumulativo massimo per il viaggiatore relativo a un'origine. I calcoli del costo continuano per ogni origine finché non si raggiunge la capacità specificata.",
	"@@Distance-Allocation_maximumaccumulation_tag1@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Distance-Allocation_maximumaccumulation_tag2@@": "Il valore deve essere maggiore di zero. La capacità predefinita è fino al bordo del raster di output.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag0@@": "Un moltiplicatore da applicare ai valori di costo.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag1@@": "Questo parametro consente il controllo della modalità di spostamento o della grandezza all'origine. Maggiore è il moltiplicatore, maggiore è il costo per lo spostamento attraverso ogni cella.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag2@@": "I valori devono essere maggiori di zero. L'impostazione predefinita è 1.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag3@@": "È possibile usare per questo parametro un valore numerico (doppio) o un campo dal <strong>Raster origine</strong>.",
	"@@Distance-Allocation_rasterbarriers_tag0@@": "Il raster che definisce le barriere.",
	"@@Distance-Allocation_rasterbarriers_tag1@@": "Il dataset deve contenere NoData laddove non ci sono barriere. Le barriere sono rappresentate da valori validi, incluso lo zero.",
	"@@Distance-Allocation_rasterbarriers_tag2@@": "Le barriere possono essere definite da un numero intero o da un raster a virgola mobile.",
	"@@Distance-Allocation_sourcefield_tag0@@": "Il campo usato per assegnare valori alle posizioni di origine. Deve essere di tipo numero intero.",
	"@@Distance-Allocation_sourceraster_tag0@@": "Posizioni dell’origine di input.",
	"@@Distance-Allocation_sourceraster_tag1@@": "È un dataset raster che identifica le celle o le posizioni dalle quali si calcola la distanza di costo minima cumulativa per ogni posizione di cella di output.",
	"@@Distance-Allocation_sourcerowandcolumnbands_tag0@@": "Stabilisce se si crea solo il raster di allocazione o un raster multibanda.",
	"@@Distance-Allocation_sourcerowandcolumnbands_tag1@@": "Non selezionato: il risultato è il raster di allocazione della distanza. Si tratta di un risultato a banda singola. Questa è l'impostazione predefinita.",
	"@@Distance-Allocation_sourcerowandcolumnbands_tag2@@": "Selezionato: si crea un raster multibanda. La prima banda è il raster di allocazione della distanza, la seconda banda contiene un indice di riga e la terza banda contiene un indice di colonna. Questi indici identificano la posizione della cella di origine che si trova alla minore distanza di costo cumulativa.",
	"@@Distance-Allocation_surfaceraster_tag0@@": "Un raster che definisce i valori di elevazione su ogni posizione della cella.",
	"@@Distance-Allocation_surfaceraster_tag1@@": "I valori vengono utilizzati per calcolare l’effettiva distanza della superficie percorsa durante il passaggio tra celle.",
	"@@Distance-Allocation_traveldirection_tag0@@": "Definisce la direzione del viaggiatore quando si applica il fattore verticale, il fattore orizzontale e il tasso di resistenza dell'origine.",
	"@@Distance-Allocation_traveldirection_tag1@@": "<strong>Dall'origine</strong>: il fattore verticale, il fattore orizzontale e il tasso di resistenza dell'origine saranno applicati a partire dall'origine di input e spostandosi verso le celle di non-origine. Questa è l'impostazione predefinita.",
	"@@Distance-Allocation_traveldirection_tag2@@": "<strong>Verso l'origine</strong>: il fattore verticale, il fattore orizzontale e il tasso di resistenza dell'origine saranno applicati a partire da ciascuna cella di non-origine e tornando indietro all'origine di input.",
	"@@Distance-Allocation_traveldirection_tag3@@": "Specificare la parola chiave <strong>Dall'origine</strong> o <strong>Verso l'origine</strong>, che sarà applicata a tutte le origini, oppure specificare un campo nel <strong>Raster di origine</strong> che contiene le parole chiave per identificare la direzione di viaggio per ogni origine. Quel campo deve contenere la stringa ${FROM_SOURCE} o ${TO_SOURCE}.",
	"@@Distance-Allocation_verticalfactor_tag0@@": "<p>Definisce la relazione tra il fattore di costo verticale e l'angolo mobile relativo verticale (VRMA).</p><p>Ci sono diversi fattori con modificatori che identificano un grafico di fattore verticale definito. Inoltre, è possibile utilizzare una tabella per creare un grafico personalizzato. I grafici sono utilizzati per identificare il fattore verticale utilizzato nel calcolo del costo totale dello spostamento in una cella vicina.</p><p>Nelle spiegazioni che seguono, vengono utilizzati due acronimi: VF e VRMA. VF stands for vertical factor, which defines the vertical difficulty encountered in moving from one cell to the next. VRMA sta per angolo mobile relativo verticale, che identifica l'angolo di pendenza tra la cella FROM, o di elaborazione, e la cella TO.</p><p><strong>I fattori verticali</strong> includono i seguenti:</p><ul><li><strong>Binario</strong>-- Specifica che se il VRMA è maggiore dell'angolo di taglio basso e minore dell'angolo di taglio alto, il VF è impostato al valore associato al fattore zero; altrimenti, è infinito.</li><li><strong>Lineare</strong> - Indica che la VF è una funzione lineare della VRMA.</li><li><strong>Lineare simmetrica</strong>-- Specifica che la VF è una funzione lineare della VRMA nel lato negativo o positivo della VRMA, rispettivamente, e le due funzioni lineari sono simmetriche rispetto all'asse VF (y).</li><li><strong>Lineare inversa</strong> - Indica che la VF è una funzione lineare inversa del VRMA.</li><li><strong>Lineare inversa simmetrica</strong>-- Indica che la VF è una funzione lineare inversa del VRMA nel lato negativo o positivo del VRMA, rispettivamente, e le due funzioni lineari sono simmetriche rispetto all'asse VF (y).</li><li><strong>Cos</strong>--Identifica la VF come funzione basata sul coseno del VRMA.</li><li><strong>Sec</strong>--Identifica la VF come funzione basata sulla secante del VRMA.</li><li><strong>Cos-Sec</strong>--Specifica che la VF è la funzione basata sul coseno del VRMA quando il VRMA è negativo e la funzione basata sulla secante del VRMA quando il VRMA non è negativo.</li><li><strong>Sec-Cos</strong>--Specifica che la VF è la funzione basata sulla secante del VRMA quando il VRMA è negativo e la funzione basata sul coseno del VRMA quando il VRMA non è negativo. </li><li><strong>Tabella</strong>--Identifica che verrà utilizzato un file tabella per definire il grafico del fattore verticale che viene utilizzato per determinare le VF.</li></ul><p>I modificatori delle parole chiave verticali includono quanto segue: </p><ul><li><strong>Fattore zero</strong>-- Stabilisce il fattore verticale usato quando il VRMA è zero. Questo fattore posiziona l’intercettazione y della funzione specificata. Per definizione, il fattore zero non è applicabile ad alcuna funzione verticale trigonometrica (COS, SEC, COS-SEC o SEC-COS). L'intercetta y è definita da queste funzioni.</li><li><strong>Angolo di taglio basso </strong>- Definisce l'angolo VRMA al di sotto del quale la VF sarà impostata su infinito.</li><li><strong>Angolo di taglio alto</strong> - Definisce l'angolo VRMA al di sopra del quale la VF sarà impostata su infinito. </li><li><strong>Pendenza</strong> - Stabilisce la pendenza della linea retta usata con le parole chiave <strong>Lineare</strong> e <strong>Lineare Inversa</strong>-fattore verticale. La pendenza è specificata come una frazione di salita su corsa (per esempio, la pendenza del 45 per cento è 1/45, che viene immessa come 0,02222).</li><li><strong>Nome tabella</strong>--</li>Identifica il nome della tabella che definisce la VF.</ul>",
	"@@Distance-Allocation_verticalraster_tag0@@": "Definisce la relazione tra il fattore di costo verticale e l'angolo di movimento relativo verticale (VRMA).",
	"@@Distance-Allocation_verticalraster_tag1@@": "I valori vengono utilizzati per calcolare la pendenza usata per identificare il fattore verticale quando si passa da una cella all'altra.",
	"@@Euclidean-Back-Direction_cellsize_tag0@@": "La dimensione della cella alla quale si creerà il raster di output.",
	"@@Euclidean-Back-Direction_cellsize_tag1@@": "Se la dimensione della cella è stata esplicitamente impostata in <strong>Ambienti</strong>, quella sarà la dimensione della cella predefinita. Se non è stata impostata, la dimensione della cella di output sarà la stessa del <strong>Raster di origine</strong>.",
	"@@Euclidean-Back-Direction_distancemethod_tag0@@": "Determina se calcolare la distanza con un metodo planare (terra piatta) o geodetico (ellissoide).",
	"@@Euclidean-Back-Direction_distancemethod_tag1@@": "Planare: la misurazione planare utilizza la matematica cartesiana 2D per calcolare area e lunghezza. Questa opzione è disponibile solo quando si misura in un sistema di coordinate proiettato e il piano 2D di tale sistema di coordinate viene utilizzato come base per le misurazioni.",
	"@@Euclidean-Back-Direction_distancemethod_tag2@@": "Geodetica: la linea più breve tra due punti sulla superficie terrestre su uno sferoide (ellissoide). Pertanto, indipendentemente dalla proiezione di input o output, i risultati non cambiano.",
	"@@Euclidean-Back-Direction_distancemethod_tag3@@": "<strong>Nota</strong>: la linea geodetica può essere usata se si desidera determinare la distanza più breve tra due città per la traiettoria di un aereo. Questo metodo è conosciuto anche come linea del cerchio massimo se basato su una sfera piuttosto che su un ellissoide.",
	"@@Euclidean-Back-Direction_maximumdistance_tag0@@": "Definisce la distanza limite entro la quale viene calcolata la direzione verso l'origine più vicina. Se la distanza fino all'origine più vicina supera questo valore, l'output di quella cella sarà NoData.",
	"@@Euclidean-Back-Direction_maximumdistance_tag1@@": "La distanza predefinita è fino all'estensione del raster di output.",
	"@@Euclidean-Back-Direction_rasterbarriers_tag0@@": "Il raster che definisce le barriere.",
	"@@Euclidean-Back-Direction_rasterbarriers_tag1@@": "Il dataset deve contenere NoData laddove non ci sono barriere. Le barriere sono rappresentate da valori validi, incluso lo zero.",
	"@@Euclidean-Back-Direction_rasterbarriers_tag2@@": "Le barriere possono essere definite da un numero intero o da un raster a virgola mobile.",
	"@@Euclidean-Back-Direction_sourceraster_tag0@@": "Un dataset raster che identifica le celle o le posizioni sulle quali si calcola la direzione euclidea per ogni posizione della cella di output.",
	"@@Euclidean-Back-Direction_sourceraster_tag1@@": "Il tipo di input può essere un numero intero o un valore a virgola mobile.",
	"@@Cost-Path_costbacklinkraster_tag0@@": "Il nome di un raster layer backlink costi utilizzato per determinare il percorso per restituire un'origine tramite il percorso minimo-costo.",
	"@@Cost-Path_costbacklinkraster_tag1@@": "Per ogni cella nel raster backlink, un valore identifica il vicino che si trova nella cella successiva nel percorso costi cumulativo minimo dalla cella a una cella origine singola o a un insieme di celle origine.",
	"@@Cost-Path_costdistanceraster_tag0@@": "Il nome di un raster distanza di costo da utilizzare per determinare il percorso minimo-costo dalle posizioni di destinazione all'origine.",
	"@@Cost-Path_costdistanceraster_tag1@@": "Il raster distanza di costo viene creato normalmente con la funzione Distanza di costo, Assegnazione dei costi o Back link costi. Il layer raster distanza di costo archivia per ogni cella la distanza di costo cumulativa minima su una superficie di costo da ogni cella su un insieme di celle di origine.",
	"@@Cost-Path_destinationfield_tag0@@": "Il campo usato per ottenere i valori per le posizioni di destinazione. I dati di feature di input devono contenere almeno un campo valido.",
	"@@Cost-Path_destinationraster_tag0@@": "Un dataset raster che identifica quelle celle da cui viene determinato il percorso di costo minimo verso l'origine meno costosa.",
	"@@Cost-Path_destinationraster_tag1@@": "Il raster layer di input è costituito da celle con valori validi (zero è un valore valido) e alle celle rimanenti devono essere assegnato NoData.",
	"@@Cost-Path_forceflowdirectionconventionforbacklinkraster_tag0@@": "Impone alla funzione di trattare il raster backlink di input come raster di direzione di flusso. I raster di direzione di flusso possono includere numeri interi con valori da 0 a 255.",
	"@@Cost-Path_forceflowdirectionconventionforbacklinkraster_tag1@@": "Deselezionato: se i valori del raster backlink specificato sono numeri interi nell'intervallo 0-8, il dataset sarà trattato come raster backlink di costo. Se i valori vanno da 0 a 255, l'input sarà trattato come raster di direzione di flusso. Se i valori vanno da 0 a 360 e sono virgola mobile, l'input sarà trattato come raster di direzione contraria.",
	"@@Cost-Path_forceflowdirectionconventionforbacklinkraster_tag2@@": "Selezionato: il raster fornito per il raster backlink sarà trattato come raster di direzione di flusso. L'uso di questa opzione del raster della direzione del flusso ha un valore massimo di 8 o meno.",
	"@@Cost-Path_pathtype_tag0@@": "Una parola chiave che definisce il modo in cui i valori e le zone nei dati di destinazione di input vengono interpretati nei calcoli dei costi di viaggio. Le opzioni sono le seguenti:",
	"@@Cost-Path_pathtype_tag1@@": "<strong>Ogni cella</strong>: per ogni cella con valori validi nei dati di destinazione di input, viene determinato e salvato sul raster di output un percorso di costo minimo. Con questa opzione, ogni cella dei dati di destinazione di input viene trattata separatamente e viene determinato un percorso di costo minimo per ciascuna.",
	"@@Cost-Path_pathtype_tag2@@": "<strong>Ogni zona</strong>: per ogni zona nei dati di destinazione di input, viene determinato e salvato sul raster di output un percorso di costo minimo. Con questa opzione, il percorso di costo minimo per ogni zona inizia nella cella con la ponderazione di distanza di costo più bassa nella zona.",
	"@@Cost-Path_pathtype_tag3@@": "<strong>Singolo migliore</strong>: per tutte le celle nei dati di destinazione di input, il percorso di costo minimo viene ricavato dalla cella con il minimo dei percorsi di costo minimo verso le celle di origine.",
	"@@Cell-Statistics_cellsizetype_tag0@@": "Scegliere quale dimensione di cella usare nel raster di output. Se le dimensioni di tutte le celle di input sono uguali, tutte le opzioni produrranno gli stessi risultati.",
	"@@Cell-Statistics_cellsizetype_tag1@@": "Primo di: usa la dimensione della prima cella dei raster di input.",
	"@@Cell-Statistics_cellsizetype_tag2@@": "Minimo di: usa la dimensione della cella più piccola tra tutti i raster di input.",
	"@@Cell-Statistics_cellsizetype_tag3@@": "Massimo di: usa la dimensione della cella più grande tra tutti i raster di input. Questa è l'impostazione predefinita.",
	"@@Cell-Statistics_cellsizetype_tag4@@": "Media di: usa la dimensione media della cella tra tutti i raster di input.",
	"@@Cell-Statistics_cellsizetype_tag5@@": "Ultimo di: usa la dimensione dell'ultima cella dei raster di input.",
	"@@Cell-Statistics_extenttype_tag0@@": "Scegliere quale estensione si dovrebbe usare nel raster di output:",
	"@@Cell-Statistics_extenttype_tag1@@": "Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.",
	"@@Cell-Statistics_extenttype_tag2@@": "Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione predefinita.",
	"@@Cell-Statistics_extenttype_tag3@@": "Unione di: usa l'estensione di tutti i raster per determinare l'estensione di elaborazione.",
	"@@Cell-Statistics_extenttype_tag4@@": "Ultimo di: usa l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.",
	"@@Cell-Statistics_processasmultiband_tag0@@": "Determina il modo in cui vengono elaborate le bande raster di input.",
	"@@Cell-Statistics_processasmultiband_tag1@@": "Deselezionato: tutti gli input multibanda vengono elaborati come bande singole. Questa è l'impostazione predefinita.",
	"@@Cell-Statistics_processasmultiband_tag2@@": "Selezionato: tutti gli input multibanda vengono elaborati come multibanda.",
	"@@Cell-Statistics_rasters_tag0@@": "L'elenco di raster a partire dai quali calcolare le statistiche, in base ai singoli pixel.",
	"@@Cell-Statistics_percentileinterpolationtype_tag0@@": "<p>Specifica il metodo di interpolazione da utilizzare quando il valore percentile specificato si trova tra due valori di celle di input. </p><ul><li><strong>Rilevamento automatico</strong>: se i raster di input sono di tipo pixel intero, viene utilizzato il cosiddetto metodo <strong>Più vicino</strong>. Se il raster di input è di tipo pixel a virgola mobile, allora viene utilizzato il metodo <strong>lineare</strong>. Questa è l'impostazione predefinita.</li><li><strong>Più vicino</strong>: il valore più vicino disponibile viene usato per il percentile desiderato. In questo caso, il tipo di pixel di output è lo stesso del raster di valore di input.</li><li><strong>Lineare</strong>: la media pesata dei due valori circostanti viene usata per il percentile desiderata. In questo caso, il tipo di pixel in uscita è a virgola mobile.</li></ul><p>Questa opzione è disponibile solo se il parametro Tipo di <strong>operazione</strong> è impostato su <strong>Mediano</strong> o <strong>Percentile</strong>.</p>",
	"@@Cell-Statistics_percentilevalue_tag0@@": "<p>Il percentile da calcolare. Il valore predefinito è 90 per il 90esimo percentile.</p><p>I valori può oscillare da 0 a 100. Il percentile numero 0 è essenzialmente l'equivalente della statistica minima e il percentile numero 100 è l'equivalente della statistica massima. Un valore di 50 produrrà essenzialmente lo stesso risultato della statistica mediana.</p><p>Questa opzione è disponibile solo se il parametro <strong>Operazione</strong> è impostato su <strong>Percentile</strong>.</p>",
	"@@Optimal-Path-As-Raster_backdirectionrasterorflowdirectionraster_tag0@@": "Il raster di direzione contraria contiene le direzioni calcolate in gradi. La direzione identifica la cella successiva seguendo il percorso ottimale fino all'origine di costo minimo cumulativo evitando barriere.",
	"@@Optimal-Path-As-Raster_backdirectionrasterorflowdirectionraster_tag1@@": "L'intervallo di valori è compreso tra 0 gradi e 360 gradi, con 0 riservato per le celle di origine. Verso est (destra) è di 90 e i valori aumentano in senso orario (180 è sud, 270 è ovest e 360 è nord).",
	"@@Optimal-Path-As-Raster_destinationfield_tag0@@": "Il campo usato per ottenere i valori per le posizioni di destinazione.",
	"@@Optimal-Path-As-Raster_destinationraster_tag0@@": "Un dataset raster che identifica quelle celle da cui viene determinato il percorso ottimale verso l'origine meno costosa. Questo input è obbligatorio.",
	"@@Optimal-Path-As-Raster_destinationraster_tag1@@": "Il raster layer di input è costituito da celle con valori validi (zero è un valore valido) e alle celle rimanenti devono essere assegnato NoData.",
	"@@Optimal-Path-As-Raster_distanceaccumulationraster_tag0@@": "Il raster di accumulo distanza viene utilizzato per stabilire il percorso ottimale dalle destinazioni alle origini. Il raster di accumulo della distanza viene solitamente creato con la funzione <strong>Accumulo distanza</strong>. Ciascuna cella nel raster di accumulo della distanza rappresenta la distanza di costo cumulativa minima su una superficie da ogni cella a un insieme di celle di origine.",
	"@@Optimal-Path-As-Raster_pathtype_tag0@@": "Specifica una parola chiave che definisce il modo in cui i valori e le zone nei dati di destinazione di input vengono interpretati nei calcoli del percorso di costo.",
	"@@Optimal-Path-As-Raster_pathtype_tag1@@": "<strong>Ogni zona</strong>: per ogni zona nei dati di destinazione di input, viene determinato e salvato sul raster di output un percorso di costo minimo. Con questa opzione, il percorso ottimale per ogni zona inizia nella cella con la ponderazione di distanza di costo più bassa nella zona.",
	"@@Optimal-Path-As-Raster_pathtype_tag2@@": "<strong>Singolo migliore</strong>: per tutte le celle nei dati di destinazione di input, il percorso ottimale viene ricavato dalla cella con il minimo dei percorsi di costo minimo verso le celle di origine.",
	"@@Optimal-Path-As-Raster_pathtype_tag3@@": "<strong>Ogni cella</strong>: per ogni cella con valori validi nei dati di destinazione di input, viene determinato un percorso ottimale. Con questa opzione, ogni cella dei dati di destinazione di input viene trattata separatamente e viene determinato un percorso ottimale per ciascuna.",
	"@@CCDC-Analysis_bandsfordetectingchange_tag0@@": "L'ID banda da utilizzare per il rilevamento delle variazioni. Se non è specificato nessun ID banda, si utilizzeranno tutte le bande del dataset raster di input.",
	"@@CCDC-Analysis_bandsfordetectingchange_tag1@@": "I valori ID devono essere numeri interi separati da spazi.",
	"@@CCDC-Analysis_bandsfortemporalmasking_tag0@@": "Gli ID banda della banda verde e della banda SWIR, da utilizzare per il mascheramento per nuvola, ombra della nuvola e neve. Se non è specificato nessun ID banda, il mascheramento non avverrà.",
	"@@CCDC-Analysis_bandsfortemporalmasking_tag1@@": "I valori ID devono essere numeri interi separati da spazi.",
	"@@CCDC-Analysis_bandsfortemporalmasking_tag2@@": "Questo parametro specifica le bande da usare per il mascheramento di nuvola, ombra della nuvola e neve. Dal momento che l'ombra della nuvola e la neve appaiono molto scure nella banda dell'infrarosso a onde corte (SWIR) e che le nuvole e la neve sono molto luminose nella banda verde, si consiglia di mascherare gli indici di banda per le bande SWIR e verdi.",
	"@@CCDC-Analysis_chi-squaredthresholdfordetectchange_tag0@@": "La soglia chi-quadrato sulla probabilità delle modifiche. Se un osservazione presenta una probabilità di modifiche calcolata al di sopra di questa soglia, viene contrassegnata come un'anomalia, che è un evento di modifica potenziale.​Il valore predefinito è 0,99.",
	"@@CCDC-Analysis_minimumconsecutiveanomalyobservations_tag0@@": "Il numero minimo di osservazioni di anomalie consecutive che devono verificarsi prima che un evento venga considerato una modifica.​Un pixel deve essere contrassegnato come un'anomalia per il numero specificato di sezioni temporali consecutive prima di essere considerato una vera modifica. L'impostazione predefinita è 6.",
	"@@CCDC-Analysis_raster_tag0@@": "Il layer raster multidimensionale di input.",
	"@@CCDC-Analysis_updatingfittingfrequency(inyears)_tag0@@": "La frequenza con la quale aggiornare il modello di serie temporali con nuove osservazioni. Per impostazione predefinita, il modello viene aggiornato ogni anno.",
	"@@CCDC-Analysis_updatingfittingfrequency(inyears)_tag1@@": "Questo parametro definisce la cadenza dell'aggiornamento del modello di serie temporali con nuove osservazioni. L'aggiornamento frequente di un modello può richiedere moltissimi calcoli e i benefici possono essere minimi. Ad esempio, se ci sono 365 sezioni o osservazioni chiare all'anno nel raster multidimensionale e l'aggiornamento viene eseguito per ogni singola osservazione, l'elaborazione sarà 365 volte più complessa dal punto di vista dei calcoli rispetto ad un aggiornamento una volta l'anno, ma la precisione potrebbe non essere superiore.",
	"@@Trend-To-RGB_modeltype_tag0@@": "Il tipo di informazioni sul modello da convertire in RGB.",
	"@@Trend-To-RGB_modeltype_tag1@@": "Lineare: le informazioni sulla tendenza lineare saranno convertite in RGB. Questa è l'impostazione predefinita.",
	"@@Trend-To-RGB_modeltype_tag2@@": "Armonica: le informazioni sulla tendenza armonica saranno convertite in RGB.",
	"@@Trend-To-RGB_raster_tag0@@": "Il raster di tendenza di input.",
	"@@LandTrendr-Analysis_bestmodelproportion_tag0@@": "<p>Valore di proporzione del modello migliore. Durante il processo di selezione del modello, lo strumento calcolerà il valore p per ogni modello e selezionerà un modello che dispone dei vertici maggiori durante il manitenimento del valore p minore (il più rilevante) basato su questo valore di proporzione. Un valore di 1 significa che il modello ha il valore p più basso ma non avrà un numero alto di vertici. L'impostazione di default è 1.25.</p>",
	"@@LandTrendr-Analysis_maximumnumberofsegments_tag0@@": "<p>Il numero massimo di segmenti da adattare al tempo delle serie per ogni pixel. L'impostazione di default è 5.</p>",
	"@@LandTrendr-Analysis_minimumnumberofobservations_tag0@@": "<p>Il numero minimo di osservazioni valide richiede di eseguire un adattamento. Il numero di anni nei dataset multidimensionali di input deve essere uguale o maggiori di questo valore. L'impostazione di default è 6.</p>",
	"@@LandTrendr-Analysis_outputotherbands_tag0@@": "<p>Specifica se altre bande saranno incluse nei risultati.</p><ul><li>Selezionata-Altre bande saranno incluse nei risultati. La segmentazione e l'e informazioni sui vertici dalla banda di segmentazione iniziale specificata nel parametro <strong>Banda di elaborazione</strong> si adatterà anche alle bande rimanenti nelle immagini multibanda. I risultati del modelli includeranno prima la banda di segmentazione, poi le bande rimanenti.</li><li>Non selezionata-Altre bande non saranno incluse. Questa è l'impostazione di default.</li></ul>",
	"@@LandTrendr-Analysis_preventoneyearrecovery_tag0@@": "<p>Specifica se i segmenti che esibiscono un recupero di un anno verranno esclusi.</p><ul><li>Selezionata-I segmenti che esibiscono un recupero di un anno verranno esclusi. Questa è l'impostazione di default.</li><li>Non selezionata-I segmenti che esibiscono un recupero di un anno non verranno esclusi.</li></ul>",
	"@@LandTrendr-Analysis_processingband_tag0@@": "<p>La banda utilizzata per segmentare le traiettorie del valore di pixel nel tempo. Scegliere una banda che catturerà nel miglior modo i cambiamenti nella feature che si desidera osservare.</p>",
	"@@LandTrendr-Analysis_p-valuethreshold_tag0@@": "<p>Il valore p per un modello da selezionare. Dopo che i vertici sono stati rilevati nello stage iniziale del modello in adattamento, lo strumento si adatterà a ogni segmenti e calcolerà il valore p per determinare la significanza del modello. Nella prossima iterazione, il modello diminuirà il numero di segmenti uno a uno e ricalcolerà il valore p. Questo processo continuerà a, se il valore p è minore del valore specificato in questo parametro, il modello sarà selezionato e lo strumento smetterà di cercare un modello migliore. Se non è selezionato tale modello, lo strumento selezionerà un modello con un valore p inferiore al più basso valore p<strong> × il miglior valore di proporzione del modello</strong>. L'impostazione di default è 0.01.</p>",
	"@@LandTrendr-Analysis_raster_tag0@@": "<p>L'input layer raster multidimensionale Landsat.</p>",
	"@@LandTrendr-Analysis_recoveryhasincreasetrend_tag0@@": "<p>Specifica se il recupero ha un trend crescente (positivo).</p><ul><li>Selezionato-Il recupero ha un trend crescente. Questa è l'impostazione di default</li><li>Selezionato-Il recupero ha un trend decrescente.</li></ul>",
	"@@LandTrendr-Analysis_recoverythreshold_tag0@@": "<p>Il valore di soglia di recupero, in anni. Se un segmento dispone di un tasso di recupero che è più veloce di <strong>1/ recovery threshold</strong>, il segmento viene eliminato e non viene incluso nello stesso modello di serie di volte. Il valore deve oscillare tra 0 e 1. L'impostazione di default è 0.25.</p>",
	"@@LandTrendr-Analysis_snappingdate_tag0@@": "<p>La data utilizzata per selezionare una porzione per ogni anno nel dataset multidimensionale di input. La porzione con la data più vicina alla data di gestione delle intolleranze verrà selezionata. Questo parametro viene richiesto se il dataset di input contiene dati annuali.</p>",
	"@@LandTrendr-Analysis_spikethreshold_tag0@@": "<p>La soglia dell'utilizzo per picchi di smorzamento o anomalie nella traiettoria del valore pixel. Il valore deve oscillare tra 0 e 1, dove 1 significa che non avviene lo smorzamento. L'impostazione di default è 0.9.</p>",
	"@@LandTrendr-Analysis_vertexcountovershoot_tag0@@": "<p>Il numero di vertici aggiuntivi sotto<strong>max_num_segments + 1</strong>può essere utilizzata per adeguare il modello durante lo stage iniziale dei vertici di identificazione. Successivamente, nel processo di modellazione, il numero di vertici aggiuntivi verrà ridotto a <strong>max_num_segments + 1</strong>. L'impostazione di default è 2.</p>",
	"@@Merge-Rasters_rasters_tag0@@": "<p>Dataset raster di input o dataset raster multidimensionali da unire.</p>",
	"@@Merge-Rasters_resolveoverlapmethod_tag0@@": "<p>Specifica il metodo per l'utilizzo per risolvere la sovrapposizione di pixel nei dataset combinati.</p><ul><li><strong>Primo</strong>--Il valore di pixel nelle aree di overlapping è il valore da primo raster nella lista di raster di input. Questa è l'impostazione di default.</li><li><strong>Ultimo</strong>--Il valore pixel nelle aree di sovrapposizione è il valore dall'ultimo raster nella lista di raster di input.</li><li><strong>Min</strong>--Il valore pixel nelle aree di sovrapposizione è il valore minimo dei pixel di sovrapposizione.</li><li><strong>Max</strong>--Il valore pixel nelle aree di sovrapposizione è il valore massimo di pixel di sovrapposizione.</li><li><strong>Media</strong>--Il valore pixel nelle aree di sovrapposizione è la media dei pixel di sovrapposizione.</li><li><strong>Somma</strong>--Il valore pixel nelle aree di sovrapposizione è la somma totale dei pixel di sovrapposizione.</li></ul>",
	"@@Generate-Trend_cycleunit_tag0@@": "<p>Specifica l'unità di tempo da utilizzare per la lunghezza di un ciclo armonico.</p><ul><li><strong>Giorni</strong>--L'unità per la lunghezza del ciclo armonico è giorni.</li><li><strong>Anni</strong>--L'unità per la lunghezza dl ciclo armonico è anni. Questa è l'impostazione di default.</li></ul>",
	"@@Generate-Trend_dimensionname_tag0@@": "<p>La dimensione lungo la quale un trend verrà estratto per la variabile o le variabili selezionate nell'analisi.</p>",
	"@@Generate-Trend_harmonicfrequency_tag0@@": "<p>Il numero di frequenza è da utilizzare nell'adattamento del trend. Questo parametro specifica la frequenza di cicli in un anno. Il valore di default è 1, o un ciclo armonico per anno.</p><p>Questo parametro è incluso solamente nell'analisi del trend per una regressione armonica.</p>",
	"@@Generate-Trend_ignorenodata_tag0@@": "<p>Specifica se valori nodata vengano ignorati nell'analisi.</p><ul><li>Selezionato--L'analisi includerà tutti i pixel validi lungo una dimensione data e ignorerà tutti i pixel nodata. Questa è l'impostazione di default.</li><li>Non selezionata--L'analisi risulterà in nodata se ci sono valori nodata per pixel lungo la dimensione data.</li></ul>",
	"@@Generate-Trend_lengthofcycle_tag0@@": "<p>La lunghezza della variazione periodica da modellare. L'unità è giorni, indipendentemente dall'unità di tempo dei dati di input. Ad esempio, il verde delle foglie ha spesso un forte ciclo di variazione in un solo anno, quindi la lunghezza del ciclo è di 365,25, anche se i dati di input sono il verde mensile. I dati di temperatura oraria hanno un forte ciclo di variazione in un solo giorno, quindi la lunghezza del ciclo è 1.</p><p>La lunghezza predefinita è di 365,25 giorni per i dati che variano su un ciclo annuale.</p>",
	"@@Generate-Trend_p-valueofslopecoefficient_tag0@@": "<p>Specifica se calcolare la statistica del valore p per il coefficiente di pendenza della linea di trend.</p><ul><li>Selezionata--Il valore p sarà calcolato e visualizzato nei dettagli al completamento della funzione.</li><li>Non selezionata--Il valore p non sarà calcolato. Questa è l'impostazione di default.</li></ul>",
	"@@Generate-Trend_polynomialorder_tag0@@": "<p>Il numero di ordine polinominale da utilizzare nell'adattamento del trend. Questo parametro specifica l'ordine polinomiale. Il valore di default è 2, o polinominale di secondo ordine.</p><p>Questo parametro è incluso nell'analisi del trend per una regressione polinominale.</p>",
	"@@Generate-Trend_r-squared_tag0@@": "<p>Specifica se calcolare la statistica bontà di adattamento del coefficiente di determinazione per la linea di adattamento del trend.</p><ul><li>Selezionato--L'indice di determinazione verrà calcolato e mostrato nei dettagli quando la funzione è completa.</li><li>Non selezionato--L'indice di determinazione non sarà calcolato. Questa è l'impostazione di default.</li></ul>",
	"@@Generate-Trend_raster_tag0@@": "<p>Il raster multidimensionale di input.</p>",
	"@@Generate-Trend_rmse_tag0@@": "<p>Specifica se generare la radice dell'errore quadratico medio (RMSE) della linea di adattamento del trend.</p><ul><li>Selezionato--Il RMSE verrà calcolato e mostrato nei dettagli quando la funzione è completa. Questa è l'impostazione di default.</li><li>Selezionato--Il RMSE non verrà calcolato.</li></ul>",
	"@@Generate-Trend_seasonalperiod_tag0@@": "<p>Specifica l'unità di tempo usata per la lunghezza di un periodo stagionale quando viene eseguito un testo Seasonal-Kendall.</p><ul><li>Giorni--L'unità per la lunghezza di un periodo stagionale è giorni. Questa è l'impostazione di default.</li><li>Mesi--L'unità per la lunghezza di un periodo stagionale è mesi.</li></ul>",
	"@@Generate-Trend_trendtype_tag0@@": "<p>Specifica il tipo di linea da utilizzare per adattare i valori dei pixel lungo una dimensione.</p><ul><li><strong>Lineare</strong>: adatta i valori dei pixel per una variabile lungo la linea di trend lineare. Questa è l'impostazione di default.</li><li><strong>Armonica</strong>--Si adatta ai valori dei pixel per una variabile lungo una linea trend armonica.</li><li><strong>Polinominale</strong>--Si adatta ai valori dei pixel per una variabile lungo una linea di trend polinominale di secondo ordine.</li><li><strong>Mann-Kendall</strong>--Valori di pixel variabili verranno valutata utilizzando il testi di trend Mann-Kendall.</li><li><strong>Seasonal Kendall</strong>--Valori di pixel variabili verranno valutati utilizzando test di trend Seasonal-Kendall.</li></ul>",
	"@@Compute-Change_cellsizetype_tag0@@": "<p>Scegliere quale grandezza di cella utilizzare nel raster di output. Se tutte le grandezze di celle di input sono le stesse, tutte le opzioni produrranno gli stessi risultati.</p><ul><li>Primo di: utilizza la prima grandezza di cella dei raster di input.</li><li>Min di: utilizza la grandezza di cella minore di raster di input.</li><li>Max di: utilizza la grandezza di cella maggiore di tutti i raster di input. Questa è l'impostazione di default.</li><li>Media di: utilizza la grandezza di cella media di tutti i raster di input.</li><li>Ultimo di: utilizza l'ultima grandezza di cella di raster di input.</li></ul>",
	"@@Compute-Change_computechangemethod_tag0@@": "<p>Il metodo utilizzato per il calcolo.</p><ul><li><strong>Differenza</strong>: Verrà calcolata la differenza matematica, o sottrazione, tra i valori dei pixel nei raster di ingresso. Questa è l'impostazione predefinita.</li><li><strong>Differenza relativa</strong>: la differenza dei valori in pixel, che tiene conto delle grandezze dei valori confrontati, verrà calcolata.</li><li><strong>Differenza categorica</strong>: la differenza tra due raster categorici o tematici verrà calcolata, dove l'output contiene transizioni di classi che si verificano tra due raster.</li><li><strong>Differenza spettrale euclidea</strong>: la distanza euclidea tra i valori in pixel dei due raster multibanda viene calcolata.</li><li><strong>Differenza angolo spettrale</strong>: viene calcolato l'angolo spettrale tra i valori in pixel dei due raster multibanda. L'output è in radianti.</li><li><strong>Banda con il maggior numero di cambiamenti</strong>: verrà calcolata la banda che rappresenta la variazione maggiore in ogni pixel tra due raster multibanda.</li></ul><p>Se il <strong>metodo di calcolo delle modifiche</strong>è impostato su<strong>Differenza categorica</strong>e uno degli input non è categorico, verrà calcolata una semplice differenza.</p>",
	"@@Compute-Change_definetransitioncolors_tag0@@": "<p>Specifica il metodo da utilizzare per simboleggiare i pixel che hanno cambiato classe.</p><ul><li><strong>Media da e verso i colori</strong>--Il colori del pixel sarà la media del colori della sua classe originale e del colori della classe finale.</li><li><strong>Usa dai colori</strong>--Il colori del pixel sarà il colori della sua classe originale</li><li><strong>Usa a colori</strong>--Il colore del pixel sarà il colori della sua classe finale.</li></ul>",
	"@@Compute-Change_extenttype_tag0@@": "<p>Scegliere quale estensione da utilizzare nel raster di output:</p><ul><li>Primo di: usare l'estensione del primo raster di input per determinare l'estensione in elaborazione.</li><li>Intersezione di: usare l'estensione di pixel sovrapposti per determinare l'estensione in elaborazione. Questa è l'impostazione di default.</li><li>Unione di: usare l'estensione di tutti i raster per determinare l'estensione di elaborazione.</li><li>Ultimo di: usare l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.</li></ul>",
	"@@Compute-Change_filtermethod_tag0@@": "<p>Scegliere il metodo di filtro per un calcolo di modifica categorico.</p><ul><li><strong>Mantieni tutto</strong>--Tutte le classi sono incluse nell'output e non verrà eseguito alcun filtraggio. Scegliere questa opzione per visualizzare la modifica e la persistenza in una dataset singolo.</li><li><strong>Mantieni solo pixel cambiati</strong>--Solamente le classi che hanno cambiato da un tipo di classe a un altro tipo di classe sono incluse nell'output. Scegliere questa opzione se si è interessati alla modifica.</li><li><strong>Mantieni solo pixel non cambiati</strong>--Solamente le classi che non hanno cambiato sono incluse nell'output. Scegliere questa opzione se si è interessati nella persistenza.</li></ul>",
	"@@Compute-Change_fromclassvalues_tag0@@": "<p>Il valore della classe da<strong>Da raster</strong>incluso nel calcolo, se comparando due raster categorici. Questa è una lista separata da spazi di valori interi corrispondenti al campo <strong>ValoreClasse</strong> nel dataset del raster di input.</p>",
	"@@Compute-Change_fromraster_tag0@@": "<p>Il primo raster da utilizzare nel calcolo. Per valutare la modifica dalla volta 1 (prima) alla 2 (più tardi), digitare il raster di volta 1 quì.</p>",
	"@@Compute-Change_toclassvalues_tag0@@": "<p>I valori di classe da <strong>Raster to</strong>da includere nel calcolo, se comparando due raster categorici. Questa è una lista separata da spazi di valori interi corrispondenti al campo <strong>ValoreClasse</strong> nel dataset del raster di input.</p>",
	"@@Compute-Change_toraster_tag0@@": "<p>Il secondo raster da utilizzare nel calcolo. Per valutare la modifica dalla volta 1 (prima) alla 2 (più tardi), digitare il raster di volta 2.</p>",
	"@@Compute-Change_usecolormethod_tag0@@": "<p>Specifica il metodo da utilizzare per simboleggiare i pixel che hanno cambiato classe.</p><ul><li><strong>Media da e verso i colori</strong>--Il colori del pixel sarà la media del colori della sua classe originale e del colori della classe finale.</li><li><strong>Usa dai colori</strong>--Il colori del pixel sarà il colori della sua classe originale</li><li><strong>Usa a colori</strong>--Il colore del pixel sarà il colori della sua classe finale.</li></ul>",
	"@@Compute-Change_fieldnameforclassnamesinfromraster_tag0@@": "<p>Un campo che memorizza i nomi delle classi nell'input <strong>Da Raster</strong>. Lo strumento cerca automaticamente il campo <strong>Nome classe</strong> o <strong>Nome_classe</strong> da utilizzare.</p><p>Usa questa opzione se l'input non contiene questi nomi di campi standard.</p>",
	"@@Compute-Change_fieldnameforclassnamesintoraster_tag0@@": "<p>Un campo che memorizza i nomi delle classi nell'input <strong>A Raster</strong>. Lo strumento cercherà automaticamente il campo <strong>Nome classe</strong> o <strong>Nome_classe</strong> da utilizzare.</p><p>Usa questa opzione se l'input non contiene questi nomi di campi standard.</p>",
	"@@Statistics_numberofcolumns_tag0@@": "<p>Il numero di colonne di pixel da utilizzare in una dimensione focale di vicinanza.</p>",
	"@@Statistics_numberofrows_tag0@@": "<p>Il numero di righe di pixel da utilizzare in una dimensione focale di vicinanza.</p>",
	"@@Statistics_onlyfillnodatapixels_tag0@@": "<p>Riempie le lacune NoData in uscita. Questa funzione è utile quando sono presenti linee rimosse nell'immagine.</p>",
	"@@Statistics_raster_tag0@@": "<p>Il raster input su cui eseguire le statistiche focali.</p>",
	"@@Statistics_statisticstype_tag0@@": "<p>I seguenti sono sette tipi di funzioni statistici focali:</p><ul><li>Minimo: calcola il valore minimo dei pixel all'interno di un quartiere.</li><li>Massimo: calcola il valore massimo di pixel all'interno di un quartiere.</li><li>Medio: calcola il valore medio dei pixel all'interno di un quartiere. Questa è l'impostazione di default.</li><li>Deviazione standard: calcola il valore di deviazione standard dei pixel all'interno di un quartiere.</li><li>Mediano: calcola il valore mediano dei pixel all'interno di un quartiere.</li><li>Maggioranza: calcola il valore di maggioranza, o il valore che si verifica più frequentemente dei pixel all'interno di un quartiere.</li><li>Minoranza: calcola il valore di minoranza o il valore che si verifica meno frequentemente dei pixel all'interno di un quartiere.</li></ul>",
	"@@Detect-Change-Using-Change-Analysis_changedirection_tag0@@": "<p>Specifica la direzione del cambiamento da includere nell'analisi.</p><p>Questo parametro è disponibile solamente quando il raster di analisi di modifica dell'input è l'output dagli strumenti LandTrendr.</p><ul><li><strong>Tutte le direzioni</strong>--Tutte le direzioni di modifica sono incluse nell'output. Questa è l'impostazione di default.</li><li><strong>Crescente</strong>--Solamente la modifica in direzione positiva o crescente è inclusa nell'output.</li><li><strong>Decrescente</strong>--Solamente la modifica in direzione negativa o decrescente è inclusa nell'output.</li></ul>",
	"@@Detect-Change-Using-Change-Analysis_changetype_tag0@@": "<p>Specifica l'informazione di modifica da calcolare.</p><ul><li><strong>Orario dell'ultimo cambiamento</strong>--Ogni pixel contiene la data di modifica più recente per quel pixel in una serie di orari. Questa è l'impostazione di default.</li><li><strong>Orario di modifica più recente</strong>--Ogni pixel contiene la data della prima modifica per quel pixel nella serie di orari.</li><li><strong>Orario della modifica maggiore</strong>--Ogni pixel contiene la data della modifica più significativa per quel pixel nella serie di orari.</li><li><strong>Numero di modifiche</strong>-Ogni pixel contiene il numero totale di volte che il pixel è cambiato nella serie di orari.</li><li><strong>Orario di modifica più lunga</strong>--Ogni pixel contiene la data della modifica alla fine del segmento di transizione più lungo nella serie di orari.</li><li><strong>Orario di modifica più breve</strong>--Ogni pixel contiene la data della modifica alla fine del segmento di transizione più breve della serie di orari.</li><li><strong>Orario di modifica più veloce</strong>--Ogni pixel contiene la data della modifica alla fine della transizione che si è verificato più rapidamente.</li><li><strong>Orario di modifica più lenta</strong>--Ogni pixel contiene la data della modifica alla fine della transizione che si è verificato più lentamente.</li></ul>",
	"@@Detect-Change-Using-Change-Analysis_filterbyduration_tag0@@": "<p>Specifica se filtrare secondo durata di modifica.</p><p></p><ul><li>Selezionato--Filtra risultati per durata in modo che solamente le modifiche che sono durate per un determinato periodo di tempo siano incluse nell'output.</li><li>Non selezionato--Non filtra risultati per durata. Questa è l'impostazione di default.</li></ul><p>Questo parametro è disponibile solo quando il raster di analisi di modifica dell'input è l'output dagli strumenti LandTrendr.</p><p>Se questo parametro è selezionato, si devono impostare i parametri <strong>Durata minima</strong>e <strong>Durata massima</strong> per filtrare.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbymagnitude_tag0@@": "<p>Specifica se filtrare per grandezza di modifica.</p><ul><li>Selezionato: filtra i risultati per grandezza in modo che solamente le modifiche di una grandezza data siano incluse nell'output.</li><li>Non selezionato: non filtra i risultati per grandezza. Questa è l'impostazione di default.</li></ul><p>Questo parametro è disponibile solo quando l'input del raster di analisi di modifica è l''output dagli strumenti LandTrendr.</p><p>Se questo parametro è selezionato si devono impostare i parametri <strong>Grandezza minima</strong>e<strong>Grandezza massima</strong>per il filtraggio.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbyyear_tag0@@": "<p>Specifica se limitare l'output secondo un range di anni.</p><ul><li>Selezionato: filtra i risultati in modo che solamente le modifiche che occorrono all'interno di un range di anni specifico sono incluse nell'output.</li><li>Non selezionato: non filtra risultati per anno. Questa è l'impostazione di default.</li></ul><p>Se questo parametro è selezionato, si devono impostare i parametri <strong>Valore minimo</strong>e<strong>Valore massimo</strong> per il filtraggio.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbystartvalue_tag0@@": "<p>Filtra i risultati per valore iniziale in modo che solo i cambiamenti di un dato valore iniziale siano inclusi nell'output.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbyendvalue_tag0@@": "<p>Filtra i risultati per valore finale in modo che solo i cambiamenti di un dato valore finale siano inclusi nell'output.</p>",
	"@@Detect-Change-Using-Change-Analysis_maximumnumberofchanges_tag0@@": "<p>Il numero massimo di modifiche per pixel da calcolare. Il numero inserito corrisponde al numero delle bande nel raster di output. L'impostazione di default e 1, significa solo che una delle date di modifiche è calcolata e il raster di output contiene solo una banda.</p><p>Questo parametro non è disponibile quando il parametro <strong>Cambia tipo</strong> è impostato su <strong>Numero di modifiche</strong>.</p>",
	"@@Detect-Change-Using-Change-Analysis_raster_tag0@@": "<p>Il raster di analisi di modifica di input.</p>",
	"@@Detect-Change-Using-Change-Analysis_segmentdate_tag0@@": "<p>Specifica se estrarre la data all'inizio di un segmento di modifica o alla fine.</p><p>Questo parametro è disponibile solo quando il raster di analisi di modifica dell'input è l'output dagli strumenti LandTrendr.</p><ul><li><strong>Inizio del segmento</strong>--Estrarre la data all'inizio di un segmento di modifica. Questa è l'impostazione di default.</li><li><strong>Fine del segmento</strong>--Estrarre la data alla fine di un segmento di modifica.</li></ul>",
	"@@Kernel-Density_areaunits_tag0@@": "<p>L'unità di area dei valori di densità dell'output.</p><ul><li>Unità di mappa quadrata: per il quadrato delle unità lineari del riferimento spaziale di uscita.</li><li>Miglia quadrate: per miglia (U.S.).</li><li>Kilometri quadrati: per kilometri.</li><li>Acri: per acri (U.S.).</li><li>Ettari: per ettari.</li><li>Metri quadrati: per metri.</li><li>Iarde quadrate: per iarde (U.S.).</li><li>Piedi quadrati: per piedi (U.S.).</li><li>Pollici quadrati: per pollici (U.S.).</li><li>Centimetri quadrati: per centimetri.</li><li>Millimetri quadrati: per millimetri.</li></ul>",
	"@@Kernel-Density_cellsize_tag0@@": "<p>La grandezza del pixel per il dataset del raster di output. Se il valore <strong>Dimensione cella</strong> è stato impostato negli ambienti di geoprocessing, è l'impostazione di default.</p>",
	"@@Kernel-Density_inputbarriers_tag0@@": "<p>Il dataset che definisce le barriere.</p><p>Le barriere possono essere un layer feature di polilinee o feature di poligono.</p>",
	"@@Kernel-Density_inputfeatures_tag0@@": "<p>Il punto di input o le feature di linea per le quali calcolare la densità.</p>",
	"@@Kernel-Density_method_tag0@@": "<p>Determina se usare un percorso più breve su uno sferoide (geodesic) o un metodo erra piatta (planare).</p><ul><li><strong>Planare</strong>--Utilizza distanze planari tra le feature. Questa è l'impostazione di default.</li><li><strong>Geodesic</strong>--Utilizza distanze geodesic tra feature. Questo metodo prende in considerazione la curvatura di uno sferoide e si occupa dei dati vicini ai poli e le linee cambiamento data internazionali.</li></ul><p>Si raccomanda di utilizzare il metodo <strong>Geodesic</strong> con dati salvati in un sistema coordinato che non è appropriato per le misurazioni della distanza e altre analisi che sono situati in un'area geografica larga. Per esempio, un Web Mercator o altro sistema di coordinate geografiche dovrebbe utilizzare il metodo <strong>Geodesic</strong>.</p>",
	"@@Kernel-Density_outputcellvalues_tag0@@": "<p>Determina cosa rappresentano i valori nel raster di output.</p><ul><li><strong>Densità</strong>--I valori di output rappresentano il valore di densità predetto. Questa è l'impostazione di default.</li><li><strong>Conteggi previsti</strong>--I valori di output rappresentano il valore predetto del fenomeno all'interno di ogni pixel. Dal momento che il valore del pixel è collegato al valore specifico <strong>Dimensione cella</strong>, il raster risultante non può essere ricampionato in una diversa dimensione di pixel e rappresenterà comunque le dimensioni del fenomeno.</li></ul>",
	"@@Kernel-Density_populationfield_tag0@@": "<p>Campo che indica i valori della popolazione per ogni caratteristica. Il valore <strong>Campo popolazione</strong> è il conteggio o la quantità da spargere nel paesaggio per creare una superficie continua. I valori nel <strong>campo popolazione</strong> possono essere interi o in virgola mobile.</p><p>Le opzioni e i comportamenti predefiniti per il campo sono elencati di seguito nell'ordine di priorità.</p><ul><li>Utilizzo<strong>Nessuno</strong>se nessun elemento o valore speciale sarà usato e ogni caratteristica sarà contata una volta.</li><li>Utilizzo<strong>Forma</strong>se le caratteristiche di input contengono Z.</li><li>Altrimenti, il campo predefinito è<strong>POPOLAZIONE</strong>, o qualsiasi derivato accettabile di popolazione:<ul><li><strong>POPOLAZIONExxxxxx</strong>where<strong>xxxxxx</strong>can essere qualsiasi carattere valido, come<strong>POPOLAZIONE6</strong>,<strong>POPOLAZIONE1974</strong>, or<strong>POPOLAZIONEATIPO</strong>.</li><li><strong>POP</strong>.</li><li><strong>POPxxxxxx</strong>.</li><li>Se nessuno dei precedenti si applica, il valore predefinito è<strong>Nessuno</strong>.</li></ul></li></ul>",
	"@@Kernel-Density_searchradius_tag0@@": "<p>Il raggio di ricerca all'interno del quale calcolare la densità. Le unità sono basate su un'unità lineare del progetto.</p><p>Per esempio, se le unità sono in metri, per includere tutte le feature in un quartiere di un miglio, impostare il raggio di ricerca uguale a 1609,344 (poiché 1 miglio = 1609,344 metri).</p>",
	"@@Zonal-Statistics_ignorenodataincalculations_tag0@@": "<p>Denota se i valori <strong>NoData</strong> nel <strong>Raster valore</strong> influenzeranno i risultati della zona in cui ricadono.</p><ul><li><strong>Sì</strong>--All'interno di qualsiasi particolare zona, solo i pixel che hanno un valore in <strong>Raster valore</strong> verranno utilizzati per determinare il valore di output per quella zona. I pixel <strong>NoData</strong> in <strong>Raster valore</strong> verrà ignorato nel calcolo statistico. Questa è l'impostazione di default.</li><li><strong>No</strong>: All'interno di qualsiasi zona particolare, se esistono pixel <strong>NoData</strong> nel <strong>Raster di valori</strong>, si considera che vi siano informazioni insufficienti per eseguire i calcoli statistici per tutti i pixel nella zona; per questa ragione, l'intera zona riceverà il valore <strong>NoData</strong> nel raster di output.</li></ul>",
	"@@Zonal-Statistics_percentileinterpolationtype_tag0@@": "<p>Determina il metodo di interpolazione percentile da usare quando il numero di valori dal raster di input da calcolare sono uniformi.</p><ul><li><strong>Rilevamento automatico</strong>: se il raster di valore di input è di tipo pixel intero, viene utilizzato il metodo <strong>Più vicino</strong>. Se il raster di valore di input è di tipo punto pixel mobile, allora viene usare il metodo <strong>Lineare</strong>. Questa è l'impostazione predefinita.</li><li><strong>Più vicino</strong>: il valore più vicino disponibile viene usato per il percentile desiderato. In questo caso, il tipo di pixel di output è lo stesso del raster di valore di input.</li><li><strong>Lineare</strong>: la media pesata dei due valori circostanti viene usata per il percentile desiderata. In questo caso, il tipo di pixel di output è il punto mobile.</li></ul>",
	"@@Zonal-Statistics_percentilevalue_tag0@@": "<p>Il percentile da calcolare. Il valore predefinito è 90 per il 90esimo percentile.</p><p>I valori può oscillare da 0 a 100. Il percentile numero 0 è essenzialmente l'equivalente della statistica minima e il percentile numero 100 è l'equivalente della statistica massima. Un valore pari a 50 produrrà essenzialmente lo stesso risultato di una statistica mediana.</p>",
	"@@Zonal-Statistics_processasmultidimensional_tag0@@": "<p>Determina come il raster di valore multidimensionale di input è elaborato.</p><ul><li><strong>Selezione corrente</strong>: si calcoleranno le statistiche della sezione corrente di un dataset multidimensionale. Questa è l'impostazione di default.</li><li><strong>Tutte le sezioni</strong>: si calcoleranno le statistiche per tutte le dimensioni (come tempo o profondità) di un dataset multidimensionale.</li></ul>",
	"@@Zonal-Statistics_statisticstype_tag0@@": "<p>Tipo statistico da calcolare.</p><ul><li><strong>Medio</strong>: calcola la media di tutti i pixel in <strong>Raster valore</strong> che appartengono alla stessa zona di quella del pixel di output.</li><li><strong>Maggioranza</strong>: determina il valore che occorre più frequentemente di tutti i pixel in <strong>Raster valore</strong> che appartengono alla stessa zona del pixel di output.</li><li><strong>Massimo</strong>: determina il valore maggiore di tutti i pixel in <strong>Raster valore</strong> che appartengono alla stessa zona del pixel di output.</li><li><strong>Mediano</strong>: determina il valore mediano di tutti i pixel in <strong>Raster valore</strong> che appartengono alla stessa zona del pixel di output.</li><li><strong>Minimo</strong>: determina il valore più basso di tutti i pixel in <strong>Raster valore</strong> che appartengono alla stessa zona del pixel output.</li><li><strong>Minoranza</strong>: determina il valore che occorre meno frequentemente di tutti i pixel nel <strong>Raster valore</strong> che appartengono alla stessa zona del pixel di output.</li><li><strong>Percentile</strong>: calcola una percentile di tutti i pixel in <strong>Raster valore</strong> che appartengono alla stessa zona del pixel di output. Il 90esimo percentile è calcolato secondo impostazioni predefinite. È possibile determinare quale percentile da calcolare con il parametro <strong>Valore percentile</strong>.</li><li><strong>Range</strong>: calcola la differenza tra il valore maggiore e minore di tutti i pixel in <strong>Raster valore</strong>che appartengono alla stessa zone del pixel di output.</li><li><strong>Deviazione standard</strong>: calcola la deviazione standard di tutti i pixel in <strong>Raster valore</strong>che appartengono alla stessa zona del pixel di output.</li><li><strong>Somma</strong>: calcola il valore totale di tutti i pixel in <strong>Raster valore</strong>che appartengono alla stessa zona del pixel di output.</li><li><strong>Varietà</strong>: calcola il numero di valori unici per tutti i pixel in <strong>Raster valore</strong>che appartengono alla stessa zona del pixel di output.</li></ul>",
	"@@Zonal-Statistics_valueraster_tag0@@": "<p>Raster che contiene i valori in base ai quali calcolare una statistica.</p>",
	"@@Zonal-Statistics_zonefield_tag0@@": "<p>Campo che contiene i valori che definiscono ogni zona. Può essere un numero intero o un campo stringa del raster di zona.</p>",
	"@@Zonal-Statistics_zoneraster_tag0@@": "<p>Dataset che definisce le zone. Le zone possono essere definite da un raster intero.</p>",
	"@@Zonal-Statistics_calculatecircularstatistics_tag0@@": "<p>Specifica la modalità con cui verrà calcolato il tipo di statistiche.</p><ul><li><strong>Aritmetica</strong>: calcola statistiche aritmetiche. È l'impostazione predefinita.</li><li><strong>Circolare</strong>: calcola statistiche circolari appropriate per quantità cicliche, ad esempio direzione bussola in gradi, ore del giorno e parti frazionarie di numeri reali.</li></ul>",
	"@@Zonal-Statistics_circularwrapvalue_tag0@@": "<p>Il massimo valore possibile (limite superiore) nei dati ciclici. È un numero positivo il cui valore predefinito è 360. Questo valore rappresenta anche la stessa quantità del minimo valore possibile (limite inferiore).</p><p>Questo parametro è applicabile solo quando vengono calcolate statistiche circolari.</p>",
	"@@Boundary-Clean-function_inputraster_tag0@@": "<p>Il raster di input per il quale il confine tra zone verrà smussato.</p><p>Deve essere di tipo intero.</p>",
	"@@Boundary-Clean-function_runexpansionandshrinkingtwice_tag0@@": "<p>Specifica il numero di volte che il processo di smussamento si verificherà, due volte o una volta.</p><ul><li><p><strong>Selezionato</strong>: esegue un'espansione e un'operazione di contrazione due volte. Per la prima volta, l'operazione viene eseguita secondo il tipo di ordinamento specifico. Poi un'espansione e un'operazione di contrazione aggiuntive vengono eseguite con la priorità invertita. Questa è l'impostazione di default.</p></li><li><p><strong>Non selezionato</strong>: esegue l'espansione e l'operazione di contrazione una volta secondo il tipo di ordinamento.</p></li></ul>",
	"@@Boundary-Clean-function_sorttype_tag0@@": "<p>Specifica il tipo di ordinamento da usare nel processo di smussamento. L'ordinamento determina la priorità secondo la quale le celle possono espandersi nelle vicinanze.</p><p>L'ordinamento può essere effettuato sulla base di zone di valore o aree di zone.</p><ul><li><p><strong>Non ordinare</strong>: le zone non vengono ordinate per dimensione. Zone con valori maggiori hanno una priorità più alta di espandersi in zone con valori minori nell'output smussato. Questa è l'impostazione di default.</p></li><li><p><strong>Decrescente</strong>: ordina le zone in ordine decrescente secondo la dimensione. Le zone con area totale maggiore hanno la priorità di espandersi in zone con aree totali minori. Questa opzione tende a eliminare o ridurre la prevalenza di celle da zone minori nell'output smussato.</p></li><li><p><strong>Crescente</strong>: ordina le zone in ordine crescente per dimensione. Le zone con aree totali minori hanno una priorità più alta di espandersi in zone con aree totali maggiori. Questa opzione tende a preservare o aumentare la prevalenza di celle con zone minori nell'output smussato.</p></li></ul>",
	"@@Aggregate-Multidimensional_dimension_tag0@@": "<p>Dimensione di aggregazione. Questa è la dimensione lungo la quale verranno aggregate le variabili.</p>",
	"@@Aggregate-Multidimensional_dimensiondefinition_tag0@@": "<p>Specifica il metodo da usare per filtrare i dati multidimensionali di input prima di eseguire l'aggregazione.</p><ul><li><strong>Tutto</strong>--Si utilizzerà l'intervallo completo per ciascuna dimensione. Questa è l'impostazione predefinita.</li><strong><li>Per valori</strong>: la dimensione verrà suddivisa utilizzando un valore di dimensione o un elenco di valori.</li><li><strong>Per intervalli</strong>: la dimensione verrà suddivisa utilizzando un intervallo o un elenco di intervalli.</li><li><strong>Per iterazione</strong>: la dimensione sarà suddivisa su una dimensione di intervallo specificata.</li></ul>",
	"@@Aggregate-Multidimensional_iterationdefinitionparameters_tag0@@": "<p>I parametri di definizione dell'iterazione consentono di definire i valori di dimensione da utilizzare per filtrare i dati multidimensionali di input per l'analisi quando il parametro <strong>Definizione di dimensione</strong> è impostato su <strong>Per iterazione</strong>.</p><ul><li><strong>Dimensione</strong> - La dimensione da utilizzare per il filtraggio.</li><li><strong>Inizio della prima iterazione</strong>: l'inizio del primo intervallo. Questo intervallo viene utilizzato per scorrere il set di dati.</li><li><strong>Fine della prima iterazione</strong>: la fine del primo intervallo. Questo intervallo viene utilizzato per scorrere il set di dati.</li><li><strong>Step</strong>: la frequenza con cui i dati verranno suddivisi.</li><li><strong>Unità</strong>: l'unità di iterazione.</li></ul>",
	"@@Aggregate-Multidimensional_keywordinterval_tag0@@": "<p>Specifica l'intervallo di parole chiave che verrà utilizzato durante l'aggregazione lungo la dimensione.</p><p>Questo parametro è obbligatorio quando il parametro<strong>Tipo</strong> è impostato su <strong>Parola chiave intervallo</strong>.</p><ul><li><strong>Ora</strong>: i valori dei dati vengono aggregati in fasi temporali orarie e il risultato include ogni ora nella serie temporale. Questa è l'impostazione predefinita.</li><li><strong>Quotidiano</strong>: i valori dei dati vengono aggregati in fasi temporali giornaliere e il risultato include ogni giorno nelle serie temporali.</li><li><strong>Settimanale</strong>: i valori dei dati vengono aggregati in fasi temporali settimanali e il risultato include ogni settimana nella serie temporali.</li><li><strong>Dekadly</strong>: i valori dei dati vengono aggregati in 3 periodi di 10 giorni ciascuno. L'ultimo periodo può contenere più o meno di 10 giorni. L'output include 3 sezioni per ogni mese.</li><li><strong>Pentadly</strong> - I valori dei dati vengono aggregati in 6 periodi di 5 giorni ciascuno. L'ultimo periodo può contenere più o meno di 5 giorni. L'output include 6 sezioni per ogni mese.</li><li><strong>Mensile</strong>: i valori dei dati vengono aggregati in fasi temporali mensili e il risultato include ogni mese nelle serie temporali.</li><li><strong>Trimestrale</strong>: i valori dei dati vengono aggregati in fasi temporali trimestrali e il risultato include ogni trimestre nelle serie temporali.</li><li><strong>Annuale</strong>: i valori dei dati vengono aggregati in fasi temporali annuali e il risultato include ogni anno nelle serie temporali.</li><li><strong>Ricorrente giornalmente</strong>: i valori dei dati vengono aggregati in fasi temporali giornaliere e il risultato ne include una valore aggregato per giorno giuliano. L'output include al massimo 366 intervalli di tempo giornalieri.</li><li><strong>Ricorrenti settimanalmente</strong>: i valori dei dati vengono aggregati in intervalli di tempo settimanali e il risultato include un valore aggregato a settimana. L'output include al massimo 53 intervalli di tempo settimanali.</li><li><strong>Ricorrenti mensilmente</strong>: i valori dei dati vengono aggregati in intervalli di tempo settimanali e il risultato include un valore aggregato a settimana. L'output include al massimo 12 intervalli di tempo mensilmente.</li><li><strong>Ricorrenti trimestralmente</strong>: i valori dei dati vengono aggregati in intervalli di tempo settimanali e il risultato include un valore aggregato a settimana. L'output include al massimo 4 periodi di tempo trimestrali.</li></ul>",
	"@@Aggregate-Multidimensional_operation_tag0@@": "<p>Specifica il metodo matematico che verrà utilizzato per combinare le sezioni aggregate in un intervallo.</p><ul><li><strong>Maggioranza</strong>: il valore dei pixel che si è verificato più frequentemente verrà calcolato su tutte le sezioni nell'intervallo.</li><li><strong>Massimo</strong>: il valore massimo di un pixel verrà calcolato tutte le sezioni nell'intervallo.</li><li><strong>Media</strong>: la media dei valori di un pixel verrà calcolata su tutte le sezioni nell'intervallo. Questo è il valore predefinito.</li><li><strong>Mediano</strong>: il valore mediano di un pixel verrà calcolato su tutte le sezioni nell'intervallo.</li><strong><li>Minimo</strong>: il valore minimo di un pixel verrà calcolato su tutte le sezioni nell'intervallo.</li><li><strong>Minoranza</strong>: il valore del pixel che si è verificato con minore frequenza verrà calcolato su tutte le sezioni nell'intervallo.</li><strong> <li>Intervallo</strong>: l'intervallo di valori per un pixel verrà calcolato su tutte le sezioni nell'intervallo.</li><li><strong>Deviazione standard</strong>: la deviazione standard dei valori di un pixel verrà calcolata su tutte le sezioni nell'intervallo.</li><li><strong>Somma</strong>: la somma dei valori di un pixel verrà calcolata su tutte le sezioni nell'intervallo.</li><li><strong>Varietà</strong>: il numero di valori di pixel univoci verrà calcolato su tutte le sezioni nell'intervallo.</li></ul><p>Tutte le opzioni hanno anche un equivalente con un Ignora l'opzione NoData. Questi eseguiranno l'operazione matematica su tutti i pixel validi lungo la dimensione e ignoreranno i pixel NoData.</p>",
	"@@Aggregate-Multidimensional_ranges_tag0@@": "<p>Le ampiezze intervallo specificate nella tabella verranno utilizzate per aggregare gruppi di valori. I valori minimo e massimo specificano l'intervallo da includere.</p><p>Questo parametro è richiesto quando il parametro<strong>Tipo</strong>è impostato su <strong>Ampiezze intervallo</strong>.</p>",
	"@@Aggregate-Multidimensional_raster_tag0@@": "<p>Il raster multidimensionale di input.</p>",
	"@@Aggregate-Multidimensional_type_tag0@@": "<p>Specifica l'intervallo di dimensione per il quale i dati verranno aggregati.</p><ul><li><strong>Tutti</strong>: i dati variabili verranno aggregati in tutte le sezioni. Questa è l'impostazione predefinita.</li><li><strong>Parola chiave intervallo</strong>: i dati della variabile verranno aggregati utilizzando un intervallo comunemente noto.</li><li><strong>Valore intervallo</strong>: i dati della variabile verranno aggregati utilizzando un intervallo e un'unità specificati dall'utente.</li><li><strong>Gamme intervalli</strong>: i dati della variabile verranno aggregati tra coppie di valori o date specificate.</li></ul>",
	"@@Aggregate-Multidimensional_valueinterval_tag0@@": "<p>La dimensione dell'intervallo utilizzato per l'aggregazione.</p><p>Questo parametro è obbligatorio quando il parametro <strong>Tipo</strong> è impostato su <strong>Valore intervallo</strong>.</p>",
	"@@Aggregate-Multidimensional_values_tag0@@": "<p>I valori delle dimensioni da utilizzare per filtrare i dati multidimensionali di input per l'analisi. Questo parametro è obbligatorio quando il parametro<strong>Definizione dimensione</strong> è impostato su<strong>Per valori</strong>.</p>",
	"@@Aggregate-Multidimensional_variables_tag0@@": "<p>La variabile o le variabili che verranno aggregate lungo la dimensione specificata.</p>",
	"@@Predict-Using-Regression_inputdefinitionfile_tag0@@": "<p>Il file di definizione del metodo di regressione di Esri (<strong>.ecd</strong>) che contiene le statistiche e informazioni per lo specifico dataset, modello di regressione e per gli attributi scelti.</p>",
	"@@Predict-Using-Regression_rasters_tag0@@": "<p>I dataset raster o dataset che rappresentano le variabili di predizione. Può essere un raster a banda singola, multipla o multidimensionale, un dataset mosaico o una raccolta di raster.</p>",
	"@@Cell-Statistics_operation_tag0@@": "<p>Il tipo di calcolo statistico che si desidera eseguire.</p><p>Le statistiche disponibili sono<strong>Maggioranza</strong>,<strong>Massimo</strong>,<strong>Media</strong>,<strong>Mediana</strong>,<strong>Minimo</strong>,<strong>Minoranza</strong>,<strong>Percentile</strong>,<strong>Intervallo</strong>,<strong>Deviazione standard</strong>,<strong>Somma</strong> e<strong>Varietà</strong>.</p><p>Il valore predefinito è<strong>Media</strong>.</p>",
	"@@Colormap-To-RGB_randomlyassigncolortounmappedpixels_tag0@@": "<p>I colori vengono assegnati casualmente ai pixel che non sono inclusi nella mappa dei colori.</p><ul><li>Deselezionato: ai pixel non mappati non viene assegnato un colore. Questa è l'impostazione predefinita.</li><li>Selezionato: ai pixel non mappati viene assegnato un colore.</li></ul>",
	"@@Pansharpen_sensor_tag0@@": "<p>Quando si sceglie l'algoritmo Gram-Schmidt, è anche possibile specificare il sensore che ha raccolto il raster multibanda di input. La scelta del tipo di sensore imposterà pesi di banda adeguati.</p>",
	"@@Dimensional-Moving-Statistics_backwardwindow_tag0@@": "<p>Il valore di quante slice prima o dopo essere incluse nella finestra definita. Il valore deve essere un numero intero positivo compreso tra 1 e 100. Il valore predefinito è 1.</p><p>L'unità di questo parametro è slice.</p>",
	"@@Dimensional-Moving-Statistics_circularwrapvalue_tag0@@": "<p>Il valore che verrà utilizzato per arrotondare un valore lineare all'intervallo di una data media circolare.</p><p>Il suo valore deve essere positivo. Il valore predefinito è 360 gradi.</p>",
	"@@Dimensional-Moving-Statistics_dimension_tag0@@": "<p>Il nome della dimensione lungo la quale si sposterà la finestra.</p><p>Il valore predefinito è la prima dimensione diversa da x,y trovata nel raster multidimensionale di input.</p>",
	"@@Dimensional-Moving-Statistics_forwardwindow_tag0@@": "<p>Il valore di quante sezioni successive o inferiori devono essere incluse nella finestra definita. Il valore deve essere un numero intero positivo compreso tra 1 e 100. Il valore predefinito è 1.</p><p>L'unità di questo parametro è slice.</p>",
	"@@Dimensional-Moving-Statistics_inputraster_tag0@@": "<p>Il raster di input può essere solo un raster multidimensionale in formato Cloud Raster (file <strong>.crf</strong>).</p>",
	"@@Dimensional-Moving-Statistics_nodatahandling_tag0@@": "<p>Specifica come verranno gestiti i valori NoData dal calcolo statistico.</p><ul><li><strong>Dati</strong>--I valori NoData nel valore immesso verranno ignorati nei risultati della finestra definita in cui rientrano. Questa è l'impostazione predefinita.</li><li><strong>NoData</strong>--I valori di output saranno NoData se esistono valori NoData nell'input all'interno della finestra definita.</li><li><strong>Compila NoData</strong>--I valori delle celle NoData verranno sostituiti utilizzando la statistica selezionata all'interno della finestra definita.</li></ul>",
	"@@Dimensional-Moving-Statistics_percentileinterpolationtype_tag0@@": "<p>Specifica il metodo di interpolazione che verrà utilizzato quando il valore percentile rientra tra due valori di cella.</p><ul><li><strong>Rilevamento automatico</strong>--Se il raster di input è di tipo pixel intero, sarà usato il metodo<strong>più vicino</strong>. Se il raster di input è di tipo pixel float, sarà usato il metodo<strong>Lineare</strong>. Questa è l'impostazione predefinita.</li><li><strong>Più vicino</strong>--il valore più vicino disponibile viene usato per il percentile. In questo caso, il tipo di pixel di output è lo stesso del raster di valore di input.</li><li><strong>Lineare</strong>: la media pesata dei due valori circostanti viene usata per il percentile. In questo caso, il tipo di pixel in uscita sarà a virgola mobile.</li></ul>",
	"@@Dimensional-Moving-Statistics_percentilevalue_tag0@@": "<p>Il percentile che verrà calcolato quando<strong>Percentile</strong>è selezionato come tipo di statistica. Il valore predefinito è 90 per il 90esimo percentile.</p><p>I valori può oscillare da 0 a 100. Il percentile numero 0 è essenzialmente l'equivalente della statistica minima, e il percentile numero 100 è l'equivalente della statistica massima, fatta eccezione per il fatto che il risultato sarà una virgola mobile. Un valore di 50 produrrà lo stesso risultato della statistica mediana.</p>",
	"@@Dimensional-Moving-Statistics_statisticstype_tag0@@": "<p>Specifica il tipo di statistica da calcolare.</p><p></p><ul><li><strong>Media</strong>--Verrà calcolata la media (valore medio) delle celle nella finestra definita. Questa è l'impostazione predefinita.</li><li><strong>Media circolare</strong>--Verrà calcolata la media circolare delle celle nella finestra definita. Quando è selezionato questo tipo di statistica, il parametro<strong>v</strong>alore wrap circolare diventa disponibile.</li><li><strong>Maggioranza</strong>--Verrà identificata la maggior parte (valore che si verifica più spesso) delle celle nella finestra definita.</li><li><strong>Massimo</strong>--Verrà identificato il massimo (valore più grande) delle celle nella finestra definita.</li><li><strong>Mediana</strong>--Sarà identificata la mediana delle celle del vicinato.</li><li><strong>Minimo</strong>--Verrà identificato il minimo (valore più piccolo) delle celle nelle vicinanze.</li><li><strong>Percentile</strong>--Verrà calcolato un percentile delle celle del vicinato. Quando questo tipo di statistiche è selezionato, diventano disponibili i parametri<strong>Valore Percentile</strong>e<strong>Tipo di interpolazione percentile</strong>. Utilizzare questi parametri per designare il percentile da calcolare e scegliere rispettivamente il tipo di interpolazione da utilizzare.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_dimension_tag0@@": "<p>La dimensione per l'uso dell'interpolazione.</p><p>Questo parametro è necessario quando il parametro <strong>Definzione dimensioni</strong>è impostato a<strong>Per intervallo</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_dimensiondefinition_tag0@@": "<p>Specifica il metodo che verrà utilizzato per filtrare i dati multidimensionali di input prima di eseguire l'interpolazione.</p><ul><li><strong>Per valori</strong>: La dimensione verrà suddivisa utilizzando un valore di dimensione o un elenco di valori.</li><li><strong>Per intervallo</strong>: La dimensione verrà suddivisa utilizzando un intervallo o un elenco di intervalli.</li><li><strong>Per raster di destinazione</strong>: La dimensione verrà tagliata utilizzando uno specifico raster multidimensionale di destinazione.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_endofinterval_tag0@@": "<p>La fine dell'intervallo, utilizzato per scorrere il set di dati.</p><p>Questo parametro è obbligatorio quando il parametro<strong>Definizione dimensioni</strong>è impostato a <strong>Per intervallo</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_ignorenodata_tag0@@": "<p>Specifica se i valori NoData verranno ignorati nell'analisi.</p><ul><li>Deselezionato: l'analisi risulterà in NoData se sono presenti valori NoData nelle sezioni adiacenti. Questa impostazione è predefinita.</li><li>Selezionato: l'analisi utilizzerà solo le sezioni con pixel validi e ignorerà le sezioni NoData.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_interpolationmethod_tag0@@": "<p>Specifica il metodo che verrà utilizzato per interpolare il raster.</p><ul><li><strong>Lineare</strong>--L'output verrà interpolato linearmente utilizzando le fette adiacenti. Questa impostazione è predefinita</li><li><strong>Il vicino più prossimo</strong>: L'output utilizzerà la slice adiacente più vicina.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_raster_tag0@@": "<p>Il raster multidimensionale di input.</p>",
	"@@Interpolate-Raster-By-Dimension_startofinterval_tag0@@": "<p>L'inizio dell'intervallo, utilizzato per scorrere il set di dati.</p><p>Questo parametro è obbligatorio quando il parametro<strong>Definizione dimensioni</strong>è impostato a <strong>Per intervallo</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_step_tag0@@": "<p>La frequenza con cui i dati verranno interpolati..</p><p>Questo parametro è necessario quando il parametro<strong>Definizione dimensioni</strong> è impostato su <strong>Per intervall</strong>o.</p>",
	"@@Interpolate-Raster-By-Dimension_targetraster_tag0@@": "<p>Il raster di destinazione specificato dalla definizione della dimensione.</p><p>Questo parametro è necessario quando il parametro <strong>Definizione dimensione</strong>è impostato su <strong>Per Raster di destinazione</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_unit_tag0@@": "<p>L'unità di intervallo.</p><p>Questo parametro è necessario quando il parametro<strong>Definizione dimensioni</strong>è impostato a<strong>Per intervallo</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_values_tag0@@": "<p>I valori dimensionali da utilizzare per filtrare i dati multidimensionali di input per l'analisi.</p><p>Questo parametro è obbligatorio quando il parametro<strong>Definizione dimensioni</strong><strong>Per valore</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_variables_tag0@@": "<p>La variabile o le variabili che verranno interpolate dalla definizione della dimensione.</p>",
	"@@Terrain-Flatten_calibrationtype_tag0@@": "<p>Specifica se l'output prevede il livellamento terreno usando il metodo<strong>Sigma nought</strong>o<strong>Gamma nought</strong>.</p><ul><li><strong>Gamma nought</strong>: la retrodiffusione Beta nought sarà normalizzata utilizzando l'area unitaria di un piano localmente tangente al DEM, comunemente noto come angolo di incidenza locale. È l'impostazione predefinita.</li><li><strong>Sigma nought</strong>: la retrodiffuzione beta zero sarà normalizzata utilizzando un DEM per calcolare l'area.</li></ul>",
	"@@Terrain-Flatten_dem_tag0@@": "<p>Il DEM di input.</p><p>Il DEM viene utilizzato per stimare l'area illuminata locale.</p>",
	"@@Terrain-Flatten_geoid_tag0@@": "<p>Specifica se il sistema di riferimento verticale del DEM in ingresso deve essere trasformato in altezza ellissoidica. La maggior parte dei dataset altimetrici sono riferiti all'altezza ortometrica del livello del mare, quindi in questi casi è necessaria una correzione per convertirli in altezza ellissoidica.</p><ul><li>Selezionato: verrà effettuata una correzione del geoide per convertire l'altezza ortometrica in altezza ellissoidica (basata sul geoide EGM96). È l'impostazione predefinita.</li><li>Non selezionato: non verrà effettuata alcuna correzione del geoide. Usa questa opzione solo se il DEM è espresso in altezza ellissoidica.</li></ul>",
	"@@Terrain-Flatten_raster_tag0@@": "<p>Dati radar di input.</p><p>Questo raster deve prima essere calibrato radiometricamente a beta nought.</p>",
	"@@Create-Color-Composite_blueexpression_tag0@@": "<p>Il calcolo assegnato alla terza banda.</p><p>Un nome di banda, un ID di banda o un'espressione algebrica che utilizza le bande.</p><p>Gli operatori supportati sono unari: più (+), meno (-), volte (*) e dividi (/).</p>",
	"@@Create-Color-Composite_greenexpression_tag0@@": "<p>Il calcolo assegnato alla seconda banda.</p><p>Un nome di banda, un ID di banda o un'espressione algebrica che utilizza le bande.</p><p>Gli operatori supportati sono unari: più (+), meno (-), volte (*) e dividi (/).</p>",
	"@@Create-Color-Composite_inputraster_tag0@@": "<p>I dati raster multibanda in input.</p>",
	"@@Create-Color-Composite_method_tag0@@": "<p>Specifica il metodo che verrà utilizzato per estrarre le bande.</p><ul><li>Nomi delle bande: viene utilizzato il nome della banda che rappresenta l'intervallo di lunghezza d'onda dello spettro elettromagnetico (come Rosso, Infrarosso vicino o Infrarosso termico) o la polarizzazione (come VH, VV, HH o HV). È l'impostazione predefinita.</li><li>ID banda: viene utilizzato il numero della banda (ad esempio B1, B2 o B3).</li></ul>",
	"@@Create-Color-Composite_redexpression_tag0@@": "<p>Il calcolo assegnato alla prima banda.</p><p>Un nome di banda, un ID di banda o un'espressione algebrica che utilizza le bande.</p><p>Gli operatori supportati sono unari: più (+), meno (-), volte (*) e dividi (/).</p>",
	"@@Surface-Parameters_localsurfacetype_tag0@@": "<p>Scegli il tipo di funzione superficie da adattare attorno alla cella di destinazione.</p><ul><li>Quadratica: alle celle del quartiere verrà adattata una funzione superficie quadratica. È il tipo predefinito.</li><li>Biquadratica: alle celle del quartiere verrà adattata una funzione superficie biquadratica.</li></ul>",
	"@@Surface-Parameters_neighborhooddistance_tag0@@": "<p>L'output verrà calcolato per questa distanza dal centro della cella di destinazione. Determina la dimensione del quartiere. Il valore predefinito è la dimensione della cella raster di input, che genera un quartiere di 3 per 3.</p>",
	"@@Surface-Parameters_outputslopemeasurement_tag0@@": "<p>Le unità di misura (gradi o percentuali) che verranno utilizzate per il raster per la pendenza di output. Questo parametro è attivo solo quando <strong>Tipo di parametro</strong>è<strong>Pendenza</strong>.</p><ul><li>Gradi: l'inclinazione della pendenza verrà calcolata in gradi. È l'impostazione predefinita.</li><li>Incremento percentuale: l'inclinazione della pendenza verrà calcolata come incremento percentuale, detto anche pendenza percentuale.</li></ul>",
	"@@Surface-Parameters_parametertype_tag0@@": "<p>Specifica il tipo di parametro della superficie di output che verrà calcolato.</p><ul><li>Pendenza: verrà calcolata la rapidità di cambiamento dell'elevazione. È l'impostazione predefinita.</li><li>Aspetto: verrà calcolata la direzione della pendenza discendente della rapidità massima di cambiamento per ogni cella.</li><li>Curvatura media: verrà misurata la curvatura complessiva della superficie. Viene calcolata come media della curvatura minima e massima. Questa curvatura descrive la convessità o la concavità intrinseca della superficie, indipendentemente dalla direzione o dalla gravità.</li><li>Curvatura tangenziale (contorno normale): verrà misurata la curvatura normale geometrica perpendicolare alla linea della pendenza, tangente alla linea di contorno. Questa curvatura generalmente viene applicata per caratterizzare la convergenza o la divergenza di un flusso attraverso la superficie.</li><li>Curvatura profilo (linea pendenza normale): verrà misurata la curvatura normale geometrica lungo la linea di pendenza. Questa curvatura generalmente viene applicata per caratterizzare l'accelerazione e la decelerazione di un flusso discendente lungo la superficie.</li><li>Curvatura piano (contorno progettato): verrà misurata la curvatura lungo le linee di contorno.</li><li>Torsione geodetica contorno: verrà misurata la rapidità di cambiamento dell'angolo della pendenza lungo le linee di contorno.</li><li>Curvatura gaussiana: verrà misurata la curvatura complessiva della superficie. Viene calcolata come prodotto della curvatura minima e massima.</li><li>Curvatura di Casorati: verrà misurata la curvatura generale della superficie. Può essere zero o qualunque numero positivo.</li></ul>",
	"@@Surface-Parameters_projectgeodesicazimuths_tag0@@": "<p>Specifica se gli azimut geodetici verranno proiettati per correggere la distorsione angolare causata da riferimento spaziale di output. Questo parametro è attivo solo quando <strong>Tipo di parametro</strong>è<strong>Aspetto</strong>.</p><ul><li>Non selezionato: gli azimut geodetici non verranno proiettati. È l'impostazione predefinita.</li><li>Selezionato: verranno proiettati gli azimut geodetici.</li></ul>",
	"@@Surface-Parameters_raster_tag0@@": "<p>Il raster superficie di input. Può essere un raster intero o in virgola mobile.</p>",
	"@@Surface-Parameters_useadaptiveneighborhood_tag0@@": "<p>Specifica se la distanza del quartiere varia con i cambiamenti del paesaggio (adattiva). La distanza massima è determinata dalla distanza del quartiere. La distanza minima è la dimensione della cella raster di input.</p><ul><li>Non selezionato: in tutte le posizioni verrà utilizzata una singola distanza del quartiere (fissa). È l'impostazione predefinita.</li><li>Selezionato: in tutte le posizioni verrà utilizzata una distanza adattiva del quartiere.</li></ul>",
	"@@Surface-Parameters_useequatorialaspect_tag0@@": "<p>Specifica se l'aspetto verrà misurato da un punto sull'equatore o dal polo nord. Questo parametro è attivo solo quando <strong>Tipo di parametro </strong>è<strong>Aspetto</strong>.</p><ul><li>Non selezionato: l'aspetto verrà misurato dal polo nord. È l'impostazione predefinita.</li><li>Selezionato: l'aspetto verrà misurato da un punto sull'equatore.</li></ul>",
	"@@Surface-Parameters_zunit_tag0@@": "<p>L'unità lineare di valori z verticali.</p><p>È definita da un sistema di coordinate verticali, se esiste. Se non esiste un sistema di coordinate verticali, l'unità Z deve essere definita dall'elenco unità per garantire il calcolo geodetico corretto.</p><ul><li>Pollici: l'unità lineare sarà in pollici.</li><li>Piedi: l'unità lineare sarà in piedi.</li><li>Iarde: l'unità lineare sarà in iarde.</li><li>Miglia USA: l'unità lineare sarà in miglia.</li><li>Miglia nautiche: l'unità lineare sarà in miglia nautiche.</li><li>Millimetri: l'unità lineare sarà in millimetri.</li><li>Centimetri: l'unità lineare sarà in centimetri.</li><li>Metri: l'unità lineare sarà in metri. È l'impostazione predefinita.</li><li>Chilometri: l'unità lineare sarà in chilometri.</li><li>Decimetri: l'unità lineare sarà in decimetri.</li></ul>",
	"@@Surface-Parameters_analysismask_tag0@@": "<p>Un raster che specifica le posizioni in cui si verificherà l'analisi.</p><p>Il raster può essere di tipo intero o a virgola mobile.</p><p>Tutte le celle con un valore valido, incluso zero, comporranno la maschera. Le celle che sono NoData nell'input della maschera saranno NoData nell'output.</p>",
	"@@Geometric-Median_cellsizetype_tag0@@": "<p>Scegliere quale grandezza di cella utilizzare nel raster di output. Se tutte le grandezze di celle di input sono le stesse, tutte le opzioni produrranno gli stessi risultati.</p><ul><li>Primo di: utilizza la prima grandezza di cella dei raster di input.</li><li>Min di: utilizza la grandezza di cella minore di raster di input.</li><li>Max di: utilizza la grandezza di cella maggiore di tutti i raster di input. Questa è l'impostazione di default.</li><li>Media di: utilizza la grandezza di cella media di tutti i raster di input.</li><li>Ultimo di: utilizza l'ultima grandezza di cella di raster di input.</li></ul>",
	"@@Geometric-Median_epsilon_tag0@@": "<p>Specifica il valore di convergenza tra due iterazioni consecutive. Quando epsilon è minore o uguale al valore specificato, l'iterazione si interrompe e viene utilizzato il risultato dell'ultima iterazione.</p>",
	"@@Geometric-Median_extenttype_tag0@@": "<p>Scegli quale estensione utilizzare nel raster di output:</p><ul><li><p>Primo di: usa l'estensione del primo raster di input per determinare l'estensione di elaborazione.</p></li><li>Intersezione di: usa l'estensione dei pixel sovrapposti per determinare l'estensione di elaborazione. Questa è l'impostazione di default.</li><li>Unione di: usare l'estensione di tutti i raster per determinare l'estensione di elaborazione.</li><li>Ultimo di: usare l'estensione dell'ultimo raster di input per determinare l'estensione di elaborazione.</li></ul>",
	"@@Geometric-Median_maximumnumberofiterations_tag0@@": "<p>Specifica il numero massimo di iterazioni da completare. Il calcolo termina quando viene raggiunto questo valore, a prescindere dall'impostazione di <strong>Epsilon</strong>.</p>",
	"@@Geometric-Median_rasters_tag0@@": "<p>I raster multibanda di input.</p>",
	"@@Least-Cost-Corridor_inputaccumulativecostdistanceraster1_tag0@@": "<p>Il raster di input che rappresenta la distanza di costo cumulativo dalla prima origine.</p><p>Deve essere una distanza di costo cumulativo prodotta dalla funzione <strong>Accumulo distanza </strong>o <strong>Allocazione distanza</strong>.</p>",
	"@@Least-Cost-Corridor_inputaccumulativecostdistanceraster2_tag0@@": "<p>Il raster di input che rappresenta la distanza di costo cumulativo dalla seconda origine.</p><p>Deve essere una distanza di costo cumulativo prodotta dalla funzione <strong>Accumulo distanza </strong>o <strong>Allocazione distanza</strong>.</p>",
	"@@Least-Cost-Corridor_inputbackdirectionraster1_tag0@@": "<p>Il raster della direzione inversa di input dalla prima origine.</p><p>Si tratta di un dataset raster che identifica la direzione della cella successiva lungo il percorso minimo costo per tornare alla prima origine. Questo è l'output della funzione <strong>Accumulo distanza </strong>o<strong> Allocazione distanza</strong>.</p>",
	"@@Least-Cost-Corridor_inputbackdirectionraster2_tag0@@": "<p>Il raster della direzione inversa di input dalla seconda origine.</p><p>Si tratta di un dataset raster che identifica la direzione della cella successiva lungo il percorso minimo costo per tornare alla prima origine. Questo è l'output della funzione <strong>Accumulo distanza </strong>o<strong> Allocazione distanza</strong>.</p>",
	"@@Least-Cost-Corridor_threshold_tag0@@": "<p>Una soglia di costo cumulativo o percentuale or che determinerà se una cella specificata sarà inclusa nel raster corridoio di output.</p><p>Quando il parametro <strong>Metodo soglia</strong> è impostato su <strong>Percentuale di minimo costo</strong>, il valore specificato indica l'aumento percentuale da applicare dal valore minimo dei raster di distanza di costo cumulativo sommati. Quando il parametro <strong>Metodo soglia</strong> è impostato su <strong>Costo cumulativo</strong>, il valore indica le celle che hanno un costo cumulativo sommato uguale o inferiore al valore che sarà incluso nel corridoio.</p><p>Questo parametro è attivo solo se il parametro <strong>Metodo soglia </strong>è impostato su <strong>Percentuale di minimo costo </strong>o<strong> Costo cumulativo</strong>.</p>",
	"@@Least-Cost-Corridor_thresholdmethod_tag0@@": "<p>Specifica come sarà definita la soglia.</p><p></p><ul><li><strong>Nessuna soglia</strong>: nessuna soglia sarà applicata e il corridoio risultate coprirà l'intera estensione dei raster di input. Questa è l'impostazione predefinita.</li><li><strong>Percentuale di minimo costo</strong>: la soglia sarà definita come percentuale del valore minimo dei raster distanza di costo cumulativo.</li><li><strong>Costo cumulativo</strong>: la soglia sarà definita nelle unità di distanza di costo cumulativo.</li></ul>"
};
const helpTexts_it = {
	rfxArgsHelpTexts: rfxArgsHelpTexts
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (helpTexts_it);


//# sourceMappingURL=help-texts.it-5c9f24f9.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTIxYmI3Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxHQUFHO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFlBQVk7QUFDdEcsNkZBQTZGLFlBQVk7QUFDekcseUZBQXlGLFlBQVk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwUkFBMFIsS0FBSztBQUMvUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RyxLQUFLO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa09BQWtPLE9BQU87QUFDek87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3WEFBd1gsYUFBYSxJQUFJLFVBQVU7QUFDblo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1WEFBdVgsYUFBYSxJQUFJLFVBQVU7QUFDbFo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc1hBQXNYLGFBQWEsSUFBSSxVQUFVO0FBQ2paO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdJQUFnSSxRQUFRO0FBQ3hJO0FBQ0EsaUlBQWlJLE9BQU87QUFDeEk7QUFDQTtBQUNBLGlHQUFpRyxFQUFFLHdGQUF3RixJQUFJO0FBQy9MO0FBQ0EscUdBQXFHLEdBQUcsSUFBSSxJQUFJO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5T0FBeU8sT0FBTztBQUNoUDtBQUNBO0FBQ0EsK0VBQStFLFFBQVE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5UEFBeVAsT0FBTztBQUNoUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFFBQVE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ09BQWdPO0FBQ2hPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFFBQVE7QUFDOUYsK0hBQStILFFBQVEseUNBQXlDLFFBQVE7QUFDeEwsZ0tBQWdLLE9BQU8sK0NBQStDLE9BQU87QUFDN047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseVNBQXlTO0FBQ3pTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEtBQTBLLEdBQUc7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLFFBQVE7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQ0FBMEMsd0VBQXdFLElBQUkseUVBQXlFLElBQUk7QUFDOU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNSQUFzUixPQUFPO0FBQzdSLGtPQUFrTyxPQUFPO0FBQ3pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdYQUF3WCxhQUFhLElBQUksVUFBVTtBQUNuWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0SSxvRUFBb0UsT0FBTztBQUN2TixrRkFBa0YsT0FBTztBQUN6RjtBQUNBLCtGQUErRixRQUFRLDJIQUEySCxPQUFPO0FBQ3pPLHVHQUF1RyxRQUFRLHNHQUFzRyxPQUFPO0FBQzVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxLQUFLO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csUUFBUTtBQUN4Ryx3S0FBd0ssUUFBUSwwREFBMEQsUUFBUTtBQUNsUCwrTUFBK00sUUFBUTtBQUN2TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpaUNBQWlpQyx5TEFBeUwsV0FBVztBQUNydUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNYQUFzWCxhQUFhLElBQUksVUFBVTtBQUNqWixpakNBQWlqQztBQUNqakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNGlDQUE0aUMseUxBQXlMLFdBQVc7QUFDaHZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlZQUFpWSxhQUFhLElBQUksVUFBVTtBQUM1WjtBQUNBLDRqQ0FBNGpDO0FBQzVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyaUNBQTJpQyx5TEFBeUwsV0FBVztBQUMvdUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdZQUFnWSxhQUFhLElBQUksVUFBVTtBQUMzWiwyakNBQTJqQztBQUMzakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZILHlCQUF5QjtBQUN0SjtBQUNBLDBKQUEwSiw4QkFBOEI7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixNQUFNO0FBQ2hHLDZJQUE2SSxPQUFPLElBQUksTUFBTTtBQUM5SjtBQUNBO0FBQ0Esd05BQXdOLE1BQU07QUFDOU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtU0FBbVM7QUFDblM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJSQUEyUjtBQUMzUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsV0FBVyx3SkFBd0osV0FBVztBQUNsUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsME9BQTBPO0FBQzFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEtBQTBLO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLE9BQU87QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCxzREFBc0Q7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSxLQUFLLGdLQUFnSyxNQUFNO0FBQ25UO0FBQ0E7QUFDQSxnTkFBZ04sZUFBZTtBQUMvTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxRQUFRO0FBQ3BGLGdHQUFnRyxRQUFRLHlJQUF5SSxRQUFRO0FBQ3pQLDhNQUE4TSxPQUFPLDhEQUE4RCxPQUFPLGdIQUFnSCxPQUFPO0FBQ2paO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSxFQUFFO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5aUNBQXlpQyx5TEFBeUwsV0FBVztBQUM3dUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZYQUE2WCxhQUFhLElBQUksVUFBVTtBQUN4Wix5akNBQXlqQztBQUN6akM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVpQ0FBdWlDLHlMQUF5TCxXQUFXO0FBQzN1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMlhBQTJYLGFBQWEsSUFBSSxVQUFVO0FBQ3RaLHVqQ0FBdWpDO0FBQ3ZqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvekJBQW96QjtBQUNwekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxZQUFZLEVBQUM7QUFDQTs7QUFFNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS9oZWxwLXRleHRzLml0LTVjOWYyNGY5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJmeEFyZ3NIZWxwVGV4dHMgPSB7XG5cdFwiQEBBYnNfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQEFic19DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQWJzX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQWJzX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBBYnNfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQWJzX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQWJzX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAQWJzX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBBYnNfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQWJzX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBBYnNfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQWJzX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgcGVyIGlsIHF1YWxlIGNhbGNvbGFyZSBpIHZhbG9yaSBhc3NvbHV0aS5cIixcblx0XCJAQEFDb3NfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQEFDb3NfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEFDb3NfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBQ29zX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBBQ29zX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEFDb3NfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBQ29zX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAQUNvc19FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQUNvc19FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBBQ29zX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBBQ29zX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEFDb3NfUmFzdGVyX3RhZzBAQFwiOiBcIkwnaW5wdXQgcGVyIGlsIHF1YWxlIGNhbGNvbGFyZSBpIHZhbG9yaSBkaSBjb3Nlbm8gaW52ZXJzby5cIixcblx0XCJAQEFDb3NIX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBBQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQUNvc0hfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQUNvc0hfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQUNvc0hfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBQ29zSF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQEFDb3NIX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBBQ29zSF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBBQ29zSF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQUNvc0hfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQUNvc0hfUmFzdGVyX3RhZzBAQFwiOiBcIkwnaW5wdXQgcGVyIGlsIHF1YWxlIGNhbGNvbGFyZSBpIHZhbG9yaSBkaSBjb3Nlbm8gaW52ZXJzbyBpcGVyYm9saWNvLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfQWxiZWRvX3RhZzBAQFwiOiBcIkkgcmlzdWx0YXRpIGRlbGxhIGZ1bnppb25lIFJpZmxldHRhbnphIGFwcGFyZW50ZSBwdcOyIGFuY2hlIGVzc2VyZSBlc3ByZXNzYSBjb21lIGFsYmVkbywgY2hlIMOoIGxhIHBlcmNlbnR1YWxlIGRpIGVuZXJnaWEgZGlzcG9uaWJpbGUgcmlmbGVzc2EgZGFsbGEgc3VwZXJmaWNpZSBkZWwgcGlhbmV0YS4gSSBkYXRpIHZlbmdvbm8gdXRpbGl6emF0aSBkYSB1dGVudGkgc2NpZW50aWZpY2kgcGVyIGFwcGxpY2F6aW9uaSBjb21wbGVzc2UgZGkgbW9kZWxsYXppb25lIGUgdGVsZXJpbGV2YW1lbnRvIHRlY25pY28uXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9BbGJlZG9fdGFnMUBAXCI6IFwiTm9uIHNlbGV6aW9uYXRvOiBsYSBmdW56aW9uZSB0b3JuYSBhaSB2YWxvcmkgZGkgcmlmbGV0dGFuemEgYXBwYXJlbnRlLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9BbGJlZG9fdGFnMkBAXCI6IFwiU2VsZXppb25hdG86IGxhIGZ1bnppb25lIHRvcm5hIGEgdmFsb3JpIDMyIGJpdCBhIHZpcmdvbGEgbW9iaWxlLCBjaGUgcmllbnRyYW5vIHBpw7kgY29tdW5lbWVudGUgbmVsbCdpbnRlcnZhbGxvIDAsMCAtIDEsMC4gU2Ugw6ggc2VsZXppb25hdGEgcXVlc3RhIG9wemlvbmUgbm9uIHNpIGVzZWd1ZSBhbGN1biB0YWdsaW8gZGVpIGRhdGkuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9BbGJlZG9fdGFnM0BAXCI6IFwiRGFsIG1vbWVudG8gY2hlIGlsIHRpcG8gZGkgZGF0aSBkaSBvdXRwdXQgcGVyIGFsYmVkbyDDqCBsYSB2aXJnb2xhIG1vYmlsZSwgw6ggbmVjZXNzYXJpbyBpbXBvc3RhcmUgZXNwbGljaXRhbWVudGUgaWwgPHN0cm9uZz5UaXBvIGRpIHBpeGVsIGRpIG91dHB1dDwvc3Ryb25nPiBwcmVmZXJpdG8gc3UgMzIgYml0IGZsb2F0IG8gNjQgYml0IGRvcHBpby4gSWwgcGFyYW1ldHJvIGRpIDxzdHJvbmc+VGlwbyBkaSBwaXhlbCBkaSBvdXRwdXQ8L3N0cm9uZz4gc2kgdHJvdmEgbmVsbGEgc2NoZWRhIDxzdHJvbmc+R2VuZXJhbGU8L3N0cm9uZz4gZGVsbGEgZnVuemlvbmUgcmFzdGVyIDxzdHJvbmc+UmlmbGV0dGFuemEgYXBwYXJlbnRlPC9zdHJvbmc+LiBTZSBpbCA8c3Ryb25nPlRpcG8gZGkgcGl4ZWwgZGkgb3V0cHV0PC9zdHJvbmc+IG5vbiDDqCBpbXBvc3RhdG8gY29ycmV0dGFtZW50ZSBwZXIgbCdvcHppb25lIDxzdHJvbmc+QWxiZWRvPC9zdHJvbmc+LCBpIHZhbG9yaSByaXN1bHRhbnRpIHNhcmFubm8gaW52YWxpZGkgZSBhc3N1bWVyYW5ubyBpbCB2YWxvcmUgMC5cIixcblx0XCJAQEFwcGFyZW50LVJlZmxlY3RhbmNlX09mZnNldF90YWcwQEBcIjogXCJJbCB2YWxvcmUgYWxiZWRvIHNjYWxhdG8gcHXDsiBhdmVyZSBmYWNvbHRhdGl2YW1lbnRlIHVuIHZhbG9yZSBkaSBvZmZzZXQ6XCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9PZmZzZXRfdGFnMUBAXCI6IFwiUGVyIGkgdGlwaSBkaSBkYXRpIHNlbnphIHNlZ25vIGEgMTYgYml0LCBsJ29mZnNldCBkaSBzY2FsYSBwcmVkZWZpbml0byDDqCA1LjAwMC5cIixcblx0XCJAQEFwcGFyZW50LVJlZmxlY3RhbmNlX09mZnNldF90YWcyQEBcIjogXCJQZXIgaSB0aXBpIGRpIGRhdGkgc2VuemEgc2Vnbm8gYSA4IGJpdCwgbCdvZmZzZXQgZGkgc2NhbGEgcHJlZGVmaW5pdG8gw6ggMC5cIixcblx0XCJAQEFwcGFyZW50LVJlZmxlY3RhbmNlX09mZnNldF90YWczQEBcIjogXCJOb24gc2kgYXBwbGljYSBuZXNzdW4gZmF0dG9yZSBkaSBzY2FsYSBxdWFuZG8gbCdvdXRwdXQgw6ggYWxiZWRvLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfUmFkaWFuY2UtR2FpbnMtYW5kLUJpYXMtVmFsdWVzLXBlci1CYW5kX3RhZzBAQFwiOiBcIsOIIHBvc3NpYmlsZSBpbXBvc3RhcmUgbyBtb2RpZmljYXJlIG1hbnVhbG1lbnRlIHF1ZXN0byB2YWxvcmUgcGVyIG9nbmkgYmFuZGEuIExlIGluZm9ybWF6aW9uaSBhcHByb3ByaWF0ZSBwb3Nzb25vIGVzc2VyZSBsZXR0ZSBkYWkgbWV0YWRhdGkgZGVsIHByb2RvdHRvIGRlbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcHJvZG90dG8gcmFzdGVyIHN1bCBxdWFsZSBzYXLDoCBhcHBsaWNhdGEgbGEgcmlmbGV0dGFuemEgYXBwYXJlbnRlLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfU2NhbGUtRmFjdG9yX3RhZzBAQFwiOiBcIklsIHZhbG9yZSBkaSBvdXRwdXQgZGVsbGEgcmlmbGV0dGFuemEgYXBwYXJlbnRlIHB1w7IgZXNzZXJlIGVzcHJlc3NvIGNvbWUgdW4gbnVtZXJvIGludGVyby4gSWwgZmF0dG9yZSBkaSBzY2FsYSB2aWVuZSBtb2x0aXBsaWNhdG8gZGFsbCdhbGJlZG8gcGVyIGNvbnZlcnRpcmUgdHV0dGkgaSB2YWxvcmkgYSB2aXJnb2xhIG1vYmlsZSBpbiB2YWxvcmkgaW50ZXJpLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfU2NhbGUtRmFjdG9yX3RhZzFAQFwiOiBcIlNlIGlsIGZhdHRvcmUgZGkgc2NhbGEgw6ggJHswfSBvIG5vbiBzcGVjaWZpY2F0bywgc2kgYXBwbGljaGVyw6AgbGEgc2NhbGEgcHJlZGVmaW5pdGEgYSBzZWNvbmRhIGRlbCB0aXBvIGRpIHBpeGVsIGRlaSBkYXRpIGRpIGlucHV0OlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfU2NhbGUtRmFjdG9yX3RhZzJAQFwiOiBcIlBlciBpIHRpcGkgZGkgZGF0aSBzZW56YSBzZWdubyBhIDE2IGJpdCwgaWwgZmF0dG9yZSBkaSBzY2FsYSBwcmVkZWZpbml0byDDqCA1MC4wMDAuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9TY2FsZS1GYWN0b3JfdGFnM0BAXCI6IFwiUGVyIGkgdGlwaSBkaSBkYXRpIHNlbnphIHNlZ25vIGEgOCBiaXQsIGlsIGZhdHRvcmUgZGkgc2NhbGEgcHJlZGVmaW5pdG8gw6ggMjU1LlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfU2NhbGUtRmFjdG9yX3RhZzRAQFwiOiBcIklsIGZhdHRvcmUgZGkgc2NhbGEgc2kgYXBwbGljYSBzZW1wcmUgcXVhbmRvIGwnb3V0cHV0IMOoIHVuYSByaWZsZXR0YW56YSBhcHBhcmVudGUuIE5vbiBzaSBhcHBsaWNhIG5lc3N1biBmYXR0b3JlIGRpIHNjYWxhIHF1YW5kbyBsJ291dHB1dCDDqCBhbGJlZG8uXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9TdW4tRWxldmF0aW9uX3RhZzBAQFwiOiBcIlF1ZXN0byDDqCBpbCB2YWxvcmUgZGkgZWxldmF6aW9uZSBkZWwgc29sZSwgZXNwcmVzc28gaW4gZ3JhZGkuIFNhcsOgIHBvcG9sYXRvIGRhbCBzaXN0ZW1hIHNlIMOoIHBvc3NpYmlsZSBsZWdnZXJlIGxlIGluZm9ybWF6aW9uaSBpZG9uZWUgZGFpIG1ldGFkYXRpLiDDiCBwb3NzaWJpbGUgaW1wb3N0YXJlIG8gbW9kaWZpY2FyZSBtYW51YWxtZW50ZSBxdWVzdG8gdmFsb3JlLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19NYXhfdGFnMEBAXCI6IFwiSWwgdmFsb3JlIG1hc3NpbW8gaW1wb3N0YXRvIMOoIGlsIHZhbG9yZSBwacO5IGFsdG8gdWd1YWxlIG8gbWlub3JlIGRlbGxhIGZpbmUgZGVsbGEgZHVyYXRhLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19NYXhfdGFnMUBAXCI6IFwiUXVlc3RvIGlucHV0IMOoIGFwcGxpY2FiaWxlIHNvbG8gc2UgaWwgbWV0b2RvIMOoIER1cmF0YS5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfTWV0aG9kX3RhZzBAQFwiOiBcIlNlbGV6aW9uYXJlIGlsIG1ldG9kbyBzdGF0aXN0aWNvIHBlciBpbCBjYWxjb2xvOlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19NZXRob2RfdGFnMUBAXCI6IFwiQXJnIE1heDogbCdhcmdvbWVudG8gZGVsIG1hc3NpbW8sIGNoZSByZXN0aXR1aXNjZSBpbCAke0JhbmQgaW5kZXh9IHBlciBpbCBxdWFsZSBpbCBwaXhlbCBkYXRvIHJhZ2dpdW5nZSBpbCBzdW8gdmFsb3JlIG1hc3NpbW8gZGEgdHV0dGUgbGUgYmFuZGUuIEEgdHV0dGUgbGUgYmFuZGUgcmFzdGVyIGRhIG9nbmkgcmFzdGVyIGRpIGlucHV0IHZpZW5lIGFzc2VnbmF0byB1biBpbmRpY2UgZGkgYmFuZGEgaW5jcmVtZW50YWxlIHN1IGJhc2UgMCwgY2hlIMOoIGlsIHByaW1vIGFkIGVzc2VyZSBvcmRpbmF0byBkYWxsJ2luZGljZSByYXN0ZXIgZGkgaW5wdXQgZSBxdWluZGkgZGFsbCdvcmRpbmUgZGkgYmFuZGEgcmVsYXRpdm8gYWxsJ2ludGVybm8gZGkgY2lhc2N1biByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX01ldGhvZF90YWcyQEBcIjogXCJBcmcgTWVkaWFuOiBsJ2FyZ29tZW50byBkZWwgbWVkaWFubywgY2hlIHJlc3RpdHVpc2NlIGlsICR7QmFuZCBpbmRleH0gcGVyIGlsIHF1YWxlIGlsIHBpeGVsIGRhdG8gcmFnZ2l1bmdlIGlsIHN1byB2YWxvcmUgbWVkaWFubyBkZWkgdmFsb3JpIGRpIHR1dHRlIGxlIGJhbmRlLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19NZXRob2RfdGFnM0BAXCI6IFwiQXJnIE1pbjogbCdhcmdvbWVudG8gZGVsIG1pbmltbywgY2hlIHJlc3RpdHVpc2NlIGlsICR7QmFuZCBpbmRleH0gcGVyIGlsIHF1YWxlIGlsIHBpeGVsIGRhdG8gcmFnZ2l1bmdlIGlsIHN1byB2YWxvcmUgbWluaW1vIGRhIHR1dHRlIGxlIGJhbmRlLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19NZXRob2RfdGFnNEBAXCI6IFwiRHVyYXRhOiB0cm92YSBnbGkgZWxlbWVudGkgY29uc2VjdXRpdmkgcGnDuSBsdW5naGkgbmVsbCdhcnJheSwgbGFkZG92ZSBvZ25pIGVsZW1lbnRvIGhhIHVuIHZhbG9yZSBzdXBlcmlvcmUgbyB1Z3VhbGUgYSA8c3Ryb25nPk1pbjwvc3Ryb25nPiBlIGluZmVyaW9yZSBvIHVndWFsZSBhIDxzdHJvbmc+TWF4PC9zdHJvbmc+LCBxdWluZGkgcmVzdGl0dWlzY2UgbGEgc3VhIGx1bmdoZXp6YS5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfTWluX3RhZzBAQFwiOiBcIklsIHZhbG9yZSBtaW5pbW8gaW1wb3N0YXRvIMOoIGlsIHZhbG9yZSBwacO5IHBpY2NvbG8gdWd1YWxlIG8gbWFnZ2lvcmUgZGVsbCdpbml6aW8gZGVsbGEgZHVyYXRhLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19NaW5fdGFnMUBAXCI6IFwiUXVlc3RvIGlucHV0IMOoIGFwcGxpY2FiaWxlIHNvbG8gc2UgaWwgbWV0b2RvIMOoIER1cmF0YS5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfUmFzdGVyc190YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgc3UgY3VpIHZlcnJhbm5vIGVzZWd1aXRpIGkgdmFyaSBtZXRvZGkgc3RhdGlzdGljaS5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfVW5kZWZpbmVkLUNsYXNzX3RhZzBAQFwiOiBcIlVuIGlucHV0IGNvc3RhbnRlIGNoZSB2aWVuZSByZXN0aXR1aXRvIHF1YW5kbyBub24gc2kgcHXDsiBvdHRlbmVyZSBuZXNzdW4gbWFzc2ltbywgbWluaW1vIG8gbWVkaWFubyBkZWZpbml0aXZvLiBMbyBzY2VuYXJpbyBwacO5IGNvbXVuZSDDqCBpbCB2ZXJpZmljYXJzaSBkZWwgdmFsb3JlIG1hc3NpbW8gbyBtaW5pbW8gcGVyIHBpw7kgZGkgdW5hIHZvbHRhIHRyYSBpIHZhbG9yaSBkaSB0dXR0ZSBsZSBiYW5kZS4gSWwgdmFsb3JlIHByZWRlZmluaXRvIHBlciBsYSBjb3N0YW50ZSBub24gZGVmaW5pdGEgw6ggMTAwLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19VbmRlZmluZWQtQ2xhc3NfdGFnMUBAXCI6IFwiTGEgY2xhc3NlIG5vbiBkZWZpbml0YSBzaSBwdcOyIGFwcGxpY2FyZSBzb2xvIHF1YW5kbyBpbCBtZXRvZG8gw6ggPHN0cm9uZz5BcmdNYXg8L3N0cm9uZz4sIDxzdHJvbmc+QXJnTWluPC9zdHJvbmc+IG8gPHN0cm9uZz5BcmdNZWRpYW48L3N0cm9uZz4uXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX2lnbm9yZW5vZGF0YV90YWcwQEBcIjogXCJJbmRpY2Egc2UgaSB2YWxvcmkgTm9EYXRhIHZlbmdvbm8gaWdub3JhdGkgbmVsIGNhbGNvbG8gc3RhdGlzdGljby5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfaWdub3Jlbm9kYXRhX3RhZzFAQFwiOiBcIlNlbGV6aW9uYXRhOiBsJ2FuYWxpc2kgaW5jbHVkZXLDoCB0dXR0aSBpIHBpeGVsIHZhbGlkaSBuZWkgcmFzdGVyIGRpIGlucHV0IGUgaWdub3JlcsOgIHR1dHRpIGkgcGl4ZWwgTm9EYXRhLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19pZ25vcmVub2RhdGFfdGFnMkBAXCI6IFwiTm9uIHNlbGV6aW9uYXRhOiBsJ2FuYWxpc2kgcHJvZHVycsOgIE5vRGF0YSBzZSBzb25vIHByZXNlbnRpIHZhbG9yaSBOb0RhdGEgcGVyIGkgcGl4ZWwgbmVpIHJhc3RlciBkaSBpbnB1dC4gU2kgdHJhdHRhIGRlbGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQXJpdGhtZXRpY19DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBAQXJpdGhtZXRpY19DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQXJpdGhtZXRpY19DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEFyaXRobWV0aWNfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEFyaXRobWV0aWNfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQXJpdGhtZXRpY19DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEFyaXRobWV0aWNfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBBcml0aG1ldGljX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBBcml0aG1ldGljX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEFyaXRobWV0aWNfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEFyaXRobWV0aWNfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQXJpdGhtZXRpY19PcGVyYXRpb25fdGFnMEBAXCI6IFwiTCdvcGVyYXppb25lIGFyaXRtZXRpY2EgZGEgZXNlZ3VpcmUgdHJhIGR1ZSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWcxQEBcIjogXCJMZSBvcHppb25pIHNvbm8gbGUgc2VndWVudGk6XCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWcyQEBcIjogXCI8c3Ryb25nPkRpdmlkaTwvc3Ryb25nPjogcmVzdGl0dWlzY2UgaWwgcmlzdWx0YXRvIGRpdmlzaWJpbGUgdHJhIGkgcmVsYXRpdmkgdmFsb3JpIHBpeGVsIHBlciBjaWFzY3VuIHJhc3Rlci5cIixcblx0XCJAQEFyaXRobWV0aWNfT3BlcmF0aW9uX3RhZzRAQFwiOiBcIjxzdHJvbmc+U290dHJhaTwvc3Ryb25nPjogcmVzdGl0dWlzY2UgbGEgZGlmZmVyZW56YSB0cmEgaSByZWxhdGl2aSB2YWxvcmkgcGl4ZWwgcGVyIGNpYXNjdW4gcmFzdGVyLiBQdcOyIGVzc2VyZSB1c2F0YSBwZXIgY2FsY29sYXJlIGlsIHJpbGV2YW1lbnRvIGRlbGxlIG1vZGlmaWNoZS5cIixcblx0XCJAQEFyaXRobWV0aWNfT3BlcmF0aW9uX3RhZzZAQFwiOiBcIjxzdHJvbmc+TW9kYTwvc3Ryb25nPjogcmVzdGl0dWlzY2UgaWwgdmFsb3JlIHBpeGVsIGRpIHR1dHRpIGkgcGl4ZWwgc292cmFwcG9zdGkgY2hlIHNpIHZlcmlmaWNhbm8gcGnDuSBkaSBmcmVxdWVudGUuIEFkIGVzZW1waW86IHNlIGNpIHNvbm8gc2VpIGJhbmRlIGluIHVuIHJhc3RlciwgY2kgc2FyYW5ubyBzZWkgcGl4ZWwgc292cmFwcG9zdGkuIFBlciBpIHZhbG9yaSA0LCA1LCA2LCA0LCA3LCA5LCBpbCB2YWxvcmUgZGVsbGEgbW9kYWxpdMOgIMOoIDQuXCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWc4QEBcIjogXCI8c3Ryb25nPk1vbHRpcGxpY2E8L3N0cm9uZz46IHJlc3RpdHVpc2NlIGlsIHByb2RvdHRvIGRlaSByZWxhdGl2aSB2YWxvcmkgcGl4ZWwgcGVyIGNpYXNjdW4gcmFzdGVyLiBQdcOyIGVzc2VyZSB1c2F0YSBwZXIgZXNlZ3VpcmUgYWxjdW5lIGZ1bnppb25pIGRpIGNvc3RvLlwiLFxuXHRcIkBAQXJpdGhtZXRpY19PcGVyYXRpb25fdGFnMTBAQFwiOiBcIjxzdHJvbmc+U29tbWE8L3N0cm9uZz46IHJlc3RpdHVpc2NlIGxhIHNvbW1hIGRpIHR1dHRpIGkgcmVsYXRpdmkgdmFsb3JpIHBpeGVsIHBlciBjaWFzY3VuIHJhc3Rlci5cIixcblx0XCJAQEFyaXRobWV0aWNfT3BlcmF0aW9uX3RhZzEyQEBcIjogXCI8c3Ryb25nPlBvdGVuemE8L3N0cm9uZz46IHJlc3RpdHVpc2NlIGlsIHByb2RvdHRvIGRlaSByZWxhdGl2aSB2YWxvcmkgcGl4ZWwgZWxldmF0aSBhbGxhIHBvdGVuemEgZGVsIHJhc3RlciBkaSBpbnB1dCBvIHNjYWxhcmUuXCIsXG5cdFwiQEBBcml0aG1ldGljX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCBwcmltbyBkYXRhc2V0IHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEFyaXRobWV0aWNfUmFzdGVyMl90YWcwQEBcIjogXCJJbCBzZWNvbmRvIGRhdGFzZXQgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEFTaW5fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEFTaW5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEFTaW5fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBBU2luX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBBU2luX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEFTaW5fRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEFTaW5fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQVNpbl9SYXN0ZXJfdGFnMEBAXCI6IFwiTCdpbnB1dCBwZXIgaWwgcXVhbGUgY2FsY29sYXJlIGkgdmFsb3JpIGRpIHNlbm8gaW52ZXJzby5cIixcblx0XCJAQEFTaW5IX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBBU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVNpbkhfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQVNpbkhfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVNpbkhfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBU2luSF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQEFTaW5IX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBBU2luSF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBBU2luSF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQVNpbkhfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQVNpbkhfUmFzdGVyX3RhZzBAQFwiOiBcIkwnaW5wdXQgcGVyIGlsIHF1YWxlIGNhbGNvbGFyZSBpIHZhbG9yaSBkaSBzZW5vIGludmVyc28gaXBlcmJvbGljby5cIixcblx0XCJAQEFzcGVjdF9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgREVNIGRpIGlucHV0IHV0aWxpenphdG8gcGVyIGRlcml2YXJlIGlsIGRhdGFzZXQgZGkgYXNwZXR0by5cIixcblx0XCJAQEFzcGVjdC1TbG9wZV9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgREVNIGRpIGlucHV0LlwiLFxuXHRcIkBAQXNwZWN0LVNsb3BlX1otRmFjdG9yX3RhZzBAQFwiOiBcIlVuIGZhdHRvcmUgZGkgc2NhbGEgdXRpbGl6emF0byBwZXIgY29udmVydGlyZSBpIHZhbG9yaSBkaSBlbGV2YXppb25lIHBlciBpIHNlZ3VlbnRpIGR1ZSBtb3Rpdmk6XCIsXG5cdFwiQEBBc3BlY3QtU2xvcGVfWi1GYWN0b3JfdGFnMUBAXCI6IFwiQ29udmVydGlyZSBsZSB1bml0w6AgZGkgZWxldmF6aW9uZSAoYWQgZXNlbXBpbywgbWV0cmkgbyBwaWVkaSkgaW4gdW5pdMOgIGRpIGNvb3JkaW5hdGUgb3JpenpvbnRhbGkgZGVsIGRhdGFzZXQsIGNoZSBwb3Nzb25vIGVzc2VyZSBwaWVkaSwgbWV0cmkgbyBncmFkaS5cIixcblx0XCJAQEFzcGVjdC1TbG9wZV9aLUZhY3Rvcl90YWcyQEBcIjogXCJBZ2dpdW5nZXJlIGlsIGZhdHRvcmUgZGkgZXNhZ2VyYXppb25lIHZlcnRpY2FsZSBwZXIgb3R0ZW5lcmUgdW4gZWZmZXR0byB2aXNpdm8uXCIsXG5cdFwiQEBBVGFuX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBBVGFuX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBVGFuX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVRhbl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQVRhbl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBVGFuX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVRhbl9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQEFUYW5fRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEFUYW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQVRhbl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQVRhbl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBBVGFuX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IHBlciBpbCBxdWFsZSBjYWxjb2xhcmUgaSB2YWxvcmkgZGkgdGFuZ2VudGUgaW52ZXJzYS5cIixcblx0XCJAQEFUYW4yX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBBVGFuMl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVRhbjJfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBVGFuMl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQVRhbjJfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVRhbjJfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBVGFuMl9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQEFUYW4yX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBBVGFuMl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBBVGFuMl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQVRhbjJfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQVRhbjJfUmFzdGVyX3RhZzBAQFwiOiBcIkwnaW5wdXQgY2hlIHNwZWNpZmljYSBpbCBudW1lcmF0b3JlLCBvIGlsIHZhbG9yZSB5IGRhIHV0aWxpenphcmUgZHVyYW50ZSBpbCBjYWxjb2xvIGRlbGxhIHRhbmdlbnRlIGludmVyc2EuXCIsXG5cdFwiQEBBVGFuMl9SYXN0ZXIyX3RhZzBAQFwiOiBcIkwnaW5wdXQgY2hlIHNwZWNpZmljYSBpbCBkZW5vbWluYXRvcmUsIG8gaWwgdmFsb3JlIHggZGEgdXRpbGl6emFyZSBkdXJhbnRlIGlsIGNhbGNvbG8gZGVsbGEgdGFuZ2VudGUgaW52ZXJzYS5cIixcblx0XCJAQEFUYW5IX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBBVGFuSF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVRhbkhfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBVGFuSF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQVRhbkhfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQVRhbkhfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBBVGFuSF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQEFUYW5IX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBBVGFuSF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBBVGFuSF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQVRhbkhfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQVRhbkhfUmFzdGVyX3RhZzBAQFwiOiBcIkwnaW5wdXQgcGVyIGlsIHF1YWxlIGNhbGNvbGFyZSBpIHZhbG9yaSBkaSB0YW5nZW50ZSBpbnZlcnNhIGlwZXJib2xpY2EuXCIsXG5cdFwiQEBBdHRyaWJ1dGUtVGFibGVfUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEF0dHJpYnV0ZS1UYWJsZV9UYWJsZS1UeXBlX3RhZzBAQFwiOiBcIkxhIHRhYmVsbGEgZGkgYXR0cmlidXRpIGRpIGlucHV0IGNoZSBwdcOyIGVzc2VyZSBpbnNlcml0YSB1dGlsaXp6YW5kbyBpbCB0aXBvIDxzdHJvbmc+TWFudWFsZTwvc3Ryb25nPiBuZWwgcXVhbGUgc2kgYXNzZWduYSB1biBub21lIGNsYXNzZSBlIHVuIGNvbG9yZSBhIG9nbmkgdmFsb3JlLCBvIHNpIHB1w7IgZmFyZSByaWZlcmltZW50byBhIHVuYSB0YWJlbGxhIGVzaXN0ZW50ZSBjaGUgcHJvdmllbmUgZGEgdW4gZmlsZSAkey5kYmZ9LlwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX0JhbmQtSW5kZXhlc190YWcwQEBcIjogXCJEZWZpbmlyZSBsYSBmb3JtdWxhIGFyaXRtZXRpY2EgYmFuZGEgc2Ugc2kgc2VsZXppb25hIDxzdHJvbmc+RGVmaW5pdG88L3N0cm9uZz4gZGFsbCd1dGVudGUgcGVyIDxzdHJvbmc+TWV0b2RvPC9zdHJvbmc+LlwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX0JhbmQtSW5kZXhlc190YWc1QEBcIjogXCJTZSBzaSBzY2VnbGllIHVuIGluZGljZSBwcmVkZWZpbml0byBwZXIgPHN0cm9uZz5NZXRvZG88L3N0cm9uZz4sIGRlZmluaXJlIGxlIGJhbmRlIGNvcnJldHRlIHBlciBpbCBkYXRhc2V0IHJhc3RlciBkaSBpbnB1dCBjb3JyaXNwb25kZW50ZSBhbGwnaW5kaWNlLlwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcwQEBcIjogXCJJbCB0aXBvIGRpIGFsZ29yaXRtbyBBcml0bWV0aWNhIEJhbmRhIGNoZSBzaSBkZXNpZGVyYSBlc2VndWlyZS4gw4ggcG9zc2liaWxlIGRlZmluaXJlIGwnYWxnb3JpdG1vIHBlcnNvbmFsaXp6YXRvIG8gc2NlZ2xpZXJlIHVuIGluZGljZSBwcmVkZWZpbml0by5cIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMUBAXCI6IFwiPHN0cm9uZz5CQUk8L3N0cm9uZz4tLUluZGljZSBkaSBhcmVhIGJydWNpYXRhIChCdXJuIEFyZWEgSW5kZXgpXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzJAQFwiOiBcIjxzdHJvbmc+Q0lnPC9zdHJvbmc+LS1JbmRpY2UgZGkgY2xvcm9maWxsYSAtIFZlcmRlIChDaGxvcm9waHlsbCBJbmRleCAtIEdyZWVuKVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPkNJcmU8L3N0cm9uZz4tLUluZGljZSBkaSBjbG9yb2ZpbGxhIC0gQm9yZG8gcm9zc28gKENobG9yb3BoeWxsIEluZGV4IC0gUmVkIEVkZ2UpXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzRAQFwiOiBcIjxzdHJvbmc+Q2xheSBNaW5lcmFsczwvc3Ryb25nPi0tUmFwcG9ydG8gbWluZXJhbGkgYXJnaWxsYSAoQ2xheSBNaW5lcmFscyBSYXRpbylcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnNUBAXCI6IFwiPHN0cm9uZz5FVkk8L3N0cm9uZz4tLUluZGljZSBkaSB2ZWdldGF6aW9uZSBtaWdsaW9yYXRvIChFbmhhbmNlZCBWZWdldGF0aW9uIEluZGV4KVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWc2QEBcIjogXCI8c3Ryb25nPkZlcnJvdXMgTWluZXJhbHM8L3N0cm9uZz4tLVJhcHBvcnRvIGRpIG1pbmVyYWxpIGZlcnJvc2kgKEZlcnJvdXMgTWluZXJhbHMgUmF0aW8pXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzdAQFwiOiBcIjxzdHJvbmc+R0VNSTwvc3Ryb25nPi0tSW5kaWNlIGRpIG1vbml0b3JhZ2dpbyBhbWJpZW50YWxlIGdsb2JhbGUgKEdsb2JhbCBFbnZpcm9ubWVudGFsIE1vbml0b3JpbmcgSW5kZXgpXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzhAQFwiOiBcIjxzdHJvbmc+R05EVkk8L3N0cm9uZz4tLUluZGljZSBkaSB2ZWdldGF6aW9uZSBhIGRpZmZlcmVuemEgdmVyZGUgbm9ybWFsaXp6YXRvIChHcmVlbiBOb3JtYWxpemVkIERpZmZlcmVuY2UgVmVnZXRhdGlvbiBJbmRleClcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnOUBAXCI6IFwiPHN0cm9uZz5HVkkgKExhbmRzYXQgVE0pPC9zdHJvbmc+LS1JbmRpY2UgZGkgdmVnZXRhemlvbmUgdmVyZGUgTGFuZHNhdCBUTSAoR3JlZW4gVmVnZXRhdGlvbiBJbmRleCBMYW5kc2F0IFRNKVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcxMEBAXCI6IFwiPHN0cm9uZz5Jcm9uIE94aWRlPC9zdHJvbmc+LS1SYXBwb3J0byBvc3NpZG8gZGkgZmVycm8gKElyb24gT3hpZGUgUmF0aW8pXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzExQEBcIjogXCI8c3Ryb25nPk1ORFdJPC9zdHJvbmc+LS1JbmRpY2UgaWRyaWNvIGRpIGRpZmZlcmVuemEgbm9ybWFsaXp6YXRvIG1vZGlmaWNhdG8gKE1vZGlmaWVkIE5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBXYXRlciBJbmRleClcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMTJAQFwiOiBcIjxzdHJvbmc+TVRWSTI8L3N0cm9uZz4tLUluZGljZSBkaSB2ZWdldGF6aW9uZSB0cmlhbmdvbGF0byBtb2RpZmljYXRvIChzZWNvbmRhIGl0ZXJhemlvbmUpIChNb2RpZmllZCBUcmlhbmd1bGF0ZWQgVmVnZXRhdGlvbiBJbmRleCAoc2Vjb25kIGl0ZXJhdGlvbikpXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzEzQEBcIjogXCI8c3Ryb25nPk1vZGlmaWVkIFNBVkk8L3N0cm9uZz4tLUluZGljZSBkaSB2ZWdldGF6aW9uZSBhZ2dpdXN0YXRvIGFsIHN1b2xvIG1vZGlmaWNhdG8gKE1vZGlmaWVkIFNvaWwgQWRqdXN0ZWQgVmVnZXRhdGlvbiBJbmRleClcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMTRAQFwiOiBcIjxzdHJvbmc+TkJSPC9zdHJvbmc+LS1JbmRpY2UgZGVsIHJhcHBvcnRvIGRpIGNvbWJ1c3Rpb25lIG5vcm1hbGl6emF0byAoTm9ybWFsaXplZCBCdXJuIFJhdGlvIEluZGV4KVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcxNUBAXCI6IFwiPHN0cm9uZz5OREJJPC9zdHJvbmc+LS1JbmRpY2UgZGkgYWNjdW11bG8gZGkgZGlmZmVyZW56YSBub3JtYWxpenphdG8gKE5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBCdWlsdC11cCBJbmRleClcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMTZAQFwiOiBcIjxzdHJvbmc+TkRNSTwvc3Ryb25nPi0tSW5kaWNlIGRpIHVtaWRpdMOgIGRpZmZlcmVuemlhbGUgbm9ybWFsaXp6YXRvIChOb3JtYWxpemVkIERpZmZlcmVuY2UgTW9pc3R1cmUgSW5kZXgpXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzE3QEBcIjogXCI8c3Ryb25nPk5EU0k8L3N0cm9uZz4tLUluZGljZSBkaSBkaWZmZXJlbnphIGRpIG5ldmUgbm9ybWFsaXp6YXRvIChOb3JtYWxpemVkIERpZmZlcmVuY2UgU25vdyBJbmRleClcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMThAQFwiOiBcIjxzdHJvbmc+TkRWSTwvc3Ryb25nPi0tSW5kaWNlIGRpIHZlZ2V0YXppb25lIGEgZGlmZmVyZW56YSBub3JtYWxpenphdGEgKE5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBWZWdldGF0aW9uIEluZGV4KVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcxOUBAXCI6IFwiPHN0cm9uZz5ORFZJcmU8L3N0cm9uZz4tLUluZGljZSBkaSB2ZWdldGF6aW9uZSBhIGRpZmZlcmVuemEgbm9ybWFsaXp6YXRhIGRpIFJlZC1FZGdlIChSZWQtRWRnZSBOb3JtYWxpemVkIERpZmZlcmVuY2UgVmVnZXRhdGlvbiBJbmRleClcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjBAQFwiOiBcIjxzdHJvbmc+TkRXSTwvc3Ryb25nPi0tSW5kaWNlIGRpIGRpZmZlcmVuemEgZGVsbCdhY3F1YSBub3JtYWxpenphdG8gKE5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBXYXRlciBJbmRleClcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjFAQFwiOiBcIjxzdHJvbmc+UFZJPC9zdHJvbmc+LS1JbmRpY2UgZGkgdmVnZXRhemlvbmUgcGVycGVuZGljb2xhcmUgKFBlcnBlbmRpY3VsYXIgVmVnZXRhdGlvbiBJbmRleClcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjJAQFwiOiBcIjxzdHJvbmc+UlRWSUNvcmU8L3N0cm9uZz4tLUluZGljZSBkaSB2ZWdldGF6aW9uZSB0cmlhbmdvbGF0byBhIGJvcmRpIHJvc3NpIChSZWQtRWRnZSBUcmlhbmd1bGF0ZWQgVmVnZXRhdGlvbiBJbmRleClcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjNAQFwiOiBcIjxzdHJvbmc+U0FWSTwvc3Ryb25nPi0tSW5kaWNlIGRpIHZlZ2V0YXppb25lIGNvcnJldHRvIHBlciBpbCBzdW9sbyAoU29pbCBBZGp1c3RlZCBWZWdldGF0aW9uIEluZGV4KVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyNEBAXCI6IFwiPHN0cm9uZz5TUjwvc3Ryb25nPi0tUmFwcG9ydG8gc2VtcGxpY2UgKFNpbXBsZSBSYXRpbylcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjVAQFwiOiBcIjxzdHJvbmc+U1JyZTwvc3Ryb25nPi0tUmFwcG9ydG8gc2VtcGxpY2UgYm9yZG8gcm9zc28gKFJlZC1FZGdlIFNpbXBsZSBSYXRpbylcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjZAQFwiOiBcIjxzdHJvbmc+U3VsdGFuJ3MgRm9ybXVsYTwvc3Ryb25nPi0tRm9ybXVsYSBkaSBTdWx0YW4gKFN1bHRhbidzIEZvcm11bGEpXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzI3QEBcIjogXCI8c3Ryb25nPlRyYW5zZm9ybWVkIFNBVkk8L3N0cm9uZz4tLUluZGljZSBkaSB2ZWdldGF6aW9uZSB0cmFzZm9ybWF0byBhZ2dpdXN0YXRvIHBlciBpbCBzdW9sbyAoVHJhbnNmb3JtZWQgU29pbCBBZGp1c3RlZCBWZWdldGF0aW9uIEluZGV4KVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyOEBAXCI6IFwiPHN0cm9uZz5Vc2VyIERlZmluZWQ8L3N0cm9uZz4tLVBlcm1ldHRlIGRpIGRlZmluaXJlIHVuJ2VzcHJlc3Npb25lIGFyaXRtZXRpY2EgZGkgYmFuZGEgcGVyc29uYWxpenphdGEgKEFsbG93cyB5b3UgdG8gZGVmaW5lIHlvdXIgY3VzdG9tIGJhbmQgYXJpdGhtZXRpYyBleHByZXNzaW9uKVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyOUBAXCI6IFwiPHN0cm9uZz5WQVJJPC9zdHJvbmc+LS1JbmRpY2UgZGkgcmVzaXN0ZW56YSBhdG1vc2ZlcmljYSB2aXNpYmlsZSAoVmlzaWJsZSBBdG1vc3BoZXJpY2FsbHkgUmVzaXN0YW50IEluZGV4KVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWczMEBAXCI6IFwiPHN0cm9uZz5XTkRXSTwvc3Ryb25nPi0tRGlmZmVyZW56YSBwb25kZXJhdGEgbm9ybWFsaXp6YXRhIGRlbGwnaW5kaWNlIGQnYWNxdWEgKFdlaWdodGVkIE5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBXYXRlciBJbmRleClcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQmluYXJ5LVRocmVzaG9sZGluZ19SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQml0d2lzZS1BbmRfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAQml0d2lzZS1BbmRfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcHJpbW8gaW5wdXQgZGEgdXNhcmUgaW4gcXVlc3RhIG9wZXJhemlvbmUgYml0d2lzZS5cIixcblx0XCJAQEJpdHdpc2UtQW5kX1Jhc3Rlcl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9SYXN0ZXIyX3RhZzBAQFwiOiBcIklsIHNlY29uZG8gaW5wdXQgZGEgdXNhcmUgaW4gcXVlc3RhIG9wZXJhemlvbmUgYml0d2lzZS5cIixcblx0XCJAQEJpdHdpc2UtQW5kX1Jhc3RlcjJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAQml0d2lzZS1MZWZ0LVNoaWZ0X0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBCaXR3aXNlLUxlZnQtU2hpZnRfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQml0d2lzZS1MZWZ0LVNoaWZ0X0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQml0d2lzZS1MZWZ0LVNoaWZ0X0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQml0d2lzZS1MZWZ0LVNoaWZ0X0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9SYXN0ZXJfdGFnMEBAXCI6IFwiTCdpbnB1dCBzdWwgcXVhbGUgZXNlZ3VpcmUgbG8gc3Bvc3RhbWVudG8uXCIsXG5cdFwiQEBCaXR3aXNlLUxlZnQtU2hpZnRfUmFzdGVyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9SYXN0ZXIyX3RhZzBAQFwiOiBcIkwnaW5wdXQgY2hlIGRlZmluaXNjZSBpbCBudW1lcm8gZGkgcG9zaXppb25pIGRlbGxlIHF1YWxpIHNwb3N0YXJlIGkgYml0LlwiLFxuXHRcIkBAQml0d2lzZS1MZWZ0LVNoaWZ0X1Jhc3RlcjJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAQml0d2lzZS1Ob3RfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQEJpdHdpc2UtTm90X0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtTm90X0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtTm90X0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAQml0d2lzZS1Ob3RfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJpdHdpc2UtTm90X0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJpdHdpc2UtTm90X0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IHN1bCBxdWFsZSBlc2VndWlyZSBsJ29wZXJhemlvbmUgQml0d2lzZSBOb3QgKHN1cHBsZW1lbnRvKVwiLFxuXHRcIkBAQml0d2lzZS1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtT3JfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJpdHdpc2UtT3JfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtT3JfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBCaXR3aXNlLU9yX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCaXR3aXNlLU9yX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJpdHdpc2UtT3JfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJpdHdpc2UtT3JfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcHJpbW8gaW5wdXQgZGEgdXNhcmUgaW4gcXVlc3RhIG9wZXJhemlvbmUgYml0d2lzZS5cIixcblx0XCJAQEJpdHdpc2UtT3JfUmFzdGVyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQEJpdHdpc2UtT3JfUmFzdGVyMl90YWcwQEBcIjogXCJJbCBzZWNvbmRvIGlucHV0IGRhIHVzYXJlIGluIHF1ZXN0YSBvcGVyYXppb25lIGJpdHdpc2UuXCIsXG5cdFwiQEBCaXR3aXNlLU9yX1Jhc3RlcjJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9SYXN0ZXJfdGFnMEBAXCI6IFwiTCdpbnB1dCBzdWwgcXVhbGUgZXNlZ3VpcmUgbG8gc3Bvc3RhbWVudG8uXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X1Jhc3Rlcl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X1Jhc3RlcjJfdGFnMEBAXCI6IFwiTCdpbnB1dCBjaGUgZGVmaW5pc2NlIGlsIG51bWVybyBkaSBwb3NpemlvbmkgZGVsbGUgcXVhbGkgc3Bvc3RhcmUgaSBiaXQuXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X1Jhc3RlcjJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAQml0d2lzZS1Yb3JfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAQml0d2lzZS1Yb3JfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcHJpbW8gaW5wdXQgZGEgdXNhcmUgaW4gcXVlc3RhIG9wZXJhemlvbmUgYml0d2lzZS5cIixcblx0XCJAQEJpdHdpc2UtWG9yX1Jhc3Rlcl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9SYXN0ZXIyX3RhZzBAQFwiOiBcIklsIHNlY29uZG8gaW5wdXQgZGEgdXNhcmUgaW4gcXVlc3RhIG9wZXJhemlvbmUgYml0d2lzZS5cIixcblx0XCJAQEJpdHdpc2UtWG9yX1Jhc3RlcjJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcHJpbW8gaW5wdXQgZGEgdXNhcmUgaW4gcXVlc3RhIG9wZXJhemlvbmUgYm9vbGVhbmEuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9SYXN0ZXJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfUmFzdGVyMl90YWcwQEBcIjogXCJJbCBzZWNvbmRvIGlucHV0IGRhIHVzYXJlIGluIHF1ZXN0YSBvcGVyYXppb25lIGJvb2xlYW5hLlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfUmFzdGVyMl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBCb29sZWFuLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJvb2xlYW4tTm90X0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJvb2xlYW4tTm90X0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJvb2xlYW4tTm90X0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBCb29sZWFuLU5vdF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJvb2xlYW4tTm90X0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJvb2xlYW4tTm90X1Jhc3Rlcl90YWcwQEBcIjogXCJJbCBwcmltbyBpbnB1dCBkYSB1c2FyZSBpbiBxdWVzdGEgb3BlcmF6aW9uZSBib29sZWFuYS5cIixcblx0XCJAQEJvb2xlYW4tT3JfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQEJvb2xlYW4tT3JfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJvb2xlYW4tT3JfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJvb2xlYW4tT3JfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJvb2xlYW4tT3JfUmFzdGVyX3RhZzBAQFwiOiBcIklsIHByaW1vIGlucHV0IGRhIHVzYXJlIGluIHF1ZXN0YSBvcGVyYXppb25lIGJvb2xlYW5hLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9SYXN0ZXJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9SYXN0ZXIyX3RhZzBAQFwiOiBcIklsIHNlY29uZG8gaW5wdXQgZGEgdXNhcmUgaW4gcXVlc3RhIG9wZXJhemlvbmUgYm9vbGVhbmEuXCIsXG5cdFwiQEBCb29sZWFuLU9yX1Jhc3RlcjJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAQm9vbGVhbi1Yb3JfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAQm9vbGVhbi1Yb3JfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcHJpbW8gaW5wdXQgZGEgdXNhcmUgaW4gcXVlc3RhIG9wZXJhemlvbmUgYm9vbGVhbmEuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9SYXN0ZXJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAQm9vbGVhbi1Yb3JfUmFzdGVyMl90YWcwQEBcIjogXCJJbCBzZWNvbmRvIGlucHV0IGRhIHVzYXJlIGluIHF1ZXN0YSBvcGVyYXppb25lIGJvb2xlYW5hLlwiLFxuXHRcIkBAQm9vbGVhbi1Yb3JfUmFzdGVyMl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBCdWZmZXJlZF9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IGRhIG1lbW9yaXp6YXJlLlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgdXRpbGl6emF0YSBwZXIgY3JlYXJlIGlsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHNjZWdsaWVyZSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIGRpIG91dHB1dCBkYWxsZSBzZWd1ZW50aSBvcHppb25pIG5lbGwnZWxlbmNvIGEgZGlzY2VzYTpcIixcblx0XCJAQENhbGN1bGF0b3JfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCI8c3Ryb25nPlByaW1vIGRpPC9zdHJvbmc+OiBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIGRlbGxhIHByaW1hIHZhcmlhYmlsZSByYXN0ZXIuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiPHN0cm9uZz5NaW4gZGk8L3N0cm9uZz46IGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgbWluaW1hIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0NlbGxzaXplLVR5cGVfdGFnNkBAXCI6IFwiPHN0cm9uZz5NYXggZGk8L3N0cm9uZz46IGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgbWFzc2ltYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9DZWxsc2l6ZS1UeXBlX3RhZzhAQFwiOiBcIjxzdHJvbmc+TWVkaWEgZGk8L3N0cm9uZz46IGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgbWVkaWEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQENhbGN1bGF0b3JfQ2VsbHNpemUtVHlwZV90YWcxMEBAXCI6IFwiPHN0cm9uZz5VbHRpbW8gZGk8L3N0cm9uZz46IGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgZGVsbCd1bHRpbWEgdmFyaWFiaWxlIHJhc3Rlci5cIixcblx0XCJAQENhbGN1bGF0b3JfQ2VsbHNpemUtVHlwZV90YWcxMkBAXCI6IFwiTGEgc2VsZXppb25lIHByZWRlZmluaXRhIMOoIDxzdHJvbmc+TWF4IGRpPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzBAQFwiOiBcIkNyZWFyZSB1bidlc3ByZXNzaW9uZSBhbGdlYnJpY2EgcGVyIGVzZWd1aXJlIGFuYWxpc2kgc3BhemlhbGkgc3VpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxQEBcIjogXCJUdXR0ZSBsZSBmdW56aW9uaSBtYXRlbWF0aWNoZSBlc2lzdGVudGkgZGEgcmljaGlhbWFyZSBwZXIgY3JlYXJlIGwnZXNwcmVzc2lvbmUuIEdsaSBvcGVyYXRvcmkgZGlzcG9uaWJpbGkgc29ubyBlbGVuY2F0aSBkaSBzZWd1aXRvLlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzJAQFwiOiBcIk9wZXJhemlvbmkgYXJpdG1ldGljaGVcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWczQEBcIjogXCJBZGRpemlvbmU6ICtcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWc0QEBcIjogXCJEaXZpc2lvbmU6IC9cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWc1QEBcIjogXCJNb2R1bG86ICVcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWc2QEBcIjogXCJNb2x0aXBsaWNhemlvbmU6ICpcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWc3QEBcIjogXCJQb3RlbnphOiAqKlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzhAQFwiOiBcIlNvdHRyYXppb25lOiAtXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnOUBAXCI6IFwiT3BlcmF6aW9uaSBib29sZWFuZVwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzEwQEBcIjogXCJBbmQgYm9vbGVhbm86ICYmXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMTFAQFwiOiBcIk9yIGJvb2xlYW5vOiB8fFwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzEyQEBcIjogXCJPcGVyYXppb25pIGRpIHJlbGF6aW9uZVwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzEzQEBcIjogXCJVZ3VhbGUgYTogPT1cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxNEBAXCI6IFwiTWFnZ2lvcmUgZGk6ID5cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxNUBAXCI6IFwiTWFnZ2lvcmUgZGkgbyB1Z3VhbGUgYTogPj1cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxNkBAXCI6IFwiTWlub3JlIGRpOiA8XCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMTdAQFwiOiBcIk1pbm9yZSBkaSBvIHVndWFsZSBhOiA8PVwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzE4QEBcIjogXCJEaXZlcnNvIGRhOiAhPVwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzE5QEBcIjogXCJPcGVyYXppb25pIGFnZ2l1bnRpdmVcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcyMEBAXCI6IFwiVW4gbWluaW1vIGRpIGR1ZSByYXN0ZXIgc3UgdW5hIGJhc2UgcGVyIHBpeGVsOiBtaW4oYSxiKVwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzIxQEBcIjogXCJVbiBtYXNzaW1vIGRpIGR1ZSByYXN0ZXIgc3UgdW5hIGJhc2UgcGVyIHBpeGVsOiBtYXgoYSxiKVwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzIyQEBcIjogXCJFY2NvIGFsY3VuaSBlc2VtcGkgZGkgZXNwcmVzc2lvbmk6XCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMjNAQFwiOiBcIklzdHJ1emlvbmUgY29uZGl6aW9uYWxlIHNlbXBsaWNlOiBpbiB1biByYXN0ZXIgKGlkZW50aWZpY2F0byBkYSBUKSB0cm92YXJlIHZhbG9yaSBkaSBlbGV2YXppb25lIHN1cGVyaW9yaSBhaSA0LjAwMCBwaWVkaSBlIGRhcmUgYSB0YWxpIGFyZWUgdW4gdmFsb3JlIGRpIDEgZSBhIHR1dHRlIGxlIGFsdHJlIGFyZWUgdW4gdmFsb3JlIGRpIDAuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMjRAQFwiOiBcIkNvbiAoVCA+IDQwMDAsIDEsIDApXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMjVAQFwiOiBcIklzdHJ1emlvbmUgY29uZGl6aW9uYWxlIG5pZGlmaWNhdGE6IHRyb3ZhcmUgbGUgYXJlZSBuZWxsZSBxdWFsaSBsYSBwZW5kZW56YSAoaWRlbnRpZmljYXRhIGRhIGIxKSDDqCBpbmZlcmlvcmUgYWkgMTAgZ3JhZGkgZSBORFZJIChpZGVudGlmaWNhdG8gZGEgYjIpIMOoIHN1cGVyaW9yZSBhIDAsNSBlIGRhcmUgYSB0YWxpIGFyZWUgdW4gdmFsb3JlIGRpIDEuIFBlciB0dXR0ZSBsZSBhbHRyZSBhcmVlLCBhc3NlZ25hcmUgdW4gdmFsb3JlIGRpIDIgc2UgbGEgcGVuZGVuemEgw6ggc3VwZXJpb3JlIGFpIDEwIGdyYWRpIGUgc2UgbCdlbGV2YXppb25lIChpZGVudGlmaWNhdGEgZGEgYjMpIMOoIHN1cGVyaW9yZSBhaSAyLjUwMCBwaWVkaS4gQSB0dXR0ZSBsZSBhbHRyZSBhcmVlIHZpZW5lIGFzc2VnbmF0byB1biB2YWxvcmUgZGkgMy5cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcyNkBAXCI6IFwiQ29uKChiMSA8IDEwICYmIGIyID4gLjUsIDEsIENvbihiMSA+IDEwICYmIGIzID4gMjUwMCwgMiwgMykpKVwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9leHRlbnR0eXBlX3RhZzBAQFwiOiBcIjxwPlNjZWdsaSBxdWFsZSBlc3RlbnNpb25lIHV0aWxpenphcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6PC9wPjx1bD48bGk+PHA+UHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS48L3A+PC9saT48bGk+SW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48bGk+VW5pb25lIGRpOiB1c2FyZSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuPC9saT48bGk+VWx0aW1vIGRpOiB1c2FyZSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLjwvbGk+PC91bD5cIixcblx0XCJAQENhbGN1bGF0b3JfUmFzdGVyLVZhcmlhYmxlc190YWcwQEBcIjogXCJJbCBub21lIGRlbGxhIHZhcmlhYmlsZSBkZWZpbml0YSBkYWxsJ3V0ZW50ZSBlIGlsIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQENsYXNzaWZ5X0lucHV0LURlZmluaXRpb24tRmlsZV90YWcwQEBcIjogXCJJbCBmaWxlIGRpIGRlZmluaXppb25lIGRlbCBtZXRvZG8gZGkgY2xhc3NpZmljYXppb25lIGRpIEVzcmkgKCR7LmVjZH0pIGNoZSBjb250aWVuZSBsZSBzdGF0aXN0aWNoZSBlIGFsdHJlIGluZm9ybWF6aW9uaSBkaSBjbGFzc2lmaWNhemlvbmUgcGVyIGxvIHNwZWNpZmljbyBkYXRhc2V0LCBjbGFzc2lmaWNhdG9yZSBlIHBlciBnbGkgYXR0cmlidXRpIHNjZWx0aS5cIixcblx0XCJAQENsYXNzaWZ5X1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGF0YXNldCBjaGUgc2kgZGVzaWRlcmEgY2xhc3NpZmljYXJlLlwiLFxuXHRcIkBAQ2xhc3NpZnlfUmFzdGVyMl90YWcwQEBcIjogXCJVbiBkYXRhc2V0IHJhc3RlciBhdXNpbGlhcmlvIG9wemlvbmFsZSBkYSBpbmNvcnBvcmFyZSBuZWwgY2xhc3NpZmljYXRvcmUsIGNvbWUgdW4naW1tYWdpbmUgc2VnbWVudGF0YSwgdW4naW1tYWdpbmUgbXVsdGlzcGV0dHJhbGUgbyBkYXRpIGRpIGVsZXZhemlvbmUsIHV0aWxpenphdG8gcGVyIGdlbmVyYXJlIHVuYSBkZWZpbml6aW9uZSBkZWxsYSBjbGFzc2lmaWNhemlvbmUgcGnDuSBzb2xpZGEgcGVyIGlsIGRhdGFzZXQuIElsIGRhdGFzZXQgcmFzdGVyIHBlciBxdWVzdG8gcGFyYW1ldHJvIGRldmUgY29ycmlzcG9uZGVyZSBhIHF1ZWxsbyB1dGlsaXp6YXRvIHBlciBjcmVhcmUgaWwgZmlsZSBkaSBkZWZpbml6aW9uZSBkZWwgbWV0b2RvIGRpIGNsYXNzaWZpY2F6aW9uZSBkaSBFc3JpIGRpIGlucHV0LlwiLFxuXHRcIkBAQ2xpcF9DbGlwcGluZy1HZW9tZXRyeS1vci1SYXN0ZXJfdGFnMEBAXCI6IFwiUXVhbnRvIHNlZ3VlIHB1w7IgZXNzZXJlIHV0aWxpenphdG8gcGVyIHNwZWNpZmljYXJlIGwnZXN0ZW5zaW9uZSBkaSB0YWdsaW86XCIsXG5cdFwiQEBDbGlwX0NsaXBwaW5nLUdlb21ldHJ5LW9yLVJhc3Rlcl90YWcxQEBcIjogXCI8c3Ryb25nPlJhc3RlciBkaSB0YWdsaW88L3N0cm9uZz46IGVzdGVuc2lvbmUgZGVsIHJhc3RlciBkaSB0YWdsaW9cIixcblx0XCJAQENsaXBfQ2xpcHBpbmctR2VvbWV0cnktb3ItUmFzdGVyX3RhZzNAQFwiOiBcIjxzdHJvbmc+RXN0ZW5zaW9uZSBwZXJzb25hbGl6emF0YTwvc3Ryb25nPjogY29vcmRpbmF0ZSB4IGUgeSBtaW5pbWUgZSBtYXNzaW1lXCIsXG5cdFwiQEBDbGlwX0NsaXBwaW5nLUdlb21ldHJ5LW9yLVJhc3Rlcl90YWc1QEBcIjogXCI8c3Ryb25nPkVzdGVuc2lvbmUgbWFwcGEgY29ycmVudGU8L3N0cm9uZz46IGVzdGVuc2lvbmUgZGkgdmlzdWFsaXp6YXppb25lIGRlbGxhIG1hcHBhIGNvcnJlbnRlXCIsXG5cdFwiQEBDbGlwX0NsaXBwaW5nLVJhc3Rlcl90YWcwQEBcIjogXCJJbCBsYXllciByYXN0ZXIgdXRpbGl6emF0byBwZXIgdGFnbGlhcmUuXCIsXG5cdFwiQEBDbGlwX0NsaXBwaW5nLVR5cGVfdGFnMEBAXCI6IFwiU3BlY2lmaWNhcmUgc2Ugc2kgdnVvbGUgbWFudGVuZXJlIGwnYXJlYSBhbGwnaW50ZXJubyBvIGFsbCdlc3Rlcm5vIGRlbGxhIGdlb21ldHJpYSByaXRhZ2xpYXRhLlwiLFxuXHRcIkBAQ2xpcF9DbGlwcGluZy1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+VGFnbGlhIGFsbCdpbnRlcm5vPC9zdHJvbmc+OiBsZSBpbW1hZ2luaSBhbGwnaW50ZXJubyBkZWxsJ2VzdGVuc2lvbmUgZGVsIHJpdGFnbGlvIHZlcnJhbm5vIHJpbW9zc2UuXCIsXG5cdFwiQEBDbGlwX0NsaXBwaW5nLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5UYWdsaWEgYWxsJ2VzdGVybm88L3N0cm9uZz46IGxlIGltbWFnaW5pIGFsbCdlc3Rlcm5vIGRlbGwnZXN0ZW5zaW9uZSBkZWwgcml0YWdsaW8gdmVycmFubm8gcmltb3NzZS5cIixcblx0XCJAQENsaXBfQ3VzdG9tLUV4dGVudF90YWcwQEBcIjogXCJTcGVjaWZpY2FyZSBsZSBxdWF0dHJvIGNvb3JkaW5hdGUgY2hlIGRlZmluaXNjb25vIGwnZXN0ZW5zaW9uZSBkZWwgcmV0dGFuZ29sbyBkaSBzZWxlemlvbmUgdXRpbGl6emF0byBwZXIgdGFnbGlhcmUgaWwgcmFzdGVyLlwiLFxuXHRcIkBAQ2xpcF9PdXRwdXQtRXh0ZW50X3RhZzBAQFwiOiBcIkxlIGNvb3JkaW5hdGUgeCBlIHkgZGVsbCdlc3RlbnNpb25lIGRpIHJpdGFnbGlvIGNvcnJlbnRlLlwiLFxuXHRcIkBAQ2xpcF9PdXRwdXQtRXh0ZW50X3RhZzFAQFwiOiBcIklsIHB1bHNhbnRlIDxzdHJvbmc+Q2F0dHVyYSBlc3RlbnNpb25lIG1hcHBhIGNvcnJlbnRlPC9zdHJvbmc+IHV0aWxpenphIGwnZXN0ZW5zaW9uZSBkaSB2aXN1YWxpenphemlvbmUgcGVyIGxhIG1hcHBhIGF0dGl2YS5cIixcblx0XCJAQENsaXBfUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBsYXllciBkaSBpbnB1dC5cIixcblx0XCJAQENsaXBfVXNlLUlucHV0LUZlYXR1cmVzLWZvci1DbGlwcGluZy1HZW9tZXRyeV90YWcwQEBcIjogXCJRdWFuZG8gdmVuZ29ubyBzZWxlemlvbmF0aSwgaSBkYXRpIHZlbmdvbm8gcml0YWdsaWF0aSBzZWNvbmRvIGxhIGdlb21ldHJpYSBkZWxsYSBmZWF0dXJlIGNsYXNzIHNwZWNpZmljYXRhLlwiLFxuXHRcIkBAQ2xpcF9Vc2UtSW5wdXQtRmVhdHVyZXMtZm9yLUNsaXBwaW5nLUdlb21ldHJ5X3RhZzFAQFwiOiBcIk5vbiBzZWxlemlvbmF0bzogcXVlc3RhIGZ1bnppb25lIHV0aWxpenphIGxhIGdlb21ldHJpYSBkaSByaXRhZ2xpbyBzcGVjaWZpY2F0YSBkYSA8c3Ryb25nPlJldHRhbmdvbG88L3N0cm9uZz4uIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQENsaXBfVXNlLUlucHV0LUZlYXR1cmVzLWZvci1DbGlwcGluZy1HZW9tZXRyeV90YWc0QEBcIjogXCJTZWxlemlvbmF0bzogcXVlc3RhIGZ1bnppb25lIHV0aWxpenphIGxhIGdlb21ldHJpYSBkaSByaXRhZ2xpbyBkZWZpbml0YSBkYSB1bmEgZmVhdHVyZSBjbGFzcy5cIixcblx0XCJAQENvbG9yLU1vZGVsLUNvbnZlcnNpb25fQ29udmVyc2lvbi1UeXBlX3RhZzBAQFwiOiBcIlRpcG8gZGkgY29udmVyc2lvbmUgZGVsIGNvbG9yZSBkYSBlc2VndWlyZTpcIixcblx0XCJAQENvbG9yLU1vZGVsLUNvbnZlcnNpb25fQ29udmVyc2lvbi1UeXBlX3RhZzFAQFwiOiBcIkRhIEhTViBhIFJHQlwiLFxuXHRcIkBAQ29sb3ItTW9kZWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLVR5cGVfdGFnMkBAXCI6IFwiRGEgUkdCIGEgSFNWXCIsXG5cdFwiQEBDb2xvci1Nb2RlbC1Db252ZXJzaW9uX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvci1SYW1wX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSB1bmEgc2NhbGEgY3JvbWF0aWNhIHByZWVzaXN0ZW50ZS5cIixcblx0XCJAQENvbG9ybWFwX0NvbG9yLVNjaGVtZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBpbCB0aXBvIGRpIHNjaGVtYSBkaSBjb2xvcmkgcGVyIGVzZWd1aXJlIGlsIHJlbmRlciBkZWwgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3ItU2NoZW1lLVR5cGVfdGFnMUBAXCI6IFwiU2NhbGEgY3JvbWF0aWNhOiB1dGlsaXp6YXJlIHVuYSBzY2FsYSBjcm9tYXRpY2EuXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvci1TY2hlbWUtVHlwZV90YWcyQEBcIjogXCJNYXBwYSBjb2xvcmU6IHV0aWxpenphcmUgdW5hIG1hcHBhIGNvbG9yZSBwcmVlc2lzdGVudGUuXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvcm1hcF90YWcwQEBcIjogXCJMZSBzZWd1ZW50aSBtYXBwZSBjb2xvcmUgcHJlZGVmaW5pdGUgc29ubyBkaXNwb25pYmlsaSBkYWxsJ2VsZW5jbyBhIGRpc2Nlc2E6XCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvcm1hcF90YWcxQEBcIjogXCJFbGV2YXppb25lOiB1bmEgbWFwcGEgY29sb3JlIGNoZSBjYW1iaWEgZ3JhZHVhbG1lbnRlIGRhbCBjaWFubyBhbCB2aW9sYSBhbCBuZXJvLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnMkBAXCI6IFwiR3JpZ2lvOiB1bmEgbWFwcGEgY29sb3JlIGNoZSBjYW1iaWEgZ3JhZHVhbG1lbnRlIGRhbCBuZXJvIGFsIGJpYW5jby5cIixcblx0XCJAQENvbG9ybWFwX0NvbG9ybWFwX3RhZzdAQFwiOiBcIlJpbGlldm8gb21icmVnZ2lhdG86IHVuYSBtYXBwYSBkaSBjb2xvcmUgcGVyIHZpc3VhbGl6emFyZSB1bmEgcmFwcHJlc2VudGF6aW9uZSBpbiAzRCBkZWxsYSBzdXBlcmZpY2llIGRlbCB0ZXJyZW5vLCBjb24gcG9zaXppb25lIHJlbGF0aXZhIGRlbCBzb2xlIGNvbnNpZGVyYXRhIHBlciBsJ29tYnJlZ2dpYXR1cmEgZGVsbCdpbW1hZ2luZS5cIixcblx0XCJAQENvbG9ybWFwX0NvbG9ybWFwX3RhZzNAQFwiOiBcIk5EVkk6IHVuYSBtYXBwYSBjb2xvcmUgcGVyIHZpc3VhbGl6emFyZSBsYSB2ZWdldGF6aW9uZS4gSSB2YWxvcmkgdmljaW5vIGFsbG8gemVybyBzb25vIGJsdS4gSSB2YWxvcmkgaW5mZXJpb3JpIHNvbm8gbWFycm9uaS4gUXVpbmRpIGkgY29sb3JpIGNhbWJpYW5vIGdyYWR1YWxtZW50ZSBkYWwgcm9zc28sIGFsbCdhcmFuY2lvbmUsIGFsIGdpYWxsbywgYWwgdmVyZGUgZSBhbCBuZXJvIG1lbnRyZSBsJ2luZGljZSBkaSB2ZWdldGF6aW9uZSB2YSBkYWwgYmFzc28gdmVyc28gbCdhbHRvLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnNEBAXCI6IFwiTkRWSTI6IHVuYSBtYXBwYSBjb2xvcmUgcGVyIHZpc3VhbGl6emFyZSBsYSB2ZWdldGF6aW9uZS4gSSB2YWxvcmkgaW5mZXJpb3JpIHZhbm5vIGRhbCBiaWFuY28gYWwgdmVyZGUuIFF1aW5kaSBpIGNvbG9yaSBzcGF6aWFubyBkYWwgZ3JpZ2lvLCBhbCB2aW9sYSwgYWwgYmx1IHNjdXJvIGUgYWwgbmVybyBtZW50cmUgbCdpbmRpY2UgZGkgdmVnZXRhemlvbmUgdmEgZGFsIGJhc3NvIHZlcnNvIGwnYWx0by5cIixcblx0XCJAQENvbG9ybWFwX0NvbG9ybWFwX3RhZzVAQFwiOiBcIk5EVkkzOiB1bmEgbWFwcGEgY29sb3JlIHBlciB2aXN1YWxpenphcmUgbGEgdmVnZXRhemlvbmUuIEkgdmFsb3JpIHZpY2lubyBhbGxvIHplcm8gc29ubyBibHUuIFF1aW5kaSBpIGNvbG9yaSBjYW1iaWFubyBncmFkdWFsbWVudGUgZGFsIHJvc3NvLCBhbGwnYXJhbmNpb25lLCBlIGFsIHZlcmRlIG1lbnRyZSBsJ2luZGljZSBkaSB2ZWdldGF6aW9uZSB2YSBkYWwgYmFzc28gdmVyc28gbCdhbHRvLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnNkBAXCI6IFwiQ2FzdWFsZTogdW5hIG1hcHBhIGNvbG9yZSBjYXN1YWxlLlwiLFxuXHRcIkBAQ29sb3JtYXBfUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQENvbG9ybWFwLVRvLVJHQl9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGNvbG9ybWFwIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29tcGxleF9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29tcG9zaXRlLUJhbmRzX1Jhc3RlcnNfdGFnMEBAXCI6IFwiVXRpbGl6emFyZSBsJ2VsZW5jbyBhIGRpc2Nlc2EgbyBpbCBwdWxzYW50ZSA8c3Ryb25nPlNmb2dsaWE8L3N0cm9uZz4gcGVyIHNjZWdsaWVyZSBnbGkgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAQ29tcG9zaXRlLUJhbmRzX2NlbGxzaXpldHlwZV90YWcwQEBcIjogXCI8cD5TY2VnbGkgbGEgZGltZW5zaW9uZSBjZWxsYSBkYSB1dGlsaXp6YXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRlbGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gaWRlbnRpY2hlLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLjwvcD48dWw+PGxpPlByaW1vIGRpOiB1dGlsaXp6YSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuPC9saT48bGk+TWluaW1vIGRpOiB1dGlsaXp6YSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSBkaSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC48L2xpPjxsaT5NYXNzaW1vIGRpOiB1dGlsaXp6YSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIGRpIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L2xpPjxsaT5NZWRpYSBkaTogdXRpbGl6emEgbGEgZ3JhbmRlenphIGRpIGNlbGxhIG1lZGlhIGRpIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LjwvbGk+PGxpPlVsdGltbyBkaTogdXRpbGl6emEgbCd1bHRpbWEgZ3JhbmRlenphIGRpIGNlbGxhIGRpIHJhc3RlciBkaSBpbnB1dC48L2xpPjwvdWw+XCIsXG5cdFwiQEBDb24tZnVuY3Rpb25fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQENvbi1mdW5jdGlvbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29uLWZ1bmN0aW9uX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29uLWZ1bmN0aW9uX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBDb24tZnVuY3Rpb25fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29uLWZ1bmN0aW9uX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29uX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAQ29uX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBDb25fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQ29uX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBDb25fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQ29uX0ZhbHNlLVJhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IGkgY3VpIHZhbG9yaSBzYXJhbm5vIHVzYXRpIGNvbWUgdmFsb3JpIHBpeGVsIGRpIG91dHB1dCBzZSBsYSBjb25kaXppb25lIMOoIGZhbHNlLiBQdcOyIGVzc2VyZSB1biBudW1lcm8gaW50ZXJvLCB1biByYXN0ZXIgYSB2aXJnb2xhIG1vYmlsZSBvIHVuIHZhbG9yZSBjb3N0YW50ZS5cIixcblx0XCJAQENvbl9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IGNoZSByYXBwcmVzZW50YSBpbCByaXN1bHRhdG8gYm9vbGVhbm8gZGkgdW5hIFJhc3RlciBGdW5jdGlvbiBtYXRlbWF0aWNhIGxvZ2ljYS4gSSB2YWxvcmkgc2FyYW5ubyAxIChwZXIgdHJ1ZSkgbyAwIChwZXIgZmFsc2UpLiBQdcOyIGVzc2VyZSB1biBudW1lcm8gaW50ZXJvIG8gdW4gcmFzdGVyIGEgdmlyZ29sYSBtb2JpbGUuXCIsXG5cdFwiQEBDb25fVHJ1ZS1SYXN0ZXJfdGFnMEBAXCI6IFwiTCdpbnB1dCBpIGN1aSB2YWxvcmkgc2FyYW5ubyB1c2F0aSBjb21lIHZhbG9yaSBwaXhlbCBkaSBvdXRwdXQgc2UgbGEgY29uZGl6aW9uZSDDqCB2ZXJvLiBQdcOyIGVzc2VyZSB1biBudW1lcm8gaW50ZXJvLCB1biByYXN0ZXIgYSB2aXJnb2xhIG1vYmlsZSBvIHVuIHZhbG9yZSBjb3N0YW50ZS5cIixcblx0XCJAQENvbnN0YW50X0NvbnN0YW50X3RhZzBAQFwiOiBcIklsIHZhbG9yZSBkZWxsYSBjb3N0YW50ZSBkYSBhZ2dpdW5nZXJlIGFsIHJhc3RlciB2aXJ0dWFsZS5cIixcblx0XCJAQENvbnN0YW50X1Jhc3Rlci1JbmZvX3RhZzBAQFwiOiBcIlVzYXJlIGlsIHB1bHNhbnRlIDxzdHJvbmc+Q2FyaWNhIHJhc3RlciBkZWwgbW9kZWxsbzwvc3Ryb25nPiBwZXIgY2FyaWNhcmUgdW4gbW9kZWxsbyBkYSB1bmEgZGlyZWN0b3J5IG8gcG9ydGFsZS5cIixcblx0XCJAQENvbnRvdXJfQWRhcHRpdmUtU21vb3RoaW5nX3RhZzBAQFwiOiBcIkxhIHF1YW50aXTDoCBkaSBhbW1vcmJpZGltZW50byBkYSBhcHBsaWNhcmUgYWxsYSBsaW5lYSBkaSBjb250b3Juby4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDIsNS5cIixcblx0XCJAQENvbnRvdXJfQWRhcHRpdmUtU21vb3RoaW5nX3RhZzFAQFwiOiBcIlVuIHZhbG9yZSBpbmZlcmlvcmUgcHJvZHVjZSB1bmEgbGluZWEgZGkgY29udG9ybm8gcGnDuSBncmFudWxhcmUgZSBtZW5vIGFtbW9yYmlkaXRhLCBtZW50cmUgdW4gdmFsb3JlIHN1cGVyaW9yZSBwcm9kdWNlIHVuYSBsaW5lYSBkaSBjb250b3JubyBwacO5IGFtbW9yYmlkaXRhIGNoZSBhcHBhcmUgbWVubyBmcmFzdGFnbGlhdGEuXCIsXG5cdFwiQEBDb250b3VyX0NvbnRvdXItSW50ZXJ2YWxfdGFnMEBAXCI6IFwiTGEgZGlmZmVyZW56YSBkaSBhbHRpdHVkaW5lIHRyYSBsZSBsaW5lZSBkaSBjb250b3Juby5cIixcblx0XCJAQENvbnRvdXJfQ29udG91ci1JbnRlcnZhbF90YWcxQEBcIjogXCJOZWxsZSBhcmVlIHJlbGF0aXZhbWVudGUgcGlhbmUgc2kgdXNhIHVuIGludGVydmFsbG8gZGkgY29udG9ybm8gcGljY29sbywgbWVudHJlIHN1IHVuIHN1b2xvIHZhcmlhYmlsZSBvIG1vbnRhZ25vc28gc2kgdXNhbm8gaW50ZXJ2YWxsaSBkaSBjb250b3JubyBwacO5IGdyYW5kaS5cIixcblx0XCJAQENvbnRvdXJfQ29udG91ci1UeXBlX3RhZzBAQFwiOiBcIklsIHRpcG8gZGkgY29udG9ybm8gZGEgY3JlYXJlOlwiLFxuXHRcIkBAQ29udG91cl9Db250b3VyLVR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5SaWVtcGltZW50byBkZWwgY29udG91cjwvc3Ryb25nPjogcmllbXBpZSBsJ2FyZWEgdHJhIG9nbmkgbGluZWEgZGkgY29udG9ybm8gY29uIGlsIHZhbG9yZSBkaSBlbGV2YXppb25lIHF1YW50aXp6YXRvLlwiLFxuXHRcIkBAQ29udG91cl9Db250b3VyLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5MaW5lZSBkaSBjb250b3Jubzwvc3Ryb25nPjogdW5pc2NlIGkgcHVudGkgZGVsbGEgc3Rlc3NhIGVsZXZhemlvbmUgcGVyIGNyZWFyZSB1bmEgbGluZWEgY2hlIHJhcHByZXNlbnRpIHVuJ2VsZXZhemlvbmUgY29zdGFudGUuXCIsXG5cdFwiQEBDb250b3VyX0NvbnRvdXItVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPlNvbG8gc3VwZXJmaWNpZSBhbW1vcmJpZGl0YTwvc3Ryb25nPjogc2Z1bWEgaWwgbGF5ZXIgZGkgZWxldmF6aW9uZSBkaSBpbnB1dCBtYSBub24gcHJvZHVjZSBDb250b3VyLlwiLFxuXHRcIkBAQ29udG91cl9OdGgtQ29udG91ci1MaW5lLUluLUJvbGRfdGFnMEBAXCI6IFwiSWwgY29udG9ybm8gZGVsbCdpbmRpY2UsIHJhcHByZXNlbnRhdG8gY29tZSB1bmEgbGluZWEgaW4gZ3Jhc3NldHRvLlwiLFxuXHRcIkBAQ29udG91cl9OdGgtQ29udG91ci1MaW5lLUluLUJvbGRfdGFnMUBAXCI6IFwiSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDU7IHF1aW5kaSwgb2duaSA1wqogbGluZWEgZGkgY29udG9ybm8gw6ggaW4gZ3Jhc3NldHRvLlwiLFxuXHRcIkBAQ29udG91cl9OdW1iZXItT2YtQ29udG91cnNfdGFnMEBAXCI6IFwiSWwgbnVtZXJvIGRpIENvbnRvdXIgZGEgZ2VuZXJhcmUgbmVsbGEgdmlzdWFsaXp6YXppb25lLiAgUmVnb2xhIGRpbmFtaWNhbWVudGUgbCdpbnRlcnZhbGxvIGRlaSBDb250b3VycyBwZXIgYWRhdHRhcmUgaWwgc3VvbG8gbmVsbGEgdmlzdWFsaXp6YXppb25lIG1hbnRlbmVuZG8gYWxsbyBzdGVzc28gdGVtcG8gaW50ZXJ2YWxsaSBzdGFuZGFyZGl6emF0aSBjb21lIDEsIDUsIDEwIGUgY29zw6wgdmlhLlwiLFxuXHRcIkBAQ29udG91cl9SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gZGF0YXNldCBkaSBlbGV2YXppb25lIHJhc3RlciBhIGJhbmRhIHNpbmdvbGEuXCIsXG5cdFwiQEBDb250b3VyX1otQmFzZV90YWcwQEBcIjogXCJJbCB2YWxvcmUgZGkgY29udG9ybm8gZGkgYmFzZS4gSSBDb250b3VyIHZlbmdvbm8gZ2VuZXJhdGkgYWwgZGkgc29wcmEgZSBhbCBkaSBzb3R0byBkaSBxdWVzdG8gdmFsb3JlIGEgc2Vjb25kYSBkaSBjacOyIGNoZSBzaWEgbmVjZXNzYXJpbyBwZXIgY29wcmlyZSBsJ2ludGVyYSBnYW1tYSBkaSB2YWxvcmkgZGVsIHJhc3RlciBkaSBpbnB1dC4gTCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEgw6ggMC5cIixcblx0XCJAQENvbnRvdXJfWi1CYXNlX3RhZzFAQFwiOiBcIlVuIHZhbG9yZSAwIHNwZXNzbyByYXBwcmVzZW50YSBpbCBsaXZlbGxvIG1lZGlvIGRlbCBtYXJlLCBhIHNlY29uZGEgZGVsIGRhdGFzZXQgZGkgZWxldmF6aW9uZSBkaSBvcmlnaW5lLlwiLFxuXHRcIkBAQ29udG91cl9aLUZhY3Rvcl90YWcwQEBcIjogXCJJbCBmYXR0b3JlIGRpIGNvbnZlcnNpb25lIGRlbGwndW5pdMOgIHVzYXRvIHF1YW5kbyBzaSBnZW5lcmFubyBDb250b3VyLiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggMS5cIixcblx0XCJAQENvbnRvdXJfWi1GYWN0b3JfdGFnMUBAXCI6IFwiTGUgbGluZWUgZGkgY29udG9ybm8gc29ubyBnZW5lcmF0ZSBpbiBiYXNlIGFpIHZhbG9yaSB6IG5lbCByYXN0ZXIgZGkgaW5wdXQsIHNwZXNzbyBtaXN1cmF0aSBpbiBtZXRyaSBvIHBpZWRpLiBDb24gaWwgdmFsb3JlIHByZWRlZmluaXRvIGRpIDEsIGkgQ29udG91ciBzYXJhbm5vIG5lbGxlIHN0ZXNzZSB1bml0w6AgZGVpIHZhbG9yaSB6IGRlbCByYXN0ZXIgZGkgaW5wdXQuIFBlciBjcmVhcmUgQ29udG91ciBpbiB1bid1bml0w6AgZGl2ZXJzYSBkYSBxdWVsbGEgZGVpIHZhbG9yaSB6LCBpbXBvc3RhcmUgdW4gdmFsb3JlIGFkZWd1YXRvIHBlciBpbCBmYXR0b3JlIHouIFBlciBxdWVzdG8gc3RydW1lbnRvLCBub24gw6ggbmVjZXNzYXJpbyBjaGUgbGUgdW5pdMOgIHgseSBkaSB0ZXJyYSBlIGxlIHVuaXTDoCB6IGRpIHN1cGVyZmljaWUgc2lhbm8gb21vZ2VuZWUuXCIsXG5cdFwiQEBDb250b3VyX1otRmFjdG9yX3RhZzJAQFwiOiBcIkFkIGVzZW1waW8sIHNlIGkgdmFsb3JpIGRpIGVsZXZhemlvbmUgbmVsIHJhc3RlciBkaSBpbnB1dCBzb25vIGVzcHJlc3NpIGluIHBpZWRpIG1hIHNpIGRlc2lkZXJhIGNoZSBpIGNvbnRvcm5pIHNpYW5vIGdlbmVyYXRpIGluIG1ldHJpLCBpbXBvc3RhcmUgaWwgZmF0dG9yZSB6IHN1IDAsMzA0OCAoZGFsIG1vbWVudG8gY2hlIDEgcGllZGUgPSAwLDMwNDggbWV0cmkpLlwiLFxuXHRcIkBAQ29udHJhc3QtYW5kLUJyaWdodG5lc3NfQnJpZ2h0bmVzcy1PZmZzZXRfdGFnMEBAXCI6IFwiUmVnb2xhcmUgbGEgbHVtaW5vc2l0w6AgZGVsIHJhc3RlciBsYXllci5cIixcblx0XCJAQENvbnRyYXN0LWFuZC1CcmlnaHRuZXNzX0JyaWdodG5lc3MtT2Zmc2V0X3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1dGlsaXp6YXJlIGlsIGN1cnNvcmUgcGVyIG1vZGlmaWNhcmUgbCdvZmZzZXQgbHVtaW5vc2l0w6AgbyDDqCBwb3NzaWJpbGUgZGlnaXRhcmUgdW4gdmFsb3JlLlwiLFxuXHRcIkBAQ29udHJhc3QtYW5kLUJyaWdodG5lc3NfQ29udHJhc3QtT2Zmc2V0X3RhZzBAQFwiOiBcIlJlZ29sYXJlIGlsIGNvbnRyYXN0byBkZWwgcmFzdGVyIGxheWVyLlwiLFxuXHRcIkBAQ29udHJhc3QtYW5kLUJyaWdodG5lc3NfQ29udHJhc3QtT2Zmc2V0X3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1dGlsaXp6YXJlIGlsIGN1cnNvcmUgcGVyIG1vZGlmaWNhcmUgbCdvZmZzZXQgY29udHJhc3RvIG8gw6ggcG9zc2liaWxlIGRpZ2l0YXJlIHVuIHZhbG9yZS5cIixcblx0XCJAQENvbnRyYXN0LWFuZC1CcmlnaHRuZXNzX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgc3VsIHF1YWxlIG1vZGlmaWNhcmUgbGEgbHVtaW5vc2l0w6AgZSBpbCBjb250cmFzdG8uXCIsXG5cdFwiQEBDb252b2x1dGlvbl9rZXJuZWxfdGFnMEBAXCI6IFwiPHA+UXVlc3RhIHRhYmVsbGEgbW9zdHJhIGNvbWUgb2duaSBwaXhlbCB2ZXJyw6AgcG9uZGVyYXRvIG5lbCBwcm9jZXNzbyBkaSBmaWx0cmFnZ2lvLiBRdWVzdGEgdGFiZWxsYSBwdcOyIGVzc2VyZSBtb2RpZmljYXRhIHNlIHNpIHNjZWdsaWUgPHN0cm9uZz5EZWZpbml0byBkYWxsJ3V0ZW50PC9zdHJvbmc+ZSBjb21lIDxzdHJvbmc+VGlwbzwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBDb252b2x1dGlvbl9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgZGF0YXNldCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBDb252b2x1dGlvbl9UeXBlX3RhZzBAQFwiOiBcIlNlbGV6aW9uYXJlIGlsIHRpcG8gZGkgZmlsdHJvIGNoZSBzaSB2dW9sZSBlc2VndWlyZS4gVmkgc29ubyBvcHppb25pIGRpIG5pdGlkZXp6YSwgc2ZvY2F0dXJhIGUgcmlsZXZhbWVudG8gbWFyZ2luaSwgbyDDqCBwb3NzaWJpbGUgZGVmaW5pcmUgaWwgcHJvcHJpbyBmaWx0cm8gYmFzYXRvIHN1IGtlcm5lbFwiLFxuXHRcIkBAQ29ycmlkb3JfRGlzdGFuY2UtUmFzdGVyLTFfdGFnMEBAXCI6IFwiSWwgcHJpbW8gcmFzdGVyIGRpIGRpc3RhbnphIGRpIGlucHV0LiBEZXZlIGVzc2VyZSB1biBvdXRwdXQgZGkgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBkYWxsYSBEaXN0YW56YSBkaSBjb3N0byBvIGRhbGxhIERpc3RhbnphIGRpIHBlcmNvcnNvLlwiLFxuXHRcIkBAQ29ycmlkb3JfRGlzdGFuY2UtUmFzdGVyLTJfdGFnMEBAXCI6IFwiSWwgc2Vjb25kbyByYXN0ZXIgZGkgZGlzdGFuemEgZGkgaW5wdXQuIERldmUgZXNzZXJlIHVuIG91dHB1dCBkaSBkaXN0YW56YSBkaSBjb3N0byBjdW11bGF0aXZvIGRhbGxhIERpc3RhbnphIGRpIGNvc3RvIG8gZGFsbGEgRGlzdGFuemEgZGkgcGVyY29yc28uXCIsXG5cdFwiQEBDb3NfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQENvc19DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29zX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29zX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBDb3NfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29zX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29zX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAQ29zX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBDb3NfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQ29zX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBDb3NfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQ29zX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IHBlciBpbCBxdWFsZSBjYWxjb2xhcmUgaSB2YWxvcmkgZGkgY29zZW5vLlwiLFxuXHRcIkBAQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBAQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQENvc0hfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQENvc0hfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQENvc0hfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBDb3NIX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBDb3NIX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQENvc0hfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQENvc0hfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQ29zSF9SYXN0ZXJfdGFnMEBAXCI6IFwiTCdpbnB1dCBwZXIgaWwgcXVhbGUgY2FsY29sYXJlIGkgdmFsb3JpIGRpIGNvc2VubyBpcGVyYm9saWNvLlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcwQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIHNpbXVsYSBsJ2F1bWVudG8gZGVsbG8gc2ZvcnpvIHBlciBzdXBlcmFyZSBpIGNvc3RpIG1hbiBtYW5vIGNoZSBpbCBjb3N0byBjdW11bGF0aXZvIGF1bWVudGEuIFZpZW5lIHVzYXRvIHBlciBtb2RlbGxhcmUgbCdhZmZhdGljYW1lbnRvIGRlbCB2aWFnZ2lhdG9yZS4gSWwgY29zdG8gY3VtdWxhdGl2byBjcmVzY2VudGUgcGVyIHJhZ2dpdW5nZXJlIHVuYSBjZWxsYSB2aWVuZSBtb2x0aXBsaWNhdG8gcGVyIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEgZSBhZ2dpdW50byBhbCBjb3N0byBwZXIgbG8gc3Bvc3RhbWVudG8gbmVsbGEgY2VsbGEgY29uc2VjdXRpdmEuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzFAQFwiOiBcIlNpIHRyYXR0YSBkaSB1bmEgdmVyc2lvbmUgbW9kaWZpY2F0YSBkaSB1bmEgZm9ybXVsYSBjb21wb3N0YSBkaSB0YXNzbyBkaSBpbnRlcmVzc2UgY2hlIHZpZW5lIHV0aWxpenphdGEgcGVyIGNhbGNvbGFyZSBpbCBjb3N0byBhcHBhcmVudGUgZGkgc3Bvc3RhbWVudG8gYXR0cmF2ZXJzbyB1bmEgY2VsbGEuIENvbiBsJ2F1bWVudGFyZSBkZWwgdmFsb3JlIGRlbCB0YXNzbyBkaSByZXNpc3RlbnphLCBhdW1lbnRhIGFuY2hlIGlsIGNvc3RvIGRlbGxlIGNlbGxlIHZpc2l0YXRlIGluIHNlZ3VpdG8uIFF1YW50byBtYWdnaW9yZSDDqCBpbCB0YXNzbyBkaSByZXNpc3RlbnphLCB0YW50byBwacO5IGFsdG8gc2Fyw6AgaWwgY29zdG8gcGVyIHJhZ2dpdW5nZXJlIGxhIGNlbGxhIHN1Y2Nlc3NpdmEsIGNoZSDDqCByZXNpc3RlbnRlIGEgb2duaSBtb3ZpbWVudG8gY29uc2VjdXRpdm8uIERhbCBtb21lbnRvIGNoZSBpbCB0YXNzbyBkaSByZXNpc3RlbnphIMOoIHNpbWlsZSBhIHVuIHRhc3NvIGNvbXBvc3RvIGUgZ2VuZXJhbG1lbnRlIGkgdmFsb3JpIGRpIGNvc3RvIGN1bXVsYXRpdm8gc29ubyBtb2x0byBncmFuZGksIHNpIGNvbnNpZ2xpYW5vIHRhc3NpIGRpIHJlc2lzdGVuemEgcGljY29saSwgY29tZSAwLDAwNSBvIGFuY2hlIG1lbm8sIGEgc2Vjb25kYSBkZWkgdmFsb3JpIGRpIGNvc3RvIGN1bXVsYXRpdmkuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIklsIHZhbG9yZSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBkaSB6ZXJvLiBMYSBjYXBhY2l0w6AgcHJlZGVmaW5pdGEgw6ggZmlubyBhbCBib3JkbyBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnM0BAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHBlciBxdWVzdG8gcGFyYW1ldHJvIHVuIHZhbG9yZSBudW1lcmljbyAoZG9wcGlvKSBvIHVuIGNhbXBvIGRhbCA8c3Ryb25nPlJhc3RlciBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX0NhcGFjaXR5X3RhZzBAQFwiOiBcIkRlZmluaXNjZSBsYSBjYXBhY2l0w6AgZGkgY29zdG8gcGVyIGlsIHZpYWdnaWF0b3JlIHJlbGF0aXZhIGEgdW4nb3JpZ2luZS4gSSBjYWxjb2xpIGRlbCBjb3N0byBjb250aW51YW5vIHBlciBvZ25pIG9yaWdpbmUgZmluY2jDqSBub24gc2kgcmFnZ2l1bmdlIGxhIGNhcGFjaXTDoCBzcGVjaWZpY2F0YS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9DYXBhY2l0eV90YWcxQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgZGkgemVyby4gTGEgY2FwYWNpdMOgIHByZWRlZmluaXRhIMOoIGZpbm8gYWwgYm9yZG8gZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fQ2FwYWNpdHlfdGFnMkBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHBlciBxdWVzdG8gcGFyYW1ldHJvIHVuIHZhbG9yZSBudW1lcmljbyAoZG9wcGlvKSBvIHVuIGNhbXBvIGRhbCA8c3Ryb25nPlJhc3RlciBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX0Nvc3QtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBkaSBpbnB1dCBvYmJsaWdhdG9yaW8gY2hlIGRlZmluaXNjZSBpbCBjb3N0byBvIGwnaW1wZWRlbnphIGRlbGxvIHNwb3N0YW1lbnRvIHBsYW5pbWV0cmljbyBhdHRyYXZlcnNvIGNpYXNjdW5hIGNlbGxhLiBJbCB2YWxvcmUgYSBvZ25pIHBvc2l6aW9uZSBkZWxsYSBjZWxsYSByYXBwcmVzZW50YSBsYSBkaXN0YW56YSBkaSBjb3N0byBwZXIgdW5pdMOgIHBlciBsJ2F0dHJhdmVyc2FtZW50byBkZWxsYSBzdGVzc2EuIE9nbmkgdmFsb3JlIGRpIHBvc2l6aW9uZSBkaSB1bmEgY2VsbGEgdmllbmUgbW9sdGlwbGljYXRvIHBlciBsYSByaXNvbHV6aW9uZSBkZWxsYSBjZWxsYSBlIGNvbXBlbnNhIGlub2x0cmUgaWwgbW92aW1lbnRvIGRpYWdvbmFsZSBwZXIgb3R0ZW5lcmUgaWwgY29zdG8gdG90YWxlIGRlbGwnYXR0cmF2ZXJzYW1lbnRvIGRlbGxhIHN0ZXNzYS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Db3N0LVJhc3Rlcl90YWcxQEBcIjogXCJJIHZhbG9yaSBkZWwgPHN0cm9uZz5SYXN0ZXIgZGkgY29zdG88L3N0cm9uZz4gcG9zc29ubyBlc3NlcmUgYSBudW1lcm8gaW50ZXJvIG8gYSB2aXJnb2xhIG1vYmlsZSwgbWEgbm9uIHBvc3Nvbm8gZXNzZXJlIG5lZ2F0aXZpIG8gemVyby5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9NYXhpbXVtLURpc3RhbmNlX3RhZzBAQFwiOiBcIkxhIHNvZ2xpYSBjaGUgaSB2YWxvcmkgZGkgY29zdG8gY3VtdWxhdGl2aSBub24gcG9zc29ubyBzdXBlcmFyZS4gU2UgdW5hIGRpc3RhbnphIGRpIGNvc3RvIGN1bXVsYXRpdm8gc3VwZXJhIHF1ZXN0byB2YWxvcmUsIGlsIHZhbG9yZSBkaSBvdXRwdXQgcGVyIGxhIHBvc2l6aW9uZSBkZWxsYSBjZWxsYSBzYXLDoCAke05vRGF0YX0uIExhIGRpc3RhbnphIG1hc3NpbWEgZGVmaW5pc2NlIGwnZXN0ZW5zaW9uZSBwZXIgbGEgcXVhbGUgc2kgY2FsY29sYW5vIGxlIGRpc3RhbnplIGRpIGNvc3RvIGN1bXVsYXRpdmUuIExhIGRpc3RhbnphIHByZWRlZmluaXRhIMOoIGZpbm8gYWxsJ2VzdGVuc2lvbmUgZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcwQEBcIjogXCJVbiBtb2x0aXBsaWNhdG9yZSBkYSBhcHBsaWNhcmUgYWkgdmFsb3JpIGRpIGNvc3RvLlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMUBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyBjb25zZW50ZSBpbCBjb250cm9sbG8gZGVsbGEgbW9kYWxpdMOgIGRpIHNwb3N0YW1lbnRvIG8gZGVsbGEgZ3JhbmRlenphIGFsbCdvcmlnaW5lLiBNYWdnaW9yZSDDqCBpbCBtb2x0aXBsaWNhdG9yZSwgbWFnZ2lvcmUgw6ggaWwgY29zdG8gcGVyIGxvIHNwb3N0YW1lbnRvIGF0dHJhdmVyc28gb2duaSBjZWxsYS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzJAQFwiOiBcIkkgdmFsb3JpIGRldm9ubyBlc3NlcmUgbWFnZ2lvcmkgZGkgemVyby4gTCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEgw6ggMS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzNAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSBwZXIgcXVlc3RvIHBhcmFtZXRybyB1biB2YWxvcmUgbnVtZXJpY28gKGRvcHBpbykgbyB1biBjYW1wbyBkYWwgPHN0cm9uZz5SYXN0ZXIgb3JpZ2luZTwvc3Ryb25nPi5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Tb3VyY2UtRmllbGRfdGFnMEBAXCI6IFwiSWwgY2FtcG8gdXNhdG8gcGVyIGFzc2VnbmFyZSB2YWxvcmkgYWxsZSBwb3NpemlvbmkgZGkgb3JpZ2luZS4gRGV2ZSBlc3NlcmUgZGkgdGlwbyBudW1lcm8gaW50ZXJvLiBTZSBpbCA8c3Ryb25nPlJhc3RlciB2YWxvcmU8L3N0cm9uZz4gw6ggc3RhdG8gaW1wb3N0YXRvLCBpIHZhbG9yaSBkaSBxdWVsbCdpbnB1dCBhdnJhbm5vIHByaW9yaXTDoCBzdSBxdWFsdW5xdWUgaW1wb3N0YXppb25lIGRpIDxzdHJvbmc+Q2FtcG8gZGkgb3JpZ2luZTwvc3Ryb25nPi5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBvYmJsaWdhdG9yaW8gcGVyIGxlIHBvc2l6aW9uaSBkaSBvcmlnaW5lLlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX1NvdXJjZS1SYXN0ZXJfdGFnMUBAXCI6IFwiw4ggdW4gcmFzdGVyIGNoZSBpZGVudGlmaWNhIGxlIGNlbGxlIG8gbGUgcG9zaXppb25pIGRhbGxlIHF1YWxpIHNpIGNhbGNvbGEgbGEgZGlzdGFuemEgZGkgY29zdG8gbWluaW1hIGN1bXVsYXRpdmEgcGVyIG9nbmkgcG9zaXppb25lIGRpIGNlbGxhIGRpIG91dHB1dC5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzJAQFwiOiBcIlNlIGlsIDxzdHJvbmc+UmFzdGVyIG9yaWdpbmU8L3N0cm9uZz4gZGkgaW5wdXQgw6ggYSB2aXJnb2xhIG1vYmlsZSwgw6ggbmVjZXNzYXJpbyBpbXBvc3RhcmUgaWwgPHN0cm9uZz5SYXN0ZXIgdmFsb3JlPC9zdHJvbmc+IGUgZGV2ZSBlc3NlcmUgdW4gbnVtZXJvIGludGVyby4gSWwgPHN0cm9uZz5SYXN0ZXIgdmFsb3JlPC9zdHJvbmc+IGF2csOgIHByaW9yaXTDoCBzdSBxdWFsdW5xdWUgaW1wb3N0YXppb25lIGRlbCA8c3Ryb25nPkNhbXBvIGRpIG9yaWdpbmU8L3N0cm9uZz4uXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fU3RhcnQtQ29zdF90YWcwQEBcIjogXCJJbCBjb3N0byBkaSBpbml6aW8gY29uIGlsIHF1YWxlIGF2dmlhcmUgaSBjYWxjb2xpIGRlbCBjb3N0by4gUXVlc3RvIHBhcmFtZXRybyBjb25zZW50ZSBkaSBzcGVjaWZpY2FyZSBpbCBjb3N0byBmaXNzbyBhc3NvY2lhdG8gYWQgdW4nb3JpZ2luZS4gSW52ZWNlIGRpIGluaXppYXJlIGNvbiB1biBjb3N0byAwLCBsJ2FsZ29yaXRtbyBkZWwgY29zdG8gaW5pemllcsOgIGNvbiBpbCB2YWxvcmUgc3BlY2lmaWNhdG8uXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fU3RhcnQtQ29zdF90YWcxQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgcGFyaSBvIHN1cGVyaW9yZSBhIHplcm8uIEwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhIMOoIDAuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fVHJhdmVsLURpcmVjdGlvbl90YWcwQEBcIjogXCJEZWZpbmlzY2UgbGEgZGlyZXppb25lIGRlbCB2aWFnZ2lhdG9yZSBxdWFuZG8gc2kgYXBwbGljYSBpbCB0YXNzbyBkaSByZXNpc3RlbnphIGRlbGwnb3JpZ2luZSBlIGlsIGNvc3RvIGluaXppYWxlIGRlbGwnb3JpZ2luZS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+RGFsbCdvcmlnaW5lPC9zdHJvbmc+OiBJbCB0YXNzbyBkaSByZXNpc3RlbnphIGRpIG9yaWdpbmUgZSBpbCBjb3N0byBpbml6aWFsZSBkZWxsJ29yaWdpbmUgc2FyYW5ubyBhcHBsaWNhdGkgYSBwYXJ0aXJlIGRhbGwnb3JpZ2luZSBkaSBpbnB1dCBlIHBvaSBzcG9zdGFuZG9zaSBhbGxlIGNlbGxlIG5vbi1vcmlnaW5lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlZlcnNvIGwnb3JpZ2luZTwvc3Ryb25nPjogSWwgdGFzc28gZGkgcmVzaXN0ZW56YSBkaSBvcmlnaW5lIGUgaWwgY29zdG8gaW5pemlhbGUgZGVsbCdvcmlnaW5lIHNhcmFubm8gYXBwbGljYXRpIGEgcGFydGlyZSBkYSBjaWFzY3VuYSBjZWxsYSBub24tb3JpZ2luZSBlIHBvaSB0b3JuYW5kbyBpbmRpZXRybyBhbGwnb3JpZ2luZSBkaSBpbnB1dC5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzVAQFwiOiBcIlNwZWNpZmljYXJlIGxhIHBhcm9sYSBjaGlhdmUgPHN0cm9uZz5EYWxsJ29yaWdpbmU8L3N0cm9uZz4gbyA8c3Ryb25nPlZlcnNvIGwnb3JpZ2luZTwvc3Ryb25nPiwgY2hlIHNhcsOgIGFwcGxpY2F0YSBhIHR1dHRlIGxlIG9yaWdpbmksIG9wcHVyZSBzcGVjaWZpY2FyZSB1biBjYW1wbyBuZWwgPHN0cm9uZz5SYXN0ZXIgZGkgb3JpZ2luZTwvc3Ryb25nPiBjaGUgY29udGllbmUgbGUgcGFyb2xlIGNoaWF2ZSBwZXIgaWRlbnRpZmljYXJlIGxhIGRpcmV6aW9uZSBkaSB2aWFnZ2lvIHBlciBvZ25pIG9yaWdpbmUuIFF1ZWwgY2FtcG8gZGV2ZSBjb250ZW5lcmUgbGEgc3RyaW5nYSAke0ZST01fU09VUkNFfSBvICR7VE9fU09VUkNFfS5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9WYWx1ZS1SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IGEgbnVtZXJvIGludGVybyBjaGUgaWRlbnRpZmljYSBpIHZhbG9yaSBkaSB6b25hIGRhIHVzYXJlIHBlciBvZ25pIHBvc2l6aW9uZSBkaSBvcmlnaW5lIGRpIGlucHV0LiBQZXIgb2duaSBjZWxsYSBkaSBwb3NpemlvbmUgZGkgb3JpZ2luZSwgaWwgdmFsb3JlIGRlZmluaXRvIGRhbCA8c3Ryb25nPlJhc3RlciBkaSB2YWxvcmk8L3N0cm9uZz4gc2Fyw6AgYXNzZWduYXRvIGEgdHV0dGUgbGUgY2VsbGUgYXNzZWduYXRlIGFsbGEgcG9zaXppb25lIGRpIG9yaWdpbmUgcGVyIGlsIGNhbGNvbG8uIElsIDxzdHJvbmc+UmFzdGVyIGRpIHZhbG9yaTwvc3Ryb25nPiBhdnLDoCBwcmlvcml0w6Agc3UgcXVhbHVucXVlIGltcG9zdGF6aW9uZSBwZXIgaWwgPHN0cm9uZz5DYW1wbyBkaSBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzBAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gc2ltdWxhIGwnYXVtZW50byBkZWxsbyBzZm9yem8gcGVyIHN1cGVyYXJlIGkgY29zdGkgbWFuIG1hbm8gY2hlIGlsIGNvc3RvIGN1bXVsYXRpdm8gYXVtZW50YS4gVmllbmUgdXNhdG8gcGVyIG1vZGVsbGFyZSBsJ2FmZmF0aWNhbWVudG8gZGVsIHZpYWdnaWF0b3JlLiBJbCBjb3N0byBjdW11bGF0aXZvIGNyZXNjZW50ZSBwZXIgcmFnZ2l1bmdlcmUgdW5hIGNlbGxhIHZpZW5lIG1vbHRpcGxpY2F0byBwZXIgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSBlIGFnZ2l1bnRvIGFsIGNvc3RvIHBlciBsbyBzcG9zdGFtZW50byBuZWxsYSBjZWxsYSBjb25zZWN1dGl2YS5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcxQEBcIjogXCJTaSB0cmF0dGEgZGkgdW5hIHZlcnNpb25lIG1vZGlmaWNhdGEgZGkgdW5hIGZvcm11bGEgY29tcG9zdGEgZGkgdGFzc28gZGkgaW50ZXJlc3NlIGNoZSB2aWVuZSB1dGlsaXp6YXRhIHBlciBjYWxjb2xhcmUgaWwgY29zdG8gYXBwYXJlbnRlIGRpIHNwb3N0YW1lbnRvIGF0dHJhdmVyc28gdW5hIGNlbGxhLiBDb24gbCdhdW1lbnRhcmUgZGVsIHZhbG9yZSBkZWwgdGFzc28gZGkgcmVzaXN0ZW56YSwgYXVtZW50YSBhbmNoZSBpbCBjb3N0byBkZWxsZSBjZWxsZSB2aXNpdGF0ZSBpbiBzZWd1aXRvLiBRdWFudG8gbWFnZ2lvcmUgw6ggaWwgdGFzc28gZGkgcmVzaXN0ZW56YSwgdGFudG8gcGnDuSBhbHRvIHNhcsOgIGlsIGNvc3RvIHBlciByYWdnaXVuZ2VyZSBsYSBjZWxsYSBzdWNjZXNzaXZhLCBjaGUgw6ggcmVzaXN0ZW50ZSBhIG9nbmkgbW92aW1lbnRvIGNvbnNlY3V0aXZvLiBEYWwgbW9tZW50byBjaGUgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSDDqCBzaW1pbGUgYSB1biB0YXNzbyBjb21wb3N0byBlIGdlbmVyYWxtZW50ZSBpIHZhbG9yaSBkaSBjb3N0byBjdW11bGF0aXZvIHNvbm8gbW9sdG8gZ3JhbmRpLCBzaSBjb25zaWdsaWFubyB0YXNzaSBkaSByZXNpc3RlbnphIHBpY2NvbGksIGNvbWUgMCwwMDUgbyBhbmNoZSBtZW5vLCBhIHNlY29uZGEgZGVpIHZhbG9yaSBkaSBjb3N0byBjdW11bGF0aXZpLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIklsIHZhbG9yZSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBkaSB6ZXJvLiBMYSBjYXBhY2l0w6AgcHJlZGVmaW5pdGEgw6ggZmlubyBhbCBib3JkbyBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWczQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgcGVyIHF1ZXN0byBwYXJhbWV0cm8gdW4gdmFsb3JlIG51bWVyaWNvIChkb3BwaW8pIG8gdW4gY2FtcG8gZGFsIDxzdHJvbmc+UmFzdGVyIG9yaWdpbmU8L3N0cm9uZz4uXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19DYXBhY2l0eV90YWcwQEBcIjogXCJEZWZpbmlzY2UgbGEgY2FwYWNpdMOgIGRpIGNvc3RvIHBlciBpbCB2aWFnZ2lhdG9yZSByZWxhdGl2YSBhIHVuJ29yaWdpbmUuIEkgY2FsY29saSBkZWwgY29zdG8gY29udGludWFubyBwZXIgb2duaSBvcmlnaW5lIGZpbmNow6kgbm9uIHNpIHJhZ2dpdW5nZSBsYSBjYXBhY2l0w6Agc3BlY2lmaWNhdGEuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19DYXBhY2l0eV90YWcxQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgZGkgemVyby4gTGEgY2FwYWNpdMOgIHByZWRlZmluaXRhIMOoIGZpbm8gYWwgYm9yZG8gZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19DYXBhY2l0eV90YWcyQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgcGVyIHF1ZXN0byBwYXJhbWV0cm8gdW4gdmFsb3JlIG51bWVyaWNvIChkb3BwaW8pIG8gdW4gY2FtcG8gZGFsIDxzdHJvbmc+UmFzdGVyIG9yaWdpbmU8L3N0cm9uZz4uXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19Db3N0LVJhc3Rlcl90YWcwQEBcIjogXCJVbiByYXN0ZXIgZGkgaW5wdXQgb2JibGlnYXRvcmlvIGNoZSBkZWZpbmlzY2UgaWwgY29zdG8gbyBsJ2ltcGVkZW56YSBkZWxsbyBzcG9zdGFtZW50byBwbGFuaW1ldHJpY28gYXR0cmF2ZXJzbyBjaWFzY3VuYSBjZWxsYS4gSWwgdmFsb3JlIGEgb2duaSBwb3NpemlvbmUgZGVsbGEgY2VsbGEgcmFwcHJlc2VudGEgbGEgZGlzdGFuemEgZGkgY29zdG8gcGVyIHVuaXTDoCBwZXIgbCdhdHRyYXZlcnNhbWVudG8gZGVsbGEgc3Rlc3NhLiBPZ25pIHZhbG9yZSBkaSBwb3NpemlvbmUgZGkgdW5hIGNlbGxhIHZpZW5lIG1vbHRpcGxpY2F0byBwZXIgbGEgcmlzb2x1emlvbmUgZGVsbGEgY2VsbGEgZSBjb21wZW5zYSBpbm9sdHJlIGlsIG1vdmltZW50byBkaWFnb25hbGUgcGVyIG90dGVuZXJlIGlsIGNvc3RvIHRvdGFsZSBkZWxsJ2F0dHJhdmVyc2FtZW50byBkZWxsYSBzdGVzc2EuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19Db3N0LVJhc3Rlcl90YWcxQEBcIjogXCJJIHZhbG9yaSBkZWwgPHN0cm9uZz5SYXN0ZXIgZGkgY29zdG88L3N0cm9uZz4gcG9zc29ubyBlc3NlcmUgYSBudW1lcm8gaW50ZXJvIG8gYSB2aXJnb2xhIG1vYmlsZSwgbWEgbm9uIHBvc3Nvbm8gZXNzZXJlIG5lZ2F0aXZpIG8gemVyby5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiTGEgc29nbGlhIGNoZSBpIHZhbG9yaSBkaSBjb3N0byBjdW11bGF0aXZpIG5vbiBwb3Nzb25vIHN1cGVyYXJlLiBTZSB1bmEgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBzdXBlcmEgcXVlc3RvIHZhbG9yZSwgaWwgdmFsb3JlIGRpIG91dHB1dCBwZXIgbGEgcG9zaXppb25lIGRlbGxhIGNlbGxhIHNhcsOgIE5vRGF0YS4gTGEgZGlzdGFuemEgbWFzc2ltYSBkZWZpbmlzY2UgbCdlc3RlbnNpb25lIHBlciBsYSBxdWFsZSBzaSBjYWxjb2xhbm8gbGUgZGlzdGFuemUgZGkgY29zdG8gY3VtdWxhdGl2ZS4gTGEgZGlzdGFuemEgcHJlZGVmaW5pdGEgw6ggZmlubyBhbGwnZXN0ZW5zaW9uZSBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiVW4gbW9sdGlwbGljYXRvcmUgZGEgYXBwbGljYXJlIGFpIHZhbG9yaSBkaSBjb3N0by5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMUBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyBjb25zZW50ZSBpbCBjb250cm9sbG8gZGVsbGEgbW9kYWxpdMOgIGRpIHNwb3N0YW1lbnRvIG8gZGVsbGEgZ3JhbmRlenphIGFsbCdvcmlnaW5lLiBNYWdnaW9yZSDDqCBpbCBtb2x0aXBsaWNhdG9yZSwgbWFnZ2lvcmUgw6ggaWwgY29zdG8gcGVyIGxvIHNwb3N0YW1lbnRvIGF0dHJhdmVyc28gb2duaSBjZWxsYS5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMkBAXCI6IFwiSSB2YWxvcmkgZGV2b25vIGVzc2VyZSBtYWdnaW9yaSBkaSB6ZXJvLiBMJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YSDDqCAxLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWczQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgcGVyIHF1ZXN0byBwYXJhbWV0cm8gdW4gdmFsb3JlIG51bWVyaWNvIChkb3BwaW8pIG8gdW4gY2FtcG8gZGFsIDxzdHJvbmc+UmFzdGVyIG9yaWdpbmU8L3N0cm9uZz4uXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBvYmJsaWdhdG9yaW8gcGVyIGxlIHBvc2l6aW9uaSBkaSBvcmlnaW5lLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfU291cmNlLVJhc3Rlcl90YWcxQEBcIjogXCLDiCB1biByYXN0ZXIgY2hlIGlkZW50aWZpY2EgbGUgY2VsbGUgbyBsZSBwb3NpemlvbmkgZGFsbGUgcXVhbGkgc2kgY2FsY29sYSBsYSBkaXN0YW56YSBkaSBjb3N0byBtaW5pbWEgY3VtdWxhdGl2YSBwZXIgb2duaSBwb3NpemlvbmUgZGkgY2VsbGEgZGkgb3V0cHV0LlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfU3RhcnQtQ29zdF90YWcwQEBcIjogXCJJbCBjb3N0byBkaSBpbml6aW8gY29uIGlsIHF1YWxlIGF2dmlhcmUgaSBjYWxjb2xpIGRlbCBjb3N0by4gUXVlc3RvIHBhcmFtZXRybyBjb25zZW50ZSBkaSBzcGVjaWZpY2FyZSBpbCBjb3N0byBmaXNzbyBhc3NvY2lhdG8gYWQgdW4nb3JpZ2luZS4gSW52ZWNlIGRpIGluaXppYXJlIGNvbiB1biBjb3N0byAwLCBsJ2FsZ29yaXRtbyBkZWwgY29zdG8gaW5pemllcsOgIGNvbiBpbCB2YWxvcmUgc3BlY2lmaWNhdG8uXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19TdGFydC1Db3N0X3RhZzFAQFwiOiBcIklsIHZhbG9yZSBkZXZlIGVzc2VyZSBwYXJpIG8gc3VwZXJpb3JlIGEgemVyby4gTCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEgw6ggMC5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX1RyYXZlbC1EaXJlY3Rpb25fdGFnMEBAXCI6IFwiRGVmaW5pc2NlIGxhIGRpcmV6aW9uZSBkZWwgdmlhZ2dpYXRvcmUgcXVhbmRvIHNpIGFwcGxpY2EgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSBkZWxsJ29yaWdpbmUgZSBpbCBjb3N0byBpbml6aWFsZSBkZWxsJ29yaWdpbmUuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19UcmF2ZWwtRGlyZWN0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+RGFsbCdvcmlnaW5lPC9zdHJvbmc+OiBJbCB0YXNzbyBkaSByZXNpc3RlbnphIGRpIG9yaWdpbmUgZSBpbCBjb3N0byBpbml6aWFsZSBkZWxsJ29yaWdpbmUgc2FyYW5ubyBhcHBsaWNhdGkgYSBwYXJ0aXJlIGRhbGwnb3JpZ2luZSBkaSBpbnB1dCBlIHBvaSBzcG9zdGFuZG9zaSBhbGxlIGNlbGxlIG5vbi1vcmlnaW5lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19UcmF2ZWwtRGlyZWN0aW9uX3RhZzNAQFwiOiBcIjxzdHJvbmc+VmVyc28gbCdvcmlnaW5lPC9zdHJvbmc+OiBJbCB0YXNzbyBkaSByZXNpc3RlbnphIGRpIG9yaWdpbmUgZSBpbCBjb3N0byBpbml6aWFsZSBkZWxsJ29yaWdpbmUgc2FyYW5ubyBhcHBsaWNhdGkgYSBwYXJ0aXJlIGRhIGNpYXNjdW5hIGNlbGxhIG5vbi1vcmlnaW5lIGUgcG9pIHRvcm5hbmRvIGluZGlldHJvIGFsbCdvcmlnaW5lIGRpIGlucHV0LlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfVHJhdmVsLURpcmVjdGlvbl90YWc1QEBcIjogXCJTcGVjaWZpY2FyZSBsYSBwYXJvbGEgY2hpYXZlIDxzdHJvbmc+RGFsbCdvcmlnaW5lPC9zdHJvbmc+IG8gPHN0cm9uZz5WZXJzbyBsJ29yaWdpbmU8L3N0cm9uZz4sIGNoZSBzYXLDoCBhcHBsaWNhdGEgYSB0dXR0ZSBsZSBvcmlnaW5pLCBvcHB1cmUgc3BlY2lmaWNhcmUgdW4gY2FtcG8gbmVsIDxzdHJvbmc+UmFzdGVyIGRpIG9yaWdpbmU8L3N0cm9uZz4gY2hlIGNvbnRpZW5lIGxlIHBhcm9sZSBjaGlhdmUgcGVyIGlkZW50aWZpY2FyZSBsYSBkaXJlemlvbmUgZGkgdmlhZ2dpbyBwZXIgb2duaSBvcmlnaW5lLiBRdWVsIGNhbXBvIGRldmUgY29udGVuZXJlIGxhIHN0cmluZ2EgJHtGUk9NX1NPVVJDRX0gbyAke1RPX1NPVVJDRX0uXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcwQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIHNpbXVsYSBsJ2F1bWVudG8gZGVsbG8gc2ZvcnpvIHBlciBzdXBlcmFyZSBpIGNvc3RpIG1hbiBtYW5vIGNoZSBpbCBjb3N0byBjdW11bGF0aXZvIGF1bWVudGEuIFZpZW5lIHVzYXRvIHBlciBtb2RlbGxhcmUgbCdhZmZhdGljYW1lbnRvIGRlbCB2aWFnZ2lhdG9yZS4gSWwgY29zdG8gY3VtdWxhdGl2byBjcmVzY2VudGUgcGVyIHJhZ2dpdW5nZXJlIHVuYSBjZWxsYSB2aWVuZSBtb2x0aXBsaWNhdG8gcGVyIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEgZSBhZ2dpdW50byBhbCBjb3N0byBwZXIgbG8gc3Bvc3RhbWVudG8gbmVsbGEgY2VsbGEgY29uc2VjdXRpdmEuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcxQEBcIjogXCJTaSB0cmF0dGEgZGkgdW5hIHZlcnNpb25lIG1vZGlmaWNhdGEgZGkgdW5hIGZvcm11bGEgY29tcG9zdGEgZGkgdGFzc28gZGkgaW50ZXJlc3NlIGNoZSB2aWVuZSB1dGlsaXp6YXRhIHBlciBjYWxjb2xhcmUgaWwgY29zdG8gYXBwYXJlbnRlIGRpIHNwb3N0YW1lbnRvIGF0dHJhdmVyc28gdW5hIGNlbGxhLiBDb24gbCdhdW1lbnRhcmUgZGVsIHZhbG9yZSBkZWwgdGFzc28gZGkgcmVzaXN0ZW56YSwgYXVtZW50YSBhbmNoZSBpbCBjb3N0byBkZWxsZSBjZWxsZSB2aXNpdGF0ZSBpbiBzZWd1aXRvLiBRdWFudG8gbWFnZ2lvcmUgw6ggaWwgdGFzc28gZGkgcmVzaXN0ZW56YSwgdGFudG8gcGnDuSBhbHRvIHNhcsOgIGlsIGNvc3RvIHBlciByYWdnaXVuZ2VyZSBsYSBjZWxsYSBzdWNjZXNzaXZhLCBjaGUgw6ggcmVzaXN0ZW50ZSBhIG9nbmkgbW92aW1lbnRvIGNvbnNlY3V0aXZvLiBEYWwgbW9tZW50byBjaGUgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSDDqCBzaW1pbGUgYSB1biB0YXNzbyBjb21wb3N0byBlIGdlbmVyYWxtZW50ZSBpIHZhbG9yaSBkaSBjb3N0byBjdW11bGF0aXZvIHNvbm8gbW9sdG8gZ3JhbmRpLCBzaSBjb25zaWdsaWFubyB0YXNzaSBkaSByZXNpc3RlbnphIHBpY2NvbGksIGNvbWUgMCwwMDUgbyBhbmNoZSBtZW5vLCBhIHNlY29uZGEgZGVpIHZhbG9yaSBkaSBjb3N0byBjdW11bGF0aXZpLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMkBAXCI6IFwiSWwgdmFsb3JlIGRldmUgZXNzZXJlIG1hZ2dpb3JlIGRpIHplcm8uIExhIGNhcGFjaXTDoCBwcmVkZWZpbml0YSDDqCBmaW5vIGFsIGJvcmRvIGRlbCByYXN0ZXIgZGkgb3V0cHV0LlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnM0BAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHBlciBxdWVzdG8gcGFyYW1ldHJvIHVuIHZhbG9yZSBudW1lcmljbyAoZG9wcGlvKSBvIHVuIGNhbXBvIGRhbCA8c3Ryb25nPlJhc3RlciBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9DYXBhY2l0eV90YWcwQEBcIjogXCJEZWZpbmlzY2UgbGEgY2FwYWNpdMOgIGRpIGNvc3RvIHBlciBpbCB2aWFnZ2lhdG9yZSByZWxhdGl2YSBhIHVuJ29yaWdpbmUuIEkgY2FsY29saSBkZWwgY29zdG8gY29udGludWFubyBwZXIgb2duaSBvcmlnaW5lIGZpbmNow6kgbm9uIHNpIHJhZ2dpdW5nZSBsYSBjYXBhY2l0w6Agc3BlY2lmaWNhdGEuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX0NhcGFjaXR5X3RhZzFAQFwiOiBcIklsIHZhbG9yZSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBkaSB6ZXJvLiBMYSBjYXBhY2l0w6AgcHJlZGVmaW5pdGEgw6ggZmlubyBhbCBib3JkbyBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfQ2FwYWNpdHlfdGFnMkBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHBlciBxdWVzdG8gcGFyYW1ldHJvIHVuIHZhbG9yZSBudW1lcmljbyAoZG9wcGlvKSBvIHVuIGNhbXBvIGRhbCA8c3Ryb25nPlJhc3RlciBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9Db3N0LVJhc3Rlcl90YWcwQEBcIjogXCJVbiByYXN0ZXIgZGkgaW5wdXQgb2JibGlnYXRvcmlvIGNoZSBkZWZpbmlzY2UgaWwgY29zdG8gbyBsJ2ltcGVkZW56YSBkZWxsbyBzcG9zdGFtZW50byBwbGFuaW1ldHJpY28gYXR0cmF2ZXJzbyBjaWFzY3VuYSBjZWxsYS4gSWwgdmFsb3JlIGEgb2duaSBwb3NpemlvbmUgZGVsbGEgY2VsbGEgcmFwcHJlc2VudGEgbGEgZGlzdGFuemEgZGkgY29zdG8gcGVyIHVuaXTDoCBwZXIgbCdhdHRyYXZlcnNhbWVudG8gZGVsbGEgc3Rlc3NhLiBPZ25pIHZhbG9yZSBkaSBwb3NpemlvbmUgZGkgdW5hIGNlbGxhIHZpZW5lIG1vbHRpcGxpY2F0byBwZXIgbGEgcmlzb2x1emlvbmUgZGVsbGEgY2VsbGEgZSBjb21wZW5zYSBpbm9sdHJlIGlsIG1vdmltZW50byBkaWFnb25hbGUgcGVyIG90dGVuZXJlIGlsIGNvc3RvIHRvdGFsZSBkZWxsJ2F0dHJhdmVyc2FtZW50byBkZWxsYSBzdGVzc2EuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX0Nvc3QtUmFzdGVyX3RhZzFAQFwiOiBcIkkgdmFsb3JpIGRlbCA8c3Ryb25nPlJhc3RlciBkaSBjb3N0bzwvc3Ryb25nPiBwb3Nzb25vIGVzc2VyZSBhIG51bWVybyBpbnRlcm8gbyBhIHZpcmdvbGEgbW9iaWxlLCBtYSBub24gcG9zc29ubyBlc3NlcmUgbmVnYXRpdmkgbyB6ZXJvLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9NYXhpbXVtLURpc3RhbmNlX3RhZzBAQFwiOiBcIkxhIHNvZ2xpYSBjaGUgaSB2YWxvcmkgZGkgY29zdG8gY3VtdWxhdGl2aSBub24gcG9zc29ubyBzdXBlcmFyZS4gU2UgdW5hIGRpc3RhbnphIGRpIGNvc3RvIGN1bXVsYXRpdm8gc3VwZXJhIHF1ZXN0byB2YWxvcmUsIGlsIHZhbG9yZSBkaSBvdXRwdXQgcGVyIGxhIHBvc2l6aW9uZSBkZWxsYSBjZWxsYSBzYXLDoCBOb0RhdGEuIExhIGRpc3RhbnphIG1hc3NpbWEgZGVmaW5pc2NlIGwnZXN0ZW5zaW9uZSBwZXIgbGEgcXVhbGUgc2kgY2FsY29sYW5vIGxlIGRpc3RhbnplIGRpIGNvc3RvIGN1bXVsYXRpdmUuIExhIGRpc3RhbnphIHByZWRlZmluaXRhIMOoIGZpbm8gYWxsJ2VzdGVuc2lvbmUgZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiVW4gbW9sdGlwbGljYXRvcmUgZGEgYXBwbGljYXJlIGFpIHZhbG9yaSBkaSBjb3N0by5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcxQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIGNvbnNlbnRlIGlsIGNvbnRyb2xsbyBkZWxsYSBtb2RhbGl0w6AgZGkgc3Bvc3RhbWVudG8gbyBkZWxsYSBncmFuZGV6emEgYWxsJ29yaWdpbmUuIE1hZ2dpb3JlIMOoIGlsIG1vbHRpcGxpY2F0b3JlLCBtYWdnaW9yZSDDqCBpbCBjb3N0byBwZXIgbG8gc3Bvc3RhbWVudG8gYXR0cmF2ZXJzbyBvZ25pIGNlbGxhLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzJAQFwiOiBcIkkgdmFsb3JpIGRldm9ubyBlc3NlcmUgbWFnZ2lvcmkgZGkgemVyby4gTCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEgw6ggMS5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWczQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgcGVyIHF1ZXN0byBwYXJhbWV0cm8gdW4gdmFsb3JlIG51bWVyaWNvIChkb3BwaW8pIG8gdW4gY2FtcG8gZGFsIDxzdHJvbmc+UmFzdGVyIG9yaWdpbmU8L3N0cm9uZz4uXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX1NvdXJjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IG9iYmxpZ2F0b3JpbyBwZXIgbGUgcG9zaXppb25pIGRpIG9yaWdpbmUuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX1NvdXJjZS1SYXN0ZXJfdGFnMUBAXCI6IFwiw4ggdW4gcmFzdGVyIGNoZSBpZGVudGlmaWNhIGxlIGNlbGxlIG8gbGUgcG9zaXppb25pIGRhbGxlIHF1YWxpIHNpIGNhbGNvbGEgbGEgZGlzdGFuemEgZGkgY29zdG8gbWluaW1hIGN1bXVsYXRpdmEgcGVyIG9nbmkgcG9zaXppb25lIGRpIGNlbGxhIGRpIG91dHB1dC5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfU3RhcnQtQ29zdF90YWcwQEBcIjogXCJJbCBjb3N0byBkaSBpbml6aW8gY29uIGlsIHF1YWxlIGF2dmlhcmUgaSBjYWxjb2xpIGRlbCBjb3N0by4gUXVlc3RvIHBhcmFtZXRybyBjb25zZW50ZSBkaSBzcGVjaWZpY2FyZSBpbCBjb3N0byBmaXNzbyBhc3NvY2lhdG8gYWQgdW4nb3JpZ2luZS4gSW52ZWNlIGRpIGluaXppYXJlIGNvbiB1biBjb3N0byAwLCBsJ2FsZ29yaXRtbyBkZWwgY29zdG8gaW5pemllcsOgIGNvbiBpbCB2YWxvcmUgc3BlY2lmaWNhdG8uXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX1N0YXJ0LUNvc3RfdGFnMUBAXCI6IFwiSWwgdmFsb3JlIGRldmUgZXNzZXJlIHBhcmkgbyBzdXBlcmlvcmUgYSB6ZXJvLiBMJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YSDDqCAwLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9UcmF2ZWwtRGlyZWN0aW9uX3RhZzBAQFwiOiBcIkRlZmluaXNjZSBsYSBkaXJlemlvbmUgZGVsIHZpYWdnaWF0b3JlIHF1YW5kbyBzaSBhcHBsaWNhIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEgZGVsbCdvcmlnaW5lIGUgaWwgY29zdG8gaW5pemlhbGUgZGVsbCdvcmlnaW5lLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9UcmF2ZWwtRGlyZWN0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+RGFsbCdvcmlnaW5lPC9zdHJvbmc+OiBJbCB0YXNzbyBkaSByZXNpc3RlbnphIGRpIG9yaWdpbmUgZSBpbCBjb3N0byBpbml6aWFsZSBkZWxsJ29yaWdpbmUgc2FyYW5ubyBhcHBsaWNhdGkgYSBwYXJ0aXJlIGRhbGwnb3JpZ2luZSBkaSBpbnB1dCBlIHBvaSBzcG9zdGFuZG9zaSBhbGxlIGNlbGxlIG5vbi1vcmlnaW5lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX1RyYXZlbC1EaXJlY3Rpb25fdGFnM0BAXCI6IFwiPHN0cm9uZz5WZXJzbyBsJ29yaWdpbmU8L3N0cm9uZz46IElsIHRhc3NvIGRpIHJlc2lzdGVuemEgZGkgb3JpZ2luZSBlIGlsIGNvc3RvIGluaXppYWxlIGRlbGwnb3JpZ2luZSBzYXJhbm5vIGFwcGxpY2F0aSBhIHBhcnRpcmUgZGEgY2lhc2N1bmEgY2VsbGEgbm9uLW9yaWdpbmUgZSBwb2kgdG9ybmFuZG8gaW5kaWV0cm8gYWxsJ29yaWdpbmUgZGkgaW5wdXQuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX1RyYXZlbC1EaXJlY3Rpb25fdGFnNUBAXCI6IFwiU3BlY2lmaWNhcmUgbGEgcGFyb2xhIGNoaWF2ZSA8c3Ryb25nPkRhbGwnb3JpZ2luZTwvc3Ryb25nPiBvIDxzdHJvbmc+VmVyc28gbCdvcmlnaW5lPC9zdHJvbmc+LCBjaGUgc2Fyw6AgYXBwbGljYXRhIGEgdHV0dGUgbGUgb3JpZ2luaSwgb3BwdXJlIHNwZWNpZmljYXJlIHVuIGNhbXBvIG5lbCA8c3Ryb25nPlJhc3RlciBkaSBvcmlnaW5lPC9zdHJvbmc+IGNoZSBjb250aWVuZSBsZSBwYXJvbGUgY2hpYXZlIHBlciBpZGVudGlmaWNhcmUgbGEgZGlyZXppb25lIGRpIHZpYWdnaW8gcGVyIG9nbmkgb3JpZ2luZS4gUXVlbCBjYW1wbyBkZXZlIGNvbnRlbmVyZSBsYSBzdHJpbmdhICR7RlJPTV9TT1VSQ0V9IG8gJHtUT19TT1VSQ0V9LlwiLFxuXHRcIkBAQ3VydmF0dXJlX0N1cnZhdHVyZS1UeXBlX3RhZzBAQFwiOiBcIklsIHRpcG8gZGkgY3VydmF0dXJhIGFjY2VudHVhIGRpdmVyc2kgYXNwZXR0aSBkZWxsYSBwZW5kZW56YS4gRXNpc3Rvbm8gdHJlIG9wemlvbmkgZGkgY3VydmF0dXJhOlwiLFxuXHRcIkBAQ3VydmF0dXJlX0N1cnZhdHVyZS1UeXBlX3RhZzFAQFwiOiBcIlN1cGVyZmljaWUgYWxhcmU6IMOoIHBlcnBlbmRpY29sYXJlIGFsbGEgZGlyZXppb25lIGRlbGxhIHBlbmRlbnphIG1hc3NpbWEuIEluZmx1ZW56YSBsYSBjb252ZXJnZW56YSBlIGxhIGRpdmVyZ2VuemEgZGVpIGZsdXNzaSBzdSB1bmEgc3VwZXJmaWNpZS5cIixcblx0XCJAQEN1cnZhdHVyZV9DdXJ2YXR1cmUtVHlwZV90YWcyQEBcIjogXCJQcm9maWxvOiDDqCBwYXJhbGxlbG8gYWxsYSBwZW5kZW56YSBlIGluZGljYSBsYSBkaXJlemlvbmUgZGVsbGEgcGVuZGVuemEgbWFzc2ltYS4gSW5mbHVlbnphIGwnYWNjZWxlcmF6aW9uZSBlIGxhIGRlY2VsZXJhemlvbmUgZGVpIGZsdXNzaSBzdWxsYSBzdXBlcmZpY2llLlwiLFxuXHRcIkBAQ3VydmF0dXJlX0N1cnZhdHVyZS1UeXBlX3RhZzNAQFwiOiBcIlN0YW5kYXJkOiBjb21iaW5hIGxlIGN1cnZhdHVyZSBkaSA8c3Ryb25nPlByb2ZpbG88L3N0cm9uZz4gZSBkaSA8c3Ryb25nPlBsYW5mb3JtPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ3VydmF0dXJlX0RFTV90YWcwQEBcIjogXCJVbiByYXN0ZXIgZGVsIG1vZGVsbG8gZGkgZWxldmF6aW9uZSBkaWdpdGFsZSAoREVNKS5cIixcblx0XCJAQEN1cnZhdHVyZV9aLUZhY3Rvcl90YWcwQEBcIjogXCJJbCBmYXR0b3JlIHogcmVnb2xhIGxlIHVuaXTDoCBkaSBtaXN1cmEgcGVyIGxlIHVuaXTDoCB6IHF1YW5kbyBkaWZmZXJpc2Nvbm8gZGFsbGUgdW5pdMOgIHgseSBkZWxsZSBzdXBlcmZpY2llIGRpIGlucHV0LiBTZSBsZSB1bml0w6AgeCx5IGUgbGUgdW5pdMOgIHogc29ubyByYXBwcmVzZW50YXRlIGNvbiBsYSBzdGVzc2EgdW5pdMOgIGRpIG1pc3VyYSwgaWwgZmF0dG9yZSB6IGRvdnJlYmJlIGVzc2VyZSBpbXBvc3RhdG8gY29tZSAxLiBJIHZhbG9yaSB6IGRlbGxhIHN1cGVyZmljaWUgZGkgaW5wdXQgdmVuZ29ubyBtb2x0aXBsaWNhdGkgcGVyIGlsIGZhdHRvcmUgeiBxdWFuZG8gc2kgY2FsY29sYSBsYSBzdXBlcmZpY2llIGZpbmFsZSBkaSBvdXRwdXQuIEFkIGVzZW1waW8sIHNlIGxlIHVuaXTDoCB6IHNvbm8gZXNwcmVzc2UgaW4gcGllZGkgZSBsZSB1bml0w6AgeCx5IHNvbm8gZXNwcmVzc2UgaW4gbWV0cmksIHNpIHVzZXLDoCB1biBmYXR0b3JlIHogZGkgMCwzMDQ4IHBlciBjb252ZXJ0aXJlIGxlIHVuaXTDoCB6IGRhIHBpZWRpIGEgbWV0cmksIGRhbCBtb21lbnRvIGNoZSAxIHBpZWRlID0gMCwzMDQ4IG1ldHJpLlwiLFxuXHRcIkBARGl2aWRlX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBEaXZpZGVfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQERpdmlkZV9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQERpdmlkZV9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBARGl2aWRlX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQERpdmlkZV9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQERpdmlkZV9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQERpdmlkZV9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBARGl2aWRlX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQERpdmlkZV9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBARGl2aWRlX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQERpdmlkZV9SYXN0ZXJfdGFnMEBAXCI6IFwiTCdpbnB1dCBpbCBjdWkgdmFsb3JlIHZlcnLDoCBkaXZpc28gcGVyIGlsIHNlY29uZG8gaW5wdXQuXCIsXG5cdFwiQEBEaXZpZGVfUmFzdGVyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biBudW1lcm8gY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciAke1Jhc3RlcjJ9LlwiLFxuXHRcIkBARGl2aWRlX1Jhc3RlcjJfdGFnMEBAXCI6IFwiTCdpbnB1dCBpbCBjdWkgdmFsb3JlIHZlcnLDoCBkaXZpc28gcGVyIGlsIHByaW1vIGlucHV0LlwiLFxuXHRcIkBARGl2aWRlX1Jhc3RlcjJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIG51bWVybyBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyICR7UmFzdGVyfS5cIixcblx0XCJAQEVsZXZhdGlvbi1Wb2lkLUZpbGxfREVNX3RhZzBAQFwiOiBcIklsIERFTSBkaSBpbnB1dC5cIixcblx0XCJAQEVsZXZhdGlvbi1Wb2lkLUZpbGxfTWF4LVZvaWQtV2lkdGhfdGFnMEBAXCI6IFwiSWwgdmFsb3JlIGRpIGxhcmdoZXp6YSBtYXNzaW1hIGRlbCB2dW90byB2aWVuZSB1c2F0byBwZXIgc3BlY2lmaWNhcmUgbGEgZGltZW5zaW9uZSBwacO5IGdyYW5kZSBkaSB1biB2dW90byBjaGUgc2kgZGVzaWRlcmEgcmllbXBpcmUuIFNlIGxhIGxhcmdoZXp6YSBvIGwnYWx0ZXp6YSBkZWxsYSBjYXNlbGxhIGRpIGNvbnRvcm5vIGludG9ybm8gYWwgdnVvdG8gw6ggcGnDuSBncmFuZGUgZGVsIHZhbG9yZSBkaSBsYXJnaGV6emEgbWFzc2ltYSBkZWwgdnVvdG8sIGlsIHZ1b3RvIG5vbiB2aWVuZSByaWVtcGl0by4gTGUgdW5pdMOgIGRpIHF1ZXN0byBwYXJhbWV0cm8gc29ubyBsZSBzdGVzc2UgZGkgcXVlbGxlIHVzYXRlIG5lbCBzaXN0ZW1hIGRpIHJpZmVyaW1lbnRvIHNwYXppYWxlIGRlaSBkYXRpLlwiLFxuXHRcIkBARWxldmF0aW9uLVZvaWQtRmlsbF9NYXgtVm9pZC1XaWR0aF90YWcxQEBcIjogXCJTZSBxdWVzdG8gcGFyYW1ldHJvIMOoIHZ1b3RvIG8gaGEgdW4gdmFsb3JlIGRpICR7MH0sIG5vbiBzaSB1c2Vyw6AgbmVzc3VuYSBsYXJnaGV6emEgbWFzc2ltYSBlIHNpIHJpZW1waXJhbm5vIHR1dHRpIGkgdnVvdGkuIFVuIHZhbG9yZSBkaSAkey0xfSBpbXBsaWNhIGNoZSBub24gc2kgcmllbXBpcsOgIG5lc3N1biB2dW90by5cIixcblx0XCJAQEVsZXZhdGlvbi1Wb2lkLUZpbGxfU2hvcnQtUmFuZ2UtSURXLVJhZGl1c190YWcwQEBcIjogXCJJbCByYWdnaW8gbWFzc2ltbyBkaSByaWNlcmNhIGNoZSBzYXLDoCB1c2F0byBwZXIgcmllbXBpcmUgaWwgdnVvdG8uIFVuIHZ1b3RvIG9sdHJlIHF1ZXN0byB2YWxvcmUgZGkgc29nbGlhLCBhIHBhcnRpcmUgZGEgcXVhbHVucXVlIHBpeGVsIHZhbGlkbywgcmVzdGVyw6AgY29tZSB2dW90by4gTGUgdW5pdMOgIGRpIHF1ZXN0byBwYXJhbWV0cm8gc29ubyBsZSBzdGVzc2UgZGkgcXVlbGxlIHVzYXRlIG5lbCBzaXN0ZW1hIGRpIHJpZmVyaW1lbnRvIHNwYXppYWxlIGRlaSBkYXRpLlwiLFxuXHRcIkBARWxldmF0aW9uLVZvaWQtRmlsbF9TaG9ydC1SYW5nZS1JRFctUmFkaXVzX3RhZzFAQFwiOiBcIlNlIGlsIHZhbG9yZSBkaSBxdWVzdG8gcGFyYW1ldHJvIMOoIHZ1b3RvLCAkezB9IG8gJHstMX0gcXVlc3RvIHBhcmFtZXRybyBub24gc2Fyw6AgdXNhdG8uXCIsXG5cdFwiQEBFcXVhbC10b19DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBARXF1YWwtdG9fQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEVxdWFsLXRvX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBARXF1YWwtdG9fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEVxdWFsLXRvX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEVxdWFsLXRvX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBARXF1YWwtdG9fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBFcXVhbC10b19FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBARXF1YWwtdG9fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBARXF1YWwtdG9fRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEVxdWFsLXRvX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEVxdWFsLXRvX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IGNoZSB2ZXJyw6AgdXNhdG8gcGVyIGNvbXBhcmFyZSBsJ3VndWFnbGlhbnphIGNvbiBpbCBzZWNvbmRvIGlucHV0LlwiLFxuXHRcIkBARXF1YWwtdG9fUmFzdGVyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQEVxdWFsLXRvX1Jhc3RlcjJfdGFnMEBAXCI6IFwiTCdpbnB1dCBjaGUgdmVycsOgIHVzYXRvIHBlciBjb21wYXJhcmUgbCd1Z3VhZ2xpYW56YSBjb24gaWwgcHJpbW8gaW5wdXQuXCIsXG5cdFwiQEBFcXVhbC10b19SYXN0ZXIyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX0NlbGxzaXplX3RhZzBAQFwiOiBcIkxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgYWxsYSBxdWFsZSBzaSBjcmVlcsOgIGlsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9DZWxsc2l6ZV90YWcxQEBcIjogXCJTZSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIMOoIHN0YXRhIGVzcGxpY2l0YW1lbnRlIGltcG9zdGF0YSBpbiA8c3Ryb25nPkFtYmllbnRpIGRpIGFuYWxpc2k8L3N0cm9uZz4sIHF1ZWxsYSBzYXLDoCBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHByZWRlZmluaXRhLiBTZSBub24gw6ggc3RhdGEgaW1wb3N0YXRhLCBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIGRpIG91dHB1dCBzYXLDoCBsYSBzdGVzc2EgZGVsIDxzdHJvbmc+UmFzdGVyIGRpIG9yaWdpbmU8L3N0cm9uZz4uXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9EaXN0YW5jZS1NZXRob2RfdGFnMEBAXCI6IFwiRGV0ZXJtaW5hIHNlIGNhbGNvbGFyZSBsYSBkaXN0YW56YSBjb24gdW4gbWV0b2RvIHBsYW5hcmUgKHRlcnJhIHBpYXR0YSkgbyBnZW9kZXRpY28gKGVsbGlzc29pZGUpLlwiLFxuXHRcIkBARXVjbGlkZWFuLUFsbG9jYXRpb25fRGlzdGFuY2UtTWV0aG9kX3RhZzFAQFwiOiBcIkdlb2RldGljYTogbGEgbGluZWEgcGnDuSBicmV2ZSB0cmEgZHVlIHB1bnRpIHN1bGxhIHN1cGVyZmljaWUgdGVycmVzdHJlIHN1IHVubyBzZmVyb2lkZSAoZWxsaXNzb2lkZSkuIFBlcnRhbnRvLCBpbmRpcGVuZGVudGVtZW50ZSBkYWxsYSBwcm9pZXppb25lIGRpIGlucHV0IG8gb3V0cHV0LCBpIHJpc3VsdGF0aSBub24gY2FtYmlhbm8uIExhIGxpbmVhIGdlb2RldGljYSBwdcOyIGVzc2VyZSB1c2F0YSBzZSBzaSBkZXNpZGVyYSBkZXRlcm1pbmFyZSBsYSBkaXN0YW56YSBwacO5IGJyZXZlIHRyYSBkdWUgY2l0dMOgIHBlciBsYSB0cmFpZXR0b3JpYSBkaSB1biBhZXJlby4gUXVlc3RvIG1ldG9kbyDDqCBjb25vc2NpdXRvIGFuY2hlIGNvbWUgbGluZWEgZGVsIGNlcmNoaW8gbWFzc2ltbyBzZSBiYXNhdG8gc3UgdW5hIHNmZXJhIHBpdXR0b3N0byBjaGUgc3UgdW4gZWxsaXNzb2lkZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX0Rpc3RhbmNlLU1ldGhvZF90YWcyQEBcIjogXCJQbGFuYXJlOiBsYSBtaXN1cmF6aW9uZSBwbGFuYXJlIHV0aWxpenphIGxhIG1hdGVtYXRpY2EgY2FydGVzaWFuYSAyRCBwZXIgY2FsY29sYXJlIGFyZWEgZSBsdW5naGV6emEuIFF1ZXN0YSBvcHppb25lIMOoIGRpc3BvbmliaWxlIHNvbG8gcXVhbmRvIHNpIG1pc3VyYSBpbiB1biBzaXN0ZW1hIGRpIGNvb3JkaW5hdGUgcHJvaWV0dGF0byBlIGlsIHBpYW5vIDJEIGRpIHRhbGUgc2lzdGVtYSBkaSBjb29yZGluYXRlIHZpZW5lIHV0aWxpenphdG8gY29tZSBiYXNlIHBlciBsZSBtaXN1cmF6aW9uaS5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiRGVmaW5pc2NlIGxhIGRpc3RhbnphIGxpbWl0ZSBlbnRybyBsYSBxdWFsZSB2aWVuZSBkZXRlcm1pbmF0YSBsJ29yaWdpbmUgcGnDuSB2aWNpbmEuIFNlIGxhIGRpc3RhbnphIGZpbm8gYWxsJ29yaWdpbmUgcGnDuSB2aWNpbmEgc3VwZXJhIHF1ZXN0byB2YWxvcmUsIGwnb3V0cHV0IGRpIHF1ZWxsYSBjZWxsYSBzYXLDoCAke05vRGF0YX0uXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9NYXhpbXVtLURpc3RhbmNlX3RhZzFAQFwiOiBcIkxhIGRpc3RhbnphIHByZWRlZmluaXRhIMOoIGZpbm8gYWxsJ2VzdGVuc2lvbmUgZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9SYXN0ZXItQmFycmllcnNfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGNoZSBkZWZpbmlzY2UgbGUgYmFycmllcmUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9SYXN0ZXItQmFycmllcnNfdGFnMUBAXCI6IFwiSWwgZGF0YXNldCBkZXZlIGNvbnRlbmVyZSAke05vRGF0YX0gbGFkZG92ZSBub24gY2kgc29ubyBiYXJyaWVyZS4gTGUgYmFycmllcmUgc29ubyByYXBwcmVzZW50YXRlIGRhIHZhbG9yaSB2YWxpZGksIGluY2x1c28gbG8gemVyby5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX1Jhc3Rlci1CYXJyaWVyc190YWcyQEBcIjogXCJMZSBiYXJyaWVyZSBwb3Nzb25vIGVzc2VyZSBkZWZpbml0ZSBkYSB1biBudW1lcm8gaW50ZXJvIG8gZGEgdW4gcmFzdGVyIGEgdmlyZ29sYSBtb2JpbGUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9Tb3VyY2UtRmllbGRfdGFnMEBAXCI6IFwiSWwgY2FtcG8gdXNhdG8gcGVyIGFzc2VnbmFyZSB2YWxvcmkgYWxsZSBwb3NpemlvbmkgZGkgb3JpZ2luZS4gRGV2ZSBlc3NlcmUgZGkgdGlwbyBudW1lcm8gaW50ZXJvLiBTZSBpbCA8c3Ryb25nPlJhc3RlciB2YWxvcmU8L3N0cm9uZz4gw6ggc3RhdG8gaW1wb3N0YXRvLCBpIHZhbG9yaSBkaSBxdWVsbCdpbnB1dCBhdnJhbm5vIHByaW9yaXTDoCBzdSBxdWFsdW5xdWUgaW1wb3N0YXppb25lIGRpIDxzdHJvbmc+Q2FtcG8gZGkgb3JpZ2luZTwvc3Ryb25nPi5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX1NvdXJjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGRpIGlucHV0IG9iYmxpZ2F0b3JpbyBjaGUgaWRlbnRpZmljYSBsZSBwb3NpemlvbmkgZGkgb3JpZ2luZS4gQmFzYW5kb3NpIHN1bGxhIGRpc3RhbnphIGV1Y2xpZGVhLCBsJ29yaWdpbmUgcGnDuSB2aWNpbmEgdmVycsOgIGRldGVybWluYXRhIHBlciBvZ25pIGNlbGxhIHByZXNlbnRlIG5lbGwnb3V0cHV0XCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzFAQFwiOiBcIklsIHRpcG8gZGkgaW5wdXQgcHXDsiBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBvIHVuIHZhbG9yZSBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBARXVjbGlkZWFuLUFsbG9jYXRpb25fVmFsdWUtUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBhIG51bWVybyBpbnRlcm8gY2hlIGlkZW50aWZpY2EgaSB2YWxvcmkgZGkgem9uYSBkYSB1c2FyZSBwZXIgb2duaSBwb3NpemlvbmUgZGkgb3JpZ2luZSBkaSBpbnB1dC4gUGVyIG9nbmkgY2VsbGEgZGkgcG9zaXppb25lIGRpIG9yaWdpbmUsIGlsIHZhbG9yZSBkZWZpbml0byBkYWwgPHN0cm9uZz5SYXN0ZXIgZGkgdmFsb3JpPC9zdHJvbmc+IHNhcsOgIGFzc2VnbmF0byBhIHR1dHRlIGxlIGNlbGxlIGFzc2VnbmF0ZSBhbGxhIHBvc2l6aW9uZSBkaSBvcmlnaW5lIHBlciBpbCBjYWxjb2xvLiBJbCA8c3Ryb25nPlJhc3RlciBkaSB2YWxvcmk8L3N0cm9uZz4gYXZyw6AgcHJpb3JpdMOgIHN1IHF1YWx1bnF1ZSBpbXBvc3RhemlvbmUgcGVyIGlsIDxzdHJvbmc+Q2FtcG8gZGkgb3JpZ2luZTwvc3Ryb25nPi5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fQ2VsbHNpemVfdGFnMEBAXCI6IFwiTGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBhbGxhIHF1YWxlIHNpIGNyZWVyw6AgaWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fQ2VsbHNpemVfdGFnMUBAXCI6IFwiU2UgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSDDqCBzdGF0YSBlc3BsaWNpdGFtZW50ZSBpbXBvc3RhdGEgaW4gPHN0cm9uZz5BbWJpZW50aSBkaSBhbmFsaXNpPC9zdHJvbmc+LCBxdWVsbGEgc2Fyw6AgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwcmVkZWZpbml0YS4gU2Ugbm9uIMOoIHN0YXRhIGltcG9zdGF0YSwgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBkaSBvdXRwdXQgc2Fyw6AgbGEgc3Rlc3NhIGRlbCA8c3Ryb25nPlJhc3RlciBkaSBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9EaXN0YW5jZS1NZXRob2RfdGFnMEBAXCI6IFwiRGV0ZXJtaW5hIHNlIGNhbGNvbGFyZSBsYSBkaXN0YW56YSBjb24gdW4gbWV0b2RvIHBsYW5hcmUgKHRlcnJhIHBpYXR0YSkgbyBnZW9kZXRpY28gKGVsbGlzc29pZGUpLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9EaXN0YW5jZS1NZXRob2RfdGFnMUBAXCI6IFwiR2VvZGV0aWNhOiBsYSBsaW5lYSBwacO5IGJyZXZlIHRyYSBkdWUgcHVudGkgc3VsbGEgc3VwZXJmaWNpZSB0ZXJyZXN0cmUgc3UgdW5vIHNmZXJvaWRlIChlbGxpc3NvaWRlKS4gUGVydGFudG8sIGluZGlwZW5kZW50ZW1lbnRlIGRhbGxhIHByb2llemlvbmUgZGkgaW5wdXQgbyBvdXRwdXQsIGkgcmlzdWx0YXRpIG5vbiBjYW1iaWFuby4gTGEgbGluZWEgZ2VvZGV0aWNhIHB1w7IgZXNzZXJlIHVzYXRhIHNlIHNpIGRlc2lkZXJhIGRldGVybWluYXJlIGxhIGRpc3RhbnphIHBpw7kgYnJldmUgdHJhIGR1ZSBjaXR0w6AgcGVyIGxhIHRyYWlldHRvcmlhIGRpIHVuIGFlcmVvLiBRdWVzdG8gbWV0b2RvIMOoIGNvbm9zY2l1dG8gYW5jaGUgY29tZSBsaW5lYSBkZWwgY2VyY2hpbyBtYXNzaW1vIHNlIGJhc2F0byBzdSB1bmEgc2ZlcmEgcGl1dHRvc3RvIGNoZSBzdSB1biBlbGxpc3NvaWRlLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9EaXN0YW5jZS1NZXRob2RfdGFnMkBAXCI6IFwiUGxhbmFyZTogbGEgbWlzdXJhemlvbmUgcGxhbmFyZSB1dGlsaXp6YSBsYSBtYXRlbWF0aWNhIGNhcnRlc2lhbmEgMkQgcGVyIGNhbGNvbGFyZSBhcmVhIGUgbHVuZ2hlenphLiBRdWVzdGEgb3B6aW9uZSDDqCBkaXNwb25pYmlsZSBzb2xvIHF1YW5kbyBzaSBtaXN1cmEgaW4gdW4gc2lzdGVtYSBkaSBjb29yZGluYXRlIHByb2lldHRhdG8gZSBpbCBwaWFubyAyRCBkaSB0YWxlIHNpc3RlbWEgZGkgY29vcmRpbmF0ZSB2aWVuZSB1dGlsaXp6YXRvIGNvbWUgYmFzZSBwZXIgbGUgbWlzdXJhemlvbmkuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlyZWN0aW9uX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiRGVmaW5pc2NlIGxhIGRpc3RhbnphIGxpbWl0ZSBlbnRybyBsYSBxdWFsZSB2aWVuZSBjYWxjb2xhdGEgbGEgZGlyZXppb25lIHZlcnNvIGwnb3JpZ2luZSBwacO5IHZpY2luYS4gU2UgbGEgZGlzdGFuemEgZmlubyBhbGwnb3JpZ2luZSBwacO5IHZpY2luYSBzdXBlcmEgcXVlc3RvIHZhbG9yZSwgbCdvdXRwdXQgZGkgcXVlbGxhIGNlbGxhIHNhcsOgICR7Tm9EYXRhfS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fTWF4aW11bS1EaXN0YW5jZV90YWcxQEBcIjogXCJMYSBkaXN0YW56YSBwcmVkZWZpbml0YSDDqCBmaW5vIGFsbCdlc3RlbnNpb25lIGRlbCByYXN0ZXIgZGkgb3V0cHV0LlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9SYXN0ZXItQmFycmllcnNfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGNoZSBkZWZpbmlzY2UgbGUgYmFycmllcmUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlyZWN0aW9uX1Jhc3Rlci1CYXJyaWVyc190YWcxQEBcIjogXCJJbCBkYXRhc2V0IGRldmUgY29udGVuZXJlIE5vRGF0YSBsYWRkb3ZlIG5vbiBjaSBzb25vIGJhcnJpZXJlLiBMZSBiYXJyaWVyZSBzb25vIHJhcHByZXNlbnRhdGUgZGEgdmFsb3JpIHZhbGlkaSwgaW5jbHVzbyBsbyB6ZXJvLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9SYXN0ZXItQmFycmllcnNfdGFnMkBAXCI6IFwiTGUgYmFycmllcmUgcG9zc29ubyBlc3NlcmUgZGVmaW5pdGUgZGEgdW4gbnVtZXJvIGludGVybyBvIGRhIHVuIHJhc3RlciBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBkaSBpbnB1dCBvYmJsaWdhdG9yaW8gY2hlIGlkZW50aWZpY2EgbGUgY2VsbGUgbyBsZSBwb3Npemlvbmkgc3VsbGUgcXVhbGkgc2kgY2FsY29sYSBsYSBkaXJlemlvbmUgZXVjbGlkZWEgcGVyIG9nbmkgcG9zaXppb25lIGRlbGxhIGNlbGxhIGRpIG91dHB1dC5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fU291cmNlLVJhc3Rlcl90YWcxQEBcIjogXCJJbCB0aXBvIGRpIGlucHV0IHB1w7IgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8gbyB1biB2YWxvcmUgYSB2aXJnb2xhIG1vYmlsZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXN0YW5jZV9DZWxsc2l6ZV90YWcwQEBcIjogXCJMYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIGFsbGEgcXVhbGUgc2kgY3JlZXLDoCBpbCByYXN0ZXIgZGkgb3V0cHV0LlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX0NlbGxzaXplX3RhZzFAQFwiOiBcIlNlIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgw6ggc3RhdGEgZXNwbGljaXRhbWVudGUgaW1wb3N0YXRhIGluIDxzdHJvbmc+QW1iaWVudGkgZGkgYW5hbGlzaTwvc3Ryb25nPiwgcXVlbGxhIHNhcsOgIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcHJlZGVmaW5pdGEuIFNlIG5vbiDDqCBzdGF0YSBpbXBvc3RhdGEsIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgZGkgb3V0cHV0IHNhcsOgIGxhIHN0ZXNzYSBkZWwgPHN0cm9uZz5SYXN0ZXIgZGkgb3JpZ2luZTwvc3Ryb25nPi5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXN0YW5jZV9EaXN0YW5jZS1NZXRob2RfdGFnMEBAXCI6IFwiRGV0ZXJtaW5hIHNlIGNhbGNvbGFyZSBsYSBkaXN0YW56YSBjb24gdW4gbWV0b2RvIHBsYW5hcmUgKHRlcnJhIHBpYXR0YSkgbyBnZW9kZXRpY28gKGVsbGlzc29pZGUpLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX0Rpc3RhbmNlLU1ldGhvZF90YWcxQEBcIjogXCJHZW9kZXRpY2E6IGxhIGxpbmVhIHBpw7kgYnJldmUgdHJhIGR1ZSBwdW50aSBzdWxsYSBzdXBlcmZpY2llIHRlcnJlc3RyZSBzdSB1bm8gc2Zlcm9pZGUgKGVsbGlzc29pZGUpLiBQZXJ0YW50bywgaW5kaXBlbmRlbnRlbWVudGUgZGFsbGEgcHJvaWV6aW9uZSBkaSBpbnB1dCBvIG91dHB1dCwgaSByaXN1bHRhdGkgbm9uIGNhbWJpYW5vLiBMYSBsaW5lYSBnZW9kZXRpY2EgcHXDsiBlc3NlcmUgdXNhdGEgc2Ugc2kgZGVzaWRlcmEgZGV0ZXJtaW5hcmUgbGEgZGlzdGFuemEgcGnDuSBicmV2ZSB0cmEgZHVlIGNpdHTDoCBwZXIgbGEgdHJhaWV0dG9yaWEgZGkgdW4gYWVyZW8uIFF1ZXN0byBtZXRvZG8gw6ggY29ub3NjaXV0byBhbmNoZSBjb21lIGxpbmVhIGRlbCBjZXJjaGlvIG1hc3NpbW8gc2UgYmFzYXRvIHN1IHVuYSBzZmVyYSBwaXV0dG9zdG8gY2hlIHN1IHVuIGVsbGlzc29pZGUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfRGlzdGFuY2UtTWV0aG9kX3RhZzJAQFwiOiBcIlBsYW5hcmU6IGxhIG1pc3VyYXppb25lIHBsYW5hcmUgdXRpbGl6emEgbGEgbWF0ZW1hdGljYSBjYXJ0ZXNpYW5hIDJEIHBlciBjYWxjb2xhcmUgYXJlYSBlIGx1bmdoZXp6YS4gUXVlc3RhIG9wemlvbmUgw6ggZGlzcG9uaWJpbGUgc29sbyBxdWFuZG8gc2kgbWlzdXJhIGluIHVuIHNpc3RlbWEgZGkgY29vcmRpbmF0ZSBwcm9pZXR0YXRvIGUgaWwgcGlhbm8gMkQgZGkgdGFsZSBzaXN0ZW1hIGRpIGNvb3JkaW5hdGUgdmllbmUgdXRpbGl6emF0byBjb21lIGJhc2UgcGVyIGxlIG1pc3VyYXppb25pLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiTGEgc29nbGlhIGNoZSBpIHZhbG9yaSBkaSBkaXN0YW56YSBjdW11bGF0aXZpIG5vbiBwb3Nzb25vIHN1cGVyYXJlLiBTZSB1bmEgZGlzdGFuemEgZXVjbGlkZWEgY3VtdWxhdGl2YSBzdXBlcmEgcXVlc3RvIHZhbG9yZSwgaWwgdmFsb3JlIGRpIG91dHB1dCBwZXIgbGEgcG9zaXppb25lIGRlbGxhIGNlbGxhIHNhcsOgIE5vRGF0YS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXN0YW5jZV9NYXhpbXVtLURpc3RhbmNlX3RhZzFAQFwiOiBcIkxhIGRpc3RhbnphIHByZWRlZmluaXRhIMOoIGZpbm8gYWxsJ2VzdGVuc2lvbmUgZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfUmFzdGVyLUJhcnJpZXJzX3RhZzBAQFwiOiBcIklsIHJhc3RlciBjaGUgZGVmaW5pc2NlIGxlIGJhcnJpZXJlLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX1Jhc3Rlci1CYXJyaWVyc190YWcxQEBcIjogXCJJbCBkYXRhc2V0IGRldmUgY29udGVuZXJlICR7Tm9EYXRhfSBsYWRkb3ZlIG5vbiBjaSBzb25vIGJhcnJpZXJlLiBMZSBiYXJyaWVyZSBzb25vIHJhcHByZXNlbnRhdGUgZGEgdmFsb3JpIHZhbGlkaSwgaW5jbHVzbyBsbyB6ZXJvLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX1Jhc3Rlci1CYXJyaWVyc190YWcyQEBcIjogXCJMZSBiYXJyaWVyZSBwb3Nzb25vIGVzc2VyZSBkZWZpbml0ZSBkYSB1biBudW1lcm8gaW50ZXJvIG8gZGEgdW4gcmFzdGVyIGEgdmlyZ29sYSBtb2JpbGUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfU291cmNlLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgb2JibGlnYXRvcmlvIGNoZSBpZGVudGlmaWNhIGxlIGNlbGxlIG8gbGUgcG9zaXppb25pIHN1bGxlIHF1YWxpIHNpIGNhbGNvbGEgbGEgZGlzdGFuemEgZXVjbGlkZWEgcGVyIG9nbmkgcG9zaXppb25lIGRlbGxhIGNlbGxhIGRpIG91dHB1dC5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXN0YW5jZV9Tb3VyY2UtUmFzdGVyX3RhZzFAQFwiOiBcIklsIHRpcG8gZGkgaW5wdXQgcHXDsiBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBvIHVuIHZhbG9yZSBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBARXhwX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBFeHBfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEV4cF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEV4cF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBARXhwX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEV4cF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEV4cF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQEV4cF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBARXhwX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEV4cF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBARXhwX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEV4cF9SYXN0ZXJfdGFnMEBAXCI6IFwiSSB2YWxvcmkgZGkgaW5wdXQgcGVyIGkgcXVhbGkgw6ggbmVjZXNzYXJpbyB0cm92YXJlIGxhIGJhc2UgZSBsJ2VzcG9uZW50ZS5cIixcblx0XCJAQEV4cDEwX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBFeHAxMF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBARXhwMTBfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBFeHAxMF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBARXhwMTBfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBARXhwMTBfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBFeHAxMF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQEV4cDEwX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBFeHAxMF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBFeHAxMF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBARXhwMTBfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBARXhwMTBfUmFzdGVyX3RhZzBAQFwiOiBcIkkgdmFsb3JpIGRpIGlucHV0IHBlciBpIHF1YWxpIMOoIG5lY2Vzc2FyaW8gdHJvdmFyZSBsYSBiYXNlIDEwIGRlbGwnZXNwb25lbnRlLlwiLFxuXHRcIkBARXhwMl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBARXhwMl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBARXhwMl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEV4cDJfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEV4cDJfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBARXhwMl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEV4cDJfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBFeHAyX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBFeHAyX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEV4cDJfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEV4cDJfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBARXhwMl9SYXN0ZXJfdGFnMEBAXCI6IFwiSSB2YWxvcmkgZGkgaW5wdXQgcGVyIGkgcXVhbGkgw6ggbmVjZXNzYXJpbyB0cm92YXJlIGxhIGJhc2UgMiBkZWxsJ2VzcG9uZW50ZS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfQmFuZF90YWcwQEBcIjogXCJTZWxlemlvbmFyZSBsZSBiYW5kZSBkYSBlc3RyYXJyZSBkYSB1biBlbGVuY28gaW4gYmFzZSBhbGwnb3B6aW9uZSBkaSBwYXJhbWV0cm8gPHN0cm9uZz5NZXRvZG88L3N0cm9uZz4gdXRpbGl6emF0YS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfQ29tYmluYXRpb25fdGFnMEBAXCI6IFwiTGEgY29tYmluYXppb25lIGRpIGJhbmRhIG8gbCdvcmRpbmUgZGkgYmFuZGEuIEwnZWxlbmNvIGRpIHNlbGV6aW9uZSBkaXBlbmRlIGRhbGwnb3B6aW9uZSA8c3Ryb25nPk1ldG9kbzwvc3Ryb25nPiBzcGVjaWZpY2F0YS4gQWQgZXNlbXBpbywgc2UgPHN0cm9uZz5NZXRvZG88L3N0cm9uZz4gw6ggPHN0cm9uZz5Ob21pIGRpIGJhbmRlPC9zdHJvbmc+LCDDqCBwb3NzaWJpbGUgc2VsZXppb25hcmUgdW5hIGNvbWJpbmF6aW9uZSBCbHUsIFZlcmRlIGUgUm9zc28gcGVyIGVzdHJhcnJlIHVuJ2ltbWFnaW5lIGRhbCBjb2xvcmUgbmF0dXJhbGUuXCIsXG5cdFwiQEBFeHRyYWN0LUJhbmRzX01ldGhvZF90YWcwQEBcIjogXCJTZWxlemlvbmFyZSB1bm8gZGVpIHNlZ3VlbnRpIG1ldG9kaSBwZXIgbCdlc3RyYXppb25lIGRlbGxlIGJhbmRlOlwiLFxuXHRcIkBARXh0cmFjdC1CYW5kc19NZXRob2RfdGFnMUBAXCI6IFwiPHN0cm9uZz5JRCBiYW5kYTwvc3Ryb25nPjogbGEgZGVzaWduYXppb25lIG8gaWwgbnVtZXJvIGRlbGxlIGJhbmRlLCBjaGUgw6ggdW4gdmFsb3JlIHVuaXZvY28gcGVyIG9nbmkgc2Vuc29yZS4gUXVlc3RpIHBvc3Nvbm8gZXNzZXJlIGlkZW50aWNpIGFpIDxzdHJvbmc+Tm9taSBiYW5kYTwvc3Ryb25nPi5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWV0aG9kX3RhZzRAQFwiOiBcIjxzdHJvbmc+Tm9taSBiYW5kYTwvc3Ryb25nPjogdXRpbGl6emEgaWwgbm9tZSBkZWxsYSBiYW5kYSBjaGUgcmFwcHJlc2VudGEgbCdpbnRlcnZhbGxvIGRpIGx1bmdoZXp6YSBkJ29uZGEgc3VsbG8gc3BldHRybyBlbGV0dHJvbWFnbmV0aWNvIChSb3NzbywgSW5mcmFyb3NzbyB2aWNpbm8sIEluZnJhcm9zc28gdGVybWljbywgYWQgZXNlbXBpbykuIFF1ZXN0byBwdcOyIGlub2x0cmUgZXNzZXJlIGlkZW50aWZpY2F0byBjb21lIG51bWVybyBJRCBkZWxsYSBiYW5kYS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWV0aG9kX3RhZzZAQFwiOiBcIjxzdHJvbmc+THVuZ2hlenplIGQnb25kYSBiYW5kZTwvc3Ryb25nPjogbGEgbHVuZ2hlenphIGQnb25kYSBzdWxsbyBzcGV0dHJvIGVsZXR0cm9tYWduZXRpY28uXCIsXG5cdFwiQEBFeHRyYWN0LUJhbmRzX01pc3NpbmctQmFuZC1BY3Rpb25fdGFnMEBAXCI6IFwiU3BlY2lmaWNhcmUgbCdhemlvbmUgY2hlIHNpIHZlcmlmaWNoZXLDoCBuZWwgY2FzbyBpbiBjdWkgdW5hIGJhbmRhIGFsbCdpbnRlcm5vIGRlbGwnZWxlbmNvIGRlbGxlIGJhbmRlIGVzdHJhdHRlIG5vbiBkb3Zlc3NlIGVzc2VyZSBkaXNwb25pYmlsZS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWlzc2luZy1CYW5kLUFjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPkNvcnJpc3BvbmRlbnphIG1pZ2xpb3JlPC9zdHJvbmc+OiB0cm92YSBsZSBtaWdsaW9yaSBiYW5kZSBkaXNwb25pYmlsaSBkYSB1dGlsaXp6YXJlIGFsIHBvc3RvIGRlbGxlIGJhbmRlIG1hbmNhbnRpIGJhc2F0ZSBzdWxsYSBsdW5naGV6emEgZCdvbmRhLCBhZmZpbmNow6kgbGEgZnVuemlvbmUgbm9uIHJpcG9ydGkgdW4gZXJyb3JlXCIsXG5cdFwiQEBFeHRyYWN0LUJhbmRzX01pc3NpbmctQmFuZC1BY3Rpb25fdGFnM0BAXCI6IFwiPHN0cm9uZz5FcnJvcmU8L3N0cm9uZz46IHNlIG5lbCBkYXRhc2V0IGRpIGlucHV0IG1hbmNhIHVuYSBiYW5kYSBzcGVjaWZpY2F0YSBuZWwgcGFyYW1ldHJvIDxzdHJvbmc+QmFuZGE8L3N0cm9uZz4sIGxhIGZ1bnppb25lIGRhcsOgIGVycm9yZS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfUmFzdGVyX3RhZzBAQFwiOiBcIklsIHByb2RvdHRvIGRlbCByYXN0ZXIgZGFsIHF1YWxlIHZlcnJhbm5vIGVzdHJhdHRlIHVuYSBvIHBpw7kgYmFuZGUuXCIsXG5cdFwiQEBGaWxsX1Jhc3Rlcl90YWcwQEBcIjogXCJVbiByYXN0ZXIgZGkgZWxldmF6aW9uZSBhIGJhbmRhIHNpbmdvbGEuXCIsXG5cdFwiQEBGaWxsX1otTGltaXRfdGFnMEBAXCI6IFwiTGEgZGlmZmVyZW56YSBkaSBlbGV2YXppb25lIG1hc3NpbWEgdHJhIHVuIHBvenpvIGUgaWwgcHVudG8gZGkgdmVyc2FtZW50byBkYSByaWVtcGlyZS5cIixcblx0XCJAQEZpbGxfWi1MaW1pdF90YWcxQEBcIjogXCJBIG1lbm8gY2hlIG5vbiB2ZW5nYSBzcGVjaWZpY2F0byB1biB2YWxvcmUgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHZlcnJhbm5vIHJpZW1waXRpIHR1dHRpIGkgcG96emksIGluZGlwZW5kZW50ZW1lbnRlIGRhbGxhIGxvcm8gcHJvZm9uZGl0w6AuXCIsXG5cdFwiQEBGaWxsX1otTGltaXRfdGFnMkBAXCI6IFwiSWwgdmFsb3JlIGRpIDxzdHJvbmc+TGltaXRlIFo8L3N0cm9uZz4gZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgZGkgemVyby5cIixcblx0XCJAQEZsb2F0X0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBGbG9hdF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBARmxvYXRfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBGbG9hdF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBARmxvYXRfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBARmxvYXRfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBGbG9hdF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQEZsb2F0X0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBGbG9hdF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBGbG9hdF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBARmxvYXRfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBARmxvYXRfUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBkYSBjb252ZXJ0aXJlIGluIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBARmxvdy1BY2N1bXVsYXRpb25fRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBjaGUgbW9zdHJhIGxhIGRpcmV6aW9uZSBkZWwgZmx1c3NvIGZ1b3JpIGRhIG9nbmkgY2VsbGEuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMUBAXCI6IFwiSWwgcmFzdGVyIGRpIGRpcmV6aW9uZSBkZWwgZmx1c3NvIHB1w7IgZXNzZXJlIGNyZWF0byBlc2VndWVuZG8gbGEgZnVuemlvbmUgPHN0cm9uZz5EaXJlemlvbmUgZmx1c3NvPC9zdHJvbmc+LlwiLFxuXHRcIkBARmxvdy1BY2N1bXVsYXRpb25fRmxvdy1EaXJlY3Rpb24tVHlwZV90YWcwQEBcIjogXCJEZWZpbmlzY2UgaWwgdGlwbyBkaSByYXN0ZXIgZGkgZGlyZXppb25lIGRpIGZsdXNzbyBkaSBpbnB1dC5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5EODwvc3Ryb25nPjogaWwgcmFzdGVyIGRpIGRpcmV6aW9uZSBkaSBmbHVzc28gZGkgaW5wdXQgw6ggZGVsIHRpcG8gRDguIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5ESU5GPC9zdHJvbmc+OiBpbCByYXN0ZXIgZGkgZGlyZXppb25lIGRpIGZsdXNzbyBkaSBpbnB1dCDDqCBkZWwgdGlwbyBELUluZmluaXR5IChESU5GKS5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnNUBAXCI6IFwiPHN0cm9uZz5NRkQ8L3N0cm9uZz46IGlsIHJhc3RlciBkaSBkaXJlemlvbmUgZGkgZmx1c3NvIGRpIGlucHV0IMOoIGRlbCB0aXBvIERpcmV6aW9uZSBtdWx0aSBmbHVzc28gKE1GRCkuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9PdXRwdXQtRGF0YS1UeXBlX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBhY2N1bXVsbyBkaSBvdXRwdXQgcHXDsiBlc3NlcmUgZGVsIHRpcG8gaW50ZXJvIG8gZGVsIHRpcG8gdmFsb3JlIGEgdmlyZ29sYSBtb2JpbGUuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9PdXRwdXQtRGF0YS1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+RmxvYXQ8L3N0cm9uZz46IGlsIHJhc3RlciBkaSBvdXRwdXQgc2Fyw6AgZGVsIHRpcG8gdmFsb3JlIGEgdmlyZ29sYSBtb2JpbGUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX091dHB1dC1EYXRhLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5OdW1lcm8gaW50ZXJvPC9zdHJvbmc+OiBpbCByYXN0ZXIgZGkgb3V0cHV0IHNhcsOgIGRlbCB0aXBvIGludGVyby5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX1dlaWdodC1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGRpIGlucHV0IG9wemlvbmFsZSBwZXIgbCdhcHBsaWNhemlvbmUgZGVsbGEgcG9uZGVyYXppb25lIGEgb2duaSBwaXhlbC5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX1dlaWdodC1SYXN0ZXJfdGFnMUBAXCI6IFwiU2Ugbm9uIMOoIHN0YXRvIHNwZWNpZmljYXRvIG5lc3N1biByYXN0ZXIgZGkgcG9uZGVyYXppb25lLCB2ZXJyw6AgYXBwbGljYXRhIHVuYSBwb25kZXJhemlvbmUgZGkgMSBhIG9nbmkgcGl4ZWwuXCIsXG5cdFwiQEBGbG93LURpcmVjdGlvbl9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzBAQFwiOiBcIkRlZmluaXNjZSBpbCB0aXBvIGRpIHJhc3RlciBkaSBkaXJlemlvbmUgZGkgZmx1c3NvIGRpIGlucHV0LlwiLFxuXHRcIkBARmxvdy1EaXJlY3Rpb25fRmxvdy1EaXJlY3Rpb24tVHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPkQ4PC9zdHJvbmc+OiBpbCByYXN0ZXIgZGkgZGlyZXppb25lIGRpIGZsdXNzbyBkaSBpbnB1dCDDqCBkZWwgdGlwbyBEOC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBARmxvdy1EaXJlY3Rpb25fRmxvdy1EaXJlY3Rpb24tVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPkRJTkY8L3N0cm9uZz46IGlsIHJhc3RlciBkaSBkaXJlemlvbmUgZGkgZmx1c3NvIGRpIGlucHV0IMOoIGRlbCB0aXBvIEQtSW5maW5pdHkgKERJTkYpLlwiLFxuXHRcIkBARmxvdy1EaXJlY3Rpb25fRmxvdy1EaXJlY3Rpb24tVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPk1GRDwvc3Ryb25nPjogaWwgcmFzdGVyIGRpIGRpcmV6aW9uZSBkaSBmbHVzc28gZGkgaW5wdXQgw6ggZGVsIHRpcG8gRGlyZXppb25lIG11bHRpIGZsdXNzbyAoTUZEKS5cIixcblx0XCJAQEZsb3ctRGlyZWN0aW9uX0ZvcmNlLWFsbC1lZGdlLWNlbGxzLXRvLWZsb3ctb3V0d2FyZF90YWcwQEBcIjogXCJTcGVjaWZpY2Egc2UgaSBwaXhlbCBtYXJnaW5lIGZsdWlyYW5ubyBzZW1wcmUgdmVyc28gbCdlc3Rlcm5vIG8gc2VndWlyYW5ubyBsZSBub3JtYWxpIHJlZ29sZSBkaSBmbHVzc28uXCIsXG5cdFwiQEBGbG93LURpcmVjdGlvbl9Gb3JjZS1hbGwtZWRnZS1jZWxscy10by1mbG93LW91dHdhcmRfdGFnMUBAXCI6IFwiPHN0cm9uZz5Obzwvc3Ryb25nPjogc2UgaWwgcmlsYXNjaW8gbWFzc2ltbyBuZWxsYSBwYXJ0ZSBpbnRlcm5hIGRpIHVuIHBpeGVsIG1hcmdpbmUgw6ggbWFnZ2lvcmUgZGkgemVybywgbGEgZGlyZXppb25lIGRpIGZsdXNzbyB2ZXJyw6AgZGV0ZXJtaW5hdGEgY29tZSBzZW1wcmU7IGluIGNhc28gY29udHJhcmlvLCBsYSBkaXJlemlvbmUgZGkgZmx1c3NvIHNhcsOgIHJpdm9sdGEgdmVyc28gaWwgbWFyZ2luZS4gSSBwaXhlbCBjaGUgZG92cmViYmVybyBmbHVpcmUgZGFsIG1hcmdpbmUgZGVsIHJhc3RlciBkaSBzdXBlcmZpY2llIHZlcnNvIGxhIHBhcnRlIGludGVybmEsIGxvIGZhcmFubm8uIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEZsb3ctRGlyZWN0aW9uX0ZvcmNlLWFsbC1lZGdlLWNlbGxzLXRvLWZsb3ctb3V0d2FyZF90YWczQEBcIjogXCI8c3Ryb25nPlPDrDwvc3Ryb25nPjogdHV0dGkgaSBwaXhlbCBhbCBtYXJnaW5lIGRlbCByYXN0ZXIgZGkgc3VwZXJmaWNpZSBmbHVpcmFubm8gdmVyc28gbGEgcGFydGUgZXN0ZXJuYSBhIHBhcnRpcmUgZGFsIHJhc3RlciBkaSBzdXBlcmZpY2llLlwiLFxuXHRcIkBARmxvdy1EaXJlY3Rpb25fUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBjaGUgcmFwcHJlc2VudGEgdW5hIHN1cGVyZmljaWUgZGkgZWxldmF6aW9uZSBjb250aW51YS5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRGlzdGFuY2UtVHlwZV90YWcwQEBcIjogXCJEZXRlcm1pbmEgc2UgaWwgY29tcG9uZW50ZSB2ZXJ0aWNhbGUgbyBvcml6em9udGFsZSBkZWxsYSBkaXN0YW56YSBkaSBmbHVzc28gdmllbmUgY2FsY29sYXRvLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9EaXN0YW5jZS1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+T3JpenpvbnRhbGU8L3N0cm9uZz46IGkgY2FsY29saSBkZWxsYSBkaXN0YW56YSBkaSBmbHVzc28gcmFwcHJlc2VudGFubyBpbCBjb21wb25lbnRlIG9yaXp6b250YWxlIGRlbGxhIGRpc3RhbnphIGRpIGZsdXNzbyBhIHBhcnRpcmUgZGEgb2duaSBwaXhlbCBuZWwgZG9taW5pbyBhbCBwaXhlbCBuZWwgZmx1c3NvIGRlbnRybyBpbCBxdWFsZSBmbHVpc2Nvbm8uXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Rpc3RhbmNlLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5WZXJ0aWNhbGU8L3N0cm9uZz46IGkgY2FsY29saSBkZWxsYSBkaXN0YW56YSBkaSBmbHVzc28gcmFwcHJlc2VudGFubyBpbCBjb21wb25lbnRlIHZlcnRpY2FsZSBkZWxsYSBkaXN0YW56YSBkaSBmbHVzc28gYSBwYXJ0aXJlIGRhIG9nbmkgcGl4ZWwgbmVsIGRvbWluaW8gYWwgcGl4ZWwgbmVsIGZsdXNzbyBkZW50cm8gaWwgcXVhbGUgZmx1aXNjb25vLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgY2hlIG1vc3RyYSBsYSBkaXJlemlvbmUgZGVsIGZsdXNzbyBmdW9yaSBkYSBvZ25pIHBpeGVsLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMUBAXCI6IFwiU2UgdmllbmUgZm9ybml0byB1biByYXN0ZXIgZGkgZGlyZXppb25lIGRpIGZsdXNzbywgbGUgZGlyZXppb25pIGRpIHBlbmRlbnphIHZlcnNvIGlsIGJhc3NvIHNhcmFubm8gbGltaXRhdGUgYSBxdWVsbGUgZGVmaW5pdGUgZGFsbGEgZGlyZXppb25lIGRlbCBmbHVzc28gZGkgaW5wdXQuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcyQEBcIjogXCJJbCByYXN0ZXIgZGkgZGlyZXppb25lIGRlbCBmbHVzc28gcHXDsiBlc3NlcmUgY3JlYXRvIHV0aWxpenphbmRvIGxhIGZ1bnppb25lIERpcmV6aW9uZSBmbHVzc28uXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnMEBAXCI6IFwiRGVmaW5pc2NlIGlsIHRpcG8gZGkgcmFzdGVyIGRpIGRpcmV6aW9uZSBkaSBmbHVzc28gZGkgaW5wdXQuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5EODwvc3Ryb25nPjogaWwgcmFzdGVyIGRpIGRpcmV6aW9uZSBkaSBmbHVzc28gZGkgaW5wdXQgw6ggZGVsIHRpcG8gRDguIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRmxvdy1EaXJlY3Rpb24tVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPkRJTkY8L3N0cm9uZz46IGlsIHJhc3RlciBkaSBkaXJlemlvbmUgZGkgZmx1c3NvIGRpIGlucHV0IMOoIGRlbCB0aXBvIEQtSW5maW5pdHkgKERJTkYpLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzVAQFwiOiBcIjxzdHJvbmc+TUZEPC9zdHJvbmc+OiBpbCByYXN0ZXIgZGkgZGlyZXppb25lIGRpIGZsdXNzbyBkaSBpbnB1dCDDqCBkZWwgdGlwbyBEaXJlemlvbmUgbXVsdGkgZmx1c3NvIChNRkQpLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9TdGF0aXN0aWNzLVR5cGVfdGFnMEBAXCI6IFwiRGV0ZXJtaW5hIGlsIHRpcG8gZGkgc3RhdGlzdGljaGUgdXRpbGl6emF0byBwZXIgY2FsY29sYXJlIGxhIGRpc3RhbnphIGRpIGZsdXNzbyBpbiB2YXJpIHBlcmNvcnNpIGRpIGZsdXNzby4gU2Ugdmkgw6ggc29sbyB1biBwZXJjb3JzbyBkaSBmbHVzc28gZGEgb2duaSBjZWxsYSBhIHVuYSBjZWxsYSBuZWwgZmx1c3NvLCB0dXR0aSBpIHRpcGkgZGkgc3RhdGlzdGljaGUgcHJvZHVycmFubm8gbG8gc3Rlc3NvIHJpc3VsdGF0by5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfU3RhdGlzdGljcy1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+TWluaW1vPC9zdHJvbmc+OiBzZSBlc2lzdG9ubyB2YXJpIHBlcmNvcnNpIGRpIGZsdXNzbywgdmllbmUgY2FsY29sYXRhIGxhIGRpc3RhbnphIGRpIGZsdXNzbyBtaW5pbWEuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfU3RhdGlzdGljcy1UeXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+TWVkaWEgcG9uZGVyYXRhPC9zdHJvbmc+OiBzZSBlc2lzdG9ubyB2YXJpIHBlcmNvcnNpIGRpIGZsdXNzbywgdmllbmUgY2FsY29sYXRhIGxhIG1lZGlhIHBvbmRlcmF0YSBkZWxsYSBkaXN0YW56YSBkaSBmbHVzc28uIExhIHByb3Bvcnppb25lIGRpIGZsdXNzbyBkYSB1bmEgY2VsbGEgYWxsZSBzdWUgY2VsbGUgdmljaW5lIGEgdmFsbGUgdmllbmUgdXRpbGl6emF0YSBjb21lIHBvbmRlcmF6aW9uZSBwZXIgaWwgY2FsY29sbyBkZWxsYSBtZWRpYSBwb25kZXJhdGEuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX1N0YXRpc3RpY3MtVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPk1hc3NpbW88L3N0cm9uZz46IHNlIGVzaXN0b25vIHZhcmkgcGVyY29yc2kgZGkgZmx1c3NvLCB2aWVuZSBjYWxjb2xhdGEgbGEgZGlzdGFuemEgZGkgZmx1c3NvIG1hc3NpbWEuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX1N0cmVhbS1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGRpIGZsdXNzbyBkaSBpbnB1dCBjaGUgcmFwcHJlc2VudGEgdW5hIHJldGUgZGkgZmx1c3NvIGxpbmVhcmUuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX1N1cmZhY2UtUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBjaGUgcmFwcHJlc2VudGEgdW5hIHN1cGVyZmljaWUgZGkgZWxldmF6aW9uZSBjb250aW51YS5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX0RpcmVjdGlvbi1vZi1NZWFzdXJlbWVudF90YWcwQEBcIjogXCJMYSBkaXJlemlvbmUgZGkgbWlzdXJhIGx1bmdvIGlsIHBlcmNvcnNvIGRpIGZsdXNzby5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX0RpcmVjdGlvbi1vZi1NZWFzdXJlbWVudF90YWcxQEBcIjogXCI8c3Ryb25nPkEgdmFsbGU8L3N0cm9uZz46IGNhbGNvbGEgbGEgZGlzdGFuemEgZGVsbGEgcGVuZGVuemEgdmVyc28gaWwgYmFzc28gbHVuZ28gaWwgcGVyY29yc28gZGkgZmx1c3NvLCBkYSBvZ25pIGNlbGxhIGEgdW4gcG96em8gbyB1c2NpdGEgc3VsIG1hcmdpbmUgZGVsIHJhc3Rlci5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX0RpcmVjdGlvbi1vZi1NZWFzdXJlbWVudF90YWczQEBcIjogXCI8c3Ryb25nPkEgbW9udGU8L3N0cm9uZz46IGNhbGNvbGEgbGEgZGlzdGFuemEgZGVsbGEgcGVuZGVuemEgdmVyc28gbCdhbHRvIHBpw7kgbHVuZ2EgbmVsIHBlcmNvcnNvIGRpIGZsdXNzbywgZGEgb2duaSBjZWxsYSBmaW5vIGFsbGEgcGFydGUgc3VwZXJpb3JlIGRlbGxvIHNwYXJ0aWFjcXVlIGRpIGRyZW5hZ2dpby5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgY2hlIG1vc3RyYSBsYSBkaXJlemlvbmUgZGVsIGZsdXNzbyBmdW9yaSBkYSBvZ25pIGNlbGxhLlwiLFxuXHRcIkBARmxvdy1MZW5ndGhfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzFAQFwiOiBcIklsIHJhc3RlciBkaSBkaXJlemlvbmUgZGVsIGZsdXNzbyBwdcOyIGVzc2VyZSBjcmVhdG8gZXNlZ3VlbmRvIGxhIGZ1bnppb25lIDxzdHJvbmc+RGlyZXppb25lIGZsdXNzbzwvc3Ryb25nPi5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX1dlaWdodC1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGRpIGlucHV0IG9wemlvbmFsZSBwZXIgbCdhcHBsaWNhemlvbmUgZGVsbGEgcG9uZGVyYXppb25lIGEgb2duaSBjZWxsYS5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX1dlaWdodC1SYXN0ZXJfdGFnMUBAXCI6IFwiU2Ugbm9uIMOoIHN0YXRvIHNwZWNpZmljYXRvIG5lc3N1biByYXN0ZXIgcG9uZGVyYXRvLCB2ZXJyw6AgYXBwbGljYXRhIHVuYSBwb25kZXJhemlvbmUgZGkgMSBhIG9nbmkgY2VsbGEuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX0lnbm9yZS1Ob0RhdGEtaW4tY2FsY3VsYXRpb25zX3RhZzBAQFwiOiBcIklkZW50aWZpY2Egc2UgaSB2YWxvcmkgJHtOb0RhdGF9IHZlbmdvbm8gaWdub3JhdGkgZGFpIGNhbGNvbGkgc3RhdGlzdGljaS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfSWdub3JlLU5vRGF0YS1pbi1jYWxjdWxhdGlvbnNfdGFnMUBAXCI6IFwiPHN0cm9uZz5TZWxlemlvbmF0bzwvc3Ryb25nPjogc3BlY2lmaWNhIGNoZSBzZSBlc2lzdGUgdW4gdmFsb3JlICR7Tm9EYXRhfSBhbGwnaW50ZXJubyBkaSB1biBxdWFydGllcmUsIGlsIHZhbG9yZSAke05vRGF0YX0gdmVycsOgIGlnbm9yYXRvLiBTb2xvIGxlIGNlbGxlIGFsbCdpbnRlcm5vIGRlbCBxdWFydGllcmUgY2hlIGhhbm5vIHZhbG9yaSBkaSBkYXRpIHZlcnJhbm5vIHV0aWxpenphdGkgcGVyIGRldGVybWluYXJlIGlsIHZhbG9yZSBkaSBvdXRwdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfSWdub3JlLU5vRGF0YS1pbi1jYWxjdWxhdGlvbnNfdGFnM0BAXCI6IFwiPHN0cm9uZz5EZXNlbGV6aW9uYXRvPC9zdHJvbmc+OiBzcGVjaWZpY2EgY2hlIHNlIHF1YWxzaWFzaSBjZWxsYSBpbiB1biBxdWFydGllcmUgaGEgdW4gdmFsb3JlIGRpICR7Tm9EYXRhfSwgbCdvdXRwdXQgcGVyIGxhIGNlbGxhIGRpIGVsYWJvcmF6aW9uZSBzYXLDoCAke05vRGF0YX0uXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWcwQEBcIjogXCJMYSBmb3JtYSBkZWxsJ2FyZWEgaW50b3JubyBhIGNpYXNjdW5hIGNlbGxhIHV0aWxpenphdGEgcGVyIGNhbGNvbGFyZSBsZSBzdGF0aXN0aWNoZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfTmVpZ2hib3Job29kX3RhZzFAQFwiOiBcIk9nbmkgcXVhcnRpZXJlIGhhIGRlaSBwYXJhbWV0cmkgYWdnaXVudGl2aSBjb24gaSBxdWFsaSDDqCBwb3NzaWJpbGUgZGVmaW5pcmUgbGEgZm9ybWEuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWcyQEBcIjogXCJDb3JvbmEgY2lyY29sYXJlLCByYWdnaW8gaW50ZXJubywgcmFnZ2lvIGVzdGVybm9cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfTmVpZ2hib3Job29kX3RhZzNAQFwiOiBcIkNlcmNoaW8sIHJhZ2dpb1wiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19OZWlnaGJvcmhvb2RfdGFnNEBAXCI6IFwiVmFsb3JpIGRpIHF1YXJ0aWVyZTogaXJyZWdvbGFyZSwgbGFyZ2hlenphLCBhbHRlenphXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWc1QEBcIjogXCJSZXR0YW5nb2xvLCBsYXJnaGV6emEsIGFsdGV6emFcIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfTmVpZ2hib3Job29kX3RhZzZAQFwiOiBcIlNwaWNjaGlvLCByYWdnaW8sIGFuZ29sbyBpbml6aWFsZSwgYW5nb2xvIGZpbmFsZVwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19OZWlnaGJvcmhvb2RfdGFnN0BAXCI6IFwiVmFsb3JpIGRpIHF1YXJ0aWVyZTogcG9uZGVyYXppb25lLCBsYXJnaGV6emEsIGFsdGV6emFcIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfTmVpZ2hib3Job29kX3RhZzhAQFwiOiBcIklsIHF1YXJ0aWVyZSBpcnJlZ29sYXJlIGNvbnNlbnRlIGRpIHNwZWNpZmljYXJlIHVuIHF1YXJ0aWVyZSBjb24gdW5hIGZvcm1hIGlycmVnb2xhcmUgaW50b3JubyBhbGxhIGNlbGxhIGRpIGVsYWJvcmF6aW9uZS4gVXRpbGl6emFyZSBsYSB0YWJlbGxhIGRlaSB2YWxvcmkgZGkgcXVhcnRpZXJlIHBlciBkZWZpbmlyZSBsYSBmb3JtYSBkZWwga2VybmVsIGRlbCBxdWFydGllcmUuIFVuIHZhbG9yZSBkaSAwIHBlciB1bmEgcG9zaXppb25lIGRpIGNlbGxhIGluZGljYSBjaGUgbGEgY2VsbGEgbm9uIGZhIHBhcnRlIGRlbCBxdWFydGllcmUgZSBjaGUgbm9uIHZlcnLDoCB1dGlsaXp6YXRhIHBlciBsJ2VsYWJvcmF6aW9uZS4gVW4gdmFsb3JlIGRpIDEgaW5kaWNhIGNoZSBsYSBzdWEgY2VsbGEgY29ycmlzcG9uZGVudGUgKGUgdmFsb3JlKSBmYSBwYXJ0ZSBkZWwgcXVhcnRpZXJlLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19OZWlnaGJvcmhvb2RfdGFnOUBAXCI6IFwiSWwgcXVhcnRpZXJlIGRpIHBvbmRlcmF6aW9uZSDDqCBzaW1pbGUgYWwgdGlwbyBkaSBxdWFydGllcmUgaXJyZWdvbGFyZSwgcG9pY2jDqSBjb25zZW50ZSBkaSBkZWZpbmlyZSB1biBxdWFydGllcmUgaXJyZWdvbGFyZSBpbnRvcm5vIGFsbGEgY2VsbGEgZGkgZWxhYm9yYXppb25lLCBtYSBpbm9sdHJlIGNvbnNlbnRlIGRpIGFwcGxpY2FyZSBkZWxsZSBwb25kZXJhemlvbmkgYWkgdmFsb3JpIGRpIGlucHV0LiBJIHZhbG9yaSBuZWkga2VybmVsIHBvbmRlcmF0aSBzcGVjaWZpY2FubyBxdWFsaSBzb25vIGxlIHBvc2l6aW9uaSBkZWxsZSBjZWxsZSBkYSBpbmNsdWRlcmUgbmVsIHF1YXJ0aWVyZSBlIHF1YWxpIHNvbm8gbGUgcG9uZGVyYXppb25pIHBlciBsZSBxdWFsaSBkb3ZyZWJiZXJvIGVzc2VyZSBtb2x0aXBsaWNhdGUuIFV0aWxpenphcmUgdW4gdmFsb3JlIGRpIDAgcGVyIGVzY2x1ZGVyZSB1bmEgY2VsbGEgZGFsbCdlbGFib3JhemlvbmUuIEkgdmFsb3JpIHBvc2l0aXZpLCBuZWdhdGl2aSBlIGRlY2ltYWxpIHJhcHByZXNlbnRhbm8gb3B6aW9uaSB2YWxpZGUgZGEgdXNhcmUgY29tZSBwb25kZXJhemlvbmkuIFBlciBpbCB0aXBvIGRpIHF1YXJ0aWVyZSBwb25kZXJhdG8sIHNvbm8gc3VwcG9ydGF0ZSBzb2xvIGxlIHN0YXRpc3RpY2hlIE1lZGlhLCBEZXZpYXppb25lIHN0YW5kYXJkIGUgU29tbWEuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1BlcmNlbnRpbGUtVmFsdWVfdGFnMEBAXCI6IFwiRGVub3RhIHF1YWxlIHBlcmNlbnRpbGUgY2FsY29sYXJlIHF1YW5kbyBzaSBzZWxlemlvbmEgPHN0cm9uZz5QZXJjZW50aWxlPC9zdHJvbmc+IGNvbWUgdGlwbyBkaSBzdGF0aXN0aWNhLiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggOTAgcGVyIGlsIDkwZXNpbW8gcGVyY2VudGlsZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfUGVyY2VudGlsZS1WYWx1ZV90YWczQEBcIjogXCJJIHZhbG9yaSBzcGF6aWFubyBkYSAwIGEgMTAwLiBJbCBwZXJjZW50aWxlIG51bWVybyAwIMOoIGVzc2VuemlhbG1lbnRlIGwnZXF1aXZhbGVudGUgZGVsbGEgc3RhdGlzdGljYSBtaW5pbWEsIGUgaWwgcGVyY2VudGlsZSBudW1lcm8gMTAwIMOoIGwnZXF1aXZhbGVudGUgZGVsbGEgc3RhdGlzdGljYSBtYXNzaW1hLCBmYXR0YSBlY2NlemlvbmUgcGVyIGlsIGZhdHRvIGNoZSBpbCByaXN1bHRhdG8gc2Fyw6AgdW5hIHZpcmdvbGEgbW9iaWxlLiBVbiB2YWxvcmUgZGkgNTAgcHJvZHVycsOgIGVzc2VuemlhbG1lbnRlIGxvIHN0ZXNzbyByaXN1bHRhdG8gZGkgdW5hIHN0YXRpc3RpY2EgbWVkaWEuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgb2JibGlnYXRvcmlvLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnMEBAXCI6IFwiSWwgdGlwbyBkaSBzdGF0aXN0aWNhIGRhIGNhbGNvbGFyZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+TWFnZ2lvcmFuemE8L3N0cm9uZz46IGNhbGNvbGEgbGEgbWFnZ2lvcmFuemEgKGlsIHZhbG9yZSBjaGUgc2kgdmVyaWZpY2EgcGnDuSBzcGVzc28pIGRlbGxlIGNlbGxlIG5lbCBxdWFydGllcmUuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPk1hc3NpbW88L3N0cm9uZz46IGNhbGNvbGEgaWwgbWFzc2ltbyAodmFsb3JlIHBpw7kgZ3JhbmRlKSBkZWxsZSBjZWxsZSBuZWwgcXVhcnRpZXJlLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnNUBAXCI6IFwiPHN0cm9uZz5NZWRpYTwvc3Ryb25nPjogY2FsY29sYSBsYSBtZWRpYSAodmFsb3JlIG1lZGlvKSBkZWxsZSBjZWxsZSBuZWwgcXVhcnRpZXJlLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnN0BAXCI6IFwiPHN0cm9uZz5NZWRpYW5hPC9zdHJvbmc+OiBjYWxjb2xhIGxhIG1lZGlhbmEgZGVsbGUgY2VsbGUgbmVsIHF1YXJ0aWVyZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzlAQFwiOiBcIjxzdHJvbmc+TWluaW1vPC9zdHJvbmc+OiBjYWxjb2xhIGlsIG1pbmltbyAoaWwgdmFsb3JlIHBpw7kgcGljY29sbykgZGVsbGUgY2VsbGUgbmVsIHF1YXJ0aWVyZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzExQEBcIjogXCI8c3Ryb25nPk1pbm9yYW56YTwvc3Ryb25nPjogY2FsY29sYSBsYSBtaW5vcmFuemEgKGlsIHZhbG9yZSBjaGUgc2kgdmVyaWZpY2EgbWVubyBzcGVzc28pIGRlbGxlIGNlbGxlIG5lbCBxdWFydGllcmUuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcxM0BAXCI6IFwiPHN0cm9uZz5QZXJjZW50aWxlPC9zdHJvbmc+OiBjYWxjb2xhIHVuIHBlcmNlbnRpbGUgZGVsbGUgY2VsbGUgbmVsIHF1YXJ0aWVyZS4gw4ggcG9zc2liaWxlIHN0YWJpbGlyZSBxdWFsZSBwZXJjZW50aWxlIGNhbGNvbGFyZSBjb24gaWwgcGFyYW1ldHJvIDxzdHJvbmc+VmFsb3JlIHBlcmNlbnRpbGU8L3N0cm9uZz4uXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcxN0BAXCI6IFwiPHN0cm9uZz5JbnRlcnZhbGxvPC9zdHJvbmc+OiBjYWxjb2xhIGwnaW50ZXJ2YWxsbyAoZGlmZmVyZW56YSB0cmEgaWwgdmFsb3JlIHBpw7kgZ3JhbmRlIGUgaWwgcGnDuSBwaWNjb2xvKSBkZWxsZSBjZWxsZSBuZWwgcXVhcnRpZXJlLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnMTlAQFwiOiBcIjxzdHJvbmc+RGV2aWF6aW9uZSBzdGFuZGFyZDwvc3Ryb25nPjogY2FsY29sYSBsYSBkZXZpYXppb25lIHN0YW5kYXJkIGRlbGxlIGNlbGxlIG5lbCBxdWFydGllcmUuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcyMUBAXCI6IFwiPHN0cm9uZz5Tb21tYTwvc3Ryb25nPjogY2FsY29sYSBsYSBzb21tYSAoaWwgdG90YWxlIGRpIHR1dHRpIGkgdmFsb3JpKSBkZWxsZSBjZWxsZSBuZWwgcXVhcnRpZXJlLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnMjNAQFwiOiBcIjxzdHJvbmc+VmFyaWV0w6A8L3N0cm9uZz46IGNhbGNvbGEgbGEgdmFyaWV0w6AgKGlsIG51bWVybyBkaSB2YWxvcmkgdW5pdm9jaSkgZGVsbGUgY2VsbGUgZGVsIHF1YXJ0aWVyZS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzI1QEBcIjogXCJTZSBpbCByYXN0ZXIgZGkgaW5wdXQgw6ggdW5hIHZpcmdvbGEgbW9iaWxlLCBzb25vIGRpc3BvbmliaWxpIHNvbG8gaSB0aXBpIHN0YXRpc3RpY2kgTWVkaW8sIE1hc3NpbW8sIE1lZGlhbm8sIE1pbmltbywgUGVyY2VudGlsZSwgSW50ZXJ2YWxsbywgRGV2aWF6aW9uZSBTdGFuZGFyZCBlIFNvbW1hLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnMjZAQFwiOiBcIlBlciBNZWRpbywgTWVkaWFubywgUGVyY2VudGlsZSBlIERldmlhemlvbmUgU3RhbmRhcmQsIGwnb3V0cHV0IHNhcsOgIHNlbXByZSB1bmEgdmlyZ29sYSBtb2JpbGUuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcyN0BAXCI6IFwiSWwgdGlwbyBkaSBzdGF0aXN0aWNhIHByZWRlZmluaXRvIMOoIE1lZGlvLlwiLFxuXHRcIkBAR2VvbWV0cmljX0NvbnN0YW50LVpfdGFnMEBAXCI6IFwiU3BlY2lmaWNhcmUgdW4nZWxldmF6aW9uZSBjb3N0YW50ZSBkYSB1dGlsaXp6YXJlIHBlciBsYSBmdW56aW9uZSBnZW9tZXRyaWNhLlwiLFxuXHRcIkBAR2VvbWV0cmljX0RFTV90YWcwQEBcIjogXCJTcGVjaWZpY2FyZSBpbCBERU0gZGEgdXRpbGl6emFyZSBwZXIgbGEgZnVuemlvbmUgZ2VvbWV0cmljYS4gw4ggcG9zc2liaWxlIHV0aWxpenphcmUgdW4gREVNIGNvbnRlbnV0byBuZWwgbW9zYWljIGRhdGFzZXQgY29tZSBkYXRhc2V0IHJhc3RlciBvIGNvbWUgbW9zYWljIGRhdGFzZXQgaWwgY3VpIG91dHB1dCDDqCB1biBERU0uXCIsXG5cdFwiQEBHZW9tZXRyaWNfR2VvaWRfdGFnMEBAXCI6IFwiTGEgbWFnZ2lvciBwYXJ0ZSBkZWkgZGF0YXNldCBkaSBlbGV2YXppb25lLCBjb21lIFVTR1MgTkVEIG8gRWxldmF6aW9uZSBtb25kaWFsZSBkaSBBcmNHSVMgT25saW5lLCBzb25vIGFsdGV6emUgb3J0b21ldHJpY2hlLCBxdWluZGkgw6ggbmVjZXNzYXJpbyBzZWxlemlvbmFyZSBsYSBjb3JyZXppb25lIGRlbCBnZW9pZGUgcGVyIGNvbXBhdGliaWxpdMOgIGNvbiBnbGkgUlBDIHNhdGVsbGl0YXJpLCBjaGUgcmljaGllZG9ubyBhbHRlenplIGVsbGlzc29pZGFsaS4gU2VsZXppb25hcmUgbGEgY2FzZWxsYSBkaSBjb250cm9sbG8gPHN0cm9uZz5HZW9pZDwvc3Ryb25nPiBwZXIgYXBwbGljYXJlIGxhIGNvcnJlemlvbmUgZGVsIGdlb2lkZSAoRUdNOTYpIGFpIHZhbG9yaSB6LCBhIG1lbm8gY2hlIGlsIERFTSBub24gYWJiaWEgZ2nDoCByaWZlcmltZW50aSBhbGxlIGFsdGV6emUgZWxsaXNzb2lkYWxpLlwiLFxuXHRcIkBAR2VvbWV0cmljX01ldGhvZF90YWcwQEBcIjogXCJTY2VnbGllcmUgaWwgbWV0b2RvIGRpIGVsZXZhemlvbmUgcGVyIGxhIGZ1bnppb25lIGdlb21ldHJpY2E6XCIsXG5cdFwiQEBHZW9tZXRyaWNfTWV0aG9kX3RhZzFAQFwiOiBcIlV0aWxpenphcmUgbGEgY29zdGFudGUgWjogc3BlY2lmaWNhcmUgdW4nZWxldmF6aW9uZSBjb3N0YW50ZSBwZXIgZXNlZ3VpcmUgbGEgZnVuemlvbmUgZ2VvbWV0cmljYS5cIixcblx0XCJAQEdlb21ldHJpY19NZXRob2RfdGFnMkBAXCI6IFwiVXRpbGl6emFyZSBERU06IHNwZWNpZmljYXJlIHVuIERFTSBwZXIgZXNlZ3VpcmUgbGEgZnVuemlvbmUgZ2VvbWV0cmljYS5cIixcblx0XCJAQEdlb21ldHJpY19SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAR2VvbWV0cmljX1otRmFjdG9yX3RhZzBAQFwiOiBcIkkgQ29lZmZpY2llbnRpIFBvbGlub21pYWxpIFJhemlvbmFsaSBzYXRlbGxpdGFyaSAoUlBDKSBzb25vIHNjYWxhdGkgcGVyIGkgZGF0YXNldCBkaSBlbGV2YXppb25lIGNvbiB1bml0w6AgdmVydGljYWxpIGVzcHJlc3NlIGluIG1ldHJpLiBTZSBsJ2VsZXZhemlvbmUgdXNhIGFsdHJlIHVuaXTDoCB2ZXJ0aWNhbGksIGltbWV0dGVyZSB1biA8c3Ryb25nPkZhdHRvcmUgWjwvc3Ryb25nPiBwZXIgcmlzY2FsYXJlIGluIG1ldHJpLiBBZCBlc2VtcGlvLCBzZSBsZSB1bml0w6AgZGkgZWxldmF6aW9uZSBzb25vIGVzcHJlc3NlIGluIHBpZWRpLCBzaSB1c2Vyw6AgdW4gdmFsb3JlIGRpIDAsMzA0OCBwZXIgY29udmVydGlyZSBsZSB1bml0w6AgZGkgZWxldmF6aW9uZSBkYSBwaWVkaSBhIG1ldHJpLlwiLFxuXHRcIkBAR2VvbWV0cmljX1otT2Zmc2V0X3RhZzBAQFwiOiBcIklsIHZhbG9yZSBkaSBiYXNlIGRhIGFnZ2l1bmdlcmUgYWwgdmFsb3JlIGRpIGVsZXZhemlvbmUgbmVsIERFTS4gTG8gc2kgcG90cmViYmUgdXNhcmUgcGVyIGRldmlhcmUgaSB2YWxvcmkgZGkgZWxldmF6aW9uZSBjaGUgbm9uIGluaXppYW5vIGFsIGxpdmVsbG8gZGVsIG1hcmUuXCIsXG5cdFwiQEBHZW9tZXRyaWNfVG9sZXJhbmNlX3RhZzBAQFwiOiBcIlNwZWNpZmljYXJlIGwnZXJyb3JlIG1hc3NpbW8gdG9sbGVyYWJpbGUgbmVsbGEgZnVuemlvbmUgZ2VvbWV0cmljYSwgZXNwcmVzc28gaW4gbnVtZXJvIGRpIHBpeGVsLiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gcGVyIGlsIHRpcG8gcmFzdGVyIE5JVEYgKE5DRFJEKSDDqCBkdWUuXCIsXG5cdFwiQEBHcmF5c2NhbGVfUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEdyYXlzY2FsZV9Db252ZXJzaW9uLVBhcmFtZXRlcnNfdGFnMEBAXCI6IFwiTGUgcG9uZGVyYXppb25pIHBlciBvZ25pIGJhbmRhIGNoZSBjb21wcmVuZG9ubyBpbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IGRhIGVzYW1pbmFyZSBwZXIgZGV0ZXJtaW5hcmUgc2Ugw6ggcGnDuSBncmFuZGUgZGVsIHNlY29uZG8gaW5wdXQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fUmFzdGVyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQEdyZWF0ZXItVGhhbl9SYXN0ZXIyX3RhZzBAQFwiOiBcIkwnaW5wdXQgY29uIGlsIHF1YWxlIHZpZW5lIG1lc3NvIGEgY29uZnJvbnRvIGlsIHByaW1vIGlucHV0IHBlciBkZXRlcm1pbmFyZSBzZSBxdWVzdCd1bHRpbW8gw6ggcGnDuSBncmFuZGUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fUmFzdGVyMl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IGRhIGVzYW1pbmFyZSBwZXIgZGV0ZXJtaW5hcmUgc2Ugw6ggcGnDuSBncmFuZGUgbyB1Z3VhbGUgYWwgc2Vjb25kbyBpbnB1dC5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9SYXN0ZXJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX1Jhc3RlcjJfdGFnMEBAXCI6IFwiTCdpbnB1dCBjb24gaWwgcXVhbGUgdmllbmUgbWVzc28gYSBjb25mcm9udG8gaWwgcHJpbW8gaW5wdXQgcGVyIGRldGVybWluYXJlIHNlIHF1ZXN0J3VsdGltbyDDqCBwacO5IGdyYW5kZSBvIHVndWFsZS5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9SYXN0ZXIyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQEhlYXQtSW5kZXhfSGVhdC1JbmRleC1Vbml0c190YWcwQEBcIjogXCJMJ3VuaXTDoCBkaSBtaXN1cmEgYXNzb2NpYXRhIGNvbiBpbCByYXN0ZXIgZGkgb3V0cHV0LiBMZSB1bml0w6AgZGkgb3V0cHV0IGRpc3BvbmliaWxpIHNvbm8gQ2Vsc2l1cywgRmFocmVuaGVpdCBlIEtlbHZpbi5cIixcblx0XCJAQEhlYXQtSW5kZXhfUmVsYXRpdmUtSHVtaWRpdHktUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBhIGJhbmRhIHNpbmdvbGEgaW4gY3VpIGkgdmFsb3JpIGRpIHBpeGVsIHJhcHByZXNlbnRhbm8gbCd1bWlkaXTDoCByZWxhdGl2YSBjb21lIHZhbG9yZSBwZXJjZW50dWFsZSB0cmEgMCBlIDEwMC5cIixcblx0XCJAQEhlYXQtSW5kZXhfVGVtcGVyYXR1cmUtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBhIGJhbmRhIHNpbmdvbGEgaW4gY3VpIGkgdmFsb3JpIGRpIHBpeGVsIHJhcHByZXNlbnRhbm8gbGEgdGVtcGVyYXR1cmEgZGVsbCdhcmlhIGRpIGFtYmllbnRlLlwiLFxuXHRcIkBASGVhdC1JbmRleF9UZW1wZXJhdHVyZS1Vbml0c190YWcwQEBcIjogXCJMJ3VuaXTDoCBkaSBtaXN1cmEgYXNzb2NpYXRhIGFsIHJhc3RlciBkaSB0ZW1wZXJhdHVyYSBkaSBpbnB1dC4gTGUgdW5pdMOgIGRpIGlucHV0IGRpc3BvbmliaWxpIHNvbm8gQ2Vsc2l1cywgRmFocmVuaGVpdCBlIEtlbHZpbi5cIixcblx0XCJAQEhpbGxzaGFkZV9BbHRpdHVkZV90YWcwQEBcIjogXCJMJ2FsdGl0dWRpbmUgw6ggbCdhbmdvbG8gZGkgZWxldmF6aW9uZSBkZWwgc29sZSBzdWxsJ29yaXp6b250ZSBlIHNwYXppYSBkYSAwIGEgOTAgZ3JhZGkuIFVuIHZhbG9yZSBkaSAwIGdyYWRpIGluZGljYSBjaGUgaWwgc29sZSDDqCBhbGwnb3JpenpvbnRlLCBvdnZlcm8gc3VsbG8gc3Rlc3NvIHBpYW5vIG9yaXp6b250YWxlIGRlbGxhIGNvcm5pY2UgZGkgcmlmZXJpbWVudG8uIFVuIHZhbG9yZSBkaSA5MCBncmFkaSBpbmRpY2EgY2hlIGlsIHNvbGUgw6ggZGlyZXR0YW1lbnRlIHNvcHJhIGRpIG5vaS5cIixcblx0XCJAQEhpbGxzaGFkZV9BbHRpdHVkZV90YWcxQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIMOoIHZhbGlkbyBzb2xvIHF1YW5kbyA8c3Ryb25nPlRpcG8gcmlsaWV2byBvbWJyZWdnaWF0bzwvc3Ryb25nPiDDqCA8c3Ryb25nPlRyYWRpemlvbmFsZTwvc3Ryb25nPi4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIGRpIDQ1IGdyYWRpIHNvcHJhIGwnb3JpenpvbnRlLlwiLFxuXHRcIkBASGlsbHNoYWRlX0F6aW11dGhfdGFnMEBAXCI6IFwiTCdhemltdXQgw6ggbGEgcG9zaXppb25lIHJlbGF0aXZhIGRlbCBzb2xlIGx1bmdvIGwnb3JpenpvbnRlIChpbiBncmFuZGkpLiBRdWVzdGEgcG9zaXppb25lIMOoIGluZGljYXRhIGRhbGwnYW5nb2xvIGRlbCBzb2xlIG1pc3VyYXRvIGluIHNlbnNvIG9yYXJpbyByaXNwZXR0byBhbCBub3JkLiBVbiBhemltdXQgZGkgMCBncmFkaSBpbmRpY2EgaWwgbm9yZCwgbCdlc3Qgw6ggOTAgZ3JhZGksIGlsIHN1ZCDDqCAxODAgZ3JhZGkgZSBsJ292ZXN0IMOoIDI3MCBncmFkaS5cIixcblx0XCJAQEhpbGxzaGFkZV9BemltdXRoX3RhZzFAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gw6ggdmFsaWRvIHNvbG8gcXVhbmRvIDxzdHJvbmc+VGlwbyByaWxpZXZvIG9tYnJlZ2dpYXRvPC9zdHJvbmc+IMOoIDxzdHJvbmc+VHJhZGl6aW9uYWxlPC9zdHJvbmc+LiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggMzE1IGdyYWRpLCBhIHBhcnRpcmUgZGEgTm9yZC1PdmVzdC5cIixcblx0XCJAQEhpbGxzaGFkZV9EaXNhYmxlLWRlZmF1bHQtZWRnZS1waXhlbC1pbnRlcnBvbGF0aW9uX3RhZzBAQFwiOiBcIlNlIHNpIHVzYSBxdWVzdGEgb3B6aW9uZSBzaSBldml0ZXJhbm5vIGdsaSBhcnRlZmF0dGkgZGkgcmljYW1waW9uYW1lbnRvIGNoZSBzaSBwb3Nzb25vIHZlcmlmaWNhcmUgbHVuZ28gaSBtYXJnaW5pIGRpIHVuIHJhc3Rlci4gSSBwaXhlbCBkaSBvdXRwdXQgbHVuZ28gaWwgbWFyZ2luZSBkaSB1biByYXN0ZXIgbyBhY2NhbnRvIGFpIHBpeGVsIE5vRGF0YSB2ZXJyYW5ubyBwb3BvbGF0aSBjb24gTm9EYXRhOyBwZXIgcXVlc3RhIHJhZ2lvbmUsIHNpIGNvbnNpZ2xpYSBkaSB1dGlsaXp6YXJlIGlsIHBhcmFtZXRybyBzb2xvIGNvbiBtb3NhaWMgZGF0YXNldCBkaSBlbGV2YXppb25lIGNvbiBzb3ZyYXBwb3NpemlvbmUuIFF1YW5kbyBzb25vIGRpc3BvbmliaWxpIHBpeGVsIHNvdnJhcHBvc3RpLCBsZSBhcmVlIE5vRGF0YSB2aXN1YWxpenplcmFubm8gaSB2YWxvcmkgZGkgcGl4ZWwgc292cmFwcG9zdGkgaW52ZWNlIGRpIHBpeGVsIHZ1b3RpLlwiLFxuXHRcIkBASGlsbHNoYWRlX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMUBAXCI6IFwiTm9uIHNlbGV6aW9uYXRvOiBzaSBhcHBsaWNoZXLDoCB1biByaWNhbXBpb25hbWVudG8gYmlsaW5lYXJlIHVuaWZvcm1lIHBlciByaWNhbXBpb25hcmUgbCdoaWxsc2hhZGUuIFV0aWxpenphcmUgcXVlc3RhIG9wemlvbmUgcXVhbmRvIGlsIG1vc2FpYyBkYXRhc2V0IGNoZSBjb250aWVuZSBpIGRhdGkgZGVsIHJhc3RlciBkaSBlbGV2YXppb25lIMOoIHVuaXRvIGRhIGNlcHBpLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBIaWxsc2hhZGVfRGlzYWJsZS1kZWZhdWx0LWVkZ2UtcGl4ZWwtaW50ZXJwb2xhdGlvbl90YWcyQEBcIjogXCJTZWxlemlvbmF0bzogc2kgdXRpbGl6emVyw6AgdW4gcmljYW1waW9uYW1lbnRvIGJpbGluZWFyZSBhbGwnaW50ZXJubyBkZWxsJ2hpbGxzaGFkZSB0cmFubmUgbHVuZ28gaSBtYXJnaW5pIGRlaSByYXN0ZXIgbyBhY2NhbnRvIGFpIHBpeGVsIGRpIE5vRGF0YS4gUXVlc3RpIHBpeGVsIHNhcmFubm8gcG9wb2xhdGkgY29uIE5vRGF0YSBlIG1vc3RyZXJhbm5vIGkgdmFsb3JpIGRpIHBpeGVsIHNvdnJhcHBvc3RpLCBxdWluZGkgcmlkdXJyYW5ubyBldmVudHVhbGkgZWZmZXR0aSBkaSBtYXJnaW5pIG5ldHRpIGNoZSBhbHRyaW1lbnRpIHNpIHZlcmlmaWNoZXJlYmJlcm8uIFV0aWxpenphcmUgcXVlc3RhIG9wemlvbmUgcXVhbmRvIGlsIG1vc2FpYyBkYXRhc2V0IGNoZSBjb250aWVuZSBpIGRhdGkgZGVsIHJhc3RlciBkaSBlbGV2YXppb25lIGNvbnNpc3RlIGRpIGVsZW1lbnRpIG8gdGlsZSBzb3ZyYXBwb3N0aS5cIixcblx0XCJAQEhpbGxzaGFkZV9EaXNhYmxlLWRlZmF1bHQtZWRnZS1waXhlbC1pbnRlcnBvbGF0aW9uX3RhZzNAQFwiOiBcIkkgcmlzdWx0YXRpIHByb3ZlbmllbnRpIGRhbGxhIGZ1bnppb25lIHBvc3Nvbm8gZXNzZXJlIGRpcGVuZGVudGkgZGFpIGRhdGkuIE9zc2VydmFuZG8gZ2xpIGFydGVmYXR0aSBkZWkgdGlsZSBib3VuZGFyeSBuZWxsJ291dHB1dCwgw6ggaW1wb3J0YW50ZSBzZWxlemlvbmFyZSBsZSBjb25kaXppb25pIGFsdGVybmF0aXZlIGRlbGxhIGNhc2VsbGEgZGkgc2VsZXppb25lLlwiLFxuXHRcIkBASGlsbHNoYWRlX0hpbGxzaGFkZS1UeXBlX3RhZzBAQFwiOiBcIkNvbnRyb2xsYSBsYSBmb250ZSBkaSBpbGx1bWluYXppb25lIHBlciBsJ2hpbGxzaGFkZTpcIixcblx0XCJAQEhpbGxzaGFkZV9IaWxsc2hhZGUtVHlwZV90YWcxQEBcIjogXCJUcmFkaXppb25hbGU6IGNhbGNvbGEgbCdoaWxsc2hhZGUgZGEgdW4ndW5pY2EgZGlyZXppb25lIGRpIGlsbHVtaW5hemlvbmUuIFNpIHRyYXR0YSBkZWxsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS4gw4ggcG9zc2liaWxlIGltcG9zdGFyZSA8c3Ryb25nPkF6aW11dDwvc3Ryb25nPiBlIDxzdHJvbmc+QWx0aXR1ZGluZTwvc3Ryb25nPiBwZXIgY29udHJvbGxhcmUgbGEgcG9zaXppb25lIGRlbGxhIGZvbnRlIGRpIGx1Y2UuXCIsXG5cdFwiQEBIaWxsc2hhZGVfSGlsbHNoYWRlLVR5cGVfdGFnNkBAXCI6IFwiTXVsdGlkaXJlemlvbmFsZTogY29tYmluYSBsYSBsdWNlIGRhIGZvbnRpIG11bHRpcGxlIHBlciByYXBwcmVzZW50YXJlIHVuYSB2aXN1YWxpenphemlvbmUgbWlnbGlvcmF0YSBkZWwgdGVycmVuby5cIixcblx0XCJAQEhpbGxzaGFkZV9QaXhlbC1TaXplLUZhY3Rvcl90YWcwQEBcIjogXCJGYXR0b3JlIGRpbWVuc2lvbmUgcGl4ZWwgc2kgcmlmZXJpc2NlIGFsbGUgdmFyaWF6aW9uaSBuZWxsYSBzY2FsYSBpbmdyYW5kZW5kbyBlIHJpZHVjZW5kbyBsJ2ltbWFnaW5lIGNvbiBsbyB6b29tIHN1bGxhIHZpc3VhbGl6emF6aW9uZSBkZWxsYSBtYXBwYS4gQ29udHJvbGxhIGlsIHRhc3NvIGFsIHF1YWxlIGNhbWJpYSBpbCA8c3Ryb25nPkZhdHRvcmUgWjwvc3Ryb25nPi5cIixcblx0XCJAQEhpbGxzaGFkZV9QaXhlbC1TaXplLUZhY3Rvcl90YWczQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIMOoIHZhbGlkbyBzb2xvIHF1YW5kbyBpbCB0aXBvIGRpIDxzdHJvbmc+U2NhbGE8L3N0cm9uZz4gw6ggPHN0cm9uZz5SZWdvbGF0bzwvc3Ryb25nPi4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDAsMDI0LlwiLFxuXHRcIkBASGlsbHNoYWRlX1BpeGVsLVNpemUtUG93ZXJfdGFnMEBAXCI6IFwiUG90ZW56YSBkaW1lbnNpb25lIHBpeGVsIHNpIHJpZmVyaXNjZSBhbGxlIHZhcmlhemlvbmkgZGkgYWx0aXR1ZGluZSAobyBzY2FsYSkgaW5ncmFuZGVuZG8gZSByaWR1Y2VuZG8gbCdpbW1hZ2luZSBjb24gbG8gem9vbSBzdWxsYSB2aXN1YWxpenphemlvbmUgZGVsbGEgbWFwcGEuIMOIIGwnZXNwb25lbnRlIGFwcGxpY2F0byBhbCB0ZXJtaW5lIGRpbWVuc2lvbmUgZGkgcGl4ZWwgbmVsbCdlcXVhemlvbmUgY2hlIGNvbnRyb2xsYSBpbCB0YXNzbyBhbCBxdWFsZSBpbCA8c3Ryb25nPkZhdHRvcmUgWjwvc3Ryb25nPiBjYW1iaWEgcGVyIGV2aXRhcmUgdW5hIHBlcmRpdGEgc2lnbmlmaWNhdGl2YSBkaSByaWxpZXZvLlwiLFxuXHRcIkBASGlsbHNoYWRlX1BpeGVsLVNpemUtUG93ZXJfdGFnM0BAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyDDqCB2YWxpZG8gc29sbyBxdWFuZG8gaWwgdGlwbyBkaSA8c3Ryb25nPlNjYWxhPC9zdHJvbmc+IMOoIDxzdHJvbmc+UmVnb2xhdG88L3N0cm9uZz4uIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAwLDY2NC5cIixcblx0XCJAQEhpbGxzaGFkZV9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgZGF0YXNldCBkaSBlbGV2YXppb25lIGRpIGlucHV0LlwiLFxuXHRcIkBASGlsbHNoYWRlX1NjYWxpbmdfdGFnMEBAXCI6IFwiSWwgcmlzdWx0YXRvIG9tYnJlZ2dpYXRvIMOoIHNjYWxhdG8gZGluYW1pY2FtZW50ZSByZWdvbGFuZG8gaWwgZmF0dG9yZSB6IHVzYW5kbyB1bmEgZGVsbGUgZHVlIG9wemlvbmkgc2VndWVudGk6XCIsXG5cdFwiQEBIaWxsc2hhZGVfU2NhbGluZ190YWcxQEBcIjogXCJSZWdvbGF0YTogUXVlc3RhIHNpIGFwcGxpY2EgYSB1bmEgcmVnb2xhemlvbmUgbm9uIGxpbmVhcmUgdXNhbmRvIGkgdmFsb3JpIHByZWRlZmluaXRpIGRpIDxzdHJvbmc+UG90ZW56YSBkaW1lbnNpb25lIHBpeGVsPC9zdHJvbmc+IGUgPHN0cm9uZz5GYXR0b3JlIGRpbWVuc2lvbmUgcGl4ZWw8L3N0cm9uZz4sIGNoZSBjb21wcmVuZGUgdW4nYW1waWEgZ2FtbWEgZGkgdmFyaWF6aW9uaSBkaSBhbHRpdHVkaW5lIChzY2FsYSkgaW5ncmFuZGVuZG8gZSByaWR1Y2VuZG8gbCdpbW1hZ2luZSBjb24gbG8gem9vbS4gSWwgcGFyYW1ldHJvIDxzdHJvbmc+UmVnb2xhdGE8L3N0cm9uZz4gw6ggY29uc2lnbGlhdG8gcXVhbmRvIHNpIHV0aWxpenphIHVuIGRhdGFzZXQgbW9uZGlhbGUuXCIsXG5cdFwiQEBIaWxsc2hhZGVfU2NhbGluZ190YWc4QEBcIjogXCJOZXNzdW5hOiBub24gc2kgYXBwbGljYSBuZXNzdW5hIHNjYWxhLiDDiCBsJ29wemlvbmUgaWRlYWxlIHBlciByYXN0ZXIgZGF0YXNldCBzaW5nb2xpIHJlbGF0aXZpIGFkIHVuJ2FyZWEgbG9jYWxlLiBOb24gw6ggdW4nb3B6aW9uZSBjb25zaWdsaWF0YSBwZXIgaSBkYXRhc2V0IG1vbmRpYWxpIGNvbiBncmFuZGkgdmFyaWF6aW9uaSBpbiB0ZXJtaW5pIGRpIGVsZXZhemlvbmUgbyBjb24gbWFwcGUgbXVsdGlzY2FsYSBwb2ljaMOpIHZlcnJlYmJlIHByb2RvdHRvIHVuIHJpbGlldm8gZGVsIHRlcnJlbm8gY29uIHBpY2NvbGUgdmFyaWF6aW9uaSBlIHBpY2NvbGUgc2NhbGUuXCIsXG5cdFwiQEBIaWxsc2hhZGVfWi1GYWN0b3JfdGFnMEBAXCI6IFwiSWwgZmF0dG9yZSBaIMOoIHVuIGZhdHRvcmUgZGkgc2NhbGEgdXRpbGl6emF0byBwZXIgY29udmVydGlyZSBpIHZhbG9yaSBkaSBlbGV2YXppb25lIHBlciBkdWUgbW90aXZpOlwiLFxuXHRcIkBASGlsbHNoYWRlX1otRmFjdG9yX3RhZzFAQFwiOiBcIkNvbnZlcnRpcmUgbGUgdW5pdMOgIGRpIGVsZXZhemlvbmUgKGFkIGVzZW1waW8sIG1ldHJpIG8gcGllZGkpIGluIHVuaXTDoCBkaSBjb29yZGluYXRlIG9yaXp6b250YWxpIGRlbCBkYXRhc2V0LCBjaGUgcG9zc29ubyBlc3NlcmUgcGllZGksIG1ldHJpIG8gZ3JhZGkuXCIsXG5cdFwiQEBIaWxsc2hhZGVfWi1GYWN0b3JfdGFnMkBAXCI6IFwiQWdnaXVuZ2VyZSBpbCBmYXR0b3JlIGRpIGVzYWdlcmF6aW9uZSB2ZXJ0aWNhbGUgcGVyIG90dGVuZXJlIHVuIGVmZmV0dG8gdmlzaXZvLlwiLFxuXHRcIkBASW50X0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBJbnRfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEludF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEludF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBASW50X0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEludF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEludF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQEludF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBASW50X0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEludF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBASW50X0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQEludF9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IGRhIGNvbnZlcnRpcmUgaW4gaW50ZXJvLlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtSXJyZWd1bGFyLURhdGFfQ2VsbHNpemVfdGFnMEBAXCI6IFwiTGEgZGltZW5zaW9uZSBkZWxsZSBjZWxsZSBwZXIgaWwgcmFzdGVyIGRpIG91dHB1dCBzYXLDoCBhdXRvbWF0aWNhbWVudGUgcmlsZXZhdGE7IHR1dHRhdmlhLCDDqCBwb3NzaWJpbGUgY2FtYmlhcmxhLiDDiCBwb3NzaWJpbGUgY2FtYmlhcmUgbGEgZGltZW5zaW9uZSBkZWxsZSBjZWxsZSwgbWEgbCdlc3RlbnNpb25lIGRlbCByYXN0ZXIgZGF0YXNldCByaW1hcnLDoCBsYSBzdGVzc2EuXCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1JcnJlZ3VsYXItRGF0YV9JbnB1dC1TYW1wbGVzX3RhZzBAQFwiOiBcIkkgZGF0aSBkZWkgcHVudGkgZGkgaW5wdXQuXCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1JcnJlZ3VsYXItRGF0YV9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWcwQEBcIjogXCJDaSBzb25vIHF1YXR0cm8gbWV0b2RpIGRpIHJpY2FtcGlvbmFtZW50byBwZXIgcXVlc3RhIGZ1bnppb25lOlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtSXJyZWd1bGFyLURhdGFfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnMUBAXCI6IFwiPHN0cm9uZz5JbnZlcnNvIGRlbGxhIGRpc3RhbnphIHBlc2F0YTwvc3Ryb25nPjogZGV0ZXJtaW5hIGkgdmFsb3JpIGRlbGxlIGNlbGxlIHVzYW5kbyB1bmEgY29tYmluYXppb25lIGxpbmVhcm1lbnRlIHBvbmRlcmF0YSBkaSB1biBpbnNpZW1lIGRpIHB1bnRpIGNhbXBpb25lIG8gY2VsbGUuIElsIHBlc28gw6ggdW5hIGZ1bnppb25lIGRlbGwnaW52ZXJzbyBkZWxsYSBkaXN0YW56YSBkYSBwdW50aSBvIGNlbGxlIGNvbm9zY2l1dGUuXCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1JcnJlZ3VsYXItRGF0YV9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPlJpdmVzdGltZW50byBsaW5lYXJlPC9zdHJvbmc+OiB1c2EgdW5hIHJldGUgaXJyZWdvbGFyZSB0cmlhbmdvbGFyZSBkYWkgcHVudGkgY2VudHJhbGkgZGkgb2duaSBjZWxsYSBkZWwgcmFzdGVyIGlycmVnb2xhcmUgcGVyIGludGVycG9sYXJlIHVuYSBzdXBlcmZpY2llIGNoZSB2aWVuZSBxdWluZGkgY29udmVydGl0YSBpbiB1biByYXN0ZXIgcmVnb2xhcmUuXCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1JcnJlZ3VsYXItRGF0YV9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWc1QEBcIjogXCI8c3Ryb25nPlZpY2lubyBuYXR1cmFsZTwvc3Ryb25nPjogdHJvdmEgaWwgc290dG9pbnNpZW1lIGRpIGNhbXBpb25pIGRpIGlucHV0IHBpw7kgdmljaW5vIGEgdW4gcHVudG8gZGkgcmlmZXJpbWVudG8gZSBhcHBsaWNhIHN1IGRpIGxvcm8gaSBwZXNpIGluIGJhc2UgYWxsZSBhcmVlIHByb3Bvcnppb25hdGUgcGVyIGludGVycG9sYXJlIHVuIHZhbG9yZS5cIixcblx0XCJAQEludGVycG9sYXRlLUlycmVndWxhci1EYXRhX0ludGVycG9sYXRpb24tTWV0aG9kX3RhZzdAQFwiOiBcIjxzdHJvbmc+VmljaW5vIHBpw7kgcHJvc3NpbW88L3N0cm9uZz46IGNhbGNvbGEgaWwgdmFsb3JlIGRlaSBwaXhlbCB1c2FuZG8gaWwgcGl4ZWwgcGnDuSB2aWNpbm8uIFNlIG5vbiBlc2lzdGUgbmVzc3VuIHBpeGVsIGRpIG9yaWdpbmUsIG5vbiDDqCBwb3NzaWJpbGUgY3JlYXJlIG5lc3N1biBwaXhlbCBudW92byBuZWxsJ291dHB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtSXJyZWd1bGFyLURhdGFfU2VhcmNoLVJhZGl1c190YWcwQEBcIjogXCJJZGVudGlmaWNhIGlsIG51bWVybyBkaSBwaXhlbCBkYSBpbmNsdWRlcmUgcGVyIGlsIG1ldG9kbyBzZWxlemlvbmF0byBkaSByaWNhbXBpb25hbWVudG8uIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAkezN9IHBpeGVsLlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtSXJyZWd1bGFyLURhdGFfVmFsdWUtRmllbGRfdGFnMEBAXCI6IFwiU2Ugc2kgc2VsZXppb25hIHVuYSBmZWF0dXJlIGNsYXNzIHB1bnR1YWxlIGNvbWUgaW5wdXQsIHNhcsOgIG5lY2Vzc2FyaW8gaWRlbnRpZmljYXJlIGlsIGNhbXBvIG5lbGxhIHRhYmVsbGEgYXR0cmlidXRpIGNvbiBpbCB2YWxvcmUgZGVpIHB1bnRpXCIsXG5cdFwiQEBJcy1OdWxsX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBJcy1OdWxsX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBJcy1OdWxsX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBASXMtTnVsbF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBASXMtTnVsbF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBJcy1OdWxsX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBASXMtTnVsbF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQElzLU51bGxfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQElzLU51bGxfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBASXMtTnVsbF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBASXMtTnVsbF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBJcy1OdWxsX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgZGEgZXNhbWluYXJlIHBlciBpZGVudGlmaWNhcmUgbGUgY2VsbGUgY2hlIHNvbm8gJHtOb0RhdGF9IChudWxsKS5cIixcblx0XCJAQElzLU51bGxfUmFzdGVyX3RhZzFAQFwiOiBcIkwnaW5wdXQgcHXDsiBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBvIHVuIHZhbG9yZSBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBAS2V5LU1ldGFkYXRhX0JhbmQtTmFtZXNfdGFnMEBAXCI6IFwiUXVlc3RhIG9wZXJhemlvbmUgdmllbmUgdXRpbGl6emF0YSBwZXIgc292cmFzY3JpdmVyZSBpIG5vbWkgZGVsbGUgYmFuZGUgZGkgdW4gcmFzdGVyLiDDiCB1bmEgc3RyaW5nYSBkaSB2YWxvcmkgc2VwYXJhdGkgZGEgdmlyZ29sZSBjaGUgcmFwcHJlc2VudGEgaSBub21pIGRpIGJhbmRlIGFnZ2lvcm5hdGkuXCIsXG5cdFwiQEBLZXktTWV0YWRhdGFfQmFuZC1OYW1lc190YWcxQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIMOoIG9wemlvbmFsZS5cIixcblx0XCJAQEtleS1NZXRhZGF0YV9NZXRhZGF0YS1KU09OX3RhZzBAQFwiOiBcIkkgbWV0YWRhdGkgcHJpbmNpcGFsaSBkYSBpbnNlcmlyZSBuZWwgcmFzdGVyIGluIHVzY2l0YSBkZXNjcml0dGkgY29tZSB1bmEgc3RyaW5nYSBKU09OIHJhcHByZXNlbnRhbm8gdW5hIHJhY2NvbHRhIGRpIGNvcHBpZSBkaSB2YWxvcmkgcHJpbmNpcGFsaS4gUXVhbnRvIHNlZ3VlIMOoIHVuIGVzZW1waW8gZGkgdW5hIHN0cmluZ2EgSlNPTiBjaGUgcHXDsiBlc3NlcmUgdXRpbGl6emF0YSBjb21lIGlucHV0IHBlciBxdWVzdGEgZnVuemlvbmUuIFR1dHRpIGdsaSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybyBkZXZvbm8gc2VndWlyZSBsbyBzdGVzc28gZm9ybWF0by5cIixcblx0XCJAQEtleS1NZXRhZGF0YV9NZXRhZGF0YS1KU09OX3RhZzFAQFwiOiBcIkxhIHN0cmluZ2EgSlNPTiBjaGUgcmFwcHJlc2VudGEgaSBtZXRhZGF0aSBwcmluY2lwYWxpXCIsXG5cdFwiQEBLZXktTWV0YWRhdGFfTWV0YWRhdGEtSlNPTl90YWcyQEBcIjogXCJ7IFxcXCJDbG91ZENvdmVyXFxcIjogNCwgXFxcIkJhbmRQcm9wZXJ0aWVzXFxcIjpbIHsgXFxcIkJhbmROYW1lXFxcIjogXFxcIkJsdWVcXFwiLCBcXFwiV2F2ZWxlbmd0aE1pblxcXCI6IDQ0NSwgXFxcIldhdmVsZW5ndGhNYXhcXFwiOiA1MTYgfSwgeyBcXFwiQmFuZE5hbWVcXFwiOiBcXFwiR3JlZW5cXFwiLCBcXFwiV2F2ZWxlbmd0aE1pblxcXCI6IDUwNiwgXFxcIldhdmVsZW5ndGhNYXhcXFwiOiA1OTUgfSwgXX1cIixcblx0XCJAQEtleS1NZXRhZGF0YV9Qcm9wZXJ0eS1OYW1lX3RhZzBAQFwiOiBcIklsIG5vbWUgZGVsbGEgcHJvcHJpZXTDoCBwcmluY2lwYWxlIGEgbGl2ZWxsbyBkZWwgZGF0YXNldCBkYSBzb3ZyYXNjcml2ZXJlLlwiLFxuXHRcIkBAS2V5LU1ldGFkYXRhX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgbyBpbCBtb3NhaWMgZGF0YXNldCBjaGUgY29udGllbmUgbWV0YWRhdGkgcHJpbmNpcGFsaSBjaGUgc2kgdnVvbGUgaW5zZXJpcmUgbyBzb3ZyYXNjcml2ZXJlLlwiLFxuXHRcIkBAS2V5LU1ldGFkYXRhX1ZhbHVlX3RhZzBAQFwiOiBcIklsIHZhbG9yZSBkaSBzb3ZyYXNjcml6aW9uZSBkZWxsYSBwcm9wcmlldMOgIHByaW5jaXBhbGUgYSBsaXZlbGxvIGRlbCBkYXRhc2V0IGNoZSBzaSB2dW9sZSBpbXBvc3RhcmUuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzBAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gc2ltdWxhIGwnYXVtZW50byBkZWxsbyBzZm9yem8gcGVyIHN1cGVyYXJlIGkgY29zdGkgbWFuIG1hbm8gY2hlIGlsIGNvc3RvIGN1bXVsYXRpdm8gYXVtZW50YS4gVmllbmUgdXNhdG8gcGVyIG1vZGVsbGFyZSBsJ2FmZmF0aWNhbWVudG8gZGVsIHZpYWdnaWF0b3JlLiBJbCBjb3N0byBjdW11bGF0aXZvIGNyZXNjZW50ZSBwZXIgcmFnZ2l1bmdlcmUgdW5hIGNlbGxhIHZpZW5lIG1vbHRpcGxpY2F0byBwZXIgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSBlIGFnZ2l1bnRvIGFsIGNvc3RvIHBlciBsbyBzcG9zdGFtZW50byBuZWxsYSBjZWxsYSBjb25zZWN1dGl2YS5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMUBAXCI6IFwiU2kgdHJhdHRhIGRpIHVuYSB2ZXJzaW9uZSBtb2RpZmljYXRhIGRpIHVuYSBmb3JtdWxhIGNvbXBvc3RhIGRpIHRhc3NvIGRpIGludGVyZXNzZSBjaGUgdmllbmUgdXRpbGl6emF0YSBwZXIgY2FsY29sYXJlIGlsIGNvc3RvIGFwcGFyZW50ZSBkaSBzcG9zdGFtZW50byBhdHRyYXZlcnNvIHVuYSBjZWxsYS4gQ29uIGwnYXVtZW50YXJlIGRlbCB2YWxvcmUgZGVsIHRhc3NvIGRpIHJlc2lzdGVuemEsIGF1bWVudGEgYW5jaGUgaWwgY29zdG8gZGVsbGUgY2VsbGUgdmlzaXRhdGUgaW4gc2VndWl0by4gUXVhbnRvIG1hZ2dpb3JlIMOoIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEsIHRhbnRvIHBpw7kgYWx0byBzYXLDoCBpbCBjb3N0byBwZXIgcmFnZ2l1bmdlcmUgbGEgY2VsbGEgc3VjY2Vzc2l2YSwgY2hlIMOoIHJlc2lzdGVudGUgYSBvZ25pIG1vdmltZW50byBjb25zZWN1dGl2by4gRGFsIG1vbWVudG8gY2hlIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEgw6ggc2ltaWxlIGEgdW4gdGFzc28gY29tcG9zdG8gZSBnZW5lcmFsbWVudGUgaSB2YWxvcmkgZGkgY29zdG8gY3VtdWxhdGl2byBzb25vIG1vbHRvIGdyYW5kaSwgc2kgY29uc2lnbGlhbm8gdGFzc2kgZGkgcmVzaXN0ZW56YSBwaWNjb2xpLCBjb21lIDAsMDA1IG8gYW5jaGUgbWVubywgYSBzZWNvbmRhIGRlaSB2YWxvcmkgZGkgY29zdG8gY3VtdWxhdGl2aS5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMkBAXCI6IFwiSWwgdmFsb3JlIGRldmUgZXNzZXJlIG1hZ2dpb3JlIGRpIHplcm8uIExhIGNhcGFjaXTDoCBwcmVkZWZpbml0YSDDqCBmaW5vIGFsIGJvcmRvIGRlbCByYXN0ZXIgZGkgb3V0cHV0LlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX0NhcGFjaXR5X3RhZzBAQFwiOiBcIkRlZmluaXNjZSBsYSBjYXBhY2l0w6AgZGkgY29zdG8gcGVyIGlsIHZpYWdnaWF0b3JlIHJlbGF0aXZhIGEgdW4nb3JpZ2luZS4gSSBjYWxjb2xpIGRlbCBjb3N0byBjb250aW51YW5vIHBlciBvZ25pIG9yaWdpbmUgZmluY2jDqSBub24gc2kgcmFnZ2l1bmdlIGxhIGNhcGFjaXTDoCBzcGVjaWZpY2F0YS5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9DYXBhY2l0eV90YWcxQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgZGkgemVyby4gTGEgY2FwYWNpdMOgIHByZWRlZmluaXRhIMOoIGZpbm8gYWwgYm9yZG8gZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfQ29zdC1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGRpIGlucHV0IG9iYmxpZ2F0b3JpbyBjaGUgZGVmaW5pc2NlIGlsIGNvc3RvIG8gbCdpbXBlZGVuemEgZGVsbG8gc3Bvc3RhbWVudG8gcGxhbmltZXRyaWNvIGF0dHJhdmVyc28gY2lhc2N1bmEgY2VsbGEuIElsIHZhbG9yZSBhIG9nbmkgcG9zaXppb25lIGRlbGxhIGNlbGxhIHJhcHByZXNlbnRhIGxhIGRpc3RhbnphIGRpIGNvc3RvIHBlciB1bml0w6AgcGVyIGwnYXR0cmF2ZXJzYW1lbnRvIGRlbGxhIHN0ZXNzYS4gT2duaSB2YWxvcmUgZGkgcG9zaXppb25lIGRpIHVuYSBjZWxsYSB2aWVuZSBtb2x0aXBsaWNhdG8gcGVyIGxhIHJpc29sdXppb25lIGRlbGxhIGNlbGxhIGUgY29tcGVuc2EgaW5vbHRyZSBpbCBtb3ZpbWVudG8gZGlhZ29uYWxlIHBlciBvdHRlbmVyZSBpbCBjb3N0byB0b3RhbGUgZGVsbCdhdHRyYXZlcnNhbWVudG8gZGVsbGEgc3Rlc3NhLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX0Nvc3QtUmFzdGVyX3RhZzFAQFwiOiBcIkkgdmFsb3JpIGRlbCA8c3Ryb25nPlJhc3RlciBkaSBjb3N0bzwvc3Ryb25nPiBwb3Nzb25vIGVzc2VyZSBhIG51bWVybyBpbnRlcm8gbyBhIHZpcmdvbGEgbW9iaWxlLCBtYSBub24gcG9zc29ubyBlc3NlcmUgbmVnYXRpdmkgbyB6ZXJvLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX0Rlc3RpbmF0aW9uLUZpZWxkX3RhZzBAQFwiOiBcIklsIGNhbXBvIHVzYXRvIHBlciBvdHRlbmVyZSBpIHZhbG9yaSBwZXIgbGUgcG9zaXppb25pIGRpIGRlc3RpbmF6aW9uZS5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9EZXN0aW5hdGlvbi1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGRpIGlucHV0IG9iYmxpZ2F0b3JpbyBjaGUgaWRlbnRpZmljYSBpIHBpeGVsIGRhIGN1aSB2aWVuZSBkZXRlcm1pbmF0byBpbCBwZXJjb3JzbyBkaSBjb3N0byBtaW5pbW8gdmVyc28gbCdvcmlnaW5lIG1lbm8gY29zdG9zYS4gUXVlc3RvIGlucHV0IMOoIGZvcm1hdG8gZGEgcGl4ZWwgY2hlIGhhbm5vIHZhbG9yaSB2YWxpZGkgZSBpIHBpeGVsIHJlc3RhbnRpIGRldm9ubyBlc3NlcmUgJHtOb0RhdGF9LiBJIHZhbG9yaSBkaSAwIHNvbm8gdmFsaWRpLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiTGEgc29nbGlhIGNoZSBpIHZhbG9yaSBkaSBjb3N0byBjdW11bGF0aXZpIG5vbiBwb3Nzb25vIHN1cGVyYXJlLiBTZSB1bmEgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBzdXBlcmEgcXVlc3RvIHZhbG9yZSwgaWwgdmFsb3JlIGRpIG91dHB1dCBwZXIgbGEgcG9zaXppb25lIGRlbGxhIGNlbGxhIHNhcsOgICR7Tm9EYXRhfS4gTGEgZGlzdGFuemEgbWFzc2ltYSBkZWZpbmlzY2UgbCdlc3RlbnNpb25lIHBlciBsYSBxdWFsZSBzaSBjYWxjb2xhbm8gbGUgZGlzdGFuemUgZGkgY29zdG8gY3VtdWxhdGl2ZS4gTGEgZGlzdGFuemEgcHJlZGVmaW5pdGEgw6ggZmlubyBhbGwnZXN0ZW5zaW9uZSBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzBAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gY29uc2VudGUgaWwgY29udHJvbGxvIGRlbGxhIG1vZGFsaXTDoCBkaSBzcG9zdGFtZW50byBvIGRlbGxhIGdyYW5kZXp6YSBhbGwnb3JpZ2luZS4gTWFnZ2lvcmUgw6ggaWwgbW9sdGlwbGljYXRvcmUsIG1hZ2dpb3JlIMOoIGlsIGNvc3RvIHBlciBsbyBzcG9zdGFtZW50byBhdHRyYXZlcnNvIG9nbmkgY2VsbGEuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcxQEBcIjogXCJJIHZhbG9yaSBkZXZvbm8gZXNzZXJlIG1hZ2dpb3JpIGRpIHplcm8uIEwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhIMOoIDEuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfUGF0aC1UeXBlX3RhZzBAQFwiOiBcIlVuYSBwYXJvbGEgY2hpYXZlIGNoZSBkZWZpbmlzY2UgaWwgbW9kbyBpbiBjdWkgaSB2YWxvcmkgZSBsZSB6b25lIG5laSBkYXRpIGRpIGRlc3RpbmF6aW9uZSBkaSBpbnB1dCB2ZW5nb25vIGludGVycHJldGF0aSBuZWkgY2FsY29saSBkZWwgcGVyY29yc28gZGkgY29zdG86XCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfUGF0aC1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+U2luZ29sbyBtaWdsaW9yZTwvc3Ryb25nPjogcGVyIHR1dHRlIGkgcGl4ZWwgbmVpIGRhdGkgZGkgZGVzdGluYXppb25lIGRpIGlucHV0LCBpbCBwZXJjb3JzbyBkaSBjb3N0byBtaW5pbW8gdmllbmUgcmljYXZhdG8gZGFsIHBpeGVsIGNvbiBpbCBtaW5pbW8gZGVpIHBlcmNvcnNpIGRpIGNvc3RvIG1pbmltbyB2ZXJzbyBsZSBjZWxsZSBkaSBvcmlnaW5lLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1BhdGgtVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPk9nbmkgY2VsbGE8L3N0cm9uZz46IHVuIHBlcmNvcnNvIGRpIGNvc3RvIG1pbmltbyDDqCBkZXRlcm1pbmF0byBwZXIgb2duaSBwaXhlbCBjb24gdmFsb3JpIHZhbGlkaSBuZWkgZGF0aSBkaSBkZXN0aW5hemlvbmUgZGkgaW5wdXQsIGUgc2FsdmF0byBuZWwgcmFzdGVyIGRpIG91dHB1dC4gT2duaSBjZWxsYSBkZWkgZGF0aSBkaSBkZXN0aW5hemlvbmUgZGkgaW5wdXQgdmllbmUgdHJhdHRhdGEgc2VwYXJhdGFtZW50ZSBlIHZpZW5lIGRldGVybWluYXRvIHVuIHBlcmNvcnNvIGRpIGNvc3RvIG1pbmltbyBwZXIgY2lhc2N1bmEgY2VsbGEuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfUGF0aC1UeXBlX3RhZzVAQFwiOiBcIjxzdHJvbmc+T2duaSB6b25hPC9zdHJvbmc+OiB1biBwZXJjb3JzbyBkaSBjb3N0byBtaW5pbW8gw6ggZGV0ZXJtaW5hdG8gcGVyIG9nbmkgem9uYSBuZWkgZGF0aSBkaSBkZXN0aW5hemlvbmUgZGkgaW5wdXQsIGUgc2FsdmF0byBuZWwgcmFzdGVyIGRpIG91dHB1dC4gSWwgcGVyY29yc28gZGkgY29zdG8gbWluaW1vIHBlciBvZ25pIHpvbmEgaW5pemlhIG5lbCBwaXhlbCBjb24gbGEgcG9uZGVyYXppb25lIGRpc3RhbnphIGRpIGNvc3RvIHBpw7kgYmFzc2EgbmVsbGEgem9uYS5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIsOIIHVuIHJhc3RlciBkaSBpbnB1dCBvYmJsaWdhdG9yaW8gY2hlIGlkZW50aWZpY2EgbGUgY2VsbGUgbyBsZSBwb3NpemlvbmkgZGFsbGUgcXVhbGkgc2kgY2FsY29sYSBsYSBkaXN0YW56YSBkaSBjb3N0byBtaW5pbWEgY3VtdWxhdGl2YSBwZXIgb2duaSBwb3NpemlvbmUgZGkgY2VsbGEgZGkgb3V0cHV0LlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiSWwgY29zdG8gZGkgaW5pemlvIGNvbiBpbCBxdWFsZSBhdnZpYXJlIGkgY2FsY29saSBkZWwgY29zdG8uIFF1ZXN0byBwYXJhbWV0cm8gY29uc2VudGUgZGkgc3BlY2lmaWNhcmUgaWwgY29zdG8gZmlzc28gYXNzb2NpYXRvIGFkIHVuJ29yaWdpbmUuIEludmVjZSBkaSBpbml6aWFyZSBjb24gdW4gY29zdG8gMCwgbCdhbGdvcml0bW8gZGVsIGNvc3RvIGluaXppZXLDoCBjb24gaWwgdmFsb3JlIHNwZWNpZmljYXRvLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1N0YXJ0LUNvc3RfdGFnMUBAXCI6IFwiSWwgdmFsb3JlIGRldmUgZXNzZXJlIHBhcmkgbyBzdXBlcmlvcmUgYSB6ZXJvLiBMJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YSDDqCAwLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1RyYXZlbC1EaXJlY3Rpb25fdGFnMEBAXCI6IFwiRGVmaW5pc2NlIGxhIGRpcmV6aW9uZSBkZWwgdmlhZ2dpYXRvcmUgcXVhbmRvIHNpIGFwcGxpY2EgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSBkZWxsJ29yaWdpbmUgZSBpbCBjb3N0byBpbml6aWFsZSBkZWxsJ29yaWdpbmUuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfVHJhdmVsLURpcmVjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPkRhbGwnb3JpZ2luZTwvc3Ryb25nPjogSWwgdGFzc28gZGkgcmVzaXN0ZW56YSBkaSBvcmlnaW5lIGUgaWwgY29zdG8gaW5pemlhbGUgZGVsbCdvcmlnaW5lIHNhcmFubm8gYXBwbGljYXRpIGEgcGFydGlyZSBkYWxsJ29yaWdpbmUgZGkgaW5wdXQgZSBwb2kgc3Bvc3RhbmRvc2kgYWxsZSBjZWxsZSBub24tb3JpZ2luZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1RyYXZlbC1EaXJlY3Rpb25fdGFnM0BAXCI6IFwiPHN0cm9uZz5WZXJzbyBsJ29yaWdpbmU8L3N0cm9uZz46IElsIHRhc3NvIGRpIHJlc2lzdGVuemEgZGkgb3JpZ2luZSBlIGlsIGNvc3RvIGluaXppYWxlIGRlbGwnb3JpZ2luZSBzYXJhbm5vIGFwcGxpY2F0aSBhIHBhcnRpcmUgZGEgY2lhc2N1bmEgY2VsbGEgbm9uLW9yaWdpbmUgZSBwb2kgdG9ybmFuZG8gaW5kaWV0cm8gYWxsJ29yaWdpbmUgZGkgaW5wdXQuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfVHJhdmVsLURpcmVjdGlvbl90YWc1QEBcIjogXCJTcGVjaWZpY2FyZSBsYSBwYXJvbGEgY2hpYXZlIDxzdHJvbmc+RGFsbCdvcmlnaW5lPC9zdHJvbmc+IG8gPHN0cm9uZz5WZXJzbyBsJ29yaWdpbmU8L3N0cm9uZz4sIGNoZSBzYXLDoCBhcHBsaWNhdGEgYSB0dXR0ZSBsZSBvcmlnaW5pLCBvcHB1cmUgc3BlY2lmaWNhcmUgdW4gY2FtcG8gbmVsIDxzdHJvbmc+UmFzdGVyIGRpIG9yaWdpbmU8L3N0cm9uZz4gY2hlIGNvbnRpZW5lIGxlIHBhcm9sZSBjaGlhdmUgcGVyIGlkZW50aWZpY2FyZSBsYSBkaXJlemlvbmUgZGkgdmlhZ2dpbyBwZXIgb2duaSBvcmlnaW5lLiBRdWVsIGNhbXBvIGRldmUgY29udGVuZXJlIGxhIHN0cmluZ2EgJHtGUk9NX1NPVVJDRX0gbyAke1RPX1NPVVJDRX0uXCIsXG5cdFwiQEBMZXNzLVRoYW5fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQExlc3MtVGhhbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATGVzcy1UaGFuX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATGVzcy1UaGFuX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBMZXNzLVRoYW5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATGVzcy1UaGFuX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATGVzcy1UaGFuX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBATGVzcy1UaGFuX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBMZXNzLVRoYW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATGVzcy1UaGFuX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBMZXNzLVRoYW5fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBATGVzcy1UaGFuX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IGRhIGVzYW1pbmFyZSBwZXIgZGV0ZXJtaW5hcmUgc2Ugw6ggcGnDuSBwaWNjb2xvIGRlbCBzZWNvbmRvIGlucHV0LlwiLFxuXHRcIkBATGVzcy1UaGFuX1Jhc3Rlcl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBMZXNzLVRoYW5fUmFzdGVyMl90YWcwQEBcIjogXCJMJ2lucHV0IGNvbiBpbCBxdWFsZSB2aWVuZSBtZXNzbyBhIGNvbmZyb250byBpbCBwcmltbyBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgc2UgcXVlc3QndWx0aW1vIMOoIHBpw7kgcGljY29sby5cIixcblx0XCJAQExlc3MtVGhhbl9SYXN0ZXIyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfUmFzdGVyX3RhZzBAQFwiOiBcIkwnaW5wdXQgZGEgZXNhbWluYXJlIHBlciBkZXRlcm1pbmFyZSBzZSDDqCBwacO5IHBpY2NvbG8gbyB1Z3VhbGUgYWwgc2Vjb25kbyBpbnB1dC5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9SYXN0ZXJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX1Jhc3RlcjJfdGFnMEBAXCI6IFwiTCdpbnB1dCBjb24gaWwgcXVhbGUgdmllbmUgbWVzc28gYSBjb25mcm9udG8gaWwgcHJpbW8gaW5wdXQgcGVyIGRldGVybWluYXJlIHNlIHF1ZXN0J3VsdGltbyDDqCBwacO5IHBpY2NvbG8gbyB1Z3VhbGUuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfUmFzdGVyMl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBMbl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBATG5fQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQExuX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATG5fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQExuX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQExuX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATG5fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBMbl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBATG5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATG5fRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQExuX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQExuX1Jhc3Rlcl90YWcwQEBcIjogXCJJIHZhbG9yaSBkaSBpbnB1dCBwZXIgaSBxdWFsaSDDqCBuZWNlc3NhcmlvIHRyb3ZhcmUgaWwgbG9nYXJpdG1vIG5hdHVyYWxlIChMbikuXCIsXG5cdFwiQEBMb2cxMF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBATG9nMTBfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQExvZzEwX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATG9nMTBfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQExvZzEwX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQExvZzEwX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATG9nMTBfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBMb2cxMF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBATG9nMTBfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATG9nMTBfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQExvZzEwX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQExvZzEwX1Jhc3Rlcl90YWcwQEBcIjogXCJJIHZhbG9yaSBkaSBpbnB1dCBwZXIgaSBxdWFsaSDDqCBuZWNlc3NhcmlvIHRyb3ZhcmUgbGEgYmFzZSAxMCBkZWwgbG9nYXJpdG1vLlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQExvZzJfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQExvZzJfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQExvZzJfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBMb2cyX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBMb2cyX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQExvZzJfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQExvZzJfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBATG9nMl9SYXN0ZXJfdGFnMEBAXCI6IFwiSSB2YWxvcmkgZGkgaW5wdXQgcGVyIGkgcXVhbGkgw6ggbmVjZXNzYXJpbyB0cm92YXJlIGxhIGJhc2UgMiBkZWwgbG9nYXJpdG1vLlwiLFxuXHRcIkBATG9va3VwX0ZpZWxkX3RhZzBAQFwiOiBcIklsIGNhbXBvIGNoZSBjb250aWVuZSBpIHZhbG9yaSBkZXNpZGVyYXRpIHBlciBpbCBudW92byByYXN0ZXIuXCIsXG5cdFwiQEBMb29rdXBfRmllbGRfdGFnMUBAXCI6IFwiRGV2ZSBlc3NlcmUgZGkgdGlwbyBudW1lcmljby5cIixcblx0XCJAQExvb2t1cF9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IGNoZSBjb250aWVuZSB1biBjYW1wbyBkYWwgcXVhbGUgY3JlYXJlIHVuIG51b3ZvIHJhc3Rlci5cIixcblx0XCJAQExvb2t1cF9SYXN0ZXJfdGFnMUBAXCI6IFwiUHXDsiBlc3NlcmUgdW4gdGlwbyBpbnRlcm8gbyBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBATWFza19JbmNsdWRlZC1SYW5nZXNfdGFnMEBAXCI6IFwiUGVyIGNpYXNjdW5hIGJhbmRhLCDDqCBwb3NzaWJpbGUgc3BlY2lmaWNhcmUgZ2xpIGludGVydmFsbGkgaW5jbHVzaSBpbnNlcmVuZG8gdW4gdmFsb3JlIG1pbmltbyBlIG1hc3NpbW87IHF1YWxzaWFzaSB2YWxvcmUgYWwgZGkgZnVvcmkgZGVsbCdpbnRlcnZhbGxvIHNhcsOgIHJlc3RpdHVpdG8gY29tZSAke05vRGF0YX0uIFVuIHBpeGVsIMOoIGluY2x1c28gc2UgaWwgdmFsb3JlIGRpIHBpeGVsIHJpZW50cmEgaW4gdW5vIHF1YWxzaWFzaSBkZWdsaSBpbnRlcnZhbGxpIHNwZWNpZmljYXRpLiBQZXJ0YW50bywgc2UgbGEgYmFuZGEgMSBoYSB1biBpbnRlcnZhbGxvIGRpIDUtMTAgZSBsYSBiYW5kYSAyIGhhIHVuIGludGVydmFsbG8gZGkgMTUtMjAgZSBpbCB2YWxvcmUgZGkgcGl4ZWwgcGVyIGxhIGJhbmRhIDEgw6ggOCwgcXVlc3RvIHBpeGVsIG5vbiB2ZXJyw6AgbWFzY2hlcmF0by5cIixcblx0XCJAQE1hc2tfTm9EYXRhLUludGVycHJldGF0aW9uX3RhZzBAQFwiOiBcIkZhIHJpZmVyaW1lbnRvIGEgY29tZSBpIDxzdHJvbmc+VmFsb3JpICR7Tm9EYXRhfTwvc3Ryb25nPiBpbmZsdWVuemVyYW5ubyBsJ2ltbWFnaW5lIGRpIG91dHB1dC5cIixcblx0XCJAQE1hc2tfTm9EYXRhLUludGVycHJldGF0aW9uX3RhZzNAQFwiOiBcIsOIIHBvc3NpYmlsZSBzZWxlemlvbmFyZSB1bmEgZGVsbGUgZHVlIHNlZ3VlbnRpIG9wemlvbmk6XCIsXG5cdFwiQEBNYXNrX05vRGF0YS1JbnRlcnByZXRhdGlvbl90YWc0QEBcIjogXCI8c3Ryb25nPkNvcnJpc3BvbmRlbnphIGNvbiB0dXR0aTwvc3Ryb25nPjogaSB2YWxvcmkgJHtOb0RhdGF9IHNwZWNpZmljYXRpIHBlciBjaWFzY3VuYSBiYW5kYSBkZXZvbm8gZXNzZXJlIHByZXNlbnRpIG5lbGxvIHN0ZXNzbyBwaXhlbCBhZmZpbmNow6kgbCdpbW1hZ2luZSBkaSBvdXRwdXQgY29udGVuZ2EgaWwgcGl4ZWwgJHtOb0RhdGF9LlwiLFxuXHRcIkBATWFza19Ob0RhdGEtSW50ZXJwcmV0YXRpb25fdGFnNkBAXCI6IFwiPHN0cm9uZz5Db3JyaXNwb25kZW56YSBjb24gcXVhbHNpYXNpPC9zdHJvbmc+OiBzZSBpbCB2YWxvcmUgJHtOb0RhdGF9IHNwZWNpZmljYXRvIMOoIHByZXNlbnRlIHBlciB1biBwaXhlbCBpbiB1bmEgYmFuZGEgc3BlY2lmaWNhLCBxdWVsIHBpeGVsIG5lbGwnaW1tYWdpbmUgZGkgb3V0cHV0IHNhcsOgICR7Tm9EYXRhfS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATWFza19Ob0RhdGEtVmFsdWVzX3RhZzBAQFwiOiBcIlBlciBjaWFzY3VuYSBiYW5kYSwgw6ggcG9zc2liaWxlIHNwZWNpZmljYXJlIGkgVmFsb3JpIE5vRGF0YS4gw4ggcG9zc2liaWxlIHNwZWNpZmljYXJlIHBpw7kgZGkgdW4gdmFsb3JlIGluc2VyZW5kbyB1biBlbGVuY28gc2VwYXJhdG8gZGEgc3BhemkuXCIsXG5cdFwiQEBNYXNrX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBNaW51c19DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBATWludXNfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQE1pbnVzX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATWludXNfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQE1pbnVzX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQE1pbnVzX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATWludXNfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBNaW51c19FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBATWludXNfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATWludXNfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQE1pbnVzX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQE1pbnVzX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IGRhbCBxdWFsZSBzb3R0cmFycmUgaSB2YWxvcmkgZGVsIHNlY29uZG8gaW5wdXQuXCIsXG5cdFwiQEBNaW51c19SYXN0ZXJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBATWludXNfUmFzdGVyMl90YWcwQEBcIjogXCJJIHZhbG9yaSBkaSBpbnB1dCBkYSBzb3R0cmFycmUgZGFpIHZhbG9yaSBkZWwgcHJpbW8gaW5wdXQuXCIsXG5cdFwiQEBNaW51c19SYXN0ZXIyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQE1MLUNsYXNzaWZ5X1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgZGEgY2xhc3NpZmljYXJlIHV0aWxpenphbmRvIGwnYWxnb3JpdG1vIGRpIGNsYXNzaWZpY2F6aW9uZSBwZXIgbWFzc2ltYSBwcm9iYWJpbGl0w6AuXCIsXG5cdFwiQEBNTC1DbGFzc2lmeV9TaWduYXR1cmUtRmlsZS1vci1VUkxfdGFnMEBAXCI6IFwiSWwgZmlsZSBkaSBmaXJtYSAkey5nc2d9LlwiLFxuXHRcIkBATW9kX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBNb2RfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQE1vZF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQE1vZF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATW9kX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQE1vZF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQE1vZF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQE1vZF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBATW9kX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQE1vZF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBATW9kX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQE1vZF9SYXN0ZXJfdGFnMEBAXCI6IFwiTCdpbnB1dCBudW1lcmF0b3JlLlwiLFxuXHRcIkBATW9kX1Jhc3Rlcl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBNb2RfUmFzdGVyMl90YWcwQEBcIjogXCJMJ2lucHV0IGRlbm9taW5hdG9yZS5cIixcblx0XCJAQE1vZF9SYXN0ZXIyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX09wZXJhdGlvbl90YWcwQEBcIjogXCJSaXNvbHZlcmUgaSBjb25mbGl0dGkgcXVhbmRvIHNpIGhhbm5vIHBhcnRpIGRpIGR1ZSBvIHBpw7kgaW1tYWdpbmkgY2hlIHNpIHNvdnJhcHBvbmdvbm8uIExlIG9wemlvbmkgaW5jbHVkb25vIHF1YW50byBzZWd1ZTpcIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX09wZXJhdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPkZ1c2lvbmU8L3N0cm9uZz46IGNhbGNvbGFyZSBlIHZpc3VhbGl6emFyZSB1bmEgbWVkaWEgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBvbmRlcmFuZG8gZGkgcGnDuSBpIHBpeGVsIHBpw7kgdmljaW5pIGFsbGUgaW1tYWdpbmkgZGkgcXVhcnRpZXJlIGFmZmluY2jDqSBsJ291dHB1dCBzaWEgdW4naW1tYWdpbmUgcGnDuSBzbXVzc2F0YS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATW9zYWljLVJhc3RlcnNfT3BlcmF0aW9uX3RhZzNAQFwiOiBcIjxzdHJvbmc+UHJpbW88L3N0cm9uZz46IHZpc3VhbGl6emFyZSBpIHBpeGVsIGRhbGxhIHByaW1hIGltbWFnaW5lIG5lbGwnZWxlbmNvIGRlbGxlIGltbWFnaW5pIHNvdnJhcHBvc3RlIGluIHVuJ2FyZWEgZGV0ZXJtaW5hdGEuXCIsXG5cdFwiQEBNb3NhaWMtUmFzdGVyc19PcGVyYXRpb25fdGFnNUBAXCI6IFwiPHN0cm9uZz5VbHRpbW88L3N0cm9uZz46IHZpc3VhbGl6emFyZSBpIHBpeGVsIGRhbGwndWx0aW1hIGltbWFnaW5lIG5lbGwnZWxlbmNvIGRlbGxlIGltbWFnaW5pIHNvdnJhcHBvc3RlIGluIHVuJ2FyZWEgZGV0ZXJtaW5hdGEuXCIsXG5cdFwiQEBNb3NhaWMtUmFzdGVyc19PcGVyYXRpb25fdGFnN0BAXCI6IFwiPHN0cm9uZz5NYXg8L3N0cm9uZz46IHZpc3VhbGl6emFyZSBpbCBwaXhlbCBjb24gaWwgdmFsb3JlIG1hc3NpbW8gcmlzcGV0dG8gYSB0dXR0aSBpIGxheWVyIHNvdnJhcHBvc3RpLiBDb24gcXVlc3RhIG9wemlvbmUgbm9uIHNpIGhhIG5lc3N1bmEgZ2FyYW56aWEgZGkgdmlzdWFsaXp6YXppb25lIGRlaSBwaXhlbCBkaSB1bmEgc29sYSBpbW1hZ2luZSBuZWxsJ2FyZWEgc292cmFwcG9zdGEsIHBpdXR0b3N0byBzaSBoYSB1bmEgY29tYmluYXppb25lIGRpIHR1dHRpIGkgbGF5ZXIgcG90ZW56aWFsaS5cIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX09wZXJhdGlvbl90YWc5QEBcIjogXCI8c3Ryb25nPk1lZGlhPC9zdHJvbmc+OiBjYWxjb2xhcmUgZSB2aXN1YWxpenphcmUgdW5hIG1lZGlhIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aS5cIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX09wZXJhdGlvbl90YWcxMUBAXCI6IFwiPHN0cm9uZz5NaW48L3N0cm9uZz46IHZpc3VhbGl6emFyZSBpbCBwaXhlbCBjb24gaWwgdmFsb3JlIG1pbmltbyByaXNwZXR0byBhIHR1dHRpIGkgbGF5ZXIgc292cmFwcG9zdGkuIENvbiBxdWVzdGEgb3B6aW9uZSBub24gc2kgaGEgbmVzc3VuYSBnYXJhbnppYSBkaSB2aXN1YWxpenphemlvbmUgZGVpIHBpeGVsIGRpIHVuYSBzb2xhIGltbWFnaW5lIG5lbGwnYXJlYSBzb3ZyYXBwb3N0YSwgcGl1dHRvc3RvIHNpIGhhIHVuYSBjb21iaW5hemlvbmUgZGkgdHV0dGkgaSBsYXllciBwb3RlbnppYWxpLlwiLFxuXHRcIkBATW9zYWljLVJhc3RlcnNfUmFzdGVyc190YWcwQEBcIjogXCJTZWxlemlvbmFyZSBpIHJhc3RlciBhIHBhcnRpcmUgZGFpIHF1YWxpIHNpIHZ1b2xlIGNyZWFyZSB1biBtb3NhaWNvIHBlciBmb3JtYXJlIHVuJ2ltbWFnaW5lLlwiLFxuXHRcIkBATkRWSV9JbmZyYXJlZC1CYW5kLUlEX3RhZzBAQFwiOiBcIlNwZWNpZmljYSBsJ0lEIGRpIGJhbmRhIGNoZSByYXBwcmVzZW50YSBsYSBwYXJ0ZSBkZWxsJ2luZnJhcm9zc28gdmljaW5vIGRlbGxvIHNwZXR0cm8gZWxldHRyb21hZ25ldGljby5cIixcblx0XCJAQE5EVklfUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBtdWx0aXNwZXR0cmFsZSBkaSBpbnB1dC5cIixcblx0XCJAQE5EVklfU2NpZW50aWZpYy1PdXRwdXRfdGFnMEBAXCI6IFwiSSB2YWxvcmkgZGkgb3V0cHV0IHNwYXppYW5vIGRhIC0xLDAgYSAxLDAsIHVuIGludGVydmFsbG8gdXNhdG8gaW4gbW9sdGUgYXBwbGljYXppb25pIHNjaWVudGlmaWNoZS5cIixcblx0XCJAQE5EVklfVmlzaWJsZS1CYW5kLUlEX3RhZzBAQFwiOiBcIlNwZWNpZmljYSBsJ0lEIGRpIGJhbmRhIGNoZSByYXBwcmVzZW50YSBsYSBwYXJ0ZSByb3NzYSBkZWxsbyBzcGV0dHJvIGVsZXR0cm9tYWduZXRpY28uXCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9Db2xvci1SYW1wX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSB1bm8gc2NoZW1hIGRpIGNvbG9yaSBwcmVkZWZpbml0byBkYWxsJ2VsZW5jbyBhIGRpc2Nlc2EuXCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9Db2xvci1TY2hlbWUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgdGlwbyBkaSBzY2hlbWEgZGkgY29sb3JpIHV0aWxpenphcmUgcGVyIGNvbG9yYXJlIGwnb3V0cHV0IE5EVkk6XCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9Db2xvci1TY2hlbWUtVHlwZV90YWcxQEBcIjogXCJNYXBwYSBjb2xvcmU6IHNjZWdsaWVyZSB1bmEgbWFwcGEgY29sb3JlIHByZWRlZmluaXRhIGRhbGwnZWxlbmNvIGEgZGlzY2VzYS4gSW4gYWx0ZXJuYXRpdmEsIMOoIHBvc3NpYmlsZSBzZm9nbGlhcmUgdW4gZmlsZSBkaSBtYXBwYSBjb2xvcmUgcHJlZXNpc3RlbnRlLlwiLFxuXHRcIkBATkRWSS1Db2xvcml6ZWRfQ29sb3ItU2NoZW1lLVR5cGVfdGFnMkBAXCI6IFwiU2NhbGEgY3JvbWF0aWNhOiBzY2VnbGllcmUgdW5vIHNjaGVtYSBkaSBjb2xvcmkgcHJlZGVmaW5pdG8gZGFsbCdlbGVuY28gYSBkaXNjZXNhLlwiLFxuXHRcIkBATkRWSS1Db2xvcml6ZWRfQ29sb3JtYXBfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHVuYSBtYXBwYSBjb2xvcmUgcHJlZGVmaW5pdGEgZGFsbCdlbGVuY28gYSBkaXNjZXNhLiBJbiBhbHRlcm5hdGl2YSwgw6ggcG9zc2liaWxlIHNmb2dsaWFyZSB1biBmaWxlIGRpIG1hcHBhIGNvbG9yZSBlc2lzdGVudGUuXCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9JbmZyYXJlZC1CYW5kLUlEX3RhZzBAQFwiOiBcIlNwZWNpZmljYSBsJ0lEIGRpIGJhbmRhIGNoZSByYXBwcmVzZW50YSBsYSBwYXJ0ZSBkZWxsJ2luZnJhcm9zc28gdmljaW5vIGRlbGxvIHNwZXR0cm8gZWxldHRyb21hZ25ldGljby5cIixcblx0XCJAQE5EVkktQ29sb3JpemVkX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgbXVsdGlzcGV0dHJhbGUgZGkgaW5wdXQuXCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9TY2llbnRpZmljLU91dHB1dF90YWcwQEBcIjogXCJJIHZhbG9yaSBkaSBvdXRwdXQgc3Bhemlhbm8gZGEgLTEsMCBhIDEsMCwgdW4gaW50ZXJ2YWxsbyB1c2F0byBpbiBtb2x0ZSBhcHBsaWNhemlvbmkgc2NpZW50aWZpY2hlLlwiLFxuXHRcIkBATkRWSS1Db2xvcml6ZWRfVmlzaWJsZS1CYW5kLUlEX3RhZzBAQFwiOiBcIlNwZWNpZmljYSBsJ0lEIGRpIGJhbmRhIGNoZSByYXBwcmVzZW50YSBsYSBwYXJ0ZSByb3NzYSBkZWxsbyBzcGV0dHJvIGVsZXR0cm9tYWduZXRpY28uXCIsXG5cdFwiQEBOZWdhdGVfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQE5lZ2F0ZV9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATmVnYXRlX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATmVnYXRlX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBOZWdhdGVfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATmVnYXRlX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATmVnYXRlX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBATmVnYXRlX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBOZWdhdGVfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATmVnYXRlX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBOZWdhdGVfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBATmVnYXRlX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgZGEgbmVnYXJlIChtb2x0aXBsaWNhdG8gcGVyIC0xKS5cIixcblx0XCJAQE5pYmJsZV9NYXNrLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgb2JibGlnYXRvcmlvIHV0aWxpenphdG8gY29tZSBtYXNjaGVyYS5cIixcblx0XCJAQE5pYmJsZV9NYXNrLVJhc3Rlcl90YWcxQEBcIjogXCJMZSBjZWxsZSBjb24gTm9EYXRhIGNvbWUgdmFsb3JlIHZlcnJhbm5vIHJpZG90dGUgbmVsIDxzdHJvbmc+UmFzdGVyPC9zdHJvbmc+IGRpIGlucHV0LlwiLFxuXHRcIkBATmliYmxlX01hc2stUmFzdGVyX3RhZzRAQFwiOiBcIlRoZSBtYXNrIHJhc3RlciBjYW4gYmUgIGFuIGludGVnZXIgb3IgYSBmbG9hdGluZy1wb2ludCB0eXBlLlwiLFxuXHRcIkBATmliYmxlX05pYmJsZS1Ob0RhdGEtY2VsbHNfdGFnMEBAXCI6IFwiRGVmaW5pc2NlIHNlIGxlIGNlbGxlIE5vRGF0YSBuZWwgcmFzdGVyIGRpIGlucHV0IHJpbWFycmFubm8gTm9EYXRhIG5lbCByYXN0ZXIgZGkgb3V0cHV0LlwiLFxuXHRcIkBATmliYmxlX05pYmJsZS1Ob0RhdGEtY2VsbHNfdGFnMUBAXCI6IFwiPHN0cm9uZz5Obzwvc3Ryb25nPjogc3BlY2lmaWNhIGNoZSBsZSBjZWxsZSBOb0RhdGEgbmVsIHJhc3RlciBkaSBpbnB1dCByaW1hcnJhbm5vIE5vRGF0YSBuZWxsJ291dHB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATmliYmxlX05pYmJsZS1Ob0RhdGEtY2VsbHNfdGFnM0BAXCI6IFwiPHN0cm9uZz5Tw6w8L3N0cm9uZz46IHNwZWNpZmljYSBjaGUgbGUgY2VsbGUgTm9EYXRhIG5lbCByYXN0ZXIgZGkgaW5wdXQgZSBhbGwnaW50ZXJubyBkZWxsYSBtYXNjaGVyYSBwb3Nzb25vIGVzc2VyZSByaWRvdHRlIGluIHZhbG9yaSBkaSBjZWxsYSBkaSBvdXRwdXQgdmFsaWRpLlwiLFxuXHRcIkBATmliYmxlX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgb2JibGlnYXRvcmlvIGNoZSB2ZXJyw6Agcmlkb3R0by5cIixcblx0XCJAQE5pYmJsZV9SYXN0ZXJfdGFnMUBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IHB1w7IgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8gbyB1biB2YWxvcmUgYSB2aXJnb2xhIG1vYmlsZS5cIixcblx0XCJAQE5pYmJsZV9Vc2UtTm9EYXRhLXZhbHVlcy1pZi10aGV5LWFyZS10aGUtbmVhcmVzdC1uZWlnaGJvcl90YWcwQEBcIjogXCJEZWZpbmlzY2Ugc2UgaSB2YWxvcmkgJHtOb0RhdGF9IG5lbCByYXN0ZXIgZGkgaW5wdXQgcG9zc29ubyBlc3NlcmUgcmlkb3R0aSBuZWxsJ2FyZWEgZGVmaW5pdGEgZGFsIHJhc3RlciBkZWxsYSBtYXNjaGVyYS5cIixcblx0XCJAQE5pYmJsZV9Vc2UtTm9EYXRhLXZhbHVlcy1pZi10aGV5LWFyZS10aGUtbmVhcmVzdC1uZWlnaGJvcl90YWcxQEBcIjogXCI8c3Ryb25nPlPDrDwvc3Ryb25nPjogc3BlY2lmaWNhIGNoZSBpbCB2YWxvcmUgZGVsIHZpY2lubyBwacO5IHByb3NzaW1vIHZlcnLDoCB1dGlsaXp6YXRvIGNoZSBzaWEgJHtOb0RhdGF9IG8gdW4gYWx0cm8gdmFsb3JlIGRpIGRhdGkgbmVsIHJhc3RlciBkaSBpbnB1dC4gSSB2YWxvcmkgJHtOb0RhdGF9IG5lbCByYXN0ZXIgZGkgaW5wdXQgcG9zc29ubyBlc3NlcmUgcmlkb3R0aSBpbiBhcmVlIGRlZmluaXRlIGRhbGxhIG1hc2NoZXJhIHNlIHNvbm8gaWwgdmljaW5vIHBpw7kgcHJvc3NpbW8uIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQE5pYmJsZV9Vc2UtTm9EYXRhLXZhbHVlcy1pZi10aGV5LWFyZS10aGUtbmVhcmVzdC1uZWlnaGJvcl90YWczQEBcIjogXCI8c3Ryb25nPk5vPC9zdHJvbmc+OiBzcGVjaWZpY2EgY2hlIHNvbG8gaSB2YWxvcmkgZGkgZGF0aSBwb3Nzb25vIGVzc2VyZSByaWRvdHRpIGluIGFyZWUgZGVmaW5pdGUgZGFsIHJhc3RlciBkZWxsYSBtYXNjaGVyYS4gSSB2YWxvcmkgJHtOb0RhdGF9IG5lbCByYXN0ZXIgZGkgaW5wdXQgbm9uIHBvc3Nvbm8gZXNzZXJlIHJpZG90dGkgaW4gYXJlZSBkZWZpbml0ZSBkYWwgcmFzdGVyIGRlbGxhIG1hc2NoZXJhIGFuY2hlIHNlIHNvbm8gaWwgdmljaW5vIHBpw7kgcHJvc3NpbW8uXCIsXG5cdFwiQEBOaWJibGVfWm9uZS1SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIHpvbmEgZGkgaW5wdXQuXCIsXG5cdFwiQEBOaWJibGVfWm9uZS1SYXN0ZXJfdGFnMUBAXCI6IFwiVW5hIHpvbmEgw6ggcmFwcHJlc2VudGF0YSBkYSB0dXR0ZSBsZSBjZWxsZSBpbiB1biByYXN0ZXIgY29uIGxvIHN0ZXNzbyB2YWxvcmUsIGNoZSBlc3NlIHNpYW5vIGNvbnRpZ3VlIG8gbWVuby4gSWwgbGF5ZXIgZGVsbGEgem9uYSBkaSBpbnB1dCBkZWZpbmlzY2UgbGEgZm9ybWEsIGkgdmFsb3JpIGUgbGUgcG9zaXppb25pIGRlbGxlIHpvbmUuIElsIHJhc3RlciBkZWxsYSB6b25hIHB1w7IgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8gbyB1biB2YWxvcmUgYSB2aXJnb2xhIG1vYmlsZS5cIixcblx0XCJAQE5vdC1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBATm90LUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQE5vdC1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBOb3QtRXF1YWxfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQE5vdC1FcXVhbF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBOb3QtRXF1YWxfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQE5vdC1FcXVhbF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBOb3QtRXF1YWxfUmFzdGVyX3RhZzBAQFwiOiBcIkwnaW5wdXQgY2hlIHZlcnLDoCB1c2F0byBwZXIgY29uZnJvbnRhcmUgbGEgZGlzdWd1YWdsaWFuemEgY29uIGlsIHNlY29uZG8gaW5wdXQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfUmFzdGVyX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQE5vdC1FcXVhbF9SYXN0ZXIyX3RhZzBAQFwiOiBcIkwnaW5wdXQgY2hlIHZlcnLDoCBjb25mcm9udGF0byBjb24gaWwgcHJpbW8gaW5wdXQgcGVyIGxhIGRpc3VndWFnbGlhbnphLlwiLFxuXHRcIkBATm90LUVxdWFsX1Jhc3RlcjJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAUGFuc2hhcnBlbmluZ19NdWx0aXNwZWN0cmFsX3RhZzBAQFwiOiBcIklsIHJhc3RlciBtdWx0aXNwZXR0cmFsZSBkaSBjdWkgc2kgZGVzaWRlcmEgYXVtZW50YXJlIGxhIG5pdGlkZXp6YSB1c2FuZG8gbGEgYmFuZGEgcGFuY3JvbWF0aWNhLlwiLFxuXHRcIkBAUGFuc2hhcnBlbmluZ19QYW5jaHJvbWF0aWNfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRhdGFzZXQgYSBiYW5kYSBzaW5nb2xhIGUgYWQgYWx0YSByaXNvbHV6aW9uZSBjaGUgc2kgdXNlcsOgIHBlciBpbCBwYW5zaGFycGVuaW5nIGRlbCByYXN0ZXIgbXVsdGlzcGV0dHJhbGUgYSBtaW5vcmUgcmlzb2x1emlvbmUuXCIsXG5cdFwiQEBQYW5zaGFycGVuaW5nX1BhbnNoYXJwZW5pbmctVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgbCdhbGdvcml0bW8gcGFuc2hhcnBlbmluZyBjaGUgc2kgZGVzaWRlcmEgdXNhcmUuXCIsXG5cdFwiQEBQYW5zaGFycGVuaW5nX1BhbnNoYXJwZW5pbmctVHlwZV90YWcxQEBcIjogXCJCcm92ZXk6IHVzYSBsJ2FsZ29yaXRtbyBCcm92ZXkgaW4gYmFzZSBhIG1vZGVsbGF6aW9uaSBzcGV0dHJhbGkgcGVyIGZ1c2lvbmUgZGkgZGF0aS5cIixcblx0XCJAQFBhbnNoYXJwZW5pbmdfUGFuc2hhcnBlbmluZy1UeXBlX3RhZzJAQFwiOiBcIkVzcmk6IHVzYSBsJ2FsZ29yaXRtbyBFc3JpIGluIGJhc2UgYSBtb2RlbGxhemlvbmkgc3BldHRyYWxpIHBlciBmdXNpb25lIGRpIGRhdGkuXCIsXG5cdFwiQEBQYW5zaGFycGVuaW5nX1BhbnNoYXJwZW5pbmctVHlwZV90YWczQEBcIjogXCJHcmFtLVNjaG1pZHQ6IHVzYSBsJ2FsZ29yaXRtbyBkaSBuaXRpZGV6emEgc3BldHRyYWxlIEdyYW0tU2NobWlkdCBwZXIgcmVuZGVyZSBuaXRpZGkgaSBkYXRpIG11bHRpc3BldHRyYWxpLlwiLFxuXHRcIkBAUGFuc2hhcnBlbmluZ19QYW5zaGFycGVuaW5nLVR5cGVfdGFnNEBAXCI6IFwiSUhTOiB1c2EgaW50ZW5zaXTDoCwgdG9uYWxpdMOgIGUgc2F0dXJhemlvbmUgZGVsIGNvbG9yZSBwZXIgbGEgZnVzaW9uZSBkaSBkYXRpLlwiLFxuXHRcIkBAUGFuc2hhcnBlbmluZ19QYW5zaGFycGVuaW5nLVR5cGVfdGFnNUBAXCI6IFwiTWVkaW86IHVzYSBpbCB2YWxvcmUgbWVkaW8gdHJhIGkgdmFsb3JpIGRpIHJvc3NvLCB2ZXJkZSBlIGJsdSBlIGlsIHZhbG9yZSBkaSBwaXhlbCBwYW5jcm9tYXRpY28uXCIsXG5cdFwiQEBQYW5zaGFycGVuaW5nX1dlaWdodHNfdGFnMEBAXCI6IFwiU3BlY2lmaWNhcmUgbGUgcG9uZGVyYXppb25pIHBlciBsZSBiYW5kZSByb3NzZSwgdmVyZGkgYmx1IGUgaW5mcmFyb3NzZS4gVHV0dGkgaSB2YWxvcmkgZGV2b25vIGVzc2VyZSBjb21wcmVzaSBuZWxsJ2ludGVydmFsbG8gdHJhIDAgZSAxLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMEBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyBzaW11bGEgbCdhdW1lbnRvIGRlbGxvIHNmb3J6byBwZXIgc3VwZXJhcmUgaSBjb3N0aSBtYW4gbWFubyBjaGUgaWwgY29zdG8gY3VtdWxhdGl2byBhdW1lbnRhLiBWaWVuZSB1c2F0byBwZXIgbW9kZWxsYXJlIGwnYWZmYXRpY2FtZW50byBkZWwgdmlhZ2dpYXRvcmUuIElsIGNvc3RvIGN1bXVsYXRpdm8gY3Jlc2NlbnRlIHBlciByYWdnaXVuZ2VyZSB1bmEgY2VsbGEgdmllbmUgbW9sdGlwbGljYXRvIHBlciBpbCB0YXNzbyBkaSByZXNpc3RlbnphIGUgYWdnaXVudG8gYWwgY29zdG8gcGVyIGxvIHNwb3N0YW1lbnRvIG5lbGxhIGNlbGxhIGNvbnNlY3V0aXZhLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMUBAXCI6IFwiU2kgdHJhdHRhIGRpIHVuYSB2ZXJzaW9uZSBtb2RpZmljYXRhIGRpIHVuYSBmb3JtdWxhIGNvbXBvc3RhIGRpIHRhc3NvIGRpIGludGVyZXNzZSBjaGUgdmllbmUgdXRpbGl6emF0YSBwZXIgY2FsY29sYXJlIGlsIGNvc3RvIGFwcGFyZW50ZSBkaSBzcG9zdGFtZW50byBhdHRyYXZlcnNvIHVuYSBjZWxsYS4gQ29uIGwnYXVtZW50YXJlIGRlbCB2YWxvcmUgZGVsIHRhc3NvIGRpIHJlc2lzdGVuemEsIGF1bWVudGEgYW5jaGUgaWwgY29zdG8gZGVsbGUgY2VsbGUgdmlzaXRhdGUgaW4gc2VndWl0by4gUXVhbnRvIG1hZ2dpb3JlIMOoIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEsIHRhbnRvIHBpw7kgYWx0byBzYXLDoCBpbCBjb3N0byBwZXIgcmFnZ2l1bmdlcmUgbGEgY2VsbGEgc3VjY2Vzc2l2YSwgY2hlIMOoIHJlc2lzdGVudGUgYSBvZ25pIG1vdmltZW50byBjb25zZWN1dGl2by4gRGFsIG1vbWVudG8gY2hlIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEgw6ggc2ltaWxlIGEgdW4gdGFzc28gY29tcG9zdG8gZSBnZW5lcmFsbWVudGUgaSB2YWxvcmkgZGkgY29zdG8gY3VtdWxhdGl2byBzb25vIG1vbHRvIGdyYW5kaSwgc2kgY29uc2lnbGlhbm8gdGFzc2kgZGkgcmVzaXN0ZW56YSBwaWNjb2xpLCBjb21lIDAsMDA1IG8gYW5jaGUgbWVubywgYSBzZWNvbmRhIGRlaSB2YWxvcmkgZGkgY29zdG8gY3VtdWxhdGl2aS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIklsIHZhbG9yZSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBkaSB6ZXJvLiBMYSBjYXBhY2l0w6AgcHJlZGVmaW5pdGEgw6ggZmlubyBhbCBib3JkbyBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfQ2FwYWNpdHlfdGFnMEBAXCI6IFwiRGVmaW5pc2NlIGxhIGNhcGFjaXTDoCBkaSBjb3N0byBwZXIgaWwgdmlhZ2dpYXRvcmUgcmVsYXRpdmEgYSB1bidvcmlnaW5lLiBJIGNhbGNvbGkgZGVsIGNvc3RvIGNvbnRpbnVhbm8gcGVyIG9nbmkgb3JpZ2luZSBmaW5jaMOpIG5vbiBzaSByYWdnaXVuZ2UgbGEgY2FwYWNpdMOgIHNwZWNpZmljYXRhLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9DYXBhY2l0eV90YWcxQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgZGkgemVyby4gTGEgY2FwYWNpdMOgIHByZWRlZmluaXRhIMOoIGZpbm8gYWwgYm9yZG8gZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX0Nvc3QtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBkaSBpbnB1dCBvYmJsaWdhdG9yaW8gY2hlIGRlZmluaXNjZSBpbCBjb3N0byBvIGwnaW1wZWRlbnphIGRlbGxvIHNwb3N0YW1lbnRvIHBsYW5pbWV0cmljbyBhdHRyYXZlcnNvIGNpYXNjdW5hIGNlbGxhLiBJbCB2YWxvcmUgYSBvZ25pIHBvc2l6aW9uZSBkZWxsYSBjZWxsYSByYXBwcmVzZW50YSBsYSBkaXN0YW56YSBkaSBjb3N0byBwZXIgdW5pdMOgIHBlciBsJ2F0dHJhdmVyc2FtZW50byBkZWxsYSBzdGVzc2EuIE9nbmkgdmFsb3JlIGRpIHBvc2l6aW9uZSBkaSB1bmEgY2VsbGEgdmllbmUgbW9sdGlwbGljYXRvIHBlciBsYSByaXNvbHV6aW9uZSBkZWxsYSBjZWxsYSBlIGNvbXBlbnNhIGlub2x0cmUgaWwgbW92aW1lbnRvIGRpYWdvbmFsZSBwZXIgb3R0ZW5lcmUgaWwgY29zdG8gdG90YWxlIGRlbGwnYXR0cmF2ZXJzYW1lbnRvIGRlbGxhIHN0ZXNzYS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfQ29zdC1SYXN0ZXJfdGFnMUBAXCI6IFwiSSB2YWxvcmkgZGVsIDxzdHJvbmc+UmFzdGVyIGRpIGNvc3RvPC9zdHJvbmc+IHBvc3Nvbm8gZXNzZXJlIGEgbnVtZXJvIGludGVybyBvIGEgdmlyZ29sYSBtb2JpbGUsIG1hIG5vbiBwb3Nzb25vIGVzc2VyZSBuZWdhdGl2aSBvIHplcm8uXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX2hvcml6b250YWxmYWN0b3JfdGFnMEBAXCI6IFwiPHA+RGVmaW5pc2NlIGxhIHJlbGF6aW9uZSB0cmEgaWwgZmF0dG9yZSBkaSBjb3N0byBvcml6em9udGFsZSBlIGwnYW5nb2xvIG1vYmlsZSByZWxhdGl2byBvcml6em9udGFsZSAoSFJNQSkuPC9wPjxwPkNpIHNvbm8gZGl2ZXJzaSBmYXR0b3JpIGNvbiBtb2RpZmljYXRvcmkgY2hlIGlkZW50aWZpY2FubyB1biBncmFmaWNvIGRlbCBmYXR0b3JlIHZlcnRpY2FsZSBkZWZpbml0by4gSW5vbHRyZSwgw6ggcG9zc2liaWxlIHV0aWxpenphcmUgdW5hIHRhYmVsbGEgcGVyIGNyZWFyZSB1biBncmFmaWNvIHBlcnNvbmFsaXp6YXRvLiBJIGdyYWZpY2kgc29ubyB1dGlsaXp6YXRpIHBlciBpZGVudGlmaWNhcmUgaWwgZmF0dG9yZSB2ZXJ0aWNhbGUgdXRpbGl6emF0byBuZWwgY2FsY29sbyBkZWwgY29zdG8gdG90YWxlIGRlbGxvIHNwb3N0YW1lbnRvIGluIHVuYSBjZWxsYSB2aWNpbmEuPC9wPjxwPk5lbGxlIHNwaWVnYXppb25pIGNoZSBzZWd1b25vLCB2ZW5nb25vIHV0aWxpenphdGkgZHVlIGFjcm9uaW1pOiBIRiBlIEhSTUEuIEhGIHN0YW5kcyBmb3IgaG9yaXpvbnRhbCBmYWN0b3IsIHdoaWNoIGRlZmluZXMgdGhlIGhvcml6b250YWwgZGlmZmljdWx0eSBlbmNvdW50ZXJlZCB3aGVuIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIHRoZSBuZXh0LiBIUk1BIHN0YSBwZXIgaG9yaXpvbnRhbCByZWxhdGl2ZSBtb3ZpbmcgYW5nbGUsIGNoZSBpZGVudGlmaWNhIGwnYW5nb2xvIHRyYSBsYSBkaXJlemlvbmUgb3JpenpvbnRhbGUgZGEgdW5hIGNlbGxhIGUgbGEgZGlyZXppb25lIGRpIG1vdmltZW50by4gSSB0aXBpIGRpIDwvcD48cD48c3Ryb25nPmZhdHRvcmkgb3JpenpvbnRhbGk8L3N0cm9uZz4gaW5jbHVkb25vIGkgc2VndWVudGk6IDwvcD48dWw+PGxpPjxzdHJvbmc+QmluYXJpbzwvc3Ryb25nPi0tIEluZGljYSBjaGUgc2UgbCdIUk1BIMOoIGluZmVyaW9yZSBhbGwnYW5nb2xvIGRpIHRhZ2xpbywgbCdIRiDDqCBpbXBvc3RhdG8gYWwgdmFsb3JlIGFzc29jaWF0byBhbCBmYXR0b3JlIHplcm87IGFsdHJpbWVudGksIMOoIGluZmluaXRvLjwvbGk+PGxpPjxzdHJvbmc+QXZhbnRpPC9zdHJvbmc+IC0tIFN0YWJpbGlzY2UgY2hlIMOoIHBlcm1lc3NvIHNvbG8gaWwgbW92aW1lbnRvIGluIGF2YW50aS4gTCdIUk1BIGRldmUgZXNzZXJlIG1hZ2dpb3JlIG8gdWd1YWxlIGEgMCBlIGluZmVyaW9yZSBhIDkwIGdyYWRpICgwICZsdDs9IEhSTUEgJmx0OzkwKS4gU2UgbCdIUk1BIMOoIHN1cGVyaW9yZSBhIDAgZSBpbmZlcmlvcmUgYSA0NSBncmFkaSwgbCdIRiBwZXIgbGEgY2VsbGEgdmllbmUgaW1wb3N0YXRvIHN1bCB2YWxvcmUgYXNzb2NpYXRvIGFsIGZhdHRvcmUgemVyby4gU2UgbCdIUk1BIMOoIHN1cGVyaW9yZSBvIHBhcmkgYSA0NSBncmFkaSwgdmllbmUgdXRpbGl6emF0byBpbCB2YWxvcmUgZGVsIG1vZGlmaWNhdG9yZSBkZWwgdmFsb3JlIGxhdGVyYWxlLiBMJ0hGIHBlciBxdWFsc2lhc2kgdmFsb3JlIEhSTUEgdWd1YWxlIG8gc3VwZXJpb3JlIGEgOTAgZ3JhZGkgw6ggaW1wb3N0YXRvIHN1IGluZmluaXRvLjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyZTwvc3Ryb25nPi0tU3BlY2lmaWNhIGNoZSBsJ0hGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGRlbGwnSFJNQS48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmUgaW52ZXJzYTwvc3Ryb25nPi0tU3BlY2lmaWNhIGNoZSBsJ0hGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGludmVyc2EgZGVsbCdIUk1BLjwvbGk+PGxpPjxzdHJvbmc+VGFiZWxsYTwvc3Ryb25nPi0gSWRlbnRpZmljYSBjaGUgdW4gZmlsZSB0YWJlbGxhIHNhcsOgIHVzYXRvIHBlciBkZWZpbmlyZSBpbCBncmFmaWNvIGRlaSBmYXR0b3JpIG9yaXp6b250YWxpIHVzYXRvIHBlciBkZXRlcm1pbmFyZSBnbGkgSEYuPC9saT48L3VsPjxwPkkgbW9kaWZpY2F0b3JpIGRlaSBmYXR0b3JpIG9yaXp6b250YWxpIGluY2x1ZG9ubyBxdWFudG8gc2VndWU6IDwvcD48dWw+PGxpPjxzdHJvbmc+RmF0dG9yZSB6ZXJvPC9zdHJvbmc+LS0gSWwgZmF0dG9yZSBvcml6em9udGFsZSBkYSB1c2FyZSBxdWFuZG8gbCdIUk1BIMOoIHplcm8uIFF1ZXN0byBmYXR0b3JlIHBvc2l6aW9uYSBsJ2ludGVyY2V0dGEgeSBwZXIgcXVhbHNpYXNpIGZ1bnppb25lIGZhdHRvcmUgb3JpenpvbnRhbGUuPC9saT48bGk+PHN0cm9uZz5BbmdvbG8gZGkgdGFnbGlvPC9zdHJvbmc+LS1EZWZpbmlzY2UgbCdhbmdvbG8gSFJNQSBvbHRyZSBpbCBxdWFsZSBsJ0hGIHNhcsOgIGltcG9zdGF0byBzdSBpbmZpbml0by48L2xpPjxsaT48c3Ryb25nPlBlbmRlbnphPC9zdHJvbmc+LS0gU3RhYmlsaXNjZSBsYSBwZW5kZW56YSBkZWxsYSBsaW5lYSByZXR0YSB1c2F0YSBjb24gbGUgcGFyb2xlIGNoaWF2ZSBmYXR0b3JlIG9yaXp6b250YWxlIDxzdHJvbmc+TGluZWFyZTwvc3Ryb25nPiBlIDxzdHJvbmc+TGluZWFyZSBpbnZlcnNhPC9zdHJvbmc+LiBMYSBwZW5kZW56YSDDqCBzcGVjaWZpY2F0YSBjb21lIHVuYSBmcmF6aW9uZSBkaSBzYWxpdGEgc3UgY29yc2EgKHBlciBlc2VtcGlvLCBsYSBwZW5kZW56YSBkZWwgNDUlIMOoIDEvNDUsIGNoZSB2aWVuZSBpbW1lc3NhIGNvbWUgMCwwMjIyMikuPC9saT48bGk+PHN0cm9uZz5TaWRlIHZhbHVlPC9zdHJvbmc+LS0gU3RhYmlsaXNjZSBsJ0hGIHF1YW5kbyBsJ0hSTUEgw6ggbWFnZ2lvcmUgbyB1Z3VhbGUgYSA0NSBncmFkaSBlIG1pbm9yZSBkaSA5MCBncmFkaSBxdWFuZG8gdmllbmUgc3BlY2lmaWNhdGEgbGEgcGFyb2xhIGNoaWF2ZSBGYXR0b3JlIG9yaXp6b250YWxlIDxzdHJvbmc+YXZhbnRpPC9zdHJvbmc+LjwvbGk+PGxpPjxzdHJvbmc+Tm9tZSBkZWxsYSB0YWJlbGxhPC9zdHJvbmc+IC0gSWRlbnRpZmljYSBpbCBub21lIGRlbGxhIHRhYmVsbGEgY2hlIGRlZmluaXNjZSBsJ0hGLjwvbGk+PC91bD5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfSG9yaXpvbnRhbC1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGNoZSBkZWZpbmlzY2UgbGEgZGlyZXppb25lIG9yaXp6b250YWxlIHN1IG9nbmkgY2VsbGEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX0hvcml6b250YWwtUmFzdGVyX3RhZzFAQFwiOiBcIkkgdmFsb3JpIHN1bCByYXN0ZXIgZGV2b25vIGVzc2VyZSBudW1lcmkgaW50ZXJpIGNvbXByZXNpIHRyYSAwIGUgMzYwIGNvbiAwIGdyYWRpIGNoZSBpbmRpY2EgaWwgbm9yZCBvIHZlcnNvIGxhIHBhcnRlIHN1cGVyaW9yZSBkZWxsbyBzY2hlcm1vIGUgY29uIGF1bWVudG8gaW4gc2Vuc28gb3JhcmlvLiBBbGxlIGFyZWUgcGlhbmUgZGV2ZSBlc3NlcmUgZm9ybml0byB1biB2YWxvcmUgZGkgLTEuIEkgdmFsb3JpIGluIG9nbmkgcG9zaXppb25lIHZlbmdvbm8gdXRpbGl6emF0aSBpbnNpZW1lIGEgPHN0cm9uZz5GYXR0b3JlIG9yaXp6b250YWxlPC9zdHJvbmc+IHBlciBkZXRlcm1pbmFyZSBpIGNvc3RpIG9yaXp6b250YWxpIGR1cmFudGUgbG8gc3Bvc3RhbWVudG8gZGEgdW5hIGNlbGxhIGEgcXVlbGxlIHZpY2luZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfTWF4aW11bS1EaXN0YW5jZV90YWcwQEBcIjogXCJMYSBzb2dsaWEgY2hlIGkgdmFsb3JpIGRpIGNvc3RvIGN1bXVsYXRpdmkgbm9uIHBvc3Nvbm8gc3VwZXJhcmUuIFNlIHVuYSBkaXN0YW56YSBkaSBjb3N0byBjdW11bGF0aXZvIHN1cGVyYSBxdWVzdG8gdmFsb3JlLCBpbCB2YWxvcmUgZGkgb3V0cHV0IHBlciBsYSBwb3NpemlvbmUgZGVsbGEgY2VsbGEgc2Fyw6AgTm9EYXRhLiBMYSBkaXN0YW56YSBtYXNzaW1hIGRlZmluaXNjZSBsJ2VzdGVuc2lvbmUgcGVyIGxhIHF1YWxlIHNpIGNhbGNvbGFubyBsZSBkaXN0YW56ZSBkaSBjb3N0byBjdW11bGF0aXZlLiBMYSBkaXN0YW56YSBwcmVkZWZpbml0YSDDqCBmaW5vIGFsbCdlc3RlbnNpb25lIGRlbCByYXN0ZXIgZGkgb3V0cHV0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzBAQFwiOiBcIlVuIG1vbHRpcGxpY2F0b3JlIGRhIGFwcGxpY2FyZSBhaSB2YWxvcmkgZGkgY29zdG8uXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMUBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyBjb25zZW50ZSBpbCBjb250cm9sbG8gZGVsbGEgbW9kYWxpdMOgIGRpIHNwb3N0YW1lbnRvIG8gZGVsbGEgZ3JhbmRlenphIGFsbCdvcmlnaW5lLiBNYWdnaW9yZSDDqCBpbCBtb2x0aXBsaWNhdG9yZSwgbWFnZ2lvcmUgw6ggaWwgY29zdG8gcGVyIGxvIHNwb3N0YW1lbnRvIGF0dHJhdmVyc28gb2duaSBjZWxsYS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcyQEBcIjogXCJJIHZhbG9yaSBkZXZvbm8gZXNzZXJlIG1hZ2dpb3JpIGRpIHplcm8uIEwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhIMOoIDEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnM0BAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHBlciBxdWVzdG8gcGFyYW1ldHJvIHVuIHZhbG9yZSBudW1lcmljbyAoZG9wcGlvKSBvIHVuIGNhbXBvIGRhbCA8c3Ryb25nPlJhc3RlciBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBvYmJsaWdhdG9yaW8gcGVyIGxlIHBvc2l6aW9uaSBkaSBvcmlnaW5lLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9Tb3VyY2UtUmFzdGVyX3RhZzFAQFwiOiBcIsOIIHVuIHJhc3RlciBjaGUgaWRlbnRpZmljYSBsZSBjZWxsZSBvIGxlIHBvc2l6aW9uaSBkYWxsZSBxdWFsaSBzaSBjYWxjb2xhIGxhIGRpc3RhbnphIGRpIGNvc3RvIG1pbmltYSBjdW11bGF0aXZhIHBlciBvZ25pIHBvc2l6aW9uZSBkaSBjZWxsYSBkaSBvdXRwdXQuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1NvdXJjZS1SYXN0ZXJfdGFnMkBAXCI6IFwiUHXDsiBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBvIHVuIHZhbG9yZSBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9TdGFydC1Db3N0X3RhZzBAQFwiOiBcIklsIGNvc3RvIGRpIGluaXppbyBjb24gaWwgcXVhbGUgYXZ2aWFyZSBpIGNhbGNvbGkgZGVsIGNvc3RvLiBRdWVzdG8gcGFyYW1ldHJvIGNvbnNlbnRlIGRpIHNwZWNpZmljYXJlIGlsIGNvc3RvIGZpc3NvIGFzc29jaWF0byBhZCB1bidvcmlnaW5lLiBJbnZlY2UgZGkgaW5pemlhcmUgY29uIHVuIGNvc3RvIDAsIGwnYWxnb3JpdG1vIGRlbCBjb3N0byBpbml6aWVyw6AgY29uIGlsIHZhbG9yZSBzcGVjaWZpY2F0by5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfU3RhcnQtQ29zdF90YWcxQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgcGFyaSBvIHN1cGVyaW9yZSBhIHplcm8uIEwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhIMOoIDAuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1N1cmZhY2UtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBjaGUgZGVmaW5pc2NlIGkgdmFsb3JpIGRpIGVsZXZhemlvbmUgc3Ugb2duaSBwb3NpemlvbmUgZGVsbGEgY2VsbGEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1N1cmZhY2UtUmFzdGVyX3RhZzFAQFwiOiBcIkkgdmFsb3JpIHZlbmdvbm8gdXRpbGl6emF0aSBwZXIgY2FsY29sYXJlIGzigJllZmZldHRpdmEgZGlzdGFuemEgZGVsbGEgc3VwZXJmaWNpZSBwZXJjb3JzYSBkdXJhbnRlIGlsIHBhc3NhZ2dpbyB0cmEgY2VsbGUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1RyYXZlbC1EaXJlY3Rpb25fdGFnMEBAXCI6IFwiRGVmaW5pc2NlIGxhIGRpcmV6aW9uZSBkZWwgdmlhZ2dpYXRvcmUgcXVhbmRvIHNpIGFwcGxpY2EgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSBkZWxsJ29yaWdpbmUgZSBpbCBjb3N0byBpbml6aWFsZSBkZWxsJ29yaWdpbmUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1RyYXZlbC1EaXJlY3Rpb25fdGFnMUBAXCI6IFwiPHN0cm9uZz5EYWxsJ29yaWdpbmU8L3N0cm9uZz46IElsIHRhc3NvIGRpIHJlc2lzdGVuemEgZGkgb3JpZ2luZSBlIGlsIGNvc3RvIGluaXppYWxlIGRlbGwnb3JpZ2luZSBzYXJhbm5vIGFwcGxpY2F0aSBhIHBhcnRpcmUgZGFsbCdvcmlnaW5lIGRpIGlucHV0IGUgcG9pIHNwb3N0YW5kb3NpIGFsbGUgY2VsbGUgbm9uLW9yaWdpbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlZlcnNvIGwnb3JpZ2luZTwvc3Ryb25nPjogSWwgdGFzc28gZGkgcmVzaXN0ZW56YSBkaSBvcmlnaW5lIGUgaWwgY29zdG8gaW5pemlhbGUgZGVsbCdvcmlnaW5lIHNhcmFubm8gYXBwbGljYXRpIGEgcGFydGlyZSBkYSBjaWFzY3VuYSBjZWxsYSBub24tb3JpZ2luZSBlIHBvaSB0b3JuYW5kbyBpbmRpZXRybyBhbGwnb3JpZ2luZSBkaSBpbnB1dC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfVHJhdmVsLURpcmVjdGlvbl90YWc1QEBcIjogXCJTcGVjaWZpY2FyZSBsYSBwYXJvbGEgY2hpYXZlIDxzdHJvbmc+RGFsbCdvcmlnaW5lPC9zdHJvbmc+IG8gPHN0cm9uZz5WZXJzbyBsJ29yaWdpbmU8L3N0cm9uZz4sIGNoZSBzYXLDoCBhcHBsaWNhdGEgYSB0dXR0ZSBsZSBvcmlnaW5pLCBvcHB1cmUgc3BlY2lmaWNhcmUgdW4gY2FtcG8gbmVsIDxzdHJvbmc+UmFzdGVyIGRpIG9yaWdpbmU8L3N0cm9uZz4gY2hlIGNvbnRpZW5lIGxlIHBhcm9sZSBjaGlhdmUgcGVyIGlkZW50aWZpY2FyZSBsYSBkaXJlemlvbmUgZGkgdmlhZ2dpbyBwZXIgb2duaSBvcmlnaW5lLiBRdWVsIGNhbXBvIGRldmUgY29udGVuZXJlIGxhIHN0cmluZ2EgJHtGUk9NX1NPVVJDRX0gbyAke1RPX1NPVVJDRX0uXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX3ZlcnRpY2FsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkRlZmluaXNjZSBsYSByZWxhemlvbmUgdHJhIGlsIGZhdHRvcmUgZGkgY29zdG8gdmVydGljYWxlIGUgbCdhbmdvbG8gbW9iaWxlIHJlbGF0aXZvIHZlcnRpY2FsZSAoVlJNQSkuPC9wPjxwPkNpIHNvbm8gZGl2ZXJzaSBmYXR0b3JpIGNvbiBtb2RpZmljYXRvcmkgY2hlIGlkZW50aWZpY2FubyB1biBncmFmaWNvIGRpIGZhdHRvcmUgdmVydGljYWxlIGRlZmluaXRvLiBJbm9sdHJlLCDDqCBwb3NzaWJpbGUgdXRpbGl6emFyZSB1bmEgdGFiZWxsYSBwZXIgY3JlYXJlIHVuIGdyYWZpY28gcGVyc29uYWxpenphdG8uIEkgZ3JhZmljaSBzb25vIHV0aWxpenphdGkgcGVyIGlkZW50aWZpY2FyZSBpbCBmYXR0b3JlIHZlcnRpY2FsZSB1dGlsaXp6YXRvIG5lbCBjYWxjb2xvIGRlbCBjb3N0byB0b3RhbGUgZGVsbG8gc3Bvc3RhbWVudG8gaW4gdW5hIGNlbGxhIHZpY2luYS48L3A+PHA+TmVsbGUgc3BpZWdhemlvbmkgY2hlIHNlZ3Vvbm8sIHZlbmdvbm8gdXRpbGl6emF0aSBkdWUgYWNyb25pbWk6IFZGIGUgVlJNQS4gVkYgc3RhbmRzIGZvciB2ZXJ0aWNhbCBmYWN0b3IsIHdoaWNoIGRlZmluZXMgdGhlIHZlcnRpY2FsIGRpZmZpY3VsdHkgZW5jb3VudGVyZWQgaW4gbW92aW5nIGZyb20gb25lIGNlbGwgdG8gdGhlIG5leHQuIFZSTUEgc3RhIHBlciBhbmdvbG8gbW9iaWxlIHJlbGF0aXZvIHZlcnRpY2FsZSwgY2hlIGlkZW50aWZpY2EgbCdhbmdvbG8gZGkgcGVuZGVuemEgdHJhIGxhIGNlbGxhIEZST00sIG8gZGkgZWxhYm9yYXppb25lLCBlIGxhIGNlbGxhIFRPLjwvcD48cD48c3Ryb25nPkkgZmF0dG9yaSB2ZXJ0aWNhbGk8L3N0cm9uZz4gaW5jbHVkb25vIGkgc2VndWVudGk6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5hcmlvPC9zdHJvbmc+LS0gU3BlY2lmaWNhIGNoZSBzZSBpbCBWUk1BIMOoIG1hZ2dpb3JlIGRlbGwnYW5nb2xvIGRpIHRhZ2xpbyBiYXNzbyBlIG1pbm9yZSBkZWxsJ2FuZ29sbyBkaSB0YWdsaW8gYWx0bywgaWwgVkYgw6ggaW1wb3N0YXRvIGFsIHZhbG9yZSBhc3NvY2lhdG8gYWwgZmF0dG9yZSB6ZXJvOyBhbHRyaW1lbnRpLCDDqCBpbmZpbml0by48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4gLSBJbmRpY2EgY2hlIGxhIFZGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGRlbGxhIFZSTUEuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIHNpbW1ldHJpY2E8L3N0cm9uZz4tLSBTcGVjaWZpY2EgY2hlIGxhIFZGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGRlbGxhIFZSTUEgbmVsIGxhdG8gbmVnYXRpdm8gbyBwb3NpdGl2byBkZWxsYSBWUk1BLCByaXNwZXR0aXZhbWVudGUsIGUgbGUgZHVlIGZ1bnppb25pIGxpbmVhcmkgc29ubyBzaW1tZXRyaWNoZSByaXNwZXR0byBhbGwnYXNzZSBWRiAoeSkuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIGludmVyc2E8L3N0cm9uZz4gLSBJbmRpY2EgY2hlIGxhIFZGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGludmVyc2EgZGVsIFZSTUEuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIGludmVyc2Egc2ltbWV0cmljYTwvc3Ryb25nPi0tIEluZGljYSBjaGUgbGEgVkYgw6ggdW5hIGZ1bnppb25lIGxpbmVhcmUgaW52ZXJzYSBkZWwgVlJNQSBuZWwgbGF0byBuZWdhdGl2byBvIHBvc2l0aXZvIGRlbCBWUk1BLCByaXNwZXR0aXZhbWVudGUsIGUgbGUgZHVlIGZ1bnppb25pIGxpbmVhcmkgc29ubyBzaW1tZXRyaWNoZSByaXNwZXR0byBhbGwnYXNzZSBWRiAoeSkuPC9saT48bGk+PHN0cm9uZz5Db3M8L3N0cm9uZz4tLUlkZW50aWZpY2EgbGEgVkYgY29tZSBmdW56aW9uZSBiYXNhdGEgc3VsIGNvc2VubyBkZWwgVlJNQS48L2xpPjxsaT48c3Ryb25nPlNlYzwvc3Ryb25nPi0tSWRlbnRpZmljYSBsYSBWRiBjb21lIGZ1bnppb25lIGJhc2F0YSBzdWxsYSBzZWNhbnRlIGRlbCBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+Q29zLVNlYzwvc3Ryb25nPi0tU3BlY2lmaWNhIGNoZSBsYSBWRiDDqCBsYSBmdW56aW9uZSBiYXNhdGEgc3VsIGNvc2VubyBkZWwgVlJNQSBxdWFuZG8gaWwgVlJNQSDDqCBuZWdhdGl2byBlIGxhIGZ1bnppb25lIGJhc2F0YSBzdWxsYSBzZWNhbnRlIGRlbCBWUk1BIHF1YW5kbyBpbCBWUk1BIG5vbiDDqCBuZWdhdGl2by48L2xpPjxsaT48c3Ryb25nPlNlYy1Db3M8L3N0cm9uZz4tLVNwZWNpZmljYSBjaGUgbGEgVkYgw6ggbGEgZnVuemlvbmUgYmFzYXRhIHN1bGxhIHNlY2FudGUgZGVsIFZSTUEgcXVhbmRvIGlsIFZSTUEgw6ggbmVnYXRpdm8gZSBsYSBmdW56aW9uZSBiYXNhdGEgc3VsIGNvc2VubyBkZWwgVlJNQSBxdWFuZG8gaWwgVlJNQSBub24gw6ggbmVnYXRpdm8uIDwvbGk+PGxpPjxzdHJvbmc+VGFiZWxsYTwvc3Ryb25nPi0tSWRlbnRpZmljYSBjaGUgdmVycsOgIHV0aWxpenphdG8gdW4gZmlsZSB0YWJlbGxhIHBlciBkZWZpbmlyZSBpbCBncmFmaWNvIGRlbCBmYXR0b3JlIHZlcnRpY2FsZSBjaGUgdmllbmUgdXRpbGl6emF0byBwZXIgZGV0ZXJtaW5hcmUgbGUgVkYuPC9saT48L3VsPjxwPkkgbW9kaWZpY2F0b3JpIGRlbGxlIHBhcm9sZSBjaGlhdmUgdmVydGljYWxpIGluY2x1ZG9ubyBxdWFudG8gc2VndWU6IDwvcD48dWw+PGxpPjxzdHJvbmc+RmF0dG9yZSB6ZXJvPC9zdHJvbmc+LS0gU3RhYmlsaXNjZSBpbCBmYXR0b3JlIHZlcnRpY2FsZSB1c2F0byBxdWFuZG8gaWwgVlJNQSDDqCB6ZXJvLiBRdWVzdG8gZmF0dG9yZSBwb3NpemlvbmEgbOKAmWludGVyY2V0dGF6aW9uZSB5IGRlbGxhIGZ1bnppb25lIHNwZWNpZmljYXRhLiBQZXIgZGVmaW5pemlvbmUsIGlsIGZhdHRvcmUgemVybyBub24gw6ggYXBwbGljYWJpbGUgYWQgYWxjdW5hIGZ1bnppb25lIHZlcnRpY2FsZSB0cmlnb25vbWV0cmljYSAoQ09TLCBTRUMsIENPUy1TRUMgbyBTRUMtQ09TKS4gTCdpbnRlcmNldHRhIHkgw6ggZGVmaW5pdGEgZGEgcXVlc3RlIGZ1bnppb25pLjwvbGk+PGxpPjxzdHJvbmc+QW5nb2xvIGRpIHRhZ2xpbyBiYXNzbyA8L3N0cm9uZz4tIERlZmluaXNjZSBsJ2FuZ29sbyBWUk1BIGFsIGRpIHNvdHRvIGRlbCBxdWFsZSBsYSBWRiBzYXLDoCBpbXBvc3RhdGEgc3UgaW5maW5pdG8uPC9saT48bGk+PHN0cm9uZz5BbmdvbG8gZGkgdGFnbGlvIGFsdG88L3N0cm9uZz4gLSBEZWZpbmlzY2UgbCdhbmdvbG8gVlJNQSBhbCBkaSBzb3ByYSBkZWwgcXVhbGUgbGEgVkYgc2Fyw6AgaW1wb3N0YXRhIHN1IGluZmluaXRvLiA8L2xpPjxsaT48c3Ryb25nPlBlbmRlbnphPC9zdHJvbmc+IC0gU3RhYmlsaXNjZSBsYSBwZW5kZW56YSBkZWxsYSBsaW5lYSByZXR0YSB1c2F0YSBjb24gbGUgcGFyb2xlIGNoaWF2ZSA8c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4gZSA8c3Ryb25nPkxpbmVhcmUgSW52ZXJzYTwvc3Ryb25nPi1mYXR0b3JlIHZlcnRpY2FsZS4gTGEgcGVuZGVuemEgw6ggc3BlY2lmaWNhdGEgY29tZSB1bmEgZnJhemlvbmUgZGkgc2FsaXRhIHN1IGNvcnNhIChwZXIgZXNlbXBpbywgbGEgcGVuZGVuemEgZGVsIDQ1IHBlciBjZW50byDDqCAxLzQ1LCBjaGUgdmllbmUgaW1tZXNzYSBjb21lIDAsMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+Tm9tZSB0YWJlbGxhPC9zdHJvbmc+LS08L2xpPklkZW50aWZpY2EgaWwgbm9tZSBkZWxsYSB0YWJlbGxhIGNoZSBkZWZpbmlzY2UgbGEgVkYuPC91bD5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfVmVydGljYWwtUmFzdGVyX3RhZzBAQFwiOiBcIkRlZmluaXNjZSBsYSByZWxhemlvbmUgdHJhIGlsIGZhdHRvcmUgZGkgY29zdG8gdmVydGljYWxlIGUgbCdhbmdvbG8gZGkgbW92aW1lbnRvIHJlbGF0aXZvIHZlcnRpY2FsZSAoVlJNQSkuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1ZlcnRpY2FsLVJhc3Rlcl90YWcxQEBcIjogXCJJIHZhbG9yaSB2ZW5nb25vIHV0aWxpenphdGkgcGVyIGNhbGNvbGFyZSBsYSBwZW5kZW56YSB1c2F0YSBwZXIgaWRlbnRpZmljYXJlIGlsIGZhdHRvcmUgdmVydGljYWxlIHF1YW5kbyBzaSBwYXNzYSBkYSB1bmEgY2VsbGEgYWxsJ2FsdHJhLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcwQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIHNpbXVsYSBsJ2F1bWVudG8gZGVsbG8gc2ZvcnpvIHBlciBzdXBlcmFyZSBpIGNvc3RpIG1hbiBtYW5vIGNoZSBpbCBjb3N0byBjdW11bGF0aXZvIGF1bWVudGEuIFZpZW5lIHVzYXRvIHBlciBtb2RlbGxhcmUgbCdhZmZhdGljYW1lbnRvIGRlbCB2aWFnZ2lhdG9yZS4gSWwgY29zdG8gY3VtdWxhdGl2byBjcmVzY2VudGUgcGVyIHJhZ2dpdW5nZXJlIHVuYSBjZWxsYSB2aWVuZSBtb2x0aXBsaWNhdG8gcGVyIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEgZSBhZ2dpdW50byBhbCBjb3N0byBwZXIgbG8gc3Bvc3RhbWVudG8gbmVsbGEgY2VsbGEgY29uc2VjdXRpdmEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzFAQFwiOiBcIlNpIHRyYXR0YSBkaSB1bmEgdmVyc2lvbmUgbW9kaWZpY2F0YSBkaSB1bmEgZm9ybXVsYSBjb21wb3N0YSBkaSB0YXNzbyBkaSBpbnRlcmVzc2UgY2hlIHZpZW5lIHV0aWxpenphdGEgcGVyIGNhbGNvbGFyZSBpbCBjb3N0byBhcHBhcmVudGUgZGkgc3Bvc3RhbWVudG8gYXR0cmF2ZXJzbyB1bmEgY2VsbGEuIENvbiBsJ2F1bWVudGFyZSBkZWwgdmFsb3JlIGRlbCB0YXNzbyBkaSByZXNpc3RlbnphLCBhdW1lbnRhIGFuY2hlIGlsIGNvc3RvIGRlbGxlIGNlbGxlIHZpc2l0YXRlIGluIHNlZ3VpdG8uIFF1YW50byBtYWdnaW9yZSDDqCBpbCB0YXNzbyBkaSByZXNpc3RlbnphLCB0YW50byBwacO5IGFsdG8gc2Fyw6AgaWwgY29zdG8gcGVyIHJhZ2dpdW5nZXJlIGxhIGNlbGxhIHN1Y2Nlc3NpdmEsIGNoZSDDqCByZXNpc3RlbnRlIGEgb2duaSBtb3ZpbWVudG8gY29uc2VjdXRpdm8uIERhbCBtb21lbnRvIGNoZSBpbCB0YXNzbyBkaSByZXNpc3RlbnphIMOoIHNpbWlsZSBhIHVuIHRhc3NvIGNvbXBvc3RvIGUgZ2VuZXJhbG1lbnRlIGkgdmFsb3JpIGRpIGNvc3RvIGN1bXVsYXRpdm8gc29ubyBtb2x0byBncmFuZGksIHNpIGNvbnNpZ2xpYW5vIHRhc3NpIGRpIHJlc2lzdGVuemEgcGljY29saSwgY29tZSAwLDAwNSBvIGFuY2hlIG1lbm8sIGEgc2Vjb25kYSBkZWkgdmFsb3JpIGRpIGNvc3RvIGN1bXVsYXRpdmkuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIklsIHZhbG9yZSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBkaSB6ZXJvLiBMYSBjYXBhY2l0w6AgcHJlZGVmaW5pdGEgw6ggZmlubyBhbCBib3JkbyBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9DYXBhY2l0eV90YWcwQEBcIjogXCJEZWZpbmlzY2UgbGEgY2FwYWNpdMOgIGRpIGNvc3RvIHBlciBpbCB2aWFnZ2lhdG9yZSByZWxhdGl2YSBhIHVuJ29yaWdpbmUuIEkgY2FsY29saSBkZWwgY29zdG8gY29udGludWFubyBwZXIgb2duaSBvcmlnaW5lIGZpbmNow6kgbm9uIHNpIHJhZ2dpdW5nZSBsYSBjYXBhY2l0w6Agc3BlY2lmaWNhdGEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fQ2FwYWNpdHlfdGFnMUBAXCI6IFwiSWwgdmFsb3JlIGRldmUgZXNzZXJlIG1hZ2dpb3JlIGRpIHplcm8uIExhIGNhcGFjaXTDoCBwcmVkZWZpbml0YSDDqCBmaW5vIGFsIGJvcmRvIGRlbCByYXN0ZXIgZGkgb3V0cHV0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX0Nvc3QtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBkaSBpbnB1dCBvYmJsaWdhdG9yaW8gY2hlIGRlZmluaXNjZSBpbCBjb3N0byBvIGwnaW1wZWRlbnphIGRlbGxvIHNwb3N0YW1lbnRvIHBsYW5pbWV0cmljbyBhdHRyYXZlcnNvIGNpYXNjdW5hIGNlbGxhLiBJbCB2YWxvcmUgYSBvZ25pIHBvc2l6aW9uZSBkZWxsYSBjZWxsYSByYXBwcmVzZW50YSBsYSBkaXN0YW56YSBkaSBjb3N0byBwZXIgdW5pdMOgIHBlciBsJ2F0dHJhdmVyc2FtZW50byBkZWxsYSBzdGVzc2EuIE9nbmkgdmFsb3JlIGRpIHBvc2l6aW9uZSBkaSB1bmEgY2VsbGEgdmllbmUgbW9sdGlwbGljYXRvIHBlciBsYSByaXNvbHV6aW9uZSBkZWxsYSBjZWxsYSBlIGNvbXBlbnNhIGlub2x0cmUgaWwgbW92aW1lbnRvIGRpYWdvbmFsZSBwZXIgb3R0ZW5lcmUgaWwgY29zdG8gdG90YWxlIGRlbGwnYXR0cmF2ZXJzYW1lbnRvIGRlbGxhIHN0ZXNzYS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9Db3N0LVJhc3Rlcl90YWcxQEBcIjogXCJJIHZhbG9yaSBkZWwgPHN0cm9uZz5SYXN0ZXIgZGkgY29zdG88L3N0cm9uZz4gcG9zc29ubyBlc3NlcmUgYSBudW1lcm8gaW50ZXJvIG8gYSB2aXJnb2xhIG1vYmlsZSwgbWEgbm9uIHBvc3Nvbm8gZXNzZXJlIG5lZ2F0aXZpIG8gemVyby5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9ob3Jpem9udGFsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkRlZmluaXNjZSBsYSByZWxhemlvbmUgdHJhIGlsIGZhdHRvcmUgZGkgY29zdG8gb3JpenpvbnRhbGUgZSBsJ2FuZ29sbyBtb2JpbGUgcmVsYXRpdm8gb3JpenpvbnRhbGUgKEhSTUEpLjwvcD48cD5DaSBzb25vIGRpdmVyc2kgZmF0dG9yaSBjb24gbW9kaWZpY2F0b3JpIGNoZSBpZGVudGlmaWNhbm8gdW4gZ3JhZmljbyBkZWwgZmF0dG9yZSB2ZXJ0aWNhbGUgZGVmaW5pdG8uIElub2x0cmUsIMOoIHBvc3NpYmlsZSB1dGlsaXp6YXJlIHVuYSB0YWJlbGxhIHBlciBjcmVhcmUgdW4gZ3JhZmljbyBwZXJzb25hbGl6emF0by4gSSBncmFmaWNpIHNvbm8gdXRpbGl6emF0aSBwZXIgaWRlbnRpZmljYXJlIGlsIGZhdHRvcmUgdmVydGljYWxlIHV0aWxpenphdG8gbmVsIGNhbGNvbG8gZGVsIGNvc3RvIHRvdGFsZSBkZWxsbyBzcG9zdGFtZW50byBpbiB1bmEgY2VsbGEgdmljaW5hLjwvcD48cD5OZWxsZSBzcGllZ2F6aW9uaSBjaGUgc2VndW9ubywgdmVuZ29ubyB1dGlsaXp6YXRpIGR1ZSBhY3JvbmltaTogSEYgZSBIUk1BLiBIRiBzdGFuZHMgZm9yIGhvcml6b250YWwgZmFjdG9yLCB3aGljaCBkZWZpbmVzIHRoZSBob3Jpem9udGFsIGRpZmZpY3VsdHkgZW5jb3VudGVyZWQgd2hlbiBtb3ZpbmcgZnJvbSBvbmUgY2VsbCB0byB0aGUgbmV4dC4gSFJNQSBzdGEgcGVyIGhvcml6b250YWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlLCBjaGUgaWRlbnRpZmljYSBsJ2FuZ29sbyB0cmEgbGEgZGlyZXppb25lIG9yaXp6b250YWxlIGRhIHVuYSBjZWxsYSBlIGxhIGRpcmV6aW9uZSBkaSBtb3ZpbWVudG8uIEkgdGlwaSBkaSA8L3A+PHA+PHN0cm9uZz5mYXR0b3JpIG9yaXp6b250YWxpPC9zdHJvbmc+IGluY2x1ZG9ubyBpIHNlZ3VlbnRpOiA8L3A+PHVsPjxsaT48c3Ryb25nPkJpbmFyaW88L3N0cm9uZz4tLSBJbmRpY2EgY2hlIHNlIGwnSFJNQSDDqCBpbmZlcmlvcmUgYWxsJ2FuZ29sbyBkaSB0YWdsaW8sIGwnSEYgw6ggaW1wb3N0YXRvIGFsIHZhbG9yZSBhc3NvY2lhdG8gYWwgZmF0dG9yZSB6ZXJvOyBhbHRyaW1lbnRpLCDDqCBpbmZpbml0by48L2xpPjxsaT48c3Ryb25nPkF2YW50aTwvc3Ryb25nPiAtLSBTdGFiaWxpc2NlIGNoZSDDqCBwZXJtZXNzbyBzb2xvIGlsIG1vdmltZW50byBpbiBhdmFudGkuIEwnSFJNQSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBvIHVndWFsZSBhIDAgZSBpbmZlcmlvcmUgYSA5MCBncmFkaSAoMCAmbHQ7PSBIUk1BICZsdDs5MCkuIFNlIGwnSFJNQSDDqCBzdXBlcmlvcmUgYSAwIGUgaW5mZXJpb3JlIGEgNDUgZ3JhZGksIGwnSEYgcGVyIGxhIGNlbGxhIHZpZW5lIGltcG9zdGF0byBzdWwgdmFsb3JlIGFzc29jaWF0byBhbCBmYXR0b3JlIHplcm8uIFNlIGwnSFJNQSDDqCBzdXBlcmlvcmUgbyBwYXJpIGEgNDUgZ3JhZGksIHZpZW5lIHV0aWxpenphdG8gaWwgdmFsb3JlIGRlbCBtb2RpZmljYXRvcmUgZGVsIHZhbG9yZSBsYXRlcmFsZS4gTCdIRiBwZXIgcXVhbHNpYXNpIHZhbG9yZSBIUk1BIHVndWFsZSBvIHN1cGVyaW9yZSBhIDkwIGdyYWRpIMOoIGltcG9zdGF0byBzdSBpbmZpbml0by48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4tLVNwZWNpZmljYSBjaGUgbCdIRiDDqCB1bmEgZnVuemlvbmUgbGluZWFyZSBkZWxsJ0hSTUEuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIGludmVyc2E8L3N0cm9uZz4tLVNwZWNpZmljYSBjaGUgbCdIRiDDqCB1bmEgZnVuemlvbmUgbGluZWFyZSBpbnZlcnNhIGRlbGwnSFJNQS48L2xpPjxsaT48c3Ryb25nPlRhYmVsbGE8L3N0cm9uZz4tIElkZW50aWZpY2EgY2hlIHVuIGZpbGUgdGFiZWxsYSBzYXLDoCB1c2F0byBwZXIgZGVmaW5pcmUgaWwgZ3JhZmljbyBkZWkgZmF0dG9yaSBvcml6em9udGFsaSB1c2F0byBwZXIgZGV0ZXJtaW5hcmUgZ2xpIEhGLjwvbGk+PC91bD48cD5JIG1vZGlmaWNhdG9yaSBkZWkgZmF0dG9yaSBvcml6em9udGFsaSBpbmNsdWRvbm8gcXVhbnRvIHNlZ3VlOiA8L3A+PHVsPjxsaT48c3Ryb25nPkZhdHRvcmUgemVybzwvc3Ryb25nPi0tIElsIGZhdHRvcmUgb3JpenpvbnRhbGUgZGEgdXNhcmUgcXVhbmRvIGwnSFJNQSDDqCB6ZXJvLiBRdWVzdG8gZmF0dG9yZSBwb3NpemlvbmEgbCdpbnRlcmNldHRhIHkgcGVyIHF1YWxzaWFzaSBmdW56aW9uZSBmYXR0b3JlIG9yaXp6b250YWxlLjwvbGk+PGxpPjxzdHJvbmc+QW5nb2xvIGRpIHRhZ2xpbzwvc3Ryb25nPi0tRGVmaW5pc2NlIGwnYW5nb2xvIEhSTUEgb2x0cmUgaWwgcXVhbGUgbCdIRiBzYXLDoCBpbXBvc3RhdG8gc3UgaW5maW5pdG8uPC9saT48bGk+PHN0cm9uZz5QZW5kZW56YTwvc3Ryb25nPi0tIFN0YWJpbGlzY2UgbGEgcGVuZGVuemEgZGVsbGEgbGluZWEgcmV0dGEgdXNhdGEgY29uIGxlIHBhcm9sZSBjaGlhdmUgZmF0dG9yZSBvcml6em9udGFsZSA8c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4gZSA8c3Ryb25nPkxpbmVhcmUgaW52ZXJzYTwvc3Ryb25nPi4gTGEgcGVuZGVuemEgw6ggc3BlY2lmaWNhdGEgY29tZSB1bmEgZnJhemlvbmUgZGkgc2FsaXRhIHN1IGNvcnNhIChwZXIgZXNlbXBpbywgbGEgcGVuZGVuemEgZGVsIDQ1JSDDqCAxLzQ1LCBjaGUgdmllbmUgaW1tZXNzYSBjb21lIDAsMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+U2lkZSB2YWx1ZTwvc3Ryb25nPi0tIFN0YWJpbGlzY2UgbCdIRiBxdWFuZG8gbCdIUk1BIMOoIG1hZ2dpb3JlIG8gdWd1YWxlIGEgNDUgZ3JhZGkgZSBtaW5vcmUgZGkgOTAgZ3JhZGkgcXVhbmRvIHZpZW5lIHNwZWNpZmljYXRhIGxhIHBhcm9sYSBjaGlhdmUgRmF0dG9yZSBvcml6em9udGFsZSA8c3Ryb25nPmF2YW50aTwvc3Ryb25nPi48L2xpPjxsaT48c3Ryb25nPk5vbWUgZGVsbGEgdGFiZWxsYTwvc3Ryb25nPiAtIElkZW50aWZpY2EgaWwgbm9tZSBkZWxsYSB0YWJlbGxhIGNoZSBkZWZpbmlzY2UgbCdIRi48L2xpPjwvdWw+XCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fSG9yaXpvbnRhbC1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGNoZSBkZWZpbmlzY2UgbGEgZGlyZXppb25lIG9yaXp6b250YWxlIHN1IG9nbmkgY2VsbGEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fSG9yaXpvbnRhbC1SYXN0ZXJfdGFnMUBAXCI6IFwiSSB2YWxvcmkgc3VsIHJhc3RlciBkZXZvbm8gZXNzZXJlIG51bWVyaSBpbnRlcmkgY29tcHJlc2kgdHJhIDAgZSAzNjAgY29uIDAgZ3JhZGkgY2hlIGluZGljYSBpbCBub3JkIG8gdmVyc28gbGEgcGFydGUgc3VwZXJpb3JlIGRlbGxvIHNjaGVybW8gZSBjb24gYXVtZW50byBpbiBzZW5zbyBvcmFyaW8uIEFsbGUgYXJlZSBwaWFuZSBkZXZlIGVzc2VyZSBmb3JuaXRvIHVuIHZhbG9yZSBkaSAtMS4gSSB2YWxvcmkgaW4gb2duaSBwb3NpemlvbmUgdmVuZ29ubyB1dGlsaXp6YXRpIGluc2llbWUgYSA8c3Ryb25nPkZhdHRvcmUgb3JpenpvbnRhbGU8L3N0cm9uZz4gcGVyIGRldGVybWluYXJlIGkgY29zdGkgb3JpenpvbnRhbGkgZHVyYW50ZSBsbyBzcG9zdGFtZW50byBkYSB1bmEgY2VsbGEgYSBxdWVsbGUgdmljaW5lLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiTGEgc29nbGlhIGNoZSBpIHZhbG9yaSBkaSBjb3N0byBjdW11bGF0aXZpIG5vbiBwb3Nzb25vIHN1cGVyYXJlLiBTZSB1bmEgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBzdXBlcmEgcXVlc3RvIHZhbG9yZSwgaWwgdmFsb3JlIGRpIG91dHB1dCBwZXIgbGEgcG9zaXppb25lIGRlbGxhIGNlbGxhIHNhcsOgIE5vRGF0YS4gTGEgZGlzdGFuemEgbWFzc2ltYSBkZWZpbmlzY2UgbCdlc3RlbnNpb25lIHBlciBsYSBxdWFsZSBzaSBjYWxjb2xhbm8gbGUgZGlzdGFuemUgZGkgY29zdG8gY3VtdWxhdGl2ZS4gTGEgZGlzdGFuemEgcHJlZGVmaW5pdGEgw6ggZmlubyBhbGwnZXN0ZW5zaW9uZSBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzBAQFwiOiBcIlVuIG1vbHRpcGxpY2F0b3JlIGRhIGFwcGxpY2FyZSBhaSB2YWxvcmkgZGkgY29zdG8uXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcxQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIGNvbnNlbnRlIGlsIGNvbnRyb2xsbyBkZWxsYSBtb2RhbGl0w6AgZGkgc3Bvc3RhbWVudG8gbyBkZWxsYSBncmFuZGV6emEgYWxsJ29yaWdpbmUuIE1hZ2dpb3JlIMOoIGlsIG1vbHRpcGxpY2F0b3JlLCBtYWdnaW9yZSDDqCBpbCBjb3N0byBwZXIgbG8gc3Bvc3RhbWVudG8gYXR0cmF2ZXJzbyBvZ25pIGNlbGxhLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMkBAXCI6IFwiSSB2YWxvcmkgZGV2b25vIGVzc2VyZSBtYWdnaW9yaSBkaSB6ZXJvLiBMJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YSDDqCAxLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnM0BAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHBlciBxdWVzdG8gcGFyYW1ldHJvIHVuIHZhbG9yZSBudW1lcmljbyAoZG9wcGlvKSBvIHVuIGNhbXBvIGRhbCA8c3Ryb25nPlJhc3RlciBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1NvdXJjZS1GaWVsZF90YWcwQEBcIjogXCJJbCBjYW1wbyB1c2F0byBwZXIgYXNzZWduYXJlIHZhbG9yaSBhbGxlIHBvc2l6aW9uaSBkaSBvcmlnaW5lLiBEZXZlIGVzc2VyZSBkaSB0aXBvIG51bWVybyBpbnRlcm8uIFNlIGlsIDxzdHJvbmc+UmFzdGVyIHZhbG9yZTwvc3Ryb25nPiDDqCBzdGF0byBpbXBvc3RhdG8sIGkgdmFsb3JpIGRpIHF1ZWxsJ2lucHV0IGF2cmFubm8gcHJpb3JpdMOgIHN1IHF1YWx1bnF1ZSBpbXBvc3RhemlvbmUgZGkgPHN0cm9uZz5DYW1wbyBkaSBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1NvdXJjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IG9iYmxpZ2F0b3JpbyBwZXIgbGUgcG9zaXppb25pIGRpIG9yaWdpbmUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fU291cmNlLVJhc3Rlcl90YWcxQEBcIjogXCLDiCB1biByYXN0ZXIgY2hlIGlkZW50aWZpY2EgbGUgY2VsbGUgbyBsZSBwb3NpemlvbmkgZGFsbGUgcXVhbGkgc2kgY2FsY29sYSBsYSBkaXN0YW56YSBkaSBjb3N0byBtaW5pbWEgY3VtdWxhdGl2YSBwZXIgb2duaSBwb3NpemlvbmUgZGkgY2VsbGEgZGkgb3V0cHV0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1NvdXJjZS1SYXN0ZXJfdGFnMkBAXCI6IFwiUHXDsiBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBvIHVuIHZhbG9yZSBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiSWwgY29zdG8gZGkgaW5pemlvIGNvbiBpbCBxdWFsZSBhdnZpYXJlIGkgY2FsY29saSBkZWwgY29zdG8uIFF1ZXN0byBwYXJhbWV0cm8gY29uc2VudGUgZGkgc3BlY2lmaWNhcmUgaWwgY29zdG8gZmlzc28gYXNzb2NpYXRvIGFkIHVuJ29yaWdpbmUuIEludmVjZSBkaSBpbml6aWFyZSBjb24gdW4gY29zdG8gMCwgbCdhbGdvcml0bW8gZGVsIGNvc3RvIGluaXppZXLDoCBjb24gaWwgdmFsb3JlIHNwZWNpZmljYXRvLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1N0YXJ0LUNvc3RfdGFnMUBAXCI6IFwiSWwgdmFsb3JlIGRldmUgZXNzZXJlIHBhcmkgbyBzdXBlcmlvcmUgYSB6ZXJvLiBMJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YSDDqCAwLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1N1cmZhY2UtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBjaGUgZGVmaW5pc2NlIGkgdmFsb3JpIGRpIGVsZXZhemlvbmUgc3Ugb2duaSBwb3NpemlvbmUgZGVsbGEgY2VsbGEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fU3VyZmFjZS1SYXN0ZXJfdGFnMUBAXCI6IFwiSSB2YWxvcmkgdmVuZ29ubyB1dGlsaXp6YXRpIHBlciBjYWxjb2xhcmUgbOKAmWVmZmV0dGl2YSBkaXN0YW56YSBkZWxsYSBzdXBlcmZpY2llIHBlcmNvcnNhIGR1cmFudGUgaWwgcGFzc2FnZ2lvIHRyYSBjZWxsZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzBAQFwiOiBcIkRlZmluaXNjZSBsYSBkaXJlemlvbmUgZGVsIHZpYWdnaWF0b3JlIHF1YW5kbyBzaSBhcHBsaWNhIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEgZGVsbCdvcmlnaW5lIGUgaWwgY29zdG8gaW5pemlhbGUgZGVsbCdvcmlnaW5lLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1RyYXZlbC1EaXJlY3Rpb25fdGFnMUBAXCI6IFwiPHN0cm9uZz5EYWxsJ29yaWdpbmU8L3N0cm9uZz46IElsIHRhc3NvIGRpIHJlc2lzdGVuemEgZGkgb3JpZ2luZSBlIGlsIGNvc3RvIGluaXppYWxlIGRlbGwnb3JpZ2luZSBzYXJhbm5vIGFwcGxpY2F0aSBhIHBhcnRpcmUgZGFsbCdvcmlnaW5lIGRpIGlucHV0IGUgcG9pIHNwb3N0YW5kb3NpIGFsbGUgY2VsbGUgbm9uLW9yaWdpbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzNAQFwiOiBcIjxzdHJvbmc+VmVyc28gbCdvcmlnaW5lPC9zdHJvbmc+OiBJbCB0YXNzbyBkaSByZXNpc3RlbnphIGRpIG9yaWdpbmUgZSBpbCBjb3N0byBpbml6aWFsZSBkZWxsJ29yaWdpbmUgc2FyYW5ubyBhcHBsaWNhdGkgYSBwYXJ0aXJlIGRhIGNpYXNjdW5hIGNlbGxhIG5vbi1vcmlnaW5lIGUgcG9pIHRvcm5hbmRvIGluZGlldHJvIGFsbCdvcmlnaW5lIGRpIGlucHV0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1RyYXZlbC1EaXJlY3Rpb25fdGFnNUBAXCI6IFwiU3BlY2lmaWNhcmUgbGEgcGFyb2xhIGNoaWF2ZSA8c3Ryb25nPkRhbGwnb3JpZ2luZTwvc3Ryb25nPiBvIDxzdHJvbmc+VmVyc28gbCdvcmlnaW5lPC9zdHJvbmc+LCBjaGUgc2Fyw6AgYXBwbGljYXRhIGEgdHV0dGUgbGUgb3JpZ2luaSwgb3BwdXJlIHNwZWNpZmljYXJlIHVuIGNhbXBvIG5lbCA8c3Ryb25nPlJhc3RlciBkaSBvcmlnaW5lPC9zdHJvbmc+IGNoZSBjb250aWVuZSBsZSBwYXJvbGUgY2hpYXZlIHBlciBpZGVudGlmaWNhcmUgbGEgZGlyZXppb25lIGRpIHZpYWdnaW8gcGVyIG9nbmkgb3JpZ2luZS4gUXVlbCBjYW1wbyBkZXZlIGNvbnRlbmVyZSBsYSBzdHJpbmdhICR7RlJPTV9TT1VSQ0V9IG8gJHtUT19TT1VSQ0V9LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1ZhbHVlLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgYSBudW1lcm8gaW50ZXJvIGNoZSBpZGVudGlmaWNhIGkgdmFsb3JpIGRpIHpvbmEgZGEgdXNhcmUgcGVyIG9nbmkgcG9zaXppb25lIGRpIG9yaWdpbmUgZGkgaW5wdXQuIFBlciBvZ25pIGNlbGxhIGRpIHBvc2l6aW9uZSBkaSBvcmlnaW5lLCBpbCB2YWxvcmUgZGVmaW5pdG8gZGFsIDxzdHJvbmc+UmFzdGVyIGRpIHZhbG9yaTwvc3Ryb25nPiBzYXLDoCBhc3NlZ25hdG8gYSB0dXR0ZSBsZSBjZWxsZSBhc3NlZ25hdGUgYWxsYSBwb3NpemlvbmUgZGkgb3JpZ2luZSBwZXIgaWwgY2FsY29sby4gSWwgPHN0cm9uZz5SYXN0ZXIgZGkgdmFsb3JpPC9zdHJvbmc+IGF2csOgIHByaW9yaXTDoCBzdSBxdWFsdW5xdWUgaW1wb3N0YXppb25lIHBlciBpbCA8c3Ryb25nPkNhbXBvIGRpIG9yaWdpbmU8L3N0cm9uZz4uXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fdmVydGljYWxmYWN0b3JfdGFnMEBAXCI6IFwiPHA+RGVmaW5pc2NlIGxhIHJlbGF6aW9uZSB0cmEgaWwgZmF0dG9yZSBkaSBjb3N0byB2ZXJ0aWNhbGUgZSBsJ2FuZ29sbyBtb2JpbGUgcmVsYXRpdm8gdmVydGljYWxlIChWUk1BKS48L3A+PHA+Q2kgc29ubyBkaXZlcnNpIGZhdHRvcmkgY29uIG1vZGlmaWNhdG9yaSBjaGUgaWRlbnRpZmljYW5vIHVuIGdyYWZpY28gZGkgZmF0dG9yZSB2ZXJ0aWNhbGUgZGVmaW5pdG8uIElub2x0cmUsIMOoIHBvc3NpYmlsZSB1dGlsaXp6YXJlIHVuYSB0YWJlbGxhIHBlciBjcmVhcmUgdW4gZ3JhZmljbyBwZXJzb25hbGl6emF0by4gSSBncmFmaWNpIHNvbm8gdXRpbGl6emF0aSBwZXIgaWRlbnRpZmljYXJlIGlsIGZhdHRvcmUgdmVydGljYWxlIHV0aWxpenphdG8gbmVsIGNhbGNvbG8gZGVsIGNvc3RvIHRvdGFsZSBkZWxsbyBzcG9zdGFtZW50byBpbiB1bmEgY2VsbGEgdmljaW5hLjwvcD48cD5OZWxsZSBzcGllZ2F6aW9uaSBjaGUgc2VndW9ubywgdmVuZ29ubyB1dGlsaXp6YXRpIGR1ZSBhY3JvbmltaTogVkYgZSBWUk1BLiBWRiBzdGFuZHMgZm9yIHZlcnRpY2FsIGZhY3Rvciwgd2hpY2ggZGVmaW5lcyB0aGUgdmVydGljYWwgZGlmZmljdWx0eSBlbmNvdW50ZXJlZCBpbiBtb3ZpbmcgZnJvbSBvbmUgY2VsbCB0byB0aGUgbmV4dC4gVlJNQSBzdGEgcGVyIGFuZ29sbyBtb2JpbGUgcmVsYXRpdm8gdmVydGljYWxlLCBjaGUgaWRlbnRpZmljYSBsJ2FuZ29sbyBkaSBwZW5kZW56YSB0cmEgbGEgY2VsbGEgRlJPTSwgbyBkaSBlbGFib3JhemlvbmUsIGUgbGEgY2VsbGEgVE8uPC9wPjxwPjxzdHJvbmc+SSBmYXR0b3JpIHZlcnRpY2FsaTwvc3Ryb25nPiBpbmNsdWRvbm8gaSBzZWd1ZW50aTo8L3A+PHVsPjxsaT48c3Ryb25nPkJpbmFyaW88L3N0cm9uZz4tLSBTcGVjaWZpY2EgY2hlIHNlIGlsIFZSTUEgw6ggbWFnZ2lvcmUgZGVsbCdhbmdvbG8gZGkgdGFnbGlvIGJhc3NvIGUgbWlub3JlIGRlbGwnYW5nb2xvIGRpIHRhZ2xpbyBhbHRvLCBpbCBWRiDDqCBpbXBvc3RhdG8gYWwgdmFsb3JlIGFzc29jaWF0byBhbCBmYXR0b3JlIHplcm87IGFsdHJpbWVudGksIMOoIGluZmluaXRvLjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyZTwvc3Ryb25nPiAtIEluZGljYSBjaGUgbGEgVkYgw6ggdW5hIGZ1bnppb25lIGxpbmVhcmUgZGVsbGEgVlJNQS48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmUgc2ltbWV0cmljYTwvc3Ryb25nPi0tIFNwZWNpZmljYSBjaGUgbGEgVkYgw6ggdW5hIGZ1bnppb25lIGxpbmVhcmUgZGVsbGEgVlJNQSBuZWwgbGF0byBuZWdhdGl2byBvIHBvc2l0aXZvIGRlbGxhIFZSTUEsIHJpc3BldHRpdmFtZW50ZSwgZSBsZSBkdWUgZnVuemlvbmkgbGluZWFyaSBzb25vIHNpbW1ldHJpY2hlIHJpc3BldHRvIGFsbCdhc3NlIFZGICh5KS48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmUgaW52ZXJzYTwvc3Ryb25nPiAtIEluZGljYSBjaGUgbGEgVkYgw6ggdW5hIGZ1bnppb25lIGxpbmVhcmUgaW52ZXJzYSBkZWwgVlJNQS48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmUgaW52ZXJzYSBzaW1tZXRyaWNhPC9zdHJvbmc+LS0gSW5kaWNhIGNoZSBsYSBWRiDDqCB1bmEgZnVuemlvbmUgbGluZWFyZSBpbnZlcnNhIGRlbCBWUk1BIG5lbCBsYXRvIG5lZ2F0aXZvIG8gcG9zaXRpdm8gZGVsIFZSTUEsIHJpc3BldHRpdmFtZW50ZSwgZSBsZSBkdWUgZnVuemlvbmkgbGluZWFyaSBzb25vIHNpbW1ldHJpY2hlIHJpc3BldHRvIGFsbCdhc3NlIFZGICh5KS48L2xpPjxsaT48c3Ryb25nPkNvczwvc3Ryb25nPi0tSWRlbnRpZmljYSBsYSBWRiBjb21lIGZ1bnppb25lIGJhc2F0YSBzdWwgY29zZW5vIGRlbCBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+U2VjPC9zdHJvbmc+LS1JZGVudGlmaWNhIGxhIFZGIGNvbWUgZnVuemlvbmUgYmFzYXRhIHN1bGxhIHNlY2FudGUgZGVsIFZSTUEuPC9saT48bGk+PHN0cm9uZz5Db3MtU2VjPC9zdHJvbmc+LS1TcGVjaWZpY2EgY2hlIGxhIFZGIMOoIGxhIGZ1bnppb25lIGJhc2F0YSBzdWwgY29zZW5vIGRlbCBWUk1BIHF1YW5kbyBpbCBWUk1BIMOoIG5lZ2F0aXZvIGUgbGEgZnVuemlvbmUgYmFzYXRhIHN1bGxhIHNlY2FudGUgZGVsIFZSTUEgcXVhbmRvIGlsIFZSTUEgbm9uIMOoIG5lZ2F0aXZvLjwvbGk+PGxpPjxzdHJvbmc+U2VjLUNvczwvc3Ryb25nPi0tU3BlY2lmaWNhIGNoZSBsYSBWRiDDqCBsYSBmdW56aW9uZSBiYXNhdGEgc3VsbGEgc2VjYW50ZSBkZWwgVlJNQSBxdWFuZG8gaWwgVlJNQSDDqCBuZWdhdGl2byBlIGxhIGZ1bnppb25lIGJhc2F0YSBzdWwgY29zZW5vIGRlbCBWUk1BIHF1YW5kbyBpbCBWUk1BIG5vbiDDqCBuZWdhdGl2by4gPC9saT48bGk+PHN0cm9uZz5UYWJlbGxhPC9zdHJvbmc+LS1JZGVudGlmaWNhIGNoZSB2ZXJyw6AgdXRpbGl6emF0byB1biBmaWxlIHRhYmVsbGEgcGVyIGRlZmluaXJlIGlsIGdyYWZpY28gZGVsIGZhdHRvcmUgdmVydGljYWxlIGNoZSB2aWVuZSB1dGlsaXp6YXRvIHBlciBkZXRlcm1pbmFyZSBsZSBWRi48L2xpPjwvdWw+PHA+SSBtb2RpZmljYXRvcmkgZGVsbGUgcGFyb2xlIGNoaWF2ZSB2ZXJ0aWNhbGkgaW5jbHVkb25vIHF1YW50byBzZWd1ZTogPC9wPjx1bD48bGk+PHN0cm9uZz5GYXR0b3JlIHplcm88L3N0cm9uZz4tLSBTdGFiaWxpc2NlIGlsIGZhdHRvcmUgdmVydGljYWxlIHVzYXRvIHF1YW5kbyBpbCBWUk1BIMOoIHplcm8uIFF1ZXN0byBmYXR0b3JlIHBvc2l6aW9uYSBs4oCZaW50ZXJjZXR0YXppb25lIHkgZGVsbGEgZnVuemlvbmUgc3BlY2lmaWNhdGEuIFBlciBkZWZpbml6aW9uZSwgaWwgZmF0dG9yZSB6ZXJvIG5vbiDDqCBhcHBsaWNhYmlsZSBhZCBhbGN1bmEgZnVuemlvbmUgdmVydGljYWxlIHRyaWdvbm9tZXRyaWNhIChDT1MsIFNFQywgQ09TLVNFQyBvIFNFQy1DT1MpLiBMJ2ludGVyY2V0dGEgeSDDqCBkZWZpbml0YSBkYSBxdWVzdGUgZnVuemlvbmkuPC9saT48bGk+PHN0cm9uZz5BbmdvbG8gZGkgdGFnbGlvIGJhc3NvIDwvc3Ryb25nPi0gRGVmaW5pc2NlIGwnYW5nb2xvIFZSTUEgYWwgZGkgc290dG8gZGVsIHF1YWxlIGxhIFZGIHNhcsOgIGltcG9zdGF0YSBzdSBpbmZpbml0by48L2xpPjxsaT48c3Ryb25nPkFuZ29sbyBkaSB0YWdsaW8gYWx0bzwvc3Ryb25nPiAtIERlZmluaXNjZSBsJ2FuZ29sbyBWUk1BIGFsIGRpIHNvcHJhIGRlbCBxdWFsZSBsYSBWRiBzYXLDoCBpbXBvc3RhdGEgc3UgaW5maW5pdG8uIDwvbGk+PGxpPjxzdHJvbmc+UGVuZGVuemE8L3N0cm9uZz4gLSBTdGFiaWxpc2NlIGxhIHBlbmRlbnphIGRlbGxhIGxpbmVhIHJldHRhIHVzYXRhIGNvbiBsZSBwYXJvbGUgY2hpYXZlIDxzdHJvbmc+TGluZWFyZTwvc3Ryb25nPiBlIDxzdHJvbmc+TGluZWFyZSBJbnZlcnNhPC9zdHJvbmc+LWZhdHRvcmUgdmVydGljYWxlLiBMYSBwZW5kZW56YSDDqCBzcGVjaWZpY2F0YSBjb21lIHVuYSBmcmF6aW9uZSBkaSBzYWxpdGEgc3UgY29yc2EgKHBlciBlc2VtcGlvLCBsYSBwZW5kZW56YSBkZWwgNDUgcGVyIGNlbnRvIMOoIDEvNDUsIGNoZSB2aWVuZSBpbW1lc3NhIGNvbWUgMCwwMjIyMikuPC9saT48bGk+PHN0cm9uZz5Ob21lIHRhYmVsbGE8L3N0cm9uZz4tLTwvbGk+SWRlbnRpZmljYSBpbCBub21lIGRlbGxhIHRhYmVsbGEgY2hlIGRlZmluaXNjZSBsYSBWRi48L3VsPlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1ZlcnRpY2FsLVJhc3Rlcl90YWcwQEBcIjogXCJEZWZpbmlzY2UgbGEgcmVsYXppb25lIHRyYSBpbCBmYXR0b3JlIGRpIGNvc3RvIHZlcnRpY2FsZSBlIGwnYW5nb2xvIGRpIG1vdmltZW50byByZWxhdGl2byB2ZXJ0aWNhbGUgKFZSTUEpLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1ZlcnRpY2FsLVJhc3Rlcl90YWcxQEBcIjogXCJJIHZhbG9yaSB2ZW5nb25vIHV0aWxpenphdGkgcGVyIGNhbGNvbGFyZSBsYSBwZW5kZW56YSB1c2F0YSBwZXIgaWRlbnRpZmljYXJlIGlsIGZhdHRvcmUgdmVydGljYWxlIHF1YW5kbyBzaSBwYXNzYSBkYSB1bmEgY2VsbGEgYWxsJ2FsdHJhLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzBAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gc2ltdWxhIGwnYXVtZW50byBkZWxsbyBzZm9yem8gcGVyIHN1cGVyYXJlIGkgY29zdGkgbWFuIG1hbm8gY2hlIGlsIGNvc3RvIGN1bXVsYXRpdm8gYXVtZW50YS4gVmllbmUgdXNhdG8gcGVyIG1vZGVsbGFyZSBsJ2FmZmF0aWNhbWVudG8gZGVsIHZpYWdnaWF0b3JlLiBJbCBjb3N0byBjdW11bGF0aXZvIGNyZXNjZW50ZSBwZXIgcmFnZ2l1bmdlcmUgdW5hIGNlbGxhIHZpZW5lIG1vbHRpcGxpY2F0byBwZXIgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSBlIGFnZ2l1bnRvIGFsIGNvc3RvIHBlciBsbyBzcG9zdGFtZW50byBuZWxsYSBjZWxsYSBjb25zZWN1dGl2YS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcxQEBcIjogXCJTaSB0cmF0dGEgZGkgdW5hIHZlcnNpb25lIG1vZGlmaWNhdGEgZGkgdW5hIGZvcm11bGEgY29tcG9zdGEgZGkgdGFzc28gZGkgaW50ZXJlc3NlIGNoZSB2aWVuZSB1dGlsaXp6YXRhIHBlciBjYWxjb2xhcmUgaWwgY29zdG8gYXBwYXJlbnRlIGRpIHNwb3N0YW1lbnRvIGF0dHJhdmVyc28gdW5hIGNlbGxhLiBDb24gbCdhdW1lbnRhcmUgZGVsIHZhbG9yZSBkZWwgdGFzc28gZGkgcmVzaXN0ZW56YSwgYXVtZW50YSBhbmNoZSBpbCBjb3N0byBkZWxsZSBjZWxsZSB2aXNpdGF0ZSBpbiBzZWd1aXRvLiBRdWFudG8gbWFnZ2lvcmUgw6ggaWwgdGFzc28gZGkgcmVzaXN0ZW56YSwgdGFudG8gcGnDuSBhbHRvIHNhcsOgIGlsIGNvc3RvIHBlciByYWdnaXVuZ2VyZSBsYSBjZWxsYSBzdWNjZXNzaXZhLCBjaGUgw6ggcmVzaXN0ZW50ZSBhIG9nbmkgbW92aW1lbnRvIGNvbnNlY3V0aXZvLiBEYWwgbW9tZW50byBjaGUgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSDDqCBzaW1pbGUgYSB1biB0YXNzbyBjb21wb3N0byBlIGdlbmVyYWxtZW50ZSBpIHZhbG9yaSBkaSBjb3N0byBjdW11bGF0aXZvIHNvbm8gbW9sdG8gZ3JhbmRpLCBzaSBjb25zaWdsaWFubyB0YXNzaSBkaSByZXNpc3RlbnphIHBpY2NvbGksIGNvbWUgMCwwMDUgbyBhbmNoZSBtZW5vLCBhIHNlY29uZGEgZGVpIHZhbG9yaSBkaSBjb3N0byBjdW11bGF0aXZpLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIklsIHZhbG9yZSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBkaSB6ZXJvLiBMYSBjYXBhY2l0w6AgcHJlZGVmaW5pdGEgw6ggZmlubyBhbCBib3JkbyBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX0NhcGFjaXR5X3RhZzBAQFwiOiBcIkRlZmluaXNjZSBsYSBjYXBhY2l0w6AgZGkgY29zdG8gcGVyIGlsIHZpYWdnaWF0b3JlIHJlbGF0aXZhIGEgdW4nb3JpZ2luZS4gSSBjYWxjb2xpIGRlbCBjb3N0byBjb250aW51YW5vIHBlciBvZ25pIG9yaWdpbmUgZmluY2jDqSBub24gc2kgcmFnZ2l1bmdlIGxhIGNhcGFjaXTDoCBzcGVjaWZpY2F0YS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX0NhcGFjaXR5X3RhZzFAQFwiOiBcIklsIHZhbG9yZSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBkaSB6ZXJvLiBMYSBjYXBhY2l0w6AgcHJlZGVmaW5pdGEgw6ggZmlubyBhbCBib3JkbyBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX0Nvc3QtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBkaSBpbnB1dCBvYmJsaWdhdG9yaW8gY2hlIGRlZmluaXNjZSBpbCBjb3N0byBvIGwnaW1wZWRlbnphIGRlbGxvIHNwb3N0YW1lbnRvIHBsYW5pbWV0cmljbyBhdHRyYXZlcnNvIGNpYXNjdW5hIGNlbGxhLiBJbCB2YWxvcmUgYSBvZ25pIHBvc2l6aW9uZSBkZWxsYSBjZWxsYSByYXBwcmVzZW50YSBsYSBkaXN0YW56YSBkaSBjb3N0byBwZXIgdW5pdMOgIHBlciBsJ2F0dHJhdmVyc2FtZW50byBkZWxsYSBzdGVzc2EuIE9nbmkgdmFsb3JlIGRpIHBvc2l6aW9uZSBkaSB1bmEgY2VsbGEgdmllbmUgbW9sdGlwbGljYXRvIHBlciBsYSByaXNvbHV6aW9uZSBkZWxsYSBjZWxsYSBlIGNvbXBlbnNhIGlub2x0cmUgaWwgbW92aW1lbnRvIGRpYWdvbmFsZSBwZXIgb3R0ZW5lcmUgaWwgY29zdG8gdG90YWxlIGRlbGwnYXR0cmF2ZXJzYW1lbnRvIGRlbGxhIHN0ZXNzYS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX0Nvc3QtUmFzdGVyX3RhZzFAQFwiOiBcIkkgdmFsb3JpIGRlbCA8c3Ryb25nPlJhc3RlciBkaSBjb3N0bzwvc3Ryb25nPiBwb3Nzb25vIGVzc2VyZSBhIG51bWVybyBpbnRlcm8gbyBhIHZpcmdvbGEgbW9iaWxlLCBtYSBub24gcG9zc29ubyBlc3NlcmUgbmVnYXRpdmkgbyB6ZXJvLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfaG9yaXpvbnRhbGZhY3Rvcl90YWcwQEBcIjogXCI8cD5EZWZpbmlzY2UgbGEgcmVsYXppb25lIHRyYSBpbCBmYXR0b3JlIGRpIGNvc3RvIG9yaXp6b250YWxlIGUgbCdhbmdvbG8gbW9iaWxlIHJlbGF0aXZvIG9yaXp6b250YWxlIChIUk1BKS48L3A+PHA+Q2kgc29ubyBkaXZlcnNpIGZhdHRvcmkgY29uIG1vZGlmaWNhdG9yaSBjaGUgaWRlbnRpZmljYW5vIHVuIGdyYWZpY28gZGVsIGZhdHRvcmUgdmVydGljYWxlIGRlZmluaXRvLiBJbm9sdHJlLCDDqCBwb3NzaWJpbGUgdXRpbGl6emFyZSB1bmEgdGFiZWxsYSBwZXIgY3JlYXJlIHVuIGdyYWZpY28gcGVyc29uYWxpenphdG8uIEkgZ3JhZmljaSBzb25vIHV0aWxpenphdGkgcGVyIGlkZW50aWZpY2FyZSBpbCBmYXR0b3JlIHZlcnRpY2FsZSB1dGlsaXp6YXRvIG5lbCBjYWxjb2xvIGRlbCBjb3N0byB0b3RhbGUgZGVsbG8gc3Bvc3RhbWVudG8gaW4gdW5hIGNlbGxhIHZpY2luYS48L3A+PHA+TmVsbGUgc3BpZWdhemlvbmkgY2hlIHNlZ3Vvbm8sIHZlbmdvbm8gdXRpbGl6emF0aSBkdWUgYWNyb25pbWk6IEhGIGUgSFJNQS4gSEYgc3RhbmRzIGZvciBob3Jpem9udGFsIGZhY3Rvciwgd2hpY2ggZGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBkaWZmaWN1bHR5IGVuY291bnRlcmVkIHdoZW4gbW92aW5nIGZyb20gb25lIGNlbGwgdG8gdGhlIG5leHQuIEhSTUEgc3RhIHBlciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSwgY2hlIGlkZW50aWZpY2EgbCdhbmdvbG8gdHJhIGxhIGRpcmV6aW9uZSBvcml6em9udGFsZSBkYSB1bmEgY2VsbGEgZSBsYSBkaXJlemlvbmUgZGkgbW92aW1lbnRvLiBJIHRpcGkgZGkgPC9wPjxwPjxzdHJvbmc+ZmF0dG9yaSBvcml6em9udGFsaTwvc3Ryb25nPiBpbmNsdWRvbm8gaSBzZWd1ZW50aTogPC9wPjx1bD48bGk+PHN0cm9uZz5CaW5hcmlvPC9zdHJvbmc+LS0gSW5kaWNhIGNoZSBzZSBsJ0hSTUEgw6ggaW5mZXJpb3JlIGFsbCdhbmdvbG8gZGkgdGFnbGlvLCBsJ0hGIMOoIGltcG9zdGF0byBhbCB2YWxvcmUgYXNzb2NpYXRvIGFsIGZhdHRvcmUgemVybzsgYWx0cmltZW50aSwgw6ggaW5maW5pdG8uPC9saT48bGk+PHN0cm9uZz5BdmFudGk8L3N0cm9uZz4gLS0gU3RhYmlsaXNjZSBjaGUgw6ggcGVybWVzc28gc29sbyBpbCBtb3ZpbWVudG8gaW4gYXZhbnRpLiBMJ0hSTUEgZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgbyB1Z3VhbGUgYSAwIGUgaW5mZXJpb3JlIGEgOTAgZ3JhZGkgKDAgJmx0Oz0gSFJNQSAmbHQ7OTApLiBTZSBsJ0hSTUEgw6ggc3VwZXJpb3JlIGEgMCBlIGluZmVyaW9yZSBhIDQ1IGdyYWRpLCBsJ0hGIHBlciBsYSBjZWxsYSB2aWVuZSBpbXBvc3RhdG8gc3VsIHZhbG9yZSBhc3NvY2lhdG8gYWwgZmF0dG9yZSB6ZXJvLiBTZSBsJ0hSTUEgw6ggc3VwZXJpb3JlIG8gcGFyaSBhIDQ1IGdyYWRpLCB2aWVuZSB1dGlsaXp6YXRvIGlsIHZhbG9yZSBkZWwgbW9kaWZpY2F0b3JlIGRlbCB2YWxvcmUgbGF0ZXJhbGUuIEwnSEYgcGVyIHF1YWxzaWFzaSB2YWxvcmUgSFJNQSB1Z3VhbGUgbyBzdXBlcmlvcmUgYSA5MCBncmFkaSDDqCBpbXBvc3RhdG8gc3UgaW5maW5pdG8uPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlPC9zdHJvbmc+LS1TcGVjaWZpY2EgY2hlIGwnSEYgw6ggdW5hIGZ1bnppb25lIGxpbmVhcmUgZGVsbCdIUk1BLjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyZSBpbnZlcnNhPC9zdHJvbmc+LS1TcGVjaWZpY2EgY2hlIGwnSEYgw6ggdW5hIGZ1bnppb25lIGxpbmVhcmUgaW52ZXJzYSBkZWxsJ0hSTUEuPC9saT48bGk+PHN0cm9uZz5UYWJlbGxhPC9zdHJvbmc+LSBJZGVudGlmaWNhIGNoZSB1biBmaWxlIHRhYmVsbGEgc2Fyw6AgdXNhdG8gcGVyIGRlZmluaXJlIGlsIGdyYWZpY28gZGVpIGZhdHRvcmkgb3JpenpvbnRhbGkgdXNhdG8gcGVyIGRldGVybWluYXJlIGdsaSBIRi48L2xpPjwvdWw+PHA+SSBtb2RpZmljYXRvcmkgZGVpIGZhdHRvcmkgb3JpenpvbnRhbGkgaW5jbHVkb25vIHF1YW50byBzZWd1ZTogPC9wPjx1bD48bGk+PHN0cm9uZz5GYXR0b3JlIHplcm88L3N0cm9uZz4tLSBJbCBmYXR0b3JlIG9yaXp6b250YWxlIGRhIHVzYXJlIHF1YW5kbyBsJ0hSTUEgw6ggemVyby4gUXVlc3RvIGZhdHRvcmUgcG9zaXppb25hIGwnaW50ZXJjZXR0YSB5IHBlciBxdWFsc2lhc2kgZnVuemlvbmUgZmF0dG9yZSBvcml6em9udGFsZS48L2xpPjxsaT48c3Ryb25nPkFuZ29sbyBkaSB0YWdsaW88L3N0cm9uZz4tLURlZmluaXNjZSBsJ2FuZ29sbyBIUk1BIG9sdHJlIGlsIHF1YWxlIGwnSEYgc2Fyw6AgaW1wb3N0YXRvIHN1IGluZmluaXRvLjwvbGk+PGxpPjxzdHJvbmc+UGVuZGVuemE8L3N0cm9uZz4tLSBTdGFiaWxpc2NlIGxhIHBlbmRlbnphIGRlbGxhIGxpbmVhIHJldHRhIHVzYXRhIGNvbiBsZSBwYXJvbGUgY2hpYXZlIGZhdHRvcmUgb3JpenpvbnRhbGUgPHN0cm9uZz5MaW5lYXJlPC9zdHJvbmc+IGUgPHN0cm9uZz5MaW5lYXJlIGludmVyc2E8L3N0cm9uZz4uIExhIHBlbmRlbnphIMOoIHNwZWNpZmljYXRhIGNvbWUgdW5hIGZyYXppb25lIGRpIHNhbGl0YSBzdSBjb3JzYSAocGVyIGVzZW1waW8sIGxhIHBlbmRlbnphIGRlbCA0NSUgw6ggMS80NSwgY2hlIHZpZW5lIGltbWVzc2EgY29tZSAwLDAyMjIyKS48L2xpPjxsaT48c3Ryb25nPlNpZGUgdmFsdWU8L3N0cm9uZz4tLSBTdGFiaWxpc2NlIGwnSEYgcXVhbmRvIGwnSFJNQSDDqCBtYWdnaW9yZSBvIHVndWFsZSBhIDQ1IGdyYWRpIGUgbWlub3JlIGRpIDkwIGdyYWRpIHF1YW5kbyB2aWVuZSBzcGVjaWZpY2F0YSBsYSBwYXJvbGEgY2hpYXZlIEZhdHRvcmUgb3JpenpvbnRhbGUgPHN0cm9uZz5hdmFudGk8L3N0cm9uZz4uPC9saT48bGk+PHN0cm9uZz5Ob21lIGRlbGxhIHRhYmVsbGE8L3N0cm9uZz4gLSBJZGVudGlmaWNhIGlsIG5vbWUgZGVsbGEgdGFiZWxsYSBjaGUgZGVmaW5pc2NlIGwnSEYuPC9saT48L3VsPlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfSG9yaXpvbnRhbC1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGNoZSBkZWZpbmlzY2UgbGEgZGlyZXppb25lIG9yaXp6b250YWxlIHN1IG9nbmkgY2VsbGEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19Ib3Jpem9udGFsLVJhc3Rlcl90YWcxQEBcIjogXCJJIHZhbG9yaSBzdWwgcmFzdGVyIGRldm9ubyBlc3NlcmUgbnVtZXJpIGludGVyaSBjb21wcmVzaSB0cmEgMCBlIDM2MCBjb24gMCBncmFkaSBjaGUgaW5kaWNhIGlsIG5vcmQgbyB2ZXJzbyBsYSBwYXJ0ZSBzdXBlcmlvcmUgZGVsbG8gc2NoZXJtbyBlIGNvbiBhdW1lbnRvIGluIHNlbnNvIG9yYXJpby4gQWxsZSBhcmVlIHBpYW5lIGRldmUgZXNzZXJlIGZvcm5pdG8gdW4gdmFsb3JlIGRpIC0xLiBJIHZhbG9yaSBpbiBvZ25pIHBvc2l6aW9uZSB2ZW5nb25vIHV0aWxpenphdGkgaW5zaWVtZSBhIDxzdHJvbmc+RmF0dG9yZSBvcml6em9udGFsZTwvc3Ryb25nPiBwZXIgZGV0ZXJtaW5hcmUgaSBjb3N0aSBvcml6em9udGFsaSBkdXJhbnRlIGxvIHNwb3N0YW1lbnRvIGRhIHVuYSBjZWxsYSBhIHF1ZWxsZSB2aWNpbmUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19NYXhpbXVtLURpc3RhbmNlX3RhZzBAQFwiOiBcIkxhIHNvZ2xpYSBjaGUgaSB2YWxvcmkgZGkgY29zdG8gY3VtdWxhdGl2aSBub24gcG9zc29ubyBzdXBlcmFyZS4gU2UgdW5hIGRpc3RhbnphIGRpIGNvc3RvIGN1bXVsYXRpdm8gc3VwZXJhIHF1ZXN0byB2YWxvcmUsIGlsIHZhbG9yZSBkaSBvdXRwdXQgcGVyIGxhIHBvc2l6aW9uZSBkZWxsYSBjZWxsYSBzYXLDoCBOb0RhdGEuIExhIGRpc3RhbnphIG1hc3NpbWEgZGVmaW5pc2NlIGwnZXN0ZW5zaW9uZSBwZXIgbGEgcXVhbGUgc2kgY2FsY29sYW5vIGxlIGRpc3RhbnplIGRpIGNvc3RvIGN1bXVsYXRpdmUuIExhIGRpc3RhbnphIHByZWRlZmluaXRhIMOoIGZpbm8gYWxsJ2VzdGVuc2lvbmUgZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzBAQFwiOiBcIlVuIG1vbHRpcGxpY2F0b3JlIGRhIGFwcGxpY2FyZSBhaSB2YWxvcmkgZGkgY29zdG8uXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzFAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gY29uc2VudGUgaWwgY29udHJvbGxvIGRlbGxhIG1vZGFsaXTDoCBkaSBzcG9zdGFtZW50byBvIGRlbGxhIGdyYW5kZXp6YSBhbGwnb3JpZ2luZS4gTWFnZ2lvcmUgw6ggaWwgbW9sdGlwbGljYXRvcmUsIG1hZ2dpb3JlIMOoIGlsIGNvc3RvIHBlciBsbyBzcG9zdGFtZW50byBhdHRyYXZlcnNvIG9nbmkgY2VsbGEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzJAQFwiOiBcIkkgdmFsb3JpIGRldm9ubyBlc3NlcmUgbWFnZ2lvcmkgZGkgemVyby4gTCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEgw6ggMS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnM0BAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHBlciBxdWVzdG8gcGFyYW1ldHJvIHVuIHZhbG9yZSBudW1lcmljbyAoZG9wcGlvKSBvIHVuIGNhbXBvIGRhbCA8c3Ryb25nPlJhc3RlciBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfU291cmNlLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgb2JibGlnYXRvcmlvIHBlciBsZSBwb3NpemlvbmkgZGkgb3JpZ2luZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1NvdXJjZS1SYXN0ZXJfdGFnMUBAXCI6IFwiw4ggdW4gcmFzdGVyIGNoZSBpZGVudGlmaWNhIGxlIGNlbGxlIG8gbGUgcG9zaXppb25pIGRhbGxlIHF1YWxpIHNpIGNhbGNvbGEgbGEgZGlzdGFuemEgZGkgY29zdG8gbWluaW1hIGN1bXVsYXRpdmEgcGVyIG9nbmkgcG9zaXppb25lIGRpIGNlbGxhIGRpIG91dHB1dC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1NvdXJjZS1SYXN0ZXJfdGFnMkBAXCI6IFwiUHXDsiBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBvIHVuIHZhbG9yZSBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfU3RhcnQtQ29zdF90YWcwQEBcIjogXCJJbCBjb3N0byBkaSBpbml6aW8gY29uIGlsIHF1YWxlIGF2dmlhcmUgaSBjYWxjb2xpIGRlbCBjb3N0by4gUXVlc3RvIHBhcmFtZXRybyBjb25zZW50ZSBkaSBzcGVjaWZpY2FyZSBpbCBjb3N0byBmaXNzbyBhc3NvY2lhdG8gYWQgdW4nb3JpZ2luZS4gSW52ZWNlIGRpIGluaXppYXJlIGNvbiB1biBjb3N0byAwLCBsJ2FsZ29yaXRtbyBkZWwgY29zdG8gaW5pemllcsOgIGNvbiBpbCB2YWxvcmUgc3BlY2lmaWNhdG8uXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19TdGFydC1Db3N0X3RhZzFAQFwiOiBcIklsIHZhbG9yZSBkZXZlIGVzc2VyZSBwYXJpIG8gc3VwZXJpb3JlIGEgemVyby4gTCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEgw6ggMC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1N1cmZhY2UtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBjaGUgZGVmaW5pc2NlIGkgdmFsb3JpIGRpIGVsZXZhemlvbmUgc3Ugb2duaSBwb3NpemlvbmUgZGVsbGEgY2VsbGEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19TdXJmYWNlLVJhc3Rlcl90YWcxQEBcIjogXCJJIHZhbG9yaSB2ZW5nb25vIHV0aWxpenphdGkgcGVyIGNhbGNvbGFyZSBs4oCZZWZmZXR0aXZhIGRpc3RhbnphIGRlbGxhIHN1cGVyZmljaWUgcGVyY29yc2EgZHVyYW50ZSBpbCBwYXNzYWdnaW8gdHJhIGNlbGxlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfVHJhdmVsLURpcmVjdGlvbl90YWcwQEBcIjogXCJEZWZpbmlzY2UgbGEgZGlyZXppb25lIGRlbCB2aWFnZ2lhdG9yZSBxdWFuZG8gc2kgYXBwbGljYSBpbCB0YXNzbyBkaSByZXNpc3RlbnphIGRlbGwnb3JpZ2luZSBlIGlsIGNvc3RvIGluaXppYWxlIGRlbGwnb3JpZ2luZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1RyYXZlbC1EaXJlY3Rpb25fdGFnMUBAXCI6IFwiPHN0cm9uZz5EYWxsJ29yaWdpbmU8L3N0cm9uZz46IElsIHRhc3NvIGRpIHJlc2lzdGVuemEgZGkgb3JpZ2luZSBlIGlsIGNvc3RvIGluaXppYWxlIGRlbGwnb3JpZ2luZSBzYXJhbm5vIGFwcGxpY2F0aSBhIHBhcnRpcmUgZGFsbCdvcmlnaW5lIGRpIGlucHV0IGUgcG9pIHNwb3N0YW5kb3NpIGFsbGUgY2VsbGUgbm9uLW9yaWdpbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1RyYXZlbC1EaXJlY3Rpb25fdGFnM0BAXCI6IFwiPHN0cm9uZz5WZXJzbyBsJ29yaWdpbmU8L3N0cm9uZz46IElsIHRhc3NvIGRpIHJlc2lzdGVuemEgZGkgb3JpZ2luZSBlIGlsIGNvc3RvIGluaXppYWxlIGRlbGwnb3JpZ2luZSBzYXJhbm5vIGFwcGxpY2F0aSBhIHBhcnRpcmUgZGEgY2lhc2N1bmEgY2VsbGEgbm9uLW9yaWdpbmUgZSBwb2kgdG9ybmFuZG8gaW5kaWV0cm8gYWxsJ29yaWdpbmUgZGkgaW5wdXQuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19UcmF2ZWwtRGlyZWN0aW9uX3RhZzVAQFwiOiBcIlNwZWNpZmljYXJlIGxhIHBhcm9sYSBjaGlhdmUgPHN0cm9uZz5EYWxsJ29yaWdpbmU8L3N0cm9uZz4gbyA8c3Ryb25nPlZlcnNvIGwnb3JpZ2luZTwvc3Ryb25nPiwgY2hlIHNhcsOgIGFwcGxpY2F0YSBhIHR1dHRlIGxlIG9yaWdpbmksIG9wcHVyZSBzcGVjaWZpY2FyZSB1biBjYW1wbyBuZWwgPHN0cm9uZz5SYXN0ZXIgZGkgb3JpZ2luZTwvc3Ryb25nPiBjaGUgY29udGllbmUgbGUgcGFyb2xlIGNoaWF2ZSBwZXIgaWRlbnRpZmljYXJlIGxhIGRpcmV6aW9uZSBkaSB2aWFnZ2lvIHBlciBvZ25pIG9yaWdpbmUuIFF1ZWwgY2FtcG8gZGV2ZSBjb250ZW5lcmUgbGEgc3RyaW5nYSAke0ZST01fU09VUkNFfSBvICR7VE9fU09VUkNFfS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX3ZlcnRpY2FsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkRlZmluaXNjZSBsYSByZWxhemlvbmUgdHJhIGlsIGZhdHRvcmUgZGkgY29zdG8gdmVydGljYWxlIGUgbCdhbmdvbG8gbW9iaWxlIHJlbGF0aXZvIHZlcnRpY2FsZSAoVlJNQSkuPC9wPjxwPkNpIHNvbm8gZGl2ZXJzaSBmYXR0b3JpIGNvbiBtb2RpZmljYXRvcmkgY2hlIGlkZW50aWZpY2FubyB1biBncmFmaWNvIGRpIGZhdHRvcmUgdmVydGljYWxlIGRlZmluaXRvLiBJbm9sdHJlLCDDqCBwb3NzaWJpbGUgdXRpbGl6emFyZSB1bmEgdGFiZWxsYSBwZXIgY3JlYXJlIHVuIGdyYWZpY28gcGVyc29uYWxpenphdG8uIEkgZ3JhZmljaSBzb25vIHV0aWxpenphdGkgcGVyIGlkZW50aWZpY2FyZSBpbCBmYXR0b3JlIHZlcnRpY2FsZSB1dGlsaXp6YXRvIG5lbCBjYWxjb2xvIGRlbCBjb3N0byB0b3RhbGUgZGVsbG8gc3Bvc3RhbWVudG8gaW4gdW5hIGNlbGxhIHZpY2luYS48L3A+PHA+TmVsbGUgc3BpZWdhemlvbmkgY2hlIHNlZ3Vvbm8sIHZlbmdvbm8gdXRpbGl6emF0aSBkdWUgYWNyb25pbWk6IFZGIGUgVlJNQS4gVkYgc3RhbmRzIGZvciB2ZXJ0aWNhbCBmYWN0b3IsIHdoaWNoIGRlZmluZXMgdGhlIHZlcnRpY2FsIGRpZmZpY3VsdHkgZW5jb3VudGVyZWQgaW4gbW92aW5nIGZyb20gb25lIGNlbGwgdG8gdGhlIG5leHQuIFZSTUEgc3RhIHBlciBhbmdvbG8gbW9iaWxlIHJlbGF0aXZvIHZlcnRpY2FsZSwgY2hlIGlkZW50aWZpY2EgbCdhbmdvbG8gZGkgcGVuZGVuemEgdHJhIGxhIGNlbGxhIEZST00sIG8gZGkgZWxhYm9yYXppb25lLCBlIGxhIGNlbGxhIFRPLjwvcD48cD48c3Ryb25nPkkgZmF0dG9yaSB2ZXJ0aWNhbGk8L3N0cm9uZz4gaW5jbHVkb25vIGkgc2VndWVudGk6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5hcmlvPC9zdHJvbmc+LS0gU3BlY2lmaWNhIGNoZSBzZSBpbCBWUk1BIMOoIG1hZ2dpb3JlIGRlbGwnYW5nb2xvIGRpIHRhZ2xpbyBiYXNzbyBlIG1pbm9yZSBkZWxsJ2FuZ29sbyBkaSB0YWdsaW8gYWx0bywgaWwgVkYgw6ggaW1wb3N0YXRvIGFsIHZhbG9yZSBhc3NvY2lhdG8gYWwgZmF0dG9yZSB6ZXJvOyBhbHRyaW1lbnRpLCDDqCBpbmZpbml0by48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4gLSBJbmRpY2EgY2hlIGxhIFZGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGRlbGxhIFZSTUEuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIHNpbW1ldHJpY2E8L3N0cm9uZz4tLSBTcGVjaWZpY2EgY2hlIGxhIFZGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGRlbGxhIFZSTUEgbmVsIGxhdG8gbmVnYXRpdm8gbyBwb3NpdGl2byBkZWxsYSBWUk1BLCByaXNwZXR0aXZhbWVudGUsIGUgbGUgZHVlIGZ1bnppb25pIGxpbmVhcmkgc29ubyBzaW1tZXRyaWNoZSByaXNwZXR0byBhbGwnYXNzZSBWRiAoeSkuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIGludmVyc2E8L3N0cm9uZz4gLSBJbmRpY2EgY2hlIGxhIFZGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGludmVyc2EgZGVsIFZSTUEuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIGludmVyc2Egc2ltbWV0cmljYTwvc3Ryb25nPi0tIEluZGljYSBjaGUgbGEgVkYgw6ggdW5hIGZ1bnppb25lIGxpbmVhcmUgaW52ZXJzYSBkZWwgVlJNQSBuZWwgbGF0byBuZWdhdGl2byBvIHBvc2l0aXZvIGRlbCBWUk1BLCByaXNwZXR0aXZhbWVudGUsIGUgbGUgZHVlIGZ1bnppb25pIGxpbmVhcmkgc29ubyBzaW1tZXRyaWNoZSByaXNwZXR0byBhbGwnYXNzZSBWRiAoeSkuPC9saT48bGk+PHN0cm9uZz5Db3M8L3N0cm9uZz4tLUlkZW50aWZpY2EgbGEgVkYgY29tZSBmdW56aW9uZSBiYXNhdGEgc3VsIGNvc2VubyBkZWwgVlJNQS48L2xpPjxsaT48c3Ryb25nPlNlYzwvc3Ryb25nPi0tSWRlbnRpZmljYSBsYSBWRiBjb21lIGZ1bnppb25lIGJhc2F0YSBzdWxsYSBzZWNhbnRlIGRlbCBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+Q29zLVNlYzwvc3Ryb25nPi0tU3BlY2lmaWNhIGNoZSBsYSBWRiDDqCBsYSBmdW56aW9uZSBiYXNhdGEgc3VsIGNvc2VubyBkZWwgVlJNQSBxdWFuZG8gaWwgVlJNQSDDqCBuZWdhdGl2byBlIGxhIGZ1bnppb25lIGJhc2F0YSBzdWxsYSBzZWNhbnRlIGRlbCBWUk1BIHF1YW5kbyBpbCBWUk1BIG5vbiDDqCBuZWdhdGl2by48L2xpPjxsaT48c3Ryb25nPlNlYy1Db3M8L3N0cm9uZz4tLVNwZWNpZmljYSBjaGUgbGEgVkYgw6ggbGEgZnVuemlvbmUgYmFzYXRhIHN1bGxhIHNlY2FudGUgZGVsIFZSTUEgcXVhbmRvIGlsIFZSTUEgw6ggbmVnYXRpdm8gZSBsYSBmdW56aW9uZSBiYXNhdGEgc3VsIGNvc2VubyBkZWwgVlJNQSBxdWFuZG8gaWwgVlJNQSBub24gw6ggbmVnYXRpdm8uIDwvbGk+PGxpPjxzdHJvbmc+VGFiZWxsYTwvc3Ryb25nPi0tSWRlbnRpZmljYSBjaGUgdmVycsOgIHV0aWxpenphdG8gdW4gZmlsZSB0YWJlbGxhIHBlciBkZWZpbmlyZSBpbCBncmFmaWNvIGRlbCBmYXR0b3JlIHZlcnRpY2FsZSBjaGUgdmllbmUgdXRpbGl6emF0byBwZXIgZGV0ZXJtaW5hcmUgbGUgVkYuPC9saT48L3VsPjxwPkkgbW9kaWZpY2F0b3JpIGRlbGxlIHBhcm9sZSBjaGlhdmUgdmVydGljYWxpIGluY2x1ZG9ubyBxdWFudG8gc2VndWU6IDwvcD48dWw+PGxpPjxzdHJvbmc+RmF0dG9yZSB6ZXJvPC9zdHJvbmc+LS0gU3RhYmlsaXNjZSBpbCBmYXR0b3JlIHZlcnRpY2FsZSB1c2F0byBxdWFuZG8gaWwgVlJNQSDDqCB6ZXJvLiBRdWVzdG8gZmF0dG9yZSBwb3NpemlvbmEgbOKAmWludGVyY2V0dGF6aW9uZSB5IGRlbGxhIGZ1bnppb25lIHNwZWNpZmljYXRhLiBQZXIgZGVmaW5pemlvbmUsIGlsIGZhdHRvcmUgemVybyBub24gw6ggYXBwbGljYWJpbGUgYWQgYWxjdW5hIGZ1bnppb25lIHZlcnRpY2FsZSB0cmlnb25vbWV0cmljYSAoQ09TLCBTRUMsIENPUy1TRUMgbyBTRUMtQ09TKS4gTCdpbnRlcmNldHRhIHkgw6ggZGVmaW5pdGEgZGEgcXVlc3RlIGZ1bnppb25pLjwvbGk+PGxpPjxzdHJvbmc+QW5nb2xvIGRpIHRhZ2xpbyBiYXNzbyA8L3N0cm9uZz4tIERlZmluaXNjZSBsJ2FuZ29sbyBWUk1BIGFsIGRpIHNvdHRvIGRlbCBxdWFsZSBsYSBWRiBzYXLDoCBpbXBvc3RhdGEgc3UgaW5maW5pdG8uPC9saT48bGk+PHN0cm9uZz5BbmdvbG8gZGkgdGFnbGlvIGFsdG88L3N0cm9uZz4gLSBEZWZpbmlzY2UgbCdhbmdvbG8gVlJNQSBhbCBkaSBzb3ByYSBkZWwgcXVhbGUgbGEgVkYgc2Fyw6AgaW1wb3N0YXRhIHN1IGluZmluaXRvLiA8L2xpPjxsaT48c3Ryb25nPlBlbmRlbnphPC9zdHJvbmc+IC0gU3RhYmlsaXNjZSBsYSBwZW5kZW56YSBkZWxsYSBsaW5lYSByZXR0YSB1c2F0YSBjb24gbGUgcGFyb2xlIGNoaWF2ZSA8c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4gZSA8c3Ryb25nPkxpbmVhcmUgSW52ZXJzYTwvc3Ryb25nPi1mYXR0b3JlIHZlcnRpY2FsZS4gTGEgcGVuZGVuemEgw6ggc3BlY2lmaWNhdGEgY29tZSB1bmEgZnJhemlvbmUgZGkgc2FsaXRhIHN1IGNvcnNhIChwZXIgZXNlbXBpbywgbGEgcGVuZGVuemEgZGVsIDQ1IHBlciBjZW50byDDqCAxLzQ1LCBjaGUgdmllbmUgaW1tZXNzYSBjb21lIDAsMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+Tm9tZSB0YWJlbGxhPC9zdHJvbmc+LS08L2xpPklkZW50aWZpY2EgaWwgbm9tZSBkZWxsYSB0YWJlbGxhIGNoZSBkZWZpbmlzY2UgbGEgVkYuPC91bD5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1ZlcnRpY2FsLVJhc3Rlcl90YWcwQEBcIjogXCJEZWZpbmlzY2UgbGEgcmVsYXppb25lIHRyYSBpbCBmYXR0b3JlIGRpIGNvc3RvIHZlcnRpY2FsZSBlIGwnYW5nb2xvIGRpIG1vdmltZW50byByZWxhdGl2byB2ZXJ0aWNhbGUgKFZSTUEpLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfVmVydGljYWwtUmFzdGVyX3RhZzFAQFwiOiBcIkkgdmFsb3JpIHZlbmdvbm8gdXRpbGl6emF0aSBwZXIgY2FsY29sYXJlIGxhIHBlbmRlbnphIHVzYXRhIHBlciBpZGVudGlmaWNhcmUgaWwgZmF0dG9yZSB2ZXJ0aWNhbGUgcXVhbmRvIHNpIHBhc3NhIGRhIHVuYSBjZWxsYSBhbGwnYWx0cmEuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAUGx1c19DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAUGx1c19DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAUGx1c19FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQFBsdXNfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFBsdXNfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAUGx1c19FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAUGx1c19FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBQbHVzX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IGFsIHF1YWxlIHZlcnJhbm5vIGFnZ2l1bnRpIGkgc3VvaSB2YWxvcmkuXCIsXG5cdFwiQEBQbHVzX1Jhc3Rlcl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBQbHVzX1Jhc3RlcjJfdGFnMEBAXCI6IFwiTCdpbnB1dCBpIGN1aSB2YWxvcmkgdmVycmFubm8gYWdnaXVudGkgYWwgcHJpbW8gaW5wdXQuXCIsXG5cdFwiQEBQbHVzX1Jhc3RlcjJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBATG9jYWxfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZ3JhbmRlenphIGRpIGNlbGxhIHV0aWxpenphcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBMb2NhbF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATG9jYWxfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBMb2NhbF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gU2kgdHJhdHRhIGRlbGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATG9jYWxfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBATG9jYWxfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBMb2NhbF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQExvY2FsX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBMb2NhbF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBTaSB0cmF0dGEgZGVsbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBMb2NhbF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBATG9jYWxfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBATG9jYWxfUmFzdGVyX3RhZzBAQFwiOiBcIkwnaW5wdXQgYWwgcXVhbGUgdmVycmFubm8gYWdnaXVudGkgaSBzdW9pIHZhbG9yaS5cIixcblx0XCJAQExvY2FsX1Jhc3Rlcl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBMb2NhbF9SYXN0ZXIyX3RhZzBAQFwiOiBcIkwnaW5wdXQgaSBjdWkgdmFsb3JpIHZlcnJhbm5vIGFnZ2l1bnRpIGFsIHByaW1vIGlucHV0LlwiLFxuXHRcIkBATG9jYWxfUmFzdGVyMl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBMb2NhbF9GYWxzZS1SYXN0ZXJfdGFnMEBAXCI6IFwiTCdpbnB1dCBpIGN1aSB2YWxvcmkgc2FyYW5ubyB1c2F0aSBjb21lIHZhbG9yaSBwaXhlbCBkaSBvdXRwdXQgc2UgbGEgY29uZGl6aW9uZSDDqCBmYWxzZS4gUHXDsiBlc3NlcmUgdW4gbnVtZXJvIGludGVybywgdW4gcmFzdGVyIGEgdmlyZ29sYSBtb2JpbGUgbyB1biB2YWxvcmUgY29zdGFudGUuXCIsXG5cdFwiQEBMb2NhbF9UcnVlLVJhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IGkgY3VpIHZhbG9yaSBzYXJhbm5vIHVzYXRpIGNvbWUgdmFsb3JpIHBpeGVsIGRpIG91dHB1dCBzZSBsYSBjb25kaXppb25lIMOoIHZlcm8uIFB1w7IgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8sIHVuIHJhc3RlciBhIHZpcmdvbGEgbW9iaWxlIG8gdW4gdmFsb3JlIGNvc3RhbnRlLlwiLFxuXHRcIkBAUG93ZXJfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQFBvd2VyX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBQb3dlcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFBvd2VyX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBQb3dlcl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBQb3dlcl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFBvd2VyX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAUG93ZXJfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFBvd2VyX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFBvd2VyX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBQb3dlcl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBQb3dlcl9SYXN0ZXJfdGFnMEBAXCI6IFwiSSB2YWxvcmkgZGkgaW5wdXQgZGEgZWxldmFyZSBhbGxhIHBvdGVuemEgZGVmaW5pdGkgZGEgPHN0cm9uZz5SYXN0ZXIyPC9zdHJvbmc+LlwiLFxuXHRcIkBAUG93ZXJfUmFzdGVyX3RhZzNAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQFBvd2VyX1Jhc3RlcjJfdGFnMEBAXCI6IFwiTCdpbnB1dCBjaGUgZGV0ZXJtaW5hIGxhIHBvdGVuemEgYWxsYSBxdWFsZSBpIHZhbG9yaSBkaSA8c3Ryb25nPlJhc3Rlcjwvc3Ryb25nPiBzYXJhbm5vIGVsZXZhdGkuXCIsXG5cdFwiQEBQb3dlcl9SYXN0ZXIyX3RhZzNAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSB1biB2YWxvcmUgY29zdGFudGUgY29tZSBpbnB1dCBwZXIgcXVlc3RvIHBhcmFtZXRybywgcHVyY2jDqSBzaWEgc3BlY2lmaWNhdG8gdW4gcmFzdGVyIHBlciBsJ2FsdHJvIHBhcmFtZXRyby5cIixcblx0XCJAQFJhZGFyLUNhbGlicmF0aW9uX0NhbGlicmF0aW9uLVR5cGVfdGFnMEBAXCI6IFwiSWwgdGlwbyBkaSBjYWxpYnJhemlvbmUgZGEgZXNlZ3VpcmUuXCIsXG5cdFwiQEBSYWRhci1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzFAQFwiOiBcIkJldGEtemVybzogbGEgZnVuemlvbmUgcmVzdGl0dWlzY2UgbGEgcmlmbGV0dGFuemEgZGVsIHJhZGFyIHBlciBhcmVhIGRlbGwndW5pdMOgIG5lbGwnaW50ZXJ2YWxsbyBpbmNsaW5hdG8uIFF1ZXN0byDDqCBpbCB0aXBvIGNhbGlicmF6aW9uZSBwcmVkZWZpbml0by5cIixcblx0XCJAQFJhZGFyLUNhbGlicmF0aW9uX0NhbGlicmF0aW9uLVR5cGVfdGFnMkBAXCI6IFwiU2lnbWEtemVybzogbGEgZnVuemlvbmUgcmVzdGl0dWlzY2UgbGEgcmlmbGV0dGFuemEgZGVsIHJhZGFyIHBlciBhcmVhIGRlbGwndW5pdMOgIG5lbGwnaW50ZXJ2YWxsbyBkZWwgdGVycmVuby4gSSByaXN1bHRhdGkgc29ubyB2YWxvcmkgYSAzMiBiaXQgYSB2aXJnb2xhIG1vYmlsZSBjaGUgcmllbnRyYW5vIGNvbXVuZW1lbnRlIG5lbGwnaW50ZXJ2YWxsbyBkYSAwLDAgYSAxLDAuIFNlIMOoIHNlbGV6aW9uYXRhIHF1ZXN0YSBvcHppb25lIG5vbiBzaSBlc2VndWUgYWxjdW4gdGFnbGlvIGRlaSBkYXRpLlwiLFxuXHRcIkBAUmFkYXItQ2FsaWJyYXRpb25fQ2FsaWJyYXRpb24tVHlwZV90YWczQEBcIjogXCJHYW1tYTogbGEgZnVuemlvbmUgcmVzdGl0dWlzY2UgbGEgcmlmbGV0dGFuemEgZGVsIHJhZGFyIHBlciBhcmVhIGRlbGwndW5pdMOgIG5lbCBwaWFubyBwZXJwZW5kaWNvbGFyZSBhbGxhIGRpcmV6aW9uZSBkaSBtaXN1cmEuXCIsXG5cdFwiQEBSYWRhci1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzRAQFwiOiBcIk5lc3N1bmFcIixcblx0XCJAQFJhZGFyLUNhbGlicmF0aW9uX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBSYXN0ZXJJbmZvX1Jhc3Rlci1JbmZvX3RhZzBAQFwiOiBcIlNlbGV6aW9uYXJlIHVuIGRhdGFzZXQgcmFzdGVyIGRhIHVzYXJlIGNvbWUgbW9kZWxsb1wiLFxuXHRcIkBAUmFzdGVySW5mb19SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfQXR0cmlidXRlLUZpZWxkLU5hbWVzX3RhZzBAQFwiOiBcIkVsZW5jbyBkaSBjYW1waSBuZWxsYSA8c3Ryb25nPlRhYmVsbGEgYXR0cmlidXRpIHpvbmFsaTwvc3Ryb25nPiwgaW4gY3VpIG9nbmkgY2FtcG8gw6ggc2VwYXJhdG8gZGEgdW5hIHZpcmdvbGEuIEkgdmFsb3JpIGRpIG9nbmkgY2FtcG8gc2FyYW5ubyByYXBwcmVzZW50YXRpIGRhIHVuYSBiYW5kYSBuZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX0JhY2tncm91bmQtVmFsdWVfdGFnMEBAXCI6IFwiSWwgdmFsb3JlIGRpIHBpeGVsIGluaXppYWxlIGRlbGxlIGJhbmRlIGRpIG91dHB1dCBpbiB1biByYXN0ZXIsIHByaW1hIGRlbGxhIG51b3ZhIG1hcHBhdHVyYS5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX0JhY2tncm91bmQtVmFsdWVfdGFnMUBAXCI6IFwiU2UgdW4gcGl4ZWwgbm9uIHJpZW50cmEgaW4gdW5hIHpvbmEsIHJpbWFycsOgIGNvbWUgdmFsb3JlIGRpIHNmb25kby5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX1ZhbHVlLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgb2JibGlnYXRvcmlvLlwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfVmFsdWUtUmFzdGVyX3RhZzFAQFwiOiBcIkwnaW5wdXQgZGV2ZSBlc3NlcmUgdW4gcmFzdGVyIGEgYmFuZGEgc2luZ29sYS4gU2Ugc2kgdXNhIHVuIHJhc3RlciBtdWx0aWJhbmRhLCB2ZXJyw6AgdXNhdGEgc29sbyBsYSBwcmltYSBiYW5kYS5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX1doZXJlLUNsYXVzZV90YWcwQEBcIjogXCJVbidpbnRlcnJvZ2F6aW9uZSBhZ2dpdW50aXZhIG9wemlvbmFsZSBhcHBsaWNhdGEgbmVsbGEgPHN0cm9uZz5UYWJlbGxhIGF0dHJpYnV0aSB6b25hbGk8L3N0cm9uZz4uXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19XaGVyZS1DbGF1c2VfdGFnM0BAXCI6IFwiU2Ugc2kgw6ggdXNhdGEgbGEgdGFiZWxsYSBwcmVjZWRlbnRlIGNvbWUgZXNlbXBpbywgbCdpbnRlcnJvZ2F6aW9uZSBzYXJlYmJlICR7VmFyaWFibGUxID0gJ2JhcmUgZWFydGgnfS5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX1pvbmFsLUF0dHJpYnV0ZXMtVGFibGVfdGFnMEBAXCI6IFwiR2xpIGF0dHJpYnV0aSB6b25hbGkgc3BlY2lmaWNhdGkgY29tZSB1biBwZXJjb3JzbyBhZCB1bmEgZmVhdHVyZSBjbGFzcyBsb2NhbGUsIGlsIHBlcmNvcnNvIHBlciB1bmEgdGFiZWxsYSwgbCdVUkwgcGVyIHVuIGxheWVyIGZlYXR1cmUgc2VydmljZSBvIHVuYSBzdHJpbmdhIEpTT04uXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19ab25hbC1BdHRyaWJ1dGVzLVRhYmxlX3RhZzFAQFwiOiBcIkluIEpTT04sIMOoIGRlc2NyaXR0YSBjb21lIHVuYSByYWNjb2x0YSBkaSBtYXBwYXR1cmUgZGEgSUQgem9uYSBhIHVuIGFycmF5IGRpIG51bWVyaSBpbnRlcmkuICR7eyB6b25lSWQ6W2YxLGYyLC4uLixmbl0sIC4uLiB9IH1cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX1pvbmUtRmllbGRfdGFnMEBAXCI6IFwiSWwgbm9tZSBkZWwgY2FtcG8gY29udGVuZW50ZSBpIHZhbG9yaSBJRCB6b25hLlwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfWm9uZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGEgYmFuZGEgc2luZ29sYSBvcHppb25hbGUgaW4gY3VpIG9nbmkgcGl4ZWwgY29udGllbmUgbCdJRCB6b25hIGFzc29jaWF0byBjb24gbGEgcG9zaXppb25lLiBMJ0lEIHpvbmEgdmllbmUgdXNhdG8gcGVyIGxhIHJpY2VyY2EgZGkgcmlnaGUgbmVsbGEgdGFiZWxsYSBhdHRyaWJ1dGkgem9uYWxpIHBlciBpbmdlc3Rpb25pIHNwZWNpZmljaGUgcGVyIHpvbmEuXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19ab25lLVJhc3Rlcl90YWcxQEBcIjogXCJMYXNjaWFyZSBxdWVzdG8gcGFyYW1ldHJvIG5vbiBzcGVjaWZpY2F0byBzZSBzaSBkZXNpZGVyYSBzb2xvIGltcG9ydGFyZSBsJ2F0dHJpYnV0by5cIixcblx0XCJAQFJhc3Rlcml6ZS1GZWF0dXJlc19GaWVsZF90YWcwQEBcIjogXCJTZWxlemlvbmEgaWwgY2FtcG8gZGEgdXNhcmUgcGVyIGlkZW50aWZpY2FyZSBvZ25pIGZlYXR1cmUuXCIsXG5cdFwiQEBSYXN0ZXJpemUtRmVhdHVyZXNfSW5wdXQtRmVhdHVyZXNfdGFnMEBAXCI6IFwiU2VsZXppb25hIGxhIGZlYXR1cmUgY2xhc3MgZGEgY29udmVydGlyZSBpbiBmb3JtYXRvIHJhc3Rlci5cIixcblx0XCJAQFJhc3Rlcml6ZS1GZWF0dXJlc19SYXN0ZXJfdGFnMEBAXCI6IFwiU2VsZXppb25hcmUgdW4gcmFzdGVyIHBlciBkZWZpbmlyZSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIGUgbCdlc3RlbnNpb25lIHBlciBsYSBjb252ZXJzaW9uZSBkZWxsYSBmZWF0dXJlLlwiLFxuXHRcIkBAUmFzdGVyaXplLUZlYXR1cmVzX1Jlc29sdmUtT3ZlcmxhcC1NZXRob2RfdGFnMEBAXCI6IFwiRGV0ZXJtaW5hIGNvbWUgZ2VzdGlyZSBsZSBmZWF0dXJlIGNoZSBzaSBzb3ZyYXBwb25nb25vOlwiLFxuXHRcIkBAUmFzdGVyaXplLUZlYXR1cmVzX1Jlc29sdmUtT3ZlcmxhcC1NZXRob2RfdGFnMUBAXCI6IFwiPHN0cm9uZz5Qcmltbzwvc3Ryb25nPjogYWxsZSBhcmVlIHNvdnJhcHBvc3RlIHNpIGFzc2VnbmVyw6AgaWwgdmFsb3JlIGRlbCBwcmltbyBkYXRhc2V0IGRlbGxhIGxpc3RhLlwiLFxuXHRcIkBAUmFzdGVyaXplLUZlYXR1cmVzX1Jlc29sdmUtT3ZlcmxhcC1NZXRob2RfdGFnM0BAXCI6IFwiPHN0cm9uZz5VbHRpbW88L3N0cm9uZz46IGFsbGUgYXJlZSBzb3ZyYXBwb3N0ZSBzaSBhc3NlZ25lcsOgIGlsIHZhbG9yZSBkZWxsJ3VsdGltbyBkYXRhc2V0IGRlbGxhIGxpc3RhLlwiLFxuXHRcIkBAUmFzdGVyaXplLUZlYXR1cmVzX1Jlc29sdmUtT3ZlcmxhcC1NZXRob2RfdGFnNUBAXCI6IFwiPHN0cm9uZz5QacO5IHBpY2NvbG88L3N0cm9uZz46IGFsbGUgYXJlZSBzb3ZyYXBwb3N0ZSBzaSBhc3NlZ25lcsOgIGlsIHZhbG9yZSBkZWxsYSBmZWF0dXJlIHBpw7kgcGljY29sYS5cIixcblx0XCJAQFJhc3Rlcml6ZS1GZWF0dXJlc19SZXNvbHZlLU92ZXJsYXAtTWV0aG9kX3RhZzdAQFwiOiBcIjxzdHJvbmc+UGnDuSBncmFuZGU8L3N0cm9uZz46IGFsbGUgYXJlZSBzb3ZyYXBwb3N0ZSBzaSBhc3NlZ25lcsOgIGlsIHZhbG9yZSBkZWxsYSBmZWF0dXJlIHBpw7kgZ3JhbmRlLlwiLFxuXHRcIkBAUmVjYXN0X092ZXJyaWRlc190YWcwQEBcIjogXCJVbmEgdGFiZWxsYSBkaSBub21pIHZhcmlhYmlsaSBlIHZhbG9yaSBkZWZpbml0aSBkYWxsJ3V0ZW50ZSB1dGlsaXp6YXRhIHBlciBtb2RpZmljYXJlIGlsIG1vc2FpYyBkYXRhc2V0LlwiLFxuXHRcIkBAUmVjYXN0X1Jhc3Rlcl90YWcwQEBcIjogXCJJbCBwcm9kb3R0byByYXN0ZXIgYWwgcXVhbGUgdmVycsOgIGFwcGxpY2F0YSBsYSBmdW56aW9uZSBSZWNhc3QuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfQWRkLUxpbmtfdGFnMEBAXCI6IFwiU3BlY2lmaWNhIHNlIHZpZW5lIGFnZ2l1bnRvIHVuIGNhbXBvIGNvbGxlZ2FtZW50byBhbGxhIHRhYmVsbGEgZGVsbCdvdXRwdXQuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfQWRkLUxpbmtfdGFnMUBAXCI6IFwiPHN0cm9uZz5BZ2dpdW5naSBjb2xsZWdhbWVudG88L3N0cm9uZz46IHVuIGVsZW1lbnRvICR7TElOS30gdmVycsOgIGFnZ2l1bnRvIGFsbGEgdGFiZWxsYSBkZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9BZGQtTGlua190YWczQEBcIjogXCI8c3Ryb25nPk5lc3N1biBjb2xsZWdhbWVudG88L3N0cm9uZz46IGxhIHRhYmVsbGEgZGkgb3V0cHV0IGRlbCByYXN0ZXIgZGkgb3V0cHV0IGNvbnRlcnLDoCBzb2xvIGVsZW1lbnRpICR7VmFsdWV9IGUgJHtDb3VudH0uXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfRXhjbHVkZWQtVmFsdWVfdGFnMEBAXCI6IFwiSWRlbnRpZmljYSB1biB2YWxvcmUgdGFsZSBjaGUgc2UgbGEgcG9zaXppb25lIGRpIHVuYSBjZWxsYSBjb250aWVuZSBpbCB2YWxvcmUsIG5vbiB2ZXJyw6AgdmFsdXRhdGEgbmVzc3VuYSBjb25uZXNzaW9uZSBzcGF6aWFsZSBpbmRpcGVuZGVudGVtZW50ZSBkYWwgbnVtZXJvIGRpIHZpY2luaSBzcGVjaWZpY2F0aSAoUVVBVFRSTyBvIE9UVE8pLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX0V4Y2x1ZGVkLVZhbHVlX3RhZzFAQFwiOiBcIkxlIGNlbGxlIGNvbiBpbCB2YWxvcmUgZXNjbHVzbyB2ZXJyYW5ubyB0cmF0dGF0ZSBjb21lIE5vRGF0YSBlZCBlbGltaW5hdGUgZGFpIGNhbGNvbGkuIExlIHBvc2l6aW9uaSBkZWxsZSBjZWxsZSBjaGUgY29udGVuZ29ubyBpbCB2YWxvcmUgZXNjbHVzbyByaWNldmVyYW5ubyAwIG5lbCByYXN0ZXIgZGkgb3V0cHV0LlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX0V4Y2x1ZGVkLVZhbHVlX3RhZzJAQFwiOiBcIklsIHZhbG9yZSBlc2NsdXNvIMOoIHNpbWlsZSBhbCBjb25jZXR0byBkaSB1biB2YWxvcmUgZGkgc2ZvbmRvLCBvIGRpIHVuYSBtYXNjaGVyYSBhcHBsaWNhdGEuIMOIIG5lY2Vzc2FyaW8gc3BlY2lmaWNhcmUgdW4gdmFsb3JlIHBlciBxdWVzdG8gcGFyYW1ldHJvIHNlIGlsIHBhcmFtZXRybyA8c3Ryb25nPiR7Q1JPU1N9PC9zdHJvbmc+IMOoIHNwZWNpZmljYXRvLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX051bWJlci1vZi1OZWlnaGJvci1DZWxsc190YWcwQEBcIjogXCJJbCBudW1lcm8gZGkgY2VsbGUgdmljaW5lIGRhIHV0aWxpenphcmUgbmVsbGEgdmFsdXRhemlvbmUgZGVsbGEgY29ubmVzc2lvbmUgdHJhIGNlbGxlLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX051bWJlci1vZi1OZWlnaGJvci1DZWxsc190YWcxQEBcIjogXCI8c3Ryb25nPlFVQVRUUk88L3N0cm9uZz46IGRlZmluaXNjZSBsYSBjb25uZXNzaW9uZSB0cmEgY2VsbGUgY29uIGxvIHN0ZXNzbyB2YWxvcmUgc29sbyBzZSBsZSBjZWxsZSBzb25vIGVzYXR0YW1lbnRlIGEgc2luaXN0cmEsIGRlc3RyYSwgc29wcmEgbyBzb3R0byBvZ251bmEgZGVsbGUgcXVhdHRybyBjZWxsZSBwacO5IHZpY2luZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX051bWJlci1vZi1OZWlnaGJvci1DZWxsc190YWczQEBcIjogXCI8c3Ryb25nPk9UVE88L3N0cm9uZz46IGRlZmluaXNjZSBsYSBjb25uZXNzaW9uZSB0cmEgY2VsbGUgY29uIGxvIHN0ZXNzbyB2YWxvcmUgc2Ugc29ubyBuZWwgcXVhcnRpZXJlIGRpIG90dG8gY2VsbGUgYWRpYWNlbnRlIGEgb2dudW5hLiBJbmNsdWRlIGwnZXNzZXJlIHBvc2l6aW9uYXRlIGEgZGVzdHJhLCBhIHNpbmlzdHJhLCBzb3ByYSBvIGluIGRpYWdvbmFsZSB1bmEgZGFsbCdhbHRyYS5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLUNvbm5lY3Rpdml0eV90YWcwQEBcIjogXCJEZWZpbmlzY2UgaSB2YWxvcmkgZGkgY2VsbGEgZGEgY29uc2lkZXJhcmUgZHVyYW50ZSBpbCB0ZXN0IGRpIGNvbm5ldHRpdml0w6AuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfWm9uZS1Db25uZWN0aXZpdHlfdGFnMUBAXCI6IFwiPHN0cm9uZz5FTlRSTzwvc3Ryb25nPjogdmVyaWZpY2EgbGEgY29ubmVzc2lvbmUgdHJhIHZhbG9yaSBkaSBpbnB1dCB1Z3VhbGkgYWxsJ2ludGVybm8gZGVsbGEgc3Rlc3NhIHpvbmEuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLUNvbm5lY3Rpdml0eV90YWczQEBcIjogXCJMZSB1bmljaGUgY2VsbGUgY2hlIHBvc3Nvbm8gZXNzZXJlIHJhZ2dydXBwYXRlIHNvbm8gY2VsbGUgZGVsbGEgc3Rlc3NhIHpvbmEgKHZhbG9yZSkgY2hlIHNvZGRpc2Zhbm8gaSByZXF1aXNpdGkgc3BhemlhbGkgZGkgY29ubmV0dGl2aXTDoCBzcGVjaWZpY2F0aSBkYWwgcGFyYW1ldHJvIDxzdHJvbmc+TnVtZXJvIGRpIHZpY2luaTwvc3Ryb25nPiAoYSBxdWF0dHJvIHVzY2l0ZSBvIGEgb3R0byB1c2NpdGUpLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX1pvbmUtQ29ubmVjdGl2aXR5X3RhZzZAQFwiOiBcIjxzdHJvbmc+SU5DUk9DSU88L3N0cm9uZz46IHZlcmlmaWNhIGxhIGNvbm5lc3Npb25lIHRyYW1pdGUgaSByZXF1aXNpdGkgc3BhemlhbGkgc3BlY2lmaWNhdGkgZGFsIG51bWVybyBkZWwgcGFyYW1ldHJvIGRpIHZpY2luaSB0cmEgY2VsbGUgY29uIHF1YWxzaWFzaSB2YWxvcmUsIGZhdHRhIGVjY2V6aW9uZSBwZXIgaWwgdmFsb3JlIGRhIGVzY2x1ZGVyZSBkYWwgcGFyYW1ldHJvIGRlbCB2YWxvcmUgZXNjbHVzby5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLUNvbm5lY3Rpdml0eV90YWc4QEBcIjogXCJRdWFuZG8gc2kgdXRpbGl6emEgcXVlc3RhIG9wemlvbmUsIMOoIG5lY2Vzc2FyaW8gc3BlY2lmaWNhcmUgdW4gdmFsb3JlIHBlciBpbCBwYXJhbWV0cm8gPHN0cm9uZz5WYWxvcmUgZXNjbHVzbzwvc3Ryb25nPi5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgb2JibGlnYXRvcmlvIGxlIGN1aSByZWdpb25pIGNvbm5lc3NlIHVuaXZvY2hlIHZlcnJhbm5vIGlkZW50aWZpY2F0ZS5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLVJhc3Rlcl90YWcxQEBcIjogXCJEZXZlIGVzc2VyZSBkaSB0aXBvIG51bWVybyBpbnRlcm8uXCIsXG5cdFwiQEBSZWdpb24tR3Jvd19GaWxsLVZhbHVlLUZpZWxkX3RhZzBAQFwiOiBcIklsIGNhbXBvIG5lbGxhIHRhYmVsbGEgZGVnbGkgYXR0cmlidXRpIGNoZSBkZWZpbmlzY2UgaWwgdmFsb3JlIGRpIHJpZW1waW1lbnRvIHBlciBpIGdydXBwaSBkaSBwaXhlbC4gSW4gdW7igJlpbW1hZ2luZSBtdWx0aWJhbmRhLCBhIHR1dHRlIGxlIGJhbmRlIHZpZW5lIGFzc2VnbmF0byBxdWVzdG8gdmFsb3JlLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3dfTWF4LUdyb3d0aC1SYWRpdXMtRmllbGRfdGFnMEBAXCI6IFwiSWwgY2FtcG8gbmVsbGEgdGFiZWxsYSBkZWdsaSBhdHRyaWJ1dGkgY2hlIGRlZmluaXNjZSBpbCByYWdnaW8gZGkgY3Jlc2NpdGEgbWFzc2ltYSBuZWxsZSB1bml0w6AgZGkgcmlmZXJpbWVudG8gc3BhemlhbGUgZGVsbOKAmWltbWFnaW5lLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3dfUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBzdSBjdWkgZXNlZ3VpcmUgcXVlc3RhIGZ1bnppb25lLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3dfU2VlZC1Qb2ludHNfdGFnMEBAXCI6IFwiVW5hIEZlYXR1cmUgQ2xhc3MgcHVudHVhbGUgY2hlIGZ1bmdlIGRhIHNlZWQgaW5pemlhbGkgcGVyIGzigJlhbGdvcml0bW8uIE9nbmkgcHVudG8gZGkgc2VlZCBjb3JyaXNwb25kZSBhZCB1bmEgdm9jZSBuZWxsYSB0YWJlbGxhIGRlZ2xpIGF0dHJpYnV0aSwgY2hlIGNvbnRpZW5lIGlsIHJhZ2dpbyBkaSBjcmVzY2l0YSBtYXNzaW1hLCBsYSBzb2dsaWEgZGkgc29taWdsaWFuemEgZSBsZSBpbmZvcm1hemlvbmkgc3VsIHZhbG9yZSBkaSByaWVtcGltZW50by5cIixcblx0XCJAQFJlZ2lvbi1Hcm93X1NpbWlsYXJpdHktVGhyZXNob2xkLUZpZWxkX3RhZzBAQFwiOiBcIklsIGNhbXBvIG5lbGxhIHRhYmVsbGEgZGVnbGkgYXR0cmlidXRpIGNoZSBkZWZpbmlzY2UgbGEgc29nbGlhIGRpIHNvbWlnbGlhbnphLCBjb21lIGRpc3RhbnphIGV1Y2xpZGVhIG5lbGxvIHNwYXppbyBzcGV0dHJhbGUuXCIsXG5cdFwiQEBSZW1hcF9BbGxvdy1Vbm1hdGNoZWQtUGl4ZWwtVmFsdWVzX3RhZzBAQFwiOiBcIkkgdmFsb3JpIG1hbmNhbnRpIG5lbGxhIHRhYmVsbGEgZGkgcmljbGFzc2lmaWNhemlvbmUgcG9zc29ubyBtYW50ZW5lcmUgaWwgbG9ybyB2YWxvcmUgbyBlc3NlcmUgcmltYXBwYXRpIGNvbWUgTm9EYXRhLlwiLFxuXHRcIkBAUmVtYXBfQWxsb3ctVW5tYXRjaGVkLVBpeGVsLVZhbHVlc190YWcxQEBcIjogXCJEZXNlbGV6aW9uYXRvIC0gT2duaSBwaXhlbCBkZWwgcmFzdGVyIGRpIGlucHV0IGNoZSBub24gdmllbmUgcmljbGFzc2lmaWNhdG8gaW4gdW5hIHRhYmVsbGEgZGkgcmVtYXAgbWFudGVycsOgIGlsIHN1byB2YWxvcmUgZSBzYXLDoCBzY3JpdHRvIHBlciBsYSBzdWEgcG9zaXppb25lIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTaSB0cmF0dGEgZGVsbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBSZW1hcF9BbGxvdy1Vbm1hdGNoZWQtUGl4ZWwtVmFsdWVzX3RhZzJAQFwiOiBcIlNlbGV6aW9uYXRvOiBpbCB2YWxvcmUgZGkgY2lhc2N1biBwaXhlbCBkZWwgcmFzdGVyIGRpIGlucHV0IG5vbiByaWNsYXNzaWZpY2F0byBpbiB1bmEgdGFiZWxsYSBkaSByaW1hcHBhdHVyYSBzYXLDoCByaW1hcHBhdG8gY29tZSBOb0RhdGEgcGVyIGlsIHN1byBwb3NpemlvbmFtZW50byBuZWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQFJlbWFwX0lucHV0LUZpZWxkX3RhZzBAQFwiOiBcIkNvbnNlbnRlIGRpIHNjZWdsaWVyZSBpbCBjYW1wbyBjaGUgc3BlY2lmaWNhIGlsIHZhbG9yZSBkaSBwaXhlbCBkaSBpbnB1dCBjaGUgc2Fyw6AgcmltYXBwYXRvLlwiLFxuXHRcIkBAUmVtYXBfSW5wdXQtRmllbGRfdGFnMUBAXCI6IFwiU2UgbGEgdGFiZWxsYSBoYSB1biBpbnRlcnZhbGxvIGRpIHZhbG9yaSwgcXVlc3RvIHNhcsOgIGlsIGNhbXBvIGRlbCB2YWxvcmUgbWluaW1vIGUgb2Njb3JyZXLDoCBzcGVjaWZpY2FyZSBhbmNoZSBpbCBwYXJhbWV0cm8gPHN0cm9uZz5DYW1wbyBtYXggZGkgaW5wdXQ8L3N0cm9uZz4uXCIsXG5cdFwiQEBSZW1hcF9JbnB1dC1NYXgtRmllbGRfdGFnMEBAXCI6IFwiQ29uc2VudGUgZGkgc2NlZ2xpZXJlIGlsIGNhbXBvIGRlbCB2YWxvcmUgbWFzc2ltbyBsYWRkb3ZlIG5lbGxhIHRhYmVsbGEgc2lhIHNwZWNpZmljYXRvIHVuIGludGVydmFsbG8gZGkgdmFsb3JpLlwiLFxuXHRcIkBAUmVtYXBfTGlzdF90YWcwQEBcIjogXCJDb25zZW50ZSBkaSBzcGVjaWZpY2FyZSBpIHZhbG9yaSBkZWxsYSBtYXBwYSwgbCdpbnRlcnZhbGxvIGRpIHZhbG9yaSBtaW5pbW8gZSBtYXNzaW1vIGUgaSBudW92aSB2YWxvcmkgZGkgcmltYXBwYXR1cmEuIElub2x0cmUsIGwnaW50ZXJ2YWxsbyBkaSB2YWxvcmkgcHXDsiBlc3NlcmUgaW1wb3N0YXRvIGNvbWUgcGl4ZWwgTm9EYXRhLlwiLFxuXHRcIkBAUmVtYXBfT3V0cHV0LUZpZWxkX3RhZzBAQFwiOiBcIkNvbnNlbnRlIGRpIHNjZWdsaWVyZSBpbCBjYW1wbyBjaGUgc2Fyw6AgdXNhdG8gY29tZSB2YWxvcmUgZGkgb3V0cHV0IHJpbWFwcGF0by5cIixcblx0XCJAQFJlbWFwX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBSZW1hcF9SZW1hcC1EZWZpbml0aW9uLVR5cGVfdGFnMEBAXCI6IFwiU2VsZXppb25hcmUgbCdvcHppb25lIGNoZSBzaSBkZXNpZGVyYSBpbXBpZWdhcmUgcGVyIGltcG9zdGFyZSBpIHZhbG9yaSBkaSByaW1hcHBhdHVyYTpcIixcblx0XCJAQFJlbWFwX1JlbWFwLURlZmluaXRpb24tVHlwZV90YWcxQEBcIjogXCJFbGVuY286IHNwZWNpZmljYW5kbyB1biBpbnRlcnZhbGxvIGRpIHZhbG9yZSBkaSBwaXhlbCBkYSBtYXBwYXJlIGluIHVuIHZhbG9yZSBkaSBwaXhlbCBkaSBvdXRwdXRcIixcblx0XCJAQFJlbWFwX1JlbWFwLVRhYmxlLVR5cGVfdGFnMEBAXCI6IFwiQ29uc2VudGUgZGkgc2NlZ2xpZXJlIGlsIHRpcG8gZGkgdGFiZWxsYSBkYSB1c2FyZSBwZXIgcmltYXBwYXJlIGlsIHJhc3RlciBkaSBpbnB1dDpcIixcblx0XCJAQFJlbWFwX1JlbWFwLVRhYmxlLVR5cGVfdGFnMUBAXCI6IFwiU2VtcGxpY2U6IHVzYSBsJ2lucHV0IGRlbGxhIDxzdHJvbmc+VGFiZWxsYSBkaSByaW1hcHBhdHVyYTwvc3Ryb25nPiBwZXIgcmltYXBwYXJlIGkgdmFsb3JpIGRpIHBpeGVsIGRlbCA8c3Ryb25nPkNhbXBvIGRpIGlucHV0PC9zdHJvbmc+IG5laSB2YWxvcmkgY29ycmlzcG9uZGVudGkgZGVsIHBhcmFtZXRybyA8c3Ryb25nPkNhbXBvIGRpIG91dHB1dDwvc3Ryb25nPi4gUXVlc3RvIG1ldG9kbyBtZW1vcml6emEgbmVsbGEgY2FjaGUgbGEgdGFiZWxsYSBkaSByaW1hcHBhdHVyYSBpbiBtb2RvIGNoZSBwb3NzYSBlc3NlcmUgZXNlZ3VpdGEgcGnDuSByYXBpZGFtZW50ZS5cIixcblx0XCJAQFJlbWFwX1JlbWFwLVRhYmxlLVR5cGVfdGFnOEBAXCI6IFwiRGluYW1pY286IHF1ZXN0byBtZXRvZG8gbm9uIG1lbW9yaXp6YSBuZWxsYSBjYWNoZSBsYSB0YWJlbGxhIGRpIHJpbWFwcGF0dXJhLCBwZXJ0YW50byBlc2VndWUgdW4naW50ZXJyb2dhemlvbmUgb2duaSB2b2x0YSBjaGUgdmllbmUgZWZmZXR0dWF0YSB1bmEgcmljaGllc3RhIChwYW4sIHpvb20gbyBhZ2dpb3JuYSkuIFNlIGxhIHRhYmVsbGEgY2FtYmlhLCBsYSByaWNoaWVzdGEgc3VjY2Vzc2l2YSByaW1hcHBlcsOgIGRpbmFtaWNhbWVudGUgaSB2YWxvcmkgZGkgY29uc2VndWVuemEuXCIsXG5cdFwiQEBSZW1hcF9SZW1hcC1UYWJsZS1UeXBlX3RhZzlAQFwiOiBcIlJpYXNzZWduYXppb25lOiBwZXIgaWwgcHJvY2Vzc28gZGkgcmljbGFzc2lmaWNhemlvbmUgdmllbmUgdXNhdGEgdW5hIHRhYmVsbGEgc3BlY2lmaWNhLCBpbiBjdWkgb2duaSByaWdhIHNhcsOgIHJpbWFwcGF0YSBzb2x0YW50byBpbiBiYXNlIGEgY2lhc2N1biBjb25maW5lIGRpIGZlYXR1cmUuXCIsXG5cdFwiQEBSZW1hcF9SZW1hcC1UYWJsZV90YWcwQEBcIjogXCJDb25zZW50ZSBkaSBuYXZpZ2FyZSBhbGwnaW50ZXJubyBkZWxsYSB0YWJlbGxhIGNoZSBpbXBvc3RhIGkgdmFsb3JpIGRpIHJpbWFwcGF0dXJhLlwiLFxuXHRcIkBAUmVwcm9qZWN0X1Jhc3Rlcl90YWcwQEBcIjogXCJJbCBkYXRhc2V0IHJhc3RlciBkYSByaXByb2lldHRhcmUgbyByaWNhbXBpb25hcmUuXCIsXG5cdFwiQEBSZXByb2plY3RfU3BhdGlhbC1SZWZlcmVuY2VfdGFnMEBAXCI6IFwiSWwgc2lzdGVtYSBkaSBjb29yZGluYXRlIHVzYXRvIHBlciByaXByb2lldHRhcmUgaSBkYXRpLlwiLFxuXHRcIkBAUmVwcm9qZWN0X1gtQ2VsbHNpemVfdGFnMEBAXCI6IFwiTGEgZGltZW5zaW9uZSB4IGFsbGEgcXVhbGUgc2kgZG92cmViYmVybyByaWNhbXBpb25hcmUgaSBkYXRpLiBGYWNvbHRhdGl2YS4gU2UgaWwgdmFsb3JlIMOoIDAgbyBtZW5vLCBsJ2VudmVsb3BlIGRlbGwnb3V0cHV0IChlc3RlbnNpb25lIGUgZGltZW5zaW9uaSBjZWxsYSkgdmllbmUgY2FsY29sYXRhIGRhbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBSZXByb2plY3RfWC1SZWdpc3RyYXRpb24tUG9pbnRfdGFnMEBAXCI6IFwiTGEgY29vcmRpbmF0YSB4IHVzYXRhIHBlciBkZWZpbmlyZSBsJ2FuZ29sbyBpbiBhbHRvIGEgc2luaXN0cmEgZGVsIGRhdGFzZXQuIFF1ZXN0YSBjb29yZGluYXRhIGRldmUgZXNzZXJlIGRlZmluaXRhIG5lbGxlIHVuaXTDoCBkZWwgbnVvdm8gcmlmZXJpbWVudG8gc3BhemlhbGUuIFNlIHNpYSBpbCBwYXJhbWV0cm8gPHN0cm9uZz5EaW1lbnNpb25lIGNlbGxhIFg8L3N0cm9uZz4gZSA8c3Ryb25nPkRpbWVuc2lvbmUgY2VsbGEgWTwvc3Ryb25nPiBzb25vIG1hZ2dpb3JpIGRpIDAsIHZlbmdvbm8gdXNhdGkgaW5zaWVtZSBhaSBwYXJhbWV0cmkgPHN0cm9uZz5QdW50byBkaSByZWdpc3RyYXppb25lIFg8L3N0cm9uZz4gZSA8c3Ryb25nPlB1bnRvIGRpIHJlZ2lzdHJhemlvbmUgWTwvc3Ryb25nPiBwZXIgZGVmaW5pcmUgbCdlbnZlbG9wZSBkZWxsJ291dHB1dC5cIixcblx0XCJAQFJlcHJvamVjdF9ZLUNlbGxzaXplX3RhZzBAQFwiOiBcIkxhIGRpbWVuc2lvbmUgWSBhbGxhIHF1YWxlIHNpIGRvdnJlYmJlcm8gcmljYW1waW9uYXJlIGkgZGF0aS4gRmFjb2x0YXRpdmEuIFNlIGlsIHZhbG9yZSDDqCAwIG8gbWVubywgbCdlbnZlbG9wZSBkZWxsJ291dHB1dCAoZXN0ZW5zaW9uZSBlIGRpbWVuc2lvbmkgY2VsbGEpIHZpZW5lIGNhbGNvbGF0YSBkYWwgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAUmVwcm9qZWN0X1ktUmVnaXN0cmF0aW9uLVBvaW50X3RhZzBAQFwiOiBcIkxhIGNvb3JkaW5hdGEgWSB1c2F0YSBwZXIgZGVmaW5pcmUgbCdhbmdvbG8gaW4gYWx0byBhIHNpbmlzdHJhIGRlbCBkYXRhc2V0LiBRdWVzdGEgY29vcmRpbmF0YSBkZXZlIGVzc2VyZSBkZWZpbml0YSBuZWxsZSB1bml0w6AgZGVsIG51b3ZvIHJpZmVyaW1lbnRvIHNwYXppYWxlLiBTZSBzaWEgaWwgcGFyYW1ldHJvIDxzdHJvbmc+RGltZW5zaW9uZSBjZWxsYSBYPC9zdHJvbmc+IGUgPHN0cm9uZz5EaW1lbnNpb25lIGNlbGxhIFk8L3N0cm9uZz4gc29ubyBtYWdnaW9yaSBkaSAwLCB2ZW5nb25vIHVzYXRpIGluc2llbWUgYWkgcGFyYW1ldHJpIDxzdHJvbmc+UHVudG8gZGkgcmVnaXN0cmF6aW9uZSBYPC9zdHJvbmc+IGUgPHN0cm9uZz5QdW50byBkaSByZWdpc3RyYXppb25lIFk8L3N0cm9uZz4gcGVyIGRlZmluaXJlIGwnZW52ZWxvcGUgZGVsbCdvdXRwdXQuXCIsXG5cdFwiQEBSZXNhbXBsZV9JbnB1dC1DZWxsc2l6ZV90YWcwQEBcIjogXCJMYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIGRlbCBwaXhlbCBkZWwgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAUmVzYW1wbGVfT3V0cHV0LUNlbGxzaXplX3RhZzBAQFwiOiBcIkxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgZGVsIHBpeGVsIGRlbCByYXN0ZXIgZGkgb3V0cHV0LiDDiCBwb3NzaWJpbGUgY2FtYmlhcmUgbGEgZGltZW5zaW9uZSBkZWxsZSBjZWxsZSwgbWEgbCdlc3RlbnNpb25lIGRlbCByYXN0ZXIgZGF0YXNldCByaW1hcnLDoCBsbyBzdGVzc28uIElsIHJpY2FtcGlvbmFtZW50byBlc2VndWl0byBkYSB1bmEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBkZWZpbml0YSBkYWxsJ3V0ZW50ZSBwdcOyIGVzc2VyZSBtb2x0byBwacO5IGxlbnRvIHJpc3BldHRvIGEgcXVlbGxvIHByZWRlZmluaXRvIGRlbCBzaXN0ZW1hLCBwb2ljaMOpIGlsIHJpY2FtcGlvbmFtZW50byBwcmVkZWZpbml0byBkZWwgc2lzdGVtYSBlbGFib3JhIGxhIHF1YW50aXTDoCBtaW5pbWEgZGkgZGF0aSBkYWxsYSByaXNvbHV6aW9uZSBwacO5IHZpY2luYSBwb3NzaWJpbGUuXCIsXG5cdFwiQEBSZXNhbXBsZV9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IGRhIHJpY2FtcGlvbmFyZS5cIixcblx0XCJAQFJlc2FtcGxlX1Jlc2FtcGxpbmctVHlwZV90YWcwQEBcIjogXCI8c3Ryb25nPlZpY2lubyBwacO5IHByb3NzaW1vPC9zdHJvbmc+OiBjYWxjb2xhIGlsIHZhbG9yZSBkZWwgcGl4ZWwgZGkgb3V0cHV0IHVzYW5kbyBpbCBwaXhlbCBkaSBpbnB1dCBwacO5IHZpY2luby4gSSBwaXhlbCBOb0RhdGEgcmltYXJyYW5ubyBpbnZhcmlhdGkgbmVsIGRhdGFzZXQgcmFzdGVyIGRpIG91dHB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzJAQFwiOiBcIjxzdHJvbmc+SW50ZXJwb2xhemlvbmUgYmlsaW5lYXJlPC9zdHJvbmc+OiBjYWxjb2xhIGlsIHZhbG9yZSBkaSBwaXhlbCB1c2FuZG8gaWwgdmFsb3JlIHZlcmlmaWNhdG8gYSBkaXN0YW56YSBkZWkgcXVhdHRybyBwaXhlbCBwacO5IHZpY2luaS4gUXVlc3RvIMOoIHVuIG1ldG9kbyBkaSBjYWxjb2xvIGVmZmljaWVudGUgZGEgZWxhYm9yYXJlLlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzRAQFwiOiBcIjxzdHJvbmc+Q29udm9sdXppb25lIGN1YmljYTwvc3Ryb25nPjogZGV0ZXJtaW5hIGlsIG51b3ZvIHZhbG9yZSBkaSB1biBwaXhlbCBiYXNhbmRvc2kgc3VsbCdhZGF0dGFtZW50byBkaSB1bmEgY3VydmEgc211c3NhdGEgYXR0cmF2ZXJzbyBpIDE2IGNlbnRyaSBkZWkgcGl4ZWwgZGkgaW5wdXQgcGnDuSB2aWNpbmkuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnNkBAXCI6IFwiPHN0cm9uZz5NYWdnaW9yYW56YTwvc3Ryb25nPjogY2FsY29sYSBpbCB2YWxvcmUgZGkgcGl4ZWwgdXNhbmRvIGlsIHZhbG9yZSBkaSBwaXhlbCBkaSBtYWdnaW9yYW56YSBuZWkgMTYgcGl4ZWwgcGnDuSB2aWNpbmkuIEkgcGl4ZWwgTm9EYXRhIHJpbWFycmFubm8gaW52YXJpYXRpIG5lbCBkYXRhc2V0IHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnOEBAXCI6IFwiPHN0cm9uZz5JbnRlcnBvbGF6aW9uZSBiaWxpbmVhcmUgUGx1czwvc3Ryb25nPjogdXRpbGl6emEgPHN0cm9uZz5JbnRlcnBvbGF6aW9uZSBiaWxpbmVhcmU8L3N0cm9uZz4sIGZhdHRhIGVjY2V6aW9uZSBwZXIgaSBwaXhlbCBsdW5nbyBpIG1hcmdpbmksIGRlZmluaXRpIGNvbWUgTm9EYXRhIGUgY2hlIG5vbiBzb25vIHJlcGxpY2F0aSBvIGNvbnNpZGVyYXRpIG5laSBjYWxjb2xpLiBVdGlsaXp6YXJlIDxzdHJvbmc+SW50ZXJwb2xhemlvbmUgYmlsaW5lYXJlIFBsdXM8L3N0cm9uZz4gcGVyIGkgZGF0aSBkaSB0aWxlIHBvaWNow6kgaSBtYXJnaW5pIG1vc3RyZXJhbm5vIGNvcnJpc3BvbmRlbnplIG1pZ2xpb3JpLlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzE0QEBcIjogXCI8c3Ryb25nPlNmb2NhdHVyYSBnYXVzc2lhbmE8L3N0cm9uZz46IGFwcGxpY2EgdW5hIGNvbnZvbHV6aW9uZSBnYXVzc2lhbmEgYWwgcmFzdGVyIGRpIG9yaWdpbmUgZSBjYWxjb2xhIGkgdmFsb3JpIGRpIHBpeGVsIHV0aWxpenphbmRvIGlsIHZhbG9yZSB2ZXJpZmljYXRvIGRpIGRpc3RhbnphIGRlaSBxdWF0dHJvIHBpeGVsIHBpw7kgdmljaW5pIHByb3ZlbmllbnRpIGRhbCByYXN0ZXIgc2ZvY2F0by4gw4ggYXBwcm9wcmlhdG8gcGVyIGxhIHJpbW96aW9uZSBkaSBydW1vcmUgZGFpIGRhdGkgcmljYW1waW9uYXRpIGUgcGVyIGlsIHJpY2FtcGlvbmFtZW50byB2ZXJzbyBpbCBiYXNzbyBwZXIgb3R0ZW5lcmUgdW5hIGRpbWVuc2lvbmUgZGkgcGl4ZWwgbWFnZ2lvcmUuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnMTZAQFwiOiBcIjxzdHJvbmc+U2ZvY2F0dXJhIGdhdXNzaWFuYSBQbHVzPC9zdHJvbmc+OiB1dGlsaXp6YSBsbyBzdGVzc28gbWV0b2RvIGRpIDxzdHJvbmc+U2ZvY2F0dXJhIGdhdXNzaWFuYTwvc3Ryb25nPiwgZmF0dGEgZWNjZXppb25lIHBlciBpIHBpeGVsIGx1bmdvIGkgbWFyZ2luaSwgZGVmaW5pdGkgY29tZSBOb0RhdGEgZSBjaGUgbm9uIHNvbm8gcmVwbGljYXRpIG8gY29uc2lkZXJhdGkgbmVpIGNhbGNvbGkuIFV0aWxpenphcmUgPHN0cm9uZz5TZm9jYXR1cmEgZ2F1c3NpYW5hIFBsdXM8L3N0cm9uZz4gcGVyIGkgZGF0aSBkaSB0aWxlIHBvaWNow6kgaSBtYXJnaW5pIG1vc3RyZXJhbm5vIGNvcnJpc3BvbmRlbnplIG1pZ2xpb3JpLlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzIyQEBcIjogXCI8c3Ryb25nPk1lZGlhPC9zdHJvbmc+OiBjYWxjb2xhIGkgdmFsb3JpIGRpIHBpeGVsIHV0aWxpenphbmRvIGlsIHZhbG9yZSBtZWRpbyBkaSB0dXR0aSBpIHBpeGVsIGRpIHNvdnJhcHBvc2l6aW9uZSwgcGVyIG9nbmkgcGl4ZWwgdGFyZ2V0LlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzI0QEBcIjogXCI8c3Ryb25nPk1pbmltbzwvc3Ryb25nPjogY2FsY29sYSBpbCB2YWxvcmUgZGkgcGl4ZWwgdXRpbGl6emFuZG8gaWwgdmFsb3JlIG1pbmltbyBkaSB0dXR0aSBpIHBpeGVsIGRpIHNvdnJhcHBvc2l6aW9uZS4gSSBwaXhlbCBOb0RhdGEgcmltYXJyYW5ubyBpbnZhcmlhdGkgbmVsIGRhdGFzZXQgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQFJlc2FtcGxlX1Jlc2FtcGxpbmctVHlwZV90YWcyNkBAXCI6IFwiPHN0cm9uZz5NYXNzaW1vPC9zdHJvbmc+OiBpZG9uZW8gcGVyIGkgZGF0aSBjb250aW51aSwgcHJvZHVjZSB1bidpbW1hZ2luZSBkaSBvdXRwdXQgcGnDuSBtb3JiaWRhIHJpc3BldHRvIGFsIG1ldG9kbyBkaSByaWNhbXBpb25hbWVudG8gVmljaW5vIHBpw7kgcHJvc3NpbW8uXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnMjhAQFwiOiBcIjxzdHJvbmc+TWVkaWEgdmV0dG9yaWFsZTwvc3Ryb25nPjogY2FsY29sYSBsYSBtZWRpYSB2ZXR0b3JpYWxlIGRlbGxhIG1hZ25pdHVkby1kaXJlemlvbmUgdXRpbGl6emFuZG8gdHV0dGkgaSBwaXhlbCBjb2ludm9sdGkuIFF1ZXN0byBtZXRvZG8gw6ggYXBwbGljYWJpbGUgc29sbyBwZXIgZHVlIHJhc3RlciBkaSBiYW5kYSBjaGUgcmFwcHJlc2VudGFubyBtYWduaXR1ZG8gZSBkaXJlemlvbmUuIENvbnZlcnRlIHByaW1hIGRpIHR1dHRvIGxhIG1hZ25pdHVkby1kaXJlemlvbmUgaW4gVS1WLCBxdWluZGkgcHJlbmRlIGxhIG1lZGlhIGFyaXRtZXRpY2EgZGkgdHV0dGkgaSBwaXhlbCBjb2ludm9sdGkgcGVyIG90dGVuZXJlIGwnVS1WIGRlbCBwaXhlbCB0YXJnZXQgZSBsbyBjb252ZXJ0ZSBudW92YW1lbnRlIGluIG1hZ25pdHVkby1kaXJlemlvbmUuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAUm91bmQtRG93bl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAUm91bmQtRG93bl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAUm91bmQtRG93bl9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQFJvdW5kLURvd25fRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFJvdW5kLURvd25fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAUm91bmQtRG93bl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAUm91bmQtRG93bl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX1Jhc3Rlcl90YWcwQEBcIjogXCJJIHZhbG9yaSBkaSBpbnB1dCBkYSBhcnJvdG9uZGFyZSBwZXIgZGlmZXR0by5cIixcblx0XCJAQFJvdW5kLVVwX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBSb3VuZC1VcF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAUm91bmQtVXBfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBSb3VuZC1VcF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAUm91bmQtVXBfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAUm91bmQtVXBfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBSb3VuZC1VcF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQFJvdW5kLVVwX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBSb3VuZC1VcF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBSb3VuZC1VcF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAUm91bmQtVXBfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAUm91bmQtVXBfUmFzdGVyX3RhZzBAQFwiOiBcIkkgdmFsb3JpIGRpIGlucHV0IGRhIGFycm90b25kYXJlIHBlciBlY2Nlc3NvLlwiLFxuXHRcIkBAU2VnbWVudC1NZWFuLVNoaWZ0X01pbmltdW0tU2VnbWVudC1TaXplLWluLVBpeGVsc190YWcwQEBcIjogXCJEaW1lbnNpb25lIG1pbmltYSBkZWwgc2VnbWVudG8sIG1pc3VyYXRhIGluIHBpeGVsLiBRdWVzdG8gdmFsb3JlIMOoIGNvcnJlbGF0byBhbGwndW5pdMOgIGRpIG1hcHBhdHVyYSBtaW5pbWEsIGUgZmlsdHJlcsOgIGkgYmxvY2NoaSBkaSBwaXhlbCBwacO5IHBpY2NvbGkuIFR1dHRpIGkgc2VnbWVudGkgcGnDuSBwaWNjb2xpIGRlbCB2YWxvcmUgc3BlY2lmaWNhdG8gdW5pcmFubm8gaSBzZWdtZW50aSBwacO5IHBpY2NvbGkgY29uIGlsIHNlZ21lbnRvIHZpY2lubyBwacO5IGFkZWd1YXRvLlwiLFxuXHRcIkBAU2VnbWVudC1NZWFuLVNoaWZ0X1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgZGEgc2VnbWVudGFyZS5cIixcblx0XCJAQFNlZ21lbnQtTWVhbi1TaGlmdF9TZWdtZW50LWJvdW5kYXJpZXMtb25seV90YWcwQEBcIjogXCJJIGNvbmZpbmkgZGVsIHNlZ21lbnRvIGRpc2VnbmF0aSBjb21lIHVuYSBsaW5lYSBkaSBjb250b3JubyBuZXJhIGludG9ybm8gYSBvZ25pIHNlZ21lbnRvLiBRdWVzdG8gw6ggZCdhaXV0byBwb2ljaMOpIGNvbnNlbnRlIGRpIGRpc3Rpbmd1ZXJlIGkgc2VnbWVudGkgYWRpYWNlbnRpIGNoZSBoYW5ubyBjb2xvcmkgc2ltaWxpLlwiLFxuXHRcIkBAU2VnbWVudC1NZWFuLVNoaWZ0X1NlZ21lbnQtYm91bmRhcmllcy1vbmx5X3RhZzFAQFwiOiBcIk5vbiBzZWxlemlvbmF0bzogaSBjb25maW5pIGRlbCBzZWdtZW50byBub24gdmVuZ29ubyB2aXN1YWxpenphdGkuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFNlZ21lbnQtTWVhbi1TaGlmdF9TZWdtZW50LWJvdW5kYXJpZXMtb25seV90YWcyQEBcIjogXCJTZWxlemlvbmF0bzogaSBjb25maW5pIGRlbCBzZWdtZW50byB2ZW5nb25vIHZpc3VhbGl6emF0aSBjb24gbGluZWUgZGkgY29udG9ybm8gbmVyZSBpbnRvcm5vIGEgb2duaSBzZWdtZW50by5cIixcblx0XCJAQFNlZ21lbnQtTWVhbi1TaGlmdF9TcGF0aWFsLURldGFpbF90YWcwQEBcIjogXCJMJ2ltcG9ydGFuemEgcmVsYXRpdmEgZGVsbGEgc2VwYXJhemlvbmUgZGVnbGkgb2dnZXR0aSBiYXNhbmRvc2kgc3VsbGUgY2FyYXR0ZXJpc3RpY2hlIHNwYXppYWxpLlwiLFxuXHRcIkBAU2VnbWVudC1NZWFuLVNoaWZ0X1NwYXRpYWwtRGV0YWlsX3RhZzFAQFwiOiBcIkkgdmFsb3JpIGludGVyaSB2YWxpZGkgc29ubyBjb21wcmVzaSB0cmEgMSBlIDIwLiBJIHZhbG9yaSBwacO5IHBpY2NvbGkgcHJvZHVjb25vIGNsYXNzaSBwacO5IGFtcGllIGUgcGnDuSBzbXVzc2F0dXJhLiBVbiB2YWxvcmUgcGnDuSBhbHRvIMOoIGFwcHJvcHJpYXRvIHBlciBkaXN0aW5ndWVyZSBsZSBmZWF0dXJlIGNoZSBzb25vIHNwYXppYWxtZW50ZSBwaWNjb2xlIGUgcmFnZ3J1cHBhdGUuIEFkIGVzZW1waW8sIGluIHVuYSBzY2VuYSB1cmJhbmEsIHNpIHBvdHJlYmJlcm8gY2xhc3NpZmljYXJlIGxlIGZlYXR1cmUgZ2VuZXJhbGkgZGkgc3VwZXJmaWNpZSBpbXBlcnZpYSB1dGlsaXp6YW5kbyB1biB2YWxvcmUgZGkgZGV0dGFnbGlvIHNwYXppYWxlIHBpw7kgcGljY29sbywgbyBzaSBwb3RyZWJiZXJvIGNsYXNzaWZpY2FyZSBlZGlmaWNpIGUgc3RyYWRlIGNvbWUgY2xhc3NpIHNlcGFyYXRlIHV0aWxpenphbmRvIHVuIHZhbG9yZSBkaSBkZXR0YWdsaW8gc3BhemlhbGUgcGnDuSBhbHRvLlwiLFxuXHRcIkBAU2VnbWVudC1NZWFuLVNoaWZ0X1NwZWN0cmFsLURldGFpbF90YWcwQEBcIjogXCJMJ2ltcG9ydGFuemEgcmVsYXRpdmEgZGVsbGEgc2VwYXJhemlvbmUgZGVnbGkgb2dnZXR0aSBiYXNhbmRvc2kgc3VsbGUgY2FyYXR0ZXJpc3RpY2hlIGNyb21hdGljaGUuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfU3BlY3RyYWwtRGV0YWlsX3RhZzFAQFwiOiBcIkkgdmFsb3JpIGEgdmlyZ29sYSBtb2JpbGUgdmFsaWRpIHNvbm8gY29tcHJlc2kgdHJhIDEsMCBlIDIwLDAuIEkgdmFsb3JpIHBpw7kgcGljY29saSBwcm9kdWNvbm8gY2xhc3NpIHBpw7kgYW1waWUgZSBwacO5IHNtdXNzYXR1cmEuIFVuIHZhbG9yZSBwacO5IGFsdG8gw6ggYXBwcm9wcmlhdG8gcXVhbmRvIHNpIHZ1b2xlIGRpZmZlcmVuemlhcmUgbGUgZmVhdHVyZSBjaGUgaGFubm8gaW4gcXVhbGNoZSBtb2RvIGRlbGxlIGNhcmF0dGVyaXN0aWNoZSBzcGV0dHJhbGkgc2ltaWxpLiBBZCBlc2VtcGlvLCB1dGlsaXp6YW5kbyB1biB2YWxvcmUgZGkgZGV0dGFnbGlvIHNwZXR0cmFsZSBtYWdnaW9yZSBpbiB1bmEgc2NlbmEgZm9yZXN0YWxlLCBhdnJlbW8gbGEgcG9zc2liaWxpdMOgIGRpIGRpc3Rpbmd1ZXJlIG1lZ2xpbyBsZSBkaXZlcnNlIHNwZWNpZSBkaSBhbGJlcmkuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfbWF4aW11bXNlZ21lbnRzaXplaW5waXhlbHNfdGFnMEBAXCI6IFwiPHA+TGEgZGltZW5zaW9uZSBtYXNzaW1hIGRpIHVuIHNlZ21lbnRvLiBJIHNlZ21lbnRpIGNoZSBzb25vIHBpw7kgZ3JhbmRpIGRlbGxhIGRpbWVuc2lvbmUgc3BlY2lmaWNhdGEgc2FyYW5ubyBkaXZpc2kuIFVzYSBxdWVzdG8gcGFyYW1ldHJvIHBlciBldml0YXJlIGFydGVmYXR0aSBuZWwgbGl2ZWxsbyBkaSB1c2NpdGEgZGVyaXZhbnRpIGRhIHNlZ21lbnRpIGRpIGdyYW5kaSBkaW1lbnNpb25pLiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggLTEuPC9wPlwiLFxuXHRcIkBAU2VudGluZWwtMS1SYWRpb21ldHJpYy1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzBAQFwiOiBcIlNlbGV6aW9uYXJlIHVubyBkZWkgcXVhdHRybyB0aXBpIGRpIGNhbGlicmF6aW9uZTpcIixcblx0XCJAQFNlbnRpbmVsLTEtUmFkaW9tZXRyaWMtQ2FsaWJyYXRpb25fQ2FsaWJyYXRpb24tVHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPkJldGEtemVybzwvc3Ryb25nPjogcHJvZHVjZSB1biBvdXRwdXQgY2hlIGNvbnRpZW5lIGlsIGNvZWZmaWNpZW50ZSBkaSBsdW1pbm9zaXTDoCBkZWwgcmFkYXIuXCIsXG5cdFwiQEBTZW50aW5lbC0xLVJhZGlvbWV0cmljLUNhbGlicmF0aW9uX0NhbGlicmF0aW9uLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5TaWdtYS16ZXJvPC9zdHJvbmc+OiBsYSByZXRyb2RpZmZ1c2lvbmUgcmVzdGl0dWl0YSBhbGwnYW50ZW5uYSBkYSB1bidhcmVhIGRpIHVuaXTDoCBzdWwgdGVycmVubywgY29ycmVsYXRhIGFsbCdpbnRlcnZhbGxvIGRlbCB0ZXJyZW5vLlwiLFxuXHRcIkBAU2VudGluZWwtMS1SYWRpb21ldHJpYy1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzVAQFwiOiBcIjxzdHJvbmc+R2FtbWE8L3N0cm9uZz46IG1pc3VyYXppb25lIGRlbGwnZW5lcmdpYSBlbWVzc2EgZSByZXN0aXR1aXRhLCB1dGlsZSBwZXIgbGEgZGV0ZXJtaW5hemlvbmUgZGVpIG1vZGVsbGkgZGVsbCdhbnRlbm5hLlwiLFxuXHRcIkBAU2VudGluZWwtMS1SYWRpb21ldHJpYy1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzdAQFwiOiBcIjxzdHJvbmc+TmVzc3Vubzwvc3Ryb25nPjogbm9uIGFwcGxpY2EgdW5hIGNvcnJlemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFNlbnRpbmVsLTEtUmFkaW9tZXRyaWMtQ2FsaWJyYXRpb25fUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBTZW50aW5lbC0xIExldmVsLTEgR1JEIG8gU0xDIGNoZSBzaSB2dW9sZSBlbGFib3JhcmUuXCIsXG5cdFwiQEBTZW50aW5lbC0xLVJhZGlvbWV0cmljLUNhbGlicmF0aW9uX1Jhc3Rlcl90YWcxQEBcIjogXCJMYSBmdW56aW9uZSB1dGlsaXp6ZXLDoCBpbCBmaWxlIExVVCBvIHBlciBhcHBsaWNhcmUgbGEgY29ycmV6aW9uZSB0ZXJtaWNhIG8gcGVyIHJpbXVvdmVybGEsIGEgc2Vjb25kYSBkZWkgY29udGVudXRpIGRlbCBmaWxlIExVVC5cIixcblx0XCJAQFNlbnRpbmVsLTEtVGhlcm1hbC1Ob2lzZS1SZW1vdmFsX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgU2VudGluZWwtMSBjaGUgc2kgdnVvbGUgZWxhYm9yYXJlLlwiLFxuXHRcIkBAU2VudGluZWwtMS1UaGVybWFsLU5vaXNlLVJlbW92YWxfUmFzdGVyX3RhZzFAQFwiOiBcIkxhIGZ1bnppb25lIHV0aWxpenplcsOgIGlsIGZpbGUgTFVUIG8gcGVyIGFwcGxpY2FyZSBsYSBjb3JyZXppb25lIHRlcm1pY2EgbyBwZXIgcmltdW92ZXJsYSBhIHNlY29uZGEgZGVpIGNvbnRlbnV0aSBkZWwgZmlsZSBMVVQuXCIsXG5cdFwiQEBTZXQtTnVsbF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBAU2V0LU51bGxfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFNldC1OdWxsX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAU2V0LU51bGxfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFNldC1OdWxsX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFNldC1OdWxsX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAU2V0LU51bGxfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBTZXQtTnVsbF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAU2V0LU51bGxfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAU2V0LU51bGxfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFNldC1OdWxsX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFNldC1OdWxsX0ZhbHNlLVJhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IGkgY3VpIHZhbG9yaSBzYXJhbm5vIHVzYXRpIGNvbWUgdmFsb3JpIHBpeGVsIGRpIG91dHB1dCBzZSBsYSBjb25kaXppb25lIMOoIGZhbHNlLiBQdcOyIGVzc2VyZSB1biBudW1lcm8gaW50ZXJvLCB1biByYXN0ZXIgYSB2aXJnb2xhIG1vYmlsZSBvIHVuIHZhbG9yZSBjb3N0YW50ZS5cIixcblx0XCJAQFNldC1OdWxsX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgY2hlIHJhcHByZXNlbnRhIGlsIHJpc3VsdGF0byBib29sZWFubyBkaSB1bmEgUmFzdGVyIEZ1bmN0aW9uIG1hdGVtYXRpY2EgbG9naWNhLiBJIHZhbG9yaSBzYXJhbm5vIDEgKHBlciB0cnVlKSBvIDAgKHBlciBmYWxzZSkuIFB1w7IgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8gbyB1biByYXN0ZXIgYSB2aXJnb2xhIG1vYmlsZS5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfQWx0aXR1ZGVfdGFnMEBAXCI6IFwiTCdhbHRpdHVkaW5lIMOoIGwnYW5nb2xvIGRpIGVsZXZhemlvbmUgZGVsIHNvbGUgc3VsbCdvcml6em9udGUgZSBzcGF6aWEgZGEgMCBhIDkwIGdyYWRpLiBVbiB2YWxvcmUgZGkgMCBncmFkaSBpbmRpY2EgY2hlIGlsIHNvbGUgw6ggYWxsJ29yaXp6b250ZSwgb3Z2ZXJvIHN1bGxvIHN0ZXNzbyBwaWFubyBvcml6em9udGFsZSBkZWxsYSBjb3JuaWNlIGRpIHJpZmVyaW1lbnRvLiBVbiB2YWxvcmUgZGkgOTAgZ3JhZGkgaW5kaWNhIGNoZSBpbCBzb2xlIMOoIGRpcmV0dGFtZW50ZSBzb3ByYSBkaSBub2kuIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCBkaSA0NSBncmFkaSBzb3ByYSBsJ29yaXp6b250ZS5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfQXppbXV0aF90YWcwQEBcIjogXCJMJ2F6aW11dCDDqCBsYSBwb3NpemlvbmUgcmVsYXRpdmEgZGVsIHNvbGUgbHVuZ28gbCdvcml6em9udGUgKGluIGdyYW5kaSkuIFF1ZXN0YSBwb3NpemlvbmUgw6ggaW5kaWNhdGEgZGFsbCdhbmdvbG8gZGVsIHNvbGUgbWlzdXJhdG8gaW4gc2Vuc28gb3JhcmlvIHJpc3BldHRvIGFsIG5vcmQuIFVuIGF6aW11dCBkaSAwIGdyYWRpIGluZGljYSBpbCBub3JkLCBsJ2VzdCDDqCA5MCBncmFkaSwgaWwgc3VkIMOoIDE4MCBncmFkaSBlIGwnb3Zlc3Qgw6ggMjcwIGdyYWRpLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9Db2xvci1TY2hlbWUtVHlwZV90YWcwQEBcIjogXCJTcGVjaWZpY2FyZSBzZSB2ZXJyw6AgdXRpbGl6emF0YSB1bmEgc2NhbGEgY3JvbWF0aWNhIG8gdW5hIG1hcHBhIGNvbG9yZSBwZXIgdmlzdWFsaXp6YXJlIGlsIHJpbGlldm8gb21icmVnZ2lhdG8uXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0NvbG9yLVNjaGVtZS1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+U2NhbGEgY3JvbWF0aWNhPC9zdHJvbmc+OiBxdWFuZG8gc2kgc2NlZ2xpZSB1bmEgPHN0cm9uZz5TY2FsYSBjcm9tYXRpY2E8L3N0cm9uZz4sIHZlcnLDoCByaWNoaWVzdG8gZGkgc2VsZXppb25hcmUgdW5hIHNjYWxhIGNyb21hdGljYSBhcHByb3ByaWF0YS5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfQ29sb3ItU2NoZW1lLVR5cGVfdGFnNUBAXCI6IFwiPHN0cm9uZz5NYXBwYSBjb2xvcmU8L3N0cm9uZz46IHF1YW5kbyBzaSBzY2VnbGllIDxzdHJvbmc+TWFwcGEgY29sb3JlPC9zdHJvbmc+LCB2ZXJyw6AgcmljaGllc3RvIGRpIHNwZWNpZmljYXJlIGlsIGZpbGUgbWFwcGEgZGkgY29sb3JlIGRhIHV0aWxpenphcmUuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMEBAXCI6IFwiU3BlY2lmaWNhcmUgc2UgbCdpbnRlcnBvbGF6aW9uZSBkZWwgcGl4ZWwgYm9yZG8gcHJlZGVmaW5pdGEgZGV2ZSBlc3NlcmUgZGlzYWJpbGl0YXRhIG8gbWVuby5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfRGlzYWJsZS1kZWZhdWx0LWVkZ2UtcGl4ZWwtaW50ZXJwb2xhdGlvbl90YWcxQEBcIjogXCJOb24gc2VsZXppb25hdG86IHNpIGFwcGxpY2hlcsOgIHVuIHJpY2FtcGlvbmFtZW50byBiaWxpbmVhcmUgdW5pZm9ybWUgcGVyIHJpY2FtcGlvbmFyZSBpbCByaWxpZXZvIG9tYnJlZ2dpYXRvLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMkBAXCI6IFwiU2VsZXppb25hdG86IHNpIHVzZXLDoCB1biByaWNhbXBpb25hbWVudG8gYmlsaW5lYXJlIGFsbCdpbnRlcm5vIGRlbCByaWxpZXZvIG9tYnJlZ2dpYXRvLCB0cmFubmUgbHVuZ28gaSBtYXJnaW5pIGRlaSByYXN0ZXIgbyBhY2NhbnRvIGEgcGl4ZWwgZGkgTm9EYXRhLiBRdWVzdGkgcGl4ZWwgc2FyYW5ubyBwb3BvbGF0aSBjb24gdmFsb3JlIE5vRGF0YSwgY2hlIHJpZHVycsOgIGV2ZW50dWFsaSBlZmZldHRpIGRpIG1hcmdpbmkgbmV0dGkuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnM0BAXCI6IFwiU2Ugc2kgdXNhIHF1ZXN0YSBvcHppb25lIHNpIGV2aXRlcmFubm8gcmljYW1waW9uYW1lbnRpIGNoZSBzaSBwb3Nzb25vIHZlcmlmaWNhcmUgbHVuZ28gaSBtYXJnaW5pIGRpIHVuIHJhc3Rlci4gSSBwaXhlbCBkaSBvdXRwdXQgbHVuZ28gaWwgbWFyZ2luZSBkaSB1biByYXN0ZXIgbyBhY2NhbnRvIGEgcGl4ZWwgc2VuemEgdW4gdmFsb3JlIHNhcmFubm8gcG9wb2xhdGkgY29uIE5vRGF0YTsgcXVpbmRpLCBzaSBjb25zaWdsaWEgZGkgdXNhcmUgcXVlc3RhIG9wemlvbmUgc29sbyBxdWFuZG8gY2kgc29ubyBhbHRyaSByYXN0ZXIgY29uIHBpeGVsIHNvdnJhcHBvc3RpIGRpc3BvbmliaWxpLiBRdWFuZG8gc29ubyBkaXNwb25pYmlsaSBwaXhlbCBzb3ZyYXBwb3N0aSwgcXVlc3RlIGFyZWUgZGkgTm9EYXRhIG5vbiBzYXJhbm5vIHZ1b3RlLCBtYSB2aXN1YWxpenplcmFubm8gaSB2YWxvcmkgcGl4ZWwgc292cmFwcG9zdGkuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgZWxldmF6aW9uZSBkaSBpbnB1dC5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfU2NhbGluZ190YWcwQEBcIjogXCJJbCByaXN1bHRhdG8gb21icmVnZ2lhdG8gw6ggc2NhbGF0byBkaW5hbWljYW1lbnRlIHJlZ29sYW5kbyBpbCBmYXR0b3JlIHogdXNhbmRvIHVuYSBkZWxsZSBkdWUgb3B6aW9uaSBzZWd1ZW50aTpcIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfU2NhbGluZ190YWcxQEBcIjogXCI8c3Ryb25nPk5lc3N1bm88L3N0cm9uZz46IG5vbiBzaSBhcHBsaWNhIG5lc3N1bmEgc2NhbGEuIMOIIGwnb3B6aW9uZSBpZGVhbGUgcGVyIHJhc3RlciBkYXRhc2V0IHNpbmdvbGkgcmVsYXRpdmkgYWQgdW4nYXJlYSBsb2NhbGUuIE5vbiDDqCB1bidvcHppb25lIGNvbnNpZ2xpYXRhIHBlciBpIGRhdGFzZXQgbW9uZGlhbGkgY29uIGdyYW5kaSB2YXJpYXppb25pIGluIHRlcm1pbmkgZGkgZWxldmF6aW9uZSBvIGNvbiBtYXBwZSBtdWx0aXNjYWxhLCBwb2ljaMOpIHZlcnJlYmJlIHByb2RvdHRvIHVuIHJpbGlldm8gZGVsIHRlcnJlbm8gY29uIHBpY2NvbGUgdmFyaWF6aW9uaSBlIHBpY2NvbGUgc2NhbGUuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1NjYWxpbmdfdGFnM0BAXCI6IFwiPHN0cm9uZz5SZWdvbGF0YTwvc3Ryb25nPjogc2kgYXBwbGljYSB1bmEgcmVnb2xhemlvbmUgbm9uIGxpbmVhcmUgdXNhbmRvIGkgdmFsb3JpIHByZWRlZmluaXRpIGRpIDxzdHJvbmc+UG90ZW56YSBkaW1lbnNpb25lIHBpeGVsPC9zdHJvbmc+IGUgPHN0cm9uZz5GYXR0b3JlIGRpbWVuc2lvbmUgcGl4ZWw8L3N0cm9uZz4sIGNoZSBjb21wcmVuZGUgdW4nYW1waWEgZ2FtbWEgZGkgdmFyaWF6aW9uaSBkaSBhbHRpdHVkaW5lIChzY2FsYSkgaW5ncmFuZGVuZG8gZSByaWR1Y2VuZG8gbCdpbW1hZ2luZSBjb24gbG8gem9vbS4gTCdvcHppb25lIDxzdHJvbmc+UmVnb2xhdGE8L3N0cm9uZz4gw6ggY29uc2lnbGlhdGEgcXVhbmRvIHNpIHV0aWxpenphIHVuIGRhdGFzZXQgbW9uZGlhbGUuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1otRmFjdG9yX3RhZzBAQFwiOiBcIklsIGZhdHRvcmUgWiDDqCB1biBmYXR0b3JlIGRpIHNjYWxhIHV0aWxpenphdG8gcGVyIGNvbnZlcnRpcmUgaSB2YWxvcmkgZGkgZWxldmF6aW9uZSBwZXIgZHVlIG1vdGl2aTpcIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfWi1GYWN0b3JfdGFnMUBAXCI6IFwiUGVyIGNvbnZlcnRpcmUgbGUgdW5pdMOgIGRpIGVsZXZhemlvbmUgKGFkIGVzZW1waW8sIG1ldHJpIG8gcGllZGkpIGluIHVuaXTDoCBkaSBjb29yZGluYXRlIG9yaXp6b250YWxpIGRlbCBkYXRhc2V0LCBjaGUgcG9zc29ubyBlc3NlcmUgcGllZGksIG1ldHJpIG8gZ3JhZGlcIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfWi1GYWN0b3JfdGFnMkBAXCI6IFwiUGVyIGFnZ2l1bmdlcmUgaWwgZmF0dG9yZSBkaSBtb2x0aXBsaWNhemlvbmUgdmVydGljYWxlIHBlciBvdHRlbmVyZSB1biBlZmZldHRvIHZpc2l2b1wiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9aLUZhY3Rvcl90YWczQEBcIjogXCJJbCByaXN1bHRhdG8gb21icmVnZ2lhdG8gw6ggc2NhbGF0byBkaW5hbWljYW1lbnRlIHJlZ29sYW5kbyBpbCBmYXR0b3JlIHogdXNhbmRvIHVuYSBkZWxsZSBkdWUgb3B6aW9uaSBzZWd1ZW50aTpcIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfWi1GYWN0b3JfdGFnNEBAXCI6IFwiPHN0cm9uZz5OZXNzdW5vPC9zdHJvbmc+OiBub24gc2kgYXBwbGljYSBuZXNzdW5hIHNjYWxhLiDDiCBsJ29wemlvbmUgaWRlYWxlIHBlciByYXN0ZXIgZGF0YXNldCBzaW5nb2xpIHJlbGF0aXZpIGFkIHVuJ2FyZWEgbG9jYWxlLiBOb24gw6ggdW4nb3B6aW9uZSBjb25zaWdsaWF0YSBwZXIgaSBkYXRhc2V0IG1vbmRpYWxpIGNvbiBncmFuZGkgdmFyaWF6aW9uaSBpbiB0ZXJtaW5pIGRpIGVsZXZhemlvbmUgbyBjb24gbWFwcGUgbXVsdGlzY2FsYSwgcG9pY2jDqSB2ZXJyZWJiZSBwcm9kb3R0byB1biByaWxpZXZvIGRlbCB0ZXJyZW5vIGNvbiBwaWNjb2xlIHZhcmlhemlvbmkgZSBwaWNjb2xlIHNjYWxlLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9aLUZhY3Rvcl90YWc2QEBcIjogXCI8c3Ryb25nPlJlZ29sYXRhPC9zdHJvbmc+OiBzaSBhcHBsaWNhIHVuYSByZWdvbGF6aW9uZSBub24gbGluZWFyZSB1c2FuZG8gaSB2YWxvcmkgcHJlZGVmaW5pdGkgZGkgPHN0cm9uZz5Qb3RlbnphIGRpbWVuc2lvbmUgcGl4ZWw8L3N0cm9uZz4gZSA8c3Ryb25nPkZhdHRvcmUgZGltZW5zaW9uZSBwaXhlbDwvc3Ryb25nPiwgY2hlIGNvbXByZW5kZSB1bidhbXBpYSBnYW1tYSBkaSB2YXJpYXppb25pIGRpIGFsdGl0dWRpbmUgKHNjYWxhKSBpbmdyYW5kZW5kbyBlIHJpZHVjZW5kbyBsJ2ltbWFnaW5lIGNvbiBsbyB6b29tLiBMJ29wemlvbmUgPHN0cm9uZz5SZWdvbGF0YTwvc3Ryb25nPiDDqCBjb25zaWdsaWF0YSBxdWFuZG8gc2kgdXRpbGl6emEgdW4gZGF0YXNldCBtb25kaWFsZS5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfaGlsbHNoYWRldHlwZV90YWcwQEBcIjogXCJDb250cm9sbGEgbGEgZm9udGUgZGkgaWxsdW1pbmF6aW9uZSBwZXIgbCdoaWxsc2hhZGUuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX2hpbGxzaGFkZXR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5UcmFkaXppb25hbGU8L3N0cm9uZz46IGNhbGNvbGEgbCdoaWxsc2hhZGUgZGEgdW4ndW5pY2EgZGlyZXppb25lIGRpIGlsbHVtaW5hemlvbmUuIMOIIHBvc3NpYmlsZSBpbXBvc3RhcmUgbGUgb3B6aW9uaSA8c3Ryb25nPkF6aW11dDwvc3Ryb25nPiBlIDxzdHJvbmc+QWx0aXR1ZGluZTwvc3Ryb25nPiBwZXIgY29udHJvbGxhcmUgbGEgcG9zaXppb25lIGRlbGxhIGZvbnRlIGRpIGx1Y2UuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfaGlsbHNoYWRldHlwZV90YWcyQEBcIjogXCI8c3Ryb25nPk11bHRpZGlyZXppb25hbGU8L3N0cm9uZz46IGNvbWJpbmEgbGEgbHVjZSBkYSBmb250aSBtdWx0aXBsZSBwZXIgcmFwcHJlc2VudGFyZSB1bmEgdmlzdWFsaXp6YXppb25lIG1pZ2xpb3JhdGEgZGVsIHRlcnJlbm8uXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1BTUG93ZXJfdGFnMEBAXCI6IFwiPHN0cm9uZz5Qb3RlbnphIGRpbWVuc2lvbmkgaW4gcGl4ZWw8L3N0cm9uZz4gc2kgcmlmZXJpc2NlIGFsbGUgdmFyaWF6aW9uaSBkaSBhbHRpdHVkaW5lIChvIHNjYWxhKSBpbmdyYW5kZW5kbyBlIHJpZHVjZW5kbyBsJ2ltbWFnaW5lIGNvbiBsbyB6b29tIGRlbCBWaWV3ZXIgc3VsbGEgdmlzdWFsaXp6YXppb25lIG1hcHBhLiDDiCBsJ2VzcG9uZW50ZSBhcHBsaWNhdG8gYWwgdGVybWluZSBkaW1lbnNpb25pIGluIHBpeGVsIG5lbGwnZXF1YXppb25lIGNoZSBjb250cm9sbGEgbGEgcGVyY2VudHVhbGUgYWxsYSBxdWFsZSBpbCA8c3Ryb25nPkZhdHRvcmUgWjwvc3Ryb25nPiBjYW1iaWEgcGVyIGV2aXRhcmUgdW5hIHBlcmRpdGEgc2lnbmlmaWNhdGl2YSBkaSByaWxpZXZvLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9QU1Bvd2VyX3RhZzFAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gw6ggdmFsaWRvIHNvbG8gcXVhbmRvIGlsIHRpcG8gZGkgPHN0cm9uZz5TY2FsYTwvc3Ryb25nPiDDqCA8c3Ryb25nPlJlZ29sYXRvPC9zdHJvbmc+LiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggMCw2NjQuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1BTWkZhY3Rvcl90YWcwQEBcIjogXCI8c3Ryb25nPkZhdHRvcmUgZGltZW5zaW9uaSBpbiBwaXhlbDwvc3Ryb25nPiBzaSByaWZlcmlzY2UgYWxsZSB2YXJpYXppb25pIG5lbGxhIHNjYWxhIGluZ3JhbmRlbmRvIGUgcmlkdWNlbmRvIGwnaW1tYWdpbmUgY29uIGxvIHpvb20gZGVsIFZpZXdlciBzdWxsYSB2aXN1YWxpenphemlvbmUgZGVsbGEgbWFwcGEuIENvbnRyb2xsYSBsYSBwZXJjZW50dWFsZSBhbGxhIHF1YWxlIGNhbWJpYSBpbCA8c3Ryb25nPkZhdHRvcmUgWjwvc3Ryb25nPi5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfUFNaRmFjdG9yX3RhZzFAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gw6ggdmFsaWRvIHNvbG8gcXVhbmRvIGlsIHRpcG8gZGkgPHN0cm9uZz5TY2FsYTwvc3Ryb25nPiDDqCA8c3Ryb25nPlJlZ29sYXRvPC9zdHJvbmc+LiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggMCwwMjQuXCIsXG5cdFwiQEBTaW5fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQFNpbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAU2luX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAU2luX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBTaW5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAU2luX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAU2luX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAU2luX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBTaW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAU2luX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBTaW5fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAU2luX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IHBlciBpbCBxdWFsZSBjYWxjb2xhcmUgaSB2YWxvcmkgZGkgc2Vuby5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBTaW5IX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBTaW5IX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBTaW5IX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAU2luSF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAU2luSF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBTaW5IX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBTaW5IX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFNpbkhfUmFzdGVyX3RhZzBAQFwiOiBcIkwnaW5wdXQgcGVyIGlsIHF1YWxlIGNhbGNvbGFyZSBpIHZhbG9yaSBkaSBzZW5vIGlwZXJib2xpY28uXCIsXG5cdFwiQEBTaW5rX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgY2hlIG1vc3RyYSBsYSBkaXJlemlvbmUgZGVsIGZsdXNzbyBmdW9yaSBkYSBvZ25pIGNlbGxhLlwiLFxuXHRcIkBAU2lua19GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMUBAXCI6IFwiSWwgcmFzdGVyIGRpIGRpcmV6aW9uZSBkZWwgZmx1c3NvIHB1w7IgZXNzZXJlIGNyZWF0byBlc2VndWVuZG8gbGEgZnVuemlvbmUgPHN0cm9uZz5EaXJlemlvbmUgZmx1c3NvPC9zdHJvbmc+LlwiLFxuXHRcIkBAU2xvcGVfREVNX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBlbGV2YXppb25lIGRpIGlucHV0LlwiLFxuXHRcIkBAU2xvcGVfRGlzYWJsZS1kZWZhdWx0LWVkZ2UtcGl4ZWwtaW50ZXJwb2xhdGlvbl90YWcwQEBcIjogXCJTZSBzaSB1c2EgcXVlc3RhIG9wemlvbmUgc2kgZXZpdGVyYW5ubyByaWNhbXBpb25hbWVudGkgY2hlIHNpIHBvc3Nvbm8gdmVyaWZpY2FyZSBsdW5nbyBpIG1hcmdpbmkgZGkgdW4gcmFzdGVyLiBJIHBpeGVsIGRpIG91dHB1dCBsdW5nbyBpbCBtYXJnaW5lIGRpIHVuIHJhc3RlciBvIGFjY2FudG8gYSBwaXhlbCBzZW56YSB1biB2YWxvcmUgc2FyYW5ubyBwb3BvbGF0aSBjb24gTm9EYXRhOyBxdWluZGksIHNpIGNvbnNpZ2xpYSBkaSB1c2FyZSBxdWVzdGEgb3B6aW9uZSBzb2xvIHF1YW5kbyBjaSBzb25vIGFsdHJpIHJhc3RlciBjb24gcGl4ZWwgc292cmFwcG9zdGkgZGlzcG9uaWJpbGkuIFF1YW5kbyBzb25vIGRpc3BvbmliaWxpIHBpeGVsIHNvdnJhcHBvc3RpLCBxdWVzdGUgYXJlZSBkaSBOb0RhdGEgbm9uIHNhcmFubm8gdnVvdGUsIG1hIHZpc3VhbGl6emVyYW5ubyBpIHZhbG9yaSBwaXhlbCBzb3ZyYXBwb3N0aS5cIixcblx0XCJAQFNsb3BlX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMUBAXCI6IFwiTm9uIHNlbGV6aW9uYXRvOiBzaSBhcHBsaWNoZXLDoCB1biByaWNhbXBpb25hbWVudG8gYmlsaW5lYXJlIHVuaWZvcm1lIHBlciByaWNhbXBpb25hcmUgbGEgcGVuZGVuemEuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFNsb3BlX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMkBAXCI6IFwiU2VsZXppb25hdG86IHNpIHVzZXLDoCB1biByaWNhbXBpb25hbWVudG8gYmlsaW5lYXJlIGFsbCdpbnRlcm5vIGRlbGxhIHBlbmRlbnphLCB0cmFubmUgbHVuZ28gaSBtYXJnaW5pIGRlaSByYXN0ZXIgbyBhY2NhbnRvIGEgcGl4ZWwgZGkgTm9EYXRhLiBRdWVzdGkgcGl4ZWwgc2FyYW5ubyBwb3BvbGF0aSBjb24gdmFsb3JlIE5vRGF0YSwgY2hlIHJpZHVycsOgIGV2ZW50dWFsaSBlZmZldHRpIGRpIG1hcmdpbmkgbmV0dGkuXCIsXG5cdFwiQEBTbG9wZV9TY2FsaW5nX3RhZzBAQFwiOiBcIkwnaW5jbGluYXppb25lIGRlbGxhIHBlbmRlbnphIHB1w7IgZXNzZXJlIGVtZXNzYSBjb21lIHVuIHZhbG9yZSBpbiBncmFkaSBvIHVuIGF1bWVudG8gcGVyY2VudHVhbGUuIEVzaXN0b25vIHRyZSBvcHppb25pIHBlciBsYSA8c3Ryb25nPlNjYWxhPC9zdHJvbmc+OlwiLFxuXHRcIkBAU2xvcGVfU2NhbGluZ190YWczQEBcIjogXCI8c3Ryb25nPkdyYWRvPC9zdHJvbmc+OiBsJ2luY2xpbmF6aW9uZSBkZWxsYSBwZW5kZW56YSDDqCBjYWxjb2xhdGEgaW4gZ3JhZGkuIFF1ZXN0aSB2YWxvcmkgc3Bhemlhbm8gZGEgMCBhIDkwLlwiLFxuXHRcIkBAU2xvcGVfU2NhbGluZ190YWc1QEBcIjogXCI8c3Ryb25nPkF1bWVudG9fcGVyY2VudHVhbGU8L3N0cm9uZz46IGwnaW5jbGluYXppb25lIGRlbGxhIHBlbmRlbnphIMOoIGNhbGNvbGF0YSBjb21lIHZhbG9yaSBwZXJjZW50dWFsaS4gUXVlc3RpIHZhbG9yaSBzcGF6aWFubyBkYSAwIGEgaW5maW5pdG8uIFVuYSBzdXBlcmZpY2llIHBpYXR0YSDDqCB1biBhdW1lbnRvIHBlcmNlbnR1YWxlIGRlbGxvIDAlLCBtZW50cmUgdW5hIHN1cGVyZmljaWUgZGkgNDUgZ3JhZGkgw6ggMTAwJS4gUXVhbnRvIHBpw7kgbGEgc3VwZXJmaWNpZSBkaXZlbnRhIHZlcnRpY2FsZSwgdGFudG8gcGnDuSBhbHRvIGRpdmVudGEgbCdhdW1lbnRvIHBlcmNlbnR1YWxlLlwiLFxuXHRcIkBAU2xvcGVfU2NhbGluZ190YWc3QEBcIjogXCI8c3Ryb25nPkluIHNjYWxhPC9zdHJvbmc+OiBsJ2luY2xpbmF6aW9uZSBkZWxsYSBwZW5kZW56YSDDqCBjYWxjb2xhdGEgY29tZSBHUkFETywgbWEgaWwgZmF0dG9yZSB6IMOoIHJlZ29sYXRvIHBlciBsYSBzY2FsYS4gVXNhIGkgdmFsb3JpIGRpIDxzdHJvbmc+UG90ZW56YSBkaW1lbnNpb25lIHBpeGVsPC9zdHJvbmc+IGUgPHN0cm9uZz5GYXR0b3JlIGRpbWVuc2lvbmUgcGl4ZWw8L3N0cm9uZz4sIGNoZSBjb21wcmVuZG9ubyB2YXJpYXppb25pIGRpIHJpc29sdXppb25lIChzY2FsYSkgaW5ncmFuZGVuZG8gZSByaW1waWNjaW9sZW5kbyBsJ2ltbWFnaW5lIGNvbiBsbyB6b29tLiDDiCBjb25zaWdsaWF0YSBxdWFuZG8gc2kgdXNhbm8gZGF0YXNldCBtb25kaWFsaSwgc29wcmF0dHV0dG8gcXVhbmRvIHNpIHVzYSBsYSBwZW5kZW56YSBjb21lIHN1cGVyZmljaWUgZGkgdmlzdWFsaXp6YXppb25lLlwiLFxuXHRcIkBAU2xvcGVfU2NhbGluZ190YWcxM0BAXCI6IFwiSWwgZmF0dG9yZSB6IMOoIHJlZ29sYXRvIHVzYW5kbyBsYSBzZWd1ZW50ZSBlcXVhemlvbmU6XCIsXG5cdFwiQEBTbG9wZV9TY2FsaW5nX3RhZzE0QEBcIjogXCJGYXR0b3JlIFogcmVnb2xhdG8gPSAoRmF0dG9yZSBaKSArIChEaW1lbnNpb25lIHBpeGVsKVwiLFxuXHRcIkBAU2xvcGVfU2NhbGluZ190YWcxNUBAXCI6IFwiw5cgKEZhdHRvcmUgZGkgTWlzdXJhIFBpeGVsKVwiLFxuXHRcIkBAU2xvcGVfU2NhbGluZ190YWcxNkBAXCI6IFwiUG90ZW56YSBkaW1lbnNpb25lIHBpeGVsXCIsXG5cdFwiQEBTbG9wZV9aLUZhY3Rvcl90YWcwQEBcIjogXCJJbCA8c3Ryb25nPmZhdHRvcmUgWjwvc3Ryb25nPiDDqCB1biBmYXR0b3JlIGRpIHNjYWxhIHV0aWxpenphdG8gcGVyIGNvbnZlcnRpcmUgaSB2YWxvcmkgZGkgZWxldmF6aW9uZSBwZXIgZHVlIG1vdGl2aTpcIixcblx0XCJAQFNsb3BlX1otRmFjdG9yX3RhZzNAQFwiOiBcIlBlciBjb252ZXJ0aXJlIGxlIHVuaXTDoCBkaSBlbGV2YXppb25lIChhZCBlc2VtcGlvLCBtZXRyaSBvIHBpZWRpKSBpbiB1bml0w6AgZGkgY29vcmRpbmF0ZSBvcml6em9udGFsaSBkZWwgZGF0YXNldCwgY2hlIHBvc3Nvbm8gZXNzZXJlIHBpZWRpLCBtZXRyaSBvIGdyYWRpXCIsXG5cdFwiQEBTbG9wZV9aLUZhY3Rvcl90YWc0QEBcIjogXCJQZXIgYWdnaXVuZ2VyZSBpbCBmYXR0b3JlIGRpIG1vbHRpcGxpY2F6aW9uZSB2ZXJ0aWNhbGUgcGVyIG90dGVuZXJlIHVuIGVmZmV0dG8gdmlzaXZvXCIsXG5cdFwiQEBTbG9wZV9QU1Bvd2VyX3RhZzBAQFwiOiBcIjxzdHJvbmc+UG90ZW56YSBkaW1lbnNpb25pIGluIHBpeGVsPC9zdHJvbmc+IHNpIHJpZmVyaXNjZSBhbGxlIHZhcmlhemlvbmkgZGkgYWx0aXR1ZGluZSAobyBzY2FsYSkgaW5ncmFuZGVuZG8gZSByaWR1Y2VuZG8gbCdpbW1hZ2luZSBjb24gbG8gem9vbSBkZWwgVmlld2VyIHN1bGxhIHZpc3VhbGl6emF6aW9uZSBtYXBwYS4gw4ggbCdlc3BvbmVudGUgYXBwbGljYXRvIGFsIHRlcm1pbmUgZGltZW5zaW9uaSBpbiBwaXhlbCBuZWxsJ2VxdWF6aW9uZSBjaGUgY29udHJvbGxhIGxhIHBlcmNlbnR1YWxlIGFsbGEgcXVhbGUgaWwgPHN0cm9uZz5GYXR0b3JlIFo8L3N0cm9uZz4gY2FtYmlhIHBlciBldml0YXJlIHVuYSBwZXJkaXRhIHNpZ25pZmljYXRpdmEgZGkgcmlsaWV2by5cIixcblx0XCJAQFNsb3BlX1BTUG93ZXJfdGFnMUBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyDDqCB2YWxpZG8gc29sbyBxdWFuZG8gaWwgdGlwbyBkaSA8c3Ryb25nPnNjYWxhIDwvc3Ryb25nPiDDqCA8c3Ryb25nPlNjYWxhdG88L3N0cm9uZz4uIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAwLDY2NC5cIixcblx0XCJAQFNsb3BlX1BTWkZhY3Rvcl90YWcwQEBcIjogXCI8c3Ryb25nPkZhdHRvcmUgZGltZW5zaW9uaSBpbiBwaXhlbDwvc3Ryb25nPiBzaSByaWZlcmlzY2UgYWxsZSB2YXJpYXppb25pIG5lbGxhIHNjYWxhIGluZ3JhbmRlbmRvIGUgcmlkdWNlbmRvIGwnaW1tYWdpbmUgY29uIGxvIHpvb20gZGVsIFZpZXdlciBzdWxsYSB2aXN1YWxpenphemlvbmUgbWFwcGEuIENvbnRyb2xsYSBsYSBwZXJjZW50dWFsZSBhbGxhIHF1YWxlIGNhbWJpYSBpbCA8c3Ryb25nPkZhdHRvcmUgWjwvc3Ryb25nPi5cIixcblx0XCJAQFNsb3BlX1BTWkZhY3Rvcl90YWcxQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIMOoIHZhbGlkbyBzb2xvIHF1YW5kbyBpbCB0aXBvIGRpIDxzdHJvbmc+c2NhbGE8L3N0cm9uZz4gw6ggPHN0cm9uZz5TY2FsYXRvPC9zdHJvbmc+LiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggMCwwMjQuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfRmxvdy1BY2N1bXVsYXRpb24tUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBsYXllciBkaSBhY2N1bXVsbyBkaSBmbHVzc28gZGkgaW5wdXQuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfRmxvdy1BY2N1bXVsYXRpb24tUmFzdGVyX3RhZzFAQFwiOiBcIlB1w7IgZXNzZXJlIGNyZWF0byBjb24gbGEgZnVuemlvbmUgPHN0cm9uZz5BY2N1bXVsbyBkaSBmbHVzc288L3N0cm9uZz4uXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfUG91ci1Qb2ludC1GaWVsZF90YWcwQEBcIjogXCJJbCBjYW1wbyB1c2F0byBwZXIgYXNzZWduYXJlIHZhbG9yaSBhbGxlIHBvc2l6aW9uaSBkZWwgcHVudG8gZGkgdmVyc2FtZW50by5cIixcblx0XCJAQFNuYXAtUG91ci1Qb2ludF9Qb3VyLVBvaW50LVJhc3Rlcl90YWcwQEBcIjogXCJMZSBwb3NpemlvbmkgZGVsIHB1bnRvIGRpIHZlcnNhbWVudG8gZGkgaW5wdXQgZGEgYWdnYW5jaWFyZS5cIixcblx0XCJAQFNuYXAtUG91ci1Qb2ludF9Qb3VyLVBvaW50LVJhc3Rlcl90YWcxQEBcIjogXCJQZXIgdW4gcmFzdGVyIGxheWVyIGRpIGlucHV0LCB0dXR0ZSBsZSBjZWxsZSBjaGUgbm9uIHNvbm8gTm9EYXRhIChjaW/DqCwgaGFubm8gdW4gdmFsb3JlKSB2ZXJyYW5ubyBjb25zaWRlcmF0ZSBwdW50aSBkaSB2ZXJzYW1lbnRvIGUgdmVycmFubm8gYWdnYW5jaWF0ZS5cIixcblx0XCJAQFNuYXAtUG91ci1Qb2ludF9TbmFwLURpc3RhbmNlX3RhZzBAQFwiOiBcIkxhIGRpc3RhbnphIG1hc3NpbWEgbmVsbGUgdW5pdMOgIGRlbGxhIG1hcHBhIGRhIHJpY2VyY2FyZSBwZXIgdW5hIGNlbGxhIGRpIGZsdXNzbyBhY2N1bXVsYXRvIG1hZ2dpb3JlLlwiLFxuXHRcIkBAU3BlY2tsZV9BZGRpdGl2ZS1Ob2lzZS1NZWFuX3RhZzBAQFwiOiBcIlNwZWNpZmljYSBpbCB2YWxvcmUgbWVkaW8gZGVsIHJ1bW9yZSBhZGRpdGl2by4gVW4gdmFsb3JlIG1lZGlvIGRlbCBydW1vcmUgbWFnZ2lvcmUgcHJvZHVycsOgIG1lbm8gc211c3NhbWVudG8sIG1lbnRyZSBpIHJpc3VsdGF0aSBkaSB2YWxvcmUgbWlub3JpIHByb2R1cnJhbm5vIHBpw7kgc211c3NhbWVudG8uXCIsXG5cdFwiQEBTcGVja2xlX0FkZGl0aXZlLU5vaXNlLU1lYW5fdGFnMUBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyDDqCB2YWxpZG8gc29sbyBxdWFuZG8gaWwgPHN0cm9uZz5UaXBvIGRpIGZpbHRybzwvc3Ryb25nPiDDqCA8c3Ryb25nPkZpbHRybyBMZWU8L3N0cm9uZz4gZSBpbCA8c3Ryb25nPk1vZGVsbG8gZGkgcnVtb3JlPC9zdHJvbmc+IMOoIDxzdHJvbmc+UnVtb3JlIGFkZGl0aXZvPC9zdHJvbmc+IG8gPHN0cm9uZz5SdW1vcmUgYWRkaXRpdm8gZSBtb2x0aXBsaWNhdGl2bzwvc3Ryb25nPi4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDAuXCIsXG5cdFwiQEBTcGVja2xlX0RhbXBpbmctRmFjdG9yX3RhZzBAQFwiOiBcIlNwZWNpZmljYSBsJ2VzdGVuc2lvbmUgZGVsbCdlZmZldHRvIHNtb3J6YW1lbnRvIGVzcG9uZW56aWFsZSBuZWwgZmlsdHJhZ2dpby4gVW4gdmFsb3JlIGRpIHNtb3J6YW1lbnRvIG1hZ2dpb3JlIGNvbnNlcnZhIG1lZ2xpbyBpIG1hcmdpbmkgbWEgc211c3NhIGRpIG1lbm8sIG1lbnRyZSB1biB2YWxvcmUgbWlub3JlIHByb2R1Y2UgcGnDuSBzbXVzc2FtZW50by4gVW4gdmFsb3JlIGRpIDAgcHJvZHVjZSBsbyBzdGVzc28gb3V0cHV0IGRpIHVuIGZpbHRybyBwYXNzYSBiYXNzby5cIixcblx0XCJAQFNwZWNrbGVfRGFtcGluZy1GYWN0b3JfdGFnMUBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyDDqCB2YWxpZG8gc29sbyBxdWFuZG8gaWwgPHN0cm9uZz5UaXBvIGRpIGZpbHRybzwvc3Ryb25nPiDDqCA8c3Ryb25nPkZpbHRybyBMZWUgbWlnbGlvcmF0bzwvc3Ryb25nPiBvIDxzdHJvbmc+RmlsdHJvIEZyb3N0PC9zdHJvbmc+LiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggMS5cIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVNpemVfdGFnMEBAXCI6IFwiU3BlY2lmaWNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgZmluZXN0cmEgZGkgcGl4ZWwgdXRpbGl6emF0YSBwZXIgZmlsdHJhcmUgaWwgcnVtb3JlOlwiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItU2l6ZV90YWcxQEBcIjogXCIzeDNcIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVNpemVfdGFnMkBAXCI6IFwiNXg1XCIsXG5cdFwiQEBTcGVja2xlX0ZpbHRlci1TaXplX3RhZzNAQFwiOiBcIjd4N1wiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItU2l6ZV90YWc0QEBcIjogXCI5eDlcIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVNpemVfdGFnNUBAXCI6IFwiMTF4MTFcIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVR5cGVfdGFnMEBAXCI6IFwiU3BlY2lmaWNhIGlsIHRpcG8gZGkgZmlsdHJvIGRhIHV0aWxpenphcmUgbmVsbCdhbGdvcml0bW8gZGkgc211c3NhbWVudG8gcGVyIHJpbXVvdmVyZSBpbCBydW1vcmUgbW9sdGlwbGljYXRpdm86XCIsXG5cdFwiQEBTcGVja2xlX0ZpbHRlci1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+RmlsdHJvIExlZTwvc3Ryb25nPjogcmlkdWNlIGlsIHJ1bW9yZSBtb2x0aXBsaWNhdGl2byBhcHBsaWNhbmRvIHVuIGZpbHRybyBzcGF6aWFsZSBhIG9nbmkgcGl4ZWwgaW4gdW4naW1tYWdpbmUsIGlsIGNoZSBmaWx0cmEgaSBkYXRpIGluIGJhc2UgYWxsZSBzdGF0aXN0aWNoZSBsb2NhbGkgY2FsY29sYXRlIGFsbCdpbnRlcm5vIGRpIHVuYSBmaW5lc3RyYSBxdWFkcmF0YS4gUXVlc3RvIGZpbHRybyDDqCB1dGlsZSBxdWFuZG8gc2kgdnVvbGUgc211c3NhcmUgaSBkYXRpIGRlbCBydW1vcmUgbW9sdGlwbGljYXRpdm8gY2hlIGhhbm5vIGNvbXBvbmVudGkgYWRkaXRpdmkgbyBtb2x0aXBsaWNhdGl2aS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPkZpbHRybyBMZWUgbWlnbGlvcmF0bzwvc3Ryb25nPjogdW5hIHZlcnNpb25lIGFkYXR0YXRhIGRlbCBmaWx0cm8gaWwgTGVlIGNoZSBpbmNsdWRlIDxzdHJvbmc+RmF0dG9yZSBkaSBzbW9yemFtZW50bzwvc3Ryb25nPiBlIDxzdHJvbmc+TnVtZXJvIGRpIHJpY2VyY2hlPC9zdHJvbmc+LiBRdWVzdG8gZmlsdHJvIMOoIHV0aWxlIHF1YW5kbyBzaSB2dW9sZSByaWR1cnJlIGlsIHJ1bW9yZSBtb2x0aXBsaWNhdGl2byBjb25zZXJ2YW5kbyBsZSBpbmZvcm1hemlvbmkgZGVsbGEgc3RydXR0dXJhLlwiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItVHlwZV90YWc5QEBcIjogXCI8c3Ryb25nPkZpbHRybyBGcm9zdDwvc3Ryb25nPjogcmlkdWNlIGlsIHJ1bW9yZSBtb2x0aXBsaWNhdGl2byBjb24gdW4gZmlsdHJvIHNpbW1ldHJpY28gY2lyY29sYXJlIHNtb3J6YXRvIGVzcG9uZW56aWFsbWVudGUgY2hlIHV0aWxpenphIGxlIHN0YXRpc3RpY2hlIGxvY2FsaSBhbGwnaW50ZXJubyBkZWxsZSBmaW5lc3RyZSBkaSBmaWx0cm8gaW5kaXZpZHVhbGkuIFF1ZXN0byBmaWx0cm8gw6ggdXRpbGUgcXVhbmRvIHNpIHZ1b2xlIHJpZHVycmUgaWwgcnVtb3JlIG1vbHRpcGxpY2F0aXZvIGNvbnNlcnZhbmRvIGkgbWFyZ2luaSBuZWxsZSBpbW1hZ2luaSByYWRhci5cIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVR5cGVfdGFnMTFAQFwiOiBcIjxzdHJvbmc+RmlsdHJvIEt1YW48L3N0cm9uZz46IHBhcmFnb25hYmlsZSBhbCBmaWx0cm8gTGVlLCBxdWVzdG8gZmlsdHJvIGFwcGxpY2EgdW4gZmlsdHJvIHNwYXppYWxlIGEgb2duaSBwaXhlbCBpbiB1bidpbW1hZ2luZSBlIGZpbHRyYSBpIGRhdGkgaW4gYmFzZSBhbGxlIHN0YXRpc3RpY2hlIGxvY2FsaSBjYWxjb2xhdGUgYWxsJ2ludGVybm8gZGkgdW5hIGZpbmVzdHJhIHF1YWRyYXRhLiBRdWVzdG8gZmlsdHJvIMOoIHV0aWxlIHF1YW5kbyBzaSB2dW9sZSByaWR1cnJlIGlsIHJ1bW9yZSBtb2x0aXBsaWNhdGl2byBjb25zZXJ2YW5kbyBpIG1hcmdpbmkgbmVsbGUgaW1tYWdpbmkgcmFkYXIuXCIsXG5cdFwiQEBTcGVja2xlX011bHRpcGxpY2F0aXZlLU5vaXNlLU1lYW5fdGFnMEBAXCI6IFwiU3BlY2lmaWNhIGlsIHZhbG9yZSBtZWRpbyBkZWwgcnVtb3JlIG1vbHRpcGxpY2F0aXZvLiBVbiB2YWxvcmUgbWVkaW8gZGVsIHJ1bW9yZSBtYWdnaW9yZSBwcm9kdXJyw6AgbWVubyBzbXVzc2FtZW50bywgbWVudHJlIGkgcmlzdWx0YXRpIGRpIHZhbG9yZSBtaW5vcmkgcHJvZHVycmFubm8gcGnDuSBzbXVzc2FtZW50by5cIixcblx0XCJAQFNwZWNrbGVfTXVsdGlwbGljYXRpdmUtTm9pc2UtTWVhbl90YWcxQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIMOoIHZhbGlkbyBzb2xvIHF1YW5kbyBpbCA8c3Ryb25nPlRpcG8gZGkgZmlsdHJvPC9zdHJvbmc+IMOoIDxzdHJvbmc+RmlsdHJvIExlZTwvc3Ryb25nPiBlIGlsIDxzdHJvbmc+TW9kZWxsbyBkaSBydW1vcmU8L3N0cm9uZz4gw6ggPHN0cm9uZz5SdW1vcmUgYWRkaXRpdm88L3N0cm9uZz4gbyA8c3Ryb25nPlJ1bW9yZSBhZGRpdGl2byBlIG1vbHRpcGxpY2F0aXZvPC9zdHJvbmc+LiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggMS5cIixcblx0XCJAQFNwZWNrbGVfTm9pc2UtTW9kZWxfdGFnMEBAXCI6IFwiU3BlY2lmaWNhIGlsIHRpcG8gZGkgcnVtb3JlIHJlc3BvbnNhYmlsZSBkZWxsYSByaWR1emlvbmUgZGVsbGEgcXVhbGl0w6AgZGVsbGUgaW1tYWdpbmkgcmFkYXI6XCIsXG5cdFwiQEBTcGVja2xlX05vaXNlLU1vZGVsX3RhZzFAQFwiOiBcIjxzdHJvbmc+UnVtb3JlIG1vbHRpcGxpY2F0aXZvPC9zdHJvbmc+OiBydW1vcmUgZGkgc2VnbmFsZSBjYXN1YWxlIGNoZSBzaSBtb2x0aXBsaWNhIG5lbCBzZWduYWxlIHJpbGV2YW50ZSBkdXJhbnRlIGwnYWNxdWlzaXppb25lIG8gbGEgdHJhc21pc3Npb25lXCIsXG5cdFwiQEBTcGVja2xlX05vaXNlLU1vZGVsX3RhZzNAQFwiOiBcIjxzdHJvbmc+UnVtb3JlIGFkZGl0aXZvPC9zdHJvbmc+OiBydW1vcmUgZGkgc2VnbmFsZSBjYXN1YWxlIGNoZSBzaSBhZ2dpdW5nZSBhbCBzZWduYWxlIHJpbGV2YW50ZSBkdXJhbnRlIGwnYWNxdWlzaXppb25lIG8gbGEgdHJhc21pc3Npb25lXCIsXG5cdFwiQEBTcGVja2xlX05vaXNlLU1vZGVsX3RhZzVAQFwiOiBcIjxzdHJvbmc+UnVtb3JlIGFkZGl0aXZvIGUgbW9sdGlwbGljYXRpdm88L3N0cm9uZz46IGVudHJhbWJpIGkgbW9kZWxsaSBkaSBydW1vcmVcIixcblx0XCJAQFNwZWNrbGVfTm9pc2UtVmFyaWFuY2VfdGFnMEBAXCI6IFwiU3BlY2lmaWNhIGxhIHZhcmlhbnphIGRpIHJ1bW9yZSBuZWxsJ2ltbWFnaW5lIHJhZGFyLlwiLFxuXHRcIkBAU3BlY2tsZV9Ob2lzZS1WYXJpYW5jZV90YWcxQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIMOoIHZhbGlkbyBzb2xvIHF1YW5kbyBpbCA8c3Ryb25nPlRpcG8gZGkgZmlsdHJvPC9zdHJvbmc+IMOoIDxzdHJvbmc+RmlsdHJvIExlZTwvc3Ryb25nPiBlIGlsIDxzdHJvbmc+TW9kZWxsbyBkaSBydW1vcmU8L3N0cm9uZz4gw6ggPHN0cm9uZz5SdW1vcmUgYWRkaXRpdm88L3N0cm9uZz4gbyA8c3Ryb25nPlJ1bW9yZSBhZGRpdGl2byBlIG1vbHRpcGxpY2F0aXZvPC9zdHJvbmc+LiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggMCwyNS5cIixcblx0XCJAQFNwZWNrbGVfTnVtYmVyLW9mLUxvb2tzX3RhZzBAQFwiOiBcIlNwZWNpZmljYSBpbCBudW1lcm8gZGkgcmljZXJjaGUgZGVsbCdpbW1hZ2luZSwgaWwgY2hlIHZlcmlmaWNhIGxvIHNtdXNzYW1lbnRvIGRlbGwnaW1tYWdpbmUgZSBzdGltYSBsYSB2YXJpYW56YSBkZWwgcnVtb3JlLiBVbiB2YWxvcmUgcGnDuSBwaWNjb2xvIHByb2R1Y2UgcGnDuSBzbXVzc2F0dXJhLCBtZW50cmUgdW4gdmFsb3JlIHBpw7kgZ3JhbmRlIGNvbnNlcnZhIHBpw7kgZmVhdHVyZSBkZWxsJ2ltbWFnaW5lLlwiLFxuXHRcIkBAU3BlY2tsZV9OdW1iZXItb2YtTG9va3NfdGFnMUBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyDDqCB2YWxpZG8gc29sbyBxdWFuZG8gaWwgPHN0cm9uZz5UaXBvIGRpIGZpbHRybzwvc3Ryb25nPiDDqCA8c3Ryb25nPkZpbHRybyBMZWU8L3N0cm9uZz4gZSBpbCA8c3Ryb25nPk1vZGVsbG8gZGkgcnVtb3JlPC9zdHJvbmc+IMOoIDxzdHJvbmc+UnVtb3JlIG1vbHRpcGxpY2F0aXZvPC9zdHJvbmc+IG8gcXVhbmRvIGlsIDxzdHJvbmc+VGlwbyBkaSBmaWx0cm88L3N0cm9uZz4gw6ggPHN0cm9uZz5GaWx0cm8gS3Vhbjwvc3Ryb25nPi4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDEuXCIsXG5cdFwiQEBTcGVja2xlX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tTWF0cml4X3RhZzBAQFwiOiBcIkxhIG1hdHJpY2UgdXRpbGl6emF0YSBwZXIgY29udmVydGlyZSBpbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tTWF0cml4X3RhZzFAQFwiOiBcIkwnZXF1YXppb25lIHVzYXRhIHBlciBlc2VndWlyZSBxdWVzdGEgY29udmVyc2lvbmUgw6g6XCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tTWF0cml4X3RhZzJAQFwiOiBcIkJhbmRhIGRpIG91dHB1dF9SID0gUG9uZGVyYXppb25lX1AgKiBCYW5kYV9DXCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tTWF0cml4X3RhZzNAQFwiOiBcImRvdmU6XCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tTWF0cml4X3RhZzRAQFwiOiBcIkJhbmRfUiDDqCB1bmEgYmFuZGEgZGkgb3V0cHV0LCBpbiBjdWkgUiDDqCB1biBudW1lcm8gZGEgMSBhbCBudW1lcm8gZGkgYmFuZGUgZGkgb3V0cHV0LlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWc1QEBcIjogXCJXZWlnaHRfUCDDqCB1biBlbGVuY28gZGkgcGVzaSBkZWxpbWl0YXRvIGRhIHZpcmdvbGUsIDEgcGVyIG9nbmkgYmFuZGEgZGkgaW5wdXQuIExhIHNvbW1hIGRlaSBwZXNpIHBlciBvZ25pIGJhbmRhIGRvdnJlYmJlIGVzc2VyZSB1Z3VhbGUgYSAxLlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWc2QEBcIjogXCJCYW5kX0Mgw6ggbCdpbW1hZ2luZSBkaSBpbnB1dCwgaW4gY3VpIEMgw6ggdW4gbnVtZXJvIGRhIDEgYWwgbnVtZXJvIGRpIGJhbmRlIGRlbGwnaW1tYWdpbmUgZGkgaW5wdXQuXCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX1Jhc3Rlcl90YWcxQEBcIjogXCJQdcOyIGVzc2VyZSB1biByYXN0ZXIgZGF0YXNldCwgdW4gbW9zYWljIGRhdGFzZXQgbyB1biBpbWFnZSBzZXJ2aWNlLlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9TaXplX3RhZzBAQFwiOiBcIklsIG51bWVybyBkaSByaWdoZSBlIGNvbG9ubmUgaW4gPHN0cm9uZz5NYXRyaWNlIGRpIGNvbnZlcnNpb25lPC9zdHJvbmc+LlwiLFxuXHRcIkBAU3F1YXJlX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBTcXVhcmVfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFNxdWFyZV9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIlVsdGltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbCd1bHRpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFNxdWFyZV9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAU3F1YXJlX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFNxdWFyZV9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBwaWNjb2xhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFNxdWFyZV9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQFNxdWFyZV9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAU3F1YXJlX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2V6aW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWkgcGl4ZWwgc292cmFwcG9zdGkgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFNxdWFyZV9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAU3F1YXJlX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFNxdWFyZV9SYXN0ZXJfdGFnMEBAXCI6IFwiSSB2YWxvcmkgZGkgaW5wdXQgZGEgZWxldmFyZSBhbCBxdWFkcmF0by5cIixcblx0XCJAQFNxdWFyZS1Sb290X0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQFNxdWFyZS1Sb290X0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfUmFzdGVyX3RhZzBAQFwiOiBcIkkgdmFsb3JpIGRpIGlucHV0IHV0aWxpenphdGkgcGVyIHRyb3ZhcmUgbGEgcmFkaWNlIHF1YWRyYXRhLlwiLFxuXHRcIkBAU3RhdGlzdGljcy1hbmQtSGlzdG9ncmFtX0RlZmluZS1TdGF0aXN0aWNzLWFuZC1IaXN0b2dyYW1fdGFnMEBAXCI6IFwiSW1wb3N0YXJlIGkgdmFsb3JpIHN0YXRpc3RpY2kgcGVyIG9nbmkgYmFuZGEuXCIsXG5cdFwiQEBTdGF0aXN0aWNzLWFuZC1IaXN0b2dyYW1fRGVmaW5lLVN0YXRpc3RpY3MtYW5kLUhpc3RvZ3JhbV90YWcxQEBcIjogXCJMYSBjb2xvbm5hICR7SGlzdG9ncmFtfSDDqCB1biBjYW1wbyBkaSBzb2xhIGxldHR1cmEgY2hlIHB1w7IgZXNzZXJlIHBvcG9sYXRvIHV0aWxpenphbmRvIGlsIHBhcmFtZXRybyA8c3Ryb25nPkltcG9ydGE8L3N0cm9uZz4uIFNlIHNpIGltcG9ydGEgdW4gZmlsZSBkaSBpc3RvZ3JhbW1hLCBsYSBjb2xvbm5hICR7SGlzdG9ncmFtfSB2aWVuZSBjb250cmFzc2VnbmF0YSBjb21lIDxzdHJvbmc+RGVmaW5pdG88L3N0cm9uZz4uXCIsXG5cdFwiQEBTdGF0aXN0aWNzLWFuZC1IaXN0b2dyYW1fSW1wb3J0X3RhZzBAQFwiOiBcIkltcG9ydGFyZSBpbmZvcm1hemlvbmkgc3Ugc3RhdGlzdGljaGUgZSBpc3RvZ3JhbW1hIGRhIHVuIHJhc3RlciBvIHVuIGZpbGUgWE1MIGVzaXN0ZW50ZS5cIixcblx0XCJAQFN0YXRpc3RpY3MtYW5kLUhpc3RvZ3JhbV9SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IGNoZSByaWNoaWVkZSBs4oCZaW1wb3N0YXppb25lIGRpIHN0YXRpc3RpY2hlIGUgaXN0b2dyYW1tYS5cIixcblx0XCJAQFN0YXRpc3RpY3MtYW5kLUhpc3RvZ3JhbV9TdGF0aXN0aWNzX3RhZzBAQFwiOiBcIkltcG9zdGFyZSBpIHZhbG9yaSBzdGF0aXN0aWNpIHBlciBvZ25pIGJhbmRhLlwiLFxuXHRcIkBAU3RyZWFtLUxpbmtfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBjaGUgbW9zdHJhIGxhIGRpcmV6aW9uZSBkZWwgZmx1c3NvIGZ1b3JpIGRhIG9nbmkgY2VsbGEuXCIsXG5cdFwiQEBTdHJlYW0tTGlua19GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMUBAXCI6IFwiSWwgcmFzdGVyIGRpIGRpcmV6aW9uZSBkZWwgZmx1c3NvIHB1w7IgZXNzZXJlIGNyZWF0byBlc2VndWVuZG8gbGEgZnVuemlvbmUgPHN0cm9uZz5EaXJlemlvbmUgZmx1c3NvPC9zdHJvbmc+LlwiLFxuXHRcIkBAU3RyZWFtLUxpbmtfU3RyZWFtLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgY2hlIHJhcHByZXNlbnRhIHVuYSByZXRlIGRpIGZsdXNzbyBsaW5lYXJlLlwiLFxuXHRcIkBAU3RyZWFtLU9yZGVyX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgY2hlIG1vc3RyYSBsYSBkaXJlemlvbmUgZGVsIGZsdXNzbyBmdW9yaSBkYSBvZ25pIGNlbGxhLlwiLFxuXHRcIkBAU3RyZWFtLU9yZGVyX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcxQEBcIjogXCJJbCByYXN0ZXIgZGkgZGlyZXppb25lIGRlbCBmbHVzc28gcHXDsiBlc3NlcmUgY3JlYXRvIGVzZWd1ZW5kbyBsYSBmdW56aW9uZSA8c3Ryb25nPkRpcmV6aW9uZSBmbHVzc288L3N0cm9uZz4uXCIsXG5cdFwiQEBTdHJlYW0tT3JkZXJfT3JkZXItTWV0aG9kX3RhZzBAQFwiOiBcIklsIG1ldG9kbyB1dGlsaXp6YXRvIHBlciBhc3NlZ25hcmUgbCdvcmRpbmUgZGkgZmx1c3NvLlwiLFxuXHRcIkBAU3RyZWFtLU9yZGVyX09yZGVyLU1ldGhvZF90YWcxQEBcIjogXCI8c3Ryb25nPlNUUkFITEVSPC9zdHJvbmc+OiBpbCBtZXRvZG8gZGkgb3JkaW5hbWVudG8gZGkgZmx1c3NvIHByb3Bvc3RvIGRhIFN0cmFobGVyIG5lbCAxOTUyLiBMJ29yZGluZSBkaSBmbHVzc28gYXVtZW50YSBzb2xvIHF1YW5kbyBzaSBpbnRlcnNlY2FubyBmbHVzc2kgZGVsbG8gc3Rlc3NvIG9yZGluZS4gTCdpbnRlcnNlemlvbmUgZGkgdW4gY29sbGVnYW1lbnRvIGRpIHByaW0nb3JkaW5lIGUgZGkgc2Vjb25kJ29yZGluZSBwcm9kdXJyw6AgdW4gY29sbGVnYW1lbnRvIGRpIHNlY29uZCdvcmRpbmUsIHBpdXR0b3N0byBjaGUgdW4gY29sbGVnYW1lbnRvIGRpIHRlcnonb3JkaW5lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBTdHJlYW0tT3JkZXJfT3JkZXItTWV0aG9kX3RhZzNAQFwiOiBcIjxzdHJvbmc+U0hSRVZFPC9zdHJvbmc+OiBpbCBtZXRvZG8gZGkgb3JkaW5hbWVudG8gZGkgZmx1c3NvIHBlciBtYWduaXR1ZG8gcHJvcG9zdG8gZGEgU2hyZXZlIG5lbCAxOTY3LiBBIHR1dHRpIGkgY29sbGVnYW1lbnRpIHNlbnphIGFmZmx1ZW50aSB2aWVuZSBhc3NlZ25hdGEgdW5hIG1hZ25pdHVkbyAob3JkaW5lKSBkaSB1bm8uIExlIG1hZ25pdHVkbyBzb25vIHBlbmRlbnplIHZlcnNvIGlsIGJhc3NvIGFkZGl0aXZlLiBRdWFuZG8gc2kgaW50ZXJzZWNhbm8gZHVlIGNvbGxlZ2FtZW50aSwgbGUgbG9ybyBtYWduaXR1ZG8gdmVuZ29ubyBhZ2dpdW50ZSBlIGFzc2VnbmF0ZSBhbCBsaW5rIGRlbGxhIHBlbmRlbnphIHZlcnNvIGlsIGJhc3NvLlwiLFxuXHRcIkBAU3RyZWFtLU9yZGVyX1N0cmVhbS1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGRpIGZsdXNzbyBkaSBpbnB1dCBjaGUgcmFwcHJlc2VudGEgdW5hIHJldGUgZGkgZmx1c3NvIGxpbmVhcmUuXCIsXG5cdFwiQEBTdHJldGNoX0F1dG8tR2FtbWFfdGFnMEBAXCI6IFwiVXRpbGl6emFyZSA8c3Ryb25nPkdhbW1hIGF1dG9tYXRpY2E8L3N0cm9uZz4gcGVyIGNhbGNvbGFyZSBsYSBnYW1tYSBkYWxsZSBzdGF0aXN0aWNoZSBlIGRhbGwnaXN0b2dyYW1tYSBkZWwgZGF0YXNldC4gTGUgc3RhdGlzdGljaGUgcG9zc29ubyBlc3NlcmUgbGUgc3RhdGlzdGljaGUgc3RpbWF0ZSBkYWxsYSBmdW56aW9uZSBzdGVzc2EsIG8gbGUgc3RhdGlzdGljaGUgcG9zc29ubyBlc3NlcmUgc3RpbWF0ZSBkYWwgc29mdHdhcmUgc2Ugc2kgc2NlZ2xpZSB1biBsYXllci5cIixcblx0XCJAQFN0cmV0Y2hfRHluYW1pYy1SYW5nZS1BZGp1c3RtZW50X3RhZzBAQFwiOiBcIlNlbGV6aW9uYXJlIGxhIGNhc2VsbGEgZGkgY29udHJvbGxvIDxzdHJvbmc+UmVnb2xhemlvbmUgZ2FtbWEgZGluYW1pY2E8L3N0cm9uZz4gc2Ugc2kgdnVvbGUgY2FsY29sYXJlIGxlIHN0YXRpc3RpY2hlIHNvbG8gZGFpIHBpeGVsIHZpc3VhbGl6emF0aSBzdWxsbyBzY2hlcm1vLiBRdWVzdGEgb3B6aW9uZSB2aWVuZSBnZW5lcmFsbWVudGUgYXBwbGljYXRhIHF1YW5kbyBsJ2ltbWFnaW5lIHZlcnLDoCBwdWJibGljYXRhIGUgdXRpbGl6emF0YSBpbiB1bidhcHBsaWNhemlvbmUgV2ViIGNoZSBub24gcHXDsiBlc2VndWlyZSBxdWVzdG8gdGlwbyBkaSBlc3RlbnNpb25lLlwiLFxuXHRcIkBAU3RyZXRjaF9Fc3RpbWF0ZS1TdGF0aXN0aWNzX3RhZzBAQFwiOiBcIlNlbGV6aW9uYXJlIGxhIGNhc2VsbGEgZGkgY29udHJvbGxvIDxzdHJvbmc+U3RpbWEgc3RhdGlzdGljaGU8L3N0cm9uZz4gc2Ugc2kgZGVzaWRlcmEgZXNlZ3VpcmUgdW5hIHN0aW1hIGRlbGxlIHN0YXRpc3RpY2hlLiBMZSBzdGF0aXN0aWNoZSBzdGltYXRlIHNvbm8gY2FsY29sYXRlIGRhIHVuIGNhbXBpb25hbWVudG8gZGkgMTAwMCBpbiAxMDAwIGRhbCBjZW50cm8gZGVsIHJhc3RlciBlIHNvbm8gdXRpbGl6emF0ZSBkYWxsJ2VzdGVuc2lvbmUuXCIsXG5cdFwiQEBTdHJldGNoX0VzdGltYXRlLVN0YXRpc3RpY3NfdGFnM0BAXCI6IFwiU2UgcXVlc3RvIMOoIHNlbGV6aW9uYXRvIGUgaWwgcmFzdGVyIGluY2x1ZGUgc3RhdGlzdGljaGUgbyBzZSBzaSBzb25vIGltbWVzc2kgdmFsb3JpIG5lbGxhIHRhYmVsbGEgPHN0cm9uZz5TdGF0aXN0aWNoZTwvc3Ryb25nPiwgc2kgdXRpbGl6emVyYW5ubyB0YWxpIGRhdGkgYWwgcG9zdG8gZGkgZXNlZ3VpcmUgbGEgc3RpbWEsIGEgbWVubyBjaGUgbCdlc3RlbnNpb25lIG5vbiByaWNoaWVkYSB1biBpc3RvZ3JhbW1hLiBTZSBsJ2VzdGVuc2lvbmUgcmljaGllZGUgdW4gaXN0b2dyYW1tYSBjaGUgbm9uIGVzaXN0ZSwgdmVycsOgIHN0aW1hdGEuXCIsXG5cdFwiQEBTdHJldGNoX0dhbW1hX3RhZzBAQFwiOiBcIlV0aWxpenphcmUgbGEgYmFycmEgZGVsIGN1cnNvcmUgcGVyIGltcG9zdGFyZSBtYW51YWxtZW50ZSBpbCB2YWxvcmUgPHN0cm9uZz5HYW1tYTwvc3Ryb25nPi5cIixcblx0XCJAQFN0cmV0Y2hfTnVtYmVyLU9mLVN0YW5kYXJkLURldmlhdGlvbnNfdGFnMEBAXCI6IFwiU3BlY2lmaWNhcmUgaWwgdmFsb3JlIG4gcGVyIGlsIG51bWVybyBkaSBkZXZpYXppb25pIHN0YW5kYXJkIGRhIHVzYXJlLiBRdWVzdG8gbWV0b2RvIHZpZW5lIHV0aWxpenphdG8gcGVyIG1ldHRlcmUgaW4gZXZpZGVuemEgcXVhbnRvIHZhcmlhbm8gaSB2YWxvcmkgZGVsbGUgZmVhdHVyZSBkYWwgdmFsb3JlIG1lZGlvOyDDqCBtZWdsaW8gcXVhbmRvIHZpZW5lIHV0aWxpenphdG8gc3VpIGRhdGkgZGlzdHJpYnVpdGkgbm9ybWFsbWVudGUuXCIsXG5cdFwiQEBTdHJldGNoX091dHB1dC1NYXhpbXVtX3RhZzBAQFwiOiBcIkltcG9zdGFyZSBpbCB2YWxvcmUgZGkgcGl4ZWwgcGnDuSBhbHRvIHBlciBsJ2lzdG9ncmFtbWEuXCIsXG5cdFwiQEBTdHJldGNoX091dHB1dC1NYXhpbXVtX3RhZzFAQFwiOiBcIkwnPHN0cm9uZz5PdXRwdXQgbWluaW1vPC9zdHJvbmc+IGUgbCc8c3Ryb25nPk91dHB1dCBtYXNzaW1vPC9zdHJvbmc+IGltcG9zdGVyYW5ubyBsJ2ludGVydmFsbG8gZGkgdmFsb3JpIGNoZSBzYXLDoCBlc3Rlc28gbGluZWFybWVudGUgaW4gY29udHJhc3RvLlwiLFxuXHRcIkBAU3RyZXRjaF9PdXRwdXQtTWluaW11bV90YWcwQEBcIjogXCJJbXBvc3RhcmUgaWwgdmFsb3JlIGRpIHBpeGVsIHBpw7kgYmFzc28gcGVyIGwnaXN0b2dyYW1tYS5cIixcblx0XCJAQFN0cmV0Y2hfT3V0cHV0LU1pbmltdW1fdGFnMUBAXCI6IFwiTCc8c3Ryb25nPk91dHB1dCBtaW5pbW88L3N0cm9uZz4gZSBsJzxzdHJvbmc+T3V0cHV0IG1hc3NpbW88L3N0cm9uZz4gaW1wb3N0ZXJhbm5vIGwnaW50ZXJ2YWxsbyBkaSB2YWxvcmkgY2hlIHNhcsOgIGVzdGVzbyBsaW5lYXJtZW50ZSBpbiBjb250cmFzdG8uXCIsXG5cdFwiQEBTdHJldGNoX1BlcmNlbnQtQ2xpcC1NYXhpbXVtX3RhZzBAQFwiOiBcIlNwZWNpZmljYXJlIGxhIHBlcmNlbnR1YWxlIGRpIHZhbG9yaSBhbHRpIGRhIGVzY2x1ZGVyZSBkYWxsJ2VzdGVuc2lvbmUuXCIsXG5cdFwiQEBTdHJldGNoX1BlcmNlbnQtQ2xpcC1NYXhpbXVtX3RhZzFAQFwiOiBcIkkgdmFsb3JpIHZhbGlkaSBzb25vIGNvbXByZXNpIHRyYSAwIGUgOTkuXCIsXG5cdFwiQEBTdHJldGNoX1BlcmNlbnQtQ2xpcC1NaW5pbXVtX3RhZzBAQFwiOiBcIlNwZWNpZmljYXJlIGxhIHBlcmNlbnR1YWxlIGRlaSB2YWxvcmkgYmFzc2kgZGEgZXNjbHVkZXJlIGRhbGwnZXN0ZW5zaW9uZS5cIixcblx0XCJAQFN0cmV0Y2hfUGVyY2VudC1DbGlwLU1pbmltdW1fdGFnMUBAXCI6IFwiSSB2YWxvcmkgdmFsaWRpIHNvbm8gY29tcHJlc2kgdHJhIDAgZSA5OS5cIixcblx0XCJAQFN0cmV0Y2hfUmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBkYSBlc3RlbmRlcmUgaW4gY29udHJhc3RvLlwiLFxuXHRcIkBAU3RyZXRjaF9TaWdtb2lkLVN0cmVuZ3RoLUxldmVsX3RhZzBAQFwiOiBcIklsIDxzdHJvbmc+TGl2ZWxsbyBkaSBmb3J6YTwvc3Ryb25nPiBkZXRlcm1pbmEgcXVhbnRhIGZ1bnppb25lIHNpZ21vaWRhbGUgdmVycsOgIHV0aWxpenphdGEgbmVsbCdlc3RlbnNpb25lLiBVbiB2YWxvcmUgYmFzc28gY29tZSAxIHV0aWxpenplcsOgIHNvbG8gbGEgcG9yemlvbmUgbWVkaWEgZGVsbGEgY3VydmEsIGUgY2nDsiBwcm9kdXJyw6AgY29sb3JpIHRlbnVpIGUgc3BlbnRpLiBVbiB2YWxvcmUgYWx0byBjb21lIDYgdXRpbGl6emVyw6AgbCdpbnRlcmEgY3VydmEsIGUgY2nDsiBwcm9kdXJyw6AgY29sb3JpIG5pdGlkaSBlIHZpdmFjaS5cIixcblx0XCJAQFN0cmV0Y2hfU3RhdGlzdGljc190YWcwQEBcIjogXCLDiCBwb3NzaWJpbGUgaW5zZXJpcmUgbGUgcHJvcHJpZSBzdGF0aXN0aWNoZSBuZWxsYSBmaW5lc3RyYSBkaSBkaWFsb2dvLiBQZXIgaW1wb3N0YXppb25lIHByZWRlZmluaXRhLCBsZSBzdGF0aXN0aWNoZSBwcm92ZW5nb25vIGRhaSBkYXRpOyB0dXR0YXZpYSwgcXVhbHNpYXNpIHZhbG9yZSBpbnNlcml0byBpbiBxdWVzdG8gcGFyYW1ldHJvIHZlcnLDoCB1dGlsaXp6YXRvIGFsIGxvcm8gcG9zdG8uXCIsXG5cdFwiQEBTdHJldGNoX1R5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIGlsIG1ldG9kbyBkZWwgdGlwbyBkaSBlc3RlbnNpb25lOlwiLFxuXHRcIkBAU3RyZXRjaF9UeXBlX3RhZzFAQFwiOiBcIk5lc3N1bm86IG5lc3N1bmEgZXN0ZW5zaW9uZSBkaSBjb250cmFzdG9cIixcblx0XCJAQFN0cmV0Y2hfVHlwZV90YWcyQEBcIjogXCJTdGREZXY6IGVzdGVuc2lvbmUgZGkgY29udHJhc3RvIHN0YW5kYXJkXCIsXG5cdFwiQEBTdHJldGNoX1R5cGVfdGFnM0BAXCI6IFwiTWluTWF4OiBlc3RlbnNpb25lIG1pbmltYS1tYXNzaW1hXCIsXG5cdFwiQEBTdHJldGNoX1R5cGVfdGFnNEBAXCI6IFwiUGVyY2VudE1pbk1heDogZXN0ZW5zaW9uZSB0YWdsaW8gcGVyY2VudHVhbGVcIixcblx0XCJAQFN0cmV0Y2hfVHlwZV90YWc1QEBcIjogXCJTaWdtb2lkOiBlc3RlbnNpb25lIHNpZ21vaWRhbGVcIixcblx0XCJAQFN0cmV0Y2hfVXNlLUdhbW1hX3RhZzBAQFwiOiBcIlNlbGV6aW9uYXJlIGxhIGNhc2VsbGEgZGkgY29udHJvbGxvIDxzdHJvbmc+VXNhIGdhbW1hPC9zdHJvbmc+IHNlIHNpIGRlc2lkZXJhIGFwcGxpY2FyZSB1bidlc3RlbnNpb25lIGdhbW1hLlwiLFxuXHRcIkBAU3dhdGhfQ2VsbHNpemVfdGFnMEBAXCI6IFwiTGEgZGltZW5zaW9uZSBkZWxsZSBjZWxsZSBwZXIgaWwgcmFzdGVyIGRpIG91dHB1dCBzYXLDoCBhdXRvbWF0aWNhbWVudGUgcmlsZXZhdGE7IHR1dHRhdmlhLCDDqCBwb3NzaWJpbGUgY2FtYmlhcmxhIHNlIGxvIHNpIGRlc2lkZXJhLiDDiCBwb3NzaWJpbGUgY2FtYmlhcmUgbGEgZGltZW5zaW9uZSBkZWxsZSBjZWxsZSwgbWEgbCdlc3RlbnNpb25lIGRlbCByYXN0ZXIgZGF0YXNldCByaW1hcnLDoCBsbyBzdGVzc28uXCIsXG5cdFwiQEBTd2F0aF9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWcwQEBcIjogXCJDaSBzb25vIHF1YXR0cm8gbWV0b2RpIGRpIHJpY2FtcGlvbmFtZW50byBwZXIgcXVlc3RhIGZ1bnppb25lOlwiLFxuXHRcIkBAU3dhdGhfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnMUBAXCI6IFwiPHN0cm9uZz5WaWNpbm8gcGnDuSBwcm9zc2ltbzwvc3Ryb25nPjogY2FsY29sYSBpbCB2YWxvcmUgZGVpIHBpeGVsIHVzYW5kbyBpbCBwaXhlbCBwacO5IHZpY2luby4gU2Ugbm9uIGVzaXN0ZSBuZXNzdW4gcGl4ZWwgZGkgb3JpZ2luZSwgbm9uIMOoIHBvc3NpYmlsZSBjcmVhcmUgbmVzc3VuIHBpeGVsIG51b3ZvIG5lbGwnb3V0cHV0LlwiLFxuXHRcIkBAU3dhdGhfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnM0BAXCI6IFwiPHN0cm9uZz5CaWxpbmVhcmU8L3N0cm9uZz46IGNhbGNvbGEgaWwgdmFsb3JlIGRpIHBpeGVsIHVzYW5kbyBpbCB2YWxvcmUgdmVyaWZpY2F0byBhIGRpc3RhbnphIGRlaSBxdWF0dHJvIHBpeGVsIHBpw7kgdmljaW5pLlwiLFxuXHRcIkBAU3dhdGhfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnNUBAXCI6IFwiPHN0cm9uZz5SaXZlc3RpbWVudG8gbGluZWFyZTwvc3Ryb25nPjogdXNhIHVuYSByZXRlIGlycmVnb2xhcmUgdHJpYW5nb2xhdGEgZGFpIHB1bnRpIGNlbnRyYWxpIGRpIG9nbmkgY2VsbGEgZGVsIHJhc3RlciBpcnJlZ29sYXJlIHBlciBpbnRlcnBvbGFyZSB1bmEgc3VwZXJmaWNpZSBjaGUgdmllbmUgcXVpbmRpIGNvbnZlcnRpdGEgaW4gdW4gcmFzdGVyIHJlZ29sYXJlLlwiLFxuXHRcIkBAU3dhdGhfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnN0BAXCI6IFwiPHN0cm9uZz5WaWNpbm8gbmF0dXJhbGU8L3N0cm9uZz46IGVzZWd1ZSB1bidhc3NlZ25hemlvbmUgZGVsIHZpY2lubyBwacO5IHByb3NzaW1vLCDDqCBpbCBwacO5IHZlbG9jZSBkZWkgbWV0b2RpIGRpIGludGVycG9sYXppb25lLiBWaWVuZSB1dGlsaXp6YXRvIHByaW5jaXBhbG1lbnRlIHBlciBkYXRpIGRpc2NyZXRpLCBhZCBlc2VtcGlvIHVuYSBjbGFzc2lmaWNhemlvbmUgZGkgdXRpbGl6em8gZGVsIHN1b2xvLCBwb2ljaMOpIG5vbiBjYW1iaWEgaSB2YWxvcmkgZGVsbGUgY2VsbGUuIEwnZXJyb3JlIHNwYXppYWxlIG1hc3NpbW8gc2Fyw6AgbWV0w6AgZGVsbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYS5cIixcblx0XCJAQFN3YXRoX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgY29uIGdyaWdsaWEgaXJyZWdvbGFyZSBkYSByaWNhbXBpb25hcmUuXCIsXG5cdFwiQEBUYW5fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQFRhbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAVGFuX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAVGFuX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBUYW5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAVGFuX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAVGFuX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAVGFuX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBUYW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAVGFuX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBUYW5fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAVGFuX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IHBlciBpbCBxdWFsZSBjYWxjb2xhcmUgaSB2YWxvcmkgZGkgdGFuZ2VudGUuXCIsXG5cdFwiQEBUYW5IX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGRpbWVuc2lvbmUgZGkgY2VsbGEgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIGxlIGRpbWVuc2lvbmkgZGkgdHV0dGUgbGUgY2VsbGUgZGkgaW5wdXQgc29ubyB1Z3VhbGksIHR1dHRlIGxlIG9wemlvbmkgcHJvZHVycmFubm8gZ2xpIHN0ZXNzaSByaXN1bHRhdGkuXCIsXG5cdFwiQEBUYW5IX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIHByaW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBUYW5IX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAVGFuSF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1hc3NpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgZ3JhbmRlIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAVGFuSF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lZGlhIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBtZWRpYSBkZWxsYSBjZWxsYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBUYW5IX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAVGFuSF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZXN0ZW5zaW9uZSBzaSBkb3ZyZWJiZSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDpcIixcblx0XCJAQFRhbkhfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiUHJpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsIHByaW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFRhbkhfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAVGFuSF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVsbCd1bHRpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAVGFuSF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGkgdHV0dGkgaSByYXN0ZXIgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBUYW5IX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IHBlciBpbCBxdWFsZSBjYWxjb2xhcmUgaSB2YWxvcmkgZGkgdGFuZ2VudGUgaXBlcmJvbGljYS5cIixcblx0XCJAQFRhc3NlbGVkLUNhcF9SYXN0ZXJfdGFnMEBAXCI6IFwiUmFzdGVyIGRpIGlucHV0IHN1IGN1aSBlc2VndWlyZSBsYSB0cmFzZm9ybWF6aW9uZSBUYXNzZWxlZCBDYXAuXCIsXG5cdFwiQEBUaW1lc19DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBAVGltZXNfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFRpbWVzX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAVGltZXNfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFRpbWVzX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFRpbWVzX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAVGltZXNfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBUaW1lc19FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAVGltZXNfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAVGltZXNfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFRpbWVzX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFRpbWVzX1Jhc3Rlcl90YWcwQEBcIjogXCJMJ2lucHV0IGNoZSBjb250aWVuZSBpIHZhbG9yaSBkYSBtb2x0aXBsaWNhcmUuXCIsXG5cdFwiQEBUaW1lc19SYXN0ZXJfdGFnMUBAXCI6IFwiw4ggcG9zc2liaWxlIHVzYXJlIHVuIHZhbG9yZSBjb3N0YW50ZSBjb21lIGlucHV0IHBlciBxdWVzdG8gcGFyYW1ldHJvLCBwdXJjaMOpIHNpYSBzcGVjaWZpY2F0byB1biByYXN0ZXIgcGVyIGwnYWx0cm8gcGFyYW1ldHJvLlwiLFxuXHRcIkBAVGltZXNfUmFzdGVyMl90YWcwQEBcIjogXCJMJ2lucHV0IGNoZSBjb250aWVuZSBpIHZhbG9yaSBwZXIgaSBxdWFsaSB2ZXJyw6AgbW9sdGlwbGljYXRvIGlsIHByaW1vIGlucHV0LlwiLFxuXHRcIkBAVGltZXNfUmFzdGVyMl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgdW4gdmFsb3JlIGNvc3RhbnRlIGNvbWUgaW5wdXQgcGVyIHF1ZXN0byBwYXJhbWV0cm8sIHB1cmNow6kgc2lhIHNwZWNpZmljYXRvIHVuIHJhc3RlciBwZXIgbCdhbHRybyBwYXJhbWV0cm8uXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWcwQEBcIjogXCJTY2VnbGllcmUgaWwgdGlwbyBkaSB0cmFzcG9zaXppb25lIGRhIGVzZWd1aXJlIG8gc3BlY2lmaWNhcmUgdW5hIHRyYXNwb3NpemlvbmUgcGVyc29uYWxpenphdGE6XCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWcxQEBcIjogXCJMYW5kc2F0IDggLSBDaXJyb1wiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfQml0LVBhdHRlcm5fdGFnMkBAXCI6IFwiTGFuZHNhdCA4IC0gTnV2b2xhXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWczQEBcIjogXCJMYW5kc2F0IDggLSBPbWJyYSBudXZvbGFcIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzRAQFwiOiBcIkxhbmRzYXQgOCAtIFJpZW1waW1lbnRvIGRlc2lnbmF0b1wiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfQml0LVBhdHRlcm5fdGFnNUBAXCI6IFwiTGFuZHNhdCA4IC0gRm90b2dyYW1tYSBlbGltaW5hdG9cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzZAQFwiOiBcIkxhbmRzYXQgOCAtIE5ldmUvR2hpYWNjaW9cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzdAQFwiOiBcIkxhbmRzYXQgOCAtIE9jY2x1c2lvbmUgdGVycmVub1wiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfQml0LVBhdHRlcm5fdGFnOEBAXCI6IFwiTGFuZHNhdCA4IC0gVmVnZXRhemlvbmVcIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzlAQFwiOiBcIkxhbmRzYXQgOCAtIEFjcXVhXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWcxMEBAXCI6IFwiRGVmaW5pdG8gZGFsbCd1dGVudGVcIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0NvbnN0YW50LVZhbHVlX3RhZzBAQFwiOiBcIlVuIHZhbG9yZSBvcHppb25hbGUgY2hlIHZlcnLDoCB1dGlsaXp6YXRvIHBlciByaWVtcGlyZSB0dXR0aSBpIHZ1b3RpIG5vbiBpbmNsdXNpIG5lbGxhIHRyYXNwb3NpemlvbmUuIFF1ZXN0byBwYXJhbWV0cm8gw6ggZXNwb3N0byBxdWFuZG8gaWwgcGFyYW1ldHJvIDxzdHJvbmc+R2VuZXJhIHJhc3RlciBkaSByaWVtcGltZW50byBkYSBjb3N0YW50ZTwvc3Ryb25nPiDDqCBpbXBvc3RhdG8gc3UgPHN0cm9uZz5Tw6w8L3N0cm9uZz4uXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19GaWxsLVJhc3Rlcl90YWcwQEBcIjogXCJTcGVjaWZpY2FyZSB1biBkYXRhc2V0IHJhc3RlciBjaGUgdmVycsOgIHV0aWxpenphdG8gcGVyIHJpZW1waXJlIHR1dHRpIGkgdnVvdGkgbm9uIGluY2x1c2kgbmVsbGEgdHJhc3Bvc2l6aW9uZS4gUXVlc3RvIHBhcmFtZXRybyDDqCBlc3Bvc3RvIHF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5HZW5lcmEgcmFzdGVyIGRpIHJpZW1waW1lbnRvIGRhIGNvc3RhbnRlPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPk5vPC9zdHJvbmc+LlwiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfR2VuZXJhdGUtRmlsbC1SYXN0ZXItZnJvbS1Db25zdGFudF90YWcwQEBcIjogXCJHZW5lcmFyZSB1biByYXN0ZXIgZGkgcmllbXBpbWVudG8gdXRpbGl6emFuZG8gdW4gdmFsb3JlIGNvc3RhbnRlOlwiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfR2VuZXJhdGUtRmlsbC1SYXN0ZXItZnJvbS1Db25zdGFudF90YWcxQEBcIjogXCI8c3Ryb25nPlPDrDwvc3Ryb25nPjogdmVycsOgIGdlbmVyYXRvIHVuIHJhc3RlciB1dGlsaXp6YW5kbyB1biB2YWxvcmUgY29zdGFudGUgcGVyIHJpZW1waXJlIGkgdnVvdGkgbm9uIGNvaW52b2x0aSBuZWxsYSB0cmFzcG9zaXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19HZW5lcmF0ZS1GaWxsLVJhc3Rlci1mcm9tLUNvbnN0YW50X3RhZzNAQFwiOiBcIjxzdHJvbmc+Tm88L3N0cm9uZz46IHZlcnLDoCBnZW5lcmF0byB1biByYXN0ZXIgdXRpbGl6emFuZG8gaSB2YWxvcmkgZGkgcGl4ZWwgcHJvdmVuaWVudGkgZGEgdW4gZGF0YXNldCByYXN0ZXIgZXNpc3RlbnRlIHBlciByaWVtcGlyZSBpIHZ1b3RpIG5vbiBjb2ludm9sdGkgbmVsbGEgdHJhc3Bvc2l6aW9uZS5cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX091dHB1dC1CaXQtYW5kLUlucHV0LUJpdF90YWcwQEBcIjogXCJVbmEgdGFiZWxsYSBkaSBzb2xhIGxldHR1cmEgY2hlIG1vc3RyYSBpIHZ1b3RpIGRpIG91dHB1dCBlIGdsaSBpbnB1dCBjaGUgbGkgc29zdGl0dWlyYW5uby5cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgZGEgc3BhY2NoZXR0YXJlIGUgcmltYXBwYXJlLlwiLFxuXHRcIkBAVW5pdC1Db252ZXJzaW9uX0Zyb20tVW5pdF90YWcwQEBcIjogXCJJbCB0aXBvIGRpIHVuaXTDoCBvcmlnaW5hbGUgZGVpIHBpeGVsLlwiLFxuXHRcIkBAVW5pdC1Db252ZXJzaW9uX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQgY2hlIGNvbnRlcnLDoCBsZSB1bml0w6AgY29udmVydGl0ZS5cIixcblx0XCJAQFVuaXQtQ29udmVyc2lvbl9Uby1Vbml0X3RhZzBAQFwiOiBcIklsIHRpcG8gZGkgdW5pdMOgIGNvbnZlcnRpdGUgZGVpIHBpeGVsLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX0FuZ2xlLVJlZmVyZW5jZS1TeXN0ZW1fdGFnMEBAXCI6IFwiU3BlY2lmaWNhIGNvbSfDqCBzdGF0byBtaXN1cmF0byBpbCBjb21wb25lbnRlIGRlbGxhIGRpcmV6aW9uZS5cIixcblx0XCJAQFZlY3Rvci1GaWVsZF9BbmdsZS1SZWZlcmVuY2UtU3lzdGVtX3RhZzFAQFwiOiBcIkdlb2dyYWZpY286IDDCsCBwdW50aSBhIE5vcmQgZSA5MMKwIHB1bnRpIGEgRXN0XCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfQW5nbGUtUmVmZXJlbmNlLVN5c3RlbV90YWcyQEBcIjogXCJBcml0bWV0aWNvOiAwwrAgcHVudGkgYSBFc3QgZSA5MMKwIHB1bnRpIGEgTm9yZFwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX0lucHV0LURhdGEtVHlwZV90YWcwQEBcIjogXCJJbCB0aXBvIGRpIGNhbXBvIHZldHRvcmlhbGUgcmFwcHJlc2VudGF0byBkYWdsaSBpbnB1dC5cIixcblx0XCJAQFZlY3Rvci1GaWVsZF9JbnB1dC1EYXRhLVR5cGVfdGFnMUBAXCI6IFwiU2Nvbm9zY2l1dG86IMOoIHNjb25vc2NpdXRvIHNlIGdsaSBpbnB1dCByYXBwcmVzZW50YW5vIFUtViBvIE1hZ25pdHVkby1EaXJlemlvbmUuXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfSW5wdXQtRGF0YS1UeXBlX3RhZzJAQFwiOiBcIlUtVjogaSBkYXRpIGRpIGlucHV0IHJhcHByZXNlbnRhbm8gaSBjb21wb25lbnRpIFUgZSBWLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX0lucHV0LURhdGEtVHlwZV90YWczQEBcIjogXCJNYWduaXR1ZG8tRGlyZXppb25lOiBpIGRhdGkgZGkgaW5wdXQgcmFwcHJlc2VudGFubyBsYSBtYWduaXR1ZG8gZSBsYSBkaXJlemlvbmUuXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfT3V0cHV0LURhdGEtVHlwZV90YWcwQEBcIjogXCJTcGVjaWZpY2EgaWwgdGlwbyBkaSBjYW1wbyB2ZXR0b3JpYWxlIHJhcHByZXNlbnRhdG8gZGFsbCdvdXRwdXQuXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfT3V0cHV0LURhdGEtVHlwZV90YWcxQEBcIjogXCJNYWduaXR1ZG8tRGlyZXppb25lOiBpIGRhdGkgZGkgb3V0cHV0IHJhcHByZXNlbnRhbm8gbGEgbWFnbml0dWRvIGUgbGEgZGlyZXppb25lLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX091dHB1dC1EYXRhLVR5cGVfdGFnMkBAXCI6IFwiVS1WOiBpIGRhdGkgZGkgb3V0cHV0IHJhcHByZXNlbnRhbm8gaSBjb21wb25lbnRpIFUgZSBWLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX1Jhc3RlcjFfdGFnMEBAXCI6IFwiSWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX1Jhc3RlcjFfdGFnMUBAXCI6IFwiU2Fyw6AgaWwgdmFsb3JlIFUgbyBsYSBtYWduaXR1ZG8uXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfUmFzdGVyMl90YWcwQEBcIjogXCJJbCBzZWNvbmRvIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFZlY3Rvci1GaWVsZF9SYXN0ZXIyX3RhZzFAQFwiOiBcIlNhcsOgIGlsIHZhbG9yZSBWIG8gbGEgZGlyZXppb25lLlwiLFxuXHRcIkBAVmlld3NoZWRfQW5hbHlzaXMtTWV0aG9kX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBpbCBtZXRvZG8gc2Vjb25kbyBpbCBxdWFsZSB2ZXJyw6AgY2FsY29sYXRhIGxhIHZpc2liaWxpdMOgLiBRdWVzdGEgb3B6aW9uZSBjb25zZW50ZSBkaSBvdHRlbmVyZSBwcmVjaXNpb25lIHBlciB1bmEgcGVyZm9ybWFuY2UgYXVtZW50YXRhLlwiLFxuXHRcIkBAVmlld3NoZWRfQW5hbHlzaXMtTWV0aG9kX3RhZzFAQFwiOiBcIlR1dHRlIGxlIGxpbmVlIGRpIHZpc3RhOiB1bmEgbGluZWEgZGkgdmlzdGEgdmllbmUgZXNlZ3VpdGEgc3Ugb2duaSBwaXhlbCBuZWwgcmFzdGVyIHBlciBzdGFiaWxpcmUgbGUgYXJlZSB2aXNpYmlsaS4gUXVlc3RvIMOoIGlsIG1ldG9kbyBwcmVkZWZpbml0by5cIixcblx0XCJAQFZpZXdzaGVkX0FuYWx5c2lzLU1ldGhvZF90YWcyQEBcIjogXCJMaW5lZSBkaSB2aXN0YSBwZXJpbWV0cmFsaTogbGUgbGluZWUgZGkgdmlzdGEgdmVuZ29ubyBlc2VndWl0ZSBzb2xvIHN1aSBwaXhlbCBkZWwgcGVyaW1ldHJvIGRlbGxlIGFyZWUgdmlzaWJpbGkgcGVyIHN0YWJpbGlyZSBsZSBhcmVlIHZpc2liaWxpLiBRdWVzdG8gbWV0b2RvIHByZXNlbnRhIGRlbGxlIHByZXN0YXppb25pIG1pZ2xpb3JpIHJpc3BldHRvIGFsIG1ldG9kbyA8c3Ryb25nPlR1dHRlIGxlIGxpbmVlIGRpIHZpc3RhPC9zdHJvbmc+IHBlcmNow6kgY2kgc29ubyBtZW5vIGxpbmVlIGRpIHZpc3RhIG5lbCBjYWxjb2xvLlwiLFxuXHRcIkBAVmlld3NoZWRfQW5hbHlzaXMtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgdGlwbyBkaSBhbmFsaXNpIGRpIHZpc2liaWxpdMOgIHNpIHZ1b2xlIGVzZWd1aXJlLCBkZXRlcm1pbmFuZG8gcXVhbnRvIMOoIHZpc2liaWxlIHVuYSBjZWxsYSBwZXIgaSBwdW50aSBkaSBvc3NlcnZhemlvbmUgbyBpZGVudGlmaWNhbmRvIHBlciBvZ25pIHBvc2l6aW9uZSBkaSBzdXBlcmZpY2llIHF1YWxpIHNvbm8gZ2xpIG9zc2VydmF0b3JpIHZpc2liaWxpLlwiLFxuXHRcIkBAVmlld3NoZWRfQW5hbHlzaXMtVHlwZV90YWcxQEBcIjogXCJGcmVxdWVuemE6IGlsIG51bWVybyBkaSB2b2x0ZSBjaGUgb2duaSBwb3NpemlvbmUgZGkgcGl4ZWwgbmVsIHJhc3RlciBkaSBzdXBlcmZpY2llIGRpIGlucHV0IHB1w7IgZXNzZXJlIHZpc3RvIGRhbGxlIHBvc2l6aW9uaSBkaSBwdW50aSBkaSBvc3NlcnZhemlvbmUgZGkgaW5wdXQgKGNvbWUgcHVudGkgbyBjb21lIHZlcnRpY2kgcGVyIGxlIGZlYXR1cmUgZGkgcHVudGkgZGkgb3NzZXJ2YXppb25lIHBvbGlsaW5lYXJlKS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAVmlld3NoZWRfQW5hbHlzaXMtVHlwZV90YWcyQEBcIjogXCJQdW50aSBkaSBvc3NlcnZhemlvbmU6IGwnaW5wdXQgaWRlbnRpZmljYSBlc2F0dGFtZW50ZSBxdWFsaSBzb25vIGkgcHVudGkgZGkgb3NzZXJ2YXppb25lIHZpc2liaWxpIGRhIG9nbmkgcG9zaXppb25lIGRpIHN1cGVyZmljaWUgcmFzdGVyLiBDb24gcXVlc3RvIHRpcG8gZGkgYW5hbGlzaSBpbCBudW1lcm8gbWFzc2ltbyBjb25zZW50aXRvIGRpIHB1bnRpIGRpIG9zc2VydmF6aW9uZSBkaSBpbnB1dCDDqCAzMi5cIixcblx0XCJAQFZpZXdzaGVkX0hvcml6b250YWwtRW5kLUFuZ2xlX3RhZzBAQFwiOiBcIlF1ZXN0byB2YWxvcmUgZGVmaW5pc2NlIGwnYW5nb2xvIGZpbmFsZSBkZWxsJ2ludGVydmFsbG8gZGkgc2NhbnNpb25lIG9yaXp6b250YWxlLiBJbCB2YWxvcmUgZG92cmViYmUgZXNzZXJlIHNwZWNpZmljYXRvIGluIGdyYWRpIGRhIDAgYSAzNjAsMCwgaW4gY3VpIGxvIDAgw6ggb3JpZW50YXRvIGEgTm9yZC4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDM2MCwwLlwiLFxuXHRcIkBAVmlld3NoZWRfSG9yaXpvbnRhbC1FbmQtQW5nbGVfdGFnMUBAXCI6IFwiUHXDsiBlc3NlcmUgdW4gY2FtcG8gbmVsIGRhdGFzZXQgPHN0cm9uZz5GZWF0dXJlIG9zc2VydmF0b3JpPC9zdHJvbmc+IGRpIGlucHV0IG8gdW4gdmFsb3JlIG51bWVyaWNvLiBTZSBxdWVzdG8gcGFyYW1ldHJvIMOoIGltcG9zdGF0byBzdSB1biB2YWxvcmUsIHF1ZWwgdmFsb3JlIHNhcsOgIGFwcGxpY2F0byBhIHR1dHRpIGdsaSBvc3NlcnZhdG9yaS4gUGVyIHNwZWNpZmljYXJlIHZhbG9yaSBkaXZlcnNpIHBlciBvZ25pIG9zc2VydmF0b3JlLCBpbXBvc3RhcmUgcXVlc3RvIHBhcmFtZXRybyBzdSB1biBjYW1wbyBuZWwgZGF0YXNldCA8c3Ryb25nPkZlYXR1cmUgb3NzZXJ2YXRvcmk8L3N0cm9uZz4uXCIsXG5cdFwiQEBWaWV3c2hlZF9Ib3Jpem9udGFsLVN0YXJ0LUFuZ2xlX3RhZzBAQFwiOiBcIlF1ZXN0byB2YWxvcmUgZGVmaW5pc2NlIGwnYW5nb2xvIGluaXppYWxlIGRlbGwnaW50ZXJ2YWxsbyBkaSBzY2Fuc2lvbmUgb3JpenpvbnRhbGUuIElsIHZhbG9yZSBkb3ZyZWJiZSBlc3NlcmUgc3BlY2lmaWNhdG8gaW4gZ3JhZGkgZGEgMCBhIDM2MCwwLCBpbiBjdWkgbG8gMCDDqCBvcmllbnRhdG8gYSBOb3JkLiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggMC5cIixcblx0XCJAQFZpZXdzaGVkX0hvcml6b250YWwtU3RhcnQtQW5nbGVfdGFnMUBAXCI6IFwiUHXDsiBlc3NlcmUgdW4gY2FtcG8gbmVsIGRhdGFzZXQgPHN0cm9uZz5GZWF0dXJlIG9zc2VydmF0b3JpPC9zdHJvbmc+IGRpIGlucHV0IG8gdW4gdmFsb3JlIG51bWVyaWNvLiBTZSBxdWVzdG8gcGFyYW1ldHJvIMOoIGltcG9zdGF0byBzdSB1biB2YWxvcmUsIHF1ZWwgdmFsb3JlIHNhcsOgIGFwcGxpY2F0byBhIHR1dHRpIGdsaSBvc3NlcnZhdG9yaS4gUGVyIHNwZWNpZmljYXJlIHZhbG9yaSBkaXZlcnNpIHBlciBvZ25pIG9zc2VydmF0b3JlLCBpbXBvc3RhcmUgcXVlc3RvIHBhcmFtZXRybyBzdSB1biBjYW1wbyBuZWwgZGF0YXNldCA8c3Ryb25nPkZlYXR1cmUgb3NzZXJ2YXRvcmk8L3N0cm9uZz4uXCIsXG5cdFwiQEBWaWV3c2hlZF9Jbm5lci1SYWRpdXMtaXMtM0QtRGlzdGFuY2VfdGFnMEBAXCI6IFwiSWwgdGlwbyBkaSBkaXN0YW56YSBwZXIgaWwgcGFyYW1ldHJvIGRlbCByYWdnaW8gaW50ZXJuby5cIixcblx0XCJAQFZpZXdzaGVkX0lubmVyLVJhZGl1cy1pcy0zRC1EaXN0YW5jZV90YWcxQEBcIjogXCJOb24gc2VsZXppb25hdG86IDxzdHJvbmc+UmFnZ2lvIGludGVybm88L3N0cm9uZz4gZGV2ZSBlc3NlcmUgaW50ZXJwcmV0YXRvIGNvbWUgdW5hIGRpc3RhbnphIDJELiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBWaWV3c2hlZF9Jbm5lci1SYWRpdXMtaXMtM0QtRGlzdGFuY2VfdGFnNEBAXCI6IFwiU2VsZXppb25hdG86IDxzdHJvbmc+UmFnZ2lvIGludGVybm88L3N0cm9uZz4gZGV2ZSBlc3NlcmUgaW50ZXJwcmV0YXRvIGNvbWUgdW5hIGRpc3RhbnphIDNELlwiLFxuXHRcIkBAVmlld3NoZWRfSW5uZXItUmFkaXVzX3RhZzBAQFwiOiBcIlF1ZXN0byB2YWxvcmUgZGVmaW5pc2NlIGxhIGRpc3RhbnphIGluaXppYWxlIChtaW5pbWEpIGRhIGN1aSB2aWVuZSBkZXRlcm1pbmF0YSBsYSB2aXNpYmlsaXTDoC4gSSBwaXhlbCBwacO5IHZpY2luaSBhIHF1ZXN0YSBkaXN0YW56YSBzb25vIGNvbnNpZGVyYXRpIG5vbiB2aXNpYmlsaSBuZWxsJ291dHB1dCBtYSBwb3Nzb25vIGNvbXVucXVlIGJsb2NjYXJlIGxhIHZpc2liaWxpdMOgIGRlaSBwaXhlbCB0cmEgPHN0cm9uZz5SYWdnaW8gaW50ZXJubzwvc3Ryb25nPiBlIDxzdHJvbmc+UmFnZ2lvIGVzdGVybm88L3N0cm9uZz4uIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAwLlwiLFxuXHRcIkBAVmlld3NoZWRfSW5uZXItUmFkaXVzX3RhZzVAQFwiOiBcIlB1w7IgZXNzZXJlIHVuIGNhbXBvIG5lbCBkYXRhc2V0IDxzdHJvbmc+RmVhdHVyZSBvc3NlcnZhdG9yaTwvc3Ryb25nPiBkaSBpbnB1dCBvIHVuIHZhbG9yZSBudW1lcmljby4gU2UgcXVlc3RvIHBhcmFtZXRybyDDqCBpbXBvc3RhdG8gc3UgdW4gdmFsb3JlLCBxdWVsIHZhbG9yZSBzYXLDoCBhcHBsaWNhdG8gYSB0dXR0aSBnbGkgb3NzZXJ2YXRvcmkuIFBlciBzcGVjaWZpY2FyZSB2YWxvcmkgZGl2ZXJzaSBwZXIgb2duaSBvc3NlcnZhdG9yZSwgaW1wb3N0YXJlIHF1ZXN0byBwYXJhbWV0cm8gc3UgdW4gY2FtcG8gbmVsIGRhdGFzZXQgPHN0cm9uZz5GZWF0dXJlIG9zc2VydmF0b3JpPC9zdHJvbmc+LlwiLFxuXHRcIkBAVmlld3NoZWRfT2JzZXJ2ZXItRWxldmF0aW9uX3RhZzBAQFwiOiBcIlF1ZXN0byB2YWxvcmUgdmllbmUgdXRpbGl6emF0byBwZXIgZGVmaW5pcmUgbGUgZWxldmF6aW9uaSBkZWxsYSBzdXBlcmZpY2llIGRlaSBwdW50aSBvIGRlaSB2ZXJ0aWNpIGRlbGwnb3NzZXJ2YXRvcmUuXCIsXG5cdFwiQEBWaWV3c2hlZF9PYnNlcnZlci1FbGV2YXRpb25fdGFnMUBAXCI6IFwiUHXDsiBlc3NlcmUgdW4gY2FtcG8gbmVsIGRhdGFzZXQgPHN0cm9uZz5GZWF0dXJlIG9zc2VydmF0b3JpPC9zdHJvbmc+IGRpIGlucHV0IG8gdW4gdmFsb3JlIG51bWVyaWNvLiBTZSBxdWVzdG8gcGFyYW1ldHJvIG5vbiDDqCBzcGVjaWZpY2F0bywgbCdlbGV2YXppb25lIGRlbCBwdW50byBkaSBvc3NlcnZhemlvbmUgc2Fyw6Agb3R0ZW51dGEgZGFsIHJhc3RlciBkaSBzdXBlcmZpY2llIHV0aWxpenphbmRvIHVuJ2ludGVycG9sYXppb25lIGJpbGluZWFyZS4gU2UgcXVlc3RvIHBhcmFtZXRybyDDqCBpbXBvc3RhdG8gc3UgdW4gdmFsb3JlLCBxdWVsIHZhbG9yZSBzYXLDoCBhcHBsaWNhdG8gYSB0dXR0aSBpIHB1bnRpIGRpIG9zc2VydmF6aW9uZS4gUGVyIHNwZWNpZmljYXJlIHZhbG9yaSBkaXZlcnNpIHBlciBvZ25pIG9zc2VydmF0b3JlLCBpbXBvc3RhcmUgcXVlc3RvIHBhcmFtZXRybyBzdSB1biBjYW1wbyBuZWwgZGF0YXNldCA8c3Ryb25nPkZlYXR1cmUgb3NzZXJ2YXRvcmk8L3N0cm9uZz4uXCIsXG5cdFwiQEBWaWV3c2hlZF9PYnNlcnZlci1GZWF0dXJlc190YWcwQEBcIjogXCJMYSBmZWF0dXJlIGNsYXNzIGRpIGlucHV0IG9iYmxpZ2F0b3JpYSBjaGUgaWRlbnRpZmljYSBsZSBwb3NpemlvbmkgZGVsIHB1bnRvIGRpIG9zc2VydmF6aW9uZS4gU2kgcHXDsiB0cmF0dGFyZSBkaSBmZWF0dXJlIHB1bnR1YWxpLCBtdWx0aXB1bnR1YWxpIG8gcG9saWxpbmVhcmkuXCIsXG5cdFwiQEBWaWV3c2hlZF9PYnNlcnZlci1GZWF0dXJlc190YWcxQEBcIjogXCJMYSBmZWF0dXJlIGNsYXNzIGRpIGlucHV0IHZpZW5lIHRyYXNmb3JtYXRhIGluIHVuIHNpc3RlbWEgZGkgY29vcmRpbmF0ZSBnZW9jZW50cmljbyAzRCBkdXJhbnRlIGlsIGNhbGNvbG8gZGVsbGEgdmlzaWJpbGl0w6AuIEkgcHVudGkgZGkgb3NzZXJ2YXppb25lIGFsbCdlc3Rlcm5vIGRlbGwnZXN0ZW5zaW9uZSBkZWwgcmFzdGVyIGRpIHN1cGVyZmljaWUgbyBwb3NpemlvbmF0aSBuZWxsZSBjZWxsZSBOb0RhdGEgdmVycmFubm8gaWdub3JhdGkgbmVsIGNhbGNvbG8uXCIsXG5cdFwiQEBWaWV3c2hlZF9PYnNlcnZlci1PZmZzZXRfdGFnMEBAXCI6IFwiUXVlc3RvIHZhbG9yZSBpbmRpY2EgdW5hIGRpc3RhbnphIHZlcnRpY2FsZSAobmVsbGUgdW5pdMOgIGRpIHN1cGVyZmljaWUpIGRhIGFnZ2l1bmdlcmUgYWxsJ2VsZXZhemlvbmUgZGVsIHB1bnRvIGRpIG9zc2VydmF6aW9uZS4gRGV2ZSBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBwb3NpdGl2byBvIHVuIHZhbG9yZSBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBAVmlld3NoZWRfT2JzZXJ2ZXItT2Zmc2V0X3RhZzFAQFwiOiBcIlB1w7IgZXNzZXJlIHVuIGNhbXBvIG5lbCBkYXRhc2V0IDxzdHJvbmc+RmVhdHVyZSBvc3NlcnZhdG9yaTwvc3Ryb25nPiBkaSBpbnB1dCBvIHVuIHZhbG9yZSBudW1lcmljby4gU2UgcXVlc3RvIHBhcmFtZXRybyDDqCBpbXBvc3RhdG8gc3UgdW4gdmFsb3JlLCBxdWVsIHZhbG9yZSBzYXLDoCBhcHBsaWNhdG8gYSB0dXR0aSBnbGkgb3NzZXJ2YXRvcmkuIFBlciBzcGVjaWZpY2FyZSB2YWxvcmkgZGl2ZXJzaSBwZXIgb2duaSBvc3NlcnZhdG9yZSwgaW1wb3N0YXJlIHF1ZXN0byBwYXJhbWV0cm8gc3UgdW4gY2FtcG8gbmVsIGRhdGFzZXQgPHN0cm9uZz5GZWF0dXJlIG9zc2VydmF0b3JpPC9zdHJvbmc+LlwiLFxuXHRcIkBAVmlld3NoZWRfT3V0ZXItUmFkaXVzLWlzLTNELURpc3RhbmNlX3RhZzBAQFwiOiBcIklsIHRpcG8gZGkgZGlzdGFuemEgcGVyIGlsIHBhcmFtZXRybyBkZWwgcmFnZ2lvIGVzdGVybm8uXCIsXG5cdFwiQEBWaWV3c2hlZF9PdXRlci1SYWRpdXMtaXMtM0QtRGlzdGFuY2VfdGFnMUBAXCI6IFwiTm9uIHNlbGV6aW9uYXRvOiA8c3Ryb25nPlJhZ2dpbyBlc3Rlcm5vPC9zdHJvbmc+IGRldmUgZXNzZXJlIGludGVycHJldGF0byBjb21lIHVuYSBkaXN0YW56YSAyRC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAVmlld3NoZWRfT3V0ZXItUmFkaXVzLWlzLTNELURpc3RhbmNlX3RhZzRAQFwiOiBcIlNlbGV6aW9uYXRvOiA8c3Ryb25nPlJhZ2dpbyBlc3Rlcm5vPC9zdHJvbmc+IGRldmUgZXNzZXJlIGludGVycHJldGF0byBjb21lIHVuYSBkaXN0YW56YSAzRC5cIixcblx0XCJAQFZpZXdzaGVkX091dGVyLVJhZGl1c190YWcwQEBcIjogXCJRdWVzdG8gdmFsb3JlIGRlZmluaXNjZSBsYSBkaXN0YW56YSBtYXNzaW1hIGRhIGN1aSB2aWVuZSBkZXRlcm1pbmF0YSBsYSB2aXNpYmlsaXTDoC4gSSBwaXhlbCBvbHRyZSBxdWVzdGEgZGlzdGFuemEgdmVuZ29ubyBlc2NsdXNpIGRhbGwnYW5hbGlzaS5cIixcblx0XCJAQFZpZXdzaGVkX091dGVyLVJhZGl1c190YWcxQEBcIjogXCJQdcOyIGVzc2VyZSB1biBjYW1wbyBuZWwgZGF0YXNldCA8c3Ryb25nPkZlYXR1cmUgb3NzZXJ2YXRvcmk8L3N0cm9uZz4gZGkgaW5wdXQgbyB1biB2YWxvcmUgbnVtZXJpY28uIFNlIHF1ZXN0byBwYXJhbWV0cm8gw6ggaW1wb3N0YXRvIHN1IHVuIHZhbG9yZSwgcXVlbCB2YWxvcmUgc2Fyw6AgYXBwbGljYXRvIGEgdHV0dGkgZ2xpIG9zc2VydmF0b3JpLiBQZXIgc3BlY2lmaWNhcmUgdmFsb3JpIGRpdmVyc2kgcGVyIG9nbmkgb3NzZXJ2YXRvcmUsIGltcG9zdGFyZSBxdWVzdG8gcGFyYW1ldHJvIHN1IHVuIGNhbXBvIG5lbCBkYXRhc2V0IDxzdHJvbmc+RmVhdHVyZSBvc3NlcnZhdG9yaTwvc3Ryb25nPi5cIixcblx0XCJAQFZpZXdzaGVkX1Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgc3VwZXJmaWNpZSBkaSBpbnB1dCBvYmJsaWdhdG9yaW8uIFB1w7IgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8gbyB1biByYXN0ZXIgYSB2aXJnb2xhIG1vYmlsZS5cIixcblx0XCJAQFZpZXdzaGVkX1Jhc3Rlcl90YWcxQEBcIjogXCJMJ2lucHV0IHZpZW5lIHRyYXNmb3JtYXRvIGluIHVuIHNpc3RlbWEgZGkgY29vcmRpbmF0ZSBnZW9jZW50cmljbyAzRCBkdXJhbnRlIGlsIGNhbGNvbG8gZGVsbGEgdmlzaWJpbGl0w6AuIExlIGNlbGxlIE5vRGF0YSBkZWwgcmFzdGVyIGRpIGlucHV0IG5vbiBibG9jY2FubyBsYSBkZXRlcm1pbmF6aW9uZSBkZWxsYSB2aXNpYmlsaXTDoC5cIixcblx0XCJAQFZpZXdzaGVkX1JlZnJhY3RpdmUtQ29lZmZpY2llbnRfdGFnMEBAXCI6IFwiQ29lZmZpY2llbnRlIGRpIHJlZnJhdHRpdml0w6AgZGVsbGEgbHVjZSB2aXNpYmlsZSBuZWxsJ2FyaWEuXCIsXG5cdFwiQEBWaWV3c2hlZF9SZWZyYWN0aXZlLUNvZWZmaWNpZW50X3RhZzFAQFwiOiBcIklsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAwLDEzLlwiLFxuXHRcIkBAVmlld3NoZWRfU3VyZmFjZS1PZmZzZXRfdGFnMEBAXCI6IFwiUXVlc3RvIHZhbG9yZSBpbmRpY2EgdW5hIGRpc3RhbnphIHZlcnRpY2FsZSAobmVsbGUgdW5pdMOgIGRpIHN1cGVyZmljaWUpIGRhIGFnZ2l1bmdlcmUgYWwgdmFsb3JlIHogZGkgb2duaSBwaXhlbCBkaSB0YXJnZXQgY29zw6wgY29tZSDDqCBjb25zaWRlcmF0YSBwZXIgbGEgdmlzaWJpbGl0w6AuIERldmUgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8gcG9zaXRpdm8gbyB1biB2YWxvcmUgYSB2aXJnb2xhIG1vYmlsZS5cIixcblx0XCJAQFZpZXdzaGVkX1N1cmZhY2UtT2Zmc2V0X3RhZzFAQFwiOiBcIlB1w7IgZXNzZXJlIHVuIGNhbXBvIG5lbCBkYXRhc2V0IDxzdHJvbmc+RmVhdHVyZSBvc3NlcnZhdG9yaTwvc3Ryb25nPiBkaSBpbnB1dCBvIHVuIHZhbG9yZSBudW1lcmljby4gU2UgcXVlc3RvIHBhcmFtZXRybyDDqCBpbXBvc3RhdG8gc3UgdW4gdmFsb3JlLCBxdWVsIHZhbG9yZSBzYXLDoCBhcHBsaWNhdG8gYSB0dXR0aSBnbGkgb3NzZXJ2YXRvcmkuIFBlciBzcGVjaWZpY2FyZSB2YWxvcmkgZGl2ZXJzaSBwZXIgb2duaSBvc3NlcnZhdG9yZSwgaW1wb3N0YXJlIHF1ZXN0byBwYXJhbWV0cm8gc3UgdW4gY2FtcG8gbmVsIGRhdGFzZXQgPHN0cm9uZz5GZWF0dXJlIG9zc2VydmF0b3JpPC9zdHJvbmc+LlwiLFxuXHRcIkBAVmlld3NoZWRfVmVydGljYWwtRXJyb3JfdGFnMEBAXCI6IFwiTGEgcXVhbnRpdMOgIGRpIGluY2VydGV6emEsIG1pc3VyYXRhIHRyYW1pdGUgbCdlcnJvcmUgcXVhZHJhdG8gbWVkaWEgcmFkaWNlIChSTVNFKSwgbmVpIHZhbG9yaSBkaSBlbGV2YXppb25lIGRlbGxhIHN1cGVyZmljaWUuIFNpIHRyYXR0YSBkaSB1biB2YWxvcmUgYSB2aXJnb2xhIG1vYmlsZSBjaGUgcmFwcHJlc2VudGEgbCdlcnJvcmUgcHJldmlzdG8gZGVpIHZhbG9yaSBkaSBlbGV2YXppb25lIGRpIGlucHV0LiBRdWFuZG8gYSBxdWVzdG8gcGFyYW1ldHJvIHZpZW5lIGFzc2VnbmF0byB1biB2YWxvcmUgbWFnZ2lvcmUgZGkgMCwgaWwgcmFzdGVyIGRpIHZpc2liaWxpdMOgIGRpIG91dHB1dCBzYXLDoCB1bmEgdmlyZ29sYSBtb2JpbGUuIEluIHRhbCBjYXNvLCBvZ25pIHZhbG9yZSBkaSBwaXhlbCBuZWwgcmFzdGVyIGRpIHZpc2liaWxpdMOgIGRpIG91dHB1dCByYXBwcmVzZW50YSBsYSBzb21tYSBkZWxsZSBwcm9iYWJpbGl0w6AgY2hlIHF1ZWxsYSBjZWxsYSBzaWEgdmlzaWJpbGUgYSBxdWFsc2lhc2kgZGVpIHB1bnRpIGRpIG9zc2VydmF6aW9uZS5cIixcblx0XCJAQFZpZXdzaGVkX1ZlcnRpY2FsLUVycm9yX3RhZzFAQFwiOiBcIlF1YW5kbyBpbCA8c3Ryb25nPlRpcG8gZGkgYW5hbGlzaTwvc3Ryb25nPiDDqCA8c3Ryb25nPk9zc2VydmF0b3JpPC9zdHJvbmc+IG8gaWwgPHN0cm9uZz5NZXRvZG8gZGkgYW5hbGlzaTwvc3Ryb25nPiDDqCA8c3Ryb25nPkxpbmVlIGRpIHZpc3RhIHBlcmltZXRyYWxpPC9zdHJvbmc+LCBxdWVzdG8gcGFyYW1ldHJvIMOoIGRpc2FiaWxpdGF0by5cIixcblx0XCJAQFZpZXdzaGVkX1ZlcnRpY2FsLUxvd2VyLUFuZ2xlX3RhZzBAQFwiOiBcIlF1ZXN0byB2YWxvcmUgZGVmaW5pc2NlIGlsIGxpbWl0ZSBkZWxsJ2FuZ29sbyB2ZXJ0aWNhbGUgaW5mZXJpb3JlIGRlbGxhIHNjYW5zaW9uZSBzb3R0byB1biBwaWFubyBvcml6em9udGFsZS4gSWwgdmFsb3JlIGRldmUgZXNzZXJlIHNwZWNpZmljYXRvIGluIGdyYWRpIGRhIC05MCwwIGEgMCwgY29tZSBudW1lcm8gaW50ZXJvIG8gYSB2aXJnb2xhIG1vYmlsZS4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIC05MCwwLlwiLFxuXHRcIkBAVmlld3NoZWRfVmVydGljYWwtTG93ZXItQW5nbGVfdGFnMUBAXCI6IFwiUHXDsiBlc3NlcmUgdW4gY2FtcG8gbmVsIGRhdGFzZXQgPHN0cm9uZz5GZWF0dXJlIG9zc2VydmF0b3JpPC9zdHJvbmc+IGRpIGlucHV0IG8gdW4gdmFsb3JlIG51bWVyaWNvLiBTZSBxdWVzdG8gcGFyYW1ldHJvIMOoIGltcG9zdGF0byBzdSB1biB2YWxvcmUsIHF1ZWwgdmFsb3JlIHNhcsOgIGFwcGxpY2F0byBhIHR1dHRpIGdsaSBvc3NlcnZhdG9yaS4gUGVyIHNwZWNpZmljYXJlIHZhbG9yaSBkaXZlcnNpIHBlciBvZ25pIG9zc2VydmF0b3JlLCBpbXBvc3RhcmUgcXVlc3RvIHBhcmFtZXRybyBzdSB1biBjYW1wbyBuZWwgZGF0YXNldCA8c3Ryb25nPkZlYXR1cmUgb3NzZXJ2YXRvcmk8L3N0cm9uZz4uXCIsXG5cdFwiQEBWaWV3c2hlZF9WZXJ0aWNhbC1VcHBlci1BbmdsZV90YWcwQEBcIjogXCJRdWVzdG8gdmFsb3JlIGRlZmluaXNjZSBpbCBsaW1pdGUgZGVsbCdhbmdvbG8gdmVydGljYWxlIHN1cGVyaW9yZSBkZWxsYSBzY2Fuc2lvbmUgc29wcmEgdW4gcGlhbm8gb3JpenpvbnRhbGUuIElsIHZhbG9yZSBkZXZlIGVzc2VyZSBzcGVjaWZpY2F0byBpbiBncmFkaSBkYSAwIGEgOTAsMCwgY29tZSBudW1lcm8gaW50ZXJvIG8gYSB2aXJnb2xhIG1vYmlsZS4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDkwLDAuXCIsXG5cdFwiQEBWaWV3c2hlZF9WZXJ0aWNhbC1VcHBlci1BbmdsZV90YWcxQEBcIjogXCJQdcOyIGVzc2VyZSB1biBjYW1wbyBuZWwgZGF0YXNldCA8c3Ryb25nPkZlYXR1cmUgb3NzZXJ2YXRvcmk8L3N0cm9uZz4gZGkgaW5wdXQgbyB1biB2YWxvcmUgbnVtZXJpY28uIFNlIHF1ZXN0byBwYXJhbWV0cm8gw6ggaW1wb3N0YXRvIHN1IHVuIHZhbG9yZSwgcXVlbCB2YWxvcmUgc2Fyw6AgYXBwbGljYXRvIGEgdHV0dGkgZ2xpIG9zc2VydmF0b3JpLiBQZXIgc3BlY2lmaWNhcmUgdmFsb3JpIGRpdmVyc2kgcGVyIG9nbmkgb3NzZXJ2YXRvcmUsIGltcG9zdGFyZSBxdWVzdG8gcGFyYW1ldHJvIHN1IHVuIGNhbXBvIG5lbCBkYXRhc2V0IDxzdHJvbmc+RmVhdHVyZSBvc3NlcnZhdG9yaTwvc3Ryb25nPi5cIixcblx0XCJAQFdhdGVyc2hlZF9GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IGNoZSBtb3N0cmEgbGEgZGlyZXppb25lIGRlbCBmbHVzc28gZnVvcmkgZGEgb2duaSBjZWxsYS5cIixcblx0XCJAQFdhdGVyc2hlZF9GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMUBAXCI6IFwiSWwgcmFzdGVyIGRpIGRpcmV6aW9uZSBkZWwgZmx1c3NvIHB1w7IgZXNzZXJlIGNyZWF0byBlc2VndWVuZG8gbGEgZnVuemlvbmUgPHN0cm9uZz5EaXJlemlvbmUgZmx1c3NvPC9zdHJvbmc+LlwiLFxuXHRcIkBAV2F0ZXJzaGVkX1BvdXItUG9pbnQocyktUmFzdGVyX3RhZzBAQFwiOiBcIkxlIHBvc2l6aW9uaSBkZWwgcHVudG8gZGkgdmVyc2FtZW50byBkaSBpbnB1dC5cIixcblx0XCJAQFdhdGVyc2hlZF9Qb3VyLVBvaW50KHMpLVJhc3Rlcl90YWcxQEBcIjogXCJRdWVzdG8gcmFzdGVyIHJhcHByZXNlbnRhIGxlIGNlbGxlIG9sdHJlIGxlIHF1YWxpIHZlcnJhbm5vIGRldGVybWluYXRlIGwnYXJlYSBvIGlsIGJhY2lubyBwbHV2aWFsZSBkaSBjb250cmlidXppb25lLiBUdXR0ZSBsZSBjZWxsZSBjaGUgbm9uIHNvbm8gTm9EYXRhIHZlcnJhbm5vIHV0aWxpenphdGUgY29tZSBjZWxsZSBkaSBvcmlnaW5lLlwiLFxuXHRcIkBAV2F0ZXJzaGVkX1BvdXItUG9pbnQtRmllbGRfdGFnMEBAXCI6IFwiSWwgY2FtcG8gdXNhdG8gcGVyIGFzc2VnbmFyZSB2YWxvcmkgYWxsZSBwb3NpemlvbmkgZGVsIHB1bnRvIGRpIHZlcnNhbWVudG8uXCIsXG5cdFwiQEBXYXRlcnNoZWRfUG91ci1Qb2ludC1GaWVsZF90YWcxQEBcIjogXCJQZXIgdW4gZGF0YXNldCBkaSBwdW50aSBkaSB2ZXJzYW1lbnRvIHJhc3RlciwgJHtWYWx1ZX0gdmllbmUgdXRpbGl6emF0byBjb21lIHZhbG9yZSBwcmVkZWZpbml0by5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJNaW5pbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHBpw7kgcGljY29sYSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJVbHRpbW8gZGk6IHVzYSBsYSBkaW1lbnNpb25lIGRlbGwndWx0aW1hIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVuaW9uZSBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfU2NhbGVzX3RhZzBAQFwiOiBcIkwnaW50ZXJ2YWxsbyBwZXIgaSBudW92aSB2YWxvcmkgc2Vjb25kbyBpIHF1YWxpIHJpbWFwcGFyZSBpIHZhbG9yaSBwcmVjZWRlbnRpLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9XZWlnaHRlZC1PdmVybGF5LVRhYmxlX3RhZzBAQFwiOiBcIkxhIHRhYmVsbGEgZGkgb3ZlcmxheSBwb25kZXJhdGEgw6ggZm9ybWF0YSBkYSBxdWF0dHJvIHBhcnRpOlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9XZWlnaHRlZC1PdmVybGF5LVRhYmxlX3RhZzFAQFwiOiBcIkxheWVyOiB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dCBkZXZvbm8gZXNzZXJlIGRpIHRpcG8gaW50ZXJvLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9XZWlnaHRlZC1PdmVybGF5LVRhYmxlX3RhZzJAQFwiOiBcIkluZmx1ZW56YTogb2duaSByYXN0ZXIgZGkgaW5wdXQgdmllbmUgcG9uZGVyYXRvIHNlY29uZG8gbGEgc3VhIGltcG9ydGFuemEsIG8gbGEgc3VhIGluZmx1ZW56YSwgY29tZSBwZXJjZW50dWFsZSByZWxhdGl2YS4gTGEgc29tbWEgZGVsbGUgcG9uZGVyYXppb25pIGRpIGluZmx1ZW56YSBpbiBwZXJjZW50dWFsZSBkZXZlIGVzc2VyZSB1Z3VhbGUgYSAxMDAsIGUgb2duaSBwb25kZXJhemlvbmUgZGV2ZSBlc3NlcmUgc3BlY2lmaWNhdGEgZGEgdmFsb3JpIGludGVyaS5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfV2VpZ2h0ZWQtT3ZlcmxheS1UYWJsZV90YWczQEBcIjogXCJDYW1wbzogdW4gY2FtcG8gaW50ZXJvIG8gc3RyaW5nYSBuZWwgcmFzdGVyIGRpIGlucHV0IHV0aWxpenphdG8gcGVyIGxhIHBvbmRlcmF6aW9uZS5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfV2VpZ2h0ZWQtT3ZlcmxheS1UYWJsZV90YWc0QEBcIjogXCJUYWJlbGxhIGRpIHJpbWFwcGF0dXJhOiBhIG9nbmkgdmFsb3JlIGRpIHVuIHJhc3RlciBkaSBpbnB1dCB2aWVuZSBhc3NlZ25hdG8gdW4gbnVvdm8gdmFsb3JlIGRpIHNjYWxhIGJhc2F0byBzdWxsYSB0YWJlbGxhIGRpIHJpbWFwcGF0dXJhLiBJbCB2YWxvcmUgZGkgc2NhbGEgcHXDsiBlc3NlcmUgdW4gdmFsb3JlIHZhbGlkbyBvIHVuIHZhbG9yZSBOb0RhdGEuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJTY2VnbGllcmUgcXVhbGUgZGltZW5zaW9uZSBkaSBjZWxsYSB1c2FyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgbGUgZGltZW5zaW9uaSBkaSB0dXR0ZSBsZSBjZWxsZSBkaSBpbnB1dCBzb25vIHVndWFsaSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBwcmltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWFzc2ltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgcGnDuSBncmFuZGUgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWRpYSBkaTogdXNhIGxhIGRpbWVuc2lvbmUgbWVkaWEgZGVsbGEgY2VsbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIHNpIGRvdnJlYmJlIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0OlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIlByaW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVsdGltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX1dlaWdodGVkLVN1bS1UYWJsZV90YWcwQEBcIjogXCJMYSB0YWJlbGxhIGRpIHNvbW1lIHBvbmRlcmF0ZSDDqCBkZWZpbml0YSBkYSB0cmUgcHJvcHJpZXTDoDpcIixcblx0XCJAQFdlaWdodGVkLVN1bV9XZWlnaHRlZC1TdW0tVGFibGVfdGFnMUBAXCI6IFwiTGF5ZXI6IGlsIHJhc3RlciBkYSBwb25kZXJhcmUuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fV2VpZ2h0ZWQtU3VtLVRhYmxlX3RhZzJAQFwiOiBcIkNhbXBvOiBpbCBjYW1wbyBkZWwgcmFzdGVyIGRhIHVzYXJlIHBlciBsYSBwb25kZXJhemlvbmUuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fV2VpZ2h0ZWQtU3VtLVRhYmxlX3RhZzNAQFwiOiBcIlBvbmRlcmF6aW9uZTogaWwgdmFsb3JlIGRpIHBvbmRlcmF6aW9uZSBwZXIgaWwgcXVhbGUgbW9sdGlwbGljYXJlIGlsIHJhc3Rlci4gUHXDsiBlc3NlcmUgdW4gdmFsb3JlIGRlY2ltYWxlIHBvc2l0aXZvIG8gbmVnYXRpdm8uXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1RlbXBlcmF0dXJlLVJhc3Rlcl90YWcwQEBcIjogXCJVbiByYXN0ZXIgYSBiYW5kYSBzaW5nb2xhIGluIGN1aSBpIHZhbG9yaSBkaSBwaXhlbCByYXBwcmVzZW50YW5vIGxhIHRlbXBlcmF0dXJhIGRlbGwnYXJpYSBkaSBhbWJpZW50ZS5cIixcblx0XCJAQFdpbmQtQ2hpbGxfVGVtcGVyYXR1cmUtVW5pdHNfdGFnMEBAXCI6IFwiTCd1bml0w6AgZGkgbWlzdXJhIGFzc29jaWF0YSBhbCByYXN0ZXIgZGkgdGVtcGVyYXR1cmEgZGkgaW5wdXQuIExlIHVuaXTDoCBkaSBpbnB1dCBkaXNwb25pYmlsaSBzb25vIENlbHNpdXMsIEZhaHJlbmhlaXQgZSBLZWx2aW4uXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1dpbmQtQ2hpbGwtVW5pdHNfdGFnMEBAXCI6IFwiTCd1bml0w6AgZGkgbWlzdXJhIGFzc29jaWF0YSBjb24gaWwgcmFzdGVyIGRpIG91dHB1dC4gTGUgdW5pdMOgIGRpIG91dHB1dCBkaXNwb25pYmlsaSBzb25vIENlbHNpdXMsIEZhaHJlbmhlaXQgZSBLZWx2aW4uXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1dpbmQtU3BlZWQtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBhIGJhbmRhIHNpbmdvbGEgaW4gY3VpIGkgdmFsb3JpIGRpIHBpeGVsIHJhcHByZXNlbnRhbm8gbGEgdmVsb2NpdMOgIGRlbCB2ZW50by5cIixcblx0XCJAQFdpbmQtQ2hpbGxfV2luZC1TcGVlZC1Vbml0c190YWcwQEBcIjogXCJEZWZpbmlzY2UgbCd1bml0w6AgZGkgbWlzdXJhIHBlciBpbCByYXN0ZXIgdmVsb2NpdMOgIGRlbCB2ZW50bzpcIixcblx0XCJAQFdpbmQtQ2hpbGxfV2luZC1TcGVlZC1Vbml0c190YWcxQEBcIjogXCJNaWdsaWEgYWxsJ29yYSAobXBoKVwiLFxuXHRcIkBAV2luZC1DaGlsbF9XaW5kLVNwZWVkLVVuaXRzX3RhZzJAQFwiOiBcIkNoaWxvbWV0cmkgYWxsJ29yYSAoa20vaClcIixcblx0XCJAQFdpbmQtQ2hpbGxfV2luZC1TcGVlZC1Vbml0c190YWczQEBcIjogXCJNZXRyaSBhbCBzZWNvbmRvIChtL3MpXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1dpbmQtU3BlZWQtVW5pdHNfdGFnNEBAXCI6IFwiUGllZGkgYWwgc2Vjb25kbyAoZnQvcylcIixcblx0XCJAQFdpbmQtQ2hpbGxfV2luZC1TcGVlZC1Vbml0c190YWc1QEBcIjogXCJOb2RpIChrbilcIixcblx0XCJAQFpvbmFsLVJlbWFwX0JhY2tncm91bmQtVmFsdWVfdGFnMEBAXCI6IFwiSWwgdmFsb3JlIGluaXppYWxlIGRpIHBpeGVsIGRlbCByYXN0ZXIgZGkgb3V0cHV0LCBwcmltYSBkZWwgcmljYWxjb2xvIGRlaSBwaXhlbCBkaSBpbnB1dC5cIixcblx0XCJAQFpvbmFsLVJlbWFwX0RlZmF1bHQtT3V0cHV0LVZhbHVlX3RhZzBAQFwiOiBcIklsIHZhbG9yZSBjaGUgc2Fyw6AgYXNzZWduYXRvIGEgdW4gcGl4ZWwgY2hlIG5vbiBzb2RkaXNmYSBuZXNzdW5hIGRlbGxlIGNvbmRpemlvbmkgaW1wb3N0YXRlIG5lbGxhIDxzdHJvbmc+VGFiZWxsYSBhdHRyaWJ1dGkgem9uYWxpPC9zdHJvbmc+LlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfRGVmYXVsdC1PdXRwdXQtVmFsdWVfdGFnM0BAXCI6IFwiUXVlc3RvIHNhcsOgIGFuY2hlIGlsIHZhbG9yZSBkZWwgcGl4ZWwgZGkgb3V0cHV0IHNlIGlsIHBhcmFtZXRybyA8c3Ryb25nPk5vbWUgY2FtcG8gdmFsb3JlIGRpIG91dHB1dDwvc3Ryb25nPiBub24gdmllbmUgc3BlY2lmaWNhdG8gbyBzZSBpbCB2YWxvcmUgZGkgb3V0cHV0IGRlbGxhIHNvZ2xpYSB6b25hbGUgY29ycmlzcG9uZGVudGUgbm9uIHZpZW5lIHNwZWNpZmljYXRvIG5lbGxhIDxzdHJvbmc+VGFiZWxsYSBhdHRyaWJ1dGkgem9uYWxpPC9zdHJvbmc+LlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfTWF4aW11bS1WYWx1ZS1GaWVsZC1OYW1lX3RhZzBAQFwiOiBcIklsIG5vbWUgZGVsIGNhbXBvIGNvbnRlbmVudGUgaWwgdmFsb3JlIG1hc3NpbW8gYWwgZGkgc290dG8gZGVsIHF1YWxlIHVuIHBpeGVsIGRpIGlucHV0IHZpZW5lIHJpbWFwcGF0by5cIixcblx0XCJAQFpvbmFsLVJlbWFwX01heGltdW0tVmFsdWUtRmllbGQtTmFtZV90YWcxQEBcIjogXCJTZSBub24gw6ggc3BlY2lmaWNhdG8sIG8gc2UgaWwgdmFsb3JlIGRlbCBjYW1wbyDDqCBudWxsbywgaSB2YWxvcmkgcGl4ZWwgbm9uIHZlbmdvbm8gdGVzdGF0aSBwZXIgaWwgbWFzc2ltby5cIixcblx0XCJAQFpvbmFsLVJlbWFwX01pbmltdW0tVmFsdWUtRmllbGQtTmFtZV90YWcwQEBcIjogXCJJbCBub21lIGRlbCBjYW1wbyBjb250ZW5lbnRlIGlsIHZhbG9yZSBtaW5pbW8gYWwgZGkgc29wcmEgZGVsIHF1YWxlIHVuIHBpeGVsIGRpIGlucHV0IHZpZW5lIHJpbWFwcGF0by5cIixcblx0XCJAQFpvbmFsLVJlbWFwX01pbmltdW0tVmFsdWUtRmllbGQtTmFtZV90YWcxQEBcIjogXCJTZSBub24gw6ggc3BlY2lmaWNhdG8sIG8gc2UgaWwgdmFsb3JlIGRlbCBjYW1wbyDDqCBudWxsbywgaSB2YWxvcmkgcGl4ZWwgbm9uIHZlbmdvbm8gdGVzdGF0aSBwZXIgaWwgbWluaW1vLlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfT3V0cHV0LVZhbHVlLUZpZWxkLU5hbWVfdGFnMEBAXCI6IFwiSWwgbm9tZSBkZWwgY2FtcG8gY29udGVuZW50ZSBpbCB2YWxvcmUgdGFyZ2V0IGluIGJhc2UgYWwgcXVhbGUgdW4gcGl4ZWwgZGkgaW5wdXQgdmllbmUgcmltYXBwYXRvLlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfT3V0cHV0LVZhbHVlLUZpZWxkLU5hbWVfdGFnMUBAXCI6IFwiU2Ugbm9uIMOoIHNwZWNpZmljYXRvLCBvIHNlIGlsIHZhbG9yZSBkZWwgY2FtcG8gw6ggbnVsbG8sIGkgdmFsb3JpIGRpIHBpeGVsIHJpbWFwcGF0aSB2ZW5nb25vIGltcG9zdGF0aSBjb24gaWwgPHN0cm9uZz5WYWxvcmUgZGkgb3V0cHV0IHByZWRlZmluaXRvPC9zdHJvbmc+LlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfVmFsdWUtUmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBhIGJhbmRhIHNpbmdvbGEgb2JibGlnYXRvcmlvIGRpIGlucHV0IGNvbnRlbmVudGUgaSB2YWxvcmkgZGkgcGl4ZWwgZGEgcmltYXBwYXJlLlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfV2hlcmUtQ2xhdXNlX3RhZzBAQFwiOiBcIlVuJ2ludGVycm9nYXppb25lIG9wemlvbmFsZSBhcHBsaWNhdGEgbmVsbGEgPHN0cm9uZz5UYWJlbGxhIGF0dHJpYnV0aSB6b25hbGk8L3N0cm9uZz4uXCIsXG5cdFwiQEBab25hbC1SZW1hcF9XaGVyZS1DbGF1c2VfdGFnM0BAXCI6IFwiU2Ugc2kgw6ggdXNhdGEgbGEgdGFiZWxsYSBwcmVjZWRlbnRlIGNvbWUgZXNlbXBpbywgbCdpbnRlcnJvZ2F6aW9uZSBzYXJlYmJlICR7VmFyaWFibGUxID0gJ2JhcmUgZWFydGgnIEFORCBWYXJpYWJsZTIgPSAnQ2FsaWZvcm5pYSd9LlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfWm9uYWwtQXR0cmlidXRlcy1UYWJsZV90YWcwQEBcIjogXCJVbmEgdGFiZWxsYSBkaSBpbnB1dCBvYmJsaWdhdG9yaWEgY29udGVuZW50ZSBhbG1lbm8gdHJlIGNhbXBpLiBEZXZlIHByZXNlbnRhcmUgdW4gdmFsb3JlIGRpIHNvZ2xpYSBtaW5pbW8sIHVuIHZhbG9yZSBkaSBzb2dsaWEgbWFzc2ltbyBlIHVuIHZhbG9yZSB0YXJnZXQuIElsIHZhbG9yZSB0YXJnZXQgw6ggaWwgY2FtcG8gY2hlIGNvbnRpZW5lIGlsIHZhbG9yZSByaWNhbGNvbGF0by5cIixcblx0XCJAQFpvbmFsLVJlbWFwX1pvbmFsLUF0dHJpYnV0ZXMtVGFibGVfdGFnMUBAXCI6IFwiSWwgZm9ybWF0byBkZWwgZmlsZSBwdcOyIGVzc2VyZSB1bmEgZmVhdHVyZSBjbGFzcywgdW4gZmVhdHVyZSBzZXJ2aWNlIG8gcXVhbHVucXVlIHRpcG8gZGkgdGFiZWxsYSBzdXBwb3J0YXRvIGRhIEFyY0dJUy5cIixcblx0XCJAQFpvbmFsLVJlbWFwX1pvbmUtRmllbGRfdGFnMEBAXCI6IFwiSWwgbm9tZSBkZWwgY2FtcG8gYWxsJ2ludGVybm8gZGVsbGEgPHN0cm9uZz5UYWJlbGxhIGF0dHJpYnV0aSB6b25hbGk8L3N0cm9uZz4gY2hlIGNvbnRpZW5lIGkgdmFsb3JpIElEIGRpIHpvbmEuXCIsXG5cdFwiQEBab25hbC1SZW1hcF9ab25lLUZpZWxkX3RhZzNAQFwiOiBcIkkgdmFsb3JpIElEIGRpIHpvbmEgZGlyZXR0YW1lbnRlIGxlZ2F0aSBhZ2xpIElEIGRpIHpvbmEgbmVsIHJhc3RlciBkaSB6b25lLiBGb3JuaXNjb25vIHVuIGFsdHJvIGxpdmVsbG8gZGkgZmlsdHJhZ2dpbyBkdXJhbnRlIGlsIHJpY2FsY29sby4gU2Ugbm9uIGMnw6ggbmVzc3VuIElEIGRpIHpvbmEgYXNzb2NpYXRvIGFkIHVuIHJlY29yZCBzcGVjaWZpY28gbmVsbGEgdGFiZWxsYSwgcXVlc3RvIG5vbiBpbnRlcnZlcnLDoCBuZWwgcmljYWxjb2xvLlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfWm9uZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGEgYmFuZGEgc2luZ29sYSBpbiBjdWkgb2duaSBwaXhlbCBkZWZpbmlzY2Ugem9uZSBhc3NvY2lhdGUgYWQgdW5hIHBvc2l6aW9uZSBzcGVjaWZpY2EuIFVuYSB6b25hIHZpZW5lIGRlZmluaXRhIGNvbWUgdHV0dGUgbGUgYXJlZSBuZWxsJ2lucHV0IGNoZSBoYW5ubyBsbyBzdGVzc28gdmFsb3JlLiBMZSBhcmVlIG5vbiBkZXZvbm8gZXNzZXJlIGNvbnRpZ3VlLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzBAQFwiOiBcIlNwZWNpZmljYSBpbCBtZXRvZG8gdXRpbGl6emF0byBwZXIgZm9ybmlyZSB2YWxvcmkgZGkgZGltZW5zaW9uZSBzdWxsZSBwcmV2aXNpb25pLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+UGVyIHZhbG9yZTwvc3Ryb25nPjogbGEgcHJldmlzaW9uZSBzYXLDoCBjYWxjb2xhdGEgcGVyIHVuIHNpbmdvbG8gdmFsb3JlIGRpIGRpbWVuc2lvbmUuIEFkIGVzZW1waW8sIHNpIGRlc2lkZXJhIHByZXZlZGVyZSBsYSBwcmVjaXBpdGF6aW9uZSBhbm51YWxlIHBlciBnbGkgYW5uaSAyMDUwLCAyMTAwIGUgMjE1MC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzJAQFwiOiBcIjxzdHJvbmc+UGVyIGludGVydmFsbG88L3N0cm9uZz46IGxhIHByZXZpc2lvbmUgc2Fyw6AgY2FsY29sYXRhIHBlciB1biBpbnRlcnZhbGxvIGRlbGxhIGRpbWVuc2lvbmUgZGVmaW5pdGEgZGEgdW4gdmFsb3JlIGRpIGluaXppbyBlIHVubyBkaSBmaW5lLiBBZCBlc2VtcGlvLCBzaSBkZXNpZGVyYSBwcmV2ZWRlcmUgbGEgcHJlY2lwaXRhemlvbmUgYW5udWFsZSBwZXIgb2duaSBhbm5vIGNvbXByZXNvIHRyYSBpbCAyMDUwIGUgaWwgMjE1MC5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfZW5kX3RhZzBAQFwiOiBcIkxhIGRhdGEsIGwnYWx0ZXp6YSBvIGxhIHByb2ZvbmRpdMOgIGZpbmFsZSBkZWxsJ2ludGVydmFsbG8gZGVsbGEgZGltZW5zaW9uZSBkYSB1c2FyZSBuZWxsYSBwcmV2aXNpb25lLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF9lbmRfdGFnMUBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyDDqCByaWNoaWVzdG8gcXVhbmRvIGlsIHBhcmFtZXRybyA8c3Ryb25nPkRlZmluaXppb25lIGRpbWVuc2lvbmU8L3N0cm9uZz4gw6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+UGVyIGludGVydmFsbG88L3N0cm9uZz4uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgdGVuZGVuemEgbXVsdGlkaW1lbnNpb25hbGUgZGkgaW5wdXQgZGFsbGEgZnVuemlvbmUgPHN0cm9uZz5HZW5lcmEgdGVuZGVuemE8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3N0YXJ0X3RhZzBAQFwiOiBcIkxhIGRhdGEsIGwnYWx0ZXp6YSBvIGxhIHByb2ZvbmRpdMOgIGluaXppYWxlIGRlbGwnaW50ZXJ2YWxsbyBkZWxsYSBkaW1lbnNpb25lIGRhIHVzYXJlIG5lbGxhIHByZXZpc2lvbmUuXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3N0YXJ0X3RhZzFAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gw6ggcmljaGllc3RvIHF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5EZWZpbml6aW9uZSBkaW1lbnNpb25lPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPlBlciBpbnRlcnZhbGxvPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF91bml0X3RhZzBAQFwiOiBcIkwndW5pdMOgIGNoZSB2ZXJyw6AgdXRpbGl6emF0YSBwZXIgbCdpbnRlcnZhbGxvIGRlaSB2YWxvcmkuIFF1ZXN0byBwYXJhbWV0cm8gc2kgYXBwbGljYSBzb2xvIHF1YW5kbyBsYSBkaW1lbnNpb25lIGRlbGwnYW5hbGlzaSDDqCB1bmEgZGltZW5zaW9uZSB0ZW1wb3JhbGUuXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3VuaXRfdGFnMUBAXCI6IFwiPHN0cm9uZz5PcmU8L3N0cm9uZz46IGxhIHByZXZpc2lvbmUgc2Fyw6AgY2FsY29sYXRhIHBlciBjaWFzY3VuYSBvcmEgYWxsJ2ludGVybm8gZGVsbCdpbnRlcnZhbGxvIGRpIHRlbXBvIGRlc2NyaXR0byBkYWkgcGFyYW1ldHJpIDxzdHJvbmc+SW5pemlvPC9zdHJvbmc+LCA8c3Ryb25nPkZpbmU8L3N0cm9uZz4gZSA8c3Ryb25nPkludGVydmFsbG8gZGkgdmFsb3JpPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF91bml0X3RhZzJAQFwiOiBcIjxzdHJvbmc+R2lvcm5pPC9zdHJvbmc+OiBsYSBwcmV2aXNpb25lIHNhcsOgIGNhbGNvbGF0YSBwZXIgY2lhc2N1biBnaW9ybm8gYWxsJ2ludGVybm8gZGVsbCdpbnRlcnZhbGxvIGRpIHRlbXBvIGRlc2NyaXR0byBkYWkgcGFyYW1ldHJpIDxzdHJvbmc+SW5pemlvPC9zdHJvbmc+LCA8c3Ryb25nPkZpbmU8L3N0cm9uZz4gZSA8c3Ryb25nPkludGVydmFsbG8gZGkgdmFsb3JpPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF91bml0X3RhZzNAQFwiOiBcIjxzdHJvbmc+U2V0dGltYW5lPC9zdHJvbmc+OiBsYSBwcmV2aXNpb25lIHNhcsOgIGNhbGNvbGF0YSBwZXIgY2lhc2N1bmEgc2V0dGltYW5hIGFsbCdpbnRlcm5vIGRlbGwnaW50ZXJ2YWxsbyBkaSB0ZW1wbyBkZXNjcml0dG8gZGFpIHBhcmFtZXRyaSA8c3Ryb25nPkluaXppbzwvc3Ryb25nPiwgPHN0cm9uZz5GaW5lPC9zdHJvbmc+IGUgPHN0cm9uZz5JbnRlcnZhbGxvIGRpIHZhbG9yaTwvc3Ryb25nPi5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfdW5pdF90YWc0QEBcIjogXCI8c3Ryb25nPk1lc2k8L3N0cm9uZz46IGxhIHByZXZpc2lvbmUgc2Fyw6AgY2FsY29sYXRhIHBlciBjaWFzY3VuIG1lc2UgYWxsJ2ludGVybm8gZGVsbCdpbnRlcnZhbGxvIGRpIHRlbXBvIGRlc2NyaXR0byBkYWkgcGFyYW1ldHJpIDxzdHJvbmc+SW5pemlvPC9zdHJvbmc+LCA8c3Ryb25nPkZpbmU8L3N0cm9uZz4gZSA8c3Ryb25nPkludGVydmFsbG8gZGkgdmFsb3JpPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF91bml0X3RhZzVAQFwiOiBcIjxzdHJvbmc+QW5uaTwvc3Ryb25nPjogbGEgcHJldmlzaW9uZSBzYXLDoCBjYWxjb2xhdGEgcGVyIGNpYXNjdW4gYW5ubyBhbGwnaW50ZXJubyBkZWxsJ2ludGVydmFsbG8gZGkgdGVtcG8gZGVzY3JpdHRvIGRhaSBwYXJhbWV0cmkgPHN0cm9uZz5Jbml6aW88L3N0cm9uZz4sIDxzdHJvbmc+RmluZTwvc3Ryb25nPiBlIDxzdHJvbmc+SW50ZXJ2YWxsbyBkaSB2YWxvcmk8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3ZhbHVlaW50ZXJ2YWxfdGFnMEBAXCI6IFwiSWwgbnVtZXJvIGRpIHBhc3NhZ2dpIHRyYSBkdWUgdmFsb3JpIGRpIGRpbWVuc2lvbmUgZGEgaW5jbHVkZXJlIG5lbGxhIHByZXZpc2lvbmUuIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAxLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF92YWx1ZWludGVydmFsX3RhZzFAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gw6ggcmljaGllc3RvIHF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5EZWZpbml6aW9uZSBkaW1lbnNpb25lPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPlBlciBpbnRlcnZhbGxvPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF92YWx1ZXNfdGFnMEBAXCI6IFwiSWwgdmFsb3JlIG8gaSB2YWxvcmkgZGkgZGltZW5zaW9uZSBkYSB1dGlsaXp6YXJlIG5lbGxhIHByZXZpc2lvbmUuXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3ZhbHVlc190YWcxQEBcIjogXCJJbCBmb3JtYXRvIGRlaSB2YWxvcmkgZGkgdGVtcG8sIHByb2ZvbmRpdMOgIGUgYWx0ZXp6YSBkZXZlIGNvcnJpc3BvbmRlcmUgYWwgZm9ybWF0byBkZWkgdmFsb3JpIGRpIGRpbWVuc2lvbmUgdXRpbGl6emF0aSBwZXIgZ2VuZXJhcmUgaWwgcmFzdGVyIGRpIHRlbmRlbnphLiBTZSBpbCByYXN0ZXIgZGkgdGVuZGVuemEgw6ggc3RhdG8gZ2VuZXJhdG8gcGVyIGxhIGRpbWVuc2lvbmUgU3RkVGltZSwgaWwgZm9ybWF0byBkZXZlIGVzc2VyZSBBQUFBLU1NLUdHVEhIOk1NOlNTLCBlcy4gMjA1MC0wMS0wMVQwMDowMDowMC4gUGnDuSB2YWxvcmkgc29ubyBzZXBhcmF0aSBjb24gdW4gcHVudG8gZSB2aXJnb2xhLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9hZ2dyZWdhdGlvbmZ1bmN0aW9uX3RhZzBAQFwiOiBcIlNwZWNpZmljYXJlIGlsIG1vZGVsbG8gZGkgZnVuemlvbmUgcmFzdGVyIHV0aWxpenphdG8gcGVyIGFnZ3JlZ2FyZSBwacO5IHNlemlvbmkgaW4gdW4gbnVtZXJvIGluZmVyaW9yZSBkaSBzZXppb25pIG8gaW4gdW4ndW5pY2Egc2V6aW9uZS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fZGltZW5zaW9uX3RhZzBAQFwiOiBcIkRpbWVuc2lvbmUgZGkgYWdncmVnYXppb25lLiBRdWVzdGEgw6ggbGEgZGltZW5zaW9uZSBsdW5nbyBsYSBxdWFsZSB2ZXJyYW5ubyBhZ2dyZWdhdGUgbGUgdmFyaWFiaWxpLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9pdGVtZnVuY3Rpb25fdGFnMEBAXCI6IFwiU3BlY2lmaWNhcmUgaWwgbW9kZWxsbyBkaSBmdW56aW9uZSByYXN0ZXIgdXRpbGl6emF0byBwZXIgZWxhYm9yYXJlIGNpYXNjdW5hIHNlemlvbmUgbyBlbGVtZW50byBuZWxsYSByYWNjb2x0YSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWcwQEBcIjogXCJTcGVjaWZpY2EgbCdpbnRlcnZhbGxvIGRpIHBhcm9sZSBjaGlhdmUgY2hlIHZlcnLDoCB1dGlsaXp6YXRvIGR1cmFudGUgbCdhZ2dyZWdhemlvbmUgbHVuZ28gbGEgZGltZW5zaW9uZS4gUXVlc3RvIHBhcmFtZXRybyDDqCBvYmJsaWdhdG9yaW8gcXVhbmRvIDxzdHJvbmc+VGlwbzwvc3Ryb25nPiDDqCBpbXBvc3RhdG8gc3UgPHN0cm9uZz5QYXJvbGEgY2hpYXZlIGRpIGludGVydmFsbG88L3N0cm9uZz4gZSBsJ2FnZ3JlZ2F6aW9uZSBkZXZlIGVzc2VyZSBuZWwgdGVtcG8uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWcxQEBcIjogXCI8c3Ryb25nPk9nbmkgb3JhPC9zdHJvbmc+OiBpIHZhbG9yaSBkZWkgZGF0aSB2ZXJyYW5ubyBhZ2dyZWdhdGkgaW4gaW50ZXJ2YWxsaSB0ZW1wb3JhbGkgb3JhcmkgZSBpbCByaXN1bHRhdG8gaW5jbHVkZXLDoCBvZ25pIG9yYSBuZWxsZSBzZXJpZSB0ZW1wb3JhbGkuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWcyQEBcIjogXCI8c3Ryb25nPk9nbmkgZ2lvcm5vPC9zdHJvbmc+OiBpIHZhbG9yaSBkZWkgZGF0aSB2ZXJyYW5ubyBhZ2dyZWdhdGkgaW4gaW50ZXJ2YWxsaSB0ZW1wb3JhbGkgZ2lvcm5hbGllcmkgZSBpbCByaXN1bHRhdG8gaW5jbHVkZXLDoCBvZ25pIGdpb3JubyBuZWxsZSBzZXJpZSB0ZW1wb3JhbGkuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWczQEBcIjogXCI8c3Ryb25nPk9nbmkgc2V0dGltYW5hPC9zdHJvbmc+OiBpIHZhbG9yaSBkZWkgZGF0aSB2ZXJyYW5ubyBhZ2dyZWdhdGkgaW4gaW50ZXJ2YWxsaSB0ZW1wb3JhbGkgc2V0dGltYW5hbGkgZSBpbCByaXN1bHRhdG8gaW5jbHVkZXLDoCBvZ25pIHNldHRpbWFuYSBuZWxsZSBzZXJpZSB0ZW1wb3JhbGkuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWc0QEBcIjogXCI8c3Ryb25nPk9nbmkgZGllY2kgZ2lvcm5pPC9zdHJvbmc+OiBpIHZhbG9yaSBkZWkgZGF0aSB2ZXJyYW5ubyBhZ2dyZWdhdGkgaW4gMyBwZXJpb2RpIGRpIDEwIGdpb3JuaSBjaWFzY3Vuby4gTCd1bHRpbW8gcGVyaW9kbyBwb3RyZWJiZSBjb250ZW5lcmUgcGnDuSBvIG1lbm8gZGkgMTAgZ2lvcm5pLiBMJ291dHB1dCBpbmNsdWRlcsOgIDMgcGVyaW9kaSBwZXIgb2duaSBtZXNlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnNUBAXCI6IFwiPHN0cm9uZz5PZ25pIGNpbnF1ZSBnaW9ybmk8L3N0cm9uZz46IGkgdmFsb3JpIGRlaSBkYXRpIHZlcnJhbm5vIGFnZ3JlZ2F0aSBpbiA2IHBlcmlvZGkgZGkgNSBnaW9ybmkgY2lhc2N1bm8uIEwndWx0aW1vIHBlcmlvZG8gcG90cmViYmUgY29udGVuZXJlIHBpw7kgbyBtZW5vIGRpIDUgZ2lvcm5pLiBMJ291dHB1dCBpbmNsdWRlcsOgIDYgcGVyaW9kaSBwZXIgb2duaSBtZXNlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnNkBAXCI6IFwiPHN0cm9uZz5PZ25pIG1lc2U8L3N0cm9uZz46IGkgdmFsb3JpIGRlaSBkYXRpIHZlcnJhbm5vIGFnZ3JlZ2F0aSBpbiBpbnRlcnZhbGxpIHRlbXBvcmFsaSBtZW5zaWxpIGUgaWwgcmlzdWx0YXRvIGluY2x1ZGVyw6Agb2duaSBtZXNlIG5lbGxlIHNlcmllIHRlbXBvcmFsaS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fa2V5d29yZGludGVydmFsX3RhZzdAQFwiOiBcIjxzdHJvbmc+T2duaSB0cmltZXN0cmU8L3N0cm9uZz46IGkgdmFsb3JpIGRlaSBkYXRpIHZlcnJhbm5vIGFnZ3JlZ2F0aSBpbiBpbnRlcnZhbGxpIHRlbXBvcmFsaSB0cmltZXN0cmFsaSBlIGlsIHJpc3VsdGF0byBpbmNsdWRlcsOgIG9nbmkgdHJpbWVzdHJlIG5lbGxlIHNlcmllIHRlbXBvcmFsaS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fa2V5d29yZGludGVydmFsX3RhZzhAQFwiOiBcIjxzdHJvbmc+T2duaSBhbm5vPC9zdHJvbmc+OiBpIHZhbG9yaSBkZWkgZGF0aSB2ZXJyYW5ubyBhZ2dyZWdhdGkgaW4gaW50ZXJ2YWxsaSB0ZW1wb3JhbGkgYW5udWFsaSBlIGlsIHJpc3VsdGF0byBpbmNsdWRlcsOgIG9nbmkgYW5ubyBuZWxsZSBzZXJpZSB0ZW1wb3JhbGkuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWc5QEBcIjogXCI8c3Ryb25nPlJpY29ycmVuemEgZ2lvcm5hbGllcmE8L3N0cm9uZz46IGkgdmFsb3JpIGRlaSBkYXRpIHZlcnJhbm5vIGFnZ3JlZ2F0aSBpbiBpbnRlcnZhbGxpIHRlbXBvcmFsaSBnaW9ybmFsaWVyaSBlIGlsIHJpc3VsdGF0byBpbmNsdWRlcsOgIHVuIHZhbG9yZSBhZ2dyZWdhdG8gcGVyIGdpb3JubyBnaXVsaWFuby4gTCdvdXRwdXQgaW5jbHVkZXLDoCBhbCBtYXNzaW1vIDM2NiBwZXJpb2RpIGRpIHRlbXBvIGdpb3JuYWxpZXJpLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnMTBAQFwiOiBcIjxzdHJvbmc+Umljb3JyZW56YSBzZXR0aW1hbmFsZTwvc3Ryb25nPjogaSB2YWxvcmkgZGVpIGRhdGkgdmVycmFubm8gYWdncmVnYXRpIGluIGludGVydmFsbGkgdGVtcG9yYWxpIHNldHRpbWFuYWxpIGUgaWwgcmlzdWx0YXRvIGluY2x1ZGVyw6AgdW4gdmFsb3JlIGFnZ3JlZ2F0byBwZXIgc2V0dGltYW5hLiBMJ291dHB1dCBpbmNsdWRlcsOgIGFsIG1hc3NpbW8gNTMgcGVyaW9kaSBkaSB0ZW1wbyBzZXR0aW1hbmFsaS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fa2V5d29yZGludGVydmFsX3RhZzExQEBcIjogXCI8c3Ryb25nPlJpY29ycmVuemEgbWVuc2lsZTwvc3Ryb25nPjogaSB2YWxvcmkgZGVpIGRhdGkgdmVycmFubm8gYWdncmVnYXRpIGluIGludGVydmFsbGkgdGVtcG9yYWxpIG1lbnNpbGkgZSBpbCByaXN1bHRhdG8gaW5jbHVkZXLDoCB1biB2YWxvcmUgYWdncmVnYXRvIHBlciBtZXNlLiBMJ291dHB1dCBpbmNsdWRlcsOgIGFsIG1hc3NpbW8gMTIgcGVyaW9kaSBkaSB0ZW1wbyBtZW5zaWxpLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnMTJAQFwiOiBcIjxzdHJvbmc+Umljb3JyZW56YSB0cmltZXN0cmFsZTwvc3Ryb25nPjogaSB2YWxvcmkgZGVpIGRhdGkgdmVycmFubm8gYWdncmVnYXRpIGluIGludGVydmFsbGkgdGVtcG9yYWxpIHRyaW1lc3RyYWxpIGUgaWwgcmlzdWx0YXRvIGluY2x1ZGVyw6AgdW4gdmFsb3JlIGFnZ3JlZ2F0byBwZXIgdHJpbWVzdHJlLiBMJ291dHB1dCBpbmNsdWRlcsOgIGFsIG1hc3NpbW8gNCBwZXJpb2RpIGRpIHRlbXBvIHRyaW1lc3RyYWxpLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9tYXhpbXVtdmFsdWVfdGFnMEBAXCI6IFwiSWwgdmFsb3JlIG1hc3NpbW8gcGVyIHVuIGludGVydmFsbG8uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX21heGltdW12YWx1ZV90YWcxQEBcIjogXCJRdWVzdG8gcGFyYW1ldHJvIMOoIHJpY2hpZXN0byBxdWFuZG8gaWwgcGFyYW1ldHJvIDxzdHJvbmc+VGlwbzwvc3Ryb25nPiDDqCBpbXBvc3RhdG8gc3UgPHN0cm9uZz5HYW1tZSBkaSBpbnRlcnZhbGxpPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9taW5pbXVtdmFsdWVfdGFnMEBAXCI6IFwiSWwgdmFsb3JlIG1pbmltbyBwZXIgdW4gaW50ZXJ2YWxsby5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fbWluaW11bXZhbHVlX3RhZzFAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gw6ggcmljaGllc3RvIHF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5UaXBvPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPkdhbW1lIGRpIGludGVydmFsbGk8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3Byb2Nlc3NpbmdmdW5jdGlvbl90YWcwQEBcIjogXCJTcGVjaWZpY2FyZSBpbCBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciB1dGlsaXp6YXRvIHBlciB2aXN1YWxpenphcmUgaWwgbGF5ZXIgcmFzdGVyIGVsYWJvcmF0by5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fcmFzdGVyY29sbGVjdGlvbl90YWcwQEBcIjogXCJJbCByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUgZGkgaW5wdXQsIGlsIGxheWVyIG1vc2FpY28gbyBpbCBkYXRhc2V0IG1vc2FpY28uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3R5cGVfdGFnMEBAXCI6IFwiU3BlY2lmaWNhIGwnaW50ZXJ2YWxsbyBkaSBkaW1lbnNpb25lIHBlciBpbCBxdWFsZSB2ZXJyYW5ubyBhZ2dyZWdhdGkgaSBkYXRpLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl90eXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+VHV0dGk8L3N0cm9uZz46IGkgdmFsb3JpIGRlaSBkYXRpIHZlcnJhbm5vIGFnZ3JlZ2F0aSBzdSB0dXR0ZSBsZSBzZXppb25pLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3R5cGVfdGFnMkBAXCI6IFwiPHN0cm9uZz5QYXJvbGEgY2hpYXZlIGRpIGludGVydmFsbG88L3N0cm9uZz46IGkgZGF0aSB2YXJpYWJpbGkgdmVycmFubm8gYWdncmVnYXRpIHV0aWxpenphbmRvIHVuIGludGVydmFsbG8gY29tdW5lbWVudGUgbm90by5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fdHlwZV90YWczQEBcIjogXCI8c3Ryb25nPkdhbW1lIGRpIGludGVydmFsbGk8L3N0cm9uZz46IGkgZGF0aSB2YXJpYWJpbGkgdmVycmFubm8gYWdncmVnYXRpIHRyYSBjb3BwaWUgc3BlY2lmaWNhdGUgZGkgdmFsb3JpIG8gZGF0ZS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fdHlwZV90YWc0QEBcIjogXCI8c3Ryb25nPlZhbG9yaSBkaSBpbnRlcnZhbGxpPC9zdHJvbmc+OiBpIGRhdGkgdmFyaWFiaWxpIHZlcnJhbm5vIGFnZ3JlZ2F0aSB1dGlsaXp6YW5kbyB1biBpbnRlcnZhbGxvIGUgdW4ndW5pdMOgIHNwZWNpZmljYXRpIGRhbGwndXRlbnRlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzBAQFwiOiBcIkwndW5pdMOgIGNoZSB2ZXJyw6AgdXRpbGl6emF0YSBwZXIgaWwgdmFsb3JlIGRlbGwnaW50ZXJ2YWxsby4gUXVlc3RvIHBhcmFtZXRybyDDqCBvYmJsaWdhdG9yaW8gcXVhbmRvIGxhIDxzdHJvbmc+RGltZW5zaW9uZTwvc3Ryb25nPiDDqCB1biBjYW1wbyB0ZW1wb3JhbGUgZSBxdWFuZG8gaWwgcGFyYW1ldHJvIDxzdHJvbmc+VGlwbzwvc3Ryb25nPiDDqCBpbXBvc3RhdG8gc3UgPHN0cm9uZz5WYWxvcmUgZGkgaW50ZXJ2YWxsaTwvc3Ryb25nPi5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fdW5pdF90YWcxQEBcIjogXCJTZSBzaSBhZ2dyZWdhIHF1YWxjb3NhIGRpIGRpdmVyc28gZGFsIHRlbXBvLCBxdWVzdGEgb3B6aW9uZSBub24gc2Fyw6AgZGlzcG9uaWJpbGUgZSBsJ3VuaXTDoCBwZXIgaWwgdmFsb3JlIGRpIGludGVydmFsbG8gY29ycmlzcG9uZGVyw6AgYWxsJ3VuaXTDoCB2YXJpYWJpbGUgZGVpIGRhdGkgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxpIGRpIGlucHV0LlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzJAQFwiOiBcIjxzdHJvbmc+T3JlPC9zdHJvbmc+OiBpIHZhbG9yaSBkZWkgZGF0aSB2ZXJyYW5ubyBhZ2dyZWdhdGkgaW4gcGVyaW9kaSBkaSB0ZW1wbyBvcmFyaSBhbGwnaW50ZXJ2YWxsbyBmb3JuaXRvLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzNAQFwiOiBcIjxzdHJvbmc+R2lvcm5pPC9zdHJvbmc+OiBpIHZhbG9yaSBkZWkgZGF0aSB2ZXJyYW5ubyBhZ2dyZWdhdGkgaW4gcGVyaW9kaSBkaSB0ZW1wbyBnaW9ybmFsaWVyaSBhbGwnaW50ZXJ2YWxsbyBmb3JuaXRvLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzRAQFwiOiBcIjxzdHJvbmc+U2V0dGltYW5lPC9zdHJvbmc+OiBpIHZhbG9yaSBkZWkgZGF0aSB2ZXJyYW5ubyBhZ2dyZWdhdGkgaW4gcGVyaW9kaSBkaSB0ZW1wbyBzZXR0aW1hbmFsaSBhbGwnaW50ZXJ2YWxsbyBmb3JuaXRvLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzVAQFwiOiBcIjxzdHJvbmc+TWVzaTwvc3Ryb25nPjogaSB2YWxvcmkgZGVpIGRhdGkgdmVycmFubm8gYWdncmVnYXRpIGluIHBlcmlvZGkgZGkgdGVtcG8gbWVuc2lsaSBhbGwnaW50ZXJ2YWxsbyBmb3JuaXRvLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzZAQFwiOiBcIjxzdHJvbmc+QW5uaTwvc3Ryb25nPjogaSB2YWxvcmkgZGVpIGRhdGkgdmVycmFubm8gYWdncmVnYXRpIGluIHBlcmlvZGkgZGkgdGVtcG8gYW5udWFsaSBhbGwnaW50ZXJ2YWxsbyBmb3JuaXRvLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl92YWx1ZWludGVydmFsX3RhZzBAQFwiOiBcIkRpbWVuc2lvbmUgZGVsbCdpbnRlcnZhbGxvIGNoZSB2ZXJyw6AgdXRpbGl6emF0byBwZXIgbCdhZ2dyZWdhemlvbmUuIFF1ZXN0byBwYXJhbWV0cm8gw6ggcmljaGllc3RvIHF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5UaXBvPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPlZhbG9yaSBkaSBpbnRlcnZhbGxpPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl92YWx1ZWludGVydmFsX3RhZzFAQFwiOiBcIkFkIGVzZW1waW8sIHBlciBhZ2dyZWdhcmUgMzAgYW5uaSBkaSBkYXRpIG1lbnNpbGkgc3VsbGEgdGVtcGVyYXR1cmEgaW4gaW5jcmVtZW50aSBkaSA1IGFubmksIGltbWV0dGVyZSA1IGNvbWUgPHN0cm9uZz5JbnRlcnZhbGxvIGRpIHZhbG9yaTwvc3Ryb25nPiBlIHNwZWNpZmljYXJlIDxzdHJvbmc+VW5pdMOgPC9zdHJvbmc+IGNvbWUgPHN0cm9uZz5Bbm5pPC9zdHJvbmc+LlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX25vbi1uZWdhdGl2ZV90YWcwQEBcIjogXCJTcGVjaWZpY2EgbGUgb3B6aW9uaSBwZXIgZGVmaW5pcmUgaSB2YWxvcmkgcGl4ZWwgZGkgb3V0cHV0LlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX25vbi1uZWdhdGl2ZV90YWcxQEBcIjogXCJTZWxlemlvbmF0bzogbm9uIGNpIHNhcmFubm8gdmFsb3JpIGRpIG91dHB1dCBuZWdhdGl2aS5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19ub24tbmVnYXRpdmVfdGFnMkBAXCI6IFwiTm9uIHNlbGV6aW9uYXRvOiBwb3Nzb25vIGVzc2VyY2kgdmFsb3JpIG5lZ2F0aXZpIGRlbGxhIGNvcGVydHVyYSBkZWwgdGVycmVubyBmcmF6aW9uYWxlLlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFwiQEBMaW5lYXItU3BlY3RyYWwtVW5taXhpbmdfc3BlY3RyYWxwcm9maWxlX3RhZzBAQFwiOiBcIklsIGZpbGUgZGVsIHByb2ZpbG8gc3BldHRyYWxlIGRpIGlucHV0LlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3NwZWN0cmFscHJvZmlsZXR5cGVfdGFnMEBAXCI6IFwiTGUgaW5mb3JtYXppb25pIHNwZXR0cmFsaSBwZXIgbGUgZGl2ZXJzZSBjbGFzc2kgZGkgY29wZXJ0dXJhIGRlbCB0ZXJyZW5vLlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3NwZWN0cmFscHJvZmlsZXR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5Qcm9maWxvIHNwZXR0cmFsZTwvc3Ryb25nPjogdW4gZmlsZSBkaSBkZWZpbml6aW9uZSBjbGFzc2lmaWNhdG9yZSAoJHsuZWNkfSksIGdlbmVyYXRvIGRhbGxvIHN0cnVtZW50byA8c3Ryb25nPjxzdHJvbmc+QWRkZXN0cmFtZW50byBDbGFzc2lmaWNhemlvbmUgZGkgUHJvYmFiaWxpdMOgIE1hc3NpbWE8L3N0cm9uZz48L3N0cm9uZz4gbyB1biBmaWxlIGRpIG5vdGF6aW9uZSBvZ2dldHRvIEphdmFTY3JpcHQgKCR7Lmpzb259KSBjaGUgY29udGllbmUgaSBwcm9maWxpIHNwZXR0cmFsaSBkaSBjbGFzc2UuXCIsXG5cdFwiQEBMaW5lYXItU3BlY3RyYWwtVW5taXhpbmdfc3BlY3RyYWxwcm9maWxldHlwZV90YWcyQEBcIjogXCI8c3Ryb25nPkZlYXR1cmUgZGkgZm9ybWF6aW9uZTwvc3Ryb25nPjogZmVhdHVyZSBwb2xpZ29uYWxpIG8gdW5hIGZlYXR1cmUgY2xhc3MgZXNlbXBpbyBkaSBmb3JtYXppb25lLCBnZW5lcmF0YSBkYSA8c3Ryb25nPkdlc3Rpb25lIEVzZW1waSBkaSBmb3JtYXppb25lPC9zdHJvbmc+LlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3N1bXRvb25lX3RhZzBAQFwiOiBcIlNwZWNpZmljYSBsZSBvcHppb25pIHBlciBkZWZpbmlyZSBpIHZhbG9yaSBwaXhlbCBkaSBvdXRwdXQuXCIsXG5cdFwiQEBMaW5lYXItU3BlY3RyYWwtVW5taXhpbmdfc3VtdG9vbmVfdGFnMUBAXCI6IFwiU2VsZXppb25hdG86IGkgdmFsb3JpIGRlbGxlIGNsYXNzaSBwZXIgY2lhc2N1biBwaXhlbCB2ZW5nb25vIGZvcm5pdGkgaW4gZm9ybWF0byBkZWNpbWFsZSBjb24gbGEgc29tbWEgZGkgdHV0dGUgbGUgY2xhc3NpIHVndWFsZSBhIDEuIEFkIGVzZW1waW8sIENsYXNzMSA9IDAsMTY7IENsYXNzMiA9IDAsMjQ7IENsYXNzMyA9IDAsNjAuXCIsXG5cdFwiQEBMaW5lYXItU3BlY3RyYWwtVW5taXhpbmdfc3VtdG9vbmVfdGFnMkBAXCI6IFwiTm9uIHNlbGV6aW9uYXRvOiBsYSBzb21tYSBkaSB0dXR0ZSBsZSBjbGFzc2kgaW4gdW4gcGl4ZWwgcHXDsiBzdXBlcmFyZSAxLlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3RyYWluaW5nZmVhdHVyZV90YWcwQEBcIjogXCJJbCBmaWxlIGRlbGxhIGZlYXR1cmUgZGkgZm9ybWF6aW9uZSBkaSBpbnB1dC5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9hZ2dyZWdhdGlvbnRlY2huaXF1ZV90YWcwQEBcIjogXCJJbCBtZXRvZG8gdXRpbGl6emF0byBwZXIgbCdhZ2dyZWdhemlvbmUuIEkgdmFsb3JpIGRlbGxlIGNlbGxlIGRpIGlucHV0IHJhY2NoaXVzZSBkYWxsZSBjZWxsZSBkaSBvdXRwdXQgcGnDuSBhcHByb3NzaW1hdGl2ZSB2ZW5nb25vIGFnZ3JlZ2F0aSBkYSB1bmEgZGVsbGUgc2VndWVudGkgc3RhdGlzdGljaGU6XCIsXG5cdFwiQEBBZ2dyZWdhdGVfYWdncmVnYXRpb250ZWNobmlxdWVfdGFnMUBAXCI6IFwiPHN0cm9uZz5Tb21tYTwvc3Ryb25nPjogaWwgdG90YWxlIGRlbGxlIGNlbGxlIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfYWdncmVnYXRpb250ZWNobmlxdWVfdGFnMkBAXCI6IFwiPHN0cm9uZz5NYXNzaW1vPC9zdHJvbmc+OiBpbCB2YWxvcmUgcGnDuSBncmFuZGUgZGVsbGUgY2VsbGUgZGkgaW5wdXQuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfYWdncmVnYXRpb250ZWNobmlxdWVfdGFnM0BAXCI6IFwiPHN0cm9uZz5NZWRpYTwvc3Ryb25nPjogaWwgdmFsb3JlIG1lZGlvIGRlbGxlIGNlbGxlIGRpIGlucHV0LlwiLFxuXHRcIkBAQWdncmVnYXRlX2FnZ3JlZ2F0aW9udGVjaG5pcXVlX3RhZzRAQFwiOiBcIjxzdHJvbmc+TWVkaWFuYTwvc3Ryb25nPjogaWwgdmFsb3JlIG1lZGlhbm8gZGVsbGUgY2VsbGUgZGkgaW5wdXQuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfYWdncmVnYXRpb250ZWNobmlxdWVfdGFnNUBAXCI6IFwiPHN0cm9uZz5NaW5pbW88L3N0cm9uZz46IGlsIHZhbG9yZSBwacO5IHBpY2NvbG8gZGVsbGUgY2VsbGUgZGkgaW5wdXQuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfY2VsbGZhY3Rvcl90YWcwQEBcIjogXCJJbCBmYXR0b3JlIHBlciBpbCBxdWFsZSBtb2x0aXBsaWNhcmUgbGEgZGltZW5zaW9uZSBjZWxsYSBkZWwgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQWdncmVnYXRlX2NlbGxmYWN0b3JfdGFnMUBAXCI6IFwiQWQgZXNlbXBpbywgdW4gdmFsb3JlIGZhdHRvcmUgY2VsbGEgZGkgdHJlIHJpc3VsdGVyZWJiZSBpbiB1bmEgZGltZW5zaW9uZSBjZWxsYSBkaSBvdXRwdXQgZGkgdHJlIHZvbHRlIHN1cGVyaW9yZSByaXNwZXR0byBhIHF1ZWxsYSBkZWwgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQWdncmVnYXRlX2V4cGFuZGV4dGVudGlmbmVlZGVkX3RhZzBAQFwiOiBcIkRlZmluaXNjZSBjb21lIGdlc3RpcmUgaSBjb25maW5pIGRlbCByYXN0ZXIgZGkgaW5wdXQgcXVhbmRvIGxlIHN1ZSByaWdoZSBvIGxlIHN1ZSBjb2xvbm5lIG5vbiBzb25vIHVuIG11bHRpcGxvIGRlbCBmYXR0b3JlIGRpIGNlbGxhLlwiLFxuXHRcIkBAQWdncmVnYXRlX2V4cGFuZGV4dGVudGlmbmVlZGVkX3RhZzFAQFwiOiBcIlNlbGV6aW9uYXRvOiBlc3BhbmRlIGkgY29uZmluaSBzdXBlcmlvcmkgbyBhIGRlc3RyYSBkZWwgcmFzdGVyIGRpIGlucHV0IGluIG1vZG8gY2hlIGlsIG51bWVybyB0b3RhbGUgZGkgY2VsbGUgaW4gdW5hIHJpZ2EgbyBjb2xvbm5hIHNpYSB1biBtdWx0aXBsbyBkZWwgZmF0dG9yZSBkaSBjZWxsYS4gQ29uIHF1ZXN0YSBvcHppb25lLCBpbCByYXN0ZXIgZGkgb3V0cHV0IHB1w7IgY29wcmlyZSB1bidlc3RlbnNpb25lIHNwYXppYWxlIHBpw7kgZ3JhbmRlIGRlbCByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9leHBhbmRleHRlbnRpZm5lZWRlZF90YWcyQEBcIjogXCJOb24gc2VsZXppb25hdG86IHJpZHVjZSBpbCBudW1lcm8gZGkgcmlnaGUgbyBjb2xvbm5lIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBRdWVzdG8gdHJvbmNhIGxlIGNlbGxlIHJpbWFuZW50aSBzdWkgY29uZmluaSBzdXBlcmlvcmkgbyBhIGRlc3RyYSBkZWwgcmFzdGVyIGRpIGlucHV0LCByZW5kZW5kbyBpbCBudW1lcm8gZGkgcmlnaGUgbyBjb2xvbm5lIG5lbCByYXN0ZXIgZGkgaW5wdXQgdW4gbXVsdGlwbG8gZGVsIGZhdHRvcmUgZGkgY2VsbGEuIENvbiBxdWVzdGEgb3B6aW9uZSwgaWwgcmFzdGVyIGRpIG91dHB1dCBwdcOyIGNvcHJpcmUgdW4nZXN0ZW5zaW9uZSBzcGF6aWFsZSBwacO5IHBpY2NvbGEgZGVsIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9pZ25vcmVub2RhdGFpbmNhbGN1bGF0aW9uc190YWcwQEBcIjogXCJJZGVudGlmaWNhIHNlIGkgdmFsb3JpICR7Tm9EYXRhfSB2ZW5nb25vIGlnbm9yYXRpIGRhaSBjYWxjb2xpIGRpIGFnZ3JlZ2F6aW9uZS5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9pZ25vcmVub2RhdGFpbmNhbGN1bGF0aW9uc190YWcxQEBcIjogXCJTZWxlemlvbmF0bzogaW5kaWNhIGNoZSBzZSBlc2lzdG9ubyB2YWxvcmkgJHtOb0RhdGF9IHBlciB1bmEgcXVhbHVucXVlIGRlbGxlIGNlbGxlIGNoZSByaWNhZG9ubyBhbGwnaW50ZXJubyBkZWxsJ2VzdGVuc2lvbmUgc3BhemlhbGUgZGkgdW5hIGNlbGxhIHBpw7kgZ3JhbmRlIHN1bCByYXN0ZXIgZGkgb3V0cHV0LCBpIHZhbG9yaSAke05vRGF0YX0gc2FyYW5ubyBpZ25vcmF0aSBxdWFuZG8gc2kgc3RhYmlsaXNjZSBpbCB2YWxvcmUgcGVyIGxlIHBvc2l6aW9uaSBkZWxsZSBjZWxsZSBkaSBvdXRwdXQuIFNvbG8gbGUgY2VsbGUgZGkgaW5wdXQgYWxsJ2ludGVybm8gZGVsbCdlc3RlbnNpb25lIGRlbGxhIGNlbGxhIGRpIG91dHB1dCBjaGUgaGFubm8gdmFsb3JpIGRpIGRhdGkgdmVycmFubm8gdXRpbGl6emF0aSBwZXIgZGV0ZXJtaW5hcmUgaWwgdmFsb3JlIGRlbGxhIGNlbGxhIGRpIG91dHB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQWdncmVnYXRlX2lnbm9yZW5vZGF0YWluY2FsY3VsYXRpb25zX3RhZzJAQFwiOiBcIk5vbiBzZWxlemlvbmF0bzogaW5kaWNhIGNoZSBzZSB1bmEgY2VsbGEgY2hlIHJpY2FkZSBhbGwnaW50ZXJubyBkZWxsJ2VzdGVuc2lvbmUgc3BhemlhbGUgZGkgdW5hIGNlbGxhIHBpw7kgZ3JhbmRlIHN1bCByYXN0ZXIgZGkgb3V0cHV0IHByZXNlbnRhIHVuIHZhbG9yZSAke05vRGF0YX0sIGlsIHZhbG9yZSBwZXIgbGEgcG9zaXppb25lIGRpIHF1ZWxsYSBjZWxsYSBkaSBvdXRwdXQgc2Fyw6AgJHtOb0RhdGF9LiBMJ3V0aWxpenpvIGRpIHF1ZXN0YSBvcHppb25lIGltcGxpY2EgY2hlIHF1YW5kbyBsZSBjZWxsZSBhbGwnaW50ZXJubyBkZWxsJ2FnZ3JlZ2F6aW9uZSBjb250ZW5nb25vIGlsIHZhbG9yZSAke05vRGF0YX0sIG5vbiBjaSBzb25vIGluZm9ybWF6aW9uaSBzdWZmaWNpZW50aSBwZXIgZXNlZ3VpcmUgaSBjYWxjb2xpIHNwZWNpZmljYXRpIG5lY2Vzc2FyaSBwZXIgZGV0ZXJtaW5hcmUgaWwgdmFsb3JlIGRpIG91dHB1dC5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9yYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IGRhIGFnZ3JlZ2FyZS5cIixcblx0XCJAQEV4cGFuZF9udW1iZXJvZmNlbGxzX3RhZzBAQFwiOiBcIklsIG51bWVybyBkaSBjZWxsZSBwZXIgbCdlc3BhbnNpb25lLlwiLFxuXHRcIkBARXhwYW5kX251bWJlcm9mY2VsbHNfdGFnMUBAXCI6IFwiSWwgdmFsb3JlIGRldmUgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8gZSBwdcOyIGVzc2VyZSBtYWdnaW9yZSBvIHVndWFsZSBhIDEuXCIsXG5cdFwiQEBFeHBhbmRfcmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSBpbnB1dCBwZXIgaWwgcXVhbGUgZXNwYW5kZXJlIGxlIHpvbmUgaWRlbnRpZmljYXRlLlwiLFxuXHRcIkBARXhwYW5kX3Jhc3Rlcl90YWcxQEBcIjogXCJEZXZlIGVzc2VyZSBkaSB0aXBvIG51bWVybyBpbnRlcm8uXCIsXG5cdFwiQEBFeHBhbmRfem9uZXZhbHVlc190YWcwQEBcIjogXCJMJ2VsZW5jbyBkaSB6b25lIGRhIGVzcGFuZGVyZS5cIixcblx0XCJAQEV4cGFuZF96b25ldmFsdWVzX3RhZzFAQFwiOiBcIkkgdmFsb3JpIHpvbmEgZGV2b25vIGVzc2VyZSB1biBudW1lcm8gaW50ZXJvIGUgc2kgcG9zc29ubyB0cm92YXJlIGluIHF1YWx1bnF1ZSBvcmRpbmUuXCIsXG5cdFwiQEBFeHBhbmRfem9uZXZhbHVlc190YWcyQEBcIjogXCJQZXIgc3BlY2lmaWNhcmUgcGnDuSB6b25lLCB1dGlsaXp6YXJlIHVubyBzcGF6aW8gcGVyIHNlcGFyYXJlIGkgdmFsb3JpIGRpIHpvbmEuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9kaW1lbnNpb25fdGFnMEBAXCI6IFwiTGEgZGltZW5zaW9uZSBkYSBjdWkgZXN0cmFycmUgbGUgdmFyaWFiaWxpLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9uZGVmaW5pdGlvbl90YWcwQEBcIjogXCJTcGVjaWZpY2EgaWwgbWV0b2RvIGNoZSB2ZXJyw6AgdXRpbGl6emF0byBwZXIgc2V6aW9uYXJlIGxhIGRpbWVuc2lvbmUuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+VHV0dGk8L3N0cm9uZz46IHNpIHV0aWxpenplcsOgIGwnaW50ZXJ2YWxsbyBjb21wbGV0byBwZXIgY2lhc2N1bmEgZGltZW5zaW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9uZGVmaW5pdGlvbl90YWcyQEBcIjogXCI8c3Ryb25nPlBlciB2YWxvcmk8L3N0cm9uZz46IHNpIHNlemlvbmVyw6AgbGEgZGltZW5zaW9uZSB1dGlsaXp6YW5kbyB1biB2YWxvcmUgZGVsbGEgZGltZW5zaW9uZSBvIHVuIGVsZW5jbyBkaSB2YWxvcmkuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzNAQFwiOiBcIjxzdHJvbmc+UGVyIGludGVydmFsbGk8L3N0cm9uZz46IHNpIHNlemlvbmVyw6AgbGEgZGltZW5zaW9uZSB1dGlsaXp6YW5kbyB1biBpbnRlcnZhbGxvIG8gdW4gZWxlbmNvIGRpIGludGVydmFsbGkuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzRAQFwiOiBcIjxzdHJvbmc+UGVyIGl0ZXJhemlvbmU8L3N0cm9uZz46IHNpIHNlemlvbmVyw6AgbGEgZGltZW5zaW9uZSBzdWxsYSBkaW1lbnNpb25lIGRpIHVuIGludGVydmFsbG8gc3BlY2lmaWNhdG8uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9lbmRvZmZpcnN0aXRlcmF0aW9uX3RhZzBAQFwiOiBcIkxhIGZpbmUgZGVsIHByaW1vIGludGVydmFsbG8uIFF1ZXN0byBpbnRlcnZhbGxvIHZpZW5lIHV0aWxpenphdG8gcGVyIGwnaXRlcmF6aW9uZSBhdHRyYXZlcnNvIHVuIGRhdGFzZXQuIFF1ZXN0byBwYXJhbWV0cm8gw6ggcmljaGllc3RvIHF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5EZWZpbml6aW9uZSBkaW1lbnNpb25lPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPlBlciBpdGVyYXppb25lPC9zdHJvbmc+LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfbWF4aW11bXZhbHVlX3RhZzBAQFwiOiBcIklsIHZhbG9yZSBtYXNzaW1vIHBlciBsJ2ludGVydmFsbG8uIFF1ZXN0byBwYXJhbWV0cm8gw6ggcmljaGllc3RvIHF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5EZWZpbml6aW9uZSBkaW1lbnNpb25lPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPlBlciBpbnRlcnZhbGxpPC9zdHJvbmc+LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfbWluaW11bXZhbHVlX3RhZzBAQFwiOiBcIklsIHZhbG9yZSBtaW5pbW8gcGVyIGwnaW50ZXJ2YWxsby4gUXVlc3RvIHBhcmFtZXRybyDDqCByaWNoaWVzdG8gcXVhbmRvIGlsIHBhcmFtZXRybyA8c3Ryb25nPkRlZmluaXppb25lIGRpbWVuc2lvbmU8L3N0cm9uZz4gw6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+UGVyIGludGVydmFsbGk8L3N0cm9uZz4uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9yYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGRpIGlucHV0LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfcmFuZ2VzX3RhZzBAQFwiOiBcIjxwPkxlIGFtcGllenplIGludGVydmFsbG8gc3BlY2lmaWNhdGUgbmVsbGEgdGFiZWxsYSB2ZXJyYW5ubyB1dGlsaXp6YXRlIHBlciBhZ2dyZWdhcmUgZ3J1cHBpIGRpIHZhbG9yaS4gSSB2YWxvcmkgbWluaW1vIGUgbWFzc2ltbyBzcGVjaWZpY2FubyBsJ2ludGVydmFsbG8gZGEgaW5jbHVkZXJlLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIHJpY2hpZXN0byBxdWFuZG8gaWwgcGFyYW1ldHJvPHN0cm9uZz5UaXBvPC9zdHJvbmc+w6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+QW1waWV6emUgaW50ZXJ2YWxsbzwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9zdGFydG9mZmlyc3RpdGVyYXRpb25fdGFnMEBAXCI6IFwiTCdpbml6aW8gZGVsIHByaW1vIGludGVydmFsbG8uIFF1ZXN0byBpbnRlcnZhbGxvIHZpZW5lIHV0aWxpenphdG8gcGVyIGwnaXRlcmF6aW9uZSBhdHRyYXZlcnNvIHVuIGRhdGFzZXQuIFF1ZXN0byBwYXJhbWV0cm8gw6ggcmljaGllc3RvIHF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5EZWZpbml6aW9uZSBkaW1lbnNpb25lPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPlBlciBpdGVyYXppb25lPC9zdHJvbmc+LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfc3RlcF90YWcwQEBcIjogXCJMYSBmcmVxdWVuemEgZGkgc2V6aW9uYW1lbnRvIGRlaSBkYXRpLiBRdWVzdG8gcGFyYW1ldHJvIMOoIHJpY2hpZXN0byBxdWFuZG8gaWwgcGFyYW1ldHJvIDxzdHJvbmc+RGVmaW5pemlvbmUgZGltZW5zaW9uZTwvc3Ryb25nPiDDqCBpbXBvc3RhdG8gc3UgPHN0cm9uZz5QZXIgaXRlcmF6aW9uZTwvc3Ryb25nPi4gTCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEgw6ggMy5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX3VuaXRfdGFnMEBAXCI6IFwiU3BlY2lmaWNhIGwndW5pdMOgIGRpIGl0ZXJhemlvbmUuIFF1ZXN0byBwYXJhbWV0cm8gw6ggb2JibGlnYXRvcmlvIHF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5EZWZpbml6aW9uZSBkaW1lbnNpb25lPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPlBlciBpdGVyYXppb25lPC9zdHJvbmc+IGUgaWwgcGFyYW1ldHJvIDxzdHJvbmc+RGltZW5zaW9uZTwvc3Ryb25nPiDDqCBpbXBvc3RhdG8gc3UgPHN0cm9uZz5TdGRUaW1lPC9zdHJvbmc+LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfdmFsdWVfdGFnMEBAXCI6IFwiSWwgdmFsb3JlIHBlciBsYSBkaW1lbnNpb25lIHNwZWNpZmljYXRhLiBRdWVzdG8gcGFyYW1ldHJvIMOoIHJpY2hpZXN0byBxdWFuZG8gaWwgcGFyYW1ldHJvIDxzdHJvbmc+RGVmaW5pemlvbmUgZGltZW5zaW9uZTwvc3Ryb25nPiDDqCBpbXBvc3RhdG8gc3UgPHN0cm9uZz5QZXIgdmFsb3JpPC9zdHJvbmc+LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfdmFyaWFibGVzX3RhZzBAQFwiOiBcIkxlIHZhcmlhYmlsaSBjaGUgc2FyYW5ubyBpbmNsdXNlIG5lbCBsYXllciByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUgZGkgb3V0cHV0LiBTZSBub24gc2kgc3BlY2lmaWNhIG5lc3N1bmEgdmFyaWFiaWxlLCBzaSB1c2Vyw6AgbGEgcHJpbWEgdmFyaWFiaWxlLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9ubGVzc190YWcwQEBcIjogXCJTcGVjaWZpY2Egc2UgaWwgbGF5ZXIgYXZyw6AgdmFsb3JpIGRpIGRpbWVuc2lvbmUuIFF1ZXN0YSBvcHppb25lIMOoIGRpc3BvbmliaWxlIHNvbG8gc2Ugw6ggc2VsZXppb25hdGEgdW4ndW5pY2Egc2V6aW9uZSBwZXIgY3JlYXJlIHVuIGxheWVyLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9ubGVzc190YWcxQEBcIjogXCJTZWxlemlvbmF0bzogaWwgbGF5ZXIgbm9uIGF2csOgIHZhbG9yaSBkaSBkaW1lbnNpb25lLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9ubGVzc190YWcyQEBcIjogXCJOb24gc2VsZXppb25hdG86IGlsIGxheWVyIGF2csOgIHVuIHZhbG9yZSBkaSBkaW1lbnNpb25lLuKAi1F1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtUmFzdGVyX2ludGVycG9sYXRpb25jZWxsc2l6ZV90YWcwQEBcIjogXCJMYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIGRlbCByYXN0ZXIgaW50ZXJwb2xhdG8uIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAkezF9LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1SYXN0ZXJfaW50ZXJwb2xhdGlvbm1ldGhvZF90YWcwQEBcIjogXCJJbCBtZXRvZG8gZGkgcmljYW1waW9uYW1lbnRvIHVzYXRvIHBlciBpbnRlcnBvbGFyZSBkYXRpIGlycmVnb2xhcmkuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLVJhc3Rlcl9pbnRlcnBvbGF0aW9ubWV0aG9kX3RhZzFAQFwiOiBcIjxzdHJvbmc+VmljaW5vIHBpw7kgcHJvc3NpbW88L3N0cm9uZz46IGNhbGNvbGEgaWwgdmFsb3JlIGRlbCBwaXhlbCBkaSBvdXRwdXQgdXNhbmRvIGlsIHBpeGVsIGRpIGlucHV0IHBpw7kgdmljaW5vLiBTZSBub24gZXNpc3RlIG5lc3N1biBwaXhlbCBkaSBvcmlnaW5lLCBub24gw6ggcG9zc2liaWxlIGNyZWFyZSBuZXNzdW4gcGl4ZWwgbnVvdm8gbmVsbCdvdXRwdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtUmFzdGVyX2ludGVycG9sYXRpb25tZXRob2RfdGFnMkBAXCI6IFwiPHN0cm9uZz5SaXZlc3RpbWVudG8gbGluZWFyZTwvc3Ryb25nPjogdXNhIHVuYSByZXRlIGlycmVnb2xhcmUgdHJpYW5nb2xhdGEgZGFsIHB1bnRvIGNlbnRyYWxlIGRpIG9nbmkgcGl4ZWwgZGVsIHJhc3RlciBpcnJlZ29sYXJlIHBlciBpbnRlcnBvbGFyZSB1bmEgc3VwZXJmaWNpZSBjaGUgdmllbmUgcXVpbmRpIGNvbnZlcnRpdGEgaW4gdW4gcmFzdGVyIHJlZ29sYXJlLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1SYXN0ZXJfaW50ZXJwb2xhdGlvbm1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPlZpY2lubyBuYXR1cmFsZTwvc3Ryb25nPjogdHJvdmEgaWwgc290dG9pbnNpZW1lIGRpIGNhbXBpb25pIGRpIGlucHV0IHBpw7kgdmljaW5vIGEgdW4gcHVudG8gZGkgcmlmZXJpbWVudG8gZSBhcHBsaWNhIHN1IGRpIGxvcm8gaSBwZXNpLCBpbiBiYXNlIGFsbGUgYXJlZSBwcm9wb3J6aW9uYXRlLCBwZXIgaW50ZXJwb2xhcmUgdW4gdmFsb3JlLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1SYXN0ZXJfaW50ZXJwb2xhdGlvbm1ldGhvZF90YWc0QEBcIjogXCI8c3Ryb25nPlBvbmRlcmF6aW9uZSBkaXN0YW56YSBpbnZlcnNhPC9zdHJvbmc+OiBkZXRlcm1pbmEgaSB2YWxvcmkgcGl4ZWwgdXNhbmRvIHVuYSBjb21iaW5hemlvbmUgbGluZWFybWVudGUgcG9uZGVyYXRhIGRpIHVuIGluc2llbWUgZGkgcHVudGkgY2FtcGlvbmUgbyBwaXhlbC4gSWwgcGVzbyDDqCB1bmEgZnVuemlvbmUgZGVsbCdpbnZlcnNvIGRlbGxhIGRpc3RhbnphIGRhIHB1bnRpIG8gcGl4ZWwgY29ub3NjaXV0aS5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtUmFzdGVyX3Jhc3Rlcl90YWcwQEBcIjogXCJJbCByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUgZGkgaW5wdXQuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLVJhc3Rlcl92YXJpYWJsZXNfdGFnMEBAXCI6IFwiTGEgdmFyaWFiaWxlIG8gbGUgdmFyaWFiaWxpIGNoZSBzYXJhbm5vIGluY2x1c2UgbmVsIGxheWVyIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnMEBAXCI6IFwiU3BlY2lmaWNhIGlsIG1ldG9kbyBkaSBkaXN0cmlidXppb25lIHZhbG9yZSBjYXN1YWxlIGRhIHV0aWxpenphcmUuXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+VW5pZm9ybWU8L3N0cm9uZz4gKE1pbmltbywgTWFzc2ltbyk6IHVuYSBkaXN0cmlidXppb25lIHVuaWZvcm1lIGNvbiB1biBpbnRlcnZhbGxvIGRlZmluaXRvLiBJIHZhbG9yaSBwcmVkZWZpbml0aSBzb25vIDAgcGVyIE1pbmltbyBlIDEgcGVyIE1hc3NpbW8uIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnMkBAXCI6IFwiPHN0cm9uZz5OdW1lcm8gaW50ZXJvPC9zdHJvbmc+IChNaW5pbW8sIE1hc3NpbW8pOiB1bmEgZGlzdHJpYnV6aW9uZSBudW1lcmkgaW50ZXJpIGNvbiB1biBpbnRlcnZhbGxvIGRlZmluaXRvLiBJIHZhbG9yaSBwcmVkZWZpbml0aSBzb25vIDEgcGVyIE1pbmltbyBlIDEwIHBlciBNYXNzaW1vLlwiLFxuXHRcIkBAUmFuZG9tX2Rpc3RyaWJ1dGlvbl90YWczQEBcIjogXCI8c3Ryb25nPk5vcm1hbGU8L3N0cm9uZz4gKE1lZGlhLCBEZXZpYXppb25lIHN0YW5kYXJkKTogdW5hIGRpc3RyaWJ1emlvbmUgbm9ybWFsZSBjb24gdW5hIG1lZGlhIGUgdW5hIGRldmlhemlvbmUgc3RhbmRhcmQgZGVmaW5pdGUuIEkgdmFsb3JpIHByZWRlZmluaXRpIHNvbm8gMCBwZXIgTWVkaWEgZSAxIHBlciBEZXZpYXppb25lIHN0YW5kYXJkLlwiLFxuXHRcIkBAUmFuZG9tX2Rpc3RyaWJ1dGlvbl90YWc0QEBcIjogXCI8c3Ryb25nPkVzcG9uZW56aWFsZTwvc3Ryb25nPiAoTWVkaWEpOiB1bmEgZGlzdHJpYnV6aW9uZSBlc3BvbmVuemlhbGUgY29uIHVuYSBtZWRpYSBkZWZpbml0YS4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDEuXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzVAQFwiOiBcIjxzdHJvbmc+UG9pc3Nvbjwvc3Ryb25nPiAoTWVkaWEpOiB1bmEgZGlzdHJpYnV6aW9uZSBQb2lzc29uIGNvbiB1bmEgbWVkaWEgZGVmaW5pdGEuIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAxLlwiLFxuXHRcIkBAUmFuZG9tX2Rpc3RyaWJ1dGlvbl90YWc2QEBcIjogXCI8c3Ryb25nPkdhbW1hPC9zdHJvbmc+IChBbGZhLCBCZXRhKTogdW5hIGRpc3RyaWJ1emlvbmUgZGkgZ2FtbWEgY29uIGFsZmEgZSBiZXRhIGRlZmluaXRpLiBJIHZhbG9yaSBwcmVkZWZpbml0aSBzb25vIDEgcGVyIEFsZmEgZSAxIHBlciBCZXRhLlwiLFxuXHRcIkBAUmFuZG9tX2Rpc3RyaWJ1dGlvbl90YWc3QEBcIjogXCI8c3Ryb25nPkJpbm9taWFsZTwvc3Ryb25nPiAoTiwgUHJvYmFiaWxpdMOgKTogdW5hIGRpc3RyaWJ1emlvbmUgYmlub21pYWxlIGNvbiBOIGUgcHJvYmFiaWxpdMOgIGRlZmluaXRpLiBJIHZhbG9yaSBwcmVkZWZpbml0aSBzb25vIDEwIHBlciBOIGUgMCw1IHBlciBQcm9iYWJpbGl0w6AuXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzhAQFwiOiBcIjxzdHJvbmc+R2VvbWV0cmljbzwvc3Ryb25nPiAoUHJvYmFiaWxpdMOgKTogdW5hIGRpc3RyaWJ1emlvbmUgZ2VvbWV0cmljYSBjb24gdW5hIHByb2JhYmlsaXTDoCBkZWZpbml0YS4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDAsNS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnOUBAXCI6IFwiPHN0cm9uZz5CaW5vbWlhbGUgbmVnYXRpdm88L3N0cm9uZz4gKHIsIFByb2JhYmlsaXTDoCk6IHVuYSBkaXN0cmlidXppb25lIFBhc2NhbCBjb24gciBlIHByb2JhYmlsaXTDoCBkZWZpbml0aS4gSSB2YWxvcmkgcHJlZGVmaW5pdGkgc29ubyAxMCwwIHBlciByIGUgMCw1IHBlciBQcm9iYWJpbGl0w6AuXCIsXG5cdFwiQEBSYW5kb21fcmFuZG9tbnVtYmVyZ2VuZXJhdG9yX3RhZzBAQFwiOiBcIlNwZWNpZmljYXJlIGwnYWxnb3JpdG1vIGdlbmVyYXRvcmUgY2FzdWFsZSBjaGUgdXRpbGl6emEgaWwgc2VlZCBlIGxhIGRpc3RyaWJ1emlvbmUgcGVyIHByb2R1cnJlIHVuYSBzZXF1ZW56YSBkaSBudW1lcmkgY2FzdWFsaS4gTGUgb3B6aW9uaSBkaXNwb25pYmlsaSBzb25vIGxlIHNlZ3VlbnRpOlwiLFxuXHRcIkBAUmFuZG9tX3JhbmRvbW51bWJlcmdlbmVyYXRvcl90YWcxQEBcIjogXCJDIFJhbmQgc3RhbmRhcmRcIixcblx0XCJAQFJhbmRvbV9yYW5kb21udW1iZXJnZW5lcmF0b3JfdGFnMkBAXCI6IFwiQWxnb3JpdG1vIDU5OSByYWNjb2x0byBkYSBBQ01cIixcblx0XCJAQFJhbmRvbV9yYW5kb21udW1iZXJnZW5lcmF0b3JfdGFnM0BAXCI6IFwiTWVyc2VubmUgVHdpc3RlclwiLFxuXHRcIkBAUmFuZG9tX3JhbmRvbW51bWJlcmdlbmVyYXRvcl90YWc0QEBcIjogXCJJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggTWVyc2VubmUgVHdpc3Rlci5cIixcblx0XCJAQFJhbmRvbV9yYXN0ZXJpbmZvX3RhZzBAQFwiOiBcIlVzYXJlIGlsIHB1bHNhbnRlIDxzdHJvbmc+Q2FyaWNhIHJhc3RlciBkZWwgbW9kZWxsbzwvc3Ryb25nPiBwZXIgY2FyaWNhcmUgdW4gbW9kZWxsbyBkYSB1bmEgZGlyZWN0b3J5IG8gcG9ydGFsZS5cIixcblx0XCJAQFJhbmRvbV9zZWVkX3RhZzBAQFwiOiBcIklsIHZhbG9yZSBpbml6aWFsZSDDqCB1biB2YWxvcmUgaW50ZXJvIGNoZSB2aWVuZSB1dGlsaXp6YXRvIHBlciBhdnZpYXJlIGlsIGdlbmVyYXRvcmUgZGkgbnVtZXJpIGNhc3VhbGkuIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAxLlwiLFxuXHRcIkBAU2hyaW5rX251bWJlcm9mY2VsbHNfdGFnMEBAXCI6IFwiSWwgbnVtZXJvIGRpIGNlbGxlIHBlciBpbCBxdWFsZSByaWR1cnJlIGNpYXNjdW5hIHpvbmEgc3BlY2lmaWNhdGEuXCIsXG5cdFwiQEBTaHJpbmtfbnVtYmVyb2ZjZWxsc190YWcxQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBlIHB1w7IgZXNzZXJlIG1hZ2dpb3JlIG8gdWd1YWxlIGEgMS5cIixcblx0XCJAQFNocmlua19yYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGlucHV0IHBlciBpbCBxdWFsZSByaWR1cnJlIGxlIHpvbmUgaWRlbnRpZmljYXRlLlwiLFxuXHRcIkBAU2hyaW5rX3Jhc3Rlcl90YWcxQEBcIjogXCJEZXZlIGVzc2VyZSBkaSB0aXBvIG51bWVybyBpbnRlcm8uXCIsXG5cdFwiQEBTaHJpbmtfem9uZXZhbHVlc190YWcwQEBcIjogXCJMJ2VsZW5jbyBkaSB6b25lIGRhIHJpZHVycmUuXCIsXG5cdFwiQEBTaHJpbmtfem9uZXZhbHVlc190YWcxQEBcIjogXCJJIHZhbG9yaSB6b25hIGRldm9ubyBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBlIHNpIHBvc3Nvbm8gdHJvdmFyZSBpbiBxdWFsdW5xdWUgb3JkaW5lLlwiLFxuXHRcIkBAU2hyaW5rX3pvbmV2YWx1ZXNfdGFnMkBAXCI6IFwiUGVyIHNwZWNpZmljYXJlIHBpw7kgem9uZSwgdXRpbGl6emFyZSB1bm8gc3BhemlvIHBlciBzZXBhcmFyZSBpIHZhbG9yaSBkaSB6b25hLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2Nvc3RyYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGNoZSBkZWZpbmlzY2UgaWwgY29zdG8gbyBsJ2ltcGVkZW56YSBkZWxsbyBzcG9zdGFtZW50byBwbGFuaW1ldHJpY28gYXR0cmF2ZXJzbyBjaWFzY3VuYSBjZWxsYS4gSWwgdmFsb3JlIGEgb2duaSBwb3NpemlvbmUgZGVsbGEgY2VsbGEgcmFwcHJlc2VudGEgbGEgZGlzdGFuemEgZGkgY29zdG8gcGVyIHVuaXTDoCBwZXIgbCdhdHRyYXZlcnNhbWVudG8gZGVsbGEgc3Rlc3NhLiBPZ25pIHZhbG9yZSBkaSBwb3NpemlvbmUgZGkgdW5hIGNlbGxhIHZpZW5lIG1vbHRpcGxpY2F0byBwZXIgbGEgcmlzb2x1emlvbmUgZGVsbGEgY2VsbGEgZSBjb21wZW5zYSBpbm9sdHJlIGlsIG1vdmltZW50byBkaWFnb25hbGUgcGVyIG90dGVuZXJlIGlsIGNvc3RvIHRvdGFsZSBkZWxsJ2F0dHJhdmVyc2FtZW50byBkZWxsYSBzdGVzc2EuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fY29zdHJhc3Rlcl90YWcxQEBcIjogXCJJIHZhbG9yaSBkZWwgPHN0cm9uZz5SYXN0ZXIgZGkgY29zdG88L3N0cm9uZz4gcG9zc29ubyBlc3NlcmUgYSBudW1lcm8gaW50ZXJvIG8gYSB2aXJnb2xhIG1vYmlsZSwgbWEgbm9uIHBvc3Nvbm8gZXNzZXJlIG5lZ2F0aXZpIG8gemVyby5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9kaXN0YW5jZW1ldGhvZF90YWcwQEBcIjogXCJEZXRlcm1pbmEgc2UgY2FsY29sYXJlIGxhIGRpc3RhbnphIGNvbiB1biBtZXRvZG8gcGxhbmFyZSAodGVycmEgcGlhdHRhKSBvIGdlb2RldGljbyAoZWxsaXNzb2lkZSkuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fZGlzdGFuY2VtZXRob2RfdGFnMUBAXCI6IFwiUGxhbmFyZTogbGEgbWlzdXJhemlvbmUgcGxhbmFyZSB1dGlsaXp6YSBsYSBtYXRlbWF0aWNhIGNhcnRlc2lhbmEgMkQgcGVyIGNhbGNvbGFyZSBhcmVhIGUgbHVuZ2hlenphLiBRdWVzdGEgb3B6aW9uZSDDqCBkaXNwb25pYmlsZSBzb2xvIHF1YW5kbyBzaSBtaXN1cmEgaW4gdW4gc2lzdGVtYSBkaSBjb29yZGluYXRlIHByb2lldHRhdG8gZSBpbCBwaWFubyAyRCBkaSB0YWxlIHNpc3RlbWEgZGkgY29vcmRpbmF0ZSB2aWVuZSB1dGlsaXp6YXRvIGNvbWUgYmFzZSBwZXIgbGUgbWlzdXJhemlvbmkuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fZGlzdGFuY2VtZXRob2RfdGFnMkBAXCI6IFwiR2VvZGV0aWNhOiBsYSBsaW5lYSBwacO5IGJyZXZlIHRyYSBkdWUgcHVudGkgc3VsbGEgc3VwZXJmaWNpZSB0ZXJyZXN0cmUgc3UgdW5vIHNmZXJvaWRlIChlbGxpc3NvaWRlKS4gUGVydGFudG8sIGluZGlwZW5kZW50ZW1lbnRlIGRhbGxhIHByb2llemlvbmUgZGkgaW5wdXQgbyBvdXRwdXQsIGkgcmlzdWx0YXRpIG5vbiBjYW1iaWFuby5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9kaXN0YW5jZW1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPk5vdGE8L3N0cm9uZz46IGxhIGxpbmVhIGdlb2RldGljYSBwdcOyIGVzc2VyZSB1c2F0YSBzZSBzaSBkZXNpZGVyYSBkZXRlcm1pbmFyZSBsYSBkaXN0YW56YSBwacO5IGJyZXZlIHRyYSBkdWUgY2l0dMOgIHBlciBsYSB0cmFpZXR0b3JpYSBkaSB1biBhZXJlby4gUXVlc3RvIG1ldG9kbyDDqCBjb25vc2NpdXRvIGFuY2hlIGNvbWUgbGluZWEgZGVsIGNlcmNoaW8gbWFzc2ltbyBzZSBiYXNhdG8gc3UgdW5hIHNmZXJhIHBpdXR0b3N0byBjaGUgc3UgdW4gZWxsaXNzb2lkZS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9nZW5lcmF0ZWJhY2tkaXJlY3Rpb25iYW5kYXNhZGRpdGlvbmFsYmFuZGlub3V0cHV0X3RhZzBAQFwiOiBcIlN0YWJpbGlzY2Ugc2Ugc2kgY3JlYSBzb2xvIHVuIHJhc3RlciBkaSBhY2N1bXVsbyBkZWxsYSBkaXN0YW56YSBvIHVuIHJhc3RlciBtdWx0aWJhbmRhIGNvbXBvc3RvIHNpYSBkYWwgcmFzdGVyIGRpIGFjY3VtdWxvIGRlbGxhIGRpc3RhbnphIHNpYSBkYWwgcmFzdGVyIGRpIGRpcmV6aW9uZSBjb250cmFyaWEuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fZ2VuZXJhdGViYWNrZGlyZWN0aW9uYmFuZGFzYWRkaXRpb25hbGJhbmRpbm91dHB1dF90YWcxQEBcIjogXCJOb24gc2VsZXppb25hdG86IGlsIHJpc3VsdGF0byDDqCBpbCByYXN0ZXIgZGkgYWNjdW11bG8gZGVsbGEgZGlzdGFuemEuIFNpIHRyYXR0YSBkaSB1biByaXN1bHRhdG8gYSBiYW5kYSBzaW5nb2xhLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fZ2VuZXJhdGViYWNrZGlyZWN0aW9uYmFuZGFzYWRkaXRpb25hbGJhbmRpbm91dHB1dF90YWcyQEBcIjogXCJTZWxlemlvbmF0bzogc2kgY3JlYSB1biByaXN1bHRhdG8gbXVsdGliYW5kYS4gTGEgcHJpbWEgYmFuZGEgw6ggaWwgcmFzdGVyIGRpIGFjY3VtdWxvIGRlbGxhIGRpc3RhbnphIGUgbGEgc2Vjb25kYSBiYW5kYSDDqCBpbCByYXN0ZXIgZGkgZGlyZXppb25lIGNvbnRyYXJpYS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9nZW5lcmF0ZWJhY2tkaXJlY3Rpb25iYW5kYXNhZGRpdGlvbmFsYmFuZGlub3V0cHV0X3RhZzNAQFwiOiBcIklsIHJhc3RlciBkaSBkaXJlemlvbmUgY29udHJhcmlhIGNhbGNvbGEgcGVyIG9nbmkgY2VsbGEsIGxhIGRpcmV6aW9uZSBpbiBncmFkaSBmaW5vIGFsbGEgY2VsbGEgdmljaW5hIHNlZ3VlbmRvIGlsIHBlcmNvcnNvIHBpw7kgYnJldmUgZmlubyBhbGxhIGZvbnRlIHBpw7kgdmljaW5hIGV2aXRhbmRvIGJhcnJpZXJlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2hvcml6b250YWxmYWN0b3JfdGFnMEBAXCI6IFwiPHA+RGVmaW5pc2NlIGxhIHJlbGF6aW9uZSB0cmEgaWwgZmF0dG9yZSBkaSBjb3N0byBvcml6em9udGFsZSBlIGwnYW5nb2xvIG1vYmlsZSByZWxhdGl2byBvcml6em9udGFsZSAoSFJNQSkuPC9wPjxwPkNpIHNvbm8gZGl2ZXJzaSBmYXR0b3JpIGNvbiBtb2RpZmljYXRvcmkgY2hlIGlkZW50aWZpY2FubyB1biBncmFmaWNvIGRlbCBmYXR0b3JlIHZlcnRpY2FsZSBkZWZpbml0by4gSW5vbHRyZSwgw6ggcG9zc2liaWxlIHV0aWxpenphcmUgdW5hIHRhYmVsbGEgcGVyIGNyZWFyZSB1biBncmFmaWNvIHBlcnNvbmFsaXp6YXRvLiBJIGdyYWZpY2kgc29ubyB1dGlsaXp6YXRpIHBlciBpZGVudGlmaWNhcmUgaWwgZmF0dG9yZSB2ZXJ0aWNhbGUgdXRpbGl6emF0byBuZWwgY2FsY29sbyBkZWwgY29zdG8gdG90YWxlIGRlbGxvIHNwb3N0YW1lbnRvIGluIHVuYSBjZWxsYSB2aWNpbmEuPC9wPjxwPk5lbGxlIHNwaWVnYXppb25pIGNoZSBzZWd1b25vLCB2ZW5nb25vIHV0aWxpenphdGkgZHVlIGFjcm9uaW1pOiBIRiBlIEhSTUEuIEhGIHN0YW5kcyBmb3IgaG9yaXpvbnRhbCBmYWN0b3IsIHdoaWNoIGRlZmluZXMgdGhlIGhvcml6b250YWwgZGlmZmljdWx0eSBlbmNvdW50ZXJlZCB3aGVuIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIHRoZSBuZXh0LiBIUk1BIHN0YSBwZXIgaG9yaXpvbnRhbCByZWxhdGl2ZSBtb3ZpbmcgYW5nbGUsIGNoZSBpZGVudGlmaWNhIGwnYW5nb2xvIHRyYSBsYSBkaXJlemlvbmUgb3JpenpvbnRhbGUgZGEgdW5hIGNlbGxhIGUgbGEgZGlyZXppb25lIGRpIG1vdmltZW50by4gSSB0aXBpIGRpIDwvcD48cD48c3Ryb25nPmZhdHRvcmkgb3JpenpvbnRhbGk8L3N0cm9uZz4gaW5jbHVkb25vIGkgc2VndWVudGk6IDwvcD48dWw+PGxpPjxzdHJvbmc+QmluYXJpbzwvc3Ryb25nPi0tIEluZGljYSBjaGUgc2UgbCdIUk1BIMOoIGluZmVyaW9yZSBhbGwnYW5nb2xvIGRpIHRhZ2xpbywgbCdIRiDDqCBpbXBvc3RhdG8gYWwgdmFsb3JlIGFzc29jaWF0byBhbCBmYXR0b3JlIHplcm87IGFsdHJpbWVudGksIMOoIGluZmluaXRvLjwvbGk+PGxpPjxzdHJvbmc+QXZhbnRpPC9zdHJvbmc+IC0tIFN0YWJpbGlzY2UgY2hlIMOoIHBlcm1lc3NvIHNvbG8gaWwgbW92aW1lbnRvIGluIGF2YW50aS4gTCdIUk1BIGRldmUgZXNzZXJlIG1hZ2dpb3JlIG8gdWd1YWxlIGEgMCBlIGluZmVyaW9yZSBhIDkwIGdyYWRpICgwICZsdDs9IEhSTUEgJmx0OzkwKS4gU2UgbCdIUk1BIMOoIHN1cGVyaW9yZSBhIDAgZSBpbmZlcmlvcmUgYSA0NSBncmFkaSwgbCdIRiBwZXIgbGEgY2VsbGEgdmllbmUgaW1wb3N0YXRvIHN1bCB2YWxvcmUgYXNzb2NpYXRvIGFsIGZhdHRvcmUgemVyby4gU2UgbCdIUk1BIMOoIHN1cGVyaW9yZSBvIHBhcmkgYSA0NSBncmFkaSwgdmllbmUgdXRpbGl6emF0byBpbCB2YWxvcmUgZGVsIG1vZGlmaWNhdG9yZSBkZWwgdmFsb3JlIGxhdGVyYWxlLiBMJ0hGIHBlciBxdWFsc2lhc2kgdmFsb3JlIEhSTUEgdWd1YWxlIG8gc3VwZXJpb3JlIGEgOTAgZ3JhZGkgw6ggaW1wb3N0YXRvIHN1IGluZmluaXRvLjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyZTwvc3Ryb25nPi0tU3BlY2lmaWNhIGNoZSBsJ0hGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGRlbGwnSFJNQS48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmUgaW52ZXJzYTwvc3Ryb25nPi0tU3BlY2lmaWNhIGNoZSBsJ0hGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGludmVyc2EgZGVsbCdIUk1BLjwvbGk+PGxpPjxzdHJvbmc+VGFiZWxsYTwvc3Ryb25nPi0gSWRlbnRpZmljYSBjaGUgdW4gZmlsZSB0YWJlbGxhIHNhcsOgIHVzYXRvIHBlciBkZWZpbmlyZSBpbCBncmFmaWNvIGRlaSBmYXR0b3JpIG9yaXp6b250YWxpIHVzYXRvIHBlciBkZXRlcm1pbmFyZSBnbGkgSEYuPC9saT48L3VsPjxwPkkgbW9kaWZpY2F0b3JpIGRlaSBmYXR0b3JpIG9yaXp6b250YWxpIGluY2x1ZG9ubyBxdWFudG8gc2VndWU6IDwvcD48dWw+PGxpPjxzdHJvbmc+RmF0dG9yZSB6ZXJvPC9zdHJvbmc+LS0gSWwgZmF0dG9yZSBvcml6em9udGFsZSBkYSB1c2FyZSBxdWFuZG8gbCdIUk1BIMOoIHplcm8uIFF1ZXN0byBmYXR0b3JlIHBvc2l6aW9uYSBsJ2ludGVyY2V0dGEgeSBwZXIgcXVhbHNpYXNpIGZ1bnppb25lIGZhdHRvcmUgb3JpenpvbnRhbGUuPC9saT48bGk+PHN0cm9uZz5BbmdvbG8gZGkgdGFnbGlvPC9zdHJvbmc+LS1EZWZpbmlzY2UgbCdhbmdvbG8gSFJNQSBvbHRyZSBpbCBxdWFsZSBsJ0hGIHNhcsOgIGltcG9zdGF0byBzdSBpbmZpbml0by48L2xpPjxsaT48c3Ryb25nPlBlbmRlbnphPC9zdHJvbmc+LS0gU3RhYmlsaXNjZSBsYSBwZW5kZW56YSBkZWxsYSBsaW5lYSByZXR0YSB1c2F0YSBjb24gbGUgcGFyb2xlIGNoaWF2ZSBmYXR0b3JlIG9yaXp6b250YWxlIDxzdHJvbmc+TGluZWFyZTwvc3Ryb25nPiBlIDxzdHJvbmc+TGluZWFyZSBpbnZlcnNhPC9zdHJvbmc+LiBMYSBwZW5kZW56YSDDqCBzcGVjaWZpY2F0YSBjb21lIHVuYSBmcmF6aW9uZSBkaSBzYWxpdGEgc3UgY29yc2EgKHBlciBlc2VtcGlvLCBsYSBwZW5kZW56YSBkZWwgNDUlIMOoIDEvNDUsIGNoZSB2aWVuZSBpbW1lc3NhIGNvbWUgMCwwMjIyMikuPC9saT48bGk+PHN0cm9uZz5TaWRlIHZhbHVlPC9zdHJvbmc+LS0gU3RhYmlsaXNjZSBsJ0hGIHF1YW5kbyBsJ0hSTUEgw6ggbWFnZ2lvcmUgbyB1Z3VhbGUgYSA0NSBncmFkaSBlIG1pbm9yZSBkaSA5MCBncmFkaSBxdWFuZG8gdmllbmUgc3BlY2lmaWNhdGEgbGEgcGFyb2xhIGNoaWF2ZSBGYXR0b3JlIG9yaXp6b250YWxlIDxzdHJvbmc+YXZhbnRpPC9zdHJvbmc+LjwvbGk+PGxpPjxzdHJvbmc+Tm9tZSBkZWxsYSB0YWJlbGxhPC9zdHJvbmc+IC0gSWRlbnRpZmljYSBpbCBub21lIGRlbGxhIHRhYmVsbGEgY2hlIGRlZmluaXNjZSBsJ0hGLjwvbGk+PC91bD5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9ob3Jpem9udGFscmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBjaGUgZGVmaW5pc2NlIGxhIGRpcmV6aW9uZSBvcml6em9udGFsZSBzdSBvZ25pIGNlbGxhLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2hvcml6b250YWxyYXN0ZXJfdGFnMUBAXCI6IFwiSSB2YWxvcmkgc3VsIHJhc3RlciBkZXZvbm8gZXNzZXJlIG51bWVyaSBpbnRlcmkgY29tcHJlc2kgdHJhIDAgZSAzNjAgY29uIDAgZ3JhZGkgY2hlIGluZGljYSBpbCBub3JkIG8gdmVyc28gbGEgcGFydGUgc3VwZXJpb3JlIGRlbGxvIHNjaGVybW8gZSBjb24gYXVtZW50byBpbiBzZW5zbyBvcmFyaW8uIEFsbGUgYXJlZSBwaWFuZSBkZXZlIGVzc2VyZSBmb3JuaXRvIHVuIHZhbG9yZSBkaSAtMS4gSSB2YWxvcmkgaW4gb2duaSBwb3NpemlvbmUgdmVuZ29ubyB1dGlsaXp6YXRpIGluc2llbWUgYSA8c3Ryb25nPkZhdHRvcmUgb3JpenpvbnRhbGU8L3N0cm9uZz4gcGVyIGRldGVybWluYXJlIGkgY29zdGkgb3JpenpvbnRhbGkgZHVyYW50ZSBsbyBzcG9zdGFtZW50byBkYSB1bmEgY2VsbGEgYSBxdWVsbGUgdmljaW5lLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2luaXRpYWxhY2N1bXVsYXRpb25fdGFnMEBAXCI6IFwiSWwgY29zdG8gY3VtdWxhdGl2byBpbml6aWFsZSBwZXIgYXZ2aWFyZSBpbCBjYWxjb2xvIGRlbCBjb3N0by4gUXVlc3RvIHBhcmFtZXRybyBjb25zZW50ZSBkaSBzcGVjaWZpY2FyZSBpbCBjb3N0byBmaXNzbyBhc3NvY2lhdG8gYWQgdW4nb3JpZ2luZS4gSW52ZWNlIGRpIGluaXppYXJlIGNvbiB1biBjb3N0byAwLCBsJ2FsZ29yaXRtbyBkZWwgY29zdG8gaW5pemllcsOgIGNvbiBpbCB2YWxvcmUgc3BlY2lmaWNhdG8uXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25faW5pdGlhbGFjY3VtdWxhdGlvbl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgcGVyIHF1ZXN0byBwYXJhbWV0cm8gdW4gdmFsb3JlIG51bWVyaWNvIChkb3BwaW8pIG8gdW4gY2FtcG8gZGFsIDxzdHJvbmc+UmFzdGVyIG9yaWdpbmU8L3N0cm9uZz4uXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25faW5pdGlhbGFjY3VtdWxhdGlvbl90YWcyQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgcGFyaSBvIHN1cGVyaW9yZSBhIHplcm8uIEwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhIMOoIDAuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbWF4aW11bWFjY3VtdWxhdGlvbl90YWcwQEBcIjogXCJEZWZpbmlzY2UgaWwgY29zdG8gY3VtdWxhdGl2byBtYXNzaW1vIHBlciBpbCB2aWFnZ2lhdG9yZSByZWxhdGl2byBhIHVuJ29yaWdpbmUuIEkgY2FsY29saSBkZWwgY29zdG8gY29udGludWFubyBwZXIgb2duaSBvcmlnaW5lIGZpbmNow6kgbm9uIHNpIHJhZ2dpdW5nZSBsYSBjYXBhY2l0w6Agc3BlY2lmaWNhdGEuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbWF4aW11bWFjY3VtdWxhdGlvbl90YWcxQEBcIjogXCLDiCBwb3NzaWJpbGUgdXNhcmUgcGVyIHF1ZXN0byBwYXJhbWV0cm8gdW4gdmFsb3JlIG51bWVyaWNvIChkb3BwaW8pIG8gdW4gY2FtcG8gZGFsIDxzdHJvbmc+UmFzdGVyIG9yaWdpbmU8L3N0cm9uZz4uXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbWF4aW11bWFjY3VtdWxhdGlvbl90YWcyQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgZGkgemVyby4gTGEgY2FwYWNpdMOgIHByZWRlZmluaXRhIMOoIGZpbm8gYWwgYm9yZG8gZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzBAQFwiOiBcIlVuIG1vbHRpcGxpY2F0b3JlIGRhIGFwcGxpY2FyZSBhaSB2YWxvcmkgZGkgY29zdG8uXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzFAQFwiOiBcIlF1ZXN0byBwYXJhbWV0cm8gY29uc2VudGUgaWwgY29udHJvbGxvIGRlbGxhIG1vZGFsaXTDoCBkaSBzcG9zdGFtZW50byBvIGRlbGxhIGdyYW5kZXp6YSBhbGwnb3JpZ2luZS4gTWFnZ2lvcmUgw6ggaWwgbW9sdGlwbGljYXRvcmUsIG1hZ2dpb3JlIMOoIGlsIGNvc3RvIHBlciBsbyBzcG9zdGFtZW50byBhdHRyYXZlcnNvIG9nbmkgY2VsbGEuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzJAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSBwZXIgcXVlc3RvIHBhcmFtZXRybyB1biB2YWxvcmUgbnVtZXJpY28gKGRvcHBpbykgbyB1biBjYW1wbyBkYWwgPHN0cm9uZz5SYXN0ZXIgb3JpZ2luZTwvc3Ryb25nPi5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9tdWx0aXBsaWVydG9hcHBseXRvY29zdHNfdGFnM0BAXCI6IFwiSSB2YWxvcmkgZGV2b25vIGVzc2VyZSBtYWdnaW9yaSBkaSB6ZXJvLiBMJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YSDDqCAxLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3Jhc3RlcmJhcnJpZXJzX3RhZzBAQFwiOiBcIklsIHJhc3RlciBjaGUgZGVmaW5pc2NlIGxlIGJhcnJpZXJlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3Jhc3RlcmJhcnJpZXJzX3RhZzFAQFwiOiBcIklsIGRhdGFzZXQgZGV2ZSBjb250ZW5lcmUgTm9EYXRhIGxhZGRvdmUgbm9uIGNpIHNvbm8gYmFycmllcmUuIExlIGJhcnJpZXJlIHNvbm8gcmFwcHJlc2VudGF0ZSBkYSB2YWxvcmkgdmFsaWRpLCBpbmNsdXNvIGxvIHplcm8uXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fcmFzdGVyYmFycmllcnNfdGFnMkBAXCI6IFwiTGUgYmFycmllcmUgcG9zc29ubyBlc3NlcmUgZGVmaW5pdGUgZGEgdW4gbnVtZXJvIGludGVybyBvIGRhIHVuIHJhc3RlciBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3NvdXJjZXJhc3Rlcl90YWcwQEBcIjogXCJQb3NpemlvbmkgZGVsbOKAmW9yaWdpbmUgZGkgaW5wdXQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fc291cmNlcmFzdGVyX3RhZzFAQFwiOiBcIsOIIHVuIGRhdGFzZXQgcmFzdGVyIGNoZSBpZGVudGlmaWNhIGxlIGNlbGxlIG8gbGUgcG9zaXppb25pIGRhbGxlIHF1YWxpIHNpIGNhbGNvbGEgbGEgZGlzdGFuemEgZGkgY29zdG8gbWluaW1hIGN1bXVsYXRpdmEgcGVyIG9nbmkgcG9zaXppb25lIGRpIGNlbGxhIGRpIG91dHB1dC5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9zb3VyY2VyYXN0ZXJfdGFnMkBAXCI6IFwiUHXDsiBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBvIHVuIHZhbG9yZSBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3N1cmZhY2VyYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGNoZSBkZWZpbmlzY2UgaSB2YWxvcmkgZGkgZWxldmF6aW9uZSBzdSBvZ25pIHBvc2l6aW9uZSBkZWxsYSBjZWxsYS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9zdXJmYWNlcmFzdGVyX3RhZzFAQFwiOiBcIkkgdmFsb3JpIHZlbmdvbm8gdXRpbGl6emF0aSBwZXIgY2FsY29sYXJlIGzigJllZmZldHRpdmEgZGlzdGFuemEgZGVsbGEgc3VwZXJmaWNpZSBwZXJjb3JzYSBkdXJhbnRlIGlsIHBhc3NhZ2dpbyB0cmEgY2VsbGUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fdHJhdmVsZGlyZWN0aW9uX3RhZzBAQFwiOiBcIkRlZmluaXNjZSBsYSBkaXJlemlvbmUgZGVsIHZpYWdnaWF0b3JlIHF1YW5kbyBzaSBhcHBsaWNhIGlsIGZhdHRvcmUgdmVydGljYWxlLCBpbCBmYXR0b3JlIG9yaXp6b250YWxlIGUgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSBkZWxsJ29yaWdpbmUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fdHJhdmVsZGlyZWN0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+RGFsbCdvcmlnaW5lPC9zdHJvbmc+OiBpbCBmYXR0b3JlIHZlcnRpY2FsZSwgaWwgZmF0dG9yZSBvcml6em9udGFsZSBlIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEgZGVsbCdvcmlnaW5lIHNhcmFubm8gYXBwbGljYXRpIGEgcGFydGlyZSBkYWxsJ29yaWdpbmUgZGkgaW5wdXQgZSBzcG9zdGFuZG9zaSB2ZXJzbyBsZSBjZWxsZSBkaSBub24tb3JpZ2luZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3RyYXZlbGRpcmVjdGlvbl90YWcyQEBcIjogXCI8c3Ryb25nPlZlcnNvIGwnb3JpZ2luZTwvc3Ryb25nPjogaWwgZmF0dG9yZSB2ZXJ0aWNhbGUsIGlsIGZhdHRvcmUgb3JpenpvbnRhbGUgZSBpbCB0YXNzbyBkaSByZXNpc3RlbnphIGRlbGwnb3JpZ2luZSBzYXJhbm5vIGFwcGxpY2F0aSBhIHBhcnRpcmUgZGEgY2lhc2N1bmEgY2VsbGEgZGkgbm9uLW9yaWdpbmUgZSB0b3JuYW5kbyBpbmRpZXRybyBhbGwnb3JpZ2luZSBkaSBpbnB1dC5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl90cmF2ZWxkaXJlY3Rpb25fdGFnM0BAXCI6IFwiU3BlY2lmaWNhcmUgbGEgcGFyb2xhIGNoaWF2ZSA8c3Ryb25nPkRhbGwnb3JpZ2luZTwvc3Ryb25nPiBvIDxzdHJvbmc+VmVyc28gbCdvcmlnaW5lPC9zdHJvbmc+LCBjaGUgc2Fyw6AgYXBwbGljYXRhIGEgdHV0dGUgbGUgb3JpZ2luaSwgb3BwdXJlIHNwZWNpZmljYXJlIHVuIGNhbXBvIG5lbCA8c3Ryb25nPlJhc3RlciBkaSBvcmlnaW5lPC9zdHJvbmc+IGNoZSBjb250aWVuZSBsZSBwYXJvbGUgY2hpYXZlIHBlciBpZGVudGlmaWNhcmUgbGEgZGlyZXppb25lIGRpIHZpYWdnaW8gcGVyIG9nbmkgb3JpZ2luZS4gUXVlbCBjYW1wbyBkZXZlIGNvbnRlbmVyZSBsYSBzdHJpbmdhICR7RlJPTV9TT1VSQ0V9IG8gJHtUT19TT1VSQ0V9LlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3ZlcnRpY2FsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkRlZmluaXNjZSBsYSByZWxhemlvbmUgdHJhIGlsIGZhdHRvcmUgZGkgY29zdG8gdmVydGljYWxlIGUgbCdhbmdvbG8gbW9iaWxlIHJlbGF0aXZvIHZlcnRpY2FsZSAoVlJNQSkuPC9wPjxwPkNpIHNvbm8gZGl2ZXJzaSBmYXR0b3JpIGNvbiBtb2RpZmljYXRvcmkgY2hlIGlkZW50aWZpY2FubyB1biBncmFmaWNvIGRpIGZhdHRvcmUgdmVydGljYWxlIGRlZmluaXRvLiBJbm9sdHJlLCDDqCBwb3NzaWJpbGUgdXRpbGl6emFyZSB1bmEgdGFiZWxsYSBwZXIgY3JlYXJlIHVuIGdyYWZpY28gcGVyc29uYWxpenphdG8uIEkgZ3JhZmljaSBzb25vIHV0aWxpenphdGkgcGVyIGlkZW50aWZpY2FyZSBpbCBmYXR0b3JlIHZlcnRpY2FsZSB1dGlsaXp6YXRvIG5lbCBjYWxjb2xvIGRlbCBjb3N0byB0b3RhbGUgZGVsbG8gc3Bvc3RhbWVudG8gaW4gdW5hIGNlbGxhIHZpY2luYS48L3A+PHA+TmVsbGUgc3BpZWdhemlvbmkgY2hlIHNlZ3Vvbm8sIHZlbmdvbm8gdXRpbGl6emF0aSBkdWUgYWNyb25pbWk6IFZGIGUgVlJNQS4gVkYgc3RhbmRzIGZvciB2ZXJ0aWNhbCBmYWN0b3IsIHdoaWNoIGRlZmluZXMgdGhlIHZlcnRpY2FsIGRpZmZpY3VsdHkgZW5jb3VudGVyZWQgaW4gbW92aW5nIGZyb20gb25lIGNlbGwgdG8gdGhlIG5leHQuIFZSTUEgc3RhIHBlciBhbmdvbG8gbW9iaWxlIHJlbGF0aXZvIHZlcnRpY2FsZSwgY2hlIGlkZW50aWZpY2EgbCdhbmdvbG8gZGkgcGVuZGVuemEgdHJhIGxhIGNlbGxhIEZST00sIG8gZGkgZWxhYm9yYXppb25lLCBlIGxhIGNlbGxhIFRPLjwvcD48cD48c3Ryb25nPkkgZmF0dG9yaSB2ZXJ0aWNhbGk8L3N0cm9uZz4gaW5jbHVkb25vIGkgc2VndWVudGk6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5hcmlvPC9zdHJvbmc+LS0gU3BlY2lmaWNhIGNoZSBzZSBpbCBWUk1BIMOoIG1hZ2dpb3JlIGRlbGwnYW5nb2xvIGRpIHRhZ2xpbyBiYXNzbyBlIG1pbm9yZSBkZWxsJ2FuZ29sbyBkaSB0YWdsaW8gYWx0bywgaWwgVkYgw6ggaW1wb3N0YXRvIGFsIHZhbG9yZSBhc3NvY2lhdG8gYWwgZmF0dG9yZSB6ZXJvOyBhbHRyaW1lbnRpLCDDqCBpbmZpbml0by48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4gLSBJbmRpY2EgY2hlIGxhIFZGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGRlbGxhIFZSTUEuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIHNpbW1ldHJpY2E8L3N0cm9uZz4tLSBTcGVjaWZpY2EgY2hlIGxhIFZGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGRlbGxhIFZSTUEgbmVsIGxhdG8gbmVnYXRpdm8gbyBwb3NpdGl2byBkZWxsYSBWUk1BLCByaXNwZXR0aXZhbWVudGUsIGUgbGUgZHVlIGZ1bnppb25pIGxpbmVhcmkgc29ubyBzaW1tZXRyaWNoZSByaXNwZXR0byBhbGwnYXNzZSBWRiAoeSkuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIGludmVyc2E8L3N0cm9uZz4gLSBJbmRpY2EgY2hlIGxhIFZGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGludmVyc2EgZGVsIFZSTUEuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIGludmVyc2Egc2ltbWV0cmljYTwvc3Ryb25nPi0tIEluZGljYSBjaGUgbGEgVkYgw6ggdW5hIGZ1bnppb25lIGxpbmVhcmUgaW52ZXJzYSBkZWwgVlJNQSBuZWwgbGF0byBuZWdhdGl2byBvIHBvc2l0aXZvIGRlbCBWUk1BLCByaXNwZXR0aXZhbWVudGUsIGUgbGUgZHVlIGZ1bnppb25pIGxpbmVhcmkgc29ubyBzaW1tZXRyaWNoZSByaXNwZXR0byBhbGwnYXNzZSBWRiAoeSkuPC9saT48bGk+PHN0cm9uZz5Db3M8L3N0cm9uZz4tLUlkZW50aWZpY2EgbGEgVkYgY29tZSBmdW56aW9uZSBiYXNhdGEgc3VsIGNvc2VubyBkZWwgVlJNQS48L2xpPjxsaT48c3Ryb25nPlNlYzwvc3Ryb25nPi0tSWRlbnRpZmljYSBsYSBWRiBjb21lIGZ1bnppb25lIGJhc2F0YSBzdWxsYSBzZWNhbnRlIGRlbCBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+Q29zLVNlYzwvc3Ryb25nPi0tU3BlY2lmaWNhIGNoZSBsYSBWRiDDqCBsYSBmdW56aW9uZSBiYXNhdGEgc3VsIGNvc2VubyBkZWwgVlJNQSBxdWFuZG8gaWwgVlJNQSDDqCBuZWdhdGl2byBlIGxhIGZ1bnppb25lIGJhc2F0YSBzdWxsYSBzZWNhbnRlIGRlbCBWUk1BIHF1YW5kbyBpbCBWUk1BIG5vbiDDqCBuZWdhdGl2by48L2xpPjxsaT48c3Ryb25nPlNlYy1Db3M8L3N0cm9uZz4tLVNwZWNpZmljYSBjaGUgbGEgVkYgw6ggbGEgZnVuemlvbmUgYmFzYXRhIHN1bGxhIHNlY2FudGUgZGVsIFZSTUEgcXVhbmRvIGlsIFZSTUEgw6ggbmVnYXRpdm8gZSBsYSBmdW56aW9uZSBiYXNhdGEgc3VsIGNvc2VubyBkZWwgVlJNQSBxdWFuZG8gaWwgVlJNQSBub24gw6ggbmVnYXRpdm8uIDwvbGk+PGxpPjxzdHJvbmc+VGFiZWxsYTwvc3Ryb25nPi0tSWRlbnRpZmljYSBjaGUgdmVycsOgIHV0aWxpenphdG8gdW4gZmlsZSB0YWJlbGxhIHBlciBkZWZpbmlyZSBpbCBncmFmaWNvIGRlbCBmYXR0b3JlIHZlcnRpY2FsZSBjaGUgdmllbmUgdXRpbGl6emF0byBwZXIgZGV0ZXJtaW5hcmUgbGUgVkYuPC9saT48L3VsPjxwPkkgbW9kaWZpY2F0b3JpIGRlbGxlIHBhcm9sZSBjaGlhdmUgdmVydGljYWxpIGluY2x1ZG9ubyBxdWFudG8gc2VndWU6IDwvcD48dWw+PGxpPjxzdHJvbmc+RmF0dG9yZSB6ZXJvPC9zdHJvbmc+LS0gU3RhYmlsaXNjZSBpbCBmYXR0b3JlIHZlcnRpY2FsZSB1c2F0byBxdWFuZG8gaWwgVlJNQSDDqCB6ZXJvLiBRdWVzdG8gZmF0dG9yZSBwb3NpemlvbmEgbOKAmWludGVyY2V0dGF6aW9uZSB5IGRlbGxhIGZ1bnppb25lIHNwZWNpZmljYXRhLiBQZXIgZGVmaW5pemlvbmUsIGlsIGZhdHRvcmUgemVybyBub24gw6ggYXBwbGljYWJpbGUgYWQgYWxjdW5hIGZ1bnppb25lIHZlcnRpY2FsZSB0cmlnb25vbWV0cmljYSAoQ09TLCBTRUMsIENPUy1TRUMgbyBTRUMtQ09TKS4gTCdpbnRlcmNldHRhIHkgw6ggZGVmaW5pdGEgZGEgcXVlc3RlIGZ1bnppb25pLjwvbGk+PGxpPjxzdHJvbmc+QW5nb2xvIGRpIHRhZ2xpbyBiYXNzbyA8L3N0cm9uZz4tIERlZmluaXNjZSBsJ2FuZ29sbyBWUk1BIGFsIGRpIHNvdHRvIGRlbCBxdWFsZSBsYSBWRiBzYXLDoCBpbXBvc3RhdGEgc3UgaW5maW5pdG8uPC9saT48bGk+PHN0cm9uZz5BbmdvbG8gZGkgdGFnbGlvIGFsdG88L3N0cm9uZz4gLSBEZWZpbmlzY2UgbCdhbmdvbG8gVlJNQSBhbCBkaSBzb3ByYSBkZWwgcXVhbGUgbGEgVkYgc2Fyw6AgaW1wb3N0YXRhIHN1IGluZmluaXRvLiA8L2xpPjxsaT48c3Ryb25nPlBlbmRlbnphPC9zdHJvbmc+IC0gU3RhYmlsaXNjZSBsYSBwZW5kZW56YSBkZWxsYSBsaW5lYSByZXR0YSB1c2F0YSBjb24gbGUgcGFyb2xlIGNoaWF2ZSA8c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4gZSA8c3Ryb25nPkxpbmVhcmUgSW52ZXJzYTwvc3Ryb25nPi1mYXR0b3JlIHZlcnRpY2FsZS4gTGEgcGVuZGVuemEgw6ggc3BlY2lmaWNhdGEgY29tZSB1bmEgZnJhemlvbmUgZGkgc2FsaXRhIHN1IGNvcnNhIChwZXIgZXNlbXBpbywgbGEgcGVuZGVuemEgZGVsIDQ1IHBlciBjZW50byDDqCAxLzQ1LCBjaGUgdmllbmUgaW1tZXNzYSBjb21lIDAsMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+Tm9tZSB0YWJlbGxhPC9zdHJvbmc+LS08L2xpPklkZW50aWZpY2EgaWwgbm9tZSBkZWxsYSB0YWJlbGxhIGNoZSBkZWZpbmlzY2UgbGEgVkYuPC91bD5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl92ZXJ0aWNhbHJhc3Rlcl90YWcwQEBcIjogXCJEZWZpbmlzY2UgbGEgcmVsYXppb25lIHRyYSBpbCBmYXR0b3JlIGRpIGNvc3RvIHZlcnRpY2FsZSBlIGwnYW5nb2xvIGRpIG1vdmltZW50byByZWxhdGl2byB2ZXJ0aWNhbGUgKFZSTUEpLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3ZlcnRpY2FscmFzdGVyX3RhZzFAQFwiOiBcIkkgdmFsb3JpIHZlbmdvbm8gdXRpbGl6emF0aSBwZXIgY2FsY29sYXJlIGxhIHBlbmRlbnphIHVzYXRhIHBlciBpZGVudGlmaWNhcmUgaWwgZmF0dG9yZSB2ZXJ0aWNhbGUgcXVhbmRvIHNpIHBhc3NhIGRhIHVuYSBjZWxsYSBhbGwnYWx0cmEuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2Nvc3RyYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGNoZSBkZWZpbmlzY2UgaWwgY29zdG8gbyBsJ2ltcGVkZW56YSBkZWxsbyBzcG9zdGFtZW50byBwbGFuaW1ldHJpY28gYXR0cmF2ZXJzbyBjaWFzY3VuYSBjZWxsYS4gSWwgdmFsb3JlIGEgb2duaSBwb3NpemlvbmUgZGVsbGEgY2VsbGEgcmFwcHJlc2VudGEgbGEgZGlzdGFuemEgZGkgY29zdG8gcGVyIHVuaXTDoCBwZXIgbCdhdHRyYXZlcnNhbWVudG8gZGVsbGEgc3Rlc3NhLiBPZ25pIHZhbG9yZSBkaSBwb3NpemlvbmUgZGkgdW5hIGNlbGxhIHZpZW5lIG1vbHRpcGxpY2F0byBwZXIgbGEgcmlzb2x1emlvbmUgZGVsbGEgY2VsbGEgZSBjb21wZW5zYSBpbm9sdHJlIGlsIG1vdmltZW50byBkaWFnb25hbGUgcGVyIG90dGVuZXJlIGlsIGNvc3RvIHRvdGFsZSBkZWxsJ2F0dHJhdmVyc2FtZW50byBkZWxsYSBzdGVzc2EuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2Nvc3RyYXN0ZXJfdGFnMUBAXCI6IFwiSSB2YWxvcmkgZGVsIDxzdHJvbmc+UmFzdGVyIGRpIGNvc3RvPC9zdHJvbmc+IHBvc3Nvbm8gZXNzZXJlIGEgbnVtZXJvIGludGVybyBvIGEgdmlyZ29sYSBtb2JpbGUsIG1hIG5vbiBwb3Nzb25vIGVzc2VyZSBuZWdhdGl2aSBvIHplcm8uXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzBAQFwiOiBcIkRldGVybWluYSBzZSBjYWxjb2xhcmUgbGEgZGlzdGFuemEgY29uIHVuIG1ldG9kbyBwbGFuYXJlICh0ZXJyYSBwaWF0dGEpIG8gZ2VvZGV0aWNvIChlbGxpc3NvaWRlKS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fZGlzdGFuY2VtZXRob2RfdGFnMUBAXCI6IFwiUGxhbmFyZTogbGEgbWlzdXJhemlvbmUgcGxhbmFyZSB1dGlsaXp6YSBsYSBtYXRlbWF0aWNhIGNhcnRlc2lhbmEgMkQgcGVyIGNhbGNvbGFyZSBhcmVhIGUgbHVuZ2hlenphLiBRdWVzdGEgb3B6aW9uZSDDqCBkaXNwb25pYmlsZSBzb2xvIHF1YW5kbyBzaSBtaXN1cmEgaW4gdW4gc2lzdGVtYSBkaSBjb29yZGluYXRlIHByb2lldHRhdG8gZSBpbCBwaWFubyAyRCBkaSB0YWxlIHNpc3RlbWEgZGkgY29vcmRpbmF0ZSB2aWVuZSB1dGlsaXp6YXRvIGNvbWUgYmFzZSBwZXIgbGUgbWlzdXJhemlvbmkuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzJAQFwiOiBcIkdlb2RldGljYTogbGEgbGluZWEgcGnDuSBicmV2ZSB0cmEgZHVlIHB1bnRpIHN1bGxhIHN1cGVyZmljaWUgdGVycmVzdHJlIHN1IHVubyBzZmVyb2lkZSAoZWxsaXNzb2lkZSkuIFBlcnRhbnRvLCBpbmRpcGVuZGVudGVtZW50ZSBkYWxsYSBwcm9pZXppb25lIGRpIGlucHV0IG8gb3V0cHV0LCBpIHJpc3VsdGF0aSBub24gY2FtYmlhbm8uXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzNAQFwiOiBcIjxzdHJvbmc+Tm90YTwvc3Ryb25nPjogbGEgbGluZWEgZ2VvZGV0aWNhIHB1w7IgZXNzZXJlIHVzYXRhIHNlIHNpIGRlc2lkZXJhIGRldGVybWluYXJlIGxhIGRpc3RhbnphIHBpw7kgYnJldmUgdHJhIGR1ZSBjaXR0w6AgcGVyIGxhIHRyYWlldHRvcmlhIGRpIHVuIGFlcmVvLiBRdWVzdG8gbWV0b2RvIMOoIGNvbm9zY2l1dG8gYW5jaGUgY29tZSBsaW5lYSBkZWwgY2VyY2hpbyBtYXNzaW1vIHNlIGJhc2F0byBzdSB1bmEgc2ZlcmEgcGl1dHRvc3RvIGNoZSBzdSB1biBlbGxpc3NvaWRlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9ob3Jpem9udGFsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkRlZmluaXNjZSBsYSByZWxhemlvbmUgdHJhIGlsIGZhdHRvcmUgZGkgY29zdG8gb3JpenpvbnRhbGUgZSBsJ2FuZ29sbyBtb2JpbGUgcmVsYXRpdm8gb3JpenpvbnRhbGUgKEhSTUEpLjwvcD48cD5DaSBzb25vIGRpdmVyc2kgZmF0dG9yaSBjb24gbW9kaWZpY2F0b3JpIGNoZSBpZGVudGlmaWNhbm8gdW4gZ3JhZmljbyBkZWwgZmF0dG9yZSB2ZXJ0aWNhbGUgZGVmaW5pdG8uIElub2x0cmUsIMOoIHBvc3NpYmlsZSB1dGlsaXp6YXJlIHVuYSB0YWJlbGxhIHBlciBjcmVhcmUgdW4gZ3JhZmljbyBwZXJzb25hbGl6emF0by4gSSBncmFmaWNpIHNvbm8gdXRpbGl6emF0aSBwZXIgaWRlbnRpZmljYXJlIGlsIGZhdHRvcmUgdmVydGljYWxlIHV0aWxpenphdG8gbmVsIGNhbGNvbG8gZGVsIGNvc3RvIHRvdGFsZSBkZWxsbyBzcG9zdGFtZW50byBpbiB1bmEgY2VsbGEgdmljaW5hLjwvcD48cD5OZWxsZSBzcGllZ2F6aW9uaSBjaGUgc2VndW9ubywgdmVuZ29ubyB1dGlsaXp6YXRpIGR1ZSBhY3JvbmltaTogSEYgZSBIUk1BLiBIRiBzdGFuZHMgZm9yIGhvcml6b250YWwgZmFjdG9yLCB3aGljaCBkZWZpbmVzIHRoZSBob3Jpem9udGFsIGRpZmZpY3VsdHkgZW5jb3VudGVyZWQgd2hlbiBtb3ZpbmcgZnJvbSBvbmUgY2VsbCB0byB0aGUgbmV4dC4gSFJNQSBzdGEgcGVyIGhvcml6b250YWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlLCBjaGUgaWRlbnRpZmljYSBsJ2FuZ29sbyB0cmEgbGEgZGlyZXppb25lIG9yaXp6b250YWxlIGRhIHVuYSBjZWxsYSBlIGxhIGRpcmV6aW9uZSBkaSBtb3ZpbWVudG8uIEkgdGlwaSBkaSA8L3A+PHA+PHN0cm9uZz5mYXR0b3JpIG9yaXp6b250YWxpPC9zdHJvbmc+IGluY2x1ZG9ubyBpIHNlZ3VlbnRpOiA8L3A+PHVsPjxsaT48c3Ryb25nPkJpbmFyaW88L3N0cm9uZz4tLSBJbmRpY2EgY2hlIHNlIGwnSFJNQSDDqCBpbmZlcmlvcmUgYWxsJ2FuZ29sbyBkaSB0YWdsaW8sIGwnSEYgw6ggaW1wb3N0YXRvIGFsIHZhbG9yZSBhc3NvY2lhdG8gYWwgZmF0dG9yZSB6ZXJvOyBhbHRyaW1lbnRpLCDDqCBpbmZpbml0by48L2xpPjxsaT48c3Ryb25nPkF2YW50aTwvc3Ryb25nPiAtLSBTdGFiaWxpc2NlIGNoZSDDqCBwZXJtZXNzbyBzb2xvIGlsIG1vdmltZW50byBpbiBhdmFudGkuIEwnSFJNQSBkZXZlIGVzc2VyZSBtYWdnaW9yZSBvIHVndWFsZSBhIDAgZSBpbmZlcmlvcmUgYSA5MCBncmFkaSAoMCAmbHQ7PSBIUk1BICZsdDs5MCkuIFNlIGwnSFJNQSDDqCBzdXBlcmlvcmUgYSAwIGUgaW5mZXJpb3JlIGEgNDUgZ3JhZGksIGwnSEYgcGVyIGxhIGNlbGxhIHZpZW5lIGltcG9zdGF0byBzdWwgdmFsb3JlIGFzc29jaWF0byBhbCBmYXR0b3JlIHplcm8uIFNlIGwnSFJNQSDDqCBzdXBlcmlvcmUgbyBwYXJpIGEgNDUgZ3JhZGksIHZpZW5lIHV0aWxpenphdG8gaWwgdmFsb3JlIGRlbCBtb2RpZmljYXRvcmUgZGVsIHZhbG9yZSBsYXRlcmFsZS4gTCdIRiBwZXIgcXVhbHNpYXNpIHZhbG9yZSBIUk1BIHVndWFsZSBvIHN1cGVyaW9yZSBhIDkwIGdyYWRpIMOoIGltcG9zdGF0byBzdSBpbmZpbml0by48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4tLVNwZWNpZmljYSBjaGUgbCdIRiDDqCB1bmEgZnVuemlvbmUgbGluZWFyZSBkZWxsJ0hSTUEuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlIGludmVyc2E8L3N0cm9uZz4tLVNwZWNpZmljYSBjaGUgbCdIRiDDqCB1bmEgZnVuemlvbmUgbGluZWFyZSBpbnZlcnNhIGRlbGwnSFJNQS48L2xpPjxsaT48c3Ryb25nPlRhYmVsbGE8L3N0cm9uZz4tIElkZW50aWZpY2EgY2hlIHVuIGZpbGUgdGFiZWxsYSBzYXLDoCB1c2F0byBwZXIgZGVmaW5pcmUgaWwgZ3JhZmljbyBkZWkgZmF0dG9yaSBvcml6em9udGFsaSB1c2F0byBwZXIgZGV0ZXJtaW5hcmUgZ2xpIEhGLjwvbGk+PC91bD48cD5JIG1vZGlmaWNhdG9yaSBkZWkgZmF0dG9yaSBvcml6em9udGFsaSBpbmNsdWRvbm8gcXVhbnRvIHNlZ3VlOiA8L3A+PHVsPjxsaT48c3Ryb25nPkZhdHRvcmUgemVybzwvc3Ryb25nPi0tIElsIGZhdHRvcmUgb3JpenpvbnRhbGUgZGEgdXNhcmUgcXVhbmRvIGwnSFJNQSDDqCB6ZXJvLiBRdWVzdG8gZmF0dG9yZSBwb3NpemlvbmEgbCdpbnRlcmNldHRhIHkgcGVyIHF1YWxzaWFzaSBmdW56aW9uZSBmYXR0b3JlIG9yaXp6b250YWxlLjwvbGk+PGxpPjxzdHJvbmc+QW5nb2xvIGRpIHRhZ2xpbzwvc3Ryb25nPi0tRGVmaW5pc2NlIGwnYW5nb2xvIEhSTUEgb2x0cmUgaWwgcXVhbGUgbCdIRiBzYXLDoCBpbXBvc3RhdG8gc3UgaW5maW5pdG8uPC9saT48bGk+PHN0cm9uZz5QZW5kZW56YTwvc3Ryb25nPi0tIFN0YWJpbGlzY2UgbGEgcGVuZGVuemEgZGVsbGEgbGluZWEgcmV0dGEgdXNhdGEgY29uIGxlIHBhcm9sZSBjaGlhdmUgZmF0dG9yZSBvcml6em9udGFsZSA8c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4gZSA8c3Ryb25nPkxpbmVhcmUgaW52ZXJzYTwvc3Ryb25nPi4gTGEgcGVuZGVuemEgw6ggc3BlY2lmaWNhdGEgY29tZSB1bmEgZnJhemlvbmUgZGkgc2FsaXRhIHN1IGNvcnNhIChwZXIgZXNlbXBpbywgbGEgcGVuZGVuemEgZGVsIDQ1JSDDqCAxLzQ1LCBjaGUgdmllbmUgaW1tZXNzYSBjb21lIDAsMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+U2lkZSB2YWx1ZTwvc3Ryb25nPi0tIFN0YWJpbGlzY2UgbCdIRiBxdWFuZG8gbCdIUk1BIMOoIG1hZ2dpb3JlIG8gdWd1YWxlIGEgNDUgZ3JhZGkgZSBtaW5vcmUgZGkgOTAgZ3JhZGkgcXVhbmRvIHZpZW5lIHNwZWNpZmljYXRhIGxhIHBhcm9sYSBjaGlhdmUgRmF0dG9yZSBvcml6em9udGFsZSA8c3Ryb25nPmF2YW50aTwvc3Ryb25nPi48L2xpPjxsaT48c3Ryb25nPk5vbWUgZGVsbGEgdGFiZWxsYTwvc3Ryb25nPiAtIElkZW50aWZpY2EgaWwgbm9tZSBkZWxsYSB0YWJlbGxhIGNoZSBkZWZpbmlzY2UgbCdIRi48L2xpPjwvdWw+XCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2hvcml6b250YWxyYXN0ZXJfdGFnMEBAXCI6IFwiVW4gcmFzdGVyIGNoZSBkZWZpbmlzY2UgbGEgZGlyZXppb25lIG9yaXp6b250YWxlIHN1IG9nbmkgY2VsbGEuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2hvcml6b250YWxyYXN0ZXJfdGFnMUBAXCI6IFwiSSB2YWxvcmkgc3VsIHJhc3RlciBkZXZvbm8gZXNzZXJlIG51bWVyaSBpbnRlcmkgY29tcHJlc2kgdHJhIDAgZSAzNjAgY29uIDAgZ3JhZGkgY2hlIGluZGljYSBpbCBub3JkIG8gdmVyc28gbGEgcGFydGUgc3VwZXJpb3JlIGRlbGxvIHNjaGVybW8gZSBjb24gYXVtZW50byBpbiBzZW5zbyBvcmFyaW8uIEFsbGUgYXJlZSBwaWFuZSBkZXZlIGVzc2VyZSBmb3JuaXRvIHVuIHZhbG9yZSBkaSAtMS4gSSB2YWxvcmkgaW4gb2duaSBwb3NpemlvbmUgdmVuZ29ubyB1dGlsaXp6YXRpIGluc2llbWUgYSA8c3Ryb25nPkZhdHRvcmUgb3JpenpvbnRhbGU8L3N0cm9uZz4gcGVyIGRldGVybWluYXJlIGkgY29zdGkgb3JpenpvbnRhbGkgZHVyYW50ZSBsbyBzcG9zdGFtZW50byBkYSB1bmEgY2VsbGEgYSBxdWVsbGUgdmljaW5lLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9pbml0aWFsYWNjdW11bGF0aW9uX3RhZzBAQFwiOiBcIklsIGNvc3RvIGN1bXVsYXRpdm8gaW5pemlhbGUgcGVyIGF2dmlhcmUgaWwgY2FsY29sbyBkZWwgY29zdG8uIFF1ZXN0byBwYXJhbWV0cm8gY29uc2VudGUgZGkgc3BlY2lmaWNhcmUgaWwgY29zdG8gZmlzc28gYXNzb2NpYXRvIGFkIHVuJ29yaWdpbmUuIEludmVjZSBkaSBpbml6aWFyZSBjb24gdW4gY29zdG8gMCwgbCdhbGdvcml0bW8gZGVsIGNvc3RvIGluaXppZXLDoCBjb24gaWwgdmFsb3JlIHNwZWNpZmljYXRvLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9pbml0aWFsYWNjdW11bGF0aW9uX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSBwZXIgcXVlc3RvIHBhcmFtZXRybyB1biB2YWxvcmUgbnVtZXJpY28gKGRvcHBpbykgbyB1biBjYW1wbyBkYWwgPHN0cm9uZz5SYXN0ZXIgb3JpZ2luZTwvc3Ryb25nPi5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25faW5pdGlhbGFjY3VtdWxhdGlvbl90YWcyQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgcGFyaSBvIHN1cGVyaW9yZSBhIHplcm8uIEwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhIMOoIDAuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX21heGltdW1hY2N1bXVsYXRpb25fdGFnMEBAXCI6IFwiRGVmaW5pc2NlIGlsIGNvc3RvIGN1bXVsYXRpdm8gbWFzc2ltbyBwZXIgaWwgdmlhZ2dpYXRvcmUgcmVsYXRpdm8gYSB1bidvcmlnaW5lLiBJIGNhbGNvbGkgZGVsIGNvc3RvIGNvbnRpbnVhbm8gcGVyIG9nbmkgb3JpZ2luZSBmaW5jaMOpIG5vbiBzaSByYWdnaXVuZ2UgbGEgY2FwYWNpdMOgIHNwZWNpZmljYXRhLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9tYXhpbXVtYWNjdW11bGF0aW9uX3RhZzFAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSBwZXIgcXVlc3RvIHBhcmFtZXRybyB1biB2YWxvcmUgbnVtZXJpY28gKGRvcHBpbykgbyB1biBjYW1wbyBkYWwgPHN0cm9uZz5SYXN0ZXIgb3JpZ2luZTwvc3Ryb25nPi5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fbWF4aW11bWFjY3VtdWxhdGlvbl90YWcyQEBcIjogXCJJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgZGkgemVyby4gTGEgY2FwYWNpdMOgIHByZWRlZmluaXRhIMOoIGZpbm8gYWwgYm9yZG8gZGVsIHJhc3RlciBkaSBvdXRwdXQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX211bHRpcGxpZXJ0b2FwcGx5dG9jb3N0c190YWcwQEBcIjogXCJVbiBtb2x0aXBsaWNhdG9yZSBkYSBhcHBsaWNhcmUgYWkgdmFsb3JpIGRpIGNvc3RvLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9tdWx0aXBsaWVydG9hcHBseXRvY29zdHNfdGFnMUBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyBjb25zZW50ZSBpbCBjb250cm9sbG8gZGVsbGEgbW9kYWxpdMOgIGRpIHNwb3N0YW1lbnRvIG8gZGVsbGEgZ3JhbmRlenphIGFsbCdvcmlnaW5lLiBNYWdnaW9yZSDDqCBpbCBtb2x0aXBsaWNhdG9yZSwgbWFnZ2lvcmUgw6ggaWwgY29zdG8gcGVyIGxvIHNwb3N0YW1lbnRvIGF0dHJhdmVyc28gb2duaSBjZWxsYS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzJAQFwiOiBcIkkgdmFsb3JpIGRldm9ubyBlc3NlcmUgbWFnZ2lvcmkgZGkgemVyby4gTCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEgw6ggMS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzNAQFwiOiBcIsOIIHBvc3NpYmlsZSB1c2FyZSBwZXIgcXVlc3RvIHBhcmFtZXRybyB1biB2YWxvcmUgbnVtZXJpY28gKGRvcHBpbykgbyB1biBjYW1wbyBkYWwgPHN0cm9uZz5SYXN0ZXIgb3JpZ2luZTwvc3Ryb25nPi5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fcmFzdGVyYmFycmllcnNfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGNoZSBkZWZpbmlzY2UgbGUgYmFycmllcmUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3Jhc3RlcmJhcnJpZXJzX3RhZzFAQFwiOiBcIklsIGRhdGFzZXQgZGV2ZSBjb250ZW5lcmUgTm9EYXRhIGxhZGRvdmUgbm9uIGNpIHNvbm8gYmFycmllcmUuIExlIGJhcnJpZXJlIHNvbm8gcmFwcHJlc2VudGF0ZSBkYSB2YWxvcmkgdmFsaWRpLCBpbmNsdXNvIGxvIHplcm8uXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3Jhc3RlcmJhcnJpZXJzX3RhZzJAQFwiOiBcIkxlIGJhcnJpZXJlIHBvc3Nvbm8gZXNzZXJlIGRlZmluaXRlIGRhIHVuIG51bWVybyBpbnRlcm8gbyBkYSB1biByYXN0ZXIgYSB2aXJnb2xhIG1vYmlsZS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fc291cmNlZmllbGRfdGFnMEBAXCI6IFwiSWwgY2FtcG8gdXNhdG8gcGVyIGFzc2VnbmFyZSB2YWxvcmkgYWxsZSBwb3NpemlvbmkgZGkgb3JpZ2luZS4gRGV2ZSBlc3NlcmUgZGkgdGlwbyBudW1lcm8gaW50ZXJvLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zb3VyY2VyYXN0ZXJfdGFnMEBAXCI6IFwiUG9zaXppb25pIGRlbGzigJlvcmlnaW5lIGRpIGlucHV0LlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zb3VyY2VyYXN0ZXJfdGFnMUBAXCI6IFwiw4ggdW4gZGF0YXNldCByYXN0ZXIgY2hlIGlkZW50aWZpY2EgbGUgY2VsbGUgbyBsZSBwb3NpemlvbmkgZGFsbGUgcXVhbGkgc2kgY2FsY29sYSBsYSBkaXN0YW56YSBkaSBjb3N0byBtaW5pbWEgY3VtdWxhdGl2YSBwZXIgb2duaSBwb3NpemlvbmUgZGkgY2VsbGEgZGkgb3V0cHV0LlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zb3VyY2Vyb3dhbmRjb2x1bW5iYW5kc190YWcwQEBcIjogXCJTdGFiaWxpc2NlIHNlIHNpIGNyZWEgc29sbyBpbCByYXN0ZXIgZGkgYWxsb2NhemlvbmUgbyB1biByYXN0ZXIgbXVsdGliYW5kYS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fc291cmNlcm93YW5kY29sdW1uYmFuZHNfdGFnMUBAXCI6IFwiTm9uIHNlbGV6aW9uYXRvOiBpbCByaXN1bHRhdG8gw6ggaWwgcmFzdGVyIGRpIGFsbG9jYXppb25lIGRlbGxhIGRpc3RhbnphLiBTaSB0cmF0dGEgZGkgdW4gcmlzdWx0YXRvIGEgYmFuZGEgc2luZ29sYS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zb3VyY2Vyb3dhbmRjb2x1bW5iYW5kc190YWcyQEBcIjogXCJTZWxlemlvbmF0bzogc2kgY3JlYSB1biByYXN0ZXIgbXVsdGliYW5kYS4gTGEgcHJpbWEgYmFuZGEgw6ggaWwgcmFzdGVyIGRpIGFsbG9jYXppb25lIGRlbGxhIGRpc3RhbnphLCBsYSBzZWNvbmRhIGJhbmRhIGNvbnRpZW5lIHVuIGluZGljZSBkaSByaWdhIGUgbGEgdGVyemEgYmFuZGEgY29udGllbmUgdW4gaW5kaWNlIGRpIGNvbG9ubmEuIFF1ZXN0aSBpbmRpY2kgaWRlbnRpZmljYW5vIGxhIHBvc2l6aW9uZSBkZWxsYSBjZWxsYSBkaSBvcmlnaW5lIGNoZSBzaSB0cm92YSBhbGxhIG1pbm9yZSBkaXN0YW56YSBkaSBjb3N0byBjdW11bGF0aXZhLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zdXJmYWNlcmFzdGVyX3RhZzBAQFwiOiBcIlVuIHJhc3RlciBjaGUgZGVmaW5pc2NlIGkgdmFsb3JpIGRpIGVsZXZhemlvbmUgc3Ugb2duaSBwb3NpemlvbmUgZGVsbGEgY2VsbGEuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3N1cmZhY2VyYXN0ZXJfdGFnMUBAXCI6IFwiSSB2YWxvcmkgdmVuZ29ubyB1dGlsaXp6YXRpIHBlciBjYWxjb2xhcmUgbOKAmWVmZmV0dGl2YSBkaXN0YW56YSBkZWxsYSBzdXBlcmZpY2llIHBlcmNvcnNhIGR1cmFudGUgaWwgcGFzc2FnZ2lvIHRyYSBjZWxsZS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fdHJhdmVsZGlyZWN0aW9uX3RhZzBAQFwiOiBcIkRlZmluaXNjZSBsYSBkaXJlemlvbmUgZGVsIHZpYWdnaWF0b3JlIHF1YW5kbyBzaSBhcHBsaWNhIGlsIGZhdHRvcmUgdmVydGljYWxlLCBpbCBmYXR0b3JlIG9yaXp6b250YWxlIGUgaWwgdGFzc28gZGkgcmVzaXN0ZW56YSBkZWxsJ29yaWdpbmUuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3RyYXZlbGRpcmVjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPkRhbGwnb3JpZ2luZTwvc3Ryb25nPjogaWwgZmF0dG9yZSB2ZXJ0aWNhbGUsIGlsIGZhdHRvcmUgb3JpenpvbnRhbGUgZSBpbCB0YXNzbyBkaSByZXNpc3RlbnphIGRlbGwnb3JpZ2luZSBzYXJhbm5vIGFwcGxpY2F0aSBhIHBhcnRpcmUgZGFsbCdvcmlnaW5lIGRpIGlucHV0IGUgc3Bvc3RhbmRvc2kgdmVyc28gbGUgY2VsbGUgZGkgbm9uLW9yaWdpbmUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fdHJhdmVsZGlyZWN0aW9uX3RhZzJAQFwiOiBcIjxzdHJvbmc+VmVyc28gbCdvcmlnaW5lPC9zdHJvbmc+OiBpbCBmYXR0b3JlIHZlcnRpY2FsZSwgaWwgZmF0dG9yZSBvcml6em9udGFsZSBlIGlsIHRhc3NvIGRpIHJlc2lzdGVuemEgZGVsbCdvcmlnaW5lIHNhcmFubm8gYXBwbGljYXRpIGEgcGFydGlyZSBkYSBjaWFzY3VuYSBjZWxsYSBkaSBub24tb3JpZ2luZSBlIHRvcm5hbmRvIGluZGlldHJvIGFsbCdvcmlnaW5lIGRpIGlucHV0LlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl90cmF2ZWxkaXJlY3Rpb25fdGFnM0BAXCI6IFwiU3BlY2lmaWNhcmUgbGEgcGFyb2xhIGNoaWF2ZSA8c3Ryb25nPkRhbGwnb3JpZ2luZTwvc3Ryb25nPiBvIDxzdHJvbmc+VmVyc28gbCdvcmlnaW5lPC9zdHJvbmc+LCBjaGUgc2Fyw6AgYXBwbGljYXRhIGEgdHV0dGUgbGUgb3JpZ2luaSwgb3BwdXJlIHNwZWNpZmljYXJlIHVuIGNhbXBvIG5lbCA8c3Ryb25nPlJhc3RlciBkaSBvcmlnaW5lPC9zdHJvbmc+IGNoZSBjb250aWVuZSBsZSBwYXJvbGUgY2hpYXZlIHBlciBpZGVudGlmaWNhcmUgbGEgZGlyZXppb25lIGRpIHZpYWdnaW8gcGVyIG9nbmkgb3JpZ2luZS4gUXVlbCBjYW1wbyBkZXZlIGNvbnRlbmVyZSBsYSBzdHJpbmdhICR7RlJPTV9TT1VSQ0V9IG8gJHtUT19TT1VSQ0V9LlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl92ZXJ0aWNhbGZhY3Rvcl90YWcwQEBcIjogXCI8cD5EZWZpbmlzY2UgbGEgcmVsYXppb25lIHRyYSBpbCBmYXR0b3JlIGRpIGNvc3RvIHZlcnRpY2FsZSBlIGwnYW5nb2xvIG1vYmlsZSByZWxhdGl2byB2ZXJ0aWNhbGUgKFZSTUEpLjwvcD48cD5DaSBzb25vIGRpdmVyc2kgZmF0dG9yaSBjb24gbW9kaWZpY2F0b3JpIGNoZSBpZGVudGlmaWNhbm8gdW4gZ3JhZmljbyBkaSBmYXR0b3JlIHZlcnRpY2FsZSBkZWZpbml0by4gSW5vbHRyZSwgw6ggcG9zc2liaWxlIHV0aWxpenphcmUgdW5hIHRhYmVsbGEgcGVyIGNyZWFyZSB1biBncmFmaWNvIHBlcnNvbmFsaXp6YXRvLiBJIGdyYWZpY2kgc29ubyB1dGlsaXp6YXRpIHBlciBpZGVudGlmaWNhcmUgaWwgZmF0dG9yZSB2ZXJ0aWNhbGUgdXRpbGl6emF0byBuZWwgY2FsY29sbyBkZWwgY29zdG8gdG90YWxlIGRlbGxvIHNwb3N0YW1lbnRvIGluIHVuYSBjZWxsYSB2aWNpbmEuPC9wPjxwPk5lbGxlIHNwaWVnYXppb25pIGNoZSBzZWd1b25vLCB2ZW5nb25vIHV0aWxpenphdGkgZHVlIGFjcm9uaW1pOiBWRiBlIFZSTUEuIFZGIHN0YW5kcyBmb3IgdmVydGljYWwgZmFjdG9yLCB3aGljaCBkZWZpbmVzIHRoZSB2ZXJ0aWNhbCBkaWZmaWN1bHR5IGVuY291bnRlcmVkIGluIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIHRoZSBuZXh0LiBWUk1BIHN0YSBwZXIgYW5nb2xvIG1vYmlsZSByZWxhdGl2byB2ZXJ0aWNhbGUsIGNoZSBpZGVudGlmaWNhIGwnYW5nb2xvIGRpIHBlbmRlbnphIHRyYSBsYSBjZWxsYSBGUk9NLCBvIGRpIGVsYWJvcmF6aW9uZSwgZSBsYSBjZWxsYSBUTy48L3A+PHA+PHN0cm9uZz5JIGZhdHRvcmkgdmVydGljYWxpPC9zdHJvbmc+IGluY2x1ZG9ubyBpIHNlZ3VlbnRpOjwvcD48dWw+PGxpPjxzdHJvbmc+QmluYXJpbzwvc3Ryb25nPi0tIFNwZWNpZmljYSBjaGUgc2UgaWwgVlJNQSDDqCBtYWdnaW9yZSBkZWxsJ2FuZ29sbyBkaSB0YWdsaW8gYmFzc28gZSBtaW5vcmUgZGVsbCdhbmdvbG8gZGkgdGFnbGlvIGFsdG8sIGlsIFZGIMOoIGltcG9zdGF0byBhbCB2YWxvcmUgYXNzb2NpYXRvIGFsIGZhdHRvcmUgemVybzsgYWx0cmltZW50aSwgw6ggaW5maW5pdG8uPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlPC9zdHJvbmc+IC0gSW5kaWNhIGNoZSBsYSBWRiDDqCB1bmEgZnVuemlvbmUgbGluZWFyZSBkZWxsYSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyZSBzaW1tZXRyaWNhPC9zdHJvbmc+LS0gU3BlY2lmaWNhIGNoZSBsYSBWRiDDqCB1bmEgZnVuemlvbmUgbGluZWFyZSBkZWxsYSBWUk1BIG5lbCBsYXRvIG5lZ2F0aXZvIG8gcG9zaXRpdm8gZGVsbGEgVlJNQSwgcmlzcGV0dGl2YW1lbnRlLCBlIGxlIGR1ZSBmdW56aW9uaSBsaW5lYXJpIHNvbm8gc2ltbWV0cmljaGUgcmlzcGV0dG8gYWxsJ2Fzc2UgVkYgKHkpLjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyZSBpbnZlcnNhPC9zdHJvbmc+IC0gSW5kaWNhIGNoZSBsYSBWRiDDqCB1bmEgZnVuemlvbmUgbGluZWFyZSBpbnZlcnNhIGRlbCBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyZSBpbnZlcnNhIHNpbW1ldHJpY2E8L3N0cm9uZz4tLSBJbmRpY2EgY2hlIGxhIFZGIMOoIHVuYSBmdW56aW9uZSBsaW5lYXJlIGludmVyc2EgZGVsIFZSTUEgbmVsIGxhdG8gbmVnYXRpdm8gbyBwb3NpdGl2byBkZWwgVlJNQSwgcmlzcGV0dGl2YW1lbnRlLCBlIGxlIGR1ZSBmdW56aW9uaSBsaW5lYXJpIHNvbm8gc2ltbWV0cmljaGUgcmlzcGV0dG8gYWxsJ2Fzc2UgVkYgKHkpLjwvbGk+PGxpPjxzdHJvbmc+Q29zPC9zdHJvbmc+LS1JZGVudGlmaWNhIGxhIFZGIGNvbWUgZnVuemlvbmUgYmFzYXRhIHN1bCBjb3Nlbm8gZGVsIFZSTUEuPC9saT48bGk+PHN0cm9uZz5TZWM8L3N0cm9uZz4tLUlkZW50aWZpY2EgbGEgVkYgY29tZSBmdW56aW9uZSBiYXNhdGEgc3VsbGEgc2VjYW50ZSBkZWwgVlJNQS48L2xpPjxsaT48c3Ryb25nPkNvcy1TZWM8L3N0cm9uZz4tLVNwZWNpZmljYSBjaGUgbGEgVkYgw6ggbGEgZnVuemlvbmUgYmFzYXRhIHN1bCBjb3Nlbm8gZGVsIFZSTUEgcXVhbmRvIGlsIFZSTUEgw6ggbmVnYXRpdm8gZSBsYSBmdW56aW9uZSBiYXNhdGEgc3VsbGEgc2VjYW50ZSBkZWwgVlJNQSBxdWFuZG8gaWwgVlJNQSBub24gw6ggbmVnYXRpdm8uPC9saT48bGk+PHN0cm9uZz5TZWMtQ29zPC9zdHJvbmc+LS1TcGVjaWZpY2EgY2hlIGxhIFZGIMOoIGxhIGZ1bnppb25lIGJhc2F0YSBzdWxsYSBzZWNhbnRlIGRlbCBWUk1BIHF1YW5kbyBpbCBWUk1BIMOoIG5lZ2F0aXZvIGUgbGEgZnVuemlvbmUgYmFzYXRhIHN1bCBjb3Nlbm8gZGVsIFZSTUEgcXVhbmRvIGlsIFZSTUEgbm9uIMOoIG5lZ2F0aXZvLiA8L2xpPjxsaT48c3Ryb25nPlRhYmVsbGE8L3N0cm9uZz4tLUlkZW50aWZpY2EgY2hlIHZlcnLDoCB1dGlsaXp6YXRvIHVuIGZpbGUgdGFiZWxsYSBwZXIgZGVmaW5pcmUgaWwgZ3JhZmljbyBkZWwgZmF0dG9yZSB2ZXJ0aWNhbGUgY2hlIHZpZW5lIHV0aWxpenphdG8gcGVyIGRldGVybWluYXJlIGxlIFZGLjwvbGk+PC91bD48cD5JIG1vZGlmaWNhdG9yaSBkZWxsZSBwYXJvbGUgY2hpYXZlIHZlcnRpY2FsaSBpbmNsdWRvbm8gcXVhbnRvIHNlZ3VlOiA8L3A+PHVsPjxsaT48c3Ryb25nPkZhdHRvcmUgemVybzwvc3Ryb25nPi0tIFN0YWJpbGlzY2UgaWwgZmF0dG9yZSB2ZXJ0aWNhbGUgdXNhdG8gcXVhbmRvIGlsIFZSTUEgw6ggemVyby4gUXVlc3RvIGZhdHRvcmUgcG9zaXppb25hIGzigJlpbnRlcmNldHRhemlvbmUgeSBkZWxsYSBmdW56aW9uZSBzcGVjaWZpY2F0YS4gUGVyIGRlZmluaXppb25lLCBpbCBmYXR0b3JlIHplcm8gbm9uIMOoIGFwcGxpY2FiaWxlIGFkIGFsY3VuYSBmdW56aW9uZSB2ZXJ0aWNhbGUgdHJpZ29ub21ldHJpY2EgKENPUywgU0VDLCBDT1MtU0VDIG8gU0VDLUNPUykuIEwnaW50ZXJjZXR0YSB5IMOoIGRlZmluaXRhIGRhIHF1ZXN0ZSBmdW56aW9uaS48L2xpPjxsaT48c3Ryb25nPkFuZ29sbyBkaSB0YWdsaW8gYmFzc28gPC9zdHJvbmc+LSBEZWZpbmlzY2UgbCdhbmdvbG8gVlJNQSBhbCBkaSBzb3R0byBkZWwgcXVhbGUgbGEgVkYgc2Fyw6AgaW1wb3N0YXRhIHN1IGluZmluaXRvLjwvbGk+PGxpPjxzdHJvbmc+QW5nb2xvIGRpIHRhZ2xpbyBhbHRvPC9zdHJvbmc+IC0gRGVmaW5pc2NlIGwnYW5nb2xvIFZSTUEgYWwgZGkgc29wcmEgZGVsIHF1YWxlIGxhIFZGIHNhcsOgIGltcG9zdGF0YSBzdSBpbmZpbml0by4gPC9saT48bGk+PHN0cm9uZz5QZW5kZW56YTwvc3Ryb25nPiAtIFN0YWJpbGlzY2UgbGEgcGVuZGVuemEgZGVsbGEgbGluZWEgcmV0dGEgdXNhdGEgY29uIGxlIHBhcm9sZSBjaGlhdmUgPHN0cm9uZz5MaW5lYXJlPC9zdHJvbmc+IGUgPHN0cm9uZz5MaW5lYXJlIEludmVyc2E8L3N0cm9uZz4tZmF0dG9yZSB2ZXJ0aWNhbGUuIExhIHBlbmRlbnphIMOoIHNwZWNpZmljYXRhIGNvbWUgdW5hIGZyYXppb25lIGRpIHNhbGl0YSBzdSBjb3JzYSAocGVyIGVzZW1waW8sIGxhIHBlbmRlbnphIGRlbCA0NSBwZXIgY2VudG8gw6ggMS80NSwgY2hlIHZpZW5lIGltbWVzc2EgY29tZSAwLDAyMjIyKS48L2xpPjxsaT48c3Ryb25nPk5vbWUgdGFiZWxsYTwvc3Ryb25nPi0tPC9saT5JZGVudGlmaWNhIGlsIG5vbWUgZGVsbGEgdGFiZWxsYSBjaGUgZGVmaW5pc2NlIGxhIFZGLjwvdWw+XCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3ZlcnRpY2FscmFzdGVyX3RhZzBAQFwiOiBcIkRlZmluaXNjZSBsYSByZWxhemlvbmUgdHJhIGlsIGZhdHRvcmUgZGkgY29zdG8gdmVydGljYWxlIGUgbCdhbmdvbG8gZGkgbW92aW1lbnRvIHJlbGF0aXZvIHZlcnRpY2FsZSAoVlJNQSkuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3ZlcnRpY2FscmFzdGVyX3RhZzFAQFwiOiBcIkkgdmFsb3JpIHZlbmdvbm8gdXRpbGl6emF0aSBwZXIgY2FsY29sYXJlIGxhIHBlbmRlbnphIHVzYXRhIHBlciBpZGVudGlmaWNhcmUgaWwgZmF0dG9yZSB2ZXJ0aWNhbGUgcXVhbmRvIHNpIHBhc3NhIGRhIHVuYSBjZWxsYSBhbGwnYWx0cmEuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fY2VsbHNpemVfdGFnMEBAXCI6IFwiTGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBhbGxhIHF1YWxlIHNpIGNyZWVyw6AgaWwgcmFzdGVyIGRpIG91dHB1dC5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9jZWxsc2l6ZV90YWcxQEBcIjogXCJTZSBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIMOoIHN0YXRhIGVzcGxpY2l0YW1lbnRlIGltcG9zdGF0YSBpbiA8c3Ryb25nPkFtYmllbnRpPC9zdHJvbmc+LCBxdWVsbGEgc2Fyw6AgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwcmVkZWZpbml0YS4gU2Ugbm9uIMOoIHN0YXRhIGltcG9zdGF0YSwgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBkaSBvdXRwdXQgc2Fyw6AgbGEgc3Rlc3NhIGRlbCA8c3Ryb25nPlJhc3RlciBkaSBvcmlnaW5lPC9zdHJvbmc+LlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzBAQFwiOiBcIkRldGVybWluYSBzZSBjYWxjb2xhcmUgbGEgZGlzdGFuemEgY29uIHVuIG1ldG9kbyBwbGFuYXJlICh0ZXJyYSBwaWF0dGEpIG8gZ2VvZGV0aWNvIChlbGxpc3NvaWRlKS5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9kaXN0YW5jZW1ldGhvZF90YWcxQEBcIjogXCJQbGFuYXJlOiBsYSBtaXN1cmF6aW9uZSBwbGFuYXJlIHV0aWxpenphIGxhIG1hdGVtYXRpY2EgY2FydGVzaWFuYSAyRCBwZXIgY2FsY29sYXJlIGFyZWEgZSBsdW5naGV6emEuIFF1ZXN0YSBvcHppb25lIMOoIGRpc3BvbmliaWxlIHNvbG8gcXVhbmRvIHNpIG1pc3VyYSBpbiB1biBzaXN0ZW1hIGRpIGNvb3JkaW5hdGUgcHJvaWV0dGF0byBlIGlsIHBpYW5vIDJEIGRpIHRhbGUgc2lzdGVtYSBkaSBjb29yZGluYXRlIHZpZW5lIHV0aWxpenphdG8gY29tZSBiYXNlIHBlciBsZSBtaXN1cmF6aW9uaS5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9kaXN0YW5jZW1ldGhvZF90YWcyQEBcIjogXCJHZW9kZXRpY2E6IGxhIGxpbmVhIHBpw7kgYnJldmUgdHJhIGR1ZSBwdW50aSBzdWxsYSBzdXBlcmZpY2llIHRlcnJlc3RyZSBzdSB1bm8gc2Zlcm9pZGUgKGVsbGlzc29pZGUpLiBQZXJ0YW50bywgaW5kaXBlbmRlbnRlbWVudGUgZGFsbGEgcHJvaWV6aW9uZSBkaSBpbnB1dCBvIG91dHB1dCwgaSByaXN1bHRhdGkgbm9uIGNhbWJpYW5vLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzNAQFwiOiBcIjxzdHJvbmc+Tm90YTwvc3Ryb25nPjogbGEgbGluZWEgZ2VvZGV0aWNhIHB1w7IgZXNzZXJlIHVzYXRhIHNlIHNpIGRlc2lkZXJhIGRldGVybWluYXJlIGxhIGRpc3RhbnphIHBpw7kgYnJldmUgdHJhIGR1ZSBjaXR0w6AgcGVyIGxhIHRyYWlldHRvcmlhIGRpIHVuIGFlcmVvLiBRdWVzdG8gbWV0b2RvIMOoIGNvbm9zY2l1dG8gYW5jaGUgY29tZSBsaW5lYSBkZWwgY2VyY2hpbyBtYXNzaW1vIHNlIGJhc2F0byBzdSB1bmEgc2ZlcmEgcGl1dHRvc3RvIGNoZSBzdSB1biBlbGxpc3NvaWRlLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX21heGltdW1kaXN0YW5jZV90YWcwQEBcIjogXCJEZWZpbmlzY2UgbGEgZGlzdGFuemEgbGltaXRlIGVudHJvIGxhIHF1YWxlIHZpZW5lIGNhbGNvbGF0YSBsYSBkaXJlemlvbmUgdmVyc28gbCdvcmlnaW5lIHBpw7kgdmljaW5hLiBTZSBsYSBkaXN0YW56YSBmaW5vIGFsbCdvcmlnaW5lIHBpw7kgdmljaW5hIHN1cGVyYSBxdWVzdG8gdmFsb3JlLCBsJ291dHB1dCBkaSBxdWVsbGEgY2VsbGEgc2Fyw6AgTm9EYXRhLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX21heGltdW1kaXN0YW5jZV90YWcxQEBcIjogXCJMYSBkaXN0YW56YSBwcmVkZWZpbml0YSDDqCBmaW5vIGFsbCdlc3RlbnNpb25lIGRlbCByYXN0ZXIgZGkgb3V0cHV0LlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX3Jhc3RlcmJhcnJpZXJzX3RhZzBAQFwiOiBcIklsIHJhc3RlciBjaGUgZGVmaW5pc2NlIGxlIGJhcnJpZXJlLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX3Jhc3RlcmJhcnJpZXJzX3RhZzFAQFwiOiBcIklsIGRhdGFzZXQgZGV2ZSBjb250ZW5lcmUgTm9EYXRhIGxhZGRvdmUgbm9uIGNpIHNvbm8gYmFycmllcmUuIExlIGJhcnJpZXJlIHNvbm8gcmFwcHJlc2VudGF0ZSBkYSB2YWxvcmkgdmFsaWRpLCBpbmNsdXNvIGxvIHplcm8uXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fcmFzdGVyYmFycmllcnNfdGFnMkBAXCI6IFwiTGUgYmFycmllcmUgcG9zc29ubyBlc3NlcmUgZGVmaW5pdGUgZGEgdW4gbnVtZXJvIGludGVybyBvIGRhIHVuIHJhc3RlciBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX3NvdXJjZXJhc3Rlcl90YWcwQEBcIjogXCJVbiBkYXRhc2V0IHJhc3RlciBjaGUgaWRlbnRpZmljYSBsZSBjZWxsZSBvIGxlIHBvc2l6aW9uaSBzdWxsZSBxdWFsaSBzaSBjYWxjb2xhIGxhIGRpcmV6aW9uZSBldWNsaWRlYSBwZXIgb2duaSBwb3NpemlvbmUgZGVsbGEgY2VsbGEgZGkgb3V0cHV0LlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX3NvdXJjZXJhc3Rlcl90YWcxQEBcIjogXCJJbCB0aXBvIGRpIGlucHV0IHB1w7IgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8gbyB1biB2YWxvcmUgYSB2aXJnb2xhIG1vYmlsZS5cIixcblx0XCJAQENvc3QtUGF0aF9jb3N0YmFja2xpbmtyYXN0ZXJfdGFnMEBAXCI6IFwiSWwgbm9tZSBkaSB1biByYXN0ZXIgbGF5ZXIgYmFja2xpbmsgY29zdGkgdXRpbGl6emF0byBwZXIgZGV0ZXJtaW5hcmUgaWwgcGVyY29yc28gcGVyIHJlc3RpdHVpcmUgdW4nb3JpZ2luZSB0cmFtaXRlIGlsIHBlcmNvcnNvIG1pbmltby1jb3N0by5cIixcblx0XCJAQENvc3QtUGF0aF9jb3N0YmFja2xpbmtyYXN0ZXJfdGFnMUBAXCI6IFwiUGVyIG9nbmkgY2VsbGEgbmVsIHJhc3RlciBiYWNrbGluaywgdW4gdmFsb3JlIGlkZW50aWZpY2EgaWwgdmljaW5vIGNoZSBzaSB0cm92YSBuZWxsYSBjZWxsYSBzdWNjZXNzaXZhIG5lbCBwZXJjb3JzbyBjb3N0aSBjdW11bGF0aXZvIG1pbmltbyBkYWxsYSBjZWxsYSBhIHVuYSBjZWxsYSBvcmlnaW5lIHNpbmdvbGEgbyBhIHVuIGluc2llbWUgZGkgY2VsbGUgb3JpZ2luZS5cIixcblx0XCJAQENvc3QtUGF0aF9jb3N0ZGlzdGFuY2VyYXN0ZXJfdGFnMEBAXCI6IFwiSWwgbm9tZSBkaSB1biByYXN0ZXIgZGlzdGFuemEgZGkgY29zdG8gZGEgdXRpbGl6emFyZSBwZXIgZGV0ZXJtaW5hcmUgaWwgcGVyY29yc28gbWluaW1vLWNvc3RvIGRhbGxlIHBvc2l6aW9uaSBkaSBkZXN0aW5hemlvbmUgYWxsJ29yaWdpbmUuXCIsXG5cdFwiQEBDb3N0LVBhdGhfY29zdGRpc3RhbmNlcmFzdGVyX3RhZzFAQFwiOiBcIklsIHJhc3RlciBkaXN0YW56YSBkaSBjb3N0byB2aWVuZSBjcmVhdG8gbm9ybWFsbWVudGUgY29uIGxhIGZ1bnppb25lIERpc3RhbnphIGRpIGNvc3RvLCBBc3NlZ25hemlvbmUgZGVpIGNvc3RpIG8gQmFjayBsaW5rIGNvc3RpLiBJbCBsYXllciByYXN0ZXIgZGlzdGFuemEgZGkgY29zdG8gYXJjaGl2aWEgcGVyIG9nbmkgY2VsbGEgbGEgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2YSBtaW5pbWEgc3UgdW5hIHN1cGVyZmljaWUgZGkgY29zdG8gZGEgb2duaSBjZWxsYSBzdSB1biBpbnNpZW1lIGRpIGNlbGxlIGRpIG9yaWdpbmUuXCIsXG5cdFwiQEBDb3N0LVBhdGhfZGVzdGluYXRpb25maWVsZF90YWcwQEBcIjogXCJJbCBjYW1wbyB1c2F0byBwZXIgb3R0ZW5lcmUgaSB2YWxvcmkgcGVyIGxlIHBvc2l6aW9uaSBkaSBkZXN0aW5hemlvbmUuIEkgZGF0aSBkaSBmZWF0dXJlIGRpIGlucHV0IGRldm9ubyBjb250ZW5lcmUgYWxtZW5vIHVuIGNhbXBvIHZhbGlkby5cIixcblx0XCJAQENvc3QtUGF0aF9kZXN0aW5hdGlvbnJhc3Rlcl90YWcwQEBcIjogXCJVbiBkYXRhc2V0IHJhc3RlciBjaGUgaWRlbnRpZmljYSBxdWVsbGUgY2VsbGUgZGEgY3VpIHZpZW5lIGRldGVybWluYXRvIGlsIHBlcmNvcnNvIGRpIGNvc3RvIG1pbmltbyB2ZXJzbyBsJ29yaWdpbmUgbWVubyBjb3N0b3NhLlwiLFxuXHRcIkBAQ29zdC1QYXRoX2Rlc3RpbmF0aW9ucmFzdGVyX3RhZzFAQFwiOiBcIklsIHJhc3RlciBsYXllciBkaSBpbnB1dCDDqCBjb3N0aXR1aXRvIGRhIGNlbGxlIGNvbiB2YWxvcmkgdmFsaWRpICh6ZXJvIMOoIHVuIHZhbG9yZSB2YWxpZG8pIGUgYWxsZSBjZWxsZSByaW1hbmVudGkgZGV2b25vIGVzc2VyZSBhc3NlZ25hdG8gTm9EYXRhLlwiLFxuXHRcIkBAQ29zdC1QYXRoX2ZvcmNlZmxvd2RpcmVjdGlvbmNvbnZlbnRpb25mb3JiYWNrbGlua3Jhc3Rlcl90YWcwQEBcIjogXCJJbXBvbmUgYWxsYSBmdW56aW9uZSBkaSB0cmF0dGFyZSBpbCByYXN0ZXIgYmFja2xpbmsgZGkgaW5wdXQgY29tZSByYXN0ZXIgZGkgZGlyZXppb25lIGRpIGZsdXNzby4gSSByYXN0ZXIgZGkgZGlyZXppb25lIGRpIGZsdXNzbyBwb3Nzb25vIGluY2x1ZGVyZSBudW1lcmkgaW50ZXJpIGNvbiB2YWxvcmkgZGEgMCBhIDI1NS5cIixcblx0XCJAQENvc3QtUGF0aF9mb3JjZWZsb3dkaXJlY3Rpb25jb252ZW50aW9uZm9yYmFja2xpbmtyYXN0ZXJfdGFnMUBAXCI6IFwiRGVzZWxlemlvbmF0bzogc2UgaSB2YWxvcmkgZGVsIHJhc3RlciBiYWNrbGluayBzcGVjaWZpY2F0byBzb25vIG51bWVyaSBpbnRlcmkgbmVsbCdpbnRlcnZhbGxvIDAtOCwgaWwgZGF0YXNldCBzYXLDoCB0cmF0dGF0byBjb21lIHJhc3RlciBiYWNrbGluayBkaSBjb3N0by4gU2UgaSB2YWxvcmkgdmFubm8gZGEgMCBhIDI1NSwgbCdpbnB1dCBzYXLDoCB0cmF0dGF0byBjb21lIHJhc3RlciBkaSBkaXJlemlvbmUgZGkgZmx1c3NvLiBTZSBpIHZhbG9yaSB2YW5ubyBkYSAwIGEgMzYwIGUgc29ubyB2aXJnb2xhIG1vYmlsZSwgbCdpbnB1dCBzYXLDoCB0cmF0dGF0byBjb21lIHJhc3RlciBkaSBkaXJlemlvbmUgY29udHJhcmlhLlwiLFxuXHRcIkBAQ29zdC1QYXRoX2ZvcmNlZmxvd2RpcmVjdGlvbmNvbnZlbnRpb25mb3JiYWNrbGlua3Jhc3Rlcl90YWcyQEBcIjogXCJTZWxlemlvbmF0bzogaWwgcmFzdGVyIGZvcm5pdG8gcGVyIGlsIHJhc3RlciBiYWNrbGluayBzYXLDoCB0cmF0dGF0byBjb21lIHJhc3RlciBkaSBkaXJlemlvbmUgZGkgZmx1c3NvLiBMJ3VzbyBkaSBxdWVzdGEgb3B6aW9uZSBkZWwgcmFzdGVyIGRlbGxhIGRpcmV6aW9uZSBkZWwgZmx1c3NvIGhhIHVuIHZhbG9yZSBtYXNzaW1vIGRpIDggbyBtZW5vLlwiLFxuXHRcIkBAQ29zdC1QYXRoX3BhdGh0eXBlX3RhZzBAQFwiOiBcIlVuYSBwYXJvbGEgY2hpYXZlIGNoZSBkZWZpbmlzY2UgaWwgbW9kbyBpbiBjdWkgaSB2YWxvcmkgZSBsZSB6b25lIG5laSBkYXRpIGRpIGRlc3RpbmF6aW9uZSBkaSBpbnB1dCB2ZW5nb25vIGludGVycHJldGF0aSBuZWkgY2FsY29saSBkZWkgY29zdGkgZGkgdmlhZ2dpby4gTGUgb3B6aW9uaSBzb25vIGxlIHNlZ3VlbnRpOlwiLFxuXHRcIkBAQ29zdC1QYXRoX3BhdGh0eXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+T2duaSBjZWxsYTwvc3Ryb25nPjogcGVyIG9nbmkgY2VsbGEgY29uIHZhbG9yaSB2YWxpZGkgbmVpIGRhdGkgZGkgZGVzdGluYXppb25lIGRpIGlucHV0LCB2aWVuZSBkZXRlcm1pbmF0byBlIHNhbHZhdG8gc3VsIHJhc3RlciBkaSBvdXRwdXQgdW4gcGVyY29yc28gZGkgY29zdG8gbWluaW1vLiBDb24gcXVlc3RhIG9wemlvbmUsIG9nbmkgY2VsbGEgZGVpIGRhdGkgZGkgZGVzdGluYXppb25lIGRpIGlucHV0IHZpZW5lIHRyYXR0YXRhIHNlcGFyYXRhbWVudGUgZSB2aWVuZSBkZXRlcm1pbmF0byB1biBwZXJjb3JzbyBkaSBjb3N0byBtaW5pbW8gcGVyIGNpYXNjdW5hLlwiLFxuXHRcIkBAQ29zdC1QYXRoX3BhdGh0eXBlX3RhZzJAQFwiOiBcIjxzdHJvbmc+T2duaSB6b25hPC9zdHJvbmc+OiBwZXIgb2duaSB6b25hIG5laSBkYXRpIGRpIGRlc3RpbmF6aW9uZSBkaSBpbnB1dCwgdmllbmUgZGV0ZXJtaW5hdG8gZSBzYWx2YXRvIHN1bCByYXN0ZXIgZGkgb3V0cHV0IHVuIHBlcmNvcnNvIGRpIGNvc3RvIG1pbmltby4gQ29uIHF1ZXN0YSBvcHppb25lLCBpbCBwZXJjb3JzbyBkaSBjb3N0byBtaW5pbW8gcGVyIG9nbmkgem9uYSBpbml6aWEgbmVsbGEgY2VsbGEgY29uIGxhIHBvbmRlcmF6aW9uZSBkaSBkaXN0YW56YSBkaSBjb3N0byBwacO5IGJhc3NhIG5lbGxhIHpvbmEuXCIsXG5cdFwiQEBDb3N0LVBhdGhfcGF0aHR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5TaW5nb2xvIG1pZ2xpb3JlPC9zdHJvbmc+OiBwZXIgdHV0dGUgbGUgY2VsbGUgbmVpIGRhdGkgZGkgZGVzdGluYXppb25lIGRpIGlucHV0LCBpbCBwZXJjb3JzbyBkaSBjb3N0byBtaW5pbW8gdmllbmUgcmljYXZhdG8gZGFsbGEgY2VsbGEgY29uIGlsIG1pbmltbyBkZWkgcGVyY29yc2kgZGkgY29zdG8gbWluaW1vIHZlcnNvIGxlIGNlbGxlIGRpIG9yaWdpbmUuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfY2VsbHNpemV0eXBlX3RhZzBAQFwiOiBcIlNjZWdsaWVyZSBxdWFsZSBkaW1lbnNpb25lIGRpIGNlbGxhIHVzYXJlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBsZSBkaW1lbnNpb25pIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0IHNvbm8gdWd1YWxpLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2NlbGxzaXpldHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGxhIGRpbWVuc2lvbmUgZGVsbGEgcHJpbWEgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19jZWxsc2l6ZXR5cGVfdGFnMkBAXCI6IFwiTWluaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IHBpY2NvbGEgdHJhIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2NlbGxzaXpldHlwZV90YWczQEBcIjogXCJNYXNzaW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSBwacO5IGdyYW5kZSB0cmEgdHV0dGkgaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19jZWxsc2l6ZXR5cGVfdGFnNEBAXCI6IFwiTWVkaWEgZGk6IHVzYSBsYSBkaW1lbnNpb25lIG1lZGlhIGRlbGxhIGNlbGxhIHRyYSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19jZWxsc2l6ZXR5cGVfdGFnNUBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbGEgZGltZW5zaW9uZSBkZWxsJ3VsdGltYSBjZWxsYSBkZWkgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2V4dGVudHR5cGVfdGFnMEBAXCI6IFwiU2NlZ2xpZXJlIHF1YWxlIGVzdGVuc2lvbmUgc2kgZG92cmViYmUgdXNhcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6XCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfZXh0ZW50dHlwZV90YWcxQEBcIjogXCJQcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2V4dGVudHR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZXppb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlaSBwaXhlbCBzb3ZyYXBwb3N0aSBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2V4dGVudHR5cGVfdGFnM0BAXCI6IFwiVW5pb25lIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRpIHR1dHRpIGkgcmFzdGVyIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2V4dGVudHR5cGVfdGFnNEBAXCI6IFwiVWx0aW1vIGRpOiB1c2EgbCdlc3RlbnNpb25lIGRlbGwndWx0aW1vIHJhc3RlciBkaSBpbnB1dCBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19wcm9jZXNzYXNtdWx0aWJhbmRfdGFnMEBAXCI6IFwiRGV0ZXJtaW5hIGlsIG1vZG8gaW4gY3VpIHZlbmdvbm8gZWxhYm9yYXRlIGxlIGJhbmRlIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19wcm9jZXNzYXNtdWx0aWJhbmRfdGFnMUBAXCI6IFwiRGVzZWxlemlvbmF0bzogdHV0dGkgZ2xpIGlucHV0IG11bHRpYmFuZGEgdmVuZ29ubyBlbGFib3JhdGkgY29tZSBiYW5kZSBzaW5nb2xlLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfcHJvY2Vzc2FzbXVsdGliYW5kX3RhZzJAQFwiOiBcIlNlbGV6aW9uYXRvOiB0dXR0aSBnbGkgaW5wdXQgbXVsdGliYW5kYSB2ZW5nb25vIGVsYWJvcmF0aSBjb21lIG11bHRpYmFuZGEuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfcmFzdGVyc190YWcwQEBcIjogXCJMJ2VsZW5jbyBkaSByYXN0ZXIgYSBwYXJ0aXJlIGRhaSBxdWFsaSBjYWxjb2xhcmUgbGUgc3RhdGlzdGljaGUsIGluIGJhc2UgYWkgc2luZ29saSBwaXhlbC5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19wZXJjZW50aWxlaW50ZXJwb2xhdGlvbnR5cGVfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGlsIG1ldG9kbyBkaSBpbnRlcnBvbGF6aW9uZSBkYSB1dGlsaXp6YXJlIHF1YW5kbyBpbCB2YWxvcmUgcGVyY2VudGlsZSBzcGVjaWZpY2F0byBzaSB0cm92YSB0cmEgZHVlIHZhbG9yaSBkaSBjZWxsZSBkaSBpbnB1dC4gPC9wPjx1bD48bGk+PHN0cm9uZz5SaWxldmFtZW50byBhdXRvbWF0aWNvPC9zdHJvbmc+OiBzZSBpIHJhc3RlciBkaSBpbnB1dCBzb25vIGRpIHRpcG8gcGl4ZWwgaW50ZXJvLCB2aWVuZSB1dGlsaXp6YXRvIGlsIGNvc2lkZGV0dG8gbWV0b2RvIDxzdHJvbmc+UGnDuSB2aWNpbm88L3N0cm9uZz4uIFNlIGlsIHJhc3RlciBkaSBpbnB1dCDDqCBkaSB0aXBvIHBpeGVsIGEgdmlyZ29sYSBtb2JpbGUsIGFsbG9yYSB2aWVuZSB1dGlsaXp6YXRvIGlsIG1ldG9kbyA8c3Ryb25nPmxpbmVhcmU8L3N0cm9uZz4uIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS48L2xpPjxsaT48c3Ryb25nPlBpw7kgdmljaW5vPC9zdHJvbmc+OiBpbCB2YWxvcmUgcGnDuSB2aWNpbm8gZGlzcG9uaWJpbGUgdmllbmUgdXNhdG8gcGVyIGlsIHBlcmNlbnRpbGUgZGVzaWRlcmF0by4gSW4gcXVlc3RvIGNhc28sIGlsIHRpcG8gZGkgcGl4ZWwgZGkgb3V0cHV0IMOoIGxvIHN0ZXNzbyBkZWwgcmFzdGVyIGRpIHZhbG9yZSBkaSBpbnB1dC48L2xpPjxsaT48c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz46IGxhIG1lZGlhIHBlc2F0YSBkZWkgZHVlIHZhbG9yaSBjaXJjb3N0YW50aSB2aWVuZSB1c2F0YSBwZXIgaWwgcGVyY2VudGlsZSBkZXNpZGVyYXRhLiBJbiBxdWVzdG8gY2FzbywgaWwgdGlwbyBkaSBwaXhlbCBpbiB1c2NpdGEgw6ggYSB2aXJnb2xhIG1vYmlsZS48L2xpPjwvdWw+PHA+UXVlc3RhIG9wemlvbmUgw6ggZGlzcG9uaWJpbGUgc29sbyBzZSBpbCBwYXJhbWV0cm8gVGlwbyBkaSA8c3Ryb25nPm9wZXJhemlvbmU8L3N0cm9uZz4gw6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+TWVkaWFubzwvc3Ryb25nPiBvIDxzdHJvbmc+UGVyY2VudGlsZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfcGVyY2VudGlsZXZhbHVlX3RhZzBAQFwiOiBcIjxwPklsIHBlcmNlbnRpbGUgZGEgY2FsY29sYXJlLiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggOTAgcGVyIGlsIDkwZXNpbW8gcGVyY2VudGlsZS48L3A+PHA+SSB2YWxvcmkgcHXDsiBvc2NpbGxhcmUgZGEgMCBhIDEwMC4gSWwgcGVyY2VudGlsZSBudW1lcm8gMCDDqCBlc3NlbnppYWxtZW50ZSBsJ2VxdWl2YWxlbnRlIGRlbGxhIHN0YXRpc3RpY2EgbWluaW1hIGUgaWwgcGVyY2VudGlsZSBudW1lcm8gMTAwIMOoIGwnZXF1aXZhbGVudGUgZGVsbGEgc3RhdGlzdGljYSBtYXNzaW1hLiBVbiB2YWxvcmUgZGkgNTAgcHJvZHVycsOgIGVzc2VuemlhbG1lbnRlIGxvIHN0ZXNzbyByaXN1bHRhdG8gZGVsbGEgc3RhdGlzdGljYSBtZWRpYW5hLjwvcD48cD5RdWVzdGEgb3B6aW9uZSDDqCBkaXNwb25pYmlsZSBzb2xvIHNlIGlsIHBhcmFtZXRybyA8c3Ryb25nPk9wZXJhemlvbmU8L3N0cm9uZz4gw6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+UGVyY2VudGlsZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX2JhY2tkaXJlY3Rpb25yYXN0ZXJvcmZsb3dkaXJlY3Rpb25yYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGRpcmV6aW9uZSBjb250cmFyaWEgY29udGllbmUgbGUgZGlyZXppb25pIGNhbGNvbGF0ZSBpbiBncmFkaS4gTGEgZGlyZXppb25lIGlkZW50aWZpY2EgbGEgY2VsbGEgc3VjY2Vzc2l2YSBzZWd1ZW5kbyBpbCBwZXJjb3JzbyBvdHRpbWFsZSBmaW5vIGFsbCdvcmlnaW5lIGRpIGNvc3RvIG1pbmltbyBjdW11bGF0aXZvIGV2aXRhbmRvIGJhcnJpZXJlLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9iYWNrZGlyZWN0aW9ucmFzdGVyb3JmbG93ZGlyZWN0aW9ucmFzdGVyX3RhZzFAQFwiOiBcIkwnaW50ZXJ2YWxsbyBkaSB2YWxvcmkgw6ggY29tcHJlc28gdHJhIDAgZ3JhZGkgZSAzNjAgZ3JhZGksIGNvbiAwIHJpc2VydmF0byBwZXIgbGUgY2VsbGUgZGkgb3JpZ2luZS4gVmVyc28gZXN0IChkZXN0cmEpIMOoIGRpIDkwIGUgaSB2YWxvcmkgYXVtZW50YW5vIGluIHNlbnNvIG9yYXJpbyAoMTgwIMOoIHN1ZCwgMjcwIMOoIG92ZXN0IGUgMzYwIMOoIG5vcmQpLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9kZXN0aW5hdGlvbmZpZWxkX3RhZzBAQFwiOiBcIklsIGNhbXBvIHVzYXRvIHBlciBvdHRlbmVyZSBpIHZhbG9yaSBwZXIgbGUgcG9zaXppb25pIGRpIGRlc3RpbmF6aW9uZS5cIixcblx0XCJAQE9wdGltYWwtUGF0aC1Bcy1SYXN0ZXJfZGVzdGluYXRpb25yYXN0ZXJfdGFnMEBAXCI6IFwiVW4gZGF0YXNldCByYXN0ZXIgY2hlIGlkZW50aWZpY2EgcXVlbGxlIGNlbGxlIGRhIGN1aSB2aWVuZSBkZXRlcm1pbmF0byBpbCBwZXJjb3JzbyBvdHRpbWFsZSB2ZXJzbyBsJ29yaWdpbmUgbWVubyBjb3N0b3NhLiBRdWVzdG8gaW5wdXQgw6ggb2JibGlnYXRvcmlvLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9kZXN0aW5hdGlvbnJhc3Rlcl90YWcxQEBcIjogXCJJbCByYXN0ZXIgbGF5ZXIgZGkgaW5wdXQgw6ggY29zdGl0dWl0byBkYSBjZWxsZSBjb24gdmFsb3JpIHZhbGlkaSAoemVybyDDqCB1biB2YWxvcmUgdmFsaWRvKSBlIGFsbGUgY2VsbGUgcmltYW5lbnRpIGRldm9ubyBlc3NlcmUgYXNzZWduYXRvIE5vRGF0YS5cIixcblx0XCJAQE9wdGltYWwtUGF0aC1Bcy1SYXN0ZXJfZGlzdGFuY2VhY2N1bXVsYXRpb25yYXN0ZXJfdGFnMEBAXCI6IFwiSWwgcmFzdGVyIGRpIGFjY3VtdWxvIGRpc3RhbnphIHZpZW5lIHV0aWxpenphdG8gcGVyIHN0YWJpbGlyZSBpbCBwZXJjb3JzbyBvdHRpbWFsZSBkYWxsZSBkZXN0aW5hemlvbmkgYWxsZSBvcmlnaW5pLiBJbCByYXN0ZXIgZGkgYWNjdW11bG8gZGVsbGEgZGlzdGFuemEgdmllbmUgc29saXRhbWVudGUgY3JlYXRvIGNvbiBsYSBmdW56aW9uZSA8c3Ryb25nPkFjY3VtdWxvIGRpc3RhbnphPC9zdHJvbmc+LiBDaWFzY3VuYSBjZWxsYSBuZWwgcmFzdGVyIGRpIGFjY3VtdWxvIGRlbGxhIGRpc3RhbnphIHJhcHByZXNlbnRhIGxhIGRpc3RhbnphIGRpIGNvc3RvIGN1bXVsYXRpdmEgbWluaW1hIHN1IHVuYSBzdXBlcmZpY2llIGRhIG9nbmkgY2VsbGEgYSB1biBpbnNpZW1lIGRpIGNlbGxlIGRpIG9yaWdpbmUuXCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX3BhdGh0eXBlX3RhZzBAQFwiOiBcIlNwZWNpZmljYSB1bmEgcGFyb2xhIGNoaWF2ZSBjaGUgZGVmaW5pc2NlIGlsIG1vZG8gaW4gY3VpIGkgdmFsb3JpIGUgbGUgem9uZSBuZWkgZGF0aSBkaSBkZXN0aW5hemlvbmUgZGkgaW5wdXQgdmVuZ29ubyBpbnRlcnByZXRhdGkgbmVpIGNhbGNvbGkgZGVsIHBlcmNvcnNvIGRpIGNvc3RvLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9wYXRodHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPk9nbmkgem9uYTwvc3Ryb25nPjogcGVyIG9nbmkgem9uYSBuZWkgZGF0aSBkaSBkZXN0aW5hemlvbmUgZGkgaW5wdXQsIHZpZW5lIGRldGVybWluYXRvIGUgc2FsdmF0byBzdWwgcmFzdGVyIGRpIG91dHB1dCB1biBwZXJjb3JzbyBkaSBjb3N0byBtaW5pbW8uIENvbiBxdWVzdGEgb3B6aW9uZSwgaWwgcGVyY29yc28gb3R0aW1hbGUgcGVyIG9nbmkgem9uYSBpbml6aWEgbmVsbGEgY2VsbGEgY29uIGxhIHBvbmRlcmF6aW9uZSBkaSBkaXN0YW56YSBkaSBjb3N0byBwacO5IGJhc3NhIG5lbGxhIHpvbmEuXCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX3BhdGh0eXBlX3RhZzJAQFwiOiBcIjxzdHJvbmc+U2luZ29sbyBtaWdsaW9yZTwvc3Ryb25nPjogcGVyIHR1dHRlIGxlIGNlbGxlIG5laSBkYXRpIGRpIGRlc3RpbmF6aW9uZSBkaSBpbnB1dCwgaWwgcGVyY29yc28gb3R0aW1hbGUgdmllbmUgcmljYXZhdG8gZGFsbGEgY2VsbGEgY29uIGlsIG1pbmltbyBkZWkgcGVyY29yc2kgZGkgY29zdG8gbWluaW1vIHZlcnNvIGxlIGNlbGxlIGRpIG9yaWdpbmUuXCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX3BhdGh0eXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+T2duaSBjZWxsYTwvc3Ryb25nPjogcGVyIG9nbmkgY2VsbGEgY29uIHZhbG9yaSB2YWxpZGkgbmVpIGRhdGkgZGkgZGVzdGluYXppb25lIGRpIGlucHV0LCB2aWVuZSBkZXRlcm1pbmF0byB1biBwZXJjb3JzbyBvdHRpbWFsZS4gQ29uIHF1ZXN0YSBvcHppb25lLCBvZ25pIGNlbGxhIGRlaSBkYXRpIGRpIGRlc3RpbmF6aW9uZSBkaSBpbnB1dCB2aWVuZSB0cmF0dGF0YSBzZXBhcmF0YW1lbnRlIGUgdmllbmUgZGV0ZXJtaW5hdG8gdW4gcGVyY29yc28gb3R0aW1hbGUgcGVyIGNpYXNjdW5hLlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc19iYW5kc2ZvcmRldGVjdGluZ2NoYW5nZV90YWcwQEBcIjogXCJMJ0lEIGJhbmRhIGRhIHV0aWxpenphcmUgcGVyIGlsIHJpbGV2YW1lbnRvIGRlbGxlIHZhcmlhemlvbmkuIFNlIG5vbiDDqCBzcGVjaWZpY2F0byBuZXNzdW4gSUQgYmFuZGEsIHNpIHV0aWxpenplcmFubm8gdHV0dGUgbGUgYmFuZGUgZGVsIGRhdGFzZXQgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc19iYW5kc2ZvcmRldGVjdGluZ2NoYW5nZV90YWcxQEBcIjogXCJJIHZhbG9yaSBJRCBkZXZvbm8gZXNzZXJlIG51bWVyaSBpbnRlcmkgc2VwYXJhdGkgZGEgc3BhemkuXCIsXG5cdFwiQEBDQ0RDLUFuYWx5c2lzX2JhbmRzZm9ydGVtcG9yYWxtYXNraW5nX3RhZzBAQFwiOiBcIkdsaSBJRCBiYW5kYSBkZWxsYSBiYW5kYSB2ZXJkZSBlIGRlbGxhIGJhbmRhIFNXSVIsIGRhIHV0aWxpenphcmUgcGVyIGlsIG1hc2NoZXJhbWVudG8gcGVyIG51dm9sYSwgb21icmEgZGVsbGEgbnV2b2xhIGUgbmV2ZS4gU2Ugbm9uIMOoIHNwZWNpZmljYXRvIG5lc3N1biBJRCBiYW5kYSwgaWwgbWFzY2hlcmFtZW50byBub24gYXZ2ZXJyw6AuXCIsXG5cdFwiQEBDQ0RDLUFuYWx5c2lzX2JhbmRzZm9ydGVtcG9yYWxtYXNraW5nX3RhZzFAQFwiOiBcIkkgdmFsb3JpIElEIGRldm9ubyBlc3NlcmUgbnVtZXJpIGludGVyaSBzZXBhcmF0aSBkYSBzcGF6aS5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfYmFuZHNmb3J0ZW1wb3JhbG1hc2tpbmdfdGFnMkBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyBzcGVjaWZpY2EgbGUgYmFuZGUgZGEgdXNhcmUgcGVyIGlsIG1hc2NoZXJhbWVudG8gZGkgbnV2b2xhLCBvbWJyYSBkZWxsYSBudXZvbGEgZSBuZXZlLiBEYWwgbW9tZW50byBjaGUgbCdvbWJyYSBkZWxsYSBudXZvbGEgZSBsYSBuZXZlIGFwcGFpb25vIG1vbHRvIHNjdXJlIG5lbGxhIGJhbmRhIGRlbGwnaW5mcmFyb3NzbyBhIG9uZGUgY29ydGUgKFNXSVIpIGUgY2hlIGxlIG51dm9sZSBlIGxhIG5ldmUgc29ubyBtb2x0byBsdW1pbm9zZSBuZWxsYSBiYW5kYSB2ZXJkZSwgc2kgY29uc2lnbGlhIGRpIG1hc2NoZXJhcmUgZ2xpIGluZGljaSBkaSBiYW5kYSBwZXIgbGUgYmFuZGUgU1dJUiBlIHZlcmRpLlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc19jaGktc3F1YXJlZHRocmVzaG9sZGZvcmRldGVjdGNoYW5nZV90YWcwQEBcIjogXCJMYSBzb2dsaWEgY2hpLXF1YWRyYXRvIHN1bGxhIHByb2JhYmlsaXTDoCBkZWxsZSBtb2RpZmljaGUuIFNlIHVuIG9zc2VydmF6aW9uZSBwcmVzZW50YSB1bmEgcHJvYmFiaWxpdMOgIGRpIG1vZGlmaWNoZSBjYWxjb2xhdGEgYWwgZGkgc29wcmEgZGkgcXVlc3RhIHNvZ2xpYSwgdmllbmUgY29udHJhc3NlZ25hdGEgY29tZSB1bidhbm9tYWxpYSwgY2hlIMOoIHVuIGV2ZW50byBkaSBtb2RpZmljYSBwb3RlbnppYWxlLuKAi0lsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAwLDk5LlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc19taW5pbXVtY29uc2VjdXRpdmVhbm9tYWx5b2JzZXJ2YXRpb25zX3RhZzBAQFwiOiBcIklsIG51bWVybyBtaW5pbW8gZGkgb3NzZXJ2YXppb25pIGRpIGFub21hbGllIGNvbnNlY3V0aXZlIGNoZSBkZXZvbm8gdmVyaWZpY2Fyc2kgcHJpbWEgY2hlIHVuIGV2ZW50byB2ZW5nYSBjb25zaWRlcmF0byB1bmEgbW9kaWZpY2Eu4oCLVW4gcGl4ZWwgZGV2ZSBlc3NlcmUgY29udHJhc3NlZ25hdG8gY29tZSB1bidhbm9tYWxpYSBwZXIgaWwgbnVtZXJvIHNwZWNpZmljYXRvIGRpIHNlemlvbmkgdGVtcG9yYWxpIGNvbnNlY3V0aXZlIHByaW1hIGRpIGVzc2VyZSBjb25zaWRlcmF0byB1bmEgdmVyYSBtb2RpZmljYS4gTCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEgw6ggNi5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfcmFzdGVyX3RhZzBAQFwiOiBcIklsIGxheWVyIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBkaSBpbnB1dC5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfdXBkYXRpbmdmaXR0aW5nZnJlcXVlbmN5KGlueWVhcnMpX3RhZzBAQFwiOiBcIkxhIGZyZXF1ZW56YSBjb24gbGEgcXVhbGUgYWdnaW9ybmFyZSBpbCBtb2RlbGxvIGRpIHNlcmllIHRlbXBvcmFsaSBjb24gbnVvdmUgb3NzZXJ2YXppb25pLiBQZXIgaW1wb3N0YXppb25lIHByZWRlZmluaXRhLCBpbCBtb2RlbGxvIHZpZW5lIGFnZ2lvcm5hdG8gb2duaSBhbm5vLlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc191cGRhdGluZ2ZpdHRpbmdmcmVxdWVuY3koaW55ZWFycylfdGFnMUBAXCI6IFwiUXVlc3RvIHBhcmFtZXRybyBkZWZpbmlzY2UgbGEgY2FkZW56YSBkZWxsJ2FnZ2lvcm5hbWVudG8gZGVsIG1vZGVsbG8gZGkgc2VyaWUgdGVtcG9yYWxpIGNvbiBudW92ZSBvc3NlcnZhemlvbmkuIEwnYWdnaW9ybmFtZW50byBmcmVxdWVudGUgZGkgdW4gbW9kZWxsbyBwdcOyIHJpY2hpZWRlcmUgbW9sdGlzc2ltaSBjYWxjb2xpIGUgaSBiZW5lZmljaSBwb3Nzb25vIGVzc2VyZSBtaW5pbWkuIEFkIGVzZW1waW8sIHNlIGNpIHNvbm8gMzY1IHNlemlvbmkgbyBvc3NlcnZhemlvbmkgY2hpYXJlIGFsbCdhbm5vIG5lbCByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUgZSBsJ2FnZ2lvcm5hbWVudG8gdmllbmUgZXNlZ3VpdG8gcGVyIG9nbmkgc2luZ29sYSBvc3NlcnZhemlvbmUsIGwnZWxhYm9yYXppb25lIHNhcsOgIDM2NSB2b2x0ZSBwacO5IGNvbXBsZXNzYSBkYWwgcHVudG8gZGkgdmlzdGEgZGVpIGNhbGNvbGkgcmlzcGV0dG8gYWQgdW4gYWdnaW9ybmFtZW50byB1bmEgdm9sdGEgbCdhbm5vLCBtYSBsYSBwcmVjaXNpb25lIHBvdHJlYmJlIG5vbiBlc3NlcmUgc3VwZXJpb3JlLlwiLFxuXHRcIkBAVHJlbmQtVG8tUkdCX21vZGVsdHlwZV90YWcwQEBcIjogXCJJbCB0aXBvIGRpIGluZm9ybWF6aW9uaSBzdWwgbW9kZWxsbyBkYSBjb252ZXJ0aXJlIGluIFJHQi5cIixcblx0XCJAQFRyZW5kLVRvLVJHQl9tb2RlbHR5cGVfdGFnMUBAXCI6IFwiTGluZWFyZTogbGUgaW5mb3JtYXppb25pIHN1bGxhIHRlbmRlbnphIGxpbmVhcmUgc2FyYW5ubyBjb252ZXJ0aXRlIGluIFJHQi4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLlwiLFxuXHRcIkBAVHJlbmQtVG8tUkdCX21vZGVsdHlwZV90YWcyQEBcIjogXCJBcm1vbmljYTogbGUgaW5mb3JtYXppb25pIHN1bGxhIHRlbmRlbnphIGFybW9uaWNhIHNhcmFubm8gY29udmVydGl0ZSBpbiBSR0IuXCIsXG5cdFwiQEBUcmVuZC1Uby1SR0JfcmFzdGVyX3RhZzBAQFwiOiBcIklsIHJhc3RlciBkaSB0ZW5kZW56YSBkaSBpbnB1dC5cIixcblx0XCJAQExhbmRUcmVuZHItQW5hbHlzaXNfYmVzdG1vZGVscHJvcG9ydGlvbl90YWcwQEBcIjogXCI8cD5WYWxvcmUgZGkgcHJvcG9yemlvbmUgZGVsIG1vZGVsbG8gbWlnbGlvcmUuIER1cmFudGUgaWwgcHJvY2Vzc28gZGkgc2VsZXppb25lIGRlbCBtb2RlbGxvLCBsbyBzdHJ1bWVudG8gY2FsY29sZXLDoCBpbCB2YWxvcmUgcCBwZXIgb2duaSBtb2RlbGxvIGUgc2VsZXppb25lcsOgIHVuIG1vZGVsbG8gY2hlIGRpc3BvbmUgZGVpIHZlcnRpY2kgbWFnZ2lvcmkgZHVyYW50ZSBpbCBtYW5pdGVuaW1lbnRvIGRlbCB2YWxvcmUgcCBtaW5vcmUgKGlsIHBpw7kgcmlsZXZhbnRlKSBiYXNhdG8gc3UgcXVlc3RvIHZhbG9yZSBkaSBwcm9wb3J6aW9uZS4gVW4gdmFsb3JlIGRpIDEgc2lnbmlmaWNhIGNoZSBpbCBtb2RlbGxvIGhhIGlsIHZhbG9yZSBwIHBpw7kgYmFzc28gbWEgbm9uIGF2csOgIHVuIG51bWVybyBhbHRvIGRpIHZlcnRpY2kuIEwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQgw6ggMS4yNS48L3A+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX21heGltdW1udW1iZXJvZnNlZ21lbnRzX3RhZzBAQFwiOiBcIjxwPklsIG51bWVybyBtYXNzaW1vIGRpIHNlZ21lbnRpIGRhIGFkYXR0YXJlIGFsIHRlbXBvIGRlbGxlIHNlcmllIHBlciBvZ25pIHBpeGVsLiBMJ2ltcG9zdGF6aW9uZSBkaSBkZWZhdWx0IMOoIDUuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19taW5pbXVtbnVtYmVyb2ZvYnNlcnZhdGlvbnNfdGFnMEBAXCI6IFwiPHA+SWwgbnVtZXJvIG1pbmltbyBkaSBvc3NlcnZhemlvbmkgdmFsaWRlIHJpY2hpZWRlIGRpIGVzZWd1aXJlIHVuIGFkYXR0YW1lbnRvLiBJbCBudW1lcm8gZGkgYW5uaSBuZWkgZGF0YXNldCBtdWx0aWRpbWVuc2lvbmFsaSBkaSBpbnB1dCBkZXZlIGVzc2VyZSB1Z3VhbGUgbyBtYWdnaW9yaSBkaSBxdWVzdG8gdmFsb3JlLiBMJ2ltcG9zdGF6aW9uZSBkaSBkZWZhdWx0IMOoIDYuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19vdXRwdXRvdGhlcmJhbmRzX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmljYSBzZSBhbHRyZSBiYW5kZSBzYXJhbm5vIGluY2x1c2UgbmVpIHJpc3VsdGF0aS48L3A+PHVsPjxsaT5TZWxlemlvbmF0YS1BbHRyZSBiYW5kZSBzYXJhbm5vIGluY2x1c2UgbmVpIHJpc3VsdGF0aS4gTGEgc2VnbWVudGF6aW9uZSBlIGwnZSBpbmZvcm1hemlvbmkgc3VpIHZlcnRpY2kgZGFsbGEgYmFuZGEgZGkgc2VnbWVudGF6aW9uZSBpbml6aWFsZSBzcGVjaWZpY2F0YSBuZWwgcGFyYW1ldHJvIDxzdHJvbmc+QmFuZGEgZGkgZWxhYm9yYXppb25lPC9zdHJvbmc+IHNpIGFkYXR0ZXLDoCBhbmNoZSBhbGxlIGJhbmRlIHJpbWFuZW50aSBuZWxsZSBpbW1hZ2luaSBtdWx0aWJhbmRhLiBJIHJpc3VsdGF0aSBkZWwgbW9kZWxsaSBpbmNsdWRlcmFubm8gcHJpbWEgbGEgYmFuZGEgZGkgc2VnbWVudGF6aW9uZSwgcG9pIGxlIGJhbmRlIHJpbWFuZW50aS48L2xpPjxsaT5Ob24gc2VsZXppb25hdGEtQWx0cmUgYmFuZGUgbm9uIHNhcmFubm8gaW5jbHVzZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48L3VsPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19wcmV2ZW50b25leWVhcnJlY292ZXJ5X3RhZzBAQFwiOiBcIjxwPlNwZWNpZmljYSBzZSBpIHNlZ21lbnRpIGNoZSBlc2liaXNjb25vIHVuIHJlY3VwZXJvIGRpIHVuIGFubm8gdmVycmFubm8gZXNjbHVzaS48L3A+PHVsPjxsaT5TZWxlemlvbmF0YS1JIHNlZ21lbnRpIGNoZSBlc2liaXNjb25vIHVuIHJlY3VwZXJvIGRpIHVuIGFubm8gdmVycmFubm8gZXNjbHVzaS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48bGk+Tm9uIHNlbGV6aW9uYXRhLUkgc2VnbWVudGkgY2hlIGVzaWJpc2Nvbm8gdW4gcmVjdXBlcm8gZGkgdW4gYW5ubyBub24gdmVycmFubm8gZXNjbHVzaS48L2xpPjwvdWw+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3Byb2Nlc3NpbmdiYW5kX3RhZzBAQFwiOiBcIjxwPkxhIGJhbmRhIHV0aWxpenphdGEgcGVyIHNlZ21lbnRhcmUgbGUgdHJhaWV0dG9yaWUgZGVsIHZhbG9yZSBkaSBwaXhlbCBuZWwgdGVtcG8uIFNjZWdsaWVyZSB1bmEgYmFuZGEgY2hlIGNhdHR1cmVyw6AgbmVsIG1pZ2xpb3IgbW9kbyBpIGNhbWJpYW1lbnRpIG5lbGxhIGZlYXR1cmUgY2hlIHNpIGRlc2lkZXJhIG9zc2VydmFyZS48L3A+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3AtdmFsdWV0aHJlc2hvbGRfdGFnMEBAXCI6IFwiPHA+SWwgdmFsb3JlIHAgcGVyIHVuIG1vZGVsbG8gZGEgc2VsZXppb25hcmUuIERvcG8gY2hlIGkgdmVydGljaSBzb25vIHN0YXRpIHJpbGV2YXRpIG5lbGxvIHN0YWdlIGluaXppYWxlIGRlbCBtb2RlbGxvIGluIGFkYXR0YW1lbnRvLCBsbyBzdHJ1bWVudG8gc2kgYWRhdHRlcsOgIGEgb2duaSBzZWdtZW50aSBlIGNhbGNvbGVyw6AgaWwgdmFsb3JlIHAgcGVyIGRldGVybWluYXJlIGxhIHNpZ25pZmljYW56YSBkZWwgbW9kZWxsby4gTmVsbGEgcHJvc3NpbWEgaXRlcmF6aW9uZSwgaWwgbW9kZWxsbyBkaW1pbnVpcsOgIGlsIG51bWVybyBkaSBzZWdtZW50aSB1bm8gYSB1bm8gZSByaWNhbGNvbGVyw6AgaWwgdmFsb3JlIHAuIFF1ZXN0byBwcm9jZXNzbyBjb250aW51ZXLDoCBhLCBzZSBpbCB2YWxvcmUgcCDDqCBtaW5vcmUgZGVsIHZhbG9yZSBzcGVjaWZpY2F0byBpbiBxdWVzdG8gcGFyYW1ldHJvLCBpbCBtb2RlbGxvIHNhcsOgIHNlbGV6aW9uYXRvIGUgbG8gc3RydW1lbnRvIHNtZXR0ZXLDoCBkaSBjZXJjYXJlIHVuIG1vZGVsbG8gbWlnbGlvcmUuIFNlIG5vbiDDqCBzZWxlemlvbmF0byB0YWxlIG1vZGVsbG8sIGxvIHN0cnVtZW50byBzZWxlemlvbmVyw6AgdW4gbW9kZWxsbyBjb24gdW4gdmFsb3JlIHAgaW5mZXJpb3JlIGFsIHBpw7kgYmFzc28gdmFsb3JlIHA8c3Ryb25nPiDDlyBpbCBtaWdsaW9yIHZhbG9yZSBkaSBwcm9wb3J6aW9uZSBkZWwgbW9kZWxsbzwvc3Ryb25nPi4gTCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdCDDqCAwLjAxLjwvcD5cIixcblx0XCJAQExhbmRUcmVuZHItQW5hbHlzaXNfcmFzdGVyX3RhZzBAQFwiOiBcIjxwPkwnaW5wdXQgbGF5ZXIgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIExhbmRzYXQuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19yZWNvdmVyeWhhc2luY3JlYXNldHJlbmRfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIHNlIGlsIHJlY3VwZXJvIGhhIHVuIHRyZW5kIGNyZXNjZW50ZSAocG9zaXRpdm8pLjwvcD48dWw+PGxpPlNlbGV6aW9uYXRvLUlsIHJlY3VwZXJvIGhhIHVuIHRyZW5kIGNyZXNjZW50ZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQ8L2xpPjxsaT5TZWxlemlvbmF0by1JbCByZWN1cGVybyBoYSB1biB0cmVuZCBkZWNyZXNjZW50ZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3JlY292ZXJ5dGhyZXNob2xkX3RhZzBAQFwiOiBcIjxwPklsIHZhbG9yZSBkaSBzb2dsaWEgZGkgcmVjdXBlcm8sIGluIGFubmkuIFNlIHVuIHNlZ21lbnRvIGRpc3BvbmUgZGkgdW4gdGFzc28gZGkgcmVjdXBlcm8gY2hlIMOoIHBpw7kgdmVsb2NlIGRpIDxzdHJvbmc+MS8gcmVjb3ZlcnkgdGhyZXNob2xkPC9zdHJvbmc+LCBpbCBzZWdtZW50byB2aWVuZSBlbGltaW5hdG8gZSBub24gdmllbmUgaW5jbHVzbyBuZWxsbyBzdGVzc28gbW9kZWxsbyBkaSBzZXJpZSBkaSB2b2x0ZS4gSWwgdmFsb3JlIGRldmUgb3NjaWxsYXJlIHRyYSAwIGUgMS4gTCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdCDDqCAwLjI1LjwvcD5cIixcblx0XCJAQExhbmRUcmVuZHItQW5hbHlzaXNfc25hcHBpbmdkYXRlX3RhZzBAQFwiOiBcIjxwPkxhIGRhdGEgdXRpbGl6emF0YSBwZXIgc2VsZXppb25hcmUgdW5hIHBvcnppb25lIHBlciBvZ25pIGFubm8gbmVsIGRhdGFzZXQgbXVsdGlkaW1lbnNpb25hbGUgZGkgaW5wdXQuIExhIHBvcnppb25lIGNvbiBsYSBkYXRhIHBpw7kgdmljaW5hIGFsbGEgZGF0YSBkaSBnZXN0aW9uZSBkZWxsZSBpbnRvbGxlcmFuemUgdmVycsOgIHNlbGV6aW9uYXRhLiBRdWVzdG8gcGFyYW1ldHJvIHZpZW5lIHJpY2hpZXN0byBzZSBpbCBkYXRhc2V0IGRpIGlucHV0IGNvbnRpZW5lIGRhdGkgYW5udWFsaS48L3A+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3NwaWtldGhyZXNob2xkX3RhZzBAQFwiOiBcIjxwPkxhIHNvZ2xpYSBkZWxsJ3V0aWxpenpvIHBlciBwaWNjaGkgZGkgc21vcnphbWVudG8gbyBhbm9tYWxpZSBuZWxsYSB0cmFpZXR0b3JpYSBkZWwgdmFsb3JlIHBpeGVsLiBJbCB2YWxvcmUgZGV2ZSBvc2NpbGxhcmUgdHJhIDAgZSAxLCBkb3ZlIDEgc2lnbmlmaWNhIGNoZSBub24gYXZ2aWVuZSBsbyBzbW9yemFtZW50by4gTCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdCDDqCAwLjkuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc192ZXJ0ZXhjb3VudG92ZXJzaG9vdF90YWcwQEBcIjogXCI8cD5JbCBudW1lcm8gZGkgdmVydGljaSBhZ2dpdW50aXZpIHNvdHRvPHN0cm9uZz5tYXhfbnVtX3NlZ21lbnRzICsgMTwvc3Ryb25nPnB1w7IgZXNzZXJlIHV0aWxpenphdGEgcGVyIGFkZWd1YXJlIGlsIG1vZGVsbG8gZHVyYW50ZSBsbyBzdGFnZSBpbml6aWFsZSBkZWkgdmVydGljaSBkaSBpZGVudGlmaWNhemlvbmUuIFN1Y2Nlc3NpdmFtZW50ZSwgbmVsIHByb2Nlc3NvIGRpIG1vZGVsbGF6aW9uZSwgaWwgbnVtZXJvIGRpIHZlcnRpY2kgYWdnaXVudGl2aSB2ZXJyw6Agcmlkb3R0byBhIDxzdHJvbmc+bWF4X251bV9zZWdtZW50cyArIDE8L3N0cm9uZz4uIEwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQgw6ggMi48L3A+XCIsXG5cdFwiQEBNZXJnZS1SYXN0ZXJzX3Jhc3RlcnNfdGFnMEBAXCI6IFwiPHA+RGF0YXNldCByYXN0ZXIgZGkgaW5wdXQgbyBkYXRhc2V0IHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsaSBkYSB1bmlyZS48L3A+XCIsXG5cdFwiQEBNZXJnZS1SYXN0ZXJzX3Jlc29sdmVvdmVybGFwbWV0aG9kX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmljYSBpbCBtZXRvZG8gcGVyIGwndXRpbGl6em8gcGVyIHJpc29sdmVyZSBsYSBzb3ZyYXBwb3NpemlvbmUgZGkgcGl4ZWwgbmVpIGRhdGFzZXQgY29tYmluYXRpLjwvcD48dWw+PGxpPjxzdHJvbmc+UHJpbW88L3N0cm9uZz4tLUlsIHZhbG9yZSBkaSBwaXhlbCBuZWxsZSBhcmVlIGRpIG92ZXJsYXBwaW5nIMOoIGlsIHZhbG9yZSBkYSBwcmltbyByYXN0ZXIgbmVsbGEgbGlzdGEgZGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L2xpPjxsaT48c3Ryb25nPlVsdGltbzwvc3Ryb25nPi0tSWwgdmFsb3JlIHBpeGVsIG5lbGxlIGFyZWUgZGkgc292cmFwcG9zaXppb25lIMOoIGlsIHZhbG9yZSBkYWxsJ3VsdGltbyByYXN0ZXIgbmVsbGEgbGlzdGEgZGkgcmFzdGVyIGRpIGlucHV0LjwvbGk+PGxpPjxzdHJvbmc+TWluPC9zdHJvbmc+LS1JbCB2YWxvcmUgcGl4ZWwgbmVsbGUgYXJlZSBkaSBzb3ZyYXBwb3NpemlvbmUgw6ggaWwgdmFsb3JlIG1pbmltbyBkZWkgcGl4ZWwgZGkgc292cmFwcG9zaXppb25lLjwvbGk+PGxpPjxzdHJvbmc+TWF4PC9zdHJvbmc+LS1JbCB2YWxvcmUgcGl4ZWwgbmVsbGUgYXJlZSBkaSBzb3ZyYXBwb3NpemlvbmUgw6ggaWwgdmFsb3JlIG1hc3NpbW8gZGkgcGl4ZWwgZGkgc292cmFwcG9zaXppb25lLjwvbGk+PGxpPjxzdHJvbmc+TWVkaWE8L3N0cm9uZz4tLUlsIHZhbG9yZSBwaXhlbCBuZWxsZSBhcmVlIGRpIHNvdnJhcHBvc2l6aW9uZSDDqCBsYSBtZWRpYSBkZWkgcGl4ZWwgZGkgc292cmFwcG9zaXppb25lLjwvbGk+PGxpPjxzdHJvbmc+U29tbWE8L3N0cm9uZz4tLUlsIHZhbG9yZSBwaXhlbCBuZWxsZSBhcmVlIGRpIHNvdnJhcHBvc2l6aW9uZSDDqCBsYSBzb21tYSB0b3RhbGUgZGVpIHBpeGVsIGRpIHNvdnJhcHBvc2l6aW9uZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9jeWNsZXVuaXRfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGwndW5pdMOgIGRpIHRlbXBvIGRhIHV0aWxpenphcmUgcGVyIGxhIGx1bmdoZXp6YSBkaSB1biBjaWNsbyBhcm1vbmljby48L3A+PHVsPjxsaT48c3Ryb25nPkdpb3JuaTwvc3Ryb25nPi0tTCd1bml0w6AgcGVyIGxhIGx1bmdoZXp6YSBkZWwgY2ljbG8gYXJtb25pY28gw6ggZ2lvcm5pLjwvbGk+PGxpPjxzdHJvbmc+QW5uaTwvc3Ryb25nPi0tTCd1bml0w6AgcGVyIGxhIGx1bmdoZXp6YSBkbCBjaWNsbyBhcm1vbmljbyDDqCBhbm5pLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9kaW1lbnNpb25uYW1lX3RhZzBAQFwiOiBcIjxwPkxhIGRpbWVuc2lvbmUgbHVuZ28gbGEgcXVhbGUgdW4gdHJlbmQgdmVycsOgIGVzdHJhdHRvIHBlciBsYSB2YXJpYWJpbGUgbyBsZSB2YXJpYWJpbGkgc2VsZXppb25hdGUgbmVsbCdhbmFsaXNpLjwvcD5cIixcblx0XCJAQEdlbmVyYXRlLVRyZW5kX2hhcm1vbmljZnJlcXVlbmN5X3RhZzBAQFwiOiBcIjxwPklsIG51bWVybyBkaSBmcmVxdWVuemEgw6ggZGEgdXRpbGl6emFyZSBuZWxsJ2FkYXR0YW1lbnRvIGRlbCB0cmVuZC4gUXVlc3RvIHBhcmFtZXRybyBzcGVjaWZpY2EgbGEgZnJlcXVlbnphIGRpIGNpY2xpIGluIHVuIGFubm8uIElsIHZhbG9yZSBkaSBkZWZhdWx0IMOoIDEsIG8gdW4gY2ljbG8gYXJtb25pY28gcGVyIGFubm8uPC9wPjxwPlF1ZXN0byBwYXJhbWV0cm8gw6ggaW5jbHVzbyBzb2xhbWVudGUgbmVsbCdhbmFsaXNpIGRlbCB0cmVuZCBwZXIgdW5hIHJlZ3Jlc3Npb25lIGFybW9uaWNhLjwvcD5cIixcblx0XCJAQEdlbmVyYXRlLVRyZW5kX2lnbm9yZW5vZGF0YV90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2Egc2UgdmFsb3JpIG5vZGF0YSB2ZW5nYW5vIGlnbm9yYXRpIG5lbGwnYW5hbGlzaS48L3A+PHVsPjxsaT5TZWxlemlvbmF0by0tTCdhbmFsaXNpIGluY2x1ZGVyw6AgdHV0dGkgaSBwaXhlbCB2YWxpZGkgbHVuZ28gdW5hIGRpbWVuc2lvbmUgZGF0YSBlIGlnbm9yZXLDoCB0dXR0aSBpIHBpeGVsIG5vZGF0YS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48bGk+Tm9uIHNlbGV6aW9uYXRhLS1MJ2FuYWxpc2kgcmlzdWx0ZXLDoCBpbiBub2RhdGEgc2UgY2kgc29ubyB2YWxvcmkgbm9kYXRhIHBlciBwaXhlbCBsdW5nbyBsYSBkaW1lbnNpb25lIGRhdGEuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfbGVuZ3Rob2ZjeWNsZV90YWcwQEBcIjogXCI8cD5MYSBsdW5naGV6emEgZGVsbGEgdmFyaWF6aW9uZSBwZXJpb2RpY2EgZGEgbW9kZWxsYXJlLiBMJ3VuaXTDoCDDqCBnaW9ybmksIGluZGlwZW5kZW50ZW1lbnRlIGRhbGwndW5pdMOgIGRpIHRlbXBvIGRlaSBkYXRpIGRpIGlucHV0LiBBZCBlc2VtcGlvLCBpbCB2ZXJkZSBkZWxsZSBmb2dsaWUgaGEgc3Blc3NvIHVuIGZvcnRlIGNpY2xvIGRpIHZhcmlhemlvbmUgaW4gdW4gc29sbyBhbm5vLCBxdWluZGkgbGEgbHVuZ2hlenphIGRlbCBjaWNsbyDDqCBkaSAzNjUsMjUsIGFuY2hlIHNlIGkgZGF0aSBkaSBpbnB1dCBzb25vIGlsIHZlcmRlIG1lbnNpbGUuIEkgZGF0aSBkaSB0ZW1wZXJhdHVyYSBvcmFyaWEgaGFubm8gdW4gZm9ydGUgY2ljbG8gZGkgdmFyaWF6aW9uZSBpbiB1biBzb2xvIGdpb3JubywgcXVpbmRpIGxhIGx1bmdoZXp6YSBkZWwgY2ljbG8gw6ggMS48L3A+PHA+TGEgbHVuZ2hlenphIHByZWRlZmluaXRhIMOoIGRpIDM2NSwyNSBnaW9ybmkgcGVyIGkgZGF0aSBjaGUgdmFyaWFubyBzdSB1biBjaWNsbyBhbm51YWxlLjwvcD5cIixcblx0XCJAQEdlbmVyYXRlLVRyZW5kX3AtdmFsdWVvZnNsb3BlY29lZmZpY2llbnRfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIHNlIGNhbGNvbGFyZSBsYSBzdGF0aXN0aWNhIGRlbCB2YWxvcmUgcCBwZXIgaWwgY29lZmZpY2llbnRlIGRpIHBlbmRlbnphIGRlbGxhIGxpbmVhIGRpIHRyZW5kLjwvcD48dWw+PGxpPlNlbGV6aW9uYXRhLS1JbCB2YWxvcmUgcCBzYXLDoCBjYWxjb2xhdG8gZSB2aXN1YWxpenphdG8gbmVpIGRldHRhZ2xpIGFsIGNvbXBsZXRhbWVudG8gZGVsbGEgZnVuemlvbmUuPC9saT48bGk+Tm9uIHNlbGV6aW9uYXRhLS1JbCB2YWxvcmUgcCBub24gc2Fyw6AgY2FsY29sYXRvLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9wb2x5bm9taWFsb3JkZXJfdGFnMEBAXCI6IFwiPHA+SWwgbnVtZXJvIGRpIG9yZGluZSBwb2xpbm9taW5hbGUgZGEgdXRpbGl6emFyZSBuZWxsJ2FkYXR0YW1lbnRvIGRlbCB0cmVuZC4gUXVlc3RvIHBhcmFtZXRybyBzcGVjaWZpY2EgbCdvcmRpbmUgcG9saW5vbWlhbGUuIElsIHZhbG9yZSBkaSBkZWZhdWx0IMOoIDIsIG8gcG9saW5vbWluYWxlIGRpIHNlY29uZG8gb3JkaW5lLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIGluY2x1c28gbmVsbCdhbmFsaXNpIGRlbCB0cmVuZCBwZXIgdW5hIHJlZ3Jlc3Npb25lIHBvbGlub21pbmFsZS48L3A+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9yLXNxdWFyZWRfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIHNlIGNhbGNvbGFyZSBsYSBzdGF0aXN0aWNhIGJvbnTDoCBkaSBhZGF0dGFtZW50byBkZWwgY29lZmZpY2llbnRlIGRpIGRldGVybWluYXppb25lIHBlciBsYSBsaW5lYSBkaSBhZGF0dGFtZW50byBkZWwgdHJlbmQuPC9wPjx1bD48bGk+U2VsZXppb25hdG8tLUwnaW5kaWNlIGRpIGRldGVybWluYXppb25lIHZlcnLDoCBjYWxjb2xhdG8gZSBtb3N0cmF0byBuZWkgZGV0dGFnbGkgcXVhbmRvIGxhIGZ1bnppb25lIMOoIGNvbXBsZXRhLjwvbGk+PGxpPk5vbiBzZWxlemlvbmF0by0tTCdpbmRpY2UgZGkgZGV0ZXJtaW5hemlvbmUgbm9uIHNhcsOgIGNhbGNvbGF0by4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfcmFzdGVyX3RhZzBAQFwiOiBcIjxwPklsIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBkaSBpbnB1dC48L3A+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9ybXNlX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmljYSBzZSBnZW5lcmFyZSBsYSByYWRpY2UgZGVsbCdlcnJvcmUgcXVhZHJhdGljbyBtZWRpbyAoUk1TRSkgZGVsbGEgbGluZWEgZGkgYWRhdHRhbWVudG8gZGVsIHRyZW5kLjwvcD48dWw+PGxpPlNlbGV6aW9uYXRvLS1JbCBSTVNFIHZlcnLDoCBjYWxjb2xhdG8gZSBtb3N0cmF0byBuZWkgZGV0dGFnbGkgcXVhbmRvIGxhIGZ1bnppb25lIMOoIGNvbXBsZXRhLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L2xpPjxsaT5TZWxlemlvbmF0by0tSWwgUk1TRSBub24gdmVycsOgIGNhbGNvbGF0by48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9zZWFzb25hbHBlcmlvZF90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2EgbCd1bml0w6AgZGkgdGVtcG8gdXNhdGEgcGVyIGxhIGx1bmdoZXp6YSBkaSB1biBwZXJpb2RvIHN0YWdpb25hbGUgcXVhbmRvIHZpZW5lIGVzZWd1aXRvIHVuIHRlc3RvIFNlYXNvbmFsLUtlbmRhbGwuPC9wPjx1bD48bGk+R2lvcm5pLS1MJ3VuaXTDoCBwZXIgbGEgbHVuZ2hlenphIGRpIHVuIHBlcmlvZG8gc3RhZ2lvbmFsZSDDqCBnaW9ybmkuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBkaSBkZWZhdWx0LjwvbGk+PGxpPk1lc2ktLUwndW5pdMOgIHBlciBsYSBsdW5naGV6emEgZGkgdW4gcGVyaW9kbyBzdGFnaW9uYWxlIMOoIG1lc2kuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfdHJlbmR0eXBlX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmljYSBpbCB0aXBvIGRpIGxpbmVhIGRhIHV0aWxpenphcmUgcGVyIGFkYXR0YXJlIGkgdmFsb3JpIGRlaSBwaXhlbCBsdW5nbyB1bmEgZGltZW5zaW9uZS48L3A+PHVsPjxsaT48c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz46IGFkYXR0YSBpIHZhbG9yaSBkZWkgcGl4ZWwgcGVyIHVuYSB2YXJpYWJpbGUgbHVuZ28gbGEgbGluZWEgZGkgdHJlbmQgbGluZWFyZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5Bcm1vbmljYTwvc3Ryb25nPi0tU2kgYWRhdHRhIGFpIHZhbG9yaSBkZWkgcGl4ZWwgcGVyIHVuYSB2YXJpYWJpbGUgbHVuZ28gdW5hIGxpbmVhIHRyZW5kIGFybW9uaWNhLjwvbGk+PGxpPjxzdHJvbmc+UG9saW5vbWluYWxlPC9zdHJvbmc+LS1TaSBhZGF0dGEgYWkgdmFsb3JpIGRlaSBwaXhlbCBwZXIgdW5hIHZhcmlhYmlsZSBsdW5nbyB1bmEgbGluZWEgZGkgdHJlbmQgcG9saW5vbWluYWxlIGRpIHNlY29uZG8gb3JkaW5lLjwvbGk+PGxpPjxzdHJvbmc+TWFubi1LZW5kYWxsPC9zdHJvbmc+LS1WYWxvcmkgZGkgcGl4ZWwgdmFyaWFiaWxpIHZlcnJhbm5vIHZhbHV0YXRhIHV0aWxpenphbmRvIGlsIHRlc3RpIGRpIHRyZW5kIE1hbm4tS2VuZGFsbC48L2xpPjxsaT48c3Ryb25nPlNlYXNvbmFsIEtlbmRhbGw8L3N0cm9uZz4tLVZhbG9yaSBkaSBwaXhlbCB2YXJpYWJpbGkgdmVycmFubm8gdmFsdXRhdGkgdXRpbGl6emFuZG8gdGVzdCBkaSB0cmVuZCBTZWFzb25hbC1LZW5kYWxsLjwvbGk+PC91bD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX2NlbGxzaXpldHlwZV90YWcwQEBcIjogXCI8cD5TY2VnbGllcmUgcXVhbGUgZ3JhbmRlenphIGRpIGNlbGxhIHV0aWxpenphcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQuIFNlIHR1dHRlIGxlIGdyYW5kZXp6ZSBkaSBjZWxsZSBkaSBpbnB1dCBzb25vIGxlIHN0ZXNzZSwgdHV0dGUgbGUgb3B6aW9uaSBwcm9kdXJyYW5ubyBnbGkgc3Rlc3NpIHJpc3VsdGF0aS48L3A+PHVsPjxsaT5QcmltbyBkaTogdXRpbGl6emEgbGEgcHJpbWEgZ3JhbmRlenphIGRpIGNlbGxhIGRlaSByYXN0ZXIgZGkgaW5wdXQuPC9saT48bGk+TWluIGRpOiB1dGlsaXp6YSBsYSBncmFuZGV6emEgZGkgY2VsbGEgbWlub3JlIGRpIHJhc3RlciBkaSBpbnB1dC48L2xpPjxsaT5NYXggZGk6IHV0aWxpenphIGxhIGdyYW5kZXp6YSBkaSBjZWxsYSBtYWdnaW9yZSBkaSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48bGk+TWVkaWEgZGk6IHV0aWxpenphIGxhIGdyYW5kZXp6YSBkaSBjZWxsYSBtZWRpYSBkaSB0dXR0aSBpIHJhc3RlciBkaSBpbnB1dC48L2xpPjxsaT5VbHRpbW8gZGk6IHV0aWxpenphIGwndWx0aW1hIGdyYW5kZXp6YSBkaSBjZWxsYSBkaSByYXN0ZXIgZGkgaW5wdXQuPC9saT48L3VsPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfY29tcHV0ZWNoYW5nZW1ldGhvZF90YWcwQEBcIjogXCI8cD5JbCBtZXRvZG8gdXRpbGl6emF0byBwZXIgaWwgY2FsY29sby48L3A+PHVsPjxsaT48c3Ryb25nPkRpZmZlcmVuemE8L3N0cm9uZz46IFZlcnLDoCBjYWxjb2xhdGEgbGEgZGlmZmVyZW56YSBtYXRlbWF0aWNhLCBvIHNvdHRyYXppb25lLCB0cmEgaSB2YWxvcmkgZGVpIHBpeGVsIG5laSByYXN0ZXIgZGkgaW5ncmVzc28uIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS48L2xpPjxsaT48c3Ryb25nPkRpZmZlcmVuemEgcmVsYXRpdmE8L3N0cm9uZz46IGxhIGRpZmZlcmVuemEgZGVpIHZhbG9yaSBpbiBwaXhlbCwgY2hlIHRpZW5lIGNvbnRvIGRlbGxlIGdyYW5kZXp6ZSBkZWkgdmFsb3JpIGNvbmZyb250YXRpLCB2ZXJyw6AgY2FsY29sYXRhLjwvbGk+PGxpPjxzdHJvbmc+RGlmZmVyZW56YSBjYXRlZ29yaWNhPC9zdHJvbmc+OiBsYSBkaWZmZXJlbnphIHRyYSBkdWUgcmFzdGVyIGNhdGVnb3JpY2kgbyB0ZW1hdGljaSB2ZXJyw6AgY2FsY29sYXRhLCBkb3ZlIGwnb3V0cHV0IGNvbnRpZW5lIHRyYW5zaXppb25pIGRpIGNsYXNzaSBjaGUgc2kgdmVyaWZpY2FubyB0cmEgZHVlIHJhc3Rlci48L2xpPjxsaT48c3Ryb25nPkRpZmZlcmVuemEgc3BldHRyYWxlIGV1Y2xpZGVhPC9zdHJvbmc+OiBsYSBkaXN0YW56YSBldWNsaWRlYSB0cmEgaSB2YWxvcmkgaW4gcGl4ZWwgZGVpIGR1ZSByYXN0ZXIgbXVsdGliYW5kYSB2aWVuZSBjYWxjb2xhdGEuPC9saT48bGk+PHN0cm9uZz5EaWZmZXJlbnphIGFuZ29sbyBzcGV0dHJhbGU8L3N0cm9uZz46IHZpZW5lIGNhbGNvbGF0byBsJ2FuZ29sbyBzcGV0dHJhbGUgdHJhIGkgdmFsb3JpIGluIHBpeGVsIGRlaSBkdWUgcmFzdGVyIG11bHRpYmFuZGEuIEwnb3V0cHV0IMOoIGluIHJhZGlhbnRpLjwvbGk+PGxpPjxzdHJvbmc+QmFuZGEgY29uIGlsIG1hZ2dpb3IgbnVtZXJvIGRpIGNhbWJpYW1lbnRpPC9zdHJvbmc+OiB2ZXJyw6AgY2FsY29sYXRhIGxhIGJhbmRhIGNoZSByYXBwcmVzZW50YSBsYSB2YXJpYXppb25lIG1hZ2dpb3JlIGluIG9nbmkgcGl4ZWwgdHJhIGR1ZSByYXN0ZXIgbXVsdGliYW5kYS48L2xpPjwvdWw+PHA+U2UgaWwgPHN0cm9uZz5tZXRvZG8gZGkgY2FsY29sbyBkZWxsZSBtb2RpZmljaGU8L3N0cm9uZz7DqCBpbXBvc3RhdG8gc3U8c3Ryb25nPkRpZmZlcmVuemEgY2F0ZWdvcmljYTwvc3Ryb25nPmUgdW5vIGRlZ2xpIGlucHV0IG5vbiDDqCBjYXRlZ29yaWNvLCB2ZXJyw6AgY2FsY29sYXRhIHVuYSBzZW1wbGljZSBkaWZmZXJlbnphLjwvcD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX2RlZmluZXRyYW5zaXRpb25jb2xvcnNfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGlsIG1ldG9kbyBkYSB1dGlsaXp6YXJlIHBlciBzaW1ib2xlZ2dpYXJlIGkgcGl4ZWwgY2hlIGhhbm5vIGNhbWJpYXRvIGNsYXNzZS48L3A+PHVsPjxsaT48c3Ryb25nPk1lZGlhIGRhIGUgdmVyc28gaSBjb2xvcmk8L3N0cm9uZz4tLUlsIGNvbG9yaSBkZWwgcGl4ZWwgc2Fyw6AgbGEgbWVkaWEgZGVsIGNvbG9yaSBkZWxsYSBzdWEgY2xhc3NlIG9yaWdpbmFsZSBlIGRlbCBjb2xvcmkgZGVsbGEgY2xhc3NlIGZpbmFsZS48L2xpPjxsaT48c3Ryb25nPlVzYSBkYWkgY29sb3JpPC9zdHJvbmc+LS1JbCBjb2xvcmkgZGVsIHBpeGVsIHNhcsOgIGlsIGNvbG9yaSBkZWxsYSBzdWEgY2xhc3NlIG9yaWdpbmFsZTwvbGk+PGxpPjxzdHJvbmc+VXNhIGEgY29sb3JpPC9zdHJvbmc+LS1JbCBjb2xvcmUgZGVsIHBpeGVsIHNhcsOgIGlsIGNvbG9yaSBkZWxsYSBzdWEgY2xhc3NlIGZpbmFsZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9leHRlbnR0eXBlX3RhZzBAQFwiOiBcIjxwPlNjZWdsaWVyZSBxdWFsZSBlc3RlbnNpb25lIGRhIHV0aWxpenphcmUgbmVsIHJhc3RlciBkaSBvdXRwdXQ6PC9wPjx1bD48bGk+UHJpbW8gZGk6IHVzYXJlIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgaW4gZWxhYm9yYXppb25lLjwvbGk+PGxpPkludGVyc2V6aW9uZSBkaTogdXNhcmUgbCdlc3RlbnNpb25lIGRpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgaW4gZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L2xpPjxsaT5VbmlvbmUgZGk6IHVzYXJlIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS48L2xpPjxsaT5VbHRpbW8gZGk6IHVzYXJlIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuPC9saT48L3VsPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfZmlsdGVybWV0aG9kX3RhZzBAQFwiOiBcIjxwPlNjZWdsaWVyZSBpbCBtZXRvZG8gZGkgZmlsdHJvIHBlciB1biBjYWxjb2xvIGRpIG1vZGlmaWNhIGNhdGVnb3JpY28uPC9wPjx1bD48bGk+PHN0cm9uZz5NYW50aWVuaSB0dXR0bzwvc3Ryb25nPi0tVHV0dGUgbGUgY2xhc3NpIHNvbm8gaW5jbHVzZSBuZWxsJ291dHB1dCBlIG5vbiB2ZXJyw6AgZXNlZ3VpdG8gYWxjdW4gZmlsdHJhZ2dpby4gU2NlZ2xpZXJlIHF1ZXN0YSBvcHppb25lIHBlciB2aXN1YWxpenphcmUgbGEgbW9kaWZpY2EgZSBsYSBwZXJzaXN0ZW56YSBpbiB1bmEgZGF0YXNldCBzaW5nb2xvLjwvbGk+PGxpPjxzdHJvbmc+TWFudGllbmkgc29sbyBwaXhlbCBjYW1iaWF0aTwvc3Ryb25nPi0tU29sYW1lbnRlIGxlIGNsYXNzaSBjaGUgaGFubm8gY2FtYmlhdG8gZGEgdW4gdGlwbyBkaSBjbGFzc2UgYSB1biBhbHRybyB0aXBvIGRpIGNsYXNzZSBzb25vIGluY2x1c2UgbmVsbCdvdXRwdXQuIFNjZWdsaWVyZSBxdWVzdGEgb3B6aW9uZSBzZSBzaSDDqCBpbnRlcmVzc2F0aSBhbGxhIG1vZGlmaWNhLjwvbGk+PGxpPjxzdHJvbmc+TWFudGllbmkgc29sbyBwaXhlbCBub24gY2FtYmlhdGk8L3N0cm9uZz4tLVNvbGFtZW50ZSBsZSBjbGFzc2kgY2hlIG5vbiBoYW5ubyBjYW1iaWF0byBzb25vIGluY2x1c2UgbmVsbCdvdXRwdXQuIFNjZWdsaWVyZSBxdWVzdGEgb3B6aW9uZSBzZSBzaSDDqCBpbnRlcmVzc2F0aSBuZWxsYSBwZXJzaXN0ZW56YS48L2xpPjwvdWw+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9mcm9tY2xhc3N2YWx1ZXNfdGFnMEBAXCI6IFwiPHA+SWwgdmFsb3JlIGRlbGxhIGNsYXNzZSBkYTxzdHJvbmc+RGEgcmFzdGVyPC9zdHJvbmc+aW5jbHVzbyBuZWwgY2FsY29sbywgc2UgY29tcGFyYW5kbyBkdWUgcmFzdGVyIGNhdGVnb3JpY2kuIFF1ZXN0YSDDqCB1bmEgbGlzdGEgc2VwYXJhdGEgZGEgc3BhemkgZGkgdmFsb3JpIGludGVyaSBjb3JyaXNwb25kZW50aSBhbCBjYW1wbyA8c3Ryb25nPlZhbG9yZUNsYXNzZTwvc3Ryb25nPiBuZWwgZGF0YXNldCBkZWwgcmFzdGVyIGRpIGlucHV0LjwvcD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX2Zyb21yYXN0ZXJfdGFnMEBAXCI6IFwiPHA+SWwgcHJpbW8gcmFzdGVyIGRhIHV0aWxpenphcmUgbmVsIGNhbGNvbG8uIFBlciB2YWx1dGFyZSBsYSBtb2RpZmljYSBkYWxsYSB2b2x0YSAxIChwcmltYSkgYWxsYSAyIChwacO5IHRhcmRpKSwgZGlnaXRhcmUgaWwgcmFzdGVyIGRpIHZvbHRhIDEgcXXDrC48L3A+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV90b2NsYXNzdmFsdWVzX3RhZzBAQFwiOiBcIjxwPkkgdmFsb3JpIGRpIGNsYXNzZSBkYSA8c3Ryb25nPlJhc3RlciB0bzwvc3Ryb25nPmRhIGluY2x1ZGVyZSBuZWwgY2FsY29sbywgc2UgY29tcGFyYW5kbyBkdWUgcmFzdGVyIGNhdGVnb3JpY2kuIFF1ZXN0YSDDqCB1bmEgbGlzdGEgc2VwYXJhdGEgZGEgc3BhemkgZGkgdmFsb3JpIGludGVyaSBjb3JyaXNwb25kZW50aSBhbCBjYW1wbyA8c3Ryb25nPlZhbG9yZUNsYXNzZTwvc3Ryb25nPiBuZWwgZGF0YXNldCBkZWwgcmFzdGVyIGRpIGlucHV0LjwvcD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX3RvcmFzdGVyX3RhZzBAQFwiOiBcIjxwPklsIHNlY29uZG8gcmFzdGVyIGRhIHV0aWxpenphcmUgbmVsIGNhbGNvbG8uIFBlciB2YWx1dGFyZSBsYSBtb2RpZmljYSBkYWxsYSB2b2x0YSAxIChwcmltYSkgYWxsYSAyIChwacO5IHRhcmRpKSwgZGlnaXRhcmUgaWwgcmFzdGVyIGRpIHZvbHRhIDIuPC9wPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfdXNlY29sb3JtZXRob2RfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGlsIG1ldG9kbyBkYSB1dGlsaXp6YXJlIHBlciBzaW1ib2xlZ2dpYXJlIGkgcGl4ZWwgY2hlIGhhbm5vIGNhbWJpYXRvIGNsYXNzZS48L3A+PHVsPjxsaT48c3Ryb25nPk1lZGlhIGRhIGUgdmVyc28gaSBjb2xvcmk8L3N0cm9uZz4tLUlsIGNvbG9yaSBkZWwgcGl4ZWwgc2Fyw6AgbGEgbWVkaWEgZGVsIGNvbG9yaSBkZWxsYSBzdWEgY2xhc3NlIG9yaWdpbmFsZSBlIGRlbCBjb2xvcmkgZGVsbGEgY2xhc3NlIGZpbmFsZS48L2xpPjxsaT48c3Ryb25nPlVzYSBkYWkgY29sb3JpPC9zdHJvbmc+LS1JbCBjb2xvcmkgZGVsIHBpeGVsIHNhcsOgIGlsIGNvbG9yaSBkZWxsYSBzdWEgY2xhc3NlIG9yaWdpbmFsZTwvbGk+PGxpPjxzdHJvbmc+VXNhIGEgY29sb3JpPC9zdHJvbmc+LS1JbCBjb2xvcmUgZGVsIHBpeGVsIHNhcsOgIGlsIGNvbG9yaSBkZWxsYSBzdWEgY2xhc3NlIGZpbmFsZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9maWVsZG5hbWVmb3JjbGFzc25hbWVzaW5mcm9tcmFzdGVyX3RhZzBAQFwiOiBcIjxwPlVuIGNhbXBvIGNoZSBtZW1vcml6emEgaSBub21pIGRlbGxlIGNsYXNzaSBuZWxsJ2lucHV0IDxzdHJvbmc+RGEgUmFzdGVyPC9zdHJvbmc+LiBMbyBzdHJ1bWVudG8gY2VyY2EgYXV0b21hdGljYW1lbnRlIGlsIGNhbXBvIDxzdHJvbmc+Tm9tZSBjbGFzc2U8L3N0cm9uZz4gbyA8c3Ryb25nPk5vbWVfY2xhc3NlPC9zdHJvbmc+IGRhIHV0aWxpenphcmUuPC9wPjxwPlVzYSBxdWVzdGEgb3B6aW9uZSBzZSBsJ2lucHV0IG5vbiBjb250aWVuZSBxdWVzdGkgbm9taSBkaSBjYW1waSBzdGFuZGFyZC48L3A+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9maWVsZG5hbWVmb3JjbGFzc25hbWVzaW50b3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5VbiBjYW1wbyBjaGUgbWVtb3JpenphIGkgbm9taSBkZWxsZSBjbGFzc2kgbmVsbCdpbnB1dCA8c3Ryb25nPkEgUmFzdGVyPC9zdHJvbmc+LiBMbyBzdHJ1bWVudG8gY2VyY2hlcsOgIGF1dG9tYXRpY2FtZW50ZSBpbCBjYW1wbyA8c3Ryb25nPk5vbWUgY2xhc3NlPC9zdHJvbmc+IG8gPHN0cm9uZz5Ob21lX2NsYXNzZTwvc3Ryb25nPiBkYSB1dGlsaXp6YXJlLjwvcD48cD5Vc2EgcXVlc3RhIG9wemlvbmUgc2UgbCdpbnB1dCBub24gY29udGllbmUgcXVlc3RpIG5vbWkgZGkgY2FtcGkgc3RhbmRhcmQuPC9wPlwiLFxuXHRcIkBAU3RhdGlzdGljc19udW1iZXJvZmNvbHVtbnNfdGFnMEBAXCI6IFwiPHA+SWwgbnVtZXJvIGRpIGNvbG9ubmUgZGkgcGl4ZWwgZGEgdXRpbGl6emFyZSBpbiB1bmEgZGltZW5zaW9uZSBmb2NhbGUgZGkgdmljaW5hbnphLjwvcD5cIixcblx0XCJAQFN0YXRpc3RpY3NfbnVtYmVyb2Zyb3dzX3RhZzBAQFwiOiBcIjxwPklsIG51bWVybyBkaSByaWdoZSBkaSBwaXhlbCBkYSB1dGlsaXp6YXJlIGluIHVuYSBkaW1lbnNpb25lIGZvY2FsZSBkaSB2aWNpbmFuemEuPC9wPlwiLFxuXHRcIkBAU3RhdGlzdGljc19vbmx5ZmlsbG5vZGF0YXBpeGVsc190YWcwQEBcIjogXCI8cD5SaWVtcGllIGxlIGxhY3VuZSBOb0RhdGEgaW4gdXNjaXRhLiBRdWVzdGEgZnVuemlvbmUgw6ggdXRpbGUgcXVhbmRvIHNvbm8gcHJlc2VudGkgbGluZWUgcmltb3NzZSBuZWxsJ2ltbWFnaW5lLjwvcD5cIixcblx0XCJAQFN0YXRpc3RpY3NfcmFzdGVyX3RhZzBAQFwiOiBcIjxwPklsIHJhc3RlciBpbnB1dCBzdSBjdWkgZXNlZ3VpcmUgbGUgc3RhdGlzdGljaGUgZm9jYWxpLjwvcD5cIixcblx0XCJAQFN0YXRpc3RpY3Nfc3RhdGlzdGljc3R5cGVfdGFnMEBAXCI6IFwiPHA+SSBzZWd1ZW50aSBzb25vIHNldHRlIHRpcGkgZGkgZnVuemlvbmkgc3RhdGlzdGljaSBmb2NhbGk6PC9wPjx1bD48bGk+TWluaW1vOiBjYWxjb2xhIGlsIHZhbG9yZSBtaW5pbW8gZGVpIHBpeGVsIGFsbCdpbnRlcm5vIGRpIHVuIHF1YXJ0aWVyZS48L2xpPjxsaT5NYXNzaW1vOiBjYWxjb2xhIGlsIHZhbG9yZSBtYXNzaW1vIGRpIHBpeGVsIGFsbCdpbnRlcm5vIGRpIHVuIHF1YXJ0aWVyZS48L2xpPjxsaT5NZWRpbzogY2FsY29sYSBpbCB2YWxvcmUgbWVkaW8gZGVpIHBpeGVsIGFsbCdpbnRlcm5vIGRpIHVuIHF1YXJ0aWVyZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48bGk+RGV2aWF6aW9uZSBzdGFuZGFyZDogY2FsY29sYSBpbCB2YWxvcmUgZGkgZGV2aWF6aW9uZSBzdGFuZGFyZCBkZWkgcGl4ZWwgYWxsJ2ludGVybm8gZGkgdW4gcXVhcnRpZXJlLjwvbGk+PGxpPk1lZGlhbm86IGNhbGNvbGEgaWwgdmFsb3JlIG1lZGlhbm8gZGVpIHBpeGVsIGFsbCdpbnRlcm5vIGRpIHVuIHF1YXJ0aWVyZS48L2xpPjxsaT5NYWdnaW9yYW56YTogY2FsY29sYSBpbCB2YWxvcmUgZGkgbWFnZ2lvcmFuemEsIG8gaWwgdmFsb3JlIGNoZSBzaSB2ZXJpZmljYSBwacO5IGZyZXF1ZW50ZW1lbnRlIGRlaSBwaXhlbCBhbGwnaW50ZXJubyBkaSB1biBxdWFydGllcmUuPC9saT48bGk+TWlub3JhbnphOiBjYWxjb2xhIGlsIHZhbG9yZSBkaSBtaW5vcmFuemEgbyBpbCB2YWxvcmUgY2hlIHNpIHZlcmlmaWNhIG1lbm8gZnJlcXVlbnRlbWVudGUgZGVpIHBpeGVsIGFsbCdpbnRlcm5vIGRpIHVuIHF1YXJ0aWVyZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19jaGFuZ2VkaXJlY3Rpb25fdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGxhIGRpcmV6aW9uZSBkZWwgY2FtYmlhbWVudG8gZGEgaW5jbHVkZXJlIG5lbGwnYW5hbGlzaS48L3A+PHA+UXVlc3RvIHBhcmFtZXRybyDDqCBkaXNwb25pYmlsZSBzb2xhbWVudGUgcXVhbmRvIGlsIHJhc3RlciBkaSBhbmFsaXNpIGRpIG1vZGlmaWNhIGRlbGwnaW5wdXQgw6ggbCdvdXRwdXQgZGFnbGkgc3RydW1lbnRpIExhbmRUcmVuZHIuPC9wPjx1bD48bGk+PHN0cm9uZz5UdXR0ZSBsZSBkaXJlemlvbmk8L3N0cm9uZz4tLVR1dHRlIGxlIGRpcmV6aW9uaSBkaSBtb2RpZmljYSBzb25vIGluY2x1c2UgbmVsbCdvdXRwdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBkaSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+Q3Jlc2NlbnRlPC9zdHJvbmc+LS1Tb2xhbWVudGUgbGEgbW9kaWZpY2EgaW4gZGlyZXppb25lIHBvc2l0aXZhIG8gY3Jlc2NlbnRlIMOoIGluY2x1c2EgbmVsbCdvdXRwdXQuPC9saT48bGk+PHN0cm9uZz5EZWNyZXNjZW50ZTwvc3Ryb25nPi0tU29sYW1lbnRlIGxhIG1vZGlmaWNhIGluIGRpcmV6aW9uZSBuZWdhdGl2YSBvIGRlY3Jlc2NlbnRlIMOoIGluY2x1c2EgbmVsbCdvdXRwdXQuPC9saT48L3VsPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfY2hhbmdldHlwZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2EgbCdpbmZvcm1hemlvbmUgZGkgbW9kaWZpY2EgZGEgY2FsY29sYXJlLjwvcD48dWw+PGxpPjxzdHJvbmc+T3JhcmlvIGRlbGwndWx0aW1vIGNhbWJpYW1lbnRvPC9zdHJvbmc+LS1PZ25pIHBpeGVsIGNvbnRpZW5lIGxhIGRhdGEgZGkgbW9kaWZpY2EgcGnDuSByZWNlbnRlIHBlciBxdWVsIHBpeGVsIGluIHVuYSBzZXJpZSBkaSBvcmFyaS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5PcmFyaW8gZGkgbW9kaWZpY2EgcGnDuSByZWNlbnRlPC9zdHJvbmc+LS1PZ25pIHBpeGVsIGNvbnRpZW5lIGxhIGRhdGEgZGVsbGEgcHJpbWEgbW9kaWZpY2EgcGVyIHF1ZWwgcGl4ZWwgbmVsbGEgc2VyaWUgZGkgb3JhcmkuPC9saT48bGk+PHN0cm9uZz5PcmFyaW8gZGVsbGEgbW9kaWZpY2EgbWFnZ2lvcmU8L3N0cm9uZz4tLU9nbmkgcGl4ZWwgY29udGllbmUgbGEgZGF0YSBkZWxsYSBtb2RpZmljYSBwacO5IHNpZ25pZmljYXRpdmEgcGVyIHF1ZWwgcGl4ZWwgbmVsbGEgc2VyaWUgZGkgb3JhcmkuPC9saT48bGk+PHN0cm9uZz5OdW1lcm8gZGkgbW9kaWZpY2hlPC9zdHJvbmc+LU9nbmkgcGl4ZWwgY29udGllbmUgaWwgbnVtZXJvIHRvdGFsZSBkaSB2b2x0ZSBjaGUgaWwgcGl4ZWwgw6ggY2FtYmlhdG8gbmVsbGEgc2VyaWUgZGkgb3JhcmkuPC9saT48bGk+PHN0cm9uZz5PcmFyaW8gZGkgbW9kaWZpY2EgcGnDuSBsdW5nYTwvc3Ryb25nPi0tT2duaSBwaXhlbCBjb250aWVuZSBsYSBkYXRhIGRlbGxhIG1vZGlmaWNhIGFsbGEgZmluZSBkZWwgc2VnbWVudG8gZGkgdHJhbnNpemlvbmUgcGnDuSBsdW5nbyBuZWxsYSBzZXJpZSBkaSBvcmFyaS48L2xpPjxsaT48c3Ryb25nPk9yYXJpbyBkaSBtb2RpZmljYSBwacO5IGJyZXZlPC9zdHJvbmc+LS1PZ25pIHBpeGVsIGNvbnRpZW5lIGxhIGRhdGEgZGVsbGEgbW9kaWZpY2EgYWxsYSBmaW5lIGRlbCBzZWdtZW50byBkaSB0cmFuc2l6aW9uZSBwacO5IGJyZXZlIGRlbGxhIHNlcmllIGRpIG9yYXJpLjwvbGk+PGxpPjxzdHJvbmc+T3JhcmlvIGRpIG1vZGlmaWNhIHBpw7kgdmVsb2NlPC9zdHJvbmc+LS1PZ25pIHBpeGVsIGNvbnRpZW5lIGxhIGRhdGEgZGVsbGEgbW9kaWZpY2EgYWxsYSBmaW5lIGRlbGxhIHRyYW5zaXppb25lIGNoZSBzaSDDqCB2ZXJpZmljYXRvIHBpw7kgcmFwaWRhbWVudGUuPC9saT48bGk+PHN0cm9uZz5PcmFyaW8gZGkgbW9kaWZpY2EgcGnDuSBsZW50YTwvc3Ryb25nPi0tT2duaSBwaXhlbCBjb250aWVuZSBsYSBkYXRhIGRlbGxhIG1vZGlmaWNhIGFsbGEgZmluZSBkZWxsYSB0cmFuc2l6aW9uZSBjaGUgc2kgw6ggdmVyaWZpY2F0byBwacO5IGxlbnRhbWVudGUuPC9saT48L3VsPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfZmlsdGVyYnlkdXJhdGlvbl90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2Egc2UgZmlsdHJhcmUgc2Vjb25kbyBkdXJhdGEgZGkgbW9kaWZpY2EuPC9wPjxwPjwvcD48dWw+PGxpPlNlbGV6aW9uYXRvLS1GaWx0cmEgcmlzdWx0YXRpIHBlciBkdXJhdGEgaW4gbW9kbyBjaGUgc29sYW1lbnRlIGxlIG1vZGlmaWNoZSBjaGUgc29ubyBkdXJhdGUgcGVyIHVuIGRldGVybWluYXRvIHBlcmlvZG8gZGkgdGVtcG8gc2lhbm8gaW5jbHVzZSBuZWxsJ291dHB1dC48L2xpPjxsaT5Ob24gc2VsZXppb25hdG8tLU5vbiBmaWx0cmEgcmlzdWx0YXRpIHBlciBkdXJhdGEuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBkaSBkZWZhdWx0LjwvbGk+PC91bD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIGRpc3BvbmliaWxlIHNvbG8gcXVhbmRvIGlsIHJhc3RlciBkaSBhbmFsaXNpIGRpIG1vZGlmaWNhIGRlbGwnaW5wdXQgw6ggbCdvdXRwdXQgZGFnbGkgc3RydW1lbnRpIExhbmRUcmVuZHIuPC9wPjxwPlNlIHF1ZXN0byBwYXJhbWV0cm8gw6ggc2VsZXppb25hdG8sIHNpIGRldm9ubyBpbXBvc3RhcmUgaSBwYXJhbWV0cmkgPHN0cm9uZz5EdXJhdGEgbWluaW1hPC9zdHJvbmc+ZSA8c3Ryb25nPkR1cmF0YSBtYXNzaW1hPC9zdHJvbmc+IHBlciBmaWx0cmFyZS48L3A+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19maWx0ZXJieW1hZ25pdHVkZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2Egc2UgZmlsdHJhcmUgcGVyIGdyYW5kZXp6YSBkaSBtb2RpZmljYS48L3A+PHVsPjxsaT5TZWxlemlvbmF0bzogZmlsdHJhIGkgcmlzdWx0YXRpIHBlciBncmFuZGV6emEgaW4gbW9kbyBjaGUgc29sYW1lbnRlIGxlIG1vZGlmaWNoZSBkaSB1bmEgZ3JhbmRlenphIGRhdGEgc2lhbm8gaW5jbHVzZSBuZWxsJ291dHB1dC48L2xpPjxsaT5Ob24gc2VsZXppb25hdG86IG5vbiBmaWx0cmEgaSByaXN1bHRhdGkgcGVyIGdyYW5kZXp6YS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48L3VsPjxwPlF1ZXN0byBwYXJhbWV0cm8gw6ggZGlzcG9uaWJpbGUgc29sbyBxdWFuZG8gbCdpbnB1dCBkZWwgcmFzdGVyIGRpIGFuYWxpc2kgZGkgbW9kaWZpY2Egw6ggbCcnb3V0cHV0IGRhZ2xpIHN0cnVtZW50aSBMYW5kVHJlbmRyLjwvcD48cD5TZSBxdWVzdG8gcGFyYW1ldHJvIMOoIHNlbGV6aW9uYXRvIHNpIGRldm9ubyBpbXBvc3RhcmUgaSBwYXJhbWV0cmkgPHN0cm9uZz5HcmFuZGV6emEgbWluaW1hPC9zdHJvbmc+ZTxzdHJvbmc+R3JhbmRlenphIG1hc3NpbWE8L3N0cm9uZz5wZXIgaWwgZmlsdHJhZ2dpby48L3A+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19maWx0ZXJieXllYXJfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIHNlIGxpbWl0YXJlIGwnb3V0cHV0IHNlY29uZG8gdW4gcmFuZ2UgZGkgYW5uaS48L3A+PHVsPjxsaT5TZWxlemlvbmF0bzogZmlsdHJhIGkgcmlzdWx0YXRpIGluIG1vZG8gY2hlIHNvbGFtZW50ZSBsZSBtb2RpZmljaGUgY2hlIG9jY29ycm9ubyBhbGwnaW50ZXJubyBkaSB1biByYW5nZSBkaSBhbm5pIHNwZWNpZmljbyBzb25vIGluY2x1c2UgbmVsbCdvdXRwdXQuPC9saT48bGk+Tm9uIHNlbGV6aW9uYXRvOiBub24gZmlsdHJhIHJpc3VsdGF0aSBwZXIgYW5uby4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48L3VsPjxwPlNlIHF1ZXN0byBwYXJhbWV0cm8gw6ggc2VsZXppb25hdG8sIHNpIGRldm9ubyBpbXBvc3RhcmUgaSBwYXJhbWV0cmkgPHN0cm9uZz5WYWxvcmUgbWluaW1vPC9zdHJvbmc+ZTxzdHJvbmc+VmFsb3JlIG1hc3NpbW88L3N0cm9uZz4gcGVyIGlsIGZpbHRyYWdnaW8uPC9wPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfZmlsdGVyYnlzdGFydHZhbHVlX3RhZzBAQFwiOiBcIjxwPkZpbHRyYSBpIHJpc3VsdGF0aSBwZXIgdmFsb3JlIGluaXppYWxlIGluIG1vZG8gY2hlIHNvbG8gaSBjYW1iaWFtZW50aSBkaSB1biBkYXRvIHZhbG9yZSBpbml6aWFsZSBzaWFubyBpbmNsdXNpIG5lbGwnb3V0cHV0LjwvcD5cIixcblx0XCJAQERldGVjdC1DaGFuZ2UtVXNpbmctQ2hhbmdlLUFuYWx5c2lzX2ZpbHRlcmJ5ZW5kdmFsdWVfdGFnMEBAXCI6IFwiPHA+RmlsdHJhIGkgcmlzdWx0YXRpIHBlciB2YWxvcmUgZmluYWxlIGluIG1vZG8gY2hlIHNvbG8gaSBjYW1iaWFtZW50aSBkaSB1biBkYXRvIHZhbG9yZSBmaW5hbGUgc2lhbm8gaW5jbHVzaSBuZWxsJ291dHB1dC48L3A+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19tYXhpbXVtbnVtYmVyb2ZjaGFuZ2VzX3RhZzBAQFwiOiBcIjxwPklsIG51bWVybyBtYXNzaW1vIGRpIG1vZGlmaWNoZSBwZXIgcGl4ZWwgZGEgY2FsY29sYXJlLiBJbCBudW1lcm8gaW5zZXJpdG8gY29ycmlzcG9uZGUgYWwgbnVtZXJvIGRlbGxlIGJhbmRlIG5lbCByYXN0ZXIgZGkgb3V0cHV0LiBMJ2ltcG9zdGF6aW9uZSBkaSBkZWZhdWx0IGUgMSwgc2lnbmlmaWNhIHNvbG8gY2hlIHVuYSBkZWxsZSBkYXRlIGRpIG1vZGlmaWNoZSDDqCBjYWxjb2xhdGEgZSBpbCByYXN0ZXIgZGkgb3V0cHV0IGNvbnRpZW5lIHNvbG8gdW5hIGJhbmRhLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIG5vbiDDqCBkaXNwb25pYmlsZSBxdWFuZG8gaWwgcGFyYW1ldHJvIDxzdHJvbmc+Q2FtYmlhIHRpcG88L3N0cm9uZz4gw6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+TnVtZXJvIGRpIG1vZGlmaWNoZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19yYXN0ZXJfdGFnMEBAXCI6IFwiPHA+SWwgcmFzdGVyIGRpIGFuYWxpc2kgZGkgbW9kaWZpY2EgZGkgaW5wdXQuPC9wPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfc2VnbWVudGRhdGVfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIHNlIGVzdHJhcnJlIGxhIGRhdGEgYWxsJ2luaXppbyBkaSB1biBzZWdtZW50byBkaSBtb2RpZmljYSBvIGFsbGEgZmluZS48L3A+PHA+UXVlc3RvIHBhcmFtZXRybyDDqCBkaXNwb25pYmlsZSBzb2xvIHF1YW5kbyBpbCByYXN0ZXIgZGkgYW5hbGlzaSBkaSBtb2RpZmljYSBkZWxsJ2lucHV0IMOoIGwnb3V0cHV0IGRhZ2xpIHN0cnVtZW50aSBMYW5kVHJlbmRyLjwvcD48dWw+PGxpPjxzdHJvbmc+SW5pemlvIGRlbCBzZWdtZW50bzwvc3Ryb25nPi0tRXN0cmFycmUgbGEgZGF0YSBhbGwnaW5pemlvIGRpIHVuIHNlZ21lbnRvIGRpIG1vZGlmaWNhLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L2xpPjxsaT48c3Ryb25nPkZpbmUgZGVsIHNlZ21lbnRvPC9zdHJvbmc+LS1Fc3RyYXJyZSBsYSBkYXRhIGFsbGEgZmluZSBkaSB1biBzZWdtZW50byBkaSBtb2RpZmljYS48L2xpPjwvdWw+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9hcmVhdW5pdHNfdGFnMEBAXCI6IFwiPHA+TCd1bml0w6AgZGkgYXJlYSBkZWkgdmFsb3JpIGRpIGRlbnNpdMOgIGRlbGwnb3V0cHV0LjwvcD48dWw+PGxpPlVuaXTDoCBkaSBtYXBwYSBxdWFkcmF0YTogcGVyIGlsIHF1YWRyYXRvIGRlbGxlIHVuaXTDoCBsaW5lYXJpIGRlbCByaWZlcmltZW50byBzcGF6aWFsZSBkaSB1c2NpdGEuPC9saT48bGk+TWlnbGlhIHF1YWRyYXRlOiBwZXIgbWlnbGlhIChVLlMuKS48L2xpPjxsaT5LaWxvbWV0cmkgcXVhZHJhdGk6IHBlciBraWxvbWV0cmkuPC9saT48bGk+QWNyaTogcGVyIGFjcmkgKFUuUy4pLjwvbGk+PGxpPkV0dGFyaTogcGVyIGV0dGFyaS48L2xpPjxsaT5NZXRyaSBxdWFkcmF0aTogcGVyIG1ldHJpLjwvbGk+PGxpPklhcmRlIHF1YWRyYXRlOiBwZXIgaWFyZGUgKFUuUy4pLjwvbGk+PGxpPlBpZWRpIHF1YWRyYXRpOiBwZXIgcGllZGkgKFUuUy4pLjwvbGk+PGxpPlBvbGxpY2kgcXVhZHJhdGk6IHBlciBwb2xsaWNpIChVLlMuKS48L2xpPjxsaT5DZW50aW1ldHJpIHF1YWRyYXRpOiBwZXIgY2VudGltZXRyaS48L2xpPjxsaT5NaWxsaW1ldHJpIHF1YWRyYXRpOiBwZXIgbWlsbGltZXRyaS48L2xpPjwvdWw+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9jZWxsc2l6ZV90YWcwQEBcIjogXCI8cD5MYSBncmFuZGV6emEgZGVsIHBpeGVsIHBlciBpbCBkYXRhc2V0IGRlbCByYXN0ZXIgZGkgb3V0cHV0LiBTZSBpbCB2YWxvcmUgPHN0cm9uZz5EaW1lbnNpb25lIGNlbGxhPC9zdHJvbmc+IMOoIHN0YXRvIGltcG9zdGF0byBuZWdsaSBhbWJpZW50aSBkaSBnZW9wcm9jZXNzaW5nLCDDqCBsJ2ltcG9zdGF6aW9uZSBkaSBkZWZhdWx0LjwvcD5cIixcblx0XCJAQEtlcm5lbC1EZW5zaXR5X2lucHV0YmFycmllcnNfdGFnMEBAXCI6IFwiPHA+SWwgZGF0YXNldCBjaGUgZGVmaW5pc2NlIGxlIGJhcnJpZXJlLjwvcD48cD5MZSBiYXJyaWVyZSBwb3Nzb25vIGVzc2VyZSB1biBsYXllciBmZWF0dXJlIGRpIHBvbGlsaW5lZSBvIGZlYXR1cmUgZGkgcG9saWdvbm8uPC9wPlwiLFxuXHRcIkBAS2VybmVsLURlbnNpdHlfaW5wdXRmZWF0dXJlc190YWcwQEBcIjogXCI8cD5JbCBwdW50byBkaSBpbnB1dCBvIGxlIGZlYXR1cmUgZGkgbGluZWEgcGVyIGxlIHF1YWxpIGNhbGNvbGFyZSBsYSBkZW5zaXTDoC48L3A+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9tZXRob2RfdGFnMEBAXCI6IFwiPHA+RGV0ZXJtaW5hIHNlIHVzYXJlIHVuIHBlcmNvcnNvIHBpw7kgYnJldmUgc3UgdW5vIHNmZXJvaWRlIChnZW9kZXNpYykgbyB1biBtZXRvZG8gZXJyYSBwaWF0dGEgKHBsYW5hcmUpLjwvcD48dWw+PGxpPjxzdHJvbmc+UGxhbmFyZTwvc3Ryb25nPi0tVXRpbGl6emEgZGlzdGFuemUgcGxhbmFyaSB0cmEgbGUgZmVhdHVyZS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5HZW9kZXNpYzwvc3Ryb25nPi0tVXRpbGl6emEgZGlzdGFuemUgZ2VvZGVzaWMgdHJhIGZlYXR1cmUuIFF1ZXN0byBtZXRvZG8gcHJlbmRlIGluIGNvbnNpZGVyYXppb25lIGxhIGN1cnZhdHVyYSBkaSB1bm8gc2Zlcm9pZGUgZSBzaSBvY2N1cGEgZGVpIGRhdGkgdmljaW5pIGFpIHBvbGkgZSBsZSBsaW5lZSBjYW1iaWFtZW50byBkYXRhIGludGVybmF6aW9uYWxpLjwvbGk+PC91bD48cD5TaSByYWNjb21hbmRhIGRpIHV0aWxpenphcmUgaWwgbWV0b2RvIDxzdHJvbmc+R2VvZGVzaWM8L3N0cm9uZz4gY29uIGRhdGkgc2FsdmF0aSBpbiB1biBzaXN0ZW1hIGNvb3JkaW5hdG8gY2hlIG5vbiDDqCBhcHByb3ByaWF0byBwZXIgbGUgbWlzdXJhemlvbmkgZGVsbGEgZGlzdGFuemEgZSBhbHRyZSBhbmFsaXNpIGNoZSBzb25vIHNpdHVhdGkgaW4gdW4nYXJlYSBnZW9ncmFmaWNhIGxhcmdhLiBQZXIgZXNlbXBpbywgdW4gV2ViIE1lcmNhdG9yIG8gYWx0cm8gc2lzdGVtYSBkaSBjb29yZGluYXRlIGdlb2dyYWZpY2hlIGRvdnJlYmJlIHV0aWxpenphcmUgaWwgbWV0b2RvIDxzdHJvbmc+R2VvZGVzaWM8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBAS2VybmVsLURlbnNpdHlfb3V0cHV0Y2VsbHZhbHVlc190YWcwQEBcIjogXCI8cD5EZXRlcm1pbmEgY29zYSByYXBwcmVzZW50YW5vIGkgdmFsb3JpIG5lbCByYXN0ZXIgZGkgb3V0cHV0LjwvcD48dWw+PGxpPjxzdHJvbmc+RGVuc2l0w6A8L3N0cm9uZz4tLUkgdmFsb3JpIGRpIG91dHB1dCByYXBwcmVzZW50YW5vIGlsIHZhbG9yZSBkaSBkZW5zaXTDoCBwcmVkZXR0by4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5Db250ZWdnaSBwcmV2aXN0aTwvc3Ryb25nPi0tSSB2YWxvcmkgZGkgb3V0cHV0IHJhcHByZXNlbnRhbm8gaWwgdmFsb3JlIHByZWRldHRvIGRlbCBmZW5vbWVubyBhbGwnaW50ZXJubyBkaSBvZ25pIHBpeGVsLiBEYWwgbW9tZW50byBjaGUgaWwgdmFsb3JlIGRlbCBwaXhlbCDDqCBjb2xsZWdhdG8gYWwgdmFsb3JlIHNwZWNpZmljbyA8c3Ryb25nPkRpbWVuc2lvbmUgY2VsbGE8L3N0cm9uZz4sIGlsIHJhc3RlciByaXN1bHRhbnRlIG5vbiBwdcOyIGVzc2VyZSByaWNhbXBpb25hdG8gaW4gdW5hIGRpdmVyc2EgZGltZW5zaW9uZSBkaSBwaXhlbCBlIHJhcHByZXNlbnRlcsOgIGNvbXVucXVlIGxlIGRpbWVuc2lvbmkgZGVsIGZlbm9tZW5vLjwvbGk+PC91bD5cIixcblx0XCJAQEtlcm5lbC1EZW5zaXR5X3BvcHVsYXRpb25maWVsZF90YWcwQEBcIjogXCI8cD5DYW1wbyBjaGUgaW5kaWNhIGkgdmFsb3JpIGRlbGxhIHBvcG9sYXppb25lIHBlciBvZ25pIGNhcmF0dGVyaXN0aWNhLiBJbCB2YWxvcmUgPHN0cm9uZz5DYW1wbyBwb3BvbGF6aW9uZTwvc3Ryb25nPiDDqCBpbCBjb250ZWdnaW8gbyBsYSBxdWFudGl0w6AgZGEgc3BhcmdlcmUgbmVsIHBhZXNhZ2dpbyBwZXIgY3JlYXJlIHVuYSBzdXBlcmZpY2llIGNvbnRpbnVhLiBJIHZhbG9yaSBuZWwgPHN0cm9uZz5jYW1wbyBwb3BvbGF6aW9uZTwvc3Ryb25nPiBwb3Nzb25vIGVzc2VyZSBpbnRlcmkgbyBpbiB2aXJnb2xhIG1vYmlsZS48L3A+PHA+TGUgb3B6aW9uaSBlIGkgY29tcG9ydGFtZW50aSBwcmVkZWZpbml0aSBwZXIgaWwgY2FtcG8gc29ubyBlbGVuY2F0aSBkaSBzZWd1aXRvIG5lbGwnb3JkaW5lIGRpIHByaW9yaXTDoC48L3A+PHVsPjxsaT5VdGlsaXp6bzxzdHJvbmc+TmVzc3Vubzwvc3Ryb25nPnNlIG5lc3N1biBlbGVtZW50byBvIHZhbG9yZSBzcGVjaWFsZSBzYXLDoCB1c2F0byBlIG9nbmkgY2FyYXR0ZXJpc3RpY2Egc2Fyw6AgY29udGF0YSB1bmEgdm9sdGEuPC9saT48bGk+VXRpbGl6em88c3Ryb25nPkZvcm1hPC9zdHJvbmc+c2UgbGUgY2FyYXR0ZXJpc3RpY2hlIGRpIGlucHV0IGNvbnRlbmdvbm8gWi48L2xpPjxsaT5BbHRyaW1lbnRpLCBpbCBjYW1wbyBwcmVkZWZpbml0byDDqDxzdHJvbmc+UE9QT0xBWklPTkU8L3N0cm9uZz4sIG8gcXVhbHNpYXNpIGRlcml2YXRvIGFjY2V0dGFiaWxlIGRpIHBvcG9sYXppb25lOjx1bD48bGk+PHN0cm9uZz5QT1BPTEFaSU9ORXh4eHh4eDwvc3Ryb25nPndoZXJlPHN0cm9uZz54eHh4eHg8L3N0cm9uZz5jYW4gZXNzZXJlIHF1YWxzaWFzaSBjYXJhdHRlcmUgdmFsaWRvLCBjb21lPHN0cm9uZz5QT1BPTEFaSU9ORTY8L3N0cm9uZz4sPHN0cm9uZz5QT1BPTEFaSU9ORTE5NzQ8L3N0cm9uZz4sIG9yPHN0cm9uZz5QT1BPTEFaSU9ORUFUSVBPPC9zdHJvbmc+LjwvbGk+PGxpPjxzdHJvbmc+UE9QPC9zdHJvbmc+LjwvbGk+PGxpPjxzdHJvbmc+UE9QeHh4eHh4PC9zdHJvbmc+LjwvbGk+PGxpPlNlIG5lc3N1bm8gZGVpIHByZWNlZGVudGkgc2kgYXBwbGljYSwgaWwgdmFsb3JlIHByZWRlZmluaXRvIMOoPHN0cm9uZz5OZXNzdW5vPC9zdHJvbmc+LjwvbGk+PC91bD48L2xpPjwvdWw+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9zZWFyY2hyYWRpdXNfdGFnMEBAXCI6IFwiPHA+SWwgcmFnZ2lvIGRpIHJpY2VyY2EgYWxsJ2ludGVybm8gZGVsIHF1YWxlIGNhbGNvbGFyZSBsYSBkZW5zaXTDoC4gTGUgdW5pdMOgIHNvbm8gYmFzYXRlIHN1IHVuJ3VuaXTDoCBsaW5lYXJlIGRlbCBwcm9nZXR0by48L3A+PHA+UGVyIGVzZW1waW8sIHNlIGxlIHVuaXTDoCBzb25vIGluIG1ldHJpLCBwZXIgaW5jbHVkZXJlIHR1dHRlIGxlIGZlYXR1cmUgaW4gdW4gcXVhcnRpZXJlIGRpIHVuIG1pZ2xpbywgaW1wb3N0YXJlIGlsIHJhZ2dpbyBkaSByaWNlcmNhIHVndWFsZSBhIDE2MDksMzQ0IChwb2ljaMOpIDEgbWlnbGlvID0gMTYwOSwzNDQgbWV0cmkpLjwvcD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3NfaWdub3Jlbm9kYXRhaW5jYWxjdWxhdGlvbnNfdGFnMEBAXCI6IFwiPHA+RGVub3RhIHNlIGkgdmFsb3JpIDxzdHJvbmc+Tm9EYXRhPC9zdHJvbmc+IG5lbCA8c3Ryb25nPlJhc3RlciB2YWxvcmU8L3N0cm9uZz4gaW5mbHVlbnplcmFubm8gaSByaXN1bHRhdGkgZGVsbGEgem9uYSBpbiBjdWkgcmljYWRvbm8uPC9wPjx1bD48bGk+PHN0cm9uZz5Tw6w8L3N0cm9uZz4tLUFsbCdpbnRlcm5vIGRpIHF1YWxzaWFzaSBwYXJ0aWNvbGFyZSB6b25hLCBzb2xvIGkgcGl4ZWwgY2hlIGhhbm5vIHVuIHZhbG9yZSBpbiA8c3Ryb25nPlJhc3RlciB2YWxvcmU8L3N0cm9uZz4gdmVycmFubm8gdXRpbGl6emF0aSBwZXIgZGV0ZXJtaW5hcmUgaWwgdmFsb3JlIGRpIG91dHB1dCBwZXIgcXVlbGxhIHpvbmEuIEkgcGl4ZWwgPHN0cm9uZz5Ob0RhdGE8L3N0cm9uZz4gaW4gPHN0cm9uZz5SYXN0ZXIgdmFsb3JlPC9zdHJvbmc+IHZlcnLDoCBpZ25vcmF0byBuZWwgY2FsY29sbyBzdGF0aXN0aWNvLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L2xpPjxsaT48c3Ryb25nPk5vPC9zdHJvbmc+OiBBbGwnaW50ZXJubyBkaSBxdWFsc2lhc2kgem9uYSBwYXJ0aWNvbGFyZSwgc2UgZXNpc3Rvbm8gcGl4ZWwgPHN0cm9uZz5Ob0RhdGE8L3N0cm9uZz4gbmVsIDxzdHJvbmc+UmFzdGVyIGRpIHZhbG9yaTwvc3Ryb25nPiwgc2kgY29uc2lkZXJhIGNoZSB2aSBzaWFubyBpbmZvcm1hemlvbmkgaW5zdWZmaWNpZW50aSBwZXIgZXNlZ3VpcmUgaSBjYWxjb2xpIHN0YXRpc3RpY2kgcGVyIHR1dHRpIGkgcGl4ZWwgbmVsbGEgem9uYTsgcGVyIHF1ZXN0YSByYWdpb25lLCBsJ2ludGVyYSB6b25hIHJpY2V2ZXLDoCBpbCB2YWxvcmUgPHN0cm9uZz5Ob0RhdGE8L3N0cm9uZz4gbmVsIHJhc3RlciBkaSBvdXRwdXQuPC9saT48L3VsPlwiLFxuXHRcIkBAWm9uYWwtU3RhdGlzdGljc19wZXJjZW50aWxlaW50ZXJwb2xhdGlvbnR5cGVfdGFnMEBAXCI6IFwiPHA+RGV0ZXJtaW5hIGlsIG1ldG9kbyBkaSBpbnRlcnBvbGF6aW9uZSBwZXJjZW50aWxlIGRhIHVzYXJlIHF1YW5kbyBpbCBudW1lcm8gZGkgdmFsb3JpIGRhbCByYXN0ZXIgZGkgaW5wdXQgZGEgY2FsY29sYXJlIHNvbm8gdW5pZm9ybWkuPC9wPjx1bD48bGk+PHN0cm9uZz5SaWxldmFtZW50byBhdXRvbWF0aWNvPC9zdHJvbmc+OiBzZSBpbCByYXN0ZXIgZGkgdmFsb3JlIGRpIGlucHV0IMOoIGRpIHRpcG8gcGl4ZWwgaW50ZXJvLCB2aWVuZSB1dGlsaXp6YXRvIGlsIG1ldG9kbyA8c3Ryb25nPlBpw7kgdmljaW5vPC9zdHJvbmc+LiBTZSBpbCByYXN0ZXIgZGkgdmFsb3JlIGRpIGlucHV0IMOoIGRpIHRpcG8gcHVudG8gcGl4ZWwgbW9iaWxlLCBhbGxvcmEgdmllbmUgdXNhcmUgaWwgbWV0b2RvIDxzdHJvbmc+TGluZWFyZTwvc3Ryb25nPi4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLjwvbGk+PGxpPjxzdHJvbmc+UGnDuSB2aWNpbm88L3N0cm9uZz46IGlsIHZhbG9yZSBwacO5IHZpY2lubyBkaXNwb25pYmlsZSB2aWVuZSB1c2F0byBwZXIgaWwgcGVyY2VudGlsZSBkZXNpZGVyYXRvLiBJbiBxdWVzdG8gY2FzbywgaWwgdGlwbyBkaSBwaXhlbCBkaSBvdXRwdXQgw6ggbG8gc3Rlc3NvIGRlbCByYXN0ZXIgZGkgdmFsb3JlIGRpIGlucHV0LjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyZTwvc3Ryb25nPjogbGEgbWVkaWEgcGVzYXRhIGRlaSBkdWUgdmFsb3JpIGNpcmNvc3RhbnRpIHZpZW5lIHVzYXRhIHBlciBpbCBwZXJjZW50aWxlIGRlc2lkZXJhdGEuIEluIHF1ZXN0byBjYXNvLCBpbCB0aXBvIGRpIHBpeGVsIGRpIG91dHB1dCDDqCBpbCBwdW50byBtb2JpbGUuPC9saT48L3VsPlwiLFxuXHRcIkBAWm9uYWwtU3RhdGlzdGljc19wZXJjZW50aWxldmFsdWVfdGFnMEBAXCI6IFwiPHA+SWwgcGVyY2VudGlsZSBkYSBjYWxjb2xhcmUuIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCA5MCBwZXIgaWwgOTBlc2ltbyBwZXJjZW50aWxlLjwvcD48cD5JIHZhbG9yaSBwdcOyIG9zY2lsbGFyZSBkYSAwIGEgMTAwLiBJbCBwZXJjZW50aWxlIG51bWVybyAwIMOoIGVzc2VuemlhbG1lbnRlIGwnZXF1aXZhbGVudGUgZGVsbGEgc3RhdGlzdGljYSBtaW5pbWEgZSBpbCBwZXJjZW50aWxlIG51bWVybyAxMDAgw6ggbCdlcXVpdmFsZW50ZSBkZWxsYSBzdGF0aXN0aWNhIG1hc3NpbWEuIFVuIHZhbG9yZSBwYXJpIGEgNTAgcHJvZHVycsOgIGVzc2VuemlhbG1lbnRlIGxvIHN0ZXNzbyByaXN1bHRhdG8gZGkgdW5hIHN0YXRpc3RpY2EgbWVkaWFuYS48L3A+XCIsXG5cdFwiQEBab25hbC1TdGF0aXN0aWNzX3Byb2Nlc3Nhc211bHRpZGltZW5zaW9uYWxfdGFnMEBAXCI6IFwiPHA+RGV0ZXJtaW5hIGNvbWUgaWwgcmFzdGVyIGRpIHZhbG9yZSBtdWx0aWRpbWVuc2lvbmFsZSBkaSBpbnB1dCDDqCBlbGFib3JhdG8uPC9wPjx1bD48bGk+PHN0cm9uZz5TZWxlemlvbmUgY29ycmVudGU8L3N0cm9uZz46IHNpIGNhbGNvbGVyYW5ubyBsZSBzdGF0aXN0aWNoZSBkZWxsYSBzZXppb25lIGNvcnJlbnRlIGRpIHVuIGRhdGFzZXQgbXVsdGlkaW1lbnNpb25hbGUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBkaSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+VHV0dGUgbGUgc2V6aW9uaTwvc3Ryb25nPjogc2kgY2FsY29sZXJhbm5vIGxlIHN0YXRpc3RpY2hlIHBlciB0dXR0ZSBsZSBkaW1lbnNpb25pIChjb21lIHRlbXBvIG8gcHJvZm9uZGl0w6ApIGRpIHVuIGRhdGFzZXQgbXVsdGlkaW1lbnNpb25hbGUuPC9saT48L3VsPlwiLFxuXHRcIkBAWm9uYWwtU3RhdGlzdGljc19zdGF0aXN0aWNzdHlwZV90YWcwQEBcIjogXCI8cD5UaXBvIHN0YXRpc3RpY28gZGEgY2FsY29sYXJlLjwvcD48dWw+PGxpPjxzdHJvbmc+TWVkaW88L3N0cm9uZz46IGNhbGNvbGEgbGEgbWVkaWEgZGkgdHV0dGkgaSBwaXhlbCBpbiA8c3Ryb25nPlJhc3RlciB2YWxvcmU8L3N0cm9uZz4gY2hlIGFwcGFydGVuZ29ubyBhbGxhIHN0ZXNzYSB6b25hIGRpIHF1ZWxsYSBkZWwgcGl4ZWwgZGkgb3V0cHV0LjwvbGk+PGxpPjxzdHJvbmc+TWFnZ2lvcmFuemE8L3N0cm9uZz46IGRldGVybWluYSBpbCB2YWxvcmUgY2hlIG9jY29ycmUgcGnDuSBmcmVxdWVudGVtZW50ZSBkaSB0dXR0aSBpIHBpeGVsIGluIDxzdHJvbmc+UmFzdGVyIHZhbG9yZTwvc3Ryb25nPiBjaGUgYXBwYXJ0ZW5nb25vIGFsbGEgc3Rlc3NhIHpvbmEgZGVsIHBpeGVsIGRpIG91dHB1dC48L2xpPjxsaT48c3Ryb25nPk1hc3NpbW88L3N0cm9uZz46IGRldGVybWluYSBpbCB2YWxvcmUgbWFnZ2lvcmUgZGkgdHV0dGkgaSBwaXhlbCBpbiA8c3Ryb25nPlJhc3RlciB2YWxvcmU8L3N0cm9uZz4gY2hlIGFwcGFydGVuZ29ubyBhbGxhIHN0ZXNzYSB6b25hIGRlbCBwaXhlbCBkaSBvdXRwdXQuPC9saT48bGk+PHN0cm9uZz5NZWRpYW5vPC9zdHJvbmc+OiBkZXRlcm1pbmEgaWwgdmFsb3JlIG1lZGlhbm8gZGkgdHV0dGkgaSBwaXhlbCBpbiA8c3Ryb25nPlJhc3RlciB2YWxvcmU8L3N0cm9uZz4gY2hlIGFwcGFydGVuZ29ubyBhbGxhIHN0ZXNzYSB6b25hIGRlbCBwaXhlbCBkaSBvdXRwdXQuPC9saT48bGk+PHN0cm9uZz5NaW5pbW88L3N0cm9uZz46IGRldGVybWluYSBpbCB2YWxvcmUgcGnDuSBiYXNzbyBkaSB0dXR0aSBpIHBpeGVsIGluIDxzdHJvbmc+UmFzdGVyIHZhbG9yZTwvc3Ryb25nPiBjaGUgYXBwYXJ0ZW5nb25vIGFsbGEgc3Rlc3NhIHpvbmEgZGVsIHBpeGVsIG91dHB1dC48L2xpPjxsaT48c3Ryb25nPk1pbm9yYW56YTwvc3Ryb25nPjogZGV0ZXJtaW5hIGlsIHZhbG9yZSBjaGUgb2Njb3JyZSBtZW5vIGZyZXF1ZW50ZW1lbnRlIGRpIHR1dHRpIGkgcGl4ZWwgbmVsIDxzdHJvbmc+UmFzdGVyIHZhbG9yZTwvc3Ryb25nPiBjaGUgYXBwYXJ0ZW5nb25vIGFsbGEgc3Rlc3NhIHpvbmEgZGVsIHBpeGVsIGRpIG91dHB1dC48L2xpPjxsaT48c3Ryb25nPlBlcmNlbnRpbGU8L3N0cm9uZz46IGNhbGNvbGEgdW5hIHBlcmNlbnRpbGUgZGkgdHV0dGkgaSBwaXhlbCBpbiA8c3Ryb25nPlJhc3RlciB2YWxvcmU8L3N0cm9uZz4gY2hlIGFwcGFydGVuZ29ubyBhbGxhIHN0ZXNzYSB6b25hIGRlbCBwaXhlbCBkaSBvdXRwdXQuIElsIDkwZXNpbW8gcGVyY2VudGlsZSDDqCBjYWxjb2xhdG8gc2Vjb25kbyBpbXBvc3RhemlvbmkgcHJlZGVmaW5pdGUuIMOIIHBvc3NpYmlsZSBkZXRlcm1pbmFyZSBxdWFsZSBwZXJjZW50aWxlIGRhIGNhbGNvbGFyZSBjb24gaWwgcGFyYW1ldHJvIDxzdHJvbmc+VmFsb3JlIHBlcmNlbnRpbGU8L3N0cm9uZz4uPC9saT48bGk+PHN0cm9uZz5SYW5nZTwvc3Ryb25nPjogY2FsY29sYSBsYSBkaWZmZXJlbnphIHRyYSBpbCB2YWxvcmUgbWFnZ2lvcmUgZSBtaW5vcmUgZGkgdHV0dGkgaSBwaXhlbCBpbiA8c3Ryb25nPlJhc3RlciB2YWxvcmU8L3N0cm9uZz5jaGUgYXBwYXJ0ZW5nb25vIGFsbGEgc3Rlc3NhIHpvbmUgZGVsIHBpeGVsIGRpIG91dHB1dC48L2xpPjxsaT48c3Ryb25nPkRldmlhemlvbmUgc3RhbmRhcmQ8L3N0cm9uZz46IGNhbGNvbGEgbGEgZGV2aWF6aW9uZSBzdGFuZGFyZCBkaSB0dXR0aSBpIHBpeGVsIGluIDxzdHJvbmc+UmFzdGVyIHZhbG9yZTwvc3Ryb25nPmNoZSBhcHBhcnRlbmdvbm8gYWxsYSBzdGVzc2Egem9uYSBkZWwgcGl4ZWwgZGkgb3V0cHV0LjwvbGk+PGxpPjxzdHJvbmc+U29tbWE8L3N0cm9uZz46IGNhbGNvbGEgaWwgdmFsb3JlIHRvdGFsZSBkaSB0dXR0aSBpIHBpeGVsIGluIDxzdHJvbmc+UmFzdGVyIHZhbG9yZTwvc3Ryb25nPmNoZSBhcHBhcnRlbmdvbm8gYWxsYSBzdGVzc2Egem9uYSBkZWwgcGl4ZWwgZGkgb3V0cHV0LjwvbGk+PGxpPjxzdHJvbmc+VmFyaWV0w6A8L3N0cm9uZz46IGNhbGNvbGEgaWwgbnVtZXJvIGRpIHZhbG9yaSB1bmljaSBwZXIgdHV0dGkgaSBwaXhlbCBpbiA8c3Ryb25nPlJhc3RlciB2YWxvcmU8L3N0cm9uZz5jaGUgYXBwYXJ0ZW5nb25vIGFsbGEgc3Rlc3NhIHpvbmEgZGVsIHBpeGVsIGRpIG91dHB1dC48L2xpPjwvdWw+XCIsXG5cdFwiQEBab25hbC1TdGF0aXN0aWNzX3ZhbHVlcmFzdGVyX3RhZzBAQFwiOiBcIjxwPlJhc3RlciBjaGUgY29udGllbmUgaSB2YWxvcmkgaW4gYmFzZSBhaSBxdWFsaSBjYWxjb2xhcmUgdW5hIHN0YXRpc3RpY2EuPC9wPlwiLFxuXHRcIkBAWm9uYWwtU3RhdGlzdGljc196b25lZmllbGRfdGFnMEBAXCI6IFwiPHA+Q2FtcG8gY2hlIGNvbnRpZW5lIGkgdmFsb3JpIGNoZSBkZWZpbmlzY29ubyBvZ25pIHpvbmEuIFB1w7IgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8gbyB1biBjYW1wbyBzdHJpbmdhIGRlbCByYXN0ZXIgZGkgem9uYS48L3A+XCIsXG5cdFwiQEBab25hbC1TdGF0aXN0aWNzX3pvbmVyYXN0ZXJfdGFnMEBAXCI6IFwiPHA+RGF0YXNldCBjaGUgZGVmaW5pc2NlIGxlIHpvbmUuIExlIHpvbmUgcG9zc29ubyBlc3NlcmUgZGVmaW5pdGUgZGEgdW4gcmFzdGVyIGludGVyby48L3A+XCIsXG5cdFwiQEBab25hbC1TdGF0aXN0aWNzX2NhbGN1bGF0ZWNpcmN1bGFyc3RhdGlzdGljc190YWcwQEBcIjogXCI8cD5TcGVjaWZpY2EgbGEgbW9kYWxpdMOgIGNvbiBjdWkgdmVycsOgIGNhbGNvbGF0byBpbCB0aXBvIGRpIHN0YXRpc3RpY2hlLjwvcD48dWw+PGxpPjxzdHJvbmc+QXJpdG1ldGljYTwvc3Ryb25nPjogY2FsY29sYSBzdGF0aXN0aWNoZSBhcml0bWV0aWNoZS4gw4ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuPC9saT48bGk+PHN0cm9uZz5DaXJjb2xhcmU8L3N0cm9uZz46IGNhbGNvbGEgc3RhdGlzdGljaGUgY2lyY29sYXJpIGFwcHJvcHJpYXRlIHBlciBxdWFudGl0w6AgY2ljbGljaGUsIGFkIGVzZW1waW8gZGlyZXppb25lIGJ1c3NvbGEgaW4gZ3JhZGksIG9yZSBkZWwgZ2lvcm5vIGUgcGFydGkgZnJhemlvbmFyaWUgZGkgbnVtZXJpIHJlYWxpLjwvbGk+PC91bD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3NfY2lyY3VsYXJ3cmFwdmFsdWVfdGFnMEBAXCI6IFwiPHA+SWwgbWFzc2ltbyB2YWxvcmUgcG9zc2liaWxlIChsaW1pdGUgc3VwZXJpb3JlKSBuZWkgZGF0aSBjaWNsaWNpLiDDiCB1biBudW1lcm8gcG9zaXRpdm8gaWwgY3VpIHZhbG9yZSBwcmVkZWZpbml0byDDqCAzNjAuIFF1ZXN0byB2YWxvcmUgcmFwcHJlc2VudGEgYW5jaGUgbGEgc3Rlc3NhIHF1YW50aXTDoCBkZWwgbWluaW1vIHZhbG9yZSBwb3NzaWJpbGUgKGxpbWl0ZSBpbmZlcmlvcmUpLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIGFwcGxpY2FiaWxlIHNvbG8gcXVhbmRvIHZlbmdvbm8gY2FsY29sYXRlIHN0YXRpc3RpY2hlIGNpcmNvbGFyaS48L3A+XCIsXG5cdFwiQEBCb3VuZGFyeS1DbGVhbi1mdW5jdGlvbl9pbnB1dHJhc3Rlcl90YWcwQEBcIjogXCI8cD5JbCByYXN0ZXIgZGkgaW5wdXQgcGVyIGlsIHF1YWxlIGlsIGNvbmZpbmUgdHJhIHpvbmUgdmVycsOgIHNtdXNzYXRvLjwvcD48cD5EZXZlIGVzc2VyZSBkaSB0aXBvIGludGVyby48L3A+XCIsXG5cdFwiQEBCb3VuZGFyeS1DbGVhbi1mdW5jdGlvbl9ydW5leHBhbnNpb25hbmRzaHJpbmtpbmd0d2ljZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2EgaWwgbnVtZXJvIGRpIHZvbHRlIGNoZSBpbCBwcm9jZXNzbyBkaSBzbXVzc2FtZW50byBzaSB2ZXJpZmljaGVyw6AsIGR1ZSB2b2x0ZSBvIHVuYSB2b2x0YS48L3A+PHVsPjxsaT48cD48c3Ryb25nPlNlbGV6aW9uYXRvPC9zdHJvbmc+OiBlc2VndWUgdW4nZXNwYW5zaW9uZSBlIHVuJ29wZXJhemlvbmUgZGkgY29udHJhemlvbmUgZHVlIHZvbHRlLiBQZXIgbGEgcHJpbWEgdm9sdGEsIGwnb3BlcmF6aW9uZSB2aWVuZSBlc2VndWl0YSBzZWNvbmRvIGlsIHRpcG8gZGkgb3JkaW5hbWVudG8gc3BlY2lmaWNvLiBQb2kgdW4nZXNwYW5zaW9uZSBlIHVuJ29wZXJhemlvbmUgZGkgY29udHJhemlvbmUgYWdnaXVudGl2ZSB2ZW5nb25vIGVzZWd1aXRlIGNvbiBsYSBwcmlvcml0w6AgaW52ZXJ0aXRhLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L3A+PC9saT48bGk+PHA+PHN0cm9uZz5Ob24gc2VsZXppb25hdG88L3N0cm9uZz46IGVzZWd1ZSBsJ2VzcGFuc2lvbmUgZSBsJ29wZXJhemlvbmUgZGkgY29udHJhemlvbmUgdW5hIHZvbHRhIHNlY29uZG8gaWwgdGlwbyBkaSBvcmRpbmFtZW50by48L3A+PC9saT48L3VsPlwiLFxuXHRcIkBAQm91bmRhcnktQ2xlYW4tZnVuY3Rpb25fc29ydHR5cGVfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGlsIHRpcG8gZGkgb3JkaW5hbWVudG8gZGEgdXNhcmUgbmVsIHByb2Nlc3NvIGRpIHNtdXNzYW1lbnRvLiBMJ29yZGluYW1lbnRvIGRldGVybWluYSBsYSBwcmlvcml0w6Agc2Vjb25kbyBsYSBxdWFsZSBsZSBjZWxsZSBwb3Nzb25vIGVzcGFuZGVyc2kgbmVsbGUgdmljaW5hbnplLjwvcD48cD5MJ29yZGluYW1lbnRvIHB1w7IgZXNzZXJlIGVmZmV0dHVhdG8gc3VsbGEgYmFzZSBkaSB6b25lIGRpIHZhbG9yZSBvIGFyZWUgZGkgem9uZS48L3A+PHVsPjxsaT48cD48c3Ryb25nPk5vbiBvcmRpbmFyZTwvc3Ryb25nPjogbGUgem9uZSBub24gdmVuZ29ubyBvcmRpbmF0ZSBwZXIgZGltZW5zaW9uZS4gWm9uZSBjb24gdmFsb3JpIG1hZ2dpb3JpIGhhbm5vIHVuYSBwcmlvcml0w6AgcGnDuSBhbHRhIGRpIGVzcGFuZGVyc2kgaW4gem9uZSBjb24gdmFsb3JpIG1pbm9yaSBuZWxsJ291dHB1dCBzbXVzc2F0by4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIGRpIGRlZmF1bHQuPC9wPjwvbGk+PGxpPjxwPjxzdHJvbmc+RGVjcmVzY2VudGU8L3N0cm9uZz46IG9yZGluYSBsZSB6b25lIGluIG9yZGluZSBkZWNyZXNjZW50ZSBzZWNvbmRvIGxhIGRpbWVuc2lvbmUuIExlIHpvbmUgY29uIGFyZWEgdG90YWxlIG1hZ2dpb3JlIGhhbm5vIGxhIHByaW9yaXTDoCBkaSBlc3BhbmRlcnNpIGluIHpvbmUgY29uIGFyZWUgdG90YWxpIG1pbm9yaS4gUXVlc3RhIG9wemlvbmUgdGVuZGUgYSBlbGltaW5hcmUgbyByaWR1cnJlIGxhIHByZXZhbGVuemEgZGkgY2VsbGUgZGEgem9uZSBtaW5vcmkgbmVsbCdvdXRwdXQgc211c3NhdG8uPC9wPjwvbGk+PGxpPjxwPjxzdHJvbmc+Q3Jlc2NlbnRlPC9zdHJvbmc+OiBvcmRpbmEgbGUgem9uZSBpbiBvcmRpbmUgY3Jlc2NlbnRlIHBlciBkaW1lbnNpb25lLiBMZSB6b25lIGNvbiBhcmVlIHRvdGFsaSBtaW5vcmkgaGFubm8gdW5hIHByaW9yaXTDoCBwacO5IGFsdGEgZGkgZXNwYW5kZXJzaSBpbiB6b25lIGNvbiBhcmVlIHRvdGFsaSBtYWdnaW9yaS4gUXVlc3RhIG9wemlvbmUgdGVuZGUgYSBwcmVzZXJ2YXJlIG8gYXVtZW50YXJlIGxhIHByZXZhbGVuemEgZGkgY2VsbGUgY29uIHpvbmUgbWlub3JpIG5lbGwnb3V0cHV0IHNtdXNzYXRvLjwvcD48L2xpPjwvdWw+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF9kaW1lbnNpb25fdGFnMEBAXCI6IFwiPHA+RGltZW5zaW9uZSBkaSBhZ2dyZWdhemlvbmUuIFF1ZXN0YSDDqCBsYSBkaW1lbnNpb25lIGx1bmdvIGxhIHF1YWxlIHZlcnJhbm5vIGFnZ3JlZ2F0ZSBsZSB2YXJpYWJpbGkuPC9wPlwiLFxuXHRcIkBAQWdncmVnYXRlLU11bHRpZGltZW5zaW9uYWxfZGltZW5zaW9uZGVmaW5pdGlvbl90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2EgaWwgbWV0b2RvIGRhIHVzYXJlIHBlciBmaWx0cmFyZSBpIGRhdGkgbXVsdGlkaW1lbnNpb25hbGkgZGkgaW5wdXQgcHJpbWEgZGkgZXNlZ3VpcmUgbCdhZ2dyZWdhemlvbmUuPC9wPjx1bD48bGk+PHN0cm9uZz5UdXR0bzwvc3Ryb25nPi0tU2kgdXRpbGl6emVyw6AgbCdpbnRlcnZhbGxvIGNvbXBsZXRvIHBlciBjaWFzY3VuYSBkaW1lbnNpb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuPC9saT48c3Ryb25nPjxsaT5QZXIgdmFsb3JpPC9zdHJvbmc+OiBsYSBkaW1lbnNpb25lIHZlcnLDoCBzdWRkaXZpc2EgdXRpbGl6emFuZG8gdW4gdmFsb3JlIGRpIGRpbWVuc2lvbmUgbyB1biBlbGVuY28gZGkgdmFsb3JpLjwvbGk+PGxpPjxzdHJvbmc+UGVyIGludGVydmFsbGk8L3N0cm9uZz46IGxhIGRpbWVuc2lvbmUgdmVycsOgIHN1ZGRpdmlzYSB1dGlsaXp6YW5kbyB1biBpbnRlcnZhbGxvIG8gdW4gZWxlbmNvIGRpIGludGVydmFsbGkuPC9saT48bGk+PHN0cm9uZz5QZXIgaXRlcmF6aW9uZTwvc3Ryb25nPjogbGEgZGltZW5zaW9uZSBzYXLDoCBzdWRkaXZpc2Egc3UgdW5hIGRpbWVuc2lvbmUgZGkgaW50ZXJ2YWxsbyBzcGVjaWZpY2F0YS48L2xpPjwvdWw+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF9pdGVyYXRpb25kZWZpbml0aW9ucGFyYW1ldGVyc190YWcwQEBcIjogXCI8cD5JIHBhcmFtZXRyaSBkaSBkZWZpbml6aW9uZSBkZWxsJ2l0ZXJhemlvbmUgY29uc2VudG9ubyBkaSBkZWZpbmlyZSBpIHZhbG9yaSBkaSBkaW1lbnNpb25lIGRhIHV0aWxpenphcmUgcGVyIGZpbHRyYXJlIGkgZGF0aSBtdWx0aWRpbWVuc2lvbmFsaSBkaSBpbnB1dCBwZXIgbCdhbmFsaXNpIHF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5EZWZpbml6aW9uZSBkaSBkaW1lbnNpb25lPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPlBlciBpdGVyYXppb25lPC9zdHJvbmc+LjwvcD48dWw+PGxpPjxzdHJvbmc+RGltZW5zaW9uZTwvc3Ryb25nPiAtIExhIGRpbWVuc2lvbmUgZGEgdXRpbGl6emFyZSBwZXIgaWwgZmlsdHJhZ2dpby48L2xpPjxsaT48c3Ryb25nPkluaXppbyBkZWxsYSBwcmltYSBpdGVyYXppb25lPC9zdHJvbmc+OiBsJ2luaXppbyBkZWwgcHJpbW8gaW50ZXJ2YWxsby4gUXVlc3RvIGludGVydmFsbG8gdmllbmUgdXRpbGl6emF0byBwZXIgc2NvcnJlcmUgaWwgc2V0IGRpIGRhdGkuPC9saT48bGk+PHN0cm9uZz5GaW5lIGRlbGxhIHByaW1hIGl0ZXJhemlvbmU8L3N0cm9uZz46IGxhIGZpbmUgZGVsIHByaW1vIGludGVydmFsbG8uIFF1ZXN0byBpbnRlcnZhbGxvIHZpZW5lIHV0aWxpenphdG8gcGVyIHNjb3JyZXJlIGlsIHNldCBkaSBkYXRpLjwvbGk+PGxpPjxzdHJvbmc+U3RlcDwvc3Ryb25nPjogbGEgZnJlcXVlbnphIGNvbiBjdWkgaSBkYXRpIHZlcnJhbm5vIHN1ZGRpdmlzaS48L2xpPjxsaT48c3Ryb25nPlVuaXTDoDwvc3Ryb25nPjogbCd1bml0w6AgZGkgaXRlcmF6aW9uZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF9rZXl3b3JkaW50ZXJ2YWxfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGwnaW50ZXJ2YWxsbyBkaSBwYXJvbGUgY2hpYXZlIGNoZSB2ZXJyw6AgdXRpbGl6emF0byBkdXJhbnRlIGwnYWdncmVnYXppb25lIGx1bmdvIGxhIGRpbWVuc2lvbmUuPC9wPjxwPlF1ZXN0byBwYXJhbWV0cm8gw6ggb2JibGlnYXRvcmlvIHF1YW5kbyBpbCBwYXJhbWV0cm88c3Ryb25nPlRpcG88L3N0cm9uZz4gw6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+UGFyb2xhIGNoaWF2ZSBpbnRlcnZhbGxvPC9zdHJvbmc+LjwvcD48dWw+PGxpPjxzdHJvbmc+T3JhPC9zdHJvbmc+OiBpIHZhbG9yaSBkZWkgZGF0aSB2ZW5nb25vIGFnZ3JlZ2F0aSBpbiBmYXNpIHRlbXBvcmFsaSBvcmFyaWUgZSBpbCByaXN1bHRhdG8gaW5jbHVkZSBvZ25pIG9yYSBuZWxsYSBzZXJpZSB0ZW1wb3JhbGUuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS48L2xpPjxsaT48c3Ryb25nPlF1b3RpZGlhbm88L3N0cm9uZz46IGkgdmFsb3JpIGRlaSBkYXRpIHZlbmdvbm8gYWdncmVnYXRpIGluIGZhc2kgdGVtcG9yYWxpIGdpb3JuYWxpZXJlIGUgaWwgcmlzdWx0YXRvIGluY2x1ZGUgb2duaSBnaW9ybm8gbmVsbGUgc2VyaWUgdGVtcG9yYWxpLjwvbGk+PGxpPjxzdHJvbmc+U2V0dGltYW5hbGU8L3N0cm9uZz46IGkgdmFsb3JpIGRlaSBkYXRpIHZlbmdvbm8gYWdncmVnYXRpIGluIGZhc2kgdGVtcG9yYWxpIHNldHRpbWFuYWxpIGUgaWwgcmlzdWx0YXRvIGluY2x1ZGUgb2duaSBzZXR0aW1hbmEgbmVsbGEgc2VyaWUgdGVtcG9yYWxpLjwvbGk+PGxpPjxzdHJvbmc+RGVrYWRseTwvc3Ryb25nPjogaSB2YWxvcmkgZGVpIGRhdGkgdmVuZ29ubyBhZ2dyZWdhdGkgaW4gMyBwZXJpb2RpIGRpIDEwIGdpb3JuaSBjaWFzY3Vuby4gTCd1bHRpbW8gcGVyaW9kbyBwdcOyIGNvbnRlbmVyZSBwacO5IG8gbWVubyBkaSAxMCBnaW9ybmkuIEwnb3V0cHV0IGluY2x1ZGUgMyBzZXppb25pIHBlciBvZ25pIG1lc2UuPC9saT48bGk+PHN0cm9uZz5QZW50YWRseTwvc3Ryb25nPiAtIEkgdmFsb3JpIGRlaSBkYXRpIHZlbmdvbm8gYWdncmVnYXRpIGluIDYgcGVyaW9kaSBkaSA1IGdpb3JuaSBjaWFzY3Vuby4gTCd1bHRpbW8gcGVyaW9kbyBwdcOyIGNvbnRlbmVyZSBwacO5IG8gbWVubyBkaSA1IGdpb3JuaS4gTCdvdXRwdXQgaW5jbHVkZSA2IHNlemlvbmkgcGVyIG9nbmkgbWVzZS48L2xpPjxsaT48c3Ryb25nPk1lbnNpbGU8L3N0cm9uZz46IGkgdmFsb3JpIGRlaSBkYXRpIHZlbmdvbm8gYWdncmVnYXRpIGluIGZhc2kgdGVtcG9yYWxpIG1lbnNpbGkgZSBpbCByaXN1bHRhdG8gaW5jbHVkZSBvZ25pIG1lc2UgbmVsbGUgc2VyaWUgdGVtcG9yYWxpLjwvbGk+PGxpPjxzdHJvbmc+VHJpbWVzdHJhbGU8L3N0cm9uZz46IGkgdmFsb3JpIGRlaSBkYXRpIHZlbmdvbm8gYWdncmVnYXRpIGluIGZhc2kgdGVtcG9yYWxpIHRyaW1lc3RyYWxpIGUgaWwgcmlzdWx0YXRvIGluY2x1ZGUgb2duaSB0cmltZXN0cmUgbmVsbGUgc2VyaWUgdGVtcG9yYWxpLjwvbGk+PGxpPjxzdHJvbmc+QW5udWFsZTwvc3Ryb25nPjogaSB2YWxvcmkgZGVpIGRhdGkgdmVuZ29ubyBhZ2dyZWdhdGkgaW4gZmFzaSB0ZW1wb3JhbGkgYW5udWFsaSBlIGlsIHJpc3VsdGF0byBpbmNsdWRlIG9nbmkgYW5ubyBuZWxsZSBzZXJpZSB0ZW1wb3JhbGkuPC9saT48bGk+PHN0cm9uZz5SaWNvcnJlbnRlIGdpb3JuYWxtZW50ZTwvc3Ryb25nPjogaSB2YWxvcmkgZGVpIGRhdGkgdmVuZ29ubyBhZ2dyZWdhdGkgaW4gZmFzaSB0ZW1wb3JhbGkgZ2lvcm5hbGllcmUgZSBpbCByaXN1bHRhdG8gbmUgaW5jbHVkZSB1bmEgdmFsb3JlIGFnZ3JlZ2F0byBwZXIgZ2lvcm5vIGdpdWxpYW5vLiBMJ291dHB1dCBpbmNsdWRlIGFsIG1hc3NpbW8gMzY2IGludGVydmFsbGkgZGkgdGVtcG8gZ2lvcm5hbGllcmkuPC9saT48bGk+PHN0cm9uZz5SaWNvcnJlbnRpIHNldHRpbWFuYWxtZW50ZTwvc3Ryb25nPjogaSB2YWxvcmkgZGVpIGRhdGkgdmVuZ29ubyBhZ2dyZWdhdGkgaW4gaW50ZXJ2YWxsaSBkaSB0ZW1wbyBzZXR0aW1hbmFsaSBlIGlsIHJpc3VsdGF0byBpbmNsdWRlIHVuIHZhbG9yZSBhZ2dyZWdhdG8gYSBzZXR0aW1hbmEuIEwnb3V0cHV0IGluY2x1ZGUgYWwgbWFzc2ltbyA1MyBpbnRlcnZhbGxpIGRpIHRlbXBvIHNldHRpbWFuYWxpLjwvbGk+PGxpPjxzdHJvbmc+Umljb3JyZW50aSBtZW5zaWxtZW50ZTwvc3Ryb25nPjogaSB2YWxvcmkgZGVpIGRhdGkgdmVuZ29ubyBhZ2dyZWdhdGkgaW4gaW50ZXJ2YWxsaSBkaSB0ZW1wbyBzZXR0aW1hbmFsaSBlIGlsIHJpc3VsdGF0byBpbmNsdWRlIHVuIHZhbG9yZSBhZ2dyZWdhdG8gYSBzZXR0aW1hbmEuIEwnb3V0cHV0IGluY2x1ZGUgYWwgbWFzc2ltbyAxMiBpbnRlcnZhbGxpIGRpIHRlbXBvIG1lbnNpbG1lbnRlLjwvbGk+PGxpPjxzdHJvbmc+Umljb3JyZW50aSB0cmltZXN0cmFsbWVudGU8L3N0cm9uZz46IGkgdmFsb3JpIGRlaSBkYXRpIHZlbmdvbm8gYWdncmVnYXRpIGluIGludGVydmFsbGkgZGkgdGVtcG8gc2V0dGltYW5hbGkgZSBpbCByaXN1bHRhdG8gaW5jbHVkZSB1biB2YWxvcmUgYWdncmVnYXRvIGEgc2V0dGltYW5hLiBMJ291dHB1dCBpbmNsdWRlIGFsIG1hc3NpbW8gNCBwZXJpb2RpIGRpIHRlbXBvIHRyaW1lc3RyYWxpLjwvbGk+PC91bD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX29wZXJhdGlvbl90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2EgaWwgbWV0b2RvIG1hdGVtYXRpY28gY2hlIHZlcnLDoCB1dGlsaXp6YXRvIHBlciBjb21iaW5hcmUgbGUgc2V6aW9uaSBhZ2dyZWdhdGUgaW4gdW4gaW50ZXJ2YWxsby48L3A+PHVsPjxsaT48c3Ryb25nPk1hZ2dpb3JhbnphPC9zdHJvbmc+OiBpbCB2YWxvcmUgZGVpIHBpeGVsIGNoZSBzaSDDqCB2ZXJpZmljYXRvIHBpw7kgZnJlcXVlbnRlbWVudGUgdmVycsOgIGNhbGNvbGF0byBzdSB0dXR0ZSBsZSBzZXppb25pIG5lbGwnaW50ZXJ2YWxsby48L2xpPjxsaT48c3Ryb25nPk1hc3NpbW88L3N0cm9uZz46IGlsIHZhbG9yZSBtYXNzaW1vIGRpIHVuIHBpeGVsIHZlcnLDoCBjYWxjb2xhdG8gdHV0dGUgbGUgc2V6aW9uaSBuZWxsJ2ludGVydmFsbG8uPC9saT48bGk+PHN0cm9uZz5NZWRpYTwvc3Ryb25nPjogbGEgbWVkaWEgZGVpIHZhbG9yaSBkaSB1biBwaXhlbCB2ZXJyw6AgY2FsY29sYXRhIHN1IHR1dHRlIGxlIHNlemlvbmkgbmVsbCdpbnRlcnZhbGxvLiBRdWVzdG8gw6ggaWwgdmFsb3JlIHByZWRlZmluaXRvLjwvbGk+PGxpPjxzdHJvbmc+TWVkaWFubzwvc3Ryb25nPjogaWwgdmFsb3JlIG1lZGlhbm8gZGkgdW4gcGl4ZWwgdmVycsOgIGNhbGNvbGF0byBzdSB0dXR0ZSBsZSBzZXppb25pIG5lbGwnaW50ZXJ2YWxsby48L2xpPjxzdHJvbmc+PGxpPk1pbmltbzwvc3Ryb25nPjogaWwgdmFsb3JlIG1pbmltbyBkaSB1biBwaXhlbCB2ZXJyw6AgY2FsY29sYXRvIHN1IHR1dHRlIGxlIHNlemlvbmkgbmVsbCdpbnRlcnZhbGxvLjwvbGk+PGxpPjxzdHJvbmc+TWlub3JhbnphPC9zdHJvbmc+OiBpbCB2YWxvcmUgZGVsIHBpeGVsIGNoZSBzaSDDqCB2ZXJpZmljYXRvIGNvbiBtaW5vcmUgZnJlcXVlbnphIHZlcnLDoCBjYWxjb2xhdG8gc3UgdHV0dGUgbGUgc2V6aW9uaSBuZWxsJ2ludGVydmFsbG8uPC9saT48c3Ryb25nPiA8bGk+SW50ZXJ2YWxsbzwvc3Ryb25nPjogbCdpbnRlcnZhbGxvIGRpIHZhbG9yaSBwZXIgdW4gcGl4ZWwgdmVycsOgIGNhbGNvbGF0byBzdSB0dXR0ZSBsZSBzZXppb25pIG5lbGwnaW50ZXJ2YWxsby48L2xpPjxsaT48c3Ryb25nPkRldmlhemlvbmUgc3RhbmRhcmQ8L3N0cm9uZz46IGxhIGRldmlhemlvbmUgc3RhbmRhcmQgZGVpIHZhbG9yaSBkaSB1biBwaXhlbCB2ZXJyw6AgY2FsY29sYXRhIHN1IHR1dHRlIGxlIHNlemlvbmkgbmVsbCdpbnRlcnZhbGxvLjwvbGk+PGxpPjxzdHJvbmc+U29tbWE8L3N0cm9uZz46IGxhIHNvbW1hIGRlaSB2YWxvcmkgZGkgdW4gcGl4ZWwgdmVycsOgIGNhbGNvbGF0YSBzdSB0dXR0ZSBsZSBzZXppb25pIG5lbGwnaW50ZXJ2YWxsby48L2xpPjxsaT48c3Ryb25nPlZhcmlldMOgPC9zdHJvbmc+OiBpbCBudW1lcm8gZGkgdmFsb3JpIGRpIHBpeGVsIHVuaXZvY2kgdmVycsOgIGNhbGNvbGF0byBzdSB0dXR0ZSBsZSBzZXppb25pIG5lbGwnaW50ZXJ2YWxsby48L2xpPjwvdWw+PHA+VHV0dGUgbGUgb3B6aW9uaSBoYW5ubyBhbmNoZSB1biBlcXVpdmFsZW50ZSBjb24gdW4gSWdub3JhIGwnb3B6aW9uZSBOb0RhdGEuIFF1ZXN0aSBlc2VndWlyYW5ubyBsJ29wZXJhemlvbmUgbWF0ZW1hdGljYSBzdSB0dXR0aSBpIHBpeGVsIHZhbGlkaSBsdW5nbyBsYSBkaW1lbnNpb25lIGUgaWdub3JlcmFubm8gaSBwaXhlbCBOb0RhdGEuPC9wPlwiLFxuXHRcIkBAQWdncmVnYXRlLU11bHRpZGltZW5zaW9uYWxfcmFuZ2VzX3RhZzBAQFwiOiBcIjxwPkxlIGFtcGllenplIGludGVydmFsbG8gc3BlY2lmaWNhdGUgbmVsbGEgdGFiZWxsYSB2ZXJyYW5ubyB1dGlsaXp6YXRlIHBlciBhZ2dyZWdhcmUgZ3J1cHBpIGRpIHZhbG9yaS4gSSB2YWxvcmkgbWluaW1vIGUgbWFzc2ltbyBzcGVjaWZpY2FubyBsJ2ludGVydmFsbG8gZGEgaW5jbHVkZXJlLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIHJpY2hpZXN0byBxdWFuZG8gaWwgcGFyYW1ldHJvPHN0cm9uZz5UaXBvPC9zdHJvbmc+w6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+QW1waWV6emUgaW50ZXJ2YWxsbzwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF9yYXN0ZXJfdGFnMEBAXCI6IFwiPHA+SWwgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGRpIGlucHV0LjwvcD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX3R5cGVfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGwnaW50ZXJ2YWxsbyBkaSBkaW1lbnNpb25lIHBlciBpbCBxdWFsZSBpIGRhdGkgdmVycmFubm8gYWdncmVnYXRpLjwvcD48dWw+PGxpPjxzdHJvbmc+VHV0dGk8L3N0cm9uZz46IGkgZGF0aSB2YXJpYWJpbGkgdmVycmFubm8gYWdncmVnYXRpIGluIHR1dHRlIGxlIHNlemlvbmkuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS48L2xpPjxsaT48c3Ryb25nPlBhcm9sYSBjaGlhdmUgaW50ZXJ2YWxsbzwvc3Ryb25nPjogaSBkYXRpIGRlbGxhIHZhcmlhYmlsZSB2ZXJyYW5ubyBhZ2dyZWdhdGkgdXRpbGl6emFuZG8gdW4gaW50ZXJ2YWxsbyBjb211bmVtZW50ZSBub3RvLjwvbGk+PGxpPjxzdHJvbmc+VmFsb3JlIGludGVydmFsbG88L3N0cm9uZz46IGkgZGF0aSBkZWxsYSB2YXJpYWJpbGUgdmVycmFubm8gYWdncmVnYXRpIHV0aWxpenphbmRvIHVuIGludGVydmFsbG8gZSB1bid1bml0w6Agc3BlY2lmaWNhdGkgZGFsbCd1dGVudGUuPC9saT48bGk+PHN0cm9uZz5HYW1tZSBpbnRlcnZhbGxpPC9zdHJvbmc+OiBpIGRhdGkgZGVsbGEgdmFyaWFiaWxlIHZlcnJhbm5vIGFnZ3JlZ2F0aSB0cmEgY29wcGllIGRpIHZhbG9yaSBvIGRhdGUgc3BlY2lmaWNhdGUuPC9saT48L3VsPlwiLFxuXHRcIkBAQWdncmVnYXRlLU11bHRpZGltZW5zaW9uYWxfdmFsdWVpbnRlcnZhbF90YWcwQEBcIjogXCI8cD5MYSBkaW1lbnNpb25lIGRlbGwnaW50ZXJ2YWxsbyB1dGlsaXp6YXRvIHBlciBsJ2FnZ3JlZ2F6aW9uZS48L3A+PHA+UXVlc3RvIHBhcmFtZXRybyDDqCBvYmJsaWdhdG9yaW8gcXVhbmRvIGlsIHBhcmFtZXRybyA8c3Ryb25nPlRpcG88L3N0cm9uZz4gw6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+VmFsb3JlIGludGVydmFsbG88L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBAQWdncmVnYXRlLU11bHRpZGltZW5zaW9uYWxfdmFsdWVzX3RhZzBAQFwiOiBcIjxwPkkgdmFsb3JpIGRlbGxlIGRpbWVuc2lvbmkgZGEgdXRpbGl6emFyZSBwZXIgZmlsdHJhcmUgaSBkYXRpIG11bHRpZGltZW5zaW9uYWxpIGRpIGlucHV0IHBlciBsJ2FuYWxpc2kuIFF1ZXN0byBwYXJhbWV0cm8gw6ggb2JibGlnYXRvcmlvIHF1YW5kbyBpbCBwYXJhbWV0cm88c3Ryb25nPkRlZmluaXppb25lIGRpbWVuc2lvbmU8L3N0cm9uZz4gw6ggaW1wb3N0YXRvIHN1PHN0cm9uZz5QZXIgdmFsb3JpPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX3ZhcmlhYmxlc190YWcwQEBcIjogXCI8cD5MYSB2YXJpYWJpbGUgbyBsZSB2YXJpYWJpbGkgY2hlIHZlcnJhbm5vIGFnZ3JlZ2F0ZSBsdW5nbyBsYSBkaW1lbnNpb25lIHNwZWNpZmljYXRhLjwvcD5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctUmVncmVzc2lvbl9pbnB1dGRlZmluaXRpb25maWxlX3RhZzBAQFwiOiBcIjxwPklsIGZpbGUgZGkgZGVmaW5pemlvbmUgZGVsIG1ldG9kbyBkaSByZWdyZXNzaW9uZSBkaSBFc3JpICg8c3Ryb25nPi5lY2Q8L3N0cm9uZz4pIGNoZSBjb250aWVuZSBsZSBzdGF0aXN0aWNoZSBlIGluZm9ybWF6aW9uaSBwZXIgbG8gc3BlY2lmaWNvIGRhdGFzZXQsIG1vZGVsbG8gZGkgcmVncmVzc2lvbmUgZSBwZXIgZ2xpIGF0dHJpYnV0aSBzY2VsdGkuPC9wPlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1SZWdyZXNzaW9uX3Jhc3RlcnNfdGFnMEBAXCI6IFwiPHA+SSBkYXRhc2V0IHJhc3RlciBvIGRhdGFzZXQgY2hlIHJhcHByZXNlbnRhbm8gbGUgdmFyaWFiaWxpIGRpIHByZWRpemlvbmUuIFB1w7IgZXNzZXJlIHVuIHJhc3RlciBhIGJhbmRhIHNpbmdvbGEsIG11bHRpcGxhIG8gbXVsdGlkaW1lbnNpb25hbGUsIHVuIGRhdGFzZXQgbW9zYWljbyBvIHVuYSByYWNjb2x0YSBkaSByYXN0ZXIuPC9wPlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX29wZXJhdGlvbl90YWcwQEBcIjogXCI8cD5JbCB0aXBvIGRpIGNhbGNvbG8gc3RhdGlzdGljbyBjaGUgc2kgZGVzaWRlcmEgZXNlZ3VpcmUuPC9wPjxwPkxlIHN0YXRpc3RpY2hlIGRpc3BvbmliaWxpIHNvbm88c3Ryb25nPk1hZ2dpb3JhbnphPC9zdHJvbmc+LDxzdHJvbmc+TWFzc2ltbzwvc3Ryb25nPiw8c3Ryb25nPk1lZGlhPC9zdHJvbmc+LDxzdHJvbmc+TWVkaWFuYTwvc3Ryb25nPiw8c3Ryb25nPk1pbmltbzwvc3Ryb25nPiw8c3Ryb25nPk1pbm9yYW56YTwvc3Ryb25nPiw8c3Ryb25nPlBlcmNlbnRpbGU8L3N0cm9uZz4sPHN0cm9uZz5JbnRlcnZhbGxvPC9zdHJvbmc+LDxzdHJvbmc+RGV2aWF6aW9uZSBzdGFuZGFyZDwvc3Ryb25nPiw8c3Ryb25nPlNvbW1hPC9zdHJvbmc+IGU8c3Ryb25nPlZhcmlldMOgPC9zdHJvbmc+LjwvcD48cD5JbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6g8c3Ryb25nPk1lZGlhPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQENvbG9ybWFwLVRvLVJHQl9yYW5kb21seWFzc2lnbmNvbG9ydG91bm1hcHBlZHBpeGVsc190YWcwQEBcIjogXCI8cD5JIGNvbG9yaSB2ZW5nb25vIGFzc2VnbmF0aSBjYXN1YWxtZW50ZSBhaSBwaXhlbCBjaGUgbm9uIHNvbm8gaW5jbHVzaSBuZWxsYSBtYXBwYSBkZWkgY29sb3JpLjwvcD48dWw+PGxpPkRlc2VsZXppb25hdG86IGFpIHBpeGVsIG5vbiBtYXBwYXRpIG5vbiB2aWVuZSBhc3NlZ25hdG8gdW4gY29sb3JlLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuPC9saT48bGk+U2VsZXppb25hdG86IGFpIHBpeGVsIG5vbiBtYXBwYXRpIHZpZW5lIGFzc2VnbmF0byB1biBjb2xvcmUuPC9saT48L3VsPlwiLFxuXHRcIkBAUGFuc2hhcnBlbl9zZW5zb3JfdGFnMEBAXCI6IFwiPHA+UXVhbmRvIHNpIHNjZWdsaWUgbCdhbGdvcml0bW8gR3JhbS1TY2htaWR0LCDDqCBhbmNoZSBwb3NzaWJpbGUgc3BlY2lmaWNhcmUgaWwgc2Vuc29yZSBjaGUgaGEgcmFjY29sdG8gaWwgcmFzdGVyIG11bHRpYmFuZGEgZGkgaW5wdXQuIExhIHNjZWx0YSBkZWwgdGlwbyBkaSBzZW5zb3JlIGltcG9zdGVyw6AgcGVzaSBkaSBiYW5kYSBhZGVndWF0aS48L3A+XCIsXG5cdFwiQEBEaW1lbnNpb25hbC1Nb3ZpbmctU3RhdGlzdGljc19iYWNrd2FyZHdpbmRvd190YWcwQEBcIjogXCI8cD5JbCB2YWxvcmUgZGkgcXVhbnRlIHNsaWNlIHByaW1hIG8gZG9wbyBlc3NlcmUgaW5jbHVzZSBuZWxsYSBmaW5lc3RyYSBkZWZpbml0YS4gSWwgdmFsb3JlIGRldmUgZXNzZXJlIHVuIG51bWVybyBpbnRlcm8gcG9zaXRpdm8gY29tcHJlc28gdHJhIDEgZSAxMDAuIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCAxLjwvcD48cD5MJ3VuaXTDoCBkaSBxdWVzdG8gcGFyYW1ldHJvIMOoIHNsaWNlLjwvcD5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX2NpcmN1bGFyd3JhcHZhbHVlX3RhZzBAQFwiOiBcIjxwPklsIHZhbG9yZSBjaGUgdmVycsOgIHV0aWxpenphdG8gcGVyIGFycm90b25kYXJlIHVuIHZhbG9yZSBsaW5lYXJlIGFsbCdpbnRlcnZhbGxvIGRpIHVuYSBkYXRhIG1lZGlhIGNpcmNvbGFyZS48L3A+PHA+SWwgc3VvIHZhbG9yZSBkZXZlIGVzc2VyZSBwb3NpdGl2by4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDM2MCBncmFkaS48L3A+XCIsXG5cdFwiQEBEaW1lbnNpb25hbC1Nb3ZpbmctU3RhdGlzdGljc19kaW1lbnNpb25fdGFnMEBAXCI6IFwiPHA+SWwgbm9tZSBkZWxsYSBkaW1lbnNpb25lIGx1bmdvIGxhIHF1YWxlIHNpIHNwb3N0ZXLDoCBsYSBmaW5lc3RyYS48L3A+PHA+SWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIGxhIHByaW1hIGRpbWVuc2lvbmUgZGl2ZXJzYSBkYSB4LHkgdHJvdmF0YSBuZWwgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGRpIGlucHV0LjwvcD5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX2ZvcndhcmR3aW5kb3dfdGFnMEBAXCI6IFwiPHA+SWwgdmFsb3JlIGRpIHF1YW50ZSBzZXppb25pIHN1Y2Nlc3NpdmUgbyBpbmZlcmlvcmkgZGV2b25vIGVzc2VyZSBpbmNsdXNlIG5lbGxhIGZpbmVzdHJhIGRlZmluaXRhLiBJbCB2YWxvcmUgZGV2ZSBlc3NlcmUgdW4gbnVtZXJvIGludGVybyBwb3NpdGl2byBjb21wcmVzbyB0cmEgMSBlIDEwMC4gSWwgdmFsb3JlIHByZWRlZmluaXRvIMOoIDEuPC9wPjxwPkwndW5pdMOgIGRpIHF1ZXN0byBwYXJhbWV0cm8gw6ggc2xpY2UuPC9wPlwiLFxuXHRcIkBARGltZW5zaW9uYWwtTW92aW5nLVN0YXRpc3RpY3NfaW5wdXRyYXN0ZXJfdGFnMEBAXCI6IFwiPHA+SWwgcmFzdGVyIGRpIGlucHV0IHB1w7IgZXNzZXJlIHNvbG8gdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGluIGZvcm1hdG8gQ2xvdWQgUmFzdGVyIChmaWxlIDxzdHJvbmc+LmNyZjwvc3Ryb25nPikuPC9wPlwiLFxuXHRcIkBARGltZW5zaW9uYWwtTW92aW5nLVN0YXRpc3RpY3Nfbm9kYXRhaGFuZGxpbmdfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGNvbWUgdmVycmFubm8gZ2VzdGl0aSBpIHZhbG9yaSBOb0RhdGEgZGFsIGNhbGNvbG8gc3RhdGlzdGljby48L3A+PHVsPjxsaT48c3Ryb25nPkRhdGk8L3N0cm9uZz4tLUkgdmFsb3JpIE5vRGF0YSBuZWwgdmFsb3JlIGltbWVzc28gdmVycmFubm8gaWdub3JhdGkgbmVpIHJpc3VsdGF0aSBkZWxsYSBmaW5lc3RyYSBkZWZpbml0YSBpbiBjdWkgcmllbnRyYW5vLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuPC9saT48bGk+PHN0cm9uZz5Ob0RhdGE8L3N0cm9uZz4tLUkgdmFsb3JpIGRpIG91dHB1dCBzYXJhbm5vIE5vRGF0YSBzZSBlc2lzdG9ubyB2YWxvcmkgTm9EYXRhIG5lbGwnaW5wdXQgYWxsJ2ludGVybm8gZGVsbGEgZmluZXN0cmEgZGVmaW5pdGEuPC9saT48bGk+PHN0cm9uZz5Db21waWxhIE5vRGF0YTwvc3Ryb25nPi0tSSB2YWxvcmkgZGVsbGUgY2VsbGUgTm9EYXRhIHZlcnJhbm5vIHNvc3RpdHVpdGkgdXRpbGl6emFuZG8gbGEgc3RhdGlzdGljYSBzZWxlemlvbmF0YSBhbGwnaW50ZXJubyBkZWxsYSBmaW5lc3RyYSBkZWZpbml0YS48L2xpPjwvdWw+XCIsXG5cdFwiQEBEaW1lbnNpb25hbC1Nb3ZpbmctU3RhdGlzdGljc19wZXJjZW50aWxlaW50ZXJwb2xhdGlvbnR5cGVfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGlsIG1ldG9kbyBkaSBpbnRlcnBvbGF6aW9uZSBjaGUgdmVycsOgIHV0aWxpenphdG8gcXVhbmRvIGlsIHZhbG9yZSBwZXJjZW50aWxlIHJpZW50cmEgdHJhIGR1ZSB2YWxvcmkgZGkgY2VsbGEuPC9wPjx1bD48bGk+PHN0cm9uZz5SaWxldmFtZW50byBhdXRvbWF0aWNvPC9zdHJvbmc+LS1TZSBpbCByYXN0ZXIgZGkgaW5wdXQgw6ggZGkgdGlwbyBwaXhlbCBpbnRlcm8sIHNhcsOgIHVzYXRvIGlsIG1ldG9kbzxzdHJvbmc+cGnDuSB2aWNpbm88L3N0cm9uZz4uIFNlIGlsIHJhc3RlciBkaSBpbnB1dCDDqCBkaSB0aXBvIHBpeGVsIGZsb2F0LCBzYXLDoCB1c2F0byBpbCBtZXRvZG88c3Ryb25nPkxpbmVhcmU8L3N0cm9uZz4uIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS48L2xpPjxsaT48c3Ryb25nPlBpw7kgdmljaW5vPC9zdHJvbmc+LS1pbCB2YWxvcmUgcGnDuSB2aWNpbm8gZGlzcG9uaWJpbGUgdmllbmUgdXNhdG8gcGVyIGlsIHBlcmNlbnRpbGUuIEluIHF1ZXN0byBjYXNvLCBpbCB0aXBvIGRpIHBpeGVsIGRpIG91dHB1dCDDqCBsbyBzdGVzc28gZGVsIHJhc3RlciBkaSB2YWxvcmUgZGkgaW5wdXQuPC9saT48bGk+PHN0cm9uZz5MaW5lYXJlPC9zdHJvbmc+OiBsYSBtZWRpYSBwZXNhdGEgZGVpIGR1ZSB2YWxvcmkgY2lyY29zdGFudGkgdmllbmUgdXNhdGEgcGVyIGlsIHBlcmNlbnRpbGUuIEluIHF1ZXN0byBjYXNvLCBpbCB0aXBvIGRpIHBpeGVsIGluIHVzY2l0YSBzYXLDoCBhIHZpcmdvbGEgbW9iaWxlLjwvbGk+PC91bD5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX3BlcmNlbnRpbGV2YWx1ZV90YWcwQEBcIjogXCI8cD5JbCBwZXJjZW50aWxlIGNoZSB2ZXJyw6AgY2FsY29sYXRvIHF1YW5kbzxzdHJvbmc+UGVyY2VudGlsZTwvc3Ryb25nPsOoIHNlbGV6aW9uYXRvIGNvbWUgdGlwbyBkaSBzdGF0aXN0aWNhLiBJbCB2YWxvcmUgcHJlZGVmaW5pdG8gw6ggOTAgcGVyIGlsIDkwZXNpbW8gcGVyY2VudGlsZS48L3A+PHA+SSB2YWxvcmkgcHXDsiBvc2NpbGxhcmUgZGEgMCBhIDEwMC4gSWwgcGVyY2VudGlsZSBudW1lcm8gMCDDqCBlc3NlbnppYWxtZW50ZSBsJ2VxdWl2YWxlbnRlIGRlbGxhIHN0YXRpc3RpY2EgbWluaW1hLCBlIGlsIHBlcmNlbnRpbGUgbnVtZXJvIDEwMCDDqCBsJ2VxdWl2YWxlbnRlIGRlbGxhIHN0YXRpc3RpY2EgbWFzc2ltYSwgZmF0dGEgZWNjZXppb25lIHBlciBpbCBmYXR0byBjaGUgaWwgcmlzdWx0YXRvIHNhcsOgIHVuYSB2aXJnb2xhIG1vYmlsZS4gVW4gdmFsb3JlIGRpIDUwIHByb2R1cnLDoCBsbyBzdGVzc28gcmlzdWx0YXRvIGRlbGxhIHN0YXRpc3RpY2EgbWVkaWFuYS48L3A+XCIsXG5cdFwiQEBEaW1lbnNpb25hbC1Nb3ZpbmctU3RhdGlzdGljc19zdGF0aXN0aWNzdHlwZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2EgaWwgdGlwbyBkaSBzdGF0aXN0aWNhIGRhIGNhbGNvbGFyZS48L3A+PHA+PC9wPjx1bD48bGk+PHN0cm9uZz5NZWRpYTwvc3Ryb25nPi0tVmVycsOgIGNhbGNvbGF0YSBsYSBtZWRpYSAodmFsb3JlIG1lZGlvKSBkZWxsZSBjZWxsZSBuZWxsYSBmaW5lc3RyYSBkZWZpbml0YS4gUXVlc3RhIMOoIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLjwvbGk+PGxpPjxzdHJvbmc+TWVkaWEgY2lyY29sYXJlPC9zdHJvbmc+LS1WZXJyw6AgY2FsY29sYXRhIGxhIG1lZGlhIGNpcmNvbGFyZSBkZWxsZSBjZWxsZSBuZWxsYSBmaW5lc3RyYSBkZWZpbml0YS4gUXVhbmRvIMOoIHNlbGV6aW9uYXRvIHF1ZXN0byB0aXBvIGRpIHN0YXRpc3RpY2EsIGlsIHBhcmFtZXRybzxzdHJvbmc+djwvc3Ryb25nPmFsb3JlIHdyYXAgY2lyY29sYXJlIGRpdmVudGEgZGlzcG9uaWJpbGUuPC9saT48bGk+PHN0cm9uZz5NYWdnaW9yYW56YTwvc3Ryb25nPi0tVmVycsOgIGlkZW50aWZpY2F0YSBsYSBtYWdnaW9yIHBhcnRlICh2YWxvcmUgY2hlIHNpIHZlcmlmaWNhIHBpw7kgc3Blc3NvKSBkZWxsZSBjZWxsZSBuZWxsYSBmaW5lc3RyYSBkZWZpbml0YS48L2xpPjxsaT48c3Ryb25nPk1hc3NpbW88L3N0cm9uZz4tLVZlcnLDoCBpZGVudGlmaWNhdG8gaWwgbWFzc2ltbyAodmFsb3JlIHBpw7kgZ3JhbmRlKSBkZWxsZSBjZWxsZSBuZWxsYSBmaW5lc3RyYSBkZWZpbml0YS48L2xpPjxsaT48c3Ryb25nPk1lZGlhbmE8L3N0cm9uZz4tLVNhcsOgIGlkZW50aWZpY2F0YSBsYSBtZWRpYW5hIGRlbGxlIGNlbGxlIGRlbCB2aWNpbmF0by48L2xpPjxsaT48c3Ryb25nPk1pbmltbzwvc3Ryb25nPi0tVmVycsOgIGlkZW50aWZpY2F0byBpbCBtaW5pbW8gKHZhbG9yZSBwacO5IHBpY2NvbG8pIGRlbGxlIGNlbGxlIG5lbGxlIHZpY2luYW56ZS48L2xpPjxsaT48c3Ryb25nPlBlcmNlbnRpbGU8L3N0cm9uZz4tLVZlcnLDoCBjYWxjb2xhdG8gdW4gcGVyY2VudGlsZSBkZWxsZSBjZWxsZSBkZWwgdmljaW5hdG8uIFF1YW5kbyBxdWVzdG8gdGlwbyBkaSBzdGF0aXN0aWNoZSDDqCBzZWxlemlvbmF0bywgZGl2ZW50YW5vIGRpc3BvbmliaWxpIGkgcGFyYW1ldHJpPHN0cm9uZz5WYWxvcmUgUGVyY2VudGlsZTwvc3Ryb25nPmU8c3Ryb25nPlRpcG8gZGkgaW50ZXJwb2xhemlvbmUgcGVyY2VudGlsZTwvc3Ryb25nPi4gVXRpbGl6emFyZSBxdWVzdGkgcGFyYW1ldHJpIHBlciBkZXNpZ25hcmUgaWwgcGVyY2VudGlsZSBkYSBjYWxjb2xhcmUgZSBzY2VnbGllcmUgcmlzcGV0dGl2YW1lbnRlIGlsIHRpcG8gZGkgaW50ZXJwb2xhemlvbmUgZGEgdXRpbGl6emFyZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX2RpbWVuc2lvbl90YWcwQEBcIjogXCI8cD5MYSBkaW1lbnNpb25lIHBlciBsJ3VzbyBkZWxsJ2ludGVycG9sYXppb25lLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIG5lY2Vzc2FyaW8gcXVhbmRvIGlsIHBhcmFtZXRybyA8c3Ryb25nPkRlZmluemlvbmUgZGltZW5zaW9uaTwvc3Ryb25nPsOoIGltcG9zdGF0byBhPHN0cm9uZz5QZXIgaW50ZXJ2YWxsbzwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX2RpbWVuc2lvbmRlZmluaXRpb25fdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGlsIG1ldG9kbyBjaGUgdmVycsOgIHV0aWxpenphdG8gcGVyIGZpbHRyYXJlIGkgZGF0aSBtdWx0aWRpbWVuc2lvbmFsaSBkaSBpbnB1dCBwcmltYSBkaSBlc2VndWlyZSBsJ2ludGVycG9sYXppb25lLjwvcD48dWw+PGxpPjxzdHJvbmc+UGVyIHZhbG9yaTwvc3Ryb25nPjogTGEgZGltZW5zaW9uZSB2ZXJyw6Agc3VkZGl2aXNhIHV0aWxpenphbmRvIHVuIHZhbG9yZSBkaSBkaW1lbnNpb25lIG8gdW4gZWxlbmNvIGRpIHZhbG9yaS48L2xpPjxsaT48c3Ryb25nPlBlciBpbnRlcnZhbGxvPC9zdHJvbmc+OiBMYSBkaW1lbnNpb25lIHZlcnLDoCBzdWRkaXZpc2EgdXRpbGl6emFuZG8gdW4gaW50ZXJ2YWxsbyBvIHVuIGVsZW5jbyBkaSBpbnRlcnZhbGxpLjwvbGk+PGxpPjxzdHJvbmc+UGVyIHJhc3RlciBkaSBkZXN0aW5hemlvbmU8L3N0cm9uZz46IExhIGRpbWVuc2lvbmUgdmVycsOgIHRhZ2xpYXRhIHV0aWxpenphbmRvIHVubyBzcGVjaWZpY28gcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGRpIGRlc3RpbmF6aW9uZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX2VuZG9maW50ZXJ2YWxfdGFnMEBAXCI6IFwiPHA+TGEgZmluZSBkZWxsJ2ludGVydmFsbG8sIHV0aWxpenphdG8gcGVyIHNjb3JyZXJlIGlsIHNldCBkaSBkYXRpLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIG9iYmxpZ2F0b3JpbyBxdWFuZG8gaWwgcGFyYW1ldHJvPHN0cm9uZz5EZWZpbml6aW9uZSBkaW1lbnNpb25pPC9zdHJvbmc+w6ggaW1wb3N0YXRvIGEgPHN0cm9uZz5QZXIgaW50ZXJ2YWxsbzwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX2lnbm9yZW5vZGF0YV90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2Egc2UgaSB2YWxvcmkgTm9EYXRhIHZlcnJhbm5vIGlnbm9yYXRpIG5lbGwnYW5hbGlzaS48L3A+PHVsPjxsaT5EZXNlbGV6aW9uYXRvOiBsJ2FuYWxpc2kgcmlzdWx0ZXLDoCBpbiBOb0RhdGEgc2Ugc29ubyBwcmVzZW50aSB2YWxvcmkgTm9EYXRhIG5lbGxlIHNlemlvbmkgYWRpYWNlbnRpLiBRdWVzdGEgaW1wb3N0YXppb25lIMOoIHByZWRlZmluaXRhLjwvbGk+PGxpPlNlbGV6aW9uYXRvOiBsJ2FuYWxpc2kgdXRpbGl6emVyw6Agc29sbyBsZSBzZXppb25pIGNvbiBwaXhlbCB2YWxpZGkgZSBpZ25vcmVyw6AgbGUgc2V6aW9uaSBOb0RhdGEuPC9saT48L3VsPlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtUmFzdGVyLUJ5LURpbWVuc2lvbl9pbnRlcnBvbGF0aW9ubWV0aG9kX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmljYSBpbCBtZXRvZG8gY2hlIHZlcnLDoCB1dGlsaXp6YXRvIHBlciBpbnRlcnBvbGFyZSBpbCByYXN0ZXIuPC9wPjx1bD48bGk+PHN0cm9uZz5MaW5lYXJlPC9zdHJvbmc+LS1MJ291dHB1dCB2ZXJyw6AgaW50ZXJwb2xhdG8gbGluZWFybWVudGUgdXRpbGl6emFuZG8gbGUgZmV0dGUgYWRpYWNlbnRpLiBRdWVzdGEgaW1wb3N0YXppb25lIMOoIHByZWRlZmluaXRhPC9saT48bGk+PHN0cm9uZz5JbCB2aWNpbm8gcGnDuSBwcm9zc2ltbzwvc3Ryb25nPjogTCdvdXRwdXQgdXRpbGl6emVyw6AgbGEgc2xpY2UgYWRpYWNlbnRlIHBpw7kgdmljaW5hLjwvbGk+PC91bD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25fcmFzdGVyX3RhZzBAQFwiOiBcIjxwPklsIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBkaSBpbnB1dC48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX3N0YXJ0b2ZpbnRlcnZhbF90YWcwQEBcIjogXCI8cD5MJ2luaXppbyBkZWxsJ2ludGVydmFsbG8sIHV0aWxpenphdG8gcGVyIHNjb3JyZXJlIGlsIHNldCBkaSBkYXRpLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIG9iYmxpZ2F0b3JpbyBxdWFuZG8gaWwgcGFyYW1ldHJvPHN0cm9uZz5EZWZpbml6aW9uZSBkaW1lbnNpb25pPC9zdHJvbmc+w6ggaW1wb3N0YXRvIGEgPHN0cm9uZz5QZXIgaW50ZXJ2YWxsbzwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX3N0ZXBfdGFnMEBAXCI6IFwiPHA+TGEgZnJlcXVlbnphIGNvbiBjdWkgaSBkYXRpIHZlcnJhbm5vIGludGVycG9sYXRpLi48L3A+PHA+UXVlc3RvIHBhcmFtZXRybyDDqCBuZWNlc3NhcmlvIHF1YW5kbyBpbCBwYXJhbWV0cm88c3Ryb25nPkRlZmluaXppb25lIGRpbWVuc2lvbmk8L3N0cm9uZz4gw6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+UGVyIGludGVydmFsbDwvc3Ryb25nPm8uPC9wPlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtUmFzdGVyLUJ5LURpbWVuc2lvbl90YXJnZXRyYXN0ZXJfdGFnMEBAXCI6IFwiPHA+SWwgcmFzdGVyIGRpIGRlc3RpbmF6aW9uZSBzcGVjaWZpY2F0byBkYWxsYSBkZWZpbml6aW9uZSBkZWxsYSBkaW1lbnNpb25lLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIG5lY2Vzc2FyaW8gcXVhbmRvIGlsIHBhcmFtZXRybyA8c3Ryb25nPkRlZmluaXppb25lIGRpbWVuc2lvbmU8L3N0cm9uZz7DqCBpbXBvc3RhdG8gc3UgPHN0cm9uZz5QZXIgUmFzdGVyIGRpIGRlc3RpbmF6aW9uZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX3VuaXRfdGFnMEBAXCI6IFwiPHA+TCd1bml0w6AgZGkgaW50ZXJ2YWxsby48L3A+PHA+UXVlc3RvIHBhcmFtZXRybyDDqCBuZWNlc3NhcmlvIHF1YW5kbyBpbCBwYXJhbWV0cm88c3Ryb25nPkRlZmluaXppb25lIGRpbWVuc2lvbmk8L3N0cm9uZz7DqCBpbXBvc3RhdG8gYTxzdHJvbmc+UGVyIGludGVydmFsbG88L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtUmFzdGVyLUJ5LURpbWVuc2lvbl92YWx1ZXNfdGFnMEBAXCI6IFwiPHA+SSB2YWxvcmkgZGltZW5zaW9uYWxpIGRhIHV0aWxpenphcmUgcGVyIGZpbHRyYXJlIGkgZGF0aSBtdWx0aWRpbWVuc2lvbmFsaSBkaSBpbnB1dCBwZXIgbCdhbmFsaXNpLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIG9iYmxpZ2F0b3JpbyBxdWFuZG8gaWwgcGFyYW1ldHJvPHN0cm9uZz5EZWZpbml6aW9uZSBkaW1lbnNpb25pPC9zdHJvbmc+PHN0cm9uZz5QZXIgdmFsb3JlPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25fdmFyaWFibGVzX3RhZzBAQFwiOiBcIjxwPkxhIHZhcmlhYmlsZSBvIGxlIHZhcmlhYmlsaSBjaGUgdmVycmFubm8gaW50ZXJwb2xhdGUgZGFsbGEgZGVmaW5pemlvbmUgZGVsbGEgZGltZW5zaW9uZS48L3A+XCIsXG5cdFwiQEBUZXJyYWluLUZsYXR0ZW5fY2FsaWJyYXRpb250eXBlX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmljYSBzZSBsJ291dHB1dCBwcmV2ZWRlIGlsIGxpdmVsbGFtZW50byB0ZXJyZW5vIHVzYW5kbyBpbCBtZXRvZG88c3Ryb25nPlNpZ21hIG5vdWdodDwvc3Ryb25nPm88c3Ryb25nPkdhbW1hIG5vdWdodDwvc3Ryb25nPi48L3A+PHVsPjxsaT48c3Ryb25nPkdhbW1hIG5vdWdodDwvc3Ryb25nPjogbGEgcmV0cm9kaWZmdXNpb25lIEJldGEgbm91Z2h0IHNhcsOgIG5vcm1hbGl6emF0YSB1dGlsaXp6YW5kbyBsJ2FyZWEgdW5pdGFyaWEgZGkgdW4gcGlhbm8gbG9jYWxtZW50ZSB0YW5nZW50ZSBhbCBERU0sIGNvbXVuZW1lbnRlIG5vdG8gY29tZSBhbmdvbG8gZGkgaW5jaWRlbnphIGxvY2FsZS4gw4ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuPC9saT48bGk+PHN0cm9uZz5TaWdtYSBub3VnaHQ8L3N0cm9uZz46IGxhIHJldHJvZGlmZnV6aW9uZSBiZXRhIHplcm8gc2Fyw6Agbm9ybWFsaXp6YXRhIHV0aWxpenphbmRvIHVuIERFTSBwZXIgY2FsY29sYXJlIGwnYXJlYS48L2xpPjwvdWw+XCIsXG5cdFwiQEBUZXJyYWluLUZsYXR0ZW5fZGVtX3RhZzBAQFwiOiBcIjxwPklsIERFTSBkaSBpbnB1dC48L3A+PHA+SWwgREVNIHZpZW5lIHV0aWxpenphdG8gcGVyIHN0aW1hcmUgbCdhcmVhIGlsbHVtaW5hdGEgbG9jYWxlLjwvcD5cIixcblx0XCJAQFRlcnJhaW4tRmxhdHRlbl9nZW9pZF90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2Egc2UgaWwgc2lzdGVtYSBkaSByaWZlcmltZW50byB2ZXJ0aWNhbGUgZGVsIERFTSBpbiBpbmdyZXNzbyBkZXZlIGVzc2VyZSB0cmFzZm9ybWF0byBpbiBhbHRlenphIGVsbGlzc29pZGljYS4gTGEgbWFnZ2lvciBwYXJ0ZSBkZWkgZGF0YXNldCBhbHRpbWV0cmljaSBzb25vIHJpZmVyaXRpIGFsbCdhbHRlenphIG9ydG9tZXRyaWNhIGRlbCBsaXZlbGxvIGRlbCBtYXJlLCBxdWluZGkgaW4gcXVlc3RpIGNhc2kgw6ggbmVjZXNzYXJpYSB1bmEgY29ycmV6aW9uZSBwZXIgY29udmVydGlybGkgaW4gYWx0ZXp6YSBlbGxpc3NvaWRpY2EuPC9wPjx1bD48bGk+U2VsZXppb25hdG86IHZlcnLDoCBlZmZldHR1YXRhIHVuYSBjb3JyZXppb25lIGRlbCBnZW9pZGUgcGVyIGNvbnZlcnRpcmUgbCdhbHRlenphIG9ydG9tZXRyaWNhIGluIGFsdGV6emEgZWxsaXNzb2lkaWNhIChiYXNhdGEgc3VsIGdlb2lkZSBFR005NikuIMOIIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLjwvbGk+PGxpPk5vbiBzZWxlemlvbmF0bzogbm9uIHZlcnLDoCBlZmZldHR1YXRhIGFsY3VuYSBjb3JyZXppb25lIGRlbCBnZW9pZGUuIFVzYSBxdWVzdGEgb3B6aW9uZSBzb2xvIHNlIGlsIERFTSDDqCBlc3ByZXNzbyBpbiBhbHRlenphIGVsbGlzc29pZGljYS48L2xpPjwvdWw+XCIsXG5cdFwiQEBUZXJyYWluLUZsYXR0ZW5fcmFzdGVyX3RhZzBAQFwiOiBcIjxwPkRhdGkgcmFkYXIgZGkgaW5wdXQuPC9wPjxwPlF1ZXN0byByYXN0ZXIgZGV2ZSBwcmltYSBlc3NlcmUgY2FsaWJyYXRvIHJhZGlvbWV0cmljYW1lbnRlIGEgYmV0YSBub3VnaHQuPC9wPlwiLFxuXHRcIkBAQ3JlYXRlLUNvbG9yLUNvbXBvc2l0ZV9ibHVlZXhwcmVzc2lvbl90YWcwQEBcIjogXCI8cD5JbCBjYWxjb2xvIGFzc2VnbmF0byBhbGxhIHRlcnphIGJhbmRhLjwvcD48cD5VbiBub21lIGRpIGJhbmRhLCB1biBJRCBkaSBiYW5kYSBvIHVuJ2VzcHJlc3Npb25lIGFsZ2VicmljYSBjaGUgdXRpbGl6emEgbGUgYmFuZGUuPC9wPjxwPkdsaSBvcGVyYXRvcmkgc3VwcG9ydGF0aSBzb25vIHVuYXJpOiBwacO5ICgrKSwgbWVubyAoLSksIHZvbHRlICgqKSBlIGRpdmlkaSAoLykuPC9wPlwiLFxuXHRcIkBAQ3JlYXRlLUNvbG9yLUNvbXBvc2l0ZV9ncmVlbmV4cHJlc3Npb25fdGFnMEBAXCI6IFwiPHA+SWwgY2FsY29sbyBhc3NlZ25hdG8gYWxsYSBzZWNvbmRhIGJhbmRhLjwvcD48cD5VbiBub21lIGRpIGJhbmRhLCB1biBJRCBkaSBiYW5kYSBvIHVuJ2VzcHJlc3Npb25lIGFsZ2VicmljYSBjaGUgdXRpbGl6emEgbGUgYmFuZGUuPC9wPjxwPkdsaSBvcGVyYXRvcmkgc3VwcG9ydGF0aSBzb25vIHVuYXJpOiBwacO5ICgrKSwgbWVubyAoLSksIHZvbHRlICgqKSBlIGRpdmlkaSAoLykuPC9wPlwiLFxuXHRcIkBAQ3JlYXRlLUNvbG9yLUNvbXBvc2l0ZV9pbnB1dHJhc3Rlcl90YWcwQEBcIjogXCI8cD5JIGRhdGkgcmFzdGVyIG11bHRpYmFuZGEgaW4gaW5wdXQuPC9wPlwiLFxuXHRcIkBAQ3JlYXRlLUNvbG9yLUNvbXBvc2l0ZV9tZXRob2RfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGlsIG1ldG9kbyBjaGUgdmVycsOgIHV0aWxpenphdG8gcGVyIGVzdHJhcnJlIGxlIGJhbmRlLjwvcD48dWw+PGxpPk5vbWkgZGVsbGUgYmFuZGU6IHZpZW5lIHV0aWxpenphdG8gaWwgbm9tZSBkZWxsYSBiYW5kYSBjaGUgcmFwcHJlc2VudGEgbCdpbnRlcnZhbGxvIGRpIGx1bmdoZXp6YSBkJ29uZGEgZGVsbG8gc3BldHRybyBlbGV0dHJvbWFnbmV0aWNvIChjb21lIFJvc3NvLCBJbmZyYXJvc3NvIHZpY2lubyBvIEluZnJhcm9zc28gdGVybWljbykgbyBsYSBwb2xhcml6emF6aW9uZSAoY29tZSBWSCwgVlYsIEhIIG8gSFYpLiDDiCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS48L2xpPjxsaT5JRCBiYW5kYTogdmllbmUgdXRpbGl6emF0byBpbCBudW1lcm8gZGVsbGEgYmFuZGEgKGFkIGVzZW1waW8gQjEsIEIyIG8gQjMpLjwvbGk+PC91bD5cIixcblx0XCJAQENyZWF0ZS1Db2xvci1Db21wb3NpdGVfcmVkZXhwcmVzc2lvbl90YWcwQEBcIjogXCI8cD5JbCBjYWxjb2xvIGFzc2VnbmF0byBhbGxhIHByaW1hIGJhbmRhLjwvcD48cD5VbiBub21lIGRpIGJhbmRhLCB1biBJRCBkaSBiYW5kYSBvIHVuJ2VzcHJlc3Npb25lIGFsZ2VicmljYSBjaGUgdXRpbGl6emEgbGUgYmFuZGUuPC9wPjxwPkdsaSBvcGVyYXRvcmkgc3VwcG9ydGF0aSBzb25vIHVuYXJpOiBwacO5ICgrKSwgbWVubyAoLSksIHZvbHRlICgqKSBlIGRpdmlkaSAoLykuPC9wPlwiLFxuXHRcIkBAU3VyZmFjZS1QYXJhbWV0ZXJzX2xvY2Fsc3VyZmFjZXR5cGVfdGFnMEBAXCI6IFwiPHA+U2NlZ2xpIGlsIHRpcG8gZGkgZnVuemlvbmUgc3VwZXJmaWNpZSBkYSBhZGF0dGFyZSBhdHRvcm5vIGFsbGEgY2VsbGEgZGkgZGVzdGluYXppb25lLjwvcD48dWw+PGxpPlF1YWRyYXRpY2E6IGFsbGUgY2VsbGUgZGVsIHF1YXJ0aWVyZSB2ZXJyw6AgYWRhdHRhdGEgdW5hIGZ1bnppb25lIHN1cGVyZmljaWUgcXVhZHJhdGljYS4gw4ggaWwgdGlwbyBwcmVkZWZpbml0by48L2xpPjxsaT5CaXF1YWRyYXRpY2E6IGFsbGUgY2VsbGUgZGVsIHF1YXJ0aWVyZSB2ZXJyw6AgYWRhdHRhdGEgdW5hIGZ1bnppb25lIHN1cGVyZmljaWUgYmlxdWFkcmF0aWNhLjwvbGk+PC91bD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc19uZWlnaGJvcmhvb2RkaXN0YW5jZV90YWcwQEBcIjogXCI8cD5MJ291dHB1dCB2ZXJyw6AgY2FsY29sYXRvIHBlciBxdWVzdGEgZGlzdGFuemEgZGFsIGNlbnRybyBkZWxsYSBjZWxsYSBkaSBkZXN0aW5hemlvbmUuIERldGVybWluYSBsYSBkaW1lbnNpb25lIGRlbCBxdWFydGllcmUuIElsIHZhbG9yZSBwcmVkZWZpbml0byDDqCBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHJhc3RlciBkaSBpbnB1dCwgY2hlIGdlbmVyYSB1biBxdWFydGllcmUgZGkgMyBwZXIgMy48L3A+XCIsXG5cdFwiQEBTdXJmYWNlLVBhcmFtZXRlcnNfb3V0cHV0c2xvcGVtZWFzdXJlbWVudF90YWcwQEBcIjogXCI8cD5MZSB1bml0w6AgZGkgbWlzdXJhIChncmFkaSBvIHBlcmNlbnR1YWxpKSBjaGUgdmVycmFubm8gdXRpbGl6emF0ZSBwZXIgaWwgcmFzdGVyIHBlciBsYSBwZW5kZW56YSBkaSBvdXRwdXQuIFF1ZXN0byBwYXJhbWV0cm8gw6ggYXR0aXZvIHNvbG8gcXVhbmRvIDxzdHJvbmc+VGlwbyBkaSBwYXJhbWV0cm88L3N0cm9uZz7DqDxzdHJvbmc+UGVuZGVuemE8L3N0cm9uZz4uPC9wPjx1bD48bGk+R3JhZGk6IGwnaW5jbGluYXppb25lIGRlbGxhIHBlbmRlbnphIHZlcnLDoCBjYWxjb2xhdGEgaW4gZ3JhZGkuIMOIIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLjwvbGk+PGxpPkluY3JlbWVudG8gcGVyY2VudHVhbGU6IGwnaW5jbGluYXppb25lIGRlbGxhIHBlbmRlbnphIHZlcnLDoCBjYWxjb2xhdGEgY29tZSBpbmNyZW1lbnRvIHBlcmNlbnR1YWxlLCBkZXR0byBhbmNoZSBwZW5kZW56YSBwZXJjZW50dWFsZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBTdXJmYWNlLVBhcmFtZXRlcnNfcGFyYW1ldGVydHlwZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpY2EgaWwgdGlwbyBkaSBwYXJhbWV0cm8gZGVsbGEgc3VwZXJmaWNpZSBkaSBvdXRwdXQgY2hlIHZlcnLDoCBjYWxjb2xhdG8uPC9wPjx1bD48bGk+UGVuZGVuemE6IHZlcnLDoCBjYWxjb2xhdGEgbGEgcmFwaWRpdMOgIGRpIGNhbWJpYW1lbnRvIGRlbGwnZWxldmF6aW9uZS4gw4ggbCdpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEuPC9saT48bGk+QXNwZXR0bzogdmVycsOgIGNhbGNvbGF0YSBsYSBkaXJlemlvbmUgZGVsbGEgcGVuZGVuemEgZGlzY2VuZGVudGUgZGVsbGEgcmFwaWRpdMOgIG1hc3NpbWEgZGkgY2FtYmlhbWVudG8gcGVyIG9nbmkgY2VsbGEuPC9saT48bGk+Q3VydmF0dXJhIG1lZGlhOiB2ZXJyw6AgbWlzdXJhdGEgbGEgY3VydmF0dXJhIGNvbXBsZXNzaXZhIGRlbGxhIHN1cGVyZmljaWUuIFZpZW5lIGNhbGNvbGF0YSBjb21lIG1lZGlhIGRlbGxhIGN1cnZhdHVyYSBtaW5pbWEgZSBtYXNzaW1hLiBRdWVzdGEgY3VydmF0dXJhIGRlc2NyaXZlIGxhIGNvbnZlc3NpdMOgIG8gbGEgY29uY2F2aXTDoCBpbnRyaW5zZWNhIGRlbGxhIHN1cGVyZmljaWUsIGluZGlwZW5kZW50ZW1lbnRlIGRhbGxhIGRpcmV6aW9uZSBvIGRhbGxhIGdyYXZpdMOgLjwvbGk+PGxpPkN1cnZhdHVyYSB0YW5nZW56aWFsZSAoY29udG9ybm8gbm9ybWFsZSk6IHZlcnLDoCBtaXN1cmF0YSBsYSBjdXJ2YXR1cmEgbm9ybWFsZSBnZW9tZXRyaWNhIHBlcnBlbmRpY29sYXJlIGFsbGEgbGluZWEgZGVsbGEgcGVuZGVuemEsIHRhbmdlbnRlIGFsbGEgbGluZWEgZGkgY29udG9ybm8uIFF1ZXN0YSBjdXJ2YXR1cmEgZ2VuZXJhbG1lbnRlIHZpZW5lIGFwcGxpY2F0YSBwZXIgY2FyYXR0ZXJpenphcmUgbGEgY29udmVyZ2VuemEgbyBsYSBkaXZlcmdlbnphIGRpIHVuIGZsdXNzbyBhdHRyYXZlcnNvIGxhIHN1cGVyZmljaWUuPC9saT48bGk+Q3VydmF0dXJhIHByb2ZpbG8gKGxpbmVhIHBlbmRlbnphIG5vcm1hbGUpOiB2ZXJyw6AgbWlzdXJhdGEgbGEgY3VydmF0dXJhIG5vcm1hbGUgZ2VvbWV0cmljYSBsdW5nbyBsYSBsaW5lYSBkaSBwZW5kZW56YS4gUXVlc3RhIGN1cnZhdHVyYSBnZW5lcmFsbWVudGUgdmllbmUgYXBwbGljYXRhIHBlciBjYXJhdHRlcml6emFyZSBsJ2FjY2VsZXJhemlvbmUgZSBsYSBkZWNlbGVyYXppb25lIGRpIHVuIGZsdXNzbyBkaXNjZW5kZW50ZSBsdW5nbyBsYSBzdXBlcmZpY2llLjwvbGk+PGxpPkN1cnZhdHVyYSBwaWFubyAoY29udG9ybm8gcHJvZ2V0dGF0byk6IHZlcnLDoCBtaXN1cmF0YSBsYSBjdXJ2YXR1cmEgbHVuZ28gbGUgbGluZWUgZGkgY29udG9ybm8uPC9saT48bGk+VG9yc2lvbmUgZ2VvZGV0aWNhIGNvbnRvcm5vOiB2ZXJyw6AgbWlzdXJhdGEgbGEgcmFwaWRpdMOgIGRpIGNhbWJpYW1lbnRvIGRlbGwnYW5nb2xvIGRlbGxhIHBlbmRlbnphIGx1bmdvIGxlIGxpbmVlIGRpIGNvbnRvcm5vLjwvbGk+PGxpPkN1cnZhdHVyYSBnYXVzc2lhbmE6IHZlcnLDoCBtaXN1cmF0YSBsYSBjdXJ2YXR1cmEgY29tcGxlc3NpdmEgZGVsbGEgc3VwZXJmaWNpZS4gVmllbmUgY2FsY29sYXRhIGNvbWUgcHJvZG90dG8gZGVsbGEgY3VydmF0dXJhIG1pbmltYSBlIG1hc3NpbWEuPC9saT48bGk+Q3VydmF0dXJhIGRpIENhc29yYXRpOiB2ZXJyw6AgbWlzdXJhdGEgbGEgY3VydmF0dXJhIGdlbmVyYWxlIGRlbGxhIHN1cGVyZmljaWUuIFB1w7IgZXNzZXJlIHplcm8gbyBxdWFsdW5xdWUgbnVtZXJvIHBvc2l0aXZvLjwvbGk+PC91bD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc19wcm9qZWN0Z2VvZGVzaWNhemltdXRoc190YWcwQEBcIjogXCI8cD5TcGVjaWZpY2Egc2UgZ2xpIGF6aW11dCBnZW9kZXRpY2kgdmVycmFubm8gcHJvaWV0dGF0aSBwZXIgY29ycmVnZ2VyZSBsYSBkaXN0b3JzaW9uZSBhbmdvbGFyZSBjYXVzYXRhIGRhIHJpZmVyaW1lbnRvIHNwYXppYWxlIGRpIG91dHB1dC4gUXVlc3RvIHBhcmFtZXRybyDDqCBhdHRpdm8gc29sbyBxdWFuZG8gPHN0cm9uZz5UaXBvIGRpIHBhcmFtZXRybzwvc3Ryb25nPsOoPHN0cm9uZz5Bc3BldHRvPC9zdHJvbmc+LjwvcD48dWw+PGxpPk5vbiBzZWxlemlvbmF0bzogZ2xpIGF6aW11dCBnZW9kZXRpY2kgbm9uIHZlcnJhbm5vIHByb2lldHRhdGkuIMOIIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLjwvbGk+PGxpPlNlbGV6aW9uYXRvOiB2ZXJyYW5ubyBwcm9pZXR0YXRpIGdsaSBhemltdXQgZ2VvZGV0aWNpLjwvbGk+PC91bD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc19yYXN0ZXJfdGFnMEBAXCI6IFwiPHA+SWwgcmFzdGVyIHN1cGVyZmljaWUgZGkgaW5wdXQuIFB1w7IgZXNzZXJlIHVuIHJhc3RlciBpbnRlcm8gbyBpbiB2aXJnb2xhIG1vYmlsZS48L3A+XCIsXG5cdFwiQEBTdXJmYWNlLVBhcmFtZXRlcnNfdXNlYWRhcHRpdmVuZWlnaGJvcmhvb2RfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIHNlIGxhIGRpc3RhbnphIGRlbCBxdWFydGllcmUgdmFyaWEgY29uIGkgY2FtYmlhbWVudGkgZGVsIHBhZXNhZ2dpbyAoYWRhdHRpdmEpLiBMYSBkaXN0YW56YSBtYXNzaW1hIMOoIGRldGVybWluYXRhIGRhbGxhIGRpc3RhbnphIGRlbCBxdWFydGllcmUuIExhIGRpc3RhbnphIG1pbmltYSDDqCBsYSBkaW1lbnNpb25lIGRlbGxhIGNlbGxhIHJhc3RlciBkaSBpbnB1dC48L3A+PHVsPjxsaT5Ob24gc2VsZXppb25hdG86IGluIHR1dHRlIGxlIHBvc2l6aW9uaSB2ZXJyw6AgdXRpbGl6emF0YSB1bmEgc2luZ29sYSBkaXN0YW56YSBkZWwgcXVhcnRpZXJlIChmaXNzYSkuIMOIIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLjwvbGk+PGxpPlNlbGV6aW9uYXRvOiBpbiB0dXR0ZSBsZSBwb3NpemlvbmkgdmVycsOgIHV0aWxpenphdGEgdW5hIGRpc3RhbnphIGFkYXR0aXZhIGRlbCBxdWFydGllcmUuPC9saT48L3VsPlwiLFxuXHRcIkBAU3VyZmFjZS1QYXJhbWV0ZXJzX3VzZWVxdWF0b3JpYWxhc3BlY3RfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIHNlIGwnYXNwZXR0byB2ZXJyw6AgbWlzdXJhdG8gZGEgdW4gcHVudG8gc3VsbCdlcXVhdG9yZSBvIGRhbCBwb2xvIG5vcmQuIFF1ZXN0byBwYXJhbWV0cm8gw6ggYXR0aXZvIHNvbG8gcXVhbmRvIDxzdHJvbmc+VGlwbyBkaSBwYXJhbWV0cm8gPC9zdHJvbmc+w6g8c3Ryb25nPkFzcGV0dG88L3N0cm9uZz4uPC9wPjx1bD48bGk+Tm9uIHNlbGV6aW9uYXRvOiBsJ2FzcGV0dG8gdmVycsOgIG1pc3VyYXRvIGRhbCBwb2xvIG5vcmQuIMOIIGwnaW1wb3N0YXppb25lIHByZWRlZmluaXRhLjwvbGk+PGxpPlNlbGV6aW9uYXRvOiBsJ2FzcGV0dG8gdmVycsOgIG1pc3VyYXRvIGRhIHVuIHB1bnRvIHN1bGwnZXF1YXRvcmUuPC9saT48L3VsPlwiLFxuXHRcIkBAU3VyZmFjZS1QYXJhbWV0ZXJzX3p1bml0X3RhZzBAQFwiOiBcIjxwPkwndW5pdMOgIGxpbmVhcmUgZGkgdmFsb3JpIHogdmVydGljYWxpLjwvcD48cD7DiCBkZWZpbml0YSBkYSB1biBzaXN0ZW1hIGRpIGNvb3JkaW5hdGUgdmVydGljYWxpLCBzZSBlc2lzdGUuIFNlIG5vbiBlc2lzdGUgdW4gc2lzdGVtYSBkaSBjb29yZGluYXRlIHZlcnRpY2FsaSwgbCd1bml0w6AgWiBkZXZlIGVzc2VyZSBkZWZpbml0YSBkYWxsJ2VsZW5jbyB1bml0w6AgcGVyIGdhcmFudGlyZSBpbCBjYWxjb2xvIGdlb2RldGljbyBjb3JyZXR0by48L3A+PHVsPjxsaT5Qb2xsaWNpOiBsJ3VuaXTDoCBsaW5lYXJlIHNhcsOgIGluIHBvbGxpY2kuPC9saT48bGk+UGllZGk6IGwndW5pdMOgIGxpbmVhcmUgc2Fyw6AgaW4gcGllZGkuPC9saT48bGk+SWFyZGU6IGwndW5pdMOgIGxpbmVhcmUgc2Fyw6AgaW4gaWFyZGUuPC9saT48bGk+TWlnbGlhIFVTQTogbCd1bml0w6AgbGluZWFyZSBzYXLDoCBpbiBtaWdsaWEuPC9saT48bGk+TWlnbGlhIG5hdXRpY2hlOiBsJ3VuaXTDoCBsaW5lYXJlIHNhcsOgIGluIG1pZ2xpYSBuYXV0aWNoZS48L2xpPjxsaT5NaWxsaW1ldHJpOiBsJ3VuaXTDoCBsaW5lYXJlIHNhcsOgIGluIG1pbGxpbWV0cmkuPC9saT48bGk+Q2VudGltZXRyaTogbCd1bml0w6AgbGluZWFyZSBzYXLDoCBpbiBjZW50aW1ldHJpLjwvbGk+PGxpPk1ldHJpOiBsJ3VuaXTDoCBsaW5lYXJlIHNhcsOgIGluIG1ldHJpLiDDiCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS48L2xpPjxsaT5DaGlsb21ldHJpOiBsJ3VuaXTDoCBsaW5lYXJlIHNhcsOgIGluIGNoaWxvbWV0cmkuPC9saT48bGk+RGVjaW1ldHJpOiBsJ3VuaXTDoCBsaW5lYXJlIHNhcsOgIGluIGRlY2ltZXRyaS48L2xpPjwvdWw+XCIsXG5cdFwiQEBTdXJmYWNlLVBhcmFtZXRlcnNfYW5hbHlzaXNtYXNrX3RhZzBAQFwiOiBcIjxwPlVuIHJhc3RlciBjaGUgc3BlY2lmaWNhIGxlIHBvc2l6aW9uaSBpbiBjdWkgc2kgdmVyaWZpY2hlcsOgIGwnYW5hbGlzaS48L3A+PHA+SWwgcmFzdGVyIHB1w7IgZXNzZXJlIGRpIHRpcG8gaW50ZXJvIG8gYSB2aXJnb2xhIG1vYmlsZS48L3A+PHA+VHV0dGUgbGUgY2VsbGUgY29uIHVuIHZhbG9yZSB2YWxpZG8sIGluY2x1c28gemVybywgY29tcG9ycmFubm8gbGEgbWFzY2hlcmEuIExlIGNlbGxlIGNoZSBzb25vIE5vRGF0YSBuZWxsJ2lucHV0IGRlbGxhIG1hc2NoZXJhIHNhcmFubm8gTm9EYXRhIG5lbGwnb3V0cHV0LjwvcD5cIixcblx0XCJAQEdlb21ldHJpYy1NZWRpYW5fY2VsbHNpemV0eXBlX3RhZzBAQFwiOiBcIjxwPlNjZWdsaWVyZSBxdWFsZSBncmFuZGV6emEgZGkgY2VsbGEgdXRpbGl6emFyZSBuZWwgcmFzdGVyIGRpIG91dHB1dC4gU2UgdHV0dGUgbGUgZ3JhbmRlenplIGRpIGNlbGxlIGRpIGlucHV0IHNvbm8gbGUgc3Rlc3NlLCB0dXR0ZSBsZSBvcHppb25pIHByb2R1cnJhbm5vIGdsaSBzdGVzc2kgcmlzdWx0YXRpLjwvcD48dWw+PGxpPlByaW1vIGRpOiB1dGlsaXp6YSBsYSBwcmltYSBncmFuZGV6emEgZGkgY2VsbGEgZGVpIHJhc3RlciBkaSBpbnB1dC48L2xpPjxsaT5NaW4gZGk6IHV0aWxpenphIGxhIGdyYW5kZXp6YSBkaSBjZWxsYSBtaW5vcmUgZGkgcmFzdGVyIGRpIGlucHV0LjwvbGk+PGxpPk1heCBkaTogdXRpbGl6emEgbGEgZ3JhbmRlenphIGRpIGNlbGxhIG1hZ2dpb3JlIGRpIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L2xpPjxsaT5NZWRpYSBkaTogdXRpbGl6emEgbGEgZ3JhbmRlenphIGRpIGNlbGxhIG1lZGlhIGRpIHR1dHRpIGkgcmFzdGVyIGRpIGlucHV0LjwvbGk+PGxpPlVsdGltbyBkaTogdXRpbGl6emEgbCd1bHRpbWEgZ3JhbmRlenphIGRpIGNlbGxhIGRpIHJhc3RlciBkaSBpbnB1dC48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW9tZXRyaWMtTWVkaWFuX2Vwc2lsb25fdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWNhIGlsIHZhbG9yZSBkaSBjb252ZXJnZW56YSB0cmEgZHVlIGl0ZXJhemlvbmkgY29uc2VjdXRpdmUuIFF1YW5kbyBlcHNpbG9uIMOoIG1pbm9yZSBvIHVndWFsZSBhbCB2YWxvcmUgc3BlY2lmaWNhdG8sIGwnaXRlcmF6aW9uZSBzaSBpbnRlcnJvbXBlIGUgdmllbmUgdXRpbGl6emF0byBpbCByaXN1bHRhdG8gZGVsbCd1bHRpbWEgaXRlcmF6aW9uZS48L3A+XCIsXG5cdFwiQEBHZW9tZXRyaWMtTWVkaWFuX2V4dGVudHR5cGVfdGFnMEBAXCI6IFwiPHA+U2NlZ2xpIHF1YWxlIGVzdGVuc2lvbmUgdXRpbGl6emFyZSBuZWwgcmFzdGVyIGRpIG91dHB1dDo8L3A+PHVsPjxsaT48cD5QcmltbyBkaTogdXNhIGwnZXN0ZW5zaW9uZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLjwvcD48L2xpPjxsaT5JbnRlcnNlemlvbmUgZGk6IHVzYSBsJ2VzdGVuc2lvbmUgZGVpIHBpeGVsIHNvdnJhcHBvc3RpIHBlciBkZXRlcm1pbmFyZSBsJ2VzdGVuc2lvbmUgZGkgZWxhYm9yYXppb25lLiBRdWVzdGEgw6ggbCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdC48L2xpPjxsaT5VbmlvbmUgZGk6IHVzYXJlIGwnZXN0ZW5zaW9uZSBkaSB0dXR0aSBpIHJhc3RlciBwZXIgZGV0ZXJtaW5hcmUgbCdlc3RlbnNpb25lIGRpIGVsYWJvcmF6aW9uZS48L2xpPjxsaT5VbHRpbW8gZGk6IHVzYXJlIGwnZXN0ZW5zaW9uZSBkZWxsJ3VsdGltbyByYXN0ZXIgZGkgaW5wdXQgcGVyIGRldGVybWluYXJlIGwnZXN0ZW5zaW9uZSBkaSBlbGFib3JhemlvbmUuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VvbWV0cmljLU1lZGlhbl9tYXhpbXVtbnVtYmVyb2ZpdGVyYXRpb25zX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmljYSBpbCBudW1lcm8gbWFzc2ltbyBkaSBpdGVyYXppb25pIGRhIGNvbXBsZXRhcmUuIElsIGNhbGNvbG8gdGVybWluYSBxdWFuZG8gdmllbmUgcmFnZ2l1bnRvIHF1ZXN0byB2YWxvcmUsIGEgcHJlc2NpbmRlcmUgZGFsbCdpbXBvc3RhemlvbmUgZGkgPHN0cm9uZz5FcHNpbG9uPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEdlb21ldHJpYy1NZWRpYW5fcmFzdGVyc190YWcwQEBcIjogXCI8cD5JIHJhc3RlciBtdWx0aWJhbmRhIGRpIGlucHV0LjwvcD5cIixcblx0XCJAQExlYXN0LUNvc3QtQ29ycmlkb3JfaW5wdXRhY2N1bXVsYXRpdmVjb3N0ZGlzdGFuY2VyYXN0ZXIxX3RhZzBAQFwiOiBcIjxwPklsIHJhc3RlciBkaSBpbnB1dCBjaGUgcmFwcHJlc2VudGEgbGEgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBkYWxsYSBwcmltYSBvcmlnaW5lLjwvcD48cD5EZXZlIGVzc2VyZSB1bmEgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBwcm9kb3R0YSBkYWxsYSBmdW56aW9uZSA8c3Ryb25nPkFjY3VtdWxvIGRpc3RhbnphIDwvc3Ryb25nPm8gPHN0cm9uZz5BbGxvY2F6aW9uZSBkaXN0YW56YTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBMZWFzdC1Db3N0LUNvcnJpZG9yX2lucHV0YWNjdW11bGF0aXZlY29zdGRpc3RhbmNlcmFzdGVyMl90YWcwQEBcIjogXCI8cD5JbCByYXN0ZXIgZGkgaW5wdXQgY2hlIHJhcHByZXNlbnRhIGxhIGRpc3RhbnphIGRpIGNvc3RvIGN1bXVsYXRpdm8gZGFsbGEgc2Vjb25kYSBvcmlnaW5lLjwvcD48cD5EZXZlIGVzc2VyZSB1bmEgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBwcm9kb3R0YSBkYWxsYSBmdW56aW9uZSA8c3Ryb25nPkFjY3VtdWxvIGRpc3RhbnphIDwvc3Ryb25nPm8gPHN0cm9uZz5BbGxvY2F6aW9uZSBkaXN0YW56YTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBMZWFzdC1Db3N0LUNvcnJpZG9yX2lucHV0YmFja2RpcmVjdGlvbnJhc3RlcjFfdGFnMEBAXCI6IFwiPHA+SWwgcmFzdGVyIGRlbGxhIGRpcmV6aW9uZSBpbnZlcnNhIGRpIGlucHV0IGRhbGxhIHByaW1hIG9yaWdpbmUuPC9wPjxwPlNpIHRyYXR0YSBkaSB1biBkYXRhc2V0IHJhc3RlciBjaGUgaWRlbnRpZmljYSBsYSBkaXJlemlvbmUgZGVsbGEgY2VsbGEgc3VjY2Vzc2l2YSBsdW5nbyBpbCBwZXJjb3JzbyBtaW5pbW8gY29zdG8gcGVyIHRvcm5hcmUgYWxsYSBwcmltYSBvcmlnaW5lLiBRdWVzdG8gw6ggbCdvdXRwdXQgZGVsbGEgZnVuemlvbmUgPHN0cm9uZz5BY2N1bXVsbyBkaXN0YW56YSA8L3N0cm9uZz5vPHN0cm9uZz4gQWxsb2NhemlvbmUgZGlzdGFuemE8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBATGVhc3QtQ29zdC1Db3JyaWRvcl9pbnB1dGJhY2tkaXJlY3Rpb25yYXN0ZXIyX3RhZzBAQFwiOiBcIjxwPklsIHJhc3RlciBkZWxsYSBkaXJlemlvbmUgaW52ZXJzYSBkaSBpbnB1dCBkYWxsYSBzZWNvbmRhIG9yaWdpbmUuPC9wPjxwPlNpIHRyYXR0YSBkaSB1biBkYXRhc2V0IHJhc3RlciBjaGUgaWRlbnRpZmljYSBsYSBkaXJlemlvbmUgZGVsbGEgY2VsbGEgc3VjY2Vzc2l2YSBsdW5nbyBpbCBwZXJjb3JzbyBtaW5pbW8gY29zdG8gcGVyIHRvcm5hcmUgYWxsYSBwcmltYSBvcmlnaW5lLiBRdWVzdG8gw6ggbCdvdXRwdXQgZGVsbGEgZnVuemlvbmUgPHN0cm9uZz5BY2N1bXVsbyBkaXN0YW56YSA8L3N0cm9uZz5vPHN0cm9uZz4gQWxsb2NhemlvbmUgZGlzdGFuemE8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBATGVhc3QtQ29zdC1Db3JyaWRvcl90aHJlc2hvbGRfdGFnMEBAXCI6IFwiPHA+VW5hIHNvZ2xpYSBkaSBjb3N0byBjdW11bGF0aXZvIG8gcGVyY2VudHVhbGUgb3IgY2hlIGRldGVybWluZXLDoCBzZSB1bmEgY2VsbGEgc3BlY2lmaWNhdGEgc2Fyw6AgaW5jbHVzYSBuZWwgcmFzdGVyIGNvcnJpZG9pbyBkaSBvdXRwdXQuPC9wPjxwPlF1YW5kbyBpbCBwYXJhbWV0cm8gPHN0cm9uZz5NZXRvZG8gc29nbGlhPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSA8c3Ryb25nPlBlcmNlbnR1YWxlIGRpIG1pbmltbyBjb3N0bzwvc3Ryb25nPiwgaWwgdmFsb3JlIHNwZWNpZmljYXRvIGluZGljYSBsJ2F1bWVudG8gcGVyY2VudHVhbGUgZGEgYXBwbGljYXJlIGRhbCB2YWxvcmUgbWluaW1vIGRlaSByYXN0ZXIgZGkgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBzb21tYXRpLiBRdWFuZG8gaWwgcGFyYW1ldHJvIDxzdHJvbmc+TWV0b2RvIHNvZ2xpYTwvc3Ryb25nPiDDqCBpbXBvc3RhdG8gc3UgPHN0cm9uZz5Db3N0byBjdW11bGF0aXZvPC9zdHJvbmc+LCBpbCB2YWxvcmUgaW5kaWNhIGxlIGNlbGxlIGNoZSBoYW5ubyB1biBjb3N0byBjdW11bGF0aXZvIHNvbW1hdG8gdWd1YWxlIG8gaW5mZXJpb3JlIGFsIHZhbG9yZSBjaGUgc2Fyw6AgaW5jbHVzbyBuZWwgY29ycmlkb2lvLjwvcD48cD5RdWVzdG8gcGFyYW1ldHJvIMOoIGF0dGl2byBzb2xvIHNlIGlsIHBhcmFtZXRybyA8c3Ryb25nPk1ldG9kbyBzb2dsaWEgPC9zdHJvbmc+w6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+UGVyY2VudHVhbGUgZGkgbWluaW1vIGNvc3RvIDwvc3Ryb25nPm88c3Ryb25nPiBDb3N0byBjdW11bGF0aXZvPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQExlYXN0LUNvc3QtQ29ycmlkb3JfdGhyZXNob2xkbWV0aG9kX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmljYSBjb21lIHNhcsOgIGRlZmluaXRhIGxhIHNvZ2xpYS48L3A+PHA+PC9wPjx1bD48bGk+PHN0cm9uZz5OZXNzdW5hIHNvZ2xpYTwvc3Ryb25nPjogbmVzc3VuYSBzb2dsaWEgc2Fyw6AgYXBwbGljYXRhIGUgaWwgY29ycmlkb2lvIHJpc3VsdGF0ZSBjb3ByaXLDoCBsJ2ludGVyYSBlc3RlbnNpb25lIGRlaSByYXN0ZXIgZGkgaW5wdXQuIFF1ZXN0YSDDqCBsJ2ltcG9zdGF6aW9uZSBwcmVkZWZpbml0YS48L2xpPjxsaT48c3Ryb25nPlBlcmNlbnR1YWxlIGRpIG1pbmltbyBjb3N0bzwvc3Ryb25nPjogbGEgc29nbGlhIHNhcsOgIGRlZmluaXRhIGNvbWUgcGVyY2VudHVhbGUgZGVsIHZhbG9yZSBtaW5pbW8gZGVpIHJhc3RlciBkaXN0YW56YSBkaSBjb3N0byBjdW11bGF0aXZvLjwvbGk+PGxpPjxzdHJvbmc+Q29zdG8gY3VtdWxhdGl2bzwvc3Ryb25nPjogbGEgc29nbGlhIHNhcsOgIGRlZmluaXRhIG5lbGxlIHVuaXTDoCBkaSBkaXN0YW56YSBkaSBjb3N0byBjdW11bGF0aXZvLjwvbGk+PC91bD5cIlxufTtcbmNvbnN0IGhlbHBUZXh0c19pdCA9IHtcblx0cmZ4QXJnc0hlbHBUZXh0czogcmZ4QXJnc0hlbHBUZXh0c1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaGVscFRleHRzX2l0O1xuZXhwb3J0IHsgcmZ4QXJnc0hlbHBUZXh0cyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwLXRleHRzLml0LTVjOWYyNGY5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==