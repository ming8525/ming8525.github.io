"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-0bcff5"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-multidimensional-variable-info.entry.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-multidimensional-variable-info.entry.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_raster_multidimensional_variable_info: () => (/* binding */ ArcgisRasterMultidimensionalVariableInfo)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./multidimensional-69f3968f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-69f3968f.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */








const arcgisRasterMultidimensionalVariableInfoCss = ":host{display:flex;flex:1 1 auto}:host .accordion-item-content,:host .accordion-item-header{--calcite-accordion-item-border:transparent}.info-section-container{border:none;--calcite-color-border-2:transparent}.info-section{padding-bottom:0.5rem;overflow-y:auto;--calcite-accordion-item-border:transparent;background-color:white}.info-general{padding:10px 15px;background-color:white}.info-content{margin:10px 10px}.info-content .info-block{color:var(--calcite-color-text-3, gray);max-height:4rem;min-height:1rem;overflow:hidden}.info-content .info-block .info-text{width:100%;word-break:normal;text-overflow:ellipsis;font-size:var(--calcite-font-size--2)}.popover{z-index:100}.table{width:100%;background-color:#ffffff;border-collapse:collapse;border-spacing:0;border:1px solid var(--calcite-color-border-1);text-align:left;overflow:auto;font-size:var(--calcite-font-size--2);color:var(--calcite-color-text-1);line-height:1.5rem}.table caption{text-align:left;margin-top:5px}.table td{display:table-cell;vertical-align:inherit}.table td:first-child{width:30%}.table th,.table td{font-weight:300;padding:2px 5px;text-align:left}.table tr:nth-child(odd){background-color:#f8f8f8}.table.table-bordered tr{border-bottom:1px solid var(--calcite-color-border-1)}.table.table-bordered tr:last-child{border-bottom:none}.table.table-bordered tr td:first-child{border-right:1px solid var(--calcite-color-border-1)}.table.table-borderless{border:none}.arcgis--rtl .table.table-bordered tr td:first-child{border-left:1px solid var(--calcite-color-border-1);border-right:none}";

const ArcgisRasterMultidimensionalVariableInfo = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisRasterMultidimensionalVariableInfoDismiss = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisRasterMultidimensionalVariableInfoDismiss", 7);
        this.variableInfo = undefined;
        this.popoverProps = undefined;
        this.showStatistics = false;
        this.showDimensionSummary = false;
        this.useTable = true;
        this.keepActiveDimension = true;
        this.strings = undefined;
        this.activeDimensionName = null;
        this.isOpen = false;
    }
    watchVariableInfo(_newValue, oldValue) {
        if (this.keepActiveDimension && this.dimensionEL && oldValue) {
            // calcite-accordion doesn't expose active/expanded item or public item select/close event
            const activeItem = this.dimensionEL.querySelector("calcite-accordion-item[active]");
            if (activeItem) {
                const index = activeItem.getAttribute("dimension-index");
                const dimension = oldValue.dimensions[index];
                this.activeDimensionName = dimension.name;
            }
            else {
                this.activeDimensionName = null;
            }
        }
        else {
            this.activeDimensionName = null;
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        [this.intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__.l)(["esri/intl"]);
        this.messages = await this.intl.fetchMessageBundle("esri/core/t9n/Units");
    }
    componentDidLoad() {
        this.isOpen = true;
    }
    // --------------------------------------------------------------------------
    //
    // Public Methods
    //
    // --------------------------------------------------------------------------
    async setFocus(focusId) {
        var _a, _b;
        if (focusId === "dismiss-button") {
            (_a = this.panelElement) === null || _a === void 0 ? void 0 : _a.setFocus();
            return;
        }
        (_b = this.hostElement) === null || _b === void 0 ? void 0 : _b.focus();
    }
    async reposition() {
        var _a;
        (_a = this.popoverNode) === null || _a === void 0 ? void 0 : _a.reposition();
    }
    // --------------------------------------------------------------------------
    //
    //  Render methods
    //
    // --------------------------------------------------------------------------
    render() {
        const statsTable = this.showStatistics && this.renderStatistics();
        const dimensionsList = this.renderDimensions();
        const variableInfoBlock = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-accordion", { class: "info-section-container", selectionMode: "single", ref: (el) => (this.dimensionEL = el) }, statsTable, dimensionsList));
        const { popoverProps, variableInfo } = this;
        const width = `${popoverProps.refElement.getBoundingClientRect().width}px`;
        const label = variableInfo.unit
            ? `${variableInfo.name} (${variableInfo.unit})`
            : `${variableInfo.name}`;
        const summary = this.showDimensionSummary
            ? variableInfo.dimensions
                .map((dimInfo) => `${dimInfo.name}: ${dimInfo.values.length}`)
                .join(", ")
            : null;
        const generalInfoBlock = this.renderGeneralInfo();
        const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "js-app-flyout" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-popover", { dir: dir, placement: popoverProps.placement || "leading-start", open: this.isOpen, pointerDisabled: true, referenceElement: popoverProps.refElement, offsetDistance: popoverProps.offsetDistance || 0, offsetSkidding: popoverProps.offsetSkidding || 0, triggerDisabled: true, label: label, class: "popover", style: { width }, ref: (node) => (this.popoverNode = node) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { ref: (el) => (this.panelElement = el), heading: label, description: summary, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: dir === "rtl"
            }, closable: true, onCalcitePanelClose: () => this.arcgisRasterMultidimensionalVariableInfoDismiss.emit() }, generalInfoBlock, variableInfoBlock))));
    }
    renderGeneralInfo() {
        const strings = this.strings.multidimensionalInfo;
        const { unit, description } = this.variableInfo;
        const hasColormap = !!this.variableInfo.colormap;
        return this.renderInfoSection([
            { name: strings.description, description: description || strings.none },
            { name: strings.unit, description: unit || strings.none },
            { name: strings.colormap, description: hasColormap ? strings.present : strings.none }
        ], null, "info-general");
    }
    renderInfoSection(nameDescriptions, caption, css) {
        return this.useTable ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: css }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("table", { class: "table table-bordered" }, caption && (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("caption", null, caption), nameDescriptions.map(({ name, description }) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("tr", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("td", null, name), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("td", null, description))))))) : ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `info-content ${css !== null && css !== void 0 ? css : ""}` }, nameDescriptions.map(({ name, description }) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, name, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "info-block" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "info-text" }, description)))))));
    }
    renderStatistics() {
        const { name, statistics } = this.variableInfo;
        if (!(statistics === null || statistics === void 0 ? void 0 : statistics.length)) {
            return null;
        }
        const strings = this.strings.multidimensionalInfo;
        const mins = this._formatStats(statistics.map(({ min }) => min));
        const maxs = this._formatStats(statistics.map(({ max }) => max));
        const means = this._formatStats(statistics.map(({ avg }) => avg));
        const stddevs = this._formatStats(statistics.map(({ stddev }) => stddev));
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-accordion-item", { "icon-position": "start", heading: strings.statistics, key: `${name}-stats}`, class: "info-section" }, this.renderInfoSection([
            { name: strings.minimum, description: mins },
            { name: strings.maximum, description: maxs },
            { name: strings.mean, description: means },
            { name: strings.stddev, description: stddevs }
        ])));
    }
    renderDimensions() {
        const { multidimensionalInfo: strings } = this.strings;
        const { name, dimensions } = this.variableInfo;
        return dimensions.map((dimensionInfo, i) => {
            const { name: dimName, values, interval, intervalUnit, hasRegularIntervals, extent } = dimensionInfo;
            let dimensionLabel = dimName === "StdTime"
                ? strings.stdTimeDimension
                : dimName === "StdZ"
                    ? strings.stdZDimension
                    : strings.generalDimension.replace("${dimensionName}", dimName);
            dimensionLabel += ` (${values.length})`;
            const intervalUnitLabel = this._formatUnit(intervalUnit);
            const intervalLabel = interval
                ? `${interval} (${hasRegularIntervals ? strings.regular : strings.irregular})`
                : "";
            const from = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_2__.f)(extent[0], dimensionInfo, { intl: this.intl });
            const to = (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_2__.f)(extent[1], dimensionInfo, { intl: this.intl });
            const extentLabel = `${from} - ${to}`;
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-accordion-item", { "icon-position": "start", expanded: dimName === this.activeDimensionName, heading: dimensionLabel, "dimension-index": i, key: `${name}-${dimName}`, class: "info-section" }, this.renderInfoSection([
                { name: strings.interval, description: intervalLabel },
                { name: strings.intervalUnit, description: intervalUnitLabel },
                { name: strings.extent, description: extentLabel }
            ])));
        });
    }
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    _formatStats(values) {
        return values.map((value) => this.intl.formatNumber(value)).join("; ");
    }
    _formatUnit(unit) {
        var _a, _b, _c;
        if (unit) {
            const srcUnit = unit.replace("esri", "");
            unit = srcUnit.toLowerCase();
            unit = (_c = (_a = this.strings.time[unit]) !== null && _a !== void 0 ? _a : (_b = this.messages.units[unit]) === null || _b === void 0 ? void 0 : _b.plural) !== null && _c !== void 0 ? _c : srcUnit;
        }
        return unit !== null && unit !== void 0 ? unit : "";
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "variableInfo": ["watchVariableInfo"]
    }; }
};
ArcgisRasterMultidimensionalVariableInfo.style = arcgisRasterMultidimensionalVariableInfoCss;



//# sourceMappingURL=arcgis-raster-multidimensional-variable-info.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-69f3968f.js":
/*!**********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-69f3968f.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getMultidimensionalInfo),
/* harmony export */   b: () => (/* binding */ getDefaultDimensionSliceValue),
/* harmony export */   c: () => (/* binding */ getMultidimensionalDefinition),
/* harmony export */   f: () => (/* binding */ formatDimensionValue),
/* harmony export */   g: () => (/* binding */ getClippedDimensionInfo),
/* harmony export */   i: () => (/* binding */ isTimeDimension),
/* harmony export */   m: () => (/* binding */ minVersionRFTMultidimensionalInfo),
/* harmony export */   u: () => (/* binding */ updateDimensionalDefinition)
/* harmony export */ });
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const minVersionRFTMultidimensionalInfo = 10.9;
function formatTime(value, options) {
    const date = new Date(value);
    const { useFriendlyISOFormat, intl, format } = options;
    if (useFriendlyISOFormat && intl) {
        return intl.formatDate(date, Object.assign(Object.assign({}, intl.convertDateFormatToIntlOptions(format !== null && format !== void 0 ? format : "short-date-long-time")), { timeZone: "UTC" }));
    }
    let isoTimeString = new Date(value).toISOString();
    isoTimeString = isoTimeString.slice(0, isoTimeString.indexOf(".")) + "Z";
    return isoTimeString;
}
function formatMonth(value_base1, intl, format = "long") {
    // using an arbitrary date (the day the code was written) to avoid side effects of setMonth near the end of the month
    // setMonth will move the date to the next month when new month doesn't have current date (e.g. 9/31, 2/30)
    // date = new Date(2002, 9, 31); date.setMonth(8); console.log(date.toLocaleDateString())
    const date = new Date(2022, 9, 10);
    date.setMonth(value_base1 - 1);
    return intl.formatDate(date, { month: format });
}
function formatQuarter(value_base1, intl) {
    const startMonth = formatMonth((value_base1 - 1) * 3 + 1, intl, "short");
    const endMonth = formatMonth(value_base1 * 3, intl, "short");
    return `${startMonth} - ${endMonth}`;
}
function formatDimensionValue(value, dimensionInfo, options = {}) {
    var _a, _b, _c, _d;
    if (value == null) {
        return "";
    }
    const { intl, useRecurringTimeLabel } = options;
    if (useRecurringTimeLabel && intl && !Array.isArray(value)) {
        const intervalUnit = (_a = dimensionInfo.intervalUnit) === null || _a === void 0 ? void 0 : _a.toLowerCase().trim();
        // weekly and daily are not supported yet
        const canUseRecurringTimeLabel = isRecurringTimeDimension(dimensionInfo) && (intervalUnit === "months" || intervalUnit === "quarters");
        if (canUseRecurringTimeLabel) {
            return intervalUnit === "months" ? formatMonth(value, intl) : formatQuarter(value, intl);
        }
    }
    // this is prefered when labeling a slider alike control
    const lastElement = (_b = dimensionInfo.values) === null || _b === void 0 ? void 0 : _b[dimensionInfo.values.length - 1];
    if (options.useStartOrEndForRangedValue && Array.isArray(value) && value.length === 2 && Array.isArray(lastElement)) {
        const isLastElement = value.join("-") === lastElement.join("-");
        value = isLastElement ? value[1] : value[0];
    }
    const isTime = isTimeDimension(dimensionInfo);
    if (!isTime) {
        return Array.isArray(value)
            ? value.map((element) => { var _a; return (_a = intl === null || intl === void 0 ? void 0 : intl.formatNumber(element)) !== null && _a !== void 0 ? _a : String(element); }).join(" - ")
            : (_c = intl === null || intl === void 0 ? void 0 : intl.formatNumber(value)) !== null && _c !== void 0 ? _c : String(value);
    }
    if (options.useFriendlyISOFormat && !options.format) {
        let resolution = (_d = dimensionInfo.intervalUnit) === null || _d === void 0 ? void 0 : _d.toLowerCase().trim();
        let { interval, extent } = dimensionInfo;
        if (resolution === "months") {
            if (interval > 11) {
                resolution = "year";
            }
        }
        else if (resolution === "days") {
            if (interval > 364) {
                resolution = "year";
            }
            else if (interval > 27) {
                resolution = "months";
            }
        }
        else if (resolution === "hours") {
            resolution = "days";
        }
        if (!["years", "months", "days"].includes(resolution) && (extent === null || extent === void 0 ? void 0 : extent.length)) {
            const interval = (extent[1] - extent[0]) / dimensionInfo.values.length;
            const day = 86400000;
            if (interval >= 365 * day) {
                resolution = "years";
            }
            else if (interval >= 28 * day) {
                resolution = "months";
            }
        }
        const format = resolution === "years" ? "year" : resolution === "months" ? "short-month-year" : "short-date";
        options = Object.assign({ format }, options);
    }
    return Array.isArray(value)
        ? value.map((element) => formatTime(element, options)).join(" - ")
        : formatTime(value, options);
}
function getClippedDimensionInfo(dimensionInfo, multidimensionalSubset) {
    var _a;
    const constraint = (_a = multidimensionalSubset === null || multidimensionalSubset === void 0 ? void 0 : multidimensionalSubset.dimensions) === null || _a === void 0 ? void 0 : _a.find(({ name }) => name === dimensionInfo.name);
    if (!(constraint === null || constraint === void 0 ? void 0 : constraint.extent)) {
        return dimensionInfo;
    }
    const extent = [...constraint.extent];
    const values = dimensionInfo.values.filter((value) => {
        // must be contained, intersection is not sufficient
        if (Array.isArray(value)) {
            if (!(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_0__.i)(extent[1]) || extent[0] === extent[1]) {
                return value[0] === extent[0];
            }
            return value[0] >= extent[0] && value[0] <= extent[1] && value[1] >= extent[0] && value[1] <= extent[1];
        }
        return value >= extent[0] && value <= extent[1];
    });
    // this is a special case, when last slice of a ranged dimension series is used
    if (values.length === 0) {
        const lastValue = dimensionInfo.values[dimensionInfo.values.length - 1];
        if (Array.isArray(lastValue) && lastValue[1] === extent[0]) {
            values.push(lastValue);
        }
    }
    return Object.assign(Object.assign({}, dimensionInfo), { extent, values });
}
function getDefaultDimensionSliceValue(dimensionInfo) {
    var _a;
    const { values, extent, name } = dimensionInfo;
    let value = (_a = values === null || values === void 0 ? void 0 : values[0]) !== null && _a !== void 0 ? _a : extent[0];
    if (name.toLowerCase() === "stdz" &&
        !dimensionInfo.hasRanges &&
        Math.abs(extent[1]) <= Math.abs(extent[0])) {
        if (values === null || values === void 0 ? void 0 : values.length) {
            value = values[values.length - 1];
        }
        else {
            value = extent[1];
        }
    }
    return value;
}
function getMultidimensionalDefinition(layer) {
    var _a, _b;
    return layer.type === "imagery-tile"
        ? layer.multidimensionalDefinition
        : (_b = ((_a = layer.mosaicRule) !== null && _a !== void 0 ? _a : layer._defaultServiceMosaicRule)) === null || _b === void 0 ? void 0 : _b.multidimensionalDefinition;
}
async function getMultidimensionalInfo(layer, useRawSourceInfo) {
    var _a, _b;
    if (layer.type === "imagery-tile") {
        return layer.rasterInfo.multidimensionalInfo;
    }
    const { rasterFunction, version } = layer;
    if (useRawSourceInfo ||
        version <= minVersionRFTMultidimensionalInfo ||
        !rasterFunction ||
        ((_a = rasterFunction.functionName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "none") {
        return layer.serviceRasterInfo.multidimensionalInfo;
    }
    const rasterInfo = (_b = (await layer.generateRasterInfo(layer.rasterFunction))) !== null && _b !== void 0 ? _b : layer.serviceRasterInfo;
    return rasterInfo.multidimensionalInfo;
}
function isTimeDimension(dimensionInfo, ignoreRecuring = false) {
    return dimensionInfo.name === "StdTime" && (ignoreRecuring || !dimensionInfo.recurring);
}
function isRecurringTimeDimension(dimensionInfo) {
    return dimensionInfo.name === "StdTime" && !!dimensionInfo.recurring;
}
function updateDimensionalDefinition(def, dimensionInfo, activeMultidimensionalSubset) {
    dimensionInfo = getClippedDimensionInfo(dimensionInfo, activeMultidimensionalSubset);
    const originalFormattedValue = formatDimensionValue(def.values[0], dimensionInfo);
    const hasOriginalFormattedValue = dimensionInfo.values.some((val) => originalFormattedValue === formatDimensionValue(val, dimensionInfo));
    if (!hasOriginalFormattedValue) {
        // get default slice value when def.values is invalid
        const value = getDefaultDimensionSliceValue(dimensionInfo);
        def.values = [value];
    }
}



//# sourceMappingURL=multidimensional-69f3968f.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTBiY2ZmNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzZHO0FBQ2hEO0FBQ2M7QUFDTztBQUMzQztBQUNKO0FBQ1I7O0FBRTNCLDJEQUEyRCxhQUFhLGNBQWMsMkRBQTJELDRDQUE0Qyx3QkFBd0IsWUFBWSxxQ0FBcUMsY0FBYyxzQkFBc0IsZ0JBQWdCLDRDQUE0Qyx1QkFBdUIsY0FBYyxrQkFBa0IsdUJBQXVCLGNBQWMsaUJBQWlCLDBCQUEwQix3Q0FBd0MsZ0JBQWdCLGdCQUFnQixnQkFBZ0IscUNBQXFDLFdBQVcsa0JBQWtCLHVCQUF1QixzQ0FBc0MsU0FBUyxZQUFZLE9BQU8sV0FBVyx5QkFBeUIseUJBQXlCLGlCQUFpQiwrQ0FBK0MsZ0JBQWdCLGNBQWMsc0NBQXNDLGtDQUFrQyxtQkFBbUIsZUFBZSxnQkFBZ0IsZUFBZSxVQUFVLG1CQUFtQix1QkFBdUIsc0JBQXNCLFVBQVUsb0JBQW9CLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLHlCQUF5Qix5QkFBeUIseUJBQXlCLHNEQUFzRCxvQ0FBb0MsbUJBQW1CLHdDQUF3QyxxREFBcUQsd0JBQXdCLFlBQVkscURBQXFELG9EQUFvRCxrQkFBa0I7O0FBRWhsRDtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEIsK0RBQStELHFEQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyREFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7O0FBRXlROztBQUV6USIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1yYXN0ZXItbXVsdGlkaW1lbnNpb25hbC12YXJpYWJsZS1pbmZvLmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL211bHRpZGltZW5zaW9uYWwtNjlmMzk2OGYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIEggYXMgSG9zdCwgZCBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBmIGFzIGZvcm1hdERpbWVuc2lvblZhbHVlIH0gZnJvbSAnLi9tdWx0aWRpbWVuc2lvbmFsLTY5ZjM5NjhmLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0RWxlbWVudERpciwgQyBhcyBDU1NfVVRJTElUWSB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCAnLi9jb21tb25GdW5jdGlvbnMtYjA4MzBlOWUuanMnO1xuaW1wb3J0ICcuL2NvbW1vbkVudW1zLWZjZjEzNjYxLmpzJztcbmltcG9ydCAnLi9kb20tNGQzNjc2NzcuanMnO1xuXG5jb25zdCBhcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsVmFyaWFibGVJbmZvQ3NzID0gXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleDoxIDEgYXV0b306aG9zdCAuYWNjb3JkaW9uLWl0ZW0tY29udGVudCw6aG9zdCAuYWNjb3JkaW9uLWl0ZW0taGVhZGVyey0tY2FsY2l0ZS1hY2NvcmRpb24taXRlbS1ib3JkZXI6dHJhbnNwYXJlbnR9LmluZm8tc2VjdGlvbi1jb250YWluZXJ7Ym9yZGVyOm5vbmU7LS1jYWxjaXRlLWNvbG9yLWJvcmRlci0yOnRyYW5zcGFyZW50fS5pbmZvLXNlY3Rpb257cGFkZGluZy1ib3R0b206MC41cmVtO292ZXJmbG93LXk6YXV0bzstLWNhbGNpdGUtYWNjb3JkaW9uLWl0ZW0tYm9yZGVyOnRyYW5zcGFyZW50O2JhY2tncm91bmQtY29sb3I6d2hpdGV9LmluZm8tZ2VuZXJhbHtwYWRkaW5nOjEwcHggMTVweDtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlfS5pbmZvLWNvbnRlbnR7bWFyZ2luOjEwcHggMTBweH0uaW5mby1jb250ZW50IC5pbmZvLWJsb2Nre2NvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItdGV4dC0zLCBncmF5KTttYXgtaGVpZ2h0OjRyZW07bWluLWhlaWdodDoxcmVtO292ZXJmbG93OmhpZGRlbn0uaW5mby1jb250ZW50IC5pbmZvLWJsb2NrIC5pbmZvLXRleHR7d2lkdGg6MTAwJTt3b3JkLWJyZWFrOm5vcm1hbDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMil9LnBvcG92ZXJ7ei1pbmRleDoxMDB9LnRhYmxle3dpZHRoOjEwMCU7YmFja2dyb3VuZC1jb2xvcjojZmZmZmZmO2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTtib3JkZXItc3BhY2luZzowO2JvcmRlcjoxcHggc29saWQgdmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItMSk7dGV4dC1hbGlnbjpsZWZ0O292ZXJmbG93OmF1dG87Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0yKTtjb2xvcjp2YXIoLS1jYWxjaXRlLWNvbG9yLXRleHQtMSk7bGluZS1oZWlnaHQ6MS41cmVtfS50YWJsZSBjYXB0aW9ue3RleHQtYWxpZ246bGVmdDttYXJnaW4tdG9wOjVweH0udGFibGUgdGR7ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOmluaGVyaXR9LnRhYmxlIHRkOmZpcnN0LWNoaWxke3dpZHRoOjMwJX0udGFibGUgdGgsLnRhYmxlIHRke2ZvbnQtd2VpZ2h0OjMwMDtwYWRkaW5nOjJweCA1cHg7dGV4dC1hbGlnbjpsZWZ0fS50YWJsZSB0cjpudGgtY2hpbGQob2RkKXtiYWNrZ3JvdW5kLWNvbG9yOiNmOGY4Zjh9LnRhYmxlLnRhYmxlLWJvcmRlcmVkIHRye2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHZhcigtLWNhbGNpdGUtY29sb3ItYm9yZGVyLTEpfS50YWJsZS50YWJsZS1ib3JkZXJlZCB0cjpsYXN0LWNoaWxke2JvcmRlci1ib3R0b206bm9uZX0udGFibGUudGFibGUtYm9yZGVyZWQgdHIgdGQ6Zmlyc3QtY2hpbGR7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJvcmRlci0xKX0udGFibGUudGFibGUtYm9yZGVybGVzc3tib3JkZXI6bm9uZX0uYXJjZ2lzLS1ydGwgLnRhYmxlLnRhYmxlLWJvcmRlcmVkIHRyIHRkOmZpcnN0LWNoaWxke2JvcmRlci1sZWZ0OjFweCBzb2xpZCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJvcmRlci0xKTtib3JkZXItcmlnaHQ6bm9uZX1cIjtcblxuY29uc3QgQXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbFZhcmlhYmxlSW5mbyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbFZhcmlhYmxlSW5mb0Rpc21pc3MgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1Jhc3Rlck11bHRpZGltZW5zaW9uYWxWYXJpYWJsZUluZm9EaXNtaXNzXCIsIDcpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2hvd1N0YXRpc3RpY3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93RGltZW5zaW9uU3VtbWFyeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZVRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5rZWVwQWN0aXZlRGltZW5zaW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmFjdGl2ZURpbWVuc2lvbk5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB3YXRjaFZhcmlhYmxlSW5mbyhfbmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmtlZXBBY3RpdmVEaW1lbnNpb24gJiYgdGhpcy5kaW1lbnNpb25FTCAmJiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gY2FsY2l0ZS1hY2NvcmRpb24gZG9lc24ndCBleHBvc2UgYWN0aXZlL2V4cGFuZGVkIGl0ZW0gb3IgcHVibGljIGl0ZW0gc2VsZWN0L2Nsb3NlIGV2ZW50XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVJdGVtID0gdGhpcy5kaW1lbnNpb25FTC5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1hY2NvcmRpb24taXRlbVthY3RpdmVdXCIpO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFjdGl2ZUl0ZW0uZ2V0QXR0cmlidXRlKFwiZGltZW5zaW9uLWluZGV4XCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IG9sZFZhbHVlLmRpbWVuc2lvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlRGltZW5zaW9uTmFtZSA9IGRpbWVuc2lvbi5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVEaW1lbnNpb25OYW1lID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRGltZW5zaW9uTmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICBbdGhpcy5pbnRsXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvaW50bFwiXSk7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBhd2FpdCB0aGlzLmludGwuZmV0Y2hNZXNzYWdlQnVuZGxlKFwiZXNyaS9jb3JlL3Q5bi9Vbml0c1wiKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gUHVibGljIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgc2V0Rm9jdXMoZm9jdXNJZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoZm9jdXNJZCA9PT0gXCJkaXNtaXNzLWJ1dHRvblwiKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnBhbmVsRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy5ob3N0RWxlbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvY3VzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlcG9zaXRpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5wb3BvdmVyTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcG9zaXRpb24oKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBSZW5kZXIgbWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRzVGFibGUgPSB0aGlzLnNob3dTdGF0aXN0aWNzICYmIHRoaXMucmVuZGVyU3RhdGlzdGljcygpO1xuICAgICAgICBjb25zdCBkaW1lbnNpb25zTGlzdCA9IHRoaXMucmVuZGVyRGltZW5zaW9ucygpO1xuICAgICAgICBjb25zdCB2YXJpYWJsZUluZm9CbG9jayA9IChoKFwiY2FsY2l0ZS1hY2NvcmRpb25cIiwgeyBjbGFzczogXCJpbmZvLXNlY3Rpb24tY29udGFpbmVyXCIsIHNlbGVjdGlvbk1vZGU6IFwic2luZ2xlXCIsIHJlZjogKGVsKSA9PiAodGhpcy5kaW1lbnNpb25FTCA9IGVsKSB9LCBzdGF0c1RhYmxlLCBkaW1lbnNpb25zTGlzdCkpO1xuICAgICAgICBjb25zdCB7IHBvcG92ZXJQcm9wcywgdmFyaWFibGVJbmZvIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGAke3BvcG92ZXJQcm9wcy5yZWZFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRofXB4YDtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB2YXJpYWJsZUluZm8udW5pdFxuICAgICAgICAgICAgPyBgJHt2YXJpYWJsZUluZm8ubmFtZX0gKCR7dmFyaWFibGVJbmZvLnVuaXR9KWBcbiAgICAgICAgICAgIDogYCR7dmFyaWFibGVJbmZvLm5hbWV9YDtcbiAgICAgICAgY29uc3Qgc3VtbWFyeSA9IHRoaXMuc2hvd0RpbWVuc2lvblN1bW1hcnlcbiAgICAgICAgICAgID8gdmFyaWFibGVJbmZvLmRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICAubWFwKChkaW1JbmZvKSA9PiBgJHtkaW1JbmZvLm5hbWV9OiAke2RpbUluZm8udmFsdWVzLmxlbmd0aH1gKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiLCBcIilcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgY29uc3QgZ2VuZXJhbEluZm9CbG9jayA9IHRoaXMucmVuZGVyR2VuZXJhbEluZm8oKTtcbiAgICAgICAgY29uc3QgZGlyID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IFwianMtYXBwLWZseW91dFwiIH0sIGgoXCJjYWxjaXRlLXBvcG92ZXJcIiwgeyBkaXI6IGRpciwgcGxhY2VtZW50OiBwb3BvdmVyUHJvcHMucGxhY2VtZW50IHx8IFwibGVhZGluZy1zdGFydFwiLCBvcGVuOiB0aGlzLmlzT3BlbiwgcG9pbnRlckRpc2FibGVkOiB0cnVlLCByZWZlcmVuY2VFbGVtZW50OiBwb3BvdmVyUHJvcHMucmVmRWxlbWVudCwgb2Zmc2V0RGlzdGFuY2U6IHBvcG92ZXJQcm9wcy5vZmZzZXREaXN0YW5jZSB8fCAwLCBvZmZzZXRTa2lkZGluZzogcG9wb3ZlclByb3BzLm9mZnNldFNraWRkaW5nIHx8IDAsIHRyaWdnZXJEaXNhYmxlZDogdHJ1ZSwgbGFiZWw6IGxhYmVsLCBjbGFzczogXCJwb3BvdmVyXCIsIHN0eWxlOiB7IHdpZHRoIH0sIHJlZjogKG5vZGUpID0+ICh0aGlzLnBvcG92ZXJOb2RlID0gbm9kZSkgfSwgaChcImNhbGNpdGUtcGFuZWxcIiwgeyByZWY6IChlbCkgPT4gKHRoaXMucGFuZWxFbGVtZW50ID0gZWwpLCBoZWFkaW5nOiBsYWJlbCwgZGVzY3JpcHRpb246IHN1bW1hcnksIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgcGFuZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IGRpciA9PT0gXCJydGxcIlxuICAgICAgICAgICAgfSwgY2xvc2FibGU6IHRydWUsIG9uQ2FsY2l0ZVBhbmVsQ2xvc2U6ICgpID0+IHRoaXMuYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbFZhcmlhYmxlSW5mb0Rpc21pc3MuZW1pdCgpIH0sIGdlbmVyYWxJbmZvQmxvY2ssIHZhcmlhYmxlSW5mb0Jsb2NrKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyR2VuZXJhbEluZm8oKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSB0aGlzLnN0cmluZ3MubXVsdGlkaW1lbnNpb25hbEluZm87XG4gICAgICAgIGNvbnN0IHsgdW5pdCwgZGVzY3JpcHRpb24gfSA9IHRoaXMudmFyaWFibGVJbmZvO1xuICAgICAgICBjb25zdCBoYXNDb2xvcm1hcCA9ICEhdGhpcy52YXJpYWJsZUluZm8uY29sb3JtYXA7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckluZm9TZWN0aW9uKFtcbiAgICAgICAgICAgIHsgbmFtZTogc3RyaW5ncy5kZXNjcmlwdGlvbiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIHx8IHN0cmluZ3Mubm9uZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBzdHJpbmdzLnVuaXQsIGRlc2NyaXB0aW9uOiB1bml0IHx8IHN0cmluZ3Mubm9uZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBzdHJpbmdzLmNvbG9ybWFwLCBkZXNjcmlwdGlvbjogaGFzQ29sb3JtYXAgPyBzdHJpbmdzLnByZXNlbnQgOiBzdHJpbmdzLm5vbmUgfVxuICAgICAgICBdLCBudWxsLCBcImluZm8tZ2VuZXJhbFwiKTtcbiAgICB9XG4gICAgcmVuZGVySW5mb1NlY3Rpb24obmFtZURlc2NyaXB0aW9ucywgY2FwdGlvbiwgY3NzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZVRhYmxlID8gKGgoXCJkaXZcIiwgeyBjbGFzczogY3NzIH0sIGgoXCJ0YWJsZVwiLCB7IGNsYXNzOiBcInRhYmxlIHRhYmxlLWJvcmRlcmVkXCIgfSwgY2FwdGlvbiAmJiBoKFwiY2FwdGlvblwiLCBudWxsLCBjYXB0aW9uKSwgbmFtZURlc2NyaXB0aW9ucy5tYXAoKHsgbmFtZSwgZGVzY3JpcHRpb24gfSkgPT4gKGgoXCJ0clwiLCBudWxsLCBoKFwidGRcIiwgbnVsbCwgbmFtZSksIGgoXCJ0ZFwiLCBudWxsLCBkZXNjcmlwdGlvbikpKSkpKSkgOiAoaChcImRpdlwiLCB7IGNsYXNzOiBgaW5mby1jb250ZW50ICR7Y3NzICE9PSBudWxsICYmIGNzcyAhPT0gdm9pZCAwID8gY3NzIDogXCJcIn1gIH0sIG5hbWVEZXNjcmlwdGlvbnMubWFwKCh7IG5hbWUsIGRlc2NyaXB0aW9uIH0pID0+IChoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiB9LCBuYW1lLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaW5mby1ibG9ja1wiIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbmZvLXRleHRcIiB9LCBkZXNjcmlwdGlvbikpKSkpKSk7XG4gICAgfVxuICAgIHJlbmRlclN0YXRpc3RpY3MoKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgc3RhdGlzdGljcyB9ID0gdGhpcy52YXJpYWJsZUluZm87XG4gICAgICAgIGlmICghKHN0YXRpc3RpY3MgPT09IG51bGwgfHwgc3RhdGlzdGljcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGlzdGljcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpbmdzID0gdGhpcy5zdHJpbmdzLm11bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgICAgICBjb25zdCBtaW5zID0gdGhpcy5fZm9ybWF0U3RhdHMoc3RhdGlzdGljcy5tYXAoKHsgbWluIH0pID0+IG1pbikpO1xuICAgICAgICBjb25zdCBtYXhzID0gdGhpcy5fZm9ybWF0U3RhdHMoc3RhdGlzdGljcy5tYXAoKHsgbWF4IH0pID0+IG1heCkpO1xuICAgICAgICBjb25zdCBtZWFucyA9IHRoaXMuX2Zvcm1hdFN0YXRzKHN0YXRpc3RpY3MubWFwKCh7IGF2ZyB9KSA9PiBhdmcpKTtcbiAgICAgICAgY29uc3Qgc3RkZGV2cyA9IHRoaXMuX2Zvcm1hdFN0YXRzKHN0YXRpc3RpY3MubWFwKCh7IHN0ZGRldiB9KSA9PiBzdGRkZXYpKTtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1hY2NvcmRpb24taXRlbVwiLCB7IFwiaWNvbi1wb3NpdGlvblwiOiBcInN0YXJ0XCIsIGhlYWRpbmc6IHN0cmluZ3Muc3RhdGlzdGljcywga2V5OiBgJHtuYW1lfS1zdGF0c31gLCBjbGFzczogXCJpbmZvLXNlY3Rpb25cIiB9LCB0aGlzLnJlbmRlckluZm9TZWN0aW9uKFtcbiAgICAgICAgICAgIHsgbmFtZTogc3RyaW5ncy5taW5pbXVtLCBkZXNjcmlwdGlvbjogbWlucyB9LFxuICAgICAgICAgICAgeyBuYW1lOiBzdHJpbmdzLm1heGltdW0sIGRlc2NyaXB0aW9uOiBtYXhzIH0sXG4gICAgICAgICAgICB7IG5hbWU6IHN0cmluZ3MubWVhbiwgZGVzY3JpcHRpb246IG1lYW5zIH0sXG4gICAgICAgICAgICB7IG5hbWU6IHN0cmluZ3Muc3RkZGV2LCBkZXNjcmlwdGlvbjogc3RkZGV2cyB9XG4gICAgICAgIF0pKSk7XG4gICAgfVxuICAgIHJlbmRlckRpbWVuc2lvbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlkaW1lbnNpb25hbEluZm86IHN0cmluZ3MgfSA9IHRoaXMuc3RyaW5ncztcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkaW1lbnNpb25zIH0gPSB0aGlzLnZhcmlhYmxlSW5mbztcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbnMubWFwKChkaW1lbnNpb25JbmZvLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWU6IGRpbU5hbWUsIHZhbHVlcywgaW50ZXJ2YWwsIGludGVydmFsVW5pdCwgaGFzUmVndWxhckludGVydmFscywgZXh0ZW50IH0gPSBkaW1lbnNpb25JbmZvO1xuICAgICAgICAgICAgbGV0IGRpbWVuc2lvbkxhYmVsID0gZGltTmFtZSA9PT0gXCJTdGRUaW1lXCJcbiAgICAgICAgICAgICAgICA/IHN0cmluZ3Muc3RkVGltZURpbWVuc2lvblxuICAgICAgICAgICAgICAgIDogZGltTmFtZSA9PT0gXCJTdGRaXCJcbiAgICAgICAgICAgICAgICAgICAgPyBzdHJpbmdzLnN0ZFpEaW1lbnNpb25cbiAgICAgICAgICAgICAgICAgICAgOiBzdHJpbmdzLmdlbmVyYWxEaW1lbnNpb24ucmVwbGFjZShcIiR7ZGltZW5zaW9uTmFtZX1cIiwgZGltTmFtZSk7XG4gICAgICAgICAgICBkaW1lbnNpb25MYWJlbCArPSBgICgke3ZhbHVlcy5sZW5ndGh9KWA7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbFVuaXRMYWJlbCA9IHRoaXMuX2Zvcm1hdFVuaXQoaW50ZXJ2YWxVbml0KTtcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsTGFiZWwgPSBpbnRlcnZhbFxuICAgICAgICAgICAgICAgID8gYCR7aW50ZXJ2YWx9ICgke2hhc1JlZ3VsYXJJbnRlcnZhbHMgPyBzdHJpbmdzLnJlZ3VsYXIgOiBzdHJpbmdzLmlycmVndWxhcn0pYFxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBmb3JtYXREaW1lbnNpb25WYWx1ZShleHRlbnRbMF0sIGRpbWVuc2lvbkluZm8sIHsgaW50bDogdGhpcy5pbnRsIH0pO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBmb3JtYXREaW1lbnNpb25WYWx1ZShleHRlbnRbMV0sIGRpbWVuc2lvbkluZm8sIHsgaW50bDogdGhpcy5pbnRsIH0pO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50TGFiZWwgPSBgJHtmcm9tfSAtICR7dG99YDtcbiAgICAgICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYWNjb3JkaW9uLWl0ZW1cIiwgeyBcImljb24tcG9zaXRpb25cIjogXCJzdGFydFwiLCBleHBhbmRlZDogZGltTmFtZSA9PT0gdGhpcy5hY3RpdmVEaW1lbnNpb25OYW1lLCBoZWFkaW5nOiBkaW1lbnNpb25MYWJlbCwgXCJkaW1lbnNpb24taW5kZXhcIjogaSwga2V5OiBgJHtuYW1lfS0ke2RpbU5hbWV9YCwgY2xhc3M6IFwiaW5mby1zZWN0aW9uXCIgfSwgdGhpcy5yZW5kZXJJbmZvU2VjdGlvbihbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiBzdHJpbmdzLmludGVydmFsLCBkZXNjcmlwdGlvbjogaW50ZXJ2YWxMYWJlbCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogc3RyaW5ncy5pbnRlcnZhbFVuaXQsIGRlc2NyaXB0aW9uOiBpbnRlcnZhbFVuaXRMYWJlbCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogc3RyaW5ncy5leHRlbnQsIGRlc2NyaXB0aW9uOiBleHRlbnRMYWJlbCB9XG4gICAgICAgICAgICBdKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQcml2YXRlIG1ldGhvZHNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgX2Zvcm1hdFN0YXRzKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCgodmFsdWUpID0+IHRoaXMuaW50bC5mb3JtYXROdW1iZXIodmFsdWUpKS5qb2luKFwiOyBcIik7XG4gICAgfVxuICAgIF9mb3JtYXRVbml0KHVuaXQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICh1bml0KSB7XG4gICAgICAgICAgICBjb25zdCBzcmNVbml0ID0gdW5pdC5yZXBsYWNlKFwiZXNyaVwiLCBcIlwiKTtcbiAgICAgICAgICAgIHVuaXQgPSBzcmNVbml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB1bml0ID0gKF9jID0gKF9hID0gdGhpcy5zdHJpbmdzLnRpbWVbdW5pdF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHRoaXMubWVzc2FnZXMudW5pdHNbdW5pdF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wbHVyYWwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHNyY1VuaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaXQgIT09IG51bGwgJiYgdW5pdCAhPT0gdm9pZCAwID8gdW5pdCA6IFwiXCI7XG4gICAgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbiAgICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgICAgICBcInZhcmlhYmxlSW5mb1wiOiBbXCJ3YXRjaFZhcmlhYmxlSW5mb1wiXVxuICAgIH07IH1cbn07XG5BcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsVmFyaWFibGVJbmZvLnN0eWxlID0gYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbFZhcmlhYmxlSW5mb0NzcztcblxuZXhwb3J0IHsgQXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbFZhcmlhYmxlSW5mbyBhcyBhcmNnaXNfcmFzdGVyX211bHRpZGltZW5zaW9uYWxfdmFyaWFibGVfaW5mbyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtcmFzdGVyLW11bHRpZGltZW5zaW9uYWwtdmFyaWFibGUtaW5mby5lbnRyeS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGkgYXMgaXNEZWZpbmVkIH0gZnJvbSAnLi9jb21tb25GdW5jdGlvbnMtYjA4MzBlOWUuanMnO1xuXG5jb25zdCBtaW5WZXJzaW9uUkZUTXVsdGlkaW1lbnNpb25hbEluZm8gPSAxMC45O1xuZnVuY3Rpb24gZm9ybWF0VGltZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgY29uc3QgeyB1c2VGcmllbmRseUlTT0Zvcm1hdCwgaW50bCwgZm9ybWF0IH0gPSBvcHRpb25zO1xuICAgIGlmICh1c2VGcmllbmRseUlTT0Zvcm1hdCAmJiBpbnRsKSB7XG4gICAgICAgIHJldHVybiBpbnRsLmZvcm1hdERhdGUoZGF0ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRsLmNvbnZlcnREYXRlRm9ybWF0VG9JbnRsT3B0aW9ucyhmb3JtYXQgIT09IG51bGwgJiYgZm9ybWF0ICE9PSB2b2lkIDAgPyBmb3JtYXQgOiBcInNob3J0LWRhdGUtbG9uZy10aW1lXCIpKSwgeyB0aW1lWm9uZTogXCJVVENcIiB9KSk7XG4gICAgfVxuICAgIGxldCBpc29UaW1lU3RyaW5nID0gbmV3IERhdGUodmFsdWUpLnRvSVNPU3RyaW5nKCk7XG4gICAgaXNvVGltZVN0cmluZyA9IGlzb1RpbWVTdHJpbmcuc2xpY2UoMCwgaXNvVGltZVN0cmluZy5pbmRleE9mKFwiLlwiKSkgKyBcIlpcIjtcbiAgICByZXR1cm4gaXNvVGltZVN0cmluZztcbn1cbmZ1bmN0aW9uIGZvcm1hdE1vbnRoKHZhbHVlX2Jhc2UxLCBpbnRsLCBmb3JtYXQgPSBcImxvbmdcIikge1xuICAgIC8vIHVzaW5nIGFuIGFyYml0cmFyeSBkYXRlICh0aGUgZGF5IHRoZSBjb2RlIHdhcyB3cml0dGVuKSB0byBhdm9pZCBzaWRlIGVmZmVjdHMgb2Ygc2V0TW9udGggbmVhciB0aGUgZW5kIG9mIHRoZSBtb250aFxuICAgIC8vIHNldE1vbnRoIHdpbGwgbW92ZSB0aGUgZGF0ZSB0byB0aGUgbmV4dCBtb250aCB3aGVuIG5ldyBtb250aCBkb2Vzbid0IGhhdmUgY3VycmVudCBkYXRlIChlLmcuIDkvMzEsIDIvMzApXG4gICAgLy8gZGF0ZSA9IG5ldyBEYXRlKDIwMDIsIDksIDMxKTsgZGF0ZS5zZXRNb250aCg4KTsgY29uc29sZS5sb2coZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoKSlcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoMjAyMiwgOSwgMTApO1xuICAgIGRhdGUuc2V0TW9udGgodmFsdWVfYmFzZTEgLSAxKTtcbiAgICByZXR1cm4gaW50bC5mb3JtYXREYXRlKGRhdGUsIHsgbW9udGg6IGZvcm1hdCB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFF1YXJ0ZXIodmFsdWVfYmFzZTEsIGludGwpIHtcbiAgICBjb25zdCBzdGFydE1vbnRoID0gZm9ybWF0TW9udGgoKHZhbHVlX2Jhc2UxIC0gMSkgKiAzICsgMSwgaW50bCwgXCJzaG9ydFwiKTtcbiAgICBjb25zdCBlbmRNb250aCA9IGZvcm1hdE1vbnRoKHZhbHVlX2Jhc2UxICogMywgaW50bCwgXCJzaG9ydFwiKTtcbiAgICByZXR1cm4gYCR7c3RhcnRNb250aH0gLSAke2VuZE1vbnRofWA7XG59XG5mdW5jdGlvbiBmb3JtYXREaW1lbnNpb25WYWx1ZSh2YWx1ZSwgZGltZW5zaW9uSW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCB7IGludGwsIHVzZVJlY3VycmluZ1RpbWVMYWJlbCB9ID0gb3B0aW9ucztcbiAgICBpZiAodXNlUmVjdXJyaW5nVGltZUxhYmVsICYmIGludGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGludGVydmFsVW5pdCA9IChfYSA9IGRpbWVuc2lvbkluZm8uaW50ZXJ2YWxVbml0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIC8vIHdlZWtseSBhbmQgZGFpbHkgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0XG4gICAgICAgIGNvbnN0IGNhblVzZVJlY3VycmluZ1RpbWVMYWJlbCA9IGlzUmVjdXJyaW5nVGltZURpbWVuc2lvbihkaW1lbnNpb25JbmZvKSAmJiAoaW50ZXJ2YWxVbml0ID09PSBcIm1vbnRoc1wiIHx8IGludGVydmFsVW5pdCA9PT0gXCJxdWFydGVyc1wiKTtcbiAgICAgICAgaWYgKGNhblVzZVJlY3VycmluZ1RpbWVMYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVydmFsVW5pdCA9PT0gXCJtb250aHNcIiA/IGZvcm1hdE1vbnRoKHZhbHVlLCBpbnRsKSA6IGZvcm1hdFF1YXJ0ZXIodmFsdWUsIGludGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRoaXMgaXMgcHJlZmVyZWQgd2hlbiBsYWJlbGluZyBhIHNsaWRlciBhbGlrZSBjb250cm9sXG4gICAgY29uc3QgbGFzdEVsZW1lbnQgPSAoX2IgPSBkaW1lbnNpb25JbmZvLnZhbHVlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2RpbWVuc2lvbkluZm8udmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChvcHRpb25zLnVzZVN0YXJ0T3JFbmRGb3JSYW5nZWRWYWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgQXJyYXkuaXNBcnJheShsYXN0RWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgaXNMYXN0RWxlbWVudCA9IHZhbHVlLmpvaW4oXCItXCIpID09PSBsYXN0RWxlbWVudC5qb2luKFwiLVwiKTtcbiAgICAgICAgdmFsdWUgPSBpc0xhc3RFbGVtZW50ID8gdmFsdWVbMV0gOiB2YWx1ZVswXTtcbiAgICB9XG4gICAgY29uc3QgaXNUaW1lID0gaXNUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8pO1xuICAgIGlmICghaXNUaW1lKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgPyB2YWx1ZS5tYXAoKGVsZW1lbnQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gaW50bCA9PT0gbnVsbCB8fCBpbnRsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRsLmZvcm1hdE51bWJlcihlbGVtZW50KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogU3RyaW5nKGVsZW1lbnQpOyB9KS5qb2luKFwiIC0gXCIpXG4gICAgICAgICAgICA6IChfYyA9IGludGwgPT09IG51bGwgfHwgaW50bCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50bC5mb3JtYXROdW1iZXIodmFsdWUpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51c2VGcmllbmRseUlTT0Zvcm1hdCAmJiAhb3B0aW9ucy5mb3JtYXQpIHtcbiAgICAgICAgbGV0IHJlc29sdXRpb24gPSAoX2QgPSBkaW1lbnNpb25JbmZvLmludGVydmFsVW5pdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBsZXQgeyBpbnRlcnZhbCwgZXh0ZW50IH0gPSBkaW1lbnNpb25JbmZvO1xuICAgICAgICBpZiAocmVzb2x1dGlvbiA9PT0gXCJtb250aHNcIikge1xuICAgICAgICAgICAgaWYgKGludGVydmFsID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uID0gXCJ5ZWFyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzb2x1dGlvbiA9PT0gXCJkYXlzXCIpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCA+IDM2NCkge1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gPSBcInllYXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGludGVydmFsID4gMjcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uID0gXCJtb250aHNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvbHV0aW9uID09PSBcImhvdXJzXCIpIHtcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSBcImRheXNcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiXS5pbmNsdWRlcyhyZXNvbHV0aW9uKSAmJiAoZXh0ZW50ID09PSBudWxsIHx8IGV4dGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0ZW50Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gKGV4dGVudFsxXSAtIGV4dGVudFswXSkgLyBkaW1lbnNpb25JbmZvLnZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBkYXkgPSA4NjQwMDAwMDtcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCA+PSAzNjUgKiBkYXkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uID0gXCJ5ZWFyc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJ2YWwgPj0gMjggKiBkYXkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uID0gXCJtb250aHNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXQgPSByZXNvbHV0aW9uID09PSBcInllYXJzXCIgPyBcInllYXJcIiA6IHJlc29sdXRpb24gPT09IFwibW9udGhzXCIgPyBcInNob3J0LW1vbnRoLXllYXJcIiA6IFwic2hvcnQtZGF0ZVwiO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGZvcm1hdCB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICAgID8gdmFsdWUubWFwKChlbGVtZW50KSA9PiBmb3JtYXRUaW1lKGVsZW1lbnQsIG9wdGlvbnMpKS5qb2luKFwiIC0gXCIpXG4gICAgICAgIDogZm9ybWF0VGltZSh2YWx1ZSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBnZXRDbGlwcGVkRGltZW5zaW9uSW5mbyhkaW1lbnNpb25JbmZvLCBtdWx0aWRpbWVuc2lvbmFsU3Vic2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNvbnN0cmFpbnQgPSAoX2EgPSBtdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID09PSBudWxsIHx8IG11bHRpZGltZW5zaW9uYWxTdWJzZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG11bHRpZGltZW5zaW9uYWxTdWJzZXQuZGltZW5zaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBkaW1lbnNpb25JbmZvLm5hbWUpO1xuICAgIGlmICghKGNvbnN0cmFpbnQgPT09IG51bGwgfHwgY29uc3RyYWludCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uc3RyYWludC5leHRlbnQpKSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb25JbmZvO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnQgPSBbLi4uY29uc3RyYWludC5leHRlbnRdO1xuICAgIGNvbnN0IHZhbHVlcyA9IGRpbWVuc2lvbkluZm8udmFsdWVzLmZpbHRlcigodmFsdWUpID0+IHtcbiAgICAgICAgLy8gbXVzdCBiZSBjb250YWluZWQsIGludGVyc2VjdGlvbiBpcyBub3Qgc3VmZmljaWVudFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGV4dGVudFsxXSkgfHwgZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbMF0gPT09IGV4dGVudFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVswXSA+PSBleHRlbnRbMF0gJiYgdmFsdWVbMF0gPD0gZXh0ZW50WzFdICYmIHZhbHVlWzFdID49IGV4dGVudFswXSAmJiB2YWx1ZVsxXSA8PSBleHRlbnRbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID49IGV4dGVudFswXSAmJiB2YWx1ZSA8PSBleHRlbnRbMV07XG4gICAgfSk7XG4gICAgLy8gdGhpcyBpcyBhIHNwZWNpYWwgY2FzZSwgd2hlbiBsYXN0IHNsaWNlIG9mIGEgcmFuZ2VkIGRpbWVuc2lvbiBzZXJpZXMgaXMgdXNlZFxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGRpbWVuc2lvbkluZm8udmFsdWVzW2RpbWVuc2lvbkluZm8udmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsYXN0VmFsdWUpICYmIGxhc3RWYWx1ZVsxXSA9PT0gZXh0ZW50WzBdKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChsYXN0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRpbWVuc2lvbkluZm8pLCB7IGV4dGVudCwgdmFsdWVzIH0pO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpbWVuc2lvblNsaWNlVmFsdWUoZGltZW5zaW9uSW5mbykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHZhbHVlcywgZXh0ZW50LCBuYW1lIH0gPSBkaW1lbnNpb25JbmZvO1xuICAgIGxldCB2YWx1ZSA9IChfYSA9IHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlc1swXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXh0ZW50WzBdO1xuICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3RkelwiICYmXG4gICAgICAgICFkaW1lbnNpb25JbmZvLmhhc1JhbmdlcyAmJlxuICAgICAgICBNYXRoLmFicyhleHRlbnRbMV0pIDw9IE1hdGguYWJzKGV4dGVudFswXSkpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gZXh0ZW50WzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldE11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKGxheWVyKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5LXRpbGVcIlxuICAgICAgICA/IGxheWVyLm11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uXG4gICAgICAgIDogKF9iID0gKChfYSA9IGxheWVyLm1vc2FpY1J1bGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGxheWVyLl9kZWZhdWx0U2VydmljZU1vc2FpY1J1bGUpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubXVsdGlkaW1lbnNpb25hbERlZmluaXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBnZXRNdWx0aWRpbWVuc2lvbmFsSW5mbyhsYXllciwgdXNlUmF3U291cmNlSW5mbykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeS10aWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyLnJhc3RlckluZm8ubXVsdGlkaW1lbnNpb25hbEluZm87XG4gICAgfVxuICAgIGNvbnN0IHsgcmFzdGVyRnVuY3Rpb24sIHZlcnNpb24gfSA9IGxheWVyO1xuICAgIGlmICh1c2VSYXdTb3VyY2VJbmZvIHx8XG4gICAgICAgIHZlcnNpb24gPD0gbWluVmVyc2lvblJGVE11bHRpZGltZW5zaW9uYWxJbmZvIHx8XG4gICAgICAgICFyYXN0ZXJGdW5jdGlvbiB8fFxuICAgICAgICAoKF9hID0gcmFzdGVyRnVuY3Rpb24uZnVuY3Rpb25OYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHJldHVybiBsYXllci5zZXJ2aWNlUmFzdGVySW5mby5tdWx0aWRpbWVuc2lvbmFsSW5mbztcbiAgICB9XG4gICAgY29uc3QgcmFzdGVySW5mbyA9IChfYiA9IChhd2FpdCBsYXllci5nZW5lcmF0ZVJhc3RlckluZm8obGF5ZXIucmFzdGVyRnVuY3Rpb24pKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbGF5ZXIuc2VydmljZVJhc3RlckluZm87XG4gICAgcmV0dXJuIHJhc3RlckluZm8ubXVsdGlkaW1lbnNpb25hbEluZm87XG59XG5mdW5jdGlvbiBpc1RpbWVEaW1lbnNpb24oZGltZW5zaW9uSW5mbywgaWdub3JlUmVjdXJpbmcgPSBmYWxzZSkge1xuICAgIHJldHVybiBkaW1lbnNpb25JbmZvLm5hbWUgPT09IFwiU3RkVGltZVwiICYmIChpZ25vcmVSZWN1cmluZyB8fCAhZGltZW5zaW9uSW5mby5yZWN1cnJpbmcpO1xufVxuZnVuY3Rpb24gaXNSZWN1cnJpbmdUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8pIHtcbiAgICByZXR1cm4gZGltZW5zaW9uSW5mby5uYW1lID09PSBcIlN0ZFRpbWVcIiAmJiAhIWRpbWVuc2lvbkluZm8ucmVjdXJyaW5nO1xufVxuZnVuY3Rpb24gdXBkYXRlRGltZW5zaW9uYWxEZWZpbml0aW9uKGRlZiwgZGltZW5zaW9uSW5mbywgYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCkge1xuICAgIGRpbWVuc2lvbkluZm8gPSBnZXRDbGlwcGVkRGltZW5zaW9uSW5mbyhkaW1lbnNpb25JbmZvLCBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KTtcbiAgICBjb25zdCBvcmlnaW5hbEZvcm1hdHRlZFZhbHVlID0gZm9ybWF0RGltZW5zaW9uVmFsdWUoZGVmLnZhbHVlc1swXSwgZGltZW5zaW9uSW5mbyk7XG4gICAgY29uc3QgaGFzT3JpZ2luYWxGb3JtYXR0ZWRWYWx1ZSA9IGRpbWVuc2lvbkluZm8udmFsdWVzLnNvbWUoKHZhbCkgPT4gb3JpZ2luYWxGb3JtYXR0ZWRWYWx1ZSA9PT0gZm9ybWF0RGltZW5zaW9uVmFsdWUodmFsLCBkaW1lbnNpb25JbmZvKSk7XG4gICAgaWYgKCFoYXNPcmlnaW5hbEZvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgIC8vIGdldCBkZWZhdWx0IHNsaWNlIHZhbHVlIHdoZW4gZGVmLnZhbHVlcyBpcyBpbnZhbGlkXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0RGVmYXVsdERpbWVuc2lvblNsaWNlVmFsdWUoZGltZW5zaW9uSW5mbyk7XG4gICAgICAgIGRlZi52YWx1ZXMgPSBbdmFsdWVdO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZ2V0TXVsdGlkaW1lbnNpb25hbEluZm8gYXMgYSwgZ2V0RGVmYXVsdERpbWVuc2lvblNsaWNlVmFsdWUgYXMgYiwgZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gYXMgYywgZm9ybWF0RGltZW5zaW9uVmFsdWUgYXMgZiwgZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8gYXMgZywgaXNUaW1lRGltZW5zaW9uIGFzIGksIG1pblZlcnNpb25SRlRNdWx0aWRpbWVuc2lvbmFsSW5mbyBhcyBtLCB1cGRhdGVEaW1lbnNpb25hbERlZmluaXRpb24gYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aWRpbWVuc2lvbmFsLTY5ZjM5NjhmLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==