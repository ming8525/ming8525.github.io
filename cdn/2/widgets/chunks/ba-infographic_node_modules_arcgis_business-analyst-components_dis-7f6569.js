"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_ba-infographic_node_modules_arcgis_business-analyst-components_dis-7f6569"],{

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/GEClient-1a83a657.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/GEClient-1a83a657.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ Environments),
/* harmony export */   G: () => (/* binding */ GEClient),
/* harmony export */   S: () => (/* binding */ SettingsHelper),
/* harmony export */   T: () => (/* binding */ TokenProvider)
/* harmony export */ });
/* harmony import */ var _ElementIds_f7d257e8_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ElementIds-f7d257e8.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/ElementIds-f7d257e8.js");


class TokenProvider {
  /**
   * todo: implement real method
   *
   * @return {Promise<unknown>}
   */
  static getToken() {
    return new Promise((resolve) => {
      resolve(TokenProvider.token.access_token);
    });
  }
  static setToken(username, token) {
    if (username && username.length > 0 && token && token.length > 0) {
      this.token.access_token = token;
      this.token.username = username;
    }
  }
}
TokenProvider.token = {
  access_token: '',
  expires_in: null,
  persist: 'true',
  ssl: 'true',
  username: 'mark_ba'
};

/** Environments
 *
 *  This class provides support for environments and subdomains
 *  PortalUrl - can be overriden for enterprise environments
 *  GeocoderUrl - can be overriden
 *  GeoenrichmentUrl - can be overriden
 */
class Environments {
  static setEnvironment(env) {
    let e = (env === 'prod' || env === 'localhost') ? 'www' : env;
    Environments._env = e;
  }
  static getEnvironment() {
    return Environments._env;
  }
  static setPortalUrl(portalUrl) {
    Environments.portalUrl = portalUrl;
  }
  static setGeoenrichmentUrl(geUrl) {
    Environments.geoenrichmentUrl = geUrl;
  }
  static setGeocodeUrl(geocodeUrl) {
    Environments.geocodeUrl = geocodeUrl;
  }
  static getPortalBase() {
    // Optional, if PortalUrl has been explicitly set/overriden use it
    if (Environments.portalUrl) {
      return Environments.portalUrl;
    }
    const e = Environments._env;
    if (!e)
      return '';
    const subdomain = e === 'dev' ? 'devext' : e === 'qa' ? 'qaext' : 'www';
    let url = 'https://' + subdomain + '.arcgis.com';
    return url;
  }
  /**
   * Returns appropriate request URL for the subdomain
   *
   * @param subDomain - one of 'geocode', 'arcgis', or 'geoenrich'
   */
  static getUrl(subDomain) {
    if (!Environments._env) {
      console.log('Environments error: env not set');
      return '';
    }
    if (!subDomain || !_ElementIds_f7d257e8_js__WEBPACK_IMPORTED_MODULE_0__.U.hasText(subDomain)) {
      console.log('Environments error: invalid subdomain');
      return '';
    }
    const portal = Environments.getPortalBase();
    if (portal === '')
      return '';
    try {
      let url = '';
      switch (subDomain) {
        case ('geocode'): {
          // Optional, if GeocodeUrl has been explicitly set/overriden use it
          if (Environments.geocodeUrl) {
            url = Environments.geocodeUrl;
            break;
          }
          else {
            url =
              (Environments._env === 'qa') ? 'https://geocodeqa.arcgis.com/arcgis/rest/services/World/GeocodeServer' :
                (Environments._env === 'dev') ? 'https://geocodedev.arcgis.com/arcgis/rest/services/World/GeocodeServer' :
                  'https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer';
            break;
          }
        }
        case ('arcgis'): {
          url = portal;
          break;
        }
        case ('infographics'): {
          url =
            (Environments._env === 'qa') ? 'https://baoqa.arcgis.com/InfographicsPlayer/BAMobile/23.R03/reportPlayer/ReportPlayerMobile.html' :
              (Environments._env === 'dev') ? 'https://baodev.arcgis.com/InfographicsPlayer/BAMobile/23.R03/reportPlayer/ReportPlayerMobile.html' :
                'https://bao.arcgis.com/InfographicsPlayer/BAMobile/23.R03/reportPlayer/ReportPlayerMobile.html';
          break;
        }
        case ('geoenrich'): {
          // Optional, if GeoenrichmentUrl has been explicitly set/overriden use it
          if (Environments.geoenrichmentUrl) {
            url = Environments.geoenrichmentUrl;
            break;
          }
          else {
            url =
              (Environments._env === 'qa') ? 'https://geoenrichqa.arcgis.com/arcgis/rest/services/World/geoenrichmentserver' :
                (Environments._env === 'dev') ? 'https://geoenrichdev.arcgis.com/arcgis/rest/services/World/geoenrichmentserver' :
                  'https://geoenrich.arcgis.com/arcgis/rest/services/World/geoenrichmentserver';
          }
          break;
        }
      }
      return url;
    }
    catch (ex) {
      _ElementIds_f7d257e8_js__WEBPACK_IMPORTED_MODULE_0__.a.Error('Environments.getUrl() error ', ex);
    }
    return '';
  }
  // Returns true if the geocodeUrl string passed in is the online Geocoder Service (dev, qa, prod), false otherwise
  static isOnlineGeocoder(geocodeUrl) {
    if (geocodeUrl.toLowerCase().startsWith('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer'.toLowerCase()) ||
      geocodeUrl.toLowerCase().startsWith('https://geocodeqa.arcgis.com/arcgis/rest/services/World/GeocodeServer'.toLowerCase()) ||
      geocodeUrl.toLowerCase().startsWith('https://geocodedev.arcgis.com/arcgis/rest/services/World/GeocodeServer'.toLowerCase())) {
      return true;
    }
    return false;
  }
  // Returns true if the portalUrl string passed in is the online Portal (dev, qa, prod), false otherwise
  static isAGOPortal(portalUrl) {
    if (portalUrl.toLowerCase().startsWith('https://www.arcgis.com'.toLowerCase()) ||
      portalUrl.toLowerCase().startsWith('https://qaext.arcgis.com'.toLowerCase()) ||
      portalUrl.toLowerCase().startsWith('https://devext.arcgis.com'.toLowerCase())) {
      return true;
    }
    return false;
  }
}
Environments._env = 'www';
// Optional, ability to override portalUrl
Environments.portalUrl = '';
// Optional, ability to override geoenrichment URL
Environments.geoenrichmentUrl = '';
// Optional, ability to override geocode URL
Environments.geocodeUrl = '';

class ArcGISClient {
  static executeSelf() {
    return new Promise((resolve, reject) => {
      TokenProvider.getToken().then((accessToken) => {
        if (accessToken === ArcGISClient._lastSelfToken) {
          resolve(ArcGISClient._selfResult);
        }
        else {
          let settings = {
            taskPath: '/portals/self',
            data: {
              culture: 'en-us' // todo: get actual locale
            }
          };
          ArcGISClient.executeRequest(settings).then(response => {
            //caching response from "/self" with token as key
            ArcGISClient._lastSelfToken = accessToken;
            ArcGISClient._selfResult = response;
            resolve(response);
          })
            .catch(err => {
            ArcGISClient._lastSelfToken = '';
            ArcGISClient._selfResult = '';
            reject(err);
          });
        }
      })
        .catch(err => reject(err));
    });
  }
  static getGeoenrichmentUrl() {
    return Environments.getUrl('geoenrich');
  }
  static getHelperServiceUrl(serviceName) {
    return new Promise((resolve, reject) => {
      ArcGISClient.executeSelf().then(function (selfResult) {
        let helperServices = selfResult.helperServices;
        if (helperServices) {
          let helperService = helperServices[serviceName];
          if (helperService) {
            let urlString = Array.isArray(helperService) ? helperService[0].url : helperService.url;
            urlString ? resolve(urlString) : reject(serviceName + ' helper service is not configured.');
          }
          else
            reject(serviceName + ' helper service is not configured.');
        }
        else
          reject('Helper services are not configured.');
      }).catch(err => reject(err));
    });
  }
  static getPortalResource(resourceName) {
    return ArcGISClient.executeRequest({
      taskPath: '/portals/self/resources/' + resourceName
    });
  }
  static getItemData(itemId) {
    return ArcGISClient.executeRequest({
      taskPath: '/content/items/' + itemId + '/data'
    });
  }
  /**
   * Searches for items by provided search query and params and extracts all search results
   * bypassing ArcGIS server limit of 100 items
   *
   * @param query
   * @param params
   * @returns {Promise<unknown>}
   */
  static searchAllItems(query, params) {
    return new Promise((resolve, reject) => {
      let searchResults = [];
      let self = this;
      let _doSearch = function (query, params, context) {
        self.searchItems(query, params, context).then(function (result) {
          if (result.items.length)
            searchResults = searchResults.concat(result.items);
          let newContext = result.context;
          if (newContext.nextStart > 0)
            _doSearch(query, params, newContext);
          else
            resolve(searchResults);
        }, function (err) {
          if (searchResults && searchResults.length)
            resolve(searchResults);
          else
            reject(err);
        });
      };
      _doSearch(query, params, null);
    });
  }
  static searchItems(query, params, context) {
    return new Promise((resolve, reject) => {
      // do deep copy, instead of $j.extend({}, params)
      let searchParams = params ? JSON.parse(JSON.stringify(params)) : {};
      if (context) {
        searchParams.q = params.q;
        let total = context.total;
        let nextStart = context.nextStart;
        if (total && nextStart) {
          if (nextStart > 0 && total >= nextStart)
            searchParams.start = nextStart;
          else
            resolve({ items: [], context: context });
        }
        if (context.sortField && context.sortOrder) {
          searchParams.sortOrder = context.sortOrder;
          searchParams.sortField = context.sortField;
        }
        // $j.ajaxSetup({
        //     global: false
        // });
      }
      else {
        let queryParts = [];
        Object.getOwnPropertyNames(query).forEach(function (key) {
          queryParts.push(key + ':"' + query[key] + '"');
        });
        if (queryParts.length)
          searchParams.q = queryParts.join(' AND ');
      }
      ArcGISClient.portalSearch(searchParams).then((searchResponse) => {
        // $j.ajaxSetup({
        //     global: true
        // });
        let resultItems = searchResponse.results;
        let ctx = {
          query: searchResponse.query,
          total: searchResponse.total,
          nextStart: searchResponse.nextStart,
          sortOrder: null,
          sortField: null
        };
        if (searchParams.sortOrder && searchParams.sortField) {
          ctx.sortOrder = searchParams.sortOrder;
          ctx.sortField = searchParams.sortField;
        }
        resolve({ items: resultItems, context: ctx });
      }).catch(reject);
    });
  }
  /// methods from BA.arcGISRequests
  static portalSearch(params) {
    return ArcGISClient.executeRequest({
      taskPath: '/search',
      data: params
    });
  }
  static async getPortalUrl() {
    return Environments.getUrl('arcgis') + '/sharing/rest';
  }
  static executeRequest(settings) {
    //settings:
    // {
    //     "data": {
    //     "num": 1000,
    //         "q": "type:\"Report Template\" typekeywords:esriWebStandardInfographicReport owner:esri_reports",
    //         "sortField": "title",
    //         "sortOrder": "asc",
    //         "start": 1
    //     },
    //     "taskPath": "/search"
    // }
    return new Promise((resolve, reject) => {
      TokenProvider.getToken().then(async (access_token) => {
        if (!settings.data)
          settings.data = {};
        // todo: use default params with ability to override them
        if (!settings.data.f)
          settings.data.f = 'json';
        settings.data.token = access_token ? access_token : settings.data.token;
        if (!settings.data.token) {
          delete settings.data.token;
        }
        settings.data.langCode = settings.data?.langCode ? settings.data.langCode : 'en-us'; // todo: update
        //todo: timeout: 30000 ms - need to implement via timer and AbortController
        const formData = new FormData();
        for (let key in settings.data)
          formData.append(key, settings.data[key]);
        let url;
        if (Object.prototype.hasOwnProperty.call(settings, 'url')) {
          url = settings.url;
        }
        else {
          url = await ArcGISClient.getPortalUrl();
        }
        //let url = settings.url || ArcGISClient.getPortalUrl();
        if (settings.taskPath)
          url = url + settings.taskPath;
        let params = {};
        // Standard Geography query is handled differently
        // Need to add charset=UTF-8 to Content-Type request header
        if (settings.isStandardGeoQuery) {
          const requestHeaders = new Headers();
          requestHeaders.append('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
          let bodyData = '';
          let booleanFirst = true;
          for (const key in settings.data) {
            bodyData += booleanFirst ? '' : '&';
            bodyData += key + '=' + encodeURI(settings.data[key]);
            booleanFirst = false;
          }
          params = {
            method: 'POST',
            body: bodyData,
            headers: requestHeaders
          };
        }
        else {
          params = {
            method: 'POST',
            body: formData
          };
        }
        fetch(url, params).then(response => {
          if (!response.ok)
            throw new Error('Network response ended with error.');
          // todo: check if response is string?
          return settings.data.f === 'bin' ? response.blob() : response.json();
        }).then(result => {
          // ArcGIS returns error with HTTP 2xx code, so handle it here
          result.error ? reject(result.error) : resolve(result);
        }).catch(error => {
          console.error('Error:', error);
          reject(error);
        });
      }).catch(err => reject(err));
    });
  }
}

class WebAppSettings {
  static getBusinessAnalystOrganizationalSettings() {
    return ArcGISClient.getPortalResource('BusinessAnalyst_Organizational_Settings.json');
  }
  static getDisabledReports() {
    return new Promise((resolve) => {
      let emptyResolveOnErr = (err) => {
        resolve({});
        console.log('WebAppSettings error', err);
      };
      ArcGISClient.executeSelf().then((selfResponse) => {
        let roleId = selfResponse.user.roleId || selfResponse.user.role;
        WebAppSettings.getBusinessAnalystOrganizationalSettings().then((settings) => {
          let disabledReports = settings['userRoles.disabledAreas.reports'];
          if (disabledReports && disabledReports[roleId])
            resolve(disabledReports[roleId]);
          else
            resolve({});
        }).catch(emptyResolveOnErr);
      }).catch(emptyResolveOnErr);
    });
  }
  /**
   * Gets ids of infographic templates that user added to "My Templates" from "Gallery"
   * (uses new version of user settings)
   *
   * @returns {*}
   */
  static getUserGalleryInfographicReportIds() {
    return new Promise((resolve, reject) => {
      WebAppSettings._searchGalleryInfographicPreferencesItem().then((galleryPrefItem) => {
        if (!galleryPrefItem) {
          reject(null);
          return;
        }
        // assuming "properties": {"inData": "true"},
        let itemId = galleryPrefItem.id;
        ArcGISClient.getItemData(itemId).then((itemData) => {
          resolve(itemData &&
            itemData.data &&
            itemData.data.myGalleryInfographicReportIds);
        }).catch(err => reject(err));
      }).catch(err => reject(err));
    });
  }
  static _searchGalleryInfographicPreferencesItem() {
    return WebAppSettings._searchUserItem('esriFavoriteReportTemplates');
  }
  static _searchUserItem(typekeywords) {
    return new Promise((resolve, reject) => {
      ArcGISClient.executeSelf().then((selfResponse) => {
        let username = selfResponse.user.username;
        let query = {
          type: 'Web Mapping Application',
          typekeywords: typekeywords,
          owner: username
        };
        let params = { num: 1 };
        ArcGISClient.searchItems(query, params, undefined).then((items) => {
          resolve(items && items.length && items[0]);
        }).catch(err => reject(err));
      }).catch(err => reject(err));
    });
  }
}

class SettingsHelper {
  static getEnvironment() {
    return new Promise((resolve) => {
      resolve(Environments.getEnvironment());
    });
  }
  static setEnvironment(environment) {
    if (environment && environment.length > 0) {
      Environments.setEnvironment(environment);
    }
    else {
      console.log('ba-reports error: setEnvironment() invalid arg');
    }
  }
  static async getPortalBaseUrl() {
    return Environments.getUrl('arcgis');
  }
  static isTrueString(value) {
    return String(value).toLowerCase() === 'true';
  }
}

class ReportTemplatesManager {
  static _condenseResultsArray(data) {
    // simplify
    const arr = data.map((obj) => {
      return { id: obj.id, title: obj.title, date: obj.modified };
    });
    // remove duplicates by title
    const names = arr.map((a) => a.title);
    const result = arr.filter((obj, index) => {
      return names.indexOf(obj.title) == index;
    });
    return result;
  }
  static _condenseResultsArrayGEInfographics(data) {
    // simplify
    let date, t1, t2;
    const arr = data.map((obj) => {
      try {
        if (obj.metadata.lastRevisionDate) {
          t2 = obj.metadata.lastRevisionDate;
        }
        if (obj.metadata.creationDate) {
          t1 = obj.metadata.creationDate;
        }
        if (t1) {
          if (!t2) {
            date = t1;
          }
          else {
            date = (t2 > t1) ? t2 : t1;
          }
        }
      }
      catch (ex) {
        console.log('ReportTemplatesManager error', ex);
      }
      return { id: obj.itemID, title: obj.metadata.title, date: date };
    });
    // remove duplicates by title
    const names = arr.map((a) => a.title);
    const result = arr.filter((obj, index) => {
      return names.indexOf(obj.title) == index;
    });
    return result;
  }
  /**
   * Gets report templates for country identified by country code. Final report
   * templates set consists of templates from GeoEnrichment and from AGOL
   *
   * @param countryCode Only 2-letter countryCode! todo: consume 3-letter also
   * @param full        Flag True=return all data, False=return Id + Title only
   * @return {Promise<unknown>}
   */
  static getReportTemplates(countryCode, full = false) {
    return new Promise((resolve, reject) => {
      let reportTemplates = {
        ge: undefined,
        shared: undefined,
        user: undefined,
        favoriteIds: undefined
      };
      ArcGISClient.executeSelf()
        .then((selfResponse) => {
        let username = selfResponse.user.username;
        Promise.allSettled([
          // ReportTemplatesManager._getGEReportTemplates(countryCode),
          ReportTemplatesManager._getSharedCustomReportTemplateItems(username),
          ReportTemplatesManager._getMyCustomReportTemplateItems(username),
          ReportTemplatesManager._getFavoriteReportsIds(username, countryCode)
        ]).then((res) => {
          reportTemplates.ge = res[0].value ? res[0].value : [];
          reportTemplates.shared = ReportTemplatesManager._createReportTemplateInfos(res[1] && res[1].value ? res[1].value : [], countryCode);
          reportTemplates.user = ReportTemplatesManager._createReportTemplateInfos(res[2] && res[2].value ? res[2].value : [], countryCode);
          reportTemplates.favoriteIds =
            res[3] && res[3].value ? res[3].value : [];
          WebAppSettings.getDisabledReports()
            .then((disabledReports) => {
            let ge = reportTemplates.ge;
            let shared = reportTemplates.shared;
            if (ge != null) {
              reportTemplates.ge = ge.filter((template) => {
                return !disabledReports[template.reportID];
              });
              if (shared != null) {
                reportTemplates.shared = shared.filter((template) => {
                  return !disabledReports[template.reportID.itemid];
                });
              }
            }
            if (!full) {
              reportTemplates.ge = ReportTemplatesManager._condenseResultsArray(reportTemplates.ge);
              reportTemplates.shared = ReportTemplatesManager._condenseResultsArray(reportTemplates.shared);
              reportTemplates.user = ReportTemplatesManager._condenseResultsArray(reportTemplates.user);
              reportTemplates.favoriteIds = ReportTemplatesManager._condenseResultsArray(reportTemplates.favoriteIds);
              resolve(reportTemplates);
            }
            else {
              resolve(reportTemplates);
            }
          })
            .catch((err) => reject(err));
        });
      })
        .catch((err) => reject(err));
    });
  }
  static _getGEReportTemplates(countryCode) {
    return new Promise((resolve, reject) => {
      // todo: store templates in country instance: country.reportTemplates;
      let reportTemplates = ReportTemplatesManager._geReportTemplatesCache[countryCode];
      if (reportTemplates) {
        resolve(reportTemplates);
        return;
      }
      GEClient.execute({ taskPath: '/GeoEnrichment/Reports/' + countryCode })
        .then((reportTemplatesResponse) => {
        let reportTemplates = reportTemplatesResponse.reports;
        ReportTemplatesManager._geReportTemplatesCache[countryCode] = reportTemplates;
        resolve(reportTemplates);
      })
        .catch(reject);
    });
  }
  static _getSharedCustomReportTemplateItems(username) {
    let query = 'type:"Report Template" (access:shared OR access:org) typekeywords:(esriWebReport NOT esriWebInfographicReport) NOT owner:' +
      username;
    return ReportTemplatesManager._searchItems(query, ReportTemplatesManager._removeInfographicTemplates);
  }
  static _getMyCustomReportTemplateItems(username) {
    let query = 'type:"Report Template" typekeywords:(esriWebReport NOT esriWebInfographicReport) owner:' +
      username;
    return ReportTemplatesManager._searchItems(query, ReportTemplatesManager._removeInfographicTemplates);
  }
  static _removeInfographicTemplates(reportTemplateItem) {
    return !SettingsHelper.isTrueString(reportTemplateItem.properties.isGraphicReport);
  }
  /**
   *
   * @param countryCode Only 2-letter countryCode! todo: consume 3-letter also
   * @return {Promise<unknown>}
   */
  static getInfographicReportTemplateItems(countryCode, full = false, token) {
    return new Promise(async (resolve, reject) => {
      let infographicItems = {
        public: undefined,
        shared: undefined,
        user: undefined,
        favoriteIds: undefined,
        gallery: undefined
      };
      const defaultHierarchy = await GEClient.getGEDefaultHierarchy(countryCode, token);
      ArcGISClient.executeSelf()
        .then((selfResponse) => {
        let username = selfResponse.user.username;
        let orgId = selfResponse.user.orgId;
        // let countryCode = country.id;
        Promise.allSettled([
          ReportTemplatesManager._getEsriInfographicReportTemplateItems(countryCode),
          ReportTemplatesManager._getSharedInfographicReportTemplateItems(username, orgId),
          ReportTemplatesManager._getUserInfographicReportTemplateItems(username),
          ReportTemplatesManager._getFavoriteReportsIds(username, countryCode),
          ReportTemplatesManager._getGalleryInfographicReportTemplateItems()
          //
        ]).then((res) => {
          let byCountryAndDefaultHiearchy = ReportTemplatesManager._byCountryAndDefaultHiearchy(countryCode, defaultHierarchy);
          infographicItems.public = res[0].value
            ? res[0].value.filter(byCountryAndDefaultHiearchy)
            : [];
          infographicItems.shared = res[1].value
            ? res[1].value.filter(byCountryAndDefaultHiearchy)
            : [];
          infographicItems.user = res[2].value
            ? res[2].value.filter(byCountryAndDefaultHiearchy)
            : [];
          // infographicItems.public = infographicItems.public
          //   ? res[0].value.filter (byDefaultHierarchy)
          //   : []
          // infographicItems.shared = res[1].value
          //   ? res[1].value.filter (byDefaultHierarchy)
          //   : []
          // infographicItems.user = res[2].value
          //   ? res[2].value.filter (byDefaultHierarchy)
          //   : []
          infographicItems.favoriteIds = res[3].value ? res[3].value : [];
          infographicItems.gallery = res[4].value
            ? res[4].value.filter(byCountryAndDefaultHiearchy)
            : [];
          let user = infographicItems.user;
          if (user != null) {
            // sort alphabetically by title
            user.sort(function (item1, item2) {
              return item1.title.localeCompare(item2.title);
            });
          }
          WebAppSettings.getDisabledReports()
            .then((disabledReports) => {
            let filterDisabled = function (igItem) {
              return !disabledReports[igItem.id];
            };
            let pub = infographicItems.public;
            if (pub != null) {
              infographicItems.public = pub.filter(filterDisabled);
            }
            let shared = infographicItems.shared;
            if (shared != null) {
              infographicItems.shared = shared.filter(filterDisabled);
            }
            let gallery = infographicItems.gallery;
            if (gallery != null) {
              infographicItems.gallery = gallery.filter(filterDisabled);
            }
            if (!full) {
              infographicItems.public = ReportTemplatesManager._condenseResultsArrayGEInfographics(infographicItems.public);
              infographicItems.shared = ReportTemplatesManager._condenseResultsArray(infographicItems.shared);
              infographicItems.user = ReportTemplatesManager._condenseResultsArray(infographicItems.user);
              infographicItems.favoriteIds = ReportTemplatesManager._condenseResultsArray(infographicItems.favoriteIds);
              infographicItems.gallery = ReportTemplatesManager._condenseResultsArray(infographicItems.gallery);
              resolve(infographicItems);
            }
            else {
              resolve(infographicItems);
            }
          })
            .catch((err) => reject(err));
        });
      })
        .catch((err) => reject(err));
    });
  }
  /**
   * Gets function to filter portal items arrays by country code in its properties
   *
   * @param countryCode country code that item's 'countries' array should contain
   * @returns {function(*): boolean}
   */
  static _byCountryAndDefaultHiearchy(countryCode, defaultHierarchy) {
    return function (item) {
      let countries = (item && item.properties && item.properties.countries.toLowerCase()) || (item && item.metadata && item.metadata.countries.toLowerCase());
      let hierarchies = (item && item.properties && item.properties.hierarchy) || (item && item.metadata && item.metadata.hierarchy);
      return countries && countries.indexOf(countryCode.toLowerCase()) >= 0 && hierarchies && hierarchies.indexOf(defaultHierarchy) >= 0;
    };
  }
  // static _byDefaultHierarchy (defaultHierarchy: string) {
  //   return function (item: any) {
  //     let hierarchies = item && item.properties && item.properties.hierarchy
  //     if (hierarchies && hierarchies.indexOf(defaultHierarchy) >= 0)
  //       return true
  //     else
  //       return false
  //   }
  // }
  static _getEsriInfographicReportTemplateItems(countryCode) {
    return GEClient.execute({ taskPath: '/GeoEnrichment/Infographics/Standard/' + countryCode })
      .then((reportTemplatesResponse) => {
      let reportTemplates = reportTemplatesResponse.reports;
      return reportTemplates;
    });
  }
  static _getSharedInfographicReportTemplateItems(username, orgId) {
    let query = 'type:"Report Template" ' +
      '(access:shared OR access:org OR (access:public AND orgid:' +
      orgId +
      ')) ' +
      ' typekeywords:esriWebInfographicReport ' +
      ' NOT owner:' +
      username;
    return ReportTemplatesManager._searchItems(query, ReportTemplatesManager._infographicFilter);
  }
  static _getGalleryInfographicReportTemplateItems() {
    let query = 'type:"Report Template" ' +
      ' typekeywords:esriWebGalleryInfographicReport ' +
      ' owner:(esri_reports OR esri_reports_test)';
    return ReportTemplatesManager._searchItems(query, ReportTemplatesManager._infographicFilter, {
      start: 1,
      num: 1000,
      sortField: 'modified',
      sortOrder: 'desc',
      q: query
    });
  }
  static _getUserInfographicReportTemplateItems(username) {
    return new Promise((resolve, reject) => {
      let query = 'type:"Report Template"' +
        ' typekeywords:esriWebInfographicReport ' +
        ' owner:' +
        username;
      let userIgDeferred = ReportTemplatesManager._searchItems(query, ReportTemplatesManager._infographicFilter);
      let userGalleryIgDeferred = ReportTemplatesManager._getUserGalleryInfographicReportTemplateItems();
      Promise.allSettled([userIgDeferred, userGalleryIgDeferred]).then((res) => {
        let userIgItems = res[0].value ? res[0].value : [];
        let userGalleryIgItems = res[1].value ? res[1].value : [];
        resolve(userIgItems.concat(userGalleryIgItems));
      }, (rejected) => {
        reject(rejected);
      });
    });
  }
  static _getFavoriteReportsIds(username, countryId) {
    return new Promise((resolve, reject) => {
      let query = 'type:"Web Mapping Application" typekeywords:"BAUserData.FavoriteReports" owner:' +
        username;
      ReportTemplatesManager._searchItems(query, null)
        .then((favoriteReportsItems) => {
        let favReportsItem = favoriteReportsItems && favoriteReportsItems[0];
        if (!favReportsItem) {
          resolve([]); //no favorite reports
          return;
        }
        ArcGISClient.getItemData(favReportsItem.id)
          .then((itemData) => {
          if (!itemData) {
            resolve([]); //no favorite reports
            return;
          }
          let favReportsInfos = itemData.data && itemData.data['favorites' + countryId];
          if (!favReportsInfos) {
            resolve([]); //no favorite reports
            return;
          }
          let ret = favReportsInfos.map(function (info) {
            return info.reportID;
          });
          resolve(ret);
        })
          .catch((err) => reject(err));
      })
        .catch((err) => reject(err));
    });
  }
  /**
   * Gets infographic templates that user added to "My Templates" from "Gallery"
   *
   * @returns {*}
   * @private
   */
  static _getUserGalleryInfographicReportTemplateItems() {
    return new Promise((resolve, reject) => {
      WebAppSettings.getUserGalleryInfographicReportIds()
        .then((reportIds) => {
        if (!reportIds || !reportIds.length) {
          resolve([]);
          return;
        }
        let query = reportIds.map((id) => 'id:' + id).join(' OR ');
        ReportTemplatesManager._searchItems(query, ReportTemplatesManager._infographicFilter)
          .then((items) => {
          resolve(items);
        })
          .catch((err) => reject(err));
      })
        .catch((err) => reject(err));
    });
  }
  static _searchItems(query, resultsFilter, options) {
    return new Promise((resolve, reject) => {
      let params = options || {
        start: 1,
        num: 1000,
        sortField: 'title',
        sortOrder: 'asc',
        q: query
      };
      ArcGISClient.searchAllItems({}, params)
        .then((resultItems) => {
        let res = resultsFilter
          ? resultItems.filter(resultsFilter)
          : resultItems;
        resolve(res);
      })
        .catch((err) => reject(err));
    });
  }
  static _createReportTemplateInfos(portalItems, countryCode) {
    let templates = [];
    portalItems.forEach(function (item) {
      let properties = item.properties;
      if (properties) {
        let countries = properties.countries;
        if (SettingsHelper.isTrueString(properties.isComparisonReport)) {
          return;
        }
        if (countries && countries.indexOf(countryCode) !== -1) {
          let rti = {
            reportID: { itemid: item.id },
            formats: properties.formats && properties.formats.split(','),
            headers: [],
            metadata: {
              author: properties.author,
              categories: [],
              countries: countries,
              coverage: properties.coverage,
              hierarchy: GEClient.getGEDefaultHierarchy(countryCode),
              keywords: properties.keywords,
              owner: item.owner,
              title: item.title,
              type: properties.type
            }
          };
          templates.push(rti);
        }
      }
    });
    return templates;
  }
  /**
   * Function for Array.filter that removes non-infographic template items
   *
   * Left here to support filtering out some legacy infographic reports that
   * were not updated on portal for some reasons.
   * @param reportTemplateItem
   * @return {*|boolean}
   * @private
   */
  static _infographicFilter(reportTemplateItem) {
    let p = reportTemplateItem.properties;
    //leave ordinary infographic, but remove single infographics, hidden and blank reports if any
    //boolean properties may be stored as strings
    return (SettingsHelper.isTrueString(p.isGraphicReport) &&
      !SettingsHelper.isTrueString(p.isSingleInfographic) &&
      !SettingsHelper.isTrueString(p.isHidden) &&
      !SettingsHelper.isTrueString(p.isBlank));
  }
}
ReportTemplatesManager._geReportTemplatesCache = {};

class GEClient {
  static async getInfographicTemplatesList(countryCode, full = false, token) {
    return await ReportTemplatesManager.getInfographicReportTemplateItems(countryCode || 'US', full, token);
  }
  static async getClassicReportsTemplatesList(countryCode, full = false) {
    return await ReportTemplatesManager.getReportTemplates(countryCode || 'US', full);
  }
  static execute(geParameters) {
    return new Promise((resolve, reject) => {
      const geoenrichmentUrl = ArcGISClient.getGeoenrichmentUrl();
      // do deep copy, instead of $j.extend({}, params)
      var _geParams = geParameters ? JSON.parse(JSON.stringify(geParameters)) : {};
      if (!_geParams.data)
        _geParams.data = {};
      _geParams.data.forStorage = false;
      // todo: implement queue for this requests, key is _geParams.taskPath or hex_sha1(geParameters)
      ArcGISClient.executeRequest({
        url: geoenrichmentUrl + _geParams.taskPath,
        data: _geParams.data,
        isStandardGeoQuery: _geParams.isStandardGeoQuery
      }).then(resolve).catch(reject);
    });
  }
  static createReport(createReportParams) {
    return new Promise((resolve, reject) => {
      const geUrl = ArcGISClient.getGeoenrichmentUrl();
      let createReportUrl = geUrl.toString() + '/Geoenrichment/CreateReport';
      ArcGISClient.executeRequest({
        url: createReportUrl,
        data: createReportParams
      }).then(resolve).catch(reject);
    });
  }
  /**
   * Performs standard geography search by textual geography query.
   *
   * Note: be patient while setting request options. `sourceCountry`, `geographyLayers`, `optionalCountryHierarchy`
   * params are coupled and country-specific, so update it simultaneously
   *
   * @param geographyQuery String to search for
   * @param options Options to refine search:
   *    featureLimit
   *    geographyLayers
   *    useFuzzySearch
   *    sourceCountry
   *    optionalCountryHierarchy
   * @see https://developers.arcgis.com/rest/geoenrichment/api-reference/standard-geography-query.htm
   */
  static searchStdGeography(geographyQuery, options) {
    return new Promise(async (resolve, reject) => {
      if (!geographyQuery || !geographyQuery.length) {
        resolve([]);
        return;
      }
      let defaultHierarchy = await this.getGEDefaultHierarchy(options?.sourceCountry || 'US', options?.token);
      let geParams = {
        geographyQuery: geographyQuery,
        featureLimit: options?.featureLimit || 10,
        geographyLayers: options?.geographyLayers || ['US.States', 'US.Counties', 'US.Places'],
        useFuzzySearch: options?.useFuzzySearch,
        sourceCountry: options?.sourceCountry || 'US',
        langCode: options?.langCode || "en-us",
        optionalCountryHierarchy: options?.optionalCountryHierarchy || defaultHierarchy
      };
      this.standardGeographyQuery(geParams)
        .then(features => resolve(features))
        .catch(error => reject(error));
    });
  }
  /**
   * Gets standard geography by layer id, feature id and some optional parameters.
   *
   * @param layerId Id of layer to look up in
   * @param featureId Id of feature to request
   * @param options Options to refine query:
   *    featureLimit
   *    returnGeometry
   *    generalizationLevel
   *    sourceCountry
   *    langCode
   *    optionalCountryHierarchy
   * @see https://developers.arcgis.com/rest/geoenrichment/api-reference/standard-geography-query.htm
   */
  static requestStdGeography(layerId, featureId, options) {
    return new Promise(async (resolve, reject) => {
      let defaultHierarchy = await this.getGEDefaultHierarchy(options?.sourceCountry || 'US', options?.token);
      let geParams = {
        geographyLayers: [layerId],
        featureLimit: options?.featureLimit || 1,
        returnGeometry: options?.returnGeometry,
        // outSR: JSON.stringify({wkid: 102100, latestWkid: 3857}),
        generalizationLevel: options?.generalizationLevel || 0,
        geographyIDs: [featureId],
        sourceCountry: options?.sourceCountry || 'US',
        langCode: options?.langCode || "en-us",
        optionalCountryHierarchy: options?.optionalCountryHierarchy || defaultHierarchy
      };
      this.standardGeographyQuery(geParams)
        .then(features => resolve(features))
        .catch(error => reject(error));
    });
  }
  static standardGeographyQuery(params) {
    return new Promise((resolve, reject) => {
      let geParams = {
        data: params,
        isStandardGeoQuery: true,
        taskPath: '/StandardGeographyQuery/execute'
      };
      GEClient.execute(geParams).then((queryResponse) => {
        let result = queryResponse &&
          queryResponse.results &&
          queryResponse.results.length &&
          queryResponse.results[0];
        let features = result &&
          result.value &&
          result.value.features;
        if (features)
          resolve(features);
        else {
          let errorMessages = queryResponse &&
            queryResponse.messages &&
            queryResponse.messages.length;
          reject(errorMessages);
        }
      }).catch(error => {
        reject(error);
      });
    });
  }
  static getStoredDefaultHierarchy(country) {
    let result;
    if (window.localStorage) {
      let d = localStorage.getItem(GEClient._defaultHierarchyStorageName);
      if (d && _ElementIds_f7d257e8_js__WEBPACK_IMPORTED_MODULE_0__.U.hasText(d)) {
        let obj = JSON.parse(d);
        result = obj[country];
        // save current defaults in static instance
        GEClient._defaultHierarchies = obj;
      }
    }
    return result;
  }
  /**  setStoredDefaultHierarchy
   *       Stores a default hierarchy name for a given country
   *
   * Stored object is in this format:
   *  {
   *    "US" : "census2020",
   *    "FR" : "FRA_EsriFrance"
   *  }
   * @param country - identifier (ex: 'US')
   * @param name    - default hierarchy name for the country
   */
  static setStoredDefaultHierarchy(country, name) {
    try {
      GEClient.getStoredDefaultHierarchy(country);
      if (!GEClient._defaultHierarchies)
        GEClient._defaultHierarchies = {};
      GEClient._defaultHierarchies[country] = name;
      if (window.localStorage) {
        localStorage.setItem(GEClient._defaultHierarchyStorageName, JSON.stringify(GEClient._defaultHierarchies));
      }
    }
    catch (ex) {
      console.log('GEClient error', ex);
    }
  }
  //   /**
  //      * Gets hierarchy for specified country: either set by id in app settings or default one
  //      *
  //      * @param countryCode 2-letter or 3-letter country code
  //      * @returns {*} Hierarchy for specified country (not null)
  //      */
  //   getPreferredHierarchy: function (countryCode) {
  //     var countryData = BA.CountryDataManager._countryData;
  //     BA.log.info("countryData: ", countryData);
  //     var country = countryData[countryCode];
  //     BA.log.info("countryCode: ", countryCode);
  //     if (country.hierarchies){
  //         for(var i=0; i < country.hierarchies.length; i++){
  //             var h = country.hierarchies[i];
  //             BA.log.info("hierarchy[i]: ", h);
  //             if(h.default){
  //                 BA.log.info("default hierarchy: ",  h);
  //                 // return if default hierarchy is true
  //                 return h;
  //             }
  //         }
  //         BA.log.info("default hierarchy not found using: ", h);
  //         return country.hierarchies[0];
  //         // return first result if no default is found
  //     }
  //     return false;
  // },
  /**  getGEDefaultHierarchy
   *      Returns the default hierarchy name for the given country.
   *      The default may be returned from a localStorage value
   *      saved previously using GEClient.setStoredDefaultHierarchy() or
   *      requested from GE.
   *
   *      In the case the default is fetched from GE, that default
   *      will be cached in local storage
   *
   * @param country - identifier (ex: 'US')
   * @param token - auth token (optional)
   */
  static getGEDefaultHierarchy(country, token) {
    return new Promise((resolve, reject) => {
      let c = 'US'; // default
      if (country && _ElementIds_f7d257e8_js__WEBPACK_IMPORTED_MODULE_0__.U.hasText(country))
        c = country;
      // pull default hierarchy from localStorage if available
      let defaultHierarchy = GEClient.getStoredDefaultHierarchy(c);
      if (defaultHierarchy && _ElementIds_f7d257e8_js__WEBPACK_IMPORTED_MODULE_0__.U.hasText(defaultHierarchy))
        resolve(defaultHierarchy);
      // Must request default from GE server
      // request= https://geoenrich.arcgis.com/arcgis/rest/services/World/geoenrichmentserver/Geoenrichment/Countries/US?f=pjson
      const geUrl = ArcGISClient.getGeoenrichmentUrl();
      let url = geUrl.toString() + '/Geoenrichment/Countries/' + country + '?f=pjson';
      const data = token ? {
        appID: GEClient.appID,
        token: token
      } :
        {
          appID: GEClient.appID
        };
      ArcGISClient.executeRequest({
        url: url,
        data
      }).then((e) => {
        let def = 'US';
        let arr = e.countries[0].hierarchies;
        if (arr && arr.length > 0) {
          for (let ii = 0; ii < arr.length; ii++) {
            let h = arr[ii];
            if (h.default) {
              def = h.ID;
              // save default to local storage
              GEClient.setStoredDefaultHierarchy(c, h.ID);
              break;
            }
          }
        }
        resolve(def);
      }).catch(reject);
    });
  }
  // async request for std geog levels
  static getStandardGeographyLevels(country, langCode) {
    return new Promise((resolve, reject) => {
      if (!country || !_ElementIds_f7d257e8_js__WEBPACK_IMPORTED_MODULE_0__.U.hasText(country))
        country = 'US'; // default
      // default hierarchy
      GEClient.getGEDefaultHierarchy(country).then((defHierarchyName) => {
        // Request geography levels
        // request= https://geoenrich.arcgis.com/arcgis/rest/services/World/geoenrichmentserver/Geoenrichment/StandardGeographyLevels/US?f=json
        const geUrl = ArcGISClient.getGeoenrichmentUrl();
        // let url: string = geUrl.toString() + '/Countries/' + country + '?f=pjson';
        let url = geUrl.toString() + '/Geoenrichment/StandardGeographyLevels/' + country + '?f=pjson';
        ArcGISClient.executeRequest({
          url: url,
          data: {
            langCode: langCode ? langCode : "en-us"
          }
        }).then((e) => {
          let hier;
          if (e && e.geographyLevels && e.geographyLevels[0] && e.geographyLevels[0].hierarchies) {
            let arr = e.geographyLevels[0].hierarchies;
            for (let ii = 0; ii < arr.length; ii++) {
              if (arr[ii].ID == defHierarchyName) {
                hier = arr[ii];
                break;
              }
            }
            if (!hier)
              hier = arr[0];
          }
          resolve(hier);
        }).catch(reject);
      }).catch(reject);
    }).catch(error => {
      console.log('GEClient error', error);
    });
  }
}
GEClient._defaultHierarchyStorageName = 'GEClient-default-hierarchy';
// NOTE!!: Hardcoded for Experience Builder, we need to modify to be passed in by consuming application to allow for multi app use
GEClient.appID = "esriexperiencebuilder";
GEClient.enrich = function (enrichRequestParams) {
  return new Promise(async (resolve, reject) => {
    const params = enrichRequestParams;
    var enrichUrl = Environments.getUrl('geoenrich') + '/Geoenrichment/Enrich';
    params.forStorage = false;
    ArcGISClient.executeRequest({
      url: enrichUrl,
      data: params
    }).then(function (enrichResponse) {
      var result = enrichResponse && enrichResponse.results && enrichResponse.results.length && enrichResponse.results[0];
      var featureSet = result && result.value && result.value.FeatureSet && result.value.FeatureSet.length && result.value.FeatureSet[0];
      if (featureSet.features && featureSet.features.length) {
        resolve(enrichResponse);
      }
      else {
        var errorDescription = enrichResponse && enrichResponse.messages && enrichResponse.messages.length && enrichResponse.messages[0].description;
        if (!errorDescription)
          errorDescription = 'getfacts-no-data';
        reject(errorDescription);
      }
    }, function (err) {
      reject(err);
    });
  });
};



//# sourceMappingURL=GEClient-1a83a657.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYmEtaW5mb2dyYXBoaWNfbm9kZV9tb2R1bGVzX2FyY2dpc19idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHNfZGlzLTdmNjU2OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzREFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBbUQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpRUFBaUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQkFBK0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsR0FBRztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixxQkFBcUIsc0RBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFLO0FBQzVCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFcUY7O0FBRXJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9iYS1pbmZvZ3JhcGhpYy9ub2RlX21vZHVsZXMvQGFyY2dpcy9idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHMvZGlzdC9zdGVuY2lsLWNvbXBvbmVudHMvZGlzdC9lc20vR0VDbGllbnQtMWE4M2E2NTcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVSBhcyBVdGlscywgYSBhcyBCYXNlVXRpbCB9IGZyb20gJy4vRWxlbWVudElkcy1mN2QyNTdlOC5qcyc7XG5cbmNsYXNzIFRva2VuUHJvdmlkZXIge1xuICAvKipcbiAgICogdG9kbzogaW1wbGVtZW50IHJlYWwgbWV0aG9kXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dW5rbm93bj59XG4gICAqL1xuICBzdGF0aWMgZ2V0VG9rZW4oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlKFRva2VuUHJvdmlkZXIudG9rZW4uYWNjZXNzX3Rva2VuKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0VG9rZW4odXNlcm5hbWUsIHRva2VuKSB7XG4gICAgaWYgKHVzZXJuYW1lICYmIHVzZXJuYW1lLmxlbmd0aCA+IDAgJiYgdG9rZW4gJiYgdG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy50b2tlbi5hY2Nlc3NfdG9rZW4gPSB0b2tlbjtcbiAgICAgIHRoaXMudG9rZW4udXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgICB9XG4gIH1cbn1cblRva2VuUHJvdmlkZXIudG9rZW4gPSB7XG4gIGFjY2Vzc190b2tlbjogJycsXG4gIGV4cGlyZXNfaW46IG51bGwsXG4gIHBlcnNpc3Q6ICd0cnVlJyxcbiAgc3NsOiAndHJ1ZScsXG4gIHVzZXJuYW1lOiAnbWFya19iYSdcbn07XG5cbi8qKiBFbnZpcm9ubWVudHNcbiAqXG4gKiAgVGhpcyBjbGFzcyBwcm92aWRlcyBzdXBwb3J0IGZvciBlbnZpcm9ubWVudHMgYW5kIHN1YmRvbWFpbnNcbiAqICBQb3J0YWxVcmwgLSBjYW4gYmUgb3ZlcnJpZGVuIGZvciBlbnRlcnByaXNlIGVudmlyb25tZW50c1xuICogIEdlb2NvZGVyVXJsIC0gY2FuIGJlIG92ZXJyaWRlblxuICogIEdlb2VucmljaG1lbnRVcmwgLSBjYW4gYmUgb3ZlcnJpZGVuXG4gKi9cbmNsYXNzIEVudmlyb25tZW50cyB7XG4gIHN0YXRpYyBzZXRFbnZpcm9ubWVudChlbnYpIHtcbiAgICBsZXQgZSA9IChlbnYgPT09ICdwcm9kJyB8fCBlbnYgPT09ICdsb2NhbGhvc3QnKSA/ICd3d3cnIDogZW52O1xuICAgIEVudmlyb25tZW50cy5fZW52ID0gZTtcbiAgfVxuICBzdGF0aWMgZ2V0RW52aXJvbm1lbnQoKSB7XG4gICAgcmV0dXJuIEVudmlyb25tZW50cy5fZW52O1xuICB9XG4gIHN0YXRpYyBzZXRQb3J0YWxVcmwocG9ydGFsVXJsKSB7XG4gICAgRW52aXJvbm1lbnRzLnBvcnRhbFVybCA9IHBvcnRhbFVybDtcbiAgfVxuICBzdGF0aWMgc2V0R2VvZW5yaWNobWVudFVybChnZVVybCkge1xuICAgIEVudmlyb25tZW50cy5nZW9lbnJpY2htZW50VXJsID0gZ2VVcmw7XG4gIH1cbiAgc3RhdGljIHNldEdlb2NvZGVVcmwoZ2VvY29kZVVybCkge1xuICAgIEVudmlyb25tZW50cy5nZW9jb2RlVXJsID0gZ2VvY29kZVVybDtcbiAgfVxuICBzdGF0aWMgZ2V0UG9ydGFsQmFzZSgpIHtcbiAgICAvLyBPcHRpb25hbCwgaWYgUG9ydGFsVXJsIGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0L292ZXJyaWRlbiB1c2UgaXRcbiAgICBpZiAoRW52aXJvbm1lbnRzLnBvcnRhbFVybCkge1xuICAgICAgcmV0dXJuIEVudmlyb25tZW50cy5wb3J0YWxVcmw7XG4gICAgfVxuICAgIGNvbnN0IGUgPSBFbnZpcm9ubWVudHMuX2VudjtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gJyc7XG4gICAgY29uc3Qgc3ViZG9tYWluID0gZSA9PT0gJ2RldicgPyAnZGV2ZXh0JyA6IGUgPT09ICdxYScgPyAncWFleHQnIDogJ3d3dyc7XG4gICAgbGV0IHVybCA9ICdodHRwczovLycgKyBzdWJkb21haW4gKyAnLmFyY2dpcy5jb20nO1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYXBwcm9wcmlhdGUgcmVxdWVzdCBVUkwgZm9yIHRoZSBzdWJkb21haW5cbiAgICpcbiAgICogQHBhcmFtIHN1YkRvbWFpbiAtIG9uZSBvZiAnZ2VvY29kZScsICdhcmNnaXMnLCBvciAnZ2VvZW5yaWNoJ1xuICAgKi9cbiAgc3RhdGljIGdldFVybChzdWJEb21haW4pIHtcbiAgICBpZiAoIUVudmlyb25tZW50cy5fZW52KSB7XG4gICAgICBjb25zb2xlLmxvZygnRW52aXJvbm1lbnRzIGVycm9yOiBlbnYgbm90IHNldCcpO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAoIXN1YkRvbWFpbiB8fCAhVXRpbHMuaGFzVGV4dChzdWJEb21haW4pKSB7XG4gICAgICBjb25zb2xlLmxvZygnRW52aXJvbm1lbnRzIGVycm9yOiBpbnZhbGlkIHN1YmRvbWFpbicpO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBwb3J0YWwgPSBFbnZpcm9ubWVudHMuZ2V0UG9ydGFsQmFzZSgpO1xuICAgIGlmIChwb3J0YWwgPT09ICcnKVxuICAgICAgcmV0dXJuICcnO1xuICAgIHRyeSB7XG4gICAgICBsZXQgdXJsID0gJyc7XG4gICAgICBzd2l0Y2ggKHN1YkRvbWFpbikge1xuICAgICAgICBjYXNlICgnZ2VvY29kZScpOiB7XG4gICAgICAgICAgLy8gT3B0aW9uYWwsIGlmIEdlb2NvZGVVcmwgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQvb3ZlcnJpZGVuIHVzZSBpdFxuICAgICAgICAgIGlmIChFbnZpcm9ubWVudHMuZ2VvY29kZVVybCkge1xuICAgICAgICAgICAgdXJsID0gRW52aXJvbm1lbnRzLmdlb2NvZGVVcmw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cmwgPVxuICAgICAgICAgICAgICAoRW52aXJvbm1lbnRzLl9lbnYgPT09ICdxYScpID8gJ2h0dHBzOi8vZ2VvY29kZXFhLmFyY2dpcy5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvV29ybGQvR2VvY29kZVNlcnZlcicgOlxuICAgICAgICAgICAgICAgIChFbnZpcm9ubWVudHMuX2VudiA9PT0gJ2RldicpID8gJ2h0dHBzOi8vZ2VvY29kZWRldi5hcmNnaXMuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1dvcmxkL0dlb2NvZGVTZXJ2ZXInIDpcbiAgICAgICAgICAgICAgICAgICdodHRwczovL2dlb2NvZGUuYXJjZ2lzLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZC9HZW9jb2RlU2VydmVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICgnYXJjZ2lzJyk6IHtcbiAgICAgICAgICB1cmwgPSBwb3J0YWw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAoJ2luZm9ncmFwaGljcycpOiB7XG4gICAgICAgICAgdXJsID1cbiAgICAgICAgICAgIChFbnZpcm9ubWVudHMuX2VudiA9PT0gJ3FhJykgPyAnaHR0cHM6Ly9iYW9xYS5hcmNnaXMuY29tL0luZm9ncmFwaGljc1BsYXllci9CQU1vYmlsZS8yMy5SMDMvcmVwb3J0UGxheWVyL1JlcG9ydFBsYXllck1vYmlsZS5odG1sJyA6XG4gICAgICAgICAgICAgIChFbnZpcm9ubWVudHMuX2VudiA9PT0gJ2RldicpID8gJ2h0dHBzOi8vYmFvZGV2LmFyY2dpcy5jb20vSW5mb2dyYXBoaWNzUGxheWVyL0JBTW9iaWxlLzIzLlIwMy9yZXBvcnRQbGF5ZXIvUmVwb3J0UGxheWVyTW9iaWxlLmh0bWwnIDpcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly9iYW8uYXJjZ2lzLmNvbS9JbmZvZ3JhcGhpY3NQbGF5ZXIvQkFNb2JpbGUvMjMuUjAzL3JlcG9ydFBsYXllci9SZXBvcnRQbGF5ZXJNb2JpbGUuaHRtbCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAoJ2dlb2VucmljaCcpOiB7XG4gICAgICAgICAgLy8gT3B0aW9uYWwsIGlmIEdlb2VucmljaG1lbnRVcmwgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQvb3ZlcnJpZGVuIHVzZSBpdFxuICAgICAgICAgIGlmIChFbnZpcm9ubWVudHMuZ2VvZW5yaWNobWVudFVybCkge1xuICAgICAgICAgICAgdXJsID0gRW52aXJvbm1lbnRzLmdlb2VucmljaG1lbnRVcmw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cmwgPVxuICAgICAgICAgICAgICAoRW52aXJvbm1lbnRzLl9lbnYgPT09ICdxYScpID8gJ2h0dHBzOi8vZ2VvZW5yaWNocWEuYXJjZ2lzLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZC9nZW9lbnJpY2htZW50c2VydmVyJyA6XG4gICAgICAgICAgICAgICAgKEVudmlyb25tZW50cy5fZW52ID09PSAnZGV2JykgPyAnaHR0cHM6Ly9nZW9lbnJpY2hkZXYuYXJjZ2lzLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZC9nZW9lbnJpY2htZW50c2VydmVyJyA6XG4gICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9nZW9lbnJpY2guYXJjZ2lzLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZC9nZW9lbnJpY2htZW50c2VydmVyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgQmFzZVV0aWwuRXJyb3IoJ0Vudmlyb25tZW50cy5nZXRVcmwoKSBlcnJvciAnLCBleCk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGdlb2NvZGVVcmwgc3RyaW5nIHBhc3NlZCBpbiBpcyB0aGUgb25saW5lIEdlb2NvZGVyIFNlcnZpY2UgKGRldiwgcWEsIHByb2QpLCBmYWxzZSBvdGhlcndpc2VcbiAgc3RhdGljIGlzT25saW5lR2VvY29kZXIoZ2VvY29kZVVybCkge1xuICAgIGlmIChnZW9jb2RlVXJsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnaHR0cHM6Ly9nZW9jb2RlLmFyY2dpcy5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvV29ybGQvR2VvY29kZVNlcnZlcicudG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgIGdlb2NvZGVVcmwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdodHRwczovL2dlb2NvZGVxYS5hcmNnaXMuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1dvcmxkL0dlb2NvZGVTZXJ2ZXInLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICBnZW9jb2RlVXJsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnaHR0cHM6Ly9nZW9jb2RlZGV2LmFyY2dpcy5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvV29ybGQvR2VvY29kZVNlcnZlcicudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBwb3J0YWxVcmwgc3RyaW5nIHBhc3NlZCBpbiBpcyB0aGUgb25saW5lIFBvcnRhbCAoZGV2LCBxYSwgcHJvZCksIGZhbHNlIG90aGVyd2lzZVxuICBzdGF0aWMgaXNBR09Qb3J0YWwocG9ydGFsVXJsKSB7XG4gICAgaWYgKHBvcnRhbFVybC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vd3d3LmFyY2dpcy5jb20nLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICBwb3J0YWxVcmwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdodHRwczovL3FhZXh0LmFyY2dpcy5jb20nLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICBwb3J0YWxVcmwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdodHRwczovL2RldmV4dC5hcmNnaXMuY29tJy50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuRW52aXJvbm1lbnRzLl9lbnYgPSAnd3d3Jztcbi8vIE9wdGlvbmFsLCBhYmlsaXR5IHRvIG92ZXJyaWRlIHBvcnRhbFVybFxuRW52aXJvbm1lbnRzLnBvcnRhbFVybCA9ICcnO1xuLy8gT3B0aW9uYWwsIGFiaWxpdHkgdG8gb3ZlcnJpZGUgZ2VvZW5yaWNobWVudCBVUkxcbkVudmlyb25tZW50cy5nZW9lbnJpY2htZW50VXJsID0gJyc7XG4vLyBPcHRpb25hbCwgYWJpbGl0eSB0byBvdmVycmlkZSBnZW9jb2RlIFVSTFxuRW52aXJvbm1lbnRzLmdlb2NvZGVVcmwgPSAnJztcblxuY2xhc3MgQXJjR0lTQ2xpZW50IHtcbiAgc3RhdGljIGV4ZWN1dGVTZWxmKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBUb2tlblByb3ZpZGVyLmdldFRva2VuKCkudGhlbigoYWNjZXNzVG9rZW4pID0+IHtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuID09PSBBcmNHSVNDbGllbnQuX2xhc3RTZWxmVG9rZW4pIHtcbiAgICAgICAgICByZXNvbHZlKEFyY0dJU0NsaWVudC5fc2VsZlJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGV0IHNldHRpbmdzID0ge1xuICAgICAgICAgICAgdGFza1BhdGg6ICcvcG9ydGFscy9zZWxmJyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgY3VsdHVyZTogJ2VuLXVzJyAvLyB0b2RvOiBnZXQgYWN0dWFsIGxvY2FsZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgQXJjR0lTQ2xpZW50LmV4ZWN1dGVSZXF1ZXN0KHNldHRpbmdzKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIC8vY2FjaGluZyByZXNwb25zZSBmcm9tIFwiL3NlbGZcIiB3aXRoIHRva2VuIGFzIGtleVxuICAgICAgICAgICAgQXJjR0lTQ2xpZW50Ll9sYXN0U2VsZlRva2VuID0gYWNjZXNzVG9rZW47XG4gICAgICAgICAgICBBcmNHSVNDbGllbnQuX3NlbGZSZXN1bHQgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIEFyY0dJU0NsaWVudC5fbGFzdFNlbGZUb2tlbiA9ICcnO1xuICAgICAgICAgICAgQXJjR0lTQ2xpZW50Ll9zZWxmUmVzdWx0ID0gJyc7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiByZWplY3QoZXJyKSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEdlb2VucmljaG1lbnRVcmwoKSB7XG4gICAgcmV0dXJuIEVudmlyb25tZW50cy5nZXRVcmwoJ2dlb2VucmljaCcpO1xuICB9XG4gIHN0YXRpYyBnZXRIZWxwZXJTZXJ2aWNlVXJsKHNlcnZpY2VOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIEFyY0dJU0NsaWVudC5leGVjdXRlU2VsZigpLnRoZW4oZnVuY3Rpb24gKHNlbGZSZXN1bHQpIHtcbiAgICAgICAgbGV0IGhlbHBlclNlcnZpY2VzID0gc2VsZlJlc3VsdC5oZWxwZXJTZXJ2aWNlcztcbiAgICAgICAgaWYgKGhlbHBlclNlcnZpY2VzKSB7XG4gICAgICAgICAgbGV0IGhlbHBlclNlcnZpY2UgPSBoZWxwZXJTZXJ2aWNlc1tzZXJ2aWNlTmFtZV07XG4gICAgICAgICAgaWYgKGhlbHBlclNlcnZpY2UpIHtcbiAgICAgICAgICAgIGxldCB1cmxTdHJpbmcgPSBBcnJheS5pc0FycmF5KGhlbHBlclNlcnZpY2UpID8gaGVscGVyU2VydmljZVswXS51cmwgOiBoZWxwZXJTZXJ2aWNlLnVybDtcbiAgICAgICAgICAgIHVybFN0cmluZyA/IHJlc29sdmUodXJsU3RyaW5nKSA6IHJlamVjdChzZXJ2aWNlTmFtZSArICcgaGVscGVyIHNlcnZpY2UgaXMgbm90IGNvbmZpZ3VyZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlamVjdChzZXJ2aWNlTmFtZSArICcgaGVscGVyIHNlcnZpY2UgaXMgbm90IGNvbmZpZ3VyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlamVjdCgnSGVscGVyIHNlcnZpY2VzIGFyZSBub3QgY29uZmlndXJlZC4nKTtcbiAgICAgIH0pLmNhdGNoKGVyciA9PiByZWplY3QoZXJyKSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldFBvcnRhbFJlc291cmNlKHJlc291cmNlTmFtZSkge1xuICAgIHJldHVybiBBcmNHSVNDbGllbnQuZXhlY3V0ZVJlcXVlc3Qoe1xuICAgICAgdGFza1BhdGg6ICcvcG9ydGFscy9zZWxmL3Jlc291cmNlcy8nICsgcmVzb3VyY2VOYW1lXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEl0ZW1EYXRhKGl0ZW1JZCkge1xuICAgIHJldHVybiBBcmNHSVNDbGllbnQuZXhlY3V0ZVJlcXVlc3Qoe1xuICAgICAgdGFza1BhdGg6ICcvY29udGVudC9pdGVtcy8nICsgaXRlbUlkICsgJy9kYXRhJ1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgaXRlbXMgYnkgcHJvdmlkZWQgc2VhcmNoIHF1ZXJ5IGFuZCBwYXJhbXMgYW5kIGV4dHJhY3RzIGFsbCBzZWFyY2ggcmVzdWx0c1xuICAgKiBieXBhc3NpbmcgQXJjR0lTIHNlcnZlciBsaW1pdCBvZiAxMDAgaXRlbXNcbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gICAqL1xuICBzdGF0aWMgc2VhcmNoQWxsSXRlbXMocXVlcnksIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc2VhcmNoUmVzdWx0cyA9IFtdO1xuICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgbGV0IF9kb1NlYXJjaCA9IGZ1bmN0aW9uIChxdWVyeSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgICAgIHNlbGYuc2VhcmNoSXRlbXMocXVlcnksIHBhcmFtcywgY29udGV4dCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pdGVtcy5sZW5ndGgpXG4gICAgICAgICAgICBzZWFyY2hSZXN1bHRzID0gc2VhcmNoUmVzdWx0cy5jb25jYXQocmVzdWx0Lml0ZW1zKTtcbiAgICAgICAgICBsZXQgbmV3Q29udGV4dCA9IHJlc3VsdC5jb250ZXh0O1xuICAgICAgICAgIGlmIChuZXdDb250ZXh0Lm5leHRTdGFydCA+IDApXG4gICAgICAgICAgICBfZG9TZWFyY2gocXVlcnksIHBhcmFtcywgbmV3Q29udGV4dCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzb2x2ZShzZWFyY2hSZXN1bHRzKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChzZWFyY2hSZXN1bHRzICYmIHNlYXJjaFJlc3VsdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmVzb2x2ZShzZWFyY2hSZXN1bHRzKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgX2RvU2VhcmNoKHF1ZXJ5LCBwYXJhbXMsIG51bGwpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBzZWFyY2hJdGVtcyhxdWVyeSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIGRvIGRlZXAgY29weSwgaW5zdGVhZCBvZiAkai5leHRlbmQoe30sIHBhcmFtcylcbiAgICAgIGxldCBzZWFyY2hQYXJhbXMgPSBwYXJhbXMgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBhcmFtcykpIDoge307XG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBzZWFyY2hQYXJhbXMucSA9IHBhcmFtcy5xO1xuICAgICAgICBsZXQgdG90YWwgPSBjb250ZXh0LnRvdGFsO1xuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gY29udGV4dC5uZXh0U3RhcnQ7XG4gICAgICAgIGlmICh0b3RhbCAmJiBuZXh0U3RhcnQpIHtcbiAgICAgICAgICBpZiAobmV4dFN0YXJ0ID4gMCAmJiB0b3RhbCA+PSBuZXh0U3RhcnQpXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuc3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzb2x2ZSh7IGl0ZW1zOiBbXSwgY29udGV4dDogY29udGV4dCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5zb3J0RmllbGQgJiYgY29udGV4dC5zb3J0T3JkZXIpIHtcbiAgICAgICAgICBzZWFyY2hQYXJhbXMuc29ydE9yZGVyID0gY29udGV4dC5zb3J0T3JkZXI7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLnNvcnRGaWVsZCA9IGNvbnRleHQuc29ydEZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIC8vICRqLmFqYXhTZXR1cCh7XG4gICAgICAgIC8vICAgICBnbG9iYWw6IGZhbHNlXG4gICAgICAgIC8vIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBxdWVyeVBhcnRzID0gW107XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHF1ZXJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBxdWVyeVBhcnRzLnB1c2goa2V5ICsgJzpcIicgKyBxdWVyeVtrZXldICsgJ1wiJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocXVlcnlQYXJ0cy5sZW5ndGgpXG4gICAgICAgICAgc2VhcmNoUGFyYW1zLnEgPSBxdWVyeVBhcnRzLmpvaW4oJyBBTkQgJyk7XG4gICAgICB9XG4gICAgICBBcmNHSVNDbGllbnQucG9ydGFsU2VhcmNoKHNlYXJjaFBhcmFtcykudGhlbigoc2VhcmNoUmVzcG9uc2UpID0+IHtcbiAgICAgICAgLy8gJGouYWpheFNldHVwKHtcbiAgICAgICAgLy8gICAgIGdsb2JhbDogdHJ1ZVxuICAgICAgICAvLyB9KTtcbiAgICAgICAgbGV0IHJlc3VsdEl0ZW1zID0gc2VhcmNoUmVzcG9uc2UucmVzdWx0cztcbiAgICAgICAgbGV0IGN0eCA9IHtcbiAgICAgICAgICBxdWVyeTogc2VhcmNoUmVzcG9uc2UucXVlcnksXG4gICAgICAgICAgdG90YWw6IHNlYXJjaFJlc3BvbnNlLnRvdGFsLFxuICAgICAgICAgIG5leHRTdGFydDogc2VhcmNoUmVzcG9uc2UubmV4dFN0YXJ0LFxuICAgICAgICAgIHNvcnRPcmRlcjogbnVsbCxcbiAgICAgICAgICBzb3J0RmllbGQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNlYXJjaFBhcmFtcy5zb3J0T3JkZXIgJiYgc2VhcmNoUGFyYW1zLnNvcnRGaWVsZCkge1xuICAgICAgICAgIGN0eC5zb3J0T3JkZXIgPSBzZWFyY2hQYXJhbXMuc29ydE9yZGVyO1xuICAgICAgICAgIGN0eC5zb3J0RmllbGQgPSBzZWFyY2hQYXJhbXMuc29ydEZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoeyBpdGVtczogcmVzdWx0SXRlbXMsIGNvbnRleHQ6IGN0eCB9KTtcbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgLy8vIG1ldGhvZHMgZnJvbSBCQS5hcmNHSVNSZXF1ZXN0c1xuICBzdGF0aWMgcG9ydGFsU2VhcmNoKHBhcmFtcykge1xuICAgIHJldHVybiBBcmNHSVNDbGllbnQuZXhlY3V0ZVJlcXVlc3Qoe1xuICAgICAgdGFza1BhdGg6ICcvc2VhcmNoJyxcbiAgICAgIGRhdGE6IHBhcmFtc1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBhc3luYyBnZXRQb3J0YWxVcmwoKSB7XG4gICAgcmV0dXJuIEVudmlyb25tZW50cy5nZXRVcmwoJ2FyY2dpcycpICsgJy9zaGFyaW5nL3Jlc3QnO1xuICB9XG4gIHN0YXRpYyBleGVjdXRlUmVxdWVzdChzZXR0aW5ncykge1xuICAgIC8vc2V0dGluZ3M6XG4gICAgLy8ge1xuICAgIC8vICAgICBcImRhdGFcIjoge1xuICAgIC8vICAgICBcIm51bVwiOiAxMDAwLFxuICAgIC8vICAgICAgICAgXCJxXCI6IFwidHlwZTpcXFwiUmVwb3J0IFRlbXBsYXRlXFxcIiB0eXBla2V5d29yZHM6ZXNyaVdlYlN0YW5kYXJkSW5mb2dyYXBoaWNSZXBvcnQgb3duZXI6ZXNyaV9yZXBvcnRzXCIsXG4gICAgLy8gICAgICAgICBcInNvcnRGaWVsZFwiOiBcInRpdGxlXCIsXG4gICAgLy8gICAgICAgICBcInNvcnRPcmRlclwiOiBcImFzY1wiLFxuICAgIC8vICAgICAgICAgXCJzdGFydFwiOiAxXG4gICAgLy8gICAgIH0sXG4gICAgLy8gICAgIFwidGFza1BhdGhcIjogXCIvc2VhcmNoXCJcbiAgICAvLyB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIFRva2VuUHJvdmlkZXIuZ2V0VG9rZW4oKS50aGVuKGFzeW5jIChhY2Nlc3NfdG9rZW4pID0+IHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5kYXRhKVxuICAgICAgICAgIHNldHRpbmdzLmRhdGEgPSB7fTtcbiAgICAgICAgLy8gdG9kbzogdXNlIGRlZmF1bHQgcGFyYW1zIHdpdGggYWJpbGl0eSB0byBvdmVycmlkZSB0aGVtXG4gICAgICAgIGlmICghc2V0dGluZ3MuZGF0YS5mKVxuICAgICAgICAgIHNldHRpbmdzLmRhdGEuZiA9ICdqc29uJztcbiAgICAgICAgc2V0dGluZ3MuZGF0YS50b2tlbiA9IGFjY2Vzc190b2tlbiA/IGFjY2Vzc190b2tlbiA6IHNldHRpbmdzLmRhdGEudG9rZW47XG4gICAgICAgIGlmICghc2V0dGluZ3MuZGF0YS50b2tlbikge1xuICAgICAgICAgIGRlbGV0ZSBzZXR0aW5ncy5kYXRhLnRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHNldHRpbmdzLmRhdGEubGFuZ0NvZGUgPSBzZXR0aW5ncy5kYXRhPy5sYW5nQ29kZSA/IHNldHRpbmdzLmRhdGEubGFuZ0NvZGUgOiAnZW4tdXMnOyAvLyB0b2RvOiB1cGRhdGVcbiAgICAgICAgLy90b2RvOiB0aW1lb3V0OiAzMDAwMCBtcyAtIG5lZWQgdG8gaW1wbGVtZW50IHZpYSB0aW1lciBhbmQgQWJvcnRDb250cm9sbGVyXG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBzZXR0aW5ncy5kYXRhKVxuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHNldHRpbmdzLmRhdGFba2V5XSk7XG4gICAgICAgIGxldCB1cmw7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0dGluZ3MsICd1cmwnKSkge1xuICAgICAgICAgIHVybCA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB1cmwgPSBhd2FpdCBBcmNHSVNDbGllbnQuZ2V0UG9ydGFsVXJsKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9sZXQgdXJsID0gc2V0dGluZ3MudXJsIHx8IEFyY0dJU0NsaWVudC5nZXRQb3J0YWxVcmwoKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnRhc2tQYXRoKVxuICAgICAgICAgIHVybCA9IHVybCArIHNldHRpbmdzLnRhc2tQYXRoO1xuICAgICAgICBsZXQgcGFyYW1zID0ge307XG4gICAgICAgIC8vIFN0YW5kYXJkIEdlb2dyYXBoeSBxdWVyeSBpcyBoYW5kbGVkIGRpZmZlcmVudGx5XG4gICAgICAgIC8vIE5lZWQgdG8gYWRkIGNoYXJzZXQ9VVRGLTggdG8gQ29udGVudC1UeXBlIHJlcXVlc3QgaGVhZGVyXG4gICAgICAgIGlmIChzZXR0aW5ncy5pc1N0YW5kYXJkR2VvUXVlcnkpIHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgICAgcmVxdWVzdEhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgICAgbGV0IGJvZHlEYXRhID0gJyc7XG4gICAgICAgICAgbGV0IGJvb2xlYW5GaXJzdCA9IHRydWU7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dGluZ3MuZGF0YSkge1xuICAgICAgICAgICAgYm9keURhdGEgKz0gYm9vbGVhbkZpcnN0ID8gJycgOiAnJic7XG4gICAgICAgICAgICBib2R5RGF0YSArPSBrZXkgKyAnPScgKyBlbmNvZGVVUkkoc2V0dGluZ3MuZGF0YVtrZXldKTtcbiAgICAgICAgICAgIGJvb2xlYW5GaXJzdCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IGJvZHlEYXRhLFxuICAgICAgICAgICAgaGVhZGVyczogcmVxdWVzdEhlYWRlcnNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogZm9ybURhdGFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZldGNoKHVybCwgcGFyYW1zKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIHJlc3BvbnNlIGVuZGVkIHdpdGggZXJyb3IuJyk7XG4gICAgICAgICAgLy8gdG9kbzogY2hlY2sgaWYgcmVzcG9uc2UgaXMgc3RyaW5nP1xuICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5kYXRhLmYgPT09ICdiaW4nID8gcmVzcG9uc2UuYmxvYigpIDogcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgLy8gQXJjR0lTIHJldHVybnMgZXJyb3Igd2l0aCBIVFRQIDJ4eCBjb2RlLCBzbyBoYW5kbGUgaXQgaGVyZVxuICAgICAgICAgIHJlc3VsdC5lcnJvciA/IHJlamVjdChyZXN1bHQuZXJyb3IpIDogcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goZXJyID0+IHJlamVjdChlcnIpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBXZWJBcHBTZXR0aW5ncyB7XG4gIHN0YXRpYyBnZXRCdXNpbmVzc0FuYWx5c3RPcmdhbml6YXRpb25hbFNldHRpbmdzKCkge1xuICAgIHJldHVybiBBcmNHSVNDbGllbnQuZ2V0UG9ydGFsUmVzb3VyY2UoJ0J1c2luZXNzQW5hbHlzdF9Pcmdhbml6YXRpb25hbF9TZXR0aW5ncy5qc29uJyk7XG4gIH1cbiAgc3RhdGljIGdldERpc2FibGVkUmVwb3J0cygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBlbXB0eVJlc29sdmVPbkVyciA9IChlcnIpID0+IHtcbiAgICAgICAgcmVzb2x2ZSh7fSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXZWJBcHBTZXR0aW5ncyBlcnJvcicsIGVycik7XG4gICAgICB9O1xuICAgICAgQXJjR0lTQ2xpZW50LmV4ZWN1dGVTZWxmKCkudGhlbigoc2VsZlJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGxldCByb2xlSWQgPSBzZWxmUmVzcG9uc2UudXNlci5yb2xlSWQgfHwgc2VsZlJlc3BvbnNlLnVzZXIucm9sZTtcbiAgICAgICAgV2ViQXBwU2V0dGluZ3MuZ2V0QnVzaW5lc3NBbmFseXN0T3JnYW5pemF0aW9uYWxTZXR0aW5ncygpLnRoZW4oKHNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgbGV0IGRpc2FibGVkUmVwb3J0cyA9IHNldHRpbmdzWyd1c2VyUm9sZXMuZGlzYWJsZWRBcmVhcy5yZXBvcnRzJ107XG4gICAgICAgICAgaWYgKGRpc2FibGVkUmVwb3J0cyAmJiBkaXNhYmxlZFJlcG9ydHNbcm9sZUlkXSlcbiAgICAgICAgICAgIHJlc29sdmUoZGlzYWJsZWRSZXBvcnRzW3JvbGVJZF0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlc29sdmUoe30pO1xuICAgICAgICB9KS5jYXRjaChlbXB0eVJlc29sdmVPbkVycik7XG4gICAgICB9KS5jYXRjaChlbXB0eVJlc29sdmVPbkVycik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgaWRzIG9mIGluZm9ncmFwaGljIHRlbXBsYXRlcyB0aGF0IHVzZXIgYWRkZWQgdG8gXCJNeSBUZW1wbGF0ZXNcIiBmcm9tIFwiR2FsbGVyeVwiXG4gICAqICh1c2VzIG5ldyB2ZXJzaW9uIG9mIHVzZXIgc2V0dGluZ3MpXG4gICAqXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgc3RhdGljIGdldFVzZXJHYWxsZXJ5SW5mb2dyYXBoaWNSZXBvcnRJZHMoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIFdlYkFwcFNldHRpbmdzLl9zZWFyY2hHYWxsZXJ5SW5mb2dyYXBoaWNQcmVmZXJlbmNlc0l0ZW0oKS50aGVuKChnYWxsZXJ5UHJlZkl0ZW0pID0+IHtcbiAgICAgICAgaWYgKCFnYWxsZXJ5UHJlZkl0ZW0pIHtcbiAgICAgICAgICByZWplY3QobnVsbCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc3VtaW5nIFwicHJvcGVydGllc1wiOiB7XCJpbkRhdGFcIjogXCJ0cnVlXCJ9LFxuICAgICAgICBsZXQgaXRlbUlkID0gZ2FsbGVyeVByZWZJdGVtLmlkO1xuICAgICAgICBBcmNHSVNDbGllbnQuZ2V0SXRlbURhdGEoaXRlbUlkKS50aGVuKChpdGVtRGF0YSkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoaXRlbURhdGEgJiZcbiAgICAgICAgICAgIGl0ZW1EYXRhLmRhdGEgJiZcbiAgICAgICAgICAgIGl0ZW1EYXRhLmRhdGEubXlHYWxsZXJ5SW5mb2dyYXBoaWNSZXBvcnRJZHMpO1xuICAgICAgICB9KS5jYXRjaChlcnIgPT4gcmVqZWN0KGVycikpO1xuICAgICAgfSkuY2F0Y2goZXJyID0+IHJlamVjdChlcnIpKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgX3NlYXJjaEdhbGxlcnlJbmZvZ3JhcGhpY1ByZWZlcmVuY2VzSXRlbSgpIHtcbiAgICByZXR1cm4gV2ViQXBwU2V0dGluZ3MuX3NlYXJjaFVzZXJJdGVtKCdlc3JpRmF2b3JpdGVSZXBvcnRUZW1wbGF0ZXMnKTtcbiAgfVxuICBzdGF0aWMgX3NlYXJjaFVzZXJJdGVtKHR5cGVrZXl3b3Jkcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBBcmNHSVNDbGllbnQuZXhlY3V0ZVNlbGYoKS50aGVuKChzZWxmUmVzcG9uc2UpID0+IHtcbiAgICAgICAgbGV0IHVzZXJuYW1lID0gc2VsZlJlc3BvbnNlLnVzZXIudXNlcm5hbWU7XG4gICAgICAgIGxldCBxdWVyeSA9IHtcbiAgICAgICAgICB0eXBlOiAnV2ViIE1hcHBpbmcgQXBwbGljYXRpb24nLFxuICAgICAgICAgIHR5cGVrZXl3b3JkczogdHlwZWtleXdvcmRzLFxuICAgICAgICAgIG93bmVyOiB1c2VybmFtZVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcGFyYW1zID0geyBudW06IDEgfTtcbiAgICAgICAgQXJjR0lTQ2xpZW50LnNlYXJjaEl0ZW1zKHF1ZXJ5LCBwYXJhbXMsIHVuZGVmaW5lZCkudGhlbigoaXRlbXMpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1swXSk7XG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiByZWplY3QoZXJyKSk7XG4gICAgICB9KS5jYXRjaChlcnIgPT4gcmVqZWN0KGVycikpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFNldHRpbmdzSGVscGVyIHtcbiAgc3RhdGljIGdldEVudmlyb25tZW50KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVzb2x2ZShFbnZpcm9ubWVudHMuZ2V0RW52aXJvbm1lbnQoKSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHNldEVudmlyb25tZW50KGVudmlyb25tZW50KSB7XG4gICAgaWYgKGVudmlyb25tZW50ICYmIGVudmlyb25tZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIEVudmlyb25tZW50cy5zZXRFbnZpcm9ubWVudChlbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ2JhLXJlcG9ydHMgZXJyb3I6IHNldEVudmlyb25tZW50KCkgaW52YWxpZCBhcmcnKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldFBvcnRhbEJhc2VVcmwoKSB7XG4gICAgcmV0dXJuIEVudmlyb25tZW50cy5nZXRVcmwoJ2FyY2dpcycpO1xuICB9XG4gIHN0YXRpYyBpc1RydWVTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gIH1cbn1cblxuY2xhc3MgUmVwb3J0VGVtcGxhdGVzTWFuYWdlciB7XG4gIHN0YXRpYyBfY29uZGVuc2VSZXN1bHRzQXJyYXkoZGF0YSkge1xuICAgIC8vIHNpbXBsaWZ5XG4gICAgY29uc3QgYXJyID0gZGF0YS5tYXAoKG9iaikgPT4ge1xuICAgICAgcmV0dXJuIHsgaWQ6IG9iai5pZCwgdGl0bGU6IG9iai50aXRsZSwgZGF0ZTogb2JqLm1vZGlmaWVkIH07XG4gICAgfSk7XG4gICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZXMgYnkgdGl0bGVcbiAgICBjb25zdCBuYW1lcyA9IGFyci5tYXAoKGEpID0+IGEudGl0bGUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFyci5maWx0ZXIoKG9iaiwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBuYW1lcy5pbmRleE9mKG9iai50aXRsZSkgPT0gaW5kZXg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgX2NvbmRlbnNlUmVzdWx0c0FycmF5R0VJbmZvZ3JhcGhpY3MoZGF0YSkge1xuICAgIC8vIHNpbXBsaWZ5XG4gICAgbGV0IGRhdGUsIHQxLCB0MjtcbiAgICBjb25zdCBhcnIgPSBkYXRhLm1hcCgob2JqKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAob2JqLm1ldGFkYXRhLmxhc3RSZXZpc2lvbkRhdGUpIHtcbiAgICAgICAgICB0MiA9IG9iai5tZXRhZGF0YS5sYXN0UmV2aXNpb25EYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoubWV0YWRhdGEuY3JlYXRpb25EYXRlKSB7XG4gICAgICAgICAgdDEgPSBvYmoubWV0YWRhdGEuY3JlYXRpb25EYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0MSkge1xuICAgICAgICAgIGlmICghdDIpIHtcbiAgICAgICAgICAgIGRhdGUgPSB0MTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gKHQyID4gdDEpID8gdDIgOiB0MTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoIChleCkge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVwb3J0VGVtcGxhdGVzTWFuYWdlciBlcnJvcicsIGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGlkOiBvYmouaXRlbUlELCB0aXRsZTogb2JqLm1ldGFkYXRhLnRpdGxlLCBkYXRlOiBkYXRlIH07XG4gICAgfSk7XG4gICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZXMgYnkgdGl0bGVcbiAgICBjb25zdCBuYW1lcyA9IGFyci5tYXAoKGEpID0+IGEudGl0bGUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFyci5maWx0ZXIoKG9iaiwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBuYW1lcy5pbmRleE9mKG9iai50aXRsZSkgPT0gaW5kZXg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogR2V0cyByZXBvcnQgdGVtcGxhdGVzIGZvciBjb3VudHJ5IGlkZW50aWZpZWQgYnkgY291bnRyeSBjb2RlLiBGaW5hbCByZXBvcnRcbiAgICogdGVtcGxhdGVzIHNldCBjb25zaXN0cyBvZiB0ZW1wbGF0ZXMgZnJvbSBHZW9FbnJpY2htZW50IGFuZCBmcm9tIEFHT0xcbiAgICpcbiAgICogQHBhcmFtIGNvdW50cnlDb2RlIE9ubHkgMi1sZXR0ZXIgY291bnRyeUNvZGUhIHRvZG86IGNvbnN1bWUgMy1sZXR0ZXIgYWxzb1xuICAgKiBAcGFyYW0gZnVsbCAgICAgICAgRmxhZyBUcnVlPXJldHVybiBhbGwgZGF0YSwgRmFsc2U9cmV0dXJuIElkICsgVGl0bGUgb25seVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHVua25vd24+fVxuICAgKi9cbiAgc3RhdGljIGdldFJlcG9ydFRlbXBsYXRlcyhjb3VudHJ5Q29kZSwgZnVsbCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCByZXBvcnRUZW1wbGF0ZXMgPSB7XG4gICAgICAgIGdlOiB1bmRlZmluZWQsXG4gICAgICAgIHNoYXJlZDogdW5kZWZpbmVkLFxuICAgICAgICB1c2VyOiB1bmRlZmluZWQsXG4gICAgICAgIGZhdm9yaXRlSWRzOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBBcmNHSVNDbGllbnQuZXhlY3V0ZVNlbGYoKVxuICAgICAgICAudGhlbigoc2VsZlJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGxldCB1c2VybmFtZSA9IHNlbGZSZXNwb25zZS51c2VyLnVzZXJuYW1lO1xuICAgICAgICBQcm9taXNlLmFsbFNldHRsZWQoW1xuICAgICAgICAgIC8vIFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2dldEdFUmVwb3J0VGVtcGxhdGVzKGNvdW50cnlDb2RlKSxcbiAgICAgICAgICBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9nZXRTaGFyZWRDdXN0b21SZXBvcnRUZW1wbGF0ZUl0ZW1zKHVzZXJuYW1lKSxcbiAgICAgICAgICBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9nZXRNeUN1c3RvbVJlcG9ydFRlbXBsYXRlSXRlbXModXNlcm5hbWUpLFxuICAgICAgICAgIFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2dldEZhdm9yaXRlUmVwb3J0c0lkcyh1c2VybmFtZSwgY291bnRyeUNvZGUpXG4gICAgICAgIF0pLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIHJlcG9ydFRlbXBsYXRlcy5nZSA9IHJlc1swXS52YWx1ZSA/IHJlc1swXS52YWx1ZSA6IFtdO1xuICAgICAgICAgIHJlcG9ydFRlbXBsYXRlcy5zaGFyZWQgPSBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9jcmVhdGVSZXBvcnRUZW1wbGF0ZUluZm9zKHJlc1sxXSAmJiByZXNbMV0udmFsdWUgPyByZXNbMV0udmFsdWUgOiBbXSwgY291bnRyeUNvZGUpO1xuICAgICAgICAgIHJlcG9ydFRlbXBsYXRlcy51c2VyID0gUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5fY3JlYXRlUmVwb3J0VGVtcGxhdGVJbmZvcyhyZXNbMl0gJiYgcmVzWzJdLnZhbHVlID8gcmVzWzJdLnZhbHVlIDogW10sIGNvdW50cnlDb2RlKTtcbiAgICAgICAgICByZXBvcnRUZW1wbGF0ZXMuZmF2b3JpdGVJZHMgPVxuICAgICAgICAgICAgcmVzWzNdICYmIHJlc1szXS52YWx1ZSA/IHJlc1szXS52YWx1ZSA6IFtdO1xuICAgICAgICAgIFdlYkFwcFNldHRpbmdzLmdldERpc2FibGVkUmVwb3J0cygpXG4gICAgICAgICAgICAudGhlbigoZGlzYWJsZWRSZXBvcnRzKSA9PiB7XG4gICAgICAgICAgICBsZXQgZ2UgPSByZXBvcnRUZW1wbGF0ZXMuZ2U7XG4gICAgICAgICAgICBsZXQgc2hhcmVkID0gcmVwb3J0VGVtcGxhdGVzLnNoYXJlZDtcbiAgICAgICAgICAgIGlmIChnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlcG9ydFRlbXBsYXRlcy5nZSA9IGdlLmZpbHRlcigodGVtcGxhdGUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWRpc2FibGVkUmVwb3J0c1t0ZW1wbGF0ZS5yZXBvcnRJRF07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoc2hhcmVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXBvcnRUZW1wbGF0ZXMuc2hhcmVkID0gc2hhcmVkLmZpbHRlcigodGVtcGxhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAhZGlzYWJsZWRSZXBvcnRzW3RlbXBsYXRlLnJlcG9ydElELml0ZW1pZF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZnVsbCkge1xuICAgICAgICAgICAgICByZXBvcnRUZW1wbGF0ZXMuZ2UgPSBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9jb25kZW5zZVJlc3VsdHNBcnJheShyZXBvcnRUZW1wbGF0ZXMuZ2UpO1xuICAgICAgICAgICAgICByZXBvcnRUZW1wbGF0ZXMuc2hhcmVkID0gUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5fY29uZGVuc2VSZXN1bHRzQXJyYXkocmVwb3J0VGVtcGxhdGVzLnNoYXJlZCk7XG4gICAgICAgICAgICAgIHJlcG9ydFRlbXBsYXRlcy51c2VyID0gUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5fY29uZGVuc2VSZXN1bHRzQXJyYXkocmVwb3J0VGVtcGxhdGVzLnVzZXIpO1xuICAgICAgICAgICAgICByZXBvcnRUZW1wbGF0ZXMuZmF2b3JpdGVJZHMgPSBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9jb25kZW5zZVJlc3VsdHNBcnJheShyZXBvcnRUZW1wbGF0ZXMuZmF2b3JpdGVJZHMpO1xuICAgICAgICAgICAgICByZXNvbHZlKHJlcG9ydFRlbXBsYXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXBvcnRUZW1wbGF0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gcmVqZWN0KGVycikpO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiByZWplY3QoZXJyKSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIF9nZXRHRVJlcG9ydFRlbXBsYXRlcyhjb3VudHJ5Q29kZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyB0b2RvOiBzdG9yZSB0ZW1wbGF0ZXMgaW4gY291bnRyeSBpbnN0YW5jZTogY291bnRyeS5yZXBvcnRUZW1wbGF0ZXM7XG4gICAgICBsZXQgcmVwb3J0VGVtcGxhdGVzID0gUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5fZ2VSZXBvcnRUZW1wbGF0ZXNDYWNoZVtjb3VudHJ5Q29kZV07XG4gICAgICBpZiAocmVwb3J0VGVtcGxhdGVzKSB7XG4gICAgICAgIHJlc29sdmUocmVwb3J0VGVtcGxhdGVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgR0VDbGllbnQuZXhlY3V0ZSh7IHRhc2tQYXRoOiAnL0dlb0VucmljaG1lbnQvUmVwb3J0cy8nICsgY291bnRyeUNvZGUgfSlcbiAgICAgICAgLnRoZW4oKHJlcG9ydFRlbXBsYXRlc1Jlc3BvbnNlKSA9PiB7XG4gICAgICAgIGxldCByZXBvcnRUZW1wbGF0ZXMgPSByZXBvcnRUZW1wbGF0ZXNSZXNwb25zZS5yZXBvcnRzO1xuICAgICAgICBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9nZVJlcG9ydFRlbXBsYXRlc0NhY2hlW2NvdW50cnlDb2RlXSA9IHJlcG9ydFRlbXBsYXRlcztcbiAgICAgICAgcmVzb2x2ZShyZXBvcnRUZW1wbGF0ZXMpO1xuICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIF9nZXRTaGFyZWRDdXN0b21SZXBvcnRUZW1wbGF0ZUl0ZW1zKHVzZXJuYW1lKSB7XG4gICAgbGV0IHF1ZXJ5ID0gJ3R5cGU6XCJSZXBvcnQgVGVtcGxhdGVcIiAoYWNjZXNzOnNoYXJlZCBPUiBhY2Nlc3M6b3JnKSB0eXBla2V5d29yZHM6KGVzcmlXZWJSZXBvcnQgTk9UIGVzcmlXZWJJbmZvZ3JhcGhpY1JlcG9ydCkgTk9UIG93bmVyOicgK1xuICAgICAgdXNlcm5hbWU7XG4gICAgcmV0dXJuIFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX3NlYXJjaEl0ZW1zKHF1ZXJ5LCBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9yZW1vdmVJbmZvZ3JhcGhpY1RlbXBsYXRlcyk7XG4gIH1cbiAgc3RhdGljIF9nZXRNeUN1c3RvbVJlcG9ydFRlbXBsYXRlSXRlbXModXNlcm5hbWUpIHtcbiAgICBsZXQgcXVlcnkgPSAndHlwZTpcIlJlcG9ydCBUZW1wbGF0ZVwiIHR5cGVrZXl3b3JkczooZXNyaVdlYlJlcG9ydCBOT1QgZXNyaVdlYkluZm9ncmFwaGljUmVwb3J0KSBvd25lcjonICtcbiAgICAgIHVzZXJuYW1lO1xuICAgIHJldHVybiBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9zZWFyY2hJdGVtcyhxdWVyeSwgUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5fcmVtb3ZlSW5mb2dyYXBoaWNUZW1wbGF0ZXMpO1xuICB9XG4gIHN0YXRpYyBfcmVtb3ZlSW5mb2dyYXBoaWNUZW1wbGF0ZXMocmVwb3J0VGVtcGxhdGVJdGVtKSB7XG4gICAgcmV0dXJuICFTZXR0aW5nc0hlbHBlci5pc1RydWVTdHJpbmcocmVwb3J0VGVtcGxhdGVJdGVtLnByb3BlcnRpZXMuaXNHcmFwaGljUmVwb3J0KTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGNvdW50cnlDb2RlIE9ubHkgMi1sZXR0ZXIgY291bnRyeUNvZGUhIHRvZG86IGNvbnN1bWUgMy1sZXR0ZXIgYWxzb1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPHVua25vd24+fVxuICAgKi9cbiAgc3RhdGljIGdldEluZm9ncmFwaGljUmVwb3J0VGVtcGxhdGVJdGVtcyhjb3VudHJ5Q29kZSwgZnVsbCA9IGZhbHNlLCB0b2tlbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgaW5mb2dyYXBoaWNJdGVtcyA9IHtcbiAgICAgICAgcHVibGljOiB1bmRlZmluZWQsXG4gICAgICAgIHNoYXJlZDogdW5kZWZpbmVkLFxuICAgICAgICB1c2VyOiB1bmRlZmluZWQsXG4gICAgICAgIGZhdm9yaXRlSWRzOiB1bmRlZmluZWQsXG4gICAgICAgIGdhbGxlcnk6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlZmF1bHRIaWVyYXJjaHkgPSBhd2FpdCBHRUNsaWVudC5nZXRHRURlZmF1bHRIaWVyYXJjaHkoY291bnRyeUNvZGUsIHRva2VuKTtcbiAgICAgIEFyY0dJU0NsaWVudC5leGVjdXRlU2VsZigpXG4gICAgICAgIC50aGVuKChzZWxmUmVzcG9uc2UpID0+IHtcbiAgICAgICAgbGV0IHVzZXJuYW1lID0gc2VsZlJlc3BvbnNlLnVzZXIudXNlcm5hbWU7XG4gICAgICAgIGxldCBvcmdJZCA9IHNlbGZSZXNwb25zZS51c2VyLm9yZ0lkO1xuICAgICAgICAvLyBsZXQgY291bnRyeUNvZGUgPSBjb3VudHJ5LmlkO1xuICAgICAgICBQcm9taXNlLmFsbFNldHRsZWQoW1xuICAgICAgICAgIFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2dldEVzcmlJbmZvZ3JhcGhpY1JlcG9ydFRlbXBsYXRlSXRlbXMoY291bnRyeUNvZGUpLFxuICAgICAgICAgIFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2dldFNoYXJlZEluZm9ncmFwaGljUmVwb3J0VGVtcGxhdGVJdGVtcyh1c2VybmFtZSwgb3JnSWQpLFxuICAgICAgICAgIFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2dldFVzZXJJbmZvZ3JhcGhpY1JlcG9ydFRlbXBsYXRlSXRlbXModXNlcm5hbWUpLFxuICAgICAgICAgIFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2dldEZhdm9yaXRlUmVwb3J0c0lkcyh1c2VybmFtZSwgY291bnRyeUNvZGUpLFxuICAgICAgICAgIFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2dldEdhbGxlcnlJbmZvZ3JhcGhpY1JlcG9ydFRlbXBsYXRlSXRlbXMoKVxuICAgICAgICAgIC8vXG4gICAgICAgIF0pLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGxldCBieUNvdW50cnlBbmREZWZhdWx0SGllYXJjaHkgPSBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9ieUNvdW50cnlBbmREZWZhdWx0SGllYXJjaHkoY291bnRyeUNvZGUsIGRlZmF1bHRIaWVyYXJjaHkpO1xuICAgICAgICAgIGluZm9ncmFwaGljSXRlbXMucHVibGljID0gcmVzWzBdLnZhbHVlXG4gICAgICAgICAgICA/IHJlc1swXS52YWx1ZS5maWx0ZXIoYnlDb3VudHJ5QW5kRGVmYXVsdEhpZWFyY2h5KVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICBpbmZvZ3JhcGhpY0l0ZW1zLnNoYXJlZCA9IHJlc1sxXS52YWx1ZVxuICAgICAgICAgICAgPyByZXNbMV0udmFsdWUuZmlsdGVyKGJ5Q291bnRyeUFuZERlZmF1bHRIaWVhcmNoeSlcbiAgICAgICAgICAgIDogW107XG4gICAgICAgICAgaW5mb2dyYXBoaWNJdGVtcy51c2VyID0gcmVzWzJdLnZhbHVlXG4gICAgICAgICAgICA/IHJlc1syXS52YWx1ZS5maWx0ZXIoYnlDb3VudHJ5QW5kRGVmYXVsdEhpZWFyY2h5KVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAvLyBpbmZvZ3JhcGhpY0l0ZW1zLnB1YmxpYyA9IGluZm9ncmFwaGljSXRlbXMucHVibGljXG4gICAgICAgICAgLy8gICA/IHJlc1swXS52YWx1ZS5maWx0ZXIgKGJ5RGVmYXVsdEhpZXJhcmNoeSlcbiAgICAgICAgICAvLyAgIDogW11cbiAgICAgICAgICAvLyBpbmZvZ3JhcGhpY0l0ZW1zLnNoYXJlZCA9IHJlc1sxXS52YWx1ZVxuICAgICAgICAgIC8vICAgPyByZXNbMV0udmFsdWUuZmlsdGVyIChieURlZmF1bHRIaWVyYXJjaHkpXG4gICAgICAgICAgLy8gICA6IFtdXG4gICAgICAgICAgLy8gaW5mb2dyYXBoaWNJdGVtcy51c2VyID0gcmVzWzJdLnZhbHVlXG4gICAgICAgICAgLy8gICA/IHJlc1syXS52YWx1ZS5maWx0ZXIgKGJ5RGVmYXVsdEhpZXJhcmNoeSlcbiAgICAgICAgICAvLyAgIDogW11cbiAgICAgICAgICBpbmZvZ3JhcGhpY0l0ZW1zLmZhdm9yaXRlSWRzID0gcmVzWzNdLnZhbHVlID8gcmVzWzNdLnZhbHVlIDogW107XG4gICAgICAgICAgaW5mb2dyYXBoaWNJdGVtcy5nYWxsZXJ5ID0gcmVzWzRdLnZhbHVlXG4gICAgICAgICAgICA/IHJlc1s0XS52YWx1ZS5maWx0ZXIoYnlDb3VudHJ5QW5kRGVmYXVsdEhpZWFyY2h5KVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICBsZXQgdXNlciA9IGluZm9ncmFwaGljSXRlbXMudXNlcjtcbiAgICAgICAgICBpZiAodXNlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBzb3J0IGFscGhhYmV0aWNhbGx5IGJ5IHRpdGxlXG4gICAgICAgICAgICB1c2VyLnNvcnQoZnVuY3Rpb24gKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbTEudGl0bGUubG9jYWxlQ29tcGFyZShpdGVtMi50aXRsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgV2ViQXBwU2V0dGluZ3MuZ2V0RGlzYWJsZWRSZXBvcnRzKClcbiAgICAgICAgICAgIC50aGVuKChkaXNhYmxlZFJlcG9ydHMpID0+IHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJEaXNhYmxlZCA9IGZ1bmN0aW9uIChpZ0l0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFkaXNhYmxlZFJlcG9ydHNbaWdJdGVtLmlkXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcHViID0gaW5mb2dyYXBoaWNJdGVtcy5wdWJsaWM7XG4gICAgICAgICAgICBpZiAocHViICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaW5mb2dyYXBoaWNJdGVtcy5wdWJsaWMgPSBwdWIuZmlsdGVyKGZpbHRlckRpc2FibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaGFyZWQgPSBpbmZvZ3JhcGhpY0l0ZW1zLnNoYXJlZDtcbiAgICAgICAgICAgIGlmIChzaGFyZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpbmZvZ3JhcGhpY0l0ZW1zLnNoYXJlZCA9IHNoYXJlZC5maWx0ZXIoZmlsdGVyRGlzYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdhbGxlcnkgPSBpbmZvZ3JhcGhpY0l0ZW1zLmdhbGxlcnk7XG4gICAgICAgICAgICBpZiAoZ2FsbGVyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGluZm9ncmFwaGljSXRlbXMuZ2FsbGVyeSA9IGdhbGxlcnkuZmlsdGVyKGZpbHRlckRpc2FibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZnVsbCkge1xuICAgICAgICAgICAgICBpbmZvZ3JhcGhpY0l0ZW1zLnB1YmxpYyA9IFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2NvbmRlbnNlUmVzdWx0c0FycmF5R0VJbmZvZ3JhcGhpY3MoaW5mb2dyYXBoaWNJdGVtcy5wdWJsaWMpO1xuICAgICAgICAgICAgICBpbmZvZ3JhcGhpY0l0ZW1zLnNoYXJlZCA9IFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2NvbmRlbnNlUmVzdWx0c0FycmF5KGluZm9ncmFwaGljSXRlbXMuc2hhcmVkKTtcbiAgICAgICAgICAgICAgaW5mb2dyYXBoaWNJdGVtcy51c2VyID0gUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5fY29uZGVuc2VSZXN1bHRzQXJyYXkoaW5mb2dyYXBoaWNJdGVtcy51c2VyKTtcbiAgICAgICAgICAgICAgaW5mb2dyYXBoaWNJdGVtcy5mYXZvcml0ZUlkcyA9IFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2NvbmRlbnNlUmVzdWx0c0FycmF5KGluZm9ncmFwaGljSXRlbXMuZmF2b3JpdGVJZHMpO1xuICAgICAgICAgICAgICBpbmZvZ3JhcGhpY0l0ZW1zLmdhbGxlcnkgPSBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9jb25kZW5zZVJlc3VsdHNBcnJheShpbmZvZ3JhcGhpY0l0ZW1zLmdhbGxlcnkpO1xuICAgICAgICAgICAgICByZXNvbHZlKGluZm9ncmFwaGljSXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoaW5mb2dyYXBoaWNJdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiByZWplY3QoZXJyKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHJlamVjdChlcnIpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBmdW5jdGlvbiB0byBmaWx0ZXIgcG9ydGFsIGl0ZW1zIGFycmF5cyBieSBjb3VudHJ5IGNvZGUgaW4gaXRzIHByb3BlcnRpZXNcbiAgICpcbiAgICogQHBhcmFtIGNvdW50cnlDb2RlIGNvdW50cnkgY29kZSB0aGF0IGl0ZW0ncyAnY291bnRyaWVzJyBhcnJheSBzaG91bGQgY29udGFpblxuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oKik6IGJvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgX2J5Q291bnRyeUFuZERlZmF1bHRIaWVhcmNoeShjb3VudHJ5Q29kZSwgZGVmYXVsdEhpZXJhcmNoeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgbGV0IGNvdW50cmllcyA9IChpdGVtICYmIGl0ZW0ucHJvcGVydGllcyAmJiBpdGVtLnByb3BlcnRpZXMuY291bnRyaWVzLnRvTG93ZXJDYXNlKCkpIHx8IChpdGVtICYmIGl0ZW0ubWV0YWRhdGEgJiYgaXRlbS5tZXRhZGF0YS5jb3VudHJpZXMudG9Mb3dlckNhc2UoKSk7XG4gICAgICBsZXQgaGllcmFyY2hpZXMgPSAoaXRlbSAmJiBpdGVtLnByb3BlcnRpZXMgJiYgaXRlbS5wcm9wZXJ0aWVzLmhpZXJhcmNoeSkgfHwgKGl0ZW0gJiYgaXRlbS5tZXRhZGF0YSAmJiBpdGVtLm1ldGFkYXRhLmhpZXJhcmNoeSk7XG4gICAgICByZXR1cm4gY291bnRyaWVzICYmIGNvdW50cmllcy5pbmRleE9mKGNvdW50cnlDb2RlLnRvTG93ZXJDYXNlKCkpID49IDAgJiYgaGllcmFyY2hpZXMgJiYgaGllcmFyY2hpZXMuaW5kZXhPZihkZWZhdWx0SGllcmFyY2h5KSA+PSAwO1xuICAgIH07XG4gIH1cbiAgLy8gc3RhdGljIF9ieURlZmF1bHRIaWVyYXJjaHkgKGRlZmF1bHRIaWVyYXJjaHk6IHN0cmluZykge1xuICAvLyAgIHJldHVybiBmdW5jdGlvbiAoaXRlbTogYW55KSB7XG4gIC8vICAgICBsZXQgaGllcmFyY2hpZXMgPSBpdGVtICYmIGl0ZW0ucHJvcGVydGllcyAmJiBpdGVtLnByb3BlcnRpZXMuaGllcmFyY2h5XG4gIC8vICAgICBpZiAoaGllcmFyY2hpZXMgJiYgaGllcmFyY2hpZXMuaW5kZXhPZihkZWZhdWx0SGllcmFyY2h5KSA+PSAwKVxuICAvLyAgICAgICByZXR1cm4gdHJ1ZVxuICAvLyAgICAgZWxzZVxuICAvLyAgICAgICByZXR1cm4gZmFsc2VcbiAgLy8gICB9XG4gIC8vIH1cbiAgc3RhdGljIF9nZXRFc3JpSW5mb2dyYXBoaWNSZXBvcnRUZW1wbGF0ZUl0ZW1zKGNvdW50cnlDb2RlKSB7XG4gICAgcmV0dXJuIEdFQ2xpZW50LmV4ZWN1dGUoeyB0YXNrUGF0aDogJy9HZW9FbnJpY2htZW50L0luZm9ncmFwaGljcy9TdGFuZGFyZC8nICsgY291bnRyeUNvZGUgfSlcbiAgICAgIC50aGVuKChyZXBvcnRUZW1wbGF0ZXNSZXNwb25zZSkgPT4ge1xuICAgICAgbGV0IHJlcG9ydFRlbXBsYXRlcyA9IHJlcG9ydFRlbXBsYXRlc1Jlc3BvbnNlLnJlcG9ydHM7XG4gICAgICByZXR1cm4gcmVwb3J0VGVtcGxhdGVzO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBfZ2V0U2hhcmVkSW5mb2dyYXBoaWNSZXBvcnRUZW1wbGF0ZUl0ZW1zKHVzZXJuYW1lLCBvcmdJZCkge1xuICAgIGxldCBxdWVyeSA9ICd0eXBlOlwiUmVwb3J0IFRlbXBsYXRlXCIgJyArXG4gICAgICAnKGFjY2VzczpzaGFyZWQgT1IgYWNjZXNzOm9yZyBPUiAoYWNjZXNzOnB1YmxpYyBBTkQgb3JnaWQ6JyArXG4gICAgICBvcmdJZCArXG4gICAgICAnKSkgJyArXG4gICAgICAnIHR5cGVrZXl3b3Jkczplc3JpV2ViSW5mb2dyYXBoaWNSZXBvcnQgJyArXG4gICAgICAnIE5PVCBvd25lcjonICtcbiAgICAgIHVzZXJuYW1lO1xuICAgIHJldHVybiBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9zZWFyY2hJdGVtcyhxdWVyeSwgUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5faW5mb2dyYXBoaWNGaWx0ZXIpO1xuICB9XG4gIHN0YXRpYyBfZ2V0R2FsbGVyeUluZm9ncmFwaGljUmVwb3J0VGVtcGxhdGVJdGVtcygpIHtcbiAgICBsZXQgcXVlcnkgPSAndHlwZTpcIlJlcG9ydCBUZW1wbGF0ZVwiICcgK1xuICAgICAgJyB0eXBla2V5d29yZHM6ZXNyaVdlYkdhbGxlcnlJbmZvZ3JhcGhpY1JlcG9ydCAnICtcbiAgICAgICcgb3duZXI6KGVzcmlfcmVwb3J0cyBPUiBlc3JpX3JlcG9ydHNfdGVzdCknO1xuICAgIHJldHVybiBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9zZWFyY2hJdGVtcyhxdWVyeSwgUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5faW5mb2dyYXBoaWNGaWx0ZXIsIHtcbiAgICAgIHN0YXJ0OiAxLFxuICAgICAgbnVtOiAxMDAwLFxuICAgICAgc29ydEZpZWxkOiAnbW9kaWZpZWQnLFxuICAgICAgc29ydE9yZGVyOiAnZGVzYycsXG4gICAgICBxOiBxdWVyeVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBfZ2V0VXNlckluZm9ncmFwaGljUmVwb3J0VGVtcGxhdGVJdGVtcyh1c2VybmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcXVlcnkgPSAndHlwZTpcIlJlcG9ydCBUZW1wbGF0ZVwiJyArXG4gICAgICAgICcgdHlwZWtleXdvcmRzOmVzcmlXZWJJbmZvZ3JhcGhpY1JlcG9ydCAnICtcbiAgICAgICAgJyBvd25lcjonICtcbiAgICAgICAgdXNlcm5hbWU7XG4gICAgICBsZXQgdXNlcklnRGVmZXJyZWQgPSBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9zZWFyY2hJdGVtcyhxdWVyeSwgUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5faW5mb2dyYXBoaWNGaWx0ZXIpO1xuICAgICAgbGV0IHVzZXJHYWxsZXJ5SWdEZWZlcnJlZCA9IFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX2dldFVzZXJHYWxsZXJ5SW5mb2dyYXBoaWNSZXBvcnRUZW1wbGF0ZUl0ZW1zKCk7XG4gICAgICBQcm9taXNlLmFsbFNldHRsZWQoW3VzZXJJZ0RlZmVycmVkLCB1c2VyR2FsbGVyeUlnRGVmZXJyZWRdKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgbGV0IHVzZXJJZ0l0ZW1zID0gcmVzWzBdLnZhbHVlID8gcmVzWzBdLnZhbHVlIDogW107XG4gICAgICAgIGxldCB1c2VyR2FsbGVyeUlnSXRlbXMgPSByZXNbMV0udmFsdWUgPyByZXNbMV0udmFsdWUgOiBbXTtcbiAgICAgICAgcmVzb2x2ZSh1c2VySWdJdGVtcy5jb25jYXQodXNlckdhbGxlcnlJZ0l0ZW1zKSk7XG4gICAgICB9LCAocmVqZWN0ZWQpID0+IHtcbiAgICAgICAgcmVqZWN0KHJlamVjdGVkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBfZ2V0RmF2b3JpdGVSZXBvcnRzSWRzKHVzZXJuYW1lLCBjb3VudHJ5SWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHF1ZXJ5ID0gJ3R5cGU6XCJXZWIgTWFwcGluZyBBcHBsaWNhdGlvblwiIHR5cGVrZXl3b3JkczpcIkJBVXNlckRhdGEuRmF2b3JpdGVSZXBvcnRzXCIgb3duZXI6JyArXG4gICAgICAgIHVzZXJuYW1lO1xuICAgICAgUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5fc2VhcmNoSXRlbXMocXVlcnksIG51bGwpXG4gICAgICAgIC50aGVuKChmYXZvcml0ZVJlcG9ydHNJdGVtcykgPT4ge1xuICAgICAgICBsZXQgZmF2UmVwb3J0c0l0ZW0gPSBmYXZvcml0ZVJlcG9ydHNJdGVtcyAmJiBmYXZvcml0ZVJlcG9ydHNJdGVtc1swXTtcbiAgICAgICAgaWYgKCFmYXZSZXBvcnRzSXRlbSkge1xuICAgICAgICAgIHJlc29sdmUoW10pOyAvL25vIGZhdm9yaXRlIHJlcG9ydHNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgQXJjR0lTQ2xpZW50LmdldEl0ZW1EYXRhKGZhdlJlcG9ydHNJdGVtLmlkKVxuICAgICAgICAgIC50aGVuKChpdGVtRGF0YSkgPT4ge1xuICAgICAgICAgIGlmICghaXRlbURhdGEpIHtcbiAgICAgICAgICAgIHJlc29sdmUoW10pOyAvL25vIGZhdm9yaXRlIHJlcG9ydHNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGZhdlJlcG9ydHNJbmZvcyA9IGl0ZW1EYXRhLmRhdGEgJiYgaXRlbURhdGEuZGF0YVsnZmF2b3JpdGVzJyArIGNvdW50cnlJZF07XG4gICAgICAgICAgaWYgKCFmYXZSZXBvcnRzSW5mb3MpIHtcbiAgICAgICAgICAgIHJlc29sdmUoW10pOyAvL25vIGZhdm9yaXRlIHJlcG9ydHNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJldCA9IGZhdlJlcG9ydHNJbmZvcy5tYXAoZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvLnJlcG9ydElEO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc29sdmUocmV0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4gcmVqZWN0KGVycikpO1xuICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHJlamVjdChlcnIpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBpbmZvZ3JhcGhpYyB0ZW1wbGF0ZXMgdGhhdCB1c2VyIGFkZGVkIHRvIFwiTXkgVGVtcGxhdGVzXCIgZnJvbSBcIkdhbGxlcnlcIlxuICAgKlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBfZ2V0VXNlckdhbGxlcnlJbmZvZ3JhcGhpY1JlcG9ydFRlbXBsYXRlSXRlbXMoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIFdlYkFwcFNldHRpbmdzLmdldFVzZXJHYWxsZXJ5SW5mb2dyYXBoaWNSZXBvcnRJZHMoKVxuICAgICAgICAudGhlbigocmVwb3J0SWRzKSA9PiB7XG4gICAgICAgIGlmICghcmVwb3J0SWRzIHx8ICFyZXBvcnRJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBxdWVyeSA9IHJlcG9ydElkcy5tYXAoKGlkKSA9PiAnaWQ6JyArIGlkKS5qb2luKCcgT1IgJyk7XG4gICAgICAgIFJlcG9ydFRlbXBsYXRlc01hbmFnZXIuX3NlYXJjaEl0ZW1zKHF1ZXJ5LCBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLl9pbmZvZ3JhcGhpY0ZpbHRlcilcbiAgICAgICAgICAudGhlbigoaXRlbXMpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGl0ZW1zKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4gcmVqZWN0KGVycikpO1xuICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHJlamVjdChlcnIpKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgX3NlYXJjaEl0ZW1zKHF1ZXJ5LCByZXN1bHRzRmlsdGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBwYXJhbXMgPSBvcHRpb25zIHx8IHtcbiAgICAgICAgc3RhcnQ6IDEsXG4gICAgICAgIG51bTogMTAwMCxcbiAgICAgICAgc29ydEZpZWxkOiAndGl0bGUnLFxuICAgICAgICBzb3J0T3JkZXI6ICdhc2MnLFxuICAgICAgICBxOiBxdWVyeVxuICAgICAgfTtcbiAgICAgIEFyY0dJU0NsaWVudC5zZWFyY2hBbGxJdGVtcyh7fSwgcGFyYW1zKVxuICAgICAgICAudGhlbigocmVzdWx0SXRlbXMpID0+IHtcbiAgICAgICAgbGV0IHJlcyA9IHJlc3VsdHNGaWx0ZXJcbiAgICAgICAgICA/IHJlc3VsdEl0ZW1zLmZpbHRlcihyZXN1bHRzRmlsdGVyKVxuICAgICAgICAgIDogcmVzdWx0SXRlbXM7XG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiByZWplY3QoZXJyKSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIF9jcmVhdGVSZXBvcnRUZW1wbGF0ZUluZm9zKHBvcnRhbEl0ZW1zLCBjb3VudHJ5Q29kZSkge1xuICAgIGxldCB0ZW1wbGF0ZXMgPSBbXTtcbiAgICBwb3J0YWxJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBsZXQgcHJvcGVydGllcyA9IGl0ZW0ucHJvcGVydGllcztcbiAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGxldCBjb3VudHJpZXMgPSBwcm9wZXJ0aWVzLmNvdW50cmllcztcbiAgICAgICAgaWYgKFNldHRpbmdzSGVscGVyLmlzVHJ1ZVN0cmluZyhwcm9wZXJ0aWVzLmlzQ29tcGFyaXNvblJlcG9ydCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50cmllcyAmJiBjb3VudHJpZXMuaW5kZXhPZihjb3VudHJ5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgbGV0IHJ0aSA9IHtcbiAgICAgICAgICAgIHJlcG9ydElEOiB7IGl0ZW1pZDogaXRlbS5pZCB9LFxuICAgICAgICAgICAgZm9ybWF0czogcHJvcGVydGllcy5mb3JtYXRzICYmIHByb3BlcnRpZXMuZm9ybWF0cy5zcGxpdCgnLCcpLFxuICAgICAgICAgICAgaGVhZGVyczogW10sXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICBhdXRob3I6IHByb3BlcnRpZXMuYXV0aG9yLFxuICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBbXSxcbiAgICAgICAgICAgICAgY291bnRyaWVzOiBjb3VudHJpZXMsXG4gICAgICAgICAgICAgIGNvdmVyYWdlOiBwcm9wZXJ0aWVzLmNvdmVyYWdlLFxuICAgICAgICAgICAgICBoaWVyYXJjaHk6IEdFQ2xpZW50LmdldEdFRGVmYXVsdEhpZXJhcmNoeShjb3VudHJ5Q29kZSksXG4gICAgICAgICAgICAgIGtleXdvcmRzOiBwcm9wZXJ0aWVzLmtleXdvcmRzLFxuICAgICAgICAgICAgICBvd25lcjogaXRlbS5vd25lcixcbiAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXG4gICAgICAgICAgICAgIHR5cGU6IHByb3BlcnRpZXMudHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGVtcGxhdGVzLnB1c2gocnRpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0ZW1wbGF0ZXM7XG4gIH1cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGZvciBBcnJheS5maWx0ZXIgdGhhdCByZW1vdmVzIG5vbi1pbmZvZ3JhcGhpYyB0ZW1wbGF0ZSBpdGVtc1xuICAgKlxuICAgKiBMZWZ0IGhlcmUgdG8gc3VwcG9ydCBmaWx0ZXJpbmcgb3V0IHNvbWUgbGVnYWN5IGluZm9ncmFwaGljIHJlcG9ydHMgdGhhdFxuICAgKiB3ZXJlIG5vdCB1cGRhdGVkIG9uIHBvcnRhbCBmb3Igc29tZSByZWFzb25zLlxuICAgKiBAcGFyYW0gcmVwb3J0VGVtcGxhdGVJdGVtXG4gICAqIEByZXR1cm4geyp8Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBfaW5mb2dyYXBoaWNGaWx0ZXIocmVwb3J0VGVtcGxhdGVJdGVtKSB7XG4gICAgbGV0IHAgPSByZXBvcnRUZW1wbGF0ZUl0ZW0ucHJvcGVydGllcztcbiAgICAvL2xlYXZlIG9yZGluYXJ5IGluZm9ncmFwaGljLCBidXQgcmVtb3ZlIHNpbmdsZSBpbmZvZ3JhcGhpY3MsIGhpZGRlbiBhbmQgYmxhbmsgcmVwb3J0cyBpZiBhbnlcbiAgICAvL2Jvb2xlYW4gcHJvcGVydGllcyBtYXkgYmUgc3RvcmVkIGFzIHN0cmluZ3NcbiAgICByZXR1cm4gKFNldHRpbmdzSGVscGVyLmlzVHJ1ZVN0cmluZyhwLmlzR3JhcGhpY1JlcG9ydCkgJiZcbiAgICAgICFTZXR0aW5nc0hlbHBlci5pc1RydWVTdHJpbmcocC5pc1NpbmdsZUluZm9ncmFwaGljKSAmJlxuICAgICAgIVNldHRpbmdzSGVscGVyLmlzVHJ1ZVN0cmluZyhwLmlzSGlkZGVuKSAmJlxuICAgICAgIVNldHRpbmdzSGVscGVyLmlzVHJ1ZVN0cmluZyhwLmlzQmxhbmspKTtcbiAgfVxufVxuUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5fZ2VSZXBvcnRUZW1wbGF0ZXNDYWNoZSA9IHt9O1xuXG5jbGFzcyBHRUNsaWVudCB7XG4gIHN0YXRpYyBhc3luYyBnZXRJbmZvZ3JhcGhpY1RlbXBsYXRlc0xpc3QoY291bnRyeUNvZGUsIGZ1bGwgPSBmYWxzZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYXdhaXQgUmVwb3J0VGVtcGxhdGVzTWFuYWdlci5nZXRJbmZvZ3JhcGhpY1JlcG9ydFRlbXBsYXRlSXRlbXMoY291bnRyeUNvZGUgfHwgJ1VTJywgZnVsbCwgdG9rZW4pO1xuICB9XG4gIHN0YXRpYyBhc3luYyBnZXRDbGFzc2ljUmVwb3J0c1RlbXBsYXRlc0xpc3QoY291bnRyeUNvZGUsIGZ1bGwgPSBmYWxzZSkge1xuICAgIHJldHVybiBhd2FpdCBSZXBvcnRUZW1wbGF0ZXNNYW5hZ2VyLmdldFJlcG9ydFRlbXBsYXRlcyhjb3VudHJ5Q29kZSB8fCAnVVMnLCBmdWxsKTtcbiAgfVxuICBzdGF0aWMgZXhlY3V0ZShnZVBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZ2VvZW5yaWNobWVudFVybCA9IEFyY0dJU0NsaWVudC5nZXRHZW9lbnJpY2htZW50VXJsKCk7XG4gICAgICAvLyBkbyBkZWVwIGNvcHksIGluc3RlYWQgb2YgJGouZXh0ZW5kKHt9LCBwYXJhbXMpXG4gICAgICB2YXIgX2dlUGFyYW1zID0gZ2VQYXJhbWV0ZXJzID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnZVBhcmFtZXRlcnMpKSA6IHt9O1xuICAgICAgaWYgKCFfZ2VQYXJhbXMuZGF0YSlcbiAgICAgICAgX2dlUGFyYW1zLmRhdGEgPSB7fTtcbiAgICAgIF9nZVBhcmFtcy5kYXRhLmZvclN0b3JhZ2UgPSBmYWxzZTtcbiAgICAgIC8vIHRvZG86IGltcGxlbWVudCBxdWV1ZSBmb3IgdGhpcyByZXF1ZXN0cywga2V5IGlzIF9nZVBhcmFtcy50YXNrUGF0aCBvciBoZXhfc2hhMShnZVBhcmFtZXRlcnMpXG4gICAgICBBcmNHSVNDbGllbnQuZXhlY3V0ZVJlcXVlc3Qoe1xuICAgICAgICB1cmw6IGdlb2VucmljaG1lbnRVcmwgKyBfZ2VQYXJhbXMudGFza1BhdGgsXG4gICAgICAgIGRhdGE6IF9nZVBhcmFtcy5kYXRhLFxuICAgICAgICBpc1N0YW5kYXJkR2VvUXVlcnk6IF9nZVBhcmFtcy5pc1N0YW5kYXJkR2VvUXVlcnlcbiAgICAgIH0pLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlUmVwb3J0KGNyZWF0ZVJlcG9ydFBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBnZVVybCA9IEFyY0dJU0NsaWVudC5nZXRHZW9lbnJpY2htZW50VXJsKCk7XG4gICAgICBsZXQgY3JlYXRlUmVwb3J0VXJsID0gZ2VVcmwudG9TdHJpbmcoKSArICcvR2VvZW5yaWNobWVudC9DcmVhdGVSZXBvcnQnO1xuICAgICAgQXJjR0lTQ2xpZW50LmV4ZWN1dGVSZXF1ZXN0KHtcbiAgICAgICAgdXJsOiBjcmVhdGVSZXBvcnRVcmwsXG4gICAgICAgIGRhdGE6IGNyZWF0ZVJlcG9ydFBhcmFtc1xuICAgICAgfSkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBzdGFuZGFyZCBnZW9ncmFwaHkgc2VhcmNoIGJ5IHRleHR1YWwgZ2VvZ3JhcGh5IHF1ZXJ5LlxuICAgKlxuICAgKiBOb3RlOiBiZSBwYXRpZW50IHdoaWxlIHNldHRpbmcgcmVxdWVzdCBvcHRpb25zLiBgc291cmNlQ291bnRyeWAsIGBnZW9ncmFwaHlMYXllcnNgLCBgb3B0aW9uYWxDb3VudHJ5SGllcmFyY2h5YFxuICAgKiBwYXJhbXMgYXJlIGNvdXBsZWQgYW5kIGNvdW50cnktc3BlY2lmaWMsIHNvIHVwZGF0ZSBpdCBzaW11bHRhbmVvdXNseVxuICAgKlxuICAgKiBAcGFyYW0gZ2VvZ3JhcGh5UXVlcnkgU3RyaW5nIHRvIHNlYXJjaCBmb3JcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byByZWZpbmUgc2VhcmNoOlxuICAgKiAgICBmZWF0dXJlTGltaXRcbiAgICogICAgZ2VvZ3JhcGh5TGF5ZXJzXG4gICAqICAgIHVzZUZ1enp5U2VhcmNoXG4gICAqICAgIHNvdXJjZUNvdW50cnlcbiAgICogICAgb3B0aW9uYWxDb3VudHJ5SGllcmFyY2h5XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmFyY2dpcy5jb20vcmVzdC9nZW9lbnJpY2htZW50L2FwaS1yZWZlcmVuY2Uvc3RhbmRhcmQtZ2VvZ3JhcGh5LXF1ZXJ5Lmh0bVxuICAgKi9cbiAgc3RhdGljIHNlYXJjaFN0ZEdlb2dyYXBoeShnZW9ncmFwaHlRdWVyeSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIWdlb2dyYXBoeVF1ZXJ5IHx8ICFnZW9ncmFwaHlRdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBkZWZhdWx0SGllcmFyY2h5ID0gYXdhaXQgdGhpcy5nZXRHRURlZmF1bHRIaWVyYXJjaHkob3B0aW9ucz8uc291cmNlQ291bnRyeSB8fCAnVVMnLCBvcHRpb25zPy50b2tlbik7XG4gICAgICBsZXQgZ2VQYXJhbXMgPSB7XG4gICAgICAgIGdlb2dyYXBoeVF1ZXJ5OiBnZW9ncmFwaHlRdWVyeSxcbiAgICAgICAgZmVhdHVyZUxpbWl0OiBvcHRpb25zPy5mZWF0dXJlTGltaXQgfHwgMTAsXG4gICAgICAgIGdlb2dyYXBoeUxheWVyczogb3B0aW9ucz8uZ2VvZ3JhcGh5TGF5ZXJzIHx8IFsnVVMuU3RhdGVzJywgJ1VTLkNvdW50aWVzJywgJ1VTLlBsYWNlcyddLFxuICAgICAgICB1c2VGdXp6eVNlYXJjaDogb3B0aW9ucz8udXNlRnV6enlTZWFyY2gsXG4gICAgICAgIHNvdXJjZUNvdW50cnk6IG9wdGlvbnM/LnNvdXJjZUNvdW50cnkgfHwgJ1VTJyxcbiAgICAgICAgbGFuZ0NvZGU6IG9wdGlvbnM/LmxhbmdDb2RlIHx8IFwiZW4tdXNcIixcbiAgICAgICAgb3B0aW9uYWxDb3VudHJ5SGllcmFyY2h5OiBvcHRpb25zPy5vcHRpb25hbENvdW50cnlIaWVyYXJjaHkgfHwgZGVmYXVsdEhpZXJhcmNoeVxuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhbmRhcmRHZW9ncmFwaHlRdWVyeShnZVBhcmFtcylcbiAgICAgICAgLnRoZW4oZmVhdHVyZXMgPT4gcmVzb2x2ZShmZWF0dXJlcykpXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiByZWplY3QoZXJyb3IpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBzdGFuZGFyZCBnZW9ncmFwaHkgYnkgbGF5ZXIgaWQsIGZlYXR1cmUgaWQgYW5kIHNvbWUgb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIGxheWVySWQgSWQgb2YgbGF5ZXIgdG8gbG9vayB1cCBpblxuICAgKiBAcGFyYW0gZmVhdHVyZUlkIElkIG9mIGZlYXR1cmUgdG8gcmVxdWVzdFxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIHJlZmluZSBxdWVyeTpcbiAgICogICAgZmVhdHVyZUxpbWl0XG4gICAqICAgIHJldHVybkdlb21ldHJ5XG4gICAqICAgIGdlbmVyYWxpemF0aW9uTGV2ZWxcbiAgICogICAgc291cmNlQ291bnRyeVxuICAgKiAgICBsYW5nQ29kZVxuICAgKiAgICBvcHRpb25hbENvdW50cnlIaWVyYXJjaHlcbiAgICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuYXJjZ2lzLmNvbS9yZXN0L2dlb2VucmljaG1lbnQvYXBpLXJlZmVyZW5jZS9zdGFuZGFyZC1nZW9ncmFwaHktcXVlcnkuaHRtXG4gICAqL1xuICBzdGF0aWMgcmVxdWVzdFN0ZEdlb2dyYXBoeShsYXllcklkLCBmZWF0dXJlSWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGRlZmF1bHRIaWVyYXJjaHkgPSBhd2FpdCB0aGlzLmdldEdFRGVmYXVsdEhpZXJhcmNoeShvcHRpb25zPy5zb3VyY2VDb3VudHJ5IHx8ICdVUycsIG9wdGlvbnM/LnRva2VuKTtcbiAgICAgIGxldCBnZVBhcmFtcyA9IHtcbiAgICAgICAgZ2VvZ3JhcGh5TGF5ZXJzOiBbbGF5ZXJJZF0sXG4gICAgICAgIGZlYXR1cmVMaW1pdDogb3B0aW9ucz8uZmVhdHVyZUxpbWl0IHx8IDEsXG4gICAgICAgIHJldHVybkdlb21ldHJ5OiBvcHRpb25zPy5yZXR1cm5HZW9tZXRyeSxcbiAgICAgICAgLy8gb3V0U1I6IEpTT04uc3RyaW5naWZ5KHt3a2lkOiAxMDIxMDAsIGxhdGVzdFdraWQ6IDM4NTd9KSxcbiAgICAgICAgZ2VuZXJhbGl6YXRpb25MZXZlbDogb3B0aW9ucz8uZ2VuZXJhbGl6YXRpb25MZXZlbCB8fCAwLFxuICAgICAgICBnZW9ncmFwaHlJRHM6IFtmZWF0dXJlSWRdLFxuICAgICAgICBzb3VyY2VDb3VudHJ5OiBvcHRpb25zPy5zb3VyY2VDb3VudHJ5IHx8ICdVUycsXG4gICAgICAgIGxhbmdDb2RlOiBvcHRpb25zPy5sYW5nQ29kZSB8fCBcImVuLXVzXCIsXG4gICAgICAgIG9wdGlvbmFsQ291bnRyeUhpZXJhcmNoeTogb3B0aW9ucz8ub3B0aW9uYWxDb3VudHJ5SGllcmFyY2h5IHx8IGRlZmF1bHRIaWVyYXJjaHlcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YW5kYXJkR2VvZ3JhcGh5UXVlcnkoZ2VQYXJhbXMpXG4gICAgICAgIC50aGVuKGZlYXR1cmVzID0+IHJlc29sdmUoZmVhdHVyZXMpKVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4gcmVqZWN0KGVycm9yKSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHN0YW5kYXJkR2VvZ3JhcGh5UXVlcnkocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBnZVBhcmFtcyA9IHtcbiAgICAgICAgZGF0YTogcGFyYW1zLFxuICAgICAgICBpc1N0YW5kYXJkR2VvUXVlcnk6IHRydWUsXG4gICAgICAgIHRhc2tQYXRoOiAnL1N0YW5kYXJkR2VvZ3JhcGh5UXVlcnkvZXhlY3V0ZSdcbiAgICAgIH07XG4gICAgICBHRUNsaWVudC5leGVjdXRlKGdlUGFyYW1zKS50aGVuKChxdWVyeVJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBxdWVyeVJlc3BvbnNlICYmXG4gICAgICAgICAgcXVlcnlSZXNwb25zZS5yZXN1bHRzICYmXG4gICAgICAgICAgcXVlcnlSZXNwb25zZS5yZXN1bHRzLmxlbmd0aCAmJlxuICAgICAgICAgIHF1ZXJ5UmVzcG9uc2UucmVzdWx0c1swXTtcbiAgICAgICAgbGV0IGZlYXR1cmVzID0gcmVzdWx0ICYmXG4gICAgICAgICAgcmVzdWx0LnZhbHVlICYmXG4gICAgICAgICAgcmVzdWx0LnZhbHVlLmZlYXR1cmVzO1xuICAgICAgICBpZiAoZmVhdHVyZXMpXG4gICAgICAgICAgcmVzb2x2ZShmZWF0dXJlcyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2VzID0gcXVlcnlSZXNwb25zZSAmJlxuICAgICAgICAgICAgcXVlcnlSZXNwb25zZS5tZXNzYWdlcyAmJlxuICAgICAgICAgICAgcXVlcnlSZXNwb25zZS5tZXNzYWdlcy5sZW5ndGg7XG4gICAgICAgICAgcmVqZWN0KGVycm9yTWVzc2FnZXMpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0U3RvcmVkRGVmYXVsdEhpZXJhcmNoeShjb3VudHJ5KSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgbGV0IGQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShHRUNsaWVudC5fZGVmYXVsdEhpZXJhcmNoeVN0b3JhZ2VOYW1lKTtcbiAgICAgIGlmIChkICYmIFV0aWxzLmhhc1RleHQoZCkpIHtcbiAgICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UoZCk7XG4gICAgICAgIHJlc3VsdCA9IG9ialtjb3VudHJ5XTtcbiAgICAgICAgLy8gc2F2ZSBjdXJyZW50IGRlZmF1bHRzIGluIHN0YXRpYyBpbnN0YW5jZVxuICAgICAgICBHRUNsaWVudC5fZGVmYXVsdEhpZXJhcmNoaWVzID0gb2JqO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKiAgc2V0U3RvcmVkRGVmYXVsdEhpZXJhcmNoeVxuICAgKiAgICAgICBTdG9yZXMgYSBkZWZhdWx0IGhpZXJhcmNoeSBuYW1lIGZvciBhIGdpdmVuIGNvdW50cnlcbiAgICpcbiAgICogU3RvcmVkIG9iamVjdCBpcyBpbiB0aGlzIGZvcm1hdDpcbiAgICogIHtcbiAgICogICAgXCJVU1wiIDogXCJjZW5zdXMyMDIwXCIsXG4gICAqICAgIFwiRlJcIiA6IFwiRlJBX0VzcmlGcmFuY2VcIlxuICAgKiAgfVxuICAgKiBAcGFyYW0gY291bnRyeSAtIGlkZW50aWZpZXIgKGV4OiAnVVMnKVxuICAgKiBAcGFyYW0gbmFtZSAgICAtIGRlZmF1bHQgaGllcmFyY2h5IG5hbWUgZm9yIHRoZSBjb3VudHJ5XG4gICAqL1xuICBzdGF0aWMgc2V0U3RvcmVkRGVmYXVsdEhpZXJhcmNoeShjb3VudHJ5LCBuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIEdFQ2xpZW50LmdldFN0b3JlZERlZmF1bHRIaWVyYXJjaHkoY291bnRyeSk7XG4gICAgICBpZiAoIUdFQ2xpZW50Ll9kZWZhdWx0SGllcmFyY2hpZXMpXG4gICAgICAgIEdFQ2xpZW50Ll9kZWZhdWx0SGllcmFyY2hpZXMgPSB7fTtcbiAgICAgIEdFQ2xpZW50Ll9kZWZhdWx0SGllcmFyY2hpZXNbY291bnRyeV0gPSBuYW1lO1xuICAgICAgaWYgKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oR0VDbGllbnQuX2RlZmF1bHRIaWVyYXJjaHlTdG9yYWdlTmFtZSwgSlNPTi5zdHJpbmdpZnkoR0VDbGllbnQuX2RlZmF1bHRIaWVyYXJjaGllcykpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdHRUNsaWVudCBlcnJvcicsIGV4KTtcbiAgICB9XG4gIH1cbiAgLy8gICAvKipcbiAgLy8gICAgICAqIEdldHMgaGllcmFyY2h5IGZvciBzcGVjaWZpZWQgY291bnRyeTogZWl0aGVyIHNldCBieSBpZCBpbiBhcHAgc2V0dGluZ3Mgb3IgZGVmYXVsdCBvbmVcbiAgLy8gICAgICAqXG4gIC8vICAgICAgKiBAcGFyYW0gY291bnRyeUNvZGUgMi1sZXR0ZXIgb3IgMy1sZXR0ZXIgY291bnRyeSBjb2RlXG4gIC8vICAgICAgKiBAcmV0dXJucyB7Kn0gSGllcmFyY2h5IGZvciBzcGVjaWZpZWQgY291bnRyeSAobm90IG51bGwpXG4gIC8vICAgICAgKi9cbiAgLy8gICBnZXRQcmVmZXJyZWRIaWVyYXJjaHk6IGZ1bmN0aW9uIChjb3VudHJ5Q29kZSkge1xuICAvLyAgICAgdmFyIGNvdW50cnlEYXRhID0gQkEuQ291bnRyeURhdGFNYW5hZ2VyLl9jb3VudHJ5RGF0YTtcbiAgLy8gICAgIEJBLmxvZy5pbmZvKFwiY291bnRyeURhdGE6IFwiLCBjb3VudHJ5RGF0YSk7XG4gIC8vICAgICB2YXIgY291bnRyeSA9IGNvdW50cnlEYXRhW2NvdW50cnlDb2RlXTtcbiAgLy8gICAgIEJBLmxvZy5pbmZvKFwiY291bnRyeUNvZGU6IFwiLCBjb3VudHJ5Q29kZSk7XG4gIC8vICAgICBpZiAoY291bnRyeS5oaWVyYXJjaGllcyl7XG4gIC8vICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBjb3VudHJ5LmhpZXJhcmNoaWVzLmxlbmd0aDsgaSsrKXtcbiAgLy8gICAgICAgICAgICAgdmFyIGggPSBjb3VudHJ5LmhpZXJhcmNoaWVzW2ldO1xuICAvLyAgICAgICAgICAgICBCQS5sb2cuaW5mbyhcImhpZXJhcmNoeVtpXTogXCIsIGgpO1xuICAvLyAgICAgICAgICAgICBpZihoLmRlZmF1bHQpe1xuICAvLyAgICAgICAgICAgICAgICAgQkEubG9nLmluZm8oXCJkZWZhdWx0IGhpZXJhcmNoeTogXCIsICBoKTtcbiAgLy8gICAgICAgICAgICAgICAgIC8vIHJldHVybiBpZiBkZWZhdWx0IGhpZXJhcmNoeSBpcyB0cnVlXG4gIC8vICAgICAgICAgICAgICAgICByZXR1cm4gaDtcbiAgLy8gICAgICAgICAgICAgfVxuICAvLyAgICAgICAgIH1cbiAgLy8gICAgICAgICBCQS5sb2cuaW5mbyhcImRlZmF1bHQgaGllcmFyY2h5IG5vdCBmb3VuZCB1c2luZzogXCIsIGgpO1xuICAvLyAgICAgICAgIHJldHVybiBjb3VudHJ5LmhpZXJhcmNoaWVzWzBdO1xuICAvLyAgICAgICAgIC8vIHJldHVybiBmaXJzdCByZXN1bHQgaWYgbm8gZGVmYXVsdCBpcyBmb3VuZFxuICAvLyAgICAgfVxuICAvLyAgICAgcmV0dXJuIGZhbHNlO1xuICAvLyB9LFxuICAvKiogIGdldEdFRGVmYXVsdEhpZXJhcmNoeVxuICAgKiAgICAgIFJldHVybnMgdGhlIGRlZmF1bHQgaGllcmFyY2h5IG5hbWUgZm9yIHRoZSBnaXZlbiBjb3VudHJ5LlxuICAgKiAgICAgIFRoZSBkZWZhdWx0IG1heSBiZSByZXR1cm5lZCBmcm9tIGEgbG9jYWxTdG9yYWdlIHZhbHVlXG4gICAqICAgICAgc2F2ZWQgcHJldmlvdXNseSB1c2luZyBHRUNsaWVudC5zZXRTdG9yZWREZWZhdWx0SGllcmFyY2h5KCkgb3JcbiAgICogICAgICByZXF1ZXN0ZWQgZnJvbSBHRS5cbiAgICpcbiAgICogICAgICBJbiB0aGUgY2FzZSB0aGUgZGVmYXVsdCBpcyBmZXRjaGVkIGZyb20gR0UsIHRoYXQgZGVmYXVsdFxuICAgKiAgICAgIHdpbGwgYmUgY2FjaGVkIGluIGxvY2FsIHN0b3JhZ2VcbiAgICpcbiAgICogQHBhcmFtIGNvdW50cnkgLSBpZGVudGlmaWVyIChleDogJ1VTJylcbiAgICogQHBhcmFtIHRva2VuIC0gYXV0aCB0b2tlbiAob3B0aW9uYWwpXG4gICAqL1xuICBzdGF0aWMgZ2V0R0VEZWZhdWx0SGllcmFyY2h5KGNvdW50cnksIHRva2VuKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBjID0gJ1VTJzsgLy8gZGVmYXVsdFxuICAgICAgaWYgKGNvdW50cnkgJiYgVXRpbHMuaGFzVGV4dChjb3VudHJ5KSlcbiAgICAgICAgYyA9IGNvdW50cnk7XG4gICAgICAvLyBwdWxsIGRlZmF1bHQgaGllcmFyY2h5IGZyb20gbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgbGV0IGRlZmF1bHRIaWVyYXJjaHkgPSBHRUNsaWVudC5nZXRTdG9yZWREZWZhdWx0SGllcmFyY2h5KGMpO1xuICAgICAgaWYgKGRlZmF1bHRIaWVyYXJjaHkgJiYgVXRpbHMuaGFzVGV4dChkZWZhdWx0SGllcmFyY2h5KSlcbiAgICAgICAgcmVzb2x2ZShkZWZhdWx0SGllcmFyY2h5KTtcbiAgICAgIC8vIE11c3QgcmVxdWVzdCBkZWZhdWx0IGZyb20gR0Ugc2VydmVyXG4gICAgICAvLyByZXF1ZXN0PSBodHRwczovL2dlb2VucmljaC5hcmNnaXMuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1dvcmxkL2dlb2VucmljaG1lbnRzZXJ2ZXIvR2VvZW5yaWNobWVudC9Db3VudHJpZXMvVVM/Zj1wanNvblxuICAgICAgY29uc3QgZ2VVcmwgPSBBcmNHSVNDbGllbnQuZ2V0R2VvZW5yaWNobWVudFVybCgpO1xuICAgICAgbGV0IHVybCA9IGdlVXJsLnRvU3RyaW5nKCkgKyAnL0dlb2VucmljaG1lbnQvQ291bnRyaWVzLycgKyBjb3VudHJ5ICsgJz9mPXBqc29uJztcbiAgICAgIGNvbnN0IGRhdGEgPSB0b2tlbiA/IHtcbiAgICAgICAgYXBwSUQ6IEdFQ2xpZW50LmFwcElELFxuICAgICAgICB0b2tlbjogdG9rZW5cbiAgICAgIH0gOlxuICAgICAgICB7XG4gICAgICAgICAgYXBwSUQ6IEdFQ2xpZW50LmFwcElEXG4gICAgICAgIH07XG4gICAgICBBcmNHSVNDbGllbnQuZXhlY3V0ZVJlcXVlc3Qoe1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZGF0YVxuICAgICAgfSkudGhlbigoZSkgPT4ge1xuICAgICAgICBsZXQgZGVmID0gJ1VTJztcbiAgICAgICAgbGV0IGFyciA9IGUuY291bnRyaWVzWzBdLmhpZXJhcmNoaWVzO1xuICAgICAgICBpZiAoYXJyICYmIGFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGFyci5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIGxldCBoID0gYXJyW2lpXTtcbiAgICAgICAgICAgIGlmIChoLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgZGVmID0gaC5JRDtcbiAgICAgICAgICAgICAgLy8gc2F2ZSBkZWZhdWx0IHRvIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgICAgICAgR0VDbGllbnQuc2V0U3RvcmVkRGVmYXVsdEhpZXJhcmNoeShjLCBoLklEKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoZGVmKTtcbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gYXN5bmMgcmVxdWVzdCBmb3Igc3RkIGdlb2cgbGV2ZWxzXG4gIHN0YXRpYyBnZXRTdGFuZGFyZEdlb2dyYXBoeUxldmVscyhjb3VudHJ5LCBsYW5nQ29kZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIWNvdW50cnkgfHwgIVV0aWxzLmhhc1RleHQoY291bnRyeSkpXG4gICAgICAgIGNvdW50cnkgPSAnVVMnOyAvLyBkZWZhdWx0XG4gICAgICAvLyBkZWZhdWx0IGhpZXJhcmNoeVxuICAgICAgR0VDbGllbnQuZ2V0R0VEZWZhdWx0SGllcmFyY2h5KGNvdW50cnkpLnRoZW4oKGRlZkhpZXJhcmNoeU5hbWUpID0+IHtcbiAgICAgICAgLy8gUmVxdWVzdCBnZW9ncmFwaHkgbGV2ZWxzXG4gICAgICAgIC8vIHJlcXVlc3Q9IGh0dHBzOi8vZ2VvZW5yaWNoLmFyY2dpcy5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvV29ybGQvZ2VvZW5yaWNobWVudHNlcnZlci9HZW9lbnJpY2htZW50L1N0YW5kYXJkR2VvZ3JhcGh5TGV2ZWxzL1VTP2Y9anNvblxuICAgICAgICBjb25zdCBnZVVybCA9IEFyY0dJU0NsaWVudC5nZXRHZW9lbnJpY2htZW50VXJsKCk7XG4gICAgICAgIC8vIGxldCB1cmw6IHN0cmluZyA9IGdlVXJsLnRvU3RyaW5nKCkgKyAnL0NvdW50cmllcy8nICsgY291bnRyeSArICc/Zj1wanNvbic7XG4gICAgICAgIGxldCB1cmwgPSBnZVVybC50b1N0cmluZygpICsgJy9HZW9lbnJpY2htZW50L1N0YW5kYXJkR2VvZ3JhcGh5TGV2ZWxzLycgKyBjb3VudHJ5ICsgJz9mPXBqc29uJztcbiAgICAgICAgQXJjR0lTQ2xpZW50LmV4ZWN1dGVSZXF1ZXN0KHtcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBsYW5nQ29kZTogbGFuZ0NvZGUgPyBsYW5nQ29kZSA6IFwiZW4tdXNcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbigoZSkgPT4ge1xuICAgICAgICAgIGxldCBoaWVyO1xuICAgICAgICAgIGlmIChlICYmIGUuZ2VvZ3JhcGh5TGV2ZWxzICYmIGUuZ2VvZ3JhcGh5TGV2ZWxzWzBdICYmIGUuZ2VvZ3JhcGh5TGV2ZWxzWzBdLmhpZXJhcmNoaWVzKSB7XG4gICAgICAgICAgICBsZXQgYXJyID0gZS5nZW9ncmFwaHlMZXZlbHNbMF0uaGllcmFyY2hpZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYXJyLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICBpZiAoYXJyW2lpXS5JRCA9PSBkZWZIaWVyYXJjaHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgaGllciA9IGFycltpaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGllcilcbiAgICAgICAgICAgICAgaGllciA9IGFyclswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShoaWVyKTtcbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ0dFQ2xpZW50IGVycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuICB9XG59XG5HRUNsaWVudC5fZGVmYXVsdEhpZXJhcmNoeVN0b3JhZ2VOYW1lID0gJ0dFQ2xpZW50LWRlZmF1bHQtaGllcmFyY2h5Jztcbi8vIE5PVEUhITogSGFyZGNvZGVkIGZvciBFeHBlcmllbmNlIEJ1aWxkZXIsIHdlIG5lZWQgdG8gbW9kaWZ5IHRvIGJlIHBhc3NlZCBpbiBieSBjb25zdW1pbmcgYXBwbGljYXRpb24gdG8gYWxsb3cgZm9yIG11bHRpIGFwcCB1c2VcbkdFQ2xpZW50LmFwcElEID0gXCJlc3JpZXhwZXJpZW5jZWJ1aWxkZXJcIjtcbkdFQ2xpZW50LmVucmljaCA9IGZ1bmN0aW9uIChlbnJpY2hSZXF1ZXN0UGFyYW1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcGFyYW1zID0gZW5yaWNoUmVxdWVzdFBhcmFtcztcbiAgICB2YXIgZW5yaWNoVXJsID0gRW52aXJvbm1lbnRzLmdldFVybCgnZ2VvZW5yaWNoJykgKyAnL0dlb2VucmljaG1lbnQvRW5yaWNoJztcbiAgICBwYXJhbXMuZm9yU3RvcmFnZSA9IGZhbHNlO1xuICAgIEFyY0dJU0NsaWVudC5leGVjdXRlUmVxdWVzdCh7XG4gICAgICB1cmw6IGVucmljaFVybCxcbiAgICAgIGRhdGE6IHBhcmFtc1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGVucmljaFJlc3BvbnNlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZW5yaWNoUmVzcG9uc2UgJiYgZW5yaWNoUmVzcG9uc2UucmVzdWx0cyAmJiBlbnJpY2hSZXNwb25zZS5yZXN1bHRzLmxlbmd0aCAmJiBlbnJpY2hSZXNwb25zZS5yZXN1bHRzWzBdO1xuICAgICAgdmFyIGZlYXR1cmVTZXQgPSByZXN1bHQgJiYgcmVzdWx0LnZhbHVlICYmIHJlc3VsdC52YWx1ZS5GZWF0dXJlU2V0ICYmIHJlc3VsdC52YWx1ZS5GZWF0dXJlU2V0Lmxlbmd0aCAmJiByZXN1bHQudmFsdWUuRmVhdHVyZVNldFswXTtcbiAgICAgIGlmIChmZWF0dXJlU2V0LmZlYXR1cmVzICYmIGZlYXR1cmVTZXQuZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmUoZW5yaWNoUmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBlcnJvckRlc2NyaXB0aW9uID0gZW5yaWNoUmVzcG9uc2UgJiYgZW5yaWNoUmVzcG9uc2UubWVzc2FnZXMgJiYgZW5yaWNoUmVzcG9uc2UubWVzc2FnZXMubGVuZ3RoICYmIGVucmljaFJlc3BvbnNlLm1lc3NhZ2VzWzBdLmRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAoIWVycm9yRGVzY3JpcHRpb24pXG4gICAgICAgICAgZXJyb3JEZXNjcmlwdGlvbiA9ICdnZXRmYWN0cy1uby1kYXRhJztcbiAgICAgICAgcmVqZWN0KGVycm9yRGVzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmV4cG9ydCB7IEVudmlyb25tZW50cyBhcyBFLCBHRUNsaWVudCBhcyBHLCBTZXR0aW5nc0hlbHBlciBhcyBTLCBUb2tlblByb3ZpZGVyIGFzIFQgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0VDbGllbnQtMWE4M2E2NTcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9