"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_portal-68dbcb"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-75adf962.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-75adf962.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ configState),
/* harmony export */   o: () => (/* binding */ onConfigChange)
/* harmony export */ });
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const configStore = (0,_index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__.c)({
    portal: null,
    user: null,
    api: 4,
    scale: "m"
});
const configState = configStore.state;
const onConfigChange = configStore.onChange;



//# sourceMappingURL=config-75adf962.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};



//# sourceMappingURL=index-05956cab.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-d518b571.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-d518b571.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getPortalRestInfo),
/* harmony export */   b: () => (/* binding */ getPortalRestInfoFromUrl),
/* harmony export */   c: () => (/* binding */ clearCache),
/* harmony export */   d: () => (/* binding */ formRequest),
/* harmony export */   e: () => (/* binding */ getToken),
/* harmony export */   f: () => (/* binding */ fromCache),
/* harmony export */   g: () => (/* binding */ getRestBaseUrl),
/* harmony export */   h: () => (/* binding */ getPortalToken),
/* harmony export */   i: () => (/* binding */ isWebTierAuth),
/* harmony export */   j: () => (/* binding */ hasModernHomePageEnabled),
/* harmony export */   k: () => (/* binding */ getHomePageConfig),
/* harmony export */   l: () => (/* binding */ getMemberDefaults),
/* harmony export */   m: () => (/* binding */ isPortalBackedBySDS),
/* harmony export */   n: () => (/* binding */ getUserId),
/* harmony export */   o: () => (/* binding */ inCache),
/* harmony export */   p: () => (/* binding */ pollForStatus),
/* harmony export */   q: () => (/* binding */ queryGroups),
/* harmony export */   r: () => (/* binding */ request),
/* harmony export */   s: () => (/* binding */ getPortalRestBaseUrl),
/* harmony export */   t: () => (/* binding */ getFederatedServers),
/* harmony export */   u: () => (/* binding */ isKubernetes)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config-75adf962.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-75adf962.js");
/* harmony import */ var _url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-4c3ae54c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-4c3ae54c.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */





function getToken(portal) {
    var _a, _b, _c, _d;
    portal !== null && portal !== void 0 ? portal : (portal = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c === null || _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c === void 0 ? void 0 : _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c.portal);
    return (
    // @ts-ignore
    ((_a = portal === null || portal === void 0 ? void 0 : portal.credential) === null || _a === void 0 ? void 0 : _a.token) || (portal === null || portal === void 0 ? void 0 : portal.token) || ((_c = (_b = portal === null || portal === void 0 ? void 0 : portal.user) === null || _b === void 0 ? void 0 : _b.credential) === null || _c === void 0 ? void 0 : _c.token) || ((_d = portal === null || portal === void 0 ? void 0 : portal.portalUser) === null || _d === void 0 ? void 0 : _d.token) || "");
}

function useSSL(url) {
    var _a;
    const { config } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c;
    // if user logged in via pop-up in viewer, the page might still be under http but the self response might have allSSL
    if (window.location.protocol === "https:" || ((_a = config === null || config === void 0 ? void 0 : config.self) === null || _a === void 0 ? void 0 : _a.allSSL) === true) {
        return url.replace("http:", "https:");
    }
    return url;
}
async function formRequest(url, form, options = {}, method) {
    const [esriRequest] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/request"]);
    const { api } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c;
    if (!url.includes("f=")) {
        form.append("f", "json");
    }
    const token = getToken();
    if (token && !form.has("token")) {
        form.append("token", token);
    }
    return new Promise((resolve, reject) => {
        if (api === 3) {
            const request = { url: options.addSSL === false ? url : useSSL(url), form, timeout: options.timeout || 0 };
            const v3Options = method === "post" ? Object.assign({ usePost: true }, options) : options;
            esriRequest(request, v3Options).then(resolve, reject);
        }
        else {
            esriRequest(url, Object.assign(Object.assign({ body: form }, options), { timeout: options.timeout || 0, method: method || "auto" }))
                .then((response) => {
                resolve(response.data);
            })
                .catch((error) => reject(error));
        }
    });
}
async function request(url, params = {}, options = {}, method, extraOption) {
    const [esriRequest] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/request"]);
    // TODO: refactor this dude out
    const { api, portal } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c;
    const { customToken, addTokenManually, addSSL } = options;
    const content = Object.assign({}, params);
    if (!url.includes("f=") && (extraOption === null || extraOption === void 0 ? void 0 : extraOption.excludeJson) !== true) {
        content.f = "json";
    }
    if (customToken) {
        content.token = customToken;
    }
    else {
        if (addTokenManually !== false) {
            const token = await getPortalToken(portal, api);
            content.token = token;
        }
    }
    const requestUrl = addSSL === false ? url : useSSL(url);
    if (api === 3) {
        const v3Request = Object.assign({ url: requestUrl, content, timeout: options.timeout || 0 }, extraOption === null || extraOption === void 0 ? void 0 : extraOption.v3Request);
        if (options.withCredentials) {
            v3Request.withCredentials = options.withCredentials;
        }
        const v3Options = method === "post" ? Object.assign({ usePost: true }, options) : options;
        return esriRequest(v3Request, v3Options);
    }
    else {
        const v4Options = Object.assign(Object.assign(Object.assign({ query: content, method: method || "auto" }, options), { timeout: options.timeout || 0 }), ((options === null || options === void 0 ? void 0 : options.disableIdentityLookup) ? { authMode: "anonymous" } : {}));
        const response = await esriRequest(requestUrl, v4Options);
        return response.data;
    }
}
// https://devtopia.esri.com/WebGIS/arcgis-portal-app/blob/master/src/js/arcgisonline/pages/item/widgets/typeOptions/featureSupport.ts#L37-L66
const ASYNC_INTERVALS = [
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 15, 15, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 120
];
function asyncIntervalTimerFunction(callCount) {
    // if call count out of bounds, use last interval, otherwise use interval at callCount
    const index = callCount > -1 && callCount < ASYNC_INTERVALS.length - 1 ? callCount : ASYNC_INTERVALS.length - 1;
    // ASYNC_INTERVALS defined in seconds, convert to milliseconds on return
    return ASYNC_INTERVALS[index] * 1000;
}
const pollForStatus = async (url, options, method) => {
    var _a, _b;
    const pendingStatuses = (_a = options === null || options === void 0 ? void 0 : options.pendingStatuses) !== null && _a !== void 0 ? _a : ["processing", "partial", "Pending", "InProgress", "EXECUTING"];
    const successStatuses = (_b = options === null || options === void 0 ? void 0 : options.successStatuses) !== null && _b !== void 0 ? _b : ["completed", "Completed", "COMPLETED"];
    let pollCount = 0;
    const poll = async () => {
        // Keep polling status until either completed or failed
        // Do failures report as success (status 200)? May need to manually throw error on status check failure
        const statusResponse = await request(url, options === null || options === void 0 ? void 0 : options.requestParams, {}, method);
        const status = statusResponse.status || statusResponse.jobStatus;
        if (pendingStatuses.includes(status)) {
            await (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_3__.t)(asyncIntervalTimerFunction(pollCount++));
            return poll();
        }
        else if (successStatuses.includes(status)) {
            return statusResponse;
        }
        else {
            throw statusResponse;
        }
    };
    try {
        return poll();
    }
    catch (e) {
        console.error(e);
        throw e;
    }
};

const cache = {};
const requestCache = {};
const cacheMetadata = {};
/**
 * Allows memory caching of requests which are expected to be called multiple times
 * @param requester - function which fetches the data to be cached
 * @param key - unique global name for this cache type - see {@link CacheType}
 * @param id - unique id for this result inside this particular cache
 */
async function fromCache(requester, key, id, cacheOption) {
    var _a, _b, _c, _d;
    const cacheExpirationTime = (_b = (_a = cacheMetadata[key]) === null || _a === void 0 ? void 0 : _a[id]) === null || _b === void 0 ? void 0 : _b.expireAt;
    const isExpired = !!cacheExpirationTime && new Date().getTime() > cacheExpirationTime;
    if (((_c = cache[key]) === null || _c === void 0 ? void 0 : _c[id]) && !isExpired) {
        return cache[key][id];
    }
    if (!requestCache[key]) {
        requestCache[key] = {};
    }
    // If it's expired, we want to re-run the entire request again, not just using the old promise
    // else we'll use the outdated data
    if (!requestCache[key][id] || isExpired) {
        requestCache[key][id] = requester();
    }
    const result = (await requestCache[key][id]);
    if (!cache[key]) {
        cache[key] = {};
    }
    if (!cacheMetadata[key]) {
        cacheMetadata[key] = {};
    }
    cache[key][id] = result;
    if (cacheOption) {
        const { expireAfter, getExpireAfterFromResult } = cacheOption;
        const expireAt = getExpireAfterFromResult || expireAfter
            ? new Date().getTime() + ((_d = getExpireAfterFromResult === null || getExpireAfterFromResult === void 0 ? void 0 : getExpireAfterFromResult(result)) !== null && _d !== void 0 ? _d : expireAfter)
            : null;
        cacheMetadata[key][id] = Object.assign(Object.assign({}, cacheMetadata[key][id]), { expireAt });
    }
    return result;
}
/**
 * Checks for a value in the cache and returns if there
 * If missing, no requests will be performed
 * @param key - unique global name for this cache type - see {@link CacheType}
 * @param id - unique id for this result inside this particular cache, will clear all entries if not provided
 * @example
 * inCache("serviceInfo", "uniqueitemid");
 */
function inCache(key, id) {
    var _a;
    return (_a = cache === null || cache === void 0 ? void 0 : cache[key]) === null || _a === void 0 ? void 0 : _a[id];
}
/**
 * Clear a particular cache entry or all entries for a particular cache type
 * @param key - unique global name for this cache type - see {@link CacheType}
 * @param id - unique id for this result inside this particular cache, will clear all entries if not provided
 * @example
 * clearCache("userGroups", "unique");
 * clearCache("userGroups");
 */
const clearCache = (key, id) => {
    var _a, _b;
    if (id) {
        (_a = cache[key]) === null || _a === void 0 ? true : delete _a[id];
        (_b = requestCache[key]) === null || _b === void 0 ? true : delete _b[id];
    }
    else {
        delete cache[key];
        delete requestCache[key];
    }
};

function getRestBaseUrl(portal) {
    var _a;
    const { portal: configPortal, config } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c || {};
    return (_a = (0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.a)(config === null || config === void 0 ? void 0 : config.restBaseUrl)) !== null && _a !== void 0 ? _a : getPortalRestBaseUrl(portal || configPortal);
}
function getPortalRestBaseUrl(portal) {
    var _a;
    return (0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.a)((_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl);
}
function getUserId(user) {
    var _a, _b;
    return (_a = user === null || user === void 0 ? void 0 : user.id) !== null && _a !== void 0 ? _a : (_b = user === null || user === void 0 ? void 0 : user.sourceJSON) === null || _b === void 0 ? void 0 : _b.id;
}
function isWebTierAuth(portal) {
    var _a, _b;
    return (_a = portal === null || portal === void 0 ? void 0 : portal.isWebTierAuth) !== null && _a !== void 0 ? _a : (_b = portal.sourceJSON) === null || _b === void 0 ? void 0 : _b.isWebTierAuth;
}
function isOrgPastLegacyHomePageCutOffDate(portal) {
    const legacyCutOffDate = new Date("June 30, 2020").getTime();
    if (!portal.isPortal) {
        return portal.created >= legacyCutOffDate;
    }
    else {
        return false;
    }
}
function isKubernetes(portal) {
    var _a;
    const portalDeploymentType = portal.portalDeploymentType || ((_a = portal.sourceJSON) === null || _a === void 0 ? void 0 : _a.portalDeploymentType);
    return portalDeploymentType === "ArcGISEnterpriseOnKubernetes";
}
function isEnterpriseSetToModernHomePageOnly(portal) {
    var _a;
    return portal.isPortal && ((_a = portal.portalProperties) === null || _a === void 0 ? void 0 : _a.homePage) === "modernOnly";
}
function hasModernHomePageEnabled(portal) {
    var _a, _b;
    if (!portal.isPortal) {
        // organizations created after this date never have access to the legacy home page
        return ((_a = portal.portalProperties) === null || _a === void 0 ? void 0 : _a.homePage) === "modern" || isOrgPastLegacyHomePageCutOffDate(portal);
    }
    else {
        return ((_b = portal.portalProperties) === null || _b === void 0 ? void 0 : _b.homePage) === "modern" || isEnterpriseSetToModernHomePageOnly(portal);
    }
}
async function getHomePageConfig(portal) {
    return fromCache(() => request(`${getRestBaseUrl(portal)}portals/self/resources/home.page.json`), "homePageConfig", portal.id);
}
async function getMemberDefaults(portal) {
    return fromCache(() => request(`${getRestBaseUrl(portal)}portals/self/userDefaultSettings`), "memberDefaults", portal.id);
}
/**
 * Get the portal's token and also handle web-tier authentication Enterprise case
 */
const getPortalToken = async (portal, api) => {
    var _a;
    // `portal` can be unexpectedly undefined
    // https://devtopia.esri.com/WebGIS/arcgis-app-components/pull/5113
    if (!(portal === null || portal === void 0 ? void 0 : portal.isPortal) || !isWebTierAuth(portal)) {
        return getToken(portal);
    }
    const { token } = await fromCache(() => getPlatformSelf(portal, api !== null && api !== void 0 ? api : _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c === null || _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c === void 0 ? void 0 : _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c.api), "platformSelf", (_a = getUserId(portal.user)) !== null && _a !== void 0 ? _a : portal.id, { getExpireAfterFromResult: (result) => result.expires_in });
    return token;
};
/**
 * Get the active client id. Defaults to "arcgisonline".
 */
const getClientId = async (portal, api) => {
    var _a, _b, _c;
    const is3x = api === 3;
    const [IdentityManager] = await _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.e.loadModules([is3x ? "esri/IdentityManager" : "esri/identity/IdentityManager"]);
    const credential = await fromCache(() => IdentityManager.getCredential(getRestBaseUrl(portal), { oAuthPopupConfirmation: false }), "credential", getUserId(portal.user));
    return ((_c = (is3x
        ? (_a = credential._oAuthCred) === null || _a === void 0 ? void 0 : _a.appId
        : (_b = credential.oAuthState) === null || _b === void 0 ? void 0 : _b.appId)) !== null && _c !== void 0 ? _c : "arcgisonline");
};
/**
 * Useful to get the token in web-tier authenticated Enterprise portals
 * Based on https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/master/esri/IdentityManagerBase.js#L1952-L1966
 */
const getPlatformSelf = async (portal, apiVersion) => {
    const appId = await getClientId(portal, apiVersion);
    const headers = {
        "X-Esri-Auth-Client-Id": appId,
        "X-Esri-Auth-Redirect-Uri": window.location.href.replace(/#.*$/, "")
    };
    return request(`${getRestBaseUrl(portal)}/oauth2/platformSelf`, {}, {
        disableIdentityLookup: true,
        headers: apiVersion === 4 ? headers : undefined,
        // To avoid infinite loop since `request` will call this again
        addTokenManually: false,
        withCredentials: true
    }, "post", { v3Request: { headers } });
};
/**
 * `portal.queryGroups` expects slightly different formats in 3.x vs 4.x
 * This is a version-agnostic replacement
 **/
async function queryGroups(params = {}, portal) {
    return request(`${getRestBaseUrl(portal)}/community/groups`, params);
}
/**
 * Get the on premise portals federated servers (must be signed in user to make this call)
 */
const getFederatedServers = async (user, portal) => {
    var _a;
    // Since the user must be signed in to make the call, this is required
    if (!user) {
        return [];
    }
    const restBaseUrl = `${(0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.a)((_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl)}portals/self/servers`;
    const result = await fromCache(() => request(restBaseUrl), "selfServers", portal.id);
    return result === null || result === void 0 ? void 0 : result.servers;
};
const getPortalRestInfo = (portal) => {
    return getPortalRestInfoFromUrl(getPortalRestBaseUrl(portal));
};
const getPortalRestInfoFromUrl = (url) => {
    var _a;
    // Sometimes serviceUrl/info will return nothing so we need to extract the `rest` out
    const infoUrl = `${(0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.a)((_a = (0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.g)(url)) !== null && _a !== void 0 ? _a : url)}info`;
    // Most likely this info won't change so it's safe to use `fromCache`
    return fromCache(() => request(infoUrl, {}, { addTokenManually: false }), "portalInfo", infoUrl);
};
const isPortalBackedBySDS = async (portal, user) => {
    if (portal.isBackedBySDS) {
        return { result: true };
    }
    if (!portal.isPortal) {
        return { result: true };
    }
    try {
        // Only on-premise portals need to be checked if they support sds
        // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/3112
        // Get the hosted managed federated Servers (this call requires a signed in user)
        const hostedServers = getHostedFederatedServer(user, portal);
        return { result: !!(hostedServers === null || hostedServers === void 0 ? void 0 : hostedServers[0]) };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) }, result: false };
    }
};
/**
 * Get the on premise portals hosted federated servers
 */
const getHostedFederatedServer = async (user, portal) => {
    var _a;
    const federatedServers = (_a = (await getFederatedServers(user, portal))) !== null && _a !== void 0 ? _a : [];
    return federatedServers.filter((server) => server.isHosted)[0];
};



//# sourceMappingURL=portal-d518b571.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-4c3ae54c.js":
/*!*********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-4c3ae54c.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ addTrailingSlashIfMissing),
/* harmony export */   b: () => (/* binding */ geoJsonRegExp),
/* harmony export */   c: () => (/* binding */ agsRegExp),
/* harmony export */   g: () => (/* binding */ getRestUrlFromUrl),
/* harmony export */   p: () => (/* binding */ parseAGSServerInfo),
/* harmony export */   r: () => (/* binding */ regexServerType),
/* harmony export */   s: () => (/* binding */ specialCharactersRegExp),
/* harmony export */   v: () => (/* binding */ validArcgisRestServicePath)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
const specialCharactersRegExp = /\+|\?|\/|\(|\)|\\|\!|\#|\"|\||\*|\:|<|>|\%|\$|\@|\'|\^|\[|\]|\,|\=|\;/gi;
const geoJsonRegExp = /(\.|outputFormat=)json|geojson$/i;
const agsRegExp = /\/ags\//gi;

const serverTypes = "MapServer|GeocodeServer|GPServer|GeometryServer|ImageServer|NAServer|FeatureServer|GeoDataServer|GlobeServer|MobileServer|WMServer|SceneServer|VectorTileServer|StreamServer|WorkspaceServer|GeoenrichmentServer|VideoServer";
const regexServerType = new RegExp(`http.+\/(${serverTypes})`);
const validArcgisRestServicePath = `\/arcgis\/rest\/services|\/rest\/services|\/arcgis\/services|\/arcgis\/rest`;
const serverInfoExp = `(?<server>http.+(?:${validArcgisRestServicePath})(?:\/?.*\/(?<name>.*)\/(?<type>${serverTypes})))(?!.*\/${serverTypes})\/?(?<soe>\\d+)?.*`;
/** Returns an array containing the input url, base server url, server name, server type, and layer index (if entered).
 * Example: [
 * "https://sampleserver6.arcgisonline.com/arcgis/rest/services/FeatureServer/500",
 * "https://sampleserver6.arcgisonline.com/arcgis/rest/services/TestService/FeatureServer",
 * "TestService",
 * "FeatureServer",
 * "500"
 * ]  */
const regexServerInfo = new RegExp(serverInfoExp, "i");

const parseAGSServerInfo = (url) => {
    const extractedInfo = url.match(regexServerInfo);
    if (!extractedInfo) {
        const containsAGS = url.match(agsRegExp);
        // Type is always MapServer for /ags/ services
        return containsAGS ? { baseServerUrl: url, serverName: null, serverType: "MapServer", index: null } : null;
    }
    const [, baseServerUrl, serverName, serverType, indexStr] = extractedInfo;
    const index = parseInt(indexStr);
    return { baseServerUrl, serverName, serverType, index: isNaN(index) ? null : index };
};
const getRestUrlFromUrl = (url) => {
    if (!url) {
        return null;
    }
    const extractedInfo = url.match(validArcgisRestServicePath);
    if (!extractedInfo) {
        return null;
    }
    const urlParts = url.split("/rest");
    return urlParts.length < 2 ? null : `${urlParts[0]}/rest/`;
};
const addTrailingSlashIfMissing = (url) => url && url.charAt(url.length - 1) !== "/" ? `${url}/` : url;



//# sourceMappingURL=url-4c3ae54c.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fcG9ydGFsLTY4ZGJjYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RDs7QUFFdkQsb0JBQW9CLHFEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRWlEOztBQUVqRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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SDtBQUNBLDhDQUE4QyxJQUFJLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVMsd0RBQXdEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvYzs7QUFFcGM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBOztBQUVBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQSw0Q0FBNEMsMkJBQTJCLGtDQUFrQyxZQUFZLFlBQVksWUFBWTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2RUFBNkU7QUFDNUc7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQSwwRkFBMEYsSUFBSTs7QUFFc0g7O0FBRXBOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vY29uZmlnLTc1YWRmOTYyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vaW5kZXgtMDU5NTZjYWIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vcG9ydGFsLWQ1MThiNTcxLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3VybC00YzNhZTU0Yy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGMgYXMgY3JlYXRlU3RvcmUgfSBmcm9tICcuL2luZGV4LTA1OTU2Y2FiLmpzJztcblxuY29uc3QgY29uZmlnU3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgcG9ydGFsOiBudWxsLFxuICAgIHVzZXI6IG51bGwsXG4gICAgYXBpOiA0LFxuICAgIHNjYWxlOiBcIm1cIlxufSk7XG5jb25zdCBjb25maWdTdGF0ZSA9IGNvbmZpZ1N0b3JlLnN0YXRlO1xuY29uc3Qgb25Db25maWdDaGFuZ2UgPSBjb25maWdTdG9yZS5vbkNoYW5nZTtcblxuZXhwb3J0IHsgY29uZmlnU3RhdGUgYXMgYywgb25Db25maWdDaGFuZ2UgYXMgbyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWctNzVhZGY5NjIuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIG4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgIGZ1bmN0aW9uIGZsdXNoKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZsdXNoZWRcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW52b2tlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgZGVib3VuY2VkLmludm9rZSA9IGludm9rZTtcbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgIGRlYm91bmNlZC5nZXRTdGF0dXMgPSBnZXRTdGF0dXM7XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIG4gbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtwcm9taXNlLCB0aW1lb3V0KG1pbkRlbGF5KV0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGlubGluZSBzZXRUaW1lb3V0IGFzIGFuIGF3YWl0IGluIGFzeW5jIGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gICAgY29uc3QgeyBrZXksIGRhdGEgfSA9IGdldEtleUFuZEl0ZW0oaXRlbSk7XG4gICAgcmV0dXJuIFtrZXksIGRhdGFdO1xufSkpO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcbiAqIGFuZCB3aGV0aGVyIHRoZXkgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50c1xuICogcmVnYXJkbGVzcyBvZiBvcmRlclxuICovXG5jb25zdCBhcnJheXNBcmVFcXVpdmFsZW50ID0gKGFycjEsIGFycjIpID0+IGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLnJlZHVjZSgobWVtbywgc3RyKSA9PiBtZW1vICYmIGFycjIuaW5kZXhPZihzdHIpID4gLTEsIHRydWUpO1xuZnVuY3Rpb24gdW5pcXVlQnkobXlBcnIsIGdldEl0ZW1JZCkge1xuICAgIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICAgIGNvbnN0IGxvb2t1cE1hcCA9IHt9O1xuICAgIG15QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZXRJdGVtSWQoaXRlbSk7XG4gICAgICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyO1xufVxuZnVuY3Rpb24gdW5pcXVlKG15QXJyKSB7XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IHsgYm9vbGVhbjoge30sIG51bWJlcjoge30sIHN0cmluZzoge30gfTtcbiAgICBjb25zdCBvYmpzID0gW107XG4gICAgcmV0dXJuIG15QXJyLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgICAgICBpZiAodHlwZSBpbiBwcmltaXRpdmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlc1t0eXBlXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSA/IGZhbHNlIDogKHByaW1pdGl2ZXNbdHlwZV1baXRlbV0gPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uYWwtNDRkZThmY2YuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBnIGFzIGdldFJlbmRlcmluZ1JlZiwgZiBhcyBmb3JjZVVwZGF0ZSB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuXG5jb25zdCBhcHBlbmRUb01hcCA9IChtYXAsIHByb3BOYW1lLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGl0ZW1zID0gbWFwLmdldChwcm9wTmFtZSk7XG4gICAgaWYgKCFpdGVtcykge1xuICAgICAgICBtYXAuc2V0KHByb3BOYW1lLCBbdmFsdWVdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWl0ZW1zLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9XG59O1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIG1zKSA9PiB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSAwO1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0sIG1zKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvc3NpYmxlIGVsZW1lbnQgaXNDb25uZWN0ZWQuXG4gKiBUaGUgcHJvcGVydHkgbWlnaHQgbm90IGJlIHRoZXJlLCBzbyB3ZSBjaGVjayBmb3IgaXQuXG4gKlxuICogV2Ugd2FudCBpdCB0byByZXR1cm4gdHJ1ZSBpZiBpc0Nvbm5lY3RlZCBpcyBub3QgYSBwcm9wZXJ0eSxcbiAqIG90aGVyd2lzZSB3ZSB3b3VsZCByZW1vdmUgdGhlc2UgZWxlbWVudHMgYW5kIHdvdWxkIG5vdCB1cGRhdGUuXG4gKlxuICogQmV0dGVyIGxlYWsgaW4gRWRnZSB0aGFuIHRvIGJlIHVzZWxlc3MuXG4gKi9cbmNvbnN0IGlzQ29ubmVjdGVkID0gKG1heWJlRWxlbWVudCkgPT4gISgnaXNDb25uZWN0ZWQnIGluIG1heWJlRWxlbWVudCkgfHwgbWF5YmVFbGVtZW50LmlzQ29ubmVjdGVkO1xuY29uc3QgY2xlYW51cEVsZW1lbnRzID0gZGVib3VuY2UoKG1hcCkgPT4ge1xuICAgIGZvciAobGV0IGtleSBvZiBtYXAua2V5cygpKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBtYXAuZ2V0KGtleSkuZmlsdGVyKGlzQ29ubmVjdGVkKSk7XG4gICAgfVxufSwgMjAwMCk7XG5jb25zdCBzdGVuY2lsU3Vic2NyaXB0aW9uID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2V0UmVuZGVyaW5nUmVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBub3QgaW4gYSBzdGVuY2lsIHByb2plY3QsIHdlIGRvIG5vdGhpbmcuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlYWxseSBleHBvcnRlZCBieSBAc3RlbmNpbC9jb3JlLlxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGVsbXNUb1VwZGF0ZSA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwb3NlOiAoKSA9PiBlbG1zVG9VcGRhdGUuY2xlYXIoKSxcbiAgICAgICAgZ2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsbSA9IGdldFJlbmRlcmluZ1JlZigpO1xuICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZFRvTWFwKGVsbXNUb1VwZGF0ZSwgcHJvcE5hbWUsIGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKHByb3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGVsbXNUb1VwZGF0ZS5nZXQocHJvcE5hbWUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZWxtc1RvVXBkYXRlLnNldChwcm9wTmFtZSwgZWxlbWVudHMuZmlsdGVyKGZvcmNlVXBkYXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhbnVwRWxlbWVudHMoZWxtc1RvVXBkYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGVsbXNUb1VwZGF0ZS5mb3JFYWNoKChlbG1zKSA9PiBlbG1zLmZvckVhY2goZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG5jb25zdCB1bndyYXAgPSAodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHZhbCgpIDogdmFsKTtcbmNvbnN0IGNyZWF0ZU9ic2VydmFibGVNYXAgPSAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUgPSAoYSwgYikgPT4gYSAhPT0gYikgPT4ge1xuICAgIGNvbnN0IHVud3JhcHBlZFN0YXRlID0gdW53cmFwKGRlZmF1bHRTdGF0ZSk7XG4gICAgbGV0IHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXModW53cmFwcGVkU3RhdGUgIT09IG51bGwgJiYgdW53cmFwcGVkU3RhdGUgIT09IHZvaWQgMCA/IHVud3JhcHBlZFN0YXRlIDoge30pKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgICAgZGlzcG9zZTogW10sXG4gICAgICAgIGdldDogW10sXG4gICAgICAgIHNldDogW10sXG4gICAgICAgIHJlc2V0OiBbXSxcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFdoZW4gcmVzZXR0aW5nIHRoZSBzdGF0ZSwgdGhlIGRlZmF1bHQgc3RhdGUgbWF5IGJlIGEgZnVuY3Rpb24gLSB1bndyYXAgaXQgdG8gaW52b2tlIGl0LlxuICAgICAgICAvLyBvdGhlcndpc2UsIHRoZSBzdGF0ZSB3b24ndCBiZSBwcm9wZXJseSByZXNldFxuICAgICAgICBzdGF0ZXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKChfYSA9IHVud3JhcChkZWZhdWx0U3RhdGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSkpO1xuICAgICAgICBoYW5kbGVycy5yZXNldC5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgfTtcbiAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xuICAgICAgICAvLyBDYWxsIGZpcnN0IGRpc3Bvc2UgYXMgcmVzZXR0aW5nIHRoZSBzdGF0ZSB3b3VsZFxuICAgICAgICAvLyBjYXVzZSBsZXNzIHVwZGF0ZXMgOylcbiAgICAgICAgaGFuZGxlcnMuZGlzcG9zZS5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXQgPSAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgaGFuZGxlcnMuZ2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSkpO1xuICAgICAgICByZXR1cm4gc3RhdGVzLmdldChwcm9wTmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXQgPSAocHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gc3RhdGVzLmdldChwcm9wTmFtZSk7XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGUodmFsdWUsIG9sZFZhbHVlLCBwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIHN0YXRlcy5zZXQocHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnNldC5mb3JFYWNoKChjYikgPT4gY2IocHJvcE5hbWUsIHZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9ICh0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8ge31cbiAgICAgICAgOiBuZXcgUHJveHkodW53cmFwcGVkU3RhdGUsIHtcbiAgICAgICAgICAgIGdldChfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQocHJvcE5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG93bktleXMoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN0YXRlcy5rZXlzKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXMoXywgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVzLmhhcyhwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KF8sIHByb3BOYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIGNvbnN0IG9uID0gKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheShoYW5kbGVyc1tldmVudE5hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IChwcm9wTmFtZSwgY2IpID0+IHtcbiAgICAgICAgY29uc3QgdW5TZXQgPSBvbignc2V0JywgKGtleSwgbmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2IobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB1bndyYXAgdGhlIGRlZmF1bHRTdGF0ZSBiZWNhdXNlIGl0IG1pZ2h0IGJlIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBtaWdodCBub3QgYmUgc2VuZGluZyB0aGUgcmlnaHQgcmVzZXQgdmFsdWUuXG4gICAgICAgIGNvbnN0IHVuUmVzZXQgPSBvbigncmVzZXQnLCAoKSA9PiBjYih1bndyYXAoZGVmYXVsdFN0YXRlKVtwcm9wTmFtZV0pKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHVuU2V0KCk7XG4gICAgICAgICAgICB1blJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB1c2UgPSAoLi4uc3Vic2NyaXB0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCB1bnN1YnMgPSBzdWJzY3JpcHRpb25zLnJlZHVjZSgodW5zdWJzLCBzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uc2V0KSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ3NldCcsIHN1YnNjcmlwdGlvbi5zZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uZ2V0KSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2dldCcsIHN1YnNjcmlwdGlvbi5nZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24ucmVzZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbigncmVzZXQnLCBzdWJzY3JpcHRpb24ucmVzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uZGlzcG9zZSkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdkaXNwb3NlJywgc3Vic2NyaXB0aW9uLmRpc3Bvc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bnN1YnM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHVuc3Vicy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSk7XG4gICAgfTtcbiAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGhhbmRsZXJzLnNldC5mb3JFYWNoKChjYikgPT4gY2Ioa2V5LCBvbGRWYWx1ZSwgb2xkVmFsdWUpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICBnZXQsXG4gICAgICAgIHNldCxcbiAgICAgICAgb24sXG4gICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICB1c2UsXG4gICAgICAgIGRpc3Bvc2UsXG4gICAgICAgIHJlc2V0LFxuICAgICAgICBmb3JjZVVwZGF0ZSxcbiAgICB9O1xufTtcbmNvbnN0IHJlbW92ZUZyb21BcnJheSA9IChhcnJheSwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgYXJyYXkubGVuZ3RoLS07XG4gICAgfVxufTtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpID0+IHtcbiAgICBjb25zdCBtYXAgPSBjcmVhdGVPYnNlcnZhYmxlTWFwKGRlZmF1bHRTdGF0ZSwgc2hvdWxkVXBkYXRlKTtcbiAgICBtYXAudXNlKHN0ZW5jaWxTdWJzY3JpcHRpb24oKSk7XG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlIGFzIGMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtMDU5NTZjYWIuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzLCBlIGFzIGVzcmlMb2FkZXIgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCB7IGMgYXMgY29uZmlnU3RhdGUgfSBmcm9tICcuL2NvbmZpZy03NWFkZjk2Mi5qcyc7XG5pbXBvcnQgeyBhIGFzIGFkZFRyYWlsaW5nU2xhc2hJZk1pc3NpbmcsIGcgYXMgZ2V0UmVzdFVybEZyb21VcmwgfSBmcm9tICcuL3VybC00YzNhZTU0Yy5qcyc7XG5pbXBvcnQgeyB0IGFzIHRpbWVvdXQgfSBmcm9tICcuL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMnO1xuXG5mdW5jdGlvbiBnZXRUb2tlbihwb3J0YWwpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcG9ydGFsICE9PSBudWxsICYmIHBvcnRhbCAhPT0gdm9pZCAwID8gcG9ydGFsIDogKHBvcnRhbCA9IGNvbmZpZ1N0YXRlID09PSBudWxsIHx8IGNvbmZpZ1N0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWdTdGF0ZS5wb3J0YWwpO1xuICAgIHJldHVybiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgICgoX2EgPSBwb3J0YWwgPT09IG51bGwgfHwgcG9ydGFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3J0YWwuY3JlZGVudGlhbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRva2VuKSB8fCAocG9ydGFsID09PSBudWxsIHx8IHBvcnRhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9ydGFsLnRva2VuKSB8fCAoKF9jID0gKF9iID0gcG9ydGFsID09PSBudWxsIHx8IHBvcnRhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9ydGFsLnVzZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jcmVkZW50aWFsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9rZW4pIHx8ICgoX2QgPSBwb3J0YWwgPT09IG51bGwgfHwgcG9ydGFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3J0YWwucG9ydGFsVXNlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRva2VuKSB8fCBcIlwiKTtcbn1cblxuZnVuY3Rpb24gdXNlU1NMKHVybCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGNvbmZpZyB9ID0gY29uZmlnU3RhdGU7XG4gICAgLy8gaWYgdXNlciBsb2dnZWQgaW4gdmlhIHBvcC11cCBpbiB2aWV3ZXIsIHRoZSBwYWdlIG1pZ2h0IHN0aWxsIGJlIHVuZGVyIGh0dHAgYnV0IHRoZSBzZWxmIHJlc3BvbnNlIG1pZ2h0IGhhdmUgYWxsU1NMXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIiB8fCAoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnNlbGYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbGxTU0wpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB1cmwucmVwbGFjZShcImh0dHA6XCIsIFwiaHR0cHM6XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuYXN5bmMgZnVuY3Rpb24gZm9ybVJlcXVlc3QodXJsLCBmb3JtLCBvcHRpb25zID0ge30sIG1ldGhvZCkge1xuICAgIGNvbnN0IFtlc3JpUmVxdWVzdF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL3JlcXVlc3RcIl0pO1xuICAgIGNvbnN0IHsgYXBpIH0gPSBjb25maWdTdGF0ZTtcbiAgICBpZiAoIXVybC5pbmNsdWRlcyhcImY9XCIpKSB7XG4gICAgICAgIGZvcm0uYXBwZW5kKFwiZlwiLCBcImpzb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcbiAgICBpZiAodG9rZW4gJiYgIWZvcm0uaGFzKFwidG9rZW5cIikpIHtcbiAgICAgICAgZm9ybS5hcHBlbmQoXCJ0b2tlblwiLCB0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChhcGkgPT09IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IHVybDogb3B0aW9ucy5hZGRTU0wgPT09IGZhbHNlID8gdXJsIDogdXNlU1NMKHVybCksIGZvcm0sIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCB8fCAwIH07XG4gICAgICAgICAgICBjb25zdCB2M09wdGlvbnMgPSBtZXRob2QgPT09IFwicG9zdFwiID8gT2JqZWN0LmFzc2lnbih7IHVzZVBvc3Q6IHRydWUgfSwgb3B0aW9ucykgOiBvcHRpb25zO1xuICAgICAgICAgICAgZXNyaVJlcXVlc3QocmVxdWVzdCwgdjNPcHRpb25zKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlc3JpUmVxdWVzdCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGJvZHk6IGZvcm0gfSwgb3B0aW9ucyksIHsgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IDAsIG1ldGhvZDogbWV0aG9kIHx8IFwiYXV0b1wiIH0pKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHJlamVjdChlcnJvcikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0KHVybCwgcGFyYW1zID0ge30sIG9wdGlvbnMgPSB7fSwgbWV0aG9kLCBleHRyYU9wdGlvbikge1xuICAgIGNvbnN0IFtlc3JpUmVxdWVzdF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL3JlcXVlc3RcIl0pO1xuICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXMgZHVkZSBvdXRcbiAgICBjb25zdCB7IGFwaSwgcG9ydGFsIH0gPSBjb25maWdTdGF0ZTtcbiAgICBjb25zdCB7IGN1c3RvbVRva2VuLCBhZGRUb2tlbk1hbnVhbGx5LCBhZGRTU0wgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY29udGVudCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gICAgaWYgKCF1cmwuaW5jbHVkZXMoXCJmPVwiKSAmJiAoZXh0cmFPcHRpb24gPT09IG51bGwgfHwgZXh0cmFPcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9uLmV4Y2x1ZGVKc29uKSAhPT0gdHJ1ZSkge1xuICAgICAgICBjb250ZW50LmYgPSBcImpzb25cIjtcbiAgICB9XG4gICAgaWYgKGN1c3RvbVRva2VuKSB7XG4gICAgICAgIGNvbnRlbnQudG9rZW4gPSBjdXN0b21Ub2tlbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChhZGRUb2tlbk1hbnVhbGx5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRQb3J0YWxUb2tlbihwb3J0YWwsIGFwaSk7XG4gICAgICAgICAgICBjb250ZW50LnRva2VuID0gdG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdFVybCA9IGFkZFNTTCA9PT0gZmFsc2UgPyB1cmwgOiB1c2VTU0wodXJsKTtcbiAgICBpZiAoYXBpID09PSAzKSB7XG4gICAgICAgIGNvbnN0IHYzUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oeyB1cmw6IHJlcXVlc3RVcmwsIGNvbnRlbnQsIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCB8fCAwIH0sIGV4dHJhT3B0aW9uID09PSBudWxsIHx8IGV4dHJhT3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRyYU9wdGlvbi52M1JlcXVlc3QpO1xuICAgICAgICBpZiAob3B0aW9ucy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHYzUmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSBvcHRpb25zLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2M09wdGlvbnMgPSBtZXRob2QgPT09IFwicG9zdFwiID8gT2JqZWN0LmFzc2lnbih7IHVzZVBvc3Q6IHRydWUgfSwgb3B0aW9ucykgOiBvcHRpb25zO1xuICAgICAgICByZXR1cm4gZXNyaVJlcXVlc3QodjNSZXF1ZXN0LCB2M09wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdjRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBxdWVyeTogY29udGVudCwgbWV0aG9kOiBtZXRob2QgfHwgXCJhdXRvXCIgfSwgb3B0aW9ucyksIHsgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IDAgfSksICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVJZGVudGl0eUxvb2t1cCkgPyB7IGF1dGhNb2RlOiBcImFub255bW91c1wiIH0gOiB7fSkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVzcmlSZXF1ZXN0KHJlcXVlc3RVcmwsIHY0T3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbn1cbi8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2Jsb2IvbWFzdGVyL3NyYy9qcy9hcmNnaXNvbmxpbmUvcGFnZXMvaXRlbS93aWRnZXRzL3R5cGVPcHRpb25zL2ZlYXR1cmVTdXBwb3J0LnRzI0wzNy1MNjZcbmNvbnN0IEFTWU5DX0lOVEVSVkFMUyA9IFtcbiAgICAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAxNSwgMTUsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAxMjBcbl07XG5mdW5jdGlvbiBhc3luY0ludGVydmFsVGltZXJGdW5jdGlvbihjYWxsQ291bnQpIHtcbiAgICAvLyBpZiBjYWxsIGNvdW50IG91dCBvZiBib3VuZHMsIHVzZSBsYXN0IGludGVydmFsLCBvdGhlcndpc2UgdXNlIGludGVydmFsIGF0IGNhbGxDb3VudFxuICAgIGNvbnN0IGluZGV4ID0gY2FsbENvdW50ID4gLTEgJiYgY2FsbENvdW50IDwgQVNZTkNfSU5URVJWQUxTLmxlbmd0aCAtIDEgPyBjYWxsQ291bnQgOiBBU1lOQ19JTlRFUlZBTFMubGVuZ3RoIC0gMTtcbiAgICAvLyBBU1lOQ19JTlRFUlZBTFMgZGVmaW5lZCBpbiBzZWNvbmRzLCBjb252ZXJ0IHRvIG1pbGxpc2Vjb25kcyBvbiByZXR1cm5cbiAgICByZXR1cm4gQVNZTkNfSU5URVJWQUxTW2luZGV4XSAqIDEwMDA7XG59XG5jb25zdCBwb2xsRm9yU3RhdHVzID0gYXN5bmMgKHVybCwgb3B0aW9ucywgbWV0aG9kKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBwZW5kaW5nU3RhdHVzZXMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGVuZGluZ1N0YXR1c2VzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXCJwcm9jZXNzaW5nXCIsIFwicGFydGlhbFwiLCBcIlBlbmRpbmdcIiwgXCJJblByb2dyZXNzXCIsIFwiRVhFQ1VUSU5HXCJdO1xuICAgIGNvbnN0IHN1Y2Nlc3NTdGF0dXNlcyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdWNjZXNzU3RhdHVzZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtcImNvbXBsZXRlZFwiLCBcIkNvbXBsZXRlZFwiLCBcIkNPTVBMRVRFRFwiXTtcbiAgICBsZXQgcG9sbENvdW50ID0gMDtcbiAgICBjb25zdCBwb2xsID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBLZWVwIHBvbGxpbmcgc3RhdHVzIHVudGlsIGVpdGhlciBjb21wbGV0ZWQgb3IgZmFpbGVkXG4gICAgICAgIC8vIERvIGZhaWx1cmVzIHJlcG9ydCBhcyBzdWNjZXNzIChzdGF0dXMgMjAwKT8gTWF5IG5lZWQgdG8gbWFudWFsbHkgdGhyb3cgZXJyb3Igb24gc3RhdHVzIGNoZWNrIGZhaWx1cmVcbiAgICAgICAgY29uc3Qgc3RhdHVzUmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KHVybCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlcXVlc3RQYXJhbXMsIHt9LCBtZXRob2QpO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBzdGF0dXNSZXNwb25zZS5zdGF0dXMgfHwgc3RhdHVzUmVzcG9uc2Uuam9iU3RhdHVzO1xuICAgICAgICBpZiAocGVuZGluZ1N0YXR1c2VzLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoYXN5bmNJbnRlcnZhbFRpbWVyRnVuY3Rpb24ocG9sbENvdW50KyspKTtcbiAgICAgICAgICAgIHJldHVybiBwb2xsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3VjY2Vzc1N0YXR1c2VzLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXNSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHN0YXR1c1Jlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gcG9sbCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn07XG5cbmNvbnN0IGNhY2hlID0ge307XG5jb25zdCByZXF1ZXN0Q2FjaGUgPSB7fTtcbmNvbnN0IGNhY2hlTWV0YWRhdGEgPSB7fTtcbi8qKlxuICogQWxsb3dzIG1lbW9yeSBjYWNoaW5nIG9mIHJlcXVlc3RzIHdoaWNoIGFyZSBleHBlY3RlZCB0byBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAqIEBwYXJhbSByZXF1ZXN0ZXIgLSBmdW5jdGlvbiB3aGljaCBmZXRjaGVzIHRoZSBkYXRhIHRvIGJlIGNhY2hlZFxuICogQHBhcmFtIGtleSAtIHVuaXF1ZSBnbG9iYWwgbmFtZSBmb3IgdGhpcyBjYWNoZSB0eXBlIC0gc2VlIHtAbGluayBDYWNoZVR5cGV9XG4gKiBAcGFyYW0gaWQgLSB1bmlxdWUgaWQgZm9yIHRoaXMgcmVzdWx0IGluc2lkZSB0aGlzIHBhcnRpY3VsYXIgY2FjaGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZnJvbUNhY2hlKHJlcXVlc3Rlciwga2V5LCBpZCwgY2FjaGVPcHRpb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgY2FjaGVFeHBpcmF0aW9uVGltZSA9IChfYiA9IChfYSA9IGNhY2hlTWV0YWRhdGFba2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2lkXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV4cGlyZUF0O1xuICAgIGNvbnN0IGlzRXhwaXJlZCA9ICEhY2FjaGVFeHBpcmF0aW9uVGltZSAmJiBuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IGNhY2hlRXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKCgoX2MgPSBjYWNoZVtrZXldKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbaWRdKSAmJiAhaXNFeHBpcmVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZVtrZXldW2lkXTtcbiAgICB9XG4gICAgaWYgKCFyZXF1ZXN0Q2FjaGVba2V5XSkge1xuICAgICAgICByZXF1ZXN0Q2FjaGVba2V5XSA9IHt9O1xuICAgIH1cbiAgICAvLyBJZiBpdCdzIGV4cGlyZWQsIHdlIHdhbnQgdG8gcmUtcnVuIHRoZSBlbnRpcmUgcmVxdWVzdCBhZ2Fpbiwgbm90IGp1c3QgdXNpbmcgdGhlIG9sZCBwcm9taXNlXG4gICAgLy8gZWxzZSB3ZSdsbCB1c2UgdGhlIG91dGRhdGVkIGRhdGFcbiAgICBpZiAoIXJlcXVlc3RDYWNoZVtrZXldW2lkXSB8fCBpc0V4cGlyZWQpIHtcbiAgICAgICAgcmVxdWVzdENhY2hlW2tleV1baWRdID0gcmVxdWVzdGVyKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IChhd2FpdCByZXF1ZXN0Q2FjaGVba2V5XVtpZF0pO1xuICAgIGlmICghY2FjaGVba2V5XSkge1xuICAgICAgICBjYWNoZVtrZXldID0ge307XG4gICAgfVxuICAgIGlmICghY2FjaGVNZXRhZGF0YVtrZXldKSB7XG4gICAgICAgIGNhY2hlTWV0YWRhdGFba2V5XSA9IHt9O1xuICAgIH1cbiAgICBjYWNoZVtrZXldW2lkXSA9IHJlc3VsdDtcbiAgICBpZiAoY2FjaGVPcHRpb24pIHtcbiAgICAgICAgY29uc3QgeyBleHBpcmVBZnRlciwgZ2V0RXhwaXJlQWZ0ZXJGcm9tUmVzdWx0IH0gPSBjYWNoZU9wdGlvbjtcbiAgICAgICAgY29uc3QgZXhwaXJlQXQgPSBnZXRFeHBpcmVBZnRlckZyb21SZXN1bHQgfHwgZXhwaXJlQWZ0ZXJcbiAgICAgICAgICAgID8gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyAoKF9kID0gZ2V0RXhwaXJlQWZ0ZXJGcm9tUmVzdWx0ID09PSBudWxsIHx8IGdldEV4cGlyZUFmdGVyRnJvbVJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0RXhwaXJlQWZ0ZXJGcm9tUmVzdWx0KHJlc3VsdCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGV4cGlyZUFmdGVyKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjYWNoZU1ldGFkYXRhW2tleV1baWRdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYWNoZU1ldGFkYXRhW2tleV1baWRdKSwgeyBleHBpcmVBdCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ2hlY2tzIGZvciBhIHZhbHVlIGluIHRoZSBjYWNoZSBhbmQgcmV0dXJucyBpZiB0aGVyZVxuICogSWYgbWlzc2luZywgbm8gcmVxdWVzdHMgd2lsbCBiZSBwZXJmb3JtZWRcbiAqIEBwYXJhbSBrZXkgLSB1bmlxdWUgZ2xvYmFsIG5hbWUgZm9yIHRoaXMgY2FjaGUgdHlwZSAtIHNlZSB7QGxpbmsgQ2FjaGVUeXBlfVxuICogQHBhcmFtIGlkIC0gdW5pcXVlIGlkIGZvciB0aGlzIHJlc3VsdCBpbnNpZGUgdGhpcyBwYXJ0aWN1bGFyIGNhY2hlLCB3aWxsIGNsZWFyIGFsbCBlbnRyaWVzIGlmIG5vdCBwcm92aWRlZFxuICogQGV4YW1wbGVcbiAqIGluQ2FjaGUoXCJzZXJ2aWNlSW5mb1wiLCBcInVuaXF1ZWl0ZW1pZFwiKTtcbiAqL1xuZnVuY3Rpb24gaW5DYWNoZShrZXksIGlkKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBjYWNoZSA9PT0gbnVsbCB8fCBjYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FjaGVba2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2lkXTtcbn1cbi8qKlxuICogQ2xlYXIgYSBwYXJ0aWN1bGFyIGNhY2hlIGVudHJ5IG9yIGFsbCBlbnRyaWVzIGZvciBhIHBhcnRpY3VsYXIgY2FjaGUgdHlwZVxuICogQHBhcmFtIGtleSAtIHVuaXF1ZSBnbG9iYWwgbmFtZSBmb3IgdGhpcyBjYWNoZSB0eXBlIC0gc2VlIHtAbGluayBDYWNoZVR5cGV9XG4gKiBAcGFyYW0gaWQgLSB1bmlxdWUgaWQgZm9yIHRoaXMgcmVzdWx0IGluc2lkZSB0aGlzIHBhcnRpY3VsYXIgY2FjaGUsIHdpbGwgY2xlYXIgYWxsIGVudHJpZXMgaWYgbm90IHByb3ZpZGVkXG4gKiBAZXhhbXBsZVxuICogY2xlYXJDYWNoZShcInVzZXJHcm91cHNcIiwgXCJ1bmlxdWVcIik7XG4gKiBjbGVhckNhY2hlKFwidXNlckdyb3Vwc1wiKTtcbiAqL1xuY29uc3QgY2xlYXJDYWNoZSA9IChrZXksIGlkKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoaWQpIHtcbiAgICAgICAgKF9hID0gY2FjaGVba2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHRydWUgOiBkZWxldGUgX2FbaWRdO1xuICAgICAgICAoX2IgPSByZXF1ZXN0Q2FjaGVba2V5XSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHRydWUgOiBkZWxldGUgX2JbaWRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0Q2FjaGVba2V5XTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBnZXRSZXN0QmFzZVVybChwb3J0YWwpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBwb3J0YWw6IGNvbmZpZ1BvcnRhbCwgY29uZmlnIH0gPSBjb25maWdTdGF0ZSB8fCB7fTtcbiAgICByZXR1cm4gKF9hID0gYWRkVHJhaWxpbmdTbGFzaElmTWlzc2luZyhjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcucmVzdEJhc2VVcmwpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBnZXRQb3J0YWxSZXN0QmFzZVVybChwb3J0YWwgfHwgY29uZmlnUG9ydGFsKTtcbn1cbmZ1bmN0aW9uIGdldFBvcnRhbFJlc3RCYXNlVXJsKHBvcnRhbCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gYWRkVHJhaWxpbmdTbGFzaElmTWlzc2luZygoX2EgPSBwb3J0YWwucmVzdFVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcG9ydGFsLnBvcnRhbFVybCk7XG59XG5mdW5jdGlvbiBnZXRVc2VySWQodXNlcikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYSA9IHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gdXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnNvdXJjZUpTT04pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZDtcbn1cbmZ1bmN0aW9uIGlzV2ViVGllckF1dGgocG9ydGFsKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9hID0gcG9ydGFsID09PSBudWxsIHx8IHBvcnRhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9ydGFsLmlzV2ViVGllckF1dGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHBvcnRhbC5zb3VyY2VKU09OKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNXZWJUaWVyQXV0aDtcbn1cbmZ1bmN0aW9uIGlzT3JnUGFzdExlZ2FjeUhvbWVQYWdlQ3V0T2ZmRGF0ZShwb3J0YWwpIHtcbiAgICBjb25zdCBsZWdhY3lDdXRPZmZEYXRlID0gbmV3IERhdGUoXCJKdW5lIDMwLCAyMDIwXCIpLmdldFRpbWUoKTtcbiAgICBpZiAoIXBvcnRhbC5pc1BvcnRhbCkge1xuICAgICAgICByZXR1cm4gcG9ydGFsLmNyZWF0ZWQgPj0gbGVnYWN5Q3V0T2ZmRGF0ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0t1YmVybmV0ZXMocG9ydGFsKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBvcnRhbERlcGxveW1lbnRUeXBlID0gcG9ydGFsLnBvcnRhbERlcGxveW1lbnRUeXBlIHx8ICgoX2EgPSBwb3J0YWwuc291cmNlSlNPTikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvcnRhbERlcGxveW1lbnRUeXBlKTtcbiAgICByZXR1cm4gcG9ydGFsRGVwbG95bWVudFR5cGUgPT09IFwiQXJjR0lTRW50ZXJwcmlzZU9uS3ViZXJuZXRlc1wiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlU2V0VG9Nb2Rlcm5Ib21lUGFnZU9ubHkocG9ydGFsKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBwb3J0YWwuaXNQb3J0YWwgJiYgKChfYSA9IHBvcnRhbC5wb3J0YWxQcm9wZXJ0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaG9tZVBhZ2UpID09PSBcIm1vZGVybk9ubHlcIjtcbn1cbmZ1bmN0aW9uIGhhc01vZGVybkhvbWVQYWdlRW5hYmxlZChwb3J0YWwpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghcG9ydGFsLmlzUG9ydGFsKSB7XG4gICAgICAgIC8vIG9yZ2FuaXphdGlvbnMgY3JlYXRlZCBhZnRlciB0aGlzIGRhdGUgbmV2ZXIgaGF2ZSBhY2Nlc3MgdG8gdGhlIGxlZ2FjeSBob21lIHBhZ2VcbiAgICAgICAgcmV0dXJuICgoX2EgPSBwb3J0YWwucG9ydGFsUHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhvbWVQYWdlKSA9PT0gXCJtb2Rlcm5cIiB8fCBpc09yZ1Bhc3RMZWdhY3lIb21lUGFnZUN1dE9mZkRhdGUocG9ydGFsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoKF9iID0gcG9ydGFsLnBvcnRhbFByb3BlcnRpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ob21lUGFnZSkgPT09IFwibW9kZXJuXCIgfHwgaXNFbnRlcnByaXNlU2V0VG9Nb2Rlcm5Ib21lUGFnZU9ubHkocG9ydGFsKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRIb21lUGFnZUNvbmZpZyhwb3J0YWwpIHtcbiAgICByZXR1cm4gZnJvbUNhY2hlKCgpID0+IHJlcXVlc3QoYCR7Z2V0UmVzdEJhc2VVcmwocG9ydGFsKX1wb3J0YWxzL3NlbGYvcmVzb3VyY2VzL2hvbWUucGFnZS5qc29uYCksIFwiaG9tZVBhZ2VDb25maWdcIiwgcG9ydGFsLmlkKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldE1lbWJlckRlZmF1bHRzKHBvcnRhbCkge1xuICAgIHJldHVybiBmcm9tQ2FjaGUoKCkgPT4gcmVxdWVzdChgJHtnZXRSZXN0QmFzZVVybChwb3J0YWwpfXBvcnRhbHMvc2VsZi91c2VyRGVmYXVsdFNldHRpbmdzYCksIFwibWVtYmVyRGVmYXVsdHNcIiwgcG9ydGFsLmlkKTtcbn1cbi8qKlxuICogR2V0IHRoZSBwb3J0YWwncyB0b2tlbiBhbmQgYWxzbyBoYW5kbGUgd2ViLXRpZXIgYXV0aGVudGljYXRpb24gRW50ZXJwcmlzZSBjYXNlXG4gKi9cbmNvbnN0IGdldFBvcnRhbFRva2VuID0gYXN5bmMgKHBvcnRhbCwgYXBpKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIGBwb3J0YWxgIGNhbiBiZSB1bmV4cGVjdGVkbHkgdW5kZWZpbmVkXG4gICAgLy8gaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLWFwcC1jb21wb25lbnRzL3B1bGwvNTExM1xuICAgIGlmICghKHBvcnRhbCA9PT0gbnVsbCB8fCBwb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbC5pc1BvcnRhbCkgfHwgIWlzV2ViVGllckF1dGgocG9ydGFsKSkge1xuICAgICAgICByZXR1cm4gZ2V0VG9rZW4ocG9ydGFsKTtcbiAgICB9XG4gICAgY29uc3QgeyB0b2tlbiB9ID0gYXdhaXQgZnJvbUNhY2hlKCgpID0+IGdldFBsYXRmb3JtU2VsZihwb3J0YWwsIGFwaSAhPT0gbnVsbCAmJiBhcGkgIT09IHZvaWQgMCA/IGFwaSA6IGNvbmZpZ1N0YXRlID09PSBudWxsIHx8IGNvbmZpZ1N0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWdTdGF0ZS5hcGkpLCBcInBsYXRmb3JtU2VsZlwiLCAoX2EgPSBnZXRVc2VySWQocG9ydGFsLnVzZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwb3J0YWwuaWQsIHsgZ2V0RXhwaXJlQWZ0ZXJGcm9tUmVzdWx0OiAocmVzdWx0KSA9PiByZXN1bHQuZXhwaXJlc19pbiB9KTtcbiAgICByZXR1cm4gdG9rZW47XG59O1xuLyoqXG4gKiBHZXQgdGhlIGFjdGl2ZSBjbGllbnQgaWQuIERlZmF1bHRzIHRvIFwiYXJjZ2lzb25saW5lXCIuXG4gKi9cbmNvbnN0IGdldENsaWVudElkID0gYXN5bmMgKHBvcnRhbCwgYXBpKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgaXMzeCA9IGFwaSA9PT0gMztcbiAgICBjb25zdCBbSWRlbnRpdHlNYW5hZ2VyXSA9IGF3YWl0IGVzcmlMb2FkZXIubG9hZE1vZHVsZXMoW2lzM3ggPyBcImVzcmkvSWRlbnRpdHlNYW5hZ2VyXCIgOiBcImVzcmkvaWRlbnRpdHkvSWRlbnRpdHlNYW5hZ2VyXCJdKTtcbiAgICBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgZnJvbUNhY2hlKCgpID0+IElkZW50aXR5TWFuYWdlci5nZXRDcmVkZW50aWFsKGdldFJlc3RCYXNlVXJsKHBvcnRhbCksIHsgb0F1dGhQb3B1cENvbmZpcm1hdGlvbjogZmFsc2UgfSksIFwiY3JlZGVudGlhbFwiLCBnZXRVc2VySWQocG9ydGFsLnVzZXIpKTtcbiAgICByZXR1cm4gKChfYyA9IChpczN4XG4gICAgICAgID8gKF9hID0gY3JlZGVudGlhbC5fb0F1dGhDcmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwSWRcbiAgICAgICAgOiAoX2IgPSBjcmVkZW50aWFsLm9BdXRoU3RhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hcHBJZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiYXJjZ2lzb25saW5lXCIpO1xufTtcbi8qKlxuICogVXNlZnVsIHRvIGdldCB0aGUgdG9rZW4gaW4gd2ViLXRpZXIgYXV0aGVudGljYXRlZCBFbnRlcnByaXNlIHBvcnRhbHNcbiAqIEJhc2VkIG9uIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1qcy1hcGkvYmxvYi9tYXN0ZXIvZXNyaS9JZGVudGl0eU1hbmFnZXJCYXNlLmpzI0wxOTUyLUwxOTY2XG4gKi9cbmNvbnN0IGdldFBsYXRmb3JtU2VsZiA9IGFzeW5jIChwb3J0YWwsIGFwaVZlcnNpb24pID0+IHtcbiAgICBjb25zdCBhcHBJZCA9IGF3YWl0IGdldENsaWVudElkKHBvcnRhbCwgYXBpVmVyc2lvbik7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgXCJYLUVzcmktQXV0aC1DbGllbnQtSWRcIjogYXBwSWQsXG4gICAgICAgIFwiWC1Fc3JpLUF1dGgtUmVkaXJlY3QtVXJpXCI6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMuKiQvLCBcIlwiKVxuICAgIH07XG4gICAgcmV0dXJuIHJlcXVlc3QoYCR7Z2V0UmVzdEJhc2VVcmwocG9ydGFsKX0vb2F1dGgyL3BsYXRmb3JtU2VsZmAsIHt9LCB7XG4gICAgICAgIGRpc2FibGVJZGVudGl0eUxvb2t1cDogdHJ1ZSxcbiAgICAgICAgaGVhZGVyczogYXBpVmVyc2lvbiA9PT0gNCA/IGhlYWRlcnMgOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIFRvIGF2b2lkIGluZmluaXRlIGxvb3Agc2luY2UgYHJlcXVlc3RgIHdpbGwgY2FsbCB0aGlzIGFnYWluXG4gICAgICAgIGFkZFRva2VuTWFudWFsbHk6IGZhbHNlLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWVcbiAgICB9LCBcInBvc3RcIiwgeyB2M1JlcXVlc3Q6IHsgaGVhZGVycyB9IH0pO1xufTtcbi8qKlxuICogYHBvcnRhbC5xdWVyeUdyb3Vwc2AgZXhwZWN0cyBzbGlnaHRseSBkaWZmZXJlbnQgZm9ybWF0cyBpbiAzLnggdnMgNC54XG4gKiBUaGlzIGlzIGEgdmVyc2lvbi1hZ25vc3RpYyByZXBsYWNlbWVudFxuICoqL1xuYXN5bmMgZnVuY3Rpb24gcXVlcnlHcm91cHMocGFyYW1zID0ge30sIHBvcnRhbCkge1xuICAgIHJldHVybiByZXF1ZXN0KGAke2dldFJlc3RCYXNlVXJsKHBvcnRhbCl9L2NvbW11bml0eS9ncm91cHNgLCBwYXJhbXMpO1xufVxuLyoqXG4gKiBHZXQgdGhlIG9uIHByZW1pc2UgcG9ydGFscyBmZWRlcmF0ZWQgc2VydmVycyAobXVzdCBiZSBzaWduZWQgaW4gdXNlciB0byBtYWtlIHRoaXMgY2FsbClcbiAqL1xuY29uc3QgZ2V0RmVkZXJhdGVkU2VydmVycyA9IGFzeW5jICh1c2VyLCBwb3J0YWwpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgLy8gU2luY2UgdGhlIHVzZXIgbXVzdCBiZSBzaWduZWQgaW4gdG8gbWFrZSB0aGUgY2FsbCwgdGhpcyBpcyByZXF1aXJlZFxuICAgIGlmICghdXNlcikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHJlc3RCYXNlVXJsID0gYCR7YWRkVHJhaWxpbmdTbGFzaElmTWlzc2luZygoX2EgPSBwb3J0YWwucmVzdFVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcG9ydGFsLnBvcnRhbFVybCl9cG9ydGFscy9zZWxmL3NlcnZlcnNgO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZyb21DYWNoZSgoKSA9PiByZXF1ZXN0KHJlc3RCYXNlVXJsKSwgXCJzZWxmU2VydmVyc1wiLCBwb3J0YWwuaWQpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuc2VydmVycztcbn07XG5jb25zdCBnZXRQb3J0YWxSZXN0SW5mbyA9IChwb3J0YWwpID0+IHtcbiAgICByZXR1cm4gZ2V0UG9ydGFsUmVzdEluZm9Gcm9tVXJsKGdldFBvcnRhbFJlc3RCYXNlVXJsKHBvcnRhbCkpO1xufTtcbmNvbnN0IGdldFBvcnRhbFJlc3RJbmZvRnJvbVVybCA9ICh1cmwpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgLy8gU29tZXRpbWVzIHNlcnZpY2VVcmwvaW5mbyB3aWxsIHJldHVybiBub3RoaW5nIHNvIHdlIG5lZWQgdG8gZXh0cmFjdCB0aGUgYHJlc3RgIG91dFxuICAgIGNvbnN0IGluZm9VcmwgPSBgJHthZGRUcmFpbGluZ1NsYXNoSWZNaXNzaW5nKChfYSA9IGdldFJlc3RVcmxGcm9tVXJsKHVybCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVybCl9aW5mb2A7XG4gICAgLy8gTW9zdCBsaWtlbHkgdGhpcyBpbmZvIHdvbid0IGNoYW5nZSBzbyBpdCdzIHNhZmUgdG8gdXNlIGBmcm9tQ2FjaGVgXG4gICAgcmV0dXJuIGZyb21DYWNoZSgoKSA9PiByZXF1ZXN0KGluZm9VcmwsIHt9LCB7IGFkZFRva2VuTWFudWFsbHk6IGZhbHNlIH0pLCBcInBvcnRhbEluZm9cIiwgaW5mb1VybCk7XG59O1xuY29uc3QgaXNQb3J0YWxCYWNrZWRCeVNEUyA9IGFzeW5jIChwb3J0YWwsIHVzZXIpID0+IHtcbiAgICBpZiAocG9ydGFsLmlzQmFja2VkQnlTRFMpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgfVxuICAgIGlmICghcG9ydGFsLmlzUG9ydGFsKSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBPbmx5IG9uLXByZW1pc2UgcG9ydGFscyBuZWVkIHRvIGJlIGNoZWNrZWQgaWYgdGhleSBzdXBwb3J0IHNkc1xuICAgICAgICAvLyBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvMzExMlxuICAgICAgICAvLyBHZXQgdGhlIGhvc3RlZCBtYW5hZ2VkIGZlZGVyYXRlZCBTZXJ2ZXJzICh0aGlzIGNhbGwgcmVxdWlyZXMgYSBzaWduZWQgaW4gdXNlcilcbiAgICAgICAgY29uc3QgaG9zdGVkU2VydmVycyA9IGdldEhvc3RlZEZlZGVyYXRlZFNlcnZlcih1c2VyLCBwb3J0YWwpO1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6ICEhKGhvc3RlZFNlcnZlcnMgPT09IG51bGwgfHwgaG9zdGVkU2VydmVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdGVkU2VydmVyc1swXSkgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKSB9LCByZXN1bHQ6IGZhbHNlIH07XG4gICAgfVxufTtcbi8qKlxuICogR2V0IHRoZSBvbiBwcmVtaXNlIHBvcnRhbHMgaG9zdGVkIGZlZGVyYXRlZCBzZXJ2ZXJzXG4gKi9cbmNvbnN0IGdldEhvc3RlZEZlZGVyYXRlZFNlcnZlciA9IGFzeW5jICh1c2VyLCBwb3J0YWwpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZmVkZXJhdGVkU2VydmVycyA9IChfYSA9IChhd2FpdCBnZXRGZWRlcmF0ZWRTZXJ2ZXJzKHVzZXIsIHBvcnRhbCkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICByZXR1cm4gZmVkZXJhdGVkU2VydmVycy5maWx0ZXIoKHNlcnZlcikgPT4gc2VydmVyLmlzSG9zdGVkKVswXTtcbn07XG5cbmV4cG9ydCB7IGdldFBvcnRhbFJlc3RJbmZvIGFzIGEsIGdldFBvcnRhbFJlc3RJbmZvRnJvbVVybCBhcyBiLCBjbGVhckNhY2hlIGFzIGMsIGZvcm1SZXF1ZXN0IGFzIGQsIGdldFRva2VuIGFzIGUsIGZyb21DYWNoZSBhcyBmLCBnZXRSZXN0QmFzZVVybCBhcyBnLCBnZXRQb3J0YWxUb2tlbiBhcyBoLCBpc1dlYlRpZXJBdXRoIGFzIGksIGhhc01vZGVybkhvbWVQYWdlRW5hYmxlZCBhcyBqLCBnZXRIb21lUGFnZUNvbmZpZyBhcyBrLCBnZXRNZW1iZXJEZWZhdWx0cyBhcyBsLCBpc1BvcnRhbEJhY2tlZEJ5U0RTIGFzIG0sIGdldFVzZXJJZCBhcyBuLCBpbkNhY2hlIGFzIG8sIHBvbGxGb3JTdGF0dXMgYXMgcCwgcXVlcnlHcm91cHMgYXMgcSwgcmVxdWVzdCBhcyByLCBnZXRQb3J0YWxSZXN0QmFzZVVybCBhcyBzLCBnZXRGZWRlcmF0ZWRTZXJ2ZXJzIGFzIHQsIGlzS3ViZXJuZXRlcyBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcnRhbC1kNTE4YjU3MS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmNvbnN0IHNwZWNpYWxDaGFyYWN0ZXJzUmVnRXhwID0gL1xcK3xcXD98XFwvfFxcKHxcXCl8XFxcXHxcXCF8XFwjfFxcXCJ8XFx8fFxcKnxcXDp8PHw+fFxcJXxcXCR8XFxAfFxcJ3xcXF58XFxbfFxcXXxcXCx8XFw9fFxcOy9naTtcbmNvbnN0IGdlb0pzb25SZWdFeHAgPSAvKFxcLnxvdXRwdXRGb3JtYXQ9KWpzb258Z2VvanNvbiQvaTtcbmNvbnN0IGFnc1JlZ0V4cCA9IC9cXC9hZ3NcXC8vZ2k7XG5cbmNvbnN0IHNlcnZlclR5cGVzID0gXCJNYXBTZXJ2ZXJ8R2VvY29kZVNlcnZlcnxHUFNlcnZlcnxHZW9tZXRyeVNlcnZlcnxJbWFnZVNlcnZlcnxOQVNlcnZlcnxGZWF0dXJlU2VydmVyfEdlb0RhdGFTZXJ2ZXJ8R2xvYmVTZXJ2ZXJ8TW9iaWxlU2VydmVyfFdNU2VydmVyfFNjZW5lU2VydmVyfFZlY3RvclRpbGVTZXJ2ZXJ8U3RyZWFtU2VydmVyfFdvcmtzcGFjZVNlcnZlcnxHZW9lbnJpY2htZW50U2VydmVyfFZpZGVvU2VydmVyXCI7XG5jb25zdCByZWdleFNlcnZlclR5cGUgPSBuZXcgUmVnRXhwKGBodHRwLitcXC8oJHtzZXJ2ZXJUeXBlc30pYCk7XG5jb25zdCB2YWxpZEFyY2dpc1Jlc3RTZXJ2aWNlUGF0aCA9IGBcXC9hcmNnaXNcXC9yZXN0XFwvc2VydmljZXN8XFwvcmVzdFxcL3NlcnZpY2VzfFxcL2FyY2dpc1xcL3NlcnZpY2VzfFxcL2FyY2dpc1xcL3Jlc3RgO1xuY29uc3Qgc2VydmVySW5mb0V4cCA9IGAoPzxzZXJ2ZXI+aHR0cC4rKD86JHt2YWxpZEFyY2dpc1Jlc3RTZXJ2aWNlUGF0aH0pKD86XFwvPy4qXFwvKD88bmFtZT4uKilcXC8oPzx0eXBlPiR7c2VydmVyVHlwZXN9KSkpKD8hLipcXC8ke3NlcnZlclR5cGVzfSlcXC8/KD88c29lPlxcXFxkKyk/LipgO1xuLyoqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgaW5wdXQgdXJsLCBiYXNlIHNlcnZlciB1cmwsIHNlcnZlciBuYW1lLCBzZXJ2ZXIgdHlwZSwgYW5kIGxheWVyIGluZGV4IChpZiBlbnRlcmVkKS5cbiAqIEV4YW1wbGU6IFtcbiAqIFwiaHR0cHM6Ly9zYW1wbGVzZXJ2ZXI2LmFyY2dpc29ubGluZS5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvRmVhdHVyZVNlcnZlci81MDBcIixcbiAqIFwiaHR0cHM6Ly9zYW1wbGVzZXJ2ZXI2LmFyY2dpc29ubGluZS5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvVGVzdFNlcnZpY2UvRmVhdHVyZVNlcnZlclwiLFxuICogXCJUZXN0U2VydmljZVwiLFxuICogXCJGZWF0dXJlU2VydmVyXCIsXG4gKiBcIjUwMFwiXG4gKiBdICAqL1xuY29uc3QgcmVnZXhTZXJ2ZXJJbmZvID0gbmV3IFJlZ0V4cChzZXJ2ZXJJbmZvRXhwLCBcImlcIik7XG5cbmNvbnN0IHBhcnNlQUdTU2VydmVySW5mbyA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBleHRyYWN0ZWRJbmZvID0gdXJsLm1hdGNoKHJlZ2V4U2VydmVySW5mbyk7XG4gICAgaWYgKCFleHRyYWN0ZWRJbmZvKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zQUdTID0gdXJsLm1hdGNoKGFnc1JlZ0V4cCk7XG4gICAgICAgIC8vIFR5cGUgaXMgYWx3YXlzIE1hcFNlcnZlciBmb3IgL2Fncy8gc2VydmljZXNcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zQUdTID8geyBiYXNlU2VydmVyVXJsOiB1cmwsIHNlcnZlck5hbWU6IG51bGwsIHNlcnZlclR5cGU6IFwiTWFwU2VydmVyXCIsIGluZGV4OiBudWxsIH0gOiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBbLCBiYXNlU2VydmVyVXJsLCBzZXJ2ZXJOYW1lLCBzZXJ2ZXJUeXBlLCBpbmRleFN0cl0gPSBleHRyYWN0ZWRJbmZvO1xuICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoaW5kZXhTdHIpO1xuICAgIHJldHVybiB7IGJhc2VTZXJ2ZXJVcmwsIHNlcnZlck5hbWUsIHNlcnZlclR5cGUsIGluZGV4OiBpc05hTihpbmRleCkgPyBudWxsIDogaW5kZXggfTtcbn07XG5jb25zdCBnZXRSZXN0VXJsRnJvbVVybCA9ICh1cmwpID0+IHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0cmFjdGVkSW5mbyA9IHVybC5tYXRjaCh2YWxpZEFyY2dpc1Jlc3RTZXJ2aWNlUGF0aCk7XG4gICAgaWYgKCFleHRyYWN0ZWRJbmZvKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybC5zcGxpdChcIi9yZXN0XCIpO1xuICAgIHJldHVybiB1cmxQYXJ0cy5sZW5ndGggPCAyID8gbnVsbCA6IGAke3VybFBhcnRzWzBdfS9yZXN0L2A7XG59O1xuY29uc3QgYWRkVHJhaWxpbmdTbGFzaElmTWlzc2luZyA9ICh1cmwpID0+IHVybCAmJiB1cmwuY2hhckF0KHVybC5sZW5ndGggLSAxKSAhPT0gXCIvXCIgPyBgJHt1cmx9L2AgOiB1cmw7XG5cbmV4cG9ydCB7IGFkZFRyYWlsaW5nU2xhc2hJZk1pc3NpbmcgYXMgYSwgZ2VvSnNvblJlZ0V4cCBhcyBiLCBhZ3NSZWdFeHAgYXMgYywgZ2V0UmVzdFVybEZyb21VcmwgYXMgZywgcGFyc2VBR1NTZXJ2ZXJJbmZvIGFzIHAsIHJlZ2V4U2VydmVyVHlwZSBhcyByLCBzcGVjaWFsQ2hhcmFjdGVyc1JlZ0V4cCBhcyBzLCB2YWxpZEFyY2dpc1Jlc3RTZXJ2aWNlUGF0aCBhcyB2IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC00YzNhZTU0Yy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=