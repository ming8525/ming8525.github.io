"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-7fb8e1"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/multidimensional-helper-fc8fbe0e.js":
/*!********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/multidimensional-helper-fc8fbe0e.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ clone),
/* harmony export */   b: () => (/* binding */ getUniqueDimensionsForSelectedVariables),
/* harmony export */   c: () => (/* binding */ cloneData),
/* harmony export */   d: () => (/* binding */ getDimensionValuesForSelectedDimension),
/* harmony export */   e: () => (/* binding */ initRecurrentIntervalName),
/* harmony export */   g: () => (/* binding */ getDimensionRangeValuesForSelectedDimension),
/* harmony export */   i: () => (/* binding */ isItemInDropdown),
/* harmony export */   m: () => (/* binding */ multidimensionalDefinitionParser)
/* harmony export */ });
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");
/* harmony import */ var _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Uint8Array-68e1e3f9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_Uint8Array-68e1e3f9.js");
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");




/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!(0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.j)(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.c)(source, (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.b)(source), object);
}

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.c)(source, (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.k)(source), object);
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.r.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.c)(source, (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.f)(source), object);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.s : function(object) {
  var result = [];
  while (object) {
    (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.h)(result, (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.f)(object));
    object = (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.m)(object);
  }
  return result;
};

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.c)(source, getSymbolsIn(source), object);
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.j)(object, _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.k, getSymbolsIn);
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.U(result).set(new _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.U(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/** Used to convert symbols to primitives and strings. */
var symbolProto = _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.S ? _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.S.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$1:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$2:
      return new Ctor;

    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);

    case regexpTag$1:
      return cloneRegExp(object);

    case setTag$2:
      return new Ctor;

    case symbolTag$1:
      return cloneSymbol(object);
  }
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !(0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.e)(object))
    ? baseCreate((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.m)(object))
    : {};
}

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.k)(value) && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.g)(value) == mapTag$1;
}

/* Node.js helper references. */
var nodeIsMap = _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.o && _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.o.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.n)(nodeIsMap) : baseIsMap;

/** `Object#toString` result references. */
var setTag$1 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.k)(value) && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.g)(value) == setTag$1;
}

/* Node.js helper references. */
var nodeIsSet = _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.o && _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.o.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.n)(nodeIsSet) : baseIsSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$1 = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!(0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.j)(value)) {
    return value;
  }
  var isArr = (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.a)(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.g)(value),
        isFunc = tag == funcTag || tag == genTag;

    if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_2__.b)(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.S);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.g)
    : (isFlat ? _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.k : _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.b);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_1__.a)(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

function getFormattedDateString(date) {
    return new Date(Number(date)).toISOString().replace("Z", "");
}
function parseFormattedDateString(date) {
    return new Date(date + "Z").getTime();
}
function mapObjectByProperty(items, key) {
    return items.map((item) => item[key]);
}
function itemInArray(array, item) {
    return array.some((element) => {
        return element.label === item.label;
    });
}
function isArrayUnique(arr) {
    return arr.every(function (a, idx, _arr) {
        return _arr.indexOf(a, idx + 1) >= 0 ? false : true;
    });
}
function removeDuplicatesFromArray(array) {
    /* works only for simple datatypes not objects */
    return array.filter(function (value, index, _array) {
        return _array.indexOf(value) === index;
    });
}
let translatedMonthMapper;
// Done to avoid making add createDataObject functions async
function initRecurrentIntervalName(strings) {
    const monthMapper = {
        1: "esriMonthJanuary",
        2: "esriMonthFebruary",
        3: "esriMonthMarch",
        4: "esriMonthApril",
        5: "esriMonthMay",
        6: "esriMonthJune",
        7: "esriMonthJuly",
        8: "esriMonthAugust",
        9: "esriMonthSeptember",
        10: "esriMonthOctober",
        11: "esriMonthNovember",
        12: "esriMonthDecember"
    };
    translatedMonthMapper = {
        1: strings[monthMapper[1]],
        2: strings[monthMapper[2]],
        3: strings[monthMapper[3]],
        4: strings[monthMapper[4]],
        5: strings[monthMapper[5]],
        6: strings[monthMapper[6]],
        7: strings[monthMapper[7]],
        8: strings[monthMapper[8]],
        9: strings[monthMapper[9]],
        10: strings[monthMapper[10]],
        11: strings[monthMapper[11]],
        12: strings[monthMapper[12]]
    };
}
function getRecurrentIntervalName(value, interval, intervalUnitStr) {
    const getMonthName = (month) => translatedMonthMapper[month];
    const formatValueName = (month) => `${value} (${getMonthName(month)})`;
    const formatIntervalName = (start, end) => `${value} (${getMonthName(start)} - ${getMonthName(end)})`;
    // check if intervalUnitStr is undefined / empty / null
    if (intervalUnitStr && intervalUnitStr === "") {
        return value.toString();
    }
    const isIntervalUnitMonth = intervalUnitStr === "Months";
    const isIntervalUnitQuarter = intervalUnitStr === "Quarters";
    if (!isIntervalUnitMonth && !isIntervalUnitQuarter) {
        return value.toString();
    }
    // Interval = Monthly => Values should be Jan, Feb, Mar, Apr etc
    if (interval == 1 && isIntervalUnitMonth) {
        return formatValueName(+value);
    }
    // Interval = Quarterly  => Values should be Jan-Mar, Apr-Jun etc
    // Quarterly could mean interval unit as 1 quarter or 3 months.
    // Dimension values will be as follows:
    // Interval unit - 1 quarter : 1,2,3,4
    // Interval unit - 3 months : 1,4,7,10
    switch (+value) {
        case 1:
            return formatIntervalName(1, 3);
        case 2:
            return formatIntervalName(4, 6);
        case 3:
        case 7:
            return formatIntervalName(7, 9);
        case 4:
            return isIntervalUnitQuarter ? formatIntervalName(10, 12) : formatIntervalName(4, 6);
        case 10:
            return formatIntervalName(10, 12);
    }
    return value.toString();
}
/**
 * Retrieves an array of variables from the given multidimensional data.
 *
 * @param {GetVariablesOptions} options - The options for getting variables.
 * @param {MultidimensionalInfo} options.multiDimensionalData - The multidimensional data containing variables.
 * @param {string[]} [options.selectedVariables=[]] - An array of selected variable names.
 * @returns {MultiDimensionalVariable[]} An array of multi-dimensional variables.
 */
function getVariables(options) {
    const { multiDimensionalData, selectedVariables = [] } = options;
    // If selectedVariables is empty, return all variables
    const variables = multiDimensionalData.variables.filter((variable) => {
        const isVariableSelected = selectedVariables.some((selectedVariable) => {
            // Handle cases of persisted data and first-time data
            return selectedVariable === variable.name;
        });
        // Return true for variables that should remain in the array
        return selectedVariables.length > 0
            ? isVariableSelected // Return true if variable is found in selectedVariables
            : true; // If length is 0, return true to keep all variables in the array
    });
    return variables;
}
/**
 * Retrieves an array of selected dimensions from the given array of multidimensional variables.
 *
 * If the array of multidimensional variables is empty, all dimensions of all variables are returned.
 * If the selected dimension is empty, all dimensions of the variables are returned.
 *
 * @param {GetDimensionsOptions} options - The options for getting dimensions.
 * @param {MultiDimensionalVariable[]} options.variables - An array of multidimensional variables.
 * @param {string} [options.selectedDimension=""] - The name of the selected dimension.
 * @returns {MultiDimensionalDimension[]} An array of multi-dimensional dimensions.
 */
function getDimensions(options) {
    const { variables = [], selectedDimension = "" } = options;
    const dimensions = variables.reduce((acc, variable) => {
        const dim = variable.dimensions.filter((dimension) => (0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_0__.i)(selectedDimension) ? true : dimension.name === selectedDimension);
        return dim.length ? [...acc, ...dim] : acc;
    }, []);
    return dimensions;
}
/**
 * Takes an array of Multidimensional Dimensions and returns formatted label and values
 * based on dimension ranges and recurring options.
 *
 * @param {MultiDimensionalDimension[]} dimensions - An array of Multidimensional Dimensions.
 * @returns {MultidimensionalDropdownOption[]} Formatted dimension values for dropdown options.
 */
function getFormattedDimensionValues(dimensions) {
    const data = [];
    const STD_TIME = "StdTime";
    dimensions.forEach(function (dimension) {
        const hasRanges = dimension.hasRanges;
        const isRecurring = dimension.recurring;
        let dropdownOption;
        dimension.values.forEach(function (val) {
            // Value can be a number, string, or array of string|number.
            // Convert everything to an array to keep operations uniform.
            let dimensionValue = clone(val);
            if (!hasRanges) {
                // If dimension does not have ranges, dimension will be a string or number
                dimensionValue = [dimensionValue];
            }
            if (dimension.name === STD_TIME) {
                dimensionValue = dimensionValue.map((dim) => isRecurring
                    ? getRecurrentIntervalName(dim, dimension.interval, dimension.intervalUnit)
                    : getFormattedDateString(Number(dim)));
            }
            const option = hasRanges ? dimensionValue.join(" — ") : dimensionValue.join("");
            dropdownOption = {
                label: option,
                key: isRecurring ? (hasRanges ? val.join(" — ") : val.toString()) : option
            };
            if (!itemInArray(data, dropdownOption)) {
                data.push(dropdownOption);
            }
        });
    });
    return data;
}
function dimensionHasRanges(dimensions) {
    let hasRanges = false;
    if (dimensions.length > 0) {
        hasRanges = dimensions[0].hasRanges;
    }
    return hasRanges;
}
function getFormattedDimensionRanges(dropdownOptions) {
    const dimensionMinRanges = [];
    const dimensionMaxRanges = [];
    dropdownOptions.forEach((dropdownOption) => {
        const labels = dropdownOption.label.split(" — ");
        dimensionMinRanges.push({
            label: labels[0],
            key: labels[0]
        });
        dimensionMaxRanges.push({
            label: labels[1],
            key: labels[1]
        });
    });
    return {
        min: dimensionMinRanges,
        max: dimensionMaxRanges
    };
}
/**
 * Gets the corresponding dimension range based on the minDimension value.
 *
 * @param {MultiDimensionalDimension} dimension - The dimension object.
 * @param {DimensionValue} minDimension - The minimum dimension value.
 * @returns {DimensionValue} The corresponding dimension range.
 */
function getCorrespondingDimensionRange(dimension, minDimension) {
    const STD_TIME = "StdTime";
    const isDimensionStdTime = dimension.name === STD_TIME;
    const tempMinDimension = isDimensionStdTime && typeof minDimension === "string" ? parseFormattedDateString(minDimension) : minDimension;
    // Find the corresponding dimensionPair based on the minDimension value
    const dimensionPair = dimension.values.find((_dimension) => _dimension[0] === tempMinDimension);
    // Handle special formatting for StdTime dimension
    if (typeof dimensionPair === "object" && isDimensionStdTime) {
        return dimensionPair.map((dim) => getFormattedDateString(Number(dim)));
    }
    return dimensionPair;
}
/**
 * Takes an array of variables and returns an array of unique dimensions
 * of the passed variables as dropdown options.
 *
 * @param {MultidimensionalInfo} multidimensionalInfo - The multidimensional data information.
 * @param {SelectedVariable[]} selectedVariables - The selected variables.
 * @returns {DimensionDropdownOption[]} An array of dimension dropdown options.
 */
function getUniqueDimensionsForSelectedVariables(multidimensionalInfo, selectedVariables) {
    const variables = getVariables({
        multiDimensionalData: multidimensionalInfo,
        selectedVariables: selectedVariables
    });
    const dimensions = getDimensions({ variables });
    const dimensionNames = mapObjectByProperty(dimensions, "name");
    const uniqueDimensionNames = removeDuplicatesFromArray(dimensionNames);
    return uniqueDimensionNames;
}
/**
 * Takes in a single dimension parameter of selected variables
 * and returns an aggreagate of all the dimension values.
 */
function getDimensionValuesForSelectedDimension(multiDimensionalData, selectedVariables, selectedDimension) {
    // extract selected variables from MD data
    const variables = getVariables({
        multiDimensionalData: multiDimensionalData,
        selectedVariables: selectedVariables
    });
    // extract dimensions from the extracted variables
    const dimensions = getDimensions({
        variables: variables,
        selectedDimension: selectedDimension
    });
    const gridDimensionValuesOptions = getFormattedDimensionValues(dimensions);
    return gridDimensionValuesOptions;
}
function getDimensionRangeValuesForSelectedDimension(multiDimensionalData, selectedVariables, selectedDimension) {
    // extract selected variables from MD data
    const variables = getVariables({
        multiDimensionalData: multiDimensionalData,
        selectedVariables: selectedVariables
    });
    // extract dimensions from the extracted variables
    const dimensions = getDimensions({
        variables: variables,
        selectedDimension: selectedDimension
    });
    const gridDimensionValuesOptions = getFormattedDimensionValues(dimensions);
    // for this.dimensionDefinition.BY_RANGES & this.dimensionDefinition.BY_ITERATION:
    let startValueOptions, endValueOptions;
    const hasRanges = dimensionHasRanges(dimensions);
    if (hasRanges) {
        const fromattedDimensions = getFormattedDimensionRanges(gridDimensionValuesOptions);
        startValueOptions = fromattedDimensions.min;
        endValueOptions = fromattedDimensions.max;
    }
    else {
        startValueOptions = clone(gridDimensionValuesOptions);
        endValueOptions = clone(gridDimensionValuesOptions);
    }
    return { startValueOptions: startValueOptions, endValueOptions: endValueOptions };
}
/**
 * Checks if a variable in a multidimensional dataset is a single slice.
 *
 * @param {MultidimensionalInfo} multidimensionalInfo - The multidimensional information.
 * @param {string} variable - The name of the variable to check.
 * @returns {boolean} True if the variable is a single slice, false otherwise.
 */
function isVariableSingleSlice(multidimensionalInfo, variable) {
    const multidimensionalInfoVariables = multidimensionalInfo?.variables;
    const mDimVariable = multidimensionalInfoVariables?.find((_variable) => variable === _variable.name);
    if (!mDimVariable) {
        return false;
    }
    const mDimVariableDimensions = mDimVariable.dimensions.reduce((accumulator, dimension) => {
        const dimensionName = dimension.name;
        accumulator[dimensionName] = dimension.values.length;
        return accumulator;
    }, {});
    return Object.values(mDimVariableDimensions).every((dimensionLength) => dimensionLength === 1);
}
function multidimensionalDefinitionParser(mdimDefinition, multidimensionalInfo) {
    const invalidDimensionDefinitionTypes = ["BY_ITERATION"];
    const isDefinitionTypeInvalid = invalidDimensionDefinitionTypes.includes(mdimDefinition.definitionType);
    if (isDefinitionTypeInvalid) {
        return false;
    }
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_0__.i)(multidimensionalInfo)) {
        return false;
    }
    const mdimDimensions = mdimDefinition.dimensions;
    if (!mdimDimensions) {
        return isVariableSingleSlice(multidimensionalInfo, mdimDefinition.variables[0]);
    }
    const isDimensionsUnique = isArrayUnique(mdimDimensions);
    if (!isDimensionsUnique) {
        return false;
    }
    const variables = getVariables({
        multiDimensionalData: multidimensionalInfo,
        selectedVariables: mdimDefinition.variables
    });
    const dimensions = getDimensions({ variables });
    const dimensionNames = mapObjectByProperty(dimensions, "name");
    const isItemInArray = (array, item) => array.indexOf(item) >= 0;
    const isEveryDimensionInMdimDef = dimensionNames.every((dimension) => isItemInArray(mdimDimensions, dimension));
    if (!isEveryDimensionInMdimDef) {
        return false;
    }
    const isDefinitionTypeByRanges = mdimDefinition.definitionType === "BY_RANGES";
    if (!isDefinitionTypeByRanges) {
        return isEveryDimensionInMdimDef;
    }
    const maxDimensionValues = mdimDefinition.maxValues;
    const minDimensionValues = mdimDefinition.minValues;
    const isMinAndMaxDimensionSame = maxDimensionValues.every((maxDimension, index) => {
        const selectedDimension = mdimDimensions[index];
        const dimensionsForSelectedDimension = getDimensions({
            variables,
            selectedDimension
        });
        const dimension = dimensionsForSelectedDimension.length > 0 ? dimensionsForSelectedDimension[0] : undefined;
        if (dimension && dimension.hasRanges) {
            const dimensionPair = getCorrespondingDimensionRange(dimension, minDimensionValues[index]);
            return maxDimension === dimensionPair[1];
        }
        return minDimensionValues[index] === maxDimension;
    });
    return isMinAndMaxDimensionSame;
}
function isItemInDropdown(dropdownData, item) {
    /** function to select a dropdown from a dropdown list */
    return dropdownData.some(function (dropdownDatum) {
        if (dropdownDatum.key === item) {
            return true;
        }
    });
}
function cloneData(data) {
    return clone(data);
}



//# sourceMappingURL=multidimensional-helper-fc8fbe0e.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTdmYjhlMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUN5SjtBQUNYOztBQUUvTTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzREFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFVLFNBQVMsMERBQUk7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUIsMERBQVUsU0FBUywwREFBTTtBQUM1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixrREFBSTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7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QUFLO0FBQ0wsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFaVI7O0FBRWpSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vbXVsdGlkaW1lbnNpb25hbC1oZWxwZXItZmM4ZmJlMGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaSBhcyBpc0VtcHR5RGF0YUl0ZW0gfSBmcm9tICcuL3R5cGUtZ2F1cmRzLTE4NDA3NDdmLmpzJztcbmltcG9ydCB7IGMgYXMgY29weU9iamVjdCwgYiBhcyBrZXlzLCBrIGFzIGtleXNJbiwgZiBhcyBnZXRTeW1ib2xzLCBzIGFzIHN0dWJBcnJheSwgaCBhcyBhcnJheVB1c2gsIGogYXMgYmFzZUdldEFsbEtleXMsIFUgYXMgVWludDhBcnJheSwgUyBhcyBTdGFjaywgZyBhcyBnZXRBbGxLZXlzLCBhIGFzIGFzc2lnblZhbHVlIH0gZnJvbSAnLi9fVWludDhBcnJheS02OGUxZTNmOS5qcyc7XG5pbXBvcnQgeyBqIGFzIGlzT2JqZWN0LCByIGFzIHJvb3QsIG0gYXMgZ2V0UHJvdG90eXBlLCBTIGFzIFN5bWJvbCwgZSBhcyBpc1Byb3RvdHlwZSwgayBhcyBpc09iamVjdExpa2UsIGcgYXMgZ2V0VGFnLCBuIGFzIGJhc2VVbmFyeSwgbyBhcyBub2RlVXRpbCwgYiBhcyBpc0J1ZmZlciwgYSBhcyBpc0FycmF5IH0gZnJvbSAnLi9fZ2V0VGFnLTk2YWYwMjlkLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWckMSA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnJDEgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnJDIgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWckMSA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyQxID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnJDIgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWckMSA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyQxID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyQxID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyQxID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnJDEgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnJDEgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnJDEgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyQxID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnJDEgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWckMSA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWckMSA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnJDEgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyQxID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnJDE6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnJDE6XG4gICAgY2FzZSBkYXRlVGFnJDE6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnJDE6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWckMTogY2FzZSBmbG9hdDY0VGFnJDE6XG4gICAgY2FzZSBpbnQ4VGFnJDE6IGNhc2UgaW50MTZUYWckMTogY2FzZSBpbnQzMlRhZyQxOlxuICAgIGNhc2UgdWludDhUYWckMTogY2FzZSB1aW50OENsYW1wZWRUYWckMTogY2FzZSB1aW50MTZUYWckMTogY2FzZSB1aW50MzJUYWckMTpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWckMjpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2UgbnVtYmVyVGFnJDE6XG4gICAgY2FzZSBzdHJpbmdUYWckMTpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWckMTpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWckMjpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnJDE6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWckMSA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWckMTtcbn1cblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNNYXAobmV3IE1hcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyQxID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZyQxO1xufVxuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUckMSA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRyQxO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZURlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbmZ1bmN0aW9uIGdldEZvcm1hdHRlZERhdGVTdHJpbmcoZGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIoZGF0ZSkpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIlpcIiwgXCJcIik7XG59XG5mdW5jdGlvbiBwYXJzZUZvcm1hdHRlZERhdGVTdHJpbmcoZGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlICsgXCJaXCIpLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIG1hcE9iamVjdEJ5UHJvcGVydHkoaXRlbXMsIGtleSkge1xuICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0pID0+IGl0ZW1ba2V5XSk7XG59XG5mdW5jdGlvbiBpdGVtSW5BcnJheShhcnJheSwgaXRlbSkge1xuICAgIHJldHVybiBhcnJheS5zb21lKChlbGVtZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmxhYmVsID09PSBpdGVtLmxhYmVsO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNBcnJheVVuaXF1ZShhcnIpIHtcbiAgICByZXR1cm4gYXJyLmV2ZXJ5KGZ1bmN0aW9uIChhLCBpZHgsIF9hcnIpIHtcbiAgICAgICAgcmV0dXJuIF9hcnIuaW5kZXhPZihhLCBpZHggKyAxKSA+PSAwID8gZmFsc2UgOiB0cnVlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlc0Zyb21BcnJheShhcnJheSkge1xuICAgIC8qIHdvcmtzIG9ubHkgZm9yIHNpbXBsZSBkYXRhdHlwZXMgbm90IG9iamVjdHMgKi9cbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIF9hcnJheSkge1xuICAgICAgICByZXR1cm4gX2FycmF5LmluZGV4T2YodmFsdWUpID09PSBpbmRleDtcbiAgICB9KTtcbn1cbmxldCB0cmFuc2xhdGVkTW9udGhNYXBwZXI7XG4vLyBEb25lIHRvIGF2b2lkIG1ha2luZyBhZGQgY3JlYXRlRGF0YU9iamVjdCBmdW5jdGlvbnMgYXN5bmNcbmZ1bmN0aW9uIGluaXRSZWN1cnJlbnRJbnRlcnZhbE5hbWUoc3RyaW5ncykge1xuICAgIGNvbnN0IG1vbnRoTWFwcGVyID0ge1xuICAgICAgICAxOiBcImVzcmlNb250aEphbnVhcnlcIixcbiAgICAgICAgMjogXCJlc3JpTW9udGhGZWJydWFyeVwiLFxuICAgICAgICAzOiBcImVzcmlNb250aE1hcmNoXCIsXG4gICAgICAgIDQ6IFwiZXNyaU1vbnRoQXByaWxcIixcbiAgICAgICAgNTogXCJlc3JpTW9udGhNYXlcIixcbiAgICAgICAgNjogXCJlc3JpTW9udGhKdW5lXCIsXG4gICAgICAgIDc6IFwiZXNyaU1vbnRoSnVseVwiLFxuICAgICAgICA4OiBcImVzcmlNb250aEF1Z3VzdFwiLFxuICAgICAgICA5OiBcImVzcmlNb250aFNlcHRlbWJlclwiLFxuICAgICAgICAxMDogXCJlc3JpTW9udGhPY3RvYmVyXCIsXG4gICAgICAgIDExOiBcImVzcmlNb250aE5vdmVtYmVyXCIsXG4gICAgICAgIDEyOiBcImVzcmlNb250aERlY2VtYmVyXCJcbiAgICB9O1xuICAgIHRyYW5zbGF0ZWRNb250aE1hcHBlciA9IHtcbiAgICAgICAgMTogc3RyaW5nc1ttb250aE1hcHBlclsxXV0sXG4gICAgICAgIDI6IHN0cmluZ3NbbW9udGhNYXBwZXJbMl1dLFxuICAgICAgICAzOiBzdHJpbmdzW21vbnRoTWFwcGVyWzNdXSxcbiAgICAgICAgNDogc3RyaW5nc1ttb250aE1hcHBlcls0XV0sXG4gICAgICAgIDU6IHN0cmluZ3NbbW9udGhNYXBwZXJbNV1dLFxuICAgICAgICA2OiBzdHJpbmdzW21vbnRoTWFwcGVyWzZdXSxcbiAgICAgICAgNzogc3RyaW5nc1ttb250aE1hcHBlcls3XV0sXG4gICAgICAgIDg6IHN0cmluZ3NbbW9udGhNYXBwZXJbOF1dLFxuICAgICAgICA5OiBzdHJpbmdzW21vbnRoTWFwcGVyWzldXSxcbiAgICAgICAgMTA6IHN0cmluZ3NbbW9udGhNYXBwZXJbMTBdXSxcbiAgICAgICAgMTE6IHN0cmluZ3NbbW9udGhNYXBwZXJbMTFdXSxcbiAgICAgICAgMTI6IHN0cmluZ3NbbW9udGhNYXBwZXJbMTJdXVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRSZWN1cnJlbnRJbnRlcnZhbE5hbWUodmFsdWUsIGludGVydmFsLCBpbnRlcnZhbFVuaXRTdHIpIHtcbiAgICBjb25zdCBnZXRNb250aE5hbWUgPSAobW9udGgpID0+IHRyYW5zbGF0ZWRNb250aE1hcHBlclttb250aF07XG4gICAgY29uc3QgZm9ybWF0VmFsdWVOYW1lID0gKG1vbnRoKSA9PiBgJHt2YWx1ZX0gKCR7Z2V0TW9udGhOYW1lKG1vbnRoKX0pYDtcbiAgICBjb25zdCBmb3JtYXRJbnRlcnZhbE5hbWUgPSAoc3RhcnQsIGVuZCkgPT4gYCR7dmFsdWV9ICgke2dldE1vbnRoTmFtZShzdGFydCl9IC0gJHtnZXRNb250aE5hbWUoZW5kKX0pYDtcbiAgICAvLyBjaGVjayBpZiBpbnRlcnZhbFVuaXRTdHIgaXMgdW5kZWZpbmVkIC8gZW1wdHkgLyBudWxsXG4gICAgaWYgKGludGVydmFsVW5pdFN0ciAmJiBpbnRlcnZhbFVuaXRTdHIgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IGlzSW50ZXJ2YWxVbml0TW9udGggPSBpbnRlcnZhbFVuaXRTdHIgPT09IFwiTW9udGhzXCI7XG4gICAgY29uc3QgaXNJbnRlcnZhbFVuaXRRdWFydGVyID0gaW50ZXJ2YWxVbml0U3RyID09PSBcIlF1YXJ0ZXJzXCI7XG4gICAgaWYgKCFpc0ludGVydmFsVW5pdE1vbnRoICYmICFpc0ludGVydmFsVW5pdFF1YXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIEludGVydmFsID0gTW9udGhseSA9PiBWYWx1ZXMgc2hvdWxkIGJlIEphbiwgRmViLCBNYXIsIEFwciBldGNcbiAgICBpZiAoaW50ZXJ2YWwgPT0gMSAmJiBpc0ludGVydmFsVW5pdE1vbnRoKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZU5hbWUoK3ZhbHVlKTtcbiAgICB9XG4gICAgLy8gSW50ZXJ2YWwgPSBRdWFydGVybHkgID0+IFZhbHVlcyBzaG91bGQgYmUgSmFuLU1hciwgQXByLUp1biBldGNcbiAgICAvLyBRdWFydGVybHkgY291bGQgbWVhbiBpbnRlcnZhbCB1bml0IGFzIDEgcXVhcnRlciBvciAzIG1vbnRocy5cbiAgICAvLyBEaW1lbnNpb24gdmFsdWVzIHdpbGwgYmUgYXMgZm9sbG93czpcbiAgICAvLyBJbnRlcnZhbCB1bml0IC0gMSBxdWFydGVyIDogMSwyLDMsNFxuICAgIC8vIEludGVydmFsIHVuaXQgLSAzIG1vbnRocyA6IDEsNCw3LDEwXG4gICAgc3dpdGNoICgrdmFsdWUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEludGVydmFsTmFtZSgxLCAzKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEludGVydmFsTmFtZSg0LCA2KTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0SW50ZXJ2YWxOYW1lKDcsIDkpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gaXNJbnRlcnZhbFVuaXRRdWFydGVyID8gZm9ybWF0SW50ZXJ2YWxOYW1lKDEwLCAxMikgOiBmb3JtYXRJbnRlcnZhbE5hbWUoNCwgNik7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0SW50ZXJ2YWxOYW1lKDEwLCAxMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYW4gYXJyYXkgb2YgdmFyaWFibGVzIGZyb20gdGhlIGdpdmVuIG11bHRpZGltZW5zaW9uYWwgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0dldFZhcmlhYmxlc09wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgZ2V0dGluZyB2YXJpYWJsZXMuXG4gKiBAcGFyYW0ge011bHRpZGltZW5zaW9uYWxJbmZvfSBvcHRpb25zLm11bHRpRGltZW5zaW9uYWxEYXRhIC0gVGhlIG11bHRpZGltZW5zaW9uYWwgZGF0YSBjb250YWluaW5nIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLnNlbGVjdGVkVmFyaWFibGVzPVtdXSAtIEFuIGFycmF5IG9mIHNlbGVjdGVkIHZhcmlhYmxlIG5hbWVzLlxuICogQHJldHVybnMge011bHRpRGltZW5zaW9uYWxWYXJpYWJsZVtdfSBBbiBhcnJheSBvZiBtdWx0aS1kaW1lbnNpb25hbCB2YXJpYWJsZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhcmlhYmxlcyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyBtdWx0aURpbWVuc2lvbmFsRGF0YSwgc2VsZWN0ZWRWYXJpYWJsZXMgPSBbXSB9ID0gb3B0aW9ucztcbiAgICAvLyBJZiBzZWxlY3RlZFZhcmlhYmxlcyBpcyBlbXB0eSwgcmV0dXJuIGFsbCB2YXJpYWJsZXNcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBtdWx0aURpbWVuc2lvbmFsRGF0YS52YXJpYWJsZXMuZmlsdGVyKCh2YXJpYWJsZSkgPT4ge1xuICAgICAgICBjb25zdCBpc1ZhcmlhYmxlU2VsZWN0ZWQgPSBzZWxlY3RlZFZhcmlhYmxlcy5zb21lKChzZWxlY3RlZFZhcmlhYmxlKSA9PiB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgY2FzZXMgb2YgcGVyc2lzdGVkIGRhdGEgYW5kIGZpcnN0LXRpbWUgZGF0YVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVmFyaWFibGUgPT09IHZhcmlhYmxlLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBmb3IgdmFyaWFibGVzIHRoYXQgc2hvdWxkIHJlbWFpbiBpbiB0aGUgYXJyYXlcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkVmFyaWFibGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gaXNWYXJpYWJsZVNlbGVjdGVkIC8vIFJldHVybiB0cnVlIGlmIHZhcmlhYmxlIGlzIGZvdW5kIGluIHNlbGVjdGVkVmFyaWFibGVzXG4gICAgICAgICAgICA6IHRydWU7IC8vIElmIGxlbmd0aCBpcyAwLCByZXR1cm4gdHJ1ZSB0byBrZWVwIGFsbCB2YXJpYWJsZXMgaW4gdGhlIGFycmF5XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhcmlhYmxlcztcbn1cbi8qKlxuICogUmV0cmlldmVzIGFuIGFycmF5IG9mIHNlbGVjdGVkIGRpbWVuc2lvbnMgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgbXVsdGlkaW1lbnNpb25hbCB2YXJpYWJsZXMuXG4gKlxuICogSWYgdGhlIGFycmF5IG9mIG11bHRpZGltZW5zaW9uYWwgdmFyaWFibGVzIGlzIGVtcHR5LCBhbGwgZGltZW5zaW9ucyBvZiBhbGwgdmFyaWFibGVzIGFyZSByZXR1cm5lZC5cbiAqIElmIHRoZSBzZWxlY3RlZCBkaW1lbnNpb24gaXMgZW1wdHksIGFsbCBkaW1lbnNpb25zIG9mIHRoZSB2YXJpYWJsZXMgYXJlIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7R2V0RGltZW5zaW9uc09wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgZ2V0dGluZyBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtNdWx0aURpbWVuc2lvbmFsVmFyaWFibGVbXX0gb3B0aW9ucy52YXJpYWJsZXMgLSBBbiBhcnJheSBvZiBtdWx0aWRpbWVuc2lvbmFsIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RlZERpbWVuc2lvbj1cIlwiXSAtIFRoZSBuYW1lIG9mIHRoZSBzZWxlY3RlZCBkaW1lbnNpb24uXG4gKiBAcmV0dXJucyB7TXVsdGlEaW1lbnNpb25hbERpbWVuc2lvbltdfSBBbiBhcnJheSBvZiBtdWx0aS1kaW1lbnNpb25hbCBkaW1lbnNpb25zLlxuICovXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHZhcmlhYmxlcyA9IFtdLCBzZWxlY3RlZERpbWVuc2lvbiA9IFwiXCIgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IHZhcmlhYmxlcy5yZWR1Y2UoKGFjYywgdmFyaWFibGUpID0+IHtcbiAgICAgICAgY29uc3QgZGltID0gdmFyaWFibGUuZGltZW5zaW9ucy5maWx0ZXIoKGRpbWVuc2lvbikgPT4gaXNFbXB0eURhdGFJdGVtKHNlbGVjdGVkRGltZW5zaW9uKSA/IHRydWUgOiBkaW1lbnNpb24ubmFtZSA9PT0gc2VsZWN0ZWREaW1lbnNpb24pO1xuICAgICAgICByZXR1cm4gZGltLmxlbmd0aCA/IFsuLi5hY2MsIC4uLmRpbV0gOiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBkaW1lbnNpb25zO1xufVxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBNdWx0aWRpbWVuc2lvbmFsIERpbWVuc2lvbnMgYW5kIHJldHVybnMgZm9ybWF0dGVkIGxhYmVsIGFuZCB2YWx1ZXNcbiAqIGJhc2VkIG9uIGRpbWVuc2lvbiByYW5nZXMgYW5kIHJlY3VycmluZyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7TXVsdGlEaW1lbnNpb25hbERpbWVuc2lvbltdfSBkaW1lbnNpb25zIC0gQW4gYXJyYXkgb2YgTXVsdGlkaW1lbnNpb25hbCBEaW1lbnNpb25zLlxuICogQHJldHVybnMge011bHRpZGltZW5zaW9uYWxEcm9wZG93bk9wdGlvbltdfSBGb3JtYXR0ZWQgZGltZW5zaW9uIHZhbHVlcyBmb3IgZHJvcGRvd24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkRGltZW5zaW9uVmFsdWVzKGRpbWVuc2lvbnMpIHtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgY29uc3QgU1REX1RJTUUgPSBcIlN0ZFRpbWVcIjtcbiAgICBkaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGRpbWVuc2lvbikge1xuICAgICAgICBjb25zdCBoYXNSYW5nZXMgPSBkaW1lbnNpb24uaGFzUmFuZ2VzO1xuICAgICAgICBjb25zdCBpc1JlY3VycmluZyA9IGRpbWVuc2lvbi5yZWN1cnJpbmc7XG4gICAgICAgIGxldCBkcm9wZG93bk9wdGlvbjtcbiAgICAgICAgZGltZW5zaW9uLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIC8vIFZhbHVlIGNhbiBiZSBhIG51bWJlciwgc3RyaW5nLCBvciBhcnJheSBvZiBzdHJpbmd8bnVtYmVyLlxuICAgICAgICAgICAgLy8gQ29udmVydCBldmVyeXRoaW5nIHRvIGFuIGFycmF5IHRvIGtlZXAgb3BlcmF0aW9ucyB1bmlmb3JtLlxuICAgICAgICAgICAgbGV0IGRpbWVuc2lvblZhbHVlID0gY2xvbmUodmFsKTtcbiAgICAgICAgICAgIGlmICghaGFzUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZGltZW5zaW9uIGRvZXMgbm90IGhhdmUgcmFuZ2VzLCBkaW1lbnNpb24gd2lsbCBiZSBhIHN0cmluZyBvciBudW1iZXJcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25WYWx1ZSA9IFtkaW1lbnNpb25WYWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uLm5hbWUgPT09IFNURF9USU1FKSB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uVmFsdWUgPSBkaW1lbnNpb25WYWx1ZS5tYXAoKGRpbSkgPT4gaXNSZWN1cnJpbmdcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRSZWN1cnJlbnRJbnRlcnZhbE5hbWUoZGltLCBkaW1lbnNpb24uaW50ZXJ2YWwsIGRpbWVuc2lvbi5pbnRlcnZhbFVuaXQpXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0Rm9ybWF0dGVkRGF0ZVN0cmluZyhOdW1iZXIoZGltKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gaGFzUmFuZ2VzID8gZGltZW5zaW9uVmFsdWUuam9pbihcIiDigJQgXCIpIDogZGltZW5zaW9uVmFsdWUuam9pbihcIlwiKTtcbiAgICAgICAgICAgIGRyb3Bkb3duT3B0aW9uID0ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBvcHRpb24sXG4gICAgICAgICAgICAgICAga2V5OiBpc1JlY3VycmluZyA/IChoYXNSYW5nZXMgPyB2YWwuam9pbihcIiDigJQgXCIpIDogdmFsLnRvU3RyaW5nKCkpIDogb3B0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFpdGVtSW5BcnJheShkYXRhLCBkcm9wZG93bk9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goZHJvcGRvd25PcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGRpbWVuc2lvbkhhc1JhbmdlcyhkaW1lbnNpb25zKSB7XG4gICAgbGV0IGhhc1JhbmdlcyA9IGZhbHNlO1xuICAgIGlmIChkaW1lbnNpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGFzUmFuZ2VzID0gZGltZW5zaW9uc1swXS5oYXNSYW5nZXM7XG4gICAgfVxuICAgIHJldHVybiBoYXNSYW5nZXM7XG59XG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWREaW1lbnNpb25SYW5nZXMoZHJvcGRvd25PcHRpb25zKSB7XG4gICAgY29uc3QgZGltZW5zaW9uTWluUmFuZ2VzID0gW107XG4gICAgY29uc3QgZGltZW5zaW9uTWF4UmFuZ2VzID0gW107XG4gICAgZHJvcGRvd25PcHRpb25zLmZvckVhY2goKGRyb3Bkb3duT3B0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IGRyb3Bkb3duT3B0aW9uLmxhYmVsLnNwbGl0KFwiIOKAlCBcIik7XG4gICAgICAgIGRpbWVuc2lvbk1pblJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbHNbMF0sXG4gICAgICAgICAgICBrZXk6IGxhYmVsc1swXVxuICAgICAgICB9KTtcbiAgICAgICAgZGltZW5zaW9uTWF4UmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsc1sxXSxcbiAgICAgICAgICAgIGtleTogbGFiZWxzWzFdXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogZGltZW5zaW9uTWluUmFuZ2VzLFxuICAgICAgICBtYXg6IGRpbWVuc2lvbk1heFJhbmdlc1xuICAgIH07XG59XG4vKipcbiAqIEdldHMgdGhlIGNvcnJlc3BvbmRpbmcgZGltZW5zaW9uIHJhbmdlIGJhc2VkIG9uIHRoZSBtaW5EaW1lbnNpb24gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtNdWx0aURpbWVuc2lvbmFsRGltZW5zaW9ufSBkaW1lbnNpb24gLSBUaGUgZGltZW5zaW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7RGltZW5zaW9uVmFsdWV9IG1pbkRpbWVuc2lvbiAtIFRoZSBtaW5pbXVtIGRpbWVuc2lvbiB2YWx1ZS5cbiAqIEByZXR1cm5zIHtEaW1lbnNpb25WYWx1ZX0gVGhlIGNvcnJlc3BvbmRpbmcgZGltZW5zaW9uIHJhbmdlLlxuICovXG5mdW5jdGlvbiBnZXRDb3JyZXNwb25kaW5nRGltZW5zaW9uUmFuZ2UoZGltZW5zaW9uLCBtaW5EaW1lbnNpb24pIHtcbiAgICBjb25zdCBTVERfVElNRSA9IFwiU3RkVGltZVwiO1xuICAgIGNvbnN0IGlzRGltZW5zaW9uU3RkVGltZSA9IGRpbWVuc2lvbi5uYW1lID09PSBTVERfVElNRTtcbiAgICBjb25zdCB0ZW1wTWluRGltZW5zaW9uID0gaXNEaW1lbnNpb25TdGRUaW1lICYmIHR5cGVvZiBtaW5EaW1lbnNpb24gPT09IFwic3RyaW5nXCIgPyBwYXJzZUZvcm1hdHRlZERhdGVTdHJpbmcobWluRGltZW5zaW9uKSA6IG1pbkRpbWVuc2lvbjtcbiAgICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGRpbWVuc2lvblBhaXIgYmFzZWQgb24gdGhlIG1pbkRpbWVuc2lvbiB2YWx1ZVxuICAgIGNvbnN0IGRpbWVuc2lvblBhaXIgPSBkaW1lbnNpb24udmFsdWVzLmZpbmQoKF9kaW1lbnNpb24pID0+IF9kaW1lbnNpb25bMF0gPT09IHRlbXBNaW5EaW1lbnNpb24pO1xuICAgIC8vIEhhbmRsZSBzcGVjaWFsIGZvcm1hdHRpbmcgZm9yIFN0ZFRpbWUgZGltZW5zaW9uXG4gICAgaWYgKHR5cGVvZiBkaW1lbnNpb25QYWlyID09PSBcIm9iamVjdFwiICYmIGlzRGltZW5zaW9uU3RkVGltZSkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uUGFpci5tYXAoKGRpbSkgPT4gZ2V0Rm9ybWF0dGVkRGF0ZVN0cmluZyhOdW1iZXIoZGltKSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGltZW5zaW9uUGFpcjtcbn1cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgdmFyaWFibGVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHVuaXF1ZSBkaW1lbnNpb25zXG4gKiBvZiB0aGUgcGFzc2VkIHZhcmlhYmxlcyBhcyBkcm9wZG93biBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7TXVsdGlkaW1lbnNpb25hbEluZm99IG11bHRpZGltZW5zaW9uYWxJbmZvIC0gVGhlIG11bHRpZGltZW5zaW9uYWwgZGF0YSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7U2VsZWN0ZWRWYXJpYWJsZVtdfSBzZWxlY3RlZFZhcmlhYmxlcyAtIFRoZSBzZWxlY3RlZCB2YXJpYWJsZXMuXG4gKiBAcmV0dXJucyB7RGltZW5zaW9uRHJvcGRvd25PcHRpb25bXX0gQW4gYXJyYXkgb2YgZGltZW5zaW9uIGRyb3Bkb3duIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdldFVuaXF1ZURpbWVuc2lvbnNGb3JTZWxlY3RlZFZhcmlhYmxlcyhtdWx0aWRpbWVuc2lvbmFsSW5mbywgc2VsZWN0ZWRWYXJpYWJsZXMpIHtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBnZXRWYXJpYWJsZXMoe1xuICAgICAgICBtdWx0aURpbWVuc2lvbmFsRGF0YTogbXVsdGlkaW1lbnNpb25hbEluZm8sXG4gICAgICAgIHNlbGVjdGVkVmFyaWFibGVzOiBzZWxlY3RlZFZhcmlhYmxlc1xuICAgIH0pO1xuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKHsgdmFyaWFibGVzIH0pO1xuICAgIGNvbnN0IGRpbWVuc2lvbk5hbWVzID0gbWFwT2JqZWN0QnlQcm9wZXJ0eShkaW1lbnNpb25zLCBcIm5hbWVcIik7XG4gICAgY29uc3QgdW5pcXVlRGltZW5zaW9uTmFtZXMgPSByZW1vdmVEdXBsaWNhdGVzRnJvbUFycmF5KGRpbWVuc2lvbk5hbWVzKTtcbiAgICByZXR1cm4gdW5pcXVlRGltZW5zaW9uTmFtZXM7XG59XG4vKipcbiAqIFRha2VzIGluIGEgc2luZ2xlIGRpbWVuc2lvbiBwYXJhbWV0ZXIgb2Ygc2VsZWN0ZWQgdmFyaWFibGVzXG4gKiBhbmQgcmV0dXJucyBhbiBhZ2dyZWFnYXRlIG9mIGFsbCB0aGUgZGltZW5zaW9uIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGltZW5zaW9uVmFsdWVzRm9yU2VsZWN0ZWREaW1lbnNpb24obXVsdGlEaW1lbnNpb25hbERhdGEsIHNlbGVjdGVkVmFyaWFibGVzLCBzZWxlY3RlZERpbWVuc2lvbikge1xuICAgIC8vIGV4dHJhY3Qgc2VsZWN0ZWQgdmFyaWFibGVzIGZyb20gTUQgZGF0YVxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IGdldFZhcmlhYmxlcyh7XG4gICAgICAgIG11bHRpRGltZW5zaW9uYWxEYXRhOiBtdWx0aURpbWVuc2lvbmFsRGF0YSxcbiAgICAgICAgc2VsZWN0ZWRWYXJpYWJsZXM6IHNlbGVjdGVkVmFyaWFibGVzXG4gICAgfSk7XG4gICAgLy8gZXh0cmFjdCBkaW1lbnNpb25zIGZyb20gdGhlIGV4dHJhY3RlZCB2YXJpYWJsZXNcbiAgICBjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyh7XG4gICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICBzZWxlY3RlZERpbWVuc2lvbjogc2VsZWN0ZWREaW1lbnNpb25cbiAgICB9KTtcbiAgICBjb25zdCBncmlkRGltZW5zaW9uVmFsdWVzT3B0aW9ucyA9IGdldEZvcm1hdHRlZERpbWVuc2lvblZhbHVlcyhkaW1lbnNpb25zKTtcbiAgICByZXR1cm4gZ3JpZERpbWVuc2lvblZhbHVlc09wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXREaW1lbnNpb25SYW5nZVZhbHVlc0ZvclNlbGVjdGVkRGltZW5zaW9uKG11bHRpRGltZW5zaW9uYWxEYXRhLCBzZWxlY3RlZFZhcmlhYmxlcywgc2VsZWN0ZWREaW1lbnNpb24pIHtcbiAgICAvLyBleHRyYWN0IHNlbGVjdGVkIHZhcmlhYmxlcyBmcm9tIE1EIGRhdGFcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBnZXRWYXJpYWJsZXMoe1xuICAgICAgICBtdWx0aURpbWVuc2lvbmFsRGF0YTogbXVsdGlEaW1lbnNpb25hbERhdGEsXG4gICAgICAgIHNlbGVjdGVkVmFyaWFibGVzOiBzZWxlY3RlZFZhcmlhYmxlc1xuICAgIH0pO1xuICAgIC8vIGV4dHJhY3QgZGltZW5zaW9ucyBmcm9tIHRoZSBleHRyYWN0ZWQgdmFyaWFibGVzXG4gICAgY29uc3QgZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnMoe1xuICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgc2VsZWN0ZWREaW1lbnNpb246IHNlbGVjdGVkRGltZW5zaW9uXG4gICAgfSk7XG4gICAgY29uc3QgZ3JpZERpbWVuc2lvblZhbHVlc09wdGlvbnMgPSBnZXRGb3JtYXR0ZWREaW1lbnNpb25WYWx1ZXMoZGltZW5zaW9ucyk7XG4gICAgLy8gZm9yIHRoaXMuZGltZW5zaW9uRGVmaW5pdGlvbi5CWV9SQU5HRVMgJiB0aGlzLmRpbWVuc2lvbkRlZmluaXRpb24uQllfSVRFUkFUSU9OOlxuICAgIGxldCBzdGFydFZhbHVlT3B0aW9ucywgZW5kVmFsdWVPcHRpb25zO1xuICAgIGNvbnN0IGhhc1JhbmdlcyA9IGRpbWVuc2lvbkhhc1JhbmdlcyhkaW1lbnNpb25zKTtcbiAgICBpZiAoaGFzUmFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGZyb21hdHRlZERpbWVuc2lvbnMgPSBnZXRGb3JtYXR0ZWREaW1lbnNpb25SYW5nZXMoZ3JpZERpbWVuc2lvblZhbHVlc09wdGlvbnMpO1xuICAgICAgICBzdGFydFZhbHVlT3B0aW9ucyA9IGZyb21hdHRlZERpbWVuc2lvbnMubWluO1xuICAgICAgICBlbmRWYWx1ZU9wdGlvbnMgPSBmcm9tYXR0ZWREaW1lbnNpb25zLm1heDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0VmFsdWVPcHRpb25zID0gY2xvbmUoZ3JpZERpbWVuc2lvblZhbHVlc09wdGlvbnMpO1xuICAgICAgICBlbmRWYWx1ZU9wdGlvbnMgPSBjbG9uZShncmlkRGltZW5zaW9uVmFsdWVzT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0VmFsdWVPcHRpb25zOiBzdGFydFZhbHVlT3B0aW9ucywgZW5kVmFsdWVPcHRpb25zOiBlbmRWYWx1ZU9wdGlvbnMgfTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFyaWFibGUgaW4gYSBtdWx0aWRpbWVuc2lvbmFsIGRhdGFzZXQgaXMgYSBzaW5nbGUgc2xpY2UuXG4gKlxuICogQHBhcmFtIHtNdWx0aWRpbWVuc2lvbmFsSW5mb30gbXVsdGlkaW1lbnNpb25hbEluZm8gLSBUaGUgbXVsdGlkaW1lbnNpb25hbCBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YXJpYWJsZSAtIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YXJpYWJsZSBpcyBhIHNpbmdsZSBzbGljZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhcmlhYmxlU2luZ2xlU2xpY2UobXVsdGlkaW1lbnNpb25hbEluZm8sIHZhcmlhYmxlKSB7XG4gICAgY29uc3QgbXVsdGlkaW1lbnNpb25hbEluZm9WYXJpYWJsZXMgPSBtdWx0aWRpbWVuc2lvbmFsSW5mbz8udmFyaWFibGVzO1xuICAgIGNvbnN0IG1EaW1WYXJpYWJsZSA9IG11bHRpZGltZW5zaW9uYWxJbmZvVmFyaWFibGVzPy5maW5kKChfdmFyaWFibGUpID0+IHZhcmlhYmxlID09PSBfdmFyaWFibGUubmFtZSk7XG4gICAgaWYgKCFtRGltVmFyaWFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtRGltVmFyaWFibGVEaW1lbnNpb25zID0gbURpbVZhcmlhYmxlLmRpbWVuc2lvbnMucmVkdWNlKChhY2N1bXVsYXRvciwgZGltZW5zaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbk5hbWUgPSBkaW1lbnNpb24ubmFtZTtcbiAgICAgICAgYWNjdW11bGF0b3JbZGltZW5zaW9uTmFtZV0gPSBkaW1lbnNpb24udmFsdWVzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhtRGltVmFyaWFibGVEaW1lbnNpb25zKS5ldmVyeSgoZGltZW5zaW9uTGVuZ3RoKSA9PiBkaW1lbnNpb25MZW5ndGggPT09IDEpO1xufVxuZnVuY3Rpb24gbXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25QYXJzZXIobWRpbURlZmluaXRpb24sIG11bHRpZGltZW5zaW9uYWxJbmZvKSB7XG4gICAgY29uc3QgaW52YWxpZERpbWVuc2lvbkRlZmluaXRpb25UeXBlcyA9IFtcIkJZX0lURVJBVElPTlwiXTtcbiAgICBjb25zdCBpc0RlZmluaXRpb25UeXBlSW52YWxpZCA9IGludmFsaWREaW1lbnNpb25EZWZpbml0aW9uVHlwZXMuaW5jbHVkZXMobWRpbURlZmluaXRpb24uZGVmaW5pdGlvblR5cGUpO1xuICAgIGlmIChpc0RlZmluaXRpb25UeXBlSW52YWxpZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0VtcHR5RGF0YUl0ZW0obXVsdGlkaW1lbnNpb25hbEluZm8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWRpbURpbWVuc2lvbnMgPSBtZGltRGVmaW5pdGlvbi5kaW1lbnNpb25zO1xuICAgIGlmICghbWRpbURpbWVuc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFyaWFibGVTaW5nbGVTbGljZShtdWx0aWRpbWVuc2lvbmFsSW5mbywgbWRpbURlZmluaXRpb24udmFyaWFibGVzWzBdKTtcbiAgICB9XG4gICAgY29uc3QgaXNEaW1lbnNpb25zVW5pcXVlID0gaXNBcnJheVVuaXF1ZShtZGltRGltZW5zaW9ucyk7XG4gICAgaWYgKCFpc0RpbWVuc2lvbnNVbmlxdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB2YXJpYWJsZXMgPSBnZXRWYXJpYWJsZXMoe1xuICAgICAgICBtdWx0aURpbWVuc2lvbmFsRGF0YTogbXVsdGlkaW1lbnNpb25hbEluZm8sXG4gICAgICAgIHNlbGVjdGVkVmFyaWFibGVzOiBtZGltRGVmaW5pdGlvbi52YXJpYWJsZXNcbiAgICB9KTtcbiAgICBjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyh7IHZhcmlhYmxlcyB9KTtcbiAgICBjb25zdCBkaW1lbnNpb25OYW1lcyA9IG1hcE9iamVjdEJ5UHJvcGVydHkoZGltZW5zaW9ucywgXCJuYW1lXCIpO1xuICAgIGNvbnN0IGlzSXRlbUluQXJyYXkgPSAoYXJyYXksIGl0ZW0pID0+IGFycmF5LmluZGV4T2YoaXRlbSkgPj0gMDtcbiAgICBjb25zdCBpc0V2ZXJ5RGltZW5zaW9uSW5NZGltRGVmID0gZGltZW5zaW9uTmFtZXMuZXZlcnkoKGRpbWVuc2lvbikgPT4gaXNJdGVtSW5BcnJheShtZGltRGltZW5zaW9ucywgZGltZW5zaW9uKSk7XG4gICAgaWYgKCFpc0V2ZXJ5RGltZW5zaW9uSW5NZGltRGVmKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaXNEZWZpbml0aW9uVHlwZUJ5UmFuZ2VzID0gbWRpbURlZmluaXRpb24uZGVmaW5pdGlvblR5cGUgPT09IFwiQllfUkFOR0VTXCI7XG4gICAgaWYgKCFpc0RlZmluaXRpb25UeXBlQnlSYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGlzRXZlcnlEaW1lbnNpb25Jbk1kaW1EZWY7XG4gICAgfVxuICAgIGNvbnN0IG1heERpbWVuc2lvblZhbHVlcyA9IG1kaW1EZWZpbml0aW9uLm1heFZhbHVlcztcbiAgICBjb25zdCBtaW5EaW1lbnNpb25WYWx1ZXMgPSBtZGltRGVmaW5pdGlvbi5taW5WYWx1ZXM7XG4gICAgY29uc3QgaXNNaW5BbmRNYXhEaW1lbnNpb25TYW1lID0gbWF4RGltZW5zaW9uVmFsdWVzLmV2ZXJ5KChtYXhEaW1lbnNpb24sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRGltZW5zaW9uID0gbWRpbURpbWVuc2lvbnNbaW5kZXhdO1xuICAgICAgICBjb25zdCBkaW1lbnNpb25zRm9yU2VsZWN0ZWREaW1lbnNpb24gPSBnZXREaW1lbnNpb25zKHtcbiAgICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICAgIHNlbGVjdGVkRGltZW5zaW9uXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSBkaW1lbnNpb25zRm9yU2VsZWN0ZWREaW1lbnNpb24ubGVuZ3RoID4gMCA/IGRpbWVuc2lvbnNGb3JTZWxlY3RlZERpbWVuc2lvblswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRpbWVuc2lvbiAmJiBkaW1lbnNpb24uaGFzUmFuZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb25QYWlyID0gZ2V0Q29ycmVzcG9uZGluZ0RpbWVuc2lvblJhbmdlKGRpbWVuc2lvbiwgbWluRGltZW5zaW9uVmFsdWVzW2luZGV4XSk7XG4gICAgICAgICAgICByZXR1cm4gbWF4RGltZW5zaW9uID09PSBkaW1lbnNpb25QYWlyWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW5EaW1lbnNpb25WYWx1ZXNbaW5kZXhdID09PSBtYXhEaW1lbnNpb247XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzTWluQW5kTWF4RGltZW5zaW9uU2FtZTtcbn1cbmZ1bmN0aW9uIGlzSXRlbUluRHJvcGRvd24oZHJvcGRvd25EYXRhLCBpdGVtKSB7XG4gICAgLyoqIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIGRyb3Bkb3duIGZyb20gYSBkcm9wZG93biBsaXN0ICovXG4gICAgcmV0dXJuIGRyb3Bkb3duRGF0YS5zb21lKGZ1bmN0aW9uIChkcm9wZG93bkRhdHVtKSB7XG4gICAgICAgIGlmIChkcm9wZG93bkRhdHVtLmtleSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNsb25lRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIGNsb25lKGRhdGEpO1xufVxuXG5leHBvcnQgeyBjbG9uZSBhcyBhLCBnZXRVbmlxdWVEaW1lbnNpb25zRm9yU2VsZWN0ZWRWYXJpYWJsZXMgYXMgYiwgY2xvbmVEYXRhIGFzIGMsIGdldERpbWVuc2lvblZhbHVlc0ZvclNlbGVjdGVkRGltZW5zaW9uIGFzIGQsIGluaXRSZWN1cnJlbnRJbnRlcnZhbE5hbWUgYXMgZSwgZ2V0RGltZW5zaW9uUmFuZ2VWYWx1ZXNGb3JTZWxlY3RlZERpbWVuc2lvbiBhcyBnLCBpc0l0ZW1JbkRyb3Bkb3duIGFzIGksIG11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uUGFyc2VyIGFzIG0gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlkaW1lbnNpb25hbC1oZWxwZXItZmM4ZmJlMGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9