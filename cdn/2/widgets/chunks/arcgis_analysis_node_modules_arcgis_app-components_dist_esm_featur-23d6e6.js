"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_featur-23d6e6"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-layer-573bb473.js":
/*!*******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-layer-573bb473.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getLayerItemData),
/* harmony export */   B: () => (/* binding */ getSecuredAGSServiceInfo),
/* harmony export */   M: () => (/* binding */ MULTI_PART_UPLOAD_MINIMUM_SIZE),
/* harmony export */   a: () => (/* binding */ addSecureAGSUrl),
/* harmony export */   b: () => (/* binding */ addApplication),
/* harmony export */   c: () => (/* binding */ addFeatureLayer),
/* harmony export */   d: () => (/* binding */ addCloudProviderResource),
/* harmony export */   e: () => (/* binding */ addFile),
/* harmony export */   f: () => (/* binding */ fetchApplicationManifest),
/* harmony export */   g: () => (/* binding */ isAppComponentError),
/* harmony export */   h: () => (/* binding */ handleAddUrl),
/* harmony export */   i: () => (/* binding */ isHybridImageService),
/* harmony export */   j: () => (/* binding */ isBackendError),
/* harmony export */   k: () => (/* binding */ addFileFromDataUrl),
/* harmony export */   l: () => (/* binding */ selectOGCFeatureLayer),
/* harmony export */   m: () => (/* binding */ formatCustomParameters),
/* harmony export */   n: () => (/* binding */ getUrlServiceInfo),
/* harmony export */   o: () => (/* binding */ parseAGSType),
/* harmony export */   p: () => (/* binding */ processPostAddKML),
/* harmony export */   q: () => (/* binding */ getServiceAndLayerInfo),
/* harmony export */   r: () => (/* binding */ removeParameter),
/* harmony export */   s: () => (/* binding */ subscriptionState),
/* harmony export */   t: () => (/* binding */ isFolderRoot),
/* harmony export */   u: () => (/* binding */ addItem),
/* harmony export */   v: () => (/* binding */ findTemplateServiceInfo),
/* harmony export */   w: () => (/* binding */ createService),
/* harmony export */   x: () => (/* binding */ getItemStatus),
/* harmony export */   y: () => (/* binding */ uploadFile),
/* harmony export */   z: () => (/* binding */ registerApplication)
/* harmony export */ });
/* harmony import */ var _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config-75adf962.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-75adf962.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-4c3ae54c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-4c3ae54c.js");
/* harmony import */ var _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./item-properties-10491b2e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-properties-10491b2e.js");
/* harmony import */ var _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./add-item-dbbe2f57.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/add-item-dbbe2f57.js");
/* harmony import */ var _feature_layer_79fb302c_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./feature-layer-79fb302c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-layer-79fb302c.js");
/* harmony import */ var _functional_81373f6d_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./functional-81373f6d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-81373f6d.js");
/* harmony import */ var _server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./server-item-8d384796.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/server-item-8d384796.js");
/* harmony import */ var _portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./portal-d518b571.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-d518b571.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _ags_eb458a03_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ags-eb458a03.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/ags-eb458a03.js");
/* harmony import */ var _url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./url-35875a10.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-35875a10.js");
/* harmony import */ var _file_bf8ab90f_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./file-bf8ab90f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/file-bf8ab90f.js");
/* harmony import */ var _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./item-types-2029b06b.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-types-2029b06b.js");
/* harmony import */ var _guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./guid-aeaed84d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js");
/* harmony import */ var _store_6a88e6c5_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./store-6a88e6c5.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-6a88e6c5.js");
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


















function isFolderRoot(folder) {
    return (folder === null || folder === void 0 ? void 0 : folder.id) === (folder === null || folder === void 0 ? void 0 : folder.username);
}

/**
 * for AGS and OGC Feature Services urls, formatted params will be used for the service Info requests
 */
function addParameters(url) {
    const { customParameters: parameters } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a;
    const delimiter = url.includes("?") ? "&" : "?";
    const customParameters = (parameters === null || parameters === void 0 ? void 0 : parameters.map(({ parameter, value }) => `${parameter || ""}${parameter || value ? "=" : ""}${value || ""}`).join("&")) || "";
    if (!customParameters) {
        return url;
    }
    return `${url}${delimiter}${customParameters}`;
}
function removeParameter(url, { value, parameter }) {
    const paramStr = `${parameter}=${value}`;
    const resultUrl = url.replace(url[url.indexOf(paramStr) - 1] === "&" ? `&${paramStr}` : paramStr, "");
    return resultUrl[resultUrl.length - 1] === "?" ? resultUrl.replace("?", "") : resultUrl;
}

const errorCodeList = [
    "appExtensionError",
    "forbiddenCredential",
    "disabledSubscription",
    "unauthorized",
    "timeout",
    // --- Item error code
    "itemExists",
    "exceedsFileSize",
    "fileExists",
    "emptyFile",
    "unavailableGeocoder",
    "dataNotAvailable",
    "invalidShapefile",
    "invalidFileGeodatabase",
    "providePath",
    "useSameFileName",
    "invalidExtension",
    "tokenRequired",
    // --- Item properties error code
    "serviceNameInvalid",
    "titleInvalid",
    "titleRequired",
    "titleInUseService",
    "summaryInvalid",
    "missingUserOrPortal",
    "dataStoreTitleInvalid",
    // --- Services
    "serviceNameExists",
    // --- AGS, WMF, WMS, WFS, etc
    "serviceNotExist",
    "unsupportedWFSVersion",
    "invalidWMTS",
    "invalidSpatialRef",
    "emptyFeatureLayer",
    // --- Feature layer,
    "invalidFeatureLayerUrl",
    "invalidUrl",
    "httpWarning",
    // --- User error
    "flowAborted",
    // --- CSV error
    "duplicateFieldNames",
    "failToFetchText",
    // --- Tile layer
    "mapServiceError",
    "noTilingSchemeFound",
    "noMatchSpatialRef",
    // --- Datastore
    "invalidDataStorePublishType",
    "noRegisteredServersForDataStore",
    "noContentInDataStore",
    "failToPublishFromDataStore",
    "failToListDataStoreContents",
    "invalidUsernameOrPassword",
    "invalidJSON",
    // --- Internal error
    "unknownAGSType",
    "unhandledError",
    // -- Append errors
    "incompatibleGeometries",
    "multiPatchRestriction"
];
// * Utils
const isAppComponentError = (error) => errorCodeList.includes(error === null || error === void 0 ? void 0 : error.code);
const isBackendError = (error) => error &&
    error.hasOwnProperty("code") &&
    error.hasOwnProperty("message") &&
    error.hasOwnProperty("details") &&
    (!error.details || Array.isArray(error.details));

const unsubscribe = async (id) => {
    const subscriber = subscriptionState.subscribers[id];
    try {
        await (subscriber === null || subscriber === void 0 ? void 0 : subscriber.unsubscribe());
    }
    catch (error) {
        console.error(`Fail to call unsubscribe for ${subscriber.name}: ${error}`);
    }
};
const removeSubscriber = async (id) => {
    delete subscriptionState.subscribers[id];
};
const unsubscribeAll = async () => {
    await Promise.all(Object.keys(subscriptionState.subscribers).map(unsubscribe));
    subscriptionStore.reset();
};
const addSubscriber = (name, unsubscribe) => {
    const id = `${name}---${(0,_guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_14__.g)()}`;
    subscriptionState.subscribers[id] = { name, unsubscribe };
    return id;
};
const isSubscriberValid = (subscriptionId) => !!subscriptionState.subscribers[subscriptionId];
/** Used to keep track and handle all the long running job like polling and upload multi-part file */
const subscriptionStore = (0,_index_05956cab_js__WEBPACK_IMPORTED_MODULE_16__.c)({
    subscribers: {},
    unsubscribeAll,
    addSubscriber,
    unsubscribe,
    removeSubscriber,
    isSubscriberValid
});
const subscriptionState = subscriptionStore.state;

// File size constants
const MULTI_PART_UPLOAD_BATCH_SIZE = 26214400; // 25mb
const MULTI_PART_UPLOAD_MINIMUM_SIZE = 78643200; // 75mb
const MULTI_PART_UPLOAD_RETRIES = 5;
const MULTI_PART_UPLOAD_MAX_PARTS = 10000;
const MULTI_PART_UPLOAD_INITIAL_BATCH_SIZE = 3;
const MULTI_PART_UPLOAD_MAX_BATCH_SIZE = 10;

// The shape of customParamters in the component is different than how it needs to be formatted in the URLS, so we do that here.
function formatCustomParameters(customParams) {
    if (!customParams) {
        return null;
    }
    let appendAll = true;
    let customParameters = {};
    let customLayerParameters = {};
    // WMS and WMTS can have custom Paramters that only apply to the specific layer not the whole serviceInfo request - thats what were doing here.
    customParams.forEach(({ append, parameter, value }) => {
        if (append === "layer") {
            appendAll = false;
            customLayerParameters[parameter] = value;
        }
        else {
            customParameters[parameter] = value;
        }
    });
    return appendAll ? { customParameters } : { customParameters, customLayerParameters };
}

async function addApplication(item, restBaseUrl, appInfo) {
    if (item.type === "Desktop Application") {
        return addFile();
    }
    const response = await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.b)(item);
    if (item.type === "Application" || item.type === "API Key") {
        await registerApplication(response.id, restBaseUrl, appInfo);
    }
    return response;
}
async function registerApplication(itemId, restBaseUrl, appInfo) {
    const url = `${restBaseUrl}oauth2/registerApp`;
    let requestParam = {
        itemId,
        appType: "multiple",
        redirect_uris: JSON.stringify(["urn:ietf:wg:oauth:2.0:oob"])
    };
    const redirectUrlString = JSON.stringify(appInfo.redirect_uris);
    if (appInfo) {
        requestParam =
            appInfo.appType === "apikey"
                ? {
                    itemId,
                    appType: "apikey",
                    redirect_uris: redirectUrlString,
                    httpReferrers: JSON.stringify(appInfo.httpReferrers),
                    privileges: JSON.stringify(appInfo.privileges)
                }
                : { itemId, appType: appInfo.appType, redirect_uris: redirectUrlString, url: appInfo.url };
    }
    try {
        return { result: await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, requestParam, {}, "post") };
    }
    catch (error) {
        console.error("error:", error);
        return { error: { code: "unhandledError" } };
    }
}
async function fetchApplicationManifest(manifestUrl) {
    try {
        return { result: await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(manifestUrl, {}, { addTokenManually: false }), error: null };
    }
    catch (error) {
        console.error("error:", error);
        return { result: null, error: { code: "appExtensionError" } };
    }
}

const HIDDEN_MAP_DIV_ID = "hiddenMapDiv";
const destroyHiddenMapDiv = () => {
    const hiddenMapDiv = document.getElementById(HIDDEN_MAP_DIV_ID);
    if (hiddenMapDiv) {
        hiddenMapDiv.parentNode.removeChild(hiddenMapDiv);
    }
};
/** Return the id of the hidden map */
const createHiddenMapDiv = (width = 200, height = 130) => {
    let hiddenMapDiv = document.getElementById(HIDDEN_MAP_DIV_ID);
    if (!hiddenMapDiv) {
        hiddenMapDiv = document.createElement("div");
        hiddenMapDiv.id = HIDDEN_MAP_DIV_ID;
        hiddenMapDiv.style.position = "absolute";
        hiddenMapDiv.style.left = "-1000px";
        hiddenMapDiv.style.top = "-1000px";
        hiddenMapDiv.style.width = `${width}px`;
        hiddenMapDiv.style.height = `${height}px`;
        document.body.appendChild(hiddenMapDiv);
    }
    const hiddenMap = document.createElement("div");
    const hiddenMapId = "hiddenMap";
    hiddenMap.id = hiddenMapId;
    hiddenMap.style.width = `${width}px`;
    hiddenMap.style.height = `${height}px`;
    hiddenMapDiv.appendChild(hiddenMap);
    return hiddenMapId;
};

async function createThumbnailImage(map, config) {
    const [PrintTemplate, PrintParameters, PrintTask, esriConfig] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        "esri/tasks/PrintTemplate",
        "esri/tasks/PrintParameters",
        "esri/tasks/PrintTask",
        "esri/config"
    ]);
    const thumbnailWidth = 600;
    const thumbnailHeight = 400;
    const template = new PrintTemplate();
    template.layout = "MAP_ONLY";
    template.format = "png32";
    template.preserveScale = false;
    template.showAttribution = false;
    template.showLabels = false;
    template.exportOptions = {
        width: thumbnailWidth,
        height: thumbnailHeight,
        dpi: 96
    };
    const printTask = new PrintTask(config.self.helperServices.printTask.url, {});
    const params = new PrintParameters();
    params.map = map;
    params.template = template;
    esriConfig.defaults.io.timeout = 120000;
    // TODO: Some feature services need to be projected to WGS84 to generate correctly
    // Can set extent to geographicExtent here but should fix within PrintParameters
    return new Promise((resolve, reject) => {
        printTask.execute(params, (result) => {
            esriConfig.defaults.io.timeout = 60000;
            destroyHiddenMap(map);
            resolve(result.url);
        }, (err) => {
            esriConfig.defaults.io.timeout = 60000;
            reject(err);
        });
    });
}
async function createHiddenMap(webMapData, gcsExtentAsList) {
    const { config } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const itemInfo = { item: { extent: gcsExtentAsList }, itemData: webMapData };
    try {
        const [arcgisUtils] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/arcgis/utils"]);
        // Need to set this so "createMap" uses the correct portalUrl, in the future
        // "createMap" should really be improved to use the portal API, or a portalUrl parameter
        // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/14819
        arcgisUtils.arcgisUrl = `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.g)()}content/items`;
        const hiddenMapId = createHiddenMapDiv();
        const response = await arcgisUtils.createMap(itemInfo, hiddenMapId, {
            mapOptions: {
                nav: false
            },
            bingMapsKey: config.self.bingKey,
            geometryServiceURL: _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.portal.helperServices.geometry.url
        });
        const waitForHeatmapImageLayer = function (layer) {
            return new Promise((resolve) => {
                if (layer._heatmapManager) {
                    layer._heatmapManager.on("recalculateHeatmap", resolve);
                }
                else {
                    // layer might be out of scale
                    resolve();
                }
            });
        };
        const waitForWFSFeatures = (layer) => {
            // there is no event...
            const count = [0];
            return new Promise((resolve) => {
                const intHndl = setInterval((layer, count) => {
                    var _a;
                    if ((_a = layer.graphics) === null || _a === void 0 ? void 0 : _a.length) {
                        clearInterval(intHndl);
                        resolve();
                    }
                    else if (count[0] > 10) {
                        clearInterval(intHndl);
                        resolve();
                    }
                    else {
                        count[0] = count[0] + 1;
                    }
                }, 500, layer, count);
            });
        };
        const waitForUpdateStart = (layer) => {
            return new Promise((resolve) => {
                if (layer.declaredClass === "esri.layers.VectorTileLayer") {
                    // bug, doesn't call onUpdateStart sometimes
                    setTimeout(resolve, 5000);
                }
                layer.on("update-start", () => {
                    waitForUpdateEnd(layer).then(resolve);
                });
            });
        };
        const waitForUpdateEnd = function (layer) {
            return new Promise((resolve) => {
                if (!layer.updating) {
                    return resolve();
                }
                if (layer.declaredClass === "esri.layers.VectorTileLayer") {
                    // bug, doesn't call onUpdateEnd if there are no tiles in the view
                    setTimeout(resolve, 10000);
                }
                layer.on("update-end", resolve);
            });
        };
        const { map } = response;
        const promises = [];
        map.graphicsLayerIds.forEach((layerId) => {
            var _a;
            const layer = map.getLayer(layerId);
            if (((_a = layer.renderer) === null || _a === void 0 ? void 0 : _a.type) === "heatmap") {
                promises.push(waitForHeatmapImageLayer(layer));
            }
            else if (layer.declaredClass === "esri.layers.WFSLayer") {
                promises.push(waitForWFSFeatures(layer));
            }
            else if (layer.updating) {
                promises.push(waitForUpdateEnd(layer));
            }
        });
        map.layerIds.forEach((layerId) => {
            const lyr = response.map.getLayer(layerId);
            if (lyr.updating) {
                promises.push(waitForUpdateEnd(lyr));
            }
            else if (lyr.declaredClass === "esri.layers.VectorTileLayer") {
                // this is not working correctly in VTL; viewer should not have to wait for update start
                promises.push(waitForUpdateStart(lyr));
            }
        });
        if (promises.length) {
            await Promise.all(promises);
            // we need to wait a little longer
            await (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.t)(1000);
            return await createThumbnailImage(response.map, config);
        }
        else {
            return await createThumbnailImage(response.map, config);
        }
    }
    catch (error) {
        throw new Error(`Map creation failed: ${JSON.stringify(error)}`);
    }
}

async function buildThumbnailURLFromItemWebMap(webMap, gcsExtentAsList, spatialReference) {
    var _a;
    // TODO: remove this dependency
    const api = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api;
    // does not support heatmap renderer
    const [Geoprocessor] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([api === 3 ? "esri/tasks/Geoprocessor" : "esri/rest/geoprocessor"]);
    const { portal } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    ((_a = webMap.baseMap.baseMapLayers) !== null && _a !== void 0 ? _a : []).forEach((baseMapLayer) => {
        delete baseMapLayer.resourceInfo;
    });
    webMap.mapOptions = {
        showAttribution: false,
        extent: {
            xmin: gcsExtentAsList[0][0],
            ymin: gcsExtentAsList[0][1],
            xmax: gcsExtentAsList[1][0],
            ymax: gcsExtentAsList[1][1],
            spatialReference: {
                wkid: 4326
            }
        },
        spatialReference: spatialReference
    };
    webMap.exportOptions = {
        dpi: 96,
        outputSize: [600, 400]
    };
    webMap.layoutOptions = {};
    const params = {
        Web_Map_as_JSON: JSON.stringify(webMap),
        Format: "PNG32",
        Layout_Template: "MAP_ONLY"
    };
    if (api === 3) {
        const gp = new Geoprocessor(portal.helperServices.printTask.url);
        return new Promise((resolve, reject) => {
            gp.execute(params).then((response) => {
                if (response) {
                    let found = false;
                    for (let i = 0; i < response.length; i++) {
                        if (response[i].paramName === "Output_File") {
                            resolve(response[i].value.url);
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        reject();
                    }
                }
            });
        });
    }
    const { results } = await Geoprocessor.execute(portal.helperServices.printTask.url, params);
    const url = results.find((result) => result.dataType === "data-file" && result).value.url;
    if (!url) {
        // TODO: refactor this error to the new system
        throw new Error("Failed to create thumbnail");
    }
    return url;
}
function destroyHiddenMap(map) {
    var _a;
    map.destroy();
    (_a = document.getElementById("hiddenMapDiv")) === null || _a === void 0 ? void 0 : _a.removeChild(document.getElementById("hiddenMap"));
}
async function buildThumbnailURLFromWebMap(webMap, gcsExtentAsList) {
    return await createHiddenMap(webMap, gcsExtentAsList);
}

async function buildThumbnailURLFromKMLItem(item) {
    var _a;
    const [SpatialReference] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? "esri/geometry/SpatialReference" : "esri/SpatialReference"
    ]);
    const { config, portal } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const webMap = {};
    webMap.baseMap = config.defaultBasemap || portal.defaultBasemap;
    webMap.baseMap.title = "basemap";
    webMap.operationalLayers = [];
    let url = item.url;
    if (!url && item.type === "KML") {
        // loaded from a file KML
        url = config.restBaseUrl + "content/items/" + item.id + "/data";
    }
    // we don't have ID manager
    const restDomain = new URL(config.restBaseUrl).hostname;
    if (url.indexOf(restDomain) > -1) {
        const token = (_a = config === null || config === void 0 ? void 0 : config.userInfo) === null || _a === void 0 ? void 0 : _a.token;
        if (token) {
            url += "?token=" + token;
        }
    }
    webMap.operationalLayers.push({
        url,
        id: "KML_" + Math.random(),
        opacity: 1,
        title: item.title,
        visibility: true,
        type: "KML"
    });
    let ext = [];
    if (typeof item.extent === "string") {
        const e = item.extent.split(",");
        ext = [
            [parseFloat(e[0]), parseFloat(e[1])],
            [parseFloat(e[2]), parseFloat(e[3])]
        ];
    }
    else {
        if (item.extent && item.extent.length > 0) {
            ext = item.extent;
        }
        else {
            ext = [
                [-180, -90],
                [180, 90]
            ];
        }
    }
    return buildThumbnailURLFromItemWebMap(webMap, ext, new SpatialReference({ wkid: 4326 }));
}

const worldExtentInfo = {
    xmax: 20000000,
    xmin: -20000000,
    ymax: 20000000,
    ymin: -20000000,
    spatialReference: {
        wkid: 102100
    }
};
function wrapAround(wkid, geom) {
    const VALID_EXTENTS = {
        "102113": [-20037508.342788905, 20037508.342788905],
        "102100": [-20037508.342788905, 20037508.342788905],
        "3785": [-20037508.342788905, 20037508.342788905],
        "3857": [-20037508.342788905, 20037508.342788905],
        "4326": [-180, 180]
    };
    const valid = VALID_EXTENTS[wkid];
    if (valid) {
        if (geom.xmin > geom.xmax) {
            // wrap around
            const dif1 = valid[1] - geom.xmin;
            const dif2 = geom.xmax - valid[0];
            if (dif1 > dif2) {
                geom.xmax = valid[1] + dif2;
            }
            else {
                geom.xmin = valid[0] - dif1;
            }
        }
    }
}
function getSpatialReference(serviceInfo, agsType) {
    var _a, _b;
    const spatialReference = agsType !== "ImageServer" ? serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.spatialReference : (_a = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.extent) === null || _a === void 0 ? void 0 : _a.spatialReference;
    if (!spatialReference) {
        return null;
    }
    else if (spatialReference.wkid) {
        return spatialReference.wkid;
    }
    else if (((_b = spatialReference.wkt) === null || _b === void 0 ? void 0 : _b.search(/^PROJCS/i)) !== -1) {
        return /^PROJCS\["[A-Za-z0-9_]*/i.exec(spatialReference.wkt)[0].split("[")[1];
    }
    return null;
}
async function projectExtentToWGS84(extent) {
    var _a, _b;
    const [SpatialReference] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? "esri/geometry/SpatialReference" : "esri/SpatialReference"
    ]);
    const hasSR = ((_a = extent === null || extent === void 0 ? void 0 : extent.spatialReference) === null || _a === void 0 ? void 0 : _a.wkid) || ((_b = extent === null || extent === void 0 ? void 0 : extent.spatialReference) === null || _b === void 0 ? void 0 : _b.wkt);
    const GCS_WGS_1984 = new SpatialReference({ wkid: 4326 });
    const sameSpatialRef = await sameSpatialReference(GCS_WGS_1984, extent === null || extent === void 0 ? void 0 : extent.spatialReference);
    return hasSR && !sameSpatialRef ? await project(extent, GCS_WGS_1984) : extent;
}
async function projectExtentToWGS84FromItem(item) {
    const { extent } = item;
    item.extent = extentToString(await projectExtentToWGS84(extent));
    return item;
}
async function projectExtent(geometry, outSR) {
    const { portal } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const [mercatorUtils, GeometryService] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4
        ? ["esri/geometry/support/webMercatorUtils", "esri/rest/geometryService"]
        : ["esri/geometry/webMercatorUtils", "esri/tasks/GeometryService"]);
    const mercator = [102113, 102100, 3857];
    const wkid = geometry.spatialReference.wkid;
    // we only have 1 geometry anyway
    if (wkid === outSR.wkid) {
        return [geometry];
    }
    let geom;
    // going from GCS_WGS_1984 to mercator
    if (wkid === 4326 && mercator.indexOf(outSR.wkid) > -1) {
        // clip it, so it's not going to Infinity
        geometry.ymin = Math.max(geometry.ymin, -89.99);
        geometry.ymax = Math.min(geometry.ymax, 89.99);
        geom = mercatorUtils.geographicToWebMercator(geometry);
        wrapAround(outSR.wkid, geom);
        // geographicToWebMercator returns 102100; make sure it's what we want
        geom.spatialReference.wkid = outSR.wkid;
        return [geom];
    }
    if (mercator.indexOf(wkid) > -1 && outSR.wkid === 4326) {
        geom = mercatorUtils.webMercatorToGeographic(geometry);
        wrapAround(outSR.wkid, geom);
        return [geom];
    }
    else {
        return new Promise(async (resolve, reject) => {
            const geometryService = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? GeometryService : new GeometryService(portal.helperServices.geometry.url);
            const firstHandler = (result) => {
                // check if response is valid
                const first = result === null || result === void 0 ? void 0 : result[0];
                if ((first === null || first === void 0 ? void 0 : first.type) === "extent" &&
                    !isNaN(result[0].xmin) &&
                    !isNaN(result[0].ymin) &&
                    !isNaN(result[0].xmax) &&
                    !isNaN(result[0].ymax)) {
                    resolve(result);
                }
                else if ((first === null || first === void 0 ? void 0 : first.type) === "point" && !isNaN(result[0].x) && !isNaN(result[0].y)) {
                    resolve(result);
                }
                else {
                    throw new Error();
                }
            };
            if (_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
                try {
                    const [_ProjectParameters] = (await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/rest/support/ProjectParameters"]));
                    const projectParameters = new _ProjectParameters({ geometries: [geometry], outSpatialReference: outSR });
                    firstHandler(await geometryService.project(portal.helperServices.geometry.url, projectParameters));
                }
                catch (error) {
                    throw new Error(error);
                }
            }
            else {
                geometryService.project([geometry], outSR, firstHandler, (err) => {
                    reject(err);
                });
            }
        });
    }
}
async function project(extent, toExtent) {
    var _a;
    const [Extent] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/geometry/Extent"]);
    const worldExtent = new Extent(worldExtentInfo);
    const fullExtent = new Extent(extent);
    const result = await projectExtent(fullExtent, toExtent);
    return ((_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.type) === "extent" ? result[0] : worldExtent;
}
async function sameSpatialReference(sp1, sp2) {
    const mercator = [102113, 102100, 3857];
    if (((sp1 === null || sp1 === void 0 ? void 0 : sp1.wkt) == (sp2 === null || sp2 === void 0 ? void 0 : sp2.wkt) && ((sp1 === null || sp1 === void 0 ? void 0 : sp1.wkid) == (sp2 === null || sp2 === void 0 ? void 0 : sp2.wkid) || ((0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.i)(sp1.latestWkid) && (sp1 === null || sp1 === void 0 ? void 0 : sp1.latestWkid) == (sp2 === null || sp2 === void 0 ? void 0 : sp2.wkid)))) ||
        ((0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.i)(sp2 === null || sp2 === void 0 ? void 0 : sp2.latestWkid) && (sp1 === null || sp1 === void 0 ? void 0 : sp1.wkid) == (sp2 === null || sp2 === void 0 ? void 0 : sp2.latestWkid)) ||
        ((0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.i)(sp1 === null || sp1 === void 0 ? void 0 : sp1.latestWkid) && (sp1 === null || sp1 === void 0 ? void 0 : sp1.latestWkid) == (sp2 === null || sp2 === void 0 ? void 0 : sp2.latestWkid))) {
        return true;
    }
    else if ((sp1 === null || sp1 === void 0 ? void 0 : sp1.wkid) && (sp2 === null || sp2 === void 0 ? void 0 : sp2.wkid) && mercator.includes(sp1 === null || sp1 === void 0 ? void 0 : sp1.wkid) && mercator.includes(sp2 === null || sp2 === void 0 ? void 0 : sp2.wkid)) {
        return true;
    }
    return false;
}
async function getExtentWithFeatures(layer, extentAsList) {
    const { api } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const [SpatialReference] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        api === 4 ? "esri/geometry/SpatialReference" : "esri/SpatialReference"
    ]);
    const [FeatureLayer, StreamLayer] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/FeatureLayer", "esri/layers/StreamLayer"]);
    if (!layer || !(layer instanceof FeatureLayer) || layer instanceof StreamLayer) {
        return extentAsList;
    }
    if (api === 3) {
        try {
            // we want to zoom to where we see features
            await layer.addPlugin("esri/plugins/FeatureLayerStatistics");
            const info = await layer.statisticsPlugin.getSuggestedScaleRange();
            const { minScale, center, relaxedMinScale } = info;
            if (center) {
                // we need to use the width the scale is calculated with and then shrink down the map
                let extent = await getExtentFromCenter(center, 1280, minScale);
                if (info.relaxedMinScale > 0) {
                    // are we still in the scale of the layer for a 200 width map?
                    let scale = getScaleForExtent(extent, 200);
                    let width = 800;
                    while (scale > relaxedMinScale) {
                        extent = getExtentFromCenter(center, width, minScale);
                        scale = getScaleForExtent(extent, 200);
                        width -= 200;
                        if (width <= 0) {
                            // that's it, we can't do more. Thumbnail might look empty now.
                            break;
                        }
                    }
                }
                const result = await projectExtent(extent, new SpatialReference({ wkid: 4326 }));
                extentAsList = [
                    [result[0].xmin, result[0].ymin],
                    [result[0].xmax, result[0].ymax]
                ];
            }
        }
        catch (e) {
            console.warn(e);
        }
        return extentAsList;
    }
    // TODO: use esri/smartMapping/heuristics/scaleRange to zoom to features.
    return extentAsList;
}
async function getScaleForExtent(extent, width) {
    const [esriConfig, WKIDUnitConversion] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/config", "esri/WKIDUnitConversion"]);
    const INCHES_PER_METER = 39.37;
    const DEC_DEG_TO_METERS = 20015077.0 / 180.0;
    const spatialRef = extent.spatialReference;
    const wkid = spatialRef === null || spatialRef === void 0 ? void 0 : spatialRef.wkid;
    const wkt = spatialRef === null || spatialRef === void 0 ? void 0 : spatialRef.wkt;
    let unitValue = null;
    if (wkid) {
        unitValue = WKIDUnitConversion.values[WKIDUnitConversion[wkid]];
    }
    else if ((wkt === null || wkt === void 0 ? void 0 : wkt.search(/^PROJCS/i)) !== -1) {
        // well known text is PROJCS
        const result = /UNIT\[([^\]]+)\]\]$/i.exec(wkt);
        if (result === null || result === void 0 ? void 0 : result[1]) {
            unitValue = parseFloat(result[1].split(",")[1]);
        }
    }
    // else assumed to be in degrees
    return ((extent.getWidth() / width) * (unitValue || DEC_DEG_TO_METERS) * INCHES_PER_METER * esriConfig.defaults.screenDPI);
}
async function getExtentFromCenter(point, width, scale) {
    const [Extent] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/geometry/Extent"]);
    const extent = new Extent(point.x - 1, point.y - 0.5, point.x + 1, point.y + 0.5, point.spatialReference);
    return getExtentForScale(extent, width, scale);
}
async function getExtentForScale(extent, width, scale) {
    const [esriConfig, WKIDUnitConversion] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/config", "esri/WKIDUnitConversion"]);
    const INCHES_PER_METER = 39.37, DEC_DEG_TO_METERS = 20015077.0 / 180.0, lookup = WKIDUnitConversion;
    let wkid, wkt, sr = extent.spatialReference;
    if (sr) {
        wkid = sr.wkid;
        wkt = sr.wkt;
    }
    let unitValue = null;
    if (wkid) {
        unitValue = lookup.values[lookup[wkid]];
    }
    else if (wkt && wkt.search(/^PROJCS/i) !== -1) {
        const result = /UNIT\[([^\]]+)\]\]$/i.exec(wkt);
        if (result === null || result === void 0 ? void 0 : result[1]) {
            unitValue = parseFloat(result[1].split(",")[1]);
        }
    }
    // else assumed to be in degrees
    const newExtent = extent.expand((scale * width) /
        ((unitValue || DEC_DEG_TO_METERS) * INCHES_PER_METER * esriConfig.defaults.screenDPI) /
        extent.getWidth());
    return newExtent;
}
const isValidWGS84Extent = (extent) => {
    // Taken from Define Extent.js
    const inRange = (value, min, max) => value >= min && value <= max;
    return (inRange(extent.ymax, -90, 90) && // -90 <= maxy <= 90
        inRange(extent.ymin, -90, 90) && // -90 <= miny <= 90
        inRange(extent.xmax, -180, 180) && // -180 <= maxx <= 180
        inRange(extent.xmin, -180, 180) && // -180 <= minx <= 180
        extent.ymax > extent.ymin && // maxy > miny
        extent.xmax > extent.xmin // maxx > minx
    );
};
function extentToString(extent, places = 4) {
    if (!extent) {
        return extentToString(worldExtentInfo);
    }
    if (typeof extent === "string") {
        return extent;
    }
    if (Array.isArray(extent)) {
        if (Array.isArray(extent[0]) && Array.isArray(extent[1])) {
            let mins;
            let maxs;
            if (extent[0].length === 2) {
                mins = extent[0];
                maxs = extent[1];
            }
            // Refer to OGCExtent's bbox type
            if (extent[0].length === 4 || extent[0].length === 6) {
                mins = [extent[0][0], extent[0][1]];
                maxs = [extent[0][2], extent[0][3]];
                if (extent[0].length === 6) {
                    maxs = [extent[0][3], extent[0][4]];
                }
            }
            return `${mins.join(",")},${maxs.join(",")}`;
        }
        return extent.join(",");
    }
    const xmin = extent.xmin.toFixed(places);
    const ymin = extent.ymin.toFixed(places);
    const xmax = extent.xmax.toFixed(places);
    const ymax = extent.ymax.toFixed(places);
    return `${xmin},${ymin},${xmax},${ymax}`;
}

async function addKMLUrl(itemProperties, config, api) {
    try {
        const [extent, thumbnailURL] = await Promise.all([
            setKmlExtent(itemProperties.url, config, api),
            buildThumbnailURLFromKMLItem(itemProperties)
        ]);
        return await addUrl(Object.assign(Object.assign({}, itemProperties), { extent, thumbnailURL }));
    }
    catch (error) {
        throw error;
    }
}
async function setKmlExtent(url, config, api) {
    const [esriConfig, KMLLayer] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/config", "esri/layers/KMLLayer"]);
    if (api === 3) {
        esriConfig.defaults.kmlService = config.kmlService;
    }
    else {
        esriConfig.kmlServiceUrl = config.kmlService;
    }
    if (api === 4) {
        const kmlLayer = new KMLLayer({ url });
        await kmlLayer.load();
        const kmlExtent = kmlLayer.fullExtent;
        const extent = extentToString(kmlExtent);
        return extent;
    }
    const kmlLayer = new KMLLayer(url);
    return new Promise((resolve, reject) => {
        kmlLayer.on("load", async () => {
            const kmlExtent = await getKmlExtent(kmlLayer);
            resolve(kmlExtent ? extentToString(kmlExtent) : undefined);
        });
        kmlLayer.on("error", reject);
    });
}
async function getKmlExtent(kmlLayer) {
    const [graphicsUtils] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/graphicsUtils"]);
    const kmlLayers = kmlLayer.getLayers();
    let kmlExtent;
    kmlLayers.forEach((layer) => {
        var _a;
        if (((_a = layer.graphics) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            const layerExtent = graphicsUtils.graphicsExtent(layer.graphics);
            kmlExtent = !kmlExtent ? layerExtent : kmlExtent.union(layerExtent);
        }
    });
    return kmlExtent;
}
const processPostAddKML = async (itemId, portal, restBaseUrl, config, api) => {
    try {
        const baseUrl = portal.isPortal ? restBaseUrl : `https://${portal.portalHostname}/sharing/rest`;
        const url = portal.portalHostname ? `${baseUrl}/content/items/${itemId}/data` : `${(0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.g)(itemId)}/data`;
        const extent = await setKmlExtent(url, config, api);
        // TODO: Double check result type on URL refactor
        const result = await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.u)(itemId, { url, extent });
        return { result };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};

/** True if x doesn't hold a value. */
function isNone(x) {
    return x == null;
}

async function isTiledImageServiceLayer(layer) {
    if (_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
        return layer.type == "imagery-tile";
    }
    const [RasterXLayer] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/RasterXLayer"]);
    return layer instanceof RasterXLayer;
}
async function isImageServiceLayer(layer) {
    if (_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
        return layer.type === "imagery";
    }
    const [ArcGISImageServiceLayer, ArcGISImageServiceVectorLayer] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        "esri/layers/ArcGISImageServiceLayer",
        "esri/layers/ArcGISImageServiceVectorLayer"
    ]);
    return layer instanceof ArcGISImageServiceLayer || layer instanceof ArcGISImageServiceVectorLayer;
}
async function getDefaultPopupInfo(layerInfo, layer) {
    var _a, _b;
    const displayField = layerInfo.displayField;
    const title = layerInfo.name + ((displayField === null || displayField === void 0 ? void 0 : displayField.length) ? `: {${displayField}}` : "");
    let fields = layerInfo.fields;
    let isMosaicDatasetService = false;
    let isVectorMosaicDatasetService = false;
    let isIntegerImageService = false;
    const isImageService = await isImageServiceLayer(layer);
    const isTiledImageService = await isTiledImageServiceLayer(layer);
    if (isImageService || isTiledImageService) {
        const options = { rasterAttributeTableFieldPrefix: "Raster." };
        fields = (_a = layer.getCustomRasterFields) === null || _a === void 0 ? void 0 : _a.call(layer, options);
        isIntegerImageService = ["F32", "F64"].indexOf(layer.pixelType) < 0;
        //checking for single dataset image service
        if (layer === null || layer === void 0 ? void 0 : layer.capabilities) {
            isMosaicDatasetService = (layer === null || layer === void 0 ? void 0 : layer.capabilities.toLowerCase().indexOf("catalog")) > -1 || ((_b = layer.fields) === null || _b === void 0 ? void 0 : _b.length) > 0;
            isVectorMosaicDatasetService =
                isMosaicDatasetService &&
                    (layer.serviceDataType === "esriImageServiceDataTypeVector-UV" ||
                        layer.serviceDataType === "esriImageServiceDataTypeVector-MagDir");
        }
    }
    const decimal = {
        esriFieldTypeDouble: 1,
        esriFieldTypeSingle: 1
    };
    const integer = {
        esriFieldTypeInteger: 1,
        esriFieldTypeSmallInteger: 1
    };
    const dt = {
        esriFieldTypeDate: 1
    };
    // hide editor tracking fields
    let editTrackingFields = ",";
    if (layerInfo.editFieldsInfo) {
        if (layerInfo.editFieldsInfo.creatorField) {
            editTrackingFields += `${layerInfo.editFieldsInfo.creatorField},`;
        }
        if (layerInfo.editFieldsInfo.creationDateField) {
            editTrackingFields += `${layerInfo.editFieldsInfo.creationDateField},`;
        }
        if (layerInfo.editFieldsInfo.editorField) {
            editTrackingFields += `${layerInfo.editFieldsInfo.editorField},`;
        }
        if (layerInfo.editFieldsInfo.editDateField) {
            editTrackingFields += `${layerInfo.editFieldsInfo.editDateField},`;
        }
        editTrackingFields = editTrackingFields.toLowerCase();
    }
    const fieldInfos = fields.map((item) => {
        let visible = item.type !== "esriFieldTypeOID" &&
            item.type !== "esriFieldTypeGlobalID" &&
            item.type !== "esriFieldTypeGeometry";
        let format = null;
        let isEditable = item.editable && item.type !== "esriFieldTypeOID" && item.type !== "esriFieldTypeGlobalID";
        if (visible) {
            let f = item.name.toLowerCase();
            let hideFieldsStr = `${editTrackingFields}stretched value,fnode_,tnode_,lpoly_,rpoly_,poly_,subclass,subclass_,rings_ok,rings_nok,`;
            if (isMosaicDatasetService) {
                hideFieldsStr = `${hideFieldsStr}raster.itempixelvalue,`;
                if (isVectorMosaicDatasetService) {
                    hideFieldsStr = `${hideFieldsStr}raster.magnitude,raster.direction,`;
                }
            }
            if (hideFieldsStr.indexOf(`,${f},`) > -1 ||
                //f.indexOf("area") > -1 ||
                //f.indexOf("length") > -1 ||
                f.indexOf("shape") > -1 ||
                f.indexOf("perimeter") > -1 ||
                f.indexOf("objectid") > -1 ||
                f.indexOf("raster.servicepixelvalue.") > -1 ||
                //f.indexOf("_") == f.length - 1 ||
                f.indexOf("_i") == f.length - 2) {
                visible = false;
            }
            if (item.type in integer) {
                format = {
                    places: 0,
                    digitSeparator: true
                };
            }
            else if (item.type in decimal) {
                var rasterPixelValueField = isIntegerImageService &&
                    (f.indexOf("raster.servicepixelvalue") > -1 || f.indexOf("raster.itempixelvalue") > -1);
                format = {
                    places: rasterPixelValueField ? 0 : 2,
                    digitSeparator: true
                };
            }
            else if (item.type in dt && (layerInfo.currentVersion >= 10 || (layer === null || layer === void 0 ? void 0 : layer.version) >= 10)) {
                format = {
                    dateFormat: "longMonthDayYear"
                };
            }
        }
        isEditable = isEditable ? editTrackingFields.indexOf(`,${item.name.toLowerCase()},`) === -1 : isEditable;
        return {
            fieldName: item.name,
            label: item.alias,
            isEditable,
            tooltip: "",
            visible,
            format,
            stringFieldOption: "textbox"
        };
    });
    const popupInfo = {
        title: title,
        fieldInfos: fieldInfos,
        description: null,
        showAttachments: true,
        mediaInfos: [],
        layerOptions: undefined
    };
    if (isImageServiceLayer(layer)) {
        popupInfo.layerOptions = {};
        popupInfo.layerOptions.showNoDataRecords = true;
        popupInfo.layerOptions.returnTopmostRaster = true;
    }
    else if (isTiledImageServiceLayer(layer)) {
        popupInfo.layerOptions = {};
        popupInfo.layerOptions.showNoDataRecords = true;
    }
    return popupInfo;
}

const pointJson = {
    type: "esriSMS",
    style: "esriSMSCircle",
    color: [34, 114, 162, 128],
    size: 6,
    outline: {
        color: [34, 114, 162, 255],
        width: 1
    }
};
const lineJson = {
    type: "esriSLS",
    style: "esriSLSSolid",
    color: [77, 77, 77, 255],
    width: 1.5
};
const polygonJson = {
    type: "esriSFS",
    style: "esriSFSSolid",
    color: [227, 139, 79, 204],
    outline: {
        type: "esriSLS",
        style: "esriSLSSolid",
        color: [255, 255, 255, 255],
        width: 0.75
    }
};
async function getRendererAsJson(geometryType) {
    const [SimpleRenderer, esriJsonUtil] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        "esri/renderers/SimpleRenderer",
        _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? "esri/geometry/support/jsonUtils" : "esri/symbols/jsonUtils"
    ]);
    switch (geometryType) {
        case "esriGeometryPoint":
            return new SimpleRenderer(esriJsonUtil.fromJson(pointJson)).toJson();
        case "esriGeometryPolyline":
            return new SimpleRenderer(esriJsonUtil.fromJson(lineJson)).toJson();
        case "esriGeometryPolygon":
            return new SimpleRenderer(esriJsonUtil.fromJson(polygonJson)).toJson();
    }
}
async function getPopupInfo(wfsLayer) {
    const { fields, selectedLayer } = wfsLayer;
    if (fields === null || fields === void 0 ? void 0 : fields.length) {
        const nonGeomFields = fields.filter((field) => field.type !== "esriFieldTypeGeometry");
        if (nonGeomFields === null || nonGeomFields === void 0 ? void 0 : nonGeomFields.length) {
            return getDefaultPopupInfo({
                name: (selectedLayer === null || selectedLayer === void 0 ? void 0 : selectedLayer.title) || "",
                fields: fields
            }, wfsLayer);
        }
    }
}
async function getWfsConfig(wfsLayer) {
    const { layerNamespace, getFeatureUrl, spatialReferences, fields } = wfsLayer;
    const { maxFeatures, geometryType: addItemGeometryType } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a;
    let url;
    let mode;
    let version;
    let name;
    if (_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3) {
        const data = wfsLayer.toJson();
        url = data.url;
        mode = data.mode;
        version = data.version;
        name = data.name;
    }
    else {
        const v4WFS = wfsLayer;
        url = v4WFS.url;
        // mode = v4WFS.mode;
        version = "2.0.0";
        name = v4WFS.name;
    }
    const geometryType = addItemGeometryType || wfsLayer.geometryType || "esriGeometryComplex";
    return {
        url,
        mode,
        wfsInfo: {
            version,
            name,
            wfsNamespace: layerNamespace,
            featureUrl: getFeatureUrl,
            supportedSpatialReferences: spatialReferences,
            customParameters: wfsLayer.customParameters || {},
            maxFeatures: maxFeatures || wfsLayer.maxFeatures || 3000
        },
        layerDefinition: {
            geometryType: geometryType,
            drawingInfo: {
                renderer: await getRendererAsJson(geometryType)
            },
            spatialReference: {
                wkid: 4326
            },
            fields
        },
        popupInfo: await getPopupInfo(wfsLayer)
    };
}
async function buildThumbnailURLFromWFSItem(extent) {
    const { config } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const webMap = {
        baseMap: config.defaultBasemap || config.self.defaultBasemap,
        operationalLayers: []
    };
    const { baseMapLayers } = webMap.baseMap;
    // we need only one basemap layer and we hide it - use layerSet bool to check if one has been set already
    let layerSet = false;
    baseMapLayers.forEach((layer) => {
        if (!layer.isReference && !layerSet) {
            // we need only one basemap layer and we hide it
            if ((config.allSSL || location.protocol == "https:") &&
                ((0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.a)(layer.url) || (0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.b)(layer.url))) {
                layer.url = layer.url.replace("http:", "https:");
            }
            layer.visibility = false;
            layerSet = true;
            webMap.baseMap.baseMapLayers = [layer];
        }
    });
    const operationalLayer = {
        type: "WFS",
        layerType: "WFS",
        opacity: 1,
        visibility: true,
        id: "wfs_xxx",
        wfsInfo: {
            maxFeatures: 100
        }
    };
    webMap.operationalLayers.push(operationalLayer);
    return buildThumbnailURLFromItemWebMap(webMap, extent);
}
async function getWMTSConfig(wmtsLayer) {
    var _a;
    const is4xAPI = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4;
    function getTileInfoAsJson(selectedTileInfo) {
        const { tileInfo } = selectedTileInfo;
        if ((tileInfo === null || tileInfo === void 0 ? void 0 : tileInfo.dpi) !== 96) {
            tileInfo.lods.forEach((lod) => {
                lod.scale = (lod.scale * 96) / tileInfo.dpi;
            });
            tileInfo.dpi = 96;
        }
        return is4xAPI ? tileInfo : tileInfo.toJson();
    }
    function getCopyright(copyright) {
        if ((copyright === null || copyright === void 0 ? void 0 : copyright.toLowerCase()) !== "none") {
            return (copyright === null || copyright === void 0 ? void 0 : copyright.length) > 180 ? `${copyright.substring(0, 180)}..` : "";
        }
        else {
            return copyright;
        }
    }
    try {
        const [SpatialReference] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
            is4xAPI ? "esri/geometry/SpatialReference" : "esri/SpatialReference"
        ]);
        const { selectedLayer, selectedTileInfo, copyright } = wmtsLayer;
        const sr = (selectedTileInfo === null || selectedTileInfo === void 0 ? void 0 : selectedTileInfo.fullExtent.spatialReference) || new SpatialReference({ wkid: 4326 });
        const fullExtent = await projectExtent(selectedLayer === null || selectedLayer === void 0 ? void 0 : selectedLayer[is4xAPI ? "fullExtent" : "gcsExtent"], sr).then((result) => { var _a; return ((_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.type) === "extent" ? (_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? result[0] : result[0].toJson()) : null; });
        const format = selectedLayer[is4xAPI ? "imageFormat" : "formats"].indexOf("image/png") > -1
            ? "image/png"
            : selectedLayer.formats[0];
        wmtsLayer.resourceUrls = selectedLayer.resourceUrls;
        let templateUrl;
        if (is4xAPI) {
            templateUrl = wmtsLayer.getUrlTemplate(selectedLayer.id, selectedTileInfo.id, format, selectedLayer.styleId);
        }
        else {
            templateUrl = wmtsLayer.getTileUrlTemplate({
                identifier: selectedLayer.identifier,
                tileMatrixSet: selectedTileInfo.tileMatrixSet,
                format
            });
        }
        const wmtsConfig = {
            templateUrl,
            copyright: getCopyright(copyright),
            fullExtent: fullExtent || wmtsLayer.selectedTileInfo.fullExtent,
            tileInfo: getTileInfoAsJson(selectedTileInfo),
            wmtsInfo: {
                url: (_a = wmtsLayer.wmtsUrl) !== null && _a !== void 0 ? _a : wmtsLayer.url,
                layerIdentifier: selectedLayer.identifier,
                tileMatrixSet: selectedTileInfo.tileMatrixSet,
                customParameters: wmtsLayer.customParameters || {},
                customLayerParameters: wmtsLayer.customLayerParameters || {}
            }
        };
        return Promise.resolve({ wmtsConfig: wmtsConfig, fullExtent: fullExtent });
    }
    catch (error) {
        console.error(error);
        throw error; // TODO: refactor this to our error system
    }
}
/** HAZARD WARNING! Return a URL to the hosted image in 3.x case and base64 data url in 4.x case*/
async function buildThumbnailURLFromWMTSItem(item, newExtent) {
    if (_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3) {
        const baseMapLayerOpts = {
            opacity: 1,
            visibility: true,
            layerType: "WebTiledLayer",
            type: "WebTiledLayer"
        };
        const webMap = {
            baseMap: {
                title: "basemap",
                baseMapLayers: [],
                operationalLayers: []
            }
        };
        if (item.id) {
            const response = await getItemData(item.id);
            webMap.baseMap.baseMapLayers.push(Object.assign(Object.assign({}, response), baseMapLayerOpts));
        }
        else {
            webMap.baseMap.baseMapLayers.push(baseMapLayerOpts);
        }
        return buildThumbnailURLFromWebMap(webMap, newExtent || item.extent);
    }
    else {
        const [WMTSLayer, Map, MapView, reactiveUtils] = (await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
            "esri/layers/WMTSLayer",
            "esri/Map",
            "esri/views/MapView",
            "esri/core/reactiveUtils"
        ]));
        const wmtsLayer = new WMTSLayer({
            portalItem: {
                id: item.id,
                // @ts-ignore --- User.role is different in 3x
                portal: _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.portal
            }
        });
        const map = new Map({ layers: [wmtsLayer] });
        const hiddenMapId = createHiddenMapDiv();
        const view = new MapView({ container: hiddenMapId, map });
        await reactiveUtils.whenOnce(() => !view.updating);
        await view.goTo(wmtsLayer.fullExtent);
        const screenshot = await view.takeScreenshot({
            width: view.width,
            height: view.height,
            format: "png"
        });
        return screenshot.dataUrl;
    }
}
async function getItemData(id) {
    const { config } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const url = `${config.restBaseUrl}content/items/${id}/data`;
    try {
        const result = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, null, {
            disableIdentityLookup: true
        });
        if (result && ((result === null || result === void 0 ? void 0 : result.wfsInfo) || result.wmtsInfo)) {
            return result;
        }
        else if (result === null || result === void 0 ? void 0 : result.layers) {
            return result.layers;
        }
        return {};
    }
    catch (error) {
        return error;
    }
}

function getStaticImagesUrl(portal) {
    var _a;
    // @ts-ignore - this property is there in 4.x, their types are incorrect
    return ((_a = portal === null || portal === void 0 ? void 0 : portal.staticImagesUrl) === null || _a === void 0 ? void 0 : _a.replace("http:", "https:")) || "";
}
const checkThumbnailURL = (item) => {
    var _a;
    const portal = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.portal;
    if (item.thumbnailURL) {
        item.thumbnailURL = getStaticImagesUrl(portal) + item.thumbnailURL;
    }
    if (portal.isPortal && ((_a = item.thumbnailURL) === null || _a === void 0 ? void 0 : _a.indexOf("http")) !== 0) {
        // staticImagesUrl is relative
        item.thumbnailURL = window.location.protocol + "//" + window.location.host + item.thumbnailURL;
    }
    return item;
};

const stripParameters = (url, blackList) => {
    const [base, search] = url.split("?");
    const whitelisted = (search === null || search === void 0 ? void 0 : search.split("&").reduce((acc, section) => {
        const [key] = section.split("=");
        if (blackList.indexOf(key.toLowerCase()) === -1) {
            return `${acc}${acc ? "&" : "?"}${section}`;
        }
        return acc;
    }, "")) || "";
    return `${base}${whitelisted}`;
};
const getWMSServiceInfo = async (item) => {
    var _a;
    const [WMSLayer] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/WMSLayer"]);
    const { customParameters } = item;
    const formattedParams = formatCustomParameters(customParameters);
    // Remove these parameters from the url since the JSAPI will set them automatically
    const wmsUrl = stripParameters(item.url, [
        "service",
        "request",
        "bbox",
        "format",
        "height",
        "width",
        "layers",
        "srs",
        "crs",
        "styles",
        "transparent",
        "bgcolor",
        "exceptions",
        "time",
        "elevation",
        "sld",
        "wfs"
    ]);
    try {
        if (_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
            const wmsLayer = new WMSLayer({
                url: wmsUrl,
                customParameters: Object.assign({}, formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customParameters) || {},
                customLayerParameters: Object.assign({}, formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customLayerParameters) || {}
            });
            try {
                const loadedLayer = await wmsLayer.load();
                item.type = "WMS";
                return { result: Object.assign(Object.assign({}, item), { type: "WMS", serviceInfo: loadedLayer }) };
            }
            catch (err) {
                return {
                    error: {
                        code: err.message ? "unhandledError" : "serviceNotExist",
                        message: (_a = err.message) !== null && _a !== void 0 ? _a : err.message
                    }
                };
            }
        }
        // --- v3 ---
        await checkCORS(wmsUrl);
        const wmsLayer = new WMSLayer(wmsUrl, {
            customParameters: Object.assign({}, formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customParameters) || {},
            customLayerParameters: Object.assign({}, formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customLayerParameters) || {}
        });
        const result = await new Promise((resolve, reject) => {
            wmsLayer.on("load", () => {
                item.type = "WMS";
                resolve(Object.assign(Object.assign({}, item), { type: "WMS", serviceInfo: wmsLayer }));
            });
            wmsLayer.on("error", (err) => {
                var _a;
                const { error } = err;
                const serviceNotExist = !(error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.status) === 404;
                reject({
                    code: serviceNotExist ? "serviceNotExist" : "unhandledError",
                    message: (_a = error.message) !== null && _a !== void 0 ? _a : err.message
                });
            });
        });
        return { result };
    }
    catch (error) {
        console.error(error);
        return { error };
    }
};
// this will correctly format the layers from the service info to be used in the bulk layer select component
const loadWMSLayers = async (serviceInfo) => {
    const loadedServiceInfo = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? await serviceInfo.load() : serviceInfo;
    const { layerInfos, title, allSublayers } = loadedServiceInfo;
    const layers = getWMSLayerTree(_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? allSublayers.items : layerInfos);
    // TODO: move title to base serviceInfo fetch, only return layers here
    return { title, layers };
};
function getWMSLayerTree(layers) {
    return layers.map((layer) => ({
        name: layer.name,
        visible: false,
        title: layer.title.replace(/ /g, String.fromCharCode(160)),
        extent: layer.extent,
        legendURL: layer.legendURL,
        queryable: layer.queryable,
        subLayers: layer.subLayers || []
    }));
}
function flattenLayerAndRemoveIds(flattenedLayers = [], layer) {
    delete layer.id;
    if (!layer.subLayers || !layer.subLayers.length) {
        return [...flattenedLayers, layer];
    }
    else {
        return layer.subLayers.reduce(flattenLayerAndRemoveIds, flattenedLayers);
    }
}
const addWMSUrl = async (item) => {
    const [SpatialReference] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? "esri/geometry/SpatialReference" : "esri/SpatialReference"
    ]);
    const { layers } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a;
    if (!item || !(item === null || item === void 0 ? void 0 : item.serviceInfo)) {
        return Promise.reject(new Error("serviceNotExist"));
    }
    const itemInfo = checkThumbnailURL(item);
    const { serviceInfo } = itemInfo;
    const visibleLayers = [];
    let fullExtent;
    const flattenedLayers = layers.reduce(flattenLayerAndRemoveIds, []);
    const selectedLayers = flattenedLayers.map((layer) => {
        fullExtent = !fullExtent ? layer.extent : layer.extent ? fullExtent.union(layer.extent) : fullExtent;
        visibleLayers.push(layer.name);
        const obj = { name: layer.name, title: layer.title, legendURL: "", queryable: layer.queryable };
        if (layer.legendURL) {
            obj.legendURL = layer.legendURL;
        }
        return obj;
    });
    serviceInfo.setVisibleLayers(visibleLayers);
    fullExtent = fullExtent || serviceInfo.fullExtent;
    const isGCS = !serviceInfo.spatialReferences.some((sr) => sr === fullExtent.spatialReference.wkid);
    const updatedItem = {
        type: item.type,
        url: serviceInfo.url,
        description: serviceInfo.description || "",
        accessInformation: serviceInfo.copyright || "",
        text: getWMSData(serviceInfo, selectedLayers),
        extent: fullExtent
    };
    if (isGCS) {
        project(fullExtent, new SpatialReference({ wkid: serviceInfo.spatialReferences[0] })).then((extent) => (updatedItem.extent = extent));
    }
    const itemToAdd = await getWMSImageUrl(updatedItem, serviceInfo);
    return addUrl(itemToAdd);
};
const getWMSImageUrl = (item, wmsLayer) => {
    return new Promise((resolve) => {
        const handler = (imageUrl) => {
            resolve(Object.assign(Object.assign({}, item), { thumbnailURL: imageUrl || item.thumbnailURL, extent: extentToString(item.extent) }));
        };
        wmsLayer.getImageUrl(item.extent, 800, 532, handler, handler);
    });
};
const getWMSData = (wmsLayer, selectedLayers) => {
    return JSON.stringify({
        title: wmsLayer.title || "",
        url: wmsLayer.url,
        mapUrl: wmsLayer.getMapURL,
        version: wmsLayer.version,
        layers: selectedLayers,
        copyright: wmsLayer.copyright || "",
        maxHeight: wmsLayer.maxHeight,
        maxWidth: wmsLayer.maxWidth,
        spatialReferences: wmsLayer.spatialReferences,
        format: wmsLayer.getImageFormat() !== "png" ? wmsLayer.getImageFormat() : null,
        featureInfoUrl: wmsLayer.getFeatureInfoURL,
        featureInfoFormat: wmsLayer.featureInfoFormat,
        customParameters: wmsLayer.customParameters || {},
        customLayerParameters: wmsLayer.customLayerParameters || {}
    });
};
const getWFSVersionFromUrl = async (url) => {
    const { query: queryObject } = await (0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.c)(url);
    return (queryObject === null || queryObject === void 0 ? void 0 : queryObject.version) || "2.0.0";
};
/**
 * Fetch a url and add to the trusted domains list if it supports CORS
 */
async function checkCORS(url) {
    var _a, _b, _c;
    try {
        const testReponse = await fetch(url);
        if (testReponse.type === "cors" && testReponse.status === 200) {
            const domain = new URL(url).hostname;
            const [esriConfig] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/config"]);
            (_c = (_b = (_a = esriConfig === null || esriConfig === void 0 ? void 0 : esriConfig.defaults) === null || _a === void 0 ? void 0 : _a.io) === null || _b === void 0 ? void 0 : _b.corsEnabledServers) === null || _c === void 0 ? void 0 : _c.push(domain);
        }
    }
    catch (error) { }
}
const getWFSServiceInfo = async (item, options) => {
    const [WFSLayer] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/WFSLayer"]);
    const { customParameters } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a;
    const { url } = item;
    const wfsUrl = stripParameters(url, ["version", "service", "request", "layer", "typename"]);
    const formattedParams = formatCustomParameters(customParameters);
    const wfsVersion = await getWFSVersionFromUrl(url);
    const wfsLayerOptions = options || {
        version: wfsVersion,
        url: wfsUrl,
        customParameters: (formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customParameters) || {}
    };
    try {
        // V4 only supports 2.0.0 version
        if (_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
            if (wfsVersion !== "2.0.0") {
                return { error: { code: "unsupportedWFSVersion" } };
            }
            // v4 version is read-only
            delete wfsLayerOptions.version;
            // and we don't need the url
            delete wfsLayerOptions.url;
            const [wfsUtils] = (await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/ogc/wfsUtils"]));
            const capabilities = await wfsUtils.getCapabilities(wfsUrl, wfsLayerOptions);
            const layers = capabilities.featureTypes;
            if (!layers || !layers.length) {
                return { error: { code: "emptyFeatureLayer" } };
            }
            else {
                const layerInfo = await wfsUtils.getWFSLayerInfo(capabilities);
                const wfsLayer = WFSLayer.fromWFSLayerInfo(layerInfo);
                wfsLayer.layers = layers;
                wfsLayer.url = wfsUrl;
                wfsLayer.isComplex = wfsLayer.geometryType === "esriGeometryComplex";
                return { result: Object.assign(Object.assign({}, item), { type: "WFS", serviceInfo: wfsLayer }) };
            }
        }
        // --- v3 ---
        const wfsLayer = new WFSLayer(wfsLayerOptions);
        await checkCORS(wfsUrl);
        const result = await new Promise((resolve, reject) => {
            wfsLayer.initialize(wfsLayerOptions, (layers) => {
                if (!layers || !layers.length) {
                    reject({ code: "emptyFeatureLayer" });
                }
                else {
                    wfsLayer.layers = layers;
                    wfsLayer.url = wfsUrl;
                    wfsLayer.isComplex = wfsLayer.geometryType === "esriGeometryComplex";
                    resolve(Object.assign(Object.assign({}, item), { type: "WFS", serviceInfo: wfsLayer }));
                }
            });
            // WFS layers can throw an error if not using the correct version - so we can try with different versions from newest version to oldest
            wfsLayer.on("error", async () => {
                if (wfsLayer.toJson().version === "2.0.0") {
                    const { result, error } = await getWFSServiceInfo(item, { version: "1.1.0", url });
                    if (error) {
                        reject(error);
                    }
                    resolve(result);
                }
                else if (wfsLayer.toJson().version === "1.1.0") {
                    const { result, error } = await getWFSServiceInfo(item, { version: "1.0.0", url });
                    if (error) {
                        reject(error);
                    }
                    resolve(result);
                }
                else {
                    reject({ code: "serviceNotExist" });
                }
            });
        });
        return { result };
    }
    catch (error) {
        console.error(error);
        return { error };
    }
};
const addWFSUrl = async (item) => {
    var _a;
    if (!item || !(item === null || item === void 0 ? void 0 : item.serviceInfo)) {
        return Promise.reject(new Error("serviceNotExist"));
    }
    const { serviceInfo: wfsLayer } = item;
    const fullExtent = ((_a = wfsLayer.selectedLayer) === null || _a === void 0 ? void 0 : _a.fullExtent) || [[], []];
    const stringExtent = extentToString(fullExtent);
    const arrExtent = stringExtent.split(",").map(Number);
    if (!wfsLayer.geometryType || wfsLayer.geometryType === "none") {
        return Promise.reject(new Error("missingGeometry"));
    }
    const formattedItem = { type: item.type, url: item.url, thumbnailURL: item.thumbnailURL };
    const wfsConfig = await getWfsConfig(wfsLayer);
    const itemInfo = Object.assign(Object.assign({}, checkThumbnailURL(formattedItem)), { text: JSON.stringify(wfsConfig), extent: stringExtent });
    const response = await addUrl(itemInfo);
    const updatedItem = Object.assign(Object.assign(Object.assign({}, itemInfo), response), { extent: [
            [arrExtent[0], arrExtent[1]],
            [arrExtent[2], arrExtent[3]]
        ] });
    // TODO: you know - looking at this - i think we need to actually call updateItem on WFS items since it looks like the thumbnail url isn't actually being set on the Item. Oops!
    try {
        const thumbnailUrl = await buildThumbnailURLFromWFSItem(updatedItem.extent);
        return Object.assign(Object.assign({}, updatedItem), { thumbnailUrl });
    }
    catch (error) {
        return updatedItem;
    }
};
async function getWMTSOptions(url) {
    var _a, _b;
    // before we strip parameters see if it's a KVP capabilities URL. Then we use that one first.
    const urlObj = await (0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.c)(url);
    const servicekey = ((_a = urlObj.query) === null || _a === void 0 ? void 0 : _a["service"]) || "";
    const requestKey = ((_b = urlObj.query) === null || _b === void 0 ? void 0 : _b["request"]) || "";
    if ((servicekey.toLowerCase() === "wmts" && requestKey.toLowerCase() === "getcapabilities") ||
        url.toLowerCase().indexOf("/1.0.0/wmtscapabilities.xml") > -1) {
        return { serviceMode: "KVP" };
    }
    else {
        return {};
    }
}
async function getWMTSServiceInfo(item, options) {
    const [WMTSLayer] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/WMTSLayer"]);
    const { customParameters, url } = item;
    const formattedParams = formatCustomParameters(customParameters);
    const wmtsOptions = Object.assign(Object.assign({}, options), { customLayerParameters: (formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customLayerParameters) || {}, customParameters: (formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customParameters) || {} }) ||
        (await Object.assign(Object.assign({}, getWMTSOptions(url)), { customLayerParameters: (formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customLayerParameters) || {}, customParameters: (formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customParameters) || {} }));
    const wmtsUrl = stripParameters(url, [
        "version",
        "service",
        "request",
        "layer",
        "style",
        "format",
        "tilematrixset",
        "tilematrix",
        "tilerow",
        "tilecol"
    ]);
    const newWmtsUrl = wmtsUrl.replace(/\/1.0.0\/wmtscapabilities.xml/i, "");
    try {
        if (_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
            const wmtsLayer = new WMTSLayer(newWmtsUrl, wmtsOptions);
            const v4Layer = wmtsLayer;
            await v4Layer.load();
            const layers = v4Layer.sublayers.toArray();
            if (!layers || !layers.length) {
                return { error: { code: `serviceNotExist` } };
            }
            else {
                wmtsLayer.layers = layers;
                return { result: Object.assign(Object.assign({}, item), { type: "WMTS", serviceInfo: wmtsLayer }) };
            }
        }
        // --- v3 ---
        await checkCORS(wmtsUrl);
        const wmtsLayer = new WMTSLayer(newWmtsUrl, wmtsOptions);
        let layers;
        const result = await new Promise((resolve, reject) => {
            wmtsLayer.on("load", ({ layer: wmtsInfo }) => {
                layers = wmtsInfo.layers;
                if (!layers || !layers.length) {
                    reject(new Error(`serviceNotExist`));
                }
                else {
                    wmtsLayer.layers = layers;
                    resolve(Object.assign(Object.assign({}, item), { type: "WMTS", serviceInfo: wmtsLayer }));
                }
            });
            wmtsLayer.on("error", (err) => {
                var _a;
                if (!wmtsOptions.serviceMode) {
                    getWMTSServiceInfo(item, { serviceMode: "KVP" }).then(({ result, error }) => {
                        if (error) {
                            reject(error);
                        }
                        resolve(result);
                    }, reject);
                }
                else {
                    if (((_a = err.error) === null || _a === void 0 ? void 0 : _a.message) === "The WMTS capabilities XML is not valid") {
                        reject({ code: "invalidWMTS" });
                    }
                    reject({ code: "serviceNotExist" });
                }
            });
        });
        return { result };
    }
    catch (error) {
        console.error(error);
        return { error };
    }
}
async function addWMTSUrl(item) {
    if (!item) {
        return Promise.reject("serviceNotExist");
    }
    const { serviceInfo: wmtsLayer, selectedLayer, selectedTileInfo } = item;
    if (!selectedLayer) {
        return Promise.reject(new Error("layerNotSelected"));
    }
    if (!selectedTileInfo) {
        return Promise.reject(new Error("missingGeometry"));
    }
    wmtsLayer.selectedTileInfo = selectedTileInfo;
    const { wmtsConfig, fullExtent: configExtent } = await getWMTSConfig(wmtsLayer).catch((error) => {
        console.error("Error getting WMTS config", error);
        throw error;
    });
    const gcsExtent = wmtsLayer.selectedLayer[_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? "fullExtent" : "gcsExtent"];
    const fullExtent = configExtent ? gcsExtent : { xmin: -180, ymin: -90, xmax: 180, ymax: 90 };
    const formattedItem = { type: item.type, url: item.url, thumbnailURL: item.thumbnailURL };
    const itemInfo = Object.assign(Object.assign({}, checkThumbnailURL(formattedItem)), { url: wmtsConfig.wmtsInfo.url, text: JSON.stringify(wmtsConfig), extent: `${fullExtent.xmin},${fullExtent.ymin},${fullExtent.xmax},${fullExtent.ymax}` });
    const response = await addUrl(itemInfo);
    const updatedItem = Object.assign(Object.assign(Object.assign({}, itemInfo), response), { extent: [
            [fullExtent.xmin, fullExtent.ymin],
            [fullExtent.xmax, fullExtent.ymax]
        ] });
    try {
        const thumbnailData = await buildThumbnailURLFromWMTSItem(updatedItem);
        const requestData = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? { type: "base64", data: thumbnailData } : { type: "url", url: thumbnailData };
        const itemWithThumbnail = await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.e)(response.id, requestData);
        return Object.assign(Object.assign({}, updatedItem), itemWithThumbnail);
    }
    catch (error) {
        console.error("Error when adding WMTS URL:", error);
        return updatedItem;
    }
}
async function getOGCFeatureLayerServiceInfo(item) {
    var _a, _b, _c, _d;
    const { url } = item;
    /** this is the first call from the MapViewer  - it will get the landing page in the form of "application/json - and then get the collection from it. */
    //   // @ 9.3 Will need to set the trustedServer stuff before this call
    //   // in case the service needs credentials
    const landingPageOptions = { addTokenManually: false, headers: { accept: "application/json" } };
    try {
        const getDataWithJSONRetry = async (func, failCallback) => {
            var _a, _b, _c;
            try {
                return await func();
            }
            catch (error) {
                const message = (_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : "";
                if (message.includes("unexpected token") || message.includes("expected expression")) {
                    return failCallback();
                }
                else {
                    throw { result: null, error: { code: "unhandledError", message: JSON.stringify(error) } };
                }
            }
        };
        const landingPage = await getDataWithJSONRetry(() => (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, {}, landingPageOptions, "auto", { excludeJson: true }), () => (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, {}, landingPageOptions));
        const serviceInfo = await getDataWithJSONRetry(() => getServerCollections(landingPage), () => getServerCollections(landingPage, {}, false));
        return {
            result: Object.assign(Object.assign({}, item), { extent: extentToString((_d = (_c = (_b = (_a = serviceInfo.collections) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.extent) === null || _c === void 0 ? void 0 : _c.spatial) === null || _d === void 0 ? void 0 : _d.bbox), type: "OGCFeatureServer", serviceInfo, layers: serviceInfo.collections }),
            error: null
        };
    }
    catch (error) {
        console.error("get OGC feature layer:", error);
        // TODO: handle error transformation here
        return { result: null, error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
}
function selectOGCFeatureLayer(selectedLayer) {
    var _a, _b;
    if (!selectedLayer) {
        return;
    }
    const { title, description } = selectedLayer;
    _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.title = (_a = title !== null && title !== void 0 ? title : _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.title) !== null && _a !== void 0 ? _a : "";
    _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.snippet = (_b = description !== null && description !== void 0 ? description : _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.snippet) !== null && _b !== void 0 ? _b : "";
    _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.selectedLayer = selectedLayer;
}
async function getServerCollections(landingPage, options = {}, excludeJson = true) {
    const { links } = landingPage;
    const link = getLink(links, "data", "application/json") ||
        getLink(links, "http://www.opengis.net/def/rel/ogc/1.0/data", "application/json");
    if (isNone(link)) {
        throw new Error("Missing collections url");
    }
    return _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3
        ? (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(addParameters(link.href), {}, Object.assign(Object.assign({}, options), { addTokenManually: false }), "auto", {
            v3Request: { headers: { accept: "application/json" } },
            excludeJson
        })
        : (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(addParameters(link.href), {}, Object.assign(Object.assign({}, options), { addTokenManually: false, headers: { accept: "application/json" } }), "auto", {
            excludeJson
        });
}
function getLink(links, relation, type) {
    return (links.find((link) => link.rel === relation && link.type === type) ||
        links.find((link) => link.rel === relation && !link.type));
}
async function addOGCFeatureService(item) {
    const { serviceInfo, customParameters } = item;
    if (!serviceInfo) {
        return Promise.reject(new Error("serviceNotExist"));
    }
    // This will need to be updated based on how metadata needs to be formatted.
    if (customParameters.length > 0) {
        item.text = JSON.stringify({ customParameters: formatCustomParameters(customParameters).customParameters });
    }
    return addUrl(item);
}

// function to navigate to the correct "addItem" requests
const addItem = (item, restBaseUrl) => {
    const { newItemMode, typeKeywords, tags, extent, selectedServiceInfoLayersNames, addFeatureLayerType } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a;
    const title = _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.title;
    if ((title === null || title === void 0 ? void 0 : title.length) > 250) {
        _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.title = title.substring(0, 250);
    }
    switch (newItemMode) {
        case "application":
            return addApplication(item, restBaseUrl);
        case "file":
            // TODO: Pass in item properties/item request here instead of grabbing from the store again
            return addFile();
        case "url":
            // TODO: refactor the passed configState out of this
            return handleAddUrl(item, _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.config, _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api);
        case "featureLayer":
            return addFeatureLayer({
                serviceInfo: item.serviceInfo,
                typeKeywords,
                tags,
                extent,
                selectedServiceInfoLayersNames,
                addFeatureLayerType
            });
        default:
            return (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.b)(Object.assign({}, item));
    }
};
const uploadFile = async () => {
    try {
        const addItemRequest = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.c; // { ...addItemStore.state };
        const response = (await addItem(addItemRequest, ""));
        _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.id = response.id;
        const jobStatus = await getItemStatus(_add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.id, { success: response.success });
        if (jobStatus.status === "failed") {
            throw jobStatus.statusMessage;
        }
        return {};
    }
    catch (error) {
        console.error(error);
        const errorMessage = (error === null || error === void 0 ? void 0 : error.statusMessage) || error || "";
        switch (true) {
            case errorMessage.includes("Invalid File Geodatabase"):
                return { error: { code: "invalidFileGeodatabase" } };
            case errorMessage.includes("Invalid Shapefile"):
                return { error: { code: "invalidShapefile" } };
            case errorMessage.includes("The request size is greater than the max allowed of 1024MB"):
                return { error: { code: "exceedsFileSize" } };
            default:
                return { error: { code: "unhandledError" } };
        }
    }
};
const addFile = async (props) => {
    const file = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.file;
    const dataUrl = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.dataUrl;
    if (!file && dataUrl) {
        return addFileFromDataUrl(props);
    }
    // TODO: remove this ECD workaround when backend fixes filename creation (WebGIS/arcgis-portal-app#41068)
    if ((file === null || file === void 0 ? void 0 : file.size) > MULTI_PART_UPLOAD_MINIMUM_SIZE || _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.type === "Esri Classifier Definition") {
        return addFileMultiPart();
    }
    return addFileSingle();
};
const addFileFromDataUrl = async (props) => {
    var _a;
    const url = (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.k)(_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.user, _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.folder);
    const { fileName, dataUrl, extension } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a;
    const addItemParams = (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.h)(_item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i, _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a);
    const overwrite = !!_add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.overwrite; //could be undefined
    // in the case where we're adding geojson from a url referencing a feature service,
    // make a unique file name so that the file isn't the query WebGIS/arcgis-portal-app#42403
    const isGeoJSONFromFeatureServer = (dataUrl === null || dataUrl === void 0 ? void 0 : dataUrl.includes("/query?")) && (fileName === null || fileName === void 0 ? void 0 : fileName.includes("query")) && (extension === null || extension === void 0 ? void 0 : extension.includes("json"));
    const geojsonProperties = isGeoJSONFromFeatureServer
        ? {
            filename: (0,_guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_14__.g)(),
            dataUrl
        }
        : {};
    const params = Object.assign(Object.assign(Object.assign({}, addItemParams), { async: true, filename: (_a = props === null || props === void 0 ? void 0 : props.filename) !== null && _a !== void 0 ? _a : fileName, title: props === null || props === void 0 ? void 0 : props.title, overwrite }), geojsonProperties);
    return (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, params, {}, "post");
};
async function addFileSingle() {
    const url = (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.k)(_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.user, _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.folder);
    const form = (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.i)(_item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i, _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a);
    try {
        return await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.d)(url, form, {}, "post");
    }
    catch (error) {
        throw (error === null || error === void 0 ? void 0 : error.message) || error;
    }
}
async function addPart(part, itemId, attempts = 0) {
    const user = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.user;
    // Keep attempting to add the part, only throwing an error after multiple retries
    try {
        const { partData, formData } = part;
        const parameters = `?streamdata=true&size=${partData.size}&partNum=${partData.partNum}&f=json`;
        const url = `${user.userContentUrl}/items/${itemId}/addPart${parameters}`;
        const response = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.d)(url, formData, {
            "X-Esri-Authorization": `Bearer ${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.e)(_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.portal)}`
        }, "post");
        return { response, attempts, partSize: partData.size };
    }
    catch (_a) {
        if (!_add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.id) {
            throw "cancelled";
        }
        attempts++;
        if (attempts > MULTI_PART_UPLOAD_RETRIES) {
            // TODO: Update error message
            throw new Error("Upload failed - too many attempts");
        }
        else {
            return addPart(part, itemId, attempts);
        }
    }
}
function* generatePart() {
    const file = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.file;
    const { name, size } = file;
    let partSize = MULTI_PART_UPLOAD_BATCH_SIZE;
    let totalParts = Math.ceil(size / partSize);
    let part = 0;
    // Max number of parts is 10,000, so we increase the chunk size if the file is bigger than the threshold
    if (totalParts > MULTI_PART_UPLOAD_MAX_PARTS) {
        partSize = Math.ceil(size / MULTI_PART_UPLOAD_MAX_PARTS);
        totalParts = Math.ceil(size / partSize);
    }
    while (part < totalParts) {
        const formData = new FormData();
        const offset = part * partSize;
        const blob = file.slice(offset, offset + partSize);
        part++;
        const partData = {
            partNum: part,
            size: blob.size
        };
        formData.append("partNum", String(partData.partNum));
        formData.append("streamdata", "true");
        formData.append("f", "json");
        formData.append("token", (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.e)(_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.portal));
        formData.append("file", blob, name);
        yield { partData, formData };
    }
    return null;
}
const addFileMultiPart = async () => {
    var _a, _b, _c, _d;
    let doUpload = true;
    const cancelUpload = () => {
        if (_add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.id) {
            doUpload = false;
            const itemId = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.id;
            _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.id = null;
            return (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.l)(itemId);
        }
    };
    const multiPartSubscriber = subscriptionState.addSubscriber("addFileMultiPart", cancelUpload);
    const config = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.config;
    const url = (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.k)(_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.user, _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.folder);
    const { fileName, file } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a;
    let partsPerBatch = (_a = config.multiPartBatchSize) !== null && _a !== void 0 ? _a : MULTI_PART_UPLOAD_INITIAL_BATCH_SIZE;
    let numConsecutiveSuccess = 0;
    let itemId;
    try {
        const itemResponse = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, { multipart: true, fileName, async: true }, {}, "post");
        itemId = (_b = itemResponse.id) !== null && _b !== void 0 ? _b : itemResponse.itemId;
        _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.id = itemId;
        // TODO: Factor uploadProgress out of addItemState
        _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.uploadProgress = 0;
        _store_6a88e6c5_js__WEBPACK_IMPORTED_MODULE_15__.w.uploadProgress = 0;
        let bytesUploaded = 0;
        // Initialize dynamic batch generator
        const partGenerator = generatePart();
        await (0,_functional_81373f6d_js__WEBPACK_IMPORTED_MODULE_6__.s)(() => {
            const { value, done } = partGenerator.next();
            return done ? null : addPart(value, itemId);
        }, {
            getBatchSize: () => partsPerBatch,
            onPromiseCompleted: (addPartResult) => {
                const { attempts, partSize } = addPartResult;
                // If a part only succeeded after one or more failures/retries, flag the batch to be reduced next time
                if (attempts > 0) {
                    partsPerBatch = Math.max(1, Math.ceil(partsPerBatch / 2));
                    numConsecutiveSuccess = 0;
                }
                else {
                    numConsecutiveSuccess++;
                    if (numConsecutiveSuccess >= partsPerBatch) {
                        partsPerBatch = Math.min(partsPerBatch + 1, MULTI_PART_UPLOAD_MAX_BATCH_SIZE);
                        numConsecutiveSuccess = 0;
                    }
                }
                bytesUploaded += partSize;
                const progress = Math.floor((bytesUploaded / file.size) * 100);
                // TODO: Factor uploadProgress out of addItemState
                _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.uploadProgress = progress;
                _store_6a88e6c5_js__WEBPACK_IMPORTED_MODULE_15__.w.uploadProgress = progress;
            },
            onPromiseThrow() {
                doUpload = false;
            },
            shouldContinue: () => doUpload && subscriptionState.isSubscriberValid(multiPartSubscriber)
        });
        subscriptionState.removeSubscriber(multiPartSubscriber);
        const { type, extension, enablePublishing, properties } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a;
        return await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.j)(itemId, {
            file,
            type,
            extension,
            enablePublishing,
            properties
        });
    }
    catch (error) {
        // If an item was partially uploaded, cancel it before throwing error
        await cancelUpload();
        console.error((_c = error === null || error === void 0 ? void 0 : error.message) !== null && _c !== void 0 ? _c : error);
        throw (_d = error === null || error === void 0 ? void 0 : error.message) !== null && _d !== void 0 ? _d : error;
    }
};
// --- URL
const handleAddUrl = (item, config, api) => {
    if (item.agsType) {
        return addSecureAGSUrl(item);
    }
    switch (item.type) {
        case "KML":
            return addKMLUrl(item, config, api);
        case "WMS":
            return addWMSUrl(item);
        case "WFS":
            return addWFSUrl(item);
        case "WMTS":
            return addWMTSUrl(item);
        case "OGCFeatureServer":
            return addOGCFeatureService(item);
        default:
            return addUrl(item);
    }
};
const getTypeKeywords = (item) => {
    var _a;
    const { type, agsType } = item;
    const generatedTypes = ((_a = _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_13__.a[agsType !== null && agsType !== void 0 ? agsType : type]) === null || _a === void 0 ? void 0 : _a.typeKeywords) || [];
    return [...generatedTypes, ...(item.typeKeywords || [])];
};
const addUrl = async (item) => {
    const { customParameters: customParams, agsType } = item;
    const { type } = (0,_file_bf8ab90f_js__WEBPACK_IMPORTED_MODULE_12__.g)(item.type);
    const content = Object.assign(Object.assign({}, item), { typeKeywords: getTypeKeywords(item), type });
    if ((customParams === null || customParams === void 0 ? void 0 : customParams.length) >= 1 && !!agsType) {
        const { customParameters } = formatCustomParameters(customParams);
        content.text = JSON.stringify({ customParameters });
    }
    return (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.b)(content);
};
// --- Other
async function getItemStatus(id, options = {}, statusUrl) {
    var _a;
    try {
        const user = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.user;
        const url = statusUrl !== null && statusUrl !== void 0 ? statusUrl : `${user.userContentUrl}/items/${id}/status`;
        const requestParams = (options === null || options === void 0 ? void 0 : options.jobId) ? { jobId: options.jobId } : {};
        // Need to await here so it will catch related error below
        const jobStatus = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.p)(url, { requestParams });
        return jobStatus;
    }
    catch (error) {
        if (!((_a = error.statusMessage) === null || _a === void 0 ? void 0 : _a.includes("Item status doesn't exist")) || !options.success) {
            console.error(error);
            throw error;
        }
        return { itemId: id, status: "status-not-found", lastUpdatedTime: 0, submissionTime: 0, recordCount: 0 };
    }
}
async function addResource(owner, id, folder, params) {
    const { config } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const folderPath = folder.id && folder.id !== "/" && folder.id !== owner ? `/${folder.id}` : "";
    const url = `${config.restBaseUrl}content/users/${owner}${folderPath}/items/${id}/addResources`;
    return (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, params, {}, "post");
}
async function addCloudProviderResource(resource, id) {
    const folder = _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.folder;
    const { user } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    // add cloud info to resource
    return addResource(user.username, id, folder, {
        fileName: "cloudProvider.json",
        text: JSON.stringify(resource),
        access: "private"
    });
}

async function getAGSThumbnail(item) {
    const { url, thumbnailURL, serviceInfo, extent } = item;
    if (thumbnailURL) {
        return thumbnailURL;
    }
    if (!["Map Service", "Feature Service", "Image Service"].includes(item.type)) {
        return null;
    }
    if (["Map Service", "Image Service"].includes(item.type) || url.indexOf("MapServer") !== -1) {
        const extentString = extentToString(extent);
        // make thumbnail in service spatial reference
        const exportCallOpts = { serviceUrl: url, extent: extentString, size: "800,532", format: "image", serviceInfo };
        return extent ? buildExportCall(exportCallOpts) : null;
    }
    const { result, error } = await buildThumbnailURLFromFSItem(item);
    if (error) {
        // Ideally the thumbnail generation process shouldn't stop the other process in case of failing
        console.error("Error generating thumbnail", error);
        return "";
    }
    return result;
}
function buildExportCall(exportCallOpts) {
    var _a;
    let { visibleLayers, serviceUrl, serviceInfo, size, extent, bboxSR, imageSR, format } = exportCallOpts;
    let position;
    if (!serviceInfo) {
        return "";
    }
    let isMap = serviceUrl.indexOf("/MapServer") > -1;
    if (!visibleLayers && isMap) {
        let layerId;
        // it's just one layer of a map service
        position = serviceUrl.indexOf("/MapServer");
        const queryPosition = serviceUrl.indexOf("?");
        if (queryPosition > -1) {
            layerId = serviceUrl.substring(position + 11, queryPosition);
            serviceUrl = serviceUrl.substring(0, position + 10) + serviceUrl.substring(queryPosition);
            visibleLayers = layerId;
        }
        else {
            layerId = serviceUrl.substring(position + 11);
            serviceUrl = serviceUrl.substring(0, position + 10);
            visibleLayers = layerId;
        }
    }
    if (!isMap && serviceInfo) {
        // if we have a proxy service ending in /service
        if (serviceInfo.capabilities) {
            isMap = serviceInfo.capabilities.toLowerCase().indexOf("map") > -1;
        }
        else {
            // older servers
            isMap = serviceInfo.supportedImageFormatTypes;
        }
    }
    let url = serviceUrl;
    position = url.indexOf("?");
    if (position === -1) {
        if (isMap) {
            url += "/export?";
        }
        else if (typeof serviceInfo.currentVersion !== "undefined" && serviceInfo.currentVersion >= 10.1) {
            url += "/info/thumbnail";
            return url;
        }
        else {
            url += "/exportImage?";
        }
    }
    else {
        if (isMap) {
            url = `${url.substring(0, position)}/export${url.substring(position, url.length)}&`;
        }
        else if (typeof serviceInfo.currentVersion !== "undefined" && serviceInfo.currentVersion >= 10.1) {
            url = `${url.substring(0, position)}/info/thumbnail${url.substring(position, url.length)}`;
            return url;
        }
        else {
            url = `${url.substring(0, position)}/exportImage${url.substring(position, url.length)}&`;
        }
    }
    url += `size=${size}&bbox=${extent}`;
    if ((bboxSR === null || bboxSR === void 0 ? void 0 : bboxSR.length) > 0) {
        url += `&bboxSR=${bboxSR}`;
    }
    if ((imageSR === null || imageSR === void 0 ? void 0 : imageSR.length) > 0) {
        url += `&imageSR=${imageSR}`;
    }
    if (isMap && ((_a = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.supportedImageFormatTypes) === null || _a === void 0 ? void 0 : _a.indexOf("PNG32")) > -1) {
        url += `&format=png32&f=${format}`;
    }
    else if (isMap) {
        url += `&format=png24&f=${format}`;
    }
    else {
        url += `&format=jpgpng&f=${format}`;
    }
    if (isMap) {
        if ((visibleLayers === null || visibleLayers === void 0 ? void 0 : visibleLayers.length) > 0) {
            url += `&layers=show:${visibleLayers}`;
        }
    }
    else {
        url += "&interpolation=RSP_NearestNeighbor&bandIds=null";
    }
    return url;
}
async function buildThumbnailForFSItem4x(id, portal) {
    var _a, _b, _c;
    const [Map, MapView, FeatureLayer, Basemap, print, PrintTemplate, PrintParameters, scaleRange] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        "esri/Map",
        "esri/views/MapView",
        "esri/layers/FeatureLayer",
        "esri/Basemap",
        "esri/rest/print",
        "esri/rest/support/PrintTemplate",
        "esri/rest/support/PrintParameters",
        "esri/smartMapping/heuristics/scaleRange"
    ]);
    try {
        const container = createHiddenMapDiv(800, 532);
        const knownBasemapId = portal.defaultBasemap.id.includes("basemap");
        const layer = new FeatureLayer({
            portalItem: {
                id,
                portal
            }
        });
        const map = new Map({
            basemap: knownBasemapId
                ? "topo-vector"
                : new Basemap({
                    portalItem: {
                        id: portal.defaultBasemap.id,
                        portal
                    }
                })
        });
        const view = new MapView({
            map,
            container
        });
        await map.watch("loaded");
        let minScale = 0;
        let maxScale = 0;
        if (!knownBasemapId) {
            ({ minScale, maxScale } = await scaleRange({
                layer,
                view
            }));
        }
        const extentResponse = await layer.queryExtent();
        view.goTo(extentResponse.extent);
        layer.minScale = minScale;
        layer.maxScale = maxScale;
        view.map.add(layer);
        view.scale = maxScale;
        await (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.t)(2000);
        // url to the print service
        const url = (_c = (_b = (_a = portal.helperServices) === null || _a === void 0 ? void 0 : _a.printTask) === null || _b === void 0 ? void 0 : _b.url) !== null && _c !== void 0 ? _c : "https://utility.arcgisonline.com/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task";
        const template = new PrintTemplate({
            format: "png32",
            exportOptions: {
                dpi: 96,
                width: 800,
                height: 532
            },
            layout: "map-only",
            showLabels: false,
            attributionVisible: false
        });
        const params = new PrintParameters({
            view: view,
            template
        });
        const printResult = await print.execute(url, params);
        destroyHiddenMapDiv();
        return printResult.url;
    }
    catch (error) {
        destroyHiddenMapDiv();
        return null;
    }
}
async function buildThumbnailURLFromFSItem(item) {
    var _a;
    const { config, portal, api } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    if (api === 4) {
        return { result: await buildThumbnailForFSItem4x(item.id, portal) };
    }
    const [FeatureLayer, Extent] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/FeatureLayer", "esri/geometry/Extent"]);
    const { serviceInfo, username, password, isSecured } = item;
    // from item properties page or viewer 'save layer' (not for feature collection)
    // newExtent and layers overwrites for the item are optional
    // 1. get item /data to get overwrites
    // 2. make service info request to get layers
    // 3. build webMap object
    // 4. call Geoprocessor task
    const webMap = {
        baseMap: config.defaultBasemap || config.self.defaultBasemap,
        operationalLayers: []
    };
    webMap.baseMap.title = "basemap";
    const len = webMap.baseMap.baseMapLayers.length;
    for (let i = 0; i < len; i++) {
        let layer = webMap.baseMap.baseMapLayers[i];
        if (!layer.isReference) {
            // we need only one basemap layer and we hide it
            if ((config.allSSL || location.protocol == "https:") &&
                ((0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.a)(layer.url) || (0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.b)(layer.url))) {
                layer.url = layer.url.replace("http:", "https:");
            }
            layer.visibility = false;
            webMap.baseMap.baseMapLayers = [layer];
            break;
        }
    }
    if (!serviceInfo) {
        return { result: "" };
    }
    const layers = serviceInfo.layers || [];
    const itemUrl = item.url;
    const urlObject = await (0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.c)(itemUrl);
    const token = isSecured.secured ? await getSecuredServiceCustomToken(urlObject.path, { username, password }) : null;
    layers.reverse().forEach(async (layer) => {
        const operationalLayer = {
            url: `${itemUrl}/${layer.id}${token ? `?token=${token}` : ""}`,
            id: `${item.id || Math.random()}_${layer.id}`,
            opacity: 1,
            title: `${item.title || "title"}_${layer.id}`,
            visibility: true,
            layerDefinition: undefined
        };
        let found = false;
        layers.forEach((lyr) => {
            if (lyr.id === layer.id && !found) {
                found = true;
                operationalLayer.layerDefinition = lyr.layerDefinition;
            }
        });
        if (!layers.length || (layers.length && found)) {
            webMap.operationalLayers.push(operationalLayer);
        }
    });
    let extent = [
        [-180, -90],
        [180, 90]
    ];
    if (typeof item.extent === "string") {
        const e = item.extent.split(",");
        extent = [
            [parseFloat(e[0]), parseFloat(e[1])],
            [parseFloat(e[2]), parseFloat(e[3])]
        ];
    }
    else if (((_a = item.extent) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        extent = item.extent;
    }
    if (webMap.operationalLayers.length === 1) {
        let featureLayer = new FeatureLayer(webMap.operationalLayers[0].url);
        return new Promise((resolve) => {
            featureLayer.on("load", async (featLayer) => {
                if (featLayer === null || featLayer === void 0 ? void 0 : featLayer.layer) {
                    featureLayer = featLayer.layer;
                }
                const extentAsList = await getExtentWithFeatures(featureLayer, extent);
                try {
                    const thumbnailUrl = await buildThumbnailURLFromWebMap(webMap, extentAsList);
                    resolve({ result: thumbnailUrl });
                }
                catch (error) {
                    resolve({ error: { code: "unhandledError", message: error } });
                }
            });
        });
    }
    else {
        // check if at least one layer is in scale
        const extentAsList = item.extent;
        const ext = new Extent(extentAsList[0][0], extentAsList[0][1], extentAsList[1][0], extentAsList[1][1]);
        const thumbnailScale = getScaleForExtent(ext, 200);
        const opLayers = [];
        const featureLayers = [];
        const promises = [];
        webMap.operationalLayers.forEach((opLayer) => {
            const featureLayer = new FeatureLayer(opLayer.url);
            const promise = new Promise((resolve) => {
                featureLayer.on("load", (layer) => {
                    opLayers.push(opLayer);
                    featureLayers.push(layer);
                    if (layer.minScale <= thumbnailScale && layer.maxScale > thumbnailScale) {
                        resolve(true);
                    }
                    else {
                        resolve(false);
                    }
                });
                featureLayer.on("error", () => {
                    resolve(false);
                });
            });
            promises.push(promise);
        });
        const responses = await Promise.all(promises);
        // clean out layers that didn't load from the webmap
        webMap.operationalLayers = opLayers;
        const found = responses.filter((res) => res).length > 0;
        try {
            if (!found && featureLayers.length > 0) {
                // saving thumbnail with item extent will be blank
                // zoom to features instead; use first working layer
                const extentWithFeatures = await getExtentWithFeatures(featureLayers[0], extentAsList);
                return { result: await buildThumbnailURLFromWebMap(webMap, extentWithFeatures) };
            }
            else {
                return { result: await buildThumbnailURLFromWebMap(webMap, extentAsList) };
            }
        }
        catch (error) {
            return { error: { code: "unhandledError", message: error } };
        }
    }
}

async function isFederatedWithWebTierAuth(itemInfo, checkUrlResponse, checkAuth) {
    var _a, _b;
    //If a service is federated with another portal, and is secured with web tier authentication
    //it will still report back that its secured with token security ("499"), even though it uses web tier authentication ("401")
    //it does this because its federated with another portal, unfortunately.  If secured with web tier, there
    //isn't a reason to store the credentials so lets hide that box, but the only way to check that is to call
    //checkUrl with the generateToken endpoint, and see if that returns 401
    //https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/3791
    if ((checkUrlResponse === null || checkUrlResponse === void 0 ? void 0 : checkUrlResponse.httpStatusCode) === 499) {
        const [esriId] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
            _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3 ? "esri/IdentityManager" : "esri/identity/IdentityManager"
        ]);
        const { url, password, username } = itemInfo;
        const tokenServiceUrl = await esriId._getTokenSvcUrl(url);
        let generateTokenUrl = (_a = tokenServiceUrl.authInfo) === null || _a === void 0 ? void 0 : _a.tokenServicesUrl;
        if (generateTokenUrl) {
            // Add a trailing slash if it doesn't exist
            if (generateTokenUrl[generateTokenUrl.length - 1] !== "/") {
                generateTokenUrl += "/";
            }
            try {
                const result = await getIsSecured({ password, username }, generateTokenUrl !== null && generateTokenUrl !== void 0 ? generateTokenUrl : "", (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.g)(), checkAuth);
                return (result === null || result === void 0 ? void 0 : result.secured) && (result === null || result === void 0 ? void 0 : result.httpStatusCode) === 401;
            }
            catch (error) {
                return ((_b = error === null || error === void 0 ? void 0 : error.message) === null || _b === void 0 ? void 0 : _b.indexOf("Http StatusCode: -1")) > -1 ? -1 : false;
            }
        }
    }
    return false;
}
function parseAGSTitle(url) {
    return (0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.p)((0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.d)(url)).serverName;
}
function parseAGSType(url) {
    const formattedUrl = (0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.d)(url);
    const serverTypeAndLayerIndex = (0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.p)(url);
    const containsAGS = formattedUrl.replace(_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.v, "").match(_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.c);
    let agsType = serverTypeAndLayerIndex === null || serverTypeAndLayerIndex === void 0 ? void 0 : serverTypeAndLayerIndex.serverType;
    let soeType = serverTypeAndLayerIndex === null || serverTypeAndLayerIndex === void 0 ? void 0 : serverTypeAndLayerIndex.index;
    const caseCorrected = {
        mapserver: "MapServer",
        geocodeserver: "GeocodeServer",
        gpserver: "GPServer",
        geometryserver: "GeometryServer",
        geoenrichmentserver: "GeoenrichmentServer",
        imageserver: "ImageServer",
        naserver: "NAServer",
        featureserver: "FeatureServer",
        geodataserver: "GeoDataServer",
        globeserver: "GlobeServer",
        wmserver: "WMServer",
        sceneserver: "SceneServer",
        vectortileserver: "VectorTileServer",
        streamserver: "StreamServer",
        videoserver: "VideoServer"
    };
    if (agsType && caseCorrected[agsType.toLowerCase()]) {
        agsType = caseCorrected[agsType.toLowerCase()];
    }
    // TODO: Fix this mapping earlier, maybe remove this whole function? The original url parser might may be able to handle this up front
    if (agsType === "ags" || (!agsType && containsAGS)) {
        agsType = "MapServer";
    }
    if (agsType === "MapServer" && soeType !== null) {
        // Layer within a mapserver - CR260845
        return "FeatureServer";
    }
    return agsType;
}
async function getSecuredAGSServiceInfo(item) {
    var _a;
    // TODO: Pass in what we need from configState as args
    const { config } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const { checkAuth, storeAuth, username, password } = item;
    item.title = parseAGSTitle(item.url);
    const agsType = parseAGSType(item.url);
    if (!agsType || (agsType === "SceneServer" && !config.sceneViewerEnabled)) {
        return { error: { code: "unknownAGSType" } };
    }
    let itemType = (_a = _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_13__.a[agsType]) === null || _a === void 0 ? void 0 : _a.type;
    if (!itemType) {
        console.warn(`Unknown AGS Type ${agsType}`);
        // TODO: Can we reach this point? And if so will an item be created?
    }
    item.type = itemType;
    item.agsType = agsType;
    try {
        if (!_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.user) {
            return { result: await getAGSServiceInfo(item) };
        }
        const result = await getIsSecured({ username, password }, item.url, (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.g)(_config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.portal), checkAuth);
        const checkUrlAllowStoredAuth = result === null || result === void 0 ? void 0 : result.allowStoredAuth;
        if (checkUrlAllowStoredAuth === false) {
            // This means /checkUrl fails for some reason
            item.allowStoredAuth = false;
        }
        if (result.secured) {
            item.isSecured = Object.assign({}, result);
            item.allowStoredAuth = false;
            //https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/3791
            const isFederatedWithWebTier = await isFederatedWithWebTierAuth({ username: item.username, password: item.password, url: item.url }, result, checkAuth);
            if (!isFederatedWithWebTier && result.httpStatusCode !== 401) {
                item.isSecured = Object.assign(Object.assign({}, result), { isFederatedWithWebTierAuth: isFederatedWithWebTier });
                // Only allow to toggle auth if `/checkUrl` determine the URL can be reached
                if (checkUrlAllowStoredAuth !== false) {
                    item.allowStoredAuth = true;
                }
                if (result.isOverride) {
                    // #29916, arcgis-portal-services-design #153 - Geoenrichment servers are able to have a proxy created without
                    // prompting for credentials. In this case don't disallow the storeAuth option and pass createAsServiceProxy
                    // through to the /addItem request
                    if (agsType === "GeoenrichmentServer" && !item.storeAuth) {
                        item.createAsServiceProxy = true;
                    }
                    else {
                        item.storeAuth = true;
                    }
                }
                if (checkAuth && !storeAuth) {
                    return { result: await getAGSServiceInfo(item, { useProxy: result.useProxy }) };
                }
                return { result: item };
            }
            else if (isFederatedWithWebTier === -1) {
                //https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/1900
                //https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/4765
                // -1 means the proxy does not trust the ssl cert for the isFederatedWithWebTierAuth request from above
                const updatedItem = Object.assign(Object.assign({}, item), { isSecured: null, checkUrlError: true, storeAuth: false });
                return { result: await getAGSServiceInfo(updatedItem, { useProxy: result.useProxy }) };
            }
            else {
                const updatedItem = Object.assign(Object.assign({}, item), { isSecured: { httpStatusCode: 401, isFederatedWithWebTierAuth: isFederatedWithWebTier } });
                return { result: await getAGSServiceInfo(updatedItem, { useProxy: result.useProxy }) };
            }
        }
        else {
            return { result: await getAGSServiceInfo(item, { useProxy: result.useProxy }) };
        }
    }
    catch (error) {
        // If the user aborted the flow, don't try to fetch again
        // Also prevent re-request if it's known that an api key is missing (code "unauthorized")
        if (isAppComponentError(error)) {
            const code = error.code;
            if (code === "flowAborted" || code === "unauthorized" || code === "invalidSpatialRef") {
                return { error };
            }
        }
        try {
            //https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/1900
            const updatedItem = Object.assign(Object.assign({}, item), { isSecured: item.isSecured || null, checkUrlError: error, storeAuth: false });
            return { result: await getAGSServiceInfo(updatedItem) };
        }
        catch (error) {
            if (isAppComponentError(error)) {
                return { error };
            }
            return {
                error: { code: "unhandledError", message: JSON.stringify(error) }
            };
        }
    }
}
const MAX_RETRY = 3; // TODO: Determine a better number
async function getAGSServiceInfo(item, extraParams, retry = 0) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const { url = item.url, useProxy = false } = extraParams !== null && extraParams !== void 0 ? extraParams : {};
    const [esriId] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3 ? "esri/IdentityManager" : "esri/identity/IdentityManager"
    ]);
    const { username, password, checkAuth, agsType } = item;
    const { tags: itemTags = [] } = _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i || {};
    const secureService = [499, 498];
    const serviceUrl = (0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.d)(url);
    if (!item.isSecured ||
        (((_a = item.isSecured) === null || _a === void 0 ? void 0 : _a.httpStatusCode) !== 401 && checkAuth) ||
        (((_b = item.checkUrlError) === null || _b === void 0 ? void 0 : _b.message) && !!item.isSecured && !!(0,_ags_eb458a03_js__WEBPACK_IMPORTED_MODULE_10__.i)(item.type))) {
        try {
            const serviceInfo = await getServiceInfo({ username, password }, serviceUrl, {
                isSecure: item.isSecured,
                isVideoService: item.type === "Video Service",
                checkAuth,
                useProxy
            });
            // Image service with LERC format tiles, create new elevation service
            if (item.type === "Image Service" && serviceInfo.tileInfo) {
                if (serviceInfo.tileInfo.format === "LERC" || ((_c = serviceInfo.cacheType) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "elevation") {
                    item.agsType = "ElevationServer";
                }
                else if (((_d = serviceInfo.cacheType) === null || _d === void 0 ? void 0 : _d.toLowerCase()) === "raster") {
                    item.agsType = "TiledImageServer";
                    if (isHybridImageService(url, serviceInfo) && _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.hybridImageServiceSetting !== "TiledImageServer") {
                        item.agsType = "ImageServer";
                    }
                }
            }
            const credential = serviceInfo.credential || esriId.findCredential(url);
            const documentInfo = serviceInfo.documentInfo;
            const keywords = ((documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.Keywords) || "").split(",");
            const serviceTitle = (_e = documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.Title) !== null && _e !== void 0 ? _e : serviceInfo.name;
            item.tags = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.b)([...keywords, ...itemTags]).filter((tag) => tag);
            // Keep parsed title if service is nullish or an empty string
            if ((serviceTitle === null || serviceTitle === void 0 ? void 0 : serviceTitle.length) > 0) {
                item.title = serviceTitle;
            }
            item.description = (_g = (_f = documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.Comments) !== null && _f !== void 0 ? _f : serviceInfo.description) !== null && _g !== void 0 ? _g : "";
            item.snippet = (_j = (_h = documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.Subject) !== null && _h !== void 0 ? _h : serviceInfo.serviceDescription) !== null && _j !== void 0 ? _j : "";
            item = Object.assign(Object.assign({}, item), { thumbnailToken: (credential === null || credential === void 0 ? void 0 : credential.token) || null, extent: item.extent || serviceInfo.fullExtent || serviceInfo.extent, serviceInfo: Object.assign(Object.assign({}, serviceInfo), { isSecure: checkAuth ? true : false, userInfo: { username, password } }) });
            return Object.assign({}, item);
        }
        catch (error) {
            if (((_k = error === null || error === void 0 ? void 0 : error.message) === null || _k === void 0 ? void 0 : _k.toLowerCase().includes("aborted")) || (error === null || error === void 0 ? void 0 : error.message) === "Error: json") {
                // user cancelled when prompted for login
                throw {
                    code: "flowAborted",
                    message: JSON.stringify(error.message.message)
                };
            }
            // Unfortunately the idManager throws an error AND calls back on the setProtocolErrorHandler when
            // an ago service needs to be accessed over ssl,  so set this flag to distunguish a typical error
            // vs the setProtocolError
            if (secureService.includes((_l = error === null || error === void 0 ? void 0 : error.code) !== null && _l !== void 0 ? _l : (_m = error === null || error === void 0 ? void 0 : error.details) === null || _m === void 0 ? void 0 : _m.httpStatus)) {
                if (item.allowStoredAuth !== false) {
                    item.allowStoredAuth = !item.checkUrlError;
                }
                return Object.assign(Object.assign({}, item), { isSecured: { secured: true }, serviceInfo: { isSecure: true }, 
                    // If we already determine that we can't store auth via `checkUrl`, just set it to false
                    allowStoredAuth: item.allowStoredAuth === false ? false : _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.allowStoredAuth });
            }
            else if ((error === null || error === void 0 ? void 0 : error.code) === 403) {
                item.serviceInfo = { isSecure: true };
                item.isSecured = { secured: true };
                throw {
                    code: "forbiddenCredential",
                    message: JSON.stringify(error)
                };
            }
            else if (error && ((_o = item.checkUrlError) === null || _o === void 0 ? void 0 : _o.message)) {
                // TODO: Handle error here using our standard form
                if ((_r = (_q = (_p = item.checkUrlError) === null || _p === void 0 ? void 0 : _p.message) === null || _q === void 0 ? void 0 : _q.includes) === null || _r === void 0 ? void 0 : _r.call(_q, "was not found")) {
                    throw {
                        code: "serviceNotExist",
                        message: JSON.stringify(item.checkUrlError.message)
                    };
                }
                throw {
                    code: "unhandledError",
                    message: JSON.stringify(item.checkUrlError.message)
                };
            }
            else if ((!!agsType && agsType !== "FeatureServer") ||
                (typeof error === "string" && error.includes("not found"))) {
                throw { code: "serviceNotExist", message: JSON.stringify(error) };
            }
            else if (isBackendError(error) &&
                error.details[0] === "The input spatial reference must be either a geographic or projected coordinate system") {
                throw {
                    code: "invalidSpatialRef",
                    message: JSON.stringify(error)
                };
            }
            else if (retry < MAX_RETRY) {
                return getAGSServiceInfo(item, extraParams, retry + 1);
            }
        }
    }
    else if (((_s = item.isSecured) === null || _s === void 0 ? void 0 : _s.isFederatedWithWebTierAuth) || ((_t = item.isSecured) === null || _t === void 0 ? void 0 : _t.httpStatusCode) === 401) {
        try {
            const { title } = item;
            const serviceInfo = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(item.url, {}, { addTokenManually: false });
            const documentInfo = serviceInfo.documentInfo;
            const keywords = (documentInfo.Keywords || "").split(",");
            const tags = [...(0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.b)([...keywords, ...itemTags])];
            item = Object.assign(Object.assign({}, item), { extent: serviceInfo.fullExtent || serviceInfo.extent, serviceInfo });
            return Object.assign(Object.assign({}, item), { title, tags });
        }
        catch (error) {
            if (error.status === 401) {
                throw { code: "unauthorized" };
            }
            throw { code: "serviceNotExist", message: JSON.stringify(error) };
        }
    }
}
async function addSecureAGSUrl(itemProperties) {
    const { serviceInfo, username, password, isSecured, storeAuth, type } = itemProperties;
    const { user, portal, config } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const itemType = type;
    const userInfo = { username, password };
    const { thumbnailURL } = (0,_file_bf8ab90f_js__WEBPACK_IMPORTED_MODULE_12__.g)(itemType);
    const item = Object.assign(Object.assign({}, itemProperties), { thumbnailURL: thumbnailURL || itemProperties.thumbnailURL });
    if (((serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.isSecure) && !serviceInfo.userInfo) ||
        ((isSecured === null || isSecured === void 0 ? void 0 : isSecured.isOverride) && !userInfo) ||
        ((isSecured === null || isSecured === void 0 ? void 0 : isSecured.httpStatusCode) !== 401 && !userInfo) ||
        (storeAuth && !userInfo)) {
        throw new Error("invalidCredentials");
    }
    if (isSecured) {
        if (storeAuth) {
            if (!portal.isPortal || (portal.isPortal && (0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.e)())) {
                item.serviceUsername = username;
                item.servicePassword = password;
            }
            else {
                throw new Error();
            }
            if (isSecured.httpStatusCode === 401) {
                const result = await addItem(item, config === null || config === void 0 ? void 0 : config.restBaseUrl).then(({ id }) => (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(`${user.userContentUrl}/items/${id}`, {}, {}, "post"));
                const updatedItem = Object.assign(Object.assign({}, item), { id: result.item.id, url: result.item.url, sourceUrl: result.item.sourceUrl });
                return addAGSService(updatedItem, true);
            }
            else if ((serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.isSecure) && !(serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.userInfo)) {
                throw new Error("invalidCredentials");
            }
        }
    }
    return addAGSService(item);
}
async function addAGSService(itemProperties, update = false) {
    var _a, _b, _c, _d, _e;
    const { url, serviceInfo, type, storeAuth, hybridImageServiceSetting, id } = itemProperties;
    let singlelayer = { StreamServer: 1, ImageServer: 1, WorkspaceServer: 1 }, serviceLayers;
    if (!serviceInfo && !storeAuth) {
        throw new Error("serviceNotExist");
    }
    if (storeAuth && !serviceInfo) {
        const updatedProperties = await getAGSServiceInfo(itemProperties);
        return Object.assign(Object.assign({}, updatedProperties), { success: true, id, folder: (_a = itemProperties.folder) === null || _a === void 0 ? void 0 : _a.title });
    }
    const updatedItem = Object.assign(Object.assign({}, itemProperties), { description: (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.description) || ((_b = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.documentInfo) === null || _b === void 0 ? void 0 : _b.Comments) || "", accessInformation: (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.copyrightText) || ((_c = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.documentInfo) === null || _c === void 0 ? void 0 : _c.Credits) || "", spatialReference: getSpatialReference(itemProperties.serviceInfo, itemProperties.agsType) });
    //For icon purposes we can update the
    //typeKeywords to show different icons
    if ((type === null || type === void 0 ? void 0 : type.toLowerCase()) === "map service") {
        updatedItem.typeKeywords.push((serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.singleFusedMapCache) ? "Tiled" : "Dynamic");
    }
    if ((type === "Image Service" && hybridImageServiceSetting === "TiledImageServer") ||
        isTilesOnlyImageService(url, serviceInfo)) {
        updatedItem.typeKeywords = _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_13__.a.TiledImageServer.typeKeywords;
    }
    if ((serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.type) === "Table") {
        updatedItem.typeKeywords = [...updatedItem.typeKeywords, "Table", "Singlelayer"];
    }
    if (type in singlelayer) {
        updatedItem.typeKeywords.push("Singlelayer");
    }
    else if ((serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.layers) || (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.tables)) {
        if ((!serviceInfo.layers || !((_d = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.layers) === null || _d === void 0 ? void 0 : _d.length)) && (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.tables.length)) {
            //Check if "Table" was added above, dont want to add it twice
            if (updatedItem.typeKeywords.findIndex((type) => type === "Table") === -1) {
                updatedItem.typeKeywords.push("Table");
            }
            updatedItem.typeKeywords.push(serviceInfo.tables.length > 1 ? "Multilayer" : "Singlelayer");
        }
        else {
            serviceLayers = [...(serviceInfo.layers || []), ...(serviceInfo.tables || [])];
            updatedItem.typeKeywords.push(serviceLayers.length > 1 ? "Multilayer" : "Singlelayer");
        }
    }
    //For icon purposes we need to update the typeKeywords for a SceneServer added by reference
    if ((type === null || type === void 0 ? void 0 : type.toLowerCase()) === "sceneserver") {
        const { layers } = serviceInfo;
        const layerType = ((_e = layers === null || layers === void 0 ? void 0 : layers[0]) === null || _e === void 0 ? void 0 : _e.layerType) || (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.layerType);
        layerType && updatedItem.typeKeywords.push(layerType);
    }
    try {
        const { extent: wgsExtent } = await projectExtentToWGS84FromItem(Object.assign({}, updatedItem));
        const item = updatedItem;
        const itemInfo = (0,_file_bf8ab90f_js__WEBPACK_IMPORTED_MODULE_12__.g)(item.type);
        item.type = itemInfo.type;
        item.typeKeywords = [...(item.typeKeywords || []), ...(itemInfo.typeKeywords || [])];
        if (!storeAuth) {
            // TODO: unify extent formatting, thumbnail generation between here and updateProxyService
            const extentAsString = extentToString(item.extent);
            const e = extentAsString.split(",");
            const formattedExtent = [
                [parseFloat(e[0]), parseFloat(e[1])],
                [parseFloat(e[2]), parseFloat(e[3])]
            ];
            item.extent = formattedExtent;
            const thumbnailURL = await getAGSThumbnail(item);
            item.thumbnailURL = thumbnailURL;
            if (item.thumbnailURL && item.thumbnailToken) {
                item.thumbnailURL += `${item.thumbnailURL.indexOf("?") > -1 ? "&" : "?"}${item.thumbnailToken}`;
            }
            item.extent = extentToString(item.type === "Feature Service" ? wgsExtent : item.extent);
        }
        if (storeAuth) {
            return updateProxyService(item);
        }
        if (update) {
            return (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.u)(item.id, Object.assign(Object.assign({}, item), { url: item.sourceUrl }));
        }
        else {
            return addUrl(item);
        }
    }
    catch (error) {
        if (storeAuth) {
            throw error;
        }
        return addUrl(itemProperties);
    }
}
async function updateProxyService(itemProperties) {
    const { user } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const { exportTilesAllowed } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a;
    const createdItem = await addUrl(itemProperties);
    const requestUrl = `${user.userContentUrl}/items/${createdItem.id}`;
    const { item } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(requestUrl, {}, {}, "post");
    const serviceInfoUrl = exportTilesAllowed ? itemProperties.url : item.url;
    const updatedItem = await getAGSServiceInfo(Object.assign(Object.assign({}, itemProperties), { type: _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.type }), serviceInfoUrl);
    const { typeKeywords, thumbnailToken, spatialReference, extent, description } = updatedItem;
    itemProperties.id = createdItem.id;
    itemProperties.typeKeywords = typeKeywords;
    itemProperties.thumbnailToken = thumbnailToken;
    itemProperties.spatialReference = spatialReference;
    itemProperties.extent = extent;
    itemProperties.description = description;
    // INC1055397 - On its own, a failed thumbnail shouldn't derail the whole upload process (?)
    // TODO: If needed, throw a more specific error in the catch block
    try {
        const extentAsString = extentToString(updatedItem.extent);
        const e = extentAsString.split(",");
        const formattedExtent = [
            [parseFloat(e[0]), parseFloat(e[1])],
            [parseFloat(e[2]), parseFloat(e[3])]
        ];
        itemProperties.extent = formattedExtent;
        /**
         * Using the newly created item's url sometimes throw an "Invalid URL" error
         * if the is created from URL with special characters in its name for some reason
         * https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/46946
         * So we have to use the original url that was entered by the user
         * Should have the same thumbnail technically
         */
        const thumbnailURL = await getAGSThumbnail(itemProperties);
        item.thumbnailURL = thumbnailURL;
        if (item.thumbnailURL && item.thumbnailToken) {
            item.thumbnailURL += `${item.thumbnailURL.indexOf("?") > -1 ? "&" : "?"}${item.thumbnailToken}`;
        }
    }
    catch (error) {
        console.error(error);
    }
    await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.u)(createdItem.id, { thumbnailURL: item.thumbnailURL });
    return createdItem;
}

const overrideUrls = [
    "geocode.arcgis.com",
    "geocodedev.arcgis.com",
    "geocodeqa.arcgis.com",
    "route.arcgis.com",
    "routedev.arcgis.com",
    "routeqa.arcgis.com",
    "geoenrich.arcgis.com",
    "geoenrichqa.arcgis.com",
    "geoenrichddev.arcgis.com"
];
async function getIsSecured(userInfo, serviceUrl, restBaseUrl, checkAuth, checkAuthViaServiceUrl = false) {
    // the /checkURL call will respond whether a service needs authentication or not.
    const url = serviceUrl.split("?")[0];
    const securedURL = `${restBaseUrl}portals/checkurl`;
    const isOverrideUrl = overrideUrls.some((url) => serviceUrl.indexOf(url) !== -1);
    if (isOverrideUrl) {
        return { secured: true, isOverride: true };
    }
    else {
        const isVectorTileService = !isOverrideUrl && serviceUrl.indexOf("/VectorTileServer") > -1;
        const requestUrl = `${securedURL}?url=${encodeURIComponent(`${addParameters(`${url}?f=json`)}`)}`;
        try {
            if (checkAuthViaServiceUrl) {
                // Internal URLs cannot be checked via `checkUrl`, and must check the service itself.
                // If the `Error checking resource` message was caught previously, this will ping the service and
                // force an auth popup if the internal service is secured, then hide the stored auth toggle.
                // Ref: https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/41451#issuecomment-3808674
                await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, {}, { disableIdentityLookup: true, addTokenManually: false });
            }
            const result = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(requestUrl, {}, { addTokenManually: false });
            const { httpStatusCode } = result;
            if (result.secured) {
                if (httpStatusCode === 403) {
                    //See https://devtopia/WebGIS/arcgis-portal-app/issues/51 403 considered not-secure
                    result.secured = false;
                }
                else if (httpStatusCode === 401) {
                    // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/35981 web tier auth doesn't allow storing credentials
                    result.allowStoredAuth = false;
                }
            }
            else if (isVectorTileService) {
                // For vectorTile services where the root url is not secured, but exportTilesAllowed = true, may have the "exporTiles" endpoint secured,
                // we need to check that here, if it is secured then we need to prompt for credentials https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/19510
                const serviceInfo = await getServiceInfo({ username: userInfo.username, password: userInfo.password }, serviceUrl, { isVideoService: false, checkAuth });
                _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.exportTilesAllowed = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.exportTilesAllowed;
                if (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.exportTilesAllowed) {
                    return getIsSecured(userInfo, `${serviceUrl}/exportTiles`, restBaseUrl, checkAuth);
                }
            }
            return Object.assign(Object.assign({}, result), { isOverride: false });
        }
        catch (error) {
            const { message, code } = error;
            // Internal service URL detected
            if (message === "Error checking resource") {
                // Don't re-run if we already tried to check the auth via the URL
                // TODO post 2023R03: add an explicit case to handle internal URLs outside the catch block
                return checkAuthViaServiceUrl
                    ? {
                        secured: false,
                        url: serviceUrl,
                        httpResponse: "",
                        httpStatusCode: code,
                        httpStatusMessage: message,
                        isOverride: false,
                        allowStoredAuth: false
                    }
                    : getIsSecured(userInfo, serviceUrl, restBaseUrl, checkAuth, true);
            }
            else if (message === "Service Proxy URL") {
                return {
                    secured: true,
                    url: serviceUrl,
                    httpResponse: "",
                    httpStatusCode: code,
                    httpStatusMessage: message,
                    isOverride: false,
                    allowStoredAuth: false,
                    useProxy: true
                };
            }
            return {
                allowStoredAuth: false,
                url: serviceUrl,
                httpResponse: "",
                httpStatusCode: code,
                httpStatusMessage: message,
                isOverride: false
            };
        }
    }
}
function isEsriHostedService(url) {
    // esri hosted service: https://dev0011211.esri.com/server/rest/services/Hosted/California/FeatureServer
    return url.indexOf(".esri.com/server/rest/services") > -1 ? true : false;
}
function isHybridImageService(url, serviceInfo) {
    var _a;
    return (url.toLowerCase().indexOf("/imageserver") > -1 &&
        (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.cacheType) === "Raster" &&
        ((_a = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.capabilities) === null || _a === void 0 ? void 0 : _a.toLowerCase().indexOf("tilesonly")) === -1);
}
function isTilesOnlyImageService(url, serviceInfo) {
    var _a, _b;
    return ((_a = url.toLowerCase()) === null || _a === void 0 ? void 0 : _a.includes("/imageserver")) && ((_b = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.capabilities) === null || _b === void 0 ? void 0 : _b.toLowerCase().includes("tilesonly"));
}
async function getServiceInfo(userInfo, svcUrl, options) {
    var _a;
    const config = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.config;
    const [esriId] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3 ? "esri/IdentityManager" : "esri/identity/IdentityManager"
    ]);
    const { forceAddToken, isSecure, checkAuth } = options;
    const { username, password } = userInfo;
    const method = "auto";
    const isHosted = (0,_url_35875a10_js__WEBPACK_IMPORTED_MODULE_11__.a)(svcUrl);
    const isESRI = isEsriHostedService(svcUrl);
    const hostedService = isHosted || isESRI;
    const isOverrideUrl = overrideUrls.some((url) => svcUrl.indexOf(url) !== -1);
    const requestOptions = {
        useProxy: (_a = options === null || options === void 0 ? void 0 : options.useProxy) !== null && _a !== void 0 ? _a : false,
        timeout: config.isMultiTenant === false ? 60000 : 5000,
        addSSL: hostedService,
        addTokenManually: (isSecure && hostedService && !!config.isMultiTenant) || forceAddToken || false,
        disableIdentityLookup: null
    };
    if (checkAuth) {
        svcUrl = svcUrl.split("?")[0];
        if (isOverrideUrl) {
            await signIn(svcUrl, { username, password });
            return serviceInfoRequest(svcUrl, requestOptions, method);
        }
        else {
            if (isSecure.secured && username && password) {
                requestOptions.customToken = await getSecuredServiceCustomToken(svcUrl, { username, password });
            }
            // Video Service URL doesn't accept POST method
            const result = await serviceInfoRequest(svcUrl, requestOptions, method);
            result.credential = esriId.findCredential(svcUrl);
            if (result.credential) {
                esriId.registerToken({
                    server: svcUrl,
                    token: result.credential.token,
                    userId: result.credential.userId,
                    expires: result.credential.expires,
                    ssl: result.credential.ssl
                });
            }
            return result;
        }
    }
    // `disableIdentityLookup` will override the Id manager in ESRIRequest so that it doesnt render the auth window - which has been a pain point for certain urls - if you have an issue with authentication and the ID manager check here first.
    requestOptions.disableIdentityLookup = true;
    return await serviceInfoRequest(svcUrl, requestOptions, method);
}
/**
 * Attempt to sign in using Identity manager and return the token
 *
 * Will retrieve from cache first if not expired
 */
const getSecuredServiceCustomToken = async (url, { username, password }) => {
    const { token } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.f)(() => signIn(url, { username, password }), "securedAGSToken", `${url}---${username}`, { getExpireAfterFromResult: (result) => result.expireAfter });
    return token;
};
async function signIn(svcUrl, userInfo) {
    const is3x = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3;
    const [esriId, Credential] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        is3x ? "esri/IdentityManager" : "esri/identity/IdentityManager",
        is3x ? "esri/Credential" : "esri/identity/Credential"
    ]);
    if (userInfo.username && userInfo.password) {
        const serverInfo = await findServerInfo(svcUrl);
        if (esriId._checkProtocol(svcUrl, serverInfo, (error) => console.error(error))) {
            try {
                const response = await esriId.generateToken(serverInfo, userInfo);
                const expires = response.expires ? Number(response.expires) : null;
                const ssl = !!response.ssl;
                const cred = new Credential({
                    userId: userInfo.username,
                    server: serverInfo.server,
                    token: response.token,
                    expires,
                    ssl,
                    validity: serverInfo.shortLivedTokenValidity,
                    resources: [svcUrl],
                    scope: "server"
                });
                if (esriId.credentials.indexOf(cred) === -1) {
                    esriId.credentials.push(cred);
                }
                return { token: cred.token, expireAfter: expires };
            }
            catch (error) {
                error.code = 403;
                throw error;
            }
        }
        return null;
    }
}
async function findServerInfo(serviceUrl) {
    const is3x = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3;
    const [esriId, ServerInfo] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_9__.l)([
        is3x ? "esri/IdentityManager" : "esri/identity/IdentityManager",
        is3x ? "esri/ServerInfo" : "esri/identity/ServerInfo"
    ]);
    let serverInfo = await esriId.findServerInfo(serviceUrl);
    if (!serverInfo) {
        serverInfo = new ServerInfo();
        serverInfo.server = await esriId._getOrigin(serviceUrl);
        const { authInfo, tokenServiceUrl, currentVersion } = await (is3x ? get3xTokenSvcUrl : get4xTokenSvcUrl)(serviceUrl, esriId);
        serverInfo.tokenServiceUrl =
            (authInfo === null || authInfo === void 0 ? void 0 : authInfo.tokenServicesUrl) ||
                (
                // @ts-ignore --- seems like we did this previously for backwards compatibility but it doesn't exist on ServerInfo
                authInfo === null || authInfo === void 0 ? void 0 : authInfo.tokenServiceUrl) ||
                tokenServiceUrl;
        serverInfo.currentVersion = currentVersion;
        serverInfo.hasServer = true;
        esriId.registerServers([serverInfo]);
    }
    return serverInfo;
}
const get4xTokenSvcUrl = async (serviceUrl, esriId) => {
    const response = (await esriId._getTokenSvcUrl(serviceUrl));
    return await response.promise;
};
const get3xTokenSvcUrl = async (serviceUrl, esriId) => {
    return esriId._getTokenSvcUrl(serviceUrl);
};
async function serviceInfoRequest(serviceUrl, options, method = "post") {
    try {
        return await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(addParameters(serviceUrl), {}, Object.assign({}, options), method);
    }
    catch (error) {
        throw error;
    }
}
async function getUrlServiceInfo(item) {
    var _a, _b;
    let urlServiceInfo = {};
    if ((0,_ags_eb458a03_js__WEBPACK_IMPORTED_MODULE_10__.i)(item.type)) {
        urlServiceInfo = await getSecuredAGSServiceInfo(item);
    }
    else {
        switch (item.type) {
            case "OGCFeatureServer":
                urlServiceInfo = await getOGCFeatureLayerServiceInfo(item);
                break;
            case "WMS":
                const { result, error } = await getWMSServiceInfo(item);
                if (error) {
                    urlServiceInfo.error = error;
                }
                else {
                    const wmsLayers = await loadWMSLayers(result.serviceInfo);
                    urlServiceInfo.result = Object.assign(Object.assign({}, result), wmsLayers);
                }
                break;
            case "WFS":
                urlServiceInfo = await getWFSServiceInfo(item);
                if (urlServiceInfo.result) {
                    urlServiceInfo.result.layers = urlServiceInfo.result.serviceInfo.layers;
                    urlServiceInfo.result.title = (_a = urlServiceInfo.result.serviceInfo.title) !== null && _a !== void 0 ? _a : "";
                    urlServiceInfo.result.isComplex = urlServiceInfo.result.serviceInfo.isComplex === "esriGeometryComplex";
                }
                break;
            case "WMTS":
                urlServiceInfo = await getWMTSServiceInfo(item);
                if (urlServiceInfo.result) {
                    urlServiceInfo.result.layers = urlServiceInfo.result.serviceInfo.layers;
                    urlServiceInfo.result.title = (_b = urlServiceInfo.result.serviceInfo.title) !== null && _b !== void 0 ? _b : "";
                }
                break;
            default:
                urlServiceInfo = { result: Object.assign({}, item) };
                break;
        }
    }
    return urlServiceInfo;
}
// We need to send layer's relationship in a separate /addToDefinition call
// https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/4319
// So this function should NOT accept layers/tables with relationships
async function createService(service, options) {
    var _a, _b;
    // Spread to avoid manipulating the original content
    const copiedService = Object.assign({}, service);
    const { config, user, asyncAddToDefinition = true } = options;
    const addToDefinitionContent = {
        layers: (_a = copiedService.layers) !== null && _a !== void 0 ? _a : [],
        tables: (_b = copiedService.tables) !== null && _b !== void 0 ? _b : []
    };
    const addToDefinitionRequestContent = JSON.stringify(addToDefinitionContent);
    // Create service fails if passing layers, tables
    delete copiedService.layers;
    delete copiedService.tables;
    delete copiedService.initialExtent;
    delete copiedService.fullExtent;
    delete copiedService._ssl;
    const createServiceContent = { createParameters: JSON.stringify(copiedService), targetType: "featureService" };
    const url = `${config.restBaseUrl}content/users/${user.username}/createService`;
    const createServiceResponse = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, createServiceContent, {}, "post");
    try {
        await addToDefinition(addToDefinitionRequestContent, createServiceResponse.encodedServiceURL, asyncAddToDefinition);
        return { createServiceResponse, addToDefinitionResponse: addToDefinitionContent };
    }
    catch (err) {
        // if there were errors adding to the definition, clean up after ourselves and delete the service
        const deleteUrl = `${user.userContentUrl}/items/${createServiceResponse.itemId}/delete`;
        await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(deleteUrl, {}, {}, "post");
        console.error(err);
        throw err;
    }
}
async function addToDefinition(params, encodedServiceURL, async = true) {
    if (params) {
        const adminUrl = encodedServiceURL.replace("rest/services", "rest/admin/services");
        const url = `${adminUrl}/addToDefinition`;
        try {
            const result = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, { addToDefinition: params, async }, {}, "post");
            return async ? await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.p)(result.statusURL) : result;
        }
        catch (error) {
            if (async) {
                // TODO: handle error gracefully
                // TODO: remove this once the backend shows meaningful errors on `async: true`
                // `async: true` doesn't show a meaningful error.
                //    so we do this to get the actual error for debugging purposes
                await addToDefinition(params, encodedServiceURL, false);
            }
            throw error;
        }
    }
    return null;
}
function getLayerItemData(item, portal) {
    // TODO: refactor this to use getItemData from server-item.ts
    const url = `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.g)(portal)}content/items/${item.id}/data`;
    return (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(url);
}
/**
 * Fetch an item of type "Layer Template" used by the org to create new attachment layers
 */
async function findTemplateServiceInfo(portal) {
    var _a, _b;
    const groupResponse = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.q)({ q: 'title: "Esri Layer Templates" AND owner: "esri_en"', num: 1 });
    const group = (_a = groupResponse.results) === null || _a === void 0 ? void 0 : _a[0];
    if (!group) {
        return null;
    }
    const templateResponse = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.r)(`${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_8__.g)(portal)}/search`, {
        q: `title:"Points" group:"${group.id}" AND type:"Layer Template" -type:"Attachment"`,
        num: 1
    });
    const template = (_b = templateResponse.results) === null || _b === void 0 ? void 0 : _b[0];
    return template ? getLayerItemData(template, portal) : null;
}

var __rest = ( false) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const defaultTemplateServiceInfo = {
    currentVersion: 10.51,
    hasVersionedData: false,
    supportsDisconnectedEditing: false,
    hasStaticData: false,
    maxRecordCount: 2000,
    supportedQueryFormats: "JSON",
    supportsVCSProjection: false,
    capabilities: "Query,Editing,Create,Update,Delete,Sync",
    description: "",
    copyrightText: "",
    allowGeometryUpdates: true,
    units: "esriMeters",
    supportsAppend: true,
    syncEnabled: false,
    supportsApplyEditsWithGlobalIds: false,
    editorTrackingInfo: {
        allowAnonymousToDelete: true,
        allowAnonymousToQuery: true,
        allowAnonymousToUpdate: true,
        allowOthersToDelete: false,
        allowOthersToQuery: true,
        allowOthersToUpdate: true,
        enableEditorTracking: false,
        enableOwnershipAccessControl: false
    },
    xssPreventionInfo: { xssPreventionEnabled: true, xssPreventionRule: "InputOnly", xssInputRule: "rejectInvalid" },
    _ssl: true
};
const addFeatureLayer = async (requestParams) => {
    var _a, _b, _c;
    const { tags, serviceInfo, typeKeywords: storeTypeKeywords, extent: storeExtent, selectedServiceInfoLayersNames, addFeatureLayerType } = requestParams;
    const { portal } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const isEnterprise = portal.isPortal;
    if (!serviceInfo) {
        // TODO: have a better error message here
        throw new Error("No service info found.");
    }
    try {
        // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/37255#issuecomment-3186564
        let presetServiceInfo = defaultTemplateServiceInfo;
        try {
            presetServiceInfo = (_a = (await findTemplateServiceInfo(portal))) !== null && _a !== void 0 ? _a : defaultTemplateServiceInfo;
            presetServiceInfo.capabilities = "Query,Editing,Create,Update,Delete";
            // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/38966
            presetServiceInfo.hasStaticData = false;
        }
        catch (error) {
            console.warn(`Could not fetch template ${JSON.stringify(error)}`);
        }
        const featureLayerServiceInfo = serviceInfo;
        let baseLayer = (_b = featureLayerServiceInfo.layers) !== null && _b !== void 0 ? _b : [];
        let baseTables = (_c = featureLayerServiceInfo.tables) !== null && _c !== void 0 ? _c : [];
        // * Filter selected layers
        // ! Make sure this is done before extractAndCleanRelationshipParam because the `relationship`
        // !   depends on it!
        // Build from scratch flow will automatically be filter at the end of its page
        if (addFeatureLayerType !== "build" && selectedServiceInfoLayersNames) {
            const checkSelected = (layer) => selectedServiceInfoLayersNames[layer.name];
            baseLayer = baseLayer.filter(checkSelected);
            baseTables = baseTables.filter(checkSelected);
        }
        // * Filter unique index
        // ! Sometimes the backend returns template layers with duplicate indexes,
        // !  we need to make it unique until the problem got fixed
        // ? Note that this might be a bug in the /addToDefinition backend because
        // ?  https://developers.arcgis.com/rest/services-reference/online/add-to-definition-feature-service-.htm
        // ?  example seems to allow duplicate fields
        const { layers: uniqueIndexLayers, tables: uniqueIndexTables } = extractUniqueIndex(baseLayer, baseTables);
        // * Fix ids
        //  Some template returns noncontinuous id, which is bad
        //  => we also need to fix ids that case
        const { layers, tables } = fixIds(uniqueIndexLayers, uniqueIndexTables);
        // * Form parameters
        const createParameters = Object.assign(Object.assign(Object.assign({}, presetServiceInfo), serviceInfo), { name: featureLayerServiceInfo.name || _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.title, layers,
            tables });
        // * Clean parameters
        // We need to send layer's relationship in a separate /addToDefinition call
        // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/4319
        // There are also some case where layers depend on each other (hence the `relationship`)
        //  but some of the layers are deselected so we need to make sure the bad relationship doesn't go the backend
        // => extract and clean
        const { cleanedCreateParameters, relationshipParameters } = extractAndCleanRelationshipParam(createParameters);
        // *   the rest of the properties
        const cherryPickProps = [
            "serviceDescription",
            "hasStaticData",
            "maxRecordCount",
            "supportedQueryFormats",
            "capabilities",
            "description",
            "copyrightText",
            "spatialReference",
            "initialExtent",
            "fullExtent",
            "_ssl",
            "allowGeometryUpdates",
            "units",
            "xssPreventionInfo"
        ];
        cherryPickProps.forEach((key) => {
            const value = featureLayerServiceInfo[key];
            value != null && (cleanedCreateParameters[key] = value);
        });
        cleanedCreateParameters.name = (0,_functional_81373f6d_js__WEBPACK_IMPORTED_MODULE_6__.a)(cleanedCreateParameters.name);
        if (addFeatureLayerType === "template") {
            cleanedCreateParameters.syncEnabled = true;
            cleanedCreateParameters.capabilities = "Query,Editing,Create,Update,Delete,Sync";
        }
        // * Send requests
        const { createServiceResponse } = await createService(cleanedCreateParameters, {
            asyncAddToDefinition: !isEnterprise,
            config: _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.config,
            user: _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.user
        });
        const { itemId, success } = createServiceResponse;
        const { typeKeywords: itemTypeKeywords } = (await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.a)(itemId)).result;
        const typeKeywords = [...storeTypeKeywords, ...itemTypeKeywords];
        if (serviceInfo.captureGPS) {
            typeKeywords.push("gpsMetadataEnabled");
        }
        try {
            // number taken from the old UI's "/update" endpoint
            const extent = portal.defaultExtent || serviceInfo.fullExtent || serviceInfo.extent || storeExtent;
            const spatialReference = extent.spatialReference.wkid || extent.spatialReference.wkt || "4326";
            const extentString = extentToString(isValidWGS84Extent(extent) ? extent : await projectExtentToWGS84(extent));
            const thumbnailURL = `https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/export?size=800,532&format=png24&bboxSR=${spatialReference}&bbox=${extentString}&f=image`;
            const isInRoot = isFolderRoot(_item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.folder);
            await Promise.all([
                (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.u)(itemId, {
                    title: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.title,
                    typeKeywords: typeKeywords.join(","),
                    tags: (tags !== null && tags !== void 0 ? tags : _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.tags).join(","),
                    extent: extentString,
                    snippet: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.snippet,
                    description: _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a.description
                }),
                relationshipParameters.layers || relationshipParameters.tables
                    ? addToDefinition(JSON.stringify(relationshipParameters), createServiceResponse.encodedServiceURL, !isEnterprise)
                    : undefined,
                !isInRoot && (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.m)(itemId, _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.folder.id)
            ]);
            // No await, just leave it be
            (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.u)(itemId, { thumbnailURL }).catch(console.error);
            return { success, id: itemId, folder: _item_properties_10491b2e_js__WEBPACK_IMPORTED_MODULE_3__.i.folder.id };
        }
        catch (error) {
            (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_7__.d)(itemId);
            console.error(error);
            throw error;
        }
    }
    catch (error) {
        console.error(error);
        throw error;
    }
};
const getServiceAndLayerInfo = async (serviceUrl, restBaseUrl, forceAddToken, isSecure
// TODO: refactor this to new error system
) => {
    var _a;
    const { username, password, checkAuth } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_4__.a;
    try {
        const getServiceInfoWrapper = (url) => getServiceInfo({ username, password }, url, {
            forceAddToken,
            isSecure,
            // Add the time of writing, only feature layer and tile layer use this method, so they're not a video service
            isVideoService: false,
            checkAuth
        });
        const extractedServiceInfo = (0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.p)(serviceUrl);
        if (!extractedServiceInfo) {
            console.warn("invalid service info");
            return null;
        }
        const { baseServerUrl, index } = extractedServiceInfo;
        const serviceInfo = (await getServiceInfoWrapper(baseServerUrl));
        const layers = (await Promise.all((serviceInfo.layers || [])
            .filter((layer) => index === null || layer.id === index)
            .map((layer) => getServiceInfoWrapper(`${baseServerUrl}/${layer.id}`))));
        const tables = (await Promise.all((serviceInfo.tables || [])
            .filter((table) => index === null || table.id === index)
            .map((table) => getServiceInfoWrapper(`${baseServerUrl}/${table.id}`))));
        return { serviceInfo, layers, tables };
    }
    catch (error) {
        console.error(error);
        if (((_a = error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "token required") {
            try {
                const { secured } = await getIsSecured({ username, password }, serviceUrl, restBaseUrl, checkAuth);
                return await getServiceAndLayerInfo(serviceUrl, restBaseUrl, secured);
            }
            catch (error) {
                throw error;
            }
        }
        throw error;
    }
};
const extractAndCleanRelationshipParam = (createParameters) => {
    const lookupMap = {};
    const setupLookupMap = (relationship) => (lookupMap[relationship.id] = true);
    createParameters.layers.forEach(setupLookupMap);
    createParameters.tables.forEach(setupLookupMap);
    // * Extract relationship
    // ! Do not delete layer.relationships here or it will break when
    // !  the user go Back then Next in the case item creation failed
    const filterMissingRelationship = (relationship) => lookupMap[relationship.relatedTableId];
    const extractRelationship = (layer) => ({
        relationships: layer.relationships.filter(filterMissingRelationship),
        id: layer.id
    });
    const filterEmptyRelationship = (layer) => { var _a; return ((_a = layer.relationships) === null || _a === void 0 ? void 0 : _a.length) > 0; };
    const layerRelationships = createParameters.layers.map(extractRelationship).filter(filterEmptyRelationship);
    const tableRelationships = createParameters.tables.map(extractRelationship).filter(filterEmptyRelationship);
    const relationshipParameters = { layers: layerRelationships, tables: tableRelationships };
    if (relationshipParameters.layers.length === 0) {
        delete relationshipParameters.layers;
    }
    if (relationshipParameters.tables.length === 0) {
        delete relationshipParameters.tables;
    }
    // * Create new createParameters without relationship
    const layers = createParameters.layers.map((_a) => {
        var layers = __rest(_a, ["relationships"]);
        return layers;
    });
    const tables = createParameters.tables.map((_a) => {
        var tables = __rest(_a, ["relationships"]);
        return tables;
    });
    const cleanedCreateParameters = Object.assign(Object.assign({}, createParameters), { layers, tables });
    return { relationshipParameters, cleanedCreateParameters };
};
const extractUniqueIndex = (layers, tables) => {
    const getUniqueIndexLayer = (layer) => (Object.assign(Object.assign({}, layer), { indexes: (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.u)(layer.indexes, (item) => item.name) }));
    return {
        layers: layers.map(getUniqueIndexLayer),
        tables: tables.map(getUniqueIndexLayer)
    };
};
/** Fix ids for both layers and relationships */
const fixIds = (layers, tables) => {
    // https://devtopia.esri.com/WebGIS/arcgis-portal-app/blob/master/src/js/arcgisonline/sharing/dijit/dialog/PublishWizard.js#L1450-L1483
    let layerInfos = (0,_feature_layer_79fb302c_js__WEBPACK_IMPORTED_MODULE_5__.c)(layers, tables);
    // * Fix layers ids
    /** Record<old id, new id> */
    const oldLayerIds = {};
    layerInfos = layerInfos.map((layerInfo, index) => {
        oldLayerIds[layerInfo.id] = index;
        const newLayer = Object.assign(Object.assign({}, layerInfo), { id: index });
        return newLayer;
    });
    // * Fix relationshipIds
    layerInfos.forEach((layerInfo) => {
        var _a;
        layerInfo.relationships = ((_a = layerInfo.relationships) !== null && _a !== void 0 ? _a : []).map((relationship) => {
            const oldRelatedId = relationship.relatedTableId;
            const newRelatedId = oldLayerIds[oldRelatedId];
            const newRelationship = Object.assign(Object.assign({}, relationship), { relatedTableId: newRelatedId });
            return newRelationship;
        });
    });
    return layerInfos.reduce((result, curInfo) => {
        curInfo.type === "Table" ? result.tables.push(curInfo) : result.layers.push(curInfo);
        return result;
    }, { layers: [], tables: [] });
};



//# sourceMappingURL=feature-layer-573bb473.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/file-bf8ab90f.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/file-bf8ab90f.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ sanitizeFileName),
/* harmony export */   f: () => (/* binding */ formatFileSize),
/* harmony export */   g: () => (/* binding */ getItemInfoByType),
/* harmony export */   s: () => (/* binding */ sanitizeFileInput),
/* harmony export */   v: () => (/* binding */ validateOverwriteFileName)
/* harmony export */ });
/* harmony import */ var _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./item-types-2029b06b.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-types-2029b06b.js");
/* harmony import */ var _guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./guid-aeaed84d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



function sanitizeFileName(name, addGUID) {
    //TODO: add new param to spec file.
    const expression = /(?:\.([^.]+))?$/;
    const invalidTitleCharacters = /\.|-/g;
    let fileName = name.replace(/^.*(\\|\/|:)/, "");
    let extension = (fileName && expression.exec(fileName)[1] ? expression.exec(fileName)[1].toLowerCase() : "");
    let title = "";
    if (fileName.indexOf(".rft.") > -1) {
        const [name, suffix] = fileName.split(".rft.");
        extension = `rft.${suffix}`;
        title = name;
    }
    if (fileName && !title) {
        title = fileName.lastIndexOf(".") === -1 ? fileName : fileName.substring(0, fileName.lastIndexOf("."));
    }
    // Replace any invalid characters with an underscore
    title = title.replace(invalidTitleCharacters, "_");
    // Allow file upload of existing item's file name // currently used in append
    if (addGUID) {
        title = makeUniqueFileName(title);
        fileName = `${title}.${extension}`;
    }
    return { title, fileName, extension };
}
// Helper method that takes in a file & returns the cleaned up file name as is and in title form, and the detected file extension
function sanitizeFileInput(file, addGUID) {
    return sanitizeFileName(file.name, !!addGUID);
}
function makeUniqueFileName(name) {
    return `${name}_${(0,_guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_1__.g)()}`;
}
function validateOverwriteFileName(uploadedFileName, sourceFileName) {
    let fileName = uploadedFileName;
    const position = uploadedFileName.lastIndexOf("\\");
    if (position > -1) {
        fileName = fileName.substring(position + 1, fileName.length);
    }
    return fileName.replace(/\ /g, "_") === sourceFileName.replace(/\ /g, "_");
}
function getItemInfoByType(type) {
    if (_item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__.a[type]) {
        return _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__.a[type];
    }
    else {
        return _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__.a[Object.keys(_item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__.a).find((fileType) => _item_types_2029b06b_js__WEBPACK_IMPORTED_MODULE_0__.a[fileType].type === type)];
    }
}
function formatFileSize(size) {
    if (!size) {
        return "0 B";
    }
    const i = Math.floor(Math.log(size) / Math.log(1024));
    const adjustedSize = Math.round(size / Math.pow(1024, i));
    const unit = ["B", "KB", "MB", "GB", "TB"][i];
    return `${adjustedSize} ${unit}`;
}



//# sourceMappingURL=file-bf8ab90f.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-6a88e6c5.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-6a88e6c5.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ workflowState)
/* harmony export */ });
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const workflowStore = (0,_index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__.c)({
    portal: null,
    user: null,
    i18n: null,
    scale: "m",
    api: 4,
    nextText: null,
    uploadProgress: 0
});
const workflowState = workflowStore.state;



//# sourceMappingURL=store-6a88e6c5.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fZmVhdHVyLTIzZDZlNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDd0Q7QUFDNEM7QUFDUztBQUNwQztBQUNZO0FBQ1Q7QUFDUTtBQUMyTDtBQUMvRztBQUNuRztBQUNkO0FBQ3VGO0FBQzFFO0FBQ087QUFDcEI7QUFDVTtBQUNGOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQixFQUFFLG9EQUFZO0FBQ3pEO0FBQ0Esd0dBQXdHLGtCQUFrQixRQUFRLGdCQUFnQixFQUFFLDhCQUE4QixFQUFFLFlBQVk7QUFDaE07QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJLEVBQUUsVUFBVSxFQUFFLGlCQUFpQjtBQUNqRDtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQsd0JBQXdCLFVBQVUsR0FBRyxNQUFNO0FBQzNDLCtFQUErRSxTQUFTO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFFaXNCOztBQUVqc0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDajlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRTtBQUNwQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTSxHQUFHLFVBQVU7QUFDekM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLLEdBQUcsb0RBQUksR0FBRztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWtCO0FBQzFCLGVBQWUsc0RBQWtCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLHNEQUFrQixhQUFhLHNEQUFrQixxQkFBcUIsc0RBQWtCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYyxFQUFFLEtBQUs7QUFDbkM7O0FBRXNJOztBQUV0STs7Ozs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEOztBQUV2RCxzQkFBc0IscURBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRThCOztBQUU5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2ZlYXR1cmUtbGF5ZXItNTczYmI0NzMuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZmlsZS1iZjhhYjkwZi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9zdG9yZS02YTg4ZTZjNS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGMgYXMgY29uZmlnU3RhdGUgfSBmcm9tICcuL2NvbmZpZy03NWFkZjk2Mi5qcyc7XG5pbXBvcnQgeyB0IGFzIHRpbWVvdXQsIGkgYXMgaXNEZWZpbmVkLCBiIGFzIHVuaXF1ZSwgdSBhcyB1bmlxdWVCeSB9IGZyb20gJy4vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyc7XG5pbXBvcnQgeyBwIGFzIHBhcnNlQUdTU2VydmVySW5mbywgdiBhcyB2YWxpZEFyY2dpc1Jlc3RTZXJ2aWNlUGF0aCwgYyBhcyBhZ3NSZWdFeHAgfSBmcm9tICcuL3VybC00YzNhZTU0Yy5qcyc7XG5pbXBvcnQgeyBpIGFzIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUgfSBmcm9tICcuL2l0ZW0tcHJvcGVydGllcy0xMDQ5MWIyZS5qcyc7XG5pbXBvcnQgeyBhIGFzIGFkZEl0ZW1TdGF0ZSwgYyBhcyBhZGRJdGVtUmVxdWVzdFN0YXRlIH0gZnJvbSAnLi9hZGQtaXRlbS1kYmJlMmY1Ny5qcyc7XG5pbXBvcnQgeyBjIGFzIGNvbWJpbmVGZWF0dXJlTGF5ZXJJbmZvcyB9IGZyb20gJy4vZmVhdHVyZS1sYXllci03OWZiMzAyYy5qcyc7XG5pbXBvcnQgeyBzIGFzIHN0cmVhbVByb21pc2VzLCBhIGFzIGZvcm1hdEZpbGVOYW1lIH0gZnJvbSAnLi9mdW5jdGlvbmFsLTgxMzczZjZkLmpzJztcbmltcG9ydCB7IGIgYXMgc2VuZEFkZEl0ZW1SZXF1ZXN0LCBnIGFzIGdldEl0ZW1VcmwsIHUgYXMgdXBkYXRlSXRlbSwgZSBhcyBhZGRUaHVtYm5haWxUb0l0ZW0sIGggYXMgZ2V0QWRkSXRlbVBhcmFtZXRlcnMsIGkgYXMgY3JlYXRlRm9ybSwgaiBhcyBjb21taXRJdGVtLCBrIGFzIGdldEFkZEl0ZW1VcmwsIGwgYXMgY2FuY2VsSXRlbSwgYSBhcyBnZXRJdGVtLCBtIGFzIG1vdmVJdGVtLCBkIGFzIGRlbGV0ZUl0ZW0gfSBmcm9tICcuL3NlcnZlci1pdGVtLThkMzg0Nzk2LmpzJztcbmltcG9ydCB7IHIgYXMgcmVxdWVzdCwgZyBhcyBnZXRSZXN0QmFzZVVybCwgZCBhcyBmb3JtUmVxdWVzdCwgcCBhcyBwb2xsRm9yU3RhdHVzLCBlIGFzIGdldFRva2VuLCBmIGFzIGZyb21DYWNoZSwgcSBhcyBxdWVyeUdyb3VwcyB9IGZyb20gJy4vcG9ydGFsLWQ1MThiNTcxLmpzJztcbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCB7IGkgYXMgaXNBR1MgfSBmcm9tICcuL2Fncy1lYjQ1OGEwMy5qcyc7XG5pbXBvcnQgeyBhIGFzIGlzSG9zdGVkU2VydmljZSwgYiBhcyBzdXBwb3J0c0h0dHBzLCBjIGFzIHVybFRvT2JqZWN0LCBkIGFzIGZvcm1hdEdJU1VybCwgZSBhcyBjaGVja1Byb3RvY29sIH0gZnJvbSAnLi91cmwtMzU4NzVhMTAuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRJdGVtSW5mb0J5VHlwZSB9IGZyb20gJy4vZmlsZS1iZjhhYjkwZi5qcyc7XG5pbXBvcnQgeyBhIGFzIGFkZENyZWF0ZUl0ZW1UeXBlcyB9IGZyb20gJy4vaXRlbS10eXBlcy0yMDI5YjA2Yi5qcyc7XG5pbXBvcnQgeyBnIGFzIGd1aWQgfSBmcm9tICcuL2d1aWQtYWVhZWQ4NGQuanMnO1xuaW1wb3J0IHsgdyBhcyB3b3JrZmxvd1N0YXRlIH0gZnJvbSAnLi9zdG9yZS02YTg4ZTZjNS5qcyc7XG5pbXBvcnQgeyBjIGFzIGNyZWF0ZVN0b3JlIH0gZnJvbSAnLi9pbmRleC0wNTk1NmNhYi5qcyc7XG5cbmZ1bmN0aW9uIGlzRm9sZGVyUm9vdChmb2xkZXIpIHtcbiAgICByZXR1cm4gKGZvbGRlciA9PT0gbnVsbCB8fCBmb2xkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvbGRlci5pZCkgPT09IChmb2xkZXIgPT09IG51bGwgfHwgZm9sZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb2xkZXIudXNlcm5hbWUpO1xufVxuXG4vKipcbiAqIGZvciBBR1MgYW5kIE9HQyBGZWF0dXJlIFNlcnZpY2VzIHVybHMsIGZvcm1hdHRlZCBwYXJhbXMgd2lsbCBiZSB1c2VkIGZvciB0aGUgc2VydmljZSBJbmZvIHJlcXVlc3RzXG4gKi9cbmZ1bmN0aW9uIGFkZFBhcmFtZXRlcnModXJsKSB7XG4gICAgY29uc3QgeyBjdXN0b21QYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzIH0gPSBhZGRJdGVtU3RhdGU7XG4gICAgY29uc3QgZGVsaW1pdGVyID0gdXJsLmluY2x1ZGVzKFwiP1wiKSA/IFwiJlwiIDogXCI/XCI7XG4gICAgY29uc3QgY3VzdG9tUGFyYW1ldGVycyA9IChwYXJhbWV0ZXJzID09PSBudWxsIHx8IHBhcmFtZXRlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtZXRlcnMubWFwKCh7IHBhcmFtZXRlciwgdmFsdWUgfSkgPT4gYCR7cGFyYW1ldGVyIHx8IFwiXCJ9JHtwYXJhbWV0ZXIgfHwgdmFsdWUgPyBcIj1cIiA6IFwiXCJ9JHt2YWx1ZSB8fCBcIlwifWApLmpvaW4oXCImXCIpKSB8fCBcIlwiO1xuICAgIGlmICghY3VzdG9tUGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dXJsfSR7ZGVsaW1pdGVyfSR7Y3VzdG9tUGFyYW1ldGVyc31gO1xufVxuZnVuY3Rpb24gcmVtb3ZlUGFyYW1ldGVyKHVybCwgeyB2YWx1ZSwgcGFyYW1ldGVyIH0pIHtcbiAgICBjb25zdCBwYXJhbVN0ciA9IGAke3BhcmFtZXRlcn09JHt2YWx1ZX1gO1xuICAgIGNvbnN0IHJlc3VsdFVybCA9IHVybC5yZXBsYWNlKHVybFt1cmwuaW5kZXhPZihwYXJhbVN0cikgLSAxXSA9PT0gXCImXCIgPyBgJiR7cGFyYW1TdHJ9YCA6IHBhcmFtU3RyLCBcIlwiKTtcbiAgICByZXR1cm4gcmVzdWx0VXJsW3Jlc3VsdFVybC5sZW5ndGggLSAxXSA9PT0gXCI/XCIgPyByZXN1bHRVcmwucmVwbGFjZShcIj9cIiwgXCJcIikgOiByZXN1bHRVcmw7XG59XG5cbmNvbnN0IGVycm9yQ29kZUxpc3QgPSBbXG4gICAgXCJhcHBFeHRlbnNpb25FcnJvclwiLFxuICAgIFwiZm9yYmlkZGVuQ3JlZGVudGlhbFwiLFxuICAgIFwiZGlzYWJsZWRTdWJzY3JpcHRpb25cIixcbiAgICBcInVuYXV0aG9yaXplZFwiLFxuICAgIFwidGltZW91dFwiLFxuICAgIC8vIC0tLSBJdGVtIGVycm9yIGNvZGVcbiAgICBcIml0ZW1FeGlzdHNcIixcbiAgICBcImV4Y2VlZHNGaWxlU2l6ZVwiLFxuICAgIFwiZmlsZUV4aXN0c1wiLFxuICAgIFwiZW1wdHlGaWxlXCIsXG4gICAgXCJ1bmF2YWlsYWJsZUdlb2NvZGVyXCIsXG4gICAgXCJkYXRhTm90QXZhaWxhYmxlXCIsXG4gICAgXCJpbnZhbGlkU2hhcGVmaWxlXCIsXG4gICAgXCJpbnZhbGlkRmlsZUdlb2RhdGFiYXNlXCIsXG4gICAgXCJwcm92aWRlUGF0aFwiLFxuICAgIFwidXNlU2FtZUZpbGVOYW1lXCIsXG4gICAgXCJpbnZhbGlkRXh0ZW5zaW9uXCIsXG4gICAgXCJ0b2tlblJlcXVpcmVkXCIsXG4gICAgLy8gLS0tIEl0ZW0gcHJvcGVydGllcyBlcnJvciBjb2RlXG4gICAgXCJzZXJ2aWNlTmFtZUludmFsaWRcIixcbiAgICBcInRpdGxlSW52YWxpZFwiLFxuICAgIFwidGl0bGVSZXF1aXJlZFwiLFxuICAgIFwidGl0bGVJblVzZVNlcnZpY2VcIixcbiAgICBcInN1bW1hcnlJbnZhbGlkXCIsXG4gICAgXCJtaXNzaW5nVXNlck9yUG9ydGFsXCIsXG4gICAgXCJkYXRhU3RvcmVUaXRsZUludmFsaWRcIixcbiAgICAvLyAtLS0gU2VydmljZXNcbiAgICBcInNlcnZpY2VOYW1lRXhpc3RzXCIsXG4gICAgLy8gLS0tIEFHUywgV01GLCBXTVMsIFdGUywgZXRjXG4gICAgXCJzZXJ2aWNlTm90RXhpc3RcIixcbiAgICBcInVuc3VwcG9ydGVkV0ZTVmVyc2lvblwiLFxuICAgIFwiaW52YWxpZFdNVFNcIixcbiAgICBcImludmFsaWRTcGF0aWFsUmVmXCIsXG4gICAgXCJlbXB0eUZlYXR1cmVMYXllclwiLFxuICAgIC8vIC0tLSBGZWF0dXJlIGxheWVyLFxuICAgIFwiaW52YWxpZEZlYXR1cmVMYXllclVybFwiLFxuICAgIFwiaW52YWxpZFVybFwiLFxuICAgIFwiaHR0cFdhcm5pbmdcIixcbiAgICAvLyAtLS0gVXNlciBlcnJvclxuICAgIFwiZmxvd0Fib3J0ZWRcIixcbiAgICAvLyAtLS0gQ1NWIGVycm9yXG4gICAgXCJkdXBsaWNhdGVGaWVsZE5hbWVzXCIsXG4gICAgXCJmYWlsVG9GZXRjaFRleHRcIixcbiAgICAvLyAtLS0gVGlsZSBsYXllclxuICAgIFwibWFwU2VydmljZUVycm9yXCIsXG4gICAgXCJub1RpbGluZ1NjaGVtZUZvdW5kXCIsXG4gICAgXCJub01hdGNoU3BhdGlhbFJlZlwiLFxuICAgIC8vIC0tLSBEYXRhc3RvcmVcbiAgICBcImludmFsaWREYXRhU3RvcmVQdWJsaXNoVHlwZVwiLFxuICAgIFwibm9SZWdpc3RlcmVkU2VydmVyc0ZvckRhdGFTdG9yZVwiLFxuICAgIFwibm9Db250ZW50SW5EYXRhU3RvcmVcIixcbiAgICBcImZhaWxUb1B1Ymxpc2hGcm9tRGF0YVN0b3JlXCIsXG4gICAgXCJmYWlsVG9MaXN0RGF0YVN0b3JlQ29udGVudHNcIixcbiAgICBcImludmFsaWRVc2VybmFtZU9yUGFzc3dvcmRcIixcbiAgICBcImludmFsaWRKU09OXCIsXG4gICAgLy8gLS0tIEludGVybmFsIGVycm9yXG4gICAgXCJ1bmtub3duQUdTVHlwZVwiLFxuICAgIFwidW5oYW5kbGVkRXJyb3JcIixcbiAgICAvLyAtLSBBcHBlbmQgZXJyb3JzXG4gICAgXCJpbmNvbXBhdGlibGVHZW9tZXRyaWVzXCIsXG4gICAgXCJtdWx0aVBhdGNoUmVzdHJpY3Rpb25cIlxuXTtcbi8vICogVXRpbHNcbmNvbnN0IGlzQXBwQ29tcG9uZW50RXJyb3IgPSAoZXJyb3IpID0+IGVycm9yQ29kZUxpc3QuaW5jbHVkZXMoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmNvZGUpO1xuY29uc3QgaXNCYWNrZW5kRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yICYmXG4gICAgZXJyb3IuaGFzT3duUHJvcGVydHkoXCJjb2RlXCIpICYmXG4gICAgZXJyb3IuaGFzT3duUHJvcGVydHkoXCJtZXNzYWdlXCIpICYmXG4gICAgZXJyb3IuaGFzT3duUHJvcGVydHkoXCJkZXRhaWxzXCIpICYmXG4gICAgKCFlcnJvci5kZXRhaWxzIHx8IEFycmF5LmlzQXJyYXkoZXJyb3IuZGV0YWlscykpO1xuXG5jb25zdCB1bnN1YnNjcmliZSA9IGFzeW5jIChpZCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmliZXIgPSBzdWJzY3JpcHRpb25TdGF0ZS5zdWJzY3JpYmVyc1tpZF07XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgKHN1YnNjcmliZXIgPT09IG51bGwgfHwgc3Vic2NyaWJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Vic2NyaWJlci51bnN1YnNjcmliZSgpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWwgdG8gY2FsbCB1bnN1YnNjcmliZSBmb3IgJHtzdWJzY3JpYmVyLm5hbWV9OiAke2Vycm9yfWApO1xuICAgIH1cbn07XG5jb25zdCByZW1vdmVTdWJzY3JpYmVyID0gYXN5bmMgKGlkKSA9PiB7XG4gICAgZGVsZXRlIHN1YnNjcmlwdGlvblN0YXRlLnN1YnNjcmliZXJzW2lkXTtcbn07XG5jb25zdCB1bnN1YnNjcmliZUFsbCA9IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhzdWJzY3JpcHRpb25TdGF0ZS5zdWJzY3JpYmVycykubWFwKHVuc3Vic2NyaWJlKSk7XG4gICAgc3Vic2NyaXB0aW9uU3RvcmUucmVzZXQoKTtcbn07XG5jb25zdCBhZGRTdWJzY3JpYmVyID0gKG5hbWUsIHVuc3Vic2NyaWJlKSA9PiB7XG4gICAgY29uc3QgaWQgPSBgJHtuYW1lfS0tLSR7Z3VpZCgpfWA7XG4gICAgc3Vic2NyaXB0aW9uU3RhdGUuc3Vic2NyaWJlcnNbaWRdID0geyBuYW1lLCB1bnN1YnNjcmliZSB9O1xuICAgIHJldHVybiBpZDtcbn07XG5jb25zdCBpc1N1YnNjcmliZXJWYWxpZCA9IChzdWJzY3JpcHRpb25JZCkgPT4gISFzdWJzY3JpcHRpb25TdGF0ZS5zdWJzY3JpYmVyc1tzdWJzY3JpcHRpb25JZF07XG4vKiogVXNlZCB0byBrZWVwIHRyYWNrIGFuZCBoYW5kbGUgYWxsIHRoZSBsb25nIHJ1bm5pbmcgam9iIGxpa2UgcG9sbGluZyBhbmQgdXBsb2FkIG11bHRpLXBhcnQgZmlsZSAqL1xuY29uc3Qgc3Vic2NyaXB0aW9uU3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgc3Vic2NyaWJlcnM6IHt9LFxuICAgIHVuc3Vic2NyaWJlQWxsLFxuICAgIGFkZFN1YnNjcmliZXIsXG4gICAgdW5zdWJzY3JpYmUsXG4gICAgcmVtb3ZlU3Vic2NyaWJlcixcbiAgICBpc1N1YnNjcmliZXJWYWxpZFxufSk7XG5jb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHN1YnNjcmlwdGlvblN0b3JlLnN0YXRlO1xuXG4vLyBGaWxlIHNpemUgY29uc3RhbnRzXG5jb25zdCBNVUxUSV9QQVJUX1VQTE9BRF9CQVRDSF9TSVpFID0gMjYyMTQ0MDA7IC8vIDI1bWJcbmNvbnN0IE1VTFRJX1BBUlRfVVBMT0FEX01JTklNVU1fU0laRSA9IDc4NjQzMjAwOyAvLyA3NW1iXG5jb25zdCBNVUxUSV9QQVJUX1VQTE9BRF9SRVRSSUVTID0gNTtcbmNvbnN0IE1VTFRJX1BBUlRfVVBMT0FEX01BWF9QQVJUUyA9IDEwMDAwO1xuY29uc3QgTVVMVElfUEFSVF9VUExPQURfSU5JVElBTF9CQVRDSF9TSVpFID0gMztcbmNvbnN0IE1VTFRJX1BBUlRfVVBMT0FEX01BWF9CQVRDSF9TSVpFID0gMTA7XG5cbi8vIFRoZSBzaGFwZSBvZiBjdXN0b21QYXJhbXRlcnMgaW4gdGhlIGNvbXBvbmVudCBpcyBkaWZmZXJlbnQgdGhhbiBob3cgaXQgbmVlZHMgdG8gYmUgZm9ybWF0dGVkIGluIHRoZSBVUkxTLCBzbyB3ZSBkbyB0aGF0IGhlcmUuXG5mdW5jdGlvbiBmb3JtYXRDdXN0b21QYXJhbWV0ZXJzKGN1c3RvbVBhcmFtcykge1xuICAgIGlmICghY3VzdG9tUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgYXBwZW5kQWxsID0gdHJ1ZTtcbiAgICBsZXQgY3VzdG9tUGFyYW1ldGVycyA9IHt9O1xuICAgIGxldCBjdXN0b21MYXllclBhcmFtZXRlcnMgPSB7fTtcbiAgICAvLyBXTVMgYW5kIFdNVFMgY2FuIGhhdmUgY3VzdG9tIFBhcmFtdGVycyB0aGF0IG9ubHkgYXBwbHkgdG8gdGhlIHNwZWNpZmljIGxheWVyIG5vdCB0aGUgd2hvbGUgc2VydmljZUluZm8gcmVxdWVzdCAtIHRoYXRzIHdoYXQgd2VyZSBkb2luZyBoZXJlLlxuICAgIGN1c3RvbVBhcmFtcy5mb3JFYWNoKCh7IGFwcGVuZCwgcGFyYW1ldGVyLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGlmIChhcHBlbmQgPT09IFwibGF5ZXJcIikge1xuICAgICAgICAgICAgYXBwZW5kQWxsID0gZmFsc2U7XG4gICAgICAgICAgICBjdXN0b21MYXllclBhcmFtZXRlcnNbcGFyYW1ldGVyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VzdG9tUGFyYW1ldGVyc1twYXJhbWV0ZXJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXBwZW5kQWxsID8geyBjdXN0b21QYXJhbWV0ZXJzIH0gOiB7IGN1c3RvbVBhcmFtZXRlcnMsIGN1c3RvbUxheWVyUGFyYW1ldGVycyB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBhZGRBcHBsaWNhdGlvbihpdGVtLCByZXN0QmFzZVVybCwgYXBwSW5mbykge1xuICAgIGlmIChpdGVtLnR5cGUgPT09IFwiRGVza3RvcCBBcHBsaWNhdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhZGRGaWxlKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VuZEFkZEl0ZW1SZXF1ZXN0KGl0ZW0pO1xuICAgIGlmIChpdGVtLnR5cGUgPT09IFwiQXBwbGljYXRpb25cIiB8fCBpdGVtLnR5cGUgPT09IFwiQVBJIEtleVwiKSB7XG4gICAgICAgIGF3YWl0IHJlZ2lzdGVyQXBwbGljYXRpb24ocmVzcG9uc2UuaWQsIHJlc3RCYXNlVXJsLCBhcHBJbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJBcHBsaWNhdGlvbihpdGVtSWQsIHJlc3RCYXNlVXJsLCBhcHBJbmZvKSB7XG4gICAgY29uc3QgdXJsID0gYCR7cmVzdEJhc2VVcmx9b2F1dGgyL3JlZ2lzdGVyQXBwYDtcbiAgICBsZXQgcmVxdWVzdFBhcmFtID0ge1xuICAgICAgICBpdGVtSWQsXG4gICAgICAgIGFwcFR5cGU6IFwibXVsdGlwbGVcIixcbiAgICAgICAgcmVkaXJlY3RfdXJpczogSlNPTi5zdHJpbmdpZnkoW1widXJuOmlldGY6d2c6b2F1dGg6Mi4wOm9vYlwiXSlcbiAgICB9O1xuICAgIGNvbnN0IHJlZGlyZWN0VXJsU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoYXBwSW5mby5yZWRpcmVjdF91cmlzKTtcbiAgICBpZiAoYXBwSW5mbykge1xuICAgICAgICByZXF1ZXN0UGFyYW0gPVxuICAgICAgICAgICAgYXBwSW5mby5hcHBUeXBlID09PSBcImFwaWtleVwiXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1JZCxcbiAgICAgICAgICAgICAgICAgICAgYXBwVHlwZTogXCJhcGlrZXlcIixcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RfdXJpczogcmVkaXJlY3RVcmxTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIGh0dHBSZWZlcnJlcnM6IEpTT04uc3RyaW5naWZ5KGFwcEluZm8uaHR0cFJlZmVycmVycyksXG4gICAgICAgICAgICAgICAgICAgIHByaXZpbGVnZXM6IEpTT04uc3RyaW5naWZ5KGFwcEluZm8ucHJpdmlsZWdlcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7IGl0ZW1JZCwgYXBwVHlwZTogYXBwSW5mby5hcHBUeXBlLCByZWRpcmVjdF91cmlzOiByZWRpcmVjdFVybFN0cmluZywgdXJsOiBhcHBJbmZvLnVybCB9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IHJlcXVlc3QodXJsLCByZXF1ZXN0UGFyYW0sIHt9LCBcInBvc3RcIikgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQXBwbGljYXRpb25NYW5pZmVzdChtYW5pZmVzdFVybCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgcmVxdWVzdChtYW5pZmVzdFVybCwge30sIHsgYWRkVG9rZW5NYW51YWxseTogZmFsc2UgfSksIGVycm9yOiBudWxsIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBudWxsLCBlcnJvcjogeyBjb2RlOiBcImFwcEV4dGVuc2lvbkVycm9yXCIgfSB9O1xuICAgIH1cbn1cblxuY29uc3QgSElEREVOX01BUF9ESVZfSUQgPSBcImhpZGRlbk1hcERpdlwiO1xuY29uc3QgZGVzdHJveUhpZGRlbk1hcERpdiA9ICgpID0+IHtcbiAgICBjb25zdCBoaWRkZW5NYXBEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChISURERU5fTUFQX0RJVl9JRCk7XG4gICAgaWYgKGhpZGRlbk1hcERpdikge1xuICAgICAgICBoaWRkZW5NYXBEaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWRkZW5NYXBEaXYpO1xuICAgIH1cbn07XG4vKiogUmV0dXJuIHRoZSBpZCBvZiB0aGUgaGlkZGVuIG1hcCAqL1xuY29uc3QgY3JlYXRlSGlkZGVuTWFwRGl2ID0gKHdpZHRoID0gMjAwLCBoZWlnaHQgPSAxMzApID0+IHtcbiAgICBsZXQgaGlkZGVuTWFwRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoSElEREVOX01BUF9ESVZfSUQpO1xuICAgIGlmICghaGlkZGVuTWFwRGl2KSB7XG4gICAgICAgIGhpZGRlbk1hcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGhpZGRlbk1hcERpdi5pZCA9IEhJRERFTl9NQVBfRElWX0lEO1xuICAgICAgICBoaWRkZW5NYXBEaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGhpZGRlbk1hcERpdi5zdHlsZS5sZWZ0ID0gXCItMTAwMHB4XCI7XG4gICAgICAgIGhpZGRlbk1hcERpdi5zdHlsZS50b3AgPSBcIi0xMDAwcHhcIjtcbiAgICAgICAgaGlkZGVuTWFwRGl2LnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgICAgICBoaWRkZW5NYXBEaXYuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChoaWRkZW5NYXBEaXYpO1xuICAgIH1cbiAgICBjb25zdCBoaWRkZW5NYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnN0IGhpZGRlbk1hcElkID0gXCJoaWRkZW5NYXBcIjtcbiAgICBoaWRkZW5NYXAuaWQgPSBoaWRkZW5NYXBJZDtcbiAgICBoaWRkZW5NYXAuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgaGlkZGVuTWFwLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgaGlkZGVuTWFwRGl2LmFwcGVuZENoaWxkKGhpZGRlbk1hcCk7XG4gICAgcmV0dXJuIGhpZGRlbk1hcElkO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGh1bWJuYWlsSW1hZ2UobWFwLCBjb25maWcpIHtcbiAgICBjb25zdCBbUHJpbnRUZW1wbGF0ZSwgUHJpbnRQYXJhbWV0ZXJzLCBQcmludFRhc2ssIGVzcmlDb25maWddID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgICAgICBcImVzcmkvdGFza3MvUHJpbnRUZW1wbGF0ZVwiLFxuICAgICAgICBcImVzcmkvdGFza3MvUHJpbnRQYXJhbWV0ZXJzXCIsXG4gICAgICAgIFwiZXNyaS90YXNrcy9QcmludFRhc2tcIixcbiAgICAgICAgXCJlc3JpL2NvbmZpZ1wiXG4gICAgXSk7XG4gICAgY29uc3QgdGh1bWJuYWlsV2lkdGggPSA2MDA7XG4gICAgY29uc3QgdGh1bWJuYWlsSGVpZ2h0ID0gNDAwO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gbmV3IFByaW50VGVtcGxhdGUoKTtcbiAgICB0ZW1wbGF0ZS5sYXlvdXQgPSBcIk1BUF9PTkxZXCI7XG4gICAgdGVtcGxhdGUuZm9ybWF0ID0gXCJwbmczMlwiO1xuICAgIHRlbXBsYXRlLnByZXNlcnZlU2NhbGUgPSBmYWxzZTtcbiAgICB0ZW1wbGF0ZS5zaG93QXR0cmlidXRpb24gPSBmYWxzZTtcbiAgICB0ZW1wbGF0ZS5zaG93TGFiZWxzID0gZmFsc2U7XG4gICAgdGVtcGxhdGUuZXhwb3J0T3B0aW9ucyA9IHtcbiAgICAgICAgd2lkdGg6IHRodW1ibmFpbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRodW1ibmFpbEhlaWdodCxcbiAgICAgICAgZHBpOiA5NlxuICAgIH07XG4gICAgY29uc3QgcHJpbnRUYXNrID0gbmV3IFByaW50VGFzayhjb25maWcuc2VsZi5oZWxwZXJTZXJ2aWNlcy5wcmludFRhc2sudXJsLCB7fSk7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFByaW50UGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5tYXAgPSBtYXA7XG4gICAgcGFyYW1zLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgZXNyaUNvbmZpZy5kZWZhdWx0cy5pby50aW1lb3V0ID0gMTIwMDAwO1xuICAgIC8vIFRPRE86IFNvbWUgZmVhdHVyZSBzZXJ2aWNlcyBuZWVkIHRvIGJlIHByb2plY3RlZCB0byBXR1M4NCB0byBnZW5lcmF0ZSBjb3JyZWN0bHlcbiAgICAvLyBDYW4gc2V0IGV4dGVudCB0byBnZW9ncmFwaGljRXh0ZW50IGhlcmUgYnV0IHNob3VsZCBmaXggd2l0aGluIFByaW50UGFyYW1ldGVyc1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHByaW50VGFzay5leGVjdXRlKHBhcmFtcywgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgZXNyaUNvbmZpZy5kZWZhdWx0cy5pby50aW1lb3V0ID0gNjAwMDA7XG4gICAgICAgICAgICBkZXN0cm95SGlkZGVuTWFwKG1hcCk7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdC51cmwpO1xuICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBlc3JpQ29uZmlnLmRlZmF1bHRzLmlvLnRpbWVvdXQgPSA2MDAwMDtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUhpZGRlbk1hcCh3ZWJNYXBEYXRhLCBnY3NFeHRlbnRBc0xpc3QpIHtcbiAgICBjb25zdCB7IGNvbmZpZyB9ID0gY29uZmlnU3RhdGU7XG4gICAgY29uc3QgaXRlbUluZm8gPSB7IGl0ZW06IHsgZXh0ZW50OiBnY3NFeHRlbnRBc0xpc3QgfSwgaXRlbURhdGE6IHdlYk1hcERhdGEgfTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBbYXJjZ2lzVXRpbHNdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9hcmNnaXMvdXRpbHNcIl0pO1xuICAgICAgICAvLyBOZWVkIHRvIHNldCB0aGlzIHNvIFwiY3JlYXRlTWFwXCIgdXNlcyB0aGUgY29ycmVjdCBwb3J0YWxVcmwsIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy8gXCJjcmVhdGVNYXBcIiBzaG91bGQgcmVhbGx5IGJlIGltcHJvdmVkIHRvIHVzZSB0aGUgcG9ydGFsIEFQSSwgb3IgYSBwb3J0YWxVcmwgcGFyYW1ldGVyXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8xNDgxOVxuICAgICAgICBhcmNnaXNVdGlscy5hcmNnaXNVcmwgPSBgJHtnZXRSZXN0QmFzZVVybCgpfWNvbnRlbnQvaXRlbXNgO1xuICAgICAgICBjb25zdCBoaWRkZW5NYXBJZCA9IGNyZWF0ZUhpZGRlbk1hcERpdigpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFyY2dpc1V0aWxzLmNyZWF0ZU1hcChpdGVtSW5mbywgaGlkZGVuTWFwSWQsIHtcbiAgICAgICAgICAgIG1hcE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBuYXY6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmluZ01hcHNLZXk6IGNvbmZpZy5zZWxmLmJpbmdLZXksXG4gICAgICAgICAgICBnZW9tZXRyeVNlcnZpY2VVUkw6IGNvbmZpZ1N0YXRlLnBvcnRhbC5oZWxwZXJTZXJ2aWNlcy5nZW9tZXRyeS51cmxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdhaXRGb3JIZWF0bWFwSW1hZ2VMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLl9oZWF0bWFwTWFuYWdlcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5faGVhdG1hcE1hbmFnZXIub24oXCJyZWNhbGN1bGF0ZUhlYXRtYXBcIiwgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYXllciBtaWdodCBiZSBvdXQgb2Ygc2NhbGVcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB3YWl0Rm9yV0ZTRmVhdHVyZXMgPSAobGF5ZXIpID0+IHtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIGV2ZW50Li4uXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IFswXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludEhuZGwgPSBzZXRJbnRlcnZhbCgobGF5ZXIsIGNvdW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IGxheWVyLmdyYXBoaWNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludEhuZGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50WzBdID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50SG5kbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudFswXSA9IGNvdW50WzBdICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDUwMCwgbGF5ZXIsIGNvdW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB3YWl0Rm9yVXBkYXRlU3RhcnQgPSAobGF5ZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5kZWNsYXJlZENsYXNzID09PSBcImVzcmkubGF5ZXJzLlZlY3RvclRpbGVMYXllclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZywgZG9lc24ndCBjYWxsIG9uVXBkYXRlU3RhcnQgc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxheWVyLm9uKFwidXBkYXRlLXN0YXJ0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvclVwZGF0ZUVuZChsYXllcikudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB3YWl0Rm9yVXBkYXRlRW5kID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXllci5kZWNsYXJlZENsYXNzID09PSBcImVzcmkubGF5ZXJzLlZlY3RvclRpbGVMYXllclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZywgZG9lc24ndCBjYWxsIG9uVXBkYXRlRW5kIGlmIHRoZXJlIGFyZSBubyB0aWxlcyBpbiB0aGUgdmlld1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGF5ZXIub24oXCJ1cGRhdGUtZW5kXCIsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgbWFwIH0gPSByZXNwb25zZTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgbWFwLmdyYXBoaWNzTGF5ZXJJZHMuZm9yRWFjaCgobGF5ZXJJZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBtYXAuZ2V0TGF5ZXIobGF5ZXJJZCk7XG4gICAgICAgICAgICBpZiAoKChfYSA9IGxheWVyLnJlbmRlcmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiaGVhdG1hcFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh3YWl0Rm9ySGVhdG1hcEltYWdlTGF5ZXIobGF5ZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxheWVyLmRlY2xhcmVkQ2xhc3MgPT09IFwiZXNyaS5sYXllcnMuV0ZTTGF5ZXJcIikge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2god2FpdEZvcldGU0ZlYXR1cmVzKGxheWVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYXllci51cGRhdGluZykge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2god2FpdEZvclVwZGF0ZUVuZChsYXllcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWFwLmxheWVySWRzLmZvckVhY2goKGxheWVySWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGx5ciA9IHJlc3BvbnNlLm1hcC5nZXRMYXllcihsYXllcklkKTtcbiAgICAgICAgICAgIGlmIChseXIudXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHdhaXRGb3JVcGRhdGVFbmQobHlyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChseXIuZGVjbGFyZWRDbGFzcyA9PT0gXCJlc3JpLmxheWVycy5WZWN0b3JUaWxlTGF5ZXJcIikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHdvcmtpbmcgY29ycmVjdGx5IGluIFZUTDsgdmlld2VyIHNob3VsZCBub3QgaGF2ZSB0byB3YWl0IGZvciB1cGRhdGUgc3RhcnRcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHdhaXRGb3JVcGRhdGVTdGFydChseXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd2FpdCBhIGxpdHRsZSBsb25nZXJcbiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgY3JlYXRlVGh1bWJuYWlsSW1hZ2UocmVzcG9uc2UubWFwLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNyZWF0ZVRodW1ibmFpbEltYWdlKHJlc3BvbnNlLm1hcCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXAgY3JlYXRpb24gZmFpbGVkOiAke0pTT04uc3RyaW5naWZ5KGVycm9yKX1gKTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkVGh1bWJuYWlsVVJMRnJvbUl0ZW1XZWJNYXAod2ViTWFwLCBnY3NFeHRlbnRBc0xpc3QsIHNwYXRpYWxSZWZlcmVuY2UpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZGVwZW5kZW5jeVxuICAgIGNvbnN0IGFwaSA9IGNvbmZpZ1N0YXRlLmFwaTtcbiAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IGhlYXRtYXAgcmVuZGVyZXJcbiAgICBjb25zdCBbR2VvcHJvY2Vzc29yXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFthcGkgPT09IDMgPyBcImVzcmkvdGFza3MvR2VvcHJvY2Vzc29yXCIgOiBcImVzcmkvcmVzdC9nZW9wcm9jZXNzb3JcIl0pO1xuICAgIGNvbnN0IHsgcG9ydGFsIH0gPSBjb25maWdTdGF0ZTtcbiAgICAoKF9hID0gd2ViTWFwLmJhc2VNYXAuYmFzZU1hcExheWVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLmZvckVhY2goKGJhc2VNYXBMYXllcikgPT4ge1xuICAgICAgICBkZWxldGUgYmFzZU1hcExheWVyLnJlc291cmNlSW5mbztcbiAgICB9KTtcbiAgICB3ZWJNYXAubWFwT3B0aW9ucyA9IHtcbiAgICAgICAgc2hvd0F0dHJpYnV0aW9uOiBmYWxzZSxcbiAgICAgICAgZXh0ZW50OiB7XG4gICAgICAgICAgICB4bWluOiBnY3NFeHRlbnRBc0xpc3RbMF1bMF0sXG4gICAgICAgICAgICB5bWluOiBnY3NFeHRlbnRBc0xpc3RbMF1bMV0sXG4gICAgICAgICAgICB4bWF4OiBnY3NFeHRlbnRBc0xpc3RbMV1bMF0sXG4gICAgICAgICAgICB5bWF4OiBnY3NFeHRlbnRBc0xpc3RbMV1bMV0sXG4gICAgICAgICAgICBzcGF0aWFsUmVmZXJlbmNlOiB7XG4gICAgICAgICAgICAgICAgd2tpZDogNDMyNlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzcGF0aWFsUmVmZXJlbmNlOiBzcGF0aWFsUmVmZXJlbmNlXG4gICAgfTtcbiAgICB3ZWJNYXAuZXhwb3J0T3B0aW9ucyA9IHtcbiAgICAgICAgZHBpOiA5NixcbiAgICAgICAgb3V0cHV0U2l6ZTogWzYwMCwgNDAwXVxuICAgIH07XG4gICAgd2ViTWFwLmxheW91dE9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIFdlYl9NYXBfYXNfSlNPTjogSlNPTi5zdHJpbmdpZnkod2ViTWFwKSxcbiAgICAgICAgRm9ybWF0OiBcIlBORzMyXCIsXG4gICAgICAgIExheW91dF9UZW1wbGF0ZTogXCJNQVBfT05MWVwiXG4gICAgfTtcbiAgICBpZiAoYXBpID09PSAzKSB7XG4gICAgICAgIGNvbnN0IGdwID0gbmV3IEdlb3Byb2Nlc3Nvcihwb3J0YWwuaGVscGVyU2VydmljZXMucHJpbnRUYXNrLnVybCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBncC5leGVjdXRlKHBhcmFtcykudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzcG9uc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVtpXS5wYXJhbU5hbWUgPT09IFwiT3V0cHV0X0ZpbGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2VbaV0udmFsdWUudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVzdWx0cyB9ID0gYXdhaXQgR2VvcHJvY2Vzc29yLmV4ZWN1dGUocG9ydGFsLmhlbHBlclNlcnZpY2VzLnByaW50VGFzay51cmwsIHBhcmFtcyk7XG4gICAgY29uc3QgdXJsID0gcmVzdWx0cy5maW5kKChyZXN1bHQpID0+IHJlc3VsdC5kYXRhVHlwZSA9PT0gXCJkYXRhLWZpbGVcIiAmJiByZXN1bHQpLnZhbHVlLnVybDtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICAvLyBUT0RPOiByZWZhY3RvciB0aGlzIGVycm9yIHRvIHRoZSBuZXcgc3lzdGVtXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgdGh1bWJuYWlsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gZGVzdHJveUhpZGRlbk1hcChtYXApIHtcbiAgICB2YXIgX2E7XG4gICAgbWFwLmRlc3Ryb3koKTtcbiAgICAoX2EgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImhpZGRlbk1hcERpdlwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaGlkZGVuTWFwXCIpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkVGh1bWJuYWlsVVJMRnJvbVdlYk1hcCh3ZWJNYXAsIGdjc0V4dGVudEFzTGlzdCkge1xuICAgIHJldHVybiBhd2FpdCBjcmVhdGVIaWRkZW5NYXAod2ViTWFwLCBnY3NFeHRlbnRBc0xpc3QpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBidWlsZFRodW1ibmFpbFVSTEZyb21LTUxJdGVtKGl0ZW0pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgW1NwYXRpYWxSZWZlcmVuY2VdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgICAgICBjb25maWdTdGF0ZS5hcGkgPT09IDQgPyBcImVzcmkvZ2VvbWV0cnkvU3BhdGlhbFJlZmVyZW5jZVwiIDogXCJlc3JpL1NwYXRpYWxSZWZlcmVuY2VcIlxuICAgIF0pO1xuICAgIGNvbnN0IHsgY29uZmlnLCBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICAgIGNvbnN0IHdlYk1hcCA9IHt9O1xuICAgIHdlYk1hcC5iYXNlTWFwID0gY29uZmlnLmRlZmF1bHRCYXNlbWFwIHx8IHBvcnRhbC5kZWZhdWx0QmFzZW1hcDtcbiAgICB3ZWJNYXAuYmFzZU1hcC50aXRsZSA9IFwiYmFzZW1hcFwiO1xuICAgIHdlYk1hcC5vcGVyYXRpb25hbExheWVycyA9IFtdO1xuICAgIGxldCB1cmwgPSBpdGVtLnVybDtcbiAgICBpZiAoIXVybCAmJiBpdGVtLnR5cGUgPT09IFwiS01MXCIpIHtcbiAgICAgICAgLy8gbG9hZGVkIGZyb20gYSBmaWxlIEtNTFxuICAgICAgICB1cmwgPSBjb25maWcucmVzdEJhc2VVcmwgKyBcImNvbnRlbnQvaXRlbXMvXCIgKyBpdGVtLmlkICsgXCIvZGF0YVwiO1xuICAgIH1cbiAgICAvLyB3ZSBkb24ndCBoYXZlIElEIG1hbmFnZXJcbiAgICBjb25zdCByZXN0RG9tYWluID0gbmV3IFVSTChjb25maWcucmVzdEJhc2VVcmwpLmhvc3RuYW1lO1xuICAgIGlmICh1cmwuaW5kZXhPZihyZXN0RG9tYWluKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnVzZXJJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9rZW47XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgdXJsICs9IFwiP3Rva2VuPVwiICsgdG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2ViTWFwLm9wZXJhdGlvbmFsTGF5ZXJzLnB1c2goe1xuICAgICAgICB1cmwsXG4gICAgICAgIGlkOiBcIktNTF9cIiArIE1hdGgucmFuZG9tKCksXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxuICAgICAgICB2aXNpYmlsaXR5OiB0cnVlLFxuICAgICAgICB0eXBlOiBcIktNTFwiXG4gICAgfSk7XG4gICAgbGV0IGV4dCA9IFtdO1xuICAgIGlmICh0eXBlb2YgaXRlbS5leHRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgZSA9IGl0ZW0uZXh0ZW50LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgZXh0ID0gW1xuICAgICAgICAgICAgW3BhcnNlRmxvYXQoZVswXSksIHBhcnNlRmxvYXQoZVsxXSldLFxuICAgICAgICAgICAgW3BhcnNlRmxvYXQoZVsyXSksIHBhcnNlRmxvYXQoZVszXSldXG4gICAgICAgIF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaXRlbS5leHRlbnQgJiYgaXRlbS5leHRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXh0ID0gaXRlbS5leHRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHQgPSBbXG4gICAgICAgICAgICAgICAgWy0xODAsIC05MF0sXG4gICAgICAgICAgICAgICAgWzE4MCwgOTBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWlsZFRodW1ibmFpbFVSTEZyb21JdGVtV2ViTWFwKHdlYk1hcCwgZXh0LCBuZXcgU3BhdGlhbFJlZmVyZW5jZSh7IHdraWQ6IDQzMjYgfSkpO1xufVxuXG5jb25zdCB3b3JsZEV4dGVudEluZm8gPSB7XG4gICAgeG1heDogMjAwMDAwMDAsXG4gICAgeG1pbjogLTIwMDAwMDAwLFxuICAgIHltYXg6IDIwMDAwMDAwLFxuICAgIHltaW46IC0yMDAwMDAwMCxcbiAgICBzcGF0aWFsUmVmZXJlbmNlOiB7XG4gICAgICAgIHdraWQ6IDEwMjEwMFxuICAgIH1cbn07XG5mdW5jdGlvbiB3cmFwQXJvdW5kKHdraWQsIGdlb20pIHtcbiAgICBjb25zdCBWQUxJRF9FWFRFTlRTID0ge1xuICAgICAgICBcIjEwMjExM1wiOiBbLTIwMDM3NTA4LjM0Mjc4ODkwNSwgMjAwMzc1MDguMzQyNzg4OTA1XSxcbiAgICAgICAgXCIxMDIxMDBcIjogWy0yMDAzNzUwOC4zNDI3ODg5MDUsIDIwMDM3NTA4LjM0Mjc4ODkwNV0sXG4gICAgICAgIFwiMzc4NVwiOiBbLTIwMDM3NTA4LjM0Mjc4ODkwNSwgMjAwMzc1MDguMzQyNzg4OTA1XSxcbiAgICAgICAgXCIzODU3XCI6IFstMjAwMzc1MDguMzQyNzg4OTA1LCAyMDAzNzUwOC4zNDI3ODg5MDVdLFxuICAgICAgICBcIjQzMjZcIjogWy0xODAsIDE4MF1cbiAgICB9O1xuICAgIGNvbnN0IHZhbGlkID0gVkFMSURfRVhURU5UU1t3a2lkXTtcbiAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgaWYgKGdlb20ueG1pbiA+IGdlb20ueG1heCkge1xuICAgICAgICAgICAgLy8gd3JhcCBhcm91bmRcbiAgICAgICAgICAgIGNvbnN0IGRpZjEgPSB2YWxpZFsxXSAtIGdlb20ueG1pbjtcbiAgICAgICAgICAgIGNvbnN0IGRpZjIgPSBnZW9tLnhtYXggLSB2YWxpZFswXTtcbiAgICAgICAgICAgIGlmIChkaWYxID4gZGlmMikge1xuICAgICAgICAgICAgICAgIGdlb20ueG1heCA9IHZhbGlkWzFdICsgZGlmMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlb20ueG1pbiA9IHZhbGlkWzBdIC0gZGlmMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNwYXRpYWxSZWZlcmVuY2Uoc2VydmljZUluZm8sIGFnc1R5cGUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHNwYXRpYWxSZWZlcmVuY2UgPSBhZ3NUeXBlICE9PSBcIkltYWdlU2VydmVyXCIgPyBzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8uc3BhdGlhbFJlZmVyZW5jZSA6IChfYSA9IHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5leHRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGF0aWFsUmVmZXJlbmNlO1xuICAgIGlmICghc3BhdGlhbFJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3BhdGlhbFJlZmVyZW5jZS53a2lkKSB7XG4gICAgICAgIHJldHVybiBzcGF0aWFsUmVmZXJlbmNlLndraWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgoX2IgPSBzcGF0aWFsUmVmZXJlbmNlLndrdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlYXJjaCgvXlBST0pDUy9pKSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiAvXlBST0pDU1xcW1wiW0EtWmEtejAtOV9dKi9pLmV4ZWMoc3BhdGlhbFJlZmVyZW5jZS53a3QpWzBdLnNwbGl0KFwiW1wiKVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9qZWN0RXh0ZW50VG9XR1M4NChleHRlbnQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IFtTcGF0aWFsUmVmZXJlbmNlXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgY29uZmlnU3RhdGUuYXBpID09PSA0ID8gXCJlc3JpL2dlb21ldHJ5L1NwYXRpYWxSZWZlcmVuY2VcIiA6IFwiZXNyaS9TcGF0aWFsUmVmZXJlbmNlXCJcbiAgICBdKTtcbiAgICBjb25zdCBoYXNTUiA9ICgoX2EgPSBleHRlbnQgPT09IG51bGwgfHwgZXh0ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnQuc3BhdGlhbFJlZmVyZW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndraWQpIHx8ICgoX2IgPSBleHRlbnQgPT09IG51bGwgfHwgZXh0ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnQuc3BhdGlhbFJlZmVyZW5jZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndrdCk7XG4gICAgY29uc3QgR0NTX1dHU18xOTg0ID0gbmV3IFNwYXRpYWxSZWZlcmVuY2UoeyB3a2lkOiA0MzI2IH0pO1xuICAgIGNvbnN0IHNhbWVTcGF0aWFsUmVmID0gYXdhaXQgc2FtZVNwYXRpYWxSZWZlcmVuY2UoR0NTX1dHU18xOTg0LCBleHRlbnQgPT09IG51bGwgfHwgZXh0ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnQuc3BhdGlhbFJlZmVyZW5jZSk7XG4gICAgcmV0dXJuIGhhc1NSICYmICFzYW1lU3BhdGlhbFJlZiA/IGF3YWl0IHByb2plY3QoZXh0ZW50LCBHQ1NfV0dTXzE5ODQpIDogZXh0ZW50O1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvamVjdEV4dGVudFRvV0dTODRGcm9tSXRlbShpdGVtKSB7XG4gICAgY29uc3QgeyBleHRlbnQgfSA9IGl0ZW07XG4gICAgaXRlbS5leHRlbnQgPSBleHRlbnRUb1N0cmluZyhhd2FpdCBwcm9qZWN0RXh0ZW50VG9XR1M4NChleHRlbnQpKTtcbiAgICByZXR1cm4gaXRlbTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2plY3RFeHRlbnQoZ2VvbWV0cnksIG91dFNSKSB7XG4gICAgY29uc3QgeyBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICAgIGNvbnN0IFttZXJjYXRvclV0aWxzLCBHZW9tZXRyeVNlcnZpY2VdID0gYXdhaXQgbG9hZE1vZHVsZXMoY29uZmlnU3RhdGUuYXBpID09PSA0XG4gICAgICAgID8gW1wiZXNyaS9nZW9tZXRyeS9zdXBwb3J0L3dlYk1lcmNhdG9yVXRpbHNcIiwgXCJlc3JpL3Jlc3QvZ2VvbWV0cnlTZXJ2aWNlXCJdXG4gICAgICAgIDogW1wiZXNyaS9nZW9tZXRyeS93ZWJNZXJjYXRvclV0aWxzXCIsIFwiZXNyaS90YXNrcy9HZW9tZXRyeVNlcnZpY2VcIl0pO1xuICAgIGNvbnN0IG1lcmNhdG9yID0gWzEwMjExMywgMTAyMTAwLCAzODU3XTtcbiAgICBjb25zdCB3a2lkID0gZ2VvbWV0cnkuc3BhdGlhbFJlZmVyZW5jZS53a2lkO1xuICAgIC8vIHdlIG9ubHkgaGF2ZSAxIGdlb21ldHJ5IGFueXdheVxuICAgIGlmICh3a2lkID09PSBvdXRTUi53a2lkKSB7XG4gICAgICAgIHJldHVybiBbZ2VvbWV0cnldO1xuICAgIH1cbiAgICBsZXQgZ2VvbTtcbiAgICAvLyBnb2luZyBmcm9tIEdDU19XR1NfMTk4NCB0byBtZXJjYXRvclxuICAgIGlmICh3a2lkID09PSA0MzI2ICYmIG1lcmNhdG9yLmluZGV4T2Yob3V0U1Iud2tpZCkgPiAtMSkge1xuICAgICAgICAvLyBjbGlwIGl0LCBzbyBpdCdzIG5vdCBnb2luZyB0byBJbmZpbml0eVxuICAgICAgICBnZW9tZXRyeS55bWluID0gTWF0aC5tYXgoZ2VvbWV0cnkueW1pbiwgLTg5Ljk5KTtcbiAgICAgICAgZ2VvbWV0cnkueW1heCA9IE1hdGgubWluKGdlb21ldHJ5LnltYXgsIDg5Ljk5KTtcbiAgICAgICAgZ2VvbSA9IG1lcmNhdG9yVXRpbHMuZ2VvZ3JhcGhpY1RvV2ViTWVyY2F0b3IoZ2VvbWV0cnkpO1xuICAgICAgICB3cmFwQXJvdW5kKG91dFNSLndraWQsIGdlb20pO1xuICAgICAgICAvLyBnZW9ncmFwaGljVG9XZWJNZXJjYXRvciByZXR1cm5zIDEwMjEwMDsgbWFrZSBzdXJlIGl0J3Mgd2hhdCB3ZSB3YW50XG4gICAgICAgIGdlb20uc3BhdGlhbFJlZmVyZW5jZS53a2lkID0gb3V0U1Iud2tpZDtcbiAgICAgICAgcmV0dXJuIFtnZW9tXTtcbiAgICB9XG4gICAgaWYgKG1lcmNhdG9yLmluZGV4T2Yod2tpZCkgPiAtMSAmJiBvdXRTUi53a2lkID09PSA0MzI2KSB7XG4gICAgICAgIGdlb20gPSBtZXJjYXRvclV0aWxzLndlYk1lcmNhdG9yVG9HZW9ncmFwaGljKGdlb21ldHJ5KTtcbiAgICAgICAgd3JhcEFyb3VuZChvdXRTUi53a2lkLCBnZW9tKTtcbiAgICAgICAgcmV0dXJuIFtnZW9tXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeVNlcnZpY2UgPSBjb25maWdTdGF0ZS5hcGkgPT09IDQgPyBHZW9tZXRyeVNlcnZpY2UgOiBuZXcgR2VvbWV0cnlTZXJ2aWNlKHBvcnRhbC5oZWxwZXJTZXJ2aWNlcy5nZW9tZXRyeS51cmwpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RIYW5kbGVyID0gKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHJlc3BvbnNlIGlzIHZhbGlkXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgaWYgKChmaXJzdCA9PT0gbnVsbCB8fCBmaXJzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3QudHlwZSkgPT09IFwiZXh0ZW50XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzTmFOKHJlc3VsdFswXS54bWluKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNOYU4ocmVzdWx0WzBdLnltaW4pICYmXG4gICAgICAgICAgICAgICAgICAgICFpc05hTihyZXN1bHRbMF0ueG1heCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzTmFOKHJlc3VsdFswXS55bWF4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChmaXJzdCA9PT0gbnVsbCB8fCBmaXJzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3QudHlwZSkgPT09IFwicG9pbnRcIiAmJiAhaXNOYU4ocmVzdWx0WzBdLngpICYmICFpc05hTihyZXN1bHRbMF0ueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjb25maWdTdGF0ZS5hcGkgPT09IDQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbX1Byb2plY3RQYXJhbWV0ZXJzXSA9IChhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL3Jlc3Qvc3VwcG9ydC9Qcm9qZWN0UGFyYW1ldGVyc1wiXSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9qZWN0UGFyYW1ldGVycyA9IG5ldyBfUHJvamVjdFBhcmFtZXRlcnMoeyBnZW9tZXRyaWVzOiBbZ2VvbWV0cnldLCBvdXRTcGF0aWFsUmVmZXJlbmNlOiBvdXRTUiB9KTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RIYW5kbGVyKGF3YWl0IGdlb21ldHJ5U2VydmljZS5wcm9qZWN0KHBvcnRhbC5oZWxwZXJTZXJ2aWNlcy5nZW9tZXRyeS51cmwsIHByb2plY3RQYXJhbWV0ZXJzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5U2VydmljZS5wcm9qZWN0KFtnZW9tZXRyeV0sIG91dFNSLCBmaXJzdEhhbmRsZXIsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2plY3QoZXh0ZW50LCB0b0V4dGVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBbRXh0ZW50XSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvZ2VvbWV0cnkvRXh0ZW50XCJdKTtcbiAgICBjb25zdCB3b3JsZEV4dGVudCA9IG5ldyBFeHRlbnQod29ybGRFeHRlbnRJbmZvKTtcbiAgICBjb25zdCBmdWxsRXh0ZW50ID0gbmV3IEV4dGVudChleHRlbnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2plY3RFeHRlbnQoZnVsbEV4dGVudCwgdG9FeHRlbnQpO1xuICAgIHJldHVybiAoKF9hID0gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0WzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiZXh0ZW50XCIgPyByZXN1bHRbMF0gOiB3b3JsZEV4dGVudDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNhbWVTcGF0aWFsUmVmZXJlbmNlKHNwMSwgc3AyKSB7XG4gICAgY29uc3QgbWVyY2F0b3IgPSBbMTAyMTEzLCAxMDIxMDAsIDM4NTddO1xuICAgIGlmICgoKHNwMSA9PT0gbnVsbCB8fCBzcDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMS53a3QpID09IChzcDIgPT09IG51bGwgfHwgc3AyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcDIud2t0KSAmJiAoKHNwMSA9PT0gbnVsbCB8fCBzcDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMS53a2lkKSA9PSAoc3AyID09PSBudWxsIHx8IHNwMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AyLndraWQpIHx8IChpc0RlZmluZWQoc3AxLmxhdGVzdFdraWQpICYmIChzcDEgPT09IG51bGwgfHwgc3AxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcDEubGF0ZXN0V2tpZCkgPT0gKHNwMiA9PT0gbnVsbCB8fCBzcDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMi53a2lkKSkpKSB8fFxuICAgICAgICAoaXNEZWZpbmVkKHNwMiA9PT0gbnVsbCB8fCBzcDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMi5sYXRlc3RXa2lkKSAmJiAoc3AxID09PSBudWxsIHx8IHNwMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AxLndraWQpID09IChzcDIgPT09IG51bGwgfHwgc3AyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcDIubGF0ZXN0V2tpZCkpIHx8XG4gICAgICAgIChpc0RlZmluZWQoc3AxID09PSBudWxsIHx8IHNwMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AxLmxhdGVzdFdraWQpICYmIChzcDEgPT09IG51bGwgfHwgc3AxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcDEubGF0ZXN0V2tpZCkgPT0gKHNwMiA9PT0gbnVsbCB8fCBzcDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMi5sYXRlc3RXa2lkKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKChzcDEgPT09IG51bGwgfHwgc3AxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcDEud2tpZCkgJiYgKHNwMiA9PT0gbnVsbCB8fCBzcDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMi53a2lkKSAmJiBtZXJjYXRvci5pbmNsdWRlcyhzcDEgPT09IG51bGwgfHwgc3AxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcDEud2tpZCkgJiYgbWVyY2F0b3IuaW5jbHVkZXMoc3AyID09PSBudWxsIHx8IHNwMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AyLndraWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRFeHRlbnRXaXRoRmVhdHVyZXMobGF5ZXIsIGV4dGVudEFzTGlzdCkge1xuICAgIGNvbnN0IHsgYXBpIH0gPSBjb25maWdTdGF0ZTtcbiAgICBjb25zdCBbU3BhdGlhbFJlZmVyZW5jZV0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICAgIGFwaSA9PT0gNCA/IFwiZXNyaS9nZW9tZXRyeS9TcGF0aWFsUmVmZXJlbmNlXCIgOiBcImVzcmkvU3BhdGlhbFJlZmVyZW5jZVwiXG4gICAgXSk7XG4gICAgY29uc3QgW0ZlYXR1cmVMYXllciwgU3RyZWFtTGF5ZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9sYXllcnMvRmVhdHVyZUxheWVyXCIsIFwiZXNyaS9sYXllcnMvU3RyZWFtTGF5ZXJcIl0pO1xuICAgIGlmICghbGF5ZXIgfHwgIShsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVMYXllcikgfHwgbGF5ZXIgaW5zdGFuY2VvZiBTdHJlYW1MYXllcikge1xuICAgICAgICByZXR1cm4gZXh0ZW50QXNMaXN0O1xuICAgIH1cbiAgICBpZiAoYXBpID09PSAzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIHpvb20gdG8gd2hlcmUgd2Ugc2VlIGZlYXR1cmVzXG4gICAgICAgICAgICBhd2FpdCBsYXllci5hZGRQbHVnaW4oXCJlc3JpL3BsdWdpbnMvRmVhdHVyZUxheWVyU3RhdGlzdGljc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCBsYXllci5zdGF0aXN0aWNzUGx1Z2luLmdldFN1Z2dlc3RlZFNjYWxlUmFuZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWluU2NhbGUsIGNlbnRlciwgcmVsYXhlZE1pblNjYWxlIH0gPSBpbmZvO1xuICAgICAgICAgICAgaWYgKGNlbnRlcikge1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdXNlIHRoZSB3aWR0aCB0aGUgc2NhbGUgaXMgY2FsY3VsYXRlZCB3aXRoIGFuZCB0aGVuIHNocmluayBkb3duIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBsZXQgZXh0ZW50ID0gYXdhaXQgZ2V0RXh0ZW50RnJvbUNlbnRlcihjZW50ZXIsIDEyODAsIG1pblNjYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5yZWxheGVkTWluU2NhbGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSB3ZSBzdGlsbCBpbiB0aGUgc2NhbGUgb2YgdGhlIGxheWVyIGZvciBhIDIwMCB3aWR0aCBtYXA/XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FsZSA9IGdldFNjYWxlRm9yRXh0ZW50KGV4dGVudCwgMjAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gODAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2NhbGUgPiByZWxheGVkTWluU2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudCA9IGdldEV4dGVudEZyb21DZW50ZXIoY2VudGVyLCB3aWR0aCwgbWluU2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBnZXRTY2FsZUZvckV4dGVudChleHRlbnQsIDIwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCAtPSAyMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQncyBpdCwgd2UgY2FuJ3QgZG8gbW9yZS4gVGh1bWJuYWlsIG1pZ2h0IGxvb2sgZW1wdHkgbm93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2plY3RFeHRlbnQoZXh0ZW50LCBuZXcgU3BhdGlhbFJlZmVyZW5jZSh7IHdraWQ6IDQzMjYgfSkpO1xuICAgICAgICAgICAgICAgIGV4dGVudEFzTGlzdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgW3Jlc3VsdFswXS54bWluLCByZXN1bHRbMF0ueW1pbl0sXG4gICAgICAgICAgICAgICAgICAgIFtyZXN1bHRbMF0ueG1heCwgcmVzdWx0WzBdLnltYXhdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbnRBc0xpc3Q7XG4gICAgfVxuICAgIC8vIFRPRE86IHVzZSBlc3JpL3NtYXJ0TWFwcGluZy9oZXVyaXN0aWNzL3NjYWxlUmFuZ2UgdG8gem9vbSB0byBmZWF0dXJlcy5cbiAgICByZXR1cm4gZXh0ZW50QXNMaXN0O1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U2NhbGVGb3JFeHRlbnQoZXh0ZW50LCB3aWR0aCkge1xuICAgIGNvbnN0IFtlc3JpQ29uZmlnLCBXS0lEVW5pdENvbnZlcnNpb25dID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9jb25maWdcIiwgXCJlc3JpL1dLSURVbml0Q29udmVyc2lvblwiXSk7XG4gICAgY29uc3QgSU5DSEVTX1BFUl9NRVRFUiA9IDM5LjM3O1xuICAgIGNvbnN0IERFQ19ERUdfVE9fTUVURVJTID0gMjAwMTUwNzcuMCAvIDE4MC4wO1xuICAgIGNvbnN0IHNwYXRpYWxSZWYgPSBleHRlbnQuc3BhdGlhbFJlZmVyZW5jZTtcbiAgICBjb25zdCB3a2lkID0gc3BhdGlhbFJlZiA9PT0gbnVsbCB8fCBzcGF0aWFsUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGF0aWFsUmVmLndraWQ7XG4gICAgY29uc3Qgd2t0ID0gc3BhdGlhbFJlZiA9PT0gbnVsbCB8fCBzcGF0aWFsUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGF0aWFsUmVmLndrdDtcbiAgICBsZXQgdW5pdFZhbHVlID0gbnVsbDtcbiAgICBpZiAod2tpZCkge1xuICAgICAgICB1bml0VmFsdWUgPSBXS0lEVW5pdENvbnZlcnNpb24udmFsdWVzW1dLSURVbml0Q29udmVyc2lvblt3a2lkXV07XG4gICAgfVxuICAgIGVsc2UgaWYgKCh3a3QgPT09IG51bGwgfHwgd2t0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3a3Quc2VhcmNoKC9eUFJPSkNTL2kpKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gd2VsbCBrbm93biB0ZXh0IGlzIFBST0pDU1xuICAgICAgICBjb25zdCByZXN1bHQgPSAvVU5JVFxcWyhbXlxcXV0rKVxcXVxcXSQvaS5leGVjKHdrdCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHRbMV0pIHtcbiAgICAgICAgICAgIHVuaXRWYWx1ZSA9IHBhcnNlRmxvYXQocmVzdWx0WzFdLnNwbGl0KFwiLFwiKVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZWxzZSBhc3N1bWVkIHRvIGJlIGluIGRlZ3JlZXNcbiAgICByZXR1cm4gKChleHRlbnQuZ2V0V2lkdGgoKSAvIHdpZHRoKSAqICh1bml0VmFsdWUgfHwgREVDX0RFR19UT19NRVRFUlMpICogSU5DSEVTX1BFUl9NRVRFUiAqIGVzcmlDb25maWcuZGVmYXVsdHMuc2NyZWVuRFBJKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEV4dGVudEZyb21DZW50ZXIocG9pbnQsIHdpZHRoLCBzY2FsZSkge1xuICAgIGNvbnN0IFtFeHRlbnRdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9nZW9tZXRyeS9FeHRlbnRcIl0pO1xuICAgIGNvbnN0IGV4dGVudCA9IG5ldyBFeHRlbnQocG9pbnQueCAtIDEsIHBvaW50LnkgLSAwLjUsIHBvaW50LnggKyAxLCBwb2ludC55ICsgMC41LCBwb2ludC5zcGF0aWFsUmVmZXJlbmNlKTtcbiAgICByZXR1cm4gZ2V0RXh0ZW50Rm9yU2NhbGUoZXh0ZW50LCB3aWR0aCwgc2NhbGUpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RXh0ZW50Rm9yU2NhbGUoZXh0ZW50LCB3aWR0aCwgc2NhbGUpIHtcbiAgICBjb25zdCBbZXNyaUNvbmZpZywgV0tJRFVuaXRDb252ZXJzaW9uXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvY29uZmlnXCIsIFwiZXNyaS9XS0lEVW5pdENvbnZlcnNpb25cIl0pO1xuICAgIGNvbnN0IElOQ0hFU19QRVJfTUVURVIgPSAzOS4zNywgREVDX0RFR19UT19NRVRFUlMgPSAyMDAxNTA3Ny4wIC8gMTgwLjAsIGxvb2t1cCA9IFdLSURVbml0Q29udmVyc2lvbjtcbiAgICBsZXQgd2tpZCwgd2t0LCBzciA9IGV4dGVudC5zcGF0aWFsUmVmZXJlbmNlO1xuICAgIGlmIChzcikge1xuICAgICAgICB3a2lkID0gc3Iud2tpZDtcbiAgICAgICAgd2t0ID0gc3Iud2t0O1xuICAgIH1cbiAgICBsZXQgdW5pdFZhbHVlID0gbnVsbDtcbiAgICBpZiAod2tpZCkge1xuICAgICAgICB1bml0VmFsdWUgPSBsb29rdXAudmFsdWVzW2xvb2t1cFt3a2lkXV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdrdCAmJiB3a3Quc2VhcmNoKC9eUFJPSkNTL2kpICE9PSAtMSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAvVU5JVFxcWyhbXlxcXV0rKVxcXVxcXSQvaS5leGVjKHdrdCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHRbMV0pIHtcbiAgICAgICAgICAgIHVuaXRWYWx1ZSA9IHBhcnNlRmxvYXQocmVzdWx0WzFdLnNwbGl0KFwiLFwiKVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZWxzZSBhc3N1bWVkIHRvIGJlIGluIGRlZ3JlZXNcbiAgICBjb25zdCBuZXdFeHRlbnQgPSBleHRlbnQuZXhwYW5kKChzY2FsZSAqIHdpZHRoKSAvXG4gICAgICAgICgodW5pdFZhbHVlIHx8IERFQ19ERUdfVE9fTUVURVJTKSAqIElOQ0hFU19QRVJfTUVURVIgKiBlc3JpQ29uZmlnLmRlZmF1bHRzLnNjcmVlbkRQSSkgL1xuICAgICAgICBleHRlbnQuZ2V0V2lkdGgoKSk7XG4gICAgcmV0dXJuIG5ld0V4dGVudDtcbn1cbmNvbnN0IGlzVmFsaWRXR1M4NEV4dGVudCA9IChleHRlbnQpID0+IHtcbiAgICAvLyBUYWtlbiBmcm9tIERlZmluZSBFeHRlbnQuanNcbiAgICBjb25zdCBpblJhbmdlID0gKHZhbHVlLCBtaW4sIG1heCkgPT4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbiAgICByZXR1cm4gKGluUmFuZ2UoZXh0ZW50LnltYXgsIC05MCwgOTApICYmIC8vIC05MCA8PSBtYXh5IDw9IDkwXG4gICAgICAgIGluUmFuZ2UoZXh0ZW50LnltaW4sIC05MCwgOTApICYmIC8vIC05MCA8PSBtaW55IDw9IDkwXG4gICAgICAgIGluUmFuZ2UoZXh0ZW50LnhtYXgsIC0xODAsIDE4MCkgJiYgLy8gLTE4MCA8PSBtYXh4IDw9IDE4MFxuICAgICAgICBpblJhbmdlKGV4dGVudC54bWluLCAtMTgwLCAxODApICYmIC8vIC0xODAgPD0gbWlueCA8PSAxODBcbiAgICAgICAgZXh0ZW50LnltYXggPiBleHRlbnQueW1pbiAmJiAvLyBtYXh5ID4gbWlueVxuICAgICAgICBleHRlbnQueG1heCA+IGV4dGVudC54bWluIC8vIG1heHggPiBtaW54XG4gICAgKTtcbn07XG5mdW5jdGlvbiBleHRlbnRUb1N0cmluZyhleHRlbnQsIHBsYWNlcyA9IDQpIHtcbiAgICBpZiAoIWV4dGVudCkge1xuICAgICAgICByZXR1cm4gZXh0ZW50VG9TdHJpbmcod29ybGRFeHRlbnRJbmZvKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleHRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVudDtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0ZW50KSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHRlbnRbMF0pICYmIEFycmF5LmlzQXJyYXkoZXh0ZW50WzFdKSkge1xuICAgICAgICAgICAgbGV0IG1pbnM7XG4gICAgICAgICAgICBsZXQgbWF4cztcbiAgICAgICAgICAgIGlmIChleHRlbnRbMF0ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgbWlucyA9IGV4dGVudFswXTtcbiAgICAgICAgICAgICAgICBtYXhzID0gZXh0ZW50WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVmZXIgdG8gT0dDRXh0ZW50J3MgYmJveCB0eXBlXG4gICAgICAgICAgICBpZiAoZXh0ZW50WzBdLmxlbmd0aCA9PT0gNCB8fCBleHRlbnRbMF0ubGVuZ3RoID09PSA2KSB7XG4gICAgICAgICAgICAgICAgbWlucyA9IFtleHRlbnRbMF1bMF0sIGV4dGVudFswXVsxXV07XG4gICAgICAgICAgICAgICAgbWF4cyA9IFtleHRlbnRbMF1bMl0sIGV4dGVudFswXVszXV07XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVudFswXS5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4cyA9IFtleHRlbnRbMF1bM10sIGV4dGVudFswXVs0XV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke21pbnMuam9pbihcIixcIil9LCR7bWF4cy5qb2luKFwiLFwiKX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbnQuam9pbihcIixcIik7XG4gICAgfVxuICAgIGNvbnN0IHhtaW4gPSBleHRlbnQueG1pbi50b0ZpeGVkKHBsYWNlcyk7XG4gICAgY29uc3QgeW1pbiA9IGV4dGVudC55bWluLnRvRml4ZWQocGxhY2VzKTtcbiAgICBjb25zdCB4bWF4ID0gZXh0ZW50LnhtYXgudG9GaXhlZChwbGFjZXMpO1xuICAgIGNvbnN0IHltYXggPSBleHRlbnQueW1heC50b0ZpeGVkKHBsYWNlcyk7XG4gICAgcmV0dXJuIGAke3htaW59LCR7eW1pbn0sJHt4bWF4fSwke3ltYXh9YDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYWRkS01MVXJsKGl0ZW1Qcm9wZXJ0aWVzLCBjb25maWcsIGFwaSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtleHRlbnQsIHRodW1ibmFpbFVSTF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBzZXRLbWxFeHRlbnQoaXRlbVByb3BlcnRpZXMudXJsLCBjb25maWcsIGFwaSksXG4gICAgICAgICAgICBidWlsZFRodW1ibmFpbFVSTEZyb21LTUxJdGVtKGl0ZW1Qcm9wZXJ0aWVzKVxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFkZFVybChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW1Qcm9wZXJ0aWVzKSwgeyBleHRlbnQsIHRodW1ibmFpbFVSTCB9KSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBzZXRLbWxFeHRlbnQodXJsLCBjb25maWcsIGFwaSkge1xuICAgIGNvbnN0IFtlc3JpQ29uZmlnLCBLTUxMYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2NvbmZpZ1wiLCBcImVzcmkvbGF5ZXJzL0tNTExheWVyXCJdKTtcbiAgICBpZiAoYXBpID09PSAzKSB7XG4gICAgICAgIGVzcmlDb25maWcuZGVmYXVsdHMua21sU2VydmljZSA9IGNvbmZpZy5rbWxTZXJ2aWNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXNyaUNvbmZpZy5rbWxTZXJ2aWNlVXJsID0gY29uZmlnLmttbFNlcnZpY2U7XG4gICAgfVxuICAgIGlmIChhcGkgPT09IDQpIHtcbiAgICAgICAgY29uc3Qga21sTGF5ZXIgPSBuZXcgS01MTGF5ZXIoeyB1cmwgfSk7XG4gICAgICAgIGF3YWl0IGttbExheWVyLmxvYWQoKTtcbiAgICAgICAgY29uc3Qga21sRXh0ZW50ID0ga21sTGF5ZXIuZnVsbEV4dGVudDtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gZXh0ZW50VG9TdHJpbmcoa21sRXh0ZW50KTtcbiAgICAgICAgcmV0dXJuIGV4dGVudDtcbiAgICB9XG4gICAgY29uc3Qga21sTGF5ZXIgPSBuZXcgS01MTGF5ZXIodXJsKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBrbWxMYXllci5vbihcImxvYWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga21sRXh0ZW50ID0gYXdhaXQgZ2V0S21sRXh0ZW50KGttbExheWVyKTtcbiAgICAgICAgICAgIHJlc29sdmUoa21sRXh0ZW50ID8gZXh0ZW50VG9TdHJpbmcoa21sRXh0ZW50KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBrbWxMYXllci5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRLbWxFeHRlbnQoa21sTGF5ZXIpIHtcbiAgICBjb25zdCBbZ3JhcGhpY3NVdGlsc10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2dyYXBoaWNzVXRpbHNcIl0pO1xuICAgIGNvbnN0IGttbExheWVycyA9IGttbExheWVyLmdldExheWVycygpO1xuICAgIGxldCBrbWxFeHRlbnQ7XG4gICAga21sTGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSBsYXllci5ncmFwaGljcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsYXllckV4dGVudCA9IGdyYXBoaWNzVXRpbHMuZ3JhcGhpY3NFeHRlbnQobGF5ZXIuZ3JhcGhpY3MpO1xuICAgICAgICAgICAga21sRXh0ZW50ID0gIWttbEV4dGVudCA/IGxheWVyRXh0ZW50IDoga21sRXh0ZW50LnVuaW9uKGxheWVyRXh0ZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBrbWxFeHRlbnQ7XG59XG5jb25zdCBwcm9jZXNzUG9zdEFkZEtNTCA9IGFzeW5jIChpdGVtSWQsIHBvcnRhbCwgcmVzdEJhc2VVcmwsIGNvbmZpZywgYXBpKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IHBvcnRhbC5pc1BvcnRhbCA/IHJlc3RCYXNlVXJsIDogYGh0dHBzOi8vJHtwb3J0YWwucG9ydGFsSG9zdG5hbWV9L3NoYXJpbmcvcmVzdGA7XG4gICAgICAgIGNvbnN0IHVybCA9IHBvcnRhbC5wb3J0YWxIb3N0bmFtZSA/IGAke2Jhc2VVcmx9L2NvbnRlbnQvaXRlbXMvJHtpdGVtSWR9L2RhdGFgIDogYCR7Z2V0SXRlbVVybChpdGVtSWQpfS9kYXRhYDtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gYXdhaXQgc2V0S21sRXh0ZW50KHVybCwgY29uZmlnLCBhcGkpO1xuICAgICAgICAvLyBUT0RPOiBEb3VibGUgY2hlY2sgcmVzdWx0IHR5cGUgb24gVVJMIHJlZmFjdG9yXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwZGF0ZUl0ZW0oaXRlbUlkLCB7IHVybCwgZXh0ZW50IH0pO1xuICAgICAgICByZXR1cm4geyByZXN1bHQgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICAgIH1cbn07XG5cbi8qKiBUcnVlIGlmIHggZG9lc24ndCBob2xkIGEgdmFsdWUuICovXG5mdW5jdGlvbiBpc05vbmUoeCkge1xuICAgIHJldHVybiB4ID09IG51bGw7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlzVGlsZWRJbWFnZVNlcnZpY2VMYXllcihsYXllcikge1xuICAgIGlmIChjb25maWdTdGF0ZS5hcGkgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyLnR5cGUgPT0gXCJpbWFnZXJ5LXRpbGVcIjtcbiAgICB9XG4gICAgY29uc3QgW1Jhc3RlclhMYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2xheWVycy9SYXN0ZXJYTGF5ZXJcIl0pO1xuICAgIHJldHVybiBsYXllciBpbnN0YW5jZW9mIFJhc3RlclhMYXllcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGlzSW1hZ2VTZXJ2aWNlTGF5ZXIobGF5ZXIpIHtcbiAgICBpZiAoY29uZmlnU3RhdGUuYXBpID09PSA0KSB7XG4gICAgICAgIHJldHVybiBsYXllci50eXBlID09PSBcImltYWdlcnlcIjtcbiAgICB9XG4gICAgY29uc3QgW0FyY0dJU0ltYWdlU2VydmljZUxheWVyLCBBcmNHSVNJbWFnZVNlcnZpY2VWZWN0b3JMYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICAgIFwiZXNyaS9sYXllcnMvQXJjR0lTSW1hZ2VTZXJ2aWNlTGF5ZXJcIixcbiAgICAgICAgXCJlc3JpL2xheWVycy9BcmNHSVNJbWFnZVNlcnZpY2VWZWN0b3JMYXllclwiXG4gICAgXSk7XG4gICAgcmV0dXJuIGxheWVyIGluc3RhbmNlb2YgQXJjR0lTSW1hZ2VTZXJ2aWNlTGF5ZXIgfHwgbGF5ZXIgaW5zdGFuY2VvZiBBcmNHSVNJbWFnZVNlcnZpY2VWZWN0b3JMYXllcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldERlZmF1bHRQb3B1cEluZm8obGF5ZXJJbmZvLCBsYXllcikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGlzcGxheUZpZWxkID0gbGF5ZXJJbmZvLmRpc3BsYXlGaWVsZDtcbiAgICBjb25zdCB0aXRsZSA9IGxheWVySW5mby5uYW1lICsgKChkaXNwbGF5RmllbGQgPT09IG51bGwgfHwgZGlzcGxheUZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaXNwbGF5RmllbGQubGVuZ3RoKSA/IGA6IHske2Rpc3BsYXlGaWVsZH19YCA6IFwiXCIpO1xuICAgIGxldCBmaWVsZHMgPSBsYXllckluZm8uZmllbGRzO1xuICAgIGxldCBpc01vc2FpY0RhdGFzZXRTZXJ2aWNlID0gZmFsc2U7XG4gICAgbGV0IGlzVmVjdG9yTW9zYWljRGF0YXNldFNlcnZpY2UgPSBmYWxzZTtcbiAgICBsZXQgaXNJbnRlZ2VySW1hZ2VTZXJ2aWNlID0gZmFsc2U7XG4gICAgY29uc3QgaXNJbWFnZVNlcnZpY2UgPSBhd2FpdCBpc0ltYWdlU2VydmljZUxheWVyKGxheWVyKTtcbiAgICBjb25zdCBpc1RpbGVkSW1hZ2VTZXJ2aWNlID0gYXdhaXQgaXNUaWxlZEltYWdlU2VydmljZUxheWVyKGxheWVyKTtcbiAgICBpZiAoaXNJbWFnZVNlcnZpY2UgfHwgaXNUaWxlZEltYWdlU2VydmljZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0geyByYXN0ZXJBdHRyaWJ1dGVUYWJsZUZpZWxkUHJlZml4OiBcIlJhc3Rlci5cIiB9O1xuICAgICAgICBmaWVsZHMgPSAoX2EgPSBsYXllci5nZXRDdXN0b21SYXN0ZXJGaWVsZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxheWVyLCBvcHRpb25zKTtcbiAgICAgICAgaXNJbnRlZ2VySW1hZ2VTZXJ2aWNlID0gW1wiRjMyXCIsIFwiRjY0XCJdLmluZGV4T2YobGF5ZXIucGl4ZWxUeXBlKSA8IDA7XG4gICAgICAgIC8vY2hlY2tpbmcgZm9yIHNpbmdsZSBkYXRhc2V0IGltYWdlIHNlcnZpY2VcbiAgICAgICAgaWYgKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci5jYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgIGlzTW9zYWljRGF0YXNldFNlcnZpY2UgPSAobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmNhcGFiaWxpdGllcy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJjYXRhbG9nXCIpKSA+IC0xIHx8ICgoX2IgPSBsYXllci5maWVsZHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpID4gMDtcbiAgICAgICAgICAgIGlzVmVjdG9yTW9zYWljRGF0YXNldFNlcnZpY2UgPVxuICAgICAgICAgICAgICAgIGlzTW9zYWljRGF0YXNldFNlcnZpY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgKGxheWVyLnNlcnZpY2VEYXRhVHlwZSA9PT0gXCJlc3JpSW1hZ2VTZXJ2aWNlRGF0YVR5cGVWZWN0b3ItVVZcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuc2VydmljZURhdGFUeXBlID09PSBcImVzcmlJbWFnZVNlcnZpY2VEYXRhVHlwZVZlY3Rvci1NYWdEaXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVjaW1hbCA9IHtcbiAgICAgICAgZXNyaUZpZWxkVHlwZURvdWJsZTogMSxcbiAgICAgICAgZXNyaUZpZWxkVHlwZVNpbmdsZTogMVxuICAgIH07XG4gICAgY29uc3QgaW50ZWdlciA9IHtcbiAgICAgICAgZXNyaUZpZWxkVHlwZUludGVnZXI6IDEsXG4gICAgICAgIGVzcmlGaWVsZFR5cGVTbWFsbEludGVnZXI6IDFcbiAgICB9O1xuICAgIGNvbnN0IGR0ID0ge1xuICAgICAgICBlc3JpRmllbGRUeXBlRGF0ZTogMVxuICAgIH07XG4gICAgLy8gaGlkZSBlZGl0b3IgdHJhY2tpbmcgZmllbGRzXG4gICAgbGV0IGVkaXRUcmFja2luZ0ZpZWxkcyA9IFwiLFwiO1xuICAgIGlmIChsYXllckluZm8uZWRpdEZpZWxkc0luZm8pIHtcbiAgICAgICAgaWYgKGxheWVySW5mby5lZGl0RmllbGRzSW5mby5jcmVhdG9yRmllbGQpIHtcbiAgICAgICAgICAgIGVkaXRUcmFja2luZ0ZpZWxkcyArPSBgJHtsYXllckluZm8uZWRpdEZpZWxkc0luZm8uY3JlYXRvckZpZWxkfSxgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXllckluZm8uZWRpdEZpZWxkc0luZm8uY3JlYXRpb25EYXRlRmllbGQpIHtcbiAgICAgICAgICAgIGVkaXRUcmFja2luZ0ZpZWxkcyArPSBgJHtsYXllckluZm8uZWRpdEZpZWxkc0luZm8uY3JlYXRpb25EYXRlRmllbGR9LGA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheWVySW5mby5lZGl0RmllbGRzSW5mby5lZGl0b3JGaWVsZCkge1xuICAgICAgICAgICAgZWRpdFRyYWNraW5nRmllbGRzICs9IGAke2xheWVySW5mby5lZGl0RmllbGRzSW5mby5lZGl0b3JGaWVsZH0sYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5ZXJJbmZvLmVkaXRGaWVsZHNJbmZvLmVkaXREYXRlRmllbGQpIHtcbiAgICAgICAgICAgIGVkaXRUcmFja2luZ0ZpZWxkcyArPSBgJHtsYXllckluZm8uZWRpdEZpZWxkc0luZm8uZWRpdERhdGVGaWVsZH0sYDtcbiAgICAgICAgfVxuICAgICAgICBlZGl0VHJhY2tpbmdGaWVsZHMgPSBlZGl0VHJhY2tpbmdGaWVsZHMudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgY29uc3QgZmllbGRJbmZvcyA9IGZpZWxkcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgbGV0IHZpc2libGUgPSBpdGVtLnR5cGUgIT09IFwiZXNyaUZpZWxkVHlwZU9JRFwiICYmXG4gICAgICAgICAgICBpdGVtLnR5cGUgIT09IFwiZXNyaUZpZWxkVHlwZUdsb2JhbElEXCIgJiZcbiAgICAgICAgICAgIGl0ZW0udHlwZSAhPT0gXCJlc3JpRmllbGRUeXBlR2VvbWV0cnlcIjtcbiAgICAgICAgbGV0IGZvcm1hdCA9IG51bGw7XG4gICAgICAgIGxldCBpc0VkaXRhYmxlID0gaXRlbS5lZGl0YWJsZSAmJiBpdGVtLnR5cGUgIT09IFwiZXNyaUZpZWxkVHlwZU9JRFwiICYmIGl0ZW0udHlwZSAhPT0gXCJlc3JpRmllbGRUeXBlR2xvYmFsSURcIjtcbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgIGxldCBmID0gaXRlbS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBsZXQgaGlkZUZpZWxkc1N0ciA9IGAke2VkaXRUcmFja2luZ0ZpZWxkc31zdHJldGNoZWQgdmFsdWUsZm5vZGVfLHRub2RlXyxscG9seV8scnBvbHlfLHBvbHlfLHN1YmNsYXNzLHN1YmNsYXNzXyxyaW5nc19vayxyaW5nc19ub2ssYDtcbiAgICAgICAgICAgIGlmIChpc01vc2FpY0RhdGFzZXRTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgaGlkZUZpZWxkc1N0ciA9IGAke2hpZGVGaWVsZHNTdHJ9cmFzdGVyLml0ZW1waXhlbHZhbHVlLGA7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmVjdG9yTW9zYWljRGF0YXNldFNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZUZpZWxkc1N0ciA9IGAke2hpZGVGaWVsZHNTdHJ9cmFzdGVyLm1hZ25pdHVkZSxyYXN0ZXIuZGlyZWN0aW9uLGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhpZGVGaWVsZHNTdHIuaW5kZXhPZihgLCR7Zn0sYCkgPiAtMSB8fFxuICAgICAgICAgICAgICAgIC8vZi5pbmRleE9mKFwiYXJlYVwiKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgLy9mLmluZGV4T2YoXCJsZW5ndGhcIikgPiAtMSB8fFxuICAgICAgICAgICAgICAgIGYuaW5kZXhPZihcInNoYXBlXCIpID4gLTEgfHxcbiAgICAgICAgICAgICAgICBmLmluZGV4T2YoXCJwZXJpbWV0ZXJcIikgPiAtMSB8fFxuICAgICAgICAgICAgICAgIGYuaW5kZXhPZihcIm9iamVjdGlkXCIpID4gLTEgfHxcbiAgICAgICAgICAgICAgICBmLmluZGV4T2YoXCJyYXN0ZXIuc2VydmljZXBpeGVsdmFsdWUuXCIpID4gLTEgfHxcbiAgICAgICAgICAgICAgICAvL2YuaW5kZXhPZihcIl9cIikgPT0gZi5sZW5ndGggLSAxIHx8XG4gICAgICAgICAgICAgICAgZi5pbmRleE9mKFwiX2lcIikgPT0gZi5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSBpbiBpbnRlZ2VyKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0ge1xuICAgICAgICAgICAgICAgICAgICBwbGFjZXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRpZ2l0U2VwYXJhdG9yOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0udHlwZSBpbiBkZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhc3RlclBpeGVsVmFsdWVGaWVsZCA9IGlzSW50ZWdlckltYWdlU2VydmljZSAmJlxuICAgICAgICAgICAgICAgICAgICAoZi5pbmRleE9mKFwicmFzdGVyLnNlcnZpY2VwaXhlbHZhbHVlXCIpID4gLTEgfHwgZi5pbmRleE9mKFwicmFzdGVyLml0ZW1waXhlbHZhbHVlXCIpID4gLTEpO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VzOiByYXN0ZXJQaXhlbFZhbHVlRmllbGQgPyAwIDogMixcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRTZXBhcmF0b3I6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS50eXBlIGluIGR0ICYmIChsYXllckluZm8uY3VycmVudFZlcnNpb24gPj0gMTAgfHwgKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci52ZXJzaW9uKSA+PSAxMCkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQ6IFwibG9uZ01vbnRoRGF5WWVhclwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc0VkaXRhYmxlID0gaXNFZGl0YWJsZSA/IGVkaXRUcmFja2luZ0ZpZWxkcy5pbmRleE9mKGAsJHtpdGVtLm5hbWUudG9Mb3dlckNhc2UoKX0sYCkgPT09IC0xIDogaXNFZGl0YWJsZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkTmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgbGFiZWw6IGl0ZW0uYWxpYXMsXG4gICAgICAgICAgICBpc0VkaXRhYmxlLFxuICAgICAgICAgICAgdG9vbHRpcDogXCJcIixcbiAgICAgICAgICAgIHZpc2libGUsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBzdHJpbmdGaWVsZE9wdGlvbjogXCJ0ZXh0Ym94XCJcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwb3B1cEluZm8gPSB7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgZmllbGRJbmZvczogZmllbGRJbmZvcyxcbiAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgIHNob3dBdHRhY2htZW50czogdHJ1ZSxcbiAgICAgICAgbWVkaWFJbmZvczogW10sXG4gICAgICAgIGxheWVyT3B0aW9uczogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAoaXNJbWFnZVNlcnZpY2VMYXllcihsYXllcikpIHtcbiAgICAgICAgcG9wdXBJbmZvLmxheWVyT3B0aW9ucyA9IHt9O1xuICAgICAgICBwb3B1cEluZm8ubGF5ZXJPcHRpb25zLnNob3dOb0RhdGFSZWNvcmRzID0gdHJ1ZTtcbiAgICAgICAgcG9wdXBJbmZvLmxheWVyT3B0aW9ucy5yZXR1cm5Ub3Btb3N0UmFzdGVyID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNUaWxlZEltYWdlU2VydmljZUxheWVyKGxheWVyKSkge1xuICAgICAgICBwb3B1cEluZm8ubGF5ZXJPcHRpb25zID0ge307XG4gICAgICAgIHBvcHVwSW5mby5sYXllck9wdGlvbnMuc2hvd05vRGF0YVJlY29yZHMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdXBJbmZvO1xufVxuXG5jb25zdCBwb2ludEpzb24gPSB7XG4gICAgdHlwZTogXCJlc3JpU01TXCIsXG4gICAgc3R5bGU6IFwiZXNyaVNNU0NpcmNsZVwiLFxuICAgIGNvbG9yOiBbMzQsIDExNCwgMTYyLCAxMjhdLFxuICAgIHNpemU6IDYsXG4gICAgb3V0bGluZToge1xuICAgICAgICBjb2xvcjogWzM0LCAxMTQsIDE2MiwgMjU1XSxcbiAgICAgICAgd2lkdGg6IDFcbiAgICB9XG59O1xuY29uc3QgbGluZUpzb24gPSB7XG4gICAgdHlwZTogXCJlc3JpU0xTXCIsXG4gICAgc3R5bGU6IFwiZXNyaVNMU1NvbGlkXCIsXG4gICAgY29sb3I6IFs3NywgNzcsIDc3LCAyNTVdLFxuICAgIHdpZHRoOiAxLjVcbn07XG5jb25zdCBwb2x5Z29uSnNvbiA9IHtcbiAgICB0eXBlOiBcImVzcmlTRlNcIixcbiAgICBzdHlsZTogXCJlc3JpU0ZTU29saWRcIixcbiAgICBjb2xvcjogWzIyNywgMTM5LCA3OSwgMjA0XSxcbiAgICBvdXRsaW5lOiB7XG4gICAgICAgIHR5cGU6IFwiZXNyaVNMU1wiLFxuICAgICAgICBzdHlsZTogXCJlc3JpU0xTU29saWRcIixcbiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1LCAyNTVdLFxuICAgICAgICB3aWR0aDogMC43NVxuICAgIH1cbn07XG5hc3luYyBmdW5jdGlvbiBnZXRSZW5kZXJlckFzSnNvbihnZW9tZXRyeVR5cGUpIHtcbiAgICBjb25zdCBbU2ltcGxlUmVuZGVyZXIsIGVzcmlKc29uVXRpbF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICAgIFwiZXNyaS9yZW5kZXJlcnMvU2ltcGxlUmVuZGVyZXJcIixcbiAgICAgICAgY29uZmlnU3RhdGUuYXBpID09PSA0ID8gXCJlc3JpL2dlb21ldHJ5L3N1cHBvcnQvanNvblV0aWxzXCIgOiBcImVzcmkvc3ltYm9scy9qc29uVXRpbHNcIlxuICAgIF0pO1xuICAgIHN3aXRjaCAoZ2VvbWV0cnlUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJlc3JpR2VvbWV0cnlQb2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVSZW5kZXJlcihlc3JpSnNvblV0aWwuZnJvbUpzb24ocG9pbnRKc29uKSkudG9Kc29uKCk7XG4gICAgICAgIGNhc2UgXCJlc3JpR2VvbWV0cnlQb2x5bGluZVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVSZW5kZXJlcihlc3JpSnNvblV0aWwuZnJvbUpzb24obGluZUpzb24pKS50b0pzb24oKTtcbiAgICAgICAgY2FzZSBcImVzcmlHZW9tZXRyeVBvbHlnb25cIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2ltcGxlUmVuZGVyZXIoZXNyaUpzb25VdGlsLmZyb21Kc29uKHBvbHlnb25Kc29uKSkudG9Kc29uKCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UG9wdXBJbmZvKHdmc0xheWVyKSB7XG4gICAgY29uc3QgeyBmaWVsZHMsIHNlbGVjdGVkTGF5ZXIgfSA9IHdmc0xheWVyO1xuICAgIGlmIChmaWVsZHMgPT09IG51bGwgfHwgZmllbGRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5vbkdlb21GaWVsZHMgPSBmaWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQudHlwZSAhPT0gXCJlc3JpRmllbGRUeXBlR2VvbWV0cnlcIik7XG4gICAgICAgIGlmIChub25HZW9tRmllbGRzID09PSBudWxsIHx8IG5vbkdlb21GaWVsZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vbkdlb21GaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdFBvcHVwSW5mbyh7XG4gICAgICAgICAgICAgICAgbmFtZTogKHNlbGVjdGVkTGF5ZXIgPT09IG51bGwgfHwgc2VsZWN0ZWRMYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWRMYXllci50aXRsZSkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICAgICAgfSwgd2ZzTGF5ZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0V2ZzQ29uZmlnKHdmc0xheWVyKSB7XG4gICAgY29uc3QgeyBsYXllck5hbWVzcGFjZSwgZ2V0RmVhdHVyZVVybCwgc3BhdGlhbFJlZmVyZW5jZXMsIGZpZWxkcyB9ID0gd2ZzTGF5ZXI7XG4gICAgY29uc3QgeyBtYXhGZWF0dXJlcywgZ2VvbWV0cnlUeXBlOiBhZGRJdGVtR2VvbWV0cnlUeXBlIH0gPSBhZGRJdGVtU3RhdGU7XG4gICAgbGV0IHVybDtcbiAgICBsZXQgbW9kZTtcbiAgICBsZXQgdmVyc2lvbjtcbiAgICBsZXQgbmFtZTtcbiAgICBpZiAoY29uZmlnU3RhdGUuYXBpID09PSAzKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB3ZnNMYXllci50b0pzb24oKTtcbiAgICAgICAgdXJsID0gZGF0YS51cmw7XG4gICAgICAgIG1vZGUgPSBkYXRhLm1vZGU7XG4gICAgICAgIHZlcnNpb24gPSBkYXRhLnZlcnNpb247XG4gICAgICAgIG5hbWUgPSBkYXRhLm5hbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB2NFdGUyA9IHdmc0xheWVyO1xuICAgICAgICB1cmwgPSB2NFdGUy51cmw7XG4gICAgICAgIC8vIG1vZGUgPSB2NFdGUy5tb2RlO1xuICAgICAgICB2ZXJzaW9uID0gXCIyLjAuMFwiO1xuICAgICAgICBuYW1lID0gdjRXRlMubmFtZTtcbiAgICB9XG4gICAgY29uc3QgZ2VvbWV0cnlUeXBlID0gYWRkSXRlbUdlb21ldHJ5VHlwZSB8fCB3ZnNMYXllci5nZW9tZXRyeVR5cGUgfHwgXCJlc3JpR2VvbWV0cnlDb21wbGV4XCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBtb2RlLFxuICAgICAgICB3ZnNJbmZvOiB7XG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHdmc05hbWVzcGFjZTogbGF5ZXJOYW1lc3BhY2UsXG4gICAgICAgICAgICBmZWF0dXJlVXJsOiBnZXRGZWF0dXJlVXJsLFxuICAgICAgICAgICAgc3VwcG9ydGVkU3BhdGlhbFJlZmVyZW5jZXM6IHNwYXRpYWxSZWZlcmVuY2VzLFxuICAgICAgICAgICAgY3VzdG9tUGFyYW1ldGVyczogd2ZzTGF5ZXIuY3VzdG9tUGFyYW1ldGVycyB8fCB7fSxcbiAgICAgICAgICAgIG1heEZlYXR1cmVzOiBtYXhGZWF0dXJlcyB8fCB3ZnNMYXllci5tYXhGZWF0dXJlcyB8fCAzMDAwXG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyRGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgZ2VvbWV0cnlUeXBlOiBnZW9tZXRyeVR5cGUsXG4gICAgICAgICAgICBkcmF3aW5nSW5mbzoge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBhd2FpdCBnZXRSZW5kZXJlckFzSnNvbihnZW9tZXRyeVR5cGUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3BhdGlhbFJlZmVyZW5jZToge1xuICAgICAgICAgICAgICAgIHdraWQ6IDQzMjZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWVsZHNcbiAgICAgICAgfSxcbiAgICAgICAgcG9wdXBJbmZvOiBhd2FpdCBnZXRQb3B1cEluZm8od2ZzTGF5ZXIpXG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkVGh1bWJuYWlsVVJMRnJvbVdGU0l0ZW0oZXh0ZW50KSB7XG4gICAgY29uc3QgeyBjb25maWcgfSA9IGNvbmZpZ1N0YXRlO1xuICAgIGNvbnN0IHdlYk1hcCA9IHtcbiAgICAgICAgYmFzZU1hcDogY29uZmlnLmRlZmF1bHRCYXNlbWFwIHx8IGNvbmZpZy5zZWxmLmRlZmF1bHRCYXNlbWFwLFxuICAgICAgICBvcGVyYXRpb25hbExheWVyczogW11cbiAgICB9O1xuICAgIGNvbnN0IHsgYmFzZU1hcExheWVycyB9ID0gd2ViTWFwLmJhc2VNYXA7XG4gICAgLy8gd2UgbmVlZCBvbmx5IG9uZSBiYXNlbWFwIGxheWVyIGFuZCB3ZSBoaWRlIGl0IC0gdXNlIGxheWVyU2V0IGJvb2wgdG8gY2hlY2sgaWYgb25lIGhhcyBiZWVuIHNldCBhbHJlYWR5XG4gICAgbGV0IGxheWVyU2V0ID0gZmFsc2U7XG4gICAgYmFzZU1hcExheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgICBpZiAoIWxheWVyLmlzUmVmZXJlbmNlICYmICFsYXllclNldCkge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCBvbmx5IG9uZSBiYXNlbWFwIGxheWVyIGFuZCB3ZSBoaWRlIGl0XG4gICAgICAgICAgICBpZiAoKGNvbmZpZy5hbGxTU0wgfHwgbG9jYXRpb24ucHJvdG9jb2wgPT0gXCJodHRwczpcIikgJiZcbiAgICAgICAgICAgICAgICAoaXNIb3N0ZWRTZXJ2aWNlKGxheWVyLnVybCkgfHwgc3VwcG9ydHNIdHRwcyhsYXllci51cmwpKSkge1xuICAgICAgICAgICAgICAgIGxheWVyLnVybCA9IGxheWVyLnVybC5yZXBsYWNlKFwiaHR0cDpcIiwgXCJodHRwczpcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllci52aXNpYmlsaXR5ID0gZmFsc2U7XG4gICAgICAgICAgICBsYXllclNldCA9IHRydWU7XG4gICAgICAgICAgICB3ZWJNYXAuYmFzZU1hcC5iYXNlTWFwTGF5ZXJzID0gW2xheWVyXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG9wZXJhdGlvbmFsTGF5ZXIgPSB7XG4gICAgICAgIHR5cGU6IFwiV0ZTXCIsXG4gICAgICAgIGxheWVyVHlwZTogXCJXRlNcIixcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgdmlzaWJpbGl0eTogdHJ1ZSxcbiAgICAgICAgaWQ6IFwid2ZzX3h4eFwiLFxuICAgICAgICB3ZnNJbmZvOiB7XG4gICAgICAgICAgICBtYXhGZWF0dXJlczogMTAwXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHdlYk1hcC5vcGVyYXRpb25hbExheWVycy5wdXNoKG9wZXJhdGlvbmFsTGF5ZXIpO1xuICAgIHJldHVybiBidWlsZFRodW1ibmFpbFVSTEZyb21JdGVtV2ViTWFwKHdlYk1hcCwgZXh0ZW50KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdNVFNDb25maWcod210c0xheWVyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGlzNHhBUEkgPSBjb25maWdTdGF0ZS5hcGkgPT09IDQ7XG4gICAgZnVuY3Rpb24gZ2V0VGlsZUluZm9Bc0pzb24oc2VsZWN0ZWRUaWxlSW5mbykge1xuICAgICAgICBjb25zdCB7IHRpbGVJbmZvIH0gPSBzZWxlY3RlZFRpbGVJbmZvO1xuICAgICAgICBpZiAoKHRpbGVJbmZvID09PSBudWxsIHx8IHRpbGVJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aWxlSW5mby5kcGkpICE9PSA5Nikge1xuICAgICAgICAgICAgdGlsZUluZm8ubG9kcy5mb3JFYWNoKChsb2QpID0+IHtcbiAgICAgICAgICAgICAgICBsb2Quc2NhbGUgPSAobG9kLnNjYWxlICogOTYpIC8gdGlsZUluZm8uZHBpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aWxlSW5mby5kcGkgPSA5NjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXM0eEFQSSA/IHRpbGVJbmZvIDogdGlsZUluZm8udG9Kc29uKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvcHlyaWdodChjb3B5cmlnaHQpIHtcbiAgICAgICAgaWYgKChjb3B5cmlnaHQgPT09IG51bGwgfHwgY29weXJpZ2h0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb3B5cmlnaHQudG9Mb3dlckNhc2UoKSkgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNvcHlyaWdodCA9PT0gbnVsbCB8fCBjb3B5cmlnaHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvcHlyaWdodC5sZW5ndGgpID4gMTgwID8gYCR7Y29weXJpZ2h0LnN1YnN0cmluZygwLCAxODApfS4uYCA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29weXJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtTcGF0aWFsUmVmZXJlbmNlXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgICAgIGlzNHhBUEkgPyBcImVzcmkvZ2VvbWV0cnkvU3BhdGlhbFJlZmVyZW5jZVwiIDogXCJlc3JpL1NwYXRpYWxSZWZlcmVuY2VcIlxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgeyBzZWxlY3RlZExheWVyLCBzZWxlY3RlZFRpbGVJbmZvLCBjb3B5cmlnaHQgfSA9IHdtdHNMYXllcjtcbiAgICAgICAgY29uc3Qgc3IgPSAoc2VsZWN0ZWRUaWxlSW5mbyA9PT0gbnVsbCB8fCBzZWxlY3RlZFRpbGVJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZFRpbGVJbmZvLmZ1bGxFeHRlbnQuc3BhdGlhbFJlZmVyZW5jZSkgfHwgbmV3IFNwYXRpYWxSZWZlcmVuY2UoeyB3a2lkOiA0MzI2IH0pO1xuICAgICAgICBjb25zdCBmdWxsRXh0ZW50ID0gYXdhaXQgcHJvamVjdEV4dGVudChzZWxlY3RlZExheWVyID09PSBudWxsIHx8IHNlbGVjdGVkTGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGVkTGF5ZXJbaXM0eEFQSSA/IFwiZnVsbEV4dGVudFwiIDogXCJnY3NFeHRlbnRcIl0sIHNyKS50aGVuKChyZXN1bHQpID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdFswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSBcImV4dGVudFwiID8gKGNvbmZpZ1N0YXRlLmFwaSA9PT0gNCA/IHJlc3VsdFswXSA6IHJlc3VsdFswXS50b0pzb24oKSkgOiBudWxsOyB9KTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gc2VsZWN0ZWRMYXllcltpczR4QVBJID8gXCJpbWFnZUZvcm1hdFwiIDogXCJmb3JtYXRzXCJdLmluZGV4T2YoXCJpbWFnZS9wbmdcIikgPiAtMVxuICAgICAgICAgICAgPyBcImltYWdlL3BuZ1wiXG4gICAgICAgICAgICA6IHNlbGVjdGVkTGF5ZXIuZm9ybWF0c1swXTtcbiAgICAgICAgd210c0xheWVyLnJlc291cmNlVXJscyA9IHNlbGVjdGVkTGF5ZXIucmVzb3VyY2VVcmxzO1xuICAgICAgICBsZXQgdGVtcGxhdGVVcmw7XG4gICAgICAgIGlmIChpczR4QVBJKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZVVybCA9IHdtdHNMYXllci5nZXRVcmxUZW1wbGF0ZShzZWxlY3RlZExheWVyLmlkLCBzZWxlY3RlZFRpbGVJbmZvLmlkLCBmb3JtYXQsIHNlbGVjdGVkTGF5ZXIuc3R5bGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZVVybCA9IHdtdHNMYXllci5nZXRUaWxlVXJsVGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IHNlbGVjdGVkTGF5ZXIuaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICB0aWxlTWF0cml4U2V0OiBzZWxlY3RlZFRpbGVJbmZvLnRpbGVNYXRyaXhTZXQsXG4gICAgICAgICAgICAgICAgZm9ybWF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3bXRzQ29uZmlnID0ge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmwsXG4gICAgICAgICAgICBjb3B5cmlnaHQ6IGdldENvcHlyaWdodChjb3B5cmlnaHQpLFxuICAgICAgICAgICAgZnVsbEV4dGVudDogZnVsbEV4dGVudCB8fCB3bXRzTGF5ZXIuc2VsZWN0ZWRUaWxlSW5mby5mdWxsRXh0ZW50LFxuICAgICAgICAgICAgdGlsZUluZm86IGdldFRpbGVJbmZvQXNKc29uKHNlbGVjdGVkVGlsZUluZm8pLFxuICAgICAgICAgICAgd210c0luZm86IHtcbiAgICAgICAgICAgICAgICB1cmw6IChfYSA9IHdtdHNMYXllci53bXRzVXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB3bXRzTGF5ZXIudXJsLFxuICAgICAgICAgICAgICAgIGxheWVySWRlbnRpZmllcjogc2VsZWN0ZWRMYXllci5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHRpbGVNYXRyaXhTZXQ6IHNlbGVjdGVkVGlsZUluZm8udGlsZU1hdHJpeFNldCxcbiAgICAgICAgICAgICAgICBjdXN0b21QYXJhbWV0ZXJzOiB3bXRzTGF5ZXIuY3VzdG9tUGFyYW1ldGVycyB8fCB7fSxcbiAgICAgICAgICAgICAgICBjdXN0b21MYXllclBhcmFtZXRlcnM6IHdtdHNMYXllci5jdXN0b21MYXllclBhcmFtZXRlcnMgfHwge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHdtdHNDb25maWc6IHdtdHNDb25maWcsIGZ1bGxFeHRlbnQ6IGZ1bGxFeHRlbnQgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFRPRE86IHJlZmFjdG9yIHRoaXMgdG8gb3VyIGVycm9yIHN5c3RlbVxuICAgIH1cbn1cbi8qKiBIQVpBUkQgV0FSTklORyEgUmV0dXJuIGEgVVJMIHRvIHRoZSBob3N0ZWQgaW1hZ2UgaW4gMy54IGNhc2UgYW5kIGJhc2U2NCBkYXRhIHVybCBpbiA0LnggY2FzZSovXG5hc3luYyBmdW5jdGlvbiBidWlsZFRodW1ibmFpbFVSTEZyb21XTVRTSXRlbShpdGVtLCBuZXdFeHRlbnQpIHtcbiAgICBpZiAoY29uZmlnU3RhdGUuYXBpID09PSAzKSB7XG4gICAgICAgIGNvbnN0IGJhc2VNYXBMYXllck9wdHMgPSB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogdHJ1ZSxcbiAgICAgICAgICAgIGxheWVyVHlwZTogXCJXZWJUaWxlZExheWVyXCIsXG4gICAgICAgICAgICB0eXBlOiBcIldlYlRpbGVkTGF5ZXJcIlxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB3ZWJNYXAgPSB7XG4gICAgICAgICAgICBiYXNlTWFwOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiYmFzZW1hcFwiLFxuICAgICAgICAgICAgICAgIGJhc2VNYXBMYXllcnM6IFtdLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbmFsTGF5ZXJzOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXRlbS5pZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRJdGVtRGF0YShpdGVtLmlkKTtcbiAgICAgICAgICAgIHdlYk1hcC5iYXNlTWFwLmJhc2VNYXBMYXllcnMucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlKSwgYmFzZU1hcExheWVyT3B0cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2ViTWFwLmJhc2VNYXAuYmFzZU1hcExheWVycy5wdXNoKGJhc2VNYXBMYXllck9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZFRodW1ibmFpbFVSTEZyb21XZWJNYXAod2ViTWFwLCBuZXdFeHRlbnQgfHwgaXRlbS5leHRlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgW1dNVFNMYXllciwgTWFwLCBNYXBWaWV3LCByZWFjdGl2ZVV0aWxzXSA9IChhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICAgICAgICBcImVzcmkvbGF5ZXJzL1dNVFNMYXllclwiLFxuICAgICAgICAgICAgXCJlc3JpL01hcFwiLFxuICAgICAgICAgICAgXCJlc3JpL3ZpZXdzL01hcFZpZXdcIixcbiAgICAgICAgICAgIFwiZXNyaS9jb3JlL3JlYWN0aXZlVXRpbHNcIlxuICAgICAgICBdKSk7XG4gICAgICAgIGNvbnN0IHdtdHNMYXllciA9IG5ldyBXTVRTTGF5ZXIoe1xuICAgICAgICAgICAgcG9ydGFsSXRlbToge1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLS0tIFVzZXIucm9sZSBpcyBkaWZmZXJlbnQgaW4gM3hcbiAgICAgICAgICAgICAgICBwb3J0YWw6IGNvbmZpZ1N0YXRlLnBvcnRhbFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IE1hcCh7IGxheWVyczogW3dtdHNMYXllcl0gfSk7XG4gICAgICAgIGNvbnN0IGhpZGRlbk1hcElkID0gY3JlYXRlSGlkZGVuTWFwRGl2KCk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgTWFwVmlldyh7IGNvbnRhaW5lcjogaGlkZGVuTWFwSWQsIG1hcCB9KTtcbiAgICAgICAgYXdhaXQgcmVhY3RpdmVVdGlscy53aGVuT25jZSgoKSA9PiAhdmlldy51cGRhdGluZyk7XG4gICAgICAgIGF3YWl0IHZpZXcuZ29Ubyh3bXRzTGF5ZXIuZnVsbEV4dGVudCk7XG4gICAgICAgIGNvbnN0IHNjcmVlbnNob3QgPSBhd2FpdCB2aWV3LnRha2VTY3JlZW5zaG90KHtcbiAgICAgICAgICAgIHdpZHRoOiB2aWV3LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB2aWV3LmhlaWdodCxcbiAgICAgICAgICAgIGZvcm1hdDogXCJwbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNjcmVlbnNob3QuZGF0YVVybDtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRJdGVtRGF0YShpZCkge1xuICAgIGNvbnN0IHsgY29uZmlnIH0gPSBjb25maWdTdGF0ZTtcbiAgICBjb25zdCB1cmwgPSBgJHtjb25maWcucmVzdEJhc2VVcmx9Y29udGVudC9pdGVtcy8ke2lkfS9kYXRhYDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0KHVybCwgbnVsbCwge1xuICAgICAgICAgICAgZGlzYWJsZUlkZW50aXR5TG9va3VwOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmICgocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0Lndmc0luZm8pIHx8IHJlc3VsdC53bXRzSW5mbykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmxheWVycykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5sYXllcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGljSW1hZ2VzVXJsKHBvcnRhbCkge1xuICAgIHZhciBfYTtcbiAgICAvLyBAdHMtaWdub3JlIC0gdGhpcyBwcm9wZXJ0eSBpcyB0aGVyZSBpbiA0LngsIHRoZWlyIHR5cGVzIGFyZSBpbmNvcnJlY3RcbiAgICByZXR1cm4gKChfYSA9IHBvcnRhbCA9PT0gbnVsbCB8fCBwb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbC5zdGF0aWNJbWFnZXNVcmwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKFwiaHR0cDpcIiwgXCJodHRwczpcIikpIHx8IFwiXCI7XG59XG5jb25zdCBjaGVja1RodW1ibmFpbFVSTCA9IChpdGVtKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBvcnRhbCA9IGNvbmZpZ1N0YXRlLnBvcnRhbDtcbiAgICBpZiAoaXRlbS50aHVtYm5haWxVUkwpIHtcbiAgICAgICAgaXRlbS50aHVtYm5haWxVUkwgPSBnZXRTdGF0aWNJbWFnZXNVcmwocG9ydGFsKSArIGl0ZW0udGh1bWJuYWlsVVJMO1xuICAgIH1cbiAgICBpZiAocG9ydGFsLmlzUG9ydGFsICYmICgoX2EgPSBpdGVtLnRodW1ibmFpbFVSTCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluZGV4T2YoXCJodHRwXCIpKSAhPT0gMCkge1xuICAgICAgICAvLyBzdGF0aWNJbWFnZXNVcmwgaXMgcmVsYXRpdmVcbiAgICAgICAgaXRlbS50aHVtYm5haWxVUkwgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIGl0ZW0udGh1bWJuYWlsVVJMO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbn07XG5cbmNvbnN0IHN0cmlwUGFyYW1ldGVycyA9ICh1cmwsIGJsYWNrTGlzdCkgPT4ge1xuICAgIGNvbnN0IFtiYXNlLCBzZWFyY2hdID0gdXJsLnNwbGl0KFwiP1wiKTtcbiAgICBjb25zdCB3aGl0ZWxpc3RlZCA9IChzZWFyY2ggPT09IG51bGwgfHwgc2VhcmNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2guc3BsaXQoXCImXCIpLnJlZHVjZSgoYWNjLCBzZWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IFtrZXldID0gc2VjdGlvbi5zcGxpdChcIj1cIik7XG4gICAgICAgIGlmIChibGFja0xpc3QuaW5kZXhPZihrZXkudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7YWNjID8gXCImXCIgOiBcIj9cIn0ke3NlY3Rpb259YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFwiXCIpKSB8fCBcIlwiO1xuICAgIHJldHVybiBgJHtiYXNlfSR7d2hpdGVsaXN0ZWR9YDtcbn07XG5jb25zdCBnZXRXTVNTZXJ2aWNlSW5mbyA9IGFzeW5jIChpdGVtKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IFtXTVNMYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2xheWVycy9XTVNMYXllclwiXSk7XG4gICAgY29uc3QgeyBjdXN0b21QYXJhbWV0ZXJzIH0gPSBpdGVtO1xuICAgIGNvbnN0IGZvcm1hdHRlZFBhcmFtcyA9IGZvcm1hdEN1c3RvbVBhcmFtZXRlcnMoY3VzdG9tUGFyYW1ldGVycyk7XG4gICAgLy8gUmVtb3ZlIHRoZXNlIHBhcmFtZXRlcnMgZnJvbSB0aGUgdXJsIHNpbmNlIHRoZSBKU0FQSSB3aWxsIHNldCB0aGVtIGF1dG9tYXRpY2FsbHlcbiAgICBjb25zdCB3bXNVcmwgPSBzdHJpcFBhcmFtZXRlcnMoaXRlbS51cmwsIFtcbiAgICAgICAgXCJzZXJ2aWNlXCIsXG4gICAgICAgIFwicmVxdWVzdFwiLFxuICAgICAgICBcImJib3hcIixcbiAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgXCJoZWlnaHRcIixcbiAgICAgICAgXCJ3aWR0aFwiLFxuICAgICAgICBcImxheWVyc1wiLFxuICAgICAgICBcInNyc1wiLFxuICAgICAgICBcImNyc1wiLFxuICAgICAgICBcInN0eWxlc1wiLFxuICAgICAgICBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgIFwiYmdjb2xvclwiLFxuICAgICAgICBcImV4Y2VwdGlvbnNcIixcbiAgICAgICAgXCJ0aW1lXCIsXG4gICAgICAgIFwiZWxldmF0aW9uXCIsXG4gICAgICAgIFwic2xkXCIsXG4gICAgICAgIFwid2ZzXCJcbiAgICBdKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoY29uZmlnU3RhdGUuYXBpID09PSA0KSB7XG4gICAgICAgICAgICBjb25zdCB3bXNMYXllciA9IG5ldyBXTVNMYXllcih7XG4gICAgICAgICAgICAgICAgdXJsOiB3bXNVcmwsXG4gICAgICAgICAgICAgICAgY3VzdG9tUGFyYW1ldGVyczogT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0dGVkUGFyYW1zID09PSBudWxsIHx8IGZvcm1hdHRlZFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0dGVkUGFyYW1zLmN1c3RvbVBhcmFtZXRlcnMpIHx8IHt9LFxuICAgICAgICAgICAgICAgIGN1c3RvbUxheWVyUGFyYW1ldGVyczogT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0dGVkUGFyYW1zID09PSBudWxsIHx8IGZvcm1hdHRlZFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0dGVkUGFyYW1zLmN1c3RvbUxheWVyUGFyYW1ldGVycykgfHwge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkZWRMYXllciA9IGF3YWl0IHdtc0xheWVyLmxvYWQoKTtcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSBcIldNU1wiO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyB0eXBlOiBcIldNU1wiLCBzZXJ2aWNlSW5mbzogbG9hZGVkTGF5ZXIgfSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyLm1lc3NhZ2UgPyBcInVuaGFuZGxlZEVycm9yXCIgOiBcInNlcnZpY2VOb3RFeGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKF9hID0gZXJyLm1lc3NhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLSB2MyAtLS1cbiAgICAgICAgYXdhaXQgY2hlY2tDT1JTKHdtc1VybCk7XG4gICAgICAgIGNvbnN0IHdtc0xheWVyID0gbmV3IFdNU0xheWVyKHdtc1VybCwge1xuICAgICAgICAgICAgY3VzdG9tUGFyYW1ldGVyczogT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0dGVkUGFyYW1zID09PSBudWxsIHx8IGZvcm1hdHRlZFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0dGVkUGFyYW1zLmN1c3RvbVBhcmFtZXRlcnMpIHx8IHt9LFxuICAgICAgICAgICAgY3VzdG9tTGF5ZXJQYXJhbWV0ZXJzOiBPYmplY3QuYXNzaWduKHt9LCBmb3JtYXR0ZWRQYXJhbXMgPT09IG51bGwgfHwgZm9ybWF0dGVkUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXR0ZWRQYXJhbXMuY3VzdG9tTGF5ZXJQYXJhbWV0ZXJzKSB8fCB7fVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgd21zTGF5ZXIub24oXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSBcIldNU1wiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyB0eXBlOiBcIldNU1wiLCBzZXJ2aWNlSW5mbzogd21zTGF5ZXIgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3bXNMYXllci5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gZXJyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VOb3RFeGlzdCA9ICEoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpIHx8IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3Iuc3RhdHVzKSA9PT0gNDA0O1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHNlcnZpY2VOb3RFeGlzdCA/IFwic2VydmljZU5vdEV4aXN0XCIgOiBcInVuaGFuZGxlZEVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChfYSA9IGVycm9yLm1lc3NhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgfVxufTtcbi8vIHRoaXMgd2lsbCBjb3JyZWN0bHkgZm9ybWF0IHRoZSBsYXllcnMgZnJvbSB0aGUgc2VydmljZSBpbmZvIHRvIGJlIHVzZWQgaW4gdGhlIGJ1bGsgbGF5ZXIgc2VsZWN0IGNvbXBvbmVudFxuY29uc3QgbG9hZFdNU0xheWVycyA9IGFzeW5jIChzZXJ2aWNlSW5mbykgPT4ge1xuICAgIGNvbnN0IGxvYWRlZFNlcnZpY2VJbmZvID0gY29uZmlnU3RhdGUuYXBpID09PSA0ID8gYXdhaXQgc2VydmljZUluZm8ubG9hZCgpIDogc2VydmljZUluZm87XG4gICAgY29uc3QgeyBsYXllckluZm9zLCB0aXRsZSwgYWxsU3VibGF5ZXJzIH0gPSBsb2FkZWRTZXJ2aWNlSW5mbztcbiAgICBjb25zdCBsYXllcnMgPSBnZXRXTVNMYXllclRyZWUoY29uZmlnU3RhdGUuYXBpID09PSA0ID8gYWxsU3VibGF5ZXJzLml0ZW1zIDogbGF5ZXJJbmZvcyk7XG4gICAgLy8gVE9ETzogbW92ZSB0aXRsZSB0byBiYXNlIHNlcnZpY2VJbmZvIGZldGNoLCBvbmx5IHJldHVybiBsYXllcnMgaGVyZVxuICAgIHJldHVybiB7IHRpdGxlLCBsYXllcnMgfTtcbn07XG5mdW5jdGlvbiBnZXRXTVNMYXllclRyZWUobGF5ZXJzKSB7XG4gICAgcmV0dXJuIGxheWVycy5tYXAoKGxheWVyKSA9PiAoe1xuICAgICAgICBuYW1lOiBsYXllci5uYW1lLFxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgdGl0bGU6IGxheWVyLnRpdGxlLnJlcGxhY2UoLyAvZywgU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApKSxcbiAgICAgICAgZXh0ZW50OiBsYXllci5leHRlbnQsXG4gICAgICAgIGxlZ2VuZFVSTDogbGF5ZXIubGVnZW5kVVJMLFxuICAgICAgICBxdWVyeWFibGU6IGxheWVyLnF1ZXJ5YWJsZSxcbiAgICAgICAgc3ViTGF5ZXJzOiBsYXllci5zdWJMYXllcnMgfHwgW11cbiAgICB9KSk7XG59XG5mdW5jdGlvbiBmbGF0dGVuTGF5ZXJBbmRSZW1vdmVJZHMoZmxhdHRlbmVkTGF5ZXJzID0gW10sIGxheWVyKSB7XG4gICAgZGVsZXRlIGxheWVyLmlkO1xuICAgIGlmICghbGF5ZXIuc3ViTGF5ZXJzIHx8ICFsYXllci5zdWJMYXllcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbLi4uZmxhdHRlbmVkTGF5ZXJzLCBsYXllcl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbGF5ZXIuc3ViTGF5ZXJzLnJlZHVjZShmbGF0dGVuTGF5ZXJBbmRSZW1vdmVJZHMsIGZsYXR0ZW5lZExheWVycyk7XG4gICAgfVxufVxuY29uc3QgYWRkV01TVXJsID0gYXN5bmMgKGl0ZW0pID0+IHtcbiAgICBjb25zdCBbU3BhdGlhbFJlZmVyZW5jZV0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICAgIGNvbmZpZ1N0YXRlLmFwaSA9PT0gNCA/IFwiZXNyaS9nZW9tZXRyeS9TcGF0aWFsUmVmZXJlbmNlXCIgOiBcImVzcmkvU3BhdGlhbFJlZmVyZW5jZVwiXG4gICAgXSk7XG4gICAgY29uc3QgeyBsYXllcnMgfSA9IGFkZEl0ZW1TdGF0ZTtcbiAgICBpZiAoIWl0ZW0gfHwgIShpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW0uc2VydmljZUluZm8pKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzZXJ2aWNlTm90RXhpc3RcIikpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtSW5mbyA9IGNoZWNrVGh1bWJuYWlsVVJMKGl0ZW0pO1xuICAgIGNvbnN0IHsgc2VydmljZUluZm8gfSA9IGl0ZW1JbmZvO1xuICAgIGNvbnN0IHZpc2libGVMYXllcnMgPSBbXTtcbiAgICBsZXQgZnVsbEV4dGVudDtcbiAgICBjb25zdCBmbGF0dGVuZWRMYXllcnMgPSBsYXllcnMucmVkdWNlKGZsYXR0ZW5MYXllckFuZFJlbW92ZUlkcywgW10pO1xuICAgIGNvbnN0IHNlbGVjdGVkTGF5ZXJzID0gZmxhdHRlbmVkTGF5ZXJzLm1hcCgobGF5ZXIpID0+IHtcbiAgICAgICAgZnVsbEV4dGVudCA9ICFmdWxsRXh0ZW50ID8gbGF5ZXIuZXh0ZW50IDogbGF5ZXIuZXh0ZW50ID8gZnVsbEV4dGVudC51bmlvbihsYXllci5leHRlbnQpIDogZnVsbEV4dGVudDtcbiAgICAgICAgdmlzaWJsZUxheWVycy5wdXNoKGxheWVyLm5hbWUpO1xuICAgICAgICBjb25zdCBvYmogPSB7IG5hbWU6IGxheWVyLm5hbWUsIHRpdGxlOiBsYXllci50aXRsZSwgbGVnZW5kVVJMOiBcIlwiLCBxdWVyeWFibGU6IGxheWVyLnF1ZXJ5YWJsZSB9O1xuICAgICAgICBpZiAobGF5ZXIubGVnZW5kVVJMKSB7XG4gICAgICAgICAgICBvYmoubGVnZW5kVVJMID0gbGF5ZXIubGVnZW5kVVJMO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSk7XG4gICAgc2VydmljZUluZm8uc2V0VmlzaWJsZUxheWVycyh2aXNpYmxlTGF5ZXJzKTtcbiAgICBmdWxsRXh0ZW50ID0gZnVsbEV4dGVudCB8fCBzZXJ2aWNlSW5mby5mdWxsRXh0ZW50O1xuICAgIGNvbnN0IGlzR0NTID0gIXNlcnZpY2VJbmZvLnNwYXRpYWxSZWZlcmVuY2VzLnNvbWUoKHNyKSA9PiBzciA9PT0gZnVsbEV4dGVudC5zcGF0aWFsUmVmZXJlbmNlLndraWQpO1xuICAgIGNvbnN0IHVwZGF0ZWRJdGVtID0ge1xuICAgICAgICB0eXBlOiBpdGVtLnR5cGUsXG4gICAgICAgIHVybDogc2VydmljZUluZm8udXJsLFxuICAgICAgICBkZXNjcmlwdGlvbjogc2VydmljZUluZm8uZGVzY3JpcHRpb24gfHwgXCJcIixcbiAgICAgICAgYWNjZXNzSW5mb3JtYXRpb246IHNlcnZpY2VJbmZvLmNvcHlyaWdodCB8fCBcIlwiLFxuICAgICAgICB0ZXh0OiBnZXRXTVNEYXRhKHNlcnZpY2VJbmZvLCBzZWxlY3RlZExheWVycyksXG4gICAgICAgIGV4dGVudDogZnVsbEV4dGVudFxuICAgIH07XG4gICAgaWYgKGlzR0NTKSB7XG4gICAgICAgIHByb2plY3QoZnVsbEV4dGVudCwgbmV3IFNwYXRpYWxSZWZlcmVuY2UoeyB3a2lkOiBzZXJ2aWNlSW5mby5zcGF0aWFsUmVmZXJlbmNlc1swXSB9KSkudGhlbigoZXh0ZW50KSA9PiAodXBkYXRlZEl0ZW0uZXh0ZW50ID0gZXh0ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1Ub0FkZCA9IGF3YWl0IGdldFdNU0ltYWdlVXJsKHVwZGF0ZWRJdGVtLCBzZXJ2aWNlSW5mbyk7XG4gICAgcmV0dXJuIGFkZFVybChpdGVtVG9BZGQpO1xufTtcbmNvbnN0IGdldFdNU0ltYWdlVXJsID0gKGl0ZW0sIHdtc0xheWVyKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoaW1hZ2VVcmwpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyB0aHVtYm5haWxVUkw6IGltYWdlVXJsIHx8IGl0ZW0udGh1bWJuYWlsVVJMLCBleHRlbnQ6IGV4dGVudFRvU3RyaW5nKGl0ZW0uZXh0ZW50KSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHdtc0xheWVyLmdldEltYWdlVXJsKGl0ZW0uZXh0ZW50LCA4MDAsIDUzMiwgaGFuZGxlciwgaGFuZGxlcik7XG4gICAgfSk7XG59O1xuY29uc3QgZ2V0V01TRGF0YSA9ICh3bXNMYXllciwgc2VsZWN0ZWRMYXllcnMpID0+IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB0aXRsZTogd21zTGF5ZXIudGl0bGUgfHwgXCJcIixcbiAgICAgICAgdXJsOiB3bXNMYXllci51cmwsXG4gICAgICAgIG1hcFVybDogd21zTGF5ZXIuZ2V0TWFwVVJMLFxuICAgICAgICB2ZXJzaW9uOiB3bXNMYXllci52ZXJzaW9uLFxuICAgICAgICBsYXllcnM6IHNlbGVjdGVkTGF5ZXJzLFxuICAgICAgICBjb3B5cmlnaHQ6IHdtc0xheWVyLmNvcHlyaWdodCB8fCBcIlwiLFxuICAgICAgICBtYXhIZWlnaHQ6IHdtc0xheWVyLm1heEhlaWdodCxcbiAgICAgICAgbWF4V2lkdGg6IHdtc0xheWVyLm1heFdpZHRoLFxuICAgICAgICBzcGF0aWFsUmVmZXJlbmNlczogd21zTGF5ZXIuc3BhdGlhbFJlZmVyZW5jZXMsXG4gICAgICAgIGZvcm1hdDogd21zTGF5ZXIuZ2V0SW1hZ2VGb3JtYXQoKSAhPT0gXCJwbmdcIiA/IHdtc0xheWVyLmdldEltYWdlRm9ybWF0KCkgOiBudWxsLFxuICAgICAgICBmZWF0dXJlSW5mb1VybDogd21zTGF5ZXIuZ2V0RmVhdHVyZUluZm9VUkwsXG4gICAgICAgIGZlYXR1cmVJbmZvRm9ybWF0OiB3bXNMYXllci5mZWF0dXJlSW5mb0Zvcm1hdCxcbiAgICAgICAgY3VzdG9tUGFyYW1ldGVyczogd21zTGF5ZXIuY3VzdG9tUGFyYW1ldGVycyB8fCB7fSxcbiAgICAgICAgY3VzdG9tTGF5ZXJQYXJhbWV0ZXJzOiB3bXNMYXllci5jdXN0b21MYXllclBhcmFtZXRlcnMgfHwge31cbiAgICB9KTtcbn07XG5jb25zdCBnZXRXRlNWZXJzaW9uRnJvbVVybCA9IGFzeW5jICh1cmwpID0+IHtcbiAgICBjb25zdCB7IHF1ZXJ5OiBxdWVyeU9iamVjdCB9ID0gYXdhaXQgdXJsVG9PYmplY3QodXJsKTtcbiAgICByZXR1cm4gKHF1ZXJ5T2JqZWN0ID09PSBudWxsIHx8IHF1ZXJ5T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBxdWVyeU9iamVjdC52ZXJzaW9uKSB8fCBcIjIuMC4wXCI7XG59O1xuLyoqXG4gKiBGZXRjaCBhIHVybCBhbmQgYWRkIHRvIHRoZSB0cnVzdGVkIGRvbWFpbnMgbGlzdCBpZiBpdCBzdXBwb3J0cyBDT1JTXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQ09SUyh1cmwpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB0ZXN0UmVwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgICAgIGlmICh0ZXN0UmVwb25zZS50eXBlID09PSBcImNvcnNcIiAmJiB0ZXN0UmVwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluID0gbmV3IFVSTCh1cmwpLmhvc3RuYW1lO1xuICAgICAgICAgICAgY29uc3QgW2VzcmlDb25maWddID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9jb25maWdcIl0pO1xuICAgICAgICAgICAgKF9jID0gKF9iID0gKF9hID0gZXNyaUNvbmZpZyA9PT0gbnVsbCB8fCBlc3JpQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlc3JpQ29uZmlnLmRlZmF1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb3JzRW5hYmxlZFNlcnZlcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wdXNoKGRvbWFpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbn1cbmNvbnN0IGdldFdGU1NlcnZpY2VJbmZvID0gYXN5bmMgKGl0ZW0sIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBbV0ZTTGF5ZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9sYXllcnMvV0ZTTGF5ZXJcIl0pO1xuICAgIGNvbnN0IHsgY3VzdG9tUGFyYW1ldGVycyB9ID0gYWRkSXRlbVN0YXRlO1xuICAgIGNvbnN0IHsgdXJsIH0gPSBpdGVtO1xuICAgIGNvbnN0IHdmc1VybCA9IHN0cmlwUGFyYW1ldGVycyh1cmwsIFtcInZlcnNpb25cIiwgXCJzZXJ2aWNlXCIsIFwicmVxdWVzdFwiLCBcImxheWVyXCIsIFwidHlwZW5hbWVcIl0pO1xuICAgIGNvbnN0IGZvcm1hdHRlZFBhcmFtcyA9IGZvcm1hdEN1c3RvbVBhcmFtZXRlcnMoY3VzdG9tUGFyYW1ldGVycyk7XG4gICAgY29uc3Qgd2ZzVmVyc2lvbiA9IGF3YWl0IGdldFdGU1ZlcnNpb25Gcm9tVXJsKHVybCk7XG4gICAgY29uc3Qgd2ZzTGF5ZXJPcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgIHZlcnNpb246IHdmc1ZlcnNpb24sXG4gICAgICAgIHVybDogd2ZzVXJsLFxuICAgICAgICBjdXN0b21QYXJhbWV0ZXJzOiAoZm9ybWF0dGVkUGFyYW1zID09PSBudWxsIHx8IGZvcm1hdHRlZFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0dGVkUGFyYW1zLmN1c3RvbVBhcmFtZXRlcnMpIHx8IHt9XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICAvLyBWNCBvbmx5IHN1cHBvcnRzIDIuMC4wIHZlcnNpb25cbiAgICAgICAgaWYgKGNvbmZpZ1N0YXRlLmFwaSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKHdmc1ZlcnNpb24gIT09IFwiMi4wLjBcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5zdXBwb3J0ZWRXRlNWZXJzaW9uXCIgfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdjQgdmVyc2lvbiBpcyByZWFkLW9ubHlcbiAgICAgICAgICAgIGRlbGV0ZSB3ZnNMYXllck9wdGlvbnMudmVyc2lvbjtcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBkb24ndCBuZWVkIHRoZSB1cmxcbiAgICAgICAgICAgIGRlbGV0ZSB3ZnNMYXllck9wdGlvbnMudXJsO1xuICAgICAgICAgICAgY29uc3QgW3dmc1V0aWxzXSA9IChhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2xheWVycy9vZ2Mvd2ZzVXRpbHNcIl0pKTtcbiAgICAgICAgICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IGF3YWl0IHdmc1V0aWxzLmdldENhcGFiaWxpdGllcyh3ZnNVcmwsIHdmc0xheWVyT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsYXllcnMgPSBjYXBhYmlsaXRpZXMuZmVhdHVyZVR5cGVzO1xuICAgICAgICAgICAgaWYgKCFsYXllcnMgfHwgIWxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcImVtcHR5RmVhdHVyZUxheWVyXCIgfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJJbmZvID0gYXdhaXQgd2ZzVXRpbHMuZ2V0V0ZTTGF5ZXJJbmZvKGNhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2ZzTGF5ZXIgPSBXRlNMYXllci5mcm9tV0ZTTGF5ZXJJbmZvKGxheWVySW5mbyk7XG4gICAgICAgICAgICAgICAgd2ZzTGF5ZXIubGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICAgICAgICAgIHdmc0xheWVyLnVybCA9IHdmc1VybDtcbiAgICAgICAgICAgICAgICB3ZnNMYXllci5pc0NvbXBsZXggPSB3ZnNMYXllci5nZW9tZXRyeVR5cGUgPT09IFwiZXNyaUdlb21ldHJ5Q29tcGxleFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyB0eXBlOiBcIldGU1wiLCBzZXJ2aWNlSW5mbzogd2ZzTGF5ZXIgfSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0gdjMgLS0tXG4gICAgICAgIGNvbnN0IHdmc0xheWVyID0gbmV3IFdGU0xheWVyKHdmc0xheWVyT3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IGNoZWNrQ09SUyh3ZnNVcmwpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3ZnNMYXllci5pbml0aWFsaXplKHdmc0xheWVyT3B0aW9ucywgKGxheWVycykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXJzIHx8ICFsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7IGNvZGU6IFwiZW1wdHlGZWF0dXJlTGF5ZXJcIiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdmc0xheWVyLmxheWVycyA9IGxheWVycztcbiAgICAgICAgICAgICAgICAgICAgd2ZzTGF5ZXIudXJsID0gd2ZzVXJsO1xuICAgICAgICAgICAgICAgICAgICB3ZnNMYXllci5pc0NvbXBsZXggPSB3ZnNMYXllci5nZW9tZXRyeVR5cGUgPT09IFwiZXNyaUdlb21ldHJ5Q29tcGxleFwiO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgdHlwZTogXCJXRlNcIiwgc2VydmljZUluZm86IHdmc0xheWVyIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFdGUyBsYXllcnMgY2FuIHRocm93IGFuIGVycm9yIGlmIG5vdCB1c2luZyB0aGUgY29ycmVjdCB2ZXJzaW9uIC0gc28gd2UgY2FuIHRyeSB3aXRoIGRpZmZlcmVudCB2ZXJzaW9ucyBmcm9tIG5ld2VzdCB2ZXJzaW9uIHRvIG9sZGVzdFxuICAgICAgICAgICAgd2ZzTGF5ZXIub24oXCJlcnJvclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHdmc0xheWVyLnRvSnNvbigpLnZlcnNpb24gPT09IFwiMi4wLjBcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IGF3YWl0IGdldFdGU1NlcnZpY2VJbmZvKGl0ZW0sIHsgdmVyc2lvbjogXCIxLjEuMFwiLCB1cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdmc0xheWVyLnRvSnNvbigpLnZlcnNpb24gPT09IFwiMS4xLjBcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IGF3YWl0IGdldFdGU1NlcnZpY2VJbmZvKGl0ZW0sIHsgdmVyc2lvbjogXCIxLjAuMFwiLCB1cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoeyBjb2RlOiBcInNlcnZpY2VOb3RFeGlzdFwiIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0IH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICB9XG59O1xuY29uc3QgYWRkV0ZTVXJsID0gYXN5bmMgKGl0ZW0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFpdGVtIHx8ICEoaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtLnNlcnZpY2VJbmZvKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwic2VydmljZU5vdEV4aXN0XCIpKTtcbiAgICB9XG4gICAgY29uc3QgeyBzZXJ2aWNlSW5mbzogd2ZzTGF5ZXIgfSA9IGl0ZW07XG4gICAgY29uc3QgZnVsbEV4dGVudCA9ICgoX2EgPSB3ZnNMYXllci5zZWxlY3RlZExheWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnVsbEV4dGVudCkgfHwgW1tdLCBbXV07XG4gICAgY29uc3Qgc3RyaW5nRXh0ZW50ID0gZXh0ZW50VG9TdHJpbmcoZnVsbEV4dGVudCk7XG4gICAgY29uc3QgYXJyRXh0ZW50ID0gc3RyaW5nRXh0ZW50LnNwbGl0KFwiLFwiKS5tYXAoTnVtYmVyKTtcbiAgICBpZiAoIXdmc0xheWVyLmdlb21ldHJ5VHlwZSB8fCB3ZnNMYXllci5nZW9tZXRyeVR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nR2VvbWV0cnlcIikpO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXR0ZWRJdGVtID0geyB0eXBlOiBpdGVtLnR5cGUsIHVybDogaXRlbS51cmwsIHRodW1ibmFpbFVSTDogaXRlbS50aHVtYm5haWxVUkwgfTtcbiAgICBjb25zdCB3ZnNDb25maWcgPSBhd2FpdCBnZXRXZnNDb25maWcod2ZzTGF5ZXIpO1xuICAgIGNvbnN0IGl0ZW1JbmZvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGVja1RodW1ibmFpbFVSTChmb3JtYXR0ZWRJdGVtKSksIHsgdGV4dDogSlNPTi5zdHJpbmdpZnkod2ZzQ29uZmlnKSwgZXh0ZW50OiBzdHJpbmdFeHRlbnQgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZGRVcmwoaXRlbUluZm8pO1xuICAgIGNvbnN0IHVwZGF0ZWRJdGVtID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW1JbmZvKSwgcmVzcG9uc2UpLCB7IGV4dGVudDogW1xuICAgICAgICAgICAgW2FyckV4dGVudFswXSwgYXJyRXh0ZW50WzFdXSxcbiAgICAgICAgICAgIFthcnJFeHRlbnRbMl0sIGFyckV4dGVudFszXV1cbiAgICAgICAgXSB9KTtcbiAgICAvLyBUT0RPOiB5b3Uga25vdyAtIGxvb2tpbmcgYXQgdGhpcyAtIGkgdGhpbmsgd2UgbmVlZCB0byBhY3R1YWxseSBjYWxsIHVwZGF0ZUl0ZW0gb24gV0ZTIGl0ZW1zIHNpbmNlIGl0IGxvb2tzIGxpa2UgdGhlIHRodW1ibmFpbCB1cmwgaXNuJ3QgYWN0dWFsbHkgYmVpbmcgc2V0IG9uIHRoZSBJdGVtLiBPb3BzIVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRodW1ibmFpbFVybCA9IGF3YWl0IGJ1aWxkVGh1bWJuYWlsVVJMRnJvbVdGU0l0ZW0odXBkYXRlZEl0ZW0uZXh0ZW50KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlZEl0ZW0pLCB7IHRodW1ibmFpbFVybCB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVkSXRlbTtcbiAgICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZ2V0V01UU09wdGlvbnModXJsKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvLyBiZWZvcmUgd2Ugc3RyaXAgcGFyYW1ldGVycyBzZWUgaWYgaXQncyBhIEtWUCBjYXBhYmlsaXRpZXMgVVJMLiBUaGVuIHdlIHVzZSB0aGF0IG9uZSBmaXJzdC5cbiAgICBjb25zdCB1cmxPYmogPSBhd2FpdCB1cmxUb09iamVjdCh1cmwpO1xuICAgIGNvbnN0IHNlcnZpY2VrZXkgPSAoKF9hID0gdXJsT2JqLnF1ZXJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbXCJzZXJ2aWNlXCJdKSB8fCBcIlwiO1xuICAgIGNvbnN0IHJlcXVlc3RLZXkgPSAoKF9iID0gdXJsT2JqLnF1ZXJ5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbXCJyZXF1ZXN0XCJdKSB8fCBcIlwiO1xuICAgIGlmICgoc2VydmljZWtleS50b0xvd2VyQ2FzZSgpID09PSBcIndtdHNcIiAmJiByZXF1ZXN0S2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0Y2FwYWJpbGl0aWVzXCIpIHx8XG4gICAgICAgIHVybC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCIvMS4wLjAvd210c2NhcGFiaWxpdGllcy54bWxcIikgPiAtMSkge1xuICAgICAgICByZXR1cm4geyBzZXJ2aWNlTW9kZTogXCJLVlBcIiB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdNVFNTZXJ2aWNlSW5mbyhpdGVtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgW1dNVFNMYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2xheWVycy9XTVRTTGF5ZXJcIl0pO1xuICAgIGNvbnN0IHsgY3VzdG9tUGFyYW1ldGVycywgdXJsIH0gPSBpdGVtO1xuICAgIGNvbnN0IGZvcm1hdHRlZFBhcmFtcyA9IGZvcm1hdEN1c3RvbVBhcmFtZXRlcnMoY3VzdG9tUGFyYW1ldGVycyk7XG4gICAgY29uc3Qgd210c09wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGN1c3RvbUxheWVyUGFyYW1ldGVyczogKGZvcm1hdHRlZFBhcmFtcyA9PT0gbnVsbCB8fCBmb3JtYXR0ZWRQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHRlZFBhcmFtcy5jdXN0b21MYXllclBhcmFtZXRlcnMpIHx8IHt9LCBjdXN0b21QYXJhbWV0ZXJzOiAoZm9ybWF0dGVkUGFyYW1zID09PSBudWxsIHx8IGZvcm1hdHRlZFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0dGVkUGFyYW1zLmN1c3RvbVBhcmFtZXRlcnMpIHx8IHt9IH0pIHx8XG4gICAgICAgIChhd2FpdCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldFdNVFNPcHRpb25zKHVybCkpLCB7IGN1c3RvbUxheWVyUGFyYW1ldGVyczogKGZvcm1hdHRlZFBhcmFtcyA9PT0gbnVsbCB8fCBmb3JtYXR0ZWRQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHRlZFBhcmFtcy5jdXN0b21MYXllclBhcmFtZXRlcnMpIHx8IHt9LCBjdXN0b21QYXJhbWV0ZXJzOiAoZm9ybWF0dGVkUGFyYW1zID09PSBudWxsIHx8IGZvcm1hdHRlZFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0dGVkUGFyYW1zLmN1c3RvbVBhcmFtZXRlcnMpIHx8IHt9IH0pKTtcbiAgICBjb25zdCB3bXRzVXJsID0gc3RyaXBQYXJhbWV0ZXJzKHVybCwgW1xuICAgICAgICBcInZlcnNpb25cIixcbiAgICAgICAgXCJzZXJ2aWNlXCIsXG4gICAgICAgIFwicmVxdWVzdFwiLFxuICAgICAgICBcImxheWVyXCIsXG4gICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgXCJ0aWxlbWF0cml4c2V0XCIsXG4gICAgICAgIFwidGlsZW1hdHJpeFwiLFxuICAgICAgICBcInRpbGVyb3dcIixcbiAgICAgICAgXCJ0aWxlY29sXCJcbiAgICBdKTtcbiAgICBjb25zdCBuZXdXbXRzVXJsID0gd210c1VybC5yZXBsYWNlKC9cXC8xLjAuMFxcL3dtdHNjYXBhYmlsaXRpZXMueG1sL2ksIFwiXCIpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChjb25maWdTdGF0ZS5hcGkgPT09IDQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdtdHNMYXllciA9IG5ldyBXTVRTTGF5ZXIobmV3V210c1VybCwgd210c09wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgdjRMYXllciA9IHdtdHNMYXllcjtcbiAgICAgICAgICAgIGF3YWl0IHY0TGF5ZXIubG9hZCgpO1xuICAgICAgICAgICAgY29uc3QgbGF5ZXJzID0gdjRMYXllci5zdWJsYXllcnMudG9BcnJheSgpO1xuICAgICAgICAgICAgaWYgKCFsYXllcnMgfHwgIWxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBgc2VydmljZU5vdEV4aXN0YCB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3bXRzTGF5ZXIubGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyB0eXBlOiBcIldNVFNcIiwgc2VydmljZUluZm86IHdtdHNMYXllciB9KSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLSB2MyAtLS1cbiAgICAgICAgYXdhaXQgY2hlY2tDT1JTKHdtdHNVcmwpO1xuICAgICAgICBjb25zdCB3bXRzTGF5ZXIgPSBuZXcgV01UU0xheWVyKG5ld1dtdHNVcmwsIHdtdHNPcHRpb25zKTtcbiAgICAgICAgbGV0IGxheWVycztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgd210c0xheWVyLm9uKFwibG9hZFwiLCAoeyBsYXllcjogd210c0luZm8gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGxheWVycyA9IHdtdHNJbmZvLmxheWVycztcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVycyB8fCAhbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBzZXJ2aWNlTm90RXhpc3RgKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3bXRzTGF5ZXIubGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgdHlwZTogXCJXTVRTXCIsIHNlcnZpY2VJbmZvOiB3bXRzTGF5ZXIgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd210c0xheWVyLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoIXdtdHNPcHRpb25zLnNlcnZpY2VNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFdNVFNTZXJ2aWNlSW5mbyhpdGVtLCB7IHNlcnZpY2VNb2RlOiBcIktWUFwiIH0pLnRoZW4oKHsgcmVzdWx0LCBlcnJvciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBlcnIuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSA9PT0gXCJUaGUgV01UUyBjYXBhYmlsaXRpZXMgWE1MIGlzIG5vdCB2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoeyBjb2RlOiBcImludmFsaWRXTVRTXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHsgY29kZTogXCJzZXJ2aWNlTm90RXhpc3RcIiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYWRkV01UU1VybChpdGVtKSB7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcInNlcnZpY2VOb3RFeGlzdFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBzZXJ2aWNlSW5mbzogd210c0xheWVyLCBzZWxlY3RlZExheWVyLCBzZWxlY3RlZFRpbGVJbmZvIH0gPSBpdGVtO1xuICAgIGlmICghc2VsZWN0ZWRMYXllcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibGF5ZXJOb3RTZWxlY3RlZFwiKSk7XG4gICAgfVxuICAgIGlmICghc2VsZWN0ZWRUaWxlSW5mbykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZ0dlb21ldHJ5XCIpKTtcbiAgICB9XG4gICAgd210c0xheWVyLnNlbGVjdGVkVGlsZUluZm8gPSBzZWxlY3RlZFRpbGVJbmZvO1xuICAgIGNvbnN0IHsgd210c0NvbmZpZywgZnVsbEV4dGVudDogY29uZmlnRXh0ZW50IH0gPSBhd2FpdCBnZXRXTVRTQ29uZmlnKHdtdHNMYXllcikuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIFdNVFMgY29uZmlnXCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgY29uc3QgZ2NzRXh0ZW50ID0gd210c0xheWVyLnNlbGVjdGVkTGF5ZXJbY29uZmlnU3RhdGUuYXBpID09PSA0ID8gXCJmdWxsRXh0ZW50XCIgOiBcImdjc0V4dGVudFwiXTtcbiAgICBjb25zdCBmdWxsRXh0ZW50ID0gY29uZmlnRXh0ZW50ID8gZ2NzRXh0ZW50IDogeyB4bWluOiAtMTgwLCB5bWluOiAtOTAsIHhtYXg6IDE4MCwgeW1heDogOTAgfTtcbiAgICBjb25zdCBmb3JtYXR0ZWRJdGVtID0geyB0eXBlOiBpdGVtLnR5cGUsIHVybDogaXRlbS51cmwsIHRodW1ibmFpbFVSTDogaXRlbS50aHVtYm5haWxVUkwgfTtcbiAgICBjb25zdCBpdGVtSW5mbyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hlY2tUaHVtYm5haWxVUkwoZm9ybWF0dGVkSXRlbSkpLCB7IHVybDogd210c0NvbmZpZy53bXRzSW5mby51cmwsIHRleHQ6IEpTT04uc3RyaW5naWZ5KHdtdHNDb25maWcpLCBleHRlbnQ6IGAke2Z1bGxFeHRlbnQueG1pbn0sJHtmdWxsRXh0ZW50LnltaW59LCR7ZnVsbEV4dGVudC54bWF4fSwke2Z1bGxFeHRlbnQueW1heH1gIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWRkVXJsKGl0ZW1JbmZvKTtcbiAgICBjb25zdCB1cGRhdGVkSXRlbSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtSW5mbyksIHJlc3BvbnNlKSwgeyBleHRlbnQ6IFtcbiAgICAgICAgICAgIFtmdWxsRXh0ZW50LnhtaW4sIGZ1bGxFeHRlbnQueW1pbl0sXG4gICAgICAgICAgICBbZnVsbEV4dGVudC54bWF4LCBmdWxsRXh0ZW50LnltYXhdXG4gICAgICAgIF0gfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGh1bWJuYWlsRGF0YSA9IGF3YWl0IGJ1aWxkVGh1bWJuYWlsVVJMRnJvbVdNVFNJdGVtKHVwZGF0ZWRJdGVtKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdERhdGEgPSBjb25maWdTdGF0ZS5hcGkgPT09IDQgPyB7IHR5cGU6IFwiYmFzZTY0XCIsIGRhdGE6IHRodW1ibmFpbERhdGEgfSA6IHsgdHlwZTogXCJ1cmxcIiwgdXJsOiB0aHVtYm5haWxEYXRhIH07XG4gICAgICAgIGNvbnN0IGl0ZW1XaXRoVGh1bWJuYWlsID0gYXdhaXQgYWRkVGh1bWJuYWlsVG9JdGVtKHJlc3BvbnNlLmlkLCByZXF1ZXN0RGF0YSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVwZGF0ZWRJdGVtKSwgaXRlbVdpdGhUaHVtYm5haWwpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoZW4gYWRkaW5nIFdNVFMgVVJMOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB1cGRhdGVkSXRlbTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRPR0NGZWF0dXJlTGF5ZXJTZXJ2aWNlSW5mbyhpdGVtKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHsgdXJsIH0gPSBpdGVtO1xuICAgIC8qKiB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIGZyb20gdGhlIE1hcFZpZXdlciAgLSBpdCB3aWxsIGdldCB0aGUgbGFuZGluZyBwYWdlIGluIHRoZSBmb3JtIG9mIFwiYXBwbGljYXRpb24vanNvbiAtIGFuZCB0aGVuIGdldCB0aGUgY29sbGVjdGlvbiBmcm9tIGl0LiAqL1xuICAgIC8vICAgLy8gQCA5LjMgV2lsbCBuZWVkIHRvIHNldCB0aGUgdHJ1c3RlZFNlcnZlciBzdHVmZiBiZWZvcmUgdGhpcyBjYWxsXG4gICAgLy8gICAvLyBpbiBjYXNlIHRoZSBzZXJ2aWNlIG5lZWRzIGNyZWRlbnRpYWxzXG4gICAgY29uc3QgbGFuZGluZ1BhZ2VPcHRpb25zID0geyBhZGRUb2tlbk1hbnVhbGx5OiBmYWxzZSwgaGVhZGVyczogeyBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0gfTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBnZXREYXRhV2l0aEpTT05SZXRyeSA9IGFzeW5jIChmdW5jLCBmYWlsQ2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZnVuYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IChfYyA9IChfYiA9IChfYSA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5pbmNsdWRlcyhcInVuZXhwZWN0ZWQgdG9rZW5cIikgfHwgbWVzc2FnZS5pbmNsdWRlcyhcImV4cGVjdGVkIGV4cHJlc3Npb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWxDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyByZXN1bHQ6IG51bGwsIGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiwgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpIH0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxhbmRpbmdQYWdlID0gYXdhaXQgZ2V0RGF0YVdpdGhKU09OUmV0cnkoKCkgPT4gcmVxdWVzdCh1cmwsIHt9LCBsYW5kaW5nUGFnZU9wdGlvbnMsIFwiYXV0b1wiLCB7IGV4Y2x1ZGVKc29uOiB0cnVlIH0pLCAoKSA9PiByZXF1ZXN0KHVybCwge30sIGxhbmRpbmdQYWdlT3B0aW9ucykpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlSW5mbyA9IGF3YWl0IGdldERhdGFXaXRoSlNPTlJldHJ5KCgpID0+IGdldFNlcnZlckNvbGxlY3Rpb25zKGxhbmRpbmdQYWdlKSwgKCkgPT4gZ2V0U2VydmVyQ29sbGVjdGlvbnMobGFuZGluZ1BhZ2UsIHt9LCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IGV4dGVudDogZXh0ZW50VG9TdHJpbmcoKF9kID0gKF9jID0gKF9iID0gKF9hID0gc2VydmljZUluZm8uY29sbGVjdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV4dGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNwYXRpYWwpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5iYm94KSwgdHlwZTogXCJPR0NGZWF0dXJlU2VydmVyXCIsIHNlcnZpY2VJbmZvLCBsYXllcnM6IHNlcnZpY2VJbmZvLmNvbGxlY3Rpb25zIH0pLFxuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJnZXQgT0dDIGZlYXR1cmUgbGF5ZXI6XCIsIGVycm9yKTtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIGVycm9yIHRyYW5zZm9ybWF0aW9uIGhlcmVcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBudWxsLCBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKSB9IH07XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0T0dDRmVhdHVyZUxheWVyKHNlbGVjdGVkTGF5ZXIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghc2VsZWN0ZWRMYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgdGl0bGUsIGRlc2NyaXB0aW9uIH0gPSBzZWxlY3RlZExheWVyO1xuICAgIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGl0bGUgPSAoX2EgPSB0aXRsZSAhPT0gbnVsbCAmJiB0aXRsZSAhPT0gdm9pZCAwID8gdGl0bGUgOiBpdGVtUHJvcGVydGllc1N0YXRlLnRpdGxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuc25pcHBldCA9IChfYiA9IGRlc2NyaXB0aW9uICE9PSBudWxsICYmIGRlc2NyaXB0aW9uICE9PSB2b2lkIDAgPyBkZXNjcmlwdGlvbiA6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuc25pcHBldCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICBhZGRJdGVtU3RhdGUuc2VsZWN0ZWRMYXllciA9IHNlbGVjdGVkTGF5ZXI7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTZXJ2ZXJDb2xsZWN0aW9ucyhsYW5kaW5nUGFnZSwgb3B0aW9ucyA9IHt9LCBleGNsdWRlSnNvbiA9IHRydWUpIHtcbiAgICBjb25zdCB7IGxpbmtzIH0gPSBsYW5kaW5nUGFnZTtcbiAgICBjb25zdCBsaW5rID0gZ2V0TGluayhsaW5rcywgXCJkYXRhXCIsIFwiYXBwbGljYXRpb24vanNvblwiKSB8fFxuICAgICAgICBnZXRMaW5rKGxpbmtzLCBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL3JlbC9vZ2MvMS4wL2RhdGFcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgIGlmIChpc05vbmUobGluaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBjb2xsZWN0aW9ucyB1cmxcIik7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdTdGF0ZS5hcGkgPT09IDNcbiAgICAgICAgPyByZXF1ZXN0KGFkZFBhcmFtZXRlcnMobGluay5ocmVmKSwge30sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgYWRkVG9rZW5NYW51YWxseTogZmFsc2UgfSksIFwiYXV0b1wiLCB7XG4gICAgICAgICAgICB2M1JlcXVlc3Q6IHsgaGVhZGVyczogeyBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0gfSxcbiAgICAgICAgICAgIGV4Y2x1ZGVKc29uXG4gICAgICAgIH0pXG4gICAgICAgIDogcmVxdWVzdChhZGRQYXJhbWV0ZXJzKGxpbmsuaHJlZiksIHt9LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGFkZFRva2VuTWFudWFsbHk6IGZhbHNlLCBoZWFkZXJzOiB7IGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSB9KSwgXCJhdXRvXCIsIHtcbiAgICAgICAgICAgIGV4Y2x1ZGVKc29uXG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0TGluayhsaW5rcywgcmVsYXRpb24sIHR5cGUpIHtcbiAgICByZXR1cm4gKGxpbmtzLmZpbmQoKGxpbmspID0+IGxpbmsucmVsID09PSByZWxhdGlvbiAmJiBsaW5rLnR5cGUgPT09IHR5cGUpIHx8XG4gICAgICAgIGxpbmtzLmZpbmQoKGxpbmspID0+IGxpbmsucmVsID09PSByZWxhdGlvbiAmJiAhbGluay50eXBlKSk7XG59XG5hc3luYyBmdW5jdGlvbiBhZGRPR0NGZWF0dXJlU2VydmljZShpdGVtKSB7XG4gICAgY29uc3QgeyBzZXJ2aWNlSW5mbywgY3VzdG9tUGFyYW1ldGVycyB9ID0gaXRlbTtcbiAgICBpZiAoIXNlcnZpY2VJbmZvKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzZXJ2aWNlTm90RXhpc3RcIikpO1xuICAgIH1cbiAgICAvLyBUaGlzIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIGhvdyBtZXRhZGF0YSBuZWVkcyB0byBiZSBmb3JtYXR0ZWQuXG4gICAgaWYgKGN1c3RvbVBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpdGVtLnRleHQgPSBKU09OLnN0cmluZ2lmeSh7IGN1c3RvbVBhcmFtZXRlcnM6IGZvcm1hdEN1c3RvbVBhcmFtZXRlcnMoY3VzdG9tUGFyYW1ldGVycykuY3VzdG9tUGFyYW1ldGVycyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZFVybChpdGVtKTtcbn1cblxuLy8gZnVuY3Rpb24gdG8gbmF2aWdhdGUgdG8gdGhlIGNvcnJlY3QgXCJhZGRJdGVtXCIgcmVxdWVzdHNcbmNvbnN0IGFkZEl0ZW0gPSAoaXRlbSwgcmVzdEJhc2VVcmwpID0+IHtcbiAgICBjb25zdCB7IG5ld0l0ZW1Nb2RlLCB0eXBlS2V5d29yZHMsIHRhZ3MsIGV4dGVudCwgc2VsZWN0ZWRTZXJ2aWNlSW5mb0xheWVyc05hbWVzLCBhZGRGZWF0dXJlTGF5ZXJUeXBlIH0gPSBhZGRJdGVtU3RhdGU7XG4gICAgY29uc3QgdGl0bGUgPSBpdGVtUHJvcGVydGllc1N0YXRlLnRpdGxlO1xuICAgIGlmICgodGl0bGUgPT09IG51bGwgfHwgdGl0bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpdGxlLmxlbmd0aCkgPiAyNTApIHtcbiAgICAgICAgaXRlbVByb3BlcnRpZXNTdGF0ZS50aXRsZSA9IHRpdGxlLnN1YnN0cmluZygwLCAyNTApO1xuICAgIH1cbiAgICBzd2l0Y2ggKG5ld0l0ZW1Nb2RlKSB7XG4gICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIGFkZEFwcGxpY2F0aW9uKGl0ZW0sIHJlc3RCYXNlVXJsKTtcbiAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgICAgIC8vIFRPRE86IFBhc3MgaW4gaXRlbSBwcm9wZXJ0aWVzL2l0ZW0gcmVxdWVzdCBoZXJlIGluc3RlYWQgb2YgZ3JhYmJpbmcgZnJvbSB0aGUgc3RvcmUgYWdhaW5cbiAgICAgICAgICAgIHJldHVybiBhZGRGaWxlKCk7XG4gICAgICAgIGNhc2UgXCJ1cmxcIjpcbiAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoZSBwYXNzZWQgY29uZmlnU3RhdGUgb3V0IG9mIHRoaXNcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVBZGRVcmwoaXRlbSwgY29uZmlnU3RhdGUuY29uZmlnLCBjb25maWdTdGF0ZS5hcGkpO1xuICAgICAgICBjYXNlIFwiZmVhdHVyZUxheWVyXCI6XG4gICAgICAgICAgICByZXR1cm4gYWRkRmVhdHVyZUxheWVyKHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlSW5mbzogaXRlbS5zZXJ2aWNlSW5mbyxcbiAgICAgICAgICAgICAgICB0eXBlS2V5d29yZHMsXG4gICAgICAgICAgICAgICAgdGFncyxcbiAgICAgICAgICAgICAgICBleHRlbnQsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRTZXJ2aWNlSW5mb0xheWVyc05hbWVzLFxuICAgICAgICAgICAgICAgIGFkZEZlYXR1cmVMYXllclR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHNlbmRBZGRJdGVtUmVxdWVzdChPYmplY3QuYXNzaWduKHt9LCBpdGVtKSk7XG4gICAgfVxufTtcbmNvbnN0IHVwbG9hZEZpbGUgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWRkSXRlbVJlcXVlc3QgPSBhZGRJdGVtUmVxdWVzdFN0YXRlOyAvLyB7IC4uLmFkZEl0ZW1TdG9yZS5zdGF0ZSB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IChhd2FpdCBhZGRJdGVtKGFkZEl0ZW1SZXF1ZXN0LCBcIlwiKSk7XG4gICAgICAgIGFkZEl0ZW1TdGF0ZS5pZCA9IHJlc3BvbnNlLmlkO1xuICAgICAgICBjb25zdCBqb2JTdGF0dXMgPSBhd2FpdCBnZXRJdGVtU3RhdHVzKGFkZEl0ZW1TdGF0ZS5pZCwgeyBzdWNjZXNzOiByZXNwb25zZS5zdWNjZXNzIH0pO1xuICAgICAgICBpZiAoam9iU3RhdHVzLnN0YXR1cyA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgam9iU3RhdHVzLnN0YXR1c01lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3Iuc3RhdHVzTWVzc2FnZSkgfHwgZXJyb3IgfHwgXCJcIjtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcIkludmFsaWQgRmlsZSBHZW9kYXRhYmFzZVwiKTpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcImludmFsaWRGaWxlR2VvZGF0YWJhc2VcIiB9IH07XG4gICAgICAgICAgICBjYXNlIGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcIkludmFsaWQgU2hhcGVmaWxlXCIpOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwiaW52YWxpZFNoYXBlZmlsZVwiIH0gfTtcbiAgICAgICAgICAgIGNhc2UgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiVGhlIHJlcXVlc3Qgc2l6ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heCBhbGxvd2VkIG9mIDEwMjRNQlwiKTpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcImV4Y2VlZHNGaWxlU2l6ZVwiIH0gfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBhZGRGaWxlID0gYXN5bmMgKHByb3BzKSA9PiB7XG4gICAgY29uc3QgZmlsZSA9IGFkZEl0ZW1TdGF0ZS5maWxlO1xuICAgIGNvbnN0IGRhdGFVcmwgPSBhZGRJdGVtU3RhdGUuZGF0YVVybDtcbiAgICBpZiAoIWZpbGUgJiYgZGF0YVVybCkge1xuICAgICAgICByZXR1cm4gYWRkRmlsZUZyb21EYXRhVXJsKHByb3BzKTtcbiAgICB9XG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgRUNEIHdvcmthcm91bmQgd2hlbiBiYWNrZW5kIGZpeGVzIGZpbGVuYW1lIGNyZWF0aW9uIChXZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAjNDEwNjgpXG4gICAgaWYgKChmaWxlID09PSBudWxsIHx8IGZpbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGUuc2l6ZSkgPiBNVUxUSV9QQVJUX1VQTE9BRF9NSU5JTVVNX1NJWkUgfHwgYWRkSXRlbVN0YXRlLnR5cGUgPT09IFwiRXNyaSBDbGFzc2lmaWVyIERlZmluaXRpb25cIikge1xuICAgICAgICByZXR1cm4gYWRkRmlsZU11bHRpUGFydCgpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkRmlsZVNpbmdsZSgpO1xufTtcbmNvbnN0IGFkZEZpbGVGcm9tRGF0YVVybCA9IGFzeW5jIChwcm9wcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB1cmwgPSBnZXRBZGRJdGVtVXJsKGNvbmZpZ1N0YXRlLnVzZXIsIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuZm9sZGVyKTtcbiAgICBjb25zdCB7IGZpbGVOYW1lLCBkYXRhVXJsLCBleHRlbnNpb24gfSA9IGFkZEl0ZW1TdGF0ZTtcbiAgICBjb25zdCBhZGRJdGVtUGFyYW1zID0gZ2V0QWRkSXRlbVBhcmFtZXRlcnMoaXRlbVByb3BlcnRpZXNTdGF0ZSwgYWRkSXRlbVN0YXRlKTtcbiAgICBjb25zdCBvdmVyd3JpdGUgPSAhIWFkZEl0ZW1TdGF0ZS5vdmVyd3JpdGU7IC8vY291bGQgYmUgdW5kZWZpbmVkXG4gICAgLy8gaW4gdGhlIGNhc2Ugd2hlcmUgd2UncmUgYWRkaW5nIGdlb2pzb24gZnJvbSBhIHVybCByZWZlcmVuY2luZyBhIGZlYXR1cmUgc2VydmljZSxcbiAgICAvLyBtYWtlIGEgdW5pcXVlIGZpbGUgbmFtZSBzbyB0aGF0IHRoZSBmaWxlIGlzbid0IHRoZSBxdWVyeSBXZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAjNDI0MDNcbiAgICBjb25zdCBpc0dlb0pTT05Gcm9tRmVhdHVyZVNlcnZlciA9IChkYXRhVXJsID09PSBudWxsIHx8IGRhdGFVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFVcmwuaW5jbHVkZXMoXCIvcXVlcnk/XCIpKSAmJiAoZmlsZU5hbWUgPT09IG51bGwgfHwgZmlsZU5hbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGVOYW1lLmluY2x1ZGVzKFwicXVlcnlcIikpICYmIChleHRlbnNpb24gPT09IG51bGwgfHwgZXh0ZW5zaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnNpb24uaW5jbHVkZXMoXCJqc29uXCIpKTtcbiAgICBjb25zdCBnZW9qc29uUHJvcGVydGllcyA9IGlzR2VvSlNPTkZyb21GZWF0dXJlU2VydmVyXG4gICAgICAgID8ge1xuICAgICAgICAgICAgZmlsZW5hbWU6IGd1aWQoKSxcbiAgICAgICAgICAgIGRhdGFVcmxcbiAgICAgICAgfVxuICAgICAgICA6IHt9O1xuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhZGRJdGVtUGFyYW1zKSwgeyBhc3luYzogdHJ1ZSwgZmlsZW5hbWU6IChfYSA9IHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5maWxlbmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlsZU5hbWUsIHRpdGxlOiBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMudGl0bGUsIG92ZXJ3cml0ZSB9KSwgZ2VvanNvblByb3BlcnRpZXMpO1xuICAgIHJldHVybiByZXF1ZXN0KHVybCwgcGFyYW1zLCB7fSwgXCJwb3N0XCIpO1xufTtcbmFzeW5jIGZ1bmN0aW9uIGFkZEZpbGVTaW5nbGUoKSB7XG4gICAgY29uc3QgdXJsID0gZ2V0QWRkSXRlbVVybChjb25maWdTdGF0ZS51c2VyLCBpdGVtUHJvcGVydGllc1N0YXRlLmZvbGRlcik7XG4gICAgY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0oaXRlbVByb3BlcnRpZXNTdGF0ZSwgYWRkSXRlbVN0YXRlKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZm9ybVJlcXVlc3QodXJsLCBmb3JtLCB7fSwgXCJwb3N0XCIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSB8fCBlcnJvcjtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBhZGRQYXJ0KHBhcnQsIGl0ZW1JZCwgYXR0ZW1wdHMgPSAwKSB7XG4gICAgY29uc3QgdXNlciA9IGNvbmZpZ1N0YXRlLnVzZXI7XG4gICAgLy8gS2VlcCBhdHRlbXB0aW5nIHRvIGFkZCB0aGUgcGFydCwgb25seSB0aHJvd2luZyBhbiBlcnJvciBhZnRlciBtdWx0aXBsZSByZXRyaWVzXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBwYXJ0RGF0YSwgZm9ybURhdGEgfSA9IHBhcnQ7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBgP3N0cmVhbWRhdGE9dHJ1ZSZzaXplPSR7cGFydERhdGEuc2l6ZX0mcGFydE51bT0ke3BhcnREYXRhLnBhcnROdW19JmY9anNvbmA7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3VzZXIudXNlckNvbnRlbnRVcmx9L2l0ZW1zLyR7aXRlbUlkfS9hZGRQYXJ0JHtwYXJhbWV0ZXJzfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZm9ybVJlcXVlc3QodXJsLCBmb3JtRGF0YSwge1xuICAgICAgICAgICAgXCJYLUVzcmktQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7Z2V0VG9rZW4oY29uZmlnU3RhdGUucG9ydGFsKX1gXG4gICAgICAgIH0sIFwicG9zdFwiKTtcbiAgICAgICAgcmV0dXJuIHsgcmVzcG9uc2UsIGF0dGVtcHRzLCBwYXJ0U2l6ZTogcGFydERhdGEuc2l6ZSB9O1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgaWYgKCFhZGRJdGVtU3RhdGUuaWQpIHtcbiAgICAgICAgICAgIHRocm93IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ZW1wdHMrKztcbiAgICAgICAgaWYgKGF0dGVtcHRzID4gTVVMVElfUEFSVF9VUExPQURfUkVUUklFUykge1xuICAgICAgICAgICAgLy8gVE9ETzogVXBkYXRlIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVwbG9hZCBmYWlsZWQgLSB0b28gbWFueSBhdHRlbXB0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRQYXJ0KHBhcnQsIGl0ZW1JZCwgYXR0ZW1wdHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24qIGdlbmVyYXRlUGFydCgpIHtcbiAgICBjb25zdCBmaWxlID0gYWRkSXRlbVN0YXRlLmZpbGU7XG4gICAgY29uc3QgeyBuYW1lLCBzaXplIH0gPSBmaWxlO1xuICAgIGxldCBwYXJ0U2l6ZSA9IE1VTFRJX1BBUlRfVVBMT0FEX0JBVENIX1NJWkU7XG4gICAgbGV0IHRvdGFsUGFydHMgPSBNYXRoLmNlaWwoc2l6ZSAvIHBhcnRTaXplKTtcbiAgICBsZXQgcGFydCA9IDA7XG4gICAgLy8gTWF4IG51bWJlciBvZiBwYXJ0cyBpcyAxMCwwMDAsIHNvIHdlIGluY3JlYXNlIHRoZSBjaHVuayBzaXplIGlmIHRoZSBmaWxlIGlzIGJpZ2dlciB0aGFuIHRoZSB0aHJlc2hvbGRcbiAgICBpZiAodG90YWxQYXJ0cyA+IE1VTFRJX1BBUlRfVVBMT0FEX01BWF9QQVJUUykge1xuICAgICAgICBwYXJ0U2l6ZSA9IE1hdGguY2VpbChzaXplIC8gTVVMVElfUEFSVF9VUExPQURfTUFYX1BBUlRTKTtcbiAgICAgICAgdG90YWxQYXJ0cyA9IE1hdGguY2VpbChzaXplIC8gcGFydFNpemUpO1xuICAgIH1cbiAgICB3aGlsZSAocGFydCA8IHRvdGFsUGFydHMpIHtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFydCAqIHBhcnRTaXplO1xuICAgICAgICBjb25zdCBibG9iID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIHBhcnRTaXplKTtcbiAgICAgICAgcGFydCsrO1xuICAgICAgICBjb25zdCBwYXJ0RGF0YSA9IHtcbiAgICAgICAgICAgIHBhcnROdW06IHBhcnQsXG4gICAgICAgICAgICBzaXplOiBibG9iLnNpemVcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwicGFydE51bVwiLCBTdHJpbmcocGFydERhdGEucGFydE51bSkpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJzdHJlYW1kYXRhXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZlwiLCBcImpzb25cIik7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcInRva2VuXCIsIGdldFRva2VuKGNvbmZpZ1N0YXRlLnBvcnRhbCkpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGJsb2IsIG5hbWUpO1xuICAgICAgICB5aWVsZCB7IHBhcnREYXRhLCBmb3JtRGF0YSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGFkZEZpbGVNdWx0aVBhcnQgPSBhc3luYyAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGxldCBkb1VwbG9hZCA9IHRydWU7XG4gICAgY29uc3QgY2FuY2VsVXBsb2FkID0gKCkgPT4ge1xuICAgICAgICBpZiAoYWRkSXRlbVN0YXRlLmlkKSB7XG4gICAgICAgICAgICBkb1VwbG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgaXRlbUlkID0gYWRkSXRlbVN0YXRlLmlkO1xuICAgICAgICAgICAgYWRkSXRlbVN0YXRlLmlkID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjYW5jZWxJdGVtKGl0ZW1JZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG11bHRpUGFydFN1YnNjcmliZXIgPSBzdWJzY3JpcHRpb25TdGF0ZS5hZGRTdWJzY3JpYmVyKFwiYWRkRmlsZU11bHRpUGFydFwiLCBjYW5jZWxVcGxvYWQpO1xuICAgIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ1N0YXRlLmNvbmZpZztcbiAgICBjb25zdCB1cmwgPSBnZXRBZGRJdGVtVXJsKGNvbmZpZ1N0YXRlLnVzZXIsIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuZm9sZGVyKTtcbiAgICBjb25zdCB7IGZpbGVOYW1lLCBmaWxlIH0gPSBhZGRJdGVtU3RhdGU7XG4gICAgbGV0IHBhcnRzUGVyQmF0Y2ggPSAoX2EgPSBjb25maWcubXVsdGlQYXJ0QmF0Y2hTaXplKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBNVUxUSV9QQVJUX1VQTE9BRF9JTklUSUFMX0JBVENIX1NJWkU7XG4gICAgbGV0IG51bUNvbnNlY3V0aXZlU3VjY2VzcyA9IDA7XG4gICAgbGV0IGl0ZW1JZDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpdGVtUmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KHVybCwgeyBtdWx0aXBhcnQ6IHRydWUsIGZpbGVOYW1lLCBhc3luYzogdHJ1ZSB9LCB7fSwgXCJwb3N0XCIpO1xuICAgICAgICBpdGVtSWQgPSAoX2IgPSBpdGVtUmVzcG9uc2UuaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGl0ZW1SZXNwb25zZS5pdGVtSWQ7XG4gICAgICAgIGFkZEl0ZW1TdGF0ZS5pZCA9IGl0ZW1JZDtcbiAgICAgICAgLy8gVE9ETzogRmFjdG9yIHVwbG9hZFByb2dyZXNzIG91dCBvZiBhZGRJdGVtU3RhdGVcbiAgICAgICAgYWRkSXRlbVN0YXRlLnVwbG9hZFByb2dyZXNzID0gMDtcbiAgICAgICAgd29ya2Zsb3dTdGF0ZS51cGxvYWRQcm9ncmVzcyA9IDA7XG4gICAgICAgIGxldCBieXRlc1VwbG9hZGVkID0gMDtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBkeW5hbWljIGJhdGNoIGdlbmVyYXRvclxuICAgICAgICBjb25zdCBwYXJ0R2VuZXJhdG9yID0gZ2VuZXJhdGVQYXJ0KCk7XG4gICAgICAgIGF3YWl0IHN0cmVhbVByb21pc2VzKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IHBhcnRHZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUgPyBudWxsIDogYWRkUGFydCh2YWx1ZSwgaXRlbUlkKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZ2V0QmF0Y2hTaXplOiAoKSA9PiBwYXJ0c1BlckJhdGNoLFxuICAgICAgICAgICAgb25Qcm9taXNlQ29tcGxldGVkOiAoYWRkUGFydFJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXR0ZW1wdHMsIHBhcnRTaXplIH0gPSBhZGRQYXJ0UmVzdWx0O1xuICAgICAgICAgICAgICAgIC8vIElmIGEgcGFydCBvbmx5IHN1Y2NlZWRlZCBhZnRlciBvbmUgb3IgbW9yZSBmYWlsdXJlcy9yZXRyaWVzLCBmbGFnIHRoZSBiYXRjaCB0byBiZSByZWR1Y2VkIG5leHQgdGltZVxuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHNQZXJCYXRjaCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChwYXJ0c1BlckJhdGNoIC8gMikpO1xuICAgICAgICAgICAgICAgICAgICBudW1Db25zZWN1dGl2ZVN1Y2Nlc3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtQ29uc2VjdXRpdmVTdWNjZXNzKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1Db25zZWN1dGl2ZVN1Y2Nlc3MgPj0gcGFydHNQZXJCYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNQZXJCYXRjaCA9IE1hdGgubWluKHBhcnRzUGVyQmF0Y2ggKyAxLCBNVUxUSV9QQVJUX1VQTE9BRF9NQVhfQkFUQ0hfU0laRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1Db25zZWN1dGl2ZVN1Y2Nlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ5dGVzVXBsb2FkZWQgKz0gcGFydFNpemU7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLmZsb29yKChieXRlc1VwbG9hZGVkIC8gZmlsZS5zaXplKSAqIDEwMCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRmFjdG9yIHVwbG9hZFByb2dyZXNzIG91dCBvZiBhZGRJdGVtU3RhdGVcbiAgICAgICAgICAgICAgICBhZGRJdGVtU3RhdGUudXBsb2FkUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICB3b3JrZmxvd1N0YXRlLnVwbG9hZFByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Qcm9taXNlVGhyb3coKSB7XG4gICAgICAgICAgICAgICAgZG9VcGxvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG91bGRDb250aW51ZTogKCkgPT4gZG9VcGxvYWQgJiYgc3Vic2NyaXB0aW9uU3RhdGUuaXNTdWJzY3JpYmVyVmFsaWQobXVsdGlQYXJ0U3Vic2NyaWJlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YnNjcmlwdGlvblN0YXRlLnJlbW92ZVN1YnNjcmliZXIobXVsdGlQYXJ0U3Vic2NyaWJlcik7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZXh0ZW5zaW9uLCBlbmFibGVQdWJsaXNoaW5nLCBwcm9wZXJ0aWVzIH0gPSBhZGRJdGVtU3RhdGU7XG4gICAgICAgIHJldHVybiBhd2FpdCBjb21taXRJdGVtKGl0ZW1JZCwge1xuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICBlbmFibGVQdWJsaXNoaW5nLFxuICAgICAgICAgICAgcHJvcGVydGllc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIGFuIGl0ZW0gd2FzIHBhcnRpYWxseSB1cGxvYWRlZCwgY2FuY2VsIGl0IGJlZm9yZSB0aHJvd2luZyBlcnJvclxuICAgICAgICBhd2FpdCBjYW5jZWxVcGxvYWQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcigoX2MgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZXJyb3IpO1xuICAgICAgICB0aHJvdyAoX2QgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZXJyb3I7XG4gICAgfVxufTtcbi8vIC0tLSBVUkxcbmNvbnN0IGhhbmRsZUFkZFVybCA9IChpdGVtLCBjb25maWcsIGFwaSkgPT4ge1xuICAgIGlmIChpdGVtLmFnc1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFNlY3VyZUFHU1VybChpdGVtKTtcbiAgICB9XG4gICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIktNTFwiOlxuICAgICAgICAgICAgcmV0dXJuIGFkZEtNTFVybChpdGVtLCBjb25maWcsIGFwaSk7XG4gICAgICAgIGNhc2UgXCJXTVNcIjpcbiAgICAgICAgICAgIHJldHVybiBhZGRXTVNVcmwoaXRlbSk7XG4gICAgICAgIGNhc2UgXCJXRlNcIjpcbiAgICAgICAgICAgIHJldHVybiBhZGRXRlNVcmwoaXRlbSk7XG4gICAgICAgIGNhc2UgXCJXTVRTXCI6XG4gICAgICAgICAgICByZXR1cm4gYWRkV01UU1VybChpdGVtKTtcbiAgICAgICAgY2FzZSBcIk9HQ0ZlYXR1cmVTZXJ2ZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBhZGRPR0NGZWF0dXJlU2VydmljZShpdGVtKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBhZGRVcmwoaXRlbSk7XG4gICAgfVxufTtcbmNvbnN0IGdldFR5cGVLZXl3b3JkcyA9IChpdGVtKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgdHlwZSwgYWdzVHlwZSB9ID0gaXRlbTtcbiAgICBjb25zdCBnZW5lcmF0ZWRUeXBlcyA9ICgoX2EgPSBhZGRDcmVhdGVJdGVtVHlwZXNbYWdzVHlwZSAhPT0gbnVsbCAmJiBhZ3NUeXBlICE9PSB2b2lkIDAgPyBhZ3NUeXBlIDogdHlwZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlS2V5d29yZHMpIHx8IFtdO1xuICAgIHJldHVybiBbLi4uZ2VuZXJhdGVkVHlwZXMsIC4uLihpdGVtLnR5cGVLZXl3b3JkcyB8fCBbXSldO1xufTtcbmNvbnN0IGFkZFVybCA9IGFzeW5jIChpdGVtKSA9PiB7XG4gICAgY29uc3QgeyBjdXN0b21QYXJhbWV0ZXJzOiBjdXN0b21QYXJhbXMsIGFnc1R5cGUgfSA9IGl0ZW07XG4gICAgY29uc3QgeyB0eXBlIH0gPSBnZXRJdGVtSW5mb0J5VHlwZShpdGVtLnR5cGUpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IHR5cGVLZXl3b3JkczogZ2V0VHlwZUtleXdvcmRzKGl0ZW0pLCB0eXBlIH0pO1xuICAgIGlmICgoY3VzdG9tUGFyYW1zID09PSBudWxsIHx8IGN1c3RvbVBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VzdG9tUGFyYW1zLmxlbmd0aCkgPj0gMSAmJiAhIWFnc1R5cGUpIHtcbiAgICAgICAgY29uc3QgeyBjdXN0b21QYXJhbWV0ZXJzIH0gPSBmb3JtYXRDdXN0b21QYXJhbWV0ZXJzKGN1c3RvbVBhcmFtcyk7XG4gICAgICAgIGNvbnRlbnQudGV4dCA9IEpTT04uc3RyaW5naWZ5KHsgY3VzdG9tUGFyYW1ldGVycyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbmRBZGRJdGVtUmVxdWVzdChjb250ZW50KTtcbn07XG4vLyAtLS0gT3RoZXJcbmFzeW5jIGZ1bmN0aW9uIGdldEl0ZW1TdGF0dXMoaWQsIG9wdGlvbnMgPSB7fSwgc3RhdHVzVXJsKSB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBjb25maWdTdGF0ZS51c2VyO1xuICAgICAgICBjb25zdCB1cmwgPSBzdGF0dXNVcmwgIT09IG51bGwgJiYgc3RhdHVzVXJsICE9PSB2b2lkIDAgPyBzdGF0dXNVcmwgOiBgJHt1c2VyLnVzZXJDb250ZW50VXJsfS9pdGVtcy8ke2lkfS9zdGF0dXNgO1xuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5qb2JJZCkgPyB7IGpvYklkOiBvcHRpb25zLmpvYklkIH0gOiB7fTtcbiAgICAgICAgLy8gTmVlZCB0byBhd2FpdCBoZXJlIHNvIGl0IHdpbGwgY2F0Y2ggcmVsYXRlZCBlcnJvciBiZWxvd1xuICAgICAgICBjb25zdCBqb2JTdGF0dXMgPSBhd2FpdCBwb2xsRm9yU3RhdHVzKHVybCwgeyByZXF1ZXN0UGFyYW1zIH0pO1xuICAgICAgICByZXR1cm4gam9iU3RhdHVzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCEoKF9hID0gZXJyb3Iuc3RhdHVzTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiSXRlbSBzdGF0dXMgZG9lc24ndCBleGlzdFwiKSkgfHwgIW9wdGlvbnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpdGVtSWQ6IGlkLCBzdGF0dXM6IFwic3RhdHVzLW5vdC1mb3VuZFwiLCBsYXN0VXBkYXRlZFRpbWU6IDAsIHN1Ym1pc3Npb25UaW1lOiAwLCByZWNvcmRDb3VudDogMCB9O1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFkZFJlc291cmNlKG93bmVyLCBpZCwgZm9sZGVyLCBwYXJhbXMpIHtcbiAgICBjb25zdCB7IGNvbmZpZyB9ID0gY29uZmlnU3RhdGU7XG4gICAgY29uc3QgZm9sZGVyUGF0aCA9IGZvbGRlci5pZCAmJiBmb2xkZXIuaWQgIT09IFwiL1wiICYmIGZvbGRlci5pZCAhPT0gb3duZXIgPyBgLyR7Zm9sZGVyLmlkfWAgOiBcIlwiO1xuICAgIGNvbnN0IHVybCA9IGAke2NvbmZpZy5yZXN0QmFzZVVybH1jb250ZW50L3VzZXJzLyR7b3duZXJ9JHtmb2xkZXJQYXRofS9pdGVtcy8ke2lkfS9hZGRSZXNvdXJjZXNgO1xuICAgIHJldHVybiByZXF1ZXN0KHVybCwgcGFyYW1zLCB7fSwgXCJwb3N0XCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gYWRkQ2xvdWRQcm92aWRlclJlc291cmNlKHJlc291cmNlLCBpZCkge1xuICAgIGNvbnN0IGZvbGRlciA9IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuZm9sZGVyO1xuICAgIGNvbnN0IHsgdXNlciB9ID0gY29uZmlnU3RhdGU7XG4gICAgLy8gYWRkIGNsb3VkIGluZm8gdG8gcmVzb3VyY2VcbiAgICByZXR1cm4gYWRkUmVzb3VyY2UodXNlci51c2VybmFtZSwgaWQsIGZvbGRlciwge1xuICAgICAgICBmaWxlTmFtZTogXCJjbG91ZFByb3ZpZGVyLmpzb25cIixcbiAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkocmVzb3VyY2UpLFxuICAgICAgICBhY2Nlc3M6IFwicHJpdmF0ZVwiXG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEFHU1RodW1ibmFpbChpdGVtKSB7XG4gICAgY29uc3QgeyB1cmwsIHRodW1ibmFpbFVSTCwgc2VydmljZUluZm8sIGV4dGVudCB9ID0gaXRlbTtcbiAgICBpZiAodGh1bWJuYWlsVVJMKSB7XG4gICAgICAgIHJldHVybiB0aHVtYm5haWxVUkw7XG4gICAgfVxuICAgIGlmICghW1wiTWFwIFNlcnZpY2VcIiwgXCJGZWF0dXJlIFNlcnZpY2VcIiwgXCJJbWFnZSBTZXJ2aWNlXCJdLmluY2x1ZGVzKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChbXCJNYXAgU2VydmljZVwiLCBcIkltYWdlIFNlcnZpY2VcIl0uaW5jbHVkZXMoaXRlbS50eXBlKSB8fCB1cmwuaW5kZXhPZihcIk1hcFNlcnZlclwiKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgZXh0ZW50U3RyaW5nID0gZXh0ZW50VG9TdHJpbmcoZXh0ZW50KTtcbiAgICAgICAgLy8gbWFrZSB0aHVtYm5haWwgaW4gc2VydmljZSBzcGF0aWFsIHJlZmVyZW5jZVxuICAgICAgICBjb25zdCBleHBvcnRDYWxsT3B0cyA9IHsgc2VydmljZVVybDogdXJsLCBleHRlbnQ6IGV4dGVudFN0cmluZywgc2l6ZTogXCI4MDAsNTMyXCIsIGZvcm1hdDogXCJpbWFnZVwiLCBzZXJ2aWNlSW5mbyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW50ID8gYnVpbGRFeHBvcnRDYWxsKGV4cG9ydENhbGxPcHRzKSA6IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gYXdhaXQgYnVpbGRUaHVtYm5haWxVUkxGcm9tRlNJdGVtKGl0ZW0pO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICAvLyBJZGVhbGx5IHRoZSB0aHVtYm5haWwgZ2VuZXJhdGlvbiBwcm9jZXNzIHNob3VsZG4ndCBzdG9wIHRoZSBvdGhlciBwcm9jZXNzIGluIGNhc2Ugb2YgZmFpbGluZ1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2VuZXJhdGluZyB0aHVtYm5haWxcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXhwb3J0Q2FsbChleHBvcnRDYWxsT3B0cykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyB2aXNpYmxlTGF5ZXJzLCBzZXJ2aWNlVXJsLCBzZXJ2aWNlSW5mbywgc2l6ZSwgZXh0ZW50LCBiYm94U1IsIGltYWdlU1IsIGZvcm1hdCB9ID0gZXhwb3J0Q2FsbE9wdHM7XG4gICAgbGV0IHBvc2l0aW9uO1xuICAgIGlmICghc2VydmljZUluZm8pIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGxldCBpc01hcCA9IHNlcnZpY2VVcmwuaW5kZXhPZihcIi9NYXBTZXJ2ZXJcIikgPiAtMTtcbiAgICBpZiAoIXZpc2libGVMYXllcnMgJiYgaXNNYXApIHtcbiAgICAgICAgbGV0IGxheWVySWQ7XG4gICAgICAgIC8vIGl0J3MganVzdCBvbmUgbGF5ZXIgb2YgYSBtYXAgc2VydmljZVxuICAgICAgICBwb3NpdGlvbiA9IHNlcnZpY2VVcmwuaW5kZXhPZihcIi9NYXBTZXJ2ZXJcIik7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UG9zaXRpb24gPSBzZXJ2aWNlVXJsLmluZGV4T2YoXCI/XCIpO1xuICAgICAgICBpZiAocXVlcnlQb3NpdGlvbiA+IC0xKSB7XG4gICAgICAgICAgICBsYXllcklkID0gc2VydmljZVVybC5zdWJzdHJpbmcocG9zaXRpb24gKyAxMSwgcXVlcnlQb3NpdGlvbik7XG4gICAgICAgICAgICBzZXJ2aWNlVXJsID0gc2VydmljZVVybC5zdWJzdHJpbmcoMCwgcG9zaXRpb24gKyAxMCkgKyBzZXJ2aWNlVXJsLnN1YnN0cmluZyhxdWVyeVBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZpc2libGVMYXllcnMgPSBsYXllcklkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGF5ZXJJZCA9IHNlcnZpY2VVcmwuc3Vic3RyaW5nKHBvc2l0aW9uICsgMTEpO1xuICAgICAgICAgICAgc2VydmljZVVybCA9IHNlcnZpY2VVcmwuc3Vic3RyaW5nKDAsIHBvc2l0aW9uICsgMTApO1xuICAgICAgICAgICAgdmlzaWJsZUxheWVycyA9IGxheWVySWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc01hcCAmJiBzZXJ2aWNlSW5mbykge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgcHJveHkgc2VydmljZSBlbmRpbmcgaW4gL3NlcnZpY2VcbiAgICAgICAgaWYgKHNlcnZpY2VJbmZvLmNhcGFiaWxpdGllcykge1xuICAgICAgICAgICAgaXNNYXAgPSBzZXJ2aWNlSW5mby5jYXBhYmlsaXRpZXMudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwibWFwXCIpID4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvbGRlciBzZXJ2ZXJzXG4gICAgICAgICAgICBpc01hcCA9IHNlcnZpY2VJbmZvLnN1cHBvcnRlZEltYWdlRm9ybWF0VHlwZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHVybCA9IHNlcnZpY2VVcmw7XG4gICAgcG9zaXRpb24gPSB1cmwuaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAgICAgICAgIHVybCArPSBcIi9leHBvcnQ/XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNlcnZpY2VJbmZvLmN1cnJlbnRWZXJzaW9uICE9PSBcInVuZGVmaW5lZFwiICYmIHNlcnZpY2VJbmZvLmN1cnJlbnRWZXJzaW9uID49IDEwLjEpIHtcbiAgICAgICAgICAgIHVybCArPSBcIi9pbmZvL3RodW1ibmFpbFwiO1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVybCArPSBcIi9leHBvcnRJbWFnZT9cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHt1cmwuc3Vic3RyaW5nKDAsIHBvc2l0aW9uKX0vZXhwb3J0JHt1cmwuc3Vic3RyaW5nKHBvc2l0aW9uLCB1cmwubGVuZ3RoKX0mYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2VydmljZUluZm8uY3VycmVudFZlcnNpb24gIT09IFwidW5kZWZpbmVkXCIgJiYgc2VydmljZUluZm8uY3VycmVudFZlcnNpb24gPj0gMTAuMSkge1xuICAgICAgICAgICAgdXJsID0gYCR7dXJsLnN1YnN0cmluZygwLCBwb3NpdGlvbil9L2luZm8vdGh1bWJuYWlsJHt1cmwuc3Vic3RyaW5nKHBvc2l0aW9uLCB1cmwubGVuZ3RoKX1gO1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVybCA9IGAke3VybC5zdWJzdHJpbmcoMCwgcG9zaXRpb24pfS9leHBvcnRJbWFnZSR7dXJsLnN1YnN0cmluZyhwb3NpdGlvbiwgdXJsLmxlbmd0aCl9JmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXJsICs9IGBzaXplPSR7c2l6ZX0mYmJveD0ke2V4dGVudH1gO1xuICAgIGlmICgoYmJveFNSID09PSBudWxsIHx8IGJib3hTUiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmJveFNSLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgIHVybCArPSBgJmJib3hTUj0ke2Jib3hTUn1gO1xuICAgIH1cbiAgICBpZiAoKGltYWdlU1IgPT09IG51bGwgfHwgaW1hZ2VTUiA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2VTUi5sZW5ndGgpID4gMCkge1xuICAgICAgICB1cmwgKz0gYCZpbWFnZVNSPSR7aW1hZ2VTUn1gO1xuICAgIH1cbiAgICBpZiAoaXNNYXAgJiYgKChfYSA9IHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5zdXBwb3J0ZWRJbWFnZUZvcm1hdFR5cGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5kZXhPZihcIlBORzMyXCIpKSA+IC0xKSB7XG4gICAgICAgIHVybCArPSBgJmZvcm1hdD1wbmczMiZmPSR7Zm9ybWF0fWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTWFwKSB7XG4gICAgICAgIHVybCArPSBgJmZvcm1hdD1wbmcyNCZmPSR7Zm9ybWF0fWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cmwgKz0gYCZmb3JtYXQ9anBncG5nJmY9JHtmb3JtYXR9YDtcbiAgICB9XG4gICAgaWYgKGlzTWFwKSB7XG4gICAgICAgIGlmICgodmlzaWJsZUxheWVycyA9PT0gbnVsbCB8fCB2aXNpYmxlTGF5ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXNpYmxlTGF5ZXJzLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICB1cmwgKz0gYCZsYXllcnM9c2hvdzoke3Zpc2libGVMYXllcnN9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXJsICs9IFwiJmludGVycG9sYXRpb249UlNQX05lYXJlc3ROZWlnaGJvciZiYW5kSWRzPW51bGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkVGh1bWJuYWlsRm9yRlNJdGVtNHgoaWQsIHBvcnRhbCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IFtNYXAsIE1hcFZpZXcsIEZlYXR1cmVMYXllciwgQmFzZW1hcCwgcHJpbnQsIFByaW50VGVtcGxhdGUsIFByaW50UGFyYW1ldGVycywgc2NhbGVSYW5nZV0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICAgIFwiZXNyaS9NYXBcIixcbiAgICAgICAgXCJlc3JpL3ZpZXdzL01hcFZpZXdcIixcbiAgICAgICAgXCJlc3JpL2xheWVycy9GZWF0dXJlTGF5ZXJcIixcbiAgICAgICAgXCJlc3JpL0Jhc2VtYXBcIixcbiAgICAgICAgXCJlc3JpL3Jlc3QvcHJpbnRcIixcbiAgICAgICAgXCJlc3JpL3Jlc3Qvc3VwcG9ydC9QcmludFRlbXBsYXRlXCIsXG4gICAgICAgIFwiZXNyaS9yZXN0L3N1cHBvcnQvUHJpbnRQYXJhbWV0ZXJzXCIsXG4gICAgICAgIFwiZXNyaS9zbWFydE1hcHBpbmcvaGV1cmlzdGljcy9zY2FsZVJhbmdlXCJcbiAgICBdKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBjcmVhdGVIaWRkZW5NYXBEaXYoODAwLCA1MzIpO1xuICAgICAgICBjb25zdCBrbm93bkJhc2VtYXBJZCA9IHBvcnRhbC5kZWZhdWx0QmFzZW1hcC5pZC5pbmNsdWRlcyhcImJhc2VtYXBcIik7XG4gICAgICAgIGNvbnN0IGxheWVyID0gbmV3IEZlYXR1cmVMYXllcih7XG4gICAgICAgICAgICBwb3J0YWxJdGVtOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgcG9ydGFsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKHtcbiAgICAgICAgICAgIGJhc2VtYXA6IGtub3duQmFzZW1hcElkXG4gICAgICAgICAgICAgICAgPyBcInRvcG8tdmVjdG9yXCJcbiAgICAgICAgICAgICAgICA6IG5ldyBCYXNlbWFwKHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydGFsSXRlbToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHBvcnRhbC5kZWZhdWx0QmFzZW1hcC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgTWFwVmlldyh7XG4gICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICBjb250YWluZXJcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IG1hcC53YXRjaChcImxvYWRlZFwiKTtcbiAgICAgICAgbGV0IG1pblNjYWxlID0gMDtcbiAgICAgICAgbGV0IG1heFNjYWxlID0gMDtcbiAgICAgICAgaWYgKCFrbm93bkJhc2VtYXBJZCkge1xuICAgICAgICAgICAgKHsgbWluU2NhbGUsIG1heFNjYWxlIH0gPSBhd2FpdCBzY2FsZVJhbmdlKHtcbiAgICAgICAgICAgICAgICBsYXllcixcbiAgICAgICAgICAgICAgICB2aWV3XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ZW50UmVzcG9uc2UgPSBhd2FpdCBsYXllci5xdWVyeUV4dGVudCgpO1xuICAgICAgICB2aWV3LmdvVG8oZXh0ZW50UmVzcG9uc2UuZXh0ZW50KTtcbiAgICAgICAgbGF5ZXIubWluU2NhbGUgPSBtaW5TY2FsZTtcbiAgICAgICAgbGF5ZXIubWF4U2NhbGUgPSBtYXhTY2FsZTtcbiAgICAgICAgdmlldy5tYXAuYWRkKGxheWVyKTtcbiAgICAgICAgdmlldy5zY2FsZSA9IG1heFNjYWxlO1xuICAgICAgICBhd2FpdCB0aW1lb3V0KDIwMDApO1xuICAgICAgICAvLyB1cmwgdG8gdGhlIHByaW50IHNlcnZpY2VcbiAgICAgICAgY29uc3QgdXJsID0gKF9jID0gKF9iID0gKF9hID0gcG9ydGFsLmhlbHBlclNlcnZpY2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJpbnRUYXNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudXJsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcImh0dHBzOi8vdXRpbGl0eS5hcmNnaXNvbmxpbmUuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1V0aWxpdGllcy9QcmludGluZ1Rvb2xzL0dQU2VydmVyL0V4cG9ydCUyMFdlYiUyME1hcCUyMFRhc2tcIjtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBuZXcgUHJpbnRUZW1wbGF0ZSh7XG4gICAgICAgICAgICBmb3JtYXQ6IFwicG5nMzJcIixcbiAgICAgICAgICAgIGV4cG9ydE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBkcGk6IDk2LFxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1MzJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXlvdXQ6IFwibWFwLW9ubHlcIixcbiAgICAgICAgICAgIHNob3dMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgYXR0cmlidXRpb25WaXNpYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFByaW50UGFyYW1ldGVycyh7XG4gICAgICAgICAgICB2aWV3OiB2aWV3LFxuICAgICAgICAgICAgdGVtcGxhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByaW50UmVzdWx0ID0gYXdhaXQgcHJpbnQuZXhlY3V0ZSh1cmwsIHBhcmFtcyk7XG4gICAgICAgIGRlc3Ryb3lIaWRkZW5NYXBEaXYoKTtcbiAgICAgICAgcmV0dXJuIHByaW50UmVzdWx0LnVybDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRlc3Ryb3lIaWRkZW5NYXBEaXYoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRUaHVtYm5haWxVUkxGcm9tRlNJdGVtKGl0ZW0pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBjb25maWcsIHBvcnRhbCwgYXBpIH0gPSBjb25maWdTdGF0ZTtcbiAgICBpZiAoYXBpID09PSA0KSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgYnVpbGRUaHVtYm5haWxGb3JGU0l0ZW00eChpdGVtLmlkLCBwb3J0YWwpIH07XG4gICAgfVxuICAgIGNvbnN0IFtGZWF0dXJlTGF5ZXIsIEV4dGVudF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2xheWVycy9GZWF0dXJlTGF5ZXJcIiwgXCJlc3JpL2dlb21ldHJ5L0V4dGVudFwiXSk7XG4gICAgY29uc3QgeyBzZXJ2aWNlSW5mbywgdXNlcm5hbWUsIHBhc3N3b3JkLCBpc1NlY3VyZWQgfSA9IGl0ZW07XG4gICAgLy8gZnJvbSBpdGVtIHByb3BlcnRpZXMgcGFnZSBvciB2aWV3ZXIgJ3NhdmUgbGF5ZXInIChub3QgZm9yIGZlYXR1cmUgY29sbGVjdGlvbilcbiAgICAvLyBuZXdFeHRlbnQgYW5kIGxheWVycyBvdmVyd3JpdGVzIGZvciB0aGUgaXRlbSBhcmUgb3B0aW9uYWxcbiAgICAvLyAxLiBnZXQgaXRlbSAvZGF0YSB0byBnZXQgb3ZlcndyaXRlc1xuICAgIC8vIDIuIG1ha2Ugc2VydmljZSBpbmZvIHJlcXVlc3QgdG8gZ2V0IGxheWVyc1xuICAgIC8vIDMuIGJ1aWxkIHdlYk1hcCBvYmplY3RcbiAgICAvLyA0LiBjYWxsIEdlb3Byb2Nlc3NvciB0YXNrXG4gICAgY29uc3Qgd2ViTWFwID0ge1xuICAgICAgICBiYXNlTWFwOiBjb25maWcuZGVmYXVsdEJhc2VtYXAgfHwgY29uZmlnLnNlbGYuZGVmYXVsdEJhc2VtYXAsXG4gICAgICAgIG9wZXJhdGlvbmFsTGF5ZXJzOiBbXVxuICAgIH07XG4gICAgd2ViTWFwLmJhc2VNYXAudGl0bGUgPSBcImJhc2VtYXBcIjtcbiAgICBjb25zdCBsZW4gPSB3ZWJNYXAuYmFzZU1hcC5iYXNlTWFwTGF5ZXJzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCBsYXllciA9IHdlYk1hcC5iYXNlTWFwLmJhc2VNYXBMYXllcnNbaV07XG4gICAgICAgIGlmICghbGF5ZXIuaXNSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgb25seSBvbmUgYmFzZW1hcCBsYXllciBhbmQgd2UgaGlkZSBpdFxuICAgICAgICAgICAgaWYgKChjb25maWcuYWxsU1NMIHx8IGxvY2F0aW9uLnByb3RvY29sID09IFwiaHR0cHM6XCIpICYmXG4gICAgICAgICAgICAgICAgKGlzSG9zdGVkU2VydmljZShsYXllci51cmwpIHx8IHN1cHBvcnRzSHR0cHMobGF5ZXIudXJsKSkpIHtcbiAgICAgICAgICAgICAgICBsYXllci51cmwgPSBsYXllci51cmwucmVwbGFjZShcImh0dHA6XCIsIFwiaHR0cHM6XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXIudmlzaWJpbGl0eSA9IGZhbHNlO1xuICAgICAgICAgICAgd2ViTWFwLmJhc2VNYXAuYmFzZU1hcExheWVycyA9IFtsYXllcl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNlcnZpY2VJbmZvKSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogXCJcIiB9O1xuICAgIH1cbiAgICBjb25zdCBsYXllcnMgPSBzZXJ2aWNlSW5mby5sYXllcnMgfHwgW107XG4gICAgY29uc3QgaXRlbVVybCA9IGl0ZW0udXJsO1xuICAgIGNvbnN0IHVybE9iamVjdCA9IGF3YWl0IHVybFRvT2JqZWN0KGl0ZW1VcmwpO1xuICAgIGNvbnN0IHRva2VuID0gaXNTZWN1cmVkLnNlY3VyZWQgPyBhd2FpdCBnZXRTZWN1cmVkU2VydmljZUN1c3RvbVRva2VuKHVybE9iamVjdC5wYXRoLCB7IHVzZXJuYW1lLCBwYXNzd29yZCB9KSA6IG51bGw7XG4gICAgbGF5ZXJzLnJldmVyc2UoKS5mb3JFYWNoKGFzeW5jIChsYXllcikgPT4ge1xuICAgICAgICBjb25zdCBvcGVyYXRpb25hbExheWVyID0ge1xuICAgICAgICAgICAgdXJsOiBgJHtpdGVtVXJsfS8ke2xheWVyLmlkfSR7dG9rZW4gPyBgP3Rva2VuPSR7dG9rZW59YCA6IFwiXCJ9YCxcbiAgICAgICAgICAgIGlkOiBgJHtpdGVtLmlkIHx8IE1hdGgucmFuZG9tKCl9XyR7bGF5ZXIuaWR9YCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0aXRsZTogYCR7aXRlbS50aXRsZSB8fCBcInRpdGxlXCJ9XyR7bGF5ZXIuaWR9YCxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IHRydWUsXG4gICAgICAgICAgICBsYXllckRlZmluaXRpb246IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgbGF5ZXJzLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgICAgICAgaWYgKGx5ci5pZCA9PT0gbGF5ZXIuaWQgJiYgIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbmFsTGF5ZXIubGF5ZXJEZWZpbml0aW9uID0gbHlyLmxheWVyRGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghbGF5ZXJzLmxlbmd0aCB8fCAobGF5ZXJzLmxlbmd0aCAmJiBmb3VuZCkpIHtcbiAgICAgICAgICAgIHdlYk1hcC5vcGVyYXRpb25hbExheWVycy5wdXNoKG9wZXJhdGlvbmFsTGF5ZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGV4dGVudCA9IFtcbiAgICAgICAgWy0xODAsIC05MF0sXG4gICAgICAgIFsxODAsIDkwXVxuICAgIF07XG4gICAgaWYgKHR5cGVvZiBpdGVtLmV4dGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBlID0gaXRlbS5leHRlbnQuc3BsaXQoXCIsXCIpO1xuICAgICAgICBleHRlbnQgPSBbXG4gICAgICAgICAgICBbcGFyc2VGbG9hdChlWzBdKSwgcGFyc2VGbG9hdChlWzFdKV0sXG4gICAgICAgICAgICBbcGFyc2VGbG9hdChlWzJdKSwgcGFyc2VGbG9hdChlWzNdKV1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKChfYSA9IGl0ZW0uZXh0ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgZXh0ZW50ID0gaXRlbS5leHRlbnQ7XG4gICAgfVxuICAgIGlmICh3ZWJNYXAub3BlcmF0aW9uYWxMYXllcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGxldCBmZWF0dXJlTGF5ZXIgPSBuZXcgRmVhdHVyZUxheWVyKHdlYk1hcC5vcGVyYXRpb25hbExheWVyc1swXS51cmwpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGZlYXR1cmVMYXllci5vbihcImxvYWRcIiwgYXN5bmMgKGZlYXRMYXllcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmZWF0TGF5ZXIgPT09IG51bGwgfHwgZmVhdExheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0TGF5ZXIubGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUxheWVyID0gZmVhdExheWVyLmxheWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnRBc0xpc3QgPSBhd2FpdCBnZXRFeHRlbnRXaXRoRmVhdHVyZXMoZmVhdHVyZUxheWVyLCBleHRlbnQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRodW1ibmFpbFVybCA9IGF3YWl0IGJ1aWxkVGh1bWJuYWlsVVJMRnJvbVdlYk1hcCh3ZWJNYXAsIGV4dGVudEFzTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyByZXN1bHQ6IHRodW1ibmFpbFVybCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsIG1lc3NhZ2U6IGVycm9yIH0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYXQgbGVhc3Qgb25lIGxheWVyIGlzIGluIHNjYWxlXG4gICAgICAgIGNvbnN0IGV4dGVudEFzTGlzdCA9IGl0ZW0uZXh0ZW50O1xuICAgICAgICBjb25zdCBleHQgPSBuZXcgRXh0ZW50KGV4dGVudEFzTGlzdFswXVswXSwgZXh0ZW50QXNMaXN0WzBdWzFdLCBleHRlbnRBc0xpc3RbMV1bMF0sIGV4dGVudEFzTGlzdFsxXVsxXSk7XG4gICAgICAgIGNvbnN0IHRodW1ibmFpbFNjYWxlID0gZ2V0U2NhbGVGb3JFeHRlbnQoZXh0LCAyMDApO1xuICAgICAgICBjb25zdCBvcExheWVycyA9IFtdO1xuICAgICAgICBjb25zdCBmZWF0dXJlTGF5ZXJzID0gW107XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIHdlYk1hcC5vcGVyYXRpb25hbExheWVycy5mb3JFYWNoKChvcExheWVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlTGF5ZXIgPSBuZXcgRmVhdHVyZUxheWVyKG9wTGF5ZXIudXJsKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVMYXllci5vbihcImxvYWRcIiwgKGxheWVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wTGF5ZXJzLnB1c2gob3BMYXllcik7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5taW5TY2FsZSA8PSB0aHVtYm5haWxTY2FsZSAmJiBsYXllci5tYXhTY2FsZSA+IHRodW1ibmFpbFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlTGF5ZXIub24oXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAvLyBjbGVhbiBvdXQgbGF5ZXJzIHRoYXQgZGlkbid0IGxvYWQgZnJvbSB0aGUgd2VibWFwXG4gICAgICAgIHdlYk1hcC5vcGVyYXRpb25hbExheWVycyA9IG9wTGF5ZXJzO1xuICAgICAgICBjb25zdCBmb3VuZCA9IHJlc3BvbnNlcy5maWx0ZXIoKHJlcykgPT4gcmVzKS5sZW5ndGggPiAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFmb3VuZCAmJiBmZWF0dXJlTGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzYXZpbmcgdGh1bWJuYWlsIHdpdGggaXRlbSBleHRlbnQgd2lsbCBiZSBibGFua1xuICAgICAgICAgICAgICAgIC8vIHpvb20gdG8gZmVhdHVyZXMgaW5zdGVhZDsgdXNlIGZpcnN0IHdvcmtpbmcgbGF5ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnRXaXRoRmVhdHVyZXMgPSBhd2FpdCBnZXRFeHRlbnRXaXRoRmVhdHVyZXMoZmVhdHVyZUxheWVyc1swXSwgZXh0ZW50QXNMaXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGJ1aWxkVGh1bWJuYWlsVVJMRnJvbVdlYk1hcCh3ZWJNYXAsIGV4dGVudFdpdGhGZWF0dXJlcykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgYnVpbGRUaHVtYm5haWxVUkxGcm9tV2ViTWFwKHdlYk1hcCwgZXh0ZW50QXNMaXN0KSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiLCBtZXNzYWdlOiBlcnJvciB9IH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlzRmVkZXJhdGVkV2l0aFdlYlRpZXJBdXRoKGl0ZW1JbmZvLCBjaGVja1VybFJlc3BvbnNlLCBjaGVja0F1dGgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8vSWYgYSBzZXJ2aWNlIGlzIGZlZGVyYXRlZCB3aXRoIGFub3RoZXIgcG9ydGFsLCBhbmQgaXMgc2VjdXJlZCB3aXRoIHdlYiB0aWVyIGF1dGhlbnRpY2F0aW9uXG4gICAgLy9pdCB3aWxsIHN0aWxsIHJlcG9ydCBiYWNrIHRoYXQgaXRzIHNlY3VyZWQgd2l0aCB0b2tlbiBzZWN1cml0eSAoXCI0OTlcIiksIGV2ZW4gdGhvdWdoIGl0IHVzZXMgd2ViIHRpZXIgYXV0aGVudGljYXRpb24gKFwiNDAxXCIpXG4gICAgLy9pdCBkb2VzIHRoaXMgYmVjYXVzZSBpdHMgZmVkZXJhdGVkIHdpdGggYW5vdGhlciBwb3J0YWwsIHVuZm9ydHVuYXRlbHkuICBJZiBzZWN1cmVkIHdpdGggd2ViIHRpZXIsIHRoZXJlXG4gICAgLy9pc24ndCBhIHJlYXNvbiB0byBzdG9yZSB0aGUgY3JlZGVudGlhbHMgc28gbGV0cyBoaWRlIHRoYXQgYm94LCBidXQgdGhlIG9ubHkgd2F5IHRvIGNoZWNrIHRoYXQgaXMgdG8gY2FsbFxuICAgIC8vY2hlY2tVcmwgd2l0aCB0aGUgZ2VuZXJhdGVUb2tlbiBlbmRwb2ludCwgYW5kIHNlZSBpZiB0aGF0IHJldHVybnMgNDAxXG4gICAgLy9odHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvMzc5MVxuICAgIGlmICgoY2hlY2tVcmxSZXNwb25zZSA9PT0gbnVsbCB8fCBjaGVja1VybFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGVja1VybFJlc3BvbnNlLmh0dHBTdGF0dXNDb2RlKSA9PT0gNDk5KSB7XG4gICAgICAgIGNvbnN0IFtlc3JpSWRdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgICAgICAgICAgY29uZmlnU3RhdGUuYXBpID09PSAzID8gXCJlc3JpL0lkZW50aXR5TWFuYWdlclwiIDogXCJlc3JpL2lkZW50aXR5L0lkZW50aXR5TWFuYWdlclwiXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCB7IHVybCwgcGFzc3dvcmQsIHVzZXJuYW1lIH0gPSBpdGVtSW5mbztcbiAgICAgICAgY29uc3QgdG9rZW5TZXJ2aWNlVXJsID0gYXdhaXQgZXNyaUlkLl9nZXRUb2tlblN2Y1VybCh1cmwpO1xuICAgICAgICBsZXQgZ2VuZXJhdGVUb2tlblVybCA9IChfYSA9IHRva2VuU2VydmljZVVybC5hdXRoSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRva2VuU2VydmljZXNVcmw7XG4gICAgICAgIGlmIChnZW5lcmF0ZVRva2VuVXJsKSB7XG4gICAgICAgICAgICAvLyBBZGQgYSB0cmFpbGluZyBzbGFzaCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVUb2tlblVybFtnZW5lcmF0ZVRva2VuVXJsLmxlbmd0aCAtIDFdICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlVG9rZW5VcmwgKz0gXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldElzU2VjdXJlZCh7IHBhc3N3b3JkLCB1c2VybmFtZSB9LCBnZW5lcmF0ZVRva2VuVXJsICE9PSBudWxsICYmIGdlbmVyYXRlVG9rZW5VcmwgIT09IHZvaWQgMCA/IGdlbmVyYXRlVG9rZW5VcmwgOiBcIlwiLCBnZXRSZXN0QmFzZVVybCgpLCBjaGVja0F1dGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LnNlY3VyZWQpICYmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuaHR0cFN0YXR1c0NvZGUpID09PSA0MDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChfYiA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5kZXhPZihcIkh0dHAgU3RhdHVzQ29kZTogLTFcIikpID4gLTEgPyAtMSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQUdTVGl0bGUodXJsKSB7XG4gICAgcmV0dXJuIHBhcnNlQUdTU2VydmVySW5mbyhmb3JtYXRHSVNVcmwodXJsKSkuc2VydmVyTmFtZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQUdTVHlwZSh1cmwpIHtcbiAgICBjb25zdCBmb3JtYXR0ZWRVcmwgPSBmb3JtYXRHSVNVcmwodXJsKTtcbiAgICBjb25zdCBzZXJ2ZXJUeXBlQW5kTGF5ZXJJbmRleCA9IHBhcnNlQUdTU2VydmVySW5mbyh1cmwpO1xuICAgIGNvbnN0IGNvbnRhaW5zQUdTID0gZm9ybWF0dGVkVXJsLnJlcGxhY2UodmFsaWRBcmNnaXNSZXN0U2VydmljZVBhdGgsIFwiXCIpLm1hdGNoKGFnc1JlZ0V4cCk7XG4gICAgbGV0IGFnc1R5cGUgPSBzZXJ2ZXJUeXBlQW5kTGF5ZXJJbmRleCA9PT0gbnVsbCB8fCBzZXJ2ZXJUeXBlQW5kTGF5ZXJJbmRleCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmVyVHlwZUFuZExheWVySW5kZXguc2VydmVyVHlwZTtcbiAgICBsZXQgc29lVHlwZSA9IHNlcnZlclR5cGVBbmRMYXllckluZGV4ID09PSBudWxsIHx8IHNlcnZlclR5cGVBbmRMYXllckluZGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2ZXJUeXBlQW5kTGF5ZXJJbmRleC5pbmRleDtcbiAgICBjb25zdCBjYXNlQ29ycmVjdGVkID0ge1xuICAgICAgICBtYXBzZXJ2ZXI6IFwiTWFwU2VydmVyXCIsXG4gICAgICAgIGdlb2NvZGVzZXJ2ZXI6IFwiR2VvY29kZVNlcnZlclwiLFxuICAgICAgICBncHNlcnZlcjogXCJHUFNlcnZlclwiLFxuICAgICAgICBnZW9tZXRyeXNlcnZlcjogXCJHZW9tZXRyeVNlcnZlclwiLFxuICAgICAgICBnZW9lbnJpY2htZW50c2VydmVyOiBcIkdlb2VucmljaG1lbnRTZXJ2ZXJcIixcbiAgICAgICAgaW1hZ2VzZXJ2ZXI6IFwiSW1hZ2VTZXJ2ZXJcIixcbiAgICAgICAgbmFzZXJ2ZXI6IFwiTkFTZXJ2ZXJcIixcbiAgICAgICAgZmVhdHVyZXNlcnZlcjogXCJGZWF0dXJlU2VydmVyXCIsXG4gICAgICAgIGdlb2RhdGFzZXJ2ZXI6IFwiR2VvRGF0YVNlcnZlclwiLFxuICAgICAgICBnbG9iZXNlcnZlcjogXCJHbG9iZVNlcnZlclwiLFxuICAgICAgICB3bXNlcnZlcjogXCJXTVNlcnZlclwiLFxuICAgICAgICBzY2VuZXNlcnZlcjogXCJTY2VuZVNlcnZlclwiLFxuICAgICAgICB2ZWN0b3J0aWxlc2VydmVyOiBcIlZlY3RvclRpbGVTZXJ2ZXJcIixcbiAgICAgICAgc3RyZWFtc2VydmVyOiBcIlN0cmVhbVNlcnZlclwiLFxuICAgICAgICB2aWRlb3NlcnZlcjogXCJWaWRlb1NlcnZlclwiXG4gICAgfTtcbiAgICBpZiAoYWdzVHlwZSAmJiBjYXNlQ29ycmVjdGVkW2Fnc1R5cGUudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgYWdzVHlwZSA9IGNhc2VDb3JyZWN0ZWRbYWdzVHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLy8gVE9ETzogRml4IHRoaXMgbWFwcGluZyBlYXJsaWVyLCBtYXliZSByZW1vdmUgdGhpcyB3aG9sZSBmdW5jdGlvbj8gVGhlIG9yaWdpbmFsIHVybCBwYXJzZXIgbWlnaHQgbWF5IGJlIGFibGUgdG8gaGFuZGxlIHRoaXMgdXAgZnJvbnRcbiAgICBpZiAoYWdzVHlwZSA9PT0gXCJhZ3NcIiB8fCAoIWFnc1R5cGUgJiYgY29udGFpbnNBR1MpKSB7XG4gICAgICAgIGFnc1R5cGUgPSBcIk1hcFNlcnZlclwiO1xuICAgIH1cbiAgICBpZiAoYWdzVHlwZSA9PT0gXCJNYXBTZXJ2ZXJcIiAmJiBzb2VUeXBlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIExheWVyIHdpdGhpbiBhIG1hcHNlcnZlciAtIENSMjYwODQ1XG4gICAgICAgIHJldHVybiBcIkZlYXR1cmVTZXJ2ZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGFnc1R5cGU7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTZWN1cmVkQUdTU2VydmljZUluZm8oaXRlbSkge1xuICAgIHZhciBfYTtcbiAgICAvLyBUT0RPOiBQYXNzIGluIHdoYXQgd2UgbmVlZCBmcm9tIGNvbmZpZ1N0YXRlIGFzIGFyZ3NcbiAgICBjb25zdCB7IGNvbmZpZyB9ID0gY29uZmlnU3RhdGU7XG4gICAgY29uc3QgeyBjaGVja0F1dGgsIHN0b3JlQXV0aCwgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSBpdGVtO1xuICAgIGl0ZW0udGl0bGUgPSBwYXJzZUFHU1RpdGxlKGl0ZW0udXJsKTtcbiAgICBjb25zdCBhZ3NUeXBlID0gcGFyc2VBR1NUeXBlKGl0ZW0udXJsKTtcbiAgICBpZiAoIWFnc1R5cGUgfHwgKGFnc1R5cGUgPT09IFwiU2NlbmVTZXJ2ZXJcIiAmJiAhY29uZmlnLnNjZW5lVmlld2VyRW5hYmxlZCkpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmtub3duQUdTVHlwZVwiIH0gfTtcbiAgICB9XG4gICAgbGV0IGl0ZW1UeXBlID0gKF9hID0gYWRkQ3JlYXRlSXRlbVR5cGVzW2Fnc1R5cGVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZTtcbiAgICBpZiAoIWl0ZW1UeXBlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBBR1MgVHlwZSAke2Fnc1R5cGV9YCk7XG4gICAgICAgIC8vIFRPRE86IENhbiB3ZSByZWFjaCB0aGlzIHBvaW50PyBBbmQgaWYgc28gd2lsbCBhbiBpdGVtIGJlIGNyZWF0ZWQ/XG4gICAgfVxuICAgIGl0ZW0udHlwZSA9IGl0ZW1UeXBlO1xuICAgIGl0ZW0uYWdzVHlwZSA9IGFnc1R5cGU7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFjb25maWdTdGF0ZS51c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGdldEFHU1NlcnZpY2VJbmZvKGl0ZW0pIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0SXNTZWN1cmVkKHsgdXNlcm5hbWUsIHBhc3N3b3JkIH0sIGl0ZW0udXJsLCBnZXRSZXN0QmFzZVVybChjb25maWdTdGF0ZS5wb3J0YWwpLCBjaGVja0F1dGgpO1xuICAgICAgICBjb25zdCBjaGVja1VybEFsbG93U3RvcmVkQXV0aCA9IHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5hbGxvd1N0b3JlZEF1dGg7XG4gICAgICAgIGlmIChjaGVja1VybEFsbG93U3RvcmVkQXV0aCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgL2NoZWNrVXJsIGZhaWxzIGZvciBzb21lIHJlYXNvblxuICAgICAgICAgICAgaXRlbS5hbGxvd1N0b3JlZEF1dGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnNlY3VyZWQpIHtcbiAgICAgICAgICAgIGl0ZW0uaXNTZWN1cmVkID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KTtcbiAgICAgICAgICAgIGl0ZW0uYWxsb3dTdG9yZWRBdXRoID0gZmFsc2U7XG4gICAgICAgICAgICAvL2h0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8zNzkxXG4gICAgICAgICAgICBjb25zdCBpc0ZlZGVyYXRlZFdpdGhXZWJUaWVyID0gYXdhaXQgaXNGZWRlcmF0ZWRXaXRoV2ViVGllckF1dGgoeyB1c2VybmFtZTogaXRlbS51c2VybmFtZSwgcGFzc3dvcmQ6IGl0ZW0ucGFzc3dvcmQsIHVybDogaXRlbS51cmwgfSwgcmVzdWx0LCBjaGVja0F1dGgpO1xuICAgICAgICAgICAgaWYgKCFpc0ZlZGVyYXRlZFdpdGhXZWJUaWVyICYmIHJlc3VsdC5odHRwU3RhdHVzQ29kZSAhPT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5pc1NlY3VyZWQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCksIHsgaXNGZWRlcmF0ZWRXaXRoV2ViVGllckF1dGg6IGlzRmVkZXJhdGVkV2l0aFdlYlRpZXIgfSk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhbGxvdyB0byB0b2dnbGUgYXV0aCBpZiBgL2NoZWNrVXJsYCBkZXRlcm1pbmUgdGhlIFVSTCBjYW4gYmUgcmVhY2hlZFxuICAgICAgICAgICAgICAgIGlmIChjaGVja1VybEFsbG93U3RvcmVkQXV0aCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hbGxvd1N0b3JlZEF1dGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmlzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIzI5OTE2LCBhcmNnaXMtcG9ydGFsLXNlcnZpY2VzLWRlc2lnbiAjMTUzIC0gR2VvZW5yaWNobWVudCBzZXJ2ZXJzIGFyZSBhYmxlIHRvIGhhdmUgYSBwcm94eSBjcmVhdGVkIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvbXB0aW5nIGZvciBjcmVkZW50aWFscy4gSW4gdGhpcyBjYXNlIGRvbid0IGRpc2FsbG93IHRoZSBzdG9yZUF1dGggb3B0aW9uIGFuZCBwYXNzIGNyZWF0ZUFzU2VydmljZVByb3h5XG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm91Z2ggdG8gdGhlIC9hZGRJdGVtIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFnc1R5cGUgPT09IFwiR2VvZW5yaWNobWVudFNlcnZlclwiICYmICFpdGVtLnN0b3JlQXV0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jcmVhdGVBc1NlcnZpY2VQcm94eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0b3JlQXV0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrQXV0aCAmJiAhc3RvcmVBdXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgZ2V0QUdTU2VydmljZUluZm8oaXRlbSwgeyB1c2VQcm94eTogcmVzdWx0LnVzZVByb3h5IH0pIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogaXRlbSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGZWRlcmF0ZWRXaXRoV2ViVGllciA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvL2h0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8xOTAwXG4gICAgICAgICAgICAgICAgLy9odHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvNDc2NVxuICAgICAgICAgICAgICAgIC8vIC0xIG1lYW5zIHRoZSBwcm94eSBkb2VzIG5vdCB0cnVzdCB0aGUgc3NsIGNlcnQgZm9yIHRoZSBpc0ZlZGVyYXRlZFdpdGhXZWJUaWVyQXV0aCByZXF1ZXN0IGZyb20gYWJvdmVcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkSXRlbSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgaXNTZWN1cmVkOiBudWxsLCBjaGVja1VybEVycm9yOiB0cnVlLCBzdG9yZUF1dGg6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgZ2V0QUdTU2VydmljZUluZm8odXBkYXRlZEl0ZW0sIHsgdXNlUHJveHk6IHJlc3VsdC51c2VQcm94eSB9KSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEl0ZW0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IGlzU2VjdXJlZDogeyBodHRwU3RhdHVzQ29kZTogNDAxLCBpc0ZlZGVyYXRlZFdpdGhXZWJUaWVyQXV0aDogaXNGZWRlcmF0ZWRXaXRoV2ViVGllciB9IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgZ2V0QUdTU2VydmljZUluZm8odXBkYXRlZEl0ZW0sIHsgdXNlUHJveHk6IHJlc3VsdC51c2VQcm94eSB9KSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBhd2FpdCBnZXRBR1NTZXJ2aWNlSW5mbyhpdGVtLCB7IHVzZVByb3h5OiByZXN1bHQudXNlUHJveHkgfSkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgYWJvcnRlZCB0aGUgZmxvdywgZG9uJ3QgdHJ5IHRvIGZldGNoIGFnYWluXG4gICAgICAgIC8vIEFsc28gcHJldmVudCByZS1yZXF1ZXN0IGlmIGl0J3Mga25vd24gdGhhdCBhbiBhcGkga2V5IGlzIG1pc3NpbmcgKGNvZGUgXCJ1bmF1dGhvcml6ZWRcIilcbiAgICAgICAgaWYgKGlzQXBwQ29tcG9uZW50RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gZXJyb3IuY29kZTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBcImZsb3dBYm9ydGVkXCIgfHwgY29kZSA9PT0gXCJ1bmF1dGhvcml6ZWRcIiB8fCBjb2RlID09PSBcImludmFsaWRTcGF0aWFsUmVmXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvL2h0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8xOTAwXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSXRlbSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgaXNTZWN1cmVkOiBpdGVtLmlzU2VjdXJlZCB8fCBudWxsLCBjaGVja1VybEVycm9yOiBlcnJvciwgc3RvcmVBdXRoOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgZ2V0QUdTU2VydmljZUluZm8odXBkYXRlZEl0ZW0pIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBcHBDb21wb25lbnRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKSB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgTUFYX1JFVFJZID0gMzsgLy8gVE9ETzogRGV0ZXJtaW5lIGEgYmV0dGVyIG51bWJlclxuYXN5bmMgZnVuY3Rpb24gZ2V0QUdTU2VydmljZUluZm8oaXRlbSwgZXh0cmFQYXJhbXMsIHJldHJ5ID0gMCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90O1xuICAgIGNvbnN0IHsgdXJsID0gaXRlbS51cmwsIHVzZVByb3h5ID0gZmFsc2UgfSA9IGV4dHJhUGFyYW1zICE9PSBudWxsICYmIGV4dHJhUGFyYW1zICE9PSB2b2lkIDAgPyBleHRyYVBhcmFtcyA6IHt9O1xuICAgIGNvbnN0IFtlc3JpSWRdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgICAgICBjb25maWdTdGF0ZS5hcGkgPT09IDMgPyBcImVzcmkvSWRlbnRpdHlNYW5hZ2VyXCIgOiBcImVzcmkvaWRlbnRpdHkvSWRlbnRpdHlNYW5hZ2VyXCJcbiAgICBdKTtcbiAgICBjb25zdCB7IHVzZXJuYW1lLCBwYXNzd29yZCwgY2hlY2tBdXRoLCBhZ3NUeXBlIH0gPSBpdGVtO1xuICAgIGNvbnN0IHsgdGFnczogaXRlbVRhZ3MgPSBbXSB9ID0gaXRlbVByb3BlcnRpZXNTdGF0ZSB8fCB7fTtcbiAgICBjb25zdCBzZWN1cmVTZXJ2aWNlID0gWzQ5OSwgNDk4XTtcbiAgICBjb25zdCBzZXJ2aWNlVXJsID0gZm9ybWF0R0lTVXJsKHVybCk7XG4gICAgaWYgKCFpdGVtLmlzU2VjdXJlZCB8fFxuICAgICAgICAoKChfYSA9IGl0ZW0uaXNTZWN1cmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cFN0YXR1c0NvZGUpICE9PSA0MDEgJiYgY2hlY2tBdXRoKSB8fFxuICAgICAgICAoKChfYiA9IGl0ZW0uY2hlY2tVcmxFcnJvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1lc3NhZ2UpICYmICEhaXRlbS5pc1NlY3VyZWQgJiYgISFpc0FHUyhpdGVtLnR5cGUpKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZUluZm8gPSBhd2FpdCBnZXRTZXJ2aWNlSW5mbyh7IHVzZXJuYW1lLCBwYXNzd29yZCB9LCBzZXJ2aWNlVXJsLCB7XG4gICAgICAgICAgICAgICAgaXNTZWN1cmU6IGl0ZW0uaXNTZWN1cmVkLFxuICAgICAgICAgICAgICAgIGlzVmlkZW9TZXJ2aWNlOiBpdGVtLnR5cGUgPT09IFwiVmlkZW8gU2VydmljZVwiLFxuICAgICAgICAgICAgICAgIGNoZWNrQXV0aCxcbiAgICAgICAgICAgICAgICB1c2VQcm94eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJbWFnZSBzZXJ2aWNlIHdpdGggTEVSQyBmb3JtYXQgdGlsZXMsIGNyZWF0ZSBuZXcgZWxldmF0aW9uIHNlcnZpY2VcbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiSW1hZ2UgU2VydmljZVwiICYmIHNlcnZpY2VJbmZvLnRpbGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VJbmZvLnRpbGVJbmZvLmZvcm1hdCA9PT0gXCJMRVJDXCIgfHwgKChfYyA9IHNlcnZpY2VJbmZvLmNhY2hlVHlwZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvTG93ZXJDYXNlKCkpID09PSBcImVsZXZhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWdzVHlwZSA9IFwiRWxldmF0aW9uU2VydmVyXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgoX2QgPSBzZXJ2aWNlSW5mby5jYWNoZVR5cGUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b0xvd2VyQ2FzZSgpKSA9PT0gXCJyYXN0ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmFnc1R5cGUgPSBcIlRpbGVkSW1hZ2VTZXJ2ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSHlicmlkSW1hZ2VTZXJ2aWNlKHVybCwgc2VydmljZUluZm8pICYmIGFkZEl0ZW1TdGF0ZS5oeWJyaWRJbWFnZVNlcnZpY2VTZXR0aW5nICE9PSBcIlRpbGVkSW1hZ2VTZXJ2ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hZ3NUeXBlID0gXCJJbWFnZVNlcnZlclwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3JlZGVudGlhbCA9IHNlcnZpY2VJbmZvLmNyZWRlbnRpYWwgfHwgZXNyaUlkLmZpbmRDcmVkZW50aWFsKHVybCk7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudEluZm8gPSBzZXJ2aWNlSW5mby5kb2N1bWVudEluZm87XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkcyA9ICgoZG9jdW1lbnRJbmZvID09PSBudWxsIHx8IGRvY3VtZW50SW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnRJbmZvLktleXdvcmRzKSB8fCBcIlwiKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlVGl0bGUgPSAoX2UgPSBkb2N1bWVudEluZm8gPT09IG51bGwgfHwgZG9jdW1lbnRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudEluZm8uVGl0bGUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHNlcnZpY2VJbmZvLm5hbWU7XG4gICAgICAgICAgICBpdGVtLnRhZ3MgPSB1bmlxdWUoWy4uLmtleXdvcmRzLCAuLi5pdGVtVGFnc10pLmZpbHRlcigodGFnKSA9PiB0YWcpO1xuICAgICAgICAgICAgLy8gS2VlcCBwYXJzZWQgdGl0bGUgaWYgc2VydmljZSBpcyBudWxsaXNoIG9yIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgaWYgKChzZXJ2aWNlVGl0bGUgPT09IG51bGwgfHwgc2VydmljZVRpdGxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlVGl0bGUubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBpdGVtLnRpdGxlID0gc2VydmljZVRpdGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5kZXNjcmlwdGlvbiA9IChfZyA9IChfZiA9IGRvY3VtZW50SW5mbyA9PT0gbnVsbCB8fCBkb2N1bWVudEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvY3VtZW50SW5mby5Db21tZW50cykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogc2VydmljZUluZm8uZGVzY3JpcHRpb24pICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFwiXCI7XG4gICAgICAgICAgICBpdGVtLnNuaXBwZXQgPSAoX2ogPSAoX2ggPSBkb2N1bWVudEluZm8gPT09IG51bGwgfHwgZG9jdW1lbnRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudEluZm8uU3ViamVjdCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogc2VydmljZUluZm8uc2VydmljZURlc2NyaXB0aW9uKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBcIlwiO1xuICAgICAgICAgICAgaXRlbSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgdGh1bWJuYWlsVG9rZW46IChjcmVkZW50aWFsID09PSBudWxsIHx8IGNyZWRlbnRpYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWwudG9rZW4pIHx8IG51bGwsIGV4dGVudDogaXRlbS5leHRlbnQgfHwgc2VydmljZUluZm8uZnVsbEV4dGVudCB8fCBzZXJ2aWNlSW5mby5leHRlbnQsIHNlcnZpY2VJbmZvOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcnZpY2VJbmZvKSwgeyBpc1NlY3VyZTogY2hlY2tBdXRoID8gdHJ1ZSA6IGZhbHNlLCB1c2VySW5mbzogeyB1c2VybmFtZSwgcGFzc3dvcmQgfSB9KSB9KTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoKF9rID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiYWJvcnRlZFwiKSkgfHwgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSA9PT0gXCJFcnJvcjoganNvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlciBjYW5jZWxsZWQgd2hlbiBwcm9tcHRlZCBmb3IgbG9naW5cbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiZmxvd0Fib3J0ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IubWVzc2FnZS5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5IHRoZSBpZE1hbmFnZXIgdGhyb3dzIGFuIGVycm9yIEFORCBjYWxscyBiYWNrIG9uIHRoZSBzZXRQcm90b2NvbEVycm9ySGFuZGxlciB3aGVuXG4gICAgICAgICAgICAvLyBhbiBhZ28gc2VydmljZSBuZWVkcyB0byBiZSBhY2Nlc3NlZCBvdmVyIHNzbCwgIHNvIHNldCB0aGlzIGZsYWcgdG8gZGlzdHVuZ3Vpc2ggYSB0eXBpY2FsIGVycm9yXG4gICAgICAgICAgICAvLyB2cyB0aGUgc2V0UHJvdG9jb2xFcnJvclxuICAgICAgICAgICAgaWYgKHNlY3VyZVNlcnZpY2UuaW5jbHVkZXMoKF9sID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmNvZGUpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IChfbSA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5kZXRhaWxzKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20uaHR0cFN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5hbGxvd1N0b3JlZEF1dGggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWxsb3dTdG9yZWRBdXRoID0gIWl0ZW0uY2hlY2tVcmxFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgaXNTZWN1cmVkOiB7IHNlY3VyZWQ6IHRydWUgfSwgc2VydmljZUluZm86IHsgaXNTZWN1cmU6IHRydWUgfSwgXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkgZGV0ZXJtaW5lIHRoYXQgd2UgY2FuJ3Qgc3RvcmUgYXV0aCB2aWEgYGNoZWNrVXJsYCwganVzdCBzZXQgaXQgdG8gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dTdG9yZWRBdXRoOiBpdGVtLmFsbG93U3RvcmVkQXV0aCA9PT0gZmFsc2UgPyBmYWxzZSA6IGFkZEl0ZW1TdGF0ZS5hbGxvd1N0b3JlZEF1dGggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmNvZGUpID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNlcnZpY2VJbmZvID0geyBpc1NlY3VyZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIGl0ZW0uaXNTZWN1cmVkID0geyBzZWN1cmVkOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcImZvcmJpZGRlbkNyZWRlbnRpYWxcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmICgoX28gPSBpdGVtLmNoZWNrVXJsRXJyb3IpID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEhhbmRsZSBlcnJvciBoZXJlIHVzaW5nIG91ciBzdGFuZGFyZCBmb3JtXG4gICAgICAgICAgICAgICAgaWYgKChfciA9IChfcSA9IChfcCA9IGl0ZW0uY2hlY2tVcmxFcnJvcikgPT09IG51bGwgfHwgX3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wLm1lc3NhZ2UpID09PSBudWxsIHx8IF9xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcS5pbmNsdWRlcykgPT09IG51bGwgfHwgX3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yLmNhbGwoX3EsIFwid2FzIG5vdCBmb3VuZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcInNlcnZpY2VOb3RFeGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoaXRlbS5jaGVja1VybEVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShpdGVtLmNoZWNrVXJsRXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKCEhYWdzVHlwZSAmJiBhZ3NUeXBlICE9PSBcIkZlYXR1cmVTZXJ2ZXJcIikgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiICYmIGVycm9yLmluY2x1ZGVzKFwibm90IGZvdW5kXCIpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHsgY29kZTogXCJzZXJ2aWNlTm90RXhpc3RcIiwgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0JhY2tlbmRFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgICAgICBlcnJvci5kZXRhaWxzWzBdID09PSBcIlRoZSBpbnB1dCBzcGF0aWFsIHJlZmVyZW5jZSBtdXN0IGJlIGVpdGhlciBhIGdlb2dyYXBoaWMgb3IgcHJvamVjdGVkIGNvb3JkaW5hdGUgc3lzdGVtXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZFNwYXRpYWxSZWZcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJldHJ5IDwgTUFYX1JFVFJZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFHU1NlcnZpY2VJbmZvKGl0ZW0sIGV4dHJhUGFyYW1zLCByZXRyeSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCgoX3MgPSBpdGVtLmlzU2VjdXJlZCkgPT09IG51bGwgfHwgX3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zLmlzRmVkZXJhdGVkV2l0aFdlYlRpZXJBdXRoKSB8fCAoKF90ID0gaXRlbS5pc1NlY3VyZWQpID09PSBudWxsIHx8IF90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdC5odHRwU3RhdHVzQ29kZSkgPT09IDQwMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyB0aXRsZSB9ID0gaXRlbTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VJbmZvID0gYXdhaXQgcmVxdWVzdChpdGVtLnVybCwge30sIHsgYWRkVG9rZW5NYW51YWxseTogZmFsc2UgfSk7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudEluZm8gPSBzZXJ2aWNlSW5mby5kb2N1bWVudEluZm87XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkcyA9IChkb2N1bWVudEluZm8uS2V5d29yZHMgfHwgXCJcIikuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgY29uc3QgdGFncyA9IFsuLi51bmlxdWUoWy4uLmtleXdvcmRzLCAuLi5pdGVtVGFnc10pXTtcbiAgICAgICAgICAgIGl0ZW0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IGV4dGVudDogc2VydmljZUluZm8uZnVsbEV4dGVudCB8fCBzZXJ2aWNlSW5mby5leHRlbnQsIHNlcnZpY2VJbmZvIH0pO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgdGl0bGUsIHRhZ3MgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7IGNvZGU6IFwidW5hdXRob3JpemVkXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHsgY29kZTogXCJzZXJ2aWNlTm90RXhpc3RcIiwgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBhZGRTZWN1cmVBR1NVcmwoaXRlbVByb3BlcnRpZXMpIHtcbiAgICBjb25zdCB7IHNlcnZpY2VJbmZvLCB1c2VybmFtZSwgcGFzc3dvcmQsIGlzU2VjdXJlZCwgc3RvcmVBdXRoLCB0eXBlIH0gPSBpdGVtUHJvcGVydGllcztcbiAgICBjb25zdCB7IHVzZXIsIHBvcnRhbCwgY29uZmlnIH0gPSBjb25maWdTdGF0ZTtcbiAgICBjb25zdCBpdGVtVHlwZSA9IHR5cGU7XG4gICAgY29uc3QgdXNlckluZm8gPSB7IHVzZXJuYW1lLCBwYXNzd29yZCB9O1xuICAgIGNvbnN0IHsgdGh1bWJuYWlsVVJMIH0gPSBnZXRJdGVtSW5mb0J5VHlwZShpdGVtVHlwZSk7XG4gICAgY29uc3QgaXRlbSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbVByb3BlcnRpZXMpLCB7IHRodW1ibmFpbFVSTDogdGh1bWJuYWlsVVJMIHx8IGl0ZW1Qcm9wZXJ0aWVzLnRodW1ibmFpbFVSTCB9KTtcbiAgICBpZiAoKChzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8uaXNTZWN1cmUpICYmICFzZXJ2aWNlSW5mby51c2VySW5mbykgfHxcbiAgICAgICAgKChpc1NlY3VyZWQgPT09IG51bGwgfHwgaXNTZWN1cmVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc1NlY3VyZWQuaXNPdmVycmlkZSkgJiYgIXVzZXJJbmZvKSB8fFxuICAgICAgICAoKGlzU2VjdXJlZCA9PT0gbnVsbCB8fCBpc1NlY3VyZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzU2VjdXJlZC5odHRwU3RhdHVzQ29kZSkgIT09IDQwMSAmJiAhdXNlckluZm8pIHx8XG4gICAgICAgIChzdG9yZUF1dGggJiYgIXVzZXJJbmZvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkQ3JlZGVudGlhbHNcIik7XG4gICAgfVxuICAgIGlmIChpc1NlY3VyZWQpIHtcbiAgICAgICAgaWYgKHN0b3JlQXV0aCkge1xuICAgICAgICAgICAgaWYgKCFwb3J0YWwuaXNQb3J0YWwgfHwgKHBvcnRhbC5pc1BvcnRhbCAmJiBjaGVja1Byb3RvY29sKCkpKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXJ2aWNlVXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgICAgICAgICAgICAgICBpdGVtLnNlcnZpY2VQYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTZWN1cmVkLmh0dHBTdGF0dXNDb2RlID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZGRJdGVtKGl0ZW0sIGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5yZXN0QmFzZVVybCkudGhlbigoeyBpZCB9KSA9PiByZXF1ZXN0KGAke3VzZXIudXNlckNvbnRlbnRVcmx9L2l0ZW1zLyR7aWR9YCwge30sIHt9LCBcInBvc3RcIikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJdGVtID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyBpZDogcmVzdWx0Lml0ZW0uaWQsIHVybDogcmVzdWx0Lml0ZW0udXJsLCBzb3VyY2VVcmw6IHJlc3VsdC5pdGVtLnNvdXJjZVVybCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkQUdTU2VydmljZSh1cGRhdGVkSXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmlzU2VjdXJlKSAmJiAhKHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby51c2VySW5mbykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkQ3JlZGVudGlhbHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFkZEFHU1NlcnZpY2UoaXRlbSk7XG59XG5hc3luYyBmdW5jdGlvbiBhZGRBR1NTZXJ2aWNlKGl0ZW1Qcm9wZXJ0aWVzLCB1cGRhdGUgPSBmYWxzZSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgeyB1cmwsIHNlcnZpY2VJbmZvLCB0eXBlLCBzdG9yZUF1dGgsIGh5YnJpZEltYWdlU2VydmljZVNldHRpbmcsIGlkIH0gPSBpdGVtUHJvcGVydGllcztcbiAgICBsZXQgc2luZ2xlbGF5ZXIgPSB7IFN0cmVhbVNlcnZlcjogMSwgSW1hZ2VTZXJ2ZXI6IDEsIFdvcmtzcGFjZVNlcnZlcjogMSB9LCBzZXJ2aWNlTGF5ZXJzO1xuICAgIGlmICghc2VydmljZUluZm8gJiYgIXN0b3JlQXV0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXJ2aWNlTm90RXhpc3RcIik7XG4gICAgfVxuICAgIGlmIChzdG9yZUF1dGggJiYgIXNlcnZpY2VJbmZvKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9wZXJ0aWVzID0gYXdhaXQgZ2V0QUdTU2VydmljZUluZm8oaXRlbVByb3BlcnRpZXMpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1cGRhdGVkUHJvcGVydGllcyksIHsgc3VjY2VzczogdHJ1ZSwgaWQsIGZvbGRlcjogKF9hID0gaXRlbVByb3BlcnRpZXMuZm9sZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGl0bGUgfSk7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWRJdGVtID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtUHJvcGVydGllcyksIHsgZGVzY3JpcHRpb246IChzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8uZGVzY3JpcHRpb24pIHx8ICgoX2IgPSBzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8uZG9jdW1lbnRJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuQ29tbWVudHMpIHx8IFwiXCIsIGFjY2Vzc0luZm9ybWF0aW9uOiAoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmNvcHlyaWdodFRleHQpIHx8ICgoX2MgPSBzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8uZG9jdW1lbnRJbmZvKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuQ3JlZGl0cykgfHwgXCJcIiwgc3BhdGlhbFJlZmVyZW5jZTogZ2V0U3BhdGlhbFJlZmVyZW5jZShpdGVtUHJvcGVydGllcy5zZXJ2aWNlSW5mbywgaXRlbVByb3BlcnRpZXMuYWdzVHlwZSkgfSk7XG4gICAgLy9Gb3IgaWNvbiBwdXJwb3NlcyB3ZSBjYW4gdXBkYXRlIHRoZVxuICAgIC8vdHlwZUtleXdvcmRzIHRvIHNob3cgZGlmZmVyZW50IGljb25zXG4gICAgaWYgKCh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR5cGUudG9Mb3dlckNhc2UoKSkgPT09IFwibWFwIHNlcnZpY2VcIikge1xuICAgICAgICB1cGRhdGVkSXRlbS50eXBlS2V5d29yZHMucHVzaCgoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLnNpbmdsZUZ1c2VkTWFwQ2FjaGUpID8gXCJUaWxlZFwiIDogXCJEeW5hbWljXCIpO1xuICAgIH1cbiAgICBpZiAoKHR5cGUgPT09IFwiSW1hZ2UgU2VydmljZVwiICYmIGh5YnJpZEltYWdlU2VydmljZVNldHRpbmcgPT09IFwiVGlsZWRJbWFnZVNlcnZlclwiKSB8fFxuICAgICAgICBpc1RpbGVzT25seUltYWdlU2VydmljZSh1cmwsIHNlcnZpY2VJbmZvKSkge1xuICAgICAgICB1cGRhdGVkSXRlbS50eXBlS2V5d29yZHMgPSBhZGRDcmVhdGVJdGVtVHlwZXMuVGlsZWRJbWFnZVNlcnZlci50eXBlS2V5d29yZHM7XG4gICAgfVxuICAgIGlmICgoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLnR5cGUpID09PSBcIlRhYmxlXCIpIHtcbiAgICAgICAgdXBkYXRlZEl0ZW0udHlwZUtleXdvcmRzID0gWy4uLnVwZGF0ZWRJdGVtLnR5cGVLZXl3b3JkcywgXCJUYWJsZVwiLCBcIlNpbmdsZWxheWVyXCJdO1xuICAgIH1cbiAgICBpZiAodHlwZSBpbiBzaW5nbGVsYXllcikge1xuICAgICAgICB1cGRhdGVkSXRlbS50eXBlS2V5d29yZHMucHVzaChcIlNpbmdsZWxheWVyXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmxheWVycykgfHwgKHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby50YWJsZXMpKSB7XG4gICAgICAgIGlmICgoIXNlcnZpY2VJbmZvLmxheWVycyB8fCAhKChfZCA9IHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5sYXllcnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpKSAmJiAoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLnRhYmxlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAvL0NoZWNrIGlmIFwiVGFibGVcIiB3YXMgYWRkZWQgYWJvdmUsIGRvbnQgd2FudCB0byBhZGQgaXQgdHdpY2VcbiAgICAgICAgICAgIGlmICh1cGRhdGVkSXRlbS50eXBlS2V5d29yZHMuZmluZEluZGV4KCh0eXBlKSA9PiB0eXBlID09PSBcIlRhYmxlXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRJdGVtLnR5cGVLZXl3b3Jkcy5wdXNoKFwiVGFibGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVkSXRlbS50eXBlS2V5d29yZHMucHVzaChzZXJ2aWNlSW5mby50YWJsZXMubGVuZ3RoID4gMSA/IFwiTXVsdGlsYXllclwiIDogXCJTaW5nbGVsYXllclwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlcnZpY2VMYXllcnMgPSBbLi4uKHNlcnZpY2VJbmZvLmxheWVycyB8fCBbXSksIC4uLihzZXJ2aWNlSW5mby50YWJsZXMgfHwgW10pXTtcbiAgICAgICAgICAgIHVwZGF0ZWRJdGVtLnR5cGVLZXl3b3Jkcy5wdXNoKHNlcnZpY2VMYXllcnMubGVuZ3RoID4gMSA/IFwiTXVsdGlsYXllclwiIDogXCJTaW5nbGVsYXllclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL0ZvciBpY29uIHB1cnBvc2VzIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSB0eXBlS2V5d29yZHMgZm9yIGEgU2NlbmVTZXJ2ZXIgYWRkZWQgYnkgcmVmZXJlbmNlXG4gICAgaWYgKCh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR5cGUudG9Mb3dlckNhc2UoKSkgPT09IFwic2NlbmVzZXJ2ZXJcIikge1xuICAgICAgICBjb25zdCB7IGxheWVycyB9ID0gc2VydmljZUluZm87XG4gICAgICAgIGNvbnN0IGxheWVyVHlwZSA9ICgoX2UgPSBsYXllcnMgPT09IG51bGwgfHwgbGF5ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllcnNbMF0pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5sYXllclR5cGUpIHx8IChzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8ubGF5ZXJUeXBlKTtcbiAgICAgICAgbGF5ZXJUeXBlICYmIHVwZGF0ZWRJdGVtLnR5cGVLZXl3b3Jkcy5wdXNoKGxheWVyVHlwZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZXh0ZW50OiB3Z3NFeHRlbnQgfSA9IGF3YWl0IHByb2plY3RFeHRlbnRUb1dHUzg0RnJvbUl0ZW0oT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlZEl0ZW0pKTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHVwZGF0ZWRJdGVtO1xuICAgICAgICBjb25zdCBpdGVtSW5mbyA9IGdldEl0ZW1JbmZvQnlUeXBlKGl0ZW0udHlwZSk7XG4gICAgICAgIGl0ZW0udHlwZSA9IGl0ZW1JbmZvLnR5cGU7XG4gICAgICAgIGl0ZW0udHlwZUtleXdvcmRzID0gWy4uLihpdGVtLnR5cGVLZXl3b3JkcyB8fCBbXSksIC4uLihpdGVtSW5mby50eXBlS2V5d29yZHMgfHwgW10pXTtcbiAgICAgICAgaWYgKCFzdG9yZUF1dGgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHVuaWZ5IGV4dGVudCBmb3JtYXR0aW5nLCB0aHVtYm5haWwgZ2VuZXJhdGlvbiBiZXR3ZWVuIGhlcmUgYW5kIHVwZGF0ZVByb3h5U2VydmljZVxuICAgICAgICAgICAgY29uc3QgZXh0ZW50QXNTdHJpbmcgPSBleHRlbnRUb1N0cmluZyhpdGVtLmV4dGVudCk7XG4gICAgICAgICAgICBjb25zdCBlID0gZXh0ZW50QXNTdHJpbmcuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkRXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgIFtwYXJzZUZsb2F0KGVbMF0pLCBwYXJzZUZsb2F0KGVbMV0pXSxcbiAgICAgICAgICAgICAgICBbcGFyc2VGbG9hdChlWzJdKSwgcGFyc2VGbG9hdChlWzNdKV1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpdGVtLmV4dGVudCA9IGZvcm1hdHRlZEV4dGVudDtcbiAgICAgICAgICAgIGNvbnN0IHRodW1ibmFpbFVSTCA9IGF3YWl0IGdldEFHU1RodW1ibmFpbChpdGVtKTtcbiAgICAgICAgICAgIGl0ZW0udGh1bWJuYWlsVVJMID0gdGh1bWJuYWlsVVJMO1xuICAgICAgICAgICAgaWYgKGl0ZW0udGh1bWJuYWlsVVJMICYmIGl0ZW0udGh1bWJuYWlsVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpdGVtLnRodW1ibmFpbFVSTCArPSBgJHtpdGVtLnRodW1ibmFpbFVSTC5pbmRleE9mKFwiP1wiKSA+IC0xID8gXCImXCIgOiBcIj9cIn0ke2l0ZW0udGh1bWJuYWlsVG9rZW59YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0uZXh0ZW50ID0gZXh0ZW50VG9TdHJpbmcoaXRlbS50eXBlID09PSBcIkZlYXR1cmUgU2VydmljZVwiID8gd2dzRXh0ZW50IDogaXRlbS5leHRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9yZUF1dGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQcm94eVNlcnZpY2UoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUl0ZW0oaXRlbS5pZCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyB1cmw6IGl0ZW0uc291cmNlVXJsIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRVcmwoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChzdG9yZUF1dGgpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRVcmwoaXRlbVByb3BlcnRpZXMpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVByb3h5U2VydmljZShpdGVtUHJvcGVydGllcykge1xuICAgIGNvbnN0IHsgdXNlciB9ID0gY29uZmlnU3RhdGU7XG4gICAgY29uc3QgeyBleHBvcnRUaWxlc0FsbG93ZWQgfSA9IGFkZEl0ZW1TdGF0ZTtcbiAgICBjb25zdCBjcmVhdGVkSXRlbSA9IGF3YWl0IGFkZFVybChpdGVtUHJvcGVydGllcyk7XG4gICAgY29uc3QgcmVxdWVzdFVybCA9IGAke3VzZXIudXNlckNvbnRlbnRVcmx9L2l0ZW1zLyR7Y3JlYXRlZEl0ZW0uaWR9YDtcbiAgICBjb25zdCB7IGl0ZW0gfSA9IGF3YWl0IHJlcXVlc3QocmVxdWVzdFVybCwge30sIHt9LCBcInBvc3RcIik7XG4gICAgY29uc3Qgc2VydmljZUluZm9VcmwgPSBleHBvcnRUaWxlc0FsbG93ZWQgPyBpdGVtUHJvcGVydGllcy51cmwgOiBpdGVtLnVybDtcbiAgICBjb25zdCB1cGRhdGVkSXRlbSA9IGF3YWl0IGdldEFHU1NlcnZpY2VJbmZvKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbVByb3BlcnRpZXMpLCB7IHR5cGU6IGFkZEl0ZW1TdGF0ZS50eXBlIH0pLCBzZXJ2aWNlSW5mb1VybCk7XG4gICAgY29uc3QgeyB0eXBlS2V5d29yZHMsIHRodW1ibmFpbFRva2VuLCBzcGF0aWFsUmVmZXJlbmNlLCBleHRlbnQsIGRlc2NyaXB0aW9uIH0gPSB1cGRhdGVkSXRlbTtcbiAgICBpdGVtUHJvcGVydGllcy5pZCA9IGNyZWF0ZWRJdGVtLmlkO1xuICAgIGl0ZW1Qcm9wZXJ0aWVzLnR5cGVLZXl3b3JkcyA9IHR5cGVLZXl3b3JkcztcbiAgICBpdGVtUHJvcGVydGllcy50aHVtYm5haWxUb2tlbiA9IHRodW1ibmFpbFRva2VuO1xuICAgIGl0ZW1Qcm9wZXJ0aWVzLnNwYXRpYWxSZWZlcmVuY2UgPSBzcGF0aWFsUmVmZXJlbmNlO1xuICAgIGl0ZW1Qcm9wZXJ0aWVzLmV4dGVudCA9IGV4dGVudDtcbiAgICBpdGVtUHJvcGVydGllcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIC8vIElOQzEwNTUzOTcgLSBPbiBpdHMgb3duLCBhIGZhaWxlZCB0aHVtYm5haWwgc2hvdWxkbid0IGRlcmFpbCB0aGUgd2hvbGUgdXBsb2FkIHByb2Nlc3MgKD8pXG4gICAgLy8gVE9ETzogSWYgbmVlZGVkLCB0aHJvdyBhIG1vcmUgc3BlY2lmaWMgZXJyb3IgaW4gdGhlIGNhdGNoIGJsb2NrXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0ZW50QXNTdHJpbmcgPSBleHRlbnRUb1N0cmluZyh1cGRhdGVkSXRlbS5leHRlbnQpO1xuICAgICAgICBjb25zdCBlID0gZXh0ZW50QXNTdHJpbmcuc3BsaXQoXCIsXCIpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRFeHRlbnQgPSBbXG4gICAgICAgICAgICBbcGFyc2VGbG9hdChlWzBdKSwgcGFyc2VGbG9hdChlWzFdKV0sXG4gICAgICAgICAgICBbcGFyc2VGbG9hdChlWzJdKSwgcGFyc2VGbG9hdChlWzNdKV1cbiAgICAgICAgXTtcbiAgICAgICAgaXRlbVByb3BlcnRpZXMuZXh0ZW50ID0gZm9ybWF0dGVkRXh0ZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNpbmcgdGhlIG5ld2x5IGNyZWF0ZWQgaXRlbSdzIHVybCBzb21ldGltZXMgdGhyb3cgYW4gXCJJbnZhbGlkIFVSTFwiIGVycm9yXG4gICAgICAgICAqIGlmIHRoZSBpcyBjcmVhdGVkIGZyb20gVVJMIHdpdGggc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGl0cyBuYW1lIGZvciBzb21lIHJlYXNvblxuICAgICAgICAgKiBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvNDY5NDZcbiAgICAgICAgICogU28gd2UgaGF2ZSB0byB1c2UgdGhlIG9yaWdpbmFsIHVybCB0aGF0IHdhcyBlbnRlcmVkIGJ5IHRoZSB1c2VyXG4gICAgICAgICAqIFNob3VsZCBoYXZlIHRoZSBzYW1lIHRodW1ibmFpbCB0ZWNobmljYWxseVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdGh1bWJuYWlsVVJMID0gYXdhaXQgZ2V0QUdTVGh1bWJuYWlsKGl0ZW1Qcm9wZXJ0aWVzKTtcbiAgICAgICAgaXRlbS50aHVtYm5haWxVUkwgPSB0aHVtYm5haWxVUkw7XG4gICAgICAgIGlmIChpdGVtLnRodW1ibmFpbFVSTCAmJiBpdGVtLnRodW1ibmFpbFRva2VuKSB7XG4gICAgICAgICAgICBpdGVtLnRodW1ibmFpbFVSTCArPSBgJHtpdGVtLnRodW1ibmFpbFVSTC5pbmRleE9mKFwiP1wiKSA+IC0xID8gXCImXCIgOiBcIj9cIn0ke2l0ZW0udGh1bWJuYWlsVG9rZW59YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGF3YWl0IHVwZGF0ZUl0ZW0oY3JlYXRlZEl0ZW0uaWQsIHsgdGh1bWJuYWlsVVJMOiBpdGVtLnRodW1ibmFpbFVSTCB9KTtcbiAgICByZXR1cm4gY3JlYXRlZEl0ZW07XG59XG5cbmNvbnN0IG92ZXJyaWRlVXJscyA9IFtcbiAgICBcImdlb2NvZGUuYXJjZ2lzLmNvbVwiLFxuICAgIFwiZ2VvY29kZWRldi5hcmNnaXMuY29tXCIsXG4gICAgXCJnZW9jb2RlcWEuYXJjZ2lzLmNvbVwiLFxuICAgIFwicm91dGUuYXJjZ2lzLmNvbVwiLFxuICAgIFwicm91dGVkZXYuYXJjZ2lzLmNvbVwiLFxuICAgIFwicm91dGVxYS5hcmNnaXMuY29tXCIsXG4gICAgXCJnZW9lbnJpY2guYXJjZ2lzLmNvbVwiLFxuICAgIFwiZ2VvZW5yaWNocWEuYXJjZ2lzLmNvbVwiLFxuICAgIFwiZ2VvZW5yaWNoZGRldi5hcmNnaXMuY29tXCJcbl07XG5hc3luYyBmdW5jdGlvbiBnZXRJc1NlY3VyZWQodXNlckluZm8sIHNlcnZpY2VVcmwsIHJlc3RCYXNlVXJsLCBjaGVja0F1dGgsIGNoZWNrQXV0aFZpYVNlcnZpY2VVcmwgPSBmYWxzZSkge1xuICAgIC8vIHRoZSAvY2hlY2tVUkwgY2FsbCB3aWxsIHJlc3BvbmQgd2hldGhlciBhIHNlcnZpY2UgbmVlZHMgYXV0aGVudGljYXRpb24gb3Igbm90LlxuICAgIGNvbnN0IHVybCA9IHNlcnZpY2VVcmwuc3BsaXQoXCI/XCIpWzBdO1xuICAgIGNvbnN0IHNlY3VyZWRVUkwgPSBgJHtyZXN0QmFzZVVybH1wb3J0YWxzL2NoZWNrdXJsYDtcbiAgICBjb25zdCBpc092ZXJyaWRlVXJsID0gb3ZlcnJpZGVVcmxzLnNvbWUoKHVybCkgPT4gc2VydmljZVVybC5pbmRleE9mKHVybCkgIT09IC0xKTtcbiAgICBpZiAoaXNPdmVycmlkZVVybCkge1xuICAgICAgICByZXR1cm4geyBzZWN1cmVkOiB0cnVlLCBpc092ZXJyaWRlOiB0cnVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBpc1ZlY3RvclRpbGVTZXJ2aWNlID0gIWlzT3ZlcnJpZGVVcmwgJiYgc2VydmljZVVybC5pbmRleE9mKFwiL1ZlY3RvclRpbGVTZXJ2ZXJcIikgPiAtMTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFVybCA9IGAke3NlY3VyZWRVUkx9P3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChgJHthZGRQYXJhbWV0ZXJzKGAke3VybH0/Zj1qc29uYCl9YCl9YDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjaGVja0F1dGhWaWFTZXJ2aWNlVXJsKSB7XG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuYWwgVVJMcyBjYW5ub3QgYmUgY2hlY2tlZCB2aWEgYGNoZWNrVXJsYCwgYW5kIG11c3QgY2hlY2sgdGhlIHNlcnZpY2UgaXRzZWxmLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBgRXJyb3IgY2hlY2tpbmcgcmVzb3VyY2VgIG1lc3NhZ2Ugd2FzIGNhdWdodCBwcmV2aW91c2x5LCB0aGlzIHdpbGwgcGluZyB0aGUgc2VydmljZSBhbmRcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBhbiBhdXRoIHBvcHVwIGlmIHRoZSBpbnRlcm5hbCBzZXJ2aWNlIGlzIHNlY3VyZWQsIHRoZW4gaGlkZSB0aGUgc3RvcmVkIGF1dGggdG9nZ2xlLlxuICAgICAgICAgICAgICAgIC8vIFJlZjogaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAvaXNzdWVzLzQxNDUxI2lzc3VlY29tbWVudC0zODA4Njc0XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVxdWVzdCh1cmwsIHt9LCB7IGRpc2FibGVJZGVudGl0eUxvb2t1cDogdHJ1ZSwgYWRkVG9rZW5NYW51YWxseTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0KHJlcXVlc3RVcmwsIHt9LCB7IGFkZFRva2VuTWFudWFsbHk6IGZhbHNlIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBodHRwU3RhdHVzQ29kZSB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zZWN1cmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGh0dHBTdGF0dXNDb2RlID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9TZWUgaHR0cHM6Ly9kZXZ0b3BpYS9XZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAvaXNzdWVzLzUxIDQwMyBjb25zaWRlcmVkIG5vdC1zZWN1cmVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNlY3VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaHR0cFN0YXR1c0NvZGUgPT09IDQwMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvMzU5ODEgd2ViIHRpZXIgYXV0aCBkb2Vzbid0IGFsbG93IHN0b3JpbmcgY3JlZGVudGlhbHNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFsbG93U3RvcmVkQXV0aCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVmVjdG9yVGlsZVNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdmVjdG9yVGlsZSBzZXJ2aWNlcyB3aGVyZSB0aGUgcm9vdCB1cmwgaXMgbm90IHNlY3VyZWQsIGJ1dCBleHBvcnRUaWxlc0FsbG93ZWQgPSB0cnVlLCBtYXkgaGF2ZSB0aGUgXCJleHBvclRpbGVzXCIgZW5kcG9pbnQgc2VjdXJlZCxcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIHRoYXQgaGVyZSwgaWYgaXQgaXMgc2VjdXJlZCB0aGVuIHdlIG5lZWQgdG8gcHJvbXB0IGZvciBjcmVkZW50aWFscyBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvMTk1MTBcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2aWNlSW5mbyA9IGF3YWl0IGdldFNlcnZpY2VJbmZvKHsgdXNlcm5hbWU6IHVzZXJJbmZvLnVzZXJuYW1lLCBwYXNzd29yZDogdXNlckluZm8ucGFzc3dvcmQgfSwgc2VydmljZVVybCwgeyBpc1ZpZGVvU2VydmljZTogZmFsc2UsIGNoZWNrQXV0aCB9KTtcbiAgICAgICAgICAgICAgICBhZGRJdGVtU3RhdGUuZXhwb3J0VGlsZXNBbGxvd2VkID0gc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmV4cG9ydFRpbGVzQWxsb3dlZDtcbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmV4cG9ydFRpbGVzQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SXNTZWN1cmVkKHVzZXJJbmZvLCBgJHtzZXJ2aWNlVXJsfS9leHBvcnRUaWxlc2AsIHJlc3RCYXNlVXJsLCBjaGVja0F1dGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCksIHsgaXNPdmVycmlkZTogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIGNvZGUgfSA9IGVycm9yO1xuICAgICAgICAgICAgLy8gSW50ZXJuYWwgc2VydmljZSBVUkwgZGV0ZWN0ZWRcbiAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSBcIkVycm9yIGNoZWNraW5nIHJlc291cmNlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCByZS1ydW4gaWYgd2UgYWxyZWFkeSB0cmllZCB0byBjaGVjayB0aGUgYXV0aCB2aWEgdGhlIFVSTFxuICAgICAgICAgICAgICAgIC8vIFRPRE8gcG9zdCAyMDIzUjAzOiBhZGQgYW4gZXhwbGljaXQgY2FzZSB0byBoYW5kbGUgaW50ZXJuYWwgVVJMcyBvdXRzaWRlIHRoZSBjYXRjaCBibG9ja1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0F1dGhWaWFTZXJ2aWNlVXJsXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHNlcnZpY2VVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwUmVzcG9uc2U6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwU3RhdHVzQ29kZTogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBTdGF0dXNNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNPdmVycmlkZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1N0b3JlZEF1dGg6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBnZXRJc1NlY3VyZWQodXNlckluZm8sIHNlcnZpY2VVcmwsIHJlc3RCYXNlVXJsLCBjaGVja0F1dGgsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZSA9PT0gXCJTZXJ2aWNlIFByb3h5IFVSTFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzZXJ2aWNlVXJsLFxuICAgICAgICAgICAgICAgICAgICBodHRwUmVzcG9uc2U6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGh0dHBTdGF0dXNDb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICBodHRwU3RhdHVzTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgaXNPdmVycmlkZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93U3RvcmVkQXV0aDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVzZVByb3h5OiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWxsb3dTdG9yZWRBdXRoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1cmw6IHNlcnZpY2VVcmwsXG4gICAgICAgICAgICAgICAgaHR0cFJlc3BvbnNlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGh0dHBTdGF0dXNDb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIGh0dHBTdGF0dXNNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIGlzT3ZlcnJpZGU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFc3JpSG9zdGVkU2VydmljZSh1cmwpIHtcbiAgICAvLyBlc3JpIGhvc3RlZCBzZXJ2aWNlOiBodHRwczovL2RldjAwMTEyMTEuZXNyaS5jb20vc2VydmVyL3Jlc3Qvc2VydmljZXMvSG9zdGVkL0NhbGlmb3JuaWEvRmVhdHVyZVNlcnZlclxuICAgIHJldHVybiB1cmwuaW5kZXhPZihcIi5lc3JpLmNvbS9zZXJ2ZXIvcmVzdC9zZXJ2aWNlc1wiKSA+IC0xID8gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNIeWJyaWRJbWFnZVNlcnZpY2UodXJsLCBzZXJ2aWNlSW5mbykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHVybC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCIvaW1hZ2VzZXJ2ZXJcIikgPiAtMSAmJlxuICAgICAgICAoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmNhY2hlVHlwZSkgPT09IFwiUmFzdGVyXCIgJiZcbiAgICAgICAgKChfYSA9IHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5jYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ0aWxlc29ubHlcIikpID09PSAtMSk7XG59XG5mdW5jdGlvbiBpc1RpbGVzT25seUltYWdlU2VydmljZSh1cmwsIHNlcnZpY2VJbmZvKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKChfYSA9IHVybC50b0xvd2VyQ2FzZSgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoXCIvaW1hZ2VzZXJ2ZXJcIikpICYmICgoX2IgPSBzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8uY2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRpbGVzb25seVwiKSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTZXJ2aWNlSW5mbyh1c2VySW5mbywgc3ZjVXJsLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ1N0YXRlLmNvbmZpZztcbiAgICBjb25zdCBbZXNyaUlkXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgY29uZmlnU3RhdGUuYXBpID09PSAzID8gXCJlc3JpL0lkZW50aXR5TWFuYWdlclwiIDogXCJlc3JpL2lkZW50aXR5L0lkZW50aXR5TWFuYWdlclwiXG4gICAgXSk7XG4gICAgY29uc3QgeyBmb3JjZUFkZFRva2VuLCBpc1NlY3VyZSwgY2hlY2tBdXRoIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSB1c2VySW5mbztcbiAgICBjb25zdCBtZXRob2QgPSBcImF1dG9cIjtcbiAgICBjb25zdCBpc0hvc3RlZCA9IGlzSG9zdGVkU2VydmljZShzdmNVcmwpO1xuICAgIGNvbnN0IGlzRVNSSSA9IGlzRXNyaUhvc3RlZFNlcnZpY2Uoc3ZjVXJsKTtcbiAgICBjb25zdCBob3N0ZWRTZXJ2aWNlID0gaXNIb3N0ZWQgfHwgaXNFU1JJO1xuICAgIGNvbnN0IGlzT3ZlcnJpZGVVcmwgPSBvdmVycmlkZVVybHMuc29tZSgodXJsKSA9PiBzdmNVcmwuaW5kZXhPZih1cmwpICE9PSAtMSk7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIHVzZVByb3h5OiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXNlUHJveHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICB0aW1lb3V0OiBjb25maWcuaXNNdWx0aVRlbmFudCA9PT0gZmFsc2UgPyA2MDAwMCA6IDUwMDAsXG4gICAgICAgIGFkZFNTTDogaG9zdGVkU2VydmljZSxcbiAgICAgICAgYWRkVG9rZW5NYW51YWxseTogKGlzU2VjdXJlICYmIGhvc3RlZFNlcnZpY2UgJiYgISFjb25maWcuaXNNdWx0aVRlbmFudCkgfHwgZm9yY2VBZGRUb2tlbiB8fCBmYWxzZSxcbiAgICAgICAgZGlzYWJsZUlkZW50aXR5TG9va3VwOiBudWxsXG4gICAgfTtcbiAgICBpZiAoY2hlY2tBdXRoKSB7XG4gICAgICAgIHN2Y1VybCA9IHN2Y1VybC5zcGxpdChcIj9cIilbMF07XG4gICAgICAgIGlmIChpc092ZXJyaWRlVXJsKSB7XG4gICAgICAgICAgICBhd2FpdCBzaWduSW4oc3ZjVXJsLCB7IHVzZXJuYW1lLCBwYXNzd29yZCB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlSW5mb1JlcXVlc3Qoc3ZjVXJsLCByZXF1ZXN0T3B0aW9ucywgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1NlY3VyZS5zZWN1cmVkICYmIHVzZXJuYW1lICYmIHBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuY3VzdG9tVG9rZW4gPSBhd2FpdCBnZXRTZWN1cmVkU2VydmljZUN1c3RvbVRva2VuKHN2Y1VybCwgeyB1c2VybmFtZSwgcGFzc3dvcmQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWaWRlbyBTZXJ2aWNlIFVSTCBkb2Vzbid0IGFjY2VwdCBQT1NUIG1ldGhvZFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZUluZm9SZXF1ZXN0KHN2Y1VybCwgcmVxdWVzdE9wdGlvbnMsIG1ldGhvZCk7XG4gICAgICAgICAgICByZXN1bHQuY3JlZGVudGlhbCA9IGVzcmlJZC5maW5kQ3JlZGVudGlhbChzdmNVcmwpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jcmVkZW50aWFsKSB7XG4gICAgICAgICAgICAgICAgZXNyaUlkLnJlZ2lzdGVyVG9rZW4oe1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXI6IHN2Y1VybCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHJlc3VsdC5jcmVkZW50aWFsLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IHJlc3VsdC5jcmVkZW50aWFsLnVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJlczogcmVzdWx0LmNyZWRlbnRpYWwuZXhwaXJlcyxcbiAgICAgICAgICAgICAgICAgICAgc3NsOiByZXN1bHQuY3JlZGVudGlhbC5zc2xcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYGRpc2FibGVJZGVudGl0eUxvb2t1cGAgd2lsbCBvdmVycmlkZSB0aGUgSWQgbWFuYWdlciBpbiBFU1JJUmVxdWVzdCBzbyB0aGF0IGl0IGRvZXNudCByZW5kZXIgdGhlIGF1dGggd2luZG93IC0gd2hpY2ggaGFzIGJlZW4gYSBwYWluIHBvaW50IGZvciBjZXJ0YWluIHVybHMgLSBpZiB5b3UgaGF2ZSBhbiBpc3N1ZSB3aXRoIGF1dGhlbnRpY2F0aW9uIGFuZCB0aGUgSUQgbWFuYWdlciBjaGVjayBoZXJlIGZpcnN0LlxuICAgIHJlcXVlc3RPcHRpb25zLmRpc2FibGVJZGVudGl0eUxvb2t1cCA9IHRydWU7XG4gICAgcmV0dXJuIGF3YWl0IHNlcnZpY2VJbmZvUmVxdWVzdChzdmNVcmwsIHJlcXVlc3RPcHRpb25zLCBtZXRob2QpO1xufVxuLyoqXG4gKiBBdHRlbXB0IHRvIHNpZ24gaW4gdXNpbmcgSWRlbnRpdHkgbWFuYWdlciBhbmQgcmV0dXJuIHRoZSB0b2tlblxuICpcbiAqIFdpbGwgcmV0cmlldmUgZnJvbSBjYWNoZSBmaXJzdCBpZiBub3QgZXhwaXJlZFxuICovXG5jb25zdCBnZXRTZWN1cmVkU2VydmljZUN1c3RvbVRva2VuID0gYXN5bmMgKHVybCwgeyB1c2VybmFtZSwgcGFzc3dvcmQgfSkgPT4ge1xuICAgIGNvbnN0IHsgdG9rZW4gfSA9IGF3YWl0IGZyb21DYWNoZSgoKSA9PiBzaWduSW4odXJsLCB7IHVzZXJuYW1lLCBwYXNzd29yZCB9KSwgXCJzZWN1cmVkQUdTVG9rZW5cIiwgYCR7dXJsfS0tLSR7dXNlcm5hbWV9YCwgeyBnZXRFeHBpcmVBZnRlckZyb21SZXN1bHQ6IChyZXN1bHQpID0+IHJlc3VsdC5leHBpcmVBZnRlciB9KTtcbiAgICByZXR1cm4gdG9rZW47XG59O1xuYXN5bmMgZnVuY3Rpb24gc2lnbkluKHN2Y1VybCwgdXNlckluZm8pIHtcbiAgICBjb25zdCBpczN4ID0gY29uZmlnU3RhdGUuYXBpID09PSAzO1xuICAgIGNvbnN0IFtlc3JpSWQsIENyZWRlbnRpYWxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgICAgICBpczN4ID8gXCJlc3JpL0lkZW50aXR5TWFuYWdlclwiIDogXCJlc3JpL2lkZW50aXR5L0lkZW50aXR5TWFuYWdlclwiLFxuICAgICAgICBpczN4ID8gXCJlc3JpL0NyZWRlbnRpYWxcIiA6IFwiZXNyaS9pZGVudGl0eS9DcmVkZW50aWFsXCJcbiAgICBdKTtcbiAgICBpZiAodXNlckluZm8udXNlcm5hbWUgJiYgdXNlckluZm8ucGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3Qgc2VydmVySW5mbyA9IGF3YWl0IGZpbmRTZXJ2ZXJJbmZvKHN2Y1VybCk7XG4gICAgICAgIGlmIChlc3JpSWQuX2NoZWNrUHJvdG9jb2woc3ZjVXJsLCBzZXJ2ZXJJbmZvLCAoZXJyb3IpID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVzcmlJZC5nZW5lcmF0ZVRva2VuKHNlcnZlckluZm8sIHVzZXJJbmZvKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBpcmVzID0gcmVzcG9uc2UuZXhwaXJlcyA/IE51bWJlcihyZXNwb25zZS5leHBpcmVzKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3NsID0gISFyZXNwb25zZS5zc2w7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlZCA9IG5ldyBDcmVkZW50aWFsKHtcbiAgICAgICAgICAgICAgICAgICAgdXNlcklkOiB1c2VySW5mby51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyOiBzZXJ2ZXJJbmZvLnNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHJlc3BvbnNlLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzLFxuICAgICAgICAgICAgICAgICAgICBzc2wsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkaXR5OiBzZXJ2ZXJJbmZvLnNob3J0TGl2ZWRUb2tlblZhbGlkaXR5LFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXM6IFtzdmNVcmxdLFxuICAgICAgICAgICAgICAgICAgICBzY29wZTogXCJzZXJ2ZXJcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChlc3JpSWQuY3JlZGVudGlhbHMuaW5kZXhPZihjcmVkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNyaUlkLmNyZWRlbnRpYWxzLnB1c2goY3JlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRva2VuOiBjcmVkLnRva2VuLCBleHBpcmVBZnRlcjogZXhwaXJlcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IDQwMztcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBmaW5kU2VydmVySW5mbyhzZXJ2aWNlVXJsKSB7XG4gICAgY29uc3QgaXMzeCA9IGNvbmZpZ1N0YXRlLmFwaSA9PT0gMztcbiAgICBjb25zdCBbZXNyaUlkLCBTZXJ2ZXJJbmZvXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgaXMzeCA/IFwiZXNyaS9JZGVudGl0eU1hbmFnZXJcIiA6IFwiZXNyaS9pZGVudGl0eS9JZGVudGl0eU1hbmFnZXJcIixcbiAgICAgICAgaXMzeCA/IFwiZXNyaS9TZXJ2ZXJJbmZvXCIgOiBcImVzcmkvaWRlbnRpdHkvU2VydmVySW5mb1wiXG4gICAgXSk7XG4gICAgbGV0IHNlcnZlckluZm8gPSBhd2FpdCBlc3JpSWQuZmluZFNlcnZlckluZm8oc2VydmljZVVybCk7XG4gICAgaWYgKCFzZXJ2ZXJJbmZvKSB7XG4gICAgICAgIHNlcnZlckluZm8gPSBuZXcgU2VydmVySW5mbygpO1xuICAgICAgICBzZXJ2ZXJJbmZvLnNlcnZlciA9IGF3YWl0IGVzcmlJZC5fZ2V0T3JpZ2luKHNlcnZpY2VVcmwpO1xuICAgICAgICBjb25zdCB7IGF1dGhJbmZvLCB0b2tlblNlcnZpY2VVcmwsIGN1cnJlbnRWZXJzaW9uIH0gPSBhd2FpdCAoaXMzeCA/IGdldDN4VG9rZW5TdmNVcmwgOiBnZXQ0eFRva2VuU3ZjVXJsKShzZXJ2aWNlVXJsLCBlc3JpSWQpO1xuICAgICAgICBzZXJ2ZXJJbmZvLnRva2VuU2VydmljZVVybCA9XG4gICAgICAgICAgICAoYXV0aEluZm8gPT09IG51bGwgfHwgYXV0aEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1dGhJbmZvLnRva2VuU2VydmljZXNVcmwpIHx8XG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLS0tIHNlZW1zIGxpa2Ugd2UgZGlkIHRoaXMgcHJldmlvdXNseSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgYnV0IGl0IGRvZXNuJ3QgZXhpc3Qgb24gU2VydmVySW5mb1xuICAgICAgICAgICAgICAgIGF1dGhJbmZvID09PSBudWxsIHx8IGF1dGhJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoSW5mby50b2tlblNlcnZpY2VVcmwpIHx8XG4gICAgICAgICAgICAgICAgdG9rZW5TZXJ2aWNlVXJsO1xuICAgICAgICBzZXJ2ZXJJbmZvLmN1cnJlbnRWZXJzaW9uID0gY3VycmVudFZlcnNpb247XG4gICAgICAgIHNlcnZlckluZm8uaGFzU2VydmVyID0gdHJ1ZTtcbiAgICAgICAgZXNyaUlkLnJlZ2lzdGVyU2VydmVycyhbc2VydmVySW5mb10pO1xuICAgIH1cbiAgICByZXR1cm4gc2VydmVySW5mbztcbn1cbmNvbnN0IGdldDR4VG9rZW5TdmNVcmwgPSBhc3luYyAoc2VydmljZVVybCwgZXNyaUlkKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgZXNyaUlkLl9nZXRUb2tlblN2Y1VybChzZXJ2aWNlVXJsKSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLnByb21pc2U7XG59O1xuY29uc3QgZ2V0M3hUb2tlblN2Y1VybCA9IGFzeW5jIChzZXJ2aWNlVXJsLCBlc3JpSWQpID0+IHtcbiAgICByZXR1cm4gZXNyaUlkLl9nZXRUb2tlblN2Y1VybChzZXJ2aWNlVXJsKTtcbn07XG5hc3luYyBmdW5jdGlvbiBzZXJ2aWNlSW5mb1JlcXVlc3Qoc2VydmljZVVybCwgb3B0aW9ucywgbWV0aG9kID0gXCJwb3N0XCIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdChhZGRQYXJhbWV0ZXJzKHNlcnZpY2VVcmwpLCB7fSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIG1ldGhvZCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRVcmxTZXJ2aWNlSW5mbyhpdGVtKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgdXJsU2VydmljZUluZm8gPSB7fTtcbiAgICBpZiAoaXNBR1MoaXRlbS50eXBlKSkge1xuICAgICAgICB1cmxTZXJ2aWNlSW5mbyA9IGF3YWl0IGdldFNlY3VyZWRBR1NTZXJ2aWNlSW5mbyhpdGVtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiT0dDRmVhdHVyZVNlcnZlclwiOlxuICAgICAgICAgICAgICAgIHVybFNlcnZpY2VJbmZvID0gYXdhaXQgZ2V0T0dDRmVhdHVyZUxheWVyU2VydmljZUluZm8oaXRlbSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV01TXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSBhd2FpdCBnZXRXTVNTZXJ2aWNlSW5mbyhpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsU2VydmljZUluZm8uZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdtc0xheWVycyA9IGF3YWl0IGxvYWRXTVNMYXllcnMocmVzdWx0LnNlcnZpY2VJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgdXJsU2VydmljZUluZm8ucmVzdWx0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCB3bXNMYXllcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXRlNcIjpcbiAgICAgICAgICAgICAgICB1cmxTZXJ2aWNlSW5mbyA9IGF3YWl0IGdldFdGU1NlcnZpY2VJbmZvKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmICh1cmxTZXJ2aWNlSW5mby5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsU2VydmljZUluZm8ucmVzdWx0LmxheWVycyA9IHVybFNlcnZpY2VJbmZvLnJlc3VsdC5zZXJ2aWNlSW5mby5sYXllcnM7XG4gICAgICAgICAgICAgICAgICAgIHVybFNlcnZpY2VJbmZvLnJlc3VsdC50aXRsZSA9IChfYSA9IHVybFNlcnZpY2VJbmZvLnJlc3VsdC5zZXJ2aWNlSW5mby50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgdXJsU2VydmljZUluZm8ucmVzdWx0LmlzQ29tcGxleCA9IHVybFNlcnZpY2VJbmZvLnJlc3VsdC5zZXJ2aWNlSW5mby5pc0NvbXBsZXggPT09IFwiZXNyaUdlb21ldHJ5Q29tcGxleFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXTVRTXCI6XG4gICAgICAgICAgICAgICAgdXJsU2VydmljZUluZm8gPSBhd2FpdCBnZXRXTVRTU2VydmljZUluZm8oaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHVybFNlcnZpY2VJbmZvLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB1cmxTZXJ2aWNlSW5mby5yZXN1bHQubGF5ZXJzID0gdXJsU2VydmljZUluZm8ucmVzdWx0LnNlcnZpY2VJbmZvLmxheWVycztcbiAgICAgICAgICAgICAgICAgICAgdXJsU2VydmljZUluZm8ucmVzdWx0LnRpdGxlID0gKF9iID0gdXJsU2VydmljZUluZm8ucmVzdWx0LnNlcnZpY2VJbmZvLnRpdGxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdXJsU2VydmljZUluZm8gPSB7IHJlc3VsdDogT2JqZWN0LmFzc2lnbih7fSwgaXRlbSkgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsU2VydmljZUluZm87XG59XG4vLyBXZSBuZWVkIHRvIHNlbmQgbGF5ZXIncyByZWxhdGlvbnNoaXAgaW4gYSBzZXBhcmF0ZSAvYWRkVG9EZWZpbml0aW9uIGNhbGxcbi8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy80MzE5XG4vLyBTbyB0aGlzIGZ1bmN0aW9uIHNob3VsZCBOT1QgYWNjZXB0IGxheWVycy90YWJsZXMgd2l0aCByZWxhdGlvbnNoaXBzXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTZXJ2aWNlKHNlcnZpY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8vIFNwcmVhZCB0byBhdm9pZCBtYW5pcHVsYXRpbmcgdGhlIG9yaWdpbmFsIGNvbnRlbnRcbiAgICBjb25zdCBjb3BpZWRTZXJ2aWNlID0gT2JqZWN0LmFzc2lnbih7fSwgc2VydmljZSk7XG4gICAgY29uc3QgeyBjb25maWcsIHVzZXIsIGFzeW5jQWRkVG9EZWZpbml0aW9uID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhZGRUb0RlZmluaXRpb25Db250ZW50ID0ge1xuICAgICAgICBsYXllcnM6IChfYSA9IGNvcGllZFNlcnZpY2UubGF5ZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgdGFibGVzOiAoX2IgPSBjb3BpZWRTZXJ2aWNlLnRhYmxlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW11cbiAgICB9O1xuICAgIGNvbnN0IGFkZFRvRGVmaW5pdGlvblJlcXVlc3RDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoYWRkVG9EZWZpbml0aW9uQ29udGVudCk7XG4gICAgLy8gQ3JlYXRlIHNlcnZpY2UgZmFpbHMgaWYgcGFzc2luZyBsYXllcnMsIHRhYmxlc1xuICAgIGRlbGV0ZSBjb3BpZWRTZXJ2aWNlLmxheWVycztcbiAgICBkZWxldGUgY29waWVkU2VydmljZS50YWJsZXM7XG4gICAgZGVsZXRlIGNvcGllZFNlcnZpY2UuaW5pdGlhbEV4dGVudDtcbiAgICBkZWxldGUgY29waWVkU2VydmljZS5mdWxsRXh0ZW50O1xuICAgIGRlbGV0ZSBjb3BpZWRTZXJ2aWNlLl9zc2w7XG4gICAgY29uc3QgY3JlYXRlU2VydmljZUNvbnRlbnQgPSB7IGNyZWF0ZVBhcmFtZXRlcnM6IEpTT04uc3RyaW5naWZ5KGNvcGllZFNlcnZpY2UpLCB0YXJnZXRUeXBlOiBcImZlYXR1cmVTZXJ2aWNlXCIgfTtcbiAgICBjb25zdCB1cmwgPSBgJHtjb25maWcucmVzdEJhc2VVcmx9Y29udGVudC91c2Vycy8ke3VzZXIudXNlcm5hbWV9L2NyZWF0ZVNlcnZpY2VgO1xuICAgIGNvbnN0IGNyZWF0ZVNlcnZpY2VSZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QodXJsLCBjcmVhdGVTZXJ2aWNlQ29udGVudCwge30sIFwicG9zdFwiKTtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBhZGRUb0RlZmluaXRpb24oYWRkVG9EZWZpbml0aW9uUmVxdWVzdENvbnRlbnQsIGNyZWF0ZVNlcnZpY2VSZXNwb25zZS5lbmNvZGVkU2VydmljZVVSTCwgYXN5bmNBZGRUb0RlZmluaXRpb24pO1xuICAgICAgICByZXR1cm4geyBjcmVhdGVTZXJ2aWNlUmVzcG9uc2UsIGFkZFRvRGVmaW5pdGlvblJlc3BvbnNlOiBhZGRUb0RlZmluaXRpb25Db250ZW50IH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2VyZSBlcnJvcnMgYWRkaW5nIHRvIHRoZSBkZWZpbml0aW9uLCBjbGVhbiB1cCBhZnRlciBvdXJzZWx2ZXMgYW5kIGRlbGV0ZSB0aGUgc2VydmljZVxuICAgICAgICBjb25zdCBkZWxldGVVcmwgPSBgJHt1c2VyLnVzZXJDb250ZW50VXJsfS9pdGVtcy8ke2NyZWF0ZVNlcnZpY2VSZXNwb25zZS5pdGVtSWR9L2RlbGV0ZWA7XG4gICAgICAgIGF3YWl0IHJlcXVlc3QoZGVsZXRlVXJsLCB7fSwge30sIFwicG9zdFwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYWRkVG9EZWZpbml0aW9uKHBhcmFtcywgZW5jb2RlZFNlcnZpY2VVUkwsIGFzeW5jID0gdHJ1ZSkge1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRtaW5VcmwgPSBlbmNvZGVkU2VydmljZVVSTC5yZXBsYWNlKFwicmVzdC9zZXJ2aWNlc1wiLCBcInJlc3QvYWRtaW4vc2VydmljZXNcIik7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke2FkbWluVXJsfS9hZGRUb0RlZmluaXRpb25gO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdCh1cmwsIHsgYWRkVG9EZWZpbml0aW9uOiBwYXJhbXMsIGFzeW5jIH0sIHt9LCBcInBvc3RcIik7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmMgPyBhd2FpdCBwb2xsRm9yU3RhdHVzKHJlc3VsdC5zdGF0dXNVUkwpIDogcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIGVycm9yIGdyYWNlZnVsbHlcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBvbmNlIHRoZSBiYWNrZW5kIHNob3dzIG1lYW5pbmdmdWwgZXJyb3JzIG9uIGBhc3luYzogdHJ1ZWBcbiAgICAgICAgICAgICAgICAvLyBgYXN5bmM6IHRydWVgIGRvZXNuJ3Qgc2hvdyBhIG1lYW5pbmdmdWwgZXJyb3IuXG4gICAgICAgICAgICAgICAgLy8gICAgc28gd2UgZG8gdGhpcyB0byBnZXQgdGhlIGFjdHVhbCBlcnJvciBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRkVG9EZWZpbml0aW9uKHBhcmFtcywgZW5jb2RlZFNlcnZpY2VVUkwsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0TGF5ZXJJdGVtRGF0YShpdGVtLCBwb3J0YWwpIHtcbiAgICAvLyBUT0RPOiByZWZhY3RvciB0aGlzIHRvIHVzZSBnZXRJdGVtRGF0YSBmcm9tIHNlcnZlci1pdGVtLnRzXG4gICAgY29uc3QgdXJsID0gYCR7Z2V0UmVzdEJhc2VVcmwocG9ydGFsKX1jb250ZW50L2l0ZW1zLyR7aXRlbS5pZH0vZGF0YWA7XG4gICAgcmV0dXJuIHJlcXVlc3QodXJsKTtcbn1cbi8qKlxuICogRmV0Y2ggYW4gaXRlbSBvZiB0eXBlIFwiTGF5ZXIgVGVtcGxhdGVcIiB1c2VkIGJ5IHRoZSBvcmcgdG8gY3JlYXRlIG5ldyBhdHRhY2htZW50IGxheWVyc1xuICovXG5hc3luYyBmdW5jdGlvbiBmaW5kVGVtcGxhdGVTZXJ2aWNlSW5mbyhwb3J0YWwpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGdyb3VwUmVzcG9uc2UgPSBhd2FpdCBxdWVyeUdyb3Vwcyh7IHE6ICd0aXRsZTogXCJFc3JpIExheWVyIFRlbXBsYXRlc1wiIEFORCBvd25lcjogXCJlc3JpX2VuXCInLCBudW06IDEgfSk7XG4gICAgY29uc3QgZ3JvdXAgPSAoX2EgPSBncm91cFJlc3BvbnNlLnJlc3VsdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0ZW1wbGF0ZVJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdChgJHtnZXRSZXN0QmFzZVVybChwb3J0YWwpfS9zZWFyY2hgLCB7XG4gICAgICAgIHE6IGB0aXRsZTpcIlBvaW50c1wiIGdyb3VwOlwiJHtncm91cC5pZH1cIiBBTkQgdHlwZTpcIkxheWVyIFRlbXBsYXRlXCIgLXR5cGU6XCJBdHRhY2htZW50XCJgLFxuICAgICAgICBudW06IDFcbiAgICB9KTtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IChfYiA9IHRlbXBsYXRlUmVzcG9uc2UucmVzdWx0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdO1xuICAgIHJldHVybiB0ZW1wbGF0ZSA/IGdldExheWVySXRlbURhdGEodGVtcGxhdGUsIHBvcnRhbCkgOiBudWxsO1xufVxuXG52YXIgX19yZXN0ID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuY29uc3QgZGVmYXVsdFRlbXBsYXRlU2VydmljZUluZm8gPSB7XG4gICAgY3VycmVudFZlcnNpb246IDEwLjUxLFxuICAgIGhhc1ZlcnNpb25lZERhdGE6IGZhbHNlLFxuICAgIHN1cHBvcnRzRGlzY29ubmVjdGVkRWRpdGluZzogZmFsc2UsXG4gICAgaGFzU3RhdGljRGF0YTogZmFsc2UsXG4gICAgbWF4UmVjb3JkQ291bnQ6IDIwMDAsXG4gICAgc3VwcG9ydGVkUXVlcnlGb3JtYXRzOiBcIkpTT05cIixcbiAgICBzdXBwb3J0c1ZDU1Byb2plY3Rpb246IGZhbHNlLFxuICAgIGNhcGFiaWxpdGllczogXCJRdWVyeSxFZGl0aW5nLENyZWF0ZSxVcGRhdGUsRGVsZXRlLFN5bmNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICBjb3B5cmlnaHRUZXh0OiBcIlwiLFxuICAgIGFsbG93R2VvbWV0cnlVcGRhdGVzOiB0cnVlLFxuICAgIHVuaXRzOiBcImVzcmlNZXRlcnNcIixcbiAgICBzdXBwb3J0c0FwcGVuZDogdHJ1ZSxcbiAgICBzeW5jRW5hYmxlZDogZmFsc2UsXG4gICAgc3VwcG9ydHNBcHBseUVkaXRzV2l0aEdsb2JhbElkczogZmFsc2UsXG4gICAgZWRpdG9yVHJhY2tpbmdJbmZvOiB7XG4gICAgICAgIGFsbG93QW5vbnltb3VzVG9EZWxldGU6IHRydWUsXG4gICAgICAgIGFsbG93QW5vbnltb3VzVG9RdWVyeTogdHJ1ZSxcbiAgICAgICAgYWxsb3dBbm9ueW1vdXNUb1VwZGF0ZTogdHJ1ZSxcbiAgICAgICAgYWxsb3dPdGhlcnNUb0RlbGV0ZTogZmFsc2UsXG4gICAgICAgIGFsbG93T3RoZXJzVG9RdWVyeTogdHJ1ZSxcbiAgICAgICAgYWxsb3dPdGhlcnNUb1VwZGF0ZTogdHJ1ZSxcbiAgICAgICAgZW5hYmxlRWRpdG9yVHJhY2tpbmc6IGZhbHNlLFxuICAgICAgICBlbmFibGVPd25lcnNoaXBBY2Nlc3NDb250cm9sOiBmYWxzZVxuICAgIH0sXG4gICAgeHNzUHJldmVudGlvbkluZm86IHsgeHNzUHJldmVudGlvbkVuYWJsZWQ6IHRydWUsIHhzc1ByZXZlbnRpb25SdWxlOiBcIklucHV0T25seVwiLCB4c3NJbnB1dFJ1bGU6IFwicmVqZWN0SW52YWxpZFwiIH0sXG4gICAgX3NzbDogdHJ1ZVxufTtcbmNvbnN0IGFkZEZlYXR1cmVMYXllciA9IGFzeW5jIChyZXF1ZXN0UGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyB0YWdzLCBzZXJ2aWNlSW5mbywgdHlwZUtleXdvcmRzOiBzdG9yZVR5cGVLZXl3b3JkcywgZXh0ZW50OiBzdG9yZUV4dGVudCwgc2VsZWN0ZWRTZXJ2aWNlSW5mb0xheWVyc05hbWVzLCBhZGRGZWF0dXJlTGF5ZXJUeXBlIH0gPSByZXF1ZXN0UGFyYW1zO1xuICAgIGNvbnN0IHsgcG9ydGFsIH0gPSBjb25maWdTdGF0ZTtcbiAgICBjb25zdCBpc0VudGVycHJpc2UgPSBwb3J0YWwuaXNQb3J0YWw7XG4gICAgaWYgKCFzZXJ2aWNlSW5mbykge1xuICAgICAgICAvLyBUT0RPOiBoYXZlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgaGVyZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzZXJ2aWNlIGluZm8gZm91bmQuXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvMzcyNTUjaXNzdWVjb21tZW50LTMxODY1NjRcbiAgICAgICAgbGV0IHByZXNldFNlcnZpY2VJbmZvID0gZGVmYXVsdFRlbXBsYXRlU2VydmljZUluZm87XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcmVzZXRTZXJ2aWNlSW5mbyA9IChfYSA9IChhd2FpdCBmaW5kVGVtcGxhdGVTZXJ2aWNlSW5mbyhwb3J0YWwpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFRlbXBsYXRlU2VydmljZUluZm87XG4gICAgICAgICAgICBwcmVzZXRTZXJ2aWNlSW5mby5jYXBhYmlsaXRpZXMgPSBcIlF1ZXJ5LEVkaXRpbmcsQ3JlYXRlLFVwZGF0ZSxEZWxldGVcIjtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8zODk2NlxuICAgICAgICAgICAgcHJlc2V0U2VydmljZUluZm8uaGFzU3RhdGljRGF0YSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmV0Y2ggdGVtcGxhdGUgJHtKU09OLnN0cmluZ2lmeShlcnJvcil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVhdHVyZUxheWVyU2VydmljZUluZm8gPSBzZXJ2aWNlSW5mbztcbiAgICAgICAgbGV0IGJhc2VMYXllciA9IChfYiA9IGZlYXR1cmVMYXllclNlcnZpY2VJbmZvLmxheWVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgIGxldCBiYXNlVGFibGVzID0gKF9jID0gZmVhdHVyZUxheWVyU2VydmljZUluZm8udGFibGVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgLy8gKiBGaWx0ZXIgc2VsZWN0ZWQgbGF5ZXJzXG4gICAgICAgIC8vICEgTWFrZSBzdXJlIHRoaXMgaXMgZG9uZSBiZWZvcmUgZXh0cmFjdEFuZENsZWFuUmVsYXRpb25zaGlwUGFyYW0gYmVjYXVzZSB0aGUgYHJlbGF0aW9uc2hpcGBcbiAgICAgICAgLy8gISAgIGRlcGVuZHMgb24gaXQhXG4gICAgICAgIC8vIEJ1aWxkIGZyb20gc2NyYXRjaCBmbG93IHdpbGwgYXV0b21hdGljYWxseSBiZSBmaWx0ZXIgYXQgdGhlIGVuZCBvZiBpdHMgcGFnZVxuICAgICAgICBpZiAoYWRkRmVhdHVyZUxheWVyVHlwZSAhPT0gXCJidWlsZFwiICYmIHNlbGVjdGVkU2VydmljZUluZm9MYXllcnNOYW1lcykge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tTZWxlY3RlZCA9IChsYXllcikgPT4gc2VsZWN0ZWRTZXJ2aWNlSW5mb0xheWVyc05hbWVzW2xheWVyLm5hbWVdO1xuICAgICAgICAgICAgYmFzZUxheWVyID0gYmFzZUxheWVyLmZpbHRlcihjaGVja1NlbGVjdGVkKTtcbiAgICAgICAgICAgIGJhc2VUYWJsZXMgPSBiYXNlVGFibGVzLmZpbHRlcihjaGVja1NlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAqIEZpbHRlciB1bmlxdWUgaW5kZXhcbiAgICAgICAgLy8gISBTb21ldGltZXMgdGhlIGJhY2tlbmQgcmV0dXJucyB0ZW1wbGF0ZSBsYXllcnMgd2l0aCBkdXBsaWNhdGUgaW5kZXhlcyxcbiAgICAgICAgLy8gISAgd2UgbmVlZCB0byBtYWtlIGl0IHVuaXF1ZSB1bnRpbCB0aGUgcHJvYmxlbSBnb3QgZml4ZWRcbiAgICAgICAgLy8gPyBOb3RlIHRoYXQgdGhpcyBtaWdodCBiZSBhIGJ1ZyBpbiB0aGUgL2FkZFRvRGVmaW5pdGlvbiBiYWNrZW5kIGJlY2F1c2VcbiAgICAgICAgLy8gPyAgaHR0cHM6Ly9kZXZlbG9wZXJzLmFyY2dpcy5jb20vcmVzdC9zZXJ2aWNlcy1yZWZlcmVuY2Uvb25saW5lL2FkZC10by1kZWZpbml0aW9uLWZlYXR1cmUtc2VydmljZS0uaHRtXG4gICAgICAgIC8vID8gIGV4YW1wbGUgc2VlbXMgdG8gYWxsb3cgZHVwbGljYXRlIGZpZWxkc1xuICAgICAgICBjb25zdCB7IGxheWVyczogdW5pcXVlSW5kZXhMYXllcnMsIHRhYmxlczogdW5pcXVlSW5kZXhUYWJsZXMgfSA9IGV4dHJhY3RVbmlxdWVJbmRleChiYXNlTGF5ZXIsIGJhc2VUYWJsZXMpO1xuICAgICAgICAvLyAqIEZpeCBpZHNcbiAgICAgICAgLy8gIFNvbWUgdGVtcGxhdGUgcmV0dXJucyBub25jb250aW51b3VzIGlkLCB3aGljaCBpcyBiYWRcbiAgICAgICAgLy8gID0+IHdlIGFsc28gbmVlZCB0byBmaXggaWRzIHRoYXQgY2FzZVxuICAgICAgICBjb25zdCB7IGxheWVycywgdGFibGVzIH0gPSBmaXhJZHModW5pcXVlSW5kZXhMYXllcnMsIHVuaXF1ZUluZGV4VGFibGVzKTtcbiAgICAgICAgLy8gKiBGb3JtIHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgY3JlYXRlUGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmVzZXRTZXJ2aWNlSW5mbyksIHNlcnZpY2VJbmZvKSwgeyBuYW1lOiBmZWF0dXJlTGF5ZXJTZXJ2aWNlSW5mby5uYW1lIHx8IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGl0bGUsIGxheWVycyxcbiAgICAgICAgICAgIHRhYmxlcyB9KTtcbiAgICAgICAgLy8gKiBDbGVhbiBwYXJhbWV0ZXJzXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc2VuZCBsYXllcidzIHJlbGF0aW9uc2hpcCBpbiBhIHNlcGFyYXRlIC9hZGRUb0RlZmluaXRpb24gY2FsbFxuICAgICAgICAvLyBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvNDMxOVxuICAgICAgICAvLyBUaGVyZSBhcmUgYWxzbyBzb21lIGNhc2Ugd2hlcmUgbGF5ZXJzIGRlcGVuZCBvbiBlYWNoIG90aGVyIChoZW5jZSB0aGUgYHJlbGF0aW9uc2hpcGApXG4gICAgICAgIC8vICBidXQgc29tZSBvZiB0aGUgbGF5ZXJzIGFyZSBkZXNlbGVjdGVkIHNvIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBiYWQgcmVsYXRpb25zaGlwIGRvZXNuJ3QgZ28gdGhlIGJhY2tlbmRcbiAgICAgICAgLy8gPT4gZXh0cmFjdCBhbmQgY2xlYW5cbiAgICAgICAgY29uc3QgeyBjbGVhbmVkQ3JlYXRlUGFyYW1ldGVycywgcmVsYXRpb25zaGlwUGFyYW1ldGVycyB9ID0gZXh0cmFjdEFuZENsZWFuUmVsYXRpb25zaGlwUGFyYW0oY3JlYXRlUGFyYW1ldGVycyk7XG4gICAgICAgIC8vICog8J+NkiDim48gdGhlIHJlc3Qgb2YgdGhlIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgY2hlcnJ5UGlja1Byb3BzID0gW1xuICAgICAgICAgICAgXCJzZXJ2aWNlRGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIFwiaGFzU3RhdGljRGF0YVwiLFxuICAgICAgICAgICAgXCJtYXhSZWNvcmRDb3VudFwiLFxuICAgICAgICAgICAgXCJzdXBwb3J0ZWRRdWVyeUZvcm1hdHNcIixcbiAgICAgICAgICAgIFwiY2FwYWJpbGl0aWVzXCIsXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBcImNvcHlyaWdodFRleHRcIixcbiAgICAgICAgICAgIFwic3BhdGlhbFJlZmVyZW5jZVwiLFxuICAgICAgICAgICAgXCJpbml0aWFsRXh0ZW50XCIsXG4gICAgICAgICAgICBcImZ1bGxFeHRlbnRcIixcbiAgICAgICAgICAgIFwiX3NzbFwiLFxuICAgICAgICAgICAgXCJhbGxvd0dlb21ldHJ5VXBkYXRlc1wiLFxuICAgICAgICAgICAgXCJ1bml0c1wiLFxuICAgICAgICAgICAgXCJ4c3NQcmV2ZW50aW9uSW5mb1wiXG4gICAgICAgIF07XG4gICAgICAgIGNoZXJyeVBpY2tQcm9wcy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmVhdHVyZUxheWVyU2VydmljZUluZm9ba2V5XTtcbiAgICAgICAgICAgIHZhbHVlICE9IG51bGwgJiYgKGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzW2tleV0gPSB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhbmVkQ3JlYXRlUGFyYW1ldGVycy5uYW1lID0gZm9ybWF0RmlsZU5hbWUoY2xlYW5lZENyZWF0ZVBhcmFtZXRlcnMubmFtZSk7XG4gICAgICAgIGlmIChhZGRGZWF0dXJlTGF5ZXJUeXBlID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICAgICAgICAgIGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzLnN5bmNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzLmNhcGFiaWxpdGllcyA9IFwiUXVlcnksRWRpdGluZyxDcmVhdGUsVXBkYXRlLERlbGV0ZSxTeW5jXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gKiBTZW5kIHJlcXVlc3RzXG4gICAgICAgIGNvbnN0IHsgY3JlYXRlU2VydmljZVJlc3BvbnNlIH0gPSBhd2FpdCBjcmVhdGVTZXJ2aWNlKGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgICBhc3luY0FkZFRvRGVmaW5pdGlvbjogIWlzRW50ZXJwcmlzZSxcbiAgICAgICAgICAgIGNvbmZpZzogY29uZmlnU3RhdGUuY29uZmlnLFxuICAgICAgICAgICAgdXNlcjogY29uZmlnU3RhdGUudXNlclxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBpdGVtSWQsIHN1Y2Nlc3MgfSA9IGNyZWF0ZVNlcnZpY2VSZXNwb25zZTtcbiAgICAgICAgY29uc3QgeyB0eXBlS2V5d29yZHM6IGl0ZW1UeXBlS2V5d29yZHMgfSA9IChhd2FpdCBnZXRJdGVtKGl0ZW1JZCkpLnJlc3VsdDtcbiAgICAgICAgY29uc3QgdHlwZUtleXdvcmRzID0gWy4uLnN0b3JlVHlwZUtleXdvcmRzLCAuLi5pdGVtVHlwZUtleXdvcmRzXTtcbiAgICAgICAgaWYgKHNlcnZpY2VJbmZvLmNhcHR1cmVHUFMpIHtcbiAgICAgICAgICAgIHR5cGVLZXl3b3Jkcy5wdXNoKFwiZ3BzTWV0YWRhdGFFbmFibGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBudW1iZXIgdGFrZW4gZnJvbSB0aGUgb2xkIFVJJ3MgXCIvdXBkYXRlXCIgZW5kcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IHBvcnRhbC5kZWZhdWx0RXh0ZW50IHx8IHNlcnZpY2VJbmZvLmZ1bGxFeHRlbnQgfHwgc2VydmljZUluZm8uZXh0ZW50IHx8IHN0b3JlRXh0ZW50O1xuICAgICAgICAgICAgY29uc3Qgc3BhdGlhbFJlZmVyZW5jZSA9IGV4dGVudC5zcGF0aWFsUmVmZXJlbmNlLndraWQgfHwgZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2Uud2t0IHx8IFwiNDMyNlwiO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50U3RyaW5nID0gZXh0ZW50VG9TdHJpbmcoaXNWYWxpZFdHUzg0RXh0ZW50KGV4dGVudCkgPyBleHRlbnQgOiBhd2FpdCBwcm9qZWN0RXh0ZW50VG9XR1M4NChleHRlbnQpKTtcbiAgICAgICAgICAgIGNvbnN0IHRodW1ibmFpbFVSTCA9IGBodHRwczovL3NlcnZpY2VzLmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvV29ybGRfVG9wb19NYXAvTWFwU2VydmVyL2V4cG9ydD9zaXplPTgwMCw1MzImZm9ybWF0PXBuZzI0JmJib3hTUj0ke3NwYXRpYWxSZWZlcmVuY2V9JmJib3g9JHtleHRlbnRTdHJpbmd9JmY9aW1hZ2VgO1xuICAgICAgICAgICAgY29uc3QgaXNJblJvb3QgPSBpc0ZvbGRlclJvb3QoaXRlbVByb3BlcnRpZXNTdGF0ZS5mb2xkZXIpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oaXRlbUlkLCB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtUHJvcGVydGllc1N0YXRlLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlS2V5d29yZHM6IHR5cGVLZXl3b3Jkcy5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogKHRhZ3MgIT09IG51bGwgJiYgdGFncyAhPT0gdm9pZCAwID8gdGFncyA6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGFncykuam9pbihcIixcIiksXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudDogZXh0ZW50U3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBzbmlwcGV0OiBpdGVtUHJvcGVydGllc1N0YXRlLnNuaXBwZXQsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBhZGRJdGVtU3RhdGUuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBQYXJhbWV0ZXJzLmxheWVycyB8fCByZWxhdGlvbnNoaXBQYXJhbWV0ZXJzLnRhYmxlc1xuICAgICAgICAgICAgICAgICAgICA/IGFkZFRvRGVmaW5pdGlvbihKU09OLnN0cmluZ2lmeShyZWxhdGlvbnNoaXBQYXJhbWV0ZXJzKSwgY3JlYXRlU2VydmljZVJlc3BvbnNlLmVuY29kZWRTZXJ2aWNlVVJMLCAhaXNFbnRlcnByaXNlKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAhaXNJblJvb3QgJiYgbW92ZUl0ZW0oaXRlbUlkLCBpdGVtUHJvcGVydGllc1N0YXRlLmZvbGRlci5pZClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gTm8gYXdhaXQsIGp1c3QgbGVhdmUgaXQgYmVcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oaXRlbUlkLCB7IHRodW1ibmFpbFVSTCB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3MsIGlkOiBpdGVtSWQsIGZvbGRlcjogaXRlbVByb3BlcnRpZXNTdGF0ZS5mb2xkZXIuaWQgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGRlbGV0ZUl0ZW0oaXRlbUlkKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuY29uc3QgZ2V0U2VydmljZUFuZExheWVySW5mbyA9IGFzeW5jIChzZXJ2aWNlVXJsLCByZXN0QmFzZVVybCwgZm9yY2VBZGRUb2tlbiwgaXNTZWN1cmVcbi8vIFRPRE86IHJlZmFjdG9yIHRoaXMgdG8gbmV3IGVycm9yIHN5c3RlbVxuKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBjaGVja0F1dGggfSA9IGFkZEl0ZW1TdGF0ZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBnZXRTZXJ2aWNlSW5mb1dyYXBwZXIgPSAodXJsKSA9PiBnZXRTZXJ2aWNlSW5mbyh7IHVzZXJuYW1lLCBwYXNzd29yZCB9LCB1cmwsIHtcbiAgICAgICAgICAgIGZvcmNlQWRkVG9rZW4sXG4gICAgICAgICAgICBpc1NlY3VyZSxcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgdGltZSBvZiB3cml0aW5nLCBvbmx5IGZlYXR1cmUgbGF5ZXIgYW5kIHRpbGUgbGF5ZXIgdXNlIHRoaXMgbWV0aG9kLCBzbyB0aGV5J3JlIG5vdCBhIHZpZGVvIHNlcnZpY2VcbiAgICAgICAgICAgIGlzVmlkZW9TZXJ2aWNlOiBmYWxzZSxcbiAgICAgICAgICAgIGNoZWNrQXV0aFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkU2VydmljZUluZm8gPSBwYXJzZUFHU1NlcnZlckluZm8oc2VydmljZVVybCk7XG4gICAgICAgIGlmICghZXh0cmFjdGVkU2VydmljZUluZm8pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImludmFsaWQgc2VydmljZSBpbmZvXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBiYXNlU2VydmVyVXJsLCBpbmRleCB9ID0gZXh0cmFjdGVkU2VydmljZUluZm87XG4gICAgICAgIGNvbnN0IHNlcnZpY2VJbmZvID0gKGF3YWl0IGdldFNlcnZpY2VJbmZvV3JhcHBlcihiYXNlU2VydmVyVXJsKSk7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IChhd2FpdCBQcm9taXNlLmFsbCgoc2VydmljZUluZm8ubGF5ZXJzIHx8IFtdKVxuICAgICAgICAgICAgLmZpbHRlcigobGF5ZXIpID0+IGluZGV4ID09PSBudWxsIHx8IGxheWVyLmlkID09PSBpbmRleClcbiAgICAgICAgICAgIC5tYXAoKGxheWVyKSA9PiBnZXRTZXJ2aWNlSW5mb1dyYXBwZXIoYCR7YmFzZVNlcnZlclVybH0vJHtsYXllci5pZH1gKSkpKTtcbiAgICAgICAgY29uc3QgdGFibGVzID0gKGF3YWl0IFByb21pc2UuYWxsKChzZXJ2aWNlSW5mby50YWJsZXMgfHwgW10pXG4gICAgICAgICAgICAuZmlsdGVyKCh0YWJsZSkgPT4gaW5kZXggPT09IG51bGwgfHwgdGFibGUuaWQgPT09IGluZGV4KVxuICAgICAgICAgICAgLm1hcCgodGFibGUpID0+IGdldFNlcnZpY2VJbmZvV3JhcHBlcihgJHtiYXNlU2VydmVyVXJsfS8ke3RhYmxlLmlkfWApKSkpO1xuICAgICAgICByZXR1cm4geyBzZXJ2aWNlSW5mbywgbGF5ZXJzLCB0YWJsZXMgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICBpZiAoKChfYSA9IGVycm9yLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSA9PT0gXCJ0b2tlbiByZXF1aXJlZFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VjdXJlZCB9ID0gYXdhaXQgZ2V0SXNTZWN1cmVkKHsgdXNlcm5hbWUsIHBhc3N3b3JkIH0sIHNlcnZpY2VVcmwsIHJlc3RCYXNlVXJsLCBjaGVja0F1dGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXRTZXJ2aWNlQW5kTGF5ZXJJbmZvKHNlcnZpY2VVcmwsIHJlc3RCYXNlVXJsLCBzZWN1cmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG5jb25zdCBleHRyYWN0QW5kQ2xlYW5SZWxhdGlvbnNoaXBQYXJhbSA9IChjcmVhdGVQYXJhbWV0ZXJzKSA9PiB7XG4gICAgY29uc3QgbG9va3VwTWFwID0ge307XG4gICAgY29uc3Qgc2V0dXBMb29rdXBNYXAgPSAocmVsYXRpb25zaGlwKSA9PiAobG9va3VwTWFwW3JlbGF0aW9uc2hpcC5pZF0gPSB0cnVlKTtcbiAgICBjcmVhdGVQYXJhbWV0ZXJzLmxheWVycy5mb3JFYWNoKHNldHVwTG9va3VwTWFwKTtcbiAgICBjcmVhdGVQYXJhbWV0ZXJzLnRhYmxlcy5mb3JFYWNoKHNldHVwTG9va3VwTWFwKTtcbiAgICAvLyAqIEV4dHJhY3QgcmVsYXRpb25zaGlwXG4gICAgLy8gISBEbyBub3QgZGVsZXRlIGxheWVyLnJlbGF0aW9uc2hpcHMgaGVyZSBvciBpdCB3aWxsIGJyZWFrIHdoZW5cbiAgICAvLyAhICB0aGUgdXNlciBnbyBCYWNrIHRoZW4gTmV4dCBpbiB0aGUgY2FzZSBpdGVtIGNyZWF0aW9uIGZhaWxlZFxuICAgIGNvbnN0IGZpbHRlck1pc3NpbmdSZWxhdGlvbnNoaXAgPSAocmVsYXRpb25zaGlwKSA9PiBsb29rdXBNYXBbcmVsYXRpb25zaGlwLnJlbGF0ZWRUYWJsZUlkXTtcbiAgICBjb25zdCBleHRyYWN0UmVsYXRpb25zaGlwID0gKGxheWVyKSA9PiAoe1xuICAgICAgICByZWxhdGlvbnNoaXBzOiBsYXllci5yZWxhdGlvbnNoaXBzLmZpbHRlcihmaWx0ZXJNaXNzaW5nUmVsYXRpb25zaGlwKSxcbiAgICAgICAgaWQ6IGxheWVyLmlkXG4gICAgfSk7XG4gICAgY29uc3QgZmlsdGVyRW1wdHlSZWxhdGlvbnNoaXAgPSAobGF5ZXIpID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGxheWVyLnJlbGF0aW9uc2hpcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID4gMDsgfTtcbiAgICBjb25zdCBsYXllclJlbGF0aW9uc2hpcHMgPSBjcmVhdGVQYXJhbWV0ZXJzLmxheWVycy5tYXAoZXh0cmFjdFJlbGF0aW9uc2hpcCkuZmlsdGVyKGZpbHRlckVtcHR5UmVsYXRpb25zaGlwKTtcbiAgICBjb25zdCB0YWJsZVJlbGF0aW9uc2hpcHMgPSBjcmVhdGVQYXJhbWV0ZXJzLnRhYmxlcy5tYXAoZXh0cmFjdFJlbGF0aW9uc2hpcCkuZmlsdGVyKGZpbHRlckVtcHR5UmVsYXRpb25zaGlwKTtcbiAgICBjb25zdCByZWxhdGlvbnNoaXBQYXJhbWV0ZXJzID0geyBsYXllcnM6IGxheWVyUmVsYXRpb25zaGlwcywgdGFibGVzOiB0YWJsZVJlbGF0aW9uc2hpcHMgfTtcbiAgICBpZiAocmVsYXRpb25zaGlwUGFyYW1ldGVycy5sYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSByZWxhdGlvbnNoaXBQYXJhbWV0ZXJzLmxheWVycztcbiAgICB9XG4gICAgaWYgKHJlbGF0aW9uc2hpcFBhcmFtZXRlcnMudGFibGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgcmVsYXRpb25zaGlwUGFyYW1ldGVycy50YWJsZXM7XG4gICAgfVxuICAgIC8vICogQ3JlYXRlIG5ldyBjcmVhdGVQYXJhbWV0ZXJzIHdpdGhvdXQgcmVsYXRpb25zaGlwXG4gICAgY29uc3QgbGF5ZXJzID0gY3JlYXRlUGFyYW1ldGVycy5sYXllcnMubWFwKChfYSkgPT4ge1xuICAgICAgICB2YXIgbGF5ZXJzID0gX19yZXN0KF9hLCBbXCJyZWxhdGlvbnNoaXBzXCJdKTtcbiAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9KTtcbiAgICBjb25zdCB0YWJsZXMgPSBjcmVhdGVQYXJhbWV0ZXJzLnRhYmxlcy5tYXAoKF9hKSA9PiB7XG4gICAgICAgIHZhciB0YWJsZXMgPSBfX3Jlc3QoX2EsIFtcInJlbGF0aW9uc2hpcHNcIl0pO1xuICAgICAgICByZXR1cm4gdGFibGVzO1xuICAgIH0pO1xuICAgIGNvbnN0IGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjcmVhdGVQYXJhbWV0ZXJzKSwgeyBsYXllcnMsIHRhYmxlcyB9KTtcbiAgICByZXR1cm4geyByZWxhdGlvbnNoaXBQYXJhbWV0ZXJzLCBjbGVhbmVkQ3JlYXRlUGFyYW1ldGVycyB9O1xufTtcbmNvbnN0IGV4dHJhY3RVbmlxdWVJbmRleCA9IChsYXllcnMsIHRhYmxlcykgPT4ge1xuICAgIGNvbnN0IGdldFVuaXF1ZUluZGV4TGF5ZXIgPSAobGF5ZXIpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxheWVyKSwgeyBpbmRleGVzOiB1bmlxdWVCeShsYXllci5pbmRleGVzLCAoaXRlbSkgPT4gaXRlbS5uYW1lKSB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGF5ZXJzOiBsYXllcnMubWFwKGdldFVuaXF1ZUluZGV4TGF5ZXIpLFxuICAgICAgICB0YWJsZXM6IHRhYmxlcy5tYXAoZ2V0VW5pcXVlSW5kZXhMYXllcilcbiAgICB9O1xufTtcbi8qKiBGaXggaWRzIGZvciBib3RoIGxheWVycyBhbmQgcmVsYXRpb25zaGlwcyAqL1xuY29uc3QgZml4SWRzID0gKGxheWVycywgdGFibGVzKSA9PiB7XG4gICAgLy8gaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAvYmxvYi9tYXN0ZXIvc3JjL2pzL2FyY2dpc29ubGluZS9zaGFyaW5nL2Rpaml0L2RpYWxvZy9QdWJsaXNoV2l6YXJkLmpzI0wxNDUwLUwxNDgzXG4gICAgbGV0IGxheWVySW5mb3MgPSBjb21iaW5lRmVhdHVyZUxheWVySW5mb3MobGF5ZXJzLCB0YWJsZXMpO1xuICAgIC8vICogRml4IGxheWVycyBpZHNcbiAgICAvKiogUmVjb3JkPG9sZCBpZCwgbmV3IGlkPiAqL1xuICAgIGNvbnN0IG9sZExheWVySWRzID0ge307XG4gICAgbGF5ZXJJbmZvcyA9IGxheWVySW5mb3MubWFwKChsYXllckluZm8sIGluZGV4KSA9PiB7XG4gICAgICAgIG9sZExheWVySWRzW2xheWVySW5mby5pZF0gPSBpbmRleDtcbiAgICAgICAgY29uc3QgbmV3TGF5ZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxheWVySW5mbyksIHsgaWQ6IGluZGV4IH0pO1xuICAgICAgICByZXR1cm4gbmV3TGF5ZXI7XG4gICAgfSk7XG4gICAgLy8gKiBGaXggcmVsYXRpb25zaGlwSWRzXG4gICAgbGF5ZXJJbmZvcy5mb3JFYWNoKChsYXllckluZm8pID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsYXllckluZm8ucmVsYXRpb25zaGlwcyA9ICgoX2EgPSBsYXllckluZm8ucmVsYXRpb25zaGlwcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLm1hcCgocmVsYXRpb25zaGlwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRSZWxhdGVkSWQgPSByZWxhdGlvbnNoaXAucmVsYXRlZFRhYmxlSWQ7XG4gICAgICAgICAgICBjb25zdCBuZXdSZWxhdGVkSWQgPSBvbGRMYXllcklkc1tvbGRSZWxhdGVkSWRdO1xuICAgICAgICAgICAgY29uc3QgbmV3UmVsYXRpb25zaGlwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWxhdGlvbnNoaXApLCB7IHJlbGF0ZWRUYWJsZUlkOiBuZXdSZWxhdGVkSWQgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3UmVsYXRpb25zaGlwO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGF5ZXJJbmZvcy5yZWR1Y2UoKHJlc3VsdCwgY3VySW5mbykgPT4ge1xuICAgICAgICBjdXJJbmZvLnR5cGUgPT09IFwiVGFibGVcIiA/IHJlc3VsdC50YWJsZXMucHVzaChjdXJJbmZvKSA6IHJlc3VsdC5sYXllcnMucHVzaChjdXJJbmZvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7IGxheWVyczogW10sIHRhYmxlczogW10gfSk7XG59O1xuXG5leHBvcnQgeyBnZXRMYXllckl0ZW1EYXRhIGFzIEEsIGdldFNlY3VyZWRBR1NTZXJ2aWNlSW5mbyBhcyBCLCBNVUxUSV9QQVJUX1VQTE9BRF9NSU5JTVVNX1NJWkUgYXMgTSwgYWRkU2VjdXJlQUdTVXJsIGFzIGEsIGFkZEFwcGxpY2F0aW9uIGFzIGIsIGFkZEZlYXR1cmVMYXllciBhcyBjLCBhZGRDbG91ZFByb3ZpZGVyUmVzb3VyY2UgYXMgZCwgYWRkRmlsZSBhcyBlLCBmZXRjaEFwcGxpY2F0aW9uTWFuaWZlc3QgYXMgZiwgaXNBcHBDb21wb25lbnRFcnJvciBhcyBnLCBoYW5kbGVBZGRVcmwgYXMgaCwgaXNIeWJyaWRJbWFnZVNlcnZpY2UgYXMgaSwgaXNCYWNrZW5kRXJyb3IgYXMgaiwgYWRkRmlsZUZyb21EYXRhVXJsIGFzIGssIHNlbGVjdE9HQ0ZlYXR1cmVMYXllciBhcyBsLCBmb3JtYXRDdXN0b21QYXJhbWV0ZXJzIGFzIG0sIGdldFVybFNlcnZpY2VJbmZvIGFzIG4sIHBhcnNlQUdTVHlwZSBhcyBvLCBwcm9jZXNzUG9zdEFkZEtNTCBhcyBwLCBnZXRTZXJ2aWNlQW5kTGF5ZXJJbmZvIGFzIHEsIHJlbW92ZVBhcmFtZXRlciBhcyByLCBzdWJzY3JpcHRpb25TdGF0ZSBhcyBzLCBpc0ZvbGRlclJvb3QgYXMgdCwgYWRkSXRlbSBhcyB1LCBmaW5kVGVtcGxhdGVTZXJ2aWNlSW5mbyBhcyB2LCBjcmVhdGVTZXJ2aWNlIGFzIHcsIGdldEl0ZW1TdGF0dXMgYXMgeCwgdXBsb2FkRmlsZSBhcyB5LCByZWdpc3RlckFwcGxpY2F0aW9uIGFzIHogfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmVhdHVyZS1sYXllci01NzNiYjQ3My5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGEgYXMgYWRkQ3JlYXRlSXRlbVR5cGVzIH0gZnJvbSAnLi9pdGVtLXR5cGVzLTIwMjliMDZiLmpzJztcbmltcG9ydCB7IGcgYXMgZ3VpZCB9IGZyb20gJy4vZ3VpZC1hZWFlZDg0ZC5qcyc7XG5cbmZ1bmN0aW9uIHNhbml0aXplRmlsZU5hbWUobmFtZSwgYWRkR1VJRCkge1xuICAgIC8vVE9ETzogYWRkIG5ldyBwYXJhbSB0byBzcGVjIGZpbGUuXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IC8oPzpcXC4oW14uXSspKT8kLztcbiAgICBjb25zdCBpbnZhbGlkVGl0bGVDaGFyYWN0ZXJzID0gL1xcLnwtL2c7XG4gICAgbGV0IGZpbGVOYW1lID0gbmFtZS5yZXBsYWNlKC9eLiooXFxcXHxcXC98OikvLCBcIlwiKTtcbiAgICBsZXQgZXh0ZW5zaW9uID0gKGZpbGVOYW1lICYmIGV4cHJlc3Npb24uZXhlYyhmaWxlTmFtZSlbMV0gPyBleHByZXNzaW9uLmV4ZWMoZmlsZU5hbWUpWzFdLnRvTG93ZXJDYXNlKCkgOiBcIlwiKTtcbiAgICBsZXQgdGl0bGUgPSBcIlwiO1xuICAgIGlmIChmaWxlTmFtZS5pbmRleE9mKFwiLnJmdC5cIikgPiAtMSkge1xuICAgICAgICBjb25zdCBbbmFtZSwgc3VmZml4XSA9IGZpbGVOYW1lLnNwbGl0KFwiLnJmdC5cIik7XG4gICAgICAgIGV4dGVuc2lvbiA9IGByZnQuJHtzdWZmaXh9YDtcbiAgICAgICAgdGl0bGUgPSBuYW1lO1xuICAgIH1cbiAgICBpZiAoZmlsZU5hbWUgJiYgIXRpdGxlKSB7XG4gICAgICAgIHRpdGxlID0gZmlsZU5hbWUubGFzdEluZGV4T2YoXCIuXCIpID09PSAtMSA/IGZpbGVOYW1lIDogZmlsZU5hbWUuc3Vic3RyaW5nKDAsIGZpbGVOYW1lLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2UgYW55IGludmFsaWQgY2hhcmFjdGVycyB3aXRoIGFuIHVuZGVyc2NvcmVcbiAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UoaW52YWxpZFRpdGxlQ2hhcmFjdGVycywgXCJfXCIpO1xuICAgIC8vIEFsbG93IGZpbGUgdXBsb2FkIG9mIGV4aXN0aW5nIGl0ZW0ncyBmaWxlIG5hbWUgLy8gY3VycmVudGx5IHVzZWQgaW4gYXBwZW5kXG4gICAgaWYgKGFkZEdVSUQpIHtcbiAgICAgICAgdGl0bGUgPSBtYWtlVW5pcXVlRmlsZU5hbWUodGl0bGUpO1xuICAgICAgICBmaWxlTmFtZSA9IGAke3RpdGxlfS4ke2V4dGVuc2lvbn1gO1xuICAgIH1cbiAgICByZXR1cm4geyB0aXRsZSwgZmlsZU5hbWUsIGV4dGVuc2lvbiB9O1xufVxuLy8gSGVscGVyIG1ldGhvZCB0aGF0IHRha2VzIGluIGEgZmlsZSAmIHJldHVybnMgdGhlIGNsZWFuZWQgdXAgZmlsZSBuYW1lIGFzIGlzIGFuZCBpbiB0aXRsZSBmb3JtLCBhbmQgdGhlIGRldGVjdGVkIGZpbGUgZXh0ZW5zaW9uXG5mdW5jdGlvbiBzYW5pdGl6ZUZpbGVJbnB1dChmaWxlLCBhZGRHVUlEKSB7XG4gICAgcmV0dXJuIHNhbml0aXplRmlsZU5hbWUoZmlsZS5uYW1lLCAhIWFkZEdVSUQpO1xufVxuZnVuY3Rpb24gbWFrZVVuaXF1ZUZpbGVOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gYCR7bmFtZX1fJHtndWlkKCl9YDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3ZlcndyaXRlRmlsZU5hbWUodXBsb2FkZWRGaWxlTmFtZSwgc291cmNlRmlsZU5hbWUpIHtcbiAgICBsZXQgZmlsZU5hbWUgPSB1cGxvYWRlZEZpbGVOYW1lO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdXBsb2FkZWRGaWxlTmFtZS5sYXN0SW5kZXhPZihcIlxcXFxcIik7XG4gICAgaWYgKHBvc2l0aW9uID4gLTEpIHtcbiAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZS5zdWJzdHJpbmcocG9zaXRpb24gKyAxLCBmaWxlTmFtZS5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZU5hbWUucmVwbGFjZSgvXFwgL2csIFwiX1wiKSA9PT0gc291cmNlRmlsZU5hbWUucmVwbGFjZSgvXFwgL2csIFwiX1wiKTtcbn1cbmZ1bmN0aW9uIGdldEl0ZW1JbmZvQnlUeXBlKHR5cGUpIHtcbiAgICBpZiAoYWRkQ3JlYXRlSXRlbVR5cGVzW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiBhZGRDcmVhdGVJdGVtVHlwZXNbdHlwZV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYWRkQ3JlYXRlSXRlbVR5cGVzW09iamVjdC5rZXlzKGFkZENyZWF0ZUl0ZW1UeXBlcykuZmluZCgoZmlsZVR5cGUpID0+IGFkZENyZWF0ZUl0ZW1UeXBlc1tmaWxlVHlwZV0udHlwZSA9PT0gdHlwZSldO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdEZpbGVTaXplKHNpemUpIHtcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgcmV0dXJuIFwiMCBCXCI7XG4gICAgfVxuICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKHNpemUpIC8gTWF0aC5sb2coMTAyNCkpO1xuICAgIGNvbnN0IGFkanVzdGVkU2l6ZSA9IE1hdGgucm91bmQoc2l6ZSAvIE1hdGgucG93KDEwMjQsIGkpKTtcbiAgICBjb25zdCB1bml0ID0gW1wiQlwiLCBcIktCXCIsIFwiTUJcIiwgXCJHQlwiLCBcIlRCXCJdW2ldO1xuICAgIHJldHVybiBgJHthZGp1c3RlZFNpemV9ICR7dW5pdH1gO1xufVxuXG5leHBvcnQgeyBzYW5pdGl6ZUZpbGVOYW1lIGFzIGEsIGZvcm1hdEZpbGVTaXplIGFzIGYsIGdldEl0ZW1JbmZvQnlUeXBlIGFzIGcsIHNhbml0aXplRmlsZUlucHV0IGFzIHMsIHZhbGlkYXRlT3ZlcndyaXRlRmlsZU5hbWUgYXMgdiB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlLWJmOGFiOTBmLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVTdG9yZSB9IGZyb20gJy4vaW5kZXgtMDU5NTZjYWIuanMnO1xuXG5jb25zdCB3b3JrZmxvd1N0b3JlID0gY3JlYXRlU3RvcmUoe1xuICAgIHBvcnRhbDogbnVsbCxcbiAgICB1c2VyOiBudWxsLFxuICAgIGkxOG46IG51bGwsXG4gICAgc2NhbGU6IFwibVwiLFxuICAgIGFwaTogNCxcbiAgICBuZXh0VGV4dDogbnVsbCxcbiAgICB1cGxvYWRQcm9ncmVzczogMFxufSk7XG5jb25zdCB3b3JrZmxvd1N0YXRlID0gd29ya2Zsb3dTdG9yZS5zdGF0ZTtcblxuZXhwb3J0IHsgd29ya2Zsb3dTdGF0ZSBhcyB3IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0b3JlLTZhODhlNmM1LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==