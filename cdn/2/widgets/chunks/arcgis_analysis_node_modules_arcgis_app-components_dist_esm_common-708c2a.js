"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_common-708c2a"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js":
/*!*****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ LastSortyBy),
/* harmony export */   a: () => (/* binding */ fieldTypesEnum),
/* harmony export */   f: () => (/* binding */ fieldInfoPrefixEnum),
/* harmony export */   i: () => (/* binding */ imageComponentInputTypesEnum),
/* harmony export */   l: () => (/* binding */ layerDisplayTypeEnum),
/* harmony export */   s: () => (/* binding */ serviceTypeEnum)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
var imageComponentInputTypesEnum;
(function (imageComponentInputTypesEnum) {
    imageComponentInputTypesEnum["sourceUrl"] = "sourceUrl";
    imageComponentInputTypesEnum["title"] = "title";
    imageComponentInputTypesEnum["caption"] = "caption";
    imageComponentInputTypesEnum["linkUrl"] = "linkUrl";
    imageComponentInputTypesEnum["altText"] = "altText";
})(imageComponentInputTypesEnum || (imageComponentInputTypesEnum = {}));
var fieldInfoPrefixEnum;
(function (fieldInfoPrefixEnum) {
    fieldInfoPrefixEnum["expression"] = "expression/";
    fieldInfoPrefixEnum["relationship"] = "relationships/";
    fieldInfoPrefixEnum["raster"] = "Raster.";
})(fieldInfoPrefixEnum || (fieldInfoPrefixEnum = {}));
var layerDisplayTypeEnum;
(function (layerDisplayTypeEnum) {
    layerDisplayTypeEnum["feature"] = "feature";
    layerDisplayTypeEnum["cluster"] = "cluster";
    layerDisplayTypeEnum["mapNotes"] = "mapNotes";
})(layerDisplayTypeEnum || (layerDisplayTypeEnum = {}));
var serviceTypeEnum;
(function (serviceTypeEnum) {
    serviceTypeEnum["feature"] = "feature";
    serviceTypeEnum["mapImage"] = "map-image";
    serviceTypeEnum["scene"] = "scene";
    serviceTypeEnum["ogcFeature"] = "ogc-feature";
    serviceTypeEnum["imagery"] = "imagery";
    serviceTypeEnum["wfs"] = "wfs";
    serviceTypeEnum["wms"] = "wms";
    serviceTypeEnum["csv"] = "csv";
    serviceTypeEnum["geojson"] = "geojson";
    serviceTypeEnum["stream"] = "stream";
    serviceTypeEnum["imageryTile"] = "imagery-tile";
    serviceTypeEnum["tile"] = "tile";
    serviceTypeEnum["subtype"] = "subtype";
})(serviceTypeEnum || (serviceTypeEnum = {}));
// https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-support-Field.html#type
var fieldTypesEnum;
(function (fieldTypesEnum) {
    fieldTypesEnum["integer"] = "integer";
    fieldTypesEnum["smallInteger"] = "small-integer";
    fieldTypesEnum["bigInteger"] = "big-integer";
    fieldTypesEnum["single"] = "single";
    fieldTypesEnum["double"] = "double";
    fieldTypesEnum["long"] = "long";
    fieldTypesEnum["string"] = "string";
    fieldTypesEnum["date"] = "date";
    fieldTypesEnum["dateOnly"] = "date-only";
    fieldTypesEnum["timeOnly"] = "time-only";
    fieldTypesEnum["timestampOffset"] = "timestamp-offset";
    fieldTypesEnum["oid"] = "oid";
    fieldTypesEnum["guid"] = "guid";
    fieldTypesEnum["globalId"] = "global-id";
    fieldTypesEnum["number"] = "number"; // for arcade
})(fieldTypesEnum || (fieldTypesEnum = {}));
var LastSortyBy;
(function (LastSortyBy) {
    LastSortyBy["default"] = "default";
    LastSortyBy["display"] = "display";
    LastSortyBy["type"] = "type";
    LastSortyBy["field"] = "field";
})(LastSortyBy || (LastSortyBy = {}));



//# sourceMappingURL=commonEnums-fcf13661.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js":
/*!*********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getFieldType),
/* harmony export */   b: () => (/* binding */ getFieldDisplayName),
/* harmony export */   c: () => (/* binding */ getServiceType),
/* harmony export */   d: () => (/* binding */ generateLayerFieldsMap),
/* harmony export */   e: () => (/* binding */ generateArcadeExpressionMap),
/* harmony export */   f: () => (/* binding */ identifyOnMapImageLayer),
/* harmony export */   g: () => (/* binding */ getFeatureCount),
/* harmony export */   h: () => (/* binding */ getLayerGeometryType),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   j: () => (/* binding */ getFieldsFromLayer),
/* harmony export */   k: () => (/* binding */ getClusterFields),
/* harmony export */   l: () => (/* binding */ getSingleClusterFeature),
/* harmony export */   m: () => (/* binding */ getSingleFeature),
/* harmony export */   n: () => (/* binding */ getRasterCount),
/* harmony export */   o: () => (/* binding */ getPointFromGeometry),
/* harmony export */   p: () => (/* binding */ getServiceVersion),
/* harmony export */   q: () => (/* binding */ queryParentElement)
/* harmony export */ });
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



// display name from fields for arcade
function getFieldDisplayName(field, arcadeMap) {
    if (field.fieldName.indexOf(_commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.f.expression) !== -1) {
        const tempArcade = arcadeMap.get(field.fieldName);
        return (tempArcade === null || tempArcade === void 0 ? void 0 : tempArcade.title) ? tempArcade.title : field.fieldName;
    }
    else {
        return field.label ? field.label : field.fieldName;
    }
}
function generateArcadeExpressionMap(popupTemplate) {
    const arcadeExpMap = new Map();
    if (popupTemplate === null || popupTemplate === void 0 ? void 0 : popupTemplate.expressionInfos) {
        popupTemplate.expressionInfos.forEach((expression) => {
            const expressionNameWithPrefix = `${_commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.f.expression}${expression.name}`;
            arcadeExpMap.set(expressionNameWithPrefix, expression);
        });
    }
    return arcadeExpMap;
}
async function generateLayerFieldsMap(layer) {
    return new Map((await getFieldsFromLayer(layer))
        .filter((field) => field.visible)
        .map((field) => [field.name, field]));
}
async function getSingleFeature(layer, mapView) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    try {
        const serviceType = getServiceType(layer);
        if (serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.mapImage &&
            layer.layer.version >= 10.5 &&
            !((_b = (_a = layer.layer.capabilities) === null || _a === void 0 ? void 0 : _a.operations) === null || _b === void 0 ? void 0 : _b.supportsQuery) &&
            ((_d = (_c = layer.layer.capabilities) === null || _c === void 0 ? void 0 : _c.operations) === null || _d === void 0 ? void 0 : _d.supportsIdentify)) {
            const currFeature = {
                features: [
                    (await identifyOnMapImageLayer(layer, mapView)) ||
                        (await generateSingleFeature(layer))
                ]
            };
            return currFeature;
        }
        if (serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.scene &&
            !((_f = (_e = layer.capabilities) === null || _e === void 0 ? void 0 : _e.operations) === null || _f === void 0 ? void 0 : _f.supportsQuery)) {
            const singleFeature = {
                features: [await generateSingleFeature(layer)]
            };
            return singleFeature;
        }
        const currentLayer = serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.ogcFeature
            ? (await mapView.whenLayerView(layer))
            : serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.stream
                ? (await mapView.whenLayerView(layer))
                : layer;
        const queryParams = currentLayer.createQuery();
        queryParams.where =
            currentLayer.definitionExpression || "1=1";
        queryParams.outFields = ["*"];
        queryParams.returnM = "hasM" in layer && layer.hasM;
        queryParams.returnZ = "hasZ" in layer && layer.hasZ;
        // pagination always supported for OGCFeatureLayerView
        if (((_h = (_g = currentLayer.sourceJSON) === null || _g === void 0 ? void 0 : _g.advancedQueryCapabilities) === null || _h === void 0 ? void 0 : _h.supportsPagination) ||
            serviceType === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.ogcFeature) {
            queryParams.start = 0;
            queryParams.num = 1;
        }
        queryParams.outSpatialReference = mapView.spatialReference;
        const singleFeatureResponse = await currentLayer.queryFeatures(queryParams);
        if (((_j = singleFeatureResponse === null || singleFeatureResponse === void 0 ? void 0 : singleFeatureResponse.features) === null || _j === void 0 ? void 0 : _j.length) === 0) {
            singleFeatureResponse.features[0] = await generateSingleFeature(layer);
        }
        return singleFeatureResponse;
    }
    catch (error) {
        console.error(error);
    }
}
async function generateSingleFeature(layer) {
    return new Promise((resolve, reject) => {
        (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__.l)(["esri/Graphic", "esri/geometry/Geometry"]).then(([Graphic, Geometry]) => {
            var _a;
            const tempGraphic = new Graphic();
            if ((_a = layer.fields) === null || _a === void 0 ? void 0 : _a.length) {
                const tempAttributes = {};
                layer.fields.forEach((feature) => {
                    tempAttributes[feature.name] = feature.defaultValue;
                });
                tempGraphic.attributes = tempAttributes;
            }
            if (layer.geometryType) {
                const tempGeometry = new Geometry();
                tempGeometry.type = layer.geometryType;
                tempGraphic.geometry = tempGeometry;
            }
            resolve(tempGraphic);
        }, (error) => {
            reject(error);
        });
    });
}
function getServiceType(layer) {
    var _a, _b, _c;
    if (((_a = layer === null || layer === void 0 ? void 0 : layer.layer) === null || _a === void 0 ? void 0 : _a.type) === "map-image") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.mapImage;
    }
    if ((layer === null || layer === void 0 ? void 0 : layer.type) === "subtype-sublayer") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.subtype;
    }
    if (((_b = layer === null || layer === void 0 ? void 0 : layer.layer) === null || _b === void 0 ? void 0 : _b.type) === "tile") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.tile;
    }
    if ((layer === null || layer === void 0 ? void 0 : layer.type) === "scene") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.scene;
    }
    if ((layer === null || layer === void 0 ? void 0 : layer.type) === "ogc-feature") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.ogcFeature;
    }
    if ((layer === null || layer === void 0 ? void 0 : layer.type) === "imagery") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.imagery;
    }
    if ((layer === null || layer === void 0 ? void 0 : layer.type) === "imagery-tile") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.imageryTile;
    }
    if ((layer === null || layer === void 0 ? void 0 : layer.type) === "wfs") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.wfs;
    }
    if (((_c = layer === null || layer === void 0 ? void 0 : layer.layer) === null || _c === void 0 ? void 0 : _c.type) === "wms") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.wms;
    }
    if ((layer === null || layer === void 0 ? void 0 : layer.type) === "csv") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.csv;
    }
    if ((layer === null || layer === void 0 ? void 0 : layer.type) === "geojson") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.geojson;
    }
    if ((layer === null || layer === void 0 ? void 0 : layer.type) === "stream") {
        return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.stream;
    }
    return _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.feature;
}
function getServiceVersion(layer) {
    const type = getServiceType(layer);
    let version;
    if (type === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.wms || type === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.mapImage) {
        version = layer === null || layer === void 0 ? void 0 : layer.layer.version;
    }
    else if (type === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.imagery || type === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.feature || type === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.scene) {
        version = layer
            .version;
    }
    return Number.parseFloat(version);
}
// ThematicGroup fields are different than regular layer.fields
async function getFieldsFromLayer(layer) {
    return new Promise(async (resolve, reject) => {
        var _a, _b, _c, _d;
        const type = getServiceType(layer);
        switch (type) {
            case _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.feature:
            case _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.ogcFeature:
            case _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.stream:
                resolve(layer.fields);
                break;
            case _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.mapImage:
                if (((_a = layer === null || layer === void 0 ? void 0 : layer.layer) === null || _a === void 0 ? void 0 : _a.portalItem) &&
                    ((_b = layer.layer) === null || _b === void 0 ? void 0 : _b.url.indexOf("https://demographics")) > -1 &&
                    ((_c = layer.layer) === null || _c === void 0 ? void 0 : _c.url.indexOf(".arcgis.com")) > -1) {
                    try {
                        const response = await ((_d = layer.layer.portalItem) === null || _d === void 0 ? void 0 : _d.fetchData());
                        if (response === null || response === void 0 ? void 0 : response.thematicGroup) {
                            // create hash map for search optimization
                            const layerFieldMap = new Map(layer.fields.map((field) => [field.name, field]));
                            const fieldNames = response.thematicGroup.fieldNames;
                            const returnFields = [];
                            fieldNames.forEach((currentField) => {
                                if (layerFieldMap.has(currentField)) {
                                    returnFields.push(layerFieldMap.get(currentField));
                                }
                            });
                            resolve(returnFields);
                        }
                        else {
                            resolve(layer.fields);
                        }
                    }
                    catch (error) {
                        reject(error);
                    }
                }
                else {
                    resolve(layer.fields);
                }
                break;
            case _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.imagery:
                const iLayer = layer;
                resolve((iLayer.fields || []).concat(iLayer.rasterFields || []));
                break;
            case _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.imageryTile:
                // not sure why it used to be popupTemplate.fieldInfos...
                resolve(/* layer.popupTemplate?.fieldInfos || */ layer.rasterFields);
                break;
            default:
                resolve("fields" in layer && layer.fields);
        }
    });
}
async function getLayerGeometryType(layer) {
    return new Promise(async (resolve) => {
        var _a, _b, _c, _d, _e;
        if (getServiceType(layer) === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.stream) {
            resolve("point");
        }
        else if (layer.geometryType) {
            resolve(layer.geometryType);
        }
        else {
            if (getServiceType(layer) === _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.s.mapImage && ((_b = (_a = layer === null || layer === void 0 ? void 0 : layer.layer) === null || _a === void 0 ? void 0 : _a.sourceJSON) === null || _b === void 0 ? void 0 : _b.layers)) {
                const tempGeometryType = (_d = (_c = layer.layer.sourceJSON.layers
                    .find((sourceJSONLayer) => {
                    if (sourceJSONLayer.id === layer.id) {
                        return sourceJSONLayer;
                    }
                })) === null || _c === void 0 ? void 0 : _c.geometryType) === null || _d === void 0 ? void 0 : _d.toLowerCase();
                if (tempGeometryType) {
                    if (tempGeometryType.indexOf("point") > -1) {
                        resolve("point");
                    }
                    else if (tempGeometryType.indexOf("line") > -1) {
                        resolve("polyline");
                    }
                    else if (tempGeometryType.indexOf("polygon") > -1) {
                        resolve("polygon");
                    }
                    else {
                        resolve(tempGeometryType);
                    }
                }
                else {
                    // try to get it via sublayer.createFeatureLayer();
                    const subLayer = (_e = layer === null || layer === void 0 ? void 0 : layer.layer) === null || _e === void 0 ? void 0 : _e.findSublayerById(layer.id);
                    if (subLayer) {
                        await (subLayer === null || subLayer === void 0 ? void 0 : subLayer.createFeatureLayer().then(async (featureLayer) => {
                            const fLayer = await (featureLayer === null || featureLayer === void 0 ? void 0 : featureLayer.load());
                            resolve(fLayer === null || fLayer === void 0 ? void 0 : fLayer.geometryType);
                        }));
                    }
                    else {
                        resolve(null);
                    }
                }
            }
            else {
                resolve(null);
            }
        }
    });
}
function getFieldType(fieldName, layerFieldsMap, arcadeExpMap) {
    let type = "";
    if (/^raster.(item|service)pixelvalue/i.test(fieldName)) {
        // e.g. "Raster.ServicePixelValue" | "Raster.ItemPixelValue" | "Raster.ServicePixelValue.Raw"
        // layer.rasterFields reports them as type "string"
        type = "number";
    }
    else if (layerFieldsMap.has(fieldName)) {
        const fieldType = layerFieldsMap.get(fieldName);
        type = fieldType.type ? fieldType.type.toLowerCase() : "";
    }
    else if (arcadeExpMap.has(fieldName)) {
        const arcadeField = arcadeExpMap.get(fieldName);
        type = arcadeField.returnType ? arcadeField.returnType.toLowerCase() : "";
    }
    else {
        // default to number for cluster
        type = "number";
    }
    return type;
}
/**
 * Returns feature count of layer
 * @param layer - FeatureLayer | WFSLayer | OGCFeatureLayer | StreamLayer | CSVLayer
 * @param mapView - View
 */
async function getFeatureCount(layer, view) {
    if (layer.type === "feature" && !layer.url) {
        return getFeatureCountForCollection(layer);
    }
    else if (layer.type === "feature" ||
        layer.type === "csv" ||
        layer.type === "scene" ||
        layer.type === "wfs" ||
        layer.type === "geojson") {
        return await layer.queryFeatureCount();
    }
    else if (view && (layer.type === "stream" || layer.type === "ogc-feature")) {
        return getFeatureCountFromView(layer, view);
    }
}
/**
 * Returns feature count of feature collection layer
 * @param layer - FeatureLayer
 */
async function getFeatureCountForCollection(layer) {
    var _a;
    const query = layer.createQuery();
    query.outFields = ["*"];
    const result = await layer.queryFeatures(query);
    if ((_a = result.features) === null || _a === void 0 ? void 0 : _a.length) {
        return result.features.length;
    }
    else {
        throw new Error("could not get feature count");
    }
}
/**
 * Returns feature count of feature collection layer
 * @param layer - StreamLayer | OGCFeatureLayer
 */
async function getFeatureCountFromView(layer, view) {
    // we can only get the features from the map
    const layerView = (await view.whenLayerView(layer));
    return layerView.queryFeatureCount();
}
/**
 * Returns raster count of imagery layer
 * @param layer - Imagerylayer
 */
async function getRasterCount(layer) {
    if (!layer.url) {
        throw new Error("could not get layer.url");
    }
    const [execute] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__.l)(["esri/rest/query/executeForCount"]);
    const count = await execute.executeForCount(layer.url, {});
    if (count) {
        return count;
    }
    else {
        throw new Error("could not get raster count");
    }
}
const getClusterFields = (popupTemplate, getExpressionFields) => {
    let tempFields = [];
    popupTemplate === null || popupTemplate === void 0 ? void 0 : popupTemplate.fieldInfos.forEach((fieldInfo) => {
        if (fieldInfo.fieldName.includes(_commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.f.expression)) {
            // from layer.renderer, to be used as a field for cluster labeling
            // also needed for the existing option in arcade
            getExpressionFields &&
                tempFields.push({
                    name: fieldInfo.fieldName.slice(_commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.f.expression.length),
                    alias: fieldInfo.fieldName.slice(_commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_0__.f.expression.length),
                    type: "string"
                });
        }
        else {
            tempFields.push({ name: fieldInfo.fieldName, alias: fieldInfo.label, type: "string" });
        }
    });
    return tempFields;
};
/**
 * Find an element up the DOM tree.
 * @param el - HTMLElement
 * @param selector - Selector
 */
function queryParentElement(el, selector) {
    let isIDSelector = selector.indexOf("#") === 0;
    let isClassSelector = selector.indexOf(".") === 0;
    if (isClassSelector || isIDSelector) {
        selector = selector.slice(1);
    }
    while (el) {
        if (isIDSelector) {
            if (el.id === selector) {
                return el;
            }
        }
        else if (isClassSelector) {
            if (el.classList.contains(selector)) {
                return el;
            }
        }
        else if (el.tagName.toLowerCase() === selector.toLowerCase()) {
            return el;
        }
        el = el.parentElement;
    }
    return null;
}
/**
 * Returns true if the value is defined
 * @param value - value to check
 */
function isDefined(value) {
    return value !== undefined && value !== null;
}
const identifyOnMapImageLayer = async (layer, mapView) => {
    var _a, _b;
    const [identify, IdentifyParameters] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__.l)([
        "esri/rest/identify",
        "esri/rest/support/IdentifyParameters"
    ]);
    const paramters = new IdentifyParameters();
    paramters.geometry = mapView.extent;
    paramters.mapExtent = mapView.extent;
    paramters.returnGeometry = true;
    paramters.tolerance = 6;
    paramters.layerOption = "popup";
    paramters.width = mapView.width;
    paramters.height = mapView.height;
    paramters.layerIds = [layer.id];
    const identifyResults = (_a = (await identify.identify(layer.layer.url, paramters))) === null || _a === void 0 ? void 0 : _a.results;
    const currFeature = (_b = identifyResults === null || identifyResults === void 0 ? void 0 : identifyResults[0]) === null || _b === void 0 ? void 0 : _b.feature;
    return currFeature;
};
const getSingleClusterFeature = async (mapView, layer, popupTemplate) => {
    var _a;
    const layerView = await mapView.whenLayerView(layer);
    const clusterFeatureSet = await layerView.queryAggregates();
    return await generateSingleClusterFeature(popupTemplate, (_a = clusterFeatureSet.features) === null || _a === void 0 ? void 0 : _a[0]);
};
const generateSingleClusterFeature = async (popupTemplate, currGraphic) => {
    const [Graphic, PointGeometry] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__.l)(["esri/Graphic", "esri/geometry/Point"]);
    let clusterGraphic;
    if (currGraphic) {
        clusterGraphic = currGraphic.clone();
    }
    else {
        clusterGraphic = new Graphic();
        const fields = getClusterFields(popupTemplate, false);
        if (fields === null || fields === void 0 ? void 0 : fields.length) {
            const tempAttributes = {};
            fields.forEach((feature) => {
                tempAttributes[feature.name] = "";
            });
            clusterGraphic.attributes = tempAttributes;
        }
        const tempGeometry = new PointGeometry();
        clusterGraphic.geometry = tempGeometry;
    }
    return clusterGraphic;
};
function getPointFromGeometry(geometry) {
    var _a;
    if (!geometry) {
        return null;
    }
    switch (geometry.type) {
        case "point":
            return geometry;
        case "extent":
            return geometry.center;
        case "polygon":
            return geometry.centroid;
        case "multipoint":
        case "polyline":
            return (_a = geometry.extent) === null || _a === void 0 ? void 0 : _a.center;
        default:
            return null;
    }
}



//# sourceMappingURL=commonFunctions-b0830e9e.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fY29tbW9uLTcwOGMyYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvRUFBb0U7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDOztBQUU0SDs7QUFFL0o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQzJGO0FBQzlCOztBQUU3RDtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVEQUFtQixZQUFZLEVBQUUsZ0JBQWdCO0FBQ2pHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1REFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Yjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcmRBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ2M7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQWlDLFNBQVMsS0FBSztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0EsNkJBQTZCLDJEQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVFQUF1RSw4QkFBOEIsYUFBYTtBQUNsSDtBQUNBLCtCQUErQiwyREFBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU8sTUFBTSxPQUFPO0FBQ2pFO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTyxNQUFNLE9BQU87QUFDNUQ7O0FBRXlIOztBQUV6SCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2NvbW1vbkVudW1zLWZjZjEzNjYxLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2NvbW1vbkZ1bmN0aW9ucy1iMDgzMGU5ZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG52YXIgaW1hZ2VDb21wb25lbnRJbnB1dFR5cGVzRW51bTtcbihmdW5jdGlvbiAoaW1hZ2VDb21wb25lbnRJbnB1dFR5cGVzRW51bSkge1xuICAgIGltYWdlQ29tcG9uZW50SW5wdXRUeXBlc0VudW1bXCJzb3VyY2VVcmxcIl0gPSBcInNvdXJjZVVybFwiO1xuICAgIGltYWdlQ29tcG9uZW50SW5wdXRUeXBlc0VudW1bXCJ0aXRsZVwiXSA9IFwidGl0bGVcIjtcbiAgICBpbWFnZUNvbXBvbmVudElucHV0VHlwZXNFbnVtW1wiY2FwdGlvblwiXSA9IFwiY2FwdGlvblwiO1xuICAgIGltYWdlQ29tcG9uZW50SW5wdXRUeXBlc0VudW1bXCJsaW5rVXJsXCJdID0gXCJsaW5rVXJsXCI7XG4gICAgaW1hZ2VDb21wb25lbnRJbnB1dFR5cGVzRW51bVtcImFsdFRleHRcIl0gPSBcImFsdFRleHRcIjtcbn0pKGltYWdlQ29tcG9uZW50SW5wdXRUeXBlc0VudW0gfHwgKGltYWdlQ29tcG9uZW50SW5wdXRUeXBlc0VudW0gPSB7fSkpO1xudmFyIGZpZWxkSW5mb1ByZWZpeEVudW07XG4oZnVuY3Rpb24gKGZpZWxkSW5mb1ByZWZpeEVudW0pIHtcbiAgICBmaWVsZEluZm9QcmVmaXhFbnVtW1wiZXhwcmVzc2lvblwiXSA9IFwiZXhwcmVzc2lvbi9cIjtcbiAgICBmaWVsZEluZm9QcmVmaXhFbnVtW1wicmVsYXRpb25zaGlwXCJdID0gXCJyZWxhdGlvbnNoaXBzL1wiO1xuICAgIGZpZWxkSW5mb1ByZWZpeEVudW1bXCJyYXN0ZXJcIl0gPSBcIlJhc3Rlci5cIjtcbn0pKGZpZWxkSW5mb1ByZWZpeEVudW0gfHwgKGZpZWxkSW5mb1ByZWZpeEVudW0gPSB7fSkpO1xudmFyIGxheWVyRGlzcGxheVR5cGVFbnVtO1xuKGZ1bmN0aW9uIChsYXllckRpc3BsYXlUeXBlRW51bSkge1xuICAgIGxheWVyRGlzcGxheVR5cGVFbnVtW1wiZmVhdHVyZVwiXSA9IFwiZmVhdHVyZVwiO1xuICAgIGxheWVyRGlzcGxheVR5cGVFbnVtW1wiY2x1c3RlclwiXSA9IFwiY2x1c3RlclwiO1xuICAgIGxheWVyRGlzcGxheVR5cGVFbnVtW1wibWFwTm90ZXNcIl0gPSBcIm1hcE5vdGVzXCI7XG59KShsYXllckRpc3BsYXlUeXBlRW51bSB8fCAobGF5ZXJEaXNwbGF5VHlwZUVudW0gPSB7fSkpO1xudmFyIHNlcnZpY2VUeXBlRW51bTtcbihmdW5jdGlvbiAoc2VydmljZVR5cGVFbnVtKSB7XG4gICAgc2VydmljZVR5cGVFbnVtW1wiZmVhdHVyZVwiXSA9IFwiZmVhdHVyZVwiO1xuICAgIHNlcnZpY2VUeXBlRW51bVtcIm1hcEltYWdlXCJdID0gXCJtYXAtaW1hZ2VcIjtcbiAgICBzZXJ2aWNlVHlwZUVudW1bXCJzY2VuZVwiXSA9IFwic2NlbmVcIjtcbiAgICBzZXJ2aWNlVHlwZUVudW1bXCJvZ2NGZWF0dXJlXCJdID0gXCJvZ2MtZmVhdHVyZVwiO1xuICAgIHNlcnZpY2VUeXBlRW51bVtcImltYWdlcnlcIl0gPSBcImltYWdlcnlcIjtcbiAgICBzZXJ2aWNlVHlwZUVudW1bXCJ3ZnNcIl0gPSBcIndmc1wiO1xuICAgIHNlcnZpY2VUeXBlRW51bVtcIndtc1wiXSA9IFwid21zXCI7XG4gICAgc2VydmljZVR5cGVFbnVtW1wiY3N2XCJdID0gXCJjc3ZcIjtcbiAgICBzZXJ2aWNlVHlwZUVudW1bXCJnZW9qc29uXCJdID0gXCJnZW9qc29uXCI7XG4gICAgc2VydmljZVR5cGVFbnVtW1wic3RyZWFtXCJdID0gXCJzdHJlYW1cIjtcbiAgICBzZXJ2aWNlVHlwZUVudW1bXCJpbWFnZXJ5VGlsZVwiXSA9IFwiaW1hZ2VyeS10aWxlXCI7XG4gICAgc2VydmljZVR5cGVFbnVtW1widGlsZVwiXSA9IFwidGlsZVwiO1xuICAgIHNlcnZpY2VUeXBlRW51bVtcInN1YnR5cGVcIl0gPSBcInN1YnR5cGVcIjtcbn0pKHNlcnZpY2VUeXBlRW51bSB8fCAoc2VydmljZVR5cGVFbnVtID0ge30pKTtcbi8vIGh0dHBzOi8vZGV2ZWxvcGVycy5hcmNnaXMuY29tL2phdmFzY3JpcHQvbGF0ZXN0L2FwaS1yZWZlcmVuY2UvZXNyaS1sYXllcnMtc3VwcG9ydC1GaWVsZC5odG1sI3R5cGVcbnZhciBmaWVsZFR5cGVzRW51bTtcbihmdW5jdGlvbiAoZmllbGRUeXBlc0VudW0pIHtcbiAgICBmaWVsZFR5cGVzRW51bVtcImludGVnZXJcIl0gPSBcImludGVnZXJcIjtcbiAgICBmaWVsZFR5cGVzRW51bVtcInNtYWxsSW50ZWdlclwiXSA9IFwic21hbGwtaW50ZWdlclwiO1xuICAgIGZpZWxkVHlwZXNFbnVtW1wiYmlnSW50ZWdlclwiXSA9IFwiYmlnLWludGVnZXJcIjtcbiAgICBmaWVsZFR5cGVzRW51bVtcInNpbmdsZVwiXSA9IFwic2luZ2xlXCI7XG4gICAgZmllbGRUeXBlc0VudW1bXCJkb3VibGVcIl0gPSBcImRvdWJsZVwiO1xuICAgIGZpZWxkVHlwZXNFbnVtW1wibG9uZ1wiXSA9IFwibG9uZ1wiO1xuICAgIGZpZWxkVHlwZXNFbnVtW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICBmaWVsZFR5cGVzRW51bVtcImRhdGVcIl0gPSBcImRhdGVcIjtcbiAgICBmaWVsZFR5cGVzRW51bVtcImRhdGVPbmx5XCJdID0gXCJkYXRlLW9ubHlcIjtcbiAgICBmaWVsZFR5cGVzRW51bVtcInRpbWVPbmx5XCJdID0gXCJ0aW1lLW9ubHlcIjtcbiAgICBmaWVsZFR5cGVzRW51bVtcInRpbWVzdGFtcE9mZnNldFwiXSA9IFwidGltZXN0YW1wLW9mZnNldFwiO1xuICAgIGZpZWxkVHlwZXNFbnVtW1wib2lkXCJdID0gXCJvaWRcIjtcbiAgICBmaWVsZFR5cGVzRW51bVtcImd1aWRcIl0gPSBcImd1aWRcIjtcbiAgICBmaWVsZFR5cGVzRW51bVtcImdsb2JhbElkXCJdID0gXCJnbG9iYWwtaWRcIjtcbiAgICBmaWVsZFR5cGVzRW51bVtcIm51bWJlclwiXSA9IFwibnVtYmVyXCI7IC8vIGZvciBhcmNhZGVcbn0pKGZpZWxkVHlwZXNFbnVtIHx8IChmaWVsZFR5cGVzRW51bSA9IHt9KSk7XG52YXIgTGFzdFNvcnR5Qnk7XG4oZnVuY3Rpb24gKExhc3RTb3J0eUJ5KSB7XG4gICAgTGFzdFNvcnR5QnlbXCJkZWZhdWx0XCJdID0gXCJkZWZhdWx0XCI7XG4gICAgTGFzdFNvcnR5QnlbXCJkaXNwbGF5XCJdID0gXCJkaXNwbGF5XCI7XG4gICAgTGFzdFNvcnR5QnlbXCJ0eXBlXCJdID0gXCJ0eXBlXCI7XG4gICAgTGFzdFNvcnR5QnlbXCJmaWVsZFwiXSA9IFwiZmllbGRcIjtcbn0pKExhc3RTb3J0eUJ5IHx8IChMYXN0U29ydHlCeSA9IHt9KSk7XG5cbmV4cG9ydCB7IExhc3RTb3J0eUJ5IGFzIEwsIGZpZWxkVHlwZXNFbnVtIGFzIGEsIGZpZWxkSW5mb1ByZWZpeEVudW0gYXMgZiwgaW1hZ2VDb21wb25lbnRJbnB1dFR5cGVzRW51bSBhcyBpLCBsYXllckRpc3BsYXlUeXBlRW51bSBhcyBsLCBzZXJ2aWNlVHlwZUVudW0gYXMgcyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb25FbnVtcy1mY2YxMzY2MS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IHMgYXMgc2VydmljZVR5cGVFbnVtLCBmIGFzIGZpZWxkSW5mb1ByZWZpeEVudW0gfSBmcm9tICcuL2NvbW1vbkVudW1zLWZjZjEzNjYxLmpzJztcbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcblxuLy8gZGlzcGxheSBuYW1lIGZyb20gZmllbGRzIGZvciBhcmNhZGVcbmZ1bmN0aW9uIGdldEZpZWxkRGlzcGxheU5hbWUoZmllbGQsIGFyY2FkZU1hcCkge1xuICAgIGlmIChmaWVsZC5maWVsZE5hbWUuaW5kZXhPZihmaWVsZEluZm9QcmVmaXhFbnVtLmV4cHJlc3Npb24pICE9PSAtMSkge1xuICAgICAgICBjb25zdCB0ZW1wQXJjYWRlID0gYXJjYWRlTWFwLmdldChmaWVsZC5maWVsZE5hbWUpO1xuICAgICAgICByZXR1cm4gKHRlbXBBcmNhZGUgPT09IG51bGwgfHwgdGVtcEFyY2FkZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGVtcEFyY2FkZS50aXRsZSkgPyB0ZW1wQXJjYWRlLnRpdGxlIDogZmllbGQuZmllbGROYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLmxhYmVsID8gZmllbGQubGFiZWwgOiBmaWVsZC5maWVsZE5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVBcmNhZGVFeHByZXNzaW9uTWFwKHBvcHVwVGVtcGxhdGUpIHtcbiAgICBjb25zdCBhcmNhZGVFeHBNYXAgPSBuZXcgTWFwKCk7XG4gICAgaWYgKHBvcHVwVGVtcGxhdGUgPT09IG51bGwgfHwgcG9wdXBUZW1wbGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9wdXBUZW1wbGF0ZS5leHByZXNzaW9uSW5mb3MpIHtcbiAgICAgICAgcG9wdXBUZW1wbGF0ZS5leHByZXNzaW9uSW5mb3MuZm9yRWFjaCgoZXhwcmVzc2lvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbk5hbWVXaXRoUHJlZml4ID0gYCR7ZmllbGRJbmZvUHJlZml4RW51bS5leHByZXNzaW9ufSR7ZXhwcmVzc2lvbi5uYW1lfWA7XG4gICAgICAgICAgICBhcmNhZGVFeHBNYXAuc2V0KGV4cHJlc3Npb25OYW1lV2l0aFByZWZpeCwgZXhwcmVzc2lvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJjYWRlRXhwTWFwO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVMYXllckZpZWxkc01hcChsYXllcikge1xuICAgIHJldHVybiBuZXcgTWFwKChhd2FpdCBnZXRGaWVsZHNGcm9tTGF5ZXIobGF5ZXIpKVxuICAgICAgICAuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQudmlzaWJsZSlcbiAgICAgICAgLm1hcCgoZmllbGQpID0+IFtmaWVsZC5uYW1lLCBmaWVsZF0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFNpbmdsZUZlYXR1cmUobGF5ZXIsIG1hcFZpZXcpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzZXJ2aWNlVHlwZSA9IGdldFNlcnZpY2VUeXBlKGxheWVyKTtcbiAgICAgICAgaWYgKHNlcnZpY2VUeXBlID09PSBzZXJ2aWNlVHlwZUVudW0ubWFwSW1hZ2UgJiZcbiAgICAgICAgICAgIGxheWVyLmxheWVyLnZlcnNpb24gPj0gMTAuNSAmJlxuICAgICAgICAgICAgISgoX2IgPSAoX2EgPSBsYXllci5sYXllci5jYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVyYXRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3VwcG9ydHNRdWVyeSkgJiZcbiAgICAgICAgICAgICgoX2QgPSAoX2MgPSBsYXllci5sYXllci5jYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5vcGVyYXRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc3VwcG9ydHNJZGVudGlmeSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJGZWF0dXJlID0ge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICAgICAgICAgIChhd2FpdCBpZGVudGlmeU9uTWFwSW1hZ2VMYXllcihsYXllciwgbWFwVmlldykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYXdhaXQgZ2VuZXJhdGVTaW5nbGVGZWF0dXJlKGxheWVyKSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJGZWF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXJ2aWNlVHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLnNjZW5lICYmXG4gICAgICAgICAgICAhKChfZiA9IChfZSA9IGxheWVyLmNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLm9wZXJhdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zdXBwb3J0c1F1ZXJ5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2luZ2xlRmVhdHVyZSA9IHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlczogW2F3YWl0IGdlbmVyYXRlU2luZ2xlRmVhdHVyZShsYXllcildXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHNpbmdsZUZlYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudExheWVyID0gc2VydmljZVR5cGUgPT09IHNlcnZpY2VUeXBlRW51bS5vZ2NGZWF0dXJlXG4gICAgICAgICAgICA/IChhd2FpdCBtYXBWaWV3LndoZW5MYXllclZpZXcobGF5ZXIpKVxuICAgICAgICAgICAgOiBzZXJ2aWNlVHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLnN0cmVhbVxuICAgICAgICAgICAgICAgID8gKGF3YWl0IG1hcFZpZXcud2hlbkxheWVyVmlldyhsYXllcikpXG4gICAgICAgICAgICAgICAgOiBsYXllcjtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBjdXJyZW50TGF5ZXIuY3JlYXRlUXVlcnkoKTtcbiAgICAgICAgcXVlcnlQYXJhbXMud2hlcmUgPVxuICAgICAgICAgICAgY3VycmVudExheWVyLmRlZmluaXRpb25FeHByZXNzaW9uIHx8IFwiMT0xXCI7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLm91dEZpZWxkcyA9IFtcIipcIl07XG4gICAgICAgIHF1ZXJ5UGFyYW1zLnJldHVybk0gPSBcImhhc01cIiBpbiBsYXllciAmJiBsYXllci5oYXNNO1xuICAgICAgICBxdWVyeVBhcmFtcy5yZXR1cm5aID0gXCJoYXNaXCIgaW4gbGF5ZXIgJiYgbGF5ZXIuaGFzWjtcbiAgICAgICAgLy8gcGFnaW5hdGlvbiBhbHdheXMgc3VwcG9ydGVkIGZvciBPR0NGZWF0dXJlTGF5ZXJWaWV3XG4gICAgICAgIGlmICgoKF9oID0gKF9nID0gY3VycmVudExheWVyLnNvdXJjZUpTT04pID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5hZHZhbmNlZFF1ZXJ5Q2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guc3VwcG9ydHNQYWdpbmF0aW9uKSB8fFxuICAgICAgICAgICAgc2VydmljZVR5cGUgPT09IHNlcnZpY2VUeXBlRW51bS5vZ2NGZWF0dXJlKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5zdGFydCA9IDA7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5udW0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5UGFyYW1zLm91dFNwYXRpYWxSZWZlcmVuY2UgPSBtYXBWaWV3LnNwYXRpYWxSZWZlcmVuY2U7XG4gICAgICAgIGNvbnN0IHNpbmdsZUZlYXR1cmVSZXNwb25zZSA9IGF3YWl0IGN1cnJlbnRMYXllci5xdWVyeUZlYXR1cmVzKHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgaWYgKCgoX2ogPSBzaW5nbGVGZWF0dXJlUmVzcG9uc2UgPT09IG51bGwgfHwgc2luZ2xlRmVhdHVyZVJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaW5nbGVGZWF0dXJlUmVzcG9uc2UuZmVhdHVyZXMpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICBzaW5nbGVGZWF0dXJlUmVzcG9uc2UuZmVhdHVyZXNbMF0gPSBhd2FpdCBnZW5lcmF0ZVNpbmdsZUZlYXR1cmUobGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5nbGVGZWF0dXJlUmVzcG9uc2U7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVNpbmdsZUZlYXR1cmUobGF5ZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsb2FkTW9kdWxlcyhbXCJlc3JpL0dyYXBoaWNcIiwgXCJlc3JpL2dlb21ldHJ5L0dlb21ldHJ5XCJdKS50aGVuKChbR3JhcGhpYywgR2VvbWV0cnldKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB0ZW1wR3JhcGhpYyA9IG5ldyBHcmFwaGljKCk7XG4gICAgICAgICAgICBpZiAoKF9hID0gbGF5ZXIuZmllbGRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBsYXllci5maWVsZHMuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQXR0cmlidXRlc1tmZWF0dXJlLm5hbWVdID0gZmVhdHVyZS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGVtcEdyYXBoaWMuYXR0cmlidXRlcyA9IHRlbXBBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheWVyLmdlb21ldHJ5VHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBHZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xuICAgICAgICAgICAgICAgIHRlbXBHZW9tZXRyeS50eXBlID0gbGF5ZXIuZ2VvbWV0cnlUeXBlO1xuICAgICAgICAgICAgICAgIHRlbXBHcmFwaGljLmdlb21ldHJ5ID0gdGVtcEdlb21ldHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSh0ZW1wR3JhcGhpYyk7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZXJ2aWNlVHlwZShsYXllcikge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmICgoKF9hID0gbGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmxheWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwibWFwLWltYWdlXCIpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VUeXBlRW51bS5tYXBJbWFnZTtcbiAgICB9XG4gICAgaWYgKChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIudHlwZSkgPT09IFwic3VidHlwZS1zdWJsYXllclwiKSB7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlVHlwZUVudW0uc3VidHlwZTtcbiAgICB9XG4gICAgaWYgKCgoX2IgPSBsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIubGF5ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gXCJ0aWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VUeXBlRW51bS50aWxlO1xuICAgIH1cbiAgICBpZiAoKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci50eXBlKSA9PT0gXCJzY2VuZVwiKSB7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlVHlwZUVudW0uc2NlbmU7XG4gICAgfVxuICAgIGlmICgobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLnR5cGUpID09PSBcIm9nYy1mZWF0dXJlXCIpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VUeXBlRW51bS5vZ2NGZWF0dXJlO1xuICAgIH1cbiAgICBpZiAoKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci50eXBlKSA9PT0gXCJpbWFnZXJ5XCIpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VUeXBlRW51bS5pbWFnZXJ5O1xuICAgIH1cbiAgICBpZiAoKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci50eXBlKSA9PT0gXCJpbWFnZXJ5LXRpbGVcIikge1xuICAgICAgICByZXR1cm4gc2VydmljZVR5cGVFbnVtLmltYWdlcnlUaWxlO1xuICAgIH1cbiAgICBpZiAoKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci50eXBlKSA9PT0gXCJ3ZnNcIikge1xuICAgICAgICByZXR1cm4gc2VydmljZVR5cGVFbnVtLndmcztcbiAgICB9XG4gICAgaWYgKCgoX2MgPSBsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIubGF5ZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50eXBlKSA9PT0gXCJ3bXNcIikge1xuICAgICAgICByZXR1cm4gc2VydmljZVR5cGVFbnVtLndtcztcbiAgICB9XG4gICAgaWYgKChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIudHlwZSkgPT09IFwiY3N2XCIpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VUeXBlRW51bS5jc3Y7XG4gICAgfVxuICAgIGlmICgobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLnR5cGUpID09PSBcImdlb2pzb25cIikge1xuICAgICAgICByZXR1cm4gc2VydmljZVR5cGVFbnVtLmdlb2pzb247XG4gICAgfVxuICAgIGlmICgobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLnR5cGUpID09PSBcInN0cmVhbVwiKSB7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlVHlwZUVudW0uc3RyZWFtO1xuICAgIH1cbiAgICByZXR1cm4gc2VydmljZVR5cGVFbnVtLmZlYXR1cmU7XG59XG5mdW5jdGlvbiBnZXRTZXJ2aWNlVmVyc2lvbihsYXllcikge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRTZXJ2aWNlVHlwZShsYXllcik7XG4gICAgbGV0IHZlcnNpb247XG4gICAgaWYgKHR5cGUgPT09IHNlcnZpY2VUeXBlRW51bS53bXMgfHwgdHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLm1hcEltYWdlKSB7XG4gICAgICAgIHZlcnNpb24gPSBsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIubGF5ZXIudmVyc2lvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLmltYWdlcnkgfHwgdHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLmZlYXR1cmUgfHwgdHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLnNjZW5lKSB7XG4gICAgICAgIHZlcnNpb24gPSBsYXllclxuICAgICAgICAgICAgLnZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIucGFyc2VGbG9hdCh2ZXJzaW9uKTtcbn1cbi8vIFRoZW1hdGljR3JvdXAgZmllbGRzIGFyZSBkaWZmZXJlbnQgdGhhbiByZWd1bGFyIGxheWVyLmZpZWxkc1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmllbGRzRnJvbUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCB0eXBlID0gZ2V0U2VydmljZVR5cGUobGF5ZXIpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2Ugc2VydmljZVR5cGVFbnVtLmZlYXR1cmU6XG4gICAgICAgICAgICBjYXNlIHNlcnZpY2VUeXBlRW51bS5vZ2NGZWF0dXJlOlxuICAgICAgICAgICAgY2FzZSBzZXJ2aWNlVHlwZUVudW0uc3RyZWFtOlxuICAgICAgICAgICAgICAgIHJlc29sdmUobGF5ZXIuZmllbGRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2VydmljZVR5cGVFbnVtLm1hcEltYWdlOlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gbGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmxheWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9ydGFsSXRlbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKChfYiA9IGxheWVyLmxheWVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudXJsLmluZGV4T2YoXCJodHRwczovL2RlbW9ncmFwaGljc1wiKSkgPiAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9jID0gbGF5ZXIubGF5ZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmwuaW5kZXhPZihcIi5hcmNnaXMuY29tXCIpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0ICgoX2QgPSBsYXllci5sYXllci5wb3J0YWxJdGVtKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZmV0Y2hEYXRhKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS50aGVtYXRpY0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGhhc2ggbWFwIGZvciBzZWFyY2ggb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJGaWVsZE1hcCA9IG5ldyBNYXAobGF5ZXIuZmllbGRzLm1hcCgoZmllbGQpID0+IFtmaWVsZC5uYW1lLCBmaWVsZF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gcmVzcG9uc2UudGhlbWF0aWNHcm91cC5maWVsZE5hbWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVybkZpZWxkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZXMuZm9yRWFjaCgoY3VycmVudEZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXllckZpZWxkTWFwLmhhcyhjdXJyZW50RmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWVsZHMucHVzaChsYXllckZpZWxkTWFwLmdldChjdXJyZW50RmllbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobGF5ZXIuZmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobGF5ZXIuZmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNlcnZpY2VUeXBlRW51bS5pbWFnZXJ5OlxuICAgICAgICAgICAgICAgIGNvbnN0IGlMYXllciA9IGxheWVyO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKGlMYXllci5maWVsZHMgfHwgW10pLmNvbmNhdChpTGF5ZXIucmFzdGVyRmllbGRzIHx8IFtdKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNlcnZpY2VUeXBlRW51bS5pbWFnZXJ5VGlsZTpcbiAgICAgICAgICAgICAgICAvLyBub3Qgc3VyZSB3aHkgaXQgdXNlZCB0byBiZSBwb3B1cFRlbXBsYXRlLmZpZWxkSW5mb3MuLi5cbiAgICAgICAgICAgICAgICByZXNvbHZlKC8qIGxheWVyLnBvcHVwVGVtcGxhdGU/LmZpZWxkSW5mb3MgfHwgKi8gbGF5ZXIucmFzdGVyRmllbGRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShcImZpZWxkc1wiIGluIGxheWVyICYmIGxheWVyLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldExheWVyR2VvbWV0cnlUeXBlKGxheWVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIGlmIChnZXRTZXJ2aWNlVHlwZShsYXllcikgPT09IHNlcnZpY2VUeXBlRW51bS5zdHJlYW0pIHtcbiAgICAgICAgICAgIHJlc29sdmUoXCJwb2ludFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXllci5nZW9tZXRyeVR5cGUpIHtcbiAgICAgICAgICAgIHJlc29sdmUobGF5ZXIuZ2VvbWV0cnlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZXRTZXJ2aWNlVHlwZShsYXllcikgPT09IHNlcnZpY2VUeXBlRW51bS5tYXBJbWFnZSAmJiAoKF9iID0gKF9hID0gbGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmxheWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc291cmNlSlNPTikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxheWVycykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wR2VvbWV0cnlUeXBlID0gKF9kID0gKF9jID0gbGF5ZXIubGF5ZXIuc291cmNlSlNPTi5sYXllcnNcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoKHNvdXJjZUpTT05MYXllcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlSlNPTkxheWVyLmlkID09PSBsYXllci5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUpTT05MYXllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2VvbWV0cnlUeXBlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcEdlb21ldHJ5VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcEdlb21ldHJ5VHlwZS5pbmRleE9mKFwicG9pbnRcIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcInBvaW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRlbXBHZW9tZXRyeVR5cGUuaW5kZXhPZihcImxpbmVcIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcInBvbHlsaW5lXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRlbXBHZW9tZXRyeVR5cGUuaW5kZXhPZihcInBvbHlnb25cIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcInBvbHlnb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRlbXBHZW9tZXRyeVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gZ2V0IGl0IHZpYSBzdWJsYXllci5jcmVhdGVGZWF0dXJlTGF5ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViTGF5ZXIgPSAoX2UgPSBsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIubGF5ZXIpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5maW5kU3VibGF5ZXJCeUlkKGxheWVyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YkxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCAoc3ViTGF5ZXIgPT09IG51bGwgfHwgc3ViTGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YkxheWVyLmNyZWF0ZUZlYXR1cmVMYXllcigpLnRoZW4oYXN5bmMgKGZlYXR1cmVMYXllcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZMYXllciA9IGF3YWl0IChmZWF0dXJlTGF5ZXIgPT09IG51bGwgfHwgZmVhdHVyZUxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0dXJlTGF5ZXIubG9hZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZMYXllciA9PT0gbnVsbCB8fCBmTGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZMYXllci5nZW9tZXRyeVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZpZWxkVHlwZShmaWVsZE5hbWUsIGxheWVyRmllbGRzTWFwLCBhcmNhZGVFeHBNYXApIHtcbiAgICBsZXQgdHlwZSA9IFwiXCI7XG4gICAgaWYgKC9ecmFzdGVyLihpdGVtfHNlcnZpY2UpcGl4ZWx2YWx1ZS9pLnRlc3QoZmllbGROYW1lKSkge1xuICAgICAgICAvLyBlLmcuIFwiUmFzdGVyLlNlcnZpY2VQaXhlbFZhbHVlXCIgfCBcIlJhc3Rlci5JdGVtUGl4ZWxWYWx1ZVwiIHwgXCJSYXN0ZXIuU2VydmljZVBpeGVsVmFsdWUuUmF3XCJcbiAgICAgICAgLy8gbGF5ZXIucmFzdGVyRmllbGRzIHJlcG9ydHMgdGhlbSBhcyB0eXBlIFwic3RyaW5nXCJcbiAgICAgICAgdHlwZSA9IFwibnVtYmVyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxheWVyRmllbGRzTWFwLmhhcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IGxheWVyRmllbGRzTWFwLmdldChmaWVsZE5hbWUpO1xuICAgICAgICB0eXBlID0gZmllbGRUeXBlLnR5cGUgPyBmaWVsZFR5cGUudHlwZS50b0xvd2VyQ2FzZSgpIDogXCJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJjYWRlRXhwTWFwLmhhcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGFyY2FkZUZpZWxkID0gYXJjYWRlRXhwTWFwLmdldChmaWVsZE5hbWUpO1xuICAgICAgICB0eXBlID0gYXJjYWRlRmllbGQucmV0dXJuVHlwZSA/IGFyY2FkZUZpZWxkLnJldHVyblR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIG51bWJlciBmb3IgY2x1c3RlclxuICAgICAgICB0eXBlID0gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG59XG4vKipcbiAqIFJldHVybnMgZmVhdHVyZSBjb3VudCBvZiBsYXllclxuICogQHBhcmFtIGxheWVyIC0gRmVhdHVyZUxheWVyIHwgV0ZTTGF5ZXIgfCBPR0NGZWF0dXJlTGF5ZXIgfCBTdHJlYW1MYXllciB8IENTVkxheWVyXG4gKiBAcGFyYW0gbWFwVmlldyAtIFZpZXdcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmVhdHVyZUNvdW50KGxheWVyLCB2aWV3KSB7XG4gICAgaWYgKGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmICFsYXllci51cmwpIHtcbiAgICAgICAgcmV0dXJuIGdldEZlYXR1cmVDb3VudEZvckNvbGxlY3Rpb24obGF5ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsYXllci50eXBlID09PSBcImZlYXR1cmVcIiB8fFxuICAgICAgICBsYXllci50eXBlID09PSBcImNzdlwiIHx8XG4gICAgICAgIGxheWVyLnR5cGUgPT09IFwic2NlbmVcIiB8fFxuICAgICAgICBsYXllci50eXBlID09PSBcIndmc1wiIHx8XG4gICAgICAgIGxheWVyLnR5cGUgPT09IFwiZ2VvanNvblwiKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBsYXllci5xdWVyeUZlYXR1cmVDb3VudCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3ICYmIChsYXllci50eXBlID09PSBcInN0cmVhbVwiIHx8IGxheWVyLnR5cGUgPT09IFwib2djLWZlYXR1cmVcIikpIHtcbiAgICAgICAgcmV0dXJuIGdldEZlYXR1cmVDb3VudEZyb21WaWV3KGxheWVyLCB2aWV3KTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgZmVhdHVyZSBjb3VudCBvZiBmZWF0dXJlIGNvbGxlY3Rpb24gbGF5ZXJcbiAqIEBwYXJhbSBsYXllciAtIEZlYXR1cmVMYXllclxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRGZWF0dXJlQ291bnRGb3JDb2xsZWN0aW9uKGxheWVyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHF1ZXJ5ID0gbGF5ZXIuY3JlYXRlUXVlcnkoKTtcbiAgICBxdWVyeS5vdXRGaWVsZHMgPSBbXCIqXCJdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxheWVyLnF1ZXJ5RmVhdHVyZXMocXVlcnkpO1xuICAgIGlmICgoX2EgPSByZXN1bHQuZmVhdHVyZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5mZWF0dXJlcy5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgZ2V0IGZlYXR1cmUgY291bnRcIik7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGZlYXR1cmUgY291bnQgb2YgZmVhdHVyZSBjb2xsZWN0aW9uIGxheWVyXG4gKiBAcGFyYW0gbGF5ZXIgLSBTdHJlYW1MYXllciB8IE9HQ0ZlYXR1cmVMYXllclxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRGZWF0dXJlQ291bnRGcm9tVmlldyhsYXllciwgdmlldykge1xuICAgIC8vIHdlIGNhbiBvbmx5IGdldCB0aGUgZmVhdHVyZXMgZnJvbSB0aGUgbWFwXG4gICAgY29uc3QgbGF5ZXJWaWV3ID0gKGF3YWl0IHZpZXcud2hlbkxheWVyVmlldyhsYXllcikpO1xuICAgIHJldHVybiBsYXllclZpZXcucXVlcnlGZWF0dXJlQ291bnQoKTtcbn1cbi8qKlxuICogUmV0dXJucyByYXN0ZXIgY291bnQgb2YgaW1hZ2VyeSBsYXllclxuICogQHBhcmFtIGxheWVyIC0gSW1hZ2VyeWxheWVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFJhc3RlckNvdW50KGxheWVyKSB7XG4gICAgaWYgKCFsYXllci51cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGQgbm90IGdldCBsYXllci51cmxcIik7XG4gICAgfVxuICAgIGNvbnN0IFtleGVjdXRlXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvcmVzdC9xdWVyeS9leGVjdXRlRm9yQ291bnRcIl0pO1xuICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgZXhlY3V0ZS5leGVjdXRlRm9yQ291bnQobGF5ZXIudXJsLCB7fSk7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBnZXQgcmFzdGVyIGNvdW50XCIpO1xuICAgIH1cbn1cbmNvbnN0IGdldENsdXN0ZXJGaWVsZHMgPSAocG9wdXBUZW1wbGF0ZSwgZ2V0RXhwcmVzc2lvbkZpZWxkcykgPT4ge1xuICAgIGxldCB0ZW1wRmllbGRzID0gW107XG4gICAgcG9wdXBUZW1wbGF0ZSA9PT0gbnVsbCB8fCBwb3B1cFRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3B1cFRlbXBsYXRlLmZpZWxkSW5mb3MuZm9yRWFjaCgoZmllbGRJbmZvKSA9PiB7XG4gICAgICAgIGlmIChmaWVsZEluZm8uZmllbGROYW1lLmluY2x1ZGVzKGZpZWxkSW5mb1ByZWZpeEVudW0uZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbGF5ZXIucmVuZGVyZXIsIHRvIGJlIHVzZWQgYXMgYSBmaWVsZCBmb3IgY2x1c3RlciBsYWJlbGluZ1xuICAgICAgICAgICAgLy8gYWxzbyBuZWVkZWQgZm9yIHRoZSBleGlzdGluZyBvcHRpb24gaW4gYXJjYWRlXG4gICAgICAgICAgICBnZXRFeHByZXNzaW9uRmllbGRzICYmXG4gICAgICAgICAgICAgICAgdGVtcEZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZmllbGRJbmZvLmZpZWxkTmFtZS5zbGljZShmaWVsZEluZm9QcmVmaXhFbnVtLmV4cHJlc3Npb24ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IGZpZWxkSW5mby5maWVsZE5hbWUuc2xpY2UoZmllbGRJbmZvUHJlZml4RW51bS5leHByZXNzaW9uLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBGaWVsZHMucHVzaCh7IG5hbWU6IGZpZWxkSW5mby5maWVsZE5hbWUsIGFsaWFzOiBmaWVsZEluZm8ubGFiZWwsIHR5cGU6IFwic3RyaW5nXCIgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGVtcEZpZWxkcztcbn07XG4vKipcbiAqIEZpbmQgYW4gZWxlbWVudCB1cCB0aGUgRE9NIHRyZWUuXG4gKiBAcGFyYW0gZWwgLSBIVE1MRWxlbWVudFxuICogQHBhcmFtIHNlbGVjdG9yIC0gU2VsZWN0b3JcbiAqL1xuZnVuY3Rpb24gcXVlcnlQYXJlbnRFbGVtZW50KGVsLCBzZWxlY3Rvcikge1xuICAgIGxldCBpc0lEU2VsZWN0b3IgPSBzZWxlY3Rvci5pbmRleE9mKFwiI1wiKSA9PT0gMDtcbiAgICBsZXQgaXNDbGFzc1NlbGVjdG9yID0gc2VsZWN0b3IuaW5kZXhPZihcIi5cIikgPT09IDA7XG4gICAgaWYgKGlzQ2xhc3NTZWxlY3RvciB8fCBpc0lEU2VsZWN0b3IpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSgxKTtcbiAgICB9XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICAgIGlmIChpc0lEU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmIChlbC5pZCA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDbGFzc1NlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGRlZmluZWRcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuY29uc3QgaWRlbnRpZnlPbk1hcEltYWdlTGF5ZXIgPSBhc3luYyAobGF5ZXIsIG1hcFZpZXcpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IFtpZGVudGlmeSwgSWRlbnRpZnlQYXJhbWV0ZXJzXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgXCJlc3JpL3Jlc3QvaWRlbnRpZnlcIixcbiAgICAgICAgXCJlc3JpL3Jlc3Qvc3VwcG9ydC9JZGVudGlmeVBhcmFtZXRlcnNcIlxuICAgIF0pO1xuICAgIGNvbnN0IHBhcmFtdGVycyA9IG5ldyBJZGVudGlmeVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXRlcnMuZ2VvbWV0cnkgPSBtYXBWaWV3LmV4dGVudDtcbiAgICBwYXJhbXRlcnMubWFwRXh0ZW50ID0gbWFwVmlldy5leHRlbnQ7XG4gICAgcGFyYW10ZXJzLnJldHVybkdlb21ldHJ5ID0gdHJ1ZTtcbiAgICBwYXJhbXRlcnMudG9sZXJhbmNlID0gNjtcbiAgICBwYXJhbXRlcnMubGF5ZXJPcHRpb24gPSBcInBvcHVwXCI7XG4gICAgcGFyYW10ZXJzLndpZHRoID0gbWFwVmlldy53aWR0aDtcbiAgICBwYXJhbXRlcnMuaGVpZ2h0ID0gbWFwVmlldy5oZWlnaHQ7XG4gICAgcGFyYW10ZXJzLmxheWVySWRzID0gW2xheWVyLmlkXTtcbiAgICBjb25zdCBpZGVudGlmeVJlc3VsdHMgPSAoX2EgPSAoYXdhaXQgaWRlbnRpZnkuaWRlbnRpZnkobGF5ZXIubGF5ZXIudXJsLCBwYXJhbXRlcnMpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VsdHM7XG4gICAgY29uc3QgY3VyckZlYXR1cmUgPSAoX2IgPSBpZGVudGlmeVJlc3VsdHMgPT09IG51bGwgfHwgaWRlbnRpZnlSZXN1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZGVudGlmeVJlc3VsdHNbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mZWF0dXJlO1xuICAgIHJldHVybiBjdXJyRmVhdHVyZTtcbn07XG5jb25zdCBnZXRTaW5nbGVDbHVzdGVyRmVhdHVyZSA9IGFzeW5jIChtYXBWaWV3LCBsYXllciwgcG9wdXBUZW1wbGF0ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsYXllclZpZXcgPSBhd2FpdCBtYXBWaWV3LndoZW5MYXllclZpZXcobGF5ZXIpO1xuICAgIGNvbnN0IGNsdXN0ZXJGZWF0dXJlU2V0ID0gYXdhaXQgbGF5ZXJWaWV3LnF1ZXJ5QWdncmVnYXRlcygpO1xuICAgIHJldHVybiBhd2FpdCBnZW5lcmF0ZVNpbmdsZUNsdXN0ZXJGZWF0dXJlKHBvcHVwVGVtcGxhdGUsIChfYSA9IGNsdXN0ZXJGZWF0dXJlU2V0LmZlYXR1cmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pO1xufTtcbmNvbnN0IGdlbmVyYXRlU2luZ2xlQ2x1c3RlckZlYXR1cmUgPSBhc3luYyAocG9wdXBUZW1wbGF0ZSwgY3VyckdyYXBoaWMpID0+IHtcbiAgICBjb25zdCBbR3JhcGhpYywgUG9pbnRHZW9tZXRyeV0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL0dyYXBoaWNcIiwgXCJlc3JpL2dlb21ldHJ5L1BvaW50XCJdKTtcbiAgICBsZXQgY2x1c3RlckdyYXBoaWM7XG4gICAgaWYgKGN1cnJHcmFwaGljKSB7XG4gICAgICAgIGNsdXN0ZXJHcmFwaGljID0gY3VyckdyYXBoaWMuY2xvbmUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNsdXN0ZXJHcmFwaGljID0gbmV3IEdyYXBoaWMoKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gZ2V0Q2x1c3RlckZpZWxkcyhwb3B1cFRlbXBsYXRlLCBmYWxzZSk7XG4gICAgICAgIGlmIChmaWVsZHMgPT09IG51bGwgfHwgZmllbGRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgZmllbGRzLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgICAgICB0ZW1wQXR0cmlidXRlc1tmZWF0dXJlLm5hbWVdID0gXCJcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2x1c3RlckdyYXBoaWMuYXR0cmlidXRlcyA9IHRlbXBBdHRyaWJ1dGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlbXBHZW9tZXRyeSA9IG5ldyBQb2ludEdlb21ldHJ5KCk7XG4gICAgICAgIGNsdXN0ZXJHcmFwaGljLmdlb21ldHJ5ID0gdGVtcEdlb21ldHJ5O1xuICAgIH1cbiAgICByZXR1cm4gY2x1c3RlckdyYXBoaWM7XG59O1xuZnVuY3Rpb24gZ2V0UG9pbnRGcm9tR2VvbWV0cnkoZ2VvbWV0cnkpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFnZW9tZXRyeSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgICAgICBjYXNlIFwiZXh0ZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gZ2VvbWV0cnkuY2VudGVyO1xuICAgICAgICBjYXNlIFwicG9seWdvblwiOlxuICAgICAgICAgICAgcmV0dXJuIGdlb21ldHJ5LmNlbnRyb2lkO1xuICAgICAgICBjYXNlIFwibXVsdGlwb2ludFwiOlxuICAgICAgICBjYXNlIFwicG9seWxpbmVcIjpcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBnZW9tZXRyeS5leHRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jZW50ZXI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGdldEZpZWxkVHlwZSBhcyBhLCBnZXRGaWVsZERpc3BsYXlOYW1lIGFzIGIsIGdldFNlcnZpY2VUeXBlIGFzIGMsIGdlbmVyYXRlTGF5ZXJGaWVsZHNNYXAgYXMgZCwgZ2VuZXJhdGVBcmNhZGVFeHByZXNzaW9uTWFwIGFzIGUsIGlkZW50aWZ5T25NYXBJbWFnZUxheWVyIGFzIGYsIGdldEZlYXR1cmVDb3VudCBhcyBnLCBnZXRMYXllckdlb21ldHJ5VHlwZSBhcyBoLCBpc0RlZmluZWQgYXMgaSwgZ2V0RmllbGRzRnJvbUxheWVyIGFzIGosIGdldENsdXN0ZXJGaWVsZHMgYXMgaywgZ2V0U2luZ2xlQ2x1c3RlckZlYXR1cmUgYXMgbCwgZ2V0U2luZ2xlRmVhdHVyZSBhcyBtLCBnZXRSYXN0ZXJDb3VudCBhcyBuLCBnZXRQb2ludEZyb21HZW9tZXRyeSBhcyBvLCBnZXRTZXJ2aWNlVmVyc2lvbiBhcyBwLCBxdWVyeVBhcmVudEVsZW1lbnQgYXMgcSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb25GdW5jdGlvbnMtYjA4MzBlOWUuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTRkMzY3Njc3LmpzJztcblxuY29uc3QgbGFuZ3VhZ2VNYXAgPSBuZXcgTWFwKFtcbiAgICBbXCJhclwiLCBcImFyXCJdLFxuICAgIFtcImJnXCIsIFwiYmdcIl0sXG4gICAgW1wiYnNcIiwgXCJic1wiXSxcbiAgICBbXCJjYVwiLCBcImNhXCJdLFxuICAgIFtcImNzXCIsIFwiY3NcIl0sXG4gICAgW1wiZGFcIiwgXCJkYVwiXSxcbiAgICBbXCJkZVwiLCBcImRlXCJdLFxuICAgIFtcImVsXCIsIFwiZWxcIl0sXG4gICAgW1wiZW5cIiwgXCJlblwiXSxcbiAgICBbXCJlc1wiLCBcImVzXCJdLFxuICAgIFtcImV0XCIsIFwiZXRcIl0sXG4gICAgW1wiZmlcIiwgXCJmaVwiXSxcbiAgICBbXCJmclwiLCBcImZyXCJdLFxuICAgIFtcImhlXCIsIFwiaGVcIl0sXG4gICAgW1wiaHJcIiwgXCJoclwiXSxcbiAgICBbXCJodVwiLCBcImh1XCJdLFxuICAgIFtcImlkXCIsIFwiaWRcIl0sXG4gICAgW1wiaXRcIiwgXCJpdFwiXSxcbiAgICBbXCJqYVwiLCBcImphXCJdLFxuICAgIFtcImtvXCIsIFwia29cIl0sXG4gICAgW1wibHRcIiwgXCJsdFwiXSxcbiAgICBbXCJsdlwiLCBcImx2XCJdLFxuICAgIFtcIm5iXCIsIFwibmJcIl0sXG4gICAgW1wibmxcIiwgXCJubFwiXSxcbiAgICBbXCJwbFwiLCBcInBsXCJdLFxuICAgIFtcInB0LWJyXCIsIFwicHQtQlJcIl0sXG4gICAgW1wicHQtcHRcIiwgXCJwdC1QVFwiXSxcbiAgICBbXCJyb1wiLCBcInJvXCJdLFxuICAgIFtcInJ1XCIsIFwicnVcIl0sXG4gICAgW1wic2tcIiwgXCJza1wiXSxcbiAgICBbXCJzbFwiLCBcInNsXCJdLFxuICAgIFtcInNyXCIsIFwic3JcIl0sXG4gICAgW1wic3ZcIiwgXCJzdlwiXSxcbiAgICBbXCJ0aFwiLCBcInRoXCJdLFxuICAgIFtcInRyXCIsIFwidHJcIl0sXG4gICAgW1widWtcIiwgXCJ1a1wiXSxcbiAgICBbXCJ2aVwiLCBcInZpXCJdLFxuICAgIFtcInpoLWNuXCIsIFwiemgtQ05cIl0sXG4gICAgW1wiemgtaGtcIiwgXCJ6aC1IS1wiXSxcbiAgICBbXCJ6aC10d1wiLCBcInpoLVRXXCJdXG5dKTtcbi8vIHJ0bFxuZnVuY3Rpb24gZ2V0RWxlbWVudERpcihlbCkge1xuICAgIHJldHVybiBnZXRFbGVtZW50UHJvcChlbCwgXCJkaXJcIiwgXCJsdHJcIik7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UHJvcChlbCwgcHJvcCwgdmFsdWUpIHtcbiAgICBjb25zdCBjbG9zZXN0V2l0aFByb3AgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWwsIGBbJHtwcm9wfV1gKTtcbiAgICByZXR1cm4gY2xvc2VzdFdpdGhQcm9wID8gY2xvc2VzdFdpdGhQcm9wLmdldEF0dHJpYnV0ZShwcm9wKSA6IHZhbHVlO1xufVxuLy8gY3NzXG5jb25zdCBDU1NfVVRJTElUWSA9IHtcbiAgICBydGw6IFwiYXJjZ2lzLS1ydGxcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFwaSwgdHlwZSwgcGxhY2VzIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChhcGkgPT09IDQpIHtcbiAgICAgICAgY29uc3QgW2ludGxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9pbnRsXCJdKTtcbiAgICAgICAgY29uc3QgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMgPSBpbnRsLmNvbnZlcnROdW1iZXJGb3JtYXRUb0ludGxPcHRpb25zKHtcbiAgICAgICAgICAgIHBsYWNlcyxcbiAgICAgICAgICAgIHN0eWxlOiB0eXBlLFxuICAgICAgICAgICAgZGlnaXRTZXBhcmF0b3I6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnRsLmZvcm1hdE51bWJlcihudW1iZXIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMpLCB7IHN0eWxlOiB0eXBlIH0pKTtcbiAgICB9XG4gICAgY29uc3QgW2Rvam9OdW1iZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZG9qby9udW1iZXJcIl0pO1xuICAgIHJldHVybiBkb2pvTnVtYmVyLmZvcm1hdChudW1iZXIsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGxhY2VzLFxuICAgICAgICBwYXR0ZXJuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGF0dGVyblxuICAgIH0pO1xufVxuY29uc3QgY2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICAgIGNvbnN0IGxhbmcgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZztcbiAgICBjb25zdCBkYXlTaG9ydE1vbnRoWWVhciA9IHtcbiAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICB9O1xuICAgIGlmICghY2FjaGVbbGFuZ10pIHtcbiAgICAgICAgY2FjaGVbbGFuZ10gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZywgZGF5U2hvcnRNb250aFllYXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbbGFuZ10uZm9ybWF0KGRhdGUpO1xufVxuZnVuY3Rpb24gZm9ybWF0UGx1cmFsKGxhbmcsIHN0cmluZ09iaiwgbnVtYmVyKSB7XG4gICAgY29uc3Qgc2luZ2xlcyA9IFtcImlkXCIsIFwiamFcIiwgXCJrb1wiLCBcInRoXCIsIFwidmlcIiwgXCJ6aC1jblwiLCBcInpoLWhrXCIsIFwiemgtdHdcIl07XG4gICAgY29uc3QgbGlrZUVuZ2xpc2ggPSBbXG4gICAgICAgIFwiZW5cIixcbiAgICAgICAgXCJjYVwiLFxuICAgICAgICBcImRhXCIsXG4gICAgICAgIFwiZGVcIixcbiAgICAgICAgXCJlbFwiLFxuICAgICAgICBcImVzXCIsXG4gICAgICAgIFwiZXRcIixcbiAgICAgICAgXCJmaVwiLFxuICAgICAgICBcImhpXCIsXG4gICAgICAgIFwiaHVcIixcbiAgICAgICAgXCJpdFwiLFxuICAgICAgICBcIm5iXCIsXG4gICAgICAgIFwibmxcIixcbiAgICAgICAgXCJwdC1wdFwiLFxuICAgICAgICBcInN2XCIsXG4gICAgICAgIFwidHJcIlxuICAgIF07XG4gICAgY29uc3QgbG9jYWxlID0gbGFuZyAhPT0gbnVsbCAmJiBsYW5nICE9PSB2b2lkIDAgPyBsYW5nIDogXCJlblwiO1xuICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgb25lLCBvciBpdCBpcyBhIFwic2ltcGxlXCIgbGFuZ3VhZ2UsIHJldHVybiB0aGUgMSBzdHJpbmdcbiAgICBpZiAobnVtYmVyID09PSAxIHx8IHNpbmdsZXMuaW5jbHVkZXMobG9jYWxlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nT2JqLnNpbmdsZS5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIFwiMVwiKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIG51bWJlciBpcyBub3QgMSBhbmQgdGhlIGxhbmd1YWdlIHVzZXMgdGhlIHNhbWUgcGx1cmFsaXphdGlvbiBzdHJhdGVneSBhcyBlbmdsaXNoLFxuICAgIC8vIHJldHVybiB0aGUgbXVsdGlwbGUgc3RyaW5nXG4gICAgaWYgKG51bWJlciAhPT0gMSAmJiBsaWtlRW5nbGlzaC5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdPYmoubXVsdGlwbGUucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBgJHtudW1iZXJ9YCk7XG4gICAgfVxuICAgIC8vIGlmIG5vbmUgb2YgdGhlIGFib3ZlIHdvcmtlZCwgcmV0dXJuIHRoZSBcInVua25vd25cIiBzdHJpbmdcbiAgICByZXR1cm4gc3RyaW5nT2JqLnVua25vd24ucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBgJHtudW1iZXJ9YCk7XG59XG5cbmV4cG9ydCB7IENTU19VVElMSVRZIGFzIEMsIGZvcm1hdERhdGUgYXMgYSwgZm9ybWF0UGx1cmFsIGFzIGIsIGZvcm1hdE51bWJlciBhcyBmLCBnZXRFbGVtZW50RGlyIGFzIGcsIGxhbmd1YWdlTWFwIGFzIGwgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==