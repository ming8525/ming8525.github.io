"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-0cac7b"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-args-helper-ab401543.js":
/*!************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-args-helper-ab401543.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ SwitchableTypes),
/* harmony export */   a: () => (/* binding */ getRFTName),
/* harmony export */   b: () => (/* binding */ getArgRFT),
/* harmony export */   c: () => (/* binding */ canBuildArgRFTUI),
/* harmony export */   d: () => (/* binding */ getCaseInsensitiveArg),
/* harmony export */   e: () => (/* binding */ containsArgName),
/* harmony export */   f: () => (/* binding */ getEnumData),
/* harmony export */   g: () => (/* binding */ getFunctionSchema),
/* harmony export */   h: () => (/* binding */ hasRasterElements),
/* harmony export */   i: () => (/* binding */ isSingleArgumentFunction),
/* harmony export */   j: () => (/* binding */ cloneRFT),
/* harmony export */   k: () => (/* binding */ getSchemaArgKey),
/* harmony export */   l: () => (/* binding */ hasRFTElements),
/* harmony export */   m: () => (/* binding */ getRasterArrayInputArgs),
/* harmony export */   n: () => (/* binding */ isFunctionChain),
/* harmony export */   o: () => (/* binding */ getRFxDefKeyFromRFT),
/* harmony export */   p: () => (/* binding */ parseSwitchableDomainArguments),
/* harmony export */   q: () => (/* binding */ getArguments),
/* harmony export */   r: () => (/* binding */ getInputArgsFromElementInfos),
/* harmony export */   s: () => (/* binding */ shouldHonorIsPublic),
/* harmony export */   u: () => (/* binding */ useRFxArgWidget)
/* harmony export */ });
/* harmony import */ var _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @arcgis/core/core/lang.js */ "@arcgis/core/core/lang.js");
/* harmony import */ var _resources_27c66f5c_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources-27c66f5c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/resources-27c66f5c.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");
/* harmony import */ var _functions_f1f2dffd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functions-f1f2dffd.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/functions-f1f2dffd.js");
/* harmony import */ var _interfaces_d0c68944_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interfaces-d0c68944.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/interfaces-d0c68944.js");






const SwitchableTypes = {
    List: "list",
    Unit: "linearUnit",
    Number: "number",
    Field: "field"
};
function isSingleArgumentFunction(rfxArgs) {
    const isDatasetDefined = !(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.i)(rfxArgs?.isDataset);
    const isRFV = rfxArgs?.type === _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.R;
    return isDatasetDefined && isRFV;
}
/**
 * Deep clone an object or an array, excluding specified properties.
 * Used to avoid circular dependency error.
 *
 * @param src The source object or array to clone.
 * @param excludeProps An array of property names to exclude from the cloned object.
 * @returns A deep copy of the input object or array.
 */
function cloneRFT(src, excludeProps) {
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.i)(excludeProps)) {
        return _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_0__.clone(src);
    }
    // Create a new object to hold the cloned properties
    const dest = {};
    // If the input is an object and not an array, clone each of its properties
    if (typeof src === "object" && src !== null && !Array.isArray(src)) {
        for (const propName in src) {
            if (src.hasOwnProperty(propName) && excludeProps.indexOf(propName) < 0) {
                dest[propName] = cloneRFT(src[propName], excludeProps);
            }
        }
        return dest;
    }
    // If the input is an array, clone each of its elements
    if (Array.isArray(src)) {
        return src.map((element) => {
            return cloneRFT(element, excludeProps);
        });
    }
    // If the input is a primitive type, use esriLang.clone to create a copy
    return _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_0__.clone(src);
}
/**
 * Get the value of an argument with case-insensitive name matching.
 * @param argName - The name of the argument to retrieve.
 * @param args - The object containing the arguments to search.
 * @returns The value of the argument with the given name, or undefined if not found.
 */
function getCaseInsensitiveArg(argName, args) {
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.i)(argName) || (0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.i)(args)) {
        return undefined;
    }
    const argKey = Object.keys(args).find((key) => key.toLowerCase() === argName.toLowerCase());
    return argKey ? args[argKey] : undefined;
}
/**
 * Finds the schema key that matches the given RFx argument key in a case-insensitive manner.
 *
 * @param {RFxSchema} functionSchemaArgs - The schema to search for the argument key.
 * @param {string} rfxArgKey - The RFx argument key to find a matching schema key for.
 * @returns {string} - The matching schema key.
 */
function getSchemaArgKey(functionSchemaArgs, rfxArgKey) {
    if (!functionSchemaArgs) {
        return "";
    }
    const schemaKeys = Object.keys(functionSchemaArgs);
    if (rfxArgKey === undefined && schemaKeys.length === 1) {
        // If the rfxArg doesn't have a key, and the schema only has 1 argument defined,
        // return it
        return schemaKeys[0];
    }
    const matchingSchemaKey = schemaKeys.find((key) => key.toLowerCase() === rfxArgKey?.toLowerCase());
    return matchingSchemaKey ?? "";
}
/**
 * Gets the name of the RFxTemplate.
 * @param rfxTemplate The RFxTemplate object to get the name from.
 * @returns The name of the RFxTemplate.
 */
async function getRFTName(rfxTemplate) {
    const functionType = rfxTemplate?.function?.type?.toLowerCase()?.replace("function", "");
    const functionArguments = rfxTemplate?.arguments;
    const specialCaseMap = _resources_27c66f5c_js__WEBPACK_IMPORTED_MODULE_1__.h.rfxNameSpecialCases;
    const localFunctionOperations = _resources_27c66f5c_js__WEBPACK_IMPORTED_MODULE_1__.h.localFunctionOperations;
    const enums = await (0,_resources_27c66f5c_js__WEBPACK_IMPORTED_MODULE_1__.g)();
    switch (functionType) {
        case "local":
            const operationValue = functionArguments?.Operation?.value;
            const localOp = localFunctionOperations.find((op) => op.key === operationValue);
            if (!(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.i)(localOp)) {
                return localOp.label;
            }
            else if (enums.cellStatisticsTypes.some((op) => op.key === operationValue)) {
                return "CellStatistics";
            }
            break;
        case "pythonadapter": {
            const pyClassName = functionArguments?.ClassName?.value;
            return pyClassName || null;
        }
        case "gpadapter": {
            const toolNameValue = functionArguments?.ToolName?.value?.toLowerCase()?.replace("_sa", "");
            const specialCase = specialCaseMap.find((sc) => sc.key === toolNameValue);
            return specialCase?.value || toolNameValue || null;
        }
        default: {
            const specialCase = specialCaseMap.find((sc) => sc.key === functionType);
            return specialCase?.value || functionType || null;
        }
    }
    return null;
}
function getArgRFT(rfxArg) {
    if (!rfxArg) {
        return;
    }
    if (rfxArg.type === _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.b) {
        return rfxArg;
    }
    else if (rfxArg.value && rfxArg.value.type === _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.b) {
        return rfxArg.value;
    }
}
/**
 * This function takes a schema object and an RFxTemplate object as input and returns
 * the schema for the corresponding function, based on the function type and name
 * determined by getFunctionName.
 * @param param
 * @returns
 */
function getFunctionSchema({ schema, rfxTemplate }) {
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.i)(rfxTemplate?.function?.type)) {
        return;
    }
    const functionType = rfxTemplate.function.type;
    const rfxArgs = rfxTemplate?.arguments;
    let functionName = (0,_functions_f1f2dffd_js__WEBPACK_IMPORTED_MODULE_3__.e)(rfxArgs);
    // The following handles case of "LocalFunction"
    if (!functionName || (!schema.hasOwnProperty(functionName) && schema.hasOwnProperty(functionType))) {
        functionName = functionType;
    }
    return schema[functionName];
}
function hasRasterElements(rfxArg) {
    // Check if an argument has raster elements in it
    // Can be { value: { elements[] } }, in which case we check in the elements
    // Else check value itself
    // Assumption: the array will only have raster/RFT elements, so checking only first element
    if (!rfxArg || !rfxArg.value) {
        return false;
    }
    const elements = rfxArg.value.elements ? rfxArg.value.elements : rfxArg.value;
    const element = elements[0];
    return element && (element.isDataset || element.type === _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.b);
}
/**
 * Determines if the given RFxTemplate should honor the "isPublic" flag.
 * If the RFxTemplate has any aliases defined, the "isPublic" flag is honored.
 * Otherwise, the "isPublic" flag is ignored.
 * Additionally, if any argument in the RFxTemplate has "isPublic" set to true,
 * the method returns true.
 * @param {RFxTemplate} rfxTemplate - The RFxTemplate to check.
 * @returns {boolean} - True if the RFxTemplate should honor the "isPublic" flag, false otherwise.
 */
function shouldHonorIsPublic(rfxTemplate) {
    if (!rfxTemplate || !rfxTemplate[_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.A]) {
        return false;
    }
    // If RFT has aliases, honor isPublic
    if (rfxTemplate.aliases) {
        return true;
    }
    const checkRFxArg = (rfxArg) => {
        if (!rfxArg) {
            return false;
        }
        // If rfxArg is public, return true
        if (rfxArg.isPublic) {
            return true;
        }
        // If rfxArg contains raster elements, check if any of the elements are public
        if (hasRasterElements(rfxArg)) {
            const elements = rfxArg.value && rfxArg.value.elements ? rfxArg.value.elements : rfxArg.value;
            if (elements && Array.isArray(elements)) {
                return elements.some((element) => checkRFxArg(element));
            }
        }
        // Recursively check the rfxArg's RFT if it exists
        const rfxArgRFT = getArgRFT(rfxArg);
        return rfxArgRFT ? shouldHonorIsPublic(rfxArgRFT) : false;
    };
    const rfxArgs = rfxTemplate[_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.A];
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.a)(rfxArgs)) {
        return checkRFxArg(rfxArgs);
    }
    return Object.keys(rfxArgs).some((rfxArgName) => {
        const rfxArg = rfxArgs[rfxArgName];
        if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.a)(rfxArg)) {
            return checkRFxArg(rfxArg);
        }
    });
}
/**
 * Determines whether to use an RFx argument widget for the given argument schema.
 * @param argSchema - The argument schema to evaluate.
 * @returns True if an RFx argument widget should be used for the given schema, false otherwise.
 */
function useRFxArgWidget(argSchema) {
    if (!argSchema) {
        return false;
    }
    const isRasterArray = argSchema.dataType === _resources_27c66f5c_js__WEBPACK_IMPORTED_MODULE_1__.d.rasterArray;
    const hasElementInfos = Boolean(argSchema.elementInfos);
    const isTable = argSchema.dataType === _resources_27c66f5c_js__WEBPACK_IMPORTED_MODULE_1__.d.table;
    return (isRasterArray && hasElementInfos) || isTable;
}
/**
 * Check if an argument name is contained in an array of argument names.
 *
 * @param {string[]} argNameArr - Array of argument names.
 * @param {string} argName - Name of the argument to check.
 * @returns {boolean} - `true` if the argument name is contained in the array, `false` otherwise.
 */
function containsArgName(argNameArr, argName) {
    return Array.isArray(argNameArr) && argNameArr.some((activeArg) => activeArg.toLowerCase() === argName.toLowerCase());
}
/**
 * Checks whether an argument has RFT elements in it.
 * Can be { value: { elements[] } }, in which case we check in the elements, else check value itself
 * @param {any} rfxArg - The RFx argument to check for RFT elements.
 * @returns {boolean} True if the argument has RFT elements, false otherwise.
 */
function hasRFTElements(rfxArg) {
    if (!rfxArg || !rfxArg.value) {
        return false;
    }
    const elements = rfxArg.value.elements ? rfxArg.value.elements : rfxArg.value;
    if (Array.isArray(elements)) {
        return elements.some(function (element) {
            return element && element.type === _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.b;
        });
    }
    return false;
}
function getEnumData(enumData) {
    enumData?.forEach((enumElement) => {
        enumElement.key = enumElement.key.toString();
    });
    return enumData;
    // dont remove this snippet. Can be used when we have to hide parameter options
    // function _removeOptionsToHide(): RFxArgumentEnum {
    //   const optionsToHide = {
    //     StatisticsType: [5, 6, 7], //[median, majority, minority]
    //     RegressionType: [3, 4], // [trendMannKendall, trendSeasonalKendall]
    //     ChangeType: [4, 5, 6, 7] //[longestChange, shortestChange, fastestChange, slowestChange]
    //   };
    //   if (portalMode === "multitenant" && optionsToHide[enumName]) {
    //     enumData = enumData.filter((rfxArgenum) => rfxArgenum && optionsToHide[enumName].indexOf(rfxArgenum.key) < 0);
    //   }
    //   return enumData;
    // }
}
//@resh TODO: remove this function, came with porting, can be done without this.
function parseSwitchableDomainArguments(attributes, rfxArgs) {
    attributes.forEach((attribute) => {
        if (attribute.type === "field") {
            const argument = getCaseInsensitiveArg(attribute.argumentName, rfxArgs);
            attribute.argumentName = argument.name;
            attribute.layerArgument = argument;
        }
        else if (attribute.type === _resources_27c66f5c_js__WEBPACK_IMPORTED_MODULE_1__.a.list || attribute.type === _resources_27c66f5c_js__WEBPACK_IMPORTED_MODULE_1__.a.linearUnit) {
            attribute.enumStore = getEnumData[attribute.enum];
        }
    });
    return attributes;
}
function getRasterArrayInputArgs(argSchema, rfxArgs) {
    let inputArgs;
    const nElementsArgument = getCaseInsensitiveArg(argSchema.nElementsArgument, rfxArgs);
    const nElementsArgumentValue = nElementsArgument?.value;
    const elementInfos = argSchema.elementInfos;
    if ((nElementsArgument === undefined || nElementsArgumentValue === undefined) && elementInfos.length === 1) {
        // For the simple case where the element infos is static, not dependent on another argument
        return elementInfos[0].inputArgs;
    }
    if (Array.isArray(elementInfos)) {
        elementInfos.some((elementInfo) => {
            const values = elementInfo.values;
            if (Array.isArray(values) && values.indexOf(nElementsArgumentValue) > -1) {
                inputArgs = elementInfo.inputArgs;
                return true;
            }
        });
    }
    return inputArgs;
}
/**
 * To check if the given Arg contains any RFT
 * @param rfxArg
 * @returns
 */
function canBuildArgRFTUI(rfxArg) {
    if (!rfxArg)
        return false;
    const argRFT = getArgRFT(rfxArg);
    if (argRFT) {
        return true;
    }
    else if (hasRFTElements(rfxArg)) {
        return true;
    }
    return false;
}
/**
 * To check if a template is a chain or has only one function
 * @param {RFxTemplate} rfxTemplate
 * @returns {boolean} true if template is a function chain or false otherwis
 */
function isFunctionChain(rfxTemplate) {
    let isFnChain = false;
    const rfxArgs = rfxTemplate[_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.A];
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.a)(rfxArgs)) {
        // checks if the arguments are of type Raster function template. Then exit with true
        return true;
    }
    // if arguments are not RFT_TYPE , then chances of the rfxTemplate being a chain is ,
    // any of the argument value is an array of RFTs
    for (const rfxTemplateArgName in rfxArgs) {
        if (rfxTemplateArgName === _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.T) {
            continue;
        }
        const rfxTemplateArg = rfxArgs[rfxTemplateArgName];
        if (canBuildArgRFTUI(rfxTemplateArg)) {
            // checks each argument and if it as RFT elements
            isFnChain = true;
            return isFnChain;
        }
    }
    return isFnChain;
}
/**
 * Get system raster function definition key from input RFT
 * @param {RFxTemplate} rfxTemplate to get the system raster function definition key from
 * @returns {string | undefined} the system RFx definition key or undefined for custom function cases
 */
function getRFxDefKeyFromRFT(rfxTemplate) {
    let functionDefKey = rfxTemplate?.function?.type;
    if (functionDefKey === "LocalFunction") {
        // for local funcitons, return rfx def key as `LocalFunction__${localOp}`
        // for example, return "LocalFunction__1" for Plus function
        const localOp = rfxTemplate.arguments?.Operation?.value?.toString();
        if (localOp !== undefined) {
            functionDefKey += `__${localOp}`;
        }
    }
    return functionDefKey;
}
function isSingleArgRFx({ functionSchema, rfxTemplate }) {
    // Single argument RFTs by design store the Raster Function Variable as the value of arguments property
    const schema = functionSchema;
    let schemaArgs;
    if (schema) {
        schemaArgs = schema.rasterFunctionArguments;
        if (Object.keys(schemaArgs).length === 1 && !schema.hasArgumentsObject) {
            return true;
        }
    }
    const rfxArgs = rfxTemplate.arguments, argsType = rfxArgs && rfxArgs.type;
    if (argsType &&
        (argsType === _interfaces_d0c68944_js__WEBPACK_IMPORTED_MODULE_4__.J.RASTER_FUNCTION_TEMPLATE || argsType === _interfaces_d0c68944_js__WEBPACK_IMPORTED_MODULE_4__.J.RASTER_FUNCTION_VARIABLE)) {
        return true;
    }
}
function getArguments({ functionSchema, rfxTemplate }) {
    if (!rfxTemplate) {
        return;
    }
    const args = [], rfxArgs = rfxTemplate.arguments, argsType = rfxArgs && rfxArgs.type;
    if (isSingleArgRFx({ functionSchema, rfxTemplate })) {
        const arg = _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_0__.clone(rfxArgs);
        let argKey;
        if (argsType === _interfaces_d0c68944_js__WEBPACK_IMPORTED_MODULE_4__.J.RASTER_FUNCTION_TEMPLATE || arg.isDataset) {
            // Aspect or similar raster function with a single raster argument
            argKey = "Raster";
        }
        else {
            // CompositeBand or similar
            argKey = "Rasters";
        }
        args.push({ ...arg, key: argKey });
        return args;
    }
    Object.keys(rfxArgs).forEach((rfxArgKey) => {
        if (rfxArgKey === _interfaces_d0c68944_js__WEBPACK_IMPORTED_MODULE_4__.M.MATCH_VARIABLE || rfxArgKey === _interfaces_d0c68944_js__WEBPACK_IMPORTED_MODULE_4__.M.UNION_DIMENSION) {
            return;
        }
        const rfxArg = _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_0__.clone(rfxArgs[rfxArgKey]);
        if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.a)(rfxArg)) {
            args.push({ ...rfxArg, key: rfxArgKey });
        }
    });
    return args;
}
function getInputArgsFromElementInfos(elementInfos, nElementsArgument) {
    const nElementsArgumentValue = nElementsArgument && nElementsArgument.value;
    if (nElementsArgumentValue == null) {
        return;
    }
    let inputArgs;
    elementInfos.some((elementInfo) => {
        if (elementInfo.values && elementInfo.values.indexOf(nElementsArgumentValue) > -1) {
            inputArgs = elementInfo.inputArgs;
            return true;
        }
    });
    return inputArgs;
}



//# sourceMappingURL=rfx-args-helper-ab401543.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTBjYWM3Yi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUNrRDtBQUM0QztBQUNyRjtBQUN5Qjs7QUFFeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQWU7QUFDN0Msb0NBQW9DLHVEQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFlO0FBQ3ZCLGVBQWUsNERBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVcsNERBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQWUsYUFBYSwyREFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQU87QUFDbEMsb0NBQW9DLHFEQUFPO0FBQzNDLHdCQUF3Qix5REFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLHNCQUFzQixzREFBVSwwQ0FBMEMsc0RBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQsb0JBQW9CLDREQUFjO0FBQ2xDO0FBQ0EseUJBQXlCLHNEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQXNCLGlDQUFpQyxzREFBc0I7QUFDdkc7QUFDQTtBQUNBLHVCQUF1Qiw0REFBYztBQUNyQyxZQUFZLDJEQUFRO0FBQ3BCLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFOGY7O0FBRTlmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vcmZ4LWFyZ3MtaGVscGVyLWFiNDAxNTQzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGVzcmlMYW5nIGZyb20gJ0BhcmNnaXMvY29yZS9jb3JlL2xhbmcuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRFbnVtcywgYSBhcyBkb21haW5UeXBlcywgZCBhcyBkYXRhVHlwZXMsIGggYXMgaGVscERvYyB9IGZyb20gJy4vcmVzb3VyY2VzLTI3YzY2ZjVjLmpzJztcbmltcG9ydCB7IGkgYXMgaXNFbXB0eURhdGFJdGVtLCBiIGFzIFJGVF9UWVBFLCBBIGFzIEFSR1NfS0VZV09SRCwgYSBhcyBpc1JGeEFyZywgVCBhcyBUWVBFX0tFWVdPUkQsIFIgYXMgUkZWX1RZUEUgfSBmcm9tICcuL3R5cGUtZ2F1cmRzLTE4NDA3NDdmLmpzJztcbmltcG9ydCB7IGUgYXMgZ2V0RnVuY3Rpb25OYW1lIH0gZnJvbSAnLi9mdW5jdGlvbnMtZjFmMmRmZmQuanMnO1xuaW1wb3J0IHsgTSBhcyBNVUxUSURJTUVOU0lPTkFMX1JVTEVTLCBKIGFzIEpTT05fVFlQRVMgfSBmcm9tICcuL2ludGVyZmFjZXMtZDBjNjg5NDQuanMnO1xuXG5jb25zdCBTd2l0Y2hhYmxlVHlwZXMgPSB7XG4gICAgTGlzdDogXCJsaXN0XCIsXG4gICAgVW5pdDogXCJsaW5lYXJVbml0XCIsXG4gICAgTnVtYmVyOiBcIm51bWJlclwiLFxuICAgIEZpZWxkOiBcImZpZWxkXCJcbn07XG5mdW5jdGlvbiBpc1NpbmdsZUFyZ3VtZW50RnVuY3Rpb24ocmZ4QXJncykge1xuICAgIGNvbnN0IGlzRGF0YXNldERlZmluZWQgPSAhaXNFbXB0eURhdGFJdGVtKHJmeEFyZ3M/LmlzRGF0YXNldCk7XG4gICAgY29uc3QgaXNSRlYgPSByZnhBcmdzPy50eXBlID09PSBSRlZfVFlQRTtcbiAgICByZXR1cm4gaXNEYXRhc2V0RGVmaW5lZCAmJiBpc1JGVjtcbn1cbi8qKlxuICogRGVlcCBjbG9uZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXksIGV4Y2x1ZGluZyBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAqIFVzZWQgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2Ugb2JqZWN0IG9yIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIGV4Y2x1ZGVQcm9wcyBBbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0byBleGNsdWRlIGZyb20gdGhlIGNsb25lZCBvYmplY3QuXG4gKiBAcmV0dXJucyBBIGRlZXAgY29weSBvZiB0aGUgaW5wdXQgb2JqZWN0IG9yIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVJGVChzcmMsIGV4Y2x1ZGVQcm9wcykge1xuICAgIGlmIChpc0VtcHR5RGF0YUl0ZW0oZXhjbHVkZVByb3BzKSkge1xuICAgICAgICByZXR1cm4gZXNyaUxhbmcuY2xvbmUoc3JjKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCB0byBob2xkIHRoZSBjbG9uZWQgcHJvcGVydGllc1xuICAgIGNvbnN0IGRlc3QgPSB7fTtcbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYW4gb2JqZWN0IGFuZCBub3QgYW4gYXJyYXksIGNsb25lIGVhY2ggb2YgaXRzIHByb3BlcnRpZXNcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIiAmJiBzcmMgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIHNyYykge1xuICAgICAgICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgZXhjbHVkZVByb3BzLmluZGV4T2YocHJvcE5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGRlc3RbcHJvcE5hbWVdID0gY2xvbmVSRlQoc3JjW3Byb3BOYW1lXSwgZXhjbHVkZVByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIGFuIGFycmF5LCBjbG9uZSBlYWNoIG9mIGl0cyBlbGVtZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZVJGVChlbGVtZW50LCBleGNsdWRlUHJvcHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgcHJpbWl0aXZlIHR5cGUsIHVzZSBlc3JpTGFuZy5jbG9uZSB0byBjcmVhdGUgYSBjb3B5XG4gICAgcmV0dXJuIGVzcmlMYW5nLmNsb25lKHNyYyk7XG59XG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYW4gYXJndW1lbnQgd2l0aCBjYXNlLWluc2Vuc2l0aXZlIG5hbWUgbWF0Y2hpbmcuXG4gKiBAcGFyYW0gYXJnTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudCB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSBhcmdzIC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBhcmd1bWVudHMgdG8gc2VhcmNoLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudCB3aXRoIHRoZSBnaXZlbiBuYW1lLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICovXG5mdW5jdGlvbiBnZXRDYXNlSW5zZW5zaXRpdmVBcmcoYXJnTmFtZSwgYXJncykge1xuICAgIGlmIChpc0VtcHR5RGF0YUl0ZW0oYXJnTmFtZSkgfHwgaXNFbXB0eURhdGFJdGVtKGFyZ3MpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ0tleSA9IE9iamVjdC5rZXlzKGFyZ3MpLmZpbmQoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IGFyZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgcmV0dXJuIGFyZ0tleSA/IGFyZ3NbYXJnS2V5XSA6IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogRmluZHMgdGhlIHNjaGVtYSBrZXkgdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBSRnggYXJndW1lbnQga2V5IGluIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYW5uZXIuXG4gKlxuICogQHBhcmFtIHtSRnhTY2hlbWF9IGZ1bmN0aW9uU2NoZW1hQXJncyAtIFRoZSBzY2hlbWEgdG8gc2VhcmNoIGZvciB0aGUgYXJndW1lbnQga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IHJmeEFyZ0tleSAtIFRoZSBSRnggYXJndW1lbnQga2V5IHRvIGZpbmQgYSBtYXRjaGluZyBzY2hlbWEga2V5IGZvci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIG1hdGNoaW5nIHNjaGVtYSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldFNjaGVtYUFyZ0tleShmdW5jdGlvblNjaGVtYUFyZ3MsIHJmeEFyZ0tleSkge1xuICAgIGlmICghZnVuY3Rpb25TY2hlbWFBcmdzKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBzY2hlbWFLZXlzID0gT2JqZWN0LmtleXMoZnVuY3Rpb25TY2hlbWFBcmdzKTtcbiAgICBpZiAocmZ4QXJnS2V5ID09PSB1bmRlZmluZWQgJiYgc2NoZW1hS2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJmeEFyZyBkb2Vzbid0IGhhdmUgYSBrZXksIGFuZCB0aGUgc2NoZW1hIG9ubHkgaGFzIDEgYXJndW1lbnQgZGVmaW5lZCxcbiAgICAgICAgLy8gcmV0dXJuIGl0XG4gICAgICAgIHJldHVybiBzY2hlbWFLZXlzWzBdO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGluZ1NjaGVtYUtleSA9IHNjaGVtYUtleXMuZmluZCgoa2V5KSA9PiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gcmZ4QXJnS2V5Py50b0xvd2VyQ2FzZSgpKTtcbiAgICByZXR1cm4gbWF0Y2hpbmdTY2hlbWFLZXkgPz8gXCJcIjtcbn1cbi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgUkZ4VGVtcGxhdGUuXG4gKiBAcGFyYW0gcmZ4VGVtcGxhdGUgVGhlIFJGeFRlbXBsYXRlIG9iamVjdCB0byBnZXQgdGhlIG5hbWUgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBSRnhUZW1wbGF0ZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UkZUTmFtZShyZnhUZW1wbGF0ZSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uVHlwZSA9IHJmeFRlbXBsYXRlPy5mdW5jdGlvbj8udHlwZT8udG9Mb3dlckNhc2UoKT8ucmVwbGFjZShcImZ1bmN0aW9uXCIsIFwiXCIpO1xuICAgIGNvbnN0IGZ1bmN0aW9uQXJndW1lbnRzID0gcmZ4VGVtcGxhdGU/LmFyZ3VtZW50cztcbiAgICBjb25zdCBzcGVjaWFsQ2FzZU1hcCA9IGhlbHBEb2MucmZ4TmFtZVNwZWNpYWxDYXNlcztcbiAgICBjb25zdCBsb2NhbEZ1bmN0aW9uT3BlcmF0aW9ucyA9IGhlbHBEb2MubG9jYWxGdW5jdGlvbk9wZXJhdGlvbnM7XG4gICAgY29uc3QgZW51bXMgPSBhd2FpdCBnZXRFbnVtcygpO1xuICAgIHN3aXRjaCAoZnVuY3Rpb25UeXBlKSB7XG4gICAgICAgIGNhc2UgXCJsb2NhbFwiOlxuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uVmFsdWUgPSBmdW5jdGlvbkFyZ3VtZW50cz8uT3BlcmF0aW9uPy52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsT3AgPSBsb2NhbEZ1bmN0aW9uT3BlcmF0aW9ucy5maW5kKChvcCkgPT4gb3Aua2V5ID09PSBvcGVyYXRpb25WYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHlEYXRhSXRlbShsb2NhbE9wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbE9wLmxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW51bXMuY2VsbFN0YXRpc3RpY3NUeXBlcy5zb21lKChvcCkgPT4gb3Aua2V5ID09PSBvcGVyYXRpb25WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJDZWxsU3RhdGlzdGljc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJweXRob25hZGFwdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHB5Q2xhc3NOYW1lID0gZnVuY3Rpb25Bcmd1bWVudHM/LkNsYXNzTmFtZT8udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gcHlDbGFzc05hbWUgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZ3BhZGFwdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lVmFsdWUgPSBmdW5jdGlvbkFyZ3VtZW50cz8uVG9vbE5hbWU/LnZhbHVlPy50b0xvd2VyQ2FzZSgpPy5yZXBsYWNlKFwiX3NhXCIsIFwiXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3BlY2lhbENhc2UgPSBzcGVjaWFsQ2FzZU1hcC5maW5kKChzYykgPT4gc2Mua2V5ID09PSB0b29sTmFtZVZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBzcGVjaWFsQ2FzZT8udmFsdWUgfHwgdG9vbE5hbWVWYWx1ZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNpYWxDYXNlID0gc3BlY2lhbENhc2VNYXAuZmluZCgoc2MpID0+IHNjLmtleSA9PT0gZnVuY3Rpb25UeXBlKTtcbiAgICAgICAgICAgIHJldHVybiBzcGVjaWFsQ2FzZT8udmFsdWUgfHwgZnVuY3Rpb25UeXBlIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRBcmdSRlQocmZ4QXJnKSB7XG4gICAgaWYgKCFyZnhBcmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmZ4QXJnLnR5cGUgPT09IFJGVF9UWVBFKSB7XG4gICAgICAgIHJldHVybiByZnhBcmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJmeEFyZy52YWx1ZSAmJiByZnhBcmcudmFsdWUudHlwZSA9PT0gUkZUX1RZUEUpIHtcbiAgICAgICAgcmV0dXJuIHJmeEFyZy52YWx1ZTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBzY2hlbWEgb2JqZWN0IGFuZCBhbiBSRnhUZW1wbGF0ZSBvYmplY3QgYXMgaW5wdXQgYW5kIHJldHVybnNcbiAqIHRoZSBzY2hlbWEgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGZ1bmN0aW9uLCBiYXNlZCBvbiB0aGUgZnVuY3Rpb24gdHlwZSBhbmQgbmFtZVxuICogZGV0ZXJtaW5lZCBieSBnZXRGdW5jdGlvbk5hbWUuXG4gKiBAcGFyYW0gcGFyYW1cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uU2NoZW1hKHsgc2NoZW1hLCByZnhUZW1wbGF0ZSB9KSB7XG4gICAgaWYgKGlzRW1wdHlEYXRhSXRlbShyZnhUZW1wbGF0ZT8uZnVuY3Rpb24/LnR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZnVuY3Rpb25UeXBlID0gcmZ4VGVtcGxhdGUuZnVuY3Rpb24udHlwZTtcbiAgICBjb25zdCByZnhBcmdzID0gcmZ4VGVtcGxhdGU/LmFyZ3VtZW50cztcbiAgICBsZXQgZnVuY3Rpb25OYW1lID0gZ2V0RnVuY3Rpb25OYW1lKHJmeEFyZ3MpO1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgaGFuZGxlcyBjYXNlIG9mIFwiTG9jYWxGdW5jdGlvblwiXG4gICAgaWYgKCFmdW5jdGlvbk5hbWUgfHwgKCFzY2hlbWEuaGFzT3duUHJvcGVydHkoZnVuY3Rpb25OYW1lKSAmJiBzY2hlbWEuaGFzT3duUHJvcGVydHkoZnVuY3Rpb25UeXBlKSkpIHtcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25UeXBlO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hW2Z1bmN0aW9uTmFtZV07XG59XG5mdW5jdGlvbiBoYXNSYXN0ZXJFbGVtZW50cyhyZnhBcmcpIHtcbiAgICAvLyBDaGVjayBpZiBhbiBhcmd1bWVudCBoYXMgcmFzdGVyIGVsZW1lbnRzIGluIGl0XG4gICAgLy8gQ2FuIGJlIHsgdmFsdWU6IHsgZWxlbWVudHNbXSB9IH0sIGluIHdoaWNoIGNhc2Ugd2UgY2hlY2sgaW4gdGhlIGVsZW1lbnRzXG4gICAgLy8gRWxzZSBjaGVjayB2YWx1ZSBpdHNlbGZcbiAgICAvLyBBc3N1bXB0aW9uOiB0aGUgYXJyYXkgd2lsbCBvbmx5IGhhdmUgcmFzdGVyL1JGVCBlbGVtZW50cywgc28gY2hlY2tpbmcgb25seSBmaXJzdCBlbGVtZW50XG4gICAgaWYgKCFyZnhBcmcgfHwgIXJmeEFyZy52YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gcmZ4QXJnLnZhbHVlLmVsZW1lbnRzID8gcmZ4QXJnLnZhbHVlLmVsZW1lbnRzIDogcmZ4QXJnLnZhbHVlO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgICByZXR1cm4gZWxlbWVudCAmJiAoZWxlbWVudC5pc0RhdGFzZXQgfHwgZWxlbWVudC50eXBlID09PSBSRlRfVFlQRSk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIFJGeFRlbXBsYXRlIHNob3VsZCBob25vciB0aGUgXCJpc1B1YmxpY1wiIGZsYWcuXG4gKiBJZiB0aGUgUkZ4VGVtcGxhdGUgaGFzIGFueSBhbGlhc2VzIGRlZmluZWQsIHRoZSBcImlzUHVibGljXCIgZmxhZyBpcyBob25vcmVkLlxuICogT3RoZXJ3aXNlLCB0aGUgXCJpc1B1YmxpY1wiIGZsYWcgaXMgaWdub3JlZC5cbiAqIEFkZGl0aW9uYWxseSwgaWYgYW55IGFyZ3VtZW50IGluIHRoZSBSRnhUZW1wbGF0ZSBoYXMgXCJpc1B1YmxpY1wiIHNldCB0byB0cnVlLFxuICogdGhlIG1ldGhvZCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0ge1JGeFRlbXBsYXRlfSByZnhUZW1wbGF0ZSAtIFRoZSBSRnhUZW1wbGF0ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIFJGeFRlbXBsYXRlIHNob3VsZCBob25vciB0aGUgXCJpc1B1YmxpY1wiIGZsYWcsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkSG9ub3JJc1B1YmxpYyhyZnhUZW1wbGF0ZSkge1xuICAgIGlmICghcmZ4VGVtcGxhdGUgfHwgIXJmeFRlbXBsYXRlW0FSR1NfS0VZV09SRF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiBSRlQgaGFzIGFsaWFzZXMsIGhvbm9yIGlzUHVibGljXG4gICAgaWYgKHJmeFRlbXBsYXRlLmFsaWFzZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrUkZ4QXJnID0gKHJmeEFyZykgPT4ge1xuICAgICAgICBpZiAoIXJmeEFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHJmeEFyZyBpcyBwdWJsaWMsIHJldHVybiB0cnVlXG4gICAgICAgIGlmIChyZnhBcmcuaXNQdWJsaWMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHJmeEFyZyBjb250YWlucyByYXN0ZXIgZWxlbWVudHMsIGNoZWNrIGlmIGFueSBvZiB0aGUgZWxlbWVudHMgYXJlIHB1YmxpY1xuICAgICAgICBpZiAoaGFzUmFzdGVyRWxlbWVudHMocmZ4QXJnKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSByZnhBcmcudmFsdWUgJiYgcmZ4QXJnLnZhbHVlLmVsZW1lbnRzID8gcmZ4QXJnLnZhbHVlLmVsZW1lbnRzIDogcmZ4QXJnLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzICYmIEFycmF5LmlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLnNvbWUoKGVsZW1lbnQpID0+IGNoZWNrUkZ4QXJnKGVsZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayB0aGUgcmZ4QXJnJ3MgUkZUIGlmIGl0IGV4aXN0c1xuICAgICAgICBjb25zdCByZnhBcmdSRlQgPSBnZXRBcmdSRlQocmZ4QXJnKTtcbiAgICAgICAgcmV0dXJuIHJmeEFyZ1JGVCA/IHNob3VsZEhvbm9ySXNQdWJsaWMocmZ4QXJnUkZUKSA6IGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgcmZ4QXJncyA9IHJmeFRlbXBsYXRlW0FSR1NfS0VZV09SRF07XG4gICAgaWYgKGlzUkZ4QXJnKHJmeEFyZ3MpKSB7XG4gICAgICAgIHJldHVybiBjaGVja1JGeEFyZyhyZnhBcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJmeEFyZ3MpLnNvbWUoKHJmeEFyZ05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgcmZ4QXJnID0gcmZ4QXJnc1tyZnhBcmdOYW1lXTtcbiAgICAgICAgaWYgKGlzUkZ4QXJnKHJmeEFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1JGeEFyZyhyZnhBcmcpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgYW4gUkZ4IGFyZ3VtZW50IHdpZGdldCBmb3IgdGhlIGdpdmVuIGFyZ3VtZW50IHNjaGVtYS5cbiAqIEBwYXJhbSBhcmdTY2hlbWEgLSBUaGUgYXJndW1lbnQgc2NoZW1hIHRvIGV2YWx1YXRlLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhbiBSRnggYXJndW1lbnQgd2lkZ2V0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgZ2l2ZW4gc2NoZW1hLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHVzZVJGeEFyZ1dpZGdldChhcmdTY2hlbWEpIHtcbiAgICBpZiAoIWFyZ1NjaGVtYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlzUmFzdGVyQXJyYXkgPSBhcmdTY2hlbWEuZGF0YVR5cGUgPT09IGRhdGFUeXBlcy5yYXN0ZXJBcnJheTtcbiAgICBjb25zdCBoYXNFbGVtZW50SW5mb3MgPSBCb29sZWFuKGFyZ1NjaGVtYS5lbGVtZW50SW5mb3MpO1xuICAgIGNvbnN0IGlzVGFibGUgPSBhcmdTY2hlbWEuZGF0YVR5cGUgPT09IGRhdGFUeXBlcy50YWJsZTtcbiAgICByZXR1cm4gKGlzUmFzdGVyQXJyYXkgJiYgaGFzRWxlbWVudEluZm9zKSB8fCBpc1RhYmxlO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhbiBhcmd1bWVudCBuYW1lIGlzIGNvbnRhaW5lZCBpbiBhbiBhcnJheSBvZiBhcmd1bWVudCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmdOYW1lQXJyIC0gQXJyYXkgb2YgYXJndW1lbnQgbmFtZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJnTmFtZSAtIE5hbWUgb2YgdGhlIGFyZ3VtZW50IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gYHRydWVgIGlmIHRoZSBhcmd1bWVudCBuYW1lIGlzIGNvbnRhaW5lZCBpbiB0aGUgYXJyYXksIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBjb250YWluc0FyZ05hbWUoYXJnTmFtZUFyciwgYXJnTmFtZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZ05hbWVBcnIpICYmIGFyZ05hbWVBcnIuc29tZSgoYWN0aXZlQXJnKSA9PiBhY3RpdmVBcmcudG9Mb3dlckNhc2UoKSA9PT0gYXJnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYW4gYXJndW1lbnQgaGFzIFJGVCBlbGVtZW50cyBpbiBpdC5cbiAqIENhbiBiZSB7IHZhbHVlOiB7IGVsZW1lbnRzW10gfSB9LCBpbiB3aGljaCBjYXNlIHdlIGNoZWNrIGluIHRoZSBlbGVtZW50cywgZWxzZSBjaGVjayB2YWx1ZSBpdHNlbGZcbiAqIEBwYXJhbSB7YW55fSByZnhBcmcgLSBUaGUgUkZ4IGFyZ3VtZW50IHRvIGNoZWNrIGZvciBSRlQgZWxlbWVudHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYXJndW1lbnQgaGFzIFJGVCBlbGVtZW50cywgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBoYXNSRlRFbGVtZW50cyhyZnhBcmcpIHtcbiAgICBpZiAoIXJmeEFyZyB8fCAhcmZ4QXJnLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSByZnhBcmcudmFsdWUuZWxlbWVudHMgPyByZnhBcmcudmFsdWUuZWxlbWVudHMgOiByZnhBcmcudmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFJGVF9UWVBFO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0RW51bURhdGEoZW51bURhdGEpIHtcbiAgICBlbnVtRGF0YT8uZm9yRWFjaCgoZW51bUVsZW1lbnQpID0+IHtcbiAgICAgICAgZW51bUVsZW1lbnQua2V5ID0gZW51bUVsZW1lbnQua2V5LnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVudW1EYXRhO1xuICAgIC8vIGRvbnQgcmVtb3ZlIHRoaXMgc25pcHBldC4gQ2FuIGJlIHVzZWQgd2hlbiB3ZSBoYXZlIHRvIGhpZGUgcGFyYW1ldGVyIG9wdGlvbnNcbiAgICAvLyBmdW5jdGlvbiBfcmVtb3ZlT3B0aW9uc1RvSGlkZSgpOiBSRnhBcmd1bWVudEVudW0ge1xuICAgIC8vICAgY29uc3Qgb3B0aW9uc1RvSGlkZSA9IHtcbiAgICAvLyAgICAgU3RhdGlzdGljc1R5cGU6IFs1LCA2LCA3XSwgLy9bbWVkaWFuLCBtYWpvcml0eSwgbWlub3JpdHldXG4gICAgLy8gICAgIFJlZ3Jlc3Npb25UeXBlOiBbMywgNF0sIC8vIFt0cmVuZE1hbm5LZW5kYWxsLCB0cmVuZFNlYXNvbmFsS2VuZGFsbF1cbiAgICAvLyAgICAgQ2hhbmdlVHlwZTogWzQsIDUsIDYsIDddIC8vW2xvbmdlc3RDaGFuZ2UsIHNob3J0ZXN0Q2hhbmdlLCBmYXN0ZXN0Q2hhbmdlLCBzbG93ZXN0Q2hhbmdlXVxuICAgIC8vICAgfTtcbiAgICAvLyAgIGlmIChwb3J0YWxNb2RlID09PSBcIm11bHRpdGVuYW50XCIgJiYgb3B0aW9uc1RvSGlkZVtlbnVtTmFtZV0pIHtcbiAgICAvLyAgICAgZW51bURhdGEgPSBlbnVtRGF0YS5maWx0ZXIoKHJmeEFyZ2VudW0pID0+IHJmeEFyZ2VudW0gJiYgb3B0aW9uc1RvSGlkZVtlbnVtTmFtZV0uaW5kZXhPZihyZnhBcmdlbnVtLmtleSkgPCAwKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiBlbnVtRGF0YTtcbiAgICAvLyB9XG59XG4vL0ByZXNoIFRPRE86IHJlbW92ZSB0aGlzIGZ1bmN0aW9uLCBjYW1lIHdpdGggcG9ydGluZywgY2FuIGJlIGRvbmUgd2l0aG91dCB0aGlzLlxuZnVuY3Rpb24gcGFyc2VTd2l0Y2hhYmxlRG9tYWluQXJndW1lbnRzKGF0dHJpYnV0ZXMsIHJmeEFyZ3MpIHtcbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICBpZiAoYXR0cmlidXRlLnR5cGUgPT09IFwiZmllbGRcIikge1xuICAgICAgICAgICAgY29uc3QgYXJndW1lbnQgPSBnZXRDYXNlSW5zZW5zaXRpdmVBcmcoYXR0cmlidXRlLmFyZ3VtZW50TmFtZSwgcmZ4QXJncyk7XG4gICAgICAgICAgICBhdHRyaWJ1dGUuYXJndW1lbnROYW1lID0gYXJndW1lbnQubmFtZTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZS5sYXllckFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXR0cmlidXRlLnR5cGUgPT09IGRvbWFpblR5cGVzLmxpc3QgfHwgYXR0cmlidXRlLnR5cGUgPT09IGRvbWFpblR5cGVzLmxpbmVhclVuaXQpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZS5lbnVtU3RvcmUgPSBnZXRFbnVtRGF0YVthdHRyaWJ1dGUuZW51bV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIGdldFJhc3RlckFycmF5SW5wdXRBcmdzKGFyZ1NjaGVtYSwgcmZ4QXJncykge1xuICAgIGxldCBpbnB1dEFyZ3M7XG4gICAgY29uc3QgbkVsZW1lbnRzQXJndW1lbnQgPSBnZXRDYXNlSW5zZW5zaXRpdmVBcmcoYXJnU2NoZW1hLm5FbGVtZW50c0FyZ3VtZW50LCByZnhBcmdzKTtcbiAgICBjb25zdCBuRWxlbWVudHNBcmd1bWVudFZhbHVlID0gbkVsZW1lbnRzQXJndW1lbnQ/LnZhbHVlO1xuICAgIGNvbnN0IGVsZW1lbnRJbmZvcyA9IGFyZ1NjaGVtYS5lbGVtZW50SW5mb3M7XG4gICAgaWYgKChuRWxlbWVudHNBcmd1bWVudCA9PT0gdW5kZWZpbmVkIHx8IG5FbGVtZW50c0FyZ3VtZW50VmFsdWUgPT09IHVuZGVmaW5lZCkgJiYgZWxlbWVudEluZm9zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBGb3IgdGhlIHNpbXBsZSBjYXNlIHdoZXJlIHRoZSBlbGVtZW50IGluZm9zIGlzIHN0YXRpYywgbm90IGRlcGVuZGVudCBvbiBhbm90aGVyIGFyZ3VtZW50XG4gICAgICAgIHJldHVybiBlbGVtZW50SW5mb3NbMF0uaW5wdXRBcmdzO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50SW5mb3MpKSB7XG4gICAgICAgIGVsZW1lbnRJbmZvcy5zb21lKChlbGVtZW50SW5mbykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZWxlbWVudEluZm8udmFsdWVzO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSAmJiB2YWx1ZXMuaW5kZXhPZihuRWxlbWVudHNBcmd1bWVudFZhbHVlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRBcmdzID0gZWxlbWVudEluZm8uaW5wdXRBcmdzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0QXJncztcbn1cbi8qKlxuICogVG8gY2hlY2sgaWYgdGhlIGdpdmVuIEFyZyBjb250YWlucyBhbnkgUkZUXG4gKiBAcGFyYW0gcmZ4QXJnXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBjYW5CdWlsZEFyZ1JGVFVJKHJmeEFyZykge1xuICAgIGlmICghcmZ4QXJnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYXJnUkZUID0gZ2V0QXJnUkZUKHJmeEFyZyk7XG4gICAgaWYgKGFyZ1JGVCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFzUkZURWxlbWVudHMocmZ4QXJnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBUbyBjaGVjayBpZiBhIHRlbXBsYXRlIGlzIGEgY2hhaW4gb3IgaGFzIG9ubHkgb25lIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JGeFRlbXBsYXRlfSByZnhUZW1wbGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGVtcGxhdGUgaXMgYSBmdW5jdGlvbiBjaGFpbiBvciBmYWxzZSBvdGhlcndpc1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uQ2hhaW4ocmZ4VGVtcGxhdGUpIHtcbiAgICBsZXQgaXNGbkNoYWluID0gZmFsc2U7XG4gICAgY29uc3QgcmZ4QXJncyA9IHJmeFRlbXBsYXRlW0FSR1NfS0VZV09SRF07XG4gICAgaWYgKGlzUkZ4QXJnKHJmeEFyZ3MpKSB7XG4gICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgYXJndW1lbnRzIGFyZSBvZiB0eXBlIFJhc3RlciBmdW5jdGlvbiB0ZW1wbGF0ZS4gVGhlbiBleGl0IHdpdGggdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaWYgYXJndW1lbnRzIGFyZSBub3QgUkZUX1RZUEUgLCB0aGVuIGNoYW5jZXMgb2YgdGhlIHJmeFRlbXBsYXRlIGJlaW5nIGEgY2hhaW4gaXMgLFxuICAgIC8vIGFueSBvZiB0aGUgYXJndW1lbnQgdmFsdWUgaXMgYW4gYXJyYXkgb2YgUkZUc1xuICAgIGZvciAoY29uc3QgcmZ4VGVtcGxhdGVBcmdOYW1lIGluIHJmeEFyZ3MpIHtcbiAgICAgICAgaWYgKHJmeFRlbXBsYXRlQXJnTmFtZSA9PT0gVFlQRV9LRVlXT1JEKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZnhUZW1wbGF0ZUFyZyA9IHJmeEFyZ3NbcmZ4VGVtcGxhdGVBcmdOYW1lXTtcbiAgICAgICAgaWYgKGNhbkJ1aWxkQXJnUkZUVUkocmZ4VGVtcGxhdGVBcmcpKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgZWFjaCBhcmd1bWVudCBhbmQgaWYgaXQgYXMgUkZUIGVsZW1lbnRzXG4gICAgICAgICAgICBpc0ZuQ2hhaW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGlzRm5DaGFpbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNGbkNoYWluO1xufVxuLyoqXG4gKiBHZXQgc3lzdGVtIHJhc3RlciBmdW5jdGlvbiBkZWZpbml0aW9uIGtleSBmcm9tIGlucHV0IFJGVFxuICogQHBhcmFtIHtSRnhUZW1wbGF0ZX0gcmZ4VGVtcGxhdGUgdG8gZ2V0IHRoZSBzeXN0ZW0gcmFzdGVyIGZ1bmN0aW9uIGRlZmluaXRpb24ga2V5IGZyb21cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IHRoZSBzeXN0ZW0gUkZ4IGRlZmluaXRpb24ga2V5IG9yIHVuZGVmaW5lZCBmb3IgY3VzdG9tIGZ1bmN0aW9uIGNhc2VzXG4gKi9cbmZ1bmN0aW9uIGdldFJGeERlZktleUZyb21SRlQocmZ4VGVtcGxhdGUpIHtcbiAgICBsZXQgZnVuY3Rpb25EZWZLZXkgPSByZnhUZW1wbGF0ZT8uZnVuY3Rpb24/LnR5cGU7XG4gICAgaWYgKGZ1bmN0aW9uRGVmS2V5ID09PSBcIkxvY2FsRnVuY3Rpb25cIikge1xuICAgICAgICAvLyBmb3IgbG9jYWwgZnVuY2l0b25zLCByZXR1cm4gcmZ4IGRlZiBrZXkgYXMgYExvY2FsRnVuY3Rpb25fXyR7bG9jYWxPcH1gXG4gICAgICAgIC8vIGZvciBleGFtcGxlLCByZXR1cm4gXCJMb2NhbEZ1bmN0aW9uX18xXCIgZm9yIFBsdXMgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgbG9jYWxPcCA9IHJmeFRlbXBsYXRlLmFyZ3VtZW50cz8uT3BlcmF0aW9uPy52YWx1ZT8udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGxvY2FsT3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWZLZXkgKz0gYF9fJHtsb2NhbE9wfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uRGVmS2V5O1xufVxuZnVuY3Rpb24gaXNTaW5nbGVBcmdSRngoeyBmdW5jdGlvblNjaGVtYSwgcmZ4VGVtcGxhdGUgfSkge1xuICAgIC8vIFNpbmdsZSBhcmd1bWVudCBSRlRzIGJ5IGRlc2lnbiBzdG9yZSB0aGUgUmFzdGVyIEZ1bmN0aW9uIFZhcmlhYmxlIGFzIHRoZSB2YWx1ZSBvZiBhcmd1bWVudHMgcHJvcGVydHlcbiAgICBjb25zdCBzY2hlbWEgPSBmdW5jdGlvblNjaGVtYTtcbiAgICBsZXQgc2NoZW1hQXJncztcbiAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgIHNjaGVtYUFyZ3MgPSBzY2hlbWEucmFzdGVyRnVuY3Rpb25Bcmd1bWVudHM7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWFBcmdzKS5sZW5ndGggPT09IDEgJiYgIXNjaGVtYS5oYXNBcmd1bWVudHNPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJmeEFyZ3MgPSByZnhUZW1wbGF0ZS5hcmd1bWVudHMsIGFyZ3NUeXBlID0gcmZ4QXJncyAmJiByZnhBcmdzLnR5cGU7XG4gICAgaWYgKGFyZ3NUeXBlICYmXG4gICAgICAgIChhcmdzVHlwZSA9PT0gSlNPTl9UWVBFUy5SQVNURVJfRlVOQ1RJT05fVEVNUExBVEUgfHwgYXJnc1R5cGUgPT09IEpTT05fVFlQRVMuUkFTVEVSX0ZVTkNUSU9OX1ZBUklBQkxFKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRBcmd1bWVudHMoeyBmdW5jdGlvblNjaGVtYSwgcmZ4VGVtcGxhdGUgfSkge1xuICAgIGlmICghcmZ4VGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW10sIHJmeEFyZ3MgPSByZnhUZW1wbGF0ZS5hcmd1bWVudHMsIGFyZ3NUeXBlID0gcmZ4QXJncyAmJiByZnhBcmdzLnR5cGU7XG4gICAgaWYgKGlzU2luZ2xlQXJnUkZ4KHsgZnVuY3Rpb25TY2hlbWEsIHJmeFRlbXBsYXRlIH0pKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IGVzcmlMYW5nLmNsb25lKHJmeEFyZ3MpO1xuICAgICAgICBsZXQgYXJnS2V5O1xuICAgICAgICBpZiAoYXJnc1R5cGUgPT09IEpTT05fVFlQRVMuUkFTVEVSX0ZVTkNUSU9OX1RFTVBMQVRFIHx8IGFyZy5pc0RhdGFzZXQpIHtcbiAgICAgICAgICAgIC8vIEFzcGVjdCBvciBzaW1pbGFyIHJhc3RlciBmdW5jdGlvbiB3aXRoIGEgc2luZ2xlIHJhc3RlciBhcmd1bWVudFxuICAgICAgICAgICAgYXJnS2V5ID0gXCJSYXN0ZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbXBvc2l0ZUJhbmQgb3Igc2ltaWxhclxuICAgICAgICAgICAgYXJnS2V5ID0gXCJSYXN0ZXJzXCI7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKHsgLi4uYXJnLCBrZXk6IGFyZ0tleSB9KTtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHJmeEFyZ3MpLmZvckVhY2goKHJmeEFyZ0tleSkgPT4ge1xuICAgICAgICBpZiAocmZ4QXJnS2V5ID09PSBNVUxUSURJTUVOU0lPTkFMX1JVTEVTLk1BVENIX1ZBUklBQkxFIHx8IHJmeEFyZ0tleSA9PT0gTVVMVElESU1FTlNJT05BTF9SVUxFUy5VTklPTl9ESU1FTlNJT04pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZnhBcmcgPSBlc3JpTGFuZy5jbG9uZShyZnhBcmdzW3JmeEFyZ0tleV0pO1xuICAgICAgICBpZiAoaXNSRnhBcmcocmZ4QXJnKSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKHsgLi4ucmZ4QXJnLCBrZXk6IHJmeEFyZ0tleSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhcmdzO1xufVxuZnVuY3Rpb24gZ2V0SW5wdXRBcmdzRnJvbUVsZW1lbnRJbmZvcyhlbGVtZW50SW5mb3MsIG5FbGVtZW50c0FyZ3VtZW50KSB7XG4gICAgY29uc3QgbkVsZW1lbnRzQXJndW1lbnRWYWx1ZSA9IG5FbGVtZW50c0FyZ3VtZW50ICYmIG5FbGVtZW50c0FyZ3VtZW50LnZhbHVlO1xuICAgIGlmIChuRWxlbWVudHNBcmd1bWVudFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgaW5wdXRBcmdzO1xuICAgIGVsZW1lbnRJbmZvcy5zb21lKChlbGVtZW50SW5mbykgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudEluZm8udmFsdWVzICYmIGVsZW1lbnRJbmZvLnZhbHVlcy5pbmRleE9mKG5FbGVtZW50c0FyZ3VtZW50VmFsdWUpID4gLTEpIHtcbiAgICAgICAgICAgIGlucHV0QXJncyA9IGVsZW1lbnRJbmZvLmlucHV0QXJncztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlucHV0QXJncztcbn1cblxuZXhwb3J0IHsgU3dpdGNoYWJsZVR5cGVzIGFzIFMsIGdldFJGVE5hbWUgYXMgYSwgZ2V0QXJnUkZUIGFzIGIsIGNhbkJ1aWxkQXJnUkZUVUkgYXMgYywgZ2V0Q2FzZUluc2Vuc2l0aXZlQXJnIGFzIGQsIGNvbnRhaW5zQXJnTmFtZSBhcyBlLCBnZXRFbnVtRGF0YSBhcyBmLCBnZXRGdW5jdGlvblNjaGVtYSBhcyBnLCBoYXNSYXN0ZXJFbGVtZW50cyBhcyBoLCBpc1NpbmdsZUFyZ3VtZW50RnVuY3Rpb24gYXMgaSwgY2xvbmVSRlQgYXMgaiwgZ2V0U2NoZW1hQXJnS2V5IGFzIGssIGhhc1JGVEVsZW1lbnRzIGFzIGwsIGdldFJhc3RlckFycmF5SW5wdXRBcmdzIGFzIG0sIGlzRnVuY3Rpb25DaGFpbiBhcyBuLCBnZXRSRnhEZWZLZXlGcm9tUkZUIGFzIG8sIHBhcnNlU3dpdGNoYWJsZURvbWFpbkFyZ3VtZW50cyBhcyBwLCBnZXRBcmd1bWVudHMgYXMgcSwgZ2V0SW5wdXRBcmdzRnJvbUVsZW1lbnRJbmZvcyBhcyByLCBzaG91bGRIb25vcklzUHVibGljIGFzIHMsIHVzZVJGeEFyZ1dpZGdldCBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJmeC1hcmdzLWhlbHBlci1hYjQwMTU0My5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=