"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_ba-infographic_node_modules_arcgis_business-analyst-components_dis-5fd423"],{

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/calcite-color-picker.entry.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/calcite-color-picker.entry.js ***!
  \***********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calcite_color_picker: () => (/* binding */ ColorPicker)
/* harmony export */ });
/* harmony import */ var _index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index-4e647411.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/index-4e647411.js");
/* harmony import */ var _index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-56dd1c42.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/index-56dd1c42.js");
/* harmony import */ var _dom_1997bfaf_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-1997bfaf.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/dom-1997bfaf.js");
/* harmony import */ var _utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils-a71d8ee9.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/utils-a71d8ee9.js");
/* harmony import */ var _interactive_29995522_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./interactive-29995522.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/interactive-29995522.js");
/* harmony import */ var _key_b75491c4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./key-b75491c4.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/key-b75491c4.js");
/* harmony import */ var _loadable_cc14d728_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./loadable-cc14d728.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/loadable-cc14d728.js");
/* harmony import */ var _locale_706df4c7_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./locale-706df4c7.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/locale-706df4c7.js");
/* harmony import */ var _math_7efd987a_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math-7efd987a.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/math-7efd987a.js");
/* harmony import */ var _t9n_9603ff05_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./t9n-9603ff05.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/t9n-9603ff05.js");
/* harmony import */ var _debounce_047e09f4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debounce-047e09f4.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/debounce-047e09f4.js");
















/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if ((0,_debounce_047e09f4_js__WEBPACK_IMPORTED_MODULE_0__.i)(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return (0,_debounce_047e09f4_js__WEBPACK_IMPORTED_MODULE_0__.d)(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const CSS = {
  container: "container",
  controlSection: "control-section",
  hexOptions: "color-hex-options",
  section: "section",
  header: "header",
  control: "control",
  splitSection: "section--split",
  colorModeContainer: "color-mode-container",
  colorMode: "color-mode",
  channels: "channels",
  channel: "channel",
  savedColors: "saved-colors",
  savedColorsSection: "saved-colors-section",
  saveColor: "save-color",
  deleteColor: "delete-color",
  savedColorsButtons: "saved-colors-buttons",
  headerHex: "header--hex",
  colorFieldAndSlider: "color-field-and-slider",
  colorFieldAndSliderInteractive: "color-field-and-slider--interactive",
  colorFieldAndSliderWrap: "color-field-and-slider-wrap",
  scope: "scope",
  hueScope: "scope--hue",
  colorFieldScope: "scope--color-field",
  savedColor: "saved-color"
};
const DEFAULT_COLOR = (0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)("#007AC2");
const DEFAULT_STORAGE_KEY_PREFIX = "calcite-color-";
const RGB_LIMITS = {
  r: 255,
  g: 255,
  b: 255
};
const HSV_LIMITS = {
  h: 360,
  s: 100,
  v: 100
};
const DIMENSIONS = {
  s: {
    slider: {
      height: 10,
      width: 160
    },
    colorField: {
      height: 80,
      width: 160
    },
    thumb: {
      radius: 8
    }
  },
  m: {
    slider: {
      height: 14,
      width: 272
    },
    colorField: {
      height: 150,
      width: 272
    },
    thumb: {
      radius: 10
    }
  },
  l: {
    slider: {
      height: 16,
      width: 464
    },
    colorField: {
      height: 200,
      width: 464
    },
    thumb: {
      radius: 12
    }
  }
};

const colorPickerCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host([disabled]){pointer-events:none;cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-ui-opacity-disabled)}:host{display:inline-block;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-normal)}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}:host([scale=s]) .container{inline-size:160px}:host([scale=s]) .saved-colors{grid-template-columns:repeat(auto-fill, minmax(20px, 1fr))}:host([scale=s]) .channels{flex-direction:column}:host([scale=s]) .channel{inline-size:100%;margin-block-end:4px}:host([scale=s]) .channel:last-child{margin-block-end:0}:host([scale=m]) .container{inline-size:272px}:host([scale=l]) .header{padding-block-end:0px}:host([scale=l]){font-size:var(--calcite-font-size--1);line-height:1rem}:host([scale=l]) .container{inline-size:464px}:host([scale=l]) .color-field-and-slider{margin-block-end:-20px}:host([scale=l]) .section{padding-block:0 16px;padding-inline:16px}:host([scale=l]) .section:first-of-type{padding-block-start:16px}:host([scale=l]) .saved-colors{grid-template-columns:repeat(auto-fill, minmax(28px, 1fr));grid-gap:12px;padding-block-start:16px}:host([scale=l]) .control-section{flex-wrap:nowrap;align-items:baseline}:host([scale=l]) .control-section>:nth-child(2){margin-inline-start:12px}:host([scale=l]) .color-hex-options{display:flex;flex-shrink:1;flex-direction:column;justify-content:space-around;min-block-size:98px;inline-size:160px}:host([scale=l]) .color-mode-container{flex-shrink:3}.container{background-color:var(--calcite-ui-foreground-1);display:inline-block;border:1px solid var(--calcite-ui-border-1)}.color-field-and-slider-wrap{position:relative}.scope{pointer-events:none;position:absolute;font-size:var(--calcite-font-size--1);outline-color:transparent;outline-offset:14px}.scope:focus{outline:2px solid var(--calcite-ui-brand);outline-offset:16px}.color-field-and-slider{margin-block-end:-16px;touch-action:none}.color-field-and-slider--interactive{cursor:pointer}.control-section{display:flex;flex-direction:row;flex-wrap:wrap}.section{padding-block:0 12px;padding-inline:12px}.section:first-of-type{padding-block-start:12px}.color-hex-options,.section--split{flex-grow:1}.header{display:flex;align-items:center;justify-content:space-between;padding-block-end:0.25rem;color:var(--calcite-ui-text-1)}.header--hex,.color-mode-container{padding-block-start:12px}.channels{display:flex;justify-content:space-between}.channel{inline-size:31%}.saved-colors{padding-block-start:12px;display:grid;grid-template-columns:repeat(auto-fill, minmax(24px, 1fr));grid-gap:8px;inline-size:100%}.saved-colors-buttons{display:flex}.saved-color{outline-offset:0;outline-color:transparent;cursor:pointer}.saved-color:focus{outline:2px solid var(--calcite-ui-brand);outline-offset:2px}.saved-color:hover{transition:outline-color var(--calcite-internal-animation-timing-fast) ease-in-out;outline:2px solid var(--calcite-ui-border-2);outline-offset:2px}";

const throttleFor60FpsInMs = 16;
const defaultValue = (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.n)(DEFAULT_COLOR.hex());
const defaultFormat = "auto";
const ColorPicker = class {
  constructor(hostRef) {
    (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.r)(this, hostRef);
    this.calciteColorPickerChange = (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.c)(this, "calciteColorPickerChange", 6);
    this.calciteColorPickerInput = (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.c)(this, "calciteColorPickerInput", 6);
    this.colorFieldAndSliderHovered = false;
    this.hueThumbState = "idle";
    this.internalColorUpdateContext = null;
    this.mode = _utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.C.HEX;
    this.shiftKeyChannelAdjustment = 0;
    this.sliderThumbState = "idle";
    this.handleTabActivate = (event) => {
      this.channelMode = event.currentTarget.getAttribute("data-color-mode");
      this.updateChannelsFromColor(this.color);
    };
    this.handleColorFieldScopeKeyDown = (event) => {
      const { key } = event;
      const arrowKeyToXYOffset = {
        ArrowUp: { x: 0, y: -10 },
        ArrowRight: { x: 10, y: 0 },
        ArrowDown: { x: 0, y: 10 },
        ArrowLeft: { x: -10, y: 0 }
      };
      if (arrowKeyToXYOffset[key]) {
        event.preventDefault();
        this.scopeOrientation = key === "ArrowDown" || key === "ArrowUp" ? "vertical" : "horizontal";
        this.captureColorFieldColor(this.colorFieldScopeLeft + arrowKeyToXYOffset[key].x || 0, this.colorFieldScopeTop + arrowKeyToXYOffset[key].y || 0, false);
      }
    };
    this.handleHueScopeKeyDown = (event) => {
      const modifier = event.shiftKey ? 10 : 1;
      const { key } = event;
      const arrowKeyToXOffset = {
        ArrowUp: 1,
        ArrowRight: 1,
        ArrowDown: -1,
        ArrowLeft: -1
      };
      if (arrowKeyToXOffset[key]) {
        event.preventDefault();
        const delta = arrowKeyToXOffset[key] * modifier;
        const hue = this.baseColorFieldColor.hue();
        const color = this.baseColorFieldColor.hue(hue + delta);
        this.internalColorSet(color, false);
      }
    };
    this.handleHexInputChange = (event) => {
      event.stopPropagation();
      const { allowEmpty, color: color$1 } = this;
      const input = event.target;
      const hex = input.value;
      if (allowEmpty && !hex) {
        this.internalColorSet(null);
        return;
      }
      const normalizedHex = color$1 && (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.n)(color$1.hex());
      if (hex !== normalizedHex) {
        this.internalColorSet((0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(hex));
      }
    };
    this.handleSavedColorSelect = (event) => {
      const swatch = event.currentTarget;
      this.internalColorSet((0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(swatch.color));
    };
    this.handleChannelInput = (event) => {
      const input = event.currentTarget;
      const channelIndex = Number(input.getAttribute("data-channel-index"));
      const limit = this.channelMode === "rgb"
        ? RGB_LIMITS[Object.keys(RGB_LIMITS)[channelIndex]]
        : HSV_LIMITS[Object.keys(HSV_LIMITS)[channelIndex]];
      let inputValue;
      if (this.allowEmpty && !input.value) {
        inputValue = "";
      }
      else {
        const value = Number(input.value) + this.shiftKeyChannelAdjustment;
        const clamped = (0,_math_7efd987a_js__WEBPACK_IMPORTED_MODULE_4__.c)(value, 0, limit);
        inputValue = clamped.toString();
      }
      input.value = inputValue;
      // TODO: refactor calcite-input so we don't need to sync the internals
      // https://github.com/Esri/calcite-components/issues/6100
      input.internalSyncChildElValue();
    };
    this.handleChannelChange = (event) => {
      const input = event.currentTarget;
      const channelIndex = Number(input.getAttribute("data-channel-index"));
      const channels = [...this.channels];
      const shouldClearChannels = this.allowEmpty && !input.value;
      if (shouldClearChannels) {
        this.channels = [null, null, null];
        this.internalColorSet(null);
        return;
      }
      channels[channelIndex] = Number(input.value);
      this.updateColorFromChannels(channels);
    };
    this.handleSavedColorKeyDown = (event) => {
      if ((0,_key_b75491c4_js__WEBPACK_IMPORTED_MODULE_5__.i)(event.key)) {
        event.preventDefault();
        this.handleSavedColorSelect(event);
      }
    };
    this.handleColorFieldAndSliderPointerLeave = () => {
      this.colorFieldAndSliderInteractive = false;
      this.colorFieldAndSliderHovered = false;
      if (this.sliderThumbState !== "drag" && this.hueThumbState !== "drag") {
        this.hueThumbState = "idle";
        this.sliderThumbState = "idle";
        this.drawColorFieldAndSlider();
      }
    };
    this.handleColorFieldAndSliderPointerDown = (event) => {
      if (!(0,_dom_1997bfaf_js__WEBPACK_IMPORTED_MODULE_6__.i)(event)) {
        return;
      }
      const { offsetX, offsetY } = event;
      const region = this.getCanvasRegion(offsetY);
      if (region === "color-field") {
        this.hueThumbState = "drag";
        this.captureColorFieldColor(offsetX, offsetY);
        this.colorFieldScopeNode?.focus();
      }
      else if (region === "slider") {
        this.sliderThumbState = "drag";
        this.captureHueSliderColor(offsetX);
        this.hueScopeNode?.focus();
      }
      // prevent text selection outside of color field & slider area
      event.preventDefault();
      document.addEventListener("pointermove", this.globalPointerMoveHandler);
      document.addEventListener("pointerup", this.globalPointerUpHandler, { once: true });
      this.activeColorFieldAndSliderRect =
        this.fieldAndSliderRenderingContext.canvas.getBoundingClientRect();
    };
    this.globalPointerUpHandler = (event) => {
      if (!(0,_dom_1997bfaf_js__WEBPACK_IMPORTED_MODULE_6__.i)(event)) {
        return;
      }
      const previouslyDragging = this.sliderThumbState === "drag" || this.hueThumbState === "drag";
      this.hueThumbState = "idle";
      this.sliderThumbState = "idle";
      this.activeColorFieldAndSliderRect = null;
      this.drawColorFieldAndSlider();
      if (previouslyDragging) {
        this.calciteColorPickerChange.emit();
      }
    };
    this.globalPointerMoveHandler = (event) => {
      const { el, dimensions } = this;
      const sliderThumbDragging = this.sliderThumbState === "drag";
      const hueThumbDragging = this.hueThumbState === "drag";
      if (!el.isConnected || (!sliderThumbDragging && !hueThumbDragging)) {
        return;
      }
      let samplingX;
      let samplingY;
      const colorFieldAndSliderRect = this.activeColorFieldAndSliderRect;
      const { clientX, clientY } = event;
      if (this.colorFieldAndSliderHovered) {
        samplingX = clientX - colorFieldAndSliderRect.x;
        samplingY = clientY - colorFieldAndSliderRect.y;
      }
      else {
        const colorFieldWidth = dimensions.colorField.width;
        const colorFieldHeight = dimensions.colorField.height;
        const hueSliderHeight = dimensions.slider.height;
        if (clientX < colorFieldAndSliderRect.x + colorFieldWidth &&
          clientX > colorFieldAndSliderRect.x) {
          samplingX = clientX - colorFieldAndSliderRect.x;
        }
        else if (clientX < colorFieldAndSliderRect.x) {
          samplingX = 0;
        }
        else {
          samplingX = colorFieldWidth - 1;
        }
        if (clientY < colorFieldAndSliderRect.y + colorFieldHeight + hueSliderHeight &&
          clientY > colorFieldAndSliderRect.y) {
          samplingY = clientY - colorFieldAndSliderRect.y;
        }
        else if (clientY < colorFieldAndSliderRect.y) {
          samplingY = 0;
        }
        else {
          samplingY = colorFieldHeight + hueSliderHeight;
        }
      }
      if (hueThumbDragging) {
        this.captureColorFieldColor(samplingX, samplingY, false);
      }
      else {
        this.captureHueSliderColor(samplingX);
      }
    };
    this.handleColorFieldAndSliderPointerEnterOrMove = ({ offsetX, offsetY }) => {
      const { dimensions: { colorField, slider, thumb } } = this;
      this.colorFieldAndSliderInteractive = offsetY <= colorField.height + slider.height;
      this.colorFieldAndSliderHovered = true;
      const region = this.getCanvasRegion(offsetY);
      if (region === "color-field") {
        const prevHueThumbState = this.hueThumbState;
        const color = this.baseColorFieldColor.hsv();
        const centerX = Math.round(color.saturationv() / (HSV_LIMITS.s / colorField.width));
        const centerY = Math.round(colorField.height - color.value() / (HSV_LIMITS.v / colorField.height));
        const hoveringThumb = this.containsPoint(offsetX, offsetY, centerX, centerY, thumb.radius);
        let transitionedBetweenHoverAndIdle = false;
        if (prevHueThumbState === "idle" && hoveringThumb) {
          this.hueThumbState = "hover";
          transitionedBetweenHoverAndIdle = true;
        }
        else if (prevHueThumbState === "hover" && !hoveringThumb) {
          this.hueThumbState = "idle";
          transitionedBetweenHoverAndIdle = true;
        }
        if (this.hueThumbState !== "drag") {
          if (transitionedBetweenHoverAndIdle) {
            // refresh since we won't update color and thus no redraw
            this.drawColorFieldAndSlider();
          }
        }
      }
      else if (region === "slider") {
        const sliderThumbColor = this.baseColorFieldColor.hsv().saturationv(100).value(100);
        const prevSliderThumbState = this.sliderThumbState;
        const sliderThumbCenterX = Math.round(sliderThumbColor.hue() / (360 / slider.width));
        const sliderThumbCenterY = Math.round((slider.height + this.getSliderCapSpacing()) / 2) + colorField.height;
        const hoveringSliderThumb = this.containsPoint(offsetX, offsetY, sliderThumbCenterX, sliderThumbCenterY, thumb.radius);
        let sliderThumbTransitionedBetweenHoverAndIdle = false;
        if (prevSliderThumbState === "idle" && hoveringSliderThumb) {
          this.sliderThumbState = "hover";
          sliderThumbTransitionedBetweenHoverAndIdle = true;
        }
        else if (prevSliderThumbState === "hover" && !hoveringSliderThumb) {
          this.sliderThumbState = "idle";
          sliderThumbTransitionedBetweenHoverAndIdle = true;
        }
        if (this.sliderThumbState !== "drag") {
          if (sliderThumbTransitionedBetweenHoverAndIdle) {
            // refresh since we won't update color and thus no redraw
            this.drawColorFieldAndSlider();
          }
        }
      }
    };
    this.storeColorFieldScope = (node) => {
      this.colorFieldScopeNode = node;
    };
    this.storeHueScope = (node) => {
      this.hueScopeNode = node;
    };
    this.renderChannelsTabTitle = (channelMode) => {
      const { channelMode: activeChannelMode, messages } = this;
      const selected = channelMode === activeChannelMode;
      const label = channelMode === "rgb" ? messages.rgb : messages.hsv;
      return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-tab-title", { class: CSS.colorMode, "data-color-mode": channelMode, key: channelMode, onCalciteTabsActivate: this.handleTabActivate, selected: selected }, label));
    };
    this.renderChannelsTab = (channelMode) => {
      const { channelMode: activeChannelMode, channels, messages } = this;
      const selected = channelMode === activeChannelMode;
      const isRgb = channelMode === "rgb";
      const channelLabels = isRgb
        ? [messages.r, messages.g, messages.b]
        : [messages.h, messages.s, messages.v];
      const channelAriaLabels = isRgb
        ? [messages.red, messages.green, messages.blue]
        : [messages.hue, messages.saturation, messages.value];
      const direction = (0,_dom_1997bfaf_js__WEBPACK_IMPORTED_MODULE_6__.b)(this.el);
      return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-tab", { class: CSS.control, key: channelMode, selected: selected }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.channels, dir: "ltr" }, channels.map((channel, index) => 
      /* the channel container is ltr, so we apply the host's direction */
      this.renderChannel(channel, index, channelLabels[index], channelAriaLabels[index], direction)))));
    };
    this.renderChannel = (value, index, label, ariaLabel, direction) => ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-input", { class: CSS.channel, "data-channel-index": index, dir: direction, label: ariaLabel, lang: this.effectiveLocale, numberButtonType: "none", numberingSystem: this.numberingSystem, onCalciteInputChange: this.handleChannelChange, onCalciteInputInput: this.handleChannelInput, onKeyDown: this.handleKeyDown, prefixText: label, scale: this.scale === "l" ? "m" : "s", type: "number", value: value?.toString() }));
    this.deleteColor = () => {
      const colorToDelete = this.color.hex();
      const inStorage = this.savedColors.indexOf(colorToDelete) > -1;
      if (!inStorage) {
        return;
      }
      const savedColors = this.savedColors.filter((color) => color !== colorToDelete);
      this.savedColors = savedColors;
      const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
      if (this.storageId) {
        localStorage.setItem(storageKey, JSON.stringify(savedColors));
      }
    };
    this.saveColor = () => {
      const colorToSave = this.color.hex();
      const alreadySaved = this.savedColors.indexOf(colorToSave) > -1;
      if (alreadySaved) {
        return;
      }
      const savedColors = [...this.savedColors, colorToSave];
      this.savedColors = savedColors;
      const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
      if (this.storageId) {
        localStorage.setItem(storageKey, JSON.stringify(savedColors));
      }
    };
    this.drawColorFieldAndSlider = throttle(() => {
      if (!this.fieldAndSliderRenderingContext) {
        return;
      }
      this.drawColorField();
      this.drawHueSlider();
    }, throttleFor60FpsInMs);
    this.captureColorFieldColor = (x, y, skipEqual = true) => {
      const { dimensions: { colorField: { height, width } } } = this;
      const saturation = Math.round((HSV_LIMITS.s / width) * x);
      const value = Math.round((HSV_LIMITS.v / height) * (height - y));
      this.internalColorSet(this.baseColorFieldColor.hsv().saturationv(saturation).value(value), skipEqual);
    };
    this.initColorFieldAndSlider = (canvas) => {
      this.fieldAndSliderRenderingContext = canvas.getContext("2d");
      this.updateCanvasSize(canvas);
    };
    this.allowEmpty = false;
    this.color = DEFAULT_COLOR;
    this.disabled = false;
    this.format = defaultFormat;
    this.hideHex = false;
    this.hideChannels = false;
    this.hideSaved = false;
    this.scale = "m";
    this.storageId = undefined;
    this.messageOverrides = undefined;
    this.numberingSystem = undefined;
    this.value = defaultValue;
    this.defaultMessages = undefined;
    this.colorFieldAndSliderInteractive = false;
    this.channelMode = "rgb";
    this.channels = this.toChannels(DEFAULT_COLOR);
    this.dimensions = DIMENSIONS.m;
    this.effectiveLocale = "";
    this.messages = undefined;
    this.savedColors = [];
    this.colorFieldScopeTop = undefined;
    this.colorFieldScopeLeft = undefined;
    this.scopeOrientation = undefined;
    this.hueScopeLeft = undefined;
    this.hueScopeTop = undefined;
  }
  handleColorChange(color, oldColor) {
    this.drawColorFieldAndSlider();
    this.updateChannelsFromColor(color);
    this.previousColor = oldColor;
  }
  handleFormatChange(format) {
    this.setMode(format);
    this.internalColorSet(this.color, false, "internal");
  }
  handleScaleChange(scale = "m") {
    this.updateDimensions(scale);
    this.updateCanvasSize(this.fieldAndSliderRenderingContext?.canvas);
  }
  onMessagesChange() {
    /* wired up by t9n util */
  }
  handleValueChange(value, oldValue) {
    const { allowEmpty, format } = this;
    const checkMode = !allowEmpty || value;
    let modeChanged = false;
    if (checkMode) {
      const nextMode = (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.p)(value);
      if (!nextMode || (format !== "auto" && nextMode !== format)) {
        this.showIncompatibleColorWarning(value, format);
        this.value = oldValue;
        return;
      }
      modeChanged = this.mode !== nextMode;
      this.setMode(nextMode);
    }
    const dragging = this.sliderThumbState === "drag" || this.hueThumbState === "drag";
    if (this.internalColorUpdateContext === "initial") {
      return;
    }
    if (this.internalColorUpdateContext === "user-interaction") {
      this.calciteColorPickerInput.emit();
      if (!dragging) {
        this.calciteColorPickerChange.emit();
      }
      return;
    }
    const color$1 = allowEmpty && !value ? null : (0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(value);
    const colorChanged = !(0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.c)(color$1, this.color);
    if (modeChanged || colorChanged) {
      this.internalColorSet(color$1, true, "internal");
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Internal State/Props
  //
  //--------------------------------------------------------------------------
  get baseColorFieldColor() {
    return this.color || this.previousColor || DEFAULT_COLOR;
  }
  effectiveLocaleChange() {
    (0,_t9n_9603ff05_js__WEBPACK_IMPORTED_MODULE_7__.u)(this, this.effectiveLocale);
  }
  // using @Listen as a workaround for VDOM listener not firing
  handleChannelKeyUpOrDown(event) {
    this.shiftKeyChannelAdjustment = 0;
    const { key } = event;
    if ((key !== "ArrowUp" && key !== "ArrowDown") ||
      !event.composedPath().some((node) => node.classList?.contains(CSS.channel))) {
      return;
    }
    const { shiftKey } = event;
    event.preventDefault();
    if (!this.color) {
      this.internalColorSet(this.previousColor);
      event.stopPropagation();
      return;
    }
    // this gets applied to the input's up/down arrow increment/decrement
    const complementaryBump = 9;
    this.shiftKeyChannelAdjustment =
      key === "ArrowUp" && shiftKey
        ? complementaryBump
        : key === "ArrowDown" && shiftKey
          ? -complementaryBump
          : 0;
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /** Sets focus on the component's first focusable element. */
  async setFocus() {
    await (0,_loadable_cc14d728_js__WEBPACK_IMPORTED_MODULE_8__.c)(this);
    this.el.focus();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    (0,_loadable_cc14d728_js__WEBPACK_IMPORTED_MODULE_8__.a)(this);
    const { allowEmpty, color: color$1, format, value } = this;
    const willSetNoColor = allowEmpty && !value;
    const parsedMode = (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.p)(value);
    const valueIsCompatible = willSetNoColor || (format === "auto" && parsedMode) || format === parsedMode;
    const initialColor = willSetNoColor ? null : valueIsCompatible ? (0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(value) : color$1;
    if (!valueIsCompatible) {
      this.showIncompatibleColorWarning(value, format);
    }
    this.setMode(format);
    this.internalColorSet(initialColor, false, "initial");
    this.updateDimensions(this.scale);
    const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
    if (this.storageId && localStorage.getItem(storageKey)) {
      this.savedColors = JSON.parse(localStorage.getItem(storageKey));
    }
    await (0,_t9n_9603ff05_js__WEBPACK_IMPORTED_MODULE_7__.s)(this);
  }
  connectedCallback() {
    (0,_locale_706df4c7_js__WEBPACK_IMPORTED_MODULE_9__.c)(this);
    (0,_t9n_9603ff05_js__WEBPACK_IMPORTED_MODULE_7__.c)(this);
  }
  componentDidLoad() {
    (0,_loadable_cc14d728_js__WEBPACK_IMPORTED_MODULE_8__.s)(this);
  }
  disconnectedCallback() {
    document.removeEventListener("pointermove", this.globalPointerMoveHandler);
    document.removeEventListener("pointerup", this.globalPointerUpHandler);
    (0,_locale_706df4c7_js__WEBPACK_IMPORTED_MODULE_9__.d)(this);
    (0,_t9n_9603ff05_js__WEBPACK_IMPORTED_MODULE_7__.d)(this);
  }
  componentDidRender() {
    (0,_interactive_29995522_js__WEBPACK_IMPORTED_MODULE_10__.u)(this);
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { allowEmpty, color, messages, hideHex, hideChannels, hideSaved, savedColors, scale } = this;
    const selectedColorInHex = color ? color.hex() : null;
    const hexInputScale = scale === "l" ? "m" : "s";
    const { colorFieldAndSliderInteractive, colorFieldScopeTop, colorFieldScopeLeft, hueScopeLeft, hueScopeTop, scopeOrientation, dimensions: { colorField: { height: colorFieldHeight, width: colorFieldWidth }, slider: { height: sliderHeight } } } = this;
    const hueTop = hueScopeTop ?? sliderHeight / 2 + colorFieldHeight;
    const hueLeft = hueScopeLeft ?? (colorFieldWidth * DEFAULT_COLOR.hue()) / HSV_LIMITS.h;
    const noColor = color === null;
    const vertical = scopeOrientation === "vertical";
    return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.container }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.colorFieldAndSliderWrap }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("canvas", { class: {
        [CSS.colorFieldAndSlider]: true,
        [CSS.colorFieldAndSliderInteractive]: colorFieldAndSliderInteractive
      }, onPointerDown: this.handleColorFieldAndSliderPointerDown, onPointerEnter: this.handleColorFieldAndSliderPointerEnterOrMove, onPointerLeave: this.handleColorFieldAndSliderPointerLeave, onPointerMove: this.handleColorFieldAndSliderPointerEnterOrMove, ref: this.initColorFieldAndSlider }), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { "aria-label": vertical ? messages.value : messages.saturation, "aria-valuemax": vertical ? HSV_LIMITS.v : HSV_LIMITS.s, "aria-valuemin": "0", "aria-valuenow": (vertical ? color?.saturationv() : color?.value()) || "0", class: { [CSS.scope]: true, [CSS.colorFieldScope]: true }, onKeyDown: this.handleColorFieldScopeKeyDown, ref: this.storeColorFieldScope, role: "slider", style: { top: `${colorFieldScopeTop || 0}px`, left: `${colorFieldScopeLeft || 0}px` }, tabindex: "0" }), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { "aria-label": messages.hue, "aria-valuemax": HSV_LIMITS.h, "aria-valuemin": "0", "aria-valuenow": color?.round().hue() || DEFAULT_COLOR.round().hue(), class: { [CSS.scope]: true, [CSS.hueScope]: true }, onKeyDown: this.handleHueScopeKeyDown, ref: this.storeHueScope, role: "slider", style: { top: `${hueTop}px`, left: `${hueLeft}px` }, tabindex: "0" })), hideHex && hideChannels ? null : ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: {
        [CSS.controlSection]: true,
        [CSS.section]: true
      } }, hideHex ? null : ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.hexOptions }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("span", { class: {
        [CSS.header]: true,
        [CSS.headerHex]: true
      } }, messages.hex), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-color-picker-hex-input", { allowEmpty: allowEmpty, class: CSS.control, hexLabel: messages.hex, numberingSystem: this.numberingSystem, onCalciteColorPickerHexInputChange: this.handleHexInputChange, scale: hexInputScale, value: selectedColorInHex }))), hideChannels ? null : ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-tabs", { class: {
        [CSS.colorModeContainer]: true,
        [CSS.splitSection]: true
      }, scale: hexInputScale }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-tab-nav", { slot: "title-group" }, this.renderChannelsTabTitle("rgb"), this.renderChannelsTabTitle("hsv")), this.renderChannelsTab("rgb"), this.renderChannelsTab("hsv"))))), hideSaved ? null : ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: { [CSS.savedColorsSection]: true, [CSS.section]: true } }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.header }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("label", null, messages.saved), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.savedColorsButtons }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-button", { appearance: "transparent", class: CSS.deleteColor, disabled: noColor, iconStart: "minus", kind: "neutral", label: messages.deleteColor, onClick: this.deleteColor, scale: hexInputScale, type: "button" }), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-button", { appearance: "transparent", class: CSS.saveColor, disabled: noColor, iconStart: "plus", kind: "neutral", label: messages.saveColor, onClick: this.saveColor, scale: hexInputScale, type: "button" }))), savedColors.length > 0 ? ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.savedColors }, [
      ...savedColors.map((color) => ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-color-picker-swatch", { active: selectedColorInHex === color, class: CSS.savedColor, color: color, key: color, onClick: this.handleSavedColorSelect, onKeyDown: this.handleSavedColorKeyDown, scale: scale, tabIndex: 0 })))
    ])) : null))));
  }
  // --------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  handleKeyDown(event) {
    if (event.key === "Enter") {
      event.preventDefault();
    }
  }
  showIncompatibleColorWarning(value, format) {
    console.warn(`ignoring color value (${value}) as it is not compatible with the current format (${format})`);
  }
  setMode(format) {
    this.mode = format === "auto" ? this.mode : format;
  }
  captureHueSliderColor(x) {
    const { dimensions: { slider: { width } } } = this;
    const hue = (360 / width) * x;
    this.internalColorSet(this.baseColorFieldColor.hue(hue), false);
  }
  getCanvasRegion(y) {
    const { dimensions: { colorField: { height: colorFieldHeight }, slider: { height: sliderHeight } } } = this;
    if (y <= colorFieldHeight) {
      return "color-field";
    }
    if (y <= colorFieldHeight + sliderHeight) {
      return "slider";
    }
    return "none";
  }
  internalColorSet(color, skipEqual = true, context = "user-interaction") {
    if (skipEqual && (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.c)(color, this.color)) {
      return;
    }
    this.internalColorUpdateContext = context;
    this.color = color;
    this.value = this.toValue(color);
    this.internalColorUpdateContext = null;
  }
  toValue(color, format = this.mode) {
    if (!color) {
      return null;
    }
    const hexMode = "hex";
    if (format.includes(hexMode)) {
      return (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.n)(color.round()[hexMode]());
    }
    if (format.includes("-css")) {
      return color[format.replace("-css", "").replace("a", "")]().round().string();
    }
    const colorObject = color[format]().round().object();
    if (format.endsWith("a")) {
      // normalize alpha prop
      colorObject.a = colorObject.alpha;
      delete colorObject.alpha;
    }
    return colorObject;
  }
  getSliderCapSpacing() {
    const { dimensions: { slider: { height }, thumb: { radius } } } = this;
    return radius * 2 - height;
  }
  updateDimensions(scale = "m") {
    this.dimensions = DIMENSIONS[scale];
  }
  drawColorField() {
    const context = this.fieldAndSliderRenderingContext;
    const { dimensions: { colorField: { height, width } } } = this;
    context.fillStyle = this.baseColorFieldColor.hsv().saturationv(100).value(100).string();
    context.fillRect(0, 0, width, height);
    const whiteGradient = context.createLinearGradient(0, 0, width, 0);
    whiteGradient.addColorStop(0, "rgba(255,255,255,1)");
    whiteGradient.addColorStop(1, "rgba(255,255,255,0)");
    context.fillStyle = whiteGradient;
    context.fillRect(0, 0, width, height);
    const blackGradient = context.createLinearGradient(0, 0, 0, height);
    blackGradient.addColorStop(0, "rgba(0,0,0,0)");
    blackGradient.addColorStop(1, "rgba(0,0,0,1)");
    context.fillStyle = blackGradient;
    context.fillRect(0, 0, width, height);
    this.drawActiveColorFieldColor();
  }
  setCanvasContextSize(canvas, { height, width }) {
    const devicePixelRatio = window.devicePixelRatio || 1;
    canvas.width = width * devicePixelRatio;
    canvas.height = height * devicePixelRatio;
    canvas.style.height = `${height}px`;
    canvas.style.width = `${width}px`;
    const context = canvas.getContext("2d");
    context.scale(devicePixelRatio, devicePixelRatio);
  }
  updateCanvasSize(canvas) {
    if (!canvas) {
      return;
    }
    this.setCanvasContextSize(canvas, {
      width: this.dimensions.colorField.width,
      height: this.dimensions.colorField.height +
        this.dimensions.slider.height +
        this.getSliderCapSpacing() * 2
    });
    this.drawColorFieldAndSlider();
  }
  containsPoint(testPointX, testPointY, boundsX, boundsY, boundsRadius) {
    return (Math.pow(testPointX - boundsX, 2) + Math.pow(testPointY - boundsY, 2) <=
      Math.pow(boundsRadius, 2));
  }
  drawActiveColorFieldColor() {
    const { color } = this;
    if (!color) {
      return;
    }
    const hsvColor = color.hsv();
    const { dimensions: { colorField: { height, width }, thumb: { radius } } } = this;
    const x = hsvColor.saturationv() / (HSV_LIMITS.s / width);
    const y = height - hsvColor.value() / (HSV_LIMITS.v / height);
    requestAnimationFrame(() => {
      this.colorFieldScopeLeft = x;
      this.colorFieldScopeTop = y;
    });
    this.drawThumb(this.fieldAndSliderRenderingContext, radius, x, y, hsvColor, this.hueThumbState);
  }
  drawThumb(context, radius, x, y, color, state) {
    const startAngle = 0;
    const endAngle = 2 * Math.PI;
    context.beginPath();
    context.arc(x, y, radius, startAngle, endAngle);
    context.shadowBlur = state === "hover" ? 32 : 16;
    context.shadowColor = `rgba(0, 0, 0, ${state === "drag" ? 0.32 : 0.16})`;
    context.fillStyle = "#fff";
    context.fill();
    context.beginPath();
    context.arc(x, y, radius - 3, startAngle, endAngle);
    context.shadowBlur = 0;
    context.shadowColor = "transparent";
    context.fillStyle = color.rgb().string();
    context.fill();
  }
  drawActiveHueSliderColor() {
    const { color } = this;
    if (!color) {
      return;
    }
    const hsvColor = color.hsv().saturationv(100).value(100);
    const { dimensions: { colorField: { height: colorFieldHeight }, slider: { height, width }, thumb: { radius } } } = this;
    const x = hsvColor.hue() / (360 / width);
    const y = height / 2 + colorFieldHeight;
    requestAnimationFrame(() => {
      this.hueScopeLeft = x;
      this.hueScopeTop = y;
    });
    this.drawThumb(this.fieldAndSliderRenderingContext, radius, x, y, hsvColor, this.sliderThumbState);
  }
  drawHueSlider() {
    const context = this.fieldAndSliderRenderingContext;
    const { dimensions: { colorField: { height: colorFieldHeight }, slider: { height, width } } } = this;
    const gradient = context.createLinearGradient(0, 0, width, 0);
    const hueSliderColorStopKeywords = ["red", "yellow", "lime", "cyan", "blue", "magenta", "red"];
    const offset = 1 / (hueSliderColorStopKeywords.length - 1);
    let currentOffset = 0;
    hueSliderColorStopKeywords.forEach((keyword) => {
      gradient.addColorStop(currentOffset, (0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(keyword).string());
      currentOffset += offset;
    });
    context.fillStyle = gradient;
    context.clearRect(0, colorFieldHeight, width, height + this.getSliderCapSpacing() * 2);
    context.fillRect(0, colorFieldHeight, width, height);
    this.drawActiveHueSliderColor();
  }
  updateColorFromChannels(channels) {
    this.internalColorSet((0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(channels, this.channelMode));
  }
  updateChannelsFromColor(color) {
    this.channels = color ? this.toChannels(color) : [null, null, null];
  }
  toChannels(color) {
    const { channelMode } = this;
    return color[channelMode]()
      .array()
      .map((value) => Math.floor(value));
  }
  static get delegatesFocus() { return true; }
  static get assetsDirs() { return ["assets"]; }
  get el() { return (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.g)(this); }
  static get watchers() { return {
    "color": ["handleColorChange"],
    "format": ["handleFormatChange"],
    "scale": ["handleScaleChange"],
    "messageOverrides": ["onMessagesChange"],
    "value": ["handleValueChange"],
    "effectiveLocale": ["effectiveLocaleChange"]
  }; }
};
ColorPicker.style = colorPickerCss;



//# sourceMappingURL=calcite-color-picker.entry.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/interactive-29995522.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/interactive-29995522.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ updateHostInteraction)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
function noopClick() {
  /** noop */
}
/**
 * This helper updates the host element to prevent keyboard interaction on its subtree and sets the appropriate aria attribute for accessibility.
 *
 * This should be used in the `componentDidRender` lifecycle hook.
 *
 * **Notes**
 *
 * this util is not needed for simple components whose root element or elements are an interactive component (custom element or native control). For those cases, set the `disabled` props on the root components instead.
 * technically, users can override `tabindex` and restore keyboard navigation, but this will be considered user error
 *
 * @param component
 * @param hostIsTabbable
 */
function updateHostInteraction(component, hostIsTabbable = false) {
  if (component.disabled) {
    component.el.setAttribute("tabindex", "-1");
    component.el.setAttribute("aria-disabled", "true");
    if (component.el.contains(document.activeElement)) {
      document.activeElement.blur();
    }
    component.el.click = noopClick;
    return;
  }
  component.el.click = HTMLElement.prototype.click;
  if (typeof hostIsTabbable === "function") {
    component.el.setAttribute("tabindex", hostIsTabbable.call(component) ? "0" : "-1");
  }
  else if (hostIsTabbable === true) {
    component.el.setAttribute("tabindex", "0");
  }
  else if (hostIsTabbable === false) {
    component.el.removeAttribute("tabindex");
  }
  else ;
  component.el.removeAttribute("aria-disabled");
}



//# sourceMappingURL=interactive-29995522.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/loadable-cc14d728.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/loadable-cc14d728.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ setUpLoadableComponent),
/* harmony export */   c: () => (/* binding */ componentLoaded),
/* harmony export */   s: () => (/* binding */ setComponentLoaded)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const resolveMap = new WeakMap();
const promiseMap = new WeakMap();
/**
 * This helper util sets up the component for the ability to know when the component has been loaded.
 *
 * This should be used in the `componentWillLoad` lifecycle hook.
 *
 * ```
 * componentWillLoad(): void {
 *   setUpLoadableComponent(this);
 * }
 * ```
 *
 * @param component
 */
function setUpLoadableComponent(component) {
  promiseMap.set(component, new Promise((resolve) => resolveMap.set(component, resolve)));
}
/**
 * This helper util lets the loadable component know that it is now loaded.
 *
 * This should be used in the `componentDidLoad` lifecycle hook.
 *
 * ```
 * componentDidLoad(): void {
 *   setComponentLoaded(this);
 * }
 * ```
 *
 * @param component
 */
function setComponentLoaded(component) {
  resolveMap.get(component)();
}
/**
 * This helper util can be used to ensure a component has been loaded (The "componentDidLoad" stencil lifecycle method has been called).
 *
 * Requires "setUpLoadableComponent" and "setComponentLoaded" to be called first.
 *
 * A component developer can await this method before proceeding with any logic that requires a component to be loaded first.
 *
 * ```
 * async setFocus(): Promise<void> {
 *   await componentLoaded(this);
 * }
 * ```
 *
 * @param component
 * @returns Promise<void>
 */
function componentLoaded(component) {
  return promiseMap.get(component);
}



//# sourceMappingURL=loadable-cc14d728.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/math-7efd987a.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/math-7efd987a.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ clamp),
/* harmony export */   d: () => (/* binding */ decimalPlaces)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const clamp = (value, min, max) => Math.max(min, Math.min(value, max));
const decimalPlaces = (value) => {
  const match = ("" + value).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  if (!match) {
    return 0;
  }
  return Math.max(0, 
  // Number of digits right of decimal point.
  (match[1] ? match[1].length : 0) -
    // Adjust for scientific notation.
    (match[2] ? +match[2] : 0));
};



//# sourceMappingURL=math-7efd987a.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/t9n-9603ff05.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/t9n-9603ff05.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ connectMessages),
/* harmony export */   d: () => (/* binding */ disconnectMessages),
/* harmony export */   s: () => (/* binding */ setUpMessages),
/* harmony export */   u: () => (/* binding */ updateMessages)
/* harmony export */ });
/* harmony import */ var _index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-4e647411.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/index-4e647411.js");
/* harmony import */ var _locale_706df4c7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-706df4c7.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/locale-706df4c7.js");



/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const componentLangToMessageBundleCache = {};
async function getMessageBundle(lang, component) {
  const key = `${component}_${lang}`;
  if (componentLangToMessageBundleCache[key]) {
    return componentLangToMessageBundleCache[key];
  }
  componentLangToMessageBundleCache[key] = fetch((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/${component}/t9n/messages_${lang}.json`))
    .then((resp) => {
    if (!resp.ok) {
      throwMessageFetchError();
    }
    return resp.json();
  })
    .catch(() => throwMessageFetchError());
  return componentLangToMessageBundleCache[key];
}
function throwMessageFetchError() {
  throw new Error("could not fetch component message bundle");
}
function mergeMessages(component) {
  component.messages = {
    ...component.defaultMessages,
    ...component.messageOverrides
  };
}
/**
 * This utility sets up the messages used by the component. It should be awaited in the `componentWillLoad` lifecycle hook.
 *
 * @param component
 */
async function setUpMessages(component) {
  component.defaultMessages = await fetchMessages(component, component.effectiveLocale);
  mergeMessages(component);
}
async function fetchMessages(component, lang) {
  const { el } = component;
  const tag = el.tagName.toLowerCase();
  const componentName = tag.replace("calcite-", "");
  return getMessageBundle((0,_locale_706df4c7_js__WEBPACK_IMPORTED_MODULE_1__.g)(lang, "t9n"), componentName);
}
/**
 * This utility must be set up for the component to update its default message bundle if the locale changes.
 *
 * It can be set up in **either** of the following ways:
 *
 * 1. called from `LocalizedComponent`'s `onLocaleChange` method or
 * 2. called from a watcher configured to watch `LocalizedComponent`'s `effectiveLocale` prop
 *
 * @param component
 * @param lang
 */
async function updateMessages(component, lang) {
  component.defaultMessages = await fetchMessages(component, lang);
  mergeMessages(component);
}
/**
 * This utility sets up internals for messages support.
 *
 * It needs to be called in `connectedCallback`
 *
 * **Note**: this must be called after `LocalizedComponent`'s `connectLocalized` method.
 *
 * @param component
 */
function connectMessages(component) {
  component.onMessagesChange = defaultOnMessagesChange;
}
/**
 * This utility tears down internals for messages support.
 *
 * It needs to be called in `disconnectedCallback`
 *
 * @param component
 */
function disconnectMessages(component) {
  component.onMessagesChange = undefined;
}
function defaultOnMessagesChange() {
  mergeMessages(this);
}



//# sourceMappingURL=t9n-9603ff05.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/utils-a71d8ee9.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/utils-a71d8ee9.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSSColorMode),
/* harmony export */   a: () => (/* binding */ isLonghandHex),
/* harmony export */   b: () => (/* binding */ hexChar),
/* harmony export */   c: () => (/* binding */ colorEqual),
/* harmony export */   h: () => (/* binding */ hexToRGB),
/* harmony export */   i: () => (/* binding */ isValidHex),
/* harmony export */   n: () => (/* binding */ normalizeHex),
/* harmony export */   p: () => (/* binding */ parseMode),
/* harmony export */   r: () => (/* binding */ rgbToHex)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
function rgbToHex(color) {
  const { r, g, b } = color;
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b
    .toString(16)
    .padStart(2, "0")}`.toLowerCase();
}
const hexChar = /^[0-9A-F]$/i;
const shortHandHex = /^#[0-9A-F]{3}$/i;
const longhandHex = /^#[0-9A-F]{6}$/i;
function isValidHex(hex) {
  return isShorthandHex(hex) || isLonghandHex(hex);
}
function isShorthandHex(hex) {
  return hex && hex.length === 4 && shortHandHex.test(hex);
}
function isLonghandHex(hex) {
  return hex && hex.length === 7 && longhandHex.test(hex);
}
function normalizeHex(hex) {
  hex = hex.toLowerCase();
  if (!hex.startsWith("#")) {
    hex = `#${hex}`;
  }
  if (isShorthandHex(hex)) {
    return rgbToHex(hexToRGB(hex));
  }
  return hex;
}
function hexToRGB(hex) {
  if (!isValidHex(hex)) {
    return null;
  }
  hex = hex.replace("#", "");
  if (hex.length === 3) {
    const [first, second, third] = hex.split("");
    const r = parseInt(`${first}${first}`, 16);
    const g = parseInt(`${second}${second}`, 16);
    const b = parseInt(`${third}${third}`, 16);
    return { r, g, b };
  }
  const r = parseInt(hex.slice(0, 2), 16);
  const g = parseInt(hex.slice(2, 4), 16);
  const b = parseInt(hex.slice(4, 6), 16);
  return { r, g, b };
}
// these utils allow users to pass enum values as strings without having to access the enum
// based on the approach suggested by https://github.com/microsoft/TypeScript/issues/17690#issuecomment-321365759,
const enumify = (x) => x;
const CSSColorMode = enumify({
  HEX: "hex",
  HEXA: "hexa",
  RGB_CSS: "rgb-css",
  RGBA_CSS: "rgba-css",
  HSL_CSS: "hsl-css",
  HSLA_CSS: "hsla-css"
});
const ObjectColorMode = enumify({
  RGB: "rgb",
  RGBA: "rgba",
  HSL: "hsl",
  HSLA: "hsla",
  HSV: "hsv",
  HSVA: "hsva"
});
function parseMode(colorValue) {
  if (typeof colorValue === "string") {
    if (colorValue.startsWith("#")) {
      const { length } = colorValue;
      if (length === 4 || length === 7) {
        return CSSColorMode.HEX;
      }
      if (length === 5 || length === 9) {
        return CSSColorMode.HEXA;
      }
    }
    if (colorValue.startsWith("rgba(")) {
      return CSSColorMode.RGBA_CSS;
    }
    if (colorValue.startsWith("rgb(")) {
      return CSSColorMode.RGB_CSS;
    }
    if (colorValue.startsWith("hsl(")) {
      return CSSColorMode.HSL_CSS;
    }
    if (colorValue.startsWith("hsla(")) {
      return CSSColorMode.HSLA_CSS;
    }
  }
  if (typeof colorValue === "object") {
    if (hasChannels(colorValue, "r", "g", "b")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.RGBA : ObjectColorMode.RGB;
    }
    if (hasChannels(colorValue, "h", "s", "l")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.HSLA : ObjectColorMode.HSL;
    }
    if (hasChannels(colorValue, "h", "s", "v")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.HSVA : ObjectColorMode.HSV;
    }
  }
  return null;
}
function hasChannels(colorObject, ...channels) {
  return channels.every((channel) => channel && colorObject && `${channel}` in colorObject);
}
function colorEqual(value1, value2) {
  return value1?.rgbNumber() === value2?.rgbNumber();
}



//# sourceMappingURL=utils-a71d8ee9.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYmEtaW5mb2dyYXBoaWNfbm9kZV9tb2R1bGVzX2FyY2dpc19idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHNfZGlzLTVmZDQyMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0c7QUFDakQ7QUFDbUM7QUFDd0I7QUFDckM7QUFDZDtBQUMyRDtBQUM3QjtBQUN2QztBQUMyRTtBQUNyRDtBQUNyQztBQUNMO0FBQ0s7QUFDQTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxXQUFXO0FBQzlCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsbUJBQW1CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3REFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0RBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LEVBQUUsZ0NBQWdDLEVBQUU7QUFDakY7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGlDQUFpQyxFQUFFO0FBQ25DLGdDQUFnQyxFQUFFO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLEVBQUUsTUFBTTtBQUN4QywwQkFBMEIsT0FBTyxFQUFFLE9BQU87QUFDMUMsMEJBQTBCLE1BQU0sRUFBRSxNQUFNO0FBQ3hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxRQUFRO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVrSzs7QUFFbEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9jYWxjaXRlLWNvbG9yLXBpY2tlci5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9pbnRlcmFjdGl2ZS0yOTk5NTUyMi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9sb2FkYWJsZS1jYzE0ZDcyOC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9tYXRoLTdlZmQ5ODdhLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYmEtaW5mb2dyYXBoaWMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYnVzaW5lc3MtYW5hbHlzdC1jb21wb25lbnRzL2Rpc3Qvc3RlbmNpbC1jb21wb25lbnRzL2Rpc3QvZXNtL3Q5bi05NjAzZmYwNS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS91dGlscy1hNzFkOGVlOS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIGcgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtNGU2NDc0MTEuanMnO1xuaW1wb3J0IHsgYyBhcyBjb2xvciB9IGZyb20gJy4vaW5kZXgtNTZkZDFjNDIuanMnO1xuaW1wb3J0IHsgaSBhcyBpc1ByaW1hcnlQb2ludGVyQnV0dG9uLCBiIGFzIGdldEVsZW1lbnREaXIgfSBmcm9tICcuL2RvbS0xOTk3YmZhZi5qcyc7XG5pbXBvcnQgeyBuIGFzIG5vcm1hbGl6ZUhleCwgQyBhcyBDU1NDb2xvck1vZGUsIHAgYXMgcGFyc2VNb2RlLCBjIGFzIGNvbG9yRXF1YWwgfSBmcm9tICcuL3V0aWxzLWE3MWQ4ZWU5LmpzJztcbmltcG9ydCB7IHUgYXMgdXBkYXRlSG9zdEludGVyYWN0aW9uIH0gZnJvbSAnLi9pbnRlcmFjdGl2ZS0yOTk5NTUyMi5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzQWN0aXZhdGlvbktleSB9IGZyb20gJy4va2V5LWI3NTQ5MWM0LmpzJztcbmltcG9ydCB7IGMgYXMgY29tcG9uZW50TG9hZGVkLCBhIGFzIHNldFVwTG9hZGFibGVDb21wb25lbnQsIHMgYXMgc2V0Q29tcG9uZW50TG9hZGVkIH0gZnJvbSAnLi9sb2FkYWJsZS1jYzE0ZDcyOC5qcyc7XG5pbXBvcnQgeyBjIGFzIGNvbm5lY3RMb2NhbGl6ZWQsIGQgYXMgZGlzY29ubmVjdExvY2FsaXplZCB9IGZyb20gJy4vbG9jYWxlLTcwNmRmNGM3LmpzJztcbmltcG9ydCB7IGMgYXMgY2xhbXAgfSBmcm9tICcuL21hdGgtN2VmZDk4N2EuanMnO1xuaW1wb3J0IHsgdSBhcyB1cGRhdGVNZXNzYWdlcywgcyBhcyBzZXRVcE1lc3NhZ2VzLCBjIGFzIGNvbm5lY3RNZXNzYWdlcywgZCBhcyBkaXNjb25uZWN0TWVzc2FnZXMgfSBmcm9tICcuL3Q5bi05NjAzZmYwNS5qcyc7XG5pbXBvcnQgeyBkIGFzIGRlYm91bmNlLCBpIGFzIGlzT2JqZWN0IH0gZnJvbSAnLi9kZWJvdW5jZS0wNDdlMDlmNC5qcyc7XG5pbXBvcnQgJy4vaW5kZXguZXNtLTY3ZjBmMjVhLmpzJztcbmltcG9ydCAnLi9ndWlkLTg4YTM3MjlmLmpzJztcbmltcG9ydCAnLi9yZXNvdXJjZXMtNDg0MzZlZWEuanMnO1xuaW1wb3J0ICcuL29ic2VydmVycy01Njc0MGU5OS5qcyc7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjAuNVxuICovXG5jb25zdCBDU1MgPSB7XG4gIGNvbnRhaW5lcjogXCJjb250YWluZXJcIixcbiAgY29udHJvbFNlY3Rpb246IFwiY29udHJvbC1zZWN0aW9uXCIsXG4gIGhleE9wdGlvbnM6IFwiY29sb3ItaGV4LW9wdGlvbnNcIixcbiAgc2VjdGlvbjogXCJzZWN0aW9uXCIsXG4gIGhlYWRlcjogXCJoZWFkZXJcIixcbiAgY29udHJvbDogXCJjb250cm9sXCIsXG4gIHNwbGl0U2VjdGlvbjogXCJzZWN0aW9uLS1zcGxpdFwiLFxuICBjb2xvck1vZGVDb250YWluZXI6IFwiY29sb3ItbW9kZS1jb250YWluZXJcIixcbiAgY29sb3JNb2RlOiBcImNvbG9yLW1vZGVcIixcbiAgY2hhbm5lbHM6IFwiY2hhbm5lbHNcIixcbiAgY2hhbm5lbDogXCJjaGFubmVsXCIsXG4gIHNhdmVkQ29sb3JzOiBcInNhdmVkLWNvbG9yc1wiLFxuICBzYXZlZENvbG9yc1NlY3Rpb246IFwic2F2ZWQtY29sb3JzLXNlY3Rpb25cIixcbiAgc2F2ZUNvbG9yOiBcInNhdmUtY29sb3JcIixcbiAgZGVsZXRlQ29sb3I6IFwiZGVsZXRlLWNvbG9yXCIsXG4gIHNhdmVkQ29sb3JzQnV0dG9uczogXCJzYXZlZC1jb2xvcnMtYnV0dG9uc1wiLFxuICBoZWFkZXJIZXg6IFwiaGVhZGVyLS1oZXhcIixcbiAgY29sb3JGaWVsZEFuZFNsaWRlcjogXCJjb2xvci1maWVsZC1hbmQtc2xpZGVyXCIsXG4gIGNvbG9yRmllbGRBbmRTbGlkZXJJbnRlcmFjdGl2ZTogXCJjb2xvci1maWVsZC1hbmQtc2xpZGVyLS1pbnRlcmFjdGl2ZVwiLFxuICBjb2xvckZpZWxkQW5kU2xpZGVyV3JhcDogXCJjb2xvci1maWVsZC1hbmQtc2xpZGVyLXdyYXBcIixcbiAgc2NvcGU6IFwic2NvcGVcIixcbiAgaHVlU2NvcGU6IFwic2NvcGUtLWh1ZVwiLFxuICBjb2xvckZpZWxkU2NvcGU6IFwic2NvcGUtLWNvbG9yLWZpZWxkXCIsXG4gIHNhdmVkQ29sb3I6IFwic2F2ZWQtY29sb3JcIlxufTtcbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBjb2xvcihcIiMwMDdBQzJcIik7XG5jb25zdCBERUZBVUxUX1NUT1JBR0VfS0VZX1BSRUZJWCA9IFwiY2FsY2l0ZS1jb2xvci1cIjtcbmNvbnN0IFJHQl9MSU1JVFMgPSB7XG4gIHI6IDI1NSxcbiAgZzogMjU1LFxuICBiOiAyNTVcbn07XG5jb25zdCBIU1ZfTElNSVRTID0ge1xuICBoOiAzNjAsXG4gIHM6IDEwMCxcbiAgdjogMTAwXG59O1xuY29uc3QgRElNRU5TSU9OUyA9IHtcbiAgczoge1xuICAgIHNsaWRlcjoge1xuICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgIHdpZHRoOiAxNjBcbiAgICB9LFxuICAgIGNvbG9yRmllbGQ6IHtcbiAgICAgIGhlaWdodDogODAsXG4gICAgICB3aWR0aDogMTYwXG4gICAgfSxcbiAgICB0aHVtYjoge1xuICAgICAgcmFkaXVzOiA4XG4gICAgfVxuICB9LFxuICBtOiB7XG4gICAgc2xpZGVyOiB7XG4gICAgICBoZWlnaHQ6IDE0LFxuICAgICAgd2lkdGg6IDI3MlxuICAgIH0sXG4gICAgY29sb3JGaWVsZDoge1xuICAgICAgaGVpZ2h0OiAxNTAsXG4gICAgICB3aWR0aDogMjcyXG4gICAgfSxcbiAgICB0aHVtYjoge1xuICAgICAgcmFkaXVzOiAxMFxuICAgIH1cbiAgfSxcbiAgbDoge1xuICAgIHNsaWRlcjoge1xuICAgICAgaGVpZ2h0OiAxNixcbiAgICAgIHdpZHRoOiA0NjRcbiAgICB9LFxuICAgIGNvbG9yRmllbGQ6IHtcbiAgICAgIGhlaWdodDogMjAwLFxuICAgICAgd2lkdGg6IDQ2NFxuICAgIH0sXG4gICAgdGh1bWI6IHtcbiAgICAgIHJhZGl1czogMTJcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGNvbG9yUGlja2VyQ3NzID0gXCJAa2V5ZnJhbWVzIGluezAle29wYWNpdHk6MH0xMDAle29wYWNpdHk6MX19QGtleWZyYW1lcyBpbi1kb3duezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgLTVweCwgMCl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIDAsIDApfX1Aa2V5ZnJhbWVzIGluLXVwezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tc2NhbGV7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZTNEKDAuOTUsIDAuOTUsIDEpfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNEKDEsIDEsIDEpfX06cm9vdHstLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZzpjYWxjKDE1MG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yOnZhcigtLWNhbGNpdGUtZHVyYXRpb24tZmFjdG9yLCAxKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1mYXN0OmNhbGMoMTAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLW1lZGl1bTpjYWxjKDIwMG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1zbG93OmNhbGMoMzAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpfS5jYWxjaXRlLWFuaW1hdGV7b3BhY2l0eTowO2FuaW1hdGlvbi1maWxsLW1vZGU6Ym90aDthbmltYXRpb24tZHVyYXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKX0uY2FsY2l0ZS1hbmltYXRlX19pbnthbmltYXRpb24tbmFtZTppbn0uY2FsY2l0ZS1hbmltYXRlX19pbi1kb3due2FuaW1hdGlvbi1uYW1lOmluLWRvd259LmNhbGNpdGUtYW5pbWF0ZV9faW4tdXB7YW5pbWF0aW9uLW5hbWU6aW4tdXB9LmNhbGNpdGUtYW5pbWF0ZV9faW4tc2NhbGV7YW5pbWF0aW9uLW5hbWU6aW4tc2NhbGV9QG1lZGlhIChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2Upezpyb290ey0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6MH19OnJvb3R7LS1jYWxjaXRlLWZsb2F0aW5nLXVpLXRyYW5zaXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKTstLWNhbGNpdGUtZmxvYXRpbmctdWktei1pbmRleDo2MDB9Omhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX06aG9zdChbZGlzYWJsZWRdKXtwb2ludGVyLWV2ZW50czpub25lO2N1cnNvcjpkZWZhdWx0Oy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO29wYWNpdHk6dmFyKC0tY2FsY2l0ZS11aS1vcGFjaXR5LWRpc2FibGVkKX06aG9zdHtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTIpO2xpbmUtaGVpZ2h0OjFyZW07Zm9udC13ZWlnaHQ6dmFyKC0tY2FsY2l0ZS1mb250LXdlaWdodC1ub3JtYWwpfTpob3N0KFtkaXNhYmxlZF0pIDo6c2xvdHRlZChbY2FsY2l0ZS1oeWRyYXRlZF1bZGlzYWJsZWRdKSw6aG9zdChbZGlzYWJsZWRdKSBbY2FsY2l0ZS1oeWRyYXRlZF1bZGlzYWJsZWRde29wYWNpdHk6MX06aG9zdChbc2NhbGU9c10pIC5jb250YWluZXJ7aW5saW5lLXNpemU6MTYwcHh9Omhvc3QoW3NjYWxlPXNdKSAuc2F2ZWQtY29sb3Jze2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoYXV0by1maWxsLCBtaW5tYXgoMjBweCwgMWZyKSl9Omhvc3QoW3NjYWxlPXNdKSAuY2hhbm5lbHN7ZmxleC1kaXJlY3Rpb246Y29sdW1ufTpob3N0KFtzY2FsZT1zXSkgLmNoYW5uZWx7aW5saW5lLXNpemU6MTAwJTttYXJnaW4tYmxvY2stZW5kOjRweH06aG9zdChbc2NhbGU9c10pIC5jaGFubmVsOmxhc3QtY2hpbGR7bWFyZ2luLWJsb2NrLWVuZDowfTpob3N0KFtzY2FsZT1tXSkgLmNvbnRhaW5lcntpbmxpbmUtc2l6ZToyNzJweH06aG9zdChbc2NhbGU9bF0pIC5oZWFkZXJ7cGFkZGluZy1ibG9jay1lbmQ6MHB4fTpob3N0KFtzY2FsZT1sXSl7Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0xKTtsaW5lLWhlaWdodDoxcmVtfTpob3N0KFtzY2FsZT1sXSkgLmNvbnRhaW5lcntpbmxpbmUtc2l6ZTo0NjRweH06aG9zdChbc2NhbGU9bF0pIC5jb2xvci1maWVsZC1hbmQtc2xpZGVye21hcmdpbi1ibG9jay1lbmQ6LTIwcHh9Omhvc3QoW3NjYWxlPWxdKSAuc2VjdGlvbntwYWRkaW5nLWJsb2NrOjAgMTZweDtwYWRkaW5nLWlubGluZToxNnB4fTpob3N0KFtzY2FsZT1sXSkgLnNlY3Rpb246Zmlyc3Qtb2YtdHlwZXtwYWRkaW5nLWJsb2NrLXN0YXJ0OjE2cHh9Omhvc3QoW3NjYWxlPWxdKSAuc2F2ZWQtY29sb3Jze2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoYXV0by1maWxsLCBtaW5tYXgoMjhweCwgMWZyKSk7Z3JpZC1nYXA6MTJweDtwYWRkaW5nLWJsb2NrLXN0YXJ0OjE2cHh9Omhvc3QoW3NjYWxlPWxdKSAuY29udHJvbC1zZWN0aW9ue2ZsZXgtd3JhcDpub3dyYXA7YWxpZ24taXRlbXM6YmFzZWxpbmV9Omhvc3QoW3NjYWxlPWxdKSAuY29udHJvbC1zZWN0aW9uPjpudGgtY2hpbGQoMil7bWFyZ2luLWlubGluZS1zdGFydDoxMnB4fTpob3N0KFtzY2FsZT1sXSkgLmNvbG9yLWhleC1vcHRpb25ze2Rpc3BsYXk6ZmxleDtmbGV4LXNocmluazoxO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYXJvdW5kO21pbi1ibG9jay1zaXplOjk4cHg7aW5saW5lLXNpemU6MTYwcHh9Omhvc3QoW3NjYWxlPWxdKSAuY29sb3ItbW9kZS1jb250YWluZXJ7ZmxleC1zaHJpbms6M30uY29udGFpbmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTEpO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JvcmRlcjoxcHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItMSl9LmNvbG9yLWZpZWxkLWFuZC1zbGlkZXItd3JhcHtwb3NpdGlvbjpyZWxhdGl2ZX0uc2NvcGV7cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTEpO291dGxpbmUtY29sb3I6dHJhbnNwYXJlbnQ7b3V0bGluZS1vZmZzZXQ6MTRweH0uc2NvcGU6Zm9jdXN7b3V0bGluZToycHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1icmFuZCk7b3V0bGluZS1vZmZzZXQ6MTZweH0uY29sb3ItZmllbGQtYW5kLXNsaWRlcnttYXJnaW4tYmxvY2stZW5kOi0xNnB4O3RvdWNoLWFjdGlvbjpub25lfS5jb2xvci1maWVsZC1hbmQtc2xpZGVyLS1pbnRlcmFjdGl2ZXtjdXJzb3I6cG9pbnRlcn0uY29udHJvbC1zZWN0aW9ue2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC13cmFwOndyYXB9LnNlY3Rpb257cGFkZGluZy1ibG9jazowIDEycHg7cGFkZGluZy1pbmxpbmU6MTJweH0uc2VjdGlvbjpmaXJzdC1vZi10eXBle3BhZGRpbmctYmxvY2stc3RhcnQ6MTJweH0uY29sb3ItaGV4LW9wdGlvbnMsLnNlY3Rpb24tLXNwbGl0e2ZsZXgtZ3JvdzoxfS5oZWFkZXJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtwYWRkaW5nLWJsb2NrLWVuZDowLjI1cmVtO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKX0uaGVhZGVyLS1oZXgsLmNvbG9yLW1vZGUtY29udGFpbmVye3BhZGRpbmctYmxvY2stc3RhcnQ6MTJweH0uY2hhbm5lbHN7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5jaGFubmVse2lubGluZS1zaXplOjMxJX0uc2F2ZWQtY29sb3Jze3BhZGRpbmctYmxvY2stc3RhcnQ6MTJweDtkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOnJlcGVhdChhdXRvLWZpbGwsIG1pbm1heCgyNHB4LCAxZnIpKTtncmlkLWdhcDo4cHg7aW5saW5lLXNpemU6MTAwJX0uc2F2ZWQtY29sb3JzLWJ1dHRvbnN7ZGlzcGxheTpmbGV4fS5zYXZlZC1jb2xvcntvdXRsaW5lLW9mZnNldDowO291dGxpbmUtY29sb3I6dHJhbnNwYXJlbnQ7Y3Vyc29yOnBvaW50ZXJ9LnNhdmVkLWNvbG9yOmZvY3Vze291dGxpbmU6MnB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktYnJhbmQpO291dGxpbmUtb2Zmc2V0OjJweH0uc2F2ZWQtY29sb3I6aG92ZXJ7dHJhbnNpdGlvbjpvdXRsaW5lLWNvbG9yIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1mYXN0KSBlYXNlLWluLW91dDtvdXRsaW5lOjJweCBzb2xpZCB2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci0yKTtvdXRsaW5lLW9mZnNldDoycHh9XCI7XG5cbmNvbnN0IHRocm90dGxlRm9yNjBGcHNJbk1zID0gMTY7XG5jb25zdCBkZWZhdWx0VmFsdWUgPSBub3JtYWxpemVIZXgoREVGQVVMVF9DT0xPUi5oZXgoKSk7XG5jb25zdCBkZWZhdWx0Rm9ybWF0ID0gXCJhdXRvXCI7XG5jb25zdCBDb2xvclBpY2tlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5jYWxjaXRlQ29sb3JQaWNrZXJDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVDb2xvclBpY2tlckNoYW5nZVwiLCA2KTtcbiAgICB0aGlzLmNhbGNpdGVDb2xvclBpY2tlcklucHV0ID0gY3JlYXRlRXZlbnQodGhpcywgXCJjYWxjaXRlQ29sb3JQaWNrZXJJbnB1dFwiLCA2KTtcbiAgICB0aGlzLmNvbG9yRmllbGRBbmRTbGlkZXJIb3ZlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5odWVUaHVtYlN0YXRlID0gXCJpZGxlXCI7XG4gICAgdGhpcy5pbnRlcm5hbENvbG9yVXBkYXRlQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5tb2RlID0gQ1NTQ29sb3JNb2RlLkhFWDtcbiAgICB0aGlzLnNoaWZ0S2V5Q2hhbm5lbEFkanVzdG1lbnQgPSAwO1xuICAgIHRoaXMuc2xpZGVyVGh1bWJTdGF0ZSA9IFwiaWRsZVwiO1xuICAgIHRoaXMuaGFuZGxlVGFiQWN0aXZhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuY2hhbm5lbE1vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29sb3ItbW9kZVwiKTtcbiAgICAgIHRoaXMudXBkYXRlQ2hhbm5lbHNGcm9tQ29sb3IodGhpcy5jb2xvcik7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNvbG9yRmllbGRTY29wZUtleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsga2V5IH0gPSBldmVudDtcbiAgICAgIGNvbnN0IGFycm93S2V5VG9YWU9mZnNldCA9IHtcbiAgICAgICAgQXJyb3dVcDogeyB4OiAwLCB5OiAtMTAgfSxcbiAgICAgICAgQXJyb3dSaWdodDogeyB4OiAxMCwgeTogMCB9LFxuICAgICAgICBBcnJvd0Rvd246IHsgeDogMCwgeTogMTAgfSxcbiAgICAgICAgQXJyb3dMZWZ0OiB7IHg6IC0xMCwgeTogMCB9XG4gICAgICB9O1xuICAgICAgaWYgKGFycm93S2V5VG9YWU9mZnNldFtrZXldKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc2NvcGVPcmllbnRhdGlvbiA9IGtleSA9PT0gXCJBcnJvd0Rvd25cIiB8fCBrZXkgPT09IFwiQXJyb3dVcFwiID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCI7XG4gICAgICAgIHRoaXMuY2FwdHVyZUNvbG9yRmllbGRDb2xvcih0aGlzLmNvbG9yRmllbGRTY29wZUxlZnQgKyBhcnJvd0tleVRvWFlPZmZzZXRba2V5XS54IHx8IDAsIHRoaXMuY29sb3JGaWVsZFNjb3BlVG9wICsgYXJyb3dLZXlUb1hZT2Zmc2V0W2tleV0ueSB8fCAwLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUh1ZVNjb3BlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgbW9kaWZpZXIgPSBldmVudC5zaGlmdEtleSA/IDEwIDogMTtcbiAgICAgIGNvbnN0IHsga2V5IH0gPSBldmVudDtcbiAgICAgIGNvbnN0IGFycm93S2V5VG9YT2Zmc2V0ID0ge1xuICAgICAgICBBcnJvd1VwOiAxLFxuICAgICAgICBBcnJvd1JpZ2h0OiAxLFxuICAgICAgICBBcnJvd0Rvd246IC0xLFxuICAgICAgICBBcnJvd0xlZnQ6IC0xXG4gICAgICB9O1xuICAgICAgaWYgKGFycm93S2V5VG9YT2Zmc2V0W2tleV0pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBhcnJvd0tleVRvWE9mZnNldFtrZXldICogbW9kaWZpZXI7XG4gICAgICAgIGNvbnN0IGh1ZSA9IHRoaXMuYmFzZUNvbG9yRmllbGRDb2xvci5odWUoKTtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuaHVlKGh1ZSArIGRlbHRhKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KGNvbG9yLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUhleElucHV0Q2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGNvbnN0IHsgYWxsb3dFbXB0eSwgY29sb3I6IGNvbG9yJDEgfSA9IHRoaXM7XG4gICAgICBjb25zdCBpbnB1dCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGNvbnN0IGhleCA9IGlucHV0LnZhbHVlO1xuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgIWhleCkge1xuICAgICAgICB0aGlzLmludGVybmFsQ29sb3JTZXQobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRIZXggPSBjb2xvciQxICYmIG5vcm1hbGl6ZUhleChjb2xvciQxLmhleCgpKTtcbiAgICAgIGlmIChoZXggIT09IG5vcm1hbGl6ZWRIZXgpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KGNvbG9yKGhleCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTYXZlZENvbG9yU2VsZWN0ID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzd2F0Y2ggPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KGNvbG9yKHN3YXRjaC5jb2xvcikpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDaGFubmVsSW5wdXQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIGNvbnN0IGNoYW5uZWxJbmRleCA9IE51bWJlcihpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNoYW5uZWwtaW5kZXhcIikpO1xuICAgICAgY29uc3QgbGltaXQgPSB0aGlzLmNoYW5uZWxNb2RlID09PSBcInJnYlwiXG4gICAgICAgID8gUkdCX0xJTUlUU1tPYmplY3Qua2V5cyhSR0JfTElNSVRTKVtjaGFubmVsSW5kZXhdXVxuICAgICAgICA6IEhTVl9MSU1JVFNbT2JqZWN0LmtleXMoSFNWX0xJTUlUUylbY2hhbm5lbEluZGV4XV07XG4gICAgICBsZXQgaW5wdXRWYWx1ZTtcbiAgICAgIGlmICh0aGlzLmFsbG93RW1wdHkgJiYgIWlucHV0LnZhbHVlKSB7XG4gICAgICAgIGlucHV0VmFsdWUgPSBcIlwiO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyKGlucHV0LnZhbHVlKSArIHRoaXMuc2hpZnRLZXlDaGFubmVsQWRqdXN0bWVudDtcbiAgICAgICAgY29uc3QgY2xhbXBlZCA9IGNsYW1wKHZhbHVlLCAwLCBsaW1pdCk7XG4gICAgICAgIGlucHV0VmFsdWUgPSBjbGFtcGVkLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpbnB1dC52YWx1ZSA9IGlucHV0VmFsdWU7XG4gICAgICAvLyBUT0RPOiByZWZhY3RvciBjYWxjaXRlLWlucHV0IHNvIHdlIGRvbid0IG5lZWQgdG8gc3luYyB0aGUgaW50ZXJuYWxzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvaXNzdWVzLzYxMDBcbiAgICAgIGlucHV0LmludGVybmFsU3luY0NoaWxkRWxWYWx1ZSgpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDaGFubmVsQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBpbnB1dCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBjaGFubmVsSW5kZXggPSBOdW1iZXIoaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jaGFubmVsLWluZGV4XCIpKTtcbiAgICAgIGNvbnN0IGNoYW5uZWxzID0gWy4uLnRoaXMuY2hhbm5lbHNdO1xuICAgICAgY29uc3Qgc2hvdWxkQ2xlYXJDaGFubmVscyA9IHRoaXMuYWxsb3dFbXB0eSAmJiAhaW5wdXQudmFsdWU7XG4gICAgICBpZiAoc2hvdWxkQ2xlYXJDaGFubmVscykge1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICB0aGlzLmludGVybmFsQ29sb3JTZXQobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWxzW2NoYW5uZWxJbmRleF0gPSBOdW1iZXIoaW5wdXQudmFsdWUpO1xuICAgICAgdGhpcy51cGRhdGVDb2xvckZyb21DaGFubmVscyhjaGFubmVscyk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVNhdmVkQ29sb3JLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoaXNBY3RpdmF0aW9uS2V5KGV2ZW50LmtleSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTYXZlZENvbG9yU2VsZWN0KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ29sb3JGaWVsZEFuZFNsaWRlclBvaW50ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuY29sb3JGaWVsZEFuZFNsaWRlckludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbG9yRmllbGRBbmRTbGlkZXJIb3ZlcmVkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5zbGlkZXJUaHVtYlN0YXRlICE9PSBcImRyYWdcIiAmJiB0aGlzLmh1ZVRodW1iU3RhdGUgIT09IFwiZHJhZ1wiKSB7XG4gICAgICAgIHRoaXMuaHVlVGh1bWJTdGF0ZSA9IFwiaWRsZVwiO1xuICAgICAgICB0aGlzLnNsaWRlclRodW1iU3RhdGUgPSBcImlkbGVcIjtcbiAgICAgICAgdGhpcy5kcmF3Q29sb3JGaWVsZEFuZFNsaWRlcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDb2xvckZpZWxkQW5kU2xpZGVyUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghaXNQcmltYXJ5UG9pbnRlckJ1dHRvbihldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0Q2FudmFzUmVnaW9uKG9mZnNldFkpO1xuICAgICAgaWYgKHJlZ2lvbiA9PT0gXCJjb2xvci1maWVsZFwiKSB7XG4gICAgICAgIHRoaXMuaHVlVGh1bWJTdGF0ZSA9IFwiZHJhZ1wiO1xuICAgICAgICB0aGlzLmNhcHR1cmVDb2xvckZpZWxkQ29sb3Iob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuY29sb3JGaWVsZFNjb3BlTm9kZT8uZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlZ2lvbiA9PT0gXCJzbGlkZXJcIikge1xuICAgICAgICB0aGlzLnNsaWRlclRodW1iU3RhdGUgPSBcImRyYWdcIjtcbiAgICAgICAgdGhpcy5jYXB0dXJlSHVlU2xpZGVyQ29sb3Iob2Zmc2V0WCk7XG4gICAgICAgIHRoaXMuaHVlU2NvcGVOb2RlPy5mb2N1cygpO1xuICAgICAgfVxuICAgICAgLy8gcHJldmVudCB0ZXh0IHNlbGVjdGlvbiBvdXRzaWRlIG9mIGNvbG9yIGZpZWxkICYgc2xpZGVyIGFyZWFcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5nbG9iYWxQb2ludGVyTW92ZUhhbmRsZXIpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLmdsb2JhbFBvaW50ZXJVcEhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHRoaXMuYWN0aXZlQ29sb3JGaWVsZEFuZFNsaWRlclJlY3QgPVxuICAgICAgICB0aGlzLmZpZWxkQW5kU2xpZGVyUmVuZGVyaW5nQ29udGV4dC5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfTtcbiAgICB0aGlzLmdsb2JhbFBvaW50ZXJVcEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghaXNQcmltYXJ5UG9pbnRlckJ1dHRvbihldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldmlvdXNseURyYWdnaW5nID0gdGhpcy5zbGlkZXJUaHVtYlN0YXRlID09PSBcImRyYWdcIiB8fCB0aGlzLmh1ZVRodW1iU3RhdGUgPT09IFwiZHJhZ1wiO1xuICAgICAgdGhpcy5odWVUaHVtYlN0YXRlID0gXCJpZGxlXCI7XG4gICAgICB0aGlzLnNsaWRlclRodW1iU3RhdGUgPSBcImlkbGVcIjtcbiAgICAgIHRoaXMuYWN0aXZlQ29sb3JGaWVsZEFuZFNsaWRlclJlY3QgPSBudWxsO1xuICAgICAgdGhpcy5kcmF3Q29sb3JGaWVsZEFuZFNsaWRlcigpO1xuICAgICAgaWYgKHByZXZpb3VzbHlEcmFnZ2luZykge1xuICAgICAgICB0aGlzLmNhbGNpdGVDb2xvclBpY2tlckNoYW5nZS5lbWl0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdsb2JhbFBvaW50ZXJNb3ZlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBlbCwgZGltZW5zaW9ucyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHNsaWRlclRodW1iRHJhZ2dpbmcgPSB0aGlzLnNsaWRlclRodW1iU3RhdGUgPT09IFwiZHJhZ1wiO1xuICAgICAgY29uc3QgaHVlVGh1bWJEcmFnZ2luZyA9IHRoaXMuaHVlVGh1bWJTdGF0ZSA9PT0gXCJkcmFnXCI7XG4gICAgICBpZiAoIWVsLmlzQ29ubmVjdGVkIHx8ICghc2xpZGVyVGh1bWJEcmFnZ2luZyAmJiAhaHVlVGh1bWJEcmFnZ2luZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHNhbXBsaW5nWDtcbiAgICAgIGxldCBzYW1wbGluZ1k7XG4gICAgICBjb25zdCBjb2xvckZpZWxkQW5kU2xpZGVyUmVjdCA9IHRoaXMuYWN0aXZlQ29sb3JGaWVsZEFuZFNsaWRlclJlY3Q7XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGV2ZW50O1xuICAgICAgaWYgKHRoaXMuY29sb3JGaWVsZEFuZFNsaWRlckhvdmVyZWQpIHtcbiAgICAgICAgc2FtcGxpbmdYID0gY2xpZW50WCAtIGNvbG9yRmllbGRBbmRTbGlkZXJSZWN0Lng7XG4gICAgICAgIHNhbXBsaW5nWSA9IGNsaWVudFkgLSBjb2xvckZpZWxkQW5kU2xpZGVyUmVjdC55O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbG9yRmllbGRXaWR0aCA9IGRpbWVuc2lvbnMuY29sb3JGaWVsZC53aWR0aDtcbiAgICAgICAgY29uc3QgY29sb3JGaWVsZEhlaWdodCA9IGRpbWVuc2lvbnMuY29sb3JGaWVsZC5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGh1ZVNsaWRlckhlaWdodCA9IGRpbWVuc2lvbnMuc2xpZGVyLmhlaWdodDtcbiAgICAgICAgaWYgKGNsaWVudFggPCBjb2xvckZpZWxkQW5kU2xpZGVyUmVjdC54ICsgY29sb3JGaWVsZFdpZHRoICYmXG4gICAgICAgICAgY2xpZW50WCA+IGNvbG9yRmllbGRBbmRTbGlkZXJSZWN0LngpIHtcbiAgICAgICAgICBzYW1wbGluZ1ggPSBjbGllbnRYIC0gY29sb3JGaWVsZEFuZFNsaWRlclJlY3QueDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGllbnRYIDwgY29sb3JGaWVsZEFuZFNsaWRlclJlY3QueCkge1xuICAgICAgICAgIHNhbXBsaW5nWCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2FtcGxpbmdYID0gY29sb3JGaWVsZFdpZHRoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpZW50WSA8IGNvbG9yRmllbGRBbmRTbGlkZXJSZWN0LnkgKyBjb2xvckZpZWxkSGVpZ2h0ICsgaHVlU2xpZGVySGVpZ2h0ICYmXG4gICAgICAgICAgY2xpZW50WSA+IGNvbG9yRmllbGRBbmRTbGlkZXJSZWN0LnkpIHtcbiAgICAgICAgICBzYW1wbGluZ1kgPSBjbGllbnRZIC0gY29sb3JGaWVsZEFuZFNsaWRlclJlY3QueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGllbnRZIDwgY29sb3JGaWVsZEFuZFNsaWRlclJlY3QueSkge1xuICAgICAgICAgIHNhbXBsaW5nWSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2FtcGxpbmdZID0gY29sb3JGaWVsZEhlaWdodCArIGh1ZVNsaWRlckhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGh1ZVRodW1iRHJhZ2dpbmcpIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlQ29sb3JGaWVsZENvbG9yKHNhbXBsaW5nWCwgc2FtcGxpbmdZLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlSHVlU2xpZGVyQ29sb3Ioc2FtcGxpbmdYKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ29sb3JGaWVsZEFuZFNsaWRlclBvaW50ZXJFbnRlck9yTW92ZSA9ICh7IG9mZnNldFgsIG9mZnNldFkgfSkgPT4ge1xuICAgICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IGNvbG9yRmllbGQsIHNsaWRlciwgdGh1bWIgfSB9ID0gdGhpcztcbiAgICAgIHRoaXMuY29sb3JGaWVsZEFuZFNsaWRlckludGVyYWN0aXZlID0gb2Zmc2V0WSA8PSBjb2xvckZpZWxkLmhlaWdodCArIHNsaWRlci5oZWlnaHQ7XG4gICAgICB0aGlzLmNvbG9yRmllbGRBbmRTbGlkZXJIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0Q2FudmFzUmVnaW9uKG9mZnNldFkpO1xuICAgICAgaWYgKHJlZ2lvbiA9PT0gXCJjb2xvci1maWVsZFwiKSB7XG4gICAgICAgIGNvbnN0IHByZXZIdWVUaHVtYlN0YXRlID0gdGhpcy5odWVUaHVtYlN0YXRlO1xuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuYmFzZUNvbG9yRmllbGRDb2xvci5oc3YoKTtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IE1hdGgucm91bmQoY29sb3Iuc2F0dXJhdGlvbnYoKSAvIChIU1ZfTElNSVRTLnMgLyBjb2xvckZpZWxkLndpZHRoKSk7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSBNYXRoLnJvdW5kKGNvbG9yRmllbGQuaGVpZ2h0IC0gY29sb3IudmFsdWUoKSAvIChIU1ZfTElNSVRTLnYgLyBjb2xvckZpZWxkLmhlaWdodCkpO1xuICAgICAgICBjb25zdCBob3ZlcmluZ1RodW1iID0gdGhpcy5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFksIGNlbnRlclgsIGNlbnRlclksIHRodW1iLnJhZGl1cyk7XG4gICAgICAgIGxldCB0cmFuc2l0aW9uZWRCZXR3ZWVuSG92ZXJBbmRJZGxlID0gZmFsc2U7XG4gICAgICAgIGlmIChwcmV2SHVlVGh1bWJTdGF0ZSA9PT0gXCJpZGxlXCIgJiYgaG92ZXJpbmdUaHVtYikge1xuICAgICAgICAgIHRoaXMuaHVlVGh1bWJTdGF0ZSA9IFwiaG92ZXJcIjtcbiAgICAgICAgICB0cmFuc2l0aW9uZWRCZXR3ZWVuSG92ZXJBbmRJZGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2SHVlVGh1bWJTdGF0ZSA9PT0gXCJob3ZlclwiICYmICFob3ZlcmluZ1RodW1iKSB7XG4gICAgICAgICAgdGhpcy5odWVUaHVtYlN0YXRlID0gXCJpZGxlXCI7XG4gICAgICAgICAgdHJhbnNpdGlvbmVkQmV0d2VlbkhvdmVyQW5kSWRsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaHVlVGh1bWJTdGF0ZSAhPT0gXCJkcmFnXCIpIHtcbiAgICAgICAgICBpZiAodHJhbnNpdGlvbmVkQmV0d2VlbkhvdmVyQW5kSWRsZSkge1xuICAgICAgICAgICAgLy8gcmVmcmVzaCBzaW5jZSB3ZSB3b24ndCB1cGRhdGUgY29sb3IgYW5kIHRodXMgbm8gcmVkcmF3XG4gICAgICAgICAgICB0aGlzLmRyYXdDb2xvckZpZWxkQW5kU2xpZGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChyZWdpb24gPT09IFwic2xpZGVyXCIpIHtcbiAgICAgICAgY29uc3Qgc2xpZGVyVGh1bWJDb2xvciA9IHRoaXMuYmFzZUNvbG9yRmllbGRDb2xvci5oc3YoKS5zYXR1cmF0aW9udigxMDApLnZhbHVlKDEwMCk7XG4gICAgICAgIGNvbnN0IHByZXZTbGlkZXJUaHVtYlN0YXRlID0gdGhpcy5zbGlkZXJUaHVtYlN0YXRlO1xuICAgICAgICBjb25zdCBzbGlkZXJUaHVtYkNlbnRlclggPSBNYXRoLnJvdW5kKHNsaWRlclRodW1iQ29sb3IuaHVlKCkgLyAoMzYwIC8gc2xpZGVyLndpZHRoKSk7XG4gICAgICAgIGNvbnN0IHNsaWRlclRodW1iQ2VudGVyWSA9IE1hdGgucm91bmQoKHNsaWRlci5oZWlnaHQgKyB0aGlzLmdldFNsaWRlckNhcFNwYWNpbmcoKSkgLyAyKSArIGNvbG9yRmllbGQuaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlcmluZ1NsaWRlclRodW1iID0gdGhpcy5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFksIHNsaWRlclRodW1iQ2VudGVyWCwgc2xpZGVyVGh1bWJDZW50ZXJZLCB0aHVtYi5yYWRpdXMpO1xuICAgICAgICBsZXQgc2xpZGVyVGh1bWJUcmFuc2l0aW9uZWRCZXR3ZWVuSG92ZXJBbmRJZGxlID0gZmFsc2U7XG4gICAgICAgIGlmIChwcmV2U2xpZGVyVGh1bWJTdGF0ZSA9PT0gXCJpZGxlXCIgJiYgaG92ZXJpbmdTbGlkZXJUaHVtYikge1xuICAgICAgICAgIHRoaXMuc2xpZGVyVGh1bWJTdGF0ZSA9IFwiaG92ZXJcIjtcbiAgICAgICAgICBzbGlkZXJUaHVtYlRyYW5zaXRpb25lZEJldHdlZW5Ib3ZlckFuZElkbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZTbGlkZXJUaHVtYlN0YXRlID09PSBcImhvdmVyXCIgJiYgIWhvdmVyaW5nU2xpZGVyVGh1bWIpIHtcbiAgICAgICAgICB0aGlzLnNsaWRlclRodW1iU3RhdGUgPSBcImlkbGVcIjtcbiAgICAgICAgICBzbGlkZXJUaHVtYlRyYW5zaXRpb25lZEJldHdlZW5Ib3ZlckFuZElkbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNsaWRlclRodW1iU3RhdGUgIT09IFwiZHJhZ1wiKSB7XG4gICAgICAgICAgaWYgKHNsaWRlclRodW1iVHJhbnNpdGlvbmVkQmV0d2VlbkhvdmVyQW5kSWRsZSkge1xuICAgICAgICAgICAgLy8gcmVmcmVzaCBzaW5jZSB3ZSB3b24ndCB1cGRhdGUgY29sb3IgYW5kIHRodXMgbm8gcmVkcmF3XG4gICAgICAgICAgICB0aGlzLmRyYXdDb2xvckZpZWxkQW5kU2xpZGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnN0b3JlQ29sb3JGaWVsZFNjb3BlID0gKG5vZGUpID0+IHtcbiAgICAgIHRoaXMuY29sb3JGaWVsZFNjb3BlTm9kZSA9IG5vZGU7XG4gICAgfTtcbiAgICB0aGlzLnN0b3JlSHVlU2NvcGUgPSAobm9kZSkgPT4ge1xuICAgICAgdGhpcy5odWVTY29wZU5vZGUgPSBub2RlO1xuICAgIH07XG4gICAgdGhpcy5yZW5kZXJDaGFubmVsc1RhYlRpdGxlID0gKGNoYW5uZWxNb2RlKSA9PiB7XG4gICAgICBjb25zdCB7IGNoYW5uZWxNb2RlOiBhY3RpdmVDaGFubmVsTW9kZSwgbWVzc2FnZXMgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IGNoYW5uZWxNb2RlID09PSBhY3RpdmVDaGFubmVsTW9kZTtcbiAgICAgIGNvbnN0IGxhYmVsID0gY2hhbm5lbE1vZGUgPT09IFwicmdiXCIgPyBtZXNzYWdlcy5yZ2IgOiBtZXNzYWdlcy5oc3Y7XG4gICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLXRhYi10aXRsZVwiLCB7IGNsYXNzOiBDU1MuY29sb3JNb2RlLCBcImRhdGEtY29sb3ItbW9kZVwiOiBjaGFubmVsTW9kZSwga2V5OiBjaGFubmVsTW9kZSwgb25DYWxjaXRlVGFic0FjdGl2YXRlOiB0aGlzLmhhbmRsZVRhYkFjdGl2YXRlLCBzZWxlY3RlZDogc2VsZWN0ZWQgfSwgbGFiZWwpKTtcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyQ2hhbm5lbHNUYWIgPSAoY2hhbm5lbE1vZGUpID0+IHtcbiAgICAgIGNvbnN0IHsgY2hhbm5lbE1vZGU6IGFjdGl2ZUNoYW5uZWxNb2RlLCBjaGFubmVscywgbWVzc2FnZXMgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IGNoYW5uZWxNb2RlID09PSBhY3RpdmVDaGFubmVsTW9kZTtcbiAgICAgIGNvbnN0IGlzUmdiID0gY2hhbm5lbE1vZGUgPT09IFwicmdiXCI7XG4gICAgICBjb25zdCBjaGFubmVsTGFiZWxzID0gaXNSZ2JcbiAgICAgICAgPyBbbWVzc2FnZXMuciwgbWVzc2FnZXMuZywgbWVzc2FnZXMuYl1cbiAgICAgICAgOiBbbWVzc2FnZXMuaCwgbWVzc2FnZXMucywgbWVzc2FnZXMudl07XG4gICAgICBjb25zdCBjaGFubmVsQXJpYUxhYmVscyA9IGlzUmdiXG4gICAgICAgID8gW21lc3NhZ2VzLnJlZCwgbWVzc2FnZXMuZ3JlZW4sIG1lc3NhZ2VzLmJsdWVdXG4gICAgICAgIDogW21lc3NhZ2VzLmh1ZSwgbWVzc2FnZXMuc2F0dXJhdGlvbiwgbWVzc2FnZXMudmFsdWVdO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZ2V0RWxlbWVudERpcih0aGlzLmVsKTtcbiAgICAgIHJldHVybiAoaChcImNhbGNpdGUtdGFiXCIsIHsgY2xhc3M6IENTUy5jb250cm9sLCBrZXk6IGNoYW5uZWxNb2RlLCBzZWxlY3RlZDogc2VsZWN0ZWQgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY2hhbm5lbHMsIGRpcjogXCJsdHJcIiB9LCBjaGFubmVscy5tYXAoKGNoYW5uZWwsIGluZGV4KSA9PiBcbiAgICAgIC8qIHRoZSBjaGFubmVsIGNvbnRhaW5lciBpcyBsdHIsIHNvIHdlIGFwcGx5IHRoZSBob3N0J3MgZGlyZWN0aW9uICovXG4gICAgICB0aGlzLnJlbmRlckNoYW5uZWwoY2hhbm5lbCwgaW5kZXgsIGNoYW5uZWxMYWJlbHNbaW5kZXhdLCBjaGFubmVsQXJpYUxhYmVsc1tpbmRleF0sIGRpcmVjdGlvbikpKSkpO1xuICAgIH07XG4gICAgdGhpcy5yZW5kZXJDaGFubmVsID0gKHZhbHVlLCBpbmRleCwgbGFiZWwsIGFyaWFMYWJlbCwgZGlyZWN0aW9uKSA9PiAoaChcImNhbGNpdGUtaW5wdXRcIiwgeyBjbGFzczogQ1NTLmNoYW5uZWwsIFwiZGF0YS1jaGFubmVsLWluZGV4XCI6IGluZGV4LCBkaXI6IGRpcmVjdGlvbiwgbGFiZWw6IGFyaWFMYWJlbCwgbGFuZzogdGhpcy5lZmZlY3RpdmVMb2NhbGUsIG51bWJlckJ1dHRvblR5cGU6IFwibm9uZVwiLCBudW1iZXJpbmdTeXN0ZW06IHRoaXMubnVtYmVyaW5nU3lzdGVtLCBvbkNhbGNpdGVJbnB1dENoYW5nZTogdGhpcy5oYW5kbGVDaGFubmVsQ2hhbmdlLCBvbkNhbGNpdGVJbnB1dElucHV0OiB0aGlzLmhhbmRsZUNoYW5uZWxJbnB1dCwgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleURvd24sIHByZWZpeFRleHQ6IGxhYmVsLCBzY2FsZTogdGhpcy5zY2FsZSA9PT0gXCJsXCIgPyBcIm1cIiA6IFwic1wiLCB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogdmFsdWU/LnRvU3RyaW5nKCkgfSkpO1xuICAgIHRoaXMuZGVsZXRlQ29sb3IgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjb2xvclRvRGVsZXRlID0gdGhpcy5jb2xvci5oZXgoKTtcbiAgICAgIGNvbnN0IGluU3RvcmFnZSA9IHRoaXMuc2F2ZWRDb2xvcnMuaW5kZXhPZihjb2xvclRvRGVsZXRlKSA+IC0xO1xuICAgICAgaWYgKCFpblN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2F2ZWRDb2xvcnMgPSB0aGlzLnNhdmVkQ29sb3JzLmZpbHRlcigoY29sb3IpID0+IGNvbG9yICE9PSBjb2xvclRvRGVsZXRlKTtcbiAgICAgIHRoaXMuc2F2ZWRDb2xvcnMgPSBzYXZlZENvbG9ycztcbiAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBgJHtERUZBVUxUX1NUT1JBR0VfS0VZX1BSRUZJWH0ke3RoaXMuc3RvcmFnZUlkfWA7XG4gICAgICBpZiAodGhpcy5zdG9yYWdlSWQpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSwgSlNPTi5zdHJpbmdpZnkoc2F2ZWRDb2xvcnMpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2F2ZUNvbG9yID0gKCkgPT4ge1xuICAgICAgY29uc3QgY29sb3JUb1NhdmUgPSB0aGlzLmNvbG9yLmhleCgpO1xuICAgICAgY29uc3QgYWxyZWFkeVNhdmVkID0gdGhpcy5zYXZlZENvbG9ycy5pbmRleE9mKGNvbG9yVG9TYXZlKSA+IC0xO1xuICAgICAgaWYgKGFscmVhZHlTYXZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzYXZlZENvbG9ycyA9IFsuLi50aGlzLnNhdmVkQ29sb3JzLCBjb2xvclRvU2F2ZV07XG4gICAgICB0aGlzLnNhdmVkQ29sb3JzID0gc2F2ZWRDb2xvcnM7XG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gYCR7REVGQVVMVF9TVE9SQUdFX0tFWV9QUkVGSVh9JHt0aGlzLnN0b3JhZ2VJZH1gO1xuICAgICAgaWYgKHRoaXMuc3RvcmFnZUlkKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KHNhdmVkQ29sb3JzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRyYXdDb2xvckZpZWxkQW5kU2xpZGVyID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmZpZWxkQW5kU2xpZGVyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdDb2xvckZpZWxkKCk7XG4gICAgICB0aGlzLmRyYXdIdWVTbGlkZXIoKTtcbiAgICB9LCB0aHJvdHRsZUZvcjYwRnBzSW5Ncyk7XG4gICAgdGhpcy5jYXB0dXJlQ29sb3JGaWVsZENvbG9yID0gKHgsIHksIHNraXBFcXVhbCA9IHRydWUpID0+IHtcbiAgICAgIGNvbnN0IHsgZGltZW5zaW9uczogeyBjb2xvckZpZWxkOiB7IGhlaWdodCwgd2lkdGggfSB9IH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2F0dXJhdGlvbiA9IE1hdGgucm91bmQoKEhTVl9MSU1JVFMucyAvIHdpZHRoKSAqIHgpO1xuICAgICAgY29uc3QgdmFsdWUgPSBNYXRoLnJvdW5kKChIU1ZfTElNSVRTLnYgLyBoZWlnaHQpICogKGhlaWdodCAtIHkpKTtcbiAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldCh0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuaHN2KCkuc2F0dXJhdGlvbnYoc2F0dXJhdGlvbikudmFsdWUodmFsdWUpLCBza2lwRXF1YWwpO1xuICAgIH07XG4gICAgdGhpcy5pbml0Q29sb3JGaWVsZEFuZFNsaWRlciA9IChjYW52YXMpID0+IHtcbiAgICAgIHRoaXMuZmllbGRBbmRTbGlkZXJSZW5kZXJpbmdDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHRoaXMudXBkYXRlQ2FudmFzU2l6ZShjYW52YXMpO1xuICAgIH07XG4gICAgdGhpcy5hbGxvd0VtcHR5ID0gZmFsc2U7XG4gICAgdGhpcy5jb2xvciA9IERFRkFVTFRfQ09MT1I7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZm9ybWF0ID0gZGVmYXVsdEZvcm1hdDtcbiAgICB0aGlzLmhpZGVIZXggPSBmYWxzZTtcbiAgICB0aGlzLmhpZGVDaGFubmVscyA9IGZhbHNlO1xuICAgIHRoaXMuaGlkZVNhdmVkID0gZmFsc2U7XG4gICAgdGhpcy5zY2FsZSA9IFwibVwiO1xuICAgIHRoaXMuc3RvcmFnZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWVzc2FnZU92ZXJyaWRlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIHRoaXMuZGVmYXVsdE1lc3NhZ2VzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sb3JGaWVsZEFuZFNsaWRlckludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jaGFubmVsTW9kZSA9IFwicmdiXCI7XG4gICAgdGhpcy5jaGFubmVscyA9IHRoaXMudG9DaGFubmVscyhERUZBVUxUX0NPTE9SKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBESU1FTlNJT05TLm07XG4gICAgdGhpcy5lZmZlY3RpdmVMb2NhbGUgPSBcIlwiO1xuICAgIHRoaXMubWVzc2FnZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zYXZlZENvbG9ycyA9IFtdO1xuICAgIHRoaXMuY29sb3JGaWVsZFNjb3BlVG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sb3JGaWVsZFNjb3BlTGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjb3BlT3JpZW50YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5odWVTY29wZUxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5odWVTY29wZVRvcCA9IHVuZGVmaW5lZDtcbiAgfVxuICBoYW5kbGVDb2xvckNoYW5nZShjb2xvciwgb2xkQ29sb3IpIHtcbiAgICB0aGlzLmRyYXdDb2xvckZpZWxkQW5kU2xpZGVyKCk7XG4gICAgdGhpcy51cGRhdGVDaGFubmVsc0Zyb21Db2xvcihjb2xvcik7XG4gICAgdGhpcy5wcmV2aW91c0NvbG9yID0gb2xkQ29sb3I7XG4gIH1cbiAgaGFuZGxlRm9ybWF0Q2hhbmdlKGZvcm1hdCkge1xuICAgIHRoaXMuc2V0TW9kZShmb3JtYXQpO1xuICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldCh0aGlzLmNvbG9yLCBmYWxzZSwgXCJpbnRlcm5hbFwiKTtcbiAgfVxuICBoYW5kbGVTY2FsZUNoYW5nZShzY2FsZSA9IFwibVwiKSB7XG4gICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKHNjYWxlKTtcbiAgICB0aGlzLnVwZGF0ZUNhbnZhc1NpemUodGhpcy5maWVsZEFuZFNsaWRlclJlbmRlcmluZ0NvbnRleHQ/LmNhbnZhcyk7XG4gIH1cbiAgb25NZXNzYWdlc0NoYW5nZSgpIHtcbiAgICAvKiB3aXJlZCB1cCBieSB0OW4gdXRpbCAqL1xuICB9XG4gIGhhbmRsZVZhbHVlQ2hhbmdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGNvbnN0IHsgYWxsb3dFbXB0eSwgZm9ybWF0IH0gPSB0aGlzO1xuICAgIGNvbnN0IGNoZWNrTW9kZSA9ICFhbGxvd0VtcHR5IHx8IHZhbHVlO1xuICAgIGxldCBtb2RlQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGlmIChjaGVja01vZGUpIHtcbiAgICAgIGNvbnN0IG5leHRNb2RlID0gcGFyc2VNb2RlKHZhbHVlKTtcbiAgICAgIGlmICghbmV4dE1vZGUgfHwgKGZvcm1hdCAhPT0gXCJhdXRvXCIgJiYgbmV4dE1vZGUgIT09IGZvcm1hdCkpIHtcbiAgICAgICAgdGhpcy5zaG93SW5jb21wYXRpYmxlQ29sb3JXYXJuaW5nKHZhbHVlLCBmb3JtYXQpO1xuICAgICAgICB0aGlzLnZhbHVlID0gb2xkVmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1vZGVDaGFuZ2VkID0gdGhpcy5tb2RlICE9PSBuZXh0TW9kZTtcbiAgICAgIHRoaXMuc2V0TW9kZShuZXh0TW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGRyYWdnaW5nID0gdGhpcy5zbGlkZXJUaHVtYlN0YXRlID09PSBcImRyYWdcIiB8fCB0aGlzLmh1ZVRodW1iU3RhdGUgPT09IFwiZHJhZ1wiO1xuICAgIGlmICh0aGlzLmludGVybmFsQ29sb3JVcGRhdGVDb250ZXh0ID09PSBcImluaXRpYWxcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnRlcm5hbENvbG9yVXBkYXRlQ29udGV4dCA9PT0gXCJ1c2VyLWludGVyYWN0aW9uXCIpIHtcbiAgICAgIHRoaXMuY2FsY2l0ZUNvbG9yUGlja2VySW5wdXQuZW1pdCgpO1xuICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICB0aGlzLmNhbGNpdGVDb2xvclBpY2tlckNoYW5nZS5lbWl0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yJDEgPSBhbGxvd0VtcHR5ICYmICF2YWx1ZSA/IG51bGwgOiBjb2xvcih2YWx1ZSk7XG4gICAgY29uc3QgY29sb3JDaGFuZ2VkID0gIWNvbG9yRXF1YWwoY29sb3IkMSwgdGhpcy5jb2xvcik7XG4gICAgaWYgKG1vZGVDaGFuZ2VkIHx8IGNvbG9yQ2hhbmdlZCkge1xuICAgICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KGNvbG9yJDEsIHRydWUsIFwiaW50ZXJuYWxcIik7XG4gICAgfVxuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIEludGVybmFsIFN0YXRlL1Byb3BzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZ2V0IGJhc2VDb2xvckZpZWxkQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3IgfHwgdGhpcy5wcmV2aW91c0NvbG9yIHx8IERFRkFVTFRfQ09MT1I7XG4gIH1cbiAgZWZmZWN0aXZlTG9jYWxlQ2hhbmdlKCkge1xuICAgIHVwZGF0ZU1lc3NhZ2VzKHRoaXMsIHRoaXMuZWZmZWN0aXZlTG9jYWxlKTtcbiAgfVxuICAvLyB1c2luZyBATGlzdGVuIGFzIGEgd29ya2Fyb3VuZCBmb3IgVkRPTSBsaXN0ZW5lciBub3QgZmlyaW5nXG4gIGhhbmRsZUNoYW5uZWxLZXlVcE9yRG93bihldmVudCkge1xuICAgIHRoaXMuc2hpZnRLZXlDaGFubmVsQWRqdXN0bWVudCA9IDA7XG4gICAgY29uc3QgeyBrZXkgfSA9IGV2ZW50O1xuICAgIGlmICgoa2V5ICE9PSBcIkFycm93VXBcIiAmJiBrZXkgIT09IFwiQXJyb3dEb3duXCIpIHx8XG4gICAgICAhZXZlbnQuY29tcG9zZWRQYXRoKCkuc29tZSgobm9kZSkgPT4gbm9kZS5jbGFzc0xpc3Q/LmNvbnRhaW5zKENTUy5jaGFubmVsKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBzaGlmdEtleSB9ID0gZXZlbnQ7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMuY29sb3IpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldCh0aGlzLnByZXZpb3VzQ29sb3IpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHRoaXMgZ2V0cyBhcHBsaWVkIHRvIHRoZSBpbnB1dCdzIHVwL2Rvd24gYXJyb3cgaW5jcmVtZW50L2RlY3JlbWVudFxuICAgIGNvbnN0IGNvbXBsZW1lbnRhcnlCdW1wID0gOTtcbiAgICB0aGlzLnNoaWZ0S2V5Q2hhbm5lbEFkanVzdG1lbnQgPVxuICAgICAga2V5ID09PSBcIkFycm93VXBcIiAmJiBzaGlmdEtleVxuICAgICAgICA/IGNvbXBsZW1lbnRhcnlCdW1wXG4gICAgICAgIDoga2V5ID09PSBcIkFycm93RG93blwiICYmIHNoaWZ0S2V5XG4gICAgICAgICAgPyAtY29tcGxlbWVudGFyeUJ1bXBcbiAgICAgICAgICA6IDA7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHVibGljIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKiogU2V0cyBmb2N1cyBvbiB0aGUgY29tcG9uZW50J3MgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQuICovXG4gIGFzeW5jIHNldEZvY3VzKCkge1xuICAgIGF3YWl0IGNvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAgICB0aGlzLmVsLmZvY3VzKCk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgc2V0VXBMb2FkYWJsZUNvbXBvbmVudCh0aGlzKTtcbiAgICBjb25zdCB7IGFsbG93RW1wdHksIGNvbG9yOiBjb2xvciQxLCBmb3JtYXQsIHZhbHVlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHdpbGxTZXROb0NvbG9yID0gYWxsb3dFbXB0eSAmJiAhdmFsdWU7XG4gICAgY29uc3QgcGFyc2VkTW9kZSA9IHBhcnNlTW9kZSh2YWx1ZSk7XG4gICAgY29uc3QgdmFsdWVJc0NvbXBhdGlibGUgPSB3aWxsU2V0Tm9Db2xvciB8fCAoZm9ybWF0ID09PSBcImF1dG9cIiAmJiBwYXJzZWRNb2RlKSB8fCBmb3JtYXQgPT09IHBhcnNlZE1vZGU7XG4gICAgY29uc3QgaW5pdGlhbENvbG9yID0gd2lsbFNldE5vQ29sb3IgPyBudWxsIDogdmFsdWVJc0NvbXBhdGlibGUgPyBjb2xvcih2YWx1ZSkgOiBjb2xvciQxO1xuICAgIGlmICghdmFsdWVJc0NvbXBhdGlibGUpIHtcbiAgICAgIHRoaXMuc2hvd0luY29tcGF0aWJsZUNvbG9yV2FybmluZyh2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgdGhpcy5zZXRNb2RlKGZvcm1hdCk7XG4gICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KGluaXRpYWxDb2xvciwgZmFsc2UsIFwiaW5pdGlhbFwiKTtcbiAgICB0aGlzLnVwZGF0ZURpbWVuc2lvbnModGhpcy5zY2FsZSk7XG4gICAgY29uc3Qgc3RvcmFnZUtleSA9IGAke0RFRkFVTFRfU1RPUkFHRV9LRVlfUFJFRklYfSR7dGhpcy5zdG9yYWdlSWR9YDtcbiAgICBpZiAodGhpcy5zdG9yYWdlSWQgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSkpIHtcbiAgICAgIHRoaXMuc2F2ZWRDb2xvcnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpKTtcbiAgICB9XG4gICAgYXdhaXQgc2V0VXBNZXNzYWdlcyh0aGlzKTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb25uZWN0TG9jYWxpemVkKHRoaXMpO1xuICAgIGNvbm5lY3RNZXNzYWdlcyh0aGlzKTtcbiAgfVxuICBjb21wb25lbnREaWRMb2FkKCkge1xuICAgIHNldENvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5nbG9iYWxQb2ludGVyTW92ZUhhbmRsZXIpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5nbG9iYWxQb2ludGVyVXBIYW5kbGVyKTtcbiAgICBkaXNjb25uZWN0TG9jYWxpemVkKHRoaXMpO1xuICAgIGRpc2Nvbm5lY3RNZXNzYWdlcyh0aGlzKTtcbiAgfVxuICBjb21wb25lbnREaWRSZW5kZXIoKSB7XG4gICAgdXBkYXRlSG9zdEludGVyYWN0aW9uKHRoaXMpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFJlbmRlciBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYWxsb3dFbXB0eSwgY29sb3IsIG1lc3NhZ2VzLCBoaWRlSGV4LCBoaWRlQ2hhbm5lbHMsIGhpZGVTYXZlZCwgc2F2ZWRDb2xvcnMsIHNjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlbGVjdGVkQ29sb3JJbkhleCA9IGNvbG9yID8gY29sb3IuaGV4KCkgOiBudWxsO1xuICAgIGNvbnN0IGhleElucHV0U2NhbGUgPSBzY2FsZSA9PT0gXCJsXCIgPyBcIm1cIiA6IFwic1wiO1xuICAgIGNvbnN0IHsgY29sb3JGaWVsZEFuZFNsaWRlckludGVyYWN0aXZlLCBjb2xvckZpZWxkU2NvcGVUb3AsIGNvbG9yRmllbGRTY29wZUxlZnQsIGh1ZVNjb3BlTGVmdCwgaHVlU2NvcGVUb3AsIHNjb3BlT3JpZW50YXRpb24sIGRpbWVuc2lvbnM6IHsgY29sb3JGaWVsZDogeyBoZWlnaHQ6IGNvbG9yRmllbGRIZWlnaHQsIHdpZHRoOiBjb2xvckZpZWxkV2lkdGggfSwgc2xpZGVyOiB7IGhlaWdodDogc2xpZGVySGVpZ2h0IH0gfSB9ID0gdGhpcztcbiAgICBjb25zdCBodWVUb3AgPSBodWVTY29wZVRvcCA/PyBzbGlkZXJIZWlnaHQgLyAyICsgY29sb3JGaWVsZEhlaWdodDtcbiAgICBjb25zdCBodWVMZWZ0ID0gaHVlU2NvcGVMZWZ0ID8/IChjb2xvckZpZWxkV2lkdGggKiBERUZBVUxUX0NPTE9SLmh1ZSgpKSAvIEhTVl9MSU1JVFMuaDtcbiAgICBjb25zdCBub0NvbG9yID0gY29sb3IgPT09IG51bGw7XG4gICAgY29uc3QgdmVydGljYWwgPSBzY29wZU9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCI7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb250YWluZXIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29sb3JGaWVsZEFuZFNsaWRlcldyYXAgfSwgaChcImNhbnZhc1wiLCB7IGNsYXNzOiB7XG4gICAgICAgIFtDU1MuY29sb3JGaWVsZEFuZFNsaWRlcl06IHRydWUsXG4gICAgICAgIFtDU1MuY29sb3JGaWVsZEFuZFNsaWRlckludGVyYWN0aXZlXTogY29sb3JGaWVsZEFuZFNsaWRlckludGVyYWN0aXZlXG4gICAgICB9LCBvblBvaW50ZXJEb3duOiB0aGlzLmhhbmRsZUNvbG9yRmllbGRBbmRTbGlkZXJQb2ludGVyRG93biwgb25Qb2ludGVyRW50ZXI6IHRoaXMuaGFuZGxlQ29sb3JGaWVsZEFuZFNsaWRlclBvaW50ZXJFbnRlck9yTW92ZSwgb25Qb2ludGVyTGVhdmU6IHRoaXMuaGFuZGxlQ29sb3JGaWVsZEFuZFNsaWRlclBvaW50ZXJMZWF2ZSwgb25Qb2ludGVyTW92ZTogdGhpcy5oYW5kbGVDb2xvckZpZWxkQW5kU2xpZGVyUG9pbnRlckVudGVyT3JNb3ZlLCByZWY6IHRoaXMuaW5pdENvbG9yRmllbGRBbmRTbGlkZXIgfSksIGgoXCJkaXZcIiwgeyBcImFyaWEtbGFiZWxcIjogdmVydGljYWwgPyBtZXNzYWdlcy52YWx1ZSA6IG1lc3NhZ2VzLnNhdHVyYXRpb24sIFwiYXJpYS12YWx1ZW1heFwiOiB2ZXJ0aWNhbCA/IEhTVl9MSU1JVFMudiA6IEhTVl9MSU1JVFMucywgXCJhcmlhLXZhbHVlbWluXCI6IFwiMFwiLCBcImFyaWEtdmFsdWVub3dcIjogKHZlcnRpY2FsID8gY29sb3I/LnNhdHVyYXRpb252KCkgOiBjb2xvcj8udmFsdWUoKSkgfHwgXCIwXCIsIGNsYXNzOiB7IFtDU1Muc2NvcGVdOiB0cnVlLCBbQ1NTLmNvbG9yRmllbGRTY29wZV06IHRydWUgfSwgb25LZXlEb3duOiB0aGlzLmhhbmRsZUNvbG9yRmllbGRTY29wZUtleURvd24sIHJlZjogdGhpcy5zdG9yZUNvbG9yRmllbGRTY29wZSwgcm9sZTogXCJzbGlkZXJcIiwgc3R5bGU6IHsgdG9wOiBgJHtjb2xvckZpZWxkU2NvcGVUb3AgfHwgMH1weGAsIGxlZnQ6IGAke2NvbG9yRmllbGRTY29wZUxlZnQgfHwgMH1weGAgfSwgdGFiaW5kZXg6IFwiMFwiIH0pLCBoKFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsXCI6IG1lc3NhZ2VzLmh1ZSwgXCJhcmlhLXZhbHVlbWF4XCI6IEhTVl9MSU1JVFMuaCwgXCJhcmlhLXZhbHVlbWluXCI6IFwiMFwiLCBcImFyaWEtdmFsdWVub3dcIjogY29sb3I/LnJvdW5kKCkuaHVlKCkgfHwgREVGQVVMVF9DT0xPUi5yb3VuZCgpLmh1ZSgpLCBjbGFzczogeyBbQ1NTLnNjb3BlXTogdHJ1ZSwgW0NTUy5odWVTY29wZV06IHRydWUgfSwgb25LZXlEb3duOiB0aGlzLmhhbmRsZUh1ZVNjb3BlS2V5RG93biwgcmVmOiB0aGlzLnN0b3JlSHVlU2NvcGUsIHJvbGU6IFwic2xpZGVyXCIsIHN0eWxlOiB7IHRvcDogYCR7aHVlVG9wfXB4YCwgbGVmdDogYCR7aHVlTGVmdH1weGAgfSwgdGFiaW5kZXg6IFwiMFwiIH0pKSwgaGlkZUhleCAmJiBoaWRlQ2hhbm5lbHMgPyBudWxsIDogKGgoXCJkaXZcIiwgeyBjbGFzczoge1xuICAgICAgICBbQ1NTLmNvbnRyb2xTZWN0aW9uXTogdHJ1ZSxcbiAgICAgICAgW0NTUy5zZWN0aW9uXTogdHJ1ZVxuICAgICAgfSB9LCBoaWRlSGV4ID8gbnVsbCA6IChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5oZXhPcHRpb25zIH0sIGgoXCJzcGFuXCIsIHsgY2xhc3M6IHtcbiAgICAgICAgW0NTUy5oZWFkZXJdOiB0cnVlLFxuICAgICAgICBbQ1NTLmhlYWRlckhleF06IHRydWVcbiAgICAgIH0gfSwgbWVzc2FnZXMuaGV4KSwgaChcImNhbGNpdGUtY29sb3ItcGlja2VyLWhleC1pbnB1dFwiLCB7IGFsbG93RW1wdHk6IGFsbG93RW1wdHksIGNsYXNzOiBDU1MuY29udHJvbCwgaGV4TGFiZWw6IG1lc3NhZ2VzLmhleCwgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLm51bWJlcmluZ1N5c3RlbSwgb25DYWxjaXRlQ29sb3JQaWNrZXJIZXhJbnB1dENoYW5nZTogdGhpcy5oYW5kbGVIZXhJbnB1dENoYW5nZSwgc2NhbGU6IGhleElucHV0U2NhbGUsIHZhbHVlOiBzZWxlY3RlZENvbG9ySW5IZXggfSkpKSwgaGlkZUNoYW5uZWxzID8gbnVsbCA6IChoKFwiY2FsY2l0ZS10YWJzXCIsIHsgY2xhc3M6IHtcbiAgICAgICAgW0NTUy5jb2xvck1vZGVDb250YWluZXJdOiB0cnVlLFxuICAgICAgICBbQ1NTLnNwbGl0U2VjdGlvbl06IHRydWVcbiAgICAgIH0sIHNjYWxlOiBoZXhJbnB1dFNjYWxlIH0sIGgoXCJjYWxjaXRlLXRhYi1uYXZcIiwgeyBzbG90OiBcInRpdGxlLWdyb3VwXCIgfSwgdGhpcy5yZW5kZXJDaGFubmVsc1RhYlRpdGxlKFwicmdiXCIpLCB0aGlzLnJlbmRlckNoYW5uZWxzVGFiVGl0bGUoXCJoc3ZcIikpLCB0aGlzLnJlbmRlckNoYW5uZWxzVGFiKFwicmdiXCIpLCB0aGlzLnJlbmRlckNoYW5uZWxzVGFiKFwiaHN2XCIpKSkpKSwgaGlkZVNhdmVkID8gbnVsbCA6IChoKFwiZGl2XCIsIHsgY2xhc3M6IHsgW0NTUy5zYXZlZENvbG9yc1NlY3Rpb25dOiB0cnVlLCBbQ1NTLnNlY3Rpb25dOiB0cnVlIH0gfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuaGVhZGVyIH0sIGgoXCJsYWJlbFwiLCBudWxsLCBtZXNzYWdlcy5zYXZlZCksIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLnNhdmVkQ29sb3JzQnV0dG9ucyB9LCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIGNsYXNzOiBDU1MuZGVsZXRlQ29sb3IsIGRpc2FibGVkOiBub0NvbG9yLCBpY29uU3RhcnQ6IFwibWludXNcIiwga2luZDogXCJuZXV0cmFsXCIsIGxhYmVsOiBtZXNzYWdlcy5kZWxldGVDb2xvciwgb25DbGljazogdGhpcy5kZWxldGVDb2xvciwgc2NhbGU6IGhleElucHV0U2NhbGUsIHR5cGU6IFwiYnV0dG9uXCIgfSksIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgY2xhc3M6IENTUy5zYXZlQ29sb3IsIGRpc2FibGVkOiBub0NvbG9yLCBpY29uU3RhcnQ6IFwicGx1c1wiLCBraW5kOiBcIm5ldXRyYWxcIiwgbGFiZWw6IG1lc3NhZ2VzLnNhdmVDb2xvciwgb25DbGljazogdGhpcy5zYXZlQ29sb3IsIHNjYWxlOiBoZXhJbnB1dFNjYWxlLCB0eXBlOiBcImJ1dHRvblwiIH0pKSksIHNhdmVkQ29sb3JzLmxlbmd0aCA+IDAgPyAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1Muc2F2ZWRDb2xvcnMgfSwgW1xuICAgICAgLi4uc2F2ZWRDb2xvcnMubWFwKChjb2xvcikgPT4gKGgoXCJjYWxjaXRlLWNvbG9yLXBpY2tlci1zd2F0Y2hcIiwgeyBhY3RpdmU6IHNlbGVjdGVkQ29sb3JJbkhleCA9PT0gY29sb3IsIGNsYXNzOiBDU1Muc2F2ZWRDb2xvciwgY29sb3I6IGNvbG9yLCBrZXk6IGNvbG9yLCBvbkNsaWNrOiB0aGlzLmhhbmRsZVNhdmVkQ29sb3JTZWxlY3QsIG9uS2V5RG93bjogdGhpcy5oYW5kbGVTYXZlZENvbG9yS2V5RG93biwgc2NhbGU6IHNjYWxlLCB0YWJJbmRleDogMCB9KSkpXG4gICAgXSkpIDogbnVsbCkpKSk7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIHNob3dJbmNvbXBhdGlibGVDb2xvcldhcm5pbmcodmFsdWUsIGZvcm1hdCkge1xuICAgIGNvbnNvbGUud2FybihgaWdub3JpbmcgY29sb3IgdmFsdWUgKCR7dmFsdWV9KSBhcyBpdCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdCAoJHtmb3JtYXR9KWApO1xuICB9XG4gIHNldE1vZGUoZm9ybWF0KSB7XG4gICAgdGhpcy5tb2RlID0gZm9ybWF0ID09PSBcImF1dG9cIiA/IHRoaXMubW9kZSA6IGZvcm1hdDtcbiAgfVxuICBjYXB0dXJlSHVlU2xpZGVyQ29sb3IoeCkge1xuICAgIGNvbnN0IHsgZGltZW5zaW9uczogeyBzbGlkZXI6IHsgd2lkdGggfSB9IH0gPSB0aGlzO1xuICAgIGNvbnN0IGh1ZSA9ICgzNjAgLyB3aWR0aCkgKiB4O1xuICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldCh0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuaHVlKGh1ZSksIGZhbHNlKTtcbiAgfVxuICBnZXRDYW52YXNSZWdpb24oeSkge1xuICAgIGNvbnN0IHsgZGltZW5zaW9uczogeyBjb2xvckZpZWxkOiB7IGhlaWdodDogY29sb3JGaWVsZEhlaWdodCB9LCBzbGlkZXI6IHsgaGVpZ2h0OiBzbGlkZXJIZWlnaHQgfSB9IH0gPSB0aGlzO1xuICAgIGlmICh5IDw9IGNvbG9yRmllbGRIZWlnaHQpIHtcbiAgICAgIHJldHVybiBcImNvbG9yLWZpZWxkXCI7XG4gICAgfVxuICAgIGlmICh5IDw9IGNvbG9yRmllbGRIZWlnaHQgKyBzbGlkZXJIZWlnaHQpIHtcbiAgICAgIHJldHVybiBcInNsaWRlclwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgaW50ZXJuYWxDb2xvclNldChjb2xvciwgc2tpcEVxdWFsID0gdHJ1ZSwgY29udGV4dCA9IFwidXNlci1pbnRlcmFjdGlvblwiKSB7XG4gICAgaWYgKHNraXBFcXVhbCAmJiBjb2xvckVxdWFsKGNvbG9yLCB0aGlzLmNvbG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmludGVybmFsQ29sb3JVcGRhdGVDb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMudG9WYWx1ZShjb2xvcik7XG4gICAgdGhpcy5pbnRlcm5hbENvbG9yVXBkYXRlQ29udGV4dCA9IG51bGw7XG4gIH1cbiAgdG9WYWx1ZShjb2xvciwgZm9ybWF0ID0gdGhpcy5tb2RlKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGhleE1vZGUgPSBcImhleFwiO1xuICAgIGlmIChmb3JtYXQuaW5jbHVkZXMoaGV4TW9kZSkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVIZXgoY29sb3Iucm91bmQoKVtoZXhNb2RlXSgpKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdC5pbmNsdWRlcyhcIi1jc3NcIikpIHtcbiAgICAgIHJldHVybiBjb2xvcltmb3JtYXQucmVwbGFjZShcIi1jc3NcIiwgXCJcIikucmVwbGFjZShcImFcIiwgXCJcIildKCkucm91bmQoKS5zdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgY29sb3JPYmplY3QgPSBjb2xvcltmb3JtYXRdKCkucm91bmQoKS5vYmplY3QoKTtcbiAgICBpZiAoZm9ybWF0LmVuZHNXaXRoKFwiYVwiKSkge1xuICAgICAgLy8gbm9ybWFsaXplIGFscGhhIHByb3BcbiAgICAgIGNvbG9yT2JqZWN0LmEgPSBjb2xvck9iamVjdC5hbHBoYTtcbiAgICAgIGRlbGV0ZSBjb2xvck9iamVjdC5hbHBoYTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yT2JqZWN0O1xuICB9XG4gIGdldFNsaWRlckNhcFNwYWNpbmcoKSB7XG4gICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IHNsaWRlcjogeyBoZWlnaHQgfSwgdGh1bWI6IHsgcmFkaXVzIH0gfSB9ID0gdGhpcztcbiAgICByZXR1cm4gcmFkaXVzICogMiAtIGhlaWdodDtcbiAgfVxuICB1cGRhdGVEaW1lbnNpb25zKHNjYWxlID0gXCJtXCIpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBESU1FTlNJT05TW3NjYWxlXTtcbiAgfVxuICBkcmF3Q29sb3JGaWVsZCgpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5maWVsZEFuZFNsaWRlclJlbmRlcmluZ0NvbnRleHQ7XG4gICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IGNvbG9yRmllbGQ6IHsgaGVpZ2h0LCB3aWR0aCB9IH0gfSA9IHRoaXM7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuaHN2KCkuc2F0dXJhdGlvbnYoMTAwKS52YWx1ZSgxMDApLnN0cmluZygpO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3Qgd2hpdGVHcmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIDApO1xuICAgIHdoaXRlR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFwicmdiYSgyNTUsMjU1LDI1NSwxKVwiKTtcbiAgICB3aGl0ZUdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBcInJnYmEoMjU1LDI1NSwyNTUsMClcIik7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSB3aGl0ZUdyYWRpZW50O1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgYmxhY2tHcmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgaGVpZ2h0KTtcbiAgICBibGFja0dyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBcInJnYmEoMCwwLDAsMClcIik7XG4gICAgYmxhY2tHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCJyZ2JhKDAsMCwwLDEpXCIpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYmxhY2tHcmFkaWVudDtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUNvbG9yRmllbGRDb2xvcigpO1xuICB9XG4gIHNldENhbnZhc0NvbnRleHRTaXplKGNhbnZhcywgeyBoZWlnaHQsIHdpZHRoIH0pIHtcbiAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIGRldmljZVBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRldmljZVBpeGVsUmF0aW87XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGNvbnRleHQuc2NhbGUoZGV2aWNlUGl4ZWxSYXRpbywgZGV2aWNlUGl4ZWxSYXRpbyk7XG4gIH1cbiAgdXBkYXRlQ2FudmFzU2l6ZShjYW52YXMpIHtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldENhbnZhc0NvbnRleHRTaXplKGNhbnZhcywge1xuICAgICAgd2lkdGg6IHRoaXMuZGltZW5zaW9ucy5jb2xvckZpZWxkLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmRpbWVuc2lvbnMuY29sb3JGaWVsZC5oZWlnaHQgK1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMuc2xpZGVyLmhlaWdodCArXG4gICAgICAgIHRoaXMuZ2V0U2xpZGVyQ2FwU3BhY2luZygpICogMlxuICAgIH0pO1xuICAgIHRoaXMuZHJhd0NvbG9yRmllbGRBbmRTbGlkZXIoKTtcbiAgfVxuICBjb250YWluc1BvaW50KHRlc3RQb2ludFgsIHRlc3RQb2ludFksIGJvdW5kc1gsIGJvdW5kc1ksIGJvdW5kc1JhZGl1cykge1xuICAgIHJldHVybiAoTWF0aC5wb3codGVzdFBvaW50WCAtIGJvdW5kc1gsIDIpICsgTWF0aC5wb3codGVzdFBvaW50WSAtIGJvdW5kc1ksIDIpIDw9XG4gICAgICBNYXRoLnBvdyhib3VuZHNSYWRpdXMsIDIpKTtcbiAgfVxuICBkcmF3QWN0aXZlQ29sb3JGaWVsZENvbG9yKCkge1xuICAgIGNvbnN0IHsgY29sb3IgfSA9IHRoaXM7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoc3ZDb2xvciA9IGNvbG9yLmhzdigpO1xuICAgIGNvbnN0IHsgZGltZW5zaW9uczogeyBjb2xvckZpZWxkOiB7IGhlaWdodCwgd2lkdGggfSwgdGh1bWI6IHsgcmFkaXVzIH0gfSB9ID0gdGhpcztcbiAgICBjb25zdCB4ID0gaHN2Q29sb3Iuc2F0dXJhdGlvbnYoKSAvIChIU1ZfTElNSVRTLnMgLyB3aWR0aCk7XG4gICAgY29uc3QgeSA9IGhlaWdodCAtIGhzdkNvbG9yLnZhbHVlKCkgLyAoSFNWX0xJTUlUUy52IC8gaGVpZ2h0KTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5jb2xvckZpZWxkU2NvcGVMZWZ0ID0geDtcbiAgICAgIHRoaXMuY29sb3JGaWVsZFNjb3BlVG9wID0geTtcbiAgICB9KTtcbiAgICB0aGlzLmRyYXdUaHVtYih0aGlzLmZpZWxkQW5kU2xpZGVyUmVuZGVyaW5nQ29udGV4dCwgcmFkaXVzLCB4LCB5LCBoc3ZDb2xvciwgdGhpcy5odWVUaHVtYlN0YXRlKTtcbiAgfVxuICBkcmF3VGh1bWIoY29udGV4dCwgcmFkaXVzLCB4LCB5LCBjb2xvciwgc3RhdGUpIHtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gMDtcbiAgICBjb25zdCBlbmRBbmdsZSA9IDIgKiBNYXRoLlBJO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgY29udGV4dC5zaGFkb3dCbHVyID0gc3RhdGUgPT09IFwiaG92ZXJcIiA/IDMyIDogMTY7XG4gICAgY29udGV4dC5zaGFkb3dDb2xvciA9IGByZ2JhKDAsIDAsIDAsICR7c3RhdGUgPT09IFwiZHJhZ1wiID8gMC4zMiA6IDAuMTZ9KWA7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNmZmZcIjtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cyAtIDMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvci5yZ2IoKS5zdHJpbmcoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuICBkcmF3QWN0aXZlSHVlU2xpZGVyQ29sb3IoKSB7XG4gICAgY29uc3QgeyBjb2xvciB9ID0gdGhpcztcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhzdkNvbG9yID0gY29sb3IuaHN2KCkuc2F0dXJhdGlvbnYoMTAwKS52YWx1ZSgxMDApO1xuICAgIGNvbnN0IHsgZGltZW5zaW9uczogeyBjb2xvckZpZWxkOiB7IGhlaWdodDogY29sb3JGaWVsZEhlaWdodCB9LCBzbGlkZXI6IHsgaGVpZ2h0LCB3aWR0aCB9LCB0aHVtYjogeyByYWRpdXMgfSB9IH0gPSB0aGlzO1xuICAgIGNvbnN0IHggPSBoc3ZDb2xvci5odWUoKSAvICgzNjAgLyB3aWR0aCk7XG4gICAgY29uc3QgeSA9IGhlaWdodCAvIDIgKyBjb2xvckZpZWxkSGVpZ2h0O1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmh1ZVNjb3BlTGVmdCA9IHg7XG4gICAgICB0aGlzLmh1ZVNjb3BlVG9wID0geTtcbiAgICB9KTtcbiAgICB0aGlzLmRyYXdUaHVtYih0aGlzLmZpZWxkQW5kU2xpZGVyUmVuZGVyaW5nQ29udGV4dCwgcmFkaXVzLCB4LCB5LCBoc3ZDb2xvciwgdGhpcy5zbGlkZXJUaHVtYlN0YXRlKTtcbiAgfVxuICBkcmF3SHVlU2xpZGVyKCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmZpZWxkQW5kU2xpZGVyUmVuZGVyaW5nQ29udGV4dDtcbiAgICBjb25zdCB7IGRpbWVuc2lvbnM6IHsgY29sb3JGaWVsZDogeyBoZWlnaHQ6IGNvbG9yRmllbGRIZWlnaHQgfSwgc2xpZGVyOiB7IGhlaWdodCwgd2lkdGggfSB9IH0gPSB0aGlzO1xuICAgIGNvbnN0IGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgY29uc3QgaHVlU2xpZGVyQ29sb3JTdG9wS2V5d29yZHMgPSBbXCJyZWRcIiwgXCJ5ZWxsb3dcIiwgXCJsaW1lXCIsIFwiY3lhblwiLCBcImJsdWVcIiwgXCJtYWdlbnRhXCIsIFwicmVkXCJdO1xuICAgIGNvbnN0IG9mZnNldCA9IDEgLyAoaHVlU2xpZGVyQ29sb3JTdG9wS2V5d29yZHMubGVuZ3RoIC0gMSk7XG4gICAgbGV0IGN1cnJlbnRPZmZzZXQgPSAwO1xuICAgIGh1ZVNsaWRlckNvbG9yU3RvcEtleXdvcmRzLmZvckVhY2goKGtleXdvcmQpID0+IHtcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChjdXJyZW50T2Zmc2V0LCBjb2xvcihrZXl3b3JkKS5zdHJpbmcoKSk7XG4gICAgICBjdXJyZW50T2Zmc2V0ICs9IG9mZnNldDtcbiAgICB9KTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIGNvbG9yRmllbGRIZWlnaHQsIHdpZHRoLCBoZWlnaHQgKyB0aGlzLmdldFNsaWRlckNhcFNwYWNpbmcoKSAqIDIpO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgY29sb3JGaWVsZEhlaWdodCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kcmF3QWN0aXZlSHVlU2xpZGVyQ29sb3IoKTtcbiAgfVxuICB1cGRhdGVDb2xvckZyb21DaGFubmVscyhjaGFubmVscykge1xuICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChjb2xvcihjaGFubmVscywgdGhpcy5jaGFubmVsTW9kZSkpO1xuICB9XG4gIHVwZGF0ZUNoYW5uZWxzRnJvbUNvbG9yKGNvbG9yKSB7XG4gICAgdGhpcy5jaGFubmVscyA9IGNvbG9yID8gdGhpcy50b0NoYW5uZWxzKGNvbG9yKSA6IFtudWxsLCBudWxsLCBudWxsXTtcbiAgfVxuICB0b0NoYW5uZWxzKGNvbG9yKSB7XG4gICAgY29uc3QgeyBjaGFubmVsTW9kZSB9ID0gdGhpcztcbiAgICByZXR1cm4gY29sb3JbY2hhbm5lbE1vZGVdKClcbiAgICAgIC5hcnJheSgpXG4gICAgICAubWFwKCh2YWx1ZSkgPT4gTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVsZWdhdGVzRm9jdXMoKSB7IHJldHVybiB0cnVlOyB9XG4gIHN0YXRpYyBnZXQgYXNzZXRzRGlycygpIHsgcmV0dXJuIFtcImFzc2V0c1wiXTsgfVxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJjb2xvclwiOiBbXCJoYW5kbGVDb2xvckNoYW5nZVwiXSxcbiAgICBcImZvcm1hdFwiOiBbXCJoYW5kbGVGb3JtYXRDaGFuZ2VcIl0sXG4gICAgXCJzY2FsZVwiOiBbXCJoYW5kbGVTY2FsZUNoYW5nZVwiXSxcbiAgICBcIm1lc3NhZ2VPdmVycmlkZXNcIjogW1wib25NZXNzYWdlc0NoYW5nZVwiXSxcbiAgICBcInZhbHVlXCI6IFtcImhhbmRsZVZhbHVlQ2hhbmdlXCJdLFxuICAgIFwiZWZmZWN0aXZlTG9jYWxlXCI6IFtcImVmZmVjdGl2ZUxvY2FsZUNoYW5nZVwiXVxuICB9OyB9XG59O1xuQ29sb3JQaWNrZXIuc3R5bGUgPSBjb2xvclBpY2tlckNzcztcblxuZXhwb3J0IHsgQ29sb3JQaWNrZXIgYXMgY2FsY2l0ZV9jb2xvcl9waWNrZXIgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsY2l0ZS1jb2xvci1waWNrZXIuZW50cnkuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cbmZ1bmN0aW9uIG5vb3BDbGljaygpIHtcbiAgLyoqIG5vb3AgKi9cbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgdXBkYXRlcyB0aGUgaG9zdCBlbGVtZW50IHRvIHByZXZlbnQga2V5Ym9hcmQgaW50ZXJhY3Rpb24gb24gaXRzIHN1YnRyZWUgYW5kIHNldHMgdGhlIGFwcHJvcHJpYXRlIGFyaWEgYXR0cmlidXRlIGZvciBhY2Nlc3NpYmlsaXR5LlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIGBjb21wb25lbnREaWRSZW5kZXJgIGxpZmVjeWNsZSBob29rLlxuICpcbiAqICoqTm90ZXMqKlxuICpcbiAqIHRoaXMgdXRpbCBpcyBub3QgbmVlZGVkIGZvciBzaW1wbGUgY29tcG9uZW50cyB3aG9zZSByb290IGVsZW1lbnQgb3IgZWxlbWVudHMgYXJlIGFuIGludGVyYWN0aXZlIGNvbXBvbmVudCAoY3VzdG9tIGVsZW1lbnQgb3IgbmF0aXZlIGNvbnRyb2wpLiBGb3IgdGhvc2UgY2FzZXMsIHNldCB0aGUgYGRpc2FibGVkYCBwcm9wcyBvbiB0aGUgcm9vdCBjb21wb25lbnRzIGluc3RlYWQuXG4gKiB0ZWNobmljYWxseSwgdXNlcnMgY2FuIG92ZXJyaWRlIGB0YWJpbmRleGAgYW5kIHJlc3RvcmUga2V5Ym9hcmQgbmF2aWdhdGlvbiwgYnV0IHRoaXMgd2lsbCBiZSBjb25zaWRlcmVkIHVzZXIgZXJyb3JcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKiBAcGFyYW0gaG9zdElzVGFiYmFibGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlSG9zdEludGVyYWN0aW9uKGNvbXBvbmVudCwgaG9zdElzVGFiYmFibGUgPSBmYWxzZSkge1xuICBpZiAoY29tcG9uZW50LmRpc2FibGVkKSB7XG4gICAgY29tcG9uZW50LmVsLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIik7XG4gICAgY29tcG9uZW50LmVsLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIpO1xuICAgIGlmIChjb21wb25lbnQuZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgICBjb21wb25lbnQuZWwuY2xpY2sgPSBub29wQ2xpY2s7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXBvbmVudC5lbC5jbGljayA9IEhUTUxFbGVtZW50LnByb3RvdHlwZS5jbGljaztcbiAgaWYgKHR5cGVvZiBob3N0SXNUYWJiYWJsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29tcG9uZW50LmVsLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIGhvc3RJc1RhYmJhYmxlLmNhbGwoY29tcG9uZW50KSA/IFwiMFwiIDogXCItMVwiKTtcbiAgfVxuICBlbHNlIGlmIChob3N0SXNUYWJiYWJsZSA9PT0gdHJ1ZSkge1xuICAgIGNvbXBvbmVudC5lbC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gIH1cbiAgZWxzZSBpZiAoaG9zdElzVGFiYmFibGUgPT09IGZhbHNlKSB7XG4gICAgY29tcG9uZW50LmVsLnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpO1xuICB9XG4gIGVsc2UgO1xuICBjb21wb25lbnQuZWwucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiKTtcbn1cblxuZXhwb3J0IHsgdXBkYXRlSG9zdEludGVyYWN0aW9uIGFzIHUgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJhY3RpdmUtMjk5OTU1MjIuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cbmNvbnN0IHJlc29sdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcHJvbWlzZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFRoaXMgaGVscGVyIHV0aWwgc2V0cyB1cCB0aGUgY29tcG9uZW50IGZvciB0aGUgYWJpbGl0eSB0byBrbm93IHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBsb2FkZWQuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgdXNlZCBpbiB0aGUgYGNvbXBvbmVudFdpbGxMb2FkYCBsaWZlY3ljbGUgaG9vay5cbiAqXG4gKiBgYGBcbiAqIGNvbXBvbmVudFdpbGxMb2FkKCk6IHZvaWQge1xuICogICBzZXRVcExvYWRhYmxlQ29tcG9uZW50KHRoaXMpO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBzZXRVcExvYWRhYmxlQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICBwcm9taXNlTWFwLnNldChjb21wb25lbnQsIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlTWFwLnNldChjb21wb25lbnQsIHJlc29sdmUpKSk7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHV0aWwgbGV0cyB0aGUgbG9hZGFibGUgY29tcG9uZW50IGtub3cgdGhhdCBpdCBpcyBub3cgbG9hZGVkLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIGBjb21wb25lbnREaWRMb2FkYCBsaWZlY3ljbGUgaG9vay5cbiAqXG4gKiBgYGBcbiAqIGNvbXBvbmVudERpZExvYWQoKTogdm9pZCB7XG4gKiAgIHNldENvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gc2V0Q29tcG9uZW50TG9hZGVkKGNvbXBvbmVudCkge1xuICByZXNvbHZlTWFwLmdldChjb21wb25lbnQpKCk7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHV0aWwgY2FuIGJlIHVzZWQgdG8gZW5zdXJlIGEgY29tcG9uZW50IGhhcyBiZWVuIGxvYWRlZCAoVGhlIFwiY29tcG9uZW50RGlkTG9hZFwiIHN0ZW5jaWwgbGlmZWN5Y2xlIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQpLlxuICpcbiAqIFJlcXVpcmVzIFwic2V0VXBMb2FkYWJsZUNvbXBvbmVudFwiIGFuZCBcInNldENvbXBvbmVudExvYWRlZFwiIHRvIGJlIGNhbGxlZCBmaXJzdC5cbiAqXG4gKiBBIGNvbXBvbmVudCBkZXZlbG9wZXIgY2FuIGF3YWl0IHRoaXMgbWV0aG9kIGJlZm9yZSBwcm9jZWVkaW5nIHdpdGggYW55IGxvZ2ljIHRoYXQgcmVxdWlyZXMgYSBjb21wb25lbnQgdG8gYmUgbG9hZGVkIGZpcnN0LlxuICpcbiAqIGBgYFxuICogYXN5bmMgc2V0Rm9jdXMoKTogUHJvbWlzZTx2b2lkPiB7XG4gKiAgIGF3YWl0IGNvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqIEByZXR1cm5zIFByb21pc2U8dm9pZD5cbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50TG9hZGVkKGNvbXBvbmVudCkge1xuICByZXR1cm4gcHJvbWlzZU1hcC5nZXQoY29tcG9uZW50KTtcbn1cblxuZXhwb3J0IHsgc2V0VXBMb2FkYWJsZUNvbXBvbmVudCBhcyBhLCBjb21wb25lbnRMb2FkZWQgYXMgYywgc2V0Q29tcG9uZW50TG9hZGVkIGFzIHMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGFibGUtY2MxNGQ3MjguanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cbmNvbnN0IGNsYW1wID0gKHZhbHVlLCBtaW4sIG1heCkgPT4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG5jb25zdCBkZWNpbWFsUGxhY2VzID0gKHZhbHVlKSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gKFwiXCIgKyB2YWx1ZSkubWF0Y2goLyg/OlxcLihcXGQrKSk/KD86W2VFXShbKy1dP1xcZCspKT8kLyk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoMCwgXG4gIC8vIE51bWJlciBvZiBkaWdpdHMgcmlnaHQgb2YgZGVjaW1hbCBwb2ludC5cbiAgKG1hdGNoWzFdID8gbWF0Y2hbMV0ubGVuZ3RoIDogMCkgLVxuICAgIC8vIEFkanVzdCBmb3Igc2NpZW50aWZpYyBub3RhdGlvbi5cbiAgICAobWF0Y2hbMl0gPyArbWF0Y2hbMl0gOiAwKSk7XG59O1xuXG5leHBvcnQgeyBjbGFtcCBhcyBjLCBkZWNpbWFsUGxhY2VzIGFzIGQgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC03ZWZkOTg3YS5qcy5tYXAiLCJpbXBvcnQgeyBhIGFzIGdldEFzc2V0UGF0aCB9IGZyb20gJy4vaW5kZXgtNGU2NDc0MTEuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRTdXBwb3J0ZWRMb2NhbGUgfSBmcm9tICcuL2xvY2FsZS03MDZkZjRjNy5qcyc7XG5cbi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjAuNVxuICovXG5jb25zdCBjb21wb25lbnRMYW5nVG9NZXNzYWdlQnVuZGxlQ2FjaGUgPSB7fTtcbmFzeW5jIGZ1bmN0aW9uIGdldE1lc3NhZ2VCdW5kbGUobGFuZywgY29tcG9uZW50KSB7XG4gIGNvbnN0IGtleSA9IGAke2NvbXBvbmVudH1fJHtsYW5nfWA7XG4gIGlmIChjb21wb25lbnRMYW5nVG9NZXNzYWdlQnVuZGxlQ2FjaGVba2V5XSkge1xuICAgIHJldHVybiBjb21wb25lbnRMYW5nVG9NZXNzYWdlQnVuZGxlQ2FjaGVba2V5XTtcbiAgfVxuICBjb21wb25lbnRMYW5nVG9NZXNzYWdlQnVuZGxlQ2FjaGVba2V5XSA9IGZldGNoKGdldEFzc2V0UGF0aChgLi9hc3NldHMvJHtjb21wb25lbnR9L3Q5bi9tZXNzYWdlc18ke2xhbmd9Lmpzb25gKSlcbiAgICAudGhlbigocmVzcCkgPT4ge1xuICAgIGlmICghcmVzcC5vaykge1xuICAgICAgdGhyb3dNZXNzYWdlRmV0Y2hFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcC5qc29uKCk7XG4gIH0pXG4gICAgLmNhdGNoKCgpID0+IHRocm93TWVzc2FnZUZldGNoRXJyb3IoKSk7XG4gIHJldHVybiBjb21wb25lbnRMYW5nVG9NZXNzYWdlQnVuZGxlQ2FjaGVba2V5XTtcbn1cbmZ1bmN0aW9uIHRocm93TWVzc2FnZUZldGNoRXJyb3IoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBmZXRjaCBjb21wb25lbnQgbWVzc2FnZSBidW5kbGVcIik7XG59XG5mdW5jdGlvbiBtZXJnZU1lc3NhZ2VzKGNvbXBvbmVudCkge1xuICBjb21wb25lbnQubWVzc2FnZXMgPSB7XG4gICAgLi4uY29tcG9uZW50LmRlZmF1bHRNZXNzYWdlcyxcbiAgICAuLi5jb21wb25lbnQubWVzc2FnZU92ZXJyaWRlc1xuICB9O1xufVxuLyoqXG4gKiBUaGlzIHV0aWxpdHkgc2V0cyB1cCB0aGUgbWVzc2FnZXMgdXNlZCBieSB0aGUgY29tcG9uZW50LiBJdCBzaG91bGQgYmUgYXdhaXRlZCBpbiB0aGUgYGNvbXBvbmVudFdpbGxMb2FkYCBsaWZlY3ljbGUgaG9vay5cbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNldFVwTWVzc2FnZXMoY29tcG9uZW50KSB7XG4gIGNvbXBvbmVudC5kZWZhdWx0TWVzc2FnZXMgPSBhd2FpdCBmZXRjaE1lc3NhZ2VzKGNvbXBvbmVudCwgY29tcG9uZW50LmVmZmVjdGl2ZUxvY2FsZSk7XG4gIG1lcmdlTWVzc2FnZXMoY29tcG9uZW50KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoTWVzc2FnZXMoY29tcG9uZW50LCBsYW5nKSB7XG4gIGNvbnN0IHsgZWwgfSA9IGNvbXBvbmVudDtcbiAgY29uc3QgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBjb21wb25lbnROYW1lID0gdGFnLnJlcGxhY2UoXCJjYWxjaXRlLVwiLCBcIlwiKTtcbiAgcmV0dXJuIGdldE1lc3NhZ2VCdW5kbGUoZ2V0U3VwcG9ydGVkTG9jYWxlKGxhbmcsIFwidDluXCIpLCBjb21wb25lbnROYW1lKTtcbn1cbi8qKlxuICogVGhpcyB1dGlsaXR5IG11c3QgYmUgc2V0IHVwIGZvciB0aGUgY29tcG9uZW50IHRvIHVwZGF0ZSBpdHMgZGVmYXVsdCBtZXNzYWdlIGJ1bmRsZSBpZiB0aGUgbG9jYWxlIGNoYW5nZXMuXG4gKlxuICogSXQgY2FuIGJlIHNldCB1cCBpbiAqKmVpdGhlcioqIG9mIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAxLiBjYWxsZWQgZnJvbSBgTG9jYWxpemVkQ29tcG9uZW50YCdzIGBvbkxvY2FsZUNoYW5nZWAgbWV0aG9kIG9yXG4gKiAyLiBjYWxsZWQgZnJvbSBhIHdhdGNoZXIgY29uZmlndXJlZCB0byB3YXRjaCBgTG9jYWxpemVkQ29tcG9uZW50YCdzIGBlZmZlY3RpdmVMb2NhbGVgIHByb3BcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKiBAcGFyYW0gbGFuZ1xuICovXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVNZXNzYWdlcyhjb21wb25lbnQsIGxhbmcpIHtcbiAgY29tcG9uZW50LmRlZmF1bHRNZXNzYWdlcyA9IGF3YWl0IGZldGNoTWVzc2FnZXMoY29tcG9uZW50LCBsYW5nKTtcbiAgbWVyZ2VNZXNzYWdlcyhjb21wb25lbnQpO1xufVxuLyoqXG4gKiBUaGlzIHV0aWxpdHkgc2V0cyB1cCBpbnRlcm5hbHMgZm9yIG1lc3NhZ2VzIHN1cHBvcnQuXG4gKlxuICogSXQgbmVlZHMgdG8gYmUgY2FsbGVkIGluIGBjb25uZWN0ZWRDYWxsYmFja2BcbiAqXG4gKiAqKk5vdGUqKjogdGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBgTG9jYWxpemVkQ29tcG9uZW50YCdzIGBjb25uZWN0TG9jYWxpemVkYCBtZXRob2QuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBjb25uZWN0TWVzc2FnZXMoY29tcG9uZW50KSB7XG4gIGNvbXBvbmVudC5vbk1lc3NhZ2VzQ2hhbmdlID0gZGVmYXVsdE9uTWVzc2FnZXNDaGFuZ2U7XG59XG4vKipcbiAqIFRoaXMgdXRpbGl0eSB0ZWFycyBkb3duIGludGVybmFscyBmb3IgbWVzc2FnZXMgc3VwcG9ydC5cbiAqXG4gKiBJdCBuZWVkcyB0byBiZSBjYWxsZWQgaW4gYGRpc2Nvbm5lY3RlZENhbGxiYWNrYFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gZGlzY29ubmVjdE1lc3NhZ2VzKGNvbXBvbmVudCkge1xuICBjb21wb25lbnQub25NZXNzYWdlc0NoYW5nZSA9IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbk1lc3NhZ2VzQ2hhbmdlKCkge1xuICBtZXJnZU1lc3NhZ2VzKHRoaXMpO1xufVxuXG5leHBvcnQgeyBjb25uZWN0TWVzc2FnZXMgYXMgYywgZGlzY29ubmVjdE1lc3NhZ2VzIGFzIGQsIHNldFVwTWVzc2FnZXMgYXMgcywgdXBkYXRlTWVzc2FnZXMgYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10OW4tOTYwM2ZmMDUuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cbmZ1bmN0aW9uIHJnYlRvSGV4KGNvbG9yKSB7XG4gIGNvbnN0IHsgciwgZywgYiB9ID0gY29sb3I7XG4gIHJldHVybiBgIyR7ci50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpfSR7Zy50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpfSR7YlxuICAgIC50b1N0cmluZygxNilcbiAgICAucGFkU3RhcnQoMiwgXCIwXCIpfWAudG9Mb3dlckNhc2UoKTtcbn1cbmNvbnN0IGhleENoYXIgPSAvXlswLTlBLUZdJC9pO1xuY29uc3Qgc2hvcnRIYW5kSGV4ID0gL14jWzAtOUEtRl17M30kL2k7XG5jb25zdCBsb25naGFuZEhleCA9IC9eI1swLTlBLUZdezZ9JC9pO1xuZnVuY3Rpb24gaXNWYWxpZEhleChoZXgpIHtcbiAgcmV0dXJuIGlzU2hvcnRoYW5kSGV4KGhleCkgfHwgaXNMb25naGFuZEhleChoZXgpO1xufVxuZnVuY3Rpb24gaXNTaG9ydGhhbmRIZXgoaGV4KSB7XG4gIHJldHVybiBoZXggJiYgaGV4Lmxlbmd0aCA9PT0gNCAmJiBzaG9ydEhhbmRIZXgudGVzdChoZXgpO1xufVxuZnVuY3Rpb24gaXNMb25naGFuZEhleChoZXgpIHtcbiAgcmV0dXJuIGhleCAmJiBoZXgubGVuZ3RoID09PSA3ICYmIGxvbmdoYW5kSGV4LnRlc3QoaGV4KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhleChoZXgpIHtcbiAgaGV4ID0gaGV4LnRvTG93ZXJDYXNlKCk7XG4gIGlmICghaGV4LnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgaGV4ID0gYCMke2hleH1gO1xuICB9XG4gIGlmIChpc1Nob3J0aGFuZEhleChoZXgpKSB7XG4gICAgcmV0dXJuIHJnYlRvSGV4KGhleFRvUkdCKGhleCkpO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBoZXhUb1JHQihoZXgpIHtcbiAgaWYgKCFpc1ZhbGlkSGV4KGhleCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoZXggPSBoZXgucmVwbGFjZShcIiNcIiwgXCJcIik7XG4gIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgY29uc3QgW2ZpcnN0LCBzZWNvbmQsIHRoaXJkXSA9IGhleC5zcGxpdChcIlwiKTtcbiAgICBjb25zdCByID0gcGFyc2VJbnQoYCR7Zmlyc3R9JHtmaXJzdH1gLCAxNik7XG4gICAgY29uc3QgZyA9IHBhcnNlSW50KGAke3NlY29uZH0ke3NlY29uZH1gLCAxNik7XG4gICAgY29uc3QgYiA9IHBhcnNlSW50KGAke3RoaXJkfSR7dGhpcmR9YCwgMTYpO1xuICAgIHJldHVybiB7IHIsIGcsIGIgfTtcbiAgfVxuICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnNsaWNlKDAsIDIpLCAxNik7XG4gIGNvbnN0IGcgPSBwYXJzZUludChoZXguc2xpY2UoMiwgNCksIDE2KTtcbiAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zbGljZSg0LCA2KSwgMTYpO1xuICByZXR1cm4geyByLCBnLCBiIH07XG59XG4vLyB0aGVzZSB1dGlscyBhbGxvdyB1c2VycyB0byBwYXNzIGVudW0gdmFsdWVzIGFzIHN0cmluZ3Mgd2l0aG91dCBoYXZpbmcgdG8gYWNjZXNzIHRoZSBlbnVtXG4vLyBiYXNlZCBvbiB0aGUgYXBwcm9hY2ggc3VnZ2VzdGVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTc2OTAjaXNzdWVjb21tZW50LTMyMTM2NTc1OSxcbmNvbnN0IGVudW1pZnkgPSAoeCkgPT4geDtcbmNvbnN0IENTU0NvbG9yTW9kZSA9IGVudW1pZnkoe1xuICBIRVg6IFwiaGV4XCIsXG4gIEhFWEE6IFwiaGV4YVwiLFxuICBSR0JfQ1NTOiBcInJnYi1jc3NcIixcbiAgUkdCQV9DU1M6IFwicmdiYS1jc3NcIixcbiAgSFNMX0NTUzogXCJoc2wtY3NzXCIsXG4gIEhTTEFfQ1NTOiBcImhzbGEtY3NzXCJcbn0pO1xuY29uc3QgT2JqZWN0Q29sb3JNb2RlID0gZW51bWlmeSh7XG4gIFJHQjogXCJyZ2JcIixcbiAgUkdCQTogXCJyZ2JhXCIsXG4gIEhTTDogXCJoc2xcIixcbiAgSFNMQTogXCJoc2xhXCIsXG4gIEhTVjogXCJoc3ZcIixcbiAgSFNWQTogXCJoc3ZhXCJcbn0pO1xuZnVuY3Rpb24gcGFyc2VNb2RlKGNvbG9yVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBjb2xvclZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGNvbG9yVmFsdWUuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBjb2xvclZhbHVlO1xuICAgICAgaWYgKGxlbmd0aCA9PT0gNCB8fCBsZW5ndGggPT09IDcpIHtcbiAgICAgICAgcmV0dXJuIENTU0NvbG9yTW9kZS5IRVg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID09PSA1IHx8IGxlbmd0aCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gQ1NTQ29sb3JNb2RlLkhFWEE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2xvclZhbHVlLnN0YXJ0c1dpdGgoXCJyZ2JhKFwiKSkge1xuICAgICAgcmV0dXJuIENTU0NvbG9yTW9kZS5SR0JBX0NTUztcbiAgICB9XG4gICAgaWYgKGNvbG9yVmFsdWUuc3RhcnRzV2l0aChcInJnYihcIikpIHtcbiAgICAgIHJldHVybiBDU1NDb2xvck1vZGUuUkdCX0NTUztcbiAgICB9XG4gICAgaWYgKGNvbG9yVmFsdWUuc3RhcnRzV2l0aChcImhzbChcIikpIHtcbiAgICAgIHJldHVybiBDU1NDb2xvck1vZGUuSFNMX0NTUztcbiAgICB9XG4gICAgaWYgKGNvbG9yVmFsdWUuc3RhcnRzV2l0aChcImhzbGEoXCIpKSB7XG4gICAgICByZXR1cm4gQ1NTQ29sb3JNb2RlLkhTTEFfQ1NTO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGNvbG9yVmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoaGFzQ2hhbm5lbHMoY29sb3JWYWx1ZSwgXCJyXCIsIFwiZ1wiLCBcImJcIikpIHtcbiAgICAgIHJldHVybiBoYXNDaGFubmVscyhjb2xvclZhbHVlLCBcImFcIikgPyBPYmplY3RDb2xvck1vZGUuUkdCQSA6IE9iamVjdENvbG9yTW9kZS5SR0I7XG4gICAgfVxuICAgIGlmIChoYXNDaGFubmVscyhjb2xvclZhbHVlLCBcImhcIiwgXCJzXCIsIFwibFwiKSkge1xuICAgICAgcmV0dXJuIGhhc0NoYW5uZWxzKGNvbG9yVmFsdWUsIFwiYVwiKSA/IE9iamVjdENvbG9yTW9kZS5IU0xBIDogT2JqZWN0Q29sb3JNb2RlLkhTTDtcbiAgICB9XG4gICAgaWYgKGhhc0NoYW5uZWxzKGNvbG9yVmFsdWUsIFwiaFwiLCBcInNcIiwgXCJ2XCIpKSB7XG4gICAgICByZXR1cm4gaGFzQ2hhbm5lbHMoY29sb3JWYWx1ZSwgXCJhXCIpID8gT2JqZWN0Q29sb3JNb2RlLkhTVkEgOiBPYmplY3RDb2xvck1vZGUuSFNWO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGhhc0NoYW5uZWxzKGNvbG9yT2JqZWN0LCAuLi5jaGFubmVscykge1xuICByZXR1cm4gY2hhbm5lbHMuZXZlcnkoKGNoYW5uZWwpID0+IGNoYW5uZWwgJiYgY29sb3JPYmplY3QgJiYgYCR7Y2hhbm5lbH1gIGluIGNvbG9yT2JqZWN0KTtcbn1cbmZ1bmN0aW9uIGNvbG9yRXF1YWwodmFsdWUxLCB2YWx1ZTIpIHtcbiAgcmV0dXJuIHZhbHVlMT8ucmdiTnVtYmVyKCkgPT09IHZhbHVlMj8ucmdiTnVtYmVyKCk7XG59XG5cbmV4cG9ydCB7IENTU0NvbG9yTW9kZSBhcyBDLCBpc0xvbmdoYW5kSGV4IGFzIGEsIGhleENoYXIgYXMgYiwgY29sb3JFcXVhbCBhcyBjLCBoZXhUb1JHQiBhcyBoLCBpc1ZhbGlkSGV4IGFzIGksIG5vcm1hbGl6ZUhleCBhcyBuLCBwYXJzZU1vZGUgYXMgcCwgcmdiVG9IZXggYXMgciB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy1hNzFkOGVlOS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=