"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_index--d2baff"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-0a84b068.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-0a84b068.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getResourceIdentifier),
/* harmony export */   b: () => (/* binding */ cloudFileNames),
/* harmony export */   c: () => (/* binding */ cloudFileIcons),
/* harmony export */   d: () => (/* binding */ getCloudOption),
/* harmony export */   e: () => (/* binding */ getProviderOption),
/* harmony export */   f: () => (/* binding */ getDownloadUrl),
/* harmony export */   g: () => (/* binding */ getProvider),
/* harmony export */   h: () => (/* binding */ getOneDriveDownloadUrl),
/* harmony export */   i: () => (/* binding */ getDropBoxDownloadUrl)
/* harmony export */ });
/* harmony import */ var _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config-75adf962.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-75adf962.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


function externalRequest(method, contentUrl, body, authorization, contentType) {
    return new Promise((resolve, reject) => {
        const xhttp = new XMLHttpRequest();
        xhttp.open(method, contentUrl, false);
        if (authorization) {
            xhttp.setRequestHeader("Authorization", authorization);
        }
        if (contentType) {
            xhttp.setRequestHeader("Content-type", contentType);
        }
        if (body) {
            xhttp.send(body);
        }
        else {
            xhttp.send();
        }
        const response = JSON.parse(xhttp.responseText);
        //status more than 400 is error
        if (xhttp.status >= 400) {
            reject(JSON.parse(xhttp.responseText));
        }
        resolve(response);
    });
}
function getTokenFromUrl(url, name) {
    return new Promise((resolve, reject) => {
        name = name.replace(/[[]/, "[").replace(/[]]/, "]");
        const regexS = `[?&#]${name}=([^&#]*)`;
        const regex = new RegExp(regexS);
        const results = regex.exec(url);
        if (results == null) {
            reject("InvalidToken");
        }
        else {
            resolve(results[1]);
        }
    });
}
function oauthSignIn(url, portalHostName) {
    return new Promise((resolve, reject) => {
        const currentSourceUrl = `${window.location.protocol}//${window.location.hostname}`;
        const queryString = `?cloudUrl=${url}&currentSourceUrl=${currentSourceUrl}&portalHostName=${portalHostName}`;
        const source = `https://${portalHostName}/home/cloudDriveOauth-callback.html${queryString}`;
        const ifrm = document.createElement("iframe");
        ifrm.src = source;
        ifrm.className = "hide";
        document.body.appendChild(ifrm);
        const eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
        const eventer = window[eventMethod];
        const messageEvent = eventMethod === "attachEvent" ? "onmessage" : "message";
        // Listen to message from child window
        eventer(messageEvent, (e) => {
            if (e.origin !== `https://${portalHostName}`) {
                return;
            }
            if (e.data === "popupBlocked" || e.data === "windowClosed") {
                reject(e.data);
            }
            resolve(e.data);
        }, false);
    });
}
const cloudFileIcons = {
    csv: "file-csv",
    excel: "file-excel",
    zip: "file-zip",
    geojson: "file-code",
    sheet: "file-report",
    cad: "file-cad",
    gpx: "file-gpx",
    png: "file-image",
    jpg: "file-image",
    jpeg: "file-image",
    tiff: "file-image",
    gif: "file-image",
    pdf: "file-pdf",
    docx: "file-word"
};
const cloudFileNames = {
    csv: "CSV",
    excel: "Excel",
    zip: "Zip File",
    geojson: "GeoJSON",
    googlesheets: "Google Sheets",
    cad: "CAD",
    gpx: "GPX",
    png: "Image",
    jpg: "Image",
    jpeg: "Image",
    tiff: "Image",
    gif: "Image",
    pdf: "PDF",
    docx: "Microsoft Word",
    pptx: "Microsoft PowerPoint"
};
const cloudFileExtensions = {
    csv: ".csv",
    excel: ".xls",
    zip: ".zip",
    geojson: ".geojson",
    googlesheets: ""
};
function getMimeType(fileName) {
    const parts = fileName.split(".");
    const extension = parts[parts.length - 1].toLowerCase();
    const extensionLookup = {
        xls: "excel",
        xlsx: "excel",
        csv: "csv",
        zip: "zip",
        geojson: "geojson",
        json: "geojson"
    };
    return extensionLookup[extension] || extension;
}

function getDropBoxDownloadUrl(id, token) {
    return `https://content.dropboxapi.com/2/files/download?httpHeaders={"Authorization":"Bearer&#32;${token}","Dropbox-API-Arg":"{\\"path\\":\\"${id}\\"}"}`;
}
class Dropbox {
    constructor() {
        this.nextStart = 0;
    }
    async connect() {
        const { config, portal } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
        const stateValue = `dropbox${Math.floor(Date.now() / 1000)}`;
        const locale = document.documentElement.lang || "en-US";
        const dropboxOauthUrl = "https://www.dropbox.com/oauth2/authorize";
        const cloudStorageOAuthRedirectUri = `https://${portal.portalHostname}/home/cloudDriveOauth-callback2.html`;
        const url = `${dropboxOauthUrl}?redirect_uri=${cloudStorageOAuthRedirectUri}&response_type=token&client_id=${config.dropboxClientId}&locale=${locale}&state=${stateValue}`;
        return new Promise(async (resolve, reject) => {
            try {
                const signInUrl = await oauthSignIn(url, portal.portalHostname);
                const stateFromUrl = await getTokenFromUrl(signInUrl, "state");
                if (stateValue !== stateFromUrl) {
                    reject("invalidState");
                }
                const accessToken = await getTokenFromUrl(signInUrl, "access_token");
                this.token = accessToken;
                resolve(accessToken);
            }
            catch (e) {
                reject(e);
            }
        });
    }
    search(filterValues = {}) {
        const { token } = this;
        return new Promise(async (resolve) => {
            const { searchText, dropdownFilter, next } = filterValues;
            const authorization = `Bearer ${token}`;
            const contentType = "application/json";
            const contentUrl = "https://api.dropboxapi.com/2/files/search";
            const searchInput = searchText ? ` ${searchText}` : "";
            const start = next ? this.nextStart : 0;
            let typeQuery = cloudFileExtensions[dropdownFilter];
            if (dropdownFilter === "excel") {
                typeQuery = "xls";
            }
            const bodyDropboxRequest = `{"path":"","query":"${searchInput} ${typeQuery}","mode": "filename","max_results":10,"start":${start}}`;
            const result = await externalRequest("POST", contentUrl, bodyDropboxRequest, authorization, contentType);
            this.nextStart = result.start;
            const files = result.matches
                .filter((file) => { var _a; return ((_a = file.metadata) === null || _a === void 0 ? void 0 : _a[".tag"]) === "file"; })
                .map(({ metadata: { id, name, size } }) => ({
                id,
                name,
                mimeType: getMimeType(name),
                downloadUrl: `https://content.dropboxapi.com/2/files/download?httpHeaders={"Authorization":"Bearer&#32;${token}","Dropbox-API-Arg":"{\\"path\\":\\"${id}\\"}"}`,
                size
            }));
            resolve({ files, next: !!result.more });
        });
    }
}

/** Google returns an actual mimetype, not just a filename, so we can check and convert to our types */
function lookupMimeType(mimeType) {
    if (mimeType.indexOf("spreadsheetml.sheet") > -1 || mimeType.indexOf("ms-excel") > -1) {
        return "excel";
    }
    if (mimeType.indexOf("application/zip") > -1) {
        return "zip";
    }
    if (mimeType.indexOf("application/octet-stream") > -1 || mimeType.indexOf("application/json") > -1) {
        return "geojson";
    }
    if (mimeType.indexOf("google-apps.spreadsheet") > -1) {
        return "googlesheets";
    }
    if (mimeType.indexOf("text/csv") > -1) {
        return "csv";
    }
    return "zip";
}
const queries = {
    csv: '(mimeType="text/csv")',
    excel: '(mimeType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"ormimeType="application/vnd.ms-excel")',
    zip: '(mimeType="application/x-zip-compressed"ormimeType="application/zip")',
    geojson: '(name contains "json" or name contains "geojson")and(mimeType="application/octet-stream"ormimeType="application/json")',
    googlesheets: `(mimeType="application/vnd.google-apps.spreadsheet")`
};
function getDownloadUrl(id, mimeType, token) {
    const baseUrl = `https://www.googleapis.com/drive/v3/files/${id}`;
    const headers = `&httpHeaders={"Authorization":"Bearer&#32;${token}"}`;
    const sheet = `${baseUrl}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet${headers}`;
    const file = `${baseUrl}?alt=media${headers}`;
    return mimeType.indexOf("google-apps") > -1 || mimeType.indexOf("googlesheets") > -1 ? sheet : file;
}
class GoogleDrive {
    async connect() {
        return new Promise(async (resolve, reject) => {
            const { config, portal } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
            const portalHostname = portal.portalHostname;
            const locale = document.documentElement.lang || "en-US";
            const stateValue = `google${Math.floor(Date.now() / 1000)}`;
            const googleOauthUrl = "https://accounts.google.com/o/oauth2/v2/auth";
            const googleScope = "https://www.googleapis.com/auth/drive.readonly";
            const cloudStorageOAuthRedirectUri = `https://${portalHostname}/home/cloudDriveOauth-callback2.html`;
            const url = `${googleOauthUrl}?scope=${googleScope}&redirect_uri=${cloudStorageOAuthRedirectUri}&response_type=token&client_id=${config.googleClientId}&hl=${locale}&state=${stateValue}`;
            try {
                const oauthSignInUrl = await oauthSignIn(url, portalHostname);
                const state = await getTokenFromUrl(oauthSignInUrl, "state");
                if (stateValue !== state) {
                    reject("invalidState");
                }
                this.token = await getTokenFromUrl(oauthSignInUrl, "access_token");
                resolve(this.token);
            }
            catch (error) {
                reject(error);
            }
        });
    }
    async search(filterValues = {}) {
        return new Promise(async (resolve) => {
            const { searchText, next, dropdownFilter } = filterValues;
            const contentType = "application/json";
            const baseUrl = `https://www.googleapis.com/drive/v3/files?access_token=${this.token}&pageSize=10&fields=incompleteSearch,nextPageToken,files(id,kind,mimeType,name)`;
            const search = searchText ? `name contains '${searchText}' and trashed = false and` : "trashed = false and";
            const filter = queries[dropdownFilter];
            const nextToken = next ? `&pageToken=${this.nextToken}` : "";
            const url = `${baseUrl}&q=${search}${filter}${nextToken}`;
            const result = await externalRequest("GET", url, null, null, contentType);
            this.nextToken = result.nextPageToken;
            const files = result.files.map(({ id, name, mimeType }) => ({
                id,
                name,
                mimeType: lookupMimeType(mimeType),
                downloadUrl: getDownloadUrl(id, mimeType, this.token)
            }));
            resolve({ files, next: !!result.nextPageToken });
        });
    }
}

function getOneDriveDownloadUrl(id, token) {
    const url = `https://graph.microsoft.com/v1.0/me/drive/items/${id}/content?httpHeaders={"Authorization":"Bearer&#32;${token}"}`;
    return url;
}
class OneDrive {
    async connect() {
        return new Promise(async (resolve, reject) => {
            const { config, portal } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c;
            const portalHostname = portal.portalHostname;
            const locale = document.documentElement.lang || "en-US";
            const stateValue = `onedrive${Math.floor(Date.now() / 1000)}`;
            const oneDriveOauthUrl = "https://login.microsoftonline.com/common/oauth2/v2.0/authorize";
            const oneDriveScope = "files.read";
            const cloudStorageOAuthRedirectUri = `https://${portalHostname}/home/cloudDriveOauth-callback2.html`;
            const url = `${oneDriveOauthUrl}?scope=${oneDriveScope}&redirect_uri=${cloudStorageOAuthRedirectUri}&response_type=token&client_id=${config.oneDriveClientId}&locale=${locale}&state=${stateValue}`;
            try {
                const oauthSignInUrl = await oauthSignIn(url, portalHostname);
                const state = await getTokenFromUrl(oauthSignInUrl, "state");
                if (stateValue !== state) {
                    reject("invalidState");
                }
                this.token = await getTokenFromUrl(oauthSignInUrl, "access_token");
                resolve(this.token);
            }
            catch (error) {
                reject(error);
            }
        });
    }
    search(filterValues = {}) {
        return new Promise(async (resolve) => {
            const { searchText, dropdownFilter, next } = filterValues;
            const authorization = `Bearer ${this.token}`;
            const contentType = "application/json";
            const ext = cloudFileExtensions[dropdownFilter] || "";
            const search = searchText || "";
            const query = `https://graph.microsoft.com/v1.0/me/drive/root/search(q='${search} ${ext}')?select=name,id,file,size&top=10`;
            const url = next ? this.nextLink : query;
            const result = await externalRequest("GET", url, null, authorization, contentType);
            this.nextLink = result["@odata.nextLink"];
            const files = result.value.map(({ size, id, name }) => ({
                size,
                id,
                name,
                mimeType: getMimeType(name),
                downloadUrl: `https://graph.microsoft.com/v1.0/me/drive/items/${id}/content?httpHeaders={"Authorization":"Bearer ${this.token}"}`
            }));
            resolve({ files, next: !!result["@odata.nextLink"] });
        });
    }
}

function getProvider(option) {
    const providers = {
        dropbox: Dropbox,
        "google drive": GoogleDrive,
        onedrive: OneDrive
    };
    return new providers[option]();
}
function getResourceIdentifier(option) {
    const resourceMap = {
        dropbox: "dropBoxConnect",
        "google drive": "googleConnect",
        onedrive: "oneDriveConnect"
    };
    return resourceMap[option];
}
function getProviderOption(option) {
    const providers = {
        dropBoxConnect: Dropbox,
        googleConnect: GoogleDrive,
        oneDriveConnect: OneDrive
    };
    return new providers[option]();
}
function getCloudOption(option) {
    const resourceMap = {
        dropBoxConnect: "dropbox",
        googleConnect: "google drive",
        oneDriveConnect: "onedrive"
    };
    return resourceMap[option];
}



//# sourceMappingURL=index-0a84b068.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21faW5kZXgtLWQyYmFmZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCLElBQUkseUJBQXlCO0FBQzFGLHlDQUF5QyxJQUFJLG9CQUFvQixpQkFBaUIsa0JBQWtCLGVBQWU7QUFDbkgsa0NBQWtDLGVBQWUscUNBQXFDLFlBQVk7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5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QW1DO0FBQ3ZELDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixRQUFRLEVBQUUsSUFBSTtBQUNwRztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLEdBQUcsc0JBQXNCLDBCQUEwQixXQUFXLEVBQUU7QUFDaEosYUFBYTtBQUNiLHNCQUFzQiwwQ0FBMEM7QUFDaEUsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNk47O0FBRTdOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vaW5kZXgtMGE4NGIwNjguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBjIGFzIGNvbmZpZ1N0YXRlIH0gZnJvbSAnLi9jb25maWctNzVhZGY5NjIuanMnO1xuXG5mdW5jdGlvbiBleHRlcm5hbFJlcXVlc3QobWV0aG9kLCBjb250ZW50VXJsLCBib2R5LCBhdXRob3JpemF0aW9uLCBjb250ZW50VHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHhodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhodHRwLm9wZW4obWV0aG9kLCBjb250ZW50VXJsLCBmYWxzZSk7XG4gICAgICAgIGlmIChhdXRob3JpemF0aW9uKSB7XG4gICAgICAgICAgICB4aHR0cC5zZXRSZXF1ZXN0SGVhZGVyKFwiQXV0aG9yaXphdGlvblwiLCBhdXRob3JpemF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHhodHRwLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgY29udGVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICB4aHR0cC5zZW5kKGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeGh0dHAuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gSlNPTi5wYXJzZSh4aHR0cC5yZXNwb25zZVRleHQpO1xuICAgICAgICAvL3N0YXR1cyBtb3JlIHRoYW4gNDAwIGlzIGVycm9yXG4gICAgICAgIGlmICh4aHR0cC5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICByZWplY3QoSlNPTi5wYXJzZSh4aHR0cC5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFRva2VuRnJvbVVybCh1cmwsIG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bW10vLCBcIltcIikucmVwbGFjZSgvW11dLywgXCJdXCIpO1xuICAgICAgICBjb25zdCByZWdleFMgPSBgWz8mI10ke25hbWV9PShbXiYjXSopYDtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4Uyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSByZWdleC5leGVjKHVybCk7XG4gICAgICAgIGlmIChyZXN1bHRzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlamVjdChcIkludmFsaWRUb2tlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0c1sxXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9hdXRoU2lnbkluKHVybCwgcG9ydGFsSG9zdE5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50U291cmNlVXJsID0gYCR7d2luZG93LmxvY2F0aW9uLnByb3RvY29sfS8vJHt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWV9YDtcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBgP2Nsb3VkVXJsPSR7dXJsfSZjdXJyZW50U291cmNlVXJsPSR7Y3VycmVudFNvdXJjZVVybH0mcG9ydGFsSG9zdE5hbWU9JHtwb3J0YWxIb3N0TmFtZX1gO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBgaHR0cHM6Ly8ke3BvcnRhbEhvc3ROYW1lfS9ob21lL2Nsb3VkRHJpdmVPYXV0aC1jYWxsYmFjay5odG1sJHtxdWVyeVN0cmluZ31gO1xuICAgICAgICBjb25zdCBpZnJtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgaWZybS5zcmMgPSBzb3VyY2U7XG4gICAgICAgIGlmcm0uY2xhc3NOYW1lID0gXCJoaWRlXCI7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZybSk7XG4gICAgICAgIGNvbnN0IGV2ZW50TWV0aG9kID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyBcImFkZEV2ZW50TGlzdGVuZXJcIiA6IFwiYXR0YWNoRXZlbnRcIjtcbiAgICAgICAgY29uc3QgZXZlbnRlciA9IHdpbmRvd1tldmVudE1ldGhvZF07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VFdmVudCA9IGV2ZW50TWV0aG9kID09PSBcImF0dGFjaEV2ZW50XCIgPyBcIm9ubWVzc2FnZVwiIDogXCJtZXNzYWdlXCI7XG4gICAgICAgIC8vIExpc3RlbiB0byBtZXNzYWdlIGZyb20gY2hpbGQgd2luZG93XG4gICAgICAgIGV2ZW50ZXIobWVzc2FnZUV2ZW50LCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUub3JpZ2luICE9PSBgaHR0cHM6Ly8ke3BvcnRhbEhvc3ROYW1lfWApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5kYXRhID09PSBcInBvcHVwQmxvY2tlZFwiIHx8IGUuZGF0YSA9PT0gXCJ3aW5kb3dDbG9zZWRcIikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGEpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfSk7XG59XG5jb25zdCBjbG91ZEZpbGVJY29ucyA9IHtcbiAgICBjc3Y6IFwiZmlsZS1jc3ZcIixcbiAgICBleGNlbDogXCJmaWxlLWV4Y2VsXCIsXG4gICAgemlwOiBcImZpbGUtemlwXCIsXG4gICAgZ2VvanNvbjogXCJmaWxlLWNvZGVcIixcbiAgICBzaGVldDogXCJmaWxlLXJlcG9ydFwiLFxuICAgIGNhZDogXCJmaWxlLWNhZFwiLFxuICAgIGdweDogXCJmaWxlLWdweFwiLFxuICAgIHBuZzogXCJmaWxlLWltYWdlXCIsXG4gICAganBnOiBcImZpbGUtaW1hZ2VcIixcbiAgICBqcGVnOiBcImZpbGUtaW1hZ2VcIixcbiAgICB0aWZmOiBcImZpbGUtaW1hZ2VcIixcbiAgICBnaWY6IFwiZmlsZS1pbWFnZVwiLFxuICAgIHBkZjogXCJmaWxlLXBkZlwiLFxuICAgIGRvY3g6IFwiZmlsZS13b3JkXCJcbn07XG5jb25zdCBjbG91ZEZpbGVOYW1lcyA9IHtcbiAgICBjc3Y6IFwiQ1NWXCIsXG4gICAgZXhjZWw6IFwiRXhjZWxcIixcbiAgICB6aXA6IFwiWmlwIEZpbGVcIixcbiAgICBnZW9qc29uOiBcIkdlb0pTT05cIixcbiAgICBnb29nbGVzaGVldHM6IFwiR29vZ2xlIFNoZWV0c1wiLFxuICAgIGNhZDogXCJDQURcIixcbiAgICBncHg6IFwiR1BYXCIsXG4gICAgcG5nOiBcIkltYWdlXCIsXG4gICAganBnOiBcIkltYWdlXCIsXG4gICAganBlZzogXCJJbWFnZVwiLFxuICAgIHRpZmY6IFwiSW1hZ2VcIixcbiAgICBnaWY6IFwiSW1hZ2VcIixcbiAgICBwZGY6IFwiUERGXCIsXG4gICAgZG9jeDogXCJNaWNyb3NvZnQgV29yZFwiLFxuICAgIHBwdHg6IFwiTWljcm9zb2Z0IFBvd2VyUG9pbnRcIlxufTtcbmNvbnN0IGNsb3VkRmlsZUV4dGVuc2lvbnMgPSB7XG4gICAgY3N2OiBcIi5jc3ZcIixcbiAgICBleGNlbDogXCIueGxzXCIsXG4gICAgemlwOiBcIi56aXBcIixcbiAgICBnZW9qc29uOiBcIi5nZW9qc29uXCIsXG4gICAgZ29vZ2xlc2hlZXRzOiBcIlwiXG59O1xuZnVuY3Rpb24gZ2V0TWltZVR5cGUoZmlsZU5hbWUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGZpbGVOYW1lLnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGV4dGVuc2lvbkxvb2t1cCA9IHtcbiAgICAgICAgeGxzOiBcImV4Y2VsXCIsXG4gICAgICAgIHhsc3g6IFwiZXhjZWxcIixcbiAgICAgICAgY3N2OiBcImNzdlwiLFxuICAgICAgICB6aXA6IFwiemlwXCIsXG4gICAgICAgIGdlb2pzb246IFwiZ2VvanNvblwiLFxuICAgICAgICBqc29uOiBcImdlb2pzb25cIlxuICAgIH07XG4gICAgcmV0dXJuIGV4dGVuc2lvbkxvb2t1cFtleHRlbnNpb25dIHx8IGV4dGVuc2lvbjtcbn1cblxuZnVuY3Rpb24gZ2V0RHJvcEJveERvd25sb2FkVXJsKGlkLCB0b2tlbikge1xuICAgIHJldHVybiBgaHR0cHM6Ly9jb250ZW50LmRyb3Bib3hhcGkuY29tLzIvZmlsZXMvZG93bmxvYWQ/aHR0cEhlYWRlcnM9e1wiQXV0aG9yaXphdGlvblwiOlwiQmVhcmVyJiMzMjske3Rva2VufVwiLFwiRHJvcGJveC1BUEktQXJnXCI6XCJ7XFxcXFwicGF0aFxcXFxcIjpcXFxcXCIke2lkfVxcXFxcIn1cIn1gO1xufVxuY2xhc3MgRHJvcGJveCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gMDtcbiAgICB9XG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgeyBjb25maWcsIHBvcnRhbCB9ID0gY29uZmlnU3RhdGU7XG4gICAgICAgIGNvbnN0IHN0YXRlVmFsdWUgPSBgZHJvcGJveCR7TWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCl9YDtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgfHwgXCJlbi1VU1wiO1xuICAgICAgICBjb25zdCBkcm9wYm94T2F1dGhVcmwgPSBcImh0dHBzOi8vd3d3LmRyb3Bib3guY29tL29hdXRoMi9hdXRob3JpemVcIjtcbiAgICAgICAgY29uc3QgY2xvdWRTdG9yYWdlT0F1dGhSZWRpcmVjdFVyaSA9IGBodHRwczovLyR7cG9ydGFsLnBvcnRhbEhvc3RuYW1lfS9ob21lL2Nsb3VkRHJpdmVPYXV0aC1jYWxsYmFjazIuaHRtbGA7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke2Ryb3Bib3hPYXV0aFVybH0/cmVkaXJlY3RfdXJpPSR7Y2xvdWRTdG9yYWdlT0F1dGhSZWRpcmVjdFVyaX0mcmVzcG9uc2VfdHlwZT10b2tlbiZjbGllbnRfaWQ9JHtjb25maWcuZHJvcGJveENsaWVudElkfSZsb2NhbGU9JHtsb2NhbGV9JnN0YXRlPSR7c3RhdGVWYWx1ZX1gO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduSW5VcmwgPSBhd2FpdCBvYXV0aFNpZ25Jbih1cmwsIHBvcnRhbC5wb3J0YWxIb3N0bmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVGcm9tVXJsID0gYXdhaXQgZ2V0VG9rZW5Gcm9tVXJsKHNpZ25JblVybCwgXCJzdGF0ZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVWYWx1ZSAhPT0gc3RhdGVGcm9tVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChcImludmFsaWRTdGF0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBhd2FpdCBnZXRUb2tlbkZyb21Vcmwoc2lnbkluVXJsLCBcImFjY2Vzc190b2tlblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuID0gYWNjZXNzVG9rZW47XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlYXJjaChmaWx0ZXJWYWx1ZXMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHRva2VuIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VhcmNoVGV4dCwgZHJvcGRvd25GaWx0ZXIsIG5leHQgfSA9IGZpbHRlclZhbHVlcztcbiAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VXJsID0gXCJodHRwczovL2FwaS5kcm9wYm94YXBpLmNvbS8yL2ZpbGVzL3NlYXJjaFwiO1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNoSW5wdXQgPSBzZWFyY2hUZXh0ID8gYCAke3NlYXJjaFRleHR9YCA6IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG5leHQgPyB0aGlzLm5leHRTdGFydCA6IDA7XG4gICAgICAgICAgICBsZXQgdHlwZVF1ZXJ5ID0gY2xvdWRGaWxlRXh0ZW5zaW9uc1tkcm9wZG93bkZpbHRlcl07XG4gICAgICAgICAgICBpZiAoZHJvcGRvd25GaWx0ZXIgPT09IFwiZXhjZWxcIikge1xuICAgICAgICAgICAgICAgIHR5cGVRdWVyeSA9IFwieGxzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib2R5RHJvcGJveFJlcXVlc3QgPSBge1wicGF0aFwiOlwiXCIsXCJxdWVyeVwiOlwiJHtzZWFyY2hJbnB1dH0gJHt0eXBlUXVlcnl9XCIsXCJtb2RlXCI6IFwiZmlsZW5hbWVcIixcIm1heF9yZXN1bHRzXCI6MTAsXCJzdGFydFwiOiR7c3RhcnR9fWA7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleHRlcm5hbFJlcXVlc3QoXCJQT1NUXCIsIGNvbnRlbnRVcmwsIGJvZHlEcm9wYm94UmVxdWVzdCwgYXV0aG9yaXphdGlvbiwgY29udGVudFR5cGUpO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSByZXN1bHQuc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBmaWxlcyA9IHJlc3VsdC5tYXRjaGVzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZmlsZSkgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gZmlsZS5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1wiLnRhZ1wiXSkgPT09IFwiZmlsZVwiOyB9KVxuICAgICAgICAgICAgICAgIC5tYXAoKHsgbWV0YWRhdGE6IHsgaWQsIG5hbWUsIHNpemUgfSB9KSA9PiAoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IGdldE1pbWVUeXBlKG5hbWUpLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkVXJsOiBgaHR0cHM6Ly9jb250ZW50LmRyb3Bib3hhcGkuY29tLzIvZmlsZXMvZG93bmxvYWQ/aHR0cEhlYWRlcnM9e1wiQXV0aG9yaXphdGlvblwiOlwiQmVhcmVyJiMzMjske3Rva2VufVwiLFwiRHJvcGJveC1BUEktQXJnXCI6XCJ7XFxcXFwicGF0aFxcXFxcIjpcXFxcXCIke2lkfVxcXFxcIn1cIn1gLFxuICAgICAgICAgICAgICAgIHNpemVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJlc29sdmUoeyBmaWxlcywgbmV4dDogISFyZXN1bHQubW9yZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiogR29vZ2xlIHJldHVybnMgYW4gYWN0dWFsIG1pbWV0eXBlLCBub3QganVzdCBhIGZpbGVuYW1lLCBzbyB3ZSBjYW4gY2hlY2sgYW5kIGNvbnZlcnQgdG8gb3VyIHR5cGVzICovXG5mdW5jdGlvbiBsb29rdXBNaW1lVHlwZShtaW1lVHlwZSkge1xuICAgIGlmIChtaW1lVHlwZS5pbmRleE9mKFwic3ByZWFkc2hlZXRtbC5zaGVldFwiKSA+IC0xIHx8IG1pbWVUeXBlLmluZGV4T2YoXCJtcy1leGNlbFwiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcImV4Y2VsXCI7XG4gICAgfVxuICAgIGlmIChtaW1lVHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vemlwXCIpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIFwiemlwXCI7XG4gICAgfVxuICAgIGlmIChtaW1lVHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpID4gLTEgfHwgbWltZVR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgPiAtMSkge1xuICAgICAgICByZXR1cm4gXCJnZW9qc29uXCI7XG4gICAgfVxuICAgIGlmIChtaW1lVHlwZS5pbmRleE9mKFwiZ29vZ2xlLWFwcHMuc3ByZWFkc2hlZXRcIikgPiAtMSkge1xuICAgICAgICByZXR1cm4gXCJnb29nbGVzaGVldHNcIjtcbiAgICB9XG4gICAgaWYgKG1pbWVUeXBlLmluZGV4T2YoXCJ0ZXh0L2NzdlwiKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBcImNzdlwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJ6aXBcIjtcbn1cbmNvbnN0IHF1ZXJpZXMgPSB7XG4gICAgY3N2OiAnKG1pbWVUeXBlPVwidGV4dC9jc3ZcIiknLFxuICAgIGV4Y2VsOiAnKG1pbWVUeXBlPVwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXRcIm9ybWltZVR5cGU9XCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWxcIiknLFxuICAgIHppcDogJyhtaW1lVHlwZT1cImFwcGxpY2F0aW9uL3gtemlwLWNvbXByZXNzZWRcIm9ybWltZVR5cGU9XCJhcHBsaWNhdGlvbi96aXBcIiknLFxuICAgIGdlb2pzb246ICcobmFtZSBjb250YWlucyBcImpzb25cIiBvciBuYW1lIGNvbnRhaW5zIFwiZ2VvanNvblwiKWFuZChtaW1lVHlwZT1cImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwib3JtaW1lVHlwZT1cImFwcGxpY2F0aW9uL2pzb25cIiknLFxuICAgIGdvb2dsZXNoZWV0czogYChtaW1lVHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtYXBwcy5zcHJlYWRzaGVldFwiKWBcbn07XG5mdW5jdGlvbiBnZXREb3dubG9hZFVybChpZCwgbWltZVR5cGUsIHRva2VuKSB7XG4gICAgY29uc3QgYmFzZVVybCA9IGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9kcml2ZS92My9maWxlcy8ke2lkfWA7XG4gICAgY29uc3QgaGVhZGVycyA9IGAmaHR0cEhlYWRlcnM9e1wiQXV0aG9yaXphdGlvblwiOlwiQmVhcmVyJiMzMjske3Rva2VufVwifWA7XG4gICAgY29uc3Qgc2hlZXQgPSBgJHtiYXNlVXJsfS9leHBvcnQ/bWltZVR5cGU9YXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQke2hlYWRlcnN9YDtcbiAgICBjb25zdCBmaWxlID0gYCR7YmFzZVVybH0/YWx0PW1lZGlhJHtoZWFkZXJzfWA7XG4gICAgcmV0dXJuIG1pbWVUeXBlLmluZGV4T2YoXCJnb29nbGUtYXBwc1wiKSA+IC0xIHx8IG1pbWVUeXBlLmluZGV4T2YoXCJnb29nbGVzaGVldHNcIikgPiAtMSA/IHNoZWV0IDogZmlsZTtcbn1cbmNsYXNzIEdvb2dsZURyaXZlIHtcbiAgICBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjb25maWcsIHBvcnRhbCB9ID0gY29uZmlnU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBwb3J0YWxIb3N0bmFtZSA9IHBvcnRhbC5wb3J0YWxIb3N0bmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nIHx8IFwiZW4tVVNcIjtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlVmFsdWUgPSBgZ29vZ2xlJHtNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKX1gO1xuICAgICAgICAgICAgY29uc3QgZ29vZ2xlT2F1dGhVcmwgPSBcImh0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi92Mi9hdXRoXCI7XG4gICAgICAgICAgICBjb25zdCBnb29nbGVTY29wZSA9IFwiaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9kcml2ZS5yZWFkb25seVwiO1xuICAgICAgICAgICAgY29uc3QgY2xvdWRTdG9yYWdlT0F1dGhSZWRpcmVjdFVyaSA9IGBodHRwczovLyR7cG9ydGFsSG9zdG5hbWV9L2hvbWUvY2xvdWREcml2ZU9hdXRoLWNhbGxiYWNrMi5odG1sYDtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke2dvb2dsZU9hdXRoVXJsfT9zY29wZT0ke2dvb2dsZVNjb3BlfSZyZWRpcmVjdF91cmk9JHtjbG91ZFN0b3JhZ2VPQXV0aFJlZGlyZWN0VXJpfSZyZXNwb25zZV90eXBlPXRva2VuJmNsaWVudF9pZD0ke2NvbmZpZy5nb29nbGVDbGllbnRJZH0maGw9JHtsb2NhbGV9JnN0YXRlPSR7c3RhdGVWYWx1ZX1gO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYXV0aFNpZ25JblVybCA9IGF3YWl0IG9hdXRoU2lnbkluKHVybCwgcG9ydGFsSG9zdG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgZ2V0VG9rZW5Gcm9tVXJsKG9hdXRoU2lnbkluVXJsLCBcInN0YXRlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZVZhbHVlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJpbnZhbGlkU3RhdGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9rZW4gPSBhd2FpdCBnZXRUb2tlbkZyb21Vcmwob2F1dGhTaWduSW5VcmwsIFwiYWNjZXNzX3Rva2VuXCIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2VhcmNoKGZpbHRlclZhbHVlcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZWFyY2hUZXh0LCBuZXh0LCBkcm9wZG93bkZpbHRlciB9ID0gZmlsdGVyVmFsdWVzO1xuICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VVcmwgPSBgaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZHJpdmUvdjMvZmlsZXM/YWNjZXNzX3Rva2VuPSR7dGhpcy50b2tlbn0mcGFnZVNpemU9MTAmZmllbGRzPWluY29tcGxldGVTZWFyY2gsbmV4dFBhZ2VUb2tlbixmaWxlcyhpZCxraW5kLG1pbWVUeXBlLG5hbWUpYDtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaCA9IHNlYXJjaFRleHQgPyBgbmFtZSBjb250YWlucyAnJHtzZWFyY2hUZXh0fScgYW5kIHRyYXNoZWQgPSBmYWxzZSBhbmRgIDogXCJ0cmFzaGVkID0gZmFsc2UgYW5kXCI7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBxdWVyaWVzW2Ryb3Bkb3duRmlsdGVyXTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IG5leHQgPyBgJnBhZ2VUb2tlbj0ke3RoaXMubmV4dFRva2VufWAgOiBcIlwiO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0mcT0ke3NlYXJjaH0ke2ZpbHRlcn0ke25leHRUb2tlbn1gO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXh0ZXJuYWxSZXF1ZXN0KFwiR0VUXCIsIHVybCwgbnVsbCwgbnVsbCwgY29udGVudFR5cGUpO1xuICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4gPSByZXN1bHQubmV4dFBhZ2VUb2tlbjtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gcmVzdWx0LmZpbGVzLm1hcCgoeyBpZCwgbmFtZSwgbWltZVR5cGUgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBsb29rdXBNaW1lVHlwZShtaW1lVHlwZSksXG4gICAgICAgICAgICAgICAgZG93bmxvYWRVcmw6IGdldERvd25sb2FkVXJsKGlkLCBtaW1lVHlwZSwgdGhpcy50b2tlbilcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJlc29sdmUoeyBmaWxlcywgbmV4dDogISFyZXN1bHQubmV4dFBhZ2VUb2tlbiB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRPbmVEcml2ZURvd25sb2FkVXJsKGlkLCB0b2tlbikge1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20vdjEuMC9tZS9kcml2ZS9pdGVtcy8ke2lkfS9jb250ZW50P2h0dHBIZWFkZXJzPXtcIkF1dGhvcml6YXRpb25cIjpcIkJlYXJlciYjMzI7JHt0b2tlbn1cIn1gO1xuICAgIHJldHVybiB1cmw7XG59XG5jbGFzcyBPbmVEcml2ZSB7XG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29uZmlnLCBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICAgICAgICAgICAgY29uc3QgcG9ydGFsSG9zdG5hbWUgPSBwb3J0YWwucG9ydGFsSG9zdG5hbWU7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyB8fCBcImVuLVVTXCI7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZVZhbHVlID0gYG9uZWRyaXZlJHtNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKX1gO1xuICAgICAgICAgICAgY29uc3Qgb25lRHJpdmVPYXV0aFVybCA9IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vbi9vYXV0aDIvdjIuMC9hdXRob3JpemVcIjtcbiAgICAgICAgICAgIGNvbnN0IG9uZURyaXZlU2NvcGUgPSBcImZpbGVzLnJlYWRcIjtcbiAgICAgICAgICAgIGNvbnN0IGNsb3VkU3RvcmFnZU9BdXRoUmVkaXJlY3RVcmkgPSBgaHR0cHM6Ly8ke3BvcnRhbEhvc3RuYW1lfS9ob21lL2Nsb3VkRHJpdmVPYXV0aC1jYWxsYmFjazIuaHRtbGA7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHtvbmVEcml2ZU9hdXRoVXJsfT9zY29wZT0ke29uZURyaXZlU2NvcGV9JnJlZGlyZWN0X3VyaT0ke2Nsb3VkU3RvcmFnZU9BdXRoUmVkaXJlY3RVcml9JnJlc3BvbnNlX3R5cGU9dG9rZW4mY2xpZW50X2lkPSR7Y29uZmlnLm9uZURyaXZlQ2xpZW50SWR9JmxvY2FsZT0ke2xvY2FsZX0mc3RhdGU9JHtzdGF0ZVZhbHVlfWA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9hdXRoU2lnbkluVXJsID0gYXdhaXQgb2F1dGhTaWduSW4odXJsLCBwb3J0YWxIb3N0bmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCBnZXRUb2tlbkZyb21Vcmwob2F1dGhTaWduSW5VcmwsIFwic3RhdGVcIik7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlVmFsdWUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChcImludmFsaWRTdGF0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbiA9IGF3YWl0IGdldFRva2VuRnJvbVVybChvYXV0aFNpZ25JblVybCwgXCJhY2Nlc3NfdG9rZW5cIik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZWFyY2goZmlsdGVyVmFsdWVzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHNlYXJjaFRleHQsIGRyb3Bkb3duRmlsdGVyLCBuZXh0IH0gPSBmaWx0ZXJWYWx1ZXM7XG4gICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gYEJlYXJlciAke3RoaXMudG9rZW59YDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgICAgICAgICBjb25zdCBleHQgPSBjbG91ZEZpbGVFeHRlbnNpb25zW2Ryb3Bkb3duRmlsdGVyXSB8fCBcIlwiO1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNoID0gc2VhcmNoVGV4dCB8fCBcIlwiO1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBgaHR0cHM6Ly9ncmFwaC5taWNyb3NvZnQuY29tL3YxLjAvbWUvZHJpdmUvcm9vdC9zZWFyY2gocT0nJHtzZWFyY2h9ICR7ZXh0fScpP3NlbGVjdD1uYW1lLGlkLGZpbGUsc2l6ZSZ0b3A9MTBgO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV4dCA/IHRoaXMubmV4dExpbmsgOiBxdWVyeTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4dGVybmFsUmVxdWVzdChcIkdFVFwiLCB1cmwsIG51bGwsIGF1dGhvcml6YXRpb24sIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgIHRoaXMubmV4dExpbmsgPSByZXN1bHRbXCJAb2RhdGEubmV4dExpbmtcIl07XG4gICAgICAgICAgICBjb25zdCBmaWxlcyA9IHJlc3VsdC52YWx1ZS5tYXAoKHsgc2l6ZSwgaWQsIG5hbWUgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IGdldE1pbWVUeXBlKG5hbWUpLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkVXJsOiBgaHR0cHM6Ly9ncmFwaC5taWNyb3NvZnQuY29tL3YxLjAvbWUvZHJpdmUvaXRlbXMvJHtpZH0vY29udGVudD9odHRwSGVhZGVycz17XCJBdXRob3JpemF0aW9uXCI6XCJCZWFyZXIgJHt0aGlzLnRva2VufVwifWBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJlc29sdmUoeyBmaWxlcywgbmV4dDogISFyZXN1bHRbXCJAb2RhdGEubmV4dExpbmtcIl0gfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvdmlkZXIob3B0aW9uKSB7XG4gICAgY29uc3QgcHJvdmlkZXJzID0ge1xuICAgICAgICBkcm9wYm94OiBEcm9wYm94LFxuICAgICAgICBcImdvb2dsZSBkcml2ZVwiOiBHb29nbGVEcml2ZSxcbiAgICAgICAgb25lZHJpdmU6IE9uZURyaXZlXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IHByb3ZpZGVyc1tvcHRpb25dKCk7XG59XG5mdW5jdGlvbiBnZXRSZXNvdXJjZUlkZW50aWZpZXIob3B0aW9uKSB7XG4gICAgY29uc3QgcmVzb3VyY2VNYXAgPSB7XG4gICAgICAgIGRyb3Bib3g6IFwiZHJvcEJveENvbm5lY3RcIixcbiAgICAgICAgXCJnb29nbGUgZHJpdmVcIjogXCJnb29nbGVDb25uZWN0XCIsXG4gICAgICAgIG9uZWRyaXZlOiBcIm9uZURyaXZlQ29ubmVjdFwiXG4gICAgfTtcbiAgICByZXR1cm4gcmVzb3VyY2VNYXBbb3B0aW9uXTtcbn1cbmZ1bmN0aW9uIGdldFByb3ZpZGVyT3B0aW9uKG9wdGlvbikge1xuICAgIGNvbnN0IHByb3ZpZGVycyA9IHtcbiAgICAgICAgZHJvcEJveENvbm5lY3Q6IERyb3Bib3gsXG4gICAgICAgIGdvb2dsZUNvbm5lY3Q6IEdvb2dsZURyaXZlLFxuICAgICAgICBvbmVEcml2ZUNvbm5lY3Q6IE9uZURyaXZlXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IHByb3ZpZGVyc1tvcHRpb25dKCk7XG59XG5mdW5jdGlvbiBnZXRDbG91ZE9wdGlvbihvcHRpb24pIHtcbiAgICBjb25zdCByZXNvdXJjZU1hcCA9IHtcbiAgICAgICAgZHJvcEJveENvbm5lY3Q6IFwiZHJvcGJveFwiLFxuICAgICAgICBnb29nbGVDb25uZWN0OiBcImdvb2dsZSBkcml2ZVwiLFxuICAgICAgICBvbmVEcml2ZUNvbm5lY3Q6IFwib25lZHJpdmVcIlxuICAgIH07XG4gICAgcmV0dXJuIHJlc291cmNlTWFwW29wdGlvbl07XG59XG5cbmV4cG9ydCB7IGdldFJlc291cmNlSWRlbnRpZmllciBhcyBhLCBjbG91ZEZpbGVOYW1lcyBhcyBiLCBjbG91ZEZpbGVJY29ucyBhcyBjLCBnZXRDbG91ZE9wdGlvbiBhcyBkLCBnZXRQcm92aWRlck9wdGlvbiBhcyBlLCBnZXREb3dubG9hZFVybCBhcyBmLCBnZXRQcm92aWRlciBhcyBnLCBnZXRPbmVEcml2ZURvd25sb2FkVXJsIGFzIGgsIGdldERyb3BCb3hEb3dubG9hZFVybCBhcyBpIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LTBhODRiMDY4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==