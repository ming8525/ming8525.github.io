"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-c4c203"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.de-1454f434.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.de-1454f434.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "OK";
const cancel = "Abbrechen";
const enterURL = "Image-Service-URL eingeben";
const serviceURL = "Service-URL";
const selectRaster = "Raster auswählen";
const failedToLoadLayer = "Fehler beim Laden des Layers";
const loadingLayer = "Layer wird geladen";
const selectFeature = "Feature-Layer auswählen";
const enterFURL = "Feature-Service-URL eingeben";
const addRaster = "Raster-Variable hinzufügen";
const addScalar = "Konstante hinzufügen";
const raster = "Raster";
const scalar = "Skalar";
const defaultModelName = "Raster-Funktionsvorlage";
const general = "Allgemein";
const parameters = "Parameter";
const variables = "Variablen";
const name = "Name";
const description = "Beschreibung";
const parameter = "Parameter";
const isPublic = "IsPublic";
const isDataset = "IsDataset";
const unknownPixelType = "Unbekannt";
const outputPixelType = "Ausgabepixeltyp";
const u8PixelType = "8-Bit ohne Vorzeichen";
const s8PixelType = "8-Bit mit Vorzeichen";
const u16PixelType = "16-Bit ohne Vorzeichen";
const s16PixelType = "16-Bit mit Vorzeichen";
const u32PixelType = "32-Bit ohne Vorzeichen";
const s32PixelType = "32-Bit mit Vorzeichen";
const f32PixelType = "32-Bit-Gleitkommazahl";
const f64PixelType = "64-Bit-Double";
const properties = "Eigenschaften";
const multidimensionalRules = "Multidimensionale Regeln";
const matchVariables = "Variablen abgleichen";
const unionDimensions = "Dimensionen vereinigen";
const rasterFunctionEditor = {
	invalidRFTMessage: "Die Raster-Funktionsvorlage ist ungültig.",
	rfxArgsEditor: {
		outputRaster: "Ausgabe-Raster",
		raster: "Raster",
		unsupportedDataTypeWarning: "Die folgenden Argumente werden nicht angezeigt, da sie derzeit nicht unterstützt werden.",
		unsupportedFunction: "Enthält aktuell nicht unterstützte Raster-Funktionen."
	},
	rfxRasterInput: {
		selectLayer: "Layer auswählen",
		browseLayers: "Layer durchsuchen",
		rfxVariable: "RasterFunctionVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Methode",
		bandLabel: "Band",
		combinationLabel: "Kombination"
	},
	rfxRemapGrid: {
		minimum: "Minimum",
		maximum: "Maximum",
		output: "Ausgabe",
		noData: "NoData",
		remapValuesLabel: "Werte neu zuordnen"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Raster-Variablen",
		deleteSelectedVars: "Ausgewählte Variablen entfernen"
	},
	rfxClippingGeometry: {
		clippingLayer: "Ausschneide-Layer",
		clippingRaster: "Raster zum Ausschneiden",
		clippingGeometry: "Ausschneidegeometrie",
		customExtent: "Benutzerdefinierte Ausdehnung",
		outputExtent: "Ausgabeausdehnung",
		currentExtent: "Aktuelle Kartenausdehnung",
		drawLabel: "Zeichnen"
	},
	rfxCustomExtent: {
		top: "Oben",
		right: "Rechts",
		bottom: "Unten",
		left: "Links"
	},
	rfxRasterArrayEditor: {
		moveUp: "Nach oben verschieben",
		moveDown: "Nach unten verschieben",
		remove: "Entfernen"
	},
	rfxStatisticsGrid: {
		stdDev: "Std. Abw",
		min: "Min.",
		max: "Max.",
		mean: "Mittelwert"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Tabelle der gewichteten Summe",
		id: "ID",
		layer: "Layer",
		field: "Feld",
		weight: "Gewichtung",
		value: "Wert",
		selectLayer: "Layer auswählen"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Gewichtungsüberlagerungstabelle",
		id: "ID",
		layer: "Layer",
		field: "Feld",
		influence: "Einfluss",
		sumOfInfluence: "Summe der Einflüsse",
		value: "Wert",
		remapTable: "Neuzuordnungs-Tabelle",
		scale: "Maßstab",
		scales: "Maßstäbe",
		selectRaster: "Raster auswählen"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Nach einem Feature-Layer suchen",
		addPointLayer: "Nach einem Punkt-Layer suchen"
	},
	rfxFieldSelect: {
		value: "Wert",
		count: "Anzahl"
	},
	rfxAttributeTable: {
		tableType: "Tabellentyp",
		manual: "Manuell",
		external: "Extern",
		minVal: "Minimalwert",
		maxVal: "Maximalwert",
		baseClassName: "Basisname für Klasse",
		colorScheme: "Farbschema",
		defaultClassName: "Label_",
		generateTable: "Tabelle generieren",
		browseTable: "Tabelle durchsuchen",
		value: "Wert",
		classname: "ClassName",
		color: "Farbe"
	},
	rfxFieldNumberSwitchable: {
		number: "Numerisch",
		field: "Feld",
		string: "Zeichenfolge",
		linearUnit: "Lineare Einheit"
	},
	rfxPropertySet: {
		name: "Name",
		value: "Wert"
	},
	rfxConversionGrid: {
		size: "Größe"
	},
	rfxTransposeBit: {
		bitPattern: "Bit-Muster",
		outputBit: "Ausgabebit",
		inputBit: "Eingabebit"
	},
	rfxSpatialReference: {
		placeHolder: "Nach Schlüsselwort eingrenzen",
		coordinateSystem: "Koordinatensystem",
		gcs: "Geographisches Koordinatensystem",
		pcs: "Projiziertes Koordinatensystem",
		vcs: "Vertikales Koordinatensystem"
	}
};
const rfxLicenseInfo = "Diese Raster-Funktionsvorlage können Sie zur Verarbeitung Ihrer Bilddaten mithilfe von ArcGIS Image Server verwenden.";
const rasterFunctions = {
	rfx: {
		aCosHName: "ACosH",
		aCosHSnip: "Den Areakosinus von Zellen in einem Raster berechnen.",
		aCosHDesc: "Mit der Funktion wird der Areakosinus Hyperbolicus der Pixel in einem Raster berechnet.",
		aCosName: "ACos",
		aCosSnip: "Berechnet den Arkuskosinus der Pixel in einem Raster.",
		aCosDesc: "Mit dieser Raster-Funktion wird der Arkuskosinus von Zellen in einem Raster berechnet. In der Mathematik verfügen alle trigonometrischen Funktionen über einen definierten Bereich gültiger Eingabewerte, der als Domäne bezeichnet wird. Die Ausgabewerte jeder Funktion haben ebenfalls einen definierten Bereich. Für dieses Werkzeug beträgt die Domäne [-1, 1] und der Bereich [0, pi].",
		aSinHName: "ASinH",
		aSinHSnip: "Den Areasinus von Zellen in einem Raster berechnen.",
		aSinHDesc: "Mit der Funktion wird der Areasinus Hyperbolicus der Pixel in einem Raster berechnet.",
		aSinName: "ASin",
		aSinSnip: "Den Arkussinus von Zellen in einem Raster berechnen.",
		aSinDesc: "Mit der Funktion wird der Arkussinus der Pixel in einem Raster berechnet.",
		aTan2Name: "ATan2",
		aTan2Snip: "Den Arkustangens (auf Basis von x,y) von Zellen in einem Raster berechnen.",
		aTan2Desc: "Mit der Funktion wird der Arkustangens (auf Basis von XY-Koordinaten) der Pixel in einem Raster berechnet.",
		aTanHName: "ATanH",
		aTanHSnip: "Den Areatangens von Zellen in einem Raster berechnen.",
		aTanHDesc: "Mit der Funktion wird der Areatangens Hyperbolicus der Pixel in einem Raster berechnet.",
		aTanName: "ATan",
		aTanSnip: "Den Arkustangens von Zellen in einem Raster berechnen.",
		aTanDesc: "Mit der Funktion wird der Arkustangens der Pixel in einem Raster berechnet.",
		absName: "Abs",
		absSnip: "Den absoluten Wert der Zellen in einem Raster berechnen.",
		absDesc: "Mit der Funktion \"Abs\" wird der absolute Wert der Pixel in einem Raster berechnet.",
		reflectanceName: "Sichtbare Reflexion",
		reflectanceSnip: "Rohe Bilddaten unter Berücksichtigung von Sensoreigenschaften, der Position der Sonne und des Zeitpunktes der Erfassung in Werte für den Oberrand der Atmosphäre konvertieren.",
		reflectanceDesc: "Diese Funktion passt die digitale Nummer (DN) für die Bildhelligkeitswerte für einige Satellitensensoren an. Die Anpassungen basieren auf der Sonnenhöhe, dem Aufnahmedatum und den Sensoreigenschaften, um die Verstärkungs- und Verzerrungseinstellungen für jedes Band festzulegen. Mit dieser Funktion werden die Reflexions- bzw. Helligkeitswerte für bestimmte Satellitenbilder gemäß den Einstellungen für die Szenenbeleuchtung und Sensorverstärkung angepasst. Die Bilder werden an eine theoretische gemeinsame Beleuchtungsbedingung angepasst, sodass weniger Abweichungen zwischen den Szenen von verschiedenen Datumseinstellungen und unterschiedlichen Sensoren bestehen. Dies kann für Bildklassifizierung, Farbausgleich und Mosaikierung nützlich sein. Diese Funktion kann nur für bestimmte Bilder verwendet werden. Die entsprechenden Sensoren sind Landsat MSS, Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 und Pleiades.<div><br/>Die Funktion führt zwei Korrekturen durch. Die erste Korrektur basiert auf den Verstärkungseinstellungen. Die ursprünglichen Helligkeitswerte werden aus den Bildwerten neu erstellt, indem die Verstärkungsgleichung umgekehrt wird. Die zweite Korrektur hängt mit den Unterschieden in Sonnenwinkel und Helligkeit zusammen. Die ursprünglichen Helligkeitswerte werden an eine gemeinsame Beleuchtungsbedingung angepasst, indem Szenen, die bei verschiedenen Beleuchtungsbedingungen aufgenommen wurden, normalisiert werden. Im Allgemeinen gilt, dass der Datentyp des Ausgabebildes mit dem Datentyp des Eingabebilds übereinstimmt, die Ausgabewerte jedoch niedriger als die Eingabewerte sind und in den gültigen Datenbereich eingepasst werden.</div>",
		argStatisticsName: "ArgStatistics",
		argStatisticsSnip: "Arg-Statistiken einschließlich ArgMax, ArgMin, ArgMedian und Dauer berechnen.",
		argStatisticsDesc: "Mit der Funktion werden Arg-Statistiken berechnet. Die Funktion \"ArgStatistics\" umfasst vier Methoden: ArgMax, ArgMin, ArgMedian und Dauer.",
		arithmeticName: "Arithmetisch",
		arithmeticSnip: "Eine arithmetische Operation zwischen zwei Rastern bzw. einem Raster und einem Skalar ausführen.",
		arithmeticDesc: "Mit der Funktion \"Arithmetisch\" wird eine arithmetische Operation zwischen zwei Rastern bzw. einem Raster und einem Skalar oder umgekehrt ausgeführt.",
		aspectSlopeName: "Ausrichtung-Neigung",
		aspectSlopeSnip: "Ein Raster erstellen, das gleichzeitig die Ausrichtung (Richtung) und die Neigung (Steilheit) einer kontinuierlichen Oberfläche anzeigt, wie in einem digitalen Höhenmodell dargestellt.",
		aspectSlopeDesc: "Mit der Funktion \"Ausrichtung-Neigung\" wird ein Raster-Layer erstellt, in dem gleichzeitig die Ausrichtung und die Neigung einer Oberfläche anzeigt werden. Die Funktion \"Ausrichtung\" bestimmt die Neigungsrichtung der maximalen Änderungsrate des Werts von einem Pixel zum jeweiligen benachbarten Pixel. Sie können sich die Ausrichtung also als Neigungsrichtung vorstellen. Die Werte des Ausgabe-Rasters entsprechen der Kompassrichtung der Ausrichtung, die durch einen Farbton dargestellt wird. Die Neigung stellt die Änderungsrate der Höhe für jedes Pixel des digitalen Höhenmodells (DEM) dar. Die Neigung stellt die Steilheit einer Oberfläche dar und wird in Form von drei Klassen symbolisiert, die durch Farbsättigung (Helligkeit) gekennzeichnet werden.<div><br/>Die Pixelwerte im Ausrichtungs-Neigungs-Ausgabe-Raster bezeichnen eine bestimmte Kombination aus Ausrichtung und Neigung. Dabei stehen Pixelwerte unter 20 (grau dargestellt) für eine ebene Fläche. Ausrichtungs-Neigungs-Werte ab 21 werden folgendermaßen in unterschiedlichen Farbsättigungen dargestellt: 21 bis 30: Farbsättigung zur Darstellung einer geringen Neigung, 31 bis 40: Farbsättigung zur Darstellung einer mittleren Neigung, ab 41: Farbsättigung zur Darstellung einer großen Neigung</div>",
		aspectName: "Ausrichtung",
		aspectSnip: "Anzeigen, in welche Richtung ein Pixel weist, wobei 0 Norden darstellt und Winkel im Uhrzeigersinn bis 360 zunehmen.",
		aspectDesc: "Die Funktion \"Ausrichtung\" bestimmt die Neigungsrichtung der maximalen Änderungsrate des Wertes jeder einzelnen Zelle zur jeweiligen Nachbarzelle. Sie können sich die Ausrichtung also als Neigungsrichtung vorstellen. Die Werte des Ausgabe-Rasters bestimmen die Kompassrichtung der Ausrichtung.<div><br/>Die Eingabe für diese Funktion ist das Eingabe-Raster. Die Funktion \"Ausrichtung\" wird oft auf ein digitales Höhenmodell (Digital Elevation Model, DEM) angewendet. Standardmäßig wird die Ausrichtung als Graustufenbild angezeigt. Sie können die Funktion \"Colormap\" hinzufügen, um ein bestimmtes Farbschema anzugeben oder um einem Benutzer bei der Anzeige des Mosaiks zu ermöglichen, die Symbolisierung mit einem eigenen Farbschema zu ändern.</div>",
		tableName: "Attributtabelle",
		tableSnip: "Verwendet zum Benennen und Symbolisieren der Werte in einem Dataset eine Tabelle. Die Spalten für die Tabelle müssen durch Komma getrennt werden: PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "Mit der Funktion \"Attributtabelle\" können Sie eine Attributtabelle definieren, um ein Einzelband-Mosaik-Dataset oder Raster-Dataset zu symbolisieren. <div><br/>Dies ist nützlich, wenn Sie Bilddaten präsentieren möchten, die als Landnutzung klassifiziert wurden, z. B. Waldflächen, Sumpfgebiete, Kulturflächen und Stadtgebiete. Wenn die Tabelle darüber hinaus Felder enthält, die als rot, grün und blau benannt sind, werden beim Rendern des Bildes Werte innerhalb dieser Felder wie eine Colormap verwendet.</div>",
		bandArithmeticName: "Bandarithmetik",
		bandArithmeticSnip: "Indizes mit den vordefinierten Formeln oder einem benutzerdefinierten Ausdruck berechnen.",
		bandArithmeticDesc: "Die Funktion \"Bandarithmetik\" führt eine arithmetische Operation auf den Bändern eines Raster-Datasets aus. Sie können vordefinierte Algorithmen auswählen oder eine eigene einzeilige Formel eingeben. Die unterstützten Operatoren sind -, +, /, * und unäres -.",
		thresholdName: "Binärer Schwellenwert",
		thresholdSnip: "Kontinuierliche Daten in Vordergrund und Hintergrund organisieren, indem die Kovarianz zwischen zwei Klassen minimiert wird.",
		thresholdDesc: "Wenn ein Raster-Dataset eine bimodale Verteilung aufweist, wird mit dieser Funktion ein neues Raster erstellt, das die Daten in zwei unterschiedliche Klassen unterteilt. Es wird eine Klasse mit niedrigen Werten erstellt, die mit schwarzen Pixeln dargestellt wird, und eine Klasse mit hohen Werten, die mit weißen Pixeln dargestellt wird.",
		bitwiseAndName: "Bitwise And",
		bitwiseAndSnip: "Führt eine bitweise AND-Operation für die binären Werte von zwei Eingabe-Rastern aus.",
		bitwiseAndDesc: "Mit \"Bitwise And\" wird eine bitweise AND-Operation für die binären Werte zweier Eingabe-Raster ausgeführt.",
		bitwiseLeftShiftName: "Bitwise Left Shift",
		bitwiseLeftShiftSnip: "Führt eine bitweise LEFT SHIFT-Operation für die binären Werte von zwei Eingabe-Rastern aus.",
		bitwiseLeftShiftDesc: "Mit \"Bitwise Left Shift\" wird eine bitweise LEFT SHIFT-Operation für die binären Werte zweier Eingabe-Raster ausgeführt.",
		bitwiseNotName: "Bitwise Not",
		bitwiseNotSnip: "Führt eine bitweise NOT-Operation (Komplement) für die binären Werte zweier Eingabe-Raster aus.",
		bitwiseNotDesc: "Mit der Funktion wird eine bitweise NOT-Operation (Komplement) für den binären Wert eines Eingabe-Rasters ausgeführt.",
		bitwiseOrName: "Bitwise Or",
		bitwiseOrSnip: "Führt eine bitweise OR-Operation für die binären Werte von zwei Eingabe-Rastern aus.",
		bitwiseOrDesc: "Mit der Funktion wird eine bitweise OR-Operation für die binären Werte zweier Eingabe-Raster ausgeführt. ",
		bitwiseRightShiftName: "Bitwise Right Shift",
		bitwiseRightShiftSnip: "Führt eine bitweise RIGHT SHIFT-Operation für die binären Werte von zwei Eingabe-Rastern aus.",
		bitwiseRightShiftDesc: "Mit der Funktion wird eine bitweise RIGHT SHIFT-Operation für die binären Werte zweier Eingabe-Raster ausgeführt.",
		bitwiseXorName: "Bitwise Xor",
		bitwiseXorSnip: "Führt eine bitweise Operation mit ausschließendem OR für die binären Werte von zwei Eingabe-Rastern aus.",
		bitwiseXorDesc: "Mit der Funktion wird eine bitweise Operation mit ausschließendem OR für die binären Werte zweier Eingabe-Raster ausgeführt.",
		booleanAndName: "Boolean And",
		booleanAndSnip: "Führt eine \"Boolean And\"-Operation für die Zellenwerte von zwei Eingabe-Rastern durch. Wenn beide Eingabewerte TRUE (ungleich 0) sind, lautet der Ausgabewert 1. Wenn eine oder beide Eingaben FALSE (0) sind, lautet der Ausgabewert 0.",
		booleanAndDesc: "Mit der Funktion wird eine boolesche AND-Operation für die Pixelwerte zweier Eingaben ausgeführt. Wenn beide Eingabewerte TRUE (ungleich 0) sind, lautet der Ausgabewert 1. Wenn eine oder beide Eingabewerte FALSE (0) sind, ist der Ausgabewert 0. ",
		booleanNotName: "Boolean Not",
		booleanNotSnip: "Führt eine \"Boolean Not\"-Operation (Komplementoperation) für die Zellenwerte des Eingabe-Rasters durch. Wenn die Eingabewerte TRUE (ungleich 0) sind, lautet der Ausgabewert 1. Wenn die Eingabewerte FALSE (0) sind, lautet die Ausgabe 1.",
		booleanNotDesc: "Mit der Funktion wird eine boolesche NOT-Operation (Komplement) für die Pixelwerte des Eingabe-Rasters ausgeführt. Wenn die Eingabewerte TRUE (ungleich 0) sind, lautet der Ausgabewert 0. Wenn die Eingabewerte FALSE (0) sind, lautet der Ausgabewert 1.",
		booleanOrName: "Boolean Or",
		booleanOrSnip: "Führt eine boolesche OR-Operation für die Zellenwerte zweier Eingabe-Raster aus. Wenn einer oder beide Eingabewerte TRUE (ungleich 0) sind, lautet der Ausgabewert 1. Wenn beide Eingabewerte FALSE (0) sind, lautet der Ausgabewert 0.",
		booleanOrDesc: "Mit der Funktion wird eine boolesche OR-Operation für die Zellenwerte zweier Eingabe-Raster ausgeführt. Wenn einer oder beide TRUE (ungleich 0) sind, lautet der Ausgabewert 1. Wenn beide Eingabewerte FALSE (0) sind, lautet der Ausgabewert 0.",
		booleanXorName: "Boolean XOr",
		booleanXorSnip: "Führt eine Operation mit \"Boolean eXclusive Or\" für die Zellenwerte von zwei Eingabe-Rastern aus. Wenn ein Eingabewert TRUE (ungleich 0) und der andere FALSE (0) ist, lautet die Ausgabe 1. Wenn beide Eingabewerte TRUE oder beide FALSE sind, lautet die Ausgabe 0.",
		booleanXorDesc: "Mit der Funktion wird eine boolesche Operation mit ausschließendem OR für die binären Werte zweier Eingabe-Raster ausgeführt. Wenn ein Eingabewert TRUE (ungleich 0) und der andere Eingabewert FALSE (0) ist, lautet der Ausgabewert 1. Wenn beide Eingabewerte TRUE oder beide FALSE sind, lautet der Ausgabewert 0.",
		bufferedRasterName: "Zwischenspeichern",
		bufferedRasterSnip: "Die zuletzt aufgerufenen Pixelblöcke zwischenspeichern.",
		bufferedRasterDesc: "Die Funktion \"Zwischenspeichern\" dient zur Optimierung der Performance komplexer Funktionsketten. Sie speichert die Ausgaben im Speicher des Teils der Funktionskette, der ihr vorangestellt ist. <div><br/>Fügen Sie diese Funktion im Funktions-Editor an der Stelle ein, an der die Ausgabe gespeichert werden soll.</div>",
		rasterCalculatorName: "Berechnung",
		rasterCalculatorSnip: "Ein Raster über einen Raster-basierten mathematischen Ausdruck berechnen.",
		rasterCalculatorDesc: "Mit der Funktion \"Berechnung\" können Sie Ausdrücke erstellen und diese in Funktionsketten integrieren.",
		cellStatisticsName: "Zellenstatistiken",
		cellStatisticsSnip: "Berechnet eine Pro-Zellen-Statistik für mehrere Raster. Die verfügbaren Statistiken sind: \"Mehrheit\", \"Maximum\", \"Mittelwert\", \"Medianwert\", \"Minimum\", \"Minderheit\", \"Perzentil\", \"Bereich\", \"Standardabweichung\", \"Summe\" und \"Varianz\".",
		cellStatisticsDesc: "Mit dieser Funktion werden Statistiken aus mehreren Rastern auf Pixelbasis berechnet. Die verfügbaren Statistiken sind: \"Mehrheit\", \"Maximum\", \"Mittelwert\", \"Medianwert\", \"Minimum\", \"Minderheit\", \"Bereich\", \"Standardabweichung\", \"Summe\" und \"Varianz\".",
		classifyName: "Klassifizieren",
		classifySnip: "Weist jedes Pixel einer Klasse zu. Es werden Zusatzdaten wie z. B. segmentierte Bilder einbezogen.",
		classifyDesc: "Diese Raster-Funktion klassifiziert ein Raster-Dataset basierend auf einer Esri Classifier Definition-Datei (.ecd) und Raster-Dataset-Eingaben. Die in der Funktion \"Klassifizieren\" verwendete ECD-Datei enthält alle Informationen für ein bestimmtes Dataset und einen bestimmten Klassifikator. Sie wird durch die Trainingswerkzeuge für Klassifizierungen, z. B. das Werkzeug \"Support Vector Machine-Klassifikator trainieren\" oder \"Random Trees-Klassifikator trainieren\", erstellt.",
		clipName: "Ausschneiden",
		clipSnip: "Die Ausdehnung eines Rasters anhand von Koordinaten oder anhand eines anderen Datasets festlegen.",
		clipDesc: "Diese Funktion schneidet ein Raster entsprechend den definierten Ausdehnungen mit einer rechteckigen Form aus oder schneidet ein Raster auf die Form der Feature-Class eines Eingabe-Polygons zu. Das Shape zum Definieren des Ausschnitts kann die Ausdehnung des Rasters oder eine Fläche innerhalb des Rasters ausschneiden.",
		colorspaceConversionName: "Farbmodellkonvertierung",
		colorspaceConversionSnip: "Ein Raster von RGB in HSV konvertieren und umgekehrt.",
		colorspaceConversionDesc: "Die Funktion \"Farbmodellkonvertierung\" konvertiert das Farbmodell eines Bildes vom HSV-Farbraum (Hue, Saturation, Value = Farbton, Sättigung, Helligkeitswert) in RGB (Rot, Grün, Blau) oder umgekehrt.<div><br/>Diese Funktion kann in einem Mosaik-Dataset verwendet werden.</div>",
		colormapToRGBName: "Colormap in RGB",
		colormapToRGBSnip: "Ein Einzelband-Raster mit einer Colormap in ein RGB-Raster (Rot, Grün und Blau) mit drei Bändern konvertieren.",
		colormapToRGBDesc: "Mit dieser Funktion wird ein Einzelband-Raster mit einer Colormap in ein RGB-Raster mit drei Bändern (Rot, Grün und Blau) konvertiert.<div><br/>Diese Funktion ist nützlich, wenn Sie aus einem Einzelband-Raster mit verknüpfter Colormap ein Raster aus drei Bändern erstellen müssen. Mit den Werten in der Colormap wird jeweils das rote, grüne und blaue Band erstellt. Diese Funktion kann in einem Mosaik-Dataset verwendet werden.</div>",
		colormapName: "Colormap",
		colormapSnip: "Die Pixelwerte für die Anzeige der Raster-Daten auf der Grundlage einer Colormap oder eines Farbverlaufs als Graustufen- oder RGB-Bild (Rot, Grün, Blau) ändern.",
		colormapDesc: "Die Funktion \"Colormap\" ist eine Art Raster-Daten-Renderer. Damit werden die Pixelwerte zur Anzeige der Raster-Daten auf der Grundlage eines Farbschemas oder bestimmter Farben in einer Colormap-Datei als Graustufen- oder RGB-Farbbild transformiert. Sie können eine Colormap zur Darstellung analysierter Daten, wie z. B. ein klassifiziertes Bild, oder beim Anzeigen einer topographischen Karte (oder eines gescannten indizierten Farbbildes) verwenden.<div><br/>Colormaps enthalten einen Satz von Werten, die mit Farben verknüpft sind, die verwendet werden, um ein Einzelband-Raster durchgängig mit den gleichen Farben anzuzeigen. Jeder Pixelwert ist einer Farbe zugeordnet, die als Gruppe von RGB-Werten definiert ist. Colormaps unterstützen sämtliche Bittiefen außer Gleitkomma. Zudem unterstützen sie positive und negative Werte; es können auch Colormapwerte fehlen. Bei der Anzeige eines Datasets mit einer Karte, in der Werte fehlen, werden die Pixel mit den fehlenden Werten nicht angezeigt.</div>",
		complexName: "Komplex",
		complexSnip: "Die Größe komplexer Zahlen extrahieren.",
		complexDesc: "Mit der Funktion wird die Größe komplexer Werte berechnet.<div><br/>Diese Funktion wird normalerweise bei RADAR-Bilddaten eines komplexen Datentyps eingesetzt. Sie kann in einem Mosaik-Dataset verwendet werden.</div>",
		compositeBandName: "Bänder zusammensetzen",
		compositeBandSnip: "Kombiniert mehrere Datasets zu einem Multiband-Raster.",
		compositeBandDesc: "Mit der Funktion \"Bänder zusammensetzen\" können Sie Raster kombinieren, sodass sie ein Multiband-Raster bilden.",
		conName: "If-Else-Bedingungen",
		conSnip: "Führt eine konditionale If-Then-Else-Operation durch. Bei der Verwendung einer If-Else-Bedingung müssen üblicherweise mindestens zwei Funktionen miteinander verknüpft werden, wobei in der einen Funktion die Kriterien und in der zweiten Funktion die If-Else-Bedingung unter Verwendung der Kriterien angegeben wird. Letztere schreibt die \"True\"- und \"False\"-Ausgaben vor.",
		conDesc: "Durch die Funktion \"If-Else-Bedingungen\" werden die Pixel des Ausgabe-Rasters auf Grundlage der If-Else-Auswertung der einzelnen Eingabepixel festgelegt. Sie gibt die Pixelwerte aus dem True-Raster zurück, wenn die Bedingungsauswertung \"true\" (1) ergibt, und die Pixelwerte aus dem False-Raster, wenn die Bedingungsauswertung \"false\" (0) lautet. Dieses Kriterium wird durch die Ausgabe einer logischen mathematischen Funktion festgelegt, die dem Eingabe-Raster entspricht.",
		constantName: "Konstante",
		constantSnip: "Ein virtuelles Raster mit einem einzelnen Pixelwert erstellen.",
		constantDesc: "Mit dieser Funktion wird ein virtuelles Raster mit einem einzelnen Pixelwert erstellt, das in Raster-Funktionsvorlagen und zum Verarbeiten eines Mosaik-Datasets verwendet werden kann.<div><br/>Der konstante Wert wird für alle Pixelwerte im Raster verwendet.</div>",
		contourName: "Konturlinie",
		contourSnip: "Konturlinien erstellen.",
		contourDesc: "Mit der Konturlinienfunktion werden Konturlinien erstellt, indem Punkte mit derselben Höhe aus einem Raster-Höhen-Dataset verbunden werden. Die Konturlinien sind Isolinien, die zum Visualisieren als Raster erstellt werden. Die Leistungsfähigkeit dieser Funktion gründet auf den folgenden zentralen Aspekten: Konturlinien werden für große Datasets wie World Elevation schnell und dynamisch erstellt; Konturlinien können geglättet werden, um ein kartografisch ansprechenderes Aussehen unter Beibehaltung der Genauigkeit der Konturlinien zu erzielen; dynamische Kontrolle über das bereitgestellte Konturlinienintervall; mögliche Ausgaben sind Konturlinien, Indexkonturlinien und gefüllte Konturlinien.<div><br/>Die Erstellung eines Konturlinien-Layers als Raster-Produkt ist für eine breite Palette von Anwendungen wertvoll, da die Konturlinien auf einer Karte überlagert werden können und viele Informationen zum Terrain bereitstellen, ohne die zugrunde liegenden Daten zu verdecken. Sie sind hilfreich bei Anwendungen wie Entwicklung, Landwirtschaft und Wasserbewirtschaftung.</div>",
		contrastBrightnessName: "Kontrast und Helligkeit",
		contrastBrightnessSnip: "Den Kontrast und die Helligkeit eines Rasters anpassen.",
		contrastBrightnessDesc: "Mit der Funktion \"Kontrast und Helligkeit\" kann das Aussehen von Raster-Daten durch Änderung von Helligkeit und/oder Kontrast im Bild verbessert werden. Durch Helligkeit wird die Gesamthelligkeit des Bildes erhöht (dunkle Farben werden aufgehellt, helle Farben werden weißer) und mit Kontrast wird der Unterschied zwischen den dunkelsten und hellsten Farben eingestellt.<div><br/>Mit dieser Funktion werden die Pixelwerte geändert. Daher sollte die Funktion verwendet werden, wenn Sie das Aussehen der Daten verbessern, diese jedoch nicht in Analysen verwenden möchten, für die die unbearbeiteten Pixelwerte benötigt werden. Diese Funktion ist geeignet, wenn Sie die Daten als Image-Service veröffentlichen, der in Anwendungen ohne Funktion zum Ändern von Kontrast und Helligkeit der Bilder verwendet werden kann, oder um sicherzustellen, dass die Anzeige tatsächlich mit den bevorzugten Einstellungen erfolgt.</div>",
		convolutionName: "Faltung",
		convolutionSnip: "Einen Filter zum Schärfen, Weichzeichnen, Erkennen von Kanten oder Glätten bzw. einen Gradient in einem Raster anwenden.",
		convolutionDesc: "Die Funktion \"Faltung\" führt die Filterung der Pixelwerte in einem Bild aus, z. B. für das Scharf- oder Weichzeichnen eines Bildes, für das Ermitteln der Kanten in einem Bild oder für andere Kernel-basierte Verbesserungen. Filter werden verwendet, um die Qualität eines Raster-Bilds durch das Entfernen von unkorrekten Daten oder durch die Erweiterung von Features in den Daten zu verbessern Diese Faltungsfilter werden auf einen bewegten, überlappenden Kernel (Fenster oder Nachbarschaft) angewendet (z. B. 3 x 3). Die Funktion \"Faltung\" filtert Ihre Arbeit durch eine Berechnung des Pixelwertes auf Grundlage der Gewichtung seiner Nachbarn..",
		corridorName: "Korridor",
		corridorSnip: "Berechnet die Summe der akkumulativen Kosten für zwei akkumulative Eingabe-Raster.",
		corridorDesc: "Mit der Funktion \"Korridor\" wird die Summe der akkumulativen Kosten für zwei Eingabe-Raster mit akkumulativen Kosten berechnet. Es können zwar zwei beliebige Raster für die Eingabe verwendet werden; um ein sinnvolles Ergebnis zu erhalten, sollte es sich dabei jedoch um unveränderte akkumulative Kosten-Ausgabe-Raster handeln. Die Reihenfolge der beiden Eingaben ist irrelevant.",
		cosHName: "CosH",
		cosHSnip: "Den Kosinus Hyperbolicus von Zellen in einem Raster berechnen.",
		cosHDesc: "Mit der Funktion wird der Kosinus Hyperbolicus der Pixel in einem Raster berechnet.",
		cosName: "Cos",
		cosSnip: "Berechnet den Kosinus einer Zelle in einem Raster.",
		cosDesc: "Mit der Funktion wird der Kosinus der Pixel in einem Raster berechnet.",
		costAllocationName: "Kostenzuordnung",
		costAllocationSnip: "Berechnet für jede Zelle die kostengünstigste Quelle basierend auf den kleinsten akkumulativen Kosten auf einer Kostenoberfläche.",
		costAllocationDesc: "Mit der Funktion \"Kostenzuweisung\" wird für jede Zelle die kostengünstigste Quelle auf Basis der geringsten akkumulativen Kosten auf einer Kostenoberfläche berechnet.",
		costBackLinkName: "Kostenrückverknüpfung",
		costBackLinkSnip: "Definiert die nächste Nachbarzelle auf dem kleinsten akkumulativen Kostenpfad zur kostengünstigsten Quelle.",
		costBackLinkDesc: "Mit der Funktion \"Kostenrückverknüpfung\" wird die nächste Nachbarzelle auf dem Pfad mit den geringsten akkumulativen Kosten zur kostengünstigsten Quelle definiert.<div><br/>Das Rückverknüpfungs-Raster enthält Werte von null bis acht. Mit diesen Werten wird die Richtung definiert oder die nächste angrenzende Zelle (die nachfolgende Zelle) entlang des Kostenpfads mit den geringsten akkumulativen Kosten von einer Zelle zur entsprechenden kostengünstigsten Quelle angegeben. Wenn der Pfad in die rechte benachbarte Zelle übergeht, wird der Zelle der Wert 1 zugeordnet, gefolgt von 2 für die diagonal rechts unten angeordnete Zelle. Die folgenden Zellen werden im Uhrzeigersinn nummeriert. Der Wert 0 ist für die Quellenzellen reserviert.</div>",
		costDistanceName: "Kostenentfernung",
		costDistanceSnip: "Berechnet für jede Zelle die kleinste akkumulative Kostenentfernung von oder zur kostengünstigsten Quelle auf einer Kostenoberfläche.",
		costDistanceDesc: "Mit der Funktion \"Kostenentfernung\" wird die kleinste akkumulative Kostenentfernung für jede Zelle von oder zur kostengünstigsten Quelle auf einer Kostenoberfläche berechnet.",
		costPathName: "Kostenpfad",
		costPathSnip: "Berechnet den kostengünstigsten Pfad von einer Quelle zu einem Ziel.",
		costPathDesc: "Mit der globalen Funktion \"Kostenpfad\" wird der kostengünstigste Pfad von einer Quelle zu einem Ziel berechnet.<div><br/>Mit dieser Funktion wird ein Ausgabe-Raster erzeugt, das den/die kostengünstigsten Pfad(e) von ausgewählten Positionen zur jeweils nächstgelegenen Quellenzelle aufzeichnet, die innerhalb der akkumulativen Kostenoberfläche definiert wurden (hinsichtlich der Kostenentfernung).</div>",
		curvatureName: "Krümmung",
		curvatureSnip: "Berechnet die Krümmung einer Raster-Oberfläche, optional mit Vertikal- und Horizontalkrümmung.",
		curvatureDesc: "Mit der Funktion \"Krümmung\" wird die Form oder Krümmung der Neigung angezeigt. Ein Teil einer Oberfläche kann konkav oder konvex sein, was Sie am Krümmungswert erkennen. Die Krümmung wird berechnet, indem die zweite Ableitung der Oberfläche ermittelt wird.<div><br/>Die Ausgabe der Funktion \"Krümmung\" dient dem Beschreiben der physischen Merkmale eines Wassereinzugsgebiets bei dem Versuch, Erosions- und Drainageprozesse nachzuvollziehen. Der Krümmungswert kann verwendet werden, um Bodenerosionsmuster zu finden und die Wasserverteilung auf dem Land zu ermitteln. Die Vertikalkrümmung wirkt sich auf die Fließbeschleunigung und -verlangsamung aus und beeinflusst dadurch Erosion und Ablagerungen. Die Horizontalkrümmung beeinflusst die Fließkonvergenz und -divergenz.</div>",
		divideName: "Divide",
		divideSnip: "Die Werte von zwei Rastern auf Zellenbasis teilen.",
		divideDesc: "Mit der Funktion \"Divide\" werden die Werte zweier Raster auf Pixelbasis dividiert.",
		elevationVoidFillName: "Lückenfüllung für Höhen",
		elevationVoidFillSnip: "Pixel in Bereichen erstellen, wo in Ihren Höhendaten Löcher vorhanden sind.",
		elevationVoidFillDesc: "Die Funktion \"Lückenfüllung für Höhen\" wird verwendet, um Pixel für Bereiche zu erstellen, wo in Ihren Höhendaten Löcher vorhanden sind.<div><br/>Lücken treten auf, wenn es keine Punkte gibt, die auf der durch ein Pixel dargestellten Fläche im resultierenden Raster erfasst wurden. Lücken werden oft von Gewässern, Klassentypauswahl oder Ausschluss verursacht. Beim Generieren einer Bodenoberfläche wird die Lückenfüllung am häufigsten verwendet.</div>",
		equalToName: "Equal To",
		equalToSnip: "Führt auf Zellenbasis eine relationale \"Equal To\"-Operation für zwei Eingaben aus. Gibt 1 für Zellen zurück, bei denen das erste Raster mit dem zweiten Raster identisch ist, andernfalls 0.",
		equalToDesc: "Mit der Funktion wird auf Pixelbasis eine \"Equal To\"-Operation für zwei Raster ausgeführt. Sie gibt den Wert 1 für Pixel zurück, bei denen das erste Raster mit dem zweiten Raster identisch ist, andernfalls 0.",
		eucAllocationName: "Euklidische Zuordnung",
		eucAllocationSnip: "Berechnet für jede Zelle die nächstgelegene Quelle auf Basis der euklidischen Entfernung.",
		eucAllocationDesc: "Mit der Funktion \"Euklidische Zuordnung\" wird für jede Zelle die nächstgelegene Quelle auf Basis der euklidischen Entfernung berechnet.",
		eucDirectionName: "Euklidische Richtung",
		eucDirectionSnip: "Berechnet für jede Zelle die Richtung in Grad zur nächstgelegenen Quelle.",
		eucDirectionDesc: "Mit der Funktion \"Euklidische Richtung\" wird für jede Zelle die Richtung in Grad zur nächstgelegenen Quelle berechnet. <div><br/>Die Richtung wird vom jeweiligen Zellenmittelpunkt bis zum Mittelpunkt der nächstgelegenen Quellenzelle berechnet. Der Wertebereich reicht von 0 Grad bis 360 Grad, wobei 0 Grad für die Quellenzellen reserviert ist. In östlicher Richtung (rechts) befindet sich der 90-Grad-Winkel, und die Werte nehmen im Uhrzeigersinn zu (180 Grad ist Süden, 270 Grad ist Westen und 360 Grad ist Norden).</div>",
		eucDistanceName: "Euklidische Entfernung",
		eucDistanceSnip: "Berechnet für jede Zelle die euklidische Entfernung zur nächstgelegenen Quelle.",
		eucDistanceDesc: "Mit der Funktion \"Euklidische Entfernung\" wird für jede Zelle die euklidische Entfernung zur nächstgelegenen Quelle berechnet.",
		exp10Name: "Exp10",
		exp10Snip: "Die Exponentialfunktion zur Basis 10 der Zellen in einem Raster berechnen.",
		exp10Desc: "Mit der Funktion \"Exp 10\" wird die Exponentialfunktion zur Basis 10 der Pixel in einem Raster berechnet.",
		exp2Name: "Exp2",
		exp2Snip: "Die Exponentialfunktion zur Basis 2 der Zellen in einem Raster berechnen.",
		exp2Desc: "Mit dieser Funktion wird die Exponentialfunktion zur Basis 2 der Pixel in einem Raster berechnet.",
		expName: "Exp",
		expSnip: "Die Exponentialfunktion zur Basis e der Zellen in einem Raster berechnen.",
		expDesc: "Mit dieser Funktion wird die Exponentialfunktion zur Basis e der Pixel in einem Raster berechnet.",
		extractBandName: "Bänder extrahieren",
		extractBandSnip: "Festlegen, mit welchen Bändern bei Verwendung von Multiband-Datasets gearbeitet werden soll.",
		extractBandDesc: " Mit der Funktion \"Bänder extrahieren\" können Sie ein oder mehrere Bänder aus einem Multiband-Raster-Dataset extrahieren bzw. die Bänder neu anordnen.<div><br/>Sie können diese Funktion vor anderen Funktionen wie z. B. \"Arithmetisch\" verwenden, um festzulegen, welche Bänder als Eingabe für die folgende Funktion verwendet werden</div>",
		fillName: "Füllung",
		fillSnip: "Senken in einem Oberflächen-Raster füllen, um alle Unregelmäßigkeiten in den Daten zu entfernen.",
		fillDesc: "Mit der globalen Funktion \"Füllung\" werden Senken und Spitzen in einem Raster für Höhenoberflächen gefüllt, um kleine Unregelmäßigkeiten in den Daten zu beseitigen. Die Funktion führt die Füllung als iterativen Vorgang aus, bis alle Senken innerhalb des angegebenen Z-Limits gefüllt sind.<div><br/>Wenn eine Höhenoberfläche mit den Ortho Mapping-Werkzeugen o. Ä. erstellt wird, treten häufig signifikante Fehler in Form von Senken und Spitzen in den Daten auf. Im Zusammenhang mit der Luftbildmessung werden Senken und Spitzen häufig als Löcher und Spitzen bezeichnet. Da Oberflächendaten oft bei der Modellierung, z. B. hydrologische Modellierung, verwendet werden, ist es wichtig, diese Senken- und Spitzenfehler so zu korrigieren, dass sie mit den umgebenden Daten konsistent sind.</div>",
		floatName: "Float",
		floatSnip: "Konvertiert jeden Zellenwert eines Rasters in eine Gleitkommadarstellung.",
		floatDesc: "Die Funktion \"Float\" konvertiert jeden Pixelwert eines Rasters in eine Gleitkommadarstellung.",
		flowAccumulationName: "Abflussakkumulation",
		flowAccumulationSnip: "Erstellt für jede Zelle ein Raster der Abflussakkumulation. Optional kann ein Gewichtungsfaktor angewendet werden.",
		flowAccumulationDesc: "Mit der globalen Funktion \"Abflussakkumulation\" wird ein Raster der Abflussakkumulation zu jedem Pixel erstellt. Bestimmt wird dies durch das Akkumulieren der Gewichtung für alle Pixel, die in einzelne tiefer gelegene Pixel fließen. Wenn kein Gewichtungs-Raster angegeben ist, wird eine Gewichtung von 1 auf die Pixel angewendet, und der Wert der Pixel im Ausgabe-Raster entspricht der Anzahl von Pixeln, die in jedes Pixel fließen.<div><br/>Ausgabepixel mit einer hohen Abflussakkumulation sind Flächen konzentrierten Flusses und können verwendet werden, um Wasserlaufkanäle zu identifizieren. Ausgabepixel mit einer Abflussakkumulation von 0 sind lokale topographische Höhen und können verwendet werden, um Bergkämme zu identifizieren.</div>",
		flowDirectionName: "Fließrichtung",
		flowDirectionSnip: "Ein Raster mit der Fließrichtung von jeder Zelle zur jeweiligen Nachbarzelle mit der steilsten Neigung erstellen.",
		flowDirectionDesc: "Eine der Hauptvoraussetzungen für das Ableiten hydrologischer Eigenschaften einer Oberfläche besteht darin, die Fließrichtung aus den einzelnen Pixeln im Raster bestimmen zu können. Die Raster-Funktion \"Fließrichtung\" verwendet eine Oberfläche als Eingabe und erstellt ein Fließrichtungs-Raster von jedem Pixel zu seinem jeweils tiefer gelegenen Nachbarn mit der steilsten Neigung. Die Funktion \"Fließrichtung\" unterstützt drei Modellierungsmethoden: D8 (acht Richtungen), Multiple Flow Direction (MFD) und D-Infinity (DINF). ",
		flowDistanceName: "Fließentfernung",
		flowDistanceSnip: "Für jede Zelle die minimale horizontale oder vertikale Neigungsentfernung zu Zellen eines Wasserlaufs oder Flusses berechnen.",
		flowDistanceDesc: "Die Funktion berechnet die minimale horizontale oder vertikale Neigungsentfernung zu Pixeln eines Wasserlaufs oder Flusses, in den sie fließen. Wenn ein optionales Fließrichtungs-Raster angegeben wird, werden nur die Neigungsrichtungen berücksichtigt, die durch das Eingabe-Fließrichtungs-Raster definiert werden. Die Ausgabe ist ein Raster für die Fließentfernung.",
		focalName: "Focal Statistics",
		focalSnip: "Berechnet auf der Grundlage einer definierten Fokusnachbarschaft die Fokusstatistiken für jedes Pixel eines Bildes.",
		focalDesc: "Mit der Funktion \"Focal Statistics\" wird die Fokusstatistik für jedes Pixel eines Bildes auf der Grundlage einer definierten Fokusnachbarschaft berechnet.",
		geometricName: "Geometrisch",
		geometricSnip: "Die Positionsgenauigkeit eines Datasets durch Berücksichtigung der Höhe steigern.",
		geometricDesc: "Die Funktion \"Geometrisch\" erzeugt auf Grundlage einer Sensordefinition und eines Terrainmodells ein orthorektifiziertes Bild. Sie erhöht die Positionsgenauigkeit eines Datasets durch Berücksichtigung der Höhe.",
		grayscaleName: "Graustufen",
		grayscaleSnip: "Konvertiert ein Multiband-Bild in ein Einzelband-Graustufen-Bild.",
		grayscaleDesc: "Mit dieser Funktion wird ein Multiband-Bild in ein Einzelband-Bild in Graustufen konvertiert.<div><br/>Bei dieser Funktion werden angegebene Gewichtungen auf die einzelnen Eingabebänder angewendet, dann wird das Ausgabebild normalisiert. Gewichtungen werden häufig angewendet, weil einige Bänder eine unterschiedliche Wichtigkeit je nach Anwendung haben. Das blaue Band enthält z. B. mehr Rauschen als andere Bänder.</div>",
		greaterThanEqualName: "Greater Than Equal",
		greaterThanEqualSnip: "Führt auf Zellenbasis eine relationale \"Greater Than or Equal To\"-Operation für zwei Eingaben aus. Gibt 1 für Zellen zurück, bei denen das erste Raster größer als das zweite Raster oder gleich ist, andernfalls 0.",
		greaterThanEqualDesc: "Mit der Funktion wird auf Pixelbasis eine relationale \"Greater Than or Equal To\"-Operation für zwei Eingaben ausgeführt. Sie gibt den Wert 1 für Pixel zurück, bei denen das erste Raster größer als das zweite Raster oder gleich ist, und den Wert 0 für Pixel, bei denen das erste Raster kleiner als oder genauso groß wie das zweite Raster ist.",
		greaterThanName: "Greater Than",
		greaterThanSnip: "Führt auf Zellenbasis eine relationale \"Greater Than\"-Operation für zwei Eingaben aus. Gibt 1 für Zellen zurück, bei denen das erste Raster größer ist als das zweite Raster, andernfalls 0.",
		greaterThanDesc: "Mit der Funktion wird auf Pixelbasis eine relationale \"Greater Than\"-Operation für zwei Eingaben ausgeführt. Gibt den Wert 1 für Pixel zurück, bei denen das erste Raster größer als das zweite Raster ist, und gibt den Wert 0 für Pixel zurück, bei denen das erste Raster nicht größer als das zweite Raster ist.",
		heatIndexName: "Hitzeindex",
		heatIndexSnip: "Kombiniert Umgebungstemperatur der Luft und relative Feuchtigkeit, um die gefühlte Temperatur zurückzugeben.",
		heatIndexDesc: "Mit dieser Funktion wird die gefühlte Temperatur basierend auf der Umgebungstemperatur und der relativen Feuchtigkeit berechnet. Die gefühlte Temperatur wird häufig als Wärme beschrieben, wie sie vom menschlichen Körper empfunden wird.<div><br/>Dieser Hitzeindex kann bei der Berechnung von Gefahren im Zusammenhang mit medizinischen Problemen hilfreich sein, z. B. Muskelkrämpfe, Dehydrierung, Hitzeschäden oder schwerwiegendere Hitzeschläge an heißen und feuchten Tagen. Wenn die relative Luftfeuchtigkeit hoch ist, wird die Verdunstung des Schweißes für den Körper zunehmend schwieriger und Menschen haben keine Möglichkeit, sich auf natürliche Weise abzukühlen. Karten mit Empfehlungen und Warnungen bei Hitze sind häufig ein Produkt der Reklassifizierung des Hitzeindexergebnisses in Klassen. Je höher der Indexwert, desto wahrscheinlicher wird daraus eine Warnung statt eine Empfehlung.</div>",
		hillshadeName: "Schummerung",
		hillshadeSnip: "Erstellt eine 3D-Darstellung der Oberfläche, wobei die relative Position der Sonne beim Schummern des Bildes berücksichtigt wird.",
		hillshadeDesc: "Die Funktion \"Schummerung\" erzeugt eine Graustufen-3D-Darstellung der Terrain-Oberfläche, wobei die relative Position der Sonne beim Schummern des Bildes berücksichtigt wird. <div><br/>Schummerung ist eine Methode zum Visualisieren von Terrain, das durch eine Lichtquelle und die Neigung und Ausrichtung der Höhenoberfläche bestimmt wird. Es handelt sich um eine qualitative Methode zum Visualisieren von Topografie, die keine absoluten Höhenwerte liefert. </div>",
		intName: "Int",
		intSnip: "Konvertiert die einzelnen Zellenwerte eines Rasters durch Kürzung in eine ganze Zahl.",
		intDesc: "Die Funktion \"Int\" konvertiert die einzelnen Pixelwerte eines Rasters durch Kürzung in eine ganze Zahl.",
		interpolateIrregularDataName: "Unregelmäßige Daten interpolieren",
		interpolateIrregularDataSnip: "Interpoliert aus Punktwolken oder unregelmäßigen Gittern.",
		interpolateIrregularDataDesc: "In einigen netCDF- oder HDF-Datasets wird die Geolokalisierung in Form von unregelmäßig angeordneten Arrays aus Pixeln oder Punktdaten gespeichert. Beim Hinzufügen dieser Datasets zu einem Mosaik-Dataset wird von der Funktion \"Unregelmäßige Daten interpolieren\" ein Resampling der unregelmäßig gerasterten Daten durchgeführt, sodass jedes Pixel die gleiche Größe und eine rechteckige Form erhält.<div><br/>Beim Hinzufügen von Variablen aus netCDF oder HDF zu einem Mosaik-Dataset wird automatisch geprüft, ob die Daten in einem regelmäßigen Array angeordnet sind. Falls dies nicht der Fall ist, können die unregelmäßigen Daten mit der Funktion \"Unregelmäßige Daten interpolieren\" in ein regelmäßiges Raster umgewandelt werden. Sie können die verwendete Interpolationsmethode und Zellengröße in der Funktion \"Unregelmäßige Daten interpolieren\" ändern. Bei regelmäßig angeordneten Raster-Daten findet keine Interpolation statt, die Daten werden in ihrem gegenwärtigen Zustand gelesen.</div>",
		isNullName: "Ist Null",
		isNullSnip: "Ermittelt auf Zellenbasis, welche Werte in den Eingabe-Rastern den Wert \"NoData\" aufweisen. Gibt den Wert 1 zurück, wenn die Eingabewerte \"NoData\" lauten, andernfalls 0.",
		isNullDesc: "Mit der Funktion \"Is Null\" wird auf Pixelbasis ermittelt, welche Werte im Eingabe-Raster den Wert \"NoData\" aufweisen. Sie gibt den Wert 1 zurück, wenn der Eingabewert \"NoData\" lautet, und den Wert 0 für Pixel, bei denen der Eingabewert nicht \"NoData\" lautet.",
		kernelDensityName: "Kerndichte",
		kernelDensitySnip: "Berechnet mit einer Kernel-Funktion eine Magnitude pro Flächeneinheit aus Punkt- oder Polylinien-Features, um für jeden Punkt bzw. jede Polylinie eine sanft abgeschrägte Oberfläche anzupassen.",
		kernelDensityDesc: "Mit dieser Funktion wird anhand einer Kernel-Funktion die Größe pro Flächeneinheit auf Basis von Punkt- oder Polylinien-Features berechnet, um für jeden Punkt bzw. jede Polylinie eine sanft abgeschrägte Oberfläche anzupassen.",
		keyMetadataName: "Schlüsselmetadaten",
		keyMetadataSnip: "Schlüsselmetadaten eines Rasters werden in eine Funktionskette eingefügt oder darin überschrieben.",
		keyMetadataDesc: "Mit dieser Funktion können Sie Schlüsselmetadaten eines Rasters einfügen oder überschreiben.<div><br/>Durch die Informationen in den Schlüsselmetadaten wird die Anwendung bei der Verarbeitung und dem Rendern unterstützt, darunter beim Bereitstellen nützlicher Informationen, z. B. von mit den Bilddaten verknüpften Sensornamen und Bandnamen oder der verknüpften Wolkenbedeckung.</div>",
		shortestPathName: "Kostengünstigster Pfad",
		shortestPathSnip: "Kostenentfernungsanalyse mithilfe von Quell- und Zieleingabe durchführen, die dann zum Ermitteln des kostengünstigsten Pfads von einer Quelle zu einem Ziel verwendet wird.",
		shortestPathDesc: "Mit der Funktion \"Kostengünstigster Pfad\" wird der kostengünstigste Pfad von einer Quelle zu einem Ziel berechnet. Die kleinste akkumulative Kostenentfernung wird für jedes Pixel über eine Kostenoberfläche zur nächstgelegenen Quelle berechnet. Dadurch wird ein Ausgabe-Raster erzeugt, das den/die kostengünstigsten Pfad(e) von ausgewählten Positionen zu den nächsten Quellpixeln aufzeichnet, die innerhalb der akkumulativen Kosten-Oberfläche definiert wurden (hinsichtlich der Kostenentfernung).<div><br/>Jedem kostengünstigen Pfad wird ein Wert zugewiesen, wenn sie beim Scanvorgang gefunden wird. Dem Endpixel im Quell-Raster eines Kostenpfades wird der Wert 1 zugewiesen. Dem ersten Pfad wird der Wert 3, dem zweiten der Wert 4 usw. zugewiesen. Wenn mehrere Pfade zusammenlaufen und für die verbleibende Entfernung zurück zu einer Quelle denselben Pfad verwenden, wird dem Segment, in dem die beiden Pfade zusammen verlaufen, der Wert 2 zugewiesen. Dem zusammengeführten Teil des Pfades kann nicht der Wert eines der Pfade zugewiesen werden, da der zusammengeführte Teil zu beiden Pfaden gehört.</div>",
		lessThanEqualName: "Less Than Equal",
		lessThanEqualSnip: "Führt auf Zellenbasis eine relationale \"Less Than or Equal To\"-Operation für zwei Eingaben aus. Gibt 1 für Zellen zurück, bei denen das erste Raster kleiner als das zweite Raster oder gleich ist, andernfalls 0.",
		lessThanEqualDesc: "Mit der Funktion wird auf Pixelbasis eine relationale \"Less Than or Equal To\"-Operation für zwei Raster ausführt. Sie gibt den Wert 1 für Pixel zurück, bei denen das erste Raster kleiner als das zweite Raster oder gleich ist, und den Wert 0 für Pixel, bei denen das erste Raster größer als das zweite Raster ist.",
		lessThanName: "Less Than",
		lessThanSnip: "Führt auf Zellenbasis eine relationale \"Less Than\"-Operation für zwei Eingaben aus. Gibt 1 für Zellen zurück, bei denen das erste Raster kleiner als das zweite Raster ist, andernfalls gibt es 0 zurück.",
		lessThanDesc: "Mit der Funktion wird auf Pixelbasis eine relationale \"Less Than\"-Operation für zwei Eingaben ausführt. Sie gibt den Wert 1 für Pixel zurück, bei denen das erste Raster kleiner als das zweite Raster ist, und den Wert 0 für Pixel, bei denen das erste Raster nicht kleiner als das zweite Raster ist.",
		lnName: "Ln",
		lnSnip: "Den natürlichen Logarithmus (Basis e) von Zellen in einem Raster berechnen.",
		lnDesc: "Mit der Funktion \"Ln\" wird der natürliche Logarithmus (Basis e) der einzelnen Pixel in einem Raster berechnet.",
		log10Name: "Log10",
		log10Snip: "Den Logarithmus der Basis 10 von Zellen in einem Raster berechnen.",
		log10Desc: "Mit der Funktion \"Log10\" wird der Logarithmus der Basis 10 der einzelnen Pixel in einem Raster berechnet.",
		log2Name: "Log2",
		log2Snip: "Den Logarithmus der Basis 2 von Zellen in einem Raster berechnen.",
		log2Desc: "Mit der Funktion \"Log2\" wird der Logarithmus der Basis 2 der einzelnen Pixel in einem Raster berechnet.",
		lookupName: "Lookup",
		lookupSnip: "Erstellt ein neues Raster durch die Suche nach Werten in einem anderen Feld in der Tabelle des Eingabe-Rasters.",
		lookupDesc: "Die Funktion erstellt durch die Suche nach Werten aus einem anderen Feld in der Tabelle des Eingabe-Rasters ein neues Raster.",
		mlClassifyName: "ML-Klassifizierung",
		mlClassifySnip: "Klassifiziert Bilddaten, wobei die Klassifizierung pro Pixel erfolgt. Gemischte Pixel werden dem Feature mit dem höchsten Prozentsatz in diesem Pixel zugewiesen.",
		mlClassifyDesc: "Mit der Funktion \"ML-Klassifizierung\" können Sie eine überwachte Klassifizierung mithilfe des Maximum-Likelihood-Klassifizierungsalgorithmus für ein Raster-Dataset oder ein Mosaik-Dataset ausführen.  Für diese Funktion ist eine Klassifizierungs-Signaturdatei erforderlich.",
		maskName: "Maske",
		maskSnip: "Werte festlegen, die nicht angezeigt werden sollen.",
		maskDesc: "Mit dieser Raster-Funktion werden Werte festgelegt, die nicht im Raster angezeigt werden sollen. Mithilfe der Funktion \"Maske\" können Sie einen oder mehrere NoData-Werte oder einen Bereich gültiger Pixelwerte angeben. ",
		minusName: "Minus",
		minusSnip: "Den Wert des zweiten Eingabe-Rasters vom Wert des ersten Eingabe-Rasters auf Zellenbasis subtrahieren.",
		minusDesc: "Mit der Funktion \"Minus\" wird der Wert des zweiten Eingabe-Rasters vom Wert des ersten Eingabe-Rasters auf Pixelbasis subtrahiert.",
		modName: "Mod",
		modSnip: "Den Rest (Modulo) der Teilung des ersten Rasters durch das zweite Raster auf Zellenbasis ermitteln.",
		modDesc: "Mit der Funktion \"Mod\" wird auf Pixelbasis der Rest (Modulo) der Teilung des ersten Rasters durch das zweite Raster ermittelt. Die Reihenfolge der Eingaben ist wichtig und wirkt sich auf das Ausgabeergebnis aus.",
		mosaicRastersName: "Raster mosaikieren",
		mosaicRastersSnip: "Fügt eine Reihe von Raster-Datasets zusammen, um ein Dataset zu erstellen.",
		mosaicRastersDesc: "Mit der Funktion \"Raster mosaikieren\" wird ein Mosaikbild aus mehreren Bildern zusammengefügt. Wenn sich die Bilder überlappen, stehen mehrere Methoden zur Auswahl, um festzulegen, welche Bilder angezeigt werden.",
		ndviColorizedName: "Farbgebung durch NDVI",
		ndviColorizedSnip: "Ein Multiband-Dataset erstellen, das den Gesundheitszustand der Vegetation basierend auf dem Unterschied zwischen dem roten und dem infrarotnahen Band darstellt.",
		ndviColorizedDesc: "Die Funktion \"Farbgebung durch NDVI\" wendet die Funktion \"NDVI\" auf das Eingabebild an und verwendet anschließend eine Colormap oder einen Farbverlauf, um das Ergebnis anzuzeigen.",
		ndviName: "NDVI",
		ndviSnip: "Berechnet den normalisierten differenzierten Vegetationsindex (Normalized Difference Vegetation Index, NDVI).",
		ndviDesc: "Die Funktion \"NDVI\" erstellt ein Multiband-Dataset, das den Vegetationszustand basierend auf dem Unterschied zwischen dem roten und dem nahinfraroten Band darstellt.<div><br/>NDVI ist ein standardisierter Index, der Ihnen das Erstellen eines Bildes mit Grünanteilen (die sog. relative Biomasse) ermöglicht. Dieser Index nutzt den Kontrast der Eigenschaften zweier Bänder aus einem multispektralen Raster-Dataset: die Absorption durch die Chlorophyllpigmente im roten Band und den Pflanzen-Reflexionsgrad im nahinfraroten Band (NIR). Äußerst niedrige oder negative NDVI-Werte stehen für Bereiche ohne Vegetation wie Wolken, Wasser oder Schnee. Sehr niedrige Werte stehen für Bereiche mit wenig oder ohne Vegetation, wie Beton, Stein oder nackter Erde. Mittlere Werte stehen für Bereiche mit Strauch- und Grasflächen. Hohe Werte stehen für Bereiche mit Forstflächen und üppiger Vegetation.</div>",
		negateName: "Negate",
		negateSnip: "Das Vorzeichen der Zellenwerte des Eingabe-Rasters (Multiplikation mit -1) auf Zellenbasis ändern.",
		negateDesc: "Durch die Funktion \"Negate\" wird das Vorzeichen der Zellenwerte des Eingabe-Rasters auf Pixelbasis geändert (Multiplikation mit -1). ",
		nibbleName: "Nibble",
		nibbleSnip: "Ersetzt die Zellen eines Rasters entsprechend einer Maske durch die Werte der nächsten Nachbarn.",
		nibbleDesc: "Mit der globalen Funktion \"Nibble\" kann ausgewählten Bereichen eines Rasters der Wert des nächsten Nachbarn zugewiesen werden. Dies ist für die Bearbeitung von Raster-Flächen, deren Daten möglicherweise fehlerhaft sind.",
		notEqualName: "Not Equal",
		notEqualSnip: "Führt auf Zellenbasis eine relationale \"Not Equal To\"-Operation für zwei Eingaben aus. Gibt 1 für Zellen zurück, bei denen das erste Raster nicht mit dem zweiten Raster identisch ist, andernfalls 0.",
		notEqualDesc: "Mit der Funktion wird auf Pixelbasis eine relationale \"Not Equal To\"-Operation für zwei Eingaben ausführt. Sie gibt den Wert 1 für Pixel zurück, bei denen das erste Raster ungleich dem zweiten Raster ist, und den Wert 0 für Pixel, bei denen das erste Raster gleich dem zweiten Raster ist.",
		pansharpeningName: "Pansharpen",
		pansharpeningSnip: "Die räumliche Auflösung eines Multiband-Bildes wird durch Verschmelzen mit einem panchromatischen Bild mit höherer Auflösung künstlich verbessert.",
		pansharpeningDesc: "Die Funktion \"Pansharpen\" führt ein panchromatisches Bild bzw. Raster-Band mit hoher Auflösung mit einem Multiband-Raster-Dataset mit geringerer Auflösung zusammen. Dadurch wird die räumliche Auflösung des Multibandbildes erhöht.<div><br/>Zweck des Pan-Sharpening ist es, ein visuell hochwertigeres Bild zu erstellen. Da durch diese Techniken die Radiometrie und die spektralen Eigenschaften der Multiband-Bilddaten geändert werden, müssen Pan-Sharpened-Bilddaten in Analysen für die Fernerkundung mit Vorsicht verwendet werden.</div>",
		pathAllocationName: "Pfadentfernungs-Zuordnung",
		pathAllocationSnip: "Berechnet die kostengünstigste Quelle für jede Zelle auf Basis der geringsten akkumulativen Kosten auf einer Kostenoberfläche unter Berücksichtigung der Oberflächenentfernung zusammen mit horizontalen und vertikalen Kostenfaktoren.",
		pathAllocationDesc: "Mit der Funktion \"Pfadentfernungs-Zuordnung\" wird für jede Zelle die nächste Quelle auf Grundlage der geringsten akkumulativen Kosten über einer Kostenoberfläche berechnet, wobei die Oberflächenentfernung sowie horizontale und vertikale Kostenfaktoren berücksichtigt werden.",
		pathBackLinkName: "Pfadentfernungs-Rückverknüpfung",
		pathBackLinkSnip: "Gibt den Nachbarn an, bei dem es sich um die nächste Zelle auf dem Pfad mit den geringsten akkumulativen Kosten zur kostengünstigsten Quelle handelt, wobei die Oberflächenentfernung zusammen mit horizontalen und vertikalen Kostenfaktoren berücksichtigt werden.",
		pathBackLinkDesc: "Mit der Funktion \"Pfadentfernungs-Rückverknüpfung\" wird der Nachbar ermittelt, bei dem es sich um die nächste Zelle auf dem Pfad mit den geringsten akkumulativen Kosten zur nächstgelegenen Quelle handelt, wobei die Oberflächenentfernung sowie horizontale und vertikale Kostenfaktoren berücksichtigt werden.",
		pathDistanceName: "Pfadentfernung",
		pathDistanceSnip: "Berechnet für jede Zelle die kleinste akkumulative Kostenentfernung von oder zur kostengünstigsten Quelle unter Berücksichtigung der Oberflächenentfernung sowie horizontaler und vertikaler Kostenfaktoren.",
		pathDistanceDesc: "Mit der Funktion \"Pfadentfernung\" wird für jede Zelle die Entfernung mit den geringsten akkumulativen Kosten zur nächstgelegenen Quelle berechnet, wobei die Oberflächenentfernung sowie horizontale und vertikale Kostenfaktoren berücksichtigt werden.",
		plusName: "Plus",
		plusSnip: "Die Werte von zwei Rastern auf Zellenbasis addieren.",
		plusDesc: "Die Funktion \"Plus\" addiert die Werte zweier Raster auf Pixelbasis.",
		powerName: "Power",
		powerSnip: "Die Zellenwerte in einem Raster mit den Werten in einem anderen Raster potenzieren.",
		powerDesc: "Mit der Funktion \"Potenz\" werden die Pixelwerte eines Rasters mit den Werten aus einem anderen Raster potenziert.",
		radarCalibrationName: "Radarkalibrierung",
		radarCalibrationSnip: "RADARSAT-2-Rückstreuung konvertieren.",
		radarCalibrationDesc: "Diese Funktion kann verwendet werden, um RADARSAT-2-Symbolik in einem Mosaik-Dataset oder als Raster-Produkt zu kalibrieren. Die Kalibrierung wird auf Radarbilddaten angewendet, damit die Pixelwerte eine echte Darstellung der Radarrückstreuung sind.",
		rasterInfoName: "RasterInfo",
		rasterInfoSnip: "Eigenschaften des Rasters wie Bittiefe, NoData-Wert, Zellengröße usw. ändern.",
		rasterInfoDesc: "Mit der Funktion \"RasterInfo\" wird ein Dialogfeld geöffnet, dass die Eigenschaften des Raster-Datasets beinhaltet, z. B. Anzahl der Spalten und Zeilen, Anzahl der Bänder, Pixeltyp, Ausdehnung und Raumbezug. Sie können diese Eigenschaften bearbeiten, indem Sie ein Raster-Dataset auswählen, das als Vorlage verwendet werden soll. ",
		rasterizeAttributesName: "Attribute rastern",
		rasterizeAttributesSnip: "Reichert ein Raster mit zusätzlichen Bändern an, die aus Werten bestimmter Attribute einer externen Tabelle oder eines Feature-Service abgeleitet wurden.",
		rasterizeAttributesDesc: "Die Funktion \"Attribute rastern\" reichert ein Raster durch Hinzufügen von Bändern an, die aus Werten bestimmter Attribute, aus einer externen Tabelle oder aus einem Feature-Service abgeleitet wurden. Sie können optional ein Zonen-Raster und das verknüpfte Zonen-ID-Attribut angeben, um die regionenbasierte Suche zu aktivieren.",
		rasterizeFeatureClassName: "Features rastern",
		rasterizeFeatureClassSnip: "Konvertiert Features in Raster.",
		rasterizeFeatureClassDesc: "Diese Funktion konvertiert Polygon-, Polyline-, und Point-Feature-Class-Daten in einen Raster-Layer.<div><br/>Features werden Pixelwerte basierend auf der OBJECTID des Features zugewiesen (Standardeinstellung). Die Pixelwerte können optional auf einem benutzerdefinierten Wertefeld in der Attributtabelle des Eingabe-Features basieren.</div>",
		recastName: "Überarbeiten",
		recastSnip: "Ändert die Parameter einer Funktionskette in einem Mosaik-Dataset oder Image-Service. Die Funktion wird häufig mit LAS-Datasets verwendet, um die Erstellung gesonderter Mosaik-Datasets für verschiedene Terrain-Darstellungen zu vermeiden.",
		recastDesc: "Die Funktion \"Überarbeiten\" wird verwendet, um die in einem Mosaik-Dataset oder Image-Service verwendeten Funktionsparameter dynamisch zu ändern, ohne die Änderungen an den Elementen physisch beizubehalten.",
		regionGroupName: "Gruppierung zu Regionen",
		regionGroupSnip: "Für jede Zelle in der Ausgabe wird die Zugehörigkeit der Zelle zu einer verbundenen Region ermittelt. Jeder Region wird eine eindeutige Nummer zugewiesen.",
		regionGroupDesc: "Mit der globalen Funktion \"Gruppierung zu Regionen\" wird für jede Zelle in der Ausgabe die Identität der verbundenen Region aufgezeichnet, zu der diese Zelle gehört. Jeder Region wird eine eindeutige Nummer zugewiesen.<div><br/>Die erste gescannte Region erhält den Wert 1, die zweite den Wert 2 usw., bis allen Regionen ein Wert zugewiesen wurde. Der Scan erfolgt von links nach rechts, von oben nach unten. Die den Ausgabe-Zonen zugewiesenen Werte hängen davon ab, wann sie im Scanvorgang gefunden wurden.</div>",
		regionGrowName: "Region Grow",
		regionGrowSnip: "Bildet Regionen aus Schwerpunkten.",
		regionGrowDesc: "Die Funktion \"Region Grow\" gruppiert benachbarte Pixel gemäß dem im Ausgangspunkt angegebenen Radius. Den Pixel- oder Objektgruppen wird ein bestimmter Füllwert zugewiesen.",
		remapName: "Neuzuordnung",
		remapSnip: "Pixelwerte durch Zuweisen neuer Werte zu Pixelwertbereichen oder durch Verwenden einer externen Tabelle ändern.",
		remapDesc: "Die Funktion \"Neuzuordnung\" ermöglicht es Ihnen, die Pixelwerte der Raster-Daten zu ändern oder zu reklassifizieren.  Dies kann erreicht werden, indem für die Zuordnung zu Ausgabepixelwerten ein Pixelwertebereich angegeben oder eine Tabelle verwendet wird.",
		reprojectName: "Neu projizieren",
		reprojectSnip: "Ändert die Projektion eines Raster-Datasets, Mosaik-Datasets oder Raster-Elements in einem Mosaik-Dataset. Sie kann auch zum Resampling der Daten in eine neue Zellengröße und zum Definieren eines Ursprungs verwendet werden.",
		reprojectDesc: "Mit der Funktion \"Neu projizieren\" wird die Projektion eines Raster-Datasets, Mosaik-Datasets oder Raster-Elements in einem Mosaik-Dataset geändert. Sie kann auch zum Resampling der Daten in eine neue Zellengröße und zum Definieren eines Ursprungs verwendet werden.<div><br/>Die Funktion \"Neu projizieren\" kann beim Erstellen eines Cache aus einem Raster oder Mosaik-Dataset verwendet werden, das sich nicht in der erforderlichen Projizierung befindet. Wenn beispielsweise ein gecachter Image-Service erstellt wird, der in Anwendungen mit anderen gecachten Services integriert ist, ist es wichtig, dass sie sich alle in derselben Projektion befinden. Dabei handelt es sich häufig um eine Web Mercator-Projektion. Da das Mosaik-Dataset nicht neu projiziert werden kann, haben Sie zwei Möglichkeiten: Entweder erstellen Sie in der erforderlichen Projektion ein referenziertes Mosaik-Dataset aus Ihrem Mosaik-Dataset oder Sie fügen der Funktionskette des Mosaik-Datasets die Funktion \"Neu projizieren\" hinzu. Ein weiteres Beispiel ist die Verwendung dieser Funktion auf dem Raster-Element in einem Mosaik-Dataset. Bei Verwendung der Funktion \"Gecachte Raster\" können Sie die Funktion \"Neu projizieren\" so einfügen, dass der Cache in der neuen Projektion erstellt wird. Raster-Elemente in einem Mosaik-Dataset können gecacht werden, wenn die das Verarbeitungsaufkommen hoch ist und Sie versuchen, einen schnellen Image-Service zu veröffentlichen, ohne den gesamten Image-Service zu cachen.</div>",
		resampleName: "Resampling",
		resampleSnip: "Die Zellengröße eines Rasters ändern.",
		resampleDesc: "Die Funktion \"Resampling\" ändert die Zellengröße, den Resampling-Typ oder beides.<div><br/>Die Funktion \"Resampling\" sollte nur bei speziellen Berechnungsanforderungen verwendet werden. Beispielsweise bei der Berechnung von Magnitude-Richtung für Wind oder Strömung, die ein Resampling aus der Quellauflösung erfordert.</div>",
		roundDownName: "Round Down",
		roundDownSnip: "Für jede Zelle in einem Raster wird die nächstniedrigere Ganzzahl zurückgegeben, die als Gleitkommazahl angegeben wird.",
		roundDownDesc: "Die Funktion \"Round down\" gibt für jedes Pixel in einem Raster die nächstniedrigere ganze Zahl als Gleitkommawert zurück.",
		roundUpName: "Round Up",
		roundUpSnip: "Gibt für jede Zelle in einem Raster den nächsthöheren ganzzahligen Wert als Gleitkommawert zurück.",
		roundUpDesc: "\"Round down\" gibt für jedes Pixel in einem Raster die nächsthöhere ganze Zahl als Gleitkommawert zurück.",
		segmentMeanShiftName: "Mean Shift-Segmentierung",
		segmentMeanShiftSnip: "Benachbarte Pixel mit ähnlichen Spektraleigenschaften in Segmente gruppieren.",
		segmentMeanShiftDesc: "Mit dieser Funktion werden Objekte, Features oder Segmente in Ihren Bilddaten identifiziert, indem benachbarte Pixel, die ähnliche Spektraleigenschaften oder räumliche Eigenschaften aufweisen, gruppiert werden. Zur besseren Ableitung von interessanten Features können Sie die Stärke der räumlichen und spektralen Glättung selbst bestimmen.",
		s1RadiometricCalibrationName: "Sentinel-1 Radiometrische Kalibrierung",
		s1RadiometricCalibrationSnip: "Unterschiedliche Typen der radiometrischen Kalibrierung für Sentinel-1-Daten ausführen.",
		s1RadiometricCalibrationDesc: "Diese Raster-Funktion führt drei verschiedene Kalibrierungen für Sentinel-1-Datasets durch, einschließlich Beta-Nought und Gamma-Nought, und gibt das kalibrierte Dataset aus. Ziel der SAR-Kalibrierung ist es, Bilddaten zu liefern, in denen Pixelwerte direkt mit der Radarrückstreuung der Szene in Beziehung gesetzt werden können. Obwohl nicht kalibrierte SAR-Bilder für den qualitativen Einsatz ausreichend sind, sind kalibrierte SAR-Bilder für die quantitative Nutzung von SAR-Daten unerlässlich.<div><br/>Eine typische SAR-Datenverarbeitung, die Level-1-Bilder erzeugt, beinhaltet keine radiometrischen Korrekturen, und es bleibt eine signifikante radiometrische Verzerrung. Daher ist es notwendig, radiometrische Korrekturen auf SAR-Bilder anzuwenden, damit die Pixelwerte der Bilder tatsächlich die Radarrückstreuung der reflektierenden Oberfläche darstellen. Die radiometrische Korrektur ist auch für den Vergleich von SAR-Bildern notwendig, die mit verschiedenen Sensoren aufgenommen wurden oder die von demselben Sensor zu verschiedenen Zeiten, in verschiedenen Modi erfasst oder von verschiedenen Prozessoren verarbeitet wurden.</div>",
		s1ThermalNoiseRemovalName: "Sentinel-1 Wärmerauschen entfernen",
		s1ThermalNoiseRemovalSnip: "Wärmerauschen aus Sentinel-1-Daten entfernen.",
		s1ThermalNoiseRemovalDesc: "Die Korrektur des Wärmerauschens kann auf Sentinel-1 Level-1 Single Look Complex (SLC)-Produkte sowie auf Level-1 Ground Range Detection (GRD)-Produkte angewendet werden, die noch nicht korrigiert wurden. Der Bearbeiter kann diese Korrektur auch auf Grundlage der Produkt-Annotations entfernen, um das Rauschsignal wieder einzubringen, das zur Erstellung des Originalprodukts entfernt wurde. Produkt-Annotations werden entsprechend aktualisiert, um eine erneute Anwendung der Korrektur zu ermöglichen. ",
		setNullName: "Auf NULL setzen",
		setNullSnip: "\"Auf NULL setzen\" legt für identifizierte Zellpositionen auf Grundlage eines angegebenen Kriteriums den Wert \"NoData\" fest. \"NoData\" wird zurückgegeben, wenn eine Bedingungsauswertung \"true\" (wahr) ergibt, und ein durch ein anderes Raster angegebener Wert wird zurückgegeben, wenn die Bedingungsauswertung \"false\" (falsch) ergibt.",
		setNullDesc: "Mit der Funktion \"Auf NULL setzen\" werden die identifizierten Pixel basierend auf den angegebenen Kriterien auf \"NoData\" festgelegt. \"NoData\" wird zurückgegeben, wenn eine Bedingungsauswertung \"true\" (1) ergibt. Der im False-Raster angegebene Wert wird zurückgegeben, wenn die Bedingungsauswertung \"false\" (0) ergibt. Dieses Kriterium wird durch die Ausgabe einer logischen mathematischen Funktion festgelegt, die dem Eingabe-Raster entspricht.",
		shadedReliefName: "Geschummertes Relief",
		shadedReliefSnip: "Eine Multiband-, farbcodierte, 3D-Darstellung der Oberfläche erstellen, wobei die relative Position der Sonne beim Schummern des Bildes berücksichtigt wird.",
		shadedReliefDesc: "Durch die Funktion \"Geschummertes Relief\" wird eine 3D-Farbdarstellung des Terrains erstellt, indem die Bilder aus den Methoden \"Höhencodiert\" und \"Schummerung\" zusammengeführt werden. Diese Funktion verwendet die Eigenschaften von Höhe und Azimut, um die Position der Sonne anzugeben.<div><br/></div>",
		sinHName: "SinH",
		sinHSnip: "Den Sinus Hyperbolicus von Zellen in einem Raster berechnen.",
		sinHDesc: "Mit der Funktion wird der Sinus Hyperbolicus der Pixel in einem Raster berechnet.",
		sinName: "Sin",
		sinSnip: "Den Sinus von Zellen in einem Raster berechnen.",
		sinDesc: "Mit der Funktion wird der Sinus der Pixel in einem Raster berechnet.",
		slopeName: "Neigung",
		slopeSnip: "Die Änderungsrate von einem Pixelwert im Vergleich zu seinen Nachbarn berechnen.",
		slopeDesc: "Mit dieser Raster-Funktion wird die Neigung berechnet, die der Änderungsrate der Höhe in den einzelnen Zellen des digitalen Höhenmodells (Digital Elevation Model, DEM) entspricht. Dies ist die erste Ableitung eines DEM.<div><br/>Diese Funktion verwendet eine beschleunigte atan()-Funktion. Sie ist sechs mal schneller und der Annäherungsfehler beträgt immer weniger als 0,3 Grad.</div>",
		speckleName: "Speckle",
		speckleSnip: "Filter bereitstellen, um SAR-Datasets vom Rauschen zu bereinigen.",
		speckleDesc: "Speckle ist das Hochfrequenzrauschen auf Radardaten. Die von SAR-Systemen (Synthetic Aperture Radar) generierten Bilder sind aufgrund der Verarbeitung zerstreuter Signale und Interferenzen elektromagnetischer Wellen, die von Oberflächen oder Objekten zurückgeworfen werden, in höchstem Maße Speckling-Effekten unterworfen. Diese Funktion filtert das Radar-Dataset mit Speckling und glättet das Rauschen, wobei Kanten oder scharfe Features im Bild erhalten bleiben.",
		spectralConversionName: "Spektralkonvertierung",
		spectralConversionSnip: "Wendet eine Matrix auf ein Multiband-Bild an.",
		spectralConversionDesc: "Die Funktion \"Spektralkonvertierung\" wendet eine Matrix auf ein Multiband-Bild an, um die Farbwerte der Ausgabe zu beeinflussen.<div><br/>Blaue Bänder werden von einigen Sensoren aufgrund des niedrigen Signal-Rausch-Verhältnisses nicht erfasst. Diese Funktion kann verwendet werden, um z. B. ein falsches Infrarotfarbbild in ein Pseudofarbbild zu konvertieren.</div>",
		squareRootName: "Square Root",
		squareRootSnip: "Die Quadratwurzel der Zellenwerte in einem Raster berechnen.",
		squareRootDesc: "Mit der Funktion \"Square Root\" wird die Quadratwurzel der Pixelwerte in einem Raster berechnet.",
		squareName: "Square",
		squareSnip: "Das Quadrat der Zellenwerte in einem Raster berechnen.",
		squareDesc: "Mit \"Square\" wird das Quadrat der Pixelwerte in einem Raster berechnet.",
		statisticsHistogramName: "Statistiken und Histogramm",
		statisticsHistogramSnip: "Statistiken und Histogramm definieren oder verknüpfen.",
		statisticsHistogramDesc: "Die Funktion \"Statistiken und Histogramm\" wird verwendet, um die Statistik und das Histogramm eines Rasters zu definieren.  Sie können diese Funktion am Ende der Funktionskette einfügen, um die Statistik und das Histogramm einer Raster-Funktionsvorlage (Raster Function Template, RFT) zu beschreiben. Dies kann erforderlich sein, um die Standardanzeige des Verarbeitungsergebnisses zu steuern, insbesondere beim Definieren einer Funktionskette, die viele Funktionen enthält.<div><br/>Sie können die Statistik definieren, indem Sie die Werte eingeben oder aus einem Raster-Dataset bzw. einer XML-Datei importieren. Histogramme können nur durch das Importieren einer Datei definiert werden.</div>",
		statisticsName: "Statistiken",
		statisticsSnip: "Berechnet auf der Grundlage einer definierten Fokusnachbarschaft die Fokusstatistiken für jedes Pixel eines Bildes.",
		statisticsDesc: "Mit der Funktion \"Statistiken\" wird die Fokusstatistik für jedes Pixel eines Bildes auf der Grundlage einer definierten Fokusnachbarschaft berechnet.<div><br/>Die Funktion \"Statistiken\" kann zum Auffüllen von gelöschten Zeilen in einem Bild verwendet werden. Gelöschte Zeilen werden häufig durch Probleme im Sensor verursacht, wobei keine Daten erfasst werden. Dies ist bei Sensoren wie dem Enhanced Thematic Mapper Plus (ETM+) des Landsat 7 aufgetreten. Die fehlenden Daten verursachen Probleme bei der Analyse und auch beim Betrachten der Bilddaten. An diesem Umstand lässt sich bei der Verwendung von Bilddaten für Analysen nicht viel ändern. Wenn jedoch ein überlappendes Bild vorliegt, könnte es anstelle des fehlenden Inhalts verwendet werden. Auf die gleiche Weise könnte auch bei Bilddaten vorgegangen werden, die zur Visualisierung verwendet werden. Da jedoch nicht immer ein zusätzliches Bild zum Auffüllen des fehlenden Inhalts zur Verfügung steht, muss er aus den vorhandenen Daten abgeleitet werden.</div>",
		streamLinkName: "Wasserlauf-Abschnitte",
		streamLinkSnip: "Weist Abschnitten eines linearen Raster-Netzwerks Einzelwerte zwischen Schnittpunkten zu.",
		streamLinkDesc: "Mit der globalen Funktion \"Wasserlauf-Abschnitte\" werden den Abschnitten eines linearen Raster-Netzwerks zwischen Schnittpunkten Einzelwerte zugewiesen.<div><br/>Links sind die Abschnitte eines Wasserlaufkanals, die zwei aufeinander folgende Knoten, einen Knoten und den Abfluss oder einen Knoten und die Wasserscheide miteinander verbinden. In der Hydrologie werden diese Wasserlaufsegmente als Flussabschnitte bezeichnet. Ein Knoten bezieht sich auf einen Abflusspunkt und ermöglicht das Skizzieren eines Abflussgebietes oder der Grenze eines Teileinzuggebiets.</div>",
		stretchName: "Streckung",
		stretchSnip: "Verstärkt ein Bild durch die Anpassung des angezeigten Wertebereichs. Dadurch werden die zugrunde liegenden Pixelwerte nicht verändert. Wenn ein Pixelwert außerhalb des angegebenen Bereichs liegt, wird er als Minimal- oder Maximalwert angezeigt.",
		stretchDesc: "Die Funktion \"Streckung\" verbessert ein Bild, indem sie Eigenschaften wie Helligkeit, Kontrast und Gamma mithilfe mehrerer Streckungstypen ändert. Diese Funktion verwendet die Statistik der Raster innerhalb des Mosaik-Datasets. Bei ihrer Verwendung müssen Sie daher sicherstellen, dass die Statistik berechnet wurde.<div><br/>Der Streckungstyp definiert eine Histogrammstreckung, die auf die Raster angewendet wird, um ihr Erscheinungsbild zu verbessern. Eine Streckung verbessert das Erscheinungsbild der Daten, indem die Pixelwerte entlang einem Histogramm von den Minimal- und Maximalwerten gedehnt werden, die durch ihre Bit-Tiefe definiert sind. </div>",
		swathName: "Streifen",
		swathSnip: "Interpoliert aus unregelmäßigen Gittern oder Streifendaten.",
		swathDesc: "In einigen netCDF- oder HDF-Datasets wird die Geolokalisierung in Form von unregelmäßig angeordneten Arrays gespeichert. Beim Hinzufügen dieser Datasets zu einem Mosaik-Dataset wird von der Funktion \"Streifen\" ein Resampling der unregelmäßig gerasterten Daten durchgeführt, sodass jedes Pixel die gleiche Größe und eine rechteckige Form erhält.<div><br/>Beim Hinzufügen von Variablen aus netCDF oder HDF zu einem Mosaik-Dataset wird automatisch geprüft, ob die Daten in einem regelmäßigen Array angeordnet sind. Falls nicht, wird die Funktion \"Streifen\" angewendet, um die unregelmäßigen Raster in Punkte und anschließend in ein regelmäßig Raster zu konvertieren. Sie können die in der Raster-Funktion \"Streifen\" verwendete Interpolationsmethode und Zellengröße ändern. Bei regelmäßig angeordneten Raster-Daten findet keine Interpolation statt, die Daten werden in ihrem gegenwärtigen Zustand gelesen.</div>",
		tanHName: "TanH",
		tanHSnip: "Den Tangens Hyperbolicus von Zellen in einem Raster berechnen.",
		tanHDesc: "Mit der Funktion wird der Tangens Hyperbolicus der Pixel in einem Raster berechnet.",
		tanName: "Tan",
		tanSnip: "Den Tangens von Zellen in einem Raster berechnen.",
		tanDesc: "Mit der Funktion wird der Tangens der Pixel in einem Raster berechnet. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Berechnet den Grad an Vegetation, Feuchtigkeit und Helligkeit. Diese Methode beruht auf Koeffizienten, die speziell für einen Sensor berechnet werden müssen.",
		tasseledCapDesc: "Die Tasseled-Cap-Transformation (auch Kauth-Thomas-Transformation) wurde entwickelt, um Veränderungen in der Vegetationsphänologie und Städteentwicklung, die von verschiedenen Satellitensensorsystemen erfasst werden, zu analysieren und als Karte darzustellen. Den Namen \"Tasseled Cap\"-Transformation (Zipfelmütze) verdankt sie der Form der graphischen Verteilung von Daten. Mit der Transformation konnten die Muster, die in Landsat-MSS-Daten für landwirtschaftliche Flächen gefunden wurden, in Abhängigkeit vom Lebenszyklus der Nutzpflanzen erklärt werden. Im Wesentlichen findet während des Wachstums von Nutzpflanzen vom Saatkorn bis zur Erntereife eine Nettozunahme der infrarotnahen und eine Abnahme der Rotreflexion basierend auf der Bodenfarbe statt.<div><br/>Diese Transformation hat mittlerweile ein breites Anwendungsspektrum und dient nicht nur zur Überwachung von Nutzpflanzen, sondern auch zur Analyse und Kartenerstellung von Vegetation für Forstwirtschaft, industrielles Vegetationsmanagement, Ökosystem-Kartenerstellung und -Verwaltung, Bestandserfassung und Überwachung von Kohlenstoffbindung und Emissionshandel, Städteentwicklung usw. Mittlerweile werden nicht nur Landsat MSS unterstützt, sondern auch andere gängige Satellitensysteme wie die Multispektralsensoren Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, WorldView-2 und RapidEye.</div>",
		timesName: "Times",
		timesSnip: "Die Werte von zwei Rastern auf Zellenbasis multiplizieren.",
		timesDesc: "Mit der Funktion \"Times\" werden die Werte zweier Raster auf Pixelbasis multipliziert.",
		transposeBitsName: "Bitversatz",
		transposeBitsSnip: "Entpackt die Bits des Eingabepixels und ordnet sie festgelegten Bits in dem Ausgabepixel zu. Zweck dieser Funktion ist es, die Bits aus einigen Eingaben zu manipulieren, z. B. Landsat 8-Bänder zur Qualitätsprüfung.",
		transposeBitsDesc: "Die Funktion \"Bitversatz\" entpackt die Bits des Eingabepixels und ordnet sie festgelegten Bits in dem Ausgabepixel zu. Zweck dieser Funktion ist es, die Bits aus einigen Eingaben zu manipulieren, z. B. solche der Landsat 8-Qualitätsbandprodukte.",
		unitConversionName: "Einheitenumrechnung",
		unitConversionSnip: "Werte von einer Maßeinheit in eine andere ändern.",
		unitConversionDesc: "Diese Funktion konvertiert Pixel von einer Einheit in eine andere. Sie unterstützt die Konvertierung von Entfernung, Geschwindigkeit und Temperatur.",
		vectorFieldName: "Vektorfeld",
		vectorFieldSnip: "Datasets mit Größe (u) und Richtung (v) als Pfeile anzeigen, wobei Höhe durch die Größe und Richtung durch den Winkel des Pfeils dargestellt wird.",
		vectorFieldDesc: "Die Funktion \"Vektorfeld\" kombiniert und konvertiert zwei Raster zu einem Zweiband-Raster, dessen Datentyp entweder \"Magnituden-Richtung\" oder \"U-V\" ist.<div><br/>Der U-Wert wird manchmal als zonale Geschwindigkeit und der V-Wert als meridionale Geschwindigkeit bezeichnet.</div>",
		viewshed2Name: "Sichtfeld",
		viewshed2Snip: "Bestimmt anhand geodätischer Methoden die Gitternetz-Oberflächenpositionen, die für eine Reihe von Beobachter-Features sichtbar sind.",
		viewshed2Desc: "Die Funktion \"Sichtfeld\" bestimmt anhand geodätischer Methoden die Raster-Oberflächenpositionen, die für eine Reihe von Beobachter-Features sichtbar sind.<div><br/>Die Sichtbarkeit jedes einzelnen Pixelmittelpunkts wird durch einen Sichtlinientest zwischen dem Ziel und dem jeweiligen Beobachter ermittelt. Wenn ein Beobachter das Ziel im Pixelmittelpunkt sehen kann, wird das Pixel als sichtbar erachtet. Bei der Ermittlung der Sichtbarkeit wird stets die Erdkrümmung berücksichtigt.</div>",
		watershedName: "Abflussgebiet",
		watershedSnip: "Ermittelt die relevante Fläche über einer Gruppe von Zellen in einem Raster.",
		watershedDesc: "Mit der globalen Funktion \"Abflussgebiet\" wird die relevante Fläche über einer Gruppe von Pixeln in einem Raster ermittelt. Abflussgebiete werden von einem Fließrichtungsraster skizziert, das die Fließrichtung von jedem Pixel identifiziert.",
		weightedOverlayName: "Gewichtete Überlagerung",
		weightedOverlaySnip: "Überlagert mehrere Raster anhand eines allgemeinen Maßstabs und gewichtet nach der Wichtigkeit jedes Rasters.",
		weightedOverlayDesc: "Mit dieser Funktion werden mehrere Raster anhand eines allgemeinen Maßstabs überlagert und nach der Wichtigkeit jedes Rasters gewichtet.",
		weightedSumName: "Gewichtete Summe",
		weightedSumSnip: "Ein Raster-Array auf Zellenbasis gewichten und hinzufügen.",
		weightedSumDesc: "Die Funktion \"Gewichtete Summe\" ermöglicht die Überlagerung mehrerer Raster, wobei sie nach ihrer jeweiligen Gewichtung multipliziert und zusammengerechnet werden.",
		windchillName: "Windchill",
		windchillSnip: "Umgebungslufttemperatur und Windgeschwindigkeit zum Berechnen des Windchill-Faktors kombinieren.",
		windchillDesc: "Die Funktion \"Windchill\" ist bei der Identifizierung gefährlicher winterlicher Bedingungen hilfreich, die je nachdem, wie lange man äußerlichen Einflüssen ausgesetzt ist, zu Erfrierungen und sogar Unterkühlung führen können. Windchill ist eine Möglichkeit, das Kälteempfinden einer Person zu messen, wenn Wind bei bereits kalten Temperaturen berücksichtigt wird. Je höher die Windgeschwindigkeit, desto schneller verliert der Körper Wärme und desto höher ist das Kälteempfinden.",
		zonalRemapName: "Zonale Neuzuordnung",
		zonalRemapSnip: "Ordnen Sie Pixel in einem Raster basierend auf in einem anderen Raster definierten Zonen und zonenabhängiger Wertzuordnung, die in einer Tabelle definiert ist, neu zu.",
		zonalRemapDesc: "Mit dieser Funktion können Sie Pixel in einem Raster basierend auf in einem anderen Raster definierten Zonen und zonenabhängiger Wertzuordnung, die in einer Tabelle definiert ist, neu zuordnen.",
		zonalStatisticsName: "Zonale Statistiken",
		zonalStatisticsSnip: "Berechnet Statistiken der Werte eines Gitternetzs innerhalb der Zonen eines anderen Datasets.",
		zonalStatisticsDesc: "Mit der Funktion werden Statistiken der Werte eines Rasters innerhalb der Zonen eines anderen Datasets berechnet. Eine Zone wird durch alle Flächen in der Eingabe definiert, die den gleichen Wert aufweisen. Diese Flächen müssen nicht zusammenhängend sein. Wenn die Zonen- und Werteingaben jeweils Raster mit derselben Auflösung sind, werden sie direkt verwendet. Wenn die Auflösungen verschieden sind, wird ein internes Resampling angewendet, um die Auflösungen zur Übereinstimmung zu bringen, bevor die zonale Operation ausgeführt wird.",
		flowLengthName: "Fließlänge",
		flowLengthSnip: "Berechnet die Entfernung flussaufwärts bzw. flussabwärts oder die kostengewichtete Entfernung entlang des Fließpfades für jede Zelle.",
		flowLengthDesc: "Dies ist eine globale Raster-Funktion. Mit dieser Funktion wird ein Raster-Layer der Entfernung flussaufwärts bzw. flussabwärts oder die gewichtete Entfernung entlang des Fließpfades für jede Zelle erstellt.<div><br/>Eine primäre Verwendung der Funktion \"Fließlänge\" besteht in der Berechnung der Länge des längsten Fließpfades innerhalb eines gegebenen Wassereinzugsgebiets. Dieser Messwert wird häufig verwendet, um die Konzentrationszeit eines Wassereinzugsgebiets zu berechnen. Hierzu wird die Option \"Flussaufwärts\" verwendet. Die Funktion kann auch verwendet werden, um Entfernungs-Flächen-Diagramme für hypothetische Niederschlags- und Abflussereignisse zu erstellen, wobei das Gewichtungs-Raster als Impedanz für die Abwärtsbewegung verwendet wird.</div>",
		streamOrderName: "Wasserlauf-Ordnung",
		streamOrderSnip: "Weist Segmenten eines Rasters, die Verzweigungen eines linearen Netzwerkes darstellen, eine numerische Ordnung zu.",
		streamOrderDesc: "Dies ist eine globale Raster-Funktion. Mit dieser Funktion wird ein Raster-Layer erstellt, der Segmenten eines Rasters, die Verzweigungen eines linearen Netzwerkes darstellen, eine numerische Ordnung zuweist.<div><br/>Die Ausgabe der Funktion \"Wasserlauf-Ordnung\" ist von höherer Qualität, wenn der Eingabe-Raster-Layer für den Wasserlauf und der Eingabe-Raster-Layer für die Fließrichtung von der gleichen Oberfläche abgeleitet werden. Wenn das Wasserlauf-Raster aus einem gerasterten Wasserlauf-Dataset abgeleitet wird, ist die Ausgabe möglicherweise unbrauchbar, da die Richtung auf Zellenbasis nicht mit der Position von Wasserlaufzellen übereinstimmt. Die Ergebnisse der Funktion \"Abflussakkumulation\" können verwendet werden, um durch das Anwenden eines Schwellenwertes zur Auswahl von Zellen mit einer hohen Abflussakkumulation ein Raster-Wasserlaufnetz zu erstellen. Beispielsweise werden Zellen mit einem Zufluss von mehr als 100 Zellen zum Definieren des Wasserlaufnetzes verwendet. Verwenden Sie die Funktion \"Con\" oder \"Auf NULL setzen\", um ein Wasserlaufnetz-Raster zu erstellen, in dem akkumulierte Wasserlaufwerte von 100 und mehr in einem Netz zusammenfließen und die anderen Wasserläufe im Hintergrund (NoData) positioniert werden. Das resultierende Wasserlaufnetz kann in der Funktion \"Wasserlauf-Ordnung\" verwendet werden. Diese Funktion unterstützt nur D8-Eingabe-Fließrichtungs-Raster-Layer. D8-Fließrichtungs-Raster können mit der Funktion \"Fließrichtung\" erstellt und mit dem Standardfließrichtungstyp D8 ausgeführt werden.</div>",
		snapPourPointName: "Abflusspunkt zuordnen",
		snapPourPointSnip: "Fängt Fließpunkte an der Zelle mit der höchsten Abflussakkumulation innerhalb einer bestimmten Entfernung.",
		snapPourPointDesc: "Dies ist eine globale Raster-Funktion. Mit dieser Funktion werden Abflusspunkte an der Zelle mit der höchsten Abflussakkumulation innerhalb einer bestimmten Entfernung gefangen.<div><br/>Beim Abgrenzen von Wassereinzugsgebieten mit der Funktion \"Abflussgebiet\" wird die Funktion \"Abflusspunkt zuordnen\" verwendet, um die Auswahl der Punkte mit hoher Abflussakkumulation sicherzustellen. \"Abflusspunkt zuordnen\" sucht innerhalb einer Fangentfernung um die angegebenen Abflusspunkte nach der Zelle mit der höchsten Abflussakkumulation und verschiebt den Abflusspunkt an diese Position. Die Ausgabe ist ein ganzzahliger Raster-Layer, wenn die ursprünglichen Abflusspunktpositionen an Positionen mit höherer Abflussakkumulation gefangen wurden.</div>",
		sinkName: "Senke",
		sinkSnip: "Erstellt ein Raster, das alle Senken oder Flächen mit interner Drainage identifiziert.",
		sinkDesc: "Dies ist eine globale Raster-Funktion. Mit dieser Funktion wird ein Raster-Layer erstellt, der alle Senken oder Flächen mit interner Drainage identifiziert. Eine Senke ist eine Zelle oder ein Satz räumlich verbundener Zellen, deren Fließrichtung keiner der acht gültigen Werte in einem Fließrichtungs-Raster zugewiesen werden kann. Dies kann auftreten, wenn alle benachbarten Zellen höher als die bearbeitete Zelle sind, oder wenn zwei Zellen ineinander fließen und eine Schleife mit zwei Zellen schaffen.<div><br/>Die Funktion \"Senke\" unterstützt nur D8-Eingabe-Fließrichtungs-Raster-Layer. D8-Fließrichtungs-Raster können mit der Funktion \"Fließrichtung\" erstellt und mit dem Standardfließrichtungstyp D8 ausgeführt werden. Die Ausgabe der Funktion \"Senke\" ist ein Integer-Raster, bei dem jeder Senke ein Einzelwert zugewiesen wird. Diese Einzelwerte weisen einen Bereich auf, der zwischen eins oder der Gesamtzahl der Senken liegt. Wenn die Gesamtzahl der Senken 1000 betragen würde, würde der Bereich der Einzelwerte 1 bis 1000 betragen.</div>",
		aggregateName: "Aggregieren",
		aggregateSnip: "Generiert eine Version des Rasters mit reduzierter Auflösung.",
		aggregateDesc: "Die Funktion \"Aggregieren\" führt entsprechend der angegebenen Aggregationsstrategie ein Resampling des Eingabe-Rasters auf eine gröbere Auflösung durch. Jede Ausgabezelle enthält die Summe, Minimum, Maximum, Mittelwert oder Medianwert der Eingabezellen, die von der Ausdehnung dieser Zelle umfasst werden.<div><br/>Sie können angeben, mit welchem Faktor die Zellengröße des Eingabe-Rasters multipliziert werden soll. Der Zellenfaktorwert 3 würde z. B. zu einer Ausgabe-Zellengröße führen, die dreimal so groß ist wie die des Eingabe-Rasters. Sie können definieren, wie die Ausdehnung der Ausgabe behandelt werden soll, wenn die Anzahl von Zeilen oder Spalten in der Eingabe kein genaues Vielfaches des Zellenfaktors ist. Standardmäßig werden die obere und rechte Begrenzung erweitert, sodass eine größere räumliche Ausdehnung als im Eingabe-Raster erfasst wird, damit wirklich alle Eingabezellen verarbeitet werden. Alternativ können die obere und rechte Begrenzung auf eine kleinere Ausdehnung reduziert werden, sodass die Anzahl der verarbeiteten Zeilen und Spalten ein genaues Vielfaches des Zellenfaktors darstellt. Sie können definieren, wie NoData-Zellen bei der Aggregationsberechnung verarbeitet werden. Beim Standardmechanismus werden NoData-Eingabezellen, die innerhalb der räumlichen Ausdehnung einer größeren Zelle im Ausgabe-Raster liegen, ignoriert, wenn der Wert der jeweiligen Ausgabezelle bestimmt wird. Alternativ können Sie angeben, dass auch nur eine einzige NoData-Eingabezelle in der räumlichen Ausdehnung einer Ausgabezelle dazu führt, dass die Zelle im Ausgabe-Raster als NoData-Zelle behandelt wird.</div>",
		ccdcName: "CCDC-Analyse",
		ccdcSnip: "Überprüft mit dem CCDC-Algorithmus (Continuous Detection and Classification) Änderungen von Pixelwerten im Zeitverlauf und generiert Modellergebnisse.",
		ccdcDesc: "Die CCDC-Analyse-Funktion überprüft mit dem CCDC-Algorithmus (Continuous Detection and Classification) Änderungen von Pixelwerten im Zeitverlauf und generiert ein multidimensionales Raster, das die Modellergebnisse enthält. Die Funktion wird nur gemeinsam mit der Funktion \"Veränderung mit Veränderungsanalyse erkennen\" in einer Vorlage für Raster-Funktionen unterstützt. Um eine Raster-Ausgabe zu erzeugen, verbinden Sie die Funktion \"CCDC-Analyse\" mit der Funktion \"Veränderung mit Veränderungsanalyse erkennen\", speichern Sie dies als Raster-Funktionsvorlage, und führen Sie die Raster-Analyse mit der Funktionsvorlage aus.<div><br/>Diese Funktion verwendet den CCDC-Algorithmus (Continuous Detection and Classification), um Änderungen an Pixelwerten im zeitlichen Verlauf für eine Reihe von Bildern auszuwerten. In einer Zeitserie von optischen Bilddaten oder abgeleiteten Bilddaten (z. B. NDVI) können Pixelwerte aus mehreren Gründen schwanken: 1. Jahreszeitliche Veränderungen: Änderungen an Pixelwerten spiegeln Veränderungen in der Vegetation aufgrund jahreszeitlicher Schwankungen von Temperatur und Niederschlägen wider. In der nördlichen Hemisphäre etwa wird eine höhere Dichte an grüner Vegetation im Sommer als im Winter erwartet. 2. Allmähliche Veränderungen: Änderungen an Pixelwerten spiegeln Trends bei der Vegetation oder Oberflächengewässern aufgrund klimatischer Schwankungen oder langfristiger Landbewirtschaftungspraktiken wider. Beispielsweise kann der Anteil von nackter Erde in einem Gebiet allmählich zunehmen, wenn die Niederschlagsmenge langfristig abnimmt. 3. Abrupte Veränderungen: Änderungen an Pixelwerten spiegeln Veränderungen bei der Landbedeckung wider, die beispielsweise aufgrund von Abholzungen, der Stadtentwicklung und Naturkatastrophen auftreten. Der CCDC-Algorithmus identifiziert alle drei Veränderungstypen mit dem primären Zweck, abrupte Veränderungen zu erkennen. Harmonische Regressions- und Trendmodelle werden auf die Daten eingepasst, um jahreszeitliche und allmähliche Veränderungen abzuschätzen. Plötzliche Abweichungen von den Trendmodellen weisen auf abrupte Veränderungen hin.<div><br/>Der CCDC-Algorithmus wurde ursprünglich für Daten zur Oberflächenreflektion oder Strahlungstemperatur von Landsat TM, Landsat ETM+ und Landsat OLI entwickelt. Die Funktion \"Veränderung mit Veränderungsanalyse erkennen\" in Kombination mit dieser Funktion erkennt jedoch Multiband-Bilddaten von allen unterstützten Sensoren sowie Ableitungen von Einzelband-Bilddaten wie Bandindizes. Sie können beispielsweise eine kontinuierliche Veränderungserkennung für ein NDVI-Raster (Normalisierter differenzierter Vegetationsindex) durchführen, da abrupte Änderungen beim NDVI auf eine Abholzung hindeuten können.</div>",
		computeChangeName: "Veränderungen berechnen",
		computeChangeSnip: "Berechnet die Unterschiede zwischen zwei kategorischen oder kontinuierlichen Raster-Datasets.",
		computeChangeDesc: "Die Funktion \"Veränderung berechnen\" kann verwendet werden, um die Unterschiede zwischen zwei klassifizierten Rastern für die Analyse von Änderungen der Landbedeckung aufzuzählen oder Änderungen zwischen zwei kontinuierlichen Einzelband-Rastern zu untersuchen, z. B. Höhe, Temperatur und Deckungsgrad.",
		detectChangeName: "Veränderung mit Veränderungsanalyse erkennen",
		detectChangeSnip: "Generiert mit dem Ausgabe-Veränderungsanalyse-Raster einen Raster-Layer, der Pixeländerungsinformationen enthält.",
		detectChangeDesc: "<div>Die Funktion \"Veränderung mit Veränderungsanalyse-Raster erkennen\" generiert mit dem Veränderungsanalyse-Raster einen Raster-Layer, der Informationen zum Pixeländerungsdatum enthält. Das Veränderungsanalyse-Raster muss mit dem Werkzeug \"Veränderungen mit CCDC analysieren\", dem Werkzeug \"Veränderungen mit LandTrendr analysieren\", der Raster-Funktion \"CCDC-Analyse\" oder der Raster-Funktion \"LandTrendr-Analyse\" generiert werden.</div><br><div>Diese Raster-Funktion kann mit der Raster-Funktion \"CCDC-Analyse\" oder der Raster-Funktion \"LandTrendr\" in einer Raster-Funktionsvorlage kombiniert werden. Um eine dauerhafte Raster-Ausgabe zu erzeugen, verbinden Sie die Ausgabe der Funktion \"CCDC-Analyse\" oder \"LandTrendr\" mit der Funktion \"Veränderung mit Veränderungsanalyse erkennen\", speichern Sie diese als Raster-Funktionsvorlage, und führen Sie die Raster-Analyse mit der Vorlage aus.</div><br><div>Durch den Parameter <strong>Art der Änderung</strong> wird angegeben, welche Informationen erstellt werden. Die Informationen werden aus dem Veränderungsanalyse-Raster extrahiert. Bei Ausführung dieses Werkzeugs für die Ausgabe der CCDC-Funktion bzw. des CCDC-Werkzeugs können Sie eine der folgenden Optionen auswählen:</div><ul><li><strong>Zeit der letzten Änderung</strong>: Datum und Uhrzeit, zu denen ein Pixel zuletzt als geändert gekennzeichnet wurde.</li><li><strong>Zeit der ersten Änderung</strong>: Datum und Uhrzeit, zu denen ein Pixel das erste Mal als geändert gekennzeichnet wurde.</li><li><strong>Zeit der größten Änderung</strong>: Datum und Uhrzeit, zu denen die berechnete Änderung die größte Signifikanz für ein Pixel aufwies.</li><li> <strong>Anzahl an Änderungen:</strong> Die Gesamtzahl der Änderungen an einem Pixel.</li></ul><div>Bei Ausführung dieser Funktion für die Ausgabe des Werkzeugs bzw. der Funktion \"LandTrendr\" stehen die folgenden zusätzlichen Optionen zur Verfügung:</div><ul><li><strong>Zeit der längsten Änderung</strong>: Datum, an dem ein Pixel als geändert gekennzeichnet wurde, am Anfang oder Ende des längsten Änderungszeitraums.</li><li><strong>Zeit der kürzesten Änderung</strong>: Datum, an dem ein Pixel als geändert gekennzeichnet wurde, am Anfang oder Ende des kürzesten Änderungszeitraums.</li><li><strong>Zeit der schnellsten Änderung</strong>: Datum, an dem ein Pixel als geändert gekennzeichnet wurde, am Anfang oder Ende des Zeitraums der schnellsten Änderung.</li><li><strong>Zeit der langsamsten Änderung</strong>: Datum, an dem ein Pixel als geändert gekennzeichnet wurde, am Anfang oder Ende des Zeitraums der langsamsten Änderung.</li></ul><div>Ausgegeben wird ein Multiband-Raster, dessen Bänder abhängig vom ausgewählten Änderungstyp und der angegebenen maximalen Anzahl von Änderungen Änderungsinformationen enthalten. Wenn beispielsweise <strong>Änderungstyp</strong> auf <strong>Zeit der ersten Änderung</strong> und <strong>Maximale Anzahl an Änderungen</strong> auf 2 festgelegt wird, berechnet die Funktion jeweils die zwei ersten Änderungen, die in der Zeitserie für die Pixel vorliegen. Ausgegeben wird ein Raster mit zwei Bändern, wobei das erste Band das Datum der ersten Änderung eines Pixels enthält und das zweite Band das Datum der zweitältesten Änderung je Pixel.</div><br><div>Bei Anwendung dieser Funktion auf die Ausgabe der Werkzeuge \"LandTrendr\" können Sie optional mit dem Parameter <strong>Segmentdatum</strong> das Datum extrahieren, das den Anfang oder das Ende einer Änderung markiert. Wenn Sie beispielsweise wissen möchten, wie die letzte Änderung in der Zeitserie begonnen hat, legen Sie den Parameter <strong>Art der Änderung</strong> auf <strong>Zeit der letzten Änderung</strong> und den Parameter <strong>Segmentdatum</strong> auf <strong>Anfang des Segments</strong> fest.</div><br><div>Verwenden Sie die folgenden Filterparameter, um spezifischere Datumsangaben zu Änderungen aus dem Veränderungsanalyse-Raster zu extrahieren:</div><ul><li><strong>Nach Jahr filtern:</strong> Hiermit identifizieren Sie Veränderungen, die innerhalb eines bestimmten Zeitraums eingetreten sind, z. B., wenn Sie nach Veränderungen in einer Landschaft während einer fünf Jahre andauernden Trockenheit suchen.</li><li><strong>Nach Dauer filtern:</strong> Hiermit identifizieren Sie Veränderungen, die über eine bestimmte Anzahl von Jahren hinweg eingetreten sind, z. B., wenn Sie nach abrupten Veränderungen über einen Zeitraum von einem oder zwei Jahren suchen. Die Dauer, für die Sie sich interessieren, können Sie mit der Formel <strong>Endjahr - Startjahr + 1</strong> berechnen. Lücken in der Zeitserie werden berücksichtigt.</li><li><strong>Nach Magnitude filtern:</strong> Hiermit identifizieren Sie Veränderungen einer bestimmten Magnitude, z. B., wenn Sie nur nach großen Veränderungen im Vegetationsindex NDVI suchen. Da die Magnitude ein absoluter Wert ist, dürfen der Minimal- und Maximalwert nicht negativ sein. Verwenden Sie zum Festlegen einer Richtungsänderung den Parameter <strong>Richtung der Änderung</strong>.</li></ul>",
		distanceAccumulationName: "Entfernungsakkumulation",
		distanceAccumulationSnip: "Berechnet die akkumulative Entfernung von jeder Zelle zu Quellen. Dabei werden geradlinige Entfernung, Kostenentfernung, tatsächliche Oberflächenentfernung sowie vertikale und horizontale Kostenfaktoren berücksichtigt.",
		distanceAccumulationDesc: "Mit \"Entfernungsakkumulation\" wird die Entfernung von den einzelnen Positionen in einem Untersuchungsgebiet zur nächstgelegenen bzw. kostengünstigsten Quelle berechnet. Wenn nur die Quellen für die Eingabe angegeben werden, wird eine geradlinige Entfernung zu den einzelnen Positionen im Untersuchungsgebiet berechnet. Wenn sowohl Quellen als auch Barrieren als Eingabe verwendet werden, wird bei der Entfernungsakkumulation die geradlinige Entfernung um die Barrieren herum berechnet. Beim Quell-Raster und Barrieren-Raster sollte der Hintergrundwert NoData sein und die Quellen und Barrieren müssen durch gültige Zellenwerte dargestellt werden. Null ist ein gültiger Wert. <div><br/>Wenn ein Oberflächen-Raster als Eingabe angegeben wurde, wird die tatsächliche Oberflächenentfernung zwischen Zellen berechnet. Damit eine Kostenanalyse mit der Entfernungsakkumulation durchgeführt werden kann, wird eine Kostenoberfläche benötigt. Wenn eine Kostenoberfläche angegeben wird, stellt das Ergebnis ein akkumuliertes Kostenentfernungs-Raster dar. Bei der Angabe von horizontalen und vertikalen Faktoren wird die Richtungsabhängigkeit als akkumulierte Kosten betrachtet. Es gibt vier Quelleneigenschaften, die verwendet werden können. Diese Eigenschaften können entweder die Quelle oder die Reisenden von der Quelle darstellen und durch mehrere spezifische Parameter gesteuert werden: 1. Initiale Akkumulation: legt die anfänglichen Kosten vor Beginn der Bewegung fest. Maximale Akkumulation: Legt fest, welche Höhe an Kosten eine Quelle maximal akkumulieren kann, bevor die Grenze erreicht wird: 3. Multiplikator zum Anwenden von Kosten: gibt den Reisemodus oder die Höhe an der Quelle an. Reiserichtung: Ermittelt, ob der Reisende an einer Quelle startet und zu Nicht-Quellenpositionen reist oder an anderen Nicht-Quellenpositionen startet und zurück zu einer Quelle reist.<div><br/>Standardmäßig ist das Ergebnis der Entfernungsakkumulation ein Einzelband, das das Entfernungsakkumulations-Raster darstellt. Es kann jedoch ein zweites Band erstellt werden, das Gegenrichtungsband. Dieses Band gibt von jeder Position im Untersuchungsgebiet an, in welche Richtung die kostengünstigste Quelle liegt. Beide Bänder werden benötigt, um die optimalen Pfade im Untersuchungsgebiet zu bestimmen. Extrahieren Sie zur Erzeugung eines Pfades zunächst mithilfe der Funktion \"Bänder extrahieren\" das Entfernungsakkumulations-Raster und das Gegenrichtungs-Raster. Diese Layer dienen als Eingabe für die Funktion \"Kostenpfad\". Verwenden Sie in der Funktion das Entfernungsakkumulations-Raster als Eingabe für das Kostenentfernungs-Raster und das Gegenrichtungs-Raster als Eingabe für das Kosten-Rückverknüpfungs-Raster.</div>",
		distanceAllocationName: "Entfernungsallokation",
		distanceAllocationSnip: "Berechnet die Entfernungsallokation für jede Zelle zu den angegebenen Quellen auf Grundlage von geradliniger Entfernung, Kostenentfernung, tatsächlicher Oberflächenentfernung sowie vertikaler und horizontaler Kostenfaktoren.",
		distanceAllocationDesc: "Die Entfernungsallokation berechnet, welcher Quelle die einzelnen Positionen im Untersuchungsgebiet zugewiesen werden. Wenn nur die Quellen als Eingabe angegeben sind, werden die Positionen durch eine geradlinige Entfernung zur nächstgelegenen Quelle zugewiesen. Wenn sowohl Quellen als auch Barrieren als Eingabe verwendet werden, wird bei der Entfernungsallokation die geradlinige Entfernung um die Barrieren herum berechnet, um zu bestimmen, welcher Quelle eine Position zugewiesen wird. Beim Quell-Raster und Barrieren-Raster sollte der Hintergrundwert NoData sein und die Quellen und Barrieren müssen durch gültige Zellenwerte dargestellt werden. Null ist ein gültiger Wert.<div><br/>Damit eine Kostenanalyse mit der Entfernungsallokation durchgeführt werden kann, wird eine Kostenoberfläche benötigt. Wenn eine Kostenoberfläche angegeben wird, besteht das Ergebnis aus einem Allokations-Raster, das auf den akkumulativen Kosten und nicht auf der geradlinigen Entfernung beruht. Bei der Angabe von horizontalen und vertikalen Faktoren wird die Richtungsabhängigkeit als akkumulierte Kosten betrachtet. Wenn ein Oberflächen-Raster als Eingabe angegeben wurde, wird die tatsächlich zurückgelegte Oberflächenentfernung beim Wechsel zwischen Zellen bei der Bestimmung der Allokation berechnet. Es gibt vier Quelleneigenschaften, die verwendet werden können. Diese Eigenschaften können entweder die Quelle oder die Reisenden von der Quelle darstellen und durch mehrere spezifische Parameter gesteuert werden: 1. Initiale Akkumulation: legt die anfänglichen Kosten vor Beginn der Bewegung fest. Maximale Akkumulation: Legt fest, welche Höhe an Kosten eine Quelle maximal akkumulieren kann, bevor die Grenze erreicht wird: 3. Multiplikator zum Anwenden von Kosten: gibt den Reisemodus oder die Höhe an der Quelle an. Reiserichtung: Ermittelt, ob der Reisende an einer Quelle startet und zu Nicht-Quellenpositionen reist oder an anderen Nicht-Quellenpositionen startet und zurück zu einer Quelle reist.<div><br/>Standardmäßig ist das Ergebnis der Entfernungsallokation ein Einzelband, das das Entfernungsallokations-Raster darstellt. Bei Aktivierung der Booleschen Option \"Quellenzeile und -spalte als zusätzliche Bänder in Ausgabe generieren\" wird ein Multiband-Raster mit drei Bändern erzeugt. Das erste Band ist das Entfernungs-Allokations-Band, das zweite enthält einen Zeilenindex und das dritte einen Spaltenindex. Diese Indizes geben die Position der Quellenzelle an, deren Entfernung die geringsten akkumulativen Kosten aufweist. Quellenzeilen- und Quellenspaltenindex können zusammen für die Erstellung einer Intensitätskarte verwendet werden. Wenn Sie in Ihrem Untersuchungsgebiet in den Bändern zwei und drei eine Position abfragen möchten, kennen Sie die Zeile und Spalte der kostengünstigsten Quelle für diese Position.</div>",
		eucBackDirectionName: "Euklidische Gegenrichtung",
		eucBackDirectionSnip: "Berechnet für jede Zelle die Richtung zur benachbarten Zelle entlang der kürzesten Route zurück zur nächstgelegenen Quelle in Grad. Dabei werden Barrieren vermieden.",
		eucBackDirectionDesc: "Das Ergebnis der Funktion \"Euklidische Gegenrichtung\" ist ein kontinuierliches Gleitkomma-Raster, das die Richtung in Grad zur nächstgelegenen Quelle zurück darstellt und Barrieren vermeidet, wenn Barrieren angegeben sind.<div><br/>Die Eingabe für \"Euklidische Gegenrichtungen\" ist die Quelle, zu der die Richtung berechnet wird. Als optionale Eingabe kann ein Raster angegeben werden, das Barrieren im Untersuchungsgebiet darstellt. Beim Quell-Raster und Barrieren-Raster sollte der Hintergrundwert NoData sein, und die Quellen und Barrieren sollten durch gültige Werte dargestellt werden. Null ist ein gültiger Wert. Standardmäßig werden bei der Berechnung die kombinierte Ausdehnung von Quellen und Barrieren plus 2 Zeilen und Spalten verarbeitet. Wenn die Analyse nur innerhalb einer festgelegten Entfernung von den Quellen benötigt wird, kann der Parameter \"Maximale Entfernung\" verwendet werden. \"Euklidische Gegenrichtung\" unterstützt eine planare und eine geodätische Methode in der Berechnung. Die Berechnungsmethode \"Planar\" erfolgt auf einer projizierten flachen Ebene mithilfe eines kartesischen 2D-Koordinatensystems. Die Berechnungsmethode \"Geodätisch\" erfolgt auf dem Ellipsoid. Das bedeutet, dass sich die Ergebnisse unabhängig von der Eingabe- oder Ausgabeprojektion nicht ändern.<div><br/>Das Ergebnis der Funktion \"Euklidische Gegenrichtung\" kann gemeinsam mit dem Ergebnis der Funktion \"Euklidische Richtung\" verwendet werden, um die kürzesten Routen von Positionen im Untersuchungsgebiet zurück zur Quelle zu bestimmen. Die Ergebnisse aus \"Euklidische Gegenrichtung\" und \"Euklidische Entfernung\" werden in der Funktion \"Kostenpfad\" gemeinsam mit Zielen verwendet, um die kürzesten Routen zu generieren.</div>",
		expandName: "Erweitern",
		expandSnip: "Erweitert ausgewählte Zonen eines Rasters um eine angegebene Zellenzahl.",
		expandDesc: "Mit der globalen Funktion \"Erweitern\" können Sie Raster generalisieren oder vereinfachen, indem Sie bestimmte Zonen vergrößern. Darüber hinaus können Sie den Grad der Generalisierung steuern.<div><br/>Die ausgewählten Zonen werden vergrößert, indem sie auf andere Zonen erweitert werden. Konzeptionell gesehen können die ausgewählten \"Zonenwerte\" als Vordergrundzonen betrachtet werden, während die anderen Werte Hintergrundzonen bleiben. Die Vordergrundzonen können auf die Hintergrundzonen erweitert werden.<div><br/>Der Grad der Generalisierung kann mit dem Parameter \"Anzahl der Zellen\" gesteuert werden. Standardmäßig lautet dieser Wert 1, d. h. die ausgewählten Zonen werden um jeweils eine Zelle erweitert. Um den Grad der Generalisierung zu erhöhen, können Sie für diesen Parameter einen größeren Wert eingeben. Konzeptionell kommt dies dem Ausführen des Werkzeugs mit einer Häufigkeit gleich, die der angegebenen Anzahl entspricht, wobei die Ergebnisse der vorherigen Ausführung die Eingabe der nächsten Ausführung sind.</div>",
		trendAnalysisName: "Trend generieren",
		trendAnalysisSnip: "Schätzt den Trend für jedes Pixel entlang einer Dimension für eine oder mehrere Variablen in einem multidimensionalen Raster.",
		trendAnalysisDesc: "<div>Mit dieser Funktion können Daten entlang einer linearen, harmonischen oder polynomischen Trendlinie angepasst werden. Das Werkzeug kann auch zur Trenderkennung mittels Mann-Kendall-Test oder saisonalem Kendall-Test verwendet werden.</div><br><div>Das mit dieser Funktion generierte Ausgabe-Trend-Raster wird als Eingabe für die Funktion <strong>Mit Trend vorhersagen</strong> verwendet.</div><br><div>Mit dem Mann-Kendall-Test und dem saisonalen Kendall-Test werden die Daten auf einen monotonen Trend hin untersucht. Sie sind nichtparametrisch, d. h. es wird keine spezifische Verteilung der Daten angenommen. Beim Mann-Kendall-Test werden serielle Korrelation oder saisonale Effekte nicht berücksichtigt. Bei Saisonalität der Daten ist der saisonale Kendall-Test besser geeignet.</div><br><div>Wenn das Werkzeug zur Durchführung des Mann-Kendall-Tests oder des saisonalen Kendall-Tests verwendet wird, ist die Ausgabe ein Fünfband-Raster. Hierbei gilt:</div><ul><li>Band 1 = Sen-Steigung</li><li>Band 2 = p-Wert</li><li>Band 3 = Mann-Kendall-Wert (S)</li><li>Band 4 = S-Varianz</li><li>Band 4 = S-Varianz</li><li>Band 5 = Z-Wert</li></ul><div>Anhand der Ausgaben des Mann-Kendall-Tests oder des saisonalen Kendall-Tests kann ermittelt werden, welche Pixel in Ihrer multidimensionalen Zeitserie einen statistisch signifikanten Trend aufweisen. Sie können diese Informationen in Verbindung mit der linearen, harmonischen oder polynomischen Trendanalyse verwenden, um signifikante Trends in der Zeitserie zu extrahieren. Sie können eine Maske generieren, die Pixel mit signifikanten p-Werten enthält, die Maske auf das multidimensionale Raster anwenden und dieses maskierte multidimensionale Raster als Eingabe für das Werkzeug verwenden, um lineare, harmonische oder polynomische Trendanalysen durchzuführen.</div><br><div>Es gibt drei Möglichkeiten der Anpassung eines Trends an die Variablenwerte entlang einer Dimension: linear, polynomisch und harmonisch.</div><br><div>In der linearen Trendanalyse besteht die Ausgabe aus einem Dreiband-Raster, für das Folgendes gilt:</div><ul><li>Band 1 = Neigung</li><li>Band 2 = Schnittpunkt</li><li>Band 3 = RMS-Fehler (Root Mean Square, quadratisches Mittel), der den Fehler um die am besten passende Linie herum darstellt</li></ul><div>In der polynomischen Trendanalyse hängt die Anzahl der Bänder in der Ausgabe von der Polynom-Ordnung ab. Bei der Polynomanpassung zweiter Ordnung entsteht ein Vierband-Raster. Hierbei gilt:</div><ul><li>Band 1 = Polynomial_2</li><li>Band 2 = Polynomial_1</li><li>Band 3 = Polynomial_0</li><li>Band 4 = RMSE</li></ul><div>Bei der Polynomanpassung dritter Ordnung entsteht ein Fünfband-Raster. Hierbei gilt:</div><ul><li>Band 1 = Polynomial_3</li><li>Band 2 = Polynomial_2</li><li>Band 3 = Polynomial_1</li><li>Band 4 = Polynomial_0</li><li>Band 5 = RMSE</li></ul><div>In der harmonischen Trendanalyse hängt die Anzahl der Bänder in der Ausgabe von der harmonischen Frequenz ab. Bei der Frequenz 1 ist die Ausgabe ein Fünfband-Raster. Hierbei gilt:</div><ul><li>Band 1 = Neigung</li><li>Band 2 = Schnittpunkt</li><li>Band 3 = Harmonic_sin1</li><li>Band 4 = Harmonic_cos1</li><li>Band 5 = RMSE</li></ul><div>Bei der Frequenz 2 ist die Ausgabe ein Siebenband-Raster. Hierbei gilt:</div><ul><li>Band 1 = Neigung</li><li>Band 2 = Schnittpunkt</li><li>Band 3 = Harmonic_sin1</li><li>Band 4 = Harmonic_cos1</li><li>Band 5 = Harmonic_sin2</li><li>Band 6 = Harmonic_cos2</li><li>Band 7 = RMSE</li></ul><div>Mit dem Parameter <strong>Zykluslänge</strong> für die harmonische Trendanalyse wird die Anzahl und Länge der Zyklen angegeben, die Sie für die Daten in einem Tag oder Jahr erwarten. Wenn Sie beispielsweise für Ihre Daten zwei Variationszyklen pro Jahr erwarten, beträgt die Zykluslänge 182,5 Tage bzw. 0,5 Jahre. Wenn alle drei Stunden eine Erfassung von Temperaturdaten erfolgt und pro Tag ein Variationszyklus vorliegt, beträgt die Zykluslänge einen Tag.</div><br><div>Mit dem Parameter <strong>Häufigkeit</strong> für die harmonische Trendanalyse wird das harmonische Modell beschrieben, das an die Daten angepasst wird. Wird die Häufigkeit auf 1 festgelegt, wird eine Kombination aus linearer Kurve und harmonischer Kurve der ersten Ordnung für die Anpassung des Modells verwendet. Beträgt die Häufigkeit 2, wird eine Kombination aus linearer Kurve, harmonischer Kurve der ersten Ordnung und harmonischer Kurve der zweiten Ordnung für die Anpassung des Modells verwendet. Beträgt die Häufigkeit 3, wird zusätzlich eine harmonische Kurve der dritten Ordnung für die Modellierung der Daten verwendet und so weiter.</div><br><div>Modellstatistiken zur Qualität der Übereinstimmung können als optionale Ausgabe generiert werden. Der RMS-Fehler (Root Mean Square, quadratisches Mittel), R-Squared und der Trend für den p-Wert der Neigung können berechnet und symbolisiert werden. Symbolisieren Sie den Ausgabe-Trend-Raster-Layer mit der Symbolisierung <strong>RGB</strong>, und geben Sie die Statistiken als rote, grüne und blaue Bänder an.</div><br>",
		spectralUnmixingName: "Lineare spektrale Entmischung",
		spectralUnmixingSnip: "Führt eine Subpixel-Klassifizierung durch und berechnet den Anteil verschiedener Landbedeckungstypen für einzelne Pixel.",
		spectralUnmixingDesc: "Die Funktion \"Lineare spektrale Entmischung\" berechnet den Anteil einzelner Pixel, die mehrere Arten von Landbedeckungen enthalten. Es wird ein Multiband-Raster erzeugt, in dem jedes Band dem Anteil der einzelnen Landbedeckungsklassen entspricht. Beispiel: Sie können mit diesem Tool in einem Multispektralbild Landbedeckungen klassifizieren und Vegetation mit und ohne Photosyntheseaktivität, nackte Erde und tote Pflanzen ermitteln.<div><br/>Die Reihenfolge des Ausgabe-Multiband-Rasters entspricht der Reihenfolge des Eingabe-Spektralprofils. Die Anzahl der Klassen darf nicht größer sein als die Anzahl an Bändern im Eingabe-Raster. Aus einem Beispiel: Einem Achtband-Raster können Sie Informationen zu maximal acht Klassen entnehmen.</div>",
		multidimensionalFilterName: "Multidimensionaler Filter",
		interpolateRasterByDimensionFunctionName: "Raster nach Dimension interpolieren",
		interpolateRasterByDimensionFunctionSnip: "Interpoliert ein multidimensionales Raster mit angegebenen Dimensionswerten mithilfe von benachbarten Ausschnitten.",
		interpolateRasterByDimensionFunctionDesc: "<p>Mit dieser Funktion können Sie Pixelwerte für einen nicht definierten Dimensionsausschnitt in einem multidimensionalen Raster schätzen. Wenn Sie zum Beispiel ein Dataset haben, das die Meerestemperatur an der Oberfläche sowie 100 Meter unter dem Meeresspiegel enthält, und Sie die Temperatur 50 Meter unter dem Meeresspiegel schätzen möchten, können Sie mit dieser Funktion eine Schätzung für diese Tiefe enthalten. Verwenden Sie dazu die Dimensionsdefinition \"Nach Werten\".</p><p>Sie können auch ein monatliches Dataset auf ein tägliches Dataset reduzieren, indem Sie die Dimensionsdefinition \"Nach Intervall\" verwenden und für den Parameter \"Schritt\" den Wert \"1\" und für den Parameter \"Einheit\" den Wert \"Tage\" angeben.</p><p>Mit der Dimensionsdefinition \"Nach Ziel-Raster\" können Sie den Wert für das Ziel-Raster schätzen.</p>",
		multidimensionalFilterSnip: "Erstellt einen Raster-Layer aus einem multidimensionalen Raster-Dataset oder einem multidimensionalen Raster-Layer, indem Daten entlang definierter Variablen und Dimensionen aufgeteilt werden.",
		multidimensionalFilterDesc: "Das Werkzeug \"Multidimensionaler Filter\" erstellt einen multidimensionalen Raster-Layer, indem es eine Teilmenge von Variablen aus einem multidimensionalen Raster herausfiltert und extrahiert. Beispiel: Sie verfügen über ein multidimensionales Dataset, das die monatlichen Niederschlagsdaten von 30 Jahren enthält. Sie möchten Daten für den Januar der einzelnen Jahre extrahieren, um zu ermitteln, wie sich der Niederschlag in diesem Monat im Lauf der Jahre verändert hat.<div><br/>Verwenden Sie den Parameter \"Dimensionsdefinition\", um Dimensionen über ein Intervall, einen Wert oder einen Wertebereich aufzuteilen. Beispiel: Ihnen stehen für 10 Jahre Daten zum Salzgehalt des Meerwassers, die monatlich alle 2 Meter bis zu einer Tiefe von 500 Metern erfasst wurden, zur Verfügung. In diesem Fall können Sie die verschiedenen Optionen zur Dimensionsdefinition für die folgenden Szenarien verwenden. Szenario1: Extrahieren der Daten zum Salzgehalt für den Monat Januar über den Zeitraum von 10 Jahren. Wählen Sie \"Durch Werte\" aus. Legen Sie für \"Dimension\" den Wert \"StdTime\" und für \"Werte\" die Option \"Januar\" fest. Szenario 2: Aufteilen der Daten zum Salzgehalt für den Tiefenbereich 0 bis 150 Meter. Wählen Sie \"Nach Bereichen\" aus. Legen Sie für \"Dimension\" den Wert \"StdZ\", für \"Minimalwert\" den Wert \"-150\" und für \"Maximalwert\" den Wert \"0\" fest. Szenario 3: Extrahieren der Daten zum Salzgehalt für die ersten 10 Tage des Monats Januar über einen Zeitraum von 10 Jahren. Wählen Sie \"Nach Iteration\" aus. Legen Sie für \"Dimension\" den Wert \"StdTime\", für \"Beginn der ersten Iteration\" und \"Ende der ersten Iteration\" den entsprechenden Beginn und das Ende des Iterationszeitraums und für \"Schritt\" den Wert \"1\" fest, und geben Sie unter \"Einheit\" die Option \"Jahre\" an.</div>",
		multidimensionalRasterName: "Multidimensionales Raster",
		multidimensionalRasterSnip: "Fügt multidimensionale Daten als multidimensionalen Raster-Layer zu einer Karte hinzu.",
		multidimensionalRasterDesc: "Die Funktion \"Multidimensionales Raster\" fügt multidimensionale Daten als multidimensionalen Raster-Layer zu einer Karte hinzu. Diese Funktion ist hilfreich, wenn Raster-Analyse-Workflows mithilfe einer Funktionskette durchgeführt werden.<div><br/>Die unterstützten multidimensionalen Raster-Datasets sind netCDF, GRIB, HDF und Esri CRF. Multidimensionale Mosaik-Datasets werden auch unterstützt.</div>",
		optimalPathAsRasterName: "Optimaler Pfad als Raster",
		optimalPathAsRasterSnip: "Berechnet den kostengünstigsten Pfad von einer Quelle zu einem Ziel.",
		optimalPathAsRasterDesc: "Mit dieser globalen Funktion wird ein Ausgabe-Raster erzeugt, das den oder die optimalen Pfade von ausgewählten Positionen zur jeweils nächstgelegenen Quellenzelle aufzeichnet, die innerhalb der akkumulativen Kostenoberfläche definiert wurden (hinsichtlich der Kostenentfernung).<div><br/>Im Allgemeinen muss mindestens eine Funktion für gewichtete Kosten (Entfernungsakkumulation oder Entfernungsallokation) vor der Ausführung der Funktion \"Optimaler Pfad als Raster\" ausgeführt werden, um das Eingabe-Entfernungsakkumulations- und Gegenrichtungs-Raster zu erstellen. Dies sind erforderliche Eingabe-Raster-Layer für die Funktion \"Optimaler Pfad\". Die Werte für den optimalen Ausgabepfad stellen die Anzahl der Pfade an einer gegebenen Position dar. Häufig folgen die Pfade derselben Route ab einer Quelle und verzweigen sich dann zu unterschiedlichen Zielen. Beispielsweise bedeutet der Wert 1, dass an einer gegebenen Position nur ein optimaler Pfad vorhanden ist, und der Wert 5 bedeutet, dass an dieser Position fünf optimale Pfade vorhanden sind, die durch diese Zelle im Untersuchungsgebiet verlaufen.<div><br/>Bei den Eingabezieldaten muss es sich um einen Raster-Layer handeln. Die Menge der Zielzellen besteht aus allen Zellen im Eingabe-Raster, die über gültige Werte verfügen. Zellen mit NoData-Werten sind nicht in der Menge enthalten. Der Wert 0 wird als ein rechtmäßiges Ziel betrachtet. Ein Ziel-Raster kann mit den Extraktionswerkzeugen erstellt werden. Möglicherweise vorhandene Ziel- oder Quell-Features können mit der Funktion \"Features rastern\" in Raster konvertiert werden. Verwenden Sie als Raster-Eingabe für die Funktion zur Rasterung das Entfernungsakkumulations- oder Gegenrichtungs-Raster. Dadurch wird sichergestellt, dass das Feature mit derselben Zellengröße, derselben Ausdehnung und demselben Raumbezug wie die anderen Raster, die als Eingabe für die Funktion \"Optimaler Pfad als Raster\" dienen, gerastert wird. Die Funktion \"Optimaler Pfad als Raster\" kann auch verwendet werden, um den Pfad des geringsten Widerstands entlang eines digitalen Höhenmodells (DEM) abzuleiten. Verwenden Sie in diesem Fall das DEM für das Eingabe-Entfernungsakkumulations--Raster und die Ausgabe aus der Funktion \"Fließrichtung\" für das Gegenrichtungs-Raster.</div>",
		trendName: "Mit Trend vorhersagen",
		trendSnip: "Berechnet einen prognostizierten multidimensionalen Raster-Layer mithilfe des Ausgabe-Trend-Rasters aus der Funktion \"Trend generieren\" oder aus dem Geoverarbeitungswerkzeug \"Trend-Raster generieren\".",
		trendDesc: "Die Funktion \"Mit Trend vorhersagen\" berechnet einen prognostizierten multidimensionalen Raster-Layer mithilfe des Ausgabe-Trend-Rasters aus der Funktion \"Trend generieren\" oder aus dem Geoverarbeitungswerkzeug \"Trend-Raster generieren\".",
		rasterCollectionName: "Raster-Sammlung verarbeiten",
		rasterCollectionSnip: "Verarbeitet jeden Ausschnitt in einem multidimensionalen Raster oder jedes Element in einem Mosaik-Raster. Mit dieser Funktion können auch mehrere Ausschnitte zu einem einzelnen aggregiert werden.",
		rasterCollectionDesc: "Die Funktion \"Raster-Sammlung verarbeiten\" verarbeitet jeden Ausschnitt in einem multidimensionalen Raster oder jedes Element in einem Mosaik-Raster. Mit dieser Funktion können auch mehrere Ausschnitte zu einem einzelnen aggregiert werden.<div><br/>Diese Funktion verarbeitet einzelne Ausschnitte in multidimensionalen Rastern oder Mosaik-Rastern mithilfe einer Raster-Funktionsvorlage. Diese Funktion unterstützt die folgenden Optionen: 1. Angeben einer Raster-Funktionsvorlage für die \"Elementfunktion\". Sie haben zum Beispiel ein Mosaik-Dataset, das Landsat-Bilddaten aus einem Zeitraum von 20 Jahren enthält, und Sie möchten den NDVI für jede Szene in der Zeitserie berechnen. Geben Sie als \"Elementfunktion\" eine Raster-Funktionsvorlage an, die die NDVI-Raster-Funktion enthält. Angeben einer Raster-Funktionsvorlage für die Aggregationsfunktion. 2. Sie haben zum Beispiel ein multidimensionales Raster, das die Tagestemperaturdaten aus einem Zeitraum von 10 Jahren enthält, und Sie möchten die maximalen Jahrestemperaturen berechnen. Geben Sie als \"Aggregationsfunktion\" eine Raster-Funktionsvorlage an, die die Funktion \"Zellenstatistik\" enthält, und setzen Sie die Operation auf \"Maximum\". Legen Sie unter \"Aggregationsdefinition\" für die \"Dimension\" die Option \"StdTime\", für den \"Typ\" die Option \"Intervallschlüsselwort\" und für das \"Schlüsselwortintervall\" die Option \"Jährlich\" fest. Beachten Sie, dass die Aggregationsdefinition von der Aggregationsfunktion nicht berücksichtigt wird, wenn das Eingabe-Mosaik-Dataset nicht multidimensional ist. Die Aggregationsfunktion aggregiert alle Elemente oder jede Gruppe in eine, wenn sie in der Vorlage der Aggregationsfunktion definiert sind. Weitere Informationen zur Verwendung von Gruppen in einem Mosaik-Dataset finden Sie unter Verwenden von Mosaik-Dataset-Elementen in Raster-Funktionsvorlagen. 3. Geben Sie eine Raster-Funktionsvorlage für die \"Verarbeitungsfunktion\" an. Die Funktion oder Funktionskette in dieser Vorlage dient der Anzeige des neuen verarbeiteten Rasters. Sie können zum Beispiel eine Raster-Funktionsvorlage mit der Funktion \"Colormap\" angeben, um Darstellungsweise des verarbeiteten Raster-Layers zu ändern. Beachten Sie, dass die Funktion auf den aktuellen Anzeigeausschnitt angewendet wird, wenn die Eingabe ein multidimensionales Raster ist. Wenn die Eingabe ein Mosaik-Layer oder ein Mosaik-Dataset ist, wird die Verarbeitungsfunktion mit der Methode \"Erste(r)\" auf das Mosaik-Raster angewendet, um Überlappungen aufzulösen. 3. Sie können Vorlagen für eine beliebige Kombination aus den drei Funktionen angeben. Sie haben zum Beispiel ein Mosaik-Dataset, das eine Zeitserie aus Landsat-Bilddaten enthält, und möchten ein zusammengesetztes Bild mit maximalem NDVI erstellen. Geben Sie als \"Elementfunktion\" eine Raster-Funktionsvorlage an, die die NDVI-Raster-Funktion enthält. Geben Sie als \"Aggregationsfunktion\" eine Raster-Funktionsvorlage an, die die Funktion Zellenstatistik enthält, und setzen Sie die Operation auf \"Maximum\". Geben Sie als \"Verarbeitungsfunktion\" eine Raster-Funktionsvorlage an, die die Funktion \"Colormap\" enthält. Beachten Sie, dass die Verarbeitungsreihenfolge der Funktion der Reihenfolge der Eingabeparameter entspricht. Die \"Elementfunktion\" wird beispielsweise zuerst verarbeitet.</div>",
		randomName: "Zufällig",
		randomSnip: "Erstellt ein Raster mit zufälligen Pixelwerten, die aus einer Pseudozufallsverteilung abgerufen werden. Es werden verschiedene Verteilungen und Zufallszahlengeneratoren unterstützt.",
		randomDesc: "Mit der neuen Funktion \"Zufallsprinzip\" wird ein Raster mit zufälligen Pixelwerten erstellt, das in Raster-Funktionsvorlagen oder Mosaik-Datasets verwendet werden kann.<div><br/>Viele Funktionen können in einem oder mehreren Eingabe-Rastern verwendet werden. Für die Zufallsfunktion ist dagegen kein Eingabe-Raster erforderlich. Das bedeutet, dass sie sich weniger wie eine Funktion als vielmehr wie ein Raster-Dataset verhält. Daher muss bei deren Hinzufügung zu bzw. Entfernung aus der Funktionskette mit besonderer Sorgfalt vorgegangen werden.</div>",
		shrinkName: "Verkleinern",
		shrinkSnip: "Verkleinert die ausgewählten Zonen um eine angegebene Anzahl an Zellen, indem sie durch den Wert der Zelle ersetzt werden, der in der Nachbarschaft am häufigsten vorkommt.",
		shrinkDesc: "Mit der globalen Funktion \"Verkleinern\" können Sie Raster generalisieren oder vereinfachen, indem Sie bestimmte Zonen verkleinern. Darüber hinaus können Sie den Grad der Generalisierung steuern.<div><br/>Die ausgewählten Zonen werden verkleinert bzw. in ihrer Größe reduziert, indem Zellen aus umliegenden Zonen auf sie erweitert werden. Konzeptionell gesehen können die ausgewählten \"Zonenwerte\" als Vordergrundzonen betrachtet werden, während die anderen Werte Hintergrundzonen bleiben. Die Zellen in den Vordergrundzonen können durch Zellen in den Hintergrundzonen ersetzt werden. Dünne Inseln in einer Zone, deren Grenzen als gemeinsame Grenzen mit der Zone angesehen werden können, werden möglicherweise ebenfalls ersetzt.<div><br/>Der Grad der Generalisierung kann mit dem Parameter \"Anzahl der Zellen\" gesteuert werden. Standardmäßig lautet dieser Wert 1, d. h. die ausgewählten Zonen werden um jeweils eine Zelle verkleinert. Um den Grad der Generalisierung zu erhöhen, können Sie für diesen Parameter einen größeren Wert eingeben. Konzeptionell kommt dies dem Ausführen des Werkzeugs mit einer Häufigkeit gleich, die der angegebenen Anzahl entspricht, wobei die Ergebnisse der vorherigen Ausführung die Eingabe der nächsten Ausführung sind.</div>",
		trendToRGBName: "Trend in RGB",
		trendToRGBSnip: "Konvertiert ein Trend-Raster in ein RGB-Raster (Rot, Grün und Blau) mit drei Bändern.",
		trendToRGBDesc: "Mit der Funktion \"Trend in RGB\" wird ein Trend-Raster in ein Raster mit drei Bändern (Rot, Grün und Blau) konvertiert. Das Trend-Raster wird aus der Raster-Funktion \"Trend generieren\" oder der Raster-Funktion \"CCDC-Analyse\" generiert.<div><br/>Diese Funktion ist hilfreich bei der Visualisierung von Modellkoeffizientendaten aus der Funktion \"Trend generieren\" oder \"CCDC-Analyse\". In beiden Funktionen werden Trends bei sich ändernden Pixelwerten abgeschätzt, die Ergebnisse der Funktionen lassen sich jedoch nur schwer direkt interpretieren.<div><br/>Wie bei vielen Raster-Funktionen müssen Sie möglicherweise die dynamische Bereichsanpassung (DRA) verwenden, um die Ergebnisse der Funktion besser anzeigen zu können.</div>",
		landTrendrName: "LandTrendr-Analyse",
		landTrendrSnip: "Überprüft mit der Landsat-Methode zur Erkennung von Störungs- und Regenerationstendenzen (LandTrendr) Veränderungen von Pixelwerten im Zeitverlauf und generiert ein Veränderungsanalyse-Raster, das die Modellergebnisse enthält.",
		landTrendrDesc: "Diese Raster-Funktion kann nur als Eingabe für die Raster-Funktion Veränderung mit Veränderungsanalyse erkennen verwendet werden. Um eine Raster-Ausgabe zu erzeugen, verbinden Sie die LandTrendr-Analyse-Funktion in einer Raster-Funktionsvorlage mit der Funktion \"Veränderung mit Veränderungsanalyse erkennen\", und verwenden Sie die Vorlage als Eingabe für das Geoverarbeitungswerkzeug \"Raster über Raster-Funktion erstellen\". Das Ergebnis ist ein Raster, das Informationen über den Zeitpunkt enthält, an dem sich Pixelwerte verändert haben.<div><br>Der Zweck dieser Raster-Funktion besteht darin, Veränderungen an einem beobachteten Feature zu extrahieren, sodass die optimalen multidimensionalen Eingabe-Bilddaten im Zeitverlauf eine konsistente Beobachtung erfassen und keine atmosphärischen oder Sensorstörungen, Wolken bzw. Wolkenschatten enthalten sollten. Es hat sich bewährt, Daten zu verwenden, die normalisiert wurden und mit einem QA-Band maskiert werden können, z. B. Produkte aus der Landsat-Sammlung 1 zur Oberflächenreflexion mit einer Wolkenmaskierung.<div><br>Die Funktion führt die Analyse für ein Bild pro Jahr aus, und die Anzahl der Jahresabschnitte muss gleich oder größer sein als der im Parameter <strong>Minimale Anzahl der Beobachtungen</strong> angegebene Wert. Es wird empfohlen, Daten aus mindestens sechs Jahren zu verwenden.<div><br>Wenn Sie über monatliche, wöchentliche oder tägliche Daten verfügen, sollten Sie aus jedem Jahr mehrere Bilder auswählen (vorzugsweise aus der gleichen Jahreszeit), Wolken und Wolkenschatten entfernen und durch Kombinieren der Bilder ein einzelnes Bild generieren, das die Beobachtung gut erfasst. Sofern monatliche, wöchentliche oder tägliche Daten als multidimensionales Eingabe-Raster bereitgestellt werden, ermittelt die Funktion einen Abschnitt für die Analyse auf der Grundlage des Datums, das dem im Parameter <strong>Fangdatum</strong> angegebenen Datum am nächsten liegt.<div><br>Ein Feature in einer Landschaft braucht häufig einige Zeit, bis es sich von einer nicht dauerhaften Veränderung wie einem Waldbrand oder einem Insektenbefall erholt hat. Legen Sie den Parameter \"Regenerationsschwellenwert\" fest, um die vom Modell erkannte Regenerationsrate zu steuern. Ein eindeutiges Segment kann keine schnellere Regenerationsrate als 1/Regenerationsschwellenwert aufweisen.<div><br>Die Regeneration nach einer Veränderung in einer Landschaft kann in positiver oder negativer Richtung erfolgen. Erleidet eine Landschaft z. B. Waldverlust, zeigt eine Zeitserie von Vegetationsindexwerten einen Rückgang der Indexwerte, und die Regeneration zeigt einen allmählichen Anstieg der Vegetationsindexwerte oder einen positiven Regenerationstrend. Geben Sie die Richtung des Regenerationstrends mit dem Parameter <strong>Regeneration mit zunehmendem Trend</strong> an.",
		aggregateMultidimensionalName: "Multidimensional aggregieren",
		aggregateMultidimensionalSnip: "Kombiniert vorhandene multidimensionale Raster-Variablendaten entlang einer Dimension.",
		aggregateMultidimensionalDesc: "Mit der Funktion \"Multidimensional aggregieren\" wird ein multidimensionaler Raster-Layer erstellt, indem vorhandene multidimensionale Raster-Variablendaten entlang einer Dimension miteinander kombiniert werden.<div><br>Mit dem Parameter <strong>Dimensionsdefinition</strong> filtern Sie zunächst die Eingabedaten, die Sie aggregieren möchten. Wenn Sie beispielsweise über monatliche Daten aus 30 Jahren verfügen, aber nur einen aggregierten Layer für die ersten 15 Jahre erstellen möchten, können Sie mithilfe des Parameters <strong>Dimensionsdefinition</strong> die Jahre angeben, die in die Analyse einbezogen werden sollen.<div><br><ul><li>Extrahieren der Daten zum Salzgehalt für den Monat Januar über den Zeitraum von 10 Jahren. Wählen Sie <strong>Durch Werte</strong> aus. Legen Sie für <strong>Dimension</strong> den Wert <strong>StdTime</strong> und für <strong>Werte</strong> die Option <strong>Januar</strong> fest.</li><li>Aufteilen der Daten zum Salzgehalt für den Tiefenbereich 0 bis 150 Meter. Wählen Sie <strong>Nach Bereichen</strong> aus. Legen Sie für <strong>Dimension</strong> den Wert <strong>StdZ</strong>, für <strong>Minimalwert</strong> den Wert <strong>-150</strong> und für <strong>Maximalwert</strong> den Wert <strong>0</strong> fest.</li><li>Extrahieren der Daten zum Salzgehalt für die ersten 10 Tage des Monats Januar über einen Zeitraum von 10 Jahren. Wählen Sie <strong>Nach Iteration</strong> aus. Legen Sie für <strong>Dimension</strong> den Wert <strong>StdTime</strong> fest und für <strong>Beginn der ersten Iteration</strong> sowie <strong>Ende der ersten Iteration</strong> entsprechend den Beginn und das Ende des Iterationszeitraums. Legen Sie für <strong>Schritt</strong> den Wert <strong>1</strong> und für <strong>Einheit</strong> die Option <strong>Jahre</strong> fest.</li></ul><div><br>Verwenden Sie die Parameter unter <strong>Aggregationsdefinition</strong>, um mithilfe eines Schlüsselwortes, eines Wertes oder eines Wertebereichs die zu bewertende Dimension und das Aggregationsintervall auszuwählen. Beispiel: Ihnen stehen für 30 Jahre Temperaturdaten der Meeresoberfläche zur Verfügung, die täglich alle 5 Meter bis zu einer Tiefe von 100 Metern erfasst wurden. In diesem Fall können Sie die verschiedenen Intervalloptionen für die folgenden Szenarien verwenden:<div><br><ul><li>Tagestemperaturdaten in monatliche Daten aggregieren, sodass sich ein multidimensionales Raster mit 12 Zeitintervallen ergibt und jedes Intervall das Aggregat der einzelnen Monate für alle Jahre ist. Wählen Sie <strong>Intervallschlüsselwort</strong> aus, und legen Sie für das Schlüsselwort die Option <strong>Monatlich wiederkehrend</strong> fest.</li><li>Tagestemperaturdaten in monatliche Daten aggregieren, sodass sich ein multidimensionales Raster mit 360 Zeitintervallen bzw. 12 Zeitintervallen pro Jahr ergibt (30 Jahre x 12 Monate = 360 Zeitintervalle). Wählen Sie <strong>Intervallschlüsselwort</strong> aus, und legen Sie für das Schlüsselwort die Option <strong>Monatlich</strong> fest.</li><li>Monatliche Temperaturdaten in 4-Monats-Intervalle aggregieren. Wählen Sie <strong>Intervallwert</strong> aus, legen Sie für <strong>Wertintervall</strong> den Wert 4 fest und für <strong>Einheit</strong> die Option <strong>Monate</strong>.</li><li>Temperaturdaten von 0 bis 25 Meter, 25 bis 50 Meter und 50 bis 100 Meter aggregieren. Wählen Sie <strong>Intervallbereiche</strong> aus, und geben Sie für die minimalen und maximalen Tiefenwerte <strong>0 25; 25 50; 50 100</strong> ein.</li></ul>",
		mergeRastersName: "Raster zusammenführen",
		mergeRastersSnip: "Kombiniert mehrere Raster-Datasets räumlich oder für verschiedene Variablen und Dimensionen.",
		mergeRastersDesc: "Diese Funktion erstellt aus einer Liste von Rastern ein zusammengeführtes Raster. Wenn Sie beispielsweise über ein Mosaik-Dataset verfügen, das die monatlichen Niederschlagsdaten von 30 Jahren enthält, und ein weiteres Dataset mit monatlichen Temperaturdaten für 10 Jahre, können Sie diese zu einem multidimensionalen Raster mit beiden Variablen kombinieren. <div><br>Wenn die multidimensionalen Eingabe-Raster unterschiedliche Variablen enthalten, enthält das multidimensionale Ausgabe-Raster sämtliche Variablen. <div><br>Wenn die multidimensionalen Eingabe-Raster unterschiedliche Dimensionen oder Dimensionswerte enthalten, enthält das multidimensionale Ausgabe-Raster sämtliche Dimensionen und Dimensionswerte. <div><br>Wenn die multidimensionalen Eingabe-Raster dieselben Dimensionen und Variablen, jedoch unterschiedliche räumliche Ausdehnungen enthalten, enthält das multidimensionale Ausgabe-Raster die Variablen und Dimensionen für die zusammengeführten räumlichen Ausdehnungen.<div><br>Verwenden Sie diese Funktion, wenn Sie mehrere Raster haben, die Sie als ein Element behandeln möchten, z. B. beim Berechnen einer Statistik für alle Bilder oder beim Farbausgleich, um den Farbausgleich nicht für jedes Bild separat vornehmen zu müssen. Dies ist nützlich bei der Arbeit mit Bilddaten, die aufgrund von Dateigrößenbeschränkungen als getrennte Kacheln gespeichert sind. Auf diese Weise werden die Kacheln als Teil eines Bildes behandelt.",
		boundaryCleanName: "Grenzen glätten",
		boundaryCleanSnip: "Glättet die Grenze zwischen Zonen.",
		boundaryCleanDesc: "<p>Die Funktion generalisiert bzw. vereinfacht Raster, indem sie die Grenzen zwischen Zonen glättet. In der Funktion sind Optionen verfügbar, mit denen gesteuert wird, welche Auswirkungen die Zellen der Eingabezonen auf das Glätten und den angewendeten Glättungsgrad haben. Jede Eingabezelle wird anhand der acht nächsten Nachbarn ausgewertet.</p><p>Beim Glättungsvorgang werden zuerst die Nachbarzellen nach einer bestimmten Priorität geordnet. Durch die Priorität wird festgelegt, welche Zone aus den Nachbarzellen den Wert der Verarbeitungszelle in der Ausgabe ersetzen kann.</p><p>Die Priorität kann entweder auf dem Wert der Zonen oder der Größe der Zonen basieren. Mit dem Parameter <strong>Sortiertyp</strong> wird der verwendete Sortiertyp bestimmt. </p><p>Bei der Standardeinstellung <strong>Nicht sortieren</strong> wird die Priorität basierend auf dem Wert der Zonen ausgewertet. Zellen aus Zonen mit höheren Werten haben für die Ausdehnung in Zonen mit niedrigeren Werten eine höhere Priorität.</p><p>Die Größe bzw. Gesamtfläche der Zonen kann für die Sortierung nach Priorität verwendet werden. Mit der Einstellung <strong>Absteigend</strong> werden die Zonen in absteigender Reihenfolge nach Größe geordnet. Zonen mit größerer Gesamtfläche haben für die Ausdehnung in Zonen mit kleinerer Gesamtfläche eine höhere Priorität. Bei der Einstellung <strong>Aufsteigend</strong> trifft das Gegenteil zu: Zonen mit kleinerer Gesamtfläche haben für die Ausdehnung in Zonen mit größerer Gesamtfläche eine höhere Priorität.</p><p>Der Glättungsgrad wird mit dem Parameter <strong>Ausdehnen und Verkleinern zweimal durchlaufen</strong> gesteuert. Damit wird die Anzahl der Durchgänge für den Ausdehnungs- und Verkleinerungsvorgang festgelegt.</p><p>Ist die Einstellung deaktiviert, wird der Ausdehnungs- und Verkleinerungsvorgang einmal durchgeführt. Ist die Einstellung hingegen aktiviert, wird der Ausdehnungs- und Verkleinerungsvorgang zweimal durchgeführt, sodass sich eine stärkere Glättung der Zonengrenzen ergibt.</p><p>Wenn die Werte aller acht Nachbarzellen dem der Verarbeitungszelle entsprechen, behält die Ausgabezelle den Wert der Eingabezelle bei.</p>",
		predictUsingRegressionName: "Mit Regression vorhersagen",
		predictUsingRegressionSnip: "Berechnet ein vorhergesagtes Raster basierend auf Raster-Daten-Eingaben und einem Regressionsmodell. Das Regressionsmodell ist die Ausgabe des Geoverarbeitungswerkzeugs <strong>Regressionsmodell \"Random Trees\" trainieren</strong>.",
		predictUsingRegressionDesc: "<p>Das Regressionsmodell ist in einer Esri Regressionsdefinitionsdatei (.ecd) definiert. Sie enthält alle Informationen für ein bestimmtes Dataset bzw. verschiedene Datasets sowie das Regressionsmodell und wird durch das Raster-Geoverarbeitungswerkzeug <strong>Regressionsmodell \"Random Trees\" trainieren</strong> generiert.</p><p>Die Eingabe kann ein Einzelband-, ein Multiband- oder ein multidimensionales Raster oder eine Liste dieser Typen sein. Die Typen der Eingabe-Raster müssen mit dem durch das Regressionsmodell trainierten Raster-Typ identisch sein.</p><ul><li>Wenn die Eingabe ein Multiband-Raster ist, wird jedes Band als Einflussvariable behandelt. Die Reihenfolge der Bänder muss mit der Multiband-Eingabe für das Regressionsmodell-Trainingswerkzeug identisch sein.</li><li>Wenn die Eingabe ein multidimensionales Raster ist, wird jede Variable als Einflussvariable behandelt. Außerdem muss die Variable eine Einzelband-Variable mit einer Zeitdimension sein. Die Reihenfolge und Namen der Variablen müssen mit der Eingabe beim Trainieren des Regressionsmodells identisch sein. Bei der Ausgabe handelt es sich um ein multidimensionales Raster.</li><li>Die Eingabe kann eine Elementliste sein. Die Anzahl und Reihenfolge der Elemente muss mit der Eingabe beim Trainieren des Regressionsmodells identisch sein.</li></ul>",
		dimensionalMovingStatisticsName: "Gleitende Dimensionsstatistiken",
		dimensionalMovingStatisticsSnip: "Berechnet in einem gleitenden Fenster und entlang einer bestimmten Dimension Statistiken für multidimensionale Daten.",
		dimensionalMovingStatisticsDesc: "<p>Mit der Funktion \"Gleitende Dimensionsstatistiken\" werden in einem vordefinierten Fenster für alle Dimensionswerte entlang einer bestimmten Dimension verschiedene Statistiken berechnet. Diese Funktion unterstützt einen multidimensionalen Raster-Layer als Eingabe und erstellt als Ausgabe einen multidimensionalen Raster-Layer, der die gleiche Dimensionsgröße wie der Eingabe-Layer aufweist.</p><p>Sie können eine Dimension angeben, für die bei der Berechnung Dimensionswerte berücksichtigt werden. Standardmäßig erfolgt die Berechnung entlang der ersten nichträumlichen Dimension. Mit den Parametern \"Rückwärtsgleitendes Fenster\" und \"Vorwärtsgleitendes Fenster\" können Sie auch eine Fenstergröße angeben.</p><p>Wenn als Statistiktyp \"Perzentil\" ausgewählt ist, werden die Parameter \"Perzentilwert\" und \"Perzentil-Interpolationstyp\" verfügbar. Über diese Parameter können Sie das zu berechnende Perzentil angeben bzw. den zu verwendenden Interpolationstyp auswählen. Wenn als Statistiktyp \"Zirkulärer Mittelwert\" festgelegt ist, wird der Parameter \"Umbruchwert für Verteilung auf Einheitskreis\" verfügbar. Anhand des Umbruchwertes für die Verteilung auf dem Einheitskreis wird ein linearer Wert in den Bereich eines bestimmten zirkulären Mittelwertes konvertiert.</p>",
		terrainFlattenFunctionName: "Terrain-Abplattung",
		terrainFlattenFunctionSnip: "Korrigiert radiometrische Verzerrungen aufgrund der Topografie in den Eingabe-SAR-Daten (SAR, Synthetic Aperture Radar).",
		terrainFlattenFunctionDesc: "<p>Die Raster-Funktion \"Terrain-Abplattung\" korrigiert radiometrische Verzerrungen aufgrund der Topografie in den Eingabe-SAR-Daten (SAR, Synthetic Aperture Radar).</p><p>Die Eingaberadardaten müssen zuerst auf Beta-Nought kalibriert werden. Kalibrieren Sie die Radardaten mit dem Werkzeug \"Radiometrische Kalibrierung anwenden\" auf Beta-Nought.</p><p>Wenn das Eingabe-DEM nicht das gesamte SAR-Dataset abdeckt und es sich um Ausgaben vom Typ \"Gamma-Nought\", \"Sigma-Nought\", \"Streuungsfläche\" und \"Geometrische Verzerrung\" handelt, gibt das Werkzeug NoData-Werte für die Pixel außerhalb der DEM-Ausdehnung aus. Bei Ausgaben vom Typ \"Geometrische Verzerrungsmaske\" gibt das Werkzeug den Wert \"Unbestimmt\" für Pixel außerhalb der DEM-Ausdehnung aus.</p><p>Das Eingabe-DEM muss im geografischen Koordinatensystem WGS 1984 (EPSG:4326) vorliegen.</p>",
		createColorCompositeFunctionName: "Farbkompositbild erstellen",
		createColorCompositeFunctionSnip: "Erstellt ein Dreiband-Raster aus einem Multiband-Raster-Dataset, bei dem jedes Band eine algebraische Berechnung verwenden kann, die auf Bandalgebra basiert.",
		createColorCompositeFunctionDesc: "<p>Die Raster-Funktion \"Farbkompositbild erstellen\" erstellt ein Dreiband-Raster aus einem Multiband-Raster-Dataset, bei dem jedes Band eine algebraische Berechnung verwenden kann, die auf Bandalgebra basiert.</p><p>Beim Definieren des Algorithmus für eine Bandarithmetik können Sie eine einzeilige algebraische Formel für jeden Ausdruck eingeben, um eine Multiband-Ausgabe zu erstellen. Unterstützt werden unäre Operatoren: Plus (+), Minus (-), Multiplizieren (*) und Dividieren (/).</p><p>Wenn in einem Ausdruck eine Band-ID verwendet wird, identifizieren Sie das Band, indem Sie der Bandnummer B oder b voranstellen.</p><p>Eine typische Bandkombination, die für Synthetic Aperture Radar (SAR) in linearen Einheiten verwendet wird, ist VV für Rot, VH für Grün und VV/VH für Blau. Wenn die Eingabedaten in Dezibel angegeben sind, sollte die Bandkombination VV für Rot, VH für Grün und VV-VH für Blau lauten.</p>",
		surfaceParametersName: "Oberflächenparameter",
		surfaceParametersSnip: "Mit dieser Funktion werden mithilfe von geodätischen Methoden Parameter eines Oberflächen-Rasters wie Ausrichtung, Neigung und verschiedene Arten von Krümmungen ermittelt.",
		surfaceParametersDesc: "<p>Mit der Funktion \"Oberflächenparameter\" werden mithilfe von geodätischen Methoden Parameter eines Oberflächen-Rasters wie Ausrichtung, Neigung und verschiedene Arten von Krümmungen ermittelt.</p><p>Diese Funktion kann für die folgenden Anwendungen verwendet werden:</p><ul><li>Berechnen der Ausrichtung und Neigung mithilfe von geodätischen Methoden</li><li>Berechnen verschiedener Arten von Krümmungen aus einem Eingabe-Oberflächen-Raster, z. B. <strong>Tangentialkrümmung (Normalkontur), </strong> womit die topografische Konvergenz und Divergenz eines Flusses auf der Oberfläche beschrieben werden.</li></ul>",
		leastCostCorridorName: "Kostengünstigster Korridor",
		leastCostCorridorSnip: "Berechnet die Summe von zwei akkumulativen Kostenentfernungs-Rastern. Dabei besteht die Option, basierend auf dem Prozentsatz der Minimalkosten oder den akkumulativen Kosten einen Schwellenwert anzuwenden.",
		leastCostCorridorDesc: "<p>Die Eingabe-Raster müssen Entfernungsakkumulations- und Gegenrichtungs-Raster-Ausgaben der Funktion <strong>Entfernungsakkumulation</strong> oder <strong>Entfernungsallokation</strong> sein. Sie sollten auf der Kostenentfernung basieren, und beim Erstellen der Layer für die jeweilige Quelle sollten dieselben Parameter verwendet werden. Beim Erstellen dieser Raster dürfen keine Parameter verwendet werden, die richtungsabhängig (horizontaler Faktor, vertikaler Faktor und Reiserichtung) sind.</p><p>Die Werte im Ausgabe-Korridor-Raster entsprechen der Summe der akkumulativen Kosten beim Erreichen einer bestimmten Position mit den gleichen Einheiten wie die Eingabe-Raster der akkumulativen Kostenentfernung.</p><p>Wenn ein angegebener <strong>Schwellenwert</strong> größer ist als die maximalen akkumulativen Kosten beim Summieren der zwei Entfernungsakkumulations-Raster, deckt das Ausgabe-Korridor-Raster die gleiche Fläche wie die Eingabe-Akkumulations-Raster ab.</p><p>Wenn ein angegebener Schwellenwert unter dem Minimalwert im Korridor-Raster liegt, wird eine Warnmeldung zurückgegeben, und das Ausgabe-Raster ist leer.</p><p>Das Ausgabe-Korridor-Raster kann Zellen mit etwas höheren akkumulativen Kosten als der Schwellenwert enthalten. Diese entstehen dadurch, dass in Gegenrichtungs-Rastern Zellen verwendet werden, denen etwas höhere Kosten zugewiesen sind, um unverbundene Zellen mit dem Korridor zu verbinden.</p>",
		geometricMedianName: "Geometrischer Medianwert",
		geometricMedianSnip: "Mit der Funktion \"Geometrischer Medianwert\" wird der geometrische Medianwert aller Pixel in einer Zeitserie von Multiband-Bilddaten berechnet.",
		geometricMedianDesc: "<p>Mit dieser Funktion werden Rauschen und Ausreißer in Zeitserien-Bilddaten reduziert, indem ein geometrischer Medianpixel für jedes Pixel-Array der Bildserie berechnet wird. Der Algorithmus behält die spektralen Beziehungen zwischen den Bändern in den Pixelspektren bei, deshalb kann die Ausgabe in Analysen verwendet werden (z. B. Vegetationsindizes).</p><p>Wolken und Schatten sollten mit dem Dataset-QA-Band maskiert werden, bevor diese Funktion angewendet wird.</p><p>Wenn es sich um ein Gleitkomma-Eingabebild handelt, etwa eine Oberflächenreflexion mit Werten zwischen 0 und 1, wird mit dem Epsilon-Wert 0,001 normalerweise ein gutes Ergebnis erzielt.</p>"
	},
	rfxArgs: {
		rasterName: "Raster",
		colorSchemeTypeName: "Typ des Farbschemas",
		colormapName: "Colormap",
		colormapNameName: "Colormap-Name",
		colorRampName: "Farbverlauf",
		contrastOffsetName: "Kontrastversatz",
		brightnessOffsetName: "Helligkeitsversatz",
		methodName: "Methode",
		bandNamesName: "Bandnamen",
		bandWavelengthsName: "Bandwellenlängen",
		bandIdsName: "Band-IDs",
		missingBandActionName: "Fehlende Bandaktion",
		conversionParametersName: "Konvertierungsparameter",
		hillshadeTypeName: "Schummerungstyp",
		azimuthName: "Azimut",
		altitudeName: "Höhe",
		slopeTypeName: "Skalierung",
		zFactorName: "Z-Faktor",
		PSPowerName: "Pixelgrößen-Potenz",
		PSZFactorName: "Pixelgrößenfaktor",
		removeEdgeEffectName: "Standardinterpolation für Kantenpixel deaktivieren",
		fromUnitName: "Ausgangseinheit",
		toUnitName: "Zieleinheit",
		rasterTypeName: "Typ",
		minName: "Ausgabe-Minimum",
		maxName: "Ausgabe-Maximum",
		minPercentName: "Minimaler Wert für \"Prozentual eingrenzen\"",
		maxPercentName: "Maximaler Wert für \"Prozentual eingrenzen\"",
		numberOfStandardDeviationName: "Anzahl der Standardabweichungen",
		sigmoidStrengthLevelName: "Sigmoid-Stärkestufe",
		estimateStatsHistogramName: "Statistiken schätzen",
		DRAName: "Dynamische Bereichsanpassung (DRA)",
		statisticsName: "Statistiken",
		histogramsName: "Histogramme",
		statisticsHistogramName: "Statistiken und Histogramm definieren",
		computeGammaName: "Automatische Gammafunktion",
		useGammaName: "Gamma verwenden",
		gammaName: "Gamma",
		inputNamesName: "Namen",
		expressionName: "Ausdruck",
		cellsizeTypeName: "Zellengrößentyp",
		extentTypeName: "Ausdehnungstyp",
		classifierDefinitionFileName: "Eingabe-Definitionsdatei",
		raster1Name: "Raster1",
		raster2Name: "Raster2",
		raster3Name: "Raster3",
		trueRasterName: "True-Raster",
		falseRasterName: "False-Raster",
		noDataInterpretationName: "NoData-Interpretation",
		noDataValuesName: "NoData-Werte",
		includedRangesName: "Eingeschlossene Bereiche",
		curvatureTypeName: "Krümmungstyp",
		rastersName: "Raster",
		attributeTableName: "Tabelle",
		attributeTableTypeName: "Tabellentyp",
		rowsName: "Anzahl Zeilen",
		columnsName: "Anzahl Spalten",
		kernelName: "Kernel",
		mirrorEdgesName: "Kanten spiegeln",
		influencesName: "Einflüsse",
		fieldsName: "Felder",
		remapsName: "Neuzuordnungs-Tabelle",
		evalFromName: "Auswertungsmaßstab von",
		evalToName: "Auswertungsmaßstab bis",
		weightsName: "Gewichtungen",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "Kurzbereichsradius für IDW",
		maxVoidWidthName: "Max. Lückenbreite",
		sigmaGaussianName: "Adaptive Glättung",
		contourTypeName: "Konturlinientyp",
		zBaseName: "Z-Basis",
		numberOfContoursName: "Anzahl der Konturlinien",
		contourIntervalName: "Konturlinienintervall",
		nthContourLineInBoldName: "N-te Konturlinie fett formatiert",
		featureClassName: "Eingabe-Features",
		classIndexFieldName: "Feld",
		resolveOverlapMethodName: "Die Methode \"Überlappung auflösen\"",
		resamplingTypeName: "Resampling-Typ",
		inputCellsizeName: "Eingabezellengröße",
		outputCellsizeName: "Ausgabezellengröße",
		pointFeatureClassName: "Schwerpunkte",
		maxGrowthRadiusFieldName: "Feld \"Max. Wachstumsradius\"",
		similarityThresholdFieldName: "Feld \"Ähnlichkeitsschwellenwert\"",
		fillValueFieldName: "Füllwertefeld",
		spectralDetailName: "Spektraldetail [1..20]",
		spatialDetailName: "Räumliches Detail [1..20]",
		minNumPixelsPerSegmentName: "Minimale Segmentgröße in Pixel",
		boundariesOnlyName: "Nur Segmentgrenzen",
		statisticsTypeName: "Statistiktyp",
		fillNoDataOnlyName: "Nur NoData-Pixel füllen",
		inputDataTypeName: "Eingabedatentyp",
		angleReferenceSystemName: "Winkelbezugssystem",
		outputDataTypeName: "Ausgabedatentyp",
		inputSamplePointFeatureClassName: "Eingabebeispiele",
		valueFieldName: "Wertefeld",
		rasterInfoName: "Raster-Info",
		interpolationMethodName: "Interpolationsmethode",
		radiusName: "Radius",
		radianceGainValuesName: "Strahlungsverstärkung",
		radianceBiasValuesName: "Strahlungs-Bias",
		reflectedGainValuesName: "Reflexionsverstärkung",
		reflectedBiasValuesName: "Reflexions-Bias",
		sunElevationName: "Sonnenstand (Grad)",
		albedoName: "Albedo",
		scaleFactorName: "Skalierungsfaktor",
		offsetName: "Versatzwert",
		thresholdTypeName: "Schwellenwerttyp",
		thresholdsName: "Schwellenwerte",
		undefinedClassName: "Nicht definierte Klasse",
		minValueName: "Min.",
		maxValueName: "Max.",
		operationName: "Operation",
		clippingTypeName: "Ausschneidetyp",
		clippingGeometryName: "Geometrie/Raster zum Ausschneiden",
		extentName: "Ausgabeausdehnung",
		useInputFeatureGeometryName: "Eingabe-Features als Geometrie zum Ausschneiden verwenden",
		remapDefinitionTypeName: "Neuzuordnungs-Definitionstyp",
		inputRangeName: "Eingabebereiche",
		outputValuesName: "Ausgabewerte",
		noDataRangeName: "NoData-Bereiche",
		inputFieldName: "Eingabefeld",
		outputFieldName: "Ausgabefeld",
		inputMaxFieldName: "Eingabefeld für Maximum (optional)",
		remapTableTypeName: "Neuzuordnungs-Tabellentyp",
		allowUnmatchedName: "Pixelwerte ohne Übereinstimmung zulassen",
		changeMissingValuesToNoDataName: "Fehlende Werte zu NoData ändern",
		visibleBandIDName: "ID für sichtbares Band",
		infraredBandIDName: "ID für Infrarotband",
		scientificOutputName: "Wissenschaftliche Ausgabe",
		bandIndexesName: "Bandindizes",
		constantName: "Konstante",
		weightName: "Gewichtung",
		minimumName: "Minimum",
		maximumName: "Maximum",
		sourceDataName: "Quell-Raster",
		sourceFieldName: "Quellfeld",
		costRasterName: "Kosten-Raster",
		maxDistanceName: "Maximale Entfernung",
		valueRasterName: "Werte-Raster",
		costMultiplierName: "Multiplikator zum Anwenden auf Kosten",
		startCostName: "Startkosten",
		accumCostResistanceRateName: "Akkumulative Kostenresistenzrate",
		capacityName: "Kapazität",
		travelDirectionName: "Reiserichtung",
		cellSizeName: "Zellengröße",
		populationFieldName: "Feld mit Grundgesamtheit",
		areaUnitsName: "Flächeneinheiten",
		outputValueTypeName: "Ausgabezellenwerte",
		barriersName: "Eingabe-Barrieren",
		destinationDataName: "Ziel-Raster",
		destinationFieldName: "Zielfeld",
		pathTypeName: "Pfadtyp",
		observerFeaturesName: "Beobachter-Features",
		analysisMethodName: "Analysemethode",
		analysisTypeName: "Analysetyp",
		verticalErrorName: "Vertikaler Fehler",
		refractivityCoefficientName: "Brechungskoeffizient",
		surfaceOffsetName: "Oberflächenversatz",
		observerElevationName: "Beobachterhöhe",
		observerOffsetName: "Beobachterversatz",
		innerRadiusName: "Innerer Radius",
		innerRadiusIs3DDistanceName: "Innerer Radius ist 3D-Entfernung",
		outerRadiusName: "Äußerer Radius",
		outerRadiusIs3DDistanceName: "Äußerer Radius ist 3D-Entfernung",
		horizontalStartAngleName: "Horizontaler Anfangswinkel",
		horizontalEndAngleName: "Horizontaler Endwinkel",
		verticalUpperAngleName: "Vertikaler oberer Winkel",
		verticalLowerAngleName: "Vertikaler unterer Winkel",
		zoneDataName: "Zonen-Raster",
		zoneFieldName: "Zonenfeld",
		ignoreNoDataName: "NoData-Werte in Berechnungen ignorieren",
		temperatureRasterName: "Temperatur-Raster",
		inTemperatureUnitsName: "Temperatureinheiten",
		outHeatIndexTemperatureUnitsName: "Hitzeindexeinheiten",
		relativeHumidityRasterName: "Raster für relative Feuchtigkeit",
		outWindChillTemperatureUnitsName: "Windchill-Einheiten",
		windSpeedRasterName: "Windgeschwindigkeits-Raster",
		inWindSpeedUnitsName: "Windgeschwindigkeitseinheiten",
		valueName: "Wert",
		propertyName: "Name der Eigenschaft",
		jsonName: "Metadaten-JSON",
		zoneTableName: "Tabelle mit zonalen Attributen",
		attributeFieldNames: "Name des Attributfeldes",
		backgroundName: "Hintergrundwert",
		whereClauseName: "Where-Bedingung",
		minimumValueFieldName: "Minimalwert-Feldname",
		maximumValueFieldName: "Maximalwert-Feldname",
		outValueFieldName: "Ausgabewert-Feldname",
		defaultValueName: "Standard-Ausgabewert",
		conversionMatrixName: "Konvertierungsmatrix",
		IsPseudoColorOutputName: "Ist eine Pseudofarbausgabe",
		unmappedAsRandomColorName: "Nicht zugeordneten Pixeln nach dem Zufallsprinzip eine Farbe zuweisen",
		distanceMethodName: "Entfernungsmethode",
		flowDirRasterName: "Fließrichtungs-Raster",
		pourPointName: "Abflusspunkt-Raster",
		pourPointFieldName: "Abflusspunkt-Feld",
		constantZName: "Z-Konstante",
		zOffsetName: "Z-Versatz",
		geoIdName: "Geoid",
		calibrationTypeName: "Kalibrierungstyp",
		filterTypeName: "Filter-Typ",
		filterSizeName: "Filtergröße",
		noiseModelName: "Rauschmodell",
		noiseVarianceName: "Rauschvarianz",
		additiveNoiseMeanName: "Additives Rauschen – Mittelwert",
		multiplicativeNoiseMeanName: "Multiplikatives Rauschen – Mittelwert",
		numberofLooksName: "Anzahl von Looks",
		dampingFactorName: "Dämpfungsfaktor",
		maskRasterName: "Maskierungs-Raster",
		nibbleValuesName: "NoData-Werte verwenden, falls sie der nächste Nachbar sind",
		nibbleNoDataName: "Nibble für NoData-Zellen",
		zLimitName: "Z-Limit",
		flowDirectionTypeName: "Fließrichtungstyp",
		weightRasterName: "Gewichtungs-Raster",
		forceEdgeName: "Abfluss von Randzellen nach außen erzwingen",
		streamRasterName: "Wasserlauf-Raster",
		surfaceRasterName: "Oberflächen-Raster",
		conversionType: "Umwandlungstyp",
		distanceRaster1: "Entfernungs-Raster 1",
		distanceRaster2: "Entfernungs-Raster 2",
		costDistanceRaster: "Kostenentfernungs-Raster",
		costBacklinkRaster: "Kosten-Rückverknüpfungs-Raster",
		overridesName: "Overrides",
		fieldName: "Feld",
		signatureFileOrUrl: "Signaturdatei oder URL",
		redName: "Rot",
		greenName: "Grün",
		blueName: "Blau",
		infraredName: "Infrarot",
		panchromaticName: "Panchromatisch",
		multispectralName: "Multispektral",
		pansharpeningType: "Pan-Sharpening-Typ",
		sensorName: "Sensor",
		spatialReferenceName: "Raumbezug",
		xCellsizeName: "X-Zellengröße",
		yCellsizeName: "Y-Zellengröße",
		xOriginName: "X-Registrierungspunkt",
		yOriginName: "Y-Registrierungspunkt",
		percentileName: "Perzentilwert",
		neighborhoodType: "Nachbarschaftstyp",
		widthName: "Breite",
		heightName: "Höhe",
		startAngleName: "Anfangswinkel",
		endAngleName: "Endwinkel",
		neighborhoodValues: "Nachbarschaftswerte",
		horizontalRaster: "Horizontal-Raster",
		horizontalFactor: "Horizontaler Faktor",
		verticalRaster: "Vertikal-Raster",
		verticalFactor: "Vertikaler Faktor",
		streamRaster: "Wasserlauf-Raster",
		flowDirRaster: "Fließrichtungs-Raster",
		numberNeighborCells: "Anzahl der Nachbarzellen",
		zoneConnectivity: "Zonenkonnektivität",
		addLinkBehavior: "Link hinzufügen",
		excludedValue: "Ausgeschlossener Wert",
		constantFillCheck: "Füll-Raster aus Konstante erstellen",
		fillRaster: "Füll-Raster",
		constantFillValue: "Konstanter Wert",
		inputBitPositions: "Eingabebit",
		outputBitPositions: "Ausgabebit",
		distanceTypeName: "Entfernungstyp",
		barrierDataName: "Raster-Barrieren",
		pourPointDataName: "Abflusspunkt-Raster",
		accumulationRasterName: "Abflussakkumulations-Raster",
		snapDistanceName: "Fangentfernung",
		orderMethodName: "Anordnungsmethode",
		directionMeasurementName: "Messrichtung",
		processAsMultiband: "Als Multiband verarbeiten",
		processMultidimensional: "Als multidimensional verarbeiten",
		forceFlowDirectionConvention: "Fließrichtungs-Konvention für Rückverknüpfungs-Raster erzwingen",
		initialAccumulation: "Initiale Akkumulation",
		maximumAccumulation: "Maximale Akkumulation",
		sourceLocationBands: "Quellenzeile und -spalte als zusätzliche Bänder in Ausgabe generieren",
		backDirectionBand: "Gegenrichtung als zusätzliches Band in der Ausgabe generieren",
		numberOfCells: "Anzahl der Zellen",
		zoneValues: "Zonenwerte",
		shrinkMethod: "Verkleinerungsmethode",
		expandMethod: "Erweiterungsmethode",
		inputSpectralProfileType: "Spektralprofiltyp",
		spectralProfileFileName: "Spektralprofil",
		trainingFeatureFileName: "Trainings-Feature",
		nonNegative: "Nicht negativ",
		sumToOne: "Summenwert 1",
		randomDistribution: "Verteilung",
		meanName: "Mittelwert",
		probabilityName: "Wahrscheinlichkeit",
		alphaName: "Alpha",
		betaName: "Beta",
		rName: "r",
		nName: "N",
		seed: "Ursprung",
		randomNumberGenerator: "Zufallszahlengenerator",
		cellFactor: "Zellenfaktor",
		aggregationType: "Aggregierungs-Methode",
		extentHandling: "Ausdehnung erweitern, falls nötig",
		trendAnalysisDimensionName: "Dimensionsname",
		trendAnalysisType: "Trendtyp",
		harmonicFrequency: "Harmonische Frequenz",
		polynomialOrder: "Polynom-Ordnung",
		cycleLengthName: "Zykluslänge",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R-Squared",
		trendAnalysisSlopePValue: "P-Wert des Neigungskoeffizienten",
		trendAnalysisSeasonalPeriod: "Saisonaler Zeitraum",
		cycleUnitName: "Zykluseinheit",
		predictDimensionValues: "Werte",
		dimensionDefinitionType: "Dimensionsdefinition",
		predictDimensionStart: "Anfang",
		predictDimensionEnd: "Ende",
		predictDimensionInterval: "Wertintervall",
		dimensionUnit: "Einheit",
		interpolationCellsizeName: "Zellengröße für die Interpolation",
		variableName: "Variablen",
		dimensionlessName: "Ohne Dimensionen",
		mdimDefinition: "Dimensionsdefinition",
		dimensionName: "Dimension",
		iterationStart: "Beginn der ersten Iteration",
		iterationEnd: "Ende der ersten Iteration",
		intervalStart: "Beginn des Intervalls",
		intervalEnd: "Ende des Intervalls",
		stepName: "Schritt",
		rangesName: "Bereiche",
		minValue: "Minimum",
		maxValue: "Maximum",
		changeAnalysisRasterName: "Veränderungsanalyse-Raster",
		changeTypeName: "Typ ändern",
		segmentDate: "Segmentdatum",
		changeDirectionName: "Richtung der Änderung",
		maxNumChangesName: "Maximale Anzahl an Änderungen",
		filterByYear: "Nach Jahr filtern",
		minimumYear: "Minimalwert",
		maximumYear: "Maximalwert",
		filterByDuration: "Nach Dauer filtern",
		minimumDuration: "Minimaldauer",
		maximumDuration: "Maximaldauer",
		filterByMagnitude: "Nach Magnitude filtern",
		minimumMagnitude: "Minimalmagnitude",
		maximumMagnitude: "Maximalmagnitude",
		filterByStartValue: "Nach Startwert filtern",
		minimumStartValue: "Minimaler Startwert",
		maximumStartValue: "Maximaler Startwert",
		filterByEndValue: "Nach Endwert filtern",
		minimumEndValue: "Minimaler Endwert",
		maximumEndValue: "Maximaler Endwert",
		modelTypeName: "Modelltyp",
		fromRasterName: "Von Raster",
		toRasterName: "Zu Raster",
		computeChangeMethod: "Methode \"Veränderungen berechnen\"",
		fromClassValues: "Von-Klassenwerte (Beispiel: 2 5)",
		toClassValues: "Zu-Klassenwerte (Beispiel: 2 5)",
		keepMethod: "Filtermethode",
		useColorMethod: "Farbübergänge definieren",
		detectChangeBands: "Bänder für die Erkennung von Änderungen (beginnend bei 0)",
		tmaskBands: "Bänder für zeitbezogene Maskierung (beginnend bei 0)",
		chiSquaredThreshold: "Chi-Quadrat-Schwellenwert für die Erkennung von Änderungen",
		minAnomaly: "Minimum der aufeinanderfolgenden beobachteten Abweichungen",
		updatingFrequency: "Anpassungshäufigkeit (in Jahren) wird aktualisiert",
		distanceAccumulationRasterName: "Entfernungsakkumulations-Raster",
		costBackdirectionRasterName: "Gegenrichtungs- oder Fließrichtungs-Raster",
		rasterCollectionName: "Raster-Sammlung",
		itemFunctionName: "Elementfunktion",
		aggregationFunctionName: "Aggregationsfunktion",
		processingFunctionName: "Verarbeitungsfunktion",
		aggregationDefinitionName: "Aggregationsdefinition",
		queryGeometryName: "Geometrie abfragen",
		factorFunctionZeroFactor: "Null-Faktor",
		factorFunctionCutAngle: "Schnittwinkel",
		factorFunctionSideFactor: "Seitenfaktor",
		factorFunctionSlope: "Neigung",
		factorFunctionLowCutAngle: "Niedriger Schnittwinkel",
		factorFunctionHighCutAngle: "Hoher Schnittwinkel",
		factorFunctionCosPower: "Kosinuspotenz",
		factorFunctionSecPower: "Sekanspotenz",
		factorFunctionTablePath: "Tabellenpfad",
		processingBand: "Verarbeitungsband",
		processingBandName: "Name des Verarbeitungsbandes",
		snappingDate: "Fangdatum",
		maxNumSegments: "Maximale Anzahl an Segmenten",
		vertexCountOvershoot: "Überstand bei Anzahl an Stützpunkten",
		spikeThreshold: "Spike-Schwellenwert",
		recoveryThreshold: "Regenerationsschwellenwert",
		minNumObs: "Mindestanzahl der Beobachtungen",
		pValueThreshold: "Schwellenwert für p-Werte",
		bestModelProportion: "Proportion des besten Modells",
		preventOneYearRecovery: "Einjährige Regeneration verhindern",
		recoveryIncreaseTrend: "Regeneration mit zunehmendem Trend",
		outputOtherBands: "Andere Bänder ausgeben",
		sortType: "Sortiertyp",
		numberOfRuns: "Ausdehnen und Verkleinern zweimal durchlaufen",
		percentileValue: "Perzentilwert",
		percentileInterpolationType: "Perzentil-Interpolationstyp",
		rasterInfoProperty: "Eigenschaft",
		rasterInfoValue: "Wert",
		rasterInfoColumns: "Spalten",
		rasterInfoRows: "Zeilen",
		rasterInfoBandCount: "Anzahl an Bändern",
		rasterInfoPixelSizeX: "Zellengröße X",
		rasterInfoPixelSizeY: "Zellengröße Y",
		rasterInfoPixelType: "Pixeltyp",
		rasterExtentTop: "Oben",
		rasterExtentBottom: "Unten",
		rasterExtentLeft: "Links",
		rasterExtentRight: "Rechts",
		rasterStatisticsNotCalculated: "Statistiken wurden nicht berechnet.",
		spatialReferenceProjection: "Projektion",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "Vorherige WKID",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "Vorherige VCSWKID",
		spatialReferenceAuthority: "Zuständige Stelle",
		spatialReferenceLinearUnit: "Lineare Einheit",
		spatialReferenceAngularUnit: "Winkeleinheit",
		spatialReferenceFalseEasting: "Östlicher Versatz",
		spatialReferenceFalseNorthing: "Nördlicher Versatz",
		spatialReferenceCentralMeridian: "Mittelmeridian",
		spatialReferencePrimeMeridian: "Nullmeridian",
		spatialReferenceStandardParallel1: "Standardparallele 1",
		spatialReferenceStandardParallel2: "Standardparallele 2",
		spatialReferenceLatitudeOfOrigin: "Breitengrad des Ursprungs",
		spatialReferenceAuxiliarySphereType: "Art der Auxiliary Sphere",
		spatialReferenceDatum: "Datum",
		spatialReferenceSpheroid: "Sphäroid",
		spatialReferenceSemimajorAxis: "Große Halbachse",
		spatialReferenceSemiminorAxis: "Kleine Halbachse",
		spatialReferenceInverseFlattening: "Inverse Abflachung",
		inputDefinitionFileName: "Eingabe-Definitionsdatei",
		deleteName: "Löschen",
		addVariableName: "Variable hinzufügen",
		maxNumPixelsPerSegment: "Maximale Segmentgröße in Pixel",
		forwardWindowName: "Vorwärtsgleitendes Fenster",
		backwardWindowName: "Rückwärtsgleitendes Fenster",
		noDataHandlingName: "Umgang mit NoData-Werten",
		circularWrapValueName: "Umbruchwert für Verteilung auf Einheitskreis",
		fromClassNameFieldName: "Feldname für Klassennamen in \"Von Raster\"",
		toClassNameFieldName: "Feldname für Klassennamen in \"In Raster\"",
		targetRasterName: "Ziel-Raster",
		circularWrapValue: "Umbruchwert für Verteilung auf Einheitskreis",
		bandIndexesR: "Roter Ausdruck",
		bandIndexesG: "Grüner Ausdruck",
		bandIndexesB: "Blauer Ausdruck",
		exampleName: "Beispiel",
		inputName: "Eingabe",
		outputName: "Ausgabe",
		optionalName: "Optional",
		browseDefinitionFile: "Definitionsdatei durchsuchen",
		selectDefinitionFile: "Eingabe-Definitionsdatei auswählen",
		inputDefinitionURL: "URL der Eingabe-Definitionsdatei",
		enterDefinitionFileURL: "URL der Definitionsdatei eingeben",
		browseXMLFile: "XML-Datei durchsuchen",
		selectStatsFile: "Statistik- und Histogrammdatei auswählen",
		enterXMLFileURL: "URL der XML-Datei eingeben",
		xmlFileURL: "URL der XML-Datei",
		circularCalculation: "Zirkuläre Statistiken berechnen",
		localSurfaceType: "Typ der lokalen Oberfläche",
		surfaceParameterType: "Parametertyp",
		neighborhoodDistance: "Nachbarschaftsentfernung",
		useAdaptiveNeighborhood: "Adaptive Nachbarschaft verwenden",
		outputSlopeType: "Messwert der Ausgabeneigung",
		projectAzimuths: "Geodätische Azimute projizieren",
		useEquatorialAspect: "Äquatorausrichtung verwenden",
		zUnit: "Z-Einheit",
		analysisMask: "Analysemaske",
		stdDeviation: "Standardabweichung",
		"true": "True",
		"false": "False",
		costDistanceRaster1: "Eingabe-Raster 1 für akkumulative Kostenentfernung",
		costDistanceRaster2: "Eingabe-Raster 2 für akkumulative Kostenentfernung",
		threshold: "Schwellenwert",
		thresholdMethod: "Schwellenwertmethode",
		directionRaster1: "Eingabe-Gegenrichtungs-Raster 1",
		directionRaster2: "Eingabe-Gegenrichtungs-Raster 2",
		maxIterations: "Maximale Anzahl der Iterationen",
		epsilon: "Epsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manuell",
		attributeTableTypeExternal: "Extern",
		clrSchemeTypeColormap: "Colormap",
		clrSchemeTypeColorRamp: "Farbverlauf",
		colormapTypeElevation: "Höhenangaben",
		colormapTypeGray: "Grau",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Zufällig",
		none: "Kein(e)",
		slopeTypeAdjusted: "Angepasst",
		slopeTypeDegree: "Grad",
		slopeTypePercentRise: "Prozentualer Anstieg",
		slopeTypeScaled: "Skaliert",
		stretchTypeMinMax: "MinMax",
		stretchTypePercentMinMax: "PercentMinMax",
		stretchTypeSigmoid: "Sigmoid",
		stretchTypeStdDev: "StdAbw",
		hillshadeTypeSimple: "Traditionell",
		hillshadeTypeMultidirectional: "Multidirektional",
		bandComboByNames: "Bandnamen",
		bandComboByWavelength: "Bandwellenlängen",
		bandComboByIDs: "Band-IDs",
		missingBandActionBestMatch: "Höchste Übereinstimmung",
		missingBandActionFail: "Fehler",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Zentimeter",
		unitTypeDecimeters: "Dezimeter",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Fuß",
		unitTypeFeetPerSec: "Fuß pro Sekunde (ft/s)",
		unitTypeInches: "Zoll",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Kilometer",
		unitTypeKmsPerHour: "Kilometer pro Stunde (km/h)",
		unitTypeKnots: "Knoten (kn)",
		unitTypeMeters: "Meter",
		unitTypeMetersPerSec: "Meter pro Sekunde (m/s)",
		unitTypeMiles: "Meilen",
		unitTypeMilesPerHour: "Meilen pro Stunde (mph)",
		unitTypeMillimeters: "Millimeter",
		unitTypeNauticalMiles: "Seemeile",
		unitTypeYards: "Yards",
		unitTypeDecimalDegrees: "Dezimalgrad",
		unitTypePoints: "Punkte",
		unitTypeUnknown: "Unbekannt",
		unitTypeSqMapUnits: "Quadrat-Karteneinheiten",
		unitTypeSqMiles: "Quadratmeilen",
		unitTypeSqKms: "Quadratkilometer",
		unitTypeAcres: "Acres",
		unitTypeHectares: "Hektar",
		unitTypeSqYards: "Quadratyards",
		unitTypeSqFt: "Quadratfuß",
		unitTypeSqInches: "Quadratzoll",
		unitTypeSqMts: "Quadratmeter",
		unitTypeSqCms: "Quadratzentimeter",
		unitTypeSqMms: "Quadratmillimeter",
		cellsizeTypeFirst: "Erste(r) von",
		cellsizeTypeMin: "Min. von",
		cellsizeTypeMax: "Max. von",
		cellsizeTypeMean: "Mittelwert von",
		cellsizeTypeLast: "Letzte(r) von",
		extentTypeFirst: "Erste(r) von",
		extentTypeIntersection: "Schnittpunkt von",
		extentTypeUnion: "Vereinigung von",
		extentTypeLast: "Letzte(r) von",
		noDataInterpretAny: "Mit irgendeinem übereinstimmend",
		noDataInterpretAll: "Mit allen übereinstimmend",
		curvatureTypeStandard: "Standard",
		curvatureTypeProfile: "Profil",
		curvatureTypePlanform: "Horizontal",
		filterTypeLineDetectionHorizontal: "Linienerkennung horizontal",
		filterTypeLineDetectionVertical: "Linienerkennung vertikal",
		filterTypeLineDetectionLeftDiagonal: "Linienerkennung links diagonal",
		filterTypeLineDetectionRightDiagonal: "Linienerkennung rechts diagonal",
		filterTypeGradientNorth: "Gradient Nord",
		filterTypeGradientWest: "Gradient West",
		filterTypeGradientEast: "Gradient Ost",
		filterTypeGradientSouth: "Gradient Süd",
		filterTypeGradientNorthEast: "Gradient Nordost",
		filterTypeGradientNorthWest: "Gradient Nordwest",
		filterTypeSmoothArithmeticMean: "Geglättetes arithmetisches Mittel",
		filterTypeSmoothing3x3: "Glätten 3x3",
		filterTypeSmoothing5x5: "Glätten 5x5",
		filterTypeSharpening3x3: "Schärfen 3x3",
		filterTypeSharpening5x5: "Schärfen 5x5",
		filterTypeLaplacian3x3: "Laplace 3x3",
		filterTypeLaplacian5x5: "Laplace 5x5",
		filterTypeSobelHorizontal: "Sobel horizontal",
		filterTypeSobelVertical: "Sobel vertikal",
		filterTypeSharpen: "Schärfen",
		filterTypeSharpen2: "Weiter schärfen",
		filterTypePointSpread: "Punktverteilung",
		userDefined: "Benutzerdefiniert",
		ContourTypeLines: "Konturlinien",
		ContourTypeFill: "Konturlinienfüllung",
		ContourTypeSmoothOnly: "Nur glatte Oberfläche",
		rasterizeFirst: "Erster",
		rasterizeLast: "Letzter",
		rasterizeSmallest: "Kleinste",
		rasterizeLargest: "Größte",
		resamplingTypeNearest: "Nächster Nachbar",
		resamplingTypeBilinear: "Bilineare Interpolation",
		resamplingTypeCubic: "Kubische Faltung",
		resamplingTypeMajority: "Mehrheit",
		resamplingTypeBilinearPlus: "Bilineare Interpolation Plus",
		resamplingTypeGauss: "Gauss Blur",
		resamplingTypeGaussPlus: "Gauss Blur Plus",
		resamplingTypeAverage: "Durchschnitt",
		resamplingTypeMinimum: "Minimum",
		resamplingTypeMaximum: "Maximum",
		resamplingTypeVectorAvg: "Vektordurchschnitt",
		minimum: "Minimum",
		maximum: "Maximum",
		mean: "Mittelwert",
		stdDeviation: "Standardabweichung",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Magnituden-Richtung",
		unknown: "Unbekannt",
		angleRefSysGeographic: "Geographisch",
		angleRefSysArithmetic: "Arithmetisch",
		interpolateIrregularDataNearest: "Nächster Nachbar",
		interpolateIrregularDataBilinear: "Bilinear",
		interpolateIrregularDataTinningLinear: "Lineare Ausdünnung",
		interpolateIrregularDataTinningNaturalNeighbor: "Natürlicher Nachbar",
		interpolateIrregularDataTinningIDW: "Inverse Distance Weighted",
		esriRasterThresholdTypeConstant: "Konstante",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "Arg-Maximum",
		argStatsTypeMin: "Arg-Minimum",
		argStatsTypeMedian: "Arg-Medianwert",
		argStatsTypeDuration: "Dauer",
		arithmeticOpPlus: "Plus",
		arithmeticOpMinus: "Minus",
		arithmeticOpMultiply: "Multiplizieren",
		arithmeticOpDivide: "Teilen",
		arithmeticOpPower: "Potenz",
		arithmeticOpMode: "Modus",
		clipTypeOutside: "Außerhalb ausschneiden",
		clipTypeInside: "Innerhalb ausschneiden",
		yes: "Ja",
		no: "Nein",
		densities: "Dichte",
		expectedCounts: "Erwartete Anzahl",
		planar: "Planar",
		geodesic: "Geodätisch",
		eachCell: "Jede Zelle",
		eachZone: "Jede Zone",
		bestSingle: "Der Beste",
		allSightlines: "Alle Sichtlinien",
		perimeterSightlines: "Sichtlinien aus Umfang",
		frequency: "Häufigkeit (Frequency)",
		observers: "Beobachter",
		majority: "Mehrheit",
		median: "Medianwert",
		minority: "Minderheit",
		percentile: "Perzentil",
		range: "Bereich",
		sum: "Summe",
		variety: "Varianz",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "Transformierter SAVI",
		bandArithmeticMethodMSAVI: "Geänderter SAVI",
		bandArithmeticMethodSultan: "Sultan-Formel",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Eisenoxid",
		ferrousMinerals: "Eisenmineralien",
		clayMinerals: "Tonmineralien",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Quadratwurzel",
		localACos: "ACos",
		localASin: "ASin",
		localATan: "ATan",
		localATanH: "ATanH",
		localAbs: "Abs",
		localBitwiseNot: "Bitwise Not",
		localBooleanNot: "Boolean Not",
		localCos: "Cos",
		localCosH: "CosH",
		localExp: "Exp",
		localExp10: "Exp10",
		localExp2: "Exp2",
		localInt: "Int",
		localIsNull: "Is Null",
		localFloat: "Float",
		localLn: "Ln",
		localLog10: "Log10",
		localLog2: "Log2",
		localNegate: "Negate",
		localRoundDown: "Round Down",
		localRoundUp: "Round Up",
		localSin: "Sin",
		localSinH: "SinH",
		localTan: "Tan",
		localTanH: "TanH",
		localACosH: "ACosH",
		localASinH: "ASinH",
		localPlus: "Plus",
		localMinus: "Minus",
		localTimes: "Times",
		localPower: "Power",
		localBitwiseAnd: "Bitwise And",
		localBitwiseLeftShift: "Bitwise Left Shift",
		localBitwiseOr: "Bitwise Or",
		localBitwiseRightShift: "Bitwise Right Shift",
		localBitwiseXor: "Bitwise Xor",
		localBooleanAnd: "Boolean And",
		localBooleanOr: "Boolean Or",
		localBooleanXor: "Boolean XOr",
		localDivide: "Divide",
		localEqualTo: "Equal To",
		localGreaterThan: "Greater Than",
		localGreaterThanEqual: "Greater Than Equal",
		localLessThan: "Less Than",
		localLessThanEqual: "Less Than Equal",
		localMod: "Mod",
		localNotEqual: "Not Equal",
		localATan2: "ATan2",
		localSquare: "Square",
		localSetNull: "Auf NULL setzen",
		remapDefTypeList: "Liste",
		remapDefTypeTable: "Tabelle",
		remapTableTypeSimple: "Einfach",
		remapTableTypeDynamic: "Dynamisch",
		remapTableTypeReassignment: "Neuzuweisung",
		geomCorrectionByConstZ: "Z-Konstante verwenden",
		geomCorrectionByDEM: "DEM verwenden",
		radarCalibBetaNought: "Beta-Nought",
		radarCalibSigmaNought: "Sigma-Nought",
		radarCalibGammaNought: "Gamma-Nought",
		speckleFilterTypeLee: "Lee-Filter",
		speckleFilterTypeEnhancedLee: "Erweiterter Lee-Filter",
		speckleFilterTypeFrost: "Frost-Filter",
		speckleFilterTypeKuan: "Kuan-Filter",
		speckleNoiseModelMul: "Multiplikatives Rauschen",
		speckleNoiseModelAdd: "Additives Rauschen",
		speckleNoiseModelAddnMul: "Additives und multiplikatives Rauschen",
		mosaicOpTypeFirst: "Erste(r)",
		mosaicOpTypeLast: "Letzte(r)",
		mosaicOpTypeMin: "Min.",
		mosaicOpTypeMax: "Max.",
		mosaicOpTypeMean: "Mittelwert",
		mosaicOpTypeBlend: "Verschmelzen",
		mosaicOpTypeSum: "Summe",
		integer: "Integer",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "DINF",
		vertical: "Vertikal",
		horizontal: "Horizontal",
		localCellStatisticsMajority: "Mehrheit",
		localCellStatisticsMax: "Maximum",
		localCellStatisticsMean: "Mittelwert",
		localCellStatisticsMedian: "Medianwert",
		localCellStatisticsMin: "Minimum",
		localCellStatisticsMinority: "Minderheit",
		localCellStatisticsRange: "Bereich",
		localCellStatisticsStdDev: "Standardabweichung",
		localCellStatisticsSum: "Summe",
		localCellStatisticsVariety: "Varianz",
		localCellStatisticsMajorityIgnoreND: "Mehrheit (NoData ignorieren)",
		localCellStatisticsMaxIgnoreND: "Maximum (NoData ignorieren)",
		localCellStatisticsMeanIgnoreND: "Mittelwert (NoData ignorieren)",
		localCellStatisticsMedianIgnoreND: "Medianwert (NoData ignorieren)",
		localCellStatisticsMinIgnoreND: "Minimum (NoData ignorieren)",
		localCellStatisticsMinorityIgnoreND: "Minderheit (NoData ignorieren)",
		localCellStatisticsRangeIgnoreND: "Bereich (NoData ignorieren)",
		localCellStatisticsStdDevIgnoreND: "Standardabweichung (NoData ignorieren)",
		localCellStatisticsSumIgnoreND: "Summe (NoData ignorieren)",
		localCellStatisticsVarietyIgnoreND: "Varianz (NoData ignorieren)",
		localCellStatisticsTypePercentileIgnoreND: "Perzentil (NoData ignorieren)",
		fromSource: "Aus Quelle",
		toSource: "Zur Quelle",
		colorspaceConversionRgbToHsv: "RGB in HSV",
		colorspaceConversionHsvToRgb: "HSV in RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Mittelwert",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Rechteck",
		circleNeighborhood: "Kreis",
		annulusNeighborhood: "Kreisring",
		wedgeNeighborhood: "Keil",
		irregularNeighborhood: "Unregelmäßig",
		weightNeighborhood: "Gewichtung",
		four: "Vier",
		eight: "Acht",
		within: "In",
		cross: "Darüberhinaus",
		addLink: "Link hinzufügen",
		noLink: "Kein Link",
		weightedMean: "Gewichteter Mittelwert",
		ls8QCBitPatternCirrus: "Landsat 8 Cirrus",
		ls8QCBitPatternCloud: "Landsat 8 Cloud",
		ls8QCBitPatternCloudShadow: "Landsat 8 Cloud Shadow",
		ls8QCBitPatternDesignatedFill: "Landsat 8 Designated Fill",
		ls8QCBitPatternDroppedFrame: "Landsat 8 Dropped Frame",
		ls8QCBitPatternSnowIce: "Landsat 8 Snow/Ice",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 Terrain Occlusion",
		ls8QCBitPatternVegetation: "Landsat 8 Vegetation",
		ls8QCBitPatternWater: "Landsat 8 Water",
		downStream: "Flussabwärts",
		upStream: "Flussaufwärts",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Aktueller Ausschnitt",
		allSlices: "Alle Ausschnitte",
		expandDistance: "ENTFERNUNG",
		expandMorphological: "MORPHOLOGISCH",
		spectralProfileFile: "Spektralprofil",
		trainingFeatureFile: "Trainings-Feature",
		randomDistributionTypeUniform: "Einheitlich",
		randomDistributionTypeUniformInteger: "Integer",
		randomDistributionTypeNormal: "Normal",
		randomDistributionTypeExponential: "Exponential",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gamma",
		randomDistributionTypeBinomial: "Binomial",
		randomDistributionTypeGeometric: "Geometrisch",
		randomDistributionTypeNegativeBinomial: "Negativ binomial",
		randomGeneratorTypeStandardCRand: "Standard C Rand",
		randomGeneratorTypeAlgorithmACM599: "ACM599 – Sammelalgorithmus",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Summe",
		medainName: "Medianwert",
		trendLinear: "Linear",
		trendHarmonic: "Harmonisch",
		trendPolynomial: "Polynomial",
		trendMannKendall: "Mann-Kendall-Test",
		trendSeasonalKendall: "Saisonaler Kendall-Test",
		dimensionByValue: "Nach Wert",
		dimensionByInterval: "Nach Intervall",
		mdimDefTypeAll: "Alle",
		mdimDefTypeByValues: "Durch Werte",
		mdimDefTypeByRanges: "Nach Bereichen",
		mdimDefTypeByIteration: "Nach Iteration",
		mdimDefTypeByInterval: "Nach Intervall",
		mdimDefTypeByTargetRaster: "Nach Ziel-Raster",
		esriTimeUnitsHours: "Stunden",
		esriTimeUnitsDays: "Tage",
		esriTimeUnitsWeeks: "Wochen",
		esriTimeUnitsMonths: "Monate",
		esriTimeUnitsYears: "Jahre",
		esriTimeIntervalKeywordHourly: "Stündlich",
		esriTimeIntervalKeywordDaily: "Täglich",
		esriTimeIntervalKeywordWeekly: "Wöchentlich",
		esriTimeIntervalKeywordDekadly: "10 Tage",
		esriTimeIntervalKeywordPentadly: "5 Tage",
		esriTimeIntervalKeywordMonthly: "Monatlich",
		esriTimeIntervalKeywordQuarterly: "Vierteljährlich",
		esriTimeIntervalKeywordYearly: "Jährlich",
		esriTimeIntervalKeywordRecurringDaily: "Täglich wiederkehrend",
		esriTimeIntervalKeywordRecurringWeekly: "Wöchentlich wiederkehrend",
		esriTimeIntervalKeywordRecurringMonthly: "Monatlich wiederkehrend",
		esriTimeIntervalKeywordRecurringQuarterly: "Quartalsweise wiederkehrend",
		aggDefTypeAll: "Alle",
		aggDefTypeIntervalKeyword: "Intervallschlüsselwort",
		aggDefTypeIntervalValue: "Intervallwert",
		aggDefTypeIntervalRanges: "Intervallbereiche",
		latestChange: "Zeit der letzten Änderung",
		earliestChange: "Zeit der ersten Änderung",
		largestChange: "Zeit der größten Änderung",
		numberOfChanges: "Anzahl an Änderungen",
		longestChange: "Zeit der längsten Änderung",
		shortestChange: "Zeit der kürzesten Änderung",
		fastestChange: "Zeit der schnellsten Änderung",
		slowestChange: "Zeit der langsamsten Änderung",
		allChanges: "Alle",
		increaseChanges: "Zunahme",
		decreaseChanges: "Abnahme",
		segmentBeginning: "Anfang des Segments",
		segmentEnd: "Ende des Segments",
		esriComputeChangeMethodDifference: "Differenz",
		esriComputeChangeMethodRelativeDifference: "Relativer Unterschied",
		esriComputeChangeMethodCategorical: "Kategorischer Unterschied",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Spektrale euklidische Entfernung",
		esriComputeChangeMethodMultispectralAngularDifference: "Spektrale Winkeldifferenz",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Band mit größter Veränderung",
		esriComputeChangeKeepAll: "Alle beibehalten",
		esriComputeChangeKeepChangedOnly: "Nur geänderte Pixel beibehalten",
		esriComputeChangeKeepUnchangedOnly: "Nur nicht geänderte Pixel beibehalten",
		esriComputeChangeUseColorAverage: "Von-Zu-Farben für Durchschnitt",
		esriComputeChangeUseColorFrom: "Von-Farben verwenden",
		esriComputeChangeUseColorTo: "Zu-Farben verwenden",
		factorFunctionBinary: "Binär",
		factorFunctionForward: "Vorwärts",
		factorFunctionLinear: "Linear",
		factorFunctionInvLinear: "Invers linear",
		factorFunctionTable: "Tabelle",
		factorFunctionSymLinear: "Symmetrisch linear",
		factorFunctionSymInvLinear: "Symmetrisch invers linear",
		factorFunctionCos: "Kosinus",
		factorFunctionSec: "Sekans",
		factorFunctionCosSec: "Kosinus Sekans",
		factorFunctionSecCos: "Sekans Kosinus",
		noSort: "Nicht sortieren",
		ascend: "Aufsteigend",
		descend: "Absteigend",
		autoDetect: "Automatisch erkennen",
		nearest: "Nächster",
		linear: "Linear",
		esriMonthJanuary: "Januar",
		esriMonthFebruary: "Februar",
		esriMonthMarch: "März",
		esriMonthApril: "April",
		esriMonthMay: "Mai",
		esriMonthJune: "Juni",
		esriMonthJuly: "Juli",
		esriMonthAugust: "August",
		esriMonthSeptember: "September",
		esriMonthOctober: "Oktober",
		esriMonthNovember: "November",
		esriMonthDecember: "Dezember",
		dimensionalMovingIgnoreNoData: "Daten",
		dimensionalMovingPropagateNoData: "NoData",
		dimensionalMovingFillOnlyNoData: "NoData-Werte füllen",
		circularMean: "Zirkulärer Mittelwert",
		circularName: "Kreisförmig",
		arithmeticName: "Arithmetisch",
		slopeName: "Neigung",
		aspectName: "Ausrichtung",
		meanCurvature: "Mittlere Krümmung",
		profileCurvature: "Profilkrümmung (Normalneigungslinie)",
		tangentialCurvature: "Tangentialkrümmung (Normalkontur)",
		planCurvature: "Plankrümmung (projizierte Kontur)",
		contourGeodesicTorsion: "Geodätische Torsion der Kontur",
		gaussianCurvature: "Gauß'sche Krümmung",
		casoratiCurvature: "Casorati-Krümmung",
		localSurfaceTypeQuadratic: "Quadratisch",
		localSurfaceTypeBiquadratic: "Biquadratisch",
		thresholdNoThreshold: "Kein Schwellenwert",
		thresholdPercentLeastCost: "Prozentsatz der geringsten Kosten",
		thresholdAccumulativeCost: "Akkumulative Kosten",
		clrmapTypeHillshade: "Schummerung"
	},
	categoryLabels: {
		sourceCharacteristics: "Quelleneigenschaften",
		neighborhoodSettings: "Nachbarschaftseinstellungen",
		statistics: "Statistiken",
		gamma: "Gamma",
		viewshedParameters: "Sichtfeldparameter",
		observerParameters: "Beobachterparameter",
		irregularDataInterpolation: "Unregelmäßige Dateninterpolation",
		modelStatistics: "Modellstatistiken",
		aggregationDef: "Aggregationsdefinition",
		filterByAttributes: "Nach Attributen filtern",
		percentileName: "Perzentil",
		rasterInfo: "Raster-Information",
		extent: "Ausdehnung",
		spatialReference: "Raumbezug"
	},
	outputRasterHelpTexts: {
		outputName: "<p>Der Name des Layers, der erstellt und der Karte hinzugefügt wird.</p>",
		resultType: "<p>Die Art der Ausgabe, die erstellt wird. Die Ausgaben können gekachelte Bilddaten-Layer oder dynamische Bilddaten-Layer sein.</p>",
		saveResultIn: "<p>Der Name des Ordners in <b>Eigene Inhalte</b>, in dem das Ergebnis gespeichert werden soll.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Umgebungseinstellungen für Analysen in Map Viewer. </p>",
		outSR: "<p>Legt das Koordinatensystem für die Analyse und den Ergebnis-Layer fest.</p>",
		extent: "<p>Gibt den Bereich an, der für die Analyse verwendet werden soll.</p>",
		snapRaster: "<p>Passt die Ausdehnung der Ausgabe an, sodass sie der Zellenausrichtung des angegebenen Fang-Raster-Layers entspricht.</p>",
		cellSize: "<p>Legt die Zellengröße oder Auflösung fest, die für die Analyse und zum Erstellen des Ausgabe-Raster-Layers verwendet wird.</p>",
		mask: "<p>Gibt einen Masken-Layer an, in dem nur die Zellen im Maskenbereich für die Analyse verwendet werden.</p>",
		resamplingMethod: "<p>Gibt an, wie Pixelwerte interpoliert werden sollen, wenn die Eingabe- und Ausgabe-Raster nicht übereinstimmen.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Nicht unterstützter Typ",
		currentlyUnsupported: " Ein Standard-Editor für ${missingType} ist in Kürze verfügbar. Temporäres Platzhalter-Textfeld für die Angabe von auf einer Zeichenfolge basierten Eingaben.",
		unsupportedOverrideWarning: "Eine Editor-Komponente zum Überschreiben mit einer besseren Benutzeroberfläche für das Arbeiten mit den folgenden Parametern ist in Kürze verfügbar:",
		overrideWidgetMissing: "Editor-Komponente zum Überschreiben fehlt!",
		uiIncomplete: "Auftragsübermittlung fehlgeschlagen. Die Funktion kann nicht ausgeführt werden, weil einige der Pflichtfelder nicht ausgefüllt sind oder in der Benutzeroberfläche fehlen.",
		count: "Anzahl",
		selectVariables: "Variablen auswählen",
		selectFeature: "Feature-Layer auswählen",
		greaterThanErrorMessage: "Die Eingabe für die Anzahl muss größer als ${min} sein.",
		lesserThanErrorMessage: "Die Eingabe für die Anzahl muss kleiner als ${max} sein.",
		greaterThanOrEqualErrorMessage: "Die Eingabe für die Anzahl muss größer als oder gleich ${min} sein.",
		lesserThanOrEqualErrorMessage: "Die Eingabe für die Anzahl muss kleiner als oder gleich ${max} sein.",
		allowScalar: "Layer auswählen oder Konstante eingeben",
		selectField: "Feld auswählen",
		parameterRequired: "Dieser Parameter ist erforderlich.",
		enterAValue: "Wert eingeben ...",
		invalidInput: "Der eingegebene Wert ist ungültig.",
		itemNotFound: "Das Element ist nicht vorhanden, oder es kann nicht darauf zugegriffen werden.",
		itemPermissionDenied: "Sie haben keine Zugriffsberechtigung für dieses Element.",
		layerNotAvailable: "Fehler beim Laden des Layers \"${layerName}\".",
		multipleLayersNotAvailable: "Fehler beim Laden des Layers \"${layerName}\" und weiterer Layer.",
		learnMoreLabel: "Mehr erfahren",
		fieldNotAvailable: "Feld konnte nicht geladen werden.",
		allowAnalysis: "Die Analyse ist für den Image-Service nicht zulässig.",
		allowAnalysisReason: "Ein oder mehrere Layer aus der Karte sind hier nicht aufgeführt, da sie keine Analyse zulassen.",
		learnMoreText: "Weitere Informationen",
		atLeastOneRasterInput: "Mindestens ein Eingabe-Layer muss ein Raster-Layer sein.",
		browseAnalysisLayers: "Layer durchsuchen",
		activeMapViewExtent: "Aktuelle Kartenausdehnung verwenden",
		chooseRaster: "Raster zum Ausschneiden auswählen",
		chooseGeometry: "Geometrie zum Ausschneiden auswählen",
		resultType: "Ergebnistyp",
		saveInFolder: "In Ordner speichern",
		outputName: "Ausgabename",
		outputLayerType: "Ausgabe-Layer-Typ",
		dynamicImageryLayer: "Dynamischer Bilddaten-Layer",
		tiledImageryLayer: "Gekachelter Bilddaten-Layer",
		custom: "Benutzerdefiniert",
		loading: "Wird geladen...",
		layerMissing: "Ein oder mehrere Layer aus der Karte sind hier nicht aufgeführt, da sie keine Analyse zulassen. Weitere Informationen",
		browseCoordinateSystems: "Koordinatensysteme durchsuchen",
		unableToRepopulateOutSR: "Das Ausgabekoordinatensystem kann nicht gefüllt werden.",
		defaultTitle: "Mehr anzeigen",
		"ARC (equal arc-second)": "ARC (gleich Bogensekunde)",
		Africa: "Afrika",
		Antarctica: "Antarktis",
		Argentina: "Argentinien",
		Asia: "Asien",
		"Asteroid Belt": "Asteroidengürtel",
		"Atlantic Ocean": "Atlantischer Ozean",
		Australia: "Australien",
		"Australia and New Zealand": "Australien und Neuseeland",
		Austria: "Österreich",
		"BLM (US Feet)": "BLM (US Feet)",
		Bangladesh: "Bangladesch",
		"Beijing 1954": "Beijing 1954",
		Bhutan: "Bhutan",
		CGCS2000: "CGCS2000",
		Canada: "Kanada",
		Caribbean: "Karibik",
		"Caribbean Sea": "Karibisches Meer",
		"Central America": "Mittelamerika",
		"Central and North America": "Mittel- und Nordamerika",
		Colombia: "Kolumbien",
		Continental: "Kontinente",
		"County Systems": "County Systems",
		"Democratic Republic of the Congo": "Demokratische Republik Kongo",
		"EPSG Arctic": "EPSG Arctic",
		Earth: "Erde",
		"Ellipsoidal-based": "Ellipsoid",
		Europe: "Europa",
		Finland: "Finnland",
		France: "Frankreich",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauß-Krüger",
		"Geographic Coordinate Systems": "Geographische Koordinatensysteme",
		Germany: "Deutschland",
		"Gravity-related": "Schwerkraftabhängig",
		"Greenwich-based": "Greenwich-basiert",
		"Highways England": "Highways England",
		Illinois: "Illinois",
		"Indian Ocean": "Indischer Ozean",
		"Indian Subcontinent": "Indischer Subkontinent",
		Indiana: "Indiana",
		Indonesia: "Indonesien",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irland und Vereinigtes Königreich",
		Italy: "Italien",
		Japan: "Japan",
		Jupiter: "Jupiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Libyen",
		Malaysia: "Malaysia",
		"Malaysia and Singapore": "Malaysia und Singapur",
		Mars: "Mars",
		Mercury: "Merkur",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (US Feet)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (Intl Feet)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (Meters)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (US Feet)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (Intl Feet)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (Meters)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (US Feet)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (Intl Feet)",
		"NAD 1983 (Meters)": "NAD 1983 (Meters)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (Meters)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (US Feet)",
		"NAD 1983 (US Feet)": "NAD 1983 (US Feet)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (Intl Feet)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (Meters)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (US Feet)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (Intl Feet)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (Meters)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (US Feet)",
		"National Grids": "Nationale Gitter",
		Navajo: "Navajo",
		Neptune: "Neptun",
		"New Beijing": "New Beijing",
		"New Zealand": "Neuseeland",
		"North America": "Nordamerika",
		"Northern Hemisphere": "Nördliche Hemisphäre",
		Norway: "Norwegen",
		Oceans: "Meere",
		Oregon: "Oregon",
		"Other GCS": "Anderes GCS",
		"Pacific Ocean": "Pazifischer Ozean",
		Pluto: "Pluto",
		Polar: "Polargebiete",
		Portugal: "Portugal",
		"Projected Coordinate Systems": "Projizierte Koordinatensysteme",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Ersetzt",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturn",
		"Solar System": "Sonnensystem",
		"South Africa": "Südafrika",
		"South America": "Südamerika",
		"South Korea": "Südkorea",
		"Southern Hemisphere": "Südliche Hemisphäre",
		"Spheroid-based": "Sphäroid-basiert",
		"State Plane": "State Plane",
		"State Systems": "State Systems",
		Sweden: "Schweden",
		"Switzerland and Liechtenstein": "Schweiz und Liechtenstein",
		Texas: "Texas",
		Tribal: "Tribal",
		Turkey: "Türkei",
		"US Feet": "US Feet",
		"USA and territories": "USA und zugehörige Territorien",
		UTM: "UTM",
		Ukraine: "Ukraine",
		"Unknown Height Systems": "Unbekannte Höhensysteme",
		Uranus: "Uranus",
		Venus: "Venus",
		"Vertical Coordinate Systems": "Vertikale Koordinatensysteme",
		Vietnam: "Vietnam",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Welt",
		"World (Sphere-based)": "Welt (Sphäroid)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Fertig",
		noResults: "Keine Ergebnisse gefunden",
		searchPlaceholder: "Name oder WKID",
		browseTemplate: "Raster-Funktionsvorlagen durchsuchen",
		saveTemplate: "Raster-Funktionsvorlage speichern",
		preview: "Vorschau",
		previewDescription: "Vor dem Ausführen der Analyse eine Vorschau des Ergebnisses anzeigen.",
		showPreview: "Vorschau anzeigen",
		previewLayer: "Vorschau von Layer ${number} anzeigen",
		newPreview: "Neue Vorschau",
		previewPopup: "Die Vorschau der Analyseergebnisse basierend auf den Eingabeparametern aktivieren.",
		updatePreviewLayer: "Ausgewählten Vorschau-Layer aktualisieren",
		createPreviewLayer: "Neuen Vorschau-Layer erstellen",
		maximumPreviewAllowed: "Maximal zulässige Anzahl von Vorschau-Layern: ${maxCount}",
		previewFailure: "Dieser Vorschau-Layer ist nicht verfügbar. Überprüfen Sie die Eingabeparameter, und aktualisieren Sie diesen Vorschau-Layer erneut.",
		header: "Element auswählen",
		content: "Nicht gespeicherte Änderungen in ${rftTitle}. Wenn Sie mit einer neuen Vorlage beginnen, gehen diese Änderungen verloren.",
		dontSave: "Nicht speichern",
		"continue": "Weiter",
		stretch: "An Fenster anpassen",
		pan: "Schwenken",
		newTemplate: "Neue Vorlage erstellen",
		openTemplate: "Vorlage öffnen",
		addFunction: "Raster-Funktionen hinzufügen",
		addConstant: "Konstante hinzufügen",
		addRaster: "Raster-Variable hinzufügen",
		move: "Verschieben",
		zoom: "Zoomen",
		saveAs: "Speichern unter",
		clear: "Löschen",
		addRasterFunctionTitle: "Raster-Funktionen hinzufügen",
		templatePropertiesTitle: "Vorlageneigenschaften",
		browseRFT: "Raster-Funktionsvorlagen durchsuchen",
		defaultToolDescription: "${toolTitle}-Analysewerkzeug",
		openToolText: "Werkzeug öffnen",
		toolDropdownText: "Werkzeug-Dropdown-Liste",
		addToMap: "Bestätigen und zur Karte hinzufügen",
		confirm: "Bestätigen",
		select: "Auswählen",
		selectTask: "Task auswählen",
		unsupportedLayer: "Dieser Parameter unterstützt die folgenden Layer nicht: ${layerName}",
		viewDetails: "Vollständige Elementdetails anzeigen",
		rename: "Umbenennen",
		duplicate: "Duplizieren",
		launch: "Zum Ausführen öffnen",
		templateEditor: "Vorlageneditor",
		createItem: "Raster-Funktionsvorlage speichern",
		actionLabel: "Filtern",
		filterPopoverHeading: "Funktionen filtern",
		defaultSearchPlaceholder: "Nach Namen suchen",
		settings: "Einstellungen",
		summary: "Zusammenfassung",
		definitionQuery: "Definitionsabfrage",
		matchVariables: "Variablen abgleichen",
		unionDimension: "Dimension vereinigen",
		nameEditorPlaceholder: "Titel eingeben",
		summaryEditorPlaceholder: "Geben Sie eine Kurzbeschreibung ein.",
		definitionQueryPlaceholder: "Eingabe...",
		upload: "Hochladen",
		chooseImage: "Klicken Sie, um eine Datei auszuwählen.",
		update: "Aktualisieren",
		thumbnailErrors: {
			wrongImageType: "Falscher Bildtyp ausgewählt",
			notAvailable: "Miniaturansicht nicht verfügbar",
			loadError: "Bild konnte nicht geladen werden",
			chooseFile: "Klicken Sie, um die Datei auszuwählen."
		}
	}
};
const copy = "Kopieren";
const save = "Speichern";
const title = "Titel";
const folder = "Ordner";
const tags = "Tags";
const savingMessage = "Element wird gespeichert in";
const shareWith = "Freigeben für";
const share = "Freigeben";
const setSharingLevel = "Freigabeebene festlegen";
const setGroupSharing = "Gruppenfreigabe festlegen";
const owner = "Besitzer";
const organization = "Organisation";
const everyone = "Alle (öffentlich)";
const groups = "Gruppen:";
const type = "Typ";
const mosaic = "Mosaik";
const itemGroup = "Elementgruppe";
const item = "Element";
const definitionQuery = "Definitionsabfrage";
const groupItemsBy = "Elemente gruppieren nach";
const groupFieldName = "Gruppierungsfeldname";
const tagFieldName = "Tag-Feldname";
const noTitleTagErrorMsg = "Sie müssen einen Titel für das Element sowie Tags angeben, damit die Karte in Suchvorgängen gefunden werden kann.";
const noTitleErrorMsg = "Sie müssen einen Titel für das Element angeben.";
const noTagErrorMsg = "Sie müssen mindestens ein Tag angeben, damit das Element in Suchvorgängen gefunden werden kann.";
const error = "Fehler";
const warning = "Warnung";
const success = "Erfolgreich abgeschlossen";
const details = "Details:";
const tryAgain = "Erneut versuchen";
const toolModeler = {
	save: "Speichern",
	editProperties: "Eigenschaften bearbeiten",
	saveAs: "Speichern als",
	savingNotification: "Änderungen am Element werden gespeichert...",
	savingTitle: "Wird gespeichert",
	saveFailedMessage: "Änderungen konnten nicht gespeichert werden.",
	saveWithErrorsMessage: "Die Änderungen wurden mit den folgenden Fehlern gespeichert.",
	viewItemMessage: "Das gespeicherte Element",
	here: "hier anzeigen.",
	itemCreatedMessage: "Es wurde ein neues Element erstellt.",
	clickToViewItemMessage: "Klicken Sie auf \"OK\", um die Elementdetailseite anzuzeigen. Klicken Sie auf \"Abbrechen\", um fortzufahren.",
	readingFailed: "Die ausgewählte Raster-Funktionsvorlage konnte nicht geladen werden.",
	failedToLoadXML: "Die ausgewählte Raster-Funktionsvorlage konnte im XML-Format nicht geladen werden.",
	learnMore: "Weitere Informationen",
	overwriteTitle: "Überschreiben bestätigen",
	overwriteMessage: "Möchten Sie das vorhandene Element überschreiben?",
	overwriteSuccessMessage: "Das Element wurde aktualisiert."
};
const toolEditor = {
	run: "Ausführen",
	save: "Speichern",
	deleteSelected: "Ausgewählte Elemente löschen",
	addRaster: "Raster hinzufügen",
	addScalar: "Skalar hinzufügen",
	layout: "Autolayout",
	errorTitle: "Fehler",
	invalidToolMessage: "Die Raster-Funktionsvorlage ist ungültig.",
	out: "Aus",
	zoomIn: "Vergrößern",
	zoomOut: "Verkleinern",
	zoomToFit: "An Fenster anpassen",
	panOn: "Zum Modus \"Schwenken\" wechseln",
	panOff: "Modus \"Schwenken\" deaktivieren",
	defaultModelName: "Werkzeugmodell",
	defaultRasterName: "Raster"
};
const toolDetailsEditor = {
	defaultToolName: "Raster-Funktionsvorlage",
	defaultToolDescription: "Fügen Sie eine kurze Zusammenfassung der Raster-Funktion hinzu.",
	defaultHelpText: "Klicken Sie auf das Hilfe-Symbol, um den Hilfetext zu bearbeiten",
	editHelpTitle: "Hilfe bearbeiten",
	saveLabel: "Speichern",
	cancelLabel: "Abbrechen",
	thumbnail: {
		wrongImageType: "Falscher Bildtyp ausgewählt",
		notAvailable: "Miniaturansicht nicht verfügbar",
		loadError: "Bild konnte nicht geladen werden",
		chooseFile: "Zum Auswählen einer Datei klicken"
	}
};
const saveUtils = {
	thumbnail: "Miniaturansicht",
	sharing: "Freigeben"
};
const close = "Schließen";
const unsavedWarningExisting = "Möchten Sie die Änderungen speichern, die am Element <b>${itemTitle}</b> vorgenommen wurden?";
const unsavedWarningNew = "Möchten Sie die Änderungen speichern?";
const saveAs = "Speichern als";
const dontSave = "Nicht speichern";
const unsavedTitle = "Nicht gespeicherte Änderungen";
const invalidRFTMessage = "Die erstellte Raster-Funktionsvorlage ist ungültig.";
const errorTitle = "Fehler";
const breadcrumb = "Raster-Funktions-Editor";
const breadcrumbEditor = "Inhalt > Raster-Funktions-Editor";
const viewerModeTitle = "Schreibgeschützt";
const viewerModeMessage = "Die Vorlagenelement für Raster-Funktionen ist schreibgeschützt. Änderungen können nicht gespeichert werden.";
const userStartDirection = "Wählen Sie eine Funktion aus, um mit der Erstellung einer Raster-Funktionsvorlage zu beginnen.";
const selectFunction = "Funktion hinzufügen";
const deselectFunction = "Funktion entfernen";
const dialogTitle = "System";
const category = "Kategorien";
const search = "Raster-Funktionen durchsuchen";
const categoryNames = {
	analysis: "Analyse",
	appearance: "Aussehen",
	classification: "Klassifizierung",
	conversion: "Konvertierung",
	correction: "Korrektur",
	dataManagement: "Datenmanagement",
	distance: "Entfernung",
	distanceLegacy: "Entfernung (Legacy)",
	hydrology: "Hydrologie",
	math: "Mathematik",
	mathConditional: "Mathematik: Konditional",
	mathLogical: "Mathematik: Logisch",
	mathTrigonometric: "Mathematik: Trigonometrisch",
	reclass: "Reklassifizieren",
	statistical: "Statistisch",
	surface: "Oberfläche"
};
const commonStrings_de = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_de);


//# sourceMappingURL=common-strings.de-1454f434.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLWM0YzIwMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsazFCQUFrMUI7QUFDbDFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrWkFBK1oscUpBQXFKLHFFQUFxRTtBQUN6bkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBOQUEwTjtBQUMxTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsODhHQUE4OEcsT0FBTztBQUNyOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxLQUFLO0FBQzlFLHlFQUF5RSxLQUFLO0FBQzlFLDRGQUE0RixLQUFLO0FBQ2pHLDRGQUE0RixLQUFLO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFVBQVU7QUFDakUsZ0VBQWdFLFVBQVU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxTQUFTO0FBQ25GO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxVQUFVO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixVQUFVO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsZ0JBQWdCLEVBQUM7QUFDaW9DOztBQUVqcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS9jb21tb24tc3RyaW5ncy5kZS0xNDU0ZjQzNC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvayA9IFwiT0tcIjtcbmNvbnN0IGNhbmNlbCA9IFwiQWJicmVjaGVuXCI7XG5jb25zdCBlbnRlclVSTCA9IFwiSW1hZ2UtU2VydmljZS1VUkwgZWluZ2ViZW5cIjtcbmNvbnN0IHNlcnZpY2VVUkwgPSBcIlNlcnZpY2UtVVJMXCI7XG5jb25zdCBzZWxlY3RSYXN0ZXIgPSBcIlJhc3RlciBhdXN3w6RobGVuXCI7XG5jb25zdCBmYWlsZWRUb0xvYWRMYXllciA9IFwiRmVobGVyIGJlaW0gTGFkZW4gZGVzIExheWVyc1wiO1xuY29uc3QgbG9hZGluZ0xheWVyID0gXCJMYXllciB3aXJkIGdlbGFkZW5cIjtcbmNvbnN0IHNlbGVjdEZlYXR1cmUgPSBcIkZlYXR1cmUtTGF5ZXIgYXVzd8OkaGxlblwiO1xuY29uc3QgZW50ZXJGVVJMID0gXCJGZWF0dXJlLVNlcnZpY2UtVVJMIGVpbmdlYmVuXCI7XG5jb25zdCBhZGRSYXN0ZXIgPSBcIlJhc3Rlci1WYXJpYWJsZSBoaW56dWbDvGdlblwiO1xuY29uc3QgYWRkU2NhbGFyID0gXCJLb25zdGFudGUgaGluenVmw7xnZW5cIjtcbmNvbnN0IHJhc3RlciA9IFwiUmFzdGVyXCI7XG5jb25zdCBzY2FsYXIgPSBcIlNrYWxhclwiO1xuY29uc3QgZGVmYXVsdE1vZGVsTmFtZSA9IFwiUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2VcIjtcbmNvbnN0IGdlbmVyYWwgPSBcIkFsbGdlbWVpblwiO1xuY29uc3QgcGFyYW1ldGVycyA9IFwiUGFyYW1ldGVyXCI7XG5jb25zdCB2YXJpYWJsZXMgPSBcIlZhcmlhYmxlblwiO1xuY29uc3QgbmFtZSA9IFwiTmFtZVwiO1xuY29uc3QgZGVzY3JpcHRpb24gPSBcIkJlc2NocmVpYnVuZ1wiO1xuY29uc3QgcGFyYW1ldGVyID0gXCJQYXJhbWV0ZXJcIjtcbmNvbnN0IGlzUHVibGljID0gXCJJc1B1YmxpY1wiO1xuY29uc3QgaXNEYXRhc2V0ID0gXCJJc0RhdGFzZXRcIjtcbmNvbnN0IHVua25vd25QaXhlbFR5cGUgPSBcIlVuYmVrYW5udFwiO1xuY29uc3Qgb3V0cHV0UGl4ZWxUeXBlID0gXCJBdXNnYWJlcGl4ZWx0eXBcIjtcbmNvbnN0IHU4UGl4ZWxUeXBlID0gXCI4LUJpdCBvaG5lIFZvcnplaWNoZW5cIjtcbmNvbnN0IHM4UGl4ZWxUeXBlID0gXCI4LUJpdCBtaXQgVm9yemVpY2hlblwiO1xuY29uc3QgdTE2UGl4ZWxUeXBlID0gXCIxNi1CaXQgb2huZSBWb3J6ZWljaGVuXCI7XG5jb25zdCBzMTZQaXhlbFR5cGUgPSBcIjE2LUJpdCBtaXQgVm9yemVpY2hlblwiO1xuY29uc3QgdTMyUGl4ZWxUeXBlID0gXCIzMi1CaXQgb2huZSBWb3J6ZWljaGVuXCI7XG5jb25zdCBzMzJQaXhlbFR5cGUgPSBcIjMyLUJpdCBtaXQgVm9yemVpY2hlblwiO1xuY29uc3QgZjMyUGl4ZWxUeXBlID0gXCIzMi1CaXQtR2xlaXRrb21tYXphaGxcIjtcbmNvbnN0IGY2NFBpeGVsVHlwZSA9IFwiNjQtQml0LURvdWJsZVwiO1xuY29uc3QgcHJvcGVydGllcyA9IFwiRWlnZW5zY2hhZnRlblwiO1xuY29uc3QgbXVsdGlkaW1lbnNpb25hbFJ1bGVzID0gXCJNdWx0aWRpbWVuc2lvbmFsZSBSZWdlbG5cIjtcbmNvbnN0IG1hdGNoVmFyaWFibGVzID0gXCJWYXJpYWJsZW4gYWJnbGVpY2hlblwiO1xuY29uc3QgdW5pb25EaW1lbnNpb25zID0gXCJEaW1lbnNpb25lbiB2ZXJlaW5pZ2VuXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbkVkaXRvciA9IHtcblx0aW52YWxpZFJGVE1lc3NhZ2U6IFwiRGllIFJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlIGlzdCB1bmfDvGx0aWcuXCIsXG5cdHJmeEFyZ3NFZGl0b3I6IHtcblx0XHRvdXRwdXRSYXN0ZXI6IFwiQXVzZ2FiZS1SYXN0ZXJcIixcblx0XHRyYXN0ZXI6IFwiUmFzdGVyXCIsXG5cdFx0dW5zdXBwb3J0ZWREYXRhVHlwZVdhcm5pbmc6IFwiRGllIGZvbGdlbmRlbiBBcmd1bWVudGUgd2VyZGVuIG5pY2h0IGFuZ2V6ZWlndCwgZGEgc2llIGRlcnplaXQgbmljaHQgdW50ZXJzdMO8dHp0IHdlcmRlbi5cIixcblx0XHR1bnN1cHBvcnRlZEZ1bmN0aW9uOiBcIkVudGjDpGx0IGFrdHVlbGwgbmljaHQgdW50ZXJzdMO8dHp0ZSBSYXN0ZXItRnVua3Rpb25lbi5cIlxuXHR9LFxuXHRyZnhSYXN0ZXJJbnB1dDoge1xuXHRcdHNlbGVjdExheWVyOiBcIkxheWVyIGF1c3fDpGhsZW5cIixcblx0XHRicm93c2VMYXllcnM6IFwiTGF5ZXIgZHVyY2hzdWNoZW5cIixcblx0XHRyZnhWYXJpYWJsZTogXCJSYXN0ZXJGdW5jdGlvblZhcmlhYmxlXCJcblx0fSxcblx0cmZ4QmFuZENvbWJpbmF0aW9uRWRpdG9yOiB7XG5cdFx0bWV0aG9kTGFiZWw6IFwiTWV0aG9kZVwiLFxuXHRcdGJhbmRMYWJlbDogXCJCYW5kXCIsXG5cdFx0Y29tYmluYXRpb25MYWJlbDogXCJLb21iaW5hdGlvblwiXG5cdH0sXG5cdHJmeFJlbWFwR3JpZDoge1xuXHRcdG1pbmltdW06IFwiTWluaW11bVwiLFxuXHRcdG1heGltdW06IFwiTWF4aW11bVwiLFxuXHRcdG91dHB1dDogXCJBdXNnYWJlXCIsXG5cdFx0bm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdHJlbWFwVmFsdWVzTGFiZWw6IFwiV2VydGUgbmV1IHp1b3JkbmVuXCJcblx0fSxcblx0cmZ4TmFtZWRSYXN0ZXJFZGl0b3I6IHtcblx0XHRyYXN0ZXJWYXJpYWJsZXM6IFwiUmFzdGVyLVZhcmlhYmxlblwiLFxuXHRcdGRlbGV0ZVNlbGVjdGVkVmFyczogXCJBdXNnZXfDpGhsdGUgVmFyaWFibGVuIGVudGZlcm5lblwiXG5cdH0sXG5cdHJmeENsaXBwaW5nR2VvbWV0cnk6IHtcblx0XHRjbGlwcGluZ0xheWVyOiBcIkF1c3NjaG5laWRlLUxheWVyXCIsXG5cdFx0Y2xpcHBpbmdSYXN0ZXI6IFwiUmFzdGVyIHp1bSBBdXNzY2huZWlkZW5cIixcblx0XHRjbGlwcGluZ0dlb21ldHJ5OiBcIkF1c3NjaG5laWRlZ2VvbWV0cmllXCIsXG5cdFx0Y3VzdG9tRXh0ZW50OiBcIkJlbnV0emVyZGVmaW5pZXJ0ZSBBdXNkZWhudW5nXCIsXG5cdFx0b3V0cHV0RXh0ZW50OiBcIkF1c2dhYmVhdXNkZWhudW5nXCIsXG5cdFx0Y3VycmVudEV4dGVudDogXCJBa3R1ZWxsZSBLYXJ0ZW5hdXNkZWhudW5nXCIsXG5cdFx0ZHJhd0xhYmVsOiBcIlplaWNobmVuXCJcblx0fSxcblx0cmZ4Q3VzdG9tRXh0ZW50OiB7XG5cdFx0dG9wOiBcIk9iZW5cIixcblx0XHRyaWdodDogXCJSZWNodHNcIixcblx0XHRib3R0b206IFwiVW50ZW5cIixcblx0XHRsZWZ0OiBcIkxpbmtzXCJcblx0fSxcblx0cmZ4UmFzdGVyQXJyYXlFZGl0b3I6IHtcblx0XHRtb3ZlVXA6IFwiTmFjaCBvYmVuIHZlcnNjaGllYmVuXCIsXG5cdFx0bW92ZURvd246IFwiTmFjaCB1bnRlbiB2ZXJzY2hpZWJlblwiLFxuXHRcdHJlbW92ZTogXCJFbnRmZXJuZW5cIlxuXHR9LFxuXHRyZnhTdGF0aXN0aWNzR3JpZDoge1xuXHRcdHN0ZERldjogXCJTdGQuIEFid1wiLFxuXHRcdG1pbjogXCJNaW4uXCIsXG5cdFx0bWF4OiBcIk1heC5cIixcblx0XHRtZWFuOiBcIk1pdHRlbHdlcnRcIlxuXHR9LFxuXHRyZnhXZWlnaHRlZFN1bVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRTdW1UYWJsZTogXCJUYWJlbGxlIGRlciBnZXdpY2h0ZXRlbiBTdW1tZVwiLFxuXHRcdGlkOiBcIklEXCIsXG5cdFx0bGF5ZXI6IFwiTGF5ZXJcIixcblx0XHRmaWVsZDogXCJGZWxkXCIsXG5cdFx0d2VpZ2h0OiBcIkdld2ljaHR1bmdcIixcblx0XHR2YWx1ZTogXCJXZXJ0XCIsXG5cdFx0c2VsZWN0TGF5ZXI6IFwiTGF5ZXIgYXVzd8OkaGxlblwiXG5cdH0sXG5cdHJmeFdlaWdodGVkT3ZlcmxheVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRPdmVybGF5VGFibGU6IFwiR2V3aWNodHVuZ3PDvGJlcmxhZ2VydW5nc3RhYmVsbGVcIixcblx0XHRpZDogXCJJRFwiLFxuXHRcdGxheWVyOiBcIkxheWVyXCIsXG5cdFx0ZmllbGQ6IFwiRmVsZFwiLFxuXHRcdGluZmx1ZW5jZTogXCJFaW5mbHVzc1wiLFxuXHRcdHN1bU9mSW5mbHVlbmNlOiBcIlN1bW1lIGRlciBFaW5mbMO8c3NlXCIsXG5cdFx0dmFsdWU6IFwiV2VydFwiLFxuXHRcdHJlbWFwVGFibGU6IFwiTmV1enVvcmRudW5ncy1UYWJlbGxlXCIsXG5cdFx0c2NhbGU6IFwiTWHDn3N0YWJcIixcblx0XHRzY2FsZXM6IFwiTWHDn3N0w6RiZVwiLFxuXHRcdHNlbGVjdFJhc3RlcjogXCJSYXN0ZXIgYXVzd8OkaGxlblwiXG5cdH0sXG5cdHJmeEZlYXR1cmVTZWxlY3Q6IHtcblx0XHRhZGRGZWF0dXJlTGF5ZXI6IFwiTmFjaCBlaW5lbSBGZWF0dXJlLUxheWVyIHN1Y2hlblwiLFxuXHRcdGFkZFBvaW50TGF5ZXI6IFwiTmFjaCBlaW5lbSBQdW5rdC1MYXllciBzdWNoZW5cIlxuXHR9LFxuXHRyZnhGaWVsZFNlbGVjdDoge1xuXHRcdHZhbHVlOiBcIldlcnRcIixcblx0XHRjb3VudDogXCJBbnphaGxcIlxuXHR9LFxuXHRyZnhBdHRyaWJ1dGVUYWJsZToge1xuXHRcdHRhYmxlVHlwZTogXCJUYWJlbGxlbnR5cFwiLFxuXHRcdG1hbnVhbDogXCJNYW51ZWxsXCIsXG5cdFx0ZXh0ZXJuYWw6IFwiRXh0ZXJuXCIsXG5cdFx0bWluVmFsOiBcIk1pbmltYWx3ZXJ0XCIsXG5cdFx0bWF4VmFsOiBcIk1heGltYWx3ZXJ0XCIsXG5cdFx0YmFzZUNsYXNzTmFtZTogXCJCYXNpc25hbWUgZsO8ciBLbGFzc2VcIixcblx0XHRjb2xvclNjaGVtZTogXCJGYXJic2NoZW1hXCIsXG5cdFx0ZGVmYXVsdENsYXNzTmFtZTogXCJMYWJlbF9cIixcblx0XHRnZW5lcmF0ZVRhYmxlOiBcIlRhYmVsbGUgZ2VuZXJpZXJlblwiLFxuXHRcdGJyb3dzZVRhYmxlOiBcIlRhYmVsbGUgZHVyY2hzdWNoZW5cIixcblx0XHR2YWx1ZTogXCJXZXJ0XCIsXG5cdFx0Y2xhc3NuYW1lOiBcIkNsYXNzTmFtZVwiLFxuXHRcdGNvbG9yOiBcIkZhcmJlXCJcblx0fSxcblx0cmZ4RmllbGROdW1iZXJTd2l0Y2hhYmxlOiB7XG5cdFx0bnVtYmVyOiBcIk51bWVyaXNjaFwiLFxuXHRcdGZpZWxkOiBcIkZlbGRcIixcblx0XHRzdHJpbmc6IFwiWmVpY2hlbmZvbGdlXCIsXG5cdFx0bGluZWFyVW5pdDogXCJMaW5lYXJlIEVpbmhlaXRcIlxuXHR9LFxuXHRyZnhQcm9wZXJ0eVNldDoge1xuXHRcdG5hbWU6IFwiTmFtZVwiLFxuXHRcdHZhbHVlOiBcIldlcnRcIlxuXHR9LFxuXHRyZnhDb252ZXJzaW9uR3JpZDoge1xuXHRcdHNpemU6IFwiR3LDtsOfZVwiXG5cdH0sXG5cdHJmeFRyYW5zcG9zZUJpdDoge1xuXHRcdGJpdFBhdHRlcm46IFwiQml0LU11c3RlclwiLFxuXHRcdG91dHB1dEJpdDogXCJBdXNnYWJlYml0XCIsXG5cdFx0aW5wdXRCaXQ6IFwiRWluZ2FiZWJpdFwiXG5cdH0sXG5cdHJmeFNwYXRpYWxSZWZlcmVuY2U6IHtcblx0XHRwbGFjZUhvbGRlcjogXCJOYWNoIFNjaGzDvHNzZWx3b3J0IGVpbmdyZW56ZW5cIixcblx0XHRjb29yZGluYXRlU3lzdGVtOiBcIktvb3JkaW5hdGVuc3lzdGVtXCIsXG5cdFx0Z2NzOiBcIkdlb2dyYXBoaXNjaGVzIEtvb3JkaW5hdGVuc3lzdGVtXCIsXG5cdFx0cGNzOiBcIlByb2ppemllcnRlcyBLb29yZGluYXRlbnN5c3RlbVwiLFxuXHRcdHZjczogXCJWZXJ0aWthbGVzIEtvb3JkaW5hdGVuc3lzdGVtXCJcblx0fVxufTtcbmNvbnN0IHJmeExpY2Vuc2VJbmZvID0gXCJEaWVzZSBSYXN0ZXItRnVua3Rpb25zdm9ybGFnZSBrw7ZubmVuIFNpZSB6dXIgVmVyYXJiZWl0dW5nIElocmVyIEJpbGRkYXRlbiBtaXRoaWxmZSB2b24gQXJjR0lTIEltYWdlIFNlcnZlciB2ZXJ3ZW5kZW4uXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbnMgPSB7XG5cdHJmeDoge1xuXHRcdGFDb3NITmFtZTogXCJBQ29zSFwiLFxuXHRcdGFDb3NIU25pcDogXCJEZW4gQXJlYWtvc2ludXMgdm9uIFplbGxlbiBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmVuLlwiLFxuXHRcdGFDb3NIRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIHdpcmQgZGVyIEFyZWFrb3NpbnVzIEh5cGVyYm9saWN1cyBkZXIgUGl4ZWwgaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5ldC5cIixcblx0XHRhQ29zTmFtZTogXCJBQ29zXCIsXG5cdFx0YUNvc1NuaXA6IFwiQmVyZWNobmV0IGRlbiBBcmt1c2tvc2ludXMgZGVyIFBpeGVsIGluIGVpbmVtIFJhc3Rlci5cIixcblx0XHRhQ29zRGVzYzogXCJNaXQgZGllc2VyIFJhc3Rlci1GdW5rdGlvbiB3aXJkIGRlciBBcmt1c2tvc2ludXMgdm9uIFplbGxlbiBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmV0LiBJbiBkZXIgTWF0aGVtYXRpayB2ZXJmw7xnZW4gYWxsZSB0cmlnb25vbWV0cmlzY2hlbiBGdW5rdGlvbmVuIMO8YmVyIGVpbmVuIGRlZmluaWVydGVuIEJlcmVpY2ggZ8O8bHRpZ2VyIEVpbmdhYmV3ZXJ0ZSwgZGVyIGFscyBEb23DpG5lIGJlemVpY2huZXQgd2lyZC4gRGllIEF1c2dhYmV3ZXJ0ZSBqZWRlciBGdW5rdGlvbiBoYWJlbiBlYmVuZmFsbHMgZWluZW4gZGVmaW5pZXJ0ZW4gQmVyZWljaC4gRsO8ciBkaWVzZXMgV2Vya3pldWcgYmV0csOkZ3QgZGllIERvbcOkbmUgWy0xLCAxXSB1bmQgZGVyIEJlcmVpY2ggWzAsIHBpXS5cIixcblx0XHRhU2luSE5hbWU6IFwiQVNpbkhcIixcblx0XHRhU2luSFNuaXA6IFwiRGVuIEFyZWFzaW51cyB2b24gWmVsbGVuIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZW4uXCIsXG5cdFx0YVNpbkhEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2lyZCBkZXIgQXJlYXNpbnVzIEh5cGVyYm9saWN1cyBkZXIgUGl4ZWwgaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5ldC5cIixcblx0XHRhU2luTmFtZTogXCJBU2luXCIsXG5cdFx0YVNpblNuaXA6IFwiRGVuIEFya3Vzc2ludXMgdm9uIFplbGxlbiBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmVuLlwiLFxuXHRcdGFTaW5EZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2lyZCBkZXIgQXJrdXNzaW51cyBkZXIgUGl4ZWwgaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5ldC5cIixcblx0XHRhVGFuMk5hbWU6IFwiQVRhbjJcIixcblx0XHRhVGFuMlNuaXA6IFwiRGVuIEFya3VzdGFuZ2VucyAoYXVmIEJhc2lzIHZvbiB4LHkpIHZvbiBaZWxsZW4gaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5lbi5cIixcblx0XHRhVGFuMkRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiB3aXJkIGRlciBBcmt1c3RhbmdlbnMgKGF1ZiBCYXNpcyB2b24gWFktS29vcmRpbmF0ZW4pIGRlciBQaXhlbCBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmV0LlwiLFxuXHRcdGFUYW5ITmFtZTogXCJBVGFuSFwiLFxuXHRcdGFUYW5IU25pcDogXCJEZW4gQXJlYXRhbmdlbnMgdm9uIFplbGxlbiBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmVuLlwiLFxuXHRcdGFUYW5IRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIHdpcmQgZGVyIEFyZWF0YW5nZW5zIEh5cGVyYm9saWN1cyBkZXIgUGl4ZWwgaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5ldC5cIixcblx0XHRhVGFuTmFtZTogXCJBVGFuXCIsXG5cdFx0YVRhblNuaXA6IFwiRGVuIEFya3VzdGFuZ2VucyB2b24gWmVsbGVuIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZW4uXCIsXG5cdFx0YVRhbkRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiB3aXJkIGRlciBBcmt1c3RhbmdlbnMgZGVyIFBpeGVsIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZXQuXCIsXG5cdFx0YWJzTmFtZTogXCJBYnNcIixcblx0XHRhYnNTbmlwOiBcIkRlbiBhYnNvbHV0ZW4gV2VydCBkZXIgWmVsbGVuIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZW4uXCIsXG5cdFx0YWJzRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJBYnNcXFwiIHdpcmQgZGVyIGFic29sdXRlIFdlcnQgZGVyIFBpeGVsIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZXQuXCIsXG5cdFx0cmVmbGVjdGFuY2VOYW1lOiBcIlNpY2h0YmFyZSBSZWZsZXhpb25cIixcblx0XHRyZWZsZWN0YW5jZVNuaXA6IFwiUm9oZSBCaWxkZGF0ZW4gdW50ZXIgQmVyw7xja3NpY2h0aWd1bmcgdm9uIFNlbnNvcmVpZ2Vuc2NoYWZ0ZW4sIGRlciBQb3NpdGlvbiBkZXIgU29ubmUgdW5kIGRlcyBaZWl0cHVua3RlcyBkZXIgRXJmYXNzdW5nIGluIFdlcnRlIGbDvHIgZGVuIE9iZXJyYW5kIGRlciBBdG1vc3Bow6RyZSBrb252ZXJ0aWVyZW4uXCIsXG5cdFx0cmVmbGVjdGFuY2VEZXNjOiBcIkRpZXNlIEZ1bmt0aW9uIHBhc3N0IGRpZSBkaWdpdGFsZSBOdW1tZXIgKEROKSBmw7xyIGRpZSBCaWxkaGVsbGlna2VpdHN3ZXJ0ZSBmw7xyIGVpbmlnZSBTYXRlbGxpdGVuc2Vuc29yZW4gYW4uIERpZSBBbnBhc3N1bmdlbiBiYXNpZXJlbiBhdWYgZGVyIFNvbm5lbmjDtmhlLCBkZW0gQXVmbmFobWVkYXR1bSB1bmQgZGVuIFNlbnNvcmVpZ2Vuc2NoYWZ0ZW4sIHVtIGRpZSBWZXJzdMOkcmt1bmdzLSB1bmQgVmVyemVycnVuZ3NlaW5zdGVsbHVuZ2VuIGbDvHIgamVkZXMgQmFuZCBmZXN0enVsZWdlbi4gTWl0IGRpZXNlciBGdW5rdGlvbiB3ZXJkZW4gZGllIFJlZmxleGlvbnMtIGJ6dy4gSGVsbGlna2VpdHN3ZXJ0ZSBmw7xyIGJlc3RpbW10ZSBTYXRlbGxpdGVuYmlsZGVyIGdlbcOkw58gZGVuIEVpbnN0ZWxsdW5nZW4gZsO8ciBkaWUgU3plbmVuYmVsZXVjaHR1bmcgdW5kIFNlbnNvcnZlcnN0w6Rya3VuZyBhbmdlcGFzc3QuIERpZSBCaWxkZXIgd2VyZGVuIGFuIGVpbmUgdGhlb3JldGlzY2hlIGdlbWVpbnNhbWUgQmVsZXVjaHR1bmdzYmVkaW5ndW5nIGFuZ2VwYXNzdCwgc29kYXNzIHdlbmlnZXIgQWJ3ZWljaHVuZ2VuIHp3aXNjaGVuIGRlbiBTemVuZW4gdm9uIHZlcnNjaGllZGVuZW4gRGF0dW1zZWluc3RlbGx1bmdlbiB1bmQgdW50ZXJzY2hpZWRsaWNoZW4gU2Vuc29yZW4gYmVzdGVoZW4uIERpZXMga2FubiBmw7xyIEJpbGRrbGFzc2lmaXppZXJ1bmcsIEZhcmJhdXNnbGVpY2ggdW5kIE1vc2Fpa2llcnVuZyBuw7x0emxpY2ggc2Vpbi4gRGllc2UgRnVua3Rpb24ga2FubiBudXIgZsO8ciBiZXN0aW1tdGUgQmlsZGVyIHZlcndlbmRldCB3ZXJkZW4uIERpZSBlbnRzcHJlY2hlbmRlbiBTZW5zb3JlbiBzaW5kIExhbmRzYXQgTVNTLCBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIEdlb0V5ZS0xLCBSYXBpZEV5ZSwgRE1DaWksIFdvcmxkVmlldy0xLCBXb3JsZFZpZXctMiwgU1BPVCA2IHVuZCBQbGVpYWRlcy48ZGl2Pjxici8+RGllIEZ1bmt0aW9uIGbDvGhydCB6d2VpIEtvcnJla3R1cmVuIGR1cmNoLiBEaWUgZXJzdGUgS29ycmVrdHVyIGJhc2llcnQgYXVmIGRlbiBWZXJzdMOkcmt1bmdzZWluc3RlbGx1bmdlbi4gRGllIHVyc3Byw7xuZ2xpY2hlbiBIZWxsaWdrZWl0c3dlcnRlIHdlcmRlbiBhdXMgZGVuIEJpbGR3ZXJ0ZW4gbmV1IGVyc3RlbGx0LCBpbmRlbSBkaWUgVmVyc3TDpHJrdW5nc2dsZWljaHVuZyB1bWdla2VocnQgd2lyZC4gRGllIHp3ZWl0ZSBLb3JyZWt0dXIgaMOkbmd0IG1pdCBkZW4gVW50ZXJzY2hpZWRlbiBpbiBTb25uZW53aW5rZWwgdW5kIEhlbGxpZ2tlaXQgenVzYW1tZW4uIERpZSB1cnNwcsO8bmdsaWNoZW4gSGVsbGlna2VpdHN3ZXJ0ZSB3ZXJkZW4gYW4gZWluZSBnZW1laW5zYW1lIEJlbGV1Y2h0dW5nc2JlZGluZ3VuZyBhbmdlcGFzc3QsIGluZGVtIFN6ZW5lbiwgZGllIGJlaSB2ZXJzY2hpZWRlbmVuIEJlbGV1Y2h0dW5nc2JlZGluZ3VuZ2VuIGF1Zmdlbm9tbWVuIHd1cmRlbiwgbm9ybWFsaXNpZXJ0IHdlcmRlbi4gSW0gQWxsZ2VtZWluZW4gZ2lsdCwgZGFzcyBkZXIgRGF0ZW50eXAgZGVzIEF1c2dhYmViaWxkZXMgbWl0IGRlbSBEYXRlbnR5cCBkZXMgRWluZ2FiZWJpbGRzIMO8YmVyZWluc3RpbW10LCBkaWUgQXVzZ2FiZXdlcnRlIGplZG9jaCBuaWVkcmlnZXIgYWxzIGRpZSBFaW5nYWJld2VydGUgc2luZCB1bmQgaW4gZGVuIGfDvGx0aWdlbiBEYXRlbmJlcmVpY2ggZWluZ2VwYXNzdCB3ZXJkZW4uPC9kaXY+XCIsXG5cdFx0YXJnU3RhdGlzdGljc05hbWU6IFwiQXJnU3RhdGlzdGljc1wiLFxuXHRcdGFyZ1N0YXRpc3RpY3NTbmlwOiBcIkFyZy1TdGF0aXN0aWtlbiBlaW5zY2hsaWXDn2xpY2ggQXJnTWF4LCBBcmdNaW4sIEFyZ01lZGlhbiB1bmQgRGF1ZXIgYmVyZWNobmVuLlwiLFxuXHRcdGFyZ1N0YXRpc3RpY3NEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2VyZGVuIEFyZy1TdGF0aXN0aWtlbiBiZXJlY2huZXQuIERpZSBGdW5rdGlvbiBcXFwiQXJnU3RhdGlzdGljc1xcXCIgdW1mYXNzdCB2aWVyIE1ldGhvZGVuOiBBcmdNYXgsIEFyZ01pbiwgQXJnTWVkaWFuIHVuZCBEYXVlci5cIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0aG1ldGlzY2hcIixcblx0XHRhcml0aG1ldGljU25pcDogXCJFaW5lIGFyaXRobWV0aXNjaGUgT3BlcmF0aW9uIHp3aXNjaGVuIHp3ZWkgUmFzdGVybiBiencuIGVpbmVtIFJhc3RlciB1bmQgZWluZW0gU2thbGFyIGF1c2bDvGhyZW4uXCIsXG5cdFx0YXJpdGhtZXRpY0Rlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiQXJpdGhtZXRpc2NoXFxcIiB3aXJkIGVpbmUgYXJpdGhtZXRpc2NoZSBPcGVyYXRpb24gendpc2NoZW4gendlaSBSYXN0ZXJuIGJ6dy4gZWluZW0gUmFzdGVyIHVuZCBlaW5lbSBTa2FsYXIgb2RlciB1bWdla2VocnQgYXVzZ2Vmw7xocnQuXCIsXG5cdFx0YXNwZWN0U2xvcGVOYW1lOiBcIkF1c3JpY2h0dW5nLU5laWd1bmdcIixcblx0XHRhc3BlY3RTbG9wZVNuaXA6IFwiRWluIFJhc3RlciBlcnN0ZWxsZW4sIGRhcyBnbGVpY2h6ZWl0aWcgZGllIEF1c3JpY2h0dW5nIChSaWNodHVuZykgdW5kIGRpZSBOZWlndW5nIChTdGVpbGhlaXQpIGVpbmVyIGtvbnRpbnVpZXJsaWNoZW4gT2JlcmZsw6RjaGUgYW56ZWlndCwgd2llIGluIGVpbmVtIGRpZ2l0YWxlbiBIw7ZoZW5tb2RlbGwgZGFyZ2VzdGVsbHQuXCIsXG5cdFx0YXNwZWN0U2xvcGVEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIkF1c3JpY2h0dW5nLU5laWd1bmdcXFwiIHdpcmQgZWluIFJhc3Rlci1MYXllciBlcnN0ZWxsdCwgaW4gZGVtIGdsZWljaHplaXRpZyBkaWUgQXVzcmljaHR1bmcgdW5kIGRpZSBOZWlndW5nIGVpbmVyIE9iZXJmbMOkY2hlIGFuemVpZ3Qgd2VyZGVuLiBEaWUgRnVua3Rpb24gXFxcIkF1c3JpY2h0dW5nXFxcIiBiZXN0aW1tdCBkaWUgTmVpZ3VuZ3NyaWNodHVuZyBkZXIgbWF4aW1hbGVuIMOEbmRlcnVuZ3NyYXRlIGRlcyBXZXJ0cyB2b24gZWluZW0gUGl4ZWwgenVtIGpld2VpbGlnZW4gYmVuYWNoYmFydGVuIFBpeGVsLiBTaWUga8O2bm5lbiBzaWNoIGRpZSBBdXNyaWNodHVuZyBhbHNvIGFscyBOZWlndW5nc3JpY2h0dW5nIHZvcnN0ZWxsZW4uIERpZSBXZXJ0ZSBkZXMgQXVzZ2FiZS1SYXN0ZXJzIGVudHNwcmVjaGVuIGRlciBLb21wYXNzcmljaHR1bmcgZGVyIEF1c3JpY2h0dW5nLCBkaWUgZHVyY2ggZWluZW4gRmFyYnRvbiBkYXJnZXN0ZWxsdCB3aXJkLiBEaWUgTmVpZ3VuZyBzdGVsbHQgZGllIMOEbmRlcnVuZ3NyYXRlIGRlciBIw7ZoZSBmw7xyIGplZGVzIFBpeGVsIGRlcyBkaWdpdGFsZW4gSMO2aGVubW9kZWxscyAoREVNKSBkYXIuIERpZSBOZWlndW5nIHN0ZWxsdCBkaWUgU3RlaWxoZWl0IGVpbmVyIE9iZXJmbMOkY2hlIGRhciB1bmQgd2lyZCBpbiBGb3JtIHZvbiBkcmVpIEtsYXNzZW4gc3ltYm9saXNpZXJ0LCBkaWUgZHVyY2ggRmFyYnPDpHR0aWd1bmcgKEhlbGxpZ2tlaXQpIGdla2VubnplaWNobmV0IHdlcmRlbi48ZGl2Pjxici8+RGllIFBpeGVsd2VydGUgaW0gQXVzcmljaHR1bmdzLU5laWd1bmdzLUF1c2dhYmUtUmFzdGVyIGJlemVpY2huZW4gZWluZSBiZXN0aW1tdGUgS29tYmluYXRpb24gYXVzIEF1c3JpY2h0dW5nIHVuZCBOZWlndW5nLiBEYWJlaSBzdGVoZW4gUGl4ZWx3ZXJ0ZSB1bnRlciAyMCAoZ3JhdSBkYXJnZXN0ZWxsdCkgZsO8ciBlaW5lIGViZW5lIEZsw6RjaGUuIEF1c3JpY2h0dW5ncy1OZWlndW5ncy1XZXJ0ZSBhYiAyMSB3ZXJkZW4gZm9sZ2VuZGVybWHDn2VuIGluIHVudGVyc2NoaWVkbGljaGVuIEZhcmJzw6R0dGlndW5nZW4gZGFyZ2VzdGVsbHQ6IDIxIGJpcyAzMDogRmFyYnPDpHR0aWd1bmcgenVyIERhcnN0ZWxsdW5nIGVpbmVyIGdlcmluZ2VuIE5laWd1bmcsIDMxIGJpcyA0MDogRmFyYnPDpHR0aWd1bmcgenVyIERhcnN0ZWxsdW5nIGVpbmVyIG1pdHRsZXJlbiBOZWlndW5nLCBhYiA0MTogRmFyYnPDpHR0aWd1bmcgenVyIERhcnN0ZWxsdW5nIGVpbmVyIGdyb8OfZW4gTmVpZ3VuZzwvZGl2PlwiLFxuXHRcdGFzcGVjdE5hbWU6IFwiQXVzcmljaHR1bmdcIixcblx0XHRhc3BlY3RTbmlwOiBcIkFuemVpZ2VuLCBpbiB3ZWxjaGUgUmljaHR1bmcgZWluIFBpeGVsIHdlaXN0LCB3b2JlaSAwIE5vcmRlbiBkYXJzdGVsbHQgdW5kIFdpbmtlbCBpbSBVaHJ6ZWlnZXJzaW5uIGJpcyAzNjAgenVuZWhtZW4uXCIsXG5cdFx0YXNwZWN0RGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIkF1c3JpY2h0dW5nXFxcIiBiZXN0aW1tdCBkaWUgTmVpZ3VuZ3NyaWNodHVuZyBkZXIgbWF4aW1hbGVuIMOEbmRlcnVuZ3NyYXRlIGRlcyBXZXJ0ZXMgamVkZXIgZWluemVsbmVuIFplbGxlIHp1ciBqZXdlaWxpZ2VuIE5hY2hiYXJ6ZWxsZS4gU2llIGvDtm5uZW4gc2ljaCBkaWUgQXVzcmljaHR1bmcgYWxzbyBhbHMgTmVpZ3VuZ3NyaWNodHVuZyB2b3JzdGVsbGVuLiBEaWUgV2VydGUgZGVzIEF1c2dhYmUtUmFzdGVycyBiZXN0aW1tZW4gZGllIEtvbXBhc3NyaWNodHVuZyBkZXIgQXVzcmljaHR1bmcuPGRpdj48YnIvPkRpZSBFaW5nYWJlIGbDvHIgZGllc2UgRnVua3Rpb24gaXN0IGRhcyBFaW5nYWJlLVJhc3Rlci4gRGllIEZ1bmt0aW9uIFxcXCJBdXNyaWNodHVuZ1xcXCIgd2lyZCBvZnQgYXVmIGVpbiBkaWdpdGFsZXMgSMO2aGVubW9kZWxsIChEaWdpdGFsIEVsZXZhdGlvbiBNb2RlbCwgREVNKSBhbmdld2VuZGV0LiBTdGFuZGFyZG3DpMOfaWcgd2lyZCBkaWUgQXVzcmljaHR1bmcgYWxzIEdyYXVzdHVmZW5iaWxkIGFuZ2V6ZWlndC4gU2llIGvDtm5uZW4gZGllIEZ1bmt0aW9uIFxcXCJDb2xvcm1hcFxcXCIgaGluenVmw7xnZW4sIHVtIGVpbiBiZXN0aW1tdGVzIEZhcmJzY2hlbWEgYW56dWdlYmVuIG9kZXIgdW0gZWluZW0gQmVudXR6ZXIgYmVpIGRlciBBbnplaWdlIGRlcyBNb3NhaWtzIHp1IGVybcO2Z2xpY2hlbiwgZGllIFN5bWJvbGlzaWVydW5nIG1pdCBlaW5lbSBlaWdlbmVuIEZhcmJzY2hlbWEgenUgw6RuZGVybi48L2Rpdj5cIixcblx0XHR0YWJsZU5hbWU6IFwiQXR0cmlidXR0YWJlbGxlXCIsXG5cdFx0dGFibGVTbmlwOiBcIlZlcndlbmRldCB6dW0gQmVuZW5uZW4gdW5kIFN5bWJvbGlzaWVyZW4gZGVyIFdlcnRlIGluIGVpbmVtIERhdGFzZXQgZWluZSBUYWJlbGxlLiBEaWUgU3BhbHRlbiBmw7xyIGRpZSBUYWJlbGxlIG3DvHNzZW4gZHVyY2ggS29tbWEgZ2V0cmVubnQgd2VyZGVuOiBQaXhlbFZhbHVlLCBBdHRyaWJ1dGVOYW1lLCBSZWRWYWx1ZSwgR3JlZW5WYWx1ZSwgQmx1ZVZhbHVlLlwiLFxuXHRcdHRhYmxlRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJBdHRyaWJ1dHRhYmVsbGVcXFwiIGvDtm5uZW4gU2llIGVpbmUgQXR0cmlidXR0YWJlbGxlIGRlZmluaWVyZW4sIHVtIGVpbiBFaW56ZWxiYW5kLU1vc2Fpay1EYXRhc2V0IG9kZXIgUmFzdGVyLURhdGFzZXQgenUgc3ltYm9saXNpZXJlbi4gPGRpdj48YnIvPkRpZXMgaXN0IG7DvHR6bGljaCwgd2VubiBTaWUgQmlsZGRhdGVuIHByw6RzZW50aWVyZW4gbcO2Y2h0ZW4sIGRpZSBhbHMgTGFuZG51dHp1bmcga2xhc3NpZml6aWVydCB3dXJkZW4sIHouIEIuIFdhbGRmbMOkY2hlbiwgU3VtcGZnZWJpZXRlLCBLdWx0dXJmbMOkY2hlbiB1bmQgU3RhZHRnZWJpZXRlLiBXZW5uIGRpZSBUYWJlbGxlIGRhcsO8YmVyIGhpbmF1cyBGZWxkZXIgZW50aMOkbHQsIGRpZSBhbHMgcm90LCBncsO8biB1bmQgYmxhdSBiZW5hbm50IHNpbmQsIHdlcmRlbiBiZWltIFJlbmRlcm4gZGVzIEJpbGRlcyBXZXJ0ZSBpbm5lcmhhbGIgZGllc2VyIEZlbGRlciB3aWUgZWluZSBDb2xvcm1hcCB2ZXJ3ZW5kZXQuPC9kaXY+XCIsXG5cdFx0YmFuZEFyaXRobWV0aWNOYW1lOiBcIkJhbmRhcml0aG1ldGlrXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNTbmlwOiBcIkluZGl6ZXMgbWl0IGRlbiB2b3JkZWZpbmllcnRlbiBGb3JtZWxuIG9kZXIgZWluZW0gYmVudXR6ZXJkZWZpbmllcnRlbiBBdXNkcnVjayBiZXJlY2huZW4uXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNEZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiQmFuZGFyaXRobWV0aWtcXFwiIGbDvGhydCBlaW5lIGFyaXRobWV0aXNjaGUgT3BlcmF0aW9uIGF1ZiBkZW4gQsOkbmRlcm4gZWluZXMgUmFzdGVyLURhdGFzZXRzIGF1cy4gU2llIGvDtm5uZW4gdm9yZGVmaW5pZXJ0ZSBBbGdvcml0aG1lbiBhdXN3w6RobGVuIG9kZXIgZWluZSBlaWdlbmUgZWluemVpbGlnZSBGb3JtZWwgZWluZ2ViZW4uIERpZSB1bnRlcnN0w7x0enRlbiBPcGVyYXRvcmVuIHNpbmQgLSwgKywgLywgKiB1bmQgdW7DpHJlcyAtLlwiLFxuXHRcdHRocmVzaG9sZE5hbWU6IFwiQmluw6RyZXIgU2Nod2VsbGVud2VydFwiLFxuXHRcdHRocmVzaG9sZFNuaXA6IFwiS29udGludWllcmxpY2hlIERhdGVuIGluIFZvcmRlcmdydW5kIHVuZCBIaW50ZXJncnVuZCBvcmdhbmlzaWVyZW4sIGluZGVtIGRpZSBLb3Zhcmlhbnogendpc2NoZW4gendlaSBLbGFzc2VuIG1pbmltaWVydCB3aXJkLlwiLFxuXHRcdHRocmVzaG9sZERlc2M6IFwiV2VubiBlaW4gUmFzdGVyLURhdGFzZXQgZWluZSBiaW1vZGFsZSBWZXJ0ZWlsdW5nIGF1ZndlaXN0LCB3aXJkIG1pdCBkaWVzZXIgRnVua3Rpb24gZWluIG5ldWVzIFJhc3RlciBlcnN0ZWxsdCwgZGFzIGRpZSBEYXRlbiBpbiB6d2VpIHVudGVyc2NoaWVkbGljaGUgS2xhc3NlbiB1bnRlcnRlaWx0LiBFcyB3aXJkIGVpbmUgS2xhc3NlIG1pdCBuaWVkcmlnZW4gV2VydGVuIGVyc3RlbGx0LCBkaWUgbWl0IHNjaHdhcnplbiBQaXhlbG4gZGFyZ2VzdGVsbHQgd2lyZCwgdW5kIGVpbmUgS2xhc3NlIG1pdCBob2hlbiBXZXJ0ZW4sIGRpZSBtaXQgd2Vpw59lbiBQaXhlbG4gZGFyZ2VzdGVsbHQgd2lyZC5cIixcblx0XHRiaXR3aXNlQW5kTmFtZTogXCJCaXR3aXNlIEFuZFwiLFxuXHRcdGJpdHdpc2VBbmRTbmlwOiBcIkbDvGhydCBlaW5lIGJpdHdlaXNlIEFORC1PcGVyYXRpb24gZsO8ciBkaWUgYmluw6RyZW4gV2VydGUgdm9uIHp3ZWkgRWluZ2FiZS1SYXN0ZXJuIGF1cy5cIixcblx0XHRiaXR3aXNlQW5kRGVzYzogXCJNaXQgXFxcIkJpdHdpc2UgQW5kXFxcIiB3aXJkIGVpbmUgYml0d2Vpc2UgQU5ELU9wZXJhdGlvbiBmw7xyIGRpZSBiaW7DpHJlbiBXZXJ0ZSB6d2VpZXIgRWluZ2FiZS1SYXN0ZXIgYXVzZ2Vmw7xocnQuXCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdE5hbWU6IFwiQml0d2lzZSBMZWZ0IFNoaWZ0XCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdFNuaXA6IFwiRsO8aHJ0IGVpbmUgYml0d2Vpc2UgTEVGVCBTSElGVC1PcGVyYXRpb24gZsO8ciBkaWUgYmluw6RyZW4gV2VydGUgdm9uIHp3ZWkgRWluZ2FiZS1SYXN0ZXJuIGF1cy5cIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0RGVzYzogXCJNaXQgXFxcIkJpdHdpc2UgTGVmdCBTaGlmdFxcXCIgd2lyZCBlaW5lIGJpdHdlaXNlIExFRlQgU0hJRlQtT3BlcmF0aW9uIGbDvHIgZGllIGJpbsOkcmVuIFdlcnRlIHp3ZWllciBFaW5nYWJlLVJhc3RlciBhdXNnZWbDvGhydC5cIixcblx0XHRiaXR3aXNlTm90TmFtZTogXCJCaXR3aXNlIE5vdFwiLFxuXHRcdGJpdHdpc2VOb3RTbmlwOiBcIkbDvGhydCBlaW5lIGJpdHdlaXNlIE5PVC1PcGVyYXRpb24gKEtvbXBsZW1lbnQpIGbDvHIgZGllIGJpbsOkcmVuIFdlcnRlIHp3ZWllciBFaW5nYWJlLVJhc3RlciBhdXMuXCIsXG5cdFx0Yml0d2lzZU5vdERlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiB3aXJkIGVpbmUgYml0d2Vpc2UgTk9ULU9wZXJhdGlvbiAoS29tcGxlbWVudCkgZsO8ciBkZW4gYmluw6RyZW4gV2VydCBlaW5lcyBFaW5nYWJlLVJhc3RlcnMgYXVzZ2Vmw7xocnQuXCIsXG5cdFx0Yml0d2lzZU9yTmFtZTogXCJCaXR3aXNlIE9yXCIsXG5cdFx0Yml0d2lzZU9yU25pcDogXCJGw7xocnQgZWluZSBiaXR3ZWlzZSBPUi1PcGVyYXRpb24gZsO8ciBkaWUgYmluw6RyZW4gV2VydGUgdm9uIHp3ZWkgRWluZ2FiZS1SYXN0ZXJuIGF1cy5cIixcblx0XHRiaXR3aXNlT3JEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2lyZCBlaW5lIGJpdHdlaXNlIE9SLU9wZXJhdGlvbiBmw7xyIGRpZSBiaW7DpHJlbiBXZXJ0ZSB6d2VpZXIgRWluZ2FiZS1SYXN0ZXIgYXVzZ2Vmw7xocnQuIFwiLFxuXHRcdGJpdHdpc2VSaWdodFNoaWZ0TmFtZTogXCJCaXR3aXNlIFJpZ2h0IFNoaWZ0XCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnRTbmlwOiBcIkbDvGhydCBlaW5lIGJpdHdlaXNlIFJJR0hUIFNISUZULU9wZXJhdGlvbiBmw7xyIGRpZSBiaW7DpHJlbiBXZXJ0ZSB2b24gendlaSBFaW5nYWJlLVJhc3Rlcm4gYXVzLlwiLFxuXHRcdGJpdHdpc2VSaWdodFNoaWZ0RGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIHdpcmQgZWluZSBiaXR3ZWlzZSBSSUdIVCBTSElGVC1PcGVyYXRpb24gZsO8ciBkaWUgYmluw6RyZW4gV2VydGUgendlaWVyIEVpbmdhYmUtUmFzdGVyIGF1c2dlZsO8aHJ0LlwiLFxuXHRcdGJpdHdpc2VYb3JOYW1lOiBcIkJpdHdpc2UgWG9yXCIsXG5cdFx0Yml0d2lzZVhvclNuaXA6IFwiRsO8aHJ0IGVpbmUgYml0d2Vpc2UgT3BlcmF0aW9uIG1pdCBhdXNzY2hsaWXDn2VuZGVtIE9SIGbDvHIgZGllIGJpbsOkcmVuIFdlcnRlIHZvbiB6d2VpIEVpbmdhYmUtUmFzdGVybiBhdXMuXCIsXG5cdFx0Yml0d2lzZVhvckRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiB3aXJkIGVpbmUgYml0d2Vpc2UgT3BlcmF0aW9uIG1pdCBhdXNzY2hsaWXDn2VuZGVtIE9SIGbDvHIgZGllIGJpbsOkcmVuIFdlcnRlIHp3ZWllciBFaW5nYWJlLVJhc3RlciBhdXNnZWbDvGhydC5cIixcblx0XHRib29sZWFuQW5kTmFtZTogXCJCb29sZWFuIEFuZFwiLFxuXHRcdGJvb2xlYW5BbmRTbmlwOiBcIkbDvGhydCBlaW5lIFxcXCJCb29sZWFuIEFuZFxcXCItT3BlcmF0aW9uIGbDvHIgZGllIFplbGxlbndlcnRlIHZvbiB6d2VpIEVpbmdhYmUtUmFzdGVybiBkdXJjaC4gV2VubiBiZWlkZSBFaW5nYWJld2VydGUgVFJVRSAodW5nbGVpY2ggMCkgc2luZCwgbGF1dGV0IGRlciBBdXNnYWJld2VydCAxLiBXZW5uIGVpbmUgb2RlciBiZWlkZSBFaW5nYWJlbiBGQUxTRSAoMCkgc2luZCwgbGF1dGV0IGRlciBBdXNnYWJld2VydCAwLlwiLFxuXHRcdGJvb2xlYW5BbmREZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2lyZCBlaW5lIGJvb2xlc2NoZSBBTkQtT3BlcmF0aW9uIGbDvHIgZGllIFBpeGVsd2VydGUgendlaWVyIEVpbmdhYmVuIGF1c2dlZsO8aHJ0LiBXZW5uIGJlaWRlIEVpbmdhYmV3ZXJ0ZSBUUlVFICh1bmdsZWljaCAwKSBzaW5kLCBsYXV0ZXQgZGVyIEF1c2dhYmV3ZXJ0IDEuIFdlbm4gZWluZSBvZGVyIGJlaWRlIEVpbmdhYmV3ZXJ0ZSBGQUxTRSAoMCkgc2luZCwgaXN0IGRlciBBdXNnYWJld2VydCAwLiBcIixcblx0XHRib29sZWFuTm90TmFtZTogXCJCb29sZWFuIE5vdFwiLFxuXHRcdGJvb2xlYW5Ob3RTbmlwOiBcIkbDvGhydCBlaW5lIFxcXCJCb29sZWFuIE5vdFxcXCItT3BlcmF0aW9uIChLb21wbGVtZW50b3BlcmF0aW9uKSBmw7xyIGRpZSBaZWxsZW53ZXJ0ZSBkZXMgRWluZ2FiZS1SYXN0ZXJzIGR1cmNoLiBXZW5uIGRpZSBFaW5nYWJld2VydGUgVFJVRSAodW5nbGVpY2ggMCkgc2luZCwgbGF1dGV0IGRlciBBdXNnYWJld2VydCAxLiBXZW5uIGRpZSBFaW5nYWJld2VydGUgRkFMU0UgKDApIHNpbmQsIGxhdXRldCBkaWUgQXVzZ2FiZSAxLlwiLFxuXHRcdGJvb2xlYW5Ob3REZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2lyZCBlaW5lIGJvb2xlc2NoZSBOT1QtT3BlcmF0aW9uIChLb21wbGVtZW50KSBmw7xyIGRpZSBQaXhlbHdlcnRlIGRlcyBFaW5nYWJlLVJhc3RlcnMgYXVzZ2Vmw7xocnQuIFdlbm4gZGllIEVpbmdhYmV3ZXJ0ZSBUUlVFICh1bmdsZWljaCAwKSBzaW5kLCBsYXV0ZXQgZGVyIEF1c2dhYmV3ZXJ0IDAuIFdlbm4gZGllIEVpbmdhYmV3ZXJ0ZSBGQUxTRSAoMCkgc2luZCwgbGF1dGV0IGRlciBBdXNnYWJld2VydCAxLlwiLFxuXHRcdGJvb2xlYW5Pck5hbWU6IFwiQm9vbGVhbiBPclwiLFxuXHRcdGJvb2xlYW5PclNuaXA6IFwiRsO8aHJ0IGVpbmUgYm9vbGVzY2hlIE9SLU9wZXJhdGlvbiBmw7xyIGRpZSBaZWxsZW53ZXJ0ZSB6d2VpZXIgRWluZ2FiZS1SYXN0ZXIgYXVzLiBXZW5uIGVpbmVyIG9kZXIgYmVpZGUgRWluZ2FiZXdlcnRlIFRSVUUgKHVuZ2xlaWNoIDApIHNpbmQsIGxhdXRldCBkZXIgQXVzZ2FiZXdlcnQgMS4gV2VubiBiZWlkZSBFaW5nYWJld2VydGUgRkFMU0UgKDApIHNpbmQsIGxhdXRldCBkZXIgQXVzZ2FiZXdlcnQgMC5cIixcblx0XHRib29sZWFuT3JEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2lyZCBlaW5lIGJvb2xlc2NoZSBPUi1PcGVyYXRpb24gZsO8ciBkaWUgWmVsbGVud2VydGUgendlaWVyIEVpbmdhYmUtUmFzdGVyIGF1c2dlZsO8aHJ0LiBXZW5uIGVpbmVyIG9kZXIgYmVpZGUgVFJVRSAodW5nbGVpY2ggMCkgc2luZCwgbGF1dGV0IGRlciBBdXNnYWJld2VydCAxLiBXZW5uIGJlaWRlIEVpbmdhYmV3ZXJ0ZSBGQUxTRSAoMCkgc2luZCwgbGF1dGV0IGRlciBBdXNnYWJld2VydCAwLlwiLFxuXHRcdGJvb2xlYW5Yb3JOYW1lOiBcIkJvb2xlYW4gWE9yXCIsXG5cdFx0Ym9vbGVhblhvclNuaXA6IFwiRsO8aHJ0IGVpbmUgT3BlcmF0aW9uIG1pdCBcXFwiQm9vbGVhbiBlWGNsdXNpdmUgT3JcXFwiIGbDvHIgZGllIFplbGxlbndlcnRlIHZvbiB6d2VpIEVpbmdhYmUtUmFzdGVybiBhdXMuIFdlbm4gZWluIEVpbmdhYmV3ZXJ0IFRSVUUgKHVuZ2xlaWNoIDApIHVuZCBkZXIgYW5kZXJlIEZBTFNFICgwKSBpc3QsIGxhdXRldCBkaWUgQXVzZ2FiZSAxLiBXZW5uIGJlaWRlIEVpbmdhYmV3ZXJ0ZSBUUlVFIG9kZXIgYmVpZGUgRkFMU0Ugc2luZCwgbGF1dGV0IGRpZSBBdXNnYWJlIDAuXCIsXG5cdFx0Ym9vbGVhblhvckRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiB3aXJkIGVpbmUgYm9vbGVzY2hlIE9wZXJhdGlvbiBtaXQgYXVzc2NobGllw59lbmRlbSBPUiBmw7xyIGRpZSBiaW7DpHJlbiBXZXJ0ZSB6d2VpZXIgRWluZ2FiZS1SYXN0ZXIgYXVzZ2Vmw7xocnQuIFdlbm4gZWluIEVpbmdhYmV3ZXJ0IFRSVUUgKHVuZ2xlaWNoIDApIHVuZCBkZXIgYW5kZXJlIEVpbmdhYmV3ZXJ0IEZBTFNFICgwKSBpc3QsIGxhdXRldCBkZXIgQXVzZ2FiZXdlcnQgMS4gV2VubiBiZWlkZSBFaW5nYWJld2VydGUgVFJVRSBvZGVyIGJlaWRlIEZBTFNFIHNpbmQsIGxhdXRldCBkZXIgQXVzZ2FiZXdlcnQgMC5cIixcblx0XHRidWZmZXJlZFJhc3Rlck5hbWU6IFwiWndpc2NoZW5zcGVpY2hlcm5cIixcblx0XHRidWZmZXJlZFJhc3RlclNuaXA6IFwiRGllIHp1bGV0enQgYXVmZ2VydWZlbmVuIFBpeGVsYmzDtmNrZSB6d2lzY2hlbnNwZWljaGVybi5cIixcblx0XHRidWZmZXJlZFJhc3RlckRlc2M6IFwiRGllIEZ1bmt0aW9uIFxcXCJad2lzY2hlbnNwZWljaGVyblxcXCIgZGllbnQgenVyIE9wdGltaWVydW5nIGRlciBQZXJmb3JtYW5jZSBrb21wbGV4ZXIgRnVua3Rpb25za2V0dGVuLiBTaWUgc3BlaWNoZXJ0IGRpZSBBdXNnYWJlbiBpbSBTcGVpY2hlciBkZXMgVGVpbHMgZGVyIEZ1bmt0aW9uc2tldHRlLCBkZXIgaWhyIHZvcmFuZ2VzdGVsbHQgaXN0LiA8ZGl2Pjxici8+RsO8Z2VuIFNpZSBkaWVzZSBGdW5rdGlvbiBpbSBGdW5rdGlvbnMtRWRpdG9yIGFuIGRlciBTdGVsbGUgZWluLCBhbiBkZXIgZGllIEF1c2dhYmUgZ2VzcGVpY2hlcnQgd2VyZGVuIHNvbGwuPC9kaXY+XCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvck5hbWU6IFwiQmVyZWNobnVuZ1wiLFxuXHRcdHJhc3RlckNhbGN1bGF0b3JTbmlwOiBcIkVpbiBSYXN0ZXIgw7xiZXIgZWluZW4gUmFzdGVyLWJhc2llcnRlbiBtYXRoZW1hdGlzY2hlbiBBdXNkcnVjayBiZXJlY2huZW4uXCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvckRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiQmVyZWNobnVuZ1xcXCIga8O2bm5lbiBTaWUgQXVzZHLDvGNrZSBlcnN0ZWxsZW4gdW5kIGRpZXNlIGluIEZ1bmt0aW9uc2tldHRlbiBpbnRlZ3JpZXJlbi5cIixcblx0XHRjZWxsU3RhdGlzdGljc05hbWU6IFwiWmVsbGVuc3RhdGlzdGlrZW5cIixcblx0XHRjZWxsU3RhdGlzdGljc1NuaXA6IFwiQmVyZWNobmV0IGVpbmUgUHJvLVplbGxlbi1TdGF0aXN0aWsgZsO8ciBtZWhyZXJlIFJhc3Rlci4gRGllIHZlcmbDvGdiYXJlbiBTdGF0aXN0aWtlbiBzaW5kOiBcXFwiTWVocmhlaXRcXFwiLCBcXFwiTWF4aW11bVxcXCIsIFxcXCJNaXR0ZWx3ZXJ0XFxcIiwgXFxcIk1lZGlhbndlcnRcXFwiLCBcXFwiTWluaW11bVxcXCIsIFxcXCJNaW5kZXJoZWl0XFxcIiwgXFxcIlBlcnplbnRpbFxcXCIsIFxcXCJCZXJlaWNoXFxcIiwgXFxcIlN0YW5kYXJkYWJ3ZWljaHVuZ1xcXCIsIFxcXCJTdW1tZVxcXCIgdW5kIFxcXCJWYXJpYW56XFxcIi5cIixcblx0XHRjZWxsU3RhdGlzdGljc0Rlc2M6IFwiTWl0IGRpZXNlciBGdW5rdGlvbiB3ZXJkZW4gU3RhdGlzdGlrZW4gYXVzIG1laHJlcmVuIFJhc3Rlcm4gYXVmIFBpeGVsYmFzaXMgYmVyZWNobmV0LiBEaWUgdmVyZsO8Z2JhcmVuIFN0YXRpc3Rpa2VuIHNpbmQ6IFxcXCJNZWhyaGVpdFxcXCIsIFxcXCJNYXhpbXVtXFxcIiwgXFxcIk1pdHRlbHdlcnRcXFwiLCBcXFwiTWVkaWFud2VydFxcXCIsIFxcXCJNaW5pbXVtXFxcIiwgXFxcIk1pbmRlcmhlaXRcXFwiLCBcXFwiQmVyZWljaFxcXCIsIFxcXCJTdGFuZGFyZGFid2VpY2h1bmdcXFwiLCBcXFwiU3VtbWVcXFwiIHVuZCBcXFwiVmFyaWFuelxcXCIuXCIsXG5cdFx0Y2xhc3NpZnlOYW1lOiBcIktsYXNzaWZpemllcmVuXCIsXG5cdFx0Y2xhc3NpZnlTbmlwOiBcIldlaXN0IGplZGVzIFBpeGVsIGVpbmVyIEtsYXNzZSB6dS4gRXMgd2VyZGVuIFp1c2F0emRhdGVuIHdpZSB6LiBCLiBzZWdtZW50aWVydGUgQmlsZGVyIGVpbmJlem9nZW4uXCIsXG5cdFx0Y2xhc3NpZnlEZXNjOiBcIkRpZXNlIFJhc3Rlci1GdW5rdGlvbiBrbGFzc2lmaXppZXJ0IGVpbiBSYXN0ZXItRGF0YXNldCBiYXNpZXJlbmQgYXVmIGVpbmVyIEVzcmkgQ2xhc3NpZmllciBEZWZpbml0aW9uLURhdGVpICguZWNkKSB1bmQgUmFzdGVyLURhdGFzZXQtRWluZ2FiZW4uIERpZSBpbiBkZXIgRnVua3Rpb24gXFxcIktsYXNzaWZpemllcmVuXFxcIiB2ZXJ3ZW5kZXRlIEVDRC1EYXRlaSBlbnRow6RsdCBhbGxlIEluZm9ybWF0aW9uZW4gZsO8ciBlaW4gYmVzdGltbXRlcyBEYXRhc2V0IHVuZCBlaW5lbiBiZXN0aW1tdGVuIEtsYXNzaWZpa2F0b3IuIFNpZSB3aXJkIGR1cmNoIGRpZSBUcmFpbmluZ3N3ZXJremV1Z2UgZsO8ciBLbGFzc2lmaXppZXJ1bmdlbiwgei4gQi4gZGFzIFdlcmt6ZXVnIFxcXCJTdXBwb3J0IFZlY3RvciBNYWNoaW5lLUtsYXNzaWZpa2F0b3IgdHJhaW5pZXJlblxcXCIgb2RlciBcXFwiUmFuZG9tIFRyZWVzLUtsYXNzaWZpa2F0b3IgdHJhaW5pZXJlblxcXCIsIGVyc3RlbGx0LlwiLFxuXHRcdGNsaXBOYW1lOiBcIkF1c3NjaG5laWRlblwiLFxuXHRcdGNsaXBTbmlwOiBcIkRpZSBBdXNkZWhudW5nIGVpbmVzIFJhc3RlcnMgYW5oYW5kIHZvbiBLb29yZGluYXRlbiBvZGVyIGFuaGFuZCBlaW5lcyBhbmRlcmVuIERhdGFzZXRzIGZlc3RsZWdlbi5cIixcblx0XHRjbGlwRGVzYzogXCJEaWVzZSBGdW5rdGlvbiBzY2huZWlkZXQgZWluIFJhc3RlciBlbnRzcHJlY2hlbmQgZGVuIGRlZmluaWVydGVuIEF1c2RlaG51bmdlbiBtaXQgZWluZXIgcmVjaHRlY2tpZ2VuIEZvcm0gYXVzIG9kZXIgc2NobmVpZGV0IGVpbiBSYXN0ZXIgYXVmIGRpZSBGb3JtIGRlciBGZWF0dXJlLUNsYXNzIGVpbmVzIEVpbmdhYmUtUG9seWdvbnMgenUuIERhcyBTaGFwZSB6dW0gRGVmaW5pZXJlbiBkZXMgQXVzc2Nobml0dHMga2FubiBkaWUgQXVzZGVobnVuZyBkZXMgUmFzdGVycyBvZGVyIGVpbmUgRmzDpGNoZSBpbm5lcmhhbGIgZGVzIFJhc3RlcnMgYXVzc2NobmVpZGVuLlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uTmFtZTogXCJGYXJibW9kZWxsa29udmVydGllcnVuZ1wiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uU25pcDogXCJFaW4gUmFzdGVyIHZvbiBSR0IgaW4gSFNWIGtvbnZlcnRpZXJlbiB1bmQgdW1nZWtlaHJ0LlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIkZhcmJtb2RlbGxrb252ZXJ0aWVydW5nXFxcIiBrb252ZXJ0aWVydCBkYXMgRmFyYm1vZGVsbCBlaW5lcyBCaWxkZXMgdm9tIEhTVi1GYXJicmF1bSAoSHVlLCBTYXR1cmF0aW9uLCBWYWx1ZSA9IEZhcmJ0b24sIFPDpHR0aWd1bmcsIEhlbGxpZ2tlaXRzd2VydCkgaW4gUkdCIChSb3QsIEdyw7xuLCBCbGF1KSBvZGVyIHVtZ2VrZWhydC48ZGl2Pjxici8+RGllc2UgRnVua3Rpb24ga2FubiBpbiBlaW5lbSBNb3NhaWstRGF0YXNldCB2ZXJ3ZW5kZXQgd2VyZGVuLjwvZGl2PlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JOYW1lOiBcIkNvbG9ybWFwIGluIFJHQlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JTbmlwOiBcIkVpbiBFaW56ZWxiYW5kLVJhc3RlciBtaXQgZWluZXIgQ29sb3JtYXAgaW4gZWluIFJHQi1SYXN0ZXIgKFJvdCwgR3LDvG4gdW5kIEJsYXUpIG1pdCBkcmVpIELDpG5kZXJuIGtvbnZlcnRpZXJlbi5cIixcblx0XHRjb2xvcm1hcFRvUkdCRGVzYzogXCJNaXQgZGllc2VyIEZ1bmt0aW9uIHdpcmQgZWluIEVpbnplbGJhbmQtUmFzdGVyIG1pdCBlaW5lciBDb2xvcm1hcCBpbiBlaW4gUkdCLVJhc3RlciBtaXQgZHJlaSBCw6RuZGVybiAoUm90LCBHcsO8biB1bmQgQmxhdSkga29udmVydGllcnQuPGRpdj48YnIvPkRpZXNlIEZ1bmt0aW9uIGlzdCBuw7x0emxpY2gsIHdlbm4gU2llIGF1cyBlaW5lbSBFaW56ZWxiYW5kLVJhc3RlciBtaXQgdmVya27DvHBmdGVyIENvbG9ybWFwIGVpbiBSYXN0ZXIgYXVzIGRyZWkgQsOkbmRlcm4gZXJzdGVsbGVuIG3DvHNzZW4uIE1pdCBkZW4gV2VydGVuIGluIGRlciBDb2xvcm1hcCB3aXJkIGpld2VpbHMgZGFzIHJvdGUsIGdyw7xuZSB1bmQgYmxhdWUgQmFuZCBlcnN0ZWxsdC4gRGllc2UgRnVua3Rpb24ga2FubiBpbiBlaW5lbSBNb3NhaWstRGF0YXNldCB2ZXJ3ZW5kZXQgd2VyZGVuLjwvZGl2PlwiLFxuXHRcdGNvbG9ybWFwTmFtZTogXCJDb2xvcm1hcFwiLFxuXHRcdGNvbG9ybWFwU25pcDogXCJEaWUgUGl4ZWx3ZXJ0ZSBmw7xyIGRpZSBBbnplaWdlIGRlciBSYXN0ZXItRGF0ZW4gYXVmIGRlciBHcnVuZGxhZ2UgZWluZXIgQ29sb3JtYXAgb2RlciBlaW5lcyBGYXJidmVybGF1ZnMgYWxzIEdyYXVzdHVmZW4tIG9kZXIgUkdCLUJpbGQgKFJvdCwgR3LDvG4sIEJsYXUpIMOkbmRlcm4uXCIsXG5cdFx0Y29sb3JtYXBEZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiQ29sb3JtYXBcXFwiIGlzdCBlaW5lIEFydCBSYXN0ZXItRGF0ZW4tUmVuZGVyZXIuIERhbWl0IHdlcmRlbiBkaWUgUGl4ZWx3ZXJ0ZSB6dXIgQW56ZWlnZSBkZXIgUmFzdGVyLURhdGVuIGF1ZiBkZXIgR3J1bmRsYWdlIGVpbmVzIEZhcmJzY2hlbWFzIG9kZXIgYmVzdGltbXRlciBGYXJiZW4gaW4gZWluZXIgQ29sb3JtYXAtRGF0ZWkgYWxzIEdyYXVzdHVmZW4tIG9kZXIgUkdCLUZhcmJiaWxkIHRyYW5zZm9ybWllcnQuIFNpZSBrw7ZubmVuIGVpbmUgQ29sb3JtYXAgenVyIERhcnN0ZWxsdW5nIGFuYWx5c2llcnRlciBEYXRlbiwgd2llIHouIEIuIGVpbiBrbGFzc2lmaXppZXJ0ZXMgQmlsZCwgb2RlciBiZWltIEFuemVpZ2VuIGVpbmVyIHRvcG9ncmFwaGlzY2hlbiBLYXJ0ZSAob2RlciBlaW5lcyBnZXNjYW5udGVuIGluZGl6aWVydGVuIEZhcmJiaWxkZXMpIHZlcndlbmRlbi48ZGl2Pjxici8+Q29sb3JtYXBzIGVudGhhbHRlbiBlaW5lbiBTYXR6IHZvbiBXZXJ0ZW4sIGRpZSBtaXQgRmFyYmVuIHZlcmtuw7xwZnQgc2luZCwgZGllIHZlcndlbmRldCB3ZXJkZW4sIHVtIGVpbiBFaW56ZWxiYW5kLVJhc3RlciBkdXJjaGfDpG5naWcgbWl0IGRlbiBnbGVpY2hlbiBGYXJiZW4gYW56dXplaWdlbi4gSmVkZXIgUGl4ZWx3ZXJ0IGlzdCBlaW5lciBGYXJiZSB6dWdlb3JkbmV0LCBkaWUgYWxzIEdydXBwZSB2b24gUkdCLVdlcnRlbiBkZWZpbmllcnQgaXN0LiBDb2xvcm1hcHMgdW50ZXJzdMO8dHplbiBzw6RtdGxpY2hlIEJpdHRpZWZlbiBhdcOfZXIgR2xlaXRrb21tYS4gWnVkZW0gdW50ZXJzdMO8dHplbiBzaWUgcG9zaXRpdmUgdW5kIG5lZ2F0aXZlIFdlcnRlOyBlcyBrw7ZubmVuIGF1Y2ggQ29sb3JtYXB3ZXJ0ZSBmZWhsZW4uIEJlaSBkZXIgQW56ZWlnZSBlaW5lcyBEYXRhc2V0cyBtaXQgZWluZXIgS2FydGUsIGluIGRlciBXZXJ0ZSBmZWhsZW4sIHdlcmRlbiBkaWUgUGl4ZWwgbWl0IGRlbiBmZWhsZW5kZW4gV2VydGVuIG5pY2h0IGFuZ2V6ZWlndC48L2Rpdj5cIixcblx0XHRjb21wbGV4TmFtZTogXCJLb21wbGV4XCIsXG5cdFx0Y29tcGxleFNuaXA6IFwiRGllIEdyw7bDn2Uga29tcGxleGVyIFphaGxlbiBleHRyYWhpZXJlbi5cIixcblx0XHRjb21wbGV4RGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIHdpcmQgZGllIEdyw7bDn2Uga29tcGxleGVyIFdlcnRlIGJlcmVjaG5ldC48ZGl2Pjxici8+RGllc2UgRnVua3Rpb24gd2lyZCBub3JtYWxlcndlaXNlIGJlaSBSQURBUi1CaWxkZGF0ZW4gZWluZXMga29tcGxleGVuIERhdGVudHlwcyBlaW5nZXNldHp0LiBTaWUga2FubiBpbiBlaW5lbSBNb3NhaWstRGF0YXNldCB2ZXJ3ZW5kZXQgd2VyZGVuLjwvZGl2PlwiLFxuXHRcdGNvbXBvc2l0ZUJhbmROYW1lOiBcIkLDpG5kZXIgenVzYW1tZW5zZXR6ZW5cIixcblx0XHRjb21wb3NpdGVCYW5kU25pcDogXCJLb21iaW5pZXJ0IG1laHJlcmUgRGF0YXNldHMgenUgZWluZW0gTXVsdGliYW5kLVJhc3Rlci5cIixcblx0XHRjb21wb3NpdGVCYW5kRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJCw6RuZGVyIHp1c2FtbWVuc2V0emVuXFxcIiBrw7ZubmVuIFNpZSBSYXN0ZXIga29tYmluaWVyZW4sIHNvZGFzcyBzaWUgZWluIE11bHRpYmFuZC1SYXN0ZXIgYmlsZGVuLlwiLFxuXHRcdGNvbk5hbWU6IFwiSWYtRWxzZS1CZWRpbmd1bmdlblwiLFxuXHRcdGNvblNuaXA6IFwiRsO8aHJ0IGVpbmUga29uZGl0aW9uYWxlIElmLVRoZW4tRWxzZS1PcGVyYXRpb24gZHVyY2guIEJlaSBkZXIgVmVyd2VuZHVuZyBlaW5lciBJZi1FbHNlLUJlZGluZ3VuZyBtw7xzc2VuIMO8YmxpY2hlcndlaXNlIG1pbmRlc3RlbnMgendlaSBGdW5rdGlvbmVuIG1pdGVpbmFuZGVyIHZlcmtuw7xwZnQgd2VyZGVuLCB3b2JlaSBpbiBkZXIgZWluZW4gRnVua3Rpb24gZGllIEtyaXRlcmllbiB1bmQgaW4gZGVyIHp3ZWl0ZW4gRnVua3Rpb24gZGllIElmLUVsc2UtQmVkaW5ndW5nIHVudGVyIFZlcndlbmR1bmcgZGVyIEtyaXRlcmllbiBhbmdlZ2ViZW4gd2lyZC4gTGV0enRlcmUgc2NocmVpYnQgZGllIFxcXCJUcnVlXFxcIi0gdW5kIFxcXCJGYWxzZVxcXCItQXVzZ2FiZW4gdm9yLlwiLFxuXHRcdGNvbkRlc2M6IFwiRHVyY2ggZGllIEZ1bmt0aW9uIFxcXCJJZi1FbHNlLUJlZGluZ3VuZ2VuXFxcIiB3ZXJkZW4gZGllIFBpeGVsIGRlcyBBdXNnYWJlLVJhc3RlcnMgYXVmIEdydW5kbGFnZSBkZXIgSWYtRWxzZS1BdXN3ZXJ0dW5nIGRlciBlaW56ZWxuZW4gRWluZ2FiZXBpeGVsIGZlc3RnZWxlZ3QuIFNpZSBnaWJ0IGRpZSBQaXhlbHdlcnRlIGF1cyBkZW0gVHJ1ZS1SYXN0ZXIgenVyw7xjaywgd2VubiBkaWUgQmVkaW5ndW5nc2F1c3dlcnR1bmcgXFxcInRydWVcXFwiICgxKSBlcmdpYnQsIHVuZCBkaWUgUGl4ZWx3ZXJ0ZSBhdXMgZGVtIEZhbHNlLVJhc3Rlciwgd2VubiBkaWUgQmVkaW5ndW5nc2F1c3dlcnR1bmcgXFxcImZhbHNlXFxcIiAoMCkgbGF1dGV0LiBEaWVzZXMgS3JpdGVyaXVtIHdpcmQgZHVyY2ggZGllIEF1c2dhYmUgZWluZXIgbG9naXNjaGVuIG1hdGhlbWF0aXNjaGVuIEZ1bmt0aW9uIGZlc3RnZWxlZ3QsIGRpZSBkZW0gRWluZ2FiZS1SYXN0ZXIgZW50c3ByaWNodC5cIixcblx0XHRjb25zdGFudE5hbWU6IFwiS29uc3RhbnRlXCIsXG5cdFx0Y29uc3RhbnRTbmlwOiBcIkVpbiB2aXJ0dWVsbGVzIFJhc3RlciBtaXQgZWluZW0gZWluemVsbmVuIFBpeGVsd2VydCBlcnN0ZWxsZW4uXCIsXG5cdFx0Y29uc3RhbnREZXNjOiBcIk1pdCBkaWVzZXIgRnVua3Rpb24gd2lyZCBlaW4gdmlydHVlbGxlcyBSYXN0ZXIgbWl0IGVpbmVtIGVpbnplbG5lbiBQaXhlbHdlcnQgZXJzdGVsbHQsIGRhcyBpbiBSYXN0ZXItRnVua3Rpb25zdm9ybGFnZW4gdW5kIHp1bSBWZXJhcmJlaXRlbiBlaW5lcyBNb3NhaWstRGF0YXNldHMgdmVyd2VuZGV0IHdlcmRlbiBrYW5uLjxkaXY+PGJyLz5EZXIga29uc3RhbnRlIFdlcnQgd2lyZCBmw7xyIGFsbGUgUGl4ZWx3ZXJ0ZSBpbSBSYXN0ZXIgdmVyd2VuZGV0LjwvZGl2PlwiLFxuXHRcdGNvbnRvdXJOYW1lOiBcIktvbnR1cmxpbmllXCIsXG5cdFx0Y29udG91clNuaXA6IFwiS29udHVybGluaWVuIGVyc3RlbGxlbi5cIixcblx0XHRjb250b3VyRGVzYzogXCJNaXQgZGVyIEtvbnR1cmxpbmllbmZ1bmt0aW9uIHdlcmRlbiBLb250dXJsaW5pZW4gZXJzdGVsbHQsIGluZGVtIFB1bmt0ZSBtaXQgZGVyc2VsYmVuIEjDtmhlIGF1cyBlaW5lbSBSYXN0ZXItSMO2aGVuLURhdGFzZXQgdmVyYnVuZGVuIHdlcmRlbi4gRGllIEtvbnR1cmxpbmllbiBzaW5kIElzb2xpbmllbiwgZGllIHp1bSBWaXN1YWxpc2llcmVuIGFscyBSYXN0ZXIgZXJzdGVsbHQgd2VyZGVuLiBEaWUgTGVpc3R1bmdzZsOkaGlna2VpdCBkaWVzZXIgRnVua3Rpb24gZ3LDvG5kZXQgYXVmIGRlbiBmb2xnZW5kZW4gemVudHJhbGVuIEFzcGVrdGVuOiBLb250dXJsaW5pZW4gd2VyZGVuIGbDvHIgZ3Jvw59lIERhdGFzZXRzIHdpZSBXb3JsZCBFbGV2YXRpb24gc2NobmVsbCB1bmQgZHluYW1pc2NoIGVyc3RlbGx0OyBLb250dXJsaW5pZW4ga8O2bm5lbiBnZWdsw6R0dGV0IHdlcmRlbiwgdW0gZWluIGthcnRvZ3JhZmlzY2ggYW5zcHJlY2hlbmRlcmVzIEF1c3NlaGVuIHVudGVyIEJlaWJlaGFsdHVuZyBkZXIgR2VuYXVpZ2tlaXQgZGVyIEtvbnR1cmxpbmllbiB6dSBlcnppZWxlbjsgZHluYW1pc2NoZSBLb250cm9sbGUgw7xiZXIgZGFzIGJlcmVpdGdlc3RlbGx0ZSBLb250dXJsaW5pZW5pbnRlcnZhbGw7IG3DtmdsaWNoZSBBdXNnYWJlbiBzaW5kIEtvbnR1cmxpbmllbiwgSW5kZXhrb250dXJsaW5pZW4gdW5kIGdlZsO8bGx0ZSBLb250dXJsaW5pZW4uPGRpdj48YnIvPkRpZSBFcnN0ZWxsdW5nIGVpbmVzIEtvbnR1cmxpbmllbi1MYXllcnMgYWxzIFJhc3Rlci1Qcm9kdWt0IGlzdCBmw7xyIGVpbmUgYnJlaXRlIFBhbGV0dGUgdm9uIEFud2VuZHVuZ2VuIHdlcnR2b2xsLCBkYSBkaWUgS29udHVybGluaWVuIGF1ZiBlaW5lciBLYXJ0ZSDDvGJlcmxhZ2VydCB3ZXJkZW4ga8O2bm5lbiB1bmQgdmllbGUgSW5mb3JtYXRpb25lbiB6dW0gVGVycmFpbiBiZXJlaXRzdGVsbGVuLCBvaG5lIGRpZSB6dWdydW5kZSBsaWVnZW5kZW4gRGF0ZW4genUgdmVyZGVja2VuLiBTaWUgc2luZCBoaWxmcmVpY2ggYmVpIEFud2VuZHVuZ2VuIHdpZSBFbnR3aWNrbHVuZywgTGFuZHdpcnRzY2hhZnQgdW5kIFdhc3NlcmJld2lydHNjaGFmdHVuZy48L2Rpdj5cIixcblx0XHRjb250cmFzdEJyaWdodG5lc3NOYW1lOiBcIktvbnRyYXN0IHVuZCBIZWxsaWdrZWl0XCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzU25pcDogXCJEZW4gS29udHJhc3QgdW5kIGRpZSBIZWxsaWdrZWl0IGVpbmVzIFJhc3RlcnMgYW5wYXNzZW4uXCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJLb250cmFzdCB1bmQgSGVsbGlna2VpdFxcXCIga2FubiBkYXMgQXVzc2VoZW4gdm9uIFJhc3Rlci1EYXRlbiBkdXJjaCDDhG5kZXJ1bmcgdm9uIEhlbGxpZ2tlaXQgdW5kL29kZXIgS29udHJhc3QgaW0gQmlsZCB2ZXJiZXNzZXJ0IHdlcmRlbi4gRHVyY2ggSGVsbGlna2VpdCB3aXJkIGRpZSBHZXNhbXRoZWxsaWdrZWl0IGRlcyBCaWxkZXMgZXJow7ZodCAoZHVua2xlIEZhcmJlbiB3ZXJkZW4gYXVmZ2VoZWxsdCwgaGVsbGUgRmFyYmVuIHdlcmRlbiB3ZWnDn2VyKSB1bmQgbWl0IEtvbnRyYXN0IHdpcmQgZGVyIFVudGVyc2NoaWVkIHp3aXNjaGVuIGRlbiBkdW5rZWxzdGVuIHVuZCBoZWxsc3RlbiBGYXJiZW4gZWluZ2VzdGVsbHQuPGRpdj48YnIvPk1pdCBkaWVzZXIgRnVua3Rpb24gd2VyZGVuIGRpZSBQaXhlbHdlcnRlIGdlw6RuZGVydC4gRGFoZXIgc29sbHRlIGRpZSBGdW5rdGlvbiB2ZXJ3ZW5kZXQgd2VyZGVuLCB3ZW5uIFNpZSBkYXMgQXVzc2VoZW4gZGVyIERhdGVuIHZlcmJlc3Nlcm4sIGRpZXNlIGplZG9jaCBuaWNodCBpbiBBbmFseXNlbiB2ZXJ3ZW5kZW4gbcO2Y2h0ZW4sIGbDvHIgZGllIGRpZSB1bmJlYXJiZWl0ZXRlbiBQaXhlbHdlcnRlIGJlbsO2dGlndCB3ZXJkZW4uIERpZXNlIEZ1bmt0aW9uIGlzdCBnZWVpZ25ldCwgd2VubiBTaWUgZGllIERhdGVuIGFscyBJbWFnZS1TZXJ2aWNlIHZlcsO2ZmZlbnRsaWNoZW4sIGRlciBpbiBBbndlbmR1bmdlbiBvaG5lIEZ1bmt0aW9uIHp1bSDDhG5kZXJuIHZvbiBLb250cmFzdCB1bmQgSGVsbGlna2VpdCBkZXIgQmlsZGVyIHZlcndlbmRldCB3ZXJkZW4ga2Fubiwgb2RlciB1bSBzaWNoZXJ6dXN0ZWxsZW4sIGRhc3MgZGllIEFuemVpZ2UgdGF0c8OkY2hsaWNoIG1pdCBkZW4gYmV2b3J6dWd0ZW4gRWluc3RlbGx1bmdlbiBlcmZvbGd0LjwvZGl2PlwiLFxuXHRcdGNvbnZvbHV0aW9uTmFtZTogXCJGYWx0dW5nXCIsXG5cdFx0Y29udm9sdXRpb25TbmlwOiBcIkVpbmVuIEZpbHRlciB6dW0gU2Now6RyZmVuLCBXZWljaHplaWNobmVuLCBFcmtlbm5lbiB2b24gS2FudGVuIG9kZXIgR2zDpHR0ZW4gYnp3LiBlaW5lbiBHcmFkaWVudCBpbiBlaW5lbSBSYXN0ZXIgYW53ZW5kZW4uXCIsXG5cdFx0Y29udm9sdXRpb25EZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiRmFsdHVuZ1xcXCIgZsO8aHJ0IGRpZSBGaWx0ZXJ1bmcgZGVyIFBpeGVsd2VydGUgaW4gZWluZW0gQmlsZCBhdXMsIHouIEIuIGbDvHIgZGFzIFNjaGFyZi0gb2RlciBXZWljaHplaWNobmVuIGVpbmVzIEJpbGRlcywgZsO8ciBkYXMgRXJtaXR0ZWxuIGRlciBLYW50ZW4gaW4gZWluZW0gQmlsZCBvZGVyIGbDvHIgYW5kZXJlIEtlcm5lbC1iYXNpZXJ0ZSBWZXJiZXNzZXJ1bmdlbi4gRmlsdGVyIHdlcmRlbiB2ZXJ3ZW5kZXQsIHVtIGRpZSBRdWFsaXTDpHQgZWluZXMgUmFzdGVyLUJpbGRzIGR1cmNoIGRhcyBFbnRmZXJuZW4gdm9uIHVua29ycmVrdGVuIERhdGVuIG9kZXIgZHVyY2ggZGllIEVyd2VpdGVydW5nIHZvbiBGZWF0dXJlcyBpbiBkZW4gRGF0ZW4genUgdmVyYmVzc2VybiBEaWVzZSBGYWx0dW5nc2ZpbHRlciB3ZXJkZW4gYXVmIGVpbmVuIGJld2VndGVuLCDDvGJlcmxhcHBlbmRlbiBLZXJuZWwgKEZlbnN0ZXIgb2RlciBOYWNoYmFyc2NoYWZ0KSBhbmdld2VuZGV0ICh6LiBCLiAzIHggMykuIERpZSBGdW5rdGlvbiBcXFwiRmFsdHVuZ1xcXCIgZmlsdGVydCBJaHJlIEFyYmVpdCBkdXJjaCBlaW5lIEJlcmVjaG51bmcgZGVzIFBpeGVsd2VydGVzIGF1ZiBHcnVuZGxhZ2UgZGVyIEdld2ljaHR1bmcgc2VpbmVyIE5hY2hiYXJuLi5cIixcblx0XHRjb3JyaWRvck5hbWU6IFwiS29ycmlkb3JcIixcblx0XHRjb3JyaWRvclNuaXA6IFwiQmVyZWNobmV0IGRpZSBTdW1tZSBkZXIgYWtrdW11bGF0aXZlbiBLb3N0ZW4gZsO8ciB6d2VpIGFra3VtdWxhdGl2ZSBFaW5nYWJlLVJhc3Rlci5cIixcblx0XHRjb3JyaWRvckRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiS29ycmlkb3JcXFwiIHdpcmQgZGllIFN1bW1lIGRlciBha2t1bXVsYXRpdmVuIEtvc3RlbiBmw7xyIHp3ZWkgRWluZ2FiZS1SYXN0ZXIgbWl0IGFra3VtdWxhdGl2ZW4gS29zdGVuIGJlcmVjaG5ldC4gRXMga8O2bm5lbiB6d2FyIHp3ZWkgYmVsaWViaWdlIFJhc3RlciBmw7xyIGRpZSBFaW5nYWJlIHZlcndlbmRldCB3ZXJkZW47IHVtIGVpbiBzaW5udm9sbGVzIEVyZ2VibmlzIHp1IGVyaGFsdGVuLCBzb2xsdGUgZXMgc2ljaCBkYWJlaSBqZWRvY2ggdW0gdW52ZXLDpG5kZXJ0ZSBha2t1bXVsYXRpdmUgS29zdGVuLUF1c2dhYmUtUmFzdGVyIGhhbmRlbG4uIERpZSBSZWloZW5mb2xnZSBkZXIgYmVpZGVuIEVpbmdhYmVuIGlzdCBpcnJlbGV2YW50LlwiLFxuXHRcdGNvc0hOYW1lOiBcIkNvc0hcIixcblx0XHRjb3NIU25pcDogXCJEZW4gS29zaW51cyBIeXBlcmJvbGljdXMgdm9uIFplbGxlbiBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmVuLlwiLFxuXHRcdGNvc0hEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2lyZCBkZXIgS29zaW51cyBIeXBlcmJvbGljdXMgZGVyIFBpeGVsIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZXQuXCIsXG5cdFx0Y29zTmFtZTogXCJDb3NcIixcblx0XHRjb3NTbmlwOiBcIkJlcmVjaG5ldCBkZW4gS29zaW51cyBlaW5lciBaZWxsZSBpbiBlaW5lbSBSYXN0ZXIuXCIsXG5cdFx0Y29zRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIHdpcmQgZGVyIEtvc2ludXMgZGVyIFBpeGVsIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZXQuXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25OYW1lOiBcIktvc3Rlbnp1b3JkbnVuZ1wiLFxuXHRcdGNvc3RBbGxvY2F0aW9uU25pcDogXCJCZXJlY2huZXQgZsO8ciBqZWRlIFplbGxlIGRpZSBrb3N0ZW5nw7xuc3RpZ3N0ZSBRdWVsbGUgYmFzaWVyZW5kIGF1ZiBkZW4ga2xlaW5zdGVuIGFra3VtdWxhdGl2ZW4gS29zdGVuIGF1ZiBlaW5lciBLb3N0ZW5vYmVyZmzDpGNoZS5cIixcblx0XHRjb3N0QWxsb2NhdGlvbkRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiS29zdGVuenV3ZWlzdW5nXFxcIiB3aXJkIGbDvHIgamVkZSBaZWxsZSBkaWUga29zdGVuZ8O8bnN0aWdzdGUgUXVlbGxlIGF1ZiBCYXNpcyBkZXIgZ2VyaW5nc3RlbiBha2t1bXVsYXRpdmVuIEtvc3RlbiBhdWYgZWluZXIgS29zdGVub2JlcmZsw6RjaGUgYmVyZWNobmV0LlwiLFxuXHRcdGNvc3RCYWNrTGlua05hbWU6IFwiS29zdGVucsO8Y2t2ZXJrbsO8cGZ1bmdcIixcblx0XHRjb3N0QmFja0xpbmtTbmlwOiBcIkRlZmluaWVydCBkaWUgbsOkY2hzdGUgTmFjaGJhcnplbGxlIGF1ZiBkZW0ga2xlaW5zdGVuIGFra3VtdWxhdGl2ZW4gS29zdGVucGZhZCB6dXIga29zdGVuZ8O8bnN0aWdzdGVuIFF1ZWxsZS5cIixcblx0XHRjb3N0QmFja0xpbmtEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIktvc3RlbnLDvGNrdmVya27DvHBmdW5nXFxcIiB3aXJkIGRpZSBuw6RjaHN0ZSBOYWNoYmFyemVsbGUgYXVmIGRlbSBQZmFkIG1pdCBkZW4gZ2VyaW5nc3RlbiBha2t1bXVsYXRpdmVuIEtvc3RlbiB6dXIga29zdGVuZ8O8bnN0aWdzdGVuIFF1ZWxsZSBkZWZpbmllcnQuPGRpdj48YnIvPkRhcyBSw7xja3Zlcmtuw7xwZnVuZ3MtUmFzdGVyIGVudGjDpGx0IFdlcnRlIHZvbiBudWxsIGJpcyBhY2h0LiBNaXQgZGllc2VuIFdlcnRlbiB3aXJkIGRpZSBSaWNodHVuZyBkZWZpbmllcnQgb2RlciBkaWUgbsOkY2hzdGUgYW5ncmVuemVuZGUgWmVsbGUgKGRpZSBuYWNoZm9sZ2VuZGUgWmVsbGUpIGVudGxhbmcgZGVzIEtvc3RlbnBmYWRzIG1pdCBkZW4gZ2VyaW5nc3RlbiBha2t1bXVsYXRpdmVuIEtvc3RlbiB2b24gZWluZXIgWmVsbGUgenVyIGVudHNwcmVjaGVuZGVuIGtvc3RlbmfDvG5zdGlnc3RlbiBRdWVsbGUgYW5nZWdlYmVuLiBXZW5uIGRlciBQZmFkIGluIGRpZSByZWNodGUgYmVuYWNoYmFydGUgWmVsbGUgw7xiZXJnZWh0LCB3aXJkIGRlciBaZWxsZSBkZXIgV2VydCAxIHp1Z2VvcmRuZXQsIGdlZm9sZ3Qgdm9uIDIgZsO8ciBkaWUgZGlhZ29uYWwgcmVjaHRzIHVudGVuIGFuZ2VvcmRuZXRlIFplbGxlLiBEaWUgZm9sZ2VuZGVuIFplbGxlbiB3ZXJkZW4gaW0gVWhyemVpZ2Vyc2lubiBudW1tZXJpZXJ0LiBEZXIgV2VydCAwIGlzdCBmw7xyIGRpZSBRdWVsbGVuemVsbGVuIHJlc2VydmllcnQuPC9kaXY+XCIsXG5cdFx0Y29zdERpc3RhbmNlTmFtZTogXCJLb3N0ZW5lbnRmZXJudW5nXCIsXG5cdFx0Y29zdERpc3RhbmNlU25pcDogXCJCZXJlY2huZXQgZsO8ciBqZWRlIFplbGxlIGRpZSBrbGVpbnN0ZSBha2t1bXVsYXRpdmUgS29zdGVuZW50ZmVybnVuZyB2b24gb2RlciB6dXIga29zdGVuZ8O8bnN0aWdzdGVuIFF1ZWxsZSBhdWYgZWluZXIgS29zdGVub2JlcmZsw6RjaGUuXCIsXG5cdFx0Y29zdERpc3RhbmNlRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJLb3N0ZW5lbnRmZXJudW5nXFxcIiB3aXJkIGRpZSBrbGVpbnN0ZSBha2t1bXVsYXRpdmUgS29zdGVuZW50ZmVybnVuZyBmw7xyIGplZGUgWmVsbGUgdm9uIG9kZXIgenVyIGtvc3RlbmfDvG5zdGlnc3RlbiBRdWVsbGUgYXVmIGVpbmVyIEtvc3Rlbm9iZXJmbMOkY2hlIGJlcmVjaG5ldC5cIixcblx0XHRjb3N0UGF0aE5hbWU6IFwiS29zdGVucGZhZFwiLFxuXHRcdGNvc3RQYXRoU25pcDogXCJCZXJlY2huZXQgZGVuIGtvc3RlbmfDvG5zdGlnc3RlbiBQZmFkIHZvbiBlaW5lciBRdWVsbGUgenUgZWluZW0gWmllbC5cIixcblx0XHRjb3N0UGF0aERlc2M6IFwiTWl0IGRlciBnbG9iYWxlbiBGdW5rdGlvbiBcXFwiS29zdGVucGZhZFxcXCIgd2lyZCBkZXIga29zdGVuZ8O8bnN0aWdzdGUgUGZhZCB2b24gZWluZXIgUXVlbGxlIHp1IGVpbmVtIFppZWwgYmVyZWNobmV0LjxkaXY+PGJyLz5NaXQgZGllc2VyIEZ1bmt0aW9uIHdpcmQgZWluIEF1c2dhYmUtUmFzdGVyIGVyemV1Z3QsIGRhcyBkZW4vZGllIGtvc3RlbmfDvG5zdGlnc3RlbiBQZmFkKGUpIHZvbiBhdXNnZXfDpGhsdGVuIFBvc2l0aW9uZW4genVyIGpld2VpbHMgbsOkY2hzdGdlbGVnZW5lbiBRdWVsbGVuemVsbGUgYXVmemVpY2huZXQsIGRpZSBpbm5lcmhhbGIgZGVyIGFra3VtdWxhdGl2ZW4gS29zdGVub2JlcmZsw6RjaGUgZGVmaW5pZXJ0IHd1cmRlbiAoaGluc2ljaHRsaWNoIGRlciBLb3N0ZW5lbnRmZXJudW5nKS48L2Rpdj5cIixcblx0XHRjdXJ2YXR1cmVOYW1lOiBcIktyw7xtbXVuZ1wiLFxuXHRcdGN1cnZhdHVyZVNuaXA6IFwiQmVyZWNobmV0IGRpZSBLcsO8bW11bmcgZWluZXIgUmFzdGVyLU9iZXJmbMOkY2hlLCBvcHRpb25hbCBtaXQgVmVydGlrYWwtIHVuZCBIb3Jpem9udGFsa3LDvG1tdW5nLlwiLFxuXHRcdGN1cnZhdHVyZURlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiS3LDvG1tdW5nXFxcIiB3aXJkIGRpZSBGb3JtIG9kZXIgS3LDvG1tdW5nIGRlciBOZWlndW5nIGFuZ2V6ZWlndC4gRWluIFRlaWwgZWluZXIgT2JlcmZsw6RjaGUga2FubiBrb25rYXYgb2RlciBrb252ZXggc2Vpbiwgd2FzIFNpZSBhbSBLcsO8bW11bmdzd2VydCBlcmtlbm5lbi4gRGllIEtyw7xtbXVuZyB3aXJkIGJlcmVjaG5ldCwgaW5kZW0gZGllIHp3ZWl0ZSBBYmxlaXR1bmcgZGVyIE9iZXJmbMOkY2hlIGVybWl0dGVsdCB3aXJkLjxkaXY+PGJyLz5EaWUgQXVzZ2FiZSBkZXIgRnVua3Rpb24gXFxcIktyw7xtbXVuZ1xcXCIgZGllbnQgZGVtIEJlc2NocmVpYmVuIGRlciBwaHlzaXNjaGVuIE1lcmttYWxlIGVpbmVzIFdhc3NlcmVpbnp1Z3NnZWJpZXRzIGJlaSBkZW0gVmVyc3VjaCwgRXJvc2lvbnMtIHVuZCBEcmFpbmFnZXByb3plc3NlIG5hY2h6dXZvbGx6aWVoZW4uIERlciBLcsO8bW11bmdzd2VydCBrYW5uIHZlcndlbmRldCB3ZXJkZW4sIHVtIEJvZGVuZXJvc2lvbnNtdXN0ZXIgenUgZmluZGVuIHVuZCBkaWUgV2Fzc2VydmVydGVpbHVuZyBhdWYgZGVtIExhbmQgenUgZXJtaXR0ZWxuLiBEaWUgVmVydGlrYWxrcsO8bW11bmcgd2lya3Qgc2ljaCBhdWYgZGllIEZsaWXDn2Jlc2NobGV1bmlndW5nIHVuZCAtdmVybGFuZ3NhbXVuZyBhdXMgdW5kIGJlZWluZmx1c3N0IGRhZHVyY2ggRXJvc2lvbiB1bmQgQWJsYWdlcnVuZ2VuLiBEaWUgSG9yaXpvbnRhbGtyw7xtbXVuZyBiZWVpbmZsdXNzdCBkaWUgRmxpZcOfa29udmVyZ2VueiB1bmQgLWRpdmVyZ2Vuei48L2Rpdj5cIixcblx0XHRkaXZpZGVOYW1lOiBcIkRpdmlkZVwiLFxuXHRcdGRpdmlkZVNuaXA6IFwiRGllIFdlcnRlIHZvbiB6d2VpIFJhc3Rlcm4gYXVmIFplbGxlbmJhc2lzIHRlaWxlbi5cIixcblx0XHRkaXZpZGVEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIkRpdmlkZVxcXCIgd2VyZGVuIGRpZSBXZXJ0ZSB6d2VpZXIgUmFzdGVyIGF1ZiBQaXhlbGJhc2lzIGRpdmlkaWVydC5cIixcblx0XHRlbGV2YXRpb25Wb2lkRmlsbE5hbWU6IFwiTMO8Y2tlbmbDvGxsdW5nIGbDvHIgSMO2aGVuXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxTbmlwOiBcIlBpeGVsIGluIEJlcmVpY2hlbiBlcnN0ZWxsZW4sIHdvIGluIElocmVuIEjDtmhlbmRhdGVuIEzDtmNoZXIgdm9yaGFuZGVuIHNpbmQuXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxEZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiTMO8Y2tlbmbDvGxsdW5nIGbDvHIgSMO2aGVuXFxcIiB3aXJkIHZlcndlbmRldCwgdW0gUGl4ZWwgZsO8ciBCZXJlaWNoZSB6dSBlcnN0ZWxsZW4sIHdvIGluIElocmVuIEjDtmhlbmRhdGVuIEzDtmNoZXIgdm9yaGFuZGVuIHNpbmQuPGRpdj48YnIvPkzDvGNrZW4gdHJldGVuIGF1Ziwgd2VubiBlcyBrZWluZSBQdW5rdGUgZ2lidCwgZGllIGF1ZiBkZXIgZHVyY2ggZWluIFBpeGVsIGRhcmdlc3RlbGx0ZW4gRmzDpGNoZSBpbSByZXN1bHRpZXJlbmRlbiBSYXN0ZXIgZXJmYXNzdCB3dXJkZW4uIEzDvGNrZW4gd2VyZGVuIG9mdCB2b24gR2V3w6Rzc2VybiwgS2xhc3NlbnR5cGF1c3dhaGwgb2RlciBBdXNzY2hsdXNzIHZlcnVyc2FjaHQuIEJlaW0gR2VuZXJpZXJlbiBlaW5lciBCb2Rlbm9iZXJmbMOkY2hlIHdpcmQgZGllIEzDvGNrZW5mw7xsbHVuZyBhbSBow6R1Zmlnc3RlbiB2ZXJ3ZW5kZXQuPC9kaXY+XCIsXG5cdFx0ZXF1YWxUb05hbWU6IFwiRXF1YWwgVG9cIixcblx0XHRlcXVhbFRvU25pcDogXCJGw7xocnQgYXVmIFplbGxlbmJhc2lzIGVpbmUgcmVsYXRpb25hbGUgXFxcIkVxdWFsIFRvXFxcIi1PcGVyYXRpb24gZsO8ciB6d2VpIEVpbmdhYmVuIGF1cy4gR2lidCAxIGbDvHIgWmVsbGVuIHp1csO8Y2ssIGJlaSBkZW5lbiBkYXMgZXJzdGUgUmFzdGVyIG1pdCBkZW0gendlaXRlbiBSYXN0ZXIgaWRlbnRpc2NoIGlzdCwgYW5kZXJuZmFsbHMgMC5cIixcblx0XHRlcXVhbFRvRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIHdpcmQgYXVmIFBpeGVsYmFzaXMgZWluZSBcXFwiRXF1YWwgVG9cXFwiLU9wZXJhdGlvbiBmw7xyIHp3ZWkgUmFzdGVyIGF1c2dlZsO8aHJ0LiBTaWUgZ2lidCBkZW4gV2VydCAxIGbDvHIgUGl4ZWwgenVyw7xjaywgYmVpIGRlbmVuIGRhcyBlcnN0ZSBSYXN0ZXIgbWl0IGRlbSB6d2VpdGVuIFJhc3RlciBpZGVudGlzY2ggaXN0LCBhbmRlcm5mYWxscyAwLlwiLFxuXHRcdGV1Y0FsbG9jYXRpb25OYW1lOiBcIkV1a2xpZGlzY2hlIFp1b3JkbnVuZ1wiLFxuXHRcdGV1Y0FsbG9jYXRpb25TbmlwOiBcIkJlcmVjaG5ldCBmw7xyIGplZGUgWmVsbGUgZGllIG7DpGNoc3RnZWxlZ2VuZSBRdWVsbGUgYXVmIEJhc2lzIGRlciBldWtsaWRpc2NoZW4gRW50ZmVybnVuZy5cIixcblx0XHRldWNBbGxvY2F0aW9uRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJFdWtsaWRpc2NoZSBadW9yZG51bmdcXFwiIHdpcmQgZsO8ciBqZWRlIFplbGxlIGRpZSBuw6RjaHN0Z2VsZWdlbmUgUXVlbGxlIGF1ZiBCYXNpcyBkZXIgZXVrbGlkaXNjaGVuIEVudGZlcm51bmcgYmVyZWNobmV0LlwiLFxuXHRcdGV1Y0RpcmVjdGlvbk5hbWU6IFwiRXVrbGlkaXNjaGUgUmljaHR1bmdcIixcblx0XHRldWNEaXJlY3Rpb25TbmlwOiBcIkJlcmVjaG5ldCBmw7xyIGplZGUgWmVsbGUgZGllIFJpY2h0dW5nIGluIEdyYWQgenVyIG7DpGNoc3RnZWxlZ2VuZW4gUXVlbGxlLlwiLFxuXHRcdGV1Y0RpcmVjdGlvbkRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiRXVrbGlkaXNjaGUgUmljaHR1bmdcXFwiIHdpcmQgZsO8ciBqZWRlIFplbGxlIGRpZSBSaWNodHVuZyBpbiBHcmFkIHp1ciBuw6RjaHN0Z2VsZWdlbmVuIFF1ZWxsZSBiZXJlY2huZXQuIDxkaXY+PGJyLz5EaWUgUmljaHR1bmcgd2lyZCB2b20gamV3ZWlsaWdlbiBaZWxsZW5taXR0ZWxwdW5rdCBiaXMgenVtIE1pdHRlbHB1bmt0IGRlciBuw6RjaHN0Z2VsZWdlbmVuIFF1ZWxsZW56ZWxsZSBiZXJlY2huZXQuIERlciBXZXJ0ZWJlcmVpY2ggcmVpY2h0IHZvbiAwIEdyYWQgYmlzIDM2MCBHcmFkLCB3b2JlaSAwIEdyYWQgZsO8ciBkaWUgUXVlbGxlbnplbGxlbiByZXNlcnZpZXJ0IGlzdC4gSW4gw7ZzdGxpY2hlciBSaWNodHVuZyAocmVjaHRzKSBiZWZpbmRldCBzaWNoIGRlciA5MC1HcmFkLVdpbmtlbCwgdW5kIGRpZSBXZXJ0ZSBuZWhtZW4gaW0gVWhyemVpZ2Vyc2lubiB6dSAoMTgwIEdyYWQgaXN0IFPDvGRlbiwgMjcwIEdyYWQgaXN0IFdlc3RlbiB1bmQgMzYwIEdyYWQgaXN0IE5vcmRlbikuPC9kaXY+XCIsXG5cdFx0ZXVjRGlzdGFuY2VOYW1lOiBcIkV1a2xpZGlzY2hlIEVudGZlcm51bmdcIixcblx0XHRldWNEaXN0YW5jZVNuaXA6IFwiQmVyZWNobmV0IGbDvHIgamVkZSBaZWxsZSBkaWUgZXVrbGlkaXNjaGUgRW50ZmVybnVuZyB6dXIgbsOkY2hzdGdlbGVnZW5lbiBRdWVsbGUuXCIsXG5cdFx0ZXVjRGlzdGFuY2VEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIkV1a2xpZGlzY2hlIEVudGZlcm51bmdcXFwiIHdpcmQgZsO8ciBqZWRlIFplbGxlIGRpZSBldWtsaWRpc2NoZSBFbnRmZXJudW5nIHp1ciBuw6RjaHN0Z2VsZWdlbmVuIFF1ZWxsZSBiZXJlY2huZXQuXCIsXG5cdFx0ZXhwMTBOYW1lOiBcIkV4cDEwXCIsXG5cdFx0ZXhwMTBTbmlwOiBcIkRpZSBFeHBvbmVudGlhbGZ1bmt0aW9uIHp1ciBCYXNpcyAxMCBkZXIgWmVsbGVuIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZW4uXCIsXG5cdFx0ZXhwMTBEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIkV4cCAxMFxcXCIgd2lyZCBkaWUgRXhwb25lbnRpYWxmdW5rdGlvbiB6dXIgQmFzaXMgMTAgZGVyIFBpeGVsIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZXQuXCIsXG5cdFx0ZXhwMk5hbWU6IFwiRXhwMlwiLFxuXHRcdGV4cDJTbmlwOiBcIkRpZSBFeHBvbmVudGlhbGZ1bmt0aW9uIHp1ciBCYXNpcyAyIGRlciBaZWxsZW4gaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5lbi5cIixcblx0XHRleHAyRGVzYzogXCJNaXQgZGllc2VyIEZ1bmt0aW9uIHdpcmQgZGllIEV4cG9uZW50aWFsZnVua3Rpb24genVyIEJhc2lzIDIgZGVyIFBpeGVsIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZXQuXCIsXG5cdFx0ZXhwTmFtZTogXCJFeHBcIixcblx0XHRleHBTbmlwOiBcIkRpZSBFeHBvbmVudGlhbGZ1bmt0aW9uIHp1ciBCYXNpcyBlIGRlciBaZWxsZW4gaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5lbi5cIixcblx0XHRleHBEZXNjOiBcIk1pdCBkaWVzZXIgRnVua3Rpb24gd2lyZCBkaWUgRXhwb25lbnRpYWxmdW5rdGlvbiB6dXIgQmFzaXMgZSBkZXIgUGl4ZWwgaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5ldC5cIixcblx0XHRleHRyYWN0QmFuZE5hbWU6IFwiQsOkbmRlciBleHRyYWhpZXJlblwiLFxuXHRcdGV4dHJhY3RCYW5kU25pcDogXCJGZXN0bGVnZW4sIG1pdCB3ZWxjaGVuIELDpG5kZXJuIGJlaSBWZXJ3ZW5kdW5nIHZvbiBNdWx0aWJhbmQtRGF0YXNldHMgZ2VhcmJlaXRldCB3ZXJkZW4gc29sbC5cIixcblx0XHRleHRyYWN0QmFuZERlc2M6IFwiIE1pdCBkZXIgRnVua3Rpb24gXFxcIkLDpG5kZXIgZXh0cmFoaWVyZW5cXFwiIGvDtm5uZW4gU2llIGVpbiBvZGVyIG1laHJlcmUgQsOkbmRlciBhdXMgZWluZW0gTXVsdGliYW5kLVJhc3Rlci1EYXRhc2V0IGV4dHJhaGllcmVuIGJ6dy4gZGllIELDpG5kZXIgbmV1IGFub3JkbmVuLjxkaXY+PGJyLz5TaWUga8O2bm5lbiBkaWVzZSBGdW5rdGlvbiB2b3IgYW5kZXJlbiBGdW5rdGlvbmVuIHdpZSB6LiBCLiBcXFwiQXJpdGhtZXRpc2NoXFxcIiB2ZXJ3ZW5kZW4sIHVtIGZlc3R6dWxlZ2VuLCB3ZWxjaGUgQsOkbmRlciBhbHMgRWluZ2FiZSBmw7xyIGRpZSBmb2xnZW5kZSBGdW5rdGlvbiB2ZXJ3ZW5kZXQgd2VyZGVuPC9kaXY+XCIsXG5cdFx0ZmlsbE5hbWU6IFwiRsO8bGx1bmdcIixcblx0XHRmaWxsU25pcDogXCJTZW5rZW4gaW4gZWluZW0gT2JlcmZsw6RjaGVuLVJhc3RlciBmw7xsbGVuLCB1bSBhbGxlIFVucmVnZWxtw6TDn2lna2VpdGVuIGluIGRlbiBEYXRlbiB6dSBlbnRmZXJuZW4uXCIsXG5cdFx0ZmlsbERlc2M6IFwiTWl0IGRlciBnbG9iYWxlbiBGdW5rdGlvbiBcXFwiRsO8bGx1bmdcXFwiIHdlcmRlbiBTZW5rZW4gdW5kIFNwaXR6ZW4gaW4gZWluZW0gUmFzdGVyIGbDvHIgSMO2aGVub2JlcmZsw6RjaGVuIGdlZsO8bGx0LCB1bSBrbGVpbmUgVW5yZWdlbG3DpMOfaWdrZWl0ZW4gaW4gZGVuIERhdGVuIHp1IGJlc2VpdGlnZW4uIERpZSBGdW5rdGlvbiBmw7xocnQgZGllIEbDvGxsdW5nIGFscyBpdGVyYXRpdmVuIFZvcmdhbmcgYXVzLCBiaXMgYWxsZSBTZW5rZW4gaW5uZXJoYWxiIGRlcyBhbmdlZ2ViZW5lbiBaLUxpbWl0cyBnZWbDvGxsdCBzaW5kLjxkaXY+PGJyLz5XZW5uIGVpbmUgSMO2aGVub2JlcmZsw6RjaGUgbWl0IGRlbiBPcnRobyBNYXBwaW5nLVdlcmt6ZXVnZW4gby4gw4QuIGVyc3RlbGx0IHdpcmQsIHRyZXRlbiBow6R1ZmlnIHNpZ25pZmlrYW50ZSBGZWhsZXIgaW4gRm9ybSB2b24gU2Vua2VuIHVuZCBTcGl0emVuIGluIGRlbiBEYXRlbiBhdWYuIEltIFp1c2FtbWVuaGFuZyBtaXQgZGVyIEx1ZnRiaWxkbWVzc3VuZyB3ZXJkZW4gU2Vua2VuIHVuZCBTcGl0emVuIGjDpHVmaWcgYWxzIEzDtmNoZXIgdW5kIFNwaXR6ZW4gYmV6ZWljaG5ldC4gRGEgT2JlcmZsw6RjaGVuZGF0ZW4gb2Z0IGJlaSBkZXIgTW9kZWxsaWVydW5nLCB6LiBCLiBoeWRyb2xvZ2lzY2hlIE1vZGVsbGllcnVuZywgdmVyd2VuZGV0IHdlcmRlbiwgaXN0IGVzIHdpY2h0aWcsIGRpZXNlIFNlbmtlbi0gdW5kIFNwaXR6ZW5mZWhsZXIgc28genUga29ycmlnaWVyZW4sIGRhc3Mgc2llIG1pdCBkZW4gdW1nZWJlbmRlbiBEYXRlbiBrb25zaXN0ZW50IHNpbmQuPC9kaXY+XCIsXG5cdFx0ZmxvYXROYW1lOiBcIkZsb2F0XCIsXG5cdFx0ZmxvYXRTbmlwOiBcIktvbnZlcnRpZXJ0IGplZGVuIFplbGxlbndlcnQgZWluZXMgUmFzdGVycyBpbiBlaW5lIEdsZWl0a29tbWFkYXJzdGVsbHVuZy5cIixcblx0XHRmbG9hdERlc2M6IFwiRGllIEZ1bmt0aW9uIFxcXCJGbG9hdFxcXCIga29udmVydGllcnQgamVkZW4gUGl4ZWx3ZXJ0IGVpbmVzIFJhc3RlcnMgaW4gZWluZSBHbGVpdGtvbW1hZGFyc3RlbGx1bmcuXCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvbk5hbWU6IFwiQWJmbHVzc2Fra3VtdWxhdGlvblwiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25TbmlwOiBcIkVyc3RlbGx0IGbDvHIgamVkZSBaZWxsZSBlaW4gUmFzdGVyIGRlciBBYmZsdXNzYWtrdW11bGF0aW9uLiBPcHRpb25hbCBrYW5uIGVpbiBHZXdpY2h0dW5nc2Zha3RvciBhbmdld2VuZGV0IHdlcmRlbi5cIixcblx0XHRmbG93QWNjdW11bGF0aW9uRGVzYzogXCJNaXQgZGVyIGdsb2JhbGVuIEZ1bmt0aW9uIFxcXCJBYmZsdXNzYWtrdW11bGF0aW9uXFxcIiB3aXJkIGVpbiBSYXN0ZXIgZGVyIEFiZmx1c3Nha2t1bXVsYXRpb24genUgamVkZW0gUGl4ZWwgZXJzdGVsbHQuIEJlc3RpbW10IHdpcmQgZGllcyBkdXJjaCBkYXMgQWtrdW11bGllcmVuIGRlciBHZXdpY2h0dW5nIGbDvHIgYWxsZSBQaXhlbCwgZGllIGluIGVpbnplbG5lIHRpZWZlciBnZWxlZ2VuZSBQaXhlbCBmbGllw59lbi4gV2VubiBrZWluIEdld2ljaHR1bmdzLVJhc3RlciBhbmdlZ2ViZW4gaXN0LCB3aXJkIGVpbmUgR2V3aWNodHVuZyB2b24gMSBhdWYgZGllIFBpeGVsIGFuZ2V3ZW5kZXQsIHVuZCBkZXIgV2VydCBkZXIgUGl4ZWwgaW0gQXVzZ2FiZS1SYXN0ZXIgZW50c3ByaWNodCBkZXIgQW56YWhsIHZvbiBQaXhlbG4sIGRpZSBpbiBqZWRlcyBQaXhlbCBmbGllw59lbi48ZGl2Pjxici8+QXVzZ2FiZXBpeGVsIG1pdCBlaW5lciBob2hlbiBBYmZsdXNzYWtrdW11bGF0aW9uIHNpbmQgRmzDpGNoZW4ga29uemVudHJpZXJ0ZW4gRmx1c3NlcyB1bmQga8O2bm5lbiB2ZXJ3ZW5kZXQgd2VyZGVuLCB1bSBXYXNzZXJsYXVma2Fuw6RsZSB6dSBpZGVudGlmaXppZXJlbi4gQXVzZ2FiZXBpeGVsIG1pdCBlaW5lciBBYmZsdXNzYWtrdW11bGF0aW9uIHZvbiAwIHNpbmQgbG9rYWxlIHRvcG9ncmFwaGlzY2hlIEjDtmhlbiB1bmQga8O2bm5lbiB2ZXJ3ZW5kZXQgd2VyZGVuLCB1bSBCZXJna8OkbW1lIHp1IGlkZW50aWZpemllcmVuLjwvZGl2PlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25OYW1lOiBcIkZsaWXDn3JpY2h0dW5nXCIsXG5cdFx0Zmxvd0RpcmVjdGlvblNuaXA6IFwiRWluIFJhc3RlciBtaXQgZGVyIEZsaWXDn3JpY2h0dW5nIHZvbiBqZWRlciBaZWxsZSB6dXIgamV3ZWlsaWdlbiBOYWNoYmFyemVsbGUgbWl0IGRlciBzdGVpbHN0ZW4gTmVpZ3VuZyBlcnN0ZWxsZW4uXCIsXG5cdFx0Zmxvd0RpcmVjdGlvbkRlc2M6IFwiRWluZSBkZXIgSGF1cHR2b3JhdXNzZXR6dW5nZW4gZsO8ciBkYXMgQWJsZWl0ZW4gaHlkcm9sb2dpc2NoZXIgRWlnZW5zY2hhZnRlbiBlaW5lciBPYmVyZmzDpGNoZSBiZXN0ZWh0IGRhcmluLCBkaWUgRmxpZcOfcmljaHR1bmcgYXVzIGRlbiBlaW56ZWxuZW4gUGl4ZWxuIGltIFJhc3RlciBiZXN0aW1tZW4genUga8O2bm5lbi4gRGllIFJhc3Rlci1GdW5rdGlvbiBcXFwiRmxpZcOfcmljaHR1bmdcXFwiIHZlcndlbmRldCBlaW5lIE9iZXJmbMOkY2hlIGFscyBFaW5nYWJlIHVuZCBlcnN0ZWxsdCBlaW4gRmxpZcOfcmljaHR1bmdzLVJhc3RlciB2b24gamVkZW0gUGl4ZWwgenUgc2VpbmVtIGpld2VpbHMgdGllZmVyIGdlbGVnZW5lbiBOYWNoYmFybiBtaXQgZGVyIHN0ZWlsc3RlbiBOZWlndW5nLiBEaWUgRnVua3Rpb24gXFxcIkZsaWXDn3JpY2h0dW5nXFxcIiB1bnRlcnN0w7x0enQgZHJlaSBNb2RlbGxpZXJ1bmdzbWV0aG9kZW46IEQ4IChhY2h0IFJpY2h0dW5nZW4pLCBNdWx0aXBsZSBGbG93IERpcmVjdGlvbiAoTUZEKSB1bmQgRC1JbmZpbml0eSAoRElORikuIFwiLFxuXHRcdGZsb3dEaXN0YW5jZU5hbWU6IFwiRmxpZcOfZW50ZmVybnVuZ1wiLFxuXHRcdGZsb3dEaXN0YW5jZVNuaXA6IFwiRsO8ciBqZWRlIFplbGxlIGRpZSBtaW5pbWFsZSBob3Jpem9udGFsZSBvZGVyIHZlcnRpa2FsZSBOZWlndW5nc2VudGZlcm51bmcgenUgWmVsbGVuIGVpbmVzIFdhc3NlcmxhdWZzIG9kZXIgRmx1c3NlcyBiZXJlY2huZW4uXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlRGVzYzogXCJEaWUgRnVua3Rpb24gYmVyZWNobmV0IGRpZSBtaW5pbWFsZSBob3Jpem9udGFsZSBvZGVyIHZlcnRpa2FsZSBOZWlndW5nc2VudGZlcm51bmcgenUgUGl4ZWxuIGVpbmVzIFdhc3NlcmxhdWZzIG9kZXIgRmx1c3NlcywgaW4gZGVuIHNpZSBmbGllw59lbi4gV2VubiBlaW4gb3B0aW9uYWxlcyBGbGllw59yaWNodHVuZ3MtUmFzdGVyIGFuZ2VnZWJlbiB3aXJkLCB3ZXJkZW4gbnVyIGRpZSBOZWlndW5nc3JpY2h0dW5nZW4gYmVyw7xja3NpY2h0aWd0LCBkaWUgZHVyY2ggZGFzIEVpbmdhYmUtRmxpZcOfcmljaHR1bmdzLVJhc3RlciBkZWZpbmllcnQgd2VyZGVuLiBEaWUgQXVzZ2FiZSBpc3QgZWluIFJhc3RlciBmw7xyIGRpZSBGbGllw59lbnRmZXJudW5nLlwiLFxuXHRcdGZvY2FsTmFtZTogXCJGb2NhbCBTdGF0aXN0aWNzXCIsXG5cdFx0Zm9jYWxTbmlwOiBcIkJlcmVjaG5ldCBhdWYgZGVyIEdydW5kbGFnZSBlaW5lciBkZWZpbmllcnRlbiBGb2t1c25hY2hiYXJzY2hhZnQgZGllIEZva3Vzc3RhdGlzdGlrZW4gZsO8ciBqZWRlcyBQaXhlbCBlaW5lcyBCaWxkZXMuXCIsXG5cdFx0Zm9jYWxEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIkZvY2FsIFN0YXRpc3RpY3NcXFwiIHdpcmQgZGllIEZva3Vzc3RhdGlzdGlrIGbDvHIgamVkZXMgUGl4ZWwgZWluZXMgQmlsZGVzIGF1ZiBkZXIgR3J1bmRsYWdlIGVpbmVyIGRlZmluaWVydGVuIEZva3VzbmFjaGJhcnNjaGFmdCBiZXJlY2huZXQuXCIsXG5cdFx0Z2VvbWV0cmljTmFtZTogXCJHZW9tZXRyaXNjaFwiLFxuXHRcdGdlb21ldHJpY1NuaXA6IFwiRGllIFBvc2l0aW9uc2dlbmF1aWdrZWl0IGVpbmVzIERhdGFzZXRzIGR1cmNoIEJlcsO8Y2tzaWNodGlndW5nIGRlciBIw7ZoZSBzdGVpZ2Vybi5cIixcblx0XHRnZW9tZXRyaWNEZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiR2VvbWV0cmlzY2hcXFwiIGVyemV1Z3QgYXVmIEdydW5kbGFnZSBlaW5lciBTZW5zb3JkZWZpbml0aW9uIHVuZCBlaW5lcyBUZXJyYWlubW9kZWxscyBlaW4gb3J0aG9yZWt0aWZpemllcnRlcyBCaWxkLiBTaWUgZXJow7ZodCBkaWUgUG9zaXRpb25zZ2VuYXVpZ2tlaXQgZWluZXMgRGF0YXNldHMgZHVyY2ggQmVyw7xja3NpY2h0aWd1bmcgZGVyIEjDtmhlLlwiLFxuXHRcdGdyYXlzY2FsZU5hbWU6IFwiR3JhdXN0dWZlblwiLFxuXHRcdGdyYXlzY2FsZVNuaXA6IFwiS29udmVydGllcnQgZWluIE11bHRpYmFuZC1CaWxkIGluIGVpbiBFaW56ZWxiYW5kLUdyYXVzdHVmZW4tQmlsZC5cIixcblx0XHRncmF5c2NhbGVEZXNjOiBcIk1pdCBkaWVzZXIgRnVua3Rpb24gd2lyZCBlaW4gTXVsdGliYW5kLUJpbGQgaW4gZWluIEVpbnplbGJhbmQtQmlsZCBpbiBHcmF1c3R1ZmVuIGtvbnZlcnRpZXJ0LjxkaXY+PGJyLz5CZWkgZGllc2VyIEZ1bmt0aW9uIHdlcmRlbiBhbmdlZ2ViZW5lIEdld2ljaHR1bmdlbiBhdWYgZGllIGVpbnplbG5lbiBFaW5nYWJlYsOkbmRlciBhbmdld2VuZGV0LCBkYW5uIHdpcmQgZGFzIEF1c2dhYmViaWxkIG5vcm1hbGlzaWVydC4gR2V3aWNodHVuZ2VuIHdlcmRlbiBow6R1ZmlnIGFuZ2V3ZW5kZXQsIHdlaWwgZWluaWdlIELDpG5kZXIgZWluZSB1bnRlcnNjaGllZGxpY2hlIFdpY2h0aWdrZWl0IGplIG5hY2ggQW53ZW5kdW5nIGhhYmVuLiBEYXMgYmxhdWUgQmFuZCBlbnRow6RsdCB6LiBCLiBtZWhyIFJhdXNjaGVuIGFscyBhbmRlcmUgQsOkbmRlci48L2Rpdj5cIixcblx0XHRncmVhdGVyVGhhbkVxdWFsTmFtZTogXCJHcmVhdGVyIFRoYW4gRXF1YWxcIixcblx0XHRncmVhdGVyVGhhbkVxdWFsU25pcDogXCJGw7xocnQgYXVmIFplbGxlbmJhc2lzIGVpbmUgcmVsYXRpb25hbGUgXFxcIkdyZWF0ZXIgVGhhbiBvciBFcXVhbCBUb1xcXCItT3BlcmF0aW9uIGbDvHIgendlaSBFaW5nYWJlbiBhdXMuIEdpYnQgMSBmw7xyIFplbGxlbiB6dXLDvGNrLCBiZWkgZGVuZW4gZGFzIGVyc3RlIFJhc3RlciBncsO2w59lciBhbHMgZGFzIHp3ZWl0ZSBSYXN0ZXIgb2RlciBnbGVpY2ggaXN0LCBhbmRlcm5mYWxscyAwLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2lyZCBhdWYgUGl4ZWxiYXNpcyBlaW5lIHJlbGF0aW9uYWxlIFxcXCJHcmVhdGVyIFRoYW4gb3IgRXF1YWwgVG9cXFwiLU9wZXJhdGlvbiBmw7xyIHp3ZWkgRWluZ2FiZW4gYXVzZ2Vmw7xocnQuIFNpZSBnaWJ0IGRlbiBXZXJ0IDEgZsO8ciBQaXhlbCB6dXLDvGNrLCBiZWkgZGVuZW4gZGFzIGVyc3RlIFJhc3RlciBncsO2w59lciBhbHMgZGFzIHp3ZWl0ZSBSYXN0ZXIgb2RlciBnbGVpY2ggaXN0LCB1bmQgZGVuIFdlcnQgMCBmw7xyIFBpeGVsLCBiZWkgZGVuZW4gZGFzIGVyc3RlIFJhc3RlciBrbGVpbmVyIGFscyBvZGVyIGdlbmF1c28gZ3Jvw58gd2llIGRhcyB6d2VpdGUgUmFzdGVyIGlzdC5cIixcblx0XHRncmVhdGVyVGhhbk5hbWU6IFwiR3JlYXRlciBUaGFuXCIsXG5cdFx0Z3JlYXRlclRoYW5TbmlwOiBcIkbDvGhydCBhdWYgWmVsbGVuYmFzaXMgZWluZSByZWxhdGlvbmFsZSBcXFwiR3JlYXRlciBUaGFuXFxcIi1PcGVyYXRpb24gZsO8ciB6d2VpIEVpbmdhYmVuIGF1cy4gR2lidCAxIGbDvHIgWmVsbGVuIHp1csO8Y2ssIGJlaSBkZW5lbiBkYXMgZXJzdGUgUmFzdGVyIGdyw7bDn2VyIGlzdCBhbHMgZGFzIHp3ZWl0ZSBSYXN0ZXIsIGFuZGVybmZhbGxzIDAuXCIsXG5cdFx0Z3JlYXRlclRoYW5EZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2lyZCBhdWYgUGl4ZWxiYXNpcyBlaW5lIHJlbGF0aW9uYWxlIFxcXCJHcmVhdGVyIFRoYW5cXFwiLU9wZXJhdGlvbiBmw7xyIHp3ZWkgRWluZ2FiZW4gYXVzZ2Vmw7xocnQuIEdpYnQgZGVuIFdlcnQgMSBmw7xyIFBpeGVsIHp1csO8Y2ssIGJlaSBkZW5lbiBkYXMgZXJzdGUgUmFzdGVyIGdyw7bDn2VyIGFscyBkYXMgendlaXRlIFJhc3RlciBpc3QsIHVuZCBnaWJ0IGRlbiBXZXJ0IDAgZsO8ciBQaXhlbCB6dXLDvGNrLCBiZWkgZGVuZW4gZGFzIGVyc3RlIFJhc3RlciBuaWNodCBncsO2w59lciBhbHMgZGFzIHp3ZWl0ZSBSYXN0ZXIgaXN0LlwiLFxuXHRcdGhlYXRJbmRleE5hbWU6IFwiSGl0emVpbmRleFwiLFxuXHRcdGhlYXRJbmRleFNuaXA6IFwiS29tYmluaWVydCBVbWdlYnVuZ3N0ZW1wZXJhdHVyIGRlciBMdWZ0IHVuZCByZWxhdGl2ZSBGZXVjaHRpZ2tlaXQsIHVtIGRpZSBnZWbDvGhsdGUgVGVtcGVyYXR1ciB6dXLDvGNrenVnZWJlbi5cIixcblx0XHRoZWF0SW5kZXhEZXNjOiBcIk1pdCBkaWVzZXIgRnVua3Rpb24gd2lyZCBkaWUgZ2Vmw7xobHRlIFRlbXBlcmF0dXIgYmFzaWVyZW5kIGF1ZiBkZXIgVW1nZWJ1bmdzdGVtcGVyYXR1ciB1bmQgZGVyIHJlbGF0aXZlbiBGZXVjaHRpZ2tlaXQgYmVyZWNobmV0LiBEaWUgZ2Vmw7xobHRlIFRlbXBlcmF0dXIgd2lyZCBow6R1ZmlnIGFscyBXw6RybWUgYmVzY2hyaWViZW4sIHdpZSBzaWUgdm9tIG1lbnNjaGxpY2hlbiBLw7ZycGVyIGVtcGZ1bmRlbiB3aXJkLjxkaXY+PGJyLz5EaWVzZXIgSGl0emVpbmRleCBrYW5uIGJlaSBkZXIgQmVyZWNobnVuZyB2b24gR2VmYWhyZW4gaW0gWnVzYW1tZW5oYW5nIG1pdCBtZWRpemluaXNjaGVuIFByb2JsZW1lbiBoaWxmcmVpY2ggc2Vpbiwgei4gQi4gTXVza2Vsa3LDpG1wZmUsIERlaHlkcmllcnVuZywgSGl0emVzY2jDpGRlbiBvZGVyIHNjaHdlcndpZWdlbmRlcmUgSGl0emVzY2hsw6RnZSBhbiBoZWnDn2VuIHVuZCBmZXVjaHRlbiBUYWdlbi4gV2VubiBkaWUgcmVsYXRpdmUgTHVmdGZldWNodGlna2VpdCBob2NoIGlzdCwgd2lyZCBkaWUgVmVyZHVuc3R1bmcgZGVzIFNjaHdlacOfZXMgZsO8ciBkZW4gS8O2cnBlciB6dW5laG1lbmQgc2Nod2llcmlnZXIgdW5kIE1lbnNjaGVuIGhhYmVuIGtlaW5lIE3DtmdsaWNoa2VpdCwgc2ljaCBhdWYgbmF0w7xybGljaGUgV2Vpc2UgYWJ6dWvDvGhsZW4uIEthcnRlbiBtaXQgRW1wZmVobHVuZ2VuIHVuZCBXYXJudW5nZW4gYmVpIEhpdHplIHNpbmQgaMOkdWZpZyBlaW4gUHJvZHVrdCBkZXIgUmVrbGFzc2lmaXppZXJ1bmcgZGVzIEhpdHplaW5kZXhlcmdlYm5pc3NlcyBpbiBLbGFzc2VuLiBKZSBow7ZoZXIgZGVyIEluZGV4d2VydCwgZGVzdG8gd2FocnNjaGVpbmxpY2hlciB3aXJkIGRhcmF1cyBlaW5lIFdhcm51bmcgc3RhdHQgZWluZSBFbXBmZWhsdW5nLjwvZGl2PlwiLFxuXHRcdGhpbGxzaGFkZU5hbWU6IFwiU2NodW1tZXJ1bmdcIixcblx0XHRoaWxsc2hhZGVTbmlwOiBcIkVyc3RlbGx0IGVpbmUgM0QtRGFyc3RlbGx1bmcgZGVyIE9iZXJmbMOkY2hlLCB3b2JlaSBkaWUgcmVsYXRpdmUgUG9zaXRpb24gZGVyIFNvbm5lIGJlaW0gU2NodW1tZXJuIGRlcyBCaWxkZXMgYmVyw7xja3NpY2h0aWd0IHdpcmQuXCIsXG5cdFx0aGlsbHNoYWRlRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIlNjaHVtbWVydW5nXFxcIiBlcnpldWd0IGVpbmUgR3JhdXN0dWZlbi0zRC1EYXJzdGVsbHVuZyBkZXIgVGVycmFpbi1PYmVyZmzDpGNoZSwgd29iZWkgZGllIHJlbGF0aXZlIFBvc2l0aW9uIGRlciBTb25uZSBiZWltIFNjaHVtbWVybiBkZXMgQmlsZGVzIGJlcsO8Y2tzaWNodGlndCB3aXJkLiA8ZGl2Pjxici8+U2NodW1tZXJ1bmcgaXN0IGVpbmUgTWV0aG9kZSB6dW0gVmlzdWFsaXNpZXJlbiB2b24gVGVycmFpbiwgZGFzIGR1cmNoIGVpbmUgTGljaHRxdWVsbGUgdW5kIGRpZSBOZWlndW5nIHVuZCBBdXNyaWNodHVuZyBkZXIgSMO2aGVub2JlcmZsw6RjaGUgYmVzdGltbXQgd2lyZC4gRXMgaGFuZGVsdCBzaWNoIHVtIGVpbmUgcXVhbGl0YXRpdmUgTWV0aG9kZSB6dW0gVmlzdWFsaXNpZXJlbiB2b24gVG9wb2dyYWZpZSwgZGllIGtlaW5lIGFic29sdXRlbiBIw7ZoZW53ZXJ0ZSBsaWVmZXJ0LiA8L2Rpdj5cIixcblx0XHRpbnROYW1lOiBcIkludFwiLFxuXHRcdGludFNuaXA6IFwiS29udmVydGllcnQgZGllIGVpbnplbG5lbiBaZWxsZW53ZXJ0ZSBlaW5lcyBSYXN0ZXJzIGR1cmNoIEvDvHJ6dW5nIGluIGVpbmUgZ2FuemUgWmFobC5cIixcblx0XHRpbnREZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiSW50XFxcIiBrb252ZXJ0aWVydCBkaWUgZWluemVsbmVuIFBpeGVsd2VydGUgZWluZXMgUmFzdGVycyBkdXJjaCBLw7xyenVuZyBpbiBlaW5lIGdhbnplIFphaGwuXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmFtZTogXCJVbnJlZ2VsbcOkw59pZ2UgRGF0ZW4gaW50ZXJwb2xpZXJlblwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVNuaXA6IFwiSW50ZXJwb2xpZXJ0IGF1cyBQdW5rdHdvbGtlbiBvZGVyIHVucmVnZWxtw6TDn2lnZW4gR2l0dGVybi5cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFEZXNjOiBcIkluIGVpbmlnZW4gbmV0Q0RGLSBvZGVyIEhERi1EYXRhc2V0cyB3aXJkIGRpZSBHZW9sb2thbGlzaWVydW5nIGluIEZvcm0gdm9uIHVucmVnZWxtw6TDn2lnIGFuZ2VvcmRuZXRlbiBBcnJheXMgYXVzIFBpeGVsbiBvZGVyIFB1bmt0ZGF0ZW4gZ2VzcGVpY2hlcnQuIEJlaW0gSGluenVmw7xnZW4gZGllc2VyIERhdGFzZXRzIHp1IGVpbmVtIE1vc2Fpay1EYXRhc2V0IHdpcmQgdm9uIGRlciBGdW5rdGlvbiBcXFwiVW5yZWdlbG3DpMOfaWdlIERhdGVuIGludGVycG9saWVyZW5cXFwiIGVpbiBSZXNhbXBsaW5nIGRlciB1bnJlZ2VsbcOkw59pZyBnZXJhc3RlcnRlbiBEYXRlbiBkdXJjaGdlZsO8aHJ0LCBzb2Rhc3MgamVkZXMgUGl4ZWwgZGllIGdsZWljaGUgR3LDtsOfZSB1bmQgZWluZSByZWNodGVja2lnZSBGb3JtIGVyaMOkbHQuPGRpdj48YnIvPkJlaW0gSGluenVmw7xnZW4gdm9uIFZhcmlhYmxlbiBhdXMgbmV0Q0RGIG9kZXIgSERGIHp1IGVpbmVtIE1vc2Fpay1EYXRhc2V0IHdpcmQgYXV0b21hdGlzY2ggZ2VwcsO8ZnQsIG9iIGRpZSBEYXRlbiBpbiBlaW5lbSByZWdlbG3DpMOfaWdlbiBBcnJheSBhbmdlb3JkbmV0IHNpbmQuIEZhbGxzIGRpZXMgbmljaHQgZGVyIEZhbGwgaXN0LCBrw7ZubmVuIGRpZSB1bnJlZ2VsbcOkw59pZ2VuIERhdGVuIG1pdCBkZXIgRnVua3Rpb24gXFxcIlVucmVnZWxtw6TDn2lnZSBEYXRlbiBpbnRlcnBvbGllcmVuXFxcIiBpbiBlaW4gcmVnZWxtw6TDn2lnZXMgUmFzdGVyIHVtZ2V3YW5kZWx0IHdlcmRlbi4gU2llIGvDtm5uZW4gZGllIHZlcndlbmRldGUgSW50ZXJwb2xhdGlvbnNtZXRob2RlIHVuZCBaZWxsZW5ncsO2w59lIGluIGRlciBGdW5rdGlvbiBcXFwiVW5yZWdlbG3DpMOfaWdlIERhdGVuIGludGVycG9saWVyZW5cXFwiIMOkbmRlcm4uIEJlaSByZWdlbG3DpMOfaWcgYW5nZW9yZG5ldGVuIFJhc3Rlci1EYXRlbiBmaW5kZXQga2VpbmUgSW50ZXJwb2xhdGlvbiBzdGF0dCwgZGllIERhdGVuIHdlcmRlbiBpbiBpaHJlbSBnZWdlbnfDpHJ0aWdlbiBadXN0YW5kIGdlbGVzZW4uPC9kaXY+XCIsXG5cdFx0aXNOdWxsTmFtZTogXCJJc3QgTnVsbFwiLFxuXHRcdGlzTnVsbFNuaXA6IFwiRXJtaXR0ZWx0IGF1ZiBaZWxsZW5iYXNpcywgd2VsY2hlIFdlcnRlIGluIGRlbiBFaW5nYWJlLVJhc3Rlcm4gZGVuIFdlcnQgXFxcIk5vRGF0YVxcXCIgYXVmd2Vpc2VuLiBHaWJ0IGRlbiBXZXJ0IDEgenVyw7xjaywgd2VubiBkaWUgRWluZ2FiZXdlcnRlIFxcXCJOb0RhdGFcXFwiIGxhdXRlbiwgYW5kZXJuZmFsbHMgMC5cIixcblx0XHRpc051bGxEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIklzIE51bGxcXFwiIHdpcmQgYXVmIFBpeGVsYmFzaXMgZXJtaXR0ZWx0LCB3ZWxjaGUgV2VydGUgaW0gRWluZ2FiZS1SYXN0ZXIgZGVuIFdlcnQgXFxcIk5vRGF0YVxcXCIgYXVmd2Vpc2VuLiBTaWUgZ2lidCBkZW4gV2VydCAxIHp1csO8Y2ssIHdlbm4gZGVyIEVpbmdhYmV3ZXJ0IFxcXCJOb0RhdGFcXFwiIGxhdXRldCwgdW5kIGRlbiBXZXJ0IDAgZsO8ciBQaXhlbCwgYmVpIGRlbmVuIGRlciBFaW5nYWJld2VydCBuaWNodCBcXFwiTm9EYXRhXFxcIiBsYXV0ZXQuXCIsXG5cdFx0a2VybmVsRGVuc2l0eU5hbWU6IFwiS2VybmRpY2h0ZVwiLFxuXHRcdGtlcm5lbERlbnNpdHlTbmlwOiBcIkJlcmVjaG5ldCBtaXQgZWluZXIgS2VybmVsLUZ1bmt0aW9uIGVpbmUgTWFnbml0dWRlIHBybyBGbMOkY2hlbmVpbmhlaXQgYXVzIFB1bmt0LSBvZGVyIFBvbHlsaW5pZW4tRmVhdHVyZXMsIHVtIGbDvHIgamVkZW4gUHVua3QgYnp3LiBqZWRlIFBvbHlsaW5pZSBlaW5lIHNhbmZ0IGFiZ2VzY2hyw6RndGUgT2JlcmZsw6RjaGUgYW56dXBhc3Nlbi5cIixcblx0XHRrZXJuZWxEZW5zaXR5RGVzYzogXCJNaXQgZGllc2VyIEZ1bmt0aW9uIHdpcmQgYW5oYW5kIGVpbmVyIEtlcm5lbC1GdW5rdGlvbiBkaWUgR3LDtsOfZSBwcm8gRmzDpGNoZW5laW5oZWl0IGF1ZiBCYXNpcyB2b24gUHVua3QtIG9kZXIgUG9seWxpbmllbi1GZWF0dXJlcyBiZXJlY2huZXQsIHVtIGbDvHIgamVkZW4gUHVua3QgYnp3LiBqZWRlIFBvbHlsaW5pZSBlaW5lIHNhbmZ0IGFiZ2VzY2hyw6RndGUgT2JlcmZsw6RjaGUgYW56dXBhc3Nlbi5cIixcblx0XHRrZXlNZXRhZGF0YU5hbWU6IFwiU2NobMO8c3NlbG1ldGFkYXRlblwiLFxuXHRcdGtleU1ldGFkYXRhU25pcDogXCJTY2hsw7xzc2VsbWV0YWRhdGVuIGVpbmVzIFJhc3RlcnMgd2VyZGVuIGluIGVpbmUgRnVua3Rpb25za2V0dGUgZWluZ2Vmw7xndCBvZGVyIGRhcmluIMO8YmVyc2NocmllYmVuLlwiLFxuXHRcdGtleU1ldGFkYXRhRGVzYzogXCJNaXQgZGllc2VyIEZ1bmt0aW9uIGvDtm5uZW4gU2llIFNjaGzDvHNzZWxtZXRhZGF0ZW4gZWluZXMgUmFzdGVycyBlaW5mw7xnZW4gb2RlciDDvGJlcnNjaHJlaWJlbi48ZGl2Pjxici8+RHVyY2ggZGllIEluZm9ybWF0aW9uZW4gaW4gZGVuIFNjaGzDvHNzZWxtZXRhZGF0ZW4gd2lyZCBkaWUgQW53ZW5kdW5nIGJlaSBkZXIgVmVyYXJiZWl0dW5nIHVuZCBkZW0gUmVuZGVybiB1bnRlcnN0w7x0enQsIGRhcnVudGVyIGJlaW0gQmVyZWl0c3RlbGxlbiBuw7x0emxpY2hlciBJbmZvcm1hdGlvbmVuLCB6LiBCLiB2b24gbWl0IGRlbiBCaWxkZGF0ZW4gdmVya27DvHBmdGVuIFNlbnNvcm5hbWVuIHVuZCBCYW5kbmFtZW4gb2RlciBkZXIgdmVya27DvHBmdGVuIFdvbGtlbmJlZGVja3VuZy48L2Rpdj5cIixcblx0XHRzaG9ydGVzdFBhdGhOYW1lOiBcIktvc3RlbmfDvG5zdGlnc3RlciBQZmFkXCIsXG5cdFx0c2hvcnRlc3RQYXRoU25pcDogXCJLb3N0ZW5lbnRmZXJudW5nc2FuYWx5c2UgbWl0aGlsZmUgdm9uIFF1ZWxsLSB1bmQgWmllbGVpbmdhYmUgZHVyY2hmw7xocmVuLCBkaWUgZGFubiB6dW0gRXJtaXR0ZWxuIGRlcyBrb3N0ZW5nw7xuc3RpZ3N0ZW4gUGZhZHMgdm9uIGVpbmVyIFF1ZWxsZSB6dSBlaW5lbSBaaWVsIHZlcndlbmRldCB3aXJkLlwiLFxuXHRcdHNob3J0ZXN0UGF0aERlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiS29zdGVuZ8O8bnN0aWdzdGVyIFBmYWRcXFwiIHdpcmQgZGVyIGtvc3RlbmfDvG5zdGlnc3RlIFBmYWQgdm9uIGVpbmVyIFF1ZWxsZSB6dSBlaW5lbSBaaWVsIGJlcmVjaG5ldC4gRGllIGtsZWluc3RlIGFra3VtdWxhdGl2ZSBLb3N0ZW5lbnRmZXJudW5nIHdpcmQgZsO8ciBqZWRlcyBQaXhlbCDDvGJlciBlaW5lIEtvc3Rlbm9iZXJmbMOkY2hlIHp1ciBuw6RjaHN0Z2VsZWdlbmVuIFF1ZWxsZSBiZXJlY2huZXQuIERhZHVyY2ggd2lyZCBlaW4gQXVzZ2FiZS1SYXN0ZXIgZXJ6ZXVndCwgZGFzIGRlbi9kaWUga29zdGVuZ8O8bnN0aWdzdGVuIFBmYWQoZSkgdm9uIGF1c2dld8OkaGx0ZW4gUG9zaXRpb25lbiB6dSBkZW4gbsOkY2hzdGVuIFF1ZWxscGl4ZWxuIGF1ZnplaWNobmV0LCBkaWUgaW5uZXJoYWxiIGRlciBha2t1bXVsYXRpdmVuIEtvc3Rlbi1PYmVyZmzDpGNoZSBkZWZpbmllcnQgd3VyZGVuIChoaW5zaWNodGxpY2ggZGVyIEtvc3RlbmVudGZlcm51bmcpLjxkaXY+PGJyLz5KZWRlbSBrb3N0ZW5nw7xuc3RpZ2VuIFBmYWQgd2lyZCBlaW4gV2VydCB6dWdld2llc2VuLCB3ZW5uIHNpZSBiZWltIFNjYW52b3JnYW5nIGdlZnVuZGVuIHdpcmQuIERlbSBFbmRwaXhlbCBpbSBRdWVsbC1SYXN0ZXIgZWluZXMgS29zdGVucGZhZGVzIHdpcmQgZGVyIFdlcnQgMSB6dWdld2llc2VuLiBEZW0gZXJzdGVuIFBmYWQgd2lyZCBkZXIgV2VydCAzLCBkZW0gendlaXRlbiBkZXIgV2VydCA0IHVzdy4genVnZXdpZXNlbi4gV2VubiBtZWhyZXJlIFBmYWRlIHp1c2FtbWVubGF1ZmVuIHVuZCBmw7xyIGRpZSB2ZXJibGVpYmVuZGUgRW50ZmVybnVuZyB6dXLDvGNrIHp1IGVpbmVyIFF1ZWxsZSBkZW5zZWxiZW4gUGZhZCB2ZXJ3ZW5kZW4sIHdpcmQgZGVtIFNlZ21lbnQsIGluIGRlbSBkaWUgYmVpZGVuIFBmYWRlIHp1c2FtbWVuIHZlcmxhdWZlbiwgZGVyIFdlcnQgMiB6dWdld2llc2VuLiBEZW0genVzYW1tZW5nZWbDvGhydGVuIFRlaWwgZGVzIFBmYWRlcyBrYW5uIG5pY2h0IGRlciBXZXJ0IGVpbmVzIGRlciBQZmFkZSB6dWdld2llc2VuIHdlcmRlbiwgZGEgZGVyIHp1c2FtbWVuZ2Vmw7xocnRlIFRlaWwgenUgYmVpZGVuIFBmYWRlbiBnZWjDtnJ0LjwvZGl2PlwiLFxuXHRcdGxlc3NUaGFuRXF1YWxOYW1lOiBcIkxlc3MgVGhhbiBFcXVhbFwiLFxuXHRcdGxlc3NUaGFuRXF1YWxTbmlwOiBcIkbDvGhydCBhdWYgWmVsbGVuYmFzaXMgZWluZSByZWxhdGlvbmFsZSBcXFwiTGVzcyBUaGFuIG9yIEVxdWFsIFRvXFxcIi1PcGVyYXRpb24gZsO8ciB6d2VpIEVpbmdhYmVuIGF1cy4gR2lidCAxIGbDvHIgWmVsbGVuIHp1csO8Y2ssIGJlaSBkZW5lbiBkYXMgZXJzdGUgUmFzdGVyIGtsZWluZXIgYWxzIGRhcyB6d2VpdGUgUmFzdGVyIG9kZXIgZ2xlaWNoIGlzdCwgYW5kZXJuZmFsbHMgMC5cIixcblx0XHRsZXNzVGhhbkVxdWFsRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIHdpcmQgYXVmIFBpeGVsYmFzaXMgZWluZSByZWxhdGlvbmFsZSBcXFwiTGVzcyBUaGFuIG9yIEVxdWFsIFRvXFxcIi1PcGVyYXRpb24gZsO8ciB6d2VpIFJhc3RlciBhdXNmw7xocnQuIFNpZSBnaWJ0IGRlbiBXZXJ0IDEgZsO8ciBQaXhlbCB6dXLDvGNrLCBiZWkgZGVuZW4gZGFzIGVyc3RlIFJhc3RlciBrbGVpbmVyIGFscyBkYXMgendlaXRlIFJhc3RlciBvZGVyIGdsZWljaCBpc3QsIHVuZCBkZW4gV2VydCAwIGbDvHIgUGl4ZWwsIGJlaSBkZW5lbiBkYXMgZXJzdGUgUmFzdGVyIGdyw7bDn2VyIGFscyBkYXMgendlaXRlIFJhc3RlciBpc3QuXCIsXG5cdFx0bGVzc1RoYW5OYW1lOiBcIkxlc3MgVGhhblwiLFxuXHRcdGxlc3NUaGFuU25pcDogXCJGw7xocnQgYXVmIFplbGxlbmJhc2lzIGVpbmUgcmVsYXRpb25hbGUgXFxcIkxlc3MgVGhhblxcXCItT3BlcmF0aW9uIGbDvHIgendlaSBFaW5nYWJlbiBhdXMuIEdpYnQgMSBmw7xyIFplbGxlbiB6dXLDvGNrLCBiZWkgZGVuZW4gZGFzIGVyc3RlIFJhc3RlciBrbGVpbmVyIGFscyBkYXMgendlaXRlIFJhc3RlciBpc3QsIGFuZGVybmZhbGxzIGdpYnQgZXMgMCB6dXLDvGNrLlwiLFxuXHRcdGxlc3NUaGFuRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIHdpcmQgYXVmIFBpeGVsYmFzaXMgZWluZSByZWxhdGlvbmFsZSBcXFwiTGVzcyBUaGFuXFxcIi1PcGVyYXRpb24gZsO8ciB6d2VpIEVpbmdhYmVuIGF1c2bDvGhydC4gU2llIGdpYnQgZGVuIFdlcnQgMSBmw7xyIFBpeGVsIHp1csO8Y2ssIGJlaSBkZW5lbiBkYXMgZXJzdGUgUmFzdGVyIGtsZWluZXIgYWxzIGRhcyB6d2VpdGUgUmFzdGVyIGlzdCwgdW5kIGRlbiBXZXJ0IDAgZsO8ciBQaXhlbCwgYmVpIGRlbmVuIGRhcyBlcnN0ZSBSYXN0ZXIgbmljaHQga2xlaW5lciBhbHMgZGFzIHp3ZWl0ZSBSYXN0ZXIgaXN0LlwiLFxuXHRcdGxuTmFtZTogXCJMblwiLFxuXHRcdGxuU25pcDogXCJEZW4gbmF0w7xybGljaGVuIExvZ2FyaXRobXVzIChCYXNpcyBlKSB2b24gWmVsbGVuIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZW4uXCIsXG5cdFx0bG5EZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIkxuXFxcIiB3aXJkIGRlciBuYXTDvHJsaWNoZSBMb2dhcml0aG11cyAoQmFzaXMgZSkgZGVyIGVpbnplbG5lbiBQaXhlbCBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmV0LlwiLFxuXHRcdGxvZzEwTmFtZTogXCJMb2cxMFwiLFxuXHRcdGxvZzEwU25pcDogXCJEZW4gTG9nYXJpdGhtdXMgZGVyIEJhc2lzIDEwIHZvbiBaZWxsZW4gaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5lbi5cIixcblx0XHRsb2cxMERlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiTG9nMTBcXFwiIHdpcmQgZGVyIExvZ2FyaXRobXVzIGRlciBCYXNpcyAxMCBkZXIgZWluemVsbmVuIFBpeGVsIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZXQuXCIsXG5cdFx0bG9nMk5hbWU6IFwiTG9nMlwiLFxuXHRcdGxvZzJTbmlwOiBcIkRlbiBMb2dhcml0aG11cyBkZXIgQmFzaXMgMiB2b24gWmVsbGVuIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZW4uXCIsXG5cdFx0bG9nMkRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiTG9nMlxcXCIgd2lyZCBkZXIgTG9nYXJpdGhtdXMgZGVyIEJhc2lzIDIgZGVyIGVpbnplbG5lbiBQaXhlbCBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmV0LlwiLFxuXHRcdGxvb2t1cE5hbWU6IFwiTG9va3VwXCIsXG5cdFx0bG9va3VwU25pcDogXCJFcnN0ZWxsdCBlaW4gbmV1ZXMgUmFzdGVyIGR1cmNoIGRpZSBTdWNoZSBuYWNoIFdlcnRlbiBpbiBlaW5lbSBhbmRlcmVuIEZlbGQgaW4gZGVyIFRhYmVsbGUgZGVzIEVpbmdhYmUtUmFzdGVycy5cIixcblx0XHRsb29rdXBEZXNjOiBcIkRpZSBGdW5rdGlvbiBlcnN0ZWxsdCBkdXJjaCBkaWUgU3VjaGUgbmFjaCBXZXJ0ZW4gYXVzIGVpbmVtIGFuZGVyZW4gRmVsZCBpbiBkZXIgVGFiZWxsZSBkZXMgRWluZ2FiZS1SYXN0ZXJzIGVpbiBuZXVlcyBSYXN0ZXIuXCIsXG5cdFx0bWxDbGFzc2lmeU5hbWU6IFwiTUwtS2xhc3NpZml6aWVydW5nXCIsXG5cdFx0bWxDbGFzc2lmeVNuaXA6IFwiS2xhc3NpZml6aWVydCBCaWxkZGF0ZW4sIHdvYmVpIGRpZSBLbGFzc2lmaXppZXJ1bmcgcHJvIFBpeGVsIGVyZm9sZ3QuIEdlbWlzY2h0ZSBQaXhlbCB3ZXJkZW4gZGVtIEZlYXR1cmUgbWl0IGRlbSBow7ZjaHN0ZW4gUHJvemVudHNhdHogaW4gZGllc2VtIFBpeGVsIHp1Z2V3aWVzZW4uXCIsXG5cdFx0bWxDbGFzc2lmeURlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiTUwtS2xhc3NpZml6aWVydW5nXFxcIiBrw7ZubmVuIFNpZSBlaW5lIMO8YmVyd2FjaHRlIEtsYXNzaWZpemllcnVuZyBtaXRoaWxmZSBkZXMgTWF4aW11bS1MaWtlbGlob29kLUtsYXNzaWZpemllcnVuZ3NhbGdvcml0aG11cyBmw7xyIGVpbiBSYXN0ZXItRGF0YXNldCBvZGVyIGVpbiBNb3NhaWstRGF0YXNldCBhdXNmw7xocmVuLiAgRsO8ciBkaWVzZSBGdW5rdGlvbiBpc3QgZWluZSBLbGFzc2lmaXppZXJ1bmdzLVNpZ25hdHVyZGF0ZWkgZXJmb3JkZXJsaWNoLlwiLFxuXHRcdG1hc2tOYW1lOiBcIk1hc2tlXCIsXG5cdFx0bWFza1NuaXA6IFwiV2VydGUgZmVzdGxlZ2VuLCBkaWUgbmljaHQgYW5nZXplaWd0IHdlcmRlbiBzb2xsZW4uXCIsXG5cdFx0bWFza0Rlc2M6IFwiTWl0IGRpZXNlciBSYXN0ZXItRnVua3Rpb24gd2VyZGVuIFdlcnRlIGZlc3RnZWxlZ3QsIGRpZSBuaWNodCBpbSBSYXN0ZXIgYW5nZXplaWd0IHdlcmRlbiBzb2xsZW4uIE1pdGhpbGZlIGRlciBGdW5rdGlvbiBcXFwiTWFza2VcXFwiIGvDtm5uZW4gU2llIGVpbmVuIG9kZXIgbWVocmVyZSBOb0RhdGEtV2VydGUgb2RlciBlaW5lbiBCZXJlaWNoIGfDvGx0aWdlciBQaXhlbHdlcnRlIGFuZ2ViZW4uIFwiLFxuXHRcdG1pbnVzTmFtZTogXCJNaW51c1wiLFxuXHRcdG1pbnVzU25pcDogXCJEZW4gV2VydCBkZXMgendlaXRlbiBFaW5nYWJlLVJhc3RlcnMgdm9tIFdlcnQgZGVzIGVyc3RlbiBFaW5nYWJlLVJhc3RlcnMgYXVmIFplbGxlbmJhc2lzIHN1YnRyYWhpZXJlbi5cIixcblx0XHRtaW51c0Rlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiTWludXNcXFwiIHdpcmQgZGVyIFdlcnQgZGVzIHp3ZWl0ZW4gRWluZ2FiZS1SYXN0ZXJzIHZvbSBXZXJ0IGRlcyBlcnN0ZW4gRWluZ2FiZS1SYXN0ZXJzIGF1ZiBQaXhlbGJhc2lzIHN1YnRyYWhpZXJ0LlwiLFxuXHRcdG1vZE5hbWU6IFwiTW9kXCIsXG5cdFx0bW9kU25pcDogXCJEZW4gUmVzdCAoTW9kdWxvKSBkZXIgVGVpbHVuZyBkZXMgZXJzdGVuIFJhc3RlcnMgZHVyY2ggZGFzIHp3ZWl0ZSBSYXN0ZXIgYXVmIFplbGxlbmJhc2lzIGVybWl0dGVsbi5cIixcblx0XHRtb2REZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIk1vZFxcXCIgd2lyZCBhdWYgUGl4ZWxiYXNpcyBkZXIgUmVzdCAoTW9kdWxvKSBkZXIgVGVpbHVuZyBkZXMgZXJzdGVuIFJhc3RlcnMgZHVyY2ggZGFzIHp3ZWl0ZSBSYXN0ZXIgZXJtaXR0ZWx0LiBEaWUgUmVpaGVuZm9sZ2UgZGVyIEVpbmdhYmVuIGlzdCB3aWNodGlnIHVuZCB3aXJrdCBzaWNoIGF1ZiBkYXMgQXVzZ2FiZWVyZ2VibmlzIGF1cy5cIixcblx0XHRtb3NhaWNSYXN0ZXJzTmFtZTogXCJSYXN0ZXIgbW9zYWlraWVyZW5cIixcblx0XHRtb3NhaWNSYXN0ZXJzU25pcDogXCJGw7xndCBlaW5lIFJlaWhlIHZvbiBSYXN0ZXItRGF0YXNldHMgenVzYW1tZW4sIHVtIGVpbiBEYXRhc2V0IHp1IGVyc3RlbGxlbi5cIixcblx0XHRtb3NhaWNSYXN0ZXJzRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJSYXN0ZXIgbW9zYWlraWVyZW5cXFwiIHdpcmQgZWluIE1vc2Fpa2JpbGQgYXVzIG1laHJlcmVuIEJpbGRlcm4genVzYW1tZW5nZWbDvGd0LiBXZW5uIHNpY2ggZGllIEJpbGRlciDDvGJlcmxhcHBlbiwgc3RlaGVuIG1laHJlcmUgTWV0aG9kZW4genVyIEF1c3dhaGwsIHVtIGZlc3R6dWxlZ2VuLCB3ZWxjaGUgQmlsZGVyIGFuZ2V6ZWlndCB3ZXJkZW4uXCIsXG5cdFx0bmR2aUNvbG9yaXplZE5hbWU6IFwiRmFyYmdlYnVuZyBkdXJjaCBORFZJXCIsXG5cdFx0bmR2aUNvbG9yaXplZFNuaXA6IFwiRWluIE11bHRpYmFuZC1EYXRhc2V0IGVyc3RlbGxlbiwgZGFzIGRlbiBHZXN1bmRoZWl0c3p1c3RhbmQgZGVyIFZlZ2V0YXRpb24gYmFzaWVyZW5kIGF1ZiBkZW0gVW50ZXJzY2hpZWQgendpc2NoZW4gZGVtIHJvdGVuIHVuZCBkZW0gaW5mcmFyb3RuYWhlbiBCYW5kIGRhcnN0ZWxsdC5cIixcblx0XHRuZHZpQ29sb3JpemVkRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIkZhcmJnZWJ1bmcgZHVyY2ggTkRWSVxcXCIgd2VuZGV0IGRpZSBGdW5rdGlvbiBcXFwiTkRWSVxcXCIgYXVmIGRhcyBFaW5nYWJlYmlsZCBhbiB1bmQgdmVyd2VuZGV0IGFuc2NobGllw59lbmQgZWluZSBDb2xvcm1hcCBvZGVyIGVpbmVuIEZhcmJ2ZXJsYXVmLCB1bSBkYXMgRXJnZWJuaXMgYW56dXplaWdlbi5cIixcblx0XHRuZHZpTmFtZTogXCJORFZJXCIsXG5cdFx0bmR2aVNuaXA6IFwiQmVyZWNobmV0IGRlbiBub3JtYWxpc2llcnRlbiBkaWZmZXJlbnppZXJ0ZW4gVmVnZXRhdGlvbnNpbmRleCAoTm9ybWFsaXplZCBEaWZmZXJlbmNlIFZlZ2V0YXRpb24gSW5kZXgsIE5EVkkpLlwiLFxuXHRcdG5kdmlEZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiTkRWSVxcXCIgZXJzdGVsbHQgZWluIE11bHRpYmFuZC1EYXRhc2V0LCBkYXMgZGVuIFZlZ2V0YXRpb25zenVzdGFuZCBiYXNpZXJlbmQgYXVmIGRlbSBVbnRlcnNjaGllZCB6d2lzY2hlbiBkZW0gcm90ZW4gdW5kIGRlbSBuYWhpbmZyYXJvdGVuIEJhbmQgZGFyc3RlbGx0LjxkaXY+PGJyLz5ORFZJIGlzdCBlaW4gc3RhbmRhcmRpc2llcnRlciBJbmRleCwgZGVyIElobmVuIGRhcyBFcnN0ZWxsZW4gZWluZXMgQmlsZGVzIG1pdCBHcsO8bmFudGVpbGVuIChkaWUgc29nLiByZWxhdGl2ZSBCaW9tYXNzZSkgZXJtw7ZnbGljaHQuIERpZXNlciBJbmRleCBudXR6dCBkZW4gS29udHJhc3QgZGVyIEVpZ2Vuc2NoYWZ0ZW4gendlaWVyIELDpG5kZXIgYXVzIGVpbmVtIG11bHRpc3Bla3RyYWxlbiBSYXN0ZXItRGF0YXNldDogZGllIEFic29ycHRpb24gZHVyY2ggZGllIENobG9yb3BoeWxscGlnbWVudGUgaW0gcm90ZW4gQmFuZCB1bmQgZGVuIFBmbGFuemVuLVJlZmxleGlvbnNncmFkIGltIG5haGluZnJhcm90ZW4gQmFuZCAoTklSKS4gw4R1w59lcnN0IG5pZWRyaWdlIG9kZXIgbmVnYXRpdmUgTkRWSS1XZXJ0ZSBzdGVoZW4gZsO8ciBCZXJlaWNoZSBvaG5lIFZlZ2V0YXRpb24gd2llIFdvbGtlbiwgV2Fzc2VyIG9kZXIgU2NobmVlLiBTZWhyIG5pZWRyaWdlIFdlcnRlIHN0ZWhlbiBmw7xyIEJlcmVpY2hlIG1pdCB3ZW5pZyBvZGVyIG9obmUgVmVnZXRhdGlvbiwgd2llIEJldG9uLCBTdGVpbiBvZGVyIG5hY2t0ZXIgRXJkZS4gTWl0dGxlcmUgV2VydGUgc3RlaGVuIGbDvHIgQmVyZWljaGUgbWl0IFN0cmF1Y2gtIHVuZCBHcmFzZmzDpGNoZW4uIEhvaGUgV2VydGUgc3RlaGVuIGbDvHIgQmVyZWljaGUgbWl0IEZvcnN0ZmzDpGNoZW4gdW5kIMO8cHBpZ2VyIFZlZ2V0YXRpb24uPC9kaXY+XCIsXG5cdFx0bmVnYXRlTmFtZTogXCJOZWdhdGVcIixcblx0XHRuZWdhdGVTbmlwOiBcIkRhcyBWb3J6ZWljaGVuIGRlciBaZWxsZW53ZXJ0ZSBkZXMgRWluZ2FiZS1SYXN0ZXJzIChNdWx0aXBsaWthdGlvbiBtaXQgLTEpIGF1ZiBaZWxsZW5iYXNpcyDDpG5kZXJuLlwiLFxuXHRcdG5lZ2F0ZURlc2M6IFwiRHVyY2ggZGllIEZ1bmt0aW9uIFxcXCJOZWdhdGVcXFwiIHdpcmQgZGFzIFZvcnplaWNoZW4gZGVyIFplbGxlbndlcnRlIGRlcyBFaW5nYWJlLVJhc3RlcnMgYXVmIFBpeGVsYmFzaXMgZ2XDpG5kZXJ0IChNdWx0aXBsaWthdGlvbiBtaXQgLTEpLiBcIixcblx0XHRuaWJibGVOYW1lOiBcIk5pYmJsZVwiLFxuXHRcdG5pYmJsZVNuaXA6IFwiRXJzZXR6dCBkaWUgWmVsbGVuIGVpbmVzIFJhc3RlcnMgZW50c3ByZWNoZW5kIGVpbmVyIE1hc2tlIGR1cmNoIGRpZSBXZXJ0ZSBkZXIgbsOkY2hzdGVuIE5hY2hiYXJuLlwiLFxuXHRcdG5pYmJsZURlc2M6IFwiTWl0IGRlciBnbG9iYWxlbiBGdW5rdGlvbiBcXFwiTmliYmxlXFxcIiBrYW5uIGF1c2dld8OkaGx0ZW4gQmVyZWljaGVuIGVpbmVzIFJhc3RlcnMgZGVyIFdlcnQgZGVzIG7DpGNoc3RlbiBOYWNoYmFybiB6dWdld2llc2VuIHdlcmRlbi4gRGllcyBpc3QgZsO8ciBkaWUgQmVhcmJlaXR1bmcgdm9uIFJhc3Rlci1GbMOkY2hlbiwgZGVyZW4gRGF0ZW4gbcO2Z2xpY2hlcndlaXNlIGZlaGxlcmhhZnQgc2luZC5cIixcblx0XHRub3RFcXVhbE5hbWU6IFwiTm90IEVxdWFsXCIsXG5cdFx0bm90RXF1YWxTbmlwOiBcIkbDvGhydCBhdWYgWmVsbGVuYmFzaXMgZWluZSByZWxhdGlvbmFsZSBcXFwiTm90IEVxdWFsIFRvXFxcIi1PcGVyYXRpb24gZsO8ciB6d2VpIEVpbmdhYmVuIGF1cy4gR2lidCAxIGbDvHIgWmVsbGVuIHp1csO8Y2ssIGJlaSBkZW5lbiBkYXMgZXJzdGUgUmFzdGVyIG5pY2h0IG1pdCBkZW0gendlaXRlbiBSYXN0ZXIgaWRlbnRpc2NoIGlzdCwgYW5kZXJuZmFsbHMgMC5cIixcblx0XHRub3RFcXVhbERlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiB3aXJkIGF1ZiBQaXhlbGJhc2lzIGVpbmUgcmVsYXRpb25hbGUgXFxcIk5vdCBFcXVhbCBUb1xcXCItT3BlcmF0aW9uIGbDvHIgendlaSBFaW5nYWJlbiBhdXNmw7xocnQuIFNpZSBnaWJ0IGRlbiBXZXJ0IDEgZsO8ciBQaXhlbCB6dXLDvGNrLCBiZWkgZGVuZW4gZGFzIGVyc3RlIFJhc3RlciB1bmdsZWljaCBkZW0gendlaXRlbiBSYXN0ZXIgaXN0LCB1bmQgZGVuIFdlcnQgMCBmw7xyIFBpeGVsLCBiZWkgZGVuZW4gZGFzIGVyc3RlIFJhc3RlciBnbGVpY2ggZGVtIHp3ZWl0ZW4gUmFzdGVyIGlzdC5cIixcblx0XHRwYW5zaGFycGVuaW5nTmFtZTogXCJQYW5zaGFycGVuXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1NuaXA6IFwiRGllIHLDpHVtbGljaGUgQXVmbMO2c3VuZyBlaW5lcyBNdWx0aWJhbmQtQmlsZGVzIHdpcmQgZHVyY2ggVmVyc2NobWVsemVuIG1pdCBlaW5lbSBwYW5jaHJvbWF0aXNjaGVuIEJpbGQgbWl0IGjDtmhlcmVyIEF1ZmzDtnN1bmcga8O8bnN0bGljaCB2ZXJiZXNzZXJ0LlwiLFxuXHRcdHBhbnNoYXJwZW5pbmdEZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiUGFuc2hhcnBlblxcXCIgZsO8aHJ0IGVpbiBwYW5jaHJvbWF0aXNjaGVzIEJpbGQgYnp3LiBSYXN0ZXItQmFuZCBtaXQgaG9oZXIgQXVmbMO2c3VuZyBtaXQgZWluZW0gTXVsdGliYW5kLVJhc3Rlci1EYXRhc2V0IG1pdCBnZXJpbmdlcmVyIEF1ZmzDtnN1bmcgenVzYW1tZW4uIERhZHVyY2ggd2lyZCBkaWUgcsOkdW1saWNoZSBBdWZsw7ZzdW5nIGRlcyBNdWx0aWJhbmRiaWxkZXMgZXJow7ZodC48ZGl2Pjxici8+WndlY2sgZGVzIFBhbi1TaGFycGVuaW5nIGlzdCBlcywgZWluIHZpc3VlbGwgaG9jaHdlcnRpZ2VyZXMgQmlsZCB6dSBlcnN0ZWxsZW4uIERhIGR1cmNoIGRpZXNlIFRlY2huaWtlbiBkaWUgUmFkaW9tZXRyaWUgdW5kIGRpZSBzcGVrdHJhbGVuIEVpZ2Vuc2NoYWZ0ZW4gZGVyIE11bHRpYmFuZC1CaWxkZGF0ZW4gZ2XDpG5kZXJ0IHdlcmRlbiwgbcO8c3NlbiBQYW4tU2hhcnBlbmVkLUJpbGRkYXRlbiBpbiBBbmFseXNlbiBmw7xyIGRpZSBGZXJuZXJrdW5kdW5nIG1pdCBWb3JzaWNodCB2ZXJ3ZW5kZXQgd2VyZGVuLjwvZGl2PlwiLFxuXHRcdHBhdGhBbGxvY2F0aW9uTmFtZTogXCJQZmFkZW50ZmVybnVuZ3MtWnVvcmRudW5nXCIsXG5cdFx0cGF0aEFsbG9jYXRpb25TbmlwOiBcIkJlcmVjaG5ldCBkaWUga29zdGVuZ8O8bnN0aWdzdGUgUXVlbGxlIGbDvHIgamVkZSBaZWxsZSBhdWYgQmFzaXMgZGVyIGdlcmluZ3N0ZW4gYWtrdW11bGF0aXZlbiBLb3N0ZW4gYXVmIGVpbmVyIEtvc3Rlbm9iZXJmbMOkY2hlIHVudGVyIEJlcsO8Y2tzaWNodGlndW5nIGRlciBPYmVyZmzDpGNoZW5lbnRmZXJudW5nIHp1c2FtbWVuIG1pdCBob3Jpem9udGFsZW4gdW5kIHZlcnRpa2FsZW4gS29zdGVuZmFrdG9yZW4uXCIsXG5cdFx0cGF0aEFsbG9jYXRpb25EZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIlBmYWRlbnRmZXJudW5ncy1adW9yZG51bmdcXFwiIHdpcmQgZsO8ciBqZWRlIFplbGxlIGRpZSBuw6RjaHN0ZSBRdWVsbGUgYXVmIEdydW5kbGFnZSBkZXIgZ2VyaW5nc3RlbiBha2t1bXVsYXRpdmVuIEtvc3RlbiDDvGJlciBlaW5lciBLb3N0ZW5vYmVyZmzDpGNoZSBiZXJlY2huZXQsIHdvYmVpIGRpZSBPYmVyZmzDpGNoZW5lbnRmZXJudW5nIHNvd2llIGhvcml6b250YWxlIHVuZCB2ZXJ0aWthbGUgS29zdGVuZmFrdG9yZW4gYmVyw7xja3NpY2h0aWd0IHdlcmRlbi5cIixcblx0XHRwYXRoQmFja0xpbmtOYW1lOiBcIlBmYWRlbnRmZXJudW5ncy1Sw7xja3Zlcmtuw7xwZnVuZ1wiLFxuXHRcdHBhdGhCYWNrTGlua1NuaXA6IFwiR2lidCBkZW4gTmFjaGJhcm4gYW4sIGJlaSBkZW0gZXMgc2ljaCB1bSBkaWUgbsOkY2hzdGUgWmVsbGUgYXVmIGRlbSBQZmFkIG1pdCBkZW4gZ2VyaW5nc3RlbiBha2t1bXVsYXRpdmVuIEtvc3RlbiB6dXIga29zdGVuZ8O8bnN0aWdzdGVuIFF1ZWxsZSBoYW5kZWx0LCB3b2JlaSBkaWUgT2JlcmZsw6RjaGVuZW50ZmVybnVuZyB6dXNhbW1lbiBtaXQgaG9yaXpvbnRhbGVuIHVuZCB2ZXJ0aWthbGVuIEtvc3RlbmZha3RvcmVuIGJlcsO8Y2tzaWNodGlndCB3ZXJkZW4uXCIsXG5cdFx0cGF0aEJhY2tMaW5rRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJQZmFkZW50ZmVybnVuZ3MtUsO8Y2t2ZXJrbsO8cGZ1bmdcXFwiIHdpcmQgZGVyIE5hY2hiYXIgZXJtaXR0ZWx0LCBiZWkgZGVtIGVzIHNpY2ggdW0gZGllIG7DpGNoc3RlIFplbGxlIGF1ZiBkZW0gUGZhZCBtaXQgZGVuIGdlcmluZ3N0ZW4gYWtrdW11bGF0aXZlbiBLb3N0ZW4genVyIG7DpGNoc3RnZWxlZ2VuZW4gUXVlbGxlIGhhbmRlbHQsIHdvYmVpIGRpZSBPYmVyZmzDpGNoZW5lbnRmZXJudW5nIHNvd2llIGhvcml6b250YWxlIHVuZCB2ZXJ0aWthbGUgS29zdGVuZmFrdG9yZW4gYmVyw7xja3NpY2h0aWd0IHdlcmRlbi5cIixcblx0XHRwYXRoRGlzdGFuY2VOYW1lOiBcIlBmYWRlbnRmZXJudW5nXCIsXG5cdFx0cGF0aERpc3RhbmNlU25pcDogXCJCZXJlY2huZXQgZsO8ciBqZWRlIFplbGxlIGRpZSBrbGVpbnN0ZSBha2t1bXVsYXRpdmUgS29zdGVuZW50ZmVybnVuZyB2b24gb2RlciB6dXIga29zdGVuZ8O8bnN0aWdzdGVuIFF1ZWxsZSB1bnRlciBCZXLDvGNrc2ljaHRpZ3VuZyBkZXIgT2JlcmZsw6RjaGVuZW50ZmVybnVuZyBzb3dpZSBob3Jpem9udGFsZXIgdW5kIHZlcnRpa2FsZXIgS29zdGVuZmFrdG9yZW4uXCIsXG5cdFx0cGF0aERpc3RhbmNlRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJQZmFkZW50ZmVybnVuZ1xcXCIgd2lyZCBmw7xyIGplZGUgWmVsbGUgZGllIEVudGZlcm51bmcgbWl0IGRlbiBnZXJpbmdzdGVuIGFra3VtdWxhdGl2ZW4gS29zdGVuIHp1ciBuw6RjaHN0Z2VsZWdlbmVuIFF1ZWxsZSBiZXJlY2huZXQsIHdvYmVpIGRpZSBPYmVyZmzDpGNoZW5lbnRmZXJudW5nIHNvd2llIGhvcml6b250YWxlIHVuZCB2ZXJ0aWthbGUgS29zdGVuZmFrdG9yZW4gYmVyw7xja3NpY2h0aWd0IHdlcmRlbi5cIixcblx0XHRwbHVzTmFtZTogXCJQbHVzXCIsXG5cdFx0cGx1c1NuaXA6IFwiRGllIFdlcnRlIHZvbiB6d2VpIFJhc3Rlcm4gYXVmIFplbGxlbmJhc2lzIGFkZGllcmVuLlwiLFxuXHRcdHBsdXNEZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiUGx1c1xcXCIgYWRkaWVydCBkaWUgV2VydGUgendlaWVyIFJhc3RlciBhdWYgUGl4ZWxiYXNpcy5cIixcblx0XHRwb3dlck5hbWU6IFwiUG93ZXJcIixcblx0XHRwb3dlclNuaXA6IFwiRGllIFplbGxlbndlcnRlIGluIGVpbmVtIFJhc3RlciBtaXQgZGVuIFdlcnRlbiBpbiBlaW5lbSBhbmRlcmVuIFJhc3RlciBwb3RlbnppZXJlbi5cIixcblx0XHRwb3dlckRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiUG90ZW56XFxcIiB3ZXJkZW4gZGllIFBpeGVsd2VydGUgZWluZXMgUmFzdGVycyBtaXQgZGVuIFdlcnRlbiBhdXMgZWluZW0gYW5kZXJlbiBSYXN0ZXIgcG90ZW56aWVydC5cIixcblx0XHRyYWRhckNhbGlicmF0aW9uTmFtZTogXCJSYWRhcmthbGlicmllcnVuZ1wiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25TbmlwOiBcIlJBREFSU0FULTItUsO8Y2tzdHJldXVuZyBrb252ZXJ0aWVyZW4uXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvbkRlc2M6IFwiRGllc2UgRnVua3Rpb24ga2FubiB2ZXJ3ZW5kZXQgd2VyZGVuLCB1bSBSQURBUlNBVC0yLVN5bWJvbGlrIGluIGVpbmVtIE1vc2Fpay1EYXRhc2V0IG9kZXIgYWxzIFJhc3Rlci1Qcm9kdWt0IHp1IGthbGlicmllcmVuLiBEaWUgS2FsaWJyaWVydW5nIHdpcmQgYXVmIFJhZGFyYmlsZGRhdGVuIGFuZ2V3ZW5kZXQsIGRhbWl0IGRpZSBQaXhlbHdlcnRlIGVpbmUgZWNodGUgRGFyc3RlbGx1bmcgZGVyIFJhZGFycsO8Y2tzdHJldXVuZyBzaW5kLlwiLFxuXHRcdHJhc3RlckluZm9OYW1lOiBcIlJhc3RlckluZm9cIixcblx0XHRyYXN0ZXJJbmZvU25pcDogXCJFaWdlbnNjaGFmdGVuIGRlcyBSYXN0ZXJzIHdpZSBCaXR0aWVmZSwgTm9EYXRhLVdlcnQsIFplbGxlbmdyw7bDn2UgdXN3LiDDpG5kZXJuLlwiLFxuXHRcdHJhc3RlckluZm9EZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIlJhc3RlckluZm9cXFwiIHdpcmQgZWluIERpYWxvZ2ZlbGQgZ2XDtmZmbmV0LCBkYXNzIGRpZSBFaWdlbnNjaGFmdGVuIGRlcyBSYXN0ZXItRGF0YXNldHMgYmVpbmhhbHRldCwgei4gQi4gQW56YWhsIGRlciBTcGFsdGVuIHVuZCBaZWlsZW4sIEFuemFobCBkZXIgQsOkbmRlciwgUGl4ZWx0eXAsIEF1c2RlaG51bmcgdW5kIFJhdW1iZXp1Zy4gU2llIGvDtm5uZW4gZGllc2UgRWlnZW5zY2hhZnRlbiBiZWFyYmVpdGVuLCBpbmRlbSBTaWUgZWluIFJhc3Rlci1EYXRhc2V0IGF1c3fDpGhsZW4sIGRhcyBhbHMgVm9ybGFnZSB2ZXJ3ZW5kZXQgd2VyZGVuIHNvbGwuIFwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNOYW1lOiBcIkF0dHJpYnV0ZSByYXN0ZXJuXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc1NuaXA6IFwiUmVpY2hlcnQgZWluIFJhc3RlciBtaXQgenVzw6R0emxpY2hlbiBCw6RuZGVybiBhbiwgZGllIGF1cyBXZXJ0ZW4gYmVzdGltbXRlciBBdHRyaWJ1dGUgZWluZXIgZXh0ZXJuZW4gVGFiZWxsZSBvZGVyIGVpbmVzIEZlYXR1cmUtU2VydmljZSBhYmdlbGVpdGV0IHd1cmRlbi5cIixcblx0XHRyYXN0ZXJpemVBdHRyaWJ1dGVzRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIkF0dHJpYnV0ZSByYXN0ZXJuXFxcIiByZWljaGVydCBlaW4gUmFzdGVyIGR1cmNoIEhpbnp1ZsO8Z2VuIHZvbiBCw6RuZGVybiBhbiwgZGllIGF1cyBXZXJ0ZW4gYmVzdGltbXRlciBBdHRyaWJ1dGUsIGF1cyBlaW5lciBleHRlcm5lbiBUYWJlbGxlIG9kZXIgYXVzIGVpbmVtIEZlYXR1cmUtU2VydmljZSBhYmdlbGVpdGV0IHd1cmRlbi4gU2llIGvDtm5uZW4gb3B0aW9uYWwgZWluIFpvbmVuLVJhc3RlciB1bmQgZGFzIHZlcmtuw7xwZnRlIFpvbmVuLUlELUF0dHJpYnV0IGFuZ2ViZW4sIHVtIGRpZSByZWdpb25lbmJhc2llcnRlIFN1Y2hlIHp1IGFrdGl2aWVyZW4uXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzTmFtZTogXCJGZWF0dXJlcyByYXN0ZXJuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzU25pcDogXCJLb252ZXJ0aWVydCBGZWF0dXJlcyBpbiBSYXN0ZXIuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzRGVzYzogXCJEaWVzZSBGdW5rdGlvbiBrb252ZXJ0aWVydCBQb2x5Z29uLSwgUG9seWxpbmUtLCB1bmQgUG9pbnQtRmVhdHVyZS1DbGFzcy1EYXRlbiBpbiBlaW5lbiBSYXN0ZXItTGF5ZXIuPGRpdj48YnIvPkZlYXR1cmVzIHdlcmRlbiBQaXhlbHdlcnRlIGJhc2llcmVuZCBhdWYgZGVyIE9CSkVDVElEIGRlcyBGZWF0dXJlcyB6dWdld2llc2VuIChTdGFuZGFyZGVpbnN0ZWxsdW5nKS4gRGllIFBpeGVsd2VydGUga8O2bm5lbiBvcHRpb25hbCBhdWYgZWluZW0gYmVudXR6ZXJkZWZpbmllcnRlbiBXZXJ0ZWZlbGQgaW4gZGVyIEF0dHJpYnV0dGFiZWxsZSBkZXMgRWluZ2FiZS1GZWF0dXJlcyBiYXNpZXJlbi48L2Rpdj5cIixcblx0XHRyZWNhc3ROYW1lOiBcIsOcYmVyYXJiZWl0ZW5cIixcblx0XHRyZWNhc3RTbmlwOiBcIsOEbmRlcnQgZGllIFBhcmFtZXRlciBlaW5lciBGdW5rdGlvbnNrZXR0ZSBpbiBlaW5lbSBNb3NhaWstRGF0YXNldCBvZGVyIEltYWdlLVNlcnZpY2UuIERpZSBGdW5rdGlvbiB3aXJkIGjDpHVmaWcgbWl0IExBUy1EYXRhc2V0cyB2ZXJ3ZW5kZXQsIHVtIGRpZSBFcnN0ZWxsdW5nIGdlc29uZGVydGVyIE1vc2Fpay1EYXRhc2V0cyBmw7xyIHZlcnNjaGllZGVuZSBUZXJyYWluLURhcnN0ZWxsdW5nZW4genUgdmVybWVpZGVuLlwiLFxuXHRcdHJlY2FzdERlc2M6IFwiRGllIEZ1bmt0aW9uIFxcXCLDnGJlcmFyYmVpdGVuXFxcIiB3aXJkIHZlcndlbmRldCwgdW0gZGllIGluIGVpbmVtIE1vc2Fpay1EYXRhc2V0IG9kZXIgSW1hZ2UtU2VydmljZSB2ZXJ3ZW5kZXRlbiBGdW5rdGlvbnNwYXJhbWV0ZXIgZHluYW1pc2NoIHp1IMOkbmRlcm4sIG9obmUgZGllIMOEbmRlcnVuZ2VuIGFuIGRlbiBFbGVtZW50ZW4gcGh5c2lzY2ggYmVpenViZWhhbHRlbi5cIixcblx0XHRyZWdpb25Hcm91cE5hbWU6IFwiR3J1cHBpZXJ1bmcgenUgUmVnaW9uZW5cIixcblx0XHRyZWdpb25Hcm91cFNuaXA6IFwiRsO8ciBqZWRlIFplbGxlIGluIGRlciBBdXNnYWJlIHdpcmQgZGllIFp1Z2Vow7ZyaWdrZWl0IGRlciBaZWxsZSB6dSBlaW5lciB2ZXJidW5kZW5lbiBSZWdpb24gZXJtaXR0ZWx0LiBKZWRlciBSZWdpb24gd2lyZCBlaW5lIGVpbmRldXRpZ2UgTnVtbWVyIHp1Z2V3aWVzZW4uXCIsXG5cdFx0cmVnaW9uR3JvdXBEZXNjOiBcIk1pdCBkZXIgZ2xvYmFsZW4gRnVua3Rpb24gXFxcIkdydXBwaWVydW5nIHp1IFJlZ2lvbmVuXFxcIiB3aXJkIGbDvHIgamVkZSBaZWxsZSBpbiBkZXIgQXVzZ2FiZSBkaWUgSWRlbnRpdMOkdCBkZXIgdmVyYnVuZGVuZW4gUmVnaW9uIGF1ZmdlemVpY2huZXQsIHp1IGRlciBkaWVzZSBaZWxsZSBnZWjDtnJ0LiBKZWRlciBSZWdpb24gd2lyZCBlaW5lIGVpbmRldXRpZ2UgTnVtbWVyIHp1Z2V3aWVzZW4uPGRpdj48YnIvPkRpZSBlcnN0ZSBnZXNjYW5udGUgUmVnaW9uIGVyaMOkbHQgZGVuIFdlcnQgMSwgZGllIHp3ZWl0ZSBkZW4gV2VydCAyIHVzdy4sIGJpcyBhbGxlbiBSZWdpb25lbiBlaW4gV2VydCB6dWdld2llc2VuIHd1cmRlLiBEZXIgU2NhbiBlcmZvbGd0IHZvbiBsaW5rcyBuYWNoIHJlY2h0cywgdm9uIG9iZW4gbmFjaCB1bnRlbi4gRGllIGRlbiBBdXNnYWJlLVpvbmVuIHp1Z2V3aWVzZW5lbiBXZXJ0ZSBow6RuZ2VuIGRhdm9uIGFiLCB3YW5uIHNpZSBpbSBTY2Fudm9yZ2FuZyBnZWZ1bmRlbiB3dXJkZW4uPC9kaXY+XCIsXG5cdFx0cmVnaW9uR3Jvd05hbWU6IFwiUmVnaW9uIEdyb3dcIixcblx0XHRyZWdpb25Hcm93U25pcDogXCJCaWxkZXQgUmVnaW9uZW4gYXVzIFNjaHdlcnB1bmt0ZW4uXCIsXG5cdFx0cmVnaW9uR3Jvd0Rlc2M6IFwiRGllIEZ1bmt0aW9uIFxcXCJSZWdpb24gR3Jvd1xcXCIgZ3J1cHBpZXJ0IGJlbmFjaGJhcnRlIFBpeGVsIGdlbcOkw58gZGVtIGltIEF1c2dhbmdzcHVua3QgYW5nZWdlYmVuZW4gUmFkaXVzLiBEZW4gUGl4ZWwtIG9kZXIgT2JqZWt0Z3J1cHBlbiB3aXJkIGVpbiBiZXN0aW1tdGVyIEbDvGxsd2VydCB6dWdld2llc2VuLlwiLFxuXHRcdHJlbWFwTmFtZTogXCJOZXV6dW9yZG51bmdcIixcblx0XHRyZW1hcFNuaXA6IFwiUGl4ZWx3ZXJ0ZSBkdXJjaCBadXdlaXNlbiBuZXVlciBXZXJ0ZSB6dSBQaXhlbHdlcnRiZXJlaWNoZW4gb2RlciBkdXJjaCBWZXJ3ZW5kZW4gZWluZXIgZXh0ZXJuZW4gVGFiZWxsZSDDpG5kZXJuLlwiLFxuXHRcdHJlbWFwRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIk5ldXp1b3JkbnVuZ1xcXCIgZXJtw7ZnbGljaHQgZXMgSWhuZW4sIGRpZSBQaXhlbHdlcnRlIGRlciBSYXN0ZXItRGF0ZW4genUgw6RuZGVybiBvZGVyIHp1IHJla2xhc3NpZml6aWVyZW4uICBEaWVzIGthbm4gZXJyZWljaHQgd2VyZGVuLCBpbmRlbSBmw7xyIGRpZSBadW9yZG51bmcgenUgQXVzZ2FiZXBpeGVsd2VydGVuIGVpbiBQaXhlbHdlcnRlYmVyZWljaCBhbmdlZ2ViZW4gb2RlciBlaW5lIFRhYmVsbGUgdmVyd2VuZGV0IHdpcmQuXCIsXG5cdFx0cmVwcm9qZWN0TmFtZTogXCJOZXUgcHJvaml6aWVyZW5cIixcblx0XHRyZXByb2plY3RTbmlwOiBcIsOEbmRlcnQgZGllIFByb2pla3Rpb24gZWluZXMgUmFzdGVyLURhdGFzZXRzLCBNb3NhaWstRGF0YXNldHMgb2RlciBSYXN0ZXItRWxlbWVudHMgaW4gZWluZW0gTW9zYWlrLURhdGFzZXQuIFNpZSBrYW5uIGF1Y2ggenVtIFJlc2FtcGxpbmcgZGVyIERhdGVuIGluIGVpbmUgbmV1ZSBaZWxsZW5ncsO2w59lIHVuZCB6dW0gRGVmaW5pZXJlbiBlaW5lcyBVcnNwcnVuZ3MgdmVyd2VuZGV0IHdlcmRlbi5cIixcblx0XHRyZXByb2plY3REZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIk5ldSBwcm9qaXppZXJlblxcXCIgd2lyZCBkaWUgUHJvamVrdGlvbiBlaW5lcyBSYXN0ZXItRGF0YXNldHMsIE1vc2Fpay1EYXRhc2V0cyBvZGVyIFJhc3Rlci1FbGVtZW50cyBpbiBlaW5lbSBNb3NhaWstRGF0YXNldCBnZcOkbmRlcnQuIFNpZSBrYW5uIGF1Y2ggenVtIFJlc2FtcGxpbmcgZGVyIERhdGVuIGluIGVpbmUgbmV1ZSBaZWxsZW5ncsO2w59lIHVuZCB6dW0gRGVmaW5pZXJlbiBlaW5lcyBVcnNwcnVuZ3MgdmVyd2VuZGV0IHdlcmRlbi48ZGl2Pjxici8+RGllIEZ1bmt0aW9uIFxcXCJOZXUgcHJvaml6aWVyZW5cXFwiIGthbm4gYmVpbSBFcnN0ZWxsZW4gZWluZXMgQ2FjaGUgYXVzIGVpbmVtIFJhc3RlciBvZGVyIE1vc2Fpay1EYXRhc2V0IHZlcndlbmRldCB3ZXJkZW4sIGRhcyBzaWNoIG5pY2h0IGluIGRlciBlcmZvcmRlcmxpY2hlbiBQcm9qaXppZXJ1bmcgYmVmaW5kZXQuIFdlbm4gYmVpc3BpZWxzd2Vpc2UgZWluIGdlY2FjaHRlciBJbWFnZS1TZXJ2aWNlIGVyc3RlbGx0IHdpcmQsIGRlciBpbiBBbndlbmR1bmdlbiBtaXQgYW5kZXJlbiBnZWNhY2h0ZW4gU2VydmljZXMgaW50ZWdyaWVydCBpc3QsIGlzdCBlcyB3aWNodGlnLCBkYXNzIHNpZSBzaWNoIGFsbGUgaW4gZGVyc2VsYmVuIFByb2pla3Rpb24gYmVmaW5kZW4uIERhYmVpIGhhbmRlbHQgZXMgc2ljaCBow6R1ZmlnIHVtIGVpbmUgV2ViIE1lcmNhdG9yLVByb2pla3Rpb24uIERhIGRhcyBNb3NhaWstRGF0YXNldCBuaWNodCBuZXUgcHJvaml6aWVydCB3ZXJkZW4ga2FubiwgaGFiZW4gU2llIHp3ZWkgTcO2Z2xpY2hrZWl0ZW46IEVudHdlZGVyIGVyc3RlbGxlbiBTaWUgaW4gZGVyIGVyZm9yZGVybGljaGVuIFByb2pla3Rpb24gZWluIHJlZmVyZW56aWVydGVzIE1vc2Fpay1EYXRhc2V0IGF1cyBJaHJlbSBNb3NhaWstRGF0YXNldCBvZGVyIFNpZSBmw7xnZW4gZGVyIEZ1bmt0aW9uc2tldHRlIGRlcyBNb3NhaWstRGF0YXNldHMgZGllIEZ1bmt0aW9uIFxcXCJOZXUgcHJvaml6aWVyZW5cXFwiIGhpbnp1LiBFaW4gd2VpdGVyZXMgQmVpc3BpZWwgaXN0IGRpZSBWZXJ3ZW5kdW5nIGRpZXNlciBGdW5rdGlvbiBhdWYgZGVtIFJhc3Rlci1FbGVtZW50IGluIGVpbmVtIE1vc2Fpay1EYXRhc2V0LiBCZWkgVmVyd2VuZHVuZyBkZXIgRnVua3Rpb24gXFxcIkdlY2FjaHRlIFJhc3RlclxcXCIga8O2bm5lbiBTaWUgZGllIEZ1bmt0aW9uIFxcXCJOZXUgcHJvaml6aWVyZW5cXFwiIHNvIGVpbmbDvGdlbiwgZGFzcyBkZXIgQ2FjaGUgaW4gZGVyIG5ldWVuIFByb2pla3Rpb24gZXJzdGVsbHQgd2lyZC4gUmFzdGVyLUVsZW1lbnRlIGluIGVpbmVtIE1vc2Fpay1EYXRhc2V0IGvDtm5uZW4gZ2VjYWNodCB3ZXJkZW4sIHdlbm4gZGllIGRhcyBWZXJhcmJlaXR1bmdzYXVma29tbWVuIGhvY2ggaXN0IHVuZCBTaWUgdmVyc3VjaGVuLCBlaW5lbiBzY2huZWxsZW4gSW1hZ2UtU2VydmljZSB6dSB2ZXLDtmZmZW50bGljaGVuLCBvaG5lIGRlbiBnZXNhbXRlbiBJbWFnZS1TZXJ2aWNlIHp1IGNhY2hlbi48L2Rpdj5cIixcblx0XHRyZXNhbXBsZU5hbWU6IFwiUmVzYW1wbGluZ1wiLFxuXHRcdHJlc2FtcGxlU25pcDogXCJEaWUgWmVsbGVuZ3LDtsOfZSBlaW5lcyBSYXN0ZXJzIMOkbmRlcm4uXCIsXG5cdFx0cmVzYW1wbGVEZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiUmVzYW1wbGluZ1xcXCIgw6RuZGVydCBkaWUgWmVsbGVuZ3LDtsOfZSwgZGVuIFJlc2FtcGxpbmctVHlwIG9kZXIgYmVpZGVzLjxkaXY+PGJyLz5EaWUgRnVua3Rpb24gXFxcIlJlc2FtcGxpbmdcXFwiIHNvbGx0ZSBudXIgYmVpIHNwZXppZWxsZW4gQmVyZWNobnVuZ3NhbmZvcmRlcnVuZ2VuIHZlcndlbmRldCB3ZXJkZW4uIEJlaXNwaWVsc3dlaXNlIGJlaSBkZXIgQmVyZWNobnVuZyB2b24gTWFnbml0dWRlLVJpY2h0dW5nIGbDvHIgV2luZCBvZGVyIFN0csO2bXVuZywgZGllIGVpbiBSZXNhbXBsaW5nIGF1cyBkZXIgUXVlbGxhdWZsw7ZzdW5nIGVyZm9yZGVydC48L2Rpdj5cIixcblx0XHRyb3VuZERvd25OYW1lOiBcIlJvdW5kIERvd25cIixcblx0XHRyb3VuZERvd25TbmlwOiBcIkbDvHIgamVkZSBaZWxsZSBpbiBlaW5lbSBSYXN0ZXIgd2lyZCBkaWUgbsOkY2hzdG5pZWRyaWdlcmUgR2FuenphaGwgenVyw7xja2dlZ2ViZW4sIGRpZSBhbHMgR2xlaXRrb21tYXphaGwgYW5nZWdlYmVuIHdpcmQuXCIsXG5cdFx0cm91bmREb3duRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIlJvdW5kIGRvd25cXFwiIGdpYnQgZsO8ciBqZWRlcyBQaXhlbCBpbiBlaW5lbSBSYXN0ZXIgZGllIG7DpGNoc3RuaWVkcmlnZXJlIGdhbnplIFphaGwgYWxzIEdsZWl0a29tbWF3ZXJ0IHp1csO8Y2suXCIsXG5cdFx0cm91bmRVcE5hbWU6IFwiUm91bmQgVXBcIixcblx0XHRyb3VuZFVwU25pcDogXCJHaWJ0IGbDvHIgamVkZSBaZWxsZSBpbiBlaW5lbSBSYXN0ZXIgZGVuIG7DpGNoc3Row7ZoZXJlbiBnYW56emFobGlnZW4gV2VydCBhbHMgR2xlaXRrb21tYXdlcnQgenVyw7xjay5cIixcblx0XHRyb3VuZFVwRGVzYzogXCJcXFwiUm91bmQgZG93blxcXCIgZ2lidCBmw7xyIGplZGVzIFBpeGVsIGluIGVpbmVtIFJhc3RlciBkaWUgbsOkY2hzdGjDtmhlcmUgZ2FuemUgWmFobCBhbHMgR2xlaXRrb21tYXdlcnQgenVyw7xjay5cIixcblx0XHRzZWdtZW50TWVhblNoaWZ0TmFtZTogXCJNZWFuIFNoaWZ0LVNlZ21lbnRpZXJ1bmdcIixcblx0XHRzZWdtZW50TWVhblNoaWZ0U25pcDogXCJCZW5hY2hiYXJ0ZSBQaXhlbCBtaXQgw6RobmxpY2hlbiBTcGVrdHJhbGVpZ2Vuc2NoYWZ0ZW4gaW4gU2VnbWVudGUgZ3J1cHBpZXJlbi5cIixcblx0XHRzZWdtZW50TWVhblNoaWZ0RGVzYzogXCJNaXQgZGllc2VyIEZ1bmt0aW9uIHdlcmRlbiBPYmpla3RlLCBGZWF0dXJlcyBvZGVyIFNlZ21lbnRlIGluIElocmVuIEJpbGRkYXRlbiBpZGVudGlmaXppZXJ0LCBpbmRlbSBiZW5hY2hiYXJ0ZSBQaXhlbCwgZGllIMOkaG5saWNoZSBTcGVrdHJhbGVpZ2Vuc2NoYWZ0ZW4gb2RlciByw6R1bWxpY2hlIEVpZ2Vuc2NoYWZ0ZW4gYXVmd2Vpc2VuLCBncnVwcGllcnQgd2VyZGVuLiBadXIgYmVzc2VyZW4gQWJsZWl0dW5nIHZvbiBpbnRlcmVzc2FudGVuIEZlYXR1cmVzIGvDtm5uZW4gU2llIGRpZSBTdMOkcmtlIGRlciByw6R1bWxpY2hlbiB1bmQgc3Bla3RyYWxlbiBHbMOkdHR1bmcgc2VsYnN0IGJlc3RpbW1lbi5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25OYW1lOiBcIlNlbnRpbmVsLTEgUmFkaW9tZXRyaXNjaGUgS2FsaWJyaWVydW5nXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uU25pcDogXCJVbnRlcnNjaGllZGxpY2hlIFR5cGVuIGRlciByYWRpb21ldHJpc2NoZW4gS2FsaWJyaWVydW5nIGbDvHIgU2VudGluZWwtMS1EYXRlbiBhdXNmw7xocmVuLlwiLFxuXHRcdHMxUmFkaW9tZXRyaWNDYWxpYnJhdGlvbkRlc2M6IFwiRGllc2UgUmFzdGVyLUZ1bmt0aW9uIGbDvGhydCBkcmVpIHZlcnNjaGllZGVuZSBLYWxpYnJpZXJ1bmdlbiBmw7xyIFNlbnRpbmVsLTEtRGF0YXNldHMgZHVyY2gsIGVpbnNjaGxpZcOfbGljaCBCZXRhLU5vdWdodCB1bmQgR2FtbWEtTm91Z2h0LCB1bmQgZ2lidCBkYXMga2FsaWJyaWVydGUgRGF0YXNldCBhdXMuIFppZWwgZGVyIFNBUi1LYWxpYnJpZXJ1bmcgaXN0IGVzLCBCaWxkZGF0ZW4genUgbGllZmVybiwgaW4gZGVuZW4gUGl4ZWx3ZXJ0ZSBkaXJla3QgbWl0IGRlciBSYWRhcnLDvGNrc3RyZXV1bmcgZGVyIFN6ZW5lIGluIEJlemllaHVuZyBnZXNldHp0IHdlcmRlbiBrw7ZubmVuLiBPYndvaGwgbmljaHQga2FsaWJyaWVydGUgU0FSLUJpbGRlciBmw7xyIGRlbiBxdWFsaXRhdGl2ZW4gRWluc2F0eiBhdXNyZWljaGVuZCBzaW5kLCBzaW5kIGthbGlicmllcnRlIFNBUi1CaWxkZXIgZsO8ciBkaWUgcXVhbnRpdGF0aXZlIE51dHp1bmcgdm9uIFNBUi1EYXRlbiB1bmVybMOkc3NsaWNoLjxkaXY+PGJyLz5FaW5lIHR5cGlzY2hlIFNBUi1EYXRlbnZlcmFyYmVpdHVuZywgZGllIExldmVsLTEtQmlsZGVyIGVyemV1Z3QsIGJlaW5oYWx0ZXQga2VpbmUgcmFkaW9tZXRyaXNjaGVuIEtvcnJla3R1cmVuLCB1bmQgZXMgYmxlaWJ0IGVpbmUgc2lnbmlmaWthbnRlIHJhZGlvbWV0cmlzY2hlIFZlcnplcnJ1bmcuIERhaGVyIGlzdCBlcyBub3R3ZW5kaWcsIHJhZGlvbWV0cmlzY2hlIEtvcnJla3R1cmVuIGF1ZiBTQVItQmlsZGVyIGFuenV3ZW5kZW4sIGRhbWl0IGRpZSBQaXhlbHdlcnRlIGRlciBCaWxkZXIgdGF0c8OkY2hsaWNoIGRpZSBSYWRhcnLDvGNrc3RyZXV1bmcgZGVyIHJlZmxla3RpZXJlbmRlbiBPYmVyZmzDpGNoZSBkYXJzdGVsbGVuLiBEaWUgcmFkaW9tZXRyaXNjaGUgS29ycmVrdHVyIGlzdCBhdWNoIGbDvHIgZGVuIFZlcmdsZWljaCB2b24gU0FSLUJpbGRlcm4gbm90d2VuZGlnLCBkaWUgbWl0IHZlcnNjaGllZGVuZW4gU2Vuc29yZW4gYXVmZ2Vub21tZW4gd3VyZGVuIG9kZXIgZGllIHZvbiBkZW1zZWxiZW4gU2Vuc29yIHp1IHZlcnNjaGllZGVuZW4gWmVpdGVuLCBpbiB2ZXJzY2hpZWRlbmVuIE1vZGkgZXJmYXNzdCBvZGVyIHZvbiB2ZXJzY2hpZWRlbmVuIFByb3plc3NvcmVuIHZlcmFyYmVpdGV0IHd1cmRlbi48L2Rpdj5cIixcblx0XHRzMVRoZXJtYWxOb2lzZVJlbW92YWxOYW1lOiBcIlNlbnRpbmVsLTEgV8Okcm1lcmF1c2NoZW4gZW50ZmVybmVuXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsU25pcDogXCJXw6RybWVyYXVzY2hlbiBhdXMgU2VudGluZWwtMS1EYXRlbiBlbnRmZXJuZW4uXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsRGVzYzogXCJEaWUgS29ycmVrdHVyIGRlcyBXw6RybWVyYXVzY2hlbnMga2FubiBhdWYgU2VudGluZWwtMSBMZXZlbC0xIFNpbmdsZSBMb29rIENvbXBsZXggKFNMQyktUHJvZHVrdGUgc293aWUgYXVmIExldmVsLTEgR3JvdW5kIFJhbmdlIERldGVjdGlvbiAoR1JEKS1Qcm9kdWt0ZSBhbmdld2VuZGV0IHdlcmRlbiwgZGllIG5vY2ggbmljaHQga29ycmlnaWVydCB3dXJkZW4uIERlciBCZWFyYmVpdGVyIGthbm4gZGllc2UgS29ycmVrdHVyIGF1Y2ggYXVmIEdydW5kbGFnZSBkZXIgUHJvZHVrdC1Bbm5vdGF0aW9ucyBlbnRmZXJuZW4sIHVtIGRhcyBSYXVzY2hzaWduYWwgd2llZGVyIGVpbnp1YnJpbmdlbiwgZGFzIHp1ciBFcnN0ZWxsdW5nIGRlcyBPcmlnaW5hbHByb2R1a3RzIGVudGZlcm50IHd1cmRlLiBQcm9kdWt0LUFubm90YXRpb25zIHdlcmRlbiBlbnRzcHJlY2hlbmQgYWt0dWFsaXNpZXJ0LCB1bSBlaW5lIGVybmV1dGUgQW53ZW5kdW5nIGRlciBLb3JyZWt0dXIgenUgZXJtw7ZnbGljaGVuLiBcIixcblx0XHRzZXROdWxsTmFtZTogXCJBdWYgTlVMTCBzZXR6ZW5cIixcblx0XHRzZXROdWxsU25pcDogXCJcXFwiQXVmIE5VTEwgc2V0emVuXFxcIiBsZWd0IGbDvHIgaWRlbnRpZml6aWVydGUgWmVsbHBvc2l0aW9uZW4gYXVmIEdydW5kbGFnZSBlaW5lcyBhbmdlZ2ViZW5lbiBLcml0ZXJpdW1zIGRlbiBXZXJ0IFxcXCJOb0RhdGFcXFwiIGZlc3QuIFxcXCJOb0RhdGFcXFwiIHdpcmQgenVyw7xja2dlZ2ViZW4sIHdlbm4gZWluZSBCZWRpbmd1bmdzYXVzd2VydHVuZyBcXFwidHJ1ZVxcXCIgKHdhaHIpIGVyZ2lidCwgdW5kIGVpbiBkdXJjaCBlaW4gYW5kZXJlcyBSYXN0ZXIgYW5nZWdlYmVuZXIgV2VydCB3aXJkIHp1csO8Y2tnZWdlYmVuLCB3ZW5uIGRpZSBCZWRpbmd1bmdzYXVzd2VydHVuZyBcXFwiZmFsc2VcXFwiIChmYWxzY2gpIGVyZ2lidC5cIixcblx0XHRzZXROdWxsRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJBdWYgTlVMTCBzZXR6ZW5cXFwiIHdlcmRlbiBkaWUgaWRlbnRpZml6aWVydGVuIFBpeGVsIGJhc2llcmVuZCBhdWYgZGVuIGFuZ2VnZWJlbmVuIEtyaXRlcmllbiBhdWYgXFxcIk5vRGF0YVxcXCIgZmVzdGdlbGVndC4gXFxcIk5vRGF0YVxcXCIgd2lyZCB6dXLDvGNrZ2VnZWJlbiwgd2VubiBlaW5lIEJlZGluZ3VuZ3NhdXN3ZXJ0dW5nIFxcXCJ0cnVlXFxcIiAoMSkgZXJnaWJ0LiBEZXIgaW0gRmFsc2UtUmFzdGVyIGFuZ2VnZWJlbmUgV2VydCB3aXJkIHp1csO8Y2tnZWdlYmVuLCB3ZW5uIGRpZSBCZWRpbmd1bmdzYXVzd2VydHVuZyBcXFwiZmFsc2VcXFwiICgwKSBlcmdpYnQuIERpZXNlcyBLcml0ZXJpdW0gd2lyZCBkdXJjaCBkaWUgQXVzZ2FiZSBlaW5lciBsb2dpc2NoZW4gbWF0aGVtYXRpc2NoZW4gRnVua3Rpb24gZmVzdGdlbGVndCwgZGllIGRlbSBFaW5nYWJlLVJhc3RlciBlbnRzcHJpY2h0LlwiLFxuXHRcdHNoYWRlZFJlbGllZk5hbWU6IFwiR2VzY2h1bW1lcnRlcyBSZWxpZWZcIixcblx0XHRzaGFkZWRSZWxpZWZTbmlwOiBcIkVpbmUgTXVsdGliYW5kLSwgZmFyYmNvZGllcnRlLCAzRC1EYXJzdGVsbHVuZyBkZXIgT2JlcmZsw6RjaGUgZXJzdGVsbGVuLCB3b2JlaSBkaWUgcmVsYXRpdmUgUG9zaXRpb24gZGVyIFNvbm5lIGJlaW0gU2NodW1tZXJuIGRlcyBCaWxkZXMgYmVyw7xja3NpY2h0aWd0IHdpcmQuXCIsXG5cdFx0c2hhZGVkUmVsaWVmRGVzYzogXCJEdXJjaCBkaWUgRnVua3Rpb24gXFxcIkdlc2NodW1tZXJ0ZXMgUmVsaWVmXFxcIiB3aXJkIGVpbmUgM0QtRmFyYmRhcnN0ZWxsdW5nIGRlcyBUZXJyYWlucyBlcnN0ZWxsdCwgaW5kZW0gZGllIEJpbGRlciBhdXMgZGVuIE1ldGhvZGVuIFxcXCJIw7ZoZW5jb2RpZXJ0XFxcIiB1bmQgXFxcIlNjaHVtbWVydW5nXFxcIiB6dXNhbW1lbmdlZsO8aHJ0IHdlcmRlbi4gRGllc2UgRnVua3Rpb24gdmVyd2VuZGV0IGRpZSBFaWdlbnNjaGFmdGVuIHZvbiBIw7ZoZSB1bmQgQXppbXV0LCB1bSBkaWUgUG9zaXRpb24gZGVyIFNvbm5lIGFuenVnZWJlbi48ZGl2Pjxici8+PC9kaXY+XCIsXG5cdFx0c2luSE5hbWU6IFwiU2luSFwiLFxuXHRcdHNpbkhTbmlwOiBcIkRlbiBTaW51cyBIeXBlcmJvbGljdXMgdm9uIFplbGxlbiBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmVuLlwiLFxuXHRcdHNpbkhEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2lyZCBkZXIgU2ludXMgSHlwZXJib2xpY3VzIGRlciBQaXhlbCBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmV0LlwiLFxuXHRcdHNpbk5hbWU6IFwiU2luXCIsXG5cdFx0c2luU25pcDogXCJEZW4gU2ludXMgdm9uIFplbGxlbiBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmVuLlwiLFxuXHRcdHNpbkRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiB3aXJkIGRlciBTaW51cyBkZXIgUGl4ZWwgaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5ldC5cIixcblx0XHRzbG9wZU5hbWU6IFwiTmVpZ3VuZ1wiLFxuXHRcdHNsb3BlU25pcDogXCJEaWUgw4RuZGVydW5nc3JhdGUgdm9uIGVpbmVtIFBpeGVsd2VydCBpbSBWZXJnbGVpY2ggenUgc2VpbmVuIE5hY2hiYXJuIGJlcmVjaG5lbi5cIixcblx0XHRzbG9wZURlc2M6IFwiTWl0IGRpZXNlciBSYXN0ZXItRnVua3Rpb24gd2lyZCBkaWUgTmVpZ3VuZyBiZXJlY2huZXQsIGRpZSBkZXIgw4RuZGVydW5nc3JhdGUgZGVyIEjDtmhlIGluIGRlbiBlaW56ZWxuZW4gWmVsbGVuIGRlcyBkaWdpdGFsZW4gSMO2aGVubW9kZWxscyAoRGlnaXRhbCBFbGV2YXRpb24gTW9kZWwsIERFTSkgZW50c3ByaWNodC4gRGllcyBpc3QgZGllIGVyc3RlIEFibGVpdHVuZyBlaW5lcyBERU0uPGRpdj48YnIvPkRpZXNlIEZ1bmt0aW9uIHZlcndlbmRldCBlaW5lIGJlc2NobGV1bmlndGUgYXRhbigpLUZ1bmt0aW9uLiBTaWUgaXN0IHNlY2hzIG1hbCBzY2huZWxsZXIgdW5kIGRlciBBbm7DpGhlcnVuZ3NmZWhsZXIgYmV0csOkZ3QgaW1tZXIgd2VuaWdlciBhbHMgMCwzIEdyYWQuPC9kaXY+XCIsXG5cdFx0c3BlY2tsZU5hbWU6IFwiU3BlY2tsZVwiLFxuXHRcdHNwZWNrbGVTbmlwOiBcIkZpbHRlciBiZXJlaXRzdGVsbGVuLCB1bSBTQVItRGF0YXNldHMgdm9tIFJhdXNjaGVuIHp1IGJlcmVpbmlnZW4uXCIsXG5cdFx0c3BlY2tsZURlc2M6IFwiU3BlY2tsZSBpc3QgZGFzIEhvY2hmcmVxdWVuenJhdXNjaGVuIGF1ZiBSYWRhcmRhdGVuLiBEaWUgdm9uIFNBUi1TeXN0ZW1lbiAoU3ludGhldGljIEFwZXJ0dXJlIFJhZGFyKSBnZW5lcmllcnRlbiBCaWxkZXIgc2luZCBhdWZncnVuZCBkZXIgVmVyYXJiZWl0dW5nIHplcnN0cmV1dGVyIFNpZ25hbGUgdW5kIEludGVyZmVyZW56ZW4gZWxla3Ryb21hZ25ldGlzY2hlciBXZWxsZW4sIGRpZSB2b24gT2JlcmZsw6RjaGVuIG9kZXIgT2JqZWt0ZW4genVyw7xja2dld29yZmVuIHdlcmRlbiwgaW4gaMO2Y2hzdGVtIE1hw59lIFNwZWNrbGluZy1FZmZla3RlbiB1bnRlcndvcmZlbi4gRGllc2UgRnVua3Rpb24gZmlsdGVydCBkYXMgUmFkYXItRGF0YXNldCBtaXQgU3BlY2tsaW5nIHVuZCBnbMOkdHRldCBkYXMgUmF1c2NoZW4sIHdvYmVpIEthbnRlbiBvZGVyIHNjaGFyZmUgRmVhdHVyZXMgaW0gQmlsZCBlcmhhbHRlbiBibGVpYmVuLlwiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvbk5hbWU6IFwiU3Bla3RyYWxrb252ZXJ0aWVydW5nXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uU25pcDogXCJXZW5kZXQgZWluZSBNYXRyaXggYXVmIGVpbiBNdWx0aWJhbmQtQmlsZCBhbi5cIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25EZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiU3Bla3RyYWxrb252ZXJ0aWVydW5nXFxcIiB3ZW5kZXQgZWluZSBNYXRyaXggYXVmIGVpbiBNdWx0aWJhbmQtQmlsZCBhbiwgdW0gZGllIEZhcmJ3ZXJ0ZSBkZXIgQXVzZ2FiZSB6dSBiZWVpbmZsdXNzZW4uPGRpdj48YnIvPkJsYXVlIELDpG5kZXIgd2VyZGVuIHZvbiBlaW5pZ2VuIFNlbnNvcmVuIGF1ZmdydW5kIGRlcyBuaWVkcmlnZW4gU2lnbmFsLVJhdXNjaC1WZXJow6RsdG5pc3NlcyBuaWNodCBlcmZhc3N0LiBEaWVzZSBGdW5rdGlvbiBrYW5uIHZlcndlbmRldCB3ZXJkZW4sIHVtIHouIEIuIGVpbiBmYWxzY2hlcyBJbmZyYXJvdGZhcmJiaWxkIGluIGVpbiBQc2V1ZG9mYXJiYmlsZCB6dSBrb252ZXJ0aWVyZW4uPC9kaXY+XCIsXG5cdFx0c3F1YXJlUm9vdE5hbWU6IFwiU3F1YXJlIFJvb3RcIixcblx0XHRzcXVhcmVSb290U25pcDogXCJEaWUgUXVhZHJhdHd1cnplbCBkZXIgWmVsbGVud2VydGUgaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5lbi5cIixcblx0XHRzcXVhcmVSb290RGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJTcXVhcmUgUm9vdFxcXCIgd2lyZCBkaWUgUXVhZHJhdHd1cnplbCBkZXIgUGl4ZWx3ZXJ0ZSBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmV0LlwiLFxuXHRcdHNxdWFyZU5hbWU6IFwiU3F1YXJlXCIsXG5cdFx0c3F1YXJlU25pcDogXCJEYXMgUXVhZHJhdCBkZXIgWmVsbGVud2VydGUgaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5lbi5cIixcblx0XHRzcXVhcmVEZXNjOiBcIk1pdCBcXFwiU3F1YXJlXFxcIiB3aXJkIGRhcyBRdWFkcmF0IGRlciBQaXhlbHdlcnRlIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZXQuXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbU5hbWU6IFwiU3RhdGlzdGlrZW4gdW5kIEhpc3RvZ3JhbW1cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtU25pcDogXCJTdGF0aXN0aWtlbiB1bmQgSGlzdG9ncmFtbSBkZWZpbmllcmVuIG9kZXIgdmVya27DvHBmZW4uXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbURlc2M6IFwiRGllIEZ1bmt0aW9uIFxcXCJTdGF0aXN0aWtlbiB1bmQgSGlzdG9ncmFtbVxcXCIgd2lyZCB2ZXJ3ZW5kZXQsIHVtIGRpZSBTdGF0aXN0aWsgdW5kIGRhcyBIaXN0b2dyYW1tIGVpbmVzIFJhc3RlcnMgenUgZGVmaW5pZXJlbi4gIFNpZSBrw7ZubmVuIGRpZXNlIEZ1bmt0aW9uIGFtIEVuZGUgZGVyIEZ1bmt0aW9uc2tldHRlIGVpbmbDvGdlbiwgdW0gZGllIFN0YXRpc3RpayB1bmQgZGFzIEhpc3RvZ3JhbW0gZWluZXIgUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2UgKFJhc3RlciBGdW5jdGlvbiBUZW1wbGF0ZSwgUkZUKSB6dSBiZXNjaHJlaWJlbi4gRGllcyBrYW5uIGVyZm9yZGVybGljaCBzZWluLCB1bSBkaWUgU3RhbmRhcmRhbnplaWdlIGRlcyBWZXJhcmJlaXR1bmdzZXJnZWJuaXNzZXMgenUgc3RldWVybiwgaW5zYmVzb25kZXJlIGJlaW0gRGVmaW5pZXJlbiBlaW5lciBGdW5rdGlvbnNrZXR0ZSwgZGllIHZpZWxlIEZ1bmt0aW9uZW4gZW50aMOkbHQuPGRpdj48YnIvPlNpZSBrw7ZubmVuIGRpZSBTdGF0aXN0aWsgZGVmaW5pZXJlbiwgaW5kZW0gU2llIGRpZSBXZXJ0ZSBlaW5nZWJlbiBvZGVyIGF1cyBlaW5lbSBSYXN0ZXItRGF0YXNldCBiencuIGVpbmVyIFhNTC1EYXRlaSBpbXBvcnRpZXJlbi4gSGlzdG9ncmFtbWUga8O2bm5lbiBudXIgZHVyY2ggZGFzIEltcG9ydGllcmVuIGVpbmVyIERhdGVpIGRlZmluaWVydCB3ZXJkZW4uPC9kaXY+XCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGlrZW5cIixcblx0XHRzdGF0aXN0aWNzU25pcDogXCJCZXJlY2huZXQgYXVmIGRlciBHcnVuZGxhZ2UgZWluZXIgZGVmaW5pZXJ0ZW4gRm9rdXNuYWNoYmFyc2NoYWZ0IGRpZSBGb2t1c3N0YXRpc3Rpa2VuIGbDvHIgamVkZXMgUGl4ZWwgZWluZXMgQmlsZGVzLlwiLFxuXHRcdHN0YXRpc3RpY3NEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gXFxcIlN0YXRpc3Rpa2VuXFxcIiB3aXJkIGRpZSBGb2t1c3N0YXRpc3RpayBmw7xyIGplZGVzIFBpeGVsIGVpbmVzIEJpbGRlcyBhdWYgZGVyIEdydW5kbGFnZSBlaW5lciBkZWZpbmllcnRlbiBGb2t1c25hY2hiYXJzY2hhZnQgYmVyZWNobmV0LjxkaXY+PGJyLz5EaWUgRnVua3Rpb24gXFxcIlN0YXRpc3Rpa2VuXFxcIiBrYW5uIHp1bSBBdWZmw7xsbGVuIHZvbiBnZWzDtnNjaHRlbiBaZWlsZW4gaW4gZWluZW0gQmlsZCB2ZXJ3ZW5kZXQgd2VyZGVuLiBHZWzDtnNjaHRlIFplaWxlbiB3ZXJkZW4gaMOkdWZpZyBkdXJjaCBQcm9ibGVtZSBpbSBTZW5zb3IgdmVydXJzYWNodCwgd29iZWkga2VpbmUgRGF0ZW4gZXJmYXNzdCB3ZXJkZW4uIERpZXMgaXN0IGJlaSBTZW5zb3JlbiB3aWUgZGVtIEVuaGFuY2VkIFRoZW1hdGljIE1hcHBlciBQbHVzIChFVE0rKSBkZXMgTGFuZHNhdCA3IGF1ZmdldHJldGVuLiBEaWUgZmVobGVuZGVuIERhdGVuIHZlcnVyc2FjaGVuIFByb2JsZW1lIGJlaSBkZXIgQW5hbHlzZSB1bmQgYXVjaCBiZWltIEJldHJhY2h0ZW4gZGVyIEJpbGRkYXRlbi4gQW4gZGllc2VtIFVtc3RhbmQgbMOkc3N0IHNpY2ggYmVpIGRlciBWZXJ3ZW5kdW5nIHZvbiBCaWxkZGF0ZW4gZsO8ciBBbmFseXNlbiBuaWNodCB2aWVsIMOkbmRlcm4uIFdlbm4gamVkb2NoIGVpbiDDvGJlcmxhcHBlbmRlcyBCaWxkIHZvcmxpZWd0LCBrw7ZubnRlIGVzIGFuc3RlbGxlIGRlcyBmZWhsZW5kZW4gSW5oYWx0cyB2ZXJ3ZW5kZXQgd2VyZGVuLiBBdWYgZGllIGdsZWljaGUgV2Vpc2Uga8O2bm50ZSBhdWNoIGJlaSBCaWxkZGF0ZW4gdm9yZ2VnYW5nZW4gd2VyZGVuLCBkaWUgenVyIFZpc3VhbGlzaWVydW5nIHZlcndlbmRldCB3ZXJkZW4uIERhIGplZG9jaCBuaWNodCBpbW1lciBlaW4genVzw6R0emxpY2hlcyBCaWxkIHp1bSBBdWZmw7xsbGVuIGRlcyBmZWhsZW5kZW4gSW5oYWx0cyB6dXIgVmVyZsO8Z3VuZyBzdGVodCwgbXVzcyBlciBhdXMgZGVuIHZvcmhhbmRlbmVuIERhdGVuIGFiZ2VsZWl0ZXQgd2VyZGVuLjwvZGl2PlwiLFxuXHRcdHN0cmVhbUxpbmtOYW1lOiBcIldhc3NlcmxhdWYtQWJzY2huaXR0ZVwiLFxuXHRcdHN0cmVhbUxpbmtTbmlwOiBcIldlaXN0IEFic2Nobml0dGVuIGVpbmVzIGxpbmVhcmVuIFJhc3Rlci1OZXR6d2Vya3MgRWluemVsd2VydGUgendpc2NoZW4gU2Nobml0dHB1bmt0ZW4genUuXCIsXG5cdFx0c3RyZWFtTGlua0Rlc2M6IFwiTWl0IGRlciBnbG9iYWxlbiBGdW5rdGlvbiBcXFwiV2Fzc2VybGF1Zi1BYnNjaG5pdHRlXFxcIiB3ZXJkZW4gZGVuIEFic2Nobml0dGVuIGVpbmVzIGxpbmVhcmVuIFJhc3Rlci1OZXR6d2Vya3Mgendpc2NoZW4gU2Nobml0dHB1bmt0ZW4gRWluemVsd2VydGUgenVnZXdpZXNlbi48ZGl2Pjxici8+TGlua3Mgc2luZCBkaWUgQWJzY2huaXR0ZSBlaW5lcyBXYXNzZXJsYXVma2FuYWxzLCBkaWUgendlaSBhdWZlaW5hbmRlciBmb2xnZW5kZSBLbm90ZW4sIGVpbmVuIEtub3RlbiB1bmQgZGVuIEFiZmx1c3Mgb2RlciBlaW5lbiBLbm90ZW4gdW5kIGRpZSBXYXNzZXJzY2hlaWRlIG1pdGVpbmFuZGVyIHZlcmJpbmRlbi4gSW4gZGVyIEh5ZHJvbG9naWUgd2VyZGVuIGRpZXNlIFdhc3NlcmxhdWZzZWdtZW50ZSBhbHMgRmx1c3NhYnNjaG5pdHRlIGJlemVpY2huZXQuIEVpbiBLbm90ZW4gYmV6aWVodCBzaWNoIGF1ZiBlaW5lbiBBYmZsdXNzcHVua3QgdW5kIGVybcO2Z2xpY2h0IGRhcyBTa2l6emllcmVuIGVpbmVzIEFiZmx1c3NnZWJpZXRlcyBvZGVyIGRlciBHcmVuemUgZWluZXMgVGVpbGVpbnp1Z2dlYmlldHMuPC9kaXY+XCIsXG5cdFx0c3RyZXRjaE5hbWU6IFwiU3RyZWNrdW5nXCIsXG5cdFx0c3RyZXRjaFNuaXA6IFwiVmVyc3TDpHJrdCBlaW4gQmlsZCBkdXJjaCBkaWUgQW5wYXNzdW5nIGRlcyBhbmdlemVpZ3RlbiBXZXJ0ZWJlcmVpY2hzLiBEYWR1cmNoIHdlcmRlbiBkaWUgenVncnVuZGUgbGllZ2VuZGVuIFBpeGVsd2VydGUgbmljaHQgdmVyw6RuZGVydC4gV2VubiBlaW4gUGl4ZWx3ZXJ0IGF1w59lcmhhbGIgZGVzIGFuZ2VnZWJlbmVuIEJlcmVpY2hzIGxpZWd0LCB3aXJkIGVyIGFscyBNaW5pbWFsLSBvZGVyIE1heGltYWx3ZXJ0IGFuZ2V6ZWlndC5cIixcblx0XHRzdHJldGNoRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIlN0cmVja3VuZ1xcXCIgdmVyYmVzc2VydCBlaW4gQmlsZCwgaW5kZW0gc2llIEVpZ2Vuc2NoYWZ0ZW4gd2llIEhlbGxpZ2tlaXQsIEtvbnRyYXN0IHVuZCBHYW1tYSBtaXRoaWxmZSBtZWhyZXJlciBTdHJlY2t1bmdzdHlwZW4gw6RuZGVydC4gRGllc2UgRnVua3Rpb24gdmVyd2VuZGV0IGRpZSBTdGF0aXN0aWsgZGVyIFJhc3RlciBpbm5lcmhhbGIgZGVzIE1vc2Fpay1EYXRhc2V0cy4gQmVpIGlocmVyIFZlcndlbmR1bmcgbcO8c3NlbiBTaWUgZGFoZXIgc2ljaGVyc3RlbGxlbiwgZGFzcyBkaWUgU3RhdGlzdGlrIGJlcmVjaG5ldCB3dXJkZS48ZGl2Pjxici8+RGVyIFN0cmVja3VuZ3N0eXAgZGVmaW5pZXJ0IGVpbmUgSGlzdG9ncmFtbXN0cmVja3VuZywgZGllIGF1ZiBkaWUgUmFzdGVyIGFuZ2V3ZW5kZXQgd2lyZCwgdW0gaWhyIEVyc2NoZWludW5nc2JpbGQgenUgdmVyYmVzc2Vybi4gRWluZSBTdHJlY2t1bmcgdmVyYmVzc2VydCBkYXMgRXJzY2hlaW51bmdzYmlsZCBkZXIgRGF0ZW4sIGluZGVtIGRpZSBQaXhlbHdlcnRlIGVudGxhbmcgZWluZW0gSGlzdG9ncmFtbSB2b24gZGVuIE1pbmltYWwtIHVuZCBNYXhpbWFsd2VydGVuIGdlZGVobnQgd2VyZGVuLCBkaWUgZHVyY2ggaWhyZSBCaXQtVGllZmUgZGVmaW5pZXJ0IHNpbmQuIDwvZGl2PlwiLFxuXHRcdHN3YXRoTmFtZTogXCJTdHJlaWZlblwiLFxuXHRcdHN3YXRoU25pcDogXCJJbnRlcnBvbGllcnQgYXVzIHVucmVnZWxtw6TDn2lnZW4gR2l0dGVybiBvZGVyIFN0cmVpZmVuZGF0ZW4uXCIsXG5cdFx0c3dhdGhEZXNjOiBcIkluIGVpbmlnZW4gbmV0Q0RGLSBvZGVyIEhERi1EYXRhc2V0cyB3aXJkIGRpZSBHZW9sb2thbGlzaWVydW5nIGluIEZvcm0gdm9uIHVucmVnZWxtw6TDn2lnIGFuZ2VvcmRuZXRlbiBBcnJheXMgZ2VzcGVpY2hlcnQuIEJlaW0gSGluenVmw7xnZW4gZGllc2VyIERhdGFzZXRzIHp1IGVpbmVtIE1vc2Fpay1EYXRhc2V0IHdpcmQgdm9uIGRlciBGdW5rdGlvbiBcXFwiU3RyZWlmZW5cXFwiIGVpbiBSZXNhbXBsaW5nIGRlciB1bnJlZ2VsbcOkw59pZyBnZXJhc3RlcnRlbiBEYXRlbiBkdXJjaGdlZsO8aHJ0LCBzb2Rhc3MgamVkZXMgUGl4ZWwgZGllIGdsZWljaGUgR3LDtsOfZSB1bmQgZWluZSByZWNodGVja2lnZSBGb3JtIGVyaMOkbHQuPGRpdj48YnIvPkJlaW0gSGluenVmw7xnZW4gdm9uIFZhcmlhYmxlbiBhdXMgbmV0Q0RGIG9kZXIgSERGIHp1IGVpbmVtIE1vc2Fpay1EYXRhc2V0IHdpcmQgYXV0b21hdGlzY2ggZ2VwcsO8ZnQsIG9iIGRpZSBEYXRlbiBpbiBlaW5lbSByZWdlbG3DpMOfaWdlbiBBcnJheSBhbmdlb3JkbmV0IHNpbmQuIEZhbGxzIG5pY2h0LCB3aXJkIGRpZSBGdW5rdGlvbiBcXFwiU3RyZWlmZW5cXFwiIGFuZ2V3ZW5kZXQsIHVtIGRpZSB1bnJlZ2VsbcOkw59pZ2VuIFJhc3RlciBpbiBQdW5rdGUgdW5kIGFuc2NobGllw59lbmQgaW4gZWluIHJlZ2VsbcOkw59pZyBSYXN0ZXIgenUga29udmVydGllcmVuLiBTaWUga8O2bm5lbiBkaWUgaW4gZGVyIFJhc3Rlci1GdW5rdGlvbiBcXFwiU3RyZWlmZW5cXFwiIHZlcndlbmRldGUgSW50ZXJwb2xhdGlvbnNtZXRob2RlIHVuZCBaZWxsZW5ncsO2w59lIMOkbmRlcm4uIEJlaSByZWdlbG3DpMOfaWcgYW5nZW9yZG5ldGVuIFJhc3Rlci1EYXRlbiBmaW5kZXQga2VpbmUgSW50ZXJwb2xhdGlvbiBzdGF0dCwgZGllIERhdGVuIHdlcmRlbiBpbiBpaHJlbSBnZWdlbnfDpHJ0aWdlbiBadXN0YW5kIGdlbGVzZW4uPC9kaXY+XCIsXG5cdFx0dGFuSE5hbWU6IFwiVGFuSFwiLFxuXHRcdHRhbkhTbmlwOiBcIkRlbiBUYW5nZW5zIEh5cGVyYm9saWN1cyB2b24gWmVsbGVuIGluIGVpbmVtIFJhc3RlciBiZXJlY2huZW4uXCIsXG5cdFx0dGFuSERlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiB3aXJkIGRlciBUYW5nZW5zIEh5cGVyYm9saWN1cyBkZXIgUGl4ZWwgaW4gZWluZW0gUmFzdGVyIGJlcmVjaG5ldC5cIixcblx0XHR0YW5OYW1lOiBcIlRhblwiLFxuXHRcdHRhblNuaXA6IFwiRGVuIFRhbmdlbnMgdm9uIFplbGxlbiBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmVuLlwiLFxuXHRcdHRhbkRlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiB3aXJkIGRlciBUYW5nZW5zIGRlciBQaXhlbCBpbiBlaW5lbSBSYXN0ZXIgYmVyZWNobmV0LiBcIixcblx0XHR0YXNzZWxlZENhcE5hbWU6IFwiVGFzc2VsZWQgQ2FwIChLYXV0aC1UaG9tYXMpXCIsXG5cdFx0dGFzc2VsZWRDYXBTbmlwOiBcIkJlcmVjaG5ldCBkZW4gR3JhZCBhbiBWZWdldGF0aW9uLCBGZXVjaHRpZ2tlaXQgdW5kIEhlbGxpZ2tlaXQuIERpZXNlIE1ldGhvZGUgYmVydWh0IGF1ZiBLb2VmZml6aWVudGVuLCBkaWUgc3BlemllbGwgZsO8ciBlaW5lbiBTZW5zb3IgYmVyZWNobmV0IHdlcmRlbiBtw7xzc2VuLlwiLFxuXHRcdHRhc3NlbGVkQ2FwRGVzYzogXCJEaWUgVGFzc2VsZWQtQ2FwLVRyYW5zZm9ybWF0aW9uIChhdWNoIEthdXRoLVRob21hcy1UcmFuc2Zvcm1hdGlvbikgd3VyZGUgZW50d2lja2VsdCwgdW0gVmVyw6RuZGVydW5nZW4gaW4gZGVyIFZlZ2V0YXRpb25zcGjDpG5vbG9naWUgdW5kIFN0w6RkdGVlbnR3aWNrbHVuZywgZGllIHZvbiB2ZXJzY2hpZWRlbmVuIFNhdGVsbGl0ZW5zZW5zb3JzeXN0ZW1lbiBlcmZhc3N0IHdlcmRlbiwgenUgYW5hbHlzaWVyZW4gdW5kIGFscyBLYXJ0ZSBkYXJ6dXN0ZWxsZW4uIERlbiBOYW1lbiBcXFwiVGFzc2VsZWQgQ2FwXFxcIi1UcmFuc2Zvcm1hdGlvbiAoWmlwZmVsbcO8dHplKSB2ZXJkYW5rdCBzaWUgZGVyIEZvcm0gZGVyIGdyYXBoaXNjaGVuIFZlcnRlaWx1bmcgdm9uIERhdGVuLiBNaXQgZGVyIFRyYW5zZm9ybWF0aW9uIGtvbm50ZW4gZGllIE11c3RlciwgZGllIGluIExhbmRzYXQtTVNTLURhdGVuIGbDvHIgbGFuZHdpcnRzY2hhZnRsaWNoZSBGbMOkY2hlbiBnZWZ1bmRlbiB3dXJkZW4sIGluIEFiaMOkbmdpZ2tlaXQgdm9tIExlYmVuc3p5a2x1cyBkZXIgTnV0enBmbGFuemVuIGVya2zDpHJ0IHdlcmRlbi4gSW0gV2VzZW50bGljaGVuIGZpbmRldCB3w6RocmVuZCBkZXMgV2FjaHN0dW1zIHZvbiBOdXR6cGZsYW56ZW4gdm9tIFNhYXRrb3JuIGJpcyB6dXIgRXJudGVyZWlmZSBlaW5lIE5ldHRvenVuYWhtZSBkZXIgaW5mcmFyb3RuYWhlbiB1bmQgZWluZSBBYm5haG1lIGRlciBSb3RyZWZsZXhpb24gYmFzaWVyZW5kIGF1ZiBkZXIgQm9kZW5mYXJiZSBzdGF0dC48ZGl2Pjxici8+RGllc2UgVHJhbnNmb3JtYXRpb24gaGF0IG1pdHRsZXJ3ZWlsZSBlaW4gYnJlaXRlcyBBbndlbmR1bmdzc3Bla3RydW0gdW5kIGRpZW50IG5pY2h0IG51ciB6dXIgw5xiZXJ3YWNodW5nIHZvbiBOdXR6cGZsYW56ZW4sIHNvbmRlcm4gYXVjaCB6dXIgQW5hbHlzZSB1bmQgS2FydGVuZXJzdGVsbHVuZyB2b24gVmVnZXRhdGlvbiBmw7xyIEZvcnN0d2lydHNjaGFmdCwgaW5kdXN0cmllbGxlcyBWZWdldGF0aW9uc21hbmFnZW1lbnQsIMOWa29zeXN0ZW0tS2FydGVuZXJzdGVsbHVuZyB1bmQgLVZlcndhbHR1bmcsIEJlc3RhbmRzZXJmYXNzdW5nIHVuZCDDnGJlcndhY2h1bmcgdm9uIEtvaGxlbnN0b2ZmYmluZHVuZyB1bmQgRW1pc3Npb25zaGFuZGVsLCBTdMOkZHRlZW50d2lja2x1bmcgdXN3LiBNaXR0bGVyd2VpbGUgd2VyZGVuIG5pY2h0IG51ciBMYW5kc2F0IE1TUyB1bnRlcnN0w7x0enQsIHNvbmRlcm4gYXVjaCBhbmRlcmUgZ8OkbmdpZ2UgU2F0ZWxsaXRlbnN5c3RlbWUgd2llIGRpZSBNdWx0aXNwZWt0cmFsc2Vuc29yZW4gTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rLCBMYW5kc2F0IDgsIElLT05PUywgUXVpY2tCaXJkLCBXb3JsZFZpZXctMiB1bmQgUmFwaWRFeWUuPC9kaXY+XCIsXG5cdFx0dGltZXNOYW1lOiBcIlRpbWVzXCIsXG5cdFx0dGltZXNTbmlwOiBcIkRpZSBXZXJ0ZSB2b24gendlaSBSYXN0ZXJuIGF1ZiBaZWxsZW5iYXNpcyBtdWx0aXBsaXppZXJlbi5cIixcblx0XHR0aW1lc0Rlc2M6IFwiTWl0IGRlciBGdW5rdGlvbiBcXFwiVGltZXNcXFwiIHdlcmRlbiBkaWUgV2VydGUgendlaWVyIFJhc3RlciBhdWYgUGl4ZWxiYXNpcyBtdWx0aXBsaXppZXJ0LlwiLFxuXHRcdHRyYW5zcG9zZUJpdHNOYW1lOiBcIkJpdHZlcnNhdHpcIixcblx0XHR0cmFuc3Bvc2VCaXRzU25pcDogXCJFbnRwYWNrdCBkaWUgQml0cyBkZXMgRWluZ2FiZXBpeGVscyB1bmQgb3JkbmV0IHNpZSBmZXN0Z2VsZWd0ZW4gQml0cyBpbiBkZW0gQXVzZ2FiZXBpeGVsIHp1LiBad2VjayBkaWVzZXIgRnVua3Rpb24gaXN0IGVzLCBkaWUgQml0cyBhdXMgZWluaWdlbiBFaW5nYWJlbiB6dSBtYW5pcHVsaWVyZW4sIHouIEIuIExhbmRzYXQgOC1Cw6RuZGVyIHp1ciBRdWFsaXTDpHRzcHLDvGZ1bmcuXCIsXG5cdFx0dHJhbnNwb3NlQml0c0Rlc2M6IFwiRGllIEZ1bmt0aW9uIFxcXCJCaXR2ZXJzYXR6XFxcIiBlbnRwYWNrdCBkaWUgQml0cyBkZXMgRWluZ2FiZXBpeGVscyB1bmQgb3JkbmV0IHNpZSBmZXN0Z2VsZWd0ZW4gQml0cyBpbiBkZW0gQXVzZ2FiZXBpeGVsIHp1LiBad2VjayBkaWVzZXIgRnVua3Rpb24gaXN0IGVzLCBkaWUgQml0cyBhdXMgZWluaWdlbiBFaW5nYWJlbiB6dSBtYW5pcHVsaWVyZW4sIHouIEIuIHNvbGNoZSBkZXIgTGFuZHNhdCA4LVF1YWxpdMOkdHNiYW5kcHJvZHVrdGUuXCIsXG5cdFx0dW5pdENvbnZlcnNpb25OYW1lOiBcIkVpbmhlaXRlbnVtcmVjaG51bmdcIixcblx0XHR1bml0Q29udmVyc2lvblNuaXA6IFwiV2VydGUgdm9uIGVpbmVyIE1hw59laW5oZWl0IGluIGVpbmUgYW5kZXJlIMOkbmRlcm4uXCIsXG5cdFx0dW5pdENvbnZlcnNpb25EZXNjOiBcIkRpZXNlIEZ1bmt0aW9uIGtvbnZlcnRpZXJ0IFBpeGVsIHZvbiBlaW5lciBFaW5oZWl0IGluIGVpbmUgYW5kZXJlLiBTaWUgdW50ZXJzdMO8dHp0IGRpZSBLb252ZXJ0aWVydW5nIHZvbiBFbnRmZXJudW5nLCBHZXNjaHdpbmRpZ2tlaXQgdW5kIFRlbXBlcmF0dXIuXCIsXG5cdFx0dmVjdG9yRmllbGROYW1lOiBcIlZla3RvcmZlbGRcIixcblx0XHR2ZWN0b3JGaWVsZFNuaXA6IFwiRGF0YXNldHMgbWl0IEdyw7bDn2UgKHUpIHVuZCBSaWNodHVuZyAodikgYWxzIFBmZWlsZSBhbnplaWdlbiwgd29iZWkgSMO2aGUgZHVyY2ggZGllIEdyw7bDn2UgdW5kIFJpY2h0dW5nIGR1cmNoIGRlbiBXaW5rZWwgZGVzIFBmZWlscyBkYXJnZXN0ZWxsdCB3aXJkLlwiLFxuXHRcdHZlY3RvckZpZWxkRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIlZla3RvcmZlbGRcXFwiIGtvbWJpbmllcnQgdW5kIGtvbnZlcnRpZXJ0IHp3ZWkgUmFzdGVyIHp1IGVpbmVtIFp3ZWliYW5kLVJhc3RlciwgZGVzc2VuIERhdGVudHlwIGVudHdlZGVyIFxcXCJNYWduaXR1ZGVuLVJpY2h0dW5nXFxcIiBvZGVyIFxcXCJVLVZcXFwiIGlzdC48ZGl2Pjxici8+RGVyIFUtV2VydCB3aXJkIG1hbmNobWFsIGFscyB6b25hbGUgR2VzY2h3aW5kaWdrZWl0IHVuZCBkZXIgVi1XZXJ0IGFscyBtZXJpZGlvbmFsZSBHZXNjaHdpbmRpZ2tlaXQgYmV6ZWljaG5ldC48L2Rpdj5cIixcblx0XHR2aWV3c2hlZDJOYW1lOiBcIlNpY2h0ZmVsZFwiLFxuXHRcdHZpZXdzaGVkMlNuaXA6IFwiQmVzdGltbXQgYW5oYW5kIGdlb2TDpHRpc2NoZXIgTWV0aG9kZW4gZGllIEdpdHRlcm5ldHotT2JlcmZsw6RjaGVucG9zaXRpb25lbiwgZGllIGbDvHIgZWluZSBSZWloZSB2b24gQmVvYmFjaHRlci1GZWF0dXJlcyBzaWNodGJhciBzaW5kLlwiLFxuXHRcdHZpZXdzaGVkMkRlc2M6IFwiRGllIEZ1bmt0aW9uIFxcXCJTaWNodGZlbGRcXFwiIGJlc3RpbW10IGFuaGFuZCBnZW9kw6R0aXNjaGVyIE1ldGhvZGVuIGRpZSBSYXN0ZXItT2JlcmZsw6RjaGVucG9zaXRpb25lbiwgZGllIGbDvHIgZWluZSBSZWloZSB2b24gQmVvYmFjaHRlci1GZWF0dXJlcyBzaWNodGJhciBzaW5kLjxkaXY+PGJyLz5EaWUgU2ljaHRiYXJrZWl0IGplZGVzIGVpbnplbG5lbiBQaXhlbG1pdHRlbHB1bmt0cyB3aXJkIGR1cmNoIGVpbmVuIFNpY2h0bGluaWVudGVzdCB6d2lzY2hlbiBkZW0gWmllbCB1bmQgZGVtIGpld2VpbGlnZW4gQmVvYmFjaHRlciBlcm1pdHRlbHQuIFdlbm4gZWluIEJlb2JhY2h0ZXIgZGFzIFppZWwgaW0gUGl4ZWxtaXR0ZWxwdW5rdCBzZWhlbiBrYW5uLCB3aXJkIGRhcyBQaXhlbCBhbHMgc2ljaHRiYXIgZXJhY2h0ZXQuIEJlaSBkZXIgRXJtaXR0bHVuZyBkZXIgU2ljaHRiYXJrZWl0IHdpcmQgc3RldHMgZGllIEVyZGtyw7xtbXVuZyBiZXLDvGNrc2ljaHRpZ3QuPC9kaXY+XCIsXG5cdFx0d2F0ZXJzaGVkTmFtZTogXCJBYmZsdXNzZ2ViaWV0XCIsXG5cdFx0d2F0ZXJzaGVkU25pcDogXCJFcm1pdHRlbHQgZGllIHJlbGV2YW50ZSBGbMOkY2hlIMO8YmVyIGVpbmVyIEdydXBwZSB2b24gWmVsbGVuIGluIGVpbmVtIFJhc3Rlci5cIixcblx0XHR3YXRlcnNoZWREZXNjOiBcIk1pdCBkZXIgZ2xvYmFsZW4gRnVua3Rpb24gXFxcIkFiZmx1c3NnZWJpZXRcXFwiIHdpcmQgZGllIHJlbGV2YW50ZSBGbMOkY2hlIMO8YmVyIGVpbmVyIEdydXBwZSB2b24gUGl4ZWxuIGluIGVpbmVtIFJhc3RlciBlcm1pdHRlbHQuIEFiZmx1c3NnZWJpZXRlIHdlcmRlbiB2b24gZWluZW0gRmxpZcOfcmljaHR1bmdzcmFzdGVyIHNraXp6aWVydCwgZGFzIGRpZSBGbGllw59yaWNodHVuZyB2b24gamVkZW0gUGl4ZWwgaWRlbnRpZml6aWVydC5cIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlOYW1lOiBcIkdld2ljaHRldGUgw5xiZXJsYWdlcnVuZ1wiLFxuXHRcdHdlaWdodGVkT3ZlcmxheVNuaXA6IFwiw5xiZXJsYWdlcnQgbWVocmVyZSBSYXN0ZXIgYW5oYW5kIGVpbmVzIGFsbGdlbWVpbmVuIE1hw59zdGFicyB1bmQgZ2V3aWNodGV0IG5hY2ggZGVyIFdpY2h0aWdrZWl0IGplZGVzIFJhc3RlcnMuXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5RGVzYzogXCJNaXQgZGllc2VyIEZ1bmt0aW9uIHdlcmRlbiBtZWhyZXJlIFJhc3RlciBhbmhhbmQgZWluZXMgYWxsZ2VtZWluZW4gTWHDn3N0YWJzIMO8YmVybGFnZXJ0IHVuZCBuYWNoIGRlciBXaWNodGlna2VpdCBqZWRlcyBSYXN0ZXJzIGdld2ljaHRldC5cIixcblx0XHR3ZWlnaHRlZFN1bU5hbWU6IFwiR2V3aWNodGV0ZSBTdW1tZVwiLFxuXHRcdHdlaWdodGVkU3VtU25pcDogXCJFaW4gUmFzdGVyLUFycmF5IGF1ZiBaZWxsZW5iYXNpcyBnZXdpY2h0ZW4gdW5kIGhpbnp1ZsO8Z2VuLlwiLFxuXHRcdHdlaWdodGVkU3VtRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIkdld2ljaHRldGUgU3VtbWVcXFwiIGVybcO2Z2xpY2h0IGRpZSDDnGJlcmxhZ2VydW5nIG1laHJlcmVyIFJhc3Rlciwgd29iZWkgc2llIG5hY2ggaWhyZXIgamV3ZWlsaWdlbiBHZXdpY2h0dW5nIG11bHRpcGxpemllcnQgdW5kIHp1c2FtbWVuZ2VyZWNobmV0IHdlcmRlbi5cIixcblx0XHR3aW5kY2hpbGxOYW1lOiBcIldpbmRjaGlsbFwiLFxuXHRcdHdpbmRjaGlsbFNuaXA6IFwiVW1nZWJ1bmdzbHVmdHRlbXBlcmF0dXIgdW5kIFdpbmRnZXNjaHdpbmRpZ2tlaXQgenVtIEJlcmVjaG5lbiBkZXMgV2luZGNoaWxsLUZha3RvcnMga29tYmluaWVyZW4uXCIsXG5cdFx0d2luZGNoaWxsRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIldpbmRjaGlsbFxcXCIgaXN0IGJlaSBkZXIgSWRlbnRpZml6aWVydW5nIGdlZsOkaHJsaWNoZXIgd2ludGVybGljaGVyIEJlZGluZ3VuZ2VuIGhpbGZyZWljaCwgZGllIGplIG5hY2hkZW0sIHdpZSBsYW5nZSBtYW4gw6R1w59lcmxpY2hlbiBFaW5mbMO8c3NlbiBhdXNnZXNldHp0IGlzdCwgenUgRXJmcmllcnVuZ2VuIHVuZCBzb2dhciBVbnRlcmvDvGhsdW5nIGbDvGhyZW4ga8O2bm5lbi4gV2luZGNoaWxsIGlzdCBlaW5lIE3DtmdsaWNoa2VpdCwgZGFzIEvDpGx0ZWVtcGZpbmRlbiBlaW5lciBQZXJzb24genUgbWVzc2VuLCB3ZW5uIFdpbmQgYmVpIGJlcmVpdHMga2FsdGVuIFRlbXBlcmF0dXJlbiBiZXLDvGNrc2ljaHRpZ3Qgd2lyZC4gSmUgaMO2aGVyIGRpZSBXaW5kZ2VzY2h3aW5kaWdrZWl0LCBkZXN0byBzY2huZWxsZXIgdmVybGllcnQgZGVyIEvDtnJwZXIgV8Okcm1lIHVuZCBkZXN0byBow7ZoZXIgaXN0IGRhcyBLw6RsdGVlbXBmaW5kZW4uXCIsXG5cdFx0em9uYWxSZW1hcE5hbWU6IFwiWm9uYWxlIE5ldXp1b3JkbnVuZ1wiLFxuXHRcdHpvbmFsUmVtYXBTbmlwOiBcIk9yZG5lbiBTaWUgUGl4ZWwgaW4gZWluZW0gUmFzdGVyIGJhc2llcmVuZCBhdWYgaW4gZWluZW0gYW5kZXJlbiBSYXN0ZXIgZGVmaW5pZXJ0ZW4gWm9uZW4gdW5kIHpvbmVuYWJow6RuZ2lnZXIgV2VydHp1b3JkbnVuZywgZGllIGluIGVpbmVyIFRhYmVsbGUgZGVmaW5pZXJ0IGlzdCwgbmV1IHp1LlwiLFxuXHRcdHpvbmFsUmVtYXBEZXNjOiBcIk1pdCBkaWVzZXIgRnVua3Rpb24ga8O2bm5lbiBTaWUgUGl4ZWwgaW4gZWluZW0gUmFzdGVyIGJhc2llcmVuZCBhdWYgaW4gZWluZW0gYW5kZXJlbiBSYXN0ZXIgZGVmaW5pZXJ0ZW4gWm9uZW4gdW5kIHpvbmVuYWJow6RuZ2lnZXIgV2VydHp1b3JkbnVuZywgZGllIGluIGVpbmVyIFRhYmVsbGUgZGVmaW5pZXJ0IGlzdCwgbmV1IHp1b3JkbmVuLlwiLFxuXHRcdHpvbmFsU3RhdGlzdGljc05hbWU6IFwiWm9uYWxlIFN0YXRpc3Rpa2VuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzU25pcDogXCJCZXJlY2huZXQgU3RhdGlzdGlrZW4gZGVyIFdlcnRlIGVpbmVzIEdpdHRlcm5ldHpzIGlubmVyaGFsYiBkZXIgWm9uZW4gZWluZXMgYW5kZXJlbiBEYXRhc2V0cy5cIixcblx0XHR6b25hbFN0YXRpc3RpY3NEZXNjOiBcIk1pdCBkZXIgRnVua3Rpb24gd2VyZGVuIFN0YXRpc3Rpa2VuIGRlciBXZXJ0ZSBlaW5lcyBSYXN0ZXJzIGlubmVyaGFsYiBkZXIgWm9uZW4gZWluZXMgYW5kZXJlbiBEYXRhc2V0cyBiZXJlY2huZXQuIEVpbmUgWm9uZSB3aXJkIGR1cmNoIGFsbGUgRmzDpGNoZW4gaW4gZGVyIEVpbmdhYmUgZGVmaW5pZXJ0LCBkaWUgZGVuIGdsZWljaGVuIFdlcnQgYXVmd2Vpc2VuLiBEaWVzZSBGbMOkY2hlbiBtw7xzc2VuIG5pY2h0IHp1c2FtbWVuaMOkbmdlbmQgc2Vpbi4gV2VubiBkaWUgWm9uZW4tIHVuZCBXZXJ0ZWluZ2FiZW4gamV3ZWlscyBSYXN0ZXIgbWl0IGRlcnNlbGJlbiBBdWZsw7ZzdW5nIHNpbmQsIHdlcmRlbiBzaWUgZGlyZWt0IHZlcndlbmRldC4gV2VubiBkaWUgQXVmbMO2c3VuZ2VuIHZlcnNjaGllZGVuIHNpbmQsIHdpcmQgZWluIGludGVybmVzIFJlc2FtcGxpbmcgYW5nZXdlbmRldCwgdW0gZGllIEF1ZmzDtnN1bmdlbiB6dXIgw5xiZXJlaW5zdGltbXVuZyB6dSBicmluZ2VuLCBiZXZvciBkaWUgem9uYWxlIE9wZXJhdGlvbiBhdXNnZWbDvGhydCB3aXJkLlwiLFxuXHRcdGZsb3dMZW5ndGhOYW1lOiBcIkZsaWXDn2zDpG5nZVwiLFxuXHRcdGZsb3dMZW5ndGhTbmlwOiBcIkJlcmVjaG5ldCBkaWUgRW50ZmVybnVuZyBmbHVzc2F1ZnfDpHJ0cyBiencuIGZsdXNzYWJ3w6RydHMgb2RlciBkaWUga29zdGVuZ2V3aWNodGV0ZSBFbnRmZXJudW5nIGVudGxhbmcgZGVzIEZsaWXDn3BmYWRlcyBmw7xyIGplZGUgWmVsbGUuXCIsXG5cdFx0Zmxvd0xlbmd0aERlc2M6IFwiRGllcyBpc3QgZWluZSBnbG9iYWxlIFJhc3Rlci1GdW5rdGlvbi4gTWl0IGRpZXNlciBGdW5rdGlvbiB3aXJkIGVpbiBSYXN0ZXItTGF5ZXIgZGVyIEVudGZlcm51bmcgZmx1c3NhdWZ3w6RydHMgYnp3LiBmbHVzc2Fid8OkcnRzIG9kZXIgZGllIGdld2ljaHRldGUgRW50ZmVybnVuZyBlbnRsYW5nIGRlcyBGbGllw59wZmFkZXMgZsO8ciBqZWRlIFplbGxlIGVyc3RlbGx0LjxkaXY+PGJyLz5FaW5lIHByaW3DpHJlIFZlcndlbmR1bmcgZGVyIEZ1bmt0aW9uIFxcXCJGbGllw59sw6RuZ2VcXFwiIGJlc3RlaHQgaW4gZGVyIEJlcmVjaG51bmcgZGVyIEzDpG5nZSBkZXMgbMOkbmdzdGVuIEZsaWXDn3BmYWRlcyBpbm5lcmhhbGIgZWluZXMgZ2VnZWJlbmVuIFdhc3NlcmVpbnp1Z3NnZWJpZXRzLiBEaWVzZXIgTWVzc3dlcnQgd2lyZCBow6R1ZmlnIHZlcndlbmRldCwgdW0gZGllIEtvbnplbnRyYXRpb25zemVpdCBlaW5lcyBXYXNzZXJlaW56dWdzZ2ViaWV0cyB6dSBiZXJlY2huZW4uIEhpZXJ6dSB3aXJkIGRpZSBPcHRpb24gXFxcIkZsdXNzYXVmd8OkcnRzXFxcIiB2ZXJ3ZW5kZXQuIERpZSBGdW5rdGlvbiBrYW5uIGF1Y2ggdmVyd2VuZGV0IHdlcmRlbiwgdW0gRW50ZmVybnVuZ3MtRmzDpGNoZW4tRGlhZ3JhbW1lIGbDvHIgaHlwb3RoZXRpc2NoZSBOaWVkZXJzY2hsYWdzLSB1bmQgQWJmbHVzc2VyZWlnbmlzc2UgenUgZXJzdGVsbGVuLCB3b2JlaSBkYXMgR2V3aWNodHVuZ3MtUmFzdGVyIGFscyBJbXBlZGFueiBmw7xyIGRpZSBBYnfDpHJ0c2Jld2VndW5nIHZlcndlbmRldCB3aXJkLjwvZGl2PlwiLFxuXHRcdHN0cmVhbU9yZGVyTmFtZTogXCJXYXNzZXJsYXVmLU9yZG51bmdcIixcblx0XHRzdHJlYW1PcmRlclNuaXA6IFwiV2Vpc3QgU2VnbWVudGVuIGVpbmVzIFJhc3RlcnMsIGRpZSBWZXJ6d2VpZ3VuZ2VuIGVpbmVzIGxpbmVhcmVuIE5ldHp3ZXJrZXMgZGFyc3RlbGxlbiwgZWluZSBudW1lcmlzY2hlIE9yZG51bmcgenUuXCIsXG5cdFx0c3RyZWFtT3JkZXJEZXNjOiBcIkRpZXMgaXN0IGVpbmUgZ2xvYmFsZSBSYXN0ZXItRnVua3Rpb24uIE1pdCBkaWVzZXIgRnVua3Rpb24gd2lyZCBlaW4gUmFzdGVyLUxheWVyIGVyc3RlbGx0LCBkZXIgU2VnbWVudGVuIGVpbmVzIFJhc3RlcnMsIGRpZSBWZXJ6d2VpZ3VuZ2VuIGVpbmVzIGxpbmVhcmVuIE5ldHp3ZXJrZXMgZGFyc3RlbGxlbiwgZWluZSBudW1lcmlzY2hlIE9yZG51bmcgenV3ZWlzdC48ZGl2Pjxici8+RGllIEF1c2dhYmUgZGVyIEZ1bmt0aW9uIFxcXCJXYXNzZXJsYXVmLU9yZG51bmdcXFwiIGlzdCB2b24gaMO2aGVyZXIgUXVhbGl0w6R0LCB3ZW5uIGRlciBFaW5nYWJlLVJhc3Rlci1MYXllciBmw7xyIGRlbiBXYXNzZXJsYXVmIHVuZCBkZXIgRWluZ2FiZS1SYXN0ZXItTGF5ZXIgZsO8ciBkaWUgRmxpZcOfcmljaHR1bmcgdm9uIGRlciBnbGVpY2hlbiBPYmVyZmzDpGNoZSBhYmdlbGVpdGV0IHdlcmRlbi4gV2VubiBkYXMgV2Fzc2VybGF1Zi1SYXN0ZXIgYXVzIGVpbmVtIGdlcmFzdGVydGVuIFdhc3NlcmxhdWYtRGF0YXNldCBhYmdlbGVpdGV0IHdpcmQsIGlzdCBkaWUgQXVzZ2FiZSBtw7ZnbGljaGVyd2Vpc2UgdW5icmF1Y2hiYXIsIGRhIGRpZSBSaWNodHVuZyBhdWYgWmVsbGVuYmFzaXMgbmljaHQgbWl0IGRlciBQb3NpdGlvbiB2b24gV2Fzc2VybGF1ZnplbGxlbiDDvGJlcmVpbnN0aW1tdC4gRGllIEVyZ2Vibmlzc2UgZGVyIEZ1bmt0aW9uIFxcXCJBYmZsdXNzYWtrdW11bGF0aW9uXFxcIiBrw7ZubmVuIHZlcndlbmRldCB3ZXJkZW4sIHVtIGR1cmNoIGRhcyBBbndlbmRlbiBlaW5lcyBTY2h3ZWxsZW53ZXJ0ZXMgenVyIEF1c3dhaGwgdm9uIFplbGxlbiBtaXQgZWluZXIgaG9oZW4gQWJmbHVzc2Fra3VtdWxhdGlvbiBlaW4gUmFzdGVyLVdhc3NlcmxhdWZuZXR6IHp1IGVyc3RlbGxlbi4gQmVpc3BpZWxzd2Vpc2Ugd2VyZGVuIFplbGxlbiBtaXQgZWluZW0gWnVmbHVzcyB2b24gbWVociBhbHMgMTAwIFplbGxlbiB6dW0gRGVmaW5pZXJlbiBkZXMgV2Fzc2VybGF1Zm5ldHplcyB2ZXJ3ZW5kZXQuIFZlcndlbmRlbiBTaWUgZGllIEZ1bmt0aW9uIFxcXCJDb25cXFwiIG9kZXIgXFxcIkF1ZiBOVUxMIHNldHplblxcXCIsIHVtIGVpbiBXYXNzZXJsYXVmbmV0ei1SYXN0ZXIgenUgZXJzdGVsbGVuLCBpbiBkZW0gYWtrdW11bGllcnRlIFdhc3NlcmxhdWZ3ZXJ0ZSB2b24gMTAwIHVuZCBtZWhyIGluIGVpbmVtIE5ldHogenVzYW1tZW5mbGllw59lbiB1bmQgZGllIGFuZGVyZW4gV2Fzc2VybMOkdWZlIGltIEhpbnRlcmdydW5kIChOb0RhdGEpIHBvc2l0aW9uaWVydCB3ZXJkZW4uIERhcyByZXN1bHRpZXJlbmRlIFdhc3NlcmxhdWZuZXR6IGthbm4gaW4gZGVyIEZ1bmt0aW9uIFxcXCJXYXNzZXJsYXVmLU9yZG51bmdcXFwiIHZlcndlbmRldCB3ZXJkZW4uIERpZXNlIEZ1bmt0aW9uIHVudGVyc3TDvHR6dCBudXIgRDgtRWluZ2FiZS1GbGllw59yaWNodHVuZ3MtUmFzdGVyLUxheWVyLiBEOC1GbGllw59yaWNodHVuZ3MtUmFzdGVyIGvDtm5uZW4gbWl0IGRlciBGdW5rdGlvbiBcXFwiRmxpZcOfcmljaHR1bmdcXFwiIGVyc3RlbGx0IHVuZCBtaXQgZGVtIFN0YW5kYXJkZmxpZcOfcmljaHR1bmdzdHlwIEQ4IGF1c2dlZsO8aHJ0IHdlcmRlbi48L2Rpdj5cIixcblx0XHRzbmFwUG91clBvaW50TmFtZTogXCJBYmZsdXNzcHVua3QgenVvcmRuZW5cIixcblx0XHRzbmFwUG91clBvaW50U25pcDogXCJGw6RuZ3QgRmxpZcOfcHVua3RlIGFuIGRlciBaZWxsZSBtaXQgZGVyIGjDtmNoc3RlbiBBYmZsdXNzYWtrdW11bGF0aW9uIGlubmVyaGFsYiBlaW5lciBiZXN0aW1tdGVuIEVudGZlcm51bmcuXCIsXG5cdFx0c25hcFBvdXJQb2ludERlc2M6IFwiRGllcyBpc3QgZWluZSBnbG9iYWxlIFJhc3Rlci1GdW5rdGlvbi4gTWl0IGRpZXNlciBGdW5rdGlvbiB3ZXJkZW4gQWJmbHVzc3B1bmt0ZSBhbiBkZXIgWmVsbGUgbWl0IGRlciBow7ZjaHN0ZW4gQWJmbHVzc2Fra3VtdWxhdGlvbiBpbm5lcmhhbGIgZWluZXIgYmVzdGltbXRlbiBFbnRmZXJudW5nIGdlZmFuZ2VuLjxkaXY+PGJyLz5CZWltIEFiZ3JlbnplbiB2b24gV2Fzc2VyZWluenVnc2dlYmlldGVuIG1pdCBkZXIgRnVua3Rpb24gXFxcIkFiZmx1c3NnZWJpZXRcXFwiIHdpcmQgZGllIEZ1bmt0aW9uIFxcXCJBYmZsdXNzcHVua3QgenVvcmRuZW5cXFwiIHZlcndlbmRldCwgdW0gZGllIEF1c3dhaGwgZGVyIFB1bmt0ZSBtaXQgaG9oZXIgQWJmbHVzc2Fra3VtdWxhdGlvbiBzaWNoZXJ6dXN0ZWxsZW4uIFxcXCJBYmZsdXNzcHVua3QgenVvcmRuZW5cXFwiIHN1Y2h0IGlubmVyaGFsYiBlaW5lciBGYW5nZW50ZmVybnVuZyB1bSBkaWUgYW5nZWdlYmVuZW4gQWJmbHVzc3B1bmt0ZSBuYWNoIGRlciBaZWxsZSBtaXQgZGVyIGjDtmNoc3RlbiBBYmZsdXNzYWtrdW11bGF0aW9uIHVuZCB2ZXJzY2hpZWJ0IGRlbiBBYmZsdXNzcHVua3QgYW4gZGllc2UgUG9zaXRpb24uIERpZSBBdXNnYWJlIGlzdCBlaW4gZ2FuenphaGxpZ2VyIFJhc3Rlci1MYXllciwgd2VubiBkaWUgdXJzcHLDvG5nbGljaGVuIEFiZmx1c3NwdW5rdHBvc2l0aW9uZW4gYW4gUG9zaXRpb25lbiBtaXQgaMO2aGVyZXIgQWJmbHVzc2Fra3VtdWxhdGlvbiBnZWZhbmdlbiB3dXJkZW4uPC9kaXY+XCIsXG5cdFx0c2lua05hbWU6IFwiU2Vua2VcIixcblx0XHRzaW5rU25pcDogXCJFcnN0ZWxsdCBlaW4gUmFzdGVyLCBkYXMgYWxsZSBTZW5rZW4gb2RlciBGbMOkY2hlbiBtaXQgaW50ZXJuZXIgRHJhaW5hZ2UgaWRlbnRpZml6aWVydC5cIixcblx0XHRzaW5rRGVzYzogXCJEaWVzIGlzdCBlaW5lIGdsb2JhbGUgUmFzdGVyLUZ1bmt0aW9uLiBNaXQgZGllc2VyIEZ1bmt0aW9uIHdpcmQgZWluIFJhc3Rlci1MYXllciBlcnN0ZWxsdCwgZGVyIGFsbGUgU2Vua2VuIG9kZXIgRmzDpGNoZW4gbWl0IGludGVybmVyIERyYWluYWdlIGlkZW50aWZpemllcnQuIEVpbmUgU2Vua2UgaXN0IGVpbmUgWmVsbGUgb2RlciBlaW4gU2F0eiByw6R1bWxpY2ggdmVyYnVuZGVuZXIgWmVsbGVuLCBkZXJlbiBGbGllw59yaWNodHVuZyBrZWluZXIgZGVyIGFjaHQgZ8O8bHRpZ2VuIFdlcnRlIGluIGVpbmVtIEZsaWXDn3JpY2h0dW5ncy1SYXN0ZXIgenVnZXdpZXNlbiB3ZXJkZW4ga2Fubi4gRGllcyBrYW5uIGF1ZnRyZXRlbiwgd2VubiBhbGxlIGJlbmFjaGJhcnRlbiBaZWxsZW4gaMO2aGVyIGFscyBkaWUgYmVhcmJlaXRldGUgWmVsbGUgc2luZCwgb2RlciB3ZW5uIHp3ZWkgWmVsbGVuIGluZWluYW5kZXIgZmxpZcOfZW4gdW5kIGVpbmUgU2NobGVpZmUgbWl0IHp3ZWkgWmVsbGVuIHNjaGFmZmVuLjxkaXY+PGJyLz5EaWUgRnVua3Rpb24gXFxcIlNlbmtlXFxcIiB1bnRlcnN0w7x0enQgbnVyIEQ4LUVpbmdhYmUtRmxpZcOfcmljaHR1bmdzLVJhc3Rlci1MYXllci4gRDgtRmxpZcOfcmljaHR1bmdzLVJhc3RlciBrw7ZubmVuIG1pdCBkZXIgRnVua3Rpb24gXFxcIkZsaWXDn3JpY2h0dW5nXFxcIiBlcnN0ZWxsdCB1bmQgbWl0IGRlbSBTdGFuZGFyZGZsaWXDn3JpY2h0dW5nc3R5cCBEOCBhdXNnZWbDvGhydCB3ZXJkZW4uIERpZSBBdXNnYWJlIGRlciBGdW5rdGlvbiBcXFwiU2Vua2VcXFwiIGlzdCBlaW4gSW50ZWdlci1SYXN0ZXIsIGJlaSBkZW0gamVkZXIgU2Vua2UgZWluIEVpbnplbHdlcnQgenVnZXdpZXNlbiB3aXJkLiBEaWVzZSBFaW56ZWx3ZXJ0ZSB3ZWlzZW4gZWluZW4gQmVyZWljaCBhdWYsIGRlciB6d2lzY2hlbiBlaW5zIG9kZXIgZGVyIEdlc2FtdHphaGwgZGVyIFNlbmtlbiBsaWVndC4gV2VubiBkaWUgR2VzYW10emFobCBkZXIgU2Vua2VuIDEwMDAgYmV0cmFnZW4gd8O8cmRlLCB3w7xyZGUgZGVyIEJlcmVpY2ggZGVyIEVpbnplbHdlcnRlIDEgYmlzIDEwMDAgYmV0cmFnZW4uPC9kaXY+XCIsXG5cdFx0YWdncmVnYXRlTmFtZTogXCJBZ2dyZWdpZXJlblwiLFxuXHRcdGFnZ3JlZ2F0ZVNuaXA6IFwiR2VuZXJpZXJ0IGVpbmUgVmVyc2lvbiBkZXMgUmFzdGVycyBtaXQgcmVkdXppZXJ0ZXIgQXVmbMO2c3VuZy5cIixcblx0XHRhZ2dyZWdhdGVEZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiQWdncmVnaWVyZW5cXFwiIGbDvGhydCBlbnRzcHJlY2hlbmQgZGVyIGFuZ2VnZWJlbmVuIEFnZ3JlZ2F0aW9uc3N0cmF0ZWdpZSBlaW4gUmVzYW1wbGluZyBkZXMgRWluZ2FiZS1SYXN0ZXJzIGF1ZiBlaW5lIGdyw7ZiZXJlIEF1ZmzDtnN1bmcgZHVyY2guIEplZGUgQXVzZ2FiZXplbGxlIGVudGjDpGx0IGRpZSBTdW1tZSwgTWluaW11bSwgTWF4aW11bSwgTWl0dGVsd2VydCBvZGVyIE1lZGlhbndlcnQgZGVyIEVpbmdhYmV6ZWxsZW4sIGRpZSB2b24gZGVyIEF1c2RlaG51bmcgZGllc2VyIFplbGxlIHVtZmFzc3Qgd2VyZGVuLjxkaXY+PGJyLz5TaWUga8O2bm5lbiBhbmdlYmVuLCBtaXQgd2VsY2hlbSBGYWt0b3IgZGllIFplbGxlbmdyw7bDn2UgZGVzIEVpbmdhYmUtUmFzdGVycyBtdWx0aXBsaXppZXJ0IHdlcmRlbiBzb2xsLiBEZXIgWmVsbGVuZmFrdG9yd2VydCAzIHfDvHJkZSB6LiBCLiB6dSBlaW5lciBBdXNnYWJlLVplbGxlbmdyw7bDn2UgZsO8aHJlbiwgZGllIGRyZWltYWwgc28gZ3Jvw58gaXN0IHdpZSBkaWUgZGVzIEVpbmdhYmUtUmFzdGVycy4gU2llIGvDtm5uZW4gZGVmaW5pZXJlbiwgd2llIGRpZSBBdXNkZWhudW5nIGRlciBBdXNnYWJlIGJlaGFuZGVsdCB3ZXJkZW4gc29sbCwgd2VubiBkaWUgQW56YWhsIHZvbiBaZWlsZW4gb2RlciBTcGFsdGVuIGluIGRlciBFaW5nYWJlIGtlaW4gZ2VuYXVlcyBWaWVsZmFjaGVzIGRlcyBaZWxsZW5mYWt0b3JzIGlzdC4gU3RhbmRhcmRtw6TDn2lnIHdlcmRlbiBkaWUgb2JlcmUgdW5kIHJlY2h0ZSBCZWdyZW56dW5nIGVyd2VpdGVydCwgc29kYXNzIGVpbmUgZ3LDtsOfZXJlIHLDpHVtbGljaGUgQXVzZGVobnVuZyBhbHMgaW0gRWluZ2FiZS1SYXN0ZXIgZXJmYXNzdCB3aXJkLCBkYW1pdCB3aXJrbGljaCBhbGxlIEVpbmdhYmV6ZWxsZW4gdmVyYXJiZWl0ZXQgd2VyZGVuLiBBbHRlcm5hdGl2IGvDtm5uZW4gZGllIG9iZXJlIHVuZCByZWNodGUgQmVncmVuenVuZyBhdWYgZWluZSBrbGVpbmVyZSBBdXNkZWhudW5nIHJlZHV6aWVydCB3ZXJkZW4sIHNvZGFzcyBkaWUgQW56YWhsIGRlciB2ZXJhcmJlaXRldGVuIFplaWxlbiB1bmQgU3BhbHRlbiBlaW4gZ2VuYXVlcyBWaWVsZmFjaGVzIGRlcyBaZWxsZW5mYWt0b3JzIGRhcnN0ZWxsdC4gU2llIGvDtm5uZW4gZGVmaW5pZXJlbiwgd2llIE5vRGF0YS1aZWxsZW4gYmVpIGRlciBBZ2dyZWdhdGlvbnNiZXJlY2hudW5nIHZlcmFyYmVpdGV0IHdlcmRlbi4gQmVpbSBTdGFuZGFyZG1lY2hhbmlzbXVzIHdlcmRlbiBOb0RhdGEtRWluZ2FiZXplbGxlbiwgZGllIGlubmVyaGFsYiBkZXIgcsOkdW1saWNoZW4gQXVzZGVobnVuZyBlaW5lciBncsO2w59lcmVuIFplbGxlIGltIEF1c2dhYmUtUmFzdGVyIGxpZWdlbiwgaWdub3JpZXJ0LCB3ZW5uIGRlciBXZXJ0IGRlciBqZXdlaWxpZ2VuIEF1c2dhYmV6ZWxsZSBiZXN0aW1tdCB3aXJkLiBBbHRlcm5hdGl2IGvDtm5uZW4gU2llIGFuZ2ViZW4sIGRhc3MgYXVjaCBudXIgZWluZSBlaW56aWdlIE5vRGF0YS1FaW5nYWJlemVsbGUgaW4gZGVyIHLDpHVtbGljaGVuIEF1c2RlaG51bmcgZWluZXIgQXVzZ2FiZXplbGxlIGRhenUgZsO8aHJ0LCBkYXNzIGRpZSBaZWxsZSBpbSBBdXNnYWJlLVJhc3RlciBhbHMgTm9EYXRhLVplbGxlIGJlaGFuZGVsdCB3aXJkLjwvZGl2PlwiLFxuXHRcdGNjZGNOYW1lOiBcIkNDREMtQW5hbHlzZVwiLFxuXHRcdGNjZGNTbmlwOiBcIsOcYmVycHLDvGZ0IG1pdCBkZW0gQ0NEQy1BbGdvcml0aG11cyAoQ29udGludW91cyBEZXRlY3Rpb24gYW5kIENsYXNzaWZpY2F0aW9uKSDDhG5kZXJ1bmdlbiB2b24gUGl4ZWx3ZXJ0ZW4gaW0gWmVpdHZlcmxhdWYgdW5kIGdlbmVyaWVydCBNb2RlbGxlcmdlYm5pc3NlLlwiLFxuXHRcdGNjZGNEZXNjOiBcIkRpZSBDQ0RDLUFuYWx5c2UtRnVua3Rpb24gw7xiZXJwcsO8ZnQgbWl0IGRlbSBDQ0RDLUFsZ29yaXRobXVzIChDb250aW51b3VzIERldGVjdGlvbiBhbmQgQ2xhc3NpZmljYXRpb24pIMOEbmRlcnVuZ2VuIHZvbiBQaXhlbHdlcnRlbiBpbSBaZWl0dmVybGF1ZiB1bmQgZ2VuZXJpZXJ0IGVpbiBtdWx0aWRpbWVuc2lvbmFsZXMgUmFzdGVyLCBkYXMgZGllIE1vZGVsbGVyZ2Vibmlzc2UgZW50aMOkbHQuIERpZSBGdW5rdGlvbiB3aXJkIG51ciBnZW1laW5zYW0gbWl0IGRlciBGdW5rdGlvbiBcXFwiVmVyw6RuZGVydW5nIG1pdCBWZXLDpG5kZXJ1bmdzYW5hbHlzZSBlcmtlbm5lblxcXCIgaW4gZWluZXIgVm9ybGFnZSBmw7xyIFJhc3Rlci1GdW5rdGlvbmVuIHVudGVyc3TDvHR6dC4gVW0gZWluZSBSYXN0ZXItQXVzZ2FiZSB6dSBlcnpldWdlbiwgdmVyYmluZGVuIFNpZSBkaWUgRnVua3Rpb24gXFxcIkNDREMtQW5hbHlzZVxcXCIgbWl0IGRlciBGdW5rdGlvbiBcXFwiVmVyw6RuZGVydW5nIG1pdCBWZXLDpG5kZXJ1bmdzYW5hbHlzZSBlcmtlbm5lblxcXCIsIHNwZWljaGVybiBTaWUgZGllcyBhbHMgUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2UsIHVuZCBmw7xocmVuIFNpZSBkaWUgUmFzdGVyLUFuYWx5c2UgbWl0IGRlciBGdW5rdGlvbnN2b3JsYWdlIGF1cy48ZGl2Pjxici8+RGllc2UgRnVua3Rpb24gdmVyd2VuZGV0IGRlbiBDQ0RDLUFsZ29yaXRobXVzIChDb250aW51b3VzIERldGVjdGlvbiBhbmQgQ2xhc3NpZmljYXRpb24pLCB1bSDDhG5kZXJ1bmdlbiBhbiBQaXhlbHdlcnRlbiBpbSB6ZWl0bGljaGVuIFZlcmxhdWYgZsO8ciBlaW5lIFJlaWhlIHZvbiBCaWxkZXJuIGF1c3p1d2VydGVuLiBJbiBlaW5lciBaZWl0c2VyaWUgdm9uIG9wdGlzY2hlbiBCaWxkZGF0ZW4gb2RlciBhYmdlbGVpdGV0ZW4gQmlsZGRhdGVuICh6LiBCLiBORFZJKSBrw7ZubmVuIFBpeGVsd2VydGUgYXVzIG1laHJlcmVuIEdyw7xuZGVuIHNjaHdhbmtlbjogMS4gSmFocmVzemVpdGxpY2hlIFZlcsOkbmRlcnVuZ2VuOiDDhG5kZXJ1bmdlbiBhbiBQaXhlbHdlcnRlbiBzcGllZ2VsbiBWZXLDpG5kZXJ1bmdlbiBpbiBkZXIgVmVnZXRhdGlvbiBhdWZncnVuZCBqYWhyZXN6ZWl0bGljaGVyIFNjaHdhbmt1bmdlbiB2b24gVGVtcGVyYXR1ciB1bmQgTmllZGVyc2NobMOkZ2VuIHdpZGVyLiBJbiBkZXIgbsO2cmRsaWNoZW4gSGVtaXNwaMOkcmUgZXR3YSB3aXJkIGVpbmUgaMO2aGVyZSBEaWNodGUgYW4gZ3LDvG5lciBWZWdldGF0aW9uIGltIFNvbW1lciBhbHMgaW0gV2ludGVyIGVyd2FydGV0LiAyLiBBbGxtw6RobGljaGUgVmVyw6RuZGVydW5nZW46IMOEbmRlcnVuZ2VuIGFuIFBpeGVsd2VydGVuIHNwaWVnZWxuIFRyZW5kcyBiZWkgZGVyIFZlZ2V0YXRpb24gb2RlciBPYmVyZmzDpGNoZW5nZXfDpHNzZXJuIGF1ZmdydW5kIGtsaW1hdGlzY2hlciBTY2h3YW5rdW5nZW4gb2RlciBsYW5nZnJpc3RpZ2VyIExhbmRiZXdpcnRzY2hhZnR1bmdzcHJha3Rpa2VuIHdpZGVyLiBCZWlzcGllbHN3ZWlzZSBrYW5uIGRlciBBbnRlaWwgdm9uIG5hY2t0ZXIgRXJkZSBpbiBlaW5lbSBHZWJpZXQgYWxsbcOkaGxpY2ggenVuZWhtZW4sIHdlbm4gZGllIE5pZWRlcnNjaGxhZ3NtZW5nZSBsYW5nZnJpc3RpZyBhYm5pbW10LiAzLiBBYnJ1cHRlIFZlcsOkbmRlcnVuZ2VuOiDDhG5kZXJ1bmdlbiBhbiBQaXhlbHdlcnRlbiBzcGllZ2VsbiBWZXLDpG5kZXJ1bmdlbiBiZWkgZGVyIExhbmRiZWRlY2t1bmcgd2lkZXIsIGRpZSBiZWlzcGllbHN3ZWlzZSBhdWZncnVuZCB2b24gQWJob2x6dW5nZW4sIGRlciBTdGFkdGVudHdpY2tsdW5nIHVuZCBOYXR1cmthdGFzdHJvcGhlbiBhdWZ0cmV0ZW4uIERlciBDQ0RDLUFsZ29yaXRobXVzIGlkZW50aWZpemllcnQgYWxsZSBkcmVpIFZlcsOkbmRlcnVuZ3N0eXBlbiBtaXQgZGVtIHByaW3DpHJlbiBad2VjaywgYWJydXB0ZSBWZXLDpG5kZXJ1bmdlbiB6dSBlcmtlbm5lbi4gSGFybW9uaXNjaGUgUmVncmVzc2lvbnMtIHVuZCBUcmVuZG1vZGVsbGUgd2VyZGVuIGF1ZiBkaWUgRGF0ZW4gZWluZ2VwYXNzdCwgdW0gamFocmVzemVpdGxpY2hlIHVuZCBhbGxtw6RobGljaGUgVmVyw6RuZGVydW5nZW4gYWJ6dXNjaMOkdHplbi4gUGzDtnR6bGljaGUgQWJ3ZWljaHVuZ2VuIHZvbiBkZW4gVHJlbmRtb2RlbGxlbiB3ZWlzZW4gYXVmIGFicnVwdGUgVmVyw6RuZGVydW5nZW4gaGluLjxkaXY+PGJyLz5EZXIgQ0NEQy1BbGdvcml0aG11cyB3dXJkZSB1cnNwcsO8bmdsaWNoIGbDvHIgRGF0ZW4genVyIE9iZXJmbMOkY2hlbnJlZmxla3Rpb24gb2RlciBTdHJhaGx1bmdzdGVtcGVyYXR1ciB2b24gTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rIHVuZCBMYW5kc2F0IE9MSSBlbnR3aWNrZWx0LiBEaWUgRnVua3Rpb24gXFxcIlZlcsOkbmRlcnVuZyBtaXQgVmVyw6RuZGVydW5nc2FuYWx5c2UgZXJrZW5uZW5cXFwiIGluIEtvbWJpbmF0aW9uIG1pdCBkaWVzZXIgRnVua3Rpb24gZXJrZW5udCBqZWRvY2ggTXVsdGliYW5kLUJpbGRkYXRlbiB2b24gYWxsZW4gdW50ZXJzdMO8dHp0ZW4gU2Vuc29yZW4gc293aWUgQWJsZWl0dW5nZW4gdm9uIEVpbnplbGJhbmQtQmlsZGRhdGVuIHdpZSBCYW5kaW5kaXplcy4gU2llIGvDtm5uZW4gYmVpc3BpZWxzd2Vpc2UgZWluZSBrb250aW51aWVybGljaGUgVmVyw6RuZGVydW5nc2Vya2VubnVuZyBmw7xyIGVpbiBORFZJLVJhc3RlciAoTm9ybWFsaXNpZXJ0ZXIgZGlmZmVyZW56aWVydGVyIFZlZ2V0YXRpb25zaW5kZXgpIGR1cmNoZsO8aHJlbiwgZGEgYWJydXB0ZSDDhG5kZXJ1bmdlbiBiZWltIE5EVkkgYXVmIGVpbmUgQWJob2x6dW5nIGhpbmRldXRlbiBrw7ZubmVuLjwvZGl2PlwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VOYW1lOiBcIlZlcsOkbmRlcnVuZ2VuIGJlcmVjaG5lblwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VTbmlwOiBcIkJlcmVjaG5ldCBkaWUgVW50ZXJzY2hpZWRlIHp3aXNjaGVuIHp3ZWkga2F0ZWdvcmlzY2hlbiBvZGVyIGtvbnRpbnVpZXJsaWNoZW4gUmFzdGVyLURhdGFzZXRzLlwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VEZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiVmVyw6RuZGVydW5nIGJlcmVjaG5lblxcXCIga2FubiB2ZXJ3ZW5kZXQgd2VyZGVuLCB1bSBkaWUgVW50ZXJzY2hpZWRlIHp3aXNjaGVuIHp3ZWkga2xhc3NpZml6aWVydGVuIFJhc3Rlcm4gZsO8ciBkaWUgQW5hbHlzZSB2b24gw4RuZGVydW5nZW4gZGVyIExhbmRiZWRlY2t1bmcgYXVmenV6w6RobGVuIG9kZXIgw4RuZGVydW5nZW4gendpc2NoZW4gendlaSBrb250aW51aWVybGljaGVuIEVpbnplbGJhbmQtUmFzdGVybiB6dSB1bnRlcnN1Y2hlbiwgei4gQi4gSMO2aGUsIFRlbXBlcmF0dXIgdW5kIERlY2t1bmdzZ3JhZC5cIixcblx0XHRkZXRlY3RDaGFuZ2VOYW1lOiBcIlZlcsOkbmRlcnVuZyBtaXQgVmVyw6RuZGVydW5nc2FuYWx5c2UgZXJrZW5uZW5cIixcblx0XHRkZXRlY3RDaGFuZ2VTbmlwOiBcIkdlbmVyaWVydCBtaXQgZGVtIEF1c2dhYmUtVmVyw6RuZGVydW5nc2FuYWx5c2UtUmFzdGVyIGVpbmVuIFJhc3Rlci1MYXllciwgZGVyIFBpeGVsw6RuZGVydW5nc2luZm9ybWF0aW9uZW4gZW50aMOkbHQuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlRGVzYzogXCI8ZGl2PkRpZSBGdW5rdGlvbiBcXFwiVmVyw6RuZGVydW5nIG1pdCBWZXLDpG5kZXJ1bmdzYW5hbHlzZS1SYXN0ZXIgZXJrZW5uZW5cXFwiIGdlbmVyaWVydCBtaXQgZGVtIFZlcsOkbmRlcnVuZ3NhbmFseXNlLVJhc3RlciBlaW5lbiBSYXN0ZXItTGF5ZXIsIGRlciBJbmZvcm1hdGlvbmVuIHp1bSBQaXhlbMOkbmRlcnVuZ3NkYXR1bSBlbnRow6RsdC4gRGFzIFZlcsOkbmRlcnVuZ3NhbmFseXNlLVJhc3RlciBtdXNzIG1pdCBkZW0gV2Vya3pldWcgXFxcIlZlcsOkbmRlcnVuZ2VuIG1pdCBDQ0RDIGFuYWx5c2llcmVuXFxcIiwgZGVtIFdlcmt6ZXVnIFxcXCJWZXLDpG5kZXJ1bmdlbiBtaXQgTGFuZFRyZW5kciBhbmFseXNpZXJlblxcXCIsIGRlciBSYXN0ZXItRnVua3Rpb24gXFxcIkNDREMtQW5hbHlzZVxcXCIgb2RlciBkZXIgUmFzdGVyLUZ1bmt0aW9uIFxcXCJMYW5kVHJlbmRyLUFuYWx5c2VcXFwiIGdlbmVyaWVydCB3ZXJkZW4uPC9kaXY+PGJyPjxkaXY+RGllc2UgUmFzdGVyLUZ1bmt0aW9uIGthbm4gbWl0IGRlciBSYXN0ZXItRnVua3Rpb24gXFxcIkNDREMtQW5hbHlzZVxcXCIgb2RlciBkZXIgUmFzdGVyLUZ1bmt0aW9uIFxcXCJMYW5kVHJlbmRyXFxcIiBpbiBlaW5lciBSYXN0ZXItRnVua3Rpb25zdm9ybGFnZSBrb21iaW5pZXJ0IHdlcmRlbi4gVW0gZWluZSBkYXVlcmhhZnRlIFJhc3Rlci1BdXNnYWJlIHp1IGVyemV1Z2VuLCB2ZXJiaW5kZW4gU2llIGRpZSBBdXNnYWJlIGRlciBGdW5rdGlvbiBcXFwiQ0NEQy1BbmFseXNlXFxcIiBvZGVyIFxcXCJMYW5kVHJlbmRyXFxcIiBtaXQgZGVyIEZ1bmt0aW9uIFxcXCJWZXLDpG5kZXJ1bmcgbWl0IFZlcsOkbmRlcnVuZ3NhbmFseXNlIGVya2VubmVuXFxcIiwgc3BlaWNoZXJuIFNpZSBkaWVzZSBhbHMgUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2UsIHVuZCBmw7xocmVuIFNpZSBkaWUgUmFzdGVyLUFuYWx5c2UgbWl0IGRlciBWb3JsYWdlIGF1cy48L2Rpdj48YnI+PGRpdj5EdXJjaCBkZW4gUGFyYW1ldGVyIDxzdHJvbmc+QXJ0IGRlciDDhG5kZXJ1bmc8L3N0cm9uZz4gd2lyZCBhbmdlZ2ViZW4sIHdlbGNoZSBJbmZvcm1hdGlvbmVuIGVyc3RlbGx0IHdlcmRlbi4gRGllIEluZm9ybWF0aW9uZW4gd2VyZGVuIGF1cyBkZW0gVmVyw6RuZGVydW5nc2FuYWx5c2UtUmFzdGVyIGV4dHJhaGllcnQuIEJlaSBBdXNmw7xocnVuZyBkaWVzZXMgV2Vya3pldWdzIGbDvHIgZGllIEF1c2dhYmUgZGVyIENDREMtRnVua3Rpb24gYnp3LiBkZXMgQ0NEQy1XZXJremV1Z3Mga8O2bm5lbiBTaWUgZWluZSBkZXIgZm9sZ2VuZGVuIE9wdGlvbmVuIGF1c3fDpGhsZW46PC9kaXY+PHVsPjxsaT48c3Ryb25nPlplaXQgZGVyIGxldHp0ZW4gw4RuZGVydW5nPC9zdHJvbmc+OiBEYXR1bSB1bmQgVWhyemVpdCwgenUgZGVuZW4gZWluIFBpeGVsIHp1bGV0enQgYWxzIGdlw6RuZGVydCBnZWtlbm56ZWljaG5ldCB3dXJkZS48L2xpPjxsaT48c3Ryb25nPlplaXQgZGVyIGVyc3RlbiDDhG5kZXJ1bmc8L3N0cm9uZz46IERhdHVtIHVuZCBVaHJ6ZWl0LCB6dSBkZW5lbiBlaW4gUGl4ZWwgZGFzIGVyc3RlIE1hbCBhbHMgZ2XDpG5kZXJ0IGdla2VubnplaWNobmV0IHd1cmRlLjwvbGk+PGxpPjxzdHJvbmc+WmVpdCBkZXIgZ3LDtsOfdGVuIMOEbmRlcnVuZzwvc3Ryb25nPjogRGF0dW0gdW5kIFVocnplaXQsIHp1IGRlbmVuIGRpZSBiZXJlY2huZXRlIMOEbmRlcnVuZyBkaWUgZ3LDtsOfdGUgU2lnbmlmaWthbnogZsO8ciBlaW4gUGl4ZWwgYXVmd2llcy48L2xpPjxsaT4gPHN0cm9uZz5BbnphaGwgYW4gw4RuZGVydW5nZW46PC9zdHJvbmc+IERpZSBHZXNhbXR6YWhsIGRlciDDhG5kZXJ1bmdlbiBhbiBlaW5lbSBQaXhlbC48L2xpPjwvdWw+PGRpdj5CZWkgQXVzZsO8aHJ1bmcgZGllc2VyIEZ1bmt0aW9uIGbDvHIgZGllIEF1c2dhYmUgZGVzIFdlcmt6ZXVncyBiencuIGRlciBGdW5rdGlvbiBcXFwiTGFuZFRyZW5kclxcXCIgc3RlaGVuIGRpZSBmb2xnZW5kZW4genVzw6R0emxpY2hlbiBPcHRpb25lbiB6dXIgVmVyZsO8Z3VuZzo8L2Rpdj48dWw+PGxpPjxzdHJvbmc+WmVpdCBkZXIgbMOkbmdzdGVuIMOEbmRlcnVuZzwvc3Ryb25nPjogRGF0dW0sIGFuIGRlbSBlaW4gUGl4ZWwgYWxzIGdlw6RuZGVydCBnZWtlbm56ZWljaG5ldCB3dXJkZSwgYW0gQW5mYW5nIG9kZXIgRW5kZSBkZXMgbMOkbmdzdGVuIMOEbmRlcnVuZ3N6ZWl0cmF1bXMuPC9saT48bGk+PHN0cm9uZz5aZWl0IGRlciBrw7xyemVzdGVuIMOEbmRlcnVuZzwvc3Ryb25nPjogRGF0dW0sIGFuIGRlbSBlaW4gUGl4ZWwgYWxzIGdlw6RuZGVydCBnZWtlbm56ZWljaG5ldCB3dXJkZSwgYW0gQW5mYW5nIG9kZXIgRW5kZSBkZXMga8O8cnplc3RlbiDDhG5kZXJ1bmdzemVpdHJhdW1zLjwvbGk+PGxpPjxzdHJvbmc+WmVpdCBkZXIgc2NobmVsbHN0ZW4gw4RuZGVydW5nPC9zdHJvbmc+OiBEYXR1bSwgYW4gZGVtIGVpbiBQaXhlbCBhbHMgZ2XDpG5kZXJ0IGdla2VubnplaWNobmV0IHd1cmRlLCBhbSBBbmZhbmcgb2RlciBFbmRlIGRlcyBaZWl0cmF1bXMgZGVyIHNjaG5lbGxzdGVuIMOEbmRlcnVuZy48L2xpPjxsaT48c3Ryb25nPlplaXQgZGVyIGxhbmdzYW1zdGVuIMOEbmRlcnVuZzwvc3Ryb25nPjogRGF0dW0sIGFuIGRlbSBlaW4gUGl4ZWwgYWxzIGdlw6RuZGVydCBnZWtlbm56ZWljaG5ldCB3dXJkZSwgYW0gQW5mYW5nIG9kZXIgRW5kZSBkZXMgWmVpdHJhdW1zIGRlciBsYW5nc2Ftc3RlbiDDhG5kZXJ1bmcuPC9saT48L3VsPjxkaXY+QXVzZ2VnZWJlbiB3aXJkIGVpbiBNdWx0aWJhbmQtUmFzdGVyLCBkZXNzZW4gQsOkbmRlciBhYmjDpG5naWcgdm9tIGF1c2dld8OkaGx0ZW4gw4RuZGVydW5nc3R5cCB1bmQgZGVyIGFuZ2VnZWJlbmVuIG1heGltYWxlbiBBbnphaGwgdm9uIMOEbmRlcnVuZ2VuIMOEbmRlcnVuZ3NpbmZvcm1hdGlvbmVuIGVudGhhbHRlbi4gV2VubiBiZWlzcGllbHN3ZWlzZSA8c3Ryb25nPsOEbmRlcnVuZ3N0eXA8L3N0cm9uZz4gYXVmIDxzdHJvbmc+WmVpdCBkZXIgZXJzdGVuIMOEbmRlcnVuZzwvc3Ryb25nPiB1bmQgPHN0cm9uZz5NYXhpbWFsZSBBbnphaGwgYW4gw4RuZGVydW5nZW48L3N0cm9uZz4gYXVmIDIgZmVzdGdlbGVndCB3aXJkLCBiZXJlY2huZXQgZGllIEZ1bmt0aW9uIGpld2VpbHMgZGllIHp3ZWkgZXJzdGVuIMOEbmRlcnVuZ2VuLCBkaWUgaW4gZGVyIFplaXRzZXJpZSBmw7xyIGRpZSBQaXhlbCB2b3JsaWVnZW4uIEF1c2dlZ2ViZW4gd2lyZCBlaW4gUmFzdGVyIG1pdCB6d2VpIELDpG5kZXJuLCB3b2JlaSBkYXMgZXJzdGUgQmFuZCBkYXMgRGF0dW0gZGVyIGVyc3RlbiDDhG5kZXJ1bmcgZWluZXMgUGl4ZWxzIGVudGjDpGx0IHVuZCBkYXMgendlaXRlIEJhbmQgZGFzIERhdHVtIGRlciB6d2VpdMOkbHRlc3RlbiDDhG5kZXJ1bmcgamUgUGl4ZWwuPC9kaXY+PGJyPjxkaXY+QmVpIEFud2VuZHVuZyBkaWVzZXIgRnVua3Rpb24gYXVmIGRpZSBBdXNnYWJlIGRlciBXZXJremV1Z2UgXFxcIkxhbmRUcmVuZHJcXFwiIGvDtm5uZW4gU2llIG9wdGlvbmFsIG1pdCBkZW0gUGFyYW1ldGVyIDxzdHJvbmc+U2VnbWVudGRhdHVtPC9zdHJvbmc+IGRhcyBEYXR1bSBleHRyYWhpZXJlbiwgZGFzIGRlbiBBbmZhbmcgb2RlciBkYXMgRW5kZSBlaW5lciDDhG5kZXJ1bmcgbWFya2llcnQuIFdlbm4gU2llIGJlaXNwaWVsc3dlaXNlIHdpc3NlbiBtw7ZjaHRlbiwgd2llIGRpZSBsZXR6dGUgw4RuZGVydW5nIGluIGRlciBaZWl0c2VyaWUgYmVnb25uZW4gaGF0LCBsZWdlbiBTaWUgZGVuIFBhcmFtZXRlciA8c3Ryb25nPkFydCBkZXIgw4RuZGVydW5nPC9zdHJvbmc+IGF1ZiA8c3Ryb25nPlplaXQgZGVyIGxldHp0ZW4gw4RuZGVydW5nPC9zdHJvbmc+IHVuZCBkZW4gUGFyYW1ldGVyIDxzdHJvbmc+U2VnbWVudGRhdHVtPC9zdHJvbmc+IGF1ZiA8c3Ryb25nPkFuZmFuZyBkZXMgU2VnbWVudHM8L3N0cm9uZz4gZmVzdC48L2Rpdj48YnI+PGRpdj5WZXJ3ZW5kZW4gU2llIGRpZSBmb2xnZW5kZW4gRmlsdGVycGFyYW1ldGVyLCB1bSBzcGV6aWZpc2NoZXJlIERhdHVtc2FuZ2FiZW4genUgw4RuZGVydW5nZW4gYXVzIGRlbSBWZXLDpG5kZXJ1bmdzYW5hbHlzZS1SYXN0ZXIgenUgZXh0cmFoaWVyZW46PC9kaXY+PHVsPjxsaT48c3Ryb25nPk5hY2ggSmFociBmaWx0ZXJuOjwvc3Ryb25nPiBIaWVybWl0IGlkZW50aWZpemllcmVuIFNpZSBWZXLDpG5kZXJ1bmdlbiwgZGllIGlubmVyaGFsYiBlaW5lcyBiZXN0aW1tdGVuIFplaXRyYXVtcyBlaW5nZXRyZXRlbiBzaW5kLCB6LsKgQi4sIHdlbm4gU2llIG5hY2ggVmVyw6RuZGVydW5nZW4gaW4gZWluZXIgTGFuZHNjaGFmdCB3w6RocmVuZCBlaW5lciBmw7xuZiBKYWhyZSBhbmRhdWVybmRlbiBUcm9ja2VuaGVpdCBzdWNoZW4uPC9saT48bGk+PHN0cm9uZz5OYWNoIERhdWVyIGZpbHRlcm46PC9zdHJvbmc+IEhpZXJtaXQgaWRlbnRpZml6aWVyZW4gU2llIFZlcsOkbmRlcnVuZ2VuLCBkaWUgw7xiZXIgZWluZSBiZXN0aW1tdGUgQW56YWhsIHZvbiBKYWhyZW4gaGlud2VnIGVpbmdldHJldGVuIHNpbmQsIHouwqBCLiwgd2VubiBTaWUgbmFjaCBhYnJ1cHRlbiBWZXLDpG5kZXJ1bmdlbiDDvGJlciBlaW5lbiBaZWl0cmF1bSB2b24gZWluZW0gb2RlciB6d2VpIEphaHJlbiBzdWNoZW4uIERpZSBEYXVlciwgZsO8ciBkaWUgU2llIHNpY2ggaW50ZXJlc3NpZXJlbiwga8O2bm5lbiBTaWUgbWl0IGRlciBGb3JtZWwgPHN0cm9uZz5FbmRqYWhyIC0gU3RhcnRqYWhyICsgMTwvc3Ryb25nPiBiZXJlY2huZW4uIEzDvGNrZW4gaW4gZGVyIFplaXRzZXJpZSB3ZXJkZW4gYmVyw7xja3NpY2h0aWd0LjwvbGk+PGxpPjxzdHJvbmc+TmFjaCBNYWduaXR1ZGUgZmlsdGVybjo8L3N0cm9uZz4gSGllcm1pdCBpZGVudGlmaXppZXJlbiBTaWUgVmVyw6RuZGVydW5nZW4gZWluZXIgYmVzdGltbXRlbiBNYWduaXR1ZGUsIHouwqBCLiwgd2VubiBTaWUgbnVyIG5hY2ggZ3Jvw59lbiBWZXLDpG5kZXJ1bmdlbiBpbSBWZWdldGF0aW9uc2luZGV4IE5EVkkgc3VjaGVuLiBEYSBkaWUgTWFnbml0dWRlIGVpbiBhYnNvbHV0ZXIgV2VydCBpc3QsIGTDvHJmZW4gZGVyIE1pbmltYWwtIHVuZCBNYXhpbWFsd2VydCBuaWNodCBuZWdhdGl2IHNlaW4uIFZlcndlbmRlbiBTaWUgenVtIEZlc3RsZWdlbiBlaW5lciBSaWNodHVuZ3PDpG5kZXJ1bmcgZGVuIFBhcmFtZXRlciA8c3Ryb25nPlJpY2h0dW5nIGRlciDDhG5kZXJ1bmc8L3N0cm9uZz4uPC9saT48L3VsPlwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uTmFtZTogXCJFbnRmZXJudW5nc2Fra3VtdWxhdGlvblwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uU25pcDogXCJCZXJlY2huZXQgZGllIGFra3VtdWxhdGl2ZSBFbnRmZXJudW5nIHZvbiBqZWRlciBaZWxsZSB6dSBRdWVsbGVuLiBEYWJlaSB3ZXJkZW4gZ2VyYWRsaW5pZ2UgRW50ZmVybnVuZywgS29zdGVuZW50ZmVybnVuZywgdGF0c8OkY2hsaWNoZSBPYmVyZmzDpGNoZW5lbnRmZXJudW5nIHNvd2llIHZlcnRpa2FsZSB1bmQgaG9yaXpvbnRhbGUgS29zdGVuZmFrdG9yZW4gYmVyw7xja3NpY2h0aWd0LlwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uRGVzYzogXCJNaXQgXFxcIkVudGZlcm51bmdzYWtrdW11bGF0aW9uXFxcIiB3aXJkIGRpZSBFbnRmZXJudW5nIHZvbiBkZW4gZWluemVsbmVuIFBvc2l0aW9uZW4gaW4gZWluZW0gVW50ZXJzdWNodW5nc2dlYmlldCB6dXIgbsOkY2hzdGdlbGVnZW5lbiBiencuIGtvc3RlbmfDvG5zdGlnc3RlbiBRdWVsbGUgYmVyZWNobmV0LiBXZW5uIG51ciBkaWUgUXVlbGxlbiBmw7xyIGRpZSBFaW5nYWJlIGFuZ2VnZWJlbiB3ZXJkZW4sIHdpcmQgZWluZSBnZXJhZGxpbmlnZSBFbnRmZXJudW5nIHp1IGRlbiBlaW56ZWxuZW4gUG9zaXRpb25lbiBpbSBVbnRlcnN1Y2h1bmdzZ2ViaWV0IGJlcmVjaG5ldC4gV2VubiBzb3dvaGwgUXVlbGxlbiBhbHMgYXVjaCBCYXJyaWVyZW4gYWxzIEVpbmdhYmUgdmVyd2VuZGV0IHdlcmRlbiwgd2lyZCBiZWkgZGVyIEVudGZlcm51bmdzYWtrdW11bGF0aW9uIGRpZSBnZXJhZGxpbmlnZSBFbnRmZXJudW5nIHVtIGRpZSBCYXJyaWVyZW4gaGVydW0gYmVyZWNobmV0LiBCZWltIFF1ZWxsLVJhc3RlciB1bmQgQmFycmllcmVuLVJhc3RlciBzb2xsdGUgZGVyIEhpbnRlcmdydW5kd2VydCBOb0RhdGEgc2VpbiB1bmQgZGllIFF1ZWxsZW4gdW5kIEJhcnJpZXJlbiBtw7xzc2VuIGR1cmNoIGfDvGx0aWdlIFplbGxlbndlcnRlIGRhcmdlc3RlbGx0IHdlcmRlbi4gTnVsbCBpc3QgZWluIGfDvGx0aWdlciBXZXJ0LiA8ZGl2Pjxici8+V2VubiBlaW4gT2JlcmZsw6RjaGVuLVJhc3RlciBhbHMgRWluZ2FiZSBhbmdlZ2ViZW4gd3VyZGUsIHdpcmQgZGllIHRhdHPDpGNobGljaGUgT2JlcmZsw6RjaGVuZW50ZmVybnVuZyB6d2lzY2hlbiBaZWxsZW4gYmVyZWNobmV0LiBEYW1pdCBlaW5lIEtvc3RlbmFuYWx5c2UgbWl0IGRlciBFbnRmZXJudW5nc2Fra3VtdWxhdGlvbiBkdXJjaGdlZsO8aHJ0IHdlcmRlbiBrYW5uLCB3aXJkIGVpbmUgS29zdGVub2JlcmZsw6RjaGUgYmVuw7Z0aWd0LiBXZW5uIGVpbmUgS29zdGVub2JlcmZsw6RjaGUgYW5nZWdlYmVuIHdpcmQsIHN0ZWxsdCBkYXMgRXJnZWJuaXMgZWluIGFra3VtdWxpZXJ0ZXMgS29zdGVuZW50ZmVybnVuZ3MtUmFzdGVyIGRhci4gQmVpIGRlciBBbmdhYmUgdm9uIGhvcml6b250YWxlbiB1bmQgdmVydGlrYWxlbiBGYWt0b3JlbiB3aXJkIGRpZSBSaWNodHVuZ3NhYmjDpG5naWdrZWl0IGFscyBha2t1bXVsaWVydGUgS29zdGVuIGJldHJhY2h0ZXQuIEVzIGdpYnQgdmllciBRdWVsbGVuZWlnZW5zY2hhZnRlbiwgZGllIHZlcndlbmRldCB3ZXJkZW4ga8O2bm5lbi4gRGllc2UgRWlnZW5zY2hhZnRlbiBrw7ZubmVuIGVudHdlZGVyIGRpZSBRdWVsbGUgb2RlciBkaWUgUmVpc2VuZGVuIHZvbiBkZXIgUXVlbGxlIGRhcnN0ZWxsZW4gdW5kIGR1cmNoIG1laHJlcmUgc3BlemlmaXNjaGUgUGFyYW1ldGVyIGdlc3RldWVydCB3ZXJkZW46IDEuIEluaXRpYWxlIEFra3VtdWxhdGlvbjrigK9sZWd0IGRpZSBhbmbDpG5nbGljaGVuIEtvc3RlbiB2b3IgQmVnaW5uIGRlciBCZXdlZ3VuZyBmZXN0LiBNYXhpbWFsZSBBa2t1bXVsYXRpb246IExlZ3QgZmVzdCwgd2VsY2hlIEjDtmhlIGFuIEtvc3RlbiBlaW5lIFF1ZWxsZSBtYXhpbWFsIGFra3VtdWxpZXJlbiBrYW5uLCBiZXZvciBkaWUgR3JlbnplIGVycmVpY2h0IHdpcmQ6IDMuIE11bHRpcGxpa2F0b3IgenVtIEFud2VuZGVuIHZvbiBLb3N0ZW464oCvZ2lidCBkZW4gUmVpc2Vtb2R1cyBvZGVyIGRpZSBIw7ZoZSBhbiBkZXIgUXVlbGxlIGFuLiBSZWlzZXJpY2h0dW5nOiBFcm1pdHRlbHQsIG9iIGRlciBSZWlzZW5kZSBhbiBlaW5lciBRdWVsbGUgc3RhcnRldCB1bmQgenUgTmljaHQtUXVlbGxlbnBvc2l0aW9uZW4gcmVpc3Qgb2RlciBhbiBhbmRlcmVuIE5pY2h0LVF1ZWxsZW5wb3NpdGlvbmVuIHN0YXJ0ZXQgdW5kIHp1csO8Y2sgenUgZWluZXIgUXVlbGxlIHJlaXN0LjxkaXY+PGJyLz5TdGFuZGFyZG3DpMOfaWcgaXN0IGRhcyBFcmdlYm5pcyBkZXIgRW50ZmVybnVuZ3Nha2t1bXVsYXRpb24gZWluIEVpbnplbGJhbmQsIGRhcyBkYXMgRW50ZmVybnVuZ3Nha2t1bXVsYXRpb25zLVJhc3RlciBkYXJzdGVsbHQuIEVzIGthbm4gamVkb2NoIGVpbiB6d2VpdGVzIEJhbmQgZXJzdGVsbHQgd2VyZGVuLCBkYXMgR2VnZW5yaWNodHVuZ3NiYW5kLiBEaWVzZXMgQmFuZCBnaWJ0IHZvbiBqZWRlciBQb3NpdGlvbiBpbSBVbnRlcnN1Y2h1bmdzZ2ViaWV0IGFuLCBpbiB3ZWxjaGUgUmljaHR1bmcgZGllIGtvc3RlbmfDvG5zdGlnc3RlIFF1ZWxsZSBsaWVndC4gQmVpZGUgQsOkbmRlciB3ZXJkZW4gYmVuw7Z0aWd0LCB1bSBkaWUgb3B0aW1hbGVuIFBmYWRlIGltIFVudGVyc3VjaHVuZ3NnZWJpZXQgenUgYmVzdGltbWVuLiBFeHRyYWhpZXJlbiBTaWUgenVyIEVyemV1Z3VuZyBlaW5lcyBQZmFkZXMgenVuw6RjaHN0IG1pdGhpbGZlIGRlciBGdW5rdGlvbiBcXFwiQsOkbmRlciBleHRyYWhpZXJlblxcXCIgZGFzIEVudGZlcm51bmdzYWtrdW11bGF0aW9ucy1SYXN0ZXIgdW5kIGRhcyBHZWdlbnJpY2h0dW5ncy1SYXN0ZXIuIERpZXNlIExheWVyIGRpZW5lbiBhbHMgRWluZ2FiZSBmw7xyIGRpZSBGdW5rdGlvbiBcXFwiS29zdGVucGZhZFxcXCIuIFZlcndlbmRlbiBTaWUgaW4gZGVyIEZ1bmt0aW9uIGRhcyBFbnRmZXJudW5nc2Fra3VtdWxhdGlvbnMtUmFzdGVyIGFscyBFaW5nYWJlIGbDvHIgZGFzIEtvc3RlbmVudGZlcm51bmdzLVJhc3RlciB1bmQgZGFzIEdlZ2VucmljaHR1bmdzLVJhc3RlciBhbHMgRWluZ2FiZSBmw7xyIGRhcyBLb3N0ZW4tUsO8Y2t2ZXJrbsO8cGZ1bmdzLVJhc3Rlci48L2Rpdj5cIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25OYW1lOiBcIkVudGZlcm51bmdzYWxsb2thdGlvblwiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvblNuaXA6IFwiQmVyZWNobmV0IGRpZSBFbnRmZXJudW5nc2FsbG9rYXRpb24gZsO8ciBqZWRlIFplbGxlIHp1IGRlbiBhbmdlZ2ViZW5lbiBRdWVsbGVuIGF1ZiBHcnVuZGxhZ2Ugdm9uIGdlcmFkbGluaWdlciBFbnRmZXJudW5nLCBLb3N0ZW5lbnRmZXJudW5nLCB0YXRzw6RjaGxpY2hlciBPYmVyZmzDpGNoZW5lbnRmZXJudW5nIHNvd2llIHZlcnRpa2FsZXIgdW5kIGhvcml6b250YWxlciBLb3N0ZW5mYWt0b3Jlbi5cIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25EZXNjOiBcIkRpZSBFbnRmZXJudW5nc2FsbG9rYXRpb24gYmVyZWNobmV0LCB3ZWxjaGVyIFF1ZWxsZSBkaWUgZWluemVsbmVuIFBvc2l0aW9uZW4gaW0gVW50ZXJzdWNodW5nc2dlYmlldCB6dWdld2llc2VuIHdlcmRlbi4gV2VubiBudXIgZGllIFF1ZWxsZW4gYWxzIEVpbmdhYmUgYW5nZWdlYmVuIHNpbmQsIHdlcmRlbiBkaWUgUG9zaXRpb25lbiBkdXJjaCBlaW5lIGdlcmFkbGluaWdlIEVudGZlcm51bmcgenVyIG7DpGNoc3RnZWxlZ2VuZW4gUXVlbGxlIHp1Z2V3aWVzZW4uIFdlbm4gc293b2hsIFF1ZWxsZW4gYWxzIGF1Y2ggQmFycmllcmVuIGFscyBFaW5nYWJlIHZlcndlbmRldCB3ZXJkZW4sIHdpcmQgYmVpIGRlciBFbnRmZXJudW5nc2FsbG9rYXRpb24gZGllIGdlcmFkbGluaWdlIEVudGZlcm51bmcgdW0gZGllIEJhcnJpZXJlbiBoZXJ1bSBiZXJlY2huZXQsIHVtIHp1IGJlc3RpbW1lbiwgd2VsY2hlciBRdWVsbGUgZWluZSBQb3NpdGlvbiB6dWdld2llc2VuIHdpcmQuIEJlaW0gUXVlbGwtUmFzdGVyIHVuZCBCYXJyaWVyZW4tUmFzdGVyIHNvbGx0ZSBkZXIgSGludGVyZ3J1bmR3ZXJ0IE5vRGF0YSBzZWluIHVuZCBkaWUgUXVlbGxlbiB1bmQgQmFycmllcmVuIG3DvHNzZW4gZHVyY2ggZ8O8bHRpZ2UgWmVsbGVud2VydGUgZGFyZ2VzdGVsbHQgd2VyZGVuLiBOdWxsIGlzdCBlaW4gZ8O8bHRpZ2VyIFdlcnQuPGRpdj48YnIvPkRhbWl0IGVpbmUgS29zdGVuYW5hbHlzZSBtaXQgZGVyIEVudGZlcm51bmdzYWxsb2thdGlvbiBkdXJjaGdlZsO8aHJ0IHdlcmRlbiBrYW5uLCB3aXJkIGVpbmUgS29zdGVub2JlcmZsw6RjaGUgYmVuw7Z0aWd0LiBXZW5uIGVpbmUgS29zdGVub2JlcmZsw6RjaGUgYW5nZWdlYmVuIHdpcmQsIGJlc3RlaHQgZGFzIEVyZ2VibmlzIGF1cyBlaW5lbSBBbGxva2F0aW9ucy1SYXN0ZXIsIGRhcyBhdWYgZGVuIGFra3VtdWxhdGl2ZW4gS29zdGVuIHVuZCBuaWNodCBhdWYgZGVyIGdlcmFkbGluaWdlbiBFbnRmZXJudW5nIGJlcnVodC4gQmVpIGRlciBBbmdhYmUgdm9uIGhvcml6b250YWxlbiB1bmQgdmVydGlrYWxlbiBGYWt0b3JlbiB3aXJkIGRpZSBSaWNodHVuZ3NhYmjDpG5naWdrZWl0IGFscyBha2t1bXVsaWVydGUgS29zdGVuIGJldHJhY2h0ZXQuIFdlbm4gZWluIE9iZXJmbMOkY2hlbi1SYXN0ZXIgYWxzIEVpbmdhYmUgYW5nZWdlYmVuIHd1cmRlLCB3aXJkIGRpZSB0YXRzw6RjaGxpY2ggenVyw7xja2dlbGVndGUgT2JlcmZsw6RjaGVuZW50ZmVybnVuZyBiZWltIFdlY2hzZWwgendpc2NoZW4gWmVsbGVuIGJlaSBkZXIgQmVzdGltbXVuZyBkZXIgQWxsb2thdGlvbiBiZXJlY2huZXQuIEVzIGdpYnQgdmllciBRdWVsbGVuZWlnZW5zY2hhZnRlbiwgZGllIHZlcndlbmRldCB3ZXJkZW4ga8O2bm5lbi4gRGllc2UgRWlnZW5zY2hhZnRlbiBrw7ZubmVuIGVudHdlZGVyIGRpZSBRdWVsbGUgb2RlciBkaWUgUmVpc2VuZGVuIHZvbiBkZXIgUXVlbGxlIGRhcnN0ZWxsZW4gdW5kIGR1cmNoIG1laHJlcmUgc3BlemlmaXNjaGUgUGFyYW1ldGVyIGdlc3RldWVydCB3ZXJkZW46IDEuIEluaXRpYWxlIEFra3VtdWxhdGlvbjrigK9sZWd0IGRpZSBhbmbDpG5nbGljaGVuIEtvc3RlbiB2b3IgQmVnaW5uIGRlciBCZXdlZ3VuZyBmZXN0LiBNYXhpbWFsZSBBa2t1bXVsYXRpb246IExlZ3QgZmVzdCwgd2VsY2hlIEjDtmhlIGFuIEtvc3RlbiBlaW5lIFF1ZWxsZSBtYXhpbWFsIGFra3VtdWxpZXJlbiBrYW5uLCBiZXZvciBkaWUgR3JlbnplIGVycmVpY2h0IHdpcmQ6IDMuIE11bHRpcGxpa2F0b3IgenVtIEFud2VuZGVuIHZvbiBLb3N0ZW464oCvZ2lidCBkZW4gUmVpc2Vtb2R1cyBvZGVyIGRpZSBIw7ZoZSBhbiBkZXIgUXVlbGxlIGFuLiBSZWlzZXJpY2h0dW5nOiBFcm1pdHRlbHQsIG9iIGRlciBSZWlzZW5kZSBhbiBlaW5lciBRdWVsbGUgc3RhcnRldCB1bmQgenUgTmljaHQtUXVlbGxlbnBvc2l0aW9uZW4gcmVpc3Qgb2RlciBhbiBhbmRlcmVuIE5pY2h0LVF1ZWxsZW5wb3NpdGlvbmVuIHN0YXJ0ZXQgdW5kIHp1csO8Y2sgenUgZWluZXIgUXVlbGxlIHJlaXN0LjxkaXY+PGJyLz5TdGFuZGFyZG3DpMOfaWcgaXN0IGRhcyBFcmdlYm5pcyBkZXIgRW50ZmVybnVuZ3NhbGxva2F0aW9uIGVpbiBFaW56ZWxiYW5kLCBkYXMgZGFzIEVudGZlcm51bmdzYWxsb2thdGlvbnMtUmFzdGVyIGRhcnN0ZWxsdC4gQmVpIEFrdGl2aWVydW5nIGRlciBCb29sZXNjaGVuIE9wdGlvbiBcXFwiUXVlbGxlbnplaWxlIHVuZCAtc3BhbHRlIGFscyB6dXPDpHR6bGljaGUgQsOkbmRlciBpbiBBdXNnYWJlIGdlbmVyaWVyZW5cXFwiIHdpcmQgZWluIE11bHRpYmFuZC1SYXN0ZXIgbWl0IGRyZWkgQsOkbmRlcm4gZXJ6ZXVndC4gRGFzIGVyc3RlIEJhbmQgaXN0IGRhcyBFbnRmZXJudW5ncy1BbGxva2F0aW9ucy1CYW5kLCBkYXMgendlaXRlIGVudGjDpGx0IGVpbmVuIFplaWxlbmluZGV4IHVuZCBkYXMgZHJpdHRlIGVpbmVuIFNwYWx0ZW5pbmRleC4gRGllc2UgSW5kaXplcyBnZWJlbiBkaWUgUG9zaXRpb24gZGVyIFF1ZWxsZW56ZWxsZSBhbiwgZGVyZW4gRW50ZmVybnVuZyBkaWUgZ2VyaW5nc3RlbiBha2t1bXVsYXRpdmVuIEtvc3RlbiBhdWZ3ZWlzdC4gUXVlbGxlbnplaWxlbi0gdW5kIFF1ZWxsZW5zcGFsdGVuaW5kZXgga8O2bm5lbiB6dXNhbW1lbiBmw7xyIGRpZSBFcnN0ZWxsdW5nIGVpbmVyIEludGVuc2l0w6R0c2thcnRlIHZlcndlbmRldCB3ZXJkZW4uIFdlbm4gU2llIGluIElocmVtIFVudGVyc3VjaHVuZ3NnZWJpZXQgaW4gZGVuIELDpG5kZXJuIHp3ZWkgdW5kIGRyZWkgZWluZSBQb3NpdGlvbiBhYmZyYWdlbiBtw7ZjaHRlbiwga2VubmVuIFNpZSBkaWUgWmVpbGUgdW5kIFNwYWx0ZSBkZXIga29zdGVuZ8O8bnN0aWdzdGVuIFF1ZWxsZSBmw7xyIGRpZXNlIFBvc2l0aW9uLjwvZGl2PlwiLFxuXHRcdGV1Y0JhY2tEaXJlY3Rpb25OYW1lOiBcIkV1a2xpZGlzY2hlIEdlZ2VucmljaHR1bmdcIixcblx0XHRldWNCYWNrRGlyZWN0aW9uU25pcDogXCJCZXJlY2huZXQgZsO8ciBqZWRlIFplbGxlIGRpZSBSaWNodHVuZyB6dXIgYmVuYWNoYmFydGVuIFplbGxlIGVudGxhbmcgZGVyIGvDvHJ6ZXN0ZW4gUm91dGUgenVyw7xjayB6dXIgbsOkY2hzdGdlbGVnZW5lbiBRdWVsbGUgaW4gR3JhZC4gRGFiZWkgd2VyZGVuIEJhcnJpZXJlbiB2ZXJtaWVkZW4uXCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvbkRlc2M6IFwiRGFzIEVyZ2VibmlzIGRlciBGdW5rdGlvbiBcXFwiRXVrbGlkaXNjaGUgR2VnZW5yaWNodHVuZ1xcXCIgaXN0IGVpbiBrb250aW51aWVybGljaGVzIEdsZWl0a29tbWEtUmFzdGVyLCBkYXMgZGllIFJpY2h0dW5nIGluIEdyYWQgenVyIG7DpGNoc3RnZWxlZ2VuZW4gUXVlbGxlIHp1csO8Y2sgZGFyc3RlbGx0IHVuZCBCYXJyaWVyZW4gdmVybWVpZGV0LCB3ZW5uIEJhcnJpZXJlbiBhbmdlZ2ViZW4gc2luZC48ZGl2Pjxici8+RGllIEVpbmdhYmUgZsO8ciBcXFwiRXVrbGlkaXNjaGUgR2VnZW5yaWNodHVuZ2VuXFxcIiBpc3QgZGllIFF1ZWxsZSwgenUgZGVyIGRpZSBSaWNodHVuZyBiZXJlY2huZXQgd2lyZC4gQWxzIG9wdGlvbmFsZSBFaW5nYWJlIGthbm4gZWluIFJhc3RlciBhbmdlZ2ViZW4gd2VyZGVuLCBkYXMgQmFycmllcmVuIGltIFVudGVyc3VjaHVuZ3NnZWJpZXQgZGFyc3RlbGx0LiBCZWltIFF1ZWxsLVJhc3RlciB1bmQgQmFycmllcmVuLVJhc3RlciBzb2xsdGUgZGVyIEhpbnRlcmdydW5kd2VydCBOb0RhdGEgc2VpbiwgdW5kIGRpZSBRdWVsbGVuIHVuZCBCYXJyaWVyZW4gc29sbHRlbiBkdXJjaCBnw7xsdGlnZSBXZXJ0ZSBkYXJnZXN0ZWxsdCB3ZXJkZW4uIE51bGwgaXN0IGVpbiBnw7xsdGlnZXIgV2VydC4gU3RhbmRhcmRtw6TDn2lnIHdlcmRlbiBiZWkgZGVyIEJlcmVjaG51bmcgZGllIGtvbWJpbmllcnRlIEF1c2RlaG51bmcgdm9uIFF1ZWxsZW4gdW5kIEJhcnJpZXJlbiBwbHVzIDIgWmVpbGVuIHVuZCBTcGFsdGVuIHZlcmFyYmVpdGV0LiBXZW5uIGRpZSBBbmFseXNlIG51ciBpbm5lcmhhbGIgZWluZXIgZmVzdGdlbGVndGVuIEVudGZlcm51bmcgdm9uIGRlbiBRdWVsbGVuIGJlbsO2dGlndCB3aXJkLCBrYW5uIGRlciBQYXJhbWV0ZXIgXFxcIk1heGltYWxlIEVudGZlcm51bmdcXFwiIHZlcndlbmRldCB3ZXJkZW4uIFxcXCJFdWtsaWRpc2NoZSBHZWdlbnJpY2h0dW5nXFxcIiB1bnRlcnN0w7x0enQgZWluZSBwbGFuYXJlIHVuZCBlaW5lIGdlb2TDpHRpc2NoZSBNZXRob2RlIGluIGRlciBCZXJlY2hudW5nLiBEaWUgQmVyZWNobnVuZ3NtZXRob2RlIFxcXCJQbGFuYXJcXFwiIGVyZm9sZ3QgYXVmIGVpbmVyIHByb2ppemllcnRlbiBmbGFjaGVuIEViZW5lIG1pdGhpbGZlIGVpbmVzIGthcnRlc2lzY2hlbiAyRC1Lb29yZGluYXRlbnN5c3RlbXMuIERpZSBCZXJlY2hudW5nc21ldGhvZGUgXFxcIkdlb2TDpHRpc2NoXFxcIiBlcmZvbGd0IGF1ZiBkZW0gRWxsaXBzb2lkLiBEYXMgYmVkZXV0ZXQsIGRhc3Mgc2ljaCBkaWUgRXJnZWJuaXNzZSB1bmFiaMOkbmdpZyB2b24gZGVyIEVpbmdhYmUtIG9kZXIgQXVzZ2FiZXByb2pla3Rpb24gbmljaHQgw6RuZGVybi48ZGl2Pjxici8+RGFzIEVyZ2VibmlzIGRlciBGdW5rdGlvbiBcXFwiRXVrbGlkaXNjaGUgR2VnZW5yaWNodHVuZ1xcXCIga2FubiBnZW1laW5zYW0gbWl0IGRlbSBFcmdlYm5pcyBkZXIgRnVua3Rpb24gXFxcIkV1a2xpZGlzY2hlIFJpY2h0dW5nXFxcIiB2ZXJ3ZW5kZXQgd2VyZGVuLCB1bSBkaWUga8O8cnplc3RlbiBSb3V0ZW4gdm9uIFBvc2l0aW9uZW4gaW0gVW50ZXJzdWNodW5nc2dlYmlldCB6dXLDvGNrIHp1ciBRdWVsbGUgenUgYmVzdGltbWVuLiBEaWUgRXJnZWJuaXNzZSBhdXMgXFxcIkV1a2xpZGlzY2hlIEdlZ2VucmljaHR1bmdcXFwiIHVuZCBcXFwiRXVrbGlkaXNjaGUgRW50ZmVybnVuZ1xcXCIgd2VyZGVuIGluIGRlciBGdW5rdGlvbiBcXFwiS29zdGVucGZhZFxcXCIgZ2VtZWluc2FtIG1pdCBaaWVsZW4gdmVyd2VuZGV0LCB1bSBkaWUga8O8cnplc3RlbiBSb3V0ZW4genUgZ2VuZXJpZXJlbi48L2Rpdj5cIixcblx0XHRleHBhbmROYW1lOiBcIkVyd2VpdGVyblwiLFxuXHRcdGV4cGFuZFNuaXA6IFwiRXJ3ZWl0ZXJ0IGF1c2dld8OkaGx0ZSBab25lbiBlaW5lcyBSYXN0ZXJzIHVtIGVpbmUgYW5nZWdlYmVuZSBaZWxsZW56YWhsLlwiLFxuXHRcdGV4cGFuZERlc2M6IFwiTWl0IGRlciBnbG9iYWxlbiBGdW5rdGlvbiBcXFwiRXJ3ZWl0ZXJuXFxcIiBrw7ZubmVuIFNpZSBSYXN0ZXIgZ2VuZXJhbGlzaWVyZW4gb2RlciB2ZXJlaW5mYWNoZW4sIGluZGVtIFNpZSBiZXN0aW1tdGUgWm9uZW4gdmVyZ3LDtsOfZXJuLiBEYXLDvGJlciBoaW5hdXMga8O2bm5lbiBTaWUgZGVuIEdyYWQgZGVyIEdlbmVyYWxpc2llcnVuZyBzdGV1ZXJuLjxkaXY+PGJyLz5EaWUgYXVzZ2V3w6RobHRlbiBab25lbiB3ZXJkZW4gdmVyZ3LDtsOfZXJ0LCBpbmRlbSBzaWUgYXVmIGFuZGVyZSBab25lbiBlcndlaXRlcnQgd2VyZGVuLiBLb256ZXB0aW9uZWxsIGdlc2VoZW4ga8O2bm5lbiBkaWUgYXVzZ2V3w6RobHRlbiBcXFwiWm9uZW53ZXJ0ZVxcXCIgYWxzIFZvcmRlcmdydW5kem9uZW4gYmV0cmFjaHRldCB3ZXJkZW4sIHfDpGhyZW5kIGRpZSBhbmRlcmVuIFdlcnRlIEhpbnRlcmdydW5kem9uZW4gYmxlaWJlbi4gRGllIFZvcmRlcmdydW5kem9uZW4ga8O2bm5lbiBhdWYgZGllIEhpbnRlcmdydW5kem9uZW4gZXJ3ZWl0ZXJ0IHdlcmRlbi48ZGl2Pjxici8+RGVyIEdyYWQgZGVyIEdlbmVyYWxpc2llcnVuZyBrYW5uIG1pdCBkZW0gUGFyYW1ldGVyIFxcXCJBbnphaGwgZGVyIFplbGxlblxcXCIgZ2VzdGV1ZXJ0IHdlcmRlbi4gU3RhbmRhcmRtw6TDn2lnIGxhdXRldCBkaWVzZXIgV2VydCAxLCBkLiBoLiBkaWUgYXVzZ2V3w6RobHRlbiBab25lbiB3ZXJkZW4gdW0gamV3ZWlscyBlaW5lIFplbGxlIGVyd2VpdGVydC4gVW0gZGVuIEdyYWQgZGVyIEdlbmVyYWxpc2llcnVuZyB6dSBlcmjDtmhlbiwga8O2bm5lbiBTaWUgZsO8ciBkaWVzZW4gUGFyYW1ldGVyIGVpbmVuIGdyw7bDn2VyZW4gV2VydCBlaW5nZWJlbi4gS29uemVwdGlvbmVsbCBrb21tdCBkaWVzIGRlbSBBdXNmw7xocmVuIGRlcyBXZXJremV1Z3MgbWl0IGVpbmVyIEjDpHVmaWdrZWl0IGdsZWljaCwgZGllIGRlciBhbmdlZ2ViZW5lbiBBbnphaGwgZW50c3ByaWNodCwgd29iZWkgZGllIEVyZ2Vibmlzc2UgZGVyIHZvcmhlcmlnZW4gQXVzZsO8aHJ1bmcgZGllIEVpbmdhYmUgZGVyIG7DpGNoc3RlbiBBdXNmw7xocnVuZyBzaW5kLjwvZGl2PlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNOYW1lOiBcIlRyZW5kIGdlbmVyaWVyZW5cIixcblx0XHR0cmVuZEFuYWx5c2lzU25pcDogXCJTY2jDpHR6dCBkZW4gVHJlbmQgZsO8ciBqZWRlcyBQaXhlbCBlbnRsYW5nIGVpbmVyIERpbWVuc2lvbiBmw7xyIGVpbmUgb2RlciBtZWhyZXJlIFZhcmlhYmxlbiBpbiBlaW5lbSBtdWx0aWRpbWVuc2lvbmFsZW4gUmFzdGVyLlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNEZXNjOiBcIjxkaXY+TWl0IGRpZXNlciBGdW5rdGlvbiBrw7ZubmVuIERhdGVuIGVudGxhbmcgZWluZXIgbGluZWFyZW4sIGhhcm1vbmlzY2hlbiBvZGVyIHBvbHlub21pc2NoZW4gVHJlbmRsaW5pZSBhbmdlcGFzc3Qgd2VyZGVuLiBEYXMgV2Vya3pldWcga2FubiBhdWNoIHp1ciBUcmVuZGVya2VubnVuZyBtaXR0ZWxzIE1hbm4tS2VuZGFsbC1UZXN0IG9kZXIgc2Fpc29uYWxlbSBLZW5kYWxsLVRlc3QgdmVyd2VuZGV0IHdlcmRlbi48L2Rpdj48YnI+PGRpdj5EYXMgbWl0IGRpZXNlciBGdW5rdGlvbiBnZW5lcmllcnRlIEF1c2dhYmUtVHJlbmQtUmFzdGVyIHdpcmQgYWxzIEVpbmdhYmUgZsO8ciBkaWUgRnVua3Rpb24gPHN0cm9uZz5NaXQgVHJlbmQgdm9yaGVyc2FnZW48L3N0cm9uZz4gdmVyd2VuZGV0LjwvZGl2Pjxicj48ZGl2Pk1pdCBkZW0gTWFubi1LZW5kYWxsLVRlc3QgdW5kIGRlbSBzYWlzb25hbGVuIEtlbmRhbGwtVGVzdCB3ZXJkZW4gZGllIERhdGVuIGF1ZiBlaW5lbiBtb25vdG9uZW4gVHJlbmQgaGluIHVudGVyc3VjaHQuIFNpZSBzaW5kIG5pY2h0cGFyYW1ldHJpc2NoLCBkLsKgaC4gZXMgd2lyZCBrZWluZSBzcGV6aWZpc2NoZSBWZXJ0ZWlsdW5nIGRlciBEYXRlbiBhbmdlbm9tbWVuLiBCZWltIE1hbm4tS2VuZGFsbC1UZXN0IHdlcmRlbiBzZXJpZWxsZSBLb3JyZWxhdGlvbiBvZGVyIHNhaXNvbmFsZSBFZmZla3RlIG5pY2h0IGJlcsO8Y2tzaWNodGlndC4gQmVpIFNhaXNvbmFsaXTDpHQgZGVyIERhdGVuIGlzdCBkZXIgc2Fpc29uYWxlIEtlbmRhbGwtVGVzdCBiZXNzZXIgZ2VlaWduZXQuPC9kaXY+PGJyPjxkaXY+V2VubiBkYXMgV2Vya3pldWcgenVyIER1cmNoZsO8aHJ1bmcgZGVzIE1hbm4tS2VuZGFsbC1UZXN0cyBvZGVyIGRlcyBzYWlzb25hbGVuIEtlbmRhbGwtVGVzdHMgdmVyd2VuZGV0IHdpcmQsIGlzdCBkaWUgQXVzZ2FiZSBlaW4gRsO8bmZiYW5kLVJhc3Rlci4gSGllcmJlaSBnaWx0OjwvZGl2Pjx1bD48bGk+QmFuZCAxID0gU2VuLVN0ZWlndW5nPC9saT48bGk+QmFuZCAyID0gcC1XZXJ0PC9saT48bGk+QmFuZCAzID0gTWFubi1LZW5kYWxsLVdlcnQgKFMpPC9saT48bGk+QmFuZCA0ID0gUy1WYXJpYW56PC9saT48bGk+QmFuZCA0ID0gUy1WYXJpYW56PC9saT48bGk+QmFuZCA1ID0gWi1XZXJ0PC9saT48L3VsPjxkaXY+QW5oYW5kIGRlciBBdXNnYWJlbiBkZXMgTWFubi1LZW5kYWxsLVRlc3RzIG9kZXIgZGVzIHNhaXNvbmFsZW4gS2VuZGFsbC1UZXN0cyBrYW5uIGVybWl0dGVsdCB3ZXJkZW4sIHdlbGNoZSBQaXhlbCBpbiBJaHJlciBtdWx0aWRpbWVuc2lvbmFsZW4gWmVpdHNlcmllIGVpbmVuIHN0YXRpc3Rpc2NoIHNpZ25pZmlrYW50ZW4gVHJlbmQgYXVmd2Vpc2VuLiBTaWUga8O2bm5lbiBkaWVzZSBJbmZvcm1hdGlvbmVuIGluIFZlcmJpbmR1bmcgbWl0IGRlciBsaW5lYXJlbiwgaGFybW9uaXNjaGVuIG9kZXIgcG9seW5vbWlzY2hlbiBUcmVuZGFuYWx5c2UgdmVyd2VuZGVuLCB1bSBzaWduaWZpa2FudGUgVHJlbmRzIGluIGRlciBaZWl0c2VyaWUgenUgZXh0cmFoaWVyZW4uIFNpZSBrw7ZubmVuIGVpbmUgTWFza2UgZ2VuZXJpZXJlbiwgZGllIFBpeGVsIG1pdCBzaWduaWZpa2FudGVuIHAtV2VydGVuIGVudGjDpGx0LCBkaWUgTWFza2UgYXVmIGRhcyBtdWx0aWRpbWVuc2lvbmFsZSBSYXN0ZXIgYW53ZW5kZW4gdW5kIGRpZXNlcyBtYXNraWVydGUgbXVsdGlkaW1lbnNpb25hbGUgUmFzdGVyIGFscyBFaW5nYWJlIGbDvHIgZGFzIFdlcmt6ZXVnIHZlcndlbmRlbiwgdW0gbGluZWFyZSwgaGFybW9uaXNjaGUgb2RlciBwb2x5bm9taXNjaGUgVHJlbmRhbmFseXNlbiBkdXJjaHp1ZsO8aHJlbi48L2Rpdj48YnI+PGRpdj5FcyBnaWJ0IGRyZWkgTcO2Z2xpY2hrZWl0ZW4gZGVyIEFucGFzc3VuZyBlaW5lcyBUcmVuZHMgYW4gZGllIFZhcmlhYmxlbndlcnRlIGVudGxhbmcgZWluZXIgRGltZW5zaW9uOiBsaW5lYXIsIHBvbHlub21pc2NoIHVuZCBoYXJtb25pc2NoLjwvZGl2Pjxicj48ZGl2PkluIGRlciBsaW5lYXJlbiBUcmVuZGFuYWx5c2UgYmVzdGVodCBkaWUgQXVzZ2FiZSBhdXMgZWluZW0gRHJlaWJhbmQtUmFzdGVyLCBmw7xyIGRhcyBGb2xnZW5kZXMgZ2lsdDo8L2Rpdj48dWw+PGxpPkJhbmQgMSA9IE5laWd1bmc8L2xpPjxsaT5CYW5kIDIgPSBTY2huaXR0cHVua3Q8L2xpPjxsaT5CYW5kIDMgPSBSTVMtRmVobGVyIChSb290IE1lYW4gU3F1YXJlLCBxdWFkcmF0aXNjaGVzIE1pdHRlbCksIGRlciBkZW4gRmVobGVyIHVtIGRpZSBhbSBiZXN0ZW4gcGFzc2VuZGUgTGluaWUgaGVydW0gZGFyc3RlbGx0PC9saT48L3VsPjxkaXY+SW4gZGVyIHBvbHlub21pc2NoZW4gVHJlbmRhbmFseXNlIGjDpG5ndCBkaWUgQW56YWhsIGRlciBCw6RuZGVyIGluIGRlciBBdXNnYWJlIHZvbiBkZXIgUG9seW5vbS1PcmRudW5nIGFiLiBCZWkgZGVyIFBvbHlub21hbnBhc3N1bmcgendlaXRlciBPcmRudW5nIGVudHN0ZWh0IGVpbiBWaWVyYmFuZC1SYXN0ZXIuIEhpZXJiZWkgZ2lsdDo8L2Rpdj48dWw+PGxpPkJhbmQgMSA9IFBvbHlub21pYWxfMjwvbGk+PGxpPkJhbmQgMiA9IFBvbHlub21pYWxfMTwvbGk+PGxpPkJhbmQgMyA9IFBvbHlub21pYWxfMDwvbGk+PGxpPkJhbmQgNCA9IFJNU0U8L2xpPjwvdWw+PGRpdj5CZWkgZGVyIFBvbHlub21hbnBhc3N1bmcgZHJpdHRlciBPcmRudW5nIGVudHN0ZWh0IGVpbiBGw7xuZmJhbmQtUmFzdGVyLiBIaWVyYmVpIGdpbHQ6PC9kaXY+PHVsPjxsaT5CYW5kIDEgPSBQb2x5bm9taWFsXzM8L2xpPjxsaT5CYW5kIDIgPSBQb2x5bm9taWFsXzI8L2xpPjxsaT5CYW5kIDMgPSBQb2x5bm9taWFsXzE8L2xpPjxsaT5CYW5kIDQgPSBQb2x5bm9taWFsXzA8L2xpPjxsaT5CYW5kIDUgPSBSTVNFPC9saT48L3VsPjxkaXY+SW4gZGVyIGhhcm1vbmlzY2hlbiBUcmVuZGFuYWx5c2UgaMOkbmd0IGRpZSBBbnphaGwgZGVyIELDpG5kZXIgaW4gZGVyIEF1c2dhYmUgdm9uIGRlciBoYXJtb25pc2NoZW4gRnJlcXVlbnogYWIuIEJlaSBkZXIgRnJlcXVlbnogMSBpc3QgZGllIEF1c2dhYmUgZWluIEbDvG5mYmFuZC1SYXN0ZXIuIEhpZXJiZWkgZ2lsdDo8L2Rpdj48dWw+PGxpPkJhbmQgMSA9IE5laWd1bmc8L2xpPjxsaT5CYW5kIDIgPSBTY2huaXR0cHVua3Q8L2xpPjxsaT5CYW5kIDMgPSBIYXJtb25pY19zaW4xPC9saT48bGk+QmFuZCA0ID0gSGFybW9uaWNfY29zMTwvbGk+PGxpPkJhbmQgNSA9IFJNU0U8L2xpPjwvdWw+PGRpdj5CZWkgZGVyIEZyZXF1ZW56IDIgaXN0IGRpZSBBdXNnYWJlIGVpbiBTaWViZW5iYW5kLVJhc3Rlci4gSGllcmJlaSBnaWx0OjwvZGl2Pjx1bD48bGk+QmFuZCAxID0gTmVpZ3VuZzwvbGk+PGxpPkJhbmQgMiA9IFNjaG5pdHRwdW5rdDwvbGk+PGxpPkJhbmQgMyA9IEhhcm1vbmljX3NpbjE8L2xpPjxsaT5CYW5kIDQgPSBIYXJtb25pY19jb3MxPC9saT48bGk+QmFuZCA1ID0gSGFybW9uaWNfc2luMjwvbGk+PGxpPkJhbmQgNiA9IEhhcm1vbmljX2NvczI8L2xpPjxsaT5CYW5kIDcgPSBSTVNFPC9saT48L3VsPjxkaXY+TWl0IGRlbSBQYXJhbWV0ZXIgPHN0cm9uZz5aeWtsdXNsw6RuZ2U8L3N0cm9uZz4gZsO8ciBkaWUgaGFybW9uaXNjaGUgVHJlbmRhbmFseXNlIHdpcmQgZGllIEFuemFobCB1bmQgTMOkbmdlIGRlciBaeWtsZW4gYW5nZWdlYmVuLCBkaWUgU2llIGbDvHIgZGllIERhdGVuIGluIGVpbmVtIFRhZyBvZGVyIEphaHIgZXJ3YXJ0ZW4uIFdlbm4gU2llIGJlaXNwaWVsc3dlaXNlIGbDvHIgSWhyZSBEYXRlbiB6d2VpIFZhcmlhdGlvbnN6eWtsZW4gcHJvIEphaHIgZXJ3YXJ0ZW4sIGJldHLDpGd0IGRpZSBaeWtsdXNsw6RuZ2UgMTgyLDXCoFRhZ2UgYnp3LiAwLDXCoEphaHJlLiBXZW5uIGFsbGUgZHJlaSBTdHVuZGVuIGVpbmUgRXJmYXNzdW5nIHZvbiBUZW1wZXJhdHVyZGF0ZW4gZXJmb2xndCB1bmQgcHJvIFRhZyBlaW4gVmFyaWF0aW9uc3p5a2x1cyB2b3JsaWVndCwgYmV0csOkZ3QgZGllIFp5a2x1c2zDpG5nZSBlaW5lbiBUYWcuPC9kaXY+PGJyPjxkaXY+TWl0IGRlbSBQYXJhbWV0ZXIgPHN0cm9uZz5Iw6R1Zmlna2VpdDwvc3Ryb25nPiBmw7xyIGRpZSBoYXJtb25pc2NoZSBUcmVuZGFuYWx5c2Ugd2lyZCBkYXMgaGFybW9uaXNjaGUgTW9kZWxsIGJlc2NocmllYmVuLCBkYXMgYW4gZGllIERhdGVuIGFuZ2VwYXNzdCB3aXJkLiBXaXJkIGRpZSBIw6R1Zmlna2VpdCBhdWYgMSBmZXN0Z2VsZWd0LCB3aXJkIGVpbmUgS29tYmluYXRpb24gYXVzIGxpbmVhcmVyIEt1cnZlIHVuZCBoYXJtb25pc2NoZXIgS3VydmUgZGVyIGVyc3RlbiBPcmRudW5nIGbDvHIgZGllIEFucGFzc3VuZyBkZXMgTW9kZWxscyB2ZXJ3ZW5kZXQuIEJldHLDpGd0IGRpZSBIw6R1Zmlna2VpdCAyLCB3aXJkIGVpbmUgS29tYmluYXRpb24gYXVzIGxpbmVhcmVyIEt1cnZlLCBoYXJtb25pc2NoZXIgS3VydmUgZGVyIGVyc3RlbiBPcmRudW5nIHVuZCBoYXJtb25pc2NoZXIgS3VydmUgZGVyIHp3ZWl0ZW4gT3JkbnVuZyBmw7xyIGRpZSBBbnBhc3N1bmcgZGVzIE1vZGVsbHMgdmVyd2VuZGV0LiBCZXRyw6RndCBkaWUgSMOkdWZpZ2tlaXQgMywgd2lyZCB6dXPDpHR6bGljaCBlaW5lIGhhcm1vbmlzY2hlIEt1cnZlIGRlciBkcml0dGVuIE9yZG51bmcgZsO8ciBkaWUgTW9kZWxsaWVydW5nIGRlciBEYXRlbiB2ZXJ3ZW5kZXQgdW5kIHNvIHdlaXRlci48L2Rpdj48YnI+PGRpdj5Nb2RlbGxzdGF0aXN0aWtlbiB6dXIgUXVhbGl0w6R0IGRlciDDnGJlcmVpbnN0aW1tdW5nIGvDtm5uZW4gYWxzIG9wdGlvbmFsZSBBdXNnYWJlIGdlbmVyaWVydCB3ZXJkZW4uIERlciBSTVMtRmVobGVyIChSb290IE1lYW4gU3F1YXJlLCBxdWFkcmF0aXNjaGVzIE1pdHRlbCksIFItU3F1YXJlZCB1bmQgZGVyIFRyZW5kIGbDvHIgZGVuIHAtV2VydCBkZXIgTmVpZ3VuZyBrw7ZubmVuIGJlcmVjaG5ldCB1bmQgc3ltYm9saXNpZXJ0IHdlcmRlbi4gU3ltYm9saXNpZXJlbiBTaWUgZGVuIEF1c2dhYmUtVHJlbmQtUmFzdGVyLUxheWVyIG1pdCBkZXIgU3ltYm9saXNpZXJ1bmcgPHN0cm9uZz5SR0I8L3N0cm9uZz4sIHVuZCBnZWJlbiBTaWUgZGllIFN0YXRpc3Rpa2VuIGFscyByb3RlLCBncsO8bmUgdW5kIGJsYXVlIELDpG5kZXIgYW4uPC9kaXY+PGJyPlwiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdOYW1lOiBcIkxpbmVhcmUgc3Bla3RyYWxlIEVudG1pc2NodW5nXCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ1NuaXA6IFwiRsO8aHJ0IGVpbmUgU3VicGl4ZWwtS2xhc3NpZml6aWVydW5nIGR1cmNoIHVuZCBiZXJlY2huZXQgZGVuIEFudGVpbCB2ZXJzY2hpZWRlbmVyIExhbmRiZWRlY2t1bmdzdHlwZW4gZsO8ciBlaW56ZWxuZSBQaXhlbC5cIixcblx0XHRzcGVjdHJhbFVubWl4aW5nRGVzYzogXCJEaWUgRnVua3Rpb24gXFxcIkxpbmVhcmUgc3Bla3RyYWxlIEVudG1pc2NodW5nXFxcIiBiZXJlY2huZXQgZGVuIEFudGVpbCBlaW56ZWxuZXIgUGl4ZWwsIGRpZSBtZWhyZXJlIEFydGVuIHZvbiBMYW5kYmVkZWNrdW5nZW4gZW50aGFsdGVuLiBFcyB3aXJkIGVpbiBNdWx0aWJhbmQtUmFzdGVyIGVyemV1Z3QsIGluIGRlbSBqZWRlcyBCYW5kIGRlbSBBbnRlaWwgZGVyIGVpbnplbG5lbiBMYW5kYmVkZWNrdW5nc2tsYXNzZW4gZW50c3ByaWNodC4gQmVpc3BpZWw6IFNpZSBrw7ZubmVuIG1pdCBkaWVzZW0gVG9vbCBpbiBlaW5lbSBNdWx0aXNwZWt0cmFsYmlsZCBMYW5kYmVkZWNrdW5nZW4ga2xhc3NpZml6aWVyZW4gdW5kIFZlZ2V0YXRpb24gbWl0IHVuZCBvaG5lIFBob3Rvc3ludGhlc2Vha3Rpdml0w6R0LCBuYWNrdGUgRXJkZSB1bmQgdG90ZSBQZmxhbnplbiBlcm1pdHRlbG4uPGRpdj48YnIvPkRpZSBSZWloZW5mb2xnZSBkZXMgQXVzZ2FiZS1NdWx0aWJhbmQtUmFzdGVycyBlbnRzcHJpY2h0IGRlciBSZWloZW5mb2xnZSBkZXMgRWluZ2FiZS1TcGVrdHJhbHByb2ZpbHMuIERpZSBBbnphaGwgZGVyIEtsYXNzZW4gZGFyZiBuaWNodCBncsO2w59lciBzZWluIGFscyBkaWUgQW56YWhsIGFuIELDpG5kZXJuIGltIEVpbmdhYmUtUmFzdGVyLiBBdXMgZWluZW0gQmVpc3BpZWw6IEVpbmVtIEFjaHRiYW5kLVJhc3RlciBrw7ZubmVuIFNpZSBJbmZvcm1hdGlvbmVuIHp1IG1heGltYWwgYWNodCBLbGFzc2VuIGVudG5laG1lbi48L2Rpdj5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsRmlsdGVyTmFtZTogXCJNdWx0aWRpbWVuc2lvbmFsZXIgRmlsdGVyXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uTmFtZTogXCJSYXN0ZXIgbmFjaCBEaW1lbnNpb24gaW50ZXJwb2xpZXJlblwiLFxuXHRcdGludGVycG9sYXRlUmFzdGVyQnlEaW1lbnNpb25GdW5jdGlvblNuaXA6IFwiSW50ZXJwb2xpZXJ0IGVpbiBtdWx0aWRpbWVuc2lvbmFsZXMgUmFzdGVyIG1pdCBhbmdlZ2ViZW5lbiBEaW1lbnNpb25zd2VydGVuIG1pdGhpbGZlIHZvbiBiZW5hY2hiYXJ0ZW4gQXVzc2Nobml0dGVuLlwiLFxuXHRcdGludGVycG9sYXRlUmFzdGVyQnlEaW1lbnNpb25GdW5jdGlvbkRlc2M6IFwiPHA+TWl0IGRpZXNlciBGdW5rdGlvbiBrw7ZubmVuIFNpZSBQaXhlbHdlcnRlIGbDvHIgZWluZW4gbmljaHQgZGVmaW5pZXJ0ZW4gRGltZW5zaW9uc2F1c3NjaG5pdHQgaW4gZWluZW0gbXVsdGlkaW1lbnNpb25hbGVuIFJhc3RlciBzY2jDpHR6ZW4uIFdlbm4gU2llIHp1bSBCZWlzcGllbCBlaW4gRGF0YXNldCBoYWJlbiwgZGFzIGRpZSBNZWVyZXN0ZW1wZXJhdHVyIGFuIGRlciBPYmVyZmzDpGNoZSBzb3dpZSAxMDDCoE1ldGVyIHVudGVyIGRlbSBNZWVyZXNzcGllZ2VsIGVudGjDpGx0LCB1bmQgU2llIGRpZSBUZW1wZXJhdHVyIDUwwqBNZXRlciB1bnRlciBkZW0gTWVlcmVzc3BpZWdlbCBzY2jDpHR6ZW4gbcO2Y2h0ZW4sIGvDtm5uZW4gU2llIG1pdCBkaWVzZXIgRnVua3Rpb24gZWluZSBTY2jDpHR6dW5nIGbDvHIgZGllc2UgVGllZmUgZW50aGFsdGVuLiBWZXJ3ZW5kZW4gU2llIGRhenUgZGllIERpbWVuc2lvbnNkZWZpbml0aW9uIFxcXCJOYWNoIFdlcnRlblxcXCIuPC9wPjxwPlNpZSBrw7ZubmVuIGF1Y2ggZWluIG1vbmF0bGljaGVzIERhdGFzZXQgYXVmIGVpbiB0w6RnbGljaGVzIERhdGFzZXQgcmVkdXppZXJlbiwgaW5kZW0gU2llIGRpZSBEaW1lbnNpb25zZGVmaW5pdGlvbiBcXFwiTmFjaCBJbnRlcnZhbGxcXFwiIHZlcndlbmRlbiB1bmQgZsO8ciBkZW4gUGFyYW1ldGVyIFxcXCJTY2hyaXR0XFxcIiBkZW4gV2VydCBcXFwiMVxcXCIgdW5kIGbDvHIgZGVuIFBhcmFtZXRlciBcXFwiRWluaGVpdFxcXCIgZGVuIFdlcnQgXFxcIlRhZ2VcXFwiIGFuZ2ViZW4uPC9wPjxwPk1pdCBkZXIgRGltZW5zaW9uc2RlZmluaXRpb24gXFxcIk5hY2ggWmllbC1SYXN0ZXJcXFwiIGvDtm5uZW4gU2llIGRlbiBXZXJ0IGbDvHIgZGFzIFppZWwtUmFzdGVyIHNjaMOkdHplbi48L3A+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlclNuaXA6IFwiRXJzdGVsbHQgZWluZW4gUmFzdGVyLUxheWVyIGF1cyBlaW5lbSBtdWx0aWRpbWVuc2lvbmFsZW4gUmFzdGVyLURhdGFzZXQgb2RlciBlaW5lbSBtdWx0aWRpbWVuc2lvbmFsZW4gUmFzdGVyLUxheWVyLCBpbmRlbSBEYXRlbiBlbnRsYW5nIGRlZmluaWVydGVyIFZhcmlhYmxlbiB1bmQgRGltZW5zaW9uZW4gYXVmZ2V0ZWlsdCB3ZXJkZW4uXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlckRlc2M6IFwiRGFzIFdlcmt6ZXVnIFxcXCJNdWx0aWRpbWVuc2lvbmFsZXIgRmlsdGVyXFxcIiBlcnN0ZWxsdCBlaW5lbiBtdWx0aWRpbWVuc2lvbmFsZW4gUmFzdGVyLUxheWVyLCBpbmRlbSBlcyBlaW5lIFRlaWxtZW5nZSB2b24gVmFyaWFibGVuIGF1cyBlaW5lbSBtdWx0aWRpbWVuc2lvbmFsZW4gUmFzdGVyIGhlcmF1c2ZpbHRlcnQgdW5kIGV4dHJhaGllcnQuIEJlaXNwaWVsOiBTaWUgdmVyZsO8Z2VuIMO8YmVyIGVpbiBtdWx0aWRpbWVuc2lvbmFsZXMgRGF0YXNldCwgZGFzIGRpZSBtb25hdGxpY2hlbiBOaWVkZXJzY2hsYWdzZGF0ZW4gdm9uIDMwIEphaHJlbiBlbnRow6RsdC4gU2llIG3DtmNodGVuIERhdGVuIGbDvHIgZGVuIEphbnVhciBkZXIgZWluemVsbmVuIEphaHJlIGV4dHJhaGllcmVuLCB1bSB6dSBlcm1pdHRlbG4sIHdpZSBzaWNoIGRlciBOaWVkZXJzY2hsYWcgaW4gZGllc2VtIE1vbmF0IGltIExhdWYgZGVyIEphaHJlIHZlcsOkbmRlcnQgaGF0LjxkaXY+PGJyLz5WZXJ3ZW5kZW4gU2llIGRlbiBQYXJhbWV0ZXIgXFxcIkRpbWVuc2lvbnNkZWZpbml0aW9uXFxcIiwgdW0gRGltZW5zaW9uZW4gw7xiZXIgZWluIEludGVydmFsbCwgZWluZW4gV2VydCBvZGVyIGVpbmVuIFdlcnRlYmVyZWljaCBhdWZ6dXRlaWxlbi4gQmVpc3BpZWw6IElobmVuIHN0ZWhlbiBmw7xyIDEwIEphaHJlIERhdGVuIHp1bSBTYWx6Z2VoYWx0IGRlcyBNZWVyd2Fzc2VycywgZGllIG1vbmF0bGljaCBhbGxlIDIgTWV0ZXIgYmlzIHp1IGVpbmVyIFRpZWZlIHZvbiA1MDAgTWV0ZXJuIGVyZmFzc3Qgd3VyZGVuLCB6dXIgVmVyZsO8Z3VuZy4gSW4gZGllc2VtIEZhbGwga8O2bm5lbiBTaWUgZGllIHZlcnNjaGllZGVuZW4gT3B0aW9uZW4genVyIERpbWVuc2lvbnNkZWZpbml0aW9uIGbDvHIgZGllIGZvbGdlbmRlbiBTemVuYXJpZW4gdmVyd2VuZGVuLiBTemVuYXJpbzE6IEV4dHJhaGllcmVuIGRlciBEYXRlbiB6dW0gU2FsemdlaGFsdCBmw7xyIGRlbiBNb25hdCBKYW51YXIgw7xiZXIgZGVuIFplaXRyYXVtIHZvbiAxMCBKYWhyZW4uIFfDpGhsZW4gU2llIFxcXCJEdXJjaCBXZXJ0ZVxcXCIgYXVzLiBMZWdlbiBTaWUgZsO8ciBcXFwiRGltZW5zaW9uXFxcIiBkZW4gV2VydCBcXFwiU3RkVGltZVxcXCIgdW5kIGbDvHIgXFxcIldlcnRlXFxcIiBkaWUgT3B0aW9uIFxcXCJKYW51YXJcXFwiIGZlc3QuIFN6ZW5hcmlvIDI6IEF1ZnRlaWxlbiBkZXIgRGF0ZW4genVtIFNhbHpnZWhhbHQgZsO8ciBkZW4gVGllZmVuYmVyZWljaCAwIGJpcyAxNTAgTWV0ZXIuIFfDpGhsZW4gU2llIFxcXCJOYWNoIEJlcmVpY2hlblxcXCIgYXVzLiBMZWdlbiBTaWUgZsO8ciBcXFwiRGltZW5zaW9uXFxcIiBkZW4gV2VydCBcXFwiU3RkWlxcXCIsIGbDvHIgXFxcIk1pbmltYWx3ZXJ0XFxcIiBkZW4gV2VydCBcXFwiLTE1MFxcXCIgdW5kIGbDvHIgXFxcIk1heGltYWx3ZXJ0XFxcIiBkZW4gV2VydCBcXFwiMFxcXCIgZmVzdC4gU3plbmFyaW8gMzogRXh0cmFoaWVyZW4gZGVyIERhdGVuIHp1bSBTYWx6Z2VoYWx0IGbDvHIgZGllIGVyc3RlbiAxMCBUYWdlIGRlcyBNb25hdHMgSmFudWFyIMO8YmVyIGVpbmVuIFplaXRyYXVtIHZvbiAxMCBKYWhyZW4uIFfDpGhsZW4gU2llIFxcXCJOYWNoIEl0ZXJhdGlvblxcXCIgYXVzLiBMZWdlbiBTaWUgZsO8ciBcXFwiRGltZW5zaW9uXFxcIiBkZW4gV2VydCBcXFwiU3RkVGltZVxcXCIsIGbDvHIgXFxcIkJlZ2lubiBkZXIgZXJzdGVuIEl0ZXJhdGlvblxcXCIgdW5kIFxcXCJFbmRlIGRlciBlcnN0ZW4gSXRlcmF0aW9uXFxcIiBkZW4gZW50c3ByZWNoZW5kZW4gQmVnaW5uIHVuZCBkYXMgRW5kZSBkZXMgSXRlcmF0aW9uc3plaXRyYXVtcyB1bmQgZsO8ciBcXFwiU2Nocml0dFxcXCIgZGVuIFdlcnQgXFxcIjFcXFwiIGZlc3QsIHVuZCBnZWJlbiBTaWUgdW50ZXIgXFxcIkVpbmhlaXRcXFwiIGRpZSBPcHRpb24gXFxcIkphaHJlXFxcIiBhbi48L2Rpdj5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyTmFtZTogXCJNdWx0aWRpbWVuc2lvbmFsZXMgUmFzdGVyXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlclNuaXA6IFwiRsO8Z3QgbXVsdGlkaW1lbnNpb25hbGUgRGF0ZW4gYWxzIG11bHRpZGltZW5zaW9uYWxlbiBSYXN0ZXItTGF5ZXIgenUgZWluZXIgS2FydGUgaGluenUuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlckRlc2M6IFwiRGllIEZ1bmt0aW9uIFxcXCJNdWx0aWRpbWVuc2lvbmFsZXMgUmFzdGVyXFxcIiBmw7xndCBtdWx0aWRpbWVuc2lvbmFsZSBEYXRlbiBhbHMgbXVsdGlkaW1lbnNpb25hbGVuIFJhc3Rlci1MYXllciB6dSBlaW5lciBLYXJ0ZSBoaW56dS4gRGllc2UgRnVua3Rpb24gaXN0IGhpbGZyZWljaCwgd2VubiBSYXN0ZXItQW5hbHlzZS1Xb3JrZmxvd3MgbWl0aGlsZmUgZWluZXIgRnVua3Rpb25za2V0dGUgZHVyY2hnZWbDvGhydCB3ZXJkZW4uPGRpdj48YnIvPkRpZSB1bnRlcnN0w7x0enRlbiBtdWx0aWRpbWVuc2lvbmFsZW4gUmFzdGVyLURhdGFzZXRzIHNpbmQgbmV0Q0RGLCBHUklCLCBIREYgdW5kIEVzcmkgQ1JGLiBNdWx0aWRpbWVuc2lvbmFsZSBNb3NhaWstRGF0YXNldHMgd2VyZGVuIGF1Y2ggdW50ZXJzdMO8dHp0LjwvZGl2PlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJOYW1lOiBcIk9wdGltYWxlciBQZmFkIGFscyBSYXN0ZXJcIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyU25pcDogXCJCZXJlY2huZXQgZGVuIGtvc3RlbmfDvG5zdGlnc3RlbiBQZmFkIHZvbiBlaW5lciBRdWVsbGUgenUgZWluZW0gWmllbC5cIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyRGVzYzogXCJNaXQgZGllc2VyIGdsb2JhbGVuIEZ1bmt0aW9uIHdpcmQgZWluIEF1c2dhYmUtUmFzdGVyIGVyemV1Z3QsIGRhcyBkZW4gb2RlciBkaWUgb3B0aW1hbGVuIFBmYWRlIHZvbiBhdXNnZXfDpGhsdGVuIFBvc2l0aW9uZW4genVyIGpld2VpbHMgbsOkY2hzdGdlbGVnZW5lbiBRdWVsbGVuemVsbGUgYXVmemVpY2huZXQsIGRpZSBpbm5lcmhhbGIgZGVyIGFra3VtdWxhdGl2ZW4gS29zdGVub2JlcmZsw6RjaGUgZGVmaW5pZXJ0IHd1cmRlbiAoaGluc2ljaHRsaWNoIGRlciBLb3N0ZW5lbnRmZXJudW5nKS48ZGl2Pjxici8+SW0gQWxsZ2VtZWluZW4gbXVzcyBtaW5kZXN0ZW5zIGVpbmUgRnVua3Rpb24gZsO8ciBnZXdpY2h0ZXRlIEtvc3RlbiAoRW50ZmVybnVuZ3Nha2t1bXVsYXRpb24gb2RlciBFbnRmZXJudW5nc2FsbG9rYXRpb24pIHZvciBkZXIgQXVzZsO8aHJ1bmcgZGVyIEZ1bmt0aW9uIFxcXCJPcHRpbWFsZXIgUGZhZCBhbHMgUmFzdGVyXFxcIiBhdXNnZWbDvGhydCB3ZXJkZW4sIHVtIGRhcyBFaW5nYWJlLUVudGZlcm51bmdzYWtrdW11bGF0aW9ucy0gdW5kIEdlZ2VucmljaHR1bmdzLVJhc3RlciB6dSBlcnN0ZWxsZW4uIERpZXMgc2luZCBlcmZvcmRlcmxpY2hlIEVpbmdhYmUtUmFzdGVyLUxheWVyIGbDvHIgZGllIEZ1bmt0aW9uIFxcXCJPcHRpbWFsZXIgUGZhZFxcXCIuIERpZSBXZXJ0ZSBmw7xyIGRlbiBvcHRpbWFsZW4gQXVzZ2FiZXBmYWQgc3RlbGxlbiBkaWUgQW56YWhsIGRlciBQZmFkZSBhbiBlaW5lciBnZWdlYmVuZW4gUG9zaXRpb24gZGFyLiBIw6R1ZmlnIGZvbGdlbiBkaWUgUGZhZGUgZGVyc2VsYmVuIFJvdXRlIGFiIGVpbmVyIFF1ZWxsZSB1bmQgdmVyendlaWdlbiBzaWNoIGRhbm4genUgdW50ZXJzY2hpZWRsaWNoZW4gWmllbGVuLiBCZWlzcGllbHN3ZWlzZSBiZWRldXRldCBkZXIgV2VydCAxLCBkYXNzIGFuIGVpbmVyIGdlZ2ViZW5lbiBQb3NpdGlvbiBudXIgZWluIG9wdGltYWxlciBQZmFkIHZvcmhhbmRlbiBpc3QsIHVuZCBkZXIgV2VydCA1IGJlZGV1dGV0LCBkYXNzIGFuIGRpZXNlciBQb3NpdGlvbiBmw7xuZiBvcHRpbWFsZSBQZmFkZSB2b3JoYW5kZW4gc2luZCwgZGllIGR1cmNoIGRpZXNlIFplbGxlIGltIFVudGVyc3VjaHVuZ3NnZWJpZXQgdmVybGF1ZmVuLjxkaXY+PGJyLz5CZWkgZGVuIEVpbmdhYmV6aWVsZGF0ZW4gbXVzcyBlcyBzaWNoIHVtIGVpbmVuIFJhc3Rlci1MYXllciBoYW5kZWxuLiBEaWUgTWVuZ2UgZGVyIFppZWx6ZWxsZW4gYmVzdGVodCBhdXMgYWxsZW4gWmVsbGVuIGltIEVpbmdhYmUtUmFzdGVyLCBkaWUgw7xiZXIgZ8O8bHRpZ2UgV2VydGUgdmVyZsO8Z2VuLiBaZWxsZW4gbWl0IE5vRGF0YS1XZXJ0ZW4gc2luZCBuaWNodCBpbiBkZXIgTWVuZ2UgZW50aGFsdGVuLiBEZXIgV2VydCAwIHdpcmQgYWxzIGVpbiByZWNodG3DpMOfaWdlcyBaaWVsIGJldHJhY2h0ZXQuIEVpbiBaaWVsLVJhc3RlciBrYW5uIG1pdCBkZW4gRXh0cmFrdGlvbnN3ZXJremV1Z2VuIGVyc3RlbGx0IHdlcmRlbi4gTcO2Z2xpY2hlcndlaXNlIHZvcmhhbmRlbmUgWmllbC0gb2RlciBRdWVsbC1GZWF0dXJlcyBrw7ZubmVuIG1pdCBkZXIgRnVua3Rpb24gXFxcIkZlYXR1cmVzIHJhc3Rlcm5cXFwiIGluIFJhc3RlciBrb252ZXJ0aWVydCB3ZXJkZW4uIFZlcndlbmRlbiBTaWUgYWxzIFJhc3Rlci1FaW5nYWJlIGbDvHIgZGllIEZ1bmt0aW9uIHp1ciBSYXN0ZXJ1bmcgZGFzIEVudGZlcm51bmdzYWtrdW11bGF0aW9ucy0gb2RlciBHZWdlbnJpY2h0dW5ncy1SYXN0ZXIuIERhZHVyY2ggd2lyZCBzaWNoZXJnZXN0ZWxsdCwgZGFzcyBkYXMgRmVhdHVyZSBtaXQgZGVyc2VsYmVuIFplbGxlbmdyw7bDn2UsIGRlcnNlbGJlbiBBdXNkZWhudW5nIHVuZCBkZW1zZWxiZW4gUmF1bWJlenVnIHdpZSBkaWUgYW5kZXJlbiBSYXN0ZXIsIGRpZSBhbHMgRWluZ2FiZSBmw7xyIGRpZSBGdW5rdGlvbiBcXFwiT3B0aW1hbGVyIFBmYWQgYWxzIFJhc3RlclxcXCIgZGllbmVuLCBnZXJhc3RlcnQgd2lyZC4gRGllIEZ1bmt0aW9uIFxcXCJPcHRpbWFsZXIgUGZhZCBhbHMgUmFzdGVyXFxcIiBrYW5uIGF1Y2ggdmVyd2VuZGV0IHdlcmRlbiwgdW0gZGVuIFBmYWQgZGVzIGdlcmluZ3N0ZW4gV2lkZXJzdGFuZHMgZW50bGFuZyBlaW5lcyBkaWdpdGFsZW4gSMO2aGVubW9kZWxscyAoREVNKSBhYnp1bGVpdGVuLiBWZXJ3ZW5kZW4gU2llIGluIGRpZXNlbSBGYWxsIGRhcyBERU0gZsO8ciBkYXMgRWluZ2FiZS1FbnRmZXJudW5nc2Fra3VtdWxhdGlvbnMtLVJhc3RlciB1bmQgZGllIEF1c2dhYmUgYXVzIGRlciBGdW5rdGlvbiBcXFwiRmxpZcOfcmljaHR1bmdcXFwiIGbDvHIgZGFzIEdlZ2VucmljaHR1bmdzLVJhc3Rlci48L2Rpdj5cIixcblx0XHR0cmVuZE5hbWU6IFwiTWl0IFRyZW5kIHZvcmhlcnNhZ2VuXCIsXG5cdFx0dHJlbmRTbmlwOiBcIkJlcmVjaG5ldCBlaW5lbiBwcm9nbm9zdGl6aWVydGVuIG11bHRpZGltZW5zaW9uYWxlbiBSYXN0ZXItTGF5ZXIgbWl0aGlsZmUgZGVzIEF1c2dhYmUtVHJlbmQtUmFzdGVycyBhdXMgZGVyIEZ1bmt0aW9uIFxcXCJUcmVuZCBnZW5lcmllcmVuXFxcIiBvZGVyIGF1cyBkZW0gR2VvdmVyYXJiZWl0dW5nc3dlcmt6ZXVnIFxcXCJUcmVuZC1SYXN0ZXIgZ2VuZXJpZXJlblxcXCIuXCIsXG5cdFx0dHJlbmREZXNjOiBcIkRpZSBGdW5rdGlvbiBcXFwiTWl0IFRyZW5kIHZvcmhlcnNhZ2VuXFxcIiBiZXJlY2huZXQgZWluZW4gcHJvZ25vc3RpemllcnRlbiBtdWx0aWRpbWVuc2lvbmFsZW4gUmFzdGVyLUxheWVyIG1pdGhpbGZlIGRlcyBBdXNnYWJlLVRyZW5kLVJhc3RlcnMgYXVzIGRlciBGdW5rdGlvbiBcXFwiVHJlbmQgZ2VuZXJpZXJlblxcXCIgb2RlciBhdXMgZGVtIEdlb3ZlcmFyYmVpdHVuZ3N3ZXJremV1ZyBcXFwiVHJlbmQtUmFzdGVyIGdlbmVyaWVyZW5cXFwiLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25OYW1lOiBcIlJhc3Rlci1TYW1tbHVuZyB2ZXJhcmJlaXRlblwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25TbmlwOiBcIlZlcmFyYmVpdGV0IGplZGVuIEF1c3NjaG5pdHQgaW4gZWluZW0gbXVsdGlkaW1lbnNpb25hbGVuIFJhc3RlciBvZGVyIGplZGVzIEVsZW1lbnQgaW4gZWluZW0gTW9zYWlrLVJhc3Rlci4gTWl0IGRpZXNlciBGdW5rdGlvbiBrw7ZubmVuIGF1Y2ggbWVocmVyZSBBdXNzY2huaXR0ZSB6dSBlaW5lbSBlaW56ZWxuZW4gYWdncmVnaWVydCB3ZXJkZW4uXCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvbkRlc2M6IFwiRGllIEZ1bmt0aW9uIFxcXCJSYXN0ZXItU2FtbWx1bmcgdmVyYXJiZWl0ZW5cXFwiIHZlcmFyYmVpdGV0IGplZGVuIEF1c3NjaG5pdHQgaW4gZWluZW0gbXVsdGlkaW1lbnNpb25hbGVuIFJhc3RlciBvZGVyIGplZGVzIEVsZW1lbnQgaW4gZWluZW0gTW9zYWlrLVJhc3Rlci4gTWl0IGRpZXNlciBGdW5rdGlvbiBrw7ZubmVuIGF1Y2ggbWVocmVyZSBBdXNzY2huaXR0ZSB6dSBlaW5lbSBlaW56ZWxuZW4gYWdncmVnaWVydCB3ZXJkZW4uPGRpdj48YnIvPkRpZXNlIEZ1bmt0aW9uIHZlcmFyYmVpdGV0IGVpbnplbG5lIEF1c3NjaG5pdHRlIGluIG11bHRpZGltZW5zaW9uYWxlbiBSYXN0ZXJuIG9kZXIgTW9zYWlrLVJhc3Rlcm4gbWl0aGlsZmUgZWluZXIgUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2UuIERpZXNlIEZ1bmt0aW9uIHVudGVyc3TDvHR6dCBkaWUgZm9sZ2VuZGVuIE9wdGlvbmVuOiAxLiBBbmdlYmVuIGVpbmVyIFJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlIGbDvHIgZGllIFxcXCJFbGVtZW50ZnVua3Rpb25cXFwiLiBTaWUgaGFiZW4genVtIEJlaXNwaWVsIGVpbiBNb3NhaWstRGF0YXNldCwgZGFzIExhbmRzYXQtQmlsZGRhdGVuIGF1cyBlaW5lbSBaZWl0cmF1bSB2b24gMjAgSmFocmVuIGVudGjDpGx0LCB1bmQgU2llIG3DtmNodGVuIGRlbiBORFZJIGbDvHIgamVkZSBTemVuZSBpbiBkZXIgWmVpdHNlcmllIGJlcmVjaG5lbi4gR2ViZW4gU2llIGFscyBcXFwiRWxlbWVudGZ1bmt0aW9uXFxcIiBlaW5lIFJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlIGFuLCBkaWUgZGllIE5EVkktUmFzdGVyLUZ1bmt0aW9uIGVudGjDpGx0LiBBbmdlYmVuIGVpbmVyIFJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlIGbDvHIgZGllIEFnZ3JlZ2F0aW9uc2Z1bmt0aW9uLiAyLiBTaWUgaGFiZW4genVtIEJlaXNwaWVsIGVpbiBtdWx0aWRpbWVuc2lvbmFsZXMgUmFzdGVyLCBkYXMgZGllIFRhZ2VzdGVtcGVyYXR1cmRhdGVuIGF1cyBlaW5lbSBaZWl0cmF1bSB2b24gMTAgSmFocmVuIGVudGjDpGx0LCB1bmQgU2llIG3DtmNodGVuIGRpZSBtYXhpbWFsZW4gSmFocmVzdGVtcGVyYXR1cmVuIGJlcmVjaG5lbi4gR2ViZW4gU2llIGFscyBcXFwiQWdncmVnYXRpb25zZnVua3Rpb25cXFwiIGVpbmUgUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2UgYW4sIGRpZSBkaWUgRnVua3Rpb24gXFxcIlplbGxlbnN0YXRpc3Rpa1xcXCIgZW50aMOkbHQsIHVuZCBzZXR6ZW4gU2llIGRpZSBPcGVyYXRpb24gYXVmIFxcXCJNYXhpbXVtXFxcIi4gTGVnZW4gU2llIHVudGVyIFxcXCJBZ2dyZWdhdGlvbnNkZWZpbml0aW9uXFxcIiBmw7xyIGRpZSBcXFwiRGltZW5zaW9uXFxcIiBkaWUgT3B0aW9uIFxcXCJTdGRUaW1lXFxcIiwgZsO8ciBkZW4gXFxcIlR5cFxcXCIgZGllIE9wdGlvbiBcXFwiSW50ZXJ2YWxsc2NobMO8c3NlbHdvcnRcXFwiIHVuZCBmw7xyIGRhcyBcXFwiU2NobMO8c3NlbHdvcnRpbnRlcnZhbGxcXFwiIGRpZSBPcHRpb24gXFxcIkrDpGhybGljaFxcXCIgZmVzdC4gQmVhY2h0ZW4gU2llLCBkYXNzIGRpZSBBZ2dyZWdhdGlvbnNkZWZpbml0aW9uIHZvbiBkZXIgQWdncmVnYXRpb25zZnVua3Rpb24gbmljaHQgYmVyw7xja3NpY2h0aWd0IHdpcmQsIHdlbm4gZGFzIEVpbmdhYmUtTW9zYWlrLURhdGFzZXQgbmljaHQgbXVsdGlkaW1lbnNpb25hbCBpc3QuIERpZSBBZ2dyZWdhdGlvbnNmdW5rdGlvbiBhZ2dyZWdpZXJ0IGFsbGUgRWxlbWVudGUgb2RlciBqZWRlIEdydXBwZSBpbiBlaW5lLCB3ZW5uIHNpZSBpbiBkZXIgVm9ybGFnZSBkZXIgQWdncmVnYXRpb25zZnVua3Rpb24gZGVmaW5pZXJ0IHNpbmQuIFdlaXRlcmUgSW5mb3JtYXRpb25lbiB6dXIgVmVyd2VuZHVuZyB2b24gR3J1cHBlbiBpbiBlaW5lbSBNb3NhaWstRGF0YXNldCBmaW5kZW4gU2llIHVudGVyIFZlcndlbmRlbiB2b24gTW9zYWlrLURhdGFzZXQtRWxlbWVudGVuIGluIFJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlbi4gMy4gR2ViZW4gU2llIGVpbmUgUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2UgZsO8ciBkaWUgXFxcIlZlcmFyYmVpdHVuZ3NmdW5rdGlvblxcXCIgYW4uIERpZSBGdW5rdGlvbiBvZGVyIEZ1bmt0aW9uc2tldHRlIGluIGRpZXNlciBWb3JsYWdlIGRpZW50IGRlciBBbnplaWdlIGRlcyBuZXVlbiB2ZXJhcmJlaXRldGVuIFJhc3RlcnMuIFNpZSBrw7ZubmVuIHp1bSBCZWlzcGllbCBlaW5lIFJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlIG1pdCBkZXIgRnVua3Rpb24gXFxcIkNvbG9ybWFwXFxcIiBhbmdlYmVuLCB1bSBEYXJzdGVsbHVuZ3N3ZWlzZSBkZXMgdmVyYXJiZWl0ZXRlbiBSYXN0ZXItTGF5ZXJzIHp1IMOkbmRlcm4uIEJlYWNodGVuIFNpZSwgZGFzcyBkaWUgRnVua3Rpb24gYXVmIGRlbiBha3R1ZWxsZW4gQW56ZWlnZWF1c3NjaG5pdHQgYW5nZXdlbmRldCB3aXJkLCB3ZW5uIGRpZSBFaW5nYWJlIGVpbiBtdWx0aWRpbWVuc2lvbmFsZXMgUmFzdGVyIGlzdC4gV2VubiBkaWUgRWluZ2FiZSBlaW4gTW9zYWlrLUxheWVyIG9kZXIgZWluIE1vc2Fpay1EYXRhc2V0IGlzdCwgd2lyZCBkaWUgVmVyYXJiZWl0dW5nc2Z1bmt0aW9uIG1pdCBkZXIgTWV0aG9kZSBcXFwiRXJzdGUocilcXFwiIGF1ZiBkYXMgTW9zYWlrLVJhc3RlciBhbmdld2VuZGV0LCB1bSDDnGJlcmxhcHB1bmdlbiBhdWZ6dWzDtnNlbi4gMy4gU2llIGvDtm5uZW4gVm9ybGFnZW4gZsO8ciBlaW5lIGJlbGllYmlnZSBLb21iaW5hdGlvbiBhdXMgZGVuIGRyZWkgRnVua3Rpb25lbiBhbmdlYmVuLiBTaWUgaGFiZW4genVtIEJlaXNwaWVsIGVpbiBNb3NhaWstRGF0YXNldCwgZGFzIGVpbmUgWmVpdHNlcmllIGF1cyBMYW5kc2F0LUJpbGRkYXRlbiBlbnRow6RsdCwgdW5kIG3DtmNodGVuIGVpbiB6dXNhbW1lbmdlc2V0enRlcyBCaWxkIG1pdCBtYXhpbWFsZW0gTkRWSSBlcnN0ZWxsZW4uIEdlYmVuIFNpZSBhbHMgXFxcIkVsZW1lbnRmdW5rdGlvblxcXCIgZWluZSBSYXN0ZXItRnVua3Rpb25zdm9ybGFnZSBhbiwgZGllIGRpZSBORFZJLVJhc3Rlci1GdW5rdGlvbiBlbnRow6RsdC4gR2ViZW4gU2llIGFscyBcXFwiQWdncmVnYXRpb25zZnVua3Rpb25cXFwiIGVpbmUgUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2UgYW4sIGRpZSBkaWUgRnVua3Rpb24gWmVsbGVuc3RhdGlzdGlrIGVudGjDpGx0LCB1bmQgc2V0emVuIFNpZSBkaWUgT3BlcmF0aW9uIGF1ZiBcXFwiTWF4aW11bVxcXCIuIEdlYmVuIFNpZSBhbHMgXFxcIlZlcmFyYmVpdHVuZ3NmdW5rdGlvblxcXCIgZWluZSBSYXN0ZXItRnVua3Rpb25zdm9ybGFnZSBhbiwgZGllIGRpZSBGdW5rdGlvbiBcXFwiQ29sb3JtYXBcXFwiIGVudGjDpGx0LiBCZWFjaHRlbiBTaWUsIGRhc3MgZGllIFZlcmFyYmVpdHVuZ3NyZWloZW5mb2xnZSBkZXIgRnVua3Rpb24gZGVyIFJlaWhlbmZvbGdlIGRlciBFaW5nYWJlcGFyYW1ldGVyIGVudHNwcmljaHQuIERpZSBcXFwiRWxlbWVudGZ1bmt0aW9uXFxcIiB3aXJkIGJlaXNwaWVsc3dlaXNlIHp1ZXJzdCB2ZXJhcmJlaXRldC48L2Rpdj5cIixcblx0XHRyYW5kb21OYW1lOiBcIlp1ZsOkbGxpZ1wiLFxuXHRcdHJhbmRvbVNuaXA6IFwiRXJzdGVsbHQgZWluIFJhc3RlciBtaXQgenVmw6RsbGlnZW4gUGl4ZWx3ZXJ0ZW4sIGRpZSBhdXMgZWluZXIgUHNldWRvenVmYWxsc3ZlcnRlaWx1bmcgYWJnZXJ1ZmVuIHdlcmRlbi4gRXMgd2VyZGVuIHZlcnNjaGllZGVuZSBWZXJ0ZWlsdW5nZW4gdW5kIFp1ZmFsbHN6YWhsZW5nZW5lcmF0b3JlbiB1bnRlcnN0w7x0enQuXCIsXG5cdFx0cmFuZG9tRGVzYzogXCJNaXQgZGVyIG5ldWVuIEZ1bmt0aW9uIFxcXCJadWZhbGxzcHJpbnppcFxcXCIgd2lyZCBlaW4gUmFzdGVyIG1pdCB6dWbDpGxsaWdlbiBQaXhlbHdlcnRlbiBlcnN0ZWxsdCwgZGFzIGluIFJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlbiBvZGVyIE1vc2Fpay1EYXRhc2V0cyB2ZXJ3ZW5kZXQgd2VyZGVuIGthbm4uPGRpdj48YnIvPlZpZWxlIEZ1bmt0aW9uZW4ga8O2bm5lbiBpbiBlaW5lbSBvZGVyIG1laHJlcmVuIEVpbmdhYmUtUmFzdGVybiB2ZXJ3ZW5kZXQgd2VyZGVuLiBGw7xyIGRpZSBadWZhbGxzZnVua3Rpb24gaXN0IGRhZ2VnZW4ga2VpbiBFaW5nYWJlLVJhc3RlciBlcmZvcmRlcmxpY2guIERhcyBiZWRldXRldCwgZGFzcyBzaWUgc2ljaCB3ZW5pZ2VyIHdpZSBlaW5lIEZ1bmt0aW9uIGFscyB2aWVsbWVociB3aWUgZWluIFJhc3Rlci1EYXRhc2V0IHZlcmjDpGx0LiBEYWhlciBtdXNzIGJlaSBkZXJlbiBIaW56dWbDvGd1bmcgenUgYnp3LiBFbnRmZXJudW5nIGF1cyBkZXIgRnVua3Rpb25za2V0dGUgbWl0IGJlc29uZGVyZXIgU29yZ2ZhbHQgdm9yZ2VnYW5nZW4gd2VyZGVuLjwvZGl2PlwiLFxuXHRcdHNocmlua05hbWU6IFwiVmVya2xlaW5lcm5cIixcblx0XHRzaHJpbmtTbmlwOiBcIlZlcmtsZWluZXJ0IGRpZSBhdXNnZXfDpGhsdGVuIFpvbmVuIHVtIGVpbmUgYW5nZWdlYmVuZSBBbnphaGwgYW4gWmVsbGVuLCBpbmRlbSBzaWUgZHVyY2ggZGVuIFdlcnQgZGVyIFplbGxlIGVyc2V0enQgd2VyZGVuLCBkZXIgaW4gZGVyIE5hY2hiYXJzY2hhZnQgYW0gaMOkdWZpZ3N0ZW4gdm9ya29tbXQuXCIsXG5cdFx0c2hyaW5rRGVzYzogXCJNaXQgZGVyIGdsb2JhbGVuIEZ1bmt0aW9uIFxcXCJWZXJrbGVpbmVyblxcXCIga8O2bm5lbiBTaWUgUmFzdGVyIGdlbmVyYWxpc2llcmVuIG9kZXIgdmVyZWluZmFjaGVuLCBpbmRlbSBTaWUgYmVzdGltbXRlIFpvbmVuIHZlcmtsZWluZXJuLiBEYXLDvGJlciBoaW5hdXMga8O2bm5lbiBTaWUgZGVuIEdyYWQgZGVyIEdlbmVyYWxpc2llcnVuZyBzdGV1ZXJuLjxkaXY+PGJyLz5EaWUgYXVzZ2V3w6RobHRlbiBab25lbiB3ZXJkZW4gdmVya2xlaW5lcnQgYnp3LiBpbiBpaHJlciBHcsO2w59lIHJlZHV6aWVydCwgaW5kZW0gWmVsbGVuIGF1cyB1bWxpZWdlbmRlbiBab25lbiBhdWYgc2llIGVyd2VpdGVydCB3ZXJkZW4uIEtvbnplcHRpb25lbGwgZ2VzZWhlbiBrw7ZubmVuIGRpZSBhdXNnZXfDpGhsdGVuIFxcXCJab25lbndlcnRlXFxcIiBhbHMgVm9yZGVyZ3J1bmR6b25lbiBiZXRyYWNodGV0IHdlcmRlbiwgd8OkaHJlbmQgZGllIGFuZGVyZW4gV2VydGUgSGludGVyZ3J1bmR6b25lbiBibGVpYmVuLiBEaWUgWmVsbGVuIGluIGRlbiBWb3JkZXJncnVuZHpvbmVuIGvDtm5uZW4gZHVyY2ggWmVsbGVuIGluIGRlbiBIaW50ZXJncnVuZHpvbmVuIGVyc2V0enQgd2VyZGVuLiBEw7xubmUgSW5zZWxuIGluIGVpbmVyIFpvbmUsIGRlcmVuIEdyZW56ZW4gYWxzIGdlbWVpbnNhbWUgR3JlbnplbiBtaXQgZGVyIFpvbmUgYW5nZXNlaGVuIHdlcmRlbiBrw7ZubmVuLCB3ZXJkZW4gbcO2Z2xpY2hlcndlaXNlIGViZW5mYWxscyBlcnNldHp0LjxkaXY+PGJyLz5EZXIgR3JhZCBkZXIgR2VuZXJhbGlzaWVydW5nIGthbm4gbWl0IGRlbSBQYXJhbWV0ZXIgXFxcIkFuemFobCBkZXIgWmVsbGVuXFxcIiBnZXN0ZXVlcnQgd2VyZGVuLiBTdGFuZGFyZG3DpMOfaWcgbGF1dGV0IGRpZXNlciBXZXJ0IDEsIGQuIGguIGRpZSBhdXNnZXfDpGhsdGVuIFpvbmVuIHdlcmRlbiB1bSBqZXdlaWxzIGVpbmUgWmVsbGUgdmVya2xlaW5lcnQuIFVtIGRlbiBHcmFkIGRlciBHZW5lcmFsaXNpZXJ1bmcgenUgZXJow7ZoZW4sIGvDtm5uZW4gU2llIGbDvHIgZGllc2VuIFBhcmFtZXRlciBlaW5lbiBncsO2w59lcmVuIFdlcnQgZWluZ2ViZW4uIEtvbnplcHRpb25lbGwga29tbXQgZGllcyBkZW0gQXVzZsO8aHJlbiBkZXMgV2Vya3pldWdzIG1pdCBlaW5lciBIw6R1Zmlna2VpdCBnbGVpY2gsIGRpZSBkZXIgYW5nZWdlYmVuZW4gQW56YWhsIGVudHNwcmljaHQsIHdvYmVpIGRpZSBFcmdlYm5pc3NlIGRlciB2b3JoZXJpZ2VuIEF1c2bDvGhydW5nIGRpZSBFaW5nYWJlIGRlciBuw6RjaHN0ZW4gQXVzZsO8aHJ1bmcgc2luZC48L2Rpdj5cIixcblx0XHR0cmVuZFRvUkdCTmFtZTogXCJUcmVuZCBpbiBSR0JcIixcblx0XHR0cmVuZFRvUkdCU25pcDogXCJLb252ZXJ0aWVydCBlaW4gVHJlbmQtUmFzdGVyIGluIGVpbiBSR0ItUmFzdGVyIChSb3QsIEdyw7xuIHVuZCBCbGF1KSBtaXQgZHJlaSBCw6RuZGVybi5cIixcblx0XHR0cmVuZFRvUkdCRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJUcmVuZCBpbiBSR0JcXFwiIHdpcmQgZWluIFRyZW5kLVJhc3RlciBpbiBlaW4gUmFzdGVyIG1pdCBkcmVpIELDpG5kZXJuIChSb3QsIEdyw7xuIHVuZCBCbGF1KSBrb252ZXJ0aWVydC4gRGFzIFRyZW5kLVJhc3RlciB3aXJkIGF1cyBkZXIgUmFzdGVyLUZ1bmt0aW9uIFxcXCJUcmVuZCBnZW5lcmllcmVuXFxcIiBvZGVyIGRlciBSYXN0ZXItRnVua3Rpb24gXFxcIkNDREMtQW5hbHlzZVxcXCIgZ2VuZXJpZXJ0LjxkaXY+PGJyLz5EaWVzZSBGdW5rdGlvbiBpc3QgaGlsZnJlaWNoIGJlaSBkZXIgVmlzdWFsaXNpZXJ1bmcgdm9uIE1vZGVsbGtvZWZmaXppZW50ZW5kYXRlbiBhdXMgZGVyIEZ1bmt0aW9uIFxcXCJUcmVuZCBnZW5lcmllcmVuXFxcIiBvZGVyIFxcXCJDQ0RDLUFuYWx5c2VcXFwiLiBJbiBiZWlkZW4gRnVua3Rpb25lbiB3ZXJkZW4gVHJlbmRzIGJlaSBzaWNoIMOkbmRlcm5kZW4gUGl4ZWx3ZXJ0ZW4gYWJnZXNjaMOkdHp0LCBkaWUgRXJnZWJuaXNzZSBkZXIgRnVua3Rpb25lbiBsYXNzZW4gc2ljaCBqZWRvY2ggbnVyIHNjaHdlciBkaXJla3QgaW50ZXJwcmV0aWVyZW4uPGRpdj48YnIvPldpZSBiZWkgdmllbGVuIFJhc3Rlci1GdW5rdGlvbmVuIG3DvHNzZW4gU2llIG3DtmdsaWNoZXJ3ZWlzZSBkaWUgZHluYW1pc2NoZSBCZXJlaWNoc2FucGFzc3VuZyAoRFJBKSB2ZXJ3ZW5kZW4sIHVtIGRpZSBFcmdlYm5pc3NlIGRlciBGdW5rdGlvbiBiZXNzZXIgYW56ZWlnZW4genUga8O2bm5lbi48L2Rpdj5cIixcblx0XHRsYW5kVHJlbmRyTmFtZTogXCJMYW5kVHJlbmRyLUFuYWx5c2VcIixcblx0XHRsYW5kVHJlbmRyU25pcDogXCLDnGJlcnByw7xmdCBtaXQgZGVyIExhbmRzYXQtTWV0aG9kZSB6dXIgRXJrZW5udW5nIHZvbiBTdMO2cnVuZ3MtIHVuZCBSZWdlbmVyYXRpb25zdGVuZGVuemVuIChMYW5kVHJlbmRyKSBWZXLDpG5kZXJ1bmdlbiB2b24gUGl4ZWx3ZXJ0ZW4gaW0gWmVpdHZlcmxhdWYgdW5kIGdlbmVyaWVydCBlaW4gVmVyw6RuZGVydW5nc2FuYWx5c2UtUmFzdGVyLCBkYXMgZGllIE1vZGVsbGVyZ2Vibmlzc2UgZW50aMOkbHQuXCIsXG5cdFx0bGFuZFRyZW5kckRlc2M6IFwiRGllc2UgUmFzdGVyLUZ1bmt0aW9uIGthbm4gbnVyIGFscyBFaW5nYWJlIGbDvHIgZGllIFJhc3Rlci1GdW5rdGlvbiBWZXLDpG5kZXJ1bmcgbWl0IFZlcsOkbmRlcnVuZ3NhbmFseXNlIGVya2VubmVuIHZlcndlbmRldCB3ZXJkZW4uIFVtIGVpbmUgUmFzdGVyLUF1c2dhYmUgenUgZXJ6ZXVnZW4sIHZlcmJpbmRlbiBTaWUgZGllIExhbmRUcmVuZHItQW5hbHlzZS1GdW5rdGlvbiBpbiBlaW5lciBSYXN0ZXItRnVua3Rpb25zdm9ybGFnZSBtaXQgZGVyIEZ1bmt0aW9uIFxcXCJWZXLDpG5kZXJ1bmcgbWl0IFZlcsOkbmRlcnVuZ3NhbmFseXNlIGVya2VubmVuXFxcIiwgdW5kIHZlcndlbmRlbiBTaWUgZGllIFZvcmxhZ2UgYWxzIEVpbmdhYmUgZsO8ciBkYXMgR2VvdmVyYXJiZWl0dW5nc3dlcmt6ZXVnIFxcXCJSYXN0ZXIgw7xiZXIgUmFzdGVyLUZ1bmt0aW9uIGVyc3RlbGxlblxcXCIuIERhcyBFcmdlYm5pcyBpc3QgZWluIFJhc3RlciwgZGFzIEluZm9ybWF0aW9uZW4gw7xiZXIgZGVuIFplaXRwdW5rdCBlbnRow6RsdCwgYW4gZGVtIHNpY2ggUGl4ZWx3ZXJ0ZSB2ZXLDpG5kZXJ0IGhhYmVuLjxkaXY+PGJyPkRlciBad2VjayBkaWVzZXIgUmFzdGVyLUZ1bmt0aW9uIGJlc3RlaHQgZGFyaW4sIFZlcsOkbmRlcnVuZ2VuIGFuIGVpbmVtIGJlb2JhY2h0ZXRlbiBGZWF0dXJlIHp1IGV4dHJhaGllcmVuLCBzb2Rhc3MgZGllIG9wdGltYWxlbiBtdWx0aWRpbWVuc2lvbmFsZW4gRWluZ2FiZS1CaWxkZGF0ZW4gaW0gWmVpdHZlcmxhdWYgZWluZSBrb25zaXN0ZW50ZSBCZW9iYWNodHVuZyBlcmZhc3NlbiB1bmQga2VpbmUgYXRtb3NwaMOkcmlzY2hlbiBvZGVyIFNlbnNvcnN0w7ZydW5nZW4sIFdvbGtlbiBiencuIFdvbGtlbnNjaGF0dGVuIGVudGhhbHRlbiBzb2xsdGVuLiBFcyBoYXQgc2ljaCBiZXfDpGhydCwgRGF0ZW4genUgdmVyd2VuZGVuLCBkaWUgbm9ybWFsaXNpZXJ0IHd1cmRlbiB1bmQgbWl0IGVpbmVtIFFBLUJhbmQgbWFza2llcnQgd2VyZGVuIGvDtm5uZW4sIHouwqBCLiBQcm9kdWt0ZSBhdXMgZGVyIExhbmRzYXQtU2FtbWx1bmfCoDEgenVyIE9iZXJmbMOkY2hlbnJlZmxleGlvbiBtaXQgZWluZXIgV29sa2VubWFza2llcnVuZy48ZGl2Pjxicj5EaWUgRnVua3Rpb24gZsO8aHJ0IGRpZSBBbmFseXNlIGbDvHIgZWluIEJpbGQgcHJvIEphaHIgYXVzLCB1bmQgZGllIEFuemFobCBkZXIgSmFocmVzYWJzY2huaXR0ZSBtdXNzIGdsZWljaCBvZGVyIGdyw7bDn2VyIHNlaW4gYWxzIGRlciBpbSBQYXJhbWV0ZXIgPHN0cm9uZz5NaW5pbWFsZSBBbnphaGwgZGVyIEJlb2JhY2h0dW5nZW48L3N0cm9uZz4gYW5nZWdlYmVuZSBXZXJ0LiBFcyB3aXJkIGVtcGZvaGxlbiwgRGF0ZW4gYXVzIG1pbmRlc3RlbnMgc2VjaHMgSmFocmVuIHp1IHZlcndlbmRlbi48ZGl2Pjxicj5XZW5uIFNpZSDDvGJlciBtb25hdGxpY2hlLCB3w7ZjaGVudGxpY2hlIG9kZXIgdMOkZ2xpY2hlIERhdGVuIHZlcmbDvGdlbiwgc29sbHRlbiBTaWUgYXVzIGplZGVtIEphaHIgbWVocmVyZSBCaWxkZXIgYXVzd8OkaGxlbiAodm9yenVnc3dlaXNlIGF1cyBkZXIgZ2xlaWNoZW4gSmFocmVzemVpdCksIFdvbGtlbiB1bmQgV29sa2Vuc2NoYXR0ZW4gZW50ZmVybmVuIHVuZCBkdXJjaCBLb21iaW5pZXJlbiBkZXIgQmlsZGVyIGVpbiBlaW56ZWxuZXMgQmlsZCBnZW5lcmllcmVuLCBkYXMgZGllIEJlb2JhY2h0dW5nIGd1dCBlcmZhc3N0LiBTb2Zlcm4gbW9uYXRsaWNoZSwgd8O2Y2hlbnRsaWNoZSBvZGVyIHTDpGdsaWNoZSBEYXRlbiBhbHMgbXVsdGlkaW1lbnNpb25hbGVzIEVpbmdhYmUtUmFzdGVyIGJlcmVpdGdlc3RlbGx0IHdlcmRlbiwgZXJtaXR0ZWx0IGRpZSBGdW5rdGlvbiBlaW5lbiBBYnNjaG5pdHQgZsO8ciBkaWUgQW5hbHlzZSBhdWYgZGVyIEdydW5kbGFnZSBkZXMgRGF0dW1zLCBkYXMgZGVtIGltIFBhcmFtZXRlciA8c3Ryb25nPkZhbmdkYXR1bTwvc3Ryb25nPiBhbmdlZ2ViZW5lbiBEYXR1bSBhbSBuw6RjaHN0ZW4gbGllZ3QuPGRpdj48YnI+RWluIEZlYXR1cmUgaW4gZWluZXIgTGFuZHNjaGFmdCBicmF1Y2h0IGjDpHVmaWcgZWluaWdlIFplaXQsIGJpcyBlcyBzaWNoIHZvbiBlaW5lciBuaWNodCBkYXVlcmhhZnRlbiBWZXLDpG5kZXJ1bmcgd2llIGVpbmVtIFdhbGRicmFuZCBvZGVyIGVpbmVtIEluc2VrdGVuYmVmYWxsIGVyaG9sdCBoYXQuIExlZ2VuIFNpZSBkZW4gUGFyYW1ldGVyIFxcXCJSZWdlbmVyYXRpb25zc2Nod2VsbGVud2VydFxcXCIgZmVzdCwgdW0gZGllIHZvbSBNb2RlbGwgZXJrYW5udGUgUmVnZW5lcmF0aW9uc3JhdGUgenUgc3RldWVybi4gRWluIGVpbmRldXRpZ2VzIFNlZ21lbnQga2FubiBrZWluZSBzY2huZWxsZXJlIFJlZ2VuZXJhdGlvbnNyYXRlIGFscyAxL1JlZ2VuZXJhdGlvbnNzY2h3ZWxsZW53ZXJ0IGF1ZndlaXNlbi48ZGl2Pjxicj5EaWUgUmVnZW5lcmF0aW9uIG5hY2ggZWluZXIgVmVyw6RuZGVydW5nIGluIGVpbmVyIExhbmRzY2hhZnQga2FubiBpbiBwb3NpdGl2ZXIgb2RlciBuZWdhdGl2ZXIgUmljaHR1bmcgZXJmb2xnZW4uIEVybGVpZGV0IGVpbmUgTGFuZHNjaGFmdCB6LsKgQi4gV2FsZHZlcmx1c3QsIHplaWd0IGVpbmUgWmVpdHNlcmllIHZvbiBWZWdldGF0aW9uc2luZGV4d2VydGVuIGVpbmVuIFLDvGNrZ2FuZyBkZXIgSW5kZXh3ZXJ0ZSwgdW5kIGRpZSBSZWdlbmVyYXRpb24gemVpZ3QgZWluZW4gYWxsbcOkaGxpY2hlbiBBbnN0aWVnIGRlciBWZWdldGF0aW9uc2luZGV4d2VydGUgb2RlciBlaW5lbiBwb3NpdGl2ZW4gUmVnZW5lcmF0aW9uc3RyZW5kLiBHZWJlbiBTaWUgZGllIFJpY2h0dW5nIGRlcyBSZWdlbmVyYXRpb25zdHJlbmRzIG1pdCBkZW0gUGFyYW1ldGVyIDxzdHJvbmc+UmVnZW5lcmF0aW9uIG1pdCB6dW5laG1lbmRlbSBUcmVuZDwvc3Ryb25nPiBhbi5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsTmFtZTogXCJNdWx0aWRpbWVuc2lvbmFsIGFnZ3JlZ2llcmVuXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbFNuaXA6IFwiS29tYmluaWVydCB2b3JoYW5kZW5lIG11bHRpZGltZW5zaW9uYWxlIFJhc3Rlci1WYXJpYWJsZW5kYXRlbiBlbnRsYW5nIGVpbmVyIERpbWVuc2lvbi5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsRGVzYzogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJNdWx0aWRpbWVuc2lvbmFsIGFnZ3JlZ2llcmVuXFxcIiB3aXJkIGVpbiBtdWx0aWRpbWVuc2lvbmFsZXIgUmFzdGVyLUxheWVyIGVyc3RlbGx0LCBpbmRlbSB2b3JoYW5kZW5lIG11bHRpZGltZW5zaW9uYWxlIFJhc3Rlci1WYXJpYWJsZW5kYXRlbiBlbnRsYW5nIGVpbmVyIERpbWVuc2lvbiBtaXRlaW5hbmRlciBrb21iaW5pZXJ0IHdlcmRlbi48ZGl2Pjxicj5NaXQgZGVtIFBhcmFtZXRlciA8c3Ryb25nPkRpbWVuc2lvbnNkZWZpbml0aW9uPC9zdHJvbmc+IGZpbHRlcm4gU2llIHp1bsOkY2hzdCBkaWUgRWluZ2FiZWRhdGVuLCBkaWUgU2llIGFnZ3JlZ2llcmVuIG3DtmNodGVuLiBXZW5uIFNpZSBiZWlzcGllbHN3ZWlzZSDDvGJlciBtb25hdGxpY2hlIERhdGVuIGF1cyAzMMKgSmFocmVuIHZlcmbDvGdlbiwgYWJlciBudXIgZWluZW4gYWdncmVnaWVydGVuIExheWVyIGbDvHIgZGllIGVyc3RlbiAxNcKgSmFocmUgZXJzdGVsbGVuIG3DtmNodGVuLCBrw7ZubmVuIFNpZSBtaXRoaWxmZSBkZXMgUGFyYW1ldGVycyA8c3Ryb25nPkRpbWVuc2lvbnNkZWZpbml0aW9uPC9zdHJvbmc+IGRpZSBKYWhyZSBhbmdlYmVuLCBkaWUgaW4gZGllIEFuYWx5c2UgZWluYmV6b2dlbiB3ZXJkZW4gc29sbGVuLjxkaXY+PGJyPjx1bD48bGk+RXh0cmFoaWVyZW4gZGVyIERhdGVuIHp1bSBTYWx6Z2VoYWx0IGbDvHIgZGVuIE1vbmF0IEphbnVhciDDvGJlciBkZW4gWmVpdHJhdW0gdm9uIDEwwqBKYWhyZW4uIFfDpGhsZW4gU2llIDxzdHJvbmc+RHVyY2ggV2VydGU8L3N0cm9uZz4gYXVzLiBMZWdlbiBTaWUgZsO8ciA8c3Ryb25nPkRpbWVuc2lvbjwvc3Ryb25nPiBkZW4gV2VydCA8c3Ryb25nPlN0ZFRpbWU8L3N0cm9uZz4gdW5kIGbDvHIgPHN0cm9uZz5XZXJ0ZTwvc3Ryb25nPiBkaWUgT3B0aW9uIDxzdHJvbmc+SmFudWFyPC9zdHJvbmc+IGZlc3QuPC9saT48bGk+QXVmdGVpbGVuIGRlciBEYXRlbiB6dW0gU2FsemdlaGFsdCBmw7xyIGRlbiBUaWVmZW5iZXJlaWNoIDAgYmlzIDE1MMKgTWV0ZXIuIFfDpGhsZW4gU2llIDxzdHJvbmc+TmFjaCBCZXJlaWNoZW48L3N0cm9uZz4gYXVzLiBMZWdlbiBTaWUgZsO8ciA8c3Ryb25nPkRpbWVuc2lvbjwvc3Ryb25nPiBkZW4gV2VydCA8c3Ryb25nPlN0ZFo8L3N0cm9uZz4sIGbDvHIgPHN0cm9uZz5NaW5pbWFsd2VydDwvc3Ryb25nPiBkZW4gV2VydCA8c3Ryb25nPi0xNTA8L3N0cm9uZz4gdW5kIGbDvHIgPHN0cm9uZz5NYXhpbWFsd2VydDwvc3Ryb25nPiBkZW4gV2VydCA8c3Ryb25nPjA8L3N0cm9uZz4gZmVzdC48L2xpPjxsaT5FeHRyYWhpZXJlbiBkZXIgRGF0ZW4genVtIFNhbHpnZWhhbHQgZsO8ciBkaWUgZXJzdGVuIDEwwqBUYWdlIGRlcyBNb25hdHMgSmFudWFyIMO8YmVyIGVpbmVuIFplaXRyYXVtIHZvbiAxMMKgSmFocmVuLiBXw6RobGVuIFNpZSA8c3Ryb25nPk5hY2ggSXRlcmF0aW9uPC9zdHJvbmc+IGF1cy4gTGVnZW4gU2llIGbDvHIgPHN0cm9uZz5EaW1lbnNpb248L3N0cm9uZz4gZGVuIFdlcnQgPHN0cm9uZz5TdGRUaW1lPC9zdHJvbmc+IGZlc3QgdW5kIGbDvHIgPHN0cm9uZz5CZWdpbm4gZGVyIGVyc3RlbiBJdGVyYXRpb248L3N0cm9uZz4gc293aWUgPHN0cm9uZz5FbmRlIGRlciBlcnN0ZW4gSXRlcmF0aW9uPC9zdHJvbmc+IGVudHNwcmVjaGVuZCBkZW4gQmVnaW5uIHVuZCBkYXMgRW5kZSBkZXMgSXRlcmF0aW9uc3plaXRyYXVtcy4gTGVnZW4gU2llIGbDvHIgPHN0cm9uZz5TY2hyaXR0PC9zdHJvbmc+IGRlbiBXZXJ0IDxzdHJvbmc+MTwvc3Ryb25nPiB1bmQgZsO8ciA8c3Ryb25nPkVpbmhlaXQ8L3N0cm9uZz4gZGllIE9wdGlvbiA8c3Ryb25nPkphaHJlPC9zdHJvbmc+IGZlc3QuPC9saT48L3VsPjxkaXY+PGJyPlZlcndlbmRlbiBTaWUgZGllIFBhcmFtZXRlciB1bnRlciA8c3Ryb25nPkFnZ3JlZ2F0aW9uc2RlZmluaXRpb248L3N0cm9uZz4sIHVtIG1pdGhpbGZlIGVpbmVzIFNjaGzDvHNzZWx3b3J0ZXMsIGVpbmVzIFdlcnRlcyBvZGVyIGVpbmVzIFdlcnRlYmVyZWljaHMgZGllIHp1IGJld2VydGVuZGUgRGltZW5zaW9uIHVuZCBkYXMgQWdncmVnYXRpb25zaW50ZXJ2YWxsIGF1c3p1d8OkaGxlbi4gQmVpc3BpZWw6IElobmVuIHN0ZWhlbiBmw7xyIDMwwqBKYWhyZSBUZW1wZXJhdHVyZGF0ZW4gZGVyIE1lZXJlc29iZXJmbMOkY2hlIHp1ciBWZXJmw7xndW5nLCBkaWUgdMOkZ2xpY2ggYWxsZSA1wqBNZXRlciBiaXMgenUgZWluZXIgVGllZmUgdm9uIDEwMMKgTWV0ZXJuIGVyZmFzc3Qgd3VyZGVuLiBJbiBkaWVzZW0gRmFsbCBrw7ZubmVuIFNpZSBkaWUgdmVyc2NoaWVkZW5lbiBJbnRlcnZhbGxvcHRpb25lbiBmw7xyIGRpZSBmb2xnZW5kZW4gU3plbmFyaWVuIHZlcndlbmRlbjo8ZGl2Pjxicj48dWw+PGxpPlRhZ2VzdGVtcGVyYXR1cmRhdGVuIGluIG1vbmF0bGljaGUgRGF0ZW4gYWdncmVnaWVyZW4sIHNvZGFzcyBzaWNoIGVpbiBtdWx0aWRpbWVuc2lvbmFsZXMgUmFzdGVyIG1pdCAxMsKgWmVpdGludGVydmFsbGVuIGVyZ2lidCB1bmQgamVkZXMgSW50ZXJ2YWxsIGRhcyBBZ2dyZWdhdCBkZXIgZWluemVsbmVuIE1vbmF0ZSBmw7xyIGFsbGUgSmFocmUgaXN0LiBXw6RobGVuIFNpZSA8c3Ryb25nPkludGVydmFsbHNjaGzDvHNzZWx3b3J0PC9zdHJvbmc+IGF1cywgdW5kIGxlZ2VuIFNpZSBmw7xyIGRhcyBTY2hsw7xzc2Vsd29ydCBkaWUgT3B0aW9uIDxzdHJvbmc+TW9uYXRsaWNoIHdpZWRlcmtlaHJlbmQ8L3N0cm9uZz4gZmVzdC48L2xpPjxsaT5UYWdlc3RlbXBlcmF0dXJkYXRlbiBpbiBtb25hdGxpY2hlIERhdGVuIGFnZ3JlZ2llcmVuLCBzb2Rhc3Mgc2ljaCBlaW4gbXVsdGlkaW1lbnNpb25hbGVzIFJhc3RlciBtaXQgMzYwwqBaZWl0aW50ZXJ2YWxsZW4gYnp3LiAxMsKgWmVpdGludGVydmFsbGVuIHBybyBKYWhyIGVyZ2lidCAoMzDCoEphaHJlIHggMTLCoE1vbmF0ZSA9IDM2MMKgWmVpdGludGVydmFsbGUpLiBXw6RobGVuIFNpZSA8c3Ryb25nPkludGVydmFsbHNjaGzDvHNzZWx3b3J0PC9zdHJvbmc+IGF1cywgdW5kIGxlZ2VuIFNpZSBmw7xyIGRhcyBTY2hsw7xzc2Vsd29ydCBkaWUgT3B0aW9uIDxzdHJvbmc+TW9uYXRsaWNoPC9zdHJvbmc+IGZlc3QuPC9saT48bGk+TW9uYXRsaWNoZSBUZW1wZXJhdHVyZGF0ZW4gaW4gNC1Nb25hdHMtSW50ZXJ2YWxsZSBhZ2dyZWdpZXJlbi4gV8OkaGxlbiBTaWUgPHN0cm9uZz5JbnRlcnZhbGx3ZXJ0PC9zdHJvbmc+IGF1cywgbGVnZW4gU2llIGbDvHIgPHN0cm9uZz5XZXJ0aW50ZXJ2YWxsPC9zdHJvbmc+IGRlbiBXZXJ0IDQgZmVzdCB1bmQgZsO8ciA8c3Ryb25nPkVpbmhlaXQ8L3N0cm9uZz4gZGllIE9wdGlvbiA8c3Ryb25nPk1vbmF0ZTwvc3Ryb25nPi48L2xpPjxsaT5UZW1wZXJhdHVyZGF0ZW4gdm9uIDDCoGJpcyAyNcKgTWV0ZXIsIDI1wqBiaXMgNTDCoE1ldGVyIHVuZCA1MMKgYmlzIDEwMMKgTWV0ZXIgYWdncmVnaWVyZW4uIFfDpGhsZW4gU2llIDxzdHJvbmc+SW50ZXJ2YWxsYmVyZWljaGU8L3N0cm9uZz4gYXVzLCB1bmQgZ2ViZW4gU2llIGbDvHIgZGllIG1pbmltYWxlbiB1bmQgbWF4aW1hbGVuIFRpZWZlbndlcnRlIDxzdHJvbmc+MCAyNTsgMjUgNTA7IDUwIDEwMDwvc3Ryb25nPiBlaW4uPC9saT48L3VsPlwiLFxuXHRcdG1lcmdlUmFzdGVyc05hbWU6IFwiUmFzdGVyIHp1c2FtbWVuZsO8aHJlblwiLFxuXHRcdG1lcmdlUmFzdGVyc1NuaXA6IFwiS29tYmluaWVydCBtZWhyZXJlIFJhc3Rlci1EYXRhc2V0cyByw6R1bWxpY2ggb2RlciBmw7xyIHZlcnNjaGllZGVuZSBWYXJpYWJsZW4gdW5kIERpbWVuc2lvbmVuLlwiLFxuXHRcdG1lcmdlUmFzdGVyc0Rlc2M6IFwiRGllc2UgRnVua3Rpb24gZXJzdGVsbHQgYXVzIGVpbmVyIExpc3RlIHZvbiBSYXN0ZXJuIGVpbiB6dXNhbW1lbmdlZsO8aHJ0ZXMgUmFzdGVyLiBXZW5uIFNpZSBiZWlzcGllbHN3ZWlzZSDDvGJlciBlaW4gTW9zYWlrLURhdGFzZXQgdmVyZsO8Z2VuLCBkYXMgZGllIG1vbmF0bGljaGVuIE5pZWRlcnNjaGxhZ3NkYXRlbiB2b24gMzDCoEphaHJlbiBlbnRow6RsdCwgdW5kIGVpbiB3ZWl0ZXJlcyBEYXRhc2V0IG1pdCBtb25hdGxpY2hlbiBUZW1wZXJhdHVyZGF0ZW4gZsO8ciAxMMKgSmFocmUsIGvDtm5uZW4gU2llIGRpZXNlIHp1IGVpbmVtIG11bHRpZGltZW5zaW9uYWxlbiBSYXN0ZXIgbWl0IGJlaWRlbiBWYXJpYWJsZW4ga29tYmluaWVyZW4uIDxkaXY+PGJyPldlbm4gZGllIG11bHRpZGltZW5zaW9uYWxlbiBFaW5nYWJlLVJhc3RlciB1bnRlcnNjaGllZGxpY2hlIFZhcmlhYmxlbiBlbnRoYWx0ZW4sIGVudGjDpGx0IGRhcyBtdWx0aWRpbWVuc2lvbmFsZSBBdXNnYWJlLVJhc3RlciBzw6RtdGxpY2hlIFZhcmlhYmxlbi4gPGRpdj48YnI+V2VubiBkaWUgbXVsdGlkaW1lbnNpb25hbGVuIEVpbmdhYmUtUmFzdGVyIHVudGVyc2NoaWVkbGljaGUgRGltZW5zaW9uZW4gb2RlciBEaW1lbnNpb25zd2VydGUgZW50aGFsdGVuLCBlbnRow6RsdCBkYXMgbXVsdGlkaW1lbnNpb25hbGUgQXVzZ2FiZS1SYXN0ZXIgc8OkbXRsaWNoZSBEaW1lbnNpb25lbiB1bmQgRGltZW5zaW9uc3dlcnRlLiA8ZGl2Pjxicj5XZW5uIGRpZSBtdWx0aWRpbWVuc2lvbmFsZW4gRWluZ2FiZS1SYXN0ZXIgZGllc2VsYmVuIERpbWVuc2lvbmVuIHVuZCBWYXJpYWJsZW4sIGplZG9jaCB1bnRlcnNjaGllZGxpY2hlIHLDpHVtbGljaGUgQXVzZGVobnVuZ2VuIGVudGhhbHRlbiwgZW50aMOkbHQgZGFzIG11bHRpZGltZW5zaW9uYWxlIEF1c2dhYmUtUmFzdGVyIGRpZSBWYXJpYWJsZW4gdW5kIERpbWVuc2lvbmVuIGbDvHIgZGllIHp1c2FtbWVuZ2Vmw7xocnRlbiByw6R1bWxpY2hlbiBBdXNkZWhudW5nZW4uPGRpdj48YnI+VmVyd2VuZGVuIFNpZSBkaWVzZSBGdW5rdGlvbiwgd2VubiBTaWUgbWVocmVyZSBSYXN0ZXIgaGFiZW4sIGRpZSBTaWUgYWxzIGVpbiBFbGVtZW50IGJlaGFuZGVsbiBtw7ZjaHRlbiwgei7CoEIuIGJlaW0gQmVyZWNobmVuIGVpbmVyIFN0YXRpc3RpayBmw7xyIGFsbGUgQmlsZGVyIG9kZXIgYmVpbSBGYXJiYXVzZ2xlaWNoLCB1bSBkZW4gRmFyYmF1c2dsZWljaCBuaWNodCBmw7xyIGplZGVzIEJpbGQgc2VwYXJhdCB2b3JuZWhtZW4genUgbcO8c3Nlbi4gRGllcyBpc3QgbsO8dHpsaWNoIGJlaSBkZXIgQXJiZWl0IG1pdCBCaWxkZGF0ZW4sIGRpZSBhdWZncnVuZCB2b24gRGF0ZWlncsO2w59lbmJlc2NocsOkbmt1bmdlbiBhbHMgZ2V0cmVubnRlIEthY2hlbG4gZ2VzcGVpY2hlcnQgc2luZC4gQXVmIGRpZXNlIFdlaXNlIHdlcmRlbiBkaWUgS2FjaGVsbiBhbHMgVGVpbCBlaW5lcyBCaWxkZXMgYmVoYW5kZWx0LlwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5OYW1lOiBcIkdyZW56ZW4gZ2zDpHR0ZW5cIixcblx0XHRib3VuZGFyeUNsZWFuU25pcDogXCJHbMOkdHRldCBkaWUgR3JlbnplIHp3aXNjaGVuIFpvbmVuLlwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5EZXNjOiBcIjxwPkRpZSBGdW5rdGlvbiBnZW5lcmFsaXNpZXJ0IGJ6dy4gdmVyZWluZmFjaHQgUmFzdGVyLCBpbmRlbSBzaWUgZGllIEdyZW56ZW4gendpc2NoZW4gWm9uZW4gZ2zDpHR0ZXQuIEluIGRlciBGdW5rdGlvbiBzaW5kIE9wdGlvbmVuIHZlcmbDvGdiYXIsIG1pdCBkZW5lbiBnZXN0ZXVlcnQgd2lyZCwgd2VsY2hlIEF1c3dpcmt1bmdlbiBkaWUgWmVsbGVuIGRlciBFaW5nYWJlem9uZW4gYXVmIGRhcyBHbMOkdHRlbiB1bmQgZGVuIGFuZ2V3ZW5kZXRlbiBHbMOkdHR1bmdzZ3JhZCBoYWJlbi4gSmVkZSBFaW5nYWJlemVsbGUgd2lyZCBhbmhhbmQgZGVyIGFjaHQgbsOkY2hzdGVuIE5hY2hiYXJuIGF1c2dld2VydGV0LjwvcD48cD5CZWltIEdsw6R0dHVuZ3N2b3JnYW5nIHdlcmRlbiB6dWVyc3QgZGllIE5hY2hiYXJ6ZWxsZW4gbmFjaCBlaW5lciBiZXN0aW1tdGVuIFByaW9yaXTDpHQgZ2VvcmRuZXQuIER1cmNoIGRpZSBQcmlvcml0w6R0IHdpcmQgZmVzdGdlbGVndCwgd2VsY2hlIFpvbmUgYXVzIGRlbiBOYWNoYmFyemVsbGVuIGRlbiBXZXJ0IGRlciBWZXJhcmJlaXR1bmdzemVsbGUgaW4gZGVyIEF1c2dhYmUgZXJzZXR6ZW4ga2Fubi48L3A+PHA+RGllIFByaW9yaXTDpHQga2FubiBlbnR3ZWRlciBhdWYgZGVtIFdlcnQgZGVyIFpvbmVuIG9kZXIgZGVyIEdyw7bDn2UgZGVyIFpvbmVuIGJhc2llcmVuLiBNaXQgZGVtIFBhcmFtZXRlciA8c3Ryb25nPlNvcnRpZXJ0eXA8L3N0cm9uZz4gd2lyZCBkZXIgdmVyd2VuZGV0ZSBTb3J0aWVydHlwIGJlc3RpbW10LiA8L3A+PHA+QmVpIGRlciBTdGFuZGFyZGVpbnN0ZWxsdW5nIDxzdHJvbmc+TmljaHQgc29ydGllcmVuPC9zdHJvbmc+IHdpcmQgZGllIFByaW9yaXTDpHQgYmFzaWVyZW5kIGF1ZiBkZW0gV2VydCBkZXIgWm9uZW4gYXVzZ2V3ZXJ0ZXQuIFplbGxlbiBhdXMgWm9uZW4gbWl0IGjDtmhlcmVuIFdlcnRlbiBoYWJlbiBmw7xyIGRpZSBBdXNkZWhudW5nIGluIFpvbmVuIG1pdCBuaWVkcmlnZXJlbiBXZXJ0ZW4gZWluZSBow7ZoZXJlIFByaW9yaXTDpHQuPC9wPjxwPkRpZSBHcsO2w59lIGJ6dy4gR2VzYW10ZmzDpGNoZSBkZXIgWm9uZW4ga2FubiBmw7xyIGRpZSBTb3J0aWVydW5nIG5hY2ggUHJpb3JpdMOkdCB2ZXJ3ZW5kZXQgd2VyZGVuLiBNaXQgZGVyIEVpbnN0ZWxsdW5nIDxzdHJvbmc+QWJzdGVpZ2VuZDwvc3Ryb25nPiB3ZXJkZW4gZGllIFpvbmVuIGluIGFic3RlaWdlbmRlciBSZWloZW5mb2xnZSBuYWNoIEdyw7bDn2UgZ2VvcmRuZXQuIFpvbmVuIG1pdCBncsO2w59lcmVyIEdlc2FtdGZsw6RjaGUgaGFiZW4gZsO8ciBkaWUgQXVzZGVobnVuZyBpbiBab25lbiBtaXQga2xlaW5lcmVyIEdlc2FtdGZsw6RjaGUgZWluZSBow7ZoZXJlIFByaW9yaXTDpHQuIEJlaSBkZXIgRWluc3RlbGx1bmcgPHN0cm9uZz5BdWZzdGVpZ2VuZDwvc3Ryb25nPiB0cmlmZnQgZGFzIEdlZ2VudGVpbCB6dTogWm9uZW4gbWl0IGtsZWluZXJlciBHZXNhbXRmbMOkY2hlIGhhYmVuIGbDvHIgZGllIEF1c2RlaG51bmcgaW4gWm9uZW4gbWl0IGdyw7bDn2VyZXIgR2VzYW10ZmzDpGNoZSBlaW5lIGjDtmhlcmUgUHJpb3JpdMOkdC48L3A+PHA+RGVyIEdsw6R0dHVuZ3NncmFkIHdpcmQgbWl0IGRlbSBQYXJhbWV0ZXIgPHN0cm9uZz5BdXNkZWhuZW4gdW5kIFZlcmtsZWluZXJuIHp3ZWltYWwgZHVyY2hsYXVmZW48L3N0cm9uZz4gZ2VzdGV1ZXJ0LiBEYW1pdCB3aXJkIGRpZSBBbnphaGwgZGVyIER1cmNoZ8OkbmdlIGbDvHIgZGVuIEF1c2RlaG51bmdzLSB1bmQgVmVya2xlaW5lcnVuZ3N2b3JnYW5nIGZlc3RnZWxlZ3QuPC9wPjxwPklzdCBkaWUgRWluc3RlbGx1bmcgZGVha3RpdmllcnQsIHdpcmQgZGVyIEF1c2RlaG51bmdzLSB1bmQgVmVya2xlaW5lcnVuZ3N2b3JnYW5nIGVpbm1hbCBkdXJjaGdlZsO8aHJ0LiBJc3QgZGllIEVpbnN0ZWxsdW5nIGhpbmdlZ2VuIGFrdGl2aWVydCwgd2lyZCBkZXIgQXVzZGVobnVuZ3MtIHVuZCBWZXJrbGVpbmVydW5nc3ZvcmdhbmcgendlaW1hbCBkdXJjaGdlZsO8aHJ0LCBzb2Rhc3Mgc2ljaCBlaW5lIHN0w6Rya2VyZSBHbMOkdHR1bmcgZGVyIFpvbmVuZ3JlbnplbiBlcmdpYnQuPC9wPjxwPldlbm4gZGllIFdlcnRlIGFsbGVyIGFjaHQgTmFjaGJhcnplbGxlbiBkZW0gZGVyIFZlcmFyYmVpdHVuZ3N6ZWxsZSBlbnRzcHJlY2hlbiwgYmVow6RsdCBkaWUgQXVzZ2FiZXplbGxlIGRlbiBXZXJ0IGRlciBFaW5nYWJlemVsbGUgYmVpLjwvcD5cIixcblx0XHRwcmVkaWN0VXNpbmdSZWdyZXNzaW9uTmFtZTogXCJNaXQgUmVncmVzc2lvbiB2b3JoZXJzYWdlblwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25TbmlwOiBcIkJlcmVjaG5ldCBlaW4gdm9yaGVyZ2VzYWd0ZXMgUmFzdGVyIGJhc2llcmVuZCBhdWYgUmFzdGVyLURhdGVuLUVpbmdhYmVuIHVuZCBlaW5lbSBSZWdyZXNzaW9uc21vZGVsbC4gRGFzIFJlZ3Jlc3Npb25zbW9kZWxsIGlzdCBkaWUgQXVzZ2FiZSBkZXMgR2VvdmVyYXJiZWl0dW5nc3dlcmt6ZXVncyA8c3Ryb25nPlJlZ3Jlc3Npb25zbW9kZWxsIFxcXCJSYW5kb20gVHJlZXNcXFwiIHRyYWluaWVyZW48L3N0cm9uZz4uXCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvbkRlc2M6IFwiPHA+RGFzIFJlZ3Jlc3Npb25zbW9kZWxsIGlzdCBpbiBlaW5lciBFc3JpIFJlZ3Jlc3Npb25zZGVmaW5pdGlvbnNkYXRlaSAoLmVjZCkgZGVmaW5pZXJ0LiBTaWUgZW50aMOkbHQgYWxsZSBJbmZvcm1hdGlvbmVuIGbDvHIgZWluIGJlc3RpbW10ZXMgRGF0YXNldCBiencuIHZlcnNjaGllZGVuZSBEYXRhc2V0cyBzb3dpZSBkYXMgUmVncmVzc2lvbnNtb2RlbGwgdW5kIHdpcmQgZHVyY2ggZGFzIFJhc3Rlci1HZW92ZXJhcmJlaXR1bmdzd2Vya3pldWcgPHN0cm9uZz5SZWdyZXNzaW9uc21vZGVsbCBcXFwiUmFuZG9tIFRyZWVzXFxcIiB0cmFpbmllcmVuPC9zdHJvbmc+IGdlbmVyaWVydC48L3A+PHA+RGllIEVpbmdhYmUga2FubiBlaW4gRWluemVsYmFuZC0sIGVpbiBNdWx0aWJhbmQtIG9kZXIgZWluIG11bHRpZGltZW5zaW9uYWxlcyBSYXN0ZXIgb2RlciBlaW5lIExpc3RlIGRpZXNlciBUeXBlbiBzZWluLiBEaWUgVHlwZW4gZGVyIEVpbmdhYmUtUmFzdGVyIG3DvHNzZW4gbWl0IGRlbSBkdXJjaCBkYXMgUmVncmVzc2lvbnNtb2RlbGwgdHJhaW5pZXJ0ZW4gUmFzdGVyLVR5cCBpZGVudGlzY2ggc2Vpbi48L3A+PHVsPjxsaT5XZW5uIGRpZSBFaW5nYWJlIGVpbiBNdWx0aWJhbmQtUmFzdGVyIGlzdCwgd2lyZCBqZWRlcyBCYW5kIGFscyBFaW5mbHVzc3ZhcmlhYmxlIGJlaGFuZGVsdC4gRGllIFJlaWhlbmZvbGdlIGRlciBCw6RuZGVyIG11c3MgbWl0IGRlciBNdWx0aWJhbmQtRWluZ2FiZSBmw7xyIGRhcyBSZWdyZXNzaW9uc21vZGVsbC1UcmFpbmluZ3N3ZXJremV1ZyBpZGVudGlzY2ggc2Vpbi48L2xpPjxsaT5XZW5uIGRpZSBFaW5nYWJlIGVpbiBtdWx0aWRpbWVuc2lvbmFsZXMgUmFzdGVyIGlzdCwgd2lyZCBqZWRlIFZhcmlhYmxlIGFscyBFaW5mbHVzc3ZhcmlhYmxlIGJlaGFuZGVsdC4gQXXDn2VyZGVtIG11c3MgZGllIFZhcmlhYmxlIGVpbmUgRWluemVsYmFuZC1WYXJpYWJsZSBtaXQgZWluZXIgWmVpdGRpbWVuc2lvbiBzZWluLiBEaWUgUmVpaGVuZm9sZ2UgdW5kIE5hbWVuIGRlciBWYXJpYWJsZW4gbcO8c3NlbiBtaXQgZGVyIEVpbmdhYmUgYmVpbSBUcmFpbmllcmVuIGRlcyBSZWdyZXNzaW9uc21vZGVsbHMgaWRlbnRpc2NoIHNlaW4uIEJlaSBkZXIgQXVzZ2FiZSBoYW5kZWx0IGVzIHNpY2ggdW0gZWluIG11bHRpZGltZW5zaW9uYWxlcyBSYXN0ZXIuPC9saT48bGk+RGllIEVpbmdhYmUga2FubiBlaW5lIEVsZW1lbnRsaXN0ZSBzZWluLiBEaWUgQW56YWhsIHVuZCBSZWloZW5mb2xnZSBkZXIgRWxlbWVudGUgbXVzcyBtaXQgZGVyIEVpbmdhYmUgYmVpbSBUcmFpbmllcmVuIGRlcyBSZWdyZXNzaW9uc21vZGVsbHMgaWRlbnRpc2NoIHNlaW4uPC9saT48L3VsPlwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc05hbWU6IFwiR2xlaXRlbmRlIERpbWVuc2lvbnNzdGF0aXN0aWtlblwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc1NuaXA6IFwiQmVyZWNobmV0IGluIGVpbmVtIGdsZWl0ZW5kZW4gRmVuc3RlciB1bmQgZW50bGFuZyBlaW5lciBiZXN0aW1tdGVuIERpbWVuc2lvbiBTdGF0aXN0aWtlbiBmw7xyIG11bHRpZGltZW5zaW9uYWxlIERhdGVuLlwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc0Rlc2M6IFwiPHA+TWl0IGRlciBGdW5rdGlvbiBcXFwiR2xlaXRlbmRlIERpbWVuc2lvbnNzdGF0aXN0aWtlblxcXCIgd2VyZGVuIGluIGVpbmVtIHZvcmRlZmluaWVydGVuIEZlbnN0ZXIgZsO8ciBhbGxlIERpbWVuc2lvbnN3ZXJ0ZSBlbnRsYW5nIGVpbmVyIGJlc3RpbW10ZW4gRGltZW5zaW9uIHZlcnNjaGllZGVuZSBTdGF0aXN0aWtlbiBiZXJlY2huZXQuIERpZXNlIEZ1bmt0aW9uIHVudGVyc3TDvHR6dCBlaW5lbiBtdWx0aWRpbWVuc2lvbmFsZW4gUmFzdGVyLUxheWVyIGFscyBFaW5nYWJlIHVuZCBlcnN0ZWxsdCBhbHMgQXVzZ2FiZSBlaW5lbiBtdWx0aWRpbWVuc2lvbmFsZW4gUmFzdGVyLUxheWVyLCBkZXIgZGllIGdsZWljaGUgRGltZW5zaW9uc2dyw7bDn2Ugd2llIGRlciBFaW5nYWJlLUxheWVyIGF1ZndlaXN0LjwvcD48cD5TaWUga8O2bm5lbiBlaW5lIERpbWVuc2lvbiBhbmdlYmVuLCBmw7xyIGRpZSBiZWkgZGVyIEJlcmVjaG51bmcgRGltZW5zaW9uc3dlcnRlIGJlcsO8Y2tzaWNodGlndCB3ZXJkZW4uIFN0YW5kYXJkbcOkw59pZyBlcmZvbGd0IGRpZSBCZXJlY2hudW5nIGVudGxhbmcgZGVyIGVyc3RlbiBuaWNodHLDpHVtbGljaGVuIERpbWVuc2lvbi4gTWl0IGRlbiBQYXJhbWV0ZXJuIFxcXCJSw7xja3fDpHJ0c2dsZWl0ZW5kZXMgRmVuc3RlclxcXCIgdW5kIFxcXCJWb3J3w6RydHNnbGVpdGVuZGVzIEZlbnN0ZXJcXFwiIGvDtm5uZW4gU2llIGF1Y2ggZWluZSBGZW5zdGVyZ3LDtsOfZSBhbmdlYmVuLjwvcD48cD5XZW5uIGFscyBTdGF0aXN0aWt0eXAgXFxcIlBlcnplbnRpbFxcXCIgYXVzZ2V3w6RobHQgaXN0LCB3ZXJkZW4gZGllIFBhcmFtZXRlciBcXFwiUGVyemVudGlsd2VydFxcXCIgdW5kIFxcXCJQZXJ6ZW50aWwtSW50ZXJwb2xhdGlvbnN0eXBcXFwiIHZlcmbDvGdiYXIuIMOcYmVyIGRpZXNlIFBhcmFtZXRlciBrw7ZubmVuIFNpZSBkYXMgenUgYmVyZWNobmVuZGUgUGVyemVudGlsIGFuZ2ViZW4gYnp3LiBkZW4genUgdmVyd2VuZGVuZGVuIEludGVycG9sYXRpb25zdHlwIGF1c3fDpGhsZW4uIFdlbm4gYWxzIFN0YXRpc3Rpa3R5cCBcXFwiWmlya3Vsw6RyZXIgTWl0dGVsd2VydFxcXCIgZmVzdGdlbGVndCBpc3QsIHdpcmQgZGVyIFBhcmFtZXRlciBcXFwiVW1icnVjaHdlcnQgZsO8ciBWZXJ0ZWlsdW5nIGF1ZiBFaW5oZWl0c2tyZWlzXFxcIiB2ZXJmw7xnYmFyLiBBbmhhbmQgZGVzIFVtYnJ1Y2h3ZXJ0ZXMgZsO8ciBkaWUgVmVydGVpbHVuZyBhdWYgZGVtIEVpbmhlaXRza3JlaXMgd2lyZCBlaW4gbGluZWFyZXIgV2VydCBpbiBkZW4gQmVyZWljaCBlaW5lcyBiZXN0aW1tdGVuIHppcmt1bMOkcmVuIE1pdHRlbHdlcnRlcyBrb252ZXJ0aWVydC48L3A+XCIsXG5cdFx0dGVycmFpbkZsYXR0ZW5GdW5jdGlvbk5hbWU6IFwiVGVycmFpbi1BYnBsYXR0dW5nXCIsXG5cdFx0dGVycmFpbkZsYXR0ZW5GdW5jdGlvblNuaXA6IFwiS29ycmlnaWVydCByYWRpb21ldHJpc2NoZSBWZXJ6ZXJydW5nZW4gYXVmZ3J1bmQgZGVyIFRvcG9ncmFmaWUgaW4gZGVuIEVpbmdhYmUtU0FSLURhdGVuIChTQVIsIFN5bnRoZXRpYyBBcGVydHVyZSBSYWRhcikuXCIsXG5cdFx0dGVycmFpbkZsYXR0ZW5GdW5jdGlvbkRlc2M6IFwiPHA+RGllIFJhc3Rlci1GdW5rdGlvbiBcXFwiVGVycmFpbi1BYnBsYXR0dW5nXFxcIiBrb3JyaWdpZXJ0IHJhZGlvbWV0cmlzY2hlIFZlcnplcnJ1bmdlbiBhdWZncnVuZCBkZXIgVG9wb2dyYWZpZSBpbiBkZW4gRWluZ2FiZS1TQVItRGF0ZW4gKFNBUiwgU3ludGhldGljIEFwZXJ0dXJlIFJhZGFyKS48L3A+PHA+RGllIEVpbmdhYmVyYWRhcmRhdGVuIG3DvHNzZW4genVlcnN0IGF1ZiBCZXRhLU5vdWdodCBrYWxpYnJpZXJ0IHdlcmRlbi4gS2FsaWJyaWVyZW4gU2llIGRpZSBSYWRhcmRhdGVuIG1pdCBkZW0gV2Vya3pldWcgXFxcIlJhZGlvbWV0cmlzY2hlIEthbGlicmllcnVuZyBhbndlbmRlblxcXCIgYXVmIEJldGEtTm91Z2h0LjwvcD48cD5XZW5uIGRhcyBFaW5nYWJlLURFTSBuaWNodCBkYXMgZ2VzYW10ZSBTQVItRGF0YXNldCBhYmRlY2t0IHVuZCBlcyBzaWNoIHVtIEF1c2dhYmVuIHZvbSBUeXAgXFxcIkdhbW1hLU5vdWdodFxcXCIsIFxcXCJTaWdtYS1Ob3VnaHRcXFwiLCBcXFwiU3RyZXV1bmdzZmzDpGNoZVxcXCIgdW5kIFxcXCJHZW9tZXRyaXNjaGUgVmVyemVycnVuZ1xcXCIgaGFuZGVsdCwgZ2lidCBkYXMgV2Vya3pldWcgTm9EYXRhLVdlcnRlIGbDvHIgZGllIFBpeGVsIGF1w59lcmhhbGIgZGVyIERFTS1BdXNkZWhudW5nIGF1cy4gQmVpIEF1c2dhYmVuIHZvbSBUeXAgXFxcIkdlb21ldHJpc2NoZSBWZXJ6ZXJydW5nc21hc2tlXFxcIiBnaWJ0IGRhcyBXZXJremV1ZyBkZW4gV2VydCBcXFwiVW5iZXN0aW1tdFxcXCIgZsO8ciBQaXhlbCBhdcOfZXJoYWxiIGRlciBERU0tQXVzZGVobnVuZyBhdXMuPC9wPjxwPkRhcyBFaW5nYWJlLURFTSBtdXNzIGltIGdlb2dyYWZpc2NoZW4gS29vcmRpbmF0ZW5zeXN0ZW0gV0dTIDE5ODQgKEVQU0c6NDMyNikgdm9ybGllZ2VuLjwvcD5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uTmFtZTogXCJGYXJia29tcG9zaXRiaWxkIGVyc3RlbGxlblwiLFxuXHRcdGNyZWF0ZUNvbG9yQ29tcG9zaXRlRnVuY3Rpb25TbmlwOiBcIkVyc3RlbGx0IGVpbiBEcmVpYmFuZC1SYXN0ZXIgYXVzIGVpbmVtIE11bHRpYmFuZC1SYXN0ZXItRGF0YXNldCwgYmVpIGRlbSBqZWRlcyBCYW5kIGVpbmUgYWxnZWJyYWlzY2hlIEJlcmVjaG51bmcgdmVyd2VuZGVuIGthbm4sIGRpZSBhdWYgQmFuZGFsZ2VicmEgYmFzaWVydC5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uRGVzYzogXCI8cD5EaWUgUmFzdGVyLUZ1bmt0aW9uIFxcXCJGYXJia29tcG9zaXRiaWxkIGVyc3RlbGxlblxcXCIgZXJzdGVsbHQgZWluIERyZWliYW5kLVJhc3RlciBhdXMgZWluZW0gTXVsdGliYW5kLVJhc3Rlci1EYXRhc2V0LCBiZWkgZGVtIGplZGVzIEJhbmQgZWluZSBhbGdlYnJhaXNjaGUgQmVyZWNobnVuZyB2ZXJ3ZW5kZW4ga2FubiwgZGllIGF1ZiBCYW5kYWxnZWJyYSBiYXNpZXJ0LjwvcD48cD5CZWltIERlZmluaWVyZW4gZGVzIEFsZ29yaXRobXVzIGbDvHIgZWluZSBCYW5kYXJpdGhtZXRpayBrw7ZubmVuIFNpZSBlaW5lIGVpbnplaWxpZ2UgYWxnZWJyYWlzY2hlIEZvcm1lbCBmw7xyIGplZGVuIEF1c2RydWNrIGVpbmdlYmVuLCB1bSBlaW5lIE11bHRpYmFuZC1BdXNnYWJlIHp1IGVyc3RlbGxlbi4gVW50ZXJzdMO8dHp0IHdlcmRlbiB1bsOkcmUgT3BlcmF0b3JlbjogUGx1cyAoKyksIE1pbnVzICgtKSwgTXVsdGlwbGl6aWVyZW4gKCopIHVuZCBEaXZpZGllcmVuICgvKS48L3A+PHA+V2VubiBpbiBlaW5lbSBBdXNkcnVjayBlaW5lIEJhbmQtSUQgdmVyd2VuZGV0IHdpcmQsIGlkZW50aWZpemllcmVuIFNpZSBkYXMgQmFuZCwgaW5kZW0gU2llIGRlciBCYW5kbnVtbWVyIEIgb2RlciBiIHZvcmFuc3RlbGxlbi48L3A+PHA+RWluZSB0eXBpc2NoZSBCYW5ka29tYmluYXRpb24sIGRpZSBmw7xyIFN5bnRoZXRpYyBBcGVydHVyZSBSYWRhciAoU0FSKSBpbiBsaW5lYXJlbiBFaW5oZWl0ZW4gdmVyd2VuZGV0IHdpcmQsIGlzdCBWViBmw7xyIFJvdCwgVkggZsO8ciBHcsO8biB1bmQgVlYvVkggZsO8ciBCbGF1LiBXZW5uIGRpZSBFaW5nYWJlZGF0ZW4gaW4gRGV6aWJlbCBhbmdlZ2ViZW4gc2luZCwgc29sbHRlIGRpZSBCYW5ka29tYmluYXRpb24gVlYgZsO8ciBSb3QsIFZIIGbDvHIgR3LDvG4gdW5kIFZWLVZIIGbDvHIgQmxhdSBsYXV0ZW4uPC9wPlwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzTmFtZTogXCJPYmVyZmzDpGNoZW5wYXJhbWV0ZXJcIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc1NuaXA6IFwiTWl0IGRpZXNlciBGdW5rdGlvbiB3ZXJkZW4gbWl0aGlsZmUgdm9uIGdlb2TDpHRpc2NoZW4gTWV0aG9kZW4gUGFyYW1ldGVyIGVpbmVzIE9iZXJmbMOkY2hlbi1SYXN0ZXJzIHdpZSBBdXNyaWNodHVuZywgTmVpZ3VuZyB1bmQgdmVyc2NoaWVkZW5lIEFydGVuIHZvbiBLcsO8bW11bmdlbiBlcm1pdHRlbHQuXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNEZXNjOiBcIjxwPk1pdCBkZXIgRnVua3Rpb24gXFxcIk9iZXJmbMOkY2hlbnBhcmFtZXRlclxcXCIgd2VyZGVuIG1pdGhpbGZlIHZvbiBnZW9kw6R0aXNjaGVuIE1ldGhvZGVuIFBhcmFtZXRlciBlaW5lcyBPYmVyZmzDpGNoZW4tUmFzdGVycyB3aWUgQXVzcmljaHR1bmcsIE5laWd1bmcgdW5kIHZlcnNjaGllZGVuZSBBcnRlbiB2b24gS3LDvG1tdW5nZW4gZXJtaXR0ZWx0LjwvcD48cD5EaWVzZSBGdW5rdGlvbiBrYW5uIGbDvHIgZGllIGZvbGdlbmRlbiBBbndlbmR1bmdlbiB2ZXJ3ZW5kZXQgd2VyZGVuOjwvcD48dWw+PGxpPkJlcmVjaG5lbiBkZXIgQXVzcmljaHR1bmcgdW5kIE5laWd1bmcgbWl0aGlsZmUgdm9uIGdlb2TDpHRpc2NoZW4gTWV0aG9kZW48L2xpPjxsaT5CZXJlY2huZW4gdmVyc2NoaWVkZW5lciBBcnRlbiB2b24gS3LDvG1tdW5nZW4gYXVzIGVpbmVtIEVpbmdhYmUtT2JlcmZsw6RjaGVuLVJhc3Rlciwgei4gQi4gPHN0cm9uZz5UYW5nZW50aWFsa3LDvG1tdW5nIChOb3JtYWxrb250dXIpLCA8L3N0cm9uZz4gd29taXQgZGllIHRvcG9ncmFmaXNjaGUgS29udmVyZ2VueiB1bmQgRGl2ZXJnZW56IGVpbmVzIEZsdXNzZXMgYXVmIGRlciBPYmVyZmzDpGNoZSBiZXNjaHJpZWJlbiB3ZXJkZW4uPC9saT48L3VsPlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yTmFtZTogXCJLb3N0ZW5nw7xuc3RpZ3N0ZXIgS29ycmlkb3JcIixcblx0XHRsZWFzdENvc3RDb3JyaWRvclNuaXA6IFwiQmVyZWNobmV0IGRpZSBTdW1tZSB2b24gendlaSBha2t1bXVsYXRpdmVuIEtvc3RlbmVudGZlcm51bmdzLVJhc3Rlcm4uIERhYmVpIGJlc3RlaHQgZGllIE9wdGlvbiwgYmFzaWVyZW5kIGF1ZiBkZW0gUHJvemVudHNhdHogZGVyIE1pbmltYWxrb3N0ZW4gb2RlciBkZW4gYWtrdW11bGF0aXZlbiBLb3N0ZW4gZWluZW4gU2Nod2VsbGVud2VydCBhbnp1d2VuZGVuLlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yRGVzYzogXCI8cD5EaWUgRWluZ2FiZS1SYXN0ZXIgbcO8c3NlbiBFbnRmZXJudW5nc2Fra3VtdWxhdGlvbnMtIHVuZCBHZWdlbnJpY2h0dW5ncy1SYXN0ZXItQXVzZ2FiZW4gZGVyIEZ1bmt0aW9uIDxzdHJvbmc+RW50ZmVybnVuZ3Nha2t1bXVsYXRpb248L3N0cm9uZz4gb2RlciA8c3Ryb25nPkVudGZlcm51bmdzYWxsb2thdGlvbjwvc3Ryb25nPiBzZWluLiBTaWUgc29sbHRlbiBhdWYgZGVyIEtvc3RlbmVudGZlcm51bmcgYmFzaWVyZW4sIHVuZCBiZWltIEVyc3RlbGxlbiBkZXIgTGF5ZXIgZsO8ciBkaWUgamV3ZWlsaWdlIFF1ZWxsZSBzb2xsdGVuIGRpZXNlbGJlbiBQYXJhbWV0ZXIgdmVyd2VuZGV0IHdlcmRlbi4gQmVpbSBFcnN0ZWxsZW4gZGllc2VyIFJhc3RlciBkw7xyZmVuIGtlaW5lIFBhcmFtZXRlciB2ZXJ3ZW5kZXQgd2VyZGVuLCBkaWUgcmljaHR1bmdzYWJow6RuZ2lnIChob3Jpem9udGFsZXIgRmFrdG9yLCB2ZXJ0aWthbGVyIEZha3RvciB1bmQgUmVpc2VyaWNodHVuZykgc2luZC48L3A+PHA+RGllIFdlcnRlIGltIEF1c2dhYmUtS29ycmlkb3ItUmFzdGVyIGVudHNwcmVjaGVuIGRlciBTdW1tZSBkZXIgYWtrdW11bGF0aXZlbiBLb3N0ZW4gYmVpbSBFcnJlaWNoZW4gZWluZXIgYmVzdGltbXRlbiBQb3NpdGlvbiBtaXQgZGVuIGdsZWljaGVuIEVpbmhlaXRlbiB3aWUgZGllIEVpbmdhYmUtUmFzdGVyIGRlciBha2t1bXVsYXRpdmVuIEtvc3RlbmVudGZlcm51bmcuPC9wPjxwPldlbm4gZWluIGFuZ2VnZWJlbmVyIDxzdHJvbmc+U2Nod2VsbGVud2VydDwvc3Ryb25nPiBncsO2w59lciBpc3QgYWxzIGRpZSBtYXhpbWFsZW4gYWtrdW11bGF0aXZlbiBLb3N0ZW4gYmVpbSBTdW1taWVyZW4gZGVyIHp3ZWkgRW50ZmVybnVuZ3Nha2t1bXVsYXRpb25zLVJhc3RlciwgZGVja3QgZGFzIEF1c2dhYmUtS29ycmlkb3ItUmFzdGVyIGRpZSBnbGVpY2hlIEZsw6RjaGUgd2llIGRpZSBFaW5nYWJlLUFra3VtdWxhdGlvbnMtUmFzdGVyIGFiLjwvcD48cD5XZW5uIGVpbiBhbmdlZ2ViZW5lciBTY2h3ZWxsZW53ZXJ0IHVudGVyIGRlbSBNaW5pbWFsd2VydCBpbSBLb3JyaWRvci1SYXN0ZXIgbGllZ3QsIHdpcmQgZWluZSBXYXJubWVsZHVuZyB6dXLDvGNrZ2VnZWJlbiwgdW5kIGRhcyBBdXNnYWJlLVJhc3RlciBpc3QgbGVlci48L3A+PHA+RGFzIEF1c2dhYmUtS29ycmlkb3ItUmFzdGVyIGthbm4gWmVsbGVuIG1pdCBldHdhcyBow7ZoZXJlbiBha2t1bXVsYXRpdmVuIEtvc3RlbiBhbHMgZGVyIFNjaHdlbGxlbndlcnQgZW50aGFsdGVuLiBEaWVzZSBlbnRzdGVoZW4gZGFkdXJjaCwgZGFzcyBpbiBHZWdlbnJpY2h0dW5ncy1SYXN0ZXJuIFplbGxlbiB2ZXJ3ZW5kZXQgd2VyZGVuLCBkZW5lbiBldHdhcyBow7ZoZXJlIEtvc3RlbiB6dWdld2llc2VuIHNpbmQsIHVtIHVudmVyYnVuZGVuZSBaZWxsZW4gbWl0IGRlbSBLb3JyaWRvciB6dSB2ZXJiaW5kZW4uPC9wPlwiLFxuXHRcdGdlb21ldHJpY01lZGlhbk5hbWU6IFwiR2VvbWV0cmlzY2hlciBNZWRpYW53ZXJ0XCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuU25pcDogXCJNaXQgZGVyIEZ1bmt0aW9uIFxcXCJHZW9tZXRyaXNjaGVyIE1lZGlhbndlcnRcXFwiIHdpcmQgZGVyIGdlb21ldHJpc2NoZSBNZWRpYW53ZXJ0IGFsbGVyIFBpeGVsIGluIGVpbmVyIFplaXRzZXJpZSB2b24gTXVsdGliYW5kLUJpbGRkYXRlbiBiZXJlY2huZXQuXCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuRGVzYzogXCI8cD5NaXQgZGllc2VyIEZ1bmt0aW9uIHdlcmRlbiBSYXVzY2hlbiB1bmQgQXVzcmVpw59lciBpbiBaZWl0c2VyaWVuLUJpbGRkYXRlbiByZWR1emllcnQsIGluZGVtIGVpbiBnZW9tZXRyaXNjaGVyIE1lZGlhbnBpeGVsIGbDvHIgamVkZXMgUGl4ZWwtQXJyYXkgZGVyIEJpbGRzZXJpZSBiZXJlY2huZXQgd2lyZC4gRGVyIEFsZ29yaXRobXVzIGJlaMOkbHQgZGllIHNwZWt0cmFsZW4gQmV6aWVodW5nZW4gendpc2NoZW4gZGVuIELDpG5kZXJuIGluIGRlbiBQaXhlbHNwZWt0cmVuIGJlaSwgZGVzaGFsYiBrYW5uIGRpZSBBdXNnYWJlIGluIEFuYWx5c2VuIHZlcndlbmRldCB3ZXJkZW4gKHouwqBCLiBWZWdldGF0aW9uc2luZGl6ZXMpLjwvcD48cD5Xb2xrZW4gdW5kIFNjaGF0dGVuIHNvbGx0ZW4gbWl0IGRlbSBEYXRhc2V0LVFBLUJhbmQgbWFza2llcnQgd2VyZGVuLCBiZXZvciBkaWVzZSBGdW5rdGlvbiBhbmdld2VuZGV0IHdpcmQuPC9wPjxwPldlbm4gZXMgc2ljaCB1bSBlaW4gR2xlaXRrb21tYS1FaW5nYWJlYmlsZCBoYW5kZWx0LCBldHdhIGVpbmUgT2JlcmZsw6RjaGVucmVmbGV4aW9uIG1pdCBXZXJ0ZW4gendpc2NoZW4gMCB1bmQgMSwgd2lyZCBtaXQgZGVtIEVwc2lsb24tV2VydMKgMCwwMDEgbm9ybWFsZXJ3ZWlzZSBlaW4gZ3V0ZXMgRXJnZWJuaXMgZXJ6aWVsdC48L3A+XCJcblx0fSxcblx0cmZ4QXJnczoge1xuXHRcdHJhc3Rlck5hbWU6IFwiUmFzdGVyXCIsXG5cdFx0Y29sb3JTY2hlbWVUeXBlTmFtZTogXCJUeXAgZGVzIEZhcmJzY2hlbWFzXCIsXG5cdFx0Y29sb3JtYXBOYW1lOiBcIkNvbG9ybWFwXCIsXG5cdFx0Y29sb3JtYXBOYW1lTmFtZTogXCJDb2xvcm1hcC1OYW1lXCIsXG5cdFx0Y29sb3JSYW1wTmFtZTogXCJGYXJidmVybGF1ZlwiLFxuXHRcdGNvbnRyYXN0T2Zmc2V0TmFtZTogXCJLb250cmFzdHZlcnNhdHpcIixcblx0XHRicmlnaHRuZXNzT2Zmc2V0TmFtZTogXCJIZWxsaWdrZWl0c3ZlcnNhdHpcIixcblx0XHRtZXRob2ROYW1lOiBcIk1ldGhvZGVcIixcblx0XHRiYW5kTmFtZXNOYW1lOiBcIkJhbmRuYW1lblwiLFxuXHRcdGJhbmRXYXZlbGVuZ3Roc05hbWU6IFwiQmFuZHdlbGxlbmzDpG5nZW5cIixcblx0XHRiYW5kSWRzTmFtZTogXCJCYW5kLUlEc1wiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uTmFtZTogXCJGZWhsZW5kZSBCYW5kYWt0aW9uXCIsXG5cdFx0Y29udmVyc2lvblBhcmFtZXRlcnNOYW1lOiBcIktvbnZlcnRpZXJ1bmdzcGFyYW1ldGVyXCIsXG5cdFx0aGlsbHNoYWRlVHlwZU5hbWU6IFwiU2NodW1tZXJ1bmdzdHlwXCIsXG5cdFx0YXppbXV0aE5hbWU6IFwiQXppbXV0XCIsXG5cdFx0YWx0aXR1ZGVOYW1lOiBcIkjDtmhlXCIsXG5cdFx0c2xvcGVUeXBlTmFtZTogXCJTa2FsaWVydW5nXCIsXG5cdFx0ekZhY3Rvck5hbWU6IFwiWi1GYWt0b3JcIixcblx0XHRQU1Bvd2VyTmFtZTogXCJQaXhlbGdyw7bDn2VuLVBvdGVuelwiLFxuXHRcdFBTWkZhY3Rvck5hbWU6IFwiUGl4ZWxncsO2w59lbmZha3RvclwiLFxuXHRcdHJlbW92ZUVkZ2VFZmZlY3ROYW1lOiBcIlN0YW5kYXJkaW50ZXJwb2xhdGlvbiBmw7xyIEthbnRlbnBpeGVsIGRlYWt0aXZpZXJlblwiLFxuXHRcdGZyb21Vbml0TmFtZTogXCJBdXNnYW5nc2VpbmhlaXRcIixcblx0XHR0b1VuaXROYW1lOiBcIlppZWxlaW5oZWl0XCIsXG5cdFx0cmFzdGVyVHlwZU5hbWU6IFwiVHlwXCIsXG5cdFx0bWluTmFtZTogXCJBdXNnYWJlLU1pbmltdW1cIixcblx0XHRtYXhOYW1lOiBcIkF1c2dhYmUtTWF4aW11bVwiLFxuXHRcdG1pblBlcmNlbnROYW1lOiBcIk1pbmltYWxlciBXZXJ0IGbDvHIgXFxcIlByb3plbnR1YWwgZWluZ3JlbnplblxcXCJcIixcblx0XHRtYXhQZXJjZW50TmFtZTogXCJNYXhpbWFsZXIgV2VydCBmw7xyIFxcXCJQcm96ZW50dWFsIGVpbmdyZW56ZW5cXFwiXCIsXG5cdFx0bnVtYmVyT2ZTdGFuZGFyZERldmlhdGlvbk5hbWU6IFwiQW56YWhsIGRlciBTdGFuZGFyZGFid2VpY2h1bmdlblwiLFxuXHRcdHNpZ21vaWRTdHJlbmd0aExldmVsTmFtZTogXCJTaWdtb2lkLVN0w6Rya2VzdHVmZVwiLFxuXHRcdGVzdGltYXRlU3RhdHNIaXN0b2dyYW1OYW1lOiBcIlN0YXRpc3Rpa2VuIHNjaMOkdHplblwiLFxuXHRcdERSQU5hbWU6IFwiRHluYW1pc2NoZSBCZXJlaWNoc2FucGFzc3VuZyAoRFJBKVwiLFxuXHRcdHN0YXRpc3RpY3NOYW1lOiBcIlN0YXRpc3Rpa2VuXCIsXG5cdFx0aGlzdG9ncmFtc05hbWU6IFwiSGlzdG9ncmFtbWVcIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtTmFtZTogXCJTdGF0aXN0aWtlbiB1bmQgSGlzdG9ncmFtbSBkZWZpbmllcmVuXCIsXG5cdFx0Y29tcHV0ZUdhbW1hTmFtZTogXCJBdXRvbWF0aXNjaGUgR2FtbWFmdW5rdGlvblwiLFxuXHRcdHVzZUdhbW1hTmFtZTogXCJHYW1tYSB2ZXJ3ZW5kZW5cIixcblx0XHRnYW1tYU5hbWU6IFwiR2FtbWFcIixcblx0XHRpbnB1dE5hbWVzTmFtZTogXCJOYW1lblwiLFxuXHRcdGV4cHJlc3Npb25OYW1lOiBcIkF1c2RydWNrXCIsXG5cdFx0Y2VsbHNpemVUeXBlTmFtZTogXCJaZWxsZW5ncsO2w59lbnR5cFwiLFxuXHRcdGV4dGVudFR5cGVOYW1lOiBcIkF1c2RlaG51bmdzdHlwXCIsXG5cdFx0Y2xhc3NpZmllckRlZmluaXRpb25GaWxlTmFtZTogXCJFaW5nYWJlLURlZmluaXRpb25zZGF0ZWlcIixcblx0XHRyYXN0ZXIxTmFtZTogXCJSYXN0ZXIxXCIsXG5cdFx0cmFzdGVyMk5hbWU6IFwiUmFzdGVyMlwiLFxuXHRcdHJhc3RlcjNOYW1lOiBcIlJhc3RlcjNcIixcblx0XHR0cnVlUmFzdGVyTmFtZTogXCJUcnVlLVJhc3RlclwiLFxuXHRcdGZhbHNlUmFzdGVyTmFtZTogXCJGYWxzZS1SYXN0ZXJcIixcblx0XHRub0RhdGFJbnRlcnByZXRhdGlvbk5hbWU6IFwiTm9EYXRhLUludGVycHJldGF0aW9uXCIsXG5cdFx0bm9EYXRhVmFsdWVzTmFtZTogXCJOb0RhdGEtV2VydGVcIixcblx0XHRpbmNsdWRlZFJhbmdlc05hbWU6IFwiRWluZ2VzY2hsb3NzZW5lIEJlcmVpY2hlXCIsXG5cdFx0Y3VydmF0dXJlVHlwZU5hbWU6IFwiS3LDvG1tdW5nc3R5cFwiLFxuXHRcdHJhc3RlcnNOYW1lOiBcIlJhc3RlclwiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlTmFtZTogXCJUYWJlbGxlXCIsXG5cdFx0YXR0cmlidXRlVGFibGVUeXBlTmFtZTogXCJUYWJlbGxlbnR5cFwiLFxuXHRcdHJvd3NOYW1lOiBcIkFuemFobCBaZWlsZW5cIixcblx0XHRjb2x1bW5zTmFtZTogXCJBbnphaGwgU3BhbHRlblwiLFxuXHRcdGtlcm5lbE5hbWU6IFwiS2VybmVsXCIsXG5cdFx0bWlycm9yRWRnZXNOYW1lOiBcIkthbnRlbiBzcGllZ2VsblwiLFxuXHRcdGluZmx1ZW5jZXNOYW1lOiBcIkVpbmZsw7xzc2VcIixcblx0XHRmaWVsZHNOYW1lOiBcIkZlbGRlclwiLFxuXHRcdHJlbWFwc05hbWU6IFwiTmV1enVvcmRudW5ncy1UYWJlbGxlXCIsXG5cdFx0ZXZhbEZyb21OYW1lOiBcIkF1c3dlcnR1bmdzbWHDn3N0YWIgdm9uXCIsXG5cdFx0ZXZhbFRvTmFtZTogXCJBdXN3ZXJ0dW5nc21hw59zdGFiIGJpc1wiLFxuXHRcdHdlaWdodHNOYW1lOiBcIkdld2ljaHR1bmdlblwiLFxuXHRcdERFTU5hbWU6IFwiREVNXCIsXG5cdFx0c2hvcnRSYW5nZUlEV1JhZGl1c05hbWU6IFwiS3VyemJlcmVpY2hzcmFkaXVzIGbDvHIgSURXXCIsXG5cdFx0bWF4Vm9pZFdpZHRoTmFtZTogXCJNYXguIEzDvGNrZW5icmVpdGVcIixcblx0XHRzaWdtYUdhdXNzaWFuTmFtZTogXCJBZGFwdGl2ZSBHbMOkdHR1bmdcIixcblx0XHRjb250b3VyVHlwZU5hbWU6IFwiS29udHVybGluaWVudHlwXCIsXG5cdFx0ekJhc2VOYW1lOiBcIlotQmFzaXNcIixcblx0XHRudW1iZXJPZkNvbnRvdXJzTmFtZTogXCJBbnphaGwgZGVyIEtvbnR1cmxpbmllblwiLFxuXHRcdGNvbnRvdXJJbnRlcnZhbE5hbWU6IFwiS29udHVybGluaWVuaW50ZXJ2YWxsXCIsXG5cdFx0bnRoQ29udG91ckxpbmVJbkJvbGROYW1lOiBcIk4tdGUgS29udHVybGluaWUgZmV0dCBmb3JtYXRpZXJ0XCIsXG5cdFx0ZmVhdHVyZUNsYXNzTmFtZTogXCJFaW5nYWJlLUZlYXR1cmVzXCIsXG5cdFx0Y2xhc3NJbmRleEZpZWxkTmFtZTogXCJGZWxkXCIsXG5cdFx0cmVzb2x2ZU92ZXJsYXBNZXRob2ROYW1lOiBcIkRpZSBNZXRob2RlIFxcXCLDnGJlcmxhcHB1bmcgYXVmbMO2c2VuXFxcIlwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmFtZTogXCJSZXNhbXBsaW5nLVR5cFwiLFxuXHRcdGlucHV0Q2VsbHNpemVOYW1lOiBcIkVpbmdhYmV6ZWxsZW5ncsO2w59lXCIsXG5cdFx0b3V0cHV0Q2VsbHNpemVOYW1lOiBcIkF1c2dhYmV6ZWxsZW5ncsO2w59lXCIsXG5cdFx0cG9pbnRGZWF0dXJlQ2xhc3NOYW1lOiBcIlNjaHdlcnB1bmt0ZVwiLFxuXHRcdG1heEdyb3d0aFJhZGl1c0ZpZWxkTmFtZTogXCJGZWxkIFxcXCJNYXguIFdhY2hzdHVtc3JhZGl1c1xcXCJcIixcblx0XHRzaW1pbGFyaXR5VGhyZXNob2xkRmllbGROYW1lOiBcIkZlbGQgXFxcIsOEaG5saWNoa2VpdHNzY2h3ZWxsZW53ZXJ0XFxcIlwiLFxuXHRcdGZpbGxWYWx1ZUZpZWxkTmFtZTogXCJGw7xsbHdlcnRlZmVsZFwiLFxuXHRcdHNwZWN0cmFsRGV0YWlsTmFtZTogXCJTcGVrdHJhbGRldGFpbCBbMS4uMjBdXCIsXG5cdFx0c3BhdGlhbERldGFpbE5hbWU6IFwiUsOkdW1saWNoZXMgRGV0YWlsIFsxLi4yMF1cIixcblx0XHRtaW5OdW1QaXhlbHNQZXJTZWdtZW50TmFtZTogXCJNaW5pbWFsZSBTZWdtZW50Z3LDtsOfZSBpbiBQaXhlbFwiLFxuXHRcdGJvdW5kYXJpZXNPbmx5TmFtZTogXCJOdXIgU2VnbWVudGdyZW56ZW5cIixcblx0XHRzdGF0aXN0aWNzVHlwZU5hbWU6IFwiU3RhdGlzdGlrdHlwXCIsXG5cdFx0ZmlsbE5vRGF0YU9ubHlOYW1lOiBcIk51ciBOb0RhdGEtUGl4ZWwgZsO8bGxlblwiLFxuXHRcdGlucHV0RGF0YVR5cGVOYW1lOiBcIkVpbmdhYmVkYXRlbnR5cFwiLFxuXHRcdGFuZ2xlUmVmZXJlbmNlU3lzdGVtTmFtZTogXCJXaW5rZWxiZXp1Z3NzeXN0ZW1cIixcblx0XHRvdXRwdXREYXRhVHlwZU5hbWU6IFwiQXVzZ2FiZWRhdGVudHlwXCIsXG5cdFx0aW5wdXRTYW1wbGVQb2ludEZlYXR1cmVDbGFzc05hbWU6IFwiRWluZ2FiZWJlaXNwaWVsZVwiLFxuXHRcdHZhbHVlRmllbGROYW1lOiBcIldlcnRlZmVsZFwiLFxuXHRcdHJhc3RlckluZm9OYW1lOiBcIlJhc3Rlci1JbmZvXCIsXG5cdFx0aW50ZXJwb2xhdGlvbk1ldGhvZE5hbWU6IFwiSW50ZXJwb2xhdGlvbnNtZXRob2RlXCIsXG5cdFx0cmFkaXVzTmFtZTogXCJSYWRpdXNcIixcblx0XHRyYWRpYW5jZUdhaW5WYWx1ZXNOYW1lOiBcIlN0cmFobHVuZ3N2ZXJzdMOkcmt1bmdcIixcblx0XHRyYWRpYW5jZUJpYXNWYWx1ZXNOYW1lOiBcIlN0cmFobHVuZ3MtQmlhc1wiLFxuXHRcdHJlZmxlY3RlZEdhaW5WYWx1ZXNOYW1lOiBcIlJlZmxleGlvbnN2ZXJzdMOkcmt1bmdcIixcblx0XHRyZWZsZWN0ZWRCaWFzVmFsdWVzTmFtZTogXCJSZWZsZXhpb25zLUJpYXNcIixcblx0XHRzdW5FbGV2YXRpb25OYW1lOiBcIlNvbm5lbnN0YW5kIChHcmFkKVwiLFxuXHRcdGFsYmVkb05hbWU6IFwiQWxiZWRvXCIsXG5cdFx0c2NhbGVGYWN0b3JOYW1lOiBcIlNrYWxpZXJ1bmdzZmFrdG9yXCIsXG5cdFx0b2Zmc2V0TmFtZTogXCJWZXJzYXR6d2VydFwiLFxuXHRcdHRocmVzaG9sZFR5cGVOYW1lOiBcIlNjaHdlbGxlbndlcnR0eXBcIixcblx0XHR0aHJlc2hvbGRzTmFtZTogXCJTY2h3ZWxsZW53ZXJ0ZVwiLFxuXHRcdHVuZGVmaW5lZENsYXNzTmFtZTogXCJOaWNodCBkZWZpbmllcnRlIEtsYXNzZVwiLFxuXHRcdG1pblZhbHVlTmFtZTogXCJNaW4uXCIsXG5cdFx0bWF4VmFsdWVOYW1lOiBcIk1heC5cIixcblx0XHRvcGVyYXRpb25OYW1lOiBcIk9wZXJhdGlvblwiLFxuXHRcdGNsaXBwaW5nVHlwZU5hbWU6IFwiQXVzc2NobmVpZGV0eXBcIixcblx0XHRjbGlwcGluZ0dlb21ldHJ5TmFtZTogXCJHZW9tZXRyaWUvUmFzdGVyIHp1bSBBdXNzY2huZWlkZW5cIixcblx0XHRleHRlbnROYW1lOiBcIkF1c2dhYmVhdXNkZWhudW5nXCIsXG5cdFx0dXNlSW5wdXRGZWF0dXJlR2VvbWV0cnlOYW1lOiBcIkVpbmdhYmUtRmVhdHVyZXMgYWxzIEdlb21ldHJpZSB6dW0gQXVzc2NobmVpZGVuIHZlcndlbmRlblwiLFxuXHRcdHJlbWFwRGVmaW5pdGlvblR5cGVOYW1lOiBcIk5ldXp1b3JkbnVuZ3MtRGVmaW5pdGlvbnN0eXBcIixcblx0XHRpbnB1dFJhbmdlTmFtZTogXCJFaW5nYWJlYmVyZWljaGVcIixcblx0XHRvdXRwdXRWYWx1ZXNOYW1lOiBcIkF1c2dhYmV3ZXJ0ZVwiLFxuXHRcdG5vRGF0YVJhbmdlTmFtZTogXCJOb0RhdGEtQmVyZWljaGVcIixcblx0XHRpbnB1dEZpZWxkTmFtZTogXCJFaW5nYWJlZmVsZFwiLFxuXHRcdG91dHB1dEZpZWxkTmFtZTogXCJBdXNnYWJlZmVsZFwiLFxuXHRcdGlucHV0TWF4RmllbGROYW1lOiBcIkVpbmdhYmVmZWxkIGbDvHIgTWF4aW11bSAob3B0aW9uYWwpXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVOYW1lOiBcIk5ldXp1b3JkbnVuZ3MtVGFiZWxsZW50eXBcIixcblx0XHRhbGxvd1VubWF0Y2hlZE5hbWU6IFwiUGl4ZWx3ZXJ0ZSBvaG5lIMOcYmVyZWluc3RpbW11bmcgenVsYXNzZW5cIixcblx0XHRjaGFuZ2VNaXNzaW5nVmFsdWVzVG9Ob0RhdGFOYW1lOiBcIkZlaGxlbmRlIFdlcnRlIHp1IE5vRGF0YSDDpG5kZXJuXCIsXG5cdFx0dmlzaWJsZUJhbmRJRE5hbWU6IFwiSUQgZsO8ciBzaWNodGJhcmVzIEJhbmRcIixcblx0XHRpbmZyYXJlZEJhbmRJRE5hbWU6IFwiSUQgZsO8ciBJbmZyYXJvdGJhbmRcIixcblx0XHRzY2llbnRpZmljT3V0cHV0TmFtZTogXCJXaXNzZW5zY2hhZnRsaWNoZSBBdXNnYWJlXCIsXG5cdFx0YmFuZEluZGV4ZXNOYW1lOiBcIkJhbmRpbmRpemVzXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIktvbnN0YW50ZVwiLFxuXHRcdHdlaWdodE5hbWU6IFwiR2V3aWNodHVuZ1wiLFxuXHRcdG1pbmltdW1OYW1lOiBcIk1pbmltdW1cIixcblx0XHRtYXhpbXVtTmFtZTogXCJNYXhpbXVtXCIsXG5cdFx0c291cmNlRGF0YU5hbWU6IFwiUXVlbGwtUmFzdGVyXCIsXG5cdFx0c291cmNlRmllbGROYW1lOiBcIlF1ZWxsZmVsZFwiLFxuXHRcdGNvc3RSYXN0ZXJOYW1lOiBcIktvc3Rlbi1SYXN0ZXJcIixcblx0XHRtYXhEaXN0YW5jZU5hbWU6IFwiTWF4aW1hbGUgRW50ZmVybnVuZ1wiLFxuXHRcdHZhbHVlUmFzdGVyTmFtZTogXCJXZXJ0ZS1SYXN0ZXJcIixcblx0XHRjb3N0TXVsdGlwbGllck5hbWU6IFwiTXVsdGlwbGlrYXRvciB6dW0gQW53ZW5kZW4gYXVmIEtvc3RlblwiLFxuXHRcdHN0YXJ0Q29zdE5hbWU6IFwiU3RhcnRrb3N0ZW5cIixcblx0XHRhY2N1bUNvc3RSZXNpc3RhbmNlUmF0ZU5hbWU6IFwiQWtrdW11bGF0aXZlIEtvc3RlbnJlc2lzdGVuenJhdGVcIixcblx0XHRjYXBhY2l0eU5hbWU6IFwiS2FwYXppdMOkdFwiLFxuXHRcdHRyYXZlbERpcmVjdGlvbk5hbWU6IFwiUmVpc2VyaWNodHVuZ1wiLFxuXHRcdGNlbGxTaXplTmFtZTogXCJaZWxsZW5ncsO2w59lXCIsXG5cdFx0cG9wdWxhdGlvbkZpZWxkTmFtZTogXCJGZWxkIG1pdCBHcnVuZGdlc2FtdGhlaXRcIixcblx0XHRhcmVhVW5pdHNOYW1lOiBcIkZsw6RjaGVuZWluaGVpdGVuXCIsXG5cdFx0b3V0cHV0VmFsdWVUeXBlTmFtZTogXCJBdXNnYWJlemVsbGVud2VydGVcIixcblx0XHRiYXJyaWVyc05hbWU6IFwiRWluZ2FiZS1CYXJyaWVyZW5cIixcblx0XHRkZXN0aW5hdGlvbkRhdGFOYW1lOiBcIlppZWwtUmFzdGVyXCIsXG5cdFx0ZGVzdGluYXRpb25GaWVsZE5hbWU6IFwiWmllbGZlbGRcIixcblx0XHRwYXRoVHlwZU5hbWU6IFwiUGZhZHR5cFwiLFxuXHRcdG9ic2VydmVyRmVhdHVyZXNOYW1lOiBcIkJlb2JhY2h0ZXItRmVhdHVyZXNcIixcblx0XHRhbmFseXNpc01ldGhvZE5hbWU6IFwiQW5hbHlzZW1ldGhvZGVcIixcblx0XHRhbmFseXNpc1R5cGVOYW1lOiBcIkFuYWx5c2V0eXBcIixcblx0XHR2ZXJ0aWNhbEVycm9yTmFtZTogXCJWZXJ0aWthbGVyIEZlaGxlclwiLFxuXHRcdHJlZnJhY3Rpdml0eUNvZWZmaWNpZW50TmFtZTogXCJCcmVjaHVuZ3Nrb2VmZml6aWVudFwiLFxuXHRcdHN1cmZhY2VPZmZzZXROYW1lOiBcIk9iZXJmbMOkY2hlbnZlcnNhdHpcIixcblx0XHRvYnNlcnZlckVsZXZhdGlvbk5hbWU6IFwiQmVvYmFjaHRlcmjDtmhlXCIsXG5cdFx0b2JzZXJ2ZXJPZmZzZXROYW1lOiBcIkJlb2JhY2h0ZXJ2ZXJzYXR6XCIsXG5cdFx0aW5uZXJSYWRpdXNOYW1lOiBcIklubmVyZXIgUmFkaXVzXCIsXG5cdFx0aW5uZXJSYWRpdXNJczNERGlzdGFuY2VOYW1lOiBcIklubmVyZXIgUmFkaXVzIGlzdCAzRC1FbnRmZXJudW5nXCIsXG5cdFx0b3V0ZXJSYWRpdXNOYW1lOiBcIsOEdcOfZXJlciBSYWRpdXNcIixcblx0XHRvdXRlclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiw4R1w59lcmVyIFJhZGl1cyBpc3QgM0QtRW50ZmVybnVuZ1wiLFxuXHRcdGhvcml6b250YWxTdGFydEFuZ2xlTmFtZTogXCJIb3Jpem9udGFsZXIgQW5mYW5nc3dpbmtlbFwiLFxuXHRcdGhvcml6b250YWxFbmRBbmdsZU5hbWU6IFwiSG9yaXpvbnRhbGVyIEVuZHdpbmtlbFwiLFxuXHRcdHZlcnRpY2FsVXBwZXJBbmdsZU5hbWU6IFwiVmVydGlrYWxlciBvYmVyZXIgV2lua2VsXCIsXG5cdFx0dmVydGljYWxMb3dlckFuZ2xlTmFtZTogXCJWZXJ0aWthbGVyIHVudGVyZXIgV2lua2VsXCIsXG5cdFx0em9uZURhdGFOYW1lOiBcIlpvbmVuLVJhc3RlclwiLFxuXHRcdHpvbmVGaWVsZE5hbWU6IFwiWm9uZW5mZWxkXCIsXG5cdFx0aWdub3JlTm9EYXRhTmFtZTogXCJOb0RhdGEtV2VydGUgaW4gQmVyZWNobnVuZ2VuIGlnbm9yaWVyZW5cIixcblx0XHR0ZW1wZXJhdHVyZVJhc3Rlck5hbWU6IFwiVGVtcGVyYXR1ci1SYXN0ZXJcIixcblx0XHRpblRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlRlbXBlcmF0dXJlaW5oZWl0ZW5cIixcblx0XHRvdXRIZWF0SW5kZXhUZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJIaXR6ZWluZGV4ZWluaGVpdGVuXCIsXG5cdFx0cmVsYXRpdmVIdW1pZGl0eVJhc3Rlck5hbWU6IFwiUmFzdGVyIGbDvHIgcmVsYXRpdmUgRmV1Y2h0aWdrZWl0XCIsXG5cdFx0b3V0V2luZENoaWxsVGVtcGVyYXR1cmVVbml0c05hbWU6IFwiV2luZGNoaWxsLUVpbmhlaXRlblwiLFxuXHRcdHdpbmRTcGVlZFJhc3Rlck5hbWU6IFwiV2luZGdlc2Nod2luZGlna2VpdHMtUmFzdGVyXCIsXG5cdFx0aW5XaW5kU3BlZWRVbml0c05hbWU6IFwiV2luZGdlc2Nod2luZGlna2VpdHNlaW5oZWl0ZW5cIixcblx0XHR2YWx1ZU5hbWU6IFwiV2VydFwiLFxuXHRcdHByb3BlcnR5TmFtZTogXCJOYW1lIGRlciBFaWdlbnNjaGFmdFwiLFxuXHRcdGpzb25OYW1lOiBcIk1ldGFkYXRlbi1KU09OXCIsXG5cdFx0em9uZVRhYmxlTmFtZTogXCJUYWJlbGxlIG1pdCB6b25hbGVuIEF0dHJpYnV0ZW5cIixcblx0XHRhdHRyaWJ1dGVGaWVsZE5hbWVzOiBcIk5hbWUgZGVzIEF0dHJpYnV0ZmVsZGVzXCIsXG5cdFx0YmFja2dyb3VuZE5hbWU6IFwiSGludGVyZ3J1bmR3ZXJ0XCIsXG5cdFx0d2hlcmVDbGF1c2VOYW1lOiBcIldoZXJlLUJlZGluZ3VuZ1wiLFxuXHRcdG1pbmltdW1WYWx1ZUZpZWxkTmFtZTogXCJNaW5pbWFsd2VydC1GZWxkbmFtZVwiLFxuXHRcdG1heGltdW1WYWx1ZUZpZWxkTmFtZTogXCJNYXhpbWFsd2VydC1GZWxkbmFtZVwiLFxuXHRcdG91dFZhbHVlRmllbGROYW1lOiBcIkF1c2dhYmV3ZXJ0LUZlbGRuYW1lXCIsXG5cdFx0ZGVmYXVsdFZhbHVlTmFtZTogXCJTdGFuZGFyZC1BdXNnYWJld2VydFwiLFxuXHRcdGNvbnZlcnNpb25NYXRyaXhOYW1lOiBcIktvbnZlcnRpZXJ1bmdzbWF0cml4XCIsXG5cdFx0SXNQc2V1ZG9Db2xvck91dHB1dE5hbWU6IFwiSXN0IGVpbmUgUHNldWRvZmFyYmF1c2dhYmVcIixcblx0XHR1bm1hcHBlZEFzUmFuZG9tQ29sb3JOYW1lOiBcIk5pY2h0IHp1Z2VvcmRuZXRlbiBQaXhlbG4gbmFjaCBkZW0gWnVmYWxsc3ByaW56aXAgZWluZSBGYXJiZSB6dXdlaXNlblwiLFxuXHRcdGRpc3RhbmNlTWV0aG9kTmFtZTogXCJFbnRmZXJudW5nc21ldGhvZGVcIixcblx0XHRmbG93RGlyUmFzdGVyTmFtZTogXCJGbGllw59yaWNodHVuZ3MtUmFzdGVyXCIsXG5cdFx0cG91clBvaW50TmFtZTogXCJBYmZsdXNzcHVua3QtUmFzdGVyXCIsXG5cdFx0cG91clBvaW50RmllbGROYW1lOiBcIkFiZmx1c3NwdW5rdC1GZWxkXCIsXG5cdFx0Y29uc3RhbnRaTmFtZTogXCJaLUtvbnN0YW50ZVwiLFxuXHRcdHpPZmZzZXROYW1lOiBcIlotVmVyc2F0elwiLFxuXHRcdGdlb0lkTmFtZTogXCJHZW9pZFwiLFxuXHRcdGNhbGlicmF0aW9uVHlwZU5hbWU6IFwiS2FsaWJyaWVydW5nc3R5cFwiLFxuXHRcdGZpbHRlclR5cGVOYW1lOiBcIkZpbHRlci1UeXBcIixcblx0XHRmaWx0ZXJTaXplTmFtZTogXCJGaWx0ZXJncsO2w59lXCIsXG5cdFx0bm9pc2VNb2RlbE5hbWU6IFwiUmF1c2NobW9kZWxsXCIsXG5cdFx0bm9pc2VWYXJpYW5jZU5hbWU6IFwiUmF1c2NodmFyaWFuelwiLFxuXHRcdGFkZGl0aXZlTm9pc2VNZWFuTmFtZTogXCJBZGRpdGl2ZXMgUmF1c2NoZW4g4oCTIE1pdHRlbHdlcnRcIixcblx0XHRtdWx0aXBsaWNhdGl2ZU5vaXNlTWVhbk5hbWU6IFwiTXVsdGlwbGlrYXRpdmVzIFJhdXNjaGVuIOKAkyBNaXR0ZWx3ZXJ0XCIsXG5cdFx0bnVtYmVyb2ZMb29rc05hbWU6IFwiQW56YWhsIHZvbiBMb29rc1wiLFxuXHRcdGRhbXBpbmdGYWN0b3JOYW1lOiBcIkTDpG1wZnVuZ3NmYWt0b3JcIixcblx0XHRtYXNrUmFzdGVyTmFtZTogXCJNYXNraWVydW5ncy1SYXN0ZXJcIixcblx0XHRuaWJibGVWYWx1ZXNOYW1lOiBcIk5vRGF0YS1XZXJ0ZSB2ZXJ3ZW5kZW4sIGZhbGxzIHNpZSBkZXIgbsOkY2hzdGUgTmFjaGJhciBzaW5kXCIsXG5cdFx0bmliYmxlTm9EYXRhTmFtZTogXCJOaWJibGUgZsO8ciBOb0RhdGEtWmVsbGVuXCIsXG5cdFx0ekxpbWl0TmFtZTogXCJaLUxpbWl0XCIsXG5cdFx0Zmxvd0RpcmVjdGlvblR5cGVOYW1lOiBcIkZsaWXDn3JpY2h0dW5nc3R5cFwiLFxuXHRcdHdlaWdodFJhc3Rlck5hbWU6IFwiR2V3aWNodHVuZ3MtUmFzdGVyXCIsXG5cdFx0Zm9yY2VFZGdlTmFtZTogXCJBYmZsdXNzIHZvbiBSYW5kemVsbGVuIG5hY2ggYXXDn2VuIGVyendpbmdlblwiLFxuXHRcdHN0cmVhbVJhc3Rlck5hbWU6IFwiV2Fzc2VybGF1Zi1SYXN0ZXJcIixcblx0XHRzdXJmYWNlUmFzdGVyTmFtZTogXCJPYmVyZmzDpGNoZW4tUmFzdGVyXCIsXG5cdFx0Y29udmVyc2lvblR5cGU6IFwiVW13YW5kbHVuZ3N0eXBcIixcblx0XHRkaXN0YW5jZVJhc3RlcjE6IFwiRW50ZmVybnVuZ3MtUmFzdGVyIDFcIixcblx0XHRkaXN0YW5jZVJhc3RlcjI6IFwiRW50ZmVybnVuZ3MtUmFzdGVyIDJcIixcblx0XHRjb3N0RGlzdGFuY2VSYXN0ZXI6IFwiS29zdGVuZW50ZmVybnVuZ3MtUmFzdGVyXCIsXG5cdFx0Y29zdEJhY2tsaW5rUmFzdGVyOiBcIktvc3Rlbi1Sw7xja3Zlcmtuw7xwZnVuZ3MtUmFzdGVyXCIsXG5cdFx0b3ZlcnJpZGVzTmFtZTogXCJPdmVycmlkZXNcIixcblx0XHRmaWVsZE5hbWU6IFwiRmVsZFwiLFxuXHRcdHNpZ25hdHVyZUZpbGVPclVybDogXCJTaWduYXR1cmRhdGVpIG9kZXIgVVJMXCIsXG5cdFx0cmVkTmFtZTogXCJSb3RcIixcblx0XHRncmVlbk5hbWU6IFwiR3LDvG5cIixcblx0XHRibHVlTmFtZTogXCJCbGF1XCIsXG5cdFx0aW5mcmFyZWROYW1lOiBcIkluZnJhcm90XCIsXG5cdFx0cGFuY2hyb21hdGljTmFtZTogXCJQYW5jaHJvbWF0aXNjaFwiLFxuXHRcdG11bHRpc3BlY3RyYWxOYW1lOiBcIk11bHRpc3Bla3RyYWxcIixcblx0XHRwYW5zaGFycGVuaW5nVHlwZTogXCJQYW4tU2hhcnBlbmluZy1UeXBcIixcblx0XHRzZW5zb3JOYW1lOiBcIlNlbnNvclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VOYW1lOiBcIlJhdW1iZXp1Z1wiLFxuXHRcdHhDZWxsc2l6ZU5hbWU6IFwiWC1aZWxsZW5ncsO2w59lXCIsXG5cdFx0eUNlbGxzaXplTmFtZTogXCJZLVplbGxlbmdyw7bDn2VcIixcblx0XHR4T3JpZ2luTmFtZTogXCJYLVJlZ2lzdHJpZXJ1bmdzcHVua3RcIixcblx0XHR5T3JpZ2luTmFtZTogXCJZLVJlZ2lzdHJpZXJ1bmdzcHVua3RcIixcblx0XHRwZXJjZW50aWxlTmFtZTogXCJQZXJ6ZW50aWx3ZXJ0XCIsXG5cdFx0bmVpZ2hib3Job29kVHlwZTogXCJOYWNoYmFyc2NoYWZ0c3R5cFwiLFxuXHRcdHdpZHRoTmFtZTogXCJCcmVpdGVcIixcblx0XHRoZWlnaHROYW1lOiBcIkjDtmhlXCIsXG5cdFx0c3RhcnRBbmdsZU5hbWU6IFwiQW5mYW5nc3dpbmtlbFwiLFxuXHRcdGVuZEFuZ2xlTmFtZTogXCJFbmR3aW5rZWxcIixcblx0XHRuZWlnaGJvcmhvb2RWYWx1ZXM6IFwiTmFjaGJhcnNjaGFmdHN3ZXJ0ZVwiLFxuXHRcdGhvcml6b250YWxSYXN0ZXI6IFwiSG9yaXpvbnRhbC1SYXN0ZXJcIixcblx0XHRob3Jpem9udGFsRmFjdG9yOiBcIkhvcml6b250YWxlciBGYWt0b3JcIixcblx0XHR2ZXJ0aWNhbFJhc3RlcjogXCJWZXJ0aWthbC1SYXN0ZXJcIixcblx0XHR2ZXJ0aWNhbEZhY3RvcjogXCJWZXJ0aWthbGVyIEZha3RvclwiLFxuXHRcdHN0cmVhbVJhc3RlcjogXCJXYXNzZXJsYXVmLVJhc3RlclwiLFxuXHRcdGZsb3dEaXJSYXN0ZXI6IFwiRmxpZcOfcmljaHR1bmdzLVJhc3RlclwiLFxuXHRcdG51bWJlck5laWdoYm9yQ2VsbHM6IFwiQW56YWhsIGRlciBOYWNoYmFyemVsbGVuXCIsXG5cdFx0em9uZUNvbm5lY3Rpdml0eTogXCJab25lbmtvbm5la3Rpdml0w6R0XCIsXG5cdFx0YWRkTGlua0JlaGF2aW9yOiBcIkxpbmsgaGluenVmw7xnZW5cIixcblx0XHRleGNsdWRlZFZhbHVlOiBcIkF1c2dlc2NobG9zc2VuZXIgV2VydFwiLFxuXHRcdGNvbnN0YW50RmlsbENoZWNrOiBcIkbDvGxsLVJhc3RlciBhdXMgS29uc3RhbnRlIGVyc3RlbGxlblwiLFxuXHRcdGZpbGxSYXN0ZXI6IFwiRsO8bGwtUmFzdGVyXCIsXG5cdFx0Y29uc3RhbnRGaWxsVmFsdWU6IFwiS29uc3RhbnRlciBXZXJ0XCIsXG5cdFx0aW5wdXRCaXRQb3NpdGlvbnM6IFwiRWluZ2FiZWJpdFwiLFxuXHRcdG91dHB1dEJpdFBvc2l0aW9uczogXCJBdXNnYWJlYml0XCIsXG5cdFx0ZGlzdGFuY2VUeXBlTmFtZTogXCJFbnRmZXJudW5nc3R5cFwiLFxuXHRcdGJhcnJpZXJEYXRhTmFtZTogXCJSYXN0ZXItQmFycmllcmVuXCIsXG5cdFx0cG91clBvaW50RGF0YU5hbWU6IFwiQWJmbHVzc3B1bmt0LVJhc3RlclwiLFxuXHRcdGFjY3VtdWxhdGlvblJhc3Rlck5hbWU6IFwiQWJmbHVzc2Fra3VtdWxhdGlvbnMtUmFzdGVyXCIsXG5cdFx0c25hcERpc3RhbmNlTmFtZTogXCJGYW5nZW50ZmVybnVuZ1wiLFxuXHRcdG9yZGVyTWV0aG9kTmFtZTogXCJBbm9yZG51bmdzbWV0aG9kZVwiLFxuXHRcdGRpcmVjdGlvbk1lYXN1cmVtZW50TmFtZTogXCJNZXNzcmljaHR1bmdcIixcblx0XHRwcm9jZXNzQXNNdWx0aWJhbmQ6IFwiQWxzIE11bHRpYmFuZCB2ZXJhcmJlaXRlblwiLFxuXHRcdHByb2Nlc3NNdWx0aWRpbWVuc2lvbmFsOiBcIkFscyBtdWx0aWRpbWVuc2lvbmFsIHZlcmFyYmVpdGVuXCIsXG5cdFx0Zm9yY2VGbG93RGlyZWN0aW9uQ29udmVudGlvbjogXCJGbGllw59yaWNodHVuZ3MtS29udmVudGlvbiBmw7xyIFLDvGNrdmVya27DvHBmdW5ncy1SYXN0ZXIgZXJ6d2luZ2VuXCIsXG5cdFx0aW5pdGlhbEFjY3VtdWxhdGlvbjogXCJJbml0aWFsZSBBa2t1bXVsYXRpb25cIixcblx0XHRtYXhpbXVtQWNjdW11bGF0aW9uOiBcIk1heGltYWxlIEFra3VtdWxhdGlvblwiLFxuXHRcdHNvdXJjZUxvY2F0aW9uQmFuZHM6IFwiUXVlbGxlbnplaWxlIHVuZCAtc3BhbHRlIGFscyB6dXPDpHR6bGljaGUgQsOkbmRlciBpbiBBdXNnYWJlIGdlbmVyaWVyZW5cIixcblx0XHRiYWNrRGlyZWN0aW9uQmFuZDogXCJHZWdlbnJpY2h0dW5nIGFscyB6dXPDpHR6bGljaGVzIEJhbmQgaW4gZGVyIEF1c2dhYmUgZ2VuZXJpZXJlblwiLFxuXHRcdG51bWJlck9mQ2VsbHM6IFwiQW56YWhsIGRlciBaZWxsZW5cIixcblx0XHR6b25lVmFsdWVzOiBcIlpvbmVud2VydGVcIixcblx0XHRzaHJpbmtNZXRob2Q6IFwiVmVya2xlaW5lcnVuZ3NtZXRob2RlXCIsXG5cdFx0ZXhwYW5kTWV0aG9kOiBcIkVyd2VpdGVydW5nc21ldGhvZGVcIixcblx0XHRpbnB1dFNwZWN0cmFsUHJvZmlsZVR5cGU6IFwiU3Bla3RyYWxwcm9maWx0eXBcIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlTmFtZTogXCJTcGVrdHJhbHByb2ZpbFwiLFxuXHRcdHRyYWluaW5nRmVhdHVyZUZpbGVOYW1lOiBcIlRyYWluaW5ncy1GZWF0dXJlXCIsXG5cdFx0bm9uTmVnYXRpdmU6IFwiTmljaHQgbmVnYXRpdlwiLFxuXHRcdHN1bVRvT25lOiBcIlN1bW1lbndlcnQgMVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvbjogXCJWZXJ0ZWlsdW5nXCIsXG5cdFx0bWVhbk5hbWU6IFwiTWl0dGVsd2VydFwiLFxuXHRcdHByb2JhYmlsaXR5TmFtZTogXCJXYWhyc2NoZWlubGljaGtlaXRcIixcblx0XHRhbHBoYU5hbWU6IFwiQWxwaGFcIixcblx0XHRiZXRhTmFtZTogXCJCZXRhXCIsXG5cdFx0ck5hbWU6IFwiclwiLFxuXHRcdG5OYW1lOiBcIk5cIixcblx0XHRzZWVkOiBcIlVyc3BydW5nXCIsXG5cdFx0cmFuZG9tTnVtYmVyR2VuZXJhdG9yOiBcIlp1ZmFsbHN6YWhsZW5nZW5lcmF0b3JcIixcblx0XHRjZWxsRmFjdG9yOiBcIlplbGxlbmZha3RvclwiLFxuXHRcdGFnZ3JlZ2F0aW9uVHlwZTogXCJBZ2dyZWdpZXJ1bmdzLU1ldGhvZGVcIixcblx0XHRleHRlbnRIYW5kbGluZzogXCJBdXNkZWhudW5nIGVyd2VpdGVybiwgZmFsbHMgbsO2dGlnXCIsXG5cdFx0dHJlbmRBbmFseXNpc0RpbWVuc2lvbk5hbWU6IFwiRGltZW5zaW9uc25hbWVcIixcblx0XHR0cmVuZEFuYWx5c2lzVHlwZTogXCJUcmVuZHR5cFwiLFxuXHRcdGhhcm1vbmljRnJlcXVlbmN5OiBcIkhhcm1vbmlzY2hlIEZyZXF1ZW56XCIsXG5cdFx0cG9seW5vbWlhbE9yZGVyOiBcIlBvbHlub20tT3JkbnVuZ1wiLFxuXHRcdGN5Y2xlTGVuZ3RoTmFtZTogXCJaeWtsdXNsw6RuZ2VcIixcblx0XHR0cmVuZEFuYWx5c2lzUk1TRTogXCJSTVNFXCIsXG5cdFx0dHJlbmRBbmFseXNpc1IyOiBcIlItU3F1YXJlZFwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTbG9wZVBWYWx1ZTogXCJQLVdlcnQgZGVzIE5laWd1bmdza29lZmZpemllbnRlblwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTZWFzb25hbFBlcmlvZDogXCJTYWlzb25hbGVyIFplaXRyYXVtXCIsXG5cdFx0Y3ljbGVVbml0TmFtZTogXCJaeWtsdXNlaW5oZWl0XCIsXG5cdFx0cHJlZGljdERpbWVuc2lvblZhbHVlczogXCJXZXJ0ZVwiLFxuXHRcdGRpbWVuc2lvbkRlZmluaXRpb25UeXBlOiBcIkRpbWVuc2lvbnNkZWZpbml0aW9uXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvblN0YXJ0OiBcIkFuZmFuZ1wiLFxuXHRcdHByZWRpY3REaW1lbnNpb25FbmQ6IFwiRW5kZVwiLFxuXHRcdHByZWRpY3REaW1lbnNpb25JbnRlcnZhbDogXCJXZXJ0aW50ZXJ2YWxsXCIsXG5cdFx0ZGltZW5zaW9uVW5pdDogXCJFaW5oZWl0XCIsXG5cdFx0aW50ZXJwb2xhdGlvbkNlbGxzaXplTmFtZTogXCJaZWxsZW5ncsO2w59lIGbDvHIgZGllIEludGVycG9sYXRpb25cIixcblx0XHR2YXJpYWJsZU5hbWU6IFwiVmFyaWFibGVuXCIsXG5cdFx0ZGltZW5zaW9ubGVzc05hbWU6IFwiT2huZSBEaW1lbnNpb25lblwiLFxuXHRcdG1kaW1EZWZpbml0aW9uOiBcIkRpbWVuc2lvbnNkZWZpbml0aW9uXCIsXG5cdFx0ZGltZW5zaW9uTmFtZTogXCJEaW1lbnNpb25cIixcblx0XHRpdGVyYXRpb25TdGFydDogXCJCZWdpbm4gZGVyIGVyc3RlbiBJdGVyYXRpb25cIixcblx0XHRpdGVyYXRpb25FbmQ6IFwiRW5kZSBkZXIgZXJzdGVuIEl0ZXJhdGlvblwiLFxuXHRcdGludGVydmFsU3RhcnQ6IFwiQmVnaW5uIGRlcyBJbnRlcnZhbGxzXCIsXG5cdFx0aW50ZXJ2YWxFbmQ6IFwiRW5kZSBkZXMgSW50ZXJ2YWxsc1wiLFxuXHRcdHN0ZXBOYW1lOiBcIlNjaHJpdHRcIixcblx0XHRyYW5nZXNOYW1lOiBcIkJlcmVpY2hlXCIsXG5cdFx0bWluVmFsdWU6IFwiTWluaW11bVwiLFxuXHRcdG1heFZhbHVlOiBcIk1heGltdW1cIixcblx0XHRjaGFuZ2VBbmFseXNpc1Jhc3Rlck5hbWU6IFwiVmVyw6RuZGVydW5nc2FuYWx5c2UtUmFzdGVyXCIsXG5cdFx0Y2hhbmdlVHlwZU5hbWU6IFwiVHlwIMOkbmRlcm5cIixcblx0XHRzZWdtZW50RGF0ZTogXCJTZWdtZW50ZGF0dW1cIixcblx0XHRjaGFuZ2VEaXJlY3Rpb25OYW1lOiBcIlJpY2h0dW5nIGRlciDDhG5kZXJ1bmdcIixcblx0XHRtYXhOdW1DaGFuZ2VzTmFtZTogXCJNYXhpbWFsZSBBbnphaGwgYW4gw4RuZGVydW5nZW5cIixcblx0XHRmaWx0ZXJCeVllYXI6IFwiTmFjaCBKYWhyIGZpbHRlcm5cIixcblx0XHRtaW5pbXVtWWVhcjogXCJNaW5pbWFsd2VydFwiLFxuXHRcdG1heGltdW1ZZWFyOiBcIk1heGltYWx3ZXJ0XCIsXG5cdFx0ZmlsdGVyQnlEdXJhdGlvbjogXCJOYWNoIERhdWVyIGZpbHRlcm5cIixcblx0XHRtaW5pbXVtRHVyYXRpb246IFwiTWluaW1hbGRhdWVyXCIsXG5cdFx0bWF4aW11bUR1cmF0aW9uOiBcIk1heGltYWxkYXVlclwiLFxuXHRcdGZpbHRlckJ5TWFnbml0dWRlOiBcIk5hY2ggTWFnbml0dWRlIGZpbHRlcm5cIixcblx0XHRtaW5pbXVtTWFnbml0dWRlOiBcIk1pbmltYWxtYWduaXR1ZGVcIixcblx0XHRtYXhpbXVtTWFnbml0dWRlOiBcIk1heGltYWxtYWduaXR1ZGVcIixcblx0XHRmaWx0ZXJCeVN0YXJ0VmFsdWU6IFwiTmFjaCBTdGFydHdlcnQgZmlsdGVyblwiLFxuXHRcdG1pbmltdW1TdGFydFZhbHVlOiBcIk1pbmltYWxlciBTdGFydHdlcnRcIixcblx0XHRtYXhpbXVtU3RhcnRWYWx1ZTogXCJNYXhpbWFsZXIgU3RhcnR3ZXJ0XCIsXG5cdFx0ZmlsdGVyQnlFbmRWYWx1ZTogXCJOYWNoIEVuZHdlcnQgZmlsdGVyblwiLFxuXHRcdG1pbmltdW1FbmRWYWx1ZTogXCJNaW5pbWFsZXIgRW5kd2VydFwiLFxuXHRcdG1heGltdW1FbmRWYWx1ZTogXCJNYXhpbWFsZXIgRW5kd2VydFwiLFxuXHRcdG1vZGVsVHlwZU5hbWU6IFwiTW9kZWxsdHlwXCIsXG5cdFx0ZnJvbVJhc3Rlck5hbWU6IFwiVm9uIFJhc3RlclwiLFxuXHRcdHRvUmFzdGVyTmFtZTogXCJadSBSYXN0ZXJcIixcblx0XHRjb21wdXRlQ2hhbmdlTWV0aG9kOiBcIk1ldGhvZGUgXFxcIlZlcsOkbmRlcnVuZ2VuIGJlcmVjaG5lblxcXCJcIixcblx0XHRmcm9tQ2xhc3NWYWx1ZXM6IFwiVm9uLUtsYXNzZW53ZXJ0ZSAoQmVpc3BpZWw6IDIgNSlcIixcblx0XHR0b0NsYXNzVmFsdWVzOiBcIlp1LUtsYXNzZW53ZXJ0ZSAoQmVpc3BpZWw6IDIgNSlcIixcblx0XHRrZWVwTWV0aG9kOiBcIkZpbHRlcm1ldGhvZGVcIixcblx0XHR1c2VDb2xvck1ldGhvZDogXCJGYXJiw7xiZXJnw6RuZ2UgZGVmaW5pZXJlblwiLFxuXHRcdGRldGVjdENoYW5nZUJhbmRzOiBcIkLDpG5kZXIgZsO8ciBkaWUgRXJrZW5udW5nIHZvbiDDhG5kZXJ1bmdlbiAoYmVnaW5uZW5kIGJlaSAwKVwiLFxuXHRcdHRtYXNrQmFuZHM6IFwiQsOkbmRlciBmw7xyIHplaXRiZXpvZ2VuZSBNYXNraWVydW5nIChiZWdpbm5lbmQgYmVpIDApXCIsXG5cdFx0Y2hpU3F1YXJlZFRocmVzaG9sZDogXCJDaGktUXVhZHJhdC1TY2h3ZWxsZW53ZXJ0IGbDvHIgZGllIEVya2VubnVuZyB2b24gw4RuZGVydW5nZW5cIixcblx0XHRtaW5Bbm9tYWx5OiBcIk1pbmltdW0gZGVyIGF1ZmVpbmFuZGVyZm9sZ2VuZGVuIGJlb2JhY2h0ZXRlbiBBYndlaWNodW5nZW5cIixcblx0XHR1cGRhdGluZ0ZyZXF1ZW5jeTogXCJBbnBhc3N1bmdzaMOkdWZpZ2tlaXQgKGluIEphaHJlbikgd2lyZCBha3R1YWxpc2llcnRcIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvblJhc3Rlck5hbWU6IFwiRW50ZmVybnVuZ3Nha2t1bXVsYXRpb25zLVJhc3RlclwiLFxuXHRcdGNvc3RCYWNrZGlyZWN0aW9uUmFzdGVyTmFtZTogXCJHZWdlbnJpY2h0dW5ncy0gb2RlciBGbGllw59yaWNodHVuZ3MtUmFzdGVyXCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvbk5hbWU6IFwiUmFzdGVyLVNhbW1sdW5nXCIsXG5cdFx0aXRlbUZ1bmN0aW9uTmFtZTogXCJFbGVtZW50ZnVua3Rpb25cIixcblx0XHRhZ2dyZWdhdGlvbkZ1bmN0aW9uTmFtZTogXCJBZ2dyZWdhdGlvbnNmdW5rdGlvblwiLFxuXHRcdHByb2Nlc3NpbmdGdW5jdGlvbk5hbWU6IFwiVmVyYXJiZWl0dW5nc2Z1bmt0aW9uXCIsXG5cdFx0YWdncmVnYXRpb25EZWZpbml0aW9uTmFtZTogXCJBZ2dyZWdhdGlvbnNkZWZpbml0aW9uXCIsXG5cdFx0cXVlcnlHZW9tZXRyeU5hbWU6IFwiR2VvbWV0cmllIGFiZnJhZ2VuXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25aZXJvRmFjdG9yOiBcIk51bGwtRmFrdG9yXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25DdXRBbmdsZTogXCJTY2huaXR0d2lua2VsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TaWRlRmFjdG9yOiBcIlNlaXRlbmZha3RvclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2xvcGU6IFwiTmVpZ3VuZ1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uTG93Q3V0QW5nbGU6IFwiTmllZHJpZ2VyIFNjaG5pdHR3aW5rZWxcIixcblx0XHRmYWN0b3JGdW5jdGlvbkhpZ2hDdXRBbmdsZTogXCJIb2hlciBTY2huaXR0d2lua2VsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3NQb3dlcjogXCJLb3NpbnVzcG90ZW56XCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWNQb3dlcjogXCJTZWthbnNwb3RlbnpcIixcblx0XHRmYWN0b3JGdW5jdGlvblRhYmxlUGF0aDogXCJUYWJlbGxlbnBmYWRcIixcblx0XHRwcm9jZXNzaW5nQmFuZDogXCJWZXJhcmJlaXR1bmdzYmFuZFwiLFxuXHRcdHByb2Nlc3NpbmdCYW5kTmFtZTogXCJOYW1lIGRlcyBWZXJhcmJlaXR1bmdzYmFuZGVzXCIsXG5cdFx0c25hcHBpbmdEYXRlOiBcIkZhbmdkYXR1bVwiLFxuXHRcdG1heE51bVNlZ21lbnRzOiBcIk1heGltYWxlIEFuemFobCBhbiBTZWdtZW50ZW5cIixcblx0XHR2ZXJ0ZXhDb3VudE92ZXJzaG9vdDogXCLDnGJlcnN0YW5kIGJlaSBBbnphaGwgYW4gU3TDvHR6cHVua3RlblwiLFxuXHRcdHNwaWtlVGhyZXNob2xkOiBcIlNwaWtlLVNjaHdlbGxlbndlcnRcIixcblx0XHRyZWNvdmVyeVRocmVzaG9sZDogXCJSZWdlbmVyYXRpb25zc2Nod2VsbGVud2VydFwiLFxuXHRcdG1pbk51bU9iczogXCJNaW5kZXN0YW56YWhsIGRlciBCZW9iYWNodHVuZ2VuXCIsXG5cdFx0cFZhbHVlVGhyZXNob2xkOiBcIlNjaHdlbGxlbndlcnQgZsO8ciBwLVdlcnRlXCIsXG5cdFx0YmVzdE1vZGVsUHJvcG9ydGlvbjogXCJQcm9wb3J0aW9uIGRlcyBiZXN0ZW4gTW9kZWxsc1wiLFxuXHRcdHByZXZlbnRPbmVZZWFyUmVjb3Zlcnk6IFwiRWluasOkaHJpZ2UgUmVnZW5lcmF0aW9uIHZlcmhpbmRlcm5cIixcblx0XHRyZWNvdmVyeUluY3JlYXNlVHJlbmQ6IFwiUmVnZW5lcmF0aW9uIG1pdCB6dW5laG1lbmRlbSBUcmVuZFwiLFxuXHRcdG91dHB1dE90aGVyQmFuZHM6IFwiQW5kZXJlIELDpG5kZXIgYXVzZ2ViZW5cIixcblx0XHRzb3J0VHlwZTogXCJTb3J0aWVydHlwXCIsXG5cdFx0bnVtYmVyT2ZSdW5zOiBcIkF1c2RlaG5lbiB1bmQgVmVya2xlaW5lcm4gendlaW1hbCBkdXJjaGxhdWZlblwiLFxuXHRcdHBlcmNlbnRpbGVWYWx1ZTogXCJQZXJ6ZW50aWx3ZXJ0XCIsXG5cdFx0cGVyY2VudGlsZUludGVycG9sYXRpb25UeXBlOiBcIlBlcnplbnRpbC1JbnRlcnBvbGF0aW9uc3R5cFwiLFxuXHRcdHJhc3RlckluZm9Qcm9wZXJ0eTogXCJFaWdlbnNjaGFmdFwiLFxuXHRcdHJhc3RlckluZm9WYWx1ZTogXCJXZXJ0XCIsXG5cdFx0cmFzdGVySW5mb0NvbHVtbnM6IFwiU3BhbHRlblwiLFxuXHRcdHJhc3RlckluZm9Sb3dzOiBcIlplaWxlblwiLFxuXHRcdHJhc3RlckluZm9CYW5kQ291bnQ6IFwiQW56YWhsIGFuIELDpG5kZXJuXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsU2l6ZVg6IFwiWmVsbGVuZ3LDtsOfZSBYXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsU2l6ZVk6IFwiWmVsbGVuZ3LDtsOfZSBZXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsVHlwZTogXCJQaXhlbHR5cFwiLFxuXHRcdHJhc3RlckV4dGVudFRvcDogXCJPYmVuXCIsXG5cdFx0cmFzdGVyRXh0ZW50Qm90dG9tOiBcIlVudGVuXCIsXG5cdFx0cmFzdGVyRXh0ZW50TGVmdDogXCJMaW5rc1wiLFxuXHRcdHJhc3RlckV4dGVudFJpZ2h0OiBcIlJlY2h0c1wiLFxuXHRcdHJhc3RlclN0YXRpc3RpY3NOb3RDYWxjdWxhdGVkOiBcIlN0YXRpc3Rpa2VuIHd1cmRlbiBuaWNodCBiZXJlY2huZXQuXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVByb2plY3Rpb246IFwiUHJvamVrdGlvblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa2lkOiBcIldLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0V2tpZDogXCJWb3JoZXJpZ2UgV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa3Q6IFwiV0tUXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVZjc1draWQ6IFwiVkNTV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRlc3RWY3NXa2lkOiBcIlZvcmhlcmlnZSBWQ1NXS0lEXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUF1dGhvcml0eTogXCJadXN0w6RuZGlnZSBTdGVsbGVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGluZWFyVW5pdDogXCJMaW5lYXJlIEVpbmhlaXRcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQW5ndWxhclVuaXQ6IFwiV2lua2VsZWluaGVpdFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VGYWxzZUVhc3Rpbmc6IFwiw5ZzdGxpY2hlciBWZXJzYXR6XCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUZhbHNlTm9ydGhpbmc6IFwiTsO2cmRsaWNoZXIgVmVyc2F0elwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VDZW50cmFsTWVyaWRpYW46IFwiTWl0dGVsbWVyaWRpYW5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlUHJpbWVNZXJpZGlhbjogXCJOdWxsbWVyaWRpYW5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3RhbmRhcmRQYXJhbGxlbDE6IFwiU3RhbmRhcmRwYXJhbGxlbGUgMVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTdGFuZGFyZFBhcmFsbGVsMjogXCJTdGFuZGFyZHBhcmFsbGVsZSAyXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGl0dWRlT2ZPcmlnaW46IFwiQnJlaXRlbmdyYWQgZGVzIFVyc3BydW5nc1wiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBdXhpbGlhcnlTcGhlcmVUeXBlOiBcIkFydCBkZXIgQXV4aWxpYXJ5IFNwaGVyZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VEYXR1bTogXCJEYXR1bVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTcGhlcm9pZDogXCJTcGjDpHJvaWRcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU2VtaW1ham9yQXhpczogXCJHcm/Dn2UgSGFsYmFjaHNlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNlbWltaW5vckF4aXM6IFwiS2xlaW5lIEhhbGJhY2hzZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VJbnZlcnNlRmxhdHRlbmluZzogXCJJbnZlcnNlIEFiZmxhY2h1bmdcIixcblx0XHRpbnB1dERlZmluaXRpb25GaWxlTmFtZTogXCJFaW5nYWJlLURlZmluaXRpb25zZGF0ZWlcIixcblx0XHRkZWxldGVOYW1lOiBcIkzDtnNjaGVuXCIsXG5cdFx0YWRkVmFyaWFibGVOYW1lOiBcIlZhcmlhYmxlIGhpbnp1ZsO8Z2VuXCIsXG5cdFx0bWF4TnVtUGl4ZWxzUGVyU2VnbWVudDogXCJNYXhpbWFsZSBTZWdtZW50Z3LDtsOfZSBpbiBQaXhlbFwiLFxuXHRcdGZvcndhcmRXaW5kb3dOYW1lOiBcIlZvcnfDpHJ0c2dsZWl0ZW5kZXMgRmVuc3RlclwiLFxuXHRcdGJhY2t3YXJkV2luZG93TmFtZTogXCJSw7xja3fDpHJ0c2dsZWl0ZW5kZXMgRmVuc3RlclwiLFxuXHRcdG5vRGF0YUhhbmRsaW5nTmFtZTogXCJVbWdhbmcgbWl0IE5vRGF0YS1XZXJ0ZW5cIixcblx0XHRjaXJjdWxhcldyYXBWYWx1ZU5hbWU6IFwiVW1icnVjaHdlcnQgZsO8ciBWZXJ0ZWlsdW5nIGF1ZiBFaW5oZWl0c2tyZWlzXCIsXG5cdFx0ZnJvbUNsYXNzTmFtZUZpZWxkTmFtZTogXCJGZWxkbmFtZSBmw7xyIEtsYXNzZW5uYW1lbiBpbiBcXFwiVm9uIFJhc3RlclxcXCJcIixcblx0XHR0b0NsYXNzTmFtZUZpZWxkTmFtZTogXCJGZWxkbmFtZSBmw7xyIEtsYXNzZW5uYW1lbiBpbiBcXFwiSW4gUmFzdGVyXFxcIlwiLFxuXHRcdHRhcmdldFJhc3Rlck5hbWU6IFwiWmllbC1SYXN0ZXJcIixcblx0XHRjaXJjdWxhcldyYXBWYWx1ZTogXCJVbWJydWNod2VydCBmw7xyIFZlcnRlaWx1bmcgYXVmIEVpbmhlaXRza3JlaXNcIixcblx0XHRiYW5kSW5kZXhlc1I6IFwiUm90ZXIgQXVzZHJ1Y2tcIixcblx0XHRiYW5kSW5kZXhlc0c6IFwiR3LDvG5lciBBdXNkcnVja1wiLFxuXHRcdGJhbmRJbmRleGVzQjogXCJCbGF1ZXIgQXVzZHJ1Y2tcIixcblx0XHRleGFtcGxlTmFtZTogXCJCZWlzcGllbFwiLFxuXHRcdGlucHV0TmFtZTogXCJFaW5nYWJlXCIsXG5cdFx0b3V0cHV0TmFtZTogXCJBdXNnYWJlXCIsXG5cdFx0b3B0aW9uYWxOYW1lOiBcIk9wdGlvbmFsXCIsXG5cdFx0YnJvd3NlRGVmaW5pdGlvbkZpbGU6IFwiRGVmaW5pdGlvbnNkYXRlaSBkdXJjaHN1Y2hlblwiLFxuXHRcdHNlbGVjdERlZmluaXRpb25GaWxlOiBcIkVpbmdhYmUtRGVmaW5pdGlvbnNkYXRlaSBhdXN3w6RobGVuXCIsXG5cdFx0aW5wdXREZWZpbml0aW9uVVJMOiBcIlVSTCBkZXIgRWluZ2FiZS1EZWZpbml0aW9uc2RhdGVpXCIsXG5cdFx0ZW50ZXJEZWZpbml0aW9uRmlsZVVSTDogXCJVUkwgZGVyIERlZmluaXRpb25zZGF0ZWkgZWluZ2ViZW5cIixcblx0XHRicm93c2VYTUxGaWxlOiBcIlhNTC1EYXRlaSBkdXJjaHN1Y2hlblwiLFxuXHRcdHNlbGVjdFN0YXRzRmlsZTogXCJTdGF0aXN0aWstIHVuZCBIaXN0b2dyYW1tZGF0ZWkgYXVzd8OkaGxlblwiLFxuXHRcdGVudGVyWE1MRmlsZVVSTDogXCJVUkwgZGVyIFhNTC1EYXRlaSBlaW5nZWJlblwiLFxuXHRcdHhtbEZpbGVVUkw6IFwiVVJMIGRlciBYTUwtRGF0ZWlcIixcblx0XHRjaXJjdWxhckNhbGN1bGF0aW9uOiBcIlppcmt1bMOkcmUgU3RhdGlzdGlrZW4gYmVyZWNobmVuXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZTogXCJUeXAgZGVyIGxva2FsZW4gT2JlcmZsw6RjaGVcIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyVHlwZTogXCJQYXJhbWV0ZXJ0eXBcIixcblx0XHRuZWlnaGJvcmhvb2REaXN0YW5jZTogXCJOYWNoYmFyc2NoYWZ0c2VudGZlcm51bmdcIixcblx0XHR1c2VBZGFwdGl2ZU5laWdoYm9yaG9vZDogXCJBZGFwdGl2ZSBOYWNoYmFyc2NoYWZ0IHZlcndlbmRlblwiLFxuXHRcdG91dHB1dFNsb3BlVHlwZTogXCJNZXNzd2VydCBkZXIgQXVzZ2FiZW5laWd1bmdcIixcblx0XHRwcm9qZWN0QXppbXV0aHM6IFwiR2VvZMOkdGlzY2hlIEF6aW11dGUgcHJvaml6aWVyZW5cIixcblx0XHR1c2VFcXVhdG9yaWFsQXNwZWN0OiBcIsOEcXVhdG9yYXVzcmljaHR1bmcgdmVyd2VuZGVuXCIsXG5cdFx0elVuaXQ6IFwiWi1FaW5oZWl0XCIsXG5cdFx0YW5hbHlzaXNNYXNrOiBcIkFuYWx5c2VtYXNrZVwiLFxuXHRcdHN0ZERldmlhdGlvbjogXCJTdGFuZGFyZGFid2VpY2h1bmdcIixcblx0XHRcInRydWVcIjogXCJUcnVlXCIsXG5cdFx0XCJmYWxzZVwiOiBcIkZhbHNlXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMTogXCJFaW5nYWJlLVJhc3RlcsKgMSBmw7xyIGFra3VtdWxhdGl2ZSBLb3N0ZW5lbnRmZXJudW5nXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMjogXCJFaW5nYWJlLVJhc3RlcsKgMiBmw7xyIGFra3VtdWxhdGl2ZSBLb3N0ZW5lbnRmZXJudW5nXCIsXG5cdFx0dGhyZXNob2xkOiBcIlNjaHdlbGxlbndlcnRcIixcblx0XHR0aHJlc2hvbGRNZXRob2Q6IFwiU2Nod2VsbGVud2VydG1ldGhvZGVcIixcblx0XHRkaXJlY3Rpb25SYXN0ZXIxOiBcIkVpbmdhYmUtR2VnZW5yaWNodHVuZ3MtUmFzdGVywqAxXCIsXG5cdFx0ZGlyZWN0aW9uUmFzdGVyMjogXCJFaW5nYWJlLUdlZ2VucmljaHR1bmdzLVJhc3RlcsKgMlwiLFxuXHRcdG1heEl0ZXJhdGlvbnM6IFwiTWF4aW1hbGUgQW56YWhsIGRlciBJdGVyYXRpb25lblwiLFxuXHRcdGVwc2lsb246IFwiRXBzaWxvblwiXG5cdH0sXG5cdGVudW1MYWJlbHM6IHtcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVNYW51YWw6IFwiTWFudWVsbFwiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZUV4dGVybmFsOiBcIkV4dGVyblwiLFxuXHRcdGNsclNjaGVtZVR5cGVDb2xvcm1hcDogXCJDb2xvcm1hcFwiLFxuXHRcdGNsclNjaGVtZVR5cGVDb2xvclJhbXA6IFwiRmFyYnZlcmxhdWZcIixcblx0XHRjb2xvcm1hcFR5cGVFbGV2YXRpb246IFwiSMO2aGVuYW5nYWJlblwiLFxuXHRcdGNvbG9ybWFwVHlwZUdyYXk6IFwiR3JhdVwiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkk6IFwiTkRWSVwiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkkyOiBcIk5EVkkyXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTM6IFwiTkRWSTNcIixcblx0XHRjb2xvcm1hcFR5cGVSYW5kb206IFwiWnVmw6RsbGlnXCIsXG5cdFx0bm9uZTogXCJLZWluKGUpXCIsXG5cdFx0c2xvcGVUeXBlQWRqdXN0ZWQ6IFwiQW5nZXBhc3N0XCIsXG5cdFx0c2xvcGVUeXBlRGVncmVlOiBcIkdyYWRcIixcblx0XHRzbG9wZVR5cGVQZXJjZW50UmlzZTogXCJQcm96ZW50dWFsZXIgQW5zdGllZ1wiLFxuXHRcdHNsb3BlVHlwZVNjYWxlZDogXCJTa2FsaWVydFwiLFxuXHRcdHN0cmV0Y2hUeXBlTWluTWF4OiBcIk1pbk1heFwiLFxuXHRcdHN0cmV0Y2hUeXBlUGVyY2VudE1pbk1heDogXCJQZXJjZW50TWluTWF4XCIsXG5cdFx0c3RyZXRjaFR5cGVTaWdtb2lkOiBcIlNpZ21vaWRcIixcblx0XHRzdHJldGNoVHlwZVN0ZERldjogXCJTdGRBYndcIixcblx0XHRoaWxsc2hhZGVUeXBlU2ltcGxlOiBcIlRyYWRpdGlvbmVsbFwiLFxuXHRcdGhpbGxzaGFkZVR5cGVNdWx0aWRpcmVjdGlvbmFsOiBcIk11bHRpZGlyZWt0aW9uYWxcIixcblx0XHRiYW5kQ29tYm9CeU5hbWVzOiBcIkJhbmRuYW1lblwiLFxuXHRcdGJhbmRDb21ib0J5V2F2ZWxlbmd0aDogXCJCYW5kd2VsbGVubMOkbmdlblwiLFxuXHRcdGJhbmRDb21ib0J5SURzOiBcIkJhbmQtSURzXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25CZXN0TWF0Y2g6IFwiSMO2Y2hzdGUgw5xiZXJlaW5zdGltbXVuZ1wiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uRmFpbDogXCJGZWhsZXJcIixcblx0XHR1bml0VHlwZUNlbHNpdXM6IFwiQ2Vsc2l1c1wiLFxuXHRcdHVuaXRUeXBlQ2VudGltZXRlcnM6IFwiWmVudGltZXRlclwiLFxuXHRcdHVuaXRUeXBlRGVjaW1ldGVyczogXCJEZXppbWV0ZXJcIixcblx0XHR1bml0VHlwZUZhaHJlbmhlaXQ6IFwiRmFocmVuaGVpdFwiLFxuXHRcdHVuaXRUeXBlRmVldDogXCJGdcOfXCIsXG5cdFx0dW5pdFR5cGVGZWV0UGVyU2VjOiBcIkZ1w58gcHJvIFNla3VuZGUgKGZ0L3MpXCIsXG5cdFx0dW5pdFR5cGVJbmNoZXM6IFwiWm9sbFwiLFxuXHRcdHVuaXRUeXBlS2VsdmluOiBcIktlbHZpblwiLFxuXHRcdHVuaXRUeXBlS2lsb21ldGVyczogXCJLaWxvbWV0ZXJcIixcblx0XHR1bml0VHlwZUttc1BlckhvdXI6IFwiS2lsb21ldGVyIHBybyBTdHVuZGUgKGttL2gpXCIsXG5cdFx0dW5pdFR5cGVLbm90czogXCJLbm90ZW4gKGtuKVwiLFxuXHRcdHVuaXRUeXBlTWV0ZXJzOiBcIk1ldGVyXCIsXG5cdFx0dW5pdFR5cGVNZXRlcnNQZXJTZWM6IFwiTWV0ZXIgcHJvIFNla3VuZGUgKG0vcylcIixcblx0XHR1bml0VHlwZU1pbGVzOiBcIk1laWxlblwiLFxuXHRcdHVuaXRUeXBlTWlsZXNQZXJIb3VyOiBcIk1laWxlbiBwcm8gU3R1bmRlIChtcGgpXCIsXG5cdFx0dW5pdFR5cGVNaWxsaW1ldGVyczogXCJNaWxsaW1ldGVyXCIsXG5cdFx0dW5pdFR5cGVOYXV0aWNhbE1pbGVzOiBcIlNlZW1laWxlXCIsXG5cdFx0dW5pdFR5cGVZYXJkczogXCJZYXJkc1wiLFxuXHRcdHVuaXRUeXBlRGVjaW1hbERlZ3JlZXM6IFwiRGV6aW1hbGdyYWRcIixcblx0XHR1bml0VHlwZVBvaW50czogXCJQdW5rdGVcIixcblx0XHR1bml0VHlwZVVua25vd246IFwiVW5iZWthbm50XCIsXG5cdFx0dW5pdFR5cGVTcU1hcFVuaXRzOiBcIlF1YWRyYXQtS2FydGVuZWluaGVpdGVuXCIsXG5cdFx0dW5pdFR5cGVTcU1pbGVzOiBcIlF1YWRyYXRtZWlsZW5cIixcblx0XHR1bml0VHlwZVNxS21zOiBcIlF1YWRyYXRraWxvbWV0ZXJcIixcblx0XHR1bml0VHlwZUFjcmVzOiBcIkFjcmVzXCIsXG5cdFx0dW5pdFR5cGVIZWN0YXJlczogXCJIZWt0YXJcIixcblx0XHR1bml0VHlwZVNxWWFyZHM6IFwiUXVhZHJhdHlhcmRzXCIsXG5cdFx0dW5pdFR5cGVTcUZ0OiBcIlF1YWRyYXRmdcOfXCIsXG5cdFx0dW5pdFR5cGVTcUluY2hlczogXCJRdWFkcmF0em9sbFwiLFxuXHRcdHVuaXRUeXBlU3FNdHM6IFwiUXVhZHJhdG1ldGVyXCIsXG5cdFx0dW5pdFR5cGVTcUNtczogXCJRdWFkcmF0emVudGltZXRlclwiLFxuXHRcdHVuaXRUeXBlU3FNbXM6IFwiUXVhZHJhdG1pbGxpbWV0ZXJcIixcblx0XHRjZWxsc2l6ZVR5cGVGaXJzdDogXCJFcnN0ZShyKSB2b25cIixcblx0XHRjZWxsc2l6ZVR5cGVNaW46IFwiTWluLiB2b25cIixcblx0XHRjZWxsc2l6ZVR5cGVNYXg6IFwiTWF4LiB2b25cIixcblx0XHRjZWxsc2l6ZVR5cGVNZWFuOiBcIk1pdHRlbHdlcnQgdm9uXCIsXG5cdFx0Y2VsbHNpemVUeXBlTGFzdDogXCJMZXR6dGUocikgdm9uXCIsXG5cdFx0ZXh0ZW50VHlwZUZpcnN0OiBcIkVyc3RlKHIpIHZvblwiLFxuXHRcdGV4dGVudFR5cGVJbnRlcnNlY3Rpb246IFwiU2Nobml0dHB1bmt0IHZvblwiLFxuXHRcdGV4dGVudFR5cGVVbmlvbjogXCJWZXJlaW5pZ3VuZyB2b25cIixcblx0XHRleHRlbnRUeXBlTGFzdDogXCJMZXR6dGUocikgdm9uXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QW55OiBcIk1pdCBpcmdlbmRlaW5lbSDDvGJlcmVpbnN0aW1tZW5kXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QWxsOiBcIk1pdCBhbGxlbiDDvGJlcmVpbnN0aW1tZW5kXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVN0YW5kYXJkOiBcIlN0YW5kYXJkXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVByb2ZpbGU6IFwiUHJvZmlsXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVBsYW5mb3JtOiBcIkhvcml6b250YWxcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvbkhvcml6b250YWw6IFwiTGluaWVuZXJrZW5udW5nIGhvcml6b250YWxcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvblZlcnRpY2FsOiBcIkxpbmllbmVya2VubnVuZyB2ZXJ0aWthbFwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uTGVmdERpYWdvbmFsOiBcIkxpbmllbmVya2VubnVuZyBsaW5rcyBkaWFnb25hbFwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uUmlnaHREaWFnb25hbDogXCJMaW5pZW5lcmtlbm51bmcgcmVjaHRzIGRpYWdvbmFsXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50Tm9ydGg6IFwiR3JhZGllbnQgTm9yZFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudFdlc3Q6IFwiR3JhZGllbnQgV2VzdFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudEVhc3Q6IFwiR3JhZGllbnQgT3N0XCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50U291dGg6IFwiR3JhZGllbnQgU8O8ZFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudE5vcnRoRWFzdDogXCJHcmFkaWVudCBOb3Jkb3N0XCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50Tm9ydGhXZXN0OiBcIkdyYWRpZW50IE5vcmR3ZXN0XCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aEFyaXRobWV0aWNNZWFuOiBcIkdlZ2zDpHR0ZXRlcyBhcml0aG1ldGlzY2hlcyBNaXR0ZWxcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoaW5nM3gzOiBcIkdsw6R0dGVuIDN4M1wiLFxuXHRcdGZpbHRlclR5cGVTbW9vdGhpbmc1eDU6IFwiR2zDpHR0ZW4gNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW5pbmczeDM6IFwiU2Now6RyZmVuIDN4M1wiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuaW5nNXg1OiBcIlNjaMOkcmZlbiA1eDVcIixcblx0XHRmaWx0ZXJUeXBlTGFwbGFjaWFuM3gzOiBcIkxhcGxhY2UgM3gzXCIsXG5cdFx0ZmlsdGVyVHlwZUxhcGxhY2lhbjV4NTogXCJMYXBsYWNlIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbEhvcml6b250YWw6IFwiU29iZWwgaG9yaXpvbnRhbFwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbFZlcnRpY2FsOiBcIlNvYmVsIHZlcnRpa2FsXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW46IFwiU2Now6RyZmVuXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW4yOiBcIldlaXRlciBzY2jDpHJmZW5cIixcblx0XHRmaWx0ZXJUeXBlUG9pbnRTcHJlYWQ6IFwiUHVua3R2ZXJ0ZWlsdW5nXCIsXG5cdFx0dXNlckRlZmluZWQ6IFwiQmVudXR6ZXJkZWZpbmllcnRcIixcblx0XHRDb250b3VyVHlwZUxpbmVzOiBcIktvbnR1cmxpbmllblwiLFxuXHRcdENvbnRvdXJUeXBlRmlsbDogXCJLb250dXJsaW5pZW5mw7xsbHVuZ1wiLFxuXHRcdENvbnRvdXJUeXBlU21vb3RoT25seTogXCJOdXIgZ2xhdHRlIE9iZXJmbMOkY2hlXCIsXG5cdFx0cmFzdGVyaXplRmlyc3Q6IFwiRXJzdGVyXCIsXG5cdFx0cmFzdGVyaXplTGFzdDogXCJMZXR6dGVyXCIsXG5cdFx0cmFzdGVyaXplU21hbGxlc3Q6IFwiS2xlaW5zdGVcIixcblx0XHRyYXN0ZXJpemVMYXJnZXN0OiBcIkdyw7bDn3RlXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVOZWFyZXN0OiBcIk7DpGNoc3RlciBOYWNoYmFyXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhcjogXCJCaWxpbmVhcmUgSW50ZXJwb2xhdGlvblwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQ3ViaWM6IFwiS3ViaXNjaGUgRmFsdHVuZ1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWFqb3JpdHk6IFwiTWVocmhlaXRcIixcblx0XHRyZXNhbXBsaW5nVHlwZUJpbGluZWFyUGx1czogXCJCaWxpbmVhcmUgSW50ZXJwb2xhdGlvbiBQbHVzXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVHYXVzczogXCJHYXVzcyBCbHVyXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVHYXVzc1BsdXM6IFwiR2F1c3MgQmx1ciBQbHVzXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVBdmVyYWdlOiBcIkR1cmNoc2Nobml0dFwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWluaW11bTogXCJNaW5pbXVtXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNYXhpbXVtOiBcIk1heGltdW1cIixcblx0XHRyZXNhbXBsaW5nVHlwZVZlY3RvckF2ZzogXCJWZWt0b3JkdXJjaHNjaG5pdHRcIixcblx0XHRtaW5pbXVtOiBcIk1pbmltdW1cIixcblx0XHRtYXhpbXVtOiBcIk1heGltdW1cIixcblx0XHRtZWFuOiBcIk1pdHRlbHdlcnRcIixcblx0XHRzdGREZXZpYXRpb246IFwiU3RhbmRhcmRhYndlaWNodW5nXCIsXG5cdFx0dXZNYWdEaXJUeXBlVVY6IFwiVS1WXCIsXG5cdFx0dXZNYWdEaXJUeXBlTWFnRGlyOiBcIk1hZ25pdHVkZW4tUmljaHR1bmdcIixcblx0XHR1bmtub3duOiBcIlVuYmVrYW5udFwiLFxuXHRcdGFuZ2xlUmVmU3lzR2VvZ3JhcGhpYzogXCJHZW9ncmFwaGlzY2hcIixcblx0XHRhbmdsZVJlZlN5c0FyaXRobWV0aWM6IFwiQXJpdGhtZXRpc2NoXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmVhcmVzdDogXCJOw6RjaHN0ZXIgTmFjaGJhclwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YUJpbGluZWFyOiBcIkJpbGluZWFyXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhVGlubmluZ0xpbmVhcjogXCJMaW5lYXJlIEF1c2TDvG5udW5nXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhVGlubmluZ05hdHVyYWxOZWlnaGJvcjogXCJOYXTDvHJsaWNoZXIgTmFjaGJhclwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdJRFc6IFwiSW52ZXJzZSBEaXN0YW5jZSBXZWlnaHRlZFwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlQ29uc3RhbnQ6IFwiS29uc3RhbnRlXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVPdHN1OiBcIk90c3VcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZVRzYWk6IFwiVHNhaVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlS2FwdXI6IFwiS2FwdXJcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZUtpdHRsZXI6IFwiS2l0dGxlclwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlUm9zaW46IFwiUm9zaW5cIixcblx0XHRhcmdTdGF0c1R5cGVNYXg6IFwiQXJnLU1heGltdW1cIixcblx0XHRhcmdTdGF0c1R5cGVNaW46IFwiQXJnLU1pbmltdW1cIixcblx0XHRhcmdTdGF0c1R5cGVNZWRpYW46IFwiQXJnLU1lZGlhbndlcnRcIixcblx0XHRhcmdTdGF0c1R5cGVEdXJhdGlvbjogXCJEYXVlclwiLFxuXHRcdGFyaXRobWV0aWNPcFBsdXM6IFwiUGx1c1wiLFxuXHRcdGFyaXRobWV0aWNPcE1pbnVzOiBcIk1pbnVzXCIsXG5cdFx0YXJpdGhtZXRpY09wTXVsdGlwbHk6IFwiTXVsdGlwbGl6aWVyZW5cIixcblx0XHRhcml0aG1ldGljT3BEaXZpZGU6IFwiVGVpbGVuXCIsXG5cdFx0YXJpdGhtZXRpY09wUG93ZXI6IFwiUG90ZW56XCIsXG5cdFx0YXJpdGhtZXRpY09wTW9kZTogXCJNb2R1c1wiLFxuXHRcdGNsaXBUeXBlT3V0c2lkZTogXCJBdcOfZXJoYWxiIGF1c3NjaG5laWRlblwiLFxuXHRcdGNsaXBUeXBlSW5zaWRlOiBcIklubmVyaGFsYiBhdXNzY2huZWlkZW5cIixcblx0XHR5ZXM6IFwiSmFcIixcblx0XHRubzogXCJOZWluXCIsXG5cdFx0ZGVuc2l0aWVzOiBcIkRpY2h0ZVwiLFxuXHRcdGV4cGVjdGVkQ291bnRzOiBcIkVyd2FydGV0ZSBBbnphaGxcIixcblx0XHRwbGFuYXI6IFwiUGxhbmFyXCIsXG5cdFx0Z2VvZGVzaWM6IFwiR2VvZMOkdGlzY2hcIixcblx0XHRlYWNoQ2VsbDogXCJKZWRlIFplbGxlXCIsXG5cdFx0ZWFjaFpvbmU6IFwiSmVkZSBab25lXCIsXG5cdFx0YmVzdFNpbmdsZTogXCJEZXIgQmVzdGVcIixcblx0XHRhbGxTaWdodGxpbmVzOiBcIkFsbGUgU2ljaHRsaW5pZW5cIixcblx0XHRwZXJpbWV0ZXJTaWdodGxpbmVzOiBcIlNpY2h0bGluaWVuIGF1cyBVbWZhbmdcIixcblx0XHRmcmVxdWVuY3k6IFwiSMOkdWZpZ2tlaXQgKEZyZXF1ZW5jeSlcIixcblx0XHRvYnNlcnZlcnM6IFwiQmVvYmFjaHRlclwiLFxuXHRcdG1ham9yaXR5OiBcIk1laHJoZWl0XCIsXG5cdFx0bWVkaWFuOiBcIk1lZGlhbndlcnRcIixcblx0XHRtaW5vcml0eTogXCJNaW5kZXJoZWl0XCIsXG5cdFx0cGVyY2VudGlsZTogXCJQZXJ6ZW50aWxcIixcblx0XHRyYW5nZTogXCJCZXJlaWNoXCIsXG5cdFx0c3VtOiBcIlN1bW1lXCIsXG5cdFx0dmFyaWV0eTogXCJWYXJpYW56XCIsXG5cdFx0bmR2aTogXCJORFZJXCIsXG5cdFx0c2F2aTogXCJTQVZJXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNNZXRob2RUU0FWSTogXCJUcmFuc2Zvcm1pZXJ0ZXIgU0FWSVwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kTVNBVkk6IFwiR2XDpG5kZXJ0ZXIgU0FWSVwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kU3VsdGFuOiBcIlN1bHRhbi1Gb3JtZWxcIixcblx0XHRnZW1pOiBcIkdFTUlcIixcblx0XHRwdmk6IFwiUFZJXCIsXG5cdFx0Z3ZpOiBcIkdWSSAoTGFuZHNhdCBUTSlcIixcblx0XHR2YXJpOiBcIlZBUklcIixcblx0XHRzcjogXCJTUlwiLFxuXHRcdGduZHZpOiBcIkdORFZJXCIsXG5cdFx0bmR2aXJlOiBcIk5EVklyZVwiLFxuXHRcdHNycmU6IFwiU1JyZVwiLFxuXHRcdG10dmkyOiBcIk1UVkkyXCIsXG5cdFx0cnR2aUNvcmU6IFwiUlRWSUNvcmVcIixcblx0XHRjaXJlOiBcIkNJcmVcIixcblx0XHRjaWc6IFwiQ0lnXCIsXG5cdFx0bmR3aTogXCJORFdJXCIsXG5cdFx0ZXZpOiBcIkVWSVwiLFxuXHRcdGlyb25PeGlkZTogXCJFaXNlbm94aWRcIixcblx0XHRmZXJyb3VzTWluZXJhbHM6IFwiRWlzZW5taW5lcmFsaWVuXCIsXG5cdFx0Y2xheU1pbmVyYWxzOiBcIlRvbm1pbmVyYWxpZW5cIixcblx0XHR3bmR3aTogXCJXTkRXSVwiLFxuXHRcdGJhaTogXCJCQUlcIixcblx0XHRtbmR3aTogXCJNTkRXSVwiLFxuXHRcdG5icjogXCJOQlJcIixcblx0XHRuZGJpOiBcIk5EQklcIixcblx0XHRuZG1pOiBcIk5ETUlcIixcblx0XHRuZHNpOiBcIk5EU0lcIixcblx0XHRsb2NhbFNxdWFyZVJvb3Q6IFwiUXVhZHJhdHd1cnplbFwiLFxuXHRcdGxvY2FsQUNvczogXCJBQ29zXCIsXG5cdFx0bG9jYWxBU2luOiBcIkFTaW5cIixcblx0XHRsb2NhbEFUYW46IFwiQVRhblwiLFxuXHRcdGxvY2FsQVRhbkg6IFwiQVRhbkhcIixcblx0XHRsb2NhbEFiczogXCJBYnNcIixcblx0XHRsb2NhbEJpdHdpc2VOb3Q6IFwiQml0d2lzZSBOb3RcIixcblx0XHRsb2NhbEJvb2xlYW5Ob3Q6IFwiQm9vbGVhbiBOb3RcIixcblx0XHRsb2NhbENvczogXCJDb3NcIixcblx0XHRsb2NhbENvc0g6IFwiQ29zSFwiLFxuXHRcdGxvY2FsRXhwOiBcIkV4cFwiLFxuXHRcdGxvY2FsRXhwMTA6IFwiRXhwMTBcIixcblx0XHRsb2NhbEV4cDI6IFwiRXhwMlwiLFxuXHRcdGxvY2FsSW50OiBcIkludFwiLFxuXHRcdGxvY2FsSXNOdWxsOiBcIklzIE51bGxcIixcblx0XHRsb2NhbEZsb2F0OiBcIkZsb2F0XCIsXG5cdFx0bG9jYWxMbjogXCJMblwiLFxuXHRcdGxvY2FsTG9nMTA6IFwiTG9nMTBcIixcblx0XHRsb2NhbExvZzI6IFwiTG9nMlwiLFxuXHRcdGxvY2FsTmVnYXRlOiBcIk5lZ2F0ZVwiLFxuXHRcdGxvY2FsUm91bmREb3duOiBcIlJvdW5kIERvd25cIixcblx0XHRsb2NhbFJvdW5kVXA6IFwiUm91bmQgVXBcIixcblx0XHRsb2NhbFNpbjogXCJTaW5cIixcblx0XHRsb2NhbFNpbkg6IFwiU2luSFwiLFxuXHRcdGxvY2FsVGFuOiBcIlRhblwiLFxuXHRcdGxvY2FsVGFuSDogXCJUYW5IXCIsXG5cdFx0bG9jYWxBQ29zSDogXCJBQ29zSFwiLFxuXHRcdGxvY2FsQVNpbkg6IFwiQVNpbkhcIixcblx0XHRsb2NhbFBsdXM6IFwiUGx1c1wiLFxuXHRcdGxvY2FsTWludXM6IFwiTWludXNcIixcblx0XHRsb2NhbFRpbWVzOiBcIlRpbWVzXCIsXG5cdFx0bG9jYWxQb3dlcjogXCJQb3dlclwiLFxuXHRcdGxvY2FsQml0d2lzZUFuZDogXCJCaXR3aXNlIEFuZFwiLFxuXHRcdGxvY2FsQml0d2lzZUxlZnRTaGlmdDogXCJCaXR3aXNlIExlZnQgU2hpZnRcIixcblx0XHRsb2NhbEJpdHdpc2VPcjogXCJCaXR3aXNlIE9yXCIsXG5cdFx0bG9jYWxCaXR3aXNlUmlnaHRTaGlmdDogXCJCaXR3aXNlIFJpZ2h0IFNoaWZ0XCIsXG5cdFx0bG9jYWxCaXR3aXNlWG9yOiBcIkJpdHdpc2UgWG9yXCIsXG5cdFx0bG9jYWxCb29sZWFuQW5kOiBcIkJvb2xlYW4gQW5kXCIsXG5cdFx0bG9jYWxCb29sZWFuT3I6IFwiQm9vbGVhbiBPclwiLFxuXHRcdGxvY2FsQm9vbGVhblhvcjogXCJCb29sZWFuIFhPclwiLFxuXHRcdGxvY2FsRGl2aWRlOiBcIkRpdmlkZVwiLFxuXHRcdGxvY2FsRXF1YWxUbzogXCJFcXVhbCBUb1wiLFxuXHRcdGxvY2FsR3JlYXRlclRoYW46IFwiR3JlYXRlciBUaGFuXCIsXG5cdFx0bG9jYWxHcmVhdGVyVGhhbkVxdWFsOiBcIkdyZWF0ZXIgVGhhbiBFcXVhbFwiLFxuXHRcdGxvY2FsTGVzc1RoYW46IFwiTGVzcyBUaGFuXCIsXG5cdFx0bG9jYWxMZXNzVGhhbkVxdWFsOiBcIkxlc3MgVGhhbiBFcXVhbFwiLFxuXHRcdGxvY2FsTW9kOiBcIk1vZFwiLFxuXHRcdGxvY2FsTm90RXF1YWw6IFwiTm90IEVxdWFsXCIsXG5cdFx0bG9jYWxBVGFuMjogXCJBVGFuMlwiLFxuXHRcdGxvY2FsU3F1YXJlOiBcIlNxdWFyZVwiLFxuXHRcdGxvY2FsU2V0TnVsbDogXCJBdWYgTlVMTCBzZXR6ZW5cIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkxpc3RlXCIsXG5cdFx0cmVtYXBEZWZUeXBlVGFibGU6IFwiVGFiZWxsZVwiLFxuXHRcdHJlbWFwVGFibGVUeXBlU2ltcGxlOiBcIkVpbmZhY2hcIixcblx0XHRyZW1hcFRhYmxlVHlwZUR5bmFtaWM6IFwiRHluYW1pc2NoXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVSZWFzc2lnbm1lbnQ6IFwiTmV1enV3ZWlzdW5nXCIsXG5cdFx0Z2VvbUNvcnJlY3Rpb25CeUNvbnN0WjogXCJaLUtvbnN0YW50ZSB2ZXJ3ZW5kZW5cIixcblx0XHRnZW9tQ29ycmVjdGlvbkJ5REVNOiBcIkRFTSB2ZXJ3ZW5kZW5cIixcblx0XHRyYWRhckNhbGliQmV0YU5vdWdodDogXCJCZXRhLU5vdWdodFwiLFxuXHRcdHJhZGFyQ2FsaWJTaWdtYU5vdWdodDogXCJTaWdtYS1Ob3VnaHRcIixcblx0XHRyYWRhckNhbGliR2FtbWFOb3VnaHQ6IFwiR2FtbWEtTm91Z2h0XCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVMZWU6IFwiTGVlLUZpbHRlclwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlRW5oYW5jZWRMZWU6IFwiRXJ3ZWl0ZXJ0ZXIgTGVlLUZpbHRlclwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlRnJvc3Q6IFwiRnJvc3QtRmlsdGVyXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVLdWFuOiBcIkt1YW4tRmlsdGVyXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxNdWw6IFwiTXVsdGlwbGlrYXRpdmVzIFJhdXNjaGVuXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxBZGQ6IFwiQWRkaXRpdmVzIFJhdXNjaGVuXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxBZGRuTXVsOiBcIkFkZGl0aXZlcyB1bmQgbXVsdGlwbGlrYXRpdmVzIFJhdXNjaGVuXCIsXG5cdFx0bW9zYWljT3BUeXBlRmlyc3Q6IFwiRXJzdGUocilcIixcblx0XHRtb3NhaWNPcFR5cGVMYXN0OiBcIkxldHp0ZShyKVwiLFxuXHRcdG1vc2FpY09wVHlwZU1pbjogXCJNaW4uXCIsXG5cdFx0bW9zYWljT3BUeXBlTWF4OiBcIk1heC5cIixcblx0XHRtb3NhaWNPcFR5cGVNZWFuOiBcIk1pdHRlbHdlcnRcIixcblx0XHRtb3NhaWNPcFR5cGVCbGVuZDogXCJWZXJzY2htZWx6ZW5cIixcblx0XHRtb3NhaWNPcFR5cGVTdW06IFwiU3VtbWVcIixcblx0XHRpbnRlZ2VyOiBcIkludGVnZXJcIixcblx0XHRyZnhEODogXCJEOFwiLFxuXHRcdHJmeE1GRDogXCJNRkRcIixcblx0XHRkaW5mOiBcIkRJTkZcIixcblx0XHR2ZXJ0aWNhbDogXCJWZXJ0aWthbFwiLFxuXHRcdGhvcml6b250YWw6IFwiSG9yaXpvbnRhbFwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eTogXCJNZWhyaGVpdFwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYXg6IFwiTWF4aW11bVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWFuOiBcIk1pdHRlbHdlcnRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVkaWFuOiBcIk1lZGlhbndlcnRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWluOiBcIk1pbmltdW1cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHk6IFwiTWluZGVyaGVpdFwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NSYW5nZTogXCJCZXJlaWNoXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N0ZERldjogXCJTdGFuZGFyZGFid2VpY2h1bmdcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtOiBcIlN1bW1lXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1ZhcmlldHk6IFwiVmFyaWFuelwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eUlnbm9yZU5EOiBcIk1laHJoZWl0IChOb0RhdGEgaWdub3JpZXJlbilcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWF4SWdub3JlTkQ6IFwiTWF4aW11bSAoTm9EYXRhIGlnbm9yaWVyZW4pXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW5JZ25vcmVORDogXCJNaXR0ZWx3ZXJ0IChOb0RhdGEgaWdub3JpZXJlbilcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVkaWFuSWdub3JlTkQ6IFwiTWVkaWFud2VydCAoTm9EYXRhIGlnbm9yaWVyZW4pXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbklnbm9yZU5EOiBcIk1pbmltdW0gKE5vRGF0YSBpZ25vcmllcmVuKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5vcml0eUlnbm9yZU5EOiBcIk1pbmRlcmhlaXQgKE5vRGF0YSBpZ25vcmllcmVuKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NSYW5nZUlnbm9yZU5EOiBcIkJlcmVpY2ggKE5vRGF0YSBpZ25vcmllcmVuKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdGREZXZJZ25vcmVORDogXCJTdGFuZGFyZGFid2VpY2h1bmcgKE5vRGF0YSBpZ25vcmllcmVuKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdW1JZ25vcmVORDogXCJTdW1tZSAoTm9EYXRhIGlnbm9yaWVyZW4pXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1ZhcmlldHlJZ25vcmVORDogXCJWYXJpYW56IChOb0RhdGEgaWdub3JpZXJlbilcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVHlwZVBlcmNlbnRpbGVJZ25vcmVORDogXCJQZXJ6ZW50aWwgKE5vRGF0YSBpZ25vcmllcmVuKVwiLFxuXHRcdGZyb21Tb3VyY2U6IFwiQXVzIFF1ZWxsZVwiLFxuXHRcdHRvU291cmNlOiBcIlp1ciBRdWVsbGVcIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvblJnYlRvSHN2OiBcIlJHQiBpbiBIU1ZcIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvbkhzdlRvUmdiOiBcIkhTViBpbiBSR0JcIixcblx0XHRwYW5zaGFycGVuVHlwZUlIUzogXCJJSFNcIixcblx0XHRwYW5zaGFycGVuVHlwZUJyb3ZleTogXCJCcm92ZXlcIixcblx0XHRwYW5zaGFycGVuVHlwZUVzcmk6IFwiRXNyaVwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlTWVhbjogXCJNaXR0ZWx3ZXJ0XCIsXG5cdFx0cGFuc2hhcnBlblR5cGVHcmFtU2NobWlkdDogXCJHcmFtLVNjaG1pZHRcIixcblx0XHRyZWN0YW5nbGVOZWlnaGJvcmhvb2Q6IFwiUmVjaHRlY2tcIixcblx0XHRjaXJjbGVOZWlnaGJvcmhvb2Q6IFwiS3JlaXNcIixcblx0XHRhbm51bHVzTmVpZ2hib3Job29kOiBcIktyZWlzcmluZ1wiLFxuXHRcdHdlZGdlTmVpZ2hib3Job29kOiBcIktlaWxcIixcblx0XHRpcnJlZ3VsYXJOZWlnaGJvcmhvb2Q6IFwiVW5yZWdlbG3DpMOfaWdcIixcblx0XHR3ZWlnaHROZWlnaGJvcmhvb2Q6IFwiR2V3aWNodHVuZ1wiLFxuXHRcdGZvdXI6IFwiVmllclwiLFxuXHRcdGVpZ2h0OiBcIkFjaHRcIixcblx0XHR3aXRoaW46IFwiSW5cIixcblx0XHRjcm9zczogXCJEYXLDvGJlcmhpbmF1c1wiLFxuXHRcdGFkZExpbms6IFwiTGluayBoaW56dWbDvGdlblwiLFxuXHRcdG5vTGluazogXCJLZWluIExpbmtcIixcblx0XHR3ZWlnaHRlZE1lYW46IFwiR2V3aWNodGV0ZXIgTWl0dGVsd2VydFwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNpcnJ1czogXCJMYW5kc2F0IDggQ2lycnVzXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWQ6IFwiTGFuZHNhdCA4IENsb3VkXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWRTaGFkb3c6IFwiTGFuZHNhdCA4IENsb3VkIFNoYWRvd1wiLFxuXHRcdGxzOFFDQml0UGF0dGVybkRlc2lnbmF0ZWRGaWxsOiBcIkxhbmRzYXQgOCBEZXNpZ25hdGVkIEZpbGxcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Ecm9wcGVkRnJhbWU6IFwiTGFuZHNhdCA4IERyb3BwZWQgRnJhbWVcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Tbm93SWNlOiBcIkxhbmRzYXQgOCBTbm93L0ljZVwiLFxuXHRcdGxzOFFDQml0UGF0dGVyblRlcnJhaW5PY2NsdXNpb246IFwiTGFuZHNhdCA4IFRlcnJhaW4gT2NjbHVzaW9uXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVmVnZXRhdGlvbjogXCJMYW5kc2F0IDggVmVnZXRhdGlvblwiLFxuXHRcdGxzOFFDQml0UGF0dGVybldhdGVyOiBcIkxhbmRzYXQgOCBXYXRlclwiLFxuXHRcdGRvd25TdHJlYW06IFwiRmx1c3NhYnfDpHJ0c1wiLFxuXHRcdHVwU3RyZWFtOiBcIkZsdXNzYXVmd8OkcnRzXCIsXG5cdFx0c3RyYWhsZXI6IFwiU1RSQUhMRVJcIixcblx0XHRzaHJldmU6IFwiU0hSRVZFXCIsXG5cdFx0Y3VycmVudFNsaWNlOiBcIkFrdHVlbGxlciBBdXNzY2huaXR0XCIsXG5cdFx0YWxsU2xpY2VzOiBcIkFsbGUgQXVzc2Nobml0dGVcIixcblx0XHRleHBhbmREaXN0YW5jZTogXCJFTlRGRVJOVU5HXCIsXG5cdFx0ZXhwYW5kTW9ycGhvbG9naWNhbDogXCJNT1JQSE9MT0dJU0NIXCIsXG5cdFx0c3BlY3RyYWxQcm9maWxlRmlsZTogXCJTcGVrdHJhbHByb2ZpbFwiLFxuXHRcdHRyYWluaW5nRmVhdHVyZUZpbGU6IFwiVHJhaW5pbmdzLUZlYXR1cmVcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlVW5pZm9ybTogXCJFaW5oZWl0bGljaFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVVbmlmb3JtSW50ZWdlcjogXCJJbnRlZ2VyXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZU5vcm1hbDogXCJOb3JtYWxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlRXhwb25lbnRpYWw6IFwiRXhwb25lbnRpYWxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlUG9pc3NvbjogXCJQb2lzc29uXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUdhbW1hOiBcIkdhbW1hXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUJpbm9taWFsOiBcIkJpbm9taWFsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUdlb21ldHJpYzogXCJHZW9tZXRyaXNjaFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVOZWdhdGl2ZUJpbm9taWFsOiBcIk5lZ2F0aXYgYmlub21pYWxcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlU3RhbmRhcmRDUmFuZDogXCJTdGFuZGFyZCBDIFJhbmRcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlQWxnb3JpdGhtQUNNNTk5OiBcIkFDTTU5OSDigJMgU2FtbWVsYWxnb3JpdGhtdXNcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlTWVyc2VubmVUd2lzdGVyOiBcIk1lcnNlbm5lIFR3aXN0ZXJcIixcblx0XHRzdW1OYW1lOiBcIlN1bW1lXCIsXG5cdFx0bWVkYWluTmFtZTogXCJNZWRpYW53ZXJ0XCIsXG5cdFx0dHJlbmRMaW5lYXI6IFwiTGluZWFyXCIsXG5cdFx0dHJlbmRIYXJtb25pYzogXCJIYXJtb25pc2NoXCIsXG5cdFx0dHJlbmRQb2x5bm9taWFsOiBcIlBvbHlub21pYWxcIixcblx0XHR0cmVuZE1hbm5LZW5kYWxsOiBcIk1hbm4tS2VuZGFsbC1UZXN0XCIsXG5cdFx0dHJlbmRTZWFzb25hbEtlbmRhbGw6IFwiU2Fpc29uYWxlciBLZW5kYWxsLVRlc3RcIixcblx0XHRkaW1lbnNpb25CeVZhbHVlOiBcIk5hY2ggV2VydFwiLFxuXHRcdGRpbWVuc2lvbkJ5SW50ZXJ2YWw6IFwiTmFjaCBJbnRlcnZhbGxcIixcblx0XHRtZGltRGVmVHlwZUFsbDogXCJBbGxlXCIsXG5cdFx0bWRpbURlZlR5cGVCeVZhbHVlczogXCJEdXJjaCBXZXJ0ZVwiLFxuXHRcdG1kaW1EZWZUeXBlQnlSYW5nZXM6IFwiTmFjaCBCZXJlaWNoZW5cIixcblx0XHRtZGltRGVmVHlwZUJ5SXRlcmF0aW9uOiBcIk5hY2ggSXRlcmF0aW9uXCIsXG5cdFx0bWRpbURlZlR5cGVCeUludGVydmFsOiBcIk5hY2ggSW50ZXJ2YWxsXCIsXG5cdFx0bWRpbURlZlR5cGVCeVRhcmdldFJhc3RlcjogXCJOYWNoIFppZWwtUmFzdGVyXCIsXG5cdFx0ZXNyaVRpbWVVbml0c0hvdXJzOiBcIlN0dW5kZW5cIixcblx0XHRlc3JpVGltZVVuaXRzRGF5czogXCJUYWdlXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1dlZWtzOiBcIldvY2hlblwiLFxuXHRcdGVzcmlUaW1lVW5pdHNNb250aHM6IFwiTW9uYXRlXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1llYXJzOiBcIkphaHJlXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRIb3VybHk6IFwiU3TDvG5kbGljaFwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkRGFpbHk6IFwiVMOkZ2xpY2hcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFdlZWtseTogXCJXw7ZjaGVudGxpY2hcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZERla2FkbHk6IFwiMTAgVGFnZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUGVudGFkbHk6IFwiNSBUYWdlXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRNb250aGx5OiBcIk1vbmF0bGljaFwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUXVhcnRlcmx5OiBcIlZpZXJ0ZWxqw6RocmxpY2hcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFllYXJseTogXCJKw6RocmxpY2hcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ0RhaWx5OiBcIlTDpGdsaWNoIHdpZWRlcmtlaHJlbmRcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1dlZWtseTogXCJXw7ZjaGVudGxpY2ggd2llZGVya2VocmVuZFwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nTW9udGhseTogXCJNb25hdGxpY2ggd2llZGVya2VocmVuZFwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nUXVhcnRlcmx5OiBcIlF1YXJ0YWxzd2Vpc2Ugd2llZGVya2VocmVuZFwiLFxuXHRcdGFnZ0RlZlR5cGVBbGw6IFwiQWxsZVwiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbEtleXdvcmQ6IFwiSW50ZXJ2YWxsc2NobMO8c3NlbHdvcnRcIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxWYWx1ZTogXCJJbnRlcnZhbGx3ZXJ0XCIsXG5cdFx0YWdnRGVmVHlwZUludGVydmFsUmFuZ2VzOiBcIkludGVydmFsbGJlcmVpY2hlXCIsXG5cdFx0bGF0ZXN0Q2hhbmdlOiBcIlplaXQgZGVyIGxldHp0ZW4gw4RuZGVydW5nXCIsXG5cdFx0ZWFybGllc3RDaGFuZ2U6IFwiWmVpdCBkZXIgZXJzdGVuIMOEbmRlcnVuZ1wiLFxuXHRcdGxhcmdlc3RDaGFuZ2U6IFwiWmVpdCBkZXIgZ3LDtsOfdGVuIMOEbmRlcnVuZ1wiLFxuXHRcdG51bWJlck9mQ2hhbmdlczogXCJBbnphaGwgYW4gw4RuZGVydW5nZW5cIixcblx0XHRsb25nZXN0Q2hhbmdlOiBcIlplaXQgZGVyIGzDpG5nc3RlbiDDhG5kZXJ1bmdcIixcblx0XHRzaG9ydGVzdENoYW5nZTogXCJaZWl0IGRlciBrw7xyemVzdGVuIMOEbmRlcnVuZ1wiLFxuXHRcdGZhc3Rlc3RDaGFuZ2U6IFwiWmVpdCBkZXIgc2NobmVsbHN0ZW4gw4RuZGVydW5nXCIsXG5cdFx0c2xvd2VzdENoYW5nZTogXCJaZWl0IGRlciBsYW5nc2Ftc3RlbiDDhG5kZXJ1bmdcIixcblx0XHRhbGxDaGFuZ2VzOiBcIkFsbGVcIixcblx0XHRpbmNyZWFzZUNoYW5nZXM6IFwiWnVuYWhtZVwiLFxuXHRcdGRlY3JlYXNlQ2hhbmdlczogXCJBYm5haG1lXCIsXG5cdFx0c2VnbWVudEJlZ2lubmluZzogXCJBbmZhbmcgZGVzIFNlZ21lbnRzXCIsXG5cdFx0c2VnbWVudEVuZDogXCJFbmRlIGRlcyBTZWdtZW50c1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kRGlmZmVyZW5jZTogXCJEaWZmZXJlbnpcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZFJlbGF0aXZlRGlmZmVyZW5jZTogXCJSZWxhdGl2ZXIgVW50ZXJzY2hpZWRcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZENhdGVnb3JpY2FsOiBcIkthdGVnb3Jpc2NoZXIgVW50ZXJzY2hpZWRcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxFdWNsaWRlYW5EaXN0YW5jZTogXCJTcGVrdHJhbGUgZXVrbGlkaXNjaGUgRW50ZmVybnVuZ1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEFuZ3VsYXJEaWZmZXJlbmNlOiBcIlNwZWt0cmFsZSBXaW5rZWxkaWZmZXJlbnpcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBeGlzV2l0aEJpZ2dlc3RDaGFuZ2U6IFwiQmFuZCBtaXQgZ3LDtsOfdGVyIFZlcsOkbmRlcnVuZ1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcEFsbDogXCJBbGxlIGJlaWJlaGFsdGVuXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwQ2hhbmdlZE9ubHk6IFwiTnVyIGdlw6RuZGVydGUgUGl4ZWwgYmVpYmVoYWx0ZW5cIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBVbmNoYW5nZWRPbmx5OiBcIk51ciBuaWNodCBnZcOkbmRlcnRlIFBpeGVsIGJlaWJlaGFsdGVuXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VVc2VDb2xvckF2ZXJhZ2U6IFwiVm9uLVp1LUZhcmJlbiBmw7xyIER1cmNoc2Nobml0dFwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JGcm9tOiBcIlZvbi1GYXJiZW4gdmVyd2VuZGVuXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VVc2VDb2xvclRvOiBcIlp1LUZhcmJlbiB2ZXJ3ZW5kZW5cIixcblx0XHRmYWN0b3JGdW5jdGlvbkJpbmFyeTogXCJCaW7DpHJcIixcblx0XHRmYWN0b3JGdW5jdGlvbkZvcndhcmQ6IFwiVm9yd8OkcnRzXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25MaW5lYXI6IFwiTGluZWFyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25JbnZMaW5lYXI6IFwiSW52ZXJzIGxpbmVhclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uVGFibGU6IFwiVGFiZWxsZVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU3ltTGluZWFyOiBcIlN5bW1ldHJpc2NoIGxpbmVhclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU3ltSW52TGluZWFyOiBcIlN5bW1ldHJpc2NoIGludmVycyBsaW5lYXJcIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvczogXCJLb3NpbnVzXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWM6IFwiU2VrYW5zXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3NTZWM6IFwiS29zaW51cyBTZWthbnNcIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY0NvczogXCJTZWthbnMgS29zaW51c1wiLFxuXHRcdG5vU29ydDogXCJOaWNodCBzb3J0aWVyZW5cIixcblx0XHRhc2NlbmQ6IFwiQXVmc3RlaWdlbmRcIixcblx0XHRkZXNjZW5kOiBcIkFic3RlaWdlbmRcIixcblx0XHRhdXRvRGV0ZWN0OiBcIkF1dG9tYXRpc2NoIGVya2VubmVuXCIsXG5cdFx0bmVhcmVzdDogXCJOw6RjaHN0ZXJcIixcblx0XHRsaW5lYXI6IFwiTGluZWFyXCIsXG5cdFx0ZXNyaU1vbnRoSmFudWFyeTogXCJKYW51YXJcIixcblx0XHRlc3JpTW9udGhGZWJydWFyeTogXCJGZWJydWFyXCIsXG5cdFx0ZXNyaU1vbnRoTWFyY2g6IFwiTcOkcnpcIixcblx0XHRlc3JpTW9udGhBcHJpbDogXCJBcHJpbFwiLFxuXHRcdGVzcmlNb250aE1heTogXCJNYWlcIixcblx0XHRlc3JpTW9udGhKdW5lOiBcIkp1bmlcIixcblx0XHRlc3JpTW9udGhKdWx5OiBcIkp1bGlcIixcblx0XHRlc3JpTW9udGhBdWd1c3Q6IFwiQXVndXN0XCIsXG5cdFx0ZXNyaU1vbnRoU2VwdGVtYmVyOiBcIlNlcHRlbWJlclwiLFxuXHRcdGVzcmlNb250aE9jdG9iZXI6IFwiT2t0b2JlclwiLFxuXHRcdGVzcmlNb250aE5vdmVtYmVyOiBcIk5vdmVtYmVyXCIsXG5cdFx0ZXNyaU1vbnRoRGVjZW1iZXI6IFwiRGV6ZW1iZXJcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ0lnbm9yZU5vRGF0YTogXCJEYXRlblwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nUHJvcGFnYXRlTm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nRmlsbE9ubHlOb0RhdGE6IFwiTm9EYXRhLVdlcnRlIGbDvGxsZW5cIixcblx0XHRjaXJjdWxhck1lYW46IFwiWmlya3Vsw6RyZXIgTWl0dGVsd2VydFwiLFxuXHRcdGNpcmN1bGFyTmFtZTogXCJLcmVpc2bDtnJtaWdcIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0aG1ldGlzY2hcIixcblx0XHRzbG9wZU5hbWU6IFwiTmVpZ3VuZ1wiLFxuXHRcdGFzcGVjdE5hbWU6IFwiQXVzcmljaHR1bmdcIixcblx0XHRtZWFuQ3VydmF0dXJlOiBcIk1pdHRsZXJlIEtyw7xtbXVuZ1wiLFxuXHRcdHByb2ZpbGVDdXJ2YXR1cmU6IFwiUHJvZmlsa3LDvG1tdW5nIChOb3JtYWxuZWlndW5nc2xpbmllKVwiLFxuXHRcdHRhbmdlbnRpYWxDdXJ2YXR1cmU6IFwiVGFuZ2VudGlhbGtyw7xtbXVuZyAoTm9ybWFsa29udHVyKVwiLFxuXHRcdHBsYW5DdXJ2YXR1cmU6IFwiUGxhbmtyw7xtbXVuZyAocHJvaml6aWVydGUgS29udHVyKVwiLFxuXHRcdGNvbnRvdXJHZW9kZXNpY1RvcnNpb246IFwiR2VvZMOkdGlzY2hlIFRvcnNpb24gZGVyIEtvbnR1clwiLFxuXHRcdGdhdXNzaWFuQ3VydmF0dXJlOiBcIkdhdcOfJ3NjaGUgS3LDvG1tdW5nXCIsXG5cdFx0Y2Fzb3JhdGlDdXJ2YXR1cmU6IFwiQ2Fzb3JhdGktS3LDvG1tdW5nXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZVF1YWRyYXRpYzogXCJRdWFkcmF0aXNjaFwiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGVCaXF1YWRyYXRpYzogXCJCaXF1YWRyYXRpc2NoXCIsXG5cdFx0dGhyZXNob2xkTm9UaHJlc2hvbGQ6IFwiS2VpbiBTY2h3ZWxsZW53ZXJ0XCIsXG5cdFx0dGhyZXNob2xkUGVyY2VudExlYXN0Q29zdDogXCJQcm96ZW50c2F0eiBkZXIgZ2VyaW5nc3RlbiBLb3N0ZW5cIixcblx0XHR0aHJlc2hvbGRBY2N1bXVsYXRpdmVDb3N0OiBcIkFra3VtdWxhdGl2ZSBLb3N0ZW5cIixcblx0XHRjbHJtYXBUeXBlSGlsbHNoYWRlOiBcIlNjaHVtbWVydW5nXCJcblx0fSxcblx0Y2F0ZWdvcnlMYWJlbHM6IHtcblx0XHRzb3VyY2VDaGFyYWN0ZXJpc3RpY3M6IFwiUXVlbGxlbmVpZ2Vuc2NoYWZ0ZW5cIixcblx0XHRuZWlnaGJvcmhvb2RTZXR0aW5nczogXCJOYWNoYmFyc2NoYWZ0c2VpbnN0ZWxsdW5nZW5cIixcblx0XHRzdGF0aXN0aWNzOiBcIlN0YXRpc3Rpa2VuXCIsXG5cdFx0Z2FtbWE6IFwiR2FtbWFcIixcblx0XHR2aWV3c2hlZFBhcmFtZXRlcnM6IFwiU2ljaHRmZWxkcGFyYW1ldGVyXCIsXG5cdFx0b2JzZXJ2ZXJQYXJhbWV0ZXJzOiBcIkJlb2JhY2h0ZXJwYXJhbWV0ZXJcIixcblx0XHRpcnJlZ3VsYXJEYXRhSW50ZXJwb2xhdGlvbjogXCJVbnJlZ2VsbcOkw59pZ2UgRGF0ZW5pbnRlcnBvbGF0aW9uXCIsXG5cdFx0bW9kZWxTdGF0aXN0aWNzOiBcIk1vZGVsbHN0YXRpc3Rpa2VuXCIsXG5cdFx0YWdncmVnYXRpb25EZWY6IFwiQWdncmVnYXRpb25zZGVmaW5pdGlvblwiLFxuXHRcdGZpbHRlckJ5QXR0cmlidXRlczogXCJOYWNoIEF0dHJpYnV0ZW4gZmlsdGVyblwiLFxuXHRcdHBlcmNlbnRpbGVOYW1lOiBcIlBlcnplbnRpbFwiLFxuXHRcdHJhc3RlckluZm86IFwiUmFzdGVyLUluZm9ybWF0aW9uXCIsXG5cdFx0ZXh0ZW50OiBcIkF1c2RlaG51bmdcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlOiBcIlJhdW1iZXp1Z1wiXG5cdH0sXG5cdG91dHB1dFJhc3RlckhlbHBUZXh0czoge1xuXHRcdG91dHB1dE5hbWU6IFwiPHA+RGVyIE5hbWUgZGVzIExheWVycywgZGVyIGVyc3RlbGx0IHVuZCBkZXIgS2FydGUgaGluenVnZWbDvGd0IHdpcmQuPC9wPlwiLFxuXHRcdHJlc3VsdFR5cGU6IFwiPHA+RGllIEFydCBkZXIgQXVzZ2FiZSwgZGllIGVyc3RlbGx0IHdpcmQuIERpZSBBdXNnYWJlbiBrw7ZubmVuIGdla2FjaGVsdGUgQmlsZGRhdGVuLUxheWVyIG9kZXIgZHluYW1pc2NoZSBCaWxkZGF0ZW4tTGF5ZXIgc2Vpbi48L3A+XCIsXG5cdFx0c2F2ZVJlc3VsdEluOiBcIjxwPkRlciBOYW1lIGRlcyBPcmRuZXJzIGluIDxiPkVpZ2VuZSBJbmhhbHRlPC9iPiwgaW4gZGVtIGRhcyBFcmdlYm5pcyBnZXNwZWljaGVydCB3ZXJkZW4gc29sbC48L3A+XCJcblx0fSxcblx0YW5hbHlzaXNFbnZpcm9ubWVudHNIZWxwVGV4dHM6IHtcblx0XHRkZXNjcmlwdGlvbjogXCI8cD5VbWdlYnVuZ3NlaW5zdGVsbHVuZ2VuIGbDvHIgQW5hbHlzZW4gaW4gTWFwIFZpZXdlci4gPC9wPlwiLFxuXHRcdG91dFNSOiBcIjxwPkxlZ3QgZGFzIEtvb3JkaW5hdGVuc3lzdGVtIGbDvHIgZGllIEFuYWx5c2UgdW5kIGRlbiBFcmdlYm5pcy1MYXllciBmZXN0LjwvcD5cIixcblx0XHRleHRlbnQ6IFwiPHA+R2lidCBkZW4gQmVyZWljaCBhbiwgZGVyIGbDvHIgZGllIEFuYWx5c2UgdmVyd2VuZGV0IHdlcmRlbiBzb2xsLjwvcD5cIixcblx0XHRzbmFwUmFzdGVyOiBcIjxwPlBhc3N0IGRpZSBBdXNkZWhudW5nIGRlciBBdXNnYWJlIGFuLCBzb2Rhc3Mgc2llIGRlciBaZWxsZW5hdXNyaWNodHVuZyBkZXMgYW5nZWdlYmVuZW4gRmFuZy1SYXN0ZXItTGF5ZXJzIGVudHNwcmljaHQuPC9wPlwiLFxuXHRcdGNlbGxTaXplOiBcIjxwPkxlZ3QgZGllIFplbGxlbmdyw7bDn2Ugb2RlciBBdWZsw7ZzdW5nIGZlc3QsIGRpZSBmw7xyIGRpZSBBbmFseXNlIHVuZCB6dW0gRXJzdGVsbGVuIGRlcyBBdXNnYWJlLVJhc3Rlci1MYXllcnMgdmVyd2VuZGV0IHdpcmQuPC9wPlwiLFxuXHRcdG1hc2s6IFwiPHA+R2lidCBlaW5lbiBNYXNrZW4tTGF5ZXIgYW4sIGluIGRlbSBudXIgZGllIFplbGxlbiBpbSBNYXNrZW5iZXJlaWNoIGbDvHIgZGllIEFuYWx5c2UgdmVyd2VuZGV0IHdlcmRlbi48L3A+XCIsXG5cdFx0cmVzYW1wbGluZ01ldGhvZDogXCI8cD5HaWJ0IGFuLCB3aWUgUGl4ZWx3ZXJ0ZSBpbnRlcnBvbGllcnQgd2VyZGVuIHNvbGxlbiwgd2VubiBkaWUgRWluZ2FiZS0gdW5kIEF1c2dhYmUtUmFzdGVyIG5pY2h0IMO8YmVyZWluc3RpbW1lbi48L3A+XCJcblx0fSxcblx0bWFpbkdlblN0cmluZ3M6IHtcblx0XHR1bnN1cHBvcnRlZERhdGFUeXBlOiBcIk5pY2h0IHVudGVyc3TDvHR6dGVyIFR5cFwiLFxuXHRcdGN1cnJlbnRseVVuc3VwcG9ydGVkOiBcIiBFaW4gU3RhbmRhcmQtRWRpdG9yIGbDvHIgJHttaXNzaW5nVHlwZX0gaXN0IGluIEvDvHJ6ZSB2ZXJmw7xnYmFyLiBUZW1wb3LDpHJlcyBQbGF0emhhbHRlci1UZXh0ZmVsZCBmw7xyIGRpZSBBbmdhYmUgdm9uIGF1ZiBlaW5lciBaZWljaGVuZm9sZ2UgYmFzaWVydGVuIEVpbmdhYmVuLlwiLFxuXHRcdHVuc3VwcG9ydGVkT3ZlcnJpZGVXYXJuaW5nOiBcIkVpbmUgRWRpdG9yLUtvbXBvbmVudGUgenVtIMOcYmVyc2NocmVpYmVuIG1pdCBlaW5lciBiZXNzZXJlbiBCZW51dHplcm9iZXJmbMOkY2hlIGbDvHIgZGFzIEFyYmVpdGVuIG1pdCBkZW4gZm9sZ2VuZGVuIFBhcmFtZXRlcm4gaXN0IGluIEvDvHJ6ZSB2ZXJmw7xnYmFyOlwiLFxuXHRcdG92ZXJyaWRlV2lkZ2V0TWlzc2luZzogXCJFZGl0b3ItS29tcG9uZW50ZSB6dW0gw5xiZXJzY2hyZWliZW4gZmVobHQhXCIsXG5cdFx0dWlJbmNvbXBsZXRlOiBcIkF1ZnRyYWdzw7xiZXJtaXR0bHVuZyBmZWhsZ2VzY2hsYWdlbi4gRGllIEZ1bmt0aW9uIGthbm4gbmljaHQgYXVzZ2Vmw7xocnQgd2VyZGVuLCB3ZWlsIGVpbmlnZSBkZXIgUGZsaWNodGZlbGRlciBuaWNodCBhdXNnZWbDvGxsdCBzaW5kIG9kZXIgaW4gZGVyIEJlbnV0emVyb2JlcmZsw6RjaGUgZmVobGVuLlwiLFxuXHRcdGNvdW50OiBcIkFuemFobFwiLFxuXHRcdHNlbGVjdFZhcmlhYmxlczogXCJWYXJpYWJsZW4gYXVzd8OkaGxlblwiLFxuXHRcdHNlbGVjdEZlYXR1cmU6IFwiRmVhdHVyZS1MYXllciBhdXN3w6RobGVuXCIsXG5cdFx0Z3JlYXRlclRoYW5FcnJvck1lc3NhZ2U6IFwiRGllIEVpbmdhYmUgZsO8ciBkaWUgQW56YWhsIG11c3MgZ3LDtsOfZXIgYWxzICR7bWlufSBzZWluLlwiLFxuXHRcdGxlc3NlclRoYW5FcnJvck1lc3NhZ2U6IFwiRGllIEVpbmdhYmUgZsO8ciBkaWUgQW56YWhsIG11c3Mga2xlaW5lciBhbHMgJHttYXh9IHNlaW4uXCIsXG5cdFx0Z3JlYXRlclRoYW5PckVxdWFsRXJyb3JNZXNzYWdlOiBcIkRpZSBFaW5nYWJlIGbDvHIgZGllIEFuemFobCBtdXNzIGdyw7bDn2VyIGFscyBvZGVyIGdsZWljaCAke21pbn0gc2Vpbi5cIixcblx0XHRsZXNzZXJUaGFuT3JFcXVhbEVycm9yTWVzc2FnZTogXCJEaWUgRWluZ2FiZSBmw7xyIGRpZSBBbnphaGwgbXVzcyBrbGVpbmVyIGFscyBvZGVyIGdsZWljaCAke21heH0gc2Vpbi5cIixcblx0XHRhbGxvd1NjYWxhcjogXCJMYXllciBhdXN3w6RobGVuIG9kZXIgS29uc3RhbnRlIGVpbmdlYmVuXCIsXG5cdFx0c2VsZWN0RmllbGQ6IFwiRmVsZCBhdXN3w6RobGVuXCIsXG5cdFx0cGFyYW1ldGVyUmVxdWlyZWQ6IFwiRGllc2VyIFBhcmFtZXRlciBpc3QgZXJmb3JkZXJsaWNoLlwiLFxuXHRcdGVudGVyQVZhbHVlOiBcIldlcnQgZWluZ2ViZW4gLi4uXCIsXG5cdFx0aW52YWxpZElucHV0OiBcIkRlciBlaW5nZWdlYmVuZSBXZXJ0IGlzdCB1bmfDvGx0aWcuXCIsXG5cdFx0aXRlbU5vdEZvdW5kOiBcIkRhcyBFbGVtZW50IGlzdCBuaWNodCB2b3JoYW5kZW4sIG9kZXIgZXMga2FubiBuaWNodCBkYXJhdWYgenVnZWdyaWZmZW4gd2VyZGVuLlwiLFxuXHRcdGl0ZW1QZXJtaXNzaW9uRGVuaWVkOiBcIlNpZSBoYWJlbiBrZWluZSBadWdyaWZmc2JlcmVjaHRpZ3VuZyBmw7xyIGRpZXNlcyBFbGVtZW50LlwiLFxuXHRcdGxheWVyTm90QXZhaWxhYmxlOiBcIkZlaGxlciBiZWltIExhZGVuIGRlcyBMYXllcnMgXFxcIiR7bGF5ZXJOYW1lfVxcXCIuXCIsXG5cdFx0bXVsdGlwbGVMYXllcnNOb3RBdmFpbGFibGU6IFwiRmVobGVyIGJlaW0gTGFkZW4gZGVzIExheWVycyBcXFwiJHtsYXllck5hbWV9XFxcIiB1bmQgd2VpdGVyZXIgTGF5ZXIuXCIsXG5cdFx0bGVhcm5Nb3JlTGFiZWw6IFwiTWVociBlcmZhaHJlblwiLFxuXHRcdGZpZWxkTm90QXZhaWxhYmxlOiBcIkZlbGQga29ubnRlIG5pY2h0IGdlbGFkZW4gd2VyZGVuLlwiLFxuXHRcdGFsbG93QW5hbHlzaXM6IFwiRGllIEFuYWx5c2UgaXN0IGbDvHIgZGVuIEltYWdlLVNlcnZpY2UgbmljaHQgenVsw6Rzc2lnLlwiLFxuXHRcdGFsbG93QW5hbHlzaXNSZWFzb246IFwiRWluIG9kZXIgbWVocmVyZSBMYXllciBhdXMgZGVyIEthcnRlIHNpbmQgaGllciBuaWNodCBhdWZnZWbDvGhydCwgZGEgc2llIGtlaW5lIEFuYWx5c2UgenVsYXNzZW4uXCIsXG5cdFx0bGVhcm5Nb3JlVGV4dDogXCJXZWl0ZXJlIEluZm9ybWF0aW9uZW5cIixcblx0XHRhdExlYXN0T25lUmFzdGVySW5wdXQ6IFwiTWluZGVzdGVucyBlaW4gRWluZ2FiZS1MYXllciBtdXNzIGVpbiBSYXN0ZXItTGF5ZXIgc2Vpbi5cIixcblx0XHRicm93c2VBbmFseXNpc0xheWVyczogXCJMYXllciBkdXJjaHN1Y2hlblwiLFxuXHRcdGFjdGl2ZU1hcFZpZXdFeHRlbnQ6IFwiQWt0dWVsbGUgS2FydGVuYXVzZGVobnVuZyB2ZXJ3ZW5kZW5cIixcblx0XHRjaG9vc2VSYXN0ZXI6IFwiUmFzdGVyIHp1bSBBdXNzY2huZWlkZW4gYXVzd8OkaGxlblwiLFxuXHRcdGNob29zZUdlb21ldHJ5OiBcIkdlb21ldHJpZSB6dW0gQXVzc2NobmVpZGVuIGF1c3fDpGhsZW5cIixcblx0XHRyZXN1bHRUeXBlOiBcIkVyZ2VibmlzdHlwXCIsXG5cdFx0c2F2ZUluRm9sZGVyOiBcIkluIE9yZG5lciBzcGVpY2hlcm5cIixcblx0XHRvdXRwdXROYW1lOiBcIkF1c2dhYmVuYW1lXCIsXG5cdFx0b3V0cHV0TGF5ZXJUeXBlOiBcIkF1c2dhYmUtTGF5ZXItVHlwXCIsXG5cdFx0ZHluYW1pY0ltYWdlcnlMYXllcjogXCJEeW5hbWlzY2hlciBCaWxkZGF0ZW4tTGF5ZXJcIixcblx0XHR0aWxlZEltYWdlcnlMYXllcjogXCJHZWthY2hlbHRlciBCaWxkZGF0ZW4tTGF5ZXJcIixcblx0XHRjdXN0b206IFwiQmVudXR6ZXJkZWZpbmllcnRcIixcblx0XHRsb2FkaW5nOiBcIldpcmQgZ2VsYWRlbi4uLlwiLFxuXHRcdGxheWVyTWlzc2luZzogXCJFaW4gb2RlciBtZWhyZXJlIExheWVyIGF1cyBkZXIgS2FydGUgc2luZCBoaWVyIG5pY2h0IGF1ZmdlZsO8aHJ0LCBkYSBzaWUga2VpbmUgQW5hbHlzZSB6dWxhc3Nlbi4gV2VpdGVyZSBJbmZvcm1hdGlvbmVuXCIsXG5cdFx0YnJvd3NlQ29vcmRpbmF0ZVN5c3RlbXM6IFwiS29vcmRpbmF0ZW5zeXN0ZW1lIGR1cmNoc3VjaGVuXCIsXG5cdFx0dW5hYmxlVG9SZXBvcHVsYXRlT3V0U1I6IFwiRGFzIEF1c2dhYmVrb29yZGluYXRlbnN5c3RlbSBrYW5uIG5pY2h0IGdlZsO8bGx0IHdlcmRlbi5cIixcblx0XHRkZWZhdWx0VGl0bGU6IFwiTWVociBhbnplaWdlblwiLFxuXHRcdFwiQVJDIChlcXVhbCBhcmMtc2Vjb25kKVwiOiBcIkFSQyAoZ2xlaWNoIEJvZ2Vuc2VrdW5kZSlcIixcblx0XHRBZnJpY2E6IFwiQWZyaWthXCIsXG5cdFx0QW50YXJjdGljYTogXCJBbnRhcmt0aXNcIixcblx0XHRBcmdlbnRpbmE6IFwiQXJnZW50aW5pZW5cIixcblx0XHRBc2lhOiBcIkFzaWVuXCIsXG5cdFx0XCJBc3Rlcm9pZCBCZWx0XCI6IFwiQXN0ZXJvaWRlbmfDvHJ0ZWxcIixcblx0XHRcIkF0bGFudGljIE9jZWFuXCI6IFwiQXRsYW50aXNjaGVyIE96ZWFuXCIsXG5cdFx0QXVzdHJhbGlhOiBcIkF1c3RyYWxpZW5cIixcblx0XHRcIkF1c3RyYWxpYSBhbmQgTmV3IFplYWxhbmRcIjogXCJBdXN0cmFsaWVuIHVuZCBOZXVzZWVsYW5kXCIsXG5cdFx0QXVzdHJpYTogXCLDlnN0ZXJyZWljaFwiLFxuXHRcdFwiQkxNIChVUyBGZWV0KVwiOiBcIkJMTSAoVVMgRmVldClcIixcblx0XHRCYW5nbGFkZXNoOiBcIkJhbmdsYWRlc2NoXCIsXG5cdFx0XCJCZWlqaW5nIDE5NTRcIjogXCJCZWlqaW5nwqAxOTU0XCIsXG5cdFx0Qmh1dGFuOiBcIkJodXRhblwiLFxuXHRcdENHQ1MyMDAwOiBcIkNHQ1MyMDAwXCIsXG5cdFx0Q2FuYWRhOiBcIkthbmFkYVwiLFxuXHRcdENhcmliYmVhbjogXCJLYXJpYmlrXCIsXG5cdFx0XCJDYXJpYmJlYW4gU2VhXCI6IFwiS2FyaWJpc2NoZXMgTWVlclwiLFxuXHRcdFwiQ2VudHJhbCBBbWVyaWNhXCI6IFwiTWl0dGVsYW1lcmlrYVwiLFxuXHRcdFwiQ2VudHJhbCBhbmQgTm9ydGggQW1lcmljYVwiOiBcIk1pdHRlbC0gdW5kIE5vcmRhbWVyaWthXCIsXG5cdFx0Q29sb21iaWE6IFwiS29sdW1iaWVuXCIsXG5cdFx0Q29udGluZW50YWw6IFwiS29udGluZW50ZVwiLFxuXHRcdFwiQ291bnR5IFN5c3RlbXNcIjogXCJDb3VudHkgU3lzdGVtc1wiLFxuXHRcdFwiRGVtb2NyYXRpYyBSZXB1YmxpYyBvZiB0aGUgQ29uZ29cIjogXCJEZW1va3JhdGlzY2hlIFJlcHVibGlrIEtvbmdvXCIsXG5cdFx0XCJFUFNHIEFyY3RpY1wiOiBcIkVQU0cgQXJjdGljXCIsXG5cdFx0RWFydGg6IFwiRXJkZVwiLFxuXHRcdFwiRWxsaXBzb2lkYWwtYmFzZWRcIjogXCJFbGxpcHNvaWRcIixcblx0XHRFdXJvcGU6IFwiRXVyb3BhXCIsXG5cdFx0RmlubGFuZDogXCJGaW5ubGFuZFwiLFxuXHRcdEZyYW5jZTogXCJGcmFua3JlaWNoXCIsXG5cdFx0XCJHU0sgMjAxMVwiOiBcIkdTS8KgMjAxMVwiLFxuXHRcdFwiR2F1c3MgS3J1Z2VyXCI6IFwiR2F1w58tS3LDvGdlclwiLFxuXHRcdFwiR2VvZ3JhcGhpYyBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJHZW9ncmFwaGlzY2hlIEtvb3JkaW5hdGVuc3lzdGVtZVwiLFxuXHRcdEdlcm1hbnk6IFwiRGV1dHNjaGxhbmRcIixcblx0XHRcIkdyYXZpdHktcmVsYXRlZFwiOiBcIlNjaHdlcmtyYWZ0YWJow6RuZ2lnXCIsXG5cdFx0XCJHcmVlbndpY2gtYmFzZWRcIjogXCJHcmVlbndpY2gtYmFzaWVydFwiLFxuXHRcdFwiSGlnaHdheXMgRW5nbGFuZFwiOiBcIkhpZ2h3YXlzIEVuZ2xhbmRcIixcblx0XHRJbGxpbm9pczogXCJJbGxpbm9pc1wiLFxuXHRcdFwiSW5kaWFuIE9jZWFuXCI6IFwiSW5kaXNjaGVyIE96ZWFuXCIsXG5cdFx0XCJJbmRpYW4gU3ViY29udGluZW50XCI6IFwiSW5kaXNjaGVyIFN1YmtvbnRpbmVudFwiLFxuXHRcdEluZGlhbmE6IFwiSW5kaWFuYVwiLFxuXHRcdEluZG9uZXNpYTogXCJJbmRvbmVzaWVuXCIsXG5cdFx0SW93YTogXCJJb3dhXCIsXG5cdFx0XCJJcmVsYW5kIGFuZCBVbml0ZWQgS2luZ2RvbVwiOiBcIklybGFuZCB1bmQgVmVyZWluaWd0ZXMgS8O2bmlncmVpY2hcIixcblx0XHRJdGFseTogXCJJdGFsaWVuXCIsXG5cdFx0SmFwYW46IFwiSmFwYW5cIixcblx0XHRKdXBpdGVyOiBcIkp1cGl0ZXJcIixcblx0XHRLYW5zYXM6IFwiS2Fuc2FzXCIsXG5cdFx0XCJMYXMgVmVnYXNcIjogXCJMYXMgVmVnYXNcIixcblx0XHRMaWJ5YTogXCJMaWJ5ZW5cIixcblx0XHRNYWxheXNpYTogXCJNYWxheXNpYVwiLFxuXHRcdFwiTWFsYXlzaWEgYW5kIFNpbmdhcG9yZVwiOiBcIk1hbGF5c2lhIHVuZCBTaW5nYXB1clwiLFxuXHRcdE1hcnM6IFwiTWFyc1wiLFxuXHRcdE1lcmN1cnk6IFwiTWVya3VyXCIsXG5cdFx0TWlubmVzb3RhOiBcIk1pbm5lc290YVwiLFxuXHRcdE1vbnRhbmE6IFwiTW9udGFuYVwiLFxuXHRcdFwiTkFEIDE5MjdcIjogXCJOQUQgMTkyN1wiLFxuXHRcdFwiTkFEIDE5MjcgKFVTIEZlZXQpXCI6IFwiTkFEIDE5MjcgKFVTIEZlZXQpXCIsXG5cdFx0XCJOQUQgMTk4M1wiOiBcIk5BRCAxOTgzXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSlcIjogXCJOQUTCoDE5ODMgKDIwMTEpXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSkgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoMjAxMSkgKEludGwgRmVldClcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzICgyMDExKSAoTWV0ZXJzKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzICgyMDExKSAoVVMgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKEludGwgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKE1ldGVycylcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChDT1JTOTYpIChVUyBGZWV0KVwiLFxuXHRcdFwiTkFEIDE5ODMgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoSW50bCBGZWV0KVwiLFxuXHRcdFwiTkFEIDE5ODMgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoTWV0ZXJzKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKFBBMTEpIChNZXRlcnMpXCIsXG5cdFx0XCJOQUQgMTk4MyAoUEExMSkgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgKFBBMTEpIChVUyBGZWV0KVwiLFxuXHRcdFwiTkFEIDE5ODMgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgKFVTIEZlZXQpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgSEFSTiAoSW50bCBGZWV0KVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIEhBUk4gKE1ldGVycylcIixcblx0XHRcIk5BRCAxOTgzIEhBUk4gKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgSEFSTiAoVVMgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKEludGwgRmVldClcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKE1ldGVycylcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIE5TUlMyMDA3IChVUyBGZWV0KVwiLFxuXHRcdFwiTmF0aW9uYWwgR3JpZHNcIjogXCJOYXRpb25hbGUgR2l0dGVyXCIsXG5cdFx0TmF2YWpvOiBcIk5hdmFqb1wiLFxuXHRcdE5lcHR1bmU6IFwiTmVwdHVuXCIsXG5cdFx0XCJOZXcgQmVpamluZ1wiOiBcIk5ldyBCZWlqaW5nXCIsXG5cdFx0XCJOZXcgWmVhbGFuZFwiOiBcIk5ldXNlZWxhbmRcIixcblx0XHRcIk5vcnRoIEFtZXJpY2FcIjogXCJOb3JkYW1lcmlrYVwiLFxuXHRcdFwiTm9ydGhlcm4gSGVtaXNwaGVyZVwiOiBcIk7DtnJkbGljaGUgSGVtaXNwaMOkcmVcIixcblx0XHROb3J3YXk6IFwiTm9yd2VnZW5cIixcblx0XHRPY2VhbnM6IFwiTWVlcmVcIixcblx0XHRPcmVnb246IFwiT3JlZ29uXCIsXG5cdFx0XCJPdGhlciBHQ1NcIjogXCJBbmRlcmVzIEdDU1wiLFxuXHRcdFwiUGFjaWZpYyBPY2VhblwiOiBcIlBhemlmaXNjaGVyIE96ZWFuXCIsXG5cdFx0UGx1dG86IFwiUGx1dG9cIixcblx0XHRQb2xhcjogXCJQb2xhcmdlYmlldGVcIixcblx0XHRQb3J0dWdhbDogXCJQb3J0dWdhbFwiLFxuXHRcdFwiUHJvamVjdGVkIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIlByb2ppemllcnRlIEtvb3JkaW5hdGVuc3lzdGVtZVwiLFxuXHRcdFwiUHVsa292byAxOTQyXCI6IFwiUHVsa292b8KgMTk0MlwiLFxuXHRcdFwiUHVsa292byAxOTk1XCI6IFwiUHVsa292b8KgMTk5NVwiLFxuXHRcdFJlcGxhY2VkOiBcIkVyc2V0enRcIixcblx0XHRcIlNBRCAxOTY5XCI6IFwiU0FEwqAxOTY5XCIsXG5cdFx0U0lSR0FTOiBcIlNJUkdBU1wiLFxuXHRcdFwiU0lSR0FTIDIwMDBcIjogXCJTSVJHQVPCoDIwMDBcIixcblx0XHRTYXR1cm46IFwiU2F0dXJuXCIsXG5cdFx0XCJTb2xhciBTeXN0ZW1cIjogXCJTb25uZW5zeXN0ZW1cIixcblx0XHRcIlNvdXRoIEFmcmljYVwiOiBcIlPDvGRhZnJpa2FcIixcblx0XHRcIlNvdXRoIEFtZXJpY2FcIjogXCJTw7xkYW1lcmlrYVwiLFxuXHRcdFwiU291dGggS29yZWFcIjogXCJTw7xka29yZWFcIixcblx0XHRcIlNvdXRoZXJuIEhlbWlzcGhlcmVcIjogXCJTw7xkbGljaGUgSGVtaXNwaMOkcmVcIixcblx0XHRcIlNwaGVyb2lkLWJhc2VkXCI6IFwiU3Bow6Ryb2lkLWJhc2llcnRcIixcblx0XHRcIlN0YXRlIFBsYW5lXCI6IFwiU3RhdGUgUGxhbmVcIixcblx0XHRcIlN0YXRlIFN5c3RlbXNcIjogXCJTdGF0ZSBTeXN0ZW1zXCIsXG5cdFx0U3dlZGVuOiBcIlNjaHdlZGVuXCIsXG5cdFx0XCJTd2l0emVybGFuZCBhbmQgTGllY2h0ZW5zdGVpblwiOiBcIlNjaHdlaXogdW5kIExpZWNodGVuc3RlaW5cIixcblx0XHRUZXhhczogXCJUZXhhc1wiLFxuXHRcdFRyaWJhbDogXCJUcmliYWxcIixcblx0XHRUdXJrZXk6IFwiVMO8cmtlaVwiLFxuXHRcdFwiVVMgRmVldFwiOiBcIlVTIEZlZXRcIixcblx0XHRcIlVTQSBhbmQgdGVycml0b3JpZXNcIjogXCJVU0EgdW5kIHp1Z2Vow7ZyaWdlIFRlcnJpdG9yaWVuXCIsXG5cdFx0VVRNOiBcIlVUTVwiLFxuXHRcdFVrcmFpbmU6IFwiVWtyYWluZVwiLFxuXHRcdFwiVW5rbm93biBIZWlnaHQgU3lzdGVtc1wiOiBcIlVuYmVrYW5udGUgSMO2aGVuc3lzdGVtZVwiLFxuXHRcdFVyYW51czogXCJVcmFudXNcIixcblx0XHRWZW51czogXCJWZW51c1wiLFxuXHRcdFwiVmVydGljYWwgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiVmVydGlrYWxlIEtvb3JkaW5hdGVuc3lzdGVtZVwiLFxuXHRcdFZpZXRuYW06IFwiVmlldG5hbVwiLFxuXHRcdFwiV0dTIDE5NzJcIjogXCJXR1MgMTk3MlwiLFxuXHRcdFwiV0dTIDE5ODRcIjogXCJXR1MgMTk4NFwiLFxuXHRcdFdpc2NvbnNpbjogXCJXaXNjb25zaW5cIixcblx0XHRcIldpc2NvbnNpbiBDUlNcIjogXCJXaXNjb25zaW4gQ1JTXCIsXG5cdFx0V29ybGQ6IFwiV2VsdFwiLFxuXHRcdFwiV29ybGQgKFNwaGVyZS1iYXNlZClcIjogXCJXZWx0IChTcGjDpHJvaWQpXCIsXG5cdFx0V3lvbWluZzogXCJXeW9taW5nXCIsXG5cdFx0XCJYaWFuIDE5ODBcIjogXCJYaWFuwqAxOTgwXCIsXG5cdFx0ZG9uZTogXCJGZXJ0aWdcIixcblx0XHRub1Jlc3VsdHM6IFwiS2VpbmUgRXJnZWJuaXNzZSBnZWZ1bmRlblwiLFxuXHRcdHNlYXJjaFBsYWNlaG9sZGVyOiBcIk5hbWUgb2RlciBXS0lEXCIsXG5cdFx0YnJvd3NlVGVtcGxhdGU6IFwiUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2VuIGR1cmNoc3VjaGVuXCIsXG5cdFx0c2F2ZVRlbXBsYXRlOiBcIlJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlIHNwZWljaGVyblwiLFxuXHRcdHByZXZpZXc6IFwiVm9yc2NoYXVcIixcblx0XHRwcmV2aWV3RGVzY3JpcHRpb246IFwiVm9yIGRlbSBBdXNmw7xocmVuIGRlciBBbmFseXNlIGVpbmUgVm9yc2NoYXUgZGVzIEVyZ2Vibmlzc2VzIGFuemVpZ2VuLlwiLFxuXHRcdHNob3dQcmV2aWV3OiBcIlZvcnNjaGF1IGFuemVpZ2VuXCIsXG5cdFx0cHJldmlld0xheWVyOiBcIlZvcnNjaGF1IHZvbiBMYXllcsKgJHtudW1iZXJ9IGFuemVpZ2VuXCIsXG5cdFx0bmV3UHJldmlldzogXCJOZXVlIFZvcnNjaGF1XCIsXG5cdFx0cHJldmlld1BvcHVwOiBcIkRpZSBWb3JzY2hhdSBkZXIgQW5hbHlzZWVyZ2Vibmlzc2UgYmFzaWVyZW5kIGF1ZiBkZW4gRWluZ2FiZXBhcmFtZXRlcm4gYWt0aXZpZXJlbi5cIixcblx0XHR1cGRhdGVQcmV2aWV3TGF5ZXI6IFwiQXVzZ2V3w6RobHRlbiBWb3JzY2hhdS1MYXllciBha3R1YWxpc2llcmVuXCIsXG5cdFx0Y3JlYXRlUHJldmlld0xheWVyOiBcIk5ldWVuIFZvcnNjaGF1LUxheWVyIGVyc3RlbGxlblwiLFxuXHRcdG1heGltdW1QcmV2aWV3QWxsb3dlZDogXCJNYXhpbWFsIHp1bMOkc3NpZ2UgQW56YWhsIHZvbiBWb3JzY2hhdS1MYXllcm46ICR7bWF4Q291bnR9XCIsXG5cdFx0cHJldmlld0ZhaWx1cmU6IFwiRGllc2VyIFZvcnNjaGF1LUxheWVyIGlzdCBuaWNodCB2ZXJmw7xnYmFyLiDDnGJlcnByw7xmZW4gU2llIGRpZSBFaW5nYWJlcGFyYW1ldGVyLCB1bmQgYWt0dWFsaXNpZXJlbiBTaWUgZGllc2VuIFZvcnNjaGF1LUxheWVyIGVybmV1dC5cIixcblx0XHRoZWFkZXI6IFwiRWxlbWVudCBhdXN3w6RobGVuXCIsXG5cdFx0Y29udGVudDogXCJOaWNodCBnZXNwZWljaGVydGUgw4RuZGVydW5nZW4gaW4gJHtyZnRUaXRsZX0uIFdlbm4gU2llIG1pdCBlaW5lciBuZXVlbiBWb3JsYWdlIGJlZ2lubmVuLCBnZWhlbiBkaWVzZSDDhG5kZXJ1bmdlbiB2ZXJsb3Jlbi5cIixcblx0XHRkb250U2F2ZTogXCJOaWNodCBzcGVpY2hlcm5cIixcblx0XHRcImNvbnRpbnVlXCI6IFwiV2VpdGVyXCIsXG5cdFx0c3RyZXRjaDogXCJBbiBGZW5zdGVyIGFucGFzc2VuXCIsXG5cdFx0cGFuOiBcIlNjaHdlbmtlblwiLFxuXHRcdG5ld1RlbXBsYXRlOiBcIk5ldWUgVm9ybGFnZSBlcnN0ZWxsZW5cIixcblx0XHRvcGVuVGVtcGxhdGU6IFwiVm9ybGFnZSDDtmZmbmVuXCIsXG5cdFx0YWRkRnVuY3Rpb246IFwiUmFzdGVyLUZ1bmt0aW9uZW4gaGluenVmw7xnZW5cIixcblx0XHRhZGRDb25zdGFudDogXCJLb25zdGFudGUgaGluenVmw7xnZW5cIixcblx0XHRhZGRSYXN0ZXI6IFwiUmFzdGVyLVZhcmlhYmxlIGhpbnp1ZsO8Z2VuXCIsXG5cdFx0bW92ZTogXCJWZXJzY2hpZWJlblwiLFxuXHRcdHpvb206IFwiWm9vbWVuXCIsXG5cdFx0c2F2ZUFzOiBcIlNwZWljaGVybiB1bnRlclwiLFxuXHRcdGNsZWFyOiBcIkzDtnNjaGVuXCIsXG5cdFx0YWRkUmFzdGVyRnVuY3Rpb25UaXRsZTogXCJSYXN0ZXItRnVua3Rpb25lbiBoaW56dWbDvGdlblwiLFxuXHRcdHRlbXBsYXRlUHJvcGVydGllc1RpdGxlOiBcIlZvcmxhZ2VuZWlnZW5zY2hhZnRlblwiLFxuXHRcdGJyb3dzZVJGVDogXCJSYXN0ZXItRnVua3Rpb25zdm9ybGFnZW4gZHVyY2hzdWNoZW5cIixcblx0XHRkZWZhdWx0VG9vbERlc2NyaXB0aW9uOiBcIiR7dG9vbFRpdGxlfS1BbmFseXNld2Vya3pldWdcIixcblx0XHRvcGVuVG9vbFRleHQ6IFwiV2Vya3pldWcgw7ZmZm5lblwiLFxuXHRcdHRvb2xEcm9wZG93blRleHQ6IFwiV2Vya3pldWctRHJvcGRvd24tTGlzdGVcIixcblx0XHRhZGRUb01hcDogXCJCZXN0w6R0aWdlbiB1bmQgenVyIEthcnRlIGhpbnp1ZsO8Z2VuXCIsXG5cdFx0Y29uZmlybTogXCJCZXN0w6R0aWdlblwiLFxuXHRcdHNlbGVjdDogXCJBdXN3w6RobGVuXCIsXG5cdFx0c2VsZWN0VGFzazogXCJUYXNrIGF1c3fDpGhsZW5cIixcblx0XHR1bnN1cHBvcnRlZExheWVyOiBcIkRpZXNlciBQYXJhbWV0ZXIgdW50ZXJzdMO8dHp0IGRpZSBmb2xnZW5kZW4gTGF5ZXIgbmljaHQ6ICR7bGF5ZXJOYW1lfVwiLFxuXHRcdHZpZXdEZXRhaWxzOiBcIlZvbGxzdMOkbmRpZ2UgRWxlbWVudGRldGFpbHMgYW56ZWlnZW5cIixcblx0XHRyZW5hbWU6IFwiVW1iZW5lbm5lblwiLFxuXHRcdGR1cGxpY2F0ZTogXCJEdXBsaXppZXJlblwiLFxuXHRcdGxhdW5jaDogXCJadW0gQXVzZsO8aHJlbiDDtmZmbmVuXCIsXG5cdFx0dGVtcGxhdGVFZGl0b3I6IFwiVm9ybGFnZW5lZGl0b3JcIixcblx0XHRjcmVhdGVJdGVtOiBcIlJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlIHNwZWljaGVyblwiLFxuXHRcdGFjdGlvbkxhYmVsOiBcIkZpbHRlcm5cIixcblx0XHRmaWx0ZXJQb3BvdmVySGVhZGluZzogXCJGdW5rdGlvbmVuIGZpbHRlcm5cIixcblx0XHRkZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXI6IFwiTmFjaCBOYW1lbiBzdWNoZW5cIixcblx0XHRzZXR0aW5nczogXCJFaW5zdGVsbHVuZ2VuXCIsXG5cdFx0c3VtbWFyeTogXCJadXNhbW1lbmZhc3N1bmdcIixcblx0XHRkZWZpbml0aW9uUXVlcnk6IFwiRGVmaW5pdGlvbnNhYmZyYWdlXCIsXG5cdFx0bWF0Y2hWYXJpYWJsZXM6IFwiVmFyaWFibGVuIGFiZ2xlaWNoZW5cIixcblx0XHR1bmlvbkRpbWVuc2lvbjogXCJEaW1lbnNpb24gdmVyZWluaWdlblwiLFxuXHRcdG5hbWVFZGl0b3JQbGFjZWhvbGRlcjogXCJUaXRlbCBlaW5nZWJlblwiLFxuXHRcdHN1bW1hcnlFZGl0b3JQbGFjZWhvbGRlcjogXCJHZWJlbiBTaWUgZWluZSBLdXJ6YmVzY2hyZWlidW5nIGVpbi5cIixcblx0XHRkZWZpbml0aW9uUXVlcnlQbGFjZWhvbGRlcjogXCJFaW5nYWJlLi4uXCIsXG5cdFx0dXBsb2FkOiBcIkhvY2hsYWRlblwiLFxuXHRcdGNob29zZUltYWdlOiBcIktsaWNrZW4gU2llLCB1bSBlaW5lIERhdGVpIGF1c3p1d8OkaGxlbi5cIixcblx0XHR1cGRhdGU6IFwiQWt0dWFsaXNpZXJlblwiLFxuXHRcdHRodW1ibmFpbEVycm9yczoge1xuXHRcdFx0d3JvbmdJbWFnZVR5cGU6IFwiRmFsc2NoZXIgQmlsZHR5cCBhdXNnZXfDpGhsdFwiLFxuXHRcdFx0bm90QXZhaWxhYmxlOiBcIk1pbmlhdHVyYW5zaWNodCBuaWNodCB2ZXJmw7xnYmFyXCIsXG5cdFx0XHRsb2FkRXJyb3I6IFwiQmlsZCBrb25udGUgbmljaHQgZ2VsYWRlbiB3ZXJkZW5cIixcblx0XHRcdGNob29zZUZpbGU6IFwiS2xpY2tlbiBTaWUsIHVtIGRpZSBEYXRlaSBhdXN6dXfDpGhsZW4uXCJcblx0XHR9XG5cdH1cbn07XG5jb25zdCBjb3B5ID0gXCJLb3BpZXJlblwiO1xuY29uc3Qgc2F2ZSA9IFwiU3BlaWNoZXJuXCI7XG5jb25zdCB0aXRsZSA9IFwiVGl0ZWxcIjtcbmNvbnN0IGZvbGRlciA9IFwiT3JkbmVyXCI7XG5jb25zdCB0YWdzID0gXCJUYWdzXCI7XG5jb25zdCBzYXZpbmdNZXNzYWdlID0gXCJFbGVtZW50IHdpcmQgZ2VzcGVpY2hlcnQgaW5cIjtcbmNvbnN0IHNoYXJlV2l0aCA9IFwiRnJlaWdlYmVuIGbDvHJcIjtcbmNvbnN0IHNoYXJlID0gXCJGcmVpZ2ViZW5cIjtcbmNvbnN0IHNldFNoYXJpbmdMZXZlbCA9IFwiRnJlaWdhYmVlYmVuZSBmZXN0bGVnZW5cIjtcbmNvbnN0IHNldEdyb3VwU2hhcmluZyA9IFwiR3J1cHBlbmZyZWlnYWJlIGZlc3RsZWdlblwiO1xuY29uc3Qgb3duZXIgPSBcIkJlc2l0emVyXCI7XG5jb25zdCBvcmdhbml6YXRpb24gPSBcIk9yZ2FuaXNhdGlvblwiO1xuY29uc3QgZXZlcnlvbmUgPSBcIkFsbGUgKMO2ZmZlbnRsaWNoKVwiO1xuY29uc3QgZ3JvdXBzID0gXCJHcnVwcGVuOlwiO1xuY29uc3QgdHlwZSA9IFwiVHlwXCI7XG5jb25zdCBtb3NhaWMgPSBcIk1vc2Fpa1wiO1xuY29uc3QgaXRlbUdyb3VwID0gXCJFbGVtZW50Z3J1cHBlXCI7XG5jb25zdCBpdGVtID0gXCJFbGVtZW50XCI7XG5jb25zdCBkZWZpbml0aW9uUXVlcnkgPSBcIkRlZmluaXRpb25zYWJmcmFnZVwiO1xuY29uc3QgZ3JvdXBJdGVtc0J5ID0gXCJFbGVtZW50ZSBncnVwcGllcmVuIG5hY2hcIjtcbmNvbnN0IGdyb3VwRmllbGROYW1lID0gXCJHcnVwcGllcnVuZ3NmZWxkbmFtZVwiO1xuY29uc3QgdGFnRmllbGROYW1lID0gXCJUYWctRmVsZG5hbWVcIjtcbmNvbnN0IG5vVGl0bGVUYWdFcnJvck1zZyA9IFwiU2llIG3DvHNzZW4gZWluZW4gVGl0ZWwgZsO8ciBkYXMgRWxlbWVudCBzb3dpZSBUYWdzIGFuZ2ViZW4sIGRhbWl0IGRpZSBLYXJ0ZSBpbiBTdWNodm9yZ8OkbmdlbiBnZWZ1bmRlbiB3ZXJkZW4ga2Fubi5cIjtcbmNvbnN0IG5vVGl0bGVFcnJvck1zZyA9IFwiU2llIG3DvHNzZW4gZWluZW4gVGl0ZWwgZsO8ciBkYXMgRWxlbWVudCBhbmdlYmVuLlwiO1xuY29uc3Qgbm9UYWdFcnJvck1zZyA9IFwiU2llIG3DvHNzZW4gbWluZGVzdGVucyBlaW4gVGFnIGFuZ2ViZW4sIGRhbWl0IGRhcyBFbGVtZW50IGluIFN1Y2h2b3Jnw6RuZ2VuIGdlZnVuZGVuIHdlcmRlbiBrYW5uLlwiO1xuY29uc3QgZXJyb3IgPSBcIkZlaGxlclwiO1xuY29uc3Qgd2FybmluZyA9IFwiV2FybnVuZ1wiO1xuY29uc3Qgc3VjY2VzcyA9IFwiRXJmb2xncmVpY2ggYWJnZXNjaGxvc3NlblwiO1xuY29uc3QgZGV0YWlscyA9IFwiRGV0YWlsczpcIjtcbmNvbnN0IHRyeUFnYWluID0gXCJFcm5ldXQgdmVyc3VjaGVuXCI7XG5jb25zdCB0b29sTW9kZWxlciA9IHtcblx0c2F2ZTogXCJTcGVpY2hlcm5cIixcblx0ZWRpdFByb3BlcnRpZXM6IFwiRWlnZW5zY2hhZnRlbiBiZWFyYmVpdGVuXCIsXG5cdHNhdmVBczogXCJTcGVpY2hlcm4gYWxzXCIsXG5cdHNhdmluZ05vdGlmaWNhdGlvbjogXCLDhG5kZXJ1bmdlbiBhbSBFbGVtZW50IHdlcmRlbiBnZXNwZWljaGVydC4uLlwiLFxuXHRzYXZpbmdUaXRsZTogXCJXaXJkIGdlc3BlaWNoZXJ0XCIsXG5cdHNhdmVGYWlsZWRNZXNzYWdlOiBcIsOEbmRlcnVuZ2VuIGtvbm50ZW4gbmljaHQgZ2VzcGVpY2hlcnQgd2VyZGVuLlwiLFxuXHRzYXZlV2l0aEVycm9yc01lc3NhZ2U6IFwiRGllIMOEbmRlcnVuZ2VuIHd1cmRlbiBtaXQgZGVuIGZvbGdlbmRlbiBGZWhsZXJuIGdlc3BlaWNoZXJ0LlwiLFxuXHR2aWV3SXRlbU1lc3NhZ2U6IFwiRGFzIGdlc3BlaWNoZXJ0ZSBFbGVtZW50XCIsXG5cdGhlcmU6IFwiaGllciBhbnplaWdlbi5cIixcblx0aXRlbUNyZWF0ZWRNZXNzYWdlOiBcIkVzIHd1cmRlIGVpbiBuZXVlcyBFbGVtZW50IGVyc3RlbGx0LlwiLFxuXHRjbGlja1RvVmlld0l0ZW1NZXNzYWdlOiBcIktsaWNrZW4gU2llIGF1ZiBcXFwiT0tcXFwiLCB1bSBkaWUgRWxlbWVudGRldGFpbHNlaXRlIGFuenV6ZWlnZW4uIEtsaWNrZW4gU2llIGF1ZiBcXFwiQWJicmVjaGVuXFxcIiwgdW0gZm9ydHp1ZmFocmVuLlwiLFxuXHRyZWFkaW5nRmFpbGVkOiBcIkRpZSBhdXNnZXfDpGhsdGUgUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2Uga29ubnRlIG5pY2h0IGdlbGFkZW4gd2VyZGVuLlwiLFxuXHRmYWlsZWRUb0xvYWRYTUw6IFwiRGllIGF1c2dld8OkaGx0ZSBSYXN0ZXItRnVua3Rpb25zdm9ybGFnZSBrb25udGUgaW0gWE1MLUZvcm1hdCBuaWNodCBnZWxhZGVuIHdlcmRlbi5cIixcblx0bGVhcm5Nb3JlOiBcIldlaXRlcmUgSW5mb3JtYXRpb25lblwiLFxuXHRvdmVyd3JpdGVUaXRsZTogXCLDnGJlcnNjaHJlaWJlbiBiZXN0w6R0aWdlblwiLFxuXHRvdmVyd3JpdGVNZXNzYWdlOiBcIk3DtmNodGVuIFNpZSBkYXMgdm9yaGFuZGVuZSBFbGVtZW50IMO8YmVyc2NocmVpYmVuP1wiLFxuXHRvdmVyd3JpdGVTdWNjZXNzTWVzc2FnZTogXCJEYXMgRWxlbWVudCB3dXJkZSBha3R1YWxpc2llcnQuXCJcbn07XG5jb25zdCB0b29sRWRpdG9yID0ge1xuXHRydW46IFwiQXVzZsO8aHJlblwiLFxuXHRzYXZlOiBcIlNwZWljaGVyblwiLFxuXHRkZWxldGVTZWxlY3RlZDogXCJBdXNnZXfDpGhsdGUgRWxlbWVudGUgbMO2c2NoZW5cIixcblx0YWRkUmFzdGVyOiBcIlJhc3RlciBoaW56dWbDvGdlblwiLFxuXHRhZGRTY2FsYXI6IFwiU2thbGFyIGhpbnp1ZsO8Z2VuXCIsXG5cdGxheW91dDogXCJBdXRvbGF5b3V0XCIsXG5cdGVycm9yVGl0bGU6IFwiRmVobGVyXCIsXG5cdGludmFsaWRUb29sTWVzc2FnZTogXCJEaWUgUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2UgaXN0IHVuZ8O8bHRpZy5cIixcblx0b3V0OiBcIkF1c1wiLFxuXHR6b29tSW46IFwiVmVyZ3LDtsOfZXJuXCIsXG5cdHpvb21PdXQ6IFwiVmVya2xlaW5lcm5cIixcblx0em9vbVRvRml0OiBcIkFuIEZlbnN0ZXIgYW5wYXNzZW5cIixcblx0cGFuT246IFwiWnVtIE1vZHVzIFxcXCJTY2h3ZW5rZW5cXFwiIHdlY2hzZWxuXCIsXG5cdHBhbk9mZjogXCJNb2R1cyBcXFwiU2Nod2Vua2VuXFxcIiBkZWFrdGl2aWVyZW5cIixcblx0ZGVmYXVsdE1vZGVsTmFtZTogXCJXZXJremV1Z21vZGVsbFwiLFxuXHRkZWZhdWx0UmFzdGVyTmFtZTogXCJSYXN0ZXJcIlxufTtcbmNvbnN0IHRvb2xEZXRhaWxzRWRpdG9yID0ge1xuXHRkZWZhdWx0VG9vbE5hbWU6IFwiUmFzdGVyLUZ1bmt0aW9uc3ZvcmxhZ2VcIixcblx0ZGVmYXVsdFRvb2xEZXNjcmlwdGlvbjogXCJGw7xnZW4gU2llIGVpbmUga3VyemUgWnVzYW1tZW5mYXNzdW5nIGRlciBSYXN0ZXItRnVua3Rpb24gaGluenUuXCIsXG5cdGRlZmF1bHRIZWxwVGV4dDogXCJLbGlja2VuIFNpZSBhdWYgZGFzIEhpbGZlLVN5bWJvbCwgdW0gZGVuIEhpbGZldGV4dCB6dSBiZWFyYmVpdGVuXCIsXG5cdGVkaXRIZWxwVGl0bGU6IFwiSGlsZmUgYmVhcmJlaXRlblwiLFxuXHRzYXZlTGFiZWw6IFwiU3BlaWNoZXJuXCIsXG5cdGNhbmNlbExhYmVsOiBcIkFiYnJlY2hlblwiLFxuXHR0aHVtYm5haWw6IHtcblx0XHR3cm9uZ0ltYWdlVHlwZTogXCJGYWxzY2hlciBCaWxkdHlwIGF1c2dld8OkaGx0XCIsXG5cdFx0bm90QXZhaWxhYmxlOiBcIk1pbmlhdHVyYW5zaWNodCBuaWNodCB2ZXJmw7xnYmFyXCIsXG5cdFx0bG9hZEVycm9yOiBcIkJpbGQga29ubnRlIG5pY2h0IGdlbGFkZW4gd2VyZGVuXCIsXG5cdFx0Y2hvb3NlRmlsZTogXCJadW0gQXVzd8OkaGxlbiBlaW5lciBEYXRlaSBrbGlja2VuXCJcblx0fVxufTtcbmNvbnN0IHNhdmVVdGlscyA9IHtcblx0dGh1bWJuYWlsOiBcIk1pbmlhdHVyYW5zaWNodFwiLFxuXHRzaGFyaW5nOiBcIkZyZWlnZWJlblwiXG59O1xuY29uc3QgY2xvc2UgPSBcIlNjaGxpZcOfZW5cIjtcbmNvbnN0IHVuc2F2ZWRXYXJuaW5nRXhpc3RpbmcgPSBcIk3DtmNodGVuIFNpZSBkaWUgw4RuZGVydW5nZW4gc3BlaWNoZXJuLCBkaWUgYW0gRWxlbWVudCA8Yj4ke2l0ZW1UaXRsZX08L2I+IHZvcmdlbm9tbWVuIHd1cmRlbj9cIjtcbmNvbnN0IHVuc2F2ZWRXYXJuaW5nTmV3ID0gXCJNw7ZjaHRlbiBTaWUgZGllIMOEbmRlcnVuZ2VuIHNwZWljaGVybj9cIjtcbmNvbnN0IHNhdmVBcyA9IFwiU3BlaWNoZXJuIGFsc1wiO1xuY29uc3QgZG9udFNhdmUgPSBcIk5pY2h0IHNwZWljaGVyblwiO1xuY29uc3QgdW5zYXZlZFRpdGxlID0gXCJOaWNodCBnZXNwZWljaGVydGUgw4RuZGVydW5nZW5cIjtcbmNvbnN0IGludmFsaWRSRlRNZXNzYWdlID0gXCJEaWUgZXJzdGVsbHRlIFJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlIGlzdCB1bmfDvGx0aWcuXCI7XG5jb25zdCBlcnJvclRpdGxlID0gXCJGZWhsZXJcIjtcbmNvbnN0IGJyZWFkY3J1bWIgPSBcIlJhc3Rlci1GdW5rdGlvbnMtRWRpdG9yXCI7XG5jb25zdCBicmVhZGNydW1iRWRpdG9yID0gXCJJbmhhbHQgPiBSYXN0ZXItRnVua3Rpb25zLUVkaXRvclwiO1xuY29uc3Qgdmlld2VyTW9kZVRpdGxlID0gXCJTY2hyZWliZ2VzY2jDvHR6dFwiO1xuY29uc3Qgdmlld2VyTW9kZU1lc3NhZ2UgPSBcIkRpZSBWb3JsYWdlbmVsZW1lbnQgZsO8ciBSYXN0ZXItRnVua3Rpb25lbiBpc3Qgc2NocmVpYmdlc2Now7x0enQuIMOEbmRlcnVuZ2VuIGvDtm5uZW4gbmljaHQgZ2VzcGVpY2hlcnQgd2VyZGVuLlwiO1xuY29uc3QgdXNlclN0YXJ0RGlyZWN0aW9uID0gXCJXw6RobGVuIFNpZSBlaW5lIEZ1bmt0aW9uIGF1cywgdW0gbWl0IGRlciBFcnN0ZWxsdW5nIGVpbmVyIFJhc3Rlci1GdW5rdGlvbnN2b3JsYWdlIHp1IGJlZ2lubmVuLlwiO1xuY29uc3Qgc2VsZWN0RnVuY3Rpb24gPSBcIkZ1bmt0aW9uIGhpbnp1ZsO8Z2VuXCI7XG5jb25zdCBkZXNlbGVjdEZ1bmN0aW9uID0gXCJGdW5rdGlvbiBlbnRmZXJuZW5cIjtcbmNvbnN0IGRpYWxvZ1RpdGxlID0gXCJTeXN0ZW1cIjtcbmNvbnN0IGNhdGVnb3J5ID0gXCJLYXRlZ29yaWVuXCI7XG5jb25zdCBzZWFyY2ggPSBcIlJhc3Rlci1GdW5rdGlvbmVuIGR1cmNoc3VjaGVuXCI7XG5jb25zdCBjYXRlZ29yeU5hbWVzID0ge1xuXHRhbmFseXNpczogXCJBbmFseXNlXCIsXG5cdGFwcGVhcmFuY2U6IFwiQXVzc2VoZW5cIixcblx0Y2xhc3NpZmljYXRpb246IFwiS2xhc3NpZml6aWVydW5nXCIsXG5cdGNvbnZlcnNpb246IFwiS29udmVydGllcnVuZ1wiLFxuXHRjb3JyZWN0aW9uOiBcIktvcnJla3R1clwiLFxuXHRkYXRhTWFuYWdlbWVudDogXCJEYXRlbm1hbmFnZW1lbnRcIixcblx0ZGlzdGFuY2U6IFwiRW50ZmVybnVuZ1wiLFxuXHRkaXN0YW5jZUxlZ2FjeTogXCJFbnRmZXJudW5nIChMZWdhY3kpXCIsXG5cdGh5ZHJvbG9neTogXCJIeWRyb2xvZ2llXCIsXG5cdG1hdGg6IFwiTWF0aGVtYXRpa1wiLFxuXHRtYXRoQ29uZGl0aW9uYWw6IFwiTWF0aGVtYXRpazogS29uZGl0aW9uYWxcIixcblx0bWF0aExvZ2ljYWw6IFwiTWF0aGVtYXRpazogTG9naXNjaFwiLFxuXHRtYXRoVHJpZ29ub21ldHJpYzogXCJNYXRoZW1hdGlrOiBUcmlnb25vbWV0cmlzY2hcIixcblx0cmVjbGFzczogXCJSZWtsYXNzaWZpemllcmVuXCIsXG5cdHN0YXRpc3RpY2FsOiBcIlN0YXRpc3Rpc2NoXCIsXG5cdHN1cmZhY2U6IFwiT2JlcmZsw6RjaGVcIlxufTtcbmNvbnN0IGNvbW1vblN0cmluZ3NfZGUgPSB7XG5cdG9rOiBvayxcblx0Y2FuY2VsOiBjYW5jZWwsXG5cdGVudGVyVVJMOiBlbnRlclVSTCxcblx0c2VydmljZVVSTDogc2VydmljZVVSTCxcblx0c2VsZWN0UmFzdGVyOiBzZWxlY3RSYXN0ZXIsXG5cdGZhaWxlZFRvTG9hZExheWVyOiBmYWlsZWRUb0xvYWRMYXllcixcblx0bG9hZGluZ0xheWVyOiBsb2FkaW5nTGF5ZXIsXG5cdHNlbGVjdEZlYXR1cmU6IHNlbGVjdEZlYXR1cmUsXG5cdGVudGVyRlVSTDogZW50ZXJGVVJMLFxuXHRhZGRSYXN0ZXI6IGFkZFJhc3Rlcixcblx0YWRkU2NhbGFyOiBhZGRTY2FsYXIsXG5cdHJhc3RlcjogcmFzdGVyLFxuXHRzY2FsYXI6IHNjYWxhcixcblx0ZGVmYXVsdE1vZGVsTmFtZTogZGVmYXVsdE1vZGVsTmFtZSxcblx0Z2VuZXJhbDogZ2VuZXJhbCxcblx0cGFyYW1ldGVyczogcGFyYW1ldGVycyxcblx0dmFyaWFibGVzOiB2YXJpYWJsZXMsXG5cdG5hbWU6IG5hbWUsXG5cdGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcblx0cGFyYW1ldGVyOiBwYXJhbWV0ZXIsXG5cdGlzUHVibGljOiBpc1B1YmxpYyxcblx0aXNEYXRhc2V0OiBpc0RhdGFzZXQsXG5cdHVua25vd25QaXhlbFR5cGU6IHVua25vd25QaXhlbFR5cGUsXG5cdG91dHB1dFBpeGVsVHlwZTogb3V0cHV0UGl4ZWxUeXBlLFxuXHR1OFBpeGVsVHlwZTogdThQaXhlbFR5cGUsXG5cdHM4UGl4ZWxUeXBlOiBzOFBpeGVsVHlwZSxcblx0dTE2UGl4ZWxUeXBlOiB1MTZQaXhlbFR5cGUsXG5cdHMxNlBpeGVsVHlwZTogczE2UGl4ZWxUeXBlLFxuXHR1MzJQaXhlbFR5cGU6IHUzMlBpeGVsVHlwZSxcblx0czMyUGl4ZWxUeXBlOiBzMzJQaXhlbFR5cGUsXG5cdGYzMlBpeGVsVHlwZTogZjMyUGl4ZWxUeXBlLFxuXHRmNjRQaXhlbFR5cGU6IGY2NFBpeGVsVHlwZSxcblx0cHJvcGVydGllczogcHJvcGVydGllcyxcblx0bXVsdGlkaW1lbnNpb25hbFJ1bGVzOiBtdWx0aWRpbWVuc2lvbmFsUnVsZXMsXG5cdG1hdGNoVmFyaWFibGVzOiBtYXRjaFZhcmlhYmxlcyxcblx0dW5pb25EaW1lbnNpb25zOiB1bmlvbkRpbWVuc2lvbnMsXG5cdHJhc3RlckZ1bmN0aW9uRWRpdG9yOiByYXN0ZXJGdW5jdGlvbkVkaXRvcixcblx0cmZ4TGljZW5zZUluZm86IHJmeExpY2Vuc2VJbmZvLFxuXHRyYXN0ZXJGdW5jdGlvbnM6IHJhc3RlckZ1bmN0aW9ucyxcblx0Y29weTogY29weSxcblx0c2F2ZTogc2F2ZSxcblx0dGl0bGU6IHRpdGxlLFxuXHRmb2xkZXI6IGZvbGRlcixcblx0dGFnczogdGFncyxcblx0c2F2aW5nTWVzc2FnZTogc2F2aW5nTWVzc2FnZSxcblx0c2hhcmVXaXRoOiBzaGFyZVdpdGgsXG5cdHNoYXJlOiBzaGFyZSxcblx0c2V0U2hhcmluZ0xldmVsOiBzZXRTaGFyaW5nTGV2ZWwsXG5cdHNldEdyb3VwU2hhcmluZzogc2V0R3JvdXBTaGFyaW5nLFxuXHRvd25lcjogb3duZXIsXG5cdG9yZ2FuaXphdGlvbjogb3JnYW5pemF0aW9uLFxuXHRldmVyeW9uZTogZXZlcnlvbmUsXG5cdGdyb3VwczogZ3JvdXBzLFxuXHR0eXBlOiB0eXBlLFxuXHRtb3NhaWM6IG1vc2FpYyxcblx0aXRlbUdyb3VwOiBpdGVtR3JvdXAsXG5cdGl0ZW06IGl0ZW0sXG5cdGRlZmluaXRpb25RdWVyeTogZGVmaW5pdGlvblF1ZXJ5LFxuXHRncm91cEl0ZW1zQnk6IGdyb3VwSXRlbXNCeSxcblx0Z3JvdXBGaWVsZE5hbWU6IGdyb3VwRmllbGROYW1lLFxuXHR0YWdGaWVsZE5hbWU6IHRhZ0ZpZWxkTmFtZSxcblx0bm9UaXRsZVRhZ0Vycm9yTXNnOiBub1RpdGxlVGFnRXJyb3JNc2csXG5cdG5vVGl0bGVFcnJvck1zZzogbm9UaXRsZUVycm9yTXNnLFxuXHRub1RhZ0Vycm9yTXNnOiBub1RhZ0Vycm9yTXNnLFxuXHRlcnJvcjogZXJyb3IsXG5cdHdhcm5pbmc6IHdhcm5pbmcsXG5cdHN1Y2Nlc3M6IHN1Y2Nlc3MsXG5cdGRldGFpbHM6IGRldGFpbHMsXG5cdHRyeUFnYWluOiB0cnlBZ2Fpbixcblx0dG9vbE1vZGVsZXI6IHRvb2xNb2RlbGVyLFxuXHR0b29sRWRpdG9yOiB0b29sRWRpdG9yLFxuXHR0b29sRGV0YWlsc0VkaXRvcjogdG9vbERldGFpbHNFZGl0b3IsXG5cdHNhdmVVdGlsczogc2F2ZVV0aWxzLFxuXHRjbG9zZTogY2xvc2UsXG5cdHVuc2F2ZWRXYXJuaW5nRXhpc3Rpbmc6IHVuc2F2ZWRXYXJuaW5nRXhpc3RpbmcsXG5cdHVuc2F2ZWRXYXJuaW5nTmV3OiB1bnNhdmVkV2FybmluZ05ldyxcblx0c2F2ZUFzOiBzYXZlQXMsXG5cdGRvbnRTYXZlOiBkb250U2F2ZSxcblx0dW5zYXZlZFRpdGxlOiB1bnNhdmVkVGl0bGUsXG5cdGludmFsaWRSRlRNZXNzYWdlOiBpbnZhbGlkUkZUTWVzc2FnZSxcblx0ZXJyb3JUaXRsZTogZXJyb3JUaXRsZSxcblx0YnJlYWRjcnVtYjogYnJlYWRjcnVtYixcblx0YnJlYWRjcnVtYkVkaXRvcjogYnJlYWRjcnVtYkVkaXRvcixcblx0dmlld2VyTW9kZVRpdGxlOiB2aWV3ZXJNb2RlVGl0bGUsXG5cdHZpZXdlck1vZGVNZXNzYWdlOiB2aWV3ZXJNb2RlTWVzc2FnZSxcblx0dXNlclN0YXJ0RGlyZWN0aW9uOiB1c2VyU3RhcnREaXJlY3Rpb24sXG5cdHNlbGVjdEZ1bmN0aW9uOiBzZWxlY3RGdW5jdGlvbixcblx0ZGVzZWxlY3RGdW5jdGlvbjogZGVzZWxlY3RGdW5jdGlvbixcblx0ZGlhbG9nVGl0bGU6IGRpYWxvZ1RpdGxlLFxuXHRjYXRlZ29yeTogY2F0ZWdvcnksXG5cdHNlYXJjaDogc2VhcmNoLFxuXHRjYXRlZ29yeU5hbWVzOiBjYXRlZ29yeU5hbWVzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb21tb25TdHJpbmdzX2RlO1xuZXhwb3J0IHsgYWRkUmFzdGVyLCBhZGRTY2FsYXIsIGJyZWFkY3J1bWIsIGJyZWFkY3J1bWJFZGl0b3IsIGNhbmNlbCwgY2F0ZWdvcnksIGNhdGVnb3J5TmFtZXMsIGNsb3NlLCBjb3B5LCBkZWZhdWx0TW9kZWxOYW1lLCBkZWZpbml0aW9uUXVlcnksIGRlc2NyaXB0aW9uLCBkZXNlbGVjdEZ1bmN0aW9uLCBkZXRhaWxzLCBkaWFsb2dUaXRsZSwgZG9udFNhdmUsIGVudGVyRlVSTCwgZW50ZXJVUkwsIGVycm9yLCBlcnJvclRpdGxlLCBldmVyeW9uZSwgZjMyUGl4ZWxUeXBlLCBmNjRQaXhlbFR5cGUsIGZhaWxlZFRvTG9hZExheWVyLCBmb2xkZXIsIGdlbmVyYWwsIGdyb3VwRmllbGROYW1lLCBncm91cEl0ZW1zQnksIGdyb3VwcywgaW52YWxpZFJGVE1lc3NhZ2UsIGlzRGF0YXNldCwgaXNQdWJsaWMsIGl0ZW0sIGl0ZW1Hcm91cCwgbG9hZGluZ0xheWVyLCBtYXRjaFZhcmlhYmxlcywgbW9zYWljLCBtdWx0aWRpbWVuc2lvbmFsUnVsZXMsIG5hbWUsIG5vVGFnRXJyb3JNc2csIG5vVGl0bGVFcnJvck1zZywgbm9UaXRsZVRhZ0Vycm9yTXNnLCBvaywgb3JnYW5pemF0aW9uLCBvdXRwdXRQaXhlbFR5cGUsIG93bmVyLCBwYXJhbWV0ZXIsIHBhcmFtZXRlcnMsIHByb3BlcnRpZXMsIHJhc3RlciwgcmFzdGVyRnVuY3Rpb25FZGl0b3IsIHJhc3RlckZ1bmN0aW9ucywgcmZ4TGljZW5zZUluZm8sIHMxNlBpeGVsVHlwZSwgczMyUGl4ZWxUeXBlLCBzOFBpeGVsVHlwZSwgc2F2ZSwgc2F2ZUFzLCBzYXZlVXRpbHMsIHNhdmluZ01lc3NhZ2UsIHNjYWxhciwgc2VhcmNoLCBzZWxlY3RGZWF0dXJlLCBzZWxlY3RGdW5jdGlvbiwgc2VsZWN0UmFzdGVyLCBzZXJ2aWNlVVJMLCBzZXRHcm91cFNoYXJpbmcsIHNldFNoYXJpbmdMZXZlbCwgc2hhcmUsIHNoYXJlV2l0aCwgc3VjY2VzcywgdGFnRmllbGROYW1lLCB0YWdzLCB0aXRsZSwgdG9vbERldGFpbHNFZGl0b3IsIHRvb2xFZGl0b3IsIHRvb2xNb2RlbGVyLCB0cnlBZ2FpbiwgdHlwZSwgdTE2UGl4ZWxUeXBlLCB1MzJQaXhlbFR5cGUsIHU4UGl4ZWxUeXBlLCB1bmlvbkRpbWVuc2lvbnMsIHVua25vd25QaXhlbFR5cGUsIHVuc2F2ZWRUaXRsZSwgdW5zYXZlZFdhcm5pbmdFeGlzdGluZywgdW5zYXZlZFdhcm5pbmdOZXcsIHVzZXJTdGFydERpcmVjdGlvbiwgdmFyaWFibGVzLCB2aWV3ZXJNb2RlTWVzc2FnZSwgdmlld2VyTW9kZVRpdGxlLCB3YXJuaW5nIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi1zdHJpbmdzLmRlLTE0NTRmNDM0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==