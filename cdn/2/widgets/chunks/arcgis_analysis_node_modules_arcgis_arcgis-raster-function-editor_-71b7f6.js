"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-71b7f6"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.it-efba6f9b.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.it-efba6f9b.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "OK";
const cancel = "Cancella";
const enterURL = "Inserire l’URL dell’image service";
const serviceURL = "URL di Servizio";
const selectRaster = "Seleziona raster";
const failedToLoadLayer = "Impossibile caricare il layer";
const loadingLayer = "Caricamento layer";
const selectFeature = "Seleziona feature layer";
const enterFURL = "Immetti URL feature service";
const addRaster = "Aggiungi variabile raster";
const addScalar = "Aggiungi costante";
const raster = "Raster";
const scalar = "Scalare";
const defaultModelName = "Modello funzione raster";
const general = "Generale";
const parameters = "Parametri";
const variables = "Variabili";
const name = "Nome";
const description = "Descrizione";
const parameter = "Parametro";
const isPublic = "IsPublic";
const isDataset = "IsDataset";
const unknownPixelType = "Sconosciuto";
const outputPixelType = "Tipo di pixel di output";
const u8PixelType = "8 bit senza segno";
const s8PixelType = "8 bit con segno";
const u16PixelType = "16 bit senza segno";
const s16PixelType = "16 bit con segno";
const u32PixelType = "32 bit senza segno";
const s32PixelType = "32 bit con segno";
const f32PixelType = "32 bit a virgola mobile";
const f64PixelType = "64 bit doppio";
const properties = "Proprietà";
const multidimensionalRules = "Regole multidimensionali";
const matchVariables = "Far corrispondere variabili.";
const unionDimensions = "Dimensioni unione";
const rasterFunctionEditor = {
	invalidRFTMessage: "Modello di funzione raster non valido.",
	rfxArgsEditor: {
		outputRaster: "Raster di Output",
		raster: "Raster",
		unsupportedDataTypeWarning: "Gli argomenti seguenti non vengono visualizzati perché non sono supportati.",
		unsupportedFunction: "Contiene le funzioni raster attualmente non supportate."
	},
	rfxRasterInput: {
		selectLayer: "Seleziona layer",
		browseLayers: "Sfoglia layer",
		rfxVariable: "RasterFunctionVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Metodo",
		bandLabel: "Banda",
		combinationLabel: "Combinazione"
	},
	rfxRemapGrid: {
		minimum: "Minimo",
		maximum: "Massimo",
		output: "Output",
		noData: "NoData",
		remapValuesLabel: "Rimappa valori"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Variabili raster",
		deleteSelectedVars: "Rimuovi le variabili selezionate"
	},
	rfxClippingGeometry: {
		clippingLayer: "Layer di ritaglio",
		clippingRaster: "Raster Clipping",
		clippingGeometry: "Geometria di ritaglio",
		customExtent: "Estensione personalizzata",
		outputExtent: "Estensione di output",
		currentExtent: "Estensione mappa corrente",
		drawLabel: "Disegna"
	},
	rfxCustomExtent: {
		top: "In alto",
		right: "Destra",
		bottom: "In basso",
		left: "Sinistra"
	},
	rfxRasterArrayEditor: {
		moveUp: "Sposta su",
		moveDown: "Sposta giù",
		remove: "Rimuovi"
	},
	rfxStatisticsGrid: {
		stdDev: "Deviazione Standard",
		min: "Minima",
		max: "Massima",
		mean: "Medio"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Tabella di somma pesata",
		id: "ID",
		layer: "Layer",
		field: "Campo",
		weight: "Peso",
		value: "Valore",
		selectLayer: "Seleziona layer"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Tabella di sovrapposizione pesata",
		id: "ID",
		layer: "Layer",
		field: "Campo",
		influence: "Influenza",
		sumOfInfluence: "Somma di influenza",
		value: "Valore",
		remapTable: "Rimappa tabella",
		scale: "Scala",
		scales: "Scale",
		selectRaster: "Seleziona raster"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Cerca un feature layer",
		addPointLayer: "Cerca un layer puntuale"
	},
	rfxFieldSelect: {
		value: "Valore",
		count: "Conteggio"
	},
	rfxAttributeTable: {
		tableType: "Tipo di tabella",
		manual: "Manuale",
		external: "Esterno",
		minVal: "Valore minimo",
		maxVal: "Valore massimo",
		baseClassName: "Nome base classe",
		colorScheme: "Schema colori",
		defaultClassName: "Etichetta_",
		generateTable: "Genera tabella",
		browseTable: "Esamina tabella",
		value: "Valore",
		classname: "ClassName",
		color: "Colore"
	},
	rfxFieldNumberSwitchable: {
		number: "Numerico",
		field: "Campo",
		string: "Stringa",
		linearUnit: "Unità lineare"
	},
	rfxPropertySet: {
		name: "Nome",
		value: "Valore"
	},
	rfxConversionGrid: {
		size: "Dimensione"
	},
	rfxTransposeBit: {
		bitPattern: "Schema bit",
		outputBit: "Bit di output",
		inputBit: "Bit di input"
	},
	rfxSpatialReference: {
		placeHolder: "Perfeziona per parola chiave",
		coordinateSystem: "Sistema di coordinate",
		gcs: "Sistema di coordinate geografiche",
		pcs: "Sistema di coordinate proiettato",
		vcs: "Sistema di coordinate verticali"
	}
};
const rfxLicenseInfo = "Questo modello di funzione raster può essere usato per elaborare le immagini utilizzando ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "ACosH",
		aCosHSnip: "Calcola il coseno iperbolico inverso di celle in un raster",
		aCosHDesc: "La funzione calcola il coseno iperbolico inverso dei pixel in un raster.",
		aCosName: "ACos",
		aCosSnip: "Calcola il coseno inverso dei pixel in un raster.",
		aCosDesc: "Questa funzione raster calcola il coseno inverso delle celle in un raster. In matematica, tutte le funzioni trigonometriche hanno una gamma definita di valori di input validi, chiamata il dominio. Anche i valori di output di ciascuna funzione hanno una gamma definita. Per questo strumento, il dominio è [-1, 1] e l’intervallo è [0, pi].",
		aSinHName: "ASinH",
		aSinHSnip: "Calcola il seno iperbolico inverso di celle in un raster.",
		aSinHDesc: "La funzione calcola il seno iperbolico inverso dei pixel in un raster.",
		aSinName: "ASin",
		aSinSnip: "Calcola il seno inverso di celle in un raster.",
		aSinDesc: "La funzione calcola il seno inverso dei pixel in un raster.",
		aTan2Name: "ATan2",
		aTan2Snip: "Calcola la tangente inversa (basata su x,y) delle celle in un raster.",
		aTan2Desc: "La funzione calcola la tangente inversa (basata su x,y) dei pixel in un raster.",
		aTanHName: "ATanH",
		aTanHSnip: "Calcola la tangente iperbolica inversa di celle in un raster.",
		aTanHDesc: "La funzione calcola la tangente iperbolica inversa dei pixel in un raster.",
		aTanName: "ATan",
		aTanSnip: "Calcola la tangente inversa di celle in un raster.",
		aTanDesc: "La funzione calcola la tangente inversa dei pixel in un raster.",
		absName: "Abs",
		absSnip: "Calcola il valore assoluto delle celle in un raster.",
		absDesc: "La funzione Abs calcola il valore assoluto dei pixel in un raster.",
		reflectanceName: "Riflettanza apparente",
		reflectanceSnip: "Converte immagini originali in valori Massimo dell'atmosfera prendendo in considerazione le caratteristiche del sensore, la posizione del sole e il tempo di acquisizione.",
		reflectanceDesc: "Questa funzione regola i valori di numero digitale (DN) della luminosità di immagine per alcuni sensori di satelliti. Le regolazioni si basano sull'elevazione del sole, la data di acquisizione e le proprietà del sensore per impostare il guadagno e il fattore di disturbo per ogni banda. Questa funzione viene usata per regolare i valori di riflettanza, o luminosità, di alcune immagini di satelliti in base alle impostazioni di illuminazione della scena e di guadagno del sensore. Le immagini vengono regolate su una condizione di illuminazione teoricamente comune, il che comporta presumibilmente una minore variazione tra scene da date diverse e sensori diversi. Ciò può essere utile per la classificazione delle immagini, il bilanciamento del colore e la creazione di un mosaico. Questa funzione può essere usata solo con immagini specifiche. I sensori applicabili sono Landsat MSS, Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 e Pleiades.<div><br/>La funzione esegue due correzioni. La prima si basa sulle impostazioni del fattore di guadagno. I valori originali di luminosità sono ricreati dai valori dell'immagine invertendo le equazioni del fattore di guadagno. La seconda correzione riguarda le differenze di angolazione del sole e luminosità. I valori originali di luminosità sono regolati su una condizione comune di illuminazione normalizzando scene acquisite in condizioni variabili di illuminazione. In generale, mentre il tipo di dati dell'immagine di output è lo stesso di quello dell'immagine di input, i valori di output sono inferiori ai valori di input e sono ritagliati nell'intervallo di dati validi.</div>",
		argStatisticsName: "ArgStatistics",
		argStatisticsSnip: "Calcola le statistiche degli argomenti, inclusi Arg Max, Arg Min, Arg Median e Duration.",
		argStatisticsDesc: "La funzione calcola le statistiche degli argomenti. Esistono quattro metodi nella funzione ArgStatistics: ArgMax, ArgMin, ArgMedian e Durata.",
		arithmeticName: "Aritmetico",
		arithmeticSnip: "Esegue un'operazione aritmetica tra due raster o un raster e uno scalare.",
		arithmeticDesc: "La funzione Aritmetica esegue un’operazione aritmetica tra due raster o tra un raster e uno scalare e viceversa.",
		aspectSlopeName: "Aspetto-Sezione",
		aspectSlopeSnip: "Crea un raster che visualizza simultaneamente l'aspetto (direzione) e la sezione (ripidezza) di una superficie continua, come rappresentata in un modello di elevazione digitale.",
		aspectSlopeDesc: "La funzione Aspetto-Pendenza crea un layer raster che visualizza simultaneamente l’aspetto e la pendenza di una superficie. L'aspetto identifica la direzione con la massima percentuale di variazione in discesa da un pixel a quelli vicini. L'aspetto può essere considerato come la direzione della pendenza. I valori del raster di output saranno la direzione della bussola dell’aspetto, rappresentata da una tonalità (colore). La pendenza rappresenta la percentuale di variazione dell'elevazione per ogni pixel del modello di elevazione digitale (DEM). La pendenza rappresenta la ripidezza della superficie ed è simboleggiata da tre classi mostrate mediante la saturazione del colore (luminosità).<div><br/>I valori dei pixel nel raster di output aspetto-pendenza rispecchiano la combinazione di aspetto e pendenza. I pixel con valori inferiori a 20 sono considerati piatti e visualizzati in grigio. I valori di aspetto-pendenza pari o superiori a 21 saranno visualizzati con diverse saturazioni, come segue: da 21 a 30 —saturazione di pendenza bassa; da 31 a 40—saturazione di pendenza moderata; da 41 in su—saturazione di pendenza elevata.</div>",
		aspectName: "Esposizione",
		aspectSnip: "Mostra la direzione verso la quale è rivolto un pixel, in cui 0 è verso nord e gli angoli aumentano in senso antiorario fino a 360.",
		aspectDesc: "La funzione Aspetto identifica la direzione con la massima percentuale di variazione in discesa da una cella a quelle vicine. L'aspetto può essere considerato come la direzione della pendenza. I valori del raster di output saranno la direzione della bussola dell'Aspect.<div><br/>L'input per questa funzione è Raster di input. La funzione Aspetto si applica spesso a un modello digitale di elevazione (DEM). Per impostazione predefinita, l'Aspetto appare come un'immagine in scala di grigi. È possibile aggiungere la funzione Colormap per specificare uno schema di colori particolare o per consentire alla persona che visualizza il mosaico di modificare la simbologia con il proprio schema di colori.</div>",
		tableName: "Tabella attributi",
		tableSnip: "Questa funzione utilizza una tabella per denominare e simboleggiare i valori in un dataset. Le colonne della tabella sono separate da virgole: PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "La funzione Tabella attributi consente di definire una tabella di attributi per simboleggiare un mosaic dataset a banda singola o un raster dataset. <div><br/>È utile quando si desidera presentare immagini sottoposte a classificazione per l'uso del suolo, come terreni forestali, zone umide, terreni coltivati e aree urbane. Inoltre, se la tabella contiene campi denominati rosso, verde e blu, i valori all'interno di tali campi verranno utilizzati come colormap durante il rendering dell'immagine.</div>",
		bandArithmeticName: "Aritmetica banda",
		bandArithmeticSnip: "Calcola gli indici utilizzando formule predefinite o un'espressione definita dall'utente.",
		bandArithmeticDesc: "La funzione Aritmetica Banda esegue un'operazione aritmetica sulle bande di un dataset raster. È possibile scegliere algoritmi predefiniti selezionabili oppure si può immettere la propria formula a riga singola. Gli operatori supportati sono -, +, /, * e - unario.",
		thresholdName: "Impostazione soglia binaria",
		thresholdSnip: "Organizza dati continui in primo piano e sullo sfondo minimizzando la covarianza tra le due classi.",
		thresholdDesc: "Quando un dataset raster ha una distribuzione bimodale, questa funzione crea un nuovo raster che divide i dati in due classi distinte. Viene creata una classe di valori bassi visualizzata con pixel neri e una classe di valori elevati visualizzata con pixel bianchi.",
		bitwiseAndName: "And Bitwise",
		bitwiseAndSnip: "Effettua una operazione bitwise And sui valori binari di due raster di input.",
		bitwiseAndDesc: "Bitwise And esegue un’operazione And a livello bit sui valori binari di due raster di input.",
		bitwiseLeftShiftName: "Spostamento a sinistra Bitwise",
		bitwiseLeftShiftSnip: "Esegue un'operazione bitwise Shift a sinistra sui valori binari di due raster di input.",
		bitwiseLeftShiftDesc: "Bitwise Left Shift esegue un'operazione di spostamento a sinistra a livello bit sui valori binari dei due raster di input.",
		bitwiseNotName: "Not Bitwise",
		bitwiseNotSnip: "Esegue un'operazione Not a livello bit (complemento) sul valore binario di un raster di input.",
		bitwiseNotDesc: "La funzione esegue un'operazione Not a livello bit (complemento) sul valore binario di un raster di input.",
		bitwiseOrName: "Or Bitwise",
		bitwiseOrSnip: "Esegue un'operazione bitwise Or sui valori binari dei due raster di input.",
		bitwiseOrDesc: "La funzione esegue un'operazione Or a livello bit sui valori binari dei due raster di input. ",
		bitwiseRightShiftName: "Spostamento a destra Bitwise",
		bitwiseRightShiftSnip: "Esegue un'operazione bitwise di di shift a destra sui valori binari dei due raster di input.",
		bitwiseRightShiftDesc: "La funzione esegue un'operazione di spostamento a destra a livello bit sui valori binari dei due raster di input.",
		bitwiseXorName: "Bitwise Xor",
		bitwiseXorSnip: "Esegue un'operazione bitwise Or esclusivo sui valori binari di due raster di input.",
		bitwiseXorDesc: "La funzione esegue un'operazione Or esclusivo a livello bit sui valori binari di due raster di input.",
		booleanAndName: "Boolean And",
		booleanAndSnip: "Esegue un'operazione And booleano sui valori delle celle di due raster di input. Se entrambi i valori di input sono true (non-zero), l’output è 1. Se uno o entrambi i valori di input sono false (zero), l'output è 0.",
		booleanAndDesc: "La funzione esegue un'operazione And booleano sui valori dei pixel di due raster di input. Se entrambi i valori di input sono true (non-zero), il valore di output è 1. Se uno o entrambi i valori di input sono false (zero), l'output è 0. ",
		booleanNotName: "No booleano",
		booleanNotSnip: "Esegue un'operazione Not booleano (complemento) sui valori delle celle del raster di input. Se i valori di input sono true (non-zero), il valore di output è 0. Se i valori di input sono false (zero), l’output è 1.",
		booleanNotDesc: "La funzione esegue un'operazione Not booleano (complemento) sui valori dei pixel del raster di input. Se i valori di input sono true (non-zero), il valore di output è 0. Se i valori di input sono false (zero), il valore di output è 1.",
		booleanOrName: "Boolean Or",
		booleanOrSnip: "Esegue un'operazione Or booleano sui valori delle celle di due raster di input. Se uno o entrambi i valori di input sono true (non-zero), il valore di output è 1. Se entrambi i valori di input sono false (zero), l’output è 0.",
		booleanOrDesc: "La funzione esegue un'operazione Or booleano sui valori delle celle di due raster di input. Se uno o entrambi i valori di input sono true (non-zero), il valore di output è 1. Se entrambi i valori di input sono false (zero), il valore di output è 0.",
		booleanXorName: "Boolean Xor",
		booleanXorSnip: "Esegue un'operazione eXclusive Or booleano sui valori delle celle di due raster di input. Se un valore di input è true (non-zero) e l'altro è false (zero), l’output è 1. Se i valori di input sono entrambi true o entrambi false, l’output è 0.",
		booleanXorDesc: "La funzione esegue un'operazione eXclusive Or booleano sui valori delle celle di due raster di input. Se un valore di input è true (non-zero) e l'altro valore è false (zero), il valore di output è 1. Se entrambi i valori di input sono true o entrambi sono false, il valore di output è 0.",
		bufferedRasterName: "Memorizzato nel buffer",
		bufferedRasterSnip: "Memorizza nel buffer gli ultimi blocchi di pixel aperti.",
		bufferedRasterDesc: "La funzione di buffer si usa per ottimizzare le prestazioni di catene complesse di funzioni. Archivia l'output in memoria della parte della catena di funzioni che la precede. <div><br/>Inserire questa funzione nell'Editor di funzioni in cui si desidera memorizzare l'output.</div>",
		rasterCalculatorName: "Calcolatore",
		rasterCalculatorSnip: "Calcola un raster da un'espressione matematica basata su raster.",
		rasterCalculatorDesc: "La funzione Calcolatore consente di creare ed eseguire espressioni e includerle in catene di funzioni.",
		cellStatisticsName: "Statistiche delle Celle",
		cellStatisticsSnip: "Calcola una statistica per cella da più raster. Le statistiche disponibili sono Maggioranza, Massimo, Media, Mediana, Minimo, Minoranza, Percentile, Intervallo, Deviazione standard, Somma e Varietà.",
		cellStatisticsDesc: "Questa funzione calcola statistiche da più raster in base ai singoli pixel. Le statistiche disponibili sono maggioranza, massimo, media, mediana, minimo, minoranza, intervallo, deviazione standard, somma e varietà.",
		classifyName: "Classifica",
		classifySnip: "Assegna ciascun pixel a una classe. Incorpora dati secondari come un'immagine segmentata.",
		classifyDesc: "Questa funzione raster classifica un dataset raster sulla base di un file di definizione del metodo di classificazione di Esri (.ecd) e dei dati immessi per il dataset raster. Il file .ecd usato nella funzione Classifica contiene tutte le informazioni relative a un dataset e a un classificatore specifici ed è generato dagli strumenti di addestramento alla classificazione, come il Computer Vettore di Supporto all'Addestramento o l’Addestramento Strutture Casuali.",
		clipName: "Clip",
		clipSnip: "Imposta l'estensione di un raster utilizzando coordinate o un altro dataset.",
		clipDesc: "Questa funzione ritaglia un raster usando una forma rettangolare in base alle estensioni definite oppure lo ritaglia in base alla forma di una feature class poligonale di input. La forma che definita dal ritaglio può essere il ritaglio dell'estensione del raster o l'estrazione di un'area all'interno raster.",
		colorspaceConversionName: "Conversione modello colore",
		colorspaceConversionSnip: "Converte un raster da RGB a HSV e viceversa.",
		colorspaceConversionDesc: "La funzione Conversione modello colore converte il modello del colore di un'immagine da uno spazio colore tonalità, saturazione e valore (HSV) a rosso, verde e blu (RGB), o viceversa.<div><br/>Questa funzione può essere usata solo in un Mosaic Dataset.</div>",
		colormapToRGBName: "Da mappa colori a RGB",
		colormapToRGBSnip: "Converte un raster a banda singola con una mappa colori in un raster a tre bande (rosso, verde e blu).",
		colormapToRGBDesc: "Questa funzione converte un raster a banda singola con una colormap in un raster a tre bande (rosso, verde e blu).<div><br/>Questa funzione è utile quando è necessario creare un raster a tre bande da un raster a banda singola con una colormap associata. I valori della colormap vengono utilizzati per creare ogni banda del rosso, verde e blu. Questa funzione può essere usata solo in un Mosaic Dataset.</div>",
		colormapName: "Colormap",
		colormapSnip: "Cambia i valori dei pixel per visualizzare i dati raster come scala di grigi o come immagine RGB (Rosso, Verde, Blu), in base a una mappa colori o una scala cromatica.",
		colormapDesc: "La funzione Colormap è un tipo di renderer dei dati raster. Trasforma i valori dei pixel per visualizzare i dati raster come una scala di grigi o come un'immagine a colori RGB basata su uno schema di colori o su specifici colori contenuti in un file colormap. È possibile usare una colormap per rappresentare i dati analizzati, come un’immagine classificata, o quando si visualizza una mappa topografica (o l’immagine di un indice digitalizzata a colori).<div><br/>Le colormap contengono un insieme di valori associati ai colori, usati per visualizzare un raster a banda singola in modo coerente con gli stessi colori. Il valore di ciascun pixel è associato a un colore, definito come un insieme di valori RGB. Le colormap sono in grado di supportare qualsiasi profondità bit a eccezione di quelle a virgola mobile. Inoltre, sono compatibili con valori positivi e negativi e possono contenere valori mappati mancanti. Quando si visualizza un dataset con una colormap contenente valori mancanti, i pixel con i valori mancanti non saranno visualizzati.</div>",
		complexName: "Complesso",
		complexSnip: "Estrae la grandezza da numeri complessi.",
		complexDesc: "Questa funzione calcola la grandezza da valori complessi.<div><br/>Questa funzione viene in genere utilizzata con immagini RADAR con un tipo di dati complessi. Può essere usata in un mosaic dataset.</div>",
		compositeBandName: "Bande Composite",
		compositeBandSnip: "Combina più dataset in un unico raster multibanda.",
		compositeBandDesc: "La funzione Bande composite consente di combinare raster per formare un’immagine multibanda.",
		conName: "Con",
		conSnip: "Esegue un’operazione If, Then, Else condizionale. Quando si utilizza un operatore Con, occorrono in genere due o più funzioni concatenate, in cui una funzione afferma i criteri e la seconda funzione è l’operatore Con che utilizza i criteri e indica quali devono essere le uscite true e false.",
		conDesc: "La funzione Con imposta i pixel del raster di output sulla base di una valutazione if\\else di ciascun pixel di input. Restituisce i valori dei pixel dal True Raster se la valutazione condizionale è true (1); restituisce i valori dei pixel dal False Raster se la valutazione condizionale è false (0). Questo criterio è specificato dall'output di una funzione matematica logica, che sarà il raster di input.",
		constantName: "Costante",
		constantSnip: "Crea un raster virtuale con un valore in pixel singolo.",
		constantDesc: "Questa funzione crea un raster virtuale con un valore pixel singolo utilizzabile in modelli di funzione raster e per elaborare un mosaic dataset.<div><br/>Il valore costante si usa per ogni valore pixel nel raster.</div>",
		contourName: "Contour",
		contourSnip: "Crea linee di contorno.",
		contourDesc: "La funzione Contour genera linee di contorno unendo punti con la stessa elevazione da un dataset di elevazione raster. I Contour sono isolinee create come raster per la visualizzazione. Questa funzione è resa potente dalle seguenti feature chiave: i Contour sono generati rapidamente e dinamicamente su dataset molto grandi, come Elevazione mondiale; i Contour possono essere smussati per fornire un aspetto cartografico più gradevole mantenendone al contempo la precisione; si dispone del controllo dinamico dell'intervallo dei Contour; le opzioni di output includono linee di Contour, Contour di indice e Contour riempiti.<div><br/>La creazione di un Contour Layer come prodotto raster è importante per un ampio spettro di applicazioni perché i contorni possono essere sovrapposti su una mappa e fornire informazioni sul suolo senza oscurare i dati sottostanti. Sono utili in applicazioni come applicazioni di ingegneria, agricoltura e gestione idrica.</div>",
		contrastBrightnessName: "Contrasto e luminosità",
		contrastBrightnessSnip: "Regola il contrasto e la luminosità di un raster.",
		contrastBrightnessDesc: "La funzione Contrasto e luminosità migliora l’aspetto dei dati raster modificando la luminosità o il contrasto nell’immagine. La luminosità aumenta la chiarezza complessiva dell'immagine—ad esempio, rendendo i colori scuri più chiari e i colori chiari più bianchi—mentre il contrasto regola la differenza tra i colori più scuri e quelli più chiari.<div><br/>L'uso di questa funzione altera i valori dei pixel; per questo motivo, la funzione deve essere utilizzata quando si desidera migliorare l'aspetto dei dati, ma non se si intende utilizzare i dati come parte di un'analisi che richiederebbe valori dei pixel non elaborati. Questa funzione è utile quando i dati vengono pubblicati come image service utilizzabili nelle applicazioni senza la possibilità di alterare il contrasto e la luminosità delle immagini, o per garantire che le immagini vengano visualizzate utilizzando le impostazioni predefinite.</div>",
		convolutionName: "Convoluzione",
		convolutionSnip: "Applica un filtro per rendere più nitido, sfocare, rilevare bordi, smussare o un gradiente su un raster.",
		convolutionDesc: "La funzione Convoluzione applica un filtro basato sui valori dei pixel in un’immagine, che può essere utilizzato per eseguire lo sharpening o la sfocatura di un’immagine, rilevare gli edge all'interno di un’immagine o apportare altri miglioramenti basati sul kernel. I filtri vengono utilizzati per migliorare la qualità dell'immagine raster eliminando i dati spuri o migliorando le feature nei dati. I filtri di convoluzione vengono applicati su un kernel mobile sovrapposto (finestra o vicinanza), ad esempio 3 per 3. I filtri di convoluzione funzionano calcolando il valore del pixel in base ai pesi di quelli vicini.",
		corridorName: "Corridor",
		corridorSnip: "Calcola la somma dei costi cumulativi per due raster di costo cumulativo di input.",
		corridorDesc: "La funzione Corridor calcola la somma dei costi cumulativi per due raster di costo cumulativo di input. Sebbene sia possibile usare due raster qualsiasi per l’input, per ottenere un risultato significativo si dovrebbero usare raster di costo cumulativo di output inalterati. L’ordine dei due raster di input non è rilevante.",
		cosHName: "CosH",
		cosHSnip: "Calcola il coseno iperbolico di celle in un raster.",
		cosHDesc: "La funzione calcola il coseno iperbolico dei pixel in un raster.",
		cosName: "Cos",
		cosSnip: "Calcola il coseno di una cella in un raster.",
		cosDesc: "La funzione calcola il coseno dei pixel in un raster.",
		costAllocationName: "Assegnazione costi",
		costAllocationSnip: "Calcola per ogni cella l'origine più economica in base al minor costo cumulativo su una superficie di costo.",
		costAllocationDesc: "La funzione Assegnazione costi calcola, per ogni cella, l'origine più economica in base al minor costo cumulativo su una superficie di costo.",
		costBackLinkName: "Back Link Costi",
		costBackLinkSnip: "Definisce l'elemento vicino che corrisponde alla cella successiva nel percorso di costo cumulativo minore per l'origine dal costo minimo.",
		costBackLinkDesc: "La funzione Backlink di costo definisce l'elemento vicino che è la cella successiva nel percorso di costo cumulativo minore per l'origine più economica.<div><br/>Il raster backlink contiene valori compresi tra zero e otto, che definiscono la direzione o identificano la successiva cella adiacente (la cella successiva) lungo il percorso di costo cumulativo minore da una cella per raggiungere l'origine più economica. Se il percorso deve passare nell'adiacente destra, alla cella verrà assegnato il valore 1, 2 per la cella diagonale in basso a destra e proseguendo in senso orario. Il valore 0 è riservato alle celle di origine.</div>",
		costDistanceName: "Distanza costi",
		costDistanceSnip: "Calcola la distanza di costo cumulativo minore per ogni cella da o verso l'origine più economica su una superficie di costo.",
		costDistanceDesc: "La funzione Distanza di costo calcola la distanza di costo cumulativo minore per ogni cella da o verso l'origine più economica su una superficie di costo.",
		costPathName: "Percorso costi",
		costPathSnip: "Calcola il percorso di costo minimo da un'origine a una destinazione.",
		costPathDesc: "La funzione globale Percorso di costo calcola il percorso di costo inferiore da un'origine a una destinazione.<div><br/>Questa funzione produce un raster di output che registra il percorso o i percorsi meno costosi, dalle posizioni selezionate alla cella di origine più vicina definita nella superficie di costo cumulativo, in termini di distanza di costo.</div>",
		curvatureName: "Curvatura",
		curvatureSnip: "Calcola la curvatura di una superficie raster, includendo facoltativamente profilo e curvatura piano.",
		curvatureDesc: "La funzione Curvatura visualizza la forma o la curvatura della pendenza. Una superficie può avere una parte concava o convessa; ciò è riconoscibile osservando il valore di curvatura. La curvatura viene calcolata computando la seconda derivata della superficie.<div><br/>L'output della funzione Curvatura può essere usato per descrivere le caratteristiche fisiche di un bacino di drenaggio nel tentativo di comprendere i processi di erosione e ruscellamento. Il valore di curvatura può essere usato per individuare modelli di erosione del suolo nonché la distribuzione dell'acqua nel terreno. La curvatura del profilo influenza l'accelerazione e la decelerazione dei flussi e, quindi, anche l'erosione e la deposizione. La curvatura della superficie alare influenza la convergenza e la divergenza dei flussi.</div>",
		divideName: "Divide",
		divideSnip: "Divide i valori di due raster in base alle singole celle.",
		divideDesc: "La funzione Dividi divide i valori di due raster in base ai singoli pixel.",
		elevationVoidFillName: "Riempimento vuoti di elevazione",
		elevationVoidFillSnip: "Crea pixel dove esistono buchi nei dati di elevazione.",
		elevationVoidFillDesc: "La funzione Riempimento vuoti di elevazione viene usata per creare pixel dove esistono spazi vuoti nell'elevazione.<div><br/>I vuoti si verificano quando non ci sono punti raccolti entro l'area rappresentata da un pixel nel raster risultante. I vuoti sono spesso causati da corpi idrici, selezione di tipi di classe o esclusione. Il riempimento del vuoto è generalmente usato quando si genera una superficie di terra.</div>",
		equalToName: "Equal To",
		equalToSnip: "Esegue un'operazione relazionale uguale-a su due input in base alle singole celle. Restituisce 1 per le celle in cui il primo raster è uguale al secondo raster e 0 per le celle in cui è diverso.",
		equalToDesc: "La funzione esegue un'operazione uguale-a su due raster in base ai singoli pixel. Restituisce il valore 1 per i pixel in cui il primo raster è uguale al secondo raster e il valore 0 per i pixel in cui sono diversi.",
		eucAllocationName: "Assegnazione euclidea",
		eucAllocationSnip: "Calcola per ogni cella l'origine più vicina in base alla distanza euclidea.",
		eucAllocationDesc: "La funzione Assegnazione euclidea calcola per ogni cella l'origine più vicina in base alla distanza euclidea.",
		eucDirectionName: "Direzione euclidea",
		eucDirectionSnip: "Calcola per ogni cella la direzione in gradi rispetto all'origine più vicina.",
		eucDirectionDesc: "La funzione Direzione euclidea calcola per ogni cella la direzione in gradi rispetto all'origine più vicina. <div><br/>Il calcolo della direzione viene eseguito dal centro di ciascuna cella al centro della cella di origine più vicina. L'intervallo di valori è compreso tra 0 gradi e 360 gradi, con 0 riservato per le celle di origine. Verso est (destra) è di 90 e i valori aumentano in senso orario (180 è sud, 270 è ovest e 360 è nord).</div>",
		eucDistanceName: "Distanza euclidea",
		eucDistanceSnip: "Calcola per ogni cella la distanza euclidea dall'origine più vicina.",
		eucDistanceDesc: "La funzione Distanza euclidea calcola per ogni cella la distanza euclidea dall'origine più vicina.",
		exp10Name: "Exp10",
		exp10Snip: "Calcola l'esponente in base 10 delle celle in un raster.",
		exp10Desc: "La funzione Exp 10 calcola l'esponente in base 10 dei pixel in un raster.",
		exp2Name: "Exp2",
		exp2Snip: "Calcola l'esponente in base 2 delle celle in un raster.",
		exp2Desc: "La funzione calcola l'esponente in base 2 dei pixel in un raster.",
		expName: "Exp",
		expSnip: "Calcola l'esponente in base e delle celle in un raster.",
		expDesc: "Questa funzione calcola l'esponente in base e dei pixel in un raster.",
		extractBandName: "Estrai bande",
		extractBandSnip: "Specifica quali bande utilizzare durante l'uso di dataset multibanda.",
		extractBandDesc: " La funzione Estrai bande consente di estrarre una o più bande, o di riordinarle, da un dataset raster multibanda.<div><br/>La funzione Estrai bande può essere usata prima di altre funzioni, come Aritmetica, per verificare quali bande vengono usate come input nella funzione successiva.</div>",
		fillName: "Compila",
		fillSnip: "Riempie i sink in un raster superficie per rimuovere piccole imperfezioni nei dati.",
		fillDesc: "La funzione globale Riempi individua e riempie i sink e le vette in un raster di elevazione per rimuovere piccole imperfezioni nei dati. La funzione eseguirà un processo iterativo di riempimento fino a quando tutti i sink saranno stati riempiti entro il limite Z specificato.<div><br/>Quando viene creata una superficie di elevazione con strumenti come Ortho Mapping o con altri mezzi, i dati contengono spesso errori piccoli ma significativi nella forma dei sink e delle vette. In fotogrammetria, sink e vette sono spesso indicati come spazi vuoti e picchi. I dati di superficie sono spesso usati in modellazione, come nella modellazione idrologica, pertanto è importante correggere questo tipo di errori a livello di sink e vette in modo coerente con i dati circostanti.</div>",
		floatName: "Float",
		floatSnip: "Converte tutti i valori delle celle di un raster in una rappresentazione a virgola mobile.",
		floatDesc: "La funzione Float converte tutti i valori dei pixel di un raster in una rappresentazione a virgola mobile.",
		flowAccumulationName: "Accumulo del Flusso",
		flowAccumulationSnip: "Crea un raster del flusso accumulato in ogni cella. È possibile applicare un fattore di peso.",
		flowAccumulationDesc: "La funzione globale Accumulo del flusso crea un raster di flusso accumulato in ciascun pixel, determinato dall’accumulo del peso di tutti i pixel che fluiscono in ciascun pixel in pendenza. Se non viene fornito alcun raster di peso, viene applicato un peso pari a 1 a ciascun pixel e il valore dei pixel nel raster di output corrisponderà al numero di pixel che fluiscono in ciascun pixel.<div><br/>I pixel di output con un elevato accumulo di flusso sono aree di flusso concentrato e possono essere usati per individuare canali di flusso. I pixel di output con un accumulo di flusso pari a zero sono rilievi topografici locali e possono essere utilizzati per identificare le creste.</div>",
		flowDirectionName: "Direzione del Flusso",
		flowDirectionSnip: "Crea un raster della direzione del flusso da ogni cella al relativo vicino in maggior pendenza.",
		flowDirectionDesc: "Una delle chiavi per derivare le caratteristiche idrologiche di una superficie è la capacità di determinare la direzione del flusso da ciascun pixel nel raster. La funzione raster Direzione del flusso prende una superficie come input e crea un raster di direzione del flusso da ciascun pixel al relativo vicino in maggior pendenza. La funzione Direzione flusso supporta tre metodi di modellazione del flusso: D8 (otto direzioni), Direzione multi-flusso (MFD) e D-Infinity (DINF). ",
		flowDistanceName: "Distanza di Flusso",
		flowDistanceSnip: "Calcola, per ogni cella, la distanza minima orizzontale o verticale dalle celle lungo la linea di scorrimento di un ruscello o di un fiume.",
		flowDistanceDesc: "Per ciascun pixel, la funzione calcolerà la distanza minima orizzontale o verticale dai pixel lungo la linea di scorrimento di un ruscello o di un fiume. Se viene fornito un raster di direzione del flusso opzionale, le direzioni saranno limitate a quelle definite dalla direzione del flusso del raster di input. L’output è un raster di distanza di flusso.",
		focalName: "Statistiche focali",
		focalSnip: "Calcola le statistiche della focale per ogni pixel di un'immagine in base agli elementi vicini con focale definita.",
		focalDesc: "La funzione Statistiche focali calcola le statistiche della focale per ogni pixel di un'immagine in base agli elementi vicini con focale definita.",
		geometricName: "Geometrica",
		geometricSnip: "Incrementa la precisione di posizionamento di un dataset tenendo conto dell'elevazione.",
		geometricDesc: "La funzione Geometrica genera un’immagine ortorettificata in base alla definizione di un sensore e a un modello di terreno. Incrementa la precisione di posizionamento di un dataset tenendo conto dell'elevazione.",
		grayscaleName: "Scala di grigi",
		grayscaleSnip: "Converte un’immagine multibanda in un’immagine in scala di grigi a banda singola.",
		grayscaleDesc: "La funzione converte un’immagine multibanda in un’immagine in scala di grigi a banda singola.<div><br/>Questa funzione applica i pesi specificati a ciascuna delle bande di input e normalizza l'immagine di output. Spesso pesi vengono applicati perché alcune bande hanno un'importanza variabile a seconda dell'applicazione. Ad esempio, la banda blu spesso contiene più rumore delle altre bande.</div>",
		greaterThanEqualName: "Greater Than Equal",
		greaterThanEqualSnip: "Esegue un'operazione relazionale maggiore-di-o-uguale-a su due input in base alle singole celle. Restituisce 1 per le celle in cui il primo raster è maggiore o uguale al secondo e 0 in caso contrario.",
		greaterThanEqualDesc: "La funzione esegue un'operazione relazionale maggiore-di-o-uguale-a su due input in base ai singoli pixel. Restituisce un valore 1 per i pixel in cui il primo raster è maggiore o uguale al secondo raster e un valore 0 per i pixel in cui il primo raster non è maggiore o uguale al secondo raster.",
		greaterThanName: "Maggiore Di",
		greaterThanSnip: "Esegue un'operazione relazionale maggiore-di su due input in base alle singole celle. Restituisce 1 per le celle in cui il primo raster è maggiore del secondo e 0 in caso contrario.",
		greaterThanDesc: "La funzione esegue un'operazione relazionale maggiore-di su due input in base ai singoli pixel. Restituisce un valore 1 per i pixel in cui il primo raster è maggiore del secondo raster e un valore 0 per i pixel in cui il primo raster non è maggiore del secondo raster.",
		heatIndexName: "Indice di calore",
		heatIndexSnip: "Combina la temperatura dell'aria e l'umidità relativa dell'ambiente per restituire la temperatura apparente.",
		heatIndexDesc: "La funzione calcola la temperatura apparente in base alla temperatura ambiente e all’umidità relativa. La temperatura apparente è spesso descritta come il calore percepito dal corpo umano.<div><br/>Questo indice può essere utile per calcolare i rischi legati a problemi medici come crampi muscolari, disidratazione, esaurimento da calore o, ancora più grave, il colpo di calore nei giorni caldi e umidi. Un'umidità relativa elevata rende più difficoltosa l’evaporazione del sudore e il corpo viene privato di un efficace metodo naturale di raffreddamento. Le mappe dei bollettini e degli alarmi meteo sono spesso il prodotto di una riclassificazione del risultato dell’indice di calore in classi, in cui quanto più alto è il valore dell’indice, più probabile sarà che venga trasformato in un allarme piuttosto che in un semplice bollettino.</div>",
		hillshadeName: "Hillshade",
		hillshadeSnip: "Crea una rappresentazione 3D della superficie, tenendo conto della posizione relativa del sole per l'ombreggiatura dell'immagine.",
		hillshadeDesc: "La funzione Hillshade produce una rappresentazione 3D in scala di grigi della superficie del suolo che tiene in considerazione la posizione relativa del sole per ombreggiare l’immagine. <div><br/>Il rilievo ombreggiato è una tecnica di visualizzazione del terreno determinata da una fonte di illuminazione e dalla pendenza e aspetto della superficie di elevazione. È un metodo qualitativo di visualizzazione della topografia e non fornisce valori di elevazione assoluti. </div>",
		intName: "Int",
		intSnip: "Converte ogni valore di cella di un raster in un numero intero mediante troncamento.",
		intDesc: "La funzione Int converte ogni valore di pixel di un raster in un numero intero mediante troncamento.",
		interpolateIrregularDataName: "Interpola dati irregolari",
		interpolateIrregularDataSnip: "Consente di interpolare da cloud di punti o griglie irregolari.",
		interpolateIrregularDataDesc: "Alcuni dataset netCDF o HDF archiviano la loro geoposizione come array di pixel o dati di punti irregolarmente spaziati. Quando si aggiungono questi dataset a un mosaic dataset, la funzione Interpolazione dati irregolari prende i dati reticolati irregolarmente e li ricampiona in modo che ogni pixel sia di dimensione uniforme e quadrato.<div><br/>Quando si aggiungono variabili da netCDF o HDF a un mosaic dataset, si verificherà automaticamente se i dati sono disposti regolarmente nell'array. In caso contrario, la funzione Interpolazione dati irregolari può essere usata per convertire i dati irregolari in raster reticolati in modo regolare. È possibile cambiare il metodo di interpolazione e la dimensione delle celle usati nella funzione raster Interpolazione dati irregolari. Per dati raster spaziati in modo regolare, non si applicherà nessuna interpolazione e i dati saranno letti così come sono.</div>",
		isNullName: "È null",
		isNullSnip: "Determina quali valori del raster di input sono NoData in base alle singole celle. Restituisce un valore 1 se il valore di input è NoData e 0 in caso contrario.",
		isNullDesc: "La funzione È null determina quali valori del raster di input sono NoData in base ai singoli pixel. Restituisce un valore 1 se il valore di input è NoData e un valore 0 per i pixel che non sono NoData.",
		kernelDensityName: "Densità Kernel",
		kernelDensitySnip: "Calcola un'area grandezza per unità a partire dalle feature punto o polilinea utilizzando una funzione kernel per adattare una superficie rastremata uniforme a ciascun punto o polilinea.",
		kernelDensityDesc: "Questa funzione calcola un'area grandezza per unità a partire dalle feature punto o polilinea utilizzando una funzione kernel per adattare una superficie rastremata uniforme a ciascun punto o polilinea.",
		keyMetadataName: "Metadati chiave",
		keyMetadataSnip: "Esclude o inserisce i metadati chiave di un raster in una catena di funzioni.",
		keyMetadataDesc: "Questa funzione consente di inserire o sostituire i metadati chiave di un raster.<div><br/>Le informazioni contenute nei metadati chiave vengono utilizzate per assistere l'applicazione in determinate elaborazioni e rendering, fornendo informazioni utili come il nome del sensore, i nomi delle bande o la copertura delle nubi associata alle immagini.</div>",
		shortestPathName: "Percorso di costo minimo",
		shortestPathSnip: "Utilizza input di origine e destinazione per eseguire un'analisi costo-distanza che viene quindi usata per stabilire il percorso dal costo minimo da un'origine a una destinazione.",
		shortestPathDesc: "La funzione Percorso di costo minimo calcola il percorso di costo minore da un'origine a una destinazione. La distanza di costo cumulativo minore viene calcolata per ogni pixel su una superficie di costo, rispetto all'origine più vicina. In questo modo, si produce un raster di output che registra il percorso o i percorsi meno costosi, dalle posizioni selezionate ai pixel di origine più vicini definiti nella superficie di costo cumulativo, in termini di distanza di costo.<div><br/>Ad ogni percorso di costo minimo rilevato nel processo di scansione viene assegnato un valore. Il pixel finale sul raster di origine di un percorso di costo riceve un valore 1. Il primo percorso riceve un valore 3, il secondo 4, e così via. Quando più percorsi si uniscono e percorrono la distanza rimanente verso un’origine sullo stesso itinerario, al segmento in cui i due percorsi viaggiano insieme viene assegnato un valore 2. Alla porzione di percorso unita non può essere assegnato il valore di uno dei percorsi, in quanto la porzione unita appartiene a entrambi.</div>",
		lessThanEqualName: "Less Than Equal",
		lessThanEqualSnip: "Esegue un'operazione relazionale minore-di-o-uguale-a su due input in base alle singole celle. Restituisce 1 per le celle in cui il primo raster è minore o uguale al secondo e 0 in caso contrario.",
		lessThanEqualDesc: "La funzione esegue un'operazione relazionale minore-di-o-uguale-a su due input in base ai singoli pixel. Restituisce un valore 1 per i pixel in cui il primo raster è minore o uguale al secondo raster e un valore 0 se il primo raster non è minore o uguale al secondo raster.",
		lessThanName: "Less Than",
		lessThanSnip: "Esegue un'operazione relazionale minore-di su due input in base alle singole celle. Restituisce 1 per le celle in cui il primo raster è minore del secondo e 0 in caso contrario.",
		lessThanDesc: "La funzione esegue un'operazione relazionale minore-di su due input in base ai singoli pixel. Restituisce un valore 1 per i pixel in cui il primo raster è minore del secondo raster e un valore 0 se il primo raster non è minore del secondo raster.",
		lnName: "Ln",
		lnSnip: "Calcola il logaritmo naturale (in base e) di celle in un raster.",
		lnDesc: "La funzione Ln calcola il logaritmo naturale (in base e) di ogni pixel in un raster.",
		log10Name: "Log10",
		log10Snip: "Calcola il logaritmo in base 10 di celle in un raster.",
		log10Desc: "La funzione Log10 calcola il logaritmo in base 10 di ogni pixel in un raster.",
		log2Name: "Log2",
		log2Snip: "Calcola il logaritmo in base 2 di celle in un raster.",
		log2Desc: "La funzione Log2 calcola il logaritmo in base 2 di ogni pixel in un raster.",
		lookupName: "Ricerca",
		lookupSnip: "Crea un nuovo raster cercando valori presenti in un altro campo nella tabella del raster di input.",
		lookupDesc: "La funzione crea un nuovo raster cercando i valori presenti in un altro campo nella tabella del raster di input.",
		mlClassifyName: "Classifica ML",
		mlClassifySnip: "Classifica le immagini utilizzando un approccio per pixel. I pixel misti vengono assegnati alla feature con la percentuale più alta in tale pixel.",
		mlClassifyDesc: "La funzione Classifica ML consente di eseguire una classificazione supervisionata, utilizzando l’algoritmo di classificazione per massima probabilità, su un dataset raster o su un mosaic dataset. Questa funzione richiede un file di firma della classificazione.",
		maskName: "Maschera",
		maskSnip: "Consente di impostare i valori che non si desidera visualizzare.",
		maskDesc: "Questa funzione raster consente di impostare i valori che non si desidera visualizzare nel raster. Usando la funzione Maschera, è possibile specificare uno o più valori NoData o un intervallo di Pixel value validi. ",
		minusName: "Minus",
		minusSnip: "Sottrae il valore del secondo raster di input dal valore del primo raster di input in base alle singole celle.",
		minusDesc: "La funzione Meno sottrae il valore del secondo raster di input dal valore del primo raster di input in base ai singoli pixel.",
		modName: "Mod",
		modSnip: "Trova il resto (modulo) del primo raster quando è diviso per il secondo raster in base alle singole celle.",
		modDesc: "La funzione Mod trova il resto (modulo) del primo raster quando è diviso per il secondo raster in base ai singoli pixel. L'ordine degli input è importante e influenza il risultato di output.",
		mosaicRastersName: "Raster mosaico",
		mosaicRastersSnip: "Unisce un insieme di dataset raster per creare un dataset.",
		mosaicRastersDesc: "La funzione Mosaic raster crea un’immagine a mosaico da varie immagini. In caso di sovrapposizione delle immagini, è possibile scegliere tra vari metodi per stabilire quali immagini visualizzare.",
		ndviColorizedName: "NDVI colorato",
		ndviColorizedSnip: "Crea un dataset multibanda che rappresenta lo stato della vegetazione, in base alla differenza tra le bande rosso e quasi infrarosso.",
		ndviColorizedDesc: "La funzione NDVI Colorized applica la funzione NDVI sull’immagine di input, quindi utilizza una colormap o una scala cromatica per visualizzare il risultato.",
		ndviName: "NDVI",
		ndviSnip: "Calcola il NDVI (Normalized Difference Vegetation Index).",
		ndviDesc: "La funzione NDVI crea un dataset a banda singola che rappresenta lo stato della vegetazione, in base alla differenza tra le bande del rosso e dell’infrarosso vicino.<div><br/>NDVI è un indice standardizzato che consente di generare un'immagine raffigurante aree verdi, anche nota come biomassa relativa. Questo indice sfrutta le caratteristiche contrastanti tra due bande di un dataset raster multispettrale: l'assorbimento dei pigmenti di clorofilla nella banda del rosso e l'elevata riflettanza del materiale vegetale nella banda dell'infrarosso vicino (NIR). Valori di NDVI estremamente bassi o negativi rappresentano aree del tutto prive di vegetazione, come nuvole, acqua o neve. Valori molto bassi rappresentano aree di vegetazione scarsa o assente, come cemento, roccia o terreno nudo. Valori moderati rappresentano aree con presenza di arbusti e prati. Valori elevati rappresentano aree forestali e ricche di vegetazione.</div>",
		negateName: "Negate",
		negateSnip: "Cambia il segno (moltiplica per -1) dei valori di cella del raster di input in base a singole celle.",
		negateDesc: "La funzione Negativo cambia il segno (moltiplica per -1) dei valori dei pixel del raster di input in base ai singoli pixel. ",
		nibbleName: "Nibble",
		nibbleSnip: "Sostituisce le celle di un raster corrispondenti a una maschera con i valori dei vicini più prossimi.",
		nibbleDesc: "La funzione globale Nibble consente di assegnare alle aree selezionate di un raster il valore del rispettivo vicino più prossimo. È utile per modificare le aree di un raster in cui i dati potrebbero essere errati.",
		notEqualName: "Not Equal",
		notEqualSnip: "Esegue un'operazione relazionale diverso-da su due input in base alle singole celle. Restituisce 1 per le celle in cui il primo raster non è uguale al secondo e 0 quando è uguale.",
		notEqualDesc: "La funzione esegue un'operazione relazionale diverso-da su due input in base ai singoli pixel. Restituisce un valore 1 per i pixel in cui il primo raster è diverso dal secondo raster e un valore 0 per i pixel in cui il primo raster è uguale al secondo raster.",
		pansharpeningName: "Fondi dati (Pansharpen)",
		pansharpeningSnip: "Migliora artificialmente la risoluzione spaziale di un'immagine multibanda fondendola con un'immagine pancromatica con risoluzione superiore.",
		pansharpeningDesc: "La funzione Pan-sharpening utilizza un’immagine pancromatica ad alta risoluzione o una banda raster per un set di dati raster multibanda a risoluzione inferiore per aumentare la risoluzione spaziale dell’immagine multibanda.<div><br/>Lo scopo del pan-sharpening è creare un'immagine visiva di qualità superiore. Dal momento che le tecniche modificano la radiometria e le caratteristiche spettrali delle immagini multibanda, le immagini con pan-sharpening devono essere utilizzate con cautela per scopi di telerilevamento analitico.</div>",
		pathAllocationName: "Assegnazioni della Distanza del Percorso",
		pathAllocationSnip: "Calcola l'origine più economica per ogni cella in base al minor costo cumulativo su una superficie di costo, tenendo comunque in considerazione i fattori relativi alla distanza della superficie insieme ai costi orizzontale e verticale.",
		pathAllocationDesc: "La funzione Assegnazione distanza di percorso calcola l'origine più vicina per ogni cella in base al costo cumulativo minore su una superficie di costo, tenendo conto dei fattori relativi alla distanza della superficie e al costo orizzontale e verticale.",
		pathBackLinkName: "Back Link Distanza Percorso",
		pathBackLinkSnip: "Definisce l'elemento vicino che corrisponde alla cella successiva nel percorso di costo cumulativo minore per l'origine più economica, tenendo comunque in considerazione i fattori relativi alla distanza della superficie insieme ai costi orizzontale e verticale.",
		pathBackLinkDesc: "La funzione Backlink distanza di percorso definisce la direzionalità del vicino corrispondente alla cella successiva nel percorso di costo cumulativo minore verso l'origine più vicina, tenendo conto dei fattori relativi alla distanza della superficie e al costo orizzontale e verticale.",
		pathDistanceName: "Distanza Percorso",
		pathDistanceSnip: "Calcola per ogni cella la distanza di costo cumulativo minore da o verso l'origine più economica, tenendo conto dei fattori relativi alla distanza della superficie e al costo orizzontale e verticale.",
		pathDistanceDesc: "La funzione Distanza di percorso calcola per ogni cella la distanza di costo cumulativo minore verso l'origine più vicina, tenendo conto dei fattori relativi alla distanza della superficie e al costo orizzontale e verticale.",
		plusName: "Plus",
		plusSnip: "Aggiunge (somma) i valori di due raster in base alle singole celle.",
		plusDesc: "La funzione Più aggiunge (somma) i valori di due raster in base ai singoli pixel.",
		powerName: "Potenza",
		powerSnip: "Eleva i valori di cella in un raster alla potenza dei valori trovati in un altro raster.",
		powerDesc: "La funzione Potenza eleva i valori di pixel in un raster alla potenza dei valori trovati in un altro raster.",
		radarCalibrationName: "Calibrazione radar",
		radarCalibrationSnip: "Converte retrodiffusione RADARSAT-2.",
		radarCalibrationDesc: "Questa funzione può essere usata per calibrare le immagini RADARSAT-2 in un mosaic dataset o come prodotto di un raster. La calibrazione viene eseguita su immagini radar in modo che i valori dei pixel siano una rappresentazione fedele del retrodiffusione radar.",
		rasterInfoName: "RasterInfo",
		rasterInfoSnip: "Modifica le proprietà del raster, ad esempio la profondità in bit, il valore NoData, le dimensioni cella e così via.",
		rasterInfoDesc: "Info raster apre una finestra di dialogo contenente le proprietà dei dataset raster, come il numero di colonne e righe, il numero di bande, il tipo di pixel, l'estensione e il riferimento spaziale. È possibile modificare queste proprietà selezionando un dataset raster da usare come modello. ",
		rasterizeAttributesName: "Rasterizza attributi",
		rasterizeAttributesSnip: "Arricchisce un raster con bande aggiuntive derivate da valori di attributi specificati provenienti da una tabella esterna o da un feature service.",
		rasterizeAttributesDesc: "La funzione Rasterizza attributi arricchisce un raster aggiungendo bande derivate da valori di attributi specificati da una tabella esterna o un feature service. È possibile specificare un raster zona e l'attributo ID zona associato per abilitare le ricerche per regione.",
		rasterizeFeatureClassName: "Rasterizza feature",
		rasterizeFeatureClassSnip: "Converte le feature in raster.",
		rasterizeFeatureClassDesc: "La funzione converte i dati di feature class poligono, polilinea e punto in un layer raster.<div><br/>Alle feature vengono assegnati valori dei pixel in base all'OBJECTID delle feature (impostazione predefinita). Facoltativamente, i valori dei pixel possono essere basati su un campo di valore definito dall'utente nella tabella degli attributi della feature di input.</div>",
		recastName: "Recast",
		recastSnip: "Modifica i parametri di una catena di funzioni in un mosaic dataset o in un image service. Viene spesso usata con dataset LAS per evitare di dover creare un mosaic dataset separato per diverse rappresentazioni del terreno.",
		recastDesc: "La funzione Recast consente di modificare dinamicamente il parametro della funzione usata in un mosaic dataset o in un image service senza conservare fisicamente le modifiche.",
		regionGroupName: "Gruppo Regione",
		regionGroupSnip: "Per ogni cella dell'output viene registrata l'identità della regione connessa cui appartiene la cella. A ogni regione viene assegnato un numero univoco.",
		regionGroupDesc: "La funzione globale Gruppo regione registra per ogni cella dell'output l'identità della regione connessa cui appartiene la cella. A ogni regione viene assegnato un numero univoco.<div><br/>La prima regione scansionata riceve il valore uno, la seconda il due e così via finché non viene assegnato un valore a tutte le regioni. Il processo di scansione si sposta da sinistra a destra, da sopra a sotto. I valori assegnati alle zone di output si basano sull’ordine di rilevamento delle stesse durante il processo di scansione.</div>",
		regionGrowName: "Aumento regione",
		regionGrowSnip: "Aumenta le regioni da punti di seed.",
		regionGrowDesc: "La funzione di aumento regione raggruppa i pixel vicini in gruppi in base al raggio specificato dal punto di seed. Al gruppo di pixel o oggetto viene assegnato un valore di riempimento specificato.",
		remapName: "Rimappa",
		remapSnip: "Cambia i valori in pixel assegnando nuovi valori a intervalli di valori in pixel o utilizzando una tabella esterna.",
		remapDesc: "La funzione Rimappa consente di modificare o riclassificare i valori dei pixel dei dati raster. Questa operazione può essere eseguita specificando un intervallo di valori dei pixel da mappare in un valore di pixel di output o utilizzando una tabella per mappare i valori dei pixel in un valore pixel di output.",
		reprojectName: "Riproietta",
		reprojectSnip: "Modifica la proiezione di un dataset raster, di un mosaic dataset o di un elemento raster in un mosaic dataset. Può anche ricampionare i dati in una nuova dimensione cella e definire un'origine.",
		reprojectDesc: "La funzione Riproietta modifica la proiezione di un raster dataset, un mosaic dataset o un elemento raster in un mosaic dataset. Può anche ricampionare i dati in una nuova dimensione cella e definire un'origine.<div><br/>La funzione Riproietta può essere usata quando si crea una cache da un raster o mosaic dataset che non si trova nella proiezione richiesta. Ad esempio, quando si crea un image service memorizzato nella cache che potrebbe essere integrato da applicazioni con altri servizi memorizzati nella cache, è importante che si trovino tutti nella stessa proiezione. Questa è spesso una proiezione Web Mercator. Dal momento che non è possibile riproiettare il mosaic dataset, è possibile realizzare una delle due operazioni seguenti:—creare un mosaic dataset proiettato a partire dal mosaic dataset nella proiezione necessaria o aggiungere la funzione Riproietta alla lista di funzioni del mosaic dataset. Un altro esempio di utilizzo di questa funzione è sull'elemento raster in un mosaic dataset. Quando si usa la funzione Raster memorizzato nella cache, si può scegliere di inserire la funzione Riproietta in modo da creare la cache nella nuova proiezione. Gli elementi raster in un mosaic dataset possono essere memorizzati nella cache quando l'elaborazione è intensa e si sta cercando di pubblicare un image service veloce, senza memorizzare l'intero image service nella cache.</div>",
		resampleName: "Ricampiona",
		resampleSnip: "Cambia la dimensione cella di un raster.",
		resampleDesc: "La funzione Ricampiona modifica la dimensione della cella, il tipo di ricampionamento o entrambi.<div><br/>La funzione Ricampiona deve essere usata esclusivamente con requisiti di calcolo specifici, ad esempio, in caso di calcolo della grandezza-direzione del vento o della corrente che richiede il ricampionamento dalla risoluzione dell'origine.</div>",
		roundDownName: "Round Down",
		roundDownSnip: "Restituisce il numero intero successivo più basso, rappresentato come un valore a virgola mobile, per ogni cella in un raster.",
		roundDownDesc: "La funzione Round Down restituisce il numero intero successivo più basso, come un valore a virgola mobile, per ogni pixel in un raster.",
		roundUpName: "Round Up",
		roundUpSnip: "Restituisce il numero intero successivo più alto, rappresentato come un valore a virgola mobile, per ogni cella in un raster.",
		roundUpDesc: "La funzione Round Up restituisce il numero intero successivo più alto, come un valore a virgola mobile, per ogni pixel in un raster.",
		segmentMeanShiftName: "Segmenta Spostamento Medio",
		segmentMeanShiftSnip: "Raggruppa pixel vicini con caratteristiche spettrali simili in segmenti.",
		segmentMeanShiftDesc: "Questa funzione identifica oggetti, feature o segmenti nelle immagini raggruppando pixel adiacenti con caratteristiche spettrali e spaziali simili. È possibile controllare la quantità di smussamento spaziale e spettrale per derivare più facilmente le feature di interesse.",
		s1RadiometricCalibrationName: "Sentinel-1 Calibrazione radiometrica",
		s1RadiometricCalibrationSnip: "Esegue vari tipi di calibrazione radiometrica sui dati Sentinel-1.",
		s1RadiometricCalibrationDesc: "Questa funzione raster esegue tre diverse calibrazioni per i dataset Sentinel 1, tra cui la calibrazione beta nought e gamma, e restituisce il dataset calibrato. L'obiettivo della calibrazione SAR è quello di fornire immagini in cui i valori dei pixel possono essere correlati direttamente alla retrodiffusione radar della scena. Sebbene per l’uso qualitativo siano sufficienti immagini SAR non calibrate, l'uso quantitativo dei dati SAR richiede immagini SAR calibrate.<div><br/>L'elaborazione tipica dei dati SAR, che produce immagini di livello 1, non include le correzioni radiometriche e i resti di bias radiometrici significativi. Pertanto, è necessario applicare la correzione radiometrica alle immagini SAR in modo che i valori dei pixel delle immagini rappresentino realmente ila retrodiffusione radar della superficie riflettente. La correzione radiometrica è necessaria, inoltre, per eseguire il confronto di immagini SAR acquisite con sensori diversi, acquisite dallo stesso sensore ma in momenti diversi o in modalità diverse, oppure elaborate da processori diversi.</div>",
		s1ThermalNoiseRemovalName: "Sentinel-1 Rimozione del rumore termico",
		s1ThermalNoiseRemovalSnip: "Rimuove il rumore termico dai dati Sentinel-1.",
		s1ThermalNoiseRemovalDesc: "La correzione del rumore termico può essere applicata ai prodotti Sentinel-1 Level-1 Single Look Complex (SLC) e ai prodotti Level-1 Ground Range Detection (GRD) non ancora corretti. Inoltre, l’operatore può rimuovere questa correzione in base alle annotazioni del prodotto al fine di reintrodurre il segnale di rumore rimosso e riprodurre il prodotto originale. Le annotazioni del prodotto saranno aggiornate di conseguenza per consentire la riapplicazione della correzione. ",
		setNullName: "Imposta Null",
		setNullSnip: "Imposta Null consente di impostare le posizioni delle celle identificate su NoData in base a un criterio specificato. Restituisce NoData se una valutazione condizionale è True; restituisce il valore specificato da un altro raster se è False.",
		setNullDesc: "La funzione Imposta Null consente di impostare i pixel identificati come NoData in base a un criterio specifico. Restituisce NoData se una valutazione condizionale è true (1); restituisce il valore specificato nel False Raster se una valutazione condizionale è false (0). Questo criterio è specificato dall'output di una funzione matematica logica, che sarà il raster di input.",
		shadedReliefName: "Rilievo ombreggiato",
		shadedReliefSnip: "Crea una rappresentazione 3D, multibanda, codificata a colori della superficie, tenendo conto della posizione relativa del sole per l'ombreggiatura dell'immagine.",
		shadedReliefDesc: "La funzione Rilievo ombreggiato è una rappresentazione 3D a colori del terreno, creata unendo le immagini dei metodi codificati per elevazione e rilievo ombreggiato. Questa funzione usa le proprietà dell'altitudine e dell'azimut per specificare la posizione del sole.<div><br/></div>",
		sinHName: "SinH",
		sinHSnip: "Calcola il seno iperbolico di celle in un raster.",
		sinHDesc: "La funzione calcola il seno iperbolico dei pixel in un raster.",
		sinName: "Sin",
		sinSnip: "Calcola il seno di celle in un raster.",
		sinDesc: "La funzione calcola il seno dei pixel in un raster.",
		slopeName: "Pendenza",
		slopeSnip: "Calcola la percentuale di variazione da un valore in pixel rispetto ai suoi vicini.",
		slopeDesc: "Questa funzione raster calcola la pendenza, che equivale alla percentuale di variazione dell'elevazione per ogni cella del modello digitale di elevazione (DEM). È la prima derivata di un DEM.<div><br/>Questa funzione usa una funzione atan() accelerata. È sei volte più veloce e l'errore di approssimazione è sempre minore di 0,3 gradi.</div>",
		speckleName: "Rumore moltiplicativo",
		speckleSnip: "Fornisce filtri per ridurre il rumore in dataset di radar ad apertura sintetica.",
		speckleDesc: "Il rumore moltiplicativo è il rumore ad alta frequenza nei dati del radar. Le immagini generate dai sistemi radar ad apertura sintetica (SAR) sono fortemente soggette a effetti di rumore moltiplicativo dovuti all'elaborazione di segnali sparsi e all'interferenza di onde elettromagnetiche diffuse da superfici od oggetti. La funzione Rumore moltiplicativo filtra il dataset del radar soggetto a rumore moltiplicativo per attenuare il rumore mantenendo gli edge o le feature nitide nell’immagine.",
		spectralConversionName: "Conversione spettrale",
		spectralConversionSnip: "Applica una matrice a un’immagine multibanda.",
		spectralConversionDesc: "La funzione Conversione spettrale applica una matrice a un'immagine multibanda per influenzare i valori di colore dell'output.<div><br/>Alcuni sensori non rilevano le bande blu a causa del basso rapporto segnale-disturbo. Questa tecnica può essere utilizzata per convertire un'immagine a infrarossi con colori falsi in un'immagine a colori pseudonaturale.</div>",
		squareRootName: "Square Root",
		squareRootSnip: "Calcola la radice quadrata dei valori di cella in un raster.",
		squareRootDesc: "La funzione Radice quadrata calcola la radice quadrata dei valori dei pixel in un raster.",
		squareName: "Square",
		squareSnip: "Calcola il quadrato dei valori di cella in un raster.",
		squareDesc: "La funzione Quadrato calcola il quadrato dei valori dei pixel in un raster.",
		statisticsHistogramName: "Statistiche e Istogramma",
		statisticsHistogramSnip: "Definire o associare statistiche e istogramma.",
		statisticsHistogramDesc: "La funzione Statistiche e Istogrammi viene utilizzata per definire le statistiche e l’istogramma di un raster. È possibile inserire questa funzione alla fine della catena di funzioni per descrivere le statistiche e l’istogramma di un modello di Raster Function (RFT). Ciò può essere necessario per controllare la visualizzazione predefinita del risultato dell’elaborazione, specialmente quando si definisce una catena di funzioni che contiene molte funzioni.<div><br/>È possibile definire statistiche digitando i valori o importando da un dataset raster o un file XML. Gli istogrammi possono essere definiti solo importando un file.</div>",
		statisticsName: "Statistiche",
		statisticsSnip: "Calcola le statistiche della focale per ogni pixel di un'immagine in base agli elementi vicini con focale definita.",
		statisticsDesc: "La funzione Statistiche calcola le statistiche della focale per ogni pixel di un'immagine in base agli elementi vicini con focale definita.<div><br/>La funzione Statistics può essere usata per riempire delle linee rimosse in un'immagine. Le linee rimosse sono spesso causate da problemi al sensore laddove non si raccolgono dati. Ciò si è verificato in sensori come Enhanced Thematic Mapper Plus (ETM+) di Landsat 7.  I dati mancanti causano problemi per l'analisi, nonché quando si guardano le immagini. Quando si usano le immagini per un'analisi non esistono interventi risolutori; tuttavia, nel caso in cui esista un'immagine sovrapposta, è possibile usarla al posto del contenuto mancante. È possibile eseguire la stessa operazione se si usa l'immagine per la visualizzazione. Tuttavia, non esiste sempre un'immagine aggiuntiva per riempire il contenuto mancante, pertanto deve essere derivata dai dati esistenti.</div>",
		streamLinkName: "Collegamento flusso",
		streamLinkSnip: "Assegna valori univoci alle sezioni di una rete lineare raster tra le intersezioni.",
		streamLinkDesc: "La funzione globale Collegamento flusso assegna valori univoci alle sezioni di una rete lineare raster tra le intersezioni.<div><br/>I collegamenti sono le sezioni di un canale di flusso che collega due nodi che si susseguono, un nodo e lo sbocco, o un nodo e lo spartiacque di drenaggio. In idrologia, questi segmenti di flusso sono chiamati tratti. Un nodo fa riferimento a un punto di versamento e aiuta a delineare uno spartiacque o un limite del sottobacino di drenaggio.</div>",
		stretchName: "Estende",
		stretchSnip: "Migliora un’immagine regolando l’intervallo dei valori visualizzati. I valori dei pixel sottostanti non vengono alterati. Se un pixel ha un valore al di fuori dell'intervallo specificato, verrà visualizzato come valore minimo o massimo.",
		stretchDesc: "La funzione Stretch migliora un'immagine modificando proprietà come luminosità, contrasto e gamma tramite vari tipi di estensione. Questa funzione usa le statistiche dei raster contenuti nel mosaic dataset; pertanto, prima di usare questa funzione, è necessario assicurarsi che le statistiche siano state calcolate.<div><br/>Il tipo di estensione definisce un'estensione di istogramma che sarà applicata ai raster per migliorarne l'aspetto. L’applicazione dell’estensione migliora l’aspetto dei dati distribuendo i valori dei pixel lungo un istogramma dai valori minimi a quelli massimi, in base alla profondità in bit. </div>",
		swathName: "Contrassegna",
		swathSnip: "Interpola da griglie irregolari o dati contrassegnati.",
		swathDesc: "Alcuni dataset netCDF o HDF archiviano la loro geoposizione come array irregolarmente spaziati. Quando si aggiungo questi dataset a un dataset di mosaico, la funzione Swath prende i dati reticolati irregolarmente e li ricampiona in modo che ogni pixel sia di dimensione uniforme e quadrato.<div><br/>Quando si aggiungono variabili da netCDF o HDF a un mosaic dataset, si verificherà automaticamente se i dati sono disposti regolarmente nell'array. In caso contrario, si applica automaticamente la funzione Swath per convertire il raster irregolare in punti e, quindi, in un raster regolarmente reticolato. È possibile cambiare il metodo di interpolazione e la dimensione delle celle usati nella funzione raster Swath. Per dati raster spaziati in modo regolare, non si applicherà nessuna interpolazione, i dati saranno letti così come sono.</div>",
		tanHName: "TanH",
		tanHSnip: "Calcola la tangente iperbolica di celle in un raster.",
		tanHDesc: "La funzione calcola la tangente iperbolica dei pixel in un raster.",
		tanName: "Tan",
		tanSnip: "Calcola la tangente di celle in un raster.",
		tanDesc: "La funzione calcola la tangente dei pixel in un raster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Calcola i livelli di vegetazione, umidità e luminosità. Questa tecnica si basa su coefficienti che devono essere calcolati specificatamente per un sensore.",
		tasseledCapDesc: "La trasformazione Tasseled Cap (Kauth-Thomas) è progettata per analizzare e mappare le variazioni di fenomenologia di vegetazione e sviluppo urbano rilevate da vari sistemi di sensori satellitari. È noto come trasformazione Tasseled Cap, a seguito della forma della distribuzione grafica dei dati. La trasformazione ha fornito una logica per i modelli trovati nei dati Landsat MSS dei campi agricoli in funzione del ciclo di vita del raccolto. Essenzialmente, mentre i raccolti crescono dal seme alla maturità, vi è un aumento netto nell'infrarosso vicino e una diminuzione della riflettanza rossa basata sul colore del suolo<div><br/>L'utilità di questa trasformazione si è ampliata dal monitoraggio del raccolto all'analisi e al Mapping della vegetazione per supportare una varietà di applicazioni quali silvicoltura, gestione della vegetazione industriale, mappatura e gestione dell'ecosistema, inventario e monitoraggio della cattura e dei crediti di carbonio, sviluppo urbano e altro. Inoltre, è stata ampliata la compatibilità di Landsat MSS in modo da includere altri popolari sistemi satellitari, tra cui i sensori multispettrali Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, WorldView-2 e RapidEye.</div>",
		timesName: "Volte",
		timesSnip: "Moltiplica i valori di due raster in base alle singole celle.",
		timesDesc: "La funzione Volte moltiplica i valori di due raster in base ai singoli pixel.",
		transposeBitsName: "Trasponi bit",
		transposeBitsSnip: "Decomprime i bit del pixel di input e li associa a bit specificati nel pixel di output. Lo scopo di questa funzione è manipolare i bit da un paio di input, come i prodotti banda di qualità Landsat 8.",
		transposeBitsDesc: "La funzione Trasponi bit decomprime i bit del pixel di input e li associa a bit specificati nel pixel di output. Lo scopo di questa funzione è manipolare i bit da un paio di input, ad esempio i prodotti banda di qualità Landsat 8.",
		unitConversionName: "Conversione unità",
		unitConversionSnip: "Cambia i valori da un'unità di misura a un'altra.",
		unitConversionDesc: "Questa funzione converte i pixel da un’unità a un’altra. Supporta la conversione di distanza, velocità e temperatura.",
		vectorFieldName: "Campo vettoriale",
		vectorFieldSnip: "Visualizza i dataset con grandezza (u) e direzione (v) come frecce dove la grandezza è rappresentata dalla dimensione e la direzione è rappresentata dall'angolo della freccia.",
		vectorFieldDesc: "La funzione Campo vettoriale viene usata per combinare e convertire due raster in un raster a due bande con dati di tipo Grandezza-Direzione o di tipo U-V.<div><br/>Il valore U viene talvolta indicato come velocità zonale, mentre il valore V come velocità meridionale.</div>",
		viewshed2Name: "Campo di Visibilità",
		viewshed2Snip: "Determina le posizioni della superficie raster visibile a un insieme di feature osservatori, utilizzando metodi geodetici.",
		viewshed2Desc: "La funzione Campo di visibilità determina le posizioni della superficie raster visibili a un insieme di feature osservatore, utilizzando metodi geodetici<div><br/>La visibilità del centro di ciascun pixel è determinata da un test di analisi della linea di vista tra l'obiettivo e ciascun osservatore. Se un osservatore è in grado di vedere l’obiettivo al centro del pixel, il pixel è considerato visibile. Questo strumento determina la visibilità tenendo sempre conto della curvatura della terra.</div>",
		watershedName: "Spartiacque",
		watershedSnip: "Determina l'area contribuente su una serie di celle in un raster.",
		watershedDesc: "La funzione globale Spartiacque determina l'area contribuente su una serie di pixel in un raster. Gli spartiacque sono delineati da un raster di direzione del flusso che individua la direzione del flusso in ciascun pixel.",
		weightedOverlayName: "Sovrapposizione Verificata",
		weightedOverlaySnip: "Sovrappone più raster utilizzando una scala di misurazione e pesi comuni ciascuno in base alla sua importanza.",
		weightedOverlayDesc: "Questa funzione consente di sovrapporre più raster utilizzando una scala di misurazione e un peso comune, ciascuno in base alla relativa importanza.",
		weightedSumName: "Somma Verificata",
		weightedSumSnip: "Pesa e aggiunge un array di raster in base alle singole celle.",
		weightedSumDesc: "La funzione Somma verificata consente di sovrapporre più raster moltiplicando ciascuno per il relativo peso e sommandoli insieme.",
		windchillName: "Wind Chill",
		windchillSnip: "Combina la temperatura dell'aria circostante e la velocità del vento per calcolare il fattore windchill.",
		windchillDesc: "La funzione Wind Chill è utile per identificare condizioni invernali pericolose che, a seconda dei tempi di esposizione agli elementi, possono provocare congelamento o addirittura ipotermia. Il wind chill è un metodo di misurazione della sensazione di freddo di un individuo che prende in considerazione il vento con temperature già fredde. Maggiore è la velocità del vento, più rapidamente il corpo perderà calore e maggiore sarà il freddo percepito.",
		zonalRemapName: "Rimappatura zonale",
		zonalRemapSnip: "Ricalcola i pixel in un raster in base alle zone definite da un altro raster e a una mappatura di valori dipendente dalla zona definita da una tabella.",
		zonalRemapDesc: "Questa è una funzione che ricalcola i pixel in un raster, in base alle zone definite da un altro raster e a una mappatura di valori dipendente dalla zona definita da una tabella.",
		zonalStatisticsName: "Statistiche zonali",
		zonalStatisticsSnip: "Calcola statistiche sui valori di un raster all'interno delle zone di un altro dataset.",
		zonalStatisticsDesc: "La funzione calcola statistiche sui valori di un raster all'interno delle zone di un altro dataset. Una zona viene definita come tutte le aree nell'input che hanno lo stesso valore. Tali aree non devono essere contigue. Quando gli input di zona e di valore sono entrambi dei raster della stessa risoluzione, saranno usati direttamente. Se le risoluzioni sono diverse, verrà applicato un ricampionamento interno per far corrispondere le risoluzioni prima che venga eseguita l'operazione zonale.",
		flowLengthName: "Lunghezza Flusso",
		flowLengthSnip: "Calcola la distanza a monte o a valle, o distanza ponderata, lungo il percorso di flusso per ciascuna cella.",
		flowLengthDesc: "Questa è una funzione raster globale. Questa funzione crea un layer raster della distanza a monte o a valle, o distanza ponderata, lungo il percorso di flusso per ogni cella.<div><br/>Un utilizzo primario della funzione lunghezza di flusso è quello di calcolare la lunghezza del percorso di flusso più lungo all'interno di un bacino determinato. Questa misurazione viene spesso utilizzata per calcolare il tempo di concentrazione di un bacino. Questa operazione viene effettuata utilizzando l'opzione A monte. La funzione può inoltre essere utilizzata per creare diagrammi aree di distanza di piogge e straripamenti ipotetici utilizzando il raster ponderato come impedimento per il movimento verso il basso.</div>",
		streamOrderName: "Ordine di Flusso",
		streamOrderSnip: "Assegna un ordine numerico ai segmenti di un raster che rappresentano le diramazioni di una rete lineare",
		streamOrderDesc: "Questa è una funzione raster globale. Questa funzione crea un layer raster che assegna un ordine numerico ai segmenti di un raster che rappresentano le diramazioni di una rete lineare.<div><br/>L'output della funzione dell'ordine di flusso sarà di qualità maggiore se il layer raster di flusso di input e il layer raster di direzione di flusso di input derivano dalla stessa superficie. Se il raster di flusso deriva da un dataset di flusso rasterizzato, l'output potrebbe non essere utilizzabile poiché, su una base di cella-per-cella, la direzione non corrisponderà alla posizione delle celle di flusso. I risultati della funzione Accumulo di flusso possono essere utilizzati per creare una rete di flusso raster applicando un valore di soglia per la selezione delle celle con un flusso di accumulo alto. Ad esempio, le celle che hanno più di 100 celle che fluiscono al loro interno vengono utilizzate per definire la rete di flusso. Utilizzare la funzione Con o Set Null per creare un raster di rete di flusso nel quale i valori di accumulo del flusso di 100 o più vanno in un'unica cella, e il resto vengono posti in background (NoData). La rete di flusso risultante può essere utilizzata nella funzione dell'ordine di flusso. Questa funzione supporta solo un layer raster di direzione di flusso di input D8. Le direzioni di flusso D8 possono essere create utilizzando la funzione di direzione di flusso ed eseguite tramite il tipo di direzione di flusso predefinito D8.</div>",
		snapPourPointName: "Aggancia Punto di Versamento",
		snapPourPointSnip: "Aggancia i punti di versamento alle celle di maggior accumulo del flusso entro una determinata distanza",
		snapPourPointDesc: "Questa è una funzione raster globale. Questa funzione aggancia i punti di versamento alle celle di maggior accumulo del flusso entro una distanza specificata.<div><br/>La funzione aggancia punto di versamento viene utilizzata per assicurare la selezione di punti di flusso di accumulo alto quando vengono delineati i bacini di drenaggio utilizzando la funzione Spartiacque. Aggancia punto di versamento ricercherà all'interno di una distanza di aggancio intorno ai punti di versamento specificati, fino a quando non troverà una cella con il flusso di accumulo massimo e sposterà il punto di versamento in quella posizione. L'output è un layer raster intero quando le posizioni dei punti di versamento originali sono state aggiunte alle posizioni del flusso di accumulo più alto.</div>",
		sinkName: "Pozzo",
		sinkSnip: "Crea un raster che identifica tutti i sink o le aree di drenaggio interno",
		sinkDesc: "Questa è una funzione raster globale. Questa funzione crea un layer raster che identifica tutti i sink o aree di drenaggio interno. Un sink è una cella o un set di celle connesse spazialmente con una direzione di flusso alla quale non può essere assegnato uno degli otto valori validi in un raster di direzione di flusso. Questo può verificarsi se tutte le celle vicine sono più alte della cella di elaborazione o se due celle fluiscono una nell'altra creando un loop a di due celle.<div><br/>La funzione sink supporta solo un layer raster di direzione di flusso D8. Le direzioni di flusso D8 possono essere create utilizzando la funzione di direzione di flusso ed eseguite tramite il tipo di direzione di flusso predefinito D8. L'output della funzione sink è un raster intero, con ogni sink assegnato a un valore univoco. Questi valori univoci hanno un intervallo che va da uno al numero totale di sink. Ad esempio, se il numero totale di sink fosse 1000, l'intervallo di valori univoci andrebbe da 1 a 1000.</div>",
		aggregateName: "Aggrega",
		aggregateSnip: "Genera una versione di risoluzione ridotta di un raster.",
		aggregateDesc: "La funzione Aggrega ricampiona un raster di input su una risoluzione più approssimativa in base a una strategia di aggregazione specificata. Ogni cella di output contiene Sum, Minimum, Maximum, Mean o Median delle cellule di input racchiuse dall’estensione di quella cella.<div><br/>È possibile specificare il fattore per il quale moltiplicare la dimensione cella del raster di input. Ad esempio, un valore fattore cella di 3 risulterebbe in un output in cui la dimensione cella è tre volte superiore rispetto a quella del raster di input. È possibile definire come gestire l'estensione dell'output se il numero di righe o colonne nell'output non è un multiplo esatto del fattore di cella. Per impostazione predefinita, i confini superiore e destro saranno ampliati per coprire un'estensione spaziale più ampia rispetto a quella del raster di input, per garantire l'elaborazione di tutte le celle di input. In alternativa, i confini superiore e destro possono essere ridotti per coprire un'estensione più piccola, in modo che il numero di righe e colonne elaborato sia un multiplo esatto del fattore di cella. È possibile definire come dovranno essere gestite le celle NoData dal calcolo di aggregazione.​Il meccanismo predefinito prevede che le celle NoData di input che rientrano nell'estensione spaziale di una cella più grande nel raster di output saranno ignorate quando si determina il valore di quella cella di output. In alternativa, è possibile specificare che se all'interno dell'estensione spaziale di una cella di output esiste anche solo una cella NoData di input, tale cella sarà NoData nel raster di output.</div>",
		ccdcName: "Analisi CCDC",
		ccdcSnip: "Valuta le variazioni dei valori dei pixel nel tempo utilizzando l'algoritmo Continuous Change Detection and Classification (CCDC) e genera i risultati del modello.",
		ccdcDesc: "La funzione Analisi CCDC valuta le variazioni dei valori dei pixel nel tempo utilizzando l'algoritmo Continuous Change Detection and Classification (CCDC) e genera un raster multidimensionale contenente i risultati del modello. È supportata solo in combinazione con la funzione di analisi Detect Change Using Change in un modello di funzione raster. Per produrre un output raster, collegare la funzione di analisi CCDC alla funzione di analisi Detect Change Using Change, salvare come modello di funzione raster ed eseguire l'analisi raster con il modello di funzione.<div><br/>Questa funzione utilizza l'algoritmo Continuous Change Detection and Classification (CCDC) per valutare le variazioni dei valori dei pixel nel tempo per una pila di immagini. In una serie temporale di immagini ottiche o derivati di immagine (ad esempio, NDVI), i valori dei pixel possono fluttuare per varie ragioni: 1. Variazione stagionale: le variazioni dei valori dei pixel riflettono le variazioni della vegetazione a causa della variabilità stagionale di temperature e precipitazioni. Nell'emisfero settentrionale, ad esempio, ci aspettiamo di trovare una densità più alta di vegetazione verde in estate rispetto all'inverno; 2. Variazione graduale: le variazioni dei valori dei pixel rispecchiano le tendenze nella vegetazione o nelle acque di superficie a causa della variabilità climatica o delle pratiche di gestione del suolo a lungo termine. Ad esempio, il suolo nudo potrebbe estendersi gradualmente a causa della riduzione delle precipitazioni a lungo termine; e 3. Variazione brusca: le variazioni dei valori dei pixel rispecchiano le variazioni della copertura del suolo che accadono improvvisamente a causa di deforestazione, sviluppo urbano, calamità naturali, e così via. L'algoritmo CCDC identifica tutti e tre i tipi di variazione con lo scopo primario di identificare la variazione brusca. I modelli di tendenza e regressione armonica sono adattati ai dati per stimare la variazione stagionale e graduale, e le deviazioni improvvise dai modelli di tendenza sono indicatori di una variazione brusca.<div><br/>L'algoritmo CCDC è stato originariamente concepito per dati Landsat TM, Landsat ETM+ e Landsat OLI, dati di riflettanza della superficie e temperatura di luminosità. Tuttavia, la funzione di analisi Detect Change Using Change in combinazione con questa funzione rileverà la variazione per le immagini multibanda da qualunque sensore supportato, nonché derivati di immagini a singola banda come gli indici di banda. Ad esempio, è possibile eseguire un rilevamento continuo delle modifiche su un raster Normalize Difference Vegetation Index (NDVI), perché le variazioni brusche nell'NDVI possono essere indicative di deforestazione.</div>",
		computeChangeName: "Calcola variazione",
		computeChangeSnip: "Calcola la differenza tra due dataset raster categorici o continui.",
		computeChangeDesc: "La funzione Calcola variazione può essere utilizzata per elencare le differenze tra due raster classificati per l'analisi della variazione della copertura del suolo oppure per esaminare le variazioni tra due raster continui a singola banda, come l'elevazione, la temperatura, la copertura da cime di alberi, e così via.",
		detectChangeName: "Analisi Detect Change Using Change",
		detectChangeSnip: "Genera un layer raster contenente informazioni sulle variazioni di pixel utilizzando il raster di analisi delle variazioni di output.",
		detectChangeDesc: "<div>La funzione Analisi Detect Change Using Change genera un layer raster contenente informazioni sulle variazioni di pixel utilizzando il raster di analisi delle variazioni di output del raster di analisi. Il raster di variazione analisi deve essere generato da Analyse Change utilizzando lo strumento CCDC o lo strumento Analyse Changes utilizzando LandTrendr, o la funzione di raster analisi CCDC o la funzione raster analisi LandTrendr.</div><br><div>Questa funzione raster può essere combinata con la funzione raster analisi CCDC o la funzione raster LandTrendr in un modello funzione raster. Per produrre un output raster permanente, collegare l'output della funzione di analisi CCDC o LandTrendr alla funzione Detect Change Using Change, salvarlo come modello funzione raster ed eseguire l'analisi raster come modello.</div><br><div>Il parametro <strong>Tipo di variazione</strong> indica l'informazione che è stata generata. Le informazioni vengono estratte dal raster di analisi di modifica. Quando si esegue questa funzione su un output della funzione/strumento CCDC, è possibile scegliere tra le seguenti opzioni:</div><ul><li><strong>Ora di ultima variazione</strong>--La data più recente e l'ora in cui un pixel è stato contrassegnato come variazione.</li><li><strong>Ora di variazione più recente</strong>--La data e l'ora più recenti alle quali un pixel è stato contrassegnato come variazione.</li><li><strong>Ora di maggiore variazione</strong>--La data e l'ora alle quali è stata calcolata la variazione più significativa per un pixel.</li><li><strong>Numero di variazioni</strong>--Il numero totale di variazioni di un pixel.</li></ul><div>Quando si esegue questa funzione sull'output dalla funzione/attrezzo LandTrendr, sono disponibili le seguenti opzioni aggiuntive:</div><ul><li><strong>Ora della modifica più lunga</strong>--La data in cui un pixel è stato segnalato come variazione, all'inizio o alla fine del periodo di variazione più lungo.</li><li><strong>Ora della variazione più breve</strong>--La data in cui un pixel è stato segnalato come variazione, all'inizio o alla fine del periodo di modifica più breve.</li><li><strong>Ora di variazione più veloce</strong>--La data in cui un pixel è stato segnalato come variazione, all'inizio o alla fine del periodo di modifica più breve.</li><li><strong>Ora della variazione più lenta</strong>--La data in cui un pixel è stato segnalato come variazione, all'inizio o alla fine del periodo di variazione più lenta. </li></ul><div>Il raster di output è un raster multibanda nel quale ogni banda contiene informazioni di variazione dipendenti dal tipo di variazione selezionata e il numero massimo di variazioni specificate. Per esempio, se <strong>Tipo di variazione</strong> è impostato su <strong>Ora di variazione più recente</strong> e <strong>Numero massimo di variazioni</strong> è impostato su 2, la funzione calcola le due date più recenti quando la variazione è avvenuta tramite la serie di orari per ogni pixel. Il risultato è un raster nel quale la prima banda contiene le date della variazione più recente per pixel, e la seconda banda contiene le date della penultima variazione più recente per pixel.</div><br><div>Quando si applica questa funzione su un output dagli strumenti LandTrendr, è possibile scegliere se estrarre la data che contrassegni l'inizio di una variazione o la fine di una variazione utilizzando il parametro <strong>Data segmento</strong>. Per esempio, per comprendere come la variazione più recente in una serie di orari cominciati, impostare <strong>Cambia tipologia</strong> su <strong>Ora dell'ultima variazione</strong> e <strong>Data segmento</strong> su <strong>Inizio di un segmento</strong></div><br><div>Utilizzare i filtri parametri seguenti per estrarre dati più specifiche di variazione dal raster di variazione analisi:</div><ul><li><strong>Filtro per anno</strong>--Identificare le variazioni che avvengono all'interno di un periodo specifico, per esempio, se si sta cercando variazioni avvenute in un periodo di cinque anni di siccità.</li><li><strong>Filtro per durata</strong>--Identificare le variazioni che avvengono su un periodo di anni, per esempio, se si sta cercando variazioni brusche che siano avvenute in 1 o 2 anni. È possibile calcolare la durata a cui si è interessati per l'utilizzo della formula <strong>concludere anno - iniziare anno +1</strong>. Intervalli nella serie di orari possono essere inclusi.</li><li><strong>Filtro per rilevanza</strong>--Identificare le variazioni di una rilevanza data, per esempio, se si sta cercando solamente per variazioni grandi nell'indice NDVI della vegetazione. La rilevanza è un valore assoluto, in modo che i valori minimi e massimi non possano essere negativi. Per specificare la variazione direzionale, utilizzare il parametro <strong>Varia direzione</strong>.</li></ul>",
		distanceAccumulationName: "Accumulo distanza",
		distanceAccumulationSnip: "Calcola la distanza accumulata per ciascuna cella dalle origini, consentendo di ottenere la distanza in linea retta, la distanza di costo, la distanza della superficie reale, nonché i fattori di costo verticale e orizzontale.",
		distanceAccumulationDesc: "Accumulo distanza calcola la distanza da ciascuna posizione nell'area di studio all'origine più vicina o di costo minimo. Se vengono specificate solo le origini per l'input, allora si calcola una distanza in linea retta da ciascuna posizione nell'area di studio. Se come input vengono utilizzate sia le origini sia le barriere, allora Accumulo distanza calcola la distanza in linea retta intorno alle barriere.​Sia per il raster di origine sia per quello di barriera, il valore di sfondo deve essere NoData, mentre le origini e le barriere sono rappresentate con valori di cella validi. I valori validi includono lo zero. <div><br/>Quando un raster di superficie viene fornito come input, allora si calcola la distanza di superficie reale tra le celle. Per eseguire l'analisi di costo adoperando Accumulo distanza, è necessaria una superficie di costo. Se si fornisce una superficie di costo, allora il risultato è un raster della distanza di costo accumulata. Quando sono specificati fattori orizzontali e verticali, allora si considera la direzionalità mentre si accumula il costo. Esistono quattro caratteristiche di origine utilizzabili. Queste caratteristiche, che possono essere dell'origine o movimenti dall'origine, sono controllate da parametri specifici:​1. Accumulo iniziale: imposta il costo iniziale prima dell'avvio del movimento. 2. Accumulo massimo: specifica il costo che un'origine può accumulare prima di raggiungere il proprio limite. 3. Moltiplicatore da applicare ai costi: specifica la modalità di viaggio o la grandezza all'origine. 4. Direzione di viaggio: identifica se il movimento parte da un'origine e si sposta su posizioni non di origine, oppure se parte da posizioni non di origine e torna a un'origine.<div><br/>Per impostazione predefinita, il risultato di Accumulo distanza è una banda singola, che costituisce il raster di accumulo distanza. Tuttavia, è anche possibile creare una seconda banda, la banda di direzione contraria.​Questa banda indica in quale direzione andare per arrivare all'origine di costo minimo a partire da ciascuna posizione nell'area di studio. Entrambe le bande saranno necessarie per stabilire i percorsi ottimali all'interno dell'area di studio. Per generare un percorso, utilizzare prima la funzione Estrai banda per estrarre il raster di accumulo della distanza e il raster di direzione contraria. Utilizzare questi layer come input per la funzione Percorso di costo. Nella funzione, utilizzare il raster di accumulo della distanza come input del raster della distanza di costo e il raster di direzione contraria come input del raster backlink dei costi.</div>",
		distanceAllocationName: "Assegnazione della distanza",
		distanceAllocationSnip: "Calcola l'assegnazione della distanza per ciascuna cella dalle origini fornite in base a distanza in linea retta, distanza di costo, distanza della superficie reale e fattori di costo verticale e orizzontale.",
		distanceAllocationDesc: "Assegnazione della distanza calcola a quale origine è assegnata ciascuna posizione nell'area di studio. Se per l'input sono specificate solo le origini, allora le posizioni vengono assegnate utilizzando una distanza in linea retta rispetto all'origine più vicina. Se come input vengono utilizzate sia le origini sia le barriere, allora Assegnazione della distanza calcola la distanza in linea retta intorno alle barriere per stabilire a quale origine è assegnata una posizione.​Sia per il raster di origine sia per quello di barriera, il valore di sfondo deve essere NoData, mentre le origini e le barriere sono rappresentate con valori di cella validi. I valori validi includono lo zero.<div><br/>Per eseguire l'analisi di costo adoperando Assegnazione della distanza, è necessaria una superficie di costo. Se è specificata una superficie di costo, allora il risultato è un raster di assegnazione basato sul costo cumulativo, non sulla distanza in linea retta. Quando sono specificati fattori orizzontali e verticali, allora si considera la direzionalità mentre si accumula il costo. Quando un raster di superficie viene fornito come input, allora quando si stabilisce l'assegnazione si calcola la distanza di superficie reale percorsa nel passaggio tra le celle. Esistono quattro caratteristiche di origine utilizzabili. Queste caratteristiche, che possono essere dell'origine o movimenti dall'origine, sono controllate da parametri specifici:​1. Accumulo iniziale: imposta il costo iniziale prima dell'avvio del movimento. 2. Accumulo massimo: specifica il costo che un'origine può accumulare prima di raggiungere il proprio limite. 3. Moltiplicatore da applicare ai costi: specifica la modalità di viaggio o la grandezza all'origine. 4. Direzione di viaggio: identifica se il movimento parte da un'origine e si sposta su posizioni non di origine, oppure se parte da posizioni non di origine e torna a un'origine.<div><br/>Per impostazione predefinita, il risultato di Assegnazione della distanza è una banda singola, che costituisce il raster di assegnazione della distanza. Selezionando l'opzione booleana Genera riga e colonna di origine come bande aggiuntive nell'output si otterrà un raster multibanda costituito da tre bande. La prima banda è la banda di allocazione della distanza, la seconda banda contiene un indice di riga e la terza banda contiene un indice di colonna. Questi indici identificano la posizione della cella di origine che si trova alla minore distanza di costo cumulativa. L'indice della riga di origine e l'indice della colonna di origine possono essere utilizzati insieme per eseguire il mapping di intensità. Se si interroga una qualunque posizione nell'area di studio tra le bande due e tre, si conoscerà la riga e la colonna dell'origine di costo minimo per quella posizione.</div>",
		eucBackDirectionName: "Back Direction euclidea",
		eucBackDirectionSnip: "Calcola, per ogni cella, la direzione in gradi fino alla cella vicina seguendo il percorso più breve fino alla fonte più vicina evitando barriere.",
		eucBackDirectionDesc: "La funzione Back Direction euclidea crea un raster a virgola mobile continuo che rappresenta la direzione di ritorno all'origine più vicina in gradi evitando le barriere, nel caso in cui vi fossero barriere.<div><br/>Gli input della Back Direction euclidea sono l'origine in base alla quale sarà calcolata quella direzione. Un input opzionale è un raster che rappresenta le barriere all'interno dell'area di studio.​Sia per il raster di origine sia per quello di barriera, il valore di sfondo deve essere NoData, mentre le origini e le barriere sono rappresentate con valori validi. I valori validi includono lo zero. Per impostazione predefinita, il calcolo verrà eseguito fino all'estensione combinata di origini e barriere, più 2 righe e colonne. Se l'analisi serve solo all'interno di una distanza specifica dalle origini, allora è possibile utilizzare il parametro Distanza massima. Back Direction euclidea supporta nel calcolo sia un metodo Planare sia un metodo Geodetico. Il calcolo del metodo Planare verrà eseguito su un piano piatto proiettato utilizzando un sistema di coordinate cartesiane 2D. Il calcolo del metodo Geodetico verrà eseguito sull'ellissoide, il che significa che a prescindere dalla proiezione di input o di output i risultati non cambiano.<div><br/>Il risultato della funzione Back Direction euclidea può essere utilizzato in combinazione con il risultato della funzione Distanza euclidea per stabilire i percorsi più brevi dalle posizioni all'interno dell'area di studio all'origine. Sia il risultato di Back Direction euclidea sia quello di Distanza euclidea vengono utilizzati nella funzione Percorso di costo insieme alle destinazioni per generare i percorsi più brevi.</div>",
		expandName: "Espandi",
		expandSnip: "Espande le zone selezionate di un raster per zone del numero specificato di celle.",
		expandDesc: "Con la funzione globale Espandi, è possibile generalizzare o semplificare i raster ampliando zone specifiche. È anche possibile controllare la quantità di generalizzazione che avverrà.<div><br/>Le zone selezionate aumenteranno di dimensione espandendosi in altre zone. Concettualmente, è possibile visualizzare i valori di zona selezionati come zone in primo piano, mentre gli altri valori rimangono zone sullo sfondo. Le zone in primo piano possono espandersi nelle zone sullo sfondo.<div><br/>La quantità di generalizzazione può essere controllata con il parametro Numero di celle. Per impostazione predefinita, questo valore è 1, il che significa che le zone selezionate si espanderanno della quantità corrispondente alla dimensione di una sola cella. Per aumentare il grado di generalizzazione, è possibile specificare un valore più grande per questo parametro. Concettualmente, ciò equivale ad eseguire lo strumento tante volte quante il numero specificato e con i risultati dell'esecuzione precedente come input dell'iterazione successiva.</div>",
		trendAnalysisName: "Generare tendenza",
		trendAnalysisSnip: "Stima la tendenza per ciascun pixel lungo una dimensione per una o più variabili in un raster multidimensionale.",
		trendAnalysisDesc: "<div>Questa funzione può essere utilizzata per adattare dati lungo una linea di trend lineare, armonica o polinomica o può essere utilizzata per effettuare rilevamento del trend utilizzando il test Mann-Kendall o Seasonal-Kendall.</div><br><div>Il raster trend di output generato con questa funzione è utilizzato come input alla funzione <strong>Predici utilizzando trend</strong>.</div><br><div>I test Mann-Kendall o Seasonal-Kendall sono utilizzati per determinare se c'è un trend monotonico nei dati. Essi non sono parametrici, significa che non assumono una distribuzione specifica dei dati. Il test Mann-Kendall non considera la correlazione seriale o gli effetti stagionali. Se i dati sono stagionali, il testo Seasonal-Kendall è più appropriato.</div><br><div>Se lo strumento è utilizzato per eseguire sia il testo Mann-Kendall che il Seasonal-Kendall, l'output è un raster a cinque bande come segue:</div><ul><li>Banda 1 = Pendenza di Sen</li><li>Banda 2 = valore p</li><li>Banda 3 = Punteggio Mann-Kendall (S)</li><li>Banda 4 = Varianza S</li><li>Banda 4 = Varianza S</li><li>Banda 5 = Punteggio Z</li></ul><div>Gli output dal test Mann-Kendall o Seasonal-Kendall possono essere usare per determinare quali pixel nella serie di orari multidimensionale abbia trend staticamente significativi. È possibile utilizzare questa informazione nella congiunzione con l'analisi di trend lineare, armonico e polinomiale per estrarre i trend significativi nella serie di orari. È possibile generare una maschera inclusi pixel con valori p significativi, eseguire la maschera al raster multidimensionale, e utilizzare questo raster multidimensionale mascherato come input allo strumento per eseguire un'analisi di trend lineare, armonico o polinominale.</div><br><div>Ci sono tre opzioni di linea di trend per adattare un trend a valori variabili lungo una dimensione: lineare, polinomiale e armonico.</div><br><div>Per un'analisi di trend lineare, l'output è un raster a tre bande come segue:</div><ul><li>Banda 1 = Pendenza</li><li>Banda 2 = Intercettare</li><li>Banda 3 = Radice dell'errore quadrico medio (RMSD) o l'errore attorno alla linea che si adatta meglio</li></ul><div>Per l'analisi di trend polinominale, il numero di bande nell'output dipende dall'ordine polinominale. L'adattamento polinominale di secondo ordine produce un raster a quattro bande come segue:</div><ul><li>Banda 1 = Polinominale_2</li><li>Banda 2 = Polinominale_1</li><li>Banda 3 = Polinominale_0</li><li>Banda 4 = RMSE</li></ul><div>Questo adattamento polinominale di terzo ordine produce un raster a cinque bande come segue:</div><ul><li>Banda 1 = Polinominale_3</li><li>Banda 2 = Polinominale_2</li><li>Banda 3 = Polinominale_1</li><li>Banda 4 = Polinominale_0</li><li>Banda 5 = RMSE</li></ul><div>Per analisi di trend armonico, il numero di bande nell'output dipende sulla frequenza armonica. Quando la frequenza è impostata su 1, l'output è un raster a cinque bande come segue:</div><ul><li>Banda 1 = Pendenza</li><li>Banda 2 = Intercezione</li><li>Banda 3 = Harmonic_sin1</li><li>Banda 4 = Harmonic_cos1</li><li>Banda 5 = RMSE</li></ul><div>Quando la frequenza è impostata su 2, l'output è un raster a cinque bande come segue:</div><ul><li>Banda 1 = Pendenza</li><li>Banda 2 = Intercettazione</li><li>Banda 3 = Harmonic_in1</li><li>Banda 4 = Harmonic_cos1</li><li>Banda 5 = Harmonic_sin2</li><li>Banda 6 = Harmonic_cos2</li><li>Banda 7 = RMSE</li></ul><div>Il parametro <strong>Lunghezza di ciclo</strong> di un'analisi di trend armonico è utilizzata per indicare il numero e la lunghezza di cicli che ci si aspetta di vedere nei dati in un giorno o un anno. Per esempio, se si prevede che i dati subiscano due cicli di variazione in un anno, la lunghezza del ciclo sarà di 182,5 giorni o 0,5 anni. Se si dispone di dati di temperatura raccolti ogni tre ore, e c'è un ciclo di variazione al giorno, la lunghezza del ciclo è un giorno.</div><br><div>Il parametro <strong>Frequenza</strong> per analisi di trend armonico è utilizzato per descrivere il modello armonico per adattarlo ai dati. Se la frequenza è impostata su 1, una combinazione di curva lineare e armonica di primo ordine sarà utilizzare per adattarla al modello. Se la frequenza è 2, una combinazione di curva lineare, di primo ordine, armmonica e una curva di secondo ordine armonica verrà utilizzata per adattare i dati. Se la frequenza è 3, una curva armonica aggiuntiva di terzo ordine sarà utilizzata per formare i dati e così via.</div><br><div>La bontà di adattamento di un modello statistico può essere generata come output opzionale. La radice dell'errore quadratico medio (RMSE), il coefficiente di determinazione e il valore p della pendenza di trend può essere calcolato e rappresentato da simboli. Simboleggiare il layer raster trend di output utilizzando la simbologia <strong>RGB</strong> e specificare le statistiche come bande rosse, verdi e blu.</div><br>",
		spectralUnmixingName: "Separazione spettrale lineare",
		spectralUnmixingSnip: "Esegue la classificazione dei sottopixel e calcola l'abbondanza frazionaria di diversi tipi di copertura del suolo per i singoli pixel.",
		spectralUnmixingDesc: "La funzione Separazione spettrale lineare calcola la copertura frazionaria per i singoli pixel che contengono più tipi di copertura del suolo. Genera un layer multibanda, in cui ciascuna banda corrisponde all'abbondanza frazionaria di ciascuna classe di copertura del suolo. Ad esempio, è possibile utilizzarla per eseguire una classificazione della copertura del suolo su un'immagine multispettrale per identificare la vegetazione fotosintetica, il suolo nudo e la vegetazione morta o non fotosintetica.<div><br/>L'ordine del raster multibanda di output segue l'ordine del profilo spettrale di input. Il numero di classi non può superare il numero di bande nel raster di input. Ad esempio, non è possibile estrarre informazioni su più di 8 classi da un raster a 8 bande.</div>",
		multidimensionalFilterName: "Filtro multidimensionale",
		interpolateRasterByDimensionFunctionName: "Interpolare il raster per dimensione",
		interpolateRasterByDimensionFunctionSnip: "Interpola un raster multidimensionale a valori di dimensione specificati utilizzando sezioni adiacenti.",
		interpolateRasterByDimensionFunctionDesc: "<p>Questa funzione consente di stimare i valori dei pixel per una porzione di dimensione non definita in un raster multidimensionale. Ad esempio, se si dispone di un set di dati contenente la temperatura dell'oceano a livello della superficie e a 100 metri sotto il livello del mare e si desidera stimare la temperatura a 50 metri sotto il livello del mare, è possibile utilizzare questa funzione per ottenere una stima a quella profondità utilizzando il Definizione della dimensione dei valori.</p><p>Puoi anche eseguire il downsampling di un set di dati mensile in un set di dati giornaliero utilizzando la definizione della dimensione Per intervallo e specificando il valore del parametro Passo come 1 e il valore del parametro Unità come Giorni.</p><p>Utilizzare la definizione della dimensione Per raster di destinazione per stimare il valore per il raster di destinazione.</p>",
		multidimensionalFilterSnip: "Crea un layer raster da un dataset raster multidimensionale o da un layer raster multidimensionale sezionando i dati lungo le variabili e le dimensioni definite.",
		multidimensionalFilterDesc: "Il Filtro multidimensionale crea un layer raster multidimensionale filtrando ed estraendo un sottoinsieme di variabili da un raster multidimensionale. Ad esempio, si possiede un dataset multidimensionale che contiene 30 anni di dati mensili sulle precipitazioni e si desiderano estrarre solo i dati di tutti i mesi di gennaio per osservare le variazioni delle precipitazioni in quel mese.<div><br/>Utilizzare il parametro Definizione dimensione per sezionare le dimensioni utilizzando un intervallo, un valore o un intervallo di valori.​ Ad esempio, se si hanno a disposizione 10 anni di dati sulla salinità degli oceani, raccolti mensilmente e a intervalli di 2 metri di profondità fino ai 500 metri, è possibile utilizzare le diverse opzioni di definizione della dimensione per i seguenti scenari.​Scenario 1: estrarre i dati sulla salinità per il mese di gennaio nell'arco di un periodo di 10 anni. Scegliere Per valori, impostare Dimensione su StdTime e impostare Valori su Gennaio. Scenario 2: sezionare i dati sulla salinità in un intervallo di profondità da 0 a 150 m. Scegliere Per intervalli, impostare Dimensione su StdZ e impostare Valore minimo su -150 e Valore massimo su 0. Scenario 3: estrarre i dati sulla salinità per i primi 10 giorni di ogni mese di gennaio nell'arco di un periodo di 10 anni. Scegliere Per iterazione, impostare Dimensione su StdTime, impostare Inizio della prima iterazione e Fine della prima iterazione sull'inizio e sulla fine corrispondenti del periodo di iterazione, impostare Passaggio su 1 e impostare Unità su Anni.</div>",
		multidimensionalRasterName: "Raster multidimensionale",
		multidimensionalRasterSnip: "Aggiunge dati multidimensionali a una mappa come layer raster multidimensionale.",
		multidimensionalRasterDesc: "La funzione Raster multidimensionale aggiunge dati multidimensionali a una mappa come layer raster multidimensionale. Questa funzione è utile quando si eseguono flussi di lavoro di analisi raster utilizzando una catena di funzioni.<div><br/>I dataset raster multidimensionali supportati includono netCDF, GRIB, HDF e CRF di Esri. Sono supportati anche i dataset di mosaico multidimensionali.</div>",
		optimalPathAsRasterName: "Percorso ottimale come raster",
		optimalPathAsRasterSnip: "Calcola il percorso di costo minimo da un'origine a una destinazione.",
		optimalPathAsRasterDesc: "Questa funzione globale produce un raster di output che registra il percorso o i percorsi ottimali, dalle posizioni selezionate alla cella di origine più vicina definita nella superficie di costo cumulativo, in termini di distanza di costo.<div><br/>È generalmente richiesta l'esecuzione di una o più funzioni di costo ponderato (Accumulo distanza o Assegnazione della distanza) prima di eseguire la funzione Percorso ottimale come raster per creare i raster di direzione contraria e accumulo distanza di input.​Questi sono layer raster di input obbligatori per la funzione Percorso ottimale. I valori sul percorso ottimale di output rappresentano il numero di percorsi in una posizione data.​In molti casi, i percorsi seguono lo stesso itinerario, lasciando un'origine e poi divergendo per dirigersi verso destinazioni diverse. Ad esempio, un valore uno indica che c'è un solo percorso ottimale in una posizione data, mentre un valore cinque significa che in quella posizione ci sono cinque percorsi ottimali che attraversano quella cella nell'area di studio.<div><br/>I dati della destinazione di input devono essere un layer raster. L'insieme delle celle di destinazione è costituito da tutte le celle nel raster di input che contengono valori validi. Le celle con valori NoData non sono inclusi nell'insieme. Il valore zero è considerato una destinazione legittima. È possibile creare un raster di destinazione utilizzando gli strumenti di estrazione. Se si dispone di feature di destinazione o origine, è possibile convertirle in raster utilizzando la funzione Rasterizza feature. Utilizzare il raster di accumulo distanza o di direzione contraria come input del raster per la funzione di rasterizzazione. Questo garantirà che la feature viene rasterizzata utilizzando la stessa dimensione cella, estensione e riferimento spaziale degli altri raster nella funzione Percorso ottimale come raster.​La funzione Percorso ottimale come raster può anche essere utilizzata per derivare il percorso di minore resistenza da un modello di elevazione digitale (DEM). In questo caso, utilizzare il DEM per il raster di accumulo distanza di input e l'output della funzione Direzione flusso per il raster di direzione contraria.</div>",
		trendName: "Predire utilizzando una tendenza",
		trendSnip: "Calcola un layer raster multidimensionale previsto utilizzando il raster di tendenza di output dalla funzione Genera tendenza o dallo strumento di geoprocessing Genera raster tendenza.",
		trendDesc: "La funzione Predire utilizzando una tendenza calcola un layer raster multidimensionale previsto utilizzando il raster di tendenza di output dalla funzione Genera tendenza o dallo strumento di geoprocessing Genera raster tendenza.",
		rasterCollectionName: "Elaborare raccolta di raster",
		rasterCollectionSnip: "Elabora ciascuna sezione in un raster multidimensionale o ciascun elemento in un raster di mosaico.​Questa funzione può anche aggregare più sezioni in un'unica sezione.",
		rasterCollectionDesc: "La funzione Elaborare raccolta di raster elabora ciascuna sezione in un raster multidimensionale o ciascun elemento in un raster di mosaico.​Questa funzione può anche aggregare più sezioni in un'unica sezione.<div><br/>Questa funzione elabora ciascuna sezione in un raster multidimensionale o raster mosaico utilizzando un modello di funzione raster.​Questa funzione supporta le seguenti opzioni: 1. Specificare un modello di funzione raster per Funzione elemento. Ad esempio, si possiede un dataset di mosaico che contiene 20 anni di immagini Landsat e si desidera calcolare l'NDVI per ciascuna scena nella serie temporale. Per Funzione elemento, specificare un modello di funzione raster che contiene la funzione raster​NDVI. 2. Specificare un modello di funzione raster per la funzione Aggregazione. Ad esempio, si possiede un raster multidimensionale che contiene 10 anni di dati sulla temperatura giornaliera e si desidera calcolare la temperatura massima per ciascun anno. Nella funzione Aggregazione, specificare un modello di funzione raster che contenga la funzione Statistiche cella, con l'operazione impostata su Massimo. In Definizione aggregazione, impostare Dimensione su StdTime, impostare Tipo su Parola chiave intervallo e Intervallo parola chiave su Ogni anno. Si noti che se il dataset di mosaico di input non è multidimensionale, la funzione di aggregazione non rispetterà la definizione di aggregazione.​La funzione di aggregazione aggregherà tutti gli elementi o ciascun gruppo in uno solo, se sono definiti nel modello della funzione di aggregazione.​Per maggiori informazioni sull'uso dei gruppi in un dataset di mosaico, consultare Utilizzo elementi del dataset di mosaico in Modelli di funzione raster. 3. Specificare un modello di funzione raster per Funzione di elaborazione. La funzione o la catena di funzioni in questo modello viene utilizzata per visualizzare il nuovo raster elaborato.​Ad esempio, specificare un modello di funzione raster che contenga la funzione Colormap per cambiare la modalità di visualizzazione del layer raster elaborato. Si prega di notare che se l'input è un raster multidimensionale, la funzione di elaborazione viene applicata alla sezione di visualizzazione corrente.​Se l'input è un layer mosaico o un dataset di mosaico, la funzione di elaborazione viene applicata al raster di mosaico utilizzando il primo metodo per risolvere le sovrapposizioni. 3. Specificare i modelli per qualunque combinazione delle tre funzioni. Ad esempio, si possiede un dataset di mosaico contenente immagini Landsat di serie temporali e si desidera generare un'immagine composita dell'NDVI massimo. Per Funzione elemento, specificare un modello di funzione raster che contiene la funzione raster​NDVI. Per la funzione Aggregazione, specificare un modello di funzione raster che contenga la funzione Statistiche cella, con l'operazione impostata su Massimo. Per la funzione di elaborazione, specificare un modello di funzione raster che contiene la funzione Colormap. Si prega di notare che l'ordine di elaborazione della funzione segue l'ordine dei parametri di input. Ad esempio, la funzione Elemento sarà elaborata per prima.</div>",
		randomName: "Casuali",
		randomSnip: "Crea un raster con valori pixel casuali provenienti da una distribuzione pseudo casuale. Sono supportate varie distribuzioni e vari generatori di numeri casuali.",
		randomDesc: "La funzione Casuale crea un raster con valori pixel casuali che possono essere utilizzati nei modelli di funzione raster o nei dataset di mosaico.<div><br/>Molte funzioni hanno bisogno di uno o più raster di input; la funzione Casuale, invece, non richiede nessun raster di input. Ciò significa che si comporta in modo più simile a un dataset raster che a una funzione, quindi è necessario prestare particolare attenzione quando viene aggiunta o rimossa da una catena di funzioni.</div>",
		shrinkName: "Riduci",
		shrinkSnip: "Riduce le zone selezionate di un numero specificato di celle sostituendole con il valore della cella più frequente nelle vicinanze.",
		shrinkDesc: "Con la funzione globale Riduci, è possibile generalizzare o semplificare i raster rimpicciolendo zone specifiche. È anche possibile controllare la quantità di generalizzazione che avverrà.<div><br/>Le zone selezionate si ridurranno, o diminuiranno di dimensioni, e le celle delle zone circostanti si espanderanno all'interno di esse. Concettualmente, è possibile visualizzare i valori di zona selezionati come zone in primo piano, mentre gli altri valori rimangono zone sullo sfondo. Le celle nelle zone in primo piano possono essere sostituite dalle celle nelle zone di sfondo. È anche possibile sostituire le isole sottili all'interno di una zona, che possono essere visualizzate come confini condivisi con la zona.<div><br/>La quantità di generalizzazione può essere controllata con il parametro Numero di celle. Per impostazione predefinita, questo valore è 1, il che significa che le zone selezionate si ridurranno della quantità corrispondente alla dimensione di una sola cella. Per aumentare il grado di generalizzazione, è possibile specificare un valore più grande per questo parametro. Concettualmente, ciò equivale ad eseguire lo strumento tante volte quante il numero specificato e con i risultati dell'esecuzione precedente come input dell'iterazione successiva.</div>",
		trendToRGBName: "Da Tendenza a RGB",
		trendToRGBSnip: "Converte un raster di tendenza in un raster a tre bande (rosso, verde e blu).",
		trendToRGBDesc: "La funzione Da Tendenza a RGB converte un raster di tendenza in un raster a tre bande (rosso, verde e blu) Il raster di tendenza è generato dalla funzione raster Genera tendenza o dalla funzioni raster Analisi CCDC.<div><br/>Questa funzione è utile per visualizzare i dati dei coefficienti dei modelli della funzione Genera tendenza o dalla funzione Analisi CCDC. Entrambe le funzioni stimano le tendenze nei valori dei pixel mutevoli, ma i risultati delle funzioni sono difficili da interpretare direttamente.<div><br/>Come per molte funzioni raster, potrebbe essere necessario utilizzare la Regolazione gamma dinamica (DRA) per visualizzare meglio i risultati di questa funzione.</div>",
		landTrendrName: "Analisi LandTrendr",
		landTrendrSnip: "Valuta le variazioni dei valori dei pixel nel corso del tempo utilizzando il metodo di rilevamento delle tendenze di disturbo e di recupero basato su Landsat (LandTrendr) e genera un raster di analisi delle variazioni contenente i risultati del modello.",
		landTrendrDesc: "Questa funzione raster può essere utilizzata solo come input alla funzione raster 'Individuare variazione utilizzando l'analisi delle variazioni'. Per generare un output raster, collegare la funzione di analisi LandTrendr alla funzione 'Individuare variazione utilizzando l'analisi delle variazioni' in un modello di funzione raster e usare tale modello come input nello strumento di geoprocessing 'Generare raster da funzione raster'. Il risultato è un raster contenente informazioni relative all'ora in cui i valori dei pixel sono variati.<div><br>Lo scopo di questa funzione raster è estrarre le variazioni in una feature osservata, quindi le immagini multidimensionali ideali di input dovrebbero catturare un'osservazione coerente nel tempo e non dovrebbero includere interferenze atmosferiche o sensoriali, nuvole o ombre di nuvole. La buona prassi è utilizzare dati normalizzati e che possono essere mascherati utilizzando una banda di QA, ad esempio i prodotti di riflettanza superficiale di Landsat Collection 1 con una maschera a nuvola.<div><br>La funzione esegue l'analisi su un'immagine all'anno e il numero di sezioni annuali deve essere uguale o superiore al valore specificato nel parametro <strong>Numero minimo di osservazioni</strong>. Si raccomanda di disporre di almeno sei anni di dati.<div><br>Se si dispone di dati mensili, settimanali o giornalieri, si consiglia di selezionare più immagini di ogni anno (preferibilmente della stessa stagione), rimuovere le nuvole e l'ombra delle nuvole, quindi combinare le immagini per generare un'unica immagine che catturi bene l'osservazione. Se come raster multidimensionale di input vengono forniti dati mensili, settimanali o giornalieri, la funzione identificherà una sezione da analizzare in base alla data più vicina a quella fornita nel parametro <strong>Data gestione delle tolleranze</strong>.<div><br>Una feature in un paesaggio spesso richiede tempo per riprendersi da una variazione non permanente come un incendio boschivo o un'infestazione di insetti. Per controllare la velocità di recupero riconosciuta dal modello, impostare il parametro Soglia di recupero. Un segmento distinto non può avere un tasso di recupero più veloce di 1/soglia di recupero.<div><br>Il recupero da un cambiamento del paesaggio può avvenire in senso positivo o negativo. Ad esempio, quando un paesaggio subisce una deforestazione, una serie temporale di valori dell'indice di vegetazione mostra un calo dei valori dell'indice e il recupero mostra un graduale aumento dei valori dell'indice di vegetazione o una tendenza di recupero positiva. Specificare la direzione della tendenza di recupero con il parametro <strong>Il recupero ha aumentato la tendenza</strong>.",
		aggregateMultidimensionalName: "Aggregare multidimensionale",
		aggregateMultidimensionalSnip: "Combina i dati della variabile raster multidimensionale esistente lungo una dimensione.",
		aggregateMultidimensionalDesc: "La funzione Aggregata Multidimensionale crea un layer raster multidimensionale combinando i dati variabili del raster multidimensionale con una dimensione.<div><br>Usa il parametro di Definizione della Dimensione <strong></strong> per filtrare previamente i dati di input che vuoi aggregare. Ad esempio, se hai 30 anni di dati mensili, ma vuoi solamente creare un layer aggregato per i primi 15 anni, puoi usare il parametro <strong>di Definizione della Dimensione</strong> per specificare gli anni da includere nell'analisi.<div><br><ul><li>Estrai i dati di salinità per il mese di gennaio durante un periodo di 10 anni. Scegli <strong>In base ai Valori</strong>, adatta <strong>la Dimensione</strong> al <strong>Fuso Orario</strong>, ed imposta <strong>i Valori</strong> al <strong>gennaio</strong>.</li><li>Ritaglia i dati di salinità all'interno di un intervallo di profondità che va da 0 a 150 metri. Scegli <strong>In base agli Intervalli</strong>, adatta <strong>la Dimensione</strong> al <strong>Fuso Orario</strong>, ed imposta <strong>il Valore Minimo</strong> a <strong>-150</strong> e <strong>il Valore Massimo</strong> a <strong>0</strong>.</li><li>Estrai i dati di salinità per i primi 10 giorni di ogni gennaio durante un periodo di 10 anni. Scegli <strong>Per Iterazione</strong>, imposta <strong>la Dimensione</strong> al <strong>FusoOrario</strong>, imposta <strong>Inizio della prima iterazione</strong> e <strong>Fine della prima iterazione</strong> all'inizio e alla fine corrispondenti al periodo dell'iterazione, imposta <strong>Passaggio</strong> a <strong>1</strong>, e imposta <strong>Unità</strong> a <strong>Anni</strong>.</li></ul><div><br>Usa i parametri <strong>di Definizione dell'Aggregazione</strong> per scegliere la dimensione da stabilire e l'intervallo dell'aggregazione usando una parola chiave, un valore o un intervallo di valori. Ad esempio, se si dispone di 30 anni di dati sulla temperatura della superficie del mare, raccolti quotidianamente e ogni 5 metri di profondità fino a 100 metri, è possibile utilizzare le diverse opzioni di intervallo per i seguenti scenari:<div><br><ul><li>aggregare i dati di temperatura giornalieri in dati mensili, dove il risultato è un raster multidimensionale con 12 sezioni di tempo, ognuna delle quali è l'aggregato di ogni mese attraverso tutti gli anni. Scegli <strong>la Parola Chiave dell'Intervallo</strong> ed imposta la parola chiave a <strong>Ricorrente a cadenza Mensile</strong>.</li><li>Aggrega i dati sulla temperatura giornalieri in dati mensili, da cui il risultato è un raster multidimensionale con 360 fette, o 12 fette temporali per anno (30 anni x 12 mesi = 360 fette). Scegli <strong>la Parola Chiave dell'Intervallo</strong> ed imposta la parola chiave <strong>a cadenza Mensile</strong>.</li><li>Aggrega i dati mensili sulla temperatura ad intervalli di 4 mesi. Scegli <strong>il Valore dell'Intervallo</strong>, imposta <strong>l'Intervallo del Valore</strong> a 4, ed imposta <strong>l'Unità</strong> a <strong>Mesi</strong>.</li><li>Aggrega i dati sulla temperatura da 0 a 25 metri, poi da 25 a 50 metri, poi da 50 a 100 metri. Scegli <strong>le Serie di Intervalli</strong> e specifica le profondità minime e massime come <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Unisci raster",
		mergeRastersSnip: "Consente di combinare più dataset raster spazialmente o attraverso variabili e dimensioni.",
		mergeRastersDesc: "Questa funzione consente di creare un raster unito da una lista di raster. Ad esempio, se si dispone di un dataset a mosaico che contiene 30 anni di dati mensili sulle precipitazioni e un altro dataset con 10 anni di dati mensili sulla temperatura, è possibile combinarli in un raster multidimensionale con entrambe le variabili. <div><br>Se i raster multidimensionali di input contengono variabili diverse, il raster multidimensionale di output conterrà tutte le variabili. <div><br>Se i raster multidimensionali di input contengono dimensioni o valori di dimensione diversi, il raster multidimensionale di output includerà tutte le dimensioni e i valori di dimensione. <div><br>Se i raster multidimensionali di input contengono le stesse dimensioni e variabili ma estensioni spaziali diverse, il raster multidimensionale di output includerà le variabili e le dimensioni attraverso le estensioni spaziali unite.<div><br>Questa funzione può essere utilizzata anche quando si dispone di più raster che si desidera trattare come un singolo elemento, ad esempio quando si calcolano le stesse statistiche per tutti o durante il bilanciamento dei colori in modo da non dover bilanciare ogni immagine separatamente. Ciò è utile quando si lavora con immagini memorizzate come tile separati a causa di vincoli di dimensione del file. In tal modo, i tile saranno trattati come parte della stessa immagine.",
		boundaryCleanName: "Pulizia Boundary",
		boundaryCleanSnip: "Smussa il confine tra le zone.",
		boundaryCleanDesc: "<p>La funziona generalizza o semplifica i raster smussando i confini tra le zone. La funzione fornisce opzioni per controllare come le celle o le zone nell'input influenzino lo smussamento e la quantità che verrà applicata. Ogni cella di ingresso viene valutata utilizzando i suoi otto vicini immediati.</p><p>Il processo di smussamento prima ordina le celle vicine secondo una particolare priorità. La priorità determina quale zona dalle celle vicine possono sostituire il valore delle celle in elaborazione nell'output.</p><p>La priorità può essere basata o su il valore nelle zone o sulla grandezza nelle zone. Il parametro <strong>Tipo di ordinamento</strong> determina il tipo di ordinamento da utilizzare. </p><p>L'impostazione di default<strong>Non ordinare</strong> valuta la priorità basata sul valore delle zone. Le celle dalle zone con grandi valori avranno una priorità più alta per espandersi nelle zone con valori più bassi.</p><p>La grandezza o area totale delle zone può essere utilizzata per ordinare la priorità. Con l'impostazione <strong>Decrescente</strong>, le zone sono ordinate per grandezza in ordine decrescente. Le zone con area totale maggiore avranno la priorità di espandersi in zone con aree minori. Tramite l'impostazione <strong>Crescente</strong>, è vero il contrario: le zone con aree totali minori avranno la priorità di espandersi in zone con aree totali maggiori. </p><p>La quantità di smussamento è controllata dal parametro <strong>Esegui due volte espansione e contrazione</strong>, che determina il numero di volte che il processo di espansione e contrazione verrà eseguito.</p><p>Con l'impostazione non selezionata, il processo di espansione e contrazione viene eseguito una volta sola. Con l'impostazione selezionata, il processo di espansione e contrazione viene eseguito due volte, risultando in un grado aggiuntivo di smussamento dei confini delle zone.</p><p>Se i valori di tutte le otto celle vicine sono le stesse delle celle in elaborazione, la cella di output manterrà il valore delle celle di input.</p>",
		predictUsingRegressionName: "Predici utilizzando regressione",
		predictUsingRegressionSnip: "Calcola un rasted predetto in base ai dati raster di input e a un modello di regressione. Il modello di regressione è l'output proveniente dallo strumento di geoprocessing raster <strong> Modello di Regressione Alberi Casuali</strong>.",
		predictUsingRegressionDesc: "<p>Il modello di regressione è definito in un file definizione di regressione Esri (.ecd). Contiene tutte le informazioni di un dataset o set di dataset specifici e del modello di regressione, e viene generato dallo strumento di geoprocessing raster <strong> Modello di Regressione Alberi Casuali</strong>.</p><p>L'input può essere a banda singola, multibanda o raster multidimensionale, o tutti i tipi precedenti. I tipi di raster di input devono essere dello stesso tipo di raster addestrato dal modello di regressione.</p><ul><li>Quando l'input è un raster multibanda ogni banda viene considerata come una variabile di predizione. Le bande devono essere nello stesso ordine dell'input delle multibande usato nello strumento di addestramento del modello di regressione.</li><li>Quando l'input è un raster multidimensionale, ognivariabile è considerata una variabile di predizione, e deve essere a banda singola e avere una dimensione temporale. L'ordine e i nomi della variabile devono essere uguali all'input di quando il modello di regressione è stato addestrato. L'output è un raster multidimensionale.</li><li>L'input può essere un elenco di elementi. Il numero e l'ordine degli elementi deve corrispondere all'input di quando il modello di regressione è stato addestrato.</li></ul>",
		dimensionalMovingStatisticsName: "Statistiche del movimento dimensionale",
		dimensionalMovingStatisticsSnip: "Calcola le statistiche su una finestra mobile su dati multidimensionali lungo una dimensione specificata.",
		dimensionalMovingStatisticsDesc: "<p>La funzione Statistiche mobili dimensionali calcola varie statistiche all'interno di una finestra predefinita per tutti i valori di dimensione lungo una dimensione. Questa funzione accetta un livello raster multidimensionale come input e crea un livello raster multidimensionale come output con la stessa dimensione dimensionale del livello di input.</p><p>È possibile specificare una dimensione per la quale vengono presi in considerazione i valori di dimensione durante il calcolo. Per impostazione predefinita, calcola lungo la prima dimensione non spaziale. È inoltre possibile specificare una dimensione della finestra specificando i parametri Finestra indietro e Finestra avanti.</p><p>Quando il Tipo di statistica è impostato su Percentile, i parametri Valore percentile e Tipo di interpolazione percentile diventano disponibili. È possibile utilizzare questi parametri per specificare il percentile da calcolare e scegliere rispettivamente il tipo di interpolazione da utilizzare. Quando il Tipo di statistica è impostato su Media circolare, il parametro Valore di avvolgimento circolare diventa disponibile. Il valore di avvolgimento circolare viene utilizzato per convertire un valore lineare nell'intervallo di una data media circolare.</p>",
		terrainFlattenFunctionName: "Livellamento terreno",
		terrainFlattenFunctionSnip: "Corregge i dati radar ad apertura sintetica (SAR) in ingresso per le distorsioni radiometriche dovute alla topografia.",
		terrainFlattenFunctionDesc: "<p>La funzione raster Livellamento terreno corregge i dati radar ad apertura sintetica (SAR) in ingresso per le distorsioni radiometriche dovute alla topografia.</p><p>I dati radar in ingresso devono prima ricevere la calibrazione beta nought. Usa lo strumento Applica calibrazione radiometrica per calibrare i dati radar a beta zero.</p><p>Se il DEM di input non copre l'intero dataset SAR, lo strumento emette valori NoData per i pixel al di fuori dell'estensione del DEM per gli output gamma nought, sigma nought, area di dispersione e distorsione geometrica. Per l'output della maschera di distorsione geometrica, lo strumento emette valori indeterminati per i pixel al di fuori dell'estensione del DEM.</p><p>Il DEM di input deve essere nel sistema di coordinate geografico WGS 1984 (EPSG:4326).</p>",
		createColorCompositeFunctionName: "Crea colore composito",
		createColorCompositeFunctionSnip: "Crea un raster a tre bande da un dataset raster multibanda in cui ogni banda può utilizzare un calcolo algebrico basato sull'algebra delle bande.",
		createColorCompositeFunctionDesc: "<p>La funzione raster Crea colore composito crea un raster a tre bande da un dataset raster multibanda in cui ogni banda può utilizzare un calcolo algebrico basato sull'algebra delle bande.</p><p>Quando si definisce un algoritmo aritmetico a bande, è possibile inserire una formula algebrica a riga singola per ogni espressione per creare un output multibanda. Gli operatori supportati sono unari: più (+), meno (-), volte (*) e dividi (/).</p><p>Quando si utilizza un ID banda in un'espressione, identificare la banda anteponendo B o b al numero di banda.</p><p>Una combinazione di bande comunemente utilizzata per i radar ad apertura sintetica (SAR) in unità lineari è VV per il rosso, VH per il verde e VV/VH per il blu. Se i dati di input sono in decibel, la combinazione di bande deve essere VV per il rosso, VH per il verde e VV-VH per il blu.</p>",
		surfaceParametersName: "Parametri superficie",
		surfaceParametersSnip: "Determina i parametri di un raster superficie, ad esempio aspetto, pendenza e vari tipi di curvature tramite metodi geodetici.",
		surfaceParametersDesc: "<p>La funzione Parametri superficie determina i parametri di un raster superficie, ad esempio aspetto, pendenza e vari tipi di curvature tramite metodi geodetici.</p><p>Questa funzione può essere utilizzata per le seguenti applicazioni:</p><ul><li>Calcolo dell'aspetto e della pendenza tramite metodi geodetici.</li><li>Calcolo di vari tipi di curvature da un raster superficie di input, ad esempio <strong>Curvatura tangenziale (contorno normale)</strong>, che caratterizza la convergenza e la divergenza topografica di un flusso nella superficie.</li></ul>",
		leastCostCorridorName: "Corridoio costo minimo",
		leastCostCorridorSnip: "Calcola la somma di due raster di distanza di costo cumulativo con l'opzione che consente di applicare una soglia in base al costo cumulativo o percentuale.",
		leastCostCorridorDesc: "<p>I raster di input devono essere raster di accumulo distanza e di direzione inversa prodotti dalla funzione <strong>Accumulo distanza</strong> o <strong>Allocazione distanza</strong>. Devono essere utilizzati in base alla distanza di costo, e durante la creazione dei layer per ogni origine devono essere utilizzate le stesse impostazioni dei parametri. Per creare questi raster, non deve essere utilizzato alcun parametro dipendente dalla direzionalità (fattore orizzontale, fattore verticale e direzione di viaggio).</p><p>I valori del raster corridoio di output sono la somma del costo cumulativo per raggiungere una posizione fornita con le stesse unità dei raster di distanza di costo cumulativo di input.</p><p>Se un valore di <strong>Soglia</strong> specificato è maggiore del costo cumulativo massimo quando i due raster di accumulo vengono sommati, il raster corridoio di output coprirà la stessa area dei raster cumulativi di input.</p><p>Se un valore di soglia specificato è minore del valore minimo del raster corridoio, viene restituito un messaggio di avviso e il raster di output sarà vuoto.</p><p>Il raster corridoio di output potrebbe contenere celle con costi cumulativi leggermente maggiori del valore di soglia. Tale risultato deriva dai raster di direzione inversa che utilizzano celle assegnate con costi lievemente più alti della soglia per collegare le celle scollegate al corridoio.</p>",
		geometricMedianName: "Mediana geometrica",
		geometricMedianSnip: "La funzione Mediana geometrica calcola la mediana geometrica tra i pixel in una serie temporale di immagini multibanda.",
		geometricMedianDesc: "<p>Questa funzione riduce il rumore e le anomalie in immagini di serie temporali calcolando un pixel mediano geometrico per ogni pixel nella pila di immagini. L'algoritmo mantiene le relazioni spettrali tra bande negli spettri di pixel per cui l'output può essere utilizzato nell'analisi, ad esempio per gli indici di vegetazione.</p><p>Nuvole e ombre devono essere mascherate utilizzando la banda QA del dataset prima di applicare questa funzione.</p><p>Se l'immagine di input è in virgola mobile, ad esempio la riflettanza di superficie con valori compresi tra 0 e 1, un valore epsilon di 0,001 deve produrre risultati di qualità.</p>"
	},
	rfxArgs: {
		rasterName: "Raster",
		colorSchemeTypeName: "Tipo di schema colori",
		colormapName: "Colormap",
		colormapNameName: "Nome Colormap",
		colorRampName: "Scala cromatica",
		contrastOffsetName: "Offset contrasto",
		brightnessOffsetName: "Offset luminosità",
		methodName: "Metodo",
		bandNamesName: "Nomi bande",
		bandWavelengthsName: "Lunghezze d'onda bande",
		bandIdsName: "ID bande",
		missingBandActionName: "Azione per banda mancante",
		conversionParametersName: "Parametri conversione",
		hillshadeTypeName: "Tipo rilievo ombreggiato",
		azimuthName: "Azimut",
		altitudeName: "Altitudine",
		slopeTypeName: "Scala",
		zFactorName: "Fattore Z",
		PSPowerName: "Potenza dimensione pixel",
		PSZFactorName: "Fattore dimensione pixel",
		removeEdgeEffectName: "Disabilita interpolazione pixel bordo predefinita",
		fromUnitName: "Unità di origine",
		toUnitName: "Unità di destinazione",
		rasterTypeName: "Tipo",
		minName: "Output minimo",
		maxName: "Output massimo",
		minPercentName: "Ritaglio percentuale minimo",
		maxPercentName: "Ritaglio percentuale massimo",
		numberOfStandardDeviationName: "Numero di deviazioni standard",
		sigmoidStrengthLevelName: "Livello di forza sigmoidea",
		estimateStatsHistogramName: "Valuta statistiche",
		DRAName: "Regolazione gamma dinamica",
		statisticsName: "Statistiche",
		histogramsName: "Istogrammi",
		statisticsHistogramName: "Definisci statistiche e istogramma",
		computeGammaName: "Gamma automatica",
		useGammaName: "Usa gamma",
		gammaName: "Gamma",
		inputNamesName: "Nomi",
		expressionName: "Espressione",
		cellsizeTypeName: "Tipo di dimensione cella",
		extentTypeName: "Tipo di estensione",
		classifierDefinitionFileName: "File di definizione di input",
		raster1Name: "Raster1",
		raster2Name: "Raster2",
		raster3Name: "Raster3",
		trueRasterName: "Raster vero",
		falseRasterName: "Raster falso",
		noDataInterpretationName: "Interpretazione NoData",
		noDataValuesName: "Valori NoData",
		includedRangesName: "Intervalli inclusi",
		curvatureTypeName: "Tipo di curvatura",
		rastersName: "Raster",
		attributeTableName: "Tabella",
		attributeTableTypeName: "Tipo di tabella",
		rowsName: "Numero di righe",
		columnsName: "Numero di colonne",
		kernelName: "Kernel",
		mirrorEdgesName: "Rifletti bordi",
		influencesName: "Influenze",
		fieldsName: "Campi",
		remapsName: "Rimappa tabella",
		evalFromName: "Scala di valutazione Da",
		evalToName: "Scala di valutazione A",
		weightsName: "Pesi",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "Raggio IDW a breve distanza",
		maxVoidWidthName: "Larghezza massima del Void",
		sigmaGaussianName: "Spianatura adattiva",
		contourTypeName: "Tipo di contorno",
		zBaseName: "Base Z",
		numberOfContoursName: "Number Of Contours",
		contourIntervalName: "Intervallo Contour",
		nthContourLineInBoldName: "Nª linea di contorno in grassetto",
		featureClassName: "Feature di input",
		classIndexFieldName: "Campo",
		resolveOverlapMethodName: "Risolvi sovrapposizione",
		resamplingTypeName: "Tipo ricampionamento",
		inputCellsizeName: "Dimensioni cella input",
		outputCellsizeName: "Dimensioni cella output",
		pointFeatureClassName: "Punti di seed",
		maxGrowthRadiusFieldName: "Campo raggio di crescita massima",
		similarityThresholdFieldName: "Campo Similarity Threshold",
		fillValueFieldName: "Campo di riempimento valore",
		spectralDetailName: "Dettaglio spettrale [1..20]",
		spatialDetailName: "Dettaglio spaziale [1..20]",
		minNumPixelsPerSegmentName: "Dimensione segmento minima in pixel",
		boundariesOnlyName: "Solo confini segmento",
		statisticsTypeName: "Tipo statistiche",
		fillNoDataOnlyName: "Riempire solo pixel NoData",
		inputDataTypeName: "Tipo di dati di input",
		angleReferenceSystemName: "Sistema di riferimento angolare",
		outputDataTypeName: "Tipo di dati di output",
		inputSamplePointFeatureClassName: "Campioni di input",
		valueFieldName: "Campo valore",
		rasterInfoName: "Informazioni raster",
		interpolationMethodName: "Metodo di interpolazione",
		radiusName: "Raggio",
		radianceGainValuesName: "Guadagno radianza",
		radianceBiasValuesName: "Radiance Bias",
		reflectedGainValuesName: "Guadagno riflessione",
		reflectedBiasValuesName: "Compensazione riflessione",
		sunElevationName: "Elevazione sole (gradi)",
		albedoName: "Albedo",
		scaleFactorName: "Fattore di scala",
		offsetName: "Offset",
		thresholdTypeName: "Tipo di soglia",
		thresholdsName: "Soglie",
		undefinedClassName: "Classe non definita",
		minValueName: "Minima",
		maxValueName: "Massima",
		operationName: "Operazione",
		clippingTypeName: "Tipo di ritaglio",
		clippingGeometryName: "Geometria di ritaglio/Raster",
		extentName: "Estensione di output",
		useInputFeatureGeometryName: "Utilizzare feature di input per la geometria di ritaglio",
		remapDefinitionTypeName: "Rimappa tipo definizione",
		inputRangeName: "Intervalli di input",
		outputValuesName: "Valori di output",
		noDataRangeName: "Intervalli NoData",
		inputFieldName: "Campo di input",
		outputFieldName: "Campo di output",
		inputMaxFieldName: "Campo max di input (facoltativo)",
		remapTableTypeName: "Rimappa tipo tabella",
		allowUnmatchedName: "Consenti valori di pixel non corrispondenti",
		changeMissingValuesToNoDataName: "Cambia valori mancanti in NoData",
		visibleBandIDName: "ID banda visibile",
		infraredBandIDName: "ID banda infrarosso",
		scientificOutputName: "Output scientifico",
		bandIndexesName: "Indici bande",
		constantName: "Costante",
		weightName: "Peso",
		minimumName: "Minimo",
		maximumName: "Massimo",
		sourceDataName: "Raster di origine",
		sourceFieldName: "Campo di origine",
		costRasterName: "Raster di costo",
		maxDistanceName: "Distanza massima",
		valueRasterName: "Raster valore",
		costMultiplierName: "Moltiplicatore da applicare ai costi",
		startCostName: "Costo iniziale",
		accumCostResistanceRateName: "Velocità resistenza costo cumulativa",
		capacityName: "Capacità",
		travelDirectionName: "Direzione di viaggio",
		cellSizeName: "Dimensione cella",
		populationFieldName: "Campo popolazione",
		areaUnitsName: "Unità area",
		outputValueTypeName: "Valori cella di output",
		barriersName: "Barriere di input",
		destinationDataName: "Raster di destinazione",
		destinationFieldName: "Campo di destinazione",
		pathTypeName: "Tipo di percorso",
		observerFeaturesName: "Feature osservatori",
		analysisMethodName: "Metodo di analisi",
		analysisTypeName: "Tipo di analisi",
		verticalErrorName: "Errore verticale",
		refractivityCoefficientName: "Coefficiente di rifrattività",
		surfaceOffsetName: "Offset superficie",
		observerElevationName: "Elevazione osservatore",
		observerOffsetName: "Offset osservatore",
		innerRadiusName: "Raggio interno",
		innerRadiusIs3DDistanceName: "Il raggio interno è una distanza 3D",
		outerRadiusName: "Raggio esterno",
		outerRadiusIs3DDistanceName: "Il raggio esterno è una distanza 3D",
		horizontalStartAngleName: "Angolo iniziale orizzontale",
		horizontalEndAngleName: "Angolo finale orizzontale",
		verticalUpperAngleName: "Angolo superiore verticale",
		verticalLowerAngleName: "Angolo inferiore verticale",
		zoneDataName: "Raster zona",
		zoneFieldName: "Campo zona",
		ignoreNoDataName: "Ignora NoData nei calcoli",
		temperatureRasterName: "Raster temperatura",
		inTemperatureUnitsName: "Unità di temperatura",
		outHeatIndexTemperatureUnitsName: "Unità indice di calore",
		relativeHumidityRasterName: "Raster umidità relativa",
		outWindChillTemperatureUnitsName: "Unità Wind Chill",
		windSpeedRasterName: "Raster velocità del vento",
		inWindSpeedUnitsName: "Unità di velocità del vento",
		valueName: "Valore",
		propertyName: "Nome proprietà",
		jsonName: "Metadati JSON",
		zoneTableName: "Tabella attributi zonali",
		attributeFieldNames: "Nomi campo attributo",
		backgroundName: "Valore sfondo",
		whereClauseName: "Clausola Where",
		minimumValueFieldName: "Nome campo valore minimo",
		maximumValueFieldName: "Nome campo valore massimo",
		outValueFieldName: "Nome campo valore di output",
		defaultValueName: "Valore di output predefinito",
		conversionMatrixName: "Matrice di conversione",
		IsPseudoColorOutputName: "È un output di pseudocolore",
		unmappedAsRandomColorName: "Assegna colori in modo casuale ai pixel non mappati",
		distanceMethodName: "Metodo Distanza",
		flowDirRasterName: "Raster di direzione del flusso",
		pourPointName: "Raster Pour Point",
		pourPointFieldName: "Campo Pour Point",
		constantZName: "Constante Z",
		zOffsetName: "Offset Z",
		geoIdName: "Geoide",
		calibrationTypeName: "Tipo calibrazione",
		filterTypeName: "Tipo di filtro",
		filterSizeName: "Dimensione filtro",
		noiseModelName: "Modello rumore",
		noiseVarianceName: "Varianza rumore",
		additiveNoiseMeanName: "Media rumore additivo",
		multiplicativeNoiseMeanName: "Media rumore moltiplicativo",
		numberofLooksName: "Numero di ricerche",
		dampingFactorName: "Fattore di smorzamento",
		maskRasterName: "Maschera di Raster",
		nibbleValuesName: "Usa valori NoData se sono di vicinanza più prossima",
		nibbleNoDataName: "Ridurre celle NoData",
		zLimitName: "Limite Z",
		flowDirectionTypeName: "Tipo di direzione di flusso",
		weightRasterName: "Raster di pesi",
		forceEdgeName: "Forza tutti i bordi della cella per fluire all'esterno",
		streamRasterName: "Raster di flusso",
		surfaceRasterName: "Superficie raster",
		conversionType: "Tipo di conversione",
		distanceRaster1: "Raster di distanza 1",
		distanceRaster2: "Raster di distanza 2",
		costDistanceRaster: "Raster distanza di costo",
		costBacklinkRaster: "Raster backlink di costo",
		overridesName: "Esclusioni",
		fieldName: "Campo",
		signatureFileOrUrl: "File di firma o URL",
		redName: "Rosso",
		greenName: "Verde",
		blueName: "Blu",
		infraredName: "Infrarosso",
		panchromaticName: "Pancromatico",
		multispectralName: "Multispettrale",
		pansharpeningType: "Tipo pansharpening",
		sensorName: "Sensore",
		spatialReferenceName: "Riferimento spaziale",
		xCellsizeName: "Dimensione cella X",
		yCellsizeName: "Dimensione cella Y",
		xOriginName: "Punto di registrazione X",
		yOriginName: "Punto di registrazione Y",
		percentileName: "Valore percentile",
		neighborhoodType: "Tipo di vicinanza",
		widthName: "Larghezza",
		heightName: "Altezza",
		startAngleName: "Angolo iniziale",
		endAngleName: "Angolo finale",
		neighborhoodValues: "Valori di quartiere",
		horizontalRaster: "Raster orizzontale",
		horizontalFactor: "Fattore orizzontale",
		verticalRaster: "Raster verticale",
		verticalFactor: "Fattore verticale",
		streamRaster: "Raster di flusso",
		flowDirRaster: "Raster di direzione del flusso",
		numberNeighborCells: "Numero di celle vicine",
		zoneConnectivity: "Zona di connettività",
		addLinkBehavior: "Aggiungi collegamento",
		excludedValue: "Valore escluso",
		constantFillCheck: "Genera raster riempimento da costante",
		fillRaster: "Raster riempimento",
		constantFillValue: "Valore costante",
		inputBitPositions: "Bit di input",
		outputBitPositions: "Bit di output",
		distanceTypeName: "Tipo di distanza",
		barrierDataName: "Barriere raster",
		pourPointDataName: "Raster Pour Point",
		accumulationRasterName: "Raster di accumulo flusso",
		snapDistanceName: "Distanza snap",
		orderMethodName: "Metodo di ordinamento",
		directionMeasurementName: "Direzione di misura",
		processAsMultiband: "Elabora come multibanda",
		processMultidimensional: "Elabora come multidimensionale",
		forceFlowDirectionConvention: "Forzare la convenzione della direzione del flusso per il raster backlink",
		initialAccumulation: "Accumulo iniziale",
		maximumAccumulation: "Accumulo massimo",
		sourceLocationBands: "Generare righe e colonne di origine come bande aggiuntive nell'output",
		backDirectionBand: "Generare la direzione inversa come banda aggiuntiva nell'output",
		numberOfCells: "Numero di celle",
		zoneValues: "Valori zona",
		shrinkMethod: "Metodo di riduzione",
		expandMethod: "Metodo di espansione",
		inputSpectralProfileType: "Tipo di profilo spettrale",
		spectralProfileFileName: "Profilo spettrale",
		trainingFeatureFileName: "Feature di formazione",
		nonNegative: "Non negativo",
		sumToOne: "Somma a uno",
		randomDistribution: "Distribuzione",
		meanName: "Medio",
		probabilityName: "Probabilità",
		alphaName: "Alfa",
		betaName: "Beta",
		rName: "r",
		nName: "N",
		seed: "Seme",
		randomNumberGenerator: "Generatore di Numero Random",
		cellFactor: "Fattore cella",
		aggregationType: "Tecnica di aggregazione",
		extentHandling: "Espandi extent se necessario",
		trendAnalysisDimensionName: "Nome dimensione",
		trendAnalysisType: "Tipo di tendenza",
		harmonicFrequency: "Frequenza armonica",
		polynomialOrder: "Ordine polinomiale",
		cycleLengthName: "Lunghezza del ciclo",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R-Squared",
		trendAnalysisSlopePValue: "Valore P del coefficiente di pendenza",
		trendAnalysisSeasonalPeriod: "Periodo stagionale",
		cycleUnitName: "Unità ciclo",
		predictDimensionValues: "Valori",
		dimensionDefinitionType: "Definizione dimensione",
		predictDimensionStart: "Partenza",
		predictDimensionEnd: "Fine",
		predictDimensionInterval: "Intervallo del valore",
		dimensionUnit: "Unità",
		interpolationCellsizeName: "Dimensione della cella di interpolazione",
		variableName: "Variabili",
		dimensionlessName: "Senza dimensioni",
		mdimDefinition: "Definizione dimensione",
		dimensionName: "Dimensione",
		iterationStart: "Inizio della prima iterazione",
		iterationEnd: "Fine della prima iterazione",
		intervalStart: "Inizio dell'intervallo",
		intervalEnd: "Fine dell'intervallo",
		stepName: "Fase",
		rangesName: "Intervalli",
		minValue: "Valore minimo",
		maxValue: "Valore massimo",
		changeAnalysisRasterName: "Raster di analisi modifica",
		changeTypeName: "Modificare tipo",
		segmentDate: "Data segmento",
		changeDirectionName: "Modifica direzione",
		maxNumChangesName: "Numero massimo di modifiche",
		filterByYear: "Filtra per anno",
		minimumYear: "Valore minimo",
		maximumYear: "Valore Massimo",
		filterByDuration: "Filtra per durata",
		minimumDuration: "Durata minima",
		maximumDuration: "Durata massima",
		filterByMagnitude: "Filtra per grandezza",
		minimumMagnitude: "Grandezza minima",
		maximumMagnitude: "Grandezza massima",
		filterByStartValue: "Filtra da valore iniziale",
		minimumStartValue: "Minimo valore iniziale",
		maximumStartValue: "Massimo valore iniziale",
		filterByEndValue: "Filtra da valore finale",
		minimumEndValue: "Minimo valore finale",
		maximumEndValue: "Massimo valore finale",
		modelTypeName: "Tipo di modello",
		fromRasterName: "Da raster",
		toRasterName: "A Raster",
		computeChangeMethod: "Calcola metodo variazione",
		fromClassValues: "Valori Da classe (Esempi: 2 5)",
		toClassValues: "Valori A classe (Esempi: 2 5)",
		keepMethod: "Metodo di filtro",
		useColorMethod: "Definisci colori di transizione",
		detectChangeBands: "Bande per rilevare il cambiamento (inizia a 0)",
		tmaskBands: "Bande per il mascheramento temporaneo (inizia a 0)",
		chiSquaredThreshold: "Soglia chi-quadrato per rilevare modifiche",
		minAnomaly: "Osservazioni di anomalie consecutive minime",
		updatingFrequency: "Aggiornamento della frequenza di adattamento (in anni)",
		distanceAccumulationRasterName: "Raster di accumulo della distanza",
		costBackdirectionRasterName: "Direzione back o raster di direzione del flusso",
		rasterCollectionName: "Raccolta di raster",
		itemFunctionName: "Funzione elemento",
		aggregationFunctionName: "Funzione di aggregazione",
		processingFunctionName: "Funzione di elaborazione",
		aggregationDefinitionName: "Definizione aggregazione",
		queryGeometryName: "Interroga geometria",
		factorFunctionZeroFactor: "Fattore Zero",
		factorFunctionCutAngle: "Angolo di taglio",
		factorFunctionSideFactor: "Fattore laterale",
		factorFunctionSlope: "Acclività",
		factorFunctionLowCutAngle: "Angolo di taglio basso",
		factorFunctionHighCutAngle: "Angolo di taglio alto",
		factorFunctionCosPower: "Potenza coseno",
		factorFunctionSecPower: "Potenza secante",
		factorFunctionTablePath: "Percorso tabella",
		processingBand: "Banda di elaborazione",
		processingBandName: "Nome della Banda in Elaborazione",
		snappingDate: "Data gestione delle tolleranze",
		maxNumSegments: "Numero massimo di segmenti",
		vertexCountOvershoot: "Conteggio vertici in eccesso",
		spikeThreshold: "Soglia Spike",
		recoveryThreshold: "Soglia Recupero",
		minNumObs: "Numero minimo di osservazioni",
		pValueThreshold: "Soglia di valore P",
		bestModelProportion: "Migliore proporzione del modello",
		preventOneYearRecovery: "Previeni recupero di un anno",
		recoveryIncreaseTrend: "Il recupero ha aumentato la tendenza",
		outputOtherBands: "Emetti altre bande",
		sortType: "Tipo di ordinamento",
		numberOfRuns: "Esegui due volte espansione e contrazione",
		percentileValue: "Valore percentile",
		percentileInterpolationType: "Tipo di interpolazione percentile",
		rasterInfoProperty: "Proprietà",
		rasterInfoValue: "Valore",
		rasterInfoColumns: "Colonne",
		rasterInfoRows: "Righe",
		rasterInfoBandCount: "Numero di bande",
		rasterInfoPixelSizeX: "Dimensione cella X",
		rasterInfoPixelSizeY: "Dimensione cella Y",
		rasterInfoPixelType: "Tipo pixel",
		rasterExtentTop: "In alto",
		rasterExtentBottom: "In basso",
		rasterExtentLeft: "Sinistra",
		rasterExtentRight: "Destra",
		rasterStatisticsNotCalculated: "Le statistiche non sono state calcolate.",
		spatialReferenceProjection: "Proiezione",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "WKID precedente",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "VCSWKID precedente",
		spatialReferenceAuthority: "Autorità",
		spatialReferenceLinearUnit: "Unità Lineare",
		spatialReferenceAngularUnit: "Unità angolare",
		spatialReferenceFalseEasting: "Direzione est falsa",
		spatialReferenceFalseNorthing: "Direzione nord falsa",
		spatialReferenceCentralMeridian: "Meridiano di riferimento",
		spatialReferencePrimeMeridian: "Primo meridiano",
		spatialReferenceStandardParallel1: "Parallelo standard 1",
		spatialReferenceStandardParallel2: "Parallelo standard 2",
		spatialReferenceLatitudeOfOrigin: "Latitudine di origine",
		spatialReferenceAuxiliarySphereType: "Tipo di sfera ausiliare",
		spatialReferenceDatum: "Riferimento",
		spatialReferenceSpheroid: "Sferoide",
		spatialReferenceSemimajorAxis: "Semiasse principale",
		spatialReferenceSemiminorAxis: "Semiasse secondario",
		spatialReferenceInverseFlattening: "Livellamento inverso",
		inputDefinitionFileName: "File di definizione di input",
		deleteName: "Elimina",
		addVariableName: "Aggiungi variabile",
		maxNumPixelsPerSegment: "Dimensione massima segmenti in pixel",
		forwardWindowName: "Finestra avanti",
		backwardWindowName: "Finestra indietro",
		noDataHandlingName: "Gestione NoData",
		circularWrapValueName: "Valore wrap circolare",
		fromClassNameFieldName: "Nome del campo per i nomi delle classi in da raster",
		toClassNameFieldName: "Nome del campo per i nomi delle classi in Raster",
		targetRasterName: "Raster di destinazione",
		circularWrapValue: "Valore wrap circolare",
		bandIndexesR: "Espressione rosso",
		bandIndexesG: "Espressione verde",
		bandIndexesB: "Espressione blu",
		exampleName: "Esempio",
		inputName: "Input",
		outputName: "Output",
		optionalName: "Opzionale",
		browseDefinitionFile: "Cerca file definizione",
		selectDefinitionFile: "Seleziona file definizione input",
		inputDefinitionURL: "Inserisci URL file definizione",
		enterDefinitionFileURL: "Inserisci URL file definizione",
		browseXMLFile: "Cerca file XML",
		selectStatsFile: "Seleziona file di statistiche e istogrammi",
		enterXMLFileURL: "Inserisci URL file XML",
		xmlFileURL: "URL file XML",
		circularCalculation: "Calcola statistiche circolari",
		localSurfaceType: "Individua tipo di superficie",
		surfaceParameterType: "Tipo di parametro",
		neighborhoodDistance: "Distanza quartiere",
		useAdaptiveNeighborhood: "Usa quartiere adattivo",
		outputSlopeType: "Output misurazione pendenza",
		projectAzimuths: "Proietta azimut geodetici",
		useEquatorialAspect: "Usa aspetto equatoriale",
		zUnit: "Unità Z",
		analysisMask: "Maschera analisi",
		stdDeviation: "Deviazione standard",
		"true": "True",
		"false": "False",
		costDistanceRaster1: "Immetti raster distanza di costo cumulativo 1",
		costDistanceRaster2: "Immetti raster distanza di costo cumulativo 2",
		threshold: "Soglia",
		thresholdMethod: "Metodo di soglia",
		directionRaster1: "Immetti raster di direzione inversa 1",
		directionRaster2: "Immetti raster di direzione inversa 2",
		maxIterations: "Numero massimo di iterazioni",
		epsilon: "Epsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manuale",
		attributeTableTypeExternal: "Esterno",
		clrSchemeTypeColormap: "Colormap",
		clrSchemeTypeColorRamp: "Scala cromatica",
		colormapTypeElevation: "Elevazione",
		colormapTypeGray: "Grigio",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Casuali",
		none: "Nessuna",
		slopeTypeAdjusted: "Regolato",
		slopeTypeDegree: "Gradi",
		slopeTypePercentRise: "Incremento percentuale",
		slopeTypeScaled: "Scalato",
		stretchTypeMinMax: "MinMax",
		stretchTypePercentMinMax: "PercentMinMax",
		stretchTypeSigmoid: "Sigmoide",
		stretchTypeStdDev: "StdDev",
		hillshadeTypeSimple: "Tradizionale",
		hillshadeTypeMultidirectional: "Multidirezionale",
		bandComboByNames: "Nomi bande",
		bandComboByWavelength: "Lunghezze d'onda bande",
		bandComboByIDs: "ID bande",
		missingBandActionBestMatch: "Corrispondenza migliore",
		missingBandActionFail: "Errore",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Centimetri",
		unitTypeDecimeters: "Decimetri",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Piedi",
		unitTypeFeetPerSec: "Piedi al secondo (ft/s)",
		unitTypeInches: "Pollici",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Chilometri",
		unitTypeKmsPerHour: "Chilometri all'ora (km/h)",
		unitTypeKnots: "Nodi (kn)",
		unitTypeMeters: "Metri",
		unitTypeMetersPerSec: "Metri al secondo (m/s)",
		unitTypeMiles: "Miglia",
		unitTypeMilesPerHour: "Miglia all'ora (mph)",
		unitTypeMillimeters: "Millimetri",
		unitTypeNauticalMiles: "Miglia nautiche",
		unitTypeYards: "Iarde",
		unitTypeDecimalDegrees: "Gradi decimali",
		unitTypePoints: "Punti",
		unitTypeUnknown: "Sconosciuto",
		unitTypeSqMapUnits: "Unità di mappa quadrate",
		unitTypeSqMiles: "Miglia quadrate",
		unitTypeSqKms: "Chilometri quadrati",
		unitTypeAcres: "Acri",
		unitTypeHectares: "Ettari",
		unitTypeSqYards: "Square Yards",
		unitTypeSqFt: "Piedi quadrati",
		unitTypeSqInches: "Pollici quadrati",
		unitTypeSqMts: "Metri quadrati",
		unitTypeSqCms: "Centimetri quadrati",
		unitTypeSqMms: "Millimetri quadrati",
		cellsizeTypeFirst: "Primo di",
		cellsizeTypeMin: "Min di",
		cellsizeTypeMax: "Max di",
		cellsizeTypeMean: "Media di",
		cellsizeTypeLast: "Ultimo di",
		extentTypeFirst: "Primo di",
		extentTypeIntersection: "Intersezione di",
		extentTypeUnion: "Unione di",
		extentTypeLast: "Ultimo di",
		noDataInterpretAny: "Qualsiasi corrispondenza",
		noDataInterpretAll: "Tutte le corrispondenze",
		curvatureTypeStandard: "Standard",
		curvatureTypeProfile: "Profilo",
		curvatureTypePlanform: "Planform",
		filterTypeLineDetectionHorizontal: "Rilevamento riga - Orizzontale",
		filterTypeLineDetectionVertical: "Rilevamento riga - Verticale",
		filterTypeLineDetectionLeftDiagonal: "Rilevamento riga - Diagonale sinistra",
		filterTypeLineDetectionRightDiagonal: "Rilevamento riga - Diagonale destra",
		filterTypeGradientNorth: "Gradiente nord",
		filterTypeGradientWest: "Gradiente ovest",
		filterTypeGradientEast: "Gradiente est",
		filterTypeGradientSouth: "Gradiente sud",
		filterTypeGradientNorthEast: "Gradiente nord-est",
		filterTypeGradientNorthWest: "Gradiente nord-ovest",
		filterTypeSmoothArithmeticMean: "Smooth Arithmetic Mean",
		filterTypeSmoothing3x3: "Smoothing 3x3",
		filterTypeSmoothing5x5: "Smoothing 5x5",
		filterTypeSharpening3x3: "Sharpening 3x3",
		filterTypeSharpening5x5: "Sharpening 5x5",
		filterTypeLaplacian3x3: "Operatore laplaciano 3x3",
		filterTypeLaplacian5x5: "Operatore laplaciano 5x5",
		filterTypeSobelHorizontal: "Sobel orizzontale",
		filterTypeSobelVertical: "Sobel verticale",
		filterTypeSharpen: "Aumenta nitidezza",
		filterTypeSharpen2: "Aumenta ulteriormente nitidezza",
		filterTypePointSpread: "Distribuzione punti",
		userDefined: "Definito dall'utente",
		ContourTypeLines: "Linee di contorno",
		ContourTypeFill: "Riempimento contorno",
		ContourTypeSmoothOnly: "Solo superfici lisce",
		rasterizeFirst: "Primo",
		rasterizeLast: "Ultimo",
		rasterizeSmallest: "Più piccolo",
		rasterizeLargest: "Più grande",
		resamplingTypeNearest: "Vicino più vicino",
		resamplingTypeBilinear: "Interpolazione bilineare",
		resamplingTypeCubic: "Convoluzione cubica",
		resamplingTypeMajority: "Maggioranza",
		resamplingTypeBilinearPlus: "Interpolazione bilineare avanzata",
		resamplingTypeGauss: "Sfocatura gaussiana",
		resamplingTypeGaussPlus: "Sfocatura gaussiana avanzata",
		resamplingTypeAverage: "Media",
		resamplingTypeMinimum: "Minimo",
		resamplingTypeMaximum: "Massimo",
		resamplingTypeVectorAvg: "Media vettoriale",
		minimum: "Minimo",
		maximum: "Massimo",
		mean: "Medio",
		stdDeviation: "Deviazione standard",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Grandezza-Direzione",
		unknown: "Sconosciuto",
		angleRefSysGeographic: "Geografico",
		angleRefSysArithmetic: "Aritmetico",
		interpolateIrregularDataNearest: "Vicino più vicino",
		interpolateIrregularDataBilinear: "Bilineare",
		interpolateIrregularDataTinningLinear: "Rivestimento lineare",
		interpolateIrregularDataTinningNaturalNeighbor: "Vicino Naturale",
		interpolateIrregularDataTinningIDW: "Inverso della distanza pesata",
		esriRasterThresholdTypeConstant: "Costante",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "ArgMax",
		argStatsTypeMin: "ArgMin",
		argStatsTypeMedian: "ArgMedian",
		argStatsTypeDuration: "Durata",
		arithmeticOpPlus: "Plus",
		arithmeticOpMinus: "Minus",
		arithmeticOpMultiply: "Moltiplicazione",
		arithmeticOpDivide: "Divide",
		arithmeticOpPower: "Potenza",
		arithmeticOpMode: "Modalità",
		clipTypeOutside: "Taglia all'esterno",
		clipTypeInside: "Taglia all'interno",
		yes: "Yes",
		no: "No",
		densities: "Densità",
		expectedCounts: "Conteggi previsti",
		planar: "Planare",
		geodesic: "Geodetico",
		eachCell: "Ogni cella",
		eachZone: "Ogni zona",
		bestSingle: "Singolo migliore",
		allSightlines: "Tutte le linee di vista",
		perimeterSightlines: "Linee di vista perimetrali",
		frequency: "Frequenza",
		observers: "Osservatori",
		majority: "Maggioranza",
		median: "Mediana",
		minority: "Minoranza",
		percentile: "Percentile",
		range: "Intervallo",
		sum: "Somma",
		variety: "Varietà",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "SAVI trasformato",
		bandArithmeticMethodMSAVI: "SAVI modificato",
		bandArithmeticMethodSultan: "Formula di Sultan",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Ossido di ferro",
		ferrousMinerals: "Minerali ferrosi",
		clayMinerals: "Minerali di argilla",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Square Root",
		localACos: "ACos",
		localASin: "ASin",
		localATan: "ATan",
		localATanH: "ATanH",
		localAbs: "Abs",
		localBitwiseNot: "Not Bitwise",
		localBooleanNot: "No booleano",
		localCos: "Cos",
		localCosH: "CosH",
		localExp: "Exp",
		localExp10: "Exp10",
		localExp2: "Exp2",
		localInt: "Int",
		localIsNull: "È null",
		localFloat: "Float",
		localLn: "Ln",
		localLog10: "Log10",
		localLog2: "Log2",
		localNegate: "Negate",
		localRoundDown: "Round Down",
		localRoundUp: "Round Up",
		localSin: "Sin",
		localSinH: "SinH",
		localTan: "Tan",
		localTanH: "TanH",
		localACosH: "ACosH",
		localASinH: "ASinH",
		localPlus: "Plus",
		localMinus: "Minus",
		localTimes: "Volte",
		localPower: "Potenza",
		localBitwiseAnd: "And Bitwise",
		localBitwiseLeftShift: "Spostamento a sinistra Bitwise",
		localBitwiseOr: "Or Bitwise",
		localBitwiseRightShift: "Spostamento a destra Bitwise",
		localBitwiseXor: "Bitwise Xor",
		localBooleanAnd: "Boolean And",
		localBooleanOr: "Boolean Or",
		localBooleanXor: "Boolean Xor",
		localDivide: "Divide",
		localEqualTo: "Equal To",
		localGreaterThan: "Maggiore Di",
		localGreaterThanEqual: "Greater Than Equal",
		localLessThan: "Less Than",
		localLessThanEqual: "Less Than Equal",
		localMod: "Mod",
		localNotEqual: "Not Equal",
		localATan2: "ATan2",
		localSquare: "Square",
		localSetNull: "Imposta Null",
		remapDefTypeList: "Elenco",
		remapDefTypeTable: "Tabella",
		remapTableTypeSimple: "Semplice",
		remapTableTypeDynamic: "Dinamico",
		remapTableTypeReassignment: "Riassegnazione",
		geomCorrectionByConstZ: "Usa costante Z",
		geomCorrectionByDEM: "Usa DEM",
		radarCalibBetaNought: "Beta nought",
		radarCalibSigmaNought: "Sigma nought",
		radarCalibGammaNought: "Gamma nought",
		speckleFilterTypeLee: "Filtro Lee",
		speckleFilterTypeEnhancedLee: "Filtro Lee migliorato",
		speckleFilterTypeFrost: "Filtro Frost",
		speckleFilterTypeKuan: "Filtro Kuan",
		speckleNoiseModelMul: "Rumore moltiplicativo",
		speckleNoiseModelAdd: "Rumore additivo",
		speckleNoiseModelAddnMul: "Rumore additivo e moltiplicativo",
		mosaicOpTypeFirst: "Primo",
		mosaicOpTypeLast: "Ultimo",
		mosaicOpTypeMin: "Minima",
		mosaicOpTypeMax: "Massima",
		mosaicOpTypeMean: "Medio",
		mosaicOpTypeBlend: "Fusione",
		mosaicOpTypeSum: "Somma",
		integer: "Intero",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Verticale",
		horizontal: "Orizzontale",
		localCellStatisticsMajority: "Maggioranza",
		localCellStatisticsMax: "Massimo",
		localCellStatisticsMean: "Medio",
		localCellStatisticsMedian: "Mediana",
		localCellStatisticsMin: "Minimo",
		localCellStatisticsMinority: "Minoranza",
		localCellStatisticsRange: "Intervallo",
		localCellStatisticsStdDev: "Deviazione standard",
		localCellStatisticsSum: "Somma",
		localCellStatisticsVariety: "Varietà",
		localCellStatisticsMajorityIgnoreND: "Maggioranza (ignora NoData)",
		localCellStatisticsMaxIgnoreND: "Valore massimo (ignora NoData)",
		localCellStatisticsMeanIgnoreND: "Valore medio (ignora NoData)",
		localCellStatisticsMedianIgnoreND: "Valore mediano (ignora NoData)",
		localCellStatisticsMinIgnoreND: "Valore minimo (ignora NoData)",
		localCellStatisticsMinorityIgnoreND: "Minoranza (ignora NoData)",
		localCellStatisticsRangeIgnoreND: "Intervallo (ignora NoData)",
		localCellStatisticsStdDevIgnoreND: "Deviazione standard (ignora NoData)",
		localCellStatisticsSumIgnoreND: "Somma (ignora NoData)",
		localCellStatisticsVarietyIgnoreND: "Varietà (ignora NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Percentile (Ignora NoData)",
		fromSource: "Da origine",
		toSource: "A origine",
		colorspaceConversionRgbToHsv: "Da RGB a HSV",
		colorspaceConversionHsvToRgb: "Da HSV a RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Medio",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Rettangolo",
		circleNeighborhood: "Cerchio",
		annulusNeighborhood: "Corona circolare",
		wedgeNeighborhood: "Spicchio",
		irregularNeighborhood: "Irregolare",
		weightNeighborhood: "Peso",
		four: "Quattro",
		eight: "Otto",
		within: "All'interno",
		cross: "Croce",
		addLink: "Aggiungi collegamento",
		noLink: "Nessun collegamento",
		weightedMean: "Media verificata",
		ls8QCBitPatternCirrus: "Landsat 8 - Cirro",
		ls8QCBitPatternCloud: "Landsat 8 - Nuvola",
		ls8QCBitPatternCloudShadow: "Landsat 8 - Ombra nuvola",
		ls8QCBitPatternDesignatedFill: "Landsat 8 - Riempimento designato",
		ls8QCBitPatternDroppedFrame: "Landsat 8 - Fotogramma eliminato",
		ls8QCBitPatternSnowIce: "Landsat 8 - Neve/Ghiaccio",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 - Occlusione terreno",
		ls8QCBitPatternVegetation: "Landsat 8 - Vegetazione",
		ls8QCBitPatternWater: "Landsat 8 - Acqua",
		downStream: "Downstream",
		upStream: "Upstream",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Sezione corrente",
		allSlices: "Tutte le sezioni",
		expandDistance: "DISTANZA",
		expandMorphological: "MORFOLOGICA",
		spectralProfileFile: "Profilo spettrale",
		trainingFeatureFile: "Feature di formazione",
		randomDistributionTypeUniform: "Uniforme",
		randomDistributionTypeUniformInteger: "Intero",
		randomDistributionTypeNormal: "Normale",
		randomDistributionTypeExponential: "Esponenziale",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gamma",
		randomDistributionTypeBinomial: "Binomiale",
		randomDistributionTypeGeometric: "Geometrica",
		randomDistributionTypeNegativeBinomial: "Binomiale negativo",
		randomGeneratorTypeStandardCRand: "C Rand standard",
		randomGeneratorTypeAlgorithmACM599: "Algoritmo 599 raccolto da ACM",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Somma",
		medainName: "Mediana",
		trendLinear: "Lineare",
		trendHarmonic: "Armonica",
		trendPolynomial: "Polinomiale",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Kendall stagionale",
		dimensionByValue: "Per Valore",
		dimensionByInterval: "Per intervallo",
		mdimDefTypeAll: "Tutto",
		mdimDefTypeByValues: "Per valori",
		mdimDefTypeByRanges: "Per intervallo",
		mdimDefTypeByIteration: "Per iterazione",
		mdimDefTypeByInterval: "Per intervallo",
		mdimDefTypeByTargetRaster: "Per raster di destinazione",
		esriTimeUnitsHours: "Ore",
		esriTimeUnitsDays: "Giorni",
		esriTimeUnitsWeeks: "Settimane",
		esriTimeUnitsMonths: "Mesi",
		esriTimeUnitsYears: "Anni",
		esriTimeIntervalKeywordHourly: "Ogni ora",
		esriTimeIntervalKeywordDaily: "Ogni giorno",
		esriTimeIntervalKeywordWeekly: "Ogni settimana",
		esriTimeIntervalKeywordDekadly: "Ogni dieci giorni",
		esriTimeIntervalKeywordPentadly: "Ogni cinque giorni",
		esriTimeIntervalKeywordMonthly: "Ogni mese",
		esriTimeIntervalKeywordQuarterly: "Trimestrale",
		esriTimeIntervalKeywordYearly: "Annuale",
		esriTimeIntervalKeywordRecurringDaily: "Ricorrenza giornaliera",
		esriTimeIntervalKeywordRecurringWeekly: "Ricorrenza settimanale",
		esriTimeIntervalKeywordRecurringMonthly: "Ricorrenza mensile",
		esriTimeIntervalKeywordRecurringQuarterly: "Ricorrenza trimestrale",
		aggDefTypeAll: "Tutte",
		aggDefTypeIntervalKeyword: "Parola chiave di intervallo",
		aggDefTypeIntervalValue: "Valore di intervallo",
		aggDefTypeIntervalRanges: "Ampiezze intervallo",
		latestChange: "Ora dell'ultima modifica",
		earliestChange: "Ora della prima modifica",
		largestChange: "Ora della modifica più grande",
		numberOfChanges: "Numero di modifiche",
		longestChange: "Ora della modifica più lunga",
		shortestChange: "Ora della modifica più breve",
		fastestChange: "Ora della modifica più veloce",
		slowestChange: "Ora della modifica più lenta",
		allChanges: "Tutte",
		increaseChanges: "Aumenta",
		decreaseChanges: "Diminuisci",
		segmentBeginning: "Inizio del segmento",
		segmentEnd: "Fine del segmento",
		esriComputeChangeMethodDifference: "Differenza",
		esriComputeChangeMethodRelativeDifference: "Differenza relativa",
		esriComputeChangeMethodCategorical: "Differenza categorica",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Distanza spettrale euclidea",
		esriComputeChangeMethodMultispectralAngularDifference: "Differenza angolo spettrale",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Banda con il maggior numero di cambiamenti",
		esriComputeChangeKeepAll: "Mantieni tutto",
		esriComputeChangeKeepChangedOnly: "Mantieni solo Pixel cambiati",
		esriComputeChangeKeepUnchangedOnly: "Mantieni solo Pixel non cambiati",
		esriComputeChangeUseColorAverage: "Colori medi Da e A",
		esriComputeChangeUseColorFrom: "Usa Da colori",
		esriComputeChangeUseColorTo: "Usa A colori",
		factorFunctionBinary: "Binario",
		factorFunctionForward: "Avanti",
		factorFunctionLinear: "Lineare",
		factorFunctionInvLinear: "Lineare inverso",
		factorFunctionTable: "Tabella",
		factorFunctionSymLinear: "Lineare simmetrico",
		factorFunctionSymInvLinear: "Lineare inverso simmetrico",
		factorFunctionCos: "Coseno",
		factorFunctionSec: "Secante",
		factorFunctionCosSec: "Secante coseno",
		factorFunctionSecCos: "Coseno secante",
		noSort: "Non ordinare",
		ascend: "Crescente",
		descend: "Decrescente",
		autoDetect: "Rilevamento automatico",
		nearest: "Più vicino",
		linear: "Lineare",
		esriMonthJanuary: "Gennaio",
		esriMonthFebruary: "Febbraio",
		esriMonthMarch: "Marzo",
		esriMonthApril: "Aprile",
		esriMonthMay: "Maggio",
		esriMonthJune: "Giugno",
		esriMonthJuly: "Luglio",
		esriMonthAugust: "Agosto",
		esriMonthSeptember: "Settembre",
		esriMonthOctober: "Ottobre",
		esriMonthNovember: "Novembre",
		esriMonthDecember: "Dicembre",
		dimensionalMovingIgnoreNoData: "Dati",
		dimensionalMovingPropagateNoData: "Nessun dato",
		dimensionalMovingFillOnlyNoData: "Riempi NoData",
		circularMean: "Media circolare",
		circularName: "Circolare",
		arithmeticName: "Aritmetico",
		slopeName: "Pendenza",
		aspectName: "Aspetto",
		meanCurvature: "Curvatura media",
		profileCurvature: "Profilo (linea di pendenza normale) curvatura",
		tangentialCurvature: "Curvatura tangenziale (contorno normale)",
		planCurvature: "Curvatura del piano (contorno proiettato)",
		contourGeodesicTorsion: "Torsione geodetica di contorno",
		gaussianCurvature: "Curvatura gaussiana",
		casoratiCurvature: "Curvatura Casorati",
		localSurfaceTypeQuadratic: "Quadratico",
		localSurfaceTypeBiquadratic: "Biquadratico",
		thresholdNoThreshold: "Nessuna soglia",
		thresholdPercentLeastCost: "Percentuale di costo minimo",
		thresholdAccumulativeCost: "Costo cumulativo",
		clrmapTypeHillshade: "Rilievo ombreggiato"
	},
	categoryLabels: {
		sourceCharacteristics: "Caratteristiche origine",
		neighborhoodSettings: "Impostazioni di vicinanza",
		statistics: "Statistiche",
		gamma: "Gamma",
		viewshedParameters: "Parametri campo di vista",
		observerParameters: "Parametri osservatore",
		irregularDataInterpolation: "Interpolazione irregolare dei dati",
		modelStatistics: "Statistiche modello",
		aggregationDef: "Definizione aggregazione",
		filterByAttributes: "Filtra per attributi",
		percentileName: "Percentile",
		rasterInfo: "Informazione raster",
		extent: "Estensione",
		spatialReference: "Riferimento spaziale"
	},
	outputRasterHelpTexts: {
		outputName: "<p>Il nome del layer che sarà creato e aggiunto alla mappa.</p>",
		resultType: "<p>Il tipo di output che sarà creato. Gli output possono essere layer immagini di tile o layer immagini dinamici.</p>",
		saveResultIn: "<p>Il nome della cartella in <b>I miei contenuti</b> in cui sarà salvato il risultato.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Impostazioni ambiente per l'analisi in Map Viewer. </p>",
		outSR: "<p>Specifica il sistema di coordinate per l'analisi e il layer dei risultati.</p>",
		extent: "<p>Specifica l'area da utilizzare per l'analisi.</p>",
		snapRaster: "<p>Regola l'estensione dell'output in modo che corrisponda all'allineamento delle celle del layer snap raster specificato.</p>",
		cellSize: "<p>Specifica la dimensione o la risoluzione delle celle che verrà utilizzata per l'analisi e per creare il layer raster di output.</p>",
		mask: "<p>Specifica un layer maschera in cui solo le celle che rientrano nell'area della maschera verranno utilizzate per l'analisi.</p>",
		resamplingMethod: "<p>Specifica come interpolare i valori dei pixel quando i raster di input e di output non sono allineati.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Tipo non supportato",
		currentlyUnsupported: " Un editor predefinito per ${missingType} è in sospeso ma disponibile a breve. Casella di testo segnaposto temporaneo per specificare input basati su stringhe.",
		unsupportedOverrideWarning: "Un componente dell'editor di override che fornisce una migliore UX per lavorare con i seguenti parametri è in sospeso ma sarà presto disponibile:",
		overrideWidgetMissing: "Componente editor di ovverride mancante!",
		uiIncomplete: "Invio del processo non riuscito. Impossibile eseguire la funzione. Alcuni dei campi richiesti sono incompleti o mancanti dalla IU.",
		count: "Conteggio",
		selectVariables: "Seleziona variabili",
		selectFeature: "Seleziona feature layer",
		greaterThanErrorMessage: "Il numero di input deve essere maggiore di ${min}",
		lesserThanErrorMessage: "Il numero di input deve essere minore di ${max}",
		greaterThanOrEqualErrorMessage: "Il numero di input deve essere maggiore o uguale a ${min}",
		lesserThanOrEqualErrorMessage: "Il numero di input deve essere minore o uguale a ${max}",
		allowScalar: "Selezionare un layer o inserire una costante",
		selectField: "Seleziona campo",
		parameterRequired: "Questo parametro è obbligatorio.",
		enterAValue: "Inserisci un valore ...",
		invalidInput: "Il valore inserito non è valido.",
		itemNotFound: "Elemento non esistente o inaccessibile.",
		itemPermissionDenied: "Non disponi delle autorizzazioni per accedere a questo elemento.",
		layerNotAvailable: "Impossibile caricare il layer ${layerName}.",
		multipleLayersNotAvailable: "Impossibile caricare il layer ${layerName} e altri",
		learnMoreLabel: "Ulteriori informazioni",
		fieldNotAvailable: "Impossibile caricare il campo.",
		allowAnalysis: "L'analisi non è consentita sull'image service.",
		allowAnalysisReason: "Uno o più layer della mappa non sono elencati qui perché non consentono l'analisi.",
		learnMoreText: "Ulteriori informazioni",
		atLeastOneRasterInput: "Almeno un layer di input deve essere un layer raster.",
		browseAnalysisLayers: "Sfoglia layer",
		activeMapViewExtent: "Utilizzare l'estensione mappa corrente",
		chooseRaster: "Scegliere il raster di ritaglio",
		chooseGeometry: "Scegliere la geometria di ritaglio",
		resultType: "Tipo di risultato",
		saveInFolder: "Salva nella cartella",
		outputName: "Nome di output",
		outputLayerType: "Tipo layer di output",
		dynamicImageryLayer: "Layer immagini dinamico",
		tiledImageryLayer: "Layer immagini con tile",
		custom: "Personalizza",
		loading: "Caricamento in corso...",
		layerMissing: "Uno o più layer della mappa non sono elencati qui perché non consentono l'analisi. Ulteriori informazioni.",
		browseCoordinateSystems: "Sfoglia sistemi di coordinate",
		unableToRepopulateOutSR: "Impossibile popolare il sistema di coordinate di output.",
		defaultTitle: "Maggiori informazioni",
		"ARC (equal arc-second)": "ARC (secondo d'arco uguale)",
		Africa: "Africa",
		Antarctica: "Antartide",
		Argentina: "Argentina",
		Asia: "Asia",
		"Asteroid Belt": "Fascia principale degli asteroidi",
		"Atlantic Ocean": "Oceano Atlantico",
		Australia: "Australia",
		"Australia and New Zealand": "Australia e Nuova Zelanda",
		Austria: "Austria",
		"BLM (US Feet)": "BLM (piedi statunitensi)",
		Bangladesh: "Bangladesh",
		"Beijing 1954": "Pechino 1954",
		Bhutan: "Bhutan",
		CGCS2000: "CGCS2000",
		Canada: "Canada",
		Caribbean: "Caraibi",
		"Caribbean Sea": "Mar dei Caraibi",
		"Central America": "America centrale",
		"Central and North America": "America centrale e settentrionale",
		Colombia: "Colombia",
		Continental: "Continentale",
		"County Systems": "Sistemi di contea",
		"Democratic Republic of the Congo": "Repubblica democratica del Congo",
		"EPSG Arctic": "EPSG Artico",
		Earth: "Terra",
		"Ellipsoidal-based": "Basato su ellissoidale",
		Europe: "Europa",
		Finland: "Finlandia",
		France: "Francia",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss-Krüger",
		"Geographic Coordinate Systems": "Sistemi di coordinate geografiche",
		Germany: "Germania",
		"Gravity-related": "Correlato alla gravità",
		"Greenwich-based": "Basato su Greenwich",
		"Highways England": "Highways England",
		Illinois: "Illinois",
		"Indian Ocean": "Oceano Indiano",
		"Indian Subcontinent": "Subcontinente indiano",
		Indiana: "Indiana",
		Indonesia: "Indonesia",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irlanda e Regno Unito",
		Italy: "Italia",
		Japan: "Giappone",
		Jupiter: "Giove",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Libia",
		Malaysia: "Malaysia",
		"Malaysia and Singapore": "Malaysia e Singapore",
		Mars: "Marte",
		Mercury: "Mercurio",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (piedi statunitensi)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (piedi internazionali)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (metri)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (piedi statunitensi)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (piedi internazionali)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (metri)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (piedi statunitensi)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (piedi internazionali)",
		"NAD 1983 (Meters)": "NAD 1983 (metri)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (metri)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (piedi statunitensi)",
		"NAD 1983 (US Feet)": "NAD 1983 (piedi statunitensi)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (piedi internazionali)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (metri)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (piedi statunitensi)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (piedi internazionali)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (metri)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (piedi statunitensi)",
		"National Grids": "Griglie nazionali",
		Navajo: "Navajo",
		Neptune: "Nettuno",
		"New Beijing": "Nuova Pechino",
		"New Zealand": "Nuova Zelanda",
		"North America": "Nord America",
		"Northern Hemisphere": "Emisfero settentrionale",
		Norway: "Norvegia",
		Oceans: "Oceani",
		Oregon: "Oregon",
		"Other GCS": "Altro GCS",
		"Pacific Ocean": "Oceano Pacifico",
		Pluto: "Plutone",
		Polar: "Polare",
		Portugal: "Portogallo",
		"Projected Coordinate Systems": "Sistemi di coordinate proiettati",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Sostituito",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturno",
		"Solar System": "Sistema solare",
		"South Africa": "Sudafrica",
		"South America": "Sud America",
		"South Korea": "Corea del Sud",
		"Southern Hemisphere": "Emisfero meridionale",
		"Spheroid-based": "Basato su sferoidi",
		"State Plane": "Piano statale",
		"State Systems": "Sistemi statali",
		Sweden: "Svezia",
		"Switzerland and Liechtenstein": "Svizzera e Liechtenstein",
		Texas: "Texas",
		Tribal: "Tribale",
		Turkey: "Turchia",
		"US Feet": "Piedi internazionali",
		"USA and territories": "Stati Uniti e territori",
		UTM: "UTM",
		Ukraine: "Ucraina",
		"Unknown Height Systems": "Sistemi di altezza sconosciuti",
		Uranus: "Uranio",
		Venus: "Venere",
		"Vertical Coordinate Systems": "Sistemi di coordinate verticali",
		Vietnam: "Vietnam",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Mondo",
		"World (Sphere-based)": "Mondo (basato su sfera)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Completato",
		noResults: "Nessun risultato trovato",
		searchPlaceholder: "Nome o WKID",
		browseTemplate: "Cercare modelli di funzione raster",
		saveTemplate: "Salva modello funzioni raster",
		preview: "Anteprima",
		previewDescription: "Visualizzare in anteprima il risultato prima di eseguire l'analisi.",
		showPreview: "Mostra anteprima",
		previewLayer: "Layer di anteprima ${number}",
		newPreview: "Nuova anteprima",
		previewPopup: "Attivare l'anteprima dei risultati dell'analisi in base ai parametri di input.",
		updatePreviewLayer: "Aggiorna layer di anteprima selezionato",
		createPreviewLayer: "Crea nuovo layer di anteprima",
		maximumPreviewAllowed: "Numero massimo di layer di anteprima consentiti: ${maxCount}",
		previewFailure: "Questo layer di anteprima non è disponibile. Controllare i parametri di input e aggiornare nuovamente questo layer di anteprima.",
		header: "Seleziona elemento",
		content: "Sono presenti modifiche non salvate in ${rftTitle}. Se si ricomincia con un nuovo modello, queste modifiche andranno perse.",
		dontSave: "Non salvare",
		"continue": "Continua",
		stretch: "Adatta a finestra",
		pan: "Pan",
		newTemplate: "Crea nuovo modello",
		openTemplate: "Apri modello",
		addFunction: "Aggiungi funzioni raster",
		addConstant: "Aggiungi costante",
		addRaster: "Aggiungi variabile raster",
		move: "Sposta",
		zoom: "Zoom",
		saveAs: "Salvare come",
		clear: "Azzera",
		addRasterFunctionTitle: "Aggiungi funzioni raster",
		templatePropertiesTitle: "Proprietà modello",
		browseRFT: "Cercare modelli di funzione raster",
		defaultToolDescription: "Strumento di analisi ${toolTitle}.",
		openToolText: "Apri strumento",
		toolDropdownText: "Elenco a discesa degli strumenti",
		addToMap: "Confermare e aggiungere alla mappa",
		confirm: "Conferma",
		select: "Seleziona",
		selectTask: "Seleziona attività",
		unsupportedLayer: "Questo parametro non supporta i seguenti layer: ${layerName}.",
		viewDetails: "Visualizza i dettagli completi dell’elemento",
		rename: "Rinomina",
		duplicate: "Duplica",
		launch: "Apri per eseguire",
		templateEditor: "Editor modello",
		createItem: "Salva modello funzioni raster",
		actionLabel: "Filtro",
		filterPopoverHeading: "Filtra funzioni",
		defaultSearchPlaceholder: "Cercare per nome",
		settings: "Impostazioni",
		summary: "Riepilogo",
		definitionQuery: "Interrogazione di definizione",
		matchVariables: "Abbina variabili",
		unionDimension: "Dimensione unione",
		nameEditorPlaceholder: "Inserisci titolo",
		summaryEditorPlaceholder: "Inserisci una breve descrizione.",
		definitionQueryPlaceholder: "Inserisci...",
		upload: "Carica",
		chooseImage: "Clicca per scegliere un file",
		update: "Aggiorna",
		thumbnailErrors: {
			wrongImageType: "Tipo di immagine errato selezionato",
			notAvailable: "Thumbnail non disponibile",
			loadError: "Impossibile caricare l'immagine",
			chooseFile: "Clicca per scegliere il file"
		}
	}
};
const copy = "Copia";
const save = "Salva";
const title = "Titolo";
const folder = "Cartella";
const tags = "Tag";
const savingMessage = "Salvataggio dell’elemento in";
const shareWith = "Condividi con";
const share = "Condividi";
const setSharingLevel = "Imposta il livello di condivisione";
const setGroupSharing = "Imposta la condivisione del gruppo";
const owner = "Proprietario";
const organization = "Organizzazione";
const everyone = "Tutti (pubblica)";
const groups = "Gruppi:";
const type = "Tipo";
const mosaic = "Mosaic";
const itemGroup = "Gruppo di elementi";
const item = "Elemento";
const definitionQuery = "Definition Query";
const groupItemsBy = "Raggruppa elementi per";
const groupFieldName = "Nome campo gruppo";
const tagFieldName = "Nome campo tag";
const noTitleTagErrorMsg = "Specificare un titolo per l’elemento e i tag per consentire di individuare la mappa nelle ricerche.";
const noTitleErrorMsg = "Specificare un titolo per l'elemento.";
const noTagErrorMsg = "Specificare almeno un tag per consentire di individuare l’elemento corrente nelle ricerche.";
const error = "Errore";
const warning = "Avviso";
const success = "Operazione riuscita";
const details = "Dettagli:";
const tryAgain = "Riprova";
const toolModeler = {
	save: "Salva",
	editProperties: "Modifica proprietà",
	saveAs: "Salva con nome",
	savingNotification: "Salvataggio delle modifiche apportate all’elemento in corso...",
	savingTitle: "Salvataggio in corso",
	saveFailedMessage: "Impossibile salvare le modifiche.",
	saveWithErrorsMessage: "Le modifiche sono state salvate con i seguenti errori.",
	viewItemMessage: "Visualizza elemento salvato",
	here: "qui.",
	itemCreatedMessage: "È stato creato un nuovo elemento.",
	clickToViewItemMessage: "Fare clic su OK per visualizzare la pagina dei dettagli dell'elemento; fare clic su Annulla per continuare.",
	readingFailed: "Impossibile caricare il modello di funzione raster selezionato.",
	failedToLoadXML: "Impossibile caricare il modello di funzione raster selezionato in formato XML.",
	learnMore: "Ulteriori informazioni",
	overwriteTitle: "Conferma sovrascrittura",
	overwriteMessage: "Sovrascrivere l'elemento esistente?",
	overwriteSuccessMessage: "L'elemento è stato aggiornato."
};
const toolEditor = {
	run: "Esegui",
	save: "Salva",
	deleteSelected: "Elimina elementi selezionati",
	addRaster: "Aggiungi raster",
	addScalar: "Aggiungi scalare",
	layout: "Layout automatico",
	errorTitle: "Errore",
	invalidToolMessage: "Modello di funzione raster non valido.",
	out: "Uscita",
	zoomIn: "Zoom avanti",
	zoomOut: "Zoom indietro",
	zoomToFit: "Adatta a finestra",
	panOn: "Passa alla modalità pan",
	panOff: "Disattiva modalità pan",
	defaultModelName: "Modello strumento",
	defaultRasterName: "Raster"
};
const toolDetailsEditor = {
	defaultToolName: "Modello funzione raster",
	defaultToolDescription: "Aggiungere un breve riepilogo della funzione raster.",
	defaultHelpText: "Fare clic sull'icona Guida per modificare il testo della guida",
	editHelpTitle: "Aiuto modifica",
	saveLabel: "Salva",
	cancelLabel: "Cancella",
	thumbnail: {
		wrongImageType: "Tipo di immagine errato selezionato",
		notAvailable: "Miniatura non disponibile",
		loadError: "Caricamento dell’immagine non riuscito",
		chooseFile: "Fare clic per scegliere il file"
	}
};
const saveUtils = {
	thumbnail: "Anteprima",
	sharing: "Condivisione"
};
const close = "Chiudi";
const unsavedWarningExisting = "Salvare le modifiche all’elemento <b>${itemTitle}</b>?";
const unsavedWarningNew = "Salvare le modifiche?";
const saveAs = "Salva con nome";
const dontSave = "Non salvare";
const unsavedTitle = "Modifiche non salvate";
const invalidRFTMessage = "Il modello di funzione raster creato non è valido.";
const errorTitle = "Errore";
const breadcrumb = "Editor funzioni raster";
const breadcrumbEditor = "Contenuti > Editor funzioni raster";
const viewerModeTitle = "Solo lettura";
const viewerModeMessage = "La voce del modello di funzione raster è di sola lettura. Le modifiche non possono essere salvate.";
const userStartDirection = "Selezionare una funzione per cominciare a costruire un modello di funzione raster.";
const selectFunction = "Aggiungi funzione";
const deselectFunction = "Rimuovi funzione";
const dialogTitle = "Sistema";
const category = "Categorie";
const search = "Cercare funzioni raster";
const categoryNames = {
	analysis: "Analisi",
	appearance: "Aspetto",
	classification: "Classificazione",
	conversion: "Conversione",
	correction: "Correzione",
	dataManagement: "Gestione dati",
	distance: "Distanza",
	distanceLegacy: "Distanza (precedenti)",
	hydrology: "Idrologia",
	math: "Matematica",
	mathConditional: "Matematica: Condizionale",
	mathLogical: "Matematica: Logica",
	mathTrigonometric: "Matematica: Trigonometria",
	reclass: "Riclassifica",
	statistical: "Statistico",
	surface: "Superficie"
};
const commonStrings_it = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_it);


//# sourceMappingURL=common-strings.it-efba6f9b.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTcxYjdmNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOGlDQUE4aUMsNkNBQTZDO0FBQzNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNk5BQTZOO0FBQzdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrV0FBK1csNEhBQTRILCtEQUErRDtBQUMxaUI7QUFDQTtBQUNBLHFiQUFxYjtBQUNyYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaU1BQWlNO0FBQ2pNLGdNQUFnTTtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMmxCQUEybEI7QUFDM2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrTkFBK047QUFDL047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVzQ0FBdXNDLHVWQUF1VjtBQUM5aEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNPQUFzTztBQUN0TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNHNHQUE0c0csT0FBTztBQUNudEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxJQUFJO0FBQzdFLHNFQUFzRSxJQUFJO0FBQzFFLHdGQUF3RixJQUFJO0FBQzVGLHFGQUFxRixJQUFJO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEUsK0RBQStELFdBQVc7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxVQUFVO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFVBQVU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxnQkFBZ0IsRUFBQztBQUNpb0M7O0FBRWpxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL2NvbW1vbi1zdHJpbmdzLml0LWVmYmE2ZjliLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG9rID0gXCJPS1wiO1xuY29uc3QgY2FuY2VsID0gXCJDYW5jZWxsYVwiO1xuY29uc3QgZW50ZXJVUkwgPSBcIkluc2VyaXJlIGzigJlVUkwgZGVsbOKAmWltYWdlIHNlcnZpY2VcIjtcbmNvbnN0IHNlcnZpY2VVUkwgPSBcIlVSTCBkaSBTZXJ2aXppb1wiO1xuY29uc3Qgc2VsZWN0UmFzdGVyID0gXCJTZWxlemlvbmEgcmFzdGVyXCI7XG5jb25zdCBmYWlsZWRUb0xvYWRMYXllciA9IFwiSW1wb3NzaWJpbGUgY2FyaWNhcmUgaWwgbGF5ZXJcIjtcbmNvbnN0IGxvYWRpbmdMYXllciA9IFwiQ2FyaWNhbWVudG8gbGF5ZXJcIjtcbmNvbnN0IHNlbGVjdEZlYXR1cmUgPSBcIlNlbGV6aW9uYSBmZWF0dXJlIGxheWVyXCI7XG5jb25zdCBlbnRlckZVUkwgPSBcIkltbWV0dGkgVVJMIGZlYXR1cmUgc2VydmljZVwiO1xuY29uc3QgYWRkUmFzdGVyID0gXCJBZ2dpdW5naSB2YXJpYWJpbGUgcmFzdGVyXCI7XG5jb25zdCBhZGRTY2FsYXIgPSBcIkFnZ2l1bmdpIGNvc3RhbnRlXCI7XG5jb25zdCByYXN0ZXIgPSBcIlJhc3RlclwiO1xuY29uc3Qgc2NhbGFyID0gXCJTY2FsYXJlXCI7XG5jb25zdCBkZWZhdWx0TW9kZWxOYW1lID0gXCJNb2RlbGxvIGZ1bnppb25lIHJhc3RlclwiO1xuY29uc3QgZ2VuZXJhbCA9IFwiR2VuZXJhbGVcIjtcbmNvbnN0IHBhcmFtZXRlcnMgPSBcIlBhcmFtZXRyaVwiO1xuY29uc3QgdmFyaWFibGVzID0gXCJWYXJpYWJpbGlcIjtcbmNvbnN0IG5hbWUgPSBcIk5vbWVcIjtcbmNvbnN0IGRlc2NyaXB0aW9uID0gXCJEZXNjcml6aW9uZVwiO1xuY29uc3QgcGFyYW1ldGVyID0gXCJQYXJhbWV0cm9cIjtcbmNvbnN0IGlzUHVibGljID0gXCJJc1B1YmxpY1wiO1xuY29uc3QgaXNEYXRhc2V0ID0gXCJJc0RhdGFzZXRcIjtcbmNvbnN0IHVua25vd25QaXhlbFR5cGUgPSBcIlNjb25vc2NpdXRvXCI7XG5jb25zdCBvdXRwdXRQaXhlbFR5cGUgPSBcIlRpcG8gZGkgcGl4ZWwgZGkgb3V0cHV0XCI7XG5jb25zdCB1OFBpeGVsVHlwZSA9IFwiOCBiaXQgc2VuemEgc2Vnbm9cIjtcbmNvbnN0IHM4UGl4ZWxUeXBlID0gXCI4IGJpdCBjb24gc2Vnbm9cIjtcbmNvbnN0IHUxNlBpeGVsVHlwZSA9IFwiMTYgYml0IHNlbnphIHNlZ25vXCI7XG5jb25zdCBzMTZQaXhlbFR5cGUgPSBcIjE2IGJpdCBjb24gc2Vnbm9cIjtcbmNvbnN0IHUzMlBpeGVsVHlwZSA9IFwiMzIgYml0IHNlbnphIHNlZ25vXCI7XG5jb25zdCBzMzJQaXhlbFR5cGUgPSBcIjMyIGJpdCBjb24gc2Vnbm9cIjtcbmNvbnN0IGYzMlBpeGVsVHlwZSA9IFwiMzIgYml0IGEgdmlyZ29sYSBtb2JpbGVcIjtcbmNvbnN0IGY2NFBpeGVsVHlwZSA9IFwiNjQgYml0IGRvcHBpb1wiO1xuY29uc3QgcHJvcGVydGllcyA9IFwiUHJvcHJpZXTDoFwiO1xuY29uc3QgbXVsdGlkaW1lbnNpb25hbFJ1bGVzID0gXCJSZWdvbGUgbXVsdGlkaW1lbnNpb25hbGlcIjtcbmNvbnN0IG1hdGNoVmFyaWFibGVzID0gXCJGYXIgY29ycmlzcG9uZGVyZSB2YXJpYWJpbGkuXCI7XG5jb25zdCB1bmlvbkRpbWVuc2lvbnMgPSBcIkRpbWVuc2lvbmkgdW5pb25lXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbkVkaXRvciA9IHtcblx0aW52YWxpZFJGVE1lc3NhZ2U6IFwiTW9kZWxsbyBkaSBmdW56aW9uZSByYXN0ZXIgbm9uIHZhbGlkby5cIixcblx0cmZ4QXJnc0VkaXRvcjoge1xuXHRcdG91dHB1dFJhc3RlcjogXCJSYXN0ZXIgZGkgT3V0cHV0XCIsXG5cdFx0cmFzdGVyOiBcIlJhc3RlclwiLFxuXHRcdHVuc3VwcG9ydGVkRGF0YVR5cGVXYXJuaW5nOiBcIkdsaSBhcmdvbWVudGkgc2VndWVudGkgbm9uIHZlbmdvbm8gdmlzdWFsaXp6YXRpIHBlcmNow6kgbm9uIHNvbm8gc3VwcG9ydGF0aS5cIixcblx0XHR1bnN1cHBvcnRlZEZ1bmN0aW9uOiBcIkNvbnRpZW5lIGxlIGZ1bnppb25pIHJhc3RlciBhdHR1YWxtZW50ZSBub24gc3VwcG9ydGF0ZS5cIlxuXHR9LFxuXHRyZnhSYXN0ZXJJbnB1dDoge1xuXHRcdHNlbGVjdExheWVyOiBcIlNlbGV6aW9uYSBsYXllclwiLFxuXHRcdGJyb3dzZUxheWVyczogXCJTZm9nbGlhIGxheWVyXCIsXG5cdFx0cmZ4VmFyaWFibGU6IFwiUmFzdGVyRnVuY3Rpb25WYXJpYWJsZVwiXG5cdH0sXG5cdHJmeEJhbmRDb21iaW5hdGlvbkVkaXRvcjoge1xuXHRcdG1ldGhvZExhYmVsOiBcIk1ldG9kb1wiLFxuXHRcdGJhbmRMYWJlbDogXCJCYW5kYVwiLFxuXHRcdGNvbWJpbmF0aW9uTGFiZWw6IFwiQ29tYmluYXppb25lXCJcblx0fSxcblx0cmZ4UmVtYXBHcmlkOiB7XG5cdFx0bWluaW11bTogXCJNaW5pbW9cIixcblx0XHRtYXhpbXVtOiBcIk1hc3NpbW9cIixcblx0XHRvdXRwdXQ6IFwiT3V0cHV0XCIsXG5cdFx0bm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdHJlbWFwVmFsdWVzTGFiZWw6IFwiUmltYXBwYSB2YWxvcmlcIlxuXHR9LFxuXHRyZnhOYW1lZFJhc3RlckVkaXRvcjoge1xuXHRcdHJhc3RlclZhcmlhYmxlczogXCJWYXJpYWJpbGkgcmFzdGVyXCIsXG5cdFx0ZGVsZXRlU2VsZWN0ZWRWYXJzOiBcIlJpbXVvdmkgbGUgdmFyaWFiaWxpIHNlbGV6aW9uYXRlXCJcblx0fSxcblx0cmZ4Q2xpcHBpbmdHZW9tZXRyeToge1xuXHRcdGNsaXBwaW5nTGF5ZXI6IFwiTGF5ZXIgZGkgcml0YWdsaW9cIixcblx0XHRjbGlwcGluZ1Jhc3RlcjogXCJSYXN0ZXIgQ2xpcHBpbmdcIixcblx0XHRjbGlwcGluZ0dlb21ldHJ5OiBcIkdlb21ldHJpYSBkaSByaXRhZ2xpb1wiLFxuXHRcdGN1c3RvbUV4dGVudDogXCJFc3RlbnNpb25lIHBlcnNvbmFsaXp6YXRhXCIsXG5cdFx0b3V0cHV0RXh0ZW50OiBcIkVzdGVuc2lvbmUgZGkgb3V0cHV0XCIsXG5cdFx0Y3VycmVudEV4dGVudDogXCJFc3RlbnNpb25lIG1hcHBhIGNvcnJlbnRlXCIsXG5cdFx0ZHJhd0xhYmVsOiBcIkRpc2VnbmFcIlxuXHR9LFxuXHRyZnhDdXN0b21FeHRlbnQ6IHtcblx0XHR0b3A6IFwiSW4gYWx0b1wiLFxuXHRcdHJpZ2h0OiBcIkRlc3RyYVwiLFxuXHRcdGJvdHRvbTogXCJJbiBiYXNzb1wiLFxuXHRcdGxlZnQ6IFwiU2luaXN0cmFcIlxuXHR9LFxuXHRyZnhSYXN0ZXJBcnJheUVkaXRvcjoge1xuXHRcdG1vdmVVcDogXCJTcG9zdGEgc3VcIixcblx0XHRtb3ZlRG93bjogXCJTcG9zdGEgZ2nDuVwiLFxuXHRcdHJlbW92ZTogXCJSaW11b3ZpXCJcblx0fSxcblx0cmZ4U3RhdGlzdGljc0dyaWQ6IHtcblx0XHRzdGREZXY6IFwiRGV2aWF6aW9uZSBTdGFuZGFyZFwiLFxuXHRcdG1pbjogXCJNaW5pbWFcIixcblx0XHRtYXg6IFwiTWFzc2ltYVwiLFxuXHRcdG1lYW46IFwiTWVkaW9cIlxuXHR9LFxuXHRyZnhXZWlnaHRlZFN1bVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRTdW1UYWJsZTogXCJUYWJlbGxhIGRpIHNvbW1hIHBlc2F0YVwiLFxuXHRcdGlkOiBcIklEXCIsXG5cdFx0bGF5ZXI6IFwiTGF5ZXJcIixcblx0XHRmaWVsZDogXCJDYW1wb1wiLFxuXHRcdHdlaWdodDogXCJQZXNvXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JlXCIsXG5cdFx0c2VsZWN0TGF5ZXI6IFwiU2VsZXppb25hIGxheWVyXCJcblx0fSxcblx0cmZ4V2VpZ2h0ZWRPdmVybGF5VGFibGVFZGl0b3I6IHtcblx0XHR3ZWlnaHRlZE92ZXJsYXlUYWJsZTogXCJUYWJlbGxhIGRpIHNvdnJhcHBvc2l6aW9uZSBwZXNhdGFcIixcblx0XHRpZDogXCJJRFwiLFxuXHRcdGxheWVyOiBcIkxheWVyXCIsXG5cdFx0ZmllbGQ6IFwiQ2FtcG9cIixcblx0XHRpbmZsdWVuY2U6IFwiSW5mbHVlbnphXCIsXG5cdFx0c3VtT2ZJbmZsdWVuY2U6IFwiU29tbWEgZGkgaW5mbHVlbnphXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JlXCIsXG5cdFx0cmVtYXBUYWJsZTogXCJSaW1hcHBhIHRhYmVsbGFcIixcblx0XHRzY2FsZTogXCJTY2FsYVwiLFxuXHRcdHNjYWxlczogXCJTY2FsZVwiLFxuXHRcdHNlbGVjdFJhc3RlcjogXCJTZWxlemlvbmEgcmFzdGVyXCJcblx0fSxcblx0cmZ4RmVhdHVyZVNlbGVjdDoge1xuXHRcdGFkZEZlYXR1cmVMYXllcjogXCJDZXJjYSB1biBmZWF0dXJlIGxheWVyXCIsXG5cdFx0YWRkUG9pbnRMYXllcjogXCJDZXJjYSB1biBsYXllciBwdW50dWFsZVwiXG5cdH0sXG5cdHJmeEZpZWxkU2VsZWN0OiB7XG5cdFx0dmFsdWU6IFwiVmFsb3JlXCIsXG5cdFx0Y291bnQ6IFwiQ29udGVnZ2lvXCJcblx0fSxcblx0cmZ4QXR0cmlidXRlVGFibGU6IHtcblx0XHR0YWJsZVR5cGU6IFwiVGlwbyBkaSB0YWJlbGxhXCIsXG5cdFx0bWFudWFsOiBcIk1hbnVhbGVcIixcblx0XHRleHRlcm5hbDogXCJFc3Rlcm5vXCIsXG5cdFx0bWluVmFsOiBcIlZhbG9yZSBtaW5pbW9cIixcblx0XHRtYXhWYWw6IFwiVmFsb3JlIG1hc3NpbW9cIixcblx0XHRiYXNlQ2xhc3NOYW1lOiBcIk5vbWUgYmFzZSBjbGFzc2VcIixcblx0XHRjb2xvclNjaGVtZTogXCJTY2hlbWEgY29sb3JpXCIsXG5cdFx0ZGVmYXVsdENsYXNzTmFtZTogXCJFdGljaGV0dGFfXCIsXG5cdFx0Z2VuZXJhdGVUYWJsZTogXCJHZW5lcmEgdGFiZWxsYVwiLFxuXHRcdGJyb3dzZVRhYmxlOiBcIkVzYW1pbmEgdGFiZWxsYVwiLFxuXHRcdHZhbHVlOiBcIlZhbG9yZVwiLFxuXHRcdGNsYXNzbmFtZTogXCJDbGFzc05hbWVcIixcblx0XHRjb2xvcjogXCJDb2xvcmVcIlxuXHR9LFxuXHRyZnhGaWVsZE51bWJlclN3aXRjaGFibGU6IHtcblx0XHRudW1iZXI6IFwiTnVtZXJpY29cIixcblx0XHRmaWVsZDogXCJDYW1wb1wiLFxuXHRcdHN0cmluZzogXCJTdHJpbmdhXCIsXG5cdFx0bGluZWFyVW5pdDogXCJVbml0w6AgbGluZWFyZVwiXG5cdH0sXG5cdHJmeFByb3BlcnR5U2V0OiB7XG5cdFx0bmFtZTogXCJOb21lXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JlXCJcblx0fSxcblx0cmZ4Q29udmVyc2lvbkdyaWQ6IHtcblx0XHRzaXplOiBcIkRpbWVuc2lvbmVcIlxuXHR9LFxuXHRyZnhUcmFuc3Bvc2VCaXQ6IHtcblx0XHRiaXRQYXR0ZXJuOiBcIlNjaGVtYSBiaXRcIixcblx0XHRvdXRwdXRCaXQ6IFwiQml0IGRpIG91dHB1dFwiLFxuXHRcdGlucHV0Qml0OiBcIkJpdCBkaSBpbnB1dFwiXG5cdH0sXG5cdHJmeFNwYXRpYWxSZWZlcmVuY2U6IHtcblx0XHRwbGFjZUhvbGRlcjogXCJQZXJmZXppb25hIHBlciBwYXJvbGEgY2hpYXZlXCIsXG5cdFx0Y29vcmRpbmF0ZVN5c3RlbTogXCJTaXN0ZW1hIGRpIGNvb3JkaW5hdGVcIixcblx0XHRnY3M6IFwiU2lzdGVtYSBkaSBjb29yZGluYXRlIGdlb2dyYWZpY2hlXCIsXG5cdFx0cGNzOiBcIlNpc3RlbWEgZGkgY29vcmRpbmF0ZSBwcm9pZXR0YXRvXCIsXG5cdFx0dmNzOiBcIlNpc3RlbWEgZGkgY29vcmRpbmF0ZSB2ZXJ0aWNhbGlcIlxuXHR9XG59O1xuY29uc3QgcmZ4TGljZW5zZUluZm8gPSBcIlF1ZXN0byBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciBwdcOyIGVzc2VyZSB1c2F0byBwZXIgZWxhYm9yYXJlIGxlIGltbWFnaW5pIHV0aWxpenphbmRvIEFyY0dJUyBJbWFnZSBTZXJ2ZXIuXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbnMgPSB7XG5cdHJmeDoge1xuXHRcdGFDb3NITmFtZTogXCJBQ29zSFwiLFxuXHRcdGFDb3NIU25pcDogXCJDYWxjb2xhIGlsIGNvc2VubyBpcGVyYm9saWNvIGludmVyc28gZGkgY2VsbGUgaW4gdW4gcmFzdGVyXCIsXG5cdFx0YUNvc0hEZXNjOiBcIkxhIGZ1bnppb25lIGNhbGNvbGEgaWwgY29zZW5vIGlwZXJib2xpY28gaW52ZXJzbyBkZWkgcGl4ZWwgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdGFDb3NOYW1lOiBcIkFDb3NcIixcblx0XHRhQ29zU25pcDogXCJDYWxjb2xhIGlsIGNvc2VubyBpbnZlcnNvIGRlaSBwaXhlbCBpbiB1biByYXN0ZXIuXCIsXG5cdFx0YUNvc0Rlc2M6IFwiUXVlc3RhIGZ1bnppb25lIHJhc3RlciBjYWxjb2xhIGlsIGNvc2VubyBpbnZlcnNvIGRlbGxlIGNlbGxlIGluIHVuIHJhc3Rlci4gSW4gbWF0ZW1hdGljYSwgdHV0dGUgbGUgZnVuemlvbmkgdHJpZ29ub21ldHJpY2hlIGhhbm5vIHVuYSBnYW1tYSBkZWZpbml0YSBkaSB2YWxvcmkgZGkgaW5wdXQgdmFsaWRpLCBjaGlhbWF0YSBpbCBkb21pbmlvLiBBbmNoZSBpIHZhbG9yaSBkaSBvdXRwdXQgZGkgY2lhc2N1bmEgZnVuemlvbmUgaGFubm8gdW5hIGdhbW1hIGRlZmluaXRhLiBQZXIgcXVlc3RvIHN0cnVtZW50bywgaWwgZG9taW5pbyDDqCBbLTEsIDFdIGUgbOKAmWludGVydmFsbG8gw6ggWzAsIHBpXS5cIixcblx0XHRhU2luSE5hbWU6IFwiQVNpbkhcIixcblx0XHRhU2luSFNuaXA6IFwiQ2FsY29sYSBpbCBzZW5vIGlwZXJib2xpY28gaW52ZXJzbyBkaSBjZWxsZSBpbiB1biByYXN0ZXIuXCIsXG5cdFx0YVNpbkhEZXNjOiBcIkxhIGZ1bnppb25lIGNhbGNvbGEgaWwgc2VubyBpcGVyYm9saWNvIGludmVyc28gZGVpIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRhU2luTmFtZTogXCJBU2luXCIsXG5cdFx0YVNpblNuaXA6IFwiQ2FsY29sYSBpbCBzZW5vIGludmVyc28gZGkgY2VsbGUgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdGFTaW5EZXNjOiBcIkxhIGZ1bnppb25lIGNhbGNvbGEgaWwgc2VubyBpbnZlcnNvIGRlaSBwaXhlbCBpbiB1biByYXN0ZXIuXCIsXG5cdFx0YVRhbjJOYW1lOiBcIkFUYW4yXCIsXG5cdFx0YVRhbjJTbmlwOiBcIkNhbGNvbGEgbGEgdGFuZ2VudGUgaW52ZXJzYSAoYmFzYXRhIHN1IHgseSkgZGVsbGUgY2VsbGUgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdGFUYW4yRGVzYzogXCJMYSBmdW56aW9uZSBjYWxjb2xhIGxhIHRhbmdlbnRlIGludmVyc2EgKGJhc2F0YSBzdSB4LHkpIGRlaSBwaXhlbCBpbiB1biByYXN0ZXIuXCIsXG5cdFx0YVRhbkhOYW1lOiBcIkFUYW5IXCIsXG5cdFx0YVRhbkhTbmlwOiBcIkNhbGNvbGEgbGEgdGFuZ2VudGUgaXBlcmJvbGljYSBpbnZlcnNhIGRpIGNlbGxlIGluIHVuIHJhc3Rlci5cIixcblx0XHRhVGFuSERlc2M6IFwiTGEgZnVuemlvbmUgY2FsY29sYSBsYSB0YW5nZW50ZSBpcGVyYm9saWNhIGludmVyc2EgZGVpIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRhVGFuTmFtZTogXCJBVGFuXCIsXG5cdFx0YVRhblNuaXA6IFwiQ2FsY29sYSBsYSB0YW5nZW50ZSBpbnZlcnNhIGRpIGNlbGxlIGluIHVuIHJhc3Rlci5cIixcblx0XHRhVGFuRGVzYzogXCJMYSBmdW56aW9uZSBjYWxjb2xhIGxhIHRhbmdlbnRlIGludmVyc2EgZGVpIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRhYnNOYW1lOiBcIkFic1wiLFxuXHRcdGFic1NuaXA6IFwiQ2FsY29sYSBpbCB2YWxvcmUgYXNzb2x1dG8gZGVsbGUgY2VsbGUgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdGFic0Rlc2M6IFwiTGEgZnVuemlvbmUgQWJzIGNhbGNvbGEgaWwgdmFsb3JlIGFzc29sdXRvIGRlaSBwaXhlbCBpbiB1biByYXN0ZXIuXCIsXG5cdFx0cmVmbGVjdGFuY2VOYW1lOiBcIlJpZmxldHRhbnphIGFwcGFyZW50ZVwiLFxuXHRcdHJlZmxlY3RhbmNlU25pcDogXCJDb252ZXJ0ZSBpbW1hZ2luaSBvcmlnaW5hbGkgaW4gdmFsb3JpIE1hc3NpbW8gZGVsbCdhdG1vc2ZlcmEgcHJlbmRlbmRvIGluIGNvbnNpZGVyYXppb25lIGxlIGNhcmF0dGVyaXN0aWNoZSBkZWwgc2Vuc29yZSwgbGEgcG9zaXppb25lIGRlbCBzb2xlIGUgaWwgdGVtcG8gZGkgYWNxdWlzaXppb25lLlwiLFxuXHRcdHJlZmxlY3RhbmNlRGVzYzogXCJRdWVzdGEgZnVuemlvbmUgcmVnb2xhIGkgdmFsb3JpIGRpIG51bWVybyBkaWdpdGFsZSAoRE4pIGRlbGxhIGx1bWlub3NpdMOgIGRpIGltbWFnaW5lIHBlciBhbGN1bmkgc2Vuc29yaSBkaSBzYXRlbGxpdGkuIExlIHJlZ29sYXppb25pIHNpIGJhc2FubyBzdWxsJ2VsZXZhemlvbmUgZGVsIHNvbGUsIGxhIGRhdGEgZGkgYWNxdWlzaXppb25lIGUgbGUgcHJvcHJpZXTDoCBkZWwgc2Vuc29yZSBwZXIgaW1wb3N0YXJlIGlsIGd1YWRhZ25vIGUgaWwgZmF0dG9yZSBkaSBkaXN0dXJibyBwZXIgb2duaSBiYW5kYS4gUXVlc3RhIGZ1bnppb25lIHZpZW5lIHVzYXRhIHBlciByZWdvbGFyZSBpIHZhbG9yaSBkaSByaWZsZXR0YW56YSwgbyBsdW1pbm9zaXTDoCwgZGkgYWxjdW5lIGltbWFnaW5pIGRpIHNhdGVsbGl0aSBpbiBiYXNlIGFsbGUgaW1wb3N0YXppb25pIGRpIGlsbHVtaW5hemlvbmUgZGVsbGEgc2NlbmEgZSBkaSBndWFkYWdubyBkZWwgc2Vuc29yZS4gTGUgaW1tYWdpbmkgdmVuZ29ubyByZWdvbGF0ZSBzdSB1bmEgY29uZGl6aW9uZSBkaSBpbGx1bWluYXppb25lIHRlb3JpY2FtZW50ZSBjb211bmUsIGlsIGNoZSBjb21wb3J0YSBwcmVzdW1pYmlsbWVudGUgdW5hIG1pbm9yZSB2YXJpYXppb25lIHRyYSBzY2VuZSBkYSBkYXRlIGRpdmVyc2UgZSBzZW5zb3JpIGRpdmVyc2kuIENpw7IgcHXDsiBlc3NlcmUgdXRpbGUgcGVyIGxhIGNsYXNzaWZpY2F6aW9uZSBkZWxsZSBpbW1hZ2luaSwgaWwgYmlsYW5jaWFtZW50byBkZWwgY29sb3JlIGUgbGEgY3JlYXppb25lIGRpIHVuIG1vc2FpY28uIFF1ZXN0YSBmdW56aW9uZSBwdcOyIGVzc2VyZSB1c2F0YSBzb2xvIGNvbiBpbW1hZ2luaSBzcGVjaWZpY2hlLiBJIHNlbnNvcmkgYXBwbGljYWJpbGkgc29ubyBMYW5kc2F0IE1TUywgTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rLCBMYW5kc2F0IDgsIElLT05PUywgUXVpY2tCaXJkLCBHZW9FeWUtMSwgUmFwaWRFeWUsIERNQ2lpLCBXb3JsZFZpZXctMSwgV29ybGRWaWV3LTIsIFNQT1QgNiBlIFBsZWlhZGVzLjxkaXY+PGJyLz5MYSBmdW56aW9uZSBlc2VndWUgZHVlIGNvcnJlemlvbmkuIExhIHByaW1hIHNpIGJhc2Egc3VsbGUgaW1wb3N0YXppb25pIGRlbCBmYXR0b3JlIGRpIGd1YWRhZ25vLiBJIHZhbG9yaSBvcmlnaW5hbGkgZGkgbHVtaW5vc2l0w6Agc29ubyByaWNyZWF0aSBkYWkgdmFsb3JpIGRlbGwnaW1tYWdpbmUgaW52ZXJ0ZW5kbyBsZSBlcXVhemlvbmkgZGVsIGZhdHRvcmUgZGkgZ3VhZGFnbm8uIExhIHNlY29uZGEgY29ycmV6aW9uZSByaWd1YXJkYSBsZSBkaWZmZXJlbnplIGRpIGFuZ29sYXppb25lIGRlbCBzb2xlIGUgbHVtaW5vc2l0w6AuIEkgdmFsb3JpIG9yaWdpbmFsaSBkaSBsdW1pbm9zaXTDoCBzb25vIHJlZ29sYXRpIHN1IHVuYSBjb25kaXppb25lIGNvbXVuZSBkaSBpbGx1bWluYXppb25lIG5vcm1hbGl6emFuZG8gc2NlbmUgYWNxdWlzaXRlIGluIGNvbmRpemlvbmkgdmFyaWFiaWxpIGRpIGlsbHVtaW5hemlvbmUuIEluIGdlbmVyYWxlLCBtZW50cmUgaWwgdGlwbyBkaSBkYXRpIGRlbGwnaW1tYWdpbmUgZGkgb3V0cHV0IMOoIGxvIHN0ZXNzbyBkaSBxdWVsbG8gZGVsbCdpbW1hZ2luZSBkaSBpbnB1dCwgaSB2YWxvcmkgZGkgb3V0cHV0IHNvbm8gaW5mZXJpb3JpIGFpIHZhbG9yaSBkaSBpbnB1dCBlIHNvbm8gcml0YWdsaWF0aSBuZWxsJ2ludGVydmFsbG8gZGkgZGF0aSB2YWxpZGkuPC9kaXY+XCIsXG5cdFx0YXJnU3RhdGlzdGljc05hbWU6IFwiQXJnU3RhdGlzdGljc1wiLFxuXHRcdGFyZ1N0YXRpc3RpY3NTbmlwOiBcIkNhbGNvbGEgbGUgc3RhdGlzdGljaGUgZGVnbGkgYXJnb21lbnRpLCBpbmNsdXNpIEFyZyBNYXgsIEFyZyBNaW4sIEFyZyBNZWRpYW4gZSBEdXJhdGlvbi5cIixcblx0XHRhcmdTdGF0aXN0aWNzRGVzYzogXCJMYSBmdW56aW9uZSBjYWxjb2xhIGxlIHN0YXRpc3RpY2hlIGRlZ2xpIGFyZ29tZW50aS4gRXNpc3Rvbm8gcXVhdHRybyBtZXRvZGkgbmVsbGEgZnVuemlvbmUgQXJnU3RhdGlzdGljczogQXJnTWF4LCBBcmdNaW4sIEFyZ01lZGlhbiBlIER1cmF0YS5cIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0bWV0aWNvXCIsXG5cdFx0YXJpdGhtZXRpY1NuaXA6IFwiRXNlZ3VlIHVuJ29wZXJhemlvbmUgYXJpdG1ldGljYSB0cmEgZHVlIHJhc3RlciBvIHVuIHJhc3RlciBlIHVubyBzY2FsYXJlLlwiLFxuXHRcdGFyaXRobWV0aWNEZXNjOiBcIkxhIGZ1bnppb25lIEFyaXRtZXRpY2EgZXNlZ3VlIHVu4oCZb3BlcmF6aW9uZSBhcml0bWV0aWNhIHRyYSBkdWUgcmFzdGVyIG8gdHJhIHVuIHJhc3RlciBlIHVubyBzY2FsYXJlIGUgdmljZXZlcnNhLlwiLFxuXHRcdGFzcGVjdFNsb3BlTmFtZTogXCJBc3BldHRvLVNlemlvbmVcIixcblx0XHRhc3BlY3RTbG9wZVNuaXA6IFwiQ3JlYSB1biByYXN0ZXIgY2hlIHZpc3VhbGl6emEgc2ltdWx0YW5lYW1lbnRlIGwnYXNwZXR0byAoZGlyZXppb25lKSBlIGxhIHNlemlvbmUgKHJpcGlkZXp6YSkgZGkgdW5hIHN1cGVyZmljaWUgY29udGludWEsIGNvbWUgcmFwcHJlc2VudGF0YSBpbiB1biBtb2RlbGxvIGRpIGVsZXZhemlvbmUgZGlnaXRhbGUuXCIsXG5cdFx0YXNwZWN0U2xvcGVEZXNjOiBcIkxhIGZ1bnppb25lIEFzcGV0dG8tUGVuZGVuemEgY3JlYSB1biBsYXllciByYXN0ZXIgY2hlIHZpc3VhbGl6emEgc2ltdWx0YW5lYW1lbnRlIGzigJlhc3BldHRvIGUgbGEgcGVuZGVuemEgZGkgdW5hIHN1cGVyZmljaWUuIEwnYXNwZXR0byBpZGVudGlmaWNhIGxhIGRpcmV6aW9uZSBjb24gbGEgbWFzc2ltYSBwZXJjZW50dWFsZSBkaSB2YXJpYXppb25lIGluIGRpc2Nlc2EgZGEgdW4gcGl4ZWwgYSBxdWVsbGkgdmljaW5pLiBMJ2FzcGV0dG8gcHXDsiBlc3NlcmUgY29uc2lkZXJhdG8gY29tZSBsYSBkaXJlemlvbmUgZGVsbGEgcGVuZGVuemEuIEkgdmFsb3JpIGRlbCByYXN0ZXIgZGkgb3V0cHV0IHNhcmFubm8gbGEgZGlyZXppb25lIGRlbGxhIGJ1c3NvbGEgZGVsbOKAmWFzcGV0dG8sIHJhcHByZXNlbnRhdGEgZGEgdW5hIHRvbmFsaXTDoCAoY29sb3JlKS4gTGEgcGVuZGVuemEgcmFwcHJlc2VudGEgbGEgcGVyY2VudHVhbGUgZGkgdmFyaWF6aW9uZSBkZWxsJ2VsZXZhemlvbmUgcGVyIG9nbmkgcGl4ZWwgZGVsIG1vZGVsbG8gZGkgZWxldmF6aW9uZSBkaWdpdGFsZSAoREVNKS4gTGEgcGVuZGVuemEgcmFwcHJlc2VudGEgbGEgcmlwaWRlenphIGRlbGxhIHN1cGVyZmljaWUgZWQgw6ggc2ltYm9sZWdnaWF0YSBkYSB0cmUgY2xhc3NpIG1vc3RyYXRlIG1lZGlhbnRlIGxhIHNhdHVyYXppb25lIGRlbCBjb2xvcmUgKGx1bWlub3NpdMOgKS48ZGl2Pjxici8+SSB2YWxvcmkgZGVpIHBpeGVsIG5lbCByYXN0ZXIgZGkgb3V0cHV0IGFzcGV0dG8tcGVuZGVuemEgcmlzcGVjY2hpYW5vIGxhIGNvbWJpbmF6aW9uZSBkaSBhc3BldHRvIGUgcGVuZGVuemEuIEkgcGl4ZWwgY29uIHZhbG9yaSBpbmZlcmlvcmkgYSAyMCBzb25vIGNvbnNpZGVyYXRpIHBpYXR0aSBlIHZpc3VhbGl6emF0aSBpbiBncmlnaW8uIEkgdmFsb3JpIGRpIGFzcGV0dG8tcGVuZGVuemEgcGFyaSBvIHN1cGVyaW9yaSBhIDIxIHNhcmFubm8gdmlzdWFsaXp6YXRpIGNvbiBkaXZlcnNlIHNhdHVyYXppb25pLCBjb21lIHNlZ3VlOiBkYSAyMSBhIDMwIOKAlHNhdHVyYXppb25lIGRpIHBlbmRlbnphIGJhc3NhOyBkYSAzMSBhIDQw4oCUc2F0dXJhemlvbmUgZGkgcGVuZGVuemEgbW9kZXJhdGE7IGRhIDQxIGluIHN14oCUc2F0dXJhemlvbmUgZGkgcGVuZGVuemEgZWxldmF0YS48L2Rpdj5cIixcblx0XHRhc3BlY3ROYW1lOiBcIkVzcG9zaXppb25lXCIsXG5cdFx0YXNwZWN0U25pcDogXCJNb3N0cmEgbGEgZGlyZXppb25lIHZlcnNvIGxhIHF1YWxlIMOoIHJpdm9sdG8gdW4gcGl4ZWwsIGluIGN1aSAwIMOoIHZlcnNvIG5vcmQgZSBnbGkgYW5nb2xpIGF1bWVudGFubyBpbiBzZW5zbyBhbnRpb3JhcmlvIGZpbm8gYSAzNjAuXCIsXG5cdFx0YXNwZWN0RGVzYzogXCJMYSBmdW56aW9uZSBBc3BldHRvIGlkZW50aWZpY2EgbGEgZGlyZXppb25lIGNvbiBsYSBtYXNzaW1hIHBlcmNlbnR1YWxlIGRpIHZhcmlhemlvbmUgaW4gZGlzY2VzYSBkYSB1bmEgY2VsbGEgYSBxdWVsbGUgdmljaW5lLiBMJ2FzcGV0dG8gcHXDsiBlc3NlcmUgY29uc2lkZXJhdG8gY29tZSBsYSBkaXJlemlvbmUgZGVsbGEgcGVuZGVuemEuIEkgdmFsb3JpIGRlbCByYXN0ZXIgZGkgb3V0cHV0IHNhcmFubm8gbGEgZGlyZXppb25lIGRlbGxhIGJ1c3NvbGEgZGVsbCdBc3BlY3QuPGRpdj48YnIvPkwnaW5wdXQgcGVyIHF1ZXN0YSBmdW56aW9uZSDDqCBSYXN0ZXIgZGkgaW5wdXQuIExhIGZ1bnppb25lIEFzcGV0dG8gc2kgYXBwbGljYSBzcGVzc28gYSB1biBtb2RlbGxvIGRpZ2l0YWxlIGRpIGVsZXZhemlvbmUgKERFTSkuIFBlciBpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEsIGwnQXNwZXR0byBhcHBhcmUgY29tZSB1bidpbW1hZ2luZSBpbiBzY2FsYSBkaSBncmlnaS4gw4ggcG9zc2liaWxlIGFnZ2l1bmdlcmUgbGEgZnVuemlvbmUgQ29sb3JtYXAgcGVyIHNwZWNpZmljYXJlIHVubyBzY2hlbWEgZGkgY29sb3JpIHBhcnRpY29sYXJlIG8gcGVyIGNvbnNlbnRpcmUgYWxsYSBwZXJzb25hIGNoZSB2aXN1YWxpenphIGlsIG1vc2FpY28gZGkgbW9kaWZpY2FyZSBsYSBzaW1ib2xvZ2lhIGNvbiBpbCBwcm9wcmlvIHNjaGVtYSBkaSBjb2xvcmkuPC9kaXY+XCIsXG5cdFx0dGFibGVOYW1lOiBcIlRhYmVsbGEgYXR0cmlidXRpXCIsXG5cdFx0dGFibGVTbmlwOiBcIlF1ZXN0YSBmdW56aW9uZSB1dGlsaXp6YSB1bmEgdGFiZWxsYSBwZXIgZGVub21pbmFyZSBlIHNpbWJvbGVnZ2lhcmUgaSB2YWxvcmkgaW4gdW4gZGF0YXNldC4gTGUgY29sb25uZSBkZWxsYSB0YWJlbGxhIHNvbm8gc2VwYXJhdGUgZGEgdmlyZ29sZTogUGl4ZWxWYWx1ZSwgQXR0cmlidXRlTmFtZSwgUmVkVmFsdWUsIEdyZWVuVmFsdWUsIEJsdWVWYWx1ZS5cIixcblx0XHR0YWJsZURlc2M6IFwiTGEgZnVuemlvbmUgVGFiZWxsYSBhdHRyaWJ1dGkgY29uc2VudGUgZGkgZGVmaW5pcmUgdW5hIHRhYmVsbGEgZGkgYXR0cmlidXRpIHBlciBzaW1ib2xlZ2dpYXJlIHVuIG1vc2FpYyBkYXRhc2V0IGEgYmFuZGEgc2luZ29sYSBvIHVuIHJhc3RlciBkYXRhc2V0LiA8ZGl2Pjxici8+w4ggdXRpbGUgcXVhbmRvIHNpIGRlc2lkZXJhIHByZXNlbnRhcmUgaW1tYWdpbmkgc290dG9wb3N0ZSBhIGNsYXNzaWZpY2F6aW9uZSBwZXIgbCd1c28gZGVsIHN1b2xvLCBjb21lIHRlcnJlbmkgZm9yZXN0YWxpLCB6b25lIHVtaWRlLCB0ZXJyZW5pIGNvbHRpdmF0aSBlIGFyZWUgdXJiYW5lLiBJbm9sdHJlLCBzZSBsYSB0YWJlbGxhIGNvbnRpZW5lIGNhbXBpIGRlbm9taW5hdGkgcm9zc28sIHZlcmRlIGUgYmx1LCBpIHZhbG9yaSBhbGwnaW50ZXJubyBkaSB0YWxpIGNhbXBpIHZlcnJhbm5vIHV0aWxpenphdGkgY29tZSBjb2xvcm1hcCBkdXJhbnRlIGlsIHJlbmRlcmluZyBkZWxsJ2ltbWFnaW5lLjwvZGl2PlwiLFxuXHRcdGJhbmRBcml0aG1ldGljTmFtZTogXCJBcml0bWV0aWNhIGJhbmRhXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNTbmlwOiBcIkNhbGNvbGEgZ2xpIGluZGljaSB1dGlsaXp6YW5kbyBmb3JtdWxlIHByZWRlZmluaXRlIG8gdW4nZXNwcmVzc2lvbmUgZGVmaW5pdGEgZGFsbCd1dGVudGUuXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNEZXNjOiBcIkxhIGZ1bnppb25lIEFyaXRtZXRpY2EgQmFuZGEgZXNlZ3VlIHVuJ29wZXJhemlvbmUgYXJpdG1ldGljYSBzdWxsZSBiYW5kZSBkaSB1biBkYXRhc2V0IHJhc3Rlci4gw4ggcG9zc2liaWxlIHNjZWdsaWVyZSBhbGdvcml0bWkgcHJlZGVmaW5pdGkgc2VsZXppb25hYmlsaSBvcHB1cmUgc2kgcHXDsiBpbW1ldHRlcmUgbGEgcHJvcHJpYSBmb3JtdWxhIGEgcmlnYSBzaW5nb2xhLiBHbGkgb3BlcmF0b3JpIHN1cHBvcnRhdGkgc29ubyAtLCArLCAvLCAqIGUgLSB1bmFyaW8uXCIsXG5cdFx0dGhyZXNob2xkTmFtZTogXCJJbXBvc3RhemlvbmUgc29nbGlhIGJpbmFyaWFcIixcblx0XHR0aHJlc2hvbGRTbmlwOiBcIk9yZ2FuaXp6YSBkYXRpIGNvbnRpbnVpIGluIHByaW1vIHBpYW5vIGUgc3VsbG8gc2ZvbmRvIG1pbmltaXp6YW5kbyBsYSBjb3ZhcmlhbnphIHRyYSBsZSBkdWUgY2xhc3NpLlwiLFxuXHRcdHRocmVzaG9sZERlc2M6IFwiUXVhbmRvIHVuIGRhdGFzZXQgcmFzdGVyIGhhIHVuYSBkaXN0cmlidXppb25lIGJpbW9kYWxlLCBxdWVzdGEgZnVuemlvbmUgY3JlYSB1biBudW92byByYXN0ZXIgY2hlIGRpdmlkZSBpIGRhdGkgaW4gZHVlIGNsYXNzaSBkaXN0aW50ZS4gVmllbmUgY3JlYXRhIHVuYSBjbGFzc2UgZGkgdmFsb3JpIGJhc3NpIHZpc3VhbGl6emF0YSBjb24gcGl4ZWwgbmVyaSBlIHVuYSBjbGFzc2UgZGkgdmFsb3JpIGVsZXZhdGkgdmlzdWFsaXp6YXRhIGNvbiBwaXhlbCBiaWFuY2hpLlwiLFxuXHRcdGJpdHdpc2VBbmROYW1lOiBcIkFuZCBCaXR3aXNlXCIsXG5cdFx0Yml0d2lzZUFuZFNuaXA6IFwiRWZmZXR0dWEgdW5hIG9wZXJhemlvbmUgYml0d2lzZSBBbmQgc3VpIHZhbG9yaSBiaW5hcmkgZGkgZHVlIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XHRiaXR3aXNlQW5kRGVzYzogXCJCaXR3aXNlIEFuZCBlc2VndWUgdW7igJlvcGVyYXppb25lIEFuZCBhIGxpdmVsbG8gYml0IHN1aSB2YWxvcmkgYmluYXJpIGRpIGR1ZSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdE5hbWU6IFwiU3Bvc3RhbWVudG8gYSBzaW5pc3RyYSBCaXR3aXNlXCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdFNuaXA6IFwiRXNlZ3VlIHVuJ29wZXJhemlvbmUgYml0d2lzZSBTaGlmdCBhIHNpbmlzdHJhIHN1aSB2YWxvcmkgYmluYXJpIGRpIGR1ZSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdERlc2M6IFwiQml0d2lzZSBMZWZ0IFNoaWZ0IGVzZWd1ZSB1bidvcGVyYXppb25lIGRpIHNwb3N0YW1lbnRvIGEgc2luaXN0cmEgYSBsaXZlbGxvIGJpdCBzdWkgdmFsb3JpIGJpbmFyaSBkZWkgZHVlIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XHRiaXR3aXNlTm90TmFtZTogXCJOb3QgQml0d2lzZVwiLFxuXHRcdGJpdHdpc2VOb3RTbmlwOiBcIkVzZWd1ZSB1bidvcGVyYXppb25lIE5vdCBhIGxpdmVsbG8gYml0IChjb21wbGVtZW50bykgc3VsIHZhbG9yZSBiaW5hcmlvIGRpIHVuIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XHRiaXR3aXNlTm90RGVzYzogXCJMYSBmdW56aW9uZSBlc2VndWUgdW4nb3BlcmF6aW9uZSBOb3QgYSBsaXZlbGxvIGJpdCAoY29tcGxlbWVudG8pIHN1bCB2YWxvcmUgYmluYXJpbyBkaSB1biByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFx0Yml0d2lzZU9yTmFtZTogXCJPciBCaXR3aXNlXCIsXG5cdFx0Yml0d2lzZU9yU25pcDogXCJFc2VndWUgdW4nb3BlcmF6aW9uZSBiaXR3aXNlIE9yIHN1aSB2YWxvcmkgYmluYXJpIGRlaSBkdWUgcmFzdGVyIGRpIGlucHV0LlwiLFxuXHRcdGJpdHdpc2VPckRlc2M6IFwiTGEgZnVuemlvbmUgZXNlZ3VlIHVuJ29wZXJhemlvbmUgT3IgYSBsaXZlbGxvIGJpdCBzdWkgdmFsb3JpIGJpbmFyaSBkZWkgZHVlIHJhc3RlciBkaSBpbnB1dC4gXCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnROYW1lOiBcIlNwb3N0YW1lbnRvIGEgZGVzdHJhIEJpdHdpc2VcIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdFNuaXA6IFwiRXNlZ3VlIHVuJ29wZXJhemlvbmUgYml0d2lzZSBkaSBkaSBzaGlmdCBhIGRlc3RyYSBzdWkgdmFsb3JpIGJpbmFyaSBkZWkgZHVlIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdERlc2M6IFwiTGEgZnVuemlvbmUgZXNlZ3VlIHVuJ29wZXJhemlvbmUgZGkgc3Bvc3RhbWVudG8gYSBkZXN0cmEgYSBsaXZlbGxvIGJpdCBzdWkgdmFsb3JpIGJpbmFyaSBkZWkgZHVlIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XHRiaXR3aXNlWG9yTmFtZTogXCJCaXR3aXNlIFhvclwiLFxuXHRcdGJpdHdpc2VYb3JTbmlwOiBcIkVzZWd1ZSB1bidvcGVyYXppb25lIGJpdHdpc2UgT3IgZXNjbHVzaXZvIHN1aSB2YWxvcmkgYmluYXJpIGRpIGR1ZSByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFx0Yml0d2lzZVhvckRlc2M6IFwiTGEgZnVuemlvbmUgZXNlZ3VlIHVuJ29wZXJhemlvbmUgT3IgZXNjbHVzaXZvIGEgbGl2ZWxsbyBiaXQgc3VpIHZhbG9yaSBiaW5hcmkgZGkgZHVlIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XHRib29sZWFuQW5kTmFtZTogXCJCb29sZWFuIEFuZFwiLFxuXHRcdGJvb2xlYW5BbmRTbmlwOiBcIkVzZWd1ZSB1bidvcGVyYXppb25lIEFuZCBib29sZWFubyBzdWkgdmFsb3JpIGRlbGxlIGNlbGxlIGRpIGR1ZSByYXN0ZXIgZGkgaW5wdXQuIFNlIGVudHJhbWJpIGkgdmFsb3JpIGRpIGlucHV0IHNvbm8gdHJ1ZSAobm9uLXplcm8pLCBs4oCZb3V0cHV0IMOoIDEuIFNlIHVubyBvIGVudHJhbWJpIGkgdmFsb3JpIGRpIGlucHV0IHNvbm8gZmFsc2UgKHplcm8pLCBsJ291dHB1dCDDqCAwLlwiLFxuXHRcdGJvb2xlYW5BbmREZXNjOiBcIkxhIGZ1bnppb25lIGVzZWd1ZSB1bidvcGVyYXppb25lIEFuZCBib29sZWFubyBzdWkgdmFsb3JpIGRlaSBwaXhlbCBkaSBkdWUgcmFzdGVyIGRpIGlucHV0LiBTZSBlbnRyYW1iaSBpIHZhbG9yaSBkaSBpbnB1dCBzb25vIHRydWUgKG5vbi16ZXJvKSwgaWwgdmFsb3JlIGRpIG91dHB1dCDDqCAxLiBTZSB1bm8gbyBlbnRyYW1iaSBpIHZhbG9yaSBkaSBpbnB1dCBzb25vIGZhbHNlICh6ZXJvKSwgbCdvdXRwdXQgw6ggMC4gXCIsXG5cdFx0Ym9vbGVhbk5vdE5hbWU6IFwiTm8gYm9vbGVhbm9cIixcblx0XHRib29sZWFuTm90U25pcDogXCJFc2VndWUgdW4nb3BlcmF6aW9uZSBOb3QgYm9vbGVhbm8gKGNvbXBsZW1lbnRvKSBzdWkgdmFsb3JpIGRlbGxlIGNlbGxlIGRlbCByYXN0ZXIgZGkgaW5wdXQuIFNlIGkgdmFsb3JpIGRpIGlucHV0IHNvbm8gdHJ1ZSAobm9uLXplcm8pLCBpbCB2YWxvcmUgZGkgb3V0cHV0IMOoIDAuIFNlIGkgdmFsb3JpIGRpIGlucHV0IHNvbm8gZmFsc2UgKHplcm8pLCBs4oCZb3V0cHV0IMOoIDEuXCIsXG5cdFx0Ym9vbGVhbk5vdERlc2M6IFwiTGEgZnVuemlvbmUgZXNlZ3VlIHVuJ29wZXJhemlvbmUgTm90IGJvb2xlYW5vIChjb21wbGVtZW50bykgc3VpIHZhbG9yaSBkZWkgcGl4ZWwgZGVsIHJhc3RlciBkaSBpbnB1dC4gU2UgaSB2YWxvcmkgZGkgaW5wdXQgc29ubyB0cnVlIChub24temVybyksIGlsIHZhbG9yZSBkaSBvdXRwdXQgw6ggMC4gU2UgaSB2YWxvcmkgZGkgaW5wdXQgc29ubyBmYWxzZSAoemVybyksIGlsIHZhbG9yZSBkaSBvdXRwdXQgw6ggMS5cIixcblx0XHRib29sZWFuT3JOYW1lOiBcIkJvb2xlYW4gT3JcIixcblx0XHRib29sZWFuT3JTbmlwOiBcIkVzZWd1ZSB1bidvcGVyYXppb25lIE9yIGJvb2xlYW5vIHN1aSB2YWxvcmkgZGVsbGUgY2VsbGUgZGkgZHVlIHJhc3RlciBkaSBpbnB1dC4gU2UgdW5vIG8gZW50cmFtYmkgaSB2YWxvcmkgZGkgaW5wdXQgc29ubyB0cnVlIChub24temVybyksIGlsIHZhbG9yZSBkaSBvdXRwdXQgw6ggMS4gU2UgZW50cmFtYmkgaSB2YWxvcmkgZGkgaW5wdXQgc29ubyBmYWxzZSAoemVybyksIGzigJlvdXRwdXQgw6ggMC5cIixcblx0XHRib29sZWFuT3JEZXNjOiBcIkxhIGZ1bnppb25lIGVzZWd1ZSB1bidvcGVyYXppb25lIE9yIGJvb2xlYW5vIHN1aSB2YWxvcmkgZGVsbGUgY2VsbGUgZGkgZHVlIHJhc3RlciBkaSBpbnB1dC4gU2UgdW5vIG8gZW50cmFtYmkgaSB2YWxvcmkgZGkgaW5wdXQgc29ubyB0cnVlIChub24temVybyksIGlsIHZhbG9yZSBkaSBvdXRwdXQgw6ggMS4gU2UgZW50cmFtYmkgaSB2YWxvcmkgZGkgaW5wdXQgc29ubyBmYWxzZSAoemVybyksIGlsIHZhbG9yZSBkaSBvdXRwdXQgw6ggMC5cIixcblx0XHRib29sZWFuWG9yTmFtZTogXCJCb29sZWFuIFhvclwiLFxuXHRcdGJvb2xlYW5Yb3JTbmlwOiBcIkVzZWd1ZSB1bidvcGVyYXppb25lIGVYY2x1c2l2ZSBPciBib29sZWFubyBzdWkgdmFsb3JpIGRlbGxlIGNlbGxlIGRpIGR1ZSByYXN0ZXIgZGkgaW5wdXQuIFNlIHVuIHZhbG9yZSBkaSBpbnB1dCDDqCB0cnVlIChub24temVybykgZSBsJ2FsdHJvIMOoIGZhbHNlICh6ZXJvKSwgbOKAmW91dHB1dCDDqCAxLiBTZSBpIHZhbG9yaSBkaSBpbnB1dCBzb25vIGVudHJhbWJpIHRydWUgbyBlbnRyYW1iaSBmYWxzZSwgbOKAmW91dHB1dCDDqCAwLlwiLFxuXHRcdGJvb2xlYW5Yb3JEZXNjOiBcIkxhIGZ1bnppb25lIGVzZWd1ZSB1bidvcGVyYXppb25lIGVYY2x1c2l2ZSBPciBib29sZWFubyBzdWkgdmFsb3JpIGRlbGxlIGNlbGxlIGRpIGR1ZSByYXN0ZXIgZGkgaW5wdXQuIFNlIHVuIHZhbG9yZSBkaSBpbnB1dCDDqCB0cnVlIChub24temVybykgZSBsJ2FsdHJvIHZhbG9yZSDDqCBmYWxzZSAoemVybyksIGlsIHZhbG9yZSBkaSBvdXRwdXQgw6ggMS4gU2UgZW50cmFtYmkgaSB2YWxvcmkgZGkgaW5wdXQgc29ubyB0cnVlIG8gZW50cmFtYmkgc29ubyBmYWxzZSwgaWwgdmFsb3JlIGRpIG91dHB1dCDDqCAwLlwiLFxuXHRcdGJ1ZmZlcmVkUmFzdGVyTmFtZTogXCJNZW1vcml6emF0byBuZWwgYnVmZmVyXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJTbmlwOiBcIk1lbW9yaXp6YSBuZWwgYnVmZmVyIGdsaSB1bHRpbWkgYmxvY2NoaSBkaSBwaXhlbCBhcGVydGkuXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJEZXNjOiBcIkxhIGZ1bnppb25lIGRpIGJ1ZmZlciBzaSB1c2EgcGVyIG90dGltaXp6YXJlIGxlIHByZXN0YXppb25pIGRpIGNhdGVuZSBjb21wbGVzc2UgZGkgZnVuemlvbmkuIEFyY2hpdmlhIGwnb3V0cHV0IGluIG1lbW9yaWEgZGVsbGEgcGFydGUgZGVsbGEgY2F0ZW5hIGRpIGZ1bnppb25pIGNoZSBsYSBwcmVjZWRlLiA8ZGl2Pjxici8+SW5zZXJpcmUgcXVlc3RhIGZ1bnppb25lIG5lbGwnRWRpdG9yIGRpIGZ1bnppb25pIGluIGN1aSBzaSBkZXNpZGVyYSBtZW1vcml6emFyZSBsJ291dHB1dC48L2Rpdj5cIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yTmFtZTogXCJDYWxjb2xhdG9yZVwiLFxuXHRcdHJhc3RlckNhbGN1bGF0b3JTbmlwOiBcIkNhbGNvbGEgdW4gcmFzdGVyIGRhIHVuJ2VzcHJlc3Npb25lIG1hdGVtYXRpY2EgYmFzYXRhIHN1IHJhc3Rlci5cIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yRGVzYzogXCJMYSBmdW56aW9uZSBDYWxjb2xhdG9yZSBjb25zZW50ZSBkaSBjcmVhcmUgZWQgZXNlZ3VpcmUgZXNwcmVzc2lvbmkgZSBpbmNsdWRlcmxlIGluIGNhdGVuZSBkaSBmdW56aW9uaS5cIixcblx0XHRjZWxsU3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGljaGUgZGVsbGUgQ2VsbGVcIixcblx0XHRjZWxsU3RhdGlzdGljc1NuaXA6IFwiQ2FsY29sYSB1bmEgc3RhdGlzdGljYSBwZXIgY2VsbGEgZGEgcGnDuSByYXN0ZXIuIExlIHN0YXRpc3RpY2hlIGRpc3BvbmliaWxpIHNvbm8gTWFnZ2lvcmFuemEsIE1hc3NpbW8sIE1lZGlhLCBNZWRpYW5hLCBNaW5pbW8sIE1pbm9yYW56YSwgUGVyY2VudGlsZSwgSW50ZXJ2YWxsbywgRGV2aWF6aW9uZSBzdGFuZGFyZCwgU29tbWEgZSBWYXJpZXTDoC5cIixcblx0XHRjZWxsU3RhdGlzdGljc0Rlc2M6IFwiUXVlc3RhIGZ1bnppb25lIGNhbGNvbGEgc3RhdGlzdGljaGUgZGEgcGnDuSByYXN0ZXIgaW4gYmFzZSBhaSBzaW5nb2xpIHBpeGVsLiBMZSBzdGF0aXN0aWNoZSBkaXNwb25pYmlsaSBzb25vIG1hZ2dpb3JhbnphLCBtYXNzaW1vLCBtZWRpYSwgbWVkaWFuYSwgbWluaW1vLCBtaW5vcmFuemEsIGludGVydmFsbG8sIGRldmlhemlvbmUgc3RhbmRhcmQsIHNvbW1hIGUgdmFyaWV0w6AuXCIsXG5cdFx0Y2xhc3NpZnlOYW1lOiBcIkNsYXNzaWZpY2FcIixcblx0XHRjbGFzc2lmeVNuaXA6IFwiQXNzZWduYSBjaWFzY3VuIHBpeGVsIGEgdW5hIGNsYXNzZS4gSW5jb3Jwb3JhIGRhdGkgc2Vjb25kYXJpIGNvbWUgdW4naW1tYWdpbmUgc2VnbWVudGF0YS5cIixcblx0XHRjbGFzc2lmeURlc2M6IFwiUXVlc3RhIGZ1bnppb25lIHJhc3RlciBjbGFzc2lmaWNhIHVuIGRhdGFzZXQgcmFzdGVyIHN1bGxhIGJhc2UgZGkgdW4gZmlsZSBkaSBkZWZpbml6aW9uZSBkZWwgbWV0b2RvIGRpIGNsYXNzaWZpY2F6aW9uZSBkaSBFc3JpICguZWNkKSBlIGRlaSBkYXRpIGltbWVzc2kgcGVyIGlsIGRhdGFzZXQgcmFzdGVyLiBJbCBmaWxlIC5lY2QgdXNhdG8gbmVsbGEgZnVuemlvbmUgQ2xhc3NpZmljYSBjb250aWVuZSB0dXR0ZSBsZSBpbmZvcm1hemlvbmkgcmVsYXRpdmUgYSB1biBkYXRhc2V0IGUgYSB1biBjbGFzc2lmaWNhdG9yZSBzcGVjaWZpY2kgZWQgw6ggZ2VuZXJhdG8gZGFnbGkgc3RydW1lbnRpIGRpIGFkZGVzdHJhbWVudG8gYWxsYSBjbGFzc2lmaWNhemlvbmUsIGNvbWUgaWwgQ29tcHV0ZXIgVmV0dG9yZSBkaSBTdXBwb3J0byBhbGwnQWRkZXN0cmFtZW50byBvIGzigJlBZGRlc3RyYW1lbnRvIFN0cnV0dHVyZSBDYXN1YWxpLlwiLFxuXHRcdGNsaXBOYW1lOiBcIkNsaXBcIixcblx0XHRjbGlwU25pcDogXCJJbXBvc3RhIGwnZXN0ZW5zaW9uZSBkaSB1biByYXN0ZXIgdXRpbGl6emFuZG8gY29vcmRpbmF0ZSBvIHVuIGFsdHJvIGRhdGFzZXQuXCIsXG5cdFx0Y2xpcERlc2M6IFwiUXVlc3RhIGZ1bnppb25lIHJpdGFnbGlhIHVuIHJhc3RlciB1c2FuZG8gdW5hIGZvcm1hIHJldHRhbmdvbGFyZSBpbiBiYXNlIGFsbGUgZXN0ZW5zaW9uaSBkZWZpbml0ZSBvcHB1cmUgbG8gcml0YWdsaWEgaW4gYmFzZSBhbGxhIGZvcm1hIGRpIHVuYSBmZWF0dXJlIGNsYXNzIHBvbGlnb25hbGUgZGkgaW5wdXQuIExhIGZvcm1hIGNoZSBkZWZpbml0YSBkYWwgcml0YWdsaW8gcHXDsiBlc3NlcmUgaWwgcml0YWdsaW8gZGVsbCdlc3RlbnNpb25lIGRlbCByYXN0ZXIgbyBsJ2VzdHJhemlvbmUgZGkgdW4nYXJlYSBhbGwnaW50ZXJubyByYXN0ZXIuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25OYW1lOiBcIkNvbnZlcnNpb25lIG1vZGVsbG8gY29sb3JlXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25TbmlwOiBcIkNvbnZlcnRlIHVuIHJhc3RlciBkYSBSR0IgYSBIU1YgZSB2aWNldmVyc2EuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25EZXNjOiBcIkxhIGZ1bnppb25lIENvbnZlcnNpb25lIG1vZGVsbG8gY29sb3JlIGNvbnZlcnRlIGlsIG1vZGVsbG8gZGVsIGNvbG9yZSBkaSB1bidpbW1hZ2luZSBkYSB1bm8gc3BhemlvIGNvbG9yZSB0b25hbGl0w6AsIHNhdHVyYXppb25lIGUgdmFsb3JlIChIU1YpIGEgcm9zc28sIHZlcmRlIGUgYmx1IChSR0IpLCBvIHZpY2V2ZXJzYS48ZGl2Pjxici8+UXVlc3RhIGZ1bnppb25lIHB1w7IgZXNzZXJlIHVzYXRhIHNvbG8gaW4gdW4gTW9zYWljIERhdGFzZXQuPC9kaXY+XCIsXG5cdFx0Y29sb3JtYXBUb1JHQk5hbWU6IFwiRGEgbWFwcGEgY29sb3JpIGEgUkdCXCIsXG5cdFx0Y29sb3JtYXBUb1JHQlNuaXA6IFwiQ29udmVydGUgdW4gcmFzdGVyIGEgYmFuZGEgc2luZ29sYSBjb24gdW5hIG1hcHBhIGNvbG9yaSBpbiB1biByYXN0ZXIgYSB0cmUgYmFuZGUgKHJvc3NvLCB2ZXJkZSBlIGJsdSkuXCIsXG5cdFx0Y29sb3JtYXBUb1JHQkRlc2M6IFwiUXVlc3RhIGZ1bnppb25lIGNvbnZlcnRlIHVuIHJhc3RlciBhIGJhbmRhIHNpbmdvbGEgY29uIHVuYSBjb2xvcm1hcCBpbiB1biByYXN0ZXIgYSB0cmUgYmFuZGUgKHJvc3NvLCB2ZXJkZSBlIGJsdSkuPGRpdj48YnIvPlF1ZXN0YSBmdW56aW9uZSDDqCB1dGlsZSBxdWFuZG8gw6ggbmVjZXNzYXJpbyBjcmVhcmUgdW4gcmFzdGVyIGEgdHJlIGJhbmRlIGRhIHVuIHJhc3RlciBhIGJhbmRhIHNpbmdvbGEgY29uIHVuYSBjb2xvcm1hcCBhc3NvY2lhdGEuIEkgdmFsb3JpIGRlbGxhIGNvbG9ybWFwIHZlbmdvbm8gdXRpbGl6emF0aSBwZXIgY3JlYXJlIG9nbmkgYmFuZGEgZGVsIHJvc3NvLCB2ZXJkZSBlIGJsdS4gUXVlc3RhIGZ1bnppb25lIHB1w7IgZXNzZXJlIHVzYXRhIHNvbG8gaW4gdW4gTW9zYWljIERhdGFzZXQuPC9kaXY+XCIsXG5cdFx0Y29sb3JtYXBOYW1lOiBcIkNvbG9ybWFwXCIsXG5cdFx0Y29sb3JtYXBTbmlwOiBcIkNhbWJpYSBpIHZhbG9yaSBkZWkgcGl4ZWwgcGVyIHZpc3VhbGl6emFyZSBpIGRhdGkgcmFzdGVyIGNvbWUgc2NhbGEgZGkgZ3JpZ2kgbyBjb21lIGltbWFnaW5lIFJHQiAoUm9zc28sIFZlcmRlLCBCbHUpLCBpbiBiYXNlIGEgdW5hIG1hcHBhIGNvbG9yaSBvIHVuYSBzY2FsYSBjcm9tYXRpY2EuXCIsXG5cdFx0Y29sb3JtYXBEZXNjOiBcIkxhIGZ1bnppb25lIENvbG9ybWFwIMOoIHVuIHRpcG8gZGkgcmVuZGVyZXIgZGVpIGRhdGkgcmFzdGVyLiBUcmFzZm9ybWEgaSB2YWxvcmkgZGVpIHBpeGVsIHBlciB2aXN1YWxpenphcmUgaSBkYXRpIHJhc3RlciBjb21lIHVuYSBzY2FsYSBkaSBncmlnaSBvIGNvbWUgdW4naW1tYWdpbmUgYSBjb2xvcmkgUkdCIGJhc2F0YSBzdSB1bm8gc2NoZW1hIGRpIGNvbG9yaSBvIHN1IHNwZWNpZmljaSBjb2xvcmkgY29udGVudXRpIGluIHVuIGZpbGUgY29sb3JtYXAuIMOIIHBvc3NpYmlsZSB1c2FyZSB1bmEgY29sb3JtYXAgcGVyIHJhcHByZXNlbnRhcmUgaSBkYXRpIGFuYWxpenphdGksIGNvbWUgdW7igJlpbW1hZ2luZSBjbGFzc2lmaWNhdGEsIG8gcXVhbmRvIHNpIHZpc3VhbGl6emEgdW5hIG1hcHBhIHRvcG9ncmFmaWNhIChvIGzigJlpbW1hZ2luZSBkaSB1biBpbmRpY2UgZGlnaXRhbGl6emF0YSBhIGNvbG9yaSkuPGRpdj48YnIvPkxlIGNvbG9ybWFwIGNvbnRlbmdvbm8gdW4gaW5zaWVtZSBkaSB2YWxvcmkgYXNzb2NpYXRpIGFpIGNvbG9yaSwgdXNhdGkgcGVyIHZpc3VhbGl6emFyZSB1biByYXN0ZXIgYSBiYW5kYSBzaW5nb2xhIGluIG1vZG8gY29lcmVudGUgY29uIGdsaSBzdGVzc2kgY29sb3JpLiBJbCB2YWxvcmUgZGkgY2lhc2N1biBwaXhlbCDDqCBhc3NvY2lhdG8gYSB1biBjb2xvcmUsIGRlZmluaXRvIGNvbWUgdW4gaW5zaWVtZSBkaSB2YWxvcmkgUkdCLiBMZSBjb2xvcm1hcCBzb25vIGluIGdyYWRvIGRpIHN1cHBvcnRhcmUgcXVhbHNpYXNpIHByb2ZvbmRpdMOgIGJpdCBhIGVjY2V6aW9uZSBkaSBxdWVsbGUgYSB2aXJnb2xhIG1vYmlsZS4gSW5vbHRyZSwgc29ubyBjb21wYXRpYmlsaSBjb24gdmFsb3JpIHBvc2l0aXZpIGUgbmVnYXRpdmkgZSBwb3Nzb25vIGNvbnRlbmVyZSB2YWxvcmkgbWFwcGF0aSBtYW5jYW50aS4gUXVhbmRvIHNpIHZpc3VhbGl6emEgdW4gZGF0YXNldCBjb24gdW5hIGNvbG9ybWFwIGNvbnRlbmVudGUgdmFsb3JpIG1hbmNhbnRpLCBpIHBpeGVsIGNvbiBpIHZhbG9yaSBtYW5jYW50aSBub24gc2FyYW5ubyB2aXN1YWxpenphdGkuPC9kaXY+XCIsXG5cdFx0Y29tcGxleE5hbWU6IFwiQ29tcGxlc3NvXCIsXG5cdFx0Y29tcGxleFNuaXA6IFwiRXN0cmFlIGxhIGdyYW5kZXp6YSBkYSBudW1lcmkgY29tcGxlc3NpLlwiLFxuXHRcdGNvbXBsZXhEZXNjOiBcIlF1ZXN0YSBmdW56aW9uZSBjYWxjb2xhIGxhIGdyYW5kZXp6YSBkYSB2YWxvcmkgY29tcGxlc3NpLjxkaXY+PGJyLz5RdWVzdGEgZnVuemlvbmUgdmllbmUgaW4gZ2VuZXJlIHV0aWxpenphdGEgY29uIGltbWFnaW5pIFJBREFSIGNvbiB1biB0aXBvIGRpIGRhdGkgY29tcGxlc3NpLiBQdcOyIGVzc2VyZSB1c2F0YSBpbiB1biBtb3NhaWMgZGF0YXNldC48L2Rpdj5cIixcblx0XHRjb21wb3NpdGVCYW5kTmFtZTogXCJCYW5kZSBDb21wb3NpdGVcIixcblx0XHRjb21wb3NpdGVCYW5kU25pcDogXCJDb21iaW5hIHBpw7kgZGF0YXNldCBpbiB1biB1bmljbyByYXN0ZXIgbXVsdGliYW5kYS5cIixcblx0XHRjb21wb3NpdGVCYW5kRGVzYzogXCJMYSBmdW56aW9uZSBCYW5kZSBjb21wb3NpdGUgY29uc2VudGUgZGkgY29tYmluYXJlIHJhc3RlciBwZXIgZm9ybWFyZSB1buKAmWltbWFnaW5lIG11bHRpYmFuZGEuXCIsXG5cdFx0Y29uTmFtZTogXCJDb25cIixcblx0XHRjb25TbmlwOiBcIkVzZWd1ZSB1buKAmW9wZXJhemlvbmUgSWYsIFRoZW4sIEVsc2UgY29uZGl6aW9uYWxlLiBRdWFuZG8gc2kgdXRpbGl6emEgdW4gb3BlcmF0b3JlIENvbiwgb2Njb3Jyb25vIGluIGdlbmVyZSBkdWUgbyBwacO5IGZ1bnppb25pIGNvbmNhdGVuYXRlLCBpbiBjdWkgdW5hIGZ1bnppb25lIGFmZmVybWEgaSBjcml0ZXJpIGUgbGEgc2Vjb25kYSBmdW56aW9uZSDDqCBs4oCZb3BlcmF0b3JlIENvbiBjaGUgdXRpbGl6emEgaSBjcml0ZXJpIGUgaW5kaWNhIHF1YWxpIGRldm9ubyBlc3NlcmUgbGUgdXNjaXRlIHRydWUgZSBmYWxzZS5cIixcblx0XHRjb25EZXNjOiBcIkxhIGZ1bnppb25lIENvbiBpbXBvc3RhIGkgcGl4ZWwgZGVsIHJhc3RlciBkaSBvdXRwdXQgc3VsbGEgYmFzZSBkaSB1bmEgdmFsdXRhemlvbmUgaWZcXFxcZWxzZSBkaSBjaWFzY3VuIHBpeGVsIGRpIGlucHV0LiBSZXN0aXR1aXNjZSBpIHZhbG9yaSBkZWkgcGl4ZWwgZGFsIFRydWUgUmFzdGVyIHNlIGxhIHZhbHV0YXppb25lIGNvbmRpemlvbmFsZSDDqCB0cnVlICgxKTsgcmVzdGl0dWlzY2UgaSB2YWxvcmkgZGVpIHBpeGVsIGRhbCBGYWxzZSBSYXN0ZXIgc2UgbGEgdmFsdXRhemlvbmUgY29uZGl6aW9uYWxlIMOoIGZhbHNlICgwKS4gUXVlc3RvIGNyaXRlcmlvIMOoIHNwZWNpZmljYXRvIGRhbGwnb3V0cHV0IGRpIHVuYSBmdW56aW9uZSBtYXRlbWF0aWNhIGxvZ2ljYSwgY2hlIHNhcsOgIGlsIHJhc3RlciBkaSBpbnB1dC5cIixcblx0XHRjb25zdGFudE5hbWU6IFwiQ29zdGFudGVcIixcblx0XHRjb25zdGFudFNuaXA6IFwiQ3JlYSB1biByYXN0ZXIgdmlydHVhbGUgY29uIHVuIHZhbG9yZSBpbiBwaXhlbCBzaW5nb2xvLlwiLFxuXHRcdGNvbnN0YW50RGVzYzogXCJRdWVzdGEgZnVuemlvbmUgY3JlYSB1biByYXN0ZXIgdmlydHVhbGUgY29uIHVuIHZhbG9yZSBwaXhlbCBzaW5nb2xvIHV0aWxpenphYmlsZSBpbiBtb2RlbGxpIGRpIGZ1bnppb25lIHJhc3RlciBlIHBlciBlbGFib3JhcmUgdW4gbW9zYWljIGRhdGFzZXQuPGRpdj48YnIvPklsIHZhbG9yZSBjb3N0YW50ZSBzaSB1c2EgcGVyIG9nbmkgdmFsb3JlIHBpeGVsIG5lbCByYXN0ZXIuPC9kaXY+XCIsXG5cdFx0Y29udG91ck5hbWU6IFwiQ29udG91clwiLFxuXHRcdGNvbnRvdXJTbmlwOiBcIkNyZWEgbGluZWUgZGkgY29udG9ybm8uXCIsXG5cdFx0Y29udG91ckRlc2M6IFwiTGEgZnVuemlvbmUgQ29udG91ciBnZW5lcmEgbGluZWUgZGkgY29udG9ybm8gdW5lbmRvIHB1bnRpIGNvbiBsYSBzdGVzc2EgZWxldmF6aW9uZSBkYSB1biBkYXRhc2V0IGRpIGVsZXZhemlvbmUgcmFzdGVyLiBJIENvbnRvdXIgc29ubyBpc29saW5lZSBjcmVhdGUgY29tZSByYXN0ZXIgcGVyIGxhIHZpc3VhbGl6emF6aW9uZS4gUXVlc3RhIGZ1bnppb25lIMOoIHJlc2EgcG90ZW50ZSBkYWxsZSBzZWd1ZW50aSBmZWF0dXJlIGNoaWF2ZTogaSBDb250b3VyIHNvbm8gZ2VuZXJhdGkgcmFwaWRhbWVudGUgZSBkaW5hbWljYW1lbnRlIHN1IGRhdGFzZXQgbW9sdG8gZ3JhbmRpLCBjb21lIEVsZXZhemlvbmUgbW9uZGlhbGU7IGkgQ29udG91ciBwb3Nzb25vIGVzc2VyZSBzbXVzc2F0aSBwZXIgZm9ybmlyZSB1biBhc3BldHRvIGNhcnRvZ3JhZmljbyBwacO5IGdyYWRldm9sZSBtYW50ZW5lbmRvbmUgYWwgY29udGVtcG8gbGEgcHJlY2lzaW9uZTsgc2kgZGlzcG9uZSBkZWwgY29udHJvbGxvIGRpbmFtaWNvIGRlbGwnaW50ZXJ2YWxsbyBkZWkgQ29udG91cjsgbGUgb3B6aW9uaSBkaSBvdXRwdXQgaW5jbHVkb25vIGxpbmVlIGRpIENvbnRvdXIsIENvbnRvdXIgZGkgaW5kaWNlIGUgQ29udG91ciByaWVtcGl0aS48ZGl2Pjxici8+TGEgY3JlYXppb25lIGRpIHVuIENvbnRvdXIgTGF5ZXIgY29tZSBwcm9kb3R0byByYXN0ZXIgw6ggaW1wb3J0YW50ZSBwZXIgdW4gYW1waW8gc3BldHRybyBkaSBhcHBsaWNhemlvbmkgcGVyY2jDqSBpIGNvbnRvcm5pIHBvc3Nvbm8gZXNzZXJlIHNvdnJhcHBvc3RpIHN1IHVuYSBtYXBwYSBlIGZvcm5pcmUgaW5mb3JtYXppb25pIHN1bCBzdW9sbyBzZW56YSBvc2N1cmFyZSBpIGRhdGkgc290dG9zdGFudGkuIFNvbm8gdXRpbGkgaW4gYXBwbGljYXppb25pIGNvbWUgYXBwbGljYXppb25pIGRpIGluZ2VnbmVyaWEsIGFncmljb2x0dXJhIGUgZ2VzdGlvbmUgaWRyaWNhLjwvZGl2PlwiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc05hbWU6IFwiQ29udHJhc3RvIGUgbHVtaW5vc2l0w6BcIixcblx0XHRjb250cmFzdEJyaWdodG5lc3NTbmlwOiBcIlJlZ29sYSBpbCBjb250cmFzdG8gZSBsYSBsdW1pbm9zaXTDoCBkaSB1biByYXN0ZXIuXCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzRGVzYzogXCJMYSBmdW56aW9uZSBDb250cmFzdG8gZSBsdW1pbm9zaXTDoCBtaWdsaW9yYSBs4oCZYXNwZXR0byBkZWkgZGF0aSByYXN0ZXIgbW9kaWZpY2FuZG8gbGEgbHVtaW5vc2l0w6AgbyBpbCBjb250cmFzdG8gbmVsbOKAmWltbWFnaW5lLiBMYSBsdW1pbm9zaXTDoCBhdW1lbnRhIGxhIGNoaWFyZXp6YSBjb21wbGVzc2l2YSBkZWxsJ2ltbWFnaW5l4oCUYWQgZXNlbXBpbywgcmVuZGVuZG8gaSBjb2xvcmkgc2N1cmkgcGnDuSBjaGlhcmkgZSBpIGNvbG9yaSBjaGlhcmkgcGnDuSBiaWFuY2hp4oCUbWVudHJlIGlsIGNvbnRyYXN0byByZWdvbGEgbGEgZGlmZmVyZW56YSB0cmEgaSBjb2xvcmkgcGnDuSBzY3VyaSBlIHF1ZWxsaSBwacO5IGNoaWFyaS48ZGl2Pjxici8+TCd1c28gZGkgcXVlc3RhIGZ1bnppb25lIGFsdGVyYSBpIHZhbG9yaSBkZWkgcGl4ZWw7IHBlciBxdWVzdG8gbW90aXZvLCBsYSBmdW56aW9uZSBkZXZlIGVzc2VyZSB1dGlsaXp6YXRhIHF1YW5kbyBzaSBkZXNpZGVyYSBtaWdsaW9yYXJlIGwnYXNwZXR0byBkZWkgZGF0aSwgbWEgbm9uIHNlIHNpIGludGVuZGUgdXRpbGl6emFyZSBpIGRhdGkgY29tZSBwYXJ0ZSBkaSB1bidhbmFsaXNpIGNoZSByaWNoaWVkZXJlYmJlIHZhbG9yaSBkZWkgcGl4ZWwgbm9uIGVsYWJvcmF0aS4gUXVlc3RhIGZ1bnppb25lIMOoIHV0aWxlIHF1YW5kbyBpIGRhdGkgdmVuZ29ubyBwdWJibGljYXRpIGNvbWUgaW1hZ2Ugc2VydmljZSB1dGlsaXp6YWJpbGkgbmVsbGUgYXBwbGljYXppb25pIHNlbnphIGxhIHBvc3NpYmlsaXTDoCBkaSBhbHRlcmFyZSBpbCBjb250cmFzdG8gZSBsYSBsdW1pbm9zaXTDoCBkZWxsZSBpbW1hZ2luaSwgbyBwZXIgZ2FyYW50aXJlIGNoZSBsZSBpbW1hZ2luaSB2ZW5nYW5vIHZpc3VhbGl6emF0ZSB1dGlsaXp6YW5kbyBsZSBpbXBvc3RhemlvbmkgcHJlZGVmaW5pdGUuPC9kaXY+XCIsXG5cdFx0Y29udm9sdXRpb25OYW1lOiBcIkNvbnZvbHV6aW9uZVwiLFxuXHRcdGNvbnZvbHV0aW9uU25pcDogXCJBcHBsaWNhIHVuIGZpbHRybyBwZXIgcmVuZGVyZSBwacO5IG5pdGlkbywgc2ZvY2FyZSwgcmlsZXZhcmUgYm9yZGksIHNtdXNzYXJlIG8gdW4gZ3JhZGllbnRlIHN1IHVuIHJhc3Rlci5cIixcblx0XHRjb252b2x1dGlvbkRlc2M6IFwiTGEgZnVuemlvbmUgQ29udm9sdXppb25lIGFwcGxpY2EgdW4gZmlsdHJvIGJhc2F0byBzdWkgdmFsb3JpIGRlaSBwaXhlbCBpbiB1buKAmWltbWFnaW5lLCBjaGUgcHXDsiBlc3NlcmUgdXRpbGl6emF0byBwZXIgZXNlZ3VpcmUgbG8gc2hhcnBlbmluZyBvIGxhIHNmb2NhdHVyYSBkaSB1buKAmWltbWFnaW5lLCByaWxldmFyZSBnbGkgZWRnZSBhbGwnaW50ZXJubyBkaSB1buKAmWltbWFnaW5lIG8gYXBwb3J0YXJlIGFsdHJpIG1pZ2xpb3JhbWVudGkgYmFzYXRpIHN1bCBrZXJuZWwuIEkgZmlsdHJpIHZlbmdvbm8gdXRpbGl6emF0aSBwZXIgbWlnbGlvcmFyZSBsYSBxdWFsaXTDoCBkZWxsJ2ltbWFnaW5lIHJhc3RlciBlbGltaW5hbmRvIGkgZGF0aSBzcHVyaSBvIG1pZ2xpb3JhbmRvIGxlIGZlYXR1cmUgbmVpIGRhdGkuIEkgZmlsdHJpIGRpIGNvbnZvbHV6aW9uZSB2ZW5nb25vIGFwcGxpY2F0aSBzdSB1biBrZXJuZWwgbW9iaWxlIHNvdnJhcHBvc3RvIChmaW5lc3RyYSBvIHZpY2luYW56YSksIGFkIGVzZW1waW8gMyBwZXIgMy4gSSBmaWx0cmkgZGkgY29udm9sdXppb25lIGZ1bnppb25hbm8gY2FsY29sYW5kbyBpbCB2YWxvcmUgZGVsIHBpeGVsIGluIGJhc2UgYWkgcGVzaSBkaSBxdWVsbGkgdmljaW5pLlwiLFxuXHRcdGNvcnJpZG9yTmFtZTogXCJDb3JyaWRvclwiLFxuXHRcdGNvcnJpZG9yU25pcDogXCJDYWxjb2xhIGxhIHNvbW1hIGRlaSBjb3N0aSBjdW11bGF0aXZpIHBlciBkdWUgcmFzdGVyIGRpIGNvc3RvIGN1bXVsYXRpdm8gZGkgaW5wdXQuXCIsXG5cdFx0Y29ycmlkb3JEZXNjOiBcIkxhIGZ1bnppb25lIENvcnJpZG9yIGNhbGNvbGEgbGEgc29tbWEgZGVpIGNvc3RpIGN1bXVsYXRpdmkgcGVyIGR1ZSByYXN0ZXIgZGkgY29zdG8gY3VtdWxhdGl2byBkaSBpbnB1dC4gU2ViYmVuZSBzaWEgcG9zc2liaWxlIHVzYXJlIGR1ZSByYXN0ZXIgcXVhbHNpYXNpIHBlciBs4oCZaW5wdXQsIHBlciBvdHRlbmVyZSB1biByaXN1bHRhdG8gc2lnbmlmaWNhdGl2byBzaSBkb3ZyZWJiZXJvIHVzYXJlIHJhc3RlciBkaSBjb3N0byBjdW11bGF0aXZvIGRpIG91dHB1dCBpbmFsdGVyYXRpLiBM4oCZb3JkaW5lIGRlaSBkdWUgcmFzdGVyIGRpIGlucHV0IG5vbiDDqCByaWxldmFudGUuXCIsXG5cdFx0Y29zSE5hbWU6IFwiQ29zSFwiLFxuXHRcdGNvc0hTbmlwOiBcIkNhbGNvbGEgaWwgY29zZW5vIGlwZXJib2xpY28gZGkgY2VsbGUgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdGNvc0hEZXNjOiBcIkxhIGZ1bnppb25lIGNhbGNvbGEgaWwgY29zZW5vIGlwZXJib2xpY28gZGVpIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRjb3NOYW1lOiBcIkNvc1wiLFxuXHRcdGNvc1NuaXA6IFwiQ2FsY29sYSBpbCBjb3Nlbm8gZGkgdW5hIGNlbGxhIGluIHVuIHJhc3Rlci5cIixcblx0XHRjb3NEZXNjOiBcIkxhIGZ1bnppb25lIGNhbGNvbGEgaWwgY29zZW5vIGRlaSBwaXhlbCBpbiB1biByYXN0ZXIuXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25OYW1lOiBcIkFzc2VnbmF6aW9uZSBjb3N0aVwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uU25pcDogXCJDYWxjb2xhIHBlciBvZ25pIGNlbGxhIGwnb3JpZ2luZSBwacO5IGVjb25vbWljYSBpbiBiYXNlIGFsIG1pbm9yIGNvc3RvIGN1bXVsYXRpdm8gc3UgdW5hIHN1cGVyZmljaWUgZGkgY29zdG8uXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25EZXNjOiBcIkxhIGZ1bnppb25lIEFzc2VnbmF6aW9uZSBjb3N0aSBjYWxjb2xhLCBwZXIgb2duaSBjZWxsYSwgbCdvcmlnaW5lIHBpw7kgZWNvbm9taWNhIGluIGJhc2UgYWwgbWlub3IgY29zdG8gY3VtdWxhdGl2byBzdSB1bmEgc3VwZXJmaWNpZSBkaSBjb3N0by5cIixcblx0XHRjb3N0QmFja0xpbmtOYW1lOiBcIkJhY2sgTGluayBDb3N0aVwiLFxuXHRcdGNvc3RCYWNrTGlua1NuaXA6IFwiRGVmaW5pc2NlIGwnZWxlbWVudG8gdmljaW5vIGNoZSBjb3JyaXNwb25kZSBhbGxhIGNlbGxhIHN1Y2Nlc3NpdmEgbmVsIHBlcmNvcnNvIGRpIGNvc3RvIGN1bXVsYXRpdm8gbWlub3JlIHBlciBsJ29yaWdpbmUgZGFsIGNvc3RvIG1pbmltby5cIixcblx0XHRjb3N0QmFja0xpbmtEZXNjOiBcIkxhIGZ1bnppb25lIEJhY2tsaW5rIGRpIGNvc3RvIGRlZmluaXNjZSBsJ2VsZW1lbnRvIHZpY2lubyBjaGUgw6ggbGEgY2VsbGEgc3VjY2Vzc2l2YSBuZWwgcGVyY29yc28gZGkgY29zdG8gY3VtdWxhdGl2byBtaW5vcmUgcGVyIGwnb3JpZ2luZSBwacO5IGVjb25vbWljYS48ZGl2Pjxici8+SWwgcmFzdGVyIGJhY2tsaW5rIGNvbnRpZW5lIHZhbG9yaSBjb21wcmVzaSB0cmEgemVybyBlIG90dG8sIGNoZSBkZWZpbmlzY29ubyBsYSBkaXJlemlvbmUgbyBpZGVudGlmaWNhbm8gbGEgc3VjY2Vzc2l2YSBjZWxsYSBhZGlhY2VudGUgKGxhIGNlbGxhIHN1Y2Nlc3NpdmEpIGx1bmdvIGlsIHBlcmNvcnNvIGRpIGNvc3RvIGN1bXVsYXRpdm8gbWlub3JlIGRhIHVuYSBjZWxsYSBwZXIgcmFnZ2l1bmdlcmUgbCdvcmlnaW5lIHBpw7kgZWNvbm9taWNhLiBTZSBpbCBwZXJjb3JzbyBkZXZlIHBhc3NhcmUgbmVsbCdhZGlhY2VudGUgZGVzdHJhLCBhbGxhIGNlbGxhIHZlcnLDoCBhc3NlZ25hdG8gaWwgdmFsb3JlIDEsIDIgcGVyIGxhIGNlbGxhIGRpYWdvbmFsZSBpbiBiYXNzbyBhIGRlc3RyYSBlIHByb3NlZ3VlbmRvIGluIHNlbnNvIG9yYXJpby4gSWwgdmFsb3JlIDAgw6ggcmlzZXJ2YXRvIGFsbGUgY2VsbGUgZGkgb3JpZ2luZS48L2Rpdj5cIixcblx0XHRjb3N0RGlzdGFuY2VOYW1lOiBcIkRpc3RhbnphIGNvc3RpXCIsXG5cdFx0Y29zdERpc3RhbmNlU25pcDogXCJDYWxjb2xhIGxhIGRpc3RhbnphIGRpIGNvc3RvIGN1bXVsYXRpdm8gbWlub3JlIHBlciBvZ25pIGNlbGxhIGRhIG8gdmVyc28gbCdvcmlnaW5lIHBpw7kgZWNvbm9taWNhIHN1IHVuYSBzdXBlcmZpY2llIGRpIGNvc3RvLlwiLFxuXHRcdGNvc3REaXN0YW5jZURlc2M6IFwiTGEgZnVuemlvbmUgRGlzdGFuemEgZGkgY29zdG8gY2FsY29sYSBsYSBkaXN0YW56YSBkaSBjb3N0byBjdW11bGF0aXZvIG1pbm9yZSBwZXIgb2duaSBjZWxsYSBkYSBvIHZlcnNvIGwnb3JpZ2luZSBwacO5IGVjb25vbWljYSBzdSB1bmEgc3VwZXJmaWNpZSBkaSBjb3N0by5cIixcblx0XHRjb3N0UGF0aE5hbWU6IFwiUGVyY29yc28gY29zdGlcIixcblx0XHRjb3N0UGF0aFNuaXA6IFwiQ2FsY29sYSBpbCBwZXJjb3JzbyBkaSBjb3N0byBtaW5pbW8gZGEgdW4nb3JpZ2luZSBhIHVuYSBkZXN0aW5hemlvbmUuXCIsXG5cdFx0Y29zdFBhdGhEZXNjOiBcIkxhIGZ1bnppb25lIGdsb2JhbGUgUGVyY29yc28gZGkgY29zdG8gY2FsY29sYSBpbCBwZXJjb3JzbyBkaSBjb3N0byBpbmZlcmlvcmUgZGEgdW4nb3JpZ2luZSBhIHVuYSBkZXN0aW5hemlvbmUuPGRpdj48YnIvPlF1ZXN0YSBmdW56aW9uZSBwcm9kdWNlIHVuIHJhc3RlciBkaSBvdXRwdXQgY2hlIHJlZ2lzdHJhIGlsIHBlcmNvcnNvIG8gaSBwZXJjb3JzaSBtZW5vIGNvc3Rvc2ksIGRhbGxlIHBvc2l6aW9uaSBzZWxlemlvbmF0ZSBhbGxhIGNlbGxhIGRpIG9yaWdpbmUgcGnDuSB2aWNpbmEgZGVmaW5pdGEgbmVsbGEgc3VwZXJmaWNpZSBkaSBjb3N0byBjdW11bGF0aXZvLCBpbiB0ZXJtaW5pIGRpIGRpc3RhbnphIGRpIGNvc3RvLjwvZGl2PlwiLFxuXHRcdGN1cnZhdHVyZU5hbWU6IFwiQ3VydmF0dXJhXCIsXG5cdFx0Y3VydmF0dXJlU25pcDogXCJDYWxjb2xhIGxhIGN1cnZhdHVyYSBkaSB1bmEgc3VwZXJmaWNpZSByYXN0ZXIsIGluY2x1ZGVuZG8gZmFjb2x0YXRpdmFtZW50ZSBwcm9maWxvIGUgY3VydmF0dXJhIHBpYW5vLlwiLFxuXHRcdGN1cnZhdHVyZURlc2M6IFwiTGEgZnVuemlvbmUgQ3VydmF0dXJhIHZpc3VhbGl6emEgbGEgZm9ybWEgbyBsYSBjdXJ2YXR1cmEgZGVsbGEgcGVuZGVuemEuIFVuYSBzdXBlcmZpY2llIHB1w7IgYXZlcmUgdW5hIHBhcnRlIGNvbmNhdmEgbyBjb252ZXNzYTsgY2nDsiDDqCByaWNvbm9zY2liaWxlIG9zc2VydmFuZG8gaWwgdmFsb3JlIGRpIGN1cnZhdHVyYS4gTGEgY3VydmF0dXJhIHZpZW5lIGNhbGNvbGF0YSBjb21wdXRhbmRvIGxhIHNlY29uZGEgZGVyaXZhdGEgZGVsbGEgc3VwZXJmaWNpZS48ZGl2Pjxici8+TCdvdXRwdXQgZGVsbGEgZnVuemlvbmUgQ3VydmF0dXJhIHB1w7IgZXNzZXJlIHVzYXRvIHBlciBkZXNjcml2ZXJlIGxlIGNhcmF0dGVyaXN0aWNoZSBmaXNpY2hlIGRpIHVuIGJhY2lubyBkaSBkcmVuYWdnaW8gbmVsIHRlbnRhdGl2byBkaSBjb21wcmVuZGVyZSBpIHByb2Nlc3NpIGRpIGVyb3Npb25lIGUgcnVzY2VsbGFtZW50by4gSWwgdmFsb3JlIGRpIGN1cnZhdHVyYSBwdcOyIGVzc2VyZSB1c2F0byBwZXIgaW5kaXZpZHVhcmUgbW9kZWxsaSBkaSBlcm9zaW9uZSBkZWwgc3VvbG8gbm9uY2jDqSBsYSBkaXN0cmlidXppb25lIGRlbGwnYWNxdWEgbmVsIHRlcnJlbm8uIExhIGN1cnZhdHVyYSBkZWwgcHJvZmlsbyBpbmZsdWVuemEgbCdhY2NlbGVyYXppb25lIGUgbGEgZGVjZWxlcmF6aW9uZSBkZWkgZmx1c3NpIGUsIHF1aW5kaSwgYW5jaGUgbCdlcm9zaW9uZSBlIGxhIGRlcG9zaXppb25lLiBMYSBjdXJ2YXR1cmEgZGVsbGEgc3VwZXJmaWNpZSBhbGFyZSBpbmZsdWVuemEgbGEgY29udmVyZ2VuemEgZSBsYSBkaXZlcmdlbnphIGRlaSBmbHVzc2kuPC9kaXY+XCIsXG5cdFx0ZGl2aWRlTmFtZTogXCJEaXZpZGVcIixcblx0XHRkaXZpZGVTbmlwOiBcIkRpdmlkZSBpIHZhbG9yaSBkaSBkdWUgcmFzdGVyIGluIGJhc2UgYWxsZSBzaW5nb2xlIGNlbGxlLlwiLFxuXHRcdGRpdmlkZURlc2M6IFwiTGEgZnVuemlvbmUgRGl2aWRpIGRpdmlkZSBpIHZhbG9yaSBkaSBkdWUgcmFzdGVyIGluIGJhc2UgYWkgc2luZ29saSBwaXhlbC5cIixcblx0XHRlbGV2YXRpb25Wb2lkRmlsbE5hbWU6IFwiUmllbXBpbWVudG8gdnVvdGkgZGkgZWxldmF6aW9uZVwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsU25pcDogXCJDcmVhIHBpeGVsIGRvdmUgZXNpc3Rvbm8gYnVjaGkgbmVpIGRhdGkgZGkgZWxldmF6aW9uZS5cIixcblx0XHRlbGV2YXRpb25Wb2lkRmlsbERlc2M6IFwiTGEgZnVuemlvbmUgUmllbXBpbWVudG8gdnVvdGkgZGkgZWxldmF6aW9uZSB2aWVuZSB1c2F0YSBwZXIgY3JlYXJlIHBpeGVsIGRvdmUgZXNpc3Rvbm8gc3BhemkgdnVvdGkgbmVsbCdlbGV2YXppb25lLjxkaXY+PGJyLz5JIHZ1b3RpIHNpIHZlcmlmaWNhbm8gcXVhbmRvIG5vbiBjaSBzb25vIHB1bnRpIHJhY2NvbHRpIGVudHJvIGwnYXJlYSByYXBwcmVzZW50YXRhIGRhIHVuIHBpeGVsIG5lbCByYXN0ZXIgcmlzdWx0YW50ZS4gSSB2dW90aSBzb25vIHNwZXNzbyBjYXVzYXRpIGRhIGNvcnBpIGlkcmljaSwgc2VsZXppb25lIGRpIHRpcGkgZGkgY2xhc3NlIG8gZXNjbHVzaW9uZS4gSWwgcmllbXBpbWVudG8gZGVsIHZ1b3RvIMOoIGdlbmVyYWxtZW50ZSB1c2F0byBxdWFuZG8gc2kgZ2VuZXJhIHVuYSBzdXBlcmZpY2llIGRpIHRlcnJhLjwvZGl2PlwiLFxuXHRcdGVxdWFsVG9OYW1lOiBcIkVxdWFsIFRvXCIsXG5cdFx0ZXF1YWxUb1NuaXA6IFwiRXNlZ3VlIHVuJ29wZXJhemlvbmUgcmVsYXppb25hbGUgdWd1YWxlLWEgc3UgZHVlIGlucHV0IGluIGJhc2UgYWxsZSBzaW5nb2xlIGNlbGxlLiBSZXN0aXR1aXNjZSAxIHBlciBsZSBjZWxsZSBpbiBjdWkgaWwgcHJpbW8gcmFzdGVyIMOoIHVndWFsZSBhbCBzZWNvbmRvIHJhc3RlciBlIDAgcGVyIGxlIGNlbGxlIGluIGN1aSDDqCBkaXZlcnNvLlwiLFxuXHRcdGVxdWFsVG9EZXNjOiBcIkxhIGZ1bnppb25lIGVzZWd1ZSB1bidvcGVyYXppb25lIHVndWFsZS1hIHN1IGR1ZSByYXN0ZXIgaW4gYmFzZSBhaSBzaW5nb2xpIHBpeGVsLiBSZXN0aXR1aXNjZSBpbCB2YWxvcmUgMSBwZXIgaSBwaXhlbCBpbiBjdWkgaWwgcHJpbW8gcmFzdGVyIMOoIHVndWFsZSBhbCBzZWNvbmRvIHJhc3RlciBlIGlsIHZhbG9yZSAwIHBlciBpIHBpeGVsIGluIGN1aSBzb25vIGRpdmVyc2kuXCIsXG5cdFx0ZXVjQWxsb2NhdGlvbk5hbWU6IFwiQXNzZWduYXppb25lIGV1Y2xpZGVhXCIsXG5cdFx0ZXVjQWxsb2NhdGlvblNuaXA6IFwiQ2FsY29sYSBwZXIgb2duaSBjZWxsYSBsJ29yaWdpbmUgcGnDuSB2aWNpbmEgaW4gYmFzZSBhbGxhIGRpc3RhbnphIGV1Y2xpZGVhLlwiLFxuXHRcdGV1Y0FsbG9jYXRpb25EZXNjOiBcIkxhIGZ1bnppb25lIEFzc2VnbmF6aW9uZSBldWNsaWRlYSBjYWxjb2xhIHBlciBvZ25pIGNlbGxhIGwnb3JpZ2luZSBwacO5IHZpY2luYSBpbiBiYXNlIGFsbGEgZGlzdGFuemEgZXVjbGlkZWEuXCIsXG5cdFx0ZXVjRGlyZWN0aW9uTmFtZTogXCJEaXJlemlvbmUgZXVjbGlkZWFcIixcblx0XHRldWNEaXJlY3Rpb25TbmlwOiBcIkNhbGNvbGEgcGVyIG9nbmkgY2VsbGEgbGEgZGlyZXppb25lIGluIGdyYWRpIHJpc3BldHRvIGFsbCdvcmlnaW5lIHBpw7kgdmljaW5hLlwiLFxuXHRcdGV1Y0RpcmVjdGlvbkRlc2M6IFwiTGEgZnVuemlvbmUgRGlyZXppb25lIGV1Y2xpZGVhIGNhbGNvbGEgcGVyIG9nbmkgY2VsbGEgbGEgZGlyZXppb25lIGluIGdyYWRpIHJpc3BldHRvIGFsbCdvcmlnaW5lIHBpw7kgdmljaW5hLiA8ZGl2Pjxici8+SWwgY2FsY29sbyBkZWxsYSBkaXJlemlvbmUgdmllbmUgZXNlZ3VpdG8gZGFsIGNlbnRybyBkaSBjaWFzY3VuYSBjZWxsYSBhbCBjZW50cm8gZGVsbGEgY2VsbGEgZGkgb3JpZ2luZSBwacO5IHZpY2luYS4gTCdpbnRlcnZhbGxvIGRpIHZhbG9yaSDDqCBjb21wcmVzbyB0cmEgMCBncmFkaSBlIDM2MCBncmFkaSwgY29uIDAgcmlzZXJ2YXRvIHBlciBsZSBjZWxsZSBkaSBvcmlnaW5lLiBWZXJzbyBlc3QgKGRlc3RyYSkgw6ggZGkgOTAgZSBpIHZhbG9yaSBhdW1lbnRhbm8gaW4gc2Vuc28gb3JhcmlvICgxODAgw6ggc3VkLCAyNzAgw6ggb3Zlc3QgZSAzNjAgw6ggbm9yZCkuPC9kaXY+XCIsXG5cdFx0ZXVjRGlzdGFuY2VOYW1lOiBcIkRpc3RhbnphIGV1Y2xpZGVhXCIsXG5cdFx0ZXVjRGlzdGFuY2VTbmlwOiBcIkNhbGNvbGEgcGVyIG9nbmkgY2VsbGEgbGEgZGlzdGFuemEgZXVjbGlkZWEgZGFsbCdvcmlnaW5lIHBpw7kgdmljaW5hLlwiLFxuXHRcdGV1Y0Rpc3RhbmNlRGVzYzogXCJMYSBmdW56aW9uZSBEaXN0YW56YSBldWNsaWRlYSBjYWxjb2xhIHBlciBvZ25pIGNlbGxhIGxhIGRpc3RhbnphIGV1Y2xpZGVhIGRhbGwnb3JpZ2luZSBwacO5IHZpY2luYS5cIixcblx0XHRleHAxME5hbWU6IFwiRXhwMTBcIixcblx0XHRleHAxMFNuaXA6IFwiQ2FsY29sYSBsJ2VzcG9uZW50ZSBpbiBiYXNlIDEwIGRlbGxlIGNlbGxlIGluIHVuIHJhc3Rlci5cIixcblx0XHRleHAxMERlc2M6IFwiTGEgZnVuemlvbmUgRXhwIDEwIGNhbGNvbGEgbCdlc3BvbmVudGUgaW4gYmFzZSAxMCBkZWkgcGl4ZWwgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdGV4cDJOYW1lOiBcIkV4cDJcIixcblx0XHRleHAyU25pcDogXCJDYWxjb2xhIGwnZXNwb25lbnRlIGluIGJhc2UgMiBkZWxsZSBjZWxsZSBpbiB1biByYXN0ZXIuXCIsXG5cdFx0ZXhwMkRlc2M6IFwiTGEgZnVuemlvbmUgY2FsY29sYSBsJ2VzcG9uZW50ZSBpbiBiYXNlIDIgZGVpIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRleHBOYW1lOiBcIkV4cFwiLFxuXHRcdGV4cFNuaXA6IFwiQ2FsY29sYSBsJ2VzcG9uZW50ZSBpbiBiYXNlIGUgZGVsbGUgY2VsbGUgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdGV4cERlc2M6IFwiUXVlc3RhIGZ1bnppb25lIGNhbGNvbGEgbCdlc3BvbmVudGUgaW4gYmFzZSBlIGRlaSBwaXhlbCBpbiB1biByYXN0ZXIuXCIsXG5cdFx0ZXh0cmFjdEJhbmROYW1lOiBcIkVzdHJhaSBiYW5kZVwiLFxuXHRcdGV4dHJhY3RCYW5kU25pcDogXCJTcGVjaWZpY2EgcXVhbGkgYmFuZGUgdXRpbGl6emFyZSBkdXJhbnRlIGwndXNvIGRpIGRhdGFzZXQgbXVsdGliYW5kYS5cIixcblx0XHRleHRyYWN0QmFuZERlc2M6IFwiIExhIGZ1bnppb25lIEVzdHJhaSBiYW5kZSBjb25zZW50ZSBkaSBlc3RyYXJyZSB1bmEgbyBwacO5IGJhbmRlLCBvIGRpIHJpb3JkaW5hcmxlLCBkYSB1biBkYXRhc2V0IHJhc3RlciBtdWx0aWJhbmRhLjxkaXY+PGJyLz5MYSBmdW56aW9uZSBFc3RyYWkgYmFuZGUgcHXDsiBlc3NlcmUgdXNhdGEgcHJpbWEgZGkgYWx0cmUgZnVuemlvbmksIGNvbWUgQXJpdG1ldGljYSwgcGVyIHZlcmlmaWNhcmUgcXVhbGkgYmFuZGUgdmVuZ29ubyB1c2F0ZSBjb21lIGlucHV0IG5lbGxhIGZ1bnppb25lIHN1Y2Nlc3NpdmEuPC9kaXY+XCIsXG5cdFx0ZmlsbE5hbWU6IFwiQ29tcGlsYVwiLFxuXHRcdGZpbGxTbmlwOiBcIlJpZW1waWUgaSBzaW5rIGluIHVuIHJhc3RlciBzdXBlcmZpY2llIHBlciByaW11b3ZlcmUgcGljY29sZSBpbXBlcmZlemlvbmkgbmVpIGRhdGkuXCIsXG5cdFx0ZmlsbERlc2M6IFwiTGEgZnVuemlvbmUgZ2xvYmFsZSBSaWVtcGkgaW5kaXZpZHVhIGUgcmllbXBpZSBpIHNpbmsgZSBsZSB2ZXR0ZSBpbiB1biByYXN0ZXIgZGkgZWxldmF6aW9uZSBwZXIgcmltdW92ZXJlIHBpY2NvbGUgaW1wZXJmZXppb25pIG5laSBkYXRpLiBMYSBmdW56aW9uZSBlc2VndWlyw6AgdW4gcHJvY2Vzc28gaXRlcmF0aXZvIGRpIHJpZW1waW1lbnRvIGZpbm8gYSBxdWFuZG8gdHV0dGkgaSBzaW5rIHNhcmFubm8gc3RhdGkgcmllbXBpdGkgZW50cm8gaWwgbGltaXRlIFogc3BlY2lmaWNhdG8uPGRpdj48YnIvPlF1YW5kbyB2aWVuZSBjcmVhdGEgdW5hIHN1cGVyZmljaWUgZGkgZWxldmF6aW9uZSBjb24gc3RydW1lbnRpIGNvbWUgT3J0aG8gTWFwcGluZyBvIGNvbiBhbHRyaSBtZXp6aSwgaSBkYXRpIGNvbnRlbmdvbm8gc3Blc3NvIGVycm9yaSBwaWNjb2xpIG1hIHNpZ25pZmljYXRpdmkgbmVsbGEgZm9ybWEgZGVpIHNpbmsgZSBkZWxsZSB2ZXR0ZS4gSW4gZm90b2dyYW1tZXRyaWEsIHNpbmsgZSB2ZXR0ZSBzb25vIHNwZXNzbyBpbmRpY2F0aSBjb21lIHNwYXppIHZ1b3RpIGUgcGljY2hpLiBJIGRhdGkgZGkgc3VwZXJmaWNpZSBzb25vIHNwZXNzbyB1c2F0aSBpbiBtb2RlbGxhemlvbmUsIGNvbWUgbmVsbGEgbW9kZWxsYXppb25lIGlkcm9sb2dpY2EsIHBlcnRhbnRvIMOoIGltcG9ydGFudGUgY29ycmVnZ2VyZSBxdWVzdG8gdGlwbyBkaSBlcnJvcmkgYSBsaXZlbGxvIGRpIHNpbmsgZSB2ZXR0ZSBpbiBtb2RvIGNvZXJlbnRlIGNvbiBpIGRhdGkgY2lyY29zdGFudGkuPC9kaXY+XCIsXG5cdFx0ZmxvYXROYW1lOiBcIkZsb2F0XCIsXG5cdFx0ZmxvYXRTbmlwOiBcIkNvbnZlcnRlIHR1dHRpIGkgdmFsb3JpIGRlbGxlIGNlbGxlIGRpIHVuIHJhc3RlciBpbiB1bmEgcmFwcHJlc2VudGF6aW9uZSBhIHZpcmdvbGEgbW9iaWxlLlwiLFxuXHRcdGZsb2F0RGVzYzogXCJMYSBmdW56aW9uZSBGbG9hdCBjb252ZXJ0ZSB0dXR0aSBpIHZhbG9yaSBkZWkgcGl4ZWwgZGkgdW4gcmFzdGVyIGluIHVuYSByYXBwcmVzZW50YXppb25lIGEgdmlyZ29sYSBtb2JpbGUuXCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvbk5hbWU6IFwiQWNjdW11bG8gZGVsIEZsdXNzb1wiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25TbmlwOiBcIkNyZWEgdW4gcmFzdGVyIGRlbCBmbHVzc28gYWNjdW11bGF0byBpbiBvZ25pIGNlbGxhLiDDiCBwb3NzaWJpbGUgYXBwbGljYXJlIHVuIGZhdHRvcmUgZGkgcGVzby5cIixcblx0XHRmbG93QWNjdW11bGF0aW9uRGVzYzogXCJMYSBmdW56aW9uZSBnbG9iYWxlIEFjY3VtdWxvIGRlbCBmbHVzc28gY3JlYSB1biByYXN0ZXIgZGkgZmx1c3NvIGFjY3VtdWxhdG8gaW4gY2lhc2N1biBwaXhlbCwgZGV0ZXJtaW5hdG8gZGFsbOKAmWFjY3VtdWxvIGRlbCBwZXNvIGRpIHR1dHRpIGkgcGl4ZWwgY2hlIGZsdWlzY29ubyBpbiBjaWFzY3VuIHBpeGVsIGluIHBlbmRlbnphLiBTZSBub24gdmllbmUgZm9ybml0byBhbGN1biByYXN0ZXIgZGkgcGVzbywgdmllbmUgYXBwbGljYXRvIHVuIHBlc28gcGFyaSBhIDEgYSBjaWFzY3VuIHBpeGVsIGUgaWwgdmFsb3JlIGRlaSBwaXhlbCBuZWwgcmFzdGVyIGRpIG91dHB1dCBjb3JyaXNwb25kZXLDoCBhbCBudW1lcm8gZGkgcGl4ZWwgY2hlIGZsdWlzY29ubyBpbiBjaWFzY3VuIHBpeGVsLjxkaXY+PGJyLz5JIHBpeGVsIGRpIG91dHB1dCBjb24gdW4gZWxldmF0byBhY2N1bXVsbyBkaSBmbHVzc28gc29ubyBhcmVlIGRpIGZsdXNzbyBjb25jZW50cmF0byBlIHBvc3Nvbm8gZXNzZXJlIHVzYXRpIHBlciBpbmRpdmlkdWFyZSBjYW5hbGkgZGkgZmx1c3NvLiBJIHBpeGVsIGRpIG91dHB1dCBjb24gdW4gYWNjdW11bG8gZGkgZmx1c3NvIHBhcmkgYSB6ZXJvIHNvbm8gcmlsaWV2aSB0b3BvZ3JhZmljaSBsb2NhbGkgZSBwb3Nzb25vIGVzc2VyZSB1dGlsaXp6YXRpIHBlciBpZGVudGlmaWNhcmUgbGUgY3Jlc3RlLjwvZGl2PlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25OYW1lOiBcIkRpcmV6aW9uZSBkZWwgRmx1c3NvXCIsXG5cdFx0Zmxvd0RpcmVjdGlvblNuaXA6IFwiQ3JlYSB1biByYXN0ZXIgZGVsbGEgZGlyZXppb25lIGRlbCBmbHVzc28gZGEgb2duaSBjZWxsYSBhbCByZWxhdGl2byB2aWNpbm8gaW4gbWFnZ2lvciBwZW5kZW56YS5cIixcblx0XHRmbG93RGlyZWN0aW9uRGVzYzogXCJVbmEgZGVsbGUgY2hpYXZpIHBlciBkZXJpdmFyZSBsZSBjYXJhdHRlcmlzdGljaGUgaWRyb2xvZ2ljaGUgZGkgdW5hIHN1cGVyZmljaWUgw6ggbGEgY2FwYWNpdMOgIGRpIGRldGVybWluYXJlIGxhIGRpcmV6aW9uZSBkZWwgZmx1c3NvIGRhIGNpYXNjdW4gcGl4ZWwgbmVsIHJhc3Rlci4gTGEgZnVuemlvbmUgcmFzdGVyIERpcmV6aW9uZSBkZWwgZmx1c3NvIHByZW5kZSB1bmEgc3VwZXJmaWNpZSBjb21lIGlucHV0IGUgY3JlYSB1biByYXN0ZXIgZGkgZGlyZXppb25lIGRlbCBmbHVzc28gZGEgY2lhc2N1biBwaXhlbCBhbCByZWxhdGl2byB2aWNpbm8gaW4gbWFnZ2lvciBwZW5kZW56YS4gTGEgZnVuemlvbmUgRGlyZXppb25lIGZsdXNzbyBzdXBwb3J0YSB0cmUgbWV0b2RpIGRpIG1vZGVsbGF6aW9uZSBkZWwgZmx1c3NvOiBEOCAob3R0byBkaXJlemlvbmkpLCBEaXJlemlvbmUgbXVsdGktZmx1c3NvIChNRkQpIGUgRC1JbmZpbml0eSAoRElORikuIFwiLFxuXHRcdGZsb3dEaXN0YW5jZU5hbWU6IFwiRGlzdGFuemEgZGkgRmx1c3NvXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlU25pcDogXCJDYWxjb2xhLCBwZXIgb2duaSBjZWxsYSwgbGEgZGlzdGFuemEgbWluaW1hIG9yaXp6b250YWxlIG8gdmVydGljYWxlIGRhbGxlIGNlbGxlIGx1bmdvIGxhIGxpbmVhIGRpIHNjb3JyaW1lbnRvIGRpIHVuIHJ1c2NlbGxvIG8gZGkgdW4gZml1bWUuXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlRGVzYzogXCJQZXIgY2lhc2N1biBwaXhlbCwgbGEgZnVuemlvbmUgY2FsY29sZXLDoCBsYSBkaXN0YW56YSBtaW5pbWEgb3JpenpvbnRhbGUgbyB2ZXJ0aWNhbGUgZGFpIHBpeGVsIGx1bmdvIGxhIGxpbmVhIGRpIHNjb3JyaW1lbnRvIGRpIHVuIHJ1c2NlbGxvIG8gZGkgdW4gZml1bWUuIFNlIHZpZW5lIGZvcm5pdG8gdW4gcmFzdGVyIGRpIGRpcmV6aW9uZSBkZWwgZmx1c3NvIG9wemlvbmFsZSwgbGUgZGlyZXppb25pIHNhcmFubm8gbGltaXRhdGUgYSBxdWVsbGUgZGVmaW5pdGUgZGFsbGEgZGlyZXppb25lIGRlbCBmbHVzc28gZGVsIHJhc3RlciBkaSBpbnB1dC4gTOKAmW91dHB1dCDDqCB1biByYXN0ZXIgZGkgZGlzdGFuemEgZGkgZmx1c3NvLlwiLFxuXHRcdGZvY2FsTmFtZTogXCJTdGF0aXN0aWNoZSBmb2NhbGlcIixcblx0XHRmb2NhbFNuaXA6IFwiQ2FsY29sYSBsZSBzdGF0aXN0aWNoZSBkZWxsYSBmb2NhbGUgcGVyIG9nbmkgcGl4ZWwgZGkgdW4naW1tYWdpbmUgaW4gYmFzZSBhZ2xpIGVsZW1lbnRpIHZpY2luaSBjb24gZm9jYWxlIGRlZmluaXRhLlwiLFxuXHRcdGZvY2FsRGVzYzogXCJMYSBmdW56aW9uZSBTdGF0aXN0aWNoZSBmb2NhbGkgY2FsY29sYSBsZSBzdGF0aXN0aWNoZSBkZWxsYSBmb2NhbGUgcGVyIG9nbmkgcGl4ZWwgZGkgdW4naW1tYWdpbmUgaW4gYmFzZSBhZ2xpIGVsZW1lbnRpIHZpY2luaSBjb24gZm9jYWxlIGRlZmluaXRhLlwiLFxuXHRcdGdlb21ldHJpY05hbWU6IFwiR2VvbWV0cmljYVwiLFxuXHRcdGdlb21ldHJpY1NuaXA6IFwiSW5jcmVtZW50YSBsYSBwcmVjaXNpb25lIGRpIHBvc2l6aW9uYW1lbnRvIGRpIHVuIGRhdGFzZXQgdGVuZW5kbyBjb250byBkZWxsJ2VsZXZhemlvbmUuXCIsXG5cdFx0Z2VvbWV0cmljRGVzYzogXCJMYSBmdW56aW9uZSBHZW9tZXRyaWNhIGdlbmVyYSB1buKAmWltbWFnaW5lIG9ydG9yZXR0aWZpY2F0YSBpbiBiYXNlIGFsbGEgZGVmaW5pemlvbmUgZGkgdW4gc2Vuc29yZSBlIGEgdW4gbW9kZWxsbyBkaSB0ZXJyZW5vLiBJbmNyZW1lbnRhIGxhIHByZWNpc2lvbmUgZGkgcG9zaXppb25hbWVudG8gZGkgdW4gZGF0YXNldCB0ZW5lbmRvIGNvbnRvIGRlbGwnZWxldmF6aW9uZS5cIixcblx0XHRncmF5c2NhbGVOYW1lOiBcIlNjYWxhIGRpIGdyaWdpXCIsXG5cdFx0Z3JheXNjYWxlU25pcDogXCJDb252ZXJ0ZSB1buKAmWltbWFnaW5lIG11bHRpYmFuZGEgaW4gdW7igJlpbW1hZ2luZSBpbiBzY2FsYSBkaSBncmlnaSBhIGJhbmRhIHNpbmdvbGEuXCIsXG5cdFx0Z3JheXNjYWxlRGVzYzogXCJMYSBmdW56aW9uZSBjb252ZXJ0ZSB1buKAmWltbWFnaW5lIG11bHRpYmFuZGEgaW4gdW7igJlpbW1hZ2luZSBpbiBzY2FsYSBkaSBncmlnaSBhIGJhbmRhIHNpbmdvbGEuPGRpdj48YnIvPlF1ZXN0YSBmdW56aW9uZSBhcHBsaWNhIGkgcGVzaSBzcGVjaWZpY2F0aSBhIGNpYXNjdW5hIGRlbGxlIGJhbmRlIGRpIGlucHV0IGUgbm9ybWFsaXp6YSBsJ2ltbWFnaW5lIGRpIG91dHB1dC4gU3Blc3NvIHBlc2kgdmVuZ29ubyBhcHBsaWNhdGkgcGVyY2jDqSBhbGN1bmUgYmFuZGUgaGFubm8gdW4naW1wb3J0YW56YSB2YXJpYWJpbGUgYSBzZWNvbmRhIGRlbGwnYXBwbGljYXppb25lLiBBZCBlc2VtcGlvLCBsYSBiYW5kYSBibHUgc3Blc3NvIGNvbnRpZW5lIHBpw7kgcnVtb3JlIGRlbGxlIGFsdHJlIGJhbmRlLjwvZGl2PlwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxOYW1lOiBcIkdyZWF0ZXIgVGhhbiBFcXVhbFwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxTbmlwOiBcIkVzZWd1ZSB1bidvcGVyYXppb25lIHJlbGF6aW9uYWxlIG1hZ2dpb3JlLWRpLW8tdWd1YWxlLWEgc3UgZHVlIGlucHV0IGluIGJhc2UgYWxsZSBzaW5nb2xlIGNlbGxlLiBSZXN0aXR1aXNjZSAxIHBlciBsZSBjZWxsZSBpbiBjdWkgaWwgcHJpbW8gcmFzdGVyIMOoIG1hZ2dpb3JlIG8gdWd1YWxlIGFsIHNlY29uZG8gZSAwIGluIGNhc28gY29udHJhcmlvLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxEZXNjOiBcIkxhIGZ1bnppb25lIGVzZWd1ZSB1bidvcGVyYXppb25lIHJlbGF6aW9uYWxlIG1hZ2dpb3JlLWRpLW8tdWd1YWxlLWEgc3UgZHVlIGlucHV0IGluIGJhc2UgYWkgc2luZ29saSBwaXhlbC4gUmVzdGl0dWlzY2UgdW4gdmFsb3JlIDEgcGVyIGkgcGl4ZWwgaW4gY3VpIGlsIHByaW1vIHJhc3RlciDDqCBtYWdnaW9yZSBvIHVndWFsZSBhbCBzZWNvbmRvIHJhc3RlciBlIHVuIHZhbG9yZSAwIHBlciBpIHBpeGVsIGluIGN1aSBpbCBwcmltbyByYXN0ZXIgbm9uIMOoIG1hZ2dpb3JlIG8gdWd1YWxlIGFsIHNlY29uZG8gcmFzdGVyLlwiLFxuXHRcdGdyZWF0ZXJUaGFuTmFtZTogXCJNYWdnaW9yZSBEaVwiLFxuXHRcdGdyZWF0ZXJUaGFuU25pcDogXCJFc2VndWUgdW4nb3BlcmF6aW9uZSByZWxhemlvbmFsZSBtYWdnaW9yZS1kaSBzdSBkdWUgaW5wdXQgaW4gYmFzZSBhbGxlIHNpbmdvbGUgY2VsbGUuIFJlc3RpdHVpc2NlIDEgcGVyIGxlIGNlbGxlIGluIGN1aSBpbCBwcmltbyByYXN0ZXIgw6ggbWFnZ2lvcmUgZGVsIHNlY29uZG8gZSAwIGluIGNhc28gY29udHJhcmlvLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRGVzYzogXCJMYSBmdW56aW9uZSBlc2VndWUgdW4nb3BlcmF6aW9uZSByZWxhemlvbmFsZSBtYWdnaW9yZS1kaSBzdSBkdWUgaW5wdXQgaW4gYmFzZSBhaSBzaW5nb2xpIHBpeGVsLiBSZXN0aXR1aXNjZSB1biB2YWxvcmUgMSBwZXIgaSBwaXhlbCBpbiBjdWkgaWwgcHJpbW8gcmFzdGVyIMOoIG1hZ2dpb3JlIGRlbCBzZWNvbmRvIHJhc3RlciBlIHVuIHZhbG9yZSAwIHBlciBpIHBpeGVsIGluIGN1aSBpbCBwcmltbyByYXN0ZXIgbm9uIMOoIG1hZ2dpb3JlIGRlbCBzZWNvbmRvIHJhc3Rlci5cIixcblx0XHRoZWF0SW5kZXhOYW1lOiBcIkluZGljZSBkaSBjYWxvcmVcIixcblx0XHRoZWF0SW5kZXhTbmlwOiBcIkNvbWJpbmEgbGEgdGVtcGVyYXR1cmEgZGVsbCdhcmlhIGUgbCd1bWlkaXTDoCByZWxhdGl2YSBkZWxsJ2FtYmllbnRlIHBlciByZXN0aXR1aXJlIGxhIHRlbXBlcmF0dXJhIGFwcGFyZW50ZS5cIixcblx0XHRoZWF0SW5kZXhEZXNjOiBcIkxhIGZ1bnppb25lIGNhbGNvbGEgbGEgdGVtcGVyYXR1cmEgYXBwYXJlbnRlIGluIGJhc2UgYWxsYSB0ZW1wZXJhdHVyYSBhbWJpZW50ZSBlIGFsbOKAmXVtaWRpdMOgIHJlbGF0aXZhLiBMYSB0ZW1wZXJhdHVyYSBhcHBhcmVudGUgw6ggc3Blc3NvIGRlc2NyaXR0YSBjb21lIGlsIGNhbG9yZSBwZXJjZXBpdG8gZGFsIGNvcnBvIHVtYW5vLjxkaXY+PGJyLz5RdWVzdG8gaW5kaWNlIHB1w7IgZXNzZXJlIHV0aWxlIHBlciBjYWxjb2xhcmUgaSByaXNjaGkgbGVnYXRpIGEgcHJvYmxlbWkgbWVkaWNpIGNvbWUgY3JhbXBpIG11c2NvbGFyaSwgZGlzaWRyYXRhemlvbmUsIGVzYXVyaW1lbnRvIGRhIGNhbG9yZSBvLCBhbmNvcmEgcGnDuSBncmF2ZSwgaWwgY29scG8gZGkgY2Fsb3JlIG5laSBnaW9ybmkgY2FsZGkgZSB1bWlkaS4gVW4ndW1pZGl0w6AgcmVsYXRpdmEgZWxldmF0YSByZW5kZSBwacO5IGRpZmZpY29sdG9zYSBs4oCZZXZhcG9yYXppb25lIGRlbCBzdWRvcmUgZSBpbCBjb3JwbyB2aWVuZSBwcml2YXRvIGRpIHVuIGVmZmljYWNlIG1ldG9kbyBuYXR1cmFsZSBkaSByYWZmcmVkZGFtZW50by4gTGUgbWFwcGUgZGVpIGJvbGxldHRpbmkgZSBkZWdsaSBhbGFybWkgbWV0ZW8gc29ubyBzcGVzc28gaWwgcHJvZG90dG8gZGkgdW5hIHJpY2xhc3NpZmljYXppb25lIGRlbCByaXN1bHRhdG8gZGVsbOKAmWluZGljZSBkaSBjYWxvcmUgaW4gY2xhc3NpLCBpbiBjdWkgcXVhbnRvIHBpw7kgYWx0byDDqCBpbCB2YWxvcmUgZGVsbOKAmWluZGljZSwgcGnDuSBwcm9iYWJpbGUgc2Fyw6AgY2hlIHZlbmdhIHRyYXNmb3JtYXRvIGluIHVuIGFsbGFybWUgcGl1dHRvc3RvIGNoZSBpbiB1biBzZW1wbGljZSBib2xsZXR0aW5vLjwvZGl2PlwiLFxuXHRcdGhpbGxzaGFkZU5hbWU6IFwiSGlsbHNoYWRlXCIsXG5cdFx0aGlsbHNoYWRlU25pcDogXCJDcmVhIHVuYSByYXBwcmVzZW50YXppb25lIDNEIGRlbGxhIHN1cGVyZmljaWUsIHRlbmVuZG8gY29udG8gZGVsbGEgcG9zaXppb25lIHJlbGF0aXZhIGRlbCBzb2xlIHBlciBsJ29tYnJlZ2dpYXR1cmEgZGVsbCdpbW1hZ2luZS5cIixcblx0XHRoaWxsc2hhZGVEZXNjOiBcIkxhIGZ1bnppb25lIEhpbGxzaGFkZSBwcm9kdWNlIHVuYSByYXBwcmVzZW50YXppb25lIDNEIGluIHNjYWxhIGRpIGdyaWdpIGRlbGxhIHN1cGVyZmljaWUgZGVsIHN1b2xvIGNoZSB0aWVuZSBpbiBjb25zaWRlcmF6aW9uZSBsYSBwb3NpemlvbmUgcmVsYXRpdmEgZGVsIHNvbGUgcGVyIG9tYnJlZ2dpYXJlIGzigJlpbW1hZ2luZS4gPGRpdj48YnIvPklsIHJpbGlldm8gb21icmVnZ2lhdG8gw6ggdW5hIHRlY25pY2EgZGkgdmlzdWFsaXp6YXppb25lIGRlbCB0ZXJyZW5vIGRldGVybWluYXRhIGRhIHVuYSBmb250ZSBkaSBpbGx1bWluYXppb25lIGUgZGFsbGEgcGVuZGVuemEgZSBhc3BldHRvIGRlbGxhIHN1cGVyZmljaWUgZGkgZWxldmF6aW9uZS4gw4ggdW4gbWV0b2RvIHF1YWxpdGF0aXZvIGRpIHZpc3VhbGl6emF6aW9uZSBkZWxsYSB0b3BvZ3JhZmlhIGUgbm9uIGZvcm5pc2NlIHZhbG9yaSBkaSBlbGV2YXppb25lIGFzc29sdXRpLiA8L2Rpdj5cIixcblx0XHRpbnROYW1lOiBcIkludFwiLFxuXHRcdGludFNuaXA6IFwiQ29udmVydGUgb2duaSB2YWxvcmUgZGkgY2VsbGEgZGkgdW4gcmFzdGVyIGluIHVuIG51bWVybyBpbnRlcm8gbWVkaWFudGUgdHJvbmNhbWVudG8uXCIsXG5cdFx0aW50RGVzYzogXCJMYSBmdW56aW9uZSBJbnQgY29udmVydGUgb2duaSB2YWxvcmUgZGkgcGl4ZWwgZGkgdW4gcmFzdGVyIGluIHVuIG51bWVybyBpbnRlcm8gbWVkaWFudGUgdHJvbmNhbWVudG8uXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmFtZTogXCJJbnRlcnBvbGEgZGF0aSBpcnJlZ29sYXJpXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhU25pcDogXCJDb25zZW50ZSBkaSBpbnRlcnBvbGFyZSBkYSBjbG91ZCBkaSBwdW50aSBvIGdyaWdsaWUgaXJyZWdvbGFyaS5cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFEZXNjOiBcIkFsY3VuaSBkYXRhc2V0IG5ldENERiBvIEhERiBhcmNoaXZpYW5vIGxhIGxvcm8gZ2VvcG9zaXppb25lIGNvbWUgYXJyYXkgZGkgcGl4ZWwgbyBkYXRpIGRpIHB1bnRpIGlycmVnb2xhcm1lbnRlIHNwYXppYXRpLiBRdWFuZG8gc2kgYWdnaXVuZ29ubyBxdWVzdGkgZGF0YXNldCBhIHVuIG1vc2FpYyBkYXRhc2V0LCBsYSBmdW56aW9uZSBJbnRlcnBvbGF6aW9uZSBkYXRpIGlycmVnb2xhcmkgcHJlbmRlIGkgZGF0aSByZXRpY29sYXRpIGlycmVnb2xhcm1lbnRlIGUgbGkgcmljYW1waW9uYSBpbiBtb2RvIGNoZSBvZ25pIHBpeGVsIHNpYSBkaSBkaW1lbnNpb25lIHVuaWZvcm1lIGUgcXVhZHJhdG8uPGRpdj48YnIvPlF1YW5kbyBzaSBhZ2dpdW5nb25vIHZhcmlhYmlsaSBkYSBuZXRDREYgbyBIREYgYSB1biBtb3NhaWMgZGF0YXNldCwgc2kgdmVyaWZpY2hlcsOgIGF1dG9tYXRpY2FtZW50ZSBzZSBpIGRhdGkgc29ubyBkaXNwb3N0aSByZWdvbGFybWVudGUgbmVsbCdhcnJheS4gSW4gY2FzbyBjb250cmFyaW8sIGxhIGZ1bnppb25lIEludGVycG9sYXppb25lIGRhdGkgaXJyZWdvbGFyaSBwdcOyIGVzc2VyZSB1c2F0YSBwZXIgY29udmVydGlyZSBpIGRhdGkgaXJyZWdvbGFyaSBpbiByYXN0ZXIgcmV0aWNvbGF0aSBpbiBtb2RvIHJlZ29sYXJlLiDDiCBwb3NzaWJpbGUgY2FtYmlhcmUgaWwgbWV0b2RvIGRpIGludGVycG9sYXppb25lIGUgbGEgZGltZW5zaW9uZSBkZWxsZSBjZWxsZSB1c2F0aSBuZWxsYSBmdW56aW9uZSByYXN0ZXIgSW50ZXJwb2xhemlvbmUgZGF0aSBpcnJlZ29sYXJpLiBQZXIgZGF0aSByYXN0ZXIgc3BhemlhdGkgaW4gbW9kbyByZWdvbGFyZSwgbm9uIHNpIGFwcGxpY2hlcsOgIG5lc3N1bmEgaW50ZXJwb2xhemlvbmUgZSBpIGRhdGkgc2FyYW5ubyBsZXR0aSBjb3PDrCBjb21lIHNvbm8uPC9kaXY+XCIsXG5cdFx0aXNOdWxsTmFtZTogXCLDiCBudWxsXCIsXG5cdFx0aXNOdWxsU25pcDogXCJEZXRlcm1pbmEgcXVhbGkgdmFsb3JpIGRlbCByYXN0ZXIgZGkgaW5wdXQgc29ubyBOb0RhdGEgaW4gYmFzZSBhbGxlIHNpbmdvbGUgY2VsbGUuIFJlc3RpdHVpc2NlIHVuIHZhbG9yZSAxIHNlIGlsIHZhbG9yZSBkaSBpbnB1dCDDqCBOb0RhdGEgZSAwIGluIGNhc28gY29udHJhcmlvLlwiLFxuXHRcdGlzTnVsbERlc2M6IFwiTGEgZnVuemlvbmUgw4ggbnVsbCBkZXRlcm1pbmEgcXVhbGkgdmFsb3JpIGRlbCByYXN0ZXIgZGkgaW5wdXQgc29ubyBOb0RhdGEgaW4gYmFzZSBhaSBzaW5nb2xpIHBpeGVsLiBSZXN0aXR1aXNjZSB1biB2YWxvcmUgMSBzZSBpbCB2YWxvcmUgZGkgaW5wdXQgw6ggTm9EYXRhIGUgdW4gdmFsb3JlIDAgcGVyIGkgcGl4ZWwgY2hlIG5vbiBzb25vIE5vRGF0YS5cIixcblx0XHRrZXJuZWxEZW5zaXR5TmFtZTogXCJEZW5zaXTDoCBLZXJuZWxcIixcblx0XHRrZXJuZWxEZW5zaXR5U25pcDogXCJDYWxjb2xhIHVuJ2FyZWEgZ3JhbmRlenphIHBlciB1bml0w6AgYSBwYXJ0aXJlIGRhbGxlIGZlYXR1cmUgcHVudG8gbyBwb2xpbGluZWEgdXRpbGl6emFuZG8gdW5hIGZ1bnppb25lIGtlcm5lbCBwZXIgYWRhdHRhcmUgdW5hIHN1cGVyZmljaWUgcmFzdHJlbWF0YSB1bmlmb3JtZSBhIGNpYXNjdW4gcHVudG8gbyBwb2xpbGluZWEuXCIsXG5cdFx0a2VybmVsRGVuc2l0eURlc2M6IFwiUXVlc3RhIGZ1bnppb25lIGNhbGNvbGEgdW4nYXJlYSBncmFuZGV6emEgcGVyIHVuaXTDoCBhIHBhcnRpcmUgZGFsbGUgZmVhdHVyZSBwdW50byBvIHBvbGlsaW5lYSB1dGlsaXp6YW5kbyB1bmEgZnVuemlvbmUga2VybmVsIHBlciBhZGF0dGFyZSB1bmEgc3VwZXJmaWNpZSByYXN0cmVtYXRhIHVuaWZvcm1lIGEgY2lhc2N1biBwdW50byBvIHBvbGlsaW5lYS5cIixcblx0XHRrZXlNZXRhZGF0YU5hbWU6IFwiTWV0YWRhdGkgY2hpYXZlXCIsXG5cdFx0a2V5TWV0YWRhdGFTbmlwOiBcIkVzY2x1ZGUgbyBpbnNlcmlzY2UgaSBtZXRhZGF0aSBjaGlhdmUgZGkgdW4gcmFzdGVyIGluIHVuYSBjYXRlbmEgZGkgZnVuemlvbmkuXCIsXG5cdFx0a2V5TWV0YWRhdGFEZXNjOiBcIlF1ZXN0YSBmdW56aW9uZSBjb25zZW50ZSBkaSBpbnNlcmlyZSBvIHNvc3RpdHVpcmUgaSBtZXRhZGF0aSBjaGlhdmUgZGkgdW4gcmFzdGVyLjxkaXY+PGJyLz5MZSBpbmZvcm1hemlvbmkgY29udGVudXRlIG5laSBtZXRhZGF0aSBjaGlhdmUgdmVuZ29ubyB1dGlsaXp6YXRlIHBlciBhc3Npc3RlcmUgbCdhcHBsaWNhemlvbmUgaW4gZGV0ZXJtaW5hdGUgZWxhYm9yYXppb25pIGUgcmVuZGVyaW5nLCBmb3JuZW5kbyBpbmZvcm1hemlvbmkgdXRpbGkgY29tZSBpbCBub21lIGRlbCBzZW5zb3JlLCBpIG5vbWkgZGVsbGUgYmFuZGUgbyBsYSBjb3BlcnR1cmEgZGVsbGUgbnViaSBhc3NvY2lhdGEgYWxsZSBpbW1hZ2luaS48L2Rpdj5cIixcblx0XHRzaG9ydGVzdFBhdGhOYW1lOiBcIlBlcmNvcnNvIGRpIGNvc3RvIG1pbmltb1wiLFxuXHRcdHNob3J0ZXN0UGF0aFNuaXA6IFwiVXRpbGl6emEgaW5wdXQgZGkgb3JpZ2luZSBlIGRlc3RpbmF6aW9uZSBwZXIgZXNlZ3VpcmUgdW4nYW5hbGlzaSBjb3N0by1kaXN0YW56YSBjaGUgdmllbmUgcXVpbmRpIHVzYXRhIHBlciBzdGFiaWxpcmUgaWwgcGVyY29yc28gZGFsIGNvc3RvIG1pbmltbyBkYSB1bidvcmlnaW5lIGEgdW5hIGRlc3RpbmF6aW9uZS5cIixcblx0XHRzaG9ydGVzdFBhdGhEZXNjOiBcIkxhIGZ1bnppb25lIFBlcmNvcnNvIGRpIGNvc3RvIG1pbmltbyBjYWxjb2xhIGlsIHBlcmNvcnNvIGRpIGNvc3RvIG1pbm9yZSBkYSB1bidvcmlnaW5lIGEgdW5hIGRlc3RpbmF6aW9uZS4gTGEgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBtaW5vcmUgdmllbmUgY2FsY29sYXRhIHBlciBvZ25pIHBpeGVsIHN1IHVuYSBzdXBlcmZpY2llIGRpIGNvc3RvLCByaXNwZXR0byBhbGwnb3JpZ2luZSBwacO5IHZpY2luYS4gSW4gcXVlc3RvIG1vZG8sIHNpIHByb2R1Y2UgdW4gcmFzdGVyIGRpIG91dHB1dCBjaGUgcmVnaXN0cmEgaWwgcGVyY29yc28gbyBpIHBlcmNvcnNpIG1lbm8gY29zdG9zaSwgZGFsbGUgcG9zaXppb25pIHNlbGV6aW9uYXRlIGFpIHBpeGVsIGRpIG9yaWdpbmUgcGnDuSB2aWNpbmkgZGVmaW5pdGkgbmVsbGEgc3VwZXJmaWNpZSBkaSBjb3N0byBjdW11bGF0aXZvLCBpbiB0ZXJtaW5pIGRpIGRpc3RhbnphIGRpIGNvc3RvLjxkaXY+PGJyLz5BZCBvZ25pIHBlcmNvcnNvIGRpIGNvc3RvIG1pbmltbyByaWxldmF0byBuZWwgcHJvY2Vzc28gZGkgc2NhbnNpb25lIHZpZW5lIGFzc2VnbmF0byB1biB2YWxvcmUuIElsIHBpeGVsIGZpbmFsZSBzdWwgcmFzdGVyIGRpIG9yaWdpbmUgZGkgdW4gcGVyY29yc28gZGkgY29zdG8gcmljZXZlIHVuIHZhbG9yZSAxLiBJbCBwcmltbyBwZXJjb3JzbyByaWNldmUgdW4gdmFsb3JlIDMsIGlsIHNlY29uZG8gNCwgZSBjb3PDrCB2aWEuIFF1YW5kbyBwacO5IHBlcmNvcnNpIHNpIHVuaXNjb25vIGUgcGVyY29ycm9ubyBsYSBkaXN0YW56YSByaW1hbmVudGUgdmVyc28gdW7igJlvcmlnaW5lIHN1bGxvIHN0ZXNzbyBpdGluZXJhcmlvLCBhbCBzZWdtZW50byBpbiBjdWkgaSBkdWUgcGVyY29yc2kgdmlhZ2dpYW5vIGluc2llbWUgdmllbmUgYXNzZWduYXRvIHVuIHZhbG9yZSAyLiBBbGxhIHBvcnppb25lIGRpIHBlcmNvcnNvIHVuaXRhIG5vbiBwdcOyIGVzc2VyZSBhc3NlZ25hdG8gaWwgdmFsb3JlIGRpIHVubyBkZWkgcGVyY29yc2ksIGluIHF1YW50byBsYSBwb3J6aW9uZSB1bml0YSBhcHBhcnRpZW5lIGEgZW50cmFtYmkuPC9kaXY+XCIsXG5cdFx0bGVzc1RoYW5FcXVhbE5hbWU6IFwiTGVzcyBUaGFuIEVxdWFsXCIsXG5cdFx0bGVzc1RoYW5FcXVhbFNuaXA6IFwiRXNlZ3VlIHVuJ29wZXJhemlvbmUgcmVsYXppb25hbGUgbWlub3JlLWRpLW8tdWd1YWxlLWEgc3UgZHVlIGlucHV0IGluIGJhc2UgYWxsZSBzaW5nb2xlIGNlbGxlLiBSZXN0aXR1aXNjZSAxIHBlciBsZSBjZWxsZSBpbiBjdWkgaWwgcHJpbW8gcmFzdGVyIMOoIG1pbm9yZSBvIHVndWFsZSBhbCBzZWNvbmRvIGUgMCBpbiBjYXNvIGNvbnRyYXJpby5cIixcblx0XHRsZXNzVGhhbkVxdWFsRGVzYzogXCJMYSBmdW56aW9uZSBlc2VndWUgdW4nb3BlcmF6aW9uZSByZWxhemlvbmFsZSBtaW5vcmUtZGktby11Z3VhbGUtYSBzdSBkdWUgaW5wdXQgaW4gYmFzZSBhaSBzaW5nb2xpIHBpeGVsLiBSZXN0aXR1aXNjZSB1biB2YWxvcmUgMSBwZXIgaSBwaXhlbCBpbiBjdWkgaWwgcHJpbW8gcmFzdGVyIMOoIG1pbm9yZSBvIHVndWFsZSBhbCBzZWNvbmRvIHJhc3RlciBlIHVuIHZhbG9yZSAwIHNlIGlsIHByaW1vIHJhc3RlciBub24gw6ggbWlub3JlIG8gdWd1YWxlIGFsIHNlY29uZG8gcmFzdGVyLlwiLFxuXHRcdGxlc3NUaGFuTmFtZTogXCJMZXNzIFRoYW5cIixcblx0XHRsZXNzVGhhblNuaXA6IFwiRXNlZ3VlIHVuJ29wZXJhemlvbmUgcmVsYXppb25hbGUgbWlub3JlLWRpIHN1IGR1ZSBpbnB1dCBpbiBiYXNlIGFsbGUgc2luZ29sZSBjZWxsZS4gUmVzdGl0dWlzY2UgMSBwZXIgbGUgY2VsbGUgaW4gY3VpIGlsIHByaW1vIHJhc3RlciDDqCBtaW5vcmUgZGVsIHNlY29uZG8gZSAwIGluIGNhc28gY29udHJhcmlvLlwiLFxuXHRcdGxlc3NUaGFuRGVzYzogXCJMYSBmdW56aW9uZSBlc2VndWUgdW4nb3BlcmF6aW9uZSByZWxhemlvbmFsZSBtaW5vcmUtZGkgc3UgZHVlIGlucHV0IGluIGJhc2UgYWkgc2luZ29saSBwaXhlbC4gUmVzdGl0dWlzY2UgdW4gdmFsb3JlIDEgcGVyIGkgcGl4ZWwgaW4gY3VpIGlsIHByaW1vIHJhc3RlciDDqCBtaW5vcmUgZGVsIHNlY29uZG8gcmFzdGVyIGUgdW4gdmFsb3JlIDAgc2UgaWwgcHJpbW8gcmFzdGVyIG5vbiDDqCBtaW5vcmUgZGVsIHNlY29uZG8gcmFzdGVyLlwiLFxuXHRcdGxuTmFtZTogXCJMblwiLFxuXHRcdGxuU25pcDogXCJDYWxjb2xhIGlsIGxvZ2FyaXRtbyBuYXR1cmFsZSAoaW4gYmFzZSBlKSBkaSBjZWxsZSBpbiB1biByYXN0ZXIuXCIsXG5cdFx0bG5EZXNjOiBcIkxhIGZ1bnppb25lIExuIGNhbGNvbGEgaWwgbG9nYXJpdG1vIG5hdHVyYWxlIChpbiBiYXNlIGUpIGRpIG9nbmkgcGl4ZWwgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdGxvZzEwTmFtZTogXCJMb2cxMFwiLFxuXHRcdGxvZzEwU25pcDogXCJDYWxjb2xhIGlsIGxvZ2FyaXRtbyBpbiBiYXNlIDEwIGRpIGNlbGxlIGluIHVuIHJhc3Rlci5cIixcblx0XHRsb2cxMERlc2M6IFwiTGEgZnVuemlvbmUgTG9nMTAgY2FsY29sYSBpbCBsb2dhcml0bW8gaW4gYmFzZSAxMCBkaSBvZ25pIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRsb2cyTmFtZTogXCJMb2cyXCIsXG5cdFx0bG9nMlNuaXA6IFwiQ2FsY29sYSBpbCBsb2dhcml0bW8gaW4gYmFzZSAyIGRpIGNlbGxlIGluIHVuIHJhc3Rlci5cIixcblx0XHRsb2cyRGVzYzogXCJMYSBmdW56aW9uZSBMb2cyIGNhbGNvbGEgaWwgbG9nYXJpdG1vIGluIGJhc2UgMiBkaSBvZ25pIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRsb29rdXBOYW1lOiBcIlJpY2VyY2FcIixcblx0XHRsb29rdXBTbmlwOiBcIkNyZWEgdW4gbnVvdm8gcmFzdGVyIGNlcmNhbmRvIHZhbG9yaSBwcmVzZW50aSBpbiB1biBhbHRybyBjYW1wbyBuZWxsYSB0YWJlbGxhIGRlbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFx0bG9va3VwRGVzYzogXCJMYSBmdW56aW9uZSBjcmVhIHVuIG51b3ZvIHJhc3RlciBjZXJjYW5kbyBpIHZhbG9yaSBwcmVzZW50aSBpbiB1biBhbHRybyBjYW1wbyBuZWxsYSB0YWJlbGxhIGRlbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFx0bWxDbGFzc2lmeU5hbWU6IFwiQ2xhc3NpZmljYSBNTFwiLFxuXHRcdG1sQ2xhc3NpZnlTbmlwOiBcIkNsYXNzaWZpY2EgbGUgaW1tYWdpbmkgdXRpbGl6emFuZG8gdW4gYXBwcm9jY2lvIHBlciBwaXhlbC4gSSBwaXhlbCBtaXN0aSB2ZW5nb25vIGFzc2VnbmF0aSBhbGxhIGZlYXR1cmUgY29uIGxhIHBlcmNlbnR1YWxlIHBpw7kgYWx0YSBpbiB0YWxlIHBpeGVsLlwiLFxuXHRcdG1sQ2xhc3NpZnlEZXNjOiBcIkxhIGZ1bnppb25lIENsYXNzaWZpY2EgTUwgY29uc2VudGUgZGkgZXNlZ3VpcmUgdW5hIGNsYXNzaWZpY2F6aW9uZSBzdXBlcnZpc2lvbmF0YSwgdXRpbGl6emFuZG8gbOKAmWFsZ29yaXRtbyBkaSBjbGFzc2lmaWNhemlvbmUgcGVyIG1hc3NpbWEgcHJvYmFiaWxpdMOgLCBzdSB1biBkYXRhc2V0IHJhc3RlciBvIHN1IHVuIG1vc2FpYyBkYXRhc2V0LiBRdWVzdGEgZnVuemlvbmUgcmljaGllZGUgdW4gZmlsZSBkaSBmaXJtYSBkZWxsYSBjbGFzc2lmaWNhemlvbmUuXCIsXG5cdFx0bWFza05hbWU6IFwiTWFzY2hlcmFcIixcblx0XHRtYXNrU25pcDogXCJDb25zZW50ZSBkaSBpbXBvc3RhcmUgaSB2YWxvcmkgY2hlIG5vbiBzaSBkZXNpZGVyYSB2aXN1YWxpenphcmUuXCIsXG5cdFx0bWFza0Rlc2M6IFwiUXVlc3RhIGZ1bnppb25lIHJhc3RlciBjb25zZW50ZSBkaSBpbXBvc3RhcmUgaSB2YWxvcmkgY2hlIG5vbiBzaSBkZXNpZGVyYSB2aXN1YWxpenphcmUgbmVsIHJhc3Rlci4gVXNhbmRvIGxhIGZ1bnppb25lIE1hc2NoZXJhLCDDqCBwb3NzaWJpbGUgc3BlY2lmaWNhcmUgdW5vIG8gcGnDuSB2YWxvcmkgTm9EYXRhIG8gdW4gaW50ZXJ2YWxsbyBkaSBQaXhlbCB2YWx1ZSB2YWxpZGkuIFwiLFxuXHRcdG1pbnVzTmFtZTogXCJNaW51c1wiLFxuXHRcdG1pbnVzU25pcDogXCJTb3R0cmFlIGlsIHZhbG9yZSBkZWwgc2Vjb25kbyByYXN0ZXIgZGkgaW5wdXQgZGFsIHZhbG9yZSBkZWwgcHJpbW8gcmFzdGVyIGRpIGlucHV0IGluIGJhc2UgYWxsZSBzaW5nb2xlIGNlbGxlLlwiLFxuXHRcdG1pbnVzRGVzYzogXCJMYSBmdW56aW9uZSBNZW5vIHNvdHRyYWUgaWwgdmFsb3JlIGRlbCBzZWNvbmRvIHJhc3RlciBkaSBpbnB1dCBkYWwgdmFsb3JlIGRlbCBwcmltbyByYXN0ZXIgZGkgaW5wdXQgaW4gYmFzZSBhaSBzaW5nb2xpIHBpeGVsLlwiLFxuXHRcdG1vZE5hbWU6IFwiTW9kXCIsXG5cdFx0bW9kU25pcDogXCJUcm92YSBpbCByZXN0byAobW9kdWxvKSBkZWwgcHJpbW8gcmFzdGVyIHF1YW5kbyDDqCBkaXZpc28gcGVyIGlsIHNlY29uZG8gcmFzdGVyIGluIGJhc2UgYWxsZSBzaW5nb2xlIGNlbGxlLlwiLFxuXHRcdG1vZERlc2M6IFwiTGEgZnVuemlvbmUgTW9kIHRyb3ZhIGlsIHJlc3RvIChtb2R1bG8pIGRlbCBwcmltbyByYXN0ZXIgcXVhbmRvIMOoIGRpdmlzbyBwZXIgaWwgc2Vjb25kbyByYXN0ZXIgaW4gYmFzZSBhaSBzaW5nb2xpIHBpeGVsLiBMJ29yZGluZSBkZWdsaSBpbnB1dCDDqCBpbXBvcnRhbnRlIGUgaW5mbHVlbnphIGlsIHJpc3VsdGF0byBkaSBvdXRwdXQuXCIsXG5cdFx0bW9zYWljUmFzdGVyc05hbWU6IFwiUmFzdGVyIG1vc2FpY29cIixcblx0XHRtb3NhaWNSYXN0ZXJzU25pcDogXCJVbmlzY2UgdW4gaW5zaWVtZSBkaSBkYXRhc2V0IHJhc3RlciBwZXIgY3JlYXJlIHVuIGRhdGFzZXQuXCIsXG5cdFx0bW9zYWljUmFzdGVyc0Rlc2M6IFwiTGEgZnVuemlvbmUgTW9zYWljIHJhc3RlciBjcmVhIHVu4oCZaW1tYWdpbmUgYSBtb3NhaWNvIGRhIHZhcmllIGltbWFnaW5pLiBJbiBjYXNvIGRpIHNvdnJhcHBvc2l6aW9uZSBkZWxsZSBpbW1hZ2luaSwgw6ggcG9zc2liaWxlIHNjZWdsaWVyZSB0cmEgdmFyaSBtZXRvZGkgcGVyIHN0YWJpbGlyZSBxdWFsaSBpbW1hZ2luaSB2aXN1YWxpenphcmUuXCIsXG5cdFx0bmR2aUNvbG9yaXplZE5hbWU6IFwiTkRWSSBjb2xvcmF0b1wiLFxuXHRcdG5kdmlDb2xvcml6ZWRTbmlwOiBcIkNyZWEgdW4gZGF0YXNldCBtdWx0aWJhbmRhIGNoZSByYXBwcmVzZW50YSBsbyBzdGF0byBkZWxsYSB2ZWdldGF6aW9uZSwgaW4gYmFzZSBhbGxhIGRpZmZlcmVuemEgdHJhIGxlIGJhbmRlIHJvc3NvIGUgcXVhc2kgaW5mcmFyb3Nzby5cIixcblx0XHRuZHZpQ29sb3JpemVkRGVzYzogXCJMYSBmdW56aW9uZSBORFZJIENvbG9yaXplZCBhcHBsaWNhIGxhIGZ1bnppb25lIE5EVkkgc3VsbOKAmWltbWFnaW5lIGRpIGlucHV0LCBxdWluZGkgdXRpbGl6emEgdW5hIGNvbG9ybWFwIG8gdW5hIHNjYWxhIGNyb21hdGljYSBwZXIgdmlzdWFsaXp6YXJlIGlsIHJpc3VsdGF0by5cIixcblx0XHRuZHZpTmFtZTogXCJORFZJXCIsXG5cdFx0bmR2aVNuaXA6IFwiQ2FsY29sYSBpbCBORFZJIChOb3JtYWxpemVkIERpZmZlcmVuY2UgVmVnZXRhdGlvbiBJbmRleCkuXCIsXG5cdFx0bmR2aURlc2M6IFwiTGEgZnVuemlvbmUgTkRWSSBjcmVhIHVuIGRhdGFzZXQgYSBiYW5kYSBzaW5nb2xhIGNoZSByYXBwcmVzZW50YSBsbyBzdGF0byBkZWxsYSB2ZWdldGF6aW9uZSwgaW4gYmFzZSBhbGxhIGRpZmZlcmVuemEgdHJhIGxlIGJhbmRlIGRlbCByb3NzbyBlIGRlbGzigJlpbmZyYXJvc3NvIHZpY2luby48ZGl2Pjxici8+TkRWSSDDqCB1biBpbmRpY2Ugc3RhbmRhcmRpenphdG8gY2hlIGNvbnNlbnRlIGRpIGdlbmVyYXJlIHVuJ2ltbWFnaW5lIHJhZmZpZ3VyYW50ZSBhcmVlIHZlcmRpLCBhbmNoZSBub3RhIGNvbWUgYmlvbWFzc2EgcmVsYXRpdmEuIFF1ZXN0byBpbmRpY2Ugc2ZydXR0YSBsZSBjYXJhdHRlcmlzdGljaGUgY29udHJhc3RhbnRpIHRyYSBkdWUgYmFuZGUgZGkgdW4gZGF0YXNldCByYXN0ZXIgbXVsdGlzcGV0dHJhbGU6IGwnYXNzb3JiaW1lbnRvIGRlaSBwaWdtZW50aSBkaSBjbG9yb2ZpbGxhIG5lbGxhIGJhbmRhIGRlbCByb3NzbyBlIGwnZWxldmF0YSByaWZsZXR0YW56YSBkZWwgbWF0ZXJpYWxlIHZlZ2V0YWxlIG5lbGxhIGJhbmRhIGRlbGwnaW5mcmFyb3NzbyB2aWNpbm8gKE5JUikuIFZhbG9yaSBkaSBORFZJIGVzdHJlbWFtZW50ZSBiYXNzaSBvIG5lZ2F0aXZpIHJhcHByZXNlbnRhbm8gYXJlZSBkZWwgdHV0dG8gcHJpdmUgZGkgdmVnZXRhemlvbmUsIGNvbWUgbnV2b2xlLCBhY3F1YSBvIG5ldmUuIFZhbG9yaSBtb2x0byBiYXNzaSByYXBwcmVzZW50YW5vIGFyZWUgZGkgdmVnZXRhemlvbmUgc2NhcnNhIG8gYXNzZW50ZSwgY29tZSBjZW1lbnRvLCByb2NjaWEgbyB0ZXJyZW5vIG51ZG8uIFZhbG9yaSBtb2RlcmF0aSByYXBwcmVzZW50YW5vIGFyZWUgY29uIHByZXNlbnphIGRpIGFyYnVzdGkgZSBwcmF0aS4gVmFsb3JpIGVsZXZhdGkgcmFwcHJlc2VudGFubyBhcmVlIGZvcmVzdGFsaSBlIHJpY2NoZSBkaSB2ZWdldGF6aW9uZS48L2Rpdj5cIixcblx0XHRuZWdhdGVOYW1lOiBcIk5lZ2F0ZVwiLFxuXHRcdG5lZ2F0ZVNuaXA6IFwiQ2FtYmlhIGlsIHNlZ25vIChtb2x0aXBsaWNhIHBlciAtMSkgZGVpIHZhbG9yaSBkaSBjZWxsYSBkZWwgcmFzdGVyIGRpIGlucHV0IGluIGJhc2UgYSBzaW5nb2xlIGNlbGxlLlwiLFxuXHRcdG5lZ2F0ZURlc2M6IFwiTGEgZnVuemlvbmUgTmVnYXRpdm8gY2FtYmlhIGlsIHNlZ25vIChtb2x0aXBsaWNhIHBlciAtMSkgZGVpIHZhbG9yaSBkZWkgcGl4ZWwgZGVsIHJhc3RlciBkaSBpbnB1dCBpbiBiYXNlIGFpIHNpbmdvbGkgcGl4ZWwuIFwiLFxuXHRcdG5pYmJsZU5hbWU6IFwiTmliYmxlXCIsXG5cdFx0bmliYmxlU25pcDogXCJTb3N0aXR1aXNjZSBsZSBjZWxsZSBkaSB1biByYXN0ZXIgY29ycmlzcG9uZGVudGkgYSB1bmEgbWFzY2hlcmEgY29uIGkgdmFsb3JpIGRlaSB2aWNpbmkgcGnDuSBwcm9zc2ltaS5cIixcblx0XHRuaWJibGVEZXNjOiBcIkxhIGZ1bnppb25lIGdsb2JhbGUgTmliYmxlIGNvbnNlbnRlIGRpIGFzc2VnbmFyZSBhbGxlIGFyZWUgc2VsZXppb25hdGUgZGkgdW4gcmFzdGVyIGlsIHZhbG9yZSBkZWwgcmlzcGV0dGl2byB2aWNpbm8gcGnDuSBwcm9zc2ltby4gw4ggdXRpbGUgcGVyIG1vZGlmaWNhcmUgbGUgYXJlZSBkaSB1biByYXN0ZXIgaW4gY3VpIGkgZGF0aSBwb3RyZWJiZXJvIGVzc2VyZSBlcnJhdGkuXCIsXG5cdFx0bm90RXF1YWxOYW1lOiBcIk5vdCBFcXVhbFwiLFxuXHRcdG5vdEVxdWFsU25pcDogXCJFc2VndWUgdW4nb3BlcmF6aW9uZSByZWxhemlvbmFsZSBkaXZlcnNvLWRhIHN1IGR1ZSBpbnB1dCBpbiBiYXNlIGFsbGUgc2luZ29sZSBjZWxsZS4gUmVzdGl0dWlzY2UgMSBwZXIgbGUgY2VsbGUgaW4gY3VpIGlsIHByaW1vIHJhc3RlciBub24gw6ggdWd1YWxlIGFsIHNlY29uZG8gZSAwIHF1YW5kbyDDqCB1Z3VhbGUuXCIsXG5cdFx0bm90RXF1YWxEZXNjOiBcIkxhIGZ1bnppb25lIGVzZWd1ZSB1bidvcGVyYXppb25lIHJlbGF6aW9uYWxlIGRpdmVyc28tZGEgc3UgZHVlIGlucHV0IGluIGJhc2UgYWkgc2luZ29saSBwaXhlbC4gUmVzdGl0dWlzY2UgdW4gdmFsb3JlIDEgcGVyIGkgcGl4ZWwgaW4gY3VpIGlsIHByaW1vIHJhc3RlciDDqCBkaXZlcnNvIGRhbCBzZWNvbmRvIHJhc3RlciBlIHVuIHZhbG9yZSAwIHBlciBpIHBpeGVsIGluIGN1aSBpbCBwcmltbyByYXN0ZXIgw6ggdWd1YWxlIGFsIHNlY29uZG8gcmFzdGVyLlwiLFxuXHRcdHBhbnNoYXJwZW5pbmdOYW1lOiBcIkZvbmRpIGRhdGkgKFBhbnNoYXJwZW4pXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1NuaXA6IFwiTWlnbGlvcmEgYXJ0aWZpY2lhbG1lbnRlIGxhIHJpc29sdXppb25lIHNwYXppYWxlIGRpIHVuJ2ltbWFnaW5lIG11bHRpYmFuZGEgZm9uZGVuZG9sYSBjb24gdW4naW1tYWdpbmUgcGFuY3JvbWF0aWNhIGNvbiByaXNvbHV6aW9uZSBzdXBlcmlvcmUuXCIsXG5cdFx0cGFuc2hhcnBlbmluZ0Rlc2M6IFwiTGEgZnVuemlvbmUgUGFuLXNoYXJwZW5pbmcgdXRpbGl6emEgdW7igJlpbW1hZ2luZSBwYW5jcm9tYXRpY2EgYWQgYWx0YSByaXNvbHV6aW9uZSBvIHVuYSBiYW5kYSByYXN0ZXIgcGVyIHVuIHNldCBkaSBkYXRpIHJhc3RlciBtdWx0aWJhbmRhIGEgcmlzb2x1emlvbmUgaW5mZXJpb3JlIHBlciBhdW1lbnRhcmUgbGEgcmlzb2x1emlvbmUgc3BhemlhbGUgZGVsbOKAmWltbWFnaW5lIG11bHRpYmFuZGEuPGRpdj48YnIvPkxvIHNjb3BvIGRlbCBwYW4tc2hhcnBlbmluZyDDqCBjcmVhcmUgdW4naW1tYWdpbmUgdmlzaXZhIGRpIHF1YWxpdMOgIHN1cGVyaW9yZS4gRGFsIG1vbWVudG8gY2hlIGxlIHRlY25pY2hlIG1vZGlmaWNhbm8gbGEgcmFkaW9tZXRyaWEgZSBsZSBjYXJhdHRlcmlzdGljaGUgc3BldHRyYWxpIGRlbGxlIGltbWFnaW5pIG11bHRpYmFuZGEsIGxlIGltbWFnaW5pIGNvbiBwYW4tc2hhcnBlbmluZyBkZXZvbm8gZXNzZXJlIHV0aWxpenphdGUgY29uIGNhdXRlbGEgcGVyIHNjb3BpIGRpIHRlbGVyaWxldmFtZW50byBhbmFsaXRpY28uPC9kaXY+XCIsXG5cdFx0cGF0aEFsbG9jYXRpb25OYW1lOiBcIkFzc2VnbmF6aW9uaSBkZWxsYSBEaXN0YW56YSBkZWwgUGVyY29yc29cIixcblx0XHRwYXRoQWxsb2NhdGlvblNuaXA6IFwiQ2FsY29sYSBsJ29yaWdpbmUgcGnDuSBlY29ub21pY2EgcGVyIG9nbmkgY2VsbGEgaW4gYmFzZSBhbCBtaW5vciBjb3N0byBjdW11bGF0aXZvIHN1IHVuYSBzdXBlcmZpY2llIGRpIGNvc3RvLCB0ZW5lbmRvIGNvbXVucXVlIGluIGNvbnNpZGVyYXppb25lIGkgZmF0dG9yaSByZWxhdGl2aSBhbGxhIGRpc3RhbnphIGRlbGxhIHN1cGVyZmljaWUgaW5zaWVtZSBhaSBjb3N0aSBvcml6em9udGFsZSBlIHZlcnRpY2FsZS5cIixcblx0XHRwYXRoQWxsb2NhdGlvbkRlc2M6IFwiTGEgZnVuemlvbmUgQXNzZWduYXppb25lIGRpc3RhbnphIGRpIHBlcmNvcnNvIGNhbGNvbGEgbCdvcmlnaW5lIHBpw7kgdmljaW5hIHBlciBvZ25pIGNlbGxhIGluIGJhc2UgYWwgY29zdG8gY3VtdWxhdGl2byBtaW5vcmUgc3UgdW5hIHN1cGVyZmljaWUgZGkgY29zdG8sIHRlbmVuZG8gY29udG8gZGVpIGZhdHRvcmkgcmVsYXRpdmkgYWxsYSBkaXN0YW56YSBkZWxsYSBzdXBlcmZpY2llIGUgYWwgY29zdG8gb3JpenpvbnRhbGUgZSB2ZXJ0aWNhbGUuXCIsXG5cdFx0cGF0aEJhY2tMaW5rTmFtZTogXCJCYWNrIExpbmsgRGlzdGFuemEgUGVyY29yc29cIixcblx0XHRwYXRoQmFja0xpbmtTbmlwOiBcIkRlZmluaXNjZSBsJ2VsZW1lbnRvIHZpY2lubyBjaGUgY29ycmlzcG9uZGUgYWxsYSBjZWxsYSBzdWNjZXNzaXZhIG5lbCBwZXJjb3JzbyBkaSBjb3N0byBjdW11bGF0aXZvIG1pbm9yZSBwZXIgbCdvcmlnaW5lIHBpw7kgZWNvbm9taWNhLCB0ZW5lbmRvIGNvbXVucXVlIGluIGNvbnNpZGVyYXppb25lIGkgZmF0dG9yaSByZWxhdGl2aSBhbGxhIGRpc3RhbnphIGRlbGxhIHN1cGVyZmljaWUgaW5zaWVtZSBhaSBjb3N0aSBvcml6em9udGFsZSBlIHZlcnRpY2FsZS5cIixcblx0XHRwYXRoQmFja0xpbmtEZXNjOiBcIkxhIGZ1bnppb25lIEJhY2tsaW5rIGRpc3RhbnphIGRpIHBlcmNvcnNvIGRlZmluaXNjZSBsYSBkaXJlemlvbmFsaXTDoCBkZWwgdmljaW5vIGNvcnJpc3BvbmRlbnRlIGFsbGEgY2VsbGEgc3VjY2Vzc2l2YSBuZWwgcGVyY29yc28gZGkgY29zdG8gY3VtdWxhdGl2byBtaW5vcmUgdmVyc28gbCdvcmlnaW5lIHBpw7kgdmljaW5hLCB0ZW5lbmRvIGNvbnRvIGRlaSBmYXR0b3JpIHJlbGF0aXZpIGFsbGEgZGlzdGFuemEgZGVsbGEgc3VwZXJmaWNpZSBlIGFsIGNvc3RvIG9yaXp6b250YWxlIGUgdmVydGljYWxlLlwiLFxuXHRcdHBhdGhEaXN0YW5jZU5hbWU6IFwiRGlzdGFuemEgUGVyY29yc29cIixcblx0XHRwYXRoRGlzdGFuY2VTbmlwOiBcIkNhbGNvbGEgcGVyIG9nbmkgY2VsbGEgbGEgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBtaW5vcmUgZGEgbyB2ZXJzbyBsJ29yaWdpbmUgcGnDuSBlY29ub21pY2EsIHRlbmVuZG8gY29udG8gZGVpIGZhdHRvcmkgcmVsYXRpdmkgYWxsYSBkaXN0YW56YSBkZWxsYSBzdXBlcmZpY2llIGUgYWwgY29zdG8gb3JpenpvbnRhbGUgZSB2ZXJ0aWNhbGUuXCIsXG5cdFx0cGF0aERpc3RhbmNlRGVzYzogXCJMYSBmdW56aW9uZSBEaXN0YW56YSBkaSBwZXJjb3JzbyBjYWxjb2xhIHBlciBvZ25pIGNlbGxhIGxhIGRpc3RhbnphIGRpIGNvc3RvIGN1bXVsYXRpdm8gbWlub3JlIHZlcnNvIGwnb3JpZ2luZSBwacO5IHZpY2luYSwgdGVuZW5kbyBjb250byBkZWkgZmF0dG9yaSByZWxhdGl2aSBhbGxhIGRpc3RhbnphIGRlbGxhIHN1cGVyZmljaWUgZSBhbCBjb3N0byBvcml6em9udGFsZSBlIHZlcnRpY2FsZS5cIixcblx0XHRwbHVzTmFtZTogXCJQbHVzXCIsXG5cdFx0cGx1c1NuaXA6IFwiQWdnaXVuZ2UgKHNvbW1hKSBpIHZhbG9yaSBkaSBkdWUgcmFzdGVyIGluIGJhc2UgYWxsZSBzaW5nb2xlIGNlbGxlLlwiLFxuXHRcdHBsdXNEZXNjOiBcIkxhIGZ1bnppb25lIFBpw7kgYWdnaXVuZ2UgKHNvbW1hKSBpIHZhbG9yaSBkaSBkdWUgcmFzdGVyIGluIGJhc2UgYWkgc2luZ29saSBwaXhlbC5cIixcblx0XHRwb3dlck5hbWU6IFwiUG90ZW56YVwiLFxuXHRcdHBvd2VyU25pcDogXCJFbGV2YSBpIHZhbG9yaSBkaSBjZWxsYSBpbiB1biByYXN0ZXIgYWxsYSBwb3RlbnphIGRlaSB2YWxvcmkgdHJvdmF0aSBpbiB1biBhbHRybyByYXN0ZXIuXCIsXG5cdFx0cG93ZXJEZXNjOiBcIkxhIGZ1bnppb25lIFBvdGVuemEgZWxldmEgaSB2YWxvcmkgZGkgcGl4ZWwgaW4gdW4gcmFzdGVyIGFsbGEgcG90ZW56YSBkZWkgdmFsb3JpIHRyb3ZhdGkgaW4gdW4gYWx0cm8gcmFzdGVyLlwiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25OYW1lOiBcIkNhbGlicmF6aW9uZSByYWRhclwiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25TbmlwOiBcIkNvbnZlcnRlIHJldHJvZGlmZnVzaW9uZSBSQURBUlNBVC0yLlwiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25EZXNjOiBcIlF1ZXN0YSBmdW56aW9uZSBwdcOyIGVzc2VyZSB1c2F0YSBwZXIgY2FsaWJyYXJlIGxlIGltbWFnaW5pIFJBREFSU0FULTIgaW4gdW4gbW9zYWljIGRhdGFzZXQgbyBjb21lIHByb2RvdHRvIGRpIHVuIHJhc3Rlci4gTGEgY2FsaWJyYXppb25lIHZpZW5lIGVzZWd1aXRhIHN1IGltbWFnaW5pIHJhZGFyIGluIG1vZG8gY2hlIGkgdmFsb3JpIGRlaSBwaXhlbCBzaWFubyB1bmEgcmFwcHJlc2VudGF6aW9uZSBmZWRlbGUgZGVsIHJldHJvZGlmZnVzaW9uZSByYWRhci5cIixcblx0XHRyYXN0ZXJJbmZvTmFtZTogXCJSYXN0ZXJJbmZvXCIsXG5cdFx0cmFzdGVySW5mb1NuaXA6IFwiTW9kaWZpY2EgbGUgcHJvcHJpZXTDoCBkZWwgcmFzdGVyLCBhZCBlc2VtcGlvIGxhIHByb2ZvbmRpdMOgIGluIGJpdCwgaWwgdmFsb3JlIE5vRGF0YSwgbGUgZGltZW5zaW9uaSBjZWxsYSBlIGNvc8OsIHZpYS5cIixcblx0XHRyYXN0ZXJJbmZvRGVzYzogXCJJbmZvIHJhc3RlciBhcHJlIHVuYSBmaW5lc3RyYSBkaSBkaWFsb2dvIGNvbnRlbmVudGUgbGUgcHJvcHJpZXTDoCBkZWkgZGF0YXNldCByYXN0ZXIsIGNvbWUgaWwgbnVtZXJvIGRpIGNvbG9ubmUgZSByaWdoZSwgaWwgbnVtZXJvIGRpIGJhbmRlLCBpbCB0aXBvIGRpIHBpeGVsLCBsJ2VzdGVuc2lvbmUgZSBpbCByaWZlcmltZW50byBzcGF6aWFsZS4gw4ggcG9zc2liaWxlIG1vZGlmaWNhcmUgcXVlc3RlIHByb3ByaWV0w6Agc2VsZXppb25hbmRvIHVuIGRhdGFzZXQgcmFzdGVyIGRhIHVzYXJlIGNvbWUgbW9kZWxsby4gXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc05hbWU6IFwiUmFzdGVyaXp6YSBhdHRyaWJ1dGlcIixcblx0XHRyYXN0ZXJpemVBdHRyaWJ1dGVzU25pcDogXCJBcnJpY2NoaXNjZSB1biByYXN0ZXIgY29uIGJhbmRlIGFnZ2l1bnRpdmUgZGVyaXZhdGUgZGEgdmFsb3JpIGRpIGF0dHJpYnV0aSBzcGVjaWZpY2F0aSBwcm92ZW5pZW50aSBkYSB1bmEgdGFiZWxsYSBlc3Rlcm5hIG8gZGEgdW4gZmVhdHVyZSBzZXJ2aWNlLlwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNEZXNjOiBcIkxhIGZ1bnppb25lIFJhc3Rlcml6emEgYXR0cmlidXRpIGFycmljY2hpc2NlIHVuIHJhc3RlciBhZ2dpdW5nZW5kbyBiYW5kZSBkZXJpdmF0ZSBkYSB2YWxvcmkgZGkgYXR0cmlidXRpIHNwZWNpZmljYXRpIGRhIHVuYSB0YWJlbGxhIGVzdGVybmEgbyB1biBmZWF0dXJlIHNlcnZpY2UuIMOIIHBvc3NpYmlsZSBzcGVjaWZpY2FyZSB1biByYXN0ZXIgem9uYSBlIGwnYXR0cmlidXRvIElEIHpvbmEgYXNzb2NpYXRvIHBlciBhYmlsaXRhcmUgbGUgcmljZXJjaGUgcGVyIHJlZ2lvbmUuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzTmFtZTogXCJSYXN0ZXJpenphIGZlYXR1cmVcIixcblx0XHRyYXN0ZXJpemVGZWF0dXJlQ2xhc3NTbmlwOiBcIkNvbnZlcnRlIGxlIGZlYXR1cmUgaW4gcmFzdGVyLlwiLFxuXHRcdHJhc3Rlcml6ZUZlYXR1cmVDbGFzc0Rlc2M6IFwiTGEgZnVuemlvbmUgY29udmVydGUgaSBkYXRpIGRpIGZlYXR1cmUgY2xhc3MgcG9saWdvbm8sIHBvbGlsaW5lYSBlIHB1bnRvIGluIHVuIGxheWVyIHJhc3Rlci48ZGl2Pjxici8+QWxsZSBmZWF0dXJlIHZlbmdvbm8gYXNzZWduYXRpIHZhbG9yaSBkZWkgcGl4ZWwgaW4gYmFzZSBhbGwnT0JKRUNUSUQgZGVsbGUgZmVhdHVyZSAoaW1wb3N0YXppb25lIHByZWRlZmluaXRhKS4gRmFjb2x0YXRpdmFtZW50ZSwgaSB2YWxvcmkgZGVpIHBpeGVsIHBvc3Nvbm8gZXNzZXJlIGJhc2F0aSBzdSB1biBjYW1wbyBkaSB2YWxvcmUgZGVmaW5pdG8gZGFsbCd1dGVudGUgbmVsbGEgdGFiZWxsYSBkZWdsaSBhdHRyaWJ1dGkgZGVsbGEgZmVhdHVyZSBkaSBpbnB1dC48L2Rpdj5cIixcblx0XHRyZWNhc3ROYW1lOiBcIlJlY2FzdFwiLFxuXHRcdHJlY2FzdFNuaXA6IFwiTW9kaWZpY2EgaSBwYXJhbWV0cmkgZGkgdW5hIGNhdGVuYSBkaSBmdW56aW9uaSBpbiB1biBtb3NhaWMgZGF0YXNldCBvIGluIHVuIGltYWdlIHNlcnZpY2UuIFZpZW5lIHNwZXNzbyB1c2F0YSBjb24gZGF0YXNldCBMQVMgcGVyIGV2aXRhcmUgZGkgZG92ZXIgY3JlYXJlIHVuIG1vc2FpYyBkYXRhc2V0IHNlcGFyYXRvIHBlciBkaXZlcnNlIHJhcHByZXNlbnRhemlvbmkgZGVsIHRlcnJlbm8uXCIsXG5cdFx0cmVjYXN0RGVzYzogXCJMYSBmdW56aW9uZSBSZWNhc3QgY29uc2VudGUgZGkgbW9kaWZpY2FyZSBkaW5hbWljYW1lbnRlIGlsIHBhcmFtZXRybyBkZWxsYSBmdW56aW9uZSB1c2F0YSBpbiB1biBtb3NhaWMgZGF0YXNldCBvIGluIHVuIGltYWdlIHNlcnZpY2Ugc2VuemEgY29uc2VydmFyZSBmaXNpY2FtZW50ZSBsZSBtb2RpZmljaGUuXCIsXG5cdFx0cmVnaW9uR3JvdXBOYW1lOiBcIkdydXBwbyBSZWdpb25lXCIsXG5cdFx0cmVnaW9uR3JvdXBTbmlwOiBcIlBlciBvZ25pIGNlbGxhIGRlbGwnb3V0cHV0IHZpZW5lIHJlZ2lzdHJhdGEgbCdpZGVudGl0w6AgZGVsbGEgcmVnaW9uZSBjb25uZXNzYSBjdWkgYXBwYXJ0aWVuZSBsYSBjZWxsYS4gQSBvZ25pIHJlZ2lvbmUgdmllbmUgYXNzZWduYXRvIHVuIG51bWVybyB1bml2b2NvLlwiLFxuXHRcdHJlZ2lvbkdyb3VwRGVzYzogXCJMYSBmdW56aW9uZSBnbG9iYWxlIEdydXBwbyByZWdpb25lIHJlZ2lzdHJhIHBlciBvZ25pIGNlbGxhIGRlbGwnb3V0cHV0IGwnaWRlbnRpdMOgIGRlbGxhIHJlZ2lvbmUgY29ubmVzc2EgY3VpIGFwcGFydGllbmUgbGEgY2VsbGEuIEEgb2duaSByZWdpb25lIHZpZW5lIGFzc2VnbmF0byB1biBudW1lcm8gdW5pdm9jby48ZGl2Pjxici8+TGEgcHJpbWEgcmVnaW9uZSBzY2Fuc2lvbmF0YSByaWNldmUgaWwgdmFsb3JlIHVubywgbGEgc2Vjb25kYSBpbCBkdWUgZSBjb3PDrCB2aWEgZmluY2jDqSBub24gdmllbmUgYXNzZWduYXRvIHVuIHZhbG9yZSBhIHR1dHRlIGxlIHJlZ2lvbmkuIElsIHByb2Nlc3NvIGRpIHNjYW5zaW9uZSBzaSBzcG9zdGEgZGEgc2luaXN0cmEgYSBkZXN0cmEsIGRhIHNvcHJhIGEgc290dG8uIEkgdmFsb3JpIGFzc2VnbmF0aSBhbGxlIHpvbmUgZGkgb3V0cHV0IHNpIGJhc2FubyBzdWxs4oCZb3JkaW5lIGRpIHJpbGV2YW1lbnRvIGRlbGxlIHN0ZXNzZSBkdXJhbnRlIGlsIHByb2Nlc3NvIGRpIHNjYW5zaW9uZS48L2Rpdj5cIixcblx0XHRyZWdpb25Hcm93TmFtZTogXCJBdW1lbnRvIHJlZ2lvbmVcIixcblx0XHRyZWdpb25Hcm93U25pcDogXCJBdW1lbnRhIGxlIHJlZ2lvbmkgZGEgcHVudGkgZGkgc2VlZC5cIixcblx0XHRyZWdpb25Hcm93RGVzYzogXCJMYSBmdW56aW9uZSBkaSBhdW1lbnRvIHJlZ2lvbmUgcmFnZ3J1cHBhIGkgcGl4ZWwgdmljaW5pIGluIGdydXBwaSBpbiBiYXNlIGFsIHJhZ2dpbyBzcGVjaWZpY2F0byBkYWwgcHVudG8gZGkgc2VlZC4gQWwgZ3J1cHBvIGRpIHBpeGVsIG8gb2dnZXR0byB2aWVuZSBhc3NlZ25hdG8gdW4gdmFsb3JlIGRpIHJpZW1waW1lbnRvIHNwZWNpZmljYXRvLlwiLFxuXHRcdHJlbWFwTmFtZTogXCJSaW1hcHBhXCIsXG5cdFx0cmVtYXBTbmlwOiBcIkNhbWJpYSBpIHZhbG9yaSBpbiBwaXhlbCBhc3NlZ25hbmRvIG51b3ZpIHZhbG9yaSBhIGludGVydmFsbGkgZGkgdmFsb3JpIGluIHBpeGVsIG8gdXRpbGl6emFuZG8gdW5hIHRhYmVsbGEgZXN0ZXJuYS5cIixcblx0XHRyZW1hcERlc2M6IFwiTGEgZnVuemlvbmUgUmltYXBwYSBjb25zZW50ZSBkaSBtb2RpZmljYXJlIG8gcmljbGFzc2lmaWNhcmUgaSB2YWxvcmkgZGVpIHBpeGVsIGRlaSBkYXRpIHJhc3Rlci4gUXVlc3RhIG9wZXJhemlvbmUgcHXDsiBlc3NlcmUgZXNlZ3VpdGEgc3BlY2lmaWNhbmRvIHVuIGludGVydmFsbG8gZGkgdmFsb3JpIGRlaSBwaXhlbCBkYSBtYXBwYXJlIGluIHVuIHZhbG9yZSBkaSBwaXhlbCBkaSBvdXRwdXQgbyB1dGlsaXp6YW5kbyB1bmEgdGFiZWxsYSBwZXIgbWFwcGFyZSBpIHZhbG9yaSBkZWkgcGl4ZWwgaW4gdW4gdmFsb3JlIHBpeGVsIGRpIG91dHB1dC5cIixcblx0XHRyZXByb2plY3ROYW1lOiBcIlJpcHJvaWV0dGFcIixcblx0XHRyZXByb2plY3RTbmlwOiBcIk1vZGlmaWNhIGxhIHByb2llemlvbmUgZGkgdW4gZGF0YXNldCByYXN0ZXIsIGRpIHVuIG1vc2FpYyBkYXRhc2V0IG8gZGkgdW4gZWxlbWVudG8gcmFzdGVyIGluIHVuIG1vc2FpYyBkYXRhc2V0LiBQdcOyIGFuY2hlIHJpY2FtcGlvbmFyZSBpIGRhdGkgaW4gdW5hIG51b3ZhIGRpbWVuc2lvbmUgY2VsbGEgZSBkZWZpbmlyZSB1bidvcmlnaW5lLlwiLFxuXHRcdHJlcHJvamVjdERlc2M6IFwiTGEgZnVuemlvbmUgUmlwcm9pZXR0YSBtb2RpZmljYSBsYSBwcm9pZXppb25lIGRpIHVuIHJhc3RlciBkYXRhc2V0LCB1biBtb3NhaWMgZGF0YXNldCBvIHVuIGVsZW1lbnRvIHJhc3RlciBpbiB1biBtb3NhaWMgZGF0YXNldC4gUHXDsiBhbmNoZSByaWNhbXBpb25hcmUgaSBkYXRpIGluIHVuYSBudW92YSBkaW1lbnNpb25lIGNlbGxhIGUgZGVmaW5pcmUgdW4nb3JpZ2luZS48ZGl2Pjxici8+TGEgZnVuemlvbmUgUmlwcm9pZXR0YSBwdcOyIGVzc2VyZSB1c2F0YSBxdWFuZG8gc2kgY3JlYSB1bmEgY2FjaGUgZGEgdW4gcmFzdGVyIG8gbW9zYWljIGRhdGFzZXQgY2hlIG5vbiBzaSB0cm92YSBuZWxsYSBwcm9pZXppb25lIHJpY2hpZXN0YS4gQWQgZXNlbXBpbywgcXVhbmRvIHNpIGNyZWEgdW4gaW1hZ2Ugc2VydmljZSBtZW1vcml6emF0byBuZWxsYSBjYWNoZSBjaGUgcG90cmViYmUgZXNzZXJlIGludGVncmF0byBkYSBhcHBsaWNhemlvbmkgY29uIGFsdHJpIHNlcnZpemkgbWVtb3JpenphdGkgbmVsbGEgY2FjaGUsIMOoIGltcG9ydGFudGUgY2hlIHNpIHRyb3Zpbm8gdHV0dGkgbmVsbGEgc3Rlc3NhIHByb2llemlvbmUuIFF1ZXN0YSDDqCBzcGVzc28gdW5hIHByb2llemlvbmUgV2ViIE1lcmNhdG9yLiBEYWwgbW9tZW50byBjaGUgbm9uIMOoIHBvc3NpYmlsZSByaXByb2lldHRhcmUgaWwgbW9zYWljIGRhdGFzZXQsIMOoIHBvc3NpYmlsZSByZWFsaXp6YXJlIHVuYSBkZWxsZSBkdWUgb3BlcmF6aW9uaSBzZWd1ZW50aTrigJRjcmVhcmUgdW4gbW9zYWljIGRhdGFzZXQgcHJvaWV0dGF0byBhIHBhcnRpcmUgZGFsIG1vc2FpYyBkYXRhc2V0IG5lbGxhIHByb2llemlvbmUgbmVjZXNzYXJpYSBvIGFnZ2l1bmdlcmUgbGEgZnVuemlvbmUgUmlwcm9pZXR0YSBhbGxhIGxpc3RhIGRpIGZ1bnppb25pIGRlbCBtb3NhaWMgZGF0YXNldC4gVW4gYWx0cm8gZXNlbXBpbyBkaSB1dGlsaXp6byBkaSBxdWVzdGEgZnVuemlvbmUgw6ggc3VsbCdlbGVtZW50byByYXN0ZXIgaW4gdW4gbW9zYWljIGRhdGFzZXQuIFF1YW5kbyBzaSB1c2EgbGEgZnVuemlvbmUgUmFzdGVyIG1lbW9yaXp6YXRvIG5lbGxhIGNhY2hlLCBzaSBwdcOyIHNjZWdsaWVyZSBkaSBpbnNlcmlyZSBsYSBmdW56aW9uZSBSaXByb2lldHRhIGluIG1vZG8gZGEgY3JlYXJlIGxhIGNhY2hlIG5lbGxhIG51b3ZhIHByb2llemlvbmUuIEdsaSBlbGVtZW50aSByYXN0ZXIgaW4gdW4gbW9zYWljIGRhdGFzZXQgcG9zc29ubyBlc3NlcmUgbWVtb3JpenphdGkgbmVsbGEgY2FjaGUgcXVhbmRvIGwnZWxhYm9yYXppb25lIMOoIGludGVuc2EgZSBzaSBzdGEgY2VyY2FuZG8gZGkgcHViYmxpY2FyZSB1biBpbWFnZSBzZXJ2aWNlIHZlbG9jZSwgc2VuemEgbWVtb3JpenphcmUgbCdpbnRlcm8gaW1hZ2Ugc2VydmljZSBuZWxsYSBjYWNoZS48L2Rpdj5cIixcblx0XHRyZXNhbXBsZU5hbWU6IFwiUmljYW1waW9uYVwiLFxuXHRcdHJlc2FtcGxlU25pcDogXCJDYW1iaWEgbGEgZGltZW5zaW9uZSBjZWxsYSBkaSB1biByYXN0ZXIuXCIsXG5cdFx0cmVzYW1wbGVEZXNjOiBcIkxhIGZ1bnppb25lIFJpY2FtcGlvbmEgbW9kaWZpY2EgbGEgZGltZW5zaW9uZSBkZWxsYSBjZWxsYSwgaWwgdGlwbyBkaSByaWNhbXBpb25hbWVudG8gbyBlbnRyYW1iaS48ZGl2Pjxici8+TGEgZnVuemlvbmUgUmljYW1waW9uYSBkZXZlIGVzc2VyZSB1c2F0YSBlc2NsdXNpdmFtZW50ZSBjb24gcmVxdWlzaXRpIGRpIGNhbGNvbG8gc3BlY2lmaWNpLCBhZCBlc2VtcGlvLCBpbiBjYXNvIGRpIGNhbGNvbG8gZGVsbGEgZ3JhbmRlenphLWRpcmV6aW9uZSBkZWwgdmVudG8gbyBkZWxsYSBjb3JyZW50ZSBjaGUgcmljaGllZGUgaWwgcmljYW1waW9uYW1lbnRvIGRhbGxhIHJpc29sdXppb25lIGRlbGwnb3JpZ2luZS48L2Rpdj5cIixcblx0XHRyb3VuZERvd25OYW1lOiBcIlJvdW5kIERvd25cIixcblx0XHRyb3VuZERvd25TbmlwOiBcIlJlc3RpdHVpc2NlIGlsIG51bWVybyBpbnRlcm8gc3VjY2Vzc2l2byBwacO5IGJhc3NvLCByYXBwcmVzZW50YXRvIGNvbWUgdW4gdmFsb3JlIGEgdmlyZ29sYSBtb2JpbGUsIHBlciBvZ25pIGNlbGxhIGluIHVuIHJhc3Rlci5cIixcblx0XHRyb3VuZERvd25EZXNjOiBcIkxhIGZ1bnppb25lIFJvdW5kIERvd24gcmVzdGl0dWlzY2UgaWwgbnVtZXJvIGludGVybyBzdWNjZXNzaXZvIHBpw7kgYmFzc28sIGNvbWUgdW4gdmFsb3JlIGEgdmlyZ29sYSBtb2JpbGUsIHBlciBvZ25pIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRyb3VuZFVwTmFtZTogXCJSb3VuZCBVcFwiLFxuXHRcdHJvdW5kVXBTbmlwOiBcIlJlc3RpdHVpc2NlIGlsIG51bWVybyBpbnRlcm8gc3VjY2Vzc2l2byBwacO5IGFsdG8sIHJhcHByZXNlbnRhdG8gY29tZSB1biB2YWxvcmUgYSB2aXJnb2xhIG1vYmlsZSwgcGVyIG9nbmkgY2VsbGEgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdHJvdW5kVXBEZXNjOiBcIkxhIGZ1bnppb25lIFJvdW5kIFVwIHJlc3RpdHVpc2NlIGlsIG51bWVybyBpbnRlcm8gc3VjY2Vzc2l2byBwacO5IGFsdG8sIGNvbWUgdW4gdmFsb3JlIGEgdmlyZ29sYSBtb2JpbGUsIHBlciBvZ25pIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRzZWdtZW50TWVhblNoaWZ0TmFtZTogXCJTZWdtZW50YSBTcG9zdGFtZW50byBNZWRpb1wiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnRTbmlwOiBcIlJhZ2dydXBwYSBwaXhlbCB2aWNpbmkgY29uIGNhcmF0dGVyaXN0aWNoZSBzcGV0dHJhbGkgc2ltaWxpIGluIHNlZ21lbnRpLlwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnREZXNjOiBcIlF1ZXN0YSBmdW56aW9uZSBpZGVudGlmaWNhIG9nZ2V0dGksIGZlYXR1cmUgbyBzZWdtZW50aSBuZWxsZSBpbW1hZ2luaSByYWdncnVwcGFuZG8gcGl4ZWwgYWRpYWNlbnRpIGNvbiBjYXJhdHRlcmlzdGljaGUgc3BldHRyYWxpIGUgc3BhemlhbGkgc2ltaWxpLiDDiCBwb3NzaWJpbGUgY29udHJvbGxhcmUgbGEgcXVhbnRpdMOgIGRpIHNtdXNzYW1lbnRvIHNwYXppYWxlIGUgc3BldHRyYWxlIHBlciBkZXJpdmFyZSBwacO5IGZhY2lsbWVudGUgbGUgZmVhdHVyZSBkaSBpbnRlcmVzc2UuXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uTmFtZTogXCJTZW50aW5lbC0xIENhbGlicmF6aW9uZSByYWRpb21ldHJpY2FcIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25TbmlwOiBcIkVzZWd1ZSB2YXJpIHRpcGkgZGkgY2FsaWJyYXppb25lIHJhZGlvbWV0cmljYSBzdWkgZGF0aSBTZW50aW5lbC0xLlwiLFxuXHRcdHMxUmFkaW9tZXRyaWNDYWxpYnJhdGlvbkRlc2M6IFwiUXVlc3RhIGZ1bnppb25lIHJhc3RlciBlc2VndWUgdHJlIGRpdmVyc2UgY2FsaWJyYXppb25pIHBlciBpIGRhdGFzZXQgU2VudGluZWwgMSwgdHJhIGN1aSBsYSBjYWxpYnJhemlvbmUgYmV0YSBub3VnaHQgZSBnYW1tYSwgZSByZXN0aXR1aXNjZSBpbCBkYXRhc2V0IGNhbGlicmF0by4gTCdvYmlldHRpdm8gZGVsbGEgY2FsaWJyYXppb25lIFNBUiDDqCBxdWVsbG8gZGkgZm9ybmlyZSBpbW1hZ2luaSBpbiBjdWkgaSB2YWxvcmkgZGVpIHBpeGVsIHBvc3Nvbm8gZXNzZXJlIGNvcnJlbGF0aSBkaXJldHRhbWVudGUgYWxsYSByZXRyb2RpZmZ1c2lvbmUgcmFkYXIgZGVsbGEgc2NlbmEuIFNlYmJlbmUgcGVyIGzigJl1c28gcXVhbGl0YXRpdm8gc2lhbm8gc3VmZmljaWVudGkgaW1tYWdpbmkgU0FSIG5vbiBjYWxpYnJhdGUsIGwndXNvIHF1YW50aXRhdGl2byBkZWkgZGF0aSBTQVIgcmljaGllZGUgaW1tYWdpbmkgU0FSIGNhbGlicmF0ZS48ZGl2Pjxici8+TCdlbGFib3JhemlvbmUgdGlwaWNhIGRlaSBkYXRpIFNBUiwgY2hlIHByb2R1Y2UgaW1tYWdpbmkgZGkgbGl2ZWxsbyAxLCBub24gaW5jbHVkZSBsZSBjb3JyZXppb25pIHJhZGlvbWV0cmljaGUgZSBpIHJlc3RpIGRpIGJpYXMgcmFkaW9tZXRyaWNpIHNpZ25pZmljYXRpdmkuIFBlcnRhbnRvLCDDqCBuZWNlc3NhcmlvIGFwcGxpY2FyZSBsYSBjb3JyZXppb25lIHJhZGlvbWV0cmljYSBhbGxlIGltbWFnaW5pIFNBUiBpbiBtb2RvIGNoZSBpIHZhbG9yaSBkZWkgcGl4ZWwgZGVsbGUgaW1tYWdpbmkgcmFwcHJlc2VudGlubyByZWFsbWVudGUgaWxhIHJldHJvZGlmZnVzaW9uZSByYWRhciBkZWxsYSBzdXBlcmZpY2llIHJpZmxldHRlbnRlLiBMYSBjb3JyZXppb25lIHJhZGlvbWV0cmljYSDDqCBuZWNlc3NhcmlhLCBpbm9sdHJlLCBwZXIgZXNlZ3VpcmUgaWwgY29uZnJvbnRvIGRpIGltbWFnaW5pIFNBUiBhY3F1aXNpdGUgY29uIHNlbnNvcmkgZGl2ZXJzaSwgYWNxdWlzaXRlIGRhbGxvIHN0ZXNzbyBzZW5zb3JlIG1hIGluIG1vbWVudGkgZGl2ZXJzaSBvIGluIG1vZGFsaXTDoCBkaXZlcnNlLCBvcHB1cmUgZWxhYm9yYXRlIGRhIHByb2Nlc3NvcmkgZGl2ZXJzaS48L2Rpdj5cIixcblx0XHRzMVRoZXJtYWxOb2lzZVJlbW92YWxOYW1lOiBcIlNlbnRpbmVsLTEgUmltb3ppb25lIGRlbCBydW1vcmUgdGVybWljb1wiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbFNuaXA6IFwiUmltdW92ZSBpbCBydW1vcmUgdGVybWljbyBkYWkgZGF0aSBTZW50aW5lbC0xLlwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbERlc2M6IFwiTGEgY29ycmV6aW9uZSBkZWwgcnVtb3JlIHRlcm1pY28gcHXDsiBlc3NlcmUgYXBwbGljYXRhIGFpIHByb2RvdHRpIFNlbnRpbmVsLTEgTGV2ZWwtMSBTaW5nbGUgTG9vayBDb21wbGV4IChTTEMpIGUgYWkgcHJvZG90dGkgTGV2ZWwtMSBHcm91bmQgUmFuZ2UgRGV0ZWN0aW9uIChHUkQpIG5vbiBhbmNvcmEgY29ycmV0dGkuIElub2x0cmUsIGzigJlvcGVyYXRvcmUgcHXDsiByaW11b3ZlcmUgcXVlc3RhIGNvcnJlemlvbmUgaW4gYmFzZSBhbGxlIGFubm90YXppb25pIGRlbCBwcm9kb3R0byBhbCBmaW5lIGRpIHJlaW50cm9kdXJyZSBpbCBzZWduYWxlIGRpIHJ1bW9yZSByaW1vc3NvIGUgcmlwcm9kdXJyZSBpbCBwcm9kb3R0byBvcmlnaW5hbGUuIExlIGFubm90YXppb25pIGRlbCBwcm9kb3R0byBzYXJhbm5vIGFnZ2lvcm5hdGUgZGkgY29uc2VndWVuemEgcGVyIGNvbnNlbnRpcmUgbGEgcmlhcHBsaWNhemlvbmUgZGVsbGEgY29ycmV6aW9uZS4gXCIsXG5cdFx0c2V0TnVsbE5hbWU6IFwiSW1wb3N0YSBOdWxsXCIsXG5cdFx0c2V0TnVsbFNuaXA6IFwiSW1wb3N0YSBOdWxsIGNvbnNlbnRlIGRpIGltcG9zdGFyZSBsZSBwb3NpemlvbmkgZGVsbGUgY2VsbGUgaWRlbnRpZmljYXRlIHN1IE5vRGF0YSBpbiBiYXNlIGEgdW4gY3JpdGVyaW8gc3BlY2lmaWNhdG8uIFJlc3RpdHVpc2NlIE5vRGF0YSBzZSB1bmEgdmFsdXRhemlvbmUgY29uZGl6aW9uYWxlIMOoIFRydWU7IHJlc3RpdHVpc2NlIGlsIHZhbG9yZSBzcGVjaWZpY2F0byBkYSB1biBhbHRybyByYXN0ZXIgc2Ugw6ggRmFsc2UuXCIsXG5cdFx0c2V0TnVsbERlc2M6IFwiTGEgZnVuemlvbmUgSW1wb3N0YSBOdWxsIGNvbnNlbnRlIGRpIGltcG9zdGFyZSBpIHBpeGVsIGlkZW50aWZpY2F0aSBjb21lIE5vRGF0YSBpbiBiYXNlIGEgdW4gY3JpdGVyaW8gc3BlY2lmaWNvLiBSZXN0aXR1aXNjZSBOb0RhdGEgc2UgdW5hIHZhbHV0YXppb25lIGNvbmRpemlvbmFsZSDDqCB0cnVlICgxKTsgcmVzdGl0dWlzY2UgaWwgdmFsb3JlIHNwZWNpZmljYXRvIG5lbCBGYWxzZSBSYXN0ZXIgc2UgdW5hIHZhbHV0YXppb25lIGNvbmRpemlvbmFsZSDDqCBmYWxzZSAoMCkuIFF1ZXN0byBjcml0ZXJpbyDDqCBzcGVjaWZpY2F0byBkYWxsJ291dHB1dCBkaSB1bmEgZnVuemlvbmUgbWF0ZW1hdGljYSBsb2dpY2EsIGNoZSBzYXLDoCBpbCByYXN0ZXIgZGkgaW5wdXQuXCIsXG5cdFx0c2hhZGVkUmVsaWVmTmFtZTogXCJSaWxpZXZvIG9tYnJlZ2dpYXRvXCIsXG5cdFx0c2hhZGVkUmVsaWVmU25pcDogXCJDcmVhIHVuYSByYXBwcmVzZW50YXppb25lIDNELCBtdWx0aWJhbmRhLCBjb2RpZmljYXRhIGEgY29sb3JpIGRlbGxhIHN1cGVyZmljaWUsIHRlbmVuZG8gY29udG8gZGVsbGEgcG9zaXppb25lIHJlbGF0aXZhIGRlbCBzb2xlIHBlciBsJ29tYnJlZ2dpYXR1cmEgZGVsbCdpbW1hZ2luZS5cIixcblx0XHRzaGFkZWRSZWxpZWZEZXNjOiBcIkxhIGZ1bnppb25lIFJpbGlldm8gb21icmVnZ2lhdG8gw6ggdW5hIHJhcHByZXNlbnRhemlvbmUgM0QgYSBjb2xvcmkgZGVsIHRlcnJlbm8sIGNyZWF0YSB1bmVuZG8gbGUgaW1tYWdpbmkgZGVpIG1ldG9kaSBjb2RpZmljYXRpIHBlciBlbGV2YXppb25lIGUgcmlsaWV2byBvbWJyZWdnaWF0by4gUXVlc3RhIGZ1bnppb25lIHVzYSBsZSBwcm9wcmlldMOgIGRlbGwnYWx0aXR1ZGluZSBlIGRlbGwnYXppbXV0IHBlciBzcGVjaWZpY2FyZSBsYSBwb3NpemlvbmUgZGVsIHNvbGUuPGRpdj48YnIvPjwvZGl2PlwiLFxuXHRcdHNpbkhOYW1lOiBcIlNpbkhcIixcblx0XHRzaW5IU25pcDogXCJDYWxjb2xhIGlsIHNlbm8gaXBlcmJvbGljbyBkaSBjZWxsZSBpbiB1biByYXN0ZXIuXCIsXG5cdFx0c2luSERlc2M6IFwiTGEgZnVuemlvbmUgY2FsY29sYSBpbCBzZW5vIGlwZXJib2xpY28gZGVpIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRzaW5OYW1lOiBcIlNpblwiLFxuXHRcdHNpblNuaXA6IFwiQ2FsY29sYSBpbCBzZW5vIGRpIGNlbGxlIGluIHVuIHJhc3Rlci5cIixcblx0XHRzaW5EZXNjOiBcIkxhIGZ1bnppb25lIGNhbGNvbGEgaWwgc2VubyBkZWkgcGl4ZWwgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdHNsb3BlTmFtZTogXCJQZW5kZW56YVwiLFxuXHRcdHNsb3BlU25pcDogXCJDYWxjb2xhIGxhIHBlcmNlbnR1YWxlIGRpIHZhcmlhemlvbmUgZGEgdW4gdmFsb3JlIGluIHBpeGVsIHJpc3BldHRvIGFpIHN1b2kgdmljaW5pLlwiLFxuXHRcdHNsb3BlRGVzYzogXCJRdWVzdGEgZnVuemlvbmUgcmFzdGVyIGNhbGNvbGEgbGEgcGVuZGVuemEsIGNoZSBlcXVpdmFsZSBhbGxhIHBlcmNlbnR1YWxlIGRpIHZhcmlhemlvbmUgZGVsbCdlbGV2YXppb25lIHBlciBvZ25pIGNlbGxhIGRlbCBtb2RlbGxvIGRpZ2l0YWxlIGRpIGVsZXZhemlvbmUgKERFTSkuIMOIIGxhIHByaW1hIGRlcml2YXRhIGRpIHVuIERFTS48ZGl2Pjxici8+UXVlc3RhIGZ1bnppb25lIHVzYSB1bmEgZnVuemlvbmUgYXRhbigpIGFjY2VsZXJhdGEuIMOIIHNlaSB2b2x0ZSBwacO5IHZlbG9jZSBlIGwnZXJyb3JlIGRpIGFwcHJvc3NpbWF6aW9uZSDDqCBzZW1wcmUgbWlub3JlIGRpIDAsMyBncmFkaS48L2Rpdj5cIixcblx0XHRzcGVja2xlTmFtZTogXCJSdW1vcmUgbW9sdGlwbGljYXRpdm9cIixcblx0XHRzcGVja2xlU25pcDogXCJGb3JuaXNjZSBmaWx0cmkgcGVyIHJpZHVycmUgaWwgcnVtb3JlIGluIGRhdGFzZXQgZGkgcmFkYXIgYWQgYXBlcnR1cmEgc2ludGV0aWNhLlwiLFxuXHRcdHNwZWNrbGVEZXNjOiBcIklsIHJ1bW9yZSBtb2x0aXBsaWNhdGl2byDDqCBpbCBydW1vcmUgYWQgYWx0YSBmcmVxdWVuemEgbmVpIGRhdGkgZGVsIHJhZGFyLiBMZSBpbW1hZ2luaSBnZW5lcmF0ZSBkYWkgc2lzdGVtaSByYWRhciBhZCBhcGVydHVyYSBzaW50ZXRpY2EgKFNBUikgc29ubyBmb3J0ZW1lbnRlIHNvZ2dldHRlIGEgZWZmZXR0aSBkaSBydW1vcmUgbW9sdGlwbGljYXRpdm8gZG92dXRpIGFsbCdlbGFib3JhemlvbmUgZGkgc2VnbmFsaSBzcGFyc2kgZSBhbGwnaW50ZXJmZXJlbnphIGRpIG9uZGUgZWxldHRyb21hZ25ldGljaGUgZGlmZnVzZSBkYSBzdXBlcmZpY2kgb2Qgb2dnZXR0aS4gTGEgZnVuemlvbmUgUnVtb3JlIG1vbHRpcGxpY2F0aXZvIGZpbHRyYSBpbCBkYXRhc2V0IGRlbCByYWRhciBzb2dnZXR0byBhIHJ1bW9yZSBtb2x0aXBsaWNhdGl2byBwZXIgYXR0ZW51YXJlIGlsIHJ1bW9yZSBtYW50ZW5lbmRvIGdsaSBlZGdlIG8gbGUgZmVhdHVyZSBuaXRpZGUgbmVsbOKAmWltbWFnaW5lLlwiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvbk5hbWU6IFwiQ29udmVyc2lvbmUgc3BldHRyYWxlXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uU25pcDogXCJBcHBsaWNhIHVuYSBtYXRyaWNlIGEgdW7igJlpbW1hZ2luZSBtdWx0aWJhbmRhLlwiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvbkRlc2M6IFwiTGEgZnVuemlvbmUgQ29udmVyc2lvbmUgc3BldHRyYWxlIGFwcGxpY2EgdW5hIG1hdHJpY2UgYSB1bidpbW1hZ2luZSBtdWx0aWJhbmRhIHBlciBpbmZsdWVuemFyZSBpIHZhbG9yaSBkaSBjb2xvcmUgZGVsbCdvdXRwdXQuPGRpdj48YnIvPkFsY3VuaSBzZW5zb3JpIG5vbiByaWxldmFubyBsZSBiYW5kZSBibHUgYSBjYXVzYSBkZWwgYmFzc28gcmFwcG9ydG8gc2VnbmFsZS1kaXN0dXJiby4gUXVlc3RhIHRlY25pY2EgcHXDsiBlc3NlcmUgdXRpbGl6emF0YSBwZXIgY29udmVydGlyZSB1bidpbW1hZ2luZSBhIGluZnJhcm9zc2kgY29uIGNvbG9yaSBmYWxzaSBpbiB1bidpbW1hZ2luZSBhIGNvbG9yaSBwc2V1ZG9uYXR1cmFsZS48L2Rpdj5cIixcblx0XHRzcXVhcmVSb290TmFtZTogXCJTcXVhcmUgUm9vdFwiLFxuXHRcdHNxdWFyZVJvb3RTbmlwOiBcIkNhbGNvbGEgbGEgcmFkaWNlIHF1YWRyYXRhIGRlaSB2YWxvcmkgZGkgY2VsbGEgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdHNxdWFyZVJvb3REZXNjOiBcIkxhIGZ1bnppb25lIFJhZGljZSBxdWFkcmF0YSBjYWxjb2xhIGxhIHJhZGljZSBxdWFkcmF0YSBkZWkgdmFsb3JpIGRlaSBwaXhlbCBpbiB1biByYXN0ZXIuXCIsXG5cdFx0c3F1YXJlTmFtZTogXCJTcXVhcmVcIixcblx0XHRzcXVhcmVTbmlwOiBcIkNhbGNvbGEgaWwgcXVhZHJhdG8gZGVpIHZhbG9yaSBkaSBjZWxsYSBpbiB1biByYXN0ZXIuXCIsXG5cdFx0c3F1YXJlRGVzYzogXCJMYSBmdW56aW9uZSBRdWFkcmF0byBjYWxjb2xhIGlsIHF1YWRyYXRvIGRlaSB2YWxvcmkgZGVpIHBpeGVsIGluIHVuIHJhc3Rlci5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtTmFtZTogXCJTdGF0aXN0aWNoZSBlIElzdG9ncmFtbWFcIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtU25pcDogXCJEZWZpbmlyZSBvIGFzc29jaWFyZSBzdGF0aXN0aWNoZSBlIGlzdG9ncmFtbWEuXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbURlc2M6IFwiTGEgZnVuemlvbmUgU3RhdGlzdGljaGUgZSBJc3RvZ3JhbW1pIHZpZW5lIHV0aWxpenphdGEgcGVyIGRlZmluaXJlIGxlIHN0YXRpc3RpY2hlIGUgbOKAmWlzdG9ncmFtbWEgZGkgdW4gcmFzdGVyLiDDiCBwb3NzaWJpbGUgaW5zZXJpcmUgcXVlc3RhIGZ1bnppb25lIGFsbGEgZmluZSBkZWxsYSBjYXRlbmEgZGkgZnVuemlvbmkgcGVyIGRlc2NyaXZlcmUgbGUgc3RhdGlzdGljaGUgZSBs4oCZaXN0b2dyYW1tYSBkaSB1biBtb2RlbGxvIGRpIFJhc3RlciBGdW5jdGlvbiAoUkZUKS4gQ2nDsiBwdcOyIGVzc2VyZSBuZWNlc3NhcmlvIHBlciBjb250cm9sbGFyZSBsYSB2aXN1YWxpenphemlvbmUgcHJlZGVmaW5pdGEgZGVsIHJpc3VsdGF0byBkZWxs4oCZZWxhYm9yYXppb25lLCBzcGVjaWFsbWVudGUgcXVhbmRvIHNpIGRlZmluaXNjZSB1bmEgY2F0ZW5hIGRpIGZ1bnppb25pIGNoZSBjb250aWVuZSBtb2x0ZSBmdW56aW9uaS48ZGl2Pjxici8+w4ggcG9zc2liaWxlIGRlZmluaXJlIHN0YXRpc3RpY2hlIGRpZ2l0YW5kbyBpIHZhbG9yaSBvIGltcG9ydGFuZG8gZGEgdW4gZGF0YXNldCByYXN0ZXIgbyB1biBmaWxlIFhNTC4gR2xpIGlzdG9ncmFtbWkgcG9zc29ubyBlc3NlcmUgZGVmaW5pdGkgc29sbyBpbXBvcnRhbmRvIHVuIGZpbGUuPC9kaXY+XCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGljaGVcIixcblx0XHRzdGF0aXN0aWNzU25pcDogXCJDYWxjb2xhIGxlIHN0YXRpc3RpY2hlIGRlbGxhIGZvY2FsZSBwZXIgb2duaSBwaXhlbCBkaSB1bidpbW1hZ2luZSBpbiBiYXNlIGFnbGkgZWxlbWVudGkgdmljaW5pIGNvbiBmb2NhbGUgZGVmaW5pdGEuXCIsXG5cdFx0c3RhdGlzdGljc0Rlc2M6IFwiTGEgZnVuemlvbmUgU3RhdGlzdGljaGUgY2FsY29sYSBsZSBzdGF0aXN0aWNoZSBkZWxsYSBmb2NhbGUgcGVyIG9nbmkgcGl4ZWwgZGkgdW4naW1tYWdpbmUgaW4gYmFzZSBhZ2xpIGVsZW1lbnRpIHZpY2luaSBjb24gZm9jYWxlIGRlZmluaXRhLjxkaXY+PGJyLz5MYSBmdW56aW9uZSBTdGF0aXN0aWNzIHB1w7IgZXNzZXJlIHVzYXRhIHBlciByaWVtcGlyZSBkZWxsZSBsaW5lZSByaW1vc3NlIGluIHVuJ2ltbWFnaW5lLiBMZSBsaW5lZSByaW1vc3NlIHNvbm8gc3Blc3NvIGNhdXNhdGUgZGEgcHJvYmxlbWkgYWwgc2Vuc29yZSBsYWRkb3ZlIG5vbiBzaSByYWNjb2xnb25vIGRhdGkuIENpw7Igc2kgw6ggdmVyaWZpY2F0byBpbiBzZW5zb3JpIGNvbWUgRW5oYW5jZWQgVGhlbWF0aWMgTWFwcGVyIFBsdXMgKEVUTSspIGRpIExhbmRzYXQgNy4gIEkgZGF0aSBtYW5jYW50aSBjYXVzYW5vIHByb2JsZW1pIHBlciBsJ2FuYWxpc2ksIG5vbmNow6kgcXVhbmRvIHNpIGd1YXJkYW5vIGxlIGltbWFnaW5pLiBRdWFuZG8gc2kgdXNhbm8gbGUgaW1tYWdpbmkgcGVyIHVuJ2FuYWxpc2kgbm9uIGVzaXN0b25vIGludGVydmVudGkgcmlzb2x1dG9yaTsgdHV0dGF2aWEsIG5lbCBjYXNvIGluIGN1aSBlc2lzdGEgdW4naW1tYWdpbmUgc292cmFwcG9zdGEsIMOoIHBvc3NpYmlsZSB1c2FybGEgYWwgcG9zdG8gZGVsIGNvbnRlbnV0byBtYW5jYW50ZS4gw4ggcG9zc2liaWxlIGVzZWd1aXJlIGxhIHN0ZXNzYSBvcGVyYXppb25lIHNlIHNpIHVzYSBsJ2ltbWFnaW5lIHBlciBsYSB2aXN1YWxpenphemlvbmUuIFR1dHRhdmlhLCBub24gZXNpc3RlIHNlbXByZSB1bidpbW1hZ2luZSBhZ2dpdW50aXZhIHBlciByaWVtcGlyZSBpbCBjb250ZW51dG8gbWFuY2FudGUsIHBlcnRhbnRvIGRldmUgZXNzZXJlIGRlcml2YXRhIGRhaSBkYXRpIGVzaXN0ZW50aS48L2Rpdj5cIixcblx0XHRzdHJlYW1MaW5rTmFtZTogXCJDb2xsZWdhbWVudG8gZmx1c3NvXCIsXG5cdFx0c3RyZWFtTGlua1NuaXA6IFwiQXNzZWduYSB2YWxvcmkgdW5pdm9jaSBhbGxlIHNlemlvbmkgZGkgdW5hIHJldGUgbGluZWFyZSByYXN0ZXIgdHJhIGxlIGludGVyc2V6aW9uaS5cIixcblx0XHRzdHJlYW1MaW5rRGVzYzogXCJMYSBmdW56aW9uZSBnbG9iYWxlIENvbGxlZ2FtZW50byBmbHVzc28gYXNzZWduYSB2YWxvcmkgdW5pdm9jaSBhbGxlIHNlemlvbmkgZGkgdW5hIHJldGUgbGluZWFyZSByYXN0ZXIgdHJhIGxlIGludGVyc2V6aW9uaS48ZGl2Pjxici8+SSBjb2xsZWdhbWVudGkgc29ubyBsZSBzZXppb25pIGRpIHVuIGNhbmFsZSBkaSBmbHVzc28gY2hlIGNvbGxlZ2EgZHVlIG5vZGkgY2hlIHNpIHN1c3NlZ3Vvbm8sIHVuIG5vZG8gZSBsbyBzYm9jY28sIG8gdW4gbm9kbyBlIGxvIHNwYXJ0aWFjcXVlIGRpIGRyZW5hZ2dpby4gSW4gaWRyb2xvZ2lhLCBxdWVzdGkgc2VnbWVudGkgZGkgZmx1c3NvIHNvbm8gY2hpYW1hdGkgdHJhdHRpLiBVbiBub2RvIGZhIHJpZmVyaW1lbnRvIGEgdW4gcHVudG8gZGkgdmVyc2FtZW50byBlIGFpdXRhIGEgZGVsaW5lYXJlIHVubyBzcGFydGlhY3F1ZSBvIHVuIGxpbWl0ZSBkZWwgc290dG9iYWNpbm8gZGkgZHJlbmFnZ2lvLjwvZGl2PlwiLFxuXHRcdHN0cmV0Y2hOYW1lOiBcIkVzdGVuZGVcIixcblx0XHRzdHJldGNoU25pcDogXCJNaWdsaW9yYSB1buKAmWltbWFnaW5lIHJlZ29sYW5kbyBs4oCZaW50ZXJ2YWxsbyBkZWkgdmFsb3JpIHZpc3VhbGl6emF0aS4gSSB2YWxvcmkgZGVpIHBpeGVsIHNvdHRvc3RhbnRpIG5vbiB2ZW5nb25vIGFsdGVyYXRpLiBTZSB1biBwaXhlbCBoYSB1biB2YWxvcmUgYWwgZGkgZnVvcmkgZGVsbCdpbnRlcnZhbGxvIHNwZWNpZmljYXRvLCB2ZXJyw6AgdmlzdWFsaXp6YXRvIGNvbWUgdmFsb3JlIG1pbmltbyBvIG1hc3NpbW8uXCIsXG5cdFx0c3RyZXRjaERlc2M6IFwiTGEgZnVuemlvbmUgU3RyZXRjaCBtaWdsaW9yYSB1bidpbW1hZ2luZSBtb2RpZmljYW5kbyBwcm9wcmlldMOgIGNvbWUgbHVtaW5vc2l0w6AsIGNvbnRyYXN0byBlIGdhbW1hIHRyYW1pdGUgdmFyaSB0aXBpIGRpIGVzdGVuc2lvbmUuIFF1ZXN0YSBmdW56aW9uZSB1c2EgbGUgc3RhdGlzdGljaGUgZGVpIHJhc3RlciBjb250ZW51dGkgbmVsIG1vc2FpYyBkYXRhc2V0OyBwZXJ0YW50bywgcHJpbWEgZGkgdXNhcmUgcXVlc3RhIGZ1bnppb25lLCDDqCBuZWNlc3NhcmlvIGFzc2ljdXJhcnNpIGNoZSBsZSBzdGF0aXN0aWNoZSBzaWFubyBzdGF0ZSBjYWxjb2xhdGUuPGRpdj48YnIvPklsIHRpcG8gZGkgZXN0ZW5zaW9uZSBkZWZpbmlzY2UgdW4nZXN0ZW5zaW9uZSBkaSBpc3RvZ3JhbW1hIGNoZSBzYXLDoCBhcHBsaWNhdGEgYWkgcmFzdGVyIHBlciBtaWdsaW9yYXJuZSBsJ2FzcGV0dG8uIEzigJlhcHBsaWNhemlvbmUgZGVsbOKAmWVzdGVuc2lvbmUgbWlnbGlvcmEgbOKAmWFzcGV0dG8gZGVpIGRhdGkgZGlzdHJpYnVlbmRvIGkgdmFsb3JpIGRlaSBwaXhlbCBsdW5nbyB1biBpc3RvZ3JhbW1hIGRhaSB2YWxvcmkgbWluaW1pIGEgcXVlbGxpIG1hc3NpbWksIGluIGJhc2UgYWxsYSBwcm9mb25kaXTDoCBpbiBiaXQuIDwvZGl2PlwiLFxuXHRcdHN3YXRoTmFtZTogXCJDb250cmFzc2VnbmFcIixcblx0XHRzd2F0aFNuaXA6IFwiSW50ZXJwb2xhIGRhIGdyaWdsaWUgaXJyZWdvbGFyaSBvIGRhdGkgY29udHJhc3NlZ25hdGkuXCIsXG5cdFx0c3dhdGhEZXNjOiBcIkFsY3VuaSBkYXRhc2V0IG5ldENERiBvIEhERiBhcmNoaXZpYW5vIGxhIGxvcm8gZ2VvcG9zaXppb25lIGNvbWUgYXJyYXkgaXJyZWdvbGFybWVudGUgc3BhemlhdGkuIFF1YW5kbyBzaSBhZ2dpdW5nbyBxdWVzdGkgZGF0YXNldCBhIHVuIGRhdGFzZXQgZGkgbW9zYWljbywgbGEgZnVuemlvbmUgU3dhdGggcHJlbmRlIGkgZGF0aSByZXRpY29sYXRpIGlycmVnb2xhcm1lbnRlIGUgbGkgcmljYW1waW9uYSBpbiBtb2RvIGNoZSBvZ25pIHBpeGVsIHNpYSBkaSBkaW1lbnNpb25lIHVuaWZvcm1lIGUgcXVhZHJhdG8uPGRpdj48YnIvPlF1YW5kbyBzaSBhZ2dpdW5nb25vIHZhcmlhYmlsaSBkYSBuZXRDREYgbyBIREYgYSB1biBtb3NhaWMgZGF0YXNldCwgc2kgdmVyaWZpY2hlcsOgIGF1dG9tYXRpY2FtZW50ZSBzZSBpIGRhdGkgc29ubyBkaXNwb3N0aSByZWdvbGFybWVudGUgbmVsbCdhcnJheS4gSW4gY2FzbyBjb250cmFyaW8sIHNpIGFwcGxpY2EgYXV0b21hdGljYW1lbnRlIGxhIGZ1bnppb25lIFN3YXRoIHBlciBjb252ZXJ0aXJlIGlsIHJhc3RlciBpcnJlZ29sYXJlIGluIHB1bnRpIGUsIHF1aW5kaSwgaW4gdW4gcmFzdGVyIHJlZ29sYXJtZW50ZSByZXRpY29sYXRvLiDDiCBwb3NzaWJpbGUgY2FtYmlhcmUgaWwgbWV0b2RvIGRpIGludGVycG9sYXppb25lIGUgbGEgZGltZW5zaW9uZSBkZWxsZSBjZWxsZSB1c2F0aSBuZWxsYSBmdW56aW9uZSByYXN0ZXIgU3dhdGguIFBlciBkYXRpIHJhc3RlciBzcGF6aWF0aSBpbiBtb2RvIHJlZ29sYXJlLCBub24gc2kgYXBwbGljaGVyw6AgbmVzc3VuYSBpbnRlcnBvbGF6aW9uZSwgaSBkYXRpIHNhcmFubm8gbGV0dGkgY29zw6wgY29tZSBzb25vLjwvZGl2PlwiLFxuXHRcdHRhbkhOYW1lOiBcIlRhbkhcIixcblx0XHR0YW5IU25pcDogXCJDYWxjb2xhIGxhIHRhbmdlbnRlIGlwZXJib2xpY2EgZGkgY2VsbGUgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdHRhbkhEZXNjOiBcIkxhIGZ1bnppb25lIGNhbGNvbGEgbGEgdGFuZ2VudGUgaXBlcmJvbGljYSBkZWkgcGl4ZWwgaW4gdW4gcmFzdGVyLlwiLFxuXHRcdHRhbk5hbWU6IFwiVGFuXCIsXG5cdFx0dGFuU25pcDogXCJDYWxjb2xhIGxhIHRhbmdlbnRlIGRpIGNlbGxlIGluIHVuIHJhc3Rlci5cIixcblx0XHR0YW5EZXNjOiBcIkxhIGZ1bnppb25lIGNhbGNvbGEgbGEgdGFuZ2VudGUgZGVpIHBpeGVsIGluIHVuIHJhc3Rlci4gXCIsXG5cdFx0dGFzc2VsZWRDYXBOYW1lOiBcIlRhc3NlbGVkIENhcCAoS2F1dGgtVGhvbWFzKVwiLFxuXHRcdHRhc3NlbGVkQ2FwU25pcDogXCJDYWxjb2xhIGkgbGl2ZWxsaSBkaSB2ZWdldGF6aW9uZSwgdW1pZGl0w6AgZSBsdW1pbm9zaXTDoC4gUXVlc3RhIHRlY25pY2Egc2kgYmFzYSBzdSBjb2VmZmljaWVudGkgY2hlIGRldm9ubyBlc3NlcmUgY2FsY29sYXRpIHNwZWNpZmljYXRhbWVudGUgcGVyIHVuIHNlbnNvcmUuXCIsXG5cdFx0dGFzc2VsZWRDYXBEZXNjOiBcIkxhIHRyYXNmb3JtYXppb25lIFRhc3NlbGVkIENhcCAoS2F1dGgtVGhvbWFzKSDDqCBwcm9nZXR0YXRhIHBlciBhbmFsaXp6YXJlIGUgbWFwcGFyZSBsZSB2YXJpYXppb25pIGRpIGZlbm9tZW5vbG9naWEgZGkgdmVnZXRhemlvbmUgZSBzdmlsdXBwbyB1cmJhbm8gcmlsZXZhdGUgZGEgdmFyaSBzaXN0ZW1pIGRpIHNlbnNvcmkgc2F0ZWxsaXRhcmkuIMOIIG5vdG8gY29tZSB0cmFzZm9ybWF6aW9uZSBUYXNzZWxlZCBDYXAsIGEgc2VndWl0byBkZWxsYSBmb3JtYSBkZWxsYSBkaXN0cmlidXppb25lIGdyYWZpY2EgZGVpIGRhdGkuIExhIHRyYXNmb3JtYXppb25lIGhhIGZvcm5pdG8gdW5hIGxvZ2ljYSBwZXIgaSBtb2RlbGxpIHRyb3ZhdGkgbmVpIGRhdGkgTGFuZHNhdCBNU1MgZGVpIGNhbXBpIGFncmljb2xpIGluIGZ1bnppb25lIGRlbCBjaWNsbyBkaSB2aXRhIGRlbCByYWNjb2x0by4gRXNzZW56aWFsbWVudGUsIG1lbnRyZSBpIHJhY2NvbHRpIGNyZXNjb25vIGRhbCBzZW1lIGFsbGEgbWF0dXJpdMOgLCB2aSDDqCB1biBhdW1lbnRvIG5ldHRvIG5lbGwnaW5mcmFyb3NzbyB2aWNpbm8gZSB1bmEgZGltaW51emlvbmUgZGVsbGEgcmlmbGV0dGFuemEgcm9zc2EgYmFzYXRhIHN1bCBjb2xvcmUgZGVsIHN1b2xvPGRpdj48YnIvPkwndXRpbGl0w6AgZGkgcXVlc3RhIHRyYXNmb3JtYXppb25lIHNpIMOoIGFtcGxpYXRhIGRhbCBtb25pdG9yYWdnaW8gZGVsIHJhY2NvbHRvIGFsbCdhbmFsaXNpIGUgYWwgTWFwcGluZyBkZWxsYSB2ZWdldGF6aW9uZSBwZXIgc3VwcG9ydGFyZSB1bmEgdmFyaWV0w6AgZGkgYXBwbGljYXppb25pIHF1YWxpIHNpbHZpY29sdHVyYSwgZ2VzdGlvbmUgZGVsbGEgdmVnZXRhemlvbmUgaW5kdXN0cmlhbGUsIG1hcHBhdHVyYSBlIGdlc3Rpb25lIGRlbGwnZWNvc2lzdGVtYSwgaW52ZW50YXJpbyBlIG1vbml0b3JhZ2dpbyBkZWxsYSBjYXR0dXJhIGUgZGVpIGNyZWRpdGkgZGkgY2FyYm9uaW8sIHN2aWx1cHBvIHVyYmFubyBlIGFsdHJvLiBJbm9sdHJlLCDDqCBzdGF0YSBhbXBsaWF0YSBsYSBjb21wYXRpYmlsaXTDoCBkaSBMYW5kc2F0IE1TUyBpbiBtb2RvIGRhIGluY2x1ZGVyZSBhbHRyaSBwb3BvbGFyaSBzaXN0ZW1pIHNhdGVsbGl0YXJpLCB0cmEgY3VpIGkgc2Vuc29yaSBtdWx0aXNwZXR0cmFsaSBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIFdvcmxkVmlldy0yIGUgUmFwaWRFeWUuPC9kaXY+XCIsXG5cdFx0dGltZXNOYW1lOiBcIlZvbHRlXCIsXG5cdFx0dGltZXNTbmlwOiBcIk1vbHRpcGxpY2EgaSB2YWxvcmkgZGkgZHVlIHJhc3RlciBpbiBiYXNlIGFsbGUgc2luZ29sZSBjZWxsZS5cIixcblx0XHR0aW1lc0Rlc2M6IFwiTGEgZnVuemlvbmUgVm9sdGUgbW9sdGlwbGljYSBpIHZhbG9yaSBkaSBkdWUgcmFzdGVyIGluIGJhc2UgYWkgc2luZ29saSBwaXhlbC5cIixcblx0XHR0cmFuc3Bvc2VCaXRzTmFtZTogXCJUcmFzcG9uaSBiaXRcIixcblx0XHR0cmFuc3Bvc2VCaXRzU25pcDogXCJEZWNvbXByaW1lIGkgYml0IGRlbCBwaXhlbCBkaSBpbnB1dCBlIGxpIGFzc29jaWEgYSBiaXQgc3BlY2lmaWNhdGkgbmVsIHBpeGVsIGRpIG91dHB1dC4gTG8gc2NvcG8gZGkgcXVlc3RhIGZ1bnppb25lIMOoIG1hbmlwb2xhcmUgaSBiaXQgZGEgdW4gcGFpbyBkaSBpbnB1dCwgY29tZSBpIHByb2RvdHRpIGJhbmRhIGRpIHF1YWxpdMOgIExhbmRzYXQgOC5cIixcblx0XHR0cmFuc3Bvc2VCaXRzRGVzYzogXCJMYSBmdW56aW9uZSBUcmFzcG9uaSBiaXQgZGVjb21wcmltZSBpIGJpdCBkZWwgcGl4ZWwgZGkgaW5wdXQgZSBsaSBhc3NvY2lhIGEgYml0IHNwZWNpZmljYXRpIG5lbCBwaXhlbCBkaSBvdXRwdXQuIExvIHNjb3BvIGRpIHF1ZXN0YSBmdW56aW9uZSDDqCBtYW5pcG9sYXJlIGkgYml0IGRhIHVuIHBhaW8gZGkgaW5wdXQsIGFkIGVzZW1waW8gaSBwcm9kb3R0aSBiYW5kYSBkaSBxdWFsaXTDoCBMYW5kc2F0IDguXCIsXG5cdFx0dW5pdENvbnZlcnNpb25OYW1lOiBcIkNvbnZlcnNpb25lIHVuaXTDoFwiLFxuXHRcdHVuaXRDb252ZXJzaW9uU25pcDogXCJDYW1iaWEgaSB2YWxvcmkgZGEgdW4ndW5pdMOgIGRpIG1pc3VyYSBhIHVuJ2FsdHJhLlwiLFxuXHRcdHVuaXRDb252ZXJzaW9uRGVzYzogXCJRdWVzdGEgZnVuemlvbmUgY29udmVydGUgaSBwaXhlbCBkYSB1buKAmXVuaXTDoCBhIHVu4oCZYWx0cmEuIFN1cHBvcnRhIGxhIGNvbnZlcnNpb25lIGRpIGRpc3RhbnphLCB2ZWxvY2l0w6AgZSB0ZW1wZXJhdHVyYS5cIixcblx0XHR2ZWN0b3JGaWVsZE5hbWU6IFwiQ2FtcG8gdmV0dG9yaWFsZVwiLFxuXHRcdHZlY3RvckZpZWxkU25pcDogXCJWaXN1YWxpenphIGkgZGF0YXNldCBjb24gZ3JhbmRlenphICh1KSBlIGRpcmV6aW9uZSAodikgY29tZSBmcmVjY2UgZG92ZSBsYSBncmFuZGV6emEgw6ggcmFwcHJlc2VudGF0YSBkYWxsYSBkaW1lbnNpb25lIGUgbGEgZGlyZXppb25lIMOoIHJhcHByZXNlbnRhdGEgZGFsbCdhbmdvbG8gZGVsbGEgZnJlY2NpYS5cIixcblx0XHR2ZWN0b3JGaWVsZERlc2M6IFwiTGEgZnVuemlvbmUgQ2FtcG8gdmV0dG9yaWFsZSB2aWVuZSB1c2F0YSBwZXIgY29tYmluYXJlIGUgY29udmVydGlyZSBkdWUgcmFzdGVyIGluIHVuIHJhc3RlciBhIGR1ZSBiYW5kZSBjb24gZGF0aSBkaSB0aXBvIEdyYW5kZXp6YS1EaXJlemlvbmUgbyBkaSB0aXBvIFUtVi48ZGl2Pjxici8+SWwgdmFsb3JlIFUgdmllbmUgdGFsdm9sdGEgaW5kaWNhdG8gY29tZSB2ZWxvY2l0w6Agem9uYWxlLCBtZW50cmUgaWwgdmFsb3JlIFYgY29tZSB2ZWxvY2l0w6AgbWVyaWRpb25hbGUuPC9kaXY+XCIsXG5cdFx0dmlld3NoZWQyTmFtZTogXCJDYW1wbyBkaSBWaXNpYmlsaXTDoFwiLFxuXHRcdHZpZXdzaGVkMlNuaXA6IFwiRGV0ZXJtaW5hIGxlIHBvc2l6aW9uaSBkZWxsYSBzdXBlcmZpY2llIHJhc3RlciB2aXNpYmlsZSBhIHVuIGluc2llbWUgZGkgZmVhdHVyZSBvc3NlcnZhdG9yaSwgdXRpbGl6emFuZG8gbWV0b2RpIGdlb2RldGljaS5cIixcblx0XHR2aWV3c2hlZDJEZXNjOiBcIkxhIGZ1bnppb25lIENhbXBvIGRpIHZpc2liaWxpdMOgIGRldGVybWluYSBsZSBwb3NpemlvbmkgZGVsbGEgc3VwZXJmaWNpZSByYXN0ZXIgdmlzaWJpbGkgYSB1biBpbnNpZW1lIGRpIGZlYXR1cmUgb3NzZXJ2YXRvcmUsIHV0aWxpenphbmRvIG1ldG9kaSBnZW9kZXRpY2k8ZGl2Pjxici8+TGEgdmlzaWJpbGl0w6AgZGVsIGNlbnRybyBkaSBjaWFzY3VuIHBpeGVsIMOoIGRldGVybWluYXRhIGRhIHVuIHRlc3QgZGkgYW5hbGlzaSBkZWxsYSBsaW5lYSBkaSB2aXN0YSB0cmEgbCdvYmlldHRpdm8gZSBjaWFzY3VuIG9zc2VydmF0b3JlLiBTZSB1biBvc3NlcnZhdG9yZSDDqCBpbiBncmFkbyBkaSB2ZWRlcmUgbOKAmW9iaWV0dGl2byBhbCBjZW50cm8gZGVsIHBpeGVsLCBpbCBwaXhlbCDDqCBjb25zaWRlcmF0byB2aXNpYmlsZS4gUXVlc3RvIHN0cnVtZW50byBkZXRlcm1pbmEgbGEgdmlzaWJpbGl0w6AgdGVuZW5kbyBzZW1wcmUgY29udG8gZGVsbGEgY3VydmF0dXJhIGRlbGxhIHRlcnJhLjwvZGl2PlwiLFxuXHRcdHdhdGVyc2hlZE5hbWU6IFwiU3BhcnRpYWNxdWVcIixcblx0XHR3YXRlcnNoZWRTbmlwOiBcIkRldGVybWluYSBsJ2FyZWEgY29udHJpYnVlbnRlIHN1IHVuYSBzZXJpZSBkaSBjZWxsZSBpbiB1biByYXN0ZXIuXCIsXG5cdFx0d2F0ZXJzaGVkRGVzYzogXCJMYSBmdW56aW9uZSBnbG9iYWxlIFNwYXJ0aWFjcXVlIGRldGVybWluYSBsJ2FyZWEgY29udHJpYnVlbnRlIHN1IHVuYSBzZXJpZSBkaSBwaXhlbCBpbiB1biByYXN0ZXIuIEdsaSBzcGFydGlhY3F1ZSBzb25vIGRlbGluZWF0aSBkYSB1biByYXN0ZXIgZGkgZGlyZXppb25lIGRlbCBmbHVzc28gY2hlIGluZGl2aWR1YSBsYSBkaXJlemlvbmUgZGVsIGZsdXNzbyBpbiBjaWFzY3VuIHBpeGVsLlwiLFxuXHRcdHdlaWdodGVkT3ZlcmxheU5hbWU6IFwiU292cmFwcG9zaXppb25lIFZlcmlmaWNhdGFcIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlTbmlwOiBcIlNvdnJhcHBvbmUgcGnDuSByYXN0ZXIgdXRpbGl6emFuZG8gdW5hIHNjYWxhIGRpIG1pc3VyYXppb25lIGUgcGVzaSBjb211bmkgY2lhc2N1bm8gaW4gYmFzZSBhbGxhIHN1YSBpbXBvcnRhbnphLlwiLFxuXHRcdHdlaWdodGVkT3ZlcmxheURlc2M6IFwiUXVlc3RhIGZ1bnppb25lIGNvbnNlbnRlIGRpIHNvdnJhcHBvcnJlIHBpw7kgcmFzdGVyIHV0aWxpenphbmRvIHVuYSBzY2FsYSBkaSBtaXN1cmF6aW9uZSBlIHVuIHBlc28gY29tdW5lLCBjaWFzY3VubyBpbiBiYXNlIGFsbGEgcmVsYXRpdmEgaW1wb3J0YW56YS5cIixcblx0XHR3ZWlnaHRlZFN1bU5hbWU6IFwiU29tbWEgVmVyaWZpY2F0YVwiLFxuXHRcdHdlaWdodGVkU3VtU25pcDogXCJQZXNhIGUgYWdnaXVuZ2UgdW4gYXJyYXkgZGkgcmFzdGVyIGluIGJhc2UgYWxsZSBzaW5nb2xlIGNlbGxlLlwiLFxuXHRcdHdlaWdodGVkU3VtRGVzYzogXCJMYSBmdW56aW9uZSBTb21tYSB2ZXJpZmljYXRhIGNvbnNlbnRlIGRpIHNvdnJhcHBvcnJlIHBpw7kgcmFzdGVyIG1vbHRpcGxpY2FuZG8gY2lhc2N1bm8gcGVyIGlsIHJlbGF0aXZvIHBlc28gZSBzb21tYW5kb2xpIGluc2llbWUuXCIsXG5cdFx0d2luZGNoaWxsTmFtZTogXCJXaW5kIENoaWxsXCIsXG5cdFx0d2luZGNoaWxsU25pcDogXCJDb21iaW5hIGxhIHRlbXBlcmF0dXJhIGRlbGwnYXJpYSBjaXJjb3N0YW50ZSBlIGxhIHZlbG9jaXTDoCBkZWwgdmVudG8gcGVyIGNhbGNvbGFyZSBpbCBmYXR0b3JlIHdpbmRjaGlsbC5cIixcblx0XHR3aW5kY2hpbGxEZXNjOiBcIkxhIGZ1bnppb25lIFdpbmQgQ2hpbGwgw6ggdXRpbGUgcGVyIGlkZW50aWZpY2FyZSBjb25kaXppb25pIGludmVybmFsaSBwZXJpY29sb3NlIGNoZSwgYSBzZWNvbmRhIGRlaSB0ZW1waSBkaSBlc3Bvc2l6aW9uZSBhZ2xpIGVsZW1lbnRpLCBwb3Nzb25vIHByb3ZvY2FyZSBjb25nZWxhbWVudG8gbyBhZGRpcml0dHVyYSBpcG90ZXJtaWEuIElsIHdpbmQgY2hpbGwgw6ggdW4gbWV0b2RvIGRpIG1pc3VyYXppb25lIGRlbGxhIHNlbnNhemlvbmUgZGkgZnJlZGRvIGRpIHVuIGluZGl2aWR1byBjaGUgcHJlbmRlIGluIGNvbnNpZGVyYXppb25lIGlsIHZlbnRvIGNvbiB0ZW1wZXJhdHVyZSBnacOgIGZyZWRkZS4gTWFnZ2lvcmUgw6ggbGEgdmVsb2NpdMOgIGRlbCB2ZW50bywgcGnDuSByYXBpZGFtZW50ZSBpbCBjb3JwbyBwZXJkZXLDoCBjYWxvcmUgZSBtYWdnaW9yZSBzYXLDoCBpbCBmcmVkZG8gcGVyY2VwaXRvLlwiLFxuXHRcdHpvbmFsUmVtYXBOYW1lOiBcIlJpbWFwcGF0dXJhIHpvbmFsZVwiLFxuXHRcdHpvbmFsUmVtYXBTbmlwOiBcIlJpY2FsY29sYSBpIHBpeGVsIGluIHVuIHJhc3RlciBpbiBiYXNlIGFsbGUgem9uZSBkZWZpbml0ZSBkYSB1biBhbHRybyByYXN0ZXIgZSBhIHVuYSBtYXBwYXR1cmEgZGkgdmFsb3JpIGRpcGVuZGVudGUgZGFsbGEgem9uYSBkZWZpbml0YSBkYSB1bmEgdGFiZWxsYS5cIixcblx0XHR6b25hbFJlbWFwRGVzYzogXCJRdWVzdGEgw6ggdW5hIGZ1bnppb25lIGNoZSByaWNhbGNvbGEgaSBwaXhlbCBpbiB1biByYXN0ZXIsIGluIGJhc2UgYWxsZSB6b25lIGRlZmluaXRlIGRhIHVuIGFsdHJvIHJhc3RlciBlIGEgdW5hIG1hcHBhdHVyYSBkaSB2YWxvcmkgZGlwZW5kZW50ZSBkYWxsYSB6b25hIGRlZmluaXRhIGRhIHVuYSB0YWJlbGxhLlwiLFxuXHRcdHpvbmFsU3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGljaGUgem9uYWxpXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzU25pcDogXCJDYWxjb2xhIHN0YXRpc3RpY2hlIHN1aSB2YWxvcmkgZGkgdW4gcmFzdGVyIGFsbCdpbnRlcm5vIGRlbGxlIHpvbmUgZGkgdW4gYWx0cm8gZGF0YXNldC5cIixcblx0XHR6b25hbFN0YXRpc3RpY3NEZXNjOiBcIkxhIGZ1bnppb25lIGNhbGNvbGEgc3RhdGlzdGljaGUgc3VpIHZhbG9yaSBkaSB1biByYXN0ZXIgYWxsJ2ludGVybm8gZGVsbGUgem9uZSBkaSB1biBhbHRybyBkYXRhc2V0LiBVbmEgem9uYSB2aWVuZSBkZWZpbml0YSBjb21lIHR1dHRlIGxlIGFyZWUgbmVsbCdpbnB1dCBjaGUgaGFubm8gbG8gc3Rlc3NvIHZhbG9yZS4gVGFsaSBhcmVlIG5vbiBkZXZvbm8gZXNzZXJlIGNvbnRpZ3VlLiBRdWFuZG8gZ2xpIGlucHV0IGRpIHpvbmEgZSBkaSB2YWxvcmUgc29ubyBlbnRyYW1iaSBkZWkgcmFzdGVyIGRlbGxhIHN0ZXNzYSByaXNvbHV6aW9uZSwgc2FyYW5ubyB1c2F0aSBkaXJldHRhbWVudGUuIFNlIGxlIHJpc29sdXppb25pIHNvbm8gZGl2ZXJzZSwgdmVycsOgIGFwcGxpY2F0byB1biByaWNhbXBpb25hbWVudG8gaW50ZXJubyBwZXIgZmFyIGNvcnJpc3BvbmRlcmUgbGUgcmlzb2x1emlvbmkgcHJpbWEgY2hlIHZlbmdhIGVzZWd1aXRhIGwnb3BlcmF6aW9uZSB6b25hbGUuXCIsXG5cdFx0Zmxvd0xlbmd0aE5hbWU6IFwiTHVuZ2hlenphIEZsdXNzb1wiLFxuXHRcdGZsb3dMZW5ndGhTbmlwOiBcIkNhbGNvbGEgbGEgZGlzdGFuemEgYSBtb250ZSBvIGEgdmFsbGUsIG8gZGlzdGFuemEgcG9uZGVyYXRhLCBsdW5nbyBpbCBwZXJjb3JzbyBkaSBmbHVzc28gcGVyIGNpYXNjdW5hIGNlbGxhLlwiLFxuXHRcdGZsb3dMZW5ndGhEZXNjOiBcIlF1ZXN0YSDDqCB1bmEgZnVuemlvbmUgcmFzdGVyIGdsb2JhbGUuIFF1ZXN0YSBmdW56aW9uZSBjcmVhIHVuIGxheWVyIHJhc3RlciBkZWxsYSBkaXN0YW56YSBhIG1vbnRlIG8gYSB2YWxsZSwgbyBkaXN0YW56YSBwb25kZXJhdGEsIGx1bmdvIGlsIHBlcmNvcnNvIGRpIGZsdXNzbyBwZXIgb2duaSBjZWxsYS48ZGl2Pjxici8+VW4gdXRpbGl6em8gcHJpbWFyaW8gZGVsbGEgZnVuemlvbmUgbHVuZ2hlenphIGRpIGZsdXNzbyDDqCBxdWVsbG8gZGkgY2FsY29sYXJlIGxhIGx1bmdoZXp6YSBkZWwgcGVyY29yc28gZGkgZmx1c3NvIHBpw7kgbHVuZ28gYWxsJ2ludGVybm8gZGkgdW4gYmFjaW5vIGRldGVybWluYXRvLiBRdWVzdGEgbWlzdXJhemlvbmUgdmllbmUgc3Blc3NvIHV0aWxpenphdGEgcGVyIGNhbGNvbGFyZSBpbCB0ZW1wbyBkaSBjb25jZW50cmF6aW9uZSBkaSB1biBiYWNpbm8uIFF1ZXN0YSBvcGVyYXppb25lIHZpZW5lIGVmZmV0dHVhdGEgdXRpbGl6emFuZG8gbCdvcHppb25lIEEgbW9udGUuIExhIGZ1bnppb25lIHB1w7IgaW5vbHRyZSBlc3NlcmUgdXRpbGl6emF0YSBwZXIgY3JlYXJlIGRpYWdyYW1taSBhcmVlIGRpIGRpc3RhbnphIGRpIHBpb2dnZSBlIHN0cmFyaXBhbWVudGkgaXBvdGV0aWNpIHV0aWxpenphbmRvIGlsIHJhc3RlciBwb25kZXJhdG8gY29tZSBpbXBlZGltZW50byBwZXIgaWwgbW92aW1lbnRvIHZlcnNvIGlsIGJhc3NvLjwvZGl2PlwiLFxuXHRcdHN0cmVhbU9yZGVyTmFtZTogXCJPcmRpbmUgZGkgRmx1c3NvXCIsXG5cdFx0c3RyZWFtT3JkZXJTbmlwOiBcIkFzc2VnbmEgdW4gb3JkaW5lIG51bWVyaWNvIGFpIHNlZ21lbnRpIGRpIHVuIHJhc3RlciBjaGUgcmFwcHJlc2VudGFubyBsZSBkaXJhbWF6aW9uaSBkaSB1bmEgcmV0ZSBsaW5lYXJlXCIsXG5cdFx0c3RyZWFtT3JkZXJEZXNjOiBcIlF1ZXN0YSDDqCB1bmEgZnVuemlvbmUgcmFzdGVyIGdsb2JhbGUuIFF1ZXN0YSBmdW56aW9uZSBjcmVhIHVuIGxheWVyIHJhc3RlciBjaGUgYXNzZWduYSB1biBvcmRpbmUgbnVtZXJpY28gYWkgc2VnbWVudGkgZGkgdW4gcmFzdGVyIGNoZSByYXBwcmVzZW50YW5vIGxlIGRpcmFtYXppb25pIGRpIHVuYSByZXRlIGxpbmVhcmUuPGRpdj48YnIvPkwnb3V0cHV0IGRlbGxhIGZ1bnppb25lIGRlbGwnb3JkaW5lIGRpIGZsdXNzbyBzYXLDoCBkaSBxdWFsaXTDoCBtYWdnaW9yZSBzZSBpbCBsYXllciByYXN0ZXIgZGkgZmx1c3NvIGRpIGlucHV0IGUgaWwgbGF5ZXIgcmFzdGVyIGRpIGRpcmV6aW9uZSBkaSBmbHVzc28gZGkgaW5wdXQgZGVyaXZhbm8gZGFsbGEgc3Rlc3NhIHN1cGVyZmljaWUuIFNlIGlsIHJhc3RlciBkaSBmbHVzc28gZGVyaXZhIGRhIHVuIGRhdGFzZXQgZGkgZmx1c3NvIHJhc3Rlcml6emF0bywgbCdvdXRwdXQgcG90cmViYmUgbm9uIGVzc2VyZSB1dGlsaXp6YWJpbGUgcG9pY2jDqSwgc3UgdW5hIGJhc2UgZGkgY2VsbGEtcGVyLWNlbGxhLCBsYSBkaXJlemlvbmUgbm9uIGNvcnJpc3BvbmRlcsOgIGFsbGEgcG9zaXppb25lIGRlbGxlIGNlbGxlIGRpIGZsdXNzby4gSSByaXN1bHRhdGkgZGVsbGEgZnVuemlvbmUgQWNjdW11bG8gZGkgZmx1c3NvIHBvc3Nvbm8gZXNzZXJlIHV0aWxpenphdGkgcGVyIGNyZWFyZSB1bmEgcmV0ZSBkaSBmbHVzc28gcmFzdGVyIGFwcGxpY2FuZG8gdW4gdmFsb3JlIGRpIHNvZ2xpYSBwZXIgbGEgc2VsZXppb25lIGRlbGxlIGNlbGxlIGNvbiB1biBmbHVzc28gZGkgYWNjdW11bG8gYWx0by4gQWQgZXNlbXBpbywgbGUgY2VsbGUgY2hlIGhhbm5vIHBpw7kgZGkgMTAwIGNlbGxlIGNoZSBmbHVpc2Nvbm8gYWwgbG9ybyBpbnRlcm5vIHZlbmdvbm8gdXRpbGl6emF0ZSBwZXIgZGVmaW5pcmUgbGEgcmV0ZSBkaSBmbHVzc28uIFV0aWxpenphcmUgbGEgZnVuemlvbmUgQ29uIG8gU2V0IE51bGwgcGVyIGNyZWFyZSB1biByYXN0ZXIgZGkgcmV0ZSBkaSBmbHVzc28gbmVsIHF1YWxlIGkgdmFsb3JpIGRpIGFjY3VtdWxvIGRlbCBmbHVzc28gZGkgMTAwIG8gcGnDuSB2YW5ubyBpbiB1bid1bmljYSBjZWxsYSwgZSBpbCByZXN0byB2ZW5nb25vIHBvc3RpIGluIGJhY2tncm91bmQgKE5vRGF0YSkuIExhIHJldGUgZGkgZmx1c3NvIHJpc3VsdGFudGUgcHXDsiBlc3NlcmUgdXRpbGl6emF0YSBuZWxsYSBmdW56aW9uZSBkZWxsJ29yZGluZSBkaSBmbHVzc28uIFF1ZXN0YSBmdW56aW9uZSBzdXBwb3J0YSBzb2xvIHVuIGxheWVyIHJhc3RlciBkaSBkaXJlemlvbmUgZGkgZmx1c3NvIGRpIGlucHV0IEQ4LiBMZSBkaXJlemlvbmkgZGkgZmx1c3NvIEQ4IHBvc3Nvbm8gZXNzZXJlIGNyZWF0ZSB1dGlsaXp6YW5kbyBsYSBmdW56aW9uZSBkaSBkaXJlemlvbmUgZGkgZmx1c3NvIGVkIGVzZWd1aXRlIHRyYW1pdGUgaWwgdGlwbyBkaSBkaXJlemlvbmUgZGkgZmx1c3NvIHByZWRlZmluaXRvIEQ4LjwvZGl2PlwiLFxuXHRcdHNuYXBQb3VyUG9pbnROYW1lOiBcIkFnZ2FuY2lhIFB1bnRvIGRpIFZlcnNhbWVudG9cIixcblx0XHRzbmFwUG91clBvaW50U25pcDogXCJBZ2dhbmNpYSBpIHB1bnRpIGRpIHZlcnNhbWVudG8gYWxsZSBjZWxsZSBkaSBtYWdnaW9yIGFjY3VtdWxvIGRlbCBmbHVzc28gZW50cm8gdW5hIGRldGVybWluYXRhIGRpc3RhbnphXCIsXG5cdFx0c25hcFBvdXJQb2ludERlc2M6IFwiUXVlc3RhIMOoIHVuYSBmdW56aW9uZSByYXN0ZXIgZ2xvYmFsZS4gUXVlc3RhIGZ1bnppb25lIGFnZ2FuY2lhIGkgcHVudGkgZGkgdmVyc2FtZW50byBhbGxlIGNlbGxlIGRpIG1hZ2dpb3IgYWNjdW11bG8gZGVsIGZsdXNzbyBlbnRybyB1bmEgZGlzdGFuemEgc3BlY2lmaWNhdGEuPGRpdj48YnIvPkxhIGZ1bnppb25lIGFnZ2FuY2lhIHB1bnRvIGRpIHZlcnNhbWVudG8gdmllbmUgdXRpbGl6emF0YSBwZXIgYXNzaWN1cmFyZSBsYSBzZWxlemlvbmUgZGkgcHVudGkgZGkgZmx1c3NvIGRpIGFjY3VtdWxvIGFsdG8gcXVhbmRvIHZlbmdvbm8gZGVsaW5lYXRpIGkgYmFjaW5pIGRpIGRyZW5hZ2dpbyB1dGlsaXp6YW5kbyBsYSBmdW56aW9uZSBTcGFydGlhY3F1ZS4gQWdnYW5jaWEgcHVudG8gZGkgdmVyc2FtZW50byByaWNlcmNoZXLDoCBhbGwnaW50ZXJubyBkaSB1bmEgZGlzdGFuemEgZGkgYWdnYW5jaW8gaW50b3JubyBhaSBwdW50aSBkaSB2ZXJzYW1lbnRvIHNwZWNpZmljYXRpLCBmaW5vIGEgcXVhbmRvIG5vbiB0cm92ZXLDoCB1bmEgY2VsbGEgY29uIGlsIGZsdXNzbyBkaSBhY2N1bXVsbyBtYXNzaW1vIGUgc3Bvc3RlcsOgIGlsIHB1bnRvIGRpIHZlcnNhbWVudG8gaW4gcXVlbGxhIHBvc2l6aW9uZS4gTCdvdXRwdXQgw6ggdW4gbGF5ZXIgcmFzdGVyIGludGVybyBxdWFuZG8gbGUgcG9zaXppb25pIGRlaSBwdW50aSBkaSB2ZXJzYW1lbnRvIG9yaWdpbmFsaSBzb25vIHN0YXRlIGFnZ2l1bnRlIGFsbGUgcG9zaXppb25pIGRlbCBmbHVzc28gZGkgYWNjdW11bG8gcGnDuSBhbHRvLjwvZGl2PlwiLFxuXHRcdHNpbmtOYW1lOiBcIlBvenpvXCIsXG5cdFx0c2lua1NuaXA6IFwiQ3JlYSB1biByYXN0ZXIgY2hlIGlkZW50aWZpY2EgdHV0dGkgaSBzaW5rIG8gbGUgYXJlZSBkaSBkcmVuYWdnaW8gaW50ZXJub1wiLFxuXHRcdHNpbmtEZXNjOiBcIlF1ZXN0YSDDqCB1bmEgZnVuemlvbmUgcmFzdGVyIGdsb2JhbGUuIFF1ZXN0YSBmdW56aW9uZSBjcmVhIHVuIGxheWVyIHJhc3RlciBjaGUgaWRlbnRpZmljYSB0dXR0aSBpIHNpbmsgbyBhcmVlIGRpIGRyZW5hZ2dpbyBpbnRlcm5vLiBVbiBzaW5rIMOoIHVuYSBjZWxsYSBvIHVuIHNldCBkaSBjZWxsZSBjb25uZXNzZSBzcGF6aWFsbWVudGUgY29uIHVuYSBkaXJlemlvbmUgZGkgZmx1c3NvIGFsbGEgcXVhbGUgbm9uIHB1w7IgZXNzZXJlIGFzc2VnbmF0byB1bm8gZGVnbGkgb3R0byB2YWxvcmkgdmFsaWRpIGluIHVuIHJhc3RlciBkaSBkaXJlemlvbmUgZGkgZmx1c3NvLiBRdWVzdG8gcHXDsiB2ZXJpZmljYXJzaSBzZSB0dXR0ZSBsZSBjZWxsZSB2aWNpbmUgc29ubyBwacO5IGFsdGUgZGVsbGEgY2VsbGEgZGkgZWxhYm9yYXppb25lIG8gc2UgZHVlIGNlbGxlIGZsdWlzY29ubyB1bmEgbmVsbCdhbHRyYSBjcmVhbmRvIHVuIGxvb3AgYSBkaSBkdWUgY2VsbGUuPGRpdj48YnIvPkxhIGZ1bnppb25lIHNpbmsgc3VwcG9ydGEgc29sbyB1biBsYXllciByYXN0ZXIgZGkgZGlyZXppb25lIGRpIGZsdXNzbyBEOC4gTGUgZGlyZXppb25pIGRpIGZsdXNzbyBEOCBwb3Nzb25vIGVzc2VyZSBjcmVhdGUgdXRpbGl6emFuZG8gbGEgZnVuemlvbmUgZGkgZGlyZXppb25lIGRpIGZsdXNzbyBlZCBlc2VndWl0ZSB0cmFtaXRlIGlsIHRpcG8gZGkgZGlyZXppb25lIGRpIGZsdXNzbyBwcmVkZWZpbml0byBEOC4gTCdvdXRwdXQgZGVsbGEgZnVuemlvbmUgc2luayDDqCB1biByYXN0ZXIgaW50ZXJvLCBjb24gb2duaSBzaW5rIGFzc2VnbmF0byBhIHVuIHZhbG9yZSB1bml2b2NvLiBRdWVzdGkgdmFsb3JpIHVuaXZvY2kgaGFubm8gdW4gaW50ZXJ2YWxsbyBjaGUgdmEgZGEgdW5vIGFsIG51bWVybyB0b3RhbGUgZGkgc2luay4gQWQgZXNlbXBpbywgc2UgaWwgbnVtZXJvIHRvdGFsZSBkaSBzaW5rIGZvc3NlIDEwMDAsIGwnaW50ZXJ2YWxsbyBkaSB2YWxvcmkgdW5pdm9jaSBhbmRyZWJiZSBkYSAxIGEgMTAwMC48L2Rpdj5cIixcblx0XHRhZ2dyZWdhdGVOYW1lOiBcIkFnZ3JlZ2FcIixcblx0XHRhZ2dyZWdhdGVTbmlwOiBcIkdlbmVyYSB1bmEgdmVyc2lvbmUgZGkgcmlzb2x1emlvbmUgcmlkb3R0YSBkaSB1biByYXN0ZXIuXCIsXG5cdFx0YWdncmVnYXRlRGVzYzogXCJMYSBmdW56aW9uZSBBZ2dyZWdhIHJpY2FtcGlvbmEgdW4gcmFzdGVyIGRpIGlucHV0IHN1IHVuYSByaXNvbHV6aW9uZSBwacO5IGFwcHJvc3NpbWF0aXZhIGluIGJhc2UgYSB1bmEgc3RyYXRlZ2lhIGRpIGFnZ3JlZ2F6aW9uZSBzcGVjaWZpY2F0YS4gT2duaSBjZWxsYSBkaSBvdXRwdXQgY29udGllbmUgU3VtLCBNaW5pbXVtLCBNYXhpbXVtLCBNZWFuIG8gTWVkaWFuIGRlbGxlIGNlbGx1bGUgZGkgaW5wdXQgcmFjY2hpdXNlIGRhbGzigJllc3RlbnNpb25lIGRpIHF1ZWxsYSBjZWxsYS48ZGl2Pjxici8+w4ggcG9zc2liaWxlIHNwZWNpZmljYXJlIGlsIGZhdHRvcmUgcGVyIGlsIHF1YWxlIG1vbHRpcGxpY2FyZSBsYSBkaW1lbnNpb25lIGNlbGxhIGRlbCByYXN0ZXIgZGkgaW5wdXQuIEFkIGVzZW1waW8sIHVuIHZhbG9yZSBmYXR0b3JlIGNlbGxhIGRpIDMgcmlzdWx0ZXJlYmJlIGluIHVuIG91dHB1dCBpbiBjdWkgbGEgZGltZW5zaW9uZSBjZWxsYSDDqCB0cmUgdm9sdGUgc3VwZXJpb3JlIHJpc3BldHRvIGEgcXVlbGxhIGRlbCByYXN0ZXIgZGkgaW5wdXQuIMOIIHBvc3NpYmlsZSBkZWZpbmlyZSBjb21lIGdlc3RpcmUgbCdlc3RlbnNpb25lIGRlbGwnb3V0cHV0IHNlIGlsIG51bWVybyBkaSByaWdoZSBvIGNvbG9ubmUgbmVsbCdvdXRwdXQgbm9uIMOoIHVuIG11bHRpcGxvIGVzYXR0byBkZWwgZmF0dG9yZSBkaSBjZWxsYS4gUGVyIGltcG9zdGF6aW9uZSBwcmVkZWZpbml0YSwgaSBjb25maW5pIHN1cGVyaW9yZSBlIGRlc3RybyBzYXJhbm5vIGFtcGxpYXRpIHBlciBjb3ByaXJlIHVuJ2VzdGVuc2lvbmUgc3BhemlhbGUgcGnDuSBhbXBpYSByaXNwZXR0byBhIHF1ZWxsYSBkZWwgcmFzdGVyIGRpIGlucHV0LCBwZXIgZ2FyYW50aXJlIGwnZWxhYm9yYXppb25lIGRpIHR1dHRlIGxlIGNlbGxlIGRpIGlucHV0LiBJbiBhbHRlcm5hdGl2YSwgaSBjb25maW5pIHN1cGVyaW9yZSBlIGRlc3RybyBwb3Nzb25vIGVzc2VyZSByaWRvdHRpIHBlciBjb3ByaXJlIHVuJ2VzdGVuc2lvbmUgcGnDuSBwaWNjb2xhLCBpbiBtb2RvIGNoZSBpbCBudW1lcm8gZGkgcmlnaGUgZSBjb2xvbm5lIGVsYWJvcmF0byBzaWEgdW4gbXVsdGlwbG8gZXNhdHRvIGRlbCBmYXR0b3JlIGRpIGNlbGxhLiDDiCBwb3NzaWJpbGUgZGVmaW5pcmUgY29tZSBkb3ZyYW5ubyBlc3NlcmUgZ2VzdGl0ZSBsZSBjZWxsZSBOb0RhdGEgZGFsIGNhbGNvbG8gZGkgYWdncmVnYXppb25lLuKAi0lsIG1lY2NhbmlzbW8gcHJlZGVmaW5pdG8gcHJldmVkZSBjaGUgbGUgY2VsbGUgTm9EYXRhIGRpIGlucHV0IGNoZSByaWVudHJhbm8gbmVsbCdlc3RlbnNpb25lIHNwYXppYWxlIGRpIHVuYSBjZWxsYSBwacO5IGdyYW5kZSBuZWwgcmFzdGVyIGRpIG91dHB1dCBzYXJhbm5vIGlnbm9yYXRlIHF1YW5kbyBzaSBkZXRlcm1pbmEgaWwgdmFsb3JlIGRpIHF1ZWxsYSBjZWxsYSBkaSBvdXRwdXQuIEluIGFsdGVybmF0aXZhLCDDqCBwb3NzaWJpbGUgc3BlY2lmaWNhcmUgY2hlIHNlIGFsbCdpbnRlcm5vIGRlbGwnZXN0ZW5zaW9uZSBzcGF6aWFsZSBkaSB1bmEgY2VsbGEgZGkgb3V0cHV0IGVzaXN0ZSBhbmNoZSBzb2xvIHVuYSBjZWxsYSBOb0RhdGEgZGkgaW5wdXQsIHRhbGUgY2VsbGEgc2Fyw6AgTm9EYXRhIG5lbCByYXN0ZXIgZGkgb3V0cHV0LjwvZGl2PlwiLFxuXHRcdGNjZGNOYW1lOiBcIkFuYWxpc2kgQ0NEQ1wiLFxuXHRcdGNjZGNTbmlwOiBcIlZhbHV0YSBsZSB2YXJpYXppb25pIGRlaSB2YWxvcmkgZGVpIHBpeGVsIG5lbCB0ZW1wbyB1dGlsaXp6YW5kbyBsJ2FsZ29yaXRtbyBDb250aW51b3VzIENoYW5nZSBEZXRlY3Rpb24gYW5kIENsYXNzaWZpY2F0aW9uIChDQ0RDKSBlIGdlbmVyYSBpIHJpc3VsdGF0aSBkZWwgbW9kZWxsby5cIixcblx0XHRjY2RjRGVzYzogXCJMYSBmdW56aW9uZSBBbmFsaXNpIENDREMgdmFsdXRhIGxlIHZhcmlhemlvbmkgZGVpIHZhbG9yaSBkZWkgcGl4ZWwgbmVsIHRlbXBvIHV0aWxpenphbmRvIGwnYWxnb3JpdG1vIENvbnRpbnVvdXMgQ2hhbmdlIERldGVjdGlvbiBhbmQgQ2xhc3NpZmljYXRpb24gKENDREMpIGUgZ2VuZXJhIHVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBjb250ZW5lbnRlIGkgcmlzdWx0YXRpIGRlbCBtb2RlbGxvLiDDiCBzdXBwb3J0YXRhIHNvbG8gaW4gY29tYmluYXppb25lIGNvbiBsYSBmdW56aW9uZSBkaSBhbmFsaXNpIERldGVjdCBDaGFuZ2UgVXNpbmcgQ2hhbmdlIGluIHVuIG1vZGVsbG8gZGkgZnVuemlvbmUgcmFzdGVyLiBQZXIgcHJvZHVycmUgdW4gb3V0cHV0IHJhc3RlciwgY29sbGVnYXJlIGxhIGZ1bnppb25lIGRpIGFuYWxpc2kgQ0NEQyBhbGxhIGZ1bnppb25lIGRpIGFuYWxpc2kgRGV0ZWN0IENoYW5nZSBVc2luZyBDaGFuZ2UsIHNhbHZhcmUgY29tZSBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciBlZCBlc2VndWlyZSBsJ2FuYWxpc2kgcmFzdGVyIGNvbiBpbCBtb2RlbGxvIGRpIGZ1bnppb25lLjxkaXY+PGJyLz5RdWVzdGEgZnVuemlvbmUgdXRpbGl6emEgbCdhbGdvcml0bW8gQ29udGludW91cyBDaGFuZ2UgRGV0ZWN0aW9uIGFuZCBDbGFzc2lmaWNhdGlvbiAoQ0NEQykgcGVyIHZhbHV0YXJlIGxlIHZhcmlhemlvbmkgZGVpIHZhbG9yaSBkZWkgcGl4ZWwgbmVsIHRlbXBvIHBlciB1bmEgcGlsYSBkaSBpbW1hZ2luaS4gSW4gdW5hIHNlcmllIHRlbXBvcmFsZSBkaSBpbW1hZ2luaSBvdHRpY2hlIG8gZGVyaXZhdGkgZGkgaW1tYWdpbmUgKGFkIGVzZW1waW8sIE5EVkkpLCBpIHZhbG9yaSBkZWkgcGl4ZWwgcG9zc29ubyBmbHV0dHVhcmUgcGVyIHZhcmllIHJhZ2lvbmk6IDEuIFZhcmlhemlvbmUgc3RhZ2lvbmFsZTogbGUgdmFyaWF6aW9uaSBkZWkgdmFsb3JpIGRlaSBwaXhlbCByaWZsZXR0b25vIGxlIHZhcmlhemlvbmkgZGVsbGEgdmVnZXRhemlvbmUgYSBjYXVzYSBkZWxsYSB2YXJpYWJpbGl0w6Agc3RhZ2lvbmFsZSBkaSB0ZW1wZXJhdHVyZSBlIHByZWNpcGl0YXppb25pLiBOZWxsJ2VtaXNmZXJvIHNldHRlbnRyaW9uYWxlLCBhZCBlc2VtcGlvLCBjaSBhc3BldHRpYW1vIGRpIHRyb3ZhcmUgdW5hIGRlbnNpdMOgIHBpw7kgYWx0YSBkaSB2ZWdldGF6aW9uZSB2ZXJkZSBpbiBlc3RhdGUgcmlzcGV0dG8gYWxsJ2ludmVybm87IDIuIFZhcmlhemlvbmUgZ3JhZHVhbGU6IGxlIHZhcmlhemlvbmkgZGVpIHZhbG9yaSBkZWkgcGl4ZWwgcmlzcGVjY2hpYW5vIGxlIHRlbmRlbnplIG5lbGxhIHZlZ2V0YXppb25lIG8gbmVsbGUgYWNxdWUgZGkgc3VwZXJmaWNpZSBhIGNhdXNhIGRlbGxhIHZhcmlhYmlsaXTDoCBjbGltYXRpY2EgbyBkZWxsZSBwcmF0aWNoZSBkaSBnZXN0aW9uZSBkZWwgc3VvbG8gYSBsdW5nbyB0ZXJtaW5lLiBBZCBlc2VtcGlvLCBpbCBzdW9sbyBudWRvIHBvdHJlYmJlIGVzdGVuZGVyc2kgZ3JhZHVhbG1lbnRlIGEgY2F1c2EgZGVsbGEgcmlkdXppb25lIGRlbGxlIHByZWNpcGl0YXppb25pIGEgbHVuZ28gdGVybWluZTsgZSAzLiBWYXJpYXppb25lIGJydXNjYTogbGUgdmFyaWF6aW9uaSBkZWkgdmFsb3JpIGRlaSBwaXhlbCByaXNwZWNjaGlhbm8gbGUgdmFyaWF6aW9uaSBkZWxsYSBjb3BlcnR1cmEgZGVsIHN1b2xvIGNoZSBhY2NhZG9ubyBpbXByb3Z2aXNhbWVudGUgYSBjYXVzYSBkaSBkZWZvcmVzdGF6aW9uZSwgc3ZpbHVwcG8gdXJiYW5vLCBjYWxhbWl0w6AgbmF0dXJhbGksIGUgY29zw6wgdmlhLiBMJ2FsZ29yaXRtbyBDQ0RDIGlkZW50aWZpY2EgdHV0dGkgZSB0cmUgaSB0aXBpIGRpIHZhcmlhemlvbmUgY29uIGxvIHNjb3BvIHByaW1hcmlvIGRpIGlkZW50aWZpY2FyZSBsYSB2YXJpYXppb25lIGJydXNjYS4gSSBtb2RlbGxpIGRpIHRlbmRlbnphIGUgcmVncmVzc2lvbmUgYXJtb25pY2Egc29ubyBhZGF0dGF0aSBhaSBkYXRpIHBlciBzdGltYXJlIGxhIHZhcmlhemlvbmUgc3RhZ2lvbmFsZSBlIGdyYWR1YWxlLCBlIGxlIGRldmlhemlvbmkgaW1wcm92dmlzZSBkYWkgbW9kZWxsaSBkaSB0ZW5kZW56YSBzb25vIGluZGljYXRvcmkgZGkgdW5hIHZhcmlhemlvbmUgYnJ1c2NhLjxkaXY+PGJyLz5MJ2FsZ29yaXRtbyBDQ0RDIMOoIHN0YXRvIG9yaWdpbmFyaWFtZW50ZSBjb25jZXBpdG8gcGVyIGRhdGkgTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rIGUgTGFuZHNhdCBPTEksIGRhdGkgZGkgcmlmbGV0dGFuemEgZGVsbGEgc3VwZXJmaWNpZSBlIHRlbXBlcmF0dXJhIGRpIGx1bWlub3NpdMOgLiBUdXR0YXZpYSwgbGEgZnVuemlvbmUgZGkgYW5hbGlzaSBEZXRlY3QgQ2hhbmdlIFVzaW5nIENoYW5nZSBpbiBjb21iaW5hemlvbmUgY29uIHF1ZXN0YSBmdW56aW9uZSByaWxldmVyw6AgbGEgdmFyaWF6aW9uZSBwZXIgbGUgaW1tYWdpbmkgbXVsdGliYW5kYSBkYSBxdWFsdW5xdWUgc2Vuc29yZSBzdXBwb3J0YXRvLCBub25jaMOpIGRlcml2YXRpIGRpIGltbWFnaW5pIGEgc2luZ29sYSBiYW5kYSBjb21lIGdsaSBpbmRpY2kgZGkgYmFuZGEuIEFkIGVzZW1waW8sIMOoIHBvc3NpYmlsZSBlc2VndWlyZSB1biByaWxldmFtZW50byBjb250aW51byBkZWxsZSBtb2RpZmljaGUgc3UgdW4gcmFzdGVyIE5vcm1hbGl6ZSBEaWZmZXJlbmNlIFZlZ2V0YXRpb24gSW5kZXggKE5EVkkpLCBwZXJjaMOpIGxlIHZhcmlhemlvbmkgYnJ1c2NoZSBuZWxsJ05EVkkgcG9zc29ubyBlc3NlcmUgaW5kaWNhdGl2ZSBkaSBkZWZvcmVzdGF6aW9uZS48L2Rpdj5cIixcblx0XHRjb21wdXRlQ2hhbmdlTmFtZTogXCJDYWxjb2xhIHZhcmlhemlvbmVcIixcblx0XHRjb21wdXRlQ2hhbmdlU25pcDogXCJDYWxjb2xhIGxhIGRpZmZlcmVuemEgdHJhIGR1ZSBkYXRhc2V0IHJhc3RlciBjYXRlZ29yaWNpIG8gY29udGludWkuXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZURlc2M6IFwiTGEgZnVuemlvbmUgQ2FsY29sYSB2YXJpYXppb25lIHB1w7IgZXNzZXJlIHV0aWxpenphdGEgcGVyIGVsZW5jYXJlIGxlIGRpZmZlcmVuemUgdHJhIGR1ZSByYXN0ZXIgY2xhc3NpZmljYXRpIHBlciBsJ2FuYWxpc2kgZGVsbGEgdmFyaWF6aW9uZSBkZWxsYSBjb3BlcnR1cmEgZGVsIHN1b2xvIG9wcHVyZSBwZXIgZXNhbWluYXJlIGxlIHZhcmlhemlvbmkgdHJhIGR1ZSByYXN0ZXIgY29udGludWkgYSBzaW5nb2xhIGJhbmRhLCBjb21lIGwnZWxldmF6aW9uZSwgbGEgdGVtcGVyYXR1cmEsIGxhIGNvcGVydHVyYSBkYSBjaW1lIGRpIGFsYmVyaSwgZSBjb3PDrCB2aWEuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlTmFtZTogXCJBbmFsaXNpIERldGVjdCBDaGFuZ2UgVXNpbmcgQ2hhbmdlXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlU25pcDogXCJHZW5lcmEgdW4gbGF5ZXIgcmFzdGVyIGNvbnRlbmVudGUgaW5mb3JtYXppb25pIHN1bGxlIHZhcmlhemlvbmkgZGkgcGl4ZWwgdXRpbGl6emFuZG8gaWwgcmFzdGVyIGRpIGFuYWxpc2kgZGVsbGUgdmFyaWF6aW9uaSBkaSBvdXRwdXQuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlRGVzYzogXCI8ZGl2PkxhIGZ1bnppb25lIEFuYWxpc2kgRGV0ZWN0IENoYW5nZSBVc2luZyBDaGFuZ2UgZ2VuZXJhIHVuIGxheWVyIHJhc3RlciBjb250ZW5lbnRlIGluZm9ybWF6aW9uaSBzdWxsZSB2YXJpYXppb25pIGRpIHBpeGVsIHV0aWxpenphbmRvIGlsIHJhc3RlciBkaSBhbmFsaXNpIGRlbGxlIHZhcmlhemlvbmkgZGkgb3V0cHV0IGRlbCByYXN0ZXIgZGkgYW5hbGlzaS4gSWwgcmFzdGVyIGRpIHZhcmlhemlvbmUgYW5hbGlzaSBkZXZlIGVzc2VyZSBnZW5lcmF0byBkYSBBbmFseXNlIENoYW5nZSB1dGlsaXp6YW5kbyBsbyBzdHJ1bWVudG8gQ0NEQyBvIGxvIHN0cnVtZW50byBBbmFseXNlIENoYW5nZXMgdXRpbGl6emFuZG8gTGFuZFRyZW5kciwgbyBsYSBmdW56aW9uZSBkaSByYXN0ZXIgYW5hbGlzaSBDQ0RDIG8gbGEgZnVuemlvbmUgcmFzdGVyIGFuYWxpc2kgTGFuZFRyZW5kci48L2Rpdj48YnI+PGRpdj5RdWVzdGEgZnVuemlvbmUgcmFzdGVyIHB1w7IgZXNzZXJlIGNvbWJpbmF0YSBjb24gbGEgZnVuemlvbmUgcmFzdGVyIGFuYWxpc2kgQ0NEQyBvIGxhIGZ1bnppb25lIHJhc3RlciBMYW5kVHJlbmRyIGluIHVuIG1vZGVsbG8gZnVuemlvbmUgcmFzdGVyLiBQZXIgcHJvZHVycmUgdW4gb3V0cHV0IHJhc3RlciBwZXJtYW5lbnRlLCBjb2xsZWdhcmUgbCdvdXRwdXQgZGVsbGEgZnVuemlvbmUgZGkgYW5hbGlzaSBDQ0RDIG8gTGFuZFRyZW5kciBhbGxhIGZ1bnppb25lIERldGVjdCBDaGFuZ2UgVXNpbmcgQ2hhbmdlLCBzYWx2YXJsbyBjb21lIG1vZGVsbG8gZnVuemlvbmUgcmFzdGVyIGVkIGVzZWd1aXJlIGwnYW5hbGlzaSByYXN0ZXIgY29tZSBtb2RlbGxvLjwvZGl2Pjxicj48ZGl2PklsIHBhcmFtZXRybyA8c3Ryb25nPlRpcG8gZGkgdmFyaWF6aW9uZTwvc3Ryb25nPiBpbmRpY2EgbCdpbmZvcm1hemlvbmUgY2hlIMOoIHN0YXRhIGdlbmVyYXRhLiBMZSBpbmZvcm1hemlvbmkgdmVuZ29ubyBlc3RyYXR0ZSBkYWwgcmFzdGVyIGRpIGFuYWxpc2kgZGkgbW9kaWZpY2EuIFF1YW5kbyBzaSBlc2VndWUgcXVlc3RhIGZ1bnppb25lIHN1IHVuIG91dHB1dCBkZWxsYSBmdW56aW9uZS9zdHJ1bWVudG8gQ0NEQywgw6ggcG9zc2liaWxlIHNjZWdsaWVyZSB0cmEgbGUgc2VndWVudGkgb3B6aW9uaTo8L2Rpdj48dWw+PGxpPjxzdHJvbmc+T3JhIGRpIHVsdGltYSB2YXJpYXppb25lPC9zdHJvbmc+LS1MYSBkYXRhIHBpw7kgcmVjZW50ZSBlIGwnb3JhIGluIGN1aSB1biBwaXhlbCDDqCBzdGF0byBjb250cmFzc2VnbmF0byBjb21lIHZhcmlhemlvbmUuPC9saT48bGk+PHN0cm9uZz5PcmEgZGkgdmFyaWF6aW9uZSBwacO5IHJlY2VudGU8L3N0cm9uZz4tLUxhIGRhdGEgZSBsJ29yYSBwacO5IHJlY2VudGkgYWxsZSBxdWFsaSB1biBwaXhlbCDDqCBzdGF0byBjb250cmFzc2VnbmF0byBjb21lIHZhcmlhemlvbmUuPC9saT48bGk+PHN0cm9uZz5PcmEgZGkgbWFnZ2lvcmUgdmFyaWF6aW9uZTwvc3Ryb25nPi0tTGEgZGF0YSBlIGwnb3JhIGFsbGUgcXVhbGkgw6ggc3RhdGEgY2FsY29sYXRhIGxhIHZhcmlhemlvbmUgcGnDuSBzaWduaWZpY2F0aXZhIHBlciB1biBwaXhlbC48L2xpPjxsaT48c3Ryb25nPk51bWVybyBkaSB2YXJpYXppb25pPC9zdHJvbmc+LS1JbCBudW1lcm8gdG90YWxlIGRpIHZhcmlhemlvbmkgZGkgdW4gcGl4ZWwuPC9saT48L3VsPjxkaXY+UXVhbmRvIHNpIGVzZWd1ZSBxdWVzdGEgZnVuemlvbmUgc3VsbCdvdXRwdXQgZGFsbGEgZnVuemlvbmUvYXR0cmV6em8gTGFuZFRyZW5kciwgc29ubyBkaXNwb25pYmlsaSBsZSBzZWd1ZW50aSBvcHppb25pIGFnZ2l1bnRpdmU6PC9kaXY+PHVsPjxsaT48c3Ryb25nPk9yYSBkZWxsYSBtb2RpZmljYSBwacO5IGx1bmdhPC9zdHJvbmc+LS1MYSBkYXRhIGluIGN1aSB1biBwaXhlbCDDqCBzdGF0byBzZWduYWxhdG8gY29tZSB2YXJpYXppb25lLCBhbGwnaW5pemlvIG8gYWxsYSBmaW5lIGRlbCBwZXJpb2RvIGRpIHZhcmlhemlvbmUgcGnDuSBsdW5nby48L2xpPjxsaT48c3Ryb25nPk9yYSBkZWxsYSB2YXJpYXppb25lIHBpw7kgYnJldmU8L3N0cm9uZz4tLUxhIGRhdGEgaW4gY3VpIHVuIHBpeGVsIMOoIHN0YXRvIHNlZ25hbGF0byBjb21lIHZhcmlhemlvbmUsIGFsbCdpbml6aW8gbyBhbGxhIGZpbmUgZGVsIHBlcmlvZG8gZGkgbW9kaWZpY2EgcGnDuSBicmV2ZS48L2xpPjxsaT48c3Ryb25nPk9yYSBkaSB2YXJpYXppb25lIHBpw7kgdmVsb2NlPC9zdHJvbmc+LS1MYSBkYXRhIGluIGN1aSB1biBwaXhlbCDDqCBzdGF0byBzZWduYWxhdG8gY29tZSB2YXJpYXppb25lLCBhbGwnaW5pemlvIG8gYWxsYSBmaW5lIGRlbCBwZXJpb2RvIGRpIG1vZGlmaWNhIHBpw7kgYnJldmUuPC9saT48bGk+PHN0cm9uZz5PcmEgZGVsbGEgdmFyaWF6aW9uZSBwacO5IGxlbnRhPC9zdHJvbmc+LS1MYSBkYXRhIGluIGN1aSB1biBwaXhlbCDDqCBzdGF0byBzZWduYWxhdG8gY29tZSB2YXJpYXppb25lLCBhbGwnaW5pemlvIG8gYWxsYSBmaW5lIGRlbCBwZXJpb2RvIGRpIHZhcmlhemlvbmUgcGnDuSBsZW50YS4gPC9saT48L3VsPjxkaXY+SWwgcmFzdGVyIGRpIG91dHB1dCDDqCB1biByYXN0ZXIgbXVsdGliYW5kYSBuZWwgcXVhbGUgb2duaSBiYW5kYSBjb250aWVuZSBpbmZvcm1hemlvbmkgZGkgdmFyaWF6aW9uZSBkaXBlbmRlbnRpIGRhbCB0aXBvIGRpIHZhcmlhemlvbmUgc2VsZXppb25hdGEgZSBpbCBudW1lcm8gbWFzc2ltbyBkaSB2YXJpYXppb25pIHNwZWNpZmljYXRlLiBQZXIgZXNlbXBpbywgc2UgPHN0cm9uZz5UaXBvIGRpIHZhcmlhemlvbmU8L3N0cm9uZz4gw6ggaW1wb3N0YXRvIHN1IDxzdHJvbmc+T3JhIGRpIHZhcmlhemlvbmUgcGnDuSByZWNlbnRlPC9zdHJvbmc+IGUgPHN0cm9uZz5OdW1lcm8gbWFzc2ltbyBkaSB2YXJpYXppb25pPC9zdHJvbmc+IMOoIGltcG9zdGF0byBzdSAyLCBsYSBmdW56aW9uZSBjYWxjb2xhIGxlIGR1ZSBkYXRlIHBpw7kgcmVjZW50aSBxdWFuZG8gbGEgdmFyaWF6aW9uZSDDqCBhdnZlbnV0YSB0cmFtaXRlIGxhIHNlcmllIGRpIG9yYXJpIHBlciBvZ25pIHBpeGVsLiBJbCByaXN1bHRhdG8gw6ggdW4gcmFzdGVyIG5lbCBxdWFsZSBsYSBwcmltYSBiYW5kYSBjb250aWVuZSBsZSBkYXRlIGRlbGxhIHZhcmlhemlvbmUgcGnDuSByZWNlbnRlIHBlciBwaXhlbCwgZSBsYSBzZWNvbmRhIGJhbmRhIGNvbnRpZW5lIGxlIGRhdGUgZGVsbGEgcGVudWx0aW1hIHZhcmlhemlvbmUgcGnDuSByZWNlbnRlIHBlciBwaXhlbC48L2Rpdj48YnI+PGRpdj5RdWFuZG8gc2kgYXBwbGljYSBxdWVzdGEgZnVuemlvbmUgc3UgdW4gb3V0cHV0IGRhZ2xpIHN0cnVtZW50aSBMYW5kVHJlbmRyLCDDqCBwb3NzaWJpbGUgc2NlZ2xpZXJlIHNlIGVzdHJhcnJlIGxhIGRhdGEgY2hlIGNvbnRyYXNzZWduaSBsJ2luaXppbyBkaSB1bmEgdmFyaWF6aW9uZSBvIGxhIGZpbmUgZGkgdW5hIHZhcmlhemlvbmUgdXRpbGl6emFuZG8gaWwgcGFyYW1ldHJvIDxzdHJvbmc+RGF0YSBzZWdtZW50bzwvc3Ryb25nPi4gUGVyIGVzZW1waW8sIHBlciBjb21wcmVuZGVyZSBjb21lIGxhIHZhcmlhemlvbmUgcGnDuSByZWNlbnRlIGluIHVuYSBzZXJpZSBkaSBvcmFyaSBjb21pbmNpYXRpLCBpbXBvc3RhcmUgPHN0cm9uZz5DYW1iaWEgdGlwb2xvZ2lhPC9zdHJvbmc+IHN1IDxzdHJvbmc+T3JhIGRlbGwndWx0aW1hIHZhcmlhemlvbmU8L3N0cm9uZz4gZSA8c3Ryb25nPkRhdGEgc2VnbWVudG88L3N0cm9uZz4gc3UgPHN0cm9uZz5Jbml6aW8gZGkgdW4gc2VnbWVudG88L3N0cm9uZz48L2Rpdj48YnI+PGRpdj5VdGlsaXp6YXJlIGkgZmlsdHJpIHBhcmFtZXRyaSBzZWd1ZW50aSBwZXIgZXN0cmFycmUgZGF0aSBwacO5IHNwZWNpZmljaGUgZGkgdmFyaWF6aW9uZSBkYWwgcmFzdGVyIGRpIHZhcmlhemlvbmUgYW5hbGlzaTo8L2Rpdj48dWw+PGxpPjxzdHJvbmc+RmlsdHJvIHBlciBhbm5vPC9zdHJvbmc+LS1JZGVudGlmaWNhcmUgbGUgdmFyaWF6aW9uaSBjaGUgYXZ2ZW5nb25vIGFsbCdpbnRlcm5vIGRpIHVuIHBlcmlvZG8gc3BlY2lmaWNvLCBwZXIgZXNlbXBpbywgc2Ugc2kgc3RhIGNlcmNhbmRvIHZhcmlhemlvbmkgYXZ2ZW51dGUgaW4gdW4gcGVyaW9kbyBkaSBjaW5xdWUgYW5uaSBkaSBzaWNjaXTDoC48L2xpPjxsaT48c3Ryb25nPkZpbHRybyBwZXIgZHVyYXRhPC9zdHJvbmc+LS1JZGVudGlmaWNhcmUgbGUgdmFyaWF6aW9uaSBjaGUgYXZ2ZW5nb25vIHN1IHVuIHBlcmlvZG8gZGkgYW5uaSwgcGVyIGVzZW1waW8sIHNlIHNpIHN0YSBjZXJjYW5kbyB2YXJpYXppb25pIGJydXNjaGUgY2hlIHNpYW5vIGF2dmVudXRlIGluIDEgbyAyIGFubmkuIMOIIHBvc3NpYmlsZSBjYWxjb2xhcmUgbGEgZHVyYXRhIGEgY3VpIHNpIMOoIGludGVyZXNzYXRpIHBlciBsJ3V0aWxpenpvIGRlbGxhIGZvcm11bGEgPHN0cm9uZz5jb25jbHVkZXJlIGFubm8gLSBpbml6aWFyZSBhbm5vICsxPC9zdHJvbmc+LiBJbnRlcnZhbGxpIG5lbGxhIHNlcmllIGRpIG9yYXJpIHBvc3Nvbm8gZXNzZXJlIGluY2x1c2kuPC9saT48bGk+PHN0cm9uZz5GaWx0cm8gcGVyIHJpbGV2YW56YTwvc3Ryb25nPi0tSWRlbnRpZmljYXJlIGxlIHZhcmlhemlvbmkgZGkgdW5hIHJpbGV2YW56YSBkYXRhLCBwZXIgZXNlbXBpbywgc2Ugc2kgc3RhIGNlcmNhbmRvIHNvbGFtZW50ZSBwZXIgdmFyaWF6aW9uaSBncmFuZGkgbmVsbCdpbmRpY2UgTkRWSSBkZWxsYSB2ZWdldGF6aW9uZS4gTGEgcmlsZXZhbnphIMOoIHVuIHZhbG9yZSBhc3NvbHV0bywgaW4gbW9kbyBjaGUgaSB2YWxvcmkgbWluaW1pIGUgbWFzc2ltaSBub24gcG9zc2FubyBlc3NlcmUgbmVnYXRpdmkuIFBlciBzcGVjaWZpY2FyZSBsYSB2YXJpYXppb25lIGRpcmV6aW9uYWxlLCB1dGlsaXp6YXJlIGlsIHBhcmFtZXRybyA8c3Ryb25nPlZhcmlhIGRpcmV6aW9uZTwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25OYW1lOiBcIkFjY3VtdWxvIGRpc3RhbnphXCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25TbmlwOiBcIkNhbGNvbGEgbGEgZGlzdGFuemEgYWNjdW11bGF0YSBwZXIgY2lhc2N1bmEgY2VsbGEgZGFsbGUgb3JpZ2luaSwgY29uc2VudGVuZG8gZGkgb3R0ZW5lcmUgbGEgZGlzdGFuemEgaW4gbGluZWEgcmV0dGEsIGxhIGRpc3RhbnphIGRpIGNvc3RvLCBsYSBkaXN0YW56YSBkZWxsYSBzdXBlcmZpY2llIHJlYWxlLCBub25jaMOpIGkgZmF0dG9yaSBkaSBjb3N0byB2ZXJ0aWNhbGUgZSBvcml6em9udGFsZS5cIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvbkRlc2M6IFwiQWNjdW11bG8gZGlzdGFuemEgY2FsY29sYSBsYSBkaXN0YW56YSBkYSBjaWFzY3VuYSBwb3NpemlvbmUgbmVsbCdhcmVhIGRpIHN0dWRpbyBhbGwnb3JpZ2luZSBwacO5IHZpY2luYSBvIGRpIGNvc3RvIG1pbmltby4gU2UgdmVuZ29ubyBzcGVjaWZpY2F0ZSBzb2xvIGxlIG9yaWdpbmkgcGVyIGwnaW5wdXQsIGFsbG9yYSBzaSBjYWxjb2xhIHVuYSBkaXN0YW56YSBpbiBsaW5lYSByZXR0YSBkYSBjaWFzY3VuYSBwb3NpemlvbmUgbmVsbCdhcmVhIGRpIHN0dWRpby4gU2UgY29tZSBpbnB1dCB2ZW5nb25vIHV0aWxpenphdGUgc2lhIGxlIG9yaWdpbmkgc2lhIGxlIGJhcnJpZXJlLCBhbGxvcmEgQWNjdW11bG8gZGlzdGFuemEgY2FsY29sYSBsYSBkaXN0YW56YSBpbiBsaW5lYSByZXR0YSBpbnRvcm5vIGFsbGUgYmFycmllcmUu4oCLU2lhIHBlciBpbCByYXN0ZXIgZGkgb3JpZ2luZSBzaWEgcGVyIHF1ZWxsbyBkaSBiYXJyaWVyYSwgaWwgdmFsb3JlIGRpIHNmb25kbyBkZXZlIGVzc2VyZSBOb0RhdGEsIG1lbnRyZSBsZSBvcmlnaW5pIGUgbGUgYmFycmllcmUgc29ubyByYXBwcmVzZW50YXRlIGNvbiB2YWxvcmkgZGkgY2VsbGEgdmFsaWRpLiBJIHZhbG9yaSB2YWxpZGkgaW5jbHVkb25vIGxvIHplcm8uIDxkaXY+PGJyLz5RdWFuZG8gdW4gcmFzdGVyIGRpIHN1cGVyZmljaWUgdmllbmUgZm9ybml0byBjb21lIGlucHV0LCBhbGxvcmEgc2kgY2FsY29sYSBsYSBkaXN0YW56YSBkaSBzdXBlcmZpY2llIHJlYWxlIHRyYSBsZSBjZWxsZS4gUGVyIGVzZWd1aXJlIGwnYW5hbGlzaSBkaSBjb3N0byBhZG9wZXJhbmRvIEFjY3VtdWxvIGRpc3RhbnphLCDDqCBuZWNlc3NhcmlhIHVuYSBzdXBlcmZpY2llIGRpIGNvc3RvLiBTZSBzaSBmb3JuaXNjZSB1bmEgc3VwZXJmaWNpZSBkaSBjb3N0bywgYWxsb3JhIGlsIHJpc3VsdGF0byDDqCB1biByYXN0ZXIgZGVsbGEgZGlzdGFuemEgZGkgY29zdG8gYWNjdW11bGF0YS4gUXVhbmRvIHNvbm8gc3BlY2lmaWNhdGkgZmF0dG9yaSBvcml6em9udGFsaSBlIHZlcnRpY2FsaSwgYWxsb3JhIHNpIGNvbnNpZGVyYSBsYSBkaXJlemlvbmFsaXTDoCBtZW50cmUgc2kgYWNjdW11bGEgaWwgY29zdG8uIEVzaXN0b25vIHF1YXR0cm8gY2FyYXR0ZXJpc3RpY2hlIGRpIG9yaWdpbmUgdXRpbGl6emFiaWxpLiBRdWVzdGUgY2FyYXR0ZXJpc3RpY2hlLCBjaGUgcG9zc29ubyBlc3NlcmUgZGVsbCdvcmlnaW5lIG8gbW92aW1lbnRpIGRhbGwnb3JpZ2luZSwgc29ubyBjb250cm9sbGF0ZSBkYSBwYXJhbWV0cmkgc3BlY2lmaWNpOuKAizEuIEFjY3VtdWxvIGluaXppYWxlOuKAr2ltcG9zdGEgaWwgY29zdG8gaW5pemlhbGUgcHJpbWEgZGVsbCdhdnZpbyBkZWwgbW92aW1lbnRvLiAyLiBBY2N1bXVsbyBtYXNzaW1vOuKAr3NwZWNpZmljYSBpbCBjb3N0byBjaGUgdW4nb3JpZ2luZSBwdcOyIGFjY3VtdWxhcmUgcHJpbWEgZGkgcmFnZ2l1bmdlcmUgaWwgcHJvcHJpbyBsaW1pdGUuIDMuIE1vbHRpcGxpY2F0b3JlIGRhIGFwcGxpY2FyZSBhaSBjb3N0aTrigK9zcGVjaWZpY2EgbGEgbW9kYWxpdMOgIGRpIHZpYWdnaW8gbyBsYSBncmFuZGV6emEgYWxsJ29yaWdpbmUuIDQuIERpcmV6aW9uZSBkaSB2aWFnZ2lvOuKAr2lkZW50aWZpY2Egc2UgaWwgbW92aW1lbnRvIHBhcnRlIGRhIHVuJ29yaWdpbmUgZSBzaSBzcG9zdGEgc3UgcG9zaXppb25pIG5vbiBkaSBvcmlnaW5lLCBvcHB1cmUgc2UgcGFydGUgZGEgcG9zaXppb25pIG5vbiBkaSBvcmlnaW5lIGUgdG9ybmEgYSB1bidvcmlnaW5lLjxkaXY+PGJyLz5QZXIgaW1wb3N0YXppb25lIHByZWRlZmluaXRhLCBpbCByaXN1bHRhdG8gZGkgQWNjdW11bG8gZGlzdGFuemEgw6ggdW5hIGJhbmRhIHNpbmdvbGEsIGNoZSBjb3N0aXR1aXNjZSBpbCByYXN0ZXIgZGkgYWNjdW11bG8gZGlzdGFuemEuIFR1dHRhdmlhLCDDqCBhbmNoZSBwb3NzaWJpbGUgY3JlYXJlIHVuYSBzZWNvbmRhIGJhbmRhLCBsYSBiYW5kYSBkaSBkaXJlemlvbmUgY29udHJhcmlhLuKAi1F1ZXN0YSBiYW5kYSBpbmRpY2EgaW4gcXVhbGUgZGlyZXppb25lIGFuZGFyZSBwZXIgYXJyaXZhcmUgYWxsJ29yaWdpbmUgZGkgY29zdG8gbWluaW1vIGEgcGFydGlyZSBkYSBjaWFzY3VuYSBwb3NpemlvbmUgbmVsbCdhcmVhIGRpIHN0dWRpby4gRW50cmFtYmUgbGUgYmFuZGUgc2FyYW5ubyBuZWNlc3NhcmllIHBlciBzdGFiaWxpcmUgaSBwZXJjb3JzaSBvdHRpbWFsaSBhbGwnaW50ZXJubyBkZWxsJ2FyZWEgZGkgc3R1ZGlvLiBQZXIgZ2VuZXJhcmUgdW4gcGVyY29yc28sIHV0aWxpenphcmUgcHJpbWEgbGEgZnVuemlvbmUgRXN0cmFpIGJhbmRhIHBlciBlc3RyYXJyZSBpbCByYXN0ZXIgZGkgYWNjdW11bG8gZGVsbGEgZGlzdGFuemEgZSBpbCByYXN0ZXIgZGkgZGlyZXppb25lIGNvbnRyYXJpYS4gVXRpbGl6emFyZSBxdWVzdGkgbGF5ZXIgY29tZSBpbnB1dCBwZXIgbGEgZnVuemlvbmUgUGVyY29yc28gZGkgY29zdG8uIE5lbGxhIGZ1bnppb25lLCB1dGlsaXp6YXJlIGlsIHJhc3RlciBkaSBhY2N1bXVsbyBkZWxsYSBkaXN0YW56YSBjb21lIGlucHV0IGRlbCByYXN0ZXIgZGVsbGEgZGlzdGFuemEgZGkgY29zdG8gZSBpbCByYXN0ZXIgZGkgZGlyZXppb25lIGNvbnRyYXJpYSBjb21lIGlucHV0IGRlbCByYXN0ZXIgYmFja2xpbmsgZGVpIGNvc3RpLjwvZGl2PlwiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvbk5hbWU6IFwiQXNzZWduYXppb25lIGRlbGxhIGRpc3RhbnphXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uU25pcDogXCJDYWxjb2xhIGwnYXNzZWduYXppb25lIGRlbGxhIGRpc3RhbnphIHBlciBjaWFzY3VuYSBjZWxsYSBkYWxsZSBvcmlnaW5pIGZvcm5pdGUgaW4gYmFzZSBhIGRpc3RhbnphIGluIGxpbmVhIHJldHRhLCBkaXN0YW56YSBkaSBjb3N0bywgZGlzdGFuemEgZGVsbGEgc3VwZXJmaWNpZSByZWFsZSBlIGZhdHRvcmkgZGkgY29zdG8gdmVydGljYWxlIGUgb3JpenpvbnRhbGUuXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uRGVzYzogXCJBc3NlZ25hemlvbmUgZGVsbGEgZGlzdGFuemEgY2FsY29sYSBhIHF1YWxlIG9yaWdpbmUgw6ggYXNzZWduYXRhIGNpYXNjdW5hIHBvc2l6aW9uZSBuZWxsJ2FyZWEgZGkgc3R1ZGlvLiBTZSBwZXIgbCdpbnB1dCBzb25vIHNwZWNpZmljYXRlIHNvbG8gbGUgb3JpZ2luaSwgYWxsb3JhIGxlIHBvc2l6aW9uaSB2ZW5nb25vIGFzc2VnbmF0ZSB1dGlsaXp6YW5kbyB1bmEgZGlzdGFuemEgaW4gbGluZWEgcmV0dGEgcmlzcGV0dG8gYWxsJ29yaWdpbmUgcGnDuSB2aWNpbmEuIFNlIGNvbWUgaW5wdXQgdmVuZ29ubyB1dGlsaXp6YXRlIHNpYSBsZSBvcmlnaW5pIHNpYSBsZSBiYXJyaWVyZSwgYWxsb3JhIEFzc2VnbmF6aW9uZSBkZWxsYSBkaXN0YW56YSBjYWxjb2xhIGxhIGRpc3RhbnphIGluIGxpbmVhIHJldHRhIGludG9ybm8gYWxsZSBiYXJyaWVyZSBwZXIgc3RhYmlsaXJlIGEgcXVhbGUgb3JpZ2luZSDDqCBhc3NlZ25hdGEgdW5hIHBvc2l6aW9uZS7igItTaWEgcGVyIGlsIHJhc3RlciBkaSBvcmlnaW5lIHNpYSBwZXIgcXVlbGxvIGRpIGJhcnJpZXJhLCBpbCB2YWxvcmUgZGkgc2ZvbmRvIGRldmUgZXNzZXJlIE5vRGF0YSwgbWVudHJlIGxlIG9yaWdpbmkgZSBsZSBiYXJyaWVyZSBzb25vIHJhcHByZXNlbnRhdGUgY29uIHZhbG9yaSBkaSBjZWxsYSB2YWxpZGkuIEkgdmFsb3JpIHZhbGlkaSBpbmNsdWRvbm8gbG8gemVyby48ZGl2Pjxici8+UGVyIGVzZWd1aXJlIGwnYW5hbGlzaSBkaSBjb3N0byBhZG9wZXJhbmRvIEFzc2VnbmF6aW9uZSBkZWxsYSBkaXN0YW56YSwgw6ggbmVjZXNzYXJpYSB1bmEgc3VwZXJmaWNpZSBkaSBjb3N0by4gU2Ugw6ggc3BlY2lmaWNhdGEgdW5hIHN1cGVyZmljaWUgZGkgY29zdG8sIGFsbG9yYSBpbCByaXN1bHRhdG8gw6ggdW4gcmFzdGVyIGRpIGFzc2VnbmF6aW9uZSBiYXNhdG8gc3VsIGNvc3RvIGN1bXVsYXRpdm8sIG5vbiBzdWxsYSBkaXN0YW56YSBpbiBsaW5lYSByZXR0YS4gUXVhbmRvIHNvbm8gc3BlY2lmaWNhdGkgZmF0dG9yaSBvcml6em9udGFsaSBlIHZlcnRpY2FsaSwgYWxsb3JhIHNpIGNvbnNpZGVyYSBsYSBkaXJlemlvbmFsaXTDoCBtZW50cmUgc2kgYWNjdW11bGEgaWwgY29zdG8uIFF1YW5kbyB1biByYXN0ZXIgZGkgc3VwZXJmaWNpZSB2aWVuZSBmb3JuaXRvIGNvbWUgaW5wdXQsIGFsbG9yYSBxdWFuZG8gc2kgc3RhYmlsaXNjZSBsJ2Fzc2VnbmF6aW9uZSBzaSBjYWxjb2xhIGxhIGRpc3RhbnphIGRpIHN1cGVyZmljaWUgcmVhbGUgcGVyY29yc2EgbmVsIHBhc3NhZ2dpbyB0cmEgbGUgY2VsbGUuIEVzaXN0b25vIHF1YXR0cm8gY2FyYXR0ZXJpc3RpY2hlIGRpIG9yaWdpbmUgdXRpbGl6emFiaWxpLiBRdWVzdGUgY2FyYXR0ZXJpc3RpY2hlLCBjaGUgcG9zc29ubyBlc3NlcmUgZGVsbCdvcmlnaW5lIG8gbW92aW1lbnRpIGRhbGwnb3JpZ2luZSwgc29ubyBjb250cm9sbGF0ZSBkYSBwYXJhbWV0cmkgc3BlY2lmaWNpOuKAizEuIEFjY3VtdWxvIGluaXppYWxlOuKAr2ltcG9zdGEgaWwgY29zdG8gaW5pemlhbGUgcHJpbWEgZGVsbCdhdnZpbyBkZWwgbW92aW1lbnRvLiAyLiBBY2N1bXVsbyBtYXNzaW1vOuKAr3NwZWNpZmljYSBpbCBjb3N0byBjaGUgdW4nb3JpZ2luZSBwdcOyIGFjY3VtdWxhcmUgcHJpbWEgZGkgcmFnZ2l1bmdlcmUgaWwgcHJvcHJpbyBsaW1pdGUuIDMuIE1vbHRpcGxpY2F0b3JlIGRhIGFwcGxpY2FyZSBhaSBjb3N0aTrigK9zcGVjaWZpY2EgbGEgbW9kYWxpdMOgIGRpIHZpYWdnaW8gbyBsYSBncmFuZGV6emEgYWxsJ29yaWdpbmUuIDQuIERpcmV6aW9uZSBkaSB2aWFnZ2lvOuKAr2lkZW50aWZpY2Egc2UgaWwgbW92aW1lbnRvIHBhcnRlIGRhIHVuJ29yaWdpbmUgZSBzaSBzcG9zdGEgc3UgcG9zaXppb25pIG5vbiBkaSBvcmlnaW5lLCBvcHB1cmUgc2UgcGFydGUgZGEgcG9zaXppb25pIG5vbiBkaSBvcmlnaW5lIGUgdG9ybmEgYSB1bidvcmlnaW5lLjxkaXY+PGJyLz5QZXIgaW1wb3N0YXppb25lIHByZWRlZmluaXRhLCBpbCByaXN1bHRhdG8gZGkgQXNzZWduYXppb25lIGRlbGxhIGRpc3RhbnphIMOoIHVuYSBiYW5kYSBzaW5nb2xhLCBjaGUgY29zdGl0dWlzY2UgaWwgcmFzdGVyIGRpIGFzc2VnbmF6aW9uZSBkZWxsYSBkaXN0YW56YS4gU2VsZXppb25hbmRvIGwnb3B6aW9uZSBib29sZWFuYSBHZW5lcmEgcmlnYSBlIGNvbG9ubmEgZGkgb3JpZ2luZSBjb21lIGJhbmRlIGFnZ2l1bnRpdmUgbmVsbCdvdXRwdXQgc2kgb3R0ZXJyw6AgdW4gcmFzdGVyIG11bHRpYmFuZGEgY29zdGl0dWl0byBkYSB0cmUgYmFuZGUuIExhIHByaW1hIGJhbmRhIMOoIGxhIGJhbmRhIGRpIGFsbG9jYXppb25lIGRlbGxhIGRpc3RhbnphLCBsYSBzZWNvbmRhIGJhbmRhIGNvbnRpZW5lIHVuIGluZGljZSBkaSByaWdhIGUgbGEgdGVyemEgYmFuZGEgY29udGllbmUgdW4gaW5kaWNlIGRpIGNvbG9ubmEuIFF1ZXN0aSBpbmRpY2kgaWRlbnRpZmljYW5vIGxhIHBvc2l6aW9uZSBkZWxsYSBjZWxsYSBkaSBvcmlnaW5lIGNoZSBzaSB0cm92YSBhbGxhIG1pbm9yZSBkaXN0YW56YSBkaSBjb3N0byBjdW11bGF0aXZhLiBMJ2luZGljZSBkZWxsYSByaWdhIGRpIG9yaWdpbmUgZSBsJ2luZGljZSBkZWxsYSBjb2xvbm5hIGRpIG9yaWdpbmUgcG9zc29ubyBlc3NlcmUgdXRpbGl6emF0aSBpbnNpZW1lIHBlciBlc2VndWlyZSBpbCBtYXBwaW5nIGRpIGludGVuc2l0w6AuIFNlIHNpIGludGVycm9nYSB1bmEgcXVhbHVucXVlIHBvc2l6aW9uZSBuZWxsJ2FyZWEgZGkgc3R1ZGlvIHRyYSBsZSBiYW5kZSBkdWUgZSB0cmUsIHNpIGNvbm9zY2Vyw6AgbGEgcmlnYSBlIGxhIGNvbG9ubmEgZGVsbCdvcmlnaW5lIGRpIGNvc3RvIG1pbmltbyBwZXIgcXVlbGxhIHBvc2l6aW9uZS48L2Rpdj5cIixcblx0XHRldWNCYWNrRGlyZWN0aW9uTmFtZTogXCJCYWNrIERpcmVjdGlvbiBldWNsaWRlYVwiLFxuXHRcdGV1Y0JhY2tEaXJlY3Rpb25TbmlwOiBcIkNhbGNvbGEsIHBlciBvZ25pIGNlbGxhLCBsYSBkaXJlemlvbmUgaW4gZ3JhZGkgZmlubyBhbGxhIGNlbGxhIHZpY2luYSBzZWd1ZW5kbyBpbCBwZXJjb3JzbyBwacO5IGJyZXZlIGZpbm8gYWxsYSBmb250ZSBwacO5IHZpY2luYSBldml0YW5kbyBiYXJyaWVyZS5cIixcblx0XHRldWNCYWNrRGlyZWN0aW9uRGVzYzogXCJMYSBmdW56aW9uZSBCYWNrIERpcmVjdGlvbiBldWNsaWRlYSBjcmVhIHVuIHJhc3RlciBhIHZpcmdvbGEgbW9iaWxlIGNvbnRpbnVvIGNoZSByYXBwcmVzZW50YSBsYSBkaXJlemlvbmUgZGkgcml0b3JubyBhbGwnb3JpZ2luZSBwacO5IHZpY2luYSBpbiBncmFkaSBldml0YW5kbyBsZSBiYXJyaWVyZSwgbmVsIGNhc28gaW4gY3VpIHZpIGZvc3Nlcm8gYmFycmllcmUuPGRpdj48YnIvPkdsaSBpbnB1dCBkZWxsYSBCYWNrIERpcmVjdGlvbiBldWNsaWRlYSBzb25vIGwnb3JpZ2luZSBpbiBiYXNlIGFsbGEgcXVhbGUgc2Fyw6AgY2FsY29sYXRhIHF1ZWxsYSBkaXJlemlvbmUuIFVuIGlucHV0IG9wemlvbmFsZSDDqCB1biByYXN0ZXIgY2hlIHJhcHByZXNlbnRhIGxlIGJhcnJpZXJlIGFsbCdpbnRlcm5vIGRlbGwnYXJlYSBkaSBzdHVkaW8u4oCLU2lhIHBlciBpbCByYXN0ZXIgZGkgb3JpZ2luZSBzaWEgcGVyIHF1ZWxsbyBkaSBiYXJyaWVyYSwgaWwgdmFsb3JlIGRpIHNmb25kbyBkZXZlIGVzc2VyZSBOb0RhdGEsIG1lbnRyZSBsZSBvcmlnaW5pIGUgbGUgYmFycmllcmUgc29ubyByYXBwcmVzZW50YXRlIGNvbiB2YWxvcmkgdmFsaWRpLiBJIHZhbG9yaSB2YWxpZGkgaW5jbHVkb25vIGxvIHplcm8uIFBlciBpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEsIGlsIGNhbGNvbG8gdmVycsOgIGVzZWd1aXRvIGZpbm8gYWxsJ2VzdGVuc2lvbmUgY29tYmluYXRhIGRpIG9yaWdpbmkgZSBiYXJyaWVyZSwgcGnDuSAyIHJpZ2hlIGUgY29sb25uZS4gU2UgbCdhbmFsaXNpIHNlcnZlIHNvbG8gYWxsJ2ludGVybm8gZGkgdW5hIGRpc3RhbnphIHNwZWNpZmljYSBkYWxsZSBvcmlnaW5pLCBhbGxvcmEgw6ggcG9zc2liaWxlIHV0aWxpenphcmUgaWwgcGFyYW1ldHJvIERpc3RhbnphIG1hc3NpbWEuIEJhY2sgRGlyZWN0aW9uIGV1Y2xpZGVhIHN1cHBvcnRhIG5lbCBjYWxjb2xvIHNpYSB1biBtZXRvZG8gUGxhbmFyZSBzaWEgdW4gbWV0b2RvIEdlb2RldGljby4gSWwgY2FsY29sbyBkZWwgbWV0b2RvIFBsYW5hcmUgdmVycsOgIGVzZWd1aXRvIHN1IHVuIHBpYW5vIHBpYXR0byBwcm9pZXR0YXRvIHV0aWxpenphbmRvIHVuIHNpc3RlbWEgZGkgY29vcmRpbmF0ZSBjYXJ0ZXNpYW5lIDJELiBJbCBjYWxjb2xvIGRlbCBtZXRvZG8gR2VvZGV0aWNvIHZlcnLDoCBlc2VndWl0byBzdWxsJ2VsbGlzc29pZGUsIGlsIGNoZSBzaWduaWZpY2EgY2hlIGEgcHJlc2NpbmRlcmUgZGFsbGEgcHJvaWV6aW9uZSBkaSBpbnB1dCBvIGRpIG91dHB1dCBpIHJpc3VsdGF0aSBub24gY2FtYmlhbm8uPGRpdj48YnIvPklsIHJpc3VsdGF0byBkZWxsYSBmdW56aW9uZSBCYWNrIERpcmVjdGlvbiBldWNsaWRlYSBwdcOyIGVzc2VyZSB1dGlsaXp6YXRvIGluIGNvbWJpbmF6aW9uZSBjb24gaWwgcmlzdWx0YXRvIGRlbGxhIGZ1bnppb25lIERpc3RhbnphIGV1Y2xpZGVhIHBlciBzdGFiaWxpcmUgaSBwZXJjb3JzaSBwacO5IGJyZXZpIGRhbGxlIHBvc2l6aW9uaSBhbGwnaW50ZXJubyBkZWxsJ2FyZWEgZGkgc3R1ZGlvIGFsbCdvcmlnaW5lLiBTaWEgaWwgcmlzdWx0YXRvIGRpIEJhY2sgRGlyZWN0aW9uIGV1Y2xpZGVhIHNpYSBxdWVsbG8gZGkgRGlzdGFuemEgZXVjbGlkZWEgdmVuZ29ubyB1dGlsaXp6YXRpIG5lbGxhIGZ1bnppb25lIFBlcmNvcnNvIGRpIGNvc3RvIGluc2llbWUgYWxsZSBkZXN0aW5hemlvbmkgcGVyIGdlbmVyYXJlIGkgcGVyY29yc2kgcGnDuSBicmV2aS48L2Rpdj5cIixcblx0XHRleHBhbmROYW1lOiBcIkVzcGFuZGlcIixcblx0XHRleHBhbmRTbmlwOiBcIkVzcGFuZGUgbGUgem9uZSBzZWxlemlvbmF0ZSBkaSB1biByYXN0ZXIgcGVyIHpvbmUgZGVsIG51bWVybyBzcGVjaWZpY2F0byBkaSBjZWxsZS5cIixcblx0XHRleHBhbmREZXNjOiBcIkNvbiBsYSBmdW56aW9uZSBnbG9iYWxlIEVzcGFuZGksIMOoIHBvc3NpYmlsZSBnZW5lcmFsaXp6YXJlIG8gc2VtcGxpZmljYXJlIGkgcmFzdGVyIGFtcGxpYW5kbyB6b25lIHNwZWNpZmljaGUuIMOIIGFuY2hlIHBvc3NpYmlsZSBjb250cm9sbGFyZSBsYSBxdWFudGl0w6AgZGkgZ2VuZXJhbGl6emF6aW9uZSBjaGUgYXZ2ZXJyw6AuPGRpdj48YnIvPkxlIHpvbmUgc2VsZXppb25hdGUgYXVtZW50ZXJhbm5vIGRpIGRpbWVuc2lvbmUgZXNwYW5kZW5kb3NpIGluIGFsdHJlIHpvbmUuIENvbmNldHR1YWxtZW50ZSwgw6ggcG9zc2liaWxlIHZpc3VhbGl6emFyZSBpIHZhbG9yaSBkaSB6b25hIHNlbGV6aW9uYXRpIGNvbWUgem9uZSBpbiBwcmltbyBwaWFubywgbWVudHJlIGdsaSBhbHRyaSB2YWxvcmkgcmltYW5nb25vIHpvbmUgc3VsbG8gc2ZvbmRvLiBMZSB6b25lIGluIHByaW1vIHBpYW5vIHBvc3Nvbm8gZXNwYW5kZXJzaSBuZWxsZSB6b25lIHN1bGxvIHNmb25kby48ZGl2Pjxici8+TGEgcXVhbnRpdMOgIGRpIGdlbmVyYWxpenphemlvbmUgcHXDsiBlc3NlcmUgY29udHJvbGxhdGEgY29uIGlsIHBhcmFtZXRybyBOdW1lcm8gZGkgY2VsbGUuIFBlciBpbXBvc3RhemlvbmUgcHJlZGVmaW5pdGEsIHF1ZXN0byB2YWxvcmUgw6ggMSwgaWwgY2hlIHNpZ25pZmljYSBjaGUgbGUgem9uZSBzZWxlemlvbmF0ZSBzaSBlc3BhbmRlcmFubm8gZGVsbGEgcXVhbnRpdMOgIGNvcnJpc3BvbmRlbnRlIGFsbGEgZGltZW5zaW9uZSBkaSB1bmEgc29sYSBjZWxsYS4gUGVyIGF1bWVudGFyZSBpbCBncmFkbyBkaSBnZW5lcmFsaXp6YXppb25lLCDDqCBwb3NzaWJpbGUgc3BlY2lmaWNhcmUgdW4gdmFsb3JlIHBpw7kgZ3JhbmRlIHBlciBxdWVzdG8gcGFyYW1ldHJvLiBDb25jZXR0dWFsbWVudGUsIGNpw7IgZXF1aXZhbGUgYWQgZXNlZ3VpcmUgbG8gc3RydW1lbnRvIHRhbnRlIHZvbHRlIHF1YW50ZSBpbCBudW1lcm8gc3BlY2lmaWNhdG8gZSBjb24gaSByaXN1bHRhdGkgZGVsbCdlc2VjdXppb25lIHByZWNlZGVudGUgY29tZSBpbnB1dCBkZWxsJ2l0ZXJhemlvbmUgc3VjY2Vzc2l2YS48L2Rpdj5cIixcblx0XHR0cmVuZEFuYWx5c2lzTmFtZTogXCJHZW5lcmFyZSB0ZW5kZW56YVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTbmlwOiBcIlN0aW1hIGxhIHRlbmRlbnphIHBlciBjaWFzY3VuIHBpeGVsIGx1bmdvIHVuYSBkaW1lbnNpb25lIHBlciB1bmEgbyBwacO5IHZhcmlhYmlsaSBpbiB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUuXCIsXG5cdFx0dHJlbmRBbmFseXNpc0Rlc2M6IFwiPGRpdj5RdWVzdGEgZnVuemlvbmUgcHXDsiBlc3NlcmUgdXRpbGl6emF0YSBwZXIgYWRhdHRhcmUgZGF0aSBsdW5nbyB1bmEgbGluZWEgZGkgdHJlbmQgbGluZWFyZSwgYXJtb25pY2EgbyBwb2xpbm9taWNhIG8gcHXDsiBlc3NlcmUgdXRpbGl6emF0YSBwZXIgZWZmZXR0dWFyZSByaWxldmFtZW50byBkZWwgdHJlbmQgdXRpbGl6emFuZG8gaWwgdGVzdCBNYW5uLUtlbmRhbGwgbyBTZWFzb25hbC1LZW5kYWxsLjwvZGl2Pjxicj48ZGl2PklsIHJhc3RlciB0cmVuZCBkaSBvdXRwdXQgZ2VuZXJhdG8gY29uIHF1ZXN0YSBmdW56aW9uZSDDqCB1dGlsaXp6YXRvIGNvbWUgaW5wdXQgYWxsYSBmdW56aW9uZSA8c3Ryb25nPlByZWRpY2kgdXRpbGl6emFuZG8gdHJlbmQ8L3N0cm9uZz4uPC9kaXY+PGJyPjxkaXY+SSB0ZXN0IE1hbm4tS2VuZGFsbCBvIFNlYXNvbmFsLUtlbmRhbGwgc29ubyB1dGlsaXp6YXRpIHBlciBkZXRlcm1pbmFyZSBzZSBjJ8OoIHVuIHRyZW5kIG1vbm90b25pY28gbmVpIGRhdGkuIEVzc2kgbm9uIHNvbm8gcGFyYW1ldHJpY2ksIHNpZ25pZmljYSBjaGUgbm9uIGFzc3Vtb25vIHVuYSBkaXN0cmlidXppb25lIHNwZWNpZmljYSBkZWkgZGF0aS4gSWwgdGVzdCBNYW5uLUtlbmRhbGwgbm9uIGNvbnNpZGVyYSBsYSBjb3JyZWxhemlvbmUgc2VyaWFsZSBvIGdsaSBlZmZldHRpIHN0YWdpb25hbGkuIFNlIGkgZGF0aSBzb25vIHN0YWdpb25hbGksIGlsIHRlc3RvIFNlYXNvbmFsLUtlbmRhbGwgw6ggcGnDuSBhcHByb3ByaWF0by48L2Rpdj48YnI+PGRpdj5TZSBsbyBzdHJ1bWVudG8gw6ggdXRpbGl6emF0byBwZXIgZXNlZ3VpcmUgc2lhIGlsIHRlc3RvIE1hbm4tS2VuZGFsbCBjaGUgaWwgU2Vhc29uYWwtS2VuZGFsbCwgbCdvdXRwdXQgw6ggdW4gcmFzdGVyIGEgY2lucXVlIGJhbmRlIGNvbWUgc2VndWU6PC9kaXY+PHVsPjxsaT5CYW5kYSAxID0gUGVuZGVuemEgZGkgU2VuPC9saT48bGk+QmFuZGEgMiA9IHZhbG9yZSBwPC9saT48bGk+QmFuZGEgMyA9IFB1bnRlZ2dpbyBNYW5uLUtlbmRhbGwgKFMpPC9saT48bGk+QmFuZGEgNCA9IFZhcmlhbnphIFM8L2xpPjxsaT5CYW5kYSA0ID0gVmFyaWFuemEgUzwvbGk+PGxpPkJhbmRhIDUgPSBQdW50ZWdnaW8gWjwvbGk+PC91bD48ZGl2PkdsaSBvdXRwdXQgZGFsIHRlc3QgTWFubi1LZW5kYWxsIG8gU2Vhc29uYWwtS2VuZGFsbCBwb3Nzb25vIGVzc2VyZSB1c2FyZSBwZXIgZGV0ZXJtaW5hcmUgcXVhbGkgcGl4ZWwgbmVsbGEgc2VyaWUgZGkgb3JhcmkgbXVsdGlkaW1lbnNpb25hbGUgYWJiaWEgdHJlbmQgc3RhdGljYW1lbnRlIHNpZ25pZmljYXRpdmkuIMOIIHBvc3NpYmlsZSB1dGlsaXp6YXJlIHF1ZXN0YSBpbmZvcm1hemlvbmUgbmVsbGEgY29uZ2l1bnppb25lIGNvbiBsJ2FuYWxpc2kgZGkgdHJlbmQgbGluZWFyZSwgYXJtb25pY28gZSBwb2xpbm9taWFsZSBwZXIgZXN0cmFycmUgaSB0cmVuZCBzaWduaWZpY2F0aXZpIG5lbGxhIHNlcmllIGRpIG9yYXJpLiDDiCBwb3NzaWJpbGUgZ2VuZXJhcmUgdW5hIG1hc2NoZXJhIGluY2x1c2kgcGl4ZWwgY29uIHZhbG9yaSBwIHNpZ25pZmljYXRpdmksIGVzZWd1aXJlIGxhIG1hc2NoZXJhIGFsIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSwgZSB1dGlsaXp6YXJlIHF1ZXN0byByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUgbWFzY2hlcmF0byBjb21lIGlucHV0IGFsbG8gc3RydW1lbnRvIHBlciBlc2VndWlyZSB1bidhbmFsaXNpIGRpIHRyZW5kIGxpbmVhcmUsIGFybW9uaWNvIG8gcG9saW5vbWluYWxlLjwvZGl2Pjxicj48ZGl2PkNpIHNvbm8gdHJlIG9wemlvbmkgZGkgbGluZWEgZGkgdHJlbmQgcGVyIGFkYXR0YXJlIHVuIHRyZW5kIGEgdmFsb3JpIHZhcmlhYmlsaSBsdW5nbyB1bmEgZGltZW5zaW9uZTogbGluZWFyZSwgcG9saW5vbWlhbGUgZSBhcm1vbmljby48L2Rpdj48YnI+PGRpdj5QZXIgdW4nYW5hbGlzaSBkaSB0cmVuZCBsaW5lYXJlLCBsJ291dHB1dCDDqCB1biByYXN0ZXIgYSB0cmUgYmFuZGUgY29tZSBzZWd1ZTo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQZW5kZW56YTwvbGk+PGxpPkJhbmRhIDIgPSBJbnRlcmNldHRhcmU8L2xpPjxsaT5CYW5kYSAzID0gUmFkaWNlIGRlbGwnZXJyb3JlIHF1YWRyaWNvIG1lZGlvIChSTVNEKSBvIGwnZXJyb3JlIGF0dG9ybm8gYWxsYSBsaW5lYSBjaGUgc2kgYWRhdHRhIG1lZ2xpbzwvbGk+PC91bD48ZGl2PlBlciBsJ2FuYWxpc2kgZGkgdHJlbmQgcG9saW5vbWluYWxlLCBpbCBudW1lcm8gZGkgYmFuZGUgbmVsbCdvdXRwdXQgZGlwZW5kZSBkYWxsJ29yZGluZSBwb2xpbm9taW5hbGUuIEwnYWRhdHRhbWVudG8gcG9saW5vbWluYWxlIGRpIHNlY29uZG8gb3JkaW5lIHByb2R1Y2UgdW4gcmFzdGVyIGEgcXVhdHRybyBiYW5kZSBjb21lIHNlZ3VlOjwvZGl2Pjx1bD48bGk+QmFuZGEgMSA9IFBvbGlub21pbmFsZV8yPC9saT48bGk+QmFuZGEgMiA9IFBvbGlub21pbmFsZV8xPC9saT48bGk+QmFuZGEgMyA9IFBvbGlub21pbmFsZV8wPC9saT48bGk+QmFuZGEgNCA9IFJNU0U8L2xpPjwvdWw+PGRpdj5RdWVzdG8gYWRhdHRhbWVudG8gcG9saW5vbWluYWxlIGRpIHRlcnpvIG9yZGluZSBwcm9kdWNlIHVuIHJhc3RlciBhIGNpbnF1ZSBiYW5kZSBjb21lIHNlZ3VlOjwvZGl2Pjx1bD48bGk+QmFuZGEgMSA9IFBvbGlub21pbmFsZV8zPC9saT48bGk+QmFuZGEgMiA9IFBvbGlub21pbmFsZV8yPC9saT48bGk+QmFuZGEgMyA9IFBvbGlub21pbmFsZV8xPC9saT48bGk+QmFuZGEgNCA9IFBvbGlub21pbmFsZV8wPC9saT48bGk+QmFuZGEgNSA9IFJNU0U8L2xpPjwvdWw+PGRpdj5QZXIgYW5hbGlzaSBkaSB0cmVuZCBhcm1vbmljbywgaWwgbnVtZXJvIGRpIGJhbmRlIG5lbGwnb3V0cHV0IGRpcGVuZGUgc3VsbGEgZnJlcXVlbnphIGFybW9uaWNhLiBRdWFuZG8gbGEgZnJlcXVlbnphIMOoIGltcG9zdGF0YSBzdSAxLCBsJ291dHB1dCDDqCB1biByYXN0ZXIgYSBjaW5xdWUgYmFuZGUgY29tZSBzZWd1ZTo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQZW5kZW56YTwvbGk+PGxpPkJhbmRhIDIgPSBJbnRlcmNlemlvbmU8L2xpPjxsaT5CYW5kYSAzID0gSGFybW9uaWNfc2luMTwvbGk+PGxpPkJhbmRhIDQgPSBIYXJtb25pY19jb3MxPC9saT48bGk+QmFuZGEgNSA9IFJNU0U8L2xpPjwvdWw+PGRpdj5RdWFuZG8gbGEgZnJlcXVlbnphIMOoIGltcG9zdGF0YSBzdSAyLCBsJ291dHB1dCDDqCB1biByYXN0ZXIgYSBjaW5xdWUgYmFuZGUgY29tZSBzZWd1ZTo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQZW5kZW56YTwvbGk+PGxpPkJhbmRhIDIgPSBJbnRlcmNldHRhemlvbmU8L2xpPjxsaT5CYW5kYSAzID0gSGFybW9uaWNfaW4xPC9saT48bGk+QmFuZGEgNCA9IEhhcm1vbmljX2NvczE8L2xpPjxsaT5CYW5kYSA1ID0gSGFybW9uaWNfc2luMjwvbGk+PGxpPkJhbmRhIDYgPSBIYXJtb25pY19jb3MyPC9saT48bGk+QmFuZGEgNyA9IFJNU0U8L2xpPjwvdWw+PGRpdj5JbCBwYXJhbWV0cm8gPHN0cm9uZz5MdW5naGV6emEgZGkgY2ljbG88L3N0cm9uZz4gZGkgdW4nYW5hbGlzaSBkaSB0cmVuZCBhcm1vbmljbyDDqCB1dGlsaXp6YXRhIHBlciBpbmRpY2FyZSBpbCBudW1lcm8gZSBsYSBsdW5naGV6emEgZGkgY2ljbGkgY2hlIGNpIHNpIGFzcGV0dGEgZGkgdmVkZXJlIG5laSBkYXRpIGluIHVuIGdpb3JubyBvIHVuIGFubm8uIFBlciBlc2VtcGlvLCBzZSBzaSBwcmV2ZWRlIGNoZSBpIGRhdGkgc3ViaXNjYW5vIGR1ZSBjaWNsaSBkaSB2YXJpYXppb25lIGluIHVuIGFubm8sIGxhIGx1bmdoZXp6YSBkZWwgY2ljbG8gc2Fyw6AgZGkgMTgyLDUgZ2lvcm5pIG8gMCw1IGFubmkuIFNlIHNpIGRpc3BvbmUgZGkgZGF0aSBkaSB0ZW1wZXJhdHVyYSByYWNjb2x0aSBvZ25pIHRyZSBvcmUsIGUgYyfDqCB1biBjaWNsbyBkaSB2YXJpYXppb25lIGFsIGdpb3JubywgbGEgbHVuZ2hlenphIGRlbCBjaWNsbyDDqCB1biBnaW9ybm8uPC9kaXY+PGJyPjxkaXY+SWwgcGFyYW1ldHJvIDxzdHJvbmc+RnJlcXVlbnphPC9zdHJvbmc+IHBlciBhbmFsaXNpIGRpIHRyZW5kIGFybW9uaWNvIMOoIHV0aWxpenphdG8gcGVyIGRlc2NyaXZlcmUgaWwgbW9kZWxsbyBhcm1vbmljbyBwZXIgYWRhdHRhcmxvIGFpIGRhdGkuIFNlIGxhIGZyZXF1ZW56YSDDqCBpbXBvc3RhdGEgc3UgMSwgdW5hIGNvbWJpbmF6aW9uZSBkaSBjdXJ2YSBsaW5lYXJlIGUgYXJtb25pY2EgZGkgcHJpbW8gb3JkaW5lIHNhcsOgIHV0aWxpenphcmUgcGVyIGFkYXR0YXJsYSBhbCBtb2RlbGxvLiBTZSBsYSBmcmVxdWVuemEgw6ggMiwgdW5hIGNvbWJpbmF6aW9uZSBkaSBjdXJ2YSBsaW5lYXJlLCBkaSBwcmltbyBvcmRpbmUsIGFybW1vbmljYSBlIHVuYSBjdXJ2YSBkaSBzZWNvbmRvIG9yZGluZSBhcm1vbmljYSB2ZXJyw6AgdXRpbGl6emF0YSBwZXIgYWRhdHRhcmUgaSBkYXRpLiBTZSBsYSBmcmVxdWVuemEgw6ggMywgdW5hIGN1cnZhIGFybW9uaWNhIGFnZ2l1bnRpdmEgZGkgdGVyem8gb3JkaW5lIHNhcsOgIHV0aWxpenphdGEgcGVyIGZvcm1hcmUgaSBkYXRpIGUgY29zw6wgdmlhLjwvZGl2Pjxicj48ZGl2PkxhIGJvbnTDoCBkaSBhZGF0dGFtZW50byBkaSB1biBtb2RlbGxvIHN0YXRpc3RpY28gcHXDsiBlc3NlcmUgZ2VuZXJhdGEgY29tZSBvdXRwdXQgb3B6aW9uYWxlLiBMYSByYWRpY2UgZGVsbCdlcnJvcmUgcXVhZHJhdGljbyBtZWRpbyAoUk1TRSksIGlsIGNvZWZmaWNpZW50ZSBkaSBkZXRlcm1pbmF6aW9uZSBlIGlsIHZhbG9yZSBwIGRlbGxhIHBlbmRlbnphIGRpIHRyZW5kIHB1w7IgZXNzZXJlIGNhbGNvbGF0byBlIHJhcHByZXNlbnRhdG8gZGEgc2ltYm9saS4gU2ltYm9sZWdnaWFyZSBpbCBsYXllciByYXN0ZXIgdHJlbmQgZGkgb3V0cHV0IHV0aWxpenphbmRvIGxhIHNpbWJvbG9naWEgPHN0cm9uZz5SR0I8L3N0cm9uZz4gZSBzcGVjaWZpY2FyZSBsZSBzdGF0aXN0aWNoZSBjb21lIGJhbmRlIHJvc3NlLCB2ZXJkaSBlIGJsdS48L2Rpdj48YnI+XCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ05hbWU6IFwiU2VwYXJhemlvbmUgc3BldHRyYWxlIGxpbmVhcmVcIixcblx0XHRzcGVjdHJhbFVubWl4aW5nU25pcDogXCJFc2VndWUgbGEgY2xhc3NpZmljYXppb25lIGRlaSBzb3R0b3BpeGVsIGUgY2FsY29sYSBsJ2FiYm9uZGFuemEgZnJhemlvbmFyaWEgZGkgZGl2ZXJzaSB0aXBpIGRpIGNvcGVydHVyYSBkZWwgc3VvbG8gcGVyIGkgc2luZ29saSBwaXhlbC5cIixcblx0XHRzcGVjdHJhbFVubWl4aW5nRGVzYzogXCJMYSBmdW56aW9uZSBTZXBhcmF6aW9uZSBzcGV0dHJhbGUgbGluZWFyZSBjYWxjb2xhIGxhIGNvcGVydHVyYSBmcmF6aW9uYXJpYSBwZXIgaSBzaW5nb2xpIHBpeGVsIGNoZSBjb250ZW5nb25vIHBpw7kgdGlwaSBkaSBjb3BlcnR1cmEgZGVsIHN1b2xvLiBHZW5lcmEgdW4gbGF5ZXIgbXVsdGliYW5kYSwgaW4gY3VpIGNpYXNjdW5hIGJhbmRhIGNvcnJpc3BvbmRlIGFsbCdhYmJvbmRhbnphIGZyYXppb25hcmlhIGRpIGNpYXNjdW5hIGNsYXNzZSBkaSBjb3BlcnR1cmEgZGVsIHN1b2xvLiBBZCBlc2VtcGlvLCDDqCBwb3NzaWJpbGUgdXRpbGl6emFybGEgcGVyIGVzZWd1aXJlIHVuYSBjbGFzc2lmaWNhemlvbmUgZGVsbGEgY29wZXJ0dXJhIGRlbCBzdW9sbyBzdSB1bidpbW1hZ2luZSBtdWx0aXNwZXR0cmFsZSBwZXIgaWRlbnRpZmljYXJlIGxhIHZlZ2V0YXppb25lIGZvdG9zaW50ZXRpY2EsIGlsIHN1b2xvIG51ZG8gZSBsYSB2ZWdldGF6aW9uZSBtb3J0YSBvIG5vbiBmb3Rvc2ludGV0aWNhLjxkaXY+PGJyLz5MJ29yZGluZSBkZWwgcmFzdGVyIG11bHRpYmFuZGEgZGkgb3V0cHV0IHNlZ3VlIGwnb3JkaW5lIGRlbCBwcm9maWxvIHNwZXR0cmFsZSBkaSBpbnB1dC4gSWwgbnVtZXJvIGRpIGNsYXNzaSBub24gcHXDsiBzdXBlcmFyZSBpbCBudW1lcm8gZGkgYmFuZGUgbmVsIHJhc3RlciBkaSBpbnB1dC4gQWQgZXNlbXBpbywgbm9uIMOoIHBvc3NpYmlsZSBlc3RyYXJyZSBpbmZvcm1hemlvbmkgc3UgcGnDuSBkaSA4IGNsYXNzaSBkYSB1biByYXN0ZXIgYSA4IGJhbmRlLjwvZGl2PlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJOYW1lOiBcIkZpbHRybyBtdWx0aWRpbWVuc2lvbmFsZVwiLFxuXHRcdGludGVycG9sYXRlUmFzdGVyQnlEaW1lbnNpb25GdW5jdGlvbk5hbWU6IFwiSW50ZXJwb2xhcmUgaWwgcmFzdGVyIHBlciBkaW1lbnNpb25lXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uU25pcDogXCJJbnRlcnBvbGEgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGEgdmFsb3JpIGRpIGRpbWVuc2lvbmUgc3BlY2lmaWNhdGkgdXRpbGl6emFuZG8gc2V6aW9uaSBhZGlhY2VudGkuXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uRGVzYzogXCI8cD5RdWVzdGEgZnVuemlvbmUgY29uc2VudGUgZGkgc3RpbWFyZSBpIHZhbG9yaSBkZWkgcGl4ZWwgcGVyIHVuYSBwb3J6aW9uZSBkaSBkaW1lbnNpb25lIG5vbiBkZWZpbml0YSBpbiB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUuIEFkIGVzZW1waW8sIHNlIHNpIGRpc3BvbmUgZGkgdW4gc2V0IGRpIGRhdGkgY29udGVuZW50ZSBsYSB0ZW1wZXJhdHVyYSBkZWxsJ29jZWFubyBhIGxpdmVsbG8gZGVsbGEgc3VwZXJmaWNpZSBlIGEgMTAwIG1ldHJpIHNvdHRvIGlsIGxpdmVsbG8gZGVsIG1hcmUgZSBzaSBkZXNpZGVyYSBzdGltYXJlIGxhIHRlbXBlcmF0dXJhIGEgNTAgbWV0cmkgc290dG8gaWwgbGl2ZWxsbyBkZWwgbWFyZSwgw6ggcG9zc2liaWxlIHV0aWxpenphcmUgcXVlc3RhIGZ1bnppb25lIHBlciBvdHRlbmVyZSB1bmEgc3RpbWEgYSBxdWVsbGEgcHJvZm9uZGl0w6AgdXRpbGl6emFuZG8gaWwgRGVmaW5pemlvbmUgZGVsbGEgZGltZW5zaW9uZSBkZWkgdmFsb3JpLjwvcD48cD5QdW9pIGFuY2hlIGVzZWd1aXJlIGlsIGRvd25zYW1wbGluZyBkaSB1biBzZXQgZGkgZGF0aSBtZW5zaWxlIGluIHVuIHNldCBkaSBkYXRpIGdpb3JuYWxpZXJvIHV0aWxpenphbmRvIGxhIGRlZmluaXppb25lIGRlbGxhIGRpbWVuc2lvbmUgUGVyIGludGVydmFsbG8gZSBzcGVjaWZpY2FuZG8gaWwgdmFsb3JlIGRlbCBwYXJhbWV0cm8gUGFzc28gY29tZSAxIGUgaWwgdmFsb3JlIGRlbCBwYXJhbWV0cm8gVW5pdMOgIGNvbWUgR2lvcm5pLjwvcD48cD5VdGlsaXp6YXJlIGxhIGRlZmluaXppb25lIGRlbGxhIGRpbWVuc2lvbmUgUGVyIHJhc3RlciBkaSBkZXN0aW5hemlvbmUgcGVyIHN0aW1hcmUgaWwgdmFsb3JlIHBlciBpbCByYXN0ZXIgZGkgZGVzdGluYXppb25lLjwvcD5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsRmlsdGVyU25pcDogXCJDcmVhIHVuIGxheWVyIHJhc3RlciBkYSB1biBkYXRhc2V0IHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBvIGRhIHVuIGxheWVyIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBzZXppb25hbmRvIGkgZGF0aSBsdW5nbyBsZSB2YXJpYWJpbGkgZSBsZSBkaW1lbnNpb25pIGRlZmluaXRlLlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJEZXNjOiBcIklsIEZpbHRybyBtdWx0aWRpbWVuc2lvbmFsZSBjcmVhIHVuIGxheWVyIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBmaWx0cmFuZG8gZWQgZXN0cmFlbmRvIHVuIHNvdHRvaW5zaWVtZSBkaSB2YXJpYWJpbGkgZGEgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlLiBBZCBlc2VtcGlvLCBzaSBwb3NzaWVkZSB1biBkYXRhc2V0IG11bHRpZGltZW5zaW9uYWxlIGNoZSBjb250aWVuZSAzMCBhbm5pIGRpIGRhdGkgbWVuc2lsaSBzdWxsZSBwcmVjaXBpdGF6aW9uaSBlIHNpIGRlc2lkZXJhbm8gZXN0cmFycmUgc29sbyBpIGRhdGkgZGkgdHV0dGkgaSBtZXNpIGRpIGdlbm5haW8gcGVyIG9zc2VydmFyZSBsZSB2YXJpYXppb25pIGRlbGxlIHByZWNpcGl0YXppb25pIGluIHF1ZWwgbWVzZS48ZGl2Pjxici8+VXRpbGl6emFyZSBpbCBwYXJhbWV0cm8gRGVmaW5pemlvbmUgZGltZW5zaW9uZSBwZXIgc2V6aW9uYXJlIGxlIGRpbWVuc2lvbmkgdXRpbGl6emFuZG8gdW4gaW50ZXJ2YWxsbywgdW4gdmFsb3JlIG8gdW4gaW50ZXJ2YWxsbyBkaSB2YWxvcmku4oCLIEFkIGVzZW1waW8sIHNlIHNpIGhhbm5vIGEgZGlzcG9zaXppb25lIDEwIGFubmkgZGkgZGF0aSBzdWxsYSBzYWxpbml0w6AgZGVnbGkgb2NlYW5pLCByYWNjb2x0aSBtZW5zaWxtZW50ZSBlIGEgaW50ZXJ2YWxsaSBkaSAyIG1ldHJpIGRpIHByb2ZvbmRpdMOgIGZpbm8gYWkgNTAwIG1ldHJpLCDDqCBwb3NzaWJpbGUgdXRpbGl6emFyZSBsZSBkaXZlcnNlIG9wemlvbmkgZGkgZGVmaW5pemlvbmUgZGVsbGEgZGltZW5zaW9uZSBwZXIgaSBzZWd1ZW50aSBzY2VuYXJpLuKAi1NjZW5hcmlvIDE6IGVzdHJhcnJlIGkgZGF0aSBzdWxsYSBzYWxpbml0w6AgcGVyIGlsIG1lc2UgZGkgZ2VubmFpbyBuZWxsJ2FyY28gZGkgdW4gcGVyaW9kbyBkaSAxMCBhbm5pLiBTY2VnbGllcmUgUGVyIHZhbG9yaSwgaW1wb3N0YXJlIERpbWVuc2lvbmUgc3UgU3RkVGltZSBlIGltcG9zdGFyZSBWYWxvcmkgc3UgR2VubmFpby4gU2NlbmFyaW8gMjogc2V6aW9uYXJlIGkgZGF0aSBzdWxsYSBzYWxpbml0w6AgaW4gdW4gaW50ZXJ2YWxsbyBkaSBwcm9mb25kaXTDoCBkYSAwIGEgMTUwIG0uIFNjZWdsaWVyZSBQZXIgaW50ZXJ2YWxsaSwgaW1wb3N0YXJlIERpbWVuc2lvbmUgc3UgU3RkWiBlIGltcG9zdGFyZSBWYWxvcmUgbWluaW1vIHN1IC0xNTAgZSBWYWxvcmUgbWFzc2ltbyBzdSAwLiBTY2VuYXJpbyAzOiBlc3RyYXJyZSBpIGRhdGkgc3VsbGEgc2FsaW5pdMOgIHBlciBpIHByaW1pIDEwIGdpb3JuaSBkaSBvZ25pIG1lc2UgZGkgZ2VubmFpbyBuZWxsJ2FyY28gZGkgdW4gcGVyaW9kbyBkaSAxMCBhbm5pLiBTY2VnbGllcmUgUGVyIGl0ZXJhemlvbmUsIGltcG9zdGFyZSBEaW1lbnNpb25lIHN1IFN0ZFRpbWUsIGltcG9zdGFyZSBJbml6aW8gZGVsbGEgcHJpbWEgaXRlcmF6aW9uZSBlIEZpbmUgZGVsbGEgcHJpbWEgaXRlcmF6aW9uZSBzdWxsJ2luaXppbyBlIHN1bGxhIGZpbmUgY29ycmlzcG9uZGVudGkgZGVsIHBlcmlvZG8gZGkgaXRlcmF6aW9uZSwgaW1wb3N0YXJlIFBhc3NhZ2dpbyBzdSAxIGUgaW1wb3N0YXJlIFVuaXTDoCBzdSBBbm5pLjwvZGl2PlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxSYXN0ZXJOYW1lOiBcIlJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZVwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxSYXN0ZXJTbmlwOiBcIkFnZ2l1bmdlIGRhdGkgbXVsdGlkaW1lbnNpb25hbGkgYSB1bmEgbWFwcGEgY29tZSBsYXllciByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlckRlc2M6IFwiTGEgZnVuemlvbmUgUmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGFnZ2l1bmdlIGRhdGkgbXVsdGlkaW1lbnNpb25hbGkgYSB1bmEgbWFwcGEgY29tZSBsYXllciByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUuIFF1ZXN0YSBmdW56aW9uZSDDqCB1dGlsZSBxdWFuZG8gc2kgZXNlZ3Vvbm8gZmx1c3NpIGRpIGxhdm9ybyBkaSBhbmFsaXNpIHJhc3RlciB1dGlsaXp6YW5kbyB1bmEgY2F0ZW5hIGRpIGZ1bnppb25pLjxkaXY+PGJyLz5JIGRhdGFzZXQgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxpIHN1cHBvcnRhdGkgaW5jbHVkb25vIG5ldENERiwgR1JJQiwgSERGIGUgQ1JGIGRpIEVzcmkuIFNvbm8gc3VwcG9ydGF0aSBhbmNoZSBpIGRhdGFzZXQgZGkgbW9zYWljbyBtdWx0aWRpbWVuc2lvbmFsaS48L2Rpdj5cIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyTmFtZTogXCJQZXJjb3JzbyBvdHRpbWFsZSBjb21lIHJhc3RlclwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJTbmlwOiBcIkNhbGNvbGEgaWwgcGVyY29yc28gZGkgY29zdG8gbWluaW1vIGRhIHVuJ29yaWdpbmUgYSB1bmEgZGVzdGluYXppb25lLlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJEZXNjOiBcIlF1ZXN0YSBmdW56aW9uZSBnbG9iYWxlIHByb2R1Y2UgdW4gcmFzdGVyIGRpIG91dHB1dCBjaGUgcmVnaXN0cmEgaWwgcGVyY29yc28gbyBpIHBlcmNvcnNpIG90dGltYWxpLCBkYWxsZSBwb3Npemlvbmkgc2VsZXppb25hdGUgYWxsYSBjZWxsYSBkaSBvcmlnaW5lIHBpw7kgdmljaW5hIGRlZmluaXRhIG5lbGxhIHN1cGVyZmljaWUgZGkgY29zdG8gY3VtdWxhdGl2bywgaW4gdGVybWluaSBkaSBkaXN0YW56YSBkaSBjb3N0by48ZGl2Pjxici8+w4ggZ2VuZXJhbG1lbnRlIHJpY2hpZXN0YSBsJ2VzZWN1emlvbmUgZGkgdW5hIG8gcGnDuSBmdW56aW9uaSBkaSBjb3N0byBwb25kZXJhdG8gKEFjY3VtdWxvIGRpc3RhbnphIG8gQXNzZWduYXppb25lIGRlbGxhIGRpc3RhbnphKSBwcmltYSBkaSBlc2VndWlyZSBsYSBmdW56aW9uZSBQZXJjb3JzbyBvdHRpbWFsZSBjb21lIHJhc3RlciBwZXIgY3JlYXJlIGkgcmFzdGVyIGRpIGRpcmV6aW9uZSBjb250cmFyaWEgZSBhY2N1bXVsbyBkaXN0YW56YSBkaSBpbnB1dC7igItRdWVzdGkgc29ubyBsYXllciByYXN0ZXIgZGkgaW5wdXQgb2JibGlnYXRvcmkgcGVyIGxhIGZ1bnppb25lIFBlcmNvcnNvIG90dGltYWxlLiBJIHZhbG9yaSBzdWwgcGVyY29yc28gb3R0aW1hbGUgZGkgb3V0cHV0IHJhcHByZXNlbnRhbm8gaWwgbnVtZXJvIGRpIHBlcmNvcnNpIGluIHVuYSBwb3NpemlvbmUgZGF0YS7igItJbiBtb2x0aSBjYXNpLCBpIHBlcmNvcnNpIHNlZ3Vvbm8gbG8gc3Rlc3NvIGl0aW5lcmFyaW8sIGxhc2NpYW5kbyB1bidvcmlnaW5lIGUgcG9pIGRpdmVyZ2VuZG8gcGVyIGRpcmlnZXJzaSB2ZXJzbyBkZXN0aW5hemlvbmkgZGl2ZXJzZS4gQWQgZXNlbXBpbywgdW4gdmFsb3JlIHVubyBpbmRpY2EgY2hlIGMnw6ggdW4gc29sbyBwZXJjb3JzbyBvdHRpbWFsZSBpbiB1bmEgcG9zaXppb25lIGRhdGEsIG1lbnRyZSB1biB2YWxvcmUgY2lucXVlIHNpZ25pZmljYSBjaGUgaW4gcXVlbGxhIHBvc2l6aW9uZSBjaSBzb25vIGNpbnF1ZSBwZXJjb3JzaSBvdHRpbWFsaSBjaGUgYXR0cmF2ZXJzYW5vIHF1ZWxsYSBjZWxsYSBuZWxsJ2FyZWEgZGkgc3R1ZGlvLjxkaXY+PGJyLz5JIGRhdGkgZGVsbGEgZGVzdGluYXppb25lIGRpIGlucHV0IGRldm9ubyBlc3NlcmUgdW4gbGF5ZXIgcmFzdGVyLiBMJ2luc2llbWUgZGVsbGUgY2VsbGUgZGkgZGVzdGluYXppb25lIMOoIGNvc3RpdHVpdG8gZGEgdHV0dGUgbGUgY2VsbGUgbmVsIHJhc3RlciBkaSBpbnB1dCBjaGUgY29udGVuZ29ubyB2YWxvcmkgdmFsaWRpLiBMZSBjZWxsZSBjb24gdmFsb3JpIE5vRGF0YSBub24gc29ubyBpbmNsdXNpIG5lbGwnaW5zaWVtZS4gSWwgdmFsb3JlIHplcm8gw6ggY29uc2lkZXJhdG8gdW5hIGRlc3RpbmF6aW9uZSBsZWdpdHRpbWEuIMOIIHBvc3NpYmlsZSBjcmVhcmUgdW4gcmFzdGVyIGRpIGRlc3RpbmF6aW9uZSB1dGlsaXp6YW5kbyBnbGkgc3RydW1lbnRpIGRpIGVzdHJhemlvbmUuIFNlIHNpIGRpc3BvbmUgZGkgZmVhdHVyZSBkaSBkZXN0aW5hemlvbmUgbyBvcmlnaW5lLCDDqCBwb3NzaWJpbGUgY29udmVydGlybGUgaW4gcmFzdGVyIHV0aWxpenphbmRvIGxhIGZ1bnppb25lIFJhc3Rlcml6emEgZmVhdHVyZS4gVXRpbGl6emFyZSBpbCByYXN0ZXIgZGkgYWNjdW11bG8gZGlzdGFuemEgbyBkaSBkaXJlemlvbmUgY29udHJhcmlhIGNvbWUgaW5wdXQgZGVsIHJhc3RlciBwZXIgbGEgZnVuemlvbmUgZGkgcmFzdGVyaXp6YXppb25lLiBRdWVzdG8gZ2FyYW50aXLDoCBjaGUgbGEgZmVhdHVyZSB2aWVuZSByYXN0ZXJpenphdGEgdXRpbGl6emFuZG8gbGEgc3Rlc3NhIGRpbWVuc2lvbmUgY2VsbGEsIGVzdGVuc2lvbmUgZSByaWZlcmltZW50byBzcGF6aWFsZSBkZWdsaSBhbHRyaSByYXN0ZXIgbmVsbGEgZnVuemlvbmUgUGVyY29yc28gb3R0aW1hbGUgY29tZSByYXN0ZXIu4oCLTGEgZnVuemlvbmUgUGVyY29yc28gb3R0aW1hbGUgY29tZSByYXN0ZXIgcHXDsiBhbmNoZSBlc3NlcmUgdXRpbGl6emF0YSBwZXIgZGVyaXZhcmUgaWwgcGVyY29yc28gZGkgbWlub3JlIHJlc2lzdGVuemEgZGEgdW4gbW9kZWxsbyBkaSBlbGV2YXppb25lIGRpZ2l0YWxlIChERU0pLiBJbiBxdWVzdG8gY2FzbywgdXRpbGl6emFyZSBpbCBERU0gcGVyIGlsIHJhc3RlciBkaSBhY2N1bXVsbyBkaXN0YW56YSBkaSBpbnB1dCBlIGwnb3V0cHV0IGRlbGxhIGZ1bnppb25lIERpcmV6aW9uZSBmbHVzc28gcGVyIGlsIHJhc3RlciBkaSBkaXJlemlvbmUgY29udHJhcmlhLjwvZGl2PlwiLFxuXHRcdHRyZW5kTmFtZTogXCJQcmVkaXJlIHV0aWxpenphbmRvIHVuYSB0ZW5kZW56YVwiLFxuXHRcdHRyZW5kU25pcDogXCJDYWxjb2xhIHVuIGxheWVyIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBwcmV2aXN0byB1dGlsaXp6YW5kbyBpbCByYXN0ZXIgZGkgdGVuZGVuemEgZGkgb3V0cHV0IGRhbGxhIGZ1bnppb25lIEdlbmVyYSB0ZW5kZW56YSBvIGRhbGxvIHN0cnVtZW50byBkaSBnZW9wcm9jZXNzaW5nIEdlbmVyYSByYXN0ZXIgdGVuZGVuemEuXCIsXG5cdFx0dHJlbmREZXNjOiBcIkxhIGZ1bnppb25lIFByZWRpcmUgdXRpbGl6emFuZG8gdW5hIHRlbmRlbnphIGNhbGNvbGEgdW4gbGF5ZXIgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIHByZXZpc3RvIHV0aWxpenphbmRvIGlsIHJhc3RlciBkaSB0ZW5kZW56YSBkaSBvdXRwdXQgZGFsbGEgZnVuemlvbmUgR2VuZXJhIHRlbmRlbnphIG8gZGFsbG8gc3RydW1lbnRvIGRpIGdlb3Byb2Nlc3NpbmcgR2VuZXJhIHJhc3RlciB0ZW5kZW56YS5cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uTmFtZTogXCJFbGFib3JhcmUgcmFjY29sdGEgZGkgcmFzdGVyXCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvblNuaXA6IFwiRWxhYm9yYSBjaWFzY3VuYSBzZXppb25lIGluIHVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBvIGNpYXNjdW4gZWxlbWVudG8gaW4gdW4gcmFzdGVyIGRpIG1vc2FpY28u4oCLUXVlc3RhIGZ1bnppb25lIHB1w7IgYW5jaGUgYWdncmVnYXJlIHBpw7kgc2V6aW9uaSBpbiB1bid1bmljYSBzZXppb25lLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25EZXNjOiBcIkxhIGZ1bnppb25lIEVsYWJvcmFyZSByYWNjb2x0YSBkaSByYXN0ZXIgZWxhYm9yYSBjaWFzY3VuYSBzZXppb25lIGluIHVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBvIGNpYXNjdW4gZWxlbWVudG8gaW4gdW4gcmFzdGVyIGRpIG1vc2FpY28u4oCLUXVlc3RhIGZ1bnppb25lIHB1w7IgYW5jaGUgYWdncmVnYXJlIHBpw7kgc2V6aW9uaSBpbiB1bid1bmljYSBzZXppb25lLjxkaXY+PGJyLz5RdWVzdGEgZnVuemlvbmUgZWxhYm9yYSBjaWFzY3VuYSBzZXppb25lIGluIHVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBvIHJhc3RlciBtb3NhaWNvIHV0aWxpenphbmRvIHVuIG1vZGVsbG8gZGkgZnVuemlvbmUgcmFzdGVyLuKAi1F1ZXN0YSBmdW56aW9uZSBzdXBwb3J0YSBsZSBzZWd1ZW50aSBvcHppb25pOiAxLiBTcGVjaWZpY2FyZSB1biBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciBwZXIgRnVuemlvbmUgZWxlbWVudG8uIEFkIGVzZW1waW8sIHNpIHBvc3NpZWRlIHVuIGRhdGFzZXQgZGkgbW9zYWljbyBjaGUgY29udGllbmUgMjAgYW5uaSBkaSBpbW1hZ2luaSBMYW5kc2F0IGUgc2kgZGVzaWRlcmEgY2FsY29sYXJlIGwnTkRWSSBwZXIgY2lhc2N1bmEgc2NlbmEgbmVsbGEgc2VyaWUgdGVtcG9yYWxlLiBQZXIgRnVuemlvbmUgZWxlbWVudG8sIHNwZWNpZmljYXJlIHVuIG1vZGVsbG8gZGkgZnVuemlvbmUgcmFzdGVyIGNoZSBjb250aWVuZSBsYSBmdW56aW9uZSByYXN0ZXLigItORFZJLiAyLiBTcGVjaWZpY2FyZSB1biBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciBwZXIgbGEgZnVuemlvbmUgQWdncmVnYXppb25lLiBBZCBlc2VtcGlvLCBzaSBwb3NzaWVkZSB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUgY2hlIGNvbnRpZW5lIDEwIGFubmkgZGkgZGF0aSBzdWxsYSB0ZW1wZXJhdHVyYSBnaW9ybmFsaWVyYSBlIHNpIGRlc2lkZXJhIGNhbGNvbGFyZSBsYSB0ZW1wZXJhdHVyYSBtYXNzaW1hIHBlciBjaWFzY3VuIGFubm8uIE5lbGxhIGZ1bnppb25lIEFnZ3JlZ2F6aW9uZSwgc3BlY2lmaWNhcmUgdW4gbW9kZWxsbyBkaSBmdW56aW9uZSByYXN0ZXIgY2hlIGNvbnRlbmdhIGxhIGZ1bnppb25lIFN0YXRpc3RpY2hlIGNlbGxhLCBjb24gbCdvcGVyYXppb25lIGltcG9zdGF0YSBzdSBNYXNzaW1vLiBJbiBEZWZpbml6aW9uZSBhZ2dyZWdhemlvbmUsIGltcG9zdGFyZSBEaW1lbnNpb25lIHN1IFN0ZFRpbWUsIGltcG9zdGFyZSBUaXBvIHN1IFBhcm9sYSBjaGlhdmUgaW50ZXJ2YWxsbyBlIEludGVydmFsbG8gcGFyb2xhIGNoaWF2ZSBzdSBPZ25pIGFubm8uIFNpIG5vdGkgY2hlIHNlIGlsIGRhdGFzZXQgZGkgbW9zYWljbyBkaSBpbnB1dCBub24gw6ggbXVsdGlkaW1lbnNpb25hbGUsIGxhIGZ1bnppb25lIGRpIGFnZ3JlZ2F6aW9uZSBub24gcmlzcGV0dGVyw6AgbGEgZGVmaW5pemlvbmUgZGkgYWdncmVnYXppb25lLuKAi0xhIGZ1bnppb25lIGRpIGFnZ3JlZ2F6aW9uZSBhZ2dyZWdoZXLDoCB0dXR0aSBnbGkgZWxlbWVudGkgbyBjaWFzY3VuIGdydXBwbyBpbiB1bm8gc29sbywgc2Ugc29ubyBkZWZpbml0aSBuZWwgbW9kZWxsbyBkZWxsYSBmdW56aW9uZSBkaSBhZ2dyZWdhemlvbmUu4oCLUGVyIG1hZ2dpb3JpIGluZm9ybWF6aW9uaSBzdWxsJ3VzbyBkZWkgZ3J1cHBpIGluIHVuIGRhdGFzZXQgZGkgbW9zYWljbywgY29uc3VsdGFyZSBVdGlsaXp6byBlbGVtZW50aSBkZWwgZGF0YXNldCBkaSBtb3NhaWNvIGluIE1vZGVsbGkgZGkgZnVuemlvbmUgcmFzdGVyLiAzLiBTcGVjaWZpY2FyZSB1biBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciBwZXIgRnVuemlvbmUgZGkgZWxhYm9yYXppb25lLiBMYSBmdW56aW9uZSBvIGxhIGNhdGVuYSBkaSBmdW56aW9uaSBpbiBxdWVzdG8gbW9kZWxsbyB2aWVuZSB1dGlsaXp6YXRhIHBlciB2aXN1YWxpenphcmUgaWwgbnVvdm8gcmFzdGVyIGVsYWJvcmF0by7igItBZCBlc2VtcGlvLCBzcGVjaWZpY2FyZSB1biBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciBjaGUgY29udGVuZ2EgbGEgZnVuemlvbmUgQ29sb3JtYXAgcGVyIGNhbWJpYXJlIGxhIG1vZGFsaXTDoCBkaSB2aXN1YWxpenphemlvbmUgZGVsIGxheWVyIHJhc3RlciBlbGFib3JhdG8uIFNpIHByZWdhIGRpIG5vdGFyZSBjaGUgc2UgbCdpbnB1dCDDqCB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUsIGxhIGZ1bnppb25lIGRpIGVsYWJvcmF6aW9uZSB2aWVuZSBhcHBsaWNhdGEgYWxsYSBzZXppb25lIGRpIHZpc3VhbGl6emF6aW9uZSBjb3JyZW50ZS7igItTZSBsJ2lucHV0IMOoIHVuIGxheWVyIG1vc2FpY28gbyB1biBkYXRhc2V0IGRpIG1vc2FpY28sIGxhIGZ1bnppb25lIGRpIGVsYWJvcmF6aW9uZSB2aWVuZSBhcHBsaWNhdGEgYWwgcmFzdGVyIGRpIG1vc2FpY28gdXRpbGl6emFuZG8gaWwgcHJpbW8gbWV0b2RvIHBlciByaXNvbHZlcmUgbGUgc292cmFwcG9zaXppb25pLiAzLiBTcGVjaWZpY2FyZSBpIG1vZGVsbGkgcGVyIHF1YWx1bnF1ZSBjb21iaW5hemlvbmUgZGVsbGUgdHJlIGZ1bnppb25pLiBBZCBlc2VtcGlvLCBzaSBwb3NzaWVkZSB1biBkYXRhc2V0IGRpIG1vc2FpY28gY29udGVuZW50ZSBpbW1hZ2luaSBMYW5kc2F0IGRpIHNlcmllIHRlbXBvcmFsaSBlIHNpIGRlc2lkZXJhIGdlbmVyYXJlIHVuJ2ltbWFnaW5lIGNvbXBvc2l0YSBkZWxsJ05EVkkgbWFzc2ltby4gUGVyIEZ1bnppb25lIGVsZW1lbnRvLCBzcGVjaWZpY2FyZSB1biBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciBjaGUgY29udGllbmUgbGEgZnVuemlvbmUgcmFzdGVy4oCLTkRWSS4gUGVyIGxhIGZ1bnppb25lIEFnZ3JlZ2F6aW9uZSwgc3BlY2lmaWNhcmUgdW4gbW9kZWxsbyBkaSBmdW56aW9uZSByYXN0ZXIgY2hlIGNvbnRlbmdhIGxhIGZ1bnppb25lIFN0YXRpc3RpY2hlIGNlbGxhLCBjb24gbCdvcGVyYXppb25lIGltcG9zdGF0YSBzdSBNYXNzaW1vLiBQZXIgbGEgZnVuemlvbmUgZGkgZWxhYm9yYXppb25lLCBzcGVjaWZpY2FyZSB1biBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciBjaGUgY29udGllbmUgbGEgZnVuemlvbmUgQ29sb3JtYXAuIFNpIHByZWdhIGRpIG5vdGFyZSBjaGUgbCdvcmRpbmUgZGkgZWxhYm9yYXppb25lIGRlbGxhIGZ1bnppb25lIHNlZ3VlIGwnb3JkaW5lIGRlaSBwYXJhbWV0cmkgZGkgaW5wdXQuIEFkIGVzZW1waW8sIGxhIGZ1bnppb25lIEVsZW1lbnRvIHNhcsOgIGVsYWJvcmF0YSBwZXIgcHJpbWEuPC9kaXY+XCIsXG5cdFx0cmFuZG9tTmFtZTogXCJDYXN1YWxpXCIsXG5cdFx0cmFuZG9tU25pcDogXCJDcmVhIHVuIHJhc3RlciBjb24gdmFsb3JpIHBpeGVsIGNhc3VhbGkgcHJvdmVuaWVudGkgZGEgdW5hIGRpc3RyaWJ1emlvbmUgcHNldWRvIGNhc3VhbGUuIFNvbm8gc3VwcG9ydGF0ZSB2YXJpZSBkaXN0cmlidXppb25pIGUgdmFyaSBnZW5lcmF0b3JpIGRpIG51bWVyaSBjYXN1YWxpLlwiLFxuXHRcdHJhbmRvbURlc2M6IFwiTGEgZnVuemlvbmUgQ2FzdWFsZSBjcmVhIHVuIHJhc3RlciBjb24gdmFsb3JpIHBpeGVsIGNhc3VhbGkgY2hlIHBvc3Nvbm8gZXNzZXJlIHV0aWxpenphdGkgbmVpIG1vZGVsbGkgZGkgZnVuemlvbmUgcmFzdGVyIG8gbmVpIGRhdGFzZXQgZGkgbW9zYWljby48ZGl2Pjxici8+TW9sdGUgZnVuemlvbmkgaGFubm8gYmlzb2dubyBkaSB1bm8gbyBwacO5IHJhc3RlciBkaSBpbnB1dDsgbGEgZnVuemlvbmUgQ2FzdWFsZSwgaW52ZWNlLCBub24gcmljaGllZGUgbmVzc3VuIHJhc3RlciBkaSBpbnB1dC4gQ2nDsiBzaWduaWZpY2EgY2hlIHNpIGNvbXBvcnRhIGluIG1vZG8gcGnDuSBzaW1pbGUgYSB1biBkYXRhc2V0IHJhc3RlciBjaGUgYSB1bmEgZnVuemlvbmUsIHF1aW5kaSDDqCBuZWNlc3NhcmlvIHByZXN0YXJlIHBhcnRpY29sYXJlIGF0dGVuemlvbmUgcXVhbmRvIHZpZW5lIGFnZ2l1bnRhIG8gcmltb3NzYSBkYSB1bmEgY2F0ZW5hIGRpIGZ1bnppb25pLjwvZGl2PlwiLFxuXHRcdHNocmlua05hbWU6IFwiUmlkdWNpXCIsXG5cdFx0c2hyaW5rU25pcDogXCJSaWR1Y2UgbGUgem9uZSBzZWxlemlvbmF0ZSBkaSB1biBudW1lcm8gc3BlY2lmaWNhdG8gZGkgY2VsbGUgc29zdGl0dWVuZG9sZSBjb24gaWwgdmFsb3JlIGRlbGxhIGNlbGxhIHBpw7kgZnJlcXVlbnRlIG5lbGxlIHZpY2luYW56ZS5cIixcblx0XHRzaHJpbmtEZXNjOiBcIkNvbiBsYSBmdW56aW9uZSBnbG9iYWxlIFJpZHVjaSwgw6ggcG9zc2liaWxlIGdlbmVyYWxpenphcmUgbyBzZW1wbGlmaWNhcmUgaSByYXN0ZXIgcmltcGljY2lvbGVuZG8gem9uZSBzcGVjaWZpY2hlLiDDiCBhbmNoZSBwb3NzaWJpbGUgY29udHJvbGxhcmUgbGEgcXVhbnRpdMOgIGRpIGdlbmVyYWxpenphemlvbmUgY2hlIGF2dmVycsOgLjxkaXY+PGJyLz5MZSB6b25lIHNlbGV6aW9uYXRlIHNpIHJpZHVycmFubm8sIG8gZGltaW51aXJhbm5vIGRpIGRpbWVuc2lvbmksIGUgbGUgY2VsbGUgZGVsbGUgem9uZSBjaXJjb3N0YW50aSBzaSBlc3BhbmRlcmFubm8gYWxsJ2ludGVybm8gZGkgZXNzZS4gQ29uY2V0dHVhbG1lbnRlLCDDqCBwb3NzaWJpbGUgdmlzdWFsaXp6YXJlIGkgdmFsb3JpIGRpIHpvbmEgc2VsZXppb25hdGkgY29tZSB6b25lIGluIHByaW1vIHBpYW5vLCBtZW50cmUgZ2xpIGFsdHJpIHZhbG9yaSByaW1hbmdvbm8gem9uZSBzdWxsbyBzZm9uZG8uIExlIGNlbGxlIG5lbGxlIHpvbmUgaW4gcHJpbW8gcGlhbm8gcG9zc29ubyBlc3NlcmUgc29zdGl0dWl0ZSBkYWxsZSBjZWxsZSBuZWxsZSB6b25lIGRpIHNmb25kby4gw4ggYW5jaGUgcG9zc2liaWxlIHNvc3RpdHVpcmUgbGUgaXNvbGUgc290dGlsaSBhbGwnaW50ZXJubyBkaSB1bmEgem9uYSwgY2hlIHBvc3Nvbm8gZXNzZXJlIHZpc3VhbGl6emF0ZSBjb21lIGNvbmZpbmkgY29uZGl2aXNpIGNvbiBsYSB6b25hLjxkaXY+PGJyLz5MYSBxdWFudGl0w6AgZGkgZ2VuZXJhbGl6emF6aW9uZSBwdcOyIGVzc2VyZSBjb250cm9sbGF0YSBjb24gaWwgcGFyYW1ldHJvIE51bWVybyBkaSBjZWxsZS4gUGVyIGltcG9zdGF6aW9uZSBwcmVkZWZpbml0YSwgcXVlc3RvIHZhbG9yZSDDqCAxLCBpbCBjaGUgc2lnbmlmaWNhIGNoZSBsZSB6b25lIHNlbGV6aW9uYXRlIHNpIHJpZHVycmFubm8gZGVsbGEgcXVhbnRpdMOgIGNvcnJpc3BvbmRlbnRlIGFsbGEgZGltZW5zaW9uZSBkaSB1bmEgc29sYSBjZWxsYS4gUGVyIGF1bWVudGFyZSBpbCBncmFkbyBkaSBnZW5lcmFsaXp6YXppb25lLCDDqCBwb3NzaWJpbGUgc3BlY2lmaWNhcmUgdW4gdmFsb3JlIHBpw7kgZ3JhbmRlIHBlciBxdWVzdG8gcGFyYW1ldHJvLiBDb25jZXR0dWFsbWVudGUsIGNpw7IgZXF1aXZhbGUgYWQgZXNlZ3VpcmUgbG8gc3RydW1lbnRvIHRhbnRlIHZvbHRlIHF1YW50ZSBpbCBudW1lcm8gc3BlY2lmaWNhdG8gZSBjb24gaSByaXN1bHRhdGkgZGVsbCdlc2VjdXppb25lIHByZWNlZGVudGUgY29tZSBpbnB1dCBkZWxsJ2l0ZXJhemlvbmUgc3VjY2Vzc2l2YS48L2Rpdj5cIixcblx0XHR0cmVuZFRvUkdCTmFtZTogXCJEYSBUZW5kZW56YSBhIFJHQlwiLFxuXHRcdHRyZW5kVG9SR0JTbmlwOiBcIkNvbnZlcnRlIHVuIHJhc3RlciBkaSB0ZW5kZW56YSBpbiB1biByYXN0ZXIgYSB0cmUgYmFuZGUgKHJvc3NvLCB2ZXJkZSBlIGJsdSkuXCIsXG5cdFx0dHJlbmRUb1JHQkRlc2M6IFwiTGEgZnVuemlvbmUgRGEgVGVuZGVuemEgYSBSR0IgY29udmVydGUgdW4gcmFzdGVyIGRpIHRlbmRlbnphIGluIHVuIHJhc3RlciBhIHRyZSBiYW5kZSAocm9zc28sIHZlcmRlIGUgYmx1KSBJbCByYXN0ZXIgZGkgdGVuZGVuemEgw6ggZ2VuZXJhdG8gZGFsbGEgZnVuemlvbmUgcmFzdGVyIEdlbmVyYSB0ZW5kZW56YSBvIGRhbGxhIGZ1bnppb25pIHJhc3RlciBBbmFsaXNpIENDREMuPGRpdj48YnIvPlF1ZXN0YSBmdW56aW9uZSDDqCB1dGlsZSBwZXIgdmlzdWFsaXp6YXJlIGkgZGF0aSBkZWkgY29lZmZpY2llbnRpIGRlaSBtb2RlbGxpIGRlbGxhIGZ1bnppb25lIEdlbmVyYSB0ZW5kZW56YSBvIGRhbGxhIGZ1bnppb25lIEFuYWxpc2kgQ0NEQy4gRW50cmFtYmUgbGUgZnVuemlvbmkgc3RpbWFubyBsZSB0ZW5kZW56ZSBuZWkgdmFsb3JpIGRlaSBwaXhlbCBtdXRldm9saSwgbWEgaSByaXN1bHRhdGkgZGVsbGUgZnVuemlvbmkgc29ubyBkaWZmaWNpbGkgZGEgaW50ZXJwcmV0YXJlIGRpcmV0dGFtZW50ZS48ZGl2Pjxici8+Q29tZSBwZXIgbW9sdGUgZnVuemlvbmkgcmFzdGVyLCBwb3RyZWJiZSBlc3NlcmUgbmVjZXNzYXJpbyB1dGlsaXp6YXJlIGxhIFJlZ29sYXppb25lIGdhbW1hIGRpbmFtaWNhIChEUkEpIHBlciB2aXN1YWxpenphcmUgbWVnbGlvIGkgcmlzdWx0YXRpIGRpIHF1ZXN0YSBmdW56aW9uZS48L2Rpdj5cIixcblx0XHRsYW5kVHJlbmRyTmFtZTogXCJBbmFsaXNpIExhbmRUcmVuZHJcIixcblx0XHRsYW5kVHJlbmRyU25pcDogXCJWYWx1dGEgbGUgdmFyaWF6aW9uaSBkZWkgdmFsb3JpIGRlaSBwaXhlbCBuZWwgY29yc28gZGVsIHRlbXBvIHV0aWxpenphbmRvIGlsIG1ldG9kbyBkaSByaWxldmFtZW50byBkZWxsZSB0ZW5kZW56ZSBkaSBkaXN0dXJibyBlIGRpIHJlY3VwZXJvIGJhc2F0byBzdSBMYW5kc2F0IChMYW5kVHJlbmRyKSBlIGdlbmVyYSB1biByYXN0ZXIgZGkgYW5hbGlzaSBkZWxsZSB2YXJpYXppb25pIGNvbnRlbmVudGUgaSByaXN1bHRhdGkgZGVsIG1vZGVsbG8uXCIsXG5cdFx0bGFuZFRyZW5kckRlc2M6IFwiUXVlc3RhIGZ1bnppb25lIHJhc3RlciBwdcOyIGVzc2VyZSB1dGlsaXp6YXRhIHNvbG8gY29tZSBpbnB1dCBhbGxhIGZ1bnppb25lIHJhc3RlciAnSW5kaXZpZHVhcmUgdmFyaWF6aW9uZSB1dGlsaXp6YW5kbyBsJ2FuYWxpc2kgZGVsbGUgdmFyaWF6aW9uaScuIFBlciBnZW5lcmFyZSB1biBvdXRwdXQgcmFzdGVyLCBjb2xsZWdhcmUgbGEgZnVuemlvbmUgZGkgYW5hbGlzaSBMYW5kVHJlbmRyIGFsbGEgZnVuemlvbmUgJ0luZGl2aWR1YXJlIHZhcmlhemlvbmUgdXRpbGl6emFuZG8gbCdhbmFsaXNpIGRlbGxlIHZhcmlhemlvbmknIGluIHVuIG1vZGVsbG8gZGkgZnVuemlvbmUgcmFzdGVyIGUgdXNhcmUgdGFsZSBtb2RlbGxvIGNvbWUgaW5wdXQgbmVsbG8gc3RydW1lbnRvIGRpIGdlb3Byb2Nlc3NpbmcgJ0dlbmVyYXJlIHJhc3RlciBkYSBmdW56aW9uZSByYXN0ZXInLiBJbCByaXN1bHRhdG8gw6ggdW4gcmFzdGVyIGNvbnRlbmVudGUgaW5mb3JtYXppb25pIHJlbGF0aXZlIGFsbCdvcmEgaW4gY3VpIGkgdmFsb3JpIGRlaSBwaXhlbCBzb25vIHZhcmlhdGkuPGRpdj48YnI+TG8gc2NvcG8gZGkgcXVlc3RhIGZ1bnppb25lIHJhc3RlciDDqCBlc3RyYXJyZSBsZSB2YXJpYXppb25pIGluIHVuYSBmZWF0dXJlIG9zc2VydmF0YSwgcXVpbmRpIGxlIGltbWFnaW5pIG11bHRpZGltZW5zaW9uYWxpIGlkZWFsaSBkaSBpbnB1dCBkb3ZyZWJiZXJvIGNhdHR1cmFyZSB1bidvc3NlcnZhemlvbmUgY29lcmVudGUgbmVsIHRlbXBvIGUgbm9uIGRvdnJlYmJlcm8gaW5jbHVkZXJlIGludGVyZmVyZW56ZSBhdG1vc2ZlcmljaGUgbyBzZW5zb3JpYWxpLCBudXZvbGUgbyBvbWJyZSBkaSBudXZvbGUuIExhIGJ1b25hIHByYXNzaSDDqCB1dGlsaXp6YXJlIGRhdGkgbm9ybWFsaXp6YXRpIGUgY2hlIHBvc3Nvbm8gZXNzZXJlIG1hc2NoZXJhdGkgdXRpbGl6emFuZG8gdW5hIGJhbmRhIGRpIFFBLCBhZCBlc2VtcGlvIGkgcHJvZG90dGkgZGkgcmlmbGV0dGFuemEgc3VwZXJmaWNpYWxlIGRpIExhbmRzYXQgQ29sbGVjdGlvbiAxIGNvbiB1bmEgbWFzY2hlcmEgYSBudXZvbGEuPGRpdj48YnI+TGEgZnVuemlvbmUgZXNlZ3VlIGwnYW5hbGlzaSBzdSB1bidpbW1hZ2luZSBhbGwnYW5ubyBlIGlsIG51bWVybyBkaSBzZXppb25pIGFubnVhbGkgZGV2ZSBlc3NlcmUgdWd1YWxlIG8gc3VwZXJpb3JlIGFsIHZhbG9yZSBzcGVjaWZpY2F0byBuZWwgcGFyYW1ldHJvIDxzdHJvbmc+TnVtZXJvIG1pbmltbyBkaSBvc3NlcnZhemlvbmk8L3N0cm9uZz4uIFNpIHJhY2NvbWFuZGEgZGkgZGlzcG9ycmUgZGkgYWxtZW5vIHNlaSBhbm5pIGRpIGRhdGkuPGRpdj48YnI+U2Ugc2kgZGlzcG9uZSBkaSBkYXRpIG1lbnNpbGksIHNldHRpbWFuYWxpIG8gZ2lvcm5hbGllcmksIHNpIGNvbnNpZ2xpYSBkaSBzZWxlemlvbmFyZSBwacO5IGltbWFnaW5pIGRpIG9nbmkgYW5ubyAocHJlZmVyaWJpbG1lbnRlIGRlbGxhIHN0ZXNzYSBzdGFnaW9uZSksIHJpbXVvdmVyZSBsZSBudXZvbGUgZSBsJ29tYnJhIGRlbGxlIG51dm9sZSwgcXVpbmRpIGNvbWJpbmFyZSBsZSBpbW1hZ2luaSBwZXIgZ2VuZXJhcmUgdW4ndW5pY2EgaW1tYWdpbmUgY2hlIGNhdHR1cmkgYmVuZSBsJ29zc2VydmF6aW9uZS4gU2UgY29tZSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUgZGkgaW5wdXQgdmVuZ29ubyBmb3JuaXRpIGRhdGkgbWVuc2lsaSwgc2V0dGltYW5hbGkgbyBnaW9ybmFsaWVyaSwgbGEgZnVuemlvbmUgaWRlbnRpZmljaGVyw6AgdW5hIHNlemlvbmUgZGEgYW5hbGl6emFyZSBpbiBiYXNlIGFsbGEgZGF0YSBwacO5IHZpY2luYSBhIHF1ZWxsYSBmb3JuaXRhIG5lbCBwYXJhbWV0cm8gPHN0cm9uZz5EYXRhIGdlc3Rpb25lIGRlbGxlIHRvbGxlcmFuemU8L3N0cm9uZz4uPGRpdj48YnI+VW5hIGZlYXR1cmUgaW4gdW4gcGFlc2FnZ2lvIHNwZXNzbyByaWNoaWVkZSB0ZW1wbyBwZXIgcmlwcmVuZGVyc2kgZGEgdW5hIHZhcmlhemlvbmUgbm9uIHBlcm1hbmVudGUgY29tZSB1biBpbmNlbmRpbyBib3NjaGl2byBvIHVuJ2luZmVzdGF6aW9uZSBkaSBpbnNldHRpLiBQZXIgY29udHJvbGxhcmUgbGEgdmVsb2NpdMOgIGRpIHJlY3VwZXJvIHJpY29ub3NjaXV0YSBkYWwgbW9kZWxsbywgaW1wb3N0YXJlIGlsIHBhcmFtZXRybyBTb2dsaWEgZGkgcmVjdXBlcm8uIFVuIHNlZ21lbnRvIGRpc3RpbnRvIG5vbiBwdcOyIGF2ZXJlIHVuIHRhc3NvIGRpIHJlY3VwZXJvIHBpw7kgdmVsb2NlIGRpIDEvc29nbGlhIGRpIHJlY3VwZXJvLjxkaXY+PGJyPklsIHJlY3VwZXJvIGRhIHVuIGNhbWJpYW1lbnRvIGRlbCBwYWVzYWdnaW8gcHXDsiBhdnZlbmlyZSBpbiBzZW5zbyBwb3NpdGl2byBvIG5lZ2F0aXZvLiBBZCBlc2VtcGlvLCBxdWFuZG8gdW4gcGFlc2FnZ2lvIHN1YmlzY2UgdW5hIGRlZm9yZXN0YXppb25lLCB1bmEgc2VyaWUgdGVtcG9yYWxlIGRpIHZhbG9yaSBkZWxsJ2luZGljZSBkaSB2ZWdldGF6aW9uZSBtb3N0cmEgdW4gY2FsbyBkZWkgdmFsb3JpIGRlbGwnaW5kaWNlIGUgaWwgcmVjdXBlcm8gbW9zdHJhIHVuIGdyYWR1YWxlIGF1bWVudG8gZGVpIHZhbG9yaSBkZWxsJ2luZGljZSBkaSB2ZWdldGF6aW9uZSBvIHVuYSB0ZW5kZW56YSBkaSByZWN1cGVybyBwb3NpdGl2YS4gU3BlY2lmaWNhcmUgbGEgZGlyZXppb25lIGRlbGxhIHRlbmRlbnphIGRpIHJlY3VwZXJvIGNvbiBpbCBwYXJhbWV0cm8gPHN0cm9uZz5JbCByZWN1cGVybyBoYSBhdW1lbnRhdG8gbGEgdGVuZGVuemE8L3N0cm9uZz4uXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbE5hbWU6IFwiQWdncmVnYXJlIG11bHRpZGltZW5zaW9uYWxlXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbFNuaXA6IFwiQ29tYmluYSBpIGRhdGkgZGVsbGEgdmFyaWFiaWxlIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBlc2lzdGVudGUgbHVuZ28gdW5hIGRpbWVuc2lvbmUuXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbERlc2M6IFwiTGEgZnVuemlvbmUgQWdncmVnYXRhIE11bHRpZGltZW5zaW9uYWxlIGNyZWEgdW4gbGF5ZXIgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGNvbWJpbmFuZG8gaSBkYXRpIHZhcmlhYmlsaSBkZWwgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGNvbiB1bmEgZGltZW5zaW9uZS48ZGl2Pjxicj5Vc2EgaWwgcGFyYW1ldHJvIGRpIERlZmluaXppb25lIGRlbGxhIERpbWVuc2lvbmXCoDxzdHJvbmc+PC9zdHJvbmc+wqBwZXIgZmlsdHJhcmUgcHJldmlhbWVudGUgaSBkYXRpIGRpIGlucHV0IGNoZSB2dW9pIGFnZ3JlZ2FyZS4gQWQgZXNlbXBpbywgc2UgaGFpIDMwIGFubmkgZGkgZGF0aSBtZW5zaWxpLCBtYSB2dW9pIHNvbGFtZW50ZSBjcmVhcmUgdW4gbGF5ZXIgYWdncmVnYXRvIHBlciBpIHByaW1pIDE1IGFubmksIHB1b2kgdXNhcmUgaWwgcGFyYW1ldHJvwqA8c3Ryb25nPmRpIERlZmluaXppb25lIGRlbGxhIERpbWVuc2lvbmU8L3N0cm9uZz7CoHBlciBzcGVjaWZpY2FyZSBnbGkgYW5uaSBkYSBpbmNsdWRlcmUgbmVsbCdhbmFsaXNpLjxkaXY+PGJyPjx1bD48bGk+RXN0cmFpIGkgZGF0aSBkaSBzYWxpbml0w6AgcGVyIGlsIG1lc2UgZGkgZ2VubmFpbyBkdXJhbnRlIHVuIHBlcmlvZG8gZGkgMTAgYW5uaS4gU2NlZ2xpwqA8c3Ryb25nPkluIGJhc2UgYWkgVmFsb3JpPC9zdHJvbmc+LCBhZGF0dGHCoDxzdHJvbmc+bGEgRGltZW5zaW9uZTwvc3Ryb25nPsKgYWzCoDxzdHJvbmc+RnVzbyBPcmFyaW88L3N0cm9uZz4sIGVkIGltcG9zdGHCoDxzdHJvbmc+aSBWYWxvcmk8L3N0cm9uZz7CoGFswqA8c3Ryb25nPmdlbm5haW88L3N0cm9uZz4uPC9saT48bGk+Uml0YWdsaWEgaSBkYXRpIGRpIHNhbGluaXTDoCBhbGwnaW50ZXJubyBkaSB1biBpbnRlcnZhbGxvIGRpIHByb2ZvbmRpdMOgIGNoZSB2YSBkYSAwIGEgMTUwIG1ldHJpLiBTY2VnbGnCoDxzdHJvbmc+SW4gYmFzZSBhZ2xpIEludGVydmFsbGk8L3N0cm9uZz4sIGFkYXR0YcKgPHN0cm9uZz5sYSBEaW1lbnNpb25lPC9zdHJvbmc+wqBhbMKgPHN0cm9uZz5GdXNvIE9yYXJpbzwvc3Ryb25nPiwgZWQgaW1wb3N0YcKgPHN0cm9uZz5pbCBWYWxvcmUgTWluaW1vPC9zdHJvbmc+wqBhwqA8c3Ryb25nPi0xNTA8L3N0cm9uZz7CoGXCoDxzdHJvbmc+aWwgVmFsb3JlIE1hc3NpbW88L3N0cm9uZz7CoGHCoDxzdHJvbmc+MDwvc3Ryb25nPi48L2xpPjxsaT5Fc3RyYWkgaSBkYXRpIGRpIHNhbGluaXTDoCBwZXIgaSBwcmltaSAxMCBnaW9ybmkgZGkgb2duaSBnZW5uYWlvIGR1cmFudGUgdW4gcGVyaW9kbyBkaSAxMCBhbm5pLiBTY2VnbGnCoDxzdHJvbmc+UGVyIEl0ZXJhemlvbmU8L3N0cm9uZz4sIGltcG9zdGHCoDxzdHJvbmc+bGEgRGltZW5zaW9uZTwvc3Ryb25nPsKgYWzCoDxzdHJvbmc+RnVzb09yYXJpbzwvc3Ryb25nPiwgaW1wb3N0YcKgPHN0cm9uZz5Jbml6aW8gZGVsbGEgcHJpbWEgaXRlcmF6aW9uZTwvc3Ryb25nPsKgZcKgPHN0cm9uZz5GaW5lIGRlbGxhIHByaW1hIGl0ZXJhemlvbmU8L3N0cm9uZz7CoGFsbCdpbml6aW8gZSBhbGxhIGZpbmUgY29ycmlzcG9uZGVudGkgYWwgcGVyaW9kbyBkZWxsJ2l0ZXJhemlvbmUsIGltcG9zdGHCoDxzdHJvbmc+UGFzc2FnZ2lvPC9zdHJvbmc+wqBhwqA8c3Ryb25nPjE8L3N0cm9uZz4sIGUgaW1wb3N0YcKgPHN0cm9uZz5Vbml0w6A8L3N0cm9uZz7CoGHCoDxzdHJvbmc+QW5uaTwvc3Ryb25nPi48L2xpPjwvdWw+PGRpdj48YnI+VXNhIGkgcGFyYW1ldHJpwqA8c3Ryb25nPmRpIERlZmluaXppb25lIGRlbGwnQWdncmVnYXppb25lPC9zdHJvbmc+wqBwZXIgc2NlZ2xpZXJlIGxhIGRpbWVuc2lvbmUgZGEgc3RhYmlsaXJlIGUgbCdpbnRlcnZhbGxvIGRlbGwnYWdncmVnYXppb25lIHVzYW5kbyB1bmEgcGFyb2xhIGNoaWF2ZSwgdW4gdmFsb3JlIG8gdW4gaW50ZXJ2YWxsbyBkaSB2YWxvcmkuIEFkIGVzZW1waW8sIHNlIHNpIGRpc3BvbmUgZGkgMzAgYW5uaSBkaSBkYXRpIHN1bGxhIHRlbXBlcmF0dXJhIGRlbGxhIHN1cGVyZmljaWUgZGVsIG1hcmUsIHJhY2NvbHRpIHF1b3RpZGlhbmFtZW50ZSBlIG9nbmkgNcKgbWV0cmkgZGkgcHJvZm9uZGl0w6AgZmlubyBhIDEwMMKgbWV0cmksIMOoIHBvc3NpYmlsZSB1dGlsaXp6YXJlIGxlIGRpdmVyc2Ugb3B6aW9uaSBkaSBpbnRlcnZhbGxvIHBlciBpIHNlZ3VlbnRpIHNjZW5hcmk6PGRpdj48YnI+PHVsPjxsaT5hZ2dyZWdhcmUgaSBkYXRpIGRpIHRlbXBlcmF0dXJhIGdpb3JuYWxpZXJpIGluIGRhdGkgbWVuc2lsaSwgZG92ZSBpbCByaXN1bHRhdG8gw6ggdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGNvbiAxMiBzZXppb25pIGRpIHRlbXBvLCBvZ251bmEgZGVsbGUgcXVhbGkgw6ggbCdhZ2dyZWdhdG8gZGkgb2duaSBtZXNlIGF0dHJhdmVyc28gdHV0dGkgZ2xpIGFubmkuIFNjZWdsacKgPHN0cm9uZz5sYSBQYXJvbGEgQ2hpYXZlIGRlbGwnSW50ZXJ2YWxsbzwvc3Ryb25nPsKgZWQgaW1wb3N0YSBsYSBwYXJvbGEgY2hpYXZlIGHCoDxzdHJvbmc+Umljb3JyZW50ZSBhIGNhZGVuemEgTWVuc2lsZTwvc3Ryb25nPi48L2xpPjxsaT5BZ2dyZWdhIGkgZGF0aSBzdWxsYSB0ZW1wZXJhdHVyYSBnaW9ybmFsaWVyaSBpbiBkYXRpIG1lbnNpbGksIGRhIGN1aSBpbCByaXN1bHRhdG8gw6ggdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGNvbiAzNjAgZmV0dGUsIG8gMTIgZmV0dGUgdGVtcG9yYWxpIHBlciBhbm5vICgzMCBhbm5pIHggMTIgbWVzaSA9IDM2MCBmZXR0ZSkuIFNjZWdsacKgPHN0cm9uZz5sYSBQYXJvbGEgQ2hpYXZlIGRlbGwnSW50ZXJ2YWxsbzwvc3Ryb25nPsKgZWQgaW1wb3N0YSBsYSBwYXJvbGEgY2hpYXZlwqA8c3Ryb25nPmEgY2FkZW56YSBNZW5zaWxlPC9zdHJvbmc+LjwvbGk+PGxpPkFnZ3JlZ2EgaSBkYXRpIG1lbnNpbGkgc3VsbGEgdGVtcGVyYXR1cmEgYWQgaW50ZXJ2YWxsaSBkaSA0IG1lc2kuIFNjZWdsacKgPHN0cm9uZz5pbCBWYWxvcmUgZGVsbCdJbnRlcnZhbGxvPC9zdHJvbmc+LCBpbXBvc3RhwqA8c3Ryb25nPmwnSW50ZXJ2YWxsbyBkZWwgVmFsb3JlPC9zdHJvbmc+wqBhwqA0LCBlZCBpbXBvc3RhwqA8c3Ryb25nPmwnVW5pdMOgPC9zdHJvbmc+wqBhwqA8c3Ryb25nPk1lc2k8L3N0cm9uZz4uPC9saT48bGk+QWdncmVnYSBpIGRhdGkgc3VsbGEgdGVtcGVyYXR1cmEgZGEgMCBhIDI1IG1ldHJpLCBwb2kgZGEgMjUgYSA1MCBtZXRyaSwgcG9pIGRhIDUwIGEgMTAwIG1ldHJpLiBTY2VnbGnCoDxzdHJvbmc+bGUgU2VyaWUgZGkgSW50ZXJ2YWxsaTwvc3Ryb25nPsKgZSBzcGVjaWZpY2EgbGUgcHJvZm9uZGl0w6AgbWluaW1lIGUgbWFzc2ltZSBjb21lwqA8c3Ryb25nPjAgMjU7IDI1IDUwOyA1MCAxMDA8L3N0cm9uZz4uPC9saT48L3VsPlwiLFxuXHRcdG1lcmdlUmFzdGVyc05hbWU6IFwiVW5pc2NpIHJhc3RlclwiLFxuXHRcdG1lcmdlUmFzdGVyc1NuaXA6IFwiQ29uc2VudGUgZGkgY29tYmluYXJlIHBpw7kgZGF0YXNldCByYXN0ZXIgc3BhemlhbG1lbnRlIG8gYXR0cmF2ZXJzbyB2YXJpYWJpbGkgZSBkaW1lbnNpb25pLlwiLFxuXHRcdG1lcmdlUmFzdGVyc0Rlc2M6IFwiUXVlc3RhIGZ1bnppb25lIGNvbnNlbnRlIGRpIGNyZWFyZSB1biByYXN0ZXIgdW5pdG8gZGEgdW5hIGxpc3RhIGRpIHJhc3Rlci4gQWQgZXNlbXBpbywgc2Ugc2kgZGlzcG9uZSBkaSB1biBkYXRhc2V0IGEgbW9zYWljbyBjaGUgY29udGllbmUgMzAgYW5uaSBkaSBkYXRpIG1lbnNpbGkgc3VsbGUgcHJlY2lwaXRhemlvbmkgZSB1biBhbHRybyBkYXRhc2V0IGNvbiAxMCBhbm5pIGRpIGRhdGkgbWVuc2lsaSBzdWxsYSB0ZW1wZXJhdHVyYSwgw6ggcG9zc2liaWxlIGNvbWJpbmFybGkgaW4gdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGNvbiBlbnRyYW1iZSBsZSB2YXJpYWJpbGkuIDxkaXY+PGJyPlNlIGkgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxpIGRpIGlucHV0IGNvbnRlbmdvbm8gdmFyaWFiaWxpIGRpdmVyc2UsIGlsIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSBkaSBvdXRwdXQgY29udGVycsOgIHR1dHRlIGxlIHZhcmlhYmlsaS4gPGRpdj48YnI+U2UgaSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGkgZGkgaW5wdXQgY29udGVuZ29ubyBkaW1lbnNpb25pIG8gdmFsb3JpIGRpIGRpbWVuc2lvbmUgZGl2ZXJzaSwgaWwgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGRpIG91dHB1dCBpbmNsdWRlcsOgIHR1dHRlIGxlIGRpbWVuc2lvbmkgZSBpIHZhbG9yaSBkaSBkaW1lbnNpb25lLiA8ZGl2Pjxicj5TZSBpIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsaSBkaSBpbnB1dCBjb250ZW5nb25vIGxlIHN0ZXNzZSBkaW1lbnNpb25pIGUgdmFyaWFiaWxpIG1hIGVzdGVuc2lvbmkgc3BhemlhbGkgZGl2ZXJzZSwgaWwgcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlIGRpIG91dHB1dCBpbmNsdWRlcsOgIGxlIHZhcmlhYmlsaSBlIGxlIGRpbWVuc2lvbmkgYXR0cmF2ZXJzbyBsZSBlc3RlbnNpb25pIHNwYXppYWxpIHVuaXRlLjxkaXY+PGJyPlF1ZXN0YSBmdW56aW9uZSBwdcOyIGVzc2VyZSB1dGlsaXp6YXRhIGFuY2hlIHF1YW5kbyBzaSBkaXNwb25lIGRpIHBpw7kgcmFzdGVyIGNoZSBzaSBkZXNpZGVyYSB0cmF0dGFyZSBjb21lIHVuIHNpbmdvbG8gZWxlbWVudG8sIGFkIGVzZW1waW8gcXVhbmRvIHNpIGNhbGNvbGFubyBsZSBzdGVzc2Ugc3RhdGlzdGljaGUgcGVyIHR1dHRpIG8gZHVyYW50ZSBpbCBiaWxhbmNpYW1lbnRvIGRlaSBjb2xvcmkgaW4gbW9kbyBkYSBub24gZG92ZXIgYmlsYW5jaWFyZSBvZ25pIGltbWFnaW5lIHNlcGFyYXRhbWVudGUuIENpw7Igw6ggdXRpbGUgcXVhbmRvIHNpIGxhdm9yYSBjb24gaW1tYWdpbmkgbWVtb3JpenphdGUgY29tZSB0aWxlIHNlcGFyYXRpIGEgY2F1c2EgZGkgdmluY29saSBkaSBkaW1lbnNpb25lIGRlbCBmaWxlLiBJbiB0YWwgbW9kbywgaSB0aWxlIHNhcmFubm8gdHJhdHRhdGkgY29tZSBwYXJ0ZSBkZWxsYSBzdGVzc2EgaW1tYWdpbmUuXCIsXG5cdFx0Ym91bmRhcnlDbGVhbk5hbWU6IFwiUHVsaXppYSBCb3VuZGFyeVwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5TbmlwOiBcIlNtdXNzYSBpbCBjb25maW5lIHRyYSBsZSB6b25lLlwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5EZXNjOiBcIjxwPkxhIGZ1bnppb25hIGdlbmVyYWxpenphIG8gc2VtcGxpZmljYSBpIHJhc3RlciBzbXVzc2FuZG8gaSBjb25maW5pIHRyYSBsZSB6b25lLiBMYSBmdW56aW9uZSBmb3JuaXNjZSBvcHppb25pIHBlciBjb250cm9sbGFyZSBjb21lIGxlIGNlbGxlIG8gbGUgem9uZSBuZWxsJ2lucHV0IGluZmx1ZW56aW5vIGxvIHNtdXNzYW1lbnRvIGUgbGEgcXVhbnRpdMOgIGNoZSB2ZXJyw6AgYXBwbGljYXRhLiBPZ25pIGNlbGxhIGRpIGluZ3Jlc3NvIHZpZW5lIHZhbHV0YXRhIHV0aWxpenphbmRvIGkgc3VvaSBvdHRvIHZpY2luaSBpbW1lZGlhdGkuPC9wPjxwPklsIHByb2Nlc3NvIGRpIHNtdXNzYW1lbnRvIHByaW1hIG9yZGluYSBsZSBjZWxsZSB2aWNpbmUgc2Vjb25kbyB1bmEgcGFydGljb2xhcmUgcHJpb3JpdMOgLiBMYSBwcmlvcml0w6AgZGV0ZXJtaW5hIHF1YWxlIHpvbmEgZGFsbGUgY2VsbGUgdmljaW5lIHBvc3Nvbm8gc29zdGl0dWlyZSBpbCB2YWxvcmUgZGVsbGUgY2VsbGUgaW4gZWxhYm9yYXppb25lIG5lbGwnb3V0cHV0LjwvcD48cD5MYSBwcmlvcml0w6AgcHXDsiBlc3NlcmUgYmFzYXRhIG8gc3UgaWwgdmFsb3JlIG5lbGxlIHpvbmUgbyBzdWxsYSBncmFuZGV6emEgbmVsbGUgem9uZS4gSWwgcGFyYW1ldHJvIDxzdHJvbmc+VGlwbyBkaSBvcmRpbmFtZW50bzwvc3Ryb25nPiBkZXRlcm1pbmEgaWwgdGlwbyBkaSBvcmRpbmFtZW50byBkYSB1dGlsaXp6YXJlLiA8L3A+PHA+TCdpbXBvc3RhemlvbmUgZGkgZGVmYXVsdDxzdHJvbmc+Tm9uIG9yZGluYXJlPC9zdHJvbmc+IHZhbHV0YSBsYSBwcmlvcml0w6AgYmFzYXRhIHN1bCB2YWxvcmUgZGVsbGUgem9uZS4gTGUgY2VsbGUgZGFsbGUgem9uZSBjb24gZ3JhbmRpIHZhbG9yaSBhdnJhbm5vIHVuYSBwcmlvcml0w6AgcGnDuSBhbHRhIHBlciBlc3BhbmRlcnNpIG5lbGxlIHpvbmUgY29uIHZhbG9yaSBwacO5IGJhc3NpLjwvcD48cD5MYSBncmFuZGV6emEgbyBhcmVhIHRvdGFsZSBkZWxsZSB6b25lIHB1w7IgZXNzZXJlIHV0aWxpenphdGEgcGVyIG9yZGluYXJlIGxhIHByaW9yaXTDoC4gQ29uIGwnaW1wb3N0YXppb25lIDxzdHJvbmc+RGVjcmVzY2VudGU8L3N0cm9uZz4sIGxlIHpvbmUgc29ubyBvcmRpbmF0ZSBwZXIgZ3JhbmRlenphIGluIG9yZGluZSBkZWNyZXNjZW50ZS4gTGUgem9uZSBjb24gYXJlYSB0b3RhbGUgbWFnZ2lvcmUgYXZyYW5ubyBsYSBwcmlvcml0w6AgZGkgZXNwYW5kZXJzaSBpbiB6b25lIGNvbiBhcmVlIG1pbm9yaS4gVHJhbWl0ZSBsJ2ltcG9zdGF6aW9uZSA8c3Ryb25nPkNyZXNjZW50ZTwvc3Ryb25nPiwgw6ggdmVybyBpbCBjb250cmFyaW86IGxlIHpvbmUgY29uIGFyZWUgdG90YWxpIG1pbm9yaSBhdnJhbm5vIGxhIHByaW9yaXTDoCBkaSBlc3BhbmRlcnNpIGluIHpvbmUgY29uIGFyZWUgdG90YWxpIG1hZ2dpb3JpLiA8L3A+PHA+TGEgcXVhbnRpdMOgIGRpIHNtdXNzYW1lbnRvIMOoIGNvbnRyb2xsYXRhIGRhbCBwYXJhbWV0cm8gPHN0cm9uZz5Fc2VndWkgZHVlIHZvbHRlIGVzcGFuc2lvbmUgZSBjb250cmF6aW9uZTwvc3Ryb25nPiwgY2hlIGRldGVybWluYSBpbCBudW1lcm8gZGkgdm9sdGUgY2hlIGlsIHByb2Nlc3NvIGRpIGVzcGFuc2lvbmUgZSBjb250cmF6aW9uZSB2ZXJyw6AgZXNlZ3VpdG8uPC9wPjxwPkNvbiBsJ2ltcG9zdGF6aW9uZSBub24gc2VsZXppb25hdGEsIGlsIHByb2Nlc3NvIGRpIGVzcGFuc2lvbmUgZSBjb250cmF6aW9uZSB2aWVuZSBlc2VndWl0byB1bmEgdm9sdGEgc29sYS4gQ29uIGwnaW1wb3N0YXppb25lIHNlbGV6aW9uYXRhLCBpbCBwcm9jZXNzbyBkaSBlc3BhbnNpb25lIGUgY29udHJhemlvbmUgdmllbmUgZXNlZ3VpdG8gZHVlIHZvbHRlLCByaXN1bHRhbmRvIGluIHVuIGdyYWRvIGFnZ2l1bnRpdm8gZGkgc211c3NhbWVudG8gZGVpIGNvbmZpbmkgZGVsbGUgem9uZS48L3A+PHA+U2UgaSB2YWxvcmkgZGkgdHV0dGUgbGUgb3R0byBjZWxsZSB2aWNpbmUgc29ubyBsZSBzdGVzc2UgZGVsbGUgY2VsbGUgaW4gZWxhYm9yYXppb25lLCBsYSBjZWxsYSBkaSBvdXRwdXQgbWFudGVycsOgIGlsIHZhbG9yZSBkZWxsZSBjZWxsZSBkaSBpbnB1dC48L3A+XCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvbk5hbWU6IFwiUHJlZGljaSB1dGlsaXp6YW5kbyByZWdyZXNzaW9uZVwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25TbmlwOiBcIkNhbGNvbGEgdW4gcmFzdGVkIHByZWRldHRvIGluIGJhc2UgYWkgZGF0aSByYXN0ZXIgZGkgaW5wdXQgZSBhIHVuIG1vZGVsbG8gZGkgcmVncmVzc2lvbmUuIElsIG1vZGVsbG8gZGkgcmVncmVzc2lvbmUgw6ggbCdvdXRwdXQgcHJvdmVuaWVudGUgZGFsbG8gc3RydW1lbnRvIGRpIGdlb3Byb2Nlc3NpbmcgcmFzdGVyIDxzdHJvbmc+IE1vZGVsbG8gZGkgUmVncmVzc2lvbmUgQWxiZXJpIENhc3VhbGk8L3N0cm9uZz4uXCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvbkRlc2M6IFwiPHA+SWwgbW9kZWxsbyBkaSByZWdyZXNzaW9uZSDDqCBkZWZpbml0byBpbiB1biBmaWxlIGRlZmluaXppb25lIGRpIHJlZ3Jlc3Npb25lIEVzcmkgKC5lY2QpLiBDb250aWVuZSB0dXR0ZSBsZSBpbmZvcm1hemlvbmkgZGkgdW4gZGF0YXNldCBvIHNldCBkaSBkYXRhc2V0IHNwZWNpZmljaSBlIGRlbCBtb2RlbGxvIGRpIHJlZ3Jlc3Npb25lLCBlIHZpZW5lIGdlbmVyYXRvIGRhbGxvIHN0cnVtZW50byBkaSBnZW9wcm9jZXNzaW5nIHJhc3RlciA8c3Ryb25nPiBNb2RlbGxvIGRpIFJlZ3Jlc3Npb25lIEFsYmVyaSBDYXN1YWxpPC9zdHJvbmc+LjwvcD48cD5MJ2lucHV0IHB1w7IgZXNzZXJlIGEgYmFuZGEgc2luZ29sYSwgbXVsdGliYW5kYSBvIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsZSwgbyB0dXR0aSBpIHRpcGkgcHJlY2VkZW50aS4gSSB0aXBpIGRpIHJhc3RlciBkaSBpbnB1dCBkZXZvbm8gZXNzZXJlIGRlbGxvIHN0ZXNzbyB0aXBvIGRpIHJhc3RlciBhZGRlc3RyYXRvIGRhbCBtb2RlbGxvIGRpIHJlZ3Jlc3Npb25lLjwvcD48dWw+PGxpPlF1YW5kbyBsJ2lucHV0IMOoIHVuIHJhc3RlciBtdWx0aWJhbmRhIG9nbmkgYmFuZGEgdmllbmUgY29uc2lkZXJhdGEgY29tZSB1bmEgdmFyaWFiaWxlIGRpIHByZWRpemlvbmUuIExlIGJhbmRlIGRldm9ubyBlc3NlcmUgbmVsbG8gc3Rlc3NvIG9yZGluZSBkZWxsJ2lucHV0IGRlbGxlIG11bHRpYmFuZGUgdXNhdG8gbmVsbG8gc3RydW1lbnRvIGRpIGFkZGVzdHJhbWVudG8gZGVsIG1vZGVsbG8gZGkgcmVncmVzc2lvbmUuPC9saT48bGk+UXVhbmRvIGwnaW5wdXQgw6ggdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlLCBvZ25pdmFyaWFiaWxlIMOoIGNvbnNpZGVyYXRhIHVuYSB2YXJpYWJpbGUgZGkgcHJlZGl6aW9uZSwgZSBkZXZlIGVzc2VyZSBhIGJhbmRhIHNpbmdvbGEgZSBhdmVyZSB1bmEgZGltZW5zaW9uZSB0ZW1wb3JhbGUuIEwnb3JkaW5lIGUgaSBub21pIGRlbGxhIHZhcmlhYmlsZSBkZXZvbm8gZXNzZXJlIHVndWFsaSBhbGwnaW5wdXQgZGkgcXVhbmRvIGlsIG1vZGVsbG8gZGkgcmVncmVzc2lvbmUgw6ggc3RhdG8gYWRkZXN0cmF0by4gTCdvdXRwdXQgw6ggdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWxlLjwvbGk+PGxpPkwnaW5wdXQgcHXDsiBlc3NlcmUgdW4gZWxlbmNvIGRpIGVsZW1lbnRpLiBJbCBudW1lcm8gZSBsJ29yZGluZSBkZWdsaSBlbGVtZW50aSBkZXZlIGNvcnJpc3BvbmRlcmUgYWxsJ2lucHV0IGRpIHF1YW5kbyBpbCBtb2RlbGxvIGRpIHJlZ3Jlc3Npb25lIMOoIHN0YXRvIGFkZGVzdHJhdG8uPC9saT48L3VsPlwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGljaGUgZGVsIG1vdmltZW50byBkaW1lbnNpb25hbGVcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NTbmlwOiBcIkNhbGNvbGEgbGUgc3RhdGlzdGljaGUgc3UgdW5hIGZpbmVzdHJhIG1vYmlsZSBzdSBkYXRpIG11bHRpZGltZW5zaW9uYWxpIGx1bmdvIHVuYSBkaW1lbnNpb25lIHNwZWNpZmljYXRhLlwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc0Rlc2M6IFwiPHA+TGEgZnVuemlvbmUgU3RhdGlzdGljaGUgbW9iaWxpIGRpbWVuc2lvbmFsaSBjYWxjb2xhIHZhcmllIHN0YXRpc3RpY2hlIGFsbCdpbnRlcm5vIGRpIHVuYSBmaW5lc3RyYSBwcmVkZWZpbml0YSBwZXIgdHV0dGkgaSB2YWxvcmkgZGkgZGltZW5zaW9uZSBsdW5nbyB1bmEgZGltZW5zaW9uZS4gUXVlc3RhIGZ1bnppb25lIGFjY2V0dGEgdW4gbGl2ZWxsbyByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUgY29tZSBpbnB1dCBlIGNyZWEgdW4gbGl2ZWxsbyByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUgY29tZSBvdXRwdXQgY29uIGxhIHN0ZXNzYSBkaW1lbnNpb25lIGRpbWVuc2lvbmFsZSBkZWwgbGl2ZWxsbyBkaSBpbnB1dC48L3A+PHA+w4ggcG9zc2liaWxlIHNwZWNpZmljYXJlIHVuYSBkaW1lbnNpb25lIHBlciBsYSBxdWFsZSB2ZW5nb25vIHByZXNpIGluIGNvbnNpZGVyYXppb25lIGkgdmFsb3JpIGRpIGRpbWVuc2lvbmUgZHVyYW50ZSBpbCBjYWxjb2xvLiBQZXIgaW1wb3N0YXppb25lIHByZWRlZmluaXRhLCBjYWxjb2xhIGx1bmdvIGxhIHByaW1hIGRpbWVuc2lvbmUgbm9uIHNwYXppYWxlLiDDiCBpbm9sdHJlIHBvc3NpYmlsZSBzcGVjaWZpY2FyZSB1bmEgZGltZW5zaW9uZSBkZWxsYSBmaW5lc3RyYSBzcGVjaWZpY2FuZG8gaSBwYXJhbWV0cmkgRmluZXN0cmEgaW5kaWV0cm8gZSBGaW5lc3RyYSBhdmFudGkuPC9wPjxwPlF1YW5kbyBpbCBUaXBvIGRpIHN0YXRpc3RpY2Egw6ggaW1wb3N0YXRvIHN1IFBlcmNlbnRpbGUsIGkgcGFyYW1ldHJpIFZhbG9yZSBwZXJjZW50aWxlIGUgVGlwbyBkaSBpbnRlcnBvbGF6aW9uZSBwZXJjZW50aWxlIGRpdmVudGFubyBkaXNwb25pYmlsaS4gw4ggcG9zc2liaWxlIHV0aWxpenphcmUgcXVlc3RpIHBhcmFtZXRyaSBwZXIgc3BlY2lmaWNhcmUgaWwgcGVyY2VudGlsZSBkYSBjYWxjb2xhcmUgZSBzY2VnbGllcmUgcmlzcGV0dGl2YW1lbnRlIGlsIHRpcG8gZGkgaW50ZXJwb2xhemlvbmUgZGEgdXRpbGl6emFyZS4gUXVhbmRvIGlsIFRpcG8gZGkgc3RhdGlzdGljYSDDqCBpbXBvc3RhdG8gc3UgTWVkaWEgY2lyY29sYXJlLCBpbCBwYXJhbWV0cm8gVmFsb3JlIGRpIGF2dm9sZ2ltZW50byBjaXJjb2xhcmUgZGl2ZW50YSBkaXNwb25pYmlsZS4gSWwgdmFsb3JlIGRpIGF2dm9sZ2ltZW50byBjaXJjb2xhcmUgdmllbmUgdXRpbGl6emF0byBwZXIgY29udmVydGlyZSB1biB2YWxvcmUgbGluZWFyZSBuZWxsJ2ludGVydmFsbG8gZGkgdW5hIGRhdGEgbWVkaWEgY2lyY29sYXJlLjwvcD5cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uTmFtZTogXCJMaXZlbGxhbWVudG8gdGVycmVub1wiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25TbmlwOiBcIkNvcnJlZ2dlIGkgZGF0aSByYWRhciBhZCBhcGVydHVyYSBzaW50ZXRpY2EgKFNBUikgaW4gaW5ncmVzc28gcGVyIGxlIGRpc3RvcnNpb25pIHJhZGlvbWV0cmljaGUgZG92dXRlIGFsbGEgdG9wb2dyYWZpYS5cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uRGVzYzogXCI8cD5MYSBmdW56aW9uZSByYXN0ZXIgTGl2ZWxsYW1lbnRvIHRlcnJlbm8gY29ycmVnZ2UgaSBkYXRpIHJhZGFyIGFkIGFwZXJ0dXJhIHNpbnRldGljYSAoU0FSKSBpbiBpbmdyZXNzbyBwZXIgbGUgZGlzdG9yc2lvbmkgcmFkaW9tZXRyaWNoZSBkb3Z1dGUgYWxsYSB0b3BvZ3JhZmlhLjwvcD48cD5JIGRhdGkgcmFkYXIgaW4gaW5ncmVzc28gZGV2b25vIHByaW1hIHJpY2V2ZXJlIGxhIGNhbGlicmF6aW9uZSBiZXRhIG5vdWdodC4gVXNhIGxvIHN0cnVtZW50byBBcHBsaWNhIGNhbGlicmF6aW9uZSByYWRpb21ldHJpY2EgcGVyIGNhbGlicmFyZSBpIGRhdGkgcmFkYXIgYSBiZXRhIHplcm8uPC9wPjxwPlNlIGlsIERFTSBkaSBpbnB1dCBub24gY29wcmUgbCdpbnRlcm8gZGF0YXNldCBTQVIsIGxvIHN0cnVtZW50byBlbWV0dGUgdmFsb3JpIE5vRGF0YSBwZXIgaSBwaXhlbCBhbCBkaSBmdW9yaSBkZWxsJ2VzdGVuc2lvbmUgZGVsIERFTSBwZXIgZ2xpIG91dHB1dCBnYW1tYSBub3VnaHQsIHNpZ21hIG5vdWdodCwgYXJlYSBkaSBkaXNwZXJzaW9uZSBlIGRpc3RvcnNpb25lIGdlb21ldHJpY2EuIFBlciBsJ291dHB1dCBkZWxsYSBtYXNjaGVyYSBkaSBkaXN0b3JzaW9uZSBnZW9tZXRyaWNhLCBsbyBzdHJ1bWVudG8gZW1ldHRlIHZhbG9yaSBpbmRldGVybWluYXRpIHBlciBpIHBpeGVsIGFsIGRpIGZ1b3JpIGRlbGwnZXN0ZW5zaW9uZSBkZWwgREVNLjwvcD48cD5JbCBERU0gZGkgaW5wdXQgZGV2ZSBlc3NlcmUgbmVsIHNpc3RlbWEgZGkgY29vcmRpbmF0ZSBnZW9ncmFmaWNvIFdHUyAxOTg0IChFUFNHOjQzMjYpLjwvcD5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uTmFtZTogXCJDcmVhIGNvbG9yZSBjb21wb3NpdG9cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uU25pcDogXCJDcmVhIHVuIHJhc3RlciBhIHRyZSBiYW5kZSBkYSB1biBkYXRhc2V0IHJhc3RlciBtdWx0aWJhbmRhIGluIGN1aSBvZ25pIGJhbmRhIHB1w7IgdXRpbGl6emFyZSB1biBjYWxjb2xvIGFsZ2VicmljbyBiYXNhdG8gc3VsbCdhbGdlYnJhIGRlbGxlIGJhbmRlLlwiLFxuXHRcdGNyZWF0ZUNvbG9yQ29tcG9zaXRlRnVuY3Rpb25EZXNjOiBcIjxwPkxhIGZ1bnppb25lIHJhc3RlciBDcmVhIGNvbG9yZSBjb21wb3NpdG8gY3JlYSB1biByYXN0ZXIgYSB0cmUgYmFuZGUgZGEgdW4gZGF0YXNldCByYXN0ZXIgbXVsdGliYW5kYSBpbiBjdWkgb2duaSBiYW5kYSBwdcOyIHV0aWxpenphcmUgdW4gY2FsY29sbyBhbGdlYnJpY28gYmFzYXRvIHN1bGwnYWxnZWJyYSBkZWxsZSBiYW5kZS48L3A+PHA+UXVhbmRvIHNpIGRlZmluaXNjZSB1biBhbGdvcml0bW8gYXJpdG1ldGljbyBhIGJhbmRlLCDDqCBwb3NzaWJpbGUgaW5zZXJpcmUgdW5hIGZvcm11bGEgYWxnZWJyaWNhIGEgcmlnYSBzaW5nb2xhIHBlciBvZ25pIGVzcHJlc3Npb25lIHBlciBjcmVhcmUgdW4gb3V0cHV0IG11bHRpYmFuZGEuIEdsaSBvcGVyYXRvcmkgc3VwcG9ydGF0aSBzb25vIHVuYXJpOiBwacO5ICgrKSwgbWVubyAoLSksIHZvbHRlICgqKSBlIGRpdmlkaSAoLykuPC9wPjxwPlF1YW5kbyBzaSB1dGlsaXp6YSB1biBJRCBiYW5kYSBpbiB1bidlc3ByZXNzaW9uZSwgaWRlbnRpZmljYXJlIGxhIGJhbmRhIGFudGVwb25lbmRvIEIgbyBiIGFsIG51bWVybyBkaSBiYW5kYS48L3A+PHA+VW5hIGNvbWJpbmF6aW9uZSBkaSBiYW5kZSBjb211bmVtZW50ZSB1dGlsaXp6YXRhIHBlciBpIHJhZGFyIGFkIGFwZXJ0dXJhIHNpbnRldGljYSAoU0FSKSBpbiB1bml0w6AgbGluZWFyaSDDqCBWViBwZXIgaWwgcm9zc28sIFZIIHBlciBpbCB2ZXJkZSBlIFZWL1ZIIHBlciBpbCBibHUuIFNlIGkgZGF0aSBkaSBpbnB1dCBzb25vIGluIGRlY2liZWwsIGxhIGNvbWJpbmF6aW9uZSBkaSBiYW5kZSBkZXZlIGVzc2VyZSBWViBwZXIgaWwgcm9zc28sIFZIIHBlciBpbCB2ZXJkZSBlIFZWLVZIIHBlciBpbCBibHUuPC9wPlwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzTmFtZTogXCJQYXJhbWV0cmkgc3VwZXJmaWNpZVwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzU25pcDogXCJEZXRlcm1pbmEgaSBwYXJhbWV0cmkgZGkgdW4gcmFzdGVyIHN1cGVyZmljaWUsIGFkIGVzZW1waW8gYXNwZXR0bywgcGVuZGVuemEgZSB2YXJpIHRpcGkgZGkgY3VydmF0dXJlIHRyYW1pdGUgbWV0b2RpIGdlb2RldGljaS5cIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc0Rlc2M6IFwiPHA+TGEgZnVuemlvbmUgUGFyYW1ldHJpIHN1cGVyZmljaWUgZGV0ZXJtaW5hIGkgcGFyYW1ldHJpIGRpIHVuIHJhc3RlciBzdXBlcmZpY2llLCBhZCBlc2VtcGlvIGFzcGV0dG8sIHBlbmRlbnphIGUgdmFyaSB0aXBpIGRpIGN1cnZhdHVyZSB0cmFtaXRlIG1ldG9kaSBnZW9kZXRpY2kuPC9wPjxwPlF1ZXN0YSBmdW56aW9uZSBwdcOyIGVzc2VyZSB1dGlsaXp6YXRhIHBlciBsZSBzZWd1ZW50aSBhcHBsaWNhemlvbmk6PC9wPjx1bD48bGk+Q2FsY29sbyBkZWxsJ2FzcGV0dG8gZSBkZWxsYSBwZW5kZW56YSB0cmFtaXRlIG1ldG9kaSBnZW9kZXRpY2kuPC9saT48bGk+Q2FsY29sbyBkaSB2YXJpIHRpcGkgZGkgY3VydmF0dXJlIGRhIHVuIHJhc3RlciBzdXBlcmZpY2llIGRpIGlucHV0LCBhZCBlc2VtcGlvIDxzdHJvbmc+Q3VydmF0dXJhIHRhbmdlbnppYWxlIChjb250b3JubyBub3JtYWxlKTwvc3Ryb25nPiwgY2hlIGNhcmF0dGVyaXp6YSBsYSBjb252ZXJnZW56YSBlIGxhIGRpdmVyZ2VuemEgdG9wb2dyYWZpY2EgZGkgdW4gZmx1c3NvIG5lbGxhIHN1cGVyZmljaWUuPC9saT48L3VsPlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yTmFtZTogXCJDb3JyaWRvaW8gY29zdG8gbWluaW1vXCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JTbmlwOiBcIkNhbGNvbGEgbGEgc29tbWEgZGkgZHVlIHJhc3RlciBkaSBkaXN0YW56YSBkaSBjb3N0byBjdW11bGF0aXZvIGNvbiBsJ29wemlvbmUgY2hlIGNvbnNlbnRlIGRpIGFwcGxpY2FyZSB1bmEgc29nbGlhIGluIGJhc2UgYWwgY29zdG8gY3VtdWxhdGl2byBvIHBlcmNlbnR1YWxlLlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yRGVzYzogXCI8cD5JIHJhc3RlciBkaSBpbnB1dCBkZXZvbm8gZXNzZXJlIHJhc3RlciBkaSBhY2N1bXVsbyBkaXN0YW56YSBlIGRpIGRpcmV6aW9uZSBpbnZlcnNhIHByb2RvdHRpIGRhbGxhIGZ1bnppb25lIDxzdHJvbmc+QWNjdW11bG8gZGlzdGFuemE8L3N0cm9uZz4gbyA8c3Ryb25nPkFsbG9jYXppb25lIGRpc3RhbnphPC9zdHJvbmc+LiBEZXZvbm8gZXNzZXJlIHV0aWxpenphdGkgaW4gYmFzZSBhbGxhIGRpc3RhbnphIGRpIGNvc3RvLCBlIGR1cmFudGUgbGEgY3JlYXppb25lIGRlaSBsYXllciBwZXIgb2duaSBvcmlnaW5lIGRldm9ubyBlc3NlcmUgdXRpbGl6emF0ZSBsZSBzdGVzc2UgaW1wb3N0YXppb25pIGRlaSBwYXJhbWV0cmkuIFBlciBjcmVhcmUgcXVlc3RpIHJhc3Rlciwgbm9uIGRldmUgZXNzZXJlIHV0aWxpenphdG8gYWxjdW4gcGFyYW1ldHJvIGRpcGVuZGVudGUgZGFsbGEgZGlyZXppb25hbGl0w6AgKGZhdHRvcmUgb3JpenpvbnRhbGUsIGZhdHRvcmUgdmVydGljYWxlIGUgZGlyZXppb25lIGRpIHZpYWdnaW8pLjwvcD48cD5JIHZhbG9yaSBkZWwgcmFzdGVyIGNvcnJpZG9pbyBkaSBvdXRwdXQgc29ubyBsYSBzb21tYSBkZWwgY29zdG8gY3VtdWxhdGl2byBwZXIgcmFnZ2l1bmdlcmUgdW5hIHBvc2l6aW9uZSBmb3JuaXRhIGNvbiBsZSBzdGVzc2UgdW5pdMOgIGRlaSByYXN0ZXIgZGkgZGlzdGFuemEgZGkgY29zdG8gY3VtdWxhdGl2byBkaSBpbnB1dC48L3A+PHA+U2UgdW4gdmFsb3JlIGRpIDxzdHJvbmc+U29nbGlhPC9zdHJvbmc+IHNwZWNpZmljYXRvIMOoIG1hZ2dpb3JlIGRlbCBjb3N0byBjdW11bGF0aXZvIG1hc3NpbW8gcXVhbmRvIGkgZHVlIHJhc3RlciBkaSBhY2N1bXVsbyB2ZW5nb25vIHNvbW1hdGksIGlsIHJhc3RlciBjb3JyaWRvaW8gZGkgb3V0cHV0IGNvcHJpcsOgIGxhIHN0ZXNzYSBhcmVhIGRlaSByYXN0ZXIgY3VtdWxhdGl2aSBkaSBpbnB1dC48L3A+PHA+U2UgdW4gdmFsb3JlIGRpIHNvZ2xpYSBzcGVjaWZpY2F0byDDqCBtaW5vcmUgZGVsIHZhbG9yZSBtaW5pbW8gZGVsIHJhc3RlciBjb3JyaWRvaW8sIHZpZW5lIHJlc3RpdHVpdG8gdW4gbWVzc2FnZ2lvIGRpIGF2dmlzbyBlIGlsIHJhc3RlciBkaSBvdXRwdXQgc2Fyw6AgdnVvdG8uPC9wPjxwPklsIHJhc3RlciBjb3JyaWRvaW8gZGkgb3V0cHV0IHBvdHJlYmJlIGNvbnRlbmVyZSBjZWxsZSBjb24gY29zdGkgY3VtdWxhdGl2aSBsZWdnZXJtZW50ZSBtYWdnaW9yaSBkZWwgdmFsb3JlIGRpIHNvZ2xpYS4gVGFsZSByaXN1bHRhdG8gZGVyaXZhIGRhaSByYXN0ZXIgZGkgZGlyZXppb25lIGludmVyc2EgY2hlIHV0aWxpenphbm8gY2VsbGUgYXNzZWduYXRlIGNvbiBjb3N0aSBsaWV2ZW1lbnRlIHBpw7kgYWx0aSBkZWxsYSBzb2dsaWEgcGVyIGNvbGxlZ2FyZSBsZSBjZWxsZSBzY29sbGVnYXRlIGFsIGNvcnJpZG9pby48L3A+XCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuTmFtZTogXCJNZWRpYW5hIGdlb21ldHJpY2FcIixcblx0XHRnZW9tZXRyaWNNZWRpYW5TbmlwOiBcIkxhIGZ1bnppb25lIE1lZGlhbmEgZ2VvbWV0cmljYSBjYWxjb2xhIGxhIG1lZGlhbmEgZ2VvbWV0cmljYSB0cmEgaSBwaXhlbCBpbiB1bmEgc2VyaWUgdGVtcG9yYWxlIGRpIGltbWFnaW5pIG11bHRpYmFuZGEuXCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuRGVzYzogXCI8cD5RdWVzdGEgZnVuemlvbmUgcmlkdWNlIGlsIHJ1bW9yZSBlIGxlIGFub21hbGllIGluIGltbWFnaW5pIGRpIHNlcmllIHRlbXBvcmFsaSBjYWxjb2xhbmRvIHVuIHBpeGVsIG1lZGlhbm8gZ2VvbWV0cmljbyBwZXIgb2duaSBwaXhlbCBuZWxsYSBwaWxhIGRpIGltbWFnaW5pLiBMJ2FsZ29yaXRtbyBtYW50aWVuZSBsZSByZWxhemlvbmkgc3BldHRyYWxpIHRyYSBiYW5kZSBuZWdsaSBzcGV0dHJpIGRpIHBpeGVsIHBlciBjdWkgbCdvdXRwdXQgcHXDsiBlc3NlcmUgdXRpbGl6emF0byBuZWxsJ2FuYWxpc2ksIGFkIGVzZW1waW8gcGVyIGdsaSBpbmRpY2kgZGkgdmVnZXRhemlvbmUuPC9wPjxwPk51dm9sZSBlIG9tYnJlIGRldm9ubyBlc3NlcmUgbWFzY2hlcmF0ZSB1dGlsaXp6YW5kbyBsYSBiYW5kYSBRQSBkZWwgZGF0YXNldCBwcmltYSBkaSBhcHBsaWNhcmUgcXVlc3RhIGZ1bnppb25lLjwvcD48cD5TZSBsJ2ltbWFnaW5lIGRpIGlucHV0IMOoIGluIHZpcmdvbGEgbW9iaWxlLCBhZCBlc2VtcGlvIGxhIHJpZmxldHRhbnphIGRpIHN1cGVyZmljaWUgY29uIHZhbG9yaSBjb21wcmVzaSB0cmEgMCBlIDEsIHVuIHZhbG9yZSBlcHNpbG9uIGRpIDAsMDAxIGRldmUgcHJvZHVycmUgcmlzdWx0YXRpIGRpIHF1YWxpdMOgLjwvcD5cIlxuXHR9LFxuXHRyZnhBcmdzOiB7XG5cdFx0cmFzdGVyTmFtZTogXCJSYXN0ZXJcIixcblx0XHRjb2xvclNjaGVtZVR5cGVOYW1lOiBcIlRpcG8gZGkgc2NoZW1hIGNvbG9yaVwiLFxuXHRcdGNvbG9ybWFwTmFtZTogXCJDb2xvcm1hcFwiLFxuXHRcdGNvbG9ybWFwTmFtZU5hbWU6IFwiTm9tZSBDb2xvcm1hcFwiLFxuXHRcdGNvbG9yUmFtcE5hbWU6IFwiU2NhbGEgY3JvbWF0aWNhXCIsXG5cdFx0Y29udHJhc3RPZmZzZXROYW1lOiBcIk9mZnNldCBjb250cmFzdG9cIixcblx0XHRicmlnaHRuZXNzT2Zmc2V0TmFtZTogXCJPZmZzZXQgbHVtaW5vc2l0w6BcIixcblx0XHRtZXRob2ROYW1lOiBcIk1ldG9kb1wiLFxuXHRcdGJhbmROYW1lc05hbWU6IFwiTm9taSBiYW5kZVwiLFxuXHRcdGJhbmRXYXZlbGVuZ3Roc05hbWU6IFwiTHVuZ2hlenplIGQnb25kYSBiYW5kZVwiLFxuXHRcdGJhbmRJZHNOYW1lOiBcIklEIGJhbmRlXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25OYW1lOiBcIkF6aW9uZSBwZXIgYmFuZGEgbWFuY2FudGVcIixcblx0XHRjb252ZXJzaW9uUGFyYW1ldGVyc05hbWU6IFwiUGFyYW1ldHJpIGNvbnZlcnNpb25lXCIsXG5cdFx0aGlsbHNoYWRlVHlwZU5hbWU6IFwiVGlwbyByaWxpZXZvIG9tYnJlZ2dpYXRvXCIsXG5cdFx0YXppbXV0aE5hbWU6IFwiQXppbXV0XCIsXG5cdFx0YWx0aXR1ZGVOYW1lOiBcIkFsdGl0dWRpbmVcIixcblx0XHRzbG9wZVR5cGVOYW1lOiBcIlNjYWxhXCIsXG5cdFx0ekZhY3Rvck5hbWU6IFwiRmF0dG9yZSBaXCIsXG5cdFx0UFNQb3dlck5hbWU6IFwiUG90ZW56YSBkaW1lbnNpb25lIHBpeGVsXCIsXG5cdFx0UFNaRmFjdG9yTmFtZTogXCJGYXR0b3JlIGRpbWVuc2lvbmUgcGl4ZWxcIixcblx0XHRyZW1vdmVFZGdlRWZmZWN0TmFtZTogXCJEaXNhYmlsaXRhIGludGVycG9sYXppb25lIHBpeGVsIGJvcmRvIHByZWRlZmluaXRhXCIsXG5cdFx0ZnJvbVVuaXROYW1lOiBcIlVuaXTDoCBkaSBvcmlnaW5lXCIsXG5cdFx0dG9Vbml0TmFtZTogXCJVbml0w6AgZGkgZGVzdGluYXppb25lXCIsXG5cdFx0cmFzdGVyVHlwZU5hbWU6IFwiVGlwb1wiLFxuXHRcdG1pbk5hbWU6IFwiT3V0cHV0IG1pbmltb1wiLFxuXHRcdG1heE5hbWU6IFwiT3V0cHV0IG1hc3NpbW9cIixcblx0XHRtaW5QZXJjZW50TmFtZTogXCJSaXRhZ2xpbyBwZXJjZW50dWFsZSBtaW5pbW9cIixcblx0XHRtYXhQZXJjZW50TmFtZTogXCJSaXRhZ2xpbyBwZXJjZW50dWFsZSBtYXNzaW1vXCIsXG5cdFx0bnVtYmVyT2ZTdGFuZGFyZERldmlhdGlvbk5hbWU6IFwiTnVtZXJvIGRpIGRldmlhemlvbmkgc3RhbmRhcmRcIixcblx0XHRzaWdtb2lkU3RyZW5ndGhMZXZlbE5hbWU6IFwiTGl2ZWxsbyBkaSBmb3J6YSBzaWdtb2lkZWFcIixcblx0XHRlc3RpbWF0ZVN0YXRzSGlzdG9ncmFtTmFtZTogXCJWYWx1dGEgc3RhdGlzdGljaGVcIixcblx0XHREUkFOYW1lOiBcIlJlZ29sYXppb25lIGdhbW1hIGRpbmFtaWNhXCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGljaGVcIixcblx0XHRoaXN0b2dyYW1zTmFtZTogXCJJc3RvZ3JhbW1pXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbU5hbWU6IFwiRGVmaW5pc2NpIHN0YXRpc3RpY2hlIGUgaXN0b2dyYW1tYVwiLFxuXHRcdGNvbXB1dGVHYW1tYU5hbWU6IFwiR2FtbWEgYXV0b21hdGljYVwiLFxuXHRcdHVzZUdhbW1hTmFtZTogXCJVc2EgZ2FtbWFcIixcblx0XHRnYW1tYU5hbWU6IFwiR2FtbWFcIixcblx0XHRpbnB1dE5hbWVzTmFtZTogXCJOb21pXCIsXG5cdFx0ZXhwcmVzc2lvbk5hbWU6IFwiRXNwcmVzc2lvbmVcIixcblx0XHRjZWxsc2l6ZVR5cGVOYW1lOiBcIlRpcG8gZGkgZGltZW5zaW9uZSBjZWxsYVwiLFxuXHRcdGV4dGVudFR5cGVOYW1lOiBcIlRpcG8gZGkgZXN0ZW5zaW9uZVwiLFxuXHRcdGNsYXNzaWZpZXJEZWZpbml0aW9uRmlsZU5hbWU6IFwiRmlsZSBkaSBkZWZpbml6aW9uZSBkaSBpbnB1dFwiLFxuXHRcdHJhc3RlcjFOYW1lOiBcIlJhc3RlcjFcIixcblx0XHRyYXN0ZXIyTmFtZTogXCJSYXN0ZXIyXCIsXG5cdFx0cmFzdGVyM05hbWU6IFwiUmFzdGVyM1wiLFxuXHRcdHRydWVSYXN0ZXJOYW1lOiBcIlJhc3RlciB2ZXJvXCIsXG5cdFx0ZmFsc2VSYXN0ZXJOYW1lOiBcIlJhc3RlciBmYWxzb1wiLFxuXHRcdG5vRGF0YUludGVycHJldGF0aW9uTmFtZTogXCJJbnRlcnByZXRhemlvbmUgTm9EYXRhXCIsXG5cdFx0bm9EYXRhVmFsdWVzTmFtZTogXCJWYWxvcmkgTm9EYXRhXCIsXG5cdFx0aW5jbHVkZWRSYW5nZXNOYW1lOiBcIkludGVydmFsbGkgaW5jbHVzaVwiLFxuXHRcdGN1cnZhdHVyZVR5cGVOYW1lOiBcIlRpcG8gZGkgY3VydmF0dXJhXCIsXG5cdFx0cmFzdGVyc05hbWU6IFwiUmFzdGVyXCIsXG5cdFx0YXR0cmlidXRlVGFibGVOYW1lOiBcIlRhYmVsbGFcIixcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVOYW1lOiBcIlRpcG8gZGkgdGFiZWxsYVwiLFxuXHRcdHJvd3NOYW1lOiBcIk51bWVybyBkaSByaWdoZVwiLFxuXHRcdGNvbHVtbnNOYW1lOiBcIk51bWVybyBkaSBjb2xvbm5lXCIsXG5cdFx0a2VybmVsTmFtZTogXCJLZXJuZWxcIixcblx0XHRtaXJyb3JFZGdlc05hbWU6IFwiUmlmbGV0dGkgYm9yZGlcIixcblx0XHRpbmZsdWVuY2VzTmFtZTogXCJJbmZsdWVuemVcIixcblx0XHRmaWVsZHNOYW1lOiBcIkNhbXBpXCIsXG5cdFx0cmVtYXBzTmFtZTogXCJSaW1hcHBhIHRhYmVsbGFcIixcblx0XHRldmFsRnJvbU5hbWU6IFwiU2NhbGEgZGkgdmFsdXRhemlvbmUgRGFcIixcblx0XHRldmFsVG9OYW1lOiBcIlNjYWxhIGRpIHZhbHV0YXppb25lIEFcIixcblx0XHR3ZWlnaHRzTmFtZTogXCJQZXNpXCIsXG5cdFx0REVNTmFtZTogXCJERU1cIixcblx0XHRzaG9ydFJhbmdlSURXUmFkaXVzTmFtZTogXCJSYWdnaW8gSURXIGEgYnJldmUgZGlzdGFuemFcIixcblx0XHRtYXhWb2lkV2lkdGhOYW1lOiBcIkxhcmdoZXp6YSBtYXNzaW1hIGRlbCBWb2lkXCIsXG5cdFx0c2lnbWFHYXVzc2lhbk5hbWU6IFwiU3BpYW5hdHVyYSBhZGF0dGl2YVwiLFxuXHRcdGNvbnRvdXJUeXBlTmFtZTogXCJUaXBvIGRpIGNvbnRvcm5vXCIsXG5cdFx0ekJhc2VOYW1lOiBcIkJhc2UgWlwiLFxuXHRcdG51bWJlck9mQ29udG91cnNOYW1lOiBcIk51bWJlciBPZiBDb250b3Vyc1wiLFxuXHRcdGNvbnRvdXJJbnRlcnZhbE5hbWU6IFwiSW50ZXJ2YWxsbyBDb250b3VyXCIsXG5cdFx0bnRoQ29udG91ckxpbmVJbkJvbGROYW1lOiBcIk7CqiBsaW5lYSBkaSBjb250b3JubyBpbiBncmFzc2V0dG9cIixcblx0XHRmZWF0dXJlQ2xhc3NOYW1lOiBcIkZlYXR1cmUgZGkgaW5wdXRcIixcblx0XHRjbGFzc0luZGV4RmllbGROYW1lOiBcIkNhbXBvXCIsXG5cdFx0cmVzb2x2ZU92ZXJsYXBNZXRob2ROYW1lOiBcIlJpc29sdmkgc292cmFwcG9zaXppb25lXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVOYW1lOiBcIlRpcG8gcmljYW1waW9uYW1lbnRvXCIsXG5cdFx0aW5wdXRDZWxsc2l6ZU5hbWU6IFwiRGltZW5zaW9uaSBjZWxsYSBpbnB1dFwiLFxuXHRcdG91dHB1dENlbGxzaXplTmFtZTogXCJEaW1lbnNpb25pIGNlbGxhIG91dHB1dFwiLFxuXHRcdHBvaW50RmVhdHVyZUNsYXNzTmFtZTogXCJQdW50aSBkaSBzZWVkXCIsXG5cdFx0bWF4R3Jvd3RoUmFkaXVzRmllbGROYW1lOiBcIkNhbXBvIHJhZ2dpbyBkaSBjcmVzY2l0YSBtYXNzaW1hXCIsXG5cdFx0c2ltaWxhcml0eVRocmVzaG9sZEZpZWxkTmFtZTogXCJDYW1wbyBTaW1pbGFyaXR5IFRocmVzaG9sZFwiLFxuXHRcdGZpbGxWYWx1ZUZpZWxkTmFtZTogXCJDYW1wbyBkaSByaWVtcGltZW50byB2YWxvcmVcIixcblx0XHRzcGVjdHJhbERldGFpbE5hbWU6IFwiRGV0dGFnbGlvIHNwZXR0cmFsZSBbMS4uMjBdXCIsXG5cdFx0c3BhdGlhbERldGFpbE5hbWU6IFwiRGV0dGFnbGlvIHNwYXppYWxlIFsxLi4yMF1cIixcblx0XHRtaW5OdW1QaXhlbHNQZXJTZWdtZW50TmFtZTogXCJEaW1lbnNpb25lIHNlZ21lbnRvIG1pbmltYSBpbiBwaXhlbFwiLFxuXHRcdGJvdW5kYXJpZXNPbmx5TmFtZTogXCJTb2xvIGNvbmZpbmkgc2VnbWVudG9cIixcblx0XHRzdGF0aXN0aWNzVHlwZU5hbWU6IFwiVGlwbyBzdGF0aXN0aWNoZVwiLFxuXHRcdGZpbGxOb0RhdGFPbmx5TmFtZTogXCJSaWVtcGlyZSBzb2xvIHBpeGVsIE5vRGF0YVwiLFxuXHRcdGlucHV0RGF0YVR5cGVOYW1lOiBcIlRpcG8gZGkgZGF0aSBkaSBpbnB1dFwiLFxuXHRcdGFuZ2xlUmVmZXJlbmNlU3lzdGVtTmFtZTogXCJTaXN0ZW1hIGRpIHJpZmVyaW1lbnRvIGFuZ29sYXJlXCIsXG5cdFx0b3V0cHV0RGF0YVR5cGVOYW1lOiBcIlRpcG8gZGkgZGF0aSBkaSBvdXRwdXRcIixcblx0XHRpbnB1dFNhbXBsZVBvaW50RmVhdHVyZUNsYXNzTmFtZTogXCJDYW1waW9uaSBkaSBpbnB1dFwiLFxuXHRcdHZhbHVlRmllbGROYW1lOiBcIkNhbXBvIHZhbG9yZVwiLFxuXHRcdHJhc3RlckluZm9OYW1lOiBcIkluZm9ybWF6aW9uaSByYXN0ZXJcIixcblx0XHRpbnRlcnBvbGF0aW9uTWV0aG9kTmFtZTogXCJNZXRvZG8gZGkgaW50ZXJwb2xhemlvbmVcIixcblx0XHRyYWRpdXNOYW1lOiBcIlJhZ2dpb1wiLFxuXHRcdHJhZGlhbmNlR2FpblZhbHVlc05hbWU6IFwiR3VhZGFnbm8gcmFkaWFuemFcIixcblx0XHRyYWRpYW5jZUJpYXNWYWx1ZXNOYW1lOiBcIlJhZGlhbmNlIEJpYXNcIixcblx0XHRyZWZsZWN0ZWRHYWluVmFsdWVzTmFtZTogXCJHdWFkYWdubyByaWZsZXNzaW9uZVwiLFxuXHRcdHJlZmxlY3RlZEJpYXNWYWx1ZXNOYW1lOiBcIkNvbXBlbnNhemlvbmUgcmlmbGVzc2lvbmVcIixcblx0XHRzdW5FbGV2YXRpb25OYW1lOiBcIkVsZXZhemlvbmUgc29sZSAoZ3JhZGkpXCIsXG5cdFx0YWxiZWRvTmFtZTogXCJBbGJlZG9cIixcblx0XHRzY2FsZUZhY3Rvck5hbWU6IFwiRmF0dG9yZSBkaSBzY2FsYVwiLFxuXHRcdG9mZnNldE5hbWU6IFwiT2Zmc2V0XCIsXG5cdFx0dGhyZXNob2xkVHlwZU5hbWU6IFwiVGlwbyBkaSBzb2dsaWFcIixcblx0XHR0aHJlc2hvbGRzTmFtZTogXCJTb2dsaWVcIixcblx0XHR1bmRlZmluZWRDbGFzc05hbWU6IFwiQ2xhc3NlIG5vbiBkZWZpbml0YVwiLFxuXHRcdG1pblZhbHVlTmFtZTogXCJNaW5pbWFcIixcblx0XHRtYXhWYWx1ZU5hbWU6IFwiTWFzc2ltYVwiLFxuXHRcdG9wZXJhdGlvbk5hbWU6IFwiT3BlcmF6aW9uZVwiLFxuXHRcdGNsaXBwaW5nVHlwZU5hbWU6IFwiVGlwbyBkaSByaXRhZ2xpb1wiLFxuXHRcdGNsaXBwaW5nR2VvbWV0cnlOYW1lOiBcIkdlb21ldHJpYSBkaSByaXRhZ2xpby9SYXN0ZXJcIixcblx0XHRleHRlbnROYW1lOiBcIkVzdGVuc2lvbmUgZGkgb3V0cHV0XCIsXG5cdFx0dXNlSW5wdXRGZWF0dXJlR2VvbWV0cnlOYW1lOiBcIlV0aWxpenphcmUgZmVhdHVyZSBkaSBpbnB1dCBwZXIgbGEgZ2VvbWV0cmlhIGRpIHJpdGFnbGlvXCIsXG5cdFx0cmVtYXBEZWZpbml0aW9uVHlwZU5hbWU6IFwiUmltYXBwYSB0aXBvIGRlZmluaXppb25lXCIsXG5cdFx0aW5wdXRSYW5nZU5hbWU6IFwiSW50ZXJ2YWxsaSBkaSBpbnB1dFwiLFxuXHRcdG91dHB1dFZhbHVlc05hbWU6IFwiVmFsb3JpIGRpIG91dHB1dFwiLFxuXHRcdG5vRGF0YVJhbmdlTmFtZTogXCJJbnRlcnZhbGxpIE5vRGF0YVwiLFxuXHRcdGlucHV0RmllbGROYW1lOiBcIkNhbXBvIGRpIGlucHV0XCIsXG5cdFx0b3V0cHV0RmllbGROYW1lOiBcIkNhbXBvIGRpIG91dHB1dFwiLFxuXHRcdGlucHV0TWF4RmllbGROYW1lOiBcIkNhbXBvIG1heCBkaSBpbnB1dCAoZmFjb2x0YXRpdm8pXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVOYW1lOiBcIlJpbWFwcGEgdGlwbyB0YWJlbGxhXCIsXG5cdFx0YWxsb3dVbm1hdGNoZWROYW1lOiBcIkNvbnNlbnRpIHZhbG9yaSBkaSBwaXhlbCBub24gY29ycmlzcG9uZGVudGlcIixcblx0XHRjaGFuZ2VNaXNzaW5nVmFsdWVzVG9Ob0RhdGFOYW1lOiBcIkNhbWJpYSB2YWxvcmkgbWFuY2FudGkgaW4gTm9EYXRhXCIsXG5cdFx0dmlzaWJsZUJhbmRJRE5hbWU6IFwiSUQgYmFuZGEgdmlzaWJpbGVcIixcblx0XHRpbmZyYXJlZEJhbmRJRE5hbWU6IFwiSUQgYmFuZGEgaW5mcmFyb3Nzb1wiLFxuXHRcdHNjaWVudGlmaWNPdXRwdXROYW1lOiBcIk91dHB1dCBzY2llbnRpZmljb1wiLFxuXHRcdGJhbmRJbmRleGVzTmFtZTogXCJJbmRpY2kgYmFuZGVcIixcblx0XHRjb25zdGFudE5hbWU6IFwiQ29zdGFudGVcIixcblx0XHR3ZWlnaHROYW1lOiBcIlBlc29cIixcblx0XHRtaW5pbXVtTmFtZTogXCJNaW5pbW9cIixcblx0XHRtYXhpbXVtTmFtZTogXCJNYXNzaW1vXCIsXG5cdFx0c291cmNlRGF0YU5hbWU6IFwiUmFzdGVyIGRpIG9yaWdpbmVcIixcblx0XHRzb3VyY2VGaWVsZE5hbWU6IFwiQ2FtcG8gZGkgb3JpZ2luZVwiLFxuXHRcdGNvc3RSYXN0ZXJOYW1lOiBcIlJhc3RlciBkaSBjb3N0b1wiLFxuXHRcdG1heERpc3RhbmNlTmFtZTogXCJEaXN0YW56YSBtYXNzaW1hXCIsXG5cdFx0dmFsdWVSYXN0ZXJOYW1lOiBcIlJhc3RlciB2YWxvcmVcIixcblx0XHRjb3N0TXVsdGlwbGllck5hbWU6IFwiTW9sdGlwbGljYXRvcmUgZGEgYXBwbGljYXJlIGFpIGNvc3RpXCIsXG5cdFx0c3RhcnRDb3N0TmFtZTogXCJDb3N0byBpbml6aWFsZVwiLFxuXHRcdGFjY3VtQ29zdFJlc2lzdGFuY2VSYXRlTmFtZTogXCJWZWxvY2l0w6AgcmVzaXN0ZW56YSBjb3N0byBjdW11bGF0aXZhXCIsXG5cdFx0Y2FwYWNpdHlOYW1lOiBcIkNhcGFjaXTDoFwiLFxuXHRcdHRyYXZlbERpcmVjdGlvbk5hbWU6IFwiRGlyZXppb25lIGRpIHZpYWdnaW9cIixcblx0XHRjZWxsU2l6ZU5hbWU6IFwiRGltZW5zaW9uZSBjZWxsYVwiLFxuXHRcdHBvcHVsYXRpb25GaWVsZE5hbWU6IFwiQ2FtcG8gcG9wb2xhemlvbmVcIixcblx0XHRhcmVhVW5pdHNOYW1lOiBcIlVuaXTDoCBhcmVhXCIsXG5cdFx0b3V0cHV0VmFsdWVUeXBlTmFtZTogXCJWYWxvcmkgY2VsbGEgZGkgb3V0cHV0XCIsXG5cdFx0YmFycmllcnNOYW1lOiBcIkJhcnJpZXJlIGRpIGlucHV0XCIsXG5cdFx0ZGVzdGluYXRpb25EYXRhTmFtZTogXCJSYXN0ZXIgZGkgZGVzdGluYXppb25lXCIsXG5cdFx0ZGVzdGluYXRpb25GaWVsZE5hbWU6IFwiQ2FtcG8gZGkgZGVzdGluYXppb25lXCIsXG5cdFx0cGF0aFR5cGVOYW1lOiBcIlRpcG8gZGkgcGVyY29yc29cIixcblx0XHRvYnNlcnZlckZlYXR1cmVzTmFtZTogXCJGZWF0dXJlIG9zc2VydmF0b3JpXCIsXG5cdFx0YW5hbHlzaXNNZXRob2ROYW1lOiBcIk1ldG9kbyBkaSBhbmFsaXNpXCIsXG5cdFx0YW5hbHlzaXNUeXBlTmFtZTogXCJUaXBvIGRpIGFuYWxpc2lcIixcblx0XHR2ZXJ0aWNhbEVycm9yTmFtZTogXCJFcnJvcmUgdmVydGljYWxlXCIsXG5cdFx0cmVmcmFjdGl2aXR5Q29lZmZpY2llbnROYW1lOiBcIkNvZWZmaWNpZW50ZSBkaSByaWZyYXR0aXZpdMOgXCIsXG5cdFx0c3VyZmFjZU9mZnNldE5hbWU6IFwiT2Zmc2V0IHN1cGVyZmljaWVcIixcblx0XHRvYnNlcnZlckVsZXZhdGlvbk5hbWU6IFwiRWxldmF6aW9uZSBvc3NlcnZhdG9yZVwiLFxuXHRcdG9ic2VydmVyT2Zmc2V0TmFtZTogXCJPZmZzZXQgb3NzZXJ2YXRvcmVcIixcblx0XHRpbm5lclJhZGl1c05hbWU6IFwiUmFnZ2lvIGludGVybm9cIixcblx0XHRpbm5lclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiSWwgcmFnZ2lvIGludGVybm8gw6ggdW5hIGRpc3RhbnphIDNEXCIsXG5cdFx0b3V0ZXJSYWRpdXNOYW1lOiBcIlJhZ2dpbyBlc3Rlcm5vXCIsXG5cdFx0b3V0ZXJSYWRpdXNJczNERGlzdGFuY2VOYW1lOiBcIklsIHJhZ2dpbyBlc3Rlcm5vIMOoIHVuYSBkaXN0YW56YSAzRFwiLFxuXHRcdGhvcml6b250YWxTdGFydEFuZ2xlTmFtZTogXCJBbmdvbG8gaW5pemlhbGUgb3JpenpvbnRhbGVcIixcblx0XHRob3Jpem9udGFsRW5kQW5nbGVOYW1lOiBcIkFuZ29sbyBmaW5hbGUgb3JpenpvbnRhbGVcIixcblx0XHR2ZXJ0aWNhbFVwcGVyQW5nbGVOYW1lOiBcIkFuZ29sbyBzdXBlcmlvcmUgdmVydGljYWxlXCIsXG5cdFx0dmVydGljYWxMb3dlckFuZ2xlTmFtZTogXCJBbmdvbG8gaW5mZXJpb3JlIHZlcnRpY2FsZVwiLFxuXHRcdHpvbmVEYXRhTmFtZTogXCJSYXN0ZXIgem9uYVwiLFxuXHRcdHpvbmVGaWVsZE5hbWU6IFwiQ2FtcG8gem9uYVwiLFxuXHRcdGlnbm9yZU5vRGF0YU5hbWU6IFwiSWdub3JhIE5vRGF0YSBuZWkgY2FsY29saVwiLFxuXHRcdHRlbXBlcmF0dXJlUmFzdGVyTmFtZTogXCJSYXN0ZXIgdGVtcGVyYXR1cmFcIixcblx0XHRpblRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlVuaXTDoCBkaSB0ZW1wZXJhdHVyYVwiLFxuXHRcdG91dEhlYXRJbmRleFRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlVuaXTDoCBpbmRpY2UgZGkgY2Fsb3JlXCIsXG5cdFx0cmVsYXRpdmVIdW1pZGl0eVJhc3Rlck5hbWU6IFwiUmFzdGVyIHVtaWRpdMOgIHJlbGF0aXZhXCIsXG5cdFx0b3V0V2luZENoaWxsVGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVW5pdMOgIFdpbmQgQ2hpbGxcIixcblx0XHR3aW5kU3BlZWRSYXN0ZXJOYW1lOiBcIlJhc3RlciB2ZWxvY2l0w6AgZGVsIHZlbnRvXCIsXG5cdFx0aW5XaW5kU3BlZWRVbml0c05hbWU6IFwiVW5pdMOgIGRpIHZlbG9jaXTDoCBkZWwgdmVudG9cIixcblx0XHR2YWx1ZU5hbWU6IFwiVmFsb3JlXCIsXG5cdFx0cHJvcGVydHlOYW1lOiBcIk5vbWUgcHJvcHJpZXTDoFwiLFxuXHRcdGpzb25OYW1lOiBcIk1ldGFkYXRpIEpTT05cIixcblx0XHR6b25lVGFibGVOYW1lOiBcIlRhYmVsbGEgYXR0cmlidXRpIHpvbmFsaVwiLFxuXHRcdGF0dHJpYnV0ZUZpZWxkTmFtZXM6IFwiTm9taSBjYW1wbyBhdHRyaWJ1dG9cIixcblx0XHRiYWNrZ3JvdW5kTmFtZTogXCJWYWxvcmUgc2ZvbmRvXCIsXG5cdFx0d2hlcmVDbGF1c2VOYW1lOiBcIkNsYXVzb2xhIFdoZXJlXCIsXG5cdFx0bWluaW11bVZhbHVlRmllbGROYW1lOiBcIk5vbWUgY2FtcG8gdmFsb3JlIG1pbmltb1wiLFxuXHRcdG1heGltdW1WYWx1ZUZpZWxkTmFtZTogXCJOb21lIGNhbXBvIHZhbG9yZSBtYXNzaW1vXCIsXG5cdFx0b3V0VmFsdWVGaWVsZE5hbWU6IFwiTm9tZSBjYW1wbyB2YWxvcmUgZGkgb3V0cHV0XCIsXG5cdFx0ZGVmYXVsdFZhbHVlTmFtZTogXCJWYWxvcmUgZGkgb3V0cHV0IHByZWRlZmluaXRvXCIsXG5cdFx0Y29udmVyc2lvbk1hdHJpeE5hbWU6IFwiTWF0cmljZSBkaSBjb252ZXJzaW9uZVwiLFxuXHRcdElzUHNldWRvQ29sb3JPdXRwdXROYW1lOiBcIsOIIHVuIG91dHB1dCBkaSBwc2V1ZG9jb2xvcmVcIixcblx0XHR1bm1hcHBlZEFzUmFuZG9tQ29sb3JOYW1lOiBcIkFzc2VnbmEgY29sb3JpIGluIG1vZG8gY2FzdWFsZSBhaSBwaXhlbCBub24gbWFwcGF0aVwiLFxuXHRcdGRpc3RhbmNlTWV0aG9kTmFtZTogXCJNZXRvZG8gRGlzdGFuemFcIixcblx0XHRmbG93RGlyUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGkgZGlyZXppb25lIGRlbCBmbHVzc29cIixcblx0XHRwb3VyUG9pbnROYW1lOiBcIlJhc3RlciBQb3VyIFBvaW50XCIsXG5cdFx0cG91clBvaW50RmllbGROYW1lOiBcIkNhbXBvIFBvdXIgUG9pbnRcIixcblx0XHRjb25zdGFudFpOYW1lOiBcIkNvbnN0YW50ZSBaXCIsXG5cdFx0ek9mZnNldE5hbWU6IFwiT2Zmc2V0IFpcIixcblx0XHRnZW9JZE5hbWU6IFwiR2VvaWRlXCIsXG5cdFx0Y2FsaWJyYXRpb25UeXBlTmFtZTogXCJUaXBvIGNhbGlicmF6aW9uZVwiLFxuXHRcdGZpbHRlclR5cGVOYW1lOiBcIlRpcG8gZGkgZmlsdHJvXCIsXG5cdFx0ZmlsdGVyU2l6ZU5hbWU6IFwiRGltZW5zaW9uZSBmaWx0cm9cIixcblx0XHRub2lzZU1vZGVsTmFtZTogXCJNb2RlbGxvIHJ1bW9yZVwiLFxuXHRcdG5vaXNlVmFyaWFuY2VOYW1lOiBcIlZhcmlhbnphIHJ1bW9yZVwiLFxuXHRcdGFkZGl0aXZlTm9pc2VNZWFuTmFtZTogXCJNZWRpYSBydW1vcmUgYWRkaXRpdm9cIixcblx0XHRtdWx0aXBsaWNhdGl2ZU5vaXNlTWVhbk5hbWU6IFwiTWVkaWEgcnVtb3JlIG1vbHRpcGxpY2F0aXZvXCIsXG5cdFx0bnVtYmVyb2ZMb29rc05hbWU6IFwiTnVtZXJvIGRpIHJpY2VyY2hlXCIsXG5cdFx0ZGFtcGluZ0ZhY3Rvck5hbWU6IFwiRmF0dG9yZSBkaSBzbW9yemFtZW50b1wiLFxuXHRcdG1hc2tSYXN0ZXJOYW1lOiBcIk1hc2NoZXJhIGRpIFJhc3RlclwiLFxuXHRcdG5pYmJsZVZhbHVlc05hbWU6IFwiVXNhIHZhbG9yaSBOb0RhdGEgc2Ugc29ubyBkaSB2aWNpbmFuemEgcGnDuSBwcm9zc2ltYVwiLFxuXHRcdG5pYmJsZU5vRGF0YU5hbWU6IFwiUmlkdXJyZSBjZWxsZSBOb0RhdGFcIixcblx0XHR6TGltaXROYW1lOiBcIkxpbWl0ZSBaXCIsXG5cdFx0Zmxvd0RpcmVjdGlvblR5cGVOYW1lOiBcIlRpcG8gZGkgZGlyZXppb25lIGRpIGZsdXNzb1wiLFxuXHRcdHdlaWdodFJhc3Rlck5hbWU6IFwiUmFzdGVyIGRpIHBlc2lcIixcblx0XHRmb3JjZUVkZ2VOYW1lOiBcIkZvcnphIHR1dHRpIGkgYm9yZGkgZGVsbGEgY2VsbGEgcGVyIGZsdWlyZSBhbGwnZXN0ZXJub1wiLFxuXHRcdHN0cmVhbVJhc3Rlck5hbWU6IFwiUmFzdGVyIGRpIGZsdXNzb1wiLFxuXHRcdHN1cmZhY2VSYXN0ZXJOYW1lOiBcIlN1cGVyZmljaWUgcmFzdGVyXCIsXG5cdFx0Y29udmVyc2lvblR5cGU6IFwiVGlwbyBkaSBjb252ZXJzaW9uZVwiLFxuXHRcdGRpc3RhbmNlUmFzdGVyMTogXCJSYXN0ZXIgZGkgZGlzdGFuemEgMVwiLFxuXHRcdGRpc3RhbmNlUmFzdGVyMjogXCJSYXN0ZXIgZGkgZGlzdGFuemEgMlwiLFxuXHRcdGNvc3REaXN0YW5jZVJhc3RlcjogXCJSYXN0ZXIgZGlzdGFuemEgZGkgY29zdG9cIixcblx0XHRjb3N0QmFja2xpbmtSYXN0ZXI6IFwiUmFzdGVyIGJhY2tsaW5rIGRpIGNvc3RvXCIsXG5cdFx0b3ZlcnJpZGVzTmFtZTogXCJFc2NsdXNpb25pXCIsXG5cdFx0ZmllbGROYW1lOiBcIkNhbXBvXCIsXG5cdFx0c2lnbmF0dXJlRmlsZU9yVXJsOiBcIkZpbGUgZGkgZmlybWEgbyBVUkxcIixcblx0XHRyZWROYW1lOiBcIlJvc3NvXCIsXG5cdFx0Z3JlZW5OYW1lOiBcIlZlcmRlXCIsXG5cdFx0Ymx1ZU5hbWU6IFwiQmx1XCIsXG5cdFx0aW5mcmFyZWROYW1lOiBcIkluZnJhcm9zc29cIixcblx0XHRwYW5jaHJvbWF0aWNOYW1lOiBcIlBhbmNyb21hdGljb1wiLFxuXHRcdG11bHRpc3BlY3RyYWxOYW1lOiBcIk11bHRpc3BldHRyYWxlXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1R5cGU6IFwiVGlwbyBwYW5zaGFycGVuaW5nXCIsXG5cdFx0c2Vuc29yTmFtZTogXCJTZW5zb3JlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZU5hbWU6IFwiUmlmZXJpbWVudG8gc3BhemlhbGVcIixcblx0XHR4Q2VsbHNpemVOYW1lOiBcIkRpbWVuc2lvbmUgY2VsbGEgWFwiLFxuXHRcdHlDZWxsc2l6ZU5hbWU6IFwiRGltZW5zaW9uZSBjZWxsYSBZXCIsXG5cdFx0eE9yaWdpbk5hbWU6IFwiUHVudG8gZGkgcmVnaXN0cmF6aW9uZSBYXCIsXG5cdFx0eU9yaWdpbk5hbWU6IFwiUHVudG8gZGkgcmVnaXN0cmF6aW9uZSBZXCIsXG5cdFx0cGVyY2VudGlsZU5hbWU6IFwiVmFsb3JlIHBlcmNlbnRpbGVcIixcblx0XHRuZWlnaGJvcmhvb2RUeXBlOiBcIlRpcG8gZGkgdmljaW5hbnphXCIsXG5cdFx0d2lkdGhOYW1lOiBcIkxhcmdoZXp6YVwiLFxuXHRcdGhlaWdodE5hbWU6IFwiQWx0ZXp6YVwiLFxuXHRcdHN0YXJ0QW5nbGVOYW1lOiBcIkFuZ29sbyBpbml6aWFsZVwiLFxuXHRcdGVuZEFuZ2xlTmFtZTogXCJBbmdvbG8gZmluYWxlXCIsXG5cdFx0bmVpZ2hib3Job29kVmFsdWVzOiBcIlZhbG9yaSBkaSBxdWFydGllcmVcIixcblx0XHRob3Jpem9udGFsUmFzdGVyOiBcIlJhc3RlciBvcml6em9udGFsZVwiLFxuXHRcdGhvcml6b250YWxGYWN0b3I6IFwiRmF0dG9yZSBvcml6em9udGFsZVwiLFxuXHRcdHZlcnRpY2FsUmFzdGVyOiBcIlJhc3RlciB2ZXJ0aWNhbGVcIixcblx0XHR2ZXJ0aWNhbEZhY3RvcjogXCJGYXR0b3JlIHZlcnRpY2FsZVwiLFxuXHRcdHN0cmVhbVJhc3RlcjogXCJSYXN0ZXIgZGkgZmx1c3NvXCIsXG5cdFx0Zmxvd0RpclJhc3RlcjogXCJSYXN0ZXIgZGkgZGlyZXppb25lIGRlbCBmbHVzc29cIixcblx0XHRudW1iZXJOZWlnaGJvckNlbGxzOiBcIk51bWVybyBkaSBjZWxsZSB2aWNpbmVcIixcblx0XHR6b25lQ29ubmVjdGl2aXR5OiBcIlpvbmEgZGkgY29ubmV0dGl2aXTDoFwiLFxuXHRcdGFkZExpbmtCZWhhdmlvcjogXCJBZ2dpdW5naSBjb2xsZWdhbWVudG9cIixcblx0XHRleGNsdWRlZFZhbHVlOiBcIlZhbG9yZSBlc2NsdXNvXCIsXG5cdFx0Y29uc3RhbnRGaWxsQ2hlY2s6IFwiR2VuZXJhIHJhc3RlciByaWVtcGltZW50byBkYSBjb3N0YW50ZVwiLFxuXHRcdGZpbGxSYXN0ZXI6IFwiUmFzdGVyIHJpZW1waW1lbnRvXCIsXG5cdFx0Y29uc3RhbnRGaWxsVmFsdWU6IFwiVmFsb3JlIGNvc3RhbnRlXCIsXG5cdFx0aW5wdXRCaXRQb3NpdGlvbnM6IFwiQml0IGRpIGlucHV0XCIsXG5cdFx0b3V0cHV0Qml0UG9zaXRpb25zOiBcIkJpdCBkaSBvdXRwdXRcIixcblx0XHRkaXN0YW5jZVR5cGVOYW1lOiBcIlRpcG8gZGkgZGlzdGFuemFcIixcblx0XHRiYXJyaWVyRGF0YU5hbWU6IFwiQmFycmllcmUgcmFzdGVyXCIsXG5cdFx0cG91clBvaW50RGF0YU5hbWU6IFwiUmFzdGVyIFBvdXIgUG9pbnRcIixcblx0XHRhY2N1bXVsYXRpb25SYXN0ZXJOYW1lOiBcIlJhc3RlciBkaSBhY2N1bXVsbyBmbHVzc29cIixcblx0XHRzbmFwRGlzdGFuY2VOYW1lOiBcIkRpc3RhbnphIHNuYXBcIixcblx0XHRvcmRlck1ldGhvZE5hbWU6IFwiTWV0b2RvIGRpIG9yZGluYW1lbnRvXCIsXG5cdFx0ZGlyZWN0aW9uTWVhc3VyZW1lbnROYW1lOiBcIkRpcmV6aW9uZSBkaSBtaXN1cmFcIixcblx0XHRwcm9jZXNzQXNNdWx0aWJhbmQ6IFwiRWxhYm9yYSBjb21lIG11bHRpYmFuZGFcIixcblx0XHRwcm9jZXNzTXVsdGlkaW1lbnNpb25hbDogXCJFbGFib3JhIGNvbWUgbXVsdGlkaW1lbnNpb25hbGVcIixcblx0XHRmb3JjZUZsb3dEaXJlY3Rpb25Db252ZW50aW9uOiBcIkZvcnphcmUgbGEgY29udmVuemlvbmUgZGVsbGEgZGlyZXppb25lIGRlbCBmbHVzc28gcGVyIGlsIHJhc3RlciBiYWNrbGlua1wiLFxuXHRcdGluaXRpYWxBY2N1bXVsYXRpb246IFwiQWNjdW11bG8gaW5pemlhbGVcIixcblx0XHRtYXhpbXVtQWNjdW11bGF0aW9uOiBcIkFjY3VtdWxvIG1hc3NpbW9cIixcblx0XHRzb3VyY2VMb2NhdGlvbkJhbmRzOiBcIkdlbmVyYXJlIHJpZ2hlIGUgY29sb25uZSBkaSBvcmlnaW5lIGNvbWUgYmFuZGUgYWdnaXVudGl2ZSBuZWxsJ291dHB1dFwiLFxuXHRcdGJhY2tEaXJlY3Rpb25CYW5kOiBcIkdlbmVyYXJlIGxhIGRpcmV6aW9uZSBpbnZlcnNhIGNvbWUgYmFuZGEgYWdnaXVudGl2YSBuZWxsJ291dHB1dFwiLFxuXHRcdG51bWJlck9mQ2VsbHM6IFwiTnVtZXJvIGRpIGNlbGxlXCIsXG5cdFx0em9uZVZhbHVlczogXCJWYWxvcmkgem9uYVwiLFxuXHRcdHNocmlua01ldGhvZDogXCJNZXRvZG8gZGkgcmlkdXppb25lXCIsXG5cdFx0ZXhwYW5kTWV0aG9kOiBcIk1ldG9kbyBkaSBlc3BhbnNpb25lXCIsXG5cdFx0aW5wdXRTcGVjdHJhbFByb2ZpbGVUeXBlOiBcIlRpcG8gZGkgcHJvZmlsbyBzcGV0dHJhbGVcIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlTmFtZTogXCJQcm9maWxvIHNwZXR0cmFsZVwiLFxuXHRcdHRyYWluaW5nRmVhdHVyZUZpbGVOYW1lOiBcIkZlYXR1cmUgZGkgZm9ybWF6aW9uZVwiLFxuXHRcdG5vbk5lZ2F0aXZlOiBcIk5vbiBuZWdhdGl2b1wiLFxuXHRcdHN1bVRvT25lOiBcIlNvbW1hIGEgdW5vXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uOiBcIkRpc3RyaWJ1emlvbmVcIixcblx0XHRtZWFuTmFtZTogXCJNZWRpb1wiLFxuXHRcdHByb2JhYmlsaXR5TmFtZTogXCJQcm9iYWJpbGl0w6BcIixcblx0XHRhbHBoYU5hbWU6IFwiQWxmYVwiLFxuXHRcdGJldGFOYW1lOiBcIkJldGFcIixcblx0XHRyTmFtZTogXCJyXCIsXG5cdFx0bk5hbWU6IFwiTlwiLFxuXHRcdHNlZWQ6IFwiU2VtZVwiLFxuXHRcdHJhbmRvbU51bWJlckdlbmVyYXRvcjogXCJHZW5lcmF0b3JlIGRpIE51bWVybyBSYW5kb21cIixcblx0XHRjZWxsRmFjdG9yOiBcIkZhdHRvcmUgY2VsbGFcIixcblx0XHRhZ2dyZWdhdGlvblR5cGU6IFwiVGVjbmljYSBkaSBhZ2dyZWdhemlvbmVcIixcblx0XHRleHRlbnRIYW5kbGluZzogXCJFc3BhbmRpIGV4dGVudCBzZSBuZWNlc3NhcmlvXCIsXG5cdFx0dHJlbmRBbmFseXNpc0RpbWVuc2lvbk5hbWU6IFwiTm9tZSBkaW1lbnNpb25lXCIsXG5cdFx0dHJlbmRBbmFseXNpc1R5cGU6IFwiVGlwbyBkaSB0ZW5kZW56YVwiLFxuXHRcdGhhcm1vbmljRnJlcXVlbmN5OiBcIkZyZXF1ZW56YSBhcm1vbmljYVwiLFxuXHRcdHBvbHlub21pYWxPcmRlcjogXCJPcmRpbmUgcG9saW5vbWlhbGVcIixcblx0XHRjeWNsZUxlbmd0aE5hbWU6IFwiTHVuZ2hlenphIGRlbCBjaWNsb1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNSTVNFOiBcIlJNU0VcIixcblx0XHR0cmVuZEFuYWx5c2lzUjI6IFwiUi1TcXVhcmVkXCIsXG5cdFx0dHJlbmRBbmFseXNpc1Nsb3BlUFZhbHVlOiBcIlZhbG9yZSBQIGRlbCBjb2VmZmljaWVudGUgZGkgcGVuZGVuemFcIixcblx0XHR0cmVuZEFuYWx5c2lzU2Vhc29uYWxQZXJpb2Q6IFwiUGVyaW9kbyBzdGFnaW9uYWxlXCIsXG5cdFx0Y3ljbGVVbml0TmFtZTogXCJVbml0w6AgY2ljbG9cIixcblx0XHRwcmVkaWN0RGltZW5zaW9uVmFsdWVzOiBcIlZhbG9yaVwiLFxuXHRcdGRpbWVuc2lvbkRlZmluaXRpb25UeXBlOiBcIkRlZmluaXppb25lIGRpbWVuc2lvbmVcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uU3RhcnQ6IFwiUGFydGVuemFcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uRW5kOiBcIkZpbmVcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uSW50ZXJ2YWw6IFwiSW50ZXJ2YWxsbyBkZWwgdmFsb3JlXCIsXG5cdFx0ZGltZW5zaW9uVW5pdDogXCJVbml0w6BcIixcblx0XHRpbnRlcnBvbGF0aW9uQ2VsbHNpemVOYW1lOiBcIkRpbWVuc2lvbmUgZGVsbGEgY2VsbGEgZGkgaW50ZXJwb2xhemlvbmVcIixcblx0XHR2YXJpYWJsZU5hbWU6IFwiVmFyaWFiaWxpXCIsXG5cdFx0ZGltZW5zaW9ubGVzc05hbWU6IFwiU2VuemEgZGltZW5zaW9uaVwiLFxuXHRcdG1kaW1EZWZpbml0aW9uOiBcIkRlZmluaXppb25lIGRpbWVuc2lvbmVcIixcblx0XHRkaW1lbnNpb25OYW1lOiBcIkRpbWVuc2lvbmVcIixcblx0XHRpdGVyYXRpb25TdGFydDogXCJJbml6aW8gZGVsbGEgcHJpbWEgaXRlcmF6aW9uZVwiLFxuXHRcdGl0ZXJhdGlvbkVuZDogXCJGaW5lIGRlbGxhIHByaW1hIGl0ZXJhemlvbmVcIixcblx0XHRpbnRlcnZhbFN0YXJ0OiBcIkluaXppbyBkZWxsJ2ludGVydmFsbG9cIixcblx0XHRpbnRlcnZhbEVuZDogXCJGaW5lIGRlbGwnaW50ZXJ2YWxsb1wiLFxuXHRcdHN0ZXBOYW1lOiBcIkZhc2VcIixcblx0XHRyYW5nZXNOYW1lOiBcIkludGVydmFsbGlcIixcblx0XHRtaW5WYWx1ZTogXCJWYWxvcmUgbWluaW1vXCIsXG5cdFx0bWF4VmFsdWU6IFwiVmFsb3JlIG1hc3NpbW9cIixcblx0XHRjaGFuZ2VBbmFseXNpc1Jhc3Rlck5hbWU6IFwiUmFzdGVyIGRpIGFuYWxpc2kgbW9kaWZpY2FcIixcblx0XHRjaGFuZ2VUeXBlTmFtZTogXCJNb2RpZmljYXJlIHRpcG9cIixcblx0XHRzZWdtZW50RGF0ZTogXCJEYXRhIHNlZ21lbnRvXCIsXG5cdFx0Y2hhbmdlRGlyZWN0aW9uTmFtZTogXCJNb2RpZmljYSBkaXJlemlvbmVcIixcblx0XHRtYXhOdW1DaGFuZ2VzTmFtZTogXCJOdW1lcm8gbWFzc2ltbyBkaSBtb2RpZmljaGVcIixcblx0XHRmaWx0ZXJCeVllYXI6IFwiRmlsdHJhIHBlciBhbm5vXCIsXG5cdFx0bWluaW11bVllYXI6IFwiVmFsb3JlIG1pbmltb1wiLFxuXHRcdG1heGltdW1ZZWFyOiBcIlZhbG9yZSBNYXNzaW1vXCIsXG5cdFx0ZmlsdGVyQnlEdXJhdGlvbjogXCJGaWx0cmEgcGVyIGR1cmF0YVwiLFxuXHRcdG1pbmltdW1EdXJhdGlvbjogXCJEdXJhdGEgbWluaW1hXCIsXG5cdFx0bWF4aW11bUR1cmF0aW9uOiBcIkR1cmF0YSBtYXNzaW1hXCIsXG5cdFx0ZmlsdGVyQnlNYWduaXR1ZGU6IFwiRmlsdHJhIHBlciBncmFuZGV6emFcIixcblx0XHRtaW5pbXVtTWFnbml0dWRlOiBcIkdyYW5kZXp6YSBtaW5pbWFcIixcblx0XHRtYXhpbXVtTWFnbml0dWRlOiBcIkdyYW5kZXp6YSBtYXNzaW1hXCIsXG5cdFx0ZmlsdGVyQnlTdGFydFZhbHVlOiBcIkZpbHRyYSBkYSB2YWxvcmUgaW5pemlhbGVcIixcblx0XHRtaW5pbXVtU3RhcnRWYWx1ZTogXCJNaW5pbW8gdmFsb3JlIGluaXppYWxlXCIsXG5cdFx0bWF4aW11bVN0YXJ0VmFsdWU6IFwiTWFzc2ltbyB2YWxvcmUgaW5pemlhbGVcIixcblx0XHRmaWx0ZXJCeUVuZFZhbHVlOiBcIkZpbHRyYSBkYSB2YWxvcmUgZmluYWxlXCIsXG5cdFx0bWluaW11bUVuZFZhbHVlOiBcIk1pbmltbyB2YWxvcmUgZmluYWxlXCIsXG5cdFx0bWF4aW11bUVuZFZhbHVlOiBcIk1hc3NpbW8gdmFsb3JlIGZpbmFsZVwiLFxuXHRcdG1vZGVsVHlwZU5hbWU6IFwiVGlwbyBkaSBtb2RlbGxvXCIsXG5cdFx0ZnJvbVJhc3Rlck5hbWU6IFwiRGEgcmFzdGVyXCIsXG5cdFx0dG9SYXN0ZXJOYW1lOiBcIkEgUmFzdGVyXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZU1ldGhvZDogXCJDYWxjb2xhIG1ldG9kbyB2YXJpYXppb25lXCIsXG5cdFx0ZnJvbUNsYXNzVmFsdWVzOiBcIlZhbG9yaSBEYSBjbGFzc2UgKEVzZW1waTogMiA1KVwiLFxuXHRcdHRvQ2xhc3NWYWx1ZXM6IFwiVmFsb3JpIEEgY2xhc3NlIChFc2VtcGk6IDIgNSlcIixcblx0XHRrZWVwTWV0aG9kOiBcIk1ldG9kbyBkaSBmaWx0cm9cIixcblx0XHR1c2VDb2xvck1ldGhvZDogXCJEZWZpbmlzY2kgY29sb3JpIGRpIHRyYW5zaXppb25lXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlQmFuZHM6IFwiQmFuZGUgcGVyIHJpbGV2YXJlIGlsIGNhbWJpYW1lbnRvIChpbml6aWEgYSAwKVwiLFxuXHRcdHRtYXNrQmFuZHM6IFwiQmFuZGUgcGVyIGlsIG1hc2NoZXJhbWVudG8gdGVtcG9yYW5lbyAoaW5pemlhIGEgMClcIixcblx0XHRjaGlTcXVhcmVkVGhyZXNob2xkOiBcIlNvZ2xpYSBjaGktcXVhZHJhdG8gcGVyIHJpbGV2YXJlIG1vZGlmaWNoZVwiLFxuXHRcdG1pbkFub21hbHk6IFwiT3NzZXJ2YXppb25pIGRpIGFub21hbGllIGNvbnNlY3V0aXZlIG1pbmltZVwiLFxuXHRcdHVwZGF0aW5nRnJlcXVlbmN5OiBcIkFnZ2lvcm5hbWVudG8gZGVsbGEgZnJlcXVlbnphIGRpIGFkYXR0YW1lbnRvIChpbiBhbm5pKVwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGkgYWNjdW11bG8gZGVsbGEgZGlzdGFuemFcIixcblx0XHRjb3N0QmFja2RpcmVjdGlvblJhc3Rlck5hbWU6IFwiRGlyZXppb25lIGJhY2sgbyByYXN0ZXIgZGkgZGlyZXppb25lIGRlbCBmbHVzc29cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uTmFtZTogXCJSYWNjb2x0YSBkaSByYXN0ZXJcIixcblx0XHRpdGVtRnVuY3Rpb25OYW1lOiBcIkZ1bnppb25lIGVsZW1lbnRvXCIsXG5cdFx0YWdncmVnYXRpb25GdW5jdGlvbk5hbWU6IFwiRnVuemlvbmUgZGkgYWdncmVnYXppb25lXCIsXG5cdFx0cHJvY2Vzc2luZ0Z1bmN0aW9uTmFtZTogXCJGdW56aW9uZSBkaSBlbGFib3JhemlvbmVcIixcblx0XHRhZ2dyZWdhdGlvbkRlZmluaXRpb25OYW1lOiBcIkRlZmluaXppb25lIGFnZ3JlZ2F6aW9uZVwiLFxuXHRcdHF1ZXJ5R2VvbWV0cnlOYW1lOiBcIkludGVycm9nYSBnZW9tZXRyaWFcIixcblx0XHRmYWN0b3JGdW5jdGlvblplcm9GYWN0b3I6IFwiRmF0dG9yZSBaZXJvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25DdXRBbmdsZTogXCJBbmdvbG8gZGkgdGFnbGlvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TaWRlRmFjdG9yOiBcIkZhdHRvcmUgbGF0ZXJhbGVcIixcblx0XHRmYWN0b3JGdW5jdGlvblNsb3BlOiBcIkFjY2xpdml0w6BcIixcblx0XHRmYWN0b3JGdW5jdGlvbkxvd0N1dEFuZ2xlOiBcIkFuZ29sbyBkaSB0YWdsaW8gYmFzc29cIixcblx0XHRmYWN0b3JGdW5jdGlvbkhpZ2hDdXRBbmdsZTogXCJBbmdvbG8gZGkgdGFnbGlvIGFsdG9cIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvc1Bvd2VyOiBcIlBvdGVuemEgY29zZW5vXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWNQb3dlcjogXCJQb3RlbnphIHNlY2FudGVcIixcblx0XHRmYWN0b3JGdW5jdGlvblRhYmxlUGF0aDogXCJQZXJjb3JzbyB0YWJlbGxhXCIsXG5cdFx0cHJvY2Vzc2luZ0JhbmQ6IFwiQmFuZGEgZGkgZWxhYm9yYXppb25lXCIsXG5cdFx0cHJvY2Vzc2luZ0JhbmROYW1lOiBcIk5vbWUgZGVsbGEgQmFuZGEgaW4gRWxhYm9yYXppb25lXCIsXG5cdFx0c25hcHBpbmdEYXRlOiBcIkRhdGEgZ2VzdGlvbmUgZGVsbGUgdG9sbGVyYW56ZVwiLFxuXHRcdG1heE51bVNlZ21lbnRzOiBcIk51bWVybyBtYXNzaW1vIGRpIHNlZ21lbnRpXCIsXG5cdFx0dmVydGV4Q291bnRPdmVyc2hvb3Q6IFwiQ29udGVnZ2lvIHZlcnRpY2kgaW4gZWNjZXNzb1wiLFxuXHRcdHNwaWtlVGhyZXNob2xkOiBcIlNvZ2xpYSBTcGlrZVwiLFxuXHRcdHJlY292ZXJ5VGhyZXNob2xkOiBcIlNvZ2xpYSBSZWN1cGVyb1wiLFxuXHRcdG1pbk51bU9iczogXCJOdW1lcm8gbWluaW1vIGRpIG9zc2VydmF6aW9uaVwiLFxuXHRcdHBWYWx1ZVRocmVzaG9sZDogXCJTb2dsaWEgZGkgdmFsb3JlIFBcIixcblx0XHRiZXN0TW9kZWxQcm9wb3J0aW9uOiBcIk1pZ2xpb3JlIHByb3Bvcnppb25lIGRlbCBtb2RlbGxvXCIsXG5cdFx0cHJldmVudE9uZVllYXJSZWNvdmVyeTogXCJQcmV2aWVuaSByZWN1cGVybyBkaSB1biBhbm5vXCIsXG5cdFx0cmVjb3ZlcnlJbmNyZWFzZVRyZW5kOiBcIklsIHJlY3VwZXJvIGhhIGF1bWVudGF0byBsYSB0ZW5kZW56YVwiLFxuXHRcdG91dHB1dE90aGVyQmFuZHM6IFwiRW1ldHRpIGFsdHJlIGJhbmRlXCIsXG5cdFx0c29ydFR5cGU6IFwiVGlwbyBkaSBvcmRpbmFtZW50b1wiLFxuXHRcdG51bWJlck9mUnVuczogXCJFc2VndWkgZHVlIHZvbHRlIGVzcGFuc2lvbmUgZSBjb250cmF6aW9uZVwiLFxuXHRcdHBlcmNlbnRpbGVWYWx1ZTogXCJWYWxvcmUgcGVyY2VudGlsZVwiLFxuXHRcdHBlcmNlbnRpbGVJbnRlcnBvbGF0aW9uVHlwZTogXCJUaXBvIGRpIGludGVycG9sYXppb25lIHBlcmNlbnRpbGVcIixcblx0XHRyYXN0ZXJJbmZvUHJvcGVydHk6IFwiUHJvcHJpZXTDoFwiLFxuXHRcdHJhc3RlckluZm9WYWx1ZTogXCJWYWxvcmVcIixcblx0XHRyYXN0ZXJJbmZvQ29sdW1uczogXCJDb2xvbm5lXCIsXG5cdFx0cmFzdGVySW5mb1Jvd3M6IFwiUmlnaGVcIixcblx0XHRyYXN0ZXJJbmZvQmFuZENvdW50OiBcIk51bWVybyBkaSBiYW5kZVwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFNpemVYOiBcIkRpbWVuc2lvbmUgY2VsbGEgWFwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFNpemVZOiBcIkRpbWVuc2lvbmUgY2VsbGEgWVwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFR5cGU6IFwiVGlwbyBwaXhlbFwiLFxuXHRcdHJhc3RlckV4dGVudFRvcDogXCJJbiBhbHRvXCIsXG5cdFx0cmFzdGVyRXh0ZW50Qm90dG9tOiBcIkluIGJhc3NvXCIsXG5cdFx0cmFzdGVyRXh0ZW50TGVmdDogXCJTaW5pc3RyYVwiLFxuXHRcdHJhc3RlckV4dGVudFJpZ2h0OiBcIkRlc3RyYVwiLFxuXHRcdHJhc3RlclN0YXRpc3RpY3NOb3RDYWxjdWxhdGVkOiBcIkxlIHN0YXRpc3RpY2hlIG5vbiBzb25vIHN0YXRlIGNhbGNvbGF0ZS5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlUHJvamVjdGlvbjogXCJQcm9pZXppb25lXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVdraWQ6IFwiV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRlc3RXa2lkOiBcIldLSUQgcHJlY2VkZW50ZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa3Q6IFwiV0tUXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVZjc1draWQ6IFwiVkNTV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRlc3RWY3NXa2lkOiBcIlZDU1dLSUQgcHJlY2VkZW50ZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBdXRob3JpdHk6IFwiQXV0b3JpdMOgXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxpbmVhclVuaXQ6IFwiVW5pdMOgIExpbmVhcmVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQW5ndWxhclVuaXQ6IFwiVW5pdMOgIGFuZ29sYXJlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUZhbHNlRWFzdGluZzogXCJEaXJlemlvbmUgZXN0IGZhbHNhXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUZhbHNlTm9ydGhpbmc6IFwiRGlyZXppb25lIG5vcmQgZmFsc2FcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQ2VudHJhbE1lcmlkaWFuOiBcIk1lcmlkaWFubyBkaSByaWZlcmltZW50b1wiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VQcmltZU1lcmlkaWFuOiBcIlByaW1vIG1lcmlkaWFub1wiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTdGFuZGFyZFBhcmFsbGVsMTogXCJQYXJhbGxlbG8gc3RhbmRhcmQgMVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTdGFuZGFyZFBhcmFsbGVsMjogXCJQYXJhbGxlbG8gc3RhbmRhcmQgMlwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRpdHVkZU9mT3JpZ2luOiBcIkxhdGl0dWRpbmUgZGkgb3JpZ2luZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBdXhpbGlhcnlTcGhlcmVUeXBlOiBcIlRpcG8gZGkgc2ZlcmEgYXVzaWxpYXJlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZURhdHVtOiBcIlJpZmVyaW1lbnRvXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNwaGVyb2lkOiBcIlNmZXJvaWRlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNlbWltYWpvckF4aXM6IFwiU2VtaWFzc2UgcHJpbmNpcGFsZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTZW1pbWlub3JBeGlzOiBcIlNlbWlhc3NlIHNlY29uZGFyaW9cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlSW52ZXJzZUZsYXR0ZW5pbmc6IFwiTGl2ZWxsYW1lbnRvIGludmVyc29cIixcblx0XHRpbnB1dERlZmluaXRpb25GaWxlTmFtZTogXCJGaWxlIGRpIGRlZmluaXppb25lIGRpIGlucHV0XCIsXG5cdFx0ZGVsZXRlTmFtZTogXCJFbGltaW5hXCIsXG5cdFx0YWRkVmFyaWFibGVOYW1lOiBcIkFnZ2l1bmdpIHZhcmlhYmlsZVwiLFxuXHRcdG1heE51bVBpeGVsc1BlclNlZ21lbnQ6IFwiRGltZW5zaW9uZSBtYXNzaW1hIHNlZ21lbnRpIGluIHBpeGVsXCIsXG5cdFx0Zm9yd2FyZFdpbmRvd05hbWU6IFwiRmluZXN0cmEgYXZhbnRpXCIsXG5cdFx0YmFja3dhcmRXaW5kb3dOYW1lOiBcIkZpbmVzdHJhIGluZGlldHJvXCIsXG5cdFx0bm9EYXRhSGFuZGxpbmdOYW1lOiBcIkdlc3Rpb25lIE5vRGF0YVwiLFxuXHRcdGNpcmN1bGFyV3JhcFZhbHVlTmFtZTogXCJWYWxvcmUgd3JhcCBjaXJjb2xhcmVcIixcblx0XHRmcm9tQ2xhc3NOYW1lRmllbGROYW1lOiBcIk5vbWUgZGVsIGNhbXBvIHBlciBpIG5vbWkgZGVsbGUgY2xhc3NpIGluIGRhIHJhc3RlclwiLFxuXHRcdHRvQ2xhc3NOYW1lRmllbGROYW1lOiBcIk5vbWUgZGVsIGNhbXBvIHBlciBpIG5vbWkgZGVsbGUgY2xhc3NpIGluIFJhc3RlclwiLFxuXHRcdHRhcmdldFJhc3Rlck5hbWU6IFwiUmFzdGVyIGRpIGRlc3RpbmF6aW9uZVwiLFxuXHRcdGNpcmN1bGFyV3JhcFZhbHVlOiBcIlZhbG9yZSB3cmFwIGNpcmNvbGFyZVwiLFxuXHRcdGJhbmRJbmRleGVzUjogXCJFc3ByZXNzaW9uZSByb3Nzb1wiLFxuXHRcdGJhbmRJbmRleGVzRzogXCJFc3ByZXNzaW9uZSB2ZXJkZVwiLFxuXHRcdGJhbmRJbmRleGVzQjogXCJFc3ByZXNzaW9uZSBibHVcIixcblx0XHRleGFtcGxlTmFtZTogXCJFc2VtcGlvXCIsXG5cdFx0aW5wdXROYW1lOiBcIklucHV0XCIsXG5cdFx0b3V0cHV0TmFtZTogXCJPdXRwdXRcIixcblx0XHRvcHRpb25hbE5hbWU6IFwiT3B6aW9uYWxlXCIsXG5cdFx0YnJvd3NlRGVmaW5pdGlvbkZpbGU6IFwiQ2VyY2EgZmlsZSBkZWZpbml6aW9uZVwiLFxuXHRcdHNlbGVjdERlZmluaXRpb25GaWxlOiBcIlNlbGV6aW9uYSBmaWxlIGRlZmluaXppb25lIGlucHV0XCIsXG5cdFx0aW5wdXREZWZpbml0aW9uVVJMOiBcIkluc2VyaXNjaSBVUkwgZmlsZSBkZWZpbml6aW9uZVwiLFxuXHRcdGVudGVyRGVmaW5pdGlvbkZpbGVVUkw6IFwiSW5zZXJpc2NpIFVSTCBmaWxlIGRlZmluaXppb25lXCIsXG5cdFx0YnJvd3NlWE1MRmlsZTogXCJDZXJjYSBmaWxlIFhNTFwiLFxuXHRcdHNlbGVjdFN0YXRzRmlsZTogXCJTZWxlemlvbmEgZmlsZSBkaSBzdGF0aXN0aWNoZSBlIGlzdG9ncmFtbWlcIixcblx0XHRlbnRlclhNTEZpbGVVUkw6IFwiSW5zZXJpc2NpIFVSTCBmaWxlIFhNTFwiLFxuXHRcdHhtbEZpbGVVUkw6IFwiVVJMIGZpbGUgWE1MXCIsXG5cdFx0Y2lyY3VsYXJDYWxjdWxhdGlvbjogXCJDYWxjb2xhIHN0YXRpc3RpY2hlIGNpcmNvbGFyaVwiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGU6IFwiSW5kaXZpZHVhIHRpcG8gZGkgc3VwZXJmaWNpZVwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJUeXBlOiBcIlRpcG8gZGkgcGFyYW1ldHJvXCIsXG5cdFx0bmVpZ2hib3Job29kRGlzdGFuY2U6IFwiRGlzdGFuemEgcXVhcnRpZXJlXCIsXG5cdFx0dXNlQWRhcHRpdmVOZWlnaGJvcmhvb2Q6IFwiVXNhIHF1YXJ0aWVyZSBhZGF0dGl2b1wiLFxuXHRcdG91dHB1dFNsb3BlVHlwZTogXCJPdXRwdXQgbWlzdXJhemlvbmUgcGVuZGVuemFcIixcblx0XHRwcm9qZWN0QXppbXV0aHM6IFwiUHJvaWV0dGEgYXppbXV0IGdlb2RldGljaVwiLFxuXHRcdHVzZUVxdWF0b3JpYWxBc3BlY3Q6IFwiVXNhIGFzcGV0dG8gZXF1YXRvcmlhbGVcIixcblx0XHR6VW5pdDogXCJVbml0w6AgWlwiLFxuXHRcdGFuYWx5c2lzTWFzazogXCJNYXNjaGVyYSBhbmFsaXNpXCIsXG5cdFx0c3RkRGV2aWF0aW9uOiBcIkRldmlhemlvbmUgc3RhbmRhcmRcIixcblx0XHRcInRydWVcIjogXCJUcnVlXCIsXG5cdFx0XCJmYWxzZVwiOiBcIkZhbHNlXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMTogXCJJbW1ldHRpIHJhc3RlciBkaXN0YW56YSBkaSBjb3N0byBjdW11bGF0aXZvIDFcIixcblx0XHRjb3N0RGlzdGFuY2VSYXN0ZXIyOiBcIkltbWV0dGkgcmFzdGVyIGRpc3RhbnphIGRpIGNvc3RvIGN1bXVsYXRpdm8gMlwiLFxuXHRcdHRocmVzaG9sZDogXCJTb2dsaWFcIixcblx0XHR0aHJlc2hvbGRNZXRob2Q6IFwiTWV0b2RvIGRpIHNvZ2xpYVwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjE6IFwiSW1tZXR0aSByYXN0ZXIgZGkgZGlyZXppb25lIGludmVyc2EgMVwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjI6IFwiSW1tZXR0aSByYXN0ZXIgZGkgZGlyZXppb25lIGludmVyc2EgMlwiLFxuXHRcdG1heEl0ZXJhdGlvbnM6IFwiTnVtZXJvIG1hc3NpbW8gZGkgaXRlcmF6aW9uaVwiLFxuXHRcdGVwc2lsb246IFwiRXBzaWxvblwiXG5cdH0sXG5cdGVudW1MYWJlbHM6IHtcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVNYW51YWw6IFwiTWFudWFsZVwiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZUV4dGVybmFsOiBcIkVzdGVybm9cIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JtYXA6IFwiQ29sb3JtYXBcIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JSYW1wOiBcIlNjYWxhIGNyb21hdGljYVwiLFxuXHRcdGNvbG9ybWFwVHlwZUVsZXZhdGlvbjogXCJFbGV2YXppb25lXCIsXG5cdFx0Y29sb3JtYXBUeXBlR3JheTogXCJHcmlnaW9cIixcblx0XHRjb2xvcm1hcFR5cGVORFZJOiBcIk5EVklcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJMjogXCJORFZJMlwiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkkzOiBcIk5EVkkzXCIsXG5cdFx0Y29sb3JtYXBUeXBlUmFuZG9tOiBcIkNhc3VhbGlcIixcblx0XHRub25lOiBcIk5lc3N1bmFcIixcblx0XHRzbG9wZVR5cGVBZGp1c3RlZDogXCJSZWdvbGF0b1wiLFxuXHRcdHNsb3BlVHlwZURlZ3JlZTogXCJHcmFkaVwiLFxuXHRcdHNsb3BlVHlwZVBlcmNlbnRSaXNlOiBcIkluY3JlbWVudG8gcGVyY2VudHVhbGVcIixcblx0XHRzbG9wZVR5cGVTY2FsZWQ6IFwiU2NhbGF0b1wiLFxuXHRcdHN0cmV0Y2hUeXBlTWluTWF4OiBcIk1pbk1heFwiLFxuXHRcdHN0cmV0Y2hUeXBlUGVyY2VudE1pbk1heDogXCJQZXJjZW50TWluTWF4XCIsXG5cdFx0c3RyZXRjaFR5cGVTaWdtb2lkOiBcIlNpZ21vaWRlXCIsXG5cdFx0c3RyZXRjaFR5cGVTdGREZXY6IFwiU3RkRGV2XCIsXG5cdFx0aGlsbHNoYWRlVHlwZVNpbXBsZTogXCJUcmFkaXppb25hbGVcIixcblx0XHRoaWxsc2hhZGVUeXBlTXVsdGlkaXJlY3Rpb25hbDogXCJNdWx0aWRpcmV6aW9uYWxlXCIsXG5cdFx0YmFuZENvbWJvQnlOYW1lczogXCJOb21pIGJhbmRlXCIsXG5cdFx0YmFuZENvbWJvQnlXYXZlbGVuZ3RoOiBcIkx1bmdoZXp6ZSBkJ29uZGEgYmFuZGVcIixcblx0XHRiYW5kQ29tYm9CeUlEczogXCJJRCBiYW5kZVwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uQmVzdE1hdGNoOiBcIkNvcnJpc3BvbmRlbnphIG1pZ2xpb3JlXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25GYWlsOiBcIkVycm9yZVwiLFxuXHRcdHVuaXRUeXBlQ2Vsc2l1czogXCJDZWxzaXVzXCIsXG5cdFx0dW5pdFR5cGVDZW50aW1ldGVyczogXCJDZW50aW1ldHJpXCIsXG5cdFx0dW5pdFR5cGVEZWNpbWV0ZXJzOiBcIkRlY2ltZXRyaVwiLFxuXHRcdHVuaXRUeXBlRmFocmVuaGVpdDogXCJGYWhyZW5oZWl0XCIsXG5cdFx0dW5pdFR5cGVGZWV0OiBcIlBpZWRpXCIsXG5cdFx0dW5pdFR5cGVGZWV0UGVyU2VjOiBcIlBpZWRpIGFsIHNlY29uZG8gKGZ0L3MpXCIsXG5cdFx0dW5pdFR5cGVJbmNoZXM6IFwiUG9sbGljaVwiLFxuXHRcdHVuaXRUeXBlS2VsdmluOiBcIktlbHZpblwiLFxuXHRcdHVuaXRUeXBlS2lsb21ldGVyczogXCJDaGlsb21ldHJpXCIsXG5cdFx0dW5pdFR5cGVLbXNQZXJIb3VyOiBcIkNoaWxvbWV0cmkgYWxsJ29yYSAoa20vaClcIixcblx0XHR1bml0VHlwZUtub3RzOiBcIk5vZGkgKGtuKVwiLFxuXHRcdHVuaXRUeXBlTWV0ZXJzOiBcIk1ldHJpXCIsXG5cdFx0dW5pdFR5cGVNZXRlcnNQZXJTZWM6IFwiTWV0cmkgYWwgc2Vjb25kbyAobS9zKVwiLFxuXHRcdHVuaXRUeXBlTWlsZXM6IFwiTWlnbGlhXCIsXG5cdFx0dW5pdFR5cGVNaWxlc1BlckhvdXI6IFwiTWlnbGlhIGFsbCdvcmEgKG1waClcIixcblx0XHR1bml0VHlwZU1pbGxpbWV0ZXJzOiBcIk1pbGxpbWV0cmlcIixcblx0XHR1bml0VHlwZU5hdXRpY2FsTWlsZXM6IFwiTWlnbGlhIG5hdXRpY2hlXCIsXG5cdFx0dW5pdFR5cGVZYXJkczogXCJJYXJkZVwiLFxuXHRcdHVuaXRUeXBlRGVjaW1hbERlZ3JlZXM6IFwiR3JhZGkgZGVjaW1hbGlcIixcblx0XHR1bml0VHlwZVBvaW50czogXCJQdW50aVwiLFxuXHRcdHVuaXRUeXBlVW5rbm93bjogXCJTY29ub3NjaXV0b1wiLFxuXHRcdHVuaXRUeXBlU3FNYXBVbml0czogXCJVbml0w6AgZGkgbWFwcGEgcXVhZHJhdGVcIixcblx0XHR1bml0VHlwZVNxTWlsZXM6IFwiTWlnbGlhIHF1YWRyYXRlXCIsXG5cdFx0dW5pdFR5cGVTcUttczogXCJDaGlsb21ldHJpIHF1YWRyYXRpXCIsXG5cdFx0dW5pdFR5cGVBY3JlczogXCJBY3JpXCIsXG5cdFx0dW5pdFR5cGVIZWN0YXJlczogXCJFdHRhcmlcIixcblx0XHR1bml0VHlwZVNxWWFyZHM6IFwiU3F1YXJlIFlhcmRzXCIsXG5cdFx0dW5pdFR5cGVTcUZ0OiBcIlBpZWRpIHF1YWRyYXRpXCIsXG5cdFx0dW5pdFR5cGVTcUluY2hlczogXCJQb2xsaWNpIHF1YWRyYXRpXCIsXG5cdFx0dW5pdFR5cGVTcU10czogXCJNZXRyaSBxdWFkcmF0aVwiLFxuXHRcdHVuaXRUeXBlU3FDbXM6IFwiQ2VudGltZXRyaSBxdWFkcmF0aVwiLFxuXHRcdHVuaXRUeXBlU3FNbXM6IFwiTWlsbGltZXRyaSBxdWFkcmF0aVwiLFxuXHRcdGNlbGxzaXplVHlwZUZpcnN0OiBcIlByaW1vIGRpXCIsXG5cdFx0Y2VsbHNpemVUeXBlTWluOiBcIk1pbiBkaVwiLFxuXHRcdGNlbGxzaXplVHlwZU1heDogXCJNYXggZGlcIixcblx0XHRjZWxsc2l6ZVR5cGVNZWFuOiBcIk1lZGlhIGRpXCIsXG5cdFx0Y2VsbHNpemVUeXBlTGFzdDogXCJVbHRpbW8gZGlcIixcblx0XHRleHRlbnRUeXBlRmlyc3Q6IFwiUHJpbW8gZGlcIixcblx0XHRleHRlbnRUeXBlSW50ZXJzZWN0aW9uOiBcIkludGVyc2V6aW9uZSBkaVwiLFxuXHRcdGV4dGVudFR5cGVVbmlvbjogXCJVbmlvbmUgZGlcIixcblx0XHRleHRlbnRUeXBlTGFzdDogXCJVbHRpbW8gZGlcIixcblx0XHRub0RhdGFJbnRlcnByZXRBbnk6IFwiUXVhbHNpYXNpIGNvcnJpc3BvbmRlbnphXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QWxsOiBcIlR1dHRlIGxlIGNvcnJpc3BvbmRlbnplXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVN0YW5kYXJkOiBcIlN0YW5kYXJkXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVByb2ZpbGU6IFwiUHJvZmlsb1wiLFxuXHRcdGN1cnZhdHVyZVR5cGVQbGFuZm9ybTogXCJQbGFuZm9ybVwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uSG9yaXpvbnRhbDogXCJSaWxldmFtZW50byByaWdhIC0gT3JpenpvbnRhbGVcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvblZlcnRpY2FsOiBcIlJpbGV2YW1lbnRvIHJpZ2EgLSBWZXJ0aWNhbGVcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvbkxlZnREaWFnb25hbDogXCJSaWxldmFtZW50byByaWdhIC0gRGlhZ29uYWxlIHNpbmlzdHJhXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25SaWdodERpYWdvbmFsOiBcIlJpbGV2YW1lbnRvIHJpZ2EgLSBEaWFnb25hbGUgZGVzdHJhXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50Tm9ydGg6IFwiR3JhZGllbnRlIG5vcmRcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRXZXN0OiBcIkdyYWRpZW50ZSBvdmVzdFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudEVhc3Q6IFwiR3JhZGllbnRlIGVzdFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudFNvdXRoOiBcIkdyYWRpZW50ZSBzdWRcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aEVhc3Q6IFwiR3JhZGllbnRlIG5vcmQtZXN0XCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50Tm9ydGhXZXN0OiBcIkdyYWRpZW50ZSBub3JkLW92ZXN0XCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aEFyaXRobWV0aWNNZWFuOiBcIlNtb290aCBBcml0aG1ldGljIE1lYW5cIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoaW5nM3gzOiBcIlNtb290aGluZyAzeDNcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoaW5nNXg1OiBcIlNtb290aGluZyA1eDVcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbmluZzN4MzogXCJTaGFycGVuaW5nIDN4M1wiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuaW5nNXg1OiBcIlNoYXJwZW5pbmcgNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZUxhcGxhY2lhbjN4MzogXCJPcGVyYXRvcmUgbGFwbGFjaWFubyAzeDNcIixcblx0XHRmaWx0ZXJUeXBlTGFwbGFjaWFuNXg1OiBcIk9wZXJhdG9yZSBsYXBsYWNpYW5vIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbEhvcml6b250YWw6IFwiU29iZWwgb3JpenpvbnRhbGVcIixcblx0XHRmaWx0ZXJUeXBlU29iZWxWZXJ0aWNhbDogXCJTb2JlbCB2ZXJ0aWNhbGVcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbjogXCJBdW1lbnRhIG5pdGlkZXp6YVwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuMjogXCJBdW1lbnRhIHVsdGVyaW9ybWVudGUgbml0aWRlenphXCIsXG5cdFx0ZmlsdGVyVHlwZVBvaW50U3ByZWFkOiBcIkRpc3RyaWJ1emlvbmUgcHVudGlcIixcblx0XHR1c2VyRGVmaW5lZDogXCJEZWZpbml0byBkYWxsJ3V0ZW50ZVwiLFxuXHRcdENvbnRvdXJUeXBlTGluZXM6IFwiTGluZWUgZGkgY29udG9ybm9cIixcblx0XHRDb250b3VyVHlwZUZpbGw6IFwiUmllbXBpbWVudG8gY29udG9ybm9cIixcblx0XHRDb250b3VyVHlwZVNtb290aE9ubHk6IFwiU29sbyBzdXBlcmZpY2kgbGlzY2VcIixcblx0XHRyYXN0ZXJpemVGaXJzdDogXCJQcmltb1wiLFxuXHRcdHJhc3Rlcml6ZUxhc3Q6IFwiVWx0aW1vXCIsXG5cdFx0cmFzdGVyaXplU21hbGxlc3Q6IFwiUGnDuSBwaWNjb2xvXCIsXG5cdFx0cmFzdGVyaXplTGFyZ2VzdDogXCJQacO5IGdyYW5kZVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmVhcmVzdDogXCJWaWNpbm8gcGnDuSB2aWNpbm9cIixcblx0XHRyZXNhbXBsaW5nVHlwZUJpbGluZWFyOiBcIkludGVycG9sYXppb25lIGJpbGluZWFyZVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQ3ViaWM6IFwiQ29udm9sdXppb25lIGN1YmljYVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWFqb3JpdHk6IFwiTWFnZ2lvcmFuemFcIixcblx0XHRyZXNhbXBsaW5nVHlwZUJpbGluZWFyUGx1czogXCJJbnRlcnBvbGF6aW9uZSBiaWxpbmVhcmUgYXZhbnphdGFcIixcblx0XHRyZXNhbXBsaW5nVHlwZUdhdXNzOiBcIlNmb2NhdHVyYSBnYXVzc2lhbmFcIixcblx0XHRyZXNhbXBsaW5nVHlwZUdhdXNzUGx1czogXCJTZm9jYXR1cmEgZ2F1c3NpYW5hIGF2YW56YXRhXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVBdmVyYWdlOiBcIk1lZGlhXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNaW5pbXVtOiBcIk1pbmltb1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWF4aW11bTogXCJNYXNzaW1vXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVWZWN0b3JBdmc6IFwiTWVkaWEgdmV0dG9yaWFsZVwiLFxuXHRcdG1pbmltdW06IFwiTWluaW1vXCIsXG5cdFx0bWF4aW11bTogXCJNYXNzaW1vXCIsXG5cdFx0bWVhbjogXCJNZWRpb1wiLFxuXHRcdHN0ZERldmlhdGlvbjogXCJEZXZpYXppb25lIHN0YW5kYXJkXCIsXG5cdFx0dXZNYWdEaXJUeXBlVVY6IFwiVS1WXCIsXG5cdFx0dXZNYWdEaXJUeXBlTWFnRGlyOiBcIkdyYW5kZXp6YS1EaXJlemlvbmVcIixcblx0XHR1bmtub3duOiBcIlNjb25vc2NpdXRvXCIsXG5cdFx0YW5nbGVSZWZTeXNHZW9ncmFwaGljOiBcIkdlb2dyYWZpY29cIixcblx0XHRhbmdsZVJlZlN5c0FyaXRobWV0aWM6IFwiQXJpdG1ldGljb1wiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YU5lYXJlc3Q6IFwiVmljaW5vIHBpw7kgdmljaW5vXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhQmlsaW5lYXI6IFwiQmlsaW5lYXJlXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhVGlubmluZ0xpbmVhcjogXCJSaXZlc3RpbWVudG8gbGluZWFyZVwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdOYXR1cmFsTmVpZ2hib3I6IFwiVmljaW5vIE5hdHVyYWxlXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhVGlubmluZ0lEVzogXCJJbnZlcnNvIGRlbGxhIGRpc3RhbnphIHBlc2F0YVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlQ29uc3RhbnQ6IFwiQ29zdGFudGVcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZU90c3U6IFwiT3RzdVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlVHNhaTogXCJUc2FpXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVLYXB1cjogXCJLYXB1clwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlS2l0dGxlcjogXCJLaXR0bGVyXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVSb3NpbjogXCJSb3NpblwiLFxuXHRcdGFyZ1N0YXRzVHlwZU1heDogXCJBcmdNYXhcIixcblx0XHRhcmdTdGF0c1R5cGVNaW46IFwiQXJnTWluXCIsXG5cdFx0YXJnU3RhdHNUeXBlTWVkaWFuOiBcIkFyZ01lZGlhblwiLFxuXHRcdGFyZ1N0YXRzVHlwZUR1cmF0aW9uOiBcIkR1cmF0YVwiLFxuXHRcdGFyaXRobWV0aWNPcFBsdXM6IFwiUGx1c1wiLFxuXHRcdGFyaXRobWV0aWNPcE1pbnVzOiBcIk1pbnVzXCIsXG5cdFx0YXJpdGhtZXRpY09wTXVsdGlwbHk6IFwiTW9sdGlwbGljYXppb25lXCIsXG5cdFx0YXJpdGhtZXRpY09wRGl2aWRlOiBcIkRpdmlkZVwiLFxuXHRcdGFyaXRobWV0aWNPcFBvd2VyOiBcIlBvdGVuemFcIixcblx0XHRhcml0aG1ldGljT3BNb2RlOiBcIk1vZGFsaXTDoFwiLFxuXHRcdGNsaXBUeXBlT3V0c2lkZTogXCJUYWdsaWEgYWxsJ2VzdGVybm9cIixcblx0XHRjbGlwVHlwZUluc2lkZTogXCJUYWdsaWEgYWxsJ2ludGVybm9cIixcblx0XHR5ZXM6IFwiWWVzXCIsXG5cdFx0bm86IFwiTm9cIixcblx0XHRkZW5zaXRpZXM6IFwiRGVuc2l0w6BcIixcblx0XHRleHBlY3RlZENvdW50czogXCJDb250ZWdnaSBwcmV2aXN0aVwiLFxuXHRcdHBsYW5hcjogXCJQbGFuYXJlXCIsXG5cdFx0Z2VvZGVzaWM6IFwiR2VvZGV0aWNvXCIsXG5cdFx0ZWFjaENlbGw6IFwiT2duaSBjZWxsYVwiLFxuXHRcdGVhY2hab25lOiBcIk9nbmkgem9uYVwiLFxuXHRcdGJlc3RTaW5nbGU6IFwiU2luZ29sbyBtaWdsaW9yZVwiLFxuXHRcdGFsbFNpZ2h0bGluZXM6IFwiVHV0dGUgbGUgbGluZWUgZGkgdmlzdGFcIixcblx0XHRwZXJpbWV0ZXJTaWdodGxpbmVzOiBcIkxpbmVlIGRpIHZpc3RhIHBlcmltZXRyYWxpXCIsXG5cdFx0ZnJlcXVlbmN5OiBcIkZyZXF1ZW56YVwiLFxuXHRcdG9ic2VydmVyczogXCJPc3NlcnZhdG9yaVwiLFxuXHRcdG1ham9yaXR5OiBcIk1hZ2dpb3JhbnphXCIsXG5cdFx0bWVkaWFuOiBcIk1lZGlhbmFcIixcblx0XHRtaW5vcml0eTogXCJNaW5vcmFuemFcIixcblx0XHRwZXJjZW50aWxlOiBcIlBlcmNlbnRpbGVcIixcblx0XHRyYW5nZTogXCJJbnRlcnZhbGxvXCIsXG5cdFx0c3VtOiBcIlNvbW1hXCIsXG5cdFx0dmFyaWV0eTogXCJWYXJpZXTDoFwiLFxuXHRcdG5kdmk6IFwiTkRWSVwiLFxuXHRcdHNhdmk6IFwiU0FWSVwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kVFNBVkk6IFwiU0FWSSB0cmFzZm9ybWF0b1wiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kTVNBVkk6IFwiU0FWSSBtb2RpZmljYXRvXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNNZXRob2RTdWx0YW46IFwiRm9ybXVsYSBkaSBTdWx0YW5cIixcblx0XHRnZW1pOiBcIkdFTUlcIixcblx0XHRwdmk6IFwiUFZJXCIsXG5cdFx0Z3ZpOiBcIkdWSSAoTGFuZHNhdCBUTSlcIixcblx0XHR2YXJpOiBcIlZBUklcIixcblx0XHRzcjogXCJTUlwiLFxuXHRcdGduZHZpOiBcIkdORFZJXCIsXG5cdFx0bmR2aXJlOiBcIk5EVklyZVwiLFxuXHRcdHNycmU6IFwiU1JyZVwiLFxuXHRcdG10dmkyOiBcIk1UVkkyXCIsXG5cdFx0cnR2aUNvcmU6IFwiUlRWSUNvcmVcIixcblx0XHRjaXJlOiBcIkNJcmVcIixcblx0XHRjaWc6IFwiQ0lnXCIsXG5cdFx0bmR3aTogXCJORFdJXCIsXG5cdFx0ZXZpOiBcIkVWSVwiLFxuXHRcdGlyb25PeGlkZTogXCJPc3NpZG8gZGkgZmVycm9cIixcblx0XHRmZXJyb3VzTWluZXJhbHM6IFwiTWluZXJhbGkgZmVycm9zaVwiLFxuXHRcdGNsYXlNaW5lcmFsczogXCJNaW5lcmFsaSBkaSBhcmdpbGxhXCIsXG5cdFx0d25kd2k6IFwiV05EV0lcIixcblx0XHRiYWk6IFwiQkFJXCIsXG5cdFx0bW5kd2k6IFwiTU5EV0lcIixcblx0XHRuYnI6IFwiTkJSXCIsXG5cdFx0bmRiaTogXCJOREJJXCIsXG5cdFx0bmRtaTogXCJORE1JXCIsXG5cdFx0bmRzaTogXCJORFNJXCIsXG5cdFx0bG9jYWxTcXVhcmVSb290OiBcIlNxdWFyZSBSb290XCIsXG5cdFx0bG9jYWxBQ29zOiBcIkFDb3NcIixcblx0XHRsb2NhbEFTaW46IFwiQVNpblwiLFxuXHRcdGxvY2FsQVRhbjogXCJBVGFuXCIsXG5cdFx0bG9jYWxBVGFuSDogXCJBVGFuSFwiLFxuXHRcdGxvY2FsQWJzOiBcIkFic1wiLFxuXHRcdGxvY2FsQml0d2lzZU5vdDogXCJOb3QgQml0d2lzZVwiLFxuXHRcdGxvY2FsQm9vbGVhbk5vdDogXCJObyBib29sZWFub1wiLFxuXHRcdGxvY2FsQ29zOiBcIkNvc1wiLFxuXHRcdGxvY2FsQ29zSDogXCJDb3NIXCIsXG5cdFx0bG9jYWxFeHA6IFwiRXhwXCIsXG5cdFx0bG9jYWxFeHAxMDogXCJFeHAxMFwiLFxuXHRcdGxvY2FsRXhwMjogXCJFeHAyXCIsXG5cdFx0bG9jYWxJbnQ6IFwiSW50XCIsXG5cdFx0bG9jYWxJc051bGw6IFwiw4ggbnVsbFwiLFxuXHRcdGxvY2FsRmxvYXQ6IFwiRmxvYXRcIixcblx0XHRsb2NhbExuOiBcIkxuXCIsXG5cdFx0bG9jYWxMb2cxMDogXCJMb2cxMFwiLFxuXHRcdGxvY2FsTG9nMjogXCJMb2cyXCIsXG5cdFx0bG9jYWxOZWdhdGU6IFwiTmVnYXRlXCIsXG5cdFx0bG9jYWxSb3VuZERvd246IFwiUm91bmQgRG93blwiLFxuXHRcdGxvY2FsUm91bmRVcDogXCJSb3VuZCBVcFwiLFxuXHRcdGxvY2FsU2luOiBcIlNpblwiLFxuXHRcdGxvY2FsU2luSDogXCJTaW5IXCIsXG5cdFx0bG9jYWxUYW46IFwiVGFuXCIsXG5cdFx0bG9jYWxUYW5IOiBcIlRhbkhcIixcblx0XHRsb2NhbEFDb3NIOiBcIkFDb3NIXCIsXG5cdFx0bG9jYWxBU2luSDogXCJBU2luSFwiLFxuXHRcdGxvY2FsUGx1czogXCJQbHVzXCIsXG5cdFx0bG9jYWxNaW51czogXCJNaW51c1wiLFxuXHRcdGxvY2FsVGltZXM6IFwiVm9sdGVcIixcblx0XHRsb2NhbFBvd2VyOiBcIlBvdGVuemFcIixcblx0XHRsb2NhbEJpdHdpc2VBbmQ6IFwiQW5kIEJpdHdpc2VcIixcblx0XHRsb2NhbEJpdHdpc2VMZWZ0U2hpZnQ6IFwiU3Bvc3RhbWVudG8gYSBzaW5pc3RyYSBCaXR3aXNlXCIsXG5cdFx0bG9jYWxCaXR3aXNlT3I6IFwiT3IgQml0d2lzZVwiLFxuXHRcdGxvY2FsQml0d2lzZVJpZ2h0U2hpZnQ6IFwiU3Bvc3RhbWVudG8gYSBkZXN0cmEgQml0d2lzZVwiLFxuXHRcdGxvY2FsQml0d2lzZVhvcjogXCJCaXR3aXNlIFhvclwiLFxuXHRcdGxvY2FsQm9vbGVhbkFuZDogXCJCb29sZWFuIEFuZFwiLFxuXHRcdGxvY2FsQm9vbGVhbk9yOiBcIkJvb2xlYW4gT3JcIixcblx0XHRsb2NhbEJvb2xlYW5Yb3I6IFwiQm9vbGVhbiBYb3JcIixcblx0XHRsb2NhbERpdmlkZTogXCJEaXZpZGVcIixcblx0XHRsb2NhbEVxdWFsVG86IFwiRXF1YWwgVG9cIixcblx0XHRsb2NhbEdyZWF0ZXJUaGFuOiBcIk1hZ2dpb3JlIERpXCIsXG5cdFx0bG9jYWxHcmVhdGVyVGhhbkVxdWFsOiBcIkdyZWF0ZXIgVGhhbiBFcXVhbFwiLFxuXHRcdGxvY2FsTGVzc1RoYW46IFwiTGVzcyBUaGFuXCIsXG5cdFx0bG9jYWxMZXNzVGhhbkVxdWFsOiBcIkxlc3MgVGhhbiBFcXVhbFwiLFxuXHRcdGxvY2FsTW9kOiBcIk1vZFwiLFxuXHRcdGxvY2FsTm90RXF1YWw6IFwiTm90IEVxdWFsXCIsXG5cdFx0bG9jYWxBVGFuMjogXCJBVGFuMlwiLFxuXHRcdGxvY2FsU3F1YXJlOiBcIlNxdWFyZVwiLFxuXHRcdGxvY2FsU2V0TnVsbDogXCJJbXBvc3RhIE51bGxcIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkVsZW5jb1wiLFxuXHRcdHJlbWFwRGVmVHlwZVRhYmxlOiBcIlRhYmVsbGFcIixcblx0XHRyZW1hcFRhYmxlVHlwZVNpbXBsZTogXCJTZW1wbGljZVwiLFxuXHRcdHJlbWFwVGFibGVUeXBlRHluYW1pYzogXCJEaW5hbWljb1wiLFxuXHRcdHJlbWFwVGFibGVUeXBlUmVhc3NpZ25tZW50OiBcIlJpYXNzZWduYXppb25lXCIsXG5cdFx0Z2VvbUNvcnJlY3Rpb25CeUNvbnN0WjogXCJVc2EgY29zdGFudGUgWlwiLFxuXHRcdGdlb21Db3JyZWN0aW9uQnlERU06IFwiVXNhIERFTVwiLFxuXHRcdHJhZGFyQ2FsaWJCZXRhTm91Z2h0OiBcIkJldGEgbm91Z2h0XCIsXG5cdFx0cmFkYXJDYWxpYlNpZ21hTm91Z2h0OiBcIlNpZ21hIG5vdWdodFwiLFxuXHRcdHJhZGFyQ2FsaWJHYW1tYU5vdWdodDogXCJHYW1tYSBub3VnaHRcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUxlZTogXCJGaWx0cm8gTGVlXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVFbmhhbmNlZExlZTogXCJGaWx0cm8gTGVlIG1pZ2xpb3JhdG9cIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUZyb3N0OiBcIkZpbHRybyBGcm9zdFwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlS3VhbjogXCJGaWx0cm8gS3VhblwiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsTXVsOiBcIlJ1bW9yZSBtb2x0aXBsaWNhdGl2b1wiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsQWRkOiBcIlJ1bW9yZSBhZGRpdGl2b1wiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsQWRkbk11bDogXCJSdW1vcmUgYWRkaXRpdm8gZSBtb2x0aXBsaWNhdGl2b1wiLFxuXHRcdG1vc2FpY09wVHlwZUZpcnN0OiBcIlByaW1vXCIsXG5cdFx0bW9zYWljT3BUeXBlTGFzdDogXCJVbHRpbW9cIixcblx0XHRtb3NhaWNPcFR5cGVNaW46IFwiTWluaW1hXCIsXG5cdFx0bW9zYWljT3BUeXBlTWF4OiBcIk1hc3NpbWFcIixcblx0XHRtb3NhaWNPcFR5cGVNZWFuOiBcIk1lZGlvXCIsXG5cdFx0bW9zYWljT3BUeXBlQmxlbmQ6IFwiRnVzaW9uZVwiLFxuXHRcdG1vc2FpY09wVHlwZVN1bTogXCJTb21tYVwiLFxuXHRcdGludGVnZXI6IFwiSW50ZXJvXCIsXG5cdFx0cmZ4RDg6IFwiRDhcIixcblx0XHRyZnhNRkQ6IFwiTUZEXCIsXG5cdFx0ZGluZjogXCJEaW5mXCIsXG5cdFx0dmVydGljYWw6IFwiVmVydGljYWxlXCIsXG5cdFx0aG9yaXpvbnRhbDogXCJPcml6em9udGFsZVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eTogXCJNYWdnaW9yYW56YVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYXg6IFwiTWFzc2ltb1wiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWFuOiBcIk1lZGlvXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbjogXCJNZWRpYW5hXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbjogXCJNaW5pbW9cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHk6IFwiTWlub3JhbnphXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1JhbmdlOiBcIkludGVydmFsbG9cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3RkRGV2OiBcIkRldmlhemlvbmUgc3RhbmRhcmRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtOiBcIlNvbW1hXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1ZhcmlldHk6IFwiVmFyaWV0w6BcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWFqb3JpdHlJZ25vcmVORDogXCJNYWdnaW9yYW56YSAoaWdub3JhIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWF4SWdub3JlTkQ6IFwiVmFsb3JlIG1hc3NpbW8gKGlnbm9yYSBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW5JZ25vcmVORDogXCJWYWxvcmUgbWVkaW8gKGlnbm9yYSBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbklnbm9yZU5EOiBcIlZhbG9yZSBtZWRpYW5vIChpZ25vcmEgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5JZ25vcmVORDogXCJWYWxvcmUgbWluaW1vIChpZ25vcmEgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5vcml0eUlnbm9yZU5EOiBcIk1pbm9yYW56YSAoaWdub3JhIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzUmFuZ2VJZ25vcmVORDogXCJJbnRlcnZhbGxvIChpZ25vcmEgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdGREZXZJZ25vcmVORDogXCJEZXZpYXppb25lIHN0YW5kYXJkIChpZ25vcmEgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdW1JZ25vcmVORDogXCJTb21tYSAoaWdub3JhIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVmFyaWV0eUlnbm9yZU5EOiBcIlZhcmlldMOgIChpZ25vcmEgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NUeXBlUGVyY2VudGlsZUlnbm9yZU5EOiBcIlBlcmNlbnRpbGUgKElnbm9yYSBOb0RhdGEpXCIsXG5cdFx0ZnJvbVNvdXJjZTogXCJEYSBvcmlnaW5lXCIsXG5cdFx0dG9Tb3VyY2U6IFwiQSBvcmlnaW5lXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25SZ2JUb0hzdjogXCJEYSBSR0IgYSBIU1ZcIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvbkhzdlRvUmdiOiBcIkRhIEhTViBhIFJHQlwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlSUhTOiBcIklIU1wiLFxuXHRcdHBhbnNoYXJwZW5UeXBlQnJvdmV5OiBcIkJyb3ZleVwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlRXNyaTogXCJFc3JpXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVNZWFuOiBcIk1lZGlvXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVHcmFtU2NobWlkdDogXCJHcmFtLVNjaG1pZHRcIixcblx0XHRyZWN0YW5nbGVOZWlnaGJvcmhvb2Q6IFwiUmV0dGFuZ29sb1wiLFxuXHRcdGNpcmNsZU5laWdoYm9yaG9vZDogXCJDZXJjaGlvXCIsXG5cdFx0YW5udWx1c05laWdoYm9yaG9vZDogXCJDb3JvbmEgY2lyY29sYXJlXCIsXG5cdFx0d2VkZ2VOZWlnaGJvcmhvb2Q6IFwiU3BpY2NoaW9cIixcblx0XHRpcnJlZ3VsYXJOZWlnaGJvcmhvb2Q6IFwiSXJyZWdvbGFyZVwiLFxuXHRcdHdlaWdodE5laWdoYm9yaG9vZDogXCJQZXNvXCIsXG5cdFx0Zm91cjogXCJRdWF0dHJvXCIsXG5cdFx0ZWlnaHQ6IFwiT3R0b1wiLFxuXHRcdHdpdGhpbjogXCJBbGwnaW50ZXJub1wiLFxuXHRcdGNyb3NzOiBcIkNyb2NlXCIsXG5cdFx0YWRkTGluazogXCJBZ2dpdW5naSBjb2xsZWdhbWVudG9cIixcblx0XHRub0xpbms6IFwiTmVzc3VuIGNvbGxlZ2FtZW50b1wiLFxuXHRcdHdlaWdodGVkTWVhbjogXCJNZWRpYSB2ZXJpZmljYXRhXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2lycnVzOiBcIkxhbmRzYXQgOCAtIENpcnJvXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWQ6IFwiTGFuZHNhdCA4IC0gTnV2b2xhXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWRTaGFkb3c6IFwiTGFuZHNhdCA4IC0gT21icmEgbnV2b2xhXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuRGVzaWduYXRlZEZpbGw6IFwiTGFuZHNhdCA4IC0gUmllbXBpbWVudG8gZGVzaWduYXRvXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuRHJvcHBlZEZyYW1lOiBcIkxhbmRzYXQgOCAtIEZvdG9ncmFtbWEgZWxpbWluYXRvXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuU25vd0ljZTogXCJMYW5kc2F0IDggLSBOZXZlL0doaWFjY2lvXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVGVycmFpbk9jY2x1c2lvbjogXCJMYW5kc2F0IDggLSBPY2NsdXNpb25lIHRlcnJlbm9cIixcblx0XHRsczhRQ0JpdFBhdHRlcm5WZWdldGF0aW9uOiBcIkxhbmRzYXQgOCAtIFZlZ2V0YXppb25lXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuV2F0ZXI6IFwiTGFuZHNhdCA4IC0gQWNxdWFcIixcblx0XHRkb3duU3RyZWFtOiBcIkRvd25zdHJlYW1cIixcblx0XHR1cFN0cmVhbTogXCJVcHN0cmVhbVwiLFxuXHRcdHN0cmFobGVyOiBcIlNUUkFITEVSXCIsXG5cdFx0c2hyZXZlOiBcIlNIUkVWRVwiLFxuXHRcdGN1cnJlbnRTbGljZTogXCJTZXppb25lIGNvcnJlbnRlXCIsXG5cdFx0YWxsU2xpY2VzOiBcIlR1dHRlIGxlIHNlemlvbmlcIixcblx0XHRleHBhbmREaXN0YW5jZTogXCJESVNUQU5aQVwiLFxuXHRcdGV4cGFuZE1vcnBob2xvZ2ljYWw6IFwiTU9SRk9MT0dJQ0FcIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlOiBcIlByb2ZpbG8gc3BldHRyYWxlXCIsXG5cdFx0dHJhaW5pbmdGZWF0dXJlRmlsZTogXCJGZWF0dXJlIGRpIGZvcm1hemlvbmVcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlVW5pZm9ybTogXCJVbmlmb3JtZVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVVbmlmb3JtSW50ZWdlcjogXCJJbnRlcm9cIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlTm9ybWFsOiBcIk5vcm1hbGVcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlRXhwb25lbnRpYWw6IFwiRXNwb25lbnppYWxlXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVBvaXNzb246IFwiUG9pc3NvblwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVHYW1tYTogXCJHYW1tYVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVCaW5vbWlhbDogXCJCaW5vbWlhbGVcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlR2VvbWV0cmljOiBcIkdlb21ldHJpY2FcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlTmVnYXRpdmVCaW5vbWlhbDogXCJCaW5vbWlhbGUgbmVnYXRpdm9cIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlU3RhbmRhcmRDUmFuZDogXCJDIFJhbmQgc3RhbmRhcmRcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlQWxnb3JpdGhtQUNNNTk5OiBcIkFsZ29yaXRtbyA1OTkgcmFjY29sdG8gZGEgQUNNXCIsXG5cdFx0cmFuZG9tR2VuZXJhdG9yVHlwZU1lcnNlbm5lVHdpc3RlcjogXCJNZXJzZW5uZSBUd2lzdGVyXCIsXG5cdFx0c3VtTmFtZTogXCJTb21tYVwiLFxuXHRcdG1lZGFpbk5hbWU6IFwiTWVkaWFuYVwiLFxuXHRcdHRyZW5kTGluZWFyOiBcIkxpbmVhcmVcIixcblx0XHR0cmVuZEhhcm1vbmljOiBcIkFybW9uaWNhXCIsXG5cdFx0dHJlbmRQb2x5bm9taWFsOiBcIlBvbGlub21pYWxlXCIsXG5cdFx0dHJlbmRNYW5uS2VuZGFsbDogXCJNYW5uLUtlbmRhbGxcIixcblx0XHR0cmVuZFNlYXNvbmFsS2VuZGFsbDogXCJLZW5kYWxsIHN0YWdpb25hbGVcIixcblx0XHRkaW1lbnNpb25CeVZhbHVlOiBcIlBlciBWYWxvcmVcIixcblx0XHRkaW1lbnNpb25CeUludGVydmFsOiBcIlBlciBpbnRlcnZhbGxvXCIsXG5cdFx0bWRpbURlZlR5cGVBbGw6IFwiVHV0dG9cIixcblx0XHRtZGltRGVmVHlwZUJ5VmFsdWVzOiBcIlBlciB2YWxvcmlcIixcblx0XHRtZGltRGVmVHlwZUJ5UmFuZ2VzOiBcIlBlciBpbnRlcnZhbGxvXCIsXG5cdFx0bWRpbURlZlR5cGVCeUl0ZXJhdGlvbjogXCJQZXIgaXRlcmF6aW9uZVwiLFxuXHRcdG1kaW1EZWZUeXBlQnlJbnRlcnZhbDogXCJQZXIgaW50ZXJ2YWxsb1wiLFxuXHRcdG1kaW1EZWZUeXBlQnlUYXJnZXRSYXN0ZXI6IFwiUGVyIHJhc3RlciBkaSBkZXN0aW5hemlvbmVcIixcblx0XHRlc3JpVGltZVVuaXRzSG91cnM6IFwiT3JlXCIsXG5cdFx0ZXNyaVRpbWVVbml0c0RheXM6IFwiR2lvcm5pXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1dlZWtzOiBcIlNldHRpbWFuZVwiLFxuXHRcdGVzcmlUaW1lVW5pdHNNb250aHM6IFwiTWVzaVwiLFxuXHRcdGVzcmlUaW1lVW5pdHNZZWFyczogXCJBbm5pXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRIb3VybHk6IFwiT2duaSBvcmFcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZERhaWx5OiBcIk9nbmkgZ2lvcm5vXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRXZWVrbHk6IFwiT2duaSBzZXR0aW1hbmFcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZERla2FkbHk6IFwiT2duaSBkaWVjaSBnaW9ybmlcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFBlbnRhZGx5OiBcIk9nbmkgY2lucXVlIGdpb3JuaVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkTW9udGhseTogXCJPZ25pIG1lc2VcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFF1YXJ0ZXJseTogXCJUcmltZXN0cmFsZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkWWVhcmx5OiBcIkFubnVhbGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ0RhaWx5OiBcIlJpY29ycmVuemEgZ2lvcm5hbGllcmFcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1dlZWtseTogXCJSaWNvcnJlbnphIHNldHRpbWFuYWxlXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdNb250aGx5OiBcIlJpY29ycmVuemEgbWVuc2lsZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nUXVhcnRlcmx5OiBcIlJpY29ycmVuemEgdHJpbWVzdHJhbGVcIixcblx0XHRhZ2dEZWZUeXBlQWxsOiBcIlR1dHRlXCIsXG5cdFx0YWdnRGVmVHlwZUludGVydmFsS2V5d29yZDogXCJQYXJvbGEgY2hpYXZlIGRpIGludGVydmFsbG9cIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxWYWx1ZTogXCJWYWxvcmUgZGkgaW50ZXJ2YWxsb1wiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFJhbmdlczogXCJBbXBpZXp6ZSBpbnRlcnZhbGxvXCIsXG5cdFx0bGF0ZXN0Q2hhbmdlOiBcIk9yYSBkZWxsJ3VsdGltYSBtb2RpZmljYVwiLFxuXHRcdGVhcmxpZXN0Q2hhbmdlOiBcIk9yYSBkZWxsYSBwcmltYSBtb2RpZmljYVwiLFxuXHRcdGxhcmdlc3RDaGFuZ2U6IFwiT3JhIGRlbGxhIG1vZGlmaWNhIHBpw7kgZ3JhbmRlXCIsXG5cdFx0bnVtYmVyT2ZDaGFuZ2VzOiBcIk51bWVybyBkaSBtb2RpZmljaGVcIixcblx0XHRsb25nZXN0Q2hhbmdlOiBcIk9yYSBkZWxsYSBtb2RpZmljYSBwacO5IGx1bmdhXCIsXG5cdFx0c2hvcnRlc3RDaGFuZ2U6IFwiT3JhIGRlbGxhIG1vZGlmaWNhIHBpw7kgYnJldmVcIixcblx0XHRmYXN0ZXN0Q2hhbmdlOiBcIk9yYSBkZWxsYSBtb2RpZmljYSBwacO5IHZlbG9jZVwiLFxuXHRcdHNsb3dlc3RDaGFuZ2U6IFwiT3JhIGRlbGxhIG1vZGlmaWNhIHBpw7kgbGVudGFcIixcblx0XHRhbGxDaGFuZ2VzOiBcIlR1dHRlXCIsXG5cdFx0aW5jcmVhc2VDaGFuZ2VzOiBcIkF1bWVudGFcIixcblx0XHRkZWNyZWFzZUNoYW5nZXM6IFwiRGltaW51aXNjaVwiLFxuXHRcdHNlZ21lbnRCZWdpbm5pbmc6IFwiSW5pemlvIGRlbCBzZWdtZW50b1wiLFxuXHRcdHNlZ21lbnRFbmQ6IFwiRmluZSBkZWwgc2VnbWVudG9cIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZERpZmZlcmVuY2U6IFwiRGlmZmVyZW56YVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kUmVsYXRpdmVEaWZmZXJlbmNlOiBcIkRpZmZlcmVuemEgcmVsYXRpdmFcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZENhdGVnb3JpY2FsOiBcIkRpZmZlcmVuemEgY2F0ZWdvcmljYVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEV1Y2xpZGVhbkRpc3RhbmNlOiBcIkRpc3RhbnphIHNwZXR0cmFsZSBldWNsaWRlYVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEFuZ3VsYXJEaWZmZXJlbmNlOiBcIkRpZmZlcmVuemEgYW5nb2xvIHNwZXR0cmFsZVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEF4aXNXaXRoQmlnZ2VzdENoYW5nZTogXCJCYW5kYSBjb24gaWwgbWFnZ2lvciBudW1lcm8gZGkgY2FtYmlhbWVudGlcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBBbGw6IFwiTWFudGllbmkgdHV0dG9cIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBDaGFuZ2VkT25seTogXCJNYW50aWVuaSBzb2xvIFBpeGVsIGNhbWJpYXRpXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwVW5jaGFuZ2VkT25seTogXCJNYW50aWVuaSBzb2xvIFBpeGVsIG5vbiBjYW1iaWF0aVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JBdmVyYWdlOiBcIkNvbG9yaSBtZWRpIERhIGUgQVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JGcm9tOiBcIlVzYSBEYSBjb2xvcmlcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yVG86IFwiVXNhIEEgY29sb3JpXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25CaW5hcnk6IFwiQmluYXJpb1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uRm9yd2FyZDogXCJBdmFudGlcIixcblx0XHRmYWN0b3JGdW5jdGlvbkxpbmVhcjogXCJMaW5lYXJlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25JbnZMaW5lYXI6IFwiTGluZWFyZSBpbnZlcnNvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZTogXCJUYWJlbGxhXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1MaW5lYXI6IFwiTGluZWFyZSBzaW1tZXRyaWNvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1JbnZMaW5lYXI6IFwiTGluZWFyZSBpbnZlcnNvIHNpbW1ldHJpY29cIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvczogXCJDb3Nlbm9cIixcblx0XHRmYWN0b3JGdW5jdGlvblNlYzogXCJTZWNhbnRlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3NTZWM6IFwiU2VjYW50ZSBjb3Nlbm9cIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY0NvczogXCJDb3Nlbm8gc2VjYW50ZVwiLFxuXHRcdG5vU29ydDogXCJOb24gb3JkaW5hcmVcIixcblx0XHRhc2NlbmQ6IFwiQ3Jlc2NlbnRlXCIsXG5cdFx0ZGVzY2VuZDogXCJEZWNyZXNjZW50ZVwiLFxuXHRcdGF1dG9EZXRlY3Q6IFwiUmlsZXZhbWVudG8gYXV0b21hdGljb1wiLFxuXHRcdG5lYXJlc3Q6IFwiUGnDuSB2aWNpbm9cIixcblx0XHRsaW5lYXI6IFwiTGluZWFyZVwiLFxuXHRcdGVzcmlNb250aEphbnVhcnk6IFwiR2VubmFpb1wiLFxuXHRcdGVzcmlNb250aEZlYnJ1YXJ5OiBcIkZlYmJyYWlvXCIsXG5cdFx0ZXNyaU1vbnRoTWFyY2g6IFwiTWFyem9cIixcblx0XHRlc3JpTW9udGhBcHJpbDogXCJBcHJpbGVcIixcblx0XHRlc3JpTW9udGhNYXk6IFwiTWFnZ2lvXCIsXG5cdFx0ZXNyaU1vbnRoSnVuZTogXCJHaXVnbm9cIixcblx0XHRlc3JpTW9udGhKdWx5OiBcIkx1Z2xpb1wiLFxuXHRcdGVzcmlNb250aEF1Z3VzdDogXCJBZ29zdG9cIixcblx0XHRlc3JpTW9udGhTZXB0ZW1iZXI6IFwiU2V0dGVtYnJlXCIsXG5cdFx0ZXNyaU1vbnRoT2N0b2JlcjogXCJPdHRvYnJlXCIsXG5cdFx0ZXNyaU1vbnRoTm92ZW1iZXI6IFwiTm92ZW1icmVcIixcblx0XHRlc3JpTW9udGhEZWNlbWJlcjogXCJEaWNlbWJyZVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nSWdub3JlTm9EYXRhOiBcIkRhdGlcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1Byb3BhZ2F0ZU5vRGF0YTogXCJOZXNzdW4gZGF0b1wiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nRmlsbE9ubHlOb0RhdGE6IFwiUmllbXBpIE5vRGF0YVwiLFxuXHRcdGNpcmN1bGFyTWVhbjogXCJNZWRpYSBjaXJjb2xhcmVcIixcblx0XHRjaXJjdWxhck5hbWU6IFwiQ2lyY29sYXJlXCIsXG5cdFx0YXJpdGhtZXRpY05hbWU6IFwiQXJpdG1ldGljb1wiLFxuXHRcdHNsb3BlTmFtZTogXCJQZW5kZW56YVwiLFxuXHRcdGFzcGVjdE5hbWU6IFwiQXNwZXR0b1wiLFxuXHRcdG1lYW5DdXJ2YXR1cmU6IFwiQ3VydmF0dXJhIG1lZGlhXCIsXG5cdFx0cHJvZmlsZUN1cnZhdHVyZTogXCJQcm9maWxvIChsaW5lYSBkaSBwZW5kZW56YSBub3JtYWxlKSBjdXJ2YXR1cmFcIixcblx0XHR0YW5nZW50aWFsQ3VydmF0dXJlOiBcIkN1cnZhdHVyYSB0YW5nZW56aWFsZSAoY29udG9ybm8gbm9ybWFsZSlcIixcblx0XHRwbGFuQ3VydmF0dXJlOiBcIkN1cnZhdHVyYSBkZWwgcGlhbm8gKGNvbnRvcm5vIHByb2lldHRhdG8pXCIsXG5cdFx0Y29udG91ckdlb2Rlc2ljVG9yc2lvbjogXCJUb3JzaW9uZSBnZW9kZXRpY2EgZGkgY29udG9ybm9cIixcblx0XHRnYXVzc2lhbkN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgZ2F1c3NpYW5hXCIsXG5cdFx0Y2Fzb3JhdGlDdXJ2YXR1cmU6IFwiQ3VydmF0dXJhIENhc29yYXRpXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZVF1YWRyYXRpYzogXCJRdWFkcmF0aWNvXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZUJpcXVhZHJhdGljOiBcIkJpcXVhZHJhdGljb1wiLFxuXHRcdHRocmVzaG9sZE5vVGhyZXNob2xkOiBcIk5lc3N1bmEgc29nbGlhXCIsXG5cdFx0dGhyZXNob2xkUGVyY2VudExlYXN0Q29zdDogXCJQZXJjZW50dWFsZSBkaSBjb3N0byBtaW5pbW9cIixcblx0XHR0aHJlc2hvbGRBY2N1bXVsYXRpdmVDb3N0OiBcIkNvc3RvIGN1bXVsYXRpdm9cIixcblx0XHRjbHJtYXBUeXBlSGlsbHNoYWRlOiBcIlJpbGlldm8gb21icmVnZ2lhdG9cIlxuXHR9LFxuXHRjYXRlZ29yeUxhYmVsczoge1xuXHRcdHNvdXJjZUNoYXJhY3RlcmlzdGljczogXCJDYXJhdHRlcmlzdGljaGUgb3JpZ2luZVwiLFxuXHRcdG5laWdoYm9yaG9vZFNldHRpbmdzOiBcIkltcG9zdGF6aW9uaSBkaSB2aWNpbmFuemFcIixcblx0XHRzdGF0aXN0aWNzOiBcIlN0YXRpc3RpY2hlXCIsXG5cdFx0Z2FtbWE6IFwiR2FtbWFcIixcblx0XHR2aWV3c2hlZFBhcmFtZXRlcnM6IFwiUGFyYW1ldHJpIGNhbXBvIGRpIHZpc3RhXCIsXG5cdFx0b2JzZXJ2ZXJQYXJhbWV0ZXJzOiBcIlBhcmFtZXRyaSBvc3NlcnZhdG9yZVwiLFxuXHRcdGlycmVndWxhckRhdGFJbnRlcnBvbGF0aW9uOiBcIkludGVycG9sYXppb25lIGlycmVnb2xhcmUgZGVpIGRhdGlcIixcblx0XHRtb2RlbFN0YXRpc3RpY3M6IFwiU3RhdGlzdGljaGUgbW9kZWxsb1wiLFxuXHRcdGFnZ3JlZ2F0aW9uRGVmOiBcIkRlZmluaXppb25lIGFnZ3JlZ2F6aW9uZVwiLFxuXHRcdGZpbHRlckJ5QXR0cmlidXRlczogXCJGaWx0cmEgcGVyIGF0dHJpYnV0aVwiLFxuXHRcdHBlcmNlbnRpbGVOYW1lOiBcIlBlcmNlbnRpbGVcIixcblx0XHRyYXN0ZXJJbmZvOiBcIkluZm9ybWF6aW9uZSByYXN0ZXJcIixcblx0XHRleHRlbnQ6IFwiRXN0ZW5zaW9uZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2U6IFwiUmlmZXJpbWVudG8gc3BhemlhbGVcIlxuXHR9LFxuXHRvdXRwdXRSYXN0ZXJIZWxwVGV4dHM6IHtcblx0XHRvdXRwdXROYW1lOiBcIjxwPklsIG5vbWUgZGVsIGxheWVyIGNoZSBzYXLDoCBjcmVhdG8gZSBhZ2dpdW50byBhbGxhIG1hcHBhLjwvcD5cIixcblx0XHRyZXN1bHRUeXBlOiBcIjxwPklsIHRpcG8gZGkgb3V0cHV0IGNoZSBzYXLDoCBjcmVhdG8uIEdsaSBvdXRwdXQgcG9zc29ubyBlc3NlcmUgbGF5ZXIgaW1tYWdpbmkgZGkgdGlsZSBvIGxheWVyIGltbWFnaW5pIGRpbmFtaWNpLjwvcD5cIixcblx0XHRzYXZlUmVzdWx0SW46IFwiPHA+SWwgbm9tZSBkZWxsYSBjYXJ0ZWxsYSBpbiA8Yj5JIG1pZWkgY29udGVudXRpPC9iPiBpbiBjdWkgc2Fyw6Agc2FsdmF0byBpbCByaXN1bHRhdG8uPC9wPlwiXG5cdH0sXG5cdGFuYWx5c2lzRW52aXJvbm1lbnRzSGVscFRleHRzOiB7XG5cdFx0ZGVzY3JpcHRpb246IFwiPHA+SW1wb3N0YXppb25pIGFtYmllbnRlIHBlciBsJ2FuYWxpc2kgaW4gTWFwIFZpZXdlci4gPC9wPlwiLFxuXHRcdG91dFNSOiBcIjxwPlNwZWNpZmljYSBpbCBzaXN0ZW1hIGRpIGNvb3JkaW5hdGUgcGVyIGwnYW5hbGlzaSBlIGlsIGxheWVyIGRlaSByaXN1bHRhdGkuPC9wPlwiLFxuXHRcdGV4dGVudDogXCI8cD5TcGVjaWZpY2EgbCdhcmVhIGRhIHV0aWxpenphcmUgcGVyIGwnYW5hbGlzaS48L3A+XCIsXG5cdFx0c25hcFJhc3RlcjogXCI8cD5SZWdvbGEgbCdlc3RlbnNpb25lIGRlbGwnb3V0cHV0IGluIG1vZG8gY2hlIGNvcnJpc3BvbmRhIGFsbCdhbGxpbmVhbWVudG8gZGVsbGUgY2VsbGUgZGVsIGxheWVyIHNuYXAgcmFzdGVyIHNwZWNpZmljYXRvLjwvcD5cIixcblx0XHRjZWxsU2l6ZTogXCI8cD5TcGVjaWZpY2EgbGEgZGltZW5zaW9uZSBvIGxhIHJpc29sdXppb25lIGRlbGxlIGNlbGxlIGNoZSB2ZXJyw6AgdXRpbGl6emF0YSBwZXIgbCdhbmFsaXNpIGUgcGVyIGNyZWFyZSBpbCBsYXllciByYXN0ZXIgZGkgb3V0cHV0LjwvcD5cIixcblx0XHRtYXNrOiBcIjxwPlNwZWNpZmljYSB1biBsYXllciBtYXNjaGVyYSBpbiBjdWkgc29sbyBsZSBjZWxsZSBjaGUgcmllbnRyYW5vIG5lbGwnYXJlYSBkZWxsYSBtYXNjaGVyYSB2ZXJyYW5ubyB1dGlsaXp6YXRlIHBlciBsJ2FuYWxpc2kuPC9wPlwiLFxuXHRcdHJlc2FtcGxpbmdNZXRob2Q6IFwiPHA+U3BlY2lmaWNhIGNvbWUgaW50ZXJwb2xhcmUgaSB2YWxvcmkgZGVpIHBpeGVsIHF1YW5kbyBpIHJhc3RlciBkaSBpbnB1dCBlIGRpIG91dHB1dCBub24gc29ubyBhbGxpbmVhdGkuPC9wPlwiXG5cdH0sXG5cdG1haW5HZW5TdHJpbmdzOiB7XG5cdFx0dW5zdXBwb3J0ZWREYXRhVHlwZTogXCJUaXBvIG5vbiBzdXBwb3J0YXRvXCIsXG5cdFx0Y3VycmVudGx5VW5zdXBwb3J0ZWQ6IFwiIFVuIGVkaXRvciBwcmVkZWZpbml0byBwZXIgJHttaXNzaW5nVHlwZX0gw6ggaW4gc29zcGVzbyBtYSBkaXNwb25pYmlsZSBhIGJyZXZlLiBDYXNlbGxhIGRpIHRlc3RvIHNlZ25hcG9zdG8gdGVtcG9yYW5lbyBwZXIgc3BlY2lmaWNhcmUgaW5wdXQgYmFzYXRpIHN1IHN0cmluZ2hlLlwiLFxuXHRcdHVuc3VwcG9ydGVkT3ZlcnJpZGVXYXJuaW5nOiBcIlVuIGNvbXBvbmVudGUgZGVsbCdlZGl0b3IgZGkgb3ZlcnJpZGUgY2hlIGZvcm5pc2NlIHVuYSBtaWdsaW9yZSBVWCBwZXIgbGF2b3JhcmUgY29uIGkgc2VndWVudGkgcGFyYW1ldHJpIMOoIGluIHNvc3Blc28gbWEgc2Fyw6AgcHJlc3RvIGRpc3BvbmliaWxlOlwiLFxuXHRcdG92ZXJyaWRlV2lkZ2V0TWlzc2luZzogXCJDb21wb25lbnRlIGVkaXRvciBkaSBvdnZlcnJpZGUgbWFuY2FudGUhXCIsXG5cdFx0dWlJbmNvbXBsZXRlOiBcIkludmlvIGRlbCBwcm9jZXNzbyBub24gcml1c2NpdG8uIEltcG9zc2liaWxlIGVzZWd1aXJlIGxhIGZ1bnppb25lLiBBbGN1bmkgZGVpIGNhbXBpIHJpY2hpZXN0aSBzb25vIGluY29tcGxldGkgbyBtYW5jYW50aSBkYWxsYSBJVS5cIixcblx0XHRjb3VudDogXCJDb250ZWdnaW9cIixcblx0XHRzZWxlY3RWYXJpYWJsZXM6IFwiU2VsZXppb25hIHZhcmlhYmlsaVwiLFxuXHRcdHNlbGVjdEZlYXR1cmU6IFwiU2VsZXppb25hIGZlYXR1cmUgbGF5ZXJcIixcblx0XHRncmVhdGVyVGhhbkVycm9yTWVzc2FnZTogXCJJbCBudW1lcm8gZGkgaW5wdXQgZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgZGkgJHttaW59XCIsXG5cdFx0bGVzc2VyVGhhbkVycm9yTWVzc2FnZTogXCJJbCBudW1lcm8gZGkgaW5wdXQgZGV2ZSBlc3NlcmUgbWlub3JlIGRpICR7bWF4fVwiLFxuXHRcdGdyZWF0ZXJUaGFuT3JFcXVhbEVycm9yTWVzc2FnZTogXCJJbCBudW1lcm8gZGkgaW5wdXQgZGV2ZSBlc3NlcmUgbWFnZ2lvcmUgbyB1Z3VhbGUgYSAke21pbn1cIixcblx0XHRsZXNzZXJUaGFuT3JFcXVhbEVycm9yTWVzc2FnZTogXCJJbCBudW1lcm8gZGkgaW5wdXQgZGV2ZSBlc3NlcmUgbWlub3JlIG8gdWd1YWxlIGEgJHttYXh9XCIsXG5cdFx0YWxsb3dTY2FsYXI6IFwiU2VsZXppb25hcmUgdW4gbGF5ZXIgbyBpbnNlcmlyZSB1bmEgY29zdGFudGVcIixcblx0XHRzZWxlY3RGaWVsZDogXCJTZWxlemlvbmEgY2FtcG9cIixcblx0XHRwYXJhbWV0ZXJSZXF1aXJlZDogXCJRdWVzdG8gcGFyYW1ldHJvIMOoIG9iYmxpZ2F0b3Jpby5cIixcblx0XHRlbnRlckFWYWx1ZTogXCJJbnNlcmlzY2kgdW4gdmFsb3JlIC4uLlwiLFxuXHRcdGludmFsaWRJbnB1dDogXCJJbCB2YWxvcmUgaW5zZXJpdG8gbm9uIMOoIHZhbGlkby5cIixcblx0XHRpdGVtTm90Rm91bmQ6IFwiRWxlbWVudG8gbm9uIGVzaXN0ZW50ZSBvIGluYWNjZXNzaWJpbGUuXCIsXG5cdFx0aXRlbVBlcm1pc3Npb25EZW5pZWQ6IFwiTm9uIGRpc3BvbmkgZGVsbGUgYXV0b3JpenphemlvbmkgcGVyIGFjY2VkZXJlIGEgcXVlc3RvIGVsZW1lbnRvLlwiLFxuXHRcdGxheWVyTm90QXZhaWxhYmxlOiBcIkltcG9zc2liaWxlIGNhcmljYXJlIGlsIGxheWVyICR7bGF5ZXJOYW1lfS5cIixcblx0XHRtdWx0aXBsZUxheWVyc05vdEF2YWlsYWJsZTogXCJJbXBvc3NpYmlsZSBjYXJpY2FyZSBpbCBsYXllciAke2xheWVyTmFtZX0gZSBhbHRyaVwiLFxuXHRcdGxlYXJuTW9yZUxhYmVsOiBcIlVsdGVyaW9yaSBpbmZvcm1hemlvbmlcIixcblx0XHRmaWVsZE5vdEF2YWlsYWJsZTogXCJJbXBvc3NpYmlsZSBjYXJpY2FyZSBpbCBjYW1wby5cIixcblx0XHRhbGxvd0FuYWx5c2lzOiBcIkwnYW5hbGlzaSBub24gw6ggY29uc2VudGl0YSBzdWxsJ2ltYWdlIHNlcnZpY2UuXCIsXG5cdFx0YWxsb3dBbmFseXNpc1JlYXNvbjogXCJVbm8gbyBwacO5IGxheWVyIGRlbGxhIG1hcHBhIG5vbiBzb25vIGVsZW5jYXRpIHF1aSBwZXJjaMOpIG5vbiBjb25zZW50b25vIGwnYW5hbGlzaS5cIixcblx0XHRsZWFybk1vcmVUZXh0OiBcIlVsdGVyaW9yaSBpbmZvcm1hemlvbmlcIixcblx0XHRhdExlYXN0T25lUmFzdGVySW5wdXQ6IFwiQWxtZW5vIHVuIGxheWVyIGRpIGlucHV0IGRldmUgZXNzZXJlIHVuIGxheWVyIHJhc3Rlci5cIixcblx0XHRicm93c2VBbmFseXNpc0xheWVyczogXCJTZm9nbGlhIGxheWVyXCIsXG5cdFx0YWN0aXZlTWFwVmlld0V4dGVudDogXCJVdGlsaXp6YXJlIGwnZXN0ZW5zaW9uZSBtYXBwYSBjb3JyZW50ZVwiLFxuXHRcdGNob29zZVJhc3RlcjogXCJTY2VnbGllcmUgaWwgcmFzdGVyIGRpIHJpdGFnbGlvXCIsXG5cdFx0Y2hvb3NlR2VvbWV0cnk6IFwiU2NlZ2xpZXJlIGxhIGdlb21ldHJpYSBkaSByaXRhZ2xpb1wiLFxuXHRcdHJlc3VsdFR5cGU6IFwiVGlwbyBkaSByaXN1bHRhdG9cIixcblx0XHRzYXZlSW5Gb2xkZXI6IFwiU2FsdmEgbmVsbGEgY2FydGVsbGFcIixcblx0XHRvdXRwdXROYW1lOiBcIk5vbWUgZGkgb3V0cHV0XCIsXG5cdFx0b3V0cHV0TGF5ZXJUeXBlOiBcIlRpcG8gbGF5ZXIgZGkgb3V0cHV0XCIsXG5cdFx0ZHluYW1pY0ltYWdlcnlMYXllcjogXCJMYXllciBpbW1hZ2luaSBkaW5hbWljb1wiLFxuXHRcdHRpbGVkSW1hZ2VyeUxheWVyOiBcIkxheWVyIGltbWFnaW5pIGNvbiB0aWxlXCIsXG5cdFx0Y3VzdG9tOiBcIlBlcnNvbmFsaXp6YVwiLFxuXHRcdGxvYWRpbmc6IFwiQ2FyaWNhbWVudG8gaW4gY29yc28uLi5cIixcblx0XHRsYXllck1pc3Npbmc6IFwiVW5vIG8gcGnDuSBsYXllciBkZWxsYSBtYXBwYSBub24gc29ubyBlbGVuY2F0aSBxdWkgcGVyY2jDqSBub24gY29uc2VudG9ubyBsJ2FuYWxpc2kuIFVsdGVyaW9yaSBpbmZvcm1hemlvbmkuXCIsXG5cdFx0YnJvd3NlQ29vcmRpbmF0ZVN5c3RlbXM6IFwiU2ZvZ2xpYSBzaXN0ZW1pIGRpIGNvb3JkaW5hdGVcIixcblx0XHR1bmFibGVUb1JlcG9wdWxhdGVPdXRTUjogXCJJbXBvc3NpYmlsZSBwb3BvbGFyZSBpbCBzaXN0ZW1hIGRpIGNvb3JkaW5hdGUgZGkgb3V0cHV0LlwiLFxuXHRcdGRlZmF1bHRUaXRsZTogXCJNYWdnaW9yaSBpbmZvcm1hemlvbmlcIixcblx0XHRcIkFSQyAoZXF1YWwgYXJjLXNlY29uZClcIjogXCJBUkMgKHNlY29uZG8gZCdhcmNvIHVndWFsZSlcIixcblx0XHRBZnJpY2E6IFwiQWZyaWNhXCIsXG5cdFx0QW50YXJjdGljYTogXCJBbnRhcnRpZGVcIixcblx0XHRBcmdlbnRpbmE6IFwiQXJnZW50aW5hXCIsXG5cdFx0QXNpYTogXCJBc2lhXCIsXG5cdFx0XCJBc3Rlcm9pZCBCZWx0XCI6IFwiRmFzY2lhIHByaW5jaXBhbGUgZGVnbGkgYXN0ZXJvaWRpXCIsXG5cdFx0XCJBdGxhbnRpYyBPY2VhblwiOiBcIk9jZWFubyBBdGxhbnRpY29cIixcblx0XHRBdXN0cmFsaWE6IFwiQXVzdHJhbGlhXCIsXG5cdFx0XCJBdXN0cmFsaWEgYW5kIE5ldyBaZWFsYW5kXCI6IFwiQXVzdHJhbGlhIGUgTnVvdmEgWmVsYW5kYVwiLFxuXHRcdEF1c3RyaWE6IFwiQXVzdHJpYVwiLFxuXHRcdFwiQkxNIChVUyBGZWV0KVwiOiBcIkJMTSAocGllZGkgc3RhdHVuaXRlbnNpKVwiLFxuXHRcdEJhbmdsYWRlc2g6IFwiQmFuZ2xhZGVzaFwiLFxuXHRcdFwiQmVpamluZyAxOTU0XCI6IFwiUGVjaGlubyAxOTU0XCIsXG5cdFx0Qmh1dGFuOiBcIkJodXRhblwiLFxuXHRcdENHQ1MyMDAwOiBcIkNHQ1MyMDAwXCIsXG5cdFx0Q2FuYWRhOiBcIkNhbmFkYVwiLFxuXHRcdENhcmliYmVhbjogXCJDYXJhaWJpXCIsXG5cdFx0XCJDYXJpYmJlYW4gU2VhXCI6IFwiTWFyIGRlaSBDYXJhaWJpXCIsXG5cdFx0XCJDZW50cmFsIEFtZXJpY2FcIjogXCJBbWVyaWNhIGNlbnRyYWxlXCIsXG5cdFx0XCJDZW50cmFsIGFuZCBOb3J0aCBBbWVyaWNhXCI6IFwiQW1lcmljYSBjZW50cmFsZSBlIHNldHRlbnRyaW9uYWxlXCIsXG5cdFx0Q29sb21iaWE6IFwiQ29sb21iaWFcIixcblx0XHRDb250aW5lbnRhbDogXCJDb250aW5lbnRhbGVcIixcblx0XHRcIkNvdW50eSBTeXN0ZW1zXCI6IFwiU2lzdGVtaSBkaSBjb250ZWFcIixcblx0XHRcIkRlbW9jcmF0aWMgUmVwdWJsaWMgb2YgdGhlIENvbmdvXCI6IFwiUmVwdWJibGljYSBkZW1vY3JhdGljYSBkZWwgQ29uZ29cIixcblx0XHRcIkVQU0cgQXJjdGljXCI6IFwiRVBTRyBBcnRpY29cIixcblx0XHRFYXJ0aDogXCJUZXJyYVwiLFxuXHRcdFwiRWxsaXBzb2lkYWwtYmFzZWRcIjogXCJCYXNhdG8gc3UgZWxsaXNzb2lkYWxlXCIsXG5cdFx0RXVyb3BlOiBcIkV1cm9wYVwiLFxuXHRcdEZpbmxhbmQ6IFwiRmlubGFuZGlhXCIsXG5cdFx0RnJhbmNlOiBcIkZyYW5jaWFcIixcblx0XHRcIkdTSyAyMDExXCI6IFwiR1NLIDIwMTFcIixcblx0XHRcIkdhdXNzIEtydWdlclwiOiBcIkdhdXNzLUtyw7xnZXJcIixcblx0XHRcIkdlb2dyYXBoaWMgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiU2lzdGVtaSBkaSBjb29yZGluYXRlIGdlb2dyYWZpY2hlXCIsXG5cdFx0R2VybWFueTogXCJHZXJtYW5pYVwiLFxuXHRcdFwiR3Jhdml0eS1yZWxhdGVkXCI6IFwiQ29ycmVsYXRvIGFsbGEgZ3Jhdml0w6BcIixcblx0XHRcIkdyZWVud2ljaC1iYXNlZFwiOiBcIkJhc2F0byBzdSBHcmVlbndpY2hcIixcblx0XHRcIkhpZ2h3YXlzIEVuZ2xhbmRcIjogXCJIaWdod2F5cyBFbmdsYW5kXCIsXG5cdFx0SWxsaW5vaXM6IFwiSWxsaW5vaXNcIixcblx0XHRcIkluZGlhbiBPY2VhblwiOiBcIk9jZWFubyBJbmRpYW5vXCIsXG5cdFx0XCJJbmRpYW4gU3ViY29udGluZW50XCI6IFwiU3ViY29udGluZW50ZSBpbmRpYW5vXCIsXG5cdFx0SW5kaWFuYTogXCJJbmRpYW5hXCIsXG5cdFx0SW5kb25lc2lhOiBcIkluZG9uZXNpYVwiLFxuXHRcdElvd2E6IFwiSW93YVwiLFxuXHRcdFwiSXJlbGFuZCBhbmQgVW5pdGVkIEtpbmdkb21cIjogXCJJcmxhbmRhIGUgUmVnbm8gVW5pdG9cIixcblx0XHRJdGFseTogXCJJdGFsaWFcIixcblx0XHRKYXBhbjogXCJHaWFwcG9uZVwiLFxuXHRcdEp1cGl0ZXI6IFwiR2lvdmVcIixcblx0XHRLYW5zYXM6IFwiS2Fuc2FzXCIsXG5cdFx0XCJMYXMgVmVnYXNcIjogXCJMYXMgVmVnYXNcIixcblx0XHRMaWJ5YTogXCJMaWJpYVwiLFxuXHRcdE1hbGF5c2lhOiBcIk1hbGF5c2lhXCIsXG5cdFx0XCJNYWxheXNpYSBhbmQgU2luZ2Fwb3JlXCI6IFwiTWFsYXlzaWEgZSBTaW5nYXBvcmVcIixcblx0XHRNYXJzOiBcIk1hcnRlXCIsXG5cdFx0TWVyY3VyeTogXCJNZXJjdXJpb1wiLFxuXHRcdE1pbm5lc290YTogXCJNaW5uZXNvdGFcIixcblx0XHRNb250YW5hOiBcIk1vbnRhbmFcIixcblx0XHRcIk5BRCAxOTI3XCI6IFwiTkFEIDE5MjdcIixcblx0XHRcIk5BRCAxOTI3IChVUyBGZWV0KVwiOiBcIk5BRCAxOTI3IChwaWVkaSBzdGF0dW5pdGVuc2kpXCIsXG5cdFx0XCJOQUQgMTk4M1wiOiBcIk5BRCAxOTgzXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSlcIjogXCJOQUQgMTk4MyAoMjAxMSlcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzICgyMDExKSAocGllZGkgaW50ZXJuYXppb25hbGkpXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSkgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoMjAxMSkgKG1ldHJpKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzICgyMDExKSAocGllZGkgc3RhdHVuaXRlbnNpKVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAocGllZGkgaW50ZXJuYXppb25hbGkpXCIsXG5cdFx0XCJOQUQgMTk4MyAoQ09SUzk2KSAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIChDT1JTOTYpIChtZXRyaSlcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChDT1JTOTYpIChwaWVkaSBzdGF0dW5pdGVuc2kpXCIsXG5cdFx0XCJOQUQgMTk4MyAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzIChwaWVkaSBpbnRlcm5hemlvbmFsaSlcIixcblx0XHRcIk5BRCAxOTgzIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKG1ldHJpKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKFBBMTEpIChtZXRyaSlcIixcblx0XHRcIk5BRCAxOTgzIChQQTExKSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoUEExMSkgKHBpZWRpIHN0YXR1bml0ZW5zaSlcIixcblx0XHRcIk5BRCAxOTgzIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChwaWVkaSBzdGF0dW5pdGVuc2kpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgSEFSTiAocGllZGkgaW50ZXJuYXppb25hbGkpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgSEFSTiAobWV0cmkpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIEhBUk4gKHBpZWRpIHN0YXR1bml0ZW5zaSlcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKHBpZWRpIGludGVybmF6aW9uYWxpKVwiLFxuXHRcdFwiTkFEIDE5ODMgTlNSUzIwMDcgKE1ldGVycylcIjogXCJOQUQgMTk4MyBOU1JTMjAwNyAobWV0cmkpXCIsXG5cdFx0XCJOQUQgMTk4MyBOU1JTMjAwNyAoVVMgRmVldClcIjogXCJOQUQgMTk4MyBOU1JTMjAwNyAocGllZGkgc3RhdHVuaXRlbnNpKVwiLFxuXHRcdFwiTmF0aW9uYWwgR3JpZHNcIjogXCJHcmlnbGllIG5hemlvbmFsaVwiLFxuXHRcdE5hdmFqbzogXCJOYXZham9cIixcblx0XHROZXB0dW5lOiBcIk5ldHR1bm9cIixcblx0XHRcIk5ldyBCZWlqaW5nXCI6IFwiTnVvdmEgUGVjaGlub1wiLFxuXHRcdFwiTmV3IFplYWxhbmRcIjogXCJOdW92YSBaZWxhbmRhXCIsXG5cdFx0XCJOb3J0aCBBbWVyaWNhXCI6IFwiTm9yZCBBbWVyaWNhXCIsXG5cdFx0XCJOb3J0aGVybiBIZW1pc3BoZXJlXCI6IFwiRW1pc2Zlcm8gc2V0dGVudHJpb25hbGVcIixcblx0XHROb3J3YXk6IFwiTm9ydmVnaWFcIixcblx0XHRPY2VhbnM6IFwiT2NlYW5pXCIsXG5cdFx0T3JlZ29uOiBcIk9yZWdvblwiLFxuXHRcdFwiT3RoZXIgR0NTXCI6IFwiQWx0cm8gR0NTXCIsXG5cdFx0XCJQYWNpZmljIE9jZWFuXCI6IFwiT2NlYW5vIFBhY2lmaWNvXCIsXG5cdFx0UGx1dG86IFwiUGx1dG9uZVwiLFxuXHRcdFBvbGFyOiBcIlBvbGFyZVwiLFxuXHRcdFBvcnR1Z2FsOiBcIlBvcnRvZ2FsbG9cIixcblx0XHRcIlByb2plY3RlZCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJTaXN0ZW1pIGRpIGNvb3JkaW5hdGUgcHJvaWV0dGF0aVwiLFxuXHRcdFwiUHVsa292byAxOTQyXCI6IFwiUHVsa292byAxOTQyXCIsXG5cdFx0XCJQdWxrb3ZvIDE5OTVcIjogXCJQdWxrb3ZvIDE5OTVcIixcblx0XHRSZXBsYWNlZDogXCJTb3N0aXR1aXRvXCIsXG5cdFx0XCJTQUQgMTk2OVwiOiBcIlNBRCAxOTY5XCIsXG5cdFx0U0lSR0FTOiBcIlNJUkdBU1wiLFxuXHRcdFwiU0lSR0FTIDIwMDBcIjogXCJTSVJHQVMgMjAwMFwiLFxuXHRcdFNhdHVybjogXCJTYXR1cm5vXCIsXG5cdFx0XCJTb2xhciBTeXN0ZW1cIjogXCJTaXN0ZW1hIHNvbGFyZVwiLFxuXHRcdFwiU291dGggQWZyaWNhXCI6IFwiU3VkYWZyaWNhXCIsXG5cdFx0XCJTb3V0aCBBbWVyaWNhXCI6IFwiU3VkIEFtZXJpY2FcIixcblx0XHRcIlNvdXRoIEtvcmVhXCI6IFwiQ29yZWEgZGVsIFN1ZFwiLFxuXHRcdFwiU291dGhlcm4gSGVtaXNwaGVyZVwiOiBcIkVtaXNmZXJvIG1lcmlkaW9uYWxlXCIsXG5cdFx0XCJTcGhlcm9pZC1iYXNlZFwiOiBcIkJhc2F0byBzdSBzZmVyb2lkaVwiLFxuXHRcdFwiU3RhdGUgUGxhbmVcIjogXCJQaWFubyBzdGF0YWxlXCIsXG5cdFx0XCJTdGF0ZSBTeXN0ZW1zXCI6IFwiU2lzdGVtaSBzdGF0YWxpXCIsXG5cdFx0U3dlZGVuOiBcIlN2ZXppYVwiLFxuXHRcdFwiU3dpdHplcmxhbmQgYW5kIExpZWNodGVuc3RlaW5cIjogXCJTdml6emVyYSBlIExpZWNodGVuc3RlaW5cIixcblx0XHRUZXhhczogXCJUZXhhc1wiLFxuXHRcdFRyaWJhbDogXCJUcmliYWxlXCIsXG5cdFx0VHVya2V5OiBcIlR1cmNoaWFcIixcblx0XHRcIlVTIEZlZXRcIjogXCJQaWVkaSBpbnRlcm5hemlvbmFsaVwiLFxuXHRcdFwiVVNBIGFuZCB0ZXJyaXRvcmllc1wiOiBcIlN0YXRpIFVuaXRpIGUgdGVycml0b3JpXCIsXG5cdFx0VVRNOiBcIlVUTVwiLFxuXHRcdFVrcmFpbmU6IFwiVWNyYWluYVwiLFxuXHRcdFwiVW5rbm93biBIZWlnaHQgU3lzdGVtc1wiOiBcIlNpc3RlbWkgZGkgYWx0ZXp6YSBzY29ub3NjaXV0aVwiLFxuXHRcdFVyYW51czogXCJVcmFuaW9cIixcblx0XHRWZW51czogXCJWZW5lcmVcIixcblx0XHRcIlZlcnRpY2FsIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIlNpc3RlbWkgZGkgY29vcmRpbmF0ZSB2ZXJ0aWNhbGlcIixcblx0XHRWaWV0bmFtOiBcIlZpZXRuYW1cIixcblx0XHRcIldHUyAxOTcyXCI6IFwiV0dTIDE5NzJcIixcblx0XHRcIldHUyAxOTg0XCI6IFwiV0dTIDE5ODRcIixcblx0XHRXaXNjb25zaW46IFwiV2lzY29uc2luXCIsXG5cdFx0XCJXaXNjb25zaW4gQ1JTXCI6IFwiV2lzY29uc2luIENSU1wiLFxuXHRcdFdvcmxkOiBcIk1vbmRvXCIsXG5cdFx0XCJXb3JsZCAoU3BoZXJlLWJhc2VkKVwiOiBcIk1vbmRvIChiYXNhdG8gc3Ugc2ZlcmEpXCIsXG5cdFx0V3lvbWluZzogXCJXeW9taW5nXCIsXG5cdFx0XCJYaWFuIDE5ODBcIjogXCJYaWFuIDE5ODBcIixcblx0XHRkb25lOiBcIkNvbXBsZXRhdG9cIixcblx0XHRub1Jlc3VsdHM6IFwiTmVzc3VuIHJpc3VsdGF0byB0cm92YXRvXCIsXG5cdFx0c2VhcmNoUGxhY2Vob2xkZXI6IFwiTm9tZSBvIFdLSURcIixcblx0XHRicm93c2VUZW1wbGF0ZTogXCJDZXJjYXJlIG1vZGVsbGkgZGkgZnVuemlvbmUgcmFzdGVyXCIsXG5cdFx0c2F2ZVRlbXBsYXRlOiBcIlNhbHZhIG1vZGVsbG8gZnVuemlvbmkgcmFzdGVyXCIsXG5cdFx0cHJldmlldzogXCJBbnRlcHJpbWFcIixcblx0XHRwcmV2aWV3RGVzY3JpcHRpb246IFwiVmlzdWFsaXp6YXJlIGluIGFudGVwcmltYSBpbCByaXN1bHRhdG8gcHJpbWEgZGkgZXNlZ3VpcmUgbCdhbmFsaXNpLlwiLFxuXHRcdHNob3dQcmV2aWV3OiBcIk1vc3RyYSBhbnRlcHJpbWFcIixcblx0XHRwcmV2aWV3TGF5ZXI6IFwiTGF5ZXIgZGkgYW50ZXByaW1hICR7bnVtYmVyfVwiLFxuXHRcdG5ld1ByZXZpZXc6IFwiTnVvdmEgYW50ZXByaW1hXCIsXG5cdFx0cHJldmlld1BvcHVwOiBcIkF0dGl2YXJlIGwnYW50ZXByaW1hIGRlaSByaXN1bHRhdGkgZGVsbCdhbmFsaXNpIGluIGJhc2UgYWkgcGFyYW1ldHJpIGRpIGlucHV0LlwiLFxuXHRcdHVwZGF0ZVByZXZpZXdMYXllcjogXCJBZ2dpb3JuYSBsYXllciBkaSBhbnRlcHJpbWEgc2VsZXppb25hdG9cIixcblx0XHRjcmVhdGVQcmV2aWV3TGF5ZXI6IFwiQ3JlYSBudW92byBsYXllciBkaSBhbnRlcHJpbWFcIixcblx0XHRtYXhpbXVtUHJldmlld0FsbG93ZWQ6IFwiTnVtZXJvIG1hc3NpbW8gZGkgbGF5ZXIgZGkgYW50ZXByaW1hIGNvbnNlbnRpdGk6ICR7bWF4Q291bnR9XCIsXG5cdFx0cHJldmlld0ZhaWx1cmU6IFwiUXVlc3RvIGxheWVyIGRpIGFudGVwcmltYSBub24gw6ggZGlzcG9uaWJpbGUuIENvbnRyb2xsYXJlIGkgcGFyYW1ldHJpIGRpIGlucHV0IGUgYWdnaW9ybmFyZSBudW92YW1lbnRlIHF1ZXN0byBsYXllciBkaSBhbnRlcHJpbWEuXCIsXG5cdFx0aGVhZGVyOiBcIlNlbGV6aW9uYSBlbGVtZW50b1wiLFxuXHRcdGNvbnRlbnQ6IFwiU29ubyBwcmVzZW50aSBtb2RpZmljaGUgbm9uIHNhbHZhdGUgaW4gJHtyZnRUaXRsZX0uIFNlIHNpIHJpY29taW5jaWEgY29uIHVuIG51b3ZvIG1vZGVsbG8sIHF1ZXN0ZSBtb2RpZmljaGUgYW5kcmFubm8gcGVyc2UuXCIsXG5cdFx0ZG9udFNhdmU6IFwiTm9uIHNhbHZhcmVcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiQ29udGludWFcIixcblx0XHRzdHJldGNoOiBcIkFkYXR0YSBhIGZpbmVzdHJhXCIsXG5cdFx0cGFuOiBcIlBhblwiLFxuXHRcdG5ld1RlbXBsYXRlOiBcIkNyZWEgbnVvdm8gbW9kZWxsb1wiLFxuXHRcdG9wZW5UZW1wbGF0ZTogXCJBcHJpIG1vZGVsbG9cIixcblx0XHRhZGRGdW5jdGlvbjogXCJBZ2dpdW5naSBmdW56aW9uaSByYXN0ZXJcIixcblx0XHRhZGRDb25zdGFudDogXCJBZ2dpdW5naSBjb3N0YW50ZVwiLFxuXHRcdGFkZFJhc3RlcjogXCJBZ2dpdW5naSB2YXJpYWJpbGUgcmFzdGVyXCIsXG5cdFx0bW92ZTogXCJTcG9zdGFcIixcblx0XHR6b29tOiBcIlpvb21cIixcblx0XHRzYXZlQXM6IFwiU2FsdmFyZSBjb21lXCIsXG5cdFx0Y2xlYXI6IFwiQXp6ZXJhXCIsXG5cdFx0YWRkUmFzdGVyRnVuY3Rpb25UaXRsZTogXCJBZ2dpdW5naSBmdW56aW9uaSByYXN0ZXJcIixcblx0XHR0ZW1wbGF0ZVByb3BlcnRpZXNUaXRsZTogXCJQcm9wcmlldMOgIG1vZGVsbG9cIixcblx0XHRicm93c2VSRlQ6IFwiQ2VyY2FyZSBtb2RlbGxpIGRpIGZ1bnppb25lIHJhc3RlclwiLFxuXHRcdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiU3RydW1lbnRvIGRpIGFuYWxpc2kgJHt0b29sVGl0bGV9LlwiLFxuXHRcdG9wZW5Ub29sVGV4dDogXCJBcHJpIHN0cnVtZW50b1wiLFxuXHRcdHRvb2xEcm9wZG93blRleHQ6IFwiRWxlbmNvIGEgZGlzY2VzYSBkZWdsaSBzdHJ1bWVudGlcIixcblx0XHRhZGRUb01hcDogXCJDb25mZXJtYXJlIGUgYWdnaXVuZ2VyZSBhbGxhIG1hcHBhXCIsXG5cdFx0Y29uZmlybTogXCJDb25mZXJtYVwiLFxuXHRcdHNlbGVjdDogXCJTZWxlemlvbmFcIixcblx0XHRzZWxlY3RUYXNrOiBcIlNlbGV6aW9uYSBhdHRpdml0w6BcIixcblx0XHR1bnN1cHBvcnRlZExheWVyOiBcIlF1ZXN0byBwYXJhbWV0cm8gbm9uIHN1cHBvcnRhIGkgc2VndWVudGkgbGF5ZXI6ICR7bGF5ZXJOYW1lfS5cIixcblx0XHR2aWV3RGV0YWlsczogXCJWaXN1YWxpenphIGkgZGV0dGFnbGkgY29tcGxldGkgZGVsbOKAmWVsZW1lbnRvXCIsXG5cdFx0cmVuYW1lOiBcIlJpbm9taW5hXCIsXG5cdFx0ZHVwbGljYXRlOiBcIkR1cGxpY2FcIixcblx0XHRsYXVuY2g6IFwiQXByaSBwZXIgZXNlZ3VpcmVcIixcblx0XHR0ZW1wbGF0ZUVkaXRvcjogXCJFZGl0b3IgbW9kZWxsb1wiLFxuXHRcdGNyZWF0ZUl0ZW06IFwiU2FsdmEgbW9kZWxsbyBmdW56aW9uaSByYXN0ZXJcIixcblx0XHRhY3Rpb25MYWJlbDogXCJGaWx0cm9cIixcblx0XHRmaWx0ZXJQb3BvdmVySGVhZGluZzogXCJGaWx0cmEgZnVuemlvbmlcIixcblx0XHRkZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXI6IFwiQ2VyY2FyZSBwZXIgbm9tZVwiLFxuXHRcdHNldHRpbmdzOiBcIkltcG9zdGF6aW9uaVwiLFxuXHRcdHN1bW1hcnk6IFwiUmllcGlsb2dvXCIsXG5cdFx0ZGVmaW5pdGlvblF1ZXJ5OiBcIkludGVycm9nYXppb25lIGRpIGRlZmluaXppb25lXCIsXG5cdFx0bWF0Y2hWYXJpYWJsZXM6IFwiQWJiaW5hIHZhcmlhYmlsaVwiLFxuXHRcdHVuaW9uRGltZW5zaW9uOiBcIkRpbWVuc2lvbmUgdW5pb25lXCIsXG5cdFx0bmFtZUVkaXRvclBsYWNlaG9sZGVyOiBcIkluc2VyaXNjaSB0aXRvbG9cIixcblx0XHRzdW1tYXJ5RWRpdG9yUGxhY2Vob2xkZXI6IFwiSW5zZXJpc2NpIHVuYSBicmV2ZSBkZXNjcml6aW9uZS5cIixcblx0XHRkZWZpbml0aW9uUXVlcnlQbGFjZWhvbGRlcjogXCJJbnNlcmlzY2kuLi5cIixcblx0XHR1cGxvYWQ6IFwiQ2FyaWNhXCIsXG5cdFx0Y2hvb3NlSW1hZ2U6IFwiQ2xpY2NhIHBlciBzY2VnbGllcmUgdW4gZmlsZVwiLFxuXHRcdHVwZGF0ZTogXCJBZ2dpb3JuYVwiLFxuXHRcdHRodW1ibmFpbEVycm9yczoge1xuXHRcdFx0d3JvbmdJbWFnZVR5cGU6IFwiVGlwbyBkaSBpbW1hZ2luZSBlcnJhdG8gc2VsZXppb25hdG9cIixcblx0XHRcdG5vdEF2YWlsYWJsZTogXCJUaHVtYm5haWwgbm9uIGRpc3BvbmliaWxlXCIsXG5cdFx0XHRsb2FkRXJyb3I6IFwiSW1wb3NzaWJpbGUgY2FyaWNhcmUgbCdpbW1hZ2luZVwiLFxuXHRcdFx0Y2hvb3NlRmlsZTogXCJDbGljY2EgcGVyIHNjZWdsaWVyZSBpbCBmaWxlXCJcblx0XHR9XG5cdH1cbn07XG5jb25zdCBjb3B5ID0gXCJDb3BpYVwiO1xuY29uc3Qgc2F2ZSA9IFwiU2FsdmFcIjtcbmNvbnN0IHRpdGxlID0gXCJUaXRvbG9cIjtcbmNvbnN0IGZvbGRlciA9IFwiQ2FydGVsbGFcIjtcbmNvbnN0IHRhZ3MgPSBcIlRhZ1wiO1xuY29uc3Qgc2F2aW5nTWVzc2FnZSA9IFwiU2FsdmF0YWdnaW8gZGVsbOKAmWVsZW1lbnRvIGluXCI7XG5jb25zdCBzaGFyZVdpdGggPSBcIkNvbmRpdmlkaSBjb25cIjtcbmNvbnN0IHNoYXJlID0gXCJDb25kaXZpZGlcIjtcbmNvbnN0IHNldFNoYXJpbmdMZXZlbCA9IFwiSW1wb3N0YSBpbCBsaXZlbGxvIGRpIGNvbmRpdmlzaW9uZVwiO1xuY29uc3Qgc2V0R3JvdXBTaGFyaW5nID0gXCJJbXBvc3RhIGxhIGNvbmRpdmlzaW9uZSBkZWwgZ3J1cHBvXCI7XG5jb25zdCBvd25lciA9IFwiUHJvcHJpZXRhcmlvXCI7XG5jb25zdCBvcmdhbml6YXRpb24gPSBcIk9yZ2FuaXp6YXppb25lXCI7XG5jb25zdCBldmVyeW9uZSA9IFwiVHV0dGkgKHB1YmJsaWNhKVwiO1xuY29uc3QgZ3JvdXBzID0gXCJHcnVwcGk6XCI7XG5jb25zdCB0eXBlID0gXCJUaXBvXCI7XG5jb25zdCBtb3NhaWMgPSBcIk1vc2FpY1wiO1xuY29uc3QgaXRlbUdyb3VwID0gXCJHcnVwcG8gZGkgZWxlbWVudGlcIjtcbmNvbnN0IGl0ZW0gPSBcIkVsZW1lbnRvXCI7XG5jb25zdCBkZWZpbml0aW9uUXVlcnkgPSBcIkRlZmluaXRpb24gUXVlcnlcIjtcbmNvbnN0IGdyb3VwSXRlbXNCeSA9IFwiUmFnZ3J1cHBhIGVsZW1lbnRpIHBlclwiO1xuY29uc3QgZ3JvdXBGaWVsZE5hbWUgPSBcIk5vbWUgY2FtcG8gZ3J1cHBvXCI7XG5jb25zdCB0YWdGaWVsZE5hbWUgPSBcIk5vbWUgY2FtcG8gdGFnXCI7XG5jb25zdCBub1RpdGxlVGFnRXJyb3JNc2cgPSBcIlNwZWNpZmljYXJlIHVuIHRpdG9sbyBwZXIgbOKAmWVsZW1lbnRvIGUgaSB0YWcgcGVyIGNvbnNlbnRpcmUgZGkgaW5kaXZpZHVhcmUgbGEgbWFwcGEgbmVsbGUgcmljZXJjaGUuXCI7XG5jb25zdCBub1RpdGxlRXJyb3JNc2cgPSBcIlNwZWNpZmljYXJlIHVuIHRpdG9sbyBwZXIgbCdlbGVtZW50by5cIjtcbmNvbnN0IG5vVGFnRXJyb3JNc2cgPSBcIlNwZWNpZmljYXJlIGFsbWVubyB1biB0YWcgcGVyIGNvbnNlbnRpcmUgZGkgaW5kaXZpZHVhcmUgbOKAmWVsZW1lbnRvIGNvcnJlbnRlIG5lbGxlIHJpY2VyY2hlLlwiO1xuY29uc3QgZXJyb3IgPSBcIkVycm9yZVwiO1xuY29uc3Qgd2FybmluZyA9IFwiQXZ2aXNvXCI7XG5jb25zdCBzdWNjZXNzID0gXCJPcGVyYXppb25lIHJpdXNjaXRhXCI7XG5jb25zdCBkZXRhaWxzID0gXCJEZXR0YWdsaTpcIjtcbmNvbnN0IHRyeUFnYWluID0gXCJSaXByb3ZhXCI7XG5jb25zdCB0b29sTW9kZWxlciA9IHtcblx0c2F2ZTogXCJTYWx2YVwiLFxuXHRlZGl0UHJvcGVydGllczogXCJNb2RpZmljYSBwcm9wcmlldMOgXCIsXG5cdHNhdmVBczogXCJTYWx2YSBjb24gbm9tZVwiLFxuXHRzYXZpbmdOb3RpZmljYXRpb246IFwiU2FsdmF0YWdnaW8gZGVsbGUgbW9kaWZpY2hlIGFwcG9ydGF0ZSBhbGzigJllbGVtZW50byBpbiBjb3Jzby4uLlwiLFxuXHRzYXZpbmdUaXRsZTogXCJTYWx2YXRhZ2dpbyBpbiBjb3Jzb1wiLFxuXHRzYXZlRmFpbGVkTWVzc2FnZTogXCJJbXBvc3NpYmlsZSBzYWx2YXJlIGxlIG1vZGlmaWNoZS5cIixcblx0c2F2ZVdpdGhFcnJvcnNNZXNzYWdlOiBcIkxlIG1vZGlmaWNoZSBzb25vIHN0YXRlIHNhbHZhdGUgY29uIGkgc2VndWVudGkgZXJyb3JpLlwiLFxuXHR2aWV3SXRlbU1lc3NhZ2U6IFwiVmlzdWFsaXp6YSBlbGVtZW50byBzYWx2YXRvXCIsXG5cdGhlcmU6IFwicXVpLlwiLFxuXHRpdGVtQ3JlYXRlZE1lc3NhZ2U6IFwiw4ggc3RhdG8gY3JlYXRvIHVuIG51b3ZvIGVsZW1lbnRvLlwiLFxuXHRjbGlja1RvVmlld0l0ZW1NZXNzYWdlOiBcIkZhcmUgY2xpYyBzdSBPSyBwZXIgdmlzdWFsaXp6YXJlIGxhIHBhZ2luYSBkZWkgZGV0dGFnbGkgZGVsbCdlbGVtZW50bzsgZmFyZSBjbGljIHN1IEFubnVsbGEgcGVyIGNvbnRpbnVhcmUuXCIsXG5cdHJlYWRpbmdGYWlsZWQ6IFwiSW1wb3NzaWJpbGUgY2FyaWNhcmUgaWwgbW9kZWxsbyBkaSBmdW56aW9uZSByYXN0ZXIgc2VsZXppb25hdG8uXCIsXG5cdGZhaWxlZFRvTG9hZFhNTDogXCJJbXBvc3NpYmlsZSBjYXJpY2FyZSBpbCBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciBzZWxlemlvbmF0byBpbiBmb3JtYXRvIFhNTC5cIixcblx0bGVhcm5Nb3JlOiBcIlVsdGVyaW9yaSBpbmZvcm1hemlvbmlcIixcblx0b3ZlcndyaXRlVGl0bGU6IFwiQ29uZmVybWEgc292cmFzY3JpdHR1cmFcIixcblx0b3ZlcndyaXRlTWVzc2FnZTogXCJTb3ZyYXNjcml2ZXJlIGwnZWxlbWVudG8gZXNpc3RlbnRlP1wiLFxuXHRvdmVyd3JpdGVTdWNjZXNzTWVzc2FnZTogXCJMJ2VsZW1lbnRvIMOoIHN0YXRvIGFnZ2lvcm5hdG8uXCJcbn07XG5jb25zdCB0b29sRWRpdG9yID0ge1xuXHRydW46IFwiRXNlZ3VpXCIsXG5cdHNhdmU6IFwiU2FsdmFcIixcblx0ZGVsZXRlU2VsZWN0ZWQ6IFwiRWxpbWluYSBlbGVtZW50aSBzZWxlemlvbmF0aVwiLFxuXHRhZGRSYXN0ZXI6IFwiQWdnaXVuZ2kgcmFzdGVyXCIsXG5cdGFkZFNjYWxhcjogXCJBZ2dpdW5naSBzY2FsYXJlXCIsXG5cdGxheW91dDogXCJMYXlvdXQgYXV0b21hdGljb1wiLFxuXHRlcnJvclRpdGxlOiBcIkVycm9yZVwiLFxuXHRpbnZhbGlkVG9vbE1lc3NhZ2U6IFwiTW9kZWxsbyBkaSBmdW56aW9uZSByYXN0ZXIgbm9uIHZhbGlkby5cIixcblx0b3V0OiBcIlVzY2l0YVwiLFxuXHR6b29tSW46IFwiWm9vbSBhdmFudGlcIixcblx0em9vbU91dDogXCJab29tIGluZGlldHJvXCIsXG5cdHpvb21Ub0ZpdDogXCJBZGF0dGEgYSBmaW5lc3RyYVwiLFxuXHRwYW5PbjogXCJQYXNzYSBhbGxhIG1vZGFsaXTDoCBwYW5cIixcblx0cGFuT2ZmOiBcIkRpc2F0dGl2YSBtb2RhbGl0w6AgcGFuXCIsXG5cdGRlZmF1bHRNb2RlbE5hbWU6IFwiTW9kZWxsbyBzdHJ1bWVudG9cIixcblx0ZGVmYXVsdFJhc3Rlck5hbWU6IFwiUmFzdGVyXCJcbn07XG5jb25zdCB0b29sRGV0YWlsc0VkaXRvciA9IHtcblx0ZGVmYXVsdFRvb2xOYW1lOiBcIk1vZGVsbG8gZnVuemlvbmUgcmFzdGVyXCIsXG5cdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiQWdnaXVuZ2VyZSB1biBicmV2ZSByaWVwaWxvZ28gZGVsbGEgZnVuemlvbmUgcmFzdGVyLlwiLFxuXHRkZWZhdWx0SGVscFRleHQ6IFwiRmFyZSBjbGljIHN1bGwnaWNvbmEgR3VpZGEgcGVyIG1vZGlmaWNhcmUgaWwgdGVzdG8gZGVsbGEgZ3VpZGFcIixcblx0ZWRpdEhlbHBUaXRsZTogXCJBaXV0byBtb2RpZmljYVwiLFxuXHRzYXZlTGFiZWw6IFwiU2FsdmFcIixcblx0Y2FuY2VsTGFiZWw6IFwiQ2FuY2VsbGFcIixcblx0dGh1bWJuYWlsOiB7XG5cdFx0d3JvbmdJbWFnZVR5cGU6IFwiVGlwbyBkaSBpbW1hZ2luZSBlcnJhdG8gc2VsZXppb25hdG9cIixcblx0XHRub3RBdmFpbGFibGU6IFwiTWluaWF0dXJhIG5vbiBkaXNwb25pYmlsZVwiLFxuXHRcdGxvYWRFcnJvcjogXCJDYXJpY2FtZW50byBkZWxs4oCZaW1tYWdpbmUgbm9uIHJpdXNjaXRvXCIsXG5cdFx0Y2hvb3NlRmlsZTogXCJGYXJlIGNsaWMgcGVyIHNjZWdsaWVyZSBpbCBmaWxlXCJcblx0fVxufTtcbmNvbnN0IHNhdmVVdGlscyA9IHtcblx0dGh1bWJuYWlsOiBcIkFudGVwcmltYVwiLFxuXHRzaGFyaW5nOiBcIkNvbmRpdmlzaW9uZVwiXG59O1xuY29uc3QgY2xvc2UgPSBcIkNoaXVkaVwiO1xuY29uc3QgdW5zYXZlZFdhcm5pbmdFeGlzdGluZyA9IFwiU2FsdmFyZSBsZSBtb2RpZmljaGUgYWxs4oCZZWxlbWVudG8gPGI+JHtpdGVtVGl0bGV9PC9iPj9cIjtcbmNvbnN0IHVuc2F2ZWRXYXJuaW5nTmV3ID0gXCJTYWx2YXJlIGxlIG1vZGlmaWNoZT9cIjtcbmNvbnN0IHNhdmVBcyA9IFwiU2FsdmEgY29uIG5vbWVcIjtcbmNvbnN0IGRvbnRTYXZlID0gXCJOb24gc2FsdmFyZVwiO1xuY29uc3QgdW5zYXZlZFRpdGxlID0gXCJNb2RpZmljaGUgbm9uIHNhbHZhdGVcIjtcbmNvbnN0IGludmFsaWRSRlRNZXNzYWdlID0gXCJJbCBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciBjcmVhdG8gbm9uIMOoIHZhbGlkby5cIjtcbmNvbnN0IGVycm9yVGl0bGUgPSBcIkVycm9yZVwiO1xuY29uc3QgYnJlYWRjcnVtYiA9IFwiRWRpdG9yIGZ1bnppb25pIHJhc3RlclwiO1xuY29uc3QgYnJlYWRjcnVtYkVkaXRvciA9IFwiQ29udGVudXRpID4gRWRpdG9yIGZ1bnppb25pIHJhc3RlclwiO1xuY29uc3Qgdmlld2VyTW9kZVRpdGxlID0gXCJTb2xvIGxldHR1cmFcIjtcbmNvbnN0IHZpZXdlck1vZGVNZXNzYWdlID0gXCJMYSB2b2NlIGRlbCBtb2RlbGxvIGRpIGZ1bnppb25lIHJhc3RlciDDqCBkaSBzb2xhIGxldHR1cmEuIExlIG1vZGlmaWNoZSBub24gcG9zc29ubyBlc3NlcmUgc2FsdmF0ZS5cIjtcbmNvbnN0IHVzZXJTdGFydERpcmVjdGlvbiA9IFwiU2VsZXppb25hcmUgdW5hIGZ1bnppb25lIHBlciBjb21pbmNpYXJlIGEgY29zdHJ1aXJlIHVuIG1vZGVsbG8gZGkgZnVuemlvbmUgcmFzdGVyLlwiO1xuY29uc3Qgc2VsZWN0RnVuY3Rpb24gPSBcIkFnZ2l1bmdpIGZ1bnppb25lXCI7XG5jb25zdCBkZXNlbGVjdEZ1bmN0aW9uID0gXCJSaW11b3ZpIGZ1bnppb25lXCI7XG5jb25zdCBkaWFsb2dUaXRsZSA9IFwiU2lzdGVtYVwiO1xuY29uc3QgY2F0ZWdvcnkgPSBcIkNhdGVnb3JpZVwiO1xuY29uc3Qgc2VhcmNoID0gXCJDZXJjYXJlIGZ1bnppb25pIHJhc3RlclwiO1xuY29uc3QgY2F0ZWdvcnlOYW1lcyA9IHtcblx0YW5hbHlzaXM6IFwiQW5hbGlzaVwiLFxuXHRhcHBlYXJhbmNlOiBcIkFzcGV0dG9cIixcblx0Y2xhc3NpZmljYXRpb246IFwiQ2xhc3NpZmljYXppb25lXCIsXG5cdGNvbnZlcnNpb246IFwiQ29udmVyc2lvbmVcIixcblx0Y29ycmVjdGlvbjogXCJDb3JyZXppb25lXCIsXG5cdGRhdGFNYW5hZ2VtZW50OiBcIkdlc3Rpb25lIGRhdGlcIixcblx0ZGlzdGFuY2U6IFwiRGlzdGFuemFcIixcblx0ZGlzdGFuY2VMZWdhY3k6IFwiRGlzdGFuemEgKHByZWNlZGVudGkpXCIsXG5cdGh5ZHJvbG9neTogXCJJZHJvbG9naWFcIixcblx0bWF0aDogXCJNYXRlbWF0aWNhXCIsXG5cdG1hdGhDb25kaXRpb25hbDogXCJNYXRlbWF0aWNhOiBDb25kaXppb25hbGVcIixcblx0bWF0aExvZ2ljYWw6IFwiTWF0ZW1hdGljYTogTG9naWNhXCIsXG5cdG1hdGhUcmlnb25vbWV0cmljOiBcIk1hdGVtYXRpY2E6IFRyaWdvbm9tZXRyaWFcIixcblx0cmVjbGFzczogXCJSaWNsYXNzaWZpY2FcIixcblx0c3RhdGlzdGljYWw6IFwiU3RhdGlzdGljb1wiLFxuXHRzdXJmYWNlOiBcIlN1cGVyZmljaWVcIlxufTtcbmNvbnN0IGNvbW1vblN0cmluZ3NfaXQgPSB7XG5cdG9rOiBvayxcblx0Y2FuY2VsOiBjYW5jZWwsXG5cdGVudGVyVVJMOiBlbnRlclVSTCxcblx0c2VydmljZVVSTDogc2VydmljZVVSTCxcblx0c2VsZWN0UmFzdGVyOiBzZWxlY3RSYXN0ZXIsXG5cdGZhaWxlZFRvTG9hZExheWVyOiBmYWlsZWRUb0xvYWRMYXllcixcblx0bG9hZGluZ0xheWVyOiBsb2FkaW5nTGF5ZXIsXG5cdHNlbGVjdEZlYXR1cmU6IHNlbGVjdEZlYXR1cmUsXG5cdGVudGVyRlVSTDogZW50ZXJGVVJMLFxuXHRhZGRSYXN0ZXI6IGFkZFJhc3Rlcixcblx0YWRkU2NhbGFyOiBhZGRTY2FsYXIsXG5cdHJhc3RlcjogcmFzdGVyLFxuXHRzY2FsYXI6IHNjYWxhcixcblx0ZGVmYXVsdE1vZGVsTmFtZTogZGVmYXVsdE1vZGVsTmFtZSxcblx0Z2VuZXJhbDogZ2VuZXJhbCxcblx0cGFyYW1ldGVyczogcGFyYW1ldGVycyxcblx0dmFyaWFibGVzOiB2YXJpYWJsZXMsXG5cdG5hbWU6IG5hbWUsXG5cdGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcblx0cGFyYW1ldGVyOiBwYXJhbWV0ZXIsXG5cdGlzUHVibGljOiBpc1B1YmxpYyxcblx0aXNEYXRhc2V0OiBpc0RhdGFzZXQsXG5cdHVua25vd25QaXhlbFR5cGU6IHVua25vd25QaXhlbFR5cGUsXG5cdG91dHB1dFBpeGVsVHlwZTogb3V0cHV0UGl4ZWxUeXBlLFxuXHR1OFBpeGVsVHlwZTogdThQaXhlbFR5cGUsXG5cdHM4UGl4ZWxUeXBlOiBzOFBpeGVsVHlwZSxcblx0dTE2UGl4ZWxUeXBlOiB1MTZQaXhlbFR5cGUsXG5cdHMxNlBpeGVsVHlwZTogczE2UGl4ZWxUeXBlLFxuXHR1MzJQaXhlbFR5cGU6IHUzMlBpeGVsVHlwZSxcblx0czMyUGl4ZWxUeXBlOiBzMzJQaXhlbFR5cGUsXG5cdGYzMlBpeGVsVHlwZTogZjMyUGl4ZWxUeXBlLFxuXHRmNjRQaXhlbFR5cGU6IGY2NFBpeGVsVHlwZSxcblx0cHJvcGVydGllczogcHJvcGVydGllcyxcblx0bXVsdGlkaW1lbnNpb25hbFJ1bGVzOiBtdWx0aWRpbWVuc2lvbmFsUnVsZXMsXG5cdG1hdGNoVmFyaWFibGVzOiBtYXRjaFZhcmlhYmxlcyxcblx0dW5pb25EaW1lbnNpb25zOiB1bmlvbkRpbWVuc2lvbnMsXG5cdHJhc3RlckZ1bmN0aW9uRWRpdG9yOiByYXN0ZXJGdW5jdGlvbkVkaXRvcixcblx0cmZ4TGljZW5zZUluZm86IHJmeExpY2Vuc2VJbmZvLFxuXHRyYXN0ZXJGdW5jdGlvbnM6IHJhc3RlckZ1bmN0aW9ucyxcblx0Y29weTogY29weSxcblx0c2F2ZTogc2F2ZSxcblx0dGl0bGU6IHRpdGxlLFxuXHRmb2xkZXI6IGZvbGRlcixcblx0dGFnczogdGFncyxcblx0c2F2aW5nTWVzc2FnZTogc2F2aW5nTWVzc2FnZSxcblx0c2hhcmVXaXRoOiBzaGFyZVdpdGgsXG5cdHNoYXJlOiBzaGFyZSxcblx0c2V0U2hhcmluZ0xldmVsOiBzZXRTaGFyaW5nTGV2ZWwsXG5cdHNldEdyb3VwU2hhcmluZzogc2V0R3JvdXBTaGFyaW5nLFxuXHRvd25lcjogb3duZXIsXG5cdG9yZ2FuaXphdGlvbjogb3JnYW5pemF0aW9uLFxuXHRldmVyeW9uZTogZXZlcnlvbmUsXG5cdGdyb3VwczogZ3JvdXBzLFxuXHR0eXBlOiB0eXBlLFxuXHRtb3NhaWM6IG1vc2FpYyxcblx0aXRlbUdyb3VwOiBpdGVtR3JvdXAsXG5cdGl0ZW06IGl0ZW0sXG5cdGRlZmluaXRpb25RdWVyeTogZGVmaW5pdGlvblF1ZXJ5LFxuXHRncm91cEl0ZW1zQnk6IGdyb3VwSXRlbXNCeSxcblx0Z3JvdXBGaWVsZE5hbWU6IGdyb3VwRmllbGROYW1lLFxuXHR0YWdGaWVsZE5hbWU6IHRhZ0ZpZWxkTmFtZSxcblx0bm9UaXRsZVRhZ0Vycm9yTXNnOiBub1RpdGxlVGFnRXJyb3JNc2csXG5cdG5vVGl0bGVFcnJvck1zZzogbm9UaXRsZUVycm9yTXNnLFxuXHRub1RhZ0Vycm9yTXNnOiBub1RhZ0Vycm9yTXNnLFxuXHRlcnJvcjogZXJyb3IsXG5cdHdhcm5pbmc6IHdhcm5pbmcsXG5cdHN1Y2Nlc3M6IHN1Y2Nlc3MsXG5cdGRldGFpbHM6IGRldGFpbHMsXG5cdHRyeUFnYWluOiB0cnlBZ2Fpbixcblx0dG9vbE1vZGVsZXI6IHRvb2xNb2RlbGVyLFxuXHR0b29sRWRpdG9yOiB0b29sRWRpdG9yLFxuXHR0b29sRGV0YWlsc0VkaXRvcjogdG9vbERldGFpbHNFZGl0b3IsXG5cdHNhdmVVdGlsczogc2F2ZVV0aWxzLFxuXHRjbG9zZTogY2xvc2UsXG5cdHVuc2F2ZWRXYXJuaW5nRXhpc3Rpbmc6IHVuc2F2ZWRXYXJuaW5nRXhpc3RpbmcsXG5cdHVuc2F2ZWRXYXJuaW5nTmV3OiB1bnNhdmVkV2FybmluZ05ldyxcblx0c2F2ZUFzOiBzYXZlQXMsXG5cdGRvbnRTYXZlOiBkb250U2F2ZSxcblx0dW5zYXZlZFRpdGxlOiB1bnNhdmVkVGl0bGUsXG5cdGludmFsaWRSRlRNZXNzYWdlOiBpbnZhbGlkUkZUTWVzc2FnZSxcblx0ZXJyb3JUaXRsZTogZXJyb3JUaXRsZSxcblx0YnJlYWRjcnVtYjogYnJlYWRjcnVtYixcblx0YnJlYWRjcnVtYkVkaXRvcjogYnJlYWRjcnVtYkVkaXRvcixcblx0dmlld2VyTW9kZVRpdGxlOiB2aWV3ZXJNb2RlVGl0bGUsXG5cdHZpZXdlck1vZGVNZXNzYWdlOiB2aWV3ZXJNb2RlTWVzc2FnZSxcblx0dXNlclN0YXJ0RGlyZWN0aW9uOiB1c2VyU3RhcnREaXJlY3Rpb24sXG5cdHNlbGVjdEZ1bmN0aW9uOiBzZWxlY3RGdW5jdGlvbixcblx0ZGVzZWxlY3RGdW5jdGlvbjogZGVzZWxlY3RGdW5jdGlvbixcblx0ZGlhbG9nVGl0bGU6IGRpYWxvZ1RpdGxlLFxuXHRjYXRlZ29yeTogY2F0ZWdvcnksXG5cdHNlYXJjaDogc2VhcmNoLFxuXHRjYXRlZ29yeU5hbWVzOiBjYXRlZ29yeU5hbWVzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb21tb25TdHJpbmdzX2l0O1xuZXhwb3J0IHsgYWRkUmFzdGVyLCBhZGRTY2FsYXIsIGJyZWFkY3J1bWIsIGJyZWFkY3J1bWJFZGl0b3IsIGNhbmNlbCwgY2F0ZWdvcnksIGNhdGVnb3J5TmFtZXMsIGNsb3NlLCBjb3B5LCBkZWZhdWx0TW9kZWxOYW1lLCBkZWZpbml0aW9uUXVlcnksIGRlc2NyaXB0aW9uLCBkZXNlbGVjdEZ1bmN0aW9uLCBkZXRhaWxzLCBkaWFsb2dUaXRsZSwgZG9udFNhdmUsIGVudGVyRlVSTCwgZW50ZXJVUkwsIGVycm9yLCBlcnJvclRpdGxlLCBldmVyeW9uZSwgZjMyUGl4ZWxUeXBlLCBmNjRQaXhlbFR5cGUsIGZhaWxlZFRvTG9hZExheWVyLCBmb2xkZXIsIGdlbmVyYWwsIGdyb3VwRmllbGROYW1lLCBncm91cEl0ZW1zQnksIGdyb3VwcywgaW52YWxpZFJGVE1lc3NhZ2UsIGlzRGF0YXNldCwgaXNQdWJsaWMsIGl0ZW0sIGl0ZW1Hcm91cCwgbG9hZGluZ0xheWVyLCBtYXRjaFZhcmlhYmxlcywgbW9zYWljLCBtdWx0aWRpbWVuc2lvbmFsUnVsZXMsIG5hbWUsIG5vVGFnRXJyb3JNc2csIG5vVGl0bGVFcnJvck1zZywgbm9UaXRsZVRhZ0Vycm9yTXNnLCBvaywgb3JnYW5pemF0aW9uLCBvdXRwdXRQaXhlbFR5cGUsIG93bmVyLCBwYXJhbWV0ZXIsIHBhcmFtZXRlcnMsIHByb3BlcnRpZXMsIHJhc3RlciwgcmFzdGVyRnVuY3Rpb25FZGl0b3IsIHJhc3RlckZ1bmN0aW9ucywgcmZ4TGljZW5zZUluZm8sIHMxNlBpeGVsVHlwZSwgczMyUGl4ZWxUeXBlLCBzOFBpeGVsVHlwZSwgc2F2ZSwgc2F2ZUFzLCBzYXZlVXRpbHMsIHNhdmluZ01lc3NhZ2UsIHNjYWxhciwgc2VhcmNoLCBzZWxlY3RGZWF0dXJlLCBzZWxlY3RGdW5jdGlvbiwgc2VsZWN0UmFzdGVyLCBzZXJ2aWNlVVJMLCBzZXRHcm91cFNoYXJpbmcsIHNldFNoYXJpbmdMZXZlbCwgc2hhcmUsIHNoYXJlV2l0aCwgc3VjY2VzcywgdGFnRmllbGROYW1lLCB0YWdzLCB0aXRsZSwgdG9vbERldGFpbHNFZGl0b3IsIHRvb2xFZGl0b3IsIHRvb2xNb2RlbGVyLCB0cnlBZ2FpbiwgdHlwZSwgdTE2UGl4ZWxUeXBlLCB1MzJQaXhlbFR5cGUsIHU4UGl4ZWxUeXBlLCB1bmlvbkRpbWVuc2lvbnMsIHVua25vd25QaXhlbFR5cGUsIHVuc2F2ZWRUaXRsZSwgdW5zYXZlZFdhcm5pbmdFeGlzdGluZywgdW5zYXZlZFdhcm5pbmdOZXcsIHVzZXJTdGFydERpcmVjdGlvbiwgdmFyaWFibGVzLCB2aWV3ZXJNb2RlTWVzc2FnZSwgdmlld2VyTW9kZVRpdGxlLCB3YXJuaW5nIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi1zdHJpbmdzLml0LWVmYmE2ZjliLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==