"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_relati-5dfdc2"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/relationship-b72d7d97.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/relationship-b72d7d97.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ createRelationshipRendererFromExisting),
/* harmony export */   c: () => (/* binding */ createRelationshipRenderer),
/* harmony export */   u: () => (/* binding */ updateRelationshipRenderer)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




/**
 * Updates the layer with a Color renderer with default settings
 * @param options: options
 */
function createRelationshipRenderer(options) {
    var _a, _b;
    const { layer: smLayer, mapImageSublayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    let relationshipScheme = options.relationshipScheme;
    if (!relationshipScheme && ["relationship", "relationship-size"].indexOf(rendererType) > -1) {
        relationshipScheme = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a0)();
    }
    options = options || {};
    if (rendererType === "relationship-size") {
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).clone();
        const authInfo = renderer.authoringInfo;
        if (authInfo &&
            ((_a = options.fieldInfos) === null || _a === void 0 ? void 0 : _a.length) > 1 &&
            options.fieldInfos[0].field == authInfo.field1.field &&
            options.fieldInfos[1].field == authInfo.field2.field) {
            // re-use relationship renderer; remove size
            renderer.visualVariables = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.n)(renderer, "size");
            renderer.authoringInfo.visualVariables = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.o)(renderer, "size");
            if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer)) {
                // switch markers to polygons
                const polygonSymbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView);
                const infos = renderer.uniqueValueInfos.slice();
                infos.map((valueInfo) => {
                    const color = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(valueInfo.symbol);
                    valueInfo.symbol = polygonSymbol.clone();
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(valueInfo.symbol, color);
                });
                renderer.uniqueValueInfos = infos;
            }
            return Promise.resolve({ renderer });
        }
    }
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer));
    const config = {
        layer,
        view: mapView,
        field1: { field: options.fieldInfos[0].field },
        field2: { field: options.fieldInfos[1].field },
        classificationMethod: "quantile",
        numClasses: 3,
        focus: "HH",
        relationshipScheme,
        outlineOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.outlineOptimizationEnabled)
                ? options.outlineOptimizationEnabled
                : true,
        sizeOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled)
                ? options.sizeOptimizationEnabled
                : true,
        legendOptions: options.legendOptions,
        defaultSymbolEnabled: false,
        forBinning: ((_b = layer.featureReduction) === null || _b === void 0 ? void 0 : _b.type) === "binning"
    };
    //console.log("createRelationshipRenderer", config);
    return modules.RelationshipCreator.createRenderer(config).then((result) => {
        //console.log("createRelationshipRenderer-success", result);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer);
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
/**
 * Creates a Relationship renderer with settings from current renderer
 */
function createRelationshipRendererFromExisting(options) {
    var _a;
    const { layer: smLayer, mapImageSublayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const authInfo = renderer.authoringInfo;
    // are we coming from a relationship-size renderer?
    const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size");
    if (options.fieldInfos &&
        options.fieldInfos.length > 1 &&
        options.fieldInfos[0].field == authInfo.field1.field &&
        options.normalizationField1 === authInfo.field1.normalizationField &&
        options.fieldInfos[1].field == authInfo.field2.field &&
        options.normalizationField2 === authInfo.field2.normalizationField) {
        // no changes to fields
        delete options.fieldInfos;
        delete options.normalizationField1;
        delete options.normalizationField2;
        if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.R)(options) && !sizeVisVar) {
            // nothing really changes
            return Promise.resolve({ renderer: renderer.clone() });
        }
    }
    let relationshipScheme = options.relationshipScheme;
    if (!relationshipScheme && ["relationship", "relationship-size"].indexOf(rendererType) > -1) {
        relationshipScheme = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a0)();
    }
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)(renderer);
    let fieldInfo1 = options.fieldInfos
        ? options.fieldInfos[0]
        : {
            field: authInfo.field1.field,
            simpleFieldType: _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.NUMBER
        };
    let fieldInfo2 = options.fieldInfos
        ? options.fieldInfos[1]
        : {
            field: authInfo.field2.field,
            simpleFieldType: _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.NUMBER
        };
    const normalizationField1 = options.normalizationField1 !== undefined // null is used as a value
        ? options.normalizationField1
        : authInfo.field1.normalizationField;
    const normalizationField2 = options.normalizationField2 !== undefined // null is used as a value
        ? options.normalizationField2
        : authInfo.field2.normalizationField;
    const symbol = renderer.uniqueValueInfos && renderer.uniqueValueInfos.length ? renderer.uniqueValueInfos[0].symbol : null;
    const defaultSymbol = renderer.defaultSymbol;
    const defaultLabel = renderer.defaultLabel;
    const numClasses = options.numClasses ? options.numClasses : authInfo.numClasses;
    // TODO need to keep ramp
    return modules.RelationshipCreator.createRenderer({
        layer,
        view: mapView,
        field1: {
            field: fieldInfo1 ? fieldInfo1.field : renderer.field,
            normalizationField: normalizationField1
        },
        field2: {
            field: fieldInfo2 ? fieldInfo2.field : renderer.field,
            normalizationField: normalizationField2
        },
        classificationMethod: options.classificationMethod
            ? options.classificationMethod
            : authInfo.classificationMethod !== "manual"
                ? authInfo.classificationMethod
                : "quantile",
        numClasses,
        focus: options.focus ? options.focus : authInfo.focus,
        relationshipScheme,
        outlineOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.outlineOptimizationEnabled)
                ? options.outlineOptimizationEnabled
                : !!extras.sizeOutlineVisVar,
        sizeOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled)
                ? options.sizeOptimizationEnabled
                : !!extras.sizeAutoVisVar,
        legendOptions: options.legendOptions ? options.legendOptions : renderer.legendOptions,
        defaultSymbolEnabled: (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.defaultSymbolEnabled)
            ? options.defaultSymbolEnabled
            : !!renderer.defaultSymbol,
        forBinning: ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
    }).then((result) => {
        //console.log("RelationshipCreator.createRenderer", result);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer);
        if (symbol) {
            const infos = result.renderer.uniqueValueInfos;
            infos.forEach((info) => {
                // keep the same symbol style, not the color
                const sym = symbol.clone();
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(sym, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(info.symbol));
                info.symbol = sym;
            });
        }
        // keep old labels
        if (!options.numClasses || options.numClasses === authInfo.numClasses) {
            (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).uniqueValueInfos.forEach((oldInfo) => {
                result.renderer.uniqueValueInfos.forEach((newInfo) => {
                    if (oldInfo.value === newInfo.value) {
                        newInfo.label = oldInfo.label;
                    }
                });
            });
        }
        if (defaultSymbol) {
            result.renderer.defaultSymbol = defaultSymbol;
            result.renderer.defaultLabel = defaultLabel;
        }
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
/**
 * Updates a relationship renderer after changes to slider breaks, focus, color ramp
 */
function updateRelationshipRenderer(options) {
    const { layer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    options = options || {};
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const authInfo = renderer.authoringInfo;
    return modules.RelationshipCreator.updateRenderer({
        field1: authInfo.field1,
        field2: authInfo.field2,
        numClasses: options.numClasses ? options.numClasses : authInfo.numClasses,
        focus: options.focus ? (options.focus === "none" ? null : options.focus) : authInfo.focus,
        colors: options.colors,
        renderer
    });
}



//# sourceMappingURL=relationship-b72d7d97.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/typeSize-9d4c5d28.js":
/*!**************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/typeSize-9d4c5d28.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ createTypeSizeAgeRenderer),
/* harmony export */   b: () => (/* binding */ createTypeSizeAgeRendererFromExisting),
/* harmony export */   c: () => (/* binding */ createTypeSizeRenderer),
/* harmony export */   d: () => (/* binding */ createTypeSizeRendererFromExisting)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorSize-ce0ccdeb.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorSize-ce0ccdeb.js");
/* harmony import */ var _type_0ace5d2e_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./type-0ace5d2e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/type-0ace5d2e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */






/**
 * Updates the layer with a Color+size renderer with default settings
 * @param options: options
 */
function createTypeSizeRenderer(options) {
    const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    options = options || {};
    // first size renderer, so we have the correct symbol types
    const secondField = options.fieldInfos.length > 1 ? options.fieldInfos[1] : options.fieldInfos[0];
    if ((0,_colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_3__.s)({ fieldInfos: [secondField] }) && ["color-size", "type-size"].indexOf(rendererType) > -1) {
        const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer), "size");
        if (sizeVisVar && (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).authoringInfo) {
            // re-use size renderer
            return createTypePartForRenderer((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer), options).then((rendererResult) => {
                return Promise.resolve(rendererResult);
            }, (error) => Promise.reject(error));
        } // else classed
    }
    return (0,_colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_3__.c)(Object.assign(Object.assign({}, options), { fieldInfos: [options.fieldInfos[1]] })).then((sizeRendererResult) => {
        //console.log("createSizeRenderer result", sizeRendererResult.renderer.toJSON());
        return createTypePartForRenderer(sizeRendererResult.renderer, options).then((rendererResult) => {
            return Promise.resolve(rendererResult);
        }, (error) => Promise.reject(error));
    }, (error) => Promise.reject(error));
}
/**
 * Updates the layer with a Color+size renderer with default settings
 * @param options: options
 */
function createTypeSizeAgeRenderer(options) {
    const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    options = options || {};
    // first size renderer, so we have the correct symbol types
    const secondField = options.fieldInfos.length > 1 ? options.fieldInfos[1] : options.fieldInfos[0];
    if ((0,_colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_3__.s)({ fieldInfos: [secondField] }) && ["color-size-age", "type-size-age"].indexOf(rendererType) > -1) {
        const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer), "size");
        if (sizeVisVar && (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).authoringInfo) {
            // re-use size renderer
            return createTypePartForRenderer((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer), options).then((rendererResult) => {
                return Promise.resolve(rendererResult);
            }, (error) => Promise.reject(error));
        } // else classed
    }
    return (0,_colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_3__.a)(Object.assign(Object.assign({}, options), { fieldInfos: [options.fieldInfos[1]] })).then((sizeRendererResult) => {
        return createTypePartForRenderer(sizeRendererResult.renderer, options).then((rendererResult) => {
            //console.log("createColorSizeRenderer out 2", rendererResult.renderer.toJSON());
            return Promise.resolve(rendererResult);
        }, (error) => Promise.reject(error));
    }, (error) => Promise.reject(error));
}
/**
 * Creates a Type&Size renderer with settings from current renderer
 */
function createTypeSizeRendererFromExisting(options, rendererSubtype) {
    const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    options = options || {};
    // first size renderer, so we have the correct symbol types
    return (0,_colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_3__.f)(Object.assign(Object.assign({}, options), { fieldInfos: options.fieldInfos ? [options.fieldInfos[1]] : null })).then((sizeRendererResult) => {
        return (0,_type_0ace5d2e_js__WEBPACK_IMPORTED_MODULE_4__.a)(Object.assign(Object.assign({}, options), { fieldInfos: options.fieldInfos ? [options.fieldInfos[0]] : null })).then((typeRendererResult) => {
            copySizeToTypeRenderer(typeRendererResult.renderer, sizeRendererResult.renderer);
            typeRendererResult.backgroundFillSymbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).backgroundFillSymbol;
            // handle situations where renderer recreation occurs from the size panel. Slider statistics must correspond to the size variable.
            if (rendererSubtype === "size") {
                typeRendererResult.statistics = sizeRendererResult.statistics;
            }
            return Promise.resolve(typeRendererResult);
        }, (error) => Promise.reject(error));
    }, (error) => Promise.reject(error));
}
/**
 * Creates a Type&SizeAge renderer with settings from current renderer
 */
function createTypeSizeAgeRendererFromExisting(options, rendererSubtype) {
    const { layer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    options = options || {};
    // first size renderer, so we have the correct symbol types
    return (0,_colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_3__.g)(Object.assign(Object.assign({}, options), { fieldInfos: options.fieldInfos ? [options.fieldInfos[1]] : null })).then((sizeRendererResult) => {
        //console.log("createSizeAgeRendererFromExisting",sizeRendererResult.renderer.toJSON());
        // remove Age options
        delete options.units;
        delete options.startTime;
        delete options.endTime;
        if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.R)(options)) {
            // re-use type renderer
            const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).clone();
            renderer.visualVariables = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.n)(renderer, "size") || [];
            const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(sizeRendererResult.renderer, "size");
            renderer.visualVariables.push(sizeVisVar);
            renderer.authoringInfo = renderer.authoringInfo || new modules.AuthoringInfo({});
            renderer.authoringInfo.visualVariables = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.o)(renderer, "size") || [];
            const sizeAuthVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)(sizeRendererResult.renderer, "size");
            renderer.authoringInfo.visualVariables.push(sizeAuthVisVar);
            return Promise.resolve({ renderer });
        }
        return (0,_type_0ace5d2e_js__WEBPACK_IMPORTED_MODULE_4__.a)(Object.assign(Object.assign({}, options), { fieldInfos: options.fieldInfos ? [options.fieldInfos[0]] : null })).then((typeRendererResult) => {
            copySizeToTypeRenderer(typeRendererResult.renderer, sizeRendererResult.renderer);
            typeRendererResult.backgroundFillSymbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).backgroundFillSymbol;
            // handle situations where renderer recreation occurs from the size panel. Slider statistics must correspond to the size variable.
            if (rendererSubtype === "size") {
                typeRendererResult.statistics = sizeRendererResult.statistics;
            }
            return Promise.resolve(typeRendererResult);
        }, (error) => Promise.reject(error));
    }, (error) => Promise.reject(error));
}
function createTypePartForRenderer(sizeRenderer, options) {
    const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    if ((0,_type_0ace5d2e_js__WEBPACK_IMPORTED_MODULE_4__.s)(options) && ["type", "type-size", "type-size-age"].indexOf(rendererType) > -1) {
        // we can re-use the type renderer
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).clone();
        copySizeToTypeRenderer(renderer, sizeRenderer);
        return Promise.resolve({ renderer });
    }
    return (0,_type_0ace5d2e_js__WEBPACK_IMPORTED_MODULE_4__.c)(Object.assign(Object.assign({}, options), { fieldInfos: [options.fieldInfos[0]] })).then((typeRendererResult) => {
        copySizeToTypeRenderer(typeRendererResult.renderer, sizeRenderer);
        return Promise.resolve(typeRendererResult);
    }, (error) => Promise.reject(error));
}
function copySizeToTypeRenderer(typeRenderer, sizeRenderer) {
    const { layer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    typeRenderer.visualVariables = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.n)(typeRenderer, "size") || [];
    typeRenderer.visualVariables = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.n)(typeRenderer, "size", "auto") || [];
    const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(sizeRenderer, "size");
    typeRenderer.visualVariables.push(sizeVisVar);
    typeRenderer.authoringInfo = typeRenderer.authoringInfo || new modules.AuthoringInfo({});
    typeRenderer.authoringInfo.visualVariables = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.o)(typeRenderer, "size") || [];
    const sizeAuthVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)(sizeRenderer, "size");
    typeRenderer.authoringInfo.visualVariables.push(sizeAuthVisVar);
    if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer)) {
        const markerSymbol = sizeRenderer.classBreakInfos && sizeRenderer.classBreakInfos.length
            ? sizeRenderer.classBreakInfos[0].symbol
            : sizeRenderer.uniqueValueInfos && sizeRenderer.uniqueValueInfos.length
                ? sizeRenderer.uniqueValueInfos[0].symbol
                : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, "type-size");
        const infos = typeRenderer.uniqueValueInfos.slice();
        infos.map((valueInfo) => {
            const color = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(valueInfo.symbol);
            valueInfo.symbol = markerSymbol.clone();
            (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(valueInfo.symbol, color);
        });
        typeRenderer.uniqueValueInfos = infos;
        typeRenderer.backgroundFillSymbol = sizeRenderer.backgroundFillSymbol;
        const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(sizeRenderer, "size", "outline");
        if (sizeOutlineVisVar) {
            typeRenderer.visualVariables.push(sizeOutlineVisVar);
        }
    }
}



//# sourceMappingURL=typeSize-9d4c5d28.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fcmVsYXRpLTVkZmRjMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM4WDtBQUMzVjtBQUM0Qjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBcUQsRUFBRSwrREFBaUI7QUFDcEY7QUFDQSx5QkFBeUIsbUVBQWU7QUFDeEM7QUFDQTtBQUNBLDZCQUE2QixvRUFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1FQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsdUNBQXVDLG1FQUFnQjtBQUN2RCxxREFBcUQsbUVBQW9CO0FBQ3pFLGdCQUFnQixtRUFBYTtBQUM3QjtBQUNBLHNDQUFzQyxtRUFBZ0I7QUFDdEQ7QUFDQTtBQUNBLGtDQUFrQyxtRUFBYztBQUNoRDtBQUNBLG9CQUFvQixtRUFBZ0I7QUFDcEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0EsbUJBQW1CLG1FQUFnQixDQUFDLG1FQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQ0FBb0M7QUFDdEQsa0JBQWtCLG9DQUFvQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFpQjtBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFxRCxFQUFFLCtEQUFpQjtBQUNwRjtBQUNBO0FBQ0EscUJBQXFCLG1FQUFXO0FBQ2hD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QTtBQUNBO0FBQ0E7O0FBRTRKOztBQUU1SiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3JlbGF0aW9uc2hpcC1iNzJkN2Q5Ny5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS90eXBlU2l6ZS05ZDRjNWQyOC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGggYXMgZ2V0UmVuZGVyZXIsIGcgYXMgZ2V0UmVuZGVyZXJUeXBlLCBhIGFzIGdldFZpc1ZhciwgUiBhcyBpc0VtcHR5LCBhMCBhcyBmaW5kUmVsYXRpb25zaGlwU2NoZW1lLCBtIGFzIHNhdmVFeHRyYVZpc1ZhcnMsIGwgYXMgYXBwbHlFeHRyYVZpc1ZhcnMsIHIgYXMgYXBwbHlTeW1ib2xDb2xvciwgdCBhcyBnZXRTeW1ib2xDb2xvciwgcyBhcyBzbWFydE1hcHBpbmdTdGF0ZSwgbiBhcyBnZXRWaXNWYXJzRXhjZXB0LCBvIGFzIGdldEF1dGhWaXNWYXJzRXhjZXB0LCBxIGFzIGlzUG9seWdvblR5cGUsIFMgYXMgZ2V0RGVmYXVsdFN5bWJvbCwgdyBhcyBzaW1wbGVGaWVsZFR5cGVzIH0gZnJvbSAnLi9yYXN0ZXItdW5pcXVlLXZhbHVlLTA5NzZlYzdmLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzRGVmaW5lZCB9IGZyb20gJy4vY29tbW9uRnVuY3Rpb25zLWIwODMwZTllLmpzJztcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBsYXllciB3aXRoIGEgQ29sb3IgcmVuZGVyZXIgd2l0aCBkZWZhdWx0IHNldHRpbmdzXG4gKiBAcGFyYW0gb3B0aW9uczogb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVSZWxhdGlvbnNoaXBSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtYXBJbWFnZVN1YmxheWVyLCBtYXBWaWV3LCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgY29uc3QgcmVuZGVyZXJUeXBlID0gZ2V0UmVuZGVyZXJUeXBlKCk7XG4gICAgbGV0IHJlbGF0aW9uc2hpcFNjaGVtZSA9IG9wdGlvbnMucmVsYXRpb25zaGlwU2NoZW1lO1xuICAgIGlmICghcmVsYXRpb25zaGlwU2NoZW1lICYmIFtcInJlbGF0aW9uc2hpcFwiLCBcInJlbGF0aW9uc2hpcC1zaXplXCJdLmluZGV4T2YocmVuZGVyZXJUeXBlKSA+IC0xKSB7XG4gICAgICAgIHJlbGF0aW9uc2hpcFNjaGVtZSA9IGZpbmRSZWxhdGlvbnNoaXBTY2hlbWUoKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHJlbmRlcmVyVHlwZSA9PT0gXCJyZWxhdGlvbnNoaXAtc2l6ZVwiKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IGF1dGhJbmZvID0gcmVuZGVyZXIuYXV0aG9yaW5nSW5mbztcbiAgICAgICAgaWYgKGF1dGhJbmZvICYmXG4gICAgICAgICAgICAoKF9hID0gb3B0aW9ucy5maWVsZEluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA+IDEgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuZmllbGRJbmZvc1swXS5maWVsZCA9PSBhdXRoSW5mby5maWVsZDEuZmllbGQgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuZmllbGRJbmZvc1sxXS5maWVsZCA9PSBhdXRoSW5mby5maWVsZDIuZmllbGQpIHtcbiAgICAgICAgICAgIC8vIHJlLXVzZSByZWxhdGlvbnNoaXAgcmVuZGVyZXI7IHJlbW92ZSBzaXplXG4gICAgICAgICAgICByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMgPSBnZXRWaXNWYXJzRXhjZXB0KHJlbmRlcmVyLCBcInNpemVcIik7XG4gICAgICAgICAgICByZW5kZXJlci5hdXRob3JpbmdJbmZvLnZpc3VhbFZhcmlhYmxlcyA9IGdldEF1dGhWaXNWYXJzRXhjZXB0KHJlbmRlcmVyLCBcInNpemVcIik7XG4gICAgICAgICAgICBpZiAoaXNQb2x5Z29uVHlwZShsYXllcikpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggbWFya2VycyB0byBwb2x5Z29uc1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlnb25TeW1ib2wgPSBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvcyA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3Muc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBpbmZvcy5tYXAoKHZhbHVlSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGdldFN5bWJvbENvbG9yKHZhbHVlSW5mby5zeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZm8uc3ltYm9sID0gcG9seWdvblN5bWJvbC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKHZhbHVlSW5mby5zeW1ib2wsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zID0gaW5mb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgcmVuZGVyZXIgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXh0cmFzID0gc2F2ZUV4dHJhVmlzVmFycyhnZXRSZW5kZXJlcihsYXllcikpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXc6IG1hcFZpZXcsXG4gICAgICAgIGZpZWxkMTogeyBmaWVsZDogb3B0aW9ucy5maWVsZEluZm9zWzBdLmZpZWxkIH0sXG4gICAgICAgIGZpZWxkMjogeyBmaWVsZDogb3B0aW9ucy5maWVsZEluZm9zWzFdLmZpZWxkIH0sXG4gICAgICAgIGNsYXNzaWZpY2F0aW9uTWV0aG9kOiBcInF1YW50aWxlXCIsXG4gICAgICAgIG51bUNsYXNzZXM6IDMsXG4gICAgICAgIGZvY3VzOiBcIkhIXCIsXG4gICAgICAgIHJlbGF0aW9uc2hpcFNjaGVtZSxcbiAgICAgICAgb3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWQ6IG1hcEltYWdlU3VibGF5ZXJcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogaXNEZWZpbmVkKG9wdGlvbnMub3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWQpXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLm91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkXG4gICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICBzaXplT3B0aW1pemF0aW9uRW5hYmxlZDogbWFwSW1hZ2VTdWJsYXllclxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiBpc0RlZmluZWQob3B0aW9ucy5zaXplT3B0aW1pemF0aW9uRW5hYmxlZClcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuc2l6ZU9wdGltaXphdGlvbkVuYWJsZWRcbiAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgIGxlZ2VuZE9wdGlvbnM6IG9wdGlvbnMubGVnZW5kT3B0aW9ucyxcbiAgICAgICAgZGVmYXVsdFN5bWJvbEVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb3JCaW5uaW5nOiAoKF9iID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID09PSBcImJpbm5pbmdcIlxuICAgIH07XG4gICAgLy9jb25zb2xlLmxvZyhcImNyZWF0ZVJlbGF0aW9uc2hpcFJlbmRlcmVyXCIsIGNvbmZpZyk7XG4gICAgcmV0dXJuIG1vZHVsZXMuUmVsYXRpb25zaGlwQ3JlYXRvci5jcmVhdGVSZW5kZXJlcihjb25maWcpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY3JlYXRlUmVsYXRpb25zaGlwUmVuZGVyZXItc3VjY2Vzc1wiLCByZXN1bHQpO1xuICAgICAgICBhcHBseUV4dHJhVmlzVmFycyhleHRyYXMsIHJlc3VsdC5yZW5kZXJlcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBSZWxhdGlvbnNoaXAgcmVuZGVyZXIgd2l0aCBzZXR0aW5ncyBmcm9tIGN1cnJlbnQgcmVuZGVyZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25zaGlwUmVuZGVyZXJGcm9tRXhpc3Rpbmcob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtYXBJbWFnZVN1YmxheWVyLCBtYXBWaWV3LCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3QgcmVuZGVyZXJUeXBlID0gZ2V0UmVuZGVyZXJUeXBlKCk7XG4gICAgY29uc3QgYXV0aEluZm8gPSByZW5kZXJlci5hdXRob3JpbmdJbmZvO1xuICAgIC8vIGFyZSB3ZSBjb21pbmcgZnJvbSBhIHJlbGF0aW9uc2hpcC1zaXplIHJlbmRlcmVyP1xuICAgIGNvbnN0IHNpemVWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICBpZiAob3B0aW9ucy5maWVsZEluZm9zICYmXG4gICAgICAgIG9wdGlvbnMuZmllbGRJbmZvcy5sZW5ndGggPiAxICYmXG4gICAgICAgIG9wdGlvbnMuZmllbGRJbmZvc1swXS5maWVsZCA9PSBhdXRoSW5mby5maWVsZDEuZmllbGQgJiZcbiAgICAgICAgb3B0aW9ucy5ub3JtYWxpemF0aW9uRmllbGQxID09PSBhdXRoSW5mby5maWVsZDEubm9ybWFsaXphdGlvbkZpZWxkICYmXG4gICAgICAgIG9wdGlvbnMuZmllbGRJbmZvc1sxXS5maWVsZCA9PSBhdXRoSW5mby5maWVsZDIuZmllbGQgJiZcbiAgICAgICAgb3B0aW9ucy5ub3JtYWxpemF0aW9uRmllbGQyID09PSBhdXRoSW5mby5maWVsZDIubm9ybWFsaXphdGlvbkZpZWxkKSB7XG4gICAgICAgIC8vIG5vIGNoYW5nZXMgdG8gZmllbGRzXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmZpZWxkSW5mb3M7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLm5vcm1hbGl6YXRpb25GaWVsZDE7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLm5vcm1hbGl6YXRpb25GaWVsZDI7XG4gICAgICAgIGlmIChpc0VtcHR5KG9wdGlvbnMpICYmICFzaXplVmlzVmFyKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHJlYWxseSBjaGFuZ2VzXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgcmVuZGVyZXI6IHJlbmRlcmVyLmNsb25lKCkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlbGF0aW9uc2hpcFNjaGVtZSA9IG9wdGlvbnMucmVsYXRpb25zaGlwU2NoZW1lO1xuICAgIGlmICghcmVsYXRpb25zaGlwU2NoZW1lICYmIFtcInJlbGF0aW9uc2hpcFwiLCBcInJlbGF0aW9uc2hpcC1zaXplXCJdLmluZGV4T2YocmVuZGVyZXJUeXBlKSA+IC0xKSB7XG4gICAgICAgIHJlbGF0aW9uc2hpcFNjaGVtZSA9IGZpbmRSZWxhdGlvbnNoaXBTY2hlbWUoKTtcbiAgICB9XG4gICAgY29uc3QgZXh0cmFzID0gc2F2ZUV4dHJhVmlzVmFycyhyZW5kZXJlcik7XG4gICAgbGV0IGZpZWxkSW5mbzEgPSBvcHRpb25zLmZpZWxkSW5mb3NcbiAgICAgICAgPyBvcHRpb25zLmZpZWxkSW5mb3NbMF1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBmaWVsZDogYXV0aEluZm8uZmllbGQxLmZpZWxkLFxuICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUlxuICAgICAgICB9O1xuICAgIGxldCBmaWVsZEluZm8yID0gb3B0aW9ucy5maWVsZEluZm9zXG4gICAgICAgID8gb3B0aW9ucy5maWVsZEluZm9zWzFdXG4gICAgICAgIDoge1xuICAgICAgICAgICAgZmllbGQ6IGF1dGhJbmZvLmZpZWxkMi5maWVsZCxcbiAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgfTtcbiAgICBjb25zdCBub3JtYWxpemF0aW9uRmllbGQxID0gb3B0aW9ucy5ub3JtYWxpemF0aW9uRmllbGQxICE9PSB1bmRlZmluZWQgLy8gbnVsbCBpcyB1c2VkIGFzIGEgdmFsdWVcbiAgICAgICAgPyBvcHRpb25zLm5vcm1hbGl6YXRpb25GaWVsZDFcbiAgICAgICAgOiBhdXRoSW5mby5maWVsZDEubm9ybWFsaXphdGlvbkZpZWxkO1xuICAgIGNvbnN0IG5vcm1hbGl6YXRpb25GaWVsZDIgPSBvcHRpb25zLm5vcm1hbGl6YXRpb25GaWVsZDIgIT09IHVuZGVmaW5lZCAvLyBudWxsIGlzIHVzZWQgYXMgYSB2YWx1ZVxuICAgICAgICA/IG9wdGlvbnMubm9ybWFsaXphdGlvbkZpZWxkMlxuICAgICAgICA6IGF1dGhJbmZvLmZpZWxkMi5ub3JtYWxpemF0aW9uRmllbGQ7XG4gICAgY29uc3Qgc3ltYm9sID0gcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcyAmJiByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLmxlbmd0aCA/IHJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3NbMF0uc3ltYm9sIDogbnVsbDtcbiAgICBjb25zdCBkZWZhdWx0U3ltYm9sID0gcmVuZGVyZXIuZGVmYXVsdFN5bWJvbDtcbiAgICBjb25zdCBkZWZhdWx0TGFiZWwgPSByZW5kZXJlci5kZWZhdWx0TGFiZWw7XG4gICAgY29uc3QgbnVtQ2xhc3NlcyA9IG9wdGlvbnMubnVtQ2xhc3NlcyA/IG9wdGlvbnMubnVtQ2xhc3NlcyA6IGF1dGhJbmZvLm51bUNsYXNzZXM7XG4gICAgLy8gVE9ETyBuZWVkIHRvIGtlZXAgcmFtcFxuICAgIHJldHVybiBtb2R1bGVzLlJlbGF0aW9uc2hpcENyZWF0b3IuY3JlYXRlUmVuZGVyZXIoe1xuICAgICAgICBsYXllcixcbiAgICAgICAgdmlldzogbWFwVmlldyxcbiAgICAgICAgZmllbGQxOiB7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRJbmZvMSA/IGZpZWxkSW5mbzEuZmllbGQgOiByZW5kZXJlci5maWVsZCxcbiAgICAgICAgICAgIG5vcm1hbGl6YXRpb25GaWVsZDogbm9ybWFsaXphdGlvbkZpZWxkMVxuICAgICAgICB9LFxuICAgICAgICBmaWVsZDI6IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZEluZm8yID8gZmllbGRJbmZvMi5maWVsZCA6IHJlbmRlcmVyLmZpZWxkLFxuICAgICAgICAgICAgbm9ybWFsaXphdGlvbkZpZWxkOiBub3JtYWxpemF0aW9uRmllbGQyXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzaWZpY2F0aW9uTWV0aG9kOiBvcHRpb25zLmNsYXNzaWZpY2F0aW9uTWV0aG9kXG4gICAgICAgICAgICA/IG9wdGlvbnMuY2xhc3NpZmljYXRpb25NZXRob2RcbiAgICAgICAgICAgIDogYXV0aEluZm8uY2xhc3NpZmljYXRpb25NZXRob2QgIT09IFwibWFudWFsXCJcbiAgICAgICAgICAgICAgICA/IGF1dGhJbmZvLmNsYXNzaWZpY2F0aW9uTWV0aG9kXG4gICAgICAgICAgICAgICAgOiBcInF1YW50aWxlXCIsXG4gICAgICAgIG51bUNsYXNzZXMsXG4gICAgICAgIGZvY3VzOiBvcHRpb25zLmZvY3VzID8gb3B0aW9ucy5mb2N1cyA6IGF1dGhJbmZvLmZvY3VzLFxuICAgICAgICByZWxhdGlvbnNoaXBTY2hlbWUsXG4gICAgICAgIG91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkOiBtYXBJbWFnZVN1YmxheWVyXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IGlzRGVmaW5lZChvcHRpb25zLm91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkKVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5vdXRsaW5lT3B0aW1pemF0aW9uRW5hYmxlZFxuICAgICAgICAgICAgICAgIDogISFleHRyYXMuc2l6ZU91dGxpbmVWaXNWYXIsXG4gICAgICAgIHNpemVPcHRpbWl6YXRpb25FbmFibGVkOiBtYXBJbWFnZVN1YmxheWVyXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IGlzRGVmaW5lZChvcHRpb25zLnNpemVPcHRpbWl6YXRpb25FbmFibGVkKVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5zaXplT3B0aW1pemF0aW9uRW5hYmxlZFxuICAgICAgICAgICAgICAgIDogISFleHRyYXMuc2l6ZUF1dG9WaXNWYXIsXG4gICAgICAgIGxlZ2VuZE9wdGlvbnM6IG9wdGlvbnMubGVnZW5kT3B0aW9ucyA/IG9wdGlvbnMubGVnZW5kT3B0aW9ucyA6IHJlbmRlcmVyLmxlZ2VuZE9wdGlvbnMsXG4gICAgICAgIGRlZmF1bHRTeW1ib2xFbmFibGVkOiBpc0RlZmluZWQob3B0aW9ucy5kZWZhdWx0U3ltYm9sRW5hYmxlZClcbiAgICAgICAgICAgID8gb3B0aW9ucy5kZWZhdWx0U3ltYm9sRW5hYmxlZFxuICAgICAgICAgICAgOiAhIXJlbmRlcmVyLmRlZmF1bHRTeW1ib2wsXG4gICAgICAgIGZvckJpbm5pbmc6ICgoX2EgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiYmlubmluZ1wiXG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJSZWxhdGlvbnNoaXBDcmVhdG9yLmNyZWF0ZVJlbmRlcmVyXCIsIHJlc3VsdCk7XG4gICAgICAgIGFwcGx5RXh0cmFWaXNWYXJzKGV4dHJhcywgcmVzdWx0LnJlbmRlcmVyKTtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgY29uc3QgaW5mb3MgPSByZXN1bHQucmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcztcbiAgICAgICAgICAgIGluZm9zLmZvckVhY2goKGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBrZWVwIHRoZSBzYW1lIHN5bWJvbCBzdHlsZSwgbm90IHRoZSBjb2xvclxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGFwcGx5U3ltYm9sQ29sb3Ioc3ltLCBnZXRTeW1ib2xDb2xvcihpbmZvLnN5bWJvbCkpO1xuICAgICAgICAgICAgICAgIGluZm8uc3ltYm9sID0gc3ltO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2VlcCBvbGQgbGFiZWxzXG4gICAgICAgIGlmICghb3B0aW9ucy5udW1DbGFzc2VzIHx8IG9wdGlvbnMubnVtQ2xhc3NlcyA9PT0gYXV0aEluZm8ubnVtQ2xhc3Nlcykge1xuICAgICAgICAgICAgZ2V0UmVuZGVyZXIobGF5ZXIpLnVuaXF1ZVZhbHVlSW5mb3MuZm9yRWFjaCgob2xkSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLmZvckVhY2goKG5ld0luZm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEluZm8udmFsdWUgPT09IG5ld0luZm8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZm8ubGFiZWwgPSBvbGRJbmZvLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdFN5bWJvbCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmRlZmF1bHRTeW1ib2wgPSBkZWZhdWx0U3ltYm9sO1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmRlZmF1bHRMYWJlbCA9IGRlZmF1bHRMYWJlbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xufVxuLyoqXG4gKiBVcGRhdGVzIGEgcmVsYXRpb25zaGlwIHJlbmRlcmVyIGFmdGVyIGNoYW5nZXMgdG8gc2xpZGVyIGJyZWFrcywgZm9jdXMsIGNvbG9yIHJhbXBcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUmVsYXRpb25zaGlwUmVuZGVyZXIob3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IGF1dGhJbmZvID0gcmVuZGVyZXIuYXV0aG9yaW5nSW5mbztcbiAgICByZXR1cm4gbW9kdWxlcy5SZWxhdGlvbnNoaXBDcmVhdG9yLnVwZGF0ZVJlbmRlcmVyKHtcbiAgICAgICAgZmllbGQxOiBhdXRoSW5mby5maWVsZDEsXG4gICAgICAgIGZpZWxkMjogYXV0aEluZm8uZmllbGQyLFxuICAgICAgICBudW1DbGFzc2VzOiBvcHRpb25zLm51bUNsYXNzZXMgPyBvcHRpb25zLm51bUNsYXNzZXMgOiBhdXRoSW5mby5udW1DbGFzc2VzLFxuICAgICAgICBmb2N1czogb3B0aW9ucy5mb2N1cyA/IChvcHRpb25zLmZvY3VzID09PSBcIm5vbmVcIiA/IG51bGwgOiBvcHRpb25zLmZvY3VzKSA6IGF1dGhJbmZvLmZvY3VzLFxuICAgICAgICBjb2xvcnM6IG9wdGlvbnMuY29sb3JzLFxuICAgICAgICByZW5kZXJlclxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBjcmVhdGVSZWxhdGlvbnNoaXBSZW5kZXJlckZyb21FeGlzdGluZyBhcyBhLCBjcmVhdGVSZWxhdGlvbnNoaXBSZW5kZXJlciBhcyBjLCB1cGRhdGVSZWxhdGlvbnNoaXBSZW5kZXJlciBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbGF0aW9uc2hpcC1iNzJkN2Q5Ny5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0UmVuZGVyZXJUeXBlLCBhIGFzIGdldFZpc1ZhciwgaCBhcyBnZXRSZW5kZXJlciwgUiBhcyBpc0VtcHR5LCBuIGFzIGdldFZpc1ZhcnNFeGNlcHQsIG8gYXMgZ2V0QXV0aFZpc1ZhcnNFeGNlcHQsIHAgYXMgZ2V0QXV0aFZpc1ZhciwgcSBhcyBpc1BvbHlnb25UeXBlLCBTIGFzIGdldERlZmF1bHRTeW1ib2wsIHQgYXMgZ2V0U3ltYm9sQ29sb3IsIHIgYXMgYXBwbHlTeW1ib2xDb2xvciwgcyBhcyBzbWFydE1hcHBpbmdTdGF0ZSB9IGZyb20gJy4vcmFzdGVyLXVuaXF1ZS12YWx1ZS0wOTc2ZWM3Zi5qcyc7XG5pbXBvcnQgJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0ICcuL2NvbW1vbkVudW1zLWZjZjEzNjYxLmpzJztcbmltcG9ydCB7IHMgYXMgc2FtZVNpemVGaWVsZCwgYyBhcyBjcmVhdGVTaXplUmVuZGVyZXIsIGEgYXMgY3JlYXRlU2l6ZUFnZVJlbmRlcmVyLCBmIGFzIGNyZWF0ZVNpemVSZW5kZXJlckZyb21FeGlzdGluZywgZyBhcyBjcmVhdGVTaXplQWdlUmVuZGVyZXJGcm9tRXhpc3RpbmcgfSBmcm9tICcuL2NvbG9yU2l6ZS1jZTBjY2RlYi5qcyc7XG5pbXBvcnQgeyBhIGFzIGNyZWF0ZVR5cGVSZW5kZXJlckZyb21FeGlzdGluZywgcyBhcyBzYW1lVHlwZUZpZWxkLCBjIGFzIGNyZWF0ZVR5cGVSZW5kZXJlciB9IGZyb20gJy4vdHlwZS0wYWNlNWQyZS5qcyc7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgbGF5ZXIgd2l0aCBhIENvbG9yK3NpemUgcmVuZGVyZXIgd2l0aCBkZWZhdWx0IHNldHRpbmdzXG4gKiBAcGFyYW0gb3B0aW9uczogb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVUeXBlU2l6ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGxheWVyIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCByZW5kZXJlclR5cGUgPSBnZXRSZW5kZXJlclR5cGUoKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBmaXJzdCBzaXplIHJlbmRlcmVyLCBzbyB3ZSBoYXZlIHRoZSBjb3JyZWN0IHN5bWJvbCB0eXBlc1xuICAgIGNvbnN0IHNlY29uZEZpZWxkID0gb3B0aW9ucy5maWVsZEluZm9zLmxlbmd0aCA+IDEgPyBvcHRpb25zLmZpZWxkSW5mb3NbMV0gOiBvcHRpb25zLmZpZWxkSW5mb3NbMF07XG4gICAgaWYgKHNhbWVTaXplRmllbGQoeyBmaWVsZEluZm9zOiBbc2Vjb25kRmllbGRdIH0pICYmIFtcImNvbG9yLXNpemVcIiwgXCJ0eXBlLXNpemVcIl0uaW5kZXhPZihyZW5kZXJlclR5cGUpID4gLTEpIHtcbiAgICAgICAgY29uc3Qgc2l6ZVZpc1ZhciA9IGdldFZpc1ZhcihnZXRSZW5kZXJlcihsYXllciksIFwic2l6ZVwiKTtcbiAgICAgICAgaWYgKHNpemVWaXNWYXIgJiYgZ2V0UmVuZGVyZXIobGF5ZXIpLmF1dGhvcmluZ0luZm8pIHtcbiAgICAgICAgICAgIC8vIHJlLXVzZSBzaXplIHJlbmRlcmVyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVHlwZVBhcnRGb3JSZW5kZXJlcihnZXRSZW5kZXJlcihsYXllciksIG9wdGlvbnMpLnRoZW4oKHJlbmRlcmVyUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlclJlc3VsdCk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG4gICAgICAgIH0gLy8gZWxzZSBjbGFzc2VkXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVTaXplUmVuZGVyZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmaWVsZEluZm9zOiBbb3B0aW9ucy5maWVsZEluZm9zWzFdXSB9KSkudGhlbigoc2l6ZVJlbmRlcmVyUmVzdWx0KSA9PiB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJjcmVhdGVTaXplUmVuZGVyZXIgcmVzdWx0XCIsIHNpemVSZW5kZXJlclJlc3VsdC5yZW5kZXJlci50b0pTT04oKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVUeXBlUGFydEZvclJlbmRlcmVyKHNpemVSZW5kZXJlclJlc3VsdC5yZW5kZXJlciwgb3B0aW9ucykudGhlbigocmVuZGVyZXJSZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZXJSZXN1bHQpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG4gICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSBsYXllciB3aXRoIGEgQ29sb3Irc2l6ZSByZW5kZXJlciB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAqIEBwYXJhbSBvcHRpb25zOiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVTaXplQWdlUmVuZGVyZXIob3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IGdldFJlbmRlcmVyVHlwZSgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIGZpcnN0IHNpemUgcmVuZGVyZXIsIHNvIHdlIGhhdmUgdGhlIGNvcnJlY3Qgc3ltYm9sIHR5cGVzXG4gICAgY29uc3Qgc2Vjb25kRmllbGQgPSBvcHRpb25zLmZpZWxkSW5mb3MubGVuZ3RoID4gMSA/IG9wdGlvbnMuZmllbGRJbmZvc1sxXSA6IG9wdGlvbnMuZmllbGRJbmZvc1swXTtcbiAgICBpZiAoc2FtZVNpemVGaWVsZCh7IGZpZWxkSW5mb3M6IFtzZWNvbmRGaWVsZF0gfSkgJiYgW1wiY29sb3Itc2l6ZS1hZ2VcIiwgXCJ0eXBlLXNpemUtYWdlXCJdLmluZGV4T2YocmVuZGVyZXJUeXBlKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IHNpemVWaXNWYXIgPSBnZXRWaXNWYXIoZ2V0UmVuZGVyZXIobGF5ZXIpLCBcInNpemVcIik7XG4gICAgICAgIGlmIChzaXplVmlzVmFyICYmIGdldFJlbmRlcmVyKGxheWVyKS5hdXRob3JpbmdJbmZvKSB7XG4gICAgICAgICAgICAvLyByZS11c2Ugc2l6ZSByZW5kZXJlclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVR5cGVQYXJ0Rm9yUmVuZGVyZXIoZ2V0UmVuZGVyZXIobGF5ZXIpLCBvcHRpb25zKS50aGVuKChyZW5kZXJlclJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZXJSZXN1bHQpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xuICAgICAgICB9IC8vIGVsc2UgY2xhc3NlZFxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlU2l6ZUFnZVJlbmRlcmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmllbGRJbmZvczogW29wdGlvbnMuZmllbGRJbmZvc1sxXV0gfSkpLnRoZW4oKHNpemVSZW5kZXJlclJlc3VsdCkgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlVHlwZVBhcnRGb3JSZW5kZXJlcihzaXplUmVuZGVyZXJSZXN1bHQucmVuZGVyZXIsIG9wdGlvbnMpLnRoZW4oKHJlbmRlcmVyUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY3JlYXRlQ29sb3JTaXplUmVuZGVyZXIgb3V0IDJcIiwgcmVuZGVyZXJSZXN1bHQucmVuZGVyZXIudG9KU09OKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlclJlc3VsdCk7XG4gICAgICAgIH0sIChlcnJvcikgPT4gUHJvbWlzZS5yZWplY3QoZXJyb3IpKTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBUeXBlJlNpemUgcmVuZGVyZXIgd2l0aCBzZXR0aW5ncyBmcm9tIGN1cnJlbnQgcmVuZGVyZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHlwZVNpemVSZW5kZXJlckZyb21FeGlzdGluZyhvcHRpb25zLCByZW5kZXJlclN1YnR5cGUpIHtcbiAgICBjb25zdCB7IGxheWVyIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBmaXJzdCBzaXplIHJlbmRlcmVyLCBzbyB3ZSBoYXZlIHRoZSBjb3JyZWN0IHN5bWJvbCB0eXBlc1xuICAgIHJldHVybiBjcmVhdGVTaXplUmVuZGVyZXJGcm9tRXhpc3RpbmcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmaWVsZEluZm9zOiBvcHRpb25zLmZpZWxkSW5mb3MgPyBbb3B0aW9ucy5maWVsZEluZm9zWzFdXSA6IG51bGwgfSkpLnRoZW4oKHNpemVSZW5kZXJlclJlc3VsdCkgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlVHlwZVJlbmRlcmVyRnJvbUV4aXN0aW5nKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmllbGRJbmZvczogb3B0aW9ucy5maWVsZEluZm9zID8gW29wdGlvbnMuZmllbGRJbmZvc1swXV0gOiBudWxsIH0pKS50aGVuKCh0eXBlUmVuZGVyZXJSZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGNvcHlTaXplVG9UeXBlUmVuZGVyZXIodHlwZVJlbmRlcmVyUmVzdWx0LnJlbmRlcmVyLCBzaXplUmVuZGVyZXJSZXN1bHQucmVuZGVyZXIpO1xuICAgICAgICAgICAgdHlwZVJlbmRlcmVyUmVzdWx0LmJhY2tncm91bmRGaWxsU3ltYm9sID0gZ2V0UmVuZGVyZXIobGF5ZXIpLmJhY2tncm91bmRGaWxsU3ltYm9sO1xuICAgICAgICAgICAgLy8gaGFuZGxlIHNpdHVhdGlvbnMgd2hlcmUgcmVuZGVyZXIgcmVjcmVhdGlvbiBvY2N1cnMgZnJvbSB0aGUgc2l6ZSBwYW5lbC4gU2xpZGVyIHN0YXRpc3RpY3MgbXVzdCBjb3JyZXNwb25kIHRvIHRoZSBzaXplIHZhcmlhYmxlLlxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyU3VidHlwZSA9PT0gXCJzaXplXCIpIHtcbiAgICAgICAgICAgICAgICB0eXBlUmVuZGVyZXJSZXN1bHQuc3RhdGlzdGljcyA9IHNpemVSZW5kZXJlclJlc3VsdC5zdGF0aXN0aWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlUmVuZGVyZXJSZXN1bHQpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG4gICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgVHlwZSZTaXplQWdlIHJlbmRlcmVyIHdpdGggc2V0dGluZ3MgZnJvbSBjdXJyZW50IHJlbmRlcmVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVTaXplQWdlUmVuZGVyZXJGcm9tRXhpc3Rpbmcob3B0aW9ucywgcmVuZGVyZXJTdWJ0eXBlKSB7XG4gICAgY29uc3QgeyBsYXllciwgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgLy8gZmlyc3Qgc2l6ZSByZW5kZXJlciwgc28gd2UgaGF2ZSB0aGUgY29ycmVjdCBzeW1ib2wgdHlwZXNcbiAgICByZXR1cm4gY3JlYXRlU2l6ZUFnZVJlbmRlcmVyRnJvbUV4aXN0aW5nKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmllbGRJbmZvczogb3B0aW9ucy5maWVsZEluZm9zID8gW29wdGlvbnMuZmllbGRJbmZvc1sxXV0gOiBudWxsIH0pKS50aGVuKChzaXplUmVuZGVyZXJSZXN1bHQpID0+IHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNyZWF0ZVNpemVBZ2VSZW5kZXJlckZyb21FeGlzdGluZ1wiLHNpemVSZW5kZXJlclJlc3VsdC5yZW5kZXJlci50b0pTT04oKSk7XG4gICAgICAgIC8vIHJlbW92ZSBBZ2Ugb3B0aW9uc1xuICAgICAgICBkZWxldGUgb3B0aW9ucy51bml0cztcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuc3RhcnRUaW1lO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5lbmRUaW1lO1xuICAgICAgICBpZiAoaXNFbXB0eShvcHRpb25zKSkge1xuICAgICAgICAgICAgLy8gcmUtdXNlIHR5cGUgcmVuZGVyZXJcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpLmNsb25lKCk7XG4gICAgICAgICAgICByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMgPSBnZXRWaXNWYXJzRXhjZXB0KHJlbmRlcmVyLCBcInNpemVcIikgfHwgW107XG4gICAgICAgICAgICBjb25zdCBzaXplVmlzVmFyID0gZ2V0VmlzVmFyKHNpemVSZW5kZXJlclJlc3VsdC5yZW5kZXJlciwgXCJzaXplXCIpO1xuICAgICAgICAgICAgcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzLnB1c2goc2l6ZVZpc1Zhcik7XG4gICAgICAgICAgICByZW5kZXJlci5hdXRob3JpbmdJbmZvID0gcmVuZGVyZXIuYXV0aG9yaW5nSW5mbyB8fCBuZXcgbW9kdWxlcy5BdXRob3JpbmdJbmZvKHt9KTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmF1dGhvcmluZ0luZm8udmlzdWFsVmFyaWFibGVzID0gZ2V0QXV0aFZpc1ZhcnNFeGNlcHQocmVuZGVyZXIsIFwic2l6ZVwiKSB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNpemVBdXRoVmlzVmFyID0gZ2V0QXV0aFZpc1ZhcihzaXplUmVuZGVyZXJSZXN1bHQucmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmF1dGhvcmluZ0luZm8udmlzdWFsVmFyaWFibGVzLnB1c2goc2l6ZUF1dGhWaXNWYXIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHJlbmRlcmVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVUeXBlUmVuZGVyZXJGcm9tRXhpc3RpbmcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmaWVsZEluZm9zOiBvcHRpb25zLmZpZWxkSW5mb3MgPyBbb3B0aW9ucy5maWVsZEluZm9zWzBdXSA6IG51bGwgfSkpLnRoZW4oKHR5cGVSZW5kZXJlclJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgY29weVNpemVUb1R5cGVSZW5kZXJlcih0eXBlUmVuZGVyZXJSZXN1bHQucmVuZGVyZXIsIHNpemVSZW5kZXJlclJlc3VsdC5yZW5kZXJlcik7XG4gICAgICAgICAgICB0eXBlUmVuZGVyZXJSZXN1bHQuYmFja2dyb3VuZEZpbGxTeW1ib2wgPSBnZXRSZW5kZXJlcihsYXllcikuYmFja2dyb3VuZEZpbGxTeW1ib2w7XG4gICAgICAgICAgICAvLyBoYW5kbGUgc2l0dWF0aW9ucyB3aGVyZSByZW5kZXJlciByZWNyZWF0aW9uIG9jY3VycyBmcm9tIHRoZSBzaXplIHBhbmVsLiBTbGlkZXIgc3RhdGlzdGljcyBtdXN0IGNvcnJlc3BvbmQgdG8gdGhlIHNpemUgdmFyaWFibGUuXG4gICAgICAgICAgICBpZiAocmVuZGVyZXJTdWJ0eXBlID09PSBcInNpemVcIikge1xuICAgICAgICAgICAgICAgIHR5cGVSZW5kZXJlclJlc3VsdC5zdGF0aXN0aWNzID0gc2l6ZVJlbmRlcmVyUmVzdWx0LnN0YXRpc3RpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHR5cGVSZW5kZXJlclJlc3VsdCk7XG4gICAgICAgIH0sIChlcnJvcikgPT4gUHJvbWlzZS5yZWplY3QoZXJyb3IpKTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlUGFydEZvclJlbmRlcmVyKHNpemVSZW5kZXJlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IGdldFJlbmRlcmVyVHlwZSgpO1xuICAgIGlmIChzYW1lVHlwZUZpZWxkKG9wdGlvbnMpICYmIFtcInR5cGVcIiwgXCJ0eXBlLXNpemVcIiwgXCJ0eXBlLXNpemUtYWdlXCJdLmluZGV4T2YocmVuZGVyZXJUeXBlKSA+IC0xKSB7XG4gICAgICAgIC8vIHdlIGNhbiByZS11c2UgdGhlIHR5cGUgcmVuZGVyZXJcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcikuY2xvbmUoKTtcbiAgICAgICAgY29weVNpemVUb1R5cGVSZW5kZXJlcihyZW5kZXJlciwgc2l6ZVJlbmRlcmVyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHJlbmRlcmVyIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVHlwZVJlbmRlcmVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmllbGRJbmZvczogW29wdGlvbnMuZmllbGRJbmZvc1swXV0gfSkpLnRoZW4oKHR5cGVSZW5kZXJlclJlc3VsdCkgPT4ge1xuICAgICAgICBjb3B5U2l6ZVRvVHlwZVJlbmRlcmVyKHR5cGVSZW5kZXJlclJlc3VsdC5yZW5kZXJlciwgc2l6ZVJlbmRlcmVyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlUmVuZGVyZXJSZXN1bHQpO1xuICAgIH0sIChlcnJvcikgPT4gUHJvbWlzZS5yZWplY3QoZXJyb3IpKTtcbn1cbmZ1bmN0aW9uIGNvcHlTaXplVG9UeXBlUmVuZGVyZXIodHlwZVJlbmRlcmVyLCBzaXplUmVuZGVyZXIpIHtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBWaWV3LCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICB0eXBlUmVuZGVyZXIudmlzdWFsVmFyaWFibGVzID0gZ2V0VmlzVmFyc0V4Y2VwdCh0eXBlUmVuZGVyZXIsIFwic2l6ZVwiKSB8fCBbXTtcbiAgICB0eXBlUmVuZGVyZXIudmlzdWFsVmFyaWFibGVzID0gZ2V0VmlzVmFyc0V4Y2VwdCh0eXBlUmVuZGVyZXIsIFwic2l6ZVwiLCBcImF1dG9cIikgfHwgW107XG4gICAgY29uc3Qgc2l6ZVZpc1ZhciA9IGdldFZpc1ZhcihzaXplUmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICB0eXBlUmVuZGVyZXIudmlzdWFsVmFyaWFibGVzLnB1c2goc2l6ZVZpc1Zhcik7XG4gICAgdHlwZVJlbmRlcmVyLmF1dGhvcmluZ0luZm8gPSB0eXBlUmVuZGVyZXIuYXV0aG9yaW5nSW5mbyB8fCBuZXcgbW9kdWxlcy5BdXRob3JpbmdJbmZvKHt9KTtcbiAgICB0eXBlUmVuZGVyZXIuYXV0aG9yaW5nSW5mby52aXN1YWxWYXJpYWJsZXMgPSBnZXRBdXRoVmlzVmFyc0V4Y2VwdCh0eXBlUmVuZGVyZXIsIFwic2l6ZVwiKSB8fCBbXTtcbiAgICBjb25zdCBzaXplQXV0aFZpc1ZhciA9IGdldEF1dGhWaXNWYXIoc2l6ZVJlbmRlcmVyLCBcInNpemVcIik7XG4gICAgdHlwZVJlbmRlcmVyLmF1dGhvcmluZ0luZm8udmlzdWFsVmFyaWFibGVzLnB1c2goc2l6ZUF1dGhWaXNWYXIpO1xuICAgIGlmIChpc1BvbHlnb25UeXBlKGxheWVyKSkge1xuICAgICAgICBjb25zdCBtYXJrZXJTeW1ib2wgPSBzaXplUmVuZGVyZXIuY2xhc3NCcmVha0luZm9zICYmIHNpemVSZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MubGVuZ3RoXG4gICAgICAgICAgICA/IHNpemVSZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMF0uc3ltYm9sXG4gICAgICAgICAgICA6IHNpemVSZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zICYmIHNpemVSZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gc2l6ZVJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3NbMF0uc3ltYm9sXG4gICAgICAgICAgICAgICAgOiBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3LCBcInR5cGUtc2l6ZVwiKTtcbiAgICAgICAgY29uc3QgaW5mb3MgPSB0eXBlUmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5zbGljZSgpO1xuICAgICAgICBpbmZvcy5tYXAoKHZhbHVlSW5mbykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBnZXRTeW1ib2xDb2xvcih2YWx1ZUluZm8uc3ltYm9sKTtcbiAgICAgICAgICAgIHZhbHVlSW5mby5zeW1ib2wgPSBtYXJrZXJTeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgICAgIGFwcGx5U3ltYm9sQ29sb3IodmFsdWVJbmZvLnN5bWJvbCwgY29sb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHlwZVJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MgPSBpbmZvcztcbiAgICAgICAgdHlwZVJlbmRlcmVyLmJhY2tncm91bmRGaWxsU3ltYm9sID0gc2l6ZVJlbmRlcmVyLmJhY2tncm91bmRGaWxsU3ltYm9sO1xuICAgICAgICBjb25zdCBzaXplT3V0bGluZVZpc1ZhciA9IGdldFZpc1ZhcihzaXplUmVuZGVyZXIsIFwic2l6ZVwiLCBcIm91dGxpbmVcIik7XG4gICAgICAgIGlmIChzaXplT3V0bGluZVZpc1Zhcikge1xuICAgICAgICAgICAgdHlwZVJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcy5wdXNoKHNpemVPdXRsaW5lVmlzVmFyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgY3JlYXRlVHlwZVNpemVBZ2VSZW5kZXJlciBhcyBhLCBjcmVhdGVUeXBlU2l6ZUFnZVJlbmRlcmVyRnJvbUV4aXN0aW5nIGFzIGIsIGNyZWF0ZVR5cGVTaXplUmVuZGVyZXIgYXMgYywgY3JlYXRlVHlwZVNpemVSZW5kZXJlckZyb21FeGlzdGluZyBhcyBkIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVTaXplLTlkNGM1ZDI4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==