"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-8a5f0a"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js":
/*!****************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ DefaultLocale),
/* harmony export */   S: () => (/* binding */ SupportedLocales),
/* harmony export */   a: () => (/* binding */ getDirectionBasedOnRTL),
/* harmony export */   b: () => (/* binding */ fetchComponentLocaleStrings),
/* harmony export */   f: () => (/* binding */ formatLocalizedHelpUrl),
/* harmony export */   g: () => (/* binding */ getLocaleInfo)
/* harmony export */ });
/**
 * Locale list reference [JSAPI](https://devtopia.esri.com/WebGIS/arcgis-js-api/tree/master/esri/nls)
 * also has Hindi: "hi"
 */
const SupportedLocales = {
    Arabic: "ar",
    Bosnian: "bs",
    Bulgarian: "bg",
    Catalan: "ca",
    Czech: "cs",
    Danish: "da",
    German: "de",
    Greek: "el",
    English: "en",
    EnglishUSA: "en-US",
    Spanish: "es",
    Estonian: "et",
    Finnish: "fi",
    French: "fr",
    Hebrew: "he",
    Hindi: "hi",
    Croatian: "hr",
    Hungarian: "hu",
    Indonesian: "id",
    Italian: "it",
    Japanese: "ja",
    Korean: "ko",
    Lithuanian: "lt",
    Latvian: "lv",
    NorwegianBokml: "nb",
    Dutch: "nl",
    Polish: "pl",
    PortugueseBrazil: "pt-BR",
    PortuguesePortugal: "pt-PT",
    Romanian: "ro",
    Russian: "ru",
    Serbian: "sr",
    Slovenian: "sl",
    Slovak: "sk",
    Swedish: "sv",
    Thai: "th",
    Turkish: "tr",
    Ukrainian: "uk",
    Vietnamese: "vi",
    ChineseChina: "zh-CN",
    ChineseHongKong: "zh-HK",
    ChineseTaiwan: "zh-TW"
};
const SupportedOnlineHelpLocales = ["ar", "de", "es", "fr", "it", "ja", "ko", "ru", "pl", "pt-br", "zh-cn"];
const LocaleMap = {
    "en-AU": "en",
    "en-CA": "en",
    "en-GB": "en",
    "en-US": "en",
    "es-ES": "es",
    "es-MX": "es",
    "de-CH": "de",
    "de-AT": "de",
    "de-DE": "de",
    "fr-CH": "fr",
    "fr-FR": "fr",
    "it-CH": "it",
    "it-IT": "it",
    ind: "id",
    ukr: "uk"
};
/**
 * List of supported locales that are RTL
 * reference: https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/4master/esri/intl/locale.ts
 */
const RTLLocales = [SupportedLocales.Arabic, SupportedLocales.Hebrew];
const DefaultLocale = SupportedLocales.English;
/**
 * Utility to centralize logic, and return "rtl" or "rtl" depending on rtl boolean
 * @param {boolean} rtl whether locale is in Right to Left direction
 * @returns {"ltr" | "rtl"} codes that can be passed to "dir" prop of a component.
 */
function getDirectionBasedOnRTL(rtl) {
    return rtl === true ? "rtl" : "ltr";
}
/**
 * Helper function to find the closest element crossing multiple (parent) shadowDOM boundaries.
 * The implementation is based on [this](https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd) solution.
 *
 * @param {string} selector
 * @param {Element} base
 */
function getClosestElement(selector, base) {
    function closestFrom(el) {
        let element;
        if (el === undefined || el === document || el === window)
            element = null;
        else {
            const found = el.closest(selector);
            element = found || closestFrom(el.getRootNode().host);
        }
        return element;
    }
    return closestFrom(base);
}
/**
 * Converts the given locale to a supported locale using the provided locale map.
 *
 * @param {string | undefined} locale - The locale to be converted.
 * @param {object} localeMap - A map of locales to supported locales.
 * @returns {string} - The supported locale.
 */
function convertToSupportedLocale(locale, localeMap) {
    const defaultLocale = DefaultLocale;
    let localeSanitized = locale?.toLowerCase();
    if (localeSanitized !== undefined && localeSanitized.indexOf("-") !== -1) {
        const [lang, region] = localeSanitized.split("-");
        localeSanitized = `${lang}-${region.toUpperCase()}`;
    }
    if (!localeSanitized) {
        return defaultLocale;
    }
    const localeMapKeys = Object.keys(LocaleMap);
    if (localeMapKeys.includes(localeSanitized) === true) {
        return localeMap[localeSanitized];
    }
    return localeSanitized;
}
/**
 * Retrieves locale information; In the case of Regional codes (en-au) it is converted to a supported locale (en).
 *
 * @param {Element} [element=document.documentElement] - The element to search for locale information.
 * @returns {Object} An object containing the locale information.
 * @property {string} locale - The locale code.
 * @property {boolean} rtl - A flag indicating whether the locale is right-to-left.
 */
function getLocaleInfo(element = document.documentElement) {
    // Gets the closest element with a lang attribute and falls back to navigator.language if not found
    const closestElement = getClosestElement("[lang]", element);
    const locale = closestElement?.lang ?? window.navigator.language;
    const supportedLocales = Object.values(SupportedLocales);
    const defaultLocale = DefaultLocale;
    const convertedLocale = convertToSupportedLocale(locale, LocaleMap);
    const isSupportedLocale = supportedLocales.includes(convertedLocale);
    return {
        locale: isSupportedLocale ? convertedLocale : defaultLocale,
        rtl: RTLLocales.includes(locale)
    };
}
/**
 * Fetches the locale file of the given component; defaults to `"en"` locale
 * @param componentName
 * @param props
 * @param locale
 * @param resourcesUrl
 * @param props.path
 * @param props.locale
 * @param props.baseURL
 */
async function fetchLocaleStrings(props) {
    const { path, locale, baseURL } = props;
    // Using the getPublicPath method that leverages `data-resources-url` currently this is not working.
    // const rUrl = getPublicPath(componentName) || resourcesUrl;
    let localeData = {};
    try {
        const response = await fetch(`${baseURL}t9n/${path}.t9n.${locale}.json`);
        localeData = await response.json();
    }
    catch (e) {
        const defaultResponse = await fetch(`${baseURL}t9n/${path}.t9n.${DefaultLocale}.json`);
        localeData = await defaultResponse.json();
    }
    return localeData;
}
async function fetchComponentLocaleStrings(element, baseURL) {
    const componentName = element.tagName.toLowerCase();
    const { locale, rtl } = getLocaleInfo(element);
    const strings = await fetchLocaleStrings({ path: componentName, locale, baseURL });
    return { strings, dir: getDirectionBasedOnRTL(rtl), locale: locale };
}
/**
 * Formats a URL to link to
 * @param {string} url the url string from after the locale
 * @param {string} basePath the base path from the signed in portal object.
 * @param {string} locale the locale abbreviation for the browser.
 * @returns {string} the formatted url.
 */
function formatLocalizedHelpUrl(url, basePath, locale = "en") {
    let localeSanitized = locale;
    const localeMapKeys = Object.keys(LocaleMap);
    if (localeMapKeys.includes(locale) === true) {
        localeSanitized = LocaleMap[locale];
    }
    const localeInLowerCase = localeSanitized.toLocaleLowerCase();
    if (SupportedOnlineHelpLocales.includes(localeInLowerCase) === true) {
        // following regex tests /en/ is present in url and replaces it with the locale
        // https://docdev.arcgis.com/en/arcgis-online/analyze/aggregate-points-mv.htm
        // self Response only provides with `en` locale not as per the user locale or current app locale
        // so we need this replace call.
        basePath = basePath.replace(/^https?:\/\/[^/]+\/en/, (match) => match.replace("en", localeInLowerCase));
    }
    const learnMoreUrl = `${basePath}analyze/${url}`;
    return learnMoreUrl;
}



//# sourceMappingURL=localization-helper-4819b67d.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-band-combination-editor-6380aa44.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-band-combination-editor-6380aa44.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ RFxBandCombinationEditor)
/* harmony export */ });
/* harmony import */ var _index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-da1b7138.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/index-da1b7138.js");
/* harmony import */ var _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcgis/core/core/lang.js */ "@arcgis/core/core/lang.js");
/* harmony import */ var _localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./localization-helper-4819b67d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");
/* harmony import */ var _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ui-utils-928a4096.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js");
/* harmony import */ var _arcgis_core_identity_IdentityManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcgis/core/identity/IdentityManager.js */ "@arcgis/core/identity/IdentityManager.js");
/* harmony import */ var _arcgis_core_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @arcgis/core/core/urlUtils.js */ "@arcgis/core/core/urlUtils.js");
/* harmony import */ var _arcgis_core_layers_Layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @arcgis/core/layers/Layer.js */ "@arcgis/core/layers/Layer.js");
/* harmony import */ var _arcgis_core_layers_ImageryLayer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @arcgis/core/layers/ImageryLayer.js */ "@arcgis/core/layers/ImageryLayer.js");
/* harmony import */ var _arcgis_core_smartMapping_raster_renderers_stretch_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @arcgis/core/smartMapping/raster/renderers/stretch.js */ "@arcgis/core/smartMapping/raster/renderers/stretch.js");
/* harmony import */ var _arcgis_core_request_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @arcgis/core/request.js */ "@arcgis/core/request.js");
/* harmony import */ var _arcgis_core_rest_support_AlgorithmicColorRamp_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @arcgis/core/rest/support/AlgorithmicColorRamp.js */ "@arcgis/core/rest/support/AlgorithmicColorRamp.js");
/* harmony import */ var _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @arcgis/core/rest/support/MultipartColorRamp.js */ "@arcgis/core/rest/support/MultipartColorRamp.js");
/* harmony import */ var _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @arcgis/core/Color.js */ "@arcgis/core/Color.js");
/* harmony import */ var _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./colorRampUtils-8bdd46c5.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/colorRampUtils-8bdd46c5.js");
/* harmony import */ var _arcgis_core_rest_geoprocessor_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @arcgis/core/rest/geoprocessor.js */ "@arcgis/core/rest/geoprocessor.js");
/* harmony import */ var _arcgis_core_portal_PortalItem_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @arcgis/core/portal/PortalItem.js */ "@arcgis/core/portal/PortalItem.js");


















const HelpClickHandlerKeys = {
    methodHelpClickHandler: "methodHelpClickHandler",
    bandHelpClickHandler: "bandHelpClickHandler",
    combinationHelpClickHandler: "combinationHelpClickHandler"
};

const RFxBandCombinationEditor = class {
    constructor(hostRef) {
        (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        /**
         * Stores event handlers for help action click, stored in connected callback to avoid
         * fetching function on each render ( to avoid common bad practice )
         */
        this.helpActionClickEventHandlers = new Map();
        this.onMethodChange = (e) => {
            const element = e.target;
            this.method = Number.parseInt(element.value, 10);
            //setting argument value
            if (this.widgetArgs.inputArgs?.Method) {
                this.widgetArgs.inputArgs.Method.value = this.method;
            }
        };
        this.onBandChange = (e) => {
            const element = e.target;
            const newBandValue = element.value;
            const bandCombinationStr = this.bandCombinationElement.value?.trim();
            const bandCombination = (0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_3__.i)(bandCombinationStr)
                ? []
                : bandCombinationStr.indexOf(",") > 0
                    ? bandCombinationStr.split(",")
                    : bandCombinationStr.split(" ");
            bandCombination.push(newBandValue);
            this._updateBandValues(this._getBandComboFormatedValue(bandCombination));
        };
        this.onBandCombinationChange = () => {
            const bandCombination = this._getBandCombinationValue();
            this._updateBandValues(bandCombination);
        };
        this.bandProperties = undefined;
        this.method = undefined;
        this.widgetArgs = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        if (!this.widgetArgs?.rasterArgs) {
            return;
        }
        this.rasterArg = this.widgetArgs.rasterArgs.Raster;
        this.rasterArg?.input?.addEventListener("rfxArgumentChange", () => {
            this.updateRasterArg();
        });
    }
    async componentWillLoad() {
        ({ strings: this.strings, dir: this.direction } = await (0,_localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_2__.b)(this.hostElement, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.g)(`.`)));
        this.updateRasterArg();
        this.setMethodValue();
    }
    componentDidLoad() {
        this.attachHelpClickEventHandlers();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    setMethodValue() {
        this.method =
            this.widgetArgs.inputArgs?.Method?.value ?? this.widgetArgs.rasterFunctionEnums[0].key;
    }
    attachHelpClickEventHandlers() {
        const methodHelpClickHandler = this.widgetArgs.onHelpActionClick({
            heading: this.widgetArgs?.inputArgs?.Method?.displayName,
            referenceElement: this.bandCombinationMethodContainer,
            helpTextID: this.widgetArgs.helpTextIDs?.extractbands_method
        });
        const bandHelpClickHandler = this.widgetArgs.onHelpActionClick({
            heading: this.widgetArgs?.inputArgs?.BandNames?.displayName,
            referenceElement: this.bandCombinationBandContainer,
            helpTextID: this.widgetArgs.helpTextIDs?.extractbands_band
        });
        const combinationHelpClickHandler = this.widgetArgs.onHelpActionClick({
            heading: this.widgetArgs?.inputArgs?.BandWavelengths?.displayName,
            referenceElement: this.bandCombinationCombinationContainer,
            helpTextID: this.widgetArgs.helpTextIDs?.extractbands_combination
        });
        this.helpActionClickEventHandlers.set(HelpClickHandlerKeys.methodHelpClickHandler, methodHelpClickHandler);
        this.helpActionClickEventHandlers.set(HelpClickHandlerKeys.bandHelpClickHandler, bandHelpClickHandler);
        this.helpActionClickEventHandlers.set(HelpClickHandlerKeys.combinationHelpClickHandler, combinationHelpClickHandler);
    }
    getMethodOptions() {
        const enums = this.widgetArgs.rasterFunctionEnums;
        const bandComboMethods = enums.bandComboMethods.map((bcMethod) => {
            return {
                key: bcMethod.key.toString(),
                label: bcMethod.label
            };
        });
        return bandComboMethods;
    }
    getBandOptions(type) {
        if (!this.bandProperties) {
            return [];
        }
        const bandOptions = this.bandProperties[type];
        const selectOptions = bandOptions.map((option) => {
            return {
                key: option.label.toString(),
                label: option.label
            };
        });
        return selectOptions;
    }
    _getBandCombinationValue() {
        const bandCombinationStr = this.bandCombinationElement.value?.trim();
        if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_3__.i)(bandCombinationStr)) {
            return [];
        }
        const bandCombination = bandCombinationStr.indexOf(",") > 0
            ? bandCombinationStr.split(",")
            : bandCombinationStr.split(" ");
        return this._getBandComboFormatedValue(bandCombination);
    }
    _getBandComboFormatedValue(bandCombination) {
        return bandCombination.map((bandData) => {
            let bandCombValue;
            if (this.method === 1) {
                //wavelength
                bandCombValue = parseFloat(bandData);
            }
            else if (this.method === 2) {
                //BandIds are 0 indexed, but shown to the user as 1 indexed.
                bandCombValue = parseInt(bandData, 10) - 1;
            }
            else {
                bandCombValue = bandData.trim();
            }
            return bandCombValue;
        });
    }
    _updateBandValues(bandCombination) {
        const inputArgs = this.widgetArgs.inputArgs;
        // this._clearArgValues();
        if (inputArgs) {
            // set the correct value
            if (this.method === 0 && inputArgs.BandNames) {
                inputArgs.BandNames.value = bandCombination;
            }
            else if (this.method === 1 && inputArgs.BandWavelengths) {
                inputArgs.BandWavelengths.value = bandCombination;
            }
            else if (this.method === 2 && inputArgs.BandIds) {
                inputArgs.BandIds.value = bandCombination;
            }
        }
        this.widgetArgs = { ...this.widgetArgs, inputArgs };
    }
    async updateRasterArg() {
        const input = this.rasterArg && this.rasterArg.input;
        this.layer = await input?.getSelectedLayer?.();
        this.updateBands();
    }
    updateBands() {
        if (!this.layer) {
            return;
        }
        if (this.layer.loaded) {
            this.updateBandsOnLayerLoad();
        }
        else {
            this.layer.when(() => {
                this.updateBandsOnLayerLoad();
                this._setupValues();
            });
        }
    }
    _setupValues() {
        const inputArgs = this.widgetArgs.inputArgs;
        if (inputArgs && inputArgs.Method && inputArgs.Method.value !== undefined) {
            this.method = inputArgs.Method.value;
        }
        else {
            if (inputArgs.BandIds && !(inputArgs.BandNames || inputArgs.BandWavelengths)) {
                this.method = 2;
            }
            else if (inputArgs.BandNames && !(inputArgs.BandIds || inputArgs.BandWavelengths)) {
                this.method = 0;
            }
            else if (inputArgs.bandWavelengths && !(inputArgs.BandIds || inputArgs.BandNames)) {
                this.method = 1;
            }
        }
    }
    updateBandsOnLayerLoad() {
        let bandIds = [], bandNames = [];
        const bandWavelengths = [{ label: "200" }, { label: "400" }, { label: "600" }];
        const rasterInfo = this.layer?.rasterInfo;
        const keyProperties = rasterInfo?.keyProperties;
        keyProperties?.BandProperties?.forEach((bandProp, idx) => {
            bandIds.push({
                //BandIds are 0 indexed, but shown to the user as 1 indexed.
                label: String(idx + 1)
            });
            bandNames.push({
                label: bandProp.BandName ?? `${"Band_"}${idx + 1}`
            });
        });
        if (!keyProperties.BandProperties ||
            (keyProperties.BandProperties && !keyProperties.BandProperties.length)) {
            const bandProperties = this._getDefaultBandProperties(rasterInfo.bandCount);
            bandNames = bandProperties.bandNames;
            bandIds = bandProperties.bandIds;
        }
        this.bandProperties = {
            bandIds,
            bandNames,
            bandWavelengths
        };
    }
    _getDefaultBandProperties(bandCount) {
        const bandIds = [], bandNames = [];
        for (let i = 1; i <= bandCount; i++) {
            bandIds.push({
                label: String(i)
            });
            bandNames.push({
                label: `${"Band_"}${i}`
            });
        }
        return {
            bandNames: bandNames,
            bandIds: bandIds
        };
    }
    getBandCombinationValue() {
        const inputArgs = this.widgetArgs.inputArgs;
        if (this.method === 0 &&
            inputArgs.BandNames &&
            inputArgs.BandNames.value &&
            inputArgs.BandNames.value.length) {
            return inputArgs.BandNames.value.join(" ");
        }
        else if (this.method === 1 &&
            inputArgs.BandWavelengths &&
            inputArgs.BandWavelengths.value &&
            inputArgs.BandWavelengths.value.length) {
            return inputArgs.BandWavelengths.value.join(" ");
        }
        else if (this.method === 2 &&
            inputArgs.BandIds &&
            inputArgs.BandIds.value &&
            inputArgs.BandIds.value.length) {
            return inputArgs.BandIds.value
                .map(function (id) {
                return +id + 1;
            })
                .join(" ");
        }
    }
    render() {
        const methodOptions = this.getMethodOptions();
        const bandCombinationValue = this.getBandCombinationValue();
        const bandOptionIdentifier = this.method === 0 ? "bandNames" : this.method === 1 ? "bandWavelengths" : "bandIds";
        const bandOptions = this.getBandOptions(bandOptionIdentifier);
        return ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { alignment: "start", scale: _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_4__.U.Scale, layout: "default", ref: (e) => {
                this.bandCombinationMethodContainer = e;
            } }, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("rfx-label", { label: this.strings.method, onRfxLabelHelpActionClick: () => this.helpActionClickEventHandlers?.get(HelpClickHandlerKeys.methodHelpClickHandler)() }), (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("rfx-dtex-common-select", { options: methodOptions, value: this.method.toString(), onRfxArgumentChange: this.onMethodChange })), (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { alignment: "start", scale: _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_4__.U.Scale, layout: "default", ref: (e) => {
                this.bandCombinationBandContainer = e;
            } }, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("rfx-label", { label: this.strings.band, onRfxLabelHelpActionClick: () => this.helpActionClickEventHandlers?.get(HelpClickHandlerKeys.bandHelpClickHandler)() }), (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("rfx-dtex-common-select", { options: bandOptions, onRfxArgumentChange: this.onBandChange, value: undefined })), (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { alignment: "start", scale: _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_4__.U.Scale, layout: "default", ref: (e) => {
                this.bandCombinationCombinationContainer = e;
            } }, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("rfx-label", { label: this.strings.combination, onRfxLabelHelpActionClick: () => this.helpActionClickEventHandlers?.get(HelpClickHandlerKeys.combinationHelpClickHandler)() }), (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-text", { scale: _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_4__.U.Scale, dir: this.direction, status: "idle", alignment: "start", "prefix-text": "", "suffix-text": "", value: bandCombinationValue, onCalciteInputTextChange: this.onBandCombinationChange, ref: (e) => {
                this.bandCombinationElement = e;
            } }))));
    }
    static get assetsDirs() { return ["t9n"]; }
    get hostElement() { return (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.a)(this); }
};



//# sourceMappingURL=rfx-cte-band-combination-editor-6380aa44.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-band-combination-editor.entry.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-band-combination-editor.entry.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rfx_cte_band_combination_editor: () => (/* reexport safe */ _rfx_cte_band_combination_editor_6380aa44_js__WEBPACK_IMPORTED_MODULE_0__.R)
/* harmony export */ });
/* harmony import */ var _rfx_cte_band_combination_editor_6380aa44_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rfx-cte-band-combination-editor-6380aa44.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-band-combination-editor-6380aa44.js");
/* harmony import */ var _index_da1b7138_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-da1b7138.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/index-da1b7138.js");
/* harmony import */ var _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/core/core/lang.js */ "@arcgis/core/core/lang.js");
/* harmony import */ var _localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./localization-helper-4819b67d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");
/* harmony import */ var _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ui-utils-928a4096.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js");
/* harmony import */ var _arcgis_core_identity_IdentityManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @arcgis/core/identity/IdentityManager.js */ "@arcgis/core/identity/IdentityManager.js");
/* harmony import */ var _arcgis_core_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @arcgis/core/core/urlUtils.js */ "@arcgis/core/core/urlUtils.js");
/* harmony import */ var _arcgis_core_layers_Layer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @arcgis/core/layers/Layer.js */ "@arcgis/core/layers/Layer.js");
/* harmony import */ var _arcgis_core_layers_ImageryLayer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @arcgis/core/layers/ImageryLayer.js */ "@arcgis/core/layers/ImageryLayer.js");
/* harmony import */ var _arcgis_core_smartMapping_raster_renderers_stretch_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @arcgis/core/smartMapping/raster/renderers/stretch.js */ "@arcgis/core/smartMapping/raster/renderers/stretch.js");
/* harmony import */ var _arcgis_core_request_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @arcgis/core/request.js */ "@arcgis/core/request.js");
/* harmony import */ var _arcgis_core_rest_support_AlgorithmicColorRamp_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @arcgis/core/rest/support/AlgorithmicColorRamp.js */ "@arcgis/core/rest/support/AlgorithmicColorRamp.js");
/* harmony import */ var _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @arcgis/core/rest/support/MultipartColorRamp.js */ "@arcgis/core/rest/support/MultipartColorRamp.js");
/* harmony import */ var _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @arcgis/core/Color.js */ "@arcgis/core/Color.js");
/* harmony import */ var _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./colorRampUtils-8bdd46c5.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/colorRampUtils-8bdd46c5.js");
/* harmony import */ var _arcgis_core_rest_geoprocessor_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @arcgis/core/rest/geoprocessor.js */ "@arcgis/core/rest/geoprocessor.js");
/* harmony import */ var _arcgis_core_portal_PortalItem_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @arcgis/core/portal/PortalItem.js */ "@arcgis/core/portal/PortalItem.js");




















//# sourceMappingURL=rfx-cte-band-combination-editor.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js":
/*!********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ARGS_KEYWORD),
/* harmony export */   F: () => (/* binding */ FUNCTION_KEYWORD),
/* harmony export */   R: () => (/* binding */ RFV_TYPE),
/* harmony export */   T: () => (/* binding */ TYPE_KEYWORD),
/* harmony export */   a: () => (/* binding */ isRFxArg),
/* harmony export */   b: () => (/* binding */ RFT_TYPE),
/* harmony export */   c: () => (/* binding */ isReferencedObject),
/* harmony export */   d: () => (/* binding */ isNumber),
/* harmony export */   e: () => (/* binding */ isWidgetValueBoolean),
/* harmony export */   f: () => (/* binding */ isColorRamp),
/* harmony export */   g: () => (/* binding */ isRecordSet),
/* harmony export */   h: () => (/* binding */ isFeatureLayer),
/* harmony export */   i: () => (/* binding */ isEmptyDataItem),
/* harmony export */   j: () => (/* binding */ isTileLayer),
/* harmony export */   k: () => (/* binding */ isDynamicImageryLayer),
/* harmony export */   l: () => (/* binding */ isImageryLayer),
/* harmony export */   m: () => (/* binding */ isImageryTileLayer)
/* harmony export */ });
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");


/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.i)(value) &&
      ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.b)(value) || (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.c)(value) || (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.d)(value))) {
    return !value.length;
  }
  var tag = (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.g)(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.e)(value)) {
    return !(0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.f)(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

const RFT_TYPE = "RasterFunctionTemplate";
const TYPE_KEYWORD = "type";
const RFV_TYPE = "RasterFunctionVariable";
const ARGS_KEYWORD = "arguments";
const FUNCTION_KEYWORD = "function";
function isReferencedObject(obj) {
    if (!obj) {
        return false;
    }
    if (obj._object_ref_id != null) {
        return true;
    }
    return false;
}
function isNumber(x) {
    x = String(x).trim();
    if (x === "") {
        return false;
    }
    return /^[+-]?(\d+)?(\.\d+)?$/.test(x);
}
function isWidgetValueBoolean(x) {
    x = String(x).trim();
    return ["true", "false"].indexOf(x) >= 0;
}
function isColorRamp(rfxArg) {
    if (!rfxArg) {
        return false;
    }
    if (rfxArg.type && rfxArg.type.toLowerCase().indexOf("colorramp") >= 0) {
        return true;
    }
    if (rfxArg.value && rfxArg.value.type && rfxArg.value.type.toLowerCase().indexOf("colorramp") >= 0) {
        return true;
    }
    return false;
}
function isRecordSet(rfxArg) {
    return rfxArg.type && rfxArg.type.toLowerCase().indexOf("recordset") >= 0;
}
/**
 * Determines whether the given RFT element is an RFx argument.
 *
 * @param {any} rftElement - The RFT element to check.
 * @returns {boolean} `true` if the given element is RasterFunctionTemplate,
 * RasterFunctionVariable, isColorRamp, isRecordSet; `false` otherwise.
 */
function isRFxArg(rftElement) {
    if (!rftElement) {
        return false;
    }
    const type = rftElement.type;
    return [RFT_TYPE, RFV_TYPE].indexOf(type) >= 0 || isColorRamp(rftElement) || isRecordSet(rftElement);
}
/**
 * Determines if the input is a FeatureLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.FeatureLayer} layer is a FeatureLayer
 */
function isFeatureLayer(layer) {
    return layer.type === "feature";
}
/**
 * Determines if the input is a TileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.TileLayer} layer is a TileLayer
 */
function isTileLayer(layer) {
    return layer.type === "tile";
}
/**
 * Determines if the input is a ImageryTileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryLayer} layer is a ImageryLayer
 */
function isDynamicImageryLayer(layer) {
    return (layer.type === "imagery-tile" &&
        layer.sourceJSON.capabilities.toLowerCase().indexOf("tilesonly") < 0);
}
/**
 * Determines if the input is a ImageryLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryLayer} layer is a ImageryLayer
 */
function isImageryLayer(layer) {
    return layer.type === "imagery" || isDynamicImageryLayer(layer);
}
/**
 * Determines if the input is a ImageryTileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryTileLayer} layer is a ImageryTileLayer
 */
function isImageryTileLayer(layer) {
    return layer.type === "imagery-tile" && !isDynamicImageryLayer(layer);
}
function isEveryPropertyEmpty(value) {
    let isAllPropsEmpty = true;
    if (typeof value === "object" && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === false) {
        // using for-in as it will work with objects with properties that set via accessors as well
        for (const prop in value) {
            // This will tell the TypeScript compiler that the obj object has a string index signature,
            // and will allow to access its properties using a string index without getting the "Element implicitly has an 'any' type" error.
            const propValue = value?.[prop];
            if (value.hasOwnProperty(prop) === true && propValue !== undefined && propValue !== null && propValue !== "") {
                isAllPropsEmpty = false;
                break;
            }
        }
    }
    return isAllPropsEmpty;
}
/**
 * Check for an empty value for data items like GPString and Field.
 * @param value data item value.
 * @returns whether the value is considered empty.
 */
function isEmptyDataItem(value) {
    return (value === undefined ||
        value === null ||
        // single-select, "" is a special case for strings
        (typeof value === "string" && value === "") ||
        // single-select, empty objects are a special case for nested values
        ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.h)(value) && isEmpty(value)) ||
        // multi-select
        (Array.isArray(value) && value.length < 1) ||
        // only testing objects which are not arrays
        // TODO: combine isEveryPropertyEmpty and isEmptyDataItem to single function
        (typeof value === "object" && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === false && isEveryPropertyEmpty(value)));
}



//# sourceMappingURL=type-gaurds-1840747f.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js":
/*!*****************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CalciteScale),
/* harmony export */   U: () => (/* binding */ UIDefaults),
/* harmony export */   a: () => (/* binding */ CalciteOverlayPositioning)
/* harmony export */ });
const UIDefaults = {
    Scale: "s",
    PopoverTimer: 60
};
const CalciteScale = {
    s: "s",
    m: "m"
};
const CalciteOverlayPositioning = {
    absolute: "absolute",
    fixed: "fixed"
};



//# sourceMappingURL=ui-utils-928a4096.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLThhNWYwYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSyxHQUFHLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRLE1BQU0sS0FBSyxPQUFPLE9BQU87QUFDekU7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVEsTUFBTSxLQUFLLE9BQU8sY0FBYztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsK0NBQStDLHNDQUFzQztBQUNyRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLFVBQVUsSUFBSTtBQUNuRDtBQUNBOztBQUVxSzs7QUFFcks7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxTW1HO0FBQ2hFO0FBQ2tEO0FBQ3BCO0FBQ1I7QUFDUDtBQUNYO0FBQ0Q7QUFDTztBQUNrQjtBQUM5QjtBQUMwQjtBQUNGO0FBQzFCO0FBQ087QUFDSztBQUNBOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLHFEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJEQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVyw2Q0FBNkMsUUFBUSxtRUFBMkIsbUJBQW1CLHFEQUFZO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJEQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWMsSUFBSSxjQUFjLElBQUksY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQ0FBK0MsUUFBUSxFQUFFLFFBQVE7QUFDakUsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCLFFBQVEsRUFBRSxFQUFFO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBQyxjQUFjLHFEQUFDLG9CQUFvQiwyQkFBMkIsb0RBQVU7QUFDekY7QUFDQSxlQUFlLEVBQUUscURBQUMsZ0JBQWdCLG9KQUFvSixHQUFHLHFEQUFDLDZCQUE2QixpR0FBaUcsSUFBSSxxREFBQyxvQkFBb0IsMkJBQTJCLG9EQUFVO0FBQ3RYO0FBQ0EsZUFBZSxFQUFFLHFEQUFDLGdCQUFnQixnSkFBZ0osR0FBRyxxREFBQyw2QkFBNkIsZ0ZBQWdGLElBQUkscURBQUMsb0JBQW9CLDJCQUEyQixvREFBVTtBQUNqVztBQUNBLGVBQWUsRUFBRSxxREFBQyxnQkFBZ0IsOEpBQThKLEdBQUcscURBQUMseUJBQXlCLE9BQU8sb0RBQVU7QUFDOU87QUFDQSxlQUFlO0FBQ2Y7QUFDQSw4QkFBOEI7QUFDOUIsd0JBQXdCLE9BQU8scURBQVU7QUFDekM7O0FBRXlDOztBQUV6Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN1NxRztBQUN4RTtBQUNNO0FBQ1E7QUFDUjtBQUNKO0FBQ0M7QUFDa0I7QUFDWDtBQUNEO0FBQ087QUFDa0I7QUFDOUI7QUFDMEI7QUFDRjtBQUMxQjtBQUNPO0FBQ0s7QUFDQTs7QUFFM0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQjZMOztBQUU3TDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNEQUFXO0FBQ2pCLE9BQU8sc0RBQU87QUFDZCxRQUFRLHNEQUFRLFdBQVcsc0RBQVksV0FBVyxzREFBVztBQUM3RDtBQUNBO0FBQ0EsWUFBWSxzREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNEQUFXO0FBQ2pCLFlBQVksc0RBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLFNBQVM7QUFDdEIscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNEQUFPO0FBQzdDOztBQUVrVzs7QUFFbFc7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4RTs7QUFFOUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS9sb2NhbGl6YXRpb24taGVscGVyLTQ4MTliNjdkLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL3JmeC1jdGUtYmFuZC1jb21iaW5hdGlvbi1lZGl0b3ItNjM4MGFhNDQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vcmZ4LWN0ZS1iYW5kLWNvbWJpbmF0aW9uLWVkaXRvci5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS90eXBlLWdhdXJkcy0xODQwNzQ3Zi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS91aS11dGlscy05MjhhNDA5Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvY2FsZSBsaXN0IHJlZmVyZW5jZSBbSlNBUEldKGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1qcy1hcGkvdHJlZS9tYXN0ZXIvZXNyaS9ubHMpXG4gKiBhbHNvIGhhcyBIaW5kaTogXCJoaVwiXG4gKi9cbmNvbnN0IFN1cHBvcnRlZExvY2FsZXMgPSB7XG4gICAgQXJhYmljOiBcImFyXCIsXG4gICAgQm9zbmlhbjogXCJic1wiLFxuICAgIEJ1bGdhcmlhbjogXCJiZ1wiLFxuICAgIENhdGFsYW46IFwiY2FcIixcbiAgICBDemVjaDogXCJjc1wiLFxuICAgIERhbmlzaDogXCJkYVwiLFxuICAgIEdlcm1hbjogXCJkZVwiLFxuICAgIEdyZWVrOiBcImVsXCIsXG4gICAgRW5nbGlzaDogXCJlblwiLFxuICAgIEVuZ2xpc2hVU0E6IFwiZW4tVVNcIixcbiAgICBTcGFuaXNoOiBcImVzXCIsXG4gICAgRXN0b25pYW46IFwiZXRcIixcbiAgICBGaW5uaXNoOiBcImZpXCIsXG4gICAgRnJlbmNoOiBcImZyXCIsXG4gICAgSGVicmV3OiBcImhlXCIsXG4gICAgSGluZGk6IFwiaGlcIixcbiAgICBDcm9hdGlhbjogXCJoclwiLFxuICAgIEh1bmdhcmlhbjogXCJodVwiLFxuICAgIEluZG9uZXNpYW46IFwiaWRcIixcbiAgICBJdGFsaWFuOiBcIml0XCIsXG4gICAgSmFwYW5lc2U6IFwiamFcIixcbiAgICBLb3JlYW46IFwia29cIixcbiAgICBMaXRodWFuaWFuOiBcImx0XCIsXG4gICAgTGF0dmlhbjogXCJsdlwiLFxuICAgIE5vcndlZ2lhbkJva21sOiBcIm5iXCIsXG4gICAgRHV0Y2g6IFwibmxcIixcbiAgICBQb2xpc2g6IFwicGxcIixcbiAgICBQb3J0dWd1ZXNlQnJhemlsOiBcInB0LUJSXCIsXG4gICAgUG9ydHVndWVzZVBvcnR1Z2FsOiBcInB0LVBUXCIsXG4gICAgUm9tYW5pYW46IFwicm9cIixcbiAgICBSdXNzaWFuOiBcInJ1XCIsXG4gICAgU2VyYmlhbjogXCJzclwiLFxuICAgIFNsb3ZlbmlhbjogXCJzbFwiLFxuICAgIFNsb3ZhazogXCJza1wiLFxuICAgIFN3ZWRpc2g6IFwic3ZcIixcbiAgICBUaGFpOiBcInRoXCIsXG4gICAgVHVya2lzaDogXCJ0clwiLFxuICAgIFVrcmFpbmlhbjogXCJ1a1wiLFxuICAgIFZpZXRuYW1lc2U6IFwidmlcIixcbiAgICBDaGluZXNlQ2hpbmE6IFwiemgtQ05cIixcbiAgICBDaGluZXNlSG9uZ0tvbmc6IFwiemgtSEtcIixcbiAgICBDaGluZXNlVGFpd2FuOiBcInpoLVRXXCJcbn07XG5jb25zdCBTdXBwb3J0ZWRPbmxpbmVIZWxwTG9jYWxlcyA9IFtcImFyXCIsIFwiZGVcIiwgXCJlc1wiLCBcImZyXCIsIFwiaXRcIiwgXCJqYVwiLCBcImtvXCIsIFwicnVcIiwgXCJwbFwiLCBcInB0LWJyXCIsIFwiemgtY25cIl07XG5jb25zdCBMb2NhbGVNYXAgPSB7XG4gICAgXCJlbi1BVVwiOiBcImVuXCIsXG4gICAgXCJlbi1DQVwiOiBcImVuXCIsXG4gICAgXCJlbi1HQlwiOiBcImVuXCIsXG4gICAgXCJlbi1VU1wiOiBcImVuXCIsXG4gICAgXCJlcy1FU1wiOiBcImVzXCIsXG4gICAgXCJlcy1NWFwiOiBcImVzXCIsXG4gICAgXCJkZS1DSFwiOiBcImRlXCIsXG4gICAgXCJkZS1BVFwiOiBcImRlXCIsXG4gICAgXCJkZS1ERVwiOiBcImRlXCIsXG4gICAgXCJmci1DSFwiOiBcImZyXCIsXG4gICAgXCJmci1GUlwiOiBcImZyXCIsXG4gICAgXCJpdC1DSFwiOiBcIml0XCIsXG4gICAgXCJpdC1JVFwiOiBcIml0XCIsXG4gICAgaW5kOiBcImlkXCIsXG4gICAgdWtyOiBcInVrXCJcbn07XG4vKipcbiAqIExpc3Qgb2Ygc3VwcG9ydGVkIGxvY2FsZXMgdGhhdCBhcmUgUlRMXG4gKiByZWZlcmVuY2U6IGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1qcy1hcGkvYmxvYi80bWFzdGVyL2VzcmkvaW50bC9sb2NhbGUudHNcbiAqL1xuY29uc3QgUlRMTG9jYWxlcyA9IFtTdXBwb3J0ZWRMb2NhbGVzLkFyYWJpYywgU3VwcG9ydGVkTG9jYWxlcy5IZWJyZXddO1xuY29uc3QgRGVmYXVsdExvY2FsZSA9IFN1cHBvcnRlZExvY2FsZXMuRW5nbGlzaDtcbi8qKlxuICogVXRpbGl0eSB0byBjZW50cmFsaXplIGxvZ2ljLCBhbmQgcmV0dXJuIFwicnRsXCIgb3IgXCJydGxcIiBkZXBlbmRpbmcgb24gcnRsIGJvb2xlYW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcnRsIHdoZXRoZXIgbG9jYWxlIGlzIGluIFJpZ2h0IHRvIExlZnQgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7XCJsdHJcIiB8IFwicnRsXCJ9IGNvZGVzIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBcImRpclwiIHByb3Agb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGdldERpcmVjdGlvbkJhc2VkT25SVEwocnRsKSB7XG4gICAgcmV0dXJuIHJ0bCA9PT0gdHJ1ZSA/IFwicnRsXCIgOiBcImx0clwiO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZmluZCB0aGUgY2xvc2VzdCBlbGVtZW50IGNyb3NzaW5nIG11bHRpcGxlIChwYXJlbnQpIHNoYWRvd0RPTSBib3VuZGFyaWVzLlxuICogVGhlIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIFt0aGlzXShodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NDUyMDU1NC9jdXN0b20tZWxlbWVudC1nZXRyb290bm9kZS1jbG9zZXN0LWZ1bmN0aW9uLWNyb3NzaW5nLW11bHRpcGxlLXBhcmVudC1zaGFkb3dkKSBzb2x1dGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7RWxlbWVudH0gYmFzZVxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0RWxlbWVudChzZWxlY3RvciwgYmFzZSkge1xuICAgIGZ1bmN0aW9uIGNsb3Nlc3RGcm9tKGVsKSB7XG4gICAgICAgIGxldCBlbGVtZW50O1xuICAgICAgICBpZiAoZWwgPT09IHVuZGVmaW5lZCB8fCBlbCA9PT0gZG9jdW1lbnQgfHwgZWwgPT09IHdpbmRvdylcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgICAgICAgICBlbGVtZW50ID0gZm91bmQgfHwgY2xvc2VzdEZyb20oZWwuZ2V0Um9vdE5vZGUoKS5ob3N0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3RGcm9tKGJhc2UpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbG9jYWxlIHRvIGEgc3VwcG9ydGVkIGxvY2FsZSB1c2luZyB0aGUgcHJvdmlkZWQgbG9jYWxlIG1hcC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gbG9jYWxlIC0gVGhlIGxvY2FsZSB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gbG9jYWxlTWFwIC0gQSBtYXAgb2YgbG9jYWxlcyB0byBzdXBwb3J0ZWQgbG9jYWxlcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIHN1cHBvcnRlZCBsb2NhbGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb1N1cHBvcnRlZExvY2FsZShsb2NhbGUsIGxvY2FsZU1hcCkge1xuICAgIGNvbnN0IGRlZmF1bHRMb2NhbGUgPSBEZWZhdWx0TG9jYWxlO1xuICAgIGxldCBsb2NhbGVTYW5pdGl6ZWQgPSBsb2NhbGU/LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvY2FsZVNhbml0aXplZCAhPT0gdW5kZWZpbmVkICYmIGxvY2FsZVNhbml0aXplZC5pbmRleE9mKFwiLVwiKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgW2xhbmcsIHJlZ2lvbl0gPSBsb2NhbGVTYW5pdGl6ZWQuc3BsaXQoXCItXCIpO1xuICAgICAgICBsb2NhbGVTYW5pdGl6ZWQgPSBgJHtsYW5nfS0ke3JlZ2lvbi50b1VwcGVyQ2FzZSgpfWA7XG4gICAgfVxuICAgIGlmICghbG9jYWxlU2FuaXRpemVkKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbGVNYXBLZXlzID0gT2JqZWN0LmtleXMoTG9jYWxlTWFwKTtcbiAgICBpZiAobG9jYWxlTWFwS2V5cy5pbmNsdWRlcyhsb2NhbGVTYW5pdGl6ZWQpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVNYXBbbG9jYWxlU2FuaXRpemVkXTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZVNhbml0aXplZDtcbn1cbi8qKlxuICogUmV0cmlldmVzIGxvY2FsZSBpbmZvcm1hdGlvbjsgSW4gdGhlIGNhc2Ugb2YgUmVnaW9uYWwgY29kZXMgKGVuLWF1KSBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdXBwb3J0ZWQgbG9jYWxlIChlbikuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBbZWxlbWVudD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdIC0gVGhlIGVsZW1lbnQgdG8gc2VhcmNoIGZvciBsb2NhbGUgaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbG9jYWxlIGluZm9ybWF0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxvY2FsZSAtIFRoZSBsb2NhbGUgY29kZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcnRsIC0gQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgbG9jYWxlIGlzIHJpZ2h0LXRvLWxlZnQuXG4gKi9cbmZ1bmN0aW9uIGdldExvY2FsZUluZm8oZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIC8vIEdldHMgdGhlIGNsb3Nlc3QgZWxlbWVudCB3aXRoIGEgbGFuZyBhdHRyaWJ1dGUgYW5kIGZhbGxzIGJhY2sgdG8gbmF2aWdhdG9yLmxhbmd1YWdlIGlmIG5vdCBmb3VuZFxuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gZ2V0Q2xvc2VzdEVsZW1lbnQoXCJbbGFuZ11cIiwgZWxlbWVudCk7XG4gICAgY29uc3QgbG9jYWxlID0gY2xvc2VzdEVsZW1lbnQ/LmxhbmcgPz8gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZTtcbiAgICBjb25zdCBzdXBwb3J0ZWRMb2NhbGVzID0gT2JqZWN0LnZhbHVlcyhTdXBwb3J0ZWRMb2NhbGVzKTtcbiAgICBjb25zdCBkZWZhdWx0TG9jYWxlID0gRGVmYXVsdExvY2FsZTtcbiAgICBjb25zdCBjb252ZXJ0ZWRMb2NhbGUgPSBjb252ZXJ0VG9TdXBwb3J0ZWRMb2NhbGUobG9jYWxlLCBMb2NhbGVNYXApO1xuICAgIGNvbnN0IGlzU3VwcG9ydGVkTG9jYWxlID0gc3VwcG9ydGVkTG9jYWxlcy5pbmNsdWRlcyhjb252ZXJ0ZWRMb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxvY2FsZTogaXNTdXBwb3J0ZWRMb2NhbGUgPyBjb252ZXJ0ZWRMb2NhbGUgOiBkZWZhdWx0TG9jYWxlLFxuICAgICAgICBydGw6IFJUTExvY2FsZXMuaW5jbHVkZXMobG9jYWxlKVxuICAgIH07XG59XG4vKipcbiAqIEZldGNoZXMgdGhlIGxvY2FsZSBmaWxlIG9mIHRoZSBnaXZlbiBjb21wb25lbnQ7IGRlZmF1bHRzIHRvIGBcImVuXCJgIGxvY2FsZVxuICogQHBhcmFtIGNvbXBvbmVudE5hbWVcbiAqIEBwYXJhbSBwcm9wc1xuICogQHBhcmFtIGxvY2FsZVxuICogQHBhcmFtIHJlc291cmNlc1VybFxuICogQHBhcmFtIHByb3BzLnBhdGhcbiAqIEBwYXJhbSBwcm9wcy5sb2NhbGVcbiAqIEBwYXJhbSBwcm9wcy5iYXNlVVJMXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5ncyhwcm9wcykge1xuICAgIGNvbnN0IHsgcGF0aCwgbG9jYWxlLCBiYXNlVVJMIH0gPSBwcm9wcztcbiAgICAvLyBVc2luZyB0aGUgZ2V0UHVibGljUGF0aCBtZXRob2QgdGhhdCBsZXZlcmFnZXMgYGRhdGEtcmVzb3VyY2VzLXVybGAgY3VycmVudGx5IHRoaXMgaXMgbm90IHdvcmtpbmcuXG4gICAgLy8gY29uc3QgclVybCA9IGdldFB1YmxpY1BhdGgoY29tcG9uZW50TmFtZSkgfHwgcmVzb3VyY2VzVXJsO1xuICAgIGxldCBsb2NhbGVEYXRhID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVVJMfXQ5bi8ke3BhdGh9LnQ5bi4ke2xvY2FsZX0uanNvbmApO1xuICAgICAgICBsb2NhbGVEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVVJMfXQ5bi8ke3BhdGh9LnQ5bi4ke0RlZmF1bHRMb2NhbGV9Lmpzb25gKTtcbiAgICAgICAgbG9jYWxlRGF0YSA9IGF3YWl0IGRlZmF1bHRSZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVEYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb21wb25lbnRMb2NhbGVTdHJpbmdzKGVsZW1lbnQsIGJhc2VVUkwpIHtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgeyBsb2NhbGUsIHJ0bCB9ID0gZ2V0TG9jYWxlSW5mbyhlbGVtZW50KTtcbiAgICBjb25zdCBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzKHsgcGF0aDogY29tcG9uZW50TmFtZSwgbG9jYWxlLCBiYXNlVVJMIH0pO1xuICAgIHJldHVybiB7IHN0cmluZ3MsIGRpcjogZ2V0RGlyZWN0aW9uQmFzZWRPblJUTChydGwpLCBsb2NhbGU6IGxvY2FsZSB9O1xufVxuLyoqXG4gKiBGb3JtYXRzIGEgVVJMIHRvIGxpbmsgdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgdGhlIHVybCBzdHJpbmcgZnJvbSBhZnRlciB0aGUgbG9jYWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGggdGhlIGJhc2UgcGF0aCBmcm9tIHRoZSBzaWduZWQgaW4gcG9ydGFsIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGUgdGhlIGxvY2FsZSBhYmJyZXZpYXRpb24gZm9yIHRoZSBicm93c2VyLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGZvcm1hdHRlZCB1cmwuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdExvY2FsaXplZEhlbHBVcmwodXJsLCBiYXNlUGF0aCwgbG9jYWxlID0gXCJlblwiKSB7XG4gICAgbGV0IGxvY2FsZVNhbml0aXplZCA9IGxvY2FsZTtcbiAgICBjb25zdCBsb2NhbGVNYXBLZXlzID0gT2JqZWN0LmtleXMoTG9jYWxlTWFwKTtcbiAgICBpZiAobG9jYWxlTWFwS2V5cy5pbmNsdWRlcyhsb2NhbGUpID09PSB0cnVlKSB7XG4gICAgICAgIGxvY2FsZVNhbml0aXplZCA9IExvY2FsZU1hcFtsb2NhbGVdO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbGVJbkxvd2VyQ2FzZSA9IGxvY2FsZVNhbml0aXplZC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmIChTdXBwb3J0ZWRPbmxpbmVIZWxwTG9jYWxlcy5pbmNsdWRlcyhsb2NhbGVJbkxvd2VyQ2FzZSkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gZm9sbG93aW5nIHJlZ2V4IHRlc3RzIC9lbi8gaXMgcHJlc2VudCBpbiB1cmwgYW5kIHJlcGxhY2VzIGl0IHdpdGggdGhlIGxvY2FsZVxuICAgICAgICAvLyBodHRwczovL2RvY2Rldi5hcmNnaXMuY29tL2VuL2FyY2dpcy1vbmxpbmUvYW5hbHl6ZS9hZ2dyZWdhdGUtcG9pbnRzLW12Lmh0bVxuICAgICAgICAvLyBzZWxmIFJlc3BvbnNlIG9ubHkgcHJvdmlkZXMgd2l0aCBgZW5gIGxvY2FsZSBub3QgYXMgcGVyIHRoZSB1c2VyIGxvY2FsZSBvciBjdXJyZW50IGFwcCBsb2NhbGVcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0aGlzIHJlcGxhY2UgY2FsbC5cbiAgICAgICAgYmFzZVBhdGggPSBiYXNlUGF0aC5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcL1teL10rXFwvZW4vLCAobWF0Y2gpID0+IG1hdGNoLnJlcGxhY2UoXCJlblwiLCBsb2NhbGVJbkxvd2VyQ2FzZSkpO1xuICAgIH1cbiAgICBjb25zdCBsZWFybk1vcmVVcmwgPSBgJHtiYXNlUGF0aH1hbmFseXplLyR7dXJsfWA7XG4gICAgcmV0dXJuIGxlYXJuTW9yZVVybDtcbn1cblxuZXhwb3J0IHsgRGVmYXVsdExvY2FsZSBhcyBELCBTdXBwb3J0ZWRMb2NhbGVzIGFzIFMsIGdldERpcmVjdGlvbkJhc2VkT25SVEwgYXMgYSwgZmV0Y2hDb21wb25lbnRMb2NhbGVTdHJpbmdzIGFzIGIsIGZvcm1hdExvY2FsaXplZEhlbHBVcmwgYXMgZiwgZ2V0TG9jYWxlSW5mbyBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsaXphdGlvbi1oZWxwZXItNDgxOWI2N2QuanMubWFwIiwiaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBnIGFzIGdldEFzc2V0UGF0aCwgaCwgYSBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC1kYTFiNzEzOC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9jb3JlL2xhbmcuanMnO1xuaW1wb3J0IHsgYiBhcyBmZXRjaENvbXBvbmVudExvY2FsZVN0cmluZ3MgfSBmcm9tICcuL2xvY2FsaXphdGlvbi1oZWxwZXItNDgxOWI2N2QuanMnO1xuaW1wb3J0IHsgaSBhcyBpc0VtcHR5RGF0YUl0ZW0gfSBmcm9tICcuL3R5cGUtZ2F1cmRzLTE4NDA3NDdmLmpzJztcbmltcG9ydCB7IFUgYXMgVUlEZWZhdWx0cyB9IGZyb20gJy4vdWktdXRpbHMtOTI4YTQwOTYuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvaWRlbnRpdHkvSWRlbnRpdHlNYW5hZ2VyLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2NvcmUvdXJsVXRpbHMuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvbGF5ZXJzL0xheWVyLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2xheWVycy9JbWFnZXJ5TGF5ZXIuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvc21hcnRNYXBwaW5nL3Jhc3Rlci9yZW5kZXJlcnMvc3RyZXRjaC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9yZXF1ZXN0LmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3Jlc3Qvc3VwcG9ydC9BbGdvcml0aG1pY0NvbG9yUmFtcC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9yZXN0L3N1cHBvcnQvTXVsdGlwYXJ0Q29sb3JSYW1wLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL0NvbG9yLmpzJztcbmltcG9ydCAnLi9jb2xvclJhbXBVdGlscy04YmRkNDZjNS5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9yZXN0L2dlb3Byb2Nlc3Nvci5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9wb3J0YWwvUG9ydGFsSXRlbS5qcyc7XG5cbmNvbnN0IEhlbHBDbGlja0hhbmRsZXJLZXlzID0ge1xuICAgIG1ldGhvZEhlbHBDbGlja0hhbmRsZXI6IFwibWV0aG9kSGVscENsaWNrSGFuZGxlclwiLFxuICAgIGJhbmRIZWxwQ2xpY2tIYW5kbGVyOiBcImJhbmRIZWxwQ2xpY2tIYW5kbGVyXCIsXG4gICAgY29tYmluYXRpb25IZWxwQ2xpY2tIYW5kbGVyOiBcImNvbWJpbmF0aW9uSGVscENsaWNrSGFuZGxlclwiXG59O1xuXG5jb25zdCBSRnhCYW5kQ29tYmluYXRpb25FZGl0b3IgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIGV2ZW50IGhhbmRsZXJzIGZvciBoZWxwIGFjdGlvbiBjbGljaywgc3RvcmVkIGluIGNvbm5lY3RlZCBjYWxsYmFjayB0byBhdm9pZFxuICAgICAgICAgKiBmZXRjaGluZyBmdW5jdGlvbiBvbiBlYWNoIHJlbmRlciAoIHRvIGF2b2lkIGNvbW1vbiBiYWQgcHJhY3RpY2UgKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWxwQWN0aW9uQ2xpY2tFdmVudEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9uTWV0aG9kQ2hhbmdlID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIHRoaXMubWV0aG9kID0gTnVtYmVyLnBhcnNlSW50KGVsZW1lbnQudmFsdWUsIDEwKTtcbiAgICAgICAgICAgIC8vc2V0dGluZyBhcmd1bWVudCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHRoaXMud2lkZ2V0QXJncy5pbnB1dEFyZ3M/Lk1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkZ2V0QXJncy5pbnB1dEFyZ3MuTWV0aG9kLnZhbHVlID0gdGhpcy5tZXRob2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25CYW5kQ2hhbmdlID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IG5ld0JhbmRWYWx1ZSA9IGVsZW1lbnQudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBiYW5kQ29tYmluYXRpb25TdHIgPSB0aGlzLmJhbmRDb21iaW5hdGlvbkVsZW1lbnQudmFsdWU/LnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGJhbmRDb21iaW5hdGlvbiA9IGlzRW1wdHlEYXRhSXRlbShiYW5kQ29tYmluYXRpb25TdHIpXG4gICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgIDogYmFuZENvbWJpbmF0aW9uU3RyLmluZGV4T2YoXCIsXCIpID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGJhbmRDb21iaW5hdGlvblN0ci5zcGxpdChcIixcIilcbiAgICAgICAgICAgICAgICAgICAgOiBiYW5kQ29tYmluYXRpb25TdHIuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgYmFuZENvbWJpbmF0aW9uLnB1c2gobmV3QmFuZFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJhbmRWYWx1ZXModGhpcy5fZ2V0QmFuZENvbWJvRm9ybWF0ZWRWYWx1ZShiYW5kQ29tYmluYXRpb24pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkJhbmRDb21iaW5hdGlvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJhbmRDb21iaW5hdGlvbiA9IHRoaXMuX2dldEJhbmRDb21iaW5hdGlvblZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCYW5kVmFsdWVzKGJhbmRDb21iaW5hdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFuZFByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWV0aG9kID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLndpZGdldEFyZ3MgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLndpZGdldEFyZ3M/LnJhc3RlckFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhc3RlckFyZyA9IHRoaXMud2lkZ2V0QXJncy5yYXN0ZXJBcmdzLlJhc3RlcjtcbiAgICAgICAgdGhpcy5yYXN0ZXJBcmc/LmlucHV0Py5hZGRFdmVudExpc3RlbmVyKFwicmZ4QXJndW1lbnRDaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSYXN0ZXJBcmcoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICAoeyBzdHJpbmdzOiB0aGlzLnN0cmluZ3MsIGRpcjogdGhpcy5kaXJlY3Rpb24gfSA9IGF3YWl0IGZldGNoQ29tcG9uZW50TG9jYWxlU3RyaW5ncyh0aGlzLmhvc3RFbGVtZW50LCBnZXRBc3NldFBhdGgoYC5gKSkpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJhc3RlckFyZygpO1xuICAgICAgICB0aGlzLnNldE1ldGhvZFZhbHVlKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIHRoaXMuYXR0YWNoSGVscENsaWNrRXZlbnRIYW5kbGVycygpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc2V0TWV0aG9kVmFsdWUoKSB7XG4gICAgICAgIHRoaXMubWV0aG9kID1cbiAgICAgICAgICAgIHRoaXMud2lkZ2V0QXJncy5pbnB1dEFyZ3M/Lk1ldGhvZD8udmFsdWUgPz8gdGhpcy53aWRnZXRBcmdzLnJhc3RlckZ1bmN0aW9uRW51bXNbMF0ua2V5O1xuICAgIH1cbiAgICBhdHRhY2hIZWxwQ2xpY2tFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICBjb25zdCBtZXRob2RIZWxwQ2xpY2tIYW5kbGVyID0gdGhpcy53aWRnZXRBcmdzLm9uSGVscEFjdGlvbkNsaWNrKHtcbiAgICAgICAgICAgIGhlYWRpbmc6IHRoaXMud2lkZ2V0QXJncz8uaW5wdXRBcmdzPy5NZXRob2Q/LmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgcmVmZXJlbmNlRWxlbWVudDogdGhpcy5iYW5kQ29tYmluYXRpb25NZXRob2RDb250YWluZXIsXG4gICAgICAgICAgICBoZWxwVGV4dElEOiB0aGlzLndpZGdldEFyZ3MuaGVscFRleHRJRHM/LmV4dHJhY3RiYW5kc19tZXRob2RcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJhbmRIZWxwQ2xpY2tIYW5kbGVyID0gdGhpcy53aWRnZXRBcmdzLm9uSGVscEFjdGlvbkNsaWNrKHtcbiAgICAgICAgICAgIGhlYWRpbmc6IHRoaXMud2lkZ2V0QXJncz8uaW5wdXRBcmdzPy5CYW5kTmFtZXM/LmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgcmVmZXJlbmNlRWxlbWVudDogdGhpcy5iYW5kQ29tYmluYXRpb25CYW5kQ29udGFpbmVyLFxuICAgICAgICAgICAgaGVscFRleHRJRDogdGhpcy53aWRnZXRBcmdzLmhlbHBUZXh0SURzPy5leHRyYWN0YmFuZHNfYmFuZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29tYmluYXRpb25IZWxwQ2xpY2tIYW5kbGVyID0gdGhpcy53aWRnZXRBcmdzLm9uSGVscEFjdGlvbkNsaWNrKHtcbiAgICAgICAgICAgIGhlYWRpbmc6IHRoaXMud2lkZ2V0QXJncz8uaW5wdXRBcmdzPy5CYW5kV2F2ZWxlbmd0aHM/LmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgcmVmZXJlbmNlRWxlbWVudDogdGhpcy5iYW5kQ29tYmluYXRpb25Db21iaW5hdGlvbkNvbnRhaW5lcixcbiAgICAgICAgICAgIGhlbHBUZXh0SUQ6IHRoaXMud2lkZ2V0QXJncy5oZWxwVGV4dElEcz8uZXh0cmFjdGJhbmRzX2NvbWJpbmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhlbHBBY3Rpb25DbGlja0V2ZW50SGFuZGxlcnMuc2V0KEhlbHBDbGlja0hhbmRsZXJLZXlzLm1ldGhvZEhlbHBDbGlja0hhbmRsZXIsIG1ldGhvZEhlbHBDbGlja0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmhlbHBBY3Rpb25DbGlja0V2ZW50SGFuZGxlcnMuc2V0KEhlbHBDbGlja0hhbmRsZXJLZXlzLmJhbmRIZWxwQ2xpY2tIYW5kbGVyLCBiYW5kSGVscENsaWNrSGFuZGxlcik7XG4gICAgICAgIHRoaXMuaGVscEFjdGlvbkNsaWNrRXZlbnRIYW5kbGVycy5zZXQoSGVscENsaWNrSGFuZGxlcktleXMuY29tYmluYXRpb25IZWxwQ2xpY2tIYW5kbGVyLCBjb21iaW5hdGlvbkhlbHBDbGlja0hhbmRsZXIpO1xuICAgIH1cbiAgICBnZXRNZXRob2RPcHRpb25zKCkge1xuICAgICAgICBjb25zdCBlbnVtcyA9IHRoaXMud2lkZ2V0QXJncy5yYXN0ZXJGdW5jdGlvbkVudW1zO1xuICAgICAgICBjb25zdCBiYW5kQ29tYm9NZXRob2RzID0gZW51bXMuYmFuZENvbWJvTWV0aG9kcy5tYXAoKGJjTWV0aG9kKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtleTogYmNNZXRob2Qua2V5LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbGFiZWw6IGJjTWV0aG9kLmxhYmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJhbmRDb21ib01ldGhvZHM7XG4gICAgfVxuICAgIGdldEJhbmRPcHRpb25zKHR5cGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJhbmRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFuZE9wdGlvbnMgPSB0aGlzLmJhbmRQcm9wZXJ0aWVzW3R5cGVdO1xuICAgICAgICBjb25zdCBzZWxlY3RPcHRpb25zID0gYmFuZE9wdGlvbnMubWFwKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBvcHRpb24ubGFiZWwudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogb3B0aW9uLmxhYmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdE9wdGlvbnM7XG4gICAgfVxuICAgIF9nZXRCYW5kQ29tYmluYXRpb25WYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgYmFuZENvbWJpbmF0aW9uU3RyID0gdGhpcy5iYW5kQ29tYmluYXRpb25FbGVtZW50LnZhbHVlPy50cmltKCk7XG4gICAgICAgIGlmIChpc0VtcHR5RGF0YUl0ZW0oYmFuZENvbWJpbmF0aW9uU3RyKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhbmRDb21iaW5hdGlvbiA9IGJhbmRDb21iaW5hdGlvblN0ci5pbmRleE9mKFwiLFwiKSA+IDBcbiAgICAgICAgICAgID8gYmFuZENvbWJpbmF0aW9uU3RyLnNwbGl0KFwiLFwiKVxuICAgICAgICAgICAgOiBiYW5kQ29tYmluYXRpb25TdHIuc3BsaXQoXCIgXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QmFuZENvbWJvRm9ybWF0ZWRWYWx1ZShiYW5kQ29tYmluYXRpb24pO1xuICAgIH1cbiAgICBfZ2V0QmFuZENvbWJvRm9ybWF0ZWRWYWx1ZShiYW5kQ29tYmluYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGJhbmRDb21iaW5hdGlvbi5tYXAoKGJhbmREYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgYmFuZENvbWJWYWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vd2F2ZWxlbmd0aFxuICAgICAgICAgICAgICAgIGJhbmRDb21iVmFsdWUgPSBwYXJzZUZsb2F0KGJhbmREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWV0aG9kID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy9CYW5kSWRzIGFyZSAwIGluZGV4ZWQsIGJ1dCBzaG93biB0byB0aGUgdXNlciBhcyAxIGluZGV4ZWQuXG4gICAgICAgICAgICAgICAgYmFuZENvbWJWYWx1ZSA9IHBhcnNlSW50KGJhbmREYXRhLCAxMCkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFuZENvbWJWYWx1ZSA9IGJhbmREYXRhLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYW5kQ29tYlZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3VwZGF0ZUJhbmRWYWx1ZXMoYmFuZENvbWJpbmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGlucHV0QXJncyA9IHRoaXMud2lkZ2V0QXJncy5pbnB1dEFyZ3M7XG4gICAgICAgIC8vIHRoaXMuX2NsZWFyQXJnVmFsdWVzKCk7XG4gICAgICAgIGlmIChpbnB1dEFyZ3MpIHtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgY29ycmVjdCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAwICYmIGlucHV0QXJncy5CYW5kTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dEFyZ3MuQmFuZE5hbWVzLnZhbHVlID0gYmFuZENvbWJpbmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tZXRob2QgPT09IDEgJiYgaW5wdXRBcmdzLkJhbmRXYXZlbGVuZ3Rocykge1xuICAgICAgICAgICAgICAgIGlucHV0QXJncy5CYW5kV2F2ZWxlbmd0aHMudmFsdWUgPSBiYW5kQ29tYmluYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1ldGhvZCA9PT0gMiAmJiBpbnB1dEFyZ3MuQmFuZElkcykge1xuICAgICAgICAgICAgICAgIGlucHV0QXJncy5CYW5kSWRzLnZhbHVlID0gYmFuZENvbWJpbmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lkZ2V0QXJncyA9IHsgLi4udGhpcy53aWRnZXRBcmdzLCBpbnB1dEFyZ3MgfTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUmFzdGVyQXJnKCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMucmFzdGVyQXJnICYmIHRoaXMucmFzdGVyQXJnLmlucHV0O1xuICAgICAgICB0aGlzLmxheWVyID0gYXdhaXQgaW5wdXQ/LmdldFNlbGVjdGVkTGF5ZXI/LigpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJhbmRzKCk7XG4gICAgfVxuICAgIHVwZGF0ZUJhbmRzKCkge1xuICAgICAgICBpZiAoIXRoaXMubGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXllci5sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQmFuZHNPbkxheWVyTG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXllci53aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJhbmRzT25MYXllckxvYWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFZhbHVlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NldHVwVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBpbnB1dEFyZ3MgPSB0aGlzLndpZGdldEFyZ3MuaW5wdXRBcmdzO1xuICAgICAgICBpZiAoaW5wdXRBcmdzICYmIGlucHV0QXJncy5NZXRob2QgJiYgaW5wdXRBcmdzLk1ldGhvZC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZCA9IGlucHV0QXJncy5NZXRob2QudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW5wdXRBcmdzLkJhbmRJZHMgJiYgIShpbnB1dEFyZ3MuQmFuZE5hbWVzIHx8IGlucHV0QXJncy5CYW5kV2F2ZWxlbmd0aHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2QgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRBcmdzLkJhbmROYW1lcyAmJiAhKGlucHV0QXJncy5CYW5kSWRzIHx8IGlucHV0QXJncy5CYW5kV2F2ZWxlbmd0aHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2QgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRBcmdzLmJhbmRXYXZlbGVuZ3RocyAmJiAhKGlucHV0QXJncy5CYW5kSWRzIHx8IGlucHV0QXJncy5CYW5kTmFtZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2QgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUJhbmRzT25MYXllckxvYWQoKSB7XG4gICAgICAgIGxldCBiYW5kSWRzID0gW10sIGJhbmROYW1lcyA9IFtdO1xuICAgICAgICBjb25zdCBiYW5kV2F2ZWxlbmd0aHMgPSBbeyBsYWJlbDogXCIyMDBcIiB9LCB7IGxhYmVsOiBcIjQwMFwiIH0sIHsgbGFiZWw6IFwiNjAwXCIgfV07XG4gICAgICAgIGNvbnN0IHJhc3RlckluZm8gPSB0aGlzLmxheWVyPy5yYXN0ZXJJbmZvO1xuICAgICAgICBjb25zdCBrZXlQcm9wZXJ0aWVzID0gcmFzdGVySW5mbz8ua2V5UHJvcGVydGllcztcbiAgICAgICAga2V5UHJvcGVydGllcz8uQmFuZFByb3BlcnRpZXM/LmZvckVhY2goKGJhbmRQcm9wLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGJhbmRJZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgLy9CYW5kSWRzIGFyZSAwIGluZGV4ZWQsIGJ1dCBzaG93biB0byB0aGUgdXNlciBhcyAxIGluZGV4ZWQuXG4gICAgICAgICAgICAgICAgbGFiZWw6IFN0cmluZyhpZHggKyAxKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiYW5kTmFtZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGJhbmRQcm9wLkJhbmROYW1lID8/IGAke1wiQmFuZF9cIn0ke2lkeCArIDF9YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWtleVByb3BlcnRpZXMuQmFuZFByb3BlcnRpZXMgfHxcbiAgICAgICAgICAgIChrZXlQcm9wZXJ0aWVzLkJhbmRQcm9wZXJ0aWVzICYmICFrZXlQcm9wZXJ0aWVzLkJhbmRQcm9wZXJ0aWVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhbmRQcm9wZXJ0aWVzID0gdGhpcy5fZ2V0RGVmYXVsdEJhbmRQcm9wZXJ0aWVzKHJhc3RlckluZm8uYmFuZENvdW50KTtcbiAgICAgICAgICAgIGJhbmROYW1lcyA9IGJhbmRQcm9wZXJ0aWVzLmJhbmROYW1lcztcbiAgICAgICAgICAgIGJhbmRJZHMgPSBiYW5kUHJvcGVydGllcy5iYW5kSWRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFuZFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBiYW5kSWRzLFxuICAgICAgICAgICAgYmFuZE5hbWVzLFxuICAgICAgICAgICAgYmFuZFdhdmVsZW5ndGhzXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXREZWZhdWx0QmFuZFByb3BlcnRpZXMoYmFuZENvdW50KSB7XG4gICAgICAgIGNvbnN0IGJhbmRJZHMgPSBbXSwgYmFuZE5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGJhbmRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBiYW5kSWRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxhYmVsOiBTdHJpbmcoaSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmFuZE5hbWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxhYmVsOiBgJHtcIkJhbmRfXCJ9JHtpfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYW5kTmFtZXM6IGJhbmROYW1lcyxcbiAgICAgICAgICAgIGJhbmRJZHM6IGJhbmRJZHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0QmFuZENvbWJpbmF0aW9uVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0QXJncyA9IHRoaXMud2lkZ2V0QXJncy5pbnB1dEFyZ3M7XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gMCAmJlxuICAgICAgICAgICAgaW5wdXRBcmdzLkJhbmROYW1lcyAmJlxuICAgICAgICAgICAgaW5wdXRBcmdzLkJhbmROYW1lcy52YWx1ZSAmJlxuICAgICAgICAgICAgaW5wdXRBcmdzLkJhbmROYW1lcy52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEFyZ3MuQmFuZE5hbWVzLnZhbHVlLmpvaW4oXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubWV0aG9kID09PSAxICYmXG4gICAgICAgICAgICBpbnB1dEFyZ3MuQmFuZFdhdmVsZW5ndGhzICYmXG4gICAgICAgICAgICBpbnB1dEFyZ3MuQmFuZFdhdmVsZW5ndGhzLnZhbHVlICYmXG4gICAgICAgICAgICBpbnB1dEFyZ3MuQmFuZFdhdmVsZW5ndGhzLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0QXJncy5CYW5kV2F2ZWxlbmd0aHMudmFsdWUuam9pbihcIiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tZXRob2QgPT09IDIgJiZcbiAgICAgICAgICAgIGlucHV0QXJncy5CYW5kSWRzICYmXG4gICAgICAgICAgICBpbnB1dEFyZ3MuQmFuZElkcy52YWx1ZSAmJlxuICAgICAgICAgICAgaW5wdXRBcmdzLkJhbmRJZHMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRBcmdzLkJhbmRJZHMudmFsdWVcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAraWQgKyAxO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbihcIiBcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBtZXRob2RPcHRpb25zID0gdGhpcy5nZXRNZXRob2RPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IGJhbmRDb21iaW5hdGlvblZhbHVlID0gdGhpcy5nZXRCYW5kQ29tYmluYXRpb25WYWx1ZSgpO1xuICAgICAgICBjb25zdCBiYW5kT3B0aW9uSWRlbnRpZmllciA9IHRoaXMubWV0aG9kID09PSAwID8gXCJiYW5kTmFtZXNcIiA6IHRoaXMubWV0aG9kID09PSAxID8gXCJiYW5kV2F2ZWxlbmd0aHNcIiA6IFwiYmFuZElkc1wiO1xuICAgICAgICBjb25zdCBiYW5kT3B0aW9ucyA9IHRoaXMuZ2V0QmFuZE9wdGlvbnMoYmFuZE9wdGlvbklkZW50aWZpZXIpO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgbnVsbCwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBhbGlnbm1lbnQ6IFwic3RhcnRcIiwgc2NhbGU6IFVJRGVmYXVsdHMuU2NhbGUsIGxheW91dDogXCJkZWZhdWx0XCIsIHJlZjogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhbmRDb21iaW5hdGlvbk1ldGhvZENvbnRhaW5lciA9IGU7XG4gICAgICAgICAgICB9IH0sIGgoXCJyZngtbGFiZWxcIiwgeyBsYWJlbDogdGhpcy5zdHJpbmdzLm1ldGhvZCwgb25SZnhMYWJlbEhlbHBBY3Rpb25DbGljazogKCkgPT4gdGhpcy5oZWxwQWN0aW9uQ2xpY2tFdmVudEhhbmRsZXJzPy5nZXQoSGVscENsaWNrSGFuZGxlcktleXMubWV0aG9kSGVscENsaWNrSGFuZGxlcikoKSB9KSwgaChcInJmeC1kdGV4LWNvbW1vbi1zZWxlY3RcIiwgeyBvcHRpb25zOiBtZXRob2RPcHRpb25zLCB2YWx1ZTogdGhpcy5tZXRob2QudG9TdHJpbmcoKSwgb25SZnhBcmd1bWVudENoYW5nZTogdGhpcy5vbk1ldGhvZENoYW5nZSB9KSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgYWxpZ25tZW50OiBcInN0YXJ0XCIsIHNjYWxlOiBVSURlZmF1bHRzLlNjYWxlLCBsYXlvdXQ6IFwiZGVmYXVsdFwiLCByZWY6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYW5kQ29tYmluYXRpb25CYW5kQ29udGFpbmVyID0gZTtcbiAgICAgICAgICAgIH0gfSwgaChcInJmeC1sYWJlbFwiLCB7IGxhYmVsOiB0aGlzLnN0cmluZ3MuYmFuZCwgb25SZnhMYWJlbEhlbHBBY3Rpb25DbGljazogKCkgPT4gdGhpcy5oZWxwQWN0aW9uQ2xpY2tFdmVudEhhbmRsZXJzPy5nZXQoSGVscENsaWNrSGFuZGxlcktleXMuYmFuZEhlbHBDbGlja0hhbmRsZXIpKCkgfSksIGgoXCJyZngtZHRleC1jb21tb24tc2VsZWN0XCIsIHsgb3B0aW9uczogYmFuZE9wdGlvbnMsIG9uUmZ4QXJndW1lbnRDaGFuZ2U6IHRoaXMub25CYW5kQ2hhbmdlLCB2YWx1ZTogdW5kZWZpbmVkIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBhbGlnbm1lbnQ6IFwic3RhcnRcIiwgc2NhbGU6IFVJRGVmYXVsdHMuU2NhbGUsIGxheW91dDogXCJkZWZhdWx0XCIsIHJlZjogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhbmRDb21iaW5hdGlvbkNvbWJpbmF0aW9uQ29udGFpbmVyID0gZTtcbiAgICAgICAgICAgIH0gfSwgaChcInJmeC1sYWJlbFwiLCB7IGxhYmVsOiB0aGlzLnN0cmluZ3MuY29tYmluYXRpb24sIG9uUmZ4TGFiZWxIZWxwQWN0aW9uQ2xpY2s6ICgpID0+IHRoaXMuaGVscEFjdGlvbkNsaWNrRXZlbnRIYW5kbGVycz8uZ2V0KEhlbHBDbGlja0hhbmRsZXJLZXlzLmNvbWJpbmF0aW9uSGVscENsaWNrSGFuZGxlcikoKSB9KSwgaChcImNhbGNpdGUtaW5wdXQtdGV4dFwiLCB7IHNjYWxlOiBVSURlZmF1bHRzLlNjYWxlLCBkaXI6IHRoaXMuZGlyZWN0aW9uLCBzdGF0dXM6IFwiaWRsZVwiLCBhbGlnbm1lbnQ6IFwic3RhcnRcIiwgXCJwcmVmaXgtdGV4dFwiOiBcIlwiLCBcInN1ZmZpeC10ZXh0XCI6IFwiXCIsIHZhbHVlOiBiYW5kQ29tYmluYXRpb25WYWx1ZSwgb25DYWxjaXRlSW5wdXRUZXh0Q2hhbmdlOiB0aGlzLm9uQmFuZENvbWJpbmF0aW9uQ2hhbmdlLCByZWY6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYW5kQ29tYmluYXRpb25FbGVtZW50ID0gZTtcbiAgICAgICAgICAgIH0gfSkpKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgYXNzZXRzRGlycygpIHsgcmV0dXJuIFtcInQ5blwiXTsgfVxuICAgIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5cbmV4cG9ydCB7IFJGeEJhbmRDb21iaW5hdGlvbkVkaXRvciBhcyBSIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJmeC1jdGUtYmFuZC1jb21iaW5hdGlvbi1lZGl0b3ItNjM4MGFhNDQuanMubWFwIiwiZXhwb3J0IHsgUiBhcyByZnhfY3RlX2JhbmRfY29tYmluYXRpb25fZWRpdG9yIH0gZnJvbSAnLi9yZngtY3RlLWJhbmQtY29tYmluYXRpb24tZWRpdG9yLTYzODBhYTQ0LmpzJztcbmltcG9ydCAnLi9pbmRleC1kYTFiNzEzOC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9jb3JlL2xhbmcuanMnO1xuaW1wb3J0ICcuL2xvY2FsaXphdGlvbi1oZWxwZXItNDgxOWI2N2QuanMnO1xuaW1wb3J0ICcuL3R5cGUtZ2F1cmRzLTE4NDA3NDdmLmpzJztcbmltcG9ydCAnLi9fZ2V0VGFnLTk2YWYwMjlkLmpzJztcbmltcG9ydCAnLi91aS11dGlscy05MjhhNDA5Ni5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9pZGVudGl0eS9JZGVudGl0eU1hbmFnZXIuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvY29yZS91cmxVdGlscy5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9sYXllcnMvTGF5ZXIuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvbGF5ZXJzL0ltYWdlcnlMYXllci5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9zbWFydE1hcHBpbmcvcmFzdGVyL3JlbmRlcmVycy9zdHJldGNoLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3JlcXVlc3QuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVzdC9zdXBwb3J0L0FsZ29yaXRobWljQ29sb3JSYW1wLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3Jlc3Qvc3VwcG9ydC9NdWx0aXBhcnRDb2xvclJhbXAuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvQ29sb3IuanMnO1xuaW1wb3J0ICcuL2NvbG9yUmFtcFV0aWxzLThiZGQ0NmM1LmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3Jlc3QvZ2VvcHJvY2Vzc29yLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3BvcnRhbC9Qb3J0YWxJdGVtLmpzJztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmZ4LWN0ZS1iYW5kLWNvbWJpbmF0aW9uLWVkaXRvci5lbnRyeS5qcy5tYXAiLCJpbXBvcnQgeyBpIGFzIGlzQXJyYXlMaWtlLCBhIGFzIGlzQXJyYXksIGIgYXMgaXNCdWZmZXIsIGMgYXMgaXNUeXBlZEFycmF5LCBkIGFzIGlzQXJndW1lbnRzLCBnIGFzIGdldFRhZywgZSBhcyBpc1Byb3RvdHlwZSwgZiBhcyBiYXNlS2V5cywgaCBhcyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9fZ2V0VGFnLTk2YWYwMjlkLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gKlxuICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0VtcHR5KG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSh0cnVlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gIH1cbiAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgUkZUX1RZUEUgPSBcIlJhc3RlckZ1bmN0aW9uVGVtcGxhdGVcIjtcbmNvbnN0IFRZUEVfS0VZV09SRCA9IFwidHlwZVwiO1xuY29uc3QgUkZWX1RZUEUgPSBcIlJhc3RlckZ1bmN0aW9uVmFyaWFibGVcIjtcbmNvbnN0IEFSR1NfS0VZV09SRCA9IFwiYXJndW1lbnRzXCI7XG5jb25zdCBGVU5DVElPTl9LRVlXT1JEID0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gaXNSZWZlcmVuY2VkT2JqZWN0KG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9iai5fb2JqZWN0X3JlZl9pZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc051bWJlcih4KSB7XG4gICAgeCA9IFN0cmluZyh4KS50cmltKCk7XG4gICAgaWYgKHggPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gL15bKy1dPyhcXGQrKT8oXFwuXFxkKyk/JC8udGVzdCh4KTtcbn1cbmZ1bmN0aW9uIGlzV2lkZ2V0VmFsdWVCb29sZWFuKHgpIHtcbiAgICB4ID0gU3RyaW5nKHgpLnRyaW0oKTtcbiAgICByZXR1cm4gW1widHJ1ZVwiLCBcImZhbHNlXCJdLmluZGV4T2YoeCkgPj0gMDtcbn1cbmZ1bmN0aW9uIGlzQ29sb3JSYW1wKHJmeEFyZykge1xuICAgIGlmICghcmZ4QXJnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJmeEFyZy50eXBlICYmIHJmeEFyZy50eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImNvbG9ycmFtcFwiKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmZ4QXJnLnZhbHVlICYmIHJmeEFyZy52YWx1ZS50eXBlICYmIHJmeEFyZy52YWx1ZS50eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImNvbG9ycmFtcFwiKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1JlY29yZFNldChyZnhBcmcpIHtcbiAgICByZXR1cm4gcmZ4QXJnLnR5cGUgJiYgcmZ4QXJnLnR5cGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmVjb3Jkc2V0XCIpID49IDA7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gUkZUIGVsZW1lbnQgaXMgYW4gUkZ4IGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7YW55fSByZnRFbGVtZW50IC0gVGhlIFJGVCBlbGVtZW50IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBSYXN0ZXJGdW5jdGlvblRlbXBsYXRlLFxuICogUmFzdGVyRnVuY3Rpb25WYXJpYWJsZSwgaXNDb2xvclJhbXAsIGlzUmVjb3JkU2V0OyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNSRnhBcmcocmZ0RWxlbWVudCkge1xuICAgIGlmICghcmZ0RWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSByZnRFbGVtZW50LnR5cGU7XG4gICAgcmV0dXJuIFtSRlRfVFlQRSwgUkZWX1RZUEVdLmluZGV4T2YodHlwZSkgPj0gMCB8fCBpc0NvbG9yUmFtcChyZnRFbGVtZW50KSB8fCBpc1JlY29yZFNldChyZnRFbGVtZW50KTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBGZWF0dXJlTGF5ZXJcbiAqIEBwYXJhbSB7X19lc3JpLkxheWVyfSBsYXllciB0aGUgbGF5ZXIgdG8gY2hlY2sgdGhlIHR5cGUgb2ZcbiAqIEByZXR1cm5zIHtsYXllciBpcyBfX2VzcmkuRmVhdHVyZUxheWVyfSBsYXllciBpcyBhIEZlYXR1cmVMYXllclxuICovXG5mdW5jdGlvbiBpc0ZlYXR1cmVMYXllcihsYXllcikge1xuICAgIHJldHVybiBsYXllci50eXBlID09PSBcImZlYXR1cmVcIjtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBUaWxlTGF5ZXJcbiAqIEBwYXJhbSB7X19lc3JpLkxheWVyfSBsYXllciB0aGUgbGF5ZXIgdG8gY2hlY2sgdGhlIHR5cGUgb2ZcbiAqIEByZXR1cm5zIHtsYXllciBpcyBfX2VzcmkuVGlsZUxheWVyfSBsYXllciBpcyBhIFRpbGVMYXllclxuICovXG5mdW5jdGlvbiBpc1RpbGVMYXllcihsYXllcikge1xuICAgIHJldHVybiBsYXllci50eXBlID09PSBcInRpbGVcIjtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBJbWFnZXJ5VGlsZUxheWVyXG4gKiBAcGFyYW0ge19fZXNyaS5MYXllcn0gbGF5ZXIgdGhlIGxheWVyIHRvIGNoZWNrIHRoZSB0eXBlIG9mXG4gKiBAcmV0dXJucyB7bGF5ZXIgaXMgX19lc3JpLkltYWdlcnlMYXllcn0gbGF5ZXIgaXMgYSBJbWFnZXJ5TGF5ZXJcbiAqL1xuZnVuY3Rpb24gaXNEeW5hbWljSW1hZ2VyeUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIChsYXllci50eXBlID09PSBcImltYWdlcnktdGlsZVwiICYmXG4gICAgICAgIGxheWVyLnNvdXJjZUpTT04uY2FwYWJpbGl0aWVzLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInRpbGVzb25seVwiKSA8IDApO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBpcyBhIEltYWdlcnlMYXllclxuICogQHBhcmFtIHtfX2VzcmkuTGF5ZXJ9IGxheWVyIHRoZSBsYXllciB0byBjaGVjayB0aGUgdHlwZSBvZlxuICogQHJldHVybnMge2xheWVyIGlzIF9fZXNyaS5JbWFnZXJ5TGF5ZXJ9IGxheWVyIGlzIGEgSW1hZ2VyeUxheWVyXG4gKi9cbmZ1bmN0aW9uIGlzSW1hZ2VyeUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeVwiIHx8IGlzRHluYW1pY0ltYWdlcnlMYXllcihsYXllcik7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgSW1hZ2VyeVRpbGVMYXllclxuICogQHBhcmFtIHtfX2VzcmkuTGF5ZXJ9IGxheWVyIHRoZSBsYXllciB0byBjaGVjayB0aGUgdHlwZSBvZlxuICogQHJldHVybnMge2xheWVyIGlzIF9fZXNyaS5JbWFnZXJ5VGlsZUxheWVyfSBsYXllciBpcyBhIEltYWdlcnlUaWxlTGF5ZXJcbiAqL1xuZnVuY3Rpb24gaXNJbWFnZXJ5VGlsZUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeS10aWxlXCIgJiYgIWlzRHluYW1pY0ltYWdlcnlMYXllcihsYXllcik7XG59XG5mdW5jdGlvbiBpc0V2ZXJ5UHJvcGVydHlFbXB0eSh2YWx1ZSkge1xuICAgIGxldCBpc0FsbFByb3BzRW1wdHkgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaXNBcnJheSh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHVzaW5nIGZvci1pbiBhcyBpdCB3aWxsIHdvcmsgd2l0aCBvYmplY3RzIHdpdGggcHJvcGVydGllcyB0aGF0IHNldCB2aWEgYWNjZXNzb3JzIGFzIHdlbGxcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGVsbCB0aGUgVHlwZVNjcmlwdCBjb21waWxlciB0aGF0IHRoZSBvYmogb2JqZWN0IGhhcyBhIHN0cmluZyBpbmRleCBzaWduYXR1cmUsXG4gICAgICAgICAgICAvLyBhbmQgd2lsbCBhbGxvdyB0byBhY2Nlc3MgaXRzIHByb3BlcnRpZXMgdXNpbmcgYSBzdHJpbmcgaW5kZXggd2l0aG91dCBnZXR0aW5nIHRoZSBcIkVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZVwiIGVycm9yLlxuICAgICAgICAgICAgY29uc3QgcHJvcFZhbHVlID0gdmFsdWU/Lltwcm9wXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSA9PT0gdHJ1ZSAmJiBwcm9wVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wVmFsdWUgIT09IG51bGwgJiYgcHJvcFZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaXNBbGxQcm9wc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzQWxsUHJvcHNFbXB0eTtcbn1cbi8qKlxuICogQ2hlY2sgZm9yIGFuIGVtcHR5IHZhbHVlIGZvciBkYXRhIGl0ZW1zIGxpa2UgR1BTdHJpbmcgYW5kIEZpZWxkLlxuICogQHBhcmFtIHZhbHVlIGRhdGEgaXRlbSB2YWx1ZS5cbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGNvbnNpZGVyZWQgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHlEYXRhSXRlbSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICB2YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAvLyBzaW5nbGUtc2VsZWN0LCBcIlwiIGlzIGEgc3BlY2lhbCBjYXNlIGZvciBzdHJpbmdzXG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgPT09IFwiXCIpIHx8XG4gICAgICAgIC8vIHNpbmdsZS1zZWxlY3QsIGVtcHR5IG9iamVjdHMgYXJlIGEgc3BlY2lhbCBjYXNlIGZvciBuZXN0ZWQgdmFsdWVzXG4gICAgICAgIChpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBpc0VtcHR5KHZhbHVlKSkgfHxcbiAgICAgICAgLy8gbXVsdGktc2VsZWN0XG4gICAgICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPCAxKSB8fFxuICAgICAgICAvLyBvbmx5IHRlc3Rpbmcgb2JqZWN0cyB3aGljaCBhcmUgbm90IGFycmF5c1xuICAgICAgICAvLyBUT0RPOiBjb21iaW5lIGlzRXZlcnlQcm9wZXJ0eUVtcHR5IGFuZCBpc0VtcHR5RGF0YUl0ZW0gdG8gc2luZ2xlIGZ1bmN0aW9uXG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaXNBcnJheSh2YWx1ZSkgPT09IGZhbHNlICYmIGlzRXZlcnlQcm9wZXJ0eUVtcHR5KHZhbHVlKSkpO1xufVxuXG5leHBvcnQgeyBBUkdTX0tFWVdPUkQgYXMgQSwgRlVOQ1RJT05fS0VZV09SRCBhcyBGLCBSRlZfVFlQRSBhcyBSLCBUWVBFX0tFWVdPUkQgYXMgVCwgaXNSRnhBcmcgYXMgYSwgUkZUX1RZUEUgYXMgYiwgaXNSZWZlcmVuY2VkT2JqZWN0IGFzIGMsIGlzTnVtYmVyIGFzIGQsIGlzV2lkZ2V0VmFsdWVCb29sZWFuIGFzIGUsIGlzQ29sb3JSYW1wIGFzIGYsIGlzUmVjb3JkU2V0IGFzIGcsIGlzRmVhdHVyZUxheWVyIGFzIGgsIGlzRW1wdHlEYXRhSXRlbSBhcyBpLCBpc1RpbGVMYXllciBhcyBqLCBpc0R5bmFtaWNJbWFnZXJ5TGF5ZXIgYXMgaywgaXNJbWFnZXJ5TGF5ZXIgYXMgbCwgaXNJbWFnZXJ5VGlsZUxheWVyIGFzIG0gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZS1nYXVyZHMtMTg0MDc0N2YuanMubWFwIiwiY29uc3QgVUlEZWZhdWx0cyA9IHtcbiAgICBTY2FsZTogXCJzXCIsXG4gICAgUG9wb3ZlclRpbWVyOiA2MFxufTtcbmNvbnN0IENhbGNpdGVTY2FsZSA9IHtcbiAgICBzOiBcInNcIixcbiAgICBtOiBcIm1cIlxufTtcbmNvbnN0IENhbGNpdGVPdmVybGF5UG9zaXRpb25pbmcgPSB7XG4gICAgYWJzb2x1dGU6IFwiYWJzb2x1dGVcIixcbiAgICBmaXhlZDogXCJmaXhlZFwiXG59O1xuXG5leHBvcnQgeyBDYWxjaXRlU2NhbGUgYXMgQywgVUlEZWZhdWx0cyBhcyBVLCBDYWxjaXRlT3ZlcmxheVBvc2l0aW9uaW5nIGFzIGEgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWktdXRpbHMtOTI4YTQwOTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9