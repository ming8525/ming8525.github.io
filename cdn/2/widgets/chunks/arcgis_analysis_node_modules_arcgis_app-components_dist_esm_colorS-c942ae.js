"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_colorS-c942ae"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorSizeUnivariant-d266ac7c.js":
/*!*************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorSizeUnivariant-d266ac7c.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ createColorSizeUnivariateRendererFromExisting),
/* harmony export */   c: () => (/* binding */ createColorSizeUnivariateRenderer),
/* harmony export */   g: () => (/* binding */ getColorSizeSliderStops)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/* harmony import */ var _color_d6da0a9a_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color-d6da0a9a.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/color-d6da0a9a.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */





/**
 * Creates a ColorSizeUnivariate renderer with default settings
 * @param options: options
 */
function createColorSizeUnivariateRenderer(options) {
    var _a;
    const { layer: smLayer, mapImageSublayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer));
    const fieldInfo = options.fieldInfos ? options.fieldInfos[0] : null;
    const theme = options.theme ? options.theme : "high-to-low";
    const config = {
        layer,
        view: mapView,
        field: fieldInfo.field,
        valueExpression: fieldInfo.expression,
        valueExpressionTitle: fieldInfo.expressionTitle,
        normalizationField: options.normalizationField,
        theme,
        legendOptions: options.legendOptions,
        colorOptions: {
            colorScheme: options.colorScheme || (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.P)(theme),
            isContinuous: (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.isContinuous) ? options.isContinuous : false
        },
        symbolOptions: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer)
            ? {
                symbolStyle: options.symbolOptions || "caret"
            }
            : undefined,
        symbols: options.symbols || undefined,
        minValue: options.min,
        maxValue: options.max,
        /* outlineOptimizationEnabled: mapImageSublayer
          ? false
          : isDefined(options.outlineOptimizationEnabled)
          ? options.outlineOptimizationEnabled
          : isPolygon(layer)
          ? true
          : false, */
        sizeOptimizationEnabled: mapImageSublayer || theme === "above-and-below"
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled)
                ? options.sizeOptimizationEnabled
                : true,
        defaultSymbolEnabled: false,
        forBinning: ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
    };
    // console.log("createColorSizeUnivariateRenderer-config", config);
    return modules.UnivariateColorSizeCreator.createContinuousRenderer(config).then((result) => {
        // console.log("createColorSizeUnivariateRenderer-success", result.renderer.toJSON());
        if (!options.noReuse &&
            ["color", "color-size", "color-size-age"].indexOf(rendererType) > -1 &&
            (0,_color_d6da0a9a_js__WEBPACK_IMPORTED_MODULE_3__.s)(options)) {
            // re-use color renderer
            const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer), "color");
            const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer), "color");
            if (colorVisVar && authColorVisVar) {
                if (theme === authColorVisVar.univariateTheme) {
                    result.renderer.visualVariables = [colorVisVar];
                    if (extras.sizeOutlineVisVar) {
                        result.renderer.visualVariables.push(extras.sizeOutlineVisVar);
                    }
                    result.renderer.authoringInfo.visualVariables = [authColorVisVar];
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.Q)(result.renderer);
                }
            }
        }
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer);
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
/**
 * Creates a Color renderer with settings from current renderer
 */
function createColorSizeUnivariateRendererFromExisting(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { layer: smLayer, mapImageSublayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
    if (colorVisVar &&
        options.fieldInfos &&
        options.fieldInfos[0] &&
        options.fieldInfos[0].field == colorVisVar.field &&
        options.fieldInfos[0].expression == colorVisVar.valueExpression &&
        options.normalizationField === colorVisVar.normalizationField) {
        // no changes to fields
        delete options.fieldInfos;
        if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.R)(options)) {
            // nothing really changes
            return Promise.resolve({ renderer: renderer.clone() });
        }
    }
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)(renderer);
    const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size");
    const authInfo = renderer.authoringInfo;
    const authSizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)(renderer, "size");
    let fieldInfo = options.fieldInfos
        ? options.fieldInfos[0]
        : colorVisVar
            ? {
                field: colorVisVar.field,
                expression: colorVisVar.valueExpression,
                expressionTitle: colorVisVar.valueExpressionTitle,
                simpleFieldType: ((_a = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.u)(colorVisVar.field)) === null || _a === void 0 ? void 0 : _a.simpleFieldType) || _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.NUMBER
            }
            : {
                field: renderer.field,
                expression: renderer.valueExpression,
                expressionTitle: renderer.valueExpressionTitle,
                simpleFieldType: ((_b = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.u)(renderer.field)) === null || _b === void 0 ? void 0 : _b.simpleFieldType) || _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.NUMBER
            };
    const normalizationField = options.normalizationField === null
        ? undefined
        : options.normalizationField
            ? options.normalizationField
            : colorVisVar
                ? colorVisVar.normalizationField
                : renderer.normalizationField;
    const theme = options.theme ? options.theme : authInfo ? authInfo.univariateTheme : "high-to-low";
    const wasAboveAndBelow = authInfo.univariateTheme === "above-and-below";
    const isAboveAndBelow = theme === "above-and-below";
    const wasCustom = authInfo.univariateSymbolStyle === "custom";
    if (options.symbolStyle === "custom" && !options.symbols) {
        // use current symbols
        if (renderer.classBreakInfos.length === 1) {
            options.symbols = [
                modules.esriLang.clone(renderer.classBreakInfos[0].symbol),
                modules.esriLang.clone(renderer.classBreakInfos[0].symbol)
            ];
        }
        else {
            options.symbols = [
                modules.esriLang.clone(renderer.classBreakInfos[0].symbol),
                modules.esriLang.clone(renderer.classBreakInfos[1].symbol)
            ];
        }
    }
    const isContinuous = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.isContinuous)
        ? options.isContinuous
        : !wasAboveAndBelow && isAboveAndBelow
            ? false // default to binary for above-and-below
            : !!colorVisVar;
    const hasPMS = ((_c = renderer.classBreakInfos[0].symbol) === null || _c === void 0 ? void 0 : _c.type) === "picture-marker" ||
        ((_d = renderer.classBreakInfos[renderer.classBreakInfos.length === 2 ? 1 : 0].symbol) === null || _d === void 0 ? void 0 : _d.type) === "picture-marker";
    const symbolStyle = (!wasAboveAndBelow && isAboveAndBelow) || (hasPMS && isContinuous)
        ? "caret"
        : isAboveAndBelow
            ? options.symbolStyle
                ? ["single", "custom"].indexOf(options.symbolStyle) > -1
                    ? undefined
                    : options.symbolStyle
                : !options.symbols
                    ? authInfo.univariateSymbolStyle !== "custom"
                        ? authInfo.univariateSymbolStyle
                        : undefined
                    : undefined
            : undefined;
    const reuseSymbols = !(hasPMS && isContinuous) && (options.symbolStyle === "custom" || (!options.symbolStyle && wasCustom));
    let symbolOptions = isAboveAndBelow && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer)
        ? {
            symbolStyle,
            symbols: symbolStyle
                ? undefined
                : ((_e = options.symbols) === null || _e === void 0 ? void 0 : _e.length) === 2 // custom; use new symbols
                    ? {
                        below: options.symbols[0],
                        above: options.symbols[1]
                    }
                    : ((_f = options.symbols) === null || _f === void 0 ? void 0 : _f.length) === 1 // single; we replace later
                        ? undefined
                        : reuseSymbols
                            ? {
                                below: renderer.classBreakInfos[0].symbol,
                                above: renderer.classBreakInfos[renderer.classBreakInfos.length === 2 ? 1 : 0].symbol
                            }
                            : undefined
        }
        : undefined;
    if (!(symbolOptions === null || symbolOptions === void 0 ? void 0 : symbolOptions.symbolStyle) && !(symbolOptions === null || symbolOptions === void 0 ? void 0 : symbolOptions.symbols)) {
        symbolOptions = undefined;
    }
    if (isContinuous && (symbolOptions === null || symbolOptions === void 0 ? void 0 : symbolOptions.symbols)) {
        // we want the symbols to be grey
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(symbolOptions === null || symbolOptions === void 0 ? void 0 : symbolOptions.symbols.below, new modules.esriColor([0, 0, 0, 0.5]));
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(symbolOptions === null || symbolOptions === void 0 ? void 0 : symbolOptions.symbols.above, new modules.esriColor([0, 0, 0, 0.5]));
    }
    const defaultSymbol = renderer.defaultSymbol;
    const defaultLabel = renderer.defaultLabel;
    const backgroundFillSymbol = renderer.backgroundFillSymbol;
    let isInverted = false;
    if (theme === (authInfo === null || authInfo === void 0 ? void 0 : authInfo.univariateTheme)) {
        // only if theme stays the same
        if ((0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(sizeVisVar.minSize)) {
            if (sizeVisVar.minSize.stops) {
                isInverted = sizeVisVar.minSize.stops[0].size > sizeVisVar.maxSize.stops[0].size;
            }
            else {
                isInverted = sizeVisVar.minSize > sizeVisVar.maxSize;
            }
        }
    }
    let needNewStatistics = false;
    if (options.normalizationField === null ||
        options.normalizationField ||
        (options.fieldInfos && options.fieldInfos[0])) {
        needNewStatistics = true;
    }
    const aboveAndBelowSwitch = (isAboveAndBelow && !wasAboveAndBelow) || (!isAboveAndBelow && wasAboveAndBelow);
    const minValue = options.discardMinMax
        ? undefined
        : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.min)
            ? options.min
            : needNewStatistics
                ? undefined
                : authSizeVisVar
                    ? authSizeVisVar.minSliderValue
                    : undefined;
    const maxValue = options.discardMinMax
        ? undefined
        : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.max)
            ? options.max
            : needNewStatistics
                ? undefined
                : authSizeVisVar
                    ? authSizeVisVar.maxSliderValue
                    : undefined;
    const wasBelow = authInfo.univariateTheme === "below";
    const isBelow = theme === "below";
    const belowSwitch = (isBelow && !wasBelow) || (!isBelow && wasBelow);
    const colorScheme = options.colorScheme || (!aboveAndBelowSwitch && (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.P)(theme));
    const config = {
        layer,
        view: mapView,
        field: fieldInfo.field,
        valueExpression: fieldInfo.expression,
        valueExpressionTitle: fieldInfo.expressionTitle,
        theme,
        legendOptions: options.legendOptions || sizeVisVar.legendOptions,
        colorOptions: {
            colorScheme,
            isContinuous
        },
        symbolOptions,
        normalizationField,
        minValue,
        maxValue,
        /* outlineOptimizationEnabled: mapImageSublayer
          ? false
          : isDefined(options.outlineOptimizationEnabled)
          ? options.outlineOptimizationEnabled
          : !!extras.sizeOutlineVisVar, */
        sizeOptimizationEnabled: mapImageSublayer || theme === "above-and-below"
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled)
                ? options.sizeOptimizationEnabled
                : !!(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)((_g = sizeVisVar.minSize) === null || _g === void 0 ? void 0 : _g.stops),
        defaultSymbolEnabled: (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.defaultSymbolEnabled)
            ? options.defaultSymbolEnabled
            : !!renderer.defaultSymbol,
        forBinning: ((_h = layer.featureReduction) === null || _h === void 0 ? void 0 : _h.type) === "binning"
    };
    // console.log("createColorSizeUnivariateRendererFromExisting-config", config);
    return modules.UnivariateColorSizeCreator.createContinuousRenderer(config).then((result) => {
        var _a, _b, _c, _d, _e;
        // console.log("createColorSizeUnivariateRendererFromExisting-success", result.renderer.toJSON());
        // reset handles and data values if necessary
        if (options.discardMinMax) {
            const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
            const newColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "color");
            colorVisVar === null || colorVisVar === void 0 ? void 0 : colorVisVar.stops.forEach((stop, idx) => (stop.value = newColorVisVar === null || newColorVisVar === void 0 ? void 0 : newColorVisVar.stops[idx].value));
            const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size");
            const newSizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "size");
            const isAboveAndBelow = authInfo.univariateTheme === "above-and-below";
            if (isAboveAndBelow) {
                (_a = sizeVisVar.stops) === null || _a === void 0 ? void 0 : _a.forEach((stop, idx) => {
                    if (newSizeVisVar.stops) {
                        stop.value = newSizeVisVar.stops[idx].value;
                    }
                });
            }
            else {
                sizeVisVar.minDataValue = newSizeVisVar.minDataValue;
                sizeVisVar.maxDataValue = newSizeVisVar.maxDataValue;
            }
        }
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer);
        if (isAboveAndBelow) {
            // save new colors
            const colorAt0 = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(result.renderer.classBreakInfos[0].symbol);
            const colorAt1 = result.renderer.classBreakInfos[1]
                ? (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(result.renderer.classBreakInfos[1].symbol)
                : colorAt0;
            if (!symbolStyle) {
                // single symbol; apply correct symbol
                if (((_b = options.symbols) === null || _b === void 0 ? void 0 : _b.length) === 1 && result.renderer.classBreakInfos.length === 1) {
                    // use new one; continuous scheme
                    result.renderer.classBreakInfos[0].symbol = options.symbols[0];
                }
                else if (((_c = options.symbols) === null || _c === void 0 ? void 0 : _c.length) === 2 && result.renderer.classBreakInfos.length === 1) {
                    // use new ones; binary scheme
                    const sym = modules.esriLang.clone(renderer.classBreakInfos[0].symbol);
                    result.renderer.classBreakInfos[0].symbol = sym;
                }
                else if (options.symbolStyle === "single" && result.renderer.classBreakInfos.length === 2) {
                    // use first symbol for both
                    let sym = modules.esriLang.clone(renderer.classBreakInfos[0].symbol);
                    result.renderer.classBreakInfos[0].symbol = sym.clone();
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(sym, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(result.renderer.classBreakInfos[1].symbol));
                    result.renderer.classBreakInfos[1].symbol = sym;
                    result.renderer.authoringInfo.univariateSymbolStyle = undefined;
                }
                else {
                    // keep old symbol(s)
                    let sym = modules.esriLang.clone(renderer.classBreakInfos[0].symbol);
                    result.renderer.classBreakInfos[0].symbol = sym;
                    if (result.renderer.classBreakInfos[1]) {
                        if (renderer.classBreakInfos[1]) {
                            sym = modules.esriLang.clone(renderer.classBreakInfos[1].symbol);
                        }
                        else {
                            // lines
                            sym = modules.esriLang.clone(renderer.classBreakInfos[0].symbol);
                        }
                        result.renderer.classBreakInfos[1].symbol = sym;
                    }
                }
            }
            const newColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "color");
            if (!newColorVisVar) {
                // was binary and is still binary
                if (!colorVisVar && !newColorVisVar) {
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(result.renderer.classBreakInfos[0].symbol, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(renderer.classBreakInfos[0].symbol));
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(result.renderer.classBreakInfos[1].symbol, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(renderer.classBreakInfos[1].symbol));
                }
                else {
                    // was continuous and is now binary
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(result.renderer.classBreakInfos[0].symbol, colorAt0);
                    if (result.renderer.classBreakInfos[1]) {
                        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(result.renderer.classBreakInfos[1].symbol, colorAt1);
                    }
                }
            }
            else {
                // continuous; make symbols grey
                const grey = new modules.esriColor([0, 0, 0, 0.5]);
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(result.renderer.classBreakInfos[0].symbol, grey);
                if (result.renderer.classBreakInfos[1]) {
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(result.renderer.classBreakInfos[1].symbol, grey);
                }
            }
        }
        else if (!isAboveAndBelow) {
            // high-to-low, above, below
            if (((_d = options.symbols) === null || _d === void 0 ? void 0 : _d.length) === 1) {
                // use new one
                result.renderer.classBreakInfos[0].symbol = options.symbols[0];
            }
            else if (((_e = renderer.classBreakInfos) === null || _e === void 0 ? void 0 : _e.length) === 1) {
                // keep previous one
                result.renderer.classBreakInfos[0].symbol = renderer.classBreakInfos[0].symbol;
            }
        }
        if (wasAboveAndBelow && isAboveAndBelow && !needNewStatistics) {
            // keep old stops
            const newSizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "size");
            const newColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "color");
            newSizeVisVar.stops = modules.esriLang.clone(sizeVisVar.stops);
            if (newColorVisVar) {
                newColorVisVar.stops.forEach((colorStop, idx) => {
                    colorStop.value = sizeVisVar.stops[idx].value;
                });
            }
            if (result.renderer.classBreakInfos.length == 2) {
                result.renderer.classBreakInfos[0].maxValue = sizeVisVar.stops[2].value;
                result.renderer.classBreakInfos[1].minValue = sizeVisVar.stops[2].value;
            }
        }
        if (belowSwitch && colorScheme && colorVisVar) {
            // need to reverse color order
            const newColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "color");
            const len = colorVisVar.stops.length - 1;
            newColorVisVar.stops.forEach((colorStop, idx) => {
                colorStop.color = colorVisVar.stops[len - idx].color;
            });
        }
        if (defaultSymbol) {
            result.renderer.defaultSymbol = defaultSymbol;
            result.renderer.defaultLabel = defaultLabel;
        }
        if (backgroundFillSymbol) {
            result.renderer.backgroundFillSymbol = backgroundFillSymbol;
        }
        else {
            result.renderer.backgroundFillSymbol = undefined;
        }
        if (isInverted) {
            const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "size");
            const tmp = sizeVisVar.minSize;
            sizeVisVar.minSize = sizeVisVar.maxSize;
            sizeVisVar.maxSize = tmp;
        }
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
function getColorSizeSliderStops() {
    const { layer, mapView } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
    const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size");
    const scale = mapView.scale;
    const { minSize, maxSize } = sizeVisVar;
    let stops;
    if (sizeVisVar.stops) {
        // above-and-below
        stops = colorVisVar.stops.map((colorStop, idx) => {
            const sizeStop = sizeVisVar.stops[idx];
            return {
                color: colorStop.color,
                size: sizeStop.size,
                value: sizeStop.value
            };
        });
    }
    else {
        const lastColorIdx = colorVisVar.stops.length - 1;
        if (typeof minSize === "number") {
            // high-to-low fixed
            stops = colorVisVar.stops.map((colorStop, idx) => {
                return {
                    color: colorStop.color,
                    value: colorStop.value,
                    size: idx === 0 ? minSize : idx === lastColorIdx ? maxSize : null
                };
            });
        }
        else {
            // hight-to-low automatic
            // find the minSize/maxSize for current scale
            let min, max;
            const lastSizeIdx = minSize.stops.length - 1;
            if (scale > minSize.stops[lastSizeIdx].value) {
                min = minSize.stops[lastSizeIdx].size;
                max = maxSize.stops[lastSizeIdx].size;
            }
            else {
                minSize.stops.forEach((sizeStop, idx) => {
                    if (scale <= sizeStop.value) {
                        min = sizeStop.size;
                        max = maxSize.stops[idx].size;
                    }
                });
            }
            const minData = sizeVisVar.minDataValue;
            const maxData = sizeVisVar.maxDataValue;
            const step = (maxData - minData) / 4;
            stops = colorVisVar.stops.map((colorStop, idx) => {
                return {
                    color: colorStop.color,
                    value: idx === 0 ? minData : idx === lastColorIdx ? maxData : minData + idx * step,
                    size: idx === 0 ? min : idx === lastColorIdx ? max : undefined
                };
            });
        }
    }
    return stops;
}



//# sourceMappingURL=colorSizeUnivariant-d266ac7c.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loading-69139907.js":
/*!*************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loading-69139907.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: () => (/* binding */ requestWrapper)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
let _loadingTimer;
let _requestCancelled;
function startLoading(node) {
    node.loading = true;
    _requestCancelled = false;
    if (_loadingTimer) {
        clearTimeout(_loadingTimer);
    }
    _loadingTimer = setTimeout(() => {
        // took too long
        endLoading(node);
        _requestCancelled = true;
    }, 60000);
}
function endLoading(node) {
    node.loading = false;
}
function requestWrapper(request, node) {
    startLoading(node);
    return request
        .then((result) => {
        endLoading(node);
        if (!_requestCancelled) {
            return Promise.resolve(result);
        }
        else {
            return Promise.reject(new Error("timeout"));
        }
    })
        .catch((error) => {
        endLoading(node);
        return Promise.reject(error);
    });
}



//# sourceMappingURL=loading-69139907.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fY29sb3JTLWM5NDJhZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNlc7QUFDMVU7QUFDNEI7QUFDTDs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBcUQsRUFBRSwrREFBaUI7QUFDcEY7QUFDQTtBQUNBLHlCQUF5QixtRUFBZTtBQUN4QyxtQkFBbUIsbUVBQWdCLENBQUMsbUVBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG1FQUFlO0FBQy9ELDBCQUEwQiwrREFBUztBQUNuQyxTQUFTO0FBQ1Qsd0JBQXdCLG1FQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQWM7QUFDMUI7QUFDQSxnQ0FBZ0MsbUVBQVMsQ0FBQyxtRUFBVztBQUNyRCxvQ0FBb0MsbUVBQWEsQ0FBQyxtRUFBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBaUI7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBcUQsRUFBRSwrREFBaUI7QUFDcEY7QUFDQTtBQUNBLHFCQUFxQixtRUFBVztBQUNoQyx3QkFBd0IsbUVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNsZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFK0I7O0FBRS9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vY29sb3JTaXplVW5pdmFyaWFudC1kMjY2YWM3Yy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2FkaW5nLTY5MTM5OTA3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgaCBhcyBnZXRSZW5kZXJlciwgYSBhcyBnZXRWaXNWYXIsIFIgYXMgaXNFbXB0eSwgbSBhcyBzYXZlRXh0cmFWaXNWYXJzLCBwIGFzIGdldEF1dGhWaXNWYXIsIHUgYXMgZ2V0RmllbGQsIHcgYXMgc2ltcGxlRmllbGRUeXBlcywgQiBhcyBpc1BvbHlsaW5lVHlwZSwgciBhcyBhcHBseVN5bWJvbENvbG9yLCBQIGFzIGZpbmRDb2xvclNjaGVtZSwgbCBhcyBhcHBseUV4dHJhVmlzVmFycywgdCBhcyBnZXRTeW1ib2xDb2xvciwgUSBhcyBmaXhOb3JtYWxpemF0aW9uRmllbGQsIHMgYXMgc21hcnRNYXBwaW5nU3RhdGUsIGcgYXMgZ2V0UmVuZGVyZXJUeXBlIH0gZnJvbSAnLi9yYXN0ZXItdW5pcXVlLXZhbHVlLTA5NzZlYzdmLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzRGVmaW5lZCB9IGZyb20gJy4vY29tbW9uRnVuY3Rpb25zLWIwODMwZTllLmpzJztcbmltcG9ydCB7IHMgYXMgc2FtZUNvbG9yRmllbGQgfSBmcm9tICcuL2NvbG9yLWQ2ZGEwYTlhLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ29sb3JTaXplVW5pdmFyaWF0ZSByZW5kZXJlciB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAqIEBwYXJhbSBvcHRpb25zOiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yU2l6ZVVuaXZhcmlhdGVSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIG1hcFZpZXcsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByZW5kZXJlclR5cGUgPSBnZXRSZW5kZXJlclR5cGUoKTtcbiAgICBjb25zdCBleHRyYXMgPSBzYXZlRXh0cmFWaXNWYXJzKGdldFJlbmRlcmVyKGxheWVyKSk7XG4gICAgY29uc3QgZmllbGRJbmZvID0gb3B0aW9ucy5maWVsZEluZm9zID8gb3B0aW9ucy5maWVsZEluZm9zWzBdIDogbnVsbDtcbiAgICBjb25zdCB0aGVtZSA9IG9wdGlvbnMudGhlbWUgPyBvcHRpb25zLnRoZW1lIDogXCJoaWdoLXRvLWxvd1wiO1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXc6IG1hcFZpZXcsXG4gICAgICAgIGZpZWxkOiBmaWVsZEluZm8uZmllbGQsXG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbjogZmllbGRJbmZvLmV4cHJlc3Npb24sXG4gICAgICAgIHZhbHVlRXhwcmVzc2lvblRpdGxlOiBmaWVsZEluZm8uZXhwcmVzc2lvblRpdGxlLFxuICAgICAgICBub3JtYWxpemF0aW9uRmllbGQ6IG9wdGlvbnMubm9ybWFsaXphdGlvbkZpZWxkLFxuICAgICAgICB0aGVtZSxcbiAgICAgICAgbGVnZW5kT3B0aW9uczogb3B0aW9ucy5sZWdlbmRPcHRpb25zLFxuICAgICAgICBjb2xvck9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNvbG9yU2NoZW1lOiBvcHRpb25zLmNvbG9yU2NoZW1lIHx8IGZpbmRDb2xvclNjaGVtZSh0aGVtZSksXG4gICAgICAgICAgICBpc0NvbnRpbnVvdXM6IGlzRGVmaW5lZChvcHRpb25zLmlzQ29udGludW91cykgPyBvcHRpb25zLmlzQ29udGludW91cyA6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbE9wdGlvbnM6ICFpc1BvbHlsaW5lVHlwZShsYXllcilcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlOiBvcHRpb25zLnN5bWJvbE9wdGlvbnMgfHwgXCJjYXJldFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sczogb3B0aW9ucy5zeW1ib2xzIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbWluVmFsdWU6IG9wdGlvbnMubWluLFxuICAgICAgICBtYXhWYWx1ZTogb3B0aW9ucy5tYXgsXG4gICAgICAgIC8qIG91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkOiBtYXBJbWFnZVN1YmxheWVyXG4gICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgIDogaXNEZWZpbmVkKG9wdGlvbnMub3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWQpXG4gICAgICAgICAgPyBvcHRpb25zLm91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkXG4gICAgICAgICAgOiBpc1BvbHlnb24obGF5ZXIpXG4gICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgOiBmYWxzZSwgKi9cbiAgICAgICAgc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQ6IG1hcEltYWdlU3VibGF5ZXIgfHwgdGhlbWUgPT09IFwiYWJvdmUtYW5kLWJlbG93XCJcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogaXNEZWZpbmVkKG9wdGlvbnMuc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQpXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnNpemVPcHRpbWl6YXRpb25FbmFibGVkXG4gICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICBkZWZhdWx0U3ltYm9sRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvckJpbm5pbmc6ICgoX2EgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiYmlubmluZ1wiXG4gICAgfTtcbiAgICAvLyBjb25zb2xlLmxvZyhcImNyZWF0ZUNvbG9yU2l6ZVVuaXZhcmlhdGVSZW5kZXJlci1jb25maWdcIiwgY29uZmlnKTtcbiAgICByZXR1cm4gbW9kdWxlcy5Vbml2YXJpYXRlQ29sb3JTaXplQ3JlYXRvci5jcmVhdGVDb250aW51b3VzUmVuZGVyZXIoY29uZmlnKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJjcmVhdGVDb2xvclNpemVVbml2YXJpYXRlUmVuZGVyZXItc3VjY2Vzc1wiLCByZXN1bHQucmVuZGVyZXIudG9KU09OKCkpO1xuICAgICAgICBpZiAoIW9wdGlvbnMubm9SZXVzZSAmJlxuICAgICAgICAgICAgW1wiY29sb3JcIiwgXCJjb2xvci1zaXplXCIsIFwiY29sb3Itc2l6ZS1hZ2VcIl0uaW5kZXhPZihyZW5kZXJlclR5cGUpID4gLTEgJiZcbiAgICAgICAgICAgIHNhbWVDb2xvckZpZWxkKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvLyByZS11c2UgY29sb3IgcmVuZGVyZXJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKGdldFJlbmRlcmVyKGxheWVyKSwgXCJjb2xvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IGF1dGhDb2xvclZpc1ZhciA9IGdldEF1dGhWaXNWYXIoZ2V0UmVuZGVyZXIobGF5ZXIpLCBcImNvbG9yXCIpO1xuICAgICAgICAgICAgaWYgKGNvbG9yVmlzVmFyICYmIGF1dGhDb2xvclZpc1Zhcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGVtZSA9PT0gYXV0aENvbG9yVmlzVmFyLnVuaXZhcmlhdGVUaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIudmlzdWFsVmFyaWFibGVzID0gW2NvbG9yVmlzVmFyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhcy5zaXplT3V0bGluZVZpc1Zhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcy5wdXNoKGV4dHJhcy5zaXplT3V0bGluZVZpc1Zhcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmF1dGhvcmluZ0luZm8udmlzdWFsVmFyaWFibGVzID0gW2F1dGhDb2xvclZpc1Zhcl07XG4gICAgICAgICAgICAgICAgICAgIGZpeE5vcm1hbGl6YXRpb25GaWVsZChyZXN1bHQucmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcHBseUV4dHJhVmlzVmFycyhleHRyYXMsIHJlc3VsdC5yZW5kZXJlcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBDb2xvciByZW5kZXJlciB3aXRoIHNldHRpbmdzIGZyb20gY3VycmVudCByZW5kZXJlclxuICovXG5mdW5jdGlvbiBjcmVhdGVDb2xvclNpemVVbml2YXJpYXRlUmVuZGVyZXJGcm9tRXhpc3Rpbmcob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwSW1hZ2VTdWJsYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgIGlmIChjb2xvclZpc1ZhciAmJlxuICAgICAgICBvcHRpb25zLmZpZWxkSW5mb3MgJiZcbiAgICAgICAgb3B0aW9ucy5maWVsZEluZm9zWzBdICYmXG4gICAgICAgIG9wdGlvbnMuZmllbGRJbmZvc1swXS5maWVsZCA9PSBjb2xvclZpc1Zhci5maWVsZCAmJlxuICAgICAgICBvcHRpb25zLmZpZWxkSW5mb3NbMF0uZXhwcmVzc2lvbiA9PSBjb2xvclZpc1Zhci52YWx1ZUV4cHJlc3Npb24gJiZcbiAgICAgICAgb3B0aW9ucy5ub3JtYWxpemF0aW9uRmllbGQgPT09IGNvbG9yVmlzVmFyLm5vcm1hbGl6YXRpb25GaWVsZCkge1xuICAgICAgICAvLyBubyBjaGFuZ2VzIHRvIGZpZWxkc1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5maWVsZEluZm9zO1xuICAgICAgICBpZiAoaXNFbXB0eShvcHRpb25zKSkge1xuICAgICAgICAgICAgLy8gbm90aGluZyByZWFsbHkgY2hhbmdlc1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHJlbmRlcmVyOiByZW5kZXJlci5jbG9uZSgpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhcyA9IHNhdmVFeHRyYVZpc1ZhcnMocmVuZGVyZXIpO1xuICAgIGNvbnN0IHNpemVWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICBjb25zdCBhdXRoSW5mbyA9IHJlbmRlcmVyLmF1dGhvcmluZ0luZm87XG4gICAgY29uc3QgYXV0aFNpemVWaXNWYXIgPSBnZXRBdXRoVmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIik7XG4gICAgbGV0IGZpZWxkSW5mbyA9IG9wdGlvbnMuZmllbGRJbmZvc1xuICAgICAgICA/IG9wdGlvbnMuZmllbGRJbmZvc1swXVxuICAgICAgICA6IGNvbG9yVmlzVmFyXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBmaWVsZDogY29sb3JWaXNWYXIuZmllbGQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogY29sb3JWaXNWYXIudmFsdWVFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25UaXRsZTogY29sb3JWaXNWYXIudmFsdWVFeHByZXNzaW9uVGl0bGUsXG4gICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiAoKF9hID0gZ2V0RmllbGQoY29sb3JWaXNWYXIuZmllbGQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2ltcGxlRmllbGRUeXBlKSB8fCBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IHJlbmRlcmVyLmZpZWxkLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHJlbmRlcmVyLnZhbHVlRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uVGl0bGU6IHJlbmRlcmVyLnZhbHVlRXhwcmVzc2lvblRpdGxlLFxuICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogKChfYiA9IGdldEZpZWxkKHJlbmRlcmVyLmZpZWxkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNpbXBsZUZpZWxkVHlwZSkgfHwgc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXphdGlvbkZpZWxkID0gb3B0aW9ucy5ub3JtYWxpemF0aW9uRmllbGQgPT09IG51bGxcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBvcHRpb25zLm5vcm1hbGl6YXRpb25GaWVsZFxuICAgICAgICAgICAgPyBvcHRpb25zLm5vcm1hbGl6YXRpb25GaWVsZFxuICAgICAgICAgICAgOiBjb2xvclZpc1ZhclxuICAgICAgICAgICAgICAgID8gY29sb3JWaXNWYXIubm9ybWFsaXphdGlvbkZpZWxkXG4gICAgICAgICAgICAgICAgOiByZW5kZXJlci5ub3JtYWxpemF0aW9uRmllbGQ7XG4gICAgY29uc3QgdGhlbWUgPSBvcHRpb25zLnRoZW1lID8gb3B0aW9ucy50aGVtZSA6IGF1dGhJbmZvID8gYXV0aEluZm8udW5pdmFyaWF0ZVRoZW1lIDogXCJoaWdoLXRvLWxvd1wiO1xuICAgIGNvbnN0IHdhc0Fib3ZlQW5kQmVsb3cgPSBhdXRoSW5mby51bml2YXJpYXRlVGhlbWUgPT09IFwiYWJvdmUtYW5kLWJlbG93XCI7XG4gICAgY29uc3QgaXNBYm92ZUFuZEJlbG93ID0gdGhlbWUgPT09IFwiYWJvdmUtYW5kLWJlbG93XCI7XG4gICAgY29uc3Qgd2FzQ3VzdG9tID0gYXV0aEluZm8udW5pdmFyaWF0ZVN5bWJvbFN0eWxlID09PSBcImN1c3RvbVwiO1xuICAgIGlmIChvcHRpb25zLnN5bWJvbFN0eWxlID09PSBcImN1c3RvbVwiICYmICFvcHRpb25zLnN5bWJvbHMpIHtcbiAgICAgICAgLy8gdXNlIGN1cnJlbnQgc3ltYm9sc1xuICAgICAgICBpZiAocmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgb3B0aW9ucy5zeW1ib2xzID0gW1xuICAgICAgICAgICAgICAgIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUocmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLnN5bWJvbCksXG4gICAgICAgICAgICAgICAgbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShyZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMF0uc3ltYm9sKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3ltYm9scyA9IFtcbiAgICAgICAgICAgICAgICBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5zeW1ib2wpLFxuICAgICAgICAgICAgICAgIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUocmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzFdLnN5bWJvbClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNDb250aW51b3VzID0gaXNEZWZpbmVkKG9wdGlvbnMuaXNDb250aW51b3VzKVxuICAgICAgICA/IG9wdGlvbnMuaXNDb250aW51b3VzXG4gICAgICAgIDogIXdhc0Fib3ZlQW5kQmVsb3cgJiYgaXNBYm92ZUFuZEJlbG93XG4gICAgICAgICAgICA/IGZhbHNlIC8vIGRlZmF1bHQgdG8gYmluYXJ5IGZvciBhYm92ZS1hbmQtYmVsb3dcbiAgICAgICAgICAgIDogISFjb2xvclZpc1ZhcjtcbiAgICBjb25zdCBoYXNQTVMgPSAoKF9jID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLnN5bWJvbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnR5cGUpID09PSBcInBpY3R1cmUtbWFya2VyXCIgfHxcbiAgICAgICAgKChfZCA9IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1tyZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MubGVuZ3RoID09PSAyID8gMSA6IDBdLnN5bWJvbCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnR5cGUpID09PSBcInBpY3R1cmUtbWFya2VyXCI7XG4gICAgY29uc3Qgc3ltYm9sU3R5bGUgPSAoIXdhc0Fib3ZlQW5kQmVsb3cgJiYgaXNBYm92ZUFuZEJlbG93KSB8fCAoaGFzUE1TICYmIGlzQ29udGludW91cylcbiAgICAgICAgPyBcImNhcmV0XCJcbiAgICAgICAgOiBpc0Fib3ZlQW5kQmVsb3dcbiAgICAgICAgICAgID8gb3B0aW9ucy5zeW1ib2xTdHlsZVxuICAgICAgICAgICAgICAgID8gW1wic2luZ2xlXCIsIFwiY3VzdG9tXCJdLmluZGV4T2Yob3B0aW9ucy5zeW1ib2xTdHlsZSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbnMuc3ltYm9sU3R5bGVcbiAgICAgICAgICAgICAgICA6ICFvcHRpb25zLnN5bWJvbHNcbiAgICAgICAgICAgICAgICAgICAgPyBhdXRoSW5mby51bml2YXJpYXRlU3ltYm9sU3R5bGUgIT09IFwiY3VzdG9tXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYXV0aEluZm8udW5pdmFyaWF0ZVN5bWJvbFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmV1c2VTeW1ib2xzID0gIShoYXNQTVMgJiYgaXNDb250aW51b3VzKSAmJiAob3B0aW9ucy5zeW1ib2xTdHlsZSA9PT0gXCJjdXN0b21cIiB8fCAoIW9wdGlvbnMuc3ltYm9sU3R5bGUgJiYgd2FzQ3VzdG9tKSk7XG4gICAgbGV0IHN5bWJvbE9wdGlvbnMgPSBpc0Fib3ZlQW5kQmVsb3cgJiYgIWlzUG9seWxpbmVUeXBlKGxheWVyKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHN5bWJvbFN0eWxlLFxuICAgICAgICAgICAgc3ltYm9sczogc3ltYm9sU3R5bGVcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogKChfZSA9IG9wdGlvbnMuc3ltYm9scykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmxlbmd0aCkgPT09IDIgLy8gY3VzdG9tOyB1c2UgbmV3IHN5bWJvbHNcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWxvdzogb3B0aW9ucy5zeW1ib2xzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvdmU6IG9wdGlvbnMuc3ltYm9sc1sxXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogKChfZiA9IG9wdGlvbnMuc3ltYm9scykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmxlbmd0aCkgPT09IDEgLy8gc2luZ2xlOyB3ZSByZXBsYWNlIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXVzZVN5bWJvbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVsb3c6IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3ZlOiByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmxlbmd0aCA9PT0gMiA/IDEgOiAwXS5zeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIShzeW1ib2xPcHRpb25zID09PSBudWxsIHx8IHN5bWJvbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbE9wdGlvbnMuc3ltYm9sU3R5bGUpICYmICEoc3ltYm9sT3B0aW9ucyA9PT0gbnVsbCB8fCBzeW1ib2xPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzeW1ib2xPcHRpb25zLnN5bWJvbHMpKSB7XG4gICAgICAgIHN5bWJvbE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc0NvbnRpbnVvdXMgJiYgKHN5bWJvbE9wdGlvbnMgPT09IG51bGwgfHwgc3ltYm9sT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ltYm9sT3B0aW9ucy5zeW1ib2xzKSkge1xuICAgICAgICAvLyB3ZSB3YW50IHRoZSBzeW1ib2xzIHRvIGJlIGdyZXlcbiAgICAgICAgYXBwbHlTeW1ib2xDb2xvcihzeW1ib2xPcHRpb25zID09PSBudWxsIHx8IHN5bWJvbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbE9wdGlvbnMuc3ltYm9scy5iZWxvdywgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSk7XG4gICAgICAgIGFwcGx5U3ltYm9sQ29sb3Ioc3ltYm9sT3B0aW9ucyA9PT0gbnVsbCB8fCBzeW1ib2xPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzeW1ib2xPcHRpb25zLnN5bWJvbHMuYWJvdmUsIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSkpO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U3ltYm9sID0gcmVuZGVyZXIuZGVmYXVsdFN5bWJvbDtcbiAgICBjb25zdCBkZWZhdWx0TGFiZWwgPSByZW5kZXJlci5kZWZhdWx0TGFiZWw7XG4gICAgY29uc3QgYmFja2dyb3VuZEZpbGxTeW1ib2wgPSByZW5kZXJlci5iYWNrZ3JvdW5kRmlsbFN5bWJvbDtcbiAgICBsZXQgaXNJbnZlcnRlZCA9IGZhbHNlO1xuICAgIGlmICh0aGVtZSA9PT0gKGF1dGhJbmZvID09PSBudWxsIHx8IGF1dGhJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoSW5mby51bml2YXJpYXRlVGhlbWUpKSB7XG4gICAgICAgIC8vIG9ubHkgaWYgdGhlbWUgc3RheXMgdGhlIHNhbWVcbiAgICAgICAgaWYgKGlzRGVmaW5lZChzaXplVmlzVmFyLm1pblNpemUpKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZVZpc1Zhci5taW5TaXplLnN0b3BzKSB7XG4gICAgICAgICAgICAgICAgaXNJbnZlcnRlZCA9IHNpemVWaXNWYXIubWluU2l6ZS5zdG9wc1swXS5zaXplID4gc2l6ZVZpc1Zhci5tYXhTaXplLnN0b3BzWzBdLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc0ludmVydGVkID0gc2l6ZVZpc1Zhci5taW5TaXplID4gc2l6ZVZpc1Zhci5tYXhTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBuZWVkTmV3U3RhdGlzdGljcyA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLm5vcm1hbGl6YXRpb25GaWVsZCA9PT0gbnVsbCB8fFxuICAgICAgICBvcHRpb25zLm5vcm1hbGl6YXRpb25GaWVsZCB8fFxuICAgICAgICAob3B0aW9ucy5maWVsZEluZm9zICYmIG9wdGlvbnMuZmllbGRJbmZvc1swXSkpIHtcbiAgICAgICAgbmVlZE5ld1N0YXRpc3RpY3MgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBhYm92ZUFuZEJlbG93U3dpdGNoID0gKGlzQWJvdmVBbmRCZWxvdyAmJiAhd2FzQWJvdmVBbmRCZWxvdykgfHwgKCFpc0Fib3ZlQW5kQmVsb3cgJiYgd2FzQWJvdmVBbmRCZWxvdyk7XG4gICAgY29uc3QgbWluVmFsdWUgPSBvcHRpb25zLmRpc2NhcmRNaW5NYXhcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBpc0RlZmluZWQob3B0aW9ucy5taW4pXG4gICAgICAgICAgICA/IG9wdGlvbnMubWluXG4gICAgICAgICAgICA6IG5lZWROZXdTdGF0aXN0aWNzXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IGF1dGhTaXplVmlzVmFyXG4gICAgICAgICAgICAgICAgICAgID8gYXV0aFNpemVWaXNWYXIubWluU2xpZGVyVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWF4VmFsdWUgPSBvcHRpb25zLmRpc2NhcmRNaW5NYXhcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBpc0RlZmluZWQob3B0aW9ucy5tYXgpXG4gICAgICAgICAgICA/IG9wdGlvbnMubWF4XG4gICAgICAgICAgICA6IG5lZWROZXdTdGF0aXN0aWNzXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IGF1dGhTaXplVmlzVmFyXG4gICAgICAgICAgICAgICAgICAgID8gYXV0aFNpemVWaXNWYXIubWF4U2xpZGVyVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgd2FzQmVsb3cgPSBhdXRoSW5mby51bml2YXJpYXRlVGhlbWUgPT09IFwiYmVsb3dcIjtcbiAgICBjb25zdCBpc0JlbG93ID0gdGhlbWUgPT09IFwiYmVsb3dcIjtcbiAgICBjb25zdCBiZWxvd1N3aXRjaCA9IChpc0JlbG93ICYmICF3YXNCZWxvdykgfHwgKCFpc0JlbG93ICYmIHdhc0JlbG93KTtcbiAgICBjb25zdCBjb2xvclNjaGVtZSA9IG9wdGlvbnMuY29sb3JTY2hlbWUgfHwgKCFhYm92ZUFuZEJlbG93U3dpdGNoICYmIGZpbmRDb2xvclNjaGVtZSh0aGVtZSkpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXc6IG1hcFZpZXcsXG4gICAgICAgIGZpZWxkOiBmaWVsZEluZm8uZmllbGQsXG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbjogZmllbGRJbmZvLmV4cHJlc3Npb24sXG4gICAgICAgIHZhbHVlRXhwcmVzc2lvblRpdGxlOiBmaWVsZEluZm8uZXhwcmVzc2lvblRpdGxlLFxuICAgICAgICB0aGVtZSxcbiAgICAgICAgbGVnZW5kT3B0aW9uczogb3B0aW9ucy5sZWdlbmRPcHRpb25zIHx8IHNpemVWaXNWYXIubGVnZW5kT3B0aW9ucyxcbiAgICAgICAgY29sb3JPcHRpb25zOiB7XG4gICAgICAgICAgICBjb2xvclNjaGVtZSxcbiAgICAgICAgICAgIGlzQ29udGludW91c1xuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xPcHRpb25zLFxuICAgICAgICBub3JtYWxpemF0aW9uRmllbGQsXG4gICAgICAgIG1pblZhbHVlLFxuICAgICAgICBtYXhWYWx1ZSxcbiAgICAgICAgLyogb3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWQ6IG1hcEltYWdlU3VibGF5ZXJcbiAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgOiBpc0RlZmluZWQob3B0aW9ucy5vdXRsaW5lT3B0aW1pemF0aW9uRW5hYmxlZClcbiAgICAgICAgICA/IG9wdGlvbnMub3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWRcbiAgICAgICAgICA6ICEhZXh0cmFzLnNpemVPdXRsaW5lVmlzVmFyLCAqL1xuICAgICAgICBzaXplT3B0aW1pemF0aW9uRW5hYmxlZDogbWFwSW1hZ2VTdWJsYXllciB8fCB0aGVtZSA9PT0gXCJhYm92ZS1hbmQtYmVsb3dcIlxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiBpc0RlZmluZWQob3B0aW9ucy5zaXplT3B0aW1pemF0aW9uRW5hYmxlZClcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuc2l6ZU9wdGltaXphdGlvbkVuYWJsZWRcbiAgICAgICAgICAgICAgICA6ICEhaXNEZWZpbmVkKChfZyA9IHNpemVWaXNWYXIubWluU2l6ZSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnN0b3BzKSxcbiAgICAgICAgZGVmYXVsdFN5bWJvbEVuYWJsZWQ6IGlzRGVmaW5lZChvcHRpb25zLmRlZmF1bHRTeW1ib2xFbmFibGVkKVxuICAgICAgICAgICAgPyBvcHRpb25zLmRlZmF1bHRTeW1ib2xFbmFibGVkXG4gICAgICAgICAgICA6ICEhcmVuZGVyZXIuZGVmYXVsdFN5bWJvbCxcbiAgICAgICAgZm9yQmlubmluZzogKChfaCA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC50eXBlKSA9PT0gXCJiaW5uaW5nXCJcbiAgICB9O1xuICAgIC8vIGNvbnNvbGUubG9nKFwiY3JlYXRlQ29sb3JTaXplVW5pdmFyaWF0ZVJlbmRlcmVyRnJvbUV4aXN0aW5nLWNvbmZpZ1wiLCBjb25maWcpO1xuICAgIHJldHVybiBtb2R1bGVzLlVuaXZhcmlhdGVDb2xvclNpemVDcmVhdG9yLmNyZWF0ZUNvbnRpbnVvdXNSZW5kZXJlcihjb25maWcpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImNyZWF0ZUNvbG9yU2l6ZVVuaXZhcmlhdGVSZW5kZXJlckZyb21FeGlzdGluZy1zdWNjZXNzXCIsIHJlc3VsdC5yZW5kZXJlci50b0pTT04oKSk7XG4gICAgICAgIC8vIHJlc2V0IGhhbmRsZXMgYW5kIGRhdGEgdmFsdWVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAob3B0aW9ucy5kaXNjYXJkTWluTWF4KSB7XG4gICAgICAgICAgICBjb25zdCBjb2xvclZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlc3VsdC5yZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICAgICAgICAgIGNvbG9yVmlzVmFyID09PSBudWxsIHx8IGNvbG9yVmlzVmFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xvclZpc1Zhci5zdG9wcy5mb3JFYWNoKChzdG9wLCBpZHgpID0+IChzdG9wLnZhbHVlID0gbmV3Q29sb3JWaXNWYXIgPT09IG51bGwgfHwgbmV3Q29sb3JWaXNWYXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ld0NvbG9yVmlzVmFyLnN0b3BzW2lkeF0udmFsdWUpKTtcbiAgICAgICAgICAgIGNvbnN0IHNpemVWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemVWaXNWYXIgPSBnZXRWaXNWYXIocmVzdWx0LnJlbmRlcmVyLCBcInNpemVcIik7XG4gICAgICAgICAgICBjb25zdCBpc0Fib3ZlQW5kQmVsb3cgPSBhdXRoSW5mby51bml2YXJpYXRlVGhlbWUgPT09IFwiYWJvdmUtYW5kLWJlbG93XCI7XG4gICAgICAgICAgICBpZiAoaXNBYm92ZUFuZEJlbG93KSB7XG4gICAgICAgICAgICAgICAgKF9hID0gc2l6ZVZpc1Zhci5zdG9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHN0b3AsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2l6ZVZpc1Zhci5zdG9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcC52YWx1ZSA9IG5ld1NpemVWaXNWYXIuc3RvcHNbaWR4XS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2l6ZVZpc1Zhci5taW5EYXRhVmFsdWUgPSBuZXdTaXplVmlzVmFyLm1pbkRhdGFWYWx1ZTtcbiAgICAgICAgICAgICAgICBzaXplVmlzVmFyLm1heERhdGFWYWx1ZSA9IG5ld1NpemVWaXNWYXIubWF4RGF0YVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGx5RXh0cmFWaXNWYXJzKGV4dHJhcywgcmVzdWx0LnJlbmRlcmVyKTtcbiAgICAgICAgaWYgKGlzQWJvdmVBbmRCZWxvdykge1xuICAgICAgICAgICAgLy8gc2F2ZSBuZXcgY29sb3JzXG4gICAgICAgICAgICBjb25zdCBjb2xvckF0MCA9IGdldFN5bWJvbENvbG9yKHJlc3VsdC5yZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMF0uc3ltYm9sKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yQXQxID0gcmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1sxXVxuICAgICAgICAgICAgICAgID8gZ2V0U3ltYm9sQ29sb3IocmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1sxXS5zeW1ib2wpXG4gICAgICAgICAgICAgICAgOiBjb2xvckF0MDtcbiAgICAgICAgICAgIGlmICghc3ltYm9sU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgc3ltYm9sOyBhcHBseSBjb3JyZWN0IHN5bWJvbFxuICAgICAgICAgICAgICAgIGlmICgoKF9iID0gb3B0aW9ucy5zeW1ib2xzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSA9PT0gMSAmJiByZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgbmV3IG9uZTsgY29udGludW91cyBzY2hlbWVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5zeW1ib2wgPSBvcHRpb25zLnN5bWJvbHNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgoX2MgPSBvcHRpb25zLnN5bWJvbHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpID09PSAyICYmIHJlc3VsdC5yZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBuZXcgb25lczsgYmluYXJ5IHNjaGVtZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW0gPSBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5zeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLnN5bWJvbCA9IHN5bTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5zeW1ib2xTdHlsZSA9PT0gXCJzaW5nbGVcIiAmJiByZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgZmlyc3Qgc3ltYm9sIGZvciBib3RoXG4gICAgICAgICAgICAgICAgICAgIGxldCBzeW0gPSBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5zeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLnN5bWJvbCA9IHN5bS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKHN5bSwgZ2V0U3ltYm9sQ29sb3IocmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1sxXS5zeW1ib2wpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1sxXS5zeW1ib2wgPSBzeW07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5hdXRob3JpbmdJbmZvLnVuaXZhcmlhdGVTeW1ib2xTdHlsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgb2xkIHN5bWJvbChzKVxuICAgICAgICAgICAgICAgICAgICBsZXQgc3ltID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShyZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMF0uc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5zeW1ib2wgPSBzeW07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShyZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMV0uc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShyZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMF0uc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMV0uc3ltYm9sID0gc3ltO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3Q29sb3JWaXNWYXIgPSBnZXRWaXNWYXIocmVzdWx0LnJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICAgICAgaWYgKCFuZXdDb2xvclZpc1Zhcikge1xuICAgICAgICAgICAgICAgIC8vIHdhcyBiaW5hcnkgYW5kIGlzIHN0aWxsIGJpbmFyeVxuICAgICAgICAgICAgICAgIGlmICghY29sb3JWaXNWYXIgJiYgIW5ld0NvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5U3ltYm9sQ29sb3IocmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5zeW1ib2wsIGdldFN5bWJvbENvbG9yKHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5zeW1ib2wpKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlTeW1ib2xDb2xvcihyZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzFdLnN5bWJvbCwgZ2V0U3ltYm9sQ29sb3IocmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzFdLnN5bWJvbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FzIGNvbnRpbnVvdXMgYW5kIGlzIG5vdyBiaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlTeW1ib2xDb2xvcihyZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLnN5bWJvbCwgY29sb3JBdDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlTeW1ib2xDb2xvcihyZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzFdLnN5bWJvbCwgY29sb3JBdDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29udGludW91czsgbWFrZSBzeW1ib2xzIGdyZXlcbiAgICAgICAgICAgICAgICBjb25zdCBncmV5ID0gbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKTtcbiAgICAgICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKHJlc3VsdC5yZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMF0uc3ltYm9sLCBncmV5KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKHJlc3VsdC5yZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMV0uc3ltYm9sLCBncmV5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzQWJvdmVBbmRCZWxvdykge1xuICAgICAgICAgICAgLy8gaGlnaC10by1sb3csIGFib3ZlLCBiZWxvd1xuICAgICAgICAgICAgaWYgKCgoX2QgPSBvcHRpb25zLnN5bWJvbHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIG5ldyBvbmVcbiAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLnN5bWJvbCA9IG9wdGlvbnMuc3ltYm9sc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgoX2UgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5sZW5ndGgpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBwcmV2aW91cyBvbmVcbiAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLnN5bWJvbCA9IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5zeW1ib2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhc0Fib3ZlQW5kQmVsb3cgJiYgaXNBYm92ZUFuZEJlbG93ICYmICFuZWVkTmV3U3RhdGlzdGljcykge1xuICAgICAgICAgICAgLy8ga2VlcCBvbGQgc3RvcHNcbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemVWaXNWYXIgPSBnZXRWaXNWYXIocmVzdWx0LnJlbmRlcmVyLCBcInNpemVcIik7XG4gICAgICAgICAgICBjb25zdCBuZXdDb2xvclZpc1ZhciA9IGdldFZpc1ZhcihyZXN1bHQucmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgICAgICBuZXdTaXplVmlzVmFyLnN0b3BzID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzaXplVmlzVmFyLnN0b3BzKTtcbiAgICAgICAgICAgIGlmIChuZXdDb2xvclZpc1Zhcikge1xuICAgICAgICAgICAgICAgIG5ld0NvbG9yVmlzVmFyLnN0b3BzLmZvckVhY2goKGNvbG9yU3RvcCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RvcC52YWx1ZSA9IHNpemVWaXNWYXIuc3RvcHNbaWR4XS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5tYXhWYWx1ZSA9IHNpemVWaXNWYXIuc3RvcHNbMl0udmFsdWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1sxXS5taW5WYWx1ZSA9IHNpemVWaXNWYXIuc3RvcHNbMl0udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlbG93U3dpdGNoICYmIGNvbG9yU2NoZW1lICYmIGNvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJldmVyc2UgY29sb3Igb3JkZXJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlc3VsdC5yZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGNvbG9yVmlzVmFyLnN0b3BzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBuZXdDb2xvclZpc1Zhci5zdG9wcy5mb3JFYWNoKChjb2xvclN0b3AsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbG9yU3RvcC5jb2xvciA9IGNvbG9yVmlzVmFyLnN0b3BzW2xlbiAtIGlkeF0uY29sb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdFN5bWJvbCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmRlZmF1bHRTeW1ib2wgPSBkZWZhdWx0U3ltYm9sO1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmRlZmF1bHRMYWJlbCA9IGRlZmF1bHRMYWJlbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFja2dyb3VuZEZpbGxTeW1ib2wpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5iYWNrZ3JvdW5kRmlsbFN5bWJvbCA9IGJhY2tncm91bmRGaWxsU3ltYm9sO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmJhY2tncm91bmRGaWxsU3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ludmVydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplVmlzVmFyID0gZ2V0VmlzVmFyKHJlc3VsdC5yZW5kZXJlciwgXCJzaXplXCIpO1xuICAgICAgICAgICAgY29uc3QgdG1wID0gc2l6ZVZpc1Zhci5taW5TaXplO1xuICAgICAgICAgICAgc2l6ZVZpc1Zhci5taW5TaXplID0gc2l6ZVZpc1Zhci5tYXhTaXplO1xuICAgICAgICAgICAgc2l6ZVZpc1Zhci5tYXhTaXplID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG5mdW5jdGlvbiBnZXRDb2xvclNpemVTbGlkZXJTdG9wcygpIHtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBWaWV3IH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCBjb2xvclZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICBjb25zdCBzaXplVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIik7XG4gICAgY29uc3Qgc2NhbGUgPSBtYXBWaWV3LnNjYWxlO1xuICAgIGNvbnN0IHsgbWluU2l6ZSwgbWF4U2l6ZSB9ID0gc2l6ZVZpc1ZhcjtcbiAgICBsZXQgc3RvcHM7XG4gICAgaWYgKHNpemVWaXNWYXIuc3RvcHMpIHtcbiAgICAgICAgLy8gYWJvdmUtYW5kLWJlbG93XG4gICAgICAgIHN0b3BzID0gY29sb3JWaXNWYXIuc3RvcHMubWFwKChjb2xvclN0b3AsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZVN0b3AgPSBzaXplVmlzVmFyLnN0b3BzW2lkeF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvclN0b3AuY29sb3IsXG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZVN0b3Auc2l6ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2l6ZVN0b3AudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbGFzdENvbG9ySWR4ID0gY29sb3JWaXNWYXIuc3RvcHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHR5cGVvZiBtaW5TaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAvLyBoaWdoLXRvLWxvdyBmaXhlZFxuICAgICAgICAgICAgc3RvcHMgPSBjb2xvclZpc1Zhci5zdG9wcy5tYXAoKGNvbG9yU3RvcCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yU3RvcC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbG9yU3RvcC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogaWR4ID09PSAwID8gbWluU2l6ZSA6IGlkeCA9PT0gbGFzdENvbG9ySWR4ID8gbWF4U2l6ZSA6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBoaWdodC10by1sb3cgYXV0b21hdGljXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBtaW5TaXplL21heFNpemUgZm9yIGN1cnJlbnQgc2NhbGVcbiAgICAgICAgICAgIGxldCBtaW4sIG1heDtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTaXplSWR4ID0gbWluU2l6ZS5zdG9wcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKHNjYWxlID4gbWluU2l6ZS5zdG9wc1tsYXN0U2l6ZUlkeF0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBtaW5TaXplLnN0b3BzW2xhc3RTaXplSWR4XS5zaXplO1xuICAgICAgICAgICAgICAgIG1heCA9IG1heFNpemUuc3RvcHNbbGFzdFNpemVJZHhdLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5TaXplLnN0b3BzLmZvckVhY2goKHNpemVTdG9wLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlIDw9IHNpemVTdG9wLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBzaXplU3RvcC5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWF4U2l6ZS5zdG9wc1tpZHhdLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pbkRhdGEgPSBzaXplVmlzVmFyLm1pbkRhdGFWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG1heERhdGEgPSBzaXplVmlzVmFyLm1heERhdGFWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSAobWF4RGF0YSAtIG1pbkRhdGEpIC8gNDtcbiAgICAgICAgICAgIHN0b3BzID0gY29sb3JWaXNWYXIuc3RvcHMubWFwKChjb2xvclN0b3AsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvclN0b3AuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpZHggPT09IDAgPyBtaW5EYXRhIDogaWR4ID09PSBsYXN0Q29sb3JJZHggPyBtYXhEYXRhIDogbWluRGF0YSArIGlkeCAqIHN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGlkeCA9PT0gMCA/IG1pbiA6IGlkeCA9PT0gbGFzdENvbG9ySWR4ID8gbWF4IDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdG9wcztcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ29sb3JTaXplVW5pdmFyaWF0ZVJlbmRlcmVyRnJvbUV4aXN0aW5nIGFzIGEsIGNyZWF0ZUNvbG9yU2l6ZVVuaXZhcmlhdGVSZW5kZXJlciBhcyBjLCBnZXRDb2xvclNpemVTbGlkZXJTdG9wcyBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yU2l6ZVVuaXZhcmlhbnQtZDI2NmFjN2MuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5sZXQgX2xvYWRpbmdUaW1lcjtcbmxldCBfcmVxdWVzdENhbmNlbGxlZDtcbmZ1bmN0aW9uIHN0YXJ0TG9hZGluZyhub2RlKSB7XG4gICAgbm9kZS5sb2FkaW5nID0gdHJ1ZTtcbiAgICBfcmVxdWVzdENhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGlmIChfbG9hZGluZ1RpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfbG9hZGluZ1RpbWVyKTtcbiAgICB9XG4gICAgX2xvYWRpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyB0b29rIHRvbyBsb25nXG4gICAgICAgIGVuZExvYWRpbmcobm9kZSk7XG4gICAgICAgIF9yZXF1ZXN0Q2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9LCA2MDAwMCk7XG59XG5mdW5jdGlvbiBlbmRMb2FkaW5nKG5vZGUpIHtcbiAgICBub2RlLmxvYWRpbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlcXVlc3RXcmFwcGVyKHJlcXVlc3QsIG5vZGUpIHtcbiAgICBzdGFydExvYWRpbmcobm9kZSk7XG4gICAgcmV0dXJuIHJlcXVlc3RcbiAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBlbmRMb2FkaW5nKG5vZGUpO1xuICAgICAgICBpZiAoIV9yZXF1ZXN0Q2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidGltZW91dFwiKSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGVuZExvYWRpbmcobm9kZSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHJlcXVlc3RXcmFwcGVyIGFzIHIgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGluZy02OTEzOTkwNy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=