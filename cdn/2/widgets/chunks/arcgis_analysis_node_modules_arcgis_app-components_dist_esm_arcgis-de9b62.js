"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-de9b62"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-application-environment_2.entry.js":
/*!***********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-application-environment_2.entry.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_application_environment: () => (/* binding */ ArcgisApplicationEnvironment),
/* harmony export */   arcgis_data_array_management: () => (/* binding */ ArcgisDataArrayManagement)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./guid-aeaed84d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */








const applicationEnvironments = ["multiple", "browser", "native", "server"];

const arcgisApplicationEnvironmentCss = ".env-select-group{display:grid;grid-template-columns:repeat(2, minmax(0, 1fr));margin-top:0.5rem}";

const ArcgisApplicationEnvironment = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisApplicationEnvironmentChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisApplicationEnvironmentChange", 7);
        this.arcgisServiceScopeChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisServiceScopeChange", 7);
        this.defaultEnvironment = undefined;
        this.selectedEnvironment = "multiple";
        this.readOnly = false;
    }
    assignSelectedEnvironment() {
        this.arcgisApplicationEnvironmentChange.emit(this.selectedEnvironment);
    }
    async componentWillLoad() {
        var _a;
        const locale = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.el);
        this.i18n = locale[0];
        this.selectedEnvironment = (_a = this.defaultEnvironment) !== null && _a !== void 0 ? _a : "multiple";
    }
    render() {
        const { i18n, selectedEnvironment, readOnly } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-new-item-description", { header: i18n.title, content: i18n.description, headerScale: "l" }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tile-select-group", { layout: "horizontal", class: "env-select-group", disabled: readOnly }, applicationEnvironments.map((envType) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tile-select", { checked: envType === selectedEnvironment, heading: i18n.applicationEnvOptions[envType],
            // icon={tileIcons[envType]}
            type: "radio", width: "full", value: envType, inputEnabled: true, onCalciteTileSelectChange: (e) => (this.selectedEnvironment = e.target.value) }))))));
    }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "selectedEnvironment": ["assignSelectedEnvironment"]
    }; }
};
ArcgisApplicationEnvironment.style = arcgisApplicationEnvironmentCss;

const arcgisDataArrayManagementCss = ".data-container{margin-top:1rem;margin-bottom:1.5rem;padding:1.5rem;background-color:var(--calcite-color-background)}.info-card{display:flex;align-items:center;list-style-type:none}.content-input{margin-top:0.5rem;margin-inline-end:1rem;width:100%}.add-new{margin-top:1rem;width:-moz-fit-content;width:fit-content}";

const ArcgisDataArrayManagement = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.dataChanged = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "dataChanged", 7);
        this.dataInputRefs = {};
        this.changeDataContent = (id, content) => {
            const { data } = this;
            const dataToChangeIndex = data.findIndex((info) => info.id === id);
            const newDataItem = Object.assign(Object.assign({}, data[dataToChangeIndex]), { content });
            this.data = data.map((info) => (info.id === id ? Object.assign(Object.assign({}, info), { content }) : info));
            this.dataChanged.emit({ dataItem: newDataItem, allData: this.data, type: "update" });
        };
        this.addData = () => {
            const { dataInputRefs, data } = this;
            const lastElement = data[data.length - 1];
            if (lastElement && !lastElement.content) {
                dataInputRefs[lastElement.id].setFocus();
                return;
            }
            const id = (0,_guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_2__.g)();
            const newDataItem = { content: "", id };
            this.data = [...data, newDataItem];
            this.dataChanged.emit({ dataItem: newDataItem, allData: this.data, type: "add" });
            (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_3__.t)(100).then(() => {
                var _a;
                (_a = dataInputRefs[id]) === null || _a === void 0 ? void 0 : _a.setFocus();
            });
        };
        this.removeData = (id) => {
            const { data, required } = this;
            if (required && data.length === 1) {
                return;
            }
            const dataToRemoveIndex = data.findIndex((info) => info.id === id);
            const newDataItem = data[dataToRemoveIndex];
            this.data = data.filter((info) => info.id !== id);
            this.dataChanged.emit({ dataItem: newDataItem, allData: this.data, type: "remove" });
        };
        this.initialData = [];
        this.header = undefined;
        this.description = undefined;
        this.addNewText = undefined;
        this.placeholder = undefined;
        this.required = false;
        this.showAddButton = () => true;
        this.validateData = () => true;
        this.data = [];
    }
    async focusInputByIndex(index) {
        var _a;
        const { dataInputRefs, data } = this;
        const dataInfo = data[index];
        (_a = dataInputRefs[dataInfo === null || dataInfo === void 0 ? void 0 : dataInfo.id]) === null || _a === void 0 ? void 0 : _a.setFocus();
    }
    async focusInputById(id) {
        var _a;
        (_a = this.dataInputRefs[id]) === null || _a === void 0 ? void 0 : _a.setFocus();
    }
    async componentWillLoad() {
        var _a;
        this.data = (_a = this.initialData.map((content) => ({ content, id: (0,_guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_2__.g)() }))) !== null && _a !== void 0 ? _a : [];
        const locale = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.el);
        this.i18n = locale[0];
    }
    async validateAllInputs({ focusWhenInvalid, stopOnFirstInvalid } = {}) {
        const { dataInputRefs, data } = this;
        let isValid = true;
        for (const dataInfo of data) {
            const isDataValid = this.validateData(dataInfo);
            if (!isDataValid) {
                isValid = false;
                if (focusWhenInvalid) {
                    dataInputRefs[dataInfo.id].setFocus();
                }
                if (stopOnFirstInvalid) {
                    return false;
                }
            }
        }
        return isValid;
    }
    render() {
        const { header, description, data, placeholder, addData, addNewText, changeDataContent, dataInputRefs, removeData, required, showAddButton, i18n } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-new-item-description", { header: header, content: description }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "data-container" }, data.map(({ id, content }) => {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("li", { class: "info-card", key: id, value: id }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { value: content, class: "content-input", placeholder: placeholder, onCalciteInputInput: (event) => {
                    const node = event.target;
                    changeDataContent(id, node.value);
                }, ref: (ele) => (dataInputRefs[id] = ele) }, (!required || data.length > 1) && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { label: i18n.delete, slot: "action", appearance: "transparent", kind: "danger", scale: "m", iconStart: "trash", onClick: () => removeData(id) })))));
        }), showAddButton(data) && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", scale: "m", "icon-start": "plus", class: "add-new", onClick: addData }, addNewText)))));
    }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisDataArrayManagement.style = arcgisDataArrayManagementCss;



//# sourceMappingURL=arcgis-application-environment_2.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ guid)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
function generateId(counts) {
    return counts
        .map((count) => {
        let out = "";
        for (let i = 0; i < count; i++) {
            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        return out;
    })
        .join("-");
}
const guid = () => generateId([2, 1, 1, 1, 3]);



//# sourceMappingURL=guid-aeaed84d.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWRlOWI2Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RztBQUN2QztBQUN2QjtBQUNTO0FBQzdCO0FBQ1M7QUFDRDs7QUFFbkM7O0FBRUEsMkRBQTJELGFBQWEsZ0RBQWdELGtCQUFrQjs7QUFFMUk7QUFDQTtBQUNBLFFBQVEscURBQWdCO0FBQ3hCLGtEQUFrRCxxREFBVztBQUM3RCx3Q0FBd0MscURBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQsZ0JBQWdCLHFEQUFDLENBQUMsaURBQUksUUFBUSxxREFBQyxrQ0FBa0MsaUVBQWlFLEdBQUcscURBQUMsZ0NBQWdDLHFFQUFxRSw0Q0FBNEMscURBQUMsMEJBQTBCO0FBQ2xULHFCQUFxQjtBQUNyQiw2SkFBNko7QUFDN0o7QUFDQSxlQUFlLE9BQU8scURBQVU7QUFDaEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFzRCxnQkFBZ0IscUJBQXFCLGVBQWUsaURBQWlELFdBQVcsYUFBYSxtQkFBbUIscUJBQXFCLGVBQWUsa0JBQWtCLHVCQUF1QixXQUFXLFNBQVMsZ0JBQWdCLHVCQUF1QixrQkFBa0I7O0FBRWhXO0FBQ0E7QUFDQSxRQUFRLHFEQUFnQjtBQUN4QiwyQkFBMkIscURBQVc7QUFDdEM7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0EsOERBQThELDhCQUE4QixTQUFTO0FBQ3JHLDJGQUEyRixXQUFXLFNBQVM7QUFDL0csb0NBQW9DLDJEQUEyRDtBQUMvRjtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMx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O0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQVc7QUFDdkIsbUJBQW1CLHdEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1EQUFpQztBQUNsRTtBQUNBO0FBQ0EsUUFBUSx3REFBVztBQUNuQixlQUFlLHdEQUFXO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLHdEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFZLDhCQUE4QixjQUFjLFFBQVEsT0FBTztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWMsRUFBRSxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFlLEdBQUcsa0JBQWtCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUU0RTs7QUFFNUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtYXBwbGljYXRpb24tZW52aXJvbm1lbnRfMi5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2d1aWQtYWVhZWQ4NGQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsZS0wNTBiNmRiOS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgSCBhcyBIb3N0LCBkIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyB9IGZyb20gJy4vbG9jYWxlLTA1MGI2ZGI5LmpzJztcbmltcG9ydCB7IGcgYXMgZ3VpZCB9IGZyb20gJy4vZ3VpZC1hZWFlZDg0ZC5qcyc7XG5pbXBvcnQgeyB0IGFzIHRpbWVvdXQgfSBmcm9tICcuL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMnO1xuaW1wb3J0ICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5cbmNvbnN0IGFwcGxpY2F0aW9uRW52aXJvbm1lbnRzID0gW1wibXVsdGlwbGVcIiwgXCJicm93c2VyXCIsIFwibmF0aXZlXCIsIFwic2VydmVyXCJdO1xuXG5jb25zdCBhcmNnaXNBcHBsaWNhdGlvbkVudmlyb25tZW50Q3NzID0gXCIuZW52LXNlbGVjdC1ncm91cHtkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOnJlcGVhdCgyLCBtaW5tYXgoMCwgMWZyKSk7bWFyZ2luLXRvcDowLjVyZW19XCI7XG5cbmNvbnN0IEFyY2dpc0FwcGxpY2F0aW9uRW52aXJvbm1lbnQgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc0FwcGxpY2F0aW9uRW52aXJvbm1lbnRDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0FwcGxpY2F0aW9uRW52aXJvbm1lbnRDaGFuZ2VcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzU2VydmljZVNjb3BlQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNTZXJ2aWNlU2NvcGVDaGFuZ2VcIiwgNyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVudmlyb25tZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRW52aXJvbm1lbnQgPSBcIm11bHRpcGxlXCI7XG4gICAgICAgIHRoaXMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9XG4gICAgYXNzaWduU2VsZWN0ZWRFbnZpcm9ubWVudCgpIHtcbiAgICAgICAgdGhpcy5hcmNnaXNBcHBsaWNhdGlvbkVudmlyb25tZW50Q2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZEVudmlyb25tZW50KTtcbiAgICB9XG4gICAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5pMThuID0gbG9jYWxlWzBdO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRW52aXJvbm1lbnQgPSAoX2EgPSB0aGlzLmRlZmF1bHRFbnZpcm9ubWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJtdWx0aXBsZVwiO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgaTE4biwgc2VsZWN0ZWRFbnZpcm9ubWVudCwgcmVhZE9ubHkgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiYXJjZ2lzLW5ldy1pdGVtLWRlc2NyaXB0aW9uXCIsIHsgaGVhZGVyOiBpMThuLnRpdGxlLCBjb250ZW50OiBpMThuLmRlc2NyaXB0aW9uLCBoZWFkZXJTY2FsZTogXCJsXCIgfSksIGgoXCJjYWxjaXRlLXRpbGUtc2VsZWN0LWdyb3VwXCIsIHsgbGF5b3V0OiBcImhvcml6b250YWxcIiwgY2xhc3M6IFwiZW52LXNlbGVjdC1ncm91cFwiLCBkaXNhYmxlZDogcmVhZE9ubHkgfSwgYXBwbGljYXRpb25FbnZpcm9ubWVudHMubWFwKChlbnZUeXBlKSA9PiAoaChcImNhbGNpdGUtdGlsZS1zZWxlY3RcIiwgeyBjaGVja2VkOiBlbnZUeXBlID09PSBzZWxlY3RlZEVudmlyb25tZW50LCBoZWFkaW5nOiBpMThuLmFwcGxpY2F0aW9uRW52T3B0aW9uc1tlbnZUeXBlXSxcbiAgICAgICAgICAgIC8vIGljb249e3RpbGVJY29uc1tlbnZUeXBlXX1cbiAgICAgICAgICAgIHR5cGU6IFwicmFkaW9cIiwgd2lkdGg6IFwiZnVsbFwiLCB2YWx1ZTogZW52VHlwZSwgaW5wdXRFbmFibGVkOiB0cnVlLCBvbkNhbGNpdGVUaWxlU2VsZWN0Q2hhbmdlOiAoZSkgPT4gKHRoaXMuc2VsZWN0ZWRFbnZpcm9ubWVudCA9IGUudGFyZ2V0LnZhbHVlKSB9KSkpKSkpO1xuICAgIH1cbiAgICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gICAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICAgICAgXCJzZWxlY3RlZEVudmlyb25tZW50XCI6IFtcImFzc2lnblNlbGVjdGVkRW52aXJvbm1lbnRcIl1cbiAgICB9OyB9XG59O1xuQXJjZ2lzQXBwbGljYXRpb25FbnZpcm9ubWVudC5zdHlsZSA9IGFyY2dpc0FwcGxpY2F0aW9uRW52aXJvbm1lbnRDc3M7XG5cbmNvbnN0IGFyY2dpc0RhdGFBcnJheU1hbmFnZW1lbnRDc3MgPSBcIi5kYXRhLWNvbnRhaW5lcnttYXJnaW4tdG9wOjFyZW07bWFyZ2luLWJvdHRvbToxLjVyZW07cGFkZGluZzoxLjVyZW07YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLWNvbG9yLWJhY2tncm91bmQpfS5pbmZvLWNhcmR7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtsaXN0LXN0eWxlLXR5cGU6bm9uZX0uY29udGVudC1pbnB1dHttYXJnaW4tdG9wOjAuNXJlbTttYXJnaW4taW5saW5lLWVuZDoxcmVtO3dpZHRoOjEwMCV9LmFkZC1uZXd7bWFyZ2luLXRvcDoxcmVtO3dpZHRoOi1tb3otZml0LWNvbnRlbnQ7d2lkdGg6Zml0LWNvbnRlbnR9XCI7XG5cbmNvbnN0IEFyY2dpc0RhdGFBcnJheU1hbmFnZW1lbnQgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gY3JlYXRlRXZlbnQodGhpcywgXCJkYXRhQ2hhbmdlZFwiLCA3KTtcbiAgICAgICAgdGhpcy5kYXRhSW5wdXRSZWZzID0ge307XG4gICAgICAgIHRoaXMuY2hhbmdlRGF0YUNvbnRlbnQgPSAoaWQsIGNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGRhdGFUb0NoYW5nZUluZGV4ID0gZGF0YS5maW5kSW5kZXgoKGluZm8pID0+IGluZm8uaWQgPT09IGlkKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RhdGFJdGVtID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhW2RhdGFUb0NoYW5nZUluZGV4XSksIHsgY29udGVudCB9KTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGEubWFwKChpbmZvKSA9PiAoaW5mby5pZCA9PT0gaWQgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluZm8pLCB7IGNvbnRlbnQgfSkgOiBpbmZvKSk7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkLmVtaXQoeyBkYXRhSXRlbTogbmV3RGF0YUl0ZW0sIGFsbERhdGE6IHRoaXMuZGF0YSwgdHlwZTogXCJ1cGRhdGVcIiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGREYXRhID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhSW5wdXRSZWZzLCBkYXRhIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdEVsZW1lbnQgJiYgIWxhc3RFbGVtZW50LmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBkYXRhSW5wdXRSZWZzW2xhc3RFbGVtZW50LmlkXS5zZXRGb2N1cygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkID0gZ3VpZCgpO1xuICAgICAgICAgICAgY29uc3QgbmV3RGF0YUl0ZW0gPSB7IGNvbnRlbnQ6IFwiXCIsIGlkIH07XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBbLi4uZGF0YSwgbmV3RGF0YUl0ZW1dO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZC5lbWl0KHsgZGF0YUl0ZW06IG5ld0RhdGFJdGVtLCBhbGxEYXRhOiB0aGlzLmRhdGEsIHR5cGU6IFwiYWRkXCIgfSk7XG4gICAgICAgICAgICB0aW1lb3V0KDEwMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IGRhdGFJbnB1dFJlZnNbaWRdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbW92ZURhdGEgPSAoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgcmVxdWlyZWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocmVxdWlyZWQgJiYgZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhVG9SZW1vdmVJbmRleCA9IGRhdGEuZmluZEluZGV4KChpbmZvKSA9PiBpbmZvLmlkID09PSBpZCk7XG4gICAgICAgICAgICBjb25zdCBuZXdEYXRhSXRlbSA9IGRhdGFbZGF0YVRvUmVtb3ZlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YS5maWx0ZXIoKGluZm8pID0+IGluZm8uaWQgIT09IGlkKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWQuZW1pdCh7IGRhdGFJdGVtOiBuZXdEYXRhSXRlbSwgYWxsRGF0YTogdGhpcy5kYXRhLCB0eXBlOiBcInJlbW92ZVwiIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxEYXRhID0gW107XG4gICAgICAgIHRoaXMuaGVhZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmFkZE5ld1RleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG93QWRkQnV0dG9uID0gKCkgPT4gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZURhdGEgPSAoKSA9PiB0cnVlO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG4gICAgYXN5bmMgZm9jdXNJbnB1dEJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGRhdGFJbnB1dFJlZnMsIGRhdGEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGRhdGFJbmZvID0gZGF0YVtpbmRleF07XG4gICAgICAgIChfYSA9IGRhdGFJbnB1dFJlZnNbZGF0YUluZm8gPT09IG51bGwgfHwgZGF0YUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFJbmZvLmlkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7XG4gICAgfVxuICAgIGFzeW5jIGZvY3VzSW5wdXRCeUlkKGlkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5kYXRhSW5wdXRSZWZzW2lkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7XG4gICAgfVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZGF0YSA9IChfYSA9IHRoaXMuaW5pdGlhbERhdGEubWFwKChjb250ZW50KSA9PiAoeyBjb250ZW50LCBpZDogZ3VpZCgpIH0pKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IGF3YWl0IGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3ModGhpcy5lbCk7XG4gICAgICAgIHRoaXMuaTE4biA9IGxvY2FsZVswXTtcbiAgICB9XG4gICAgYXN5bmMgdmFsaWRhdGVBbGxJbnB1dHMoeyBmb2N1c1doZW5JbnZhbGlkLCBzdG9wT25GaXJzdEludmFsaWQgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YUlucHV0UmVmcywgZGF0YSB9ID0gdGhpcztcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGRhdGFJbmZvIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRGF0YVZhbGlkID0gdGhpcy52YWxpZGF0ZURhdGEoZGF0YUluZm8pO1xuICAgICAgICAgICAgaWYgKCFpc0RhdGFWYWxpZCkge1xuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZm9jdXNXaGVuSW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSW5wdXRSZWZzW2RhdGFJbmZvLmlkXS5zZXRGb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RvcE9uRmlyc3RJbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBoZWFkZXIsIGRlc2NyaXB0aW9uLCBkYXRhLCBwbGFjZWhvbGRlciwgYWRkRGF0YSwgYWRkTmV3VGV4dCwgY2hhbmdlRGF0YUNvbnRlbnQsIGRhdGFJbnB1dFJlZnMsIHJlbW92ZURhdGEsIHJlcXVpcmVkLCBzaG93QWRkQnV0dG9uLCBpMThuIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgbnVsbCwgaChcImFyY2dpcy1uZXctaXRlbS1kZXNjcmlwdGlvblwiLCB7IGhlYWRlcjogaGVhZGVyLCBjb250ZW50OiBkZXNjcmlwdGlvbiB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiBcImRhdGEtY29udGFpbmVyXCIgfSwgZGF0YS5tYXAoKHsgaWQsIGNvbnRlbnQgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChoKFwibGlcIiwgeyBjbGFzczogXCJpbmZvLWNhcmRcIiwga2V5OiBpZCwgdmFsdWU6IGlkIH0sIGgoXCJjYWxjaXRlLWlucHV0XCIsIHsgdmFsdWU6IGNvbnRlbnQsIGNsYXNzOiBcImNvbnRlbnQtaW5wdXRcIiwgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLCBvbkNhbGNpdGVJbnB1dElucHV0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGF0YUNvbnRlbnQoaWQsIG5vZGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sIHJlZjogKGVsZSkgPT4gKGRhdGFJbnB1dFJlZnNbaWRdID0gZWxlKSB9LCAoIXJlcXVpcmVkIHx8IGRhdGEubGVuZ3RoID4gMSkgJiYgKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGxhYmVsOiBpMThuLmRlbGV0ZSwgc2xvdDogXCJhY3Rpb25cIiwgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCBraW5kOiBcImRhbmdlclwiLCBzY2FsZTogXCJtXCIsIGljb25TdGFydDogXCJ0cmFzaFwiLCBvbkNsaWNrOiAoKSA9PiByZW1vdmVEYXRhKGlkKSB9KSkpKSk7XG4gICAgICAgIH0pLCBzaG93QWRkQnV0dG9uKGRhdGEpICYmIChoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIHNjYWxlOiBcIm1cIiwgXCJpY29uLXN0YXJ0XCI6IFwicGx1c1wiLCBjbGFzczogXCJhZGQtbmV3XCIsIG9uQ2xpY2s6IGFkZERhdGEgfSwgYWRkTmV3VGV4dCkpKSkpO1xuICAgIH1cbiAgICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzRGF0YUFycmF5TWFuYWdlbWVudC5zdHlsZSA9IGFyY2dpc0RhdGFBcnJheU1hbmFnZW1lbnRDc3M7XG5cbmV4cG9ydCB7IEFyY2dpc0FwcGxpY2F0aW9uRW52aXJvbm1lbnQgYXMgYXJjZ2lzX2FwcGxpY2F0aW9uX2Vudmlyb25tZW50LCBBcmNnaXNEYXRhQXJyYXlNYW5hZ2VtZW50IGFzIGFyY2dpc19kYXRhX2FycmF5X21hbmFnZW1lbnQgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJjZ2lzLWFwcGxpY2F0aW9uLWVudmlyb25tZW50XzIuZW50cnkuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIG4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgIGZ1bmN0aW9uIGZsdXNoKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZsdXNoZWRcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW52b2tlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgZGVib3VuY2VkLmludm9rZSA9IGludm9rZTtcbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgIGRlYm91bmNlZC5nZXRTdGF0dXMgPSBnZXRTdGF0dXM7XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIG4gbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtwcm9taXNlLCB0aW1lb3V0KG1pbkRlbGF5KV0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGlubGluZSBzZXRUaW1lb3V0IGFzIGFuIGF3YWl0IGluIGFzeW5jIGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gICAgY29uc3QgeyBrZXksIGRhdGEgfSA9IGdldEtleUFuZEl0ZW0oaXRlbSk7XG4gICAgcmV0dXJuIFtrZXksIGRhdGFdO1xufSkpO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcbiAqIGFuZCB3aGV0aGVyIHRoZXkgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50c1xuICogcmVnYXJkbGVzcyBvZiBvcmRlclxuICovXG5jb25zdCBhcnJheXNBcmVFcXVpdmFsZW50ID0gKGFycjEsIGFycjIpID0+IGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLnJlZHVjZSgobWVtbywgc3RyKSA9PiBtZW1vICYmIGFycjIuaW5kZXhPZihzdHIpID4gLTEsIHRydWUpO1xuZnVuY3Rpb24gdW5pcXVlQnkobXlBcnIsIGdldEl0ZW1JZCkge1xuICAgIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICAgIGNvbnN0IGxvb2t1cE1hcCA9IHt9O1xuICAgIG15QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZXRJdGVtSWQoaXRlbSk7XG4gICAgICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyO1xufVxuZnVuY3Rpb24gdW5pcXVlKG15QXJyKSB7XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IHsgYm9vbGVhbjoge30sIG51bWJlcjoge30sIHN0cmluZzoge30gfTtcbiAgICBjb25zdCBvYmpzID0gW107XG4gICAgcmV0dXJuIG15QXJyLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgICAgICBpZiAodHlwZSBpbiBwcmltaXRpdmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlc1t0eXBlXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSA/IGZhbHNlIDogKHByaW1pdGl2ZXNbdHlwZV1baXRlbV0gPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uYWwtNDRkZThmY2YuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUlkKGNvdW50cykge1xuICAgIHJldHVybiBjb3VudHNcbiAgICAgICAgLm1hcCgoY291bnQpID0+IHtcbiAgICAgICAgbGV0IG91dCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0ICs9ICgoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApIHwgMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pXG4gICAgICAgIC5qb2luKFwiLVwiKTtcbn1cbmNvbnN0IGd1aWQgPSAoKSA9PiBnZW5lcmF0ZUlkKFsyLCAxLCAxLCAxLCAzXSk7XG5cbmV4cG9ydCB7IGd1aWQgYXMgZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ndWlkLWFlYWVkODRkLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5cbmNvbnN0IGxhbmd1YWdlTWFwID0gbmV3IE1hcChbXG4gICAgW1wiYXJcIiwgXCJhclwiXSxcbiAgICBbXCJiZ1wiLCBcImJnXCJdLFxuICAgIFtcImJzXCIsIFwiYnNcIl0sXG4gICAgW1wiY2FcIiwgXCJjYVwiXSxcbiAgICBbXCJjc1wiLCBcImNzXCJdLFxuICAgIFtcImRhXCIsIFwiZGFcIl0sXG4gICAgW1wiZGVcIiwgXCJkZVwiXSxcbiAgICBbXCJlbFwiLCBcImVsXCJdLFxuICAgIFtcImVuXCIsIFwiZW5cIl0sXG4gICAgW1wiZXNcIiwgXCJlc1wiXSxcbiAgICBbXCJldFwiLCBcImV0XCJdLFxuICAgIFtcImZpXCIsIFwiZmlcIl0sXG4gICAgW1wiZnJcIiwgXCJmclwiXSxcbiAgICBbXCJoZVwiLCBcImhlXCJdLFxuICAgIFtcImhyXCIsIFwiaHJcIl0sXG4gICAgW1wiaHVcIiwgXCJodVwiXSxcbiAgICBbXCJpZFwiLCBcImlkXCJdLFxuICAgIFtcIml0XCIsIFwiaXRcIl0sXG4gICAgW1wiamFcIiwgXCJqYVwiXSxcbiAgICBbXCJrb1wiLCBcImtvXCJdLFxuICAgIFtcImx0XCIsIFwibHRcIl0sXG4gICAgW1wibHZcIiwgXCJsdlwiXSxcbiAgICBbXCJuYlwiLCBcIm5iXCJdLFxuICAgIFtcIm5sXCIsIFwibmxcIl0sXG4gICAgW1wicGxcIiwgXCJwbFwiXSxcbiAgICBbXCJwdC1iclwiLCBcInB0LUJSXCJdLFxuICAgIFtcInB0LXB0XCIsIFwicHQtUFRcIl0sXG4gICAgW1wicm9cIiwgXCJyb1wiXSxcbiAgICBbXCJydVwiLCBcInJ1XCJdLFxuICAgIFtcInNrXCIsIFwic2tcIl0sXG4gICAgW1wic2xcIiwgXCJzbFwiXSxcbiAgICBbXCJzclwiLCBcInNyXCJdLFxuICAgIFtcInN2XCIsIFwic3ZcIl0sXG4gICAgW1widGhcIiwgXCJ0aFwiXSxcbiAgICBbXCJ0clwiLCBcInRyXCJdLFxuICAgIFtcInVrXCIsIFwidWtcIl0sXG4gICAgW1widmlcIiwgXCJ2aVwiXSxcbiAgICBbXCJ6aC1jblwiLCBcInpoLUNOXCJdLFxuICAgIFtcInpoLWhrXCIsIFwiemgtSEtcIl0sXG4gICAgW1wiemgtdHdcIiwgXCJ6aC1UV1wiXVxuXSk7XG4vLyBydGxcbmZ1bmN0aW9uIGdldEVsZW1lbnREaXIoZWwpIHtcbiAgICByZXR1cm4gZ2V0RWxlbWVudFByb3AoZWwsIFwiZGlyXCIsIFwibHRyXCIpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFByb3AoZWwsIHByb3AsIHZhbHVlKSB7XG4gICAgY29uc3QgY2xvc2VzdFdpdGhQcm9wID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsLCBgWyR7cHJvcH1dYCk7XG4gICAgcmV0dXJuIGNsb3Nlc3RXaXRoUHJvcCA/IGNsb3Nlc3RXaXRoUHJvcC5nZXRBdHRyaWJ1dGUocHJvcCkgOiB2YWx1ZTtcbn1cbi8vIGNzc1xuY29uc3QgQ1NTX1VUSUxJVFkgPSB7XG4gICAgcnRsOiBcImFyY2dpcy0tcnRsXCJcbn07XG5hc3luYyBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtYmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcGksIHR5cGUsIHBsYWNlcyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoYXBpID09PSA0KSB7XG4gICAgICAgIGNvbnN0IFtpbnRsXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvaW50bFwiXSk7XG4gICAgICAgIGNvbnN0IG51bWJlckZvcm1hdEludGxPcHRpb25zID0gaW50bC5jb252ZXJ0TnVtYmVyRm9ybWF0VG9JbnRsT3B0aW9ucyh7XG4gICAgICAgICAgICBwbGFjZXMsXG4gICAgICAgICAgICBzdHlsZTogdHlwZSxcbiAgICAgICAgICAgIGRpZ2l0U2VwYXJhdG9yOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW50bC5mb3JtYXROdW1iZXIobnVtYmVyLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG51bWJlckZvcm1hdEludGxPcHRpb25zKSwgeyBzdHlsZTogdHlwZSB9KSk7XG4gICAgfVxuICAgIGNvbnN0IFtkb2pvTnVtYmVyXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImRvam8vbnVtYmVyXCJdKTtcbiAgICByZXR1cm4gZG9qb051bWJlci5mb3JtYXQobnVtYmVyLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBsYWNlcyxcbiAgICAgICAgcGF0dGVybjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhdHRlcm5cbiAgICB9KTtcbn1cbmNvbnN0IGNhY2hlID0ge307XG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgICBjb25zdCBsYW5nID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lmxhbmc7XG4gICAgY29uc3QgZGF5U2hvcnRNb250aFllYXIgPSB7XG4gICAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgICBtb250aDogXCJzaG9ydFwiLFxuICAgICAgICBkYXk6IFwibnVtZXJpY1wiXG4gICAgfTtcbiAgICBpZiAoIWNhY2hlW2xhbmddKSB7XG4gICAgICAgIGNhY2hlW2xhbmddID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcsIGRheVNob3J0TW9udGhZZWFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2xhbmddLmZvcm1hdChkYXRlKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFBsdXJhbChsYW5nLCBzdHJpbmdPYmosIG51bWJlcikge1xuICAgIGNvbnN0IHNpbmdsZXMgPSBbXCJpZFwiLCBcImphXCIsIFwia29cIiwgXCJ0aFwiLCBcInZpXCIsIFwiemgtY25cIiwgXCJ6aC1oa1wiLCBcInpoLXR3XCJdO1xuICAgIGNvbnN0IGxpa2VFbmdsaXNoID0gW1xuICAgICAgICBcImVuXCIsXG4gICAgICAgIFwiY2FcIixcbiAgICAgICAgXCJkYVwiLFxuICAgICAgICBcImRlXCIsXG4gICAgICAgIFwiZWxcIixcbiAgICAgICAgXCJlc1wiLFxuICAgICAgICBcImV0XCIsXG4gICAgICAgIFwiZmlcIixcbiAgICAgICAgXCJoaVwiLFxuICAgICAgICBcImh1XCIsXG4gICAgICAgIFwiaXRcIixcbiAgICAgICAgXCJuYlwiLFxuICAgICAgICBcIm5sXCIsXG4gICAgICAgIFwicHQtcHRcIixcbiAgICAgICAgXCJzdlwiLFxuICAgICAgICBcInRyXCJcbiAgICBdO1xuICAgIGNvbnN0IGxvY2FsZSA9IGxhbmcgIT09IG51bGwgJiYgbGFuZyAhPT0gdm9pZCAwID8gbGFuZyA6IFwiZW5cIjtcbiAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIG9uZSwgb3IgaXQgaXMgYSBcInNpbXBsZVwiIGxhbmd1YWdlLCByZXR1cm4gdGhlIDEgc3RyaW5nXG4gICAgaWYgKG51bWJlciA9PT0gMSB8fCBzaW5nbGVzLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ09iai5zaW5nbGUucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBcIjFcIik7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgbm90IDEgYW5kIHRoZSBsYW5ndWFnZSB1c2VzIHRoZSBzYW1lIHBsdXJhbGl6YXRpb24gc3RyYXRlZ3kgYXMgZW5nbGlzaCxcbiAgICAvLyByZXR1cm4gdGhlIG11bHRpcGxlIHN0cmluZ1xuICAgIGlmIChudW1iZXIgIT09IDEgJiYgbGlrZUVuZ2xpc2guaW5jbHVkZXMobG9jYWxlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nT2JqLm11bHRpcGxlLnJlcGxhY2UoXCIke251bWJlcn1cIiwgYCR7bnVtYmVyfWApO1xuICAgIH1cbiAgICAvLyBpZiBub25lIG9mIHRoZSBhYm92ZSB3b3JrZWQsIHJldHVybiB0aGUgXCJ1bmtub3duXCIgc3RyaW5nXG4gICAgcmV0dXJuIHN0cmluZ09iai51bmtub3duLnJlcGxhY2UoXCIke251bWJlcn1cIiwgYCR7bnVtYmVyfWApO1xufVxuXG5leHBvcnQgeyBDU1NfVVRJTElUWSBhcyBDLCBmb3JtYXREYXRlIGFzIGEsIGZvcm1hdFBsdXJhbCBhcyBiLCBmb3JtYXROdW1iZXIgYXMgZiwgZ2V0RWxlbWVudERpciBhcyBnLCBsYW5ndWFnZU1hcCBhcyBsIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tNGQzNjc2NzcuanMnO1xuaW1wb3J0IHsgbCBhcyBsYW5ndWFnZU1hcCB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCB7IGEgYXMgZ2V0QXNzZXRQYXRoIH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5cbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9zdGVuY2lsLXRyaWNrcy9pbXBsZW1lbnRpbmctaW50ZXJuYXRpb25hbGlzYXRpb24taTE4bi13aXRoLXN0ZW5jaWwtNWU2NTU5NTU0MTE3XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gXCJydS1SVVwiIG1hcHMgdG8gXCJydVwiIHVzZSBjYXNlXG4gICAgICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZy5zbGljZSgwLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlblwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgLy8gaXQncyBPSyBpZiB3ZSBkb24ndCBoYXZlIHRoZSA0IGxldHRlciBsYW5ndWFnZSBmaWxlIGZvciBpdFxuICAgIC8vIDQgbGV0dGVyIGxhbmd1YWdlIGNvZGUgbmVlZGVkIGZvciBmb3JtYXR0aW5nIG51bWJlcnNcbiAgICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgICAgICAgIC8vIHdlIHN1cHBvcnQgdGhlIDIgbGV0dGVyIGNvZGVkIGxhbmd1YWdlXG4gICAgICAgICAgICAvLyBlLmcuIGl0LUNIIHZzIGl0XG4gICAgICAgICAgICByZXR1cm4gbGFuZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZmV0Y2goZ2V0QXNzZXRQYXRoKGAuLi9hcmNnaXMtYXBwLWFzc2V0cy9pMThuLyR7Y29tcG9uZW50TmFtZX0uaTE4bi4ke2xvY2FsZX0uanNvbmApKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQub2spXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQuanNvbigpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSwgKCkgPT4gcmVqZWN0KCkpO1xuICAgIH0pO1xufVxuY29uc3Qgc3RyaW5nQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICBjb25zdCBpZCA9IGAke2NvbXBvbmVudE5hbWV9JHtsb2NhbGV9YDtcbiAgICBpZiAoIXN0cmluZ0NhY2hlW2lkXSkge1xuICAgICAgICBzdHJpbmdDYWNoZVtpZF0gPSBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ0NhY2hlW2lkXTtcbn1cbi8qKlxuICogR2V0IHN0cmluZ3MgYW5kIGxhbmd1YWdlIGNvZGVzLlxuICogVGhpcyBtZXRob2QgcmV0dXJucyAyIGxhbmd1YWdlIGNvZGVzLlxuICogVGhlIGZpcnN0IG9uZSByZXR1cm5zIGEgY29kZSB0aGF0J3MgYWxzbyBzdXBwb3J0ZWQgYXMgYSBsYW5ndWFnZSBmaWxlLlxuICogVGhlIHNlY29uZCBvbmUgcmV0dXJucyBhIGNvZGUgd2hlcmUgdGhlcmUgaXMgc3VwcG9ydCBmb3IgdGhlIGZpcnN0IDIgbGV0dGVycyBvZiB0aGUgY29kZSBhcyBwYXJ0IG9mIGEgbGFuZ3VhZ2UgZmlsZSxcbiAqIGJ1dCB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgNCBsZXR0ZXIgY29kZSBmcm9tIHRoZSBwYWdlLlxuICogRS5nLiBGb3IgXCJpdC1jaFwiIGl0IHdpbGwgcmV0dXJuIFwiaXRcIiBhcyB0aGUgZmlyc3QgbGFuZ3VhZ2UgY29kZSBhbmQgXCJpdC1jaFwiIGFzIHRoZSBzZWNvbmQuXG4gKiBUaGUgc2Vjb25kIG9uZSBpcyByZXF1aXJlZCBmb3IgZXNyaS5pbnRsLnNldExvY2FsZSgpIHRvIGdldCB0aGUgY29ycmVjdCBmb3JtYXR0aW5nLlxuICpcbiAqIElmIGEgdGFnTmFtZSBpcyBwcm92aWRlZCBpdCB3aWxsIG92ZXJ3aXRlIHRoZSBlbGVtZW50J3MgdGFnTmFtZVxuICpcbiAqICBAcmV0dXJuIFsgc3RyaW5ncywgZmlyc3QgbGFuZ3VhZ2UgY29kZSwgc2Vjb25kIGxhbmd1YWdlIGNvZGVdXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MoZWxlbWVudCwgdGFnTmFtZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB0YWdOYW1lIHx8IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpO1xuICAgIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlSW50bCA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCk7XG4gICAgbGV0IHN0cmluZ3M7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBjb21wb25lbnRMYW5ndWFnZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgbm8gbG9jYWxlIGZvciAke2NvbXBvbmVudE5hbWV9ICgke2NvbXBvbmVudExhbmd1YWdlfSkgbG9hZGluZyBkZWZhdWx0IGxvY2FsZSBlbi5gKTtcbiAgICAgICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBcImVuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW3N0cmluZ3MsIGNvbXBvbmVudExhbmd1YWdlLCBjb21wb25lbnRMYW5ndWFnZUludGxdO1xufVxuXG5leHBvcnQgeyBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UgYXMgYSwgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsZS0wNTBiNmRiOS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=