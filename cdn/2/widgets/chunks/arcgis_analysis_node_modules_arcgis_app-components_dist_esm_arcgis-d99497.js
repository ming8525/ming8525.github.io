"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-d99497"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-symbol-styler.entry.js":
/*!***********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-symbol-styler.entry.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_symbol_styler: () => (/* binding */ ArcGISSymbolStyler)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorRampUtils-8d9a3bed.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorRampUtils-8d9a3bed.js");
/* harmony import */ var _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbolUtils-f207d979.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/symbolUtils-f207d979.js");
/* harmony import */ var _color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color-16791b45.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/color-16791b45.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */










function equal(rampStops1, rampStops2, matchAlpha = false, reverse = true) {
    if (!rampStops1 || !rampStops2) {
        return false;
    }
    const equalMatch = rampStops1.every((color1, index) => {
        const color2 = rampStops2[index];
        return (color1.r === color2.r && color1.g === color2.g && color1.b === color2.b && (!matchAlpha || color1.a === color2.a));
    });
    if (!reverse) {
        return equalMatch;
    }
    return equalMatch || equal(rampStops1.slice().reverse(), rampStops2, matchAlpha, false);
}

function cimSymbolWalker(symbol, onVisit) {
    return visit(symbol, onVisit);
}
function visit(node, onVisit) {
    if (Array.isArray(node)) {
        for (let i = 0; i < node.length; i++) {
            const child = node[i];
            const result = visit(child, onVisit);
            if (result !== undefined) {
                return result;
            }
        }
        return;
    }
    const result = onVisit(node);
    if (result !== undefined) {
        return result;
    }
    if (node.type === "cim") {
        return visit(node.data.symbol, onVisit);
    }
    if (node.type === "CIMSymbolReference" || node.type === "CIMMarkerGraphic") {
        return visit(node.symbol, onVisit);
    }
    if (node.type === "CIMPointSymbol" || node.type === "CIMPolygonSymbol" || node.type === "CIMLineSymbol") {
        return visit(node.symbolLayers, onVisit);
    }
    if (node.type === "CIMHatchFill") {
        return visit(node.lineSymbol, onVisit);
    }
    if (node.type === "CIMVectorMarker") {
        return visit(node.markerGraphics, onVisit);
    }
    if (node.type === "CIMPictureMarker" ||
        node.type === "CIMTextSymbol" ||
        node.type === "CIMGradientFill" ||
        node.type === "CIMGradientStroke" ||
        node.type === "CIMObjectMarker3D" ||
        node.type === "CIMCharacterMarker" ||
        node.type === "CIMMaterialSymbolLayer" ||
        node.type === "CIMPictureStroke" ||
        node.type === "CIMPictureFill" ||
        node.type === "CIMSolidFill" ||
        node.type === "CIMSolidStroke") {
        /* end of the line â€“ intentional no-op */
        return;
    }
}
function updateSymbolLayerColor(symbolLayer, color, context) {
    const colorJSON = color.toJSON();
    cimSymbolWalker(symbolLayer, (node) => {
        if (context === "fill") {
            if (node.type === "CIMSolidFill") {
                node.color = colorJSON;
            }
            if (node.type === "CIMPictureFill" || node.type === "CIMPictureMarker") {
                node.tintColor = colorJSON;
            }
        }
        if (context === "stroke") {
            if (node.type === "CIMSolidStroke") {
                node.color = colorJSON;
            }
            if (node.type === "CIMPictureStroke") {
                node.tintColor = colorJSON;
            }
        }
    });
}
function getChildSymbolLayerColorContext(symbolLayer) {
    const observedTypes = new Set();
    observedTypes.add(cimSymbolWalker(symbolLayer, (node) => {
        if (node.type === "CIMSolidFill" ||
            node.type === "CIMHatchFill" ||
            node.type === "CIMPictureFill" ||
            node.type === "CIMPictureMarker") {
            return "fill";
        }
    }));
    observedTypes.add(cimSymbolWalker(symbolLayer, (node) => {
        if (node.type === "CIMSolidStroke" || node.type === "CIMPictureStroke") {
            return "stroke";
        }
    }));
    return Array.from(observedTypes).filter(Boolean);
}
function getVectorMarkerColor(vectorMarkerSymbolLayer, context) {
    const colorJSON = cimSymbolWalker(vectorMarkerSymbolLayer, (node) => {
        if (context === "fill") {
            if (node.type === "CIMSolidFill") {
                return node.color;
            }
            if (node.type === "CIMPictureFill" || node.type === "CIMPictureMarker") {
                return node.tintColor;
            }
        }
        if (context === "stroke") {
            if (node.type === "CIMSolidStroke") {
                return node.color;
            }
            if (node.type === "CIMPictureStroke") {
                return node.tintColor;
            }
        }
    });
    return _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.Color.fromJSON(colorJSON);
}
function getVectorMarkerSize(vectorMarkerSymbolLayer, context) {
    let size = 0;
    cimSymbolWalker(vectorMarkerSymbolLayer, (node) => {
        if (context === "fill") {
            if (node.type === "CIMVectorMarker" || node.type === "CIMPictureMarker") {
                if (node.size > size) {
                    size = node.size;
                }
            }
        }
        if (context === "stroke") {
            if (node.type === "CIMSolidStroke" || node.type === "CIMPictureStroke") {
                if (node.width > size) {
                    size = node.width;
                }
            }
        }
    });
    return size;
}
function updateSymbolLayerSize(symbolLayer, size, context) {
    cimSymbolWalker(symbolLayer, (node) => {
        if (context === "fill") {
            if (node.type === "CIMVectorMarker" || node.type === "CIMPictureMarker") {
                node.size = size;
            }
        }
        if (context === "stroke") {
            if (node.type === "CIMSolidStroke" || node.type === "CIMPictureStroke") {
                node.width = size;
            }
        }
    });
}
function getCIMStrokeWidthBounds() {
    // width should always use minWidthInPx/maxWidthInPx
    // except for CIMPictureStroke there we treat them as marker sizes with sizeMin/sizeMax
    return { min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.m, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.a };
}
function validateEditable(symbol) {
    if (!symbol) {
        return "missing symbol to edit";
    }
    if (symbol.type === "text" || symbol.type === "picture-fill") {
        return `editing symbol of type ${symbol.type} is not supported`;
    }
}
function adjustTransparencyIfNeeded(previous, next) {
    if (previous.a === 0) {
        next.a = 1;
    }
    return next;
}
function supportsFill(symbol) {
    return (((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) && (isMVCompatible(symbol) || isFillOnlyCIM(symbol))) ||
        ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.a)(symbol) && !isLineOnlySymbol(symbol)) ||
        (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.b)(symbol));
}
function supportsStroke(symbol) {
    return (((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) && isMVCompatible(symbol)) || (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.a)(symbol) || (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.c)(symbol) || (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.b)(symbol));
}
function isLineOnlySymbol(symbol) {
    return !!((symbol === null || symbol === void 0 ? void 0 : symbol.type) === "simple-marker" && (symbol.style === "x" || symbol.style === "cross"));
}
function normalizeSizeProp(payloadWithSizeProp, newSize = payloadWithSizeProp.size) {
    return Object.assign(Object.assign({}, payloadWithSizeProp), { size: normalizePt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(newSize)) });
}
function normalizePxOrPt(pxOrPt) {
    const fractionDigits = Number.isInteger(pxOrPt) ? 0 : 2;
    return Number(pxOrPt.toFixed(fractionDigits));
}
function normalizePx(pxOrPt) {
    const fractionDigits = Number.isInteger(pxOrPt) ? 0 : 2;
    return Number(pxOrPt.toFixed(fractionDigits));
}
function normalizePt(pxOrPt) {
    const fractionDigits = Number.isInteger(pxOrPt) ? 0 : 3;
    return Number(pxOrPt.toFixed(fractionDigits));
}
function parseSize(size, fallback) {
    return !isNaN(size) ? normalizePxOrPt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(size)) : fallback;
}
function getSymbolRotation(symbol) {
    var _a;
    if (!symbol || symbol.type === "simple-line" || symbol.type === "simple-fill") {
        return 0;
    }
    return (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) ? _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolRotation(symbol, true) : (_a = symbol.angle) !== null && _a !== void 0 ? _a : 0;
}
function isCIMTextSymbol(symbol) {
    return symbol.type === "CIMTextSymbol";
}
function isMVCompatible(symbol) {
    if (isCIMTextSymbol(symbol.data.symbol)) {
        return false;
    }
    const { symbolLayers } = symbol.data.symbol;
    if (symbolLayers.length === 1) {
        const [first] = symbolLayers;
        if (first.type !== "CIMVectorMarker" || first.colorLocked) {
            return false;
        }
        const { markerGraphics } = first;
        return (markerGraphics.length === 1 &&
            !isCIMTextSymbol(markerGraphics[0].symbol) &&
            hasUnlockedFillAndStroke(markerGraphics[0].symbol.symbolLayers));
    }
    if (symbolLayers.length === 2) {
        const [first, second] = symbolLayers;
        if (first.type !== "CIMVectorMarker" ||
            second.type !== "CIMVectorMarker" ||
            first.colorLocked ||
            first.size > second.size) {
            return false;
        }
        const firstMarkerGraphics = first.markerGraphics;
        const secondMarkerGraphics = second.markerGraphics;
        if (firstMarkerGraphics.length !== 1 || secondMarkerGraphics.length !== 1) {
            return false;
        }
        const [{ symbol: firstMarkerGraphicSymbol }] = firstMarkerGraphics;
        const [{ symbol: secondMarkerGraphicSymbol }] = secondMarkerGraphics;
        return (firstMarkerGraphicSymbol &&
            secondMarkerGraphicSymbol &&
            !isCIMTextSymbol(firstMarkerGraphicSymbol) &&
            !isCIMTextSymbol(secondMarkerGraphicSymbol) &&
            hasUnlockedFillAndStroke(firstMarkerGraphicSymbol.symbolLayers) &&
            hasFillAndStroke(secondMarkerGraphicSymbol.symbolLayers));
    }
    return false;
}
function isFillOnlyCIM(symbol) {
    return !!_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolColor(symbol);
}
function hasUnlockedFillAndStroke(symbolLayers) {
    return hasUnlockedFill(symbolLayers) && hasStroke(symbolLayers);
}
function hasFillAndStroke(symbolLayers) {
    return hasFill(symbolLayers) && hasStroke(symbolLayers);
}
function hasFill(symbolLayers) {
    return !!(symbolLayers === null || symbolLayers === void 0 ? void 0 : symbolLayers.find(({ type }) => type === "CIMSolidFill"));
}
function hasUnlockedFill(symbolLayers) {
    return !!getUnlockedFill(symbolLayers);
}
function getUnlockedFill(symbolLayers) {
    return symbolLayers === null || symbolLayers === void 0 ? void 0 : symbolLayers.find(({ type, colorLocked }) => type === "CIMSolidFill" && !colorLocked);
}
function hasStroke(symbolLayers) {
    return !!getStroke(symbolLayers);
}
function getStroke(symbolLayers) {
    return symbolLayers === null || symbolLayers === void 0 ? void 0 : symbolLayers.find(({ type }) => type === "CIMSolidStroke");
}
function supportsOutlineWidth(symbol) {
    var _a;
    // CIM must have a stroke
    const hasStroke = (_a = symbol.data.symbol.symbolLayers) === null || _a === void 0 ? void 0 : _a.find(({ type }) => ["CIMSolidStroke", "CIMPictureStroke"].indexOf(type) > -1);
    return !!hasStroke;
}
function getOutlineWidth(symbol) {
    var _a, _b;
    // just take first stroke
    const stroke = (_a = symbol.data.symbol.symbolLayers) === null || _a === void 0 ? void 0 : _a.find((symbolLayer) => ["CIMSolidStroke", "CIMPictureStroke"].indexOf(symbolLayer.type) > -1);
    return (_b = stroke.width) !== null && _b !== void 0 ? _b : 0;
}
function setOutlineWidth(symbol, width) {
    var _a;
    // don't use scaleCIMSymbolTo() because it also scales markers, separation, ... of the CIM
    // apply width to all strokes inside the CIM
    (_a = symbol.data.symbol.symbolLayers) === null || _a === void 0 ? void 0 : _a.forEach((symbolLayer) => {
        if (["CIMSolidStroke", "CIMPictureStroke"].indexOf(symbolLayer.type) > -1) {
            symbolLayer.width = width;
        }
    });
}
function isArrowMarker(marker) {
    return _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.s.includes(marker === null || marker === void 0 ? void 0 : marker.placement) && (marker === null || marker === void 0 ? void 0 : marker.style) === "arrow";
}
function toArrowPlacement(marker) {
    if (!marker) {
        return "none";
    }
    return isArrowMarker(marker) ? marker.placement : "none";
}
function toArrowMarker(placement) {
    if (placement === "none") {
        return undefined;
    }
    return {
        style: "arrow",
        placement
    };
}
function getStateColorRamps(section, strokeOrFillProps) {
    if (section && strokeOrFillProps && has2DColorRamp(section)) {
        const rotationsToMatch = getRotationsToMatchSelected(strokeOrFillProps.color, section.colorRamps);
        if (rotationsToMatch > 0) {
            return section.colorRamps.map((ramp) => {
                const rampClone = Object.assign({}, ramp);
                for (let i = 0; i < rotationsToMatch; i++) {
                    rampClone.stops = (0,_colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.f)(rampClone.stops, true);
                }
                return rampClone;
            });
        }
    }
    return section === null || section === void 0 ? void 0 : section.colorRamps;
}
function has2DColorRamp(section) {
    return (section === null || section === void 0 ? void 0 : section.type) === "color-ramp" && section.style === "2d";
}
function getRotationsToMatchSelected(selected, colorRamps) {
    const options = colorRamps.map((ramp) => ramp.stops);
    const maxRotations = 4;
    let selectedClone = selected.map((color) => color.clone());
    let totalRotationsOnSelected = 0;
    let matched = false;
    for (let i = 0; i < maxRotations; i++) {
        const match = options.some((option) => equal(selectedClone, option, true, false));
        if (match) {
            matched = true;
            break;
        }
        selectedClone = (0,_colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.f)(selectedClone, true);
        totalRotationsOnSelected++;
    }
    return matched ? (maxRotations - totalRotationsOnSelected) % maxRotations : null;
}
function capitalize(text) {
    return text.charAt(0).toUpperCase() + text.slice(1);
}
function getSymbolLabel(symbol, strings) {
    if (!symbol) {
        return null;
    }
    if (symbol.type === "picture-marker" || symbol.type === "simple-marker") {
        return strings.basicPoint;
    }
    if (symbol.type === "simple-line") {
        return strings.basicLine;
    }
    if (symbol.type === "simple-fill") {
        return strings.basicPolygon;
    }
    if (symbol.data.symbol.type === "CIMPointSymbol") {
        return strings.vectorPoint;
    }
    if (symbol.data.symbol.type === "CIMLineSymbol") {
        return strings.vectorLine;
    }
    if (symbol.data.symbol.type === "CIMPolygonSymbol") {
        return strings.vectorPolygon;
    }
    throw new Error("unsupported symbol provided");
}

const SelectCSS = {
    base: "select-number",
    input: "select-number__input"
};
const stepperClickHandlerForProperFocus = (event) => {
    // workaround for calcite-label wrapped SelectNumber focus bug
    event.stopPropagation();
};
const SelectNumber = (props) => {
    const { disabled, flipLabels = false, min, max, step, unitsLabel, value, withSteppers = true, label } = props;
    return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: SelectCSS.base },
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-slider", { disabled: disabled, min: min, max: max, value: value, step: step, onCalciteSliderInput: (event) => applyValueOnChange(event.target, props) }),
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { class: SelectCSS.input, disabled: disabled, max: max, min: min, numberButtonType: withSteppers ? "vertical" : "none", prefixText: flipLabels ? unitsLabel : "", onCalciteInputInput: (event) => applyValueOnChange(event.target, props), onClick: stepperClickHandlerForProperFocus, scale: "s", step: "any", suffixText: flipLabels ? "" : unitsLabel, type: "number", value: value.toString(), label: label })));
};
const applyValueOnChange = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.d)((node, props) => {
    debouncedApplyValueOnChange(node, props);
}, 800);
function debouncedApplyValueOnChange(node, props) {
    const value = Number(node.value);
    const clamped = Math.min(props.max, Math.max(props.min, value));
    if (value === props.value) {
        return;
    }
    node.value = `${clamped}`; // ensure value is within allowed range
    props.onValueChange(clamped);
}

const arcgisSymbolStylerCss = ".select-number{display:flex;align-items:center;justify-content:space-between;position:relative}.select-number calcite-slider{width:50%}.select-number__input{width:45%;font-size:var(--arcgis-app-font-size-0);font-family:var(--arcgis-app-font-family)}button{overflow:hidden;background-color:var(--arcgis-symbol-styler-inline-input-trigger-background-color);align-items:center;border:none;border-radius:0;box-sizing:border-box;cursor:pointer;display:flex;font-family:inherit;gap:8px;height:100%;justify-content:center;outline-color:transparent;outline-offset:0;padding:3px 0;padding-inline:3px 8px;position:relative;text-decoration:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;text-align:center;-webkit-appearance:none;width:100%}button:focus{outline:2px solid var(--calcite-color-brand);outline-offset:2px}button:hover{text-decoration:none}:host{min-width:240px;height:-moz-min-content;height:min-content;display:flex;flex:1 1 auto;flex-flow:column nowrap;align-items:stretch}calcite-dropdown{width:100%}calcite-flow{height:100%}.color-locked-info{display:flex;gap:4px;margin:8px 0;align-items:center}.color-locked-info calcite-icon{color:var(--calcite-color-text-3)}.icon-dropdown{padding:0.25rem 0 0 0;width:100%;background-color:var(--arcgis-app-background);height:2.25rem;border:1px solid #a9a9a9;box-shadow:inset 0 1px 2px rgba(0, 0, 0, 0.075)}.icon-dropdown--selected{cursor:pointer;margin-left:12px;height:3px;width:100%}.icon-dropdown .icon-dropdown-item-content,.icon-dropdown--selected{background-position:center;background-clip:content-box;background-origin:content-box;padding-left:0;padding-right:0}.icon-dropdown .icon-dropdown-item-content{height:30px;width:200px}.arcgis--rtl .icon-dropdown--selected{margin-right:12px}.style-dropdown [slot=trigger]{width:100%;display:flex;justify-content:space-between;align-items:center}.style-dropdown [slot=trigger] calcite-icon{margin:8px;background-color:#fff}.style-dropdown [slot=trigger],.style-dropdown .icon-dropdown-item-content{background-repeat:repeat-x}.arrow-dropdown [slot=trigger]{width:100%;display:flex;justify-content:space-between;align-items:center}.arrow-dropdown [slot=trigger] .icon-dropdown--selected{height:30px;background-size:100% 119px}.arrow-dropdown [slot=trigger] calcite-icon{margin:8px;background-color:#fff}.arrow-dropdown [slot=trigger] .icon-dropdown--selected,.arrow-dropdown .icon-dropdown-item-content{background-repeat:no-repeat}.arrow-dropdown [slot=trigger] .icon-dropdown--selected[data-arrow=none],.arrow-dropdown .icon-dropdown-item-content[data-arrow=none]{background-position:0 0}.arrow-dropdown [slot=trigger] .icon-dropdown--selected[data-arrow=begin],.arrow-dropdown .icon-dropdown-item-content[data-arrow=begin]{background-position:0 -32px}.arrow-dropdown [slot=trigger] .icon-dropdown--selected[data-arrow=end],.arrow-dropdown .icon-dropdown-item-content[data-arrow=end]{background-position:0 -61px}.arrow-dropdown [slot=trigger] .icon-dropdown--selected[data-arrow=begin-end],.arrow-dropdown .icon-dropdown-item-content[data-arrow=begin-end]{background-position:0 -91px}.content-group{display:flex;flex-direction:column}.content-group label{margin:8px 0 0 0}.color-ramp-selection{padding:4px}.section-toggle--disabled{pointer-events:none;opacity:0.5}.swatch-item{box-sizing:border-box;height:16px;width:16px;border-radius:2px;box-shadow:0 0 0 1px rgba(0, 0, 0, 0.33)}calcite-input[disabled] [data-adjustment]{pointer-events:none}arcgis-symbol-styler-section calcite-block{overflow:visible;margin:0 -12px}arcgis-symbol-styler-section calcite-block[open]:before{content:\"\";height:16px;display:flex;background-color:var(--calcite-color-foreground-2)}arcgis-symbol-styler-section calcite-block:nth-of-type(n+1){border-bottom:1px solid #f0f0f0}arcgis-symbol-styler-section calcite-block:last-child{border-bottom:none}arcgis-symbol-styler-section calcite-block arcgis-symbol-styler-section:nth-of-type(2){margin-top:12px}calcite-panel{overflow:visible;margin-top:0}.input-color{flex-wrap:nowrap;gap:8px;align-items:center}calcite-tooltip{max-width:250px}calcite-tooltip:not([open]){visibility:hidden;pointer-events:none}.message{margin-top:8px}arcgis-symbol-styler-symbol-preview[slot=icon]{width:32px;height:32px;padding:2px;display:flex;align-items:center;justify-content:center}.container{display:flex;padding:8px 12px;align-items:center;justify-content:center;width:100%;gap:8px;flex-grow:1}.symbol{height:32px;display:flex;justify-content:center;align-items:center}.label{flex-grow:1;display:flex;justify-content:flex-start}.change-symbol-trigger{border:1px solid #949494}.symbol-selection-panel{min-height:min(100vh - 200px, 500px);display:flex;flex-direction:column}.symbol-selection-panel arcgis-item-palette .palette{gap:8px}.symbol-selection-panel calcite-notice:first-of-type{margin:auto 0 0 0}.symbol-selection-panel calcite-label{margin:16px 12px 0 12px}.symbol-selection-panel calcite-panel{overflow:visible}.section{display:flex;flex-direction:column;background-color:var(--arcgis-app-background)}";

const ArcGISSymbolStyler = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisSymbolStylerEdit = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerEdit", 7);
        this.arcgisSymbolStylerMarkerChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerMarkerChange", 7);
        this.arcgisSymbolStylerFillChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerFillChange", 7);
        this.arcgisSymbolStylerFillEnabledChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerFillEnabledChange", 7);
        this.arcgisSymbolStylerStrokeChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerStrokeChange", 7);
        this.arcgisSymbolStylerStrokeEnabledChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerStrokeEnabledChange", 7);
        this.arcgisSymbolStylerSourceIdChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerSourceIdChange", 7);
        this.resizeObserver = new ResizeObserver((entries) => {
            const last = entries.pop();
            this.narrow = last.contentRect.width <= 275;
        });
        this.windowResizeObserver = new ResizeObserver(() => this.checkPopoverMaxHeight());
        this.autoOpenFirstBlock = false;
        this.autoCalcHeight = false;
        this.colorInputEl = [];
        this.manualBlockOpen = false;
        this.updatePreviewSymbol = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.c)(() => {
            const preview = this.symbol.clone();
            this.syncSymbolProps(preview, {
                symbolState: {
                    marker: this.marker,
                    fill: this.fill,
                    stroke: this.stroke
                }
            });
            this.previewSymbol = preview;
        }, 150);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.setRampInputRef = (el) => {
            this.rampInputEl = el;
        };
        this.setColorInputRef = (el) => {
            this.colorInputEl.push(el);
        };
        this.onColorRampFillTransparencyChange = (strokeTransparency) => {
            const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(strokeTransparency);
            const fill = this.fill;
            const mergedFill = {
                color: fill.color.map((color) => (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(Object.assign(Object.assign({}, color), { a: alpha })))
            };
            this.fill = mergedFill;
            this.arcgisSymbolStylerFillChange.emit(mergedFill);
            this.setInternalSymbol(this.syncSymbolProps(this.symbol, { cimChangeContext: "root" }), true);
        };
        this.onFillColorRampCategoryChange = (event) => {
            const select = event.target;
            const activeCategory = select.selectedOption.value;
            const section = this.sections.fill;
            this.sections = Object.assign(Object.assign({}, this.sections), { fill: Object.assign(Object.assign({}, section), { activeCategory }) });
            event.stopPropagation();
        };
        this.onColorFillTransparencyChange = (strokeTransparency) => {
            const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(strokeTransparency);
            const { fill } = this;
            const mergedFill = {
                color: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(Object.assign(Object.assign({}, fill.color), { a: alpha }))
            };
            this.fill = mergedFill;
            this.arcgisSymbolStylerFillChange.emit(mergedFill);
            this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
        };
        this.onStrokeColorRampCategoryChange = (event) => {
            const select = event.target;
            const activeCategory = select.selectedOption.value;
            const section = this.sections.stroke;
            this.sections = Object.assign(Object.assign({}, this.sections), { stroke: Object.assign(Object.assign({}, section), { activeCategory }) });
            event.stopPropagation();
        };
        this.onColorStrokeTransparencyChange = (strokeTransparency) => {
            const { stroke } = this;
            const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(strokeTransparency);
            const mergedStroke = Object.assign(Object.assign({}, stroke), { color: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(Object.assign(Object.assign({}, stroke.color), { a: alpha })) });
            this.stroke = mergedStroke;
            this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
            this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
        };
        this.onColorRampStrokeTransparencyChange = (strokeTransparency) => {
            const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(strokeTransparency);
            const stroke = this.stroke;
            const mergedStroke = Object.assign(Object.assign({}, stroke), { color: stroke.color.map((color) => (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(Object.assign(Object.assign({}, color), { a: alpha }))) });
            this.stroke = mergedStroke;
            this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
            this.setInternalSymbol(this.syncSymbolProps(this.symbol, { cimChangeContext: "root" }), true);
        };
        this.onStrokeStyleChange = (event) => {
            const dropdown = event.currentTarget;
            const style = dropdown.selectedItems[0].getAttribute("data-style");
            const { stroke } = this;
            const mergedStroke = Object.assign(Object.assign({}, stroke), { style });
            this.stroke = mergedStroke;
            this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
            this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
            event.stopPropagation();
        };
        this.onStrokeArrowChange = (event) => {
            const dropdown = event.currentTarget;
            const arrow = dropdown.selectedItems[0].getAttribute("data-arrow");
            const { stroke } = this;
            const mergedStroke = Object.assign(Object.assign({}, stroke), { marker: toArrowMarker(arrow) });
            this.stroke = mergedStroke;
            this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
            this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
            event.stopPropagation();
        };
        this.onStrokeWidthChange = (width) => this.setStrokeWidth(width);
        this.onAutoAdjustStrokeChange = (event) => {
            const node = event.currentTarget;
            const autoAdjusted = node.checked;
            const { stroke } = this;
            const mergedStroke = Object.assign(Object.assign({}, stroke), { autoAdjusted });
            this.stroke = mergedStroke;
            this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
            // we set to emit the auto-adjusted changes regardless of the symbol not changing
            this.emitEdit(this.symbol);
            event.stopPropagation();
        };
        this.syncSymbolProps = (symbol, options) => {
            const symbolState = (options === null || options === void 0 ? void 0 : options.symbolState) || {
                marker: this.marker,
                fill: this.fill,
                stroke: this.stroke
            };
            const cimChangeContext = options === null || options === void 0 ? void 0 : options.cimChangeContext;
            const type = (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.g)(symbol);
            return type === "point"
                ? this.syncPointSymbolProps(symbol, symbolState, cimChangeContext)
                : type === "line"
                    ? this.syncLineSymbolProps(symbol, symbolState, cimChangeContext)
                    : this.syncPolygonSymbolProps(symbol, symbolState, cimChangeContext);
        };
        this.syncPointSymbolProps = (symbol, { fill, marker, stroke }, cimChangeContext) => {
            const { screenUtils } = _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e;
            const { sections } = this;
            const size = normalizePt(screenUtils.px2pt(marker.size));
            if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.a)(symbol)) {
                const lineOnlySymbol = isLineOnlySymbol(symbol);
                if (!lineOnlySymbol) {
                    if (this.isFillColorRamp()) {
                        symbol.color = this.getSampleFillColorRampColor();
                    }
                    else {
                        symbol.color = sections.fill.enabled ? fill.color : (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(null);
                    }
                }
                if (symbol.outline) {
                    if (this.isStrokeColorRamp()) {
                        symbol.outline.color = this.getSampleStrokeColorRampColor();
                    }
                    else if (lineOnlySymbol && this.isFillColorRamp()) {
                        symbol.outline.color = this.getSampleFillColorRampColor();
                    }
                    else {
                        symbol.outline.color = sections.stroke.enabled
                            ? stroke.color
                            : (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(null);
                    }
                    symbol.outline.marker = stroke.marker;
                    symbol.outline.style = stroke.style;
                    symbol.outline.width = normalizePt(screenUtils.px2pt(stroke.size));
                }
                symbol.size = size;
            }
            else if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.d)(symbol)) {
                // keep aspect ratio
                symbol.height = Math.round((symbol.height / symbol.width) * size * 100) / 100;
                symbol.width = size;
            }
            const clockwiseAngle = Math.abs(marker.angle);
            if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol)) {
                // only top-level props are applied
                // when using the original symbol from a symbol set we want to keep these current settings
                if (["root", "original-root"].indexOf(cimChangeContext) > -1) {
                    _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolRotation(symbol, clockwiseAngle, true);
                    _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.scaleCIMSymbolTo(symbol, size);
                }
                else {
                    symbol.data.symbol.angle = clockwiseAngle;
                }
                if (this.isFillColorRamp()) {
                    _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolColor(symbol, this.getSampleFillColorRampColor(), {
                        layersToColor: "fill"
                    });
                }
                else if (this.isStrokeColorRamp()) {
                    _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolColor(symbol, this.getSampleStrokeColorRampColor(), { layersToColor: "outline" });
                }
            }
            else {
                symbol.angle = clockwiseAngle;
            }
            return symbol;
        };
        this.syncLineSymbolProps = (symbol, { stroke }, cimChangeContext) => {
            const { screenUtils } = _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e;
            const { sections } = this;
            const width = normalizePt(screenUtils.px2pt(stroke.size));
            if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.c)(symbol)) {
                if (this.isStrokeColorRamp()) {
                    symbol.color = this.getSampleStrokeColorRampColor();
                }
                else {
                    symbol.color = sections.stroke.enabled ? stroke.color : (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(null);
                }
                // when using the original symbol from a symbol set we don't want to keep these settings
                if (cimChangeContext !== "original-root") {
                    symbol.marker = stroke.marker;
                    symbol.style = stroke.style;
                    symbol.width = width;
                }
            }
            else if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol)) {
                // only top-level props are applied
                // when using the original symbol from a symbol set ("original-root") we don't want to keep these settings
                if (cimChangeContext === "root") {
                    _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.scaleCIMSymbolTo(symbol, width);
                }
                if (this.isStrokeColorRamp()) {
                    _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolColor(symbol, this.getSampleStrokeColorRampColor());
                }
            }
            return symbol;
        };
        this.syncPolygonSymbolProps = (symbol, { fill, stroke }, cimChangeContext) => {
            const { screenUtils } = _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e;
            const { sections } = this;
            const width = normalizePt(screenUtils.px2pt(stroke.size));
            if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.b)(symbol)) {
                if (this.isFillColorRamp()) {
                    symbol.color = this.getSampleFillColorRampColor();
                }
                else {
                    symbol.color = sections.fill.enabled ? fill.color : (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(null);
                }
                if (this.isStrokeColorRamp()) {
                    symbol.outline.color = this.getSampleStrokeColorRampColor();
                }
                else {
                    symbol.outline.color = sections.stroke.enabled
                        ? stroke.color
                        : (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(null);
                }
                // when using the original symbol from a symbol set we don't want to keep these settings
                if (cimChangeContext !== "original-root") {
                    symbol.outline.width = width;
                    symbol.outline.style = stroke.style;
                }
            }
            else if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol)) {
                // only top-level props are applied
                if (this.isFillColorRamp()) {
                    _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolColor(symbol, this.getSampleFillColorRampColor(), {
                        layersToColor: "fill"
                    });
                }
                else if (this.isStrokeColorRamp()) {
                    _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolColor(symbol, this.getSampleStrokeColorRampColor(), { layersToColor: "outline" });
                }
                // when using the original symbol from a symbol set ("original-root") we don't want to keep these settings
                if (cimChangeContext === "root") {
                    if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.f)(symbol)) {
                        // scaleCIMSymbolTo() also scales markers, separators, ...
                        setOutlineWidth(symbol, width);
                    }
                    else {
                        _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.scaleCIMSymbolTo(symbol, width);
                    }
                }
            }
            return symbol;
        };
        this.onStrokeEnabledChange = (enabled) => {
            const { sections } = this;
            const preventChange = isLineOnlySymbol(this.activeSymbol);
            this.sections = Object.assign(Object.assign({}, sections), { stroke: Object.assign(Object.assign({}, sections.stroke), { enabled: preventChange ? true : enabled }) });
            if (preventChange) {
                return;
            }
            this.arcgisSymbolStylerStrokeEnabledChange.emit({
                enabled,
                stroke: normalizeSizeProp(this.stroke)
            });
            this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
        };
        this.onFillEnabledChange = (enabled) => {
            const { fill, sections } = this;
            const preventChange = isLineOnlySymbol(this.activeSymbol);
            this.sections = Object.assign(Object.assign({}, sections), { fill: Object.assign(Object.assign({}, sections.fill), { enabled: preventChange ? false : enabled }) });
            if (preventChange) {
                return;
            }
            this.arcgisSymbolStylerFillEnabledChange.emit({
                enabled,
                fill
            });
            this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
        };
        this.onAutoAdjustSizeChange = (event) => {
            const node = event.currentTarget;
            const autoAdjusted = node.checked;
            const { marker } = this;
            const mergedMarker = Object.assign(Object.assign({}, marker), { autoAdjusted });
            this.marker = mergedMarker;
            this.arcgisSymbolStylerMarkerChange.emit(normalizeSizeProp(mergedMarker));
            // we set to emit the auto-adjusted changes regardless of the symbol not changing
            this.emitEdit(this.symbol);
            event.stopPropagation();
        };
        this.onSymbolSizeChange = (size) => this.setSymbolSize(size);
        this.onSymbolRotationChange = (angle) => {
            const { marker, fill, stroke } = this;
            const mergedMarker = Object.assign(Object.assign({}, marker), { angle, symbol: this.syncSymbolProps(this.symbol, {
                    cimChangeContext: "root",
                    symbolState: {
                        marker: Object.assign(Object.assign({}, marker), { angle }),
                        fill: fill,
                        stroke: stroke
                    }
                }) });
            this.marker = mergedMarker;
            this.setInternalSymbol(mergedMarker.symbol, true);
            this.arcgisSymbolStylerMarkerChange.emit(normalizeSizeProp(mergedMarker));
        };
        this.onSymbolSelect = (symbol) => {
            var _a;
            const { fill, marker, sections, stroke } = this;
            const changedFromPMSToSMS = ((_a = this.activeSymbol) === null || _a === void 0 ? void 0 : _a.type) === "picture-marker" && symbol.type === "simple-marker";
            const hadLineOnlySymbol = isLineOnlySymbol(this.activeSymbol);
            const selectedLineOnlySymbol = isLineOnlySymbol(symbol);
            const changedFromLineOnlySMSToNonLineOnlySMS = hadLineOnlySymbol && !selectedLineOnlySymbol;
            const changedFromNonLineOnlySMSToLineOnlySMS = !hadLineOnlySymbol && selectedLineOnlySymbol;
            this.autoOpenFirstBlock = true;
            const fillSupported = supportsFill(symbol);
            const strokeSupported = supportsStroke(symbol);
            const fillStrokeOverrides = {};
            const switchedFromCIMToNonCIM = (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(this.activeSymbol) && !(0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol);
            if (switchedFromCIMToNonCIM) {
                if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.a)(symbol) || (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.b)(symbol)) {
                    if (fillSupported && sections.fill.type === "color") {
                        fillStrokeOverrides.fill = Object.assign(Object.assign({}, fill), { color: symbol.color.clone() });
                    }
                    if (strokeSupported && sections.stroke.type === "color") {
                        const smsOrSfs = symbol;
                        const color = smsOrSfs.outline.color.clone();
                        if (changedFromNonLineOnlySMSToLineOnlySMS) {
                            // ensure line color is visible
                            color.a = 1;
                        }
                        fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { color });
                        if (_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.b) {
                            // override with outline width of new symbol
                            fillStrokeOverrides.stroke.size = symbol.outline.width;
                            fillStrokeOverrides.stroke.style = symbol.outline.style;
                        }
                    }
                }
                else if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.c)(symbol)) {
                    if (strokeSupported && sections.stroke.type === "color") {
                        const sls = symbol;
                        fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { size: sls.width, color: sls.color.clone() });
                    }
                }
            }
            else if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol)) {
                const rootColor = _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolColor(symbol);
                if (sections.fill.type === "color") {
                    fillStrokeOverrides.fill = Object.assign(Object.assign({}, fill), { color: rootColor });
                }
                fillStrokeOverrides.stroke = Object.assign({}, stroke);
                if (this.editGeometry === "point") {
                    fillStrokeOverrides.stroke.size = normalizePt(marker.size);
                }
                else if (this.editGeometry === "line") {
                    fillStrokeOverrides.stroke.size = normalizePt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolSize(symbol));
                }
                if (sections.stroke.type === "color") {
                    fillStrokeOverrides.stroke.color = rootColor;
                }
                this.cimStrokeWidthBounds = getCIMStrokeWidthBounds();
            }
            else if (sections.fill.type === "color-ramp" && sections.stroke.type === "color") {
                if (selectedLineOnlySymbol) {
                    // use fill ramp category and store selected ramp whenever switching to pure-line style
                    this.tempStrokeColorRampStateActiveCategory = sections.fill.activeCategory;
                    this.tempStrokeColorRampStateStops = fill.color;
                    this.tempStrokePreviousColorBeforeColorRampSwitch = stroke.color;
                    fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { color: this.tempStrokeColorRampStateStops });
                }
                else if (changedFromLineOnlySMSToNonLineOnlySMS) {
                    fillStrokeOverrides.fill = Object.assign(Object.assign({}, fill), { color: this.tempStrokeColorRampStateStops });
                    fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { color: this.tempStrokePreviousColorBeforeColorRampSwitch });
                    this.tempStrokeColorRampStateActiveCategory = null;
                    this.tempStrokeColorRampStateStops = null;
                }
            }
            else if (sections.fill.type === "color" && sections.stroke.type === "color-ramp") {
                if (changedFromNonLineOnlySMSToLineOnlySMS) {
                    const ramp = stroke.color.map((color) => {
                        // ensure line color is visible
                        color.a = 1;
                        return color;
                    });
                    fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { color: ramp });
                }
            }
            else if (sections.fill.type === "color" && sections.stroke.type === "color") {
                if (changedFromNonLineOnlySMSToLineOnlySMS) {
                    const color = stroke.color.clone();
                    if (changedFromNonLineOnlySMSToLineOnlySMS) {
                        // ensure line color is visible
                        color.a = 1;
                    }
                    fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { color });
                }
            }
            this.sections = Object.assign(Object.assign({}, sections), { fill: Object.assign(Object.assign({}, sections.fill), { open: !selectedLineOnlySymbol && sections.fill.open, enabled: fillSupported &&
                        (!selectedLineOnlySymbol ||
                            (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) ||
                            changedFromLineOnlySMSToNonLineOnlySMS ||
                            changedFromPMSToSMS ||
                            sections.fill.enabled) }), stroke: Object.assign(Object.assign({}, sections.stroke), { enabled: strokeSupported &&
                        ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) ||
                            changedFromNonLineOnlySMSToLineOnlySMS ||
                            (switchedFromCIMToNonCIM && !selectedLineOnlySymbol) ||
                            changedFromPMSToSMS ||
                            sections.stroke.enabled) }) });
            const finalFill = (fillStrokeOverrides.fill || fill);
            const finalStroke = (fillStrokeOverrides.stroke || stroke);
            const mergedMarker = Object.assign(Object.assign({}, marker), { symbol: this.syncSymbolProps(symbol, {
                    cimChangeContext: "original-root",
                    symbolState: {
                        marker,
                        fill: finalFill,
                        stroke: finalStroke
                    }
                }) });
            this.fill = finalFill;
            this.stroke = finalStroke;
            this.marker = mergedMarker;
            this.activeSymbol = symbol;
            this.setInternalSymbol(mergedMarker.symbol, true, true);
            this.arcgisSymbolStylerMarkerChange.emit(normalizeSizeProp(mergedMarker));
        };
        this.emitEdit = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.d)(async (symbol, symbolSwitch) => {
            const clone = symbol.clone();
            const info = {};
            const { editGeometry } = this;
            const addMarker = editGeometry === "point";
            const addFill = (!isLineOnlySymbol(symbol) && editGeometry === "point") || editGeometry === "polygon";
            if (addMarker) {
                info.marker = Object.assign(Object.assign({}, normalizeSizeProp(this.marker)), { symbol: clone });
            }
            if (addFill) {
                info.fill = Object.assign({}, this.fill);
            }
            // stroke applies to all geometry types
            info.stroke = Object.assign({}, normalizeSizeProp(this.stroke));
            this.arcgisSymbolStylerEdit.emit({
                symbol: clone,
                info,
                symbolSwitch
            });
        }, 300);
        this.flipFillColorRamps = () => {
            const section = this.sections.fill;
            const fill = this.fill;
            const is2d = section.style === "2d";
            const mergedFill = {
                color: (0,_colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.f)(fill.color, is2d)
            };
            this.sections = Object.assign(Object.assign({}, this.sections), { fill: Object.assign(Object.assign({}, section), { colorRamps: section.colorRamps.map(({ stops, tags, name }) => ({
                        stops: (0,_colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.f)(stops, is2d),
                        tags,
                        name
                    })) }) });
            this.fill = mergedFill;
            this.arcgisSymbolStylerFillChange.emit(mergedFill);
            // we set to emit the auto-adjusted changes regardless of the symbol not changing
            this.emitEdit(this.symbol);
        };
        this.renderBlock = (props) => {
            var _a;
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { collapsible: true, disabled: (_a = props.disabled) !== null && _a !== void 0 ? _a : false, heading: props.heading, key: props.key, onCalciteBlockOpen: this.onBlockToggle, onCalciteBlockClose: this.onBlockToggle }, props.icon, props.content));
        };
        this.onBlockToggle = (event) => {
            var _a;
            if (this.manualBlockOpen) {
                this.manualBlockOpen = false;
                return;
            }
            // close all color picker popovers
            (_a = this.rampInputEl) === null || _a === void 0 ? void 0 : _a.close();
            this.colorInputEl.forEach((el) => el === null || el === void 0 ? void 0 : el.close());
        };
        this.renderSection = ({ disabled, embedded = false, key, sectionContent }) => {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { disabled: disabled, key: key, embedded: embedded }, sectionContent.map(({ content }) => content)));
        };
        this.flipStrokeColorRamps = () => {
            const section = this.sections.stroke;
            const stroke = this.stroke;
            const is2d = section.style === "2d";
            const mergedStroke = Object.assign(Object.assign({}, stroke), { color: (0,_colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.f)(stroke.color, is2d) });
            this.sections = Object.assign(Object.assign({}, this.sections), { stroke: Object.assign(Object.assign({}, section), { colorRamps: section.colorRamps.map(({ stops, tags, name }) => ({
                        stops: (0,_colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.f)(stops, is2d),
                        tags: tags.slice(),
                        name
                    })) }) });
            this.stroke = mergedStroke;
            this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
            // we set to emit the auto-adjusted changes regardless of the symbol not changing
            this.emitEdit(this.symbol);
        };
        this.popoverProps = undefined;
        this.initialSourceId = undefined;
        this.portal = undefined;
        this.stringOverrides = undefined;
        this.mode = "default";
        this.cimStrokeWidthBounds = undefined;
        this.config = undefined;
        this.editGeometry = undefined;
        this.fill = undefined;
        this.marker = undefined;
        this.narrow = false;
        this.preppingEdit = true;
        this.previewSymbol = undefined;
        this.sections = undefined;
        this.builtInStrings = undefined;
        this.mergedStrings = undefined;
        this.stroke = undefined;
        this.symbol = undefined;
        this.tempStrokeColorRampStateActiveCategory = "all";
        this.activeSymbol = undefined;
        this.activeSymbolItem = undefined;
        this.activeSourceId = undefined;
        this.state = "editing";
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.resizeObserver.observe(this.el);
        this.windowResizeObserver.observe(document.body);
    }
    disconnectedCallback() {
        this.resizeObserver.unobserve(this.el);
        this.windowResizeObserver.unobserve(document.body);
    }
    async componentWillLoad() {
        const [, [strings]] = await Promise.all([
            _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.load(),
            (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.el)
        ]);
        this.currentLanguage = (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_5__.a)(this.el);
        this.dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.el);
        const percentFormatter = new Intl.NumberFormat(this.currentLanguage, { style: "percent" });
        const percentFormatSample = percentFormatter.format(0);
        this.percentLabelFlip =
            this.dir === "rtl" ? percentFormatSample.endsWith("%") : percentFormatSample.startsWith("%");
        this.builtInStrings = strings;
    }
    componentShouldUpdate(newVal, _oldVal, propName) {
        if (propName === "preppingEdit") {
            return !newVal;
        }
    }
    componentDidRender() {
        if (this.autoOpenFirstBlock && !this.preppingEdit) {
            const firstBlock = this.el.shadowRoot.querySelector("calcite-block");
            if (firstBlock) {
                this.autoOpenFirstBlock = false;
                // workaround for Calcite issue #8453
                this.manualBlockOpen = true;
                firstBlock.open = true;
            }
        }
    }
    // multiple watches trigger false negative for this rule
    // eslint-disable-next-line @stencil/no-unused-watch
    handleStringChanges() {
        this.mergedStrings = Object.assign(Object.assign({}, this.builtInStrings), this.stringOverrides);
    }
    onPanelBack(event) {
        event.stopPropagation();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    async edit(symbol, config) {
        var _a, _b, _c, _d, _e, _f, _g;
        const errorMessage = validateEditable(symbol);
        if (errorMessage) {
            throw new Error(`[arcgis-symbol-styler] ${errorMessage}`);
        }
        symbol = await this.checkLineOnlySymbol(symbol, config);
        this.portalOrInterceptor = config.portal || this.portal || _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.Portal.getDefault();
        this.preppingEdit = true;
        this.autoOpenFirstBlock = true;
        const { marker: markerSection, fill: fillSection, stroke: strokeSection } = config.sections;
        this.symbolFilter =
            config.symbolFilter ||
                ((markerSection === null || markerSection === void 0 ? void 0 : markerSection.markerType) === "all" ? undefined : markerSection === null || markerSection === void 0 ? void 0 : markerSection.markerType);
        this.editGeometry = (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.g)(symbol);
        symbol = symbol.clone();
        const fillSupported = supportsFill(symbol);
        const strokeSupported = supportsStroke(symbol);
        if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.a)(symbol) || (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.b)(symbol)) {
            if (!symbol.outline) {
                symbol.outline = { type: "simple-line", color: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(null) };
            }
            else if (!symbol.outline.color) {
                symbol.outline.color = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(null);
            }
        }
        const stroke = Object.assign(Object.assign({ autoAdjusted: false }, config.stroke), { size: parseSize((_a = config.stroke) === null || _a === void 0 ? void 0 : _a.size, 2), style: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.b.includes((_b = config.stroke) === null || _b === void 0 ? void 0 : _b.style) ? config.stroke.style : "solid" });
        if ((_c = config.stroke) === null || _c === void 0 ? void 0 : _c.marker) {
            stroke.marker = config.stroke.marker;
        }
        this.sections = {
            marker: {
                backgroundStyle: "light",
                optional: false /* placeholder */,
                enabled: false /* placeholder */,
                open: (markerSection === null || markerSection === void 0 ? void 0 : markerSection.open) || false,
                symbolsOpen: (markerSection && (!("symbolsOpen" in markerSection) || markerSection.symbolsOpen)) ||
                    false,
                sizeOpen: (markerSection && (!("sizeOpen" in markerSection) || markerSection.sizeOpen)) || false,
                rotationOpen: (markerSection && (!("rotationOpen" in markerSection) || markerSection.rotationOpen)) ||
                    false,
                keepChoice: (markerSection === null || markerSection === void 0 ? void 0 : markerSection.keepChoice) || false,
                parts: Object.assign(Object.assign({}, _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.d), markerSection === null || markerSection === void 0 ? void 0 : markerSection.parts)
            },
            fill: {
                activeCategory: "all",
                open: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.open) || false,
                optional: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.optional) || false,
                enabled: fillSupported &&
                    ((_d = config.fillEnabled) !== null && _d !== void 0 ? _d : true) &&
                    !(0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) &&
                    (fillSection === null || fillSection === void 0 ? void 0 : fillSection.type) === "color" &&
                    !!this.toColorPickerValue(config.fill.color),
                type: fillSection === null || fillSection === void 0 ? void 0 : fillSection.type,
                style: fillSection === null || fillSection === void 0 ? void 0 : fillSection.style,
                suggestedColorsOpen: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.suggestedColorsOpen) || false,
                customColorOpen: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.customColorOpen) || false,
                colorRampsOpen: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.colorRampsOpen) || false,
                colorRamps: getStateColorRamps(fillSection, config.fill),
                transparencyOpen: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.transparencyOpen) || false,
                parts: Object.assign(Object.assign(Object.assign({}, _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.c), _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.e), fillSection === null || fillSection === void 0 ? void 0 : fillSection.parts)
            },
            stroke: {
                activeCategory: "all",
                optional: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.optional) || false,
                open: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.open) || false,
                enabled: strokeSupported &&
                    ((_e = config.strokeEnabled) !== null && _e !== void 0 ? _e : true) &&
                    !(0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) &&
                    (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.type) === "color" &&
                    !!this.toColorPickerValue(config.stroke.color),
                type: strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.type,
                style: strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.style,
                suggestedColorsOpen: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.suggestedColorsOpen) || false,
                customColorOpen: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.customColorOpen) || false,
                colorRampsOpen: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.colorRampsOpen) || false,
                colorRamps: getStateColorRamps(strokeSection, config.stroke),
                transparencyOpen: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.transparencyOpen) || false,
                extraOpen: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.extraOpen) || false,
                extraParts: Object.assign(Object.assign({}, _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.g), strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.extraParts),
                parts: Object.assign(Object.assign(Object.assign(Object.assign({}, _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.c), _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.e), _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.h), strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.parts)
            }
        };
        this.marker = Object.assign(Object.assign({}, config.marker), { size: parseSize((_f = config.marker) === null || _f === void 0 ? void 0 : _f.size, 0), angle: getSymbolRotation(symbol), autoAdjusted: ((_g = config.marker) === null || _g === void 0 ? void 0 : _g.autoAdjusted) || false, symbol });
        this.fill = Object.assign({}, config.fill);
        this.stroke = stroke;
        this.activeSymbol = symbol;
        this.activeSourceId = ((markerSection === null || markerSection === void 0 ? void 0 : markerSection.keepChoice) && this.activeSourceId) || null;
        this.activeSymbolItem = ((markerSection === null || markerSection === void 0 ? void 0 : markerSection.keepChoice) && this.activeSymbolItem) || null;
        this.config = config;
        if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) && (this.isFillColorRamp() || this.isStrokeColorRamp())) {
            this.syncSymbolProps(symbol, {
                cimChangeContext: "root"
            });
        }
        if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol)) {
            this.cimStrokeWidthBounds = getCIMStrokeWidthBounds();
        }
        this.setInternalSymbol(symbol, false);
        this.preppingEdit = false;
    }
    async checkLineOnlySymbol(symbol, config) {
        // we no longer support plus and X markers in the styler
        var _a, _b, _c, _d, _e, _f, _g;
        if (isLineOnlySymbol(symbol)) {
            //"fill":{"color":Color},
            //"fill":{"color":[Color,Color,Color,Color,Color]}
            //"marker":{"size":13.5,"autoAdjusted":false},
            //"stroke":{"color":Color,"size":0.75}
            const [SimpleMarkerSymbol] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_7__.l)(["esri/symbols/SimpleMarkerSymbol"]);
            symbol = new SimpleMarkerSymbol();
            // make sure config fits to new symbol
            if ((_a = config.fill) === null || _a === void 0 ? void 0 : _a.color) {
                if (Array.isArray(config.fill.color)) {
                    // "color-ramp"
                    symbol.color = config.fill.color[config.fill.color.length - 1];
                }
                else {
                    // "color"
                    symbol.color = config.fill.color;
                }
            }
            if ((_b = config.stroke) === null || _b === void 0 ? void 0 : _b.color) {
                config.stroke.color = symbol.outline.color.clone();
            }
            if (((_c = config.stroke) === null || _c === void 0 ? void 0 : _c.size) || ((_d = config.stroke) === null || _d === void 0 ? void 0 : _d.size) === 0) {
                config.stroke.size = symbol.outline.width;
            }
            if ((_e = config.marker) === null || _e === void 0 ? void 0 : _e.size) {
                symbol.size = config.marker.size;
            }
            this.marker = Object.assign(Object.assign({}, config.marker), { size: parseSize((_f = config.marker) === null || _f === void 0 ? void 0 : _f.size, 0), angle: getSymbolRotation(symbol), autoAdjusted: ((_g = config.marker) === null || _g === void 0 ? void 0 : _g.autoAdjusted) || false, symbol });
            this.emitEdit(symbol);
            return Promise.resolve(symbol);
        }
        return Promise.resolve(symbol);
    }
    async setSize(type, size) {
        const { screenUtils } = _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e;
        if (type === "stroke") {
            this.setStrokeWidth(normalizePx(screenUtils.pt2px(size)), false);
        }
        if (type === "marker") {
            this.setSymbolSize(normalizePx(screenUtils.pt2px(size)), false);
        }
    }
    getLinePatternStyle(style) {
        return {
            backgroundImage: `url(${(0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/line-patterns/${style}.png`)})`
        };
    }
    getSelectedArrowPatternStyle() {
        return {
            backgroundImage: `url(${(0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/arrow-pattern-spritesheet.png`)})`
        };
    }
    getArrowPatternOptionStyle() {
        return {
            backgroundImage: `url(${(0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/arrow-pattern-options-spritesheet.png`)})`
        };
    }
    hasActiveLineOnlySimpleMarkerSymbol() {
        const { marker, symbol } = this;
        return marker && isLineOnlySymbol(symbol);
    }
    hasActivePictureMarkerSymbol() {
        var _a;
        return ((_a = this.symbol) === null || _a === void 0 ? void 0 : _a.type) === "picture-marker" || this.activeSymbol.type === "picture-marker";
    }
    setStrokeWidth(width, emit = true) {
        const { stroke } = this;
        const size = width < 0 ? 0 : normalizePx(width);
        const mergedStroke = Object.assign(Object.assign({}, stroke), { size });
        this.stroke = mergedStroke;
        if (emit) {
            this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke, width));
        }
        this.setInternalSymbol(this.syncSymbolProps(this.symbol, { cimChangeContext: "root" }), emit);
    }
    isFillColorRamp() {
        var _a;
        return ((_a = this.config.sections.fill) === null || _a === void 0 ? void 0 : _a.type) === "color-ramp";
    }
    isStrokeColorRamp() {
        var _a;
        return ((_a = this.config.sections.stroke) === null || _a === void 0 ? void 0 : _a.type) === "color-ramp";
    }
    getSampleFillColorRampColor() {
        const section = this.sections.fill;
        const fill = this.fill;
        return this.getSampleColorRampColor(section, fill.color);
    }
    getSampleStrokeColorRampColor() {
        const section = this.sections.stroke;
        const stroke = this.stroke;
        return this.getSampleColorRampColor(section, stroke.color);
    }
    getSampleColorRampColor(section, rampColors) {
        const totalColors = rampColors.length;
        if (section.style === "2d" || section.style === "discrete") {
            return rampColors[totalColors - 1];
        }
        return rampColors[Math.floor(totalColors / 2)];
    }
    setSymbolSize(size, emit = true) {
        const { marker, fill, stroke, symbol } = this;
        const mergedMarker = Object.assign(Object.assign({}, marker), { symbol: this.syncSymbolProps(symbol, {
                cimChangeContext: "root",
                symbolState: {
                    marker: Object.assign(Object.assign({}, marker), { size }),
                    fill: fill,
                    stroke: stroke
                }
            }), size });
        this.marker = mergedMarker;
        this.setInternalSymbol(mergedMarker.symbol, emit);
        if (emit) {
            this.arcgisSymbolStylerMarkerChange.emit(normalizeSizeProp(mergedMarker, size));
        }
    }
    render() {
        var _a, _b, _c, _d, _e, _f;
        if (this.preppingEdit) {
            return;
        }
        const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.el);
        const { sections } = this.config;
        const editingCIM = (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(this.activeSymbol);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow", { ref: (el) => {
                this.flowEl = el;
                // we're here after componentDidLoad
                this.checkPopoverMaxHeight();
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { class: {
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__.C.rtl]: dir === "rtl"
            }, dir: dir,
            // omitting `heading` intentionally to allow embedding into existing panels
            //heightScale={this.heightScale}
            key: "main" }, [
            ((_b = (_a = sections.marker) === null || _a === void 0 ? void 0 : _a.parts) === null || _b === void 0 ? void 0 : _b.rotation) === false &&
                ((_d = (_c = sections.marker) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.preview) === false &&
                ((_f = (_e = sections.marker) === null || _e === void 0 ? void 0 : _e.parts) === null || _f === void 0 ? void 0 : _f.size) === false
                ? null
                : this.renderSymbolBlock(),
            !editingCIM && sections.fill ? this.renderFillBlock() : null,
            !editingCIM && sections.stroke ? this.renderStrokeBlock() : null
        ]), this.state === "choosing-symbol" ? this.renderSymbolSelectionPanel() : null)));
    }
    renderSymbolBlock() {
        const { marker: section, stroke: strokeSection } = this.sections;
        const { parts: parts } = section;
        const { editGeometry, symbol } = this;
        const isCIM = (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol);
        const content = [];
        if (parts.preview) {
            content.push({
                content: this.renderSymbolsSelection()
            });
        }
        if (isCIM) {
            if (this.isFillColorRamp()) {
                content.push({
                    content: this.renderColorRampFillBlock(true)
                });
            }
            else if (this.isStrokeColorRamp()) {
                content.push({
                    content: this.renderColorRampStrokeBlock(true)
                });
            }
        }
        if (editGeometry === "point") {
            if (parts.size) {
                content.push({
                    content: isCIM ? this.renderRootCIMSymbolSizeContent() : this.renderSymbolSizeContent()
                });
            }
            if (parts.rotation) {
                content.push({
                    content: this.renderSymbolRotationContent()
                });
            }
        }
        else if (isCIM && strokeSection.extraParts.width) {
            // check if the specific CIM supports an outline width
            if (!(0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.f)(symbol) || ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.f)(symbol) && supportsOutlineWidth(symbol))) {
                content.push({
                    content: this.renderRootCIMSymbolWidthContent()
                });
            }
        }
        if (isCIM) {
            content.push({
                content: this.renderRootCIMSymbolContent(symbol)
            });
        }
        return this.renderSection({
            key: "marker-symbols",
            sectionContent: content
        });
    }
    renderRootCIMSymbolContent(symbol) {
        const layerPanels = this.renderCIMSymbolLayersContent(symbol.data.symbol, "root-symbol");
        if (layerPanels.length > _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.i) {
            return [
                ...layerPanels.slice(0, _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.i),
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.message }, this.mergedStrings.additionalSymbolLayersNotShown.replace("${count}", _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.i.toString()))
            ];
        }
        return layerPanels;
    }
    renderCIMSymbolLayersContent({ symbolLayers }, key, contentOnly = false, parentSymbolLayer) {
        return symbolLayers
            .filter(({ type }) => this.isSupportedSymbolLayerType(type))
            .map((symbolLayer, index) => {
            const contentKey = `${key}__symbol-layers__symbol-layer-${index.toString()}`;
            if (symbolLayer.type === "CIMVectorMarker") {
                return this.renderCIMVectorMarkerSymbolLayerBlocks(symbolLayer, contentKey);
            }
            if (symbolLayer.type === "CIMPictureMarker") {
                return this.renderCIMPictureMarkerSymbolLayerBlock(symbolLayer, contentKey, contentOnly);
            }
            if (symbolLayer.type === "CIMSolidStroke") {
                return this.renderCIMSolidStrokeSymbolLayerBlock(symbolLayer, contentKey, contentOnly, parentSymbolLayer);
            }
            if (symbolLayer.type === "CIMPictureStroke") {
                return this.renderCIMPictureStrokeSymbolLayerBlock(symbolLayer, contentKey, contentOnly);
            }
            if (symbolLayer.type === "CIMSolidFill") {
                return this.renderCIMSolidFillSymbolLayerBlock(symbolLayer, contentKey, contentOnly);
            }
            if (symbolLayer.type === "CIMHatchFill") {
                return this.renderCIMHatchFillSymbolLayerBlocks(symbolLayer, contentKey);
            }
            if (symbolLayer.type === "CIMPictureFill") {
                return this.renderCIMPictureFillSymbolLayerBlock(symbolLayer, contentKey, contentOnly);
            }
        })
            .filter(Boolean)
            .flat();
    }
    renderSymbolsSelection() {
        var _a, _b;
        const activeSymbol = this.previewSymbol;
        const contrastingBackgroundTheme = activeSymbol
            ? _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.previewSymbol2D.getContrastingBackgroundTheme(activeSymbol, 245)
            : "light";
        const isRtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.el) === "rtl";
        const singleSourceAndItemAvailable = ((_a = this.filteredSources) === null || _a === void 0 ? void 0 : _a.length) === 1 && ((_b = this.activeSymbolItems) === null || _b === void 0 ? void 0 : _b.length) === 1;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { style: {
                "--arcgis-symbol-styler-inline-input-trigger-background-color": contrastingBackgroundTheme === "dark" ? "#f3f3f3" : ""
            } }, this.mergedStrings.currentSymbol, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.changeSymbolTrigger, disabled: singleSourceAndItemAvailable, onClick: () => {
                this.state = "choosing-symbol";
            }, type: "button" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.container, tabIndex: 0 }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.symbol }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { symbol: activeSymbol, options: this.editGeometry === "point" ? _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.p : null })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.label }, getSymbolLabel(activeSymbol, this.mergedStrings))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: singleSourceAndItemAvailable ? null : `chevron-${isRtl ? "left" : "right"}`, scale: "s" }))));
    }
    renderSymbolSelectionPanel() {
        const { dir, mergedStrings } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { class: {
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__.C.rtl]: dir === "rtl",
                "symbol-selection-panel": true
            }, dir: dir, heading: mergedStrings.changeSymbol,
            //heightScale={this.heightScale}
            key: "symbol-selection", beforeBack: async () => {
                this.state = "editing";
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-picker", { lang: this.currentLanguage, onArcgisActiveSymbolChange: (event) => {
                const { detail: symbol } = event;
                this.onSymbolSelect(symbol);
                event.stopPropagation();
            }, onArcgisActiveSourceIdChange: ({ detail: activeSourceId }) => {
                this.activeSourceId = activeSourceId;
                this.arcgisSymbolStylerSourceIdChange.emit(activeSourceId);
            }, onArcgisActiveSymbolItemChange: ({ detail: activeSymbolItem }) => {
                this.activeSymbolItem = activeSymbolItem;
            }, onArcgisSymbolSourcesChange: ({ detail: filteredSources }) => (this.filteredSources = filteredSources), onArcgisActiveSourceItemsChange: ({ detail: activeSourceItems }) => (this.activeSymbolItems = activeSourceItems), activeSymbolItem: this.activeSymbolItem, activeSourceId: this.activeSourceId || this.initialSourceId, portal: this.portalOrInterceptor, style: {
                "--scroller-max-height": "var(--symbol-scroller-max-height)"
            }, symbolFilter: this.symbolFilter, symbol: this.activeSymbol }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { width: "full", slot: "footer", onClick: () => this.flowEl.back() }, mergedStrings.done)));
    }
    setInternalSymbol(symbol, emit, symbolSwitch) {
        this.symbol = symbol;
        this.updatePreviewSymbol();
        if (emit) {
            this.emitEdit(symbol, symbolSwitch);
        }
    }
    renderRootCIMSymbolSizeContent() {
        const { sections: { marker: { parts: { size } } }, marker } = this;
        const max = 150;
        const min = 1;
        const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
        const largestSize = _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolSize(this.symbol);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.contentGroup }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.symbolSize, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted, min: min, max: max, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(largestSize)), onValueChange: this.onSymbolSizeChange, withSteppers: !this.narrow, label: this.mergedStrings.symbolSize })), autoSizeAdjust
            ? this.renderAutoAdjust((0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.el), this.marker.autoAdjusted, this.mergedStrings.autoAdjustSize, this.onAutoAdjustSizeChange)
            : null));
    }
    renderRootCIMSymbolWidthContent() {
        var _a;
        // for polygon CIMs it only comes here for an outline
        const symbol = this.symbol;
        const { sections: { stroke: { extraParts: { autoStrokeAdjust } } }, stroke } = this;
        const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.el);
        const width = (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.f)(symbol)
            ? getOutlineWidth(symbol)
            : _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolSize(this.symbol);
        let label = this.getStrokeString("width");
        let min = this.cimStrokeWidthBounds.min;
        let max = this.cimStrokeWidthBounds.max;
        if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.h)(symbol)) {
            // if it has markers we should treat it as size, not width
            const hasMarker = (_a = symbol.data.symbol.symbolLayers) === null || _a === void 0 ? void 0 : _a.some((symbolLayer) => ["CIMVectorMarker", "CIMPictureMarker"].indexOf(symbolLayer.type) > -1);
            if (hasMarker) {
                label = this.mergedStrings.symbolSize;
                min = _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.n;
                max = _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.q;
            }
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.contentGroup }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir }, label, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: autoStrokeAdjust && autoStrokeAdjust !== "editable" && stroke.autoAdjusted, min: min, max: max, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(width)), onValueChange: this.onStrokeWidthChange, withSteppers: !this.narrow, label: label })), autoStrokeAdjust
            ? this.renderAutoAdjust(dir, this.stroke.autoAdjusted, this.mergedStrings.autoAdjustStroke, this.onAutoAdjustStrokeChange)
            : null));
    }
    renderSymbolSizeContent() {
        const { sections: { marker: { parts: { size } } }, marker } = this;
        const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.el);
        const max = 150;
        const min = 1;
        const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.contentGroup }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.symbolSize, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted, min: min, max: max, step: 1, unitsLabel: this.mergedStrings.px, value: marker.size, onValueChange: this.onSymbolSizeChange, withSteppers: !this.narrow, label: this.mergedStrings.symbolSize })), autoSizeAdjust
            ? this.renderAutoAdjust(dir, marker.autoAdjusted, this.mergedStrings.autoAdjustSize, this.onAutoAdjustSizeChange)
            : null));
    }
    renderAutoAdjust(dir, adjusted, label, changeHandler) {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.autoAdjustLabel, dir: dir, layout: "inline", key: "auto-adjust" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { checked: adjusted, class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.autoAdjustCheckbox, onCalciteCheckboxChange: changeHandler }), label));
    }
    renderSymbolRotationContent() {
        const { marker, mergedStrings } = this;
        const max = 360;
        const min = 0;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.rotation, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: min, max: max, step: 1, unitsLabel: "\u00BA", flipLabels: this.dir === "rtl", value: marker.angle, onValueChange: this.onSymbolRotationChange, withSteppers: !this.narrow, label: mergedStrings.rotation })));
    }
    renderFillBlock() {
        const { fill } = this.config.sections;
        if (fill.type === "color") {
            return this.renderColorFillBlock();
        }
        return this.renderColorRampFillBlock();
    }
    renderColorFillBlock() {
        const section = this.sections.fill;
        const { parts } = section;
        const content = [];
        if (parts.suggestedColors || parts.customColor) {
            content.push({
                content: this.renderFillColorContent()
            });
        }
        if (parts.transparency) {
            content.push({
                content: ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: !section.enabled }, this.renderColorFillTransparencyContent(this.mergedStrings.fillTransparency, !section.enabled)))
            });
        }
        return this.renderSection({
            key: "color-fill",
            disabled: section.optional === "non-editable" ||
                this.hasActivePictureMarkerSymbol() ||
                this.hasActiveLineOnlySimpleMarkerSymbol(),
            sectionContent: content
        });
    }
    toColorPickerValue(color) {
        if (!color || (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(color)) {
            return null;
        }
        return color.toHex();
    }
    renderFillColorContent() {
        const section = this.sections.fill;
        const color = section.enabled ? this.toColorPickerValue(this.fill.color) : null;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillColor, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: color,
            //compact={this.narrow}
            clearable: section.optional !== false, onArcgisColorInputChange: (event) => {
                const selectedColor = event.currentTarget.color;
                if (!selectedColor) {
                    this.onFillEnabledChange(false);
                    // no updates to color needed
                    return;
                }
                if (!section.enabled) {
                    this.onFillEnabledChange(true);
                }
                const color = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(selectedColor);
                const { color: currentColor } = this.fill;
                const mergedColor = adjustTransparencyIfNeeded(currentColor, Object.assign(Object.assign(Object.assign({}, currentColor), color), { a: currentColor.a }));
                const mergedFill = {
                    color: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(mergedColor)
                };
                this.fill = mergedFill;
                this.arcgisSymbolStylerFillChange.emit(mergedFill);
                this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
                event.stopPropagation();
            }, popoverProps: this.popoverProps, storageId: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef })));
    }
    getStrokeString(prop) {
        return this.mergedStrings[this.editGeometry === "line" ? prop : `stroke${capitalize(prop)}`];
    }
    isSupportedSymbolLayerType(type) {
        return (type === "CIMVectorMarker" ||
            type === "CIMSolidFill" ||
            type === "CIMSolidStroke" ||
            type === "CIMHatchFill" ||
            type === "CIMPictureFill" ||
            type === "CIMPictureStroke" ||
            type === "CIMPictureMarker");
    }
    getSymbolLayerPreviewSymbol(symbolLayer, geometryType) {
        var _a;
        const symbolProps = {
            data: {
                type: "CIMSymbolReference",
                symbol: {
                    type: geometryType === "point"
                        ? "CIMPointSymbol"
                        : geometryType === "line"
                            ? "CIMLineSymbol"
                            : "CIMPolygonSymbol",
                    symbolLayers: [symbolLayer]
                }
            }
        };
        if (symbolLayer.type === "CIMVectorMarker") {
            symbolProps.data.symbol.angle = (_a = symbolLayer.rotation) !== null && _a !== void 0 ? _a : 0;
        }
        return new _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.CIMSymbol(symbolProps);
    }
    renderCIMVectorMarkerSymbolLayerBlocks(symbolLayer, key) {
        if (this.mode === "minimal") {
            return null;
        }
        const { sections: { marker: { parts: { size } }, stroke: { extraParts: { autoStrokeAdjust } } }, marker, mergedStrings } = this;
        const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
        const updateTargetSymbol = this.getSymbolLayerPreviewSymbol(symbolLayer, "point");
        const symbolSize = _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolSize(updateTargetSymbol);
        const symbolRotation = _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolRotation(updateTargetSymbol, true);
        const colorContext = getChildSymbolLayerColorContext(symbolLayer);
        const fillAndStrokeSections = [];
        if (colorContext.includes("fill") && (!this.isFillColorRamp() || symbolLayer.colorLocked)) {
            const fillColor = getVectorMarkerColor(symbolLayer, "fill");
            const fillContent = [
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "fill-color" }, colorContext.length === 1 ? mergedStrings.color : mergedStrings.fillColor, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(fillColor),
                    //compact={this.narrow}
                    clearable: true, onArcgisColorInputChange: (event) => {
                        const color = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(event.currentTarget.color);
                        if (!(0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(color) && !(0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(fillColor)) {
                            color.a = fillColor.a;
                        }
                        updateSymbolLayerColor(symbolLayer, color, "fill");
                        this.setInternalSymbol(this.symbol, true);
                        event.stopPropagation();
                    }, popoverProps: this.popoverProps, storageId: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))),
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "fill-transparency" }, colorContext.length === 1 ? mergedStrings.transparency : mergedStrings.fillTransparency, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", flipLabels: this.percentLabelFlip, value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)(fillColor.a), onValueChange: (transparency) => {
                        const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(transparency);
                        const color = fillColor.clone();
                        color.a = alpha;
                        updateSymbolLayerColor(symbolLayer, color, "fill");
                        this.setInternalSymbol(this.symbol, true);
                    }, withSteppers: !this.narrow, label: colorContext.length === 1
                        ? mergedStrings.transparency
                        : mergedStrings.fillTransparency }))
            ];
            fillAndStrokeSections.push(fillContent);
        }
        if (colorContext.includes("stroke")) {
            const strokeColor = getVectorMarkerColor(symbolLayer, "stroke");
            const strokeWidth = getVectorMarkerSize(symbolLayer, "stroke");
            const strokeContent = [
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "stroke-color" }, colorContext.length === 1 ? mergedStrings.color : mergedStrings.strokeColor, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(strokeColor),
                    //compact={this.narrow}
                    clearable: true, onArcgisColorInputChange: (event) => {
                        const color = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(event.currentTarget.color);
                        if (!(0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(color) && !(0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(strokeColor)) {
                            color.a = strokeColor.a;
                        }
                        updateSymbolLayerColor(symbolLayer, color, "stroke");
                        this.setInternalSymbol(this.symbol, true);
                        event.stopPropagation();
                    }, popoverProps: this.popoverProps, storageId: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))),
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "stroke-transparency" }, colorContext.length === 1
                    ? mergedStrings.transparency
                    : mergedStrings.strokeTransparency, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", flipLabels: this.percentLabelFlip, value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)(strokeColor.a), onValueChange: (transparency) => {
                        const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(transparency);
                        const color = strokeColor.clone();
                        color.a = alpha;
                        updateSymbolLayerColor(symbolLayer, color, "stroke");
                        this.setInternalSymbol(this.symbol, true);
                    }, withSteppers: !this.narrow, label: colorContext.length === 1
                        ? mergedStrings.transparency
                        : mergedStrings.strokeTransparency })),
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "stroke-width" }, colorContext.length === 1 ? mergedStrings.width : mergedStrings.strokeWidth, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: autoStrokeAdjust && autoStrokeAdjust !== "editable" && this.stroke.autoAdjusted, min: this.cimStrokeWidthBounds.min, max: this.cimStrokeWidthBounds.max, step: 1, unitsLabel: mergedStrings.px, value: normalizePx(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(strokeWidth)), onValueChange: (width) => {
                        updateSymbolLayerSize(symbolLayer, normalizePt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(width)), "stroke");
                        this.setInternalSymbol(this.symbol, true);
                    }, withSteppers: !this.narrow, label: colorContext.length === 1 ? mergedStrings.width : mergedStrings.strokeWidth }))
            ];
            fillAndStrokeSections.push(strokeContent);
        }
        const content = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.contentGroup, key: `${key}__vector-marker-symbol-layer` }, [...fillAndStrokeSections], (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.symbolSize, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.n, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.q, step: 1, unitsLabel: mergedStrings.px, value: normalizePx(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(symbolSize)), onValueChange: (size) => {
                this.setMarkerSymbolLayerSize(updateTargetSymbol, size);
                this.setInternalSymbol(this.symbol, true);
            }, withSteppers: !this.narrow, label: mergedStrings.symbolSize })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.rotation, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.r, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.l, step: 1, unitsLabel: "\u00BA", flipLabels: this.dir === "rtl", value: normalizePxOrPt(symbolRotation), onValueChange: (rotation) => {
                _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolRotation(updateTargetSymbol, normalizePxOrPt(rotation), true);
                this.setInternalSymbol(this.symbol, true);
            }, withSteppers: !this.narrow, label: mergedStrings.rotation })), this.renderCIMMarkerPlacementSection(symbolLayer)));
        const symbolLayerPreview = this.getSymbolLayerPreviewSymbol(this.sanitizePointPreviewSymbolLayer(symbolLayer), "point");
        return this.renderBlock({
            icon: ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__symbol-layer-preview`, symbol: symbolLayerPreview, options: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.p, slot: "icon" })),
            key: `${key}__symbol-layer`,
            heading: mergedStrings.vectorMarker,
            content
        });
    }
    setMarkerSymbolLayerSize(symbol, size) {
        if ((0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.j)(this.activeSymbol)) {
            symbol.data.symbol.symbolLayers[0].size = normalizePt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(size));
        }
        else {
            _symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.scaleCIMSymbolTo(symbol, normalizePt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(size)));
        }
    }
    renderCIMSolidFillSymbolLayerBlock(symbolLayer, key, contentOnly = false) {
        if (this.mode === "minimal") {
            return null;
        }
        const fillColor = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(symbolLayer.color, true);
        const noFillColor = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(fillColor);
        let colorContent = null;
        let transparencyContent = null;
        if (!this.isFillColorRamp() || symbolLayer.colorLocked) {
            colorContent = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillColor, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(fillColor),
                //compact={this.narrow}
                clearable: true, onArcgisColorInputChange: (event) => {
                    const color = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(event.currentTarget.color);
                    if (!(0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(color) && !noFillColor) {
                        color.a = fillColor.a;
                    }
                    symbolLayer.color = color.toJSON();
                    this.setInternalSymbol(this.symbol, true);
                    event.stopPropagation();
                }, popoverProps: this.popoverProps, storageId: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))));
            transparencyContent = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillTransparency, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)(fillColor.a), disabled: noFillColor, onValueChange: (transparency) => {
                    const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(transparency);
                    const color = fillColor.clone();
                    color.a = alpha;
                    symbolLayer.color = color.toJSON();
                    this.setInternalSymbol(this.symbol, true);
                }, withSteppers: !this.narrow, label: this.mergedStrings.fillTransparency })));
        }
        const content = colorContent || transparencyContent ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, key: `${key}__solid-fill-symbol-layer-content` }, colorContent, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: noFillColor }, transparencyContent))) : ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.emptySymbolLayerMsg));
        if (contentOnly) {
            return content;
        }
        const symbolLayerPreview = this.getSymbolLayerPreviewSymbol(symbolLayer, "polygon");
        return this.renderBlock({
            icon: ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__solid-fill-symbol-layer-preview`, symbol: symbolLayerPreview, slot: "icon" })),
            heading: this.mergedStrings.solidFill,
            key: `${key}__solid-fill-symbol-layer`,
            content
        });
    }
    renderCIMSolidStrokeSymbolLayerBlock(symbolLayer, key, contentOnly = false, parentSymbolLayer) {
        if (this.mode === "minimal") {
            return null;
        }
        const strokeColor = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(symbolLayer.color, true);
        const withinHatchFillSymbolLayer = (parentSymbolLayer === null || parentSymbolLayer === void 0 ? void 0 : parentSymbolLayer.type) === "CIMHatchFill";
        const overriddenByColorRamp = withinHatchFillSymbolLayer && this.isFillColorRamp();
        const autoStrokeAdjust = this.sections.stroke.extraParts.autoStrokeAdjust;
        const noStrokeColor = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(strokeColor);
        let colorContent = null;
        let transparencyContent = null;
        if (!this.isStrokeColorRamp() || symbolLayer.colorLocked) {
            colorContent = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "stroke-color" }, contentOnly ? this.mergedStrings.strokeColor : this.mergedStrings.color, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(strokeColor),
                //compact={this.narrow}
                clearable: true, onArcgisColorInputChange: (event) => {
                    const color = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(event.currentTarget.color);
                    if (!(0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(color) && !noStrokeColor) {
                        color.a = strokeColor.a;
                    }
                    symbolLayer.color = color.toJSON();
                    this.setInternalSymbol(this.symbol, true);
                    event.stopPropagation();
                }, popoverProps: this.popoverProps, storageId: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))));
            transparencyContent = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "stroke-transparency" }, contentOnly ? this.mergedStrings.strokeTransparency : this.mergedStrings.transparency, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)(strokeColor.a), disabled: noStrokeColor, onValueChange: (transparency) => {
                    const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(transparency);
                    const color = strokeColor.clone();
                    color.a = alpha;
                    symbolLayer.color = color.toJSON();
                    this.setInternalSymbol(this.symbol, true);
                }, withSteppers: !this.narrow, label: contentOnly ? this.mergedStrings.strokeTransparency : this.mergedStrings.transparency })));
        }
        const content = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, key: `${key}__solid-stroke-symbol-layer-content` }, overriddenByColorRamp ? null : colorContent, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: noStrokeColor }, overriddenByColorRamp ? null : transparencyContent, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, contentOnly ? this.mergedStrings.strokeWidth : this.mergedStrings.width, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: noStrokeColor ||
                (autoStrokeAdjust && autoStrokeAdjust !== "editable" && this.stroke.autoAdjusted), min: this.cimStrokeWidthBounds.min, max: this.cimStrokeWidthBounds.max, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(symbolLayer.width)), onValueChange: (width) => {
                symbolLayer.width = normalizePt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(width));
                this.setInternalSymbol(this.symbol, true);
            }, withSteppers: !this.narrow, label: contentOnly ? this.mergedStrings.strokeWidth : this.mergedStrings.width }))), withinHatchFillSymbolLayer
            ? this.renderCIMHatchFillPatternSection(parentSymbolLayer)
            : null));
        if (contentOnly) {
            return content;
        }
        const symbolLayerPreview = withinHatchFillSymbolLayer
            ? this.getSymbolLayerPreviewSymbol(Object.assign(Object.assign({}, parentSymbolLayer), { lineSymbol: {
                    type: "CIMLineSymbol",
                    symbolLayers: [symbolLayer]
                } }), "polygon")
            : this.getSymbolLayerPreviewSymbol(symbolLayer, "line");
        return this.renderBlock({
            icon: ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__solid-stroke-symbol-layer-preview`, symbol: symbolLayerPreview, slot: "icon" })),
            heading: withinHatchFillSymbolLayer
                ? this.mergedStrings.hatchFill
                : this.mergedStrings.solidStroke,
            key: `${key}__solid-stroke-symbol-layer`,
            content
        });
    }
    renderCIMHatchFillSymbolLayerBlocks(symbolLayer, key) {
        return this.renderCIMSymbolLayersContent(symbolLayer.lineSymbol, `${key}__hatch-symbol-fill-symbol-layers`, false, symbolLayer).flat();
    }
    renderCIMHatchFillPatternSection(symbolLayer) {
        var _a, _b, _c;
        const { mergedStrings } = this;
        const fillOffset = (_a = symbolLayer.offsetX) !== null && _a !== void 0 ? _a : 0; // we apply offset uniformly, so we use take X
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block-section", { key: "hatch-fill-pattern", text: mergedStrings.pattern }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.rotation, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.dir === "rtl", max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.l, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.r, onValueChange: (rotation) => {
                symbolLayer.rotation = Math.abs(rotation);
                this.setInternalSymbol(this.symbol, true);
            }, step: 1, unitsLabel: "\u00BA", value: (_b = symbolLayer.rotation) !== null && _b !== void 0 ? _b : 0, withSteppers: !this.narrow, label: mergedStrings.rotation })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.separation, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.dir === "rtl", max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.v, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.w, onValueChange: (separation) => {
                symbolLayer.separation = separation;
                this.setInternalSymbol(this.symbol, true);
            }, step: 1, value: (_c = symbolLayer.separation) !== null && _c !== void 0 ? _c : 0, unitsLabel: mergedStrings.px, withSteppers: !this.narrow, label: mergedStrings.separation })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.offset, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.dir === "rtl", max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.t, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.u, onValueChange: (offset) => {
                symbolLayer.offsetX = offset;
                symbolLayer.offsetY = offset;
                this.setInternalSymbol(this.symbol, true);
            }, step: 1, value: fillOffset, unitsLabel: mergedStrings.px, withSteppers: !this.narrow, label: mergedStrings.offset }))));
    }
    renderCIMPictureMarkerSymbolLayerBlock(symbolLayer, key, contentOnly = false) {
        if (this.mode === "minimal") {
            return null;
        }
        const tintColor = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(symbolLayer.tintColor, true);
        const { sections: { marker: { parts: { size } } }, marker } = this;
        const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
        const updateTargetSymbol = this.getSymbolLayerPreviewSymbol(symbolLayer, "point");
        const noTintColor = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(tintColor);
        const content = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: `${key}__picture-marker-symbol-layer` }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, key: `${key}__picture-marker-symbol-layer-content` }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillColor, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(tintColor),
            //compact={this.narrow}
            clearable: true, onArcgisColorInputChange: (event) => {
                const color = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(event.currentTarget.color);
                if (!(0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(color) && !noTintColor) {
                    color.a = tintColor.a;
                }
                symbolLayer.tintColor = color.toJSON();
                this.setInternalSymbol(this.symbol, true);
                event.stopPropagation();
            }, popoverProps: this.popoverProps, storageId: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: noTintColor }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillTransparency, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)(tintColor.a), disabled: noTintColor, onValueChange: (transparency) => {
                const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(transparency);
                const color = tintColor.clone();
                color.a = alpha;
                symbolLayer.tintColor = color.toJSON();
                this.setInternalSymbol(this.symbol, true);
            }, withSteppers: !this.narrow, label: this.mergedStrings.fillTransparency })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.symbolSize, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: noTintColor ||
                (autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted), min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.n, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.q, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(symbolLayer.size)), onValueChange: (size) => {
                this.setMarkerSymbolLayerSize(updateTargetSymbol, size);
                this.setInternalSymbol(this.symbol, true);
            }, withSteppers: !this.narrow, label: this.mergedStrings.symbolSize })))), this.renderCIMMarkerPlacementSection(symbolLayer), this.renderCIMPictureMarkerAnimationSection(symbolLayer)));
        if (contentOnly) {
            return content;
        }
        const symbolLayerPreview = this.getSymbolLayerPreviewSymbol(this.sanitizePointPreviewSymbolLayer(symbolLayer), "point");
        return this.renderBlock({
            icon: ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__solid-fill-symbol-layer-preview`, symbol: symbolLayerPreview, options: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.p, slot: "icon" })),
            heading: this.mergedStrings.pictureMarker,
            key: `${key}__picture-marker-symbol-layer`,
            content
        });
    }
    sanitizePointPreviewSymbolLayer(symbolLayer) {
        return Object.assign(Object.assign({}, symbolLayer), {
            // ensure markerPlacement is not set on CIM point symbols symbol layer for proper preview
            markerPlacement: undefined
        });
    }
    renderCIMPictureStrokeSymbolLayerBlock(symbolLayer, key, contentOnly = false) {
        if (this.mode === "minimal") {
            return null;
        }
        const tintColor = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(symbolLayer.tintColor, true);
        const { sections: { marker: { parts: { size } } }, marker } = this;
        const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
        const noTintColor = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(tintColor);
        const content = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, key: `${key}__picture-stroke-symbol-layer-content` }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillColor, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(tintColor),
            //compact={this.narrow}
            clearable: true, onArcgisColorInputChange: (event) => {
                const color = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(event.currentTarget.color);
                if (!(0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(color) && !noTintColor) {
                    color.a = tintColor.a;
                }
                symbolLayer.tintColor = color.toJSON();
                this.setInternalSymbol(this.symbol, true);
                event.stopPropagation();
            }, popoverProps: this.popoverProps, storageId: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: noTintColor }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillTransparency, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)(tintColor.a), disabled: noTintColor, onValueChange: (transparency) => {
                const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(transparency);
                const color = tintColor.clone();
                color.a = alpha;
                symbolLayer.tintColor = color.toJSON();
                this.setInternalSymbol(this.symbol, true);
            }, withSteppers: !this.narrow, label: this.mergedStrings.fillTransparency })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.symbolSize, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: noTintColor ||
                (autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted), min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.n, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.q, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(symbolLayer.width)), onValueChange: (width) => {
                symbolLayer.width = normalizePt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(width));
                this.setInternalSymbol(this.symbol, true);
            }, withSteppers: !this.narrow, label: this.mergedStrings.symbolSize })))));
        if (contentOnly) {
            return content;
        }
        const symbolLayerPreview = this.getSymbolLayerPreviewSymbol(symbolLayer, "line");
        return this.renderBlock({
            icon: ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__picture-stroke-symbol-layer-preview`, symbol: symbolLayerPreview, slot: "icon" })),
            heading: this.mergedStrings.pictureStroke,
            key: `${key}__picture-stroke-symbol-layer`,
            content
        });
    }
    renderCIMPictureFillSymbolLayerBlock(symbolLayer, key, contentOnly = false) {
        if (this.mode === "minimal") {
            return null;
        }
        const tintColor = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(symbolLayer.tintColor, true);
        const { sections: { marker: { parts: { size } } }, marker } = this;
        const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
        const noTintColor = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(tintColor);
        const content = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, key: `${key}__picture-fill-symbol-layer-content` }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillColor, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(tintColor),
            //compact={this.narrow}
            clearable: true, onArcgisColorInputChange: (event) => {
                const color = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(event.currentTarget.color);
                if (!(0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.i)(color) && !noTintColor) {
                    color.a = tintColor.a;
                }
                symbolLayer.tintColor = color.toJSON();
                this.setInternalSymbol(this.symbol, true);
                event.stopPropagation();
            }, popoverProps: this.popoverProps, storageId: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: noTintColor }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillTransparency, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)(tintColor.a), disabled: noTintColor, onValueChange: (transparency) => {
                const alpha = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.t)(transparency);
                const color = tintColor.clone();
                color.a = alpha;
                symbolLayer.tintColor = color.toJSON();
                this.setInternalSymbol(this.symbol, true);
            }, withSteppers: !this.narrow, label: this.mergedStrings.fillTransparency })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.symbolSize, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: noTintColor ||
                (autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted), min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.n, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.q, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(symbolLayer.height)), onValueChange: (height) => {
                symbolLayer.height = normalizePt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(height));
                this.setInternalSymbol(this.symbol, true);
            }, withSteppers: !this.narrow, label: this.mergedStrings.symbolSize })))));
        if (contentOnly) {
            return content;
        }
        const symbolLayerPreview = this.getSymbolLayerPreviewSymbol(symbolLayer, "polygon");
        return this.renderBlock({
            icon: ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__picture-fill-symbol-layer-preview`, symbol: symbolLayerPreview, slot: "icon" })),
            heading: this.mergedStrings.pictureFill,
            key: `${key}__picture-fill-symbol-layer`,
            content
        });
    }
    renderCIMPictureMarkerAnimationSection(symbolLayer) {
        var _a, _b, _c;
        const { dir, mergedStrings } = this;
        const { animatedSymbolProperties } = symbolLayer;
        if (animatedSymbolProperties) {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block-section", { key: "picture-marker-animation", text: mergedStrings.animation }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, layout: "inline" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { checked: animatedSymbolProperties.playAnimation, onCalciteCheckboxChange: (event) => {
                    const { checked } = event.currentTarget;
                    animatedSymbolProperties.playAnimation = checked;
                    this.setInternalSymbol(this.symbol, true);
                } }), mergedStrings.playAnimation), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, layout: "inline" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { checked: animatedSymbolProperties.reverseAnimation, onCalciteCheckboxChange: (event) => {
                    const { checked } = event.currentTarget;
                    animatedSymbolProperties.reverseAnimation = checked;
                    this.setInternalSymbol(this.symbol, true);
                } }), mergedStrings.reverseAnimation), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.startTimeOffset, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control", { onCalciteSegmentedControlChange: (event) => {
                    const value = event.currentTarget.value;
                    animatedSymbolProperties.randomizeStartTime = value === "random";
                    this.setInternalSymbol(this.symbol, true);
                } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "random", checked: animatedSymbolProperties.randomizeStartTime }, mergedStrings.randomized), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "manual", checked: !animatedSymbolProperties.randomizeStartTime }, mergedStrings.manualOffset))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.manualOffset, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: animatedSymbolProperties.randomizeStartTime, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.x, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.y, onValueChange: (offset) => {
                    animatedSymbolProperties.startTimeOffset = offset;
                    this.setInternalSymbol(this.symbol, true);
                }, step: 1, value: (_a = animatedSymbolProperties.startTimeOffset) !== null && _a !== void 0 ? _a : 0, withSteppers: !this.narrow, label: mergedStrings.manualOffset })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.duration, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.x, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.y, onValueChange: (duration) => {
                    animatedSymbolProperties.duration = duration;
                    this.setInternalSymbol(this.symbol, true);
                }, step: 1, value: (_b = animatedSymbolProperties.duration) !== null && _b !== void 0 ? _b : 0, withSteppers: !this.narrow, label: mergedStrings.duration })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.repeatType, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control", { onCalciteSegmentedControlChange: (event) => {
                    const type = event.currentTarget
                        .value;
                    animatedSymbolProperties.repeatType = type;
                    this.setInternalSymbol(this.symbol, true);
                } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "None", checked: animatedSymbolProperties.repeatType === "None" }, mergedStrings.none), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "Loop", checked: animatedSymbolProperties.repeatType === "Loop" }, mergedStrings.loop), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "Oscillate", checked: animatedSymbolProperties.repeatType === "Oscillate" }, mergedStrings.oscillate))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.repeatDelay, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.x, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.y, onValueChange: (delay) => {
                    animatedSymbolProperties.repeatDelay = delay;
                    this.setInternalSymbol(this.symbol, true);
                }, step: 1, value: (_c = animatedSymbolProperties.repeatDelay) !== null && _c !== void 0 ? _c : 0, withSteppers: !this.narrow, label: mergedStrings.repeatDelay }))));
        }
        else {
            return null;
        }
    }
    renderCIMMarkerPlacementSection(symbolLayer) {
        const { dir, mergedStrings } = this;
        const { markerPlacement } = symbolLayer;
        if ((markerPlacement === null || markerPlacement === void 0 ? void 0 : markerPlacement.type) === "CIMMarkerPlacementInsidePolygon" &&
            ((markerPlacement === null || markerPlacement === void 0 ? void 0 : markerPlacement.gridType) === "Random" || (markerPlacement === null || markerPlacement === void 0 ? void 0 : markerPlacement.gridType) === "Fixed")) {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block-section", { key: "marker-placement", text: mergedStrings.markerPlacement }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.gridType, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control", { onCalciteSegmentedControlChange: (event) => {
                    const value = event.currentTarget
                        .value;
                    markerPlacement.gridType = value;
                    this.setInternalSymbol(this.symbol, true);
                } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "Fixed", checked: markerPlacement.gridType === "Fixed" }, mergedStrings.fixed), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "Random", checked: markerPlacement.gridType === "Random" }, mergedStrings.random))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.randomness, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: markerPlacement.gridType === "Fixed", flipLabels: this.percentLabelFlip, max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.B, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.D, onValueChange: (randomness) => {
                    markerPlacement.randomness = randomness;
                    this.setInternalSymbol(this.symbol, true);
                }, step: 1, value: markerPlacement.randomness, unitsLabel: "%", withSteppers: !this.narrow, label: mergedStrings.randomness })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.stepX, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.z, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.A, onValueChange: (step) => {
                    markerPlacement.stepX = normalizePt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(step));
                    this.setInternalSymbol(this.symbol, true);
                }, step: 1, value: normalizePx(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(markerPlacement.stepX)), unitsLabel: mergedStrings.px, withSteppers: !this.narrow, label: mergedStrings.stepX })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.stepY, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { max: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.z, min: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.A, onValueChange: (step) => {
                    markerPlacement.stepY = normalizePt(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(step));
                    this.setInternalSymbol(this.symbol, true);
                }, step: 1, unitsLabel: mergedStrings.px, value: normalizePx(_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(markerPlacement.stepY)), withSteppers: !this.narrow, label: mergedStrings.stepY })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, layout: "inline" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { checked: markerPlacement.shiftOddRows && markerPlacement.gridType === "Fixed", disabled: markerPlacement.gridType === "Random", onCalciteCheckboxChange: (event) => {
                    const { checked } = event.currentTarget;
                    markerPlacement.shiftOddRows = checked;
                    this.setInternalSymbol(this.symbol, true);
                } }), mergedStrings.shiftOddRows)));
        }
        else {
            return null;
        }
    }
    renderColorFillTransparencyContent(label, disabled) {
        var _a;
        const { fill } = this;
        const max = 100;
        const min = 0;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, label, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: min, max: max, step: 1, unitsLabel: "%", value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)((_a = fill.color) === null || _a === void 0 ? void 0 : _a.a), onValueChange: this.onColorFillTransparencyChange, withSteppers: !this.narrow, disabled: disabled, label: label })));
    }
    renderColorRampFillBlock(embedded = false) {
        const section = this.sections.fill;
        const { parts } = section;
        const shouldHide = this.hasActivePictureMarkerSymbol() || this.hasActiveLineOnlySimpleMarkerSymbol();
        if (shouldHide) {
            return null;
        }
        const content = [];
        if (parts.colorRamps) {
            content.push({
                content: this.renderFillColorRampsContent()
            });
        }
        if (parts.transparency) {
            content.push({
                content: this.renderColorRampFillTransparencyContent()
            });
        }
        return this.renderSection({
            key: "color-ramp-fill",
            disabled: section.optional === "non-editable",
            embedded,
            sectionContent: content
        });
    }
    renderFillColorRampsContent() {
        const { style } = this.config.sections.fill;
        const { activeCategory, colorRamps } = this.sections.fill;
        return this.renderRampsContent({
            style,
            activeCategory,
            colorRampStops: this.fill.color,
            colorRamps,
            heading: this.mergedStrings.colors,
            onCategoryChange: this.onFillColorRampCategoryChange,
            isSelected: (colorRamp) => {
                const currentColorRamp = this.fill.color;
                return equal(currentColorRamp, colorRamp.stops, style === "2d");
            },
            onSelect: (event) => {
                const { detail: colorRamp } = event;
                const color = colorRamp.stops.slice();
                const { fill } = this;
                const mergedFill = Object.assign(Object.assign({}, fill), { color });
                this.fill = mergedFill;
                this.tempStrokeColorRampStateStops = color;
                this.arcgisSymbolStylerFillChange.emit(mergedFill);
                this.setInternalSymbol(this.syncSymbolProps(this.symbol, { cimChangeContext: "root" }), true);
                event.stopPropagation();
            },
            onFlip: this.flipFillColorRamps
        });
    }
    renderRampsContent(options) {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, options.heading, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-color-ramp-input", { options: options, strings: this.mergedStrings, popoverProps: this.popoverProps, style: {
                "--scroller-max-height": "var(--ramp-scroller-max-height)"
            }, ref: this.setRampInputRef })));
    }
    renderColorRampFillTransparencyContent() {
        const { fill } = this;
        const max = 100;
        const min = 0;
        const color = fill.color[0];
        // for CIM symbols this might be a rgba array
        const alpha = color.length === 4 ? color[3] / 255 : color.a;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillTransparency, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: min, max: max, step: 1, unitsLabel: "%", value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)(alpha), onValueChange: this.onColorRampFillTransparencyChange, withSteppers: !this.narrow, label: this.mergedStrings.fillTransparency })));
    }
    renderStrokeBlock() {
        const { stroke } = this.config.sections;
        if (stroke.type === "color") {
            return this.renderColorStrokeBlock();
        }
        return this.renderColorRampStrokeBlock();
    }
    renderColorStrokeBlock() {
        const sections = this.sections;
        const section = sections.stroke;
        const { parts } = section;
        const content = [];
        if (parts.suggestedColors || parts.customColor) {
            content.push({
                content: this.renderStrokeColorsContent()
            });
        }
        if (parts.transparency || parts.extra) {
            const innerContent = [];
            if (parts.transparency) {
                innerContent.push(this.showingRampOptionsInStroke()
                    ? this.renderColorRampStrokeTransparencyContent(!section.enabled)
                    : this.renderColorStrokeTransparencyContent(!section.enabled));
            }
            if (parts.extra) {
                innerContent.push(this.renderStrokeExtraContent(!section.enabled));
            }
            content.push({
                content: ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: !section.enabled }, innerContent))
            });
        }
        return this.renderSection({
            key: "color-stroke",
            disabled: section.optional === "non-editable" || this.hasActivePictureMarkerSymbol(),
            sectionContent: content
        });
    }
    renderStrokeColorRampsContent() {
        const { style } = this.config.sections.stroke;
        const { activeCategory, colorRamps } = this.sections.stroke;
        return this.renderRampsContent({
            style,
            activeCategory,
            colorRampStops: this.stroke.color,
            colorRamps,
            heading: this.getStrokeString("color"),
            onCategoryChange: this.onStrokeColorRampCategoryChange,
            isSelected: (colorRamp) => {
                const currentColorRamp = this.stroke.color;
                return equal(currentColorRamp, colorRamp.stops);
            },
            onSelect: (event) => {
                const { detail: colorRamp } = event;
                const color = colorRamp.stops.slice();
                const { stroke } = this;
                const mergedStroke = Object.assign(Object.assign({}, stroke), { color });
                this.stroke = mergedStroke;
                this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
                this.setInternalSymbol(this.syncSymbolProps(this.symbol, { cimChangeContext: "root" }), true);
                event.stopPropagation();
            },
            onFlip: this.flipStrokeColorRamps
        });
    }
    showingRampOptionsInStroke() {
        const strokeSectionConfig = this.config.sections.stroke;
        const shouldShowFillColorsForOutline = isLineOnlySymbol(this.activeSymbol);
        const fillType = this.sections.fill.type;
        return (shouldShowFillColorsForOutline &&
            fillType === "color-ramp" &&
            strokeSectionConfig.type === "color");
    }
    renderStrokeColorsContent() {
        const strokeSection = this.sections.stroke;
        if (this.showingRampOptionsInStroke()) {
            const activeCategory = this.tempStrokeColorRampStateActiveCategory;
            const { style } = this.config.sections.fill;
            const { colorRamps } = this.sections.fill;
            return this.renderRampsContent({
                style,
                activeCategory,
                colorRampStops: this.tempStrokeColorRampStateStops,
                colorRamps,
                heading: this.getStrokeString("color"),
                onCategoryChange: (event) => {
                    const dropdown = event.currentTarget;
                    const activeCategory = dropdown.selectedItems[0].getAttribute("data-value");
                    this.tempStrokeColorRampStateActiveCategory = activeCategory;
                    event.stopPropagation();
                },
                isSelected: (colorRamp) => {
                    const currentColorRampStops = this.tempStrokeColorRampStateStops;
                    return equal(currentColorRampStops, colorRamp.stops);
                },
                onSelect: (event) => {
                    const { detail: colorRamp } = event;
                    const color = colorRamp.stops.slice();
                    const { stroke } = this;
                    const mergedStroke = Object.assign(Object.assign({}, stroke), { color });
                    this.stroke = mergedStroke;
                    this.tempStrokeColorRampStateStops = color;
                    this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
                    this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
                    event.stopPropagation();
                },
                onFlip: this.flipFillColorRamps
            });
        }
        const color = strokeSection.enabled
            ? this.toColorPickerValue(this.stroke.color)
            : null;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.getStrokeString("color"), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: color,
            //compact={this.narrow}
            clearable: strokeSection.optional !== false, onArcgisColorInputChange: (event) => {
                const selectedColor = event.currentTarget.color;
                if (!selectedColor) {
                    this.onStrokeEnabledChange(false);
                    // no updates to color needed
                    return;
                }
                if (!strokeSection.enabled) {
                    this.onStrokeEnabledChange(true);
                }
                const color = (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(selectedColor);
                const currentColor = this.stroke.color;
                const { stroke } = this;
                const mergedStroke = Object.assign(Object.assign({}, stroke), { color: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.c)(adjustTransparencyIfNeeded(currentColor, Object.assign(Object.assign(Object.assign({}, currentColor), color), { a: currentColor.a }))) });
                this.stroke = mergedStroke;
                this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
                this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
                event.stopPropagation();
            }, popoverProps: this.popoverProps, storageId: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef })));
    }
    renderColorStrokeTransparencyContent(disabled) {
        const { stroke } = this;
        const max = 100;
        const min = 0;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.getStrokeString("transparency"), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: min, max: max, step: 1, unitsLabel: "%", value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)(stroke.color.a), onValueChange: this.onColorStrokeTransparencyChange, withSteppers: !this.narrow, disabled: disabled, label: this.getStrokeString("transparency") })));
    }
    renderStrokeExtraContent(disabled) {
        var _a, _b;
        const { sections: { stroke: { extraParts: { arrow, autoStrokeAdjust, style, width } } }, stroke } = this;
        const maxWidthInPx = 18;
        const editingLine = this.editGeometry === "line";
        const editingPolygon = this.editGeometry === "polygon";
        const minWidthInPx = editingLine ? 0.1 : 0;
        const isCim = (0,_symbolUtils_f207d979_js__WEBPACK_IMPORTED_MODULE_2__.i)(this.symbol);
        const canUpdateStyle = !isCim && style && (editingLine || editingPolygon);
        const canUpdateArrows = !isCim && arrow && editingLine;
        const canUpdateWidth = !isCim && width;
        const canUpdateAutoAdjust = !isCim && autoStrokeAdjust;
        const dir = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.el);
        const currentPlacement = toArrowPlacement(stroke.marker);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.contentGroup }, canUpdateWidth ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, key: "width-options" }, this.getStrokeString("width"), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: disabled ||
                (autoStrokeAdjust && autoStrokeAdjust !== "editable" && stroke.autoAdjusted), min: minWidthInPx, max: maxWidthInPx, step: 1, unitsLabel: this.mergedStrings.px, value: stroke.size, onValueChange: this.onStrokeWidthChange, withSteppers: !this.narrow, label: this.getStrokeString("width") }))) : null, canUpdateAutoAdjust
            ? this.renderAutoAdjust(dir, stroke.autoAdjusted, this.mergedStrings.autoAdjustStroke, this.onAutoAdjustStrokeChange)
            : null, canUpdateArrows ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, key: "arrow-options" }, this.mergedStrings.arrow, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown", { class: {
                [_colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdown]: true,
                [_colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.arrowDropdown]: true
            }, onCalciteDropdownSelect: this.onStrokeArrowChange, widthScale: "l", placement: "top-end", "overlay-positioning": (_a = this.popoverProps) === null || _a === void 0 ? void 0 : _a.overlayPositioning, scale: "s" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { role: "button", slot: "trigger", tabIndex: 0 }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { "data-arrow": currentPlacement, class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdownSelected, style: this.getSelectedArrowPatternStyle() }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: "chevron-down", scale: "s" })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-group", null, _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.s.map((arrow) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-item", { selected: arrow === currentPlacement, "data-arrow": arrow }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdownItemContent, "data-arrow": arrow, style: this.getArrowPatternOptionStyle() })))))))) : null, canUpdateStyle ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, key: "pattern-options" }, this.mergedStrings.pattern, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown", { class: {
                [_colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdown]: true,
                [_colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.styleDropdown]: true
            }, onCalciteDropdownSelect: this.onStrokeStyleChange, widthScale: "l", placement: "top-end", "overlay-positioning": (_b = this.popoverProps) === null || _b === void 0 ? void 0 : _b.overlayPositioning, scale: "s" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { role: "button", slot: "trigger", tabIndex: 0 }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdownSelected, style: this.getLinePatternStyle(stroke.style) }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: "chevron-down", scale: "s" })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-group", null, _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.b.map((style) => {
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-item", { selected: style === stroke.style, "data-style": style }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { style: this.getLinePatternStyle(style), class: _colorRampUtils_8d9a3bed_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdownItemContent })));
        }))))) : null));
    }
    renderColorRampStrokeBlock(embedded = false) {
        const section = this.sections.stroke;
        const parts = section.parts;
        const content = [];
        if (parts.colorRamps) {
            content.push({
                content: this.renderStrokeColorRampsContent()
            });
        }
        if (parts.transparency) {
            content.push({
                content: this.renderColorRampStrokeTransparencyContent(section.optional === "non-editable" || this.hasActivePictureMarkerSymbol())
            });
        }
        if (parts.extra) {
            content.push({
                content: this.renderStrokeExtraContent(section.optional === "non-editable" || this.hasActivePictureMarkerSymbol())
            });
        }
        return this.renderSection({
            key: "color-ramp-stroke",
            disabled: section.optional === "non-editable" || this.hasActivePictureMarkerSymbol(),
            embedded,
            sectionContent: content
        });
    }
    renderColorRampStrokeTransparencyContent(disabled) {
        const { stroke } = this;
        const max = 100;
        const min = 0;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.getStrokeString("transparency"), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: min, max: max, step: 1, unitsLabel: "%", value: (0,_color_16791b45_js__WEBPACK_IMPORTED_MODULE_3__.a)(stroke.color[0].a), onValueChange: this.onColorRampStrokeTransparencyChange, withSteppers: !this.narrow, disabled: disabled, label: this.getStrokeString("transparency") })));
    }
    checkPopoverMaxHeight() {
        var _a, _b, _c;
        // if not set by caller then calculate the max height for any popover openend by the styler
        if (this.flowEl && this.popoverProps && (!this.popoverProps.maxHeight || this.autoCalcHeight)) {
            this.autoCalcHeight = true;
            const panelRect = this.flowEl.getBoundingClientRect();
            const windowHeight = window.innerHeight ||
                ((_a = document.documentElement) === null || _a === void 0 ? void 0 : _a.clientHeight) ||
                ((_b = document.body) === null || _b === void 0 ? void 0 : _b.clientHeight) ||
                0;
            const spaceToBottom = windowHeight && (panelRect === null || panelRect === void 0 ? void 0 : panelRect.top) ? windowHeight - panelRect.top - 30 : 0;
            this.popoverProps.maxHeight = `${Math.max(spaceToBottom || panelRect.height, 250) -
                ((_c = this.popoverProps.offsetDistance) !== null && _c !== void 0 ? _c : 0) -
                5}px`;
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "builtInStrings": ["handleStringChanges"],
        "stringOverrides": ["handleStringChanges"]
    }; }
};
ArcGISSymbolStyler.style = arcgisSymbolStylerCss;



//# sourceMappingURL=arcgis-symbol-styler.entry.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWQ5OTQ5Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDZ0k7QUFDK3JCO0FBQ2ptQjtBQUM1RjtBQUMxRDtBQUNnQztBQUN0QjtBQUNyQjtBQUNsQzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsdURBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUV0RCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1zeW1ib2wtc3R5bGVyLmVudHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgaCwgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBhIGFzIGdldEFzc2V0UGF0aCwgSCBhcyBIb3N0LCBkIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcbmltcG9ydCB7IG0gYXMgbWluV2lkdGhJblB4LCBhIGFzIG1heFdpZHRoSW5QeCwgZiBhcyBmbGlwQ29sb3JSYW1wU3RvcHMsIHMgYXMgc3VwcG9ydGVkQXJyb3dzLCBiIGFzIHN1cHBvcnRlZFN0eWxlcywgZCBhcyBkZWZhdWx0VmlzaWJsZU1hcmtlclNlY3Rpb25QYXJ0cywgYyBhcyBkZWZhdWx0VmlzaWJsZUNvbG9yU2VjdGlvblBhcnRzLCBlIGFzIGRlZmF1bHRWaXNpYmxlQ29sb3JSYW1wU2VjdGlvblBhcnRzLCBnIGFzIGRlZmF1bHRWaXNpYmxlRXh0cmFTdHJva2VTZWN0aW9uUGFydHMsIGggYXMgZGVmYXVsdFZpc2libGVTdHJva2VTZWN0aW9uUGFydHMsIGkgYXMgbWF4RGlzcGxheWVkU3ltYm9sTGF5ZXJzLCBDIGFzIENTUywgcCBhcyBwb2ludFByZXZpZXdPcHRpb25zLCBqIGFzIGNvbG9yU3RvcmFnZUlkLCBvIGFzIG9wYWNpdHlNaW4sIGsgYXMgb3BhY2l0eU1heCwgciBhcyByb3RhdGlvbk1pbiwgbCBhcyByb3RhdGlvbk1heCwgbiBhcyBzaXplTWluLCBxIGFzIHNpemVNYXgsIHQgYXMgaGF0Y2hGaWxsT2Zmc2V0TWF4LCB1IGFzIGhhdGNoRmlsbE9mZnNldE1pbiwgdiBhcyBoYXRjaEZpbGxTZXBhcmF0aW9uTWF4LCB3IGFzIGhhdGNoRmlsbFNlcGFyYXRpb25NaW4sIHggYXMgYW5pbWF0aW9uRHVyYXRpb25NYXgsIHkgYXMgYW5pbWF0aW9uRHVyYXRpb25NaW4sIHogYXMgbWFya2VyUGxhY2VtZW50U3RlcE1heCwgQSBhcyBtYXJrZXJQbGFjZW1lbnRTdGVwTWluLCBCIGFzIG1hcmtlclBsYWNlbWVudFJhbmRvbW5lc3NNYXgsIEQgYXMgbWFya2VyUGxhY2VtZW50UmFuZG9tbmVzc01pbiB9IGZyb20gJy4vY29sb3JSYW1wVXRpbHMtOGQ5YTNiZWQuanMnO1xuaW1wb3J0IHsgZSBhcyBlc3JpTW9kdWxlcywgaSBhcyBpc0NJTVN5bWJvbCwgYSBhcyBpc1NNU1N5bWJvbCwgYiBhcyBpc1NGU1N5bWJvbCwgYyBhcyBpc1NMU1N5bWJvbCwgZCBhcyBpc1BNU1N5bWJvbCwgZiBhcyBpc1BvbHlnb25DSU0sIGcgYXMgZ2VvbWV0cnlUeXBlLCBoIGFzIGlzTGluZUNJTSwgaiBhcyBpc1BvaW50Q0lNIH0gZnJvbSAnLi9zeW1ib2xVdGlscy1mMjA3ZDk3OS5qcyc7XG5pbXBvcnQgeyB0IGFzIHRyYW5zcGFyZW5jeVRvQWxwaGEsIGMgYXMgY3JlYXRlLCBpIGFzIGlzTnVsbEVxdWl2YWxlbnRDb2xvciwgYSBhcyBhbHBoYVRvVHJhbnNwYXJlbmN5IH0gZnJvbSAnLi9jb2xvci0xNjc5MWI0NS5qcyc7XG5pbXBvcnQgeyBkIGFzIGRlYm91bmNlLCBjIGFzIHRocm90dGxlIH0gZnJvbSAnLi9mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncywgYSBhcyBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UgfSBmcm9tICcuL2xvY2FsZS0wNTBiNmRiOS5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldEVsZW1lbnREaXIsIEMgYXMgQ1NTX1VUSUxJVFkgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyc7XG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgJy4vZG9tLTRkMzY3Njc3LmpzJztcblxuZnVuY3Rpb24gZXF1YWwocmFtcFN0b3BzMSwgcmFtcFN0b3BzMiwgbWF0Y2hBbHBoYSA9IGZhbHNlLCByZXZlcnNlID0gdHJ1ZSkge1xuICAgIGlmICghcmFtcFN0b3BzMSB8fCAhcmFtcFN0b3BzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVxdWFsTWF0Y2ggPSByYW1wU3RvcHMxLmV2ZXJ5KChjb2xvcjEsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbG9yMiA9IHJhbXBTdG9wczJbaW5kZXhdO1xuICAgICAgICByZXR1cm4gKGNvbG9yMS5yID09PSBjb2xvcjIuciAmJiBjb2xvcjEuZyA9PT0gY29sb3IyLmcgJiYgY29sb3IxLmIgPT09IGNvbG9yMi5iICYmICghbWF0Y2hBbHBoYSB8fCBjb2xvcjEuYSA9PT0gY29sb3IyLmEpKTtcbiAgICB9KTtcbiAgICBpZiAoIXJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFsTWF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBlcXVhbE1hdGNoIHx8IGVxdWFsKHJhbXBTdG9wczEuc2xpY2UoKS5yZXZlcnNlKCksIHJhbXBTdG9wczIsIG1hdGNoQWxwaGEsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gY2ltU3ltYm9sV2Fsa2VyKHN5bWJvbCwgb25WaXNpdCkge1xuICAgIHJldHVybiB2aXNpdChzeW1ib2wsIG9uVmlzaXQpO1xufVxuZnVuY3Rpb24gdmlzaXQobm9kZSwgb25WaXNpdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmlzaXQoY2hpbGQsIG9uVmlzaXQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG9uVmlzaXQobm9kZSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiY2ltXCIpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0KG5vZGUuZGF0YS5zeW1ib2wsIG9uVmlzaXQpO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVN5bWJvbFJlZmVyZW5jZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJDSU1NYXJrZXJHcmFwaGljXCIpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0KG5vZGUuc3ltYm9sLCBvblZpc2l0KTtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1Qb2ludFN5bWJvbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJDSU1Qb2x5Z29uU3ltYm9sXCIgfHwgbm9kZS50eXBlID09PSBcIkNJTUxpbmVTeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gdmlzaXQobm9kZS5zeW1ib2xMYXllcnMsIG9uVmlzaXQpO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTUhhdGNoRmlsbFwiKSB7XG4gICAgICAgIHJldHVybiB2aXNpdChub2RlLmxpbmVTeW1ib2wsIG9uVmlzaXQpO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVZlY3Rvck1hcmtlclwiKSB7XG4gICAgICAgIHJldHVybiB2aXNpdChub2RlLm1hcmtlckdyYXBoaWNzLCBvblZpc2l0KTtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlTWFya2VyXCIgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSBcIkNJTVRleHRTeW1ib2xcIiB8fFxuICAgICAgICBub2RlLnR5cGUgPT09IFwiQ0lNR3JhZGllbnRGaWxsXCIgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSBcIkNJTUdyYWRpZW50U3Ryb2tlXCIgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSBcIkNJTU9iamVjdE1hcmtlcjNEXCIgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSBcIkNJTUNoYXJhY3Rlck1hcmtlclwiIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gXCJDSU1NYXRlcmlhbFN5bWJvbExheWVyXCIgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVTdHJva2VcIiB8fFxuICAgICAgICBub2RlLnR5cGUgPT09IFwiQ0lNUGljdHVyZUZpbGxcIiB8fFxuICAgICAgICBub2RlLnR5cGUgPT09IFwiQ0lNU29saWRGaWxsXCIgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIpIHtcbiAgICAgICAgLyogZW5kIG9mIHRoZSBsaW5lIOKAkyBpbnRlbnRpb25hbCBuby1vcCAqL1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlU3ltYm9sTGF5ZXJDb2xvcihzeW1ib2xMYXllciwgY29sb3IsIGNvbnRleHQpIHtcbiAgICBjb25zdCBjb2xvckpTT04gPSBjb2xvci50b0pTT04oKTtcbiAgICBjaW1TeW1ib2xXYWxrZXIoc3ltYm9sTGF5ZXIsIChub2RlKSA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSBcImZpbGxcIikge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1Tb2xpZEZpbGxcIikge1xuICAgICAgICAgICAgICAgIG5vZGUuY29sb3IgPSBjb2xvckpTT047XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVGaWxsXCIgfHwgbm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVNYXJrZXJcIikge1xuICAgICAgICAgICAgICAgIG5vZGUudGludENvbG9yID0gY29sb3JKU09OO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ID09PSBcInN0cm9rZVwiKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIpIHtcbiAgICAgICAgICAgICAgICBub2RlLmNvbG9yID0gY29sb3JKU09OO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlU3Ryb2tlXCIpIHtcbiAgICAgICAgICAgICAgICBub2RlLnRpbnRDb2xvciA9IGNvbG9ySlNPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q2hpbGRTeW1ib2xMYXllckNvbG9yQ29udGV4dChzeW1ib2xMYXllcikge1xuICAgIGNvbnN0IG9ic2VydmVkVHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgb2JzZXJ2ZWRUeXBlcy5hZGQoY2ltU3ltYm9sV2Fsa2VyKHN5bWJvbExheWVyLCAobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVNvbGlkRmlsbFwiIHx8XG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwiQ0lNSGF0Y2hGaWxsXCIgfHxcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlRmlsbFwiIHx8XG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwiQ0lNUGljdHVyZU1hcmtlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJmaWxsXCI7XG4gICAgICAgIH1cbiAgICB9KSk7XG4gICAgb2JzZXJ2ZWRUeXBlcy5hZGQoY2ltU3ltYm9sV2Fsa2VyKHN5bWJvbExheWVyLCAobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIgfHwgbm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVTdHJva2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwic3Ryb2tlXCI7XG4gICAgICAgIH1cbiAgICB9KSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JzZXJ2ZWRUeXBlcykuZmlsdGVyKEJvb2xlYW4pO1xufVxuZnVuY3Rpb24gZ2V0VmVjdG9yTWFya2VyQ29sb3IodmVjdG9yTWFya2VyU3ltYm9sTGF5ZXIsIGNvbnRleHQpIHtcbiAgICBjb25zdCBjb2xvckpTT04gPSBjaW1TeW1ib2xXYWxrZXIodmVjdG9yTWFya2VyU3ltYm9sTGF5ZXIsIChub2RlKSA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSBcImZpbGxcIikge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1Tb2xpZEZpbGxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlRmlsbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlTWFya2VyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS50aW50Q29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT09IFwic3Ryb2tlXCIpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiQ0lNU29saWRTdHJva2VcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlU3Ryb2tlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS50aW50Q29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXNyaU1vZHVsZXMuQ29sb3IuZnJvbUpTT04oY29sb3JKU09OKTtcbn1cbmZ1bmN0aW9uIGdldFZlY3Rvck1hcmtlclNpemUodmVjdG9yTWFya2VyU3ltYm9sTGF5ZXIsIGNvbnRleHQpIHtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgY2ltU3ltYm9sV2Fsa2VyKHZlY3Rvck1hcmtlclN5bWJvbExheWVyLCAobm9kZSkgPT4ge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiQ0lNVmVjdG9yTWFya2VyXCIgfHwgbm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVNYXJrZXJcIikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnNpemUgPiBzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBub2RlLnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ID09PSBcInN0cm9rZVwiKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIgfHwgbm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVTdHJva2VcIikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLndpZHRoID4gc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gbm9kZS53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN5bWJvbExheWVyU2l6ZShzeW1ib2xMYXllciwgc2l6ZSwgY29udGV4dCkge1xuICAgIGNpbVN5bWJvbFdhbGtlcihzeW1ib2xMYXllciwgKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IFwiZmlsbFwiKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVZlY3Rvck1hcmtlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlTWFya2VyXCIpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ID09PSBcInN0cm9rZVwiKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIgfHwgbm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVTdHJva2VcIikge1xuICAgICAgICAgICAgICAgIG5vZGUud2lkdGggPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRDSU1TdHJva2VXaWR0aEJvdW5kcygpIHtcbiAgICAvLyB3aWR0aCBzaG91bGQgYWx3YXlzIHVzZSBtaW5XaWR0aEluUHgvbWF4V2lkdGhJblB4XG4gICAgLy8gZXhjZXB0IGZvciBDSU1QaWN0dXJlU3Ryb2tlIHRoZXJlIHdlIHRyZWF0IHRoZW0gYXMgbWFya2VyIHNpemVzIHdpdGggc2l6ZU1pbi9zaXplTWF4XG4gICAgcmV0dXJuIHsgbWluOiBtaW5XaWR0aEluUHgsIG1heDogbWF4V2lkdGhJblB4IH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUVkaXRhYmxlKHN5bWJvbCkge1xuICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBcIm1pc3Npbmcgc3ltYm9sIHRvIGVkaXRcIjtcbiAgICB9XG4gICAgaWYgKHN5bWJvbC50eXBlID09PSBcInRleHRcIiB8fCBzeW1ib2wudHlwZSA9PT0gXCJwaWN0dXJlLWZpbGxcIikge1xuICAgICAgICByZXR1cm4gYGVkaXRpbmcgc3ltYm9sIG9mIHR5cGUgJHtzeW1ib2wudHlwZX0gaXMgbm90IHN1cHBvcnRlZGA7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRqdXN0VHJhbnNwYXJlbmN5SWZOZWVkZWQocHJldmlvdXMsIG5leHQpIHtcbiAgICBpZiAocHJldmlvdXMuYSA9PT0gMCkge1xuICAgICAgICBuZXh0LmEgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dDtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzRmlsbChzeW1ib2wpIHtcbiAgICByZXR1cm4gKChpc0NJTVN5bWJvbChzeW1ib2wpICYmIChpc01WQ29tcGF0aWJsZShzeW1ib2wpIHx8IGlzRmlsbE9ubHlDSU0oc3ltYm9sKSkpIHx8XG4gICAgICAgIChpc1NNU1N5bWJvbChzeW1ib2wpICYmICFpc0xpbmVPbmx5U3ltYm9sKHN5bWJvbCkpIHx8XG4gICAgICAgIGlzU0ZTU3ltYm9sKHN5bWJvbCkpO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNTdHJva2Uoc3ltYm9sKSB7XG4gICAgcmV0dXJuICgoaXNDSU1TeW1ib2woc3ltYm9sKSAmJiBpc01WQ29tcGF0aWJsZShzeW1ib2wpKSB8fCBpc1NNU1N5bWJvbChzeW1ib2wpIHx8IGlzU0xTU3ltYm9sKHN5bWJvbCkgfHwgaXNTRlNTeW1ib2woc3ltYm9sKSk7XG59XG5mdW5jdGlvbiBpc0xpbmVPbmx5U3ltYm9sKHN5bWJvbCkge1xuICAgIHJldHVybiAhISgoc3ltYm9sID09PSBudWxsIHx8IHN5bWJvbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ltYm9sLnR5cGUpID09PSBcInNpbXBsZS1tYXJrZXJcIiAmJiAoc3ltYm9sLnN0eWxlID09PSBcInhcIiB8fCBzeW1ib2wuc3R5bGUgPT09IFwiY3Jvc3NcIikpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2l6ZVByb3AocGF5bG9hZFdpdGhTaXplUHJvcCwgbmV3U2l6ZSA9IHBheWxvYWRXaXRoU2l6ZVByb3Auc2l6ZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWRXaXRoU2l6ZVByb3ApLCB7IHNpemU6IG5vcm1hbGl6ZVB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB4MnB0KG5ld1NpemUpKSB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVB4T3JQdChweE9yUHQpIHtcbiAgICBjb25zdCBmcmFjdGlvbkRpZ2l0cyA9IE51bWJlci5pc0ludGVnZXIocHhPclB0KSA/IDAgOiAyO1xuICAgIHJldHVybiBOdW1iZXIocHhPclB0LnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVB4KHB4T3JQdCkge1xuICAgIGNvbnN0IGZyYWN0aW9uRGlnaXRzID0gTnVtYmVyLmlzSW50ZWdlcihweE9yUHQpID8gMCA6IDI7XG4gICAgcmV0dXJuIE51bWJlcihweE9yUHQudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHQocHhPclB0KSB7XG4gICAgY29uc3QgZnJhY3Rpb25EaWdpdHMgPSBOdW1iZXIuaXNJbnRlZ2VyKHB4T3JQdCkgPyAwIDogMztcbiAgICByZXR1cm4gTnVtYmVyKHB4T3JQdC50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSk7XG59XG5mdW5jdGlvbiBwYXJzZVNpemUoc2l6ZSwgZmFsbGJhY2spIHtcbiAgICByZXR1cm4gIWlzTmFOKHNpemUpID8gbm9ybWFsaXplUHhPclB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB0MnB4KHNpemUpKSA6IGZhbGxiYWNrO1xufVxuZnVuY3Rpb24gZ2V0U3ltYm9sUm90YXRpb24oc3ltYm9sKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghc3ltYm9sIHx8IHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1saW5lXCIgfHwgc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLWZpbGxcIikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGlzQ0lNU3ltYm9sKHN5bWJvbCkgPyBlc3JpTW9kdWxlcy5jaW1TeW1ib2xVdGlscy5nZXRDSU1TeW1ib2xSb3RhdGlvbihzeW1ib2wsIHRydWUpIDogKF9hID0gc3ltYm9sLmFuZ2xlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xufVxuZnVuY3Rpb24gaXNDSU1UZXh0U3ltYm9sKHN5bWJvbCkge1xuICAgIHJldHVybiBzeW1ib2wudHlwZSA9PT0gXCJDSU1UZXh0U3ltYm9sXCI7XG59XG5mdW5jdGlvbiBpc01WQ29tcGF0aWJsZShzeW1ib2wpIHtcbiAgICBpZiAoaXNDSU1UZXh0U3ltYm9sKHN5bWJvbC5kYXRhLnN5bWJvbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IHN5bWJvbExheWVycyB9ID0gc3ltYm9sLmRhdGEuc3ltYm9sO1xuICAgIGlmIChzeW1ib2xMYXllcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IFtmaXJzdF0gPSBzeW1ib2xMYXllcnM7XG4gICAgICAgIGlmIChmaXJzdC50eXBlICE9PSBcIkNJTVZlY3Rvck1hcmtlclwiIHx8IGZpcnN0LmNvbG9yTG9ja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtYXJrZXJHcmFwaGljcyB9ID0gZmlyc3Q7XG4gICAgICAgIHJldHVybiAobWFya2VyR3JhcGhpY3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAhaXNDSU1UZXh0U3ltYm9sKG1hcmtlckdyYXBoaWNzWzBdLnN5bWJvbCkgJiZcbiAgICAgICAgICAgIGhhc1VubG9ja2VkRmlsbEFuZFN0cm9rZShtYXJrZXJHcmFwaGljc1swXS5zeW1ib2wuc3ltYm9sTGF5ZXJzKSk7XG4gICAgfVxuICAgIGlmIChzeW1ib2xMYXllcnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGNvbnN0IFtmaXJzdCwgc2Vjb25kXSA9IHN5bWJvbExheWVycztcbiAgICAgICAgaWYgKGZpcnN0LnR5cGUgIT09IFwiQ0lNVmVjdG9yTWFya2VyXCIgfHxcbiAgICAgICAgICAgIHNlY29uZC50eXBlICE9PSBcIkNJTVZlY3Rvck1hcmtlclwiIHx8XG4gICAgICAgICAgICBmaXJzdC5jb2xvckxvY2tlZCB8fFxuICAgICAgICAgICAgZmlyc3Quc2l6ZSA+IHNlY29uZC5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RNYXJrZXJHcmFwaGljcyA9IGZpcnN0Lm1hcmtlckdyYXBoaWNzO1xuICAgICAgICBjb25zdCBzZWNvbmRNYXJrZXJHcmFwaGljcyA9IHNlY29uZC5tYXJrZXJHcmFwaGljcztcbiAgICAgICAgaWYgKGZpcnN0TWFya2VyR3JhcGhpY3MubGVuZ3RoICE9PSAxIHx8IHNlY29uZE1hcmtlckdyYXBoaWNzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt7IHN5bWJvbDogZmlyc3RNYXJrZXJHcmFwaGljU3ltYm9sIH1dID0gZmlyc3RNYXJrZXJHcmFwaGljcztcbiAgICAgICAgY29uc3QgW3sgc3ltYm9sOiBzZWNvbmRNYXJrZXJHcmFwaGljU3ltYm9sIH1dID0gc2Vjb25kTWFya2VyR3JhcGhpY3M7XG4gICAgICAgIHJldHVybiAoZmlyc3RNYXJrZXJHcmFwaGljU3ltYm9sICYmXG4gICAgICAgICAgICBzZWNvbmRNYXJrZXJHcmFwaGljU3ltYm9sICYmXG4gICAgICAgICAgICAhaXNDSU1UZXh0U3ltYm9sKGZpcnN0TWFya2VyR3JhcGhpY1N5bWJvbCkgJiZcbiAgICAgICAgICAgICFpc0NJTVRleHRTeW1ib2woc2Vjb25kTWFya2VyR3JhcGhpY1N5bWJvbCkgJiZcbiAgICAgICAgICAgIGhhc1VubG9ja2VkRmlsbEFuZFN0cm9rZShmaXJzdE1hcmtlckdyYXBoaWNTeW1ib2wuc3ltYm9sTGF5ZXJzKSAmJlxuICAgICAgICAgICAgaGFzRmlsbEFuZFN0cm9rZShzZWNvbmRNYXJrZXJHcmFwaGljU3ltYm9sLnN5bWJvbExheWVycykpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0ZpbGxPbmx5Q0lNKHN5bWJvbCkge1xuICAgIHJldHVybiAhIWVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbENvbG9yKHN5bWJvbCk7XG59XG5mdW5jdGlvbiBoYXNVbmxvY2tlZEZpbGxBbmRTdHJva2Uoc3ltYm9sTGF5ZXJzKSB7XG4gICAgcmV0dXJuIGhhc1VubG9ja2VkRmlsbChzeW1ib2xMYXllcnMpICYmIGhhc1N0cm9rZShzeW1ib2xMYXllcnMpO1xufVxuZnVuY3Rpb24gaGFzRmlsbEFuZFN0cm9rZShzeW1ib2xMYXllcnMpIHtcbiAgICByZXR1cm4gaGFzRmlsbChzeW1ib2xMYXllcnMpICYmIGhhc1N0cm9rZShzeW1ib2xMYXllcnMpO1xufVxuZnVuY3Rpb24gaGFzRmlsbChzeW1ib2xMYXllcnMpIHtcbiAgICByZXR1cm4gISEoc3ltYm9sTGF5ZXJzID09PSBudWxsIHx8IHN5bWJvbExheWVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ltYm9sTGF5ZXJzLmZpbmQoKHsgdHlwZSB9KSA9PiB0eXBlID09PSBcIkNJTVNvbGlkRmlsbFwiKSk7XG59XG5mdW5jdGlvbiBoYXNVbmxvY2tlZEZpbGwoc3ltYm9sTGF5ZXJzKSB7XG4gICAgcmV0dXJuICEhZ2V0VW5sb2NrZWRGaWxsKHN5bWJvbExheWVycyk7XG59XG5mdW5jdGlvbiBnZXRVbmxvY2tlZEZpbGwoc3ltYm9sTGF5ZXJzKSB7XG4gICAgcmV0dXJuIHN5bWJvbExheWVycyA9PT0gbnVsbCB8fCBzeW1ib2xMYXllcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbExheWVycy5maW5kKCh7IHR5cGUsIGNvbG9yTG9ja2VkIH0pID0+IHR5cGUgPT09IFwiQ0lNU29saWRGaWxsXCIgJiYgIWNvbG9yTG9ja2VkKTtcbn1cbmZ1bmN0aW9uIGhhc1N0cm9rZShzeW1ib2xMYXllcnMpIHtcbiAgICByZXR1cm4gISFnZXRTdHJva2Uoc3ltYm9sTGF5ZXJzKTtcbn1cbmZ1bmN0aW9uIGdldFN0cm9rZShzeW1ib2xMYXllcnMpIHtcbiAgICByZXR1cm4gc3ltYm9sTGF5ZXJzID09PSBudWxsIHx8IHN5bWJvbExheWVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ltYm9sTGF5ZXJzLmZpbmQoKHsgdHlwZSB9KSA9PiB0eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIpO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNPdXRsaW5lV2lkdGgoc3ltYm9sKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIENJTSBtdXN0IGhhdmUgYSBzdHJva2VcbiAgICBjb25zdCBoYXNTdHJva2UgPSAoX2EgPSBzeW1ib2wuZGF0YS5zeW1ib2wuc3ltYm9sTGF5ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoeyB0eXBlIH0pID0+IFtcIkNJTVNvbGlkU3Ryb2tlXCIsIFwiQ0lNUGljdHVyZVN0cm9rZVwiXS5pbmRleE9mKHR5cGUpID4gLTEpO1xuICAgIHJldHVybiAhIWhhc1N0cm9rZTtcbn1cbmZ1bmN0aW9uIGdldE91dGxpbmVXaWR0aChzeW1ib2wpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8vIGp1c3QgdGFrZSBmaXJzdCBzdHJva2VcbiAgICBjb25zdCBzdHJva2UgPSAoX2EgPSBzeW1ib2wuZGF0YS5zeW1ib2wuc3ltYm9sTGF5ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoc3ltYm9sTGF5ZXIpID0+IFtcIkNJTVNvbGlkU3Ryb2tlXCIsIFwiQ0lNUGljdHVyZVN0cm9rZVwiXS5pbmRleE9mKHN5bWJvbExheWVyLnR5cGUpID4gLTEpO1xuICAgIHJldHVybiAoX2IgPSBzdHJva2Uud2lkdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG59XG5mdW5jdGlvbiBzZXRPdXRsaW5lV2lkdGgoc3ltYm9sLCB3aWR0aCkge1xuICAgIHZhciBfYTtcbiAgICAvLyBkb24ndCB1c2Ugc2NhbGVDSU1TeW1ib2xUbygpIGJlY2F1c2UgaXQgYWxzbyBzY2FsZXMgbWFya2Vycywgc2VwYXJhdGlvbiwgLi4uIG9mIHRoZSBDSU1cbiAgICAvLyBhcHBseSB3aWR0aCB0byBhbGwgc3Ryb2tlcyBpbnNpZGUgdGhlIENJTVxuICAgIChfYSA9IHN5bWJvbC5kYXRhLnN5bWJvbC5zeW1ib2xMYXllcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChzeW1ib2xMYXllcikgPT4ge1xuICAgICAgICBpZiAoW1wiQ0lNU29saWRTdHJva2VcIiwgXCJDSU1QaWN0dXJlU3Ryb2tlXCJdLmluZGV4T2Yoc3ltYm9sTGF5ZXIudHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgc3ltYm9sTGF5ZXIud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNBcnJvd01hcmtlcihtYXJrZXIpIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkQXJyb3dzLmluY2x1ZGVzKG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5wbGFjZW1lbnQpICYmIChtYXJrZXIgPT09IG51bGwgfHwgbWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXIuc3R5bGUpID09PSBcImFycm93XCI7XG59XG5mdW5jdGlvbiB0b0Fycm93UGxhY2VtZW50KG1hcmtlcikge1xuICAgIGlmICghbWFya2VyKSB7XG4gICAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyb3dNYXJrZXIobWFya2VyKSA/IG1hcmtlci5wbGFjZW1lbnQgOiBcIm5vbmVcIjtcbn1cbmZ1bmN0aW9uIHRvQXJyb3dNYXJrZXIocGxhY2VtZW50KSB7XG4gICAgaWYgKHBsYWNlbWVudCA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6IFwiYXJyb3dcIixcbiAgICAgICAgcGxhY2VtZW50XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFN0YXRlQ29sb3JSYW1wcyhzZWN0aW9uLCBzdHJva2VPckZpbGxQcm9wcykge1xuICAgIGlmIChzZWN0aW9uICYmIHN0cm9rZU9yRmlsbFByb3BzICYmIGhhczJEQ29sb3JSYW1wKHNlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uc1RvTWF0Y2ggPSBnZXRSb3RhdGlvbnNUb01hdGNoU2VsZWN0ZWQoc3Ryb2tlT3JGaWxsUHJvcHMuY29sb3IsIHNlY3Rpb24uY29sb3JSYW1wcyk7XG4gICAgICAgIGlmIChyb3RhdGlvbnNUb01hdGNoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb24uY29sb3JSYW1wcy5tYXAoKHJhbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW1wQ2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCByYW1wKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdGF0aW9uc1RvTWF0Y2g7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByYW1wQ2xvbmUuc3RvcHMgPSBmbGlwQ29sb3JSYW1wU3RvcHMocmFtcENsb25lLnN0b3BzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbXBDbG9uZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWN0aW9uID09PSBudWxsIHx8IHNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlY3Rpb24uY29sb3JSYW1wcztcbn1cbmZ1bmN0aW9uIGhhczJEQ29sb3JSYW1wKHNlY3Rpb24pIHtcbiAgICByZXR1cm4gKHNlY3Rpb24gPT09IG51bGwgfHwgc2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VjdGlvbi50eXBlKSA9PT0gXCJjb2xvci1yYW1wXCIgJiYgc2VjdGlvbi5zdHlsZSA9PT0gXCIyZFwiO1xufVxuZnVuY3Rpb24gZ2V0Um90YXRpb25zVG9NYXRjaFNlbGVjdGVkKHNlbGVjdGVkLCBjb2xvclJhbXBzKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbG9yUmFtcHMubWFwKChyYW1wKSA9PiByYW1wLnN0b3BzKTtcbiAgICBjb25zdCBtYXhSb3RhdGlvbnMgPSA0O1xuICAgIGxldCBzZWxlY3RlZENsb25lID0gc2VsZWN0ZWQubWFwKChjb2xvcikgPT4gY29sb3IuY2xvbmUoKSk7XG4gICAgbGV0IHRvdGFsUm90YXRpb25zT25TZWxlY3RlZCA9IDA7XG4gICAgbGV0IG1hdGNoZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFJvdGF0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gb3B0aW9ucy5zb21lKChvcHRpb24pID0+IGVxdWFsKHNlbGVjdGVkQ2xvbmUsIG9wdGlvbiwgdHJ1ZSwgZmFsc2UpKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGVkQ2xvbmUgPSBmbGlwQ29sb3JSYW1wU3RvcHMoc2VsZWN0ZWRDbG9uZSwgdHJ1ZSk7XG4gICAgICAgIHRvdGFsUm90YXRpb25zT25TZWxlY3RlZCsrO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlZCA/IChtYXhSb3RhdGlvbnMgLSB0b3RhbFJvdGF0aW9uc09uU2VsZWN0ZWQpICUgbWF4Um90YXRpb25zIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNhcGl0YWxpemUodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4dC5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIGdldFN5bWJvbExhYmVsKHN5bWJvbCwgc3RyaW5ncykge1xuICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIiB8fCBzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3MuYmFzaWNQb2ludDtcbiAgICB9XG4gICAgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1saW5lXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3MuYmFzaWNMaW5lO1xuICAgIH1cbiAgICBpZiAoc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLWZpbGxcIikge1xuICAgICAgICByZXR1cm4gc3RyaW5ncy5iYXNpY1BvbHlnb247XG4gICAgfVxuICAgIGlmIChzeW1ib2wuZGF0YS5zeW1ib2wudHlwZSA9PT0gXCJDSU1Qb2ludFN5bWJvbFwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdzLnZlY3RvclBvaW50O1xuICAgIH1cbiAgICBpZiAoc3ltYm9sLmRhdGEuc3ltYm9sLnR5cGUgPT09IFwiQ0lNTGluZVN5bWJvbFwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdzLnZlY3RvckxpbmU7XG4gICAgfVxuICAgIGlmIChzeW1ib2wuZGF0YS5zeW1ib2wudHlwZSA9PT0gXCJDSU1Qb2x5Z29uU3ltYm9sXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3MudmVjdG9yUG9seWdvbjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgc3ltYm9sIHByb3ZpZGVkXCIpO1xufVxuXG5jb25zdCBTZWxlY3RDU1MgPSB7XG4gICAgYmFzZTogXCJzZWxlY3QtbnVtYmVyXCIsXG4gICAgaW5wdXQ6IFwic2VsZWN0LW51bWJlcl9faW5wdXRcIlxufTtcbmNvbnN0IHN0ZXBwZXJDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyA9IChldmVudCkgPT4ge1xuICAgIC8vIHdvcmthcm91bmQgZm9yIGNhbGNpdGUtbGFiZWwgd3JhcHBlZCBTZWxlY3ROdW1iZXIgZm9jdXMgYnVnXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuY29uc3QgU2VsZWN0TnVtYmVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBkaXNhYmxlZCwgZmxpcExhYmVscyA9IGZhbHNlLCBtaW4sIG1heCwgc3RlcCwgdW5pdHNMYWJlbCwgdmFsdWUsIHdpdGhTdGVwcGVycyA9IHRydWUsIGxhYmVsIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogU2VsZWN0Q1NTLmJhc2UgfSxcbiAgICAgICAgaChcImNhbGNpdGUtc2xpZGVyXCIsIHsgZGlzYWJsZWQ6IGRpc2FibGVkLCBtaW46IG1pbiwgbWF4OiBtYXgsIHZhbHVlOiB2YWx1ZSwgc3RlcDogc3RlcCwgb25DYWxjaXRlU2xpZGVySW5wdXQ6IChldmVudCkgPT4gYXBwbHlWYWx1ZU9uQ2hhbmdlKGV2ZW50LnRhcmdldCwgcHJvcHMpIH0pLFxuICAgICAgICBoKFwiY2FsY2l0ZS1pbnB1dFwiLCB7IGNsYXNzOiBTZWxlY3RDU1MuaW5wdXQsIGRpc2FibGVkOiBkaXNhYmxlZCwgbWF4OiBtYXgsIG1pbjogbWluLCBudW1iZXJCdXR0b25UeXBlOiB3aXRoU3RlcHBlcnMgPyBcInZlcnRpY2FsXCIgOiBcIm5vbmVcIiwgcHJlZml4VGV4dDogZmxpcExhYmVscyA/IHVuaXRzTGFiZWwgOiBcIlwiLCBvbkNhbGNpdGVJbnB1dElucHV0OiAoZXZlbnQpID0+IGFwcGx5VmFsdWVPbkNoYW5nZShldmVudC50YXJnZXQsIHByb3BzKSwgb25DbGljazogc3RlcHBlckNsaWNrSGFuZGxlckZvclByb3BlckZvY3VzLCBzY2FsZTogXCJzXCIsIHN0ZXA6IFwiYW55XCIsIHN1ZmZpeFRleHQ6IGZsaXBMYWJlbHMgPyBcIlwiIDogdW5pdHNMYWJlbCwgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IHZhbHVlLnRvU3RyaW5nKCksIGxhYmVsOiBsYWJlbCB9KSkpO1xufTtcbmNvbnN0IGFwcGx5VmFsdWVPbkNoYW5nZSA9IGRlYm91bmNlKChub2RlLCBwcm9wcykgPT4ge1xuICAgIGRlYm91bmNlZEFwcGx5VmFsdWVPbkNoYW5nZShub2RlLCBwcm9wcyk7XG59LCA4MDApO1xuZnVuY3Rpb24gZGVib3VuY2VkQXBwbHlWYWx1ZU9uQ2hhbmdlKG5vZGUsIHByb3BzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBOdW1iZXIobm9kZS52YWx1ZSk7XG4gICAgY29uc3QgY2xhbXBlZCA9IE1hdGgubWluKHByb3BzLm1heCwgTWF0aC5tYXgocHJvcHMubWluLCB2YWx1ZSkpO1xuICAgIGlmICh2YWx1ZSA9PT0gcHJvcHMudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnZhbHVlID0gYCR7Y2xhbXBlZH1gOyAvLyBlbnN1cmUgdmFsdWUgaXMgd2l0aGluIGFsbG93ZWQgcmFuZ2VcbiAgICBwcm9wcy5vblZhbHVlQ2hhbmdlKGNsYW1wZWQpO1xufVxuXG5jb25zdCBhcmNnaXNTeW1ib2xTdHlsZXJDc3MgPSBcIi5zZWxlY3QtbnVtYmVye2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47cG9zaXRpb246cmVsYXRpdmV9LnNlbGVjdC1udW1iZXIgY2FsY2l0ZS1zbGlkZXJ7d2lkdGg6NTAlfS5zZWxlY3QtbnVtYmVyX19pbnB1dHt3aWR0aDo0NSU7Zm9udC1zaXplOnZhcigtLWFyY2dpcy1hcHAtZm9udC1zaXplLTApO2ZvbnQtZmFtaWx5OnZhcigtLWFyY2dpcy1hcHAtZm9udC1mYW1pbHkpfWJ1dHRvbntvdmVyZmxvdzpoaWRkZW47YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hcmNnaXMtc3ltYm9sLXN0eWxlci1pbmxpbmUtaW5wdXQtdHJpZ2dlci1iYWNrZ3JvdW5kLWNvbG9yKTthbGlnbi1pdGVtczpjZW50ZXI7Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czowO2JveC1zaXppbmc6Ym9yZGVyLWJveDtjdXJzb3I6cG9pbnRlcjtkaXNwbGF5OmZsZXg7Zm9udC1mYW1pbHk6aW5oZXJpdDtnYXA6OHB4O2hlaWdodDoxMDAlO2p1c3RpZnktY29udGVudDpjZW50ZXI7b3V0bGluZS1jb2xvcjp0cmFuc3BhcmVudDtvdXRsaW5lLW9mZnNldDowO3BhZGRpbmc6M3B4IDA7cGFkZGluZy1pbmxpbmU6M3B4IDhweDtwb3NpdGlvbjpyZWxhdGl2ZTt0ZXh0LWRlY29yYXRpb246bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7dGV4dC1hbGlnbjpjZW50ZXI7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7d2lkdGg6MTAwJX1idXR0b246Zm9jdXN7b3V0bGluZToycHggc29saWQgdmFyKC0tY2FsY2l0ZS1jb2xvci1icmFuZCk7b3V0bGluZS1vZmZzZXQ6MnB4fWJ1dHRvbjpob3Zlcnt0ZXh0LWRlY29yYXRpb246bm9uZX06aG9zdHttaW4td2lkdGg6MjQwcHg7aGVpZ2h0Oi1tb3otbWluLWNvbnRlbnQ7aGVpZ2h0Om1pbi1jb250ZW50O2Rpc3BsYXk6ZmxleDtmbGV4OjEgMSBhdXRvO2ZsZXgtZmxvdzpjb2x1bW4gbm93cmFwO2FsaWduLWl0ZW1zOnN0cmV0Y2h9Y2FsY2l0ZS1kcm9wZG93bnt3aWR0aDoxMDAlfWNhbGNpdGUtZmxvd3toZWlnaHQ6MTAwJX0uY29sb3ItbG9ja2VkLWluZm97ZGlzcGxheTpmbGV4O2dhcDo0cHg7bWFyZ2luOjhweCAwO2FsaWduLWl0ZW1zOmNlbnRlcn0uY29sb3ItbG9ja2VkLWluZm8gY2FsY2l0ZS1pY29ue2NvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItdGV4dC0zKX0uaWNvbi1kcm9wZG93bntwYWRkaW5nOjAuMjVyZW0gMCAwIDA7d2lkdGg6MTAwJTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWFyY2dpcy1hcHAtYmFja2dyb3VuZCk7aGVpZ2h0OjIuMjVyZW07Ym9yZGVyOjFweCBzb2xpZCAjYTlhOWE5O2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4wNzUpfS5pY29uLWRyb3Bkb3duLS1zZWxlY3RlZHtjdXJzb3I6cG9pbnRlcjttYXJnaW4tbGVmdDoxMnB4O2hlaWdodDozcHg7d2lkdGg6MTAwJX0uaWNvbi1kcm9wZG93biAuaWNvbi1kcm9wZG93bi1pdGVtLWNvbnRlbnQsLmljb24tZHJvcGRvd24tLXNlbGVjdGVke2JhY2tncm91bmQtcG9zaXRpb246Y2VudGVyO2JhY2tncm91bmQtY2xpcDpjb250ZW50LWJveDtiYWNrZ3JvdW5kLW9yaWdpbjpjb250ZW50LWJveDtwYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjB9Lmljb24tZHJvcGRvd24gLmljb24tZHJvcGRvd24taXRlbS1jb250ZW50e2hlaWdodDozMHB4O3dpZHRoOjIwMHB4fS5hcmNnaXMtLXJ0bCAuaWNvbi1kcm9wZG93bi0tc2VsZWN0ZWR7bWFyZ2luLXJpZ2h0OjEycHh9LnN0eWxlLWRyb3Bkb3duIFtzbG90PXRyaWdnZXJde3dpZHRoOjEwMCU7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWl0ZW1zOmNlbnRlcn0uc3R5bGUtZHJvcGRvd24gW3Nsb3Q9dHJpZ2dlcl0gY2FsY2l0ZS1pY29ue21hcmdpbjo4cHg7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5zdHlsZS1kcm9wZG93biBbc2xvdD10cmlnZ2VyXSwuc3R5bGUtZHJvcGRvd24gLmljb24tZHJvcGRvd24taXRlbS1jb250ZW50e2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14fS5hcnJvdy1kcm9wZG93biBbc2xvdD10cmlnZ2VyXXt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjthbGlnbi1pdGVtczpjZW50ZXJ9LmFycm93LWRyb3Bkb3duIFtzbG90PXRyaWdnZXJdIC5pY29uLWRyb3Bkb3duLS1zZWxlY3RlZHtoZWlnaHQ6MzBweDtiYWNrZ3JvdW5kLXNpemU6MTAwJSAxMTlweH0uYXJyb3ctZHJvcGRvd24gW3Nsb3Q9dHJpZ2dlcl0gY2FsY2l0ZS1pY29ue21hcmdpbjo4cHg7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5hcnJvdy1kcm9wZG93biBbc2xvdD10cmlnZ2VyXSAuaWNvbi1kcm9wZG93bi0tc2VsZWN0ZWQsLmFycm93LWRyb3Bkb3duIC5pY29uLWRyb3Bkb3duLWl0ZW0tY29udGVudHtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXR9LmFycm93LWRyb3Bkb3duIFtzbG90PXRyaWdnZXJdIC5pY29uLWRyb3Bkb3duLS1zZWxlY3RlZFtkYXRhLWFycm93PW5vbmVdLC5hcnJvdy1kcm9wZG93biAuaWNvbi1kcm9wZG93bi1pdGVtLWNvbnRlbnRbZGF0YS1hcnJvdz1ub25lXXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgMH0uYXJyb3ctZHJvcGRvd24gW3Nsb3Q9dHJpZ2dlcl0gLmljb24tZHJvcGRvd24tLXNlbGVjdGVkW2RhdGEtYXJyb3c9YmVnaW5dLC5hcnJvdy1kcm9wZG93biAuaWNvbi1kcm9wZG93bi1pdGVtLWNvbnRlbnRbZGF0YS1hcnJvdz1iZWdpbl17YmFja2dyb3VuZC1wb3NpdGlvbjowIC0zMnB4fS5hcnJvdy1kcm9wZG93biBbc2xvdD10cmlnZ2VyXSAuaWNvbi1kcm9wZG93bi0tc2VsZWN0ZWRbZGF0YS1hcnJvdz1lbmRdLC5hcnJvdy1kcm9wZG93biAuaWNvbi1kcm9wZG93bi1pdGVtLWNvbnRlbnRbZGF0YS1hcnJvdz1lbmRde2JhY2tncm91bmQtcG9zaXRpb246MCAtNjFweH0uYXJyb3ctZHJvcGRvd24gW3Nsb3Q9dHJpZ2dlcl0gLmljb24tZHJvcGRvd24tLXNlbGVjdGVkW2RhdGEtYXJyb3c9YmVnaW4tZW5kXSwuYXJyb3ctZHJvcGRvd24gLmljb24tZHJvcGRvd24taXRlbS1jb250ZW50W2RhdGEtYXJyb3c9YmVnaW4tZW5kXXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTkxcHh9LmNvbnRlbnQtZ3JvdXB7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0uY29udGVudC1ncm91cCBsYWJlbHttYXJnaW46OHB4IDAgMCAwfS5jb2xvci1yYW1wLXNlbGVjdGlvbntwYWRkaW5nOjRweH0uc2VjdGlvbi10b2dnbGUtLWRpc2FibGVke3BvaW50ZXItZXZlbnRzOm5vbmU7b3BhY2l0eTowLjV9LnN3YXRjaC1pdGVte2JveC1zaXppbmc6Ym9yZGVyLWJveDtoZWlnaHQ6MTZweDt3aWR0aDoxNnB4O2JvcmRlci1yYWRpdXM6MnB4O2JveC1zaGFkb3c6MCAwIDAgMXB4IHJnYmEoMCwgMCwgMCwgMC4zMyl9Y2FsY2l0ZS1pbnB1dFtkaXNhYmxlZF0gW2RhdGEtYWRqdXN0bWVudF17cG9pbnRlci1ldmVudHM6bm9uZX1hcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uIGNhbGNpdGUtYmxvY2t7b3ZlcmZsb3c6dmlzaWJsZTttYXJnaW46MCAtMTJweH1hcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uIGNhbGNpdGUtYmxvY2tbb3Blbl06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXCI7aGVpZ2h0OjE2cHg7ZGlzcGxheTpmbGV4O2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci1mb3JlZ3JvdW5kLTIpfWFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb24gY2FsY2l0ZS1ibG9jazpudGgtb2YtdHlwZShuKzEpe2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNmMGYwZjB9YXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvbiBjYWxjaXRlLWJsb2NrOmxhc3QtY2hpbGR7Ym9yZGVyLWJvdHRvbTpub25lfWFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb24gY2FsY2l0ZS1ibG9jayBhcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uOm50aC1vZi10eXBlKDIpe21hcmdpbi10b3A6MTJweH1jYWxjaXRlLXBhbmVse292ZXJmbG93OnZpc2libGU7bWFyZ2luLXRvcDowfS5pbnB1dC1jb2xvcntmbGV4LXdyYXA6bm93cmFwO2dhcDo4cHg7YWxpZ24taXRlbXM6Y2VudGVyfWNhbGNpdGUtdG9vbHRpcHttYXgtd2lkdGg6MjUwcHh9Y2FsY2l0ZS10b29sdGlwOm5vdChbb3Blbl0pe3Zpc2liaWxpdHk6aGlkZGVuO3BvaW50ZXItZXZlbnRzOm5vbmV9Lm1lc3NhZ2V7bWFyZ2luLXRvcDo4cHh9YXJjZ2lzLXN5bWJvbC1zdHlsZXItc3ltYm9sLXByZXZpZXdbc2xvdD1pY29uXXt3aWR0aDozMnB4O2hlaWdodDozMnB4O3BhZGRpbmc6MnB4O2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uY29udGFpbmVye2Rpc3BsYXk6ZmxleDtwYWRkaW5nOjhweCAxMnB4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEwMCU7Z2FwOjhweDtmbGV4LWdyb3c6MX0uc3ltYm9se2hlaWdodDozMnB4O2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn0ubGFiZWx7ZmxleC1ncm93OjE7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0fS5jaGFuZ2Utc3ltYm9sLXRyaWdnZXJ7Ym9yZGVyOjFweCBzb2xpZCAjOTQ5NDk0fS5zeW1ib2wtc2VsZWN0aW9uLXBhbmVse21pbi1oZWlnaHQ6bWluKDEwMHZoIC0gMjAwcHgsIDUwMHB4KTtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5zeW1ib2wtc2VsZWN0aW9uLXBhbmVsIGFyY2dpcy1pdGVtLXBhbGV0dGUgLnBhbGV0dGV7Z2FwOjhweH0uc3ltYm9sLXNlbGVjdGlvbi1wYW5lbCBjYWxjaXRlLW5vdGljZTpmaXJzdC1vZi10eXBle21hcmdpbjphdXRvIDAgMCAwfS5zeW1ib2wtc2VsZWN0aW9uLXBhbmVsIGNhbGNpdGUtbGFiZWx7bWFyZ2luOjE2cHggMTJweCAwIDEycHh9LnN5bWJvbC1zZWxlY3Rpb24tcGFuZWwgY2FsY2l0ZS1wYW5lbHtvdmVyZmxvdzp2aXNpYmxlfS5zZWN0aW9ue2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hcmNnaXMtYXBwLWJhY2tncm91bmQpfVwiO1xuXG5jb25zdCBBcmNHSVNTeW1ib2xTdHlsZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlckVkaXQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1N5bWJvbFN0eWxlckVkaXRcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyTWFya2VyQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNTeW1ib2xTdHlsZXJNYXJrZXJDaGFuZ2VcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyRmlsbENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU3ltYm9sU3R5bGVyRmlsbENoYW5nZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJGaWxsRW5hYmxlZENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU3ltYm9sU3R5bGVyRmlsbEVuYWJsZWRDaGFuZ2VcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyU3Ryb2tlQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2VcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyU3Ryb2tlRW5hYmxlZENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU3ltYm9sU3R5bGVyU3Ryb2tlRW5hYmxlZENoYW5nZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTb3VyY2VJZENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU3ltYm9sU3R5bGVyU291cmNlSWRDaGFuZ2VcIiwgNyk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBlbnRyaWVzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5uYXJyb3cgPSBsYXN0LmNvbnRlbnRSZWN0LndpZHRoIDw9IDI3NTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud2luZG93UmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy5jaGVja1BvcG92ZXJNYXhIZWlnaHQoKSk7XG4gICAgICAgIHRoaXMuYXV0b09wZW5GaXJzdEJsb2NrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0b0NhbGNIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2xvcklucHV0RWwgPSBbXTtcbiAgICAgICAgdGhpcy5tYW51YWxCbG9ja09wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVQcmV2aWV3U3ltYm9sID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJldmlldyA9IHRoaXMuc3ltYm9sLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLnN5bmNTeW1ib2xQcm9wcyhwcmV2aWV3LCB7XG4gICAgICAgICAgICAgICAgc3ltYm9sU3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyOiB0aGlzLm1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5maWxsLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuc3Ryb2tlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXdTeW1ib2wgPSBwcmV2aWV3O1xuICAgICAgICB9LCAxNTApO1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vXG4gICAgICAgIC8vICBQcml2YXRlIE1ldGhvZHNcbiAgICAgICAgLy9cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLnNldFJhbXBJbnB1dFJlZiA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yYW1wSW5wdXRFbCA9IGVsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldENvbG9ySW5wdXRSZWYgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JJbnB1dEVsLnB1c2goZWwpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ29sb3JSYW1wRmlsbFRyYW5zcGFyZW5jeUNoYW5nZSA9IChzdHJva2VUcmFuc3BhcmVuY3kpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFscGhhID0gdHJhbnNwYXJlbmN5VG9BbHBoYShzdHJva2VUcmFuc3BhcmVuY3kpO1xuICAgICAgICAgICAgY29uc3QgZmlsbCA9IHRoaXMuZmlsbDtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZEZpbGwgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGZpbGwuY29sb3IubWFwKChjb2xvcikgPT4gY3JlYXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29sb3IpLCB7IGE6IGFscGhhIH0pKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmZpbGwgPSBtZXJnZWRGaWxsO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJGaWxsQ2hhbmdlLmVtaXQobWVyZ2VkRmlsbCk7XG4gICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sLCB7IGNpbUNoYW5nZUNvbnRleHQ6IFwicm9vdFwiIH0pLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkZpbGxDb2xvclJhbXBDYXRlZ29yeUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlQ2F0ZWdvcnkgPSBzZWxlY3Quc2VsZWN0ZWRPcHRpb24udmFsdWU7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5zZWN0aW9ucy5maWxsO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZWN0aW9ucyksIHsgZmlsbDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWN0aW9uKSwgeyBhY3RpdmVDYXRlZ29yeSB9KSB9KTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ29sb3JGaWxsVHJhbnNwYXJlbmN5Q2hhbmdlID0gKHN0cm9rZVRyYW5zcGFyZW5jeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWxwaGEgPSB0cmFuc3BhcmVuY3lUb0FscGhhKHN0cm9rZVRyYW5zcGFyZW5jeSk7XG4gICAgICAgICAgICBjb25zdCB7IGZpbGwgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRGaWxsID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjcmVhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWxsLmNvbG9yKSwgeyBhOiBhbHBoYSB9KSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmZpbGwgPSBtZXJnZWRGaWxsO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJGaWxsQ2hhbmdlLmVtaXQobWVyZ2VkRmlsbCk7XG4gICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sKSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25TdHJva2VDb2xvclJhbXBDYXRlZ29yeUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlQ2F0ZWdvcnkgPSBzZWxlY3Quc2VsZWN0ZWRPcHRpb24udmFsdWU7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5zZWN0aW9ucy5zdHJva2U7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNlY3Rpb25zKSwgeyBzdHJva2U6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VjdGlvbiksIHsgYWN0aXZlQ2F0ZWdvcnkgfSkgfSk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkNvbG9yU3Ryb2tlVHJhbnNwYXJlbmN5Q2hhbmdlID0gKHN0cm9rZVRyYW5zcGFyZW5jeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzdHJva2UgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEoc3Ryb2tlVHJhbnNwYXJlbmN5KTtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFN0cm9rZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3Ryb2tlKSwgeyBjb2xvcjogY3JlYXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3Ryb2tlLmNvbG9yKSwgeyBhOiBhbHBoYSB9KSkgfSk7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZSA9IG1lcmdlZFN0cm9rZTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyU3Ryb2tlQ2hhbmdlLmVtaXQobm9ybWFsaXplU2l6ZVByb3AobWVyZ2VkU3Ryb2tlKSk7XG4gICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sKSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Db2xvclJhbXBTdHJva2VUcmFuc3BhcmVuY3lDaGFuZ2UgPSAoc3Ryb2tlVHJhbnNwYXJlbmN5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEoc3Ryb2tlVHJhbnNwYXJlbmN5KTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yOiBzdHJva2UuY29sb3IubWFwKChjb2xvcikgPT4gY3JlYXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29sb3IpLCB7IGE6IGFscGhhIH0pKSkgfSk7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZSA9IG1lcmdlZFN0cm9rZTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyU3Ryb2tlQ2hhbmdlLmVtaXQobm9ybWFsaXplU2l6ZVByb3AobWVyZ2VkU3Ryb2tlKSk7XG4gICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sLCB7IGNpbUNoYW5nZUNvbnRleHQ6IFwicm9vdFwiIH0pLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblN0cm9rZVN0eWxlQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkcm9wZG93biA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IGRyb3Bkb3duLnNlbGVjdGVkSXRlbXNbMF0uZ2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc3Ryb2tlIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IHN0eWxlIH0pO1xuICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBtZXJnZWRTdHJva2U7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZFN0cm9rZSkpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bmNTeW1ib2xQcm9wcyh0aGlzLnN5bWJvbCksIHRydWUpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25TdHJva2VBcnJvd0NoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZHJvcGRvd24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgYXJyb3cgPSBkcm9wZG93bi5zZWxlY3RlZEl0ZW1zWzBdLmdldEF0dHJpYnV0ZShcImRhdGEtYXJyb3dcIik7XG4gICAgICAgICAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFN0cm9rZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3Ryb2tlKSwgeyBtYXJrZXI6IHRvQXJyb3dNYXJrZXIoYXJyb3cpIH0pO1xuICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBtZXJnZWRTdHJva2U7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZFN0cm9rZSkpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bmNTeW1ib2xQcm9wcyh0aGlzLnN5bWJvbCksIHRydWUpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25TdHJva2VXaWR0aENoYW5nZSA9ICh3aWR0aCkgPT4gdGhpcy5zZXRTdHJva2VXaWR0aCh3aWR0aCk7XG4gICAgICAgIHRoaXMub25BdXRvQWRqdXN0U3Ryb2tlQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGF1dG9BZGp1c3RlZCA9IG5vZGUuY2hlY2tlZDtcbiAgICAgICAgICAgIGNvbnN0IHsgc3Ryb2tlIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGF1dG9BZGp1c3RlZCB9KTtcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlID0gbWVyZ2VkU3Ryb2tlO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2UuZW1pdChub3JtYWxpemVTaXplUHJvcChtZXJnZWRTdHJva2UpKTtcbiAgICAgICAgICAgIC8vIHdlIHNldCB0byBlbWl0IHRoZSBhdXRvLWFkanVzdGVkIGNoYW5nZXMgcmVnYXJkbGVzcyBvZiB0aGUgc3ltYm9sIG5vdCBjaGFuZ2luZ1xuICAgICAgICAgICAgdGhpcy5lbWl0RWRpdCh0aGlzLnN5bWJvbCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zeW5jU3ltYm9sUHJvcHMgPSAoc3ltYm9sLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzeW1ib2xTdGF0ZSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3ltYm9sU3RhdGUpIHx8IHtcbiAgICAgICAgICAgICAgICBtYXJrZXI6IHRoaXMubWFya2VyLFxuICAgICAgICAgICAgICAgIGZpbGw6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuc3Ryb2tlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2ltQ2hhbmdlQ29udGV4dCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaW1DaGFuZ2VDb250ZXh0O1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5VHlwZShzeW1ib2wpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwicG9pbnRcIlxuICAgICAgICAgICAgICAgID8gdGhpcy5zeW5jUG9pbnRTeW1ib2xQcm9wcyhzeW1ib2wsIHN5bWJvbFN0YXRlLCBjaW1DaGFuZ2VDb250ZXh0KVxuICAgICAgICAgICAgICAgIDogdHlwZSA9PT0gXCJsaW5lXCJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnN5bmNMaW5lU3ltYm9sUHJvcHMoc3ltYm9sLCBzeW1ib2xTdGF0ZSwgY2ltQ2hhbmdlQ29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnN5bmNQb2x5Z29uU3ltYm9sUHJvcHMoc3ltYm9sLCBzeW1ib2xTdGF0ZSwgY2ltQ2hhbmdlQ29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3luY1BvaW50U3ltYm9sUHJvcHMgPSAoc3ltYm9sLCB7IGZpbGwsIG1hcmtlciwgc3Ryb2tlIH0sIGNpbUNoYW5nZUNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NyZWVuVXRpbHMgfSA9IGVzcmlNb2R1bGVzO1xuICAgICAgICAgICAgY29uc3QgeyBzZWN0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBub3JtYWxpemVQdChzY3JlZW5VdGlscy5weDJwdChtYXJrZXIuc2l6ZSkpO1xuICAgICAgICAgICAgaWYgKGlzU01TU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lT25seVN5bWJvbCA9IGlzTGluZU9ubHlTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmVPbmx5U3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRmlsbENvbG9yUmFtcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuY29sb3IgPSB0aGlzLmdldFNhbXBsZUZpbGxDb2xvclJhbXBDb2xvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmNvbG9yID0gc2VjdGlvbnMuZmlsbC5lbmFibGVkID8gZmlsbC5jb2xvciA6IGNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sLm91dGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdHJva2VDb2xvclJhbXAoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm91dGxpbmUuY29sb3IgPSB0aGlzLmdldFNhbXBsZVN0cm9rZUNvbG9yUmFtcENvbG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGluZU9ubHlTeW1ib2wgJiYgdGhpcy5pc0ZpbGxDb2xvclJhbXAoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm91dGxpbmUuY29sb3IgPSB0aGlzLmdldFNhbXBsZUZpbGxDb2xvclJhbXBDb2xvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm91dGxpbmUuY29sb3IgPSBzZWN0aW9ucy5zdHJva2UuZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3Ryb2tlLmNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm91dGxpbmUubWFya2VyID0gc3Ryb2tlLm1hcmtlcjtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm91dGxpbmUuc3R5bGUgPSBzdHJva2Uuc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5vdXRsaW5lLndpZHRoID0gbm9ybWFsaXplUHQoc2NyZWVuVXRpbHMucHgycHQoc3Ryb2tlLnNpemUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ltYm9sLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQTVNTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgYXNwZWN0IHJhdGlvXG4gICAgICAgICAgICAgICAgc3ltYm9sLmhlaWdodCA9IE1hdGgucm91bmQoKHN5bWJvbC5oZWlnaHQgLyBzeW1ib2wud2lkdGgpICogc2l6ZSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICAgICAgc3ltYm9sLndpZHRoID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNsb2Nrd2lzZUFuZ2xlID0gTWF0aC5hYnMobWFya2VyLmFuZ2xlKTtcbiAgICAgICAgICAgIGlmIChpc0NJTVN5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSB0b3AtbGV2ZWwgcHJvcHMgYXJlIGFwcGxpZWRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHVzaW5nIHRoZSBvcmlnaW5hbCBzeW1ib2wgZnJvbSBhIHN5bWJvbCBzZXQgd2Ugd2FudCB0byBrZWVwIHRoZXNlIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICBpZiAoW1wicm9vdFwiLCBcIm9yaWdpbmFsLXJvb3RcIl0uaW5kZXhPZihjaW1DaGFuZ2VDb250ZXh0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmFwcGx5Q0lNU3ltYm9sUm90YXRpb24oc3ltYm9sLCBjbG9ja3dpc2VBbmdsZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLnNjYWxlQ0lNU3ltYm9sVG8oc3ltYm9sLCBzaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5kYXRhLnN5bWJvbC5hbmdsZSA9IGNsb2Nrd2lzZUFuZ2xlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ZpbGxDb2xvclJhbXAoKSkge1xuICAgICAgICAgICAgICAgICAgICBlc3JpTW9kdWxlcy5jaW1TeW1ib2xVdGlscy5hcHBseUNJTVN5bWJvbENvbG9yKHN5bWJvbCwgdGhpcy5nZXRTYW1wbGVGaWxsQ29sb3JSYW1wQ29sb3IoKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzVG9Db2xvcjogXCJmaWxsXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdHJva2VDb2xvclJhbXAoKSkge1xuICAgICAgICAgICAgICAgICAgICBlc3JpTW9kdWxlcy5jaW1TeW1ib2xVdGlscy5hcHBseUNJTVN5bWJvbENvbG9yKHN5bWJvbCwgdGhpcy5nZXRTYW1wbGVTdHJva2VDb2xvclJhbXBDb2xvcigpLCB7IGxheWVyc1RvQ29sb3I6IFwib3V0bGluZVwiIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bWJvbC5hbmdsZSA9IGNsb2Nrd2lzZUFuZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zeW5jTGluZVN5bWJvbFByb3BzID0gKHN5bWJvbCwgeyBzdHJva2UgfSwgY2ltQ2hhbmdlQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzY3JlZW5VdGlscyB9ID0gZXNyaU1vZHVsZXM7XG4gICAgICAgICAgICBjb25zdCB7IHNlY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBub3JtYWxpemVQdChzY3JlZW5VdGlscy5weDJwdChzdHJva2Uuc2l6ZSkpO1xuICAgICAgICAgICAgaWYgKGlzU0xTU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0cm9rZUNvbG9yUmFtcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5jb2xvciA9IHRoaXMuZ2V0U2FtcGxlU3Ryb2tlQ29sb3JSYW1wQ29sb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5jb2xvciA9IHNlY3Rpb25zLnN0cm9rZS5lbmFibGVkID8gc3Ryb2tlLmNvbG9yIDogY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3aGVuIHVzaW5nIHRoZSBvcmlnaW5hbCBzeW1ib2wgZnJvbSBhIHN5bWJvbCBzZXQgd2UgZG9uJ3Qgd2FudCB0byBrZWVwIHRoZXNlIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgaWYgKGNpbUNoYW5nZUNvbnRleHQgIT09IFwib3JpZ2luYWwtcm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5tYXJrZXIgPSBzdHJva2UubWFya2VyO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuc3R5bGUgPSBzdHJva2Uuc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ0lNU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHRvcC1sZXZlbCBwcm9wcyBhcmUgYXBwbGllZFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIG9yaWdpbmFsIHN5bWJvbCBmcm9tIGEgc3ltYm9sIHNldCAoXCJvcmlnaW5hbC1yb290XCIpIHdlIGRvbid0IHdhbnQgdG8ga2VlcCB0aGVzZSBzZXR0aW5nc1xuICAgICAgICAgICAgICAgIGlmIChjaW1DaGFuZ2VDb250ZXh0ID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgICAgICAgICBlc3JpTW9kdWxlcy5jaW1TeW1ib2xVdGlscy5zY2FsZUNJTVN5bWJvbFRvKHN5bWJvbCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0cm9rZUNvbG9yUmFtcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmFwcGx5Q0lNU3ltYm9sQ29sb3Ioc3ltYm9sLCB0aGlzLmdldFNhbXBsZVN0cm9rZUNvbG9yUmFtcENvbG9yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3luY1BvbHlnb25TeW1ib2xQcm9wcyA9IChzeW1ib2wsIHsgZmlsbCwgc3Ryb2tlIH0sIGNpbUNoYW5nZUNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NyZWVuVXRpbHMgfSA9IGVzcmlNb2R1bGVzO1xuICAgICAgICAgICAgY29uc3QgeyBzZWN0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gbm9ybWFsaXplUHQoc2NyZWVuVXRpbHMucHgycHQoc3Ryb2tlLnNpemUpKTtcbiAgICAgICAgICAgIGlmIChpc1NGU1N5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNGaWxsQ29sb3JSYW1wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmNvbG9yID0gdGhpcy5nZXRTYW1wbGVGaWxsQ29sb3JSYW1wQ29sb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5jb2xvciA9IHNlY3Rpb25zLmZpbGwuZW5hYmxlZCA/IGZpbGwuY29sb3IgOiBjcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU3Ryb2tlQ29sb3JSYW1wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm91dGxpbmUuY29sb3IgPSB0aGlzLmdldFNhbXBsZVN0cm9rZUNvbG9yUmFtcENvbG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wub3V0bGluZS5jb2xvciA9IHNlY3Rpb25zLnN0cm9rZS5lbmFibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0cm9rZS5jb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIG9yaWdpbmFsIHN5bWJvbCBmcm9tIGEgc3ltYm9sIHNldCB3ZSBkb24ndCB3YW50IHRvIGtlZXAgdGhlc2Ugc2V0dGluZ3NcbiAgICAgICAgICAgICAgICBpZiAoY2ltQ2hhbmdlQ29udGV4dCAhPT0gXCJvcmlnaW5hbC1yb290XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm91dGxpbmUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm91dGxpbmUuc3R5bGUgPSBzdHJva2Uuc3R5bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDSU1TeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgdG9wLWxldmVsIHByb3BzIGFyZSBhcHBsaWVkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNGaWxsQ29sb3JSYW1wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuYXBwbHlDSU1TeW1ib2xDb2xvcihzeW1ib2wsIHRoaXMuZ2V0U2FtcGxlRmlsbENvbG9yUmFtcENvbG9yKCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyc1RvQ29sb3I6IFwiZmlsbFwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3Ryb2tlQ29sb3JSYW1wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuYXBwbHlDSU1TeW1ib2xDb2xvcihzeW1ib2wsIHRoaXMuZ2V0U2FtcGxlU3Ryb2tlQ29sb3JSYW1wQ29sb3IoKSwgeyBsYXllcnNUb0NvbG9yOiBcIm91dGxpbmVcIiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1c2luZyB0aGUgb3JpZ2luYWwgc3ltYm9sIGZyb20gYSBzeW1ib2wgc2V0IChcIm9yaWdpbmFsLXJvb3RcIikgd2UgZG9uJ3Qgd2FudCB0byBrZWVwIHRoZXNlIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgaWYgKGNpbUNoYW5nZUNvbnRleHQgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BvbHlnb25DSU0oc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NhbGVDSU1TeW1ib2xUbygpIGFsc28gc2NhbGVzIG1hcmtlcnMsIHNlcGFyYXRvcnMsIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3V0bGluZVdpZHRoKHN5bWJvbCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuc2NhbGVDSU1TeW1ib2xUbyhzeW1ib2wsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25TdHJva2VFbmFibGVkQ2hhbmdlID0gKGVuYWJsZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VjdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBwcmV2ZW50Q2hhbmdlID0gaXNMaW5lT25seVN5bWJvbCh0aGlzLmFjdGl2ZVN5bWJvbCk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWN0aW9ucyksIHsgc3Ryb2tlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlY3Rpb25zLnN0cm9rZSksIHsgZW5hYmxlZDogcHJldmVudENoYW5nZSA/IHRydWUgOiBlbmFibGVkIH0pIH0pO1xuICAgICAgICAgICAgaWYgKHByZXZlbnRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUVuYWJsZWRDaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgICAgICAgICBzdHJva2U6IG5vcm1hbGl6ZVNpemVQcm9wKHRoaXMuc3Ryb2tlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sKSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25GaWxsRW5hYmxlZENoYW5nZSA9IChlbmFibGVkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGZpbGwsIHNlY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgcHJldmVudENoYW5nZSA9IGlzTGluZU9ubHlTeW1ib2wodGhpcy5hY3RpdmVTeW1ib2wpO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VjdGlvbnMpLCB7IGZpbGw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VjdGlvbnMuZmlsbCksIHsgZW5hYmxlZDogcHJldmVudENoYW5nZSA/IGZhbHNlIDogZW5hYmxlZCB9KSB9KTtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJGaWxsRW5hYmxlZENoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBlbmFibGVkLFxuICAgICAgICAgICAgICAgIGZpbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bmNTeW1ib2xQcm9wcyh0aGlzLnN5bWJvbCksIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQXV0b0FkanVzdFNpemVDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgYXV0b0FkanVzdGVkID0gbm9kZS5jaGVja2VkO1xuICAgICAgICAgICAgY29uc3QgeyBtYXJrZXIgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRNYXJrZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1hcmtlciksIHsgYXV0b0FkanVzdGVkIH0pO1xuICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSBtZXJnZWRNYXJrZXI7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlck1hcmtlckNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZE1hcmtlcikpO1xuICAgICAgICAgICAgLy8gd2Ugc2V0IHRvIGVtaXQgdGhlIGF1dG8tYWRqdXN0ZWQgY2hhbmdlcyByZWdhcmRsZXNzIG9mIHRoZSBzeW1ib2wgbm90IGNoYW5naW5nXG4gICAgICAgICAgICB0aGlzLmVtaXRFZGl0KHRoaXMuc3ltYm9sKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU3ltYm9sU2l6ZUNoYW5nZSA9IChzaXplKSA9PiB0aGlzLnNldFN5bWJvbFNpemUoc2l6ZSk7XG4gICAgICAgIHRoaXMub25TeW1ib2xSb3RhdGlvbkNoYW5nZSA9IChhbmdsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBtYXJrZXIsIGZpbGwsIHN0cm9rZSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZE1hcmtlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFya2VyKSwgeyBhbmdsZSwgc3ltYm9sOiB0aGlzLnN5bmNTeW1ib2xQcm9wcyh0aGlzLnN5bWJvbCwge1xuICAgICAgICAgICAgICAgICAgICBjaW1DaGFuZ2VDb250ZXh0OiBcInJvb3RcIixcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sU3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlcjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYXJrZXIpLCB7IGFuZ2xlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgICAgIHRoaXMubWFya2VyID0gbWVyZ2VkTWFya2VyO1xuICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbChtZXJnZWRNYXJrZXIuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyTWFya2VyQ2hhbmdlLmVtaXQobm9ybWFsaXplU2l6ZVByb3AobWVyZ2VkTWFya2VyKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25TeW1ib2xTZWxlY3QgPSAoc3ltYm9sKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGZpbGwsIG1hcmtlciwgc2VjdGlvbnMsIHN0cm9rZSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRGcm9tUE1TVG9TTVMgPSAoKF9hID0gdGhpcy5hY3RpdmVTeW1ib2wpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJwaWN0dXJlLW1hcmtlclwiICYmIHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1tYXJrZXJcIjtcbiAgICAgICAgICAgIGNvbnN0IGhhZExpbmVPbmx5U3ltYm9sID0gaXNMaW5lT25seVN5bWJvbCh0aGlzLmFjdGl2ZVN5bWJvbCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZExpbmVPbmx5U3ltYm9sID0gaXNMaW5lT25seVN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlZEZyb21MaW5lT25seVNNU1RvTm9uTGluZU9ubHlTTVMgPSBoYWRMaW5lT25seVN5bWJvbCAmJiAhc2VsZWN0ZWRMaW5lT25seVN5bWJvbDtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRGcm9tTm9uTGluZU9ubHlTTVNUb0xpbmVPbmx5U01TID0gIWhhZExpbmVPbmx5U3ltYm9sICYmIHNlbGVjdGVkTGluZU9ubHlTeW1ib2w7XG4gICAgICAgICAgICB0aGlzLmF1dG9PcGVuRmlyc3RCbG9jayA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBmaWxsU3VwcG9ydGVkID0gc3VwcG9ydHNGaWxsKHN5bWJvbCk7XG4gICAgICAgICAgICBjb25zdCBzdHJva2VTdXBwb3J0ZWQgPSBzdXBwb3J0c1N0cm9rZShzeW1ib2wpO1xuICAgICAgICAgICAgY29uc3QgZmlsbFN0cm9rZU92ZXJyaWRlcyA9IHt9O1xuICAgICAgICAgICAgY29uc3Qgc3dpdGNoZWRGcm9tQ0lNVG9Ob25DSU0gPSBpc0NJTVN5bWJvbCh0aGlzLmFjdGl2ZVN5bWJvbCkgJiYgIWlzQ0lNU3ltYm9sKHN5bWJvbCk7XG4gICAgICAgICAgICBpZiAoc3dpdGNoZWRGcm9tQ0lNVG9Ob25DSU0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTTVNTeW1ib2woc3ltYm9sKSB8fCBpc1NGU1N5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxsU3VwcG9ydGVkICYmIHNlY3Rpb25zLmZpbGwudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsU3Ryb2tlT3ZlcnJpZGVzLmZpbGwgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpbGwpLCB7IGNvbG9yOiBzeW1ib2wuY29sb3IuY2xvbmUoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Ryb2tlU3VwcG9ydGVkICYmIHNlY3Rpb25zLnN0cm9rZS50eXBlID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNtc09yU2ZzID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBzbXNPclNmcy5vdXRsaW5lLmNvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZEZyb21Ob25MaW5lT25seVNNU1RvTGluZU9ubHlTTVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgbGluZSBjb2xvciBpcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IuYSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsU3Ryb2tlT3ZlcnJpZGVzLnN0cm9rZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3Ryb2tlKSwgeyBjb2xvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NGU1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlIHdpdGggb3V0bGluZSB3aWR0aCBvZiBuZXcgc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2Uuc2l6ZSA9IHN5bWJvbC5vdXRsaW5lLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuc3Ryb2tlLnN0eWxlID0gc3ltYm9sLm91dGxpbmUuc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTTFNTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Ryb2tlU3VwcG9ydGVkICYmIHNlY3Rpb25zLnN0cm9rZS50eXBlID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNscyA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuc3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IHNpemU6IHNscy53aWR0aCwgY29sb3I6IHNscy5jb2xvci5jbG9uZSgpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDSU1TeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RDb2xvciA9IGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbENvbG9yKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlY3Rpb25zLmZpbGwudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuZmlsbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsbCksIHsgY29sb3I6IHJvb3RDb2xvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2UgPSBPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVkaXRHZW9tZXRyeSA9PT0gXCJwb2ludFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuc3Ryb2tlLnNpemUgPSBub3JtYWxpemVQdChtYXJrZXIuc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZWRpdEdlb21ldHJ5ID09PSBcImxpbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBmaWxsU3Ryb2tlT3ZlcnJpZGVzLnN0cm9rZS5zaXplID0gbm9ybWFsaXplUHQoZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuZ2V0Q0lNU3ltYm9sU2l6ZShzeW1ib2wpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlY3Rpb25zLnN0cm9rZS50eXBlID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2UuY29sb3IgPSByb290Q29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2ltU3Ryb2tlV2lkdGhCb3VuZHMgPSBnZXRDSU1TdHJva2VXaWR0aEJvdW5kcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VjdGlvbnMuZmlsbC50eXBlID09PSBcImNvbG9yLXJhbXBcIiAmJiBzZWN0aW9ucy5zdHJva2UudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTGluZU9ubHlTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGZpbGwgcmFtcCBjYXRlZ29yeSBhbmQgc3RvcmUgc2VsZWN0ZWQgcmFtcCB3aGVuZXZlciBzd2l0Y2hpbmcgdG8gcHVyZS1saW5lIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVtcFN0cm9rZUNvbG9yUmFtcFN0YXRlQWN0aXZlQ2F0ZWdvcnkgPSBzZWN0aW9ucy5maWxsLmFjdGl2ZUNhdGVnb3J5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbXBTdHJva2VDb2xvclJhbXBTdGF0ZVN0b3BzID0gZmlsbC5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZW1wU3Ryb2tlUHJldmlvdXNDb2xvckJlZm9yZUNvbG9yUmFtcFN3aXRjaCA9IHN0cm9rZS5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgY29sb3I6IHRoaXMudGVtcFN0cm9rZUNvbG9yUmFtcFN0YXRlU3RvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZWRGcm9tTGluZU9ubHlTTVNUb05vbkxpbmVPbmx5U01TKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuZmlsbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsbCksIHsgY29sb3I6IHRoaXMudGVtcFN0cm9rZUNvbG9yUmFtcFN0YXRlU3RvcHMgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuc3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yOiB0aGlzLnRlbXBTdHJva2VQcmV2aW91c0NvbG9yQmVmb3JlQ29sb3JSYW1wU3dpdGNoIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbXBTdHJva2VDb2xvclJhbXBTdGF0ZUFjdGl2ZUNhdGVnb3J5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZW1wU3Ryb2tlQ29sb3JSYW1wU3RhdGVTdG9wcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VjdGlvbnMuZmlsbC50eXBlID09PSBcImNvbG9yXCIgJiYgc2VjdGlvbnMuc3Ryb2tlLnR5cGUgPT09IFwiY29sb3ItcmFtcFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRGcm9tTm9uTGluZU9ubHlTTVNUb0xpbmVPbmx5U01TKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbXAgPSBzdHJva2UuY29sb3IubWFwKChjb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGxpbmUgY29sb3IgaXMgdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IuYSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmaWxsU3Ryb2tlT3ZlcnJpZGVzLnN0cm9rZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3Ryb2tlKSwgeyBjb2xvcjogcmFtcCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWN0aW9ucy5maWxsLnR5cGUgPT09IFwiY29sb3JcIiAmJiBzZWN0aW9ucy5zdHJva2UudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRGcm9tTm9uTGluZU9ubHlTTVNUb0xpbmVPbmx5U01TKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gc3Ryb2tlLmNvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkRnJvbU5vbkxpbmVPbmx5U01TVG9MaW5lT25seVNNUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGxpbmUgY29sb3IgaXMgdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IuYSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgY29sb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VjdGlvbnMpLCB7IGZpbGw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VjdGlvbnMuZmlsbCksIHsgb3BlbjogIXNlbGVjdGVkTGluZU9ubHlTeW1ib2wgJiYgc2VjdGlvbnMuZmlsbC5vcGVuLCBlbmFibGVkOiBmaWxsU3VwcG9ydGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXNlbGVjdGVkTGluZU9ubHlTeW1ib2wgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NJTVN5bWJvbChzeW1ib2wpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZyb21MaW5lT25seVNNU1RvTm9uTGluZU9ubHlTTVMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRnJvbVBNU1RvU01TIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbnMuZmlsbC5lbmFibGVkKSB9KSwgc3Ryb2tlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlY3Rpb25zLnN0cm9rZSksIHsgZW5hYmxlZDogc3Ryb2tlU3VwcG9ydGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNDSU1TeW1ib2woc3ltYm9sKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGcm9tTm9uTGluZU9ubHlTTVNUb0xpbmVPbmx5U01TIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN3aXRjaGVkRnJvbUNJTVRvTm9uQ0lNICYmICFzZWxlY3RlZExpbmVPbmx5U3ltYm9sKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGcm9tUE1TVG9TTVMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9ucy5zdHJva2UuZW5hYmxlZCkgfSkgfSk7XG4gICAgICAgICAgICBjb25zdCBmaW5hbEZpbGwgPSAoZmlsbFN0cm9rZU92ZXJyaWRlcy5maWxsIHx8IGZpbGwpO1xuICAgICAgICAgICAgY29uc3QgZmluYWxTdHJva2UgPSAoZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2UgfHwgc3Ryb2tlKTtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZE1hcmtlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFya2VyKSwgeyBzeW1ib2w6IHRoaXMuc3luY1N5bWJvbFByb3BzKHN5bWJvbCwge1xuICAgICAgICAgICAgICAgICAgICBjaW1DaGFuZ2VDb250ZXh0OiBcIm9yaWdpbmFsLXJvb3RcIixcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sU3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZpbmFsRmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogZmluYWxTdHJva2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICAgICAgdGhpcy5maWxsID0gZmluYWxGaWxsO1xuICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBmaW5hbFN0cm9rZTtcbiAgICAgICAgICAgIHRoaXMubWFya2VyID0gbWVyZ2VkTWFya2VyO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKG1lcmdlZE1hcmtlci5zeW1ib2wsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJNYXJrZXJDaGFuZ2UuZW1pdChub3JtYWxpemVTaXplUHJvcChtZXJnZWRNYXJrZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0RWRpdCA9IGRlYm91bmNlKGFzeW5jIChzeW1ib2wsIHN5bWJvbFN3aXRjaCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBzeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRpdEdlb21ldHJ5IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgYWRkTWFya2VyID0gZWRpdEdlb21ldHJ5ID09PSBcInBvaW50XCI7XG4gICAgICAgICAgICBjb25zdCBhZGRGaWxsID0gKCFpc0xpbmVPbmx5U3ltYm9sKHN5bWJvbCkgJiYgZWRpdEdlb21ldHJ5ID09PSBcInBvaW50XCIpIHx8IGVkaXRHZW9tZXRyeSA9PT0gXCJwb2x5Z29uXCI7XG4gICAgICAgICAgICBpZiAoYWRkTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgaW5mby5tYXJrZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vcm1hbGl6ZVNpemVQcm9wKHRoaXMubWFya2VyKSksIHsgc3ltYm9sOiBjbG9uZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRGaWxsKSB7XG4gICAgICAgICAgICAgICAgaW5mby5maWxsID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5maWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0cm9rZSBhcHBsaWVzIHRvIGFsbCBnZW9tZXRyeSB0eXBlc1xuICAgICAgICAgICAgaW5mby5zdHJva2UgPSBPYmplY3QuYXNzaWduKHt9LCBub3JtYWxpemVTaXplUHJvcCh0aGlzLnN0cm9rZSkpO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJFZGl0LmVtaXQoe1xuICAgICAgICAgICAgICAgIHN5bWJvbDogY2xvbmUsXG4gICAgICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICAgICAgICBzeW1ib2xTd2l0Y2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAzMDApO1xuICAgICAgICB0aGlzLmZsaXBGaWxsQ29sb3JSYW1wcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zLmZpbGw7XG4gICAgICAgICAgICBjb25zdCBmaWxsID0gdGhpcy5maWxsO1xuICAgICAgICAgICAgY29uc3QgaXMyZCA9IHNlY3Rpb24uc3R5bGUgPT09IFwiMmRcIjtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZEZpbGwgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGZsaXBDb2xvclJhbXBTdG9wcyhmaWxsLmNvbG9yLCBpczJkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc2VjdGlvbnMpLCB7IGZpbGw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VjdGlvbiksIHsgY29sb3JSYW1wczogc2VjdGlvbi5jb2xvclJhbXBzLm1hcCgoeyBzdG9wcywgdGFncywgbmFtZSB9KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHM6IGZsaXBDb2xvclJhbXBTdG9wcyhzdG9wcywgaXMyZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICB9KSkgfSkgfSk7XG4gICAgICAgICAgICB0aGlzLmZpbGwgPSBtZXJnZWRGaWxsO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJGaWxsQ2hhbmdlLmVtaXQobWVyZ2VkRmlsbCk7XG4gICAgICAgICAgICAvLyB3ZSBzZXQgdG8gZW1pdCB0aGUgYXV0by1hZGp1c3RlZCBjaGFuZ2VzIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5bWJvbCBub3QgY2hhbmdpbmdcbiAgICAgICAgICAgIHRoaXMuZW1pdEVkaXQodGhpcy5zeW1ib2wpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbmRlckJsb2NrID0gKHByb3BzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJsb2NrXCIsIHsgY29sbGFwc2libGU6IHRydWUsIGRpc2FibGVkOiAoX2EgPSBwcm9wcy5kaXNhYmxlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsIGhlYWRpbmc6IHByb3BzLmhlYWRpbmcsIGtleTogcHJvcHMua2V5LCBvbkNhbGNpdGVCbG9ja09wZW46IHRoaXMub25CbG9ja1RvZ2dsZSwgb25DYWxjaXRlQmxvY2tDbG9zZTogdGhpcy5vbkJsb2NrVG9nZ2xlIH0sIHByb3BzLmljb24sIHByb3BzLmNvbnRlbnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkJsb2NrVG9nZ2xlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5tYW51YWxCbG9ja09wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbnVhbEJsb2NrT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsb3NlIGFsbCBjb2xvciBwaWNrZXIgcG9wb3ZlcnNcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmFtcElucHV0RWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jb2xvcklucHV0RWwuZm9yRWFjaCgoZWwpID0+IGVsID09PSBudWxsIHx8IGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbC5jbG9zZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uID0gKHsgZGlzYWJsZWQsIGVtYmVkZGVkID0gZmFsc2UsIGtleSwgc2VjdGlvbkNvbnRlbnQgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvblwiLCB7IGRpc2FibGVkOiBkaXNhYmxlZCwga2V5OiBrZXksIGVtYmVkZGVkOiBlbWJlZGRlZCB9LCBzZWN0aW9uQ29udGVudC5tYXAoKHsgY29udGVudCB9KSA9PiBjb250ZW50KSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZsaXBTdHJva2VDb2xvclJhbXBzID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuc2VjdGlvbnMuc3Ryb2tlO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgICAgICAgICBjb25zdCBpczJkID0gc2VjdGlvbi5zdHlsZSA9PT0gXCIyZFwiO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yOiBmbGlwQ29sb3JSYW1wU3RvcHMoc3Ryb2tlLmNvbG9yLCBpczJkKSB9KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc2VjdGlvbnMpLCB7IHN0cm9rZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWN0aW9uKSwgeyBjb2xvclJhbXBzOiBzZWN0aW9uLmNvbG9yUmFtcHMubWFwKCh7IHN0b3BzLCB0YWdzLCBuYW1lIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wczogZmxpcENvbG9yUmFtcFN0b3BzKHN0b3BzLCBpczJkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHRhZ3Muc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSkpIH0pIH0pO1xuICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBtZXJnZWRTdHJva2U7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZFN0cm9rZSkpO1xuICAgICAgICAgICAgLy8gd2Ugc2V0IHRvIGVtaXQgdGhlIGF1dG8tYWRqdXN0ZWQgY2hhbmdlcyByZWdhcmRsZXNzIG9mIHRoZSBzeW1ib2wgbm90IGNoYW5naW5nXG4gICAgICAgICAgICB0aGlzLmVtaXRFZGl0KHRoaXMuc3ltYm9sKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb3BvdmVyUHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW5pdGlhbFNvdXJjZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvcnRhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdHJpbmdPdmVycmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubW9kZSA9IFwiZGVmYXVsdFwiO1xuICAgICAgICB0aGlzLmNpbVN0cm9rZVdpZHRoQm91bmRzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lZGl0R2VvbWV0cnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZmlsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tYXJrZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubmFycm93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlcHBpbmdFZGl0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcmV2aWV3U3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmJ1aWx0SW5TdHJpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1lcmdlZFN0cmluZ3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50ZW1wU3Ryb2tlQ29sb3JSYW1wU3RhdGVBY3RpdmVDYXRlZ29yeSA9IFwiYWxsXCI7XG4gICAgICAgIHRoaXMuYWN0aXZlU3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmFjdGl2ZVN5bWJvbEl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYWN0aXZlU291cmNlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImVkaXRpbmdcIjtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5lbCk7XG4gICAgICAgIHRoaXMud2luZG93UmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5KTtcbiAgICB9XG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLndpbmRvd1Jlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShkb2N1bWVudC5ib2R5KTtcbiAgICB9XG4gICAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgIGNvbnN0IFssIFtzdHJpbmdzXV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBlc3JpTW9kdWxlcy5sb2FkKCksXG4gICAgICAgICAgICBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKHRoaXMuZWwpXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRMYW5ndWFnZSA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5kaXIgPSBnZXRFbGVtZW50RGlyKHRoaXMuZWwpO1xuICAgICAgICBjb25zdCBwZXJjZW50Rm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMuY3VycmVudExhbmd1YWdlLCB7IHN0eWxlOiBcInBlcmNlbnRcIiB9KTtcbiAgICAgICAgY29uc3QgcGVyY2VudEZvcm1hdFNhbXBsZSA9IHBlcmNlbnRGb3JtYXR0ZXIuZm9ybWF0KDApO1xuICAgICAgICB0aGlzLnBlcmNlbnRMYWJlbEZsaXAgPVxuICAgICAgICAgICAgdGhpcy5kaXIgPT09IFwicnRsXCIgPyBwZXJjZW50Rm9ybWF0U2FtcGxlLmVuZHNXaXRoKFwiJVwiKSA6IHBlcmNlbnRGb3JtYXRTYW1wbGUuc3RhcnRzV2l0aChcIiVcIik7XG4gICAgICAgIHRoaXMuYnVpbHRJblN0cmluZ3MgPSBzdHJpbmdzO1xuICAgIH1cbiAgICBjb21wb25lbnRTaG91bGRVcGRhdGUobmV3VmFsLCBfb2xkVmFsLCBwcm9wTmFtZSkge1xuICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwicHJlcHBpbmdFZGl0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAhbmV3VmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b09wZW5GaXJzdEJsb2NrICYmICF0aGlzLnByZXBwaW5nRWRpdCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RCbG9jayA9IHRoaXMuZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1ibG9ja1wiKTtcbiAgICAgICAgICAgIGlmIChmaXJzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvT3BlbkZpcnN0QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBDYWxjaXRlIGlzc3VlICM4NDUzXG4gICAgICAgICAgICAgICAgdGhpcy5tYW51YWxCbG9ja09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZpcnN0QmxvY2sub3BlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbXVsdGlwbGUgd2F0Y2hlcyB0cmlnZ2VyIGZhbHNlIG5lZ2F0aXZlIGZvciB0aGlzIHJ1bGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHN0ZW5jaWwvbm8tdW51c2VkLXdhdGNoXG4gICAgaGFuZGxlU3RyaW5nQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5tZXJnZWRTdHJpbmdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJ1aWx0SW5TdHJpbmdzKSwgdGhpcy5zdHJpbmdPdmVycmlkZXMpO1xuICAgIH1cbiAgICBvblBhbmVsQmFjayhldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFB1YmxpYyBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgZWRpdChzeW1ib2wsIGNvbmZpZykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHZhbGlkYXRlRWRpdGFibGUoc3ltYm9sKTtcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbYXJjZ2lzLXN5bWJvbC1zdHlsZXJdICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbCA9IGF3YWl0IHRoaXMuY2hlY2tMaW5lT25seVN5bWJvbChzeW1ib2wsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMucG9ydGFsT3JJbnRlcmNlcHRvciA9IGNvbmZpZy5wb3J0YWwgfHwgdGhpcy5wb3J0YWwgfHwgZXNyaU1vZHVsZXMuUG9ydGFsLmdldERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5wcmVwcGluZ0VkaXQgPSB0cnVlO1xuICAgICAgICB0aGlzLmF1dG9PcGVuRmlyc3RCbG9jayA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgbWFya2VyOiBtYXJrZXJTZWN0aW9uLCBmaWxsOiBmaWxsU2VjdGlvbiwgc3Ryb2tlOiBzdHJva2VTZWN0aW9uIH0gPSBjb25maWcuc2VjdGlvbnM7XG4gICAgICAgIHRoaXMuc3ltYm9sRmlsdGVyID1cbiAgICAgICAgICAgIGNvbmZpZy5zeW1ib2xGaWx0ZXIgfHxcbiAgICAgICAgICAgICAgICAoKG1hcmtlclNlY3Rpb24gPT09IG51bGwgfHwgbWFya2VyU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyU2VjdGlvbi5tYXJrZXJUeXBlKSA9PT0gXCJhbGxcIiA/IHVuZGVmaW5lZCA6IG1hcmtlclNlY3Rpb24gPT09IG51bGwgfHwgbWFya2VyU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyU2VjdGlvbi5tYXJrZXJUeXBlKTtcbiAgICAgICAgdGhpcy5lZGl0R2VvbWV0cnkgPSBnZW9tZXRyeVR5cGUoc3ltYm9sKTtcbiAgICAgICAgc3ltYm9sID0gc3ltYm9sLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IGZpbGxTdXBwb3J0ZWQgPSBzdXBwb3J0c0ZpbGwoc3ltYm9sKTtcbiAgICAgICAgY29uc3Qgc3Ryb2tlU3VwcG9ydGVkID0gc3VwcG9ydHNTdHJva2Uoc3ltYm9sKTtcbiAgICAgICAgaWYgKGlzU01TU3ltYm9sKHN5bWJvbCkgfHwgaXNTRlNTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgaWYgKCFzeW1ib2wub3V0bGluZSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbC5vdXRsaW5lID0geyB0eXBlOiBcInNpbXBsZS1saW5lXCIsIGNvbG9yOiBjcmVhdGUobnVsbCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFzeW1ib2wub3V0bGluZS5jb2xvcikge1xuICAgICAgICAgICAgICAgIHN5bWJvbC5vdXRsaW5lLmNvbG9yID0gY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cm9rZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGF1dG9BZGp1c3RlZDogZmFsc2UgfSwgY29uZmlnLnN0cm9rZSksIHsgc2l6ZTogcGFyc2VTaXplKChfYSA9IGNvbmZpZy5zdHJva2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplLCAyKSwgc3R5bGU6IHN1cHBvcnRlZFN0eWxlcy5pbmNsdWRlcygoX2IgPSBjb25maWcuc3Ryb2tlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3R5bGUpID8gY29uZmlnLnN0cm9rZS5zdHlsZSA6IFwic29saWRcIiB9KTtcbiAgICAgICAgaWYgKChfYyA9IGNvbmZpZy5zdHJva2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXJrZXIpIHtcbiAgICAgICAgICAgIHN0cm9rZS5tYXJrZXIgPSBjb25maWcuc3Ryb2tlLm1hcmtlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlY3Rpb25zID0ge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFN0eWxlOiBcImxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IGZhbHNlIC8qIHBsYWNlaG9sZGVyICovLFxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlIC8qIHBsYWNlaG9sZGVyICovLFxuICAgICAgICAgICAgICAgIG9wZW46IChtYXJrZXJTZWN0aW9uID09PSBudWxsIHx8IG1hcmtlclNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlclNlY3Rpb24ub3BlbikgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgc3ltYm9sc09wZW46IChtYXJrZXJTZWN0aW9uICYmICghKFwic3ltYm9sc09wZW5cIiBpbiBtYXJrZXJTZWN0aW9uKSB8fCBtYXJrZXJTZWN0aW9uLnN5bWJvbHNPcGVuKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgc2l6ZU9wZW46IChtYXJrZXJTZWN0aW9uICYmICghKFwic2l6ZU9wZW5cIiBpbiBtYXJrZXJTZWN0aW9uKSB8fCBtYXJrZXJTZWN0aW9uLnNpemVPcGVuKSkgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgcm90YXRpb25PcGVuOiAobWFya2VyU2VjdGlvbiAmJiAoIShcInJvdGF0aW9uT3BlblwiIGluIG1hcmtlclNlY3Rpb24pIHx8IG1hcmtlclNlY3Rpb24ucm90YXRpb25PcGVuKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAga2VlcENob2ljZTogKG1hcmtlclNlY3Rpb24gPT09IG51bGwgfHwgbWFya2VyU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyU2VjdGlvbi5rZWVwQ2hvaWNlKSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXJ0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0VmlzaWJsZU1hcmtlclNlY3Rpb25QYXJ0cyksIG1hcmtlclNlY3Rpb24gPT09IG51bGwgfHwgbWFya2VyU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyU2VjdGlvbi5wYXJ0cylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ2F0ZWdvcnk6IFwiYWxsXCIsXG4gICAgICAgICAgICAgICAgb3BlbjogKGZpbGxTZWN0aW9uID09PSBudWxsIHx8IGZpbGxTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxsU2VjdGlvbi5vcGVuKSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogKGZpbGxTZWN0aW9uID09PSBudWxsIHx8IGZpbGxTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxsU2VjdGlvbi5vcHRpb25hbCkgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmlsbFN1cHBvcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9kID0gY29uZmlnLmZpbGxFbmFibGVkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNDSU1TeW1ib2woc3ltYm9sKSAmJlxuICAgICAgICAgICAgICAgICAgICAoZmlsbFNlY3Rpb24gPT09IG51bGwgfHwgZmlsbFNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGxTZWN0aW9uLnR5cGUpID09PSBcImNvbG9yXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgISF0aGlzLnRvQ29sb3JQaWNrZXJWYWx1ZShjb25maWcuZmlsbC5jb2xvciksXG4gICAgICAgICAgICAgICAgdHlwZTogZmlsbFNlY3Rpb24gPT09IG51bGwgfHwgZmlsbFNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGxTZWN0aW9uLnR5cGUsXG4gICAgICAgICAgICAgICAgc3R5bGU6IGZpbGxTZWN0aW9uID09PSBudWxsIHx8IGZpbGxTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxsU2VjdGlvbi5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnNPcGVuOiAoZmlsbFNlY3Rpb24gPT09IG51bGwgfHwgZmlsbFNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGxTZWN0aW9uLnN1Z2dlc3RlZENvbG9yc09wZW4pIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN1c3RvbUNvbG9yT3BlbjogKGZpbGxTZWN0aW9uID09PSBudWxsIHx8IGZpbGxTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxsU2VjdGlvbi5jdXN0b21Db2xvck9wZW4pIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbG9yUmFtcHNPcGVuOiAoZmlsbFNlY3Rpb24gPT09IG51bGwgfHwgZmlsbFNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGxTZWN0aW9uLmNvbG9yUmFtcHNPcGVuKSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb2xvclJhbXBzOiBnZXRTdGF0ZUNvbG9yUmFtcHMoZmlsbFNlY3Rpb24sIGNvbmZpZy5maWxsKSxcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3lPcGVuOiAoZmlsbFNlY3Rpb24gPT09IG51bGwgfHwgZmlsbFNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGxTZWN0aW9uLnRyYW5zcGFyZW5jeU9wZW4pIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcnRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFZpc2libGVDb2xvclNlY3Rpb25QYXJ0cyksIGRlZmF1bHRWaXNpYmxlQ29sb3JSYW1wU2VjdGlvblBhcnRzKSwgZmlsbFNlY3Rpb24gPT09IG51bGwgfHwgZmlsbFNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGxTZWN0aW9uLnBhcnRzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUNhdGVnb3J5OiBcImFsbFwiLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiAoc3Ryb2tlU2VjdGlvbiA9PT0gbnVsbCB8fCBzdHJva2VTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VTZWN0aW9uLm9wdGlvbmFsKSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBvcGVuOiAoc3Ryb2tlU2VjdGlvbiA9PT0gbnVsbCB8fCBzdHJva2VTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VTZWN0aW9uLm9wZW4pIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHN0cm9rZVN1cHBvcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9lID0gY29uZmlnLnN0cm9rZUVuYWJsZWQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRydWUpICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0NJTVN5bWJvbChzeW1ib2wpICYmXG4gICAgICAgICAgICAgICAgICAgIChzdHJva2VTZWN0aW9uID09PSBudWxsIHx8IHN0cm9rZVNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZVNlY3Rpb24udHlwZSkgPT09IFwiY29sb3JcIiAmJlxuICAgICAgICAgICAgICAgICAgICAhIXRoaXMudG9Db2xvclBpY2tlclZhbHVlKGNvbmZpZy5zdHJva2UuY29sb3IpLFxuICAgICAgICAgICAgICAgIHR5cGU6IHN0cm9rZVNlY3Rpb24gPT09IG51bGwgfHwgc3Ryb2tlU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Ryb2tlU2VjdGlvbi50eXBlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHJva2VTZWN0aW9uID09PSBudWxsIHx8IHN0cm9rZVNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZVNlY3Rpb24uc3R5bGUsXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogKHN0cm9rZVNlY3Rpb24gPT09IG51bGwgfHwgc3Ryb2tlU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Ryb2tlU2VjdGlvbi5zdWdnZXN0ZWRDb2xvcnNPcGVuKSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBjdXN0b21Db2xvck9wZW46IChzdHJva2VTZWN0aW9uID09PSBudWxsIHx8IHN0cm9rZVNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZVNlY3Rpb24uY3VzdG9tQ29sb3JPcGVuKSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb2xvclJhbXBzT3BlbjogKHN0cm9rZVNlY3Rpb24gPT09IG51bGwgfHwgc3Ryb2tlU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Ryb2tlU2VjdGlvbi5jb2xvclJhbXBzT3BlbikgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgY29sb3JSYW1wczogZ2V0U3RhdGVDb2xvclJhbXBzKHN0cm9rZVNlY3Rpb24sIGNvbmZpZy5zdHJva2UpLFxuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW5jeU9wZW46IChzdHJva2VTZWN0aW9uID09PSBudWxsIHx8IHN0cm9rZVNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZVNlY3Rpb24udHJhbnNwYXJlbmN5T3BlbikgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgZXh0cmFPcGVuOiAoc3Ryb2tlU2VjdGlvbiA9PT0gbnVsbCB8fCBzdHJva2VTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VTZWN0aW9uLmV4dHJhT3BlbikgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgZXh0cmFQYXJ0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0VmlzaWJsZUV4dHJhU3Ryb2tlU2VjdGlvblBhcnRzKSwgc3Ryb2tlU2VjdGlvbiA9PT0gbnVsbCB8fCBzdHJva2VTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VTZWN0aW9uLmV4dHJhUGFydHMpLFxuICAgICAgICAgICAgICAgIHBhcnRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0VmlzaWJsZUNvbG9yU2VjdGlvblBhcnRzKSwgZGVmYXVsdFZpc2libGVDb2xvclJhbXBTZWN0aW9uUGFydHMpLCBkZWZhdWx0VmlzaWJsZVN0cm9rZVNlY3Rpb25QYXJ0cyksIHN0cm9rZVNlY3Rpb24gPT09IG51bGwgfHwgc3Ryb2tlU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Ryb2tlU2VjdGlvbi5wYXJ0cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYXJrZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZy5tYXJrZXIpLCB7IHNpemU6IHBhcnNlU2l6ZSgoX2YgPSBjb25maWcubWFya2VyKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2l6ZSwgMCksIGFuZ2xlOiBnZXRTeW1ib2xSb3RhdGlvbihzeW1ib2wpLCBhdXRvQWRqdXN0ZWQ6ICgoX2cgPSBjb25maWcubWFya2VyKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuYXV0b0FkanVzdGVkKSB8fCBmYWxzZSwgc3ltYm9sIH0pO1xuICAgICAgICB0aGlzLmZpbGwgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcuZmlsbCk7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gc3Ryb2tlO1xuICAgICAgICB0aGlzLmFjdGl2ZVN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgdGhpcy5hY3RpdmVTb3VyY2VJZCA9ICgobWFya2VyU2VjdGlvbiA9PT0gbnVsbCB8fCBtYXJrZXJTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJTZWN0aW9uLmtlZXBDaG9pY2UpICYmIHRoaXMuYWN0aXZlU291cmNlSWQpIHx8IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlU3ltYm9sSXRlbSA9ICgobWFya2VyU2VjdGlvbiA9PT0gbnVsbCB8fCBtYXJrZXJTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJTZWN0aW9uLmtlZXBDaG9pY2UpICYmIHRoaXMuYWN0aXZlU3ltYm9sSXRlbSkgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIGlmIChpc0NJTVN5bWJvbChzeW1ib2wpICYmICh0aGlzLmlzRmlsbENvbG9yUmFtcCgpIHx8IHRoaXMuaXNTdHJva2VDb2xvclJhbXAoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY1N5bWJvbFByb3BzKHN5bWJvbCwge1xuICAgICAgICAgICAgICAgIGNpbUNoYW5nZUNvbnRleHQ6IFwicm9vdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDSU1TeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgdGhpcy5jaW1TdHJva2VXaWR0aEJvdW5kcyA9IGdldENJTVN0cm9rZVdpZHRoQm91bmRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbChzeW1ib2wsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5wcmVwcGluZ0VkaXQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgY2hlY2tMaW5lT25seVN5bWJvbChzeW1ib2wsIGNvbmZpZykge1xuICAgICAgICAvLyB3ZSBubyBsb25nZXIgc3VwcG9ydCBwbHVzIGFuZCBYIG1hcmtlcnMgaW4gdGhlIHN0eWxlclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIGlmIChpc0xpbmVPbmx5U3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgICAgIC8vXCJmaWxsXCI6e1wiY29sb3JcIjpDb2xvcn0sXG4gICAgICAgICAgICAvL1wiZmlsbFwiOntcImNvbG9yXCI6W0NvbG9yLENvbG9yLENvbG9yLENvbG9yLENvbG9yXX1cbiAgICAgICAgICAgIC8vXCJtYXJrZXJcIjp7XCJzaXplXCI6MTMuNSxcImF1dG9BZGp1c3RlZFwiOmZhbHNlfSxcbiAgICAgICAgICAgIC8vXCJzdHJva2VcIjp7XCJjb2xvclwiOkNvbG9yLFwic2l6ZVwiOjAuNzV9XG4gICAgICAgICAgICBjb25zdCBbU2ltcGxlTWFya2VyU3ltYm9sXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvc3ltYm9scy9TaW1wbGVNYXJrZXJTeW1ib2xcIl0pO1xuICAgICAgICAgICAgc3ltYm9sID0gbmV3IFNpbXBsZU1hcmtlclN5bWJvbCgpO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNvbmZpZyBmaXRzIHRvIG5ldyBzeW1ib2xcbiAgICAgICAgICAgIGlmICgoX2EgPSBjb25maWcuZmlsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmZpbGwuY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFwiY29sb3ItcmFtcFwiXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5jb2xvciA9IGNvbmZpZy5maWxsLmNvbG9yW2NvbmZpZy5maWxsLmNvbG9yLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJjb2xvclwiXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5jb2xvciA9IGNvbmZpZy5maWxsLmNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoX2IgPSBjb25maWcuc3Ryb2tlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3Ryb2tlLmNvbG9yID0gc3ltYm9sLm91dGxpbmUuY29sb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoKF9jID0gY29uZmlnLnN0cm9rZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNpemUpIHx8ICgoX2QgPSBjb25maWcuc3Ryb2tlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2l6ZSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3Ryb2tlLnNpemUgPSBzeW1ib2wub3V0bGluZS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoX2UgPSBjb25maWcubWFya2VyKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbC5zaXplID0gY29uZmlnLm1hcmtlci5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZy5tYXJrZXIpLCB7IHNpemU6IHBhcnNlU2l6ZSgoX2YgPSBjb25maWcubWFya2VyKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2l6ZSwgMCksIGFuZ2xlOiBnZXRTeW1ib2xSb3RhdGlvbihzeW1ib2wpLCBhdXRvQWRqdXN0ZWQ6ICgoX2cgPSBjb25maWcubWFya2VyKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuYXV0b0FkanVzdGVkKSB8fCBmYWxzZSwgc3ltYm9sIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0RWRpdChzeW1ib2wpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3ltYm9sKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0U2l6ZSh0eXBlLCBzaXplKSB7XG4gICAgICAgIGNvbnN0IHsgc2NyZWVuVXRpbHMgfSA9IGVzcmlNb2R1bGVzO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJva2VcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJva2VXaWR0aChub3JtYWxpemVQeChzY3JlZW5VdGlscy5wdDJweChzaXplKSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJtYXJrZXJcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRTeW1ib2xTaXplKG5vcm1hbGl6ZVB4KHNjcmVlblV0aWxzLnB0MnB4KHNpemUpKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldExpbmVQYXR0ZXJuU3R5bGUoc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke2dldEFzc2V0UGF0aChgLi9hc3NldHMvbGluZS1wYXR0ZXJucy8ke3N0eWxlfS5wbmdgKX0pYFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRTZWxlY3RlZEFycm93UGF0dGVyblN0eWxlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7Z2V0QXNzZXRQYXRoKGAuL2Fzc2V0cy9hcnJvdy1wYXR0ZXJuLXNwcml0ZXNoZWV0LnBuZ2ApfSlgXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEFycm93UGF0dGVybk9wdGlvblN0eWxlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7Z2V0QXNzZXRQYXRoKGAuL2Fzc2V0cy9hcnJvdy1wYXR0ZXJuLW9wdGlvbnMtc3ByaXRlc2hlZXQucG5nYCl9KWBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaGFzQWN0aXZlTGluZU9ubHlTaW1wbGVNYXJrZXJTeW1ib2woKSB7XG4gICAgICAgIGNvbnN0IHsgbWFya2VyLCBzeW1ib2wgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtYXJrZXIgJiYgaXNMaW5lT25seVN5bWJvbChzeW1ib2wpO1xuICAgIH1cbiAgICBoYXNBY3RpdmVQaWN0dXJlTWFya2VyU3ltYm9sKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5zeW1ib2wpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJwaWN0dXJlLW1hcmtlclwiIHx8IHRoaXMuYWN0aXZlU3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIjtcbiAgICB9XG4gICAgc2V0U3Ryb2tlV2lkdGgod2lkdGgsIGVtaXQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgc3Ryb2tlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzaXplID0gd2lkdGggPCAwID8gMCA6IG5vcm1hbGl6ZVB4KHdpZHRoKTtcbiAgICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IHNpemUgfSk7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gbWVyZ2VkU3Ryb2tlO1xuICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2UuZW1pdChub3JtYWxpemVTaXplUHJvcChtZXJnZWRTdHJva2UsIHdpZHRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bmNTeW1ib2xQcm9wcyh0aGlzLnN5bWJvbCwgeyBjaW1DaGFuZ2VDb250ZXh0OiBcInJvb3RcIiB9KSwgZW1pdCk7XG4gICAgfVxuICAgIGlzRmlsbENvbG9yUmFtcCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuY29uZmlnLnNlY3Rpb25zLmZpbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJjb2xvci1yYW1wXCI7XG4gICAgfVxuICAgIGlzU3Ryb2tlQ29sb3JSYW1wKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5jb25maWcuc2VjdGlvbnMuc3Ryb2tlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiY29sb3ItcmFtcFwiO1xuICAgIH1cbiAgICBnZXRTYW1wbGVGaWxsQ29sb3JSYW1wQ29sb3IoKSB7XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zLmZpbGw7XG4gICAgICAgIGNvbnN0IGZpbGwgPSB0aGlzLmZpbGw7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNhbXBsZUNvbG9yUmFtcENvbG9yKHNlY3Rpb24sIGZpbGwuY29sb3IpO1xuICAgIH1cbiAgICBnZXRTYW1wbGVTdHJva2VDb2xvclJhbXBDb2xvcigpIHtcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuc2VjdGlvbnMuc3Ryb2tlO1xuICAgICAgICBjb25zdCBzdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2FtcGxlQ29sb3JSYW1wQ29sb3Ioc2VjdGlvbiwgc3Ryb2tlLmNvbG9yKTtcbiAgICB9XG4gICAgZ2V0U2FtcGxlQ29sb3JSYW1wQ29sb3Ioc2VjdGlvbiwgcmFtcENvbG9ycykge1xuICAgICAgICBjb25zdCB0b3RhbENvbG9ycyA9IHJhbXBDb2xvcnMubGVuZ3RoO1xuICAgICAgICBpZiAoc2VjdGlvbi5zdHlsZSA9PT0gXCIyZFwiIHx8IHNlY3Rpb24uc3R5bGUgPT09IFwiZGlzY3JldGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHJhbXBDb2xvcnNbdG90YWxDb2xvcnMgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFtcENvbG9yc1tNYXRoLmZsb29yKHRvdGFsQ29sb3JzIC8gMildO1xuICAgIH1cbiAgICBzZXRTeW1ib2xTaXplKHNpemUsIGVtaXQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgbWFya2VyLCBmaWxsLCBzdHJva2UsIHN5bWJvbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbWVyZ2VkTWFya2VyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYXJrZXIpLCB7IHN5bWJvbDogdGhpcy5zeW5jU3ltYm9sUHJvcHMoc3ltYm9sLCB7XG4gICAgICAgICAgICAgICAgY2ltQ2hhbmdlQ29udGV4dDogXCJyb290XCIsXG4gICAgICAgICAgICAgICAgc3ltYm9sU3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1hcmtlciksIHsgc2l6ZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgc2l6ZSB9KTtcbiAgICAgICAgdGhpcy5tYXJrZXIgPSBtZXJnZWRNYXJrZXI7XG4gICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wobWVyZ2VkTWFya2VyLnN5bWJvbCwgZW1pdCk7XG4gICAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlck1hcmtlckNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZE1hcmtlciwgc2l6ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGlmICh0aGlzLnByZXBwaW5nRWRpdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5lbCk7XG4gICAgICAgIGNvbnN0IHsgc2VjdGlvbnMgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBlZGl0aW5nQ0lNID0gaXNDSU1TeW1ib2wodGhpcy5hY3RpdmVTeW1ib2wpO1xuICAgICAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImNhbGNpdGUtZmxvd1wiLCB7IHJlZjogKGVsKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93RWwgPSBlbDtcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBoZXJlIGFmdGVyIGNvbXBvbmVudERpZExvYWRcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUG9wb3Zlck1heEhlaWdodCgpO1xuICAgICAgICAgICAgfSB9LCBoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBjbGFzczoge1xuICAgICAgICAgICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBkaXIgPT09IFwicnRsXCJcbiAgICAgICAgICAgIH0sIGRpcjogZGlyLFxuICAgICAgICAgICAgLy8gb21pdHRpbmcgYGhlYWRpbmdgIGludGVudGlvbmFsbHkgdG8gYWxsb3cgZW1iZWRkaW5nIGludG8gZXhpc3RpbmcgcGFuZWxzXG4gICAgICAgICAgICAvL2hlaWdodFNjYWxlPXt0aGlzLmhlaWdodFNjYWxlfVxuICAgICAgICAgICAga2V5OiBcIm1haW5cIiB9LCBbXG4gICAgICAgICAgICAoKF9iID0gKF9hID0gc2VjdGlvbnMubWFya2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFydHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yb3RhdGlvbikgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKChfZCA9IChfYyA9IHNlY3Rpb25zLm1hcmtlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucHJldmlldykgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKChfZiA9IChfZSA9IHNlY3Rpb25zLm1hcmtlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnBhcnRzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2l6ZSkgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJlbmRlclN5bWJvbEJsb2NrKCksXG4gICAgICAgICAgICAhZWRpdGluZ0NJTSAmJiBzZWN0aW9ucy5maWxsID8gdGhpcy5yZW5kZXJGaWxsQmxvY2soKSA6IG51bGwsXG4gICAgICAgICAgICAhZWRpdGluZ0NJTSAmJiBzZWN0aW9ucy5zdHJva2UgPyB0aGlzLnJlbmRlclN0cm9rZUJsb2NrKCkgOiBudWxsXG4gICAgICAgIF0pLCB0aGlzLnN0YXRlID09PSBcImNob29zaW5nLXN5bWJvbFwiID8gdGhpcy5yZW5kZXJTeW1ib2xTZWxlY3Rpb25QYW5lbCgpIDogbnVsbCkpKTtcbiAgICB9XG4gICAgcmVuZGVyU3ltYm9sQmxvY2soKSB7XG4gICAgICAgIGNvbnN0IHsgbWFya2VyOiBzZWN0aW9uLCBzdHJva2U6IHN0cm9rZVNlY3Rpb24gfSA9IHRoaXMuc2VjdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgcGFydHM6IHBhcnRzIH0gPSBzZWN0aW9uO1xuICAgICAgICBjb25zdCB7IGVkaXRHZW9tZXRyeSwgc3ltYm9sIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpc0NJTSA9IGlzQ0lNU3ltYm9sKHN5bWJvbCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgICAgICAgaWYgKHBhcnRzLnByZXZpZXcpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJTeW1ib2xzU2VsZWN0aW9uKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NJTSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGaWxsQ29sb3JSYW1wKCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLnJlbmRlckNvbG9yUmFtcEZpbGxCbG9jayh0cnVlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0cm9rZUNvbG9yUmFtcCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJDb2xvclJhbXBTdHJva2VCbG9jayh0cnVlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZGl0R2VvbWV0cnkgPT09IFwicG9pbnRcIikge1xuICAgICAgICAgICAgaWYgKHBhcnRzLnNpemUpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBpc0NJTSA/IHRoaXMucmVuZGVyUm9vdENJTVN5bWJvbFNpemVDb250ZW50KCkgOiB0aGlzLnJlbmRlclN5bWJvbFNpemVDb250ZW50KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0cy5yb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyU3ltYm9sUm90YXRpb25Db250ZW50KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NJTSAmJiBzdHJva2VTZWN0aW9uLmV4dHJhUGFydHMud2lkdGgpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzcGVjaWZpYyBDSU0gc3VwcG9ydHMgYW4gb3V0bGluZSB3aWR0aFxuICAgICAgICAgICAgaWYgKCFpc1BvbHlnb25DSU0oc3ltYm9sKSB8fCAoaXNQb2x5Z29uQ0lNKHN5bWJvbCkgJiYgc3VwcG9ydHNPdXRsaW5lV2lkdGgoc3ltYm9sKSkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLnJlbmRlclJvb3RDSU1TeW1ib2xXaWR0aENvbnRlbnQoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NJTSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLnJlbmRlclJvb3RDSU1TeW1ib2xDb250ZW50KHN5bWJvbClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclNlY3Rpb24oe1xuICAgICAgICAgICAga2V5OiBcIm1hcmtlci1zeW1ib2xzXCIsXG4gICAgICAgICAgICBzZWN0aW9uQ29udGVudDogY29udGVudFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyUm9vdENJTVN5bWJvbENvbnRlbnQoc3ltYm9sKSB7XG4gICAgICAgIGNvbnN0IGxheWVyUGFuZWxzID0gdGhpcy5yZW5kZXJDSU1TeW1ib2xMYXllcnNDb250ZW50KHN5bWJvbC5kYXRhLnN5bWJvbCwgXCJyb290LXN5bWJvbFwiKTtcbiAgICAgICAgaWYgKGxheWVyUGFuZWxzLmxlbmd0aCA+IG1heERpc3BsYXllZFN5bWJvbExheWVycykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5sYXllclBhbmVscy5zbGljZSgwLCBtYXhEaXNwbGF5ZWRTeW1ib2xMYXllcnMpLFxuICAgICAgICAgICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLm1lc3NhZ2UgfSwgdGhpcy5tZXJnZWRTdHJpbmdzLmFkZGl0aW9uYWxTeW1ib2xMYXllcnNOb3RTaG93bi5yZXBsYWNlKFwiJHtjb3VudH1cIiwgbWF4RGlzcGxheWVkU3ltYm9sTGF5ZXJzLnRvU3RyaW5nKCkpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF5ZXJQYW5lbHM7XG4gICAgfVxuICAgIHJlbmRlckNJTVN5bWJvbExheWVyc0NvbnRlbnQoeyBzeW1ib2xMYXllcnMgfSwga2V5LCBjb250ZW50T25seSA9IGZhbHNlLCBwYXJlbnRTeW1ib2xMYXllcikge1xuICAgICAgICByZXR1cm4gc3ltYm9sTGF5ZXJzXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHR5cGUgfSkgPT4gdGhpcy5pc1N1cHBvcnRlZFN5bWJvbExheWVyVHlwZSh0eXBlKSlcbiAgICAgICAgICAgIC5tYXAoKHN5bWJvbExheWVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudEtleSA9IGAke2tleX1fX3N5bWJvbC1sYXllcnNfX3N5bWJvbC1sYXllci0ke2luZGV4LnRvU3RyaW5nKCl9YDtcbiAgICAgICAgICAgIGlmIChzeW1ib2xMYXllci50eXBlID09PSBcIkNJTVZlY3Rvck1hcmtlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ0lNVmVjdG9yTWFya2VyU3ltYm9sTGF5ZXJCbG9ja3Moc3ltYm9sTGF5ZXIsIGNvbnRlbnRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN5bWJvbExheWVyLnR5cGUgPT09IFwiQ0lNUGljdHVyZU1hcmtlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ0lNUGljdHVyZU1hcmtlclN5bWJvbExheWVyQmxvY2soc3ltYm9sTGF5ZXIsIGNvbnRlbnRLZXksIGNvbnRlbnRPbmx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzeW1ib2xMYXllci50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDSU1Tb2xpZFN0cm9rZVN5bWJvbExheWVyQmxvY2soc3ltYm9sTGF5ZXIsIGNvbnRlbnRLZXksIGNvbnRlbnRPbmx5LCBwYXJlbnRTeW1ib2xMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3ltYm9sTGF5ZXIudHlwZSA9PT0gXCJDSU1QaWN0dXJlU3Ryb2tlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDSU1QaWN0dXJlU3Ryb2tlU3ltYm9sTGF5ZXJCbG9jayhzeW1ib2xMYXllciwgY29udGVudEtleSwgY29udGVudE9ubHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN5bWJvbExheWVyLnR5cGUgPT09IFwiQ0lNU29saWRGaWxsXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDSU1Tb2xpZEZpbGxTeW1ib2xMYXllckJsb2NrKHN5bWJvbExheWVyLCBjb250ZW50S2V5LCBjb250ZW50T25seSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3ltYm9sTGF5ZXIudHlwZSA9PT0gXCJDSU1IYXRjaEZpbGxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckNJTUhhdGNoRmlsbFN5bWJvbExheWVyQmxvY2tzKHN5bWJvbExheWVyLCBjb250ZW50S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzeW1ib2xMYXllci50eXBlID09PSBcIkNJTVBpY3R1cmVGaWxsXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDSU1QaWN0dXJlRmlsbFN5bWJvbExheWVyQmxvY2soc3ltYm9sTGF5ZXIsIGNvbnRlbnRLZXksIGNvbnRlbnRPbmx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5mbGF0KCk7XG4gICAgfVxuICAgIHJlbmRlclN5bWJvbHNTZWxlY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVN5bWJvbCA9IHRoaXMucHJldmlld1N5bWJvbDtcbiAgICAgICAgY29uc3QgY29udHJhc3RpbmdCYWNrZ3JvdW5kVGhlbWUgPSBhY3RpdmVTeW1ib2xcbiAgICAgICAgICAgID8gZXNyaU1vZHVsZXMucHJldmlld1N5bWJvbDJELmdldENvbnRyYXN0aW5nQmFja2dyb3VuZFRoZW1lKGFjdGl2ZVN5bWJvbCwgMjQ1KVxuICAgICAgICAgICAgOiBcImxpZ2h0XCI7XG4gICAgICAgIGNvbnN0IGlzUnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmVsKSA9PT0gXCJydGxcIjtcbiAgICAgICAgY29uc3Qgc2luZ2xlU291cmNlQW5kSXRlbUF2YWlsYWJsZSA9ICgoX2EgPSB0aGlzLmZpbHRlcmVkU291cmNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPT09IDEgJiYgKChfYiA9IHRoaXMuYWN0aXZlU3ltYm9sSXRlbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpID09PSAxO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBcIi0tYXJjZ2lzLXN5bWJvbC1zdHlsZXItaW5saW5lLWlucHV0LXRyaWdnZXItYmFja2dyb3VuZC1jb2xvclwiOiBjb250cmFzdGluZ0JhY2tncm91bmRUaGVtZSA9PT0gXCJkYXJrXCIgPyBcIiNmM2YzZjNcIiA6IFwiXCJcbiAgICAgICAgICAgIH0gfSwgdGhpcy5tZXJnZWRTdHJpbmdzLmN1cnJlbnRTeW1ib2wsIGgoXCJidXR0b25cIiwgeyBjbGFzczogQ1NTLmNoYW5nZVN5bWJvbFRyaWdnZXIsIGRpc2FibGVkOiBzaW5nbGVTb3VyY2VBbmRJdGVtQXZhaWxhYmxlLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFwiY2hvb3Npbmctc3ltYm9sXCI7XG4gICAgICAgICAgICB9LCB0eXBlOiBcImJ1dHRvblwiIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRhaW5lciwgdGFiSW5kZXg6IDAgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1Muc3ltYm9sIH0sIGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zeW1ib2wtcHJldmlld1wiLCB7IHN5bWJvbDogYWN0aXZlU3ltYm9sLCBvcHRpb25zOiB0aGlzLmVkaXRHZW9tZXRyeSA9PT0gXCJwb2ludFwiID8gcG9pbnRQcmV2aWV3T3B0aW9ucyA6IG51bGwgfSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5sYWJlbCB9LCBnZXRTeW1ib2xMYWJlbChhY3RpdmVTeW1ib2wsIHRoaXMubWVyZ2VkU3RyaW5ncykpKSwgaChcImNhbGNpdGUtaWNvblwiLCB7IGljb246IHNpbmdsZVNvdXJjZUFuZEl0ZW1BdmFpbGFibGUgPyBudWxsIDogYGNoZXZyb24tJHtpc1J0bCA/IFwibGVmdFwiIDogXCJyaWdodFwifWAsIHNjYWxlOiBcInNcIiB9KSkpKTtcbiAgICB9XG4gICAgcmVuZGVyU3ltYm9sU2VsZWN0aW9uUGFuZWwoKSB7XG4gICAgICAgIGNvbnN0IHsgZGlyLCBtZXJnZWRTdHJpbmdzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWZsb3ctaXRlbVwiLCB7IGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IGRpciA9PT0gXCJydGxcIixcbiAgICAgICAgICAgICAgICBcInN5bWJvbC1zZWxlY3Rpb24tcGFuZWxcIjogdHJ1ZVxuICAgICAgICAgICAgfSwgZGlyOiBkaXIsIGhlYWRpbmc6IG1lcmdlZFN0cmluZ3MuY2hhbmdlU3ltYm9sLFxuICAgICAgICAgICAgLy9oZWlnaHRTY2FsZT17dGhpcy5oZWlnaHRTY2FsZX1cbiAgICAgICAgICAgIGtleTogXCJzeW1ib2wtc2VsZWN0aW9uXCIsIGJlZm9yZUJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gXCJlZGl0aW5nXCI7XG4gICAgICAgICAgICB9IH0sIGgoXCJhcmNnaXMtc3ltYm9sLXBpY2tlclwiLCB7IGxhbmc6IHRoaXMuY3VycmVudExhbmd1YWdlLCBvbkFyY2dpc0FjdGl2ZVN5bWJvbENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZXRhaWw6IHN5bWJvbCB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN5bWJvbFNlbGVjdChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSwgb25BcmNnaXNBY3RpdmVTb3VyY2VJZENoYW5nZTogKHsgZGV0YWlsOiBhY3RpdmVTb3VyY2VJZCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVTb3VyY2VJZCA9IGFjdGl2ZVNvdXJjZUlkO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyU291cmNlSWRDaGFuZ2UuZW1pdChhY3RpdmVTb3VyY2VJZCk7XG4gICAgICAgICAgICB9LCBvbkFyY2dpc0FjdGl2ZVN5bWJvbEl0ZW1DaGFuZ2U6ICh7IGRldGFpbDogYWN0aXZlU3ltYm9sSXRlbSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVTeW1ib2xJdGVtID0gYWN0aXZlU3ltYm9sSXRlbTtcbiAgICAgICAgICAgIH0sIG9uQXJjZ2lzU3ltYm9sU291cmNlc0NoYW5nZTogKHsgZGV0YWlsOiBmaWx0ZXJlZFNvdXJjZXMgfSkgPT4gKHRoaXMuZmlsdGVyZWRTb3VyY2VzID0gZmlsdGVyZWRTb3VyY2VzKSwgb25BcmNnaXNBY3RpdmVTb3VyY2VJdGVtc0NoYW5nZTogKHsgZGV0YWlsOiBhY3RpdmVTb3VyY2VJdGVtcyB9KSA9PiAodGhpcy5hY3RpdmVTeW1ib2xJdGVtcyA9IGFjdGl2ZVNvdXJjZUl0ZW1zKSwgYWN0aXZlU3ltYm9sSXRlbTogdGhpcy5hY3RpdmVTeW1ib2xJdGVtLCBhY3RpdmVTb3VyY2VJZDogdGhpcy5hY3RpdmVTb3VyY2VJZCB8fCB0aGlzLmluaXRpYWxTb3VyY2VJZCwgcG9ydGFsOiB0aGlzLnBvcnRhbE9ySW50ZXJjZXB0b3IsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgXCItLXNjcm9sbGVyLW1heC1oZWlnaHRcIjogXCJ2YXIoLS1zeW1ib2wtc2Nyb2xsZXItbWF4LWhlaWdodClcIlxuICAgICAgICAgICAgfSwgc3ltYm9sRmlsdGVyOiB0aGlzLnN5bWJvbEZpbHRlciwgc3ltYm9sOiB0aGlzLmFjdGl2ZVN5bWJvbCB9KSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgd2lkdGg6IFwiZnVsbFwiLCBzbG90OiBcImZvb3RlclwiLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmZsb3dFbC5iYWNrKCkgfSwgbWVyZ2VkU3RyaW5ncy5kb25lKSkpO1xuICAgIH1cbiAgICBzZXRJbnRlcm5hbFN5bWJvbChzeW1ib2wsIGVtaXQsIHN5bWJvbFN3aXRjaCkge1xuICAgICAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgdGhpcy51cGRhdGVQcmV2aWV3U3ltYm9sKCk7XG4gICAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRFZGl0KHN5bWJvbCwgc3ltYm9sU3dpdGNoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJSb290Q0lNU3ltYm9sU2l6ZUNvbnRlbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgc2VjdGlvbnM6IHsgbWFya2VyOiB7IHBhcnRzOiB7IHNpemUgfSB9IH0sIG1hcmtlciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbWF4ID0gMTUwO1xuICAgICAgICBjb25zdCBtaW4gPSAxO1xuICAgICAgICBjb25zdCBhdXRvU2l6ZUFkanVzdCA9IHR5cGVvZiBzaXplID09PSBcIm9iamVjdFwiICYmIChzaXplID09PSBudWxsIHx8IHNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpemUuYXV0b1NpemVBZGp1c3QpO1xuICAgICAgICBjb25zdCBsYXJnZXN0U2l6ZSA9IGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbFNpemUodGhpcy5zeW1ib2wpO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnRHcm91cCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCB0aGlzLm1lcmdlZFN0cmluZ3Muc3ltYm9sU2l6ZSwgaChTZWxlY3ROdW1iZXIsIHsgZGlzYWJsZWQ6IGF1dG9TaXplQWRqdXN0ICYmIGF1dG9TaXplQWRqdXN0ICE9PSBcImVkaXRhYmxlXCIgJiYgbWFya2VyLmF1dG9BZGp1c3RlZCwgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3MucHgsIHZhbHVlOiBub3JtYWxpemVQeChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5wdDJweChsYXJnZXN0U2l6ZSkpLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uU3ltYm9sU2l6ZUNoYW5nZSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3Muc3ltYm9sU2l6ZSB9KSksIGF1dG9TaXplQWRqdXN0XG4gICAgICAgICAgICA/IHRoaXMucmVuZGVyQXV0b0FkanVzdChnZXRFbGVtZW50RGlyKHRoaXMuZWwpLCB0aGlzLm1hcmtlci5hdXRvQWRqdXN0ZWQsIHRoaXMubWVyZ2VkU3RyaW5ncy5hdXRvQWRqdXN0U2l6ZSwgdGhpcy5vbkF1dG9BZGp1c3RTaXplQ2hhbmdlKVxuICAgICAgICAgICAgOiBudWxsKSk7XG4gICAgfVxuICAgIHJlbmRlclJvb3RDSU1TeW1ib2xXaWR0aENvbnRlbnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gZm9yIHBvbHlnb24gQ0lNcyBpdCBvbmx5IGNvbWVzIGhlcmUgZm9yIGFuIG91dGxpbmVcbiAgICAgICAgY29uc3Qgc3ltYm9sID0gdGhpcy5zeW1ib2w7XG4gICAgICAgIGNvbnN0IHsgc2VjdGlvbnM6IHsgc3Ryb2tlOiB7IGV4dHJhUGFydHM6IHsgYXV0b1N0cm9rZUFkanVzdCB9IH0gfSwgc3Ryb2tlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBkaXIgPSBnZXRFbGVtZW50RGlyKHRoaXMuZWwpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGlzUG9seWdvbkNJTShzeW1ib2wpXG4gICAgICAgICAgICA/IGdldE91dGxpbmVXaWR0aChzeW1ib2wpXG4gICAgICAgICAgICA6IGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbFNpemUodGhpcy5zeW1ib2wpO1xuICAgICAgICBsZXQgbGFiZWwgPSB0aGlzLmdldFN0cm9rZVN0cmluZyhcIndpZHRoXCIpO1xuICAgICAgICBsZXQgbWluID0gdGhpcy5jaW1TdHJva2VXaWR0aEJvdW5kcy5taW47XG4gICAgICAgIGxldCBtYXggPSB0aGlzLmNpbVN0cm9rZVdpZHRoQm91bmRzLm1heDtcbiAgICAgICAgaWYgKGlzTGluZUNJTShzeW1ib2wpKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBoYXMgbWFya2VycyB3ZSBzaG91bGQgdHJlYXQgaXQgYXMgc2l6ZSwgbm90IHdpZHRoXG4gICAgICAgICAgICBjb25zdCBoYXNNYXJrZXIgPSAoX2EgPSBzeW1ib2wuZGF0YS5zeW1ib2wuc3ltYm9sTGF5ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoc3ltYm9sTGF5ZXIpID0+IFtcIkNJTVZlY3Rvck1hcmtlclwiLCBcIkNJTVBpY3R1cmVNYXJrZXJcIl0uaW5kZXhPZihzeW1ib2xMYXllci50eXBlKSA+IC0xKTtcbiAgICAgICAgICAgIGlmIChoYXNNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IHRoaXMubWVyZ2VkU3RyaW5ncy5zeW1ib2xTaXplO1xuICAgICAgICAgICAgICAgIG1pbiA9IHNpemVNaW47XG4gICAgICAgICAgICAgICAgbWF4ID0gc2l6ZU1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnRHcm91cCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGRpcjogZGlyIH0sIGxhYmVsLCBoKFNlbGVjdE51bWJlciwgeyBkaXNhYmxlZDogYXV0b1N0cm9rZUFkanVzdCAmJiBhdXRvU3Ryb2tlQWRqdXN0ICE9PSBcImVkaXRhYmxlXCIgJiYgc3Ryb2tlLmF1dG9BZGp1c3RlZCwgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3MucHgsIHZhbHVlOiBub3JtYWxpemVQeChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5wdDJweCh3aWR0aCkpLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uU3Ryb2tlV2lkdGhDaGFuZ2UsIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogbGFiZWwgfSkpLCBhdXRvU3Ryb2tlQWRqdXN0XG4gICAgICAgICAgICA/IHRoaXMucmVuZGVyQXV0b0FkanVzdChkaXIsIHRoaXMuc3Ryb2tlLmF1dG9BZGp1c3RlZCwgdGhpcy5tZXJnZWRTdHJpbmdzLmF1dG9BZGp1c3RTdHJva2UsIHRoaXMub25BdXRvQWRqdXN0U3Ryb2tlQ2hhbmdlKVxuICAgICAgICAgICAgOiBudWxsKSk7XG4gICAgfVxuICAgIHJlbmRlclN5bWJvbFNpemVDb250ZW50KCkge1xuICAgICAgICBjb25zdCB7IHNlY3Rpb25zOiB7IG1hcmtlcjogeyBwYXJ0czogeyBzaXplIH0gfSB9LCBtYXJrZXIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5lbCk7XG4gICAgICAgIGNvbnN0IG1heCA9IDE1MDtcbiAgICAgICAgY29uc3QgbWluID0gMTtcbiAgICAgICAgY29uc3QgYXV0b1NpemVBZGp1c3QgPSB0eXBlb2Ygc2l6ZSA9PT0gXCJvYmplY3RcIiAmJiAoc2l6ZSA9PT0gbnVsbCB8fCBzaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaXplLmF1dG9TaXplQWRqdXN0KTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb250ZW50R3JvdXAgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUsIGgoU2VsZWN0TnVtYmVyLCB7IGRpc2FibGVkOiBhdXRvU2l6ZUFkanVzdCAmJiBhdXRvU2l6ZUFkanVzdCAhPT0gXCJlZGl0YWJsZVwiICYmIG1hcmtlci5hdXRvQWRqdXN0ZWQsIG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLnB4LCB2YWx1ZTogbWFya2VyLnNpemUsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25TeW1ib2xTaXplQ2hhbmdlLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5zeW1ib2xTaXplIH0pKSwgYXV0b1NpemVBZGp1c3RcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJBdXRvQWRqdXN0KGRpciwgbWFya2VyLmF1dG9BZGp1c3RlZCwgdGhpcy5tZXJnZWRTdHJpbmdzLmF1dG9BZGp1c3RTaXplLCB0aGlzLm9uQXV0b0FkanVzdFNpemVDaGFuZ2UpXG4gICAgICAgICAgICA6IG51bGwpKTtcbiAgICB9XG4gICAgcmVuZGVyQXV0b0FkanVzdChkaXIsIGFkanVzdGVkLCBsYWJlbCwgY2hhbmdlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgY2xhc3M6IENTUy5hdXRvQWRqdXN0TGFiZWwsIGRpcjogZGlyLCBsYXlvdXQ6IFwiaW5saW5lXCIsIGtleTogXCJhdXRvLWFkanVzdFwiIH0sIGgoXCJjYWxjaXRlLWNoZWNrYm94XCIsIHsgY2hlY2tlZDogYWRqdXN0ZWQsIGNsYXNzOiBDU1MuYXV0b0FkanVzdENoZWNrYm94LCBvbkNhbGNpdGVDaGVja2JveENoYW5nZTogY2hhbmdlSGFuZGxlciB9KSwgbGFiZWwpKTtcbiAgICB9XG4gICAgcmVuZGVyU3ltYm9sUm90YXRpb25Db250ZW50KCkge1xuICAgICAgICBjb25zdCB7IG1hcmtlciwgbWVyZ2VkU3RyaW5ncyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbWF4ID0gMzYwO1xuICAgICAgICBjb25zdCBtaW4gPSAwO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3Mucm90YXRpb24sIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCJcXHUwMEJBXCIsIGZsaXBMYWJlbHM6IHRoaXMuZGlyID09PSBcInJ0bFwiLCB2YWx1ZTogbWFya2VyLmFuZ2xlLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uU3ltYm9sUm90YXRpb25DaGFuZ2UsIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogbWVyZ2VkU3RyaW5ncy5yb3RhdGlvbiB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJGaWxsQmxvY2soKSB7XG4gICAgICAgIGNvbnN0IHsgZmlsbCB9ID0gdGhpcy5jb25maWcuc2VjdGlvbnM7XG4gICAgICAgIGlmIChmaWxsLnR5cGUgPT09IFwiY29sb3JcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ29sb3JGaWxsQmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDb2xvclJhbXBGaWxsQmxvY2soKTtcbiAgICB9XG4gICAgcmVuZGVyQ29sb3JGaWxsQmxvY2soKSB7XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zLmZpbGw7XG4gICAgICAgIGNvbnN0IHsgcGFydHMgfSA9IHNlY3Rpb247XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgICAgICAgaWYgKHBhcnRzLnN1Z2dlc3RlZENvbG9ycyB8fCBwYXJ0cy5jdXN0b21Db2xvcikge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLnJlbmRlckZpbGxDb2xvckNvbnRlbnQoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzLnRyYW5zcGFyZW5jeSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb25cIiwgeyBlbWJlZGRlZDogdHJ1ZSwgZGlzYWJsZWQ6ICFzZWN0aW9uLmVuYWJsZWQgfSwgdGhpcy5yZW5kZXJDb2xvckZpbGxUcmFuc3BhcmVuY3lDb250ZW50KHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsVHJhbnNwYXJlbmN5LCAhc2VjdGlvbi5lbmFibGVkKSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTZWN0aW9uKHtcbiAgICAgICAgICAgIGtleTogXCJjb2xvci1maWxsXCIsXG4gICAgICAgICAgICBkaXNhYmxlZDogc2VjdGlvbi5vcHRpb25hbCA9PT0gXCJub24tZWRpdGFibGVcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaGFzQWN0aXZlUGljdHVyZU1hcmtlclN5bWJvbCgpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNBY3RpdmVMaW5lT25seVNpbXBsZU1hcmtlclN5bWJvbCgpLFxuICAgICAgICAgICAgc2VjdGlvbkNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvQ29sb3JQaWNrZXJWYWx1ZShjb2xvcikge1xuICAgICAgICBpZiAoIWNvbG9yIHx8IGlzTnVsbEVxdWl2YWxlbnRDb2xvcihjb2xvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvci50b0hleCgpO1xuICAgIH1cbiAgICByZW5kZXJGaWxsQ29sb3JDb250ZW50KCkge1xuICAgICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5zZWN0aW9ucy5maWxsO1xuICAgICAgICBjb25zdCBjb2xvciA9IHNlY3Rpb24uZW5hYmxlZCA/IHRoaXMudG9Db2xvclBpY2tlclZhbHVlKHRoaXMuZmlsbC5jb2xvcikgOiBudWxsO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsQ29sb3IsIGgoXCJhcmNnaXMtY29sb3ItaW5wdXRcIiwgeyBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAvL2NvbXBhY3Q9e3RoaXMubmFycm93fVxuICAgICAgICAgICAgY2xlYXJhYmxlOiBzZWN0aW9uLm9wdGlvbmFsICE9PSBmYWxzZSwgb25BcmNnaXNDb2xvcklucHV0Q2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZENvbG9yID0gZXZlbnQuY3VycmVudFRhcmdldC5jb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZpbGxFbmFibGVkQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gdXBkYXRlcyB0byBjb2xvciBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlY3Rpb24uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRmlsbEVuYWJsZWRDaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gY3JlYXRlKHNlbGVjdGVkQ29sb3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29sb3I6IGN1cnJlbnRDb2xvciB9ID0gdGhpcy5maWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlZENvbG9yID0gYWRqdXN0VHJhbnNwYXJlbmN5SWZOZWVkZWQoY3VycmVudENvbG9yLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudENvbG9yKSwgY29sb3IpLCB7IGE6IGN1cnJlbnRDb2xvci5hIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWRGaWxsID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY3JlYXRlKG1lcmdlZENvbG9yKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsID0gbWVyZ2VkRmlsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlckZpbGxDaGFuZ2UuZW1pdChtZXJnZWRGaWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9LCBwb3BvdmVyUHJvcHM6IHRoaXMucG9wb3ZlclByb3BzLCBzdG9yYWdlSWQ6IGNvbG9yU3RvcmFnZUlkLCByZWY6IHRoaXMuc2V0Q29sb3JJbnB1dFJlZiB9KSkpO1xuICAgIH1cbiAgICBnZXRTdHJva2VTdHJpbmcocHJvcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZWRTdHJpbmdzW3RoaXMuZWRpdEdlb21ldHJ5ID09PSBcImxpbmVcIiA/IHByb3AgOiBgc3Ryb2tlJHtjYXBpdGFsaXplKHByb3ApfWBdO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZFN5bWJvbExheWVyVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiAodHlwZSA9PT0gXCJDSU1WZWN0b3JNYXJrZXJcIiB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gXCJDSU1Tb2xpZEZpbGxcIiB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gXCJDSU1Tb2xpZFN0cm9rZVwiIHx8XG4gICAgICAgICAgICB0eXBlID09PSBcIkNJTUhhdGNoRmlsbFwiIHx8XG4gICAgICAgICAgICB0eXBlID09PSBcIkNJTVBpY3R1cmVGaWxsXCIgfHxcbiAgICAgICAgICAgIHR5cGUgPT09IFwiQ0lNUGljdHVyZVN0cm9rZVwiIHx8XG4gICAgICAgICAgICB0eXBlID09PSBcIkNJTVBpY3R1cmVNYXJrZXJcIik7XG4gICAgfVxuICAgIGdldFN5bWJvbExheWVyUHJldmlld1N5bWJvbChzeW1ib2xMYXllciwgZ2VvbWV0cnlUeXBlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc3ltYm9sUHJvcHMgPSB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJDSU1TeW1ib2xSZWZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICBzeW1ib2w6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2VvbWV0cnlUeXBlID09PSBcInBvaW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJDSU1Qb2ludFN5bWJvbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGdlb21ldHJ5VHlwZSA9PT0gXCJsaW5lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiQ0lNTGluZVN5bWJvbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIkNJTVBvbHlnb25TeW1ib2xcIixcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sTGF5ZXJzOiBbc3ltYm9sTGF5ZXJdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3ltYm9sTGF5ZXIudHlwZSA9PT0gXCJDSU1WZWN0b3JNYXJrZXJcIikge1xuICAgICAgICAgICAgc3ltYm9sUHJvcHMuZGF0YS5zeW1ib2wuYW5nbGUgPSAoX2EgPSBzeW1ib2xMYXllci5yb3RhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGVzcmlNb2R1bGVzLkNJTVN5bWJvbChzeW1ib2xQcm9wcyk7XG4gICAgfVxuICAgIHJlbmRlckNJTVZlY3Rvck1hcmtlclN5bWJvbExheWVyQmxvY2tzKHN5bWJvbExheWVyLCBrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJtaW5pbWFsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2VjdGlvbnM6IHsgbWFya2VyOiB7IHBhcnRzOiB7IHNpemUgfSB9LCBzdHJva2U6IHsgZXh0cmFQYXJ0czogeyBhdXRvU3Ryb2tlQWRqdXN0IH0gfSB9LCBtYXJrZXIsIG1lcmdlZFN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGF1dG9TaXplQWRqdXN0ID0gdHlwZW9mIHNpemUgPT09IFwib2JqZWN0XCIgJiYgKHNpemUgPT09IG51bGwgfHwgc2l6ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2l6ZS5hdXRvU2l6ZUFkanVzdCk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVRhcmdldFN5bWJvbCA9IHRoaXMuZ2V0U3ltYm9sTGF5ZXJQcmV2aWV3U3ltYm9sKHN5bWJvbExheWVyLCBcInBvaW50XCIpO1xuICAgICAgICBjb25zdCBzeW1ib2xTaXplID0gZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuZ2V0Q0lNU3ltYm9sU2l6ZSh1cGRhdGVUYXJnZXRTeW1ib2wpO1xuICAgICAgICBjb25zdCBzeW1ib2xSb3RhdGlvbiA9IGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbFJvdGF0aW9uKHVwZGF0ZVRhcmdldFN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGNvbG9yQ29udGV4dCA9IGdldENoaWxkU3ltYm9sTGF5ZXJDb2xvckNvbnRleHQoc3ltYm9sTGF5ZXIpO1xuICAgICAgICBjb25zdCBmaWxsQW5kU3Ryb2tlU2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGNvbG9yQ29udGV4dC5pbmNsdWRlcyhcImZpbGxcIikgJiYgKCF0aGlzLmlzRmlsbENvbG9yUmFtcCgpIHx8IHN5bWJvbExheWVyLmNvbG9yTG9ja2VkKSkge1xuICAgICAgICAgICAgY29uc3QgZmlsbENvbG9yID0gZ2V0VmVjdG9yTWFya2VyQ29sb3Ioc3ltYm9sTGF5ZXIsIFwiZmlsbFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGxDb250ZW50ID0gW1xuICAgICAgICAgICAgICAgIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsga2V5OiBcImZpbGwtY29sb3JcIiB9LCBjb2xvckNvbnRleHQubGVuZ3RoID09PSAxID8gbWVyZ2VkU3RyaW5ncy5jb2xvciA6IG1lcmdlZFN0cmluZ3MuZmlsbENvbG9yLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaW5wdXQtY29sb3JcIiB9LCBoKFwiYXJjZ2lzLWNvbG9yLWlucHV0XCIsIHsgY29sb3I6IHRoaXMudG9Db2xvclBpY2tlclZhbHVlKGZpbGxDb2xvciksXG4gICAgICAgICAgICAgICAgICAgIC8vY29tcGFjdD17dGhpcy5uYXJyb3d9XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyYWJsZTogdHJ1ZSwgb25BcmNnaXNDb2xvcklucHV0Q2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gY3JlYXRlKGV2ZW50LmN1cnJlbnRUYXJnZXQuY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGxFcXVpdmFsZW50Q29sb3IoY29sb3IpICYmICFpc051bGxFcXVpdmFsZW50Q29sb3IoZmlsbENvbG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLmEgPSBmaWxsQ29sb3IuYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN5bWJvbExheWVyQ29sb3Ioc3ltYm9sTGF5ZXIsIGNvbG9yLCBcImZpbGxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9LCBwb3BvdmVyUHJvcHM6IHRoaXMucG9wb3ZlclByb3BzLCBzdG9yYWdlSWQ6IGNvbG9yU3RvcmFnZUlkLCByZWY6IHRoaXMuc2V0Q29sb3JJbnB1dFJlZiB9KSkpLFxuICAgICAgICAgICAgICAgIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsga2V5OiBcImZpbGwtdHJhbnNwYXJlbmN5XCIgfSwgY29sb3JDb250ZXh0Lmxlbmd0aCA9PT0gMSA/IG1lcmdlZFN0cmluZ3MudHJhbnNwYXJlbmN5IDogbWVyZ2VkU3RyaW5ncy5maWxsVHJhbnNwYXJlbmN5LCBoKFNlbGVjdE51bWJlciwgeyBtaW46IG9wYWNpdHlNaW4sIG1heDogb3BhY2l0eU1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCIlXCIsIGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgdmFsdWU6IGFscGhhVG9UcmFuc3BhcmVuY3koZmlsbENvbG9yLmEpLCBvblZhbHVlQ2hhbmdlOiAodHJhbnNwYXJlbmN5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEodHJhbnNwYXJlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gZmlsbENvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvci5hID0gYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTeW1ib2xMYXllckNvbG9yKHN5bWJvbExheWVyLCBjb2xvciwgXCJmaWxsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogY29sb3JDb250ZXh0Lmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtZXJnZWRTdHJpbmdzLnRyYW5zcGFyZW5jeVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtZXJnZWRTdHJpbmdzLmZpbGxUcmFuc3BhcmVuY3kgfSkpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZmlsbEFuZFN0cm9rZVNlY3Rpb25zLnB1c2goZmlsbENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvckNvbnRleHQuaW5jbHVkZXMoXCJzdHJva2VcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gZ2V0VmVjdG9yTWFya2VyQ29sb3Ioc3ltYm9sTGF5ZXIsIFwic3Ryb2tlXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBnZXRWZWN0b3JNYXJrZXJTaXplKHN5bWJvbExheWVyLCBcInN0cm9rZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZUNvbnRlbnQgPSBbXG4gICAgICAgICAgICAgICAgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBrZXk6IFwic3Ryb2tlLWNvbG9yXCIgfSwgY29sb3JDb250ZXh0Lmxlbmd0aCA9PT0gMSA/IG1lcmdlZFN0cmluZ3MuY29sb3IgOiBtZXJnZWRTdHJpbmdzLnN0cm9rZUNvbG9yLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaW5wdXQtY29sb3JcIiB9LCBoKFwiYXJjZ2lzLWNvbG9yLWlucHV0XCIsIHsgY29sb3I6IHRoaXMudG9Db2xvclBpY2tlclZhbHVlKHN0cm9rZUNvbG9yKSxcbiAgICAgICAgICAgICAgICAgICAgLy9jb21wYWN0PXt0aGlzLm5hcnJvd31cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJhYmxlOiB0cnVlLCBvbkFyY2dpc0NvbG9ySW5wdXRDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBjcmVhdGUoZXZlbnQuY3VycmVudFRhcmdldC5jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbEVxdWl2YWxlbnRDb2xvcihjb2xvcikgJiYgIWlzTnVsbEVxdWl2YWxlbnRDb2xvcihzdHJva2VDb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvci5hID0gc3Ryb2tlQ29sb3IuYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN5bWJvbExheWVyQ29sb3Ioc3ltYm9sTGF5ZXIsIGNvbG9yLCBcInN0cm9rZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHBvcG92ZXJQcm9wczogdGhpcy5wb3BvdmVyUHJvcHMsIHN0b3JhZ2VJZDogY29sb3JTdG9yYWdlSWQsIHJlZjogdGhpcy5zZXRDb2xvcklucHV0UmVmIH0pKSksXG4gICAgICAgICAgICAgICAgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBrZXk6IFwic3Ryb2tlLXRyYW5zcGFyZW5jeVwiIH0sIGNvbG9yQ29udGV4dC5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICAgICAgICAgPyBtZXJnZWRTdHJpbmdzLnRyYW5zcGFyZW5jeVxuICAgICAgICAgICAgICAgICAgICA6IG1lcmdlZFN0cmluZ3Muc3Ryb2tlVHJhbnNwYXJlbmN5LCBoKFNlbGVjdE51bWJlciwgeyBtaW46IG9wYWNpdHlNaW4sIG1heDogb3BhY2l0eU1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCIlXCIsIGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgdmFsdWU6IGFscGhhVG9UcmFuc3BhcmVuY3koc3Ryb2tlQ29sb3IuYSksIG9uVmFsdWVDaGFuZ2U6ICh0cmFuc3BhcmVuY3kpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFscGhhID0gdHJhbnNwYXJlbmN5VG9BbHBoYSh0cmFuc3BhcmVuY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBzdHJva2VDb2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IuYSA9IGFscGhhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU3ltYm9sTGF5ZXJDb2xvcihzeW1ib2xMYXllciwgY29sb3IsIFwic3Ryb2tlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogY29sb3JDb250ZXh0Lmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtZXJnZWRTdHJpbmdzLnRyYW5zcGFyZW5jeVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtZXJnZWRTdHJpbmdzLnN0cm9rZVRyYW5zcGFyZW5jeSB9KSksXG4gICAgICAgICAgICAgICAgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBrZXk6IFwic3Ryb2tlLXdpZHRoXCIgfSwgY29sb3JDb250ZXh0Lmxlbmd0aCA9PT0gMSA/IG1lcmdlZFN0cmluZ3Mud2lkdGggOiBtZXJnZWRTdHJpbmdzLnN0cm9rZVdpZHRoLCBoKFNlbGVjdE51bWJlciwgeyBkaXNhYmxlZDogYXV0b1N0cm9rZUFkanVzdCAmJiBhdXRvU3Ryb2tlQWRqdXN0ICE9PSBcImVkaXRhYmxlXCIgJiYgdGhpcy5zdHJva2UuYXV0b0FkanVzdGVkLCBtaW46IHRoaXMuY2ltU3Ryb2tlV2lkdGhCb3VuZHMubWluLCBtYXg6IHRoaXMuY2ltU3Ryb2tlV2lkdGhCb3VuZHMubWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiBtZXJnZWRTdHJpbmdzLnB4LCB2YWx1ZTogbm9ybWFsaXplUHgoZXNyaU1vZHVsZXMuc2NyZWVuVXRpbHMucHQycHgoc3Ryb2tlV2lkdGgpKSwgb25WYWx1ZUNoYW5nZTogKHdpZHRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTeW1ib2xMYXllclNpemUoc3ltYm9sTGF5ZXIsIG5vcm1hbGl6ZVB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB4MnB0KHdpZHRoKSksIFwic3Ryb2tlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogY29sb3JDb250ZXh0Lmxlbmd0aCA9PT0gMSA/IG1lcmdlZFN0cmluZ3Mud2lkdGggOiBtZXJnZWRTdHJpbmdzLnN0cm9rZVdpZHRoIH0pKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZpbGxBbmRTdHJva2VTZWN0aW9ucy5wdXNoKHN0cm9rZUNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGVudEdyb3VwLCBrZXk6IGAke2tleX1fX3ZlY3Rvci1tYXJrZXItc3ltYm9sLWxheWVyYCB9LCBbLi4uZmlsbEFuZFN0cm9rZVNlY3Rpb25zXSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5zeW1ib2xTaXplLCBoKFNlbGVjdE51bWJlciwgeyBkaXNhYmxlZDogYXV0b1NpemVBZGp1c3QgJiYgYXV0b1NpemVBZGp1c3QgIT09IFwiZWRpdGFibGVcIiAmJiBtYXJrZXIuYXV0b0FkanVzdGVkLCBtaW46IHNpemVNaW4sIG1heDogc2l6ZU1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogbWVyZ2VkU3RyaW5ncy5weCwgdmFsdWU6IG5vcm1hbGl6ZVB4KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB0MnB4KHN5bWJvbFNpemUpKSwgb25WYWx1ZUNoYW5nZTogKHNpemUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1hcmtlclN5bWJvbExheWVyU2l6ZSh1cGRhdGVUYXJnZXRTeW1ib2wsIHNpemUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgfSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiBtZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUgfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBtZXJnZWRTdHJpbmdzLnJvdGF0aW9uLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IHJvdGF0aW9uTWluLCBtYXg6IHJvdGF0aW9uTWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiBcIlxcdTAwQkFcIiwgZmxpcExhYmVsczogdGhpcy5kaXIgPT09IFwicnRsXCIsIHZhbHVlOiBub3JtYWxpemVQeE9yUHQoc3ltYm9sUm90YXRpb24pLCBvblZhbHVlQ2hhbmdlOiAocm90YXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBlc3JpTW9kdWxlcy5jaW1TeW1ib2xVdGlscy5hcHBseUNJTVN5bWJvbFJvdGF0aW9uKHVwZGF0ZVRhcmdldFN5bWJvbCwgbm9ybWFsaXplUHhPclB0KHJvdGF0aW9uKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3Mucm90YXRpb24gfSkpLCB0aGlzLnJlbmRlckNJTU1hcmtlclBsYWNlbWVudFNlY3Rpb24oc3ltYm9sTGF5ZXIpKSk7XG4gICAgICAgIGNvbnN0IHN5bWJvbExheWVyUHJldmlldyA9IHRoaXMuZ2V0U3ltYm9sTGF5ZXJQcmV2aWV3U3ltYm9sKHRoaXMuc2FuaXRpemVQb2ludFByZXZpZXdTeW1ib2xMYXllcihzeW1ib2xMYXllciksIFwicG9pbnRcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckJsb2NrKHtcbiAgICAgICAgICAgIGljb246IChoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc3ltYm9sLXByZXZpZXdcIiwgeyBjb250cmFzdDogdHJ1ZSwga2V5OiBgJHtrZXl9X19zeW1ib2wtbGF5ZXItcHJldmlld2AsIHN5bWJvbDogc3ltYm9sTGF5ZXJQcmV2aWV3LCBvcHRpb25zOiBwb2ludFByZXZpZXdPcHRpb25zLCBzbG90OiBcImljb25cIiB9KSksXG4gICAgICAgICAgICBrZXk6IGAke2tleX1fX3N5bWJvbC1sYXllcmAsXG4gICAgICAgICAgICBoZWFkaW5nOiBtZXJnZWRTdHJpbmdzLnZlY3Rvck1hcmtlcixcbiAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldE1hcmtlclN5bWJvbExheWVyU2l6ZShzeW1ib2wsIHNpemUpIHtcbiAgICAgICAgaWYgKGlzUG9pbnRDSU0odGhpcy5hY3RpdmVTeW1ib2wpKSB7XG4gICAgICAgICAgICBzeW1ib2wuZGF0YS5zeW1ib2wuc3ltYm9sTGF5ZXJzWzBdLnNpemUgPSBub3JtYWxpemVQdChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5weDJwdChzaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlc3JpTW9kdWxlcy5jaW1TeW1ib2xVdGlscy5zY2FsZUNJTVN5bWJvbFRvKHN5bWJvbCwgbm9ybWFsaXplUHQoZXNyaU1vZHVsZXMuc2NyZWVuVXRpbHMucHgycHQoc2l6ZSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJDSU1Tb2xpZEZpbGxTeW1ib2xMYXllckJsb2NrKHN5bWJvbExheWVyLCBrZXksIGNvbnRlbnRPbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJtaW5pbWFsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbGxDb2xvciA9IGNyZWF0ZShzeW1ib2xMYXllci5jb2xvciwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IG5vRmlsbENvbG9yID0gaXNOdWxsRXF1aXZhbGVudENvbG9yKGZpbGxDb2xvcik7XG4gICAgICAgIGxldCBjb2xvckNvbnRlbnQgPSBudWxsO1xuICAgICAgICBsZXQgdHJhbnNwYXJlbmN5Q29udGVudCA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5pc0ZpbGxDb2xvclJhbXAoKSB8fCBzeW1ib2xMYXllci5jb2xvckxvY2tlZCkge1xuICAgICAgICAgICAgY29sb3JDb250ZW50ID0gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsQ29sb3IsIGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbnB1dC1jb2xvclwiIH0sIGgoXCJhcmNnaXMtY29sb3ItaW5wdXRcIiwgeyBjb2xvcjogdGhpcy50b0NvbG9yUGlja2VyVmFsdWUoZmlsbENvbG9yKSxcbiAgICAgICAgICAgICAgICAvL2NvbXBhY3Q9e3RoaXMubmFycm93fVxuICAgICAgICAgICAgICAgIGNsZWFyYWJsZTogdHJ1ZSwgb25BcmNnaXNDb2xvcklucHV0Q2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBjcmVhdGUoZXZlbnQuY3VycmVudFRhcmdldC5jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsRXF1aXZhbGVudENvbG9yKGNvbG9yKSAmJiAhbm9GaWxsQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLmEgPSBmaWxsQ29sb3IuYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xMYXllci5jb2xvciA9IGNvbG9yLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSwgcG9wb3ZlclByb3BzOiB0aGlzLnBvcG92ZXJQcm9wcywgc3RvcmFnZUlkOiBjb2xvclN0b3JhZ2VJZCwgcmVmOiB0aGlzLnNldENvbG9ySW5wdXRSZWYgfSkpKSk7XG4gICAgICAgICAgICB0cmFuc3BhcmVuY3lDb250ZW50ID0gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsVHJhbnNwYXJlbmN5LCBoKFNlbGVjdE51bWJlciwgeyBmbGlwTGFiZWxzOiB0aGlzLnBlcmNlbnRMYWJlbEZsaXAsIG1pbjogb3BhY2l0eU1pbiwgbWF4OiBvcGFjaXR5TWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiBcIiVcIiwgdmFsdWU6IGFscGhhVG9UcmFuc3BhcmVuY3koZmlsbENvbG9yLmEpLCBkaXNhYmxlZDogbm9GaWxsQ29sb3IsIG9uVmFsdWVDaGFuZ2U6ICh0cmFuc3BhcmVuY3kpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxwaGEgPSB0cmFuc3BhcmVuY3lUb0FscGhhKHRyYW5zcGFyZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gZmlsbENvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yLmEgPSBhbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sTGF5ZXIuY29sb3IgPSBjb2xvci50b0pTT04oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3MuZmlsbFRyYW5zcGFyZW5jeSB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBjb2xvckNvbnRlbnQgfHwgdHJhbnNwYXJlbmN5Q29udGVudCA/IChoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvblwiLCB7IGVtYmVkZGVkOiB0cnVlLCBrZXk6IGAke2tleX1fX3NvbGlkLWZpbGwtc3ltYm9sLWxheWVyLWNvbnRlbnRgIH0sIGNvbG9yQ29udGVudCwgaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb25cIiwgeyBlbWJlZGRlZDogdHJ1ZSwgZGlzYWJsZWQ6IG5vRmlsbENvbG9yIH0sIHRyYW5zcGFyZW5jeUNvbnRlbnQpKSkgOiAoaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLmVtcHR5U3ltYm9sTGF5ZXJNc2cpKTtcbiAgICAgICAgaWYgKGNvbnRlbnRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzeW1ib2xMYXllclByZXZpZXcgPSB0aGlzLmdldFN5bWJvbExheWVyUHJldmlld1N5bWJvbChzeW1ib2xMYXllciwgXCJwb2x5Z29uXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJCbG9jayh7XG4gICAgICAgICAgICBpY29uOiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXN5bWJvbC1wcmV2aWV3XCIsIHsgY29udHJhc3Q6IHRydWUsIGtleTogYCR7a2V5fV9fc29saWQtZmlsbC1zeW1ib2wtbGF5ZXItcHJldmlld2AsIHN5bWJvbDogc3ltYm9sTGF5ZXJQcmV2aWV3LCBzbG90OiBcImljb25cIiB9KSksXG4gICAgICAgICAgICBoZWFkaW5nOiB0aGlzLm1lcmdlZFN0cmluZ3Muc29saWRGaWxsLFxuICAgICAgICAgICAga2V5OiBgJHtrZXl9X19zb2xpZC1maWxsLXN5bWJvbC1sYXllcmAsXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXJDSU1Tb2xpZFN0cm9rZVN5bWJvbExheWVyQmxvY2soc3ltYm9sTGF5ZXIsIGtleSwgY29udGVudE9ubHkgPSBmYWxzZSwgcGFyZW50U3ltYm9sTGF5ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJtaW5pbWFsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gY3JlYXRlKHN5bWJvbExheWVyLmNvbG9yLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgd2l0aGluSGF0Y2hGaWxsU3ltYm9sTGF5ZXIgPSAocGFyZW50U3ltYm9sTGF5ZXIgPT09IG51bGwgfHwgcGFyZW50U3ltYm9sTGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudFN5bWJvbExheWVyLnR5cGUpID09PSBcIkNJTUhhdGNoRmlsbFwiO1xuICAgICAgICBjb25zdCBvdmVycmlkZGVuQnlDb2xvclJhbXAgPSB3aXRoaW5IYXRjaEZpbGxTeW1ib2xMYXllciAmJiB0aGlzLmlzRmlsbENvbG9yUmFtcCgpO1xuICAgICAgICBjb25zdCBhdXRvU3Ryb2tlQWRqdXN0ID0gdGhpcy5zZWN0aW9ucy5zdHJva2UuZXh0cmFQYXJ0cy5hdXRvU3Ryb2tlQWRqdXN0O1xuICAgICAgICBjb25zdCBub1N0cm9rZUNvbG9yID0gaXNOdWxsRXF1aXZhbGVudENvbG9yKHN0cm9rZUNvbG9yKTtcbiAgICAgICAgbGV0IGNvbG9yQ29udGVudCA9IG51bGw7XG4gICAgICAgIGxldCB0cmFuc3BhcmVuY3lDb250ZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3Ryb2tlQ29sb3JSYW1wKCkgfHwgc3ltYm9sTGF5ZXIuY29sb3JMb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbG9yQ29udGVudCA9IChoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGtleTogXCJzdHJva2UtY29sb3JcIiB9LCBjb250ZW50T25seSA/IHRoaXMubWVyZ2VkU3RyaW5ncy5zdHJva2VDb2xvciA6IHRoaXMubWVyZ2VkU3RyaW5ncy5jb2xvciwgaChcImRpdlwiLCB7IGNsYXNzOiBcImlucHV0LWNvbG9yXCIgfSwgaChcImFyY2dpcy1jb2xvci1pbnB1dFwiLCB7IGNvbG9yOiB0aGlzLnRvQ29sb3JQaWNrZXJWYWx1ZShzdHJva2VDb2xvciksXG4gICAgICAgICAgICAgICAgLy9jb21wYWN0PXt0aGlzLm5hcnJvd31cbiAgICAgICAgICAgICAgICBjbGVhcmFibGU6IHRydWUsIG9uQXJjZ2lzQ29sb3JJbnB1dENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gY3JlYXRlKGV2ZW50LmN1cnJlbnRUYXJnZXQuY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbEVxdWl2YWxlbnRDb2xvcihjb2xvcikgJiYgIW5vU3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLmEgPSBzdHJva2VDb2xvci5hO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbExheWVyLmNvbG9yID0gY29sb3IudG9KU09OKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9LCBwb3BvdmVyUHJvcHM6IHRoaXMucG9wb3ZlclByb3BzLCBzdG9yYWdlSWQ6IGNvbG9yU3RvcmFnZUlkLCByZWY6IHRoaXMuc2V0Q29sb3JJbnB1dFJlZiB9KSkpKTtcbiAgICAgICAgICAgIHRyYW5zcGFyZW5jeUNvbnRlbnQgPSAoaChcImNhbGNpdGUtbGFiZWxcIiwgeyBrZXk6IFwic3Ryb2tlLXRyYW5zcGFyZW5jeVwiIH0sIGNvbnRlbnRPbmx5ID8gdGhpcy5tZXJnZWRTdHJpbmdzLnN0cm9rZVRyYW5zcGFyZW5jeSA6IHRoaXMubWVyZ2VkU3RyaW5ncy50cmFuc3BhcmVuY3ksIGgoU2VsZWN0TnVtYmVyLCB7IGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgbWluOiBvcGFjaXR5TWluLCBtYXg6IG9wYWNpdHlNYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IFwiJVwiLCB2YWx1ZTogYWxwaGFUb1RyYW5zcGFyZW5jeShzdHJva2VDb2xvci5hKSwgZGlzYWJsZWQ6IG5vU3Ryb2tlQ29sb3IsIG9uVmFsdWVDaGFuZ2U6ICh0cmFuc3BhcmVuY3kpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxwaGEgPSB0cmFuc3BhcmVuY3lUb0FscGhhKHRyYW5zcGFyZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gc3Ryb2tlQ29sb3IuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IuYSA9IGFscGhhO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xMYXllci5jb2xvciA9IGNvbG9yLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IGNvbnRlbnRPbmx5ID8gdGhpcy5tZXJnZWRTdHJpbmdzLnN0cm9rZVRyYW5zcGFyZW5jeSA6IHRoaXMubWVyZ2VkU3RyaW5ncy50cmFuc3BhcmVuY3kgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50ID0gKGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uXCIsIHsgZW1iZWRkZWQ6IHRydWUsIGtleTogYCR7a2V5fV9fc29saWQtc3Ryb2tlLXN5bWJvbC1sYXllci1jb250ZW50YCB9LCBvdmVycmlkZGVuQnlDb2xvclJhbXAgPyBudWxsIDogY29sb3JDb250ZW50LCBoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvblwiLCB7IGVtYmVkZGVkOiB0cnVlLCBkaXNhYmxlZDogbm9TdHJva2VDb2xvciB9LCBvdmVycmlkZGVuQnlDb2xvclJhbXAgPyBudWxsIDogdHJhbnNwYXJlbmN5Q29udGVudCwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgY29udGVudE9ubHkgPyB0aGlzLm1lcmdlZFN0cmluZ3Muc3Ryb2tlV2lkdGggOiB0aGlzLm1lcmdlZFN0cmluZ3Mud2lkdGgsIGgoU2VsZWN0TnVtYmVyLCB7IGRpc2FibGVkOiBub1N0cm9rZUNvbG9yIHx8XG4gICAgICAgICAgICAgICAgKGF1dG9TdHJva2VBZGp1c3QgJiYgYXV0b1N0cm9rZUFkanVzdCAhPT0gXCJlZGl0YWJsZVwiICYmIHRoaXMuc3Ryb2tlLmF1dG9BZGp1c3RlZCksIG1pbjogdGhpcy5jaW1TdHJva2VXaWR0aEJvdW5kcy5taW4sIG1heDogdGhpcy5jaW1TdHJva2VXaWR0aEJvdW5kcy5tYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5weCwgdmFsdWU6IG5vcm1hbGl6ZVB4KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB0MnB4KHN5bWJvbExheWVyLndpZHRoKSksIG9uVmFsdWVDaGFuZ2U6ICh3aWR0aCkgPT4ge1xuICAgICAgICAgICAgICAgIHN5bWJvbExheWVyLndpZHRoID0gbm9ybWFsaXplUHQoZXNyaU1vZHVsZXMuc2NyZWVuVXRpbHMucHgycHQod2lkdGgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogY29udGVudE9ubHkgPyB0aGlzLm1lcmdlZFN0cmluZ3Muc3Ryb2tlV2lkdGggOiB0aGlzLm1lcmdlZFN0cmluZ3Mud2lkdGggfSkpKSwgd2l0aGluSGF0Y2hGaWxsU3ltYm9sTGF5ZXJcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJDSU1IYXRjaEZpbGxQYXR0ZXJuU2VjdGlvbihwYXJlbnRTeW1ib2xMYXllcilcbiAgICAgICAgICAgIDogbnVsbCkpO1xuICAgICAgICBpZiAoY29udGVudE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN5bWJvbExheWVyUHJldmlldyA9IHdpdGhpbkhhdGNoRmlsbFN5bWJvbExheWVyXG4gICAgICAgICAgICA/IHRoaXMuZ2V0U3ltYm9sTGF5ZXJQcmV2aWV3U3ltYm9sKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50U3ltYm9sTGF5ZXIpLCB7IGxpbmVTeW1ib2w6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJDSU1MaW5lU3ltYm9sXCIsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbExheWVyczogW3N5bWJvbExheWVyXVxuICAgICAgICAgICAgICAgIH0gfSksIFwicG9seWdvblwiKVxuICAgICAgICAgICAgOiB0aGlzLmdldFN5bWJvbExheWVyUHJldmlld1N5bWJvbChzeW1ib2xMYXllciwgXCJsaW5lXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJCbG9jayh7XG4gICAgICAgICAgICBpY29uOiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXN5bWJvbC1wcmV2aWV3XCIsIHsgY29udHJhc3Q6IHRydWUsIGtleTogYCR7a2V5fV9fc29saWQtc3Ryb2tlLXN5bWJvbC1sYXllci1wcmV2aWV3YCwgc3ltYm9sOiBzeW1ib2xMYXllclByZXZpZXcsIHNsb3Q6IFwiaWNvblwiIH0pKSxcbiAgICAgICAgICAgIGhlYWRpbmc6IHdpdGhpbkhhdGNoRmlsbFN5bWJvbExheWVyXG4gICAgICAgICAgICAgICAgPyB0aGlzLm1lcmdlZFN0cmluZ3MuaGF0Y2hGaWxsXG4gICAgICAgICAgICAgICAgOiB0aGlzLm1lcmdlZFN0cmluZ3Muc29saWRTdHJva2UsXG4gICAgICAgICAgICBrZXk6IGAke2tleX1fX3NvbGlkLXN0cm9rZS1zeW1ib2wtbGF5ZXJgLFxuICAgICAgICAgICAgY29udGVudFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyQ0lNSGF0Y2hGaWxsU3ltYm9sTGF5ZXJCbG9ja3Moc3ltYm9sTGF5ZXIsIGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDSU1TeW1ib2xMYXllcnNDb250ZW50KHN5bWJvbExheWVyLmxpbmVTeW1ib2wsIGAke2tleX1fX2hhdGNoLXN5bWJvbC1maWxsLXN5bWJvbC1sYXllcnNgLCBmYWxzZSwgc3ltYm9sTGF5ZXIpLmZsYXQoKTtcbiAgICB9XG4gICAgcmVuZGVyQ0lNSGF0Y2hGaWxsUGF0dGVyblNlY3Rpb24oc3ltYm9sTGF5ZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHsgbWVyZ2VkU3RyaW5ncyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZmlsbE9mZnNldCA9IChfYSA9IHN5bWJvbExheWVyLm9mZnNldFgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7IC8vIHdlIGFwcGx5IG9mZnNldCB1bmlmb3JtbHksIHNvIHdlIHVzZSB0YWtlIFhcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ibG9jay1zZWN0aW9uXCIsIHsga2V5OiBcImhhdGNoLWZpbGwtcGF0dGVyblwiLCB0ZXh0OiBtZXJnZWRTdHJpbmdzLnBhdHRlcm4gfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5yb3RhdGlvbiwgaChTZWxlY3ROdW1iZXIsIHsgZmxpcExhYmVsczogdGhpcy5kaXIgPT09IFwicnRsXCIsIG1heDogcm90YXRpb25NYXgsIG1pbjogcm90YXRpb25NaW4sIG9uVmFsdWVDaGFuZ2U6IChyb3RhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHN5bWJvbExheWVyLnJvdGF0aW9uID0gTWF0aC5hYnMocm90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgfSwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCJcXHUwMEJBXCIsIHZhbHVlOiAoX2IgPSBzeW1ib2xMYXllci5yb3RhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiBtZXJnZWRTdHJpbmdzLnJvdGF0aW9uIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5zZXBhcmF0aW9uLCBoKFNlbGVjdE51bWJlciwgeyBmbGlwTGFiZWxzOiB0aGlzLmRpciA9PT0gXCJydGxcIiwgbWF4OiBoYXRjaEZpbGxTZXBhcmF0aW9uTWF4LCBtaW46IGhhdGNoRmlsbFNlcGFyYXRpb25NaW4sIG9uVmFsdWVDaGFuZ2U6IChzZXBhcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sTGF5ZXIuc2VwYXJhdGlvbiA9IHNlcGFyYXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBzdGVwOiAxLCB2YWx1ZTogKF9jID0gc3ltYm9sTGF5ZXIuc2VwYXJhdGlvbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCwgdW5pdHNMYWJlbDogbWVyZ2VkU3RyaW5ncy5weCwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiBtZXJnZWRTdHJpbmdzLnNlcGFyYXRpb24gfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBtZXJnZWRTdHJpbmdzLm9mZnNldCwgaChTZWxlY3ROdW1iZXIsIHsgZmxpcExhYmVsczogdGhpcy5kaXIgPT09IFwicnRsXCIsIG1heDogaGF0Y2hGaWxsT2Zmc2V0TWF4LCBtaW46IGhhdGNoRmlsbE9mZnNldE1pbiwgb25WYWx1ZUNoYW5nZTogKG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHN5bWJvbExheWVyLm9mZnNldFggPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgc3ltYm9sTGF5ZXIub2Zmc2V0WSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgIH0sIHN0ZXA6IDEsIHZhbHVlOiBmaWxsT2Zmc2V0LCB1bml0c0xhYmVsOiBtZXJnZWRTdHJpbmdzLnB4LCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3Mub2Zmc2V0IH0pKSkpO1xuICAgIH1cbiAgICByZW5kZXJDSU1QaWN0dXJlTWFya2VyU3ltYm9sTGF5ZXJCbG9jayhzeW1ib2xMYXllciwga2V5LCBjb250ZW50T25seSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwibWluaW1hbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW50Q29sb3IgPSBjcmVhdGUoc3ltYm9sTGF5ZXIudGludENvbG9yLCB0cnVlKTtcbiAgICAgICAgY29uc3QgeyBzZWN0aW9uczogeyBtYXJrZXI6IHsgcGFydHM6IHsgc2l6ZSB9IH0gfSwgbWFya2VyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBhdXRvU2l6ZUFkanVzdCA9IHR5cGVvZiBzaXplID09PSBcIm9iamVjdFwiICYmIChzaXplID09PSBudWxsIHx8IHNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpemUuYXV0b1NpemVBZGp1c3QpO1xuICAgICAgICBjb25zdCB1cGRhdGVUYXJnZXRTeW1ib2wgPSB0aGlzLmdldFN5bWJvbExheWVyUHJldmlld1N5bWJvbChzeW1ib2xMYXllciwgXCJwb2ludFwiKTtcbiAgICAgICAgY29uc3Qgbm9UaW50Q29sb3IgPSBpc051bGxFcXVpdmFsZW50Q29sb3IodGludENvbG9yKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IChoKFwiZGl2XCIsIHsga2V5OiBgJHtrZXl9X19waWN0dXJlLW1hcmtlci1zeW1ib2wtbGF5ZXJgIH0sIGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uXCIsIHsgZW1iZWRkZWQ6IHRydWUsIGtleTogYCR7a2V5fV9fcGljdHVyZS1tYXJrZXItc3ltYm9sLWxheWVyLWNvbnRlbnRgIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsQ29sb3IsIGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbnB1dC1jb2xvclwiIH0sIGgoXCJhcmNnaXMtY29sb3ItaW5wdXRcIiwgeyBjb2xvcjogdGhpcy50b0NvbG9yUGlja2VyVmFsdWUodGludENvbG9yKSxcbiAgICAgICAgICAgIC8vY29tcGFjdD17dGhpcy5uYXJyb3d9XG4gICAgICAgICAgICBjbGVhcmFibGU6IHRydWUsIG9uQXJjZ2lzQ29sb3JJbnB1dENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBjcmVhdGUoZXZlbnQuY3VycmVudFRhcmdldC5jb2xvcik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGxFcXVpdmFsZW50Q29sb3IoY29sb3IpICYmICFub1RpbnRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBjb2xvci5hID0gdGludENvbG9yLmE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN5bWJvbExheWVyLnRpbnRDb2xvciA9IGNvbG9yLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSwgcG9wb3ZlclByb3BzOiB0aGlzLnBvcG92ZXJQcm9wcywgc3RvcmFnZUlkOiBjb2xvclN0b3JhZ2VJZCwgcmVmOiB0aGlzLnNldENvbG9ySW5wdXRSZWYgfSkpKSwgaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb25cIiwgeyBlbWJlZGRlZDogdHJ1ZSwgZGlzYWJsZWQ6IG5vVGludENvbG9yIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsVHJhbnNwYXJlbmN5LCBoKFNlbGVjdE51bWJlciwgeyBmbGlwTGFiZWxzOiB0aGlzLnBlcmNlbnRMYWJlbEZsaXAsIG1pbjogb3BhY2l0eU1pbiwgbWF4OiBvcGFjaXR5TWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiBcIiVcIiwgdmFsdWU6IGFscGhhVG9UcmFuc3BhcmVuY3kodGludENvbG9yLmEpLCBkaXNhYmxlZDogbm9UaW50Q29sb3IsIG9uVmFsdWVDaGFuZ2U6ICh0cmFuc3BhcmVuY3kpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEodHJhbnNwYXJlbmN5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHRpbnRDb2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGNvbG9yLmEgPSBhbHBoYTtcbiAgICAgICAgICAgICAgICBzeW1ib2xMYXllci50aW50Q29sb3IgPSBjb2xvci50b0pTT04oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxUcmFuc3BhcmVuY3kgfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCB0aGlzLm1lcmdlZFN0cmluZ3Muc3ltYm9sU2l6ZSwgaChTZWxlY3ROdW1iZXIsIHsgZGlzYWJsZWQ6IG5vVGludENvbG9yIHx8XG4gICAgICAgICAgICAgICAgKGF1dG9TaXplQWRqdXN0ICYmIGF1dG9TaXplQWRqdXN0ICE9PSBcImVkaXRhYmxlXCIgJiYgbWFya2VyLmF1dG9BZGp1c3RlZCksIG1pbjogc2l6ZU1pbiwgbWF4OiBzaXplTWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3MucHgsIHZhbHVlOiBub3JtYWxpemVQeChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5wdDJweChzeW1ib2xMYXllci5zaXplKSksIG9uVmFsdWVDaGFuZ2U6IChzaXplKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNYXJrZXJTeW1ib2xMYXllclNpemUodXBkYXRlVGFyZ2V0U3ltYm9sLCBzaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUgfSkpKSksIHRoaXMucmVuZGVyQ0lNTWFya2VyUGxhY2VtZW50U2VjdGlvbihzeW1ib2xMYXllciksIHRoaXMucmVuZGVyQ0lNUGljdHVyZU1hcmtlckFuaW1hdGlvblNlY3Rpb24oc3ltYm9sTGF5ZXIpKSk7XG4gICAgICAgIGlmIChjb250ZW50T25seSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ltYm9sTGF5ZXJQcmV2aWV3ID0gdGhpcy5nZXRTeW1ib2xMYXllclByZXZpZXdTeW1ib2wodGhpcy5zYW5pdGl6ZVBvaW50UHJldmlld1N5bWJvbExheWVyKHN5bWJvbExheWVyKSwgXCJwb2ludFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQmxvY2soe1xuICAgICAgICAgICAgaWNvbjogKGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zeW1ib2wtcHJldmlld1wiLCB7IGNvbnRyYXN0OiB0cnVlLCBrZXk6IGAke2tleX1fX3NvbGlkLWZpbGwtc3ltYm9sLWxheWVyLXByZXZpZXdgLCBzeW1ib2w6IHN5bWJvbExheWVyUHJldmlldywgb3B0aW9uczogcG9pbnRQcmV2aWV3T3B0aW9ucywgc2xvdDogXCJpY29uXCIgfSkpLFxuICAgICAgICAgICAgaGVhZGluZzogdGhpcy5tZXJnZWRTdHJpbmdzLnBpY3R1cmVNYXJrZXIsXG4gICAgICAgICAgICBrZXk6IGAke2tleX1fX3BpY3R1cmUtbWFya2VyLXN5bWJvbC1sYXllcmAsXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYW5pdGl6ZVBvaW50UHJldmlld1N5bWJvbExheWVyKHN5bWJvbExheWVyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN5bWJvbExheWVyKSwge1xuICAgICAgICAgICAgLy8gZW5zdXJlIG1hcmtlclBsYWNlbWVudCBpcyBub3Qgc2V0IG9uIENJTSBwb2ludCBzeW1ib2xzIHN5bWJvbCBsYXllciBmb3IgcHJvcGVyIHByZXZpZXdcbiAgICAgICAgICAgIG1hcmtlclBsYWNlbWVudDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXJDSU1QaWN0dXJlU3Ryb2tlU3ltYm9sTGF5ZXJCbG9jayhzeW1ib2xMYXllciwga2V5LCBjb250ZW50T25seSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwibWluaW1hbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW50Q29sb3IgPSBjcmVhdGUoc3ltYm9sTGF5ZXIudGludENvbG9yLCB0cnVlKTtcbiAgICAgICAgY29uc3QgeyBzZWN0aW9uczogeyBtYXJrZXI6IHsgcGFydHM6IHsgc2l6ZSB9IH0gfSwgbWFya2VyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBhdXRvU2l6ZUFkanVzdCA9IHR5cGVvZiBzaXplID09PSBcIm9iamVjdFwiICYmIChzaXplID09PSBudWxsIHx8IHNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpemUuYXV0b1NpemVBZGp1c3QpO1xuICAgICAgICBjb25zdCBub1RpbnRDb2xvciA9IGlzTnVsbEVxdWl2YWxlbnRDb2xvcih0aW50Q29sb3IpO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gKGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uXCIsIHsgZW1iZWRkZWQ6IHRydWUsIGtleTogYCR7a2V5fV9fcGljdHVyZS1zdHJva2Utc3ltYm9sLWxheWVyLWNvbnRlbnRgIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsQ29sb3IsIGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbnB1dC1jb2xvclwiIH0sIGgoXCJhcmNnaXMtY29sb3ItaW5wdXRcIiwgeyBjb2xvcjogdGhpcy50b0NvbG9yUGlja2VyVmFsdWUodGludENvbG9yKSxcbiAgICAgICAgICAgIC8vY29tcGFjdD17dGhpcy5uYXJyb3d9XG4gICAgICAgICAgICBjbGVhcmFibGU6IHRydWUsIG9uQXJjZ2lzQ29sb3JJbnB1dENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBjcmVhdGUoZXZlbnQuY3VycmVudFRhcmdldC5jb2xvcik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGxFcXVpdmFsZW50Q29sb3IoY29sb3IpICYmICFub1RpbnRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBjb2xvci5hID0gdGludENvbG9yLmE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN5bWJvbExheWVyLnRpbnRDb2xvciA9IGNvbG9yLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSwgcG9wb3ZlclByb3BzOiB0aGlzLnBvcG92ZXJQcm9wcywgc3RvcmFnZUlkOiBjb2xvclN0b3JhZ2VJZCwgcmVmOiB0aGlzLnNldENvbG9ySW5wdXRSZWYgfSkpKSwgaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb25cIiwgeyBlbWJlZGRlZDogdHJ1ZSwgZGlzYWJsZWQ6IG5vVGludENvbG9yIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsVHJhbnNwYXJlbmN5LCBoKFNlbGVjdE51bWJlciwgeyBmbGlwTGFiZWxzOiB0aGlzLnBlcmNlbnRMYWJlbEZsaXAsIG1pbjogb3BhY2l0eU1pbiwgbWF4OiBvcGFjaXR5TWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiBcIiVcIiwgdmFsdWU6IGFscGhhVG9UcmFuc3BhcmVuY3kodGludENvbG9yLmEpLCBkaXNhYmxlZDogbm9UaW50Q29sb3IsIG9uVmFsdWVDaGFuZ2U6ICh0cmFuc3BhcmVuY3kpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEodHJhbnNwYXJlbmN5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHRpbnRDb2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGNvbG9yLmEgPSBhbHBoYTtcbiAgICAgICAgICAgICAgICBzeW1ib2xMYXllci50aW50Q29sb3IgPSBjb2xvci50b0pTT04oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxUcmFuc3BhcmVuY3kgfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCB0aGlzLm1lcmdlZFN0cmluZ3Muc3ltYm9sU2l6ZSwgaChTZWxlY3ROdW1iZXIsIHsgZGlzYWJsZWQ6IG5vVGludENvbG9yIHx8XG4gICAgICAgICAgICAgICAgKGF1dG9TaXplQWRqdXN0ICYmIGF1dG9TaXplQWRqdXN0ICE9PSBcImVkaXRhYmxlXCIgJiYgbWFya2VyLmF1dG9BZGp1c3RlZCksIG1pbjogc2l6ZU1pbiwgbWF4OiBzaXplTWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3MucHgsIHZhbHVlOiBub3JtYWxpemVQeChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5wdDJweChzeW1ib2xMYXllci53aWR0aCkpLCBvblZhbHVlQ2hhbmdlOiAod2lkdGgpID0+IHtcbiAgICAgICAgICAgICAgICBzeW1ib2xMYXllci53aWR0aCA9IG5vcm1hbGl6ZVB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB4MnB0KHdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5zeW1ib2xTaXplIH0pKSkpKTtcbiAgICAgICAgaWYgKGNvbnRlbnRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzeW1ib2xMYXllclByZXZpZXcgPSB0aGlzLmdldFN5bWJvbExheWVyUHJldmlld1N5bWJvbChzeW1ib2xMYXllciwgXCJsaW5lXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJCbG9jayh7XG4gICAgICAgICAgICBpY29uOiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXN5bWJvbC1wcmV2aWV3XCIsIHsgY29udHJhc3Q6IHRydWUsIGtleTogYCR7a2V5fV9fcGljdHVyZS1zdHJva2Utc3ltYm9sLWxheWVyLXByZXZpZXdgLCBzeW1ib2w6IHN5bWJvbExheWVyUHJldmlldywgc2xvdDogXCJpY29uXCIgfSkpLFxuICAgICAgICAgICAgaGVhZGluZzogdGhpcy5tZXJnZWRTdHJpbmdzLnBpY3R1cmVTdHJva2UsXG4gICAgICAgICAgICBrZXk6IGAke2tleX1fX3BpY3R1cmUtc3Ryb2tlLXN5bWJvbC1sYXllcmAsXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXJDSU1QaWN0dXJlRmlsbFN5bWJvbExheWVyQmxvY2soc3ltYm9sTGF5ZXIsIGtleSwgY29udGVudE9ubHkgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBcIm1pbmltYWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGludENvbG9yID0gY3JlYXRlKHN5bWJvbExheWVyLnRpbnRDb2xvciwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHsgc2VjdGlvbnM6IHsgbWFya2VyOiB7IHBhcnRzOiB7IHNpemUgfSB9IH0sIG1hcmtlciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYXV0b1NpemVBZGp1c3QgPSB0eXBlb2Ygc2l6ZSA9PT0gXCJvYmplY3RcIiAmJiAoc2l6ZSA9PT0gbnVsbCB8fCBzaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaXplLmF1dG9TaXplQWRqdXN0KTtcbiAgICAgICAgY29uc3Qgbm9UaW50Q29sb3IgPSBpc051bGxFcXVpdmFsZW50Q29sb3IodGludENvbG9yKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IChoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvblwiLCB7IGVtYmVkZGVkOiB0cnVlLCBrZXk6IGAke2tleX1fX3BpY3R1cmUtZmlsbC1zeW1ib2wtbGF5ZXItY29udGVudGAgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxDb2xvciwgaChcImRpdlwiLCB7IGNsYXNzOiBcImlucHV0LWNvbG9yXCIgfSwgaChcImFyY2dpcy1jb2xvci1pbnB1dFwiLCB7IGNvbG9yOiB0aGlzLnRvQ29sb3JQaWNrZXJWYWx1ZSh0aW50Q29sb3IpLFxuICAgICAgICAgICAgLy9jb21wYWN0PXt0aGlzLm5hcnJvd31cbiAgICAgICAgICAgIGNsZWFyYWJsZTogdHJ1ZSwgb25BcmNnaXNDb2xvcklucHV0Q2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGNyZWF0ZShldmVudC5jdXJyZW50VGFyZ2V0LmNvbG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbEVxdWl2YWxlbnRDb2xvcihjb2xvcikgJiYgIW5vVGludENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yLmEgPSB0aW50Q29sb3IuYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ltYm9sTGF5ZXIudGludENvbG9yID0gY29sb3IudG9KU09OKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9LCBwb3BvdmVyUHJvcHM6IHRoaXMucG9wb3ZlclByb3BzLCBzdG9yYWdlSWQ6IGNvbG9yU3RvcmFnZUlkLCByZWY6IHRoaXMuc2V0Q29sb3JJbnB1dFJlZiB9KSkpLCBoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvblwiLCB7IGVtYmVkZGVkOiB0cnVlLCBkaXNhYmxlZDogbm9UaW50Q29sb3IgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxUcmFuc3BhcmVuY3ksIGgoU2VsZWN0TnVtYmVyLCB7IGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgbWluOiBvcGFjaXR5TWluLCBtYXg6IG9wYWNpdHlNYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IFwiJVwiLCB2YWx1ZTogYWxwaGFUb1RyYW5zcGFyZW5jeSh0aW50Q29sb3IuYSksIGRpc2FibGVkOiBub1RpbnRDb2xvciwgb25WYWx1ZUNoYW5nZTogKHRyYW5zcGFyZW5jeSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscGhhID0gdHJhbnNwYXJlbmN5VG9BbHBoYSh0cmFuc3BhcmVuY3kpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGludENvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgY29sb3IuYSA9IGFscGhhO1xuICAgICAgICAgICAgICAgIHN5bWJvbExheWVyLnRpbnRDb2xvciA9IGNvbG9yLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgfSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3MuZmlsbFRyYW5zcGFyZW5jeSB9KSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5zeW1ib2xTaXplLCBoKFNlbGVjdE51bWJlciwgeyBkaXNhYmxlZDogbm9UaW50Q29sb3IgfHxcbiAgICAgICAgICAgICAgICAoYXV0b1NpemVBZGp1c3QgJiYgYXV0b1NpemVBZGp1c3QgIT09IFwiZWRpdGFibGVcIiAmJiBtYXJrZXIuYXV0b0FkanVzdGVkKSwgbWluOiBzaXplTWluLCBtYXg6IHNpemVNYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5weCwgdmFsdWU6IG5vcm1hbGl6ZVB4KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB0MnB4KHN5bWJvbExheWVyLmhlaWdodCkpLCBvblZhbHVlQ2hhbmdlOiAoaGVpZ2h0KSA9PiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sTGF5ZXIuaGVpZ2h0ID0gbm9ybWFsaXplUHQoZXNyaU1vZHVsZXMuc2NyZWVuVXRpbHMucHgycHQoaGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5zeW1ib2xTaXplIH0pKSkpKTtcbiAgICAgICAgaWYgKGNvbnRlbnRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzeW1ib2xMYXllclByZXZpZXcgPSB0aGlzLmdldFN5bWJvbExheWVyUHJldmlld1N5bWJvbChzeW1ib2xMYXllciwgXCJwb2x5Z29uXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJCbG9jayh7XG4gICAgICAgICAgICBpY29uOiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXN5bWJvbC1wcmV2aWV3XCIsIHsgY29udHJhc3Q6IHRydWUsIGtleTogYCR7a2V5fV9fcGljdHVyZS1maWxsLXN5bWJvbC1sYXllci1wcmV2aWV3YCwgc3ltYm9sOiBzeW1ib2xMYXllclByZXZpZXcsIHNsb3Q6IFwiaWNvblwiIH0pKSxcbiAgICAgICAgICAgIGhlYWRpbmc6IHRoaXMubWVyZ2VkU3RyaW5ncy5waWN0dXJlRmlsbCxcbiAgICAgICAgICAgIGtleTogYCR7a2V5fV9fcGljdHVyZS1maWxsLXN5bWJvbC1sYXllcmAsXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXJDSU1QaWN0dXJlTWFya2VyQW5pbWF0aW9uU2VjdGlvbihzeW1ib2xMYXllcikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgeyBkaXIsIG1lcmdlZFN0cmluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzIH0gPSBzeW1ib2xMYXllcjtcbiAgICAgICAgaWYgKGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ibG9jay1zZWN0aW9uXCIsIHsga2V5OiBcInBpY3R1cmUtbWFya2VyLWFuaW1hdGlvblwiLCB0ZXh0OiBtZXJnZWRTdHJpbmdzLmFuaW1hdGlvbiB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGRpcjogZGlyLCBsYXlvdXQ6IFwiaW5saW5lXCIgfSwgaChcImNhbGNpdGUtY2hlY2tib3hcIiwgeyBjaGVja2VkOiBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMucGxheUFuaW1hdGlvbiwgb25DYWxjaXRlQ2hlY2tib3hDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5wbGF5QW5pbWF0aW9uID0gY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSB9KSwgbWVyZ2VkU3RyaW5ncy5wbGF5QW5pbWF0aW9uKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBkaXI6IGRpciwgbGF5b3V0OiBcImlubGluZVwiIH0sIGgoXCJjYWxjaXRlLWNoZWNrYm94XCIsIHsgY2hlY2tlZDogYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLnJldmVyc2VBbmltYXRpb24sIG9uQ2FsY2l0ZUNoZWNrYm94Q2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjaGVja2VkIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMucmV2ZXJzZUFuaW1hdGlvbiA9IGNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gfSksIG1lcmdlZFN0cmluZ3MucmV2ZXJzZUFuaW1hdGlvbiksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3Muc3RhcnRUaW1lT2Zmc2V0LCBoKFwiY2FsY2l0ZS1zZWdtZW50ZWQtY29udHJvbFwiLCB7IG9uQ2FsY2l0ZVNlZ21lbnRlZENvbnRyb2xDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5yYW5kb21pemVTdGFydFRpbWUgPSB2YWx1ZSA9PT0gXCJyYW5kb21cIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSB9LCBoKFwiY2FsY2l0ZS1zZWdtZW50ZWQtY29udHJvbC1pdGVtXCIsIHsgdmFsdWU6IFwicmFuZG9tXCIsIGNoZWNrZWQ6IGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5yYW5kb21pemVTdGFydFRpbWUgfSwgbWVyZ2VkU3RyaW5ncy5yYW5kb21pemVkKSwgaChcImNhbGNpdGUtc2VnbWVudGVkLWNvbnRyb2wtaXRlbVwiLCB7IHZhbHVlOiBcIm1hbnVhbFwiLCBjaGVja2VkOiAhYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLnJhbmRvbWl6ZVN0YXJ0VGltZSB9LCBtZXJnZWRTdHJpbmdzLm1hbnVhbE9mZnNldCkpKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5tYW51YWxPZmZzZXQsIGgoU2VsZWN0TnVtYmVyLCB7IGRpc2FibGVkOiBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMucmFuZG9taXplU3RhcnRUaW1lLCBtYXg6IGFuaW1hdGlvbkR1cmF0aW9uTWF4LCBtaW46IGFuaW1hdGlvbkR1cmF0aW9uTWluLCBvblZhbHVlQ2hhbmdlOiAob2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5zdGFydFRpbWVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sIHN0ZXA6IDEsIHZhbHVlOiAoX2EgPSBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMuc3RhcnRUaW1lT2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3MubWFudWFsT2Zmc2V0IH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5kdXJhdGlvbiwgaChTZWxlY3ROdW1iZXIsIHsgbWF4OiBhbmltYXRpb25EdXJhdGlvbk1heCwgbWluOiBhbmltYXRpb25EdXJhdGlvbk1pbiwgb25WYWx1ZUNoYW5nZTogKGR1cmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LCBzdGVwOiAxLCB2YWx1ZTogKF9iID0gYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLmR1cmF0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3MuZHVyYXRpb24gfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBtZXJnZWRTdHJpbmdzLnJlcGVhdFR5cGUsIGgoXCJjYWxjaXRlLXNlZ21lbnRlZC1jb250cm9sXCIsIHsgb25DYWxjaXRlU2VnbWVudGVkQ29udHJvbENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBldmVudC5jdXJyZW50VGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5yZXBlYXRUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSB9LCBoKFwiY2FsY2l0ZS1zZWdtZW50ZWQtY29udHJvbC1pdGVtXCIsIHsgdmFsdWU6IFwiTm9uZVwiLCBjaGVja2VkOiBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMucmVwZWF0VHlwZSA9PT0gXCJOb25lXCIgfSwgbWVyZ2VkU3RyaW5ncy5ub25lKSwgaChcImNhbGNpdGUtc2VnbWVudGVkLWNvbnRyb2wtaXRlbVwiLCB7IHZhbHVlOiBcIkxvb3BcIiwgY2hlY2tlZDogYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLnJlcGVhdFR5cGUgPT09IFwiTG9vcFwiIH0sIG1lcmdlZFN0cmluZ3MubG9vcCksIGgoXCJjYWxjaXRlLXNlZ21lbnRlZC1jb250cm9sLWl0ZW1cIiwgeyB2YWx1ZTogXCJPc2NpbGxhdGVcIiwgY2hlY2tlZDogYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLnJlcGVhdFR5cGUgPT09IFwiT3NjaWxsYXRlXCIgfSwgbWVyZ2VkU3RyaW5ncy5vc2NpbGxhdGUpKSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3MucmVwZWF0RGVsYXksIGgoU2VsZWN0TnVtYmVyLCB7IG1heDogYW5pbWF0aW9uRHVyYXRpb25NYXgsIG1pbjogYW5pbWF0aW9uRHVyYXRpb25NaW4sIG9uVmFsdWVDaGFuZ2U6IChkZWxheSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMucmVwZWF0RGVsYXkgPSBkZWxheTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSwgc3RlcDogMSwgdmFsdWU6IChfYyA9IGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5yZXBlYXREZWxheSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiBtZXJnZWRTdHJpbmdzLnJlcGVhdERlbGF5IH0pKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyQ0lNTWFya2VyUGxhY2VtZW50U2VjdGlvbihzeW1ib2xMYXllcikge1xuICAgICAgICBjb25zdCB7IGRpciwgbWVyZ2VkU3RyaW5ncyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBtYXJrZXJQbGFjZW1lbnQgfSA9IHN5bWJvbExheWVyO1xuICAgICAgICBpZiAoKG1hcmtlclBsYWNlbWVudCA9PT0gbnVsbCB8fCBtYXJrZXJQbGFjZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlclBsYWNlbWVudC50eXBlKSA9PT0gXCJDSU1NYXJrZXJQbGFjZW1lbnRJbnNpZGVQb2x5Z29uXCIgJiZcbiAgICAgICAgICAgICgobWFya2VyUGxhY2VtZW50ID09PSBudWxsIHx8IG1hcmtlclBsYWNlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyUGxhY2VtZW50LmdyaWRUeXBlKSA9PT0gXCJSYW5kb21cIiB8fCAobWFya2VyUGxhY2VtZW50ID09PSBudWxsIHx8IG1hcmtlclBsYWNlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyUGxhY2VtZW50LmdyaWRUeXBlKSA9PT0gXCJGaXhlZFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ibG9jay1zZWN0aW9uXCIsIHsga2V5OiBcIm1hcmtlci1wbGFjZW1lbnRcIiwgdGV4dDogbWVyZ2VkU3RyaW5ncy5tYXJrZXJQbGFjZW1lbnQgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5ncmlkVHlwZSwgaChcImNhbGNpdGUtc2VnbWVudGVkLWNvbnRyb2xcIiwgeyBvbkNhbGNpdGVTZWdtZW50ZWRDb250cm9sQ2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC5jdXJyZW50VGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlclBsYWNlbWVudC5ncmlkVHlwZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IH0sIGgoXCJjYWxjaXRlLXNlZ21lbnRlZC1jb250cm9sLWl0ZW1cIiwgeyB2YWx1ZTogXCJGaXhlZFwiLCBjaGVja2VkOiBtYXJrZXJQbGFjZW1lbnQuZ3JpZFR5cGUgPT09IFwiRml4ZWRcIiB9LCBtZXJnZWRTdHJpbmdzLmZpeGVkKSwgaChcImNhbGNpdGUtc2VnbWVudGVkLWNvbnRyb2wtaXRlbVwiLCB7IHZhbHVlOiBcIlJhbmRvbVwiLCBjaGVja2VkOiBtYXJrZXJQbGFjZW1lbnQuZ3JpZFR5cGUgPT09IFwiUmFuZG9tXCIgfSwgbWVyZ2VkU3RyaW5ncy5yYW5kb20pKSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3MucmFuZG9tbmVzcywgaChTZWxlY3ROdW1iZXIsIHsgZGlzYWJsZWQ6IG1hcmtlclBsYWNlbWVudC5ncmlkVHlwZSA9PT0gXCJGaXhlZFwiLCBmbGlwTGFiZWxzOiB0aGlzLnBlcmNlbnRMYWJlbEZsaXAsIG1heDogbWFya2VyUGxhY2VtZW50UmFuZG9tbmVzc01heCwgbWluOiBtYXJrZXJQbGFjZW1lbnRSYW5kb21uZXNzTWluLCBvblZhbHVlQ2hhbmdlOiAocmFuZG9tbmVzcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJQbGFjZW1lbnQucmFuZG9tbmVzcyA9IHJhbmRvbW5lc3M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sIHN0ZXA6IDEsIHZhbHVlOiBtYXJrZXJQbGFjZW1lbnQucmFuZG9tbmVzcywgdW5pdHNMYWJlbDogXCIlXCIsIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogbWVyZ2VkU3RyaW5ncy5yYW5kb21uZXNzIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5zdGVwWCwgaChTZWxlY3ROdW1iZXIsIHsgbWF4OiBtYXJrZXJQbGFjZW1lbnRTdGVwTWF4LCBtaW46IG1hcmtlclBsYWNlbWVudFN0ZXBNaW4sIG9uVmFsdWVDaGFuZ2U6IChzdGVwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlclBsYWNlbWVudC5zdGVwWCA9IG5vcm1hbGl6ZVB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB4MnB0KHN0ZXApKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSwgc3RlcDogMSwgdmFsdWU6IG5vcm1hbGl6ZVB4KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB0MnB4KG1hcmtlclBsYWNlbWVudC5zdGVwWCkpLCB1bml0c0xhYmVsOiBtZXJnZWRTdHJpbmdzLnB4LCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3Muc3RlcFggfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBtZXJnZWRTdHJpbmdzLnN0ZXBZLCBoKFNlbGVjdE51bWJlciwgeyBtYXg6IG1hcmtlclBsYWNlbWVudFN0ZXBNYXgsIG1pbjogbWFya2VyUGxhY2VtZW50U3RlcE1pbiwgb25WYWx1ZUNoYW5nZTogKHN0ZXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyUGxhY2VtZW50LnN0ZXBZID0gbm9ybWFsaXplUHQoZXNyaU1vZHVsZXMuc2NyZWVuVXRpbHMucHgycHQoc3RlcCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LCBzdGVwOiAxLCB1bml0c0xhYmVsOiBtZXJnZWRTdHJpbmdzLnB4LCB2YWx1ZTogbm9ybWFsaXplUHgoZXNyaU1vZHVsZXMuc2NyZWVuVXRpbHMucHQycHgobWFya2VyUGxhY2VtZW50LnN0ZXBZKSksIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogbWVyZ2VkU3RyaW5ncy5zdGVwWSB9KSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgZGlyOiBkaXIsIGxheW91dDogXCJpbmxpbmVcIiB9LCBoKFwiY2FsY2l0ZS1jaGVja2JveFwiLCB7IGNoZWNrZWQ6IG1hcmtlclBsYWNlbWVudC5zaGlmdE9kZFJvd3MgJiYgbWFya2VyUGxhY2VtZW50LmdyaWRUeXBlID09PSBcIkZpeGVkXCIsIGRpc2FibGVkOiBtYXJrZXJQbGFjZW1lbnQuZ3JpZFR5cGUgPT09IFwiUmFuZG9tXCIsIG9uQ2FsY2l0ZUNoZWNrYm94Q2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjaGVja2VkIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJQbGFjZW1lbnQuc2hpZnRPZGRSb3dzID0gY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSB9KSwgbWVyZ2VkU3RyaW5ncy5zaGlmdE9kZFJvd3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJDb2xvckZpbGxUcmFuc3BhcmVuY3lDb250ZW50KGxhYmVsLCBkaXNhYmxlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgZmlsbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbWF4ID0gMTAwO1xuICAgICAgICBjb25zdCBtaW4gPSAwO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIGxhYmVsLCBoKFNlbGVjdE51bWJlciwgeyBmbGlwTGFiZWxzOiB0aGlzLnBlcmNlbnRMYWJlbEZsaXAsIG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCIlXCIsIHZhbHVlOiBhbHBoYVRvVHJhbnNwYXJlbmN5KChfYSA9IGZpbGwuY29sb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hKSwgb25WYWx1ZUNoYW5nZTogdGhpcy5vbkNvbG9yRmlsbFRyYW5zcGFyZW5jeUNoYW5nZSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGRpc2FibGVkOiBkaXNhYmxlZCwgbGFiZWw6IGxhYmVsIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckNvbG9yUmFtcEZpbGxCbG9jayhlbWJlZGRlZCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zLmZpbGw7XG4gICAgICAgIGNvbnN0IHsgcGFydHMgfSA9IHNlY3Rpb247XG4gICAgICAgIGNvbnN0IHNob3VsZEhpZGUgPSB0aGlzLmhhc0FjdGl2ZVBpY3R1cmVNYXJrZXJTeW1ib2woKSB8fCB0aGlzLmhhc0FjdGl2ZUxpbmVPbmx5U2ltcGxlTWFya2VyU3ltYm9sKCk7XG4gICAgICAgIGlmIChzaG91bGRIaWRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgICAgIGlmIChwYXJ0cy5jb2xvclJhbXBzKSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyRmlsbENvbG9yUmFtcHNDb250ZW50KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy50cmFuc3BhcmVuY3kpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJDb2xvclJhbXBGaWxsVHJhbnNwYXJlbmN5Q29udGVudCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTZWN0aW9uKHtcbiAgICAgICAgICAgIGtleTogXCJjb2xvci1yYW1wLWZpbGxcIixcbiAgICAgICAgICAgIGRpc2FibGVkOiBzZWN0aW9uLm9wdGlvbmFsID09PSBcIm5vbi1lZGl0YWJsZVwiLFxuICAgICAgICAgICAgZW1iZWRkZWQsXG4gICAgICAgICAgICBzZWN0aW9uQ29udGVudDogY29udGVudFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyRmlsbENvbG9yUmFtcHNDb250ZW50KCkge1xuICAgICAgICBjb25zdCB7IHN0eWxlIH0gPSB0aGlzLmNvbmZpZy5zZWN0aW9ucy5maWxsO1xuICAgICAgICBjb25zdCB7IGFjdGl2ZUNhdGVnb3J5LCBjb2xvclJhbXBzIH0gPSB0aGlzLnNlY3Rpb25zLmZpbGw7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJhbXBzQ29udGVudCh7XG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgIGFjdGl2ZUNhdGVnb3J5LFxuICAgICAgICAgICAgY29sb3JSYW1wU3RvcHM6IHRoaXMuZmlsbC5jb2xvcixcbiAgICAgICAgICAgIGNvbG9yUmFtcHMsXG4gICAgICAgICAgICBoZWFkaW5nOiB0aGlzLm1lcmdlZFN0cmluZ3MuY29sb3JzLFxuICAgICAgICAgICAgb25DYXRlZ29yeUNoYW5nZTogdGhpcy5vbkZpbGxDb2xvclJhbXBDYXRlZ29yeUNoYW5nZSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IChjb2xvclJhbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q29sb3JSYW1wID0gdGhpcy5maWxsLmNvbG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbChjdXJyZW50Q29sb3JSYW1wLCBjb2xvclJhbXAuc3RvcHMsIHN0eWxlID09PSBcIjJkXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU2VsZWN0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRldGFpbDogY29sb3JSYW1wIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGNvbG9yUmFtcC5zdG9wcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZmlsbCB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWRGaWxsID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWxsKSwgeyBjb2xvciB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGwgPSBtZXJnZWRGaWxsO1xuICAgICAgICAgICAgICAgIHRoaXMudGVtcFN0cm9rZUNvbG9yUmFtcFN0YXRlU3RvcHMgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlckZpbGxDaGFuZ2UuZW1pdChtZXJnZWRGaWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sLCB7IGNpbUNoYW5nZUNvbnRleHQ6IFwicm9vdFwiIH0pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkZsaXA6IHRoaXMuZmxpcEZpbGxDb2xvclJhbXBzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXJSYW1wc0NvbnRlbnQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG9wdGlvbnMuaGVhZGluZywgaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLWNvbG9yLXJhbXAtaW5wdXRcIiwgeyBvcHRpb25zOiBvcHRpb25zLCBzdHJpbmdzOiB0aGlzLm1lcmdlZFN0cmluZ3MsIHBvcG92ZXJQcm9wczogdGhpcy5wb3BvdmVyUHJvcHMsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgXCItLXNjcm9sbGVyLW1heC1oZWlnaHRcIjogXCJ2YXIoLS1yYW1wLXNjcm9sbGVyLW1heC1oZWlnaHQpXCJcbiAgICAgICAgICAgIH0sIHJlZjogdGhpcy5zZXRSYW1wSW5wdXRSZWYgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyQ29sb3JSYW1wRmlsbFRyYW5zcGFyZW5jeUNvbnRlbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgZmlsbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbWF4ID0gMTAwO1xuICAgICAgICBjb25zdCBtaW4gPSAwO1xuICAgICAgICBjb25zdCBjb2xvciA9IGZpbGwuY29sb3JbMF07XG4gICAgICAgIC8vIGZvciBDSU0gc3ltYm9scyB0aGlzIG1pZ2h0IGJlIGEgcmdiYSBhcnJheVxuICAgICAgICBjb25zdCBhbHBoYSA9IGNvbG9yLmxlbmd0aCA9PT0gNCA/IGNvbG9yWzNdIC8gMjU1IDogY29sb3IuYTtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCB0aGlzLm1lcmdlZFN0cmluZ3MuZmlsbFRyYW5zcGFyZW5jeSwgaChTZWxlY3ROdW1iZXIsIHsgZmxpcExhYmVsczogdGhpcy5wZXJjZW50TGFiZWxGbGlwLCBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IFwiJVwiLCB2YWx1ZTogYWxwaGFUb1RyYW5zcGFyZW5jeShhbHBoYSksIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Db2xvclJhbXBGaWxsVHJhbnNwYXJlbmN5Q2hhbmdlLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsVHJhbnNwYXJlbmN5IH0pKSk7XG4gICAgfVxuICAgIHJlbmRlclN0cm9rZUJsb2NrKCkge1xuICAgICAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcy5jb25maWcuc2VjdGlvbnM7XG4gICAgICAgIGlmIChzdHJva2UudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDb2xvclN0cm9rZUJsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ29sb3JSYW1wU3Ryb2tlQmxvY2soKTtcbiAgICB9XG4gICAgcmVuZGVyQ29sb3JTdHJva2VCbG9jaygpIHtcbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zO1xuICAgICAgICBjb25zdCBzZWN0aW9uID0gc2VjdGlvbnMuc3Ryb2tlO1xuICAgICAgICBjb25zdCB7IHBhcnRzIH0gPSBzZWN0aW9uO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgICAgIGlmIChwYXJ0cy5zdWdnZXN0ZWRDb2xvcnMgfHwgcGFydHMuY3VzdG9tQ29sb3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJTdHJva2VDb2xvcnNDb250ZW50KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy50cmFuc3BhcmVuY3kgfHwgcGFydHMuZXh0cmEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlubmVyQ29udGVudCA9IFtdO1xuICAgICAgICAgICAgaWYgKHBhcnRzLnRyYW5zcGFyZW5jeSkge1xuICAgICAgICAgICAgICAgIGlubmVyQ29udGVudC5wdXNoKHRoaXMuc2hvd2luZ1JhbXBPcHRpb25zSW5TdHJva2UoKVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMucmVuZGVyQ29sb3JSYW1wU3Ryb2tlVHJhbnNwYXJlbmN5Q29udGVudCghc2VjdGlvbi5lbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMucmVuZGVyQ29sb3JTdHJva2VUcmFuc3BhcmVuY3lDb250ZW50KCFzZWN0aW9uLmVuYWJsZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0cy5leHRyYSkge1xuICAgICAgICAgICAgICAgIGlubmVyQ29udGVudC5wdXNoKHRoaXMucmVuZGVyU3Ryb2tlRXh0cmFDb250ZW50KCFzZWN0aW9uLmVuYWJsZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogKGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uXCIsIHsgZW1iZWRkZWQ6IHRydWUsIGRpc2FibGVkOiAhc2VjdGlvbi5lbmFibGVkIH0sIGlubmVyQ29udGVudCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTZWN0aW9uKHtcbiAgICAgICAgICAgIGtleTogXCJjb2xvci1zdHJva2VcIixcbiAgICAgICAgICAgIGRpc2FibGVkOiBzZWN0aW9uLm9wdGlvbmFsID09PSBcIm5vbi1lZGl0YWJsZVwiIHx8IHRoaXMuaGFzQWN0aXZlUGljdHVyZU1hcmtlclN5bWJvbCgpLFxuICAgICAgICAgICAgc2VjdGlvbkNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlclN0cm9rZUNvbG9yUmFtcHNDb250ZW50KCkge1xuICAgICAgICBjb25zdCB7IHN0eWxlIH0gPSB0aGlzLmNvbmZpZy5zZWN0aW9ucy5zdHJva2U7XG4gICAgICAgIGNvbnN0IHsgYWN0aXZlQ2F0ZWdvcnksIGNvbG9yUmFtcHMgfSA9IHRoaXMuc2VjdGlvbnMuc3Ryb2tlO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJSYW1wc0NvbnRlbnQoe1xuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBhY3RpdmVDYXRlZ29yeSxcbiAgICAgICAgICAgIGNvbG9yUmFtcFN0b3BzOiB0aGlzLnN0cm9rZS5jb2xvcixcbiAgICAgICAgICAgIGNvbG9yUmFtcHMsXG4gICAgICAgICAgICBoZWFkaW5nOiB0aGlzLmdldFN0cm9rZVN0cmluZyhcImNvbG9yXCIpLFxuICAgICAgICAgICAgb25DYXRlZ29yeUNoYW5nZTogdGhpcy5vblN0cm9rZUNvbG9yUmFtcENhdGVnb3J5Q2hhbmdlLFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogKGNvbG9yUmFtcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2xvclJhbXAgPSB0aGlzLnN0cm9rZS5jb2xvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXF1YWwoY3VycmVudENvbG9yUmFtcCwgY29sb3JSYW1wLnN0b3BzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZXRhaWw6IGNvbG9yUmFtcCB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBjb2xvclJhbXAuc3RvcHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWRTdHJva2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgY29sb3IgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBtZXJnZWRTdHJva2U7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2UuZW1pdChub3JtYWxpemVTaXplUHJvcChtZXJnZWRTdHJva2UpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sLCB7IGNpbUNoYW5nZUNvbnRleHQ6IFwicm9vdFwiIH0pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkZsaXA6IHRoaXMuZmxpcFN0cm9rZUNvbG9yUmFtcHNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNob3dpbmdSYW1wT3B0aW9uc0luU3Ryb2tlKCkge1xuICAgICAgICBjb25zdCBzdHJva2VTZWN0aW9uQ29uZmlnID0gdGhpcy5jb25maWcuc2VjdGlvbnMuc3Ryb2tlO1xuICAgICAgICBjb25zdCBzaG91bGRTaG93RmlsbENvbG9yc0Zvck91dGxpbmUgPSBpc0xpbmVPbmx5U3ltYm9sKHRoaXMuYWN0aXZlU3ltYm9sKTtcbiAgICAgICAgY29uc3QgZmlsbFR5cGUgPSB0aGlzLnNlY3Rpb25zLmZpbGwudHlwZTtcbiAgICAgICAgcmV0dXJuIChzaG91bGRTaG93RmlsbENvbG9yc0Zvck91dGxpbmUgJiZcbiAgICAgICAgICAgIGZpbGxUeXBlID09PSBcImNvbG9yLXJhbXBcIiAmJlxuICAgICAgICAgICAgc3Ryb2tlU2VjdGlvbkNvbmZpZy50eXBlID09PSBcImNvbG9yXCIpO1xuICAgIH1cbiAgICByZW5kZXJTdHJva2VDb2xvcnNDb250ZW50KCkge1xuICAgICAgICBjb25zdCBzdHJva2VTZWN0aW9uID0gdGhpcy5zZWN0aW9ucy5zdHJva2U7XG4gICAgICAgIGlmICh0aGlzLnNob3dpbmdSYW1wT3B0aW9uc0luU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUNhdGVnb3J5ID0gdGhpcy50ZW1wU3Ryb2tlQ29sb3JSYW1wU3RhdGVBY3RpdmVDYXRlZ29yeTtcbiAgICAgICAgICAgIGNvbnN0IHsgc3R5bGUgfSA9IHRoaXMuY29uZmlnLnNlY3Rpb25zLmZpbGw7XG4gICAgICAgICAgICBjb25zdCB7IGNvbG9yUmFtcHMgfSA9IHRoaXMuc2VjdGlvbnMuZmlsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJhbXBzQ29udGVudCh7XG4gICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgYWN0aXZlQ2F0ZWdvcnksXG4gICAgICAgICAgICAgICAgY29sb3JSYW1wU3RvcHM6IHRoaXMudGVtcFN0cm9rZUNvbG9yUmFtcFN0YXRlU3RvcHMsXG4gICAgICAgICAgICAgICAgY29sb3JSYW1wcyxcbiAgICAgICAgICAgICAgICBoZWFkaW5nOiB0aGlzLmdldFN0cm9rZVN0cmluZyhcImNvbG9yXCIpLFxuICAgICAgICAgICAgICAgIG9uQ2F0ZWdvcnlDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkcm9wZG93biA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUNhdGVnb3J5ID0gZHJvcGRvd24uc2VsZWN0ZWRJdGVtc1swXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbXBTdHJva2VDb2xvclJhbXBTdGF0ZUFjdGl2ZUNhdGVnb3J5ID0gYWN0aXZlQ2F0ZWdvcnk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZDogKGNvbG9yUmFtcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q29sb3JSYW1wU3RvcHMgPSB0aGlzLnRlbXBTdHJva2VDb2xvclJhbXBTdGF0ZVN0b3BzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXF1YWwoY3VycmVudENvbG9yUmFtcFN0b3BzLCBjb2xvclJhbXAuc3RvcHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TZWxlY3Q6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRldGFpbDogY29sb3JSYW1wIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBjb2xvclJhbXAuc3RvcHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdHJva2UgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlZFN0cm9rZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3Ryb2tlKSwgeyBjb2xvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBtZXJnZWRTdHJva2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVtcFN0cm9rZUNvbG9yUmFtcFN0YXRlU3RvcHMgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2UuZW1pdChub3JtYWxpemVTaXplUHJvcChtZXJnZWRTdHJva2UpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bmNTeW1ib2xQcm9wcyh0aGlzLnN5bWJvbCksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uRmxpcDogdGhpcy5mbGlwRmlsbENvbG9yUmFtcHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbG9yID0gc3Ryb2tlU2VjdGlvbi5lbmFibGVkXG4gICAgICAgICAgICA/IHRoaXMudG9Db2xvclBpY2tlclZhbHVlKHRoaXMuc3Ryb2tlLmNvbG9yKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMuZ2V0U3Ryb2tlU3RyaW5nKFwiY29sb3JcIiksIGgoXCJhcmNnaXMtY29sb3ItaW5wdXRcIiwgeyBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAvL2NvbXBhY3Q9e3RoaXMubmFycm93fVxuICAgICAgICAgICAgY2xlYXJhYmxlOiBzdHJva2VTZWN0aW9uLm9wdGlvbmFsICE9PSBmYWxzZSwgb25BcmNnaXNDb2xvcklucHV0Q2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZENvbG9yID0gZXZlbnQuY3VycmVudFRhcmdldC5jb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblN0cm9rZUVuYWJsZWRDaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBubyB1cGRhdGVzIHRvIGNvbG9yIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc3Ryb2tlU2VjdGlvbi5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TdHJva2VFbmFibGVkQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGNyZWF0ZShzZWxlY3RlZENvbG9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q29sb3IgPSB0aGlzLnN0cm9rZS5jb2xvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWRTdHJva2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgY29sb3I6IGNyZWF0ZShhZGp1c3RUcmFuc3BhcmVuY3lJZk5lZWRlZChjdXJyZW50Q29sb3IsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50Q29sb3IpLCBjb2xvciksIHsgYTogY3VycmVudENvbG9yLmEgfSkpKSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZSA9IG1lcmdlZFN0cm9rZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZFN0cm9rZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW5jU3ltYm9sUHJvcHModGhpcy5zeW1ib2wpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0sIHBvcG92ZXJQcm9wczogdGhpcy5wb3BvdmVyUHJvcHMsIHN0b3JhZ2VJZDogY29sb3JTdG9yYWdlSWQsIHJlZjogdGhpcy5zZXRDb2xvcklucHV0UmVmIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckNvbG9yU3Ryb2tlVHJhbnNwYXJlbmN5Q29udGVudChkaXNhYmxlZCkge1xuICAgICAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbWF4ID0gMTAwO1xuICAgICAgICBjb25zdCBtaW4gPSAwO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMuZ2V0U3Ryb2tlU3RyaW5nKFwidHJhbnNwYXJlbmN5XCIpLCBoKFNlbGVjdE51bWJlciwgeyBmbGlwTGFiZWxzOiB0aGlzLnBlcmNlbnRMYWJlbEZsaXAsIG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCIlXCIsIHZhbHVlOiBhbHBoYVRvVHJhbnNwYXJlbmN5KHN0cm9rZS5jb2xvci5hKSwgb25WYWx1ZUNoYW5nZTogdGhpcy5vbkNvbG9yU3Ryb2tlVHJhbnNwYXJlbmN5Q2hhbmdlLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgZGlzYWJsZWQ6IGRpc2FibGVkLCBsYWJlbDogdGhpcy5nZXRTdHJva2VTdHJpbmcoXCJ0cmFuc3BhcmVuY3lcIikgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyU3Ryb2tlRXh0cmFDb250ZW50KGRpc2FibGVkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgc2VjdGlvbnM6IHsgc3Ryb2tlOiB7IGV4dHJhUGFydHM6IHsgYXJyb3csIGF1dG9TdHJva2VBZGp1c3QsIHN0eWxlLCB3aWR0aCB9IH0gfSwgc3Ryb2tlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBtYXhXaWR0aEluUHggPSAxODtcbiAgICAgICAgY29uc3QgZWRpdGluZ0xpbmUgPSB0aGlzLmVkaXRHZW9tZXRyeSA9PT0gXCJsaW5lXCI7XG4gICAgICAgIGNvbnN0IGVkaXRpbmdQb2x5Z29uID0gdGhpcy5lZGl0R2VvbWV0cnkgPT09IFwicG9seWdvblwiO1xuICAgICAgICBjb25zdCBtaW5XaWR0aEluUHggPSBlZGl0aW5nTGluZSA/IDAuMSA6IDA7XG4gICAgICAgIGNvbnN0IGlzQ2ltID0gaXNDSU1TeW1ib2wodGhpcy5zeW1ib2wpO1xuICAgICAgICBjb25zdCBjYW5VcGRhdGVTdHlsZSA9ICFpc0NpbSAmJiBzdHlsZSAmJiAoZWRpdGluZ0xpbmUgfHwgZWRpdGluZ1BvbHlnb24pO1xuICAgICAgICBjb25zdCBjYW5VcGRhdGVBcnJvd3MgPSAhaXNDaW0gJiYgYXJyb3cgJiYgZWRpdGluZ0xpbmU7XG4gICAgICAgIGNvbnN0IGNhblVwZGF0ZVdpZHRoID0gIWlzQ2ltICYmIHdpZHRoO1xuICAgICAgICBjb25zdCBjYW5VcGRhdGVBdXRvQWRqdXN0ID0gIWlzQ2ltICYmIGF1dG9TdHJva2VBZGp1c3Q7XG4gICAgICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5lbCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1lbnQgPSB0b0Fycm93UGxhY2VtZW50KHN0cm9rZS5tYXJrZXIpO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnRHcm91cCB9LCBjYW5VcGRhdGVXaWR0aCA/IChoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGRpcjogZGlyLCBrZXk6IFwid2lkdGgtb3B0aW9uc1wiIH0sIHRoaXMuZ2V0U3Ryb2tlU3RyaW5nKFwid2lkdGhcIiksIGgoU2VsZWN0TnVtYmVyLCB7IGRpc2FibGVkOiBkaXNhYmxlZCB8fFxuICAgICAgICAgICAgICAgIChhdXRvU3Ryb2tlQWRqdXN0ICYmIGF1dG9TdHJva2VBZGp1c3QgIT09IFwiZWRpdGFibGVcIiAmJiBzdHJva2UuYXV0b0FkanVzdGVkKSwgbWluOiBtaW5XaWR0aEluUHgsIG1heDogbWF4V2lkdGhJblB4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3MucHgsIHZhbHVlOiBzdHJva2Uuc2l6ZSwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblN0cm9rZVdpZHRoQ2hhbmdlLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IHRoaXMuZ2V0U3Ryb2tlU3RyaW5nKFwid2lkdGhcIikgfSkpKSA6IG51bGwsIGNhblVwZGF0ZUF1dG9BZGp1c3RcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJBdXRvQWRqdXN0KGRpciwgc3Ryb2tlLmF1dG9BZGp1c3RlZCwgdGhpcy5tZXJnZWRTdHJpbmdzLmF1dG9BZGp1c3RTdHJva2UsIHRoaXMub25BdXRvQWRqdXN0U3Ryb2tlQ2hhbmdlKVxuICAgICAgICAgICAgOiBudWxsLCBjYW5VcGRhdGVBcnJvd3MgPyAoaChcImNhbGNpdGUtbGFiZWxcIiwgeyBkaXI6IGRpciwga2V5OiBcImFycm93LW9wdGlvbnNcIiB9LCB0aGlzLm1lcmdlZFN0cmluZ3MuYXJyb3csIGgoXCJjYWxjaXRlLWRyb3Bkb3duXCIsIHsgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICBbQ1NTLmljb25Ecm9wZG93bl06IHRydWUsXG4gICAgICAgICAgICAgICAgW0NTUy5hcnJvd0Ryb3Bkb3duXTogdHJ1ZVxuICAgICAgICAgICAgfSwgb25DYWxjaXRlRHJvcGRvd25TZWxlY3Q6IHRoaXMub25TdHJva2VBcnJvd0NoYW5nZSwgd2lkdGhTY2FsZTogXCJsXCIsIHBsYWNlbWVudDogXCJ0b3AtZW5kXCIsIFwib3ZlcmxheS1wb3NpdGlvbmluZ1wiOiAoX2EgPSB0aGlzLnBvcG92ZXJQcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm92ZXJsYXlQb3NpdGlvbmluZywgc2NhbGU6IFwic1wiIH0sIGgoXCJkaXZcIiwgeyByb2xlOiBcImJ1dHRvblwiLCBzbG90OiBcInRyaWdnZXJcIiwgdGFiSW5kZXg6IDAgfSwgaChcImRpdlwiLCB7IFwiZGF0YS1hcnJvd1wiOiBjdXJyZW50UGxhY2VtZW50LCBjbGFzczogQ1NTLmljb25Ecm9wZG93blNlbGVjdGVkLCBzdHlsZTogdGhpcy5nZXRTZWxlY3RlZEFycm93UGF0dGVyblN0eWxlKCkgfSksIGgoXCJjYWxjaXRlLWljb25cIiwgeyBpY29uOiBcImNoZXZyb24tZG93blwiLCBzY2FsZTogXCJzXCIgfSkpLCBoKFwiY2FsY2l0ZS1kcm9wZG93bi1ncm91cFwiLCBudWxsLCBzdXBwb3J0ZWRBcnJvd3MubWFwKChhcnJvdykgPT4gKGgoXCJjYWxjaXRlLWRyb3Bkb3duLWl0ZW1cIiwgeyBzZWxlY3RlZDogYXJyb3cgPT09IGN1cnJlbnRQbGFjZW1lbnQsIFwiZGF0YS1hcnJvd1wiOiBhcnJvdyB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5pY29uRHJvcGRvd25JdGVtQ29udGVudCwgXCJkYXRhLWFycm93XCI6IGFycm93LCBzdHlsZTogdGhpcy5nZXRBcnJvd1BhdHRlcm5PcHRpb25TdHlsZSgpIH0pKSkpKSkpKSA6IG51bGwsIGNhblVwZGF0ZVN0eWxlID8gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgZGlyOiBkaXIsIGtleTogXCJwYXR0ZXJuLW9wdGlvbnNcIiB9LCB0aGlzLm1lcmdlZFN0cmluZ3MucGF0dGVybiwgaChcImNhbGNpdGUtZHJvcGRvd25cIiwgeyBjbGFzczoge1xuICAgICAgICAgICAgICAgIFtDU1MuaWNvbkRyb3Bkb3duXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbQ1NTLnN0eWxlRHJvcGRvd25dOiB0cnVlXG4gICAgICAgICAgICB9LCBvbkNhbGNpdGVEcm9wZG93blNlbGVjdDogdGhpcy5vblN0cm9rZVN0eWxlQ2hhbmdlLCB3aWR0aFNjYWxlOiBcImxcIiwgcGxhY2VtZW50OiBcInRvcC1lbmRcIiwgXCJvdmVybGF5LXBvc2l0aW9uaW5nXCI6IChfYiA9IHRoaXMucG9wb3ZlclByb3BzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3ZlcmxheVBvc2l0aW9uaW5nLCBzY2FsZTogXCJzXCIgfSwgaChcImRpdlwiLCB7IHJvbGU6IFwiYnV0dG9uXCIsIHNsb3Q6IFwidHJpZ2dlclwiLCB0YWJJbmRleDogMCB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5pY29uRHJvcGRvd25TZWxlY3RlZCwgc3R5bGU6IHRoaXMuZ2V0TGluZVBhdHRlcm5TdHlsZShzdHJva2Uuc3R5bGUpIH0pLCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgaWNvbjogXCJjaGV2cm9uLWRvd25cIiwgc2NhbGU6IFwic1wiIH0pKSwgaChcImNhbGNpdGUtZHJvcGRvd24tZ3JvdXBcIiwgbnVsbCwgc3VwcG9ydGVkU3R5bGVzLm1hcCgoc3R5bGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtZHJvcGRvd24taXRlbVwiLCB7IHNlbGVjdGVkOiBzdHlsZSA9PT0gc3Ryb2tlLnN0eWxlLCBcImRhdGEtc3R5bGVcIjogc3R5bGUgfSwgaChcImRpdlwiLCB7IHN0eWxlOiB0aGlzLmdldExpbmVQYXR0ZXJuU3R5bGUoc3R5bGUpLCBjbGFzczogQ1NTLmljb25Ecm9wZG93bkl0ZW1Db250ZW50IH0pKSk7XG4gICAgICAgIH0pKSkpKSA6IG51bGwpKTtcbiAgICB9XG4gICAgcmVuZGVyQ29sb3JSYW1wU3Ryb2tlQmxvY2soZW1iZWRkZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5zZWN0aW9ucy5zdHJva2U7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gc2VjdGlvbi5wYXJ0cztcbiAgICAgICAgY29uc3QgY29udGVudCA9IFtdO1xuICAgICAgICBpZiAocGFydHMuY29sb3JSYW1wcykge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLnJlbmRlclN0cm9rZUNvbG9yUmFtcHNDb250ZW50KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy50cmFuc3BhcmVuY3kpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJDb2xvclJhbXBTdHJva2VUcmFuc3BhcmVuY3lDb250ZW50KHNlY3Rpb24ub3B0aW9uYWwgPT09IFwibm9uLWVkaXRhYmxlXCIgfHwgdGhpcy5oYXNBY3RpdmVQaWN0dXJlTWFya2VyU3ltYm9sKCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydHMuZXh0cmEpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJTdHJva2VFeHRyYUNvbnRlbnQoc2VjdGlvbi5vcHRpb25hbCA9PT0gXCJub24tZWRpdGFibGVcIiB8fCB0aGlzLmhhc0FjdGl2ZVBpY3R1cmVNYXJrZXJTeW1ib2woKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclNlY3Rpb24oe1xuICAgICAgICAgICAga2V5OiBcImNvbG9yLXJhbXAtc3Ryb2tlXCIsXG4gICAgICAgICAgICBkaXNhYmxlZDogc2VjdGlvbi5vcHRpb25hbCA9PT0gXCJub24tZWRpdGFibGVcIiB8fCB0aGlzLmhhc0FjdGl2ZVBpY3R1cmVNYXJrZXJTeW1ib2woKSxcbiAgICAgICAgICAgIGVtYmVkZGVkLFxuICAgICAgICAgICAgc2VjdGlvbkNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlckNvbG9yUmFtcFN0cm9rZVRyYW5zcGFyZW5jeUNvbnRlbnQoZGlzYWJsZWQpIHtcbiAgICAgICAgY29uc3QgeyBzdHJva2UgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1heCA9IDEwMDtcbiAgICAgICAgY29uc3QgbWluID0gMDtcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCB0aGlzLmdldFN0cm9rZVN0cmluZyhcInRyYW5zcGFyZW5jeVwiKSwgaChTZWxlY3ROdW1iZXIsIHsgZmxpcExhYmVsczogdGhpcy5wZXJjZW50TGFiZWxGbGlwLCBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IFwiJVwiLCB2YWx1ZTogYWxwaGFUb1RyYW5zcGFyZW5jeShzdHJva2UuY29sb3JbMF0uYSksIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Db2xvclJhbXBTdHJva2VUcmFuc3BhcmVuY3lDaGFuZ2UsIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBkaXNhYmxlZDogZGlzYWJsZWQsIGxhYmVsOiB0aGlzLmdldFN0cm9rZVN0cmluZyhcInRyYW5zcGFyZW5jeVwiKSB9KSkpO1xuICAgIH1cbiAgICBjaGVja1BvcG92ZXJNYXhIZWlnaHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAvLyBpZiBub3Qgc2V0IGJ5IGNhbGxlciB0aGVuIGNhbGN1bGF0ZSB0aGUgbWF4IGhlaWdodCBmb3IgYW55IHBvcG92ZXIgb3BlbmVuZCBieSB0aGUgc3R5bGVyXG4gICAgICAgIGlmICh0aGlzLmZsb3dFbCAmJiB0aGlzLnBvcG92ZXJQcm9wcyAmJiAoIXRoaXMucG9wb3ZlclByb3BzLm1heEhlaWdodCB8fCB0aGlzLmF1dG9DYWxjSGVpZ2h0KSkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQ2FsY0hlaWdodCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBwYW5lbFJlY3QgPSB0aGlzLmZsb3dFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fFxuICAgICAgICAgICAgICAgICgoX2EgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGllbnRIZWlnaHQpIHx8XG4gICAgICAgICAgICAgICAgKChfYiA9IGRvY3VtZW50LmJvZHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGllbnRIZWlnaHQpIHx8XG4gICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlVG9Cb3R0b20gPSB3aW5kb3dIZWlnaHQgJiYgKHBhbmVsUmVjdCA9PT0gbnVsbCB8fCBwYW5lbFJlY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhbmVsUmVjdC50b3ApID8gd2luZG93SGVpZ2h0IC0gcGFuZWxSZWN0LnRvcCAtIDMwIDogMDtcbiAgICAgICAgICAgIHRoaXMucG9wb3ZlclByb3BzLm1heEhlaWdodCA9IGAke01hdGgubWF4KHNwYWNlVG9Cb3R0b20gfHwgcGFuZWxSZWN0LmhlaWdodCwgMjUwKSAtXG4gICAgICAgICAgICAgICAgKChfYyA9IHRoaXMucG9wb3ZlclByb3BzLm9mZnNldERpc3RhbmNlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKSAtXG4gICAgICAgICAgICAgICAgNX1weGA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldCBhc3NldHNEaXJzKCkgeyByZXR1cm4gW1wiYXNzZXRzXCJdOyB9XG4gICAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICAgIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgICAgIFwiYnVpbHRJblN0cmluZ3NcIjogW1wiaGFuZGxlU3RyaW5nQ2hhbmdlc1wiXSxcbiAgICAgICAgXCJzdHJpbmdPdmVycmlkZXNcIjogW1wiaGFuZGxlU3RyaW5nQ2hhbmdlc1wiXVxuICAgIH07IH1cbn07XG5BcmNHSVNTeW1ib2xTdHlsZXIuc3R5bGUgPSBhcmNnaXNTeW1ib2xTdHlsZXJDc3M7XG5cbmV4cG9ydCB7IEFyY0dJU1N5bWJvbFN0eWxlciBhcyBhcmNnaXNfc3ltYm9sX3N0eWxlciB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtc3ltYm9sLXN0eWxlci5lbnRyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=