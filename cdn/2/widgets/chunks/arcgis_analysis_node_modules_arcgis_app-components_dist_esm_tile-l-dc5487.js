"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_tile-l-dc5487"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/tile-layer-8a7b93de.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/tile-layer-8a7b93de.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ canUseLayerForPublishTiles),
/* harmony export */   b: () => (/* binding */ getTileLayerInfo),
/* harmony export */   c: () => (/* binding */ canUseRendererForPublishTiles),
/* harmony export */   d: () => (/* binding */ getPublishTileLayerParams),
/* harmony export */   e: () => (/* binding */ getSuggestedScaleRange),
/* harmony export */   f: () => (/* binding */ formUpdateItemDataForTileLayer),
/* harmony export */   g: () => (/* binding */ getDatastoreServers),
/* harmony export */   h: () => (/* binding */ checkTilesOnDemandSupport),
/* harmony export */   l: () => (/* binding */ layerHasClustering),
/* harmony export */   p: () => (/* binding */ publishTileLayer)
/* harmony export */ });
/* harmony import */ var _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config-75adf962.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-75adf962.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _tile_layer_cf04fa97_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tile-layer-cf04fa97.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/tile-layer-cf04fa97.js");
/* harmony import */ var _feature_layer_573bb473_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./feature-layer-573bb473.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-layer-573bb473.js");
/* harmony import */ var _functional_81373f6d_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-81373f6d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-81373f6d.js");
/* harmony import */ var _server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./server-item-8d384796.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/server-item-8d384796.js");
/* harmony import */ var _portal_d518b571_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./portal-d518b571.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-d518b571.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */








// TODO: test --- add unit test!
var __rest = ( false) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const addScaleLabels = (tileInfo) => (Object.assign(Object.assign({}, tileInfo), { lods: (tileInfo.lods || []).map((lod) => (Object.assign(Object.assign({}, lod), { label: `1:${Math.round(lod.scale).toLocaleString("en-EN", { maximumFractionDigits: 0 })}` }))) }));
const normalizeMaxScale = (min, max, lods) => {
    var _a, _b;
    // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/10524
    if (min <= max && (lods === null || lods === void 0 ? void 0 : lods.length) > 0) {
        let maxIdx = -1;
        // go through lods and find closest lod to min scale, then find max scale two lods down, or last one
        for (let i = lods.length - 1; i >= 0; i--) {
            if (min < lods[i].scale) {
                maxIdx = i + 2;
                break;
            }
        }
        maxIdx = maxIdx > lods.length - 1 ? lods.length - 1 : maxIdx;
        return (_b = (_a = lods[maxIdx]) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : max;
    }
    return max;
};
/** Check if we support on demand, exclusively for "tiles" type */
const checkTilesOnDemandSupport = (layers, tilesOnDemandEnabled) => {
    let canShowTilesOnDemand = false;
    if (tilesOnDemandEnabled && (layers === null || layers === void 0 ? void 0 : layers.length) > 0) {
        canShowTilesOnDemand = !layers.some(
        // tiles on demand aren't allowed when labeling turned on
        (layer) => !canUseLayerForPublish(layer, false, "tiles"));
    }
    return canShowTilesOnDemand;
};
// * --- Publishing tile stuff
function canUseLayerForPublish(layerInfo, allowLabels, type) {
    if (layerInfo.type !== "Feature Layer" || !layerInfo.drawingInfo) {
        // Wrong layer type
        return false;
    }
    if (type === "scenes") {
        return canUseLayerForPublishScene(layerInfo, allowLabels);
    }
    return canUseLayerForPublishTiles(layerInfo, allowLabels);
}
function canUseLayerForPublishTiles(layerInfo, allowLabels) {
    var _a, _b;
    if (layerInfo.geometryType === "esriGeometryMultiPatch") {
        // MultiPatch
        return false;
    }
    const renderer = (_a = layerInfo.drawingInfo) === null || _a === void 0 ? void 0 : _a.renderer;
    const labelingInfo = (_b = layerInfo.drawingInfo) === null || _b === void 0 ? void 0 : _b.labelingInfo;
    const fields = layerInfo.fields;
    // clustering
    if (layerHasClustering(layerInfo)) {
        return false;
    }
    if (renderer &&
        layerInfo.geometryType &&
        (fields === null || fields === void 0 ? void 0 : fields.length) > 0 &&
        !canUseRendererForPublishTiles(renderer, layerInfo.geometryType, fields)) {
        return false;
    }
    // labels
    if (!allowLabels && (labelingInfo === null || labelingInfo === void 0 ? void 0 : labelingInfo.length)) {
        return false;
    }
    return true;
}
const layerHasClustering = (layerInfo) => {
    var _a, _b;
    const featureReduction = (_a = layerInfo.featureReduction) !== null && _a !== void 0 ? _a : (_b = layerInfo.layerDefinition) === null || _b === void 0 ? void 0 : _b.featureReduction;
    return !!featureReduction && Object.keys(featureReduction).length > 0;
};
const canUseRendererForPublishTiles = (renderer, geometryType, fields) => {
    var _a;
    // heatmap renderer
    if (renderer.type === "heatmap") {
        return false;
    }
    // scale dependent marker sizing on polygon layer
    /*
      if (layerInfo.geometryType === "esriGeometryPolygon" && renderer.visualVariables) {
        if (array.some(renderer.visualVariables, function (visVar) {
            // {target: "outline"} is OK
            if (visVar.type === "sizeInfo" && !visVar.target &&
              (typeof visVar.minSize === "object" || typeof visVar.maxSize === "object")) {
              return true;
            }
          })
        ) {
          return false;
        }
      }
      */
    // type + size on polygon layer
    if (geometryType === "esriGeometryPolygon" && renderer.uniqueValueInfos && renderer.visualVariables) {
        if (renderer.visualVariables.some((visVar) => {
            if (visVar.type === "sizeInfo" && !visVar.target) {
                return true;
            }
        })) {
            return false;
        }
    }
    // date fields
    const dateFields = fields.filter((field) => field.type === "esriFieldTypeDate").map((field) => field.name);
    if (dateFields.length) {
        // renderer using date field
        if (dateFields.indexOf(renderer.field) > -1 || dateFields.indexOf(renderer.field1) > -1) {
            return false;
        }
        // visual variables with date field
        if ((_a = renderer.visualVariables) === null || _a === void 0 ? void 0 : _a.some((visVar) => dateFields.indexOf(visVar.field) > -1)) {
            return false;
        }
    }
    return true;
};
function canUseLayerForPublishScene(layerInfo, allowLabels) {
    var _a, _b, _c;
    const renderer = layerInfo.drawingInfo.renderer;
    const labelingInfo = layerInfo.drawingInfo.labelingInfo;
    const featureReduction = layerInfo.featureReduction;
    const fields = layerInfo.fields;
    // only point or multiPatch layers
    if (["esriGeometryPoint", "esriGeometryMultiPatch"].indexOf(layerInfo.geometryType) === -1) {
        return false;
    }
    // stream layer
    if (renderer.observationRenderer || renderer.latestObservationRenderer) {
        return false;
    }
    // heatmap renderer
    if (renderer.type === "heatmap") {
        return false;
    }
    // Arcade expressions
    if ((_a = renderer.valueExpression) === null || _a === void 0 ? void 0 : _a.length) {
        return false;
    }
    if ((_b = renderer.visualVariables) === null || _b === void 0 ? void 0 : _b.some((visVar) => visVar.valueExpression.length)) {
        return false;
    }
    // date fields
    const dateFields = fields.filter((field) => field.type === "esriFieldTypeDate").map((field) => field.name);
    if (dateFields.length) {
        // renderer using date field
        if (dateFields.indexOf(renderer.field) > -1 || dateFields.indexOf(renderer.field1) > -1) {
            return false;
        }
        // visual variables with date field
        if ((_c = renderer.visualVariables) === null || _c === void 0 ? void 0 : _c.some((visVar) => visVar.field && dateFields.indexOf(visVar.field) > -1)) {
            return false;
        }
    }
    // clustering
    if (featureReduction) {
        return false;
    }
    // labels
    if (!allowLabels && (labelingInfo === null || labelingInfo === void 0 ? void 0 : labelingInfo.length)) {
        return false;
    }
    return true;
}
const getPublishTileLayerParams = (itemInfo, publishInfo, isEnterprise) => {
    const { publishType, cacheOnDemand, tileInfo, cacheOnDemandMinScale, scale, layers } = publishInfo;
    const { maxScale, minScale } = scale;
    const cacheStorageInfo = {
        storageFormat: isEnterprise || publishInfo.publishType === "vectorTiles"
            ? "esriMapCacheStorageModeCompactV2"
            : "esriMapCacheStorageModeExploded",
        packetSize: 128
    };
    const tileCacheInfo = Object.assign(Object.assign({}, (publishType === "vectorTiles" ? _tile_layer_cf04fa97_js__WEBPACK_IMPORTED_MODULE_2__.p : _tile_layer_cf04fa97_js__WEBPACK_IMPORTED_MODULE_2__.a)), tileInfo);
    if (tileCacheInfo.dpi && !tileCacheInfo.preciseDpi) {
        tileCacheInfo.preciseDpi = tileCacheInfo.dpi;
    }
    tileCacheInfo.lods = tileCacheInfo.lods.map((_a) => {
        var lod = __rest(_a, ["label"]);
        return lod;
    });
    // --- Main info
    const tileImageInfo = publishType === "vectorTiles" ? Object.assign({}, _tile_layer_cf04fa97_js__WEBPACK_IMPORTED_MODULE_2__.b) : Object.assign({}, _tile_layer_cf04fa97_js__WEBPACK_IMPORTED_MODULE_2__.c);
    let publishParameters = {
        name: (0,_functional_81373f6d_js__WEBPACK_IMPORTED_MODULE_4__.a)(itemInfo.title),
        tilingSchema: { tileCacheInfo, tileImageInfo, cacheStorageInfo },
        minScale,
        maxScale
    };
    if (layers) {
        publishParameters.layers = layers.map(({ layerDefinition, id, drawingInfo }) => 
        // Override drawingInfo if it exists
        (layerDefinition === null || layerDefinition === void 0 ? void 0 : layerDefinition.drawingInfo)
            ? { id, drawingInfo: Object.assign(Object.assign({}, drawingInfo), layerDefinition.drawingInfo) }
            : { id, drawingInfo });
    }
    if (publishType !== "vectorTiles") {
        // On demand stuff
        publishParameters.cacheOnDemand = cacheOnDemand;
        if (cacheOnDemand) {
            publishParameters = Object.assign(Object.assign({}, publishParameters), { capabilities: "Map,ChangeTracking", cacheOnDemandMinScale });
        }
    }
    const publishContent = {
        itemId: itemInfo.id,
        filetype: "featureService",
        outputType: publishType,
        publishParameters: JSON.stringify(publishParameters),
        buildInitialCache: false
    };
    return { publishContent, publishParameters };
};

const getTileLayerInfo = async (url, isVectorTiles) => {
    const isValidUrlType = url.includes(isVectorTiles ? "/VectorTileServer" : "/MapServer");
    if (!isValidUrlType) {
        return { error: { code: "invalidUrl" } };
    }
    try {
        const result = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_6__.r)(url, {}, { addTokenManually: false });
        if (result && result.singleFusedMapCache && result.tileInfo) {
            return { result: addScaleLabels(result.tileInfo) };
        }
        else if (result && isVectorTiles && result.tileInfo) {
            return { result: result.tileInfo };
        }
        return { error: { code: "noTilingSchemeFound" } };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "mapServiceError", message: JSON.stringify(error) } };
    }
};
const getSuggestedScaleRangeForLayer = async (url) => {
    try {
        // TODO: Test more thoroughly as this has only been tested with 0 sampling
        const [FeatureLayer] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__.l)(["esri/layers/FeatureLayer"]);
        const featureLayer = new FeatureLayer(url);
        const pluggedInFeatureLayer = await featureLayer.addPlugin("esri/plugins/FeatureLayerStatistics");
        const suggestedScale = await pluggedInFeatureLayer.target.statisticsPlugin.getSuggestedScaleRange({
            sampleSize: 100,
            forPublishingTiles: true
        });
        return { result: suggestedScale };
    }
    catch (error) {
        if (typeof error === "string" && error.toLowerCase().includes("sampling returned 0 features")) {
            return { result: null, error: null };
        }
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};
const getSuggestedScaleRange = async (constraints, curLods, featureLayerInfos, itemUrl) => {
    // constraints and initial min/maxScale values will be the same initially
    const lod15Scale = 18055.954822;
    let maxSupportedMinScale = null;
    let cacheOnDemandMinScale = _tile_layer_cf04fa97_js__WEBPACK_IMPORTED_MODULE_2__.T;
    const calculatedScale = {
        constraints: constraints,
        minScale: constraints.minScale,
        maxScale: constraints.maxScale || lod15Scale
    };
    if (!itemUrl) {
        return { maxSupportedMinScale, cacheOnDemandMinScale, calculatedScale };
    }
    try {
        const results = await Promise.allSettled(featureLayerInfos.map(({ id }) => getSuggestedScaleRangeForLayer(`${itemUrl}/${id}`)));
        let maxOfMinScale = 0;
        let minOfMaxScale = Infinity;
        results.forEach((result) => {
            if (result.status === "rejected") {
                return;
            }
            const fetchData = result.value.result;
            if (!fetchData) {
                return;
            }
            const { maxScale, minScale } = fetchData;
            maxOfMinScale = minScale == null || minScale <= maxOfMinScale ? maxOfMinScale : minScale;
            minOfMaxScale = maxScale == null || maxScale >= minOfMaxScale ? minOfMaxScale : maxScale;
            // find the floor of the minScales for multi-layer feature services for the cache on demand min scale
            cacheOnDemandMinScale = minScale == null || minScale >= cacheOnDemandMinScale ? cacheOnDemandMinScale : minScale;
        });
        maxSupportedMinScale = constraints.minScale || _tile_layer_cf04fa97_js__WEBPACK_IMPORTED_MODULE_2__.T;
        cacheOnDemandMinScale || (cacheOnDemandMinScale = maxOfMinScale);
        calculatedScale.minScale = cacheOnDemandMinScale || constraints.minScale;
        calculatedScale.maxScale = minOfMaxScale || calculatedScale.maxScale; // don't allow maxScale of 0
        // * --- Normalize min and max scale downward to match feature layer constraints if necessary
        if (calculatedScale.minScale > constraints.minScale && constraints.minScale > 0) {
            calculatedScale.minScale = constraints.minScale;
        }
        if (calculatedScale.maxScale >= calculatedScale.minScale && calculatedScale.minScale > 0) {
            calculatedScale.maxScale = normalizeMaxScale(calculatedScale.minScale, calculatedScale.maxScale, curLods);
        }
    }
    catch (error) {
        console.error(error);
        // * --- Error retrieving suggested scale range, continue without notification
        calculatedScale.minScale = constraints.minScale;
    }
    return { maxSupportedMinScale, cacheOnDemandMinScale, calculatedScale };
};
const publishTileLayer = async (tileLayerPublishContent, publishInfo, updateData) => {
    var _a;
    const { publishType, user, folder, title, tags, snippet, categories } = publishInfo;
    let publishContent = Object.assign({}, tileLayerPublishContent);
    if (title) {
        const publishParameters = JSON.parse(publishContent.publishParameters);
        publishParameters.name = (0,_functional_81373f6d_js__WEBPACK_IMPORTED_MODULE_4__.a)(title);
        publishContent.publishParameters = JSON.stringify(publishParameters);
    }
    const url = `${user.userContentUrl}/publish`;
    const { services } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_6__.r)(url, publishContent, {}, "post");
    const { jobId, serviceItemId, serviceurl, error, type } = services[0] || {};
    if (error) {
        console.error(error);
        // TODO: refactor to the new error system
        throw error;
    }
    await (0,_feature_layer_573bb473_js__WEBPACK_IMPORTED_MODULE_3__.x)(serviceItemId, { jobId, success: true });
    publishType !== "scenes" && (await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_5__.u)(serviceItemId, { title, tags, snippet, categories }));
    updateData && (await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_5__.u)(serviceItemId, { text: JSON.stringify(updateData) }));
    folder.id !== ((_a = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.initialFolder) === null || _a === void 0 ? void 0 : _a.id) &&
        (await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_5__.m)(serviceItemId, (0,_feature_layer_573bb473_js__WEBPACK_IMPORTED_MODULE_3__.t)(folder) ? "/" : folder.id));
    return { id: serviceItemId, jobId, serviceType: type, serviceUrl: serviceurl };
};
const getDatastoreServers = async (datastoreId) => {
    var _a;
    // https://developers.arcgis.com/rest/users-groups-and-items/get-servers-for-data-store.htm
    const portal = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_0__.c.portal;
    const restBaseUrl = `${(_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl}portals/${portal.id}`;
    const serverIdApiUrl = `${restBaseUrl}/datastores/getServers`;
    const serverIdApiPayload = { datastoreId: datastoreId, f: "json" };
    try {
        const response = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_6__.r)(serverIdApiUrl, serverIdApiPayload, {}, "post");
        return { result: response.servers };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};
const formUpdateItemDataForTileLayer = async ({ itemId, itemUrl, portal, publishType, fullLayers }) => {
    try {
        const itemData = await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_5__.n)(itemId, portal);
        // update the layers with a popup to include the url property for the feature service layer
        const layerList = ((itemData === null || itemData === void 0 ? void 0 : itemData.layers) || [])
            .map((layer, index) => {
            var _a, _b, _c, _d;
            if (!layer) {
                return null;
            }
            const layerId = (_a = layer.id) !== null && _a !== void 0 ? _a : index;
            let newLayer = Object.assign(Object.assign({}, layer), { id: layerId, layerUrl: `${itemUrl}/${layerId}`, layerItemId: itemId, layerDefinition: layer.layerDefinition });
            if (publishType === "vector") {
                delete newLayer.popupInfo;
            }
            if (layer.popupInfo) {
                newLayer = Object.assign(Object.assign({}, newLayer), { popupInfo: layer.popupInfo });
            }
            if (layer.showLegend != null) {
                newLayer = Object.assign(Object.assign({}, newLayer), { showLegend: layer.showLegend });
            }
            const correspondingFullLayer = fullLayers.find((fullLayer) => fullLayer.id === layerId);
            // Using the correspondingFullLayer as the fallback of the drawingInfo
            newLayer = Object.assign(Object.assign({}, newLayer), { drawingInfo: Object.assign(Object.assign(Object.assign({}, correspondingFullLayer === null || correspondingFullLayer === void 0 ? void 0 : correspondingFullLayer.drawingInfo), layer.drawingInfo), { renderer: (_c = (_b = layer.drawingInfo) === null || _b === void 0 ? void 0 : _b.renderer) !== null && _c !== void 0 ? _c : (_d = correspondingFullLayer === null || correspondingFullLayer === void 0 ? void 0 : correspondingFullLayer.drawingInfo) === null || _d === void 0 ? void 0 : _d.renderer }) });
            return newLayer;
        })
            .filter((layer) => layer != null);
        return { result: Object.assign(Object.assign({}, itemData), { layers: layerList }) };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};



//# sourceMappingURL=tile-layer-8a7b93de.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fdGlsZS1sLWRjNTQ4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dEO0FBQ0s7QUFDd0k7QUFDakg7QUFDckI7QUFDOEI7QUFDekM7O0FBRXBEO0FBQ0EsY0FBYyxNQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZUFBZSx3RUFBd0UsVUFBVSxZQUFZLGdEQUFnRCwwQkFBMEIsRUFBRSxHQUFHLEtBQUs7QUFDclE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7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QW1CLGtEQUFXO0FBQzlCLDJCQUEyQix3RUFBd0UsVUFBVSxVQUFVO0FBQ3ZILDhCQUE4QixZQUFZO0FBQzFDLGlDQUFpQztBQUNqQztBQUNBLCtCQUErQixzREFBTyx1Q0FBdUM7QUFDN0UsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxnREFBZ0Qsa0RBQWtEO0FBQ2xHO0FBQ0EsK0JBQStCLDJEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWSwwQkFBMEIsUUFBUSxHQUFHLFFBQVEsZ0VBQWdFO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGVBQWUsNEJBQTRCO0FBQ3BHO0FBQ0E7QUFDQSx5REFBeUQsZUFBZSw4QkFBOEI7QUFDdEc7QUFDQTtBQUNBO0FBQ0EscURBQXFELGVBQWUseURBQXlELDZJQUE2SSx3U0FBd1MsR0FBRztBQUNyakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQkFBaUIsc0NBQXNDLGVBQWUsbUJBQW1CO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRWtUOztBQUVsVCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3RpbGUtbGF5ZXItOGE3YjkzZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBjIGFzIGNvbmZpZ1N0YXRlIH0gZnJvbSAnLi9jb25maWctNzVhZGY5NjIuanMnO1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0IHsgcCBhcyBwcmVzZXRWZWN0b3JUaWxlQ2FjaGVJbmZvLCBhIGFzIHByZXNldFJhc3RlclRpbGVDYWNoZUluZm8sIGIgYXMgcHJlc2V0VmVjdG9yVGlsZUltYWdlSW5mbywgYyBhcyBwcmVzZXRSYXN0ZXJUaWxlSW1hZ2VJbmZvLCBUIGFzIFRJTEVfTEFZRVJfU0NBTEVfTUlOIH0gZnJvbSAnLi90aWxlLWxheWVyLWNmMDRmYTk3LmpzJztcbmltcG9ydCB7IHggYXMgZ2V0SXRlbVN0YXR1cywgdCBhcyBpc0ZvbGRlclJvb3QgfSBmcm9tICcuL2ZlYXR1cmUtbGF5ZXItNTczYmI0NzMuanMnO1xuaW1wb3J0IHsgYSBhcyBmb3JtYXRGaWxlTmFtZSB9IGZyb20gJy4vZnVuY3Rpb25hbC04MTM3M2Y2ZC5qcyc7XG5pbXBvcnQgeyB1IGFzIHVwZGF0ZUl0ZW0sIG0gYXMgbW92ZUl0ZW0sIG4gYXMgZ2V0SXRlbURhdGEgfSBmcm9tICcuL3NlcnZlci1pdGVtLThkMzg0Nzk2LmpzJztcbmltcG9ydCB7IHIgYXMgcmVxdWVzdCB9IGZyb20gJy4vcG9ydGFsLWQ1MThiNTcxLmpzJztcblxuLy8gVE9ETzogdGVzdCAtLS0gYWRkIHVuaXQgdGVzdCFcbnZhciBfX3Jlc3QgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5jb25zdCBhZGRTY2FsZUxhYmVscyA9ICh0aWxlSW5mbykgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGlsZUluZm8pLCB7IGxvZHM6ICh0aWxlSW5mby5sb2RzIHx8IFtdKS5tYXAoKGxvZCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9kKSwgeyBsYWJlbDogYDE6JHtNYXRoLnJvdW5kKGxvZC5zY2FsZSkudG9Mb2NhbGVTdHJpbmcoXCJlbi1FTlwiLCB7IG1heGltdW1GcmFjdGlvbkRpZ2l0czogMCB9KX1gIH0pKSkgfSkpO1xuY29uc3Qgbm9ybWFsaXplTWF4U2NhbGUgPSAobWluLCBtYXgsIGxvZHMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8xMDUyNFxuICAgIGlmIChtaW4gPD0gbWF4ICYmIChsb2RzID09PSBudWxsIHx8IGxvZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZHMubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgbGV0IG1heElkeCA9IC0xO1xuICAgICAgICAvLyBnbyB0aHJvdWdoIGxvZHMgYW5kIGZpbmQgY2xvc2VzdCBsb2QgdG8gbWluIHNjYWxlLCB0aGVuIGZpbmQgbWF4IHNjYWxlIHR3byBsb2RzIGRvd24sIG9yIGxhc3Qgb25lXG4gICAgICAgIGZvciAobGV0IGkgPSBsb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAobWluIDwgbG9kc1tpXS5zY2FsZSkge1xuICAgICAgICAgICAgICAgIG1heElkeCA9IGkgKyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heElkeCA9IG1heElkeCA+IGxvZHMubGVuZ3RoIC0gMSA/IGxvZHMubGVuZ3RoIC0gMSA6IG1heElkeDtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGxvZHNbbWF4SWR4XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjYWxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBtYXg7XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG59O1xuLyoqIENoZWNrIGlmIHdlIHN1cHBvcnQgb24gZGVtYW5kLCBleGNsdXNpdmVseSBmb3IgXCJ0aWxlc1wiIHR5cGUgKi9cbmNvbnN0IGNoZWNrVGlsZXNPbkRlbWFuZFN1cHBvcnQgPSAobGF5ZXJzLCB0aWxlc09uRGVtYW5kRW5hYmxlZCkgPT4ge1xuICAgIGxldCBjYW5TaG93VGlsZXNPbkRlbWFuZCA9IGZhbHNlO1xuICAgIGlmICh0aWxlc09uRGVtYW5kRW5hYmxlZCAmJiAobGF5ZXJzID09PSBudWxsIHx8IGxheWVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJzLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgIGNhblNob3dUaWxlc09uRGVtYW5kID0gIWxheWVycy5zb21lKFxuICAgICAgICAvLyB0aWxlcyBvbiBkZW1hbmQgYXJlbid0IGFsbG93ZWQgd2hlbiBsYWJlbGluZyB0dXJuZWQgb25cbiAgICAgICAgKGxheWVyKSA9PiAhY2FuVXNlTGF5ZXJGb3JQdWJsaXNoKGxheWVyLCBmYWxzZSwgXCJ0aWxlc1wiKSk7XG4gICAgfVxuICAgIHJldHVybiBjYW5TaG93VGlsZXNPbkRlbWFuZDtcbn07XG4vLyAqIC0tLSBQdWJsaXNoaW5nIHRpbGUgc3R1ZmZcbmZ1bmN0aW9uIGNhblVzZUxheWVyRm9yUHVibGlzaChsYXllckluZm8sIGFsbG93TGFiZWxzLCB0eXBlKSB7XG4gICAgaWYgKGxheWVySW5mby50eXBlICE9PSBcIkZlYXR1cmUgTGF5ZXJcIiB8fCAhbGF5ZXJJbmZvLmRyYXdpbmdJbmZvKSB7XG4gICAgICAgIC8vIFdyb25nIGxheWVyIHR5cGVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJzY2VuZXNcIikge1xuICAgICAgICByZXR1cm4gY2FuVXNlTGF5ZXJGb3JQdWJsaXNoU2NlbmUobGF5ZXJJbmZvLCBhbGxvd0xhYmVscyk7XG4gICAgfVxuICAgIHJldHVybiBjYW5Vc2VMYXllckZvclB1Ymxpc2hUaWxlcyhsYXllckluZm8sIGFsbG93TGFiZWxzKTtcbn1cbmZ1bmN0aW9uIGNhblVzZUxheWVyRm9yUHVibGlzaFRpbGVzKGxheWVySW5mbywgYWxsb3dMYWJlbHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChsYXllckluZm8uZ2VvbWV0cnlUeXBlID09PSBcImVzcmlHZW9tZXRyeU11bHRpUGF0Y2hcIikge1xuICAgICAgICAvLyBNdWx0aVBhdGNoXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyZXIgPSAoX2EgPSBsYXllckluZm8uZHJhd2luZ0luZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW5kZXJlcjtcbiAgICBjb25zdCBsYWJlbGluZ0luZm8gPSAoX2IgPSBsYXllckluZm8uZHJhd2luZ0luZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sYWJlbGluZ0luZm87XG4gICAgY29uc3QgZmllbGRzID0gbGF5ZXJJbmZvLmZpZWxkcztcbiAgICAvLyBjbHVzdGVyaW5nXG4gICAgaWYgKGxheWVySGFzQ2x1c3RlcmluZyhsYXllckluZm8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJlbmRlcmVyICYmXG4gICAgICAgIGxheWVySW5mby5nZW9tZXRyeVR5cGUgJiZcbiAgICAgICAgKGZpZWxkcyA9PT0gbnVsbCB8fCBmaWVsZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkcy5sZW5ndGgpID4gMCAmJlxuICAgICAgICAhY2FuVXNlUmVuZGVyZXJGb3JQdWJsaXNoVGlsZXMocmVuZGVyZXIsIGxheWVySW5mby5nZW9tZXRyeVR5cGUsIGZpZWxkcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBsYWJlbHNcbiAgICBpZiAoIWFsbG93TGFiZWxzICYmIChsYWJlbGluZ0luZm8gPT09IG51bGwgfHwgbGFiZWxpbmdJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYWJlbGluZ0luZm8ubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgbGF5ZXJIYXNDbHVzdGVyaW5nID0gKGxheWVySW5mbykgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZmVhdHVyZVJlZHVjdGlvbiA9IChfYSA9IGxheWVySW5mby5mZWF0dXJlUmVkdWN0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IgPSBsYXllckluZm8ubGF5ZXJEZWZpbml0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZmVhdHVyZVJlZHVjdGlvbjtcbiAgICByZXR1cm4gISFmZWF0dXJlUmVkdWN0aW9uICYmIE9iamVjdC5rZXlzKGZlYXR1cmVSZWR1Y3Rpb24pLmxlbmd0aCA+IDA7XG59O1xuY29uc3QgY2FuVXNlUmVuZGVyZXJGb3JQdWJsaXNoVGlsZXMgPSAocmVuZGVyZXIsIGdlb21ldHJ5VHlwZSwgZmllbGRzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIGhlYXRtYXAgcmVuZGVyZXJcbiAgICBpZiAocmVuZGVyZXIudHlwZSA9PT0gXCJoZWF0bWFwXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBzY2FsZSBkZXBlbmRlbnQgbWFya2VyIHNpemluZyBvbiBwb2x5Z29uIGxheWVyXG4gICAgLypcbiAgICAgIGlmIChsYXllckluZm8uZ2VvbWV0cnlUeXBlID09PSBcImVzcmlHZW9tZXRyeVBvbHlnb25cIiAmJiByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKGFycmF5LnNvbWUocmVuZGVyZXIudmlzdWFsVmFyaWFibGVzLCBmdW5jdGlvbiAodmlzVmFyKSB7XG4gICAgICAgICAgICAvLyB7dGFyZ2V0OiBcIm91dGxpbmVcIn0gaXMgT0tcbiAgICAgICAgICAgIGlmICh2aXNWYXIudHlwZSA9PT0gXCJzaXplSW5mb1wiICYmICF2aXNWYXIudGFyZ2V0ICYmXG4gICAgICAgICAgICAgICh0eXBlb2YgdmlzVmFyLm1pblNpemUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZpc1Zhci5tYXhTaXplID09PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICovXG4gICAgLy8gdHlwZSArIHNpemUgb24gcG9seWdvbiBsYXllclxuICAgIGlmIChnZW9tZXRyeVR5cGUgPT09IFwiZXNyaUdlb21ldHJ5UG9seWdvblwiICYmIHJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MgJiYgcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzKSB7XG4gICAgICAgIGlmIChyZW5kZXJlci52aXN1YWxWYXJpYWJsZXMuc29tZSgodmlzVmFyKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlzVmFyLnR5cGUgPT09IFwic2l6ZUluZm9cIiAmJiAhdmlzVmFyLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRhdGUgZmllbGRzXG4gICAgY29uc3QgZGF0ZUZpZWxkcyA9IGZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC50eXBlID09PSBcImVzcmlGaWVsZFR5cGVEYXRlXCIpLm1hcCgoZmllbGQpID0+IGZpZWxkLm5hbWUpO1xuICAgIGlmIChkYXRlRmllbGRzLmxlbmd0aCkge1xuICAgICAgICAvLyByZW5kZXJlciB1c2luZyBkYXRlIGZpZWxkXG4gICAgICAgIGlmIChkYXRlRmllbGRzLmluZGV4T2YocmVuZGVyZXIuZmllbGQpID4gLTEgfHwgZGF0ZUZpZWxkcy5pbmRleE9mKHJlbmRlcmVyLmZpZWxkMSkgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZpc3VhbCB2YXJpYWJsZXMgd2l0aCBkYXRlIGZpZWxkXG4gICAgICAgIGlmICgoX2EgPSByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKCh2aXNWYXIpID0+IGRhdGVGaWVsZHMuaW5kZXhPZih2aXNWYXIuZmllbGQpID4gLTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gY2FuVXNlTGF5ZXJGb3JQdWJsaXNoU2NlbmUobGF5ZXJJbmZvLCBhbGxvd0xhYmVscykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXJJbmZvLmRyYXdpbmdJbmZvLnJlbmRlcmVyO1xuICAgIGNvbnN0IGxhYmVsaW5nSW5mbyA9IGxheWVySW5mby5kcmF3aW5nSW5mby5sYWJlbGluZ0luZm87XG4gICAgY29uc3QgZmVhdHVyZVJlZHVjdGlvbiA9IGxheWVySW5mby5mZWF0dXJlUmVkdWN0aW9uO1xuICAgIGNvbnN0IGZpZWxkcyA9IGxheWVySW5mby5maWVsZHM7XG4gICAgLy8gb25seSBwb2ludCBvciBtdWx0aVBhdGNoIGxheWVyc1xuICAgIGlmIChbXCJlc3JpR2VvbWV0cnlQb2ludFwiLCBcImVzcmlHZW9tZXRyeU11bHRpUGF0Y2hcIl0uaW5kZXhPZihsYXllckluZm8uZ2VvbWV0cnlUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBzdHJlYW0gbGF5ZXJcbiAgICBpZiAocmVuZGVyZXIub2JzZXJ2YXRpb25SZW5kZXJlciB8fCByZW5kZXJlci5sYXRlc3RPYnNlcnZhdGlvblJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gaGVhdG1hcCByZW5kZXJlclxuICAgIGlmIChyZW5kZXJlci50eXBlID09PSBcImhlYXRtYXBcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFyY2FkZSBleHByZXNzaW9uc1xuICAgIGlmICgoX2EgPSByZW5kZXJlci52YWx1ZUV4cHJlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKF9iID0gcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc29tZSgodmlzVmFyKSA9PiB2aXNWYXIudmFsdWVFeHByZXNzaW9uLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBkYXRlIGZpZWxkc1xuICAgIGNvbnN0IGRhdGVGaWVsZHMgPSBmaWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gXCJlc3JpRmllbGRUeXBlRGF0ZVwiKS5tYXAoKGZpZWxkKSA9PiBmaWVsZC5uYW1lKTtcbiAgICBpZiAoZGF0ZUZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVuZGVyZXIgdXNpbmcgZGF0ZSBmaWVsZFxuICAgICAgICBpZiAoZGF0ZUZpZWxkcy5pbmRleE9mKHJlbmRlcmVyLmZpZWxkKSA+IC0xIHx8IGRhdGVGaWVsZHMuaW5kZXhPZihyZW5kZXJlci5maWVsZDEpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB2aXN1YWwgdmFyaWFibGVzIHdpdGggZGF0ZSBmaWVsZFxuICAgICAgICBpZiAoKF9jID0gcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc29tZSgodmlzVmFyKSA9PiB2aXNWYXIuZmllbGQgJiYgZGF0ZUZpZWxkcy5pbmRleE9mKHZpc1Zhci5maWVsZCkgPiAtMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjbHVzdGVyaW5nXG4gICAgaWYgKGZlYXR1cmVSZWR1Y3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBsYWJlbHNcbiAgICBpZiAoIWFsbG93TGFiZWxzICYmIChsYWJlbGluZ0luZm8gPT09IG51bGwgfHwgbGFiZWxpbmdJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYWJlbGluZ0luZm8ubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgZ2V0UHVibGlzaFRpbGVMYXllclBhcmFtcyA9IChpdGVtSW5mbywgcHVibGlzaEluZm8sIGlzRW50ZXJwcmlzZSkgPT4ge1xuICAgIGNvbnN0IHsgcHVibGlzaFR5cGUsIGNhY2hlT25EZW1hbmQsIHRpbGVJbmZvLCBjYWNoZU9uRGVtYW5kTWluU2NhbGUsIHNjYWxlLCBsYXllcnMgfSA9IHB1Ymxpc2hJbmZvO1xuICAgIGNvbnN0IHsgbWF4U2NhbGUsIG1pblNjYWxlIH0gPSBzY2FsZTtcbiAgICBjb25zdCBjYWNoZVN0b3JhZ2VJbmZvID0ge1xuICAgICAgICBzdG9yYWdlRm9ybWF0OiBpc0VudGVycHJpc2UgfHwgcHVibGlzaEluZm8ucHVibGlzaFR5cGUgPT09IFwidmVjdG9yVGlsZXNcIlxuICAgICAgICAgICAgPyBcImVzcmlNYXBDYWNoZVN0b3JhZ2VNb2RlQ29tcGFjdFYyXCJcbiAgICAgICAgICAgIDogXCJlc3JpTWFwQ2FjaGVTdG9yYWdlTW9kZUV4cGxvZGVkXCIsXG4gICAgICAgIHBhY2tldFNpemU6IDEyOFxuICAgIH07XG4gICAgY29uc3QgdGlsZUNhY2hlSW5mbyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHB1Ymxpc2hUeXBlID09PSBcInZlY3RvclRpbGVzXCIgPyBwcmVzZXRWZWN0b3JUaWxlQ2FjaGVJbmZvIDogcHJlc2V0UmFzdGVyVGlsZUNhY2hlSW5mbykpLCB0aWxlSW5mbyk7XG4gICAgaWYgKHRpbGVDYWNoZUluZm8uZHBpICYmICF0aWxlQ2FjaGVJbmZvLnByZWNpc2VEcGkpIHtcbiAgICAgICAgdGlsZUNhY2hlSW5mby5wcmVjaXNlRHBpID0gdGlsZUNhY2hlSW5mby5kcGk7XG4gICAgfVxuICAgIHRpbGVDYWNoZUluZm8ubG9kcyA9IHRpbGVDYWNoZUluZm8ubG9kcy5tYXAoKF9hKSA9PiB7XG4gICAgICAgIHZhciBsb2QgPSBfX3Jlc3QoX2EsIFtcImxhYmVsXCJdKTtcbiAgICAgICAgcmV0dXJuIGxvZDtcbiAgICB9KTtcbiAgICAvLyAtLS0gTWFpbiBpbmZvXG4gICAgY29uc3QgdGlsZUltYWdlSW5mbyA9IHB1Ymxpc2hUeXBlID09PSBcInZlY3RvclRpbGVzXCIgPyBPYmplY3QuYXNzaWduKHt9LCBwcmVzZXRWZWN0b3JUaWxlSW1hZ2VJbmZvKSA6IE9iamVjdC5hc3NpZ24oe30sIHByZXNldFJhc3RlclRpbGVJbWFnZUluZm8pO1xuICAgIGxldCBwdWJsaXNoUGFyYW1ldGVycyA9IHtcbiAgICAgICAgbmFtZTogZm9ybWF0RmlsZU5hbWUoaXRlbUluZm8udGl0bGUpLFxuICAgICAgICB0aWxpbmdTY2hlbWE6IHsgdGlsZUNhY2hlSW5mbywgdGlsZUltYWdlSW5mbywgY2FjaGVTdG9yYWdlSW5mbyB9LFxuICAgICAgICBtaW5TY2FsZSxcbiAgICAgICAgbWF4U2NhbGVcbiAgICB9O1xuICAgIGlmIChsYXllcnMpIHtcbiAgICAgICAgcHVibGlzaFBhcmFtZXRlcnMubGF5ZXJzID0gbGF5ZXJzLm1hcCgoeyBsYXllckRlZmluaXRpb24sIGlkLCBkcmF3aW5nSW5mbyB9KSA9PiBcbiAgICAgICAgLy8gT3ZlcnJpZGUgZHJhd2luZ0luZm8gaWYgaXQgZXhpc3RzXG4gICAgICAgIChsYXllckRlZmluaXRpb24gPT09IG51bGwgfHwgbGF5ZXJEZWZpbml0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllckRlZmluaXRpb24uZHJhd2luZ0luZm8pXG4gICAgICAgICAgICA/IHsgaWQsIGRyYXdpbmdJbmZvOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRyYXdpbmdJbmZvKSwgbGF5ZXJEZWZpbml0aW9uLmRyYXdpbmdJbmZvKSB9XG4gICAgICAgICAgICA6IHsgaWQsIGRyYXdpbmdJbmZvIH0pO1xuICAgIH1cbiAgICBpZiAocHVibGlzaFR5cGUgIT09IFwidmVjdG9yVGlsZXNcIikge1xuICAgICAgICAvLyBPbiBkZW1hbmQgc3R1ZmZcbiAgICAgICAgcHVibGlzaFBhcmFtZXRlcnMuY2FjaGVPbkRlbWFuZCA9IGNhY2hlT25EZW1hbmQ7XG4gICAgICAgIGlmIChjYWNoZU9uRGVtYW5kKSB7XG4gICAgICAgICAgICBwdWJsaXNoUGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHVibGlzaFBhcmFtZXRlcnMpLCB7IGNhcGFiaWxpdGllczogXCJNYXAsQ2hhbmdlVHJhY2tpbmdcIiwgY2FjaGVPbkRlbWFuZE1pblNjYWxlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHB1Ymxpc2hDb250ZW50ID0ge1xuICAgICAgICBpdGVtSWQ6IGl0ZW1JbmZvLmlkLFxuICAgICAgICBmaWxldHlwZTogXCJmZWF0dXJlU2VydmljZVwiLFxuICAgICAgICBvdXRwdXRUeXBlOiBwdWJsaXNoVHlwZSxcbiAgICAgICAgcHVibGlzaFBhcmFtZXRlcnM6IEpTT04uc3RyaW5naWZ5KHB1Ymxpc2hQYXJhbWV0ZXJzKSxcbiAgICAgICAgYnVpbGRJbml0aWFsQ2FjaGU6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4geyBwdWJsaXNoQ29udGVudCwgcHVibGlzaFBhcmFtZXRlcnMgfTtcbn07XG5cbmNvbnN0IGdldFRpbGVMYXllckluZm8gPSBhc3luYyAodXJsLCBpc1ZlY3RvclRpbGVzKSA9PiB7XG4gICAgY29uc3QgaXNWYWxpZFVybFR5cGUgPSB1cmwuaW5jbHVkZXMoaXNWZWN0b3JUaWxlcyA/IFwiL1ZlY3RvclRpbGVTZXJ2ZXJcIiA6IFwiL01hcFNlcnZlclwiKTtcbiAgICBpZiAoIWlzVmFsaWRVcmxUeXBlKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwiaW52YWxpZFVybFwiIH0gfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdCh1cmwsIHt9LCB7IGFkZFRva2VuTWFudWFsbHk6IGZhbHNlIH0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zaW5nbGVGdXNlZE1hcENhY2hlICYmIHJlc3VsdC50aWxlSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBhZGRTY2FsZUxhYmVscyhyZXN1bHQudGlsZUluZm8pIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ICYmIGlzVmVjdG9yVGlsZXMgJiYgcmVzdWx0LnRpbGVJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHJlc3VsdC50aWxlSW5mbyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwibm9UaWxpbmdTY2hlbWVGb3VuZFwiIH0gfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcIm1hcFNlcnZpY2VFcnJvclwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfSB9O1xuICAgIH1cbn07XG5jb25zdCBnZXRTdWdnZXN0ZWRTY2FsZVJhbmdlRm9yTGF5ZXIgPSBhc3luYyAodXJsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVE9ETzogVGVzdCBtb3JlIHRob3JvdWdobHkgYXMgdGhpcyBoYXMgb25seSBiZWVuIHRlc3RlZCB3aXRoIDAgc2FtcGxpbmdcbiAgICAgICAgY29uc3QgW0ZlYXR1cmVMYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2xheWVycy9GZWF0dXJlTGF5ZXJcIl0pO1xuICAgICAgICBjb25zdCBmZWF0dXJlTGF5ZXIgPSBuZXcgRmVhdHVyZUxheWVyKHVybCk7XG4gICAgICAgIGNvbnN0IHBsdWdnZWRJbkZlYXR1cmVMYXllciA9IGF3YWl0IGZlYXR1cmVMYXllci5hZGRQbHVnaW4oXCJlc3JpL3BsdWdpbnMvRmVhdHVyZUxheWVyU3RhdGlzdGljc1wiKTtcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGVkU2NhbGUgPSBhd2FpdCBwbHVnZ2VkSW5GZWF0dXJlTGF5ZXIudGFyZ2V0LnN0YXRpc3RpY3NQbHVnaW4uZ2V0U3VnZ2VzdGVkU2NhbGVSYW5nZSh7XG4gICAgICAgICAgICBzYW1wbGVTaXplOiAxMDAsXG4gICAgICAgICAgICBmb3JQdWJsaXNoaW5nVGlsZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogc3VnZ2VzdGVkU2NhbGUgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNhbXBsaW5nIHJldHVybmVkIDAgZmVhdHVyZXNcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogbnVsbCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfSB9O1xuICAgIH1cbn07XG5jb25zdCBnZXRTdWdnZXN0ZWRTY2FsZVJhbmdlID0gYXN5bmMgKGNvbnN0cmFpbnRzLCBjdXJMb2RzLCBmZWF0dXJlTGF5ZXJJbmZvcywgaXRlbVVybCkgPT4ge1xuICAgIC8vIGNvbnN0cmFpbnRzIGFuZCBpbml0aWFsIG1pbi9tYXhTY2FsZSB2YWx1ZXMgd2lsbCBiZSB0aGUgc2FtZSBpbml0aWFsbHlcbiAgICBjb25zdCBsb2QxNVNjYWxlID0gMTgwNTUuOTU0ODIyO1xuICAgIGxldCBtYXhTdXBwb3J0ZWRNaW5TY2FsZSA9IG51bGw7XG4gICAgbGV0IGNhY2hlT25EZW1hbmRNaW5TY2FsZSA9IFRJTEVfTEFZRVJfU0NBTEVfTUlOO1xuICAgIGNvbnN0IGNhbGN1bGF0ZWRTY2FsZSA9IHtcbiAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnRzLFxuICAgICAgICBtaW5TY2FsZTogY29uc3RyYWludHMubWluU2NhbGUsXG4gICAgICAgIG1heFNjYWxlOiBjb25zdHJhaW50cy5tYXhTY2FsZSB8fCBsb2QxNVNjYWxlXG4gICAgfTtcbiAgICBpZiAoIWl0ZW1VcmwpIHtcbiAgICAgICAgcmV0dXJuIHsgbWF4U3VwcG9ydGVkTWluU2NhbGUsIGNhY2hlT25EZW1hbmRNaW5TY2FsZSwgY2FsY3VsYXRlZFNjYWxlIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoZmVhdHVyZUxheWVySW5mb3MubWFwKCh7IGlkIH0pID0+IGdldFN1Z2dlc3RlZFNjYWxlUmFuZ2VGb3JMYXllcihgJHtpdGVtVXJsfS8ke2lkfWApKSk7XG4gICAgICAgIGxldCBtYXhPZk1pblNjYWxlID0gMDtcbiAgICAgICAgbGV0IG1pbk9mTWF4U2NhbGUgPSBJbmZpbml0eTtcbiAgICAgICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmZXRjaERhdGEgPSByZXN1bHQudmFsdWUucmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFmZXRjaERhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG1heFNjYWxlLCBtaW5TY2FsZSB9ID0gZmV0Y2hEYXRhO1xuICAgICAgICAgICAgbWF4T2ZNaW5TY2FsZSA9IG1pblNjYWxlID09IG51bGwgfHwgbWluU2NhbGUgPD0gbWF4T2ZNaW5TY2FsZSA/IG1heE9mTWluU2NhbGUgOiBtaW5TY2FsZTtcbiAgICAgICAgICAgIG1pbk9mTWF4U2NhbGUgPSBtYXhTY2FsZSA9PSBudWxsIHx8IG1heFNjYWxlID49IG1pbk9mTWF4U2NhbGUgPyBtaW5PZk1heFNjYWxlIDogbWF4U2NhbGU7XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBmbG9vciBvZiB0aGUgbWluU2NhbGVzIGZvciBtdWx0aS1sYXllciBmZWF0dXJlIHNlcnZpY2VzIGZvciB0aGUgY2FjaGUgb24gZGVtYW5kIG1pbiBzY2FsZVxuICAgICAgICAgICAgY2FjaGVPbkRlbWFuZE1pblNjYWxlID0gbWluU2NhbGUgPT0gbnVsbCB8fCBtaW5TY2FsZSA+PSBjYWNoZU9uRGVtYW5kTWluU2NhbGUgPyBjYWNoZU9uRGVtYW5kTWluU2NhbGUgOiBtaW5TY2FsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1heFN1cHBvcnRlZE1pblNjYWxlID0gY29uc3RyYWludHMubWluU2NhbGUgfHwgVElMRV9MQVlFUl9TQ0FMRV9NSU47XG4gICAgICAgIGNhY2hlT25EZW1hbmRNaW5TY2FsZSB8fCAoY2FjaGVPbkRlbWFuZE1pblNjYWxlID0gbWF4T2ZNaW5TY2FsZSk7XG4gICAgICAgIGNhbGN1bGF0ZWRTY2FsZS5taW5TY2FsZSA9IGNhY2hlT25EZW1hbmRNaW5TY2FsZSB8fCBjb25zdHJhaW50cy5taW5TY2FsZTtcbiAgICAgICAgY2FsY3VsYXRlZFNjYWxlLm1heFNjYWxlID0gbWluT2ZNYXhTY2FsZSB8fCBjYWxjdWxhdGVkU2NhbGUubWF4U2NhbGU7IC8vIGRvbid0IGFsbG93IG1heFNjYWxlIG9mIDBcbiAgICAgICAgLy8gKiAtLS0gTm9ybWFsaXplIG1pbiBhbmQgbWF4IHNjYWxlIGRvd253YXJkIHRvIG1hdGNoIGZlYXR1cmUgbGF5ZXIgY29uc3RyYWludHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChjYWxjdWxhdGVkU2NhbGUubWluU2NhbGUgPiBjb25zdHJhaW50cy5taW5TY2FsZSAmJiBjb25zdHJhaW50cy5taW5TY2FsZSA+IDApIHtcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRTY2FsZS5taW5TY2FsZSA9IGNvbnN0cmFpbnRzLm1pblNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxjdWxhdGVkU2NhbGUubWF4U2NhbGUgPj0gY2FsY3VsYXRlZFNjYWxlLm1pblNjYWxlICYmIGNhbGN1bGF0ZWRTY2FsZS5taW5TY2FsZSA+IDApIHtcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRTY2FsZS5tYXhTY2FsZSA9IG5vcm1hbGl6ZU1heFNjYWxlKGNhbGN1bGF0ZWRTY2FsZS5taW5TY2FsZSwgY2FsY3VsYXRlZFNjYWxlLm1heFNjYWxlLCBjdXJMb2RzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIC8vICogLS0tIEVycm9yIHJldHJpZXZpbmcgc3VnZ2VzdGVkIHNjYWxlIHJhbmdlLCBjb250aW51ZSB3aXRob3V0IG5vdGlmaWNhdGlvblxuICAgICAgICBjYWxjdWxhdGVkU2NhbGUubWluU2NhbGUgPSBjb25zdHJhaW50cy5taW5TY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWF4U3VwcG9ydGVkTWluU2NhbGUsIGNhY2hlT25EZW1hbmRNaW5TY2FsZSwgY2FsY3VsYXRlZFNjYWxlIH07XG59O1xuY29uc3QgcHVibGlzaFRpbGVMYXllciA9IGFzeW5jICh0aWxlTGF5ZXJQdWJsaXNoQ29udGVudCwgcHVibGlzaEluZm8sIHVwZGF0ZURhdGEpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBwdWJsaXNoVHlwZSwgdXNlciwgZm9sZGVyLCB0aXRsZSwgdGFncywgc25pcHBldCwgY2F0ZWdvcmllcyB9ID0gcHVibGlzaEluZm87XG4gICAgbGV0IHB1Ymxpc2hDb250ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgdGlsZUxheWVyUHVibGlzaENvbnRlbnQpO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgICBjb25zdCBwdWJsaXNoUGFyYW1ldGVycyA9IEpTT04ucGFyc2UocHVibGlzaENvbnRlbnQucHVibGlzaFBhcmFtZXRlcnMpO1xuICAgICAgICBwdWJsaXNoUGFyYW1ldGVycy5uYW1lID0gZm9ybWF0RmlsZU5hbWUodGl0bGUpO1xuICAgICAgICBwdWJsaXNoQ29udGVudC5wdWJsaXNoUGFyYW1ldGVycyA9IEpTT04uc3RyaW5naWZ5KHB1Ymxpc2hQYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dXNlci51c2VyQ29udGVudFVybH0vcHVibGlzaGA7XG4gICAgY29uc3QgeyBzZXJ2aWNlcyB9ID0gYXdhaXQgcmVxdWVzdCh1cmwsIHB1Ymxpc2hDb250ZW50LCB7fSwgXCJwb3N0XCIpO1xuICAgIGNvbnN0IHsgam9iSWQsIHNlcnZpY2VJdGVtSWQsIHNlcnZpY2V1cmwsIGVycm9yLCB0eXBlIH0gPSBzZXJ2aWNlc1swXSB8fCB7fTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIHRoZSBuZXcgZXJyb3Igc3lzdGVtXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBhd2FpdCBnZXRJdGVtU3RhdHVzKHNlcnZpY2VJdGVtSWQsIHsgam9iSWQsIHN1Y2Nlc3M6IHRydWUgfSk7XG4gICAgcHVibGlzaFR5cGUgIT09IFwic2NlbmVzXCIgJiYgKGF3YWl0IHVwZGF0ZUl0ZW0oc2VydmljZUl0ZW1JZCwgeyB0aXRsZSwgdGFncywgc25pcHBldCwgY2F0ZWdvcmllcyB9KSk7XG4gICAgdXBkYXRlRGF0YSAmJiAoYXdhaXQgdXBkYXRlSXRlbShzZXJ2aWNlSXRlbUlkLCB7IHRleHQ6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZURhdGEpIH0pKTtcbiAgICBmb2xkZXIuaWQgIT09ICgoX2EgPSBjb25maWdTdGF0ZS5pbml0aWFsRm9sZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpICYmXG4gICAgICAgIChhd2FpdCBtb3ZlSXRlbShzZXJ2aWNlSXRlbUlkLCBpc0ZvbGRlclJvb3QoZm9sZGVyKSA/IFwiL1wiIDogZm9sZGVyLmlkKSk7XG4gICAgcmV0dXJuIHsgaWQ6IHNlcnZpY2VJdGVtSWQsIGpvYklkLCBzZXJ2aWNlVHlwZTogdHlwZSwgc2VydmljZVVybDogc2VydmljZXVybCB9O1xufTtcbmNvbnN0IGdldERhdGFzdG9yZVNlcnZlcnMgPSBhc3luYyAoZGF0YXN0b3JlSWQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmFyY2dpcy5jb20vcmVzdC91c2Vycy1ncm91cHMtYW5kLWl0ZW1zL2dldC1zZXJ2ZXJzLWZvci1kYXRhLXN0b3JlLmh0bVxuICAgIGNvbnN0IHBvcnRhbCA9IGNvbmZpZ1N0YXRlLnBvcnRhbDtcbiAgICBjb25zdCByZXN0QmFzZVVybCA9IGAkeyhfYSA9IHBvcnRhbC5yZXN0VXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwb3J0YWwucG9ydGFsVXJsfXBvcnRhbHMvJHtwb3J0YWwuaWR9YDtcbiAgICBjb25zdCBzZXJ2ZXJJZEFwaVVybCA9IGAke3Jlc3RCYXNlVXJsfS9kYXRhc3RvcmVzL2dldFNlcnZlcnNgO1xuICAgIGNvbnN0IHNlcnZlcklkQXBpUGF5bG9hZCA9IHsgZGF0YXN0b3JlSWQ6IGRhdGFzdG9yZUlkLCBmOiBcImpzb25cIiB9O1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdChzZXJ2ZXJJZEFwaVVybCwgc2VydmVySWRBcGlQYXlsb2FkLCB7fSwgXCJwb3N0XCIpO1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHJlc3BvbnNlLnNlcnZlcnMgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKSB9IH07XG4gICAgfVxufTtcbmNvbnN0IGZvcm1VcGRhdGVJdGVtRGF0YUZvclRpbGVMYXllciA9IGFzeW5jICh7IGl0ZW1JZCwgaXRlbVVybCwgcG9ydGFsLCBwdWJsaXNoVHlwZSwgZnVsbExheWVycyB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaXRlbURhdGEgPSBhd2FpdCBnZXRJdGVtRGF0YShpdGVtSWQsIHBvcnRhbCk7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgbGF5ZXJzIHdpdGggYSBwb3B1cCB0byBpbmNsdWRlIHRoZSB1cmwgcHJvcGVydHkgZm9yIHRoZSBmZWF0dXJlIHNlcnZpY2UgbGF5ZXJcbiAgICAgICAgY29uc3QgbGF5ZXJMaXN0ID0gKChpdGVtRGF0YSA9PT0gbnVsbCB8fCBpdGVtRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbURhdGEubGF5ZXJzKSB8fCBbXSlcbiAgICAgICAgICAgIC5tYXAoKGxheWVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGF5ZXJJZCA9IChfYSA9IGxheWVyLmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbmRleDtcbiAgICAgICAgICAgIGxldCBuZXdMYXllciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbGF5ZXIpLCB7IGlkOiBsYXllcklkLCBsYXllclVybDogYCR7aXRlbVVybH0vJHtsYXllcklkfWAsIGxheWVySXRlbUlkOiBpdGVtSWQsIGxheWVyRGVmaW5pdGlvbjogbGF5ZXIubGF5ZXJEZWZpbml0aW9uIH0pO1xuICAgICAgICAgICAgaWYgKHB1Ymxpc2hUeXBlID09PSBcInZlY3RvclwiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0xheWVyLnBvcHVwSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXllci5wb3B1cEluZm8pIHtcbiAgICAgICAgICAgICAgICBuZXdMYXllciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV3TGF5ZXIpLCB7IHBvcHVwSW5mbzogbGF5ZXIucG9wdXBJbmZvIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheWVyLnNob3dMZWdlbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld0xheWVyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXdMYXllciksIHsgc2hvd0xlZ2VuZDogbGF5ZXIuc2hvd0xlZ2VuZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvcnJlc3BvbmRpbmdGdWxsTGF5ZXIgPSBmdWxsTGF5ZXJzLmZpbmQoKGZ1bGxMYXllcikgPT4gZnVsbExheWVyLmlkID09PSBsYXllcklkKTtcbiAgICAgICAgICAgIC8vIFVzaW5nIHRoZSBjb3JyZXNwb25kaW5nRnVsbExheWVyIGFzIHRoZSBmYWxsYmFjayBvZiB0aGUgZHJhd2luZ0luZm9cbiAgICAgICAgICAgIG5ld0xheWVyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXdMYXllciksIHsgZHJhd2luZ0luZm86IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb3JyZXNwb25kaW5nRnVsbExheWVyID09PSBudWxsIHx8IGNvcnJlc3BvbmRpbmdGdWxsTGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvcnJlc3BvbmRpbmdGdWxsTGF5ZXIuZHJhd2luZ0luZm8pLCBsYXllci5kcmF3aW5nSW5mbyksIHsgcmVuZGVyZXI6IChfYyA9IChfYiA9IGxheWVyLmRyYXdpbmdJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVuZGVyZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChfZCA9IGNvcnJlc3BvbmRpbmdGdWxsTGF5ZXIgPT09IG51bGwgfHwgY29ycmVzcG9uZGluZ0Z1bGxMYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ycmVzcG9uZGluZ0Z1bGxMYXllci5kcmF3aW5nSW5mbykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlbmRlcmVyIH0pIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0xheWVyO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigobGF5ZXIpID0+IGxheWVyICE9IG51bGwpO1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbURhdGEpLCB7IGxheWVyczogbGF5ZXJMaXN0IH0pIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfSB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGNhblVzZUxheWVyRm9yUHVibGlzaFRpbGVzIGFzIGEsIGdldFRpbGVMYXllckluZm8gYXMgYiwgY2FuVXNlUmVuZGVyZXJGb3JQdWJsaXNoVGlsZXMgYXMgYywgZ2V0UHVibGlzaFRpbGVMYXllclBhcmFtcyBhcyBkLCBnZXRTdWdnZXN0ZWRTY2FsZVJhbmdlIGFzIGUsIGZvcm1VcGRhdGVJdGVtRGF0YUZvclRpbGVMYXllciBhcyBmLCBnZXREYXRhc3RvcmVTZXJ2ZXJzIGFzIGcsIGNoZWNrVGlsZXNPbkRlbWFuZFN1cHBvcnQgYXMgaCwgbGF5ZXJIYXNDbHVzdGVyaW5nIGFzIGwsIHB1Ymxpc2hUaWxlTGF5ZXIgYXMgcCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aWxlLWxheWVyLThhN2I5M2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==