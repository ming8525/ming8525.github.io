"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-045495"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-credit-estimate_2.entry.js":
/*!***************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-credit-estimate_2.entry.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_credit_estimate: () => (/* binding */ ArcgisCreditEstimate),
/* harmony export */   arcgis_select: () => (/* binding */ ArcgisSelect)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _util_21dc2ac5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util-21dc2ac5.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-21dc2ac5.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./guid-aeaed84d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */









const arcgisCreditEstimateCss = ":host{display:flex;border:1px solid var(--calcite-color-border-1)}.left{padding-top:1rem;padding-bottom:1rem;padding-left:1.5rem;padding-right:1.5rem;flex:1 1 auto}.right{display:flex;flex-direction:column;justify-content:center;padding-top:1rem;padding-bottom:1rem;padding-left:1.5rem;padding-right:1.5rem;text-align:center;font-size:0.875rem;color:var(--calcite-color-text-3);flex:0 0 auto;border-inline-start:1px solid var(--calcite-color-border-1)}.number{display:block;font-size:1.625rem;font-weight:700}.number--blue{color:var(--calcite-color-brand)}.number--red{color:var(--calcite-color-status-danger)}.number--orange{color:#fe583e}.number calcite-icon{margin-inline-end:0.25rem;vertical-align:-0.25rem}.header{margin:0px;padding-bottom:0.5rem;font-size:1rem;font-weight:500;color:var(--calcite-color-text-1)}.text{margin-bottom:0.25rem;margin-top:0px;display:flex;font-size:0.875rem;color:var(--calcite-color-text-2)}.text--left{flex:1 1 auto}";

const ArcgisCreditEstimate = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.api = 4;
        this.transactionCreditCost = undefined;
        this.availableCredits = undefined;
        this.showTotal = false;
        this.formattedStrings = undefined;
    }
    updateTransactionCost() {
        this.replaceStrings();
    }
    async componentWillLoad() {
        const locale = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.el);
        this.i18n = locale[0];
        await this.replaceStrings();
    }
    async replaceStrings() {
        const { transactionCreditCost, availableCredits, i18n } = this;
        const options = { api: this.api, type: "decimal", places: 2 };
        const available = await (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.f)(availableCredits, options);
        const needed = await (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.f)(transactionCreditCost, options);
        const percent = await (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.f)(transactionCreditCost / availableCredits, Object.assign(Object.assign({}, options), { type: "percent" }));
        this.formattedStrings = Object.assign(Object.assign({}, i18n), { creditsAvailable: i18n.creditsAvailable.replace("${credits}", available), creditsAvailableColon: i18n.creditsAvailableColon.replace("${credits}", available), creditsNeededColon: i18n.creditsNeededColon.replace("${credits}", needed), creditsNeeded: i18n.creditsNeeded.replace("${credits}", needed), creditsNeededPercent: i18n.creditsNeededPercent.replace("${percent}", percent), needed,
            percent });
    }
    render() {
        if (!this.formattedStrings) {
            return null;
        }
        const { transactionCreditCost, availableCredits, showTotal, formattedStrings: i18n, api } = this;
        const color = (0,_util_21dc2ac5_js__WEBPACK_IMPORTED_MODULE_3__.g)(transactionCreditCost, availableCredits);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "left" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("h4", { class: "header" }, i18n.creditEstimate), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("p", { class: "text" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "text--left" }, i18n.creditsNeededColon), showTotal && (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, i18n.creditsAvailableColon)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-meter", { max: availableCredits, maxLabel: i18n.notEnough, current: transactionCreditCost, min: 0, label: showTotal ? i18n.creditEstimate : i18n.creditsNeededPercent, api: api })), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "right" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: `number number--${color}` }, color === "red" && (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: "exclamation-mark-triangle" }), i18n.needed), i18n.creditsNeeded)));
    }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "transactionCreditCost": ["updateTransactionCost"],
        "availableCredits": ["updateTransactionCost"]
    }; }
};
ArcgisCreditEstimate.style = arcgisCreditEstimateCss;

const arcgisSelectCss = ":host{position:relative}.select{margin-top:0.25rem;margin-bottom:1rem;position:relative}.select--no-margin{margin:0}.label{font-size:0.875rem;color:var(--calcite-color-text-1);line-height:18px}.label--bold{font-weight:500}.description{margin-top:0.5rem;margin-bottom:1rem;display:block;font-size:0.875rem;font-weight:400;color:var(--calcite-color-text-3)}.large{font-size:1rem}.dropdown-container{position:absolute;left:0px;--tw-shadow:0 6px 20px -4px rgba(0, 0, 0, 0.1), 0 4px 12px -2px rgba(0, 0, 0, 0.08);--tw-shadow-colored:0 6px 20px -4px var(--tw-shadow-color), 0 4px 12px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);width:100%;top:100%;max-height:240px;overflow:auto;z-index:100}";

const ArcgisSelect = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisOptionChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisOptionChange", 7);
        this.guid = (0,_guid_aeaed84d_js__WEBPACK_IMPORTED_MODULE_5__.g)();
        this.handleKeys = (event) => {
            const key = event.key;
            const { options, selectedIndex, selectOpen, selectedOption } = this;
            switch (key) {
                case " " :
                case "Enter":
                    this.selectOpen = !this.selectOpen;
                    if (selectOpen) {
                        this.arcgisOptionChange.emit(options[selectedIndex].value);
                    }
                    break;
                case "ArrowDown":
                    this.selectOpen = true;
                    if (this.selectOpen) {
                        event.preventDefault();
                        this.selectedIndex = (selectedIndex + 1) % options.length;
                    }
                    break;
                case "ArrowUp":
                    if (this.selectOpen) {
                        event.preventDefault();
                        if (selectedIndex === 0) {
                            this.selectedIndex = options.length - 1;
                        }
                        else {
                            this.selectedIndex = selectedIndex - 1;
                        }
                    }
                    break;
                case "Tab":
                    if (selectOpen) {
                        this.selectedIndex = Math.max(options.findIndex((option) => option.value === selectedOption), 0);
                        this.selectOpen = false;
                    }
                    break;
                case "Escape":
                    this.selectedIndex = Math.max(options.findIndex((option) => option.value === selectedOption), 0);
                    this.selectOpen = false;
                    this.defaultOptionRef.setFocus();
            }
        };
        this.renderOptions = () => {
            return this.options.map(({ optionTitle, description, icon, badge, value }, index) => {
                const isFocusedIndex = index === this.selectedIndex;
                const isSelectedOption = value === this.selectedOption;
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-option", { "aria-selected": isSelectedOption ? "true" : "false", selected: isSelectedOption, active: isFocusedIndex, optionTitle: optionTitle, value: value, badge: badge, description: description, icon: icon, autoFocus: true }));
            });
        };
        this.renderSelectedOption = () => {
            var _a;
            const { selectOpen, selectedOption, emptyText, options, guid } = this;
            const selected = options.find((option) => option.value === selectedOption);
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-option", { "aria-controls": `select_${guid}`, "aria-labelledby": `label_${guid}`, "aria-expanded": selectOpen ? "true" : "false", "aria-activedescendant": ((_a = options[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.value) || "no-selection", isSelector: true, optionTitle: (selected === null || selected === void 0 ? void 0 : selected.optionTitle) || emptyText, value: (selected === null || selected === void 0 ? void 0 : selected.value) || "", description: (selected === null || selected === void 0 ? void 0 : selected.description) || "", badge: selected === null || selected === void 0 ? void 0 : selected.badge, icon: (selected === null || selected === void 0 ? void 0 : selected.icon) || "", ref: (ele) => (this.defaultOptionRef = ele), onArcgisSelectOpen: () => {
                    this.selectOpen = !this.selectOpen;
                } }));
        };
        this.selectOpen = false;
        this.selectedIndex = undefined;
        this.selectedOption = "";
        this.emptyText = undefined;
        this.options = undefined;
        this.label = undefined;
        this.labelDescription = undefined;
        this.labelWeight = "bold";
        this.autoFocus = undefined;
        this.focusDelay = 0;
    }
    async componentDidLoad() {
        this.onSelectedOptionChanged(this.selectedOption);
        if (this.autoFocus && this.selectOpen) {
            await (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.t)(this.focusDelay);
            this.defaultOptionRef.focus();
        }
    }
    async setFocus() {
        this.defaultOptionRef.setFocus();
    }
    // eslint-disable-next-line @stencil/prefer-vdom-listener
    closeOnBlur() {
        this.selectOpen = false;
    }
    onSelectedOptionChanged(newSelectedOption) {
        const optionIndex = this.options.findIndex((option) => option.value === newSelectedOption);
        this.selectedIndex = Math.max(0, optionIndex);
    }
    async arcgisOptionChangeHandler() {
        this.selectOpen = false;
        this.defaultOptionRef.setFocus();
    }
    render() {
        const { label, labelDescription, guid, selectOpen } = this;
        const large = !!(this.label && this.labelDescription);
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("label", { id: `label_${guid}`, class: "label" }, label && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: { label: true, "label--bold": this.labelWeight === "bold", large } }, label, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", { name: "afterLabel" }))), labelDescription && (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: { description: true, large } }, labelDescription)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "select", onKeyDown: this.handleKeys }, this.renderSelectedOption(), selectOpen && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { role: "listbox", "aria-haspopup": "listbox", id: `select_${guid}`, class: "dropdown-container" }, this.renderOptions())))));
    }
    get element() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "selectedOption": ["onSelectedOptionChanged"]
    }; }
};
ArcgisSelect.style = arcgisSelectCss;



//# sourceMappingURL=arcgis-credit-estimate_2.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-aeaed84d.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ guid)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
function generateId(counts) {
    return counts
        .map((count) => {
        let out = "";
        for (let i = 0; i < count; i++) {
            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        return out;
    })
        .join("-");
}
const guid = () => generateId([2, 1, 1, 1, 3]);



//# sourceMappingURL=guid-aeaed84d.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-21dc2ac5.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-21dc2ac5.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ getMeterColor)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
function getMeterColor(current, max) {
    const percent = current / max;
    if (percent >= 1 || percent < 0) {
        return "red";
    }
    if (percent > 0.8) {
        return "orange";
    }
    return "blue";
}



//# sourceMappingURL=util-21dc2ac5.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTA0NTQ5NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNkc7QUFDOUM7QUFDTztBQUNkO0FBQ0E7QUFDVDtBQUNaO0FBQ1I7O0FBRTNCLHVDQUF1QyxhQUFhLCtDQUErQyxNQUFNLGlCQUFpQixvQkFBb0Isb0JBQW9CLHFCQUFxQixjQUFjLE9BQU8sYUFBYSxzQkFBc0IsdUJBQXVCLGlCQUFpQixvQkFBb0Isb0JBQW9CLHFCQUFxQixrQkFBa0IsbUJBQW1CLGtDQUFrQyxjQUFjLDREQUE0RCxRQUFRLGNBQWMsbUJBQW1CLGdCQUFnQixjQUFjLGlDQUFpQyxhQUFhLHlDQUF5QyxnQkFBZ0IsY0FBYyxxQkFBcUIsMEJBQTBCLHdCQUF3QixRQUFRLFdBQVcsc0JBQXNCLGVBQWUsZ0JBQWdCLGtDQUFrQyxNQUFNLHNCQUFzQixlQUFlLGFBQWEsbUJBQW1CLGtDQUFrQyxZQUFZLGNBQWM7O0FBRXo5QjtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQXlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSwwQkFBMEI7QUFDMUIsZ0NBQWdDLDREQUFZO0FBQzVDLDZCQUE2Qiw0REFBWTtBQUN6Qyw4QkFBOEIsNERBQVkseUVBQXlFLGNBQWMsaUJBQWlCO0FBQ2xKLDhEQUE4RCxXQUFXLG1EQUFtRCxRQUFRLDRFQUE0RSxRQUFRLHNFQUFzRSxRQUFRLHlEQUF5RCxRQUFRLHVFQUF1RSxRQUFRO0FBQ3RiLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtGQUFrRjtBQUNsRyxzQkFBc0Is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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscURBQVksOEJBQThCLGNBQWMsUUFBUSxPQUFPO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYyxFQUFFLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWUsR0FBRyxrQkFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRTRFOztBQUU1RTs7Ozs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEI7O0FBRTlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLWNyZWRpdC1lc3RpbWF0ZV8yLmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZ3VpZC1hZWFlZDg0ZC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxlLTA1MGI2ZGI5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3V0aWwtMjFkYzJhYzUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGgsIEggYXMgSG9zdCwgZCBhcyBnZXRFbGVtZW50LCBjIGFzIGNyZWF0ZUV2ZW50IH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5pbXBvcnQgeyBmIGFzIGZvcm1hdE51bWJlciB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyB9IGZyb20gJy4vbG9jYWxlLTA1MGI2ZGI5LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0TWV0ZXJDb2xvciB9IGZyb20gJy4vdXRpbC0yMWRjMmFjNS5qcyc7XG5pbXBvcnQgeyB0IGFzIHRpbWVvdXQgfSBmcm9tICcuL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMnO1xuaW1wb3J0IHsgZyBhcyBndWlkIH0gZnJvbSAnLi9ndWlkLWFlYWVkODRkLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgJy4vZG9tLTRkMzY3Njc3LmpzJztcblxuY29uc3QgYXJjZ2lzQ3JlZGl0RXN0aW1hdGVDc3MgPSBcIjpob3N0e2Rpc3BsYXk6ZmxleDtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWNhbGNpdGUtY29sb3ItYm9yZGVyLTEpfS5sZWZ0e3BhZGRpbmctdG9wOjFyZW07cGFkZGluZy1ib3R0b206MXJlbTtwYWRkaW5nLWxlZnQ6MS41cmVtO3BhZGRpbmctcmlnaHQ6MS41cmVtO2ZsZXg6MSAxIGF1dG99LnJpZ2h0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47anVzdGlmeS1jb250ZW50OmNlbnRlcjtwYWRkaW5nLXRvcDoxcmVtO3BhZGRpbmctYm90dG9tOjFyZW07cGFkZGluZy1sZWZ0OjEuNXJlbTtwYWRkaW5nLXJpZ2h0OjEuNXJlbTt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXNpemU6MC44NzVyZW07Y29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci10ZXh0LTMpO2ZsZXg6MCAwIGF1dG87Ym9yZGVyLWlubGluZS1zdGFydDoxcHggc29saWQgdmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItMSl9Lm51bWJlcntkaXNwbGF5OmJsb2NrO2ZvbnQtc2l6ZToxLjYyNXJlbTtmb250LXdlaWdodDo3MDB9Lm51bWJlci0tYmx1ZXtjb2xvcjp2YXIoLS1jYWxjaXRlLWNvbG9yLWJyYW5kKX0ubnVtYmVyLS1yZWR7Y29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci1zdGF0dXMtZGFuZ2VyKX0ubnVtYmVyLS1vcmFuZ2V7Y29sb3I6I2ZlNTgzZX0ubnVtYmVyIGNhbGNpdGUtaWNvbnttYXJnaW4taW5saW5lLWVuZDowLjI1cmVtO3ZlcnRpY2FsLWFsaWduOi0wLjI1cmVtfS5oZWFkZXJ7bWFyZ2luOjBweDtwYWRkaW5nLWJvdHRvbTowLjVyZW07Zm9udC1zaXplOjFyZW07Zm9udC13ZWlnaHQ6NTAwO2NvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItdGV4dC0xKX0udGV4dHttYXJnaW4tYm90dG9tOjAuMjVyZW07bWFyZ2luLXRvcDowcHg7ZGlzcGxheTpmbGV4O2ZvbnQtc2l6ZTowLjg3NXJlbTtjb2xvcjp2YXIoLS1jYWxjaXRlLWNvbG9yLXRleHQtMil9LnRleHQtLWxlZnR7ZmxleDoxIDEgYXV0b31cIjtcblxuY29uc3QgQXJjZ2lzQ3JlZGl0RXN0aW1hdGUgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFwaSA9IDQ7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25DcmVkaXRDb3N0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmF2YWlsYWJsZUNyZWRpdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2hvd1RvdGFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVkU3RyaW5ncyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdXBkYXRlVHJhbnNhY3Rpb25Db3N0KCkge1xuICAgICAgICB0aGlzLnJlcGxhY2VTdHJpbmdzKCk7XG4gICAgfVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICBjb25zdCBsb2NhbGUgPSBhd2FpdCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLmkxOG4gPSBsb2NhbGVbMF07XG4gICAgICAgIGF3YWl0IHRoaXMucmVwbGFjZVN0cmluZ3MoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVN0cmluZ3MoKSB7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25DcmVkaXRDb3N0LCBhdmFpbGFibGVDcmVkaXRzLCBpMThuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0geyBhcGk6IHRoaXMuYXBpLCB0eXBlOiBcImRlY2ltYWxcIiwgcGxhY2VzOiAyIH07XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IGF3YWl0IGZvcm1hdE51bWJlcihhdmFpbGFibGVDcmVkaXRzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbmVlZGVkID0gYXdhaXQgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uQ3JlZGl0Q29zdCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBlcmNlbnQgPSBhd2FpdCBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb25DcmVkaXRDb3N0IC8gYXZhaWxhYmxlQ3JlZGl0cywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyB0eXBlOiBcInBlcmNlbnRcIiB9KSk7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVkU3RyaW5ncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaTE4biksIHsgY3JlZGl0c0F2YWlsYWJsZTogaTE4bi5jcmVkaXRzQXZhaWxhYmxlLnJlcGxhY2UoXCIke2NyZWRpdHN9XCIsIGF2YWlsYWJsZSksIGNyZWRpdHNBdmFpbGFibGVDb2xvbjogaTE4bi5jcmVkaXRzQXZhaWxhYmxlQ29sb24ucmVwbGFjZShcIiR7Y3JlZGl0c31cIiwgYXZhaWxhYmxlKSwgY3JlZGl0c05lZWRlZENvbG9uOiBpMThuLmNyZWRpdHNOZWVkZWRDb2xvbi5yZXBsYWNlKFwiJHtjcmVkaXRzfVwiLCBuZWVkZWQpLCBjcmVkaXRzTmVlZGVkOiBpMThuLmNyZWRpdHNOZWVkZWQucmVwbGFjZShcIiR7Y3JlZGl0c31cIiwgbmVlZGVkKSwgY3JlZGl0c05lZWRlZFBlcmNlbnQ6IGkxOG4uY3JlZGl0c05lZWRlZFBlcmNlbnQucmVwbGFjZShcIiR7cGVyY2VudH1cIiwgcGVyY2VudCksIG5lZWRlZCxcbiAgICAgICAgICAgIHBlcmNlbnQgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZvcm1hdHRlZFN0cmluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25DcmVkaXRDb3N0LCBhdmFpbGFibGVDcmVkaXRzLCBzaG93VG90YWwsIGZvcm1hdHRlZFN0cmluZ3M6IGkxOG4sIGFwaSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY29sb3IgPSBnZXRNZXRlckNvbG9yKHRyYW5zYWN0aW9uQ3JlZGl0Q29zdCwgYXZhaWxhYmxlQ3JlZGl0cyk7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwibGVmdFwiIH0sIGgoXCJoNFwiLCB7IGNsYXNzOiBcImhlYWRlclwiIH0sIGkxOG4uY3JlZGl0RXN0aW1hdGUpLCBoKFwicFwiLCB7IGNsYXNzOiBcInRleHRcIiB9LCBoKFwic3BhblwiLCB7IGNsYXNzOiBcInRleHQtLWxlZnRcIiB9LCBpMThuLmNyZWRpdHNOZWVkZWRDb2xvbiksIHNob3dUb3RhbCAmJiBoKFwic3BhblwiLCBudWxsLCBpMThuLmNyZWRpdHNBdmFpbGFibGVDb2xvbikpLCBoKFwiYXJjZ2lzLW1ldGVyXCIsIHsgbWF4OiBhdmFpbGFibGVDcmVkaXRzLCBtYXhMYWJlbDogaTE4bi5ub3RFbm91Z2gsIGN1cnJlbnQ6IHRyYW5zYWN0aW9uQ3JlZGl0Q29zdCwgbWluOiAwLCBsYWJlbDogc2hvd1RvdGFsID8gaTE4bi5jcmVkaXRFc3RpbWF0ZSA6IGkxOG4uY3JlZGl0c05lZWRlZFBlcmNlbnQsIGFwaTogYXBpIH0pKSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInJpZ2h0XCIgfSwgaChcInNwYW5cIiwgeyBjbGFzczogYG51bWJlciBudW1iZXItLSR7Y29sb3J9YCB9LCBjb2xvciA9PT0gXCJyZWRcIiAmJiBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgaWNvbjogXCJleGNsYW1hdGlvbi1tYXJrLXRyaWFuZ2xlXCIgfSksIGkxOG4ubmVlZGVkKSwgaTE4bi5jcmVkaXRzTmVlZGVkKSkpO1xuICAgIH1cbiAgICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gICAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICAgICAgXCJ0cmFuc2FjdGlvbkNyZWRpdENvc3RcIjogW1widXBkYXRlVHJhbnNhY3Rpb25Db3N0XCJdLFxuICAgICAgICBcImF2YWlsYWJsZUNyZWRpdHNcIjogW1widXBkYXRlVHJhbnNhY3Rpb25Db3N0XCJdXG4gICAgfTsgfVxufTtcbkFyY2dpc0NyZWRpdEVzdGltYXRlLnN0eWxlID0gYXJjZ2lzQ3JlZGl0RXN0aW1hdGVDc3M7XG5cbmNvbnN0IGFyY2dpc1NlbGVjdENzcyA9IFwiOmhvc3R7cG9zaXRpb246cmVsYXRpdmV9LnNlbGVjdHttYXJnaW4tdG9wOjAuMjVyZW07bWFyZ2luLWJvdHRvbToxcmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5zZWxlY3QtLW5vLW1hcmdpbnttYXJnaW46MH0ubGFiZWx7Zm9udC1zaXplOjAuODc1cmVtO2NvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItdGV4dC0xKTtsaW5lLWhlaWdodDoxOHB4fS5sYWJlbC0tYm9sZHtmb250LXdlaWdodDo1MDB9LmRlc2NyaXB0aW9ue21hcmdpbi10b3A6MC41cmVtO21hcmdpbi1ib3R0b206MXJlbTtkaXNwbGF5OmJsb2NrO2ZvbnQtc2l6ZTowLjg3NXJlbTtmb250LXdlaWdodDo0MDA7Y29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci10ZXh0LTMpfS5sYXJnZXtmb250LXNpemU6MXJlbX0uZHJvcGRvd24tY29udGFpbmVye3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MHB4Oy0tdHctc2hhZG93OjAgNnB4IDIwcHggLTRweCByZ2JhKDAsIDAsIDAsIDAuMSksIDAgNHB4IDEycHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMDgpOy0tdHctc2hhZG93LWNvbG9yZWQ6MCA2cHggMjBweCAtNHB4IHZhcigtLXR3LXNoYWRvdy1jb2xvciksIDAgNHB4IDEycHggLTJweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO2JveC1zaGFkb3c6dmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTt3aWR0aDoxMDAlO3RvcDoxMDAlO21heC1oZWlnaHQ6MjQwcHg7b3ZlcmZsb3c6YXV0bzt6LWluZGV4OjEwMH1cIjtcblxuY29uc3QgQXJjZ2lzU2VsZWN0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNPcHRpb25DaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc09wdGlvbkNoYW5nZVwiLCA3KTtcbiAgICAgICAgdGhpcy5ndWlkID0gZ3VpZCgpO1xuICAgICAgICB0aGlzLmhhbmRsZUtleXMgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucywgc2VsZWN0ZWRJbmRleCwgc2VsZWN0T3Blbiwgc2VsZWN0ZWRPcHRpb24gfSA9IHRoaXM7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIgXCIgOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE9wZW4gPSAhdGhpcy5zZWxlY3RPcGVuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0T3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmNnaXNPcHRpb25DaGFuZ2UuZW1pdChvcHRpb25zW3NlbGVjdGVkSW5kZXhdLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0T3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdE9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAoc2VsZWN0ZWRJbmRleCArIDEpICUgb3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0T3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gb3B0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlRhYlwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0T3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gTWF0aC5tYXgob3B0aW9ucy5maW5kSW5kZXgoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlID09PSBzZWxlY3RlZE9wdGlvbiksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkVzY2FwZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBNYXRoLm1heChvcHRpb25zLmZpbmRJbmRleCgob3B0aW9uKSA9PiBvcHRpb24udmFsdWUgPT09IHNlbGVjdGVkT3B0aW9uKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0T3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRPcHRpb25SZWYuc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5kZXJPcHRpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tYXAoKHsgb3B0aW9uVGl0bGUsIGRlc2NyaXB0aW9uLCBpY29uLCBiYWRnZSwgdmFsdWUgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ZvY3VzZWRJbmRleCA9IGluZGV4ID09PSB0aGlzLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZE9wdGlvbiA9IHZhbHVlID09PSB0aGlzLnNlbGVjdGVkT3B0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiAoaChcImFyY2dpcy1vcHRpb25cIiwgeyBcImFyaWEtc2VsZWN0ZWRcIjogaXNTZWxlY3RlZE9wdGlvbiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiLCBzZWxlY3RlZDogaXNTZWxlY3RlZE9wdGlvbiwgYWN0aXZlOiBpc0ZvY3VzZWRJbmRleCwgb3B0aW9uVGl0bGU6IG9wdGlvblRpdGxlLCB2YWx1ZTogdmFsdWUsIGJhZGdlOiBiYWRnZSwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLCBpY29uOiBpY29uLCBhdXRvRm9jdXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0ZWRPcHRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdE9wZW4sIHNlbGVjdGVkT3B0aW9uLCBlbXB0eVRleHQsIG9wdGlvbnMsIGd1aWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IG9wdGlvbnMuZmluZCgob3B0aW9uKSA9PiBvcHRpb24udmFsdWUgPT09IHNlbGVjdGVkT3B0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiAoaChcImFyY2dpcy1vcHRpb25cIiwgeyBcImFyaWEtY29udHJvbHNcIjogYHNlbGVjdF8ke2d1aWR9YCwgXCJhcmlhLWxhYmVsbGVkYnlcIjogYGxhYmVsXyR7Z3VpZH1gLCBcImFyaWEtZXhwYW5kZWRcIjogc2VsZWN0T3BlbiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiLCBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiAoKF9hID0gb3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWUpIHx8IFwibm8tc2VsZWN0aW9uXCIsIGlzU2VsZWN0b3I6IHRydWUsIG9wdGlvblRpdGxlOiAoc2VsZWN0ZWQgPT09IG51bGwgfHwgc2VsZWN0ZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGVkLm9wdGlvblRpdGxlKSB8fCBlbXB0eVRleHQsIHZhbHVlOiAoc2VsZWN0ZWQgPT09IG51bGwgfHwgc2VsZWN0ZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGVkLnZhbHVlKSB8fCBcIlwiLCBkZXNjcmlwdGlvbjogKHNlbGVjdGVkID09PSBudWxsIHx8IHNlbGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZC5kZXNjcmlwdGlvbikgfHwgXCJcIiwgYmFkZ2U6IHNlbGVjdGVkID09PSBudWxsIHx8IHNlbGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZC5iYWRnZSwgaWNvbjogKHNlbGVjdGVkID09PSBudWxsIHx8IHNlbGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZC5pY29uKSB8fCBcIlwiLCByZWY6IChlbGUpID0+ICh0aGlzLmRlZmF1bHRPcHRpb25SZWYgPSBlbGUpLCBvbkFyY2dpc1NlbGVjdE9wZW46ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RPcGVuID0gIXRoaXMuc2VsZWN0T3BlbjtcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZWxlY3RPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvbiA9IFwiXCI7XG4gICAgICAgIHRoaXMuZW1wdHlUZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFiZWxEZXNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYWJlbFdlaWdodCA9IFwiYm9sZFwiO1xuICAgICAgICB0aGlzLmF1dG9Gb2N1cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mb2N1c0RlbGF5ID0gMDtcbiAgICB9XG4gICAgYXN5bmMgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgdGhpcy5vblNlbGVjdGVkT3B0aW9uQ2hhbmdlZCh0aGlzLnNlbGVjdGVkT3B0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0ZvY3VzICYmIHRoaXMuc2VsZWN0T3Blbikge1xuICAgICAgICAgICAgYXdhaXQgdGltZW91dCh0aGlzLmZvY3VzRGVsYXkpO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9uUmVmLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvblJlZi5zZXRGb2N1cygpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHN0ZW5jaWwvcHJlZmVyLXZkb20tbGlzdGVuZXJcbiAgICBjbG9zZU9uQmx1cigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RPcGVuID0gZmFsc2U7XG4gICAgfVxuICAgIG9uU2VsZWN0ZWRPcHRpb25DaGFuZ2VkKG5ld1NlbGVjdGVkT3B0aW9uKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbkluZGV4ID0gdGhpcy5vcHRpb25zLmZpbmRJbmRleCgob3B0aW9uKSA9PiBvcHRpb24udmFsdWUgPT09IG5ld1NlbGVjdGVkT3B0aW9uKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gTWF0aC5tYXgoMCwgb3B0aW9uSW5kZXgpO1xuICAgIH1cbiAgICBhc3luYyBhcmNnaXNPcHRpb25DaGFuZ2VIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnNlbGVjdE9wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9uUmVmLnNldEZvY3VzKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBsYWJlbCwgbGFiZWxEZXNjcmlwdGlvbiwgZ3VpZCwgc2VsZWN0T3BlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGFyZ2UgPSAhISh0aGlzLmxhYmVsICYmIHRoaXMubGFiZWxEZXNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwibGFiZWxcIiwgeyBpZDogYGxhYmVsXyR7Z3VpZH1gLCBjbGFzczogXCJsYWJlbFwiIH0sIGxhYmVsICYmIChoKFwic3BhblwiLCB7IGNsYXNzOiB7IGxhYmVsOiB0cnVlLCBcImxhYmVsLS1ib2xkXCI6IHRoaXMubGFiZWxXZWlnaHQgPT09IFwiYm9sZFwiLCBsYXJnZSB9IH0sIGxhYmVsLCBoKFwic2xvdFwiLCB7IG5hbWU6IFwiYWZ0ZXJMYWJlbFwiIH0pKSksIGxhYmVsRGVzY3JpcHRpb24gJiYgaChcInNwYW5cIiwgeyBjbGFzczogeyBkZXNjcmlwdGlvbjogdHJ1ZSwgbGFyZ2UgfSB9LCBsYWJlbERlc2NyaXB0aW9uKSksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJzZWxlY3RcIiwgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleXMgfSwgdGhpcy5yZW5kZXJTZWxlY3RlZE9wdGlvbigpLCBzZWxlY3RPcGVuICYmIChoKFwiZGl2XCIsIHsgcm9sZTogXCJsaXN0Ym94XCIsIFwiYXJpYS1oYXNwb3B1cFwiOiBcImxpc3Rib3hcIiwgaWQ6IGBzZWxlY3RfJHtndWlkfWAsIGNsYXNzOiBcImRyb3Bkb3duLWNvbnRhaW5lclwiIH0sIHRoaXMucmVuZGVyT3B0aW9ucygpKSkpKSk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICAgIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgICAgIFwic2VsZWN0ZWRPcHRpb25cIjogW1wib25TZWxlY3RlZE9wdGlvbkNoYW5nZWRcIl1cbiAgICB9OyB9XG59O1xuQXJjZ2lzU2VsZWN0LnN0eWxlID0gYXJjZ2lzU2VsZWN0Q3NzO1xuXG5leHBvcnQgeyBBcmNnaXNDcmVkaXRFc3RpbWF0ZSBhcyBhcmNnaXNfY3JlZGl0X2VzdGltYXRlLCBBcmNnaXNTZWxlY3QgYXMgYXJjZ2lzX3NlbGVjdCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtY3JlZGl0LWVzdGltYXRlXzIuZW50cnkuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIG4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgIGZ1bmN0aW9uIGZsdXNoKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZsdXNoZWRcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW52b2tlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgZGVib3VuY2VkLmludm9rZSA9IGludm9rZTtcbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgIGRlYm91bmNlZC5nZXRTdGF0dXMgPSBnZXRTdGF0dXM7XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIG4gbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtwcm9taXNlLCB0aW1lb3V0KG1pbkRlbGF5KV0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGlubGluZSBzZXRUaW1lb3V0IGFzIGFuIGF3YWl0IGluIGFzeW5jIGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gICAgY29uc3QgeyBrZXksIGRhdGEgfSA9IGdldEtleUFuZEl0ZW0oaXRlbSk7XG4gICAgcmV0dXJuIFtrZXksIGRhdGFdO1xufSkpO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcbiAqIGFuZCB3aGV0aGVyIHRoZXkgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50c1xuICogcmVnYXJkbGVzcyBvZiBvcmRlclxuICovXG5jb25zdCBhcnJheXNBcmVFcXVpdmFsZW50ID0gKGFycjEsIGFycjIpID0+IGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLnJlZHVjZSgobWVtbywgc3RyKSA9PiBtZW1vICYmIGFycjIuaW5kZXhPZihzdHIpID4gLTEsIHRydWUpO1xuZnVuY3Rpb24gdW5pcXVlQnkobXlBcnIsIGdldEl0ZW1JZCkge1xuICAgIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICAgIGNvbnN0IGxvb2t1cE1hcCA9IHt9O1xuICAgIG15QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZXRJdGVtSWQoaXRlbSk7XG4gICAgICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyO1xufVxuZnVuY3Rpb24gdW5pcXVlKG15QXJyKSB7XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IHsgYm9vbGVhbjoge30sIG51bWJlcjoge30sIHN0cmluZzoge30gfTtcbiAgICBjb25zdCBvYmpzID0gW107XG4gICAgcmV0dXJuIG15QXJyLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgICAgICBpZiAodHlwZSBpbiBwcmltaXRpdmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlc1t0eXBlXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSA/IGZhbHNlIDogKHByaW1pdGl2ZXNbdHlwZV1baXRlbV0gPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uYWwtNDRkZThmY2YuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUlkKGNvdW50cykge1xuICAgIHJldHVybiBjb3VudHNcbiAgICAgICAgLm1hcCgoY291bnQpID0+IHtcbiAgICAgICAgbGV0IG91dCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0ICs9ICgoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApIHwgMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pXG4gICAgICAgIC5qb2luKFwiLVwiKTtcbn1cbmNvbnN0IGd1aWQgPSAoKSA9PiBnZW5lcmF0ZUlkKFsyLCAxLCAxLCAxLCAzXSk7XG5cbmV4cG9ydCB7IGd1aWQgYXMgZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ndWlkLWFlYWVkODRkLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5cbmNvbnN0IGxhbmd1YWdlTWFwID0gbmV3IE1hcChbXG4gICAgW1wiYXJcIiwgXCJhclwiXSxcbiAgICBbXCJiZ1wiLCBcImJnXCJdLFxuICAgIFtcImJzXCIsIFwiYnNcIl0sXG4gICAgW1wiY2FcIiwgXCJjYVwiXSxcbiAgICBbXCJjc1wiLCBcImNzXCJdLFxuICAgIFtcImRhXCIsIFwiZGFcIl0sXG4gICAgW1wiZGVcIiwgXCJkZVwiXSxcbiAgICBbXCJlbFwiLCBcImVsXCJdLFxuICAgIFtcImVuXCIsIFwiZW5cIl0sXG4gICAgW1wiZXNcIiwgXCJlc1wiXSxcbiAgICBbXCJldFwiLCBcImV0XCJdLFxuICAgIFtcImZpXCIsIFwiZmlcIl0sXG4gICAgW1wiZnJcIiwgXCJmclwiXSxcbiAgICBbXCJoZVwiLCBcImhlXCJdLFxuICAgIFtcImhyXCIsIFwiaHJcIl0sXG4gICAgW1wiaHVcIiwgXCJodVwiXSxcbiAgICBbXCJpZFwiLCBcImlkXCJdLFxuICAgIFtcIml0XCIsIFwiaXRcIl0sXG4gICAgW1wiamFcIiwgXCJqYVwiXSxcbiAgICBbXCJrb1wiLCBcImtvXCJdLFxuICAgIFtcImx0XCIsIFwibHRcIl0sXG4gICAgW1wibHZcIiwgXCJsdlwiXSxcbiAgICBbXCJuYlwiLCBcIm5iXCJdLFxuICAgIFtcIm5sXCIsIFwibmxcIl0sXG4gICAgW1wicGxcIiwgXCJwbFwiXSxcbiAgICBbXCJwdC1iclwiLCBcInB0LUJSXCJdLFxuICAgIFtcInB0LXB0XCIsIFwicHQtUFRcIl0sXG4gICAgW1wicm9cIiwgXCJyb1wiXSxcbiAgICBbXCJydVwiLCBcInJ1XCJdLFxuICAgIFtcInNrXCIsIFwic2tcIl0sXG4gICAgW1wic2xcIiwgXCJzbFwiXSxcbiAgICBbXCJzclwiLCBcInNyXCJdLFxuICAgIFtcInN2XCIsIFwic3ZcIl0sXG4gICAgW1widGhcIiwgXCJ0aFwiXSxcbiAgICBbXCJ0clwiLCBcInRyXCJdLFxuICAgIFtcInVrXCIsIFwidWtcIl0sXG4gICAgW1widmlcIiwgXCJ2aVwiXSxcbiAgICBbXCJ6aC1jblwiLCBcInpoLUNOXCJdLFxuICAgIFtcInpoLWhrXCIsIFwiemgtSEtcIl0sXG4gICAgW1wiemgtdHdcIiwgXCJ6aC1UV1wiXVxuXSk7XG4vLyBydGxcbmZ1bmN0aW9uIGdldEVsZW1lbnREaXIoZWwpIHtcbiAgICByZXR1cm4gZ2V0RWxlbWVudFByb3AoZWwsIFwiZGlyXCIsIFwibHRyXCIpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFByb3AoZWwsIHByb3AsIHZhbHVlKSB7XG4gICAgY29uc3QgY2xvc2VzdFdpdGhQcm9wID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsLCBgWyR7cHJvcH1dYCk7XG4gICAgcmV0dXJuIGNsb3Nlc3RXaXRoUHJvcCA/IGNsb3Nlc3RXaXRoUHJvcC5nZXRBdHRyaWJ1dGUocHJvcCkgOiB2YWx1ZTtcbn1cbi8vIGNzc1xuY29uc3QgQ1NTX1VUSUxJVFkgPSB7XG4gICAgcnRsOiBcImFyY2dpcy0tcnRsXCJcbn07XG5hc3luYyBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtYmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcGksIHR5cGUsIHBsYWNlcyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoYXBpID09PSA0KSB7XG4gICAgICAgIGNvbnN0IFtpbnRsXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvaW50bFwiXSk7XG4gICAgICAgIGNvbnN0IG51bWJlckZvcm1hdEludGxPcHRpb25zID0gaW50bC5jb252ZXJ0TnVtYmVyRm9ybWF0VG9JbnRsT3B0aW9ucyh7XG4gICAgICAgICAgICBwbGFjZXMsXG4gICAgICAgICAgICBzdHlsZTogdHlwZSxcbiAgICAgICAgICAgIGRpZ2l0U2VwYXJhdG9yOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW50bC5mb3JtYXROdW1iZXIobnVtYmVyLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG51bWJlckZvcm1hdEludGxPcHRpb25zKSwgeyBzdHlsZTogdHlwZSB9KSk7XG4gICAgfVxuICAgIGNvbnN0IFtkb2pvTnVtYmVyXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImRvam8vbnVtYmVyXCJdKTtcbiAgICByZXR1cm4gZG9qb051bWJlci5mb3JtYXQobnVtYmVyLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBsYWNlcyxcbiAgICAgICAgcGF0dGVybjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhdHRlcm5cbiAgICB9KTtcbn1cbmNvbnN0IGNhY2hlID0ge307XG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgICBjb25zdCBsYW5nID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lmxhbmc7XG4gICAgY29uc3QgZGF5U2hvcnRNb250aFllYXIgPSB7XG4gICAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgICBtb250aDogXCJzaG9ydFwiLFxuICAgICAgICBkYXk6IFwibnVtZXJpY1wiXG4gICAgfTtcbiAgICBpZiAoIWNhY2hlW2xhbmddKSB7XG4gICAgICAgIGNhY2hlW2xhbmddID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcsIGRheVNob3J0TW9udGhZZWFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2xhbmddLmZvcm1hdChkYXRlKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFBsdXJhbChsYW5nLCBzdHJpbmdPYmosIG51bWJlcikge1xuICAgIGNvbnN0IHNpbmdsZXMgPSBbXCJpZFwiLCBcImphXCIsIFwia29cIiwgXCJ0aFwiLCBcInZpXCIsIFwiemgtY25cIiwgXCJ6aC1oa1wiLCBcInpoLXR3XCJdO1xuICAgIGNvbnN0IGxpa2VFbmdsaXNoID0gW1xuICAgICAgICBcImVuXCIsXG4gICAgICAgIFwiY2FcIixcbiAgICAgICAgXCJkYVwiLFxuICAgICAgICBcImRlXCIsXG4gICAgICAgIFwiZWxcIixcbiAgICAgICAgXCJlc1wiLFxuICAgICAgICBcImV0XCIsXG4gICAgICAgIFwiZmlcIixcbiAgICAgICAgXCJoaVwiLFxuICAgICAgICBcImh1XCIsXG4gICAgICAgIFwiaXRcIixcbiAgICAgICAgXCJuYlwiLFxuICAgICAgICBcIm5sXCIsXG4gICAgICAgIFwicHQtcHRcIixcbiAgICAgICAgXCJzdlwiLFxuICAgICAgICBcInRyXCJcbiAgICBdO1xuICAgIGNvbnN0IGxvY2FsZSA9IGxhbmcgIT09IG51bGwgJiYgbGFuZyAhPT0gdm9pZCAwID8gbGFuZyA6IFwiZW5cIjtcbiAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIG9uZSwgb3IgaXQgaXMgYSBcInNpbXBsZVwiIGxhbmd1YWdlLCByZXR1cm4gdGhlIDEgc3RyaW5nXG4gICAgaWYgKG51bWJlciA9PT0gMSB8fCBzaW5nbGVzLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ09iai5zaW5nbGUucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBcIjFcIik7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgbm90IDEgYW5kIHRoZSBsYW5ndWFnZSB1c2VzIHRoZSBzYW1lIHBsdXJhbGl6YXRpb24gc3RyYXRlZ3kgYXMgZW5nbGlzaCxcbiAgICAvLyByZXR1cm4gdGhlIG11bHRpcGxlIHN0cmluZ1xuICAgIGlmIChudW1iZXIgIT09IDEgJiYgbGlrZUVuZ2xpc2guaW5jbHVkZXMobG9jYWxlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nT2JqLm11bHRpcGxlLnJlcGxhY2UoXCIke251bWJlcn1cIiwgYCR7bnVtYmVyfWApO1xuICAgIH1cbiAgICAvLyBpZiBub25lIG9mIHRoZSBhYm92ZSB3b3JrZWQsIHJldHVybiB0aGUgXCJ1bmtub3duXCIgc3RyaW5nXG4gICAgcmV0dXJuIHN0cmluZ09iai51bmtub3duLnJlcGxhY2UoXCIke251bWJlcn1cIiwgYCR7bnVtYmVyfWApO1xufVxuXG5leHBvcnQgeyBDU1NfVVRJTElUWSBhcyBDLCBmb3JtYXREYXRlIGFzIGEsIGZvcm1hdFBsdXJhbCBhcyBiLCBmb3JtYXROdW1iZXIgYXMgZiwgZ2V0RWxlbWVudERpciBhcyBnLCBsYW5ndWFnZU1hcCBhcyBsIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tNGQzNjc2NzcuanMnO1xuaW1wb3J0IHsgbCBhcyBsYW5ndWFnZU1hcCB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCB7IGEgYXMgZ2V0QXNzZXRQYXRoIH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5cbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9zdGVuY2lsLXRyaWNrcy9pbXBsZW1lbnRpbmctaW50ZXJuYXRpb25hbGlzYXRpb24taTE4bi13aXRoLXN0ZW5jaWwtNWU2NTU5NTU0MTE3XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gXCJydS1SVVwiIG1hcHMgdG8gXCJydVwiIHVzZSBjYXNlXG4gICAgICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZy5zbGljZSgwLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlblwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgLy8gaXQncyBPSyBpZiB3ZSBkb24ndCBoYXZlIHRoZSA0IGxldHRlciBsYW5ndWFnZSBmaWxlIGZvciBpdFxuICAgIC8vIDQgbGV0dGVyIGxhbmd1YWdlIGNvZGUgbmVlZGVkIGZvciBmb3JtYXR0aW5nIG51bWJlcnNcbiAgICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgICAgICAgIC8vIHdlIHN1cHBvcnQgdGhlIDIgbGV0dGVyIGNvZGVkIGxhbmd1YWdlXG4gICAgICAgICAgICAvLyBlLmcuIGl0LUNIIHZzIGl0XG4gICAgICAgICAgICByZXR1cm4gbGFuZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZmV0Y2goZ2V0QXNzZXRQYXRoKGAuLi9hcmNnaXMtYXBwLWFzc2V0cy9pMThuLyR7Y29tcG9uZW50TmFtZX0uaTE4bi4ke2xvY2FsZX0uanNvbmApKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQub2spXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQuanNvbigpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSwgKCkgPT4gcmVqZWN0KCkpO1xuICAgIH0pO1xufVxuY29uc3Qgc3RyaW5nQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICBjb25zdCBpZCA9IGAke2NvbXBvbmVudE5hbWV9JHtsb2NhbGV9YDtcbiAgICBpZiAoIXN0cmluZ0NhY2hlW2lkXSkge1xuICAgICAgICBzdHJpbmdDYWNoZVtpZF0gPSBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ0NhY2hlW2lkXTtcbn1cbi8qKlxuICogR2V0IHN0cmluZ3MgYW5kIGxhbmd1YWdlIGNvZGVzLlxuICogVGhpcyBtZXRob2QgcmV0dXJucyAyIGxhbmd1YWdlIGNvZGVzLlxuICogVGhlIGZpcnN0IG9uZSByZXR1cm5zIGEgY29kZSB0aGF0J3MgYWxzbyBzdXBwb3J0ZWQgYXMgYSBsYW5ndWFnZSBmaWxlLlxuICogVGhlIHNlY29uZCBvbmUgcmV0dXJucyBhIGNvZGUgd2hlcmUgdGhlcmUgaXMgc3VwcG9ydCBmb3IgdGhlIGZpcnN0IDIgbGV0dGVycyBvZiB0aGUgY29kZSBhcyBwYXJ0IG9mIGEgbGFuZ3VhZ2UgZmlsZSxcbiAqIGJ1dCB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgNCBsZXR0ZXIgY29kZSBmcm9tIHRoZSBwYWdlLlxuICogRS5nLiBGb3IgXCJpdC1jaFwiIGl0IHdpbGwgcmV0dXJuIFwiaXRcIiBhcyB0aGUgZmlyc3QgbGFuZ3VhZ2UgY29kZSBhbmQgXCJpdC1jaFwiIGFzIHRoZSBzZWNvbmQuXG4gKiBUaGUgc2Vjb25kIG9uZSBpcyByZXF1aXJlZCBmb3IgZXNyaS5pbnRsLnNldExvY2FsZSgpIHRvIGdldCB0aGUgY29ycmVjdCBmb3JtYXR0aW5nLlxuICpcbiAqIElmIGEgdGFnTmFtZSBpcyBwcm92aWRlZCBpdCB3aWxsIG92ZXJ3aXRlIHRoZSBlbGVtZW50J3MgdGFnTmFtZVxuICpcbiAqICBAcmV0dXJuIFsgc3RyaW5ncywgZmlyc3QgbGFuZ3VhZ2UgY29kZSwgc2Vjb25kIGxhbmd1YWdlIGNvZGVdXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MoZWxlbWVudCwgdGFnTmFtZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB0YWdOYW1lIHx8IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpO1xuICAgIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlSW50bCA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCk7XG4gICAgbGV0IHN0cmluZ3M7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBjb21wb25lbnRMYW5ndWFnZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgbm8gbG9jYWxlIGZvciAke2NvbXBvbmVudE5hbWV9ICgke2NvbXBvbmVudExhbmd1YWdlfSkgbG9hZGluZyBkZWZhdWx0IGxvY2FsZSBlbi5gKTtcbiAgICAgICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBcImVuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW3N0cmluZ3MsIGNvbXBvbmVudExhbmd1YWdlLCBjb21wb25lbnRMYW5ndWFnZUludGxdO1xufVxuXG5leHBvcnQgeyBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UgYXMgYSwgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsZS0wNTBiNmRiOS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmZ1bmN0aW9uIGdldE1ldGVyQ29sb3IoY3VycmVudCwgbWF4KSB7XG4gICAgY29uc3QgcGVyY2VudCA9IGN1cnJlbnQgLyBtYXg7XG4gICAgaWYgKHBlcmNlbnQgPj0gMSB8fCBwZXJjZW50IDwgMCkge1xuICAgICAgICByZXR1cm4gXCJyZWRcIjtcbiAgICB9XG4gICAgaWYgKHBlcmNlbnQgPiAwLjgpIHtcbiAgICAgICAgcmV0dXJuIFwib3JhbmdlXCI7XG4gICAgfVxuICAgIHJldHVybiBcImJsdWVcIjtcbn1cblxuZXhwb3J0IHsgZ2V0TWV0ZXJDb2xvciBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwtMjFkYzJhYzUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9